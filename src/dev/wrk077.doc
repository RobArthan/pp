=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex
\def\Slrp{{\bf SLRP}}
\def\Hide#1{\relax}

%%%%% YOU WILL USUALLY WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{ A {\Slrp} Parser for Full ANSI-C }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document gives a grammar for ANSI-C together with the supporting code to form a
fairly complete parser for the full ANSI-C language.}
\end{center}}

\def\Reference{LEMMA1/DEV/WRK077}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.3 $%
}
\def\Date{\FormatDate{$Date: 2006/10/07 13:16:49 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1] First draft.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

As determined by experience with the template.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}
\begin{center}
\begin{tabular}{ll}
Lemma 1 Development Library
\end{tabular}
\end{center}


\newpage

%%%%% NOW THE CREATIVE BIT:

\section{Introduction}
\subsection{Scope}
This document is part of some preparatory work on the C language.

\subsection{Purpose and Background}
This document is part of the {\Slrp} test suite and also provides an example of
various techniques of interest to users of {\Slrp}.

\subsection{Overview}
This document provides a grammar in the {\Slrp} format that can support the full C language.
I.e., unlike the grammar of \cite{LEMMA1/DEV/WRK063}, this grammar caters for the numerous
rather obscure consequences of the definitions of C, for example, the rule that says structure member names are in a separate namespace .

=TEX
\section{THE GRAMMAR} \label{GRAMMAR}
Our starting point is the reference grammar given in \cite{LEMMA1/DEV/WRK063}
which is itself based on the 1990 standard \cite{ansi90} and the grammar given in.

The following records the various changes that have been made to the grammar of \cite{LEMMA1/DEV/WRK063}.

\begin{itemize}
\item
Introduce a new non-terminal  identifier\_or\_typedef\_name for
use in situations such as statement labels where either an identifier or a typedef name is allowed.
Use this as appropriate wherever it does not cause LALR(1) conflicts (which is everywhere except in a direct\_declarator).
\item
* Change declaration\_list into declaration\_list\_opt allowing empty lists, and exploit this to abbreviate the productions that use it.
Similarly for init\_declarator\_list.
Do the gcc trick, which amounts to this:
\begin{itemize}
\item
Add a new non-terminal type\_declarator which is like declarator but having a typedef name as the name being declared.
Similarly add init\_type\_declarator\_list, struct\_type\_declarator\_list etc.
Change declaration\_specifiers to require at least one type specifier and at most one typedef name, and add a new non-terminal declaration\_modifiers for a sequence of storage class specifiers and type qualifiers (i.e., what would have been a declaration\_specifiers with no type specifiers).
This gives a new case in the production for declaration and then it is safe to add a further alternative allowing an init\_type\_declarator after a declaration\_specifiers.
\item
Similarly change specifier\_qualifier list to require at least one type specifier and at most one typedef name and so add an alternative allowing a struct\_type\_declarator\_list after a specifier\_qualifier list.
\end{itemize}
\end{itemize}

\subsection{Translation Units}
=DUMP wrk077.grm.txt
€translation_unit›
	= external_declaration
	| translation_unit, external_declaration
	;
=TEX
=DUMPMORE wrk077.grm.txt
€external_declaration›
	= function_definition
	| declaration
	;
=TEX
=DUMPMORE wrk077.grm.txt
€function_definition›
	= declarator, declaration_list_opt, compound_statement
	| declaration_specifiers, declarator, declaration_list_opt, compound_statement
	;
=TEX
\subsection{Declarations}

=TEX
=DUMPMORE wrk077.grm.txt
€declaration›
	= declaration_modifiers, init_declarator_list_opt, `;`
	| declaration_specifiers, init_declarator_list_opt, `;`
	| declaration_specifiers, init_type_declarator_list, `;`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€declaration_list_opt›
	=
	| declaration_list_opt, declaration
	;
=TEX
=DUMPMORE wrk077.grm.txt
€declaration_modifiers›
	= storage_class_specifier
	| storage_class_specifier, declaration_modifiers
	| type_qualifier
	| type_qualifier, declaration_modifiers
	;
=TEX
=DUMPMORE wrk077.grm.txt
€declaration_specifiers›
	= type_specifier, reserved_declaration_specifiers
	| declaration_modifiers, type_specifier, reserved_declaration_specifiers
	;
=DUMPMORE wrk077.grm.txt
€reserved_declaration_specifiers›
	=
	| reserved_declaration_specifiers, reserved_type_specifier
	| reserved_declaration_specifiers, type_qualifier
	| reserved_declaration_specifiers, storage_class_specifier
	;
=TEX
=DUMPMORE wrk077.grm.txt
€storage_class_specifier›
	= `auto`
	| `register`
	| `static`
	| `extern`
	| `typedef`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€reserved_type_specifier›
	= `void`
	| `char`
	| `short`
	| `int`
	| `long`
	| `float`
	| `double`
	| `signed`
	| `unsigned`
	| struct_or_union_specifier
	| enum_specifier
	;
=TEX
=DUMPMORE wrk077.grm.txt
€type_specifier›
	= reserved_type_specifier
	| typedef_name
	;
=TEX
=DUMPMORE wrk077.grm.txt
€type_qualifier›
	= `const`
	| `volatile`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€struct_or_union_specifier›
	= struct_or_union, `{`, struct_declaration_list, `}`
	| struct_or_union, identifier_or_typedef_name, `{`, struct_declaration_list, `}`
	| struct_or_union, identifier_or_typedef_name
	;
=TEX
=DUMPMORE wrk077.grm.txt
€struct_or_union›
	= `struct`
	| `union`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€struct_declaration_list›
	= struct_declaration
	| struct_declaration_list, struct_declaration
	;
=TEX
=DUMPMORE wrk077.grm.txt
€init_declarator_list_opt›
	= 
	| init_declarator_list
	;
=TEX
=DUMPMORE wrk077.grm.txt
€init_declarator_list›
	= init_declarator
	| init_declarator_list, `,`, init_declarator
	| init_declarator_list, `,`, init_type_declarator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€init_type_declarator_list›
	= init_type_declarator
	| init_type_declarator_list, `,`, init_declarator
	| init_type_declarator_list, `,`, init_type_declarator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€init_declarator›
	= declarator
	| declarator, `=`, initializer
	;
=TEX
=DUMPMORE wrk077.grm.txt
€init_type_declarator›
	= type_declarator
	| type_declarator, `=`, initializer
	;
=TEX
=TEX
=DUMPMORE wrk077.grm.txt
€struct_declaration›
	= qualifier_list, struct_declarator_list, `;`
	| specifier_qualifier_list, struct_declarator_list, `;`
	| specifier_qualifier_list, struct_type_declarator_list, `;`
	;
=TEX
=DUMPMORE decl.grm.txt
€specifier_qualifier_list›
	= type_specifier
	| type_specifier, specifier_qualifier_list
	| type_qualifier
	| type_qualifier, specifier_qualifier_list
	;
=TEX
=DUMPMORE wrk077.grm.txt
€qualifier_list›
	= type_qualifier
	| type_qualifier, declaration_modifiers
	;
=TEX
=DUMPMORE wrk077.grm.txt
€specifier_qualifier_list›
	= type_specifier, reserved_specifier_qualifiers
	| qualifier_list, type_specifier, reserved_specifier_qualifiers
	;
=DUMPMORE wrk077.grm.txt
€reserved_specifier_qualifiers›
	=
	| reserved_specifier_qualifiers, reserved_type_specifier
	| reserved_specifier_qualifiers, type_qualifier
	;
=TEX
=DUMPMORE wrk077.grm.txt
€struct_declarator_list›
	= struct_declarator
	| struct_declarator_list, `,`, struct_declarator
	| struct_declarator_list, `,`, struct_type_declarator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€struct_type_declarator_list›
	= struct_type_declarator
	| struct_type_declarator_list, `,`, struct_type_declarator
	| struct_type_declarator_list, `,`, struct_declarator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€struct_declarator›
	= declarator
	| `:`, constant_expression
	| declarator, `:`, constant_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€struct_type_declarator›
	= type_declarator
	| type_declarator, `:`, constant_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€enum_specifier›
	= `enum`, `{`, enumerator_list, `}`
	| `enum`, identifier_or_typedef_name, `{`, enumerator_list, `}`
	| `enum`, identifier_or_typedef_name
	;
=TEX
=DUMPMORE wrk077.grm.txt
€enumerator_list›
	= enumerator
	| enumerator_list, `,`, enumerator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€enumerator›
	= identifier_or_typedef_name
	| identifier_or_typedef_name, `=`, constant_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€declarator›
	= direct_declarator
	| pointer, direct_declarator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€type_declarator›
	= type_direct_declarator
	| pointer, type_direct_declarator
	;
=TEX
In the following note that there is just one identifier or typedef\_name at the
heart of the declarator (i.e., the name the declarator, declares).
The distinction between identifier or typedef\_name declarators then ripples up through the grammar.
=DUMPMORE wrk077.grm.txt
€direct_declarator›
	= identifier
	| `(`, declarator, `)`
	| direct_declarator, `[`, `]`
	| direct_declarator, `[`, constant_expression, `]`
	| direct_declarator, `(`, `)`
	| direct_declarator, `(`, parameter_type_list, `)`
	| direct_declarator, `(`, identifier_list, `)`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€type_direct_declarator›
	= typedef_name
	| `(`, type_declarator, `)`
	| type_direct_declarator, `[`, `]`
	| type_direct_declarator, `[`, constant_expression, `]`
	| type_direct_declarator, `(`, `)`
	| type_direct_declarator, `(`, parameter_type_list, `)`
	| type_direct_declarator, `(`, identifier_list, `)`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€pointer›
	= `*`
	| `*`, type_qualifier_list
	| `*`, pointer
	| `*`, type_qualifier_list, pointer
	;
=TEX
=DUMPMORE wrk077.grm.txt
€type_qualifier_list›
	= type_qualifier
	| type_qualifier_list, type_qualifier
	;
=TEX
=DUMPMORE wrk077.grm.txt
€parameter_type_list›
	= parameter_list
	| parameter_list, `,`, `...`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€parameter_list›
	= parameter_declaration
	| parameter_list, `,`, parameter_declaration
	;
=TEX
=DUMPMORE wrk077.grm.txt
€parameter_declaration›
	= declaration_specifiers, declarator
	| declaration_specifiers
	| declaration_specifiers, abstract_declarator
	;
=TEX
The following production is only used for old style formal parameter lists, in which {\tt typedef} names are (following {\tt gcc} at least) not to be treated as identifiers.
=DUMPMORE wrk077.grm.txt
€identifier_list›
	= identifier
	| identifier_list, `,`, identifier
	;
=TEX
=DUMPMORE wrk077.grm.txt
€initializer›
	= assignment_expression
	| `{`, initializer_list, `}`
	| `{`, initializer_list, `,`, `}`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€initializer_list›
	= initializer
	| initializer_list, `,`, initializer
	;
=TEX
=DUMPMORE wrk077.grm.txt
€type_name›
	= qualifier_list
	| qualifier_list, abstract_declarator
	| specifier_qualifier_list
	| specifier_qualifier_list, abstract_declarator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€abstract_declarator›
	= pointer
	| direct_abstract_declarator
	| pointer, direct_abstract_declarator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€direct_abstract_declarator›
	= `(`, abstract_declarator, `)`
	| `[`, `]`
	| `[`, constant_expression, `]`
	| direct_abstract_declarator, `[`, `]`
	| direct_abstract_declarator, `[`, constant_expression, `]`
	| `(`, `)`
	| `(`, parameter_type_list, `)`
	| direct_abstract_declarator, `(`, `)`
	| direct_abstract_declarator, `(`, parameter_type_list, `)`
	;
=TEX
The production for {\it typedef\_name} has to be modified, since the grammar becomes ambiguous
if typedef names cannot be distinugished from other names. E.g., to decide whether the
expression ``{\tt(X)(x)}'' is a cast or a function call, one needs to know whether ``{\tt X}''
denotes a type.
=DUMPMORE wrk077.grm.txt
€typedef_name› =
	TypeDefName;
=TEX
However, the C name space rules imply that there a {\tt typedef} name may be used as an identifier in several places, e.g., as a structure tag.
Where it does not introduce LALR(1) conflicts, we use the following production to achieve this:
=DUMPMORE wrk077.grm.txt
€identifier_or_typedef_name›
	= identifier
	| typedef_name
	;
=TEX
\subsection{Statements}
=DUMPMORE wrk077.grm.txt
€statement›
	= labeled_statement
	| compound_statement
	| expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	;
=TEX
=DUMPMORE wrk077.grm.txt
€labeled_statement›
	= identifier_or_typedef_name, `:`, statement
	| `case`, constant_expression, `:`, statement
	| `default`, `:`, statement
	;
=TEX
=DUMPMORE wrk077.grm.txt
€compound_statement›
	= `{`, declaration_list_opt, `}`
	| `{`, declaration_list_opt, statement_list, `}`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€statement_list›
	= statement
	| statement_list, statement
	;
=TEX
=DUMPMORE wrk077.grm.txt
€expression_statement›
	= `;`
	| expression, `;`
	;
=TEX
This is where the shift/reduce conflict arises. The statement ``{\tt if(a) if(b) f(); else g();}''
can be parsed so that the else-part belongs to the inner if-statement or the outer one
according to the following grammar. The resolution is that it should belong to the
inner if-statement, i.e., reduce.
=DUMPMORE wrk077.grm.txt
€selection_statement›
	= `if`, `(`, expression, `)`, statement
	| `if`, `(`, expression, `)`, statement, `else`, statement
	| `switch`, `(`, expression, `)`, statement
	;
=TEX
To avoid 7 extra cases in the following, we introduce a new production for an optional expression.
=DUMPMORE wrk077.grm.txt
€iteration_statement›
	= `while`, `(`, expression, `)`, statement
	| `do`, statement, `while`, `(`, expression, `)`, `;`
	| `for`, `(`, expression_opt, `;`, expression_opt, `;`, expression_opt, `)`,
	  statement
	;
=TEX
=DUMPMORE wrk077.grm.txt
€expression_opt›
	=
	| expression;
=TEX
=DUMPMORE wrk077.grm.txt
€jump_statement›
	= `goto`, identifier_or_typedef_name, `;`
	| `continue`, `;`
	| `break`, `;`
	| `return`, expression_opt, `;`
	;
=TEX
\subsection{Expressions}

=DUMPMORE wrk077.grm.txt
€expression›
	= assignment_expression
	| expression, `,`, assignment_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
=TEX
=DUMPMORE wrk077.grm.txt
€assignment_expression›
	= conditional_expression
	| unary_expression, assignment_operator, assignment_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€assignment_operator›
	= `=`
	| `*=`
	| `/=`
	| `%=`
	| `+=`
	| `-=`
	| `<<=`
	| `>>=`
	| `&=`
	| `^=`
	| `|=`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€conditional_expression›
	= logical_or_expression
	| logical_or_expression, `?`, expression, `:`, conditional_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€constant_expression›
	= conditional_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€logical_or_expression›
	= logical_and_expression
	| logical_or_expression, `||`, logical_and_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€logical_and_expression›
	= inclusive_or_expression
	| logical_and_expression, `&&`, inclusive_or_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€inclusive_or_expression›
	= exclusive_or_expression
	| inclusive_or_expression, `|`, exclusive_or_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€exclusive_or_expression›
	= and_expression
	| exclusive_or_expression, `^`, and_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€and_expression›
	= equality_expression
	| and_expression, `&`, equality_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€equality_expression›
	= relational_expression
	| equality_expression, `==`, relational_expression
	| equality_expression, `!=`, relational_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€relational_expression›
	= shift_expression
	| relational_expression, `<`, shift_expression
	| relational_expression, `>`, shift_expression
	| relational_expression, `<=`, shift_expression
	| relational_expression, `>=`, shift_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€shift_expression›
	= additive_expression
	| shift_expression, `<<`, additive_expression
	| shift_expression, `>>`, additive_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€additive_expression›
	= multiplicative_expression
	| additive_expression, `+`, multiplicative_expression
	| additive_expression, `-`, multiplicative_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€multiplicative_expression›
	= cast_expression
	| multiplicative_expression, `*`, cast_expression
	| multiplicative_expression, `/`, cast_expression
	| multiplicative_expression, `%`, cast_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€cast_expression›
	= unary_expression
	| `(`, type_name, `)`, cast_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€unary_expression›
	= postfix_expression
	| `++`, unary_expression
	| `--`, unary_expression
	| unary_operator, cast_expression
	| `sizeof`, unary_expression
	| `sizeof`, `(`, type_name, `)`
	;
€unary_operator›
	= `&`
	| `*`
	| `+`
	| `-`
	| `~`
	| `!`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€postfix_expression›
	= primary_expression
	| postfix_expression, `[`, expression, `]`
	| postfix_expression, `(`, `)`
	| postfix_expression, `(`, argument_expression_list, `)`
	| postfix_expression, `.`, identifier_or_typedef_name
	| postfix_expression, `->`, identifier_or_typedef_name
	| postfix_expression, `++`
	| postfix_expression, `--`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€primary_expression›
	= identifier
	| constant
	| string
	| `(`, expression, `)`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€argument_expression_list›
	= assignment_expression
	| argument_expression_list, `,`, assignment_expression
	;
=TEX
We leave enumeration constants out of the following list, on the grounds that a practical parser
would more likely treat them as identifiers during lexical analysis. The distinction between
enumeration constants and other identifiers does not affect the parsing.
=DUMPMORE wrk077.grm.txt
€constant›
	= IntegerConstant
	| CharacterConstant
	| FloatingConstant
	;
=TEX
We add productions for {\it string} and identifier just to keep the naming scheme uniform.
=DUMPMORE wrk077.grm.txt
€string›
	= String
	;
=DUMPMORE wrk077.grm.txt
€identifier›
	= Identifier
	;
=TEX
=SH
slrp -g -l 2  -f wrk077.grm.txt >wrk077.grm.run
=TEX
\newpage
\section{INDEX}
\small
\printindex
\end{document}


=IGN
