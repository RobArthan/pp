=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex
\def\Slrp{{\bf SLRP}}
\def\Hide#1{\relax}

%%%%% YOU WILL USUALLY WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{ A {\Slrp} Parser for Full ANSI-C }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document gives a grammar for ANSI-C together with the supporting code to form a
fairly complete parser for the full ANSI-C language.}
\end{center}}

\def\Reference{LEMMA1/DEV/WRK077}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.6 $%
}
\def\Date{\FormatDate{$Date: 2006/10/17 16:48:05 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1] First draft.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

Parser code to be added.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}
\begin{center}
\begin{tabular}{ll}
Lemma 1 Development Library
\end{tabular}
\end{center}


\newpage

%%%%% NOW THE CREATIVE BIT:

\section{Introduction}
\subsection{Scope}
This document is part of the {\Slrp} test suite.

\subsection{Purpose and Background}
This document is part of the {\Slrp} test suite and also provides an example of
various techniques of interest to users of {\Slrp}.

\subsection{Overview}
This document provides a grammar in the {\Slrp} format that can support the full C language.
I.e., unlike the grammar of \cite{LEMMA1/DEV/WRK063}, this grammar caters for the numerous
rather obscure consequences of the definitions of C, for example, the rule that says structure member names are in a separate namespace.

=TEX
\section{THE GRAMMAR} \label{GRAMMAR}
Our starting point is the reference grammar given in \cite{LEMMA1/DEV/WRK063}
which is itself based on the 1990 standard \cite{ansi90} and the grammar given in
\cite{Kernighan88}.
Note that all of these grammars leave some essentially syntactic issues unspecified, 
i.e., they expect some syntax errors to be detected after parsing.
For example, the declarator at the beginning of a function definition must contain a parameter list, but none of the grammars captures this constraint.

There are two main problems with the reference grammar of \cite{LEMMA1/DEV/WRK063}:

\begin{enumerate}
\item
The grannar as presented effectively assumes that {\tt typedef} names
comprise a distinguished subset of the set of identifers.
This means that ther declarations must be analysed as they are encountered to maintain a timely record of what names are {\tt typedef} names.
For example, to parse  `{\tt typedef int I; I i;}' properly according to the reference grammar,
one must take the first `{\tt I}' as an {\em identifier} and the second `{\tt I}' as a {\em typedef\_name}.
\item
The kind of problem pointed out in example 3 of section 6.5.6 of \cite{ansi90}, whereby {\tt typedef} names may be redeclared in inner scopes.
This leads to some oddities as in the following example:
{\small
\begin{verbatim}
    typedef int I, J;
    void f(void)
    {
        I I;               /* legal - declares a variable I */
        J;                 /* legal but useless, declares nothing */
        struct {
            int J:4;       /* bitfield: type `int'; width 4; name J */
            const J:5;     /* bitfield: type `const J'; width 5; nameless */
            J j:6;         /* bitfield: type `J'; width 6; name j */
        } x;
     }
\end{verbatim}}
\end{enumerate}

The solution to the first problem is fairly straightforward: one must simply ensure that the parsing action functions are called at the appropriate time to process declarations maintaining a record of which names are currently {\tt typedef} names.
This needs to be take into account the C scope rules: in particular, it must
take into account section 6.2.1 of \cite{ansi90}: {\em each enumeration constant has scope that begins
just after its defining enumerator \ldots Any other identifier has scope that begins just after
the completion of its declarator.}

The solution to the second problem is more complicated: we adopt a trick that goes back to early versions of the {\tt gcc} compiler\footnote{Recent versions of {|tt gcc} use a hand-coded recursive descent parser for C and C++.}.
The {\tt gcc} trick exploits the following points from \cite{ansi90}:
\begin{description}
\item[6.7.1] {\it If the declarator includes an identifier list, \ldots. An identifier declared as
a {\tt typedef name} shall not be redecared as a parameter.}

(This is taken to apply to all declarators, not just those in function definitions. It means that an old-style parameter list can't redefine a {\tt typedef} name.)
\item[6.5.6] {\it If the identifier is redeclared in an inner scope or is declared as a member of a structure or union in the same or an inner scope, the type specifiers shall not be omitted in the inner declaration.}
\item[6.5.2] {\em Each list of type specifiers shall be one of the following sets \ldots}

(The list implies that the type specifier part of a declaration can contain at most one {\tt typedef} name and that {\tt typedef} name cannot be mixed with other kinds of type specifier so that the second `{\tt I}' in the declaration `{\tt I I;}' above must be a declarator and cannot be a type specifier.)
\end{description}

The following records the various changes that have been made to the grammar of \cite{LEMMA1/DEV/WRK063}.
If the changes are made incrementally, then, at each stage, the only LALR(1) conflict is the shift/reduce conflict caused by the dangling else problem.

\begin{itemize}
\item
Introduce a new non-terminal  {\em identifier\_or\_typedef\_name} for
use in situations such as statement labels where either an identifier or a typedef name is allowed.
Use this as appropriate wherever it does not cause LALR(1) conflicts (which is everywhere except in a {\em direct\_declarator}).
\item
Change {\em declaration\_list} into {\em declaration\_list\_opt} allowing empty lists, and exploit this to abbreviate the productions that use it.
Similarly for {\em init\_declarator\_list} and {\em identifier\_list}.
\item
Do the gcc trick, which applies to the three different types of declarations as follows:
\begin{description}
\item[Variable and constant declarations:]
add a new non-terminal {\em type\_declarator} which is like {\em declarator} but having a typedef name as the name being declared.
Similarly add {\em init\_type\_declarator\_list}, {\em struct\_type\_declarator\_list} etc.
Change {\em declaration\_specifiers} to have at least one type specifier and at most one typedef name, and add a new non-terminal {\em declaration\_modifiers} for a sequence of storage class specifiers and type qualifiers (i.e., what would have been a {\em declaration\_specifiers} with no type specifiers).
Add a new production {\em declaration\_modifiers} to represent what was previously a {\em declaration\_specifiers} with no type specifiers.
This gives a new case in the production for {\em declaration} and then it becomes safe to add a further alternative allowing an {\em init\_type\_declarator} after a {\em declaration\_specifiers}.
\item[Structure and union member declarations:]
change {\em specifier\_qualifier\_list} to have at least one type specifier and at most one {\em typedef\_name} and so add an alternative allowing a {\em struct\_type\_declarator\_list} after a {\em specifier\_qualifier} list in a {\em struct\_declaration}.
\item
\item[Parameter declarations:]
Add new non-terminals {\em parameter\_direct\_declarator} and {\em parameter\_declarator}.
{\em parameter\_direct\_declarator} is the union of {\em direct\_declarator}, {\em type\_direct\_declarator} and {\em direct\_abstract\_declarator} expressed in a separate recursion to avoid LALR(1) conflicts.
Use {\em parameter\_declarator} in {\em parameter\_declaration} in place of the separate alternatives for {\em declarator} and {\em abstract\_declarator}.
\end{description}
\item
Add in new non-terminals, {\em do\_begin\_members} etc. at the points in the syntax where an action function needs to be invoked, see section~\ref{actions} below.
Each of these non-terminals had a name beginning `{\em do\_}' and generates an empty language.
\end{itemize}

[Remark: The 1999 revision of the C standard, \cite{ansi99}, requires a type specifier in
each of the three sorts of declaration, and so the non-terminals {\em declaration\_specifiers}
and {\em specification\_qualifier\_list} as modified here are what is required in C99.]

\subsection{Translation Units}
=DUMP wrk077.grm.txt
€translation_unit›
	= external_declaration
	| translation_unit, external_declaration
	;
=TEX
=DUMPMORE wrk077.grm.txt
€external_declaration›
	= function_definition
	| declaration
	;
=TEX
=DUMPMORE wrk077.grm.txt
€function_definition›
	= declarator, declaration_list_opt, compound_statement
	| declaration_specifiers, declarator, declaration_list_opt, compound_statement
	;
=TEX
\subsection{Declarations}

=TEX
=DUMPMORE wrk077.grm.txt
€declaration›
	= declaration_modifiers, init_declarator_list_opt, do_end_declaration, `;`
	| declaration_specifiers, init_declarator_list_opt, do_end_declaration, `;`
	| declaration_specifiers, init_type_declarator_list, do_end_declaration, `;`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€declaration_list_opt›
	=
	| declaration_list_opt, declaration
	;
=TEX
=DUMPMORE wrk077.grm.txt
€declaration_modifiers›
	= storage_class_specifier
	| storage_class_specifier, declaration_modifiers
	| type_qualifier
	| type_qualifier, declaration_modifiers
	;
=TEX
=DUMPMORE wrk077.grm.txt
€declaration_specifiers›
	= type_specifier, reserved_declaration_specifiers
	| declaration_modifiers, type_specifier, reserved_declaration_specifiers
	;
=TEX
=DUMPMORE wrk077.grm.txt
€reserved_declaration_specifiers›
	=
	| reserved_declaration_specifiers, reserved_type_specifier
	| reserved_declaration_specifiers, type_qualifier
	| reserved_declaration_specifiers, storage_class_specifier
	;
=TEX
=DUMPMORE wrk077.grm.txt
€storage_class_specifier›
	= `auto`
	| `register`
	| `static`
	| `extern`
	| do_typedef, `typedef`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€reserved_type_specifier›
	= `void`
	| `char`
	| `short`
	| `int`
	| `long`
	| `float`
	| `double`
	| `signed`
	| `unsigned`
	| struct_or_union_specifier
	| enum_specifier
	;
=TEX
=DUMPMORE wrk077.grm.txt
€type_specifier›
	= reserved_type_specifier
	| typedef_name
	;
=TEX
=DUMPMORE wrk077.grm.txt
€type_qualifier›
	= `const`
	| `volatile`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€struct_or_union_specifier›
	= struct_or_union, do_begin_members,
		`{`, struct_declaration_list, do_end_members, `}`
	| struct_or_union, identifier_or_typedef_name, do_begin_members,
		`{`, struct_declaration_list, do_end_members, `}`
	| struct_or_union, identifier_or_typedef_name
	;
=TEX
=DUMPMORE wrk077.grm.txt
€struct_or_union›
	= `struct`
	| `union`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€struct_declaration_list›
	= struct_declaration
	| struct_declaration_list, struct_declaration
	;
=TEX
=DUMPMORE wrk077.grm.txt
€init_declarator_list_opt›
	= 
	| init_declarator_list
	;
=TEX
Note that it would not introduce an LALR(1) conflict to allow an {\em init\_type\_declarator} in the second and subsequent members of the list below.
However, section 6.5.6 of \cite{ansi90} does not allow this extra generality:
if `{\tt I}' has been declared as a {\tt typedef} name, a redeclaration such as `{\tt const J, I;}' without a type specifier is not allowed.
=DUMPMORE wrk077.grm.txt
€init_declarator_list›
	= init_declarator
	| init_declarator_list, `,`, init_declarator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€init_type_declarator_list›
	= init_type_declarator
	| init_type_declarator_list, `,`, init_declarator
	| init_type_declarator_list, `,`, init_type_declarator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€init_declarator›
	= declarator
	| declarator, `=`, initializer
	;
=TEX
=DUMPMORE wrk077.grm.txt
€init_type_declarator›
	= type_declarator
	| type_declarator, `=`, initializer
	;
=TEX
=TEX
=DUMPMORE wrk077.grm.txt
€struct_declaration›
	= type_qualifier_list, struct_declarator_list, `;`
	| specifier_qualifier_list, struct_declarator_list, `;`
	| specifier_qualifier_list, struct_type_declarator_list, `;`
	;
=TEX
=DUMPMORE decl.grm.txt
€specifier_qualifier_list›
	= type_specifier
	| type_specifier, specifier_qualifier_list
	| type_qualifier
	| type_qualifier, specifier_qualifier_list
	;
=TEX
=DUMPMORE wrk077.grm.txt
€specifier_qualifier_list›
	= type_specifier, reserved_specifier_qualifiers
	| type_qualifier_list, type_specifier, reserved_specifier_qualifiers
	;
=TEX
=DUMPMORE wrk077.grm.txt
€reserved_specifier_qualifiers›
	=
	| reserved_specifier_qualifiers, reserved_type_specifier
	| reserved_specifier_qualifiers, type_qualifier
	;
=TEX
The comment about {\em innit\_declarator\_list} above also applies, {\it mutatis mutandis} to
{\em struct\_declarator\_list}.
=DUMPMORE wrk077.grm.txt
€struct_declarator_list›
	= struct_declarator
	| struct_declarator_list, `,`, struct_declarator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€struct_type_declarator_list›
	= struct_type_declarator
	| struct_type_declarator_list, `,`, struct_type_declarator
	| struct_type_declarator_list, `,`, struct_declarator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€struct_declarator›
	= declarator
	| `:`, constant_expression
	| declarator, `:`, constant_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€struct_type_declarator›
	= type_declarator
	| type_declarator, `:`, constant_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€enum_specifier›
	= `enum`, do_begin_enumerators,
		`{`, enumerator_list, do_end_enumerators, `}`
	| `enum`, identifier_or_typedef_name, do_begin_enumerators,
		`{`, enumerator_list, do_end_enumerators, `}`
	| `enum`, identifier_or_typedef_name
	;
=TEX
=DUMPMORE wrk077.grm.txt
€enumerator_list›
	= enumerator, do_enumerator
	| enumerator_list, `,`, enumerator, do_enumerator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€enumerator›
	= identifier_or_typedef_name
	| identifier_or_typedef_name, `=`, constant_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€declarator›
	= direct_declarator, do_declarator
	| pointer, direct_declarator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€type_declarator›
	= type_direct_declarator, do_declarator
	| pointer, type_direct_declarator
	;
=TEX
In the following note that there is just one identifier or {\em typedef\_name} at the
heart of the declarator (i.e., the name the declarator, declares).
The distinction between identifier or {\em typedef\_name} declarators then ripples up through the grammar.
=DUMPMORE wrk077.grm.txt
€direct_declarator›
	= identifier
	| `(`, declarator, `)`
	| direct_declarator, `[`, `]`
	| direct_declarator, `[`, constant_expression, `]`
	| direct_declarator, do_begin_parameters,
		`(`, parameter_type_list, do_end_parameters, `)`
	| direct_declarator, do_begin_parameters,
		`(`, identifier_list_opt, do_end_parameters, `)`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€type_direct_declarator›
	= typedef_name
	| `(`, type_declarator, `)`
	| type_direct_declarator, `[`, `]`
	| type_direct_declarator, `[`, constant_expression, `]`
	| type_direct_declarator, do_begin_parameters,
		`(`, parameter_type_list, do_end_parameters, `)`
	| type_direct_declarator, do_begin_parameters,
		`(`, identifier_list_opt, do_end_parameters,` )`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€pointer›
	= `*`
	| `*`, type_qualifier_list
	| `*`, pointer
	| `*`, type_qualifier_list, pointer
	;
=TEX
=DUMPMORE wrk077.grm.txt
€type_qualifier_list›
	= type_qualifier
	| type_qualifier_list, type_qualifier
	;
=TEX
=DUMPMORE wrk077.grm.txt
€parameter_type_list›
	= parameter_list
	| parameter_list, `,`, `...`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€parameter_list›
	= parameter_declaration
	| parameter_list, `,`, parameter_declaration
	;
=TEX
=DUMPMORE wrk077.grm.txt
€parameter_declaration›
	= declaration_specifiers
	| declaration_specifiers, parameter_declarator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€parameter_declarator›
	= parameter_direct_declarator, do_declarator
	| pointer, parameter_direct_declarator, do_declarator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€parameter_direct_declarator›
	= identifier_or_typedef_name
	| `(`, parameter_declarator, `)`
	| `(`, `)`
	| `[`, `]`
	| parameter_direct_declarator, `[`, `]`
	| parameter_direct_declarator, `[`, constant_expression, `]`
	| parameter_direct_declarator, do_begin_parameters,
		`(`, parameter_type_list, do_end_parameters, `)`
	| parameter_direct_declarator, do_begin_parameters,
		`(`, identifier_list_opt, do_end_parameters, `)`
	;
=TEX
The following production is only used for old style formal parameter lists, in which {\tt typedef} names are (following {\tt gcc} at least) not to be treated as identifiers.
=DUMPMORE wrk077.grm.txt
€identifier_list_opt›
	=
	| identifier, `,`, identifier_list_opt
	;
=TEX
=DUMPMORE wrk077.grm.txt
€initializer›
	= assignment_expression
	| `{`, initializer_list, `}`
	| `{`, initializer_list, `,`, `}`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€initializer_list›
	= initializer
	| initializer_list, `,`, initializer
	;
=TEX
=DUMPMORE wrk077.grm.txt
€type_name›
	= type_qualifier_list
	| type_qualifier_list, abstract_declarator
	| specifier_qualifier_list
	| specifier_qualifier_list, abstract_declarator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€abstract_declarator›
	= pointer
	| direct_abstract_declarator
	| pointer, direct_abstract_declarator
	;
=TEX
=DUMPMORE wrk077.grm.txt
€direct_abstract_declarator›
	= `(`, abstract_declarator, `)`
	| `[`, `]`
	| `[`, constant_expression, `]`
	| direct_abstract_declarator, `[`, `]`
	| direct_abstract_declarator, `[`, constant_expression, `]`
	| `(`, `)`
	| `(`, parameter_type_list, `)`
	| direct_abstract_declarator, `(`, `)`
	| direct_abstract_declarator, `(`, parameter_type_list, `)`
	;
=TEX
The production for {\em typedef\_name} has to be modified, since the grammar becomes ambiguous
if typedef names cannot be distinugished from other names. E.g., to decide whether the
expression ``{\tt(X)(x)}'' is a cast or a function call, one needs to know whether ``{\tt X}''
denotes a type.
=DUMPMORE wrk077.grm.txt
€typedef_name› =
	TypeDefName;
=TEX
However, the C name space rules imply that there a {\tt typedef} name may be used as an identifier in several places, e.g., as a structure tag.
Where it does not introduce LALR(1) conflicts, we use the following production to achieve this:
=DUMPMORE wrk077.grm.txt
€identifier_or_typedef_name›
	= identifier
	| typedef_name
	;
=TEX
\subsection{Statements}
=DUMPMORE wrk077.grm.txt
€statement›
	= labeled_statement
	| compound_statement
	| expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	;
=TEX
=DUMPMORE wrk077.grm.txt
€labeled_statement›
	= identifier_or_typedef_name, `:`, statement
	| `case`, constant_expression, `:`, statement
	| `default`, `:`, statement
	;
=TEX
=DUMPMORE wrk077.grm.txt
€compound_statement›
	= do_begin_compound_statement,
	 `{`, declaration_list_opt, do_end_compound_statement, `}`
	| do_begin_compound_statement,
	 `{`, declaration_list_opt, statement_list, do_end_compound_statement, `}`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€statement_list›
	= statement
	| statement_list, statement
	;
=TEX
=DUMPMORE wrk077.grm.txt
€expression_statement›
	= `;`
	| expression, `;`
	;
=TEX
This is where the shift/reduce conflict arises. The statement ``{\tt if(a) if(b) f(); else g();}''
can be parsed so that the else-part belongs to the inner if-statement or the outer one
according to the following grammar. The resolution is that it should belong to the
inner if-statement, i.e., shift.
=DUMPMORE wrk077.grm.txt
€selection_statement›
	= `if`, `(`, expression, `)`, statement
	| `if`, `(`, expression, `)`, statement, `else`, statement
	| `switch`, `(`, expression, `)`, statement
	;
=TEX
To avoid 7 extra cases in the following, we introduce a new production for an optional expression.
=DUMPMORE wrk077.grm.txt
€iteration_statement›
	= `while`, `(`, expression, `)`, statement
	| `do`, statement, `while`, `(`, expression, `)`, `;`
	| `for`, `(`, expression_opt, `;`, expression_opt, `;`, expression_opt, `)`,
	  statement
	;
=TEX
=DUMPMORE wrk077.grm.txt
€expression_opt›
	=
	| expression;
=TEX
=DUMPMORE wrk077.grm.txt
€jump_statement›
	= `goto`, identifier_or_typedef_name, `;`
	| `continue`, `;`
	| `break`, `;`
	| `return`, expression_opt, `;`
	;
=TEX
\subsection{Expressions}

=DUMPMORE wrk077.grm.txt
€expression›
	= assignment_expression
	| expression, `,`, assignment_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
=TEX
=DUMPMORE wrk077.grm.txt
€assignment_expression›
	= conditional_expression
	| unary_expression, assignment_operator, assignment_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€assignment_operator›
	= `=`
	| `*=`
	| `/=`
	| `%=`
	| `+=`
	| `-=`
	| `<<=`
	| `>>=`
	| `&=`
	| `^=`
	| `|=`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€conditional_expression›
	= logical_or_expression
	| logical_or_expression, `?`, expression, `:`, conditional_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€constant_expression›
	= conditional_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€logical_or_expression›
	= logical_and_expression
	| logical_or_expression, `||`, logical_and_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€logical_and_expression›
	= inclusive_or_expression
	| logical_and_expression, `&&`, inclusive_or_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€inclusive_or_expression›
	= exclusive_or_expression
	| inclusive_or_expression, `|`, exclusive_or_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€exclusive_or_expression›
	= and_expression
	| exclusive_or_expression, `^`, and_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€and_expression›
	= equality_expression
	| and_expression, `&`, equality_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€equality_expression›
	= relational_expression
	| equality_expression, `==`, relational_expression
	| equality_expression, `!=`, relational_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€relational_expression›
	= shift_expression
	| relational_expression, `<`, shift_expression
	| relational_expression, `>`, shift_expression
	| relational_expression, `<=`, shift_expression
	| relational_expression, `>=`, shift_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€shift_expression›
	= additive_expression
	| shift_expression, `<<`, additive_expression
	| shift_expression, `>>`, additive_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€additive_expression›
	= multiplicative_expression
	| additive_expression, `+`, multiplicative_expression
	| additive_expression, `-`, multiplicative_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€multiplicative_expression›
	= cast_expression
	| multiplicative_expression, `*`, cast_expression
	| multiplicative_expression, `/`, cast_expression
	| multiplicative_expression, `%`, cast_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€cast_expression›
	= unary_expression
	| `(`, type_name, `)`, cast_expression
	;
=TEX
=DUMPMORE wrk077.grm.txt
€unary_expression›
	= postfix_expression
	| `++`, unary_expression
	| `--`, unary_expression
	| unary_operator, cast_expression
	| `sizeof`, unary_expression
	| `sizeof`, `(`, type_name, `)`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€unary_operator›
	= `&`
	| `*`
	| `+`
	| `-`
	| `~`
	| `!`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€postfix_expression›
	= primary_expression
	| postfix_expression, `[`, expression, `]`
	| postfix_expression, `(`, `)`
	| postfix_expression, `(`, argument_expression_list, `)`
	| postfix_expression, `.`, identifier_or_typedef_name
	| postfix_expression, `->`, identifier_or_typedef_name
	| postfix_expression, `++`
	| postfix_expression, `--`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€primary_expression›
	= identifier
	| constant
	| string
	| `(`, expression, `)`
	;
=TEX
=DUMPMORE wrk077.grm.txt
€argument_expression_list›
	= assignment_expression
	| argument_expression_list, `,`, assignment_expression
	;
=TEX
We leave enumeration constants out of the following list, on the grounds that a practical parser
would more likely treat them as identifiers during lexical analysis. The distinction between
enumeration constants and other identifiers does not affect the parsing.
=DUMPMORE wrk077.grm.txt
€constant›
	= IntegerConstant
	| CharacterConstant
	| FloatingConstant
	;
=TEX
We add productions for {\it string} and identifier just to keep the naming scheme uniform.
=DUMPMORE wrk077.grm.txt
€string›
	= String
	;
=TEX
=DUMPMORE wrk077.grm.txt
€identifier›
	= Identifier
	;
=TEX
\subsection{Action Functions}~\label{actions}
=TEX
=DUMPMORE wrk077.grm.txt
€do_end_declaration›
	= 
	;
=TEX
=DUMPMORE wrk077.grm.txt
€do_typedef›
	= 
	;
=TEX
=DUMPMORE wrk077.grm.txt
€do_begin_members›
	= 
	;
=TEX
=DUMPMORE wrk077.grm.txt
€do_end_members›
	= 
	;
=TEX
=DUMPMORE wrk077.grm.txt
€do_begin_enumerators›
	= 
	;
=TEX
=DUMPMORE wrk077.grm.txt
€do_end_enumerators›
	= 
	;
=TEX
=DUMPMORE wrk077.grm.txt
€do_declarator›
	= 
	;
=TEX
=DUMPMORE wrk077.grm.txt
€do_enumerator›
	= 
	;
=TEX
=DUMPMORE wrk077.grm.txt
€do_begin_parameters›
	= 
	;
=TEX
=DUMPMORE wrk077.grm.txt
€do_end_parameters›
	= 
	;
=TEX
=DUMPMORE wrk077.grm.txt
€do_begin_compound_statement›
	=
	;
=TEX
=DUMPMORE wrk077.grm.txt
€do_end_compound_statement›
	=
	;
=TEX
=SH
slrp -g -l 2  -f wrk077.grm.txt >wrk077.grm.run
=TEX
\newpage
\section{INDEX}
\small
\printindex
\end{document}


=IGN
