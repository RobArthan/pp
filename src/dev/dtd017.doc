%  dtd017.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=10000
\def\Slrp{{\bf SLRP}}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{SLR Parser Generator}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD017}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B. Jones & FMU Manager}
\TPPabstract{
The detailed design of a simple SLR parser generator.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issues 1.1 to 1.12 ] First drafts.

\item[Issue 2.1, 3 September 1991 ] First approved version.

\item[Issue \SCCSversion, \FormatDate{92/01/20} ] Updated to use new fonts.

%\item[Issue \SCCSversion, \FormatDate{$Date$%
%}]

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for an SLR(1) parser generator,
called \Slrp,
to be used in constructing the parser for HOL in the ICL HOL system.
It responds to the demand for such a tool made in \cite{DS/FMU/IED/HLD013}.
The parser generator itself is not intended to be part of the release 1 system.

\subsection{Introduction}
The parser generator uses the SLR(1) technique which is well-known
in the compiler literature. Chapter 6 of \cite{Aho77} has been used
as the main reference in its design and implementation.

This document is a long way from a detailed design of the internal structure
of a parser generator, the implementation document, \cite{DS/FMU/IED/IMP018}
is much closer to that. Instead, it attempts to give a
description of the parser generator which explains the services it supplies
to the user mainly by means of examples.
This description is not self-contained. It is, however, intended that someone
who reads section 6.1 of \cite{Aho77}, will be able to gain
an adequate understanding of the parser generator.
It will also be helpful for the reader first to glance at section 2 of
\cite{DS/FMU/IED/DTD018}, which discusses the datatypes used in the
generated parsers. End-user documentation may be derived by amalgamating
material from these two sources with the information given here.

The implementation is given in \cite{DS/FMU/IED/IMP017}.

\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD013}.

\subsection{Dependencies}
The implementation will be dependent on \cite{DS/FMU/IED/IMP001}.
The signature declaration in the design given
here actually only depends on Standard ML facilities.

\subsection{Possible Enhancements}
It would be nice to have systematic support for the second
simplest case of shift/reduce resolution, where different operator
precedence schemes apply depending on the non-terminal for which
reduction might be attempted.

It might be useful to have an interface which lets the grammar be read
in from the standard input.
\subsection{Deficiencies}
The output format currently used (shown in an example in this document)
is a piece of Standard ML which is rather slow to compile on
practical examples. This is apparently because it initialises arrays
by presenting the desired values as lists of structured values and,
when they have of the order of 100 elements, these lists take a long time
to type-check. 
\pagebreak
\section{INPUT FORMAT}
The BNF dialect used by \Slrp\
is a subset of British Standard BNF, \cite{DS/FMU/IED/PLN009},
extended to allow fragments of ML code to be given with any alternative.

The subset is the one in which the only operators are concatenation
and alternation and in which grouping with parentheses is not allowed.
Empty alternatives are allowed. An alternative may optionally be followed
by an {\em action}, which is just a fragment of Standard ML text.
We refer to such an extended grammar as an {\em action grammar}.
The BNF syntax for action grammars is as follows:

=GFT
	Grammar	=	Prod, `;`
			|	Prod, `;`, Grammar;

	Prod		=	Name, `=`, Def;

	Def		=	OptAlt, OptAction | OptAlt, OptAction, `|`, Def;

	OptAlt		=	Alt |;

	Alt		=	Symbol | Symbol, `,`, Alt;

	Symbol		=	Name | Constant;

	OptAction	=	Action | ;
=TEX

The terminal symbols in the above grammar are, $Name$, $Constant$ and, $Action$.
Names are formed using alphanumeric characters and underscores.
Names denote non-terminal symbols or classes of terminal symbols.

Constants start and finish with a backprime character `\verb"`"'.
A
`\verb"`"' may appear within a constant provided it is preceded by a
backslash character, `\verb"\"'. Constants
are used to denote individual terminal symbols.

Note that the distinction between names and constants for terminal symbols
is purely for documentary purposes. \Slrp\ treats either sort of terminal
in exactly the same way, and the generated parser is parameterised by
a $CLASSIFIER$ function to map input tokens onto terminal symbols
(see \cite{DS/FMU/IED/DTD018}). The names and constant symbols are used
as Standard ML identifiers in the generated parser and so if the parser
is to be syntactically correct they must be follow the rules for identifiers
in Standard ML.

Actions start with a left bracket, `\verb"(", and finish with
a right bracket, `\verb")"'. Any brackets appearing within an action must
be well-balanced. Actions denote fragments of Standard ML code to be
executed by the generated parser when a particular alternative has
been recognised.
The actions may be omitted, e.g., when using \Slrp\ to help design
a grammar.  The actions must either all\footnote{All the actions means
the complete set of actions required for the grammar.  Some
alternatives may not require any action.  Omitting any required actions
is a user error which \Slrp\ cannot detect.  No warning messages are
produced if actions are omitted. } be omitted or all be present.
If they are omitted, \Slrp\ proceeds as if each action had been supplied
as `\verb"()"'. Omitting the actions is appropriate when one is
experimenting with a grammar, e.g., to convert a non-SLR(1) grammar into
an SLR(1) one.

Comments may be included in a grammar using the Standard ML comment
symbols.

The following is an example of an extended grammar:
=GFT Example Grammar
(* Grammar for a Pocket Calculator *)
	E	=	E, `Plus`, T			(add x1 x3)
		|	T 				(fetch x1);

	T	=	T, `Times`, F			(mul x1 x3)
		|	F				(fetch x1);

	F	=	`Lbrack`, E, `Rbrack`		(fetch x2)
		|	Num				(conv x1);
=TEX

\Slrp\ assumes that the first non-terminal to appear in the grammar
is the chosen sentence symbol for the language defined by the grammar.
So here the sentences correspond to the non-terminal $E$.

Note the convention adopted by \Slrp\ that $x1$, $x2$ etc. are used
in an action to refer to the symbols int the corresponding alternative in
the grammar. Thus, in the alternative for addition above, the action
is to call the function $add$ with the result of parsing the $E$ and the $T$ as
its arguments.

The values $x1$, $x2$, used to refer to the symbols
in an alternative etc. have as their ML type an instance of the type
$('tok, 'lc, 'pp)INPUT\_STACK\_ITEM$ described in \cite{DS/FMU/IED/DTD018}.
This has two constructors: $Token$ and $Parsed$. The $Token$ constructor
corresponds to a terminal symbol in an alternative, and $Parsed$ corresponds
to a non-terminal. In the above example, all of the $x$s will be constructed
with $Parsed$, except for $x1$ in the second alternative for $F$.

We will refer to this example as the pocket calculator example in the
rest of this document.
\section{CODE GENERATION}
The output from \Slrp\ is some Standard ML source text, which, when compiled,
defines three tables and a function, as shown in the following skeletal
listing of the output produced for the pocket calculator example:
=GFT Example
val slrp'actions = Array.arrayoflist[
[(Num,Shift 5),(Lbrack,Shift 4)],[(Plus,Shift 6),(Eos,Accept)],[
...
];
val slrp'gotos = Array.arrayoflist[
...
];
val slrp'reducers = list_e_merge initial_E_DICT[
("F",[(fn(x3::x2::x1::_)=>(fetch x2)|_=>raise PARSER_ERROR"invalid reduction"),
...
];
val slrp'gen_parser = slrp'parse 0 slrp'actions slrp'gotos slrp'reducers;
=TEX
This code must be compiled in a context 
including the following:

\begin{enumerate}
\item
the data types and functions defined in
\cite{DS/FMU/IED/DTD018};
\item
a datatype
having a nullary constructor for each terminal
symbol and for a special end of sentence symbol (the name of this
special symbol is one of the parameters to the parser generator);
\item
any supporting functions, types, etc. required by the action code.
\end{enumerate}

In the pocket calculator example the context required might be
set up by the following code:
=GFT Example Code
open SlrpDriver;

datatype PC_CLASS = Plus | Times | Lbrack | Rbrack | Num | Eos | Wrong;

fun add (Parsed (x:int)) (Parsed (y:int)) = x + y
|   add _ _ = raise PARSER_ERROR "corrupt stack";
fun mul (Parsed (x:int)) (Parsed (y:int)) = x * y
|   mul _ _ = raise PARSER_ERROR "corrupt stack";
fun fetch (Parsed (x:int)) = x
|   fetch _= raise PARSER_ERROR "corrupt stack";
fun conv (Token (n:string, _)) = nat_of_string n
|   conv _ = raise PARSER_ERROR "corrupt stack";
=TEX


Here we are constructing a parser for the pocket calculator language which
computes the value of the expression it is parsing as it goes. As already
mentioned the parsing stack entries which are the arguments
to $add$, $mul$ and $conv$ will have type an instance of
$(''tok, ''lc, int) INPUT\_STACK\_ITEM$. 

The result of compiling the generated code in the above example
produces the following output:
=GFT Example SML Output
val slrp'actions = ? : (PC_CLASS * ACTION) list array   
val slrp'gotos = ? : (string * int) list array   
val slrp'reducers = ? : ((string, 'a, int) INPUT_STACK_ITEM list -> int) list
E_DICT
val slrp'gen_parser = fn : (string, PC_CLASS, int) RESOLVER ->
(string, PC_CLASS) CLASSIFIER ->
(string, PC_CLASS, int) ERROR_ROUTINE -> (string, 'a)READER -> 'a -> int
=TEX
Thus $slrp'gen\_parser$ requires as its arguments a resolver, a classifier,
an error routine, and a reader function to
give a parser which will return integer values.
The type definitions used for the arguments are explained
in \cite{DS/FMU/IED/DTD018}:

{\ftlmargin=1in
\begin{itemize}
\item
In this example, the default resolver described in
\cite{DS/FMU/IED/DTD018} will do.
\item
The  following classifier function gives the usual ASCII syntax for
arithmetical expressions.
=GFT Example SML
fun pc_classify "*" = Times
|   pc_classify "+" = Plus
|   pc_classify "(" = Lbrack
|   pc_classify ")" = Rbrack
|   pc_classify "<end-of-input>" = Eos
|   pc_classify Other = if is_all_decimal Other then Num else Wrong;
=TEX
\item
The default error routine will serve our needs here. It requires an
argument which is a function giving the string form of a token. Since our
tokens are already strings this is easy to arrange:
=GFT Example SML
val pc_error = default_error (fn s => s);
=TEX
\item
Now we need to define a reader. For simplicity, let us construct the
parser so that its input is given in its entirety as an exploded
string before parsing commences.
Thus the following reader will do:
=GFT Example SML
fun pc_reader (ip : string list) : string * string list = (
	case ip of
		(h :: more) => (h, more)
	|	[] => ("<end-of-input>", [])
);
=TEX
\end{itemize}}

The desired parser may now be obtained by  applying
$slrp'gen\_parser$ as follows:
=GFT Example SML
val pc_parser = slrp'gen_parser default_resolver pc_classify pc_error pc_reader;
=TEX
To test our parser we build a simple lexical analyser, e.g.:

=GFT Example SML
fun pc_lex (s : string) : string list = (
	let	val chars = explode s;
		fun get_num acc (x :: more) = (
			if is_all_decimal x
			then get_num (acc ^ x) more
			else (acc, x :: more)
		)  | get_num acc [] = (acc, []);
		fun get_tok (x :: more) = (
			if is_all_decimal x
			then let val (num, rest) = get_num x more
			in	num :: get_tok rest
			end else if x = " "
			then get_tok more
			else x :: get_tok more
		) | get_tok [] = []
	in	get_tok chars
	end
);
=TEX
With the lexical analyser we can define a more user-friendly pocket
calculator:
=GFT Example SML
val pc : string -> int = pc_parser o pc_lex;
=TEX
and we can then test its behaviour:
=GFT Example SML Session
:> pc"1001+42";
val it = 1043 : int   
:> pc"1001 * 42";
val it = 42042 : int   
:> pc"(1001)";
val it = 1001 : int   
:> pc"1001";
val it = 1001 : int   
:> pc"(1*(2*(3*(4*(5*(6*(7*8)))))))";
val it = 40320 : int   
=TEX
\section{CONFLICT RESOLUTION}
Not all grammars can be parsed by the SLR(1) technique.
\Slrp\ will report the so-called conflicts which mean the grammar
is not SLR(1).
However non-SLR(1) grammars are often useful, e.g., an ambiguous grammar
is never SLR(1) and ambiguous grammars can be very convenient.

There are two sorts of conflicts which arise, shift/reduce conflicts
and reduce/reduce conflicts.

\subsection{Shift/Reduce Conflicts}
We illustrate the use of a grammar with shift/reduce conflicts
by a modification of the pocket calculator example, in which we merge
the addition and multiplication operators into a single class $Op$ (as one
would to support user-defined operators with user-defined
precedences).

=GFT Example Grammar
E	=	 E, Op, E			(apply x2 x1 x3)
	|	 `Lbrack`, E, `Rbrack`		(fetch x2)
	|	 Num 				(conv x1);                        
=TEX

Here when we run \Slrp\ we will see the following message:
=GFT Example Output
1 conflict detected (1 shift/reduce, 0 reduce/reduce)
+++ Dynamic Actions +++
State 6 on symbol Op
        Either shift to 4 or reduce by E = E, Op, E | ...
=TEX

Let us see what happens if we ignore this message
and proceed to construct the parser as before.
$fetch$ and $conv$ are unchanged. $apply$ might be as in the following.
=GFT Example Code
datatype PC_CLASS = Op | Lbrack | Rbrack | Num | Eos | Wrong;
fun apply (Token("+", _)) (Parsed (x:int)) (Parsed (y:int)) = x + y
|   apply (Token("*", _)) (Parsed (x:int)) (Parsed (y:int)) = x * y
|   apply (Token(s, _)) _ _ = raise PARSER_ERROR ("operator " ^ s  ^ " not recognised")
|   apply _ _ _ = raise PARSER_ERROR "corrupt stack";
=TEX
=GFT Example Code
fun pc_classify "*" = Op
|   pc_classify "+" = Op
|   pc_classify "(" = Lbrack
|   pc_classify ")" = Rbrack
|   pc_classify "<end-of-input>" = Eos
|   pc_classify Other = if is_all_decimal Other then Num else Wrong;
=TEX

If we test the behaviour of the generated parser, we find that all
goes well until we supply a term which exhibits the ambiguity
in the grammar:
=GFT Example SML Session
:> pc"1001";
val it = 1001 : int   
:> pc"1001 * 42";
val it = 42042 : int   
:> pc"1001 * (3 + 5)";
val it = 8008 : int   
:> pc"1001 * 3 + 5";
Exception- PARSER_ERROR "shift/reduce conflict" raised
=TEX

What has happened is that on reading the $+$, the generated parser
has to choose between the two possible ways of parsing 
$1001*3+5$,
i.e., it has to choose whether {\em(a)} to ``reduce'' the expression to the left of
the $+$, i.e., to evaluate $1001*3$ before doing the addition,
or {\em(b)} to ``shift'' the $+$, i.e., to defer evaluation of the multiplication
until it has evaluated $3+5$.
It makes this choice by calling the resolver function supplied as one
of its arguments. As discussed in
\cite{DS/FMU/IED/DTD018}, the resolver function makes a three-way choice:
``shift'', ``reduce'' or ``error''. The default resolver we have used
in the example always chooses error, which causes an exception to
be raised as shown above.


To resolve the problem we must supply a different resolver to
$slrp'gen\_parser$. In the current example, we see by inspecting the
grammar and the conflict report from \Slrp\ that the problem always
arises when an $Op$ is being read in a situation where the parser
could reduce using $E = E\,Op\,E$, and in this case we can decide
what to do simply by comparing the two instances of $Op$.

The support functions defined in \cite{DS/FMU/IED/DTD018} make special
provision for this common case where the conflict can be resolved by
comparing the current input token with the rightmost terminal in
the reduction which could be made. This special provision comprises
a function $simple\_resolver$  which takes as an argument
a function to perform the comparison.
In our example we might define the following comparison function
=GFT Example Code
fun pc_compare ((s1, _), (s2, _)) = (
	case (s1, s2) of
		("+", "+") => DoReduce
	|	("+", "*") => DoShift
	|	("*", "+") => DoReduce
	|	("*", "*") => DoReduce
	|	_ => raise PARSER_ERROR "unrecognised operator"
);
=TEX

($DoShift$ etc. are the constructors of a datatype $RESOLUTION$ discussed
in \cite{DS/FMU/IED/DTD018}.)

We then define the parser as follows.
=GFT Example Code
val pc_parser = slrp'gen_parser (simple_resolver pc_compare) pc_classify pc_error pc_reader;
=TEX
Defining $pc$ as before, we see that the case which used to fail now
works as we would like:
=GFT Example SML Session
:> pc"1001 * 3 + 5";
val it = 3008 : int   
=TEX

The simple technique supported by $simple\_resolver$ will handle
many useful grammars. More complex cases can be handled by hand-coding
a resolver function. The interface for the resolver function is
described in \cite{DS/FMU/IED/DTD018}.

\subsection{Reduce/Reduce Conflicts}
Reduce/reduce conflicts occur much less often in practically useful
grammars than shift/reduce conflicts.
An example connected with an equation-typesetting preprocessor may be
found in \cite{Aho77}. \Slrp\ does not cater for dynamic resolution of
reduce/reduce conflicts but instead adopts a similar rule for
resolving them to that adopted by the program YACC discussed in\cite{Aho77},
namely, that a reduce/reduce conflict for two distinct non-terminals
is resolved in favour of the production which appears first
in the grammar\footnote{%
This rule is slightly complicated since,
\Slrp\ allows several alternatives to be given for one non-terminal
and also allows alternatives to be given in separate productions for the same non-terminal.
Internally, \Slrp\ brings all the alternatives for a given non-terminal
together as soon as it encounters the first production for that non-terminal.
The reduce/reduce resolution is done using the ordering of alternatives within
this internal representation for the grammar.%
}.

=TEX
\pagebreak
\section{INTERFACE}
In the release 1 system, the parser generator is to be compiled during system
build into a separate ML database, $sun{\cal N}slrp.db$, ${\cal N}= 3, 4$.
This is then invoked using the $slrp$ function defined below to construct part of
the source of the ICL HOL parser.
=DOC
signature ÛSlrpÝ = sig
=DESCRIBE
This is the signature of a structure containing an SLR(1) parser
generator, \Slrp.
It is not included as part of the release 1 HOL system.
=ENDDOC
The parser generator is invoked using the following function $slrp$.
=DOC
val ÛslrpÝ : {infile : string, outfile : string, logfile : string, eos:string, loglevel:int} -> unit
=DESCRIBE
$slrp$ is used to invoke \Slrp, an SLR(1) parser generator. 
It is not included as part of the release 1 HOL system.
It is further documented in DTD017.

$infile$ names the input file for $slrp$.
The input file should contain a BNF grammar in which optional fragments of
Standard ML may be supplied in brackets at the end of each alternative.
The identifiers $x1$, $x2$, ... may be used to refer to
the successive components of the alternative in these Standard ML fragments.

$slrp$ writes to the output file, named by $outfile$,
some Standard ML source text defining some tables and a function
$slrp'gen\_parser$ which acts as a parser for the supplied grammar.

$eos$ gives the name of the lexical class denoting end of input.

The integer $loglevel$ determines the amount
of log information to be written to the file named $logfile$, as follows:

\begin{center}
\begin{tabular}{|l|p{4in}|}\hline
Level & Information Logged \\ \hline\hline
$\leq 0$ & No log information is produced and the logfile parameter is ignored. \\ \hline
$1$ & This gives a summary of the conflict
resolution process and a listing of any conflicts requiring
dynamic resolution. \\ \hline
$2$ & As 1 together with a listing
of the grammar and its terminals and the state table and a listing of any conflicts
before resolution. \\ \hline
$\geq 3$ & As 2 together with a listing of the full action table before resolution. \\ \hline
\end{tabular}
\end{center}

$loglevel=2$ is the most useful level during development of a parser.
=ENDDOC

=SML
end; (* of signature Slrp *)
=TEX
\section{TEST POLICY}
The parser generator will not itself form part of the release 1 system and
only rudimentary testing will be feasible for it.
Since the generated parser for HOL will itself be comprehensively tested,
this will not compromise quality assurance for the delivered system.

If the parser generator is to be include in a subsequent release of the HOL
system then more comprehensive testing will be required.

\section{INDEX}
\small
\printindex

\end{document}


