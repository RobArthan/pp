=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=10000
\def\Slrp{{\bf SLRP}}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{SLR Parser Generator}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD017}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
The detailed design of a simple SLR parser generator.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion (\FormatDate{$Date$%
})]
First draft for comment.
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for an SLR parser generator,
called \Slrp,
to be used in constructing the parser for HOL in the ICL HOL system.
It responds to the demand for such a tool made in \cite{DS/FMU/IED/HLD013}.
The parser generator itself is not intended to be part of the release 1 system.

\subsection{Introduction}
The parser generator uses the SLR(1) technique which is well-known
in the compiler literature. Familiarity
with the relevant parts of \cite{Aho86} will be useful
for a reader of this document.

This document is a long way from a detailed design of the internal structure
of a parser generator, the implementation document, \cite{DS/FMU/IED/IMP018}
is much closer to that. Instead, what follows attempts to give a
description of the parser generator which explains the services it supplies
to the user, in user-oriented terms and frequently by means of examples.
 
\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD013}.

\subsection{Dependencies}
The implementation will be dependent on \cite{DS/FMU/IED/IMP017}.

\subsection{Possible Enhancements}
It would be nice to have systematic support for the second
simplest case of shift/reduce resolution, where different operator
precedence schemes apply depending on the non-terminal for which
reduction might be attempted.
\subsection{Deficiencies}
It would probably be useful to have an interface which let the grammar be read
in from the standard input.
\pagebreak
\section{INPUT FORMAT}
The BNF dialect used by \Slrp 
is a subset of the British Standard (\cite{BS6154}),
extended to allow fragments of ML code to be given with any alternative.

The subset is the one in which the only operators are concatenation
and alternation and in which grouping with parentheses is not allowed.
Empty alternatives are allowed. Alternatives may optionally be followed
by an {\em action}, which is just a fragment of text.
We refer to such an extended grammar as an {\em action grammar}.
The BNF syntax for action grammars is as follows:

=TEX
Û
	Grammar	=		Prod, `;`
			|	Prod, `;`, Grammar;

	Prod		=	Name, `=`, Def;

	Def		=	OptAlt, OptAction | OptAlt, OptAction, `|`, Def;

	OptAlt		=	Alt |;

	Alt		=	Symbol | Symbol, `,`, Alt;

	Symbol		=	Name | Constant;

	OptAction	=	Action | ;
Ê

The terminal symbols in the above grammar are, $Name$, $Constant$ and, $Action$.
Names are formed using alphanumeric characters underscores.
Names denote non-terminal symbols or classes of terminal symbols.

Constants start and finish with a backprime character `\verb"`"'.
`\verb"`"' may appear within a constant provided it is preceded by a
backslash character `\verb"\"'. Constants
are used to denote individual terminal symbols.

Note that the distinction between names and constants for terminal symbols
is purely for documentary purposes. \Slrp\ treats either sort of terminal
in exactly the same way, and the generated parser is parameterised by
a $CLASSIFIER$ function to map input tokens onto terminal symbols
(see \cite{DS/FMU/IED/DTD018}).

Actions start with a left bracket, `\verb"(", and finish with
a right bracket, `\verb")"'. Any brackets appearing within an action must
be well-balanced. Actions denote fragments of Standard ML code to be
executed by the generated parser when a particular alternative has
been recognised.
The actions may be omitted, e.g., when using \Slrp\ to help design
a grammar., The actions must either all be omitted or all be present.
If they are omitted \Slrp\ proceeds as if each action had been supplied
as `\verb"()"'.

Comments may be included in a grammar using the Standard ML comment
symbols.

The following is an example of an extended grammar:
ÛExample Grammar
(* Grammar for a Pocket Calculator *)
	E	=	E, `Plus`, T			(add x1 x3)
		|	T 				(fetch x1);

	T	=	T, `Times`, F			(mul x1 x3)
		|	F				(fetch x1);

	F	=	`Lbrack`, E, `Rbrack`		(fetch x2)
		|	Num				(conv x1);
Ê

\Slrp\ assumes that the first non-terminal to appear in the grammar
is the chosen sentence symbol for the language defined by the grammar.
So here the sentences correspond to the non-terminal $E$.

Note the convention adopted by \Slrp\ that $x1$, $x2$ etc. are used
in an action to refer to the pieces of the corresponding alternative in
the grammar. Thus in the alternative for addition above the action
is call the function $add$ with the result of parsing the $E$ and the $T$ as
its arguments.

We will refer to this example as the pocket calculator example in the
rest of this document.
\section{CODE GENERATION}
The output form \Slrp\ is some Standard ML source text, which, when compiled,
defines three tables and a function, as shown in the following skeletal
listing of the output produced for the pocket calculator example:
ÛExample
val slrp'actions = Array.arrayoflist[
[(Num,Shift 5),(Lbrack,Shift 4)],[(Plus,Shift 6),(Eos,Accept)],[
...
];
val slrp'gotos = Array.arrayoflist[
...
];
val slrp'reducers = list_e_merge initial_E_DICT[
("F",[(fn(x3::x2::x1::_)=>(fetch x2)|_=>raise PARSER_ERROR"invalid reduction"),
...
];
val slrp'gen_parser = slrp'parse 0 slrp'actions slrp'gotos slrp'reducers;
Ê
This code must be compiled in a context 
including the following:

\begin{enumerate}
\item
the data types and functions defined in
\cite{DS/FMU/IED/DTD018};
\item
a datatype
having a nullary constructor for each terminal
symbol and for the end of sentence symbol;
\item
any supporting functions required by the action code.
\end{enumerate}

In the pocket calculator example the context required might be
set up by the following code:
ÛExample Code
open SlrpDriver;

datatype PC_CLASS = Plus | Times | Lbrack | Rbrack | Num | Eos | Wrong;

fun add (Parsed (x:int)) (Parsed (y:int)) = x + y
|   add _ _ = raise PARSER_ERROR "corrupt stack";
fun mul (Parsed (x:int)) (Parsed (y:int)) = x * y
|   mul _ _ = raise PARSER_ERROR "corrupt stack";
fun fetch (Parsed (x:int)) = x
|   fetch _= raise PARSER_ERROR "corrupt stack";
fun conv (Token (n:string, _)) = nat_of_string n
|   conv _ = raise PARSER_ERROR "corrupt stack";
Ê

Here we are constructing a parser for the pocket calculator language which
computes the value of the expression it is parsed as it goes. Thus
the parsing stack entries will have type an instance of
$(''tok, ''lc, int) INPUT\_STACK\_ITEM$. 

The result of compiling the generated code in the above example
produces the following output:
ÛExample SML Output
val slrp'actions = ? : (PC_CLASS * ACTION) list array   
val slrp'gotos = ? : (string * int) list array   
val slrp'reducers = ? : ((string, 'a, int) INPUT_STACK_ITEM list -> int) list
E_DICT
val slrp'gen_parser = fn : (string, PC_CLASS, int) RESOLVER ->
(string, PC_CLASS) CLASSIFIER ->
(string, PC_CLASS, int) ERROR_ROUTINE -> (string, 'a)READER -> 'a -> int
Ê
Thus $slrp'gen\_parser$ requires a resolver, a classifier
an error routine and a reader function
give a parser which will return integer values.

In this example, since the grammar does not
generate any conflicts the default resolver supplied by
\cite{DS/FMU/IED/DTD018} will do.

The  following classifier function gives the usual ASCII syntax for
arithmetical expressions.
ÛExample SML
fun pc_classify "*" = Times
|   pc_classify "+" = Plus
|   pc_classify "(" = Lbrack
|   pc_classify ")" = Rbrack
|   pc_classify "<end-of-input>" = Eos
|   pc_classify Other = if is_all_decimal Other then Num else Wrong;
Slrp.slrp {infile="slr.tst", outfile="slr.sml", logfile ="slr.log", eos ="Eos", loglevel=2};
Ê

The default error routine will serve our needs here. It requires an
argument which is a function giving the string form of a token. Since our
tokens are already strings this is easy to arrange:
ÛExample SML
val pc_error = default_error (fn s => s);
Ê

Now we need to define a reader. For simplicity, let us construct the
parser so that its input is given in its entirety as an exploded
string before parsing commences.
Thus the following reader will do:
ÛExample SML
fun pc_reader (ip : string list) : string * string list = (
	case ip of
		(h :: more) => (h, more)
	|	[] => ("<end-of-input>", [])
);
Ê
The desired parser may now be obtained by  instiantiating
$slrp'gen\_parser$ as follows:
ÛExample SML
val pc_parser = slrp'gen_parser default_resolver pc_classify pc_error pc_reader;
Ê
To test our parser we might build a simple lexical analyser, e.g.:

ÛExample SML
fun pc_lex (s : string) : string list = (
	let	val chars = explode s;
		fun get_num acc (x :: more) = (
			if is_all_decimal x
			then get_num (acc ^ x) more
			else (acc, x :: more)
		)  | get_num acc [] = (acc, []);
		fun get_tok (x :: more) = (
			if is_all_decimal x
			then let val (num, rest) = get_num x more
			in	num :: get_tok rest
			end else if x = " "
			then get_tok more
			else x :: get_tok more
		) | get_tok [] = []
	in	get_tok chars
	end
);
Ê
With the lexical analyser we can define a more user-friendly pocket
calculator:
ÛExample SML
val pc : string -> int = pc_parser o pc_lex;
Ê
and we can then test its behaviour:
ÛExample SML Session
:> pc"1001+42";
val it = 1043 : int   
:> pc"1001 * 42";
val it = 42042 : int   
:> pc"(1001)";
val it = 1001 : int   
:> pc"1001";
val it = 1001 : int   
:> pc"(1*(2*(3*(4*(5*(6*(7*8)))))))";
val it = 40320 : int   
Ê
\section{CONFLICT RESOLUTION}
Not all grammars can be parsed by the SLR(1) technique.
\Slrp\ will report the so-called conflicts which mean the grammar
is no SLR(1).
However non-SLR(1) grammars are often useful,e.g. an ambiguous grammar
is never SLR(1) and ambiguous grammars can be very convenient.

There are two sorts of conflicts which arise, shift/reduce conflicts
and reduce/reduce conflicts.

\subsection{Shift/Reduce Conflicts}
We illustrate the use of a grammar with shift/reduce conflicts
by a modification of the pocket calculator example, in which we merge
the addition and multiplication operators into a single class $Op$ (perhaps
with a view to supporting user-defined operators with user-defined
precedences).

ÛExample Grammar
E	=	 E, Op, E			(apply x2 x1 x3)
	|	 `Lbrack`, E, `Rbrack`		(fetch x2)
	|	 Num 				(conv x1);                        
Ê

Here when we run \Slrp\ we will see the following message:
ÛExample Output
1 conflict detected (1 shift/reduce, 0 reduce/reduce)
+++ Dynamic Actions +++
State 6 on symbol Op
        Either shift to 4 or reduce by E = E, Op, E | ...
Ê

Let us see what happens if we ignore this message
and proceed to construct the parser as before.
$fetch$ and $conv$ are unchanged. $apply$ might be as in the following.
ÛExample Code
datatype PC_CLASS = Op | Lbrack | Rbrack | Num | Eos | Wrong;
fun apply (Token("+", _)) (Parsed (x:int)) (Parsed (y:int)) = x + y
|   apply (Token("*", _)) (Parsed (x:int)) (Parsed (y:int)) = x * y
|   apply (Token(s, _)) _ _ = raise PARSER_ERROR ("operator " ^ s  ^ " not recognised")
|   apply _ _ _ = raise PARSER_ERROR "corrupt stack";
Ê
ÛExample Code
fun pc_classify "*" = Op
|   pc_classify "+" = Op
|   pc_classify "(" = Lbrack
|   pc_classify ")" = Rbrack
|   pc_classify "<end-of-input>" = Eos
|   pc_classify Other = if is_all_decimal Other then Num else Wrong;
Ê

If we test the behaviour of the generated parser, we find that all
goes well until we supply a term which exhibits the ambiguity
in the grammar:
ÛExample SML Session
:> pc"1001";
val it = 1001 : int   
:> pc"1001 * 42";
val it = 42042 : int   
:> pc"1001 * (3 + 5)";
val it = 8008 : int   
:> pc"1001 * 3 + 5";
Exception- PARSER_ERROR "shift/reduce conflict" raised
Exception++ failure handled by useterminal
Ê

To resolve the problem we must supply a different resolver to
$slrp'gen\_parser$. In the current example, we see by inspecting the
grammar and the conflict report from \Slrp\ that the problem always
arises when an $Op$ is being read in a situation where the parser
could reduce using $E = E\,Op\,E$, and in this case we can decide
what to do simply by comparing the two instances of $Op$.

The support functions defined in \cite{DS/FMU/IED/DTD018} make special
provision for this common case where the conflict can be resolved by
comparing the current input token with the rightmost terminal in
the reduction which could be made. This special provision comprises
a function $simple\_resolver$  which takes as an argument
a function to perform the comparison and returns one of $DoShift$,
$DoReduce$ or $DoError$.
In our example we might define the following comparison function
ÛExample Code
fun pc_compare ((s1, _), (s2, _)) = (
	case (s1, s2) of
		("+", "+") => DoReduce
	|	("+", "*") => DoShift
	|	("*", "+") => DoReduce
	|	("*", "*") => DoReduce
	|	_ => raise PARSER_ERROR "unrecognised operator"
);
Ê

and then define the parser as follows.
ÛExample Code
val pc_parser = slrp'gen_parser (simple_resolver pc_compare) pc_classify pc_error pc_reader;
Ê
Definining $pc$ as before, we see that the case which used to fail now
works as we would expect:
ÛExample SML Session
:> pc"1001 * 3 + 5";
val it = 3008 : int   
Ê

The simple technique supported by $simple\_resolver$ will handle
many useful grammars. More complex cases can be handled by hand-coding
a resolution function.

\subsection{Reduce/Reduce Conflicts}
Reduce/reduce conflicts occur much less often in practically useful
grammars than shift/reduce conflicts.
An example connected with an equation-typesetting preprocessor may be
found in \cite{Aho86}. \Slrp\ does not cater for dynamic resolution of
Reduce/reduce conflicts but instead adopts a simular rule for
resolving them to that adopted by the program YACC discussed in\cite{Aho86},
namely, that a reduce/reduce conflict for two distinct non-terminals
is resolved in favour of the production which appears first
in the grammar\footnote{%
This rule is slightly complicated since,
\Slrp\ allows several alternatives to be given for one non-terminal
and also allows alternatives to be given in separate productions for the same non-terminal.
Internally \Slrp\ brings all the alternatives for a given non-terminal
together as soon as it encounters the first production for that non-terminal.
The reduce/reduce resolution is done using the ordering of alternatives within
this internal representation for the grammar.%
}.

=TEX
\section{INTERFACE}
=DOC
signature ‚Slrp· = sig
=DESCRIBE
See DS/FMU/IED/DTD018
=ENDDOC
The parser generator is invoked using the following function $slrp$.
Its first three parameters are the names of the input file, output file and
lo
=DOC
val ‚slrp· : {infile : string, outfile : string, logfile : string, eos:string, loglevel:int} -> unit
=DESCRIBE
See DS/FMU/IED/DTD018
=ENDDOC
$slrp$ is used to invoke an SLR(1) parser generator. It is not included
as part of the release 1 HOL system. It is further documented
in DS/FMU/IED/DTD017.

$infile$ names the input file for $slrp$.
The input file should contain a BNF grammar in which optional fragments of
Standard ML may be supplied in brackets at the end of each alternative.
The identifiers $x1$, $x2$, ... may be used to refer to
the successive components of the alternative in these Standard ML fragments.

$slrp$ writes to the output file, named by $outfile$,
some Standard ML code which defines a function
$slrp'gen\_parser$ which acts as a parser for the supplied grammar.

$eos$ gives the name of the lexical class denoting end of input.

The integer $loglevel$ determines the amount
of log information to be written to the file named $logfile$, as follows:

\begin{centering}
\begin{tabular}{|l|p{4in}|}\hline
Level & Information Logged \\ \hline\hline
$\leq 0$ & No log information is produced and the logfile parameter is ignored. \\ \hline
$1$ & This gives a summary of the conflict
resolution process and a listing of any conflicts requiring
dynamic resolution. \\ \hline
$2$ & As 1 together with a listing
of the grammar and its terminals and the state table and a listing of any conflicts
before resolution. \\ \hline
$\geq 3$ & As 2 together with a listing of the full action table before resolution. \\ \hline
\end{tabular}
\end{centering}

$loglevel=2$ is by the most useful level during development of a parser.
$loglevel=0$ or perhaps $1$ is appropriate to subsequent production runs.

=SML
end; (* of signature Slrp *)
=TEX
\section{TEST POLICY}
The parser generator will not itself form part of the release 1 system and
only rudimentary testing will be feasible for it.
Since the generated parser for HOL will itself be comprehensively tested,
this will not compromise quality assurance for the delivered system.

If the parser generator is to be include in a subsequent release of the HOL
system then more comprehensive testing will be required.
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
=TEST
fun dump_string file string = (
	let	val os = open_out file;
	in	(output(os, string); close_out os)
	end
);
(* First Pocket Calculator Example: *)
dump_string "slr.tst"(
"E	= E, `Plus`, T (add x1 x3)			\n" ^
"	| T (fetch x1);			\n" ^
"T	= T, `Times`, F (mul x1 x3)		\n	" ^
"	| F (fetch x1);\n" ^
"F	= `Lbrack`, E, `Rbrack` (fetch x2)	\n		" ^
"	| Num (conv x1);			\n");


open SlrpDriver;
datatype PC_CLASS = Plus | Times | Lbrack | Rbrack | Num | Eos | Wrong;

fun add (Parsed (x:int)) (Parsed (y:int)) = x + y
|   add _ _ = raise PARSER_ERROR "corrupt stack";
fun mul (Parsed (x:int)) (Parsed (y:int)) = x * y
|   mul _ _ = raise PARSER_ERROR "corrupt stack";
fun fetch (Parsed (x:int)) = x
|   fetch _= raise PARSER_ERROR "corrupt stack";
fun conv (Token (n:string, _)) = nat_of_string n
|   conv _ = raise PARSER_ERROR "corrupt stack";

fun pc_classify "*" = Times
|   pc_classify "+" = Plus
|   pc_classify "(" = Lbrack
|   pc_classify ")" = Rbrack
|   pc_classify "<end-of-input>" = Eos
|   pc_classify Other = if is_all_decimal Other then Num else Wrong;

val pc_error = default_error (fn s => s);
fun pc_reader (ip : string list) : string * string list = (
	case ip of
		(h :: more) => (h, more)
	|	[] => ("<end-of-input>", [])
);
Slrp.slrp {infile="slr.tst", outfile="slr.sml", logfile ="slr.log", eos ="Eos", loglevel=2};
open EfficientDictionary;
PolyML.use"slr.sml";
val pc_parser = slrp'gen_parser default_resolver pc_classify pc_error pc_reader;
fun pc_lex (s : string) : string list = (
	let	val chars = explode s;
		fun get_num acc (x :: more) = (
			if is_all_decimal x
			then get_num (acc ^ x) more
			else (acc, x :: more)
		)  | get_num acc [] = (acc, []);
		fun get_tok (x :: more) = (
			if is_all_decimal x
			then let val (num, rest) = get_num x more
			in	num :: get_tok rest
			end else if x = " "
			then get_tok more
			else x :: get_tok more
		) | get_tok [] = []
	in	get_tok chars
	end
);
val pc : string -> int = pc_parser o pc_lex;

pc"1001+42";
pc"1001 * 42";
pc"(1001)";
pc"1001";
pc"(1*(2*(3*(4*(5*(6*(7*8)))))))";
pc"(((((((1+2)+3)+4)+5)+6)+7)+8)";
pc"((((((1+2)+3)+4)+5)+6)+7)+8)" (* error case *);
pc"((((((((((1+2)+3)+4)+5)+6)+7)+8)" (* error case *);


(* Second pocket calculator example *)


dump_string "slr.tst"(
"E	= E, Op, E (apply x2 x1 x3)			\n" ^
"	| `Lbrack`, E, `Rbrack` (fetch x2)	\n		" ^
"	| Num (conv x1);			\n");

Slrp.slrp {infile="slr.tst", outfile="slr.sml", logfile ="slr.log", eos ="Eos", loglevel=2};

datatype PC_CLASS = Op | Lbrack | Rbrack | Num | Eos | Wrong;

fun apply (Token("+", _)) (Parsed (x:int)) (Parsed (y:int)) = x + y
|   apply (Token("*", _)) (Parsed (x:int)) (Parsed (y:int)) = x * y
|   apply (Token(s, _)) _ _ = raise PARSER_ERROR ("operator " ^ s  ^ " not recognised")
|   apply _ _ _ = raise PARSER_ERROR "corrupt stack";


fun pc_classify "*" = Op
|   pc_classify "+" = Op
|   pc_classify "(" = Lbrack
|   pc_classify ")" = Rbrack
|   pc_classify "<end-of-input>" = Eos
|   pc_classify Other = if is_all_decimal Other then Num else Wrong;

open EfficientDictionary;
PolyML.use"slr.sml";
val pc_parser = slrp'gen_parser default_resolver pc_classify pc_error pc_reader;
fun pc_lex (s : string) : string list = (
	let	val chars = explode s;
		fun get_num acc (x :: more) = (
			if is_all_decimal x
			then get_num (acc ^ x) more
			else (acc, x :: more)
		)  | get_num acc [] = (acc, []);
		fun get_tok (x :: more) = (
			if is_all_decimal x
			then let val (num, rest) = get_num x more
			in	num :: get_tok rest
			end else if x = " "
			then get_tok more
			else x :: get_tok more
		) | get_tok [] = []
	in	get_tok chars
	end
);
val pc : string -> int = pc_parser o pc_lex;

pc"1001";
pc"1001 * 42";
pc"1001 * (3 + 5)";
pc"1001 * 3 + 5";


fun pc_compare ((s1, _), (s2, _)) = (
	case (s1, s2) of
		("+", "+") => DoReduce
	|	("+", "*") => DoShift
	|	("*", "+") => DoReduce
	|	("*", "*") => DoReduce
	|	_ => raise PARSER_ERROR "unrecognised operator"
);
val pc_parser = slrp'gen_parser (simple_resolver pc_compare) pc_classify pc_error pc_reader;

val pc : string -> int = pc_parser o pc_lex;
