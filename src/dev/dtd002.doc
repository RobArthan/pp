=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of System Control and Basic Error Reporting}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD001}  %% Mandatory field
\def\SCCSversion{1.2
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
The detailed design of the
system control and basic
error reporting subsystem for the ICL HOL system.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion (\FormatDate{91/01/17%
})]
First draft for comment.
\end{description}
\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains part of the detailed design of the
ICL HOL system.
\subsection{Introduction}
\subsubsection{Background and Purpose}
The desired attributes of the error handling subsystem
are defined in \cite{DS/FMU/IED/HLD001}.
\subsubsection{Dependencies}
None, but note that the implementation of this material
will involve some compiler dependencies for best results
(see section \ref{Deficiencies} below for more information).
\subsubsection{Interface}
The document defines signatures $BasicError$ and
$SystemControl$.
\subsubsection{Possible Enhancements}
It may be desirable for more of the standard system controls
to be introduced here.
\subsubsection{Deficiencies}\label{Dependencies}
The main deficiency will be with Standard ML compilers which
do not support printing of the value associated with an
uncaught exception.
To support such a compiler a facility, $print\_last\_error$,
could be offered so that the user could ask the system
to print the error message associated with an evaluation
which had just failed.

The design given here will accomodate compilers which
will print a string value associated with an uncaught
exception but less efficiently than is possible with
a compiler allowing a user defined printing function
to be invoked (since it will not be possible to defer
formatting of error messages until the point when the
message is printed).

\section{MINIMAL ERROR REPORTING}
\subsection{Overview}
=DOC
signature âBasicErrorá = sig
=DESCRIBE
This is the signature of the module $BasicError$.
=ENDDOC
=TEX
This structure contains a basic repertoire of error
reporting facilities and certain
system control functions.
\subsection{Types}
The following types are used for error messages.
The details of the type $MESSAGE$ are local to this
structure since they may, in general, be compiler
dependent. Typically $MESSAGE$ will be a function which
returns
a string indicating the name of the source
of an error, a number identifying the error message and
a list of strings for inserting in the message.
A function $give\_message$ is available for inspecting
$MESSAGE$s.
=DOC
	type âMESSAGEá
=DESCRIBE
This type is used to pass error and other messages
around in the system. 
=USES
Obscure debugging situations.
=ENDDOC
=TEX
\subsection{Exceptions}
Two exceptions are used: one which may be trapped
and one which, by convention, ensures that
a message will be printed.
=DOC
	exception âFailá of MESSAGE
	exception âErrorá of MESSAGE
=DESCRIBE
These exception are raised to report error conditions.
$Fail$ is for errors which may be trapped (so that
the associated message is suppressed).
$Error$ is intended to ensure that the message will be reported
and, by convention, should not be trapped.
=USES
Obscure debugging situations.
=ENDDOC
\subsection{Error Message Database}
The structure will contain the database of error messages.
These are referenced by a number and are allocated
as and when needed at compile time by the following
function:
=DOC
	val ânew_error_messageá : {id:int, text:string} -> unit
=DESCRIBE
This function adds a new entry to the database
of error messages.
Note that substrings of the message of the form ``$?i$'' where
$i$ is a decimal digit have special significance (see
\ref{SimpleErrorReporting} below.
``$??$'' may be used to insert a single ``$?$'' character
in a message.
=FAILURE
2001 The error number identifies an already existing message
=USES
For use when adding facilities to the system.
=ENDDOC
=DOC
	val âgive_error_messageá : int -> (string list) -> string
=DESCRIBE
This function returns the entry in the error message
database associated with the given integer key.
The second parameter gives a list of strings to be inserted
into the text of the message. Substrings of the
message text of the form  ``$?i$'' where
$i$ is a decimal digit indicate position where these insertions
are to be made. ``$?0'' identifies the string at the
head of the list etc.  
=FAILURE
2002 The error number ?0 does not identify an entry in the error message database
=ENDDOC
=DOC
	val âgive_error_messagesá : unit -> {id:int, text:string} list
=DESCRIBE
This function returns the contents of the error message
database as a list.
=ENDDOC
=TEX
The following facility is only there in the interests
of internationalisation at some far distant date.
=DOC
	val âicl'change_error_messageá : {id:int, text:string} -> unit
=DESCRIBE
This function changes an entry in the database
of error messages. If the number does not identify
an existing entry a new entry is made.
=USES
ICL Use only.
=ENDDOC
=TEX
\subsection{Simple Error Reporting}\label{SimpleErrorReporting}
=DOC
	val âfailá : string -> int -> (unit -> string) list -> 'a
	val âerrorá : string -> int -> (unit -> string) list -> 'a
=DESCRIBE
These functions report a message of the corresponding
class with text determined by an integer parameter and
a list of string valued functions.
The string parameter is intended to give the name
of the top level function which has invoked the error message.

The error messages are stored in a database maintained by
$new\_error\_message$ and the integer parameter gives the
key for the desired entry in the database. The list of
string valued functions allow the messages to be parameterised.
When the error is printed the functions are evaluated to
produce a list of strings. Substrings of the database
entry of the form ``$?i$'' where $i$ is a decimal
digit are replaced by the corresponding entries in the
list (with ``$?0$'' correspponding to the head of the list).
(If there are more than ten entries in the list entries
after the tenth are evaluated but the result of the
evaluation is ignored).

$fail$ is for unrecoverable errors which may, however, be trapped. It causes
exception $Fail$ to be raised.

$error$ is for unrecoverable errors which must be reported
to the user.
It causes exception $Error$ to be raised.
=FAILURE
=FAILUREC
As for $set\_flag$ etc.
=USES
For use when coding new facilities to add to the system.
=ENDDOC
=TEX
\subsection{Printing Errors}
Values of type $MESSAGE$ may be inspected using the following
function.
=DOC
	val give_message: MESSAGE -> string
=DESCRIBE
This returns a printable form of an error message
value.
=ENDDOC
=TEX
We supply a function to print the
message corresponding to the latest error to be reported.
This is mainly for use on
systems which do not allow exceptions raised at the top level
to be pretty printed under our control.
The variable used to store the last error should be updated
as rarely as possible (e.g. in the error pretty printer
on systems which support one).

=TEX
\subsection{Support for Error Handling}
=DOC
	val âdivertá : exn -> string -> string -> int -> (unit -> string) list -> 'a
	val âlist_divertá : exn -> string -> ((string * int * ((unit -> string) list)) list) -> 'a
=DESCRIBE
These functions support a style of error handling in which,
if an error is reported during evaluation of an expression,
the source of the error may be checked and the error report
modified if needed to give a more meaningful report to
the user.
Sources of errors are identified by the string passed
as the first argument to the function $fail$ which is used
to flag trappable errors. By convention, this string gives
the name of the top level function which has raised
the error.

In the call $divert\,X\,from\,new\,new\_msg\,inserters$,
$X$ is the exception which has been
raised and
$from$ identifies a possible source for an error report.
$inserters$ is a list of functions to be used to generate
insertions for the error message (as with $fail$ q.v.).
If an error has reported by $from$, the call will have
the same effect as if $fail\,new\,new\_msg$ had been
called.

$list\_divert\,X\,new\,triples$ handles the more general case in which
errors from several sources are expected.
$X$ and $new$ are as for $divert$. $pairs$ gives a list
of triples giving possible sources of error and the corresponding
new messages and insertion functions.

=EXAMPLES
\begin{verbatim}
	new_error_message{id=12345, text="Cannot apply f to a"}
	...
	(mk_comb(f, a))
	handle X => divert X "mk_comb" "my_func" 12345 []
=USES
For use when coding new facilities to add to the system.
=ENDDOC
=TEX
That concludes the signature
=SML
end; (* of signature BasicError *)
=TEX
\section{SYSTEM CONTROL}\label{OVERVIEW}
\subsection{Overview}
=DOC
signature âSystemControlá = sig
=DESCRIBE
This is the signature of the module $SystemControl$.
=ENDDOC
=TEX
This section contains definitions concerned with
user-settable controls which govern the behaviour of the
system.

The intention is to give an extensible scheme whereby
ICL and user code can declare any controls needed
at compile time.
Boolean, string and integer controls are catered for.

\subsection{Introducing new controls.}
=DOC
	val ânew_flagá :
	{name:string, control:bool ref, default:unit->bool} -> unit
	val ânew_int_controlá :
	{name:string, control:int ref, default:unit->int, check:int -> bool} -> unit
	val ânew_string_controlá :
	{name:string, control:string ref, default:unit->string, check:string -> bool} -> unit
=DESCRIBE
These functions are used to introduce new named
control variables of the corresponding types. The $name$ parameter gives the
name of the new control variable. The $control$ component
of the parameter
gives the variable itself.
The $default$ component of the parameter is a function
which is used by $reset\_flag$, $reset\_int\_control$ or
$reset\_string\_control$ to reset the value.

In the integer and string cases the second argument is
a function to check the validity of the control values.
Whenever one of $set\_int\_control$ or $set\_string\_control$
is called it will issue an error message if this
functions returns {\it false} when applied to the
new value supplied by the caller.

After the call users
may update the control using one of
$set\_flag$, $set\_int\_control$ or $set\_string\_control$.

=FAILURE
2010 The name ?0 is already in use as a control variable name.
=USES
This function is for use when adding new facilities
to the HOL system which require global control variables.
=ENDDOC
=DOC
	val âset_flagá : (string * bool) -> unit
	val âset_int_controlá : (string * int) -> unit
	val âset_string_controlá : (string * string) -> unit
=DESCRIBE
These functions are used to change
the values of named
control variables of the corresponding types.
The first parameter gives the
name of the control variable. The second parameter
gives the desired new value.
=FAILURE
2011 The name ?0 is not in use as a control variable name.
2012 Value out of range for control variable ?0
=USES
This function is the standard means of changing
global control variables.

=DOC
	val âreset_flagá : string -> unit
	val âreset_int_controlá : string -> unit
	val âreset_string_controlá : string -> unit
=DESCRIBE
These functions are used to reset
the values of named
control variables of the corresponding types.
The parameter gives the
name of the control variable.
=FAILURE
2013 The name ?0 is not in use as a control variable name.
=USES
This function is for use when adding new facilities
to the HOL system which require global control variables.
=ENDDOC
=DOC
	val âget_flagá : string -> bool
	val âget_int_controlá : string -> int
	val âget_string_controlá : string -> string
=DESCRIBE
These functions are used to get
the values of named
control variables of the corresponding types.
The parameter gives the
name of the control variable.
=FAILURE
2013 The name ?0 is not in use as a control variable name.
=USES
This function is for use when adding new facilities
to the HOL system which require global control variables.
=ENDDOC
=DOC
	val âget_flagsá : unit -> (string * bool) list
	val âget_int_controlsá : unit -> (string * int) list
	val âget_string_controlsá : unit -> (string * string) list
=DESCRIBE
These functions return the names and current values of
the system flags or controls.
=SML
end; (* of signature SystemControl *)
=ENDDOC
=TEX
\section{TESTING}
The module tests for this document should invoke
each of the functions at least once.
The various failure cases identified should be
exhibited.

The functionality of $divert$ and $list\_divert$ should
be carefully checked out.
\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}
