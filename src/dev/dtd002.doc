=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of System Control and Basic Error Reporting}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of \cr System Control and Basic Error Reporting}
\TPPref{DS/FMU/IED/DTD002}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{
This document gives the detailed design of the
system control and basic
error reporting subsystem for the ICL HOL system.
It also defines the policies for reporting and handling errors
and for allocating error messages to be followed throughout
the detailed design and implementation.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ K. Blackburn\\ A.J. Hammon}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1]
First draft for comment.
\item[Issue 1.8]
$set\_flag$ and associate functions changed, to return previous value of control variable.
\item[Issue 1.10]
Reformated error messages.
Modified $new\_error\_message$ design, to ignore fully duplicated
error messages.
\item [Issue 1.14]
Added $pass\_on$.
Indexed some functions missing the same.
\item [Issue 1.15 (4 July 1991)]
$new\_error\_message$ changed so as not to raise exceptions.
\item [Issue \SCCSversion (\FormatDate{$Date$%
})] Rework after inspection ID0019.
\end{description}
\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design of the
the structure $SystemControl$ and $BasicError$
called for in \cite{DS/FMU/IED/HLD006}. It is intended
to constitute a detailed design document for part of the ICL HOL
system in the  sense of \cite{DS/FMU/IED/PLN008}.
\subsection{Introduction}
\subsubsection{Background and Purpose}
The desired attributes of the error handling subsystem
are defined in \cite{DS/FMU/IED/HLD006}.
\subsubsection{Dependencies}
None, but note that the implementation of this material
will involve some compiler dependencies for best results
(see section \ref{Deficiencies} below for more information).
\subsubsection{Interface}
The document defines signatures $BasicError$ and
$SystemControl$.
\subsubsection{Possible Enhancements}
It may be desirable for more of the standard system controls
to be introduced here.
\subsubsection{Deficiencies}\label{Deficiencies}
The main deficiency will be with Standard ML compilers which
do not support printing of the value associated with an
uncaught exception.
To support such a compiler a facility, $print\_last\_error$,
could be offered so that the user could ask the system
to print the error message associated with an evaluation
which had just failed.

The design given here will accommodate compilers which
will print a string value associated with an uncaught
exception but less efficiently than is possible with
a compiler allowing a user defined printing function
to be invoked (since it will not be possible to defer
formatting of error messages until the point when the
message is printed).

\section{POLICIES}
\subsection{Allocation of Message Texts}
Detailed design and implementation documents should not contain
string literals containing
text for inclusion in messages
other than those which appear in arguments to calls of
the function {\it new\_error\_message} which is used to
allocate an error message text and associated error message number.
Subsystems such as the type checker
which format and output complex messages containing information
derived from their input should allocate message texts which give
the framework of the desired message and use the inserts facility
supported by $get\_error\_message$ to generate the desired message.

Error message numbers for a document have the form
$1000 ‰ r + n$, where $r$ is the numeric part of the reference
for the detailed design document allocating a message,
and $1 \le n \le 999$. It is permitted for several functions
to share the same message number if the text is suitable.

\subsection{Error Reporting}
The function $fail$ should be used to report errors which may be
trapped (e.g. by a rewriting algorithm which works by repetition
until failure).

The function $error$ should be used to report errors which must
be reported to the user and are not intended to be trapped.
An example might be an ``impossible'' branch in a case switch
indicating an error in the system itself.

Recoverable situations in which the interactive user will be
asked whether to continue are to be reported by the function
$warn$ (which is defined in \cite{DS/FMU/IED/DTD010}).

\subsection{Error Handling}
The idioms used for handling (i.e. trapping) an error should
normally follow one of the following fragments.

ó
    handle complaint => ... divert complaint ...
    handle complaint => ... list_divert ...
    handle complaint => ... reraise complaint ...
    handle complaint => ... area_of complaint ...
    handle (Fail _) => ...
æ

That is to say, if a handler is supplied which can catch any value
of type $exn$ (as in the first four examples), then the only
use of the exception value should be as an argument to one of the functions
defined in this document.
Alternatively a handler may be supplied to catch exceptions
constructed with the constructor $Fail$.

Other, more specialised, error handling schemes may be required
in some cases. These are not encouraged
and should be reviewed against the policy here and
the stated objectives for error handling laid down in
\cite{DS/FMU/IED/HLD006}.

\section{MINIMAL ERROR REPORTING}
\subsection{Overview}
=DOC
signature âBasicErrorá = sig
=DESCRIBE
This is the signature of the structure $BasicError$.
=ENDDOC
=TEX
This structure contains a basic repertoire of error
reporting facilities and related functions.
\subsection{Types}
The following types are used for error messages.
The details of the type $MESSAGE$ are local to this
structure since they may, in general, be compiler
dependent. Typically, $MESSAGE$ will be a function which
returns
a string indicating the name of the source
of an error, a number identifying the error message and
a list of strings for inserting in the message.
A function $get\_message$ is available for inspecting
$MESSAGE$s.
=DOC
type âMESSAGEá
=DESCRIBE
This type is used to pass error and other messages
around in the system. 
=USES
Obscure debugging situations.
=ENDDOC
=TEX
\subsection{Exceptions}
Two exceptions are used: one which may be trapped
and one which, by convention, ensures that
a message will be printed.
=DOC
exception âFailá of MESSAGE
exception âErrorá of MESSAGE
=DESCRIBE
These exception are raised to report error conditions.
$Fail$ is for errors which may be trapped (so that
the associated message is suppressed).
$Error$ is intended to ensure that the message will be reported
and, by convention, should not be trapped.
=USES
Obscure debugging situations.
=ENDDOC
\subsection{Error Message Database}
The structure will contain the database of error messages.
These are referenced by a number and are allocated
as and when needed at compile time by the following
function:
=DOC
val ânew_error_messageá : {id:int, text:string} -> unit
=DESCRIBE
This function adds a new entry to the database
of error messages.
Note that substrings of the message of the form ``$?i$'' where
$i$ is a decimal digit have special significance (see
$fail$ for details).
``$??$'' may be used to insert a single ``$?$'' character
in a message.

If the $id$ and the $text$ are identical to an existing entry, then
$new\_error\_message$ has no effect.
If there is an existing entry with the same $id$ but a different $text$
then a message is reported on the standard output
and the existing entry is left unchanged.
=FAILURE
2001	The error number ?0 is already in use for a different message
=USES
For use when adding facilities to the system.
=ENDDOC
=DOC
val âget_error_messageá : int -> (string list) -> string
=DESCRIBE
This function returns the entry in the error message
database associated with the given integer key.
The second parameter gives a list of strings to be inserted
into the text of the message. Substrings of the
message text of the form  ``$?i$'' where
$i$ is a decimal digit indicate positions where these insertions
are to be made. ``$?0$'' identifies the string at the
head of the list etc.  
=FAILURE
2002	The error number ?0 does not identify an entry in the error message database
=ENDDOC
=DOC
val âget_error_messagesá : unit -> {id:int, text:string} list
=DESCRIBE
This function returns the contents of the error message
database as a list.
=ENDDOC
=TEX
The following facility is only there in the interests
of internationalisation at some far distant date.
=DOC
val âicl'change_error_messageá : {id:int, text:string} -> unit
=DESCRIBE
This function changes an entry in the database
of error messages. If the number does not identify
an existing entry a new entry is made.
=USES
ICL Use only.
=ENDDOC
=TEX
\subsection{Simple Error Reporting}\label{SimpleErrorReporting}
=DOC
val âfailá : string -> int -> (unit -> string) list -> 'a
val âerrorá : string -> int -> (unit -> string) list -> 'a
=DESCRIBE
These functions report a message of the corresponding
class with text determined by an integer parameter and
a list of string valued functions.
The string parameter is intended to give the name
of the top level function which has invoked the error message.

The error messages are stored in a database maintained by
$new\_error\_message$ and the integer parameter gives the
key for the desired entry in the database. The list of
string valued functions allow the messages to be parameterised.
When the error is printed the functions are evaluated to
produce a list of strings. Substrings of the database
entry of the form ``$?i$'' where $i$ is a decimal
digit are replaced by the corresponding entries in the
list (with ``$?0$'' corresponding to the head of the list).
(If there are more than ten entries in the list entries
after the tenth are evaluated but the result of the
evaluation is ignored).

$fail$ is for unrecoverable errors which may, however, be trapped. It causes
exception $Fail$ to be raised.

$error$ is for unrecoverable errors which must be reported
to the user.
It causes exception $Error$ to be raised.
=FAILUREC
As for $set\_flag$ etc.
=USES
For use when coding new facilities to add to the system.
=ENDDOC
=TEX
\subsection{Printing Errors}
Values of type $MESSAGE$ may be inspected using the following
function.
=DOC
val âget_messageá: MESSAGE -> string
=DESCRIBE
This returns a printable form of an error message
value. The message text is preceded by a header of the form
``{\it ERROR $<$nnnnn$>$ raised by $<$area$>$}'', where {\it $<$nnnnn$>$}
is the number of the message in the error database and {\it $<$area$>$}
typically gives the name of the function which gave rise to the error message.
=USES
In constructing extensions to the system.
=SEEALSO
$get\_message\_text$
=ENDDOC
=FAILURE
2003	ERROR ?0 raised by ?1: ?2
=TEX
=DOC
val âget_message_textá: MESSAGE -> string
=DESCRIBE
This returns a printable form of an error message text.
The message text is given without the header information which is
inserted by $get\_message$, q.v.
=USES
In constructing extensions to the system.
=SEEALSO
$get\_message$
=ENDDOC
=TEX
We could supply a function to print the
message corresponding to the latest error to be reported.
This would mainly be for use on
systems which do not allow exceptions raised at the top level
to be pretty printed under our control.
The variable used to store the last error would be updated
as rarely as possible (e.g. in the error pretty printer
on systems which support one).

=TEX
\subsection{Support for Error Handling}
=DOC
val âdivertá : exn -> string -> string -> int -> (unit -> string) list -> 'a
val âlist_divertá : exn -> string -> ((string * int * ((unit -> string) list)) list) -> 'a
=DESCRIBE
These functions support a style of error handling in which,
if an error is reported during evaluation of an expression,
the source of the error may be checked and the error report
modified if needed to give a more meaningful report to
the user.
Sources of errors are identified by the string passed
as the first argument to the function $fail$ which is used
to flag trappable errors. By convention, this string gives
the name of the top level function which has raised
the error.

In the call $divert\,X\,from\,new\,new\_msg\,inserters$,
$X$ is the exception which has been
raised and
$from$ identifies a possible source for an error report.
$inserters$ is a list of functions to be used to generate
insertions for the error message (as with $fail$ q.v.).
If an error has been reported by $from$, the call will have
the same effect as if $fail\,new\,new\_msg$ had been
called.

$list\_divert\,X\,new\,triples$ handles the more general case in which
errors from several sources are expected.
$X$ and $new$ are as for $divert$. $triples$ gives a list
of triples giving possible sources of error and the corresponding
new messages and insertion functions.

=USES
For use when coding new facilities to add to the system.
=ENDDOC
=TEX
=DOC
val âarea_ofá : exn -> string
=DESCRIBE
This returns the name of the function which raised an exception
(provided the exception was raised with $fail$
following the usual conventions). If the exception was not
the one raised by $fail$ then it is raised again.
=USES
For use when coding new facilities to add to the system.
=ENDDOC
=DOC
val âreraiseá : exn -> string -> 'a
=DESCRIBE
This re-raises an exception. If the exception is the exception $Fail$
as (raised by $fail$, q.v.) then the function name associated with the exception
is changed to the name given by the second argument.
=USES
For use when coding new facilities to add to the system.
=ENDDOC
=DOC
val âpass_oná : exn -> string -> string -> 'a
=DESCRIBE
$pass\_on$ $exn$ $from$ $to$ is similar to $reraise$, q.v., but
the function name associated with the exception is only modified if it
is equal to $from$, in which case it is changed to $to$.
=ENDDOC
=TEX
\subsection{Initialisation}
Some implementations will require the error system to be initialised
at the start of a session. For example, with PolyML, the function which
causes the exception values to be printed by the pretty printer needs
to be reinvoked at the start of each session. The following function
is intended to perform any such initialisations.
=DOC
val âicl'error_initá : unit -> unit
=DESCRIBE
This function is used to initialise certain aspects of the error reporting
system. It is called automatically at the start of each session. It is
harmless, but unnecessary, to call it within a session.
=ENDDOC
=SML
end; (* of signature BasicError *)
=TEX
\section{SYSTEM CONTROL}\label{OVERVIEW}
\subsection{Overview}
=DOC
signature âSystemControlá = sig
=DESCRIBE
This is the signature of the structure $SystemControl$.
=ENDDOC
=TEX
This section contains definitions concerned with
user-settable controls which govern the behaviour of the
system.

The intention is to give an extensible scheme whereby
ICL and user code can declare any controls needed
at compile time.
Boolean, string and integer controls are catered for.

\subsection{Introducing new controls.}
=DOC
val ânew_flagá :
	{name:string, control:bool ref, default:unit->bool, check:bool -> bool} -> unit
val ânew_int_controlá :
	{name:string, control:int ref, default:unit->int, check:int -> bool} -> unit
val ânew_string_controlá :
	{name:string, control:string ref, default:unit->string, check:string -> bool} -> unit
=DESCRIBE
These functions are used to introduce new named
control variables of the corresponding types. The $name$ parameter gives the
name of the new control variable. The $control$ component
of the parameter
gives the variable itself.
The $default$ component of the parameter is a function
which is used by $reset\_flag$, $reset\_int\_control$ or
$reset\_string\_control$ to reset the value.

The $check$ component of the parameter is
a function to check the validity of the control values, and, if desired,
to notify other code of the change in the value.
Whenever one of $set\_int\_control$ or $set\_string\_control$
is called it will issue an error message if this
functions returns {\it false} when applied to the
new value supplied by the caller.

After the introduction users
may update the control using one of
$set\_flag$, $set\_int\_control$ or $set\_string\_control$.

=FAILURE
2010	The name ?0 is already in use as a control variable name
=USES
This function is for use when adding new facilities
to the HOL system which require global control variables.
=ENDDOC
In most cases, it is better for ICL code to supply a $check$ function
which calls $fail$ rather than returns $false$, since then a more appropriate
error message than the one produce by $set\_flag$ etc. below:

=DOC
val âset_flagá : (string * bool) -> bool
val âset_int_controlá : (string * int) -> int
val âset_string_controlá : (string * string) -> string
=DESCRIBE
These functions are used to change
the values of named
control variables of the corresponding types.
The first parameter gives the
name of the control variable. The second parameter
gives the desired new value.
They return the previous value of the control variable.
=FAILURE
2011	The name ?0 is not in use as a control variable name
2012	Value out of range for control variable ?0
=USES
This function is the standard means of changing
global control variables.
=ENDDOC
=DOC
val âreset_flagá : string -> bool
val âreset_int_controlá : string -> int
val âreset_string_controlá : string -> string
=DESCRIBE
These functions are used to reset
the values of named
control variables of the corresponding types.
The parameter gives the
name of the control variable.
They return the previous value of the control variable.
=FAILURE
2011	The name ?0 is not in use as a control variable name
=USES
This function is for use when adding new facilities
to the HOL system which require global control variables.
=ENDDOC
=DOC
val âget_flagá : string -> bool
val âget_int_controlá : string -> int
val âget_string_controlá : string -> string
=DESCRIBE
These functions are used to get
the values of named
control variables of the corresponding types.
The parameter gives the
name of the control variable.
=FAILURE
2011	The name ?0 is not in use as a control variable name
=USES
This function is for use when adding new facilities
to the HOL system which require global control variables.
=ENDDOC
=DOC
val âget_flagsá : unit -> (string * bool) list
val âget_int_controlsá : unit -> (string * int) list
val âget_string_controlsá : unit -> (string * string) list
val âget_controlsá : unit ->
	((string * bool) list * (string * int) list * (string * string) list)
=DESCRIBE
These functions return the names and current values of
the system flags or controls.
=ENDDOC
=SML
end; (* of signature SystemControl *)
=TEX
\section{TEST POLICY}
The module tests for this document should invoke
each of the functions at least once.
The various failure cases identified should be
exhibited.

The functionality of $divert$ and $list\_divert$ should
be carefully checked out.
\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}
