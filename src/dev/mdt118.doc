=IGN
********************************************************************************
dtd118.doc: this file is part of the PPDev system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex
\def\Slrp{{\bf SLRP}}
\def\Hide#1{\relax}

%%%%% YOU WILL USUALLY WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{ Generic SLRP Parser: Module Tests}

\def\Abstract{\begin{center}
{\bf Abstract}\par
{The module tests for the generic SLRP parser.}
\end{center}}

\def\Reference{DS/FMU/IED/MDT118}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.3 $%
}
\def\Date{\FormatDate{$Date: 2003/03/04 18:05:37 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}

\item[Issues 1.1 to 1.3 ] First drafts.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}
\begin{center}
\begin{tabular}{ll}
{\Product} Development Library & Lemma 1\\
\end{tabular}
\end{center}
\newpage
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for a generic framework for a parser generated
by \Slrp. This is useful both for testing {\Slrp} and as a service to {\Slrp} users.

\subsection{Introduction}
See \cite{DS/FMU/IED/DTD118}.



\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD118}.

\section{TEST CASES}
We currently run the generic parser on each of Ada 95, C, Java 1.1 and pascal.

\pagebreak
\section{COMPILING THE COMMON MATERIAL}
=SML
map use [
	"dtd108.sml",
	"imp108.sml",
	"dtd002.sml",
	"imp002.sml",
	"dtd001.sml",
	"imp001.sml",
	"dtd018.sml",
	"imp018.sml",
	"dtd118.sml",
	"imp118.sml"
	];
=TEX
=SML
map use [ "dtd013.sml",
	"imp013.sml"];
=TEX

=TEX
\section{ADA 95}
=DUMP mdt118.ada
PACKAGE identifier IS

TYPE identifier IS `(` identifier `,` identifier `)` `;`

END identifier `;`
=TEX
=SML
open GenericSlrpParser;
use "ada95.grm.sml";
val t = parse_file slrp'gen_parser "mdt118.ada";
print_tree (curry output std_out) t;
fun f (Leaf _) = 1
|   f (Node(_, children)) = (
	1 + fold (op +) (map f children) 0
);
store_mt_results
mt_run[
	("ada95.1", f, t, 43)
];
=TEX
\section{C}
=DUMP mdt118.c.tok
`typedef` TypeDefName  `*`Identifier`;`
`int` Identifier `(` `)`
`{`
	`typedef` TypeDefName Identifier `;`
	TypeDefName Identifier `=` IntegerConstant `;`
	Identifier `=` Identifier `+` Identifier`;`
	`return` Identifier`;`
`}`
=TEX
=IGN
PolyML.print_depth 4;
val t = parse_string slrp'gen_parser "`int` Identifier `;`";
=SML
use"c.grm.sml";
val t = parse_file slrp'gen_parser "mdt118.c.tok";
print_tree (curry output std_out) t;
store_mt_results
mt_run[
	("c.1", f, t, 149)
];
=TEX
\section{JAVA 1.1}
=DUMP mdt118.java
INTERFACE IDENTIFIER `{`
        PUBLIC VOID IDENTIFIER `(` CHAR IDENTIFIER `)` `;`
`}`
=TEX
=SML
use "java11.grm.sml";
val t = parse_file slrp'gen_parser "mdt118.java";
print_tree (curry output std_out) t;
store_mt_results
mt_run[
	("java11.1", f, t, 38)
];
=TEX
\section{PASCAL}
=DUMP mdt118.p
PROGRAM IDENTIFIER SEMICOLON

VAR IDENTIFIER COLON IDENTIFIER SEMICOLON

PBEGIN
    IDENTIFIER ASSIGNMENT REALNUMBER SEMICOLON
    FOR IDENTIFIER ASSIGNMENT IDENTIFIER TO DIGSEQ
    DO IDENTIFIER ASSIGNMENT IDENTIFIER PLUS IDENTIFIER SEMICOLON
    IDENTIFIER LPAREN IDENTIFIER COMMA
               IDENTIFIER STAR IDENTIFIER PLUS IDENTIFIER RPAREN SEMICOLON

END

DOT
=TEX
=SML
use "pascal.grm.sml";
open GenericSlrpParser;
val t = parse_file slrp'gen_parser "mdt118.p";
print_tree (curry output std_out) t;
store_mt_results
mt_run[
	("pascal.1", f, t, 173)
];
=TEX
=TEX
\section{CUSTOMISED EXAMPLE}
We now develop something a little more like a real lexical analyser for C.
We need to track the type definitions in the input, which we do by manipulating
a type environment defined as follows (and in which when we push a new frame, we
copy the dictionary from the outer frame into it).

We also need to keep track of when we are in a type definition and when we are
inside the declarator-list that declares the members of a struct or union (and these
can be nested).

=SML
val type_env : unit E_DICT list ref = ref [initial_e_dict];
val in_type_def : bool ref = ref false;
val strunion_nesting : int ref = ref 0;
fun reset_state () = (
	type_env := [initial_e_dict];
	in_type_def := false;
	strunion_nesting := 0
);
=TEX
=SML
fun c_classifier (LVIdentifier (s, _) : LEX_VALUE) : LEX_CLASS = (
	case e_lookup s (hd(!type_env)) of
		Value () => LCIdentifier "TypeDefName"
	|	Nil => LCIdentifier "Identifier"
) | c_classifier (LVString (s, _)) = LCString s
|   c_classifier (LVEos _) = LCEos;
=IGN
(* Poly/ML specific version for debugging *)
local
fun debug_classifier (lv : LEX_VALUE) : LEX_CLASS = (
	let	val lc = c_classifier lv;
	in	output(std_out, PolyML.makestring lv);
		output(std_out, ": ");
		output(std_out, PolyML.makestring lc);
		output(std_out, "\n");
		lc
	end
);
in
val c_classifier = debug_classifier
end;

=TEX
=TEX
We need the following custom reduction functions:
=SML
fun red_declaration (nt, i) (x1,x2) stk = (
	(* declaration = unterminated_declaration, `;` *)
	in_type_def := false;
	generic_reducer (nt, i) [x1,x2] stk
);
fun red_storage_class_specifier_5 (nt, i) (x1) stk = (
	(* storage_class_specifier = `typedef` *)
	in_type_def := true;
	generic_reducer (nt, i) [x1] stk
);
fun red_begin_members (nt, i) (x1) stk = (
	(* begin_members = `{` *)
	strunion_nesting := !strunion_nesting + 1;
	generic_reducer (nt, i) [x1] stk
);
fun red_end_members (nt, i) (x1) stk = (
	(* end_members = `}` *)
	strunion_nesting := !strunion_nesting - 1;
	generic_reducer (nt, i) [x1] stk
);
fun red_begin_block (nt, i) (x1) stk = (
	(* begin_block = `{` *)
	type_env := hd(!type_env) :: !type_env;
	generic_reducer (nt, i) [x1] stk
);
fun red_end_block (nt, i) (x1) stk = (
	(* end_block = `}` *)
	type_env := tl (!type_env);
	generic_reducer (nt, i) [x1] stk
);
fun red_direct_declarator_1 (nt, i) (x1) stk = (
	(* direct_declarator = identifier *)
	(case x1 of
		Parsed(Node(_, [Leaf(LVIdentifier (s, _), _)])) => (
			if	!in_type_def andalso !strunion_nesting = 0
			then	type_env := e_enter s () (hd(!type_env)) :: tl (!type_env)
			else	()
		) | _ => ()
	);
	generic_reducer (nt, i) [x1] stk
);
=TEX
Now we construct a better lexical analyser.
=SML
val keyword_dict : string E_DICT = list_e_merge initial_e_dict (map (fn s => (s, s)) [
	"auto", "break", "case", "char", "const", "continue", "default", "double",
	"do", "else", "enum", "extern", "float", "for", "goto", "if",
	"int", "long", "register", "return", "short", "signed", "sizeof", "static",
	"struct", "switch", "typedef", "union", "unsigned", "void", "volatile", "while"
]);
=TEX
The following could be implemented more efficiently by adapting some of the analogous code
from IMP118.
=SML
fun c_is_alpha ch = (
		"a" <= ch andalso ch <= "z"
	orelse	"A" <= ch andalso ch <= "Z"
	orelse	ch = "_"
);

fun is_digit ch = "0" <= ch andalso ch <= "9";

val is_alnum = c_is_alpha fun_or is_digit;
=TEX
=SML
fun get_ident [] = Nil
| get_ident (chs as (ch :: more)) = (
	let	fun aux acc [] = Value(implode(rev acc), [])
		|   aux acc (c::more) = (
			if	is_alnum c
			then	aux (c::acc) more
			else	Value(implode(rev acc), c::more)
		);
	in	if	c_is_alpha ch
		then	aux [ch] more
		else	Nil
	end
);
=TEX
=SML
fun rec_ident ((chs, status) : LEX_STATE) : LEX_STATE = (
	case get_ident chs of
		Value(n, more) => (
			case e_lookup n keyword_dict of
				Value s =>(
					 (more,
					 Known (LVString (s, get_line_number())))
			) |	Nil => (
					 (more,
					 Known (LVIdentifier (n, get_line_number())))
			)
	) |	Nil => (chs, Unknown)
);
=TEX
=SML
fun get_oct_dec_num [] = Nil
| get_oct_dec_num (chs as (ch :: more)) = (
	let	fun aux acc [] = Value(implode(rev acc), [])
		|   aux acc (c::more) = (
			if	is_digit c
			then	aux (c::acc) more
			else	Value(implode(rev acc), c::more)
		);
	in	if	is_digit ch
		then	aux [ch] more
		else	Nil
	end
);
=TEX
=SML
fun rec_dec_num ((chs, status) : LEX_STATE) : LEX_STATE = (
	case get_oct_dec_num chs of
		Value(n, more) => (
			 (more,
			 Known (LVIdentifier ("IntegerConstant", get_line_number())))
	) |	Nil => (chs, Unknown)
);
=TEX
=SMLPLAIN
val punct_dict : string E_DICT = list_e_merge initial_e_dict (map (fn s => (s, s)) [
	"!=", "!", "%=", "%", "&&", "&=", "&", "(",
	")", "*=", "*", "++", "+=", "+", ",", "--",
	"-=", "->", "-", "...", ".", "/=", "/", ":",
	";", "<<=", "<<", "<=", "<", "==", "=", ">=",
	">>=", ">>", ">", "?", "[", "]", "^=", "^",
	"{", "|=", "|", "||", "}", "~"
]);
=TEX
In the following the magic number 2 is 1 less than the maximum length of a punctuation symbol.
=SML
fun  get_punct chs = (
	let	fun aux ~1 = Nil
		|    aux i = (
			case e_lookup (implode (chs to i)) punct_dict of
				Value s => Value(s, chs from(i+1))
			|	Nil => aux (i-1)
		);
	in	aux 2
	end
);
=TEX
=SML
fun rec_punct ((chs, status) : LEX_STATE) : LEX_STATE = (
	case get_punct chs of
		Value(n, more) => (
			(more, Known (LVString (n, get_line_number())))
	) |	Nil => (chs, Unknown)
);
=TEX
TBS: CharacterConstant, FloatingConstant, IntegerConstant, String
=SML
val rec_any = rec_first[rec_ident, rec_punct, rec_dec_num];
fun c_resolver _ = DoShift;
use"c1.grm.sml";
fun c_parse_file name = (
	reset_state();
	slrp'gen_parser c_resolver c_classifier
	(default_error string_of_lex_value)
	(gen_reader rec_any (in_char_stream_of_file name))
	([], true)
);
fun c_parse_string str = (
	reset_state();
	slrp'gen_parser c_resolver c_classifier
	(default_error string_of_lex_value)
	(gen_reader rec_any (in_char_stream_of_string str))
	([], true)
);
=TEX
=DUMP mdt118.1.c
static int table = {1, 2, 4, 8, 16};

int main(void)
{
	fprintf(stderr, sizeof table);
}
=SML
val t1 = (c_parse_file "mdt118.1.c");
print_tree (curry output std_out) t1;
store_mt_results
mt_run[
	("c1.1.1", f, t1, 216)
];
=TEX
\section{EPIILOGUE}
=SML
raw_diag_string (summarize_mt_results()^"\n");
=TEX
\end{document}
=IGN
