=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Standard ML Utilities}  %% Mandatory field
\def\TPPheadtitle{Implementation of Standard ML Utilities}
\TPPref{DS/FMU/IED/IMP001}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}
%\TPPstatus{Approved}
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{Utility functions for use in the Release 1 of ICL HOL
system are implemented in this document.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1 - 1.14]
Initial drafts up to desk check ID0061 and its rework.
\item [Issue 2.1 (12th September 1991)]
Approved version of issue 1.14.
\item [Issue 2.2 (21 November 1991)]
Addition of sparse arrays.

\item[Issue 2.3, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 2.4 (3rd February 1992)]
Changed $diag\_$ to $raw\_diag\_$.
\item [Issue 2.5 (30th March 1992)]
Added $filter$.
\item [Issue 2.6 (31st March 1992)]
Removed $gensym$.
\item [Issue 2.7 (1st April 1992)]
Renamed $set\_eq$ to $~=$.
\item [Issue 2.8 (13th April 1992)]
Changes due to CR0017.
\item [Issue 2.9 (28th May 1992)]
Changed implementation of $format\_list$.
\item [Issue 2.12 (14th December 1992)]
Added $set\_stats$.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation
of the detailed design in \cite{DS/FMU/IED/DTD001}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document implements definitions of some general purpose
Standard ML objects,
whose signatures are declared in \cite{DS/FMU/IED/DTD001}.
Many of these are general functions which
support some common functional programming idioms.
\subsubsection{Dependencies}
The definitions in this document are mostly self-contained
and depend only on the Standard ML facilities defined
in \cite{Harper86},
and on the error handling features of \cite{DS/FMU/IED/DTD002}.
The signatures for the document are in \cite{DS/FMU/IED/DTD001}.
Error messages numbers for this document are set in this document,
but their texts are assigned by \cite{DS/FMU/IED/DTD001}.
\subsubsection{Algorithms}
Nearly all the functions defined here are short
and straightforward.
When felt necessary, the algorithms used are discussed
in the narrative which accompanies each function.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
Versions of the general functions defined here
may well be supplied with particular
Standard ML compilers. It may improve performance if
the supplied versions are used.

Various functions could be recoded with auxiliary functions,
to avoid passing unchanging arguments through a recursive loop, and such-like putative optimisations.
\section{LIST UTILITIES}
=SML
structure ÛListUtilitiesÝ : ListUtilities = struct
=TEX
\subsection{Some Useful Datatypes and Functions upon them}
The datatype $'a\;OPT$ is declared in $UtilitySharedTypes$.
Occasionally we want to force a $'a\;OPT$ into a $'a$
raising an exception if the $'a\;OPT$ is $Nil$.
=SML
fun Ûforce_valueÝ (Value X : 'a OPT) : 'a = X
|   force_value Nil = fail "force_value" 1001 [];
=TEX
A test for $Nil$:
=SML
fun Ûis_NilÝ (Nil:'a OPT) : bool = true
|   is_Nil _ = false;
=TEX
\subsection{List Processing Functions}
Many of the following functions are supplied as standard with
some SML compilers. The definitions here could
be removed if we fix on a compiler with these supplied.

$hd$ and $tl$ are the usual destructor functions for
lists. 
They raise an exception when passed empty arguments.
=SML
fun ÛhdÝ (h :: _ : 'a list) : 'a = h
|   hd [] = fail "hd" 1002 [];
=TEX
=SML
fun ÛtlÝ (_ :: t : 'a list) : 'a list = t
|   tl [] = fail "tl" 1003 [];
=TEX
$fold\;f\;[x_1, x_2, \ldots, x_k]\;b$ is $f(x_1, f(x_2, \ldots f(x_k, b)) \ldots)$.
=SML
fun ÛfoldÝ (f : ('a*'b -> 'b)) (h :: t : 'a list) (b : 'b) : 'b = f (h, fold f t b)
|   fold (f : ('a*'b -> 'b)) ([] : 'a list) (b : 'b) = b;
=TEX
$revfold\;f\;[x_1, x_2, \ldots]\;b$  is
$f(x_k,\ldots f(x_2,(f(x_1, b)))\ldots)$
=SML
fun ÛrevfoldÝ (f : ('a*'b -> 'b)) (h :: t : 'a list) (b : 'b) : 'b = revfold f t (f(h, b))
|   revfold (f : ('a*'b -> 'b)) ([] : 'a list) (b : 'b) = b;
=TEX
$length$ returns the length of a list (this version written to avoid garbage generation).
=SML
local
	fun l n (_ :: t) = l (n+1) t
	| l n [] = n
in
	val ÛlengthÝ : 'a list -> int = l 0
end;
=TEX
=SML
fun ÛfilterÝ (pred : 'a -> bool) ([]:'a list) : 'a list = []
| filter pred (a :: x) = (if pred a
	then (a :: filter pred x)
	else filter pred x
);
=TEX
\subsection{Lists as Sets}
$drop$,  $less$ and $grab$ are infix operators with priority 4 (lower than
`::' and higher than `=').
$drop$ and $less$ are essentially the set difference operation.
$grab$ is union with a singleton set.

$contains$ searches for a member of
a list equal to a given value and returns true iff. it finds one.
=SML
fun ÛcontainsÝ ((x' :: xs)  : ''a list) (x: ''a) : bool = (
	(x = x') orelse contains xs x
) | contains ([]  : ''a list) (_ : ''a) = false;
=TEX
$mem$ is an infix form of $contains$.
=SML
fun (x: ''a) ÛmemÝ ((x' :: xs)  : ''a list) : bool = (
	(x = x') orelse x mem xs
) | (_ : ''a) mem ([]  : ''a list) = false;
=TEX
$present$ is an equality-parameterised membership test.
We use an auxiliary function to save passing two parameters,
and allow some minor partial evaluation.
=SML
fun ÛpresentÝ (eq : ('a * 'a) -> bool) (x: 'a) : 'a list -> bool = (
	let fun test (h :: t) = eq(x,h) orelse test t
	| test [] = false
	in
		test
	end
);
=TEX
$any$ returns true iff. some element of a list satisfies a given
condition.
=SML
fun ÛanyÝ ((x :: xs) : 'a list) (cond : 'a -> bool) : bool = (
	cond x orelse any xs cond
) | any ([] : 'a list) (_ : 'a -> bool) : bool = false;
=TEX
$all$ returns true iff. all elements of a list satisfy a given
property.
=SML
fun ÛallÝ ((x :: xs) : 'a list) (cond : 'a -> bool) : bool = (
	cond x andalso all xs cond
) |   all ([] : 'a list) (_ : 'a -> bool) : bool = true;
=TEX

$list\,drop\,cond$ is the list obtained by deleting all members
of $list$ for which the boolean function $cond$ returns true.
Could rewrite with auxiliary function.
=SML
fun ((x :: xs) : 'a list) ÛdropÝ (cond : 'a  -> bool) : 'a list = (
	if cond x
	then xs drop cond
	else x :: (xs drop cond)
) | ([] : 'a list) drop (_ : 'a  -> bool) : 'a list = [];
=TEX
$list\,less\,what$ is the list obtained by deleting all members
of $list$ which are equal to $what$.
=SML
fun ((x :: xs) : ''a list) ÛlessÝ (what : ''a) : ''a list = (
	if x = what
	then xs less what
	else x :: (xs less what)
) | ([] : ''a list) less (_ : ''a) : ''a list = [];
=TEX
$list\, grab\,what$ is the list obtained by inserting $what$
at the head of $list$ if it is not a member of it already.
=SML
fun (lst : ''a list) ÛgrabÝ (what : ''a) = (
	if what mem lst
	then lst
	else (what :: lst)
);
=TEX
=SML
fun ÛinsertÝ (eq:'a * 'a -> bool) (lst : 'a list) (what : 'a) = (
	if present eq what lst
	then lst
	else (what :: lst)
);
=TEX
$union$ is essentially a binary union operation for lists.
Since we need it to work on types which are
not equality types, it has a parameter giving the relation to be
used to determine equality of members of the lists.
In some cases it may be important for the order of members of the union
to be known. The rule is that $union\,eq\,list1\,list2$ is
the list obtained by prepending those elements of $list1$ not already present in $list2$, to the list $list2$.
Presence for $x$ in the list being created being
that there is a
member, $y$, of the list being created with $eq(x,\,y)\,=\,true$.
If $list1$ contains duplicates then all but the rightmost will be eliminated,
but those in $list2$ will not be.
Note also that if one of the lists is small it is better
supplied as the first list argument if efficiency is of
the essence.

Could rewrite $insert\_it$ with auxiliary function.
=SML
fun ÛunionÝ (eq : ('a*'a) -> bool) (list1 : 'a list)(list2 : 'a list) : 'a list = (
	let
		fun insert_it (what, lst) = (
			if present eq what lst
			then lst
			else (what :: lst)
		);
	in
		fold insert_it list1 list2
	end
);
=TEX
For convenience and performance we supply the special
case of $union$ 
when the equality function is ordinary SML equality.
This is the following infix function $cup$:
=SML
fun (list1 : ''a list) ÛcupÝ (list2 : ''a list) : ''a list = (
	fold (fn(x, xs) => xs grab x) list1 list2
);
=TEX
$list\_union$ is essentially a distributed union operation for lists.
=GFT Example
list_union eq [list0, list1, ...] = union eq (list0 union eq (list1 ...)).
=TEX
=SML
fun Ûlist_unionÝ (eq : ('a * 'a) -> bool) (lists : 'a list list) : 'a list = (
	fold (fn (l1, l2) => union eq l1 l2) lists []
);
=TEX
For convenience and performance again, we supply
$list\_cup$: the special case of $list\_union$ when the
equality operator is ordinary SML equality.
=SML
fun Ûlist_cupÝ (lists : ''a list list) : ''a list = (
	fold op cup lists []
);
=TEX
$find$ searches for a member of a list satisfying a given condition and
returns such a member if there is one.
=SML
fun ÛfindÝ ((x :: xs)  : 'a list) (cond: 'a -> bool) : 'a = (
	if cond x
	then x
	else find xs cond
) | find ([]  : 'a list) (_ : 'a -> bool) = fail "find" 1004 [];
=TEX
$l1\,subset\,l2$ is true iff. all the elements of $l1$
are  also elements of $l2$
=SML
fun (x : ''a list) ÛsubsetÝ (y : ''a list) : bool = (
	all x (fn a => a mem y)
);
=TEX
Given two lists, considered as sets are they equal:
=SML
fun ([]: ''a list)  Û~=Ý ([]:''a list) : bool = true 
| [] ~= _  = false
| _ ~= [] = false
| (a1 :: x1) ~= l2 = (
let fun aux acc (a2 :: x2) = (
	if (a1 = a2)
	then (true, acc @ (x2 less a1))
	else aux (a2 :: acc) x2
	) | aux acc [] = (false, []);

	val (ok,res) = aux [] l2;
in
	ok andalso ((x1 less a1) ~= res)
end);
=TEX
$diff$ is the set difference operator for lists.
=SML
fun (list1 : ''a list) ÛdiffÝ (list2 : ''a list) : ''a list = (
	list1 drop (fn x => x mem list2)
);
=TEX
\subsection{Lists of Pairs as Functions and Relations}
We will frequently implement functions or relations as
lists of pairs. The following associative lookup functions are
used to implement application of such functions or relations.
We will need some variations on the same theme.
Each variation has left- and right-handed versions.

They could all be rewritten with auxiliary functions.

The first two variations are used to view a list of pairs as
representing a total function. The function is applied to an argument
by looking for the first member in the list with that argument
in the appropriate position. In the first variation the function
is made total by taking the argument as the result if there is no
appropriate member of the list.
=SML
fun Ûlassoc1Ý ((x, y) :: rest : (''a * ''a) list) (what : ''a) : ''a = (
	if x = what
	then y
	else lassoc1 rest what
) | lassoc1 [] what = what;
=TEX
=SML
fun Ûrassoc1Ý ((x, y) :: rest : (''a * ''a) list) (what : ''a) : ''a = (
	if y = what
	then x
	else rassoc1 rest what
) | rassoc1 [] what = what;
=TEX
In the second variation, an ML function
to compute the value in this case is supplied as an argument.
=SML
fun Ûlassoc2Ý
	((x, y) :: rest : (''a * 'b) list)
	(default : ''a -> 'b)
	(what : ''a) : 'b = (
	if x = what
	then y
	else lassoc2 rest default what
) | lassoc2 [] default what = default what;
=TEX
=SML
fun Ûrassoc2Ý
	((x, y) :: rest : ('a * ''b) list)
	(default : ''b -> 'a)
	(what : ''b) : 'a = (
	if y = what
	then x
	else rassoc2 rest default what
) | rassoc2 [] default what = default what;
=TEX
The third variation treats the list as defining a partial
function. An error is signaled if the list does not
contain an appropriate pair.  
=SML
fun Ûlassoc3Ý ((x, y) :: rest : (''a * 'b) list) (what : ''a) : 'b = (
	if x = what
	then y
	else lassoc3 rest what
) | lassoc3 [] _ = fail "lassoc3" 1005 [];
=TEX
=SML
fun Ûrassoc3Ý ((x, y) :: rest : ('a * ''b) list)(what : ''b) : 'a = (
	if y = what
	then x
	else rassoc3 rest what
) | rassoc3 [] _ = fail "rassoc3" 1005 [];
=TEX
The fourth variation is the special case of the second
in which a constant default is to be used.
=SML
fun Ûlassoc4Ý
	((x, y) :: rest : (''a * 'b) list)
	(default : 'b)
	(what : ''a) : 'b = (
	if x = what
	then y
	else lassoc4 rest default what
) | lassoc4 [] default _ = default;
=TEX
=SML
fun Ûrassoc4Ý
	((x, y) :: rest : ('a * ''b) list)
	(default : 'a)
	(what : ''b) : 'a = (
	if y = what
	then x
	else rassoc4 rest default what
) | rassoc4 [] default _ = default;
=TEX
A fifth variation uses the datatype $'a\;OPT$ to implement
the partial function.
=SML
fun Ûlassoc5Ý ((x, y) :: rest : (''a * 'b) list) (what : ''a) : 'b OPT = (
	if x = what
	then Value y
	else lassoc5 rest what
) | lassoc5 [] _ = Nil;
=TEX
=SML
fun Ûrassoc5Ý ((x, y) :: rest : ('a * ''b) list)(what : ''b) : 'a OPT = (
	if y = what
	then Value x
	else rassoc5 rest what
) | rassoc5 [] _ = Nil;
=TEX
The following functions facilitate the creation and
modification of functions represented as lists of pairs.
They are similar to the function override notion in Z.
$overwrite$ overwrites with a single element,
$list\_overwrite$ with a list of elements.
Both work with the argument before value representation
(corresponding to $lassoc\ldots$ above).

Could rewrite with auxiliary function.
=SML
fun (((a, b) :: abs) : (''a * 'b) list) ÛoverwriteÝ ((x, y) : ''a * 'b) : (''a * 'b) list = (
	if a = x
	then (x, y) :: abs
	else (a, b) :: (abs overwrite (x, y))
) | [] overwrite (x, y) = [(x, y)];
=TEX
=SML

fun (abs : (''a * 'b) list) Ûlist_overwriteÝ (xys : (''a * 'b) list) : (''a * 'b) list = (
	fold (fn (l1, l2) => l2 overwrite l1) xys abs
);
=TEX
$roverwrite$ and $list\_roverwrite$ are the value before
argument versions of the above.
=SML
fun (((a, b) :: abs) : ('a * ''b) list) ÛroverwriteÝ ((x, y) : 'a * ''b)  : ('a * ''b) list = (
	if b = y
	then (x, y) :: abs
	else (a, b) :: (abs roverwrite (x, y))
) | ([] : ('a * ''b) list) roverwrite (x, y) = [(x, y)];
=TEX
=SML
fun (abs : ('a * ''b) list) Ûlist_roverwriteÝ (xys : ('a * ''b) list) : ('a * ''b) list = (
	fold (fn (l1, l2) => l2 roverwrite l1) xys abs
);
=TEX
\subsection{Another Miscellany}
$is\_nil$ tests whether a list is []. It can be
used for lists of types which do not admit equality.
=SML
fun Ûis_nilÝ ([] : 'a list) : bool = true
|   is_nil ( _ : 'a list) : bool = false;
=TEX
$flat$ takes a list of lists and returns the result of
concatenating them all.
=SML
fun ÛflatÝ  (lists : 'a list list) : 'a list = (
	fold op @ lists []
);
=TEX
$split$ takes a list of pairs:
=GFT Example
[(x_0, y_0), (x_1, y_1), ... (x_k, y_k)]
=TEX
say, and returns
the pair of lists:
=GFT Example
[x_0, x_1, ... , x_k],  [y_0, y_1, ... , y_k]
=TEX
=SML
fun ÛsplitÝ ((x, y) :: xys : ('a * 'b) list) : ('a list) * ('b list) = (
	let	val (xs, ys) = split xys
	in	(x :: xs, y :: ys)
	end
) | split [] = ([], []);
=TEX
$split3$ is the analogue of $split$ for lists of triples.
=SML
fun Ûsplit3Ý ((x, y, z) :: xyzs : ('a * 'b * 'c) list) : ('a list) * ('b list) * ('c list) = (
	let	val (xs, ys, zs) = split3 xyzs
	in	(x :: xs, y :: ys, z :: zs)
	end
) | split3 [] = ([], [], []);
=TEX
$combine$ is the left inverse of $split$; it signals an error
if its arguments are not lists of equal length.
=SML
fun ÛcombineÝ ((x :: xs) : 'a list) ((y :: ys) : 'b list) : ('a * 'b) list = (
	(x, y) :: combine xs ys
) | combine ([] : 'a list) ([] : 'b list) : ('a * 'b) list = []
|   combine _ _ = fail "combine" 1007 [];
=TEX
$all\_different$ determines whether a list has any
repeated entries:
=SML
fun Ûall_differentÝ (x :: xs : ''a list) : bool = (
	not (x mem xs) andalso all_different xs
) |   all_different [] = true;
=TEX
$all\_distinct$ determines whether a list has any
repeated entries using a given function to test for
equality.
=SML
fun Ûall_distinctÝ (eq : ('a * 'a) -> bool) (x :: xs : 'a list) : bool = (
	not (present eq x xs) andalso all_distinct eq xs
) | all_distinct eq [] = true;
=TEX
The infix functions $from$ and $to$ take
slices of lists. The conventions are such
that, e.g. $$[0,1,2,3] from 2 = [2,3]$$ and
$$[0,1,2,3] to 2 = [0,1,2]$$.
=SML
fun ((h :: t) : 'a list) ÛfromÝ (n : int) : 'a list = (
	if n > 0
	then t from (n-1)
	else h :: t
) | [] from _ = [];
=TEX
=SML
fun ((h :: t): 'a list) ÛtoÝ (n: int) : 'a list = (
	if n >= 0
	then h :: (t to (n-1))
	else []
) | [] to _ = [];
=TEX
$interval\;a\;b$ is the list $[a,a+1,a+2\ldots,b]$.
This is taken to be $[]$ if $a > b$ and to be $[a]$
if $a = b$.
Could rewrite with auxiliary function.
=SML
fun ÛintervalÝ (a:int) (b:int) : int list = (
	if a < b
	then a :: interval (a+1) b
	else if a = b
	then [a]
	else []
);
=TEX
Map a function over a list - failure on an element is treated as do not include in the list.
=SML
fun ÛmapfilterÝ (f : 'a -> 'b) ((x :: xs) : 'a list) = (
	([f x] handle (Fail _) => []) @ mapfilter f xs
) | mapfilter _ [] = [];
=TEX
=SML
fun ÛzipÝ (lf_hd :: lf_tl: ('a -> 'b)list) (lt_hd :: lt_tl: 'a  list): 'b list = (
	lf_hd lt_hd :: (zip lf_tl lt_tl)
) | zip [] [] = []
| zip _ _ = fail "zip" 1008 [];
=TEX
=SML
fun ÛnthÝ n ((a: 'a) :: al): 'a = (
	if n = 0 then a else nth (n-1) al
) | nth n [] = fail "nth" 1009 [];
=TEX
=SML
fun ÛwhichÝ (eq: ('a * 'a) -> bool) (v: 'a) (lt: 'a list): int OPT = (
let 
	fun lwhich (n: int) ((a: 'a) :: al): int OPT = (
		if eq (v, a) 
		then Value n 
		else lwhich (n+1) al
	) | lwhich n [] = Nil
in
	lwhich 0 lt
end);
=TEX

\subsection{End of ListUtilities}
=SML
end (* of ListUtilities *);
open ListUtilities;
=TEX
\section{FUNCTION UTILITIES}
=SML
structure ÛFunctionUtilitiesÝ : FunctionUtilities = struct
=TEX
\subsection{Pairs}
$fst$ and $snd$ are the projection functions for pairs.
=SML
fun ÛfstÝ (a, _) = a;

fun ÛsndÝ (_, b) = b;
=TEX
$swap$ interchanges the elements of a pair
=SML
fun ÛswapÝ (a, b) = (b, a);
=TEX
\subsection{Functionals}
Certain higher-order functions are useful.
$curry$ and $uncurry$ convert a function with a pair
of arguments into a function with an argument pair (and
vice versa).
=SML
fun ÛcurryÝ (f : ('a * 'b) -> 'c) : 'a -> 'b -> 'c = (
	(fn a => (fn b => f(a, b)))
);

fun ÛuncurryÝ (f : 'a -> 'b -> 'c) : ('a * 'b) -> 'c = (
	(fn (a, b) => f a b)
);
=TEX
$switch$ reverse the order of the arguments of a
two argument function.
=SML
fun ÛswitchÝ (f:'b -> 'a -> 'c) (a : 'a) (b : 'b) : 'c = f b a;
=TEX
The infix operator ``**'', with precedence 4 (higher
than ``$o$''), gives the function induced by a pair
of functions from the product of their domains to
the product of their codomains. (To use categorical
language it is is the morphisms part of the product
functor.)
=SML

fun (f : 'a1 -> 'b1) Û**Ý (g : 'a2 -> 'b2) : ('a1 * 'a2) -> ('b1 * 'b2) = (
	(fn (x1, x2) => (f x1, g x2))
);
=TEX
For non-negative $n$,
$fun\_pow (n:int) (f:'a->'a)$ is $f^n$, i.e. the
function $Ìx·f(f( ... f(f x) ....)$, where $f$
appears $n$ times.
=SML
fun Ûfun_powÝ (n:int) (f:'a->'a) (v:'a) : 'a = (
	if n > 0
	then fun_pow (n-1) f (f v)
	else if n = 0
	then v
	else fail "fun_pow" 1010 []
);
=TEX
=SML
fun ((f: 'a -> bool) Ûfun_andÝ (g: 'a -> bool)) (x: 'a) : bool = (
	f x andalso g x
);
fun ((f: 'a -> bool) Ûfun_orÝ (g: 'a -> bool)) (x: 'a) : bool = (
	f x orelse g x
);
fun Ûfun_notÝ (f: 'a -> bool) (x: 'a) : bool = (
	not(f x)
);
val Ûfun_trueÝ : 'a -> bool = (fn x => true);
val Ûfun_falseÝ : 'a -> bool = (fn x => false);
=TEX
The detailed design for the following refers to catching any failure:
our implementation will only catch $Fail$ exceptions,
following our conventions for exception handling.
=SML
fun ÛrepeatÝ (f: unit -> 'a) : unit = (
	(f (); repeat f) handle (Fail _) => ()
);
fun ÛiterateÝ (f : 'a -> 'a) (a:'a): 'a = (
	iterate f (f a) handle (Fail _) => a
);
end (* of FunctionUtilities *);
open FunctionUtilities;
=TEX
\section{COMBINATORS}
It can be convenient to have the definitions of
certain combinators. We package these in a structure
(since their conventional names are single letters).
=SML
structure ÛCombinatorsÝ : Combinators = struct
	fun ÛIÝ (x: 'a) : 'a = x;
	fun ÛKÝ (x : 'a) (_ : 'b) : 'a = x;
	fun ÛSÝ (f: 'a -> 'b -> 'c) (g  : 'a -> 'b) (x : 'a): 'c = f x (g x);
end (* of Combinators *);

=TEX
\section{I/O}
=SML
structure ÛSimpleOutputÝ : SimpleOutput = struct
=TEX
Currently we offer a rudimentary output facility
for messages to the user.

We first need a mechanism for the user to set and get a line length, that defaults to 80.
{\em set\_line\_length} returns the old value of the
setting.
The actual value, {\em line\_length}, is declared and handled by the utilities within SystemControls.
=SML
local 
	val line_length: int ref = ref 80;
	val _ = new_int_control{name="line_length",
		control=line_length,
		default=(fn u => 80),
		check = (fn x => if x >= 20
			then true
			else fail "set_line_length" 1015 [])};
in
fun Ûset_line_lengthÝ (n: int): int = set_int_control ("line_length", n);
fun Ûget_line_lengthÝ (():unit): int = get_int_control "line_length";
end;
=TEX
$raw\_diag\_string$ outputs
a string on the standard output stream.
If the string exceeds the value of {\em get\_line\_length} it attempts to split the string into tokens, to fit within the line length.
A token is taken to be an initial string of spaces, followed by exclusively non-space characters.
=SML
fun Ûraw_diag_stringÝ ("" : string) : unit = ()
| raw_diag_string (s : string) : unit = (
	let val ss = explode s;
		val line_length = get_line_length();
		fun to_first_space (" "::rest) = []
		| to_first_space (a :: rest) = (a:: to_first_space rest)
		| to_first_space [] = [];
		fun to_first_space2 (" "::rest) = (" ":: to_first_space2 rest)
		| to_first_space2 (a :: rest) = (a:: to_first_space rest)
		| to_first_space2 [] = [];

		fun fill_rest_of_line l_so_far [] = []
		| fill_rest_of_line l_so_far str =
		let
			val next_chunk = to_first_space2 str
			val l_next_chunk = length next_chunk
		in
			if (l_next_chunk + l_so_far) <= line_length
			then (output(std_out, implode next_chunk);
				fill_rest_of_line (l_next_chunk + l_so_far) 
				 (str from l_next_chunk))
			else (output(std_out, "\n"); str)
		end;
		fun first_part_of_line str =
		let
			val next_chunk = to_first_space2 str
			val l_next_chunk = length next_chunk
		in
			(output(std_out, implode next_chunk);
				fill_rest_of_line l_next_chunk (str from l_next_chunk))
		end;
		fun print_lines [] = output(std_out, "\n")
		| print_lines str = print_lines(first_part_of_line str)
	in
		if length ss <= line_length
		then (output(std_out, s); output(std_out, "\n"))
		else print_lines ss
	end
);
=TEX
$raw\_diag\_string\_list$ outputs a list of strings
onto the standard output stream. The strings in the list
are concatenated (with spaces to separate them) and then
output with $raw\_diag\_string$. 
=SML
fun Ûlist_raw_diag_stringÝ (s : string list) : unit = (
    let
        fun aux ((s :: []) : string list) = s
        |   aux ((s :: t) : string list) = s ^ " " ^ aux t
        |   aux [] = "";
    in
        raw_diag_string (aux s)
    end
);
=TEX
$raw\_diag\_line$ outputs a string to the standard output
stream followed by a new line.
It is intended for use in printing formatted terms,
theorems and the like (for which the pretty printer
will have included new lines within the string if
necessary ).
=SML
fun Ûraw_diag_lineÝ (s : string) : unit = (
        output(std_out, s);
        output(std_out, "\n")
);
=TEX
$format\_list$ is used to format a list of items for printing
as a string, given a function to format a single item
and a string to separate elements of a multi-element
list.
=SML
fun	Ûformat_listÝ
	(format_it : 'a -> string)
	(what : 'a list) (sep : string): string = (
let
	fun aux [] = []
	| aux (h :: []) = (format_it h) :: []
	| aux (h :: t) = (format_it h) :: sep :: (aux t);
in
	implode(aux what)
end);
=TEX
=SML
end (* of SimpleOutput *);
open SimpleOutput;
=TEX
\section{CHARACTER UTILITIES}
=SML
structure ÛCharacterUtilitiesÝ : CharacterUtilities = struct
=TEX
$is\_all\_decimal$ checks whether a string consists
of one or more decimal digits.
=SML
local
	val ord0 = ord "0";
	val ord9 = ord "9";
in
fun Ûis_all_decimalÝ (s : string) : bool = (
	s <> "" andalso
	all (explode s) ((fn x => x >= ord0 andalso x <= ord9) o ord)
);
end;
=TEX
\subsection{Numeric Conversions}
$nat\_of\_string$ converts a string into non-negative
integer (using decimal notation). It raises an exception
if that cannot be done.
=SML
local
	val ord0 = ord "0"
in
fun Ûnat_of_stringÝ (s : string) : int = (
	let	val cs = rev(explode s);
		fun aux (dig :: digs) = (
			let	val n = ord dig - ord0;
			in	if n >= 0 andalso n <= 9
				then n + (10 * aux digs)
				else fail "nat_of_string" 1012 [(fn (():unit) => s)]
			end
		) | aux [] = 0;
	in	case cs of
			[] => fail "nat_of_string" 1013 []
		|	_ => aux cs
	end
);
end;
=TEX
$string\_of\_int$ converts an integer into a decimal
string. (SML's library function $makestring$ would
nearly do, but we want negative numbers to be shown
with a minus sign, and we do not want 
to be affected by $PolyML.print\-\_depth$ being set to 0.)
=SML
local
	val ord0 = ord "0"
in
fun Ûstring_of_intÝ (n : int) : string = (
	let	fun aux m = ( (* assumes m > 0 *)
			case m div 10 of
				0 => chr(ord0 + (m mod 10))
			|	mdiv10 => aux mdiv10 ^ chr(ord0 + (m mod 10))
		);
	in	if n > 0
		then aux n
		else if n = 0
		then "0"
		else "-" ^ aux (~n)
	end
);
end;
=TEX
=SML
end (* of CharacterUtilities *);
open CharacterUtilities;
=TEX

\section{DICTIONARIES}
To implement HOL theories and the theory hierarchy
we need to represent the type and constant environments
of the formal specification (\cite{DS/FMU/IED/SPC001}).
These environments are essentially partial functions from
$string$ to values of suitable type.

The operations required on these partial functions
are: application,
extension by a singleton function, deletion of elements
from the domain and overwriting both
by singleton functions and by arbitrary partial function.
This is similar to what is typically required for
the symbol table of a compiler.
We will call a data structure together with functions
to perform these operations a ``dictionary''.

We offer two generic implementations of dictionaries
here. The first implementation uses linear search
and performs slowly when the data structures become
large. The second implementation uses a hash addressing technique
and gives considerably more efficient access than the simple
implementation to larger data structures.
\subsection{Simple Dictionaries}
=SML
structure ÛSimpleDictionaryÝ : SimpleDictionary = struct
=TEX

These are straightforward. We use the prefix $s\_$ to
distinguish the types and functions involved from those
used for the more efficient technique.

We define a simple dictionary to be a list of
pairs in UtilitySharedTypes.
The functions for accessing and modifying
dictionaries are essentially just interfaces to the
partial function operations defined in
previous sections:

$s\_lookup$ implements application (of the dictionary
viewed as a partial function):
=SML
fun Ûs_lookupÝ (s : string) (dict : 'a S_DICT) : 'a OPT = (
	lassoc5 dict s
);
=TEX
$s\_enter$ implements overwriting by a singleton function:
=SML
fun Ûs_enterÝ (s : string) (a : 'a) (dict : 'a S_DICT) : 'a S_DICT = (
	dict overwrite (s, a)
);
=TEX
$s\_extend$ implements extension by a singleton function,
that is to say it is like $s\_enter$  but raises an
exception if the new argument is already
in the domain of the dictionary:
=SML
fun Ûs_extendÝ (s : string) (a : 'a) (dict : 'a S_DICT) : 'a S_DICT = (
	case lassoc5 dict s of
	Value _ => fail "s_extend" 1014 [fn (():unit) => s]
	| Nil => (s,a) :: dict
);
=TEX
$s\_delete$ deletes an element of the domain of a dictionary.
If the element is not in the domain it returns the
dictionary unchanged.
=SML
fun Ûs_deleteÝ (s : string) (dict : 'a S_DICT) : 'a S_DICT = (
	dict drop (fn (s', _) => s' = s)
);
=TEX
$s\_merge$ extends one dictionary by another.
An exception will be raised if the domains of the
two dictionaries have elements in common.
=SML
fun Ûs_mergeÝ (dict1 : 'a S_DICT) (dict2 : 'a S_DICT) : 'a S_DICT = (
	fold (uncurry(uncurry s_extend)) dict1 dict2
);
=TEX
The initial value of the dictionary is just the empty list.
=SML
val Ûinitial_s_dictÝ : 'a S_DICT = [];
=TEX
=SML
end (* of SimpleDictionary *);

open SimpleDictionary;
=TEX

\subsection{Efficient Dictionaries}
=SML
structure ÛEfficientDictionaryÝ : EfficientDictionary = struct
=TEX
The technique we use for the more efficient dictionaries
is essentially the standard compiler writer's technique
of hash addressing with chaining to handle collisions
(see, for example, \cite{Bornat79}).

To access such a dictionary given a string $s$, we first
compute a $hash$ $key$, which is an integer, $k$ say, in some
fixed range. We then use $k$ to index an array of lists of
pairs. The $k$-th entry in this array is, effectively,
a simple dictionary representing the restriction of the
dictionary (viewed as a partial function) to elements
with hash key $k$.

Since Standard ML has no array data type we use binary
trees to simulate arrays. Note that these trees never
grow to have more than $R$ (internal) nodes where
$R$ is the number of possible hash keys. The idea of
using the hashing approach rather than binary search trees with
one node per dictionary entry is to avoid string
comparisons.

(For a typical access in a dictionary with $N$ entries,
with $N >> R$,
we are performing approximately $\log R$ integer comparisons plus
$N / 2 R$ string equality tests, rather than $\log N$
string comparisons. Since the string comparison operation
is not supplied as primitive in Standard ML, it seems
likely that $N$ would have to be much larger than
is expected here for the tree search technique to be more
efficient. This assertion has not been scientifically
verified.)

The code for the more efficient dictionaries is quite
straightforward. We use the prefix $e\_$ to distinguish
names from those used for the simple dictionaries.
We package the dictionary code in an abstract data type
since the implementation may well change if the performance
is not satisfactory.

Inside the abstract data type we see that an efficient
dictionary is, as promised above, a binary tree whose
internal nodes contain integer keys and simple dictionaries.
=SML
abstype 'a ÛE_DICTÝ	=	ÛLeafÝ
			|	ÛNodeÝ of int * ('a S_DICT) * ('a E_DICT) * ('a E_DICT)
with
=TEX
The hashing function, $hash$ is local to the abstract
data type. The function chosen has no special merit
except that it is reasonably simple and appears to give
an acceptable spread of values for some typical strings.
Essentially, we divide the string into three-character
slices starting at the left and adding null characters
to the right of the last slice if necessary. We view
each three-character slice as a base 256 number and
take the sum of the slices modulo $2^{24} - 1$.
The hash key is the result of this taken modulo 127.
=SML
local
	open SimpleDictionary;
	val prime = 127;
	val H = 256;
	val Hsq = 256 * 256;
	val Hcubedless1 = 256 * 256 * 256 - 1;
	fun hash (s : string) : int = (
		let
			fun  aux (X1 :: []) = (ord X1 * Hsq)
			|  aux (X1 :: X2 :: []) = (ord X2 * H + ord X1) * H
			| aux (X1 :: X2 :: X3 :: rest) =
				(((((ord X3 * H) + ord X2) * H) + ord X1)  + aux rest)
				mod Hcubedless1
			|  aux [] = 0;
		in	aux (explode s) mod prime
		end
	);
in
=TEX
The various operations on the dictionaries are straightforward
to code.
In each case we precompute the hash key of the string
argument then apply an auxiliary function to perform
the desired operation.

Like $s\_lookup$, $e\_lookup$ implements application:
=SML
	fun Ûe_lookupÝ (s : string) (dict : 'a E_DICT) : 'a OPT = (
		let	val k = hash s;
			fun aux Leaf = Nil
			| aux (Node(k', pairs, l, r)) = (
				if k < k'
				then aux l
				else if k = k'
				then lassoc5 pairs s
				else aux r
			);
		in	aux dict
		end
);
=TEX
Like $s\_enter$,
$e\_enter$ implements overwriting by a singleton function:
=SML
	fun Ûe_enterÝ (s : string) (a : 'a) (dict : 'a E_DICT) : 'a E_DICT = (
		let	val k = hash s;
			fun aux Leaf = Node (k, [(s, a)], Leaf, Leaf)
			| aux (Node(k', pairs, l, r)) = (
				if k < k'
				then Node(k', pairs, aux l, r)
				else if k = k'
				then Node(k', pairs overwrite (s, a), l, r)
				else Node(k', pairs, l, aux r)
			);
		in	aux dict
		end
	);
=TEX
Like $s\_extend$,
$e\_extend$ implements extension by a singleton function:
=SML
	fun Ûe_extendÝ (s : string) (a : 'a) (dict : 'a E_DICT) : 'a E_DICT = (
		let	val k = hash s;
			fun aux Leaf = Node (k, [(s, a)], Leaf, Leaf)
			| aux (Node(k', pairs, l, r)) = (
				if k < k'
				then Node(k', pairs, aux l, r)
				else if k = k'
				then	case lassoc5 pairs s of
						Nil => Node(k', ((s, a) :: pairs), l, r)
					|	Value _ => fail "e_extend" 
							1014 [fn (():unit) => s]
				else Node(k', pairs, l, aux r)
			);
		in	aux dict
		end
	);
=TEX
Like $s\_delete$, $e\_delete$ deletes an element from
the domain of a dictionary:
=SML
	fun Ûe_deleteÝ (s : string) (dict : 'a E_DICT) : 'a E_DICT = (
		let	val k = hash s;
			fun aux Leaf = Leaf
			|   aux (Node(k', pairs, l, r)) = (
				if k < k'
				then Node(k', pairs, aux l, r)
				else if k = k'
				then Node(k', pairs drop (fn (s',_) => s' = s), l, r)
				else Node(k', pairs, l, aux r)
			);
		in	aux dict
		end
	);
=TEX
Before defining $e\_merge$ we first define operations
which allow efficient dictionaries to be converted
into simple ones and vice versa.

$e\_flatten$ converts an efficient dictionary into a simple one.
Notice the ordering of a flattened node's components - this is done to attempt to address the problem of gaining an unbalanced tree if one flattens a dictionary, and then rebuilds it.
The order chosen is likely to cause the creation of a dictionary with a similar structure and balance to the original.
=SML
	fun Ûe_flattenÝ (dict : 'a E_DICT) : 'a S_DICT = (
		case dict of
			Leaf => []
		|	Node(_, pairs, l, r) => pairs @ e_flatten l @ e_flatten r
	);
=TEX
$list\_e\_merge$ extends an efficient dictionary by a simple
one. Note that this operation raises an exception if the domains of the
two dictionaries have elements in common.
=SML
	fun Ûlist_e_mergeÝ (dict1 : 'a E_DICT) (pairs : 'a S_DICT) : 'a E_DICT = (
		fold (uncurry(uncurry e_extend)) pairs dict1
	);
=TEX
$e\_merge$ extends one efficient dictionary by another.
Again, note that this operation raises an exception if the domains of the
two dictionaries have elements in common.
=SML
	fun Ûe_mergeÝ (dict1 : 'a E_DICT) (dict2 : 'a E_DICT) : 'a E_DICT = (
		list_e_merge dict1 (e_flatten dict2)
	);
=TEX
The final item declared in the abstract data type for
efficient dictionaries is an empty dictionary, which
gives a starting point for the use of the above functions.

Arguably, $initial\_e\_dict$ should be given as a tree
containing all the possible hash keys each with an empty
simple dictionary. This can easily be done so that
the tree is balanced. The hashing function we have used
gives rise to reasonably well-balanced trees on all the
sample data sets tried, so this speed-for-space
optimisation has not been made.
=SML
	val Ûinitial_e_dictÝ : 'a E_DICT = Leaf;

end (* of local ... in ... end *)
end; (* of abstype E_DICT *)
=TEX
=SML
end (* of EfficientDictionary *);

open EfficientDictionary;
=TEX
\section{CODE PROFILING}
The following definitions may be used to record
statistics, e.g., on the number of times certain
functions have been called.
=SML
structure ÛProfilingÝ : Profiling = struct
local
	open EfficientDictionary;
	val stats : int E_DICT ref = ref initial_e_dict;
	val profiling : bool ref = ref true;
	val _= new_flag{name="ÛprofilingÝ",
		control = profiling,
		default = fun_true,
		check = fun_true};
in
fun ÛprofÝ (name : string) : unit = (
	if !profiling
	then
		stats := 
		e_enter
		name
		(case e_lookup name (!stats) of
			Value n => n + 1
		|	Nil => 1)
		(!stats)
	else ()
);
fun ÛcountsÝ (name: string) : int OPT = e_lookup name (!stats);

fun Ûprint_statsÝ (i_d : int S_DICT) : unit = (
	map (raw_diag_string o (fn (n, i: int) => n ^ " : " ^ string_of_int i)) i_d;
	()
);

fun Ûget_statsÝ (():unit) : int S_DICT = e_flatten (!stats);

fun Ûinit_statsÝ (():unit) : unit = (
	stats := initial_e_dict;
	()
);

fun Ûset_statsÝ (stts: int S_DICT) : unit = (
let	val estats = list_e_merge initial_e_dict stts
		handle (Fail _) => fail "set_stats" 1020 [];
	val dummy = (stats := estats);
in
	()
end);	
end(* of local *)
end(* of Profiling *);
open Profiling;
=TEX
\section{SORTING UTILITIES}
It is convenient here and elsewhere to have a reasonably
efficient sort function.
In this section we define a structure $Sort$ which
supplies such a function and some associated
utilities.
The structure has the following signature:
=SML
structure ÛSortÝ : Sort = struct
=TEX
The sorting of items of type $'a$ is parameterised by an
ordering function of type $'a -> 'a -> int$.
The integer, say $n$ returned by an application
of this function, say $f\ a1\ a2$, is interpreted as
follows: 
\begin{description}
\item[$n < 0$] $a2$ is to come after $a1$ (i.e. the arguments are in order)
\item[$n > 0$] $a2$ is to come before $a1$ (i.e. the arguments are out of order)
\item[$n = 0$] $a2$ is to be taken as equal to $a1$
\end{description}
Note that the sorting function returns a list with
no duplicate entries with respect to the equality
relation determined by the ordering function.

By way of an example, to sort integers in ascending order,
you would use $curry (op -)$.

\subsection{$lexicographic$}
This function returns the lexicographic ordering
function induced from an ordering
of items of type $'a$ on items of type $'a\,list$.
=SML
fun ÛlexicographicÝ (order : 'a -> 'a -> int) : ('a list) -> ('a list) -> int = (
	let	fun aux [] [] = 0
		| aux [] _ = ~1
		| aux _ [] = 1
		| aux (x :: xs) (y :: ys) = (
			case order x y of
				0 => aux xs ys
			|	NonZero => NonZero
		);
	in	aux
	end
);
=TEX
\subsection{$string\_order$}
This function gives a more civilised ordering on
strings than the one given by the ASCII codes.
It first does a lexicographic (q.v) case-insensitive ordering, 
with alphabetics before the rest, but otherwise in ASCII order, on exploded strings.
If two strings are otherwise equal then a case-sensitive
comparison is made, with the string having the first unmatched capitalisation being ordered as first.
The integer result is appropriate for use in $sort$ (q.v.).
=SML
local
	val orda = ord "a";
	val ordz = ord "z";
	val ordA = ord "A";
	val ordZ = ord "Z";
	val atoA = ordA - orda;
	datatype CASE = Ucase | Lcase | Other;
	fun classify (x : int) : CASE = (
		if x < ordA
		then Other
		else if x <= ordZ
		then Ucase
		else if (orda <= x) andalso (x <= ordz)
		then Lcase
		else Other
	);
	fun charorder (x : int) (y : int) : int = (
		case (classify x, classify y) of
			(Ucase, Ucase) => x - y
		|	(Lcase, Lcase) => x - y
		|	(Ucase, Lcase) => x - (y + atoA)
		|	(Lcase, Ucase) => (x + atoA) - y
		|	(Ucase, Other) => ~1
		|	(Lcase, Other) => ~1
		|	(Other, Ucase) => 1
		|	(Other, Lcase) => 1
		|	(Other, Other) => x - y
	);
in
	fun Ûstring_orderÝ (s1 : string) (s2 : string) : int = (
let	val es1 = map ord (explode s1);
	val es2 = map ord (explode s2);
	val case_ins = lexicographic charorder es1 es2;
in
	if case_ins = 0
	then  (	if s1 = s2
		then 0
		else lexicographic (curry(op -)) es1 es2
	) else case_ins
end);
end;
=TEX
\subsection{$sort$}
The sorting algorithm is a common one: insert
everything into a binary tree and then flatten the tree.
=SML
fun ÛsortÝ (order : 'a -> 'a -> int) (what : 'a list) : 'a list = (
	let	datatype 'a TREE	= SLeaf
					| SNode of 'a * ('a TREE) * ('a TREE);
		fun enter (item, SLeaf) = SNode(item, SLeaf, SLeaf)
		|   enter (item, n as (SNode(x, l, r))) = (
			let	val rel = order item x;
			in	if rel > 0
				then SNode(x, l, enter(item, r))
				else if rel < 0
				then SNode(x, enter(item, l), r)
				else n
			end
		);
		fun flatten SLeaf = []
		|   flatten (SNode(x, l, r)) = flatten l @ (x :: flatten r);

	in	flatten (fold enter what SLeaf)
	end
);
=TEX
That ends the structure:
=SML
end (* of Structure Sort *);
=TEX
\section{SPARSE ARRAYS}
=SML
structure SparseArray : SparseArray = struct
=TEX
The sparse arrays are represented using the following data structure.
An empty array is signalled by $lbound$ being greater than $ubound$.
=SML
abstype '_a ÛSPARSE_ARRAYÝ = SA of {
	lbound	: int ref,
	ubound	: int ref,
	data	: (int * '_a) list Array.array
}
with
=TEX
=SML
fun ÛarrayÝ (len : int) : '_a SPARSE_ARRAY = (
	if len <= 0
	then	fail "array" 1102 []
	else	SA{lbound = ref 1, ubound = ref 0, data =Array.array (len, [])}
);
=TEX
=SML
fun ÛupdateÝ (array:'_a SPARSE_ARRAY, ind : int, a : '_a) : unit  = (
	let	val SA{	lbound = lbound as ref lb,
			ubound = ubound as ref ub,
			data = data} = array;
		val se1 = (
			if lb > ub
			then	(lbound := ind; ubound := ind)
			else if ind < lb
			then	lbound := ind
			else if ind > ub
			then	ubound := ind
			else ()
		);
		val actind = ind mod (Array.length data);
		val old = Array.sub(data, actind)
		val new = old overwrite (ind, a)
	in	Array.update(data, actind, new)
	end
);
=TEX
=SML
fun ÛscratchÝ (array:'_a SPARSE_ARRAY) : unit  = (
	let	val SA{	lbound = lbound,
			ubound = ubound,
			data = data} = array;
		fun aux i = (
			if i >= 0
			then (Array.update(data, i, []); aux (i-1))
			else ()
		);
	in	(lbound := 1; ubound := 0; aux (Array.length data - 1))
	end
);
=TEX
=SML
fun ÛsubÝ (array:'_a SPARSE_ARRAY, ind : int) : '_a  = (
	let	val SA{	lbound = _,
			ubound = _,
			data = data} = array;
		val pairs = Array.sub(data, ind mod Array.length data);
	in	lassoc3 pairs ind
	end	handle ex => divert ex "lassoc3" "sub" 1101 [fn()=>string_of_int ind]
);
=TEX
=SML
fun Ûsub_optÝ (arrayind :'_a SPARSE_ARRAY * int) : '_a OPT = (
	(Value (sub arrayind)) handle Fail _ => Nil
);
=TEX
=SML
fun ÛlindexÝ (array :'_a SPARSE_ARRAY) : int = (
	let	val SA{	lbound = lbound as ref lb,
			ubound = ubound as ref ub,
			data = _} = array;
	in	if lb > ub
		then	fail "lindex" 1103 []
		else lb
	end
);
=TEX
=SML
fun ÛuindexÝ (array :'_a SPARSE_ARRAY) : int = (
	let	val SA{	lbound = lbound as ref lb,
			ubound = ubound as ref ub,
			data = _} = array;
	in	if lb > ub
		then	fail "uindex" 1103 []
		else ub
	end
);
=TEX
=SML
end; (* of abstype 'a SPARSEARRAY *)
end; (* of structure SparseArray *)
=TEX

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


