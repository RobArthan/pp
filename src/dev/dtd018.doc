%  dtd018.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for SLR Parser Driver}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD018}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & FMU Manager}
\TPPabstract{
This document contains the detailed design for the
driver function and associated data types and functions to be
used in conjunction with the
simple SLR parser generator defined in DS/FMU/IED/DTD017.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issues 1.1 to 1.10 ] Initial drafts.

\item[Issue 2.1, 3 September 1991 ] First approved version.

\item[Issue 2.2, (20 January 1992)] Updated to use new fonts.

\item[Issue 2.3 (4 February 1992)]
Changed the signature of $ERROR\_ROUTINE$.
%\item[Issue \SCCSversion, \FormatDate{$Date$%
%} ]

\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a fragment of Standard ML source code which is intended
for inclusion in parsers generated by the SLR parser generator
defined in \cite{DS/FMU/IED/DTD017}.
The document is called for in \cite{DS/FMU/IED/HLD008}.

The functions defined here
are not visible at the user interface in release 1 of ICL HOL.
\subsection{Introduction}
A companion document \cite{DS/FMU/IED/DTD017} contains a parser generator
program. The output of this program comprises of a file containing
Standard ML definitions of three tables and of a function. A skeletal example of
the output is as follows:

=GFT Example
val slrp'actions = Array.arrayoflist[
[(Num,Shift 5),(Lbrack,Shift 4)],[(Plus,Shift 6),(HL_eos,Accept)],[
...
];
val slrp'gotos = Array.arrayoflist[
...
];
val slrp'reducers = list_e_merge initial_E_DICT[
("F",[(fn(x3::x2::x1::_)=>(fetch x2)|_=>raise PARSER_ERROR"invalid reduction"),
...
];
val slrp'gen_parser = slrp'parse 0 slrp'actions slrp'gotos slrp'reducers;
=TEX
The purpose of this document is to define the
function $slrp'parse$ which is used in the last of these definitions.
This function is a generic implementation of the LR parsing algorithm described
in section 6.1 of \cite{Aho77}.

The introduction of \cite{DS/FMU/IED/DTD017} should be consulted before
a first reading of this document.

\subsection{Purpose and Background}
This document supplies material for inclusion in the parser for ICL HOL.

\subsection{Dependencies}
The code depends on the functional toolkit described
in \cite{DS/FMU/IED/DTD002}.
\subsection{Possible Enhancements}
The default error function supplied here only prints unreduced tokens.
It would probably be better to supply a default in which a user-supplied
function was used to print the reduced text.
\subsection{Deficiencies}
None known.
\subsection{PREAMBLE}
=DOC
signature ÛSlrpDriverÝ = sig
=DESCRIBE
See DTD018.
=ENDDOC
\section{DATA TYPES FOR THE DRIVER}
\subsection{Parsing Stacks}
We differ slightly from \cite{Aho77} in that we work with two stacks, one
for states and one for partially parsed input.
The state stack is actually just a list of numbers although
all that the user needs to know is that the states and the state stack
are equality types:

The partially parsed input stack contains items of two sorts: {\em(a)}
unreduced tokens, given by a pair consisting of a $'tok'$ and a $'lc$,
$'tok$ being the type of the items in the input token stream,
$'lc$ being the type of the lexical classes used, and {\em(b)},
reduced phrases represented by a value of type $'pp$.
=DOC
eqtype ÛSTATEÝ				(* = int *);
eqtype ÛSTATE_STACKÝ		(* = STATE list *);
datatype ('tok, 'lc, 'pp) ÛINPUT_STACK_ITEMÝ
					=	ÛTokenÝ of 'tok * 'lc
					|	ÛParsedÝ of 'pp;
type('tok, 'lc, 'pp) ÛINPUT_STACKÝ	(* = ('tok, 'lc, 'pp) INPUT_STACK_ITEM list *);
=DESCRIBE
See DTD018.
=ENDDOC
\pagebreak
\subsection{Actions}
As in \cite{Aho77}, an action\footnote{%
The term $action$ in this document is used, as in \cite{Aho77}, to
refer to the four sorts of parsing actions made by the SLR parser driver.
These are not the same as the actions in the action grammars described
in \cite{DS/FMU/IED/DTD017}, which correspond to the reduction code
here. This  somewhat confusing terminology is, alas, traditional.
}%
takes one of the following four options:

\begin{enumerate}
\item
Shift into a given state, $s$
\item
Reduce by some alternative, $\beta$, for the nonterminal $A$. This means
that the top most $n$ items, where $n$ is the length of the alternative $\beta$
have been recognised as an $A$. In our case this means that $n$ items
are popped from the input stack and some user-defined
code is invoked to compute a $'pp$, say $A$, from them, which is then
pushed (as $Parsed\,A$) back on the stack.
\item
Accept. I.e., parsing has finished.
The input stack now contains a single $'pp$ which is the desired result.
\item
Error. The input to be parsed is invalid.
\end{enumerate}

Actions are encoded in the following datatype, in which we assume that the
user-defined reduction code may be accessed by the name of the non-terminal, $A$,
together with the index of the alternative, $\beta$ and in which we also
record the number of symbols to reduce by in the reduce case.
Note that as in \cite{Aho77} the parts of the goto tables concerned
with terminal symbols (i.e., lexical classes) are held in the shift
actions.
The ``dynamic'' option is for a shift/reduce conflict which is to be
resolved during parsing by a user-defined routine.
=DOC
datatype ÛACTIONÝ	=	ÛShiftÝ of STATE
			|	ÛReduceÝ of ((string * int) * int)
			|	ÛDynamicÝ of STATE * ((string * int) * int)
			|	ÛAcceptÝ
			|	ÛErrorÝ;
=DESCRIBE
See DTD018.
=ENDDOC
\subsection{Parsing Tables}

The action tables \cite{Aho77} are two-dimensional arrays
indexed by states and lexical classes.
The action tables with which we work are held as one-dimensional
arrays of lists of lexical class-(action-state pair) pairs.
If the state index for these tables is out of range then the
table has been generated incorrectly
and the exception $PARSER\_ERROR$ is raised if this occurs.
User error entries correspond to valid state indices for which the
lexical class in question is not represented.

Similarly the goto tables (for the non-terminal symbols) are held
in a one-dimensional array of pairs each comprising a non-terminal name and a
state.

Finally, the user-defined reduction code (indexed by non-terminal
names and alternative indices) is held in string-indexed
dictionaries of lists of functions from (slices of) partially parsed input stacks
to $'pp$.
(Arrays could be used if we represented non-terminals as
numbers rather than by their names, however there are advantages
for the user in using the names, since the parameterisation of the
resolver function defined later is more straightforward.
No significant performance problems have been encountered with the
present formulation.)

Indexing errors with either the goto tables or the reduction tables indicate
that the table is incorrect and cause the exception $PARSER\_ERROR$ to be
raised.
=DOC
type ('lc)ÛACTION_TABLEÝ	(* =  ('lc * ACTION) list Array.array *);
type ÛGOTO_TABLEÝ		(* = (string * STATE) list Array.array *);
type ('tok, 'lc, 'pp)ÛREDUCTION_TABLEÝ
				(* = (('tok, 'lc, 'pp)INPUT_STACK -> 'pp) list E_DICT *);
=DESCRIBE
See DTD018.
=ENDDOC
\subsection{Conflict Resolution}
The user-defined dynamic conflict resolver takes an input stack and the
reduction information
contained in the dynamic action and returns a value 
indicating
whether the parser should shift, reduce or report an error:
=DOC
datatype ÛRESOLUTIONÝ	=	ÛDoShiftÝ
				|	ÛDoReduceÝ
				|	ÛDoErrorÝ;
type ('tok, 'lc, 'pp)ÛRESOLVERÝ 
		(* = ('tok * 'lc) * ('tok, 'lc, 'pp)ÛINPUT_STACKÝ * ((string * int) * int)
			-> RESOLUTION *);
=DESCRIBE
See DTD018.
=ENDDOC
\subsection{Lexical Classification}
We use a function of the following type
to give the lexical class of an input token.
=DOC
type ('tok, 'lc)ÛCLASSIFIERÝ		(* = 'tok -> 'lc *);
=DESCRIBE
See DTD018.
=ENDDOC
\subsection{Error Handling}
We use a function of the following types to handle errors.
=DOC
type ('tok, 'lc, 'pp, 'st)ÛERROR_ROUTINEÝ
 			(* = 'tok * ('tok, 'lc, 'pp)INPUT_STACK * STATE_STACK * 'st
				-> ('tok, 'st) *);
=DESCRIBE
See DTD018.
=ENDDOC
\subsection{Input Stream}
A function of the following type is assumed to be available
to generate the input stream to be parsed. Typically $'st$ and might be
instantiated to $(''tok)list$ for a parser which was to be used in a context
where all the input is to be available before parsing begins --- in this
case the reader would be a function which returns the head and tail of the argument
if the list was not empty and returns the end-of-sentence symbol and an empty list
otherwise. Alternatively, for a reader which read text from a file, $'st$ would
be instantiated to $unit$.

=DOC
type ('tok, 'st)ÛREADERÝ
 			(* = 'st -> ('tok * 'st) *);
=DESCRIBE
See DTD018.
=ENDDOC

\section{THE DRIVER FUNCTION}
The driver function has the following type. The significance of its parameters
should be clear from the discussion of their
types in the previous section.
=DOC
val Ûslrp'parseÝ:
	STATE ->
	''lc ACTION_TABLE ->
	GOTO_TABLE ->
	(''tok, ''lc, 'pp) REDUCTION_TABLE ->
	(''tok, ''lc, 'pp) RESOLVER ->
	(''tok, ''lc) CLASSIFIER ->
	(''tok, ''lc, 'pp, 'st) ERROR_ROUTINE ->
	(''tok, 'st) READER -> 'st -> 'pp;
=ENDDOC
\section{ERROR REPORTING}
The following two exceptions may be raised by the driver. $SYNTAX\_ERROR$
is raised if an error in the input has been detected and passed to the
error routine and the error routine has not raised an exception.
$PARSER\_ERROR$ ``should not happen'': it indicates an error in the driver
or its tables.
=DOC
exception ÛSYNTAX_ERRORÝ;
exception ÛPARSER_ERRORÝ of string;
=DESCRIBE
See DTD018.
=ENDDOC
\section{UTILITIES FOR USER CODE}

In this section we describe functions which support the user in defining
error handling and conflict resolution functions.

\subsection{Error Handling}

The following utility may be of use in formatting diagnostic messages.
It formats the parsing stack in reverse order (i.e., in the
same order as the input stream) as a string.
It formats the reduced entries as three dots and uses the supplied
token printer to format the unreduced entries.
=DOC
val Ûformat_stackÝ : ('tok -> string) -> ('tok, 'lc, 'pp)INPUT_STACK -> string;
=DESCRIBE
See DTD018.
=ENDDOC
Many applications of the parser generator will be served by the
following $default\_error$ function which is parameterised by a function
to print input tokens. It writes an error message on the standard output
and then raises $SYNTAX\_ERROR$.
The messages it produces have one of the following  forms:
=GFT
*** ERROR Syntax error ***
<token> not expected after: <stack print out>
=TEX
=GFT
*** ERROR Syntax error ***
<token> not expected here
=TEX
Here ``$<token>$'' and ``$<stack print out>$'' are the result of printing
the offending input token and the parsing stack using the supplied
input token printer (and $format\_stack$).
The second form is produced if there is nothing on the stack to print out
(i.e., the error has occurred on the first token read, or the stack contains
only reduced entries).
=DOC
val Ûdefault_errorÝ:
	('tok -> string) -> 'tok * ('tok, 'lc, 'pp) INPUT_STACK * STATE_STACK *'st -> ('tok*'st);
=DESCRIBE
See DTD018.
=ENDDOC
\subsection{Conflict Resolution}
The default resolver is one which raises $PARSER\_ERROR$ if it is called.
It is intended for use when there are no conflicts.
=DOC
val Ûdefault_resolverÝ: ('tok, 'lc, 'pp) RESOLVER;
=DESCRIBE
See DTD018.
=ENDDOC
For grammars which do contain shift/reduce conflicts the commonest form of
conflict resolution simply compares the latest input token with the topmost
token on the stack. $simple\_resolver$ helps the user define such a
resolver. Its argument is a function which compares two tokens (which
are given as a pair in input order, i.e., the latest input token comes second).
The resulting resolver will report a syntax error if there are no tokens
on the stack, a situation which corresponds, for example, to an input whose
first symbol is an infix operator.
=DOC
val Ûsimple_resolverÝ:
	(('tok * 'lc) * ('tok * 'lc) -> RESOLUTION) -> ('tok, 'lc, 'pp) RESOLVER;
=DESCRIBE
See DTD018.
=ENDDOC
=SML
end; (* of signature SlrpDriver *)
=TEX
\section{TEST POLICY}
Since the code here is not to be visible to the user in the release 1 system,
and the parser for HOL which includes the code will itself be thoroughly tested,
an adequate level of testing for $slrp'parse$ will be just to try out
a couple of simple parsers, which is done in the module testing
for \cite{DS/FMU/IED/DTD017}. More comprehensive testing would be necessary
if the parser generator were to be included as part of the HOL product.
For present
purposes, the module tests for the parser driver
should therefore just check the utilities for user code.
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}


