=IGN
********************************************************************************
dtd018.doc: this file is part of the PPDev system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\ftlinepenalty=9999
\makeindex
%%%%% YOU WILL USUALLY WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{ Detailed Design for SLR Parser Driver }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document contains the detailed design for the
driver function and associated data types and functions that provide
run-time support for the parsers generated by the
simple SLR parser generator defined in DS/FMU/IED/DTD017.}
\end{center}}

\def\Reference{DS/FMU/IED/DTD018}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 2.7 $%
}
\def\Date{\FormatDate{$Date: 2002/10/17 15:10:58 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1 to 1.10 ] Initial drafts.

\item[Issue 2.1, 3 September 1991 ] First approved version.

\item[Issue 2.2, (20 January 1992)] Updated to use new fonts.

\item[Issue 2.3 (4 February 1992)]
Changed the signature of $ERROR\_ROUTINE$.
\item [Issue 2.4 (1st April 1992)]
Changes required by CR0016.
\item[Issues 2.5,2.6 (6th September 2000)] Reformatted for LaTeX2e etc.
\item[Issue 2.7] Copyright and banner updates for open source release.
\item[Issue 2.8] PPDev-specific updates for open source release
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}
\begin{center}
\begin{tabular}{ll}
{\Product} Development Library & Lemma 1\\
\end{tabular}
\end{center}
\begin{centering}


\end{centering}

\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a fragment of Standard ML source code which is intended
for inclusion in parsers generated by the SLR parser generator
defined in \cite{DS/FMU/IED/DTD017}.
The document is called for in \cite{DS/FMU/IED/HLD008}.

The functions defined here
are not visible at the user interface in release 1 of ICL HOL.
\subsection{Introduction}
A companion document \cite{DS/FMU/IED/DTD017} contains a parser generator
program. The output of this program comprises a file containing
Standard ML definitions. A skeletal example of
the output is as follows:

=GFT Example
local
	....
val slrp'a2=[[(Eos,Reduce(("T",1),1)),(Plus,Reduce(("T",1),1)),
(Times,Reduce(("T",1),1)),(Rbrack,Reduce(("T",1),1))]]@slrp'a3;
val slrp'a1=[[(Eos,Reduce(("T",0),3)),(Plus,Reduce(("T",0),3)),
(Times,Reduce(("T",0),3)),(Rbrack,Reduce(("T",0),3))]]@slrp'a2;
in
val slrp'actions=PPArray.arrayoflist slrp'a1;
end;
local
	....
val slrp'g2=[[]]@slrp'g3;
val slrp'g1=[[]]@slrp'g2;
in
val slrp'gotos=PPArray.arrayoflist slrp'g1;
end;
val slrp'reducers = list_e_merge initial_E_DICT[
("F",[(fn(x3::x2::x1::_)=>(fetch x2)|_=>raise PARSER_ERROR"invalid reduction"),
...
];
local
	...
fun slrp'r2()=[("E",[
(fn(x3::x2::x1::stk)=>(add x1 x3)|_=>raise PARSER_ERROR"invalid reduction"),
(fn(x1::stk)=>(fetch x1)|_=>raise PARSER_ERROR"invalid reduction")])]@slrp'r3();
fun slrp'r1()=[("F",[
(fn(x3::x2::x1::stk)=>(fetch x2)|_=>raise PARSER_ERROR"invalid reduction"),
(fn(x1::stk)=>(conv x1)|_=>raise PARSER_ERROR"invalid reduction")])]@slrp'r2();
in
fun slrp'reducers () = list_e_merge initial_e_dict (slrp'r1());
end;
fun slrp'gen_parser x = slrp'parse 10 slrp'actions slrp'gotos (slrp'reducers()) x;
=TEX
The purpose of this document is to define the
function $slrp'parse$ which is used in the last of these definitions.
This function is a generic implementation of the LR parsing algorithm described
in section 6.1 of \cite{Aho77}.

The introduction of \cite{DS/FMU/IED/DTD017} should be consulted before
a first reading of this document.

\subsection{Purpose and Background}
This document supplies material for inclusion in the parser for ICL HOL.

\subsection{Dependencies}
The code depends on the functional toolkit described
in \cite{DS/FMU/IED/DTD002}.
\subsection{Possible Enhancements}
The default error function supplied here only prints unreduced tokens.
It would probably be better to supply a default in which a user-supplied
function was used to print the reduced text.
\subsection{Deficiencies}
None known.
\subsection{PREAMBLE}
=DOC
signature ÛSlrpDriverÝ = sig
=DESCRIBE
See main text.
=ENDDOC
\section{DATA TYPES FOR THE DRIVER}
\subsection{Parsing Stacks}
We differ slightly from \cite{Aho77} in that we work with two stacks, one
for states and one for partially parsed input.
The state stack is actually just a list of numbers although
all that the user needs to know is that the states and the state stack
are equality types:

The partially parsed input stack contains items of two sorts: {\em(a)}
unreduced tokens, given by a pair consisting of a $'tok'$ and a $'lc$,
$'tok$ being the type of the items in the input token stream,
$'lc$ being the type of the lexical classes used, and {\em(b)},
reduced phrases represented by a value of type $'pp$.
=DOC
eqtype ÛSTATEÝ
	(* = int *);
eqtype ÛSTATE_STACKÝ
	(* = STATE list *);
datatype ('tok, 'lc, 'pp) ÛINPUT_STACK_ITEMÝ
					=	ÛTokenÝ of 'tok * 'lc
					|	ÛParsedÝ of 'pp;
type('tok, 'lc, 'pp) ÛINPUT_STACKÝ
	(* = ('tok, 'lc, 'pp) INPUT_STACK_ITEM list *);
=DESCRIBE
See main text.
=ENDDOC
\pagebreak
\subsection{Actions}
As in \cite{Aho77}, an action\footnote{%
The term $action$ in this document is used, as in \cite{Aho77}, to
refer to the four sorts of parsing actions made by the SLR parser driver.
These are not the same as the actions in the action grammars described
in \cite{DS/FMU/IED/DTD017}, which correspond to the reduction code
here. This  somewhat confusing terminology is, alas, traditional.
}%
takes one of the following four options:

\begin{enumerate}
\item
Shift into a given state, $s$
\item
Reduce by some alternative, $\beta$, for the nonterminal $A$. This means
that the top most $n$ items, where $n$ is the length of the alternative $\beta$
have been recognised as an $A$. In our case this means that $n$ items
are popped from the input stack and some user-defined
code is invoked to compute a $'pp$, say $A$, from them, which is then
pushed (as $Parsed\,A$) back on the stack.
\item
Accept. I.e., parsing has finished.
The input stack now contains a single $'pp$ which is the desired result.
\item
Error. The input to be parsed is invalid.
\end{enumerate}

Actions are encoded in the following datatype, in which we assume that the
user-defined reduction code may be accessed by the name of the non-terminal, $A$,
together with the index of the alternative, $\beta$ and in which we also
record the number of symbols to reduce by in the reduce case.
Note that as in \cite{Aho77} the parts of the goto tables concerned
with terminal symbols (i.e., lexical classes) are held in the shift
actions.
The ``dynamic'' option is for a shift/reduce conflict which is to be
resolved during parsing by a user-defined routine.
=DOC
datatype ÛACTIONÝ	=	ÛShiftÝ of STATE
			|	ÛReduceÝ of ((string * int) * int)
			|	ÛDynamicÝ of STATE * ((string * int) * int)
			|	ÛAcceptÝ
			|	ÛErrorÝ;
=DESCRIBE
See main text.
=ENDDOC
\subsection{Parsing Tables}

The action tables \cite{Aho77} are two-dimensional arrays
indexed by states and lexical classes.
The action tables with which we work are held as one-dimensional
arrays of lists of lexical class-(action-state pair) pairs.
If the state index for these tables is out of range then the
table has been generated incorrectly
and the exception $PARSER\_ERROR$ is raised if this occurs.
User error entries correspond to valid state indices for which the
lexical class in question is not represented.

Similarly the goto tables (for the non-terminal symbols) are held
in a one-dimensional array of pairs each comprising a non-terminal name and a
state.

Finally, the user-defined reduction code (indexed by non-terminal
names and alternative indices) is held in string-indexed
dictionaries of lists of functions from (slices of) partially parsed input stacks
to $'pp$.
(Arrays could be used if we represented non-terminals as
numbers rather than by their names, however there are advantages
for the user in using the names, since the parameterisation of the
resolver function defined later is more straightforward.
No significant performance problems have been encountered with the
present formulation.)

Indexing errors with either the goto tables or the reduction tables indicate
that the table is incorrect and cause the exception $PARSER\_ERROR$ to be
raised.
=DOC
type ('lc)ÛACTION_TABLEÝ
	(* =  ('lc * ACTION) list Array.array *);
type ÛGOTO_TABLEÝ
	(* = (string * STATE) list Array.array *);
type ('tok, 'lc, 'pp)ÛREDUCTION_TABLEÝ
	(* = (('tok, 'lc, 'pp)INPUT_STACK -> 'pp) list E_DICT *);
=DESCRIBE
See main text.
=ENDDOC
\subsection{Conflict Resolution}
The user-defined dynamic conflict resolver takes an input stack and the
reduction information
contained in the dynamic action and returns a value 
indicating
whether the parser should shift, reduce or report an error:
=DOC
datatype ÛRESOLUTIONÝ	=	ÛDoShiftÝ
				|	ÛDoReduceÝ
				|	ÛDoErrorÝ;
type ('tok, 'lc, 'pp)ÛRESOLVERÝ 
	(* = ('tok * 'lc) * ('tok, 'lc, 'pp)ÛINPUT_STACKÝ * ((string * int) * int)
		-> RESOLUTION *);
=DESCRIBE
See main text.
=ENDDOC
\subsection{Lexical Classification}
We use a function of the following type
to give the lexical class of an input token.
=DOC
type ('tok, 'lc)ÛCLASSIFIERÝ		(* = 'tok -> 'lc *);
=DESCRIBE
See main text.
=ENDDOC
\subsection{Error Handling}
We use a function of the following types to handle errors.
=DOC
type ('tok, 'lc, 'pp, 'st)ÛERROR_ROUTINEÝ
 	(* = 'tok * ('tok, 'lc, 'pp)INPUT_STACK * STATE_STACK * 'st
		-> ('tok, 'st) *);
=DESCRIBE
See main text.
=ENDDOC
\subsection{Input Stream}
A function of the following type is assumed to be available
to generate the input stream to be parsed. Typically $'st$ and might be
instantiated to $('tok)list$ for a parser which was to be used in a context
where all the input is to be available before parsing begins --- in this
case the reader would be a function which returns the head and tail of the argument
if the list was not empty and returns the end-of-sentence symbol and an empty list
otherwise. Alternatively, for a reader which read text from a file, $'st$ would
be instantiated to $unit$.

=DOC
type ('tok, 'st)ÛREADERÝ
 			(* = 'st -> ('tok * 'st) *);
=DESCRIBE
See main text.
=ENDDOC

\section{THE DRIVER FUNCTION}
The driver function has the following type. The significance of its parameters
should be clear from the discussion of their
types in the previous section.
=DOC
val Ûslrp'parseÝ:
	STATE ->
	''lc ACTION_TABLE ->
	GOTO_TABLE ->
	('tok, ''lc, 'pp) REDUCTION_TABLE ->
	('tok, ''lc, 'pp) RESOLVER ->
	('tok, ''lc) CLASSIFIER ->
	('tok, ''lc, 'pp, 'st) ERROR_ROUTINE ->
	('tok, 'st) READER -> 'st -> 'pp;
=ENDDOC
\section{ERROR REPORTING}
The following two exceptions may be raised by the driver. $SYNTAX\_ERROR$
is raised if an error in the input has been detected and passed to the
error routine and the error routine has not raised an exception.
$PARSER\_ERROR$ ``should not happen'': it indicates an error in the driver
or its tables.
=DOC
exception ÛSYNTAX_ERRORÝ;
exception ÛPARSER_ERRORÝ of string;
=DESCRIBE
See main text.
=ENDDOC
\section{UTILITIES FOR USER CODE}

In this section we describe functions which support the user in defining
error handling and conflict resolution functions.

\subsection{Error Handling}

The following utility may be of use in formatting diagnostic messages.
It formats the parsing stack in reverse order (i.e., in the
same order as the input stream) as a string.
It formats the reduced entries as three dots and uses the supplied
token printer to format the unreduced entries.
=DOC
val Ûformat_stackÝ : ('tok -> string) -> ('tok, 'lc, 'pp)INPUT_STACK -> string;
=DESCRIBE
See main text.
=ENDDOC
Many applications of the parser generator will be served by the
following $default\_error$ function which is parameterised by a function
to print input tokens. It writes an error message on the standard output
and then raises $SYNTAX\_ERROR$.
The messages it produces have one of the following  forms:
=GFT
*** ERROR Syntax error ***
<token> not expected after: <stack print out>
=TEX
=GFT
*** ERROR Syntax error ***
<token> not expected here
=TEX
Here ``$<token>$'' and ``$<stack print out>$'' are the result of printing
the offending input token and the parsing stack using the supplied
input token printer (and $format\_stack$).
The second form is produced if there is nothing on the stack to print out
(i.e., the error has occurred on the first token read, or the stack contains
only reduced entries).
=DOC
val Ûdefault_errorÝ:
	('tok -> string) ->
	'tok * ('tok, 'lc, 'pp) INPUT_STACK * STATE_STACK *'st ->
	('tok*'st);
=DESCRIBE
See main text.
=ENDDOC
\subsection{Conflict Resolution}
The default resolver is one which raises $PARSER\_ERROR$ if it is called.
It is intended for use when there are no conflicts.
=DOC
val Ûdefault_resolverÝ: ('tok, 'lc, 'pp) RESOLVER;
=DESCRIBE
See main text.
=ENDDOC
For grammars which do contain shift/reduce conflicts the commonest form of
conflict resolution simply compares the latest input token with the topmost
token on the stack. $simple\_resolver$ helps the user define such a
resolver. Its argument is a function which compares two tokens (which
are given as a pair in input order, i.e., the latest input token comes second).
The resulting resolver will report a syntax error if there are no tokens
on the stack, a situation which corresponds, for example, to an input whose
first symbol is an infix operator.
=DOC
val Ûsimple_resolverÝ:
	(('tok * 'lc) * ('tok * 'lc) -> RESOLUTION) -> ('tok, 'lc, 'pp) RESOLVER;
=DESCRIBE
See main text.
=ENDDOC
=SML
end; (* of signature SlrpDriver *)
=TEX
\section{TEST POLICY}
Module testing for the parser driver is covered by the module testing for
the parser generator as specified in \cite{DS/FMU/IED/DTD017}.

\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}


