=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for SLR Parser Driver}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD018}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the detailed design for the
driver function which is
used in conjunction with the
simple SLR parser generator defined in DS/FMU/IED/DTD017.
Some utilities for using the function are also defined.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion (\FormatDate{$Date$%
})]
First draft for comment.
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a fragment of code which is intended
for inclusion in parsers generated by the SLR parser generator
defined in \cite{DS/FMU/IED/DTD018}.
The functions defined here
are not visible at the user interface in release 1 of ICL HOL.
\subsection{Introduction}
A companion document \cite{DS/FMU/IED/DTD018} contains a parser generator
program. The output of this program comprises of a file containing
Standard ML definitions of three tables and of a function. A skeletal example of
the output is as follows:

ÛExample
val slrp'actions = Array.arrayoflist[
[(Num,Shift 5),(Lbrack,Shift 4)],[(Plus,Shift 6),(HL_eos,Accept)],[
...
];
val slrp'gotos = Array.arrayoflist[
...
];
val slrp'reducers = list_e_merge initial_E_DICT[
("F",[(fn(x3::x2::x1::_)=>(fetch x2)|_=>raise PARSER_ERROR"invalid reduction"),
...
];
val slrp'gen_parser = slrp'parse 0 slrp'actions slrp'gotos slrp'reducers;
Ê
The purpose of this document is to define the
function $slrp'parse$ which is used in the last of these definitions.
This function is a generic implementation of the LR parsing algorithm described
in section 6.1 of \cite{Aho86}.
We assume familiarity with chapter 6 of \cite{Aho86} throughout this document.

\subsection{Purpose and Background}
This document supplies material for inclusion in the parser for ICL HOL.

\subsection{Dependencies}
The code depends on the functional toolkit described
in \cite{DS/FMU/IED/DTD002}.
\subsection{Possible Enhancements}
The default error function supplied here only prints unreduced tokens.
It would probably better to supply a default in which a user-supplied
function was used to print the reduced text.
\subsection{Deficiencies}
None known.
\subsection{PREAMBLE}
=DOC
signature ‚SlrpDriver· = sig
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
\section{DATA TYPES FOR THE DRIVER}
We differ slightly from \cite{Aho86} in that we work with two stacks, one
for states and one for partially parsed input.
The state stack is actually just a list of numbers although
all that the user needs to know is that the states and the state stack
are equality types.
=DOC
eqtype ‚STATE·	(* = int *);
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
=DOC
eqtype ‚STATE_STACK·		(* = STATE list *);
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
The partially parsed input stack contains entries of the following
type, $'tok$ being the type of the input token stream,
$'lc$ being the type of the lexical classes used, and $'pp$ being
the type preduced when a phrase is reduced.
=DOC
datatype ('tok, 'lc, 'pp) ‚INPUT_STACK_ITEM·	=	‚Token· of 'tok * 'lc
							|	‚Parsed· of 'pp;
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
An $INPUT\_STACK$ is just a list of $INPUT\_STACK\_ITEM$s.
=DOC
type('tok, 'lc, 'pp) ‚INPUT_STACK·
					(* = ('tok, 'lc, 'pp) INPUT_STACK_ITEM list *);
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
As in \cite{Aho86}, an action takes one of the following four options:

\begin{enumerate}
\item
Shift into a given state, $s$
\item
Reduce by some alternative, $\beta$, for the nonterminal $A$. This means
that the top most $n$ items, where $n$ is the length of the alternative $\beta$
have been recognised as an $A$. In our case this means that $n$ items
are popped from the input stack and some user-defined
code is invoked to compute a $'pp$, say $A$, from them, which is then
pushed (as $Parsed\,A$) back on the stack.
\item
Accept. I.e. Parsing has finished.
The input stack now contains a single $'pp$ which is the desired result.
\item
Error. The input to be parsed is invalid.
\end{enumerate}

Actions are encoded in the following datatype, in which we assume that the
user-defined reduction code may be accessed by the name of the non-terminal, $A$,
together with the index of the alternative, $\beta$ and in which we also
record the number of symbols to reduce by in the reduce case.
Note that as in \cite{Aho86} the parts of the goto tables concerned
with terminal symbols (i.e. lexical classes) are held in the shift
actions.
The ``dynamic'' option is for a shift/reduce conflict which is to be
resolved during parsing by a user-defined routine.
=DOC
datatype ‚ACTION·	= ‚Shift· of STATE
			| ‚Reduce· of ((string * int) * int)
			| ‚Dynamic· of STATE * ((string * int) * int)
			| ‚Accept·
			| ‚Error·;
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
The action tables described in \cite{Aho86} are two-dimensional arrays
indexed by states and lexical classes.
The action tables with which we work are held as one-dimensional
arrays of lists of lexical class-(action-state pair) pairs.
If the state index for these tables is out of range it is a design error.
User error entries correspond to valid state indices for which the
lexical class in question is not represented.
=DOC
type ('lc)‚ACTION_TABLE·	(* =  ('lc * ACTION) list Array.array *);
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
Similarly the goto tables (for the non-terminal symbols) are held
in a one-dimensional array of pairs each comprising a non-terminal name and a
state.
It is a design error if an invalid index pair is supplied for these tables
and the exception $PARSER\_ERROR$ is raised if this occurs.
=DOC
type ‚GOTO_TABLE·	(* = (string * STATE) list Array.array *);
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
We assume that the user-defined reduction code (indexed by non-terminal
names and alternative indices) is held in a table of the following type.
(This could be made more efficient if we represented non-terminals as
numeric offsets rather than by there names.)
=DOC
type ('tok, 'lc, 'pp)‚REDUCTION_TABLE·
				(* = (('tok, 'lc, 'pp)INPUT_STACK -> 'pp) list E_DICT *);
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
The user-defined dynamic conflict resolver takes an input stack and the
reduction information
contained in the dynamic action and returns a value 
of the following type indicating
whether the parser should shift, reduce or report an error:
=DOC
datatype ‚RESOLUTION·	= ‚DoShift·
				| ‚DoReduce·
				| ‚DoError·;
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
Thus the resolver has the following type:
=DOC
type ('tok, 'lc, 'pp)‚RESOLVER· 
		(* = ('tok * 'lc) * ('tok, 'lc, 'pp)‚INPUT_STACK· * ((string * int) * int)
			-> RESOLUTION *);
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
A function of the following type is assumed to be available
to give the lexical class of an input token.
=DOC
type ('tok, 'lc)CLASSIFIER		(* = 'tok -> 'lc *);
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
We use a function of the following types to handle errors.
=DOC
type ('tok, 'lc, 'pp)‚ERROR_ROUTINE·
 			(* = 'tok * ('tok, 'lc, 'pp)INPUT_STACK * STATE_STACK -> unit *);
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
Finally, a function of the following type is assumed to be available
to generate the input stream to be parsed. Typically $'st$ and might be
instantiated to $(''tok)list$ for a parser which was to be used in a context
where all the input is to be available before parsing begins --- in this
case the reader would be a function which returns the head and tail of the argument
if the list was not empty and returnsthe end-of-sentence symbol and an empty list
otherwise. Alternatively, for a reader which read text from a file, $'st$ would
be instantiated to $unit$.

=DOC
type ('tok, 'st)‚READER·
 			(* = 'st -> ('tok * 'tok) *);
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC

\section{THE DRIVER FUNCTION}
The driver function has the following type. The significance of its parameters
should be clear from the discussion of their
types in the previous section.
=DOC
val ‚slrp'parse·:
	STATE ->
	''lc ACTION_TABLE ->
	GOTO_TABLE ->
	(''tok, ''lc, 'pp) REDUCTION_TABLE ->
	(''tok, ''lc, 'pp) RESOLVER ->
	(''tok, ''lc) CLASSIFIER ->
	(''tok, ''lc, 'pp) ERROR_ROUTINE ->
	(''tok, 'st) READER -> 'st -> 'pp;
=ENDDOC
\section{ERROR REPORTING}
The following two exceptions may be raised by the driver. $SYNTAX\_ERROR$
is raised if an error in the input has been detected and passed to the
error routine and the error routine has not raised an exception.
$PARSER\_ERROR$ ``should not happen'': it indicates an error in the driver
or its tables.
=DOC
exception ‚SYNTAX_ERROR·;
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
=DOC
exception ‚PARSER_ERROR· of string;
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
\section{UTILITIES FOR USER CODE}
In this section we describe functions which support the user in defining
error handling and conflict resolution functions.

The following utility may be of use for diagnostic purposes.
It formats out the parsing stack in reverse order as a string.
It formats the reduced entries as three dots and uses the supplied
token printer to format the unreduced entries.
=DOC
val ‚format_stack· : ('tok -> string) -> ('tok, 'lc, 'pp)INPUT_STACK -> string;
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
Many applications of the parser generator will be served by the
following $default\_error$ function which is parameterised by a function
to print input tokens. It writes an error message on the standard output
and then raises $SYNTAX\_ERROR$.
The messages it produces have one of the following  forms:
Û
*** ERROR Syntax error ***
<token> not expected after: <stack print out>
Ê
Û
*** ERROR Syntax error ***
<token> not expected here
Ê
Here ``$<token>$'' and ``$<stack print out>$'' are the result of printing
the offending input token and the parsing stack using the supplied
input token printer (and $format\_stack$).
The second form is produced if there is nothing on the stack to print out
(i.e. the error has occurred on the first token read, or the stack contains
only reduced entries).
=DOC
val ‚default_error·:
	('tok -> string) -> 'tok * ('tok, 'lc, 'pp) INPUT_STACK * STATE_STACK -> unit;
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
The default resolver is one which raises $PARSER\_ERROR$ if it is called.
It is intended for use when there are no conflicts.
=DOC
val ‚default_resolver·: ('tok, 'lc, 'pp) RESOLVER;
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
For grammars which do contain shift/reduce conflicts the commonest form of
conflict resolution simply compares the latest input token with the topmost
token on the stack. $simple\_resolver$ helps the user define such a
resolver. Its argument is a function which compares two tokens (which
are given as a pair in input order, i.e. the latest input token comes second).
The resulting resolver will report a syntax error if there are no tokens
on the stack, a situation which corresponds, for example, to an input whose
first symbol is an infix operator.
=DOC
val ‚simple_resolver·:
	(('tok * 'lc) * ('tok * 'lc) -> RESOLUTION) -> ('tok, 'lc, 'pp) RESOLVER;
=DESCRIBE
See DS/FMU/IED/DTD017
=ENDDOC
=SML
end; (* of signature SlrpDriver *)
=TEX
\section{TEST POLICY}
Since the code here is not to be visible to the user in the release 1 system
and the parser for HOL which includes the code will itself be thoroughly tested,
an adequate level of testing for present purpose will be just to try out
a couple of simple parsers. More comprehensive testing would be necessary
if the parser generator were to be included as part of the HOL product.
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
