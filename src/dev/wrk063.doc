=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex
\def\Slrp{{\bf SLRP}}
\def\Hide#1{\relax}

%%%%% YOU WILL USUALLY WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{ A {\Slrp} Grammar for ANSI-C }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document gives a grammar for ANSI-C.}
\end{center}}

\def\Reference{LEMMA1/PPTEX/WRK063}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.3 $%
}
\def\Date{\FormatDate{$Date: 2000/08/01 14:47:06 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1] First draft.
\item[Issues 1.2] Minor corrections.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

As determined by experience with the template.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}
\begin{center}
\begin{tabular}{ll}
Lemma 1 Development Library
\end{tabular}
\end{center}


\newpage

%%%%% NOW THE CREATIVE BIT:

\section{Introduction}
\subsection{Scope}
This document provides an example of a grammar in the {\Slrp} format.
It may be used, {\it inter alia}, for testing the {\Slrp} parser generator.

\subsection{Purpose and Background}


\subsection{Overview}

This document gives a grammar for ANSI C as per the 1990 standard \cite{ansi90}.
It follows Kernighan \& Ritchie \cite{kernighan88} in leaving out lexical details and
preprocessor syntax.

The grammar is presented so that it can be processed by {\Slrp} in several ways.
Section~\ref{REFERENCE} of this document gives the plain grammar, much as in \cite{kernighan88}.
This grammar is given top-down, and is divided into four sections: translation units, declarations,
statements and expressions. The output from processing this section comprises
four separate {\Slrp} input files: {c.grm.txt}, {\tt decl.grm.txt}, {stmt.grm.txt} and {\tt expr.grm.txt},
each one of which contains the later ones. The sentence symbols for these four grammars are:
{\it translation\_unit}, {\it declaration}, {\it statement} and {\it expression} respectively.

The resulting {\Slrp} grammar for {\it translation\_unit} is essentially an instance of the observations at the beginning
of appendix A13 of~\cite{kernighan88}, which correctly predicts that the results is free
of LALR(1) conflicts apart from the shift/reduce conflict caused by the ``dangling else'' ambiguity
(which is to be resolved by always reducing).

The grammar as presented in section~\ref{REFERENCE} is still not really suitable for practical use.
This is because it presupposes that the names defined in {\tt typedef} declarations.can be
distinguished lexically, whereas, in fact, that distinction is necessarily context-sensitive.
Section~\ref{WORKING} presents a working version of the grammar. This is obtained
by replacing a few of the productions in {\tt c.grm.txt} with productions that allow a parser
generated by {\Slrp} to record and use the necessary contextual information. The resulting
grammar is dumped into the file {\tt c1.grm.txt}. The productions in section~\ref{REFERENCE}
that are replaced are marked with a comment ``{\it (* REFERENCE ONLY *)}''.

=TEX
\section{THE REFERENCE GRAMMAR} \label{REFERENCE}
\subsection{Translation Units}
=DUMP c.grm.txt
translation_unit
	= external_declaration
	| translation_unit, external_declaration
	;
=TEX
=DUMPMORE c.grm.txt
external_declaration
	= function_definition
	| declaration
	;
=TEX
=DUMPMORE c.grm.txt
function_definition
	= declarator, compound_statement
	| declarator, declaration_list, compound_statement
	| declaration_specifiers, declarator, compound_statement
	| declaration_specifiers, declarator, declaration_list, compound_statement
	;
=TEX
\subsection{Declarations}

=TEX
=DUMP decl.grm.txt
declaration				(* REFERENCE ONLY *)
	= declaration_specifiers, `;`
	| declaration_specifiers, init_declarator_list, `;`
	;
=TEX
=DUMPMORE decl.grm.txt
declaration_list
	= declaration
	| declaration_list, declaration
	;
=TEX
=DUMPMORE decl.grm.txt
declaration_specifiers
	= storage_class_specifier
	| storage_class_specifier, declaration_specifiers
	| type_specifier
	| type_qualifier, declaration_specifiers
	| type_specifier
	| type_qualifier, declaration_specifiers
	;
=TEX
=DUMPMORE decl.grm.txt
storage_class_specifier			(* REFERENCE ONLY *)
	= `auto`
	| `register`
	| `static`
	| `extern`
	| `typedef`
	;
=TEX
=DUMPMORE decl.grm.txt
type_specifier
	= `void`
	| `char`
	| `short`
	| `int`
	| `long`
	| `float`
	| `double`
	| `signed`
	| `unsigned`
	| struct_or_union_specifier
	| enum_specifier
	| typedef_name
	;
=TEX
=DUMPMORE decl.grm.txt
type_qualifier
	= `const`
	| `volatile`
	;
=TEX
=DUMPMORE decl.grm.txt
struct_or_union_specifier		(* REFERENCE ONLY *)
	= struct_or_union, `{`, struct_declaration_list, `}`
	| struct_or_union, identifier, `{`, struct_declaration_list, `}`
	| struct_or_union, identifier
	;
=TEX
=DUMPMORE decl.grm.txt
struct_or_union
	= `struct`
	| `union`
	;
=TEX
=DUMPMORE decl.grm.txt
struct_declaration_list
	= struct_declaration
	| struct_declaration_list, struct_declaration
	;
=TEX
=DUMPMORE decl.grm.txt
init_declarator_list
	= init_declarator
	| init_declarator_list, `,`, init_declarator
	;
=TEX
=DUMPMORE decl.grm.txt
init_declarator
	= declarator
	| declarator, `=`, initializer
	;
=TEX
=DUMPMORE decl.grm.txt
struct_declaration
	= specifier_qualifier_list, struct_declarator_list, `;`
	;
=TEX
=DUMPMORE decl.grm.txt
specifier_qualifier_list
	= type_specifier
	| type_specifier, specifier_qualifier_list
	| type_qualifier
	| type_qualifier, specifier_qualifier_list
	;
=TEX
=DUMPMORE decl.grm.txt
struct_declarator_list
	= struct_declarator
	| struct_declarator_list, `,`, struct_declarator
	;
=TEX
=DUMPMORE decl.grm.txt
struct_declarator
	= declarator
	| `:`, constant_expression
	| declarator, `:`, constant_expression
	;
=TEX
=DUMPMORE decl.grm.txt
enum_specifier
	= `enum`, `{`, enumerator_list, `}`
	| `enum`, identifier, `{`, enumerator_list, `}`
	| `enum`, identifier
	;
=TEX
=DUMPMORE decl.grm.txt
enumerator_list
	= enumerator
	| enumerator_list, `,`, enumerator
	;
=TEX
=DUMPMORE decl.grm.txt
enumerator
	= identifier
	| identifier, `=`, constant_expression
	;
=TEX
=DUMPMORE decl.grm.txt
declarator
	= direct_declarator
	| pointer, direct_declarator
	;
=TEX
=DUMPMORE decl.grm.txt
direct_declarator		(* REFERENCE ONLY *)
	= identifier
	| `(`, declarator, `)`
	| direct_declarator, `[`, `]`
	| direct_declarator, `[`, constant_expression, `]`
	| direct_declarator, `(`, `)`
	| direct_declarator, `(`, parameter_type_list, `)`
	| direct_declarator, `(`, identifier_list, `)`
	;
=TEX
=DUMPMORE decl.grm.txt
pointer
	= `*`
	| `*`, type_qualifier_list
	| `*`, pointer
	| `*`, type_qualifier_list, pointer
	;
=TEX
=DUMPMORE decl.grm.txt
type_qualifier_list
	= type_qualifier
	| type_qualifier_list, type_qualifier
	;
=TEX
=DUMPMORE decl.grm.txt
parameter_type_list
	= parameter_list
	| parameter_list, `,`, `...`
	;
=TEX
=DUMPMORE decl.grm.txt
parameter_list
	= parameter_declaration
	| parameter_list, `,`, parameter_declaration
	;
=TEX
=DUMPMORE decl.grm.txt
parameter_declaration
	= declaration_specifiers, declarator
	| declaration_specifiers
	| declaration_specifiers, abstract_declarator
	;
=TEX
=DUMPMORE decl.grm.txt
identifier_list
	= identifier
	| identifier_list, `,`, identifier
	;
=TEX
=DUMPMORE decl.grm.txt
initializer
	= assignment_expression
	| `{`, initializer_list, `}`
	| `{`, initializer_list, `,`, `}`
	;
=TEX
=DUMPMORE decl.grm.txt
initializer_list
	= initializer
	| initializer_list, `,`, initializer
	;
=TEX
=DUMPMORE decl.grm.txt
type_name
	= specifier_qualifier_list
	| specifier_qualifier_list, abstract_declarator
	;
=TEX
=DUMPMORE decl.grm.txt
abstract_declarator
	= pointer
	| direct_abstract_declarator
	| pointer, direct_abstract_declarator
	;
=TEX
=DUMPMORE decl.grm.txt
direct_abstract_declarator
	= `(`, abstract_declarator, `)`
	| `[`, `]`
	| `[`, constant_expression, `]`
	| direct_abstract_declarator, `[`, `]`
	| direct_abstract_declarator, `[`, constant_expression, `]`
	| `(`, `)`
	| `(`, parameter_type_list, `)`
	| direct_abstract_declarator, `(`, `)`
	| direct_abstract_declarator, `(`, parameter_type_list, `)`
	;
=TEX
The production for {\it typedef\_name} has to be modified, since the grammar becomes ambiguous
if typedef names cannot be distinugished from other names. E.g., to decide whether the
expression ``{\tt(X)(x)}'' is a cast or a function call, one needs to know whether ``{\tt X}''
denotes a type.
=DUMPMORE decl.grm.txt
typedef_name = TypeDefName;
=TEX
\subsection{Statements}
=DUMP stmt.grm.txt
statement
	= labeled_statement
	| compound_statement
	| expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	;
=TEX
=TEX
=DUMPMORE stmt.grm.txt
labeled_statement
	= identifier, `:`, statement
	| `case`, constant_expression, `:`, statement
	| `default`, `:`, statement
	;
=TEX
=DUMPMORE stmt.grm.txt
compound_statement			(* REFERENCE ONLY *)
	= `{`, `}`
	| `{`, statement_list, `}`
	| `{`, declaration_list, `}`
	| `{`, declaration_list, statement_list, `}`
	;
=TEX
=DUMPMORE stmt.grm.txt
statement_list
	= statement
	| statement_list, statement
	;
=TEX
=DUMPMORE stmt.grm.txt
expression_statement
	= `;`
	| expression, `;`
	;
=TEX
This is where the shift/reduce conflict arises. The statement ``{\tt if(a) if(b) f(); else g();}''
can be parsed so that the else-part belongs to the inner if-statement or the outer one
according to the following grammar. The resolution is that it should belong to the
inner if-statement, i.e., reduce.
=DUMPMORE stmt.grm.txt
selection_statement
	= `if`, `(`, expression, `)`, statement
	| `if`, `(`, expression, `)`, statement, `else`, statement
	| `switch`, `(`, expression, `)`, statement
	;
=TEX
To avoid 7 extra cases in the following, we introduce a new production for an optional expression.
=DUMPMORE stmt.grm.txt
iteration_statement
	= `while`, `(`, expression, `)`, statement
	| `do`, statement, `while`, `(`, expression, `)`, `;`
	| `for`, `(`, expression_opt, `;`, expression_opt, `;`, expression_opt, `)`,
	  statement
	;
=TEX
=DUMPMORE stmt.grm.txt
expression_opt
	=
	| expression;
=TEX
=DUMPMORE stmt.grm.txt
jump_statement
	= `goto`, identifier, `;`
	| `continue`, `;`
	| `break`, `;`
	| `return`, expression_opt, `;`
	;
=TEX
\subsection{Expressions}

=DUMP expr.grm.txt
expression
	= assignment_expression
	| expression, `,`, assignment_expression
	;
=TEX
=DUMPMORE expr.grm.txt
=TEX
=DUMPMORE expr.grm.txt
assignment_expression
	= conditional_expression
	| unary_expression, assignment_operator, assignment_expression
	;
=TEX
=DUMPMORE expr.grm.txt
assignment_operator
	= `=`
	| `*=`
	| `/=`
	| `%=`
	| `+=`
	| `-=`
	| `<<=`
	| `>>=`
	| `&=`
	| `^=`
	| `|=`
	;
=TEX
=DUMPMORE expr.grm.txt
conditional_expression
	= logical_or_expression
	| logical_or_expression, `?`, expression, `:`, conditional_expression
	;
=TEX
=DUMPMORE expr.grm.txt
constant_expression
	= conditional_expression
	;
=TEX
=DUMPMORE expr.grm.txt
logical_or_expression
	= logical_and_expression
	| logical_or_expression, `||`, logical_and_expression
	;
=TEX
=DUMPMORE expr.grm.txt
logical_and_expression
	= inclusive_or_expression
	| logical_and_expression, `&&`, inclusive_or_expression
	;
=TEX
=DUMPMORE expr.grm.txt
inclusive_or_expression
	= exclusive_or_expression
	| inclusive_or_expression, `|`, exclusive_or_expression
	;
=TEX
=DUMPMORE expr.grm.txt
exclusive_or_expression
	= and_expression
	| exclusive_or_expression, `^`, and_expression
	;
=TEX
=DUMPMORE expr.grm.txt
and_expression
	= equality_expression
	| and_expression, `&`, equality_expression
	;
=TEX
=DUMPMORE expr.grm.txt
equality_expression
	= relational_expression
	| equality_expression, `==`, relational_expression
	| equality_expression, `!=`, relational_expression
	;
=TEX
=DUMPMORE expr.grm.txt
relational_expression
	= shift_expression
	| relational_expression, `<`, shift_expression
	| relational_expression, `>`, shift_expression
	| relational_expression, `<=`, shift_expression
	| relational_expression, `<=`, shift_expression
	;
=TEX
=DUMPMORE expr.grm.txt
shift_expression
	= additive_expression
	| shift_expression, `<<`, additive_expression
	| shift_expression, `>>`, additive_expression
	;
=TEX
=DUMPMORE expr.grm.txt
additive_expression
	= multiplicative_expression
	| additive_expression, `+`, multiplicative_expression
	| additive_expression, `-`, multiplicative_expression
	;
=TEX
=DUMPMORE expr.grm.txt
multiplicative_expression
	= cast_expression
	| multiplicative_expression, `*`, cast_expression
	| multiplicative_expression, `/`, cast_expression
	| multiplicative_expression, `%`, cast_expression
	;
=TEX
=DUMPMORE expr.grm.txt
cast_expression
	= unary_expression
	| `(`, type_name, `)`, cast_expression
	;
=TEX
=DUMPMORE expr.grm.txt
unary_expression
	= postfix_expression
	| `++`, unary_expression
	| `--`, unary_expression
	| unary_operator, cast_expression
	| `sizeof`, unary_expression
	| `sizeof`, `(`, type_name, `)`
	;
unary_operator
	= `&`
	| `*`
	| `+`
	| `-`
	| `~`
	| `!`
	;
=TEX
=DUMPMORE expr.grm.txt
postfix_expression
	= primary_expression
	| postfix_expression, `[`, expression, `]`
	| postfix_expression, `(`, `)`
	| postfix_expression, `(`, argument_expression_list, `)`
	| postfix_expression, `.`, identifier
	| postfix_expression, `->`, identifier
	| postfix_expression, `++`
	| postfix_expression, `--`
	;
=TEX
=DUMPMORE expr.grm.txt
primary_expression
	= identifier
	| constant
	| string
	| `(`, expression, `)`
	;
=TEX
=DUMPMORE expr.grm.txt
argument_expression_list
	= assignment_expression
	| argument_expression_list, `,`, assignment_expression
	;
=TEX
We leave enumeration constants out of the following list, on the grounds that a practical parser
would more likely treat them as identifiers during lexical analysis. The distinction between
enumeration constants and other identifiers does not affect the parsing.
=DUMPMORE expr.grm.txt
constant
	= IntegerConstant
	| CharacterConstant
	| FloatingConstant
	;
=TEX
We add productions for {\it string} and identifier just to keep the naming scheme uniform.
=DUMPMORE expr.grm.txt
string			(* REFERENCE ONLY *)
	= String
	;
=DUMPMORE expr.grm.txt
identifier
	= Identifier
	;
=TEX
=SH
cat decl.grm.txt stmt.grm.txt expr.grm.txt >>c.grm.txt
cat expr.grm.txt >>decl.grm.txt
cat decl.grm.txt >>stmt.grm.txt
# slrp -g -l 2 -f expr.grm.txt >expr.grm.run
# slrp -g -l 2 -f decl.grm.txt >decl.grm.run
# slrp -g -l 2 -f stmt.grm.txt >stmt.grm.run
slrp -g -l 2  -f c.grm.txt >c.grm.run
=TEX
=TEX
\newpage
\section{A WORKING VERSION} \label{WORKING}
First of all, we copy {\tt c.grm.txt} onto {\tt c1.grm.txt} but removing the productions marked
as REFERENCE ONLY
=SH
sed -e '/REFERENCE ONLY/,/;$/d' <c.grm.txt > c1.grm.txt
=TEX
We now give the changed productions together with the {\Slrp} reduction actions where appropriate.
These are all designed to work with the {\tt -g} option of {\Slrp}, which will cause it to fill
in the omitted reduction actions automatically.

The following change enables the declarative impact of a declaration that defines a type to occur
when the semicolon is read, i.e., ready for the next declaration.
Without this change, i.e., with the extra production {\it unterminated\_declaration} expanded away,
an input like ``{\tt typedef X int; X x;}'' could not be parsed, because the type definition
``{\tt typedef X int;}'' would not have been reduced at the point when the parser
needs to know the lexical classification of the ``{\tt X}'' that follows it.
A similar techique is also used below to ensure that the braces around a {\it declarator\_list} in a
{\tt struct} or {\tt union} declaration or in a {\it compound\_statement} are also reduced as they are recognised.
=DUMPMORE c1.grm.txt
declaration =
	unterminated_declaration, `;`
	(red_declaration ("declaration", 1) (x1, x2) stk)
	;
=TEX
=DUMPMORE c1.grm.txt
unterminated_declaration
	= declaration_specifiers
	| declaration_specifiers, init_declarator_list
	;
=TEX
The following changes let the parser flag when it is in a {\tt typedef} declaration \ldots
=DUMPMORE c1.grm.txt
storage_class_specifier
	= `auto`
	| `register`
	| `static`
	| `extern`
	| `typedef`
	(red_storage_class_specifier_5 ("storage_class_specifier", 5) x1 stk)
	;
=TEX
\ldots and let it know when declarators are inside a {\tt struct} or a {\tt union} \ldots
=DUMPMORE c1.grm.txt
struct_or_union_specifier
	= struct_or_union, begin_members, struct_declaration_list, end_members
	| struct_or_union, identifier, begin_members, struct_declaration_list, `}`
	| struct_or_union, identifier
	;
=TEX
\ldots which means taking the reduction action for the braces as soon as they are recognised as such \ldots
=DUMPMORE c1.grm.txt
begin_members =
	`{`
	(red_begin_members ("begin_members", 1) x1 stk)
	;
=TEX
=DUMPMORE c1.grm.txt
end_members =
	`}`
	(red_end_members ("end_members", 1) x1 stk)
	;
=TEX
\ldots and, when an identifier appears as  direct declarator, to register that identifier
as a new {\tt typedef} name, if that is what it is.
=DUMPMORE c1.grm.txt
direct_declarator
	= identifier
	(red_direct_declarator_1 ("direct_declarator", 1) x1 stk)
	| `(`, declarator, `)`
	| direct_declarator, `[`, `]`
	| direct_declarator, `[`, constant_expression, `]`
	| direct_declarator, `(`, `)`
	| direct_declarator, `(`, parameter_type_list, `)`
	| direct_declarator, `(`, identifier_list, `)`
	;
=TEX
Finally, the following changes let the parser detect the beginning and end of a compound
statement \ldots
=DUMPMORE c1.grm.txt
compound_statement
	= begin_block, end_block
	| begin_block, statement_list, end_block
	| begin_block, declaration_list, end_block
	| begin_block, declaration_list, statement_list, end_block
	;
=TEX
\ldots and detect the braces as soon as they are recognised.
=DUMPMORE c1.grm.txt
begin_block =
	`{`
	(red_begin_block ("begin_block", 1) x1 stk)
	;
=TEX
=DUMPMORE c1.grm.txt
end_block =
	`}`
	(red_end_block ("end_block", 1) x1 stk)
	;
=TEX
Finally, just to keep lexical analysis simple, we deal with adjacent string literals (see \cite[appendix A2.6]{kernighan88})
in the grammar rather than the lexis:
=DUMPMORE c1.grm.txt
string
	= String
	| string, String;
=TEX
=SH
slrp -g -l 2  -f c1.grm.txt >c1.grm.run
=TEX
\end{document}







