=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex
\def\Slrp{{\bf SLRP}}
\def\Hide#1{\relax}

%%%%% YOU WILL USUALLY WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{ A {\Slrp} Parser for ANSI-C }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document gives a grammar for ANSI-C together with the supporting code to form a parser for C.}
\end{center}}

\def\Reference{LEMMA1/PPTEX/WRK063}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.3 $%
}
\def\Date{\FormatDate{$Date: 2003/03/05 14:09:24 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1 -- 1.3] First drafts.
\item[ Issue 1.4 ] Corrections after (semi-automatic) testing against all of the {\tt xpp} code.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

As determined by experience with the template.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}
\begin{center}
\begin{tabular}{ll}
Lemma 1 Development Library
\end{tabular}
\end{center}


\newpage

%%%%% NOW THE CREATIVE BIT:

\section{Introduction}
\subsection{Scope}
This document provides an example of a grammar in the {\Slrp} format.
It may be used, {\it inter alia}, for testing the {\Slrp} parser generator.

\subsection{Purpose and Background}
This document is part of the {\Slrp} test suite and also provides an example of
various techniques of interest to users of {\Slrp}.

\subsection{Overview}

This document gives a grammar for ANSI C as per the 1990 standard \cite{ansi90}.
The grammar follows Kernighan \& Ritchie \cite{kernighan88} in leaving out lexical details and
preprocessor syntax.

The grammar is presented so that it can be processed by {\Slrp} in several ways.
Section~\ref{REFERENCE} of this document gives the plain grammar, much as in \cite{kernighan88}.
This grammar is given top-down, and is divided into four sections: translation units, declarations,
statements and expressions. The output from processing this section comprises
four separate {\Slrp} input files: {c.grm.txt}, {\tt decl.grm.txt}, {stmt.grm.txt} and {\tt expr.grm.txt},
each one of which contains the later ones. The sentence symbols for these four grammars are:
{\it translation\_unit}, {\it declaration}, {\it statement} and {\it expression} respectively.

The resulting {\Slrp} grammar for {\it translation\_unit} is essentially an instance of the observations at the beginning
of appendix A13 of~\cite{kernighan88}, which correctly predicts that the results is free
of LALR(1) conflicts apart from the shift/reduce conflict caused by the ``dangling else'' ambiguity
(which is to be resolved by always shifting, which makes the dangling else belong to the innermost
if-statement).

The grammar as presented in section~\ref{REFERENCE} is still not really suitable for practical use.
This is because it presupposes that the names defined in {\tt typedef} declarations.can be
distinguished lexically, whereas, in fact, that distinction is necessarily context-sensitive.
Section~\ref{WORKING} presents a working version of the grammar. This is obtained
by replacing a few of the productions in {\tt c.grm.txt} with productions that allow a parser
generated by {\Slrp} to record and use the necessary contextual information. The resulting
grammar is dumped into the file {\tt c1.grm.txt}. The productions in section~\ref{REFERENCE}
that are replaced are marked with a comment ``{\it (* REFERENCE ONLY *)}''.

Section~\ref{PARSER} completes the programme by instantiating
the generic parser produced by running {\Slrp} on the grammar to give a parser for C.
The semantic values of the parser are parse trees.

=TEX
\section{THE REFERENCE GRAMMAR} \label{REFERENCE}
\subsection{Translation Units}
=DUMP c.grm.txt
€translation_unit›
	= external_declaration
	| translation_unit, external_declaration
	;
=TEX
=DUMPMORE c.grm.txt
€external_declaration›
	= function_definition
	| declaration
	;
=TEX
=DUMPMORE c.grm.txt
€function_definition›
	= declarator, compound_statement
	| declarator, declaration_list, compound_statement
	| declaration_specifiers, declarator, compound_statement
	| declaration_specifiers, declarator, declaration_list, compound_statement
	;
=TEX
\subsection{Declarations}

=TEX
=DUMP decl.grm.txt
€declaration›				(* REFERENCE ONLY *)
	= declaration_specifiers, `;`
	| declaration_specifiers, init_declarator_list, `;`
	;
=TEX
=DUMPMORE decl.grm.txt
€declaration_list›
	= declaration
	| declaration_list, declaration
	;
=TEX
=DUMPMORE decl.grm.txt
€declaration_specifiers›
	= storage_class_specifier
	| storage_class_specifier, declaration_specifiers
	| type_specifier
	| type_specifier, declaration_specifiers
	| type_qualifier
	| type_qualifier, declaration_specifiers
	;
=TEX
=DUMPMORE decl.grm.txt
€storage_class_specifier›			(* REFERENCE ONLY *)
	= `auto`
	| `register`
	| `static`
	| `extern`
	| `typedef`
	;
=TEX
=DUMPMORE decl.grm.txt
€type_specifier›
	= `void`
	| `char`
	| `short`
	| `int`
	| `long`
	| `float`
	| `double`
	| `signed`
	| `unsigned`
	| struct_or_union_specifier
	| enum_specifier
	| typedef_name
	;
=TEX
=DUMPMORE decl.grm.txt
€type_qualifier›
	= `const`
	| `volatile`
	;
=TEX
=DUMPMORE decl.grm.txt
€struct_or_union_specifier›		(* REFERENCE ONLY *)
	= struct_or_union, `{`, struct_declaration_list, `}`
	| struct_or_union, identifier, `{`, struct_declaration_list, `}`
	| struct_or_union, identifier
	;
=TEX
=DUMPMORE decl.grm.txt
€struct_or_union›
	= `struct`
	| `union`
	;
=TEX
=DUMPMORE decl.grm.txt
€struct_declaration_list›
	= struct_declaration
	| struct_declaration_list, struct_declaration
	;
=TEX
=DUMPMORE decl.grm.txt
€init_declarator_list›
	= init_declarator
	| init_declarator_list, `,`, init_declarator
	;
=TEX
=DUMPMORE decl.grm.txt
€init_declarator›
	= declarator
	| declarator, `=`, initializer
	;
=TEX
=DUMPMORE decl.grm.txt
€struct_declaration›
	= specifier_qualifier_list, struct_declarator_list, `;`
	;
=TEX
=DUMPMORE decl.grm.txt
€specifier_qualifier_list›
	= type_specifier
	| type_specifier, specifier_qualifier_list
	| type_qualifier
	| type_qualifier, specifier_qualifier_list
	;
=TEX
=DUMPMORE decl.grm.txt
€struct_declarator_list›
	= struct_declarator
	| struct_declarator_list, `,`, struct_declarator
	;
=TEX
=DUMPMORE decl.grm.txt
€struct_declarator›
	= declarator
	| `:`, constant_expression
	| declarator, `:`, constant_expression
	;
=TEX
=DUMPMORE decl.grm.txt
€enum_specifier›
	= `enum`, `{`, enumerator_list, `}`
	| `enum`, identifier, `{`, enumerator_list, `}`
	| `enum`, identifier
	;
=TEX
=DUMPMORE decl.grm.txt
€enumerator_list›
	= enumerator
	| enumerator_list, `,`, enumerator
	;
=TEX
=DUMPMORE decl.grm.txt
€enumerator›
	= identifier
	| identifier, `=`, constant_expression
	;
=TEX
=DUMPMORE decl.grm.txt
€declarator›
	= direct_declarator
	| pointer, direct_declarator
	;
=TEX
=DUMPMORE decl.grm.txt
€direct_declarator›		(* REFERENCE ONLY *)
	= identifier
	| `(`, declarator, `)`
	| direct_declarator, `[`, `]`
	| direct_declarator, `[`, constant_expression, `]`
	| direct_declarator, `(`, `)`
	| direct_declarator, `(`, parameter_type_list, `)`
	| direct_declarator, `(`, identifier_list, `)`
	;
=TEX
=DUMPMORE decl.grm.txt
€pointer›
	= `*`
	| `*`, type_qualifier_list
	| `*`, pointer
	| `*`, type_qualifier_list, pointer
	;
=TEX
=DUMPMORE decl.grm.txt
€type_qualifier_list›
	= type_qualifier
	| type_qualifier_list, type_qualifier
	;
=TEX
=DUMPMORE decl.grm.txt
€parameter_type_list›
	= parameter_list
	| parameter_list, `,`, `...`
	;
=TEX
=DUMPMORE decl.grm.txt
€parameter_list›
	= parameter_declaration
	| parameter_list, `,`, parameter_declaration
	;
=TEX
=DUMPMORE decl.grm.txt
€parameter_declaration›
	= declaration_specifiers, declarator
	| declaration_specifiers
	| declaration_specifiers, abstract_declarator
	;
=TEX
=DUMPMORE decl.grm.txt
€identifier_list›
	= identifier
	| identifier_list, `,`, identifier
	;
=TEX
=DUMPMORE decl.grm.txt
€initializer›
	= assignment_expression
	| `{`, initializer_list, `}`
	| `{`, initializer_list, `,`, `}`
	;
=TEX
=DUMPMORE decl.grm.txt
€initializer_list›
	= initializer
	| initializer_list, `,`, initializer
	;
=TEX
=DUMPMORE decl.grm.txt
€type_name›
	= specifier_qualifier_list
	| specifier_qualifier_list, abstract_declarator
	;
=TEX
=DUMPMORE decl.grm.txt
€abstract_declarator›
	= pointer
	| direct_abstract_declarator
	| pointer, direct_abstract_declarator
	;
=TEX
=DUMPMORE decl.grm.txt
€direct_abstract_declarator›
	= `(`, abstract_declarator, `)`
	| `[`, `]`
	| `[`, constant_expression, `]`
	| direct_abstract_declarator, `[`, `]`
	| direct_abstract_declarator, `[`, constant_expression, `]`
	| `(`, `)`
	| `(`, parameter_type_list, `)`
	| direct_abstract_declarator, `(`, `)`
	| direct_abstract_declarator, `(`, parameter_type_list, `)`
	;
=TEX
The production for {\it typedef\_name} has to be modified, since the grammar becomes ambiguous
if typedef names cannot be distinugished from other names. E.g., to decide whether the
expression ``{\tt(X)(x)}'' is a cast or a function call, one needs to know whether ``{\tt X}''
denotes a type.
=DUMPMORE decl.grm.txt
€typedef_name› = TypeDefName;
=TEX
\subsection{Statements}
=DUMP stmt.grm.txt
€statement›
	= labeled_statement
	| compound_statement
	| expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	;
=TEX
=TEX
=DUMPMORE stmt.grm.txt
€labeled_statement›
	= identifier, `:`, statement
	| `case`, constant_expression, `:`, statement
	| `default`, `:`, statement
	;
=TEX
=DUMPMORE stmt.grm.txt
€compound_statement›			(* REFERENCE ONLY *)
	= `{`, `}`
	| `{`, statement_list, `}`
	| `{`, declaration_list, `}`
	| `{`, declaration_list, statement_list, `}`
	;
=TEX
=DUMPMORE stmt.grm.txt
€statement_list›
	= statement
	| statement_list, statement
	;
=TEX
=DUMPMORE stmt.grm.txt
€expression_statement›
	= `;`
	| expression, `;`
	;
=TEX
This is where the shift/reduce conflict arises. The statement ``{\tt if(a) if(b) f(); else g();}''
can be parsed so that the else-part belongs to the inner if-statement or the outer one
according to the following grammar. The resolution is that it should belong to the
inner if-statement, i.e., reduce.
=DUMPMORE stmt.grm.txt
€selection_statement›
	= `if`, `(`, expression, `)`, statement
	| `if`, `(`, expression, `)`, statement, `else`, statement
	| `switch`, `(`, expression, `)`, statement
	;
=TEX
To avoid 7 extra cases in the following, we introduce a new production for an optional expression.
=DUMPMORE stmt.grm.txt
€iteration_statement›
	= `while`, `(`, expression, `)`, statement
	| `do`, statement, `while`, `(`, expression, `)`, `;`
	| `for`, `(`, expression_opt, `;`, expression_opt, `;`, expression_opt, `)`,
	  statement
	;
=TEX
=DUMPMORE stmt.grm.txt
€expression_opt›
	=
	| expression;
=TEX
=DUMPMORE stmt.grm.txt
€jump_statement›
	= `goto`, identifier, `;`
	| `continue`, `;`
	| `break`, `;`
	| `return`, expression_opt, `;`
	;
=TEX
\subsection{Expressions}

=DUMP expr.grm.txt
€expression›
	= assignment_expression
	| expression, `,`, assignment_expression
	;
=TEX
=DUMPMORE expr.grm.txt
=TEX
=DUMPMORE expr.grm.txt
€assignment_expression›
	= conditional_expression
	| unary_expression, assignment_operator, assignment_expression
	;
=TEX
=DUMPMORE expr.grm.txt
€assignment_operator›
	= `=`
	| `*=`
	| `/=`
	| `%=`
	| `+=`
	| `-=`
	| `<<=`
	| `>>=`
	| `&=`
	| `^=`
	| `|=`
	;
=TEX
=DUMPMORE expr.grm.txt
€conditional_expression›
	= logical_or_expression
	| logical_or_expression, `?`, expression, `:`, conditional_expression
	;
=TEX
=DUMPMORE expr.grm.txt
€constant_expression›
	= conditional_expression
	;
=TEX
=DUMPMORE expr.grm.txt
€logical_or_expression›
	= logical_and_expression
	| logical_or_expression, `||`, logical_and_expression
	;
=TEX
=DUMPMORE expr.grm.txt
€logical_and_expression›
	= inclusive_or_expression
	| logical_and_expression, `&&`, inclusive_or_expression
	;
=TEX
=DUMPMORE expr.grm.txt
€inclusive_or_expression›
	= exclusive_or_expression
	| inclusive_or_expression, `|`, exclusive_or_expression
	;
=TEX
=DUMPMORE expr.grm.txt
€exclusive_or_expression›
	= and_expression
	| exclusive_or_expression, `^`, and_expression
	;
=TEX
=DUMPMORE expr.grm.txt
€and_expression›
	= equality_expression
	| and_expression, `&`, equality_expression
	;
=TEX
=DUMPMORE expr.grm.txt
€equality_expression›
	= relational_expression
	| equality_expression, `==`, relational_expression
	| equality_expression, `!=`, relational_expression
	;
=TEX
=DUMPMORE expr.grm.txt
€relational_expression›
	= shift_expression
	| relational_expression, `<`, shift_expression
	| relational_expression, `>`, shift_expression
	| relational_expression, `<=`, shift_expression
	| relational_expression, `>=`, shift_expression
	;
=TEX
=DUMPMORE expr.grm.txt
€shift_expression›
	= additive_expression
	| shift_expression, `<<`, additive_expression
	| shift_expression, `>>`, additive_expression
	;
=TEX
=DUMPMORE expr.grm.txt
€additive_expression›
	= multiplicative_expression
	| additive_expression, `+`, multiplicative_expression
	| additive_expression, `-`, multiplicative_expression
	;
=TEX
=DUMPMORE expr.grm.txt
€multiplicative_expression›
	= cast_expression
	| multiplicative_expression, `*`, cast_expression
	| multiplicative_expression, `/`, cast_expression
	| multiplicative_expression, `%`, cast_expression
	;
=TEX
=DUMPMORE expr.grm.txt
€cast_expression›
	= unary_expression
	| `(`, type_name, `)`, cast_expression
	;
=TEX
=DUMPMORE expr.grm.txt
€unary_expression›
	= postfix_expression
	| `++`, unary_expression
	| `--`, unary_expression
	| unary_operator, cast_expression
	| `sizeof`, unary_expression
	| `sizeof`, `(`, type_name, `)`
	;
€unary_operator›
	= `&`
	| `*`
	| `+`
	| `-`
	| `~`
	| `!`
	;
=TEX
=DUMPMORE expr.grm.txt
€postfix_expression›
	= primary_expression
	| postfix_expression, `[`, expression, `]`
	| postfix_expression, `(`, `)`
	| postfix_expression, `(`, argument_expression_list, `)`
	| postfix_expression, `.`, identifier
	| postfix_expression, `->`, identifier
	| postfix_expression, `++`
	| postfix_expression, `--`
	;
=TEX
=DUMPMORE expr.grm.txt
€primary_expression›
	= identifier
	| constant
	| string
	| `(`, expression, `)`
	;
=TEX
=DUMPMORE expr.grm.txt
€argument_expression_list›
	= assignment_expression
	| argument_expression_list, `,`, assignment_expression
	;
=TEX
We leave enumeration constants out of the following list, on the grounds that a practical parser
would more likely treat them as identifiers during lexical analysis. The distinction between
enumeration constants and other identifiers does not affect the parsing.
=DUMPMORE expr.grm.txt
€constant›
	= IntegerConstant
	| CharacterConstant
	| FloatingConstant
	;
=TEX
We add productions for {\it string} and identifier just to keep the naming scheme uniform.
=DUMPMORE expr.grm.txt
€string›			(* REFERENCE ONLY *)
	= String
	;
=DUMPMORE expr.grm.txt
€identifier›
	= Identifier
	;
=TEX
=SH
cat decl.grm.txt stmt.grm.txt expr.grm.txt >>c.grm.txt
cat expr.grm.txt >>decl.grm.txt
cat decl.grm.txt >>stmt.grm.txt
# slrp -g -l 2 -f expr.grm.txt >expr.grm.run
# slrp -g -l 2 -f decl.grm.txt >decl.grm.run
# slrp -g -l 2 -f stmt.grm.txt >stmt.grm.run
slrp -g -l 2  -f c.grm.txt >c.grm.run
=TEX
=TEX
\newpage
\section{A WORKING VERSION} \label{WORKING}
First of all, we copy {\tt c.grm.txt} onto {\tt c1.grm.txt} but removing the productions marked
as REFERENCE ONLY
=SH
sed -e '/REFERENCE ONLY/,/;$/d' <c.grm.txt > c1.grm.txt
=TEX
We now give the changed productions together with the {\Slrp} reduction actions where appropriate.
These are all designed to work with the {\tt -g} option of {\Slrp}, which will cause it to fill
in the omitted reduction actions automatically.

The following change enables the declarative impact of a declaration that defines a type to occur
when the semicolon is read, i.e., ready for the next declaration.
Without this change, i.e., with the extra production {\it unterminated\_declaration} expanded away,
an input like ``{\tt typedef X int; X x;}'' could not be parsed, because the type definition
``{\tt typedef X int;}'' would not have been reduced at the point when the parser
needs to know the lexical classification of the ``{\tt X}'' that follows it.
A similar techique is also used below to ensure that the braces around a {\it declarator\_list} in a
{\tt struct} or {\tt union} declaration or in a {\it compound\_statement} are also reduced as they are recognised.
=DUMPMORE c1.grm.txt
€declaration› =
	unterminated_declaration, `;`
	(red_declaration ("declaration", 1) (x1, x2) stk)
	;
=TEX
=DUMPMORE c1.grm.txt
€unterminated_declaration›
	= declaration_specifiers
	| declaration_specifiers, init_declarator_list
	;
=TEX
The following changes let the parser flag when it is in a {\tt typedef} declaration \ldots
=DUMPMORE c1.grm.txt
€storage_class_specifier›
	= `auto`
	| `register`
	| `static`
	| `extern`
	| `typedef`
	(red_storage_class_specifier_5 ("storage_class_specifier", 5) x1 stk)
	;
=TEX
\ldots and let it know when declarators are inside a {\tt struct} or a {\tt union} \ldots
=DUMPMORE c1.grm.txt
€struct_or_union_specifier›
	= struct_or_union, begin_members, struct_declaration_list, end_members
	| struct_or_union, identifier, begin_members, struct_declaration_list, end_members
	| struct_or_union, identifier
	;
=TEX
\ldots which means taking the reduction action for the braces as soon as they are recognised as such \ldots
=DUMPMORE c1.grm.txt
€begin_members› =
	`{`
	(red_begin_members ("begin_members", 1) x1 stk)
	;
=TEX
=DUMPMORE c1.grm.txt
€end_members› =
	`}`
	(red_end_members ("end_members", 1) x1 stk)
	;
=TEX
\ldots and, when an identifier appears as  direct declarator, to register that identifier
as a new {\tt typedef} name, if that is what it is.
=DUMPMORE c1.grm.txt
€direct_declarator›
	= identifier
	(red_direct_declarator_1 ("direct_declarator", 1) x1 stk)
	| `(`, declarator, `)`
	| direct_declarator, `[`, `]`
	| direct_declarator, `[`, constant_expression, `]`
	| direct_declarator, `(`, `)`
	| direct_declarator, begin_formal_params, parameter_type_list, end_formal_params
	| direct_declarator, `(`, identifier_list, `)`
	;
=DUMPMORE c1.grm.txt
€begin_formal_params› =
	`(`
	(red_begin_formal_params ("begin_formal_params", 1) x1 stk)
	;
=TEX
=DUMPMORE c1.grm.txt
€end_formal_params› =
	`)`
	(red_end_formal_params ("end_formal_params", 1) x1 stk)
	;
=TEX
The following changes let the parser detect the beginning and end of a compound
statement \ldots
=DUMPMORE c1.grm.txt
€compound_statement›
	= begin_block, end_block
	| begin_block, statement_list, end_block
	| begin_block, declaration_list, end_block
	| begin_block, declaration_list, statement_list, end_block
	;
=TEX
\ldots and detect the braces as soon as they are recognised.
=DUMPMORE c1.grm.txt
€begin_block› =
	`{`
	(red_begin_block ("begin_block", 1) x1 stk)
	;
=TEX
=DUMPMORE c1.grm.txt
€end_block› =
	`}`
	(red_end_block ("end_block", 1) x1 stk)
	;
=TEX
Finally, just to keep lexical analysis simple, we deal with adjacent string literals (see \cite[appendix A2.6]{kernighan88})
in the grammar rather than the lexis:
=DUMPMORE c1.grm.txt
€string›
	= String
	| string, String;
=TEX
=SH
slrp -g -l 2  -f c1.grm.txt >c1.grm.run
=TEX
\newpage
\section{PARSER IMPLEMENTATION}\label{PARSER}
\subsection{Compiling the {\Slrp} library code}
The following source files need to be loaded if we are not building the parser on top of
a {\Product} database or the {\Slrp} database:
=SML
map use [
	"dtd108.sml",	(* Portability infrastructure *)
	"imp108.sml",
	"dtd002.sml",	(* System control and error reporting *)
	"imp002.sml",
	"dtd001.sml",	(* Standard ML utilities *)
	"imp001.sml"];
=TEX
The following source files need to be loaded if we are not building the parser on top of
the {\Slrp} database:
=SML
map use [
	"dtd018.sml",	(* SLRP parser driver *)
	"imp018.sml",
	"dtd118.sml",	(* Generic SLRP parser support *)
	"imp118.sml"
	];
=TEX
=SML
open GenericSlrpParser;
=TEX
\subsection{Parser State}
We need to track the type definitions in the input, which we do by manipulating
a type environment defined as follows (and in which when we push a new frame, we
copy the dictionary from the outer frame into it).
=SML
val €type_env› : unit E_DICT list ref = ref [initial_e_dict];
=TEX
We also need to keep track of when we are in a type definition and when we are
inside the declarator-list that declares the members of a struct or union or in a formal
parameter list in a declarator (and these
can be nested, so we have a counter giving the nesting depth).
=SML
val €in_type_def› : bool ref = ref false;
val €str_un_fpar_nesting› : int ref = ref 0;
=TEX
=SML
fun €reset_state› () = (
	type_env := [initial_e_dict];
	in_type_def := false;
	str_un_fpar_nesting := 0
);
=TEX
\subsection{Classifier Function}
The approach we are taking here relies on the names of the terminal symbols, {\it CharacterConstant},
{\it FloatingConstant}, {\it IntegerConstant} and {\it String} being neither C keywords nor C
operators  (as indeed is the case).
=SML
fun €c_classifier› (LVIdentifier (s, _) : LEX_VALUE) : LEX_CLASS = (
	case e_lookup s (hd(!type_env)) of
		Value () => LCIdentifier "TypeDefName"
	|	Nil => LCIdentifier "Identifier"
) | c_classifier (LVString (s, _)) = (
	case s of
		"CharacterConstant" => LCIdentifier s
	|	"FloatingConstant" => LCIdentifier s
	|	"IntegerConstant" => LCIdentifier s
	|	"String" => LCIdentifier s
	|	_ => LCString s
) |  c_classifier (LVEos _) = LCEos;
=TEX
\subsection{Reduction Actions}
=TEX
When called with the {\it -g} option on our grammar, {\Slrp} will generate the action
code automatically for each rule that does not contain any action code. The automatically
generated action is a call on the function {\it generic\_reducer}. Our custom reduction
functions simply update the parser state as necessary and then make the same
call on {\it generic\_reducer} as the automatically generated code would make:

=TEX
=SML
fun €red_declaration› (nt, i) (x1,x2) stk = (
	(* declaration = unterminated_declaration, `;` *)
	in_type_def := false;
	generic_reducer (nt, i) [x1,x2] stk
);
=TEX
=SML
fun €red_storage_class_specifier_5› (nt, i) (x1) stk = (
	(* storage_class_specifier = `typedef` *)
	in_type_def := true;
	generic_reducer (nt, i) [x1] stk
);
=TEX
=SML
fun €red_begin_members› (nt, i) (x1) stk = (
	(* begin_members = `{` *)
	str_un_fpar_nesting := !str_un_fpar_nesting + 1;
	generic_reducer (nt, i) [x1] stk
);
=TEX
=SML
fun €red_end_members› (nt, i) (x1) stk = (
	(* end_members = `}` *)
	str_un_fpar_nesting := !str_un_fpar_nesting - 1;
	generic_reducer (nt, i) [x1] stk
);
=TEX
=SML
val €red_begin_formal_params› = red_begin_members;
=TEX
=SML
val €red_end_formal_params› = red_end_members;
=TEX
=SML
fun €red_begin_block› (nt, i) (x1) stk = (
	(* begin_block = `{` *)
	type_env := hd(!type_env) :: !type_env;
	generic_reducer (nt, i) [x1] stk
);
=TEX
=SML
fun €red_end_block› (nt, i) (x1) stk = (
	(* end_block = `}` *)
	type_env := tl (!type_env);
	generic_reducer (nt, i) [x1] stk
);
=TEX
=SML
fun €red_direct_declarator_1› (nt, i) (x1) stk = (
	(* direct_declarator = identifier *)
	(case x1 of
		Parsed(Node(_, [Leaf(LVIdentifier (s, _), _)])) => (
			if	!in_type_def andalso !str_un_fpar_nesting = 0
			then	type_env := e_enter s () (hd(!type_env)) :: tl (!type_env)
			else	()
		) | _ => ()
	);
	generic_reducer (nt, i) [x1] stk
);
=TEX
\subsection{Lexical Analyser}
=TEX
Now we construct the lexical analyser.
\subsection{Comments}
=SML
fun €skip_to_end_of_comment› ("*" :: "/"::more) = Value more
|   skip_to_end_of_comment (_::more) = skip_to_end_of_comment more
|   skip_to_end_of_comment [] = Nil;
=TEX
Since they are otherwise lexically illegal, we recognise C++-style single line comments as well
as the standard ANSI ones. Similarly, we treat preprocessor directives as comments (to
skip over the ``\verb!#line!'' directives that {\tt cc -E} typically generates).
=SML
fun €rec_comment› ((chs, status as (Continuation (_, InComment))) : LEX_STATE)
	: LEX_STATE = (
	case skip_to_end_of_comment chs of
		Value rest => (rest, Comment)
	|	Nil => ([], status)
) | rec_comment (chs, status as Continuation _) = (
	(chs, Unknown)
) | rec_comment ("/" :: "*"  :: chs, status) = (
	case skip_to_end_of_comment chs of
		Value rest => (rest, Comment)
	|	Nil => ([], Continuation(get_line_number(), InComment))
) | rec_comment ("/" :: "/"  :: chs, status) = (([], Comment)
) | rec_comment ("#" :: chs, status) = (([], Comment)
) | rec_comment (chs, _) = (chs, Unknown);
=TEX
\subsection{Keywords and Identifiers}
=SML
val €keyword_dict› : string E_DICT =
	list_e_merge initial_e_dict (map (fn s => (s, s)) [
	"auto", "break", "case", "char", "const", "continue", "default", "double",
	"do", "else", "enum", "extern", "float", "for", "goto", "if",
	"int", "long", "register", "return", "short", "signed", "sizeof", "static",
	"struct", "switch", "typedef", "union", "unsigned", "void", "volatile", "while"
]);
=TEX
The following could be implemented more efficiently by adapting some of the analogous code
from IMP118.
=SML
fun €c_is_alpha› ch = (
		"a" <= ch andalso ch <= "z"
	orelse	"A" <= ch andalso ch <= "Z"
	orelse	ch = "_"
);
=TEX
=SML
fun €is_digit› ch = "0" <= ch andalso ch <= "9";
=TEX
=SML
val €is_alnum› = c_is_alpha fun_or is_digit;
=TEX
=SML
fun €get_ident› [] = Nil
| get_ident (chs as (ch :: more)) = (
	let	fun aux acc [] = Value(implode(rev acc), [])
		|   aux acc (c::more) = (
			if	is_alnum c
			then	aux (c::acc) more
			else	Value(implode(rev acc), c::more)
		);
	in	if	c_is_alpha ch
		then	aux [ch] more
		else	Nil
	end
);
=TEX
=SML
fun €rec_ident› ((chs, status) : LEX_STATE) : LEX_STATE = (
	case get_ident chs of
		Value(n, more) => (
			case e_lookup n keyword_dict of
				Value s =>(
					 (more,
					 Known (LVString (s, get_line_number())))
			) |	Nil => (
					 (more,
					 Known (LVIdentifier (n, get_line_number())))
			)
	) |	Nil => (chs, Unknown)
);
=TEX
\subsection{Integer Constants}
=SML
fun €is_int_type_char› "u" = true
|   is_int_type_char "U" = true
|   is_int_type_char "l" = true
|   is_int_type_char "L" = true
|   is_int_type_char _ = false;
=TEX
=SML
fun €is_hexit› ch = (
		is_digit ch
	orelse	("a" <= ch andalso ch <= "f")
	orelse	("A" <=  ch andalso ch <= "F")
);
=TEX
=SML
fun €get_integer› [] = Nil
| get_integer (chs as (ch :: more)) = (
	let	fun aux1 acc [] = Value(implode(rev acc), [])
		|    aux1 acc (c::more) = (
			if	is_int_type_char c
			then	aux1 (c::acc) more
			else	Value(implode(rev acc), c::more)
		);
		fun aux2 test acc [] = Value(implode(rev acc), [])
		|   aux2 test acc (c::more) = (
			if	test c
			then	aux2 test (c::acc) more
			else if	is_int_type_char c
			then	aux1 (c::acc) more
			else	Value(implode(rev acc), c::more)
		);
		fun aux3 acc ("x" :: more) = aux2 is_hexit ("x"::acc) more
		|   aux3 acc ("X" :: more) = aux2 is_digit ("X"::acc) more
		|   aux3 acc chs = aux2 is_digit acc chs;
	in	if	is_digit ch
		then	aux3 [ch] more
		else	Nil
	end
);
=TEX
=SML
fun €rec_integer› ((chs, status) : LEX_STATE) : LEX_STATE = (
	case get_integer chs of
		Value(n, more) => (
			 (more,
			 Known (LVString ("IntegerConstant", get_line_number())))
	) |	Nil => (chs, Unknown)
);
=TEX
\subsection{Character Constants}
We widen the lexis of character constants to allow any sequence of characters
inside single quote marks, using backslash as an escape character. I.e., we are
deferring the check that the character constant actually denotes a single valid
character to a later stage of processing (not implemented here).
=SML
fun €get_char_const› acc ("'"::more) = (implode(rev ("'"::acc)), more)
|   get_char_const acc ("\\"::ch::more) = get_char_const (ch::"\\"::acc) more
|   get_char_const acc (ch::more) = get_char_const (ch::acc) more
|   get_char_const acc [] = (
	raise LexFail (get_line_number(), "unmatched character quotation symbol")
);
=TEX
=SML
fun €rec_char_const› (("'"::chs, status) : LEX_STATE) : LEX_STATE = (
	let	val (this, rest) = get_char_const ["'"] chs
	in	(rest, Known(LVString ("CharacterConstant", get_line_number())))
	end
) | rec_char_const (chs, _) = (chs, Unknown);
=TEX
\subsection{Floating Constants}
=SML
fun €is_floating_type_char› "f" = true
|   is_floating_type_char "F" = true
|   is_floating_type_char "l" = true
|   is_floating_type_char "L" = true
|   is_floating_type_char _ = false;
=TEX
=SML
fun €is_floating_exp_char› "e" = true
|   is_floating_exp_char "E" = true
|   is_floating_exp_char _ = false;
=TEX
=SML
fun €get_floating› [] = Nil
| get_floating (chs as (ch :: _)) = (
	let	fun aux1 acc [] = Value(implode(rev acc), [])
		|    aux1 acc (c::more) = (
			if	is_floating_type_char c
			then	aux1 (c::acc) more
			else	Value(implode(rev acc), c::more)
		);
		fun aux2 got_digit got_exp acc [] = Value(implode(rev acc), [])
		|   aux2 got_digit got_exp acc (c::more) = (
			if	is_digit c
			then	aux2 true got_exp (c::acc) more
			else if	not got_digit
			then	Nil
			else if	is_floating_exp_char c
			then	if	got_exp
				then	Value(implode(rev acc), c::more)
				else	aux2 got_digit true (c::acc) more
			else if	is_floating_type_char c
			then	aux1 (c::acc) more
			else	Value(implode(rev acc), c::more)
		);
		fun aux3 got_digit acc ("." :: more) = aux2 got_digit false ("."::acc) more
		|   aux3 _ _ _ = Nil;
		fun aux4 _ _ [] =Nil
		|   aux4 got_digit acc (c::more) = (
			if	is_digit c
			then	aux4 true (c::acc) more
			else	aux3 got_digit acc (c::more)
		);

	in	if	is_digit ch orelse ch = "."
		then	aux4 false [] chs
		else	Nil
	end
);
=TEX
=SML
fun €rec_floating› ((chs, status) : LEX_STATE) : LEX_STATE = (
	case get_floating chs of
		Value(n, more) => (
			 (more,
			 Known (LVString ("FloatingConstant", get_line_number())))
	) |	Nil => (chs, Unknown)
);
=TEX
\subsection{String Constants}
The grammar takes care of the treatment of adjacent string literals.
=SML
fun €get_string_lit› acc ("\""::more) = (implode(rev ("\""::acc)), more)
|   get_string_lit acc ("\\"::ch::more) = get_string_lit (ch::"\\"::acc) more
|   get_string_lit acc (ch::more) = get_string_lit (ch::acc) more
|   get_string_lit acc [] = (
	raise LexFail (get_line_number(), "unmatched string quotation symbol")
);
=TEX
=SML
fun €rec_string_lit› (("\""::chs, status) : LEX_STATE) : LEX_STATE = (
	let	val (this, rest) = get_string_lit ["\""] chs
	in	(rest, Known(LVString ("String", get_line_number())))
	end
) | rec_string_lit (chs, _) = (chs, Unknown);
=TEX
=TEX
\subsection{Operators}
=SML
val €operator_dict› : string E_DICT =
	list_e_merge initial_e_dict (map (fn s => (s, s)) [
	"!=", "!", "\037=", "\037", "&&", "&=", "&", "(",
	")", "*=", "*", "++", "+=", "+", ",", "--",
	"-=", "->", "-", "...", ".", "/=", "/", ":",
	";", "<<=", "<<", "<=", "<", "==", "=", ">=",
	">>=", ">>", ">", "?", "[", "]", "^=", "^",
	"{", "|=", "|", "||", "}", "~"
]);
=TEX
In the following the magic number 2 is 1 less than the maximum length of an operator symbol.
=SML
fun  €get_operator› chs = (
	let	fun aux ~1 = Nil
		|    aux i = (
			case e_lookup (implode (chs to i)) operator_dict of
				Value s => Value(s, chs from(i+1))
			|	Nil => aux (i-1)
		);
	in	aux 2
	end
);
=TEX
=SML
fun €rec_operator› ((chs, status) : LEX_STATE) : LEX_STATE = (
	case get_operator chs of
		Value(n, more) => (
			(more, Known (LVString (n, get_line_number())))
	) |	Nil => (chs, Unknown)
);
=TEX
In the following, it is important that we do comments before anything else and floating constants
before operators or integer constants.
=SML
val €rec_any› = rec_first[
	rec_comment,
	rec_ident,
	rec_floating,
	rec_operator,
	rec_integer,
	rec_string_lit,
	rec_char_const];
=TEX
\subsection{Resolver Function}
There is one shift/reduce conflict as shown in the following outline extract from the {\Slrp} listing:
=GFT SLRP Output
+++ State Table +++
...
210:	selection_statement = `if`, `(`, expression, `)`, statement.
	selection_statement = `if`, `(`, expression, `)`, statement., `else`, statement
...
348:	...
	selection_statement = `if`, `(`, expression, `)`, statement, `else`., statement
	...
...
+++ Conflicts +++

LALR(1) lookahead sets resolved 12 conflicts

1 conflict detected (1 shift/reduce, 0 reduce/reduce)

State 210 on symbol `else`
	Reduce by selection_statement = `if`, `(`, expression, `)`, statement | ...
	Shift to 348
=TEX
The conflict arises when the statement forming the then-part of the if-statement is
itself an if-statement with no else-part (yet). The resolution is to shift, which means that
the else-part is given to the inner if-statement. (If we were to reduce, then the parser would
not work: a valid input such as ``{\tt while(a) if(b) f(x); else g(x);}'' would be unparseable).

The upshot of all this is that the resolver function is extremely simple:
=SML
fun €c_resolver› _ = DoShift;
=TEX
\subsection{The Parser}
The parser is now completed in two easy stages:
First include the Standard ML code generated by {\Slrp}:
=IGN
use_file"c1.grm";
=INCLUDE
c1.grm.sml
=TEX
Second, {\it et voila}, instantiate the function {\it slrp'gen\_parser} generated
by {\Slrp} to use our resolver, classifier etc.
=SML
fun €c_parse_file› name = (
	reset_state();
	slrp'gen_parser c_resolver c_classifier
	(default_error string_of_lex_value)
	(gen_reader rec_any (in_char_stream_of_file name))
	([], true)
);
=TEX
\subsection{A Simple Test}
=DUMP wrk063.c
#define MSG "Hello World!\n"
#define LEN_MSG (sizeof MSG - 1)
#define STDOUT 1
int main(int argc, char **argv)
{
	return (write(STDOUT, MSG, LEN_MSG) != LEN_MSG);
}
=TEX
=SH
cc -E wrk063.c >wrk063.i
=SML
print_tree (curry output std_out) (c_parse_file"wrk063.i");
=TEX
\newpage
\section{INDEX}
\small
\printindex
\end{document}


=IGN
rm -rf t
mkdir t
cd t
ln -s ~/tmp/daz/RCS  .
co `make -f xpp.mkf`packinglist`
make -f xpp.mkf help.c
for f in *.c
do
	b=`basename $f .c`
	cc -E -DLINUX $b.c |
		sed -e '/__extension__/s/__extension__/ /g' \
			-e '/__const/s/__const/ /g' \
			-e '/__restrict/s/__restrict/ /g' \
			-e '/__inline__/s/__inline__/ /g' \
			-e '/__attribute__.*;/s/__attribute__.*;/;/g' \
		 > $b.i
done

fun f (Leaf _) = 1
|   f (Node(_, children)) = (
	1 + fold (op +) (map f children) 0
);
f (c_parse_file "t/cmdline.i");
f (c_parse_file "t/diag.i");
f (c_parse_file "t/files.i");
f (c_parse_file "t/help.i");
f (c_parse_file "t/mainw.i");
f (c_parse_file "t/menus.i");
f (c_parse_file "t/msg.i");
f (c_parse_file "t/options.i");
f (c_parse_file "t/palette.i");
f (c_parse_file "t/pixmaps.i");
f (c_parse_file "t/pterm.i");
f (c_parse_file "t/search.i");
f (c_parse_file "t/templates.i");
f (c_parse_file "t/undo.i");
f (c_parse_file "t/xmisc.i");
f (c_parse_file "t/xpp.i");

print_tree (curry output std_out) (c_parse_file "t/foo.i");

e_flatten(hd(!type_env));

(* Poly/ML specific version for debugging *)
val old_c_classifier = c_classifier;
local
fun debug_classifier (lv : LEX_VALUE) : LEX_CLASS = (
	let	val lc = c_classifier lv;
	in	output(std_out, PolyML.makestring lv);
		output(std_out, ": ");
		output(std_out, PolyML.makestring lc);
		output(std_out, "\n");
		lc
	end
);
in
val c_classifier = debug_classifier;
end;
fun c_parse_file name = (
	reset_state();
	slrp'gen_parser c_resolver c_classifier
	(default_error string_of_lex_value)
	(gen_reader rec_any (in_char_stream_of_file name))
	([], true)
);
