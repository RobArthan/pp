=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Release 1 ICL HOL: Detailed Design for Standard ML Utilities}  %% Mandatory field
\def\TPPheadtitle{Release 1 ICL HOL \cr Detailed Design for Standard ML Utilities}
\TPPref{DS/FMU/IED/DTD001}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{Utility functions for use in the prototype HOL
system are given a detailed design in this document.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue 1.1]
First draft version.
Based on \cite{DS/FMU/IED/SML001}.
Name changes from that are currently recorded in 
\[\verb"~"kb/ied/NameChanges\]
\item [Issue 1.2]
Improved presentation of error messages.
Typos tidied up.
\item [Issue 1.3]
Changed format, addressed comments made upon issue 1.2.
\item [Issue 1.4]
Added test material. Noted dependence upon the Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
\item [Issue 1.5]
Reformated Error messages.
\item [Issue 1.6]
Modified $is\_all\_graphical$ to be true for codes 33-126 and 128+.
Replaced two instances of "‹" by "->".
\item [Issue 1.7]
$give\_stats$ renamed as $get\_stats$.
\item [Issue 1.8]
Renamed section ``TEST SPECIFICATIONS'' to ``TEST POLICY''.
Changed error message 1009.
Added ``Release 1 ICL HOL:'' to document's title.
$union$ noted not to gain duplicates if they were present in its second list argument.
Removed $dump\_string$.
\end{description}
%\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design of the functional tool-kit, called for by section 4.1.2 of the Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The design is
implemented in \cite{DS/FMU/IED/IMP001}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document gives a detailed design, in the form of signatures and informal descriptions,  of a number of general purpose
Standard ML objects
which are of use in coding the prototype HOL system.
Many of these are general functions which
support some common functional programming idioms.
\subsubsection{Dependencies}
The definitions in this document are self-contained
and depend only on the Standard ML facilities defined
in \cite{Harper86}.
\subsubsection{Deficiencies}
The treatment of I/O currently supports only output
of messages to the terminal (i.e. UNIX standard output)
and a crude facility for dumping string data to a file.
These facilities may well need revision.
\subsubsection{Possible Enhancements}
Versions of the general functions defined here
may well be supplied with particular
Standard ML compilers. It may improve performance if
the supplied versions are used.

The proposed pretty character set would be useful in giving clearer examples,
error messages etc.
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the `top level'.
Thus we give the commands here for those functions declared in the following signatures.
=SML
infix 4 drop;
infix 4 less;
infix 4 grab;
infix 4 cup;
infix 3 mem;
infix 3 subset;
infix 2 diff;
infix 4 overwrite;
infix 4 list_overwrite;
infix 4 roverwrite;
infix 4 list_roverwrite;
infix 5 from;
infix 5 to;
infix 4 **;
=TEX
\section{SHARED TYPES IN THIS DOCUMENT}
=DOC
signature âUtilitySharedTypesá = sig
=DESCRIBE
Any new types in the Utility structures mentioned in more than one signature
will be declared in this signature.
=ENDDOC
The associated structure is also declared in this document.
=DOC
datatype 'a âOPTá = âNilá | âValueá of 'a;
=DESCRIBE
A type of ``optional'' values.
=USES
The datatype $'a\;OPT$ is useful for implementing
partial functions for which raising an exception
is not an appropriate action for undefined cases.
=SEEALSO
Signature $ListUtilities$.
=ENDDOC
=DOC
type 'a âS_DICTá;
=DESCRIBE
The type of simple dictionaries: $(string\ *\ 'a)\ list$.
=SEEALSO
Signature $SimpleDictionary$.
=ENDDOC
=SML
end (* UtilitySharedTypes signature *);
=TEX
We now declare the shared type structure:
=SML
structure âUtilitySharedTypesá : UtilitySharedTypes = struct
	datatype 'a âOPTá = âNilá | âValueá of 'a;
	type 'a âS_DICTá = (string * 'a) list;
end;
open UtilitySharedTypes;
=TEX
\section{LIST UTILITIES}
=DOC
signature âListUtilitiesá = sig
=DESCRIBE
Holds a variety of utility Standard ML list functions.
=ENDDOC
\subsection{Some Useful Datatypes and Functions upon them}
=DOC
val âforce_valueá : 'a OPT -> 'a;
=DESCRIBE
Force an object of type  $'a\;OPT$ into one of type $'a$:
$force\_value\ (Value\ x)\ =\ x$
=FAILURE
1001	Argument may not be Nil
=ENDDOC
=DOC
val âis_Nilá : 'a OPT -> bool
=DESCRIBE
Is the argument equal to $Nil$.
=ENDDOC
=DOC
type (''a, 'b) âgrelá;
=DESCRIBE
A type used for representing binary relations between differing types:
\[(''a\ *\ ('b\ list))\ list\]
=USES
In combination with the associative look-up functions and
overwrite etc., which are defined in $ListUtilities$, are often convenient.
=ENDDOC
=DOC
type ''a ârelá;
=DESCRIBE
A type used for representing binary relations within one type:
\[(''a\ *\ (''a\ list))\ list\]
=USES
In combination with the associative look-up functions and
overwrite etc., which are defined in $ListUtilities$, are often convenient.
=ENDDOC
\subsection{List Processing Functions}
\subsubsection{A Miscellany}
$hd$ and $tl$ are the usual destructor functions for
lists.
=DOC
val âhdá : 'a list -> 'a;
=DESCRIBE
Returns first element of a list: $hd(a\ ::\ x)\ =\ a$.
=FAILURE
1002	An empty list has no head
=SEEALSO
tl
=ENDDOC
=DOC
val âtlá : 'a list -> 'a list;
=DESCRIBE
Returns all but the first element of a list: $tl(a\ ::\ x)\ =\ x$.
=FAILURE
1003	An empty list has no tail
=SEEALSO
hd
=ENDDOC
=DOC
val âfoldá : ('a * 'b -> 'b) -> 'a list -> 'b -> 'b;
=DESCRIBE
Fold a list into a single value:
óDefinition
fold f [x1, x2, ...., xk] b = f(x1, f(x2, ... f (xk, b))...)
æ
=SEEALSO
revfold
=ENDDOC
=DOC
val ârevfoldá : ('a * 'b -> 'b) -> 'a list -> 'b -> 'b;
=DESCRIBE
Fold a list into a single value:
óDefinition
revfold f [x1, x2, ...., xk] b = f(xk, ..., f(x2, f (x1, b))...)
æ
=SEEALSO
fold
=ENDDOC
=DOC
val âlengthá : 'a list -> int;
=DESCRIBE
$length$ returns the length of a list.
=ENDDOC
\subsection{Lists as Sets}
$drop$,  $less$ and $grab$ are infix operators with priority 4 (lower than
`::' and higher than `=').
$drop$ and $less$ are essentially the set difference operation.
$grab$ is union with a singleton set.

=DOC
val âdropá : 'a list * ('a -> bool) -> 'a list;
=DESCRIBE
$list\,drop\,cond$ is the list obtained by deleting all members
of $list$ for which the boolean function $cond$ is true.
=ENDDOC
=DOC
val âlessá : ''a list * ''a -> ''a list;
=DESCRIBE
$list\,less\,what$ is the list obtained by deleting all members
of $list$ which are equal to $what$.
=ENDDOC
=DOC
val âgrabá : ''a list * ''a -> ''a list;
=DESCRIBE
$list\, grab\,what$ is the list obtained by inserting $what$
at the end of $list$ if it is not a member of it already,
in which case $list$ is returned.

=ENDDOC
=DOC
val âunioná : ('a * 'a -> bool) -> 'a list -> 'a list -> 'a list;
=SYNOPSIS
A prefix binary union operation for lists, with parameterised equality test.
=DESCRIBE
$union$ is essentially a binary union operation for lists.
Since we need it for types such as $TERM$, which are
not equality types, it has a parameter giving the relation to be
used to determine equality of members of the lists.
In some cases it may be important for the order of members of the union
to be known. The rule is that $union\,eq\,list1\,list2$ is
the list obtained by  successively appending elements of $list2$ to the end of $list1$ if they are not present so far, presence for $y$ of $list2$ being
that there is a
member, $x$, of list being created with $eq(x,\,y)\,=\,true$.
Note also that if one of the lists is small it should
be supplied as the second list argument if speed is of
the essence.

=SEEALSO
$cup$, $list\_union$, $list\_cup$
=ENDDOC
=DOC
val âcupá : ''a list * ''a list -> ''a list;
=DESCRIBE
An infix binary union operation for lists, with Standard ML equality test.
Duplicates in the second list will not be duplicated in the result.
=SEEALSO
$union$, $list\_cup$, $list\_union$
=ENDDOC
=DOC
val âlist_unioná : ('a * 'a -> bool) -> 'a list list -> 'a list;
=DESCRIBE
A distributed union operation for lists, with parameterised equality test:
óDefinition
list_union eq [list0, list1, ...] = union eq (list0 union eq (list1 ...)).
æ
=SEEALSO
$union$, $list\_cup$.
=ENDDOC
=DOC
val âlist_cupá : ''a list list -> ''a list;
=DESCRIBE
A distributed union operation for lists, with Standard ML equality test.
=SEEALSO
$cup$, $list\_union$
=ENDDOC
=DOC
val âfindá : 'a list -> ('a -> bool) -> 'a;
=DESCRIBE
$find$ $list$ $cond$ searches for the first member of $list$ satisfying $cond$, and
returns such a member if there is one.
=FAILURE
1004	Element cannot be found in list
=ENDDOC
=DOC
val âcontainsá : ''a list -> ''a -> bool;
=DESCRIBE
$contains$ $list$ $x$ searches for a member of
$list$ equal to $x$ and returns true iff. it finds one.
=SEEALSO
$mem$
=ENDDOC
=DOC
val âmemá : ''a * ''a list -> bool;
=DESCRIBE
$x$ $mem$ $list$ searches for a member of
$list$ equal to $x$ and returns true iff. it finds one.
=SEEALSO
$contains$
=ENDDOC
=DOC
val âanyá : 'a list -> ('a -> bool) -> bool;
=DESCRIBE
$any$ $list$ $cond$ is true iff. some element of $list$ satisfies $cond$.
=ENDDOC
=DOC
val âallá : 'a list -> ('a -> bool) -> bool;
=DESCRIBE
$all$ $list$ $cond$ is true iff. all elements of $list$ satisfy $cond$.
=ENDDOC
=DOC
val âsubsetá : ''a list * ''a list -> bool;
=DESCRIBE
$l1\,subset\,l2$ is true iff. all the elements of $l1$
are  also elements of $l2$
=ENDDOC
=DOC
val âdiffá : ''a list * ''a list -> ''a list;
=DESCRIBE
$diff$ is the set difference operator for lists.
=ENDDOC
\subsection{Lists of Pairs as Functions and Relations}
We will frequently implement functions or relations as
lists of pairs. The following associative lookup functions are
used to implement application of such functions or relations.
We will need a number of variations on the same theme.
Each variation has left- and right-handed versions.

=DOC
val âlassoc1á : (''a * ''a) list -> ''a -> ''a;
=DESCRIBE
$lassoc1$ $alist$ $arg$ is $x$, where $(arg,\ x)$ is the first element of $alist$ with $arg$ as its left item.
The function
is made total by taking $arg$ as the result if there is no
appropriate member of the list.
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC
=DOC
val ârassoc1á : (''a * ''a) list -> ''a -> ''a;
=DESCRIBE
$rassoc1$ $alist$ $arg$ is $x$, where $(x,\ arg)$ is the first element of $alist$ with $arg$ as its right item.
The function
is made total by taking $arg$ as the result if there is no
appropriate member of the list.
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC
=DOC
val âlassoc2á : (''a * 'b) list -> (''a -> 'b) -> ''a -> 'b;
=DESCRIBE
$lassoc2$ $alist$ $f$ $arg$ is $x$, where $(arg,\ x)$ is the first element of $alist$ with $arg$ as its left item.
The function
is made total by returning $f\ arg$ if there is no
appropriate member of the list.
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC
=DOC
val ârassoc2á : ('a * ''b) list -> (''b -> 'a) -> ''b -> 'a;
=DESCRIBE
$rassoc2$ $alist$ $f$ $arg$ is $x$, where $(x,\ arg)$ is the first element of $alist$ with $arg$ as its left item.
The function
is made total by returning $f\ arg$ if there is no
appropriate member of the list.
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC
=DOC
val âlassoc3á : (''a * 'b) list -> ''a -> 'b;
=DESCRIBE
$lassoc3$ $alist$ $arg$ is $x$, where $(arg,\ x)$ is the first element of $alist$ with $arg$ as its left item.
=FAILURE
1005	No such value in association list
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC
=DOC
val ârassoc3á : ('a * ''b) list -> ''b -> 'a;
=DESCRIBE
$rassoc3$ $alist$ $arg$ is $x$, where $(x,\ arg)$ is the first element of $alist$ with $arg$ as its right item.
=FAILURE
1005	No such value in association list
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC
=DOC
val âlassoc4á : (''a * 'b) list -> 'b -> ''a -> 'b;
=DESCRIBE
$lassoc4$ $alist$ $default$ $arg$ is $x$, where $(arg,\ x)$ is the first element of $alist$ with $arg$ as its left item.
The function
is made total by returning $default$ if there is no
appropriate member of the list.
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC
=DOC
val ârassoc4á : ('a * ''b) list -> 'a -> ''b -> 'a;
=DESCRIBE
$rassoc4$ $alist$ $default$ $arg$ is $x$, where $(x,\ arg)$ is the first element of $alist$ with $arg$ as its right item.
The function
is made total by returning $default$ if there is no
appropriate member of the list.
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC
=DOC
val âlassoc5á : (''a * 'b) list -> ''a -> 'b OPT;
=DESCRIBE
$lassoc5$ $alist$ $arg$ is $Value\ x$, where $(arg,\ x)$ is the first element of $alist$ with $arg$ as its left item.
The function
is made total by returning $Nil$ if there is no
appropriate member of the list.
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC
=DOC
val ârassoc5á : ('a * ''b) list -> ''b -> 'a OPT;
=DESCRIBE
$rassoc5$ $alist$ $arg$ is $Value\ x$, where $(x,\ arg)$ is the first element of $alist$ with $arg$ as its right item.
The function
is made total by returning $Nil$ if there is no
appropriate member of the list.
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC
=DOC
val âoverwriteá : (''a * 'b) list * (''a * 'b) -> (''a * 'b) list;
=DESCRIBE
$alist$ $overwrite$ $(a,b)$ gives the list that replaces the first pair in $alist$ that has the left item $a$ with the pair $(a, b)$.
If no such pair is found in $alist$ then $(a,b)$ is appended to the end of $alist$.
=SEEALSO
$roverwrite$, $list\_overwrite$
=ENDDOC
=DOC
val âlist_overwriteá : (''a * 'b) list * (''a * 'b) list -> (''a * 'b) list;
=DESCRIBE
$alist$ $list\_overwrite$ $olist$ overwrites $alist$ with each element of $olist$, using $overwrite$.
=SEEALSO
$overwrite$, $list\_roverwrite$.
=ENDDOC
=DOC
val âroverwriteá : ('a * ''b) list * ('a * ''b) -> ('a * ''b) list;
=DESCRIBE
$alist$ $roverwrite$ $(a,b)$ gives the list that replaces the first pair in $alist$ that has the right item $b$ with the pair $(a, b)$.
If no such pair is found in $alist$ then $(a,b)$ is appended to the end of $alist$.
=ENDDOC
=DOC
val âlist_roverwriteá : ('a * ''b) list * ('a * ''b) list -> ('a * ''b) list;
=DESCRIBE
$alist$ $list\_roverwrite$ $olist$ overwrites $alist$ with each element of $olist$, using $roverwrite$.
=SEEALSO
$roverwrite$, $list\_overwrite$.
=ENDDOC
\subsection{Another Miscellany}

=DOC
val âis_nilá : 'a list -> bool;
=DESCRIBE
$is\_nil$ tests whether a list is empty([]). It can be
used for lists of types which do not admit equality.
=ENDDOC
An alternative is to call this $is\_empty$.
=DOC
val âflatá : 'a list list -> 'a list;
=DESCRIBE
$flat$ takes a list of lists and returns the result of
concatenating them all.
=ENDDOC
=DOC
val âsplitá : ('a * 'b) list -> 'a list * 'b list;
=DESCRIBE
Split a list of pairs into a pair of lists.
óDefinition
split [(x0, y0), (x1, y1), ... (xk, yk)] = [x0, x1, ... , xk],  [y0, y1, ... , yk]
æ
=SEEALSO
$split3$, $combine$
=ENDDOC
=DOC
val âsplit3á : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list;
=DESCRIBE
Split a list of triples into a triple of lists.
$split3$ is the analogue of $split$ for lists of triples.
=SEEALSO
$split$
=ENDDOC
=DOC
val âcombineá : 'a list -> 'b list -> ('a * 'b) list;
=DESCRIBE
$combine$ combines a pair of lists into a list of pairs. It is the left inverse of $split$.
=FAILURE
1007	Cannot combine unequal length lists
=SEEALSO
$split$
=ENDDOC
=DOC
val âall_differentá : ''a list -> bool;
=DESCRIBE
$all\_different$ determines whether a list has any
repeated entries.
=ENDDOC
=DOC
val âall_distinctá : ('a * 'a -> bool) -> 'a list -> bool;
=DESCRIBE
$all\_distinct$ determines whether a list has any
repeated entries using a given function to test for
equality.
=ENDDOC
=DOC
val âfromá : 'a list * int -> 'a list;
=DESCRIBE
The infix function $from$ takes
the trailing slice of a list.
It uses 0-based indexing.
=EXAMPLE
[0,1,2,3] from 2 = [2,3]
=SEEALSO
$to$
=ENDDOC
=DOC
val âtoá : 'a list * int -> 'a list;
=DESCRIBE
The infix function $to$ takes
the initial slice of a list.
It uses 0-based indexing.
=EXAMPLE
[0,1,2,3] to 2 = [0,1,2]
=SEEALSO
$from$
=ENDDOC
=DOC
val âintervalá : int -> int -> int list;
=DESCRIBE
$interval\;a\;b$ is the list $[a,a+1,a+2\ldots,b]$.
This is taken to be $[]$ if $a > b$ and to be $[a]$
if $a = b$.
=ENDDOC
=DOC
val âmapfilterá : ('a -> 'b) -> 'a list -> 'b list;
=DESCRIBE
Map a function over a list.
If, when evaluating 
\[mapfilter f (x_1 :: \ldots x_{k-1} :: x_k :: x_{k+1} :: \ldots )\]
the evaluation of $f\ x_k$ raises a $Fail$ exception, then 
the result will be
\[(f\ x_1 :: \ldots f\ x_{k-1} :: f\ x_{k+1} :: \ldots)\]
=ENDDOC
=DOC
val âzipá : ('a -> 'b)list -> 'a  list -> 'b list;
=DESCRIBE
Given a list of functions, and a list of arguments, of the same length, apply each function to its corresponding argument.
=FAILURE
1008	List lengths differ
=ENDDOC
=DOC
val ânthá : int -> 'a list -> 'a;
=DESCRIBE
Return the $n$-th element of a list. The head of the list is the $0$-th element.
=FAILURE
1009	Index past ends of list
=ENDDOC
=DOC
val âwhichá : (('a * 'a) -> bool) -> 'a -> 'a list -> int;
=DESCRIBE
$which$ $eq$ $x$ $list$ returns the position of first element, $y$, in $list$ for which $eq\ x\ y$ is true.
It uses 0-based indexing.
If no such $y$ found, return \verb"~1".
=ENDDOC
\subsection{End of ListUtilities}
=SML
end (* of ListUtilities signature *);
=TEX
\section{FUNCTION UTILITIES}
=DOC
signature âFunctionUtilitiesá = sig
=DESCRIBE
Holds a variety of utility Standard ML functions concerned with functions.
=ENDDOC
\subsection{Pairs}
=DOC
val âfstá : 'a * 'b -> 'a;
=DESCRIBE
$fst$ is the left projection function for pairs: $fst(a,b)\ =\ a$.
=SEEALSO
$snd$
=ENDDOC
=DOC
val âsndá : 'a * 'b -> 'b;
=DESCRIBE
$fst$ is the right projection function for pairs: $fst(a,b)\ =\ b$.
=SEEALSO
$fst$
=ENDDOC
=DOC
val âswapá  : 'a * 'b -> 'b * 'a;
=DESCRIBE
$swap$ interchanges the elements of a pair: $sway(a,b)\ =\ (b,a)$.
=ENDDOC
\subsection{Functionals}
Certain higher-order functions are very useful.

=DOC
val âcurryá  : ('a * 'b -> 'c) -> 'a -> 'b -> 'c;
=DESCRIBE
$curry$ $f$ $a$ $b$ gives $f\ (a,b)$.
=ENDDOC
=DOC
val âuncurryá : ('a -> 'b -> 'c) -> 'a * 'b -> 'c;
=DESCRIBE
$uncurry$ $f$ $(a,b)$ gives $uncurry$ $f$ $a$ $b$.
=ENDDOC
=DOC
val âswitchá  : ('a -> 'b -> 'c) -> 'b -> 'a -> 'c;
=DESCRIBE
$switch$ $f$ $a$ $b$ gives $f$ $b$ $a$.
=ENDDOC
=DOC
val â**á  : ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd;
=DESCRIBE
The infix operator ``**'', with precedence 4 (higher
than ``$o$''), gives the function induced by a pair
of functions from the product of their domains to
the product of their codomains. 
=ENDDOC
=DOC
val âfunpowá  : int -> ('a -> 'a) -> 'a -> 'a;
=DESCRIBE
For non-negative $n$, $funpow\ n\ f$ is $f^n$, i.e. the
function 
\[xŽf(f( ... f(f x) ....)\]
where $f$
appears $n$ times.
=FAILURE
1010	First argument must not be negative
=ENDDOC
=SML
end (* of FunctionUtilities signature *);
=TEX
\section{COMBINATORS}
It can be convenient to have the definitions of
certain combinators. We package these in a structure
(since their conventional names are single letters).
=DOC
signature âCombinatorsá = sig
=DESCRIBE
Holds the three combinators $S$, $K$, $I$.
=ENDDOC
=DOC
val âIá : 'a -> 'a
=DESCRIBE
The identity combinator: $I\ x\ =\ x$.
=ENDDOC
=DOC
val âSá : ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c
=DESCRIBE
The duplication combinator: $S\ f\ g\ a$ is $(f\ a)(g\ a)$.
=ENDDOC
=DOC
val âKá : 'a -> 'b -> 'a
=DESCRIBE
The deletion combinator: $K\ x\ y$ is $x$.
=ENDDOC
=SML
end (* of Combinators signature *);
=TEX
\section{INPUT AND OUTPUT}
=DOC
signature âInputOutputá = sig
=DESCRIBE
Holds a variety of utility Standard ML functions concerned with input and output.
=ENDDOC
The following two functions will be implemented using 
the functions of structure $SystemControl$.
=DOC
(* âline_lengthá - integer control declared by new_int_control *)
=DESCRIBE
An integer control dictating the output's length of line available for printing.
=SEEALSO
$set\_line\_length$, $get\_line\_length$
=ENDDOC
=DOC
val âset_line_lengthá : int -> int
=DESCRIBE
Set the output line length, returning the previous line length.
Default length is 80, minimum length 20.
=FAILUREC
If length less than 20 then will gain an error message from 
$set\_int\_control$: ``Value out of range for control variable line\_length''.
=ENDDOC
=DOC
val âget_line_lengthá : unit -> int
=DESCRIBE
Returns current output line length.

=ENDDOC
=DOC
val âdiag_stringá : string -> unit;
=DESCRIBE
$diag\_string$ outputs
a string on the standard output stream.
If the string exceeds the value of {\em get\_line\_length} it attempts to split the string into tokens, to fit within the line length.
A token is taken to be an initial string of spaces, followed by exclusively non-space characters.
=ENDDOC
=DOC
val âlist_diag_stringá : string list -> unit;
=DESCRIBE
$list\_diag\_string$ outputs a list of strings
onto the standard output stream. The strings in the list
are concatenated (with spaces to separate them) and then
output with $diag\_string$. 
=ENDDOC
=DOC
val âdiag_lineá : string -> unit;
=DESCRIBE
$diag\_line$ outputs a string to the standard output
stream followed by a new line.
It is intended for use in printing formatted terms,
theorems and the like (for which the pretty printer
will have included new lines within the string if
necessary ).
=ENDDOC
=DOC
val âformat_listá : ('a -> string) -> 'a list -> string -> string;
=DESCRIBE
$format\_list$ is used to format a list of items for printing
as a string, given a function to format a single item
and a string to separate elements of a multi-element
list.
=ENDDOC
=SML
end (* of InputOutput signature *);
=TEX
\section{CHARACTER UTILITIES}
=DOC
signature âCharacterUtilitiesá = sig
=DESCRIBE
Holds a variety of utility Standard ML functions concerned with character handling.
=ENDDOC
=DOC
val âis_all_graphicalá : string -> bool;
=DESCRIBE
$is\_all\_graphical$ checks whether a string consists
of one or more graphical characters (ASCII code 33 to 126, 128+).
=ENDDOC
=DOC
val âis_all_decimalá : string -> bool;
=DESCRIBE
$is\_all\_decimal$ checks whether a string consists
of one or more decimal digits.
=ENDDOC
=DOC
val âstrip_spacesá : string -> string;
=DESCRIBE
$strip\_spaces$ removes space characters from
a string.
=ENDDOC
=DOC
val âgensymá : unit -> int;
=DESCRIBE
Successive applications of $gensym$ return
successive integers.
=ENDDOC
\subsection{Numeric Conversions}
=DOC
val ânat_of_stringá : string -> int;
=DESCRIBE
$nat\_of\_string$ converts a string into non-negative
integer (using decimal notation). 
=FAILURE
1012	?0 is not a decimal string
1013	String is empty
=ENDDOC
=DOC
val âstring_of_intá  : int -> string;
=DESCRIBE
$string\_of\_int$ converts an integer into a decimal
string.
=ENDDOC
This function is similar to $makestring$ of some implementations of Standard ML.
=SML
end (* of CharacterUtilities signature *);
=TEX
\section{DICTIONARIES}
To implement HOL theories and the theory hierarchy
we need to represent the type and constant environments
of the formal specification (\cite{DS/FMU/IED/SPC001}).
These environments are essentially partial functions from
$string$ to values of suitable type.

The operations required on these partial functions
are: application,
extension by a singleton function, deletion of elements
from the domain and overwriting both
by singleton functions and by arbitrary partial function.
This is similar to what is typically required for
the symbol table of a compiler.
We will call a data structure together with functions
to perform these operations a ``dictionary''.

We offer two generic implementations of dictionaries
here. The first implementation uses linear search
and performs slowly when the data structures become
large. The second implementation uses a hash addressing technique
and gives considerably more efficient access than the simple
implementation to larger data structures.

\subsection{Simple Dictionaries}
The implementation will use linear search
and performs slowly when the data structures become
large.
 
Its functions very straightforward. We use the prefix $s\_$ to
distinguish the types and functions involved from those
used for the more efficient technique.

After defining a simple dictionary to be a list of
pairs, the functions for accessing and modifying
dictionaries are essentially just interfaces to the
partial function operations defined in
signature $ListUtilities$.

The type of simple dictionaries is declared in signature $UtilitySharedTypes$.
=DOC
signature âSimpleDictionaryá = sig
=DESCRIBE
Holds a set of Standard ML functions concerned with a linear search
dictionary.
=USES
For handling small dictionaries.
=SEEALSO
$EfficientDictionary$.
=ENDDOC
=DOC
val âs_lookupá : string -> 'a S_DICT -> 'a OPT;
=DESCRIBE
$s\_lookup$ implements application (of the dictionary
viewed as a partial function).
$s\_lookup$ $name$ $dict$ returns the value that $dict$ associates with $name$.
=ENDDOC
=DOC
val âs_enterá : string -> 'a -> 'a S_DICT -> 'a S_DICT;
=DESCRIBE
$s\_enter$ implements overwriting by a singleton function.
$s\_enter$ $name$ $value$ $dict$ returns the dictionary
that associates $name$ with $value$, and otherwise associates as $dict$.
=ENDDOC
=DOC
val âs_extendá : string -> 'a -> 'a S_DICT -> 'a S_DICT;
=DESCRIBE
$s\_extend$ implements extension by a singleton function,
that is to say it is like $s\_enter$.
$s\_extend$ $name$ $value$ $dict$ returns the dictionary
that associates $name$ with $value$, and otherwise associates as $dict$.
It fails if $name$ is already in the domain of $dict$.
=FAILURE
1014	?0 is already in dictionary
=ENDDOC
=DOC
val âs_deleteá : string -> 'a S_DICT -> 'a S_DICT;
=DESCRIBE
$s\_delete$ deletes an element of the domain of a dictionary.
If the element is not in the domain it returns the
dictionary unchanged.
$s\_delete$ $name$ $dict$ returns a dictionary that does not associate anything with $name$, but otherwise associates as $dict$.
=ENDDOC
=DOC
val âs_mergeá : 'a S_DICT -> 'a S_DICT -> 'a S_DICT;
=DESCRIBE
$s\_merge$ extends one dictionary by another.
The dictionary $s\_merge$ $dict1$ $dict2$ will associate 
a name with the value that either $dict1$ or $dict2$ associates it with.
=FAILUREC
\paragraph{Failure}
Will get the $s\_extend$ failure message if any element is common to the domains of both dictionaries ($dict1$ and $dict2$).
=ENDDOC
=SML
end (* of SimpleDictionary signature *);
=TEX
\subsection{Efficient Dictionaries}
The technique we use for the more efficient dictionaries
is essentially the standard compiler writer's technique
of hash addressing with chaining to handle collisions
(see, for example, \cite{Bornat79}).

We discuss the detailed algorithm in \cite{DS/FMU/IED/IMP001}.
The signature is essentially that of simple dictionaries, 
only the desire to open these structures at the same time,
and a few additional functions,
means that the signatures are not unified.

Its functions are similar to those of $SimpleDictionary$.
=DOC
signature âEfficientDictionaryá = sig
=DESCRIBE
A dictionary based on hash-search techniques.
=USES
For handling large dictionaries.
=SEEALSO
$SimpleDictionary$.
=ENDDOC
=DOC
type 'a âE_DICTá;
=DESCRIBE
The type of efficient dictionaries.
=ENDDOC
=DOC
val âe_lookupá : string -> 'a E_DICT -> 'a OPT
=DESCRIBE
$e\_lookup$ implements application (of the dictionary
viewed as a partial function).
$e\_lookup$ $name$ $dict$ returns the value that $dict$ associates with $name$.
=ENDDOC
=DOC
val âe_enterá : string -> 'a -> 'a E_DICT -> 'a E_DICT;
=DESCRIBE
$e\_enter$ implements overwriting by a singleton function.
$e\_enter$ $name$ $value$ $dict$ returns the dictionary
that associates $name$ with $value$, and otherwise associates as $dict$.
=ENDDOC
=DOC
val âe_extendá : string -> 'a -> 'a E_DICT -> 'a E_DICT;
=DESCRIBE
$e\_extend$ implements extension by a singleton function,
that is to say it is like $e\_enter$.
$e\_extend$ $name$ $value$ $dict$ returns the dictionary
that associates $name$ with $value$, and otherwise associates as $dict$.
It fails if $name$ is already in the domain of $dict$.
=FAILURE
1014	?0 is already in dictionary
=ENDDOC
=DOC
val âe_deleteá : string -> 'a E_DICT -> 'a E_DICT;
=DESCRIBE
$e\_delete$ deletes an element of the domain of a dictionary.
If the element is not in the domain it returns the
dictionary unchanged.
$e\_delete$ $name$ $dict$ returns a dictionary that does not associate anything with $name$, but otherwise associates as $dict$.
=ENDDOC
=DOC
val âe_flattená : 'a E_DICT -> 'a S_DICT;
=DESCRIBE
$e\_flatten$ converts an efficient dictionary into a simple one.
=ENDDOC
=DOC
val âlist_e_mergeá : 'a E_DICT -> 'a S_DICT -> 'a E_DICT;
=DESCRIBE
$list\_e\_merge$ extends an efficient dictionary by a simple
one.
That is, for each association within the simple dictionary
an $e\_extend$ is executed on the efficient dictionary.
=FAILUREC
\paragraph{Failure}
Will get the $e\_extend$ failure message if an element is common to the domains of both dictionaries.
=ENDDOC
=DOC
val âe_mergeá : 'a E_DICT -> 'a E_DICT -> 'a E_DICT;
=DESCRIBE
$e\_merge$ extends one efficient dictionary by another.
The dictionary $e\_merge$ $dict1$ $dict2$ will associate 
a name with the value that either $dict1$ or $dict2$ associates it with.
=FAILUREC
\paragraph{Failure}
Will get the $e\_extend$ failure message if an element is common to the domains of both dictionaries.
=ENDDOC
=DOC
val âinitial_E_DICTá : 'a E_DICT;
=DESCRIBE
The empty dictionary, which
gives a starting point for the use of the efficient dictionary functions.
It does not associate a value with any name.
=ENDDOC
=SML
end (* of EfficientDictionary signature *);
=TEX
\section{CODE PROFILING}
=DOC
signature âProfilingá = sig
=DESCRIBE
The signature contains definitions may be used to record
statistics, e.g., on the number of times certain
functions have been called.
=ENDDOC
=DOC
(* âprofilingá - boolean flag declared by new_flag *)
=DESCRIBE
Turns profiling on (if true) or off (if false).
Default is on.
This should be maintained via the functions of structure $SystemControl$.
=ENDDOC
=DOC
val âprofá : string -> unit;
=DESCRIBE
Indicates that a call to the named function has been made.
=USES
A single call to this function should be made in any function to be profiled.
=ENDDOC
=DOC
val âcountsá : string -> int OPT;
=DESCRIBE
Returns the number of calls to $prof$ with the given string.
=ENDDOC
=DOC
val âprint_statsá : unit -> unit;
=DESCRIBE
Prints all profiling data currently held.
=ENDDOC
=DOC
val âget_statsá : unit -> int S_DICT;
=DESCRIBE
Returns the current profiling data as a simple dictionary.
=ENDDOC
=SML
end(* of Profiling signature *);
=TEX
\section{SORTING}
=DOC
signature âSortá = sig
=DESCRIBE
This provides an efficient sort utility package.
=ENDDOC
=DOC
val âsortá : ('a -> 'a -> int) -> 'a list -> 'a list
=SYNOPSIS
A parameterised sort of a list.
=DESCRIBE
The sorting of items of type $'a$ is parametrised by an
ordering function of type $'a -> 'a -> int$.
The integer, say $n$ returned by an application
of this function, say $f\ a_1\ a_2$, is interpreted as
follows: 
\begin{description}
\item[$n < 0$] $a_2$ is to come after $a_1$ (i.e. the arguments are in order)
\item[$n > 0$] $a_2$ is to come before $a_1$ (i.e. the arguments are out of order)
\item[$n = 0$] $a_2$ is to be taken as equal to $a_1$
\end{description}
Note that the sorting function returns a list with
no duplicate entries with respect to the equality
relation determined by the ordering function.
=EXAMPLE
To sort a list of integers, ilist in ascending order:

	sort (curry (op -)) ilist
=ENDDOC
=DOC
val âstringorderá : string -> string -> int
=DESCRIBE
This function gives a more civilised ordering on
strings than the one given by the ASCII codes.
The sequence is: {\it A, a, B, b, \ldots z, Z} followed
by all the other characters in their ASCII order.
For multi-character strings the ordering is lexicographic
=SEEALSO
$lexicographic$
=ENDDOC
=DOC
val âlexicographicá : ('a -> 'a -> int) -> 'a list -> 'a list -> int
=SYNOPSIS
This function returns the lexicographic ordering
function induced from an ordering
of items of type $'a$ on items of type $'a\,list$.
=DESCRIBE
Lexicographic ordering may be defined as follows:

Let us presume some ordering $<$ on the type of variables $a_i$ and $b_i$.
Then
\[ [a_1, \ldots, a_n]\ <_{lexicographic}\ [b_1, \ldots, b_m] \]
If, and only if, either
\[ n\ <_{int}\ m\ € \ ƒ i : 1 .. n\ Ž\ a_i\ =\ b_i\]
Or
\[„ j : 1 .. n\ Ž\ (ƒ i : 1 .. (j-1)\ Ž\ a_i\ =\ b_i)\ €\ (a_j\ <\ b_j)\]
=ENDDOC
=SML
end (* end of Sort signature *);
=TEX
\section{TEST POLICY}
In  \cite{DS/FMU/IED/PLN008} there is a statement of the general principle of testing to be adopted.
This section gives some individual comments on special testing requirements for individual functions.

Any function parameterised by an equality argument should be tested with an asymmetric ``equality'', to check the argument order.

The design of the function $union$ describes a particular ordering of its result.
The conformance to this order should be checked.

The functions $lassoc{\cal N}$, $rassoc{\cal N}$ and all others that act on ``\ldots the first element of the list that \ldots'' should be checked with lists containing duplicates, to ensure that the first matching element is selected.

The designs of functions $stringorder$ and $lexicographic$
describe orderings that their implementations should be tested against.

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
