=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for Standard ML Utilities}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for Standard ML Utilities}
\TPPref{DS/FMU/IED/DTD001}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{Utility functions for use in the prototype HOL
system are given a detailed design in this document.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1]
First draft version.
Based on \cite{DS/FMU/IED/SML001}.
Name changes from that are currently recorded in 
\[\verb"~"kb/ied/NameChanges\]
\item [Issue 1.2]
Improved presentation of error messages.
Typos tidied up.
\item [Issue 1.3]
Changed format, addressed comments made upon issue 1.2.
\item [Issue 1.4]
Added test material. Noted dependence upon the Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
\item [Issue 1.5]
Reformated Error messages.
\item [Issue 1.6]
Modified $is\_all\_graphical$ to be true for codes 33-126 and 128+.
Replaced two instances of $‹$ by $->$.
\item [Issue 1.7]
$give\_stats$ renamed as $get\_stats$.
\item [Issue 1.8]
Renamed section ``TEST SPECIFICATIONS'' to ``TEST POLICY''.
Changed error message 1009.
Added ``Release 1 ICL HOL:'' to document's title.
$union$ noted not to gain duplicates if they were present in its second list argument.
Removed $dump\_string$.
\item [Issue 1.9]
Improved comments upon $all\_distinct$.
\item [Issue 1.10]
Modified the statements of ordering for $grab$, $union$, and $s\_extend$.
Removed $rel$ and $grel$.
Added $initial\_s\_dict$, and renamed $initial\_E\_DICT$ to $initial\_e\_dict$.
Added $present$.
\item [Issue 1.11]
Added $set\_eq$.
\item [Issue 1.12]
Added $init\_stats$.
\item [Issue 1.13, 1.14]
Changes in response to inspection IR0012.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design of the functional tool-kit, called for by section 4.1.2 of the Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004},
and by the high level design \cite{DS/FMU/IED/HLD006}.
The design is
implemented in \cite{DS/FMU/IED/IMP001}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document gives a detailed design, in the form of signatures and informal descriptions,  of a number of general purpose
Standard ML objects
which are of use in coding the prototype HOL system.
Many of these are general functions which
support some common functional programming idioms.
\subsubsection{Dependencies}
The definitions in this document are self-contained
and depend only on the Standard ML facilities defined
in \cite{Harper86}.
\subsubsection{Deficiencies}
The treatment of output supports only output
of messages to the terminal (i.e. UNIX standard output),
and this document contains no input functions.
These facilities may need revision.
\subsubsection{Possible Enhancements}
Versions of the general functions defined here
may well be supplied with particular
Standard ML compilers. It may improve performance if
the supplied versions are used.
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the `top level'.
Thus we give the commands here for those functions declared in the following signatures.
=SML
infix 4 drop;
infix 4 less;
infix 4 grab;
infix 4 cup;
infix 3 mem;
infix 3 subset;
infix 3 set_eq;
infix 4 diff;
infix 4 overwrite;
infix 4 list_overwrite;
infix 4 roverwrite;
infix 4 list_roverwrite;
infix 5 from;
infix 5 to;
infix 4 **;
infix 4 fun_and;
infix 4 fun_or;
=TEX
The binding precedences are chosen reflect ``most likely use''.
A higher precedence indicates tighter binding.
Thus we choose higher precedences for functions that construct
objects (e.g. $cup$) rather than test for properties (e.g. $mem$)
so that we test ``the largest constructed objects'' rather than
their constituents.

For comparison Standard ML sets the following precedences:

\begin{tabular}{| c | l |}\hline
Precedence & Functions \\ \hline
7 & $/$, $div$, $mod$, $*$ \\
6 & $+$, $-$, \verb"^" \\
5 & $::$, $@$ \\
4 & $=$, $<>$, $<$, $>$, $<=$, $>=$ \\
3 & $:=$, $o$ \\ \hline
\end{tabular}

Prefix function application has higher precedence than all infix functions.
Language keywords (e.g. $andalso$, $orelse$) have a lower precedence than any infix function.

\section{SHARED TYPES IN THIS DOCUMENT}
=DOC
signature âUtilitySharedTypesá = sig
=DESCRIBE
Any new types in the Utility structures mentioned in more than one signature
will be declared in this signature.
=ENDDOC
The associated structure is also declared in this document,
as the types involved are required to declare the signatures
that follow this one.
=DOC
datatype 'a âOPTá = âNilá | âValueá of 'a;
=DESCRIBE
A type of ``optional'' values.
=USES
A typical use for the datatype $'a\;OPT$ is  in implementing
partial functions for which raising an exception
is not an appropriate action for undefined cases.
=SEEALSO
$force\_value$, $is\_Nil$
=ENDDOC
=DOC
type 'a âS_DICTá;
=DESCRIBE
The type of simple dictionaries: $(string\ *\ 'a)\ list$.
=SEEALSO
Signature $SimpleDictionary$.
=ENDDOC
=SML
end (* UtilitySharedTypes signature *);
=TEX
We now declare the shared type structure:
=SML
structure âUtilitySharedTypesá : UtilitySharedTypes = struct
	datatype 'a âOPTá = âNilá | âValueá of 'a;
	type 'a âS_DICTá = (string * 'a) list;
end;
open UtilitySharedTypes;
=TEX
\section{LIST UTILITIES}
=DOC
signature âListUtilitiesá = sig
=DESCRIBE
Holds a variety of utility Standard ML list functions.
=ENDDOC
\subsection{Functions For Type $'a\ OPT$}
=DOC
val âforce_valueá : 'a OPT -> 'a;
=DESCRIBE
Force an object of type  $'a\;OPT$ (q.v) into one of type $'a$:
óDefinition
force_value (Value x) = x
æ
=FAILURE
1001	Argument may not be Nil
=ENDDOC
=DOC
val âis_Nilá : 'a OPT -> bool
=DESCRIBE
Is the argument equal to $Nil$  (q.v).
óDefinition
is_Nil Nil = true 
| is_Nil _ = false
æ
=ENDDOC
We choose the unconventional capitalisation of $is\_Nil$ to
avoid clashing with the name $is\_nil$ (q.v.).
\subsection{A Miscellany}
$hd$ and $tl$ are the usual destructor functions for
lists.
=DOC
val âhdá : 'a list -> 'a;
val âtlá : 'a list -> 'a list;
=DESCRIBE
$hd$ returns first element of a list,
$tl$ returns all but the first element of a list.
óDefinition
hd (a :: x) = a
tl (a :: x) = x
æ
=FAILURE
1002	An empty list has no head
1003	An empty list has no tail
=ENDDOC
=DOC
val âfoldá : ('a * 'b -> 'b) -> 'a list -> 'b -> 'b;
=DESCRIBE
Fold a list into a single value:
óDefinition
fold f [x1, x2, ...., xk] b = f(x1, f(x2, ... f (xk, b))...)
æ
=SEEALSO
revfold
=ENDDOC
=DOC
val ârevfoldá : ('a * 'b -> 'b) -> 'a list -> 'b -> 'b;
=DESCRIBE
Fold a list into a single value:
óDefinition
revfold f [x1, x2, ...., xk] b = f(xk, ..., f(x2, f (x1, b))...)
æ
=SEEALSO
fold
=ENDDOC
=DOC
val âlengthá : 'a list -> int;
=DESCRIBE
$length$ returns the length of a list.
Note that the Standard ML function $size$ can be used to find the length of strings.
=ENDDOC
\subsection{Lists as Sets}
$drop$,  $less$ and $grab$ are infix operators with priority 4 (lower than
`::' and higher than `=').
$drop$ and $less$ are essentially the set difference operation.
$grab$ is union with a singleton set.

=DOC
val âdropá : 'a list * ('a -> bool) -> 'a list;
=DESCRIBE
$list\,drop\,cond$ is the list obtained by deleting all members
of $list$ for which the boolean function $cond$ is true.
=SEEALSO
$less$
=ENDDOC
=DOC
val âlessá : ''a list * ''a -> ''a list;
=DESCRIBE
$list\,less\,what$ is the list obtained by deleting all members
of $list$ which are equal to $what$.
=SEEALSO
$drop$
=ENDDOC
=DOC
val âgrabá : ''a list * ''a -> ''a list;
=DESCRIBE
$list\, grab\,what$ is the list obtained by inserting $what$
at the head of $list$ if it is not a member of it already,
in which case $list$ is returned.

=ENDDOC
=DOC
val âunioná : ('a * 'a -> bool) -> 'a list -> 'a list -> 'a list;
=SYNOPSIS
A prefix binary union operation for lists, with parameterised equality test.
=DESCRIBE
$union$ is essentially a binary union operation for lists.
Since we need it to work on types which are
not equality types, it has a parameter giving the relation to be
used to determine equality of members of the lists.
In some cases it may be important for the order of members of the union
to be known. The rule is that $union\,eq\,list1\,list2$ is
the list obtained by prepending those elements of $list1$ not already present in $list2$, to the list $list2$.
Presence for $x$ in the list being created being
that there is a
member, $y$, of the list being created with $eq(x,\,y)\,=\,true$.
If $list1$ contains duplicates then all but the rightmost will be eliminated,
but those in $list2$ will not be.
Note also that if one of the lists is small it is better
supplied as the first list argument if efficiency is of
the essence.
óDefinition
union eq (list1 @ [a]) list2 = union eq list1 (
	if present eq a list2
	then list2 
	else (a :: list2)
) | union eq [] list2 = list2
æ
=SEEALSO
$cup$, $list\_union$
=ENDDOC
=DOC
val âcupá : ''a list * ''a list -> ''a list;
=DESCRIBE
An infix binary union operation for lists, with Standard ML equality test.
It has the same result ordering as $union$(q.v.).
=SEEALSO
$list\_cup$, $union$
=ENDDOC
=DOC
val âlist_unioná : ('a * 'a -> bool) -> 'a list list -> 'a list;
=DESCRIBE
A distributed union operation for lists, with parameterised equality test:
óDefinition
list_union eq [list0, list1, ..., listn] = 
	union eq list0 (union eq list1 (...(union eq listn [])...))
æ
=SEEALSO
$union$, $list\_cup$.
=ENDDOC
=DOC
val âlist_cupá : ''a list list -> ''a list;
=DESCRIBE
A distributed union operation for lists, with Standard ML equality test.
óDefinition
list_cup [list0, list1, ..., listn] = 
	list0 cup (list1 cup ...(listn cup [])...))
æ
=SEEALSO
$cup$, $list\_union$
=ENDDOC
=DOC
val âfindá : 'a list -> ('a -> bool) -> 'a;
=DESCRIBE
$find$ $list$ $cond$ searches for the first member of $list$ satisfying $cond$, and
returns such a member if there is one.
=FAILURE
1004	Element cannot be found in list
=ENDDOC
=DOC
val âcontainsá : ''a list -> ''a -> bool;
=DESCRIBE
$contains$ $list$ $x$ searches for a member of
$list$ equal to $x$ and returns true iff. it finds one.
=SEEALSO
$present$, $mem$
=ENDDOC
=DOC
val âmemá : ''a * ''a list -> bool;
=DESCRIBE
$x$ $mem$ $list$ searches for a member of
$list$ equal to $x$ and returns true iff. it finds one.
=SEEALSO
$contains$, $present$
=ENDDOC
=DOC
val âpresentá : (('a * 'a) -> bool) -> 'a -> 'a list -> bool;
=DESCRIBE
$present$ $eq$ $x$ $list$ searches for a member, $y$, of
$list$ that satisfies $eq(x,y)$  and returns true iff. it finds one.
=SEEALSO
$contains$, $mem$
=ENDDOC
=DOC
val âanyá : 'a list -> ('a -> bool) -> bool;
=DESCRIBE
$any$ $list$ $cond$ is true iff. some element of $list$ satisfies $cond$.
=ENDDOC
=DOC
val âallá : 'a list -> ('a -> bool) -> bool;
=DESCRIBE
$all$ $list$ $cond$ is true iff. all elements of $list$ satisfy $cond$.
=ENDDOC
=DOC
val âsubsetá : ''a list * ''a list -> bool;
=DESCRIBE
$l1\,subset\,l2$ is true iff. all the elements of $l1$
are  also elements of $l2$
=SEEALSO
$set\_eq$
=ENDDOC
=DOC
val âset_eqá : ''a list * ''a list -> bool;
=DESCRIBE
$l1\,set\_eq\,l2$ is true iff. the members of $set\_eq$ of $l1$ are precisely the members of $l2$.
Though the two lists are viewed as sets, they may contain
duplicates, which will not affect the outcome of this test.
=SEEALSO
$subset$
=ENDDOC
=DOC
val âdiffá : ''a list * ''a list -> ''a list;
=DESCRIBE
$diff$ is the set difference operator for lists.
=ENDDOC
\subsection{Lists of Pairs as Functions and Relations}
We will frequently implement functions or relations as
lists of pairs. The following associative lookup functions are
used to implement application of such functions or relations.
We will need a number of variations on the same theme.
Each variation has left- and right-handed versions.

=DOC
val âlassoc1á : (''a * ''a) list -> ''a -> ''a;
=DESCRIBE
$lassoc1$ $alist$ $arg$ is $x$, where $(arg,\ x)$ is the first element of $alist$ with $arg$ as its left item.
The function
is made total by taking $arg$ as the result if there is no
appropriate member of the list.
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC
=DOC
val ârassoc1á : (''a * ''a) list -> ''a -> ''a;
=DESCRIBE
$rassoc1$ $alist$ $arg$ is $x$, where $(x,\ arg)$ is the first element of $alist$ with $arg$ as its right item.
The function
is made total by taking $arg$ as the result if there is no
appropriate member of the list.
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC

=DOC
val âlassoc2á : (''a * 'b) list -> (''a -> 'b) -> ''a -> 'b;
=DESCRIBE
$lassoc2$ $alist$ $f$ $arg$ is $x$, where $(arg,\ x)$ is the first element of $alist$ with $arg$ as its left item.
The function
is made total by returning $f\ arg$ if there is no
appropriate member of the list.
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC
=DOC
val ârassoc2á : ('a * ''b) list -> (''b -> 'a) -> ''b -> 'a;
=DESCRIBE
$rassoc2$ $alist$ $f$ $arg$ is $x$, where $(x,\ arg)$ is the first element of $alist$ with $arg$ as its left item.
The function
is made total by returning $f\ arg$ if there is no
appropriate member of the list.
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC

=DOC
val âlassoc3á : (''a * 'b) list -> ''a -> 'b;
=DESCRIBE
$lassoc3$ $alist$ $arg$ is $x$, where $(arg,\ x)$ is the first element of $alist$ with $arg$ as its left item.
=FAILURE
1005	No such value in association list
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC
=DOC
val ârassoc3á : ('a * ''b) list -> ''b -> 'a;
=DESCRIBE
$rassoc3$ $alist$ $arg$ is $x$, where $(x,\ arg)$ is the first element of $alist$ with $arg$ as its right item.
=FAILURE
1005	No such value in association list
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC

=DOC
val âlassoc4á : (''a * 'b) list -> 'b -> ''a -> 'b;
=DESCRIBE
$lassoc4$ $alist$ $default$ $arg$ is $x$, where $(arg,\ x)$ is the first element of $alist$ with $arg$ as its left item.
The function
is made total by returning $default$ if there is no
appropriate member of the list.
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC
=DOC
val ârassoc4á : ('a * ''b) list -> 'a -> ''b -> 'a;
=DESCRIBE
$rassoc4$ $alist$ $default$ $arg$ is $x$, where $(x,\ arg)$ is the first element of $alist$ with $arg$ as its right item.
The function
is made total by returning $default$ if there is no
appropriate member of the list.
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC

=DOC
val âlassoc5á : (''a * 'b) list -> ''a -> 'b OPT;
=DESCRIBE
$lassoc5$ $alist$ $arg$ is $Value\ x$, where $(arg,\ x)$ is the first element of $alist$ with $arg$ as its left item.
The function
is made total by returning $Nil$ if there is no
appropriate member of the list.
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC
=DOC
val ârassoc5á : ('a * ''b) list -> ''b -> 'a OPT;
=DESCRIBE
$rassoc5$ $alist$ $arg$ is $Value\ x$, where $(x,\ arg)$ is the first element of $alist$ with $arg$ as its right item.
The function
is made total by returning $Nil$ if there is no
appropriate member of the list.
=SEEALSO
lassoc$\cal N$ and rassoc$\cal N$, where ${\cal N} =\ 1 \ldots 5$.
=ENDDOC
=DOC
val âoverwriteá : (''a * 'b) list * (''a * 'b) -> (''a * 'b) list;
=DESCRIBE
$alist$ $overwrite$ $(a,b)$ gives the list in which the first pair in $alist$ that has the left item $a$ is replaced with the pair $(a, b)$.
If no such pair is found in $alist$ then it returns the list of $(a,b)$ appended to the tail of $alist$.
=SEEALSO
$roverwrite$, $list\_overwrite$
=ENDDOC
=DOC
val âlist_overwriteá : (''a * 'b) list * (''a * 'b) list -> (''a * 'b) list;
=DESCRIBE
$alist$ $list\_overwrite$ $olist$ overwrites $alist$ with each element of $olist$, using $overwrite$(q.v).
=SEEALSO
$overwrite$, $list\_roverwrite$.
=ENDDOC
=DOC
val âroverwriteá : ('a * ''b) list * ('a * ''b) -> ('a * ''b) list;
=DESCRIBE
$alist$ $roverwrite$ $(a,b)$ gives the list that in which the first pair in $alist$ that has the right item $b$ is replaced with the pair $(a, b)$.
If no such pair is found in $alist$ then it returns the list of $(a,b)$ appended to the end of $alist$.
=SEEALSO
$overwrite$, $list\_roverwrite$
=ENDDOC
=DOC
val âlist_roverwriteá : ('a * ''b) list * ('a * ''b) list -> ('a * ''b) list;
=DESCRIBE
$alist$ $list\_roverwrite$ $olist$ overwrites $alist$ with each element of $olist$, using $roverwrite$ (q.v.).
=SEEALSO
$roverwrite$, $list\_overwrite$.
=ENDDOC

\subsection{Another Miscellany}
=DOC
val âis_nilá : 'a list -> bool;
=DESCRIBE
$is\_nil$ tests whether a list is empty([]). It can be
used for lists of types which do not admit equality.
=ENDDOC
=DOC
val âflatá : 'a list list -> 'a list;
=DESCRIBE
$flat$ takes a list of lists and returns the result of
concatenating them all.
=ENDDOC
=DOC
val âsplitá : ('a * 'b) list -> 'a list * 'b list;
=DESCRIBE
Split a list of pairs into a pair of lists.
óDefinition
split [(x0, y0), (x1, y1), ... (xk, yk)] = [x0, x1, ... , xk],  [y0, y1, ... , yk]
æ
=SEEALSO
$split3$, $combine$
=ENDDOC
=DOC
val âsplit3á : ('a * 'b * 'c) list -> 'a list * 'b list * 'c list;
=DESCRIBE
Split a list of triples into a triple of lists.
$split3$ is the analogue of $split$ for lists of triples.
=SEEALSO
$split$
=ENDDOC
=DOC
val âcombineá : 'a list -> 'b list -> ('a * 'b) list;
=DESCRIBE
$combine$ combines a pair of lists into a list of pairs. It is the left inverse of $split$.
=FAILURE
1007	Cannot combine unequal length lists
=SEEALSO
$split$, $zip$
=ENDDOC
=DOC
val âall_differentá : ''a list -> bool;
=DESCRIBE
$all\_different$ determines whether a list has any
repeated entries.
=SEEALSO
$all\_distinct$
=ENDDOC
=DOC
val âall_distinctá : ('a * 'a -> bool) -> 'a list -> bool;
=DESCRIBE
$all\_distinct$ $eq$ $list$ determines whether $list$ has any
repeated entries using $eq$ to test for
equality.
Each member, $x$ of the list is tested against all the subsequent
members of the list, with $x$ being the first argument to
$eq$.
=SEEALSO
$all\_different$
=ENDDOC
=DOC
val âfromá : 'a list * int -> 'a list;
=DESCRIBE
The infix function $from$ takes
the trailing slice of a list.
It uses 0-based indexing.
=EXAMPLE
[0,1,2,3] from 2 = [2,3]
=SEEALSO
$to$
=ENDDOC
=DOC
val âtoá : 'a list * int -> 'a list;
=DESCRIBE
The infix function $to$ takes
the initial slice of a list.
It uses 0-based indexing.
=EXAMPLE
[0,1,2,3] to 2 = [0,1,2]
=SEEALSO
$from$
=ENDDOC
=DOC
val âintervalá : int -> int -> int list;
=DESCRIBE
$interval\;a\;b$ is the list $[a,a+1,a+2\ldots,b]$.
This is taken to be $[]$ if $a > b$ and to be $[a]$
if $a = b$.
=ENDDOC
=DOC
val âmapfilterá : ('a -> 'b) -> 'a list -> 'b list;
=DESCRIBE
Map a function over a list.
If, when evaluating 
\[mapfilter f (x_1 :: \ldots x_{k-1} :: x_k :: x_{k+1} :: \ldots )\]
the evaluation of $f\ x_k$ raises a $Fail$ exception, then 
the result will be
\[(f\ x_1 :: \ldots f\ x_{k-1} :: f\ x_{k+1} :: \ldots)\]
=ENDDOC
=DOC
val âzipá : ('a -> 'b)list -> 'a  list -> 'b list;
=DESCRIBE
Given a list of functions, and a list of arguments, of the same length, apply each function to its corresponding argument.
For the cases when the list of functions induce side effects, 
note that 
the functions are applied from the head of their list to the tail, and 
will be applied until there are insufficient elements of either list to continue.
If there lists are not of equal length then at that point a failure will be raised.
=SEEALSO
$combine$
=FAILURE
1008	List lengths differ
=ENDDOC
=DOC
val ânthá : int -> 'a list -> 'a;
=DESCRIBE
Return the $n$-th element of a list. The head of the list is the $0$-th element.
=FAILURE
1009	Index past ends of list
=ENDDOC
=DOC
val âwhichá : (('a * 'a) -> bool) -> 'a -> 'a list -> int OPT;
=DESCRIBE
$which$ $eq$ $x$ $list$ returns $Value$ of the position of first element, $y$, in $list$ for which $eq\ x\ y$ is true.
It uses 0-based indexing.
If no such $y$ is found, then it returns $Nil$.
=ENDDOC
\subsection{End of ListUtilities}
=SML
end (* of ListUtilities signature *);
=TEX
\section{FUNCTION UTILITIES}
=DOC
signature âFunctionUtilitiesá = sig
=DESCRIBE
Holds a variety of utility Standard ML functions concerned with functions.
=ENDDOC
\subsection{Pairs}
=DOC
val âfstá : 'a * 'b -> 'a;
=DESCRIBE
$fst$ is the left projection function for pairs: $fst(a,b)\ =\ a$.
=SEEALSO
$snd$
=ENDDOC
=DOC
val âsndá : 'a * 'b -> 'b;
=DESCRIBE
$snd$ is the right projection function for pairs: $snd(a,b)\ =\ b$.
=SEEALSO
$fst$
=ENDDOC
=DOC
val âswapá  : 'a * 'b -> 'b * 'a;
=DESCRIBE
$swap$ interchanges the elements of a pair: $swap(a,b)\ =\ (b,a)$.
=ENDDOC
\subsection{Functionals}
Certain higher-order functions are very useful.

=DOC
val âcurryá  : ('a * 'b -> 'c) -> 'a -> 'b -> 'c;
=DESCRIBE
$curry$ $f$ $a$ $b$ gives $f\ (a,b)$.
=SEEALSO
$uncurry$
=ENDDOC
=DOC
val âuncurryá : ('a -> 'b -> 'c) -> 'a * 'b -> 'c;
=DESCRIBE
$uncurry$ $f$ $(a,b)$ gives $f$ $a$ $b$.
=SEEALSO
$curry$
=ENDDOC
=DOC
val âswitchá  : ('a -> 'b -> 'c) -> 'b -> 'a -> 'c;
=DESCRIBE
$switch$ $f$ $a$ $b$ gives $f$ $b$ $a$.
=ENDDOC
=DOC
val â**á  : ('a -> 'b) * ('c -> 'd) -> 'a * 'c -> 'b * 'd;
=DESCRIBE
The infix operator $**$, with precedence 4 (higher
than ``$o$''), gives the function induced by a pair
of functions from the product of their domains to
the product of their codomains. 
óDefinition
(f ** g) x = (f x, g x)
æ
=ENDDOC
=DOC
val âfunpowá  : int -> ('a -> 'a) -> 'a -> 'a;
=DESCRIBE
For non-negative $n$, $funpow\ n\ f$ is $f^n$, i.e. the
function 
\[xŽf(f( ... f(f x) ....)\]
where $f$
appears $n$ times.
=FAILURE
1010	First argument must not be negative
=ENDDOC
=DOC
val âfun_andá : (('a -> bool) * ('a -> bool)) -> 'a -> bool;
val âfun_orá : (('a -> bool) * ('a -> bool)) -> 'a -> bool;
val âfun_notá : ('a -> bool) -> 'a -> bool;
val âfun_trueá : 'a -> bool;
val âfun_falseá : 'a -> bool;
=DESCRIBE
These functions allow a style of programming that handles predicates rather than booleans.
óDefinition
(f fun_and g) x	= f x andalso g x
(f fun_or g) x 	= f x orelse g x
(fun_not f) x 	= not(f x)
fun_true x 	= true
fun_false x 	= false
æ
=ENDDOC
=DOC
val ârepeatá : (unit -> 'a) -> unit;
val âiterateá : ('a -> 'a) -> 'a -> 'a;
=DESCRIBE
$repeat$ applies its argument to $()$ until it fails, whereupon it returns $()$.
$iterate$ $f$ $a$ applies $f$ to $a$.
If this causes no failure it then calls $iterate$ $f$ on the result.
If it fails it returns $a$.
óDefinition
fun repeat f	= (f (); repeat f) handle (Fail _) => ()
fun iterate f a	= (iterate f (f a); handle (Fail _) => a)
æ
=ENDDOC
$repeat$ does not return its last successful result, as if it failed on the
first application there would be none available.
=SML
end (* of FunctionUtilities signature *);
=TEX
\section{COMBINATORS}
It can be convenient to have the definitions of
certain combinators. We package these in a structure
(since their conventional names are single letters).
=DOC
signature âCombinatorsá = sig
=DESCRIBE
Holds the three combinators $S$, $K$, $I$.
=ENDDOC
=DOC
val âIá : 'a -> 'a
=DESCRIBE
The identity combinator: $I\ x\ =\ x$.
=ENDDOC
=DOC
val âSá : ('a -> 'b -> 'c) -> ('a -> 'b) -> 'a -> 'c
=DESCRIBE
The duplication combinator: $S\ f\ g\ a$ is $(f\ a)(g\ a)$.
=ENDDOC
=DOC
val âKá : 'a -> 'b -> 'a
=DESCRIBE
The deletion combinator: $K\ x\ y$ is $x$.
=ENDDOC
=SML
end (* of Combinators signature *);
=TEX
\section{SIMPLE OUTPUT}
=DOC
signature âSimpleOutputá = sig
=DESCRIBE
Holds a variety of utility Standard ML functions concerned with simple output.
Related facilities may be found in structure ReaderWriter.
Function $ask\_at\_terminal$ (q.v)
provides for prompted input of text from the terminal.

Strings containing extended characters and strings derived
from HOL types and terms should be passed through the ReaderWriter function $translate\_for\_output$ (q.v) before being output.  This allows the proper output
of keywords and extended characters on both graphic and simple 
ASCII terminals.

=ENDDOC
The following two functions will be implemented using 
the functions of structure $SystemControl$.
=DOC
(* âline_lengthá - integer control declared by new_int_control *)
=DESCRIBE
An integer control dictating the output's length of line available for printing.
=SEEALSO
$set\_line\_length$, $get\_line\_length$
=ENDDOC
=DOC
val âset_line_lengthá : int -> int
=DESCRIBE
Set the output line length, returning the previous line length.
Default length is 80, minimum length 20.
=SEEALSO
$get\_line\_length$
=FAILURE
1015	line length must be at least 20
=ENDDOC
=DOC
val âget_line_lengthá : unit -> int
=DESCRIBE
Returns current output line length.
=SEEALSO
$set\_line\_length$
=ENDDOC
=DOC
val âdiag_stringá : string -> unit;
=DESCRIBE
$diag\_string$ outputs
a string on the standard output stream.
If the string exceeds the value of {\em get\_line\_length} it attempts to split the string into tokens, to fit within the line length.
A token is taken to be an initial string of spaces, followed by exclusively non-space characters.
=SEEALSO
$list\_diag\_string$, $diag\_line$
=ENDDOC
=DOC
val âlist_diag_stringá : string list -> unit;
=DESCRIBE
$list\_diag\_string$ outputs a list of strings
onto the standard output stream. The strings in the list
are concatenated (with spaces to separate them) and then
output with $diag\_string$ (q.v). 
=ENDDOC
=DOC
val âdiag_lineá : string -> unit;
=DESCRIBE
$diag\_line$ outputs a string to the standard output
stream followed by a new line.
It is intended for use in printing formatted terms,
theorems and the like (for which the pretty printer
will have included new lines within the string if
necessary).
=SEEALSO
$diag\_string$
=ENDDOC
=DOC
val âformat_listá : ('a -> string) -> 'a list -> string -> string;
=DESCRIBE
$format\_list$ is used to format a list of items for printing
as a string, given a function to format a single item
and a string to separate elements of a multi-element
list.
=ENDDOC
=SML
end (* of SimpleOutput signature *);
=TEX
\section{CHARACTER UTILITIES}
=DOC
signature âCharacterUtilitiesá = sig
=DESCRIBE
Holds a variety of utility Standard ML functions concerned with character handling.
=ENDDOC
=DOC
val âis_all_decimalá : string -> bool;
=DESCRIBE
$is\_all\_decimal$ checks whether a string consists
of one or more decimal digits.
=ENDDOC
=DOC
val âgensymá : unit -> int;
=DESCRIBE
Successive applications of $gensym$ return
successive integers.
=ENDDOC
\subsection{Numeric Conversions}
=DOC
val ânat_of_stringá : string -> int;
=DESCRIBE
$nat\_of\_string$ converts a string into non-negative
integer (using decimal notation).
=SEEALSO
$string\_of\_int$
=FAILURE
1012	?0 is not a decimal string
1013	String is empty
=ENDDOC
=DOC
val âstring_of_intá  : int -> string;
=DESCRIBE
$string\_of\_int$ converts an integer into a decimal
string.
=SEEALSO
$nat\_of\_string$
=ENDDOC
This function is similar to $makestring$ of some implementations of Standard ML.
=SML
end (* of CharacterUtilities signature *);
=TEX
\section{DICTIONARIES}
To implement HOL theories and the theory hierarchy
we need to represent the type and constant environments
of the formal specification (\cite{DS/FMU/IED/SPC001}).
These environments are essentially partial functions from
$string$ to values of suitable type.

The operations required on these partial functions
are: application,
extension by a singleton function, deletion of elements
from the domain and overwriting both
by singleton functions and by arbitrary partial function.
This is similar to what is typically required for
the symbol table of a compiler.
We will call a data structure together with functions
to perform these operations a ``dictionary''.

We offer two generic implementations of dictionaries
here. The first implementation uses linear search
and performs slowly when the data structures become
large. The second implementation uses a hash addressing technique
and gives considerably more efficient access than the simple
implementation to larger data structures.

\subsection{Simple Dictionaries}
The implementation will use linear search
and performs slowly when the data structures become
large.
 
Its functions are straightforward. We use the prefix $s\_$ to
distinguish the types and functions involved from those
used for the more efficient technique.

After defining a simple dictionary to be a list of
pairs, the functions for accessing and modifying
dictionaries are essentially just interfaces to the
partial function operations defined in
signature $ListUtilities$.

The type of simple dictionaries is declared in signature $UtilitySharedTypes$.
=DOC
signature âSimpleDictionaryá = sig
=DESCRIBE
Holds a set of Standard ML functions concerned with a linear search
dictionary.
=USES
For handling small dictionaries.
=SEEALSO
$EfficientDictionary$.
=ENDDOC
=DOC
val âs_lookupá : string -> 'a S_DICT -> 'a OPT;
=DESCRIBE
$s\_lookup$ implements application (of the dictionary
viewed as a partial function).
$s\_lookup$ $name$ $dict$ returns the value that $dict$ associates with $name$.
=ENDDOC
=DOC
val âs_enterá : string -> 'a -> 'a S_DICT -> 'a S_DICT;
=DESCRIBE
$s\_enter$ implements overwriting by a singleton function.
$s\_enter$ $name$ $value$ $dict$ returns the dictionary
that associates $name$ with $value$, and otherwise associates as $dict$.
Overwriting is done ``in place'', entries not previously present will be placed at the end of the dictionary viewed as a list.
=ENDDOC
=DOC
val âs_extendá : string -> 'a -> 'a S_DICT -> 'a S_DICT;
=DESCRIBE
$s\_extend$ implements extension by a singleton function,
that is to say it is like $s\_enter$.
$s\_extend$ $name$ $value$ $dict$ returns the dictionary
that associates $name$ with $value$, and otherwise associates as $dict$.
It fails if $name$ is already in the domain of $dict$.
Entries not previously present will be placed at the head of the dictionary viewed as a list.
=FAILURE
1014	?0 is already in dictionary
=ENDDOC
=DOC
val âs_deleteá : string -> 'a S_DICT -> 'a S_DICT;
=DESCRIBE
$s\_delete$ deletes an element of the domain of a dictionary.
If the element is not in the domain it returns the
dictionary unchanged.
$s\_delete$ $name$ $dict$ returns a dictionary that does not associate anything with $name$, but otherwise associates as $dict$.
=ENDDOC
=DOC
val âs_mergeá : 'a S_DICT -> 'a S_DICT -> 'a S_DICT;
=DESCRIBE
$s\_merge$ extends one dictionary by another.
The dictionary $s\_merge$ $dict1$ $dict2$ will associate 
a name with the value that either $dict1$ or $dict2$ associates it with.
=FAILUREC
\paragraph{Failure}
Will get the $s\_extend$ failure message if any element is common to the domains of both dictionaries ($dict1$ and $dict2$).
Duplicate keys in the first list will also cause an $s\_extend$ error,
but will be replicated in the result if found in the second list.
=ENDDOC
=DOC
val âinitial_s_dictá : 'a S_DICT;
=DESCRIBE
The empty dictionary, which
gives a starting point for the use of the simple dictionary functions.
It does not associate a value with any name.
=ENDDOC
=SML
end (* of SimpleDictionary signature *);
=TEX
\subsection{Efficient Dictionaries}
The technique we use for the more efficient dictionaries
is essentially the standard compiler writer's technique
of hash addressing with chaining to handle collisions
(see, for example, \cite{Bornat79}).

We discuss the detailed algorithm in \cite{DS/FMU/IED/IMP001}.
The signature is essentially that of simple dictionaries, 
only the desire to open these structures at the same time,
and a few additional functions,
means that the signatures are not unified.

Its functions are similar to those of $SimpleDictionary$.
=DOC
signature âEfficientDictionaryá = sig
=DESCRIBE
A dictionary based on hash-search techniques.
=USES
For handling large dictionaries.
=SEEALSO
$SimpleDictionary$.
=ENDDOC
=DOC
type 'a âE_DICTá;
=DESCRIBE
The type of efficient dictionaries.
=ENDDOC
=DOC
val âe_lookupá : string -> 'a E_DICT -> 'a OPT
=DESCRIBE
$e\_lookup$ implements application (of the dictionary
viewed as a partial function).
$e\_lookup$ $name$ $dict$ returns the value that $dict$ associates with $name$.
=ENDDOC
=DOC
val âe_enterá : string -> 'a -> 'a E_DICT -> 'a E_DICT;
=DESCRIBE
$e\_enter$ implements overwriting by a singleton function.
$e\_enter$ $name$ $value$ $dict$ returns the dictionary
that associates $name$ with $value$, and otherwise associates as $dict$.
=ENDDOC
=DOC
val âe_extendá : string -> 'a -> 'a E_DICT -> 'a E_DICT;
=DESCRIBE
$e\_extend$ implements extension by a singleton function,
that is to say it is like $e\_enter$.
$e\_extend$ $name$ $value$ $dict$ returns the dictionary
that associates $name$ with $value$, and otherwise associates as $dict$.
It fails if $name$ is already in the domain of $dict$.
=FAILURE
1014	?0 is already in dictionary
=ENDDOC
=DOC
val âe_deleteá : string -> 'a E_DICT -> 'a E_DICT;
=DESCRIBE
$e\_delete$ deletes an element of the domain of a dictionary.
If the element is not in the domain it returns the
dictionary unchanged.
$e\_delete$ $name$ $dict$ returns a dictionary that does not associate anything with $name$, but otherwise associates as $dict$.
=ENDDOC
=DOC
val âe_flattená : 'a E_DICT -> 'a S_DICT;
=DESCRIBE
$e\_flatten$ converts an efficient dictionary into a simple one.
The result will contain no duplicates, but will be in no useful order.
=ENDDOC
=DOC
val âlist_e_mergeá : 'a E_DICT -> 'a S_DICT -> 'a E_DICT;
=DESCRIBE
$list\_e\_merge$ extends an efficient dictionary by a simple
one.
That is, for each association within the simple dictionary
an $e\_extend$ is executed on the efficient dictionary.
=FAILUREC
\paragraph{Failure}
Will get the $e\_extend$ failure message if an element is common to the domains of both dictionaries.
=ENDDOC
=DOC
val âe_mergeá : 'a E_DICT -> 'a E_DICT -> 'a E_DICT;
=DESCRIBE
$e\_merge$ extends one efficient dictionary by another.
The dictionary $e\_merge$ $dict1$ $dict2$ will associate 
a name with the value that either $dict1$ or $dict2$ associates it with.
=FAILUREC
\paragraph{Failure}
Will get the $e\_extend$ failure message if an element is common to the domains of both dictionaries.
=ENDDOC
=DOC
val âinitial_e_dictá : 'a E_DICT;
=DESCRIBE
The empty dictionary, which
gives a starting point for the use of the efficient dictionary functions.
It does not associate a value with any name.
=ENDDOC
=SML
end (* of EfficientDictionary signature *);
=TEX
\section{CODE PROFILING}
=DOC
signature âProfilingá = sig
=DESCRIBE
The signature contains definitions may be used to record
statistics, e.g., on the number of times certain
functions have been called.
=ENDDOC
=DOC
(* âprofilingá - boolean flag declared by new_flag *)
=DESCRIBE
Turns profiling on (if true) or off (if false).
Default is on.
This should be maintained via the functions of structure $SystemControl$.
=ENDDOC
=DOC
val âprofá : string -> unit;
val âcountsá : string -> int OPT;
val âget_statsá : unit -> int S_DICT;
val âprint_statsá : int S_DICT -> unit;
val âinit_statsá : unit -> unit;
=DESCRIBE
These five functions provide a simple database facility, associating
each name with a count.
A call to $prof$ $name$ increments the count for $name$.
A call to $counts$ $name$ returns the value of the current count 
for $name$.
A call to $get\_stats$ provides the counting database as an integer dictionary, in order of first name entry into database being first
in the dictionary viewed as a list.
The function $print\_stats$ will provide a one line - one entry
display of an integer dictionary, in particular the kind of dictionary
provided by $get\_stats$.
A call to $init\_stats$ initialises all the counts to 0
(which is also the state in which the database starts).

It is likely that the output of $get\_stats$ would be best sorted
before being printed by $print\_stats$.
=USES
The intended use of this database is to profile function calls,
with the implementer making one call to $prof$ per profiled function.
=ENDDOC
=SML
end(* of Profiling signature *);
=TEX
\section{SORTING}
=DOC
signature âSortá = sig
=DESCRIBE
This provides an efficient sort utility package.
=ENDDOC
=DOC
val âsortá : ('a -> 'a -> int) -> 'a list -> 'a list
=SYNOPSIS
A parameterised sort of a list.
=DESCRIBE
The sorting of items of type $'a$ is parameterised by an
ordering function of type $'a -> 'a -> int$.
The integer, say $n$ returned by an application
of this function, say $f\ a_1\ a_2$, is interpreted as
follows: 
\begin{description}
\item[$n < 0$] $a_2$ is to come after $a_1$ (i.e. the arguments are in order).
\item[$n > 0$] $a_2$ is to come before $a_1$ (i.e. the arguments are out of order).
\item[$n = 0$] $a_2$ is to be taken as equal to $a_1$
(all but the first of each set of duplicates, in this sense, will be ignored).
\end{description}
=EXAMPLE
To sort a list of integers, ilist in ascending order:

	sort (curry (op -)) ilist
=SEEALSO
For two possible orderings: $stringorder$ and $lexicographic$.
=ENDDOC
=DOC
val âstringorderá : string -> string -> int
=DESCRIBE
This function gives a more civilised ordering on
strings than the one given by the ASCII codes.
It first does a lexicographic (q.v) case-insensitive ordering
(treating all upper case letters as their corresponding lower case), all alphabetic characters are considered ``before'' the rest,
but otherwise using ASCII order, on exploded strings.
If two strings are otherwise equal then a case-sensitive
comparison is made, with the string having the first unmatched capitalisation being ordered as first.
The integer result is appropriate for use in $sort$ (q.v.).
=SEEALSO
$lexicographic$
=ENDDOC
=DOC
val âlexicographicá : ('a -> 'a -> int) -> 'a list -> 'a list -> int
=SYNOPSIS
This function returns the lexicographic ordering
function induced from an ordering
of items of type $'a$ on items of type $'a\,list$.
=DESCRIBE
Lexicographic ordering may be defined as follows:

Let us presume some ordering $<$ on the type of variables $a_i$ and $b_i$.
Then
\[ [a_1, \ldots, a_n]\ <_{lexicographic}\ [b_1, \ldots, b_m] \]
If, and only if, either
\[ n\ <_{int}\ m\ € \ ƒ i : 1 .. n\ Ž\ a_i\ =\ b_i\]
Or
\[„ j : 1 .. n\ Ž\ (ƒ i : 1 .. (j-1)\ Ž\ a_i\ =\ b_i)\ €\ (a_j\ <\ b_j)\]
The integer result is appropriate for use in $sort$ (q.v.).
=SEEALSO
$stringorder$
=ENDDOC
=SML
end (* end of Sort signature *);
=TEX
\section{TEST POLICY}
In  \cite{DS/FMU/IED/PLN008} there is a statement of the general principle of testing to be adopted.
This section gives some individual comments on special testing requirements for individual functions.

Any function parameterised by an equality argument should be tested with an asymmetric ``equality'', to check the argument order.

The design of the function $union$ describes a particular ordering of its result.
The conformance to this order should be checked.

The functions $lassoc{\cal N}$, $rassoc{\cal N}$ and all others that act on ``\ldots the first element of the list that \ldots'' should be checked with lists containing duplicates, to ensure that the first matching element is selected.

The designs of functions $stringorder$ and $lexicographic$
describe orderings that their implementations should be tested against.

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
