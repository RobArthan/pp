=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of the Module Test Harness}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD013}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document gives the detailed design of the module test harness for use in testing Standard ML functions which constitute various
parts of ICL HOL.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}

\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'

\begin{description}
\item[Issue 1.1]
Draft for review
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}

\subsection{Scope}

This documents the detailed design of the
module test harness. The harness is to be
used for the purpose of developing
and running tests for the ICL HOL development.

\subsection{Introduction}

\subsubsection{Background and Purpose}

---EXTRACT FOR INCLUSION INTO TEST PROCEDURE---

It is essential that test material is inspectable against
the guidelines for tests outlined in the quality plan
and in the test section of a detailed design document. In order
to ensure that this is the case, it is recommended that
there be a section in a module test document outlining the
test cases which should be carried out for the functions
which the document addresses. This makes checking the
tests for completeness possible. This section provides a
link between the requirements for testing and the actual
test code and data.

It is strongly recommended that test cases are enumerated,
so that the corresponding test code can be located.
A suggested scheme is to use the name of the function which
the test case tests followed by a number; for example
``function.1'', ``function.2'' and so on.

-----------------END OF EXTRACT----------------

The test harness allows a function to be tested by
supplying the harness with the function, some
inputs and expected
outputs. It can test functions for handling exceptions, and
check that the message generated by an exception corresponds
to one expected.

The harness should make the development of module tests
much easier and in particular, help the developer
speedily identify those test cases which fail.

\subsubsection{Interface}

This document defines a signature ModuleTest.

\subsubsection{Deficiencies}

None Known.

\subsubsection{Dependencies}

This document depends on the error handling system described
in document DS/FMU/IED/DTD002.

\section{THE STRUCTURE $ModuleTest$}

The module test harness comprises functions do the
following:
\begin{description}
\item[Control Functions]
The first group of functions manage the running
of the module tests. These allow test results
to be collected together and printed at the
end of running the tests. 

\item[Test Execution]
These functions generally take test data and produce
a list of test results. The results can be delivered to
the control functions for managing the test results.

\end{description}

In addition there is a function $gen\_fail\_msg$ which is
useful for generating fail and error exception messages for
contructing test data.

\subsection{STRUCTURE OF TESTS IN A MODULE TEST DOCUMENT}

The following is a suggested structure for constructing tests
using the test harness. By enclosing the variable declarations
in the let clause, unnecessary output is minimised.
There are two tests in the example below. The test
cases are the strings ``func.1'' and ``func.2''. They
test that the function $func$ supplied with arguments $i1$ and
$i2$ deliver $r1$ and $r2$ respectively. The tests are evaluated
by the function $mt_run$, and are stored in a results store
using $store\_mt\_results$.

=EXAMPLE
let	val i1 = ...;
	val i2 = ...;

	val r1 = ...;
	val r2 = ...;
in

store_mt_results mt_run [
	("func.1", func, i1, r1),
	("func.2", func, i2, r2)
]
end;
=TEX

The next example is given to show how tests might be constructed
for checking that ``fail'' exceptions occur when they are
supposed to. It differs from the above example in that
the expected results are generated using the function
$gen\_fail\_message$. The function $mt\_run\_fail$ runs
the tests, expecting an exception with the constructor, ``Fail''
to be raised. The output is compared with $fm1$ and $fm2$
respectively
and the results are subsequently stored using $store\_mt\_results$.

=EXAMPLE
let	val i1 = ...;
	val i2 = ...;

	val fm1 = gen_fail_message ...;
	val fm2 = gen_fail_message ...;
in

store_mt_results mt_run_fail [
	("CASE1", func, i1, fm1),
	("CASE2", func, i2, fm2)
]
end;

summarize_mt_results();
=TEX

At the end of the tests the results are summarized by the
call to the function $summarize\_mt\_results$.

=DOC
signature âModuleTestá = sig
=DESCRIBE
This is the signature for the structure ModuleTest.
=ENDDOC

=DOC
	val gen_fail_msg : string -> int -> string list -> string;
=DESCRIBE
{\it gen\_fail\_msg} allows the user to construct an error
message of the form that would be generated by the system
on the occasion of a ``Fail'' or an ``Error'' exception.
This is provided to aid the developer of test material to
generate test data.

The function takes three arguments. The
first argument supplied indicates the name of the
function from which the message would have been generated.
The second identifies the error message in the error
message database. The third is a list of strings which
may be used to substitute strings in the error message string.
=EXAMPLE
	icl'change_error_message{id=1,text="Error message"};
	gen_fail_msg "mt" 1 [];
=SEEALSO
{\it fail} and {\it error} described in DS/FMU/IED/DTD002.
=ENDDOC


=DOC
	val âmt_runá		: (string * ('a -> ''b) * 'a * ''b) list -> (string * bool) list;
=DESCRIBE
{\it mt\_run} is a function which takes a list of test cases
and delivers a list of results. The test cases are
of the form $(testcase, function, argument, expected-result)$

$testcase$ is a string which identifies the test. 
$function$ is the function to be tested. $argument$ is the
input which is supplied to the function to produce an output.
If the output matches $expected-result$ then $(testcase,\ true)$
is produced for that particular test, otherwise
$(testcase,\ false)$ is produced. 
=USES
{\it mt\_run} can be used alone as in the example below for debugging
test cases. When running the module tests formally however, it should
be used in conjunction with {\it store\_mt\_results} and
{\it store\_mt\_results\_show}.
=EXAMPLE
	mt_run [("TESTCASE",hd, [3,4,5], 3)];
=SEEALSO
{\it mt\_runf}, {\it store\_mt\_results}, {\it store\_mt\_results\_show}
=ENDDOC

=DOC
	val âmt_runfá		: (('b * 'c) -> bool) -> ((string * ('a -> 'b) * 'a * 'c) list)
					-> (string * bool) list;
=DESCRIBE
{\it mt\_runf} is a function which takes a comparison
function, a list of test cases
and delivers a list of results. The test cases are
of the form $(testcase, function, argument, expected-result)$.
$testcase$ is a string which identifies the test.
$function$ is the function to be tested. $argument$ is the
input which is supplied to the function to produce an output.
If the comparison function provided returns the value
true when given the result of the function applied to the
argument, and $expected-result$, then $(testcase,\ true)$
is produced for that particular test, otherwise
$(testcase,\ false)$ is produced.
=USES
{\it mt\_runf} can be used when it is inappropriate to
check that the result of a function is equal to some expected
result. For example a ``greater-than'' function could
be supplied for testing that an evaluation of a function with
an intput is always greater than a particular value.
Another use would be to supply a comparison function to
compare objects of two different types. An example of this
use is shown below.

{\it mt\_runf} can be used alone as in the example below for debugging
test cases. When running the module tests formally however, it should
be used in conjunction with {\it store\_mt\_results} and
{\it store\_mt\_results\_show}.
=EXAMPLE
	datatype VAL = Value of int;
	fun is_eq (i, Value n) = (i = n);
	mt_runf is_eq [("TESTCASE",hd, [3,4,5], Value 3)];
=SEEALSO
{\it mt\_run}, {\it store\_mt\_results}, {\it store\_mt\_results\_show}
=ENDDOC

=DOC
	val âmt_run_failá	: ((string * ('a -> 'b) * 'a * string) list) -> (string * bool) list;
	val âmt_run_errorá	: ((string * ('a -> 'b) * 'a * string) list) -> (string * bool) list;
=DESCRIBE
{\it mt\_run\_fail} is a function which takes a list of
test cases and yields a list of test results. Each test
case is expected to raise an exception with the
constructor``Fail''.
{\it mt\_run\_fail} will catch the exception and compare the error message
generated with the expected message supplied in each test
case. If the messages match, then the test result is of
the form $(testcase,\ true)$, otherwise it is of the form
$(testcase,\ false)$.

{\it mt\_run\_error} is the same as {\it mt\_run\_fail} in
all respects, except that an
exception with the constructor ``Error'' is expected
to be raised for each test case.

=USES
{\it mt\_run\_fail} and {\it mt\_run\_error}
can be used as in the example below for debugging
test cases. When running the module tests however, they should
only be used in conjunction with {\it store\_mt\_results} and
{\it store\_mt\_results\_show}.
=EXAMPLE
	icl'change_error_message{id=1,text="Error message"};
	val exp_res = gen_fail_msg "mt" 1 [];
	mt_run_fail [("TESTCASE", fail "mt" 1, [], exp_res)];
	mt_run_error [("TESTCASE", error "mt" 1, [], exp_res)];
=SEEALSO
{\it store\_mt\_results}, {\it store\_mt\_results\_show}
=ENDDOC

=DOC
	val âinit_mt_resultsá		: unit -> unit;
=DESCRIBE
{\it init\_mt\_results} initialises the store of computed
results to an empty list. This is the state the store
should be set to before running any tests.
=USES
It should be called before any tests are run. It can
also be used to re-initialise the result store at any time.
=EXAMPLE
	init_mt_results();
=ENDDOC

=DOC
	val âstore_mt_resultsá		: ('a -> (string * bool) list) -> 'a -> unit;
	val âstore_mt_results_showá	: ('a -> (string * bool) list) -> 'a -> (string * bool) list;
=DESCRIBE
{\it store\_mt\_results} takes two arguments. The first is a function
which takes a list of test cases, and produces a
list of outputs. The second argument is a list of testcases
which are to be tested. {\it store\_mt\_results} will apply the first
argument to the second, and append the results to the
result store.

{\it store\_mt\_results\_show} is similar to {\it store\_mt\_results}, but
the result of evaluating the first argument with the
second argument is returned by the function {\it store\_mt\_results\_show}. The result is also stored.
=USES
These two functions can be used to build up a set of test
case results, which can be printed later using {\it get\_mt\_results}. 
=EXAMPLE
	store_mt_results mt_run [("TESTCASE",hd, [3,4,5], 3)];
	store_mt_results_show mt_run [("TESTCASE",hd, [3,4,5], 3)];
=ENDDOC

=DOC
	val âget_mt_resultsá		: unit -> (string * bool) list;
=DESCRIBE
{\it get\_mt\_results} prints the contents of the results
store. This prints a list of ordered pairs. The first
element of a pair in the list is a string which identifies the
test case which has been tested. The second element of the pair
is the value true or false indicating success or failure
of the test. The list of results will only contain those
tests which have actually been run. Thus, the list is
a complete record of all tests which have been run.
=USES
It is typically used after running several module
tests, and will print a complete set of results since
the beginning of the run, or since the last call to
{\it init\_mt\_results}.
=EXAMPLE
	get_mt_results();
=ENDDOC

=DOC
	val âsummarize_mt_resultsá	: unit -> string;
=DESCRIBE
{\it summarize\_mt\_results} returns true if and only if
all the tests in the results store have all passed. Otherwise
it returns false. It is thus the result of ``and-ing'' the
second element of each pair in the list of results obtained.
=USES
It enables a user to establish quickly if there are any failed
tests. This is useful when dealing with large sets of results.
=EXAMPLE
	summarize_mt_results();
=ENDDOC


=SML
end; (* of signature ModuleTest *)
=TEX
\section{TEST POLICY}
The tests should follow the standards and guidelines laid down in
DS/FMU/IED/PLN008.

\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}
