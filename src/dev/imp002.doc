% imp002.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of System Control and Basic Error Reporting}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP002}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the implementation of the
system control and basic
error reporting subsystem for the ICL HOL system.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library\\ R.D. Arthan\\ K. Blackburn}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1]
First draft for comment.
\item[Issue 1.4]
$set\_flag$ and associated functions changed, to return previous value of control variable.
\item [Issue 1.6]
Modified $new\_error\_message$ to only give an error if given a duplicate $id$, but also a differing $text$.
\item [Issue 1.11]
Added $pass\_on$.
\item [Issue 1.12 (4 July 1991)]
$new\_error\_message$ no longer raises exceptions.
\item [Issue 1.14 (\FormatDate{91/08/12%
})] Rework after inspection (ID0019) of DTD002.

\item[Issue 1.15, \FormatDate{92/01/20} ] Updated to use new fonts.

\item[Issue 1.16, \FormatDate{92/02/21} ] Error
messages are not contained in ``***'' anymore.

\item[Issue 1.18, \FormatDate{92/02/26} ] Minor
change to error message format.
Avoid use of $PolyML.makestring$ by adding $string_of_int$. {}
Make $setup_pp$ print error messages a word at a time.
\item[Issue 1.19 (14th December 1992)]
Changed to allow uniform saving of controls and error messages.

\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains part of the implementation of
the ICL HOL system.
\subsection{Introduction}
\subsubsection{Background and Purpose}
This document contains the implementation of the
material whose detailed design may be found in
\cite{DS/FMU/IED/DTD002}.
\subsection{Dependencies}
The use of $PolyML.install\_pp$
immediately after the definition of $give\_message$ is
also compiler-specific.
\subsection{Interface}
See \cite{DS/FMU/IED/DTD002}.
\subsection{Algorithms}
There are no complex algorithms in this document.
The most difficult problem is finding an interleaving
of the system control and error functions compatible
with declaration before use.
Since this structure is compiled before the utilities
defined in \cite{DS/FMU/IED/DTD001} it has to be self-sufficient
as regards table lookup algorithms etc.

\subsection{Possible Enhancements}
\subsection{Deficiencies}
\section{MINIMAL ERROR REPORTING}
\subsection{Preamble}
=SML
structure ÛBasicErrorİ : BasicError = struct
=TEX
\subsection{Types}
=SML
datatype ÛMESSAGEİ = ÛMessageİ of {area:string, id:int, inserters:(unit -> string) list};
=TEX
\subsection{Formatting Numbers}

Rather than use $PolyML.makestring$ we have
$string\_of\_int$ which converts an integer into a decimal
string. (SML's library function $makestring$ would
nearly do, but we want negative numbers to be shown
with a minus sign, and we do not want 
to be affected by $PolyML.print\-\_depth$ being set to 0.)

=SML
local
	val ord0 = ord "0"
in
fun Ûstring_of_intİ (n : int) : string = (
	let	fun aux m = ( (* assumes m > 0 *)
			case m div 10 of
				0 => chr(ord0 + (m mod 10))
			|	mdiv10 => aux mdiv10 ^ chr(ord0 + (m mod 10))
		);
	in	if n > 0
		then aux n
		else if n = 0
		then "0"
		else "-" ^ aux (~n)
	end
);
end;
=TEX

\subsection{Exceptions}
=SML
exception ÛFailİ of MESSAGE;
exception ÛErrorİ of MESSAGE;
=TEX
\subsection{Error Message Database}
The database is represented by an assignable variable
holding a table of identifier-entry pairs .
(Experiments show an average access time of 2msecs. (on a 
SPARC 1) to
do a look up in a table of 1000 entries. This seems
acceptable for an operation which is only performed when
an error message is actually printed.)
=SML
val Ûmessage_dbİ : {id:int, text:string} list ref = ref [];
=TEX
Some of the database access functions
can give rise to errors. None of these errors is recoverable
or trappable.
We therefore need the following simple function to raise errors.
=SML
fun Ûscreamİ (area : string) (msg : int) (inserts : string list): 'a = (
	raise (Error(Message({area=area, id=msg,
		inserters=map (fn x => (fn () => x))inserts})))
);
=TEX
=SML
fun Ûget_error_messageİ (id:int) (inserts:string list) : string = (
	let	fun aux1 ({id=id', text=text'} :: rest) = (
			if id' = id
			then text'
			else aux1 rest
		) | aux1 [] = scream "get_error_message" 2002 [string_of_int id];
		fun aux2 [] i = "?" ^ string_of_int i
		|   aux2 (h::t) i = (if i <= 0 then h else aux2 t (i-1));
		fun aux3 chs = (
			case chs of
				("?"::c::cs) => (
					if c = "?"
					then "?" :: aux3 cs
					else	let val num = ord c - ord "0"
						in	if num >= 0 andalso num <= 9
							then aux2 inserts num :: aux3 cs
							else "?" :: c :: aux3 cs
						end
			) |	c :: cs => (c :: aux3 cs
			) |	[] => []
		);
	in	implode(aux3(explode(aux1 (!message_db))))
	end
);
fun Ûnew_error_messageİ (arg as {id:int, text: string}) : unit = (
	let	fun aux ((arg' as {id=id', text=text'}) :: rest) = (
			if id' = id
			then 	if text = text'
				then aux rest
				else let val msg = get_error_message 2001 [string_of_int id];
				in
	output(std_out, "* " ^ msg ^ "\n [new_error_message.2001] *");
					arg' :: rest
				end
			else arg' :: aux rest
		) | aux [] = [arg]
	in	message_db := aux(!message_db)
	end
);
fun Ûget_error_messagesİ () : {id:int, text:string} list = (
	!message_db
);
fun Ûset_error_messagesİ (lst : {id:int, text:string} list): unit = (
	map new_error_message lst;
	()
);
fun Ûicl'change_error_messageİ (arg as {id:int, text: string}) : unit = (
	let	fun aux ((arg' as {id=id', text=text'}) :: rest) = (
			if id' = id
			then arg :: rest
			else arg' :: aux rest
		) | aux [] = [arg]
	in	message_db := aux(!message_db)
	end
);
=TEX
\subsection{Simple Error Reporting 1}
=SML
fun Ûreportİ (area : string) (id : int) (inserters : (unit -> string) list) : MESSAGE = (
	Message ({
		area=area,
		id=id,
		inserters = inserters})
);
fun Ûfailİ (area : string) (id : int) (inserters : (unit -> string) list) : 'a = (
	raise Fail(report area id inserters)
);
fun Ûerrorİ (area : string) (id : int) (inserters : (unit -> string) list) : 'a = (
	raise Error(report area id inserters)
);
=TEX
\subsection{Printing Errors}

=SML
fun Ûget_message_textİ (Message msg:MESSAGE) : string = (
	let	val {area:string, id:int, inserters:(unit->string)list} = msg;
		val inserts = map (fn f=> f())inserters;
	in	(get_error_message id inserts)
		handle Error _ => ("* " ^
			(get_error_message 2002 [string_of_int id]) ^ "[get_error_message.2002]  *")
	end
);
fun Ûget_messageİ ((arg as (Message msg)):MESSAGE) : string = (
	let	val {area:string, id:int, ...} = msg;
		val text = get_message_text arg;
		val number = string_of_int id;
	in	(get_error_message 2003 [number, area, text])
		handle Error _ => ("* " ^
			(get_error_message 2002 [string_of_int id]) ^ "[get_error_message.2002] *")
	end
);
=TEX
We arrange for PolyML automatically to format error reports
using the following function.
A simplistic coding here would process each space character
with a call on the Oppen formatting routine $space$ and each
other character with $addstring$, however this causes the
reader writer~\cite{DS/FMU/IED/DTD005} to output text having
capital letter~`Q's wrongly.  To avoid the reader writer
problem the characters are gathered together, spaces are
counted (via $p_int:PREV$) and non-spaces are assembled
(via $p_str:PREV$); then these gathered items are output.
=SML
fun Ûsetup_ppİ (():unit) : unit = (
	let
		fun error_pp (addstring, beginb, space, endb) (msg:MESSAGE) = (
			let
				datatype PREV	= p_str of string list
						| p_int of int;

				fun op_str nil = ()
				| op_str ss = addstring(implode(rev ss));

				fun aux (p_str ss) nil = op_str ss
				| aux (p_int n) nil = space(n, 0)
				| aux (p_str prev) (" " :: more) =
					(op_str prev; aux (p_int 1) more)
				| aux (p_str prev) (ch :: more) =
					aux (p_str(ch :: prev)) more
				| aux (p_int n) (" " :: more) =
					aux (p_int(n+1)) more
				| aux (p_int n) (ch :: more) =
					(space(n, 0); aux (p_str[ch]) more)
				;
			in
				beginb(0, false);
				aux (p_str nil) (explode(get_message msg));
				endb()
			end 
		);
	in
		PolyML.install_pp error_pp
	end
);
=TEX
\subsection{Support for Error Handling}
=SML
fun Ûdivertİ (exn : exn) (from : string) (to: string) (new_id:int) (new_inserters:(unit->string)list): 'a = (
	case exn of
		Fail (Message msg) => (
			raise Fail (Message(
	let	val {area, id, inserters} = msg;
	in	if area = from
		then {area=to, id=new_id, inserters = new_inserters}
		else msg
	end		))
		) | Other => raise Other
);
fun Ûlist_divertİ (exn : exn) (to : string)
	(triples :(string * int * ((unit -> string) list))list): 'a = (
	case exn of
		Fail (Message msg) => (
			raise Fail (Message(
	let	val {area, ...} = msg;
		fun aux [] = msg
		|  aux ((from, new_id, inserters)::rest) = (
			if area = from
			then {area=to, id=new_id, inserters = inserters}
			else aux rest
		);
	in	aux triples
	end		))
		) | Other => raise Other
);
fun Ûarea_ofİ ((Fail(Message {area, ...})) : exn) : string= area
|   area_of Other = raise Other;
fun Ûreraiseİ ((Fail(Message {area, id, inserters})) : exn) (new_area: string) : 'a = (
	raise (Fail(Message{area=new_area, id=id, inserters=inserters}))
)
|   reraise Other _ = raise Other;
fun Ûpass_onİ (e : exn) (fromnm : string) (tonm : string) : 'a = (
let 	val efrom = area_of e
in
	if efrom = fromnm
	then reraise e tonm
	else reraise e efrom
end);
=TEX
\subsection{Initialisation}
=SML
val _ = setup_pp();
=TEX
=SML
val Ûicl'error_initİ : unit -> unit = setup_pp;
=TEX
=SML
end; (* Of structure BasicError *)
open BasicError;
=TEX
\section{SYSTEM CONTROL}
=SML
structure ÛSystemControlİ : SystemControl = struct
=TEX
\subsection{Support Functions}
By including a check function even for the flags we
can handle all of the functions polymorphically.
=SML
type 'a ÛCONTROL_RECİ = {name:string, control:'a ref, default:unit->'a, check:'a -> bool};
=TEX
These functions are not performance critical, so we use
very simple table access algorithms:
=SML
fun Ûlookupİ (func_name : string) (table : 'a CONTROL_REC list) 
		(what : string) : 'a CONTROL_REC = (
	case table of
		(record as {name, ...}) :: rest => (
			if name = what
			then record
			else lookup func_name rest what
		) | [] => fail func_name 2011 [fn()=>what]
);
fun Ûnew_controlİ
	(func_name : string)
	(var : 'a CONTROL_REC list ref)
	(record as {name, ...}:'a CONTROL_REC) : unit = (
	if ((lookup "" (!var) name; true) handle Fail _ => false) 
	then	fail func_name 2010 [fn()=>name]
	else	(var := record :: (!var))
);
fun Ûset_controlİ
	(func_name : string)
	(var : 'a CONTROL_REC list ref)
	(name : string, value : 'a) : 'a = (
	let	val {name, control, check, ...} = lookup func_name (!var) name;
		val old = !control
	in	if (check value)
		then control := value
		else fail func_name 2012 [fn()=>name];
		old
	end
);
fun Ûreset_controlİ
	(func_name : string)
	(var : 'a CONTROL_REC list ref)
	(name : string)
	: 'a = (
	let	val {name, control, default, ...} = lookup func_name (!var) name
		val old = !control
	in	control := default();
		old
	end
);
fun Ûget_controlİ
	(func_name : string)
	(var : 'a CONTROL_REC list ref)
	(name : string)
	: 'a = (
	let	val {control,...} = lookup func_name (!var) name
	in	!control
	end
);
fun Ûget_controlsİ
	(func_name : string)
	(var : 'a CONTROL_REC list ref)
	(():unit) : (string * 'a) list = (
	map (fn {name, control, ...} => (name, !control)) (!var)
);
fun Ûset_controlsİ
	(func_name : string)
	(var : 'a CONTROL_REC list ref)
	(lst : (string * 'a) list) : unit = (
	map (set_control func_name var) lst;
	()
);
fun Ûreset_controlsİ
	(func_name : string)
	(var : 'a CONTROL_REC list ref)
	: unit = (
	map (fn {name,...} => reset_control func_name var name) (!var);
	()
);
=TEX
\subsection{State Variables}
=SML
	val Ûflagsİ : bool CONTROL_REC list ref = ref[];
	val Ûint_controlsİ : int CONTROL_REC list ref = ref[];
	val Ûstring_controlsİ : string CONTROL_REC list ref = ref[];
=TEX
\subsection{Visible Functions}
The function for introducing flags is the odd man out,
in that its parameter record does not have the $check$ field.
=SML
val Ûnew_flagİ : {name:string, control:bool ref, default:unit->bool, check:bool->bool} -> unit = (
	new_control
	"new_flag"
	flags
);
val Ûnew_int_controlİ : {name:string, control:int ref, default:unit->int, check:int->bool} -> unit
	 = new_control "new_int_control" int_controls;
val Ûnew_string_controlİ : 
	{name:string, control:string ref, default:unit->string, check:string->bool} -> unit
	 = new_control "new_string_control" string_controls;
val Ûset_flagİ : (string * bool) -> bool
	= set_control "set_flag" flags;
val Ûset_int_controlİ : (string * int) -> int
	 = set_control "set_int_control" int_controls;
val Ûset_string_controlİ : (string * string) -> string
	= set_control "set_string_control" string_controls;
val Ûreset_flagİ : string -> bool
	= reset_control "reset_flag" flags;
val Ûreset_int_controlİ : string -> int
	= reset_control "reset_int_control" int_controls;
val Ûreset_string_controlİ : string -> string
	= reset_control "reset_string_control" string_controls;
val Ûget_flagİ : string -> bool
	= get_control "get_flag" flags;
val Ûget_int_controlİ : string -> int
	= get_control "get_int_control" int_controls;
val Ûget_string_controlİ : string -> string
	= get_control "get_string_control" string_controls;
val Ûget_flagsİ : unit -> (string * bool) list
	= get_controls "get_flag" flags;
val Ûset_flagsİ : (string * bool) list -> unit
	= set_controls "set_flags" flags;
fun Ûreset_flagsİ (): unit
	= reset_controls "reset_flags" flags;
val Ûget_int_controlsİ : unit -> (string * int) list
	= get_controls "get_int_controls" int_controls;
val Ûset_int_controlsİ : (string * int) list -> unit
	= set_controls "set_int_controls" int_controls;
fun Ûreset_int_controlsİ (): unit
	= reset_controls "reset_int_controls" int_controls;
val Ûget_string_controlsİ : unit -> (string * string) list
	= get_controls "get_string_control" string_controls;
val Ûset_string_controlsİ : (string * string) list -> unit
	= set_controls "set_string_control" string_controls;
fun Ûreset_string_controlsİ (): unit
	= reset_controls "reset_string_controls" string_controls;
fun Ûget_controlsİ ((): unit)
	:	((string * bool) list *
		(string * int) list *
		(string * string) list) = (
	(get_flags(), get_int_controls(), get_string_controls())
);
fun Ûset_controlsİ (sf : (string * bool) list,
		si : (string * int) list,
		ss : (string * string) list): unit = (
	(set_flags sf, set_int_controls si, set_string_controls ss);
	()
);
fun Ûreset_controlsİ (): unit = (
	(reset_flags(), reset_int_controls(), reset_string_controls());
	()
);
=TEX
That completes the structure:
=SML
end; (* of structure SystemControl *)
open SystemControl;
=TEX
\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}


