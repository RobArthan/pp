% imp002.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of System Control and Basic Error Reporting}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP002}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the implementation of the
system control and basic
error reporting subsystem for the ICL HOL system.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library\\ R.D. Arthan\\ K. Blackburn}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1]
First draft for comment.
\item[Issue 1.4]
$set\_flag$ and associated functions changed, to return previous value of control variable.
\item [Issue 1.6]
Modified $new\_error\_message$ to only give an error if given a duplicate $id$, but also a differing $text$.
\item [Issue 1.11]
Added $pass\_on$.
\item [Issue 1.12 (4 July 1991)]
$new\_error\_message$ no longer raises exceptions.
\item [Issue 1.14 (\FormatDate{91/08/12%
})] Rework after inspection (ID0019) of DTD002.

\item[Issue 1.15, \FormatDate{92/01/20} ] Updated to use new fonts.

\item[Issue 1.16, \FormatDate{92/02/21} ] Error
messages are not contained in ``***'' anymore.

\item[Issue 1.18, \FormatDate{92/02/26} ] Minor
change to error message format.
Avoid use of $PolyML.makestring$ by adding $string_of_int$. {}
Make $setup_pp$ print error messages a word at a time.
\item[Issue 1.19 (14th December 1992)]
Changed to allow uniform saving of controls and error messages.

\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains part of the implementation of
the ICL HOL system.
\subsection{Introduction}
\subsubsection{Background and Purpose}
This document contains the implementation of the
material whose detailed design may be found in
\cite{DS/FMU/IED/DTD002}.
\subsection{Dependencies}
The use of $PolyML.install\_pp$
immediately after the definition of $give\_message$ is
also compiler-specific.
\subsection{Interface}
See \cite{DS/FMU/IED/DTD002}.
\subsection{Algorithms}
There are no complex algorithms in this document.
The most difficult problem is finding an interleaving
of the system control and error functions compatible
with declaration before use.
Since this structure is compiled before the utilities
defined in \cite{DS/FMU/IED/DTD001} it has to be self-sufficient
as regards table lookup algorithms etc.

\subsection{Possible Enhancements}
\subsection{Deficiencies}
\section{MINIMAL ERROR REPORTING}
\subsection{Preamble}
=SML
structure €BasicError› : BasicError = struct
=TEX
\subsection{Types}
=SML
datatype €MESSAGE› = €Message› of {area:string, id:int, inserters:(unit -> string) list};
=TEX
\subsection{Formatting Numbers}

Rather than use $PolyML.makestring$ we have
$string\_of\_int$ which converts an integer into a decimal
string. (SML's library function $makestring$ would
nearly do, but we want negative numbers to be shown
with a minus sign, and we do not want 
to be affected by $PolyML.print\-\_depth$ being set to 0.)

=SML
local
	val ord0 = ord "0"
in
fun €string_of_int› (n : int) : string = (
	let	fun aux m = ( (* assumes m > 0 *)
			case m div 10 of
				0 => chr(ord0 + (m mod 10))
			|	mdiv10 => aux mdiv10 ^ chr(ord0 + (m mod 10))
		);
	in	if n > 0
		then aux n
		else if n = 0
		then "0"
		else "-" ^ aux (~n)
	end
);
end;
=TEX

\subsection{Exceptions}
=SML
exception €Fail› of MESSAGE;
exception €Error› of MESSAGE;
=TEX
\subsection{Error Message Database}
The database is represented by an assignable variable
holding a table of identifier-entry pairs .
(Experiments show an average access time of 2msecs. (on a 
SPARC 1) to
do a look up in a table of 1000 entries. This seems
acceptable for an operation which is only performed when
an error message is actually printed.)
=SML
val €message_db› : {id:int, text:string} list ref = ref [];
=TEX
Some of the database access functions
can give rise to errors. None of these errors is recoverable
or trappable.
We therefore need the following simple function to raise errors.
=SML
fun €scream› (area : string) (msg : int) (inserts : string list): 'a = (
	raise (Error(Message({area=area, id=msg,
		inserters=map (fn x => (fn () => x))inserts})))
);
=TEX
=SML
fun €get_error_message› (id:int) (inserts:string list) : string = (
	let	fun aux1 ({id=id', text=text'} :: rest) = (
			if id' = id
			then text'
			else aux1 rest
		) | aux1 [] = scream "get_error_message" 2002 [string_of_int id];
		fun aux2 [] i = "?" ^ string_of_int i
		|   aux2 (h::t) i = (if i <= 0 then h else aux2 t (i-1));
		fun aux3 chs = (
			case chs of
				("?"::c::cs) => (
					if c = "?"
					then "?" :: aux3 cs
					else	let val num = ord c - ord "0"
						in	if num >= 0 andalso num <= 9
							then aux2 inserts num :: aux3 cs
							else "?" :: c :: aux3 cs
						end
			) |	c :: cs => (c :: aux3 cs
			) |	[] => []
		);
	in	implode(aux3(explode(aux1 (!message_db))))
	end
);
fun €new_error_message› (arg as {id:int, text: string}) : unit = (
	let	fun aux ((arg' as {id=id', text=text'}) :: rest) = (
			if id' = id
			then 	if text = text'
				then aux rest
				else let val msg = get_error_message 2001 [string_of_int id];
				in
	output(std_out, "* " ^ msg ^ "\n [new_error_message.2001] *");
					arg' :: rest
				end
			else arg' :: aux rest
		) | aux [] = [arg]
	in	message_db := aux(!message_db)
	end
);
fun €get_error_messages› () : {id:int, text:string} list = (
	!message_db
);
fun €set_error_messages› (lst : {id:int, text:string} list): unit = (
	map new_error_message lst;
	()
);
fun €icl'change_error_message› (arg as {id:int, text: string}) : unit = (
	let	fun aux ((arg' as {id=id', text=text'}) :: rest) = (
			if id' = id
			then arg :: rest
			else arg' :: aux rest
		) | aux [] = [arg]
	in	message_db := aux(!message_db)
	end
);
=TEX
\subsection{Simple Error Reporting 1}
=SML
fun €report› (area : string) (id : int) (inserters : (unit -> string) list) : MESSAGE = (
	Message ({
		area=area,
		id=id,
		inserters = inserters})
);
fun €fail› (area : string) (id : int) (inserters : (unit -> string) list) : 'a = (
	raise Fail(report area id inserters)
);
fun €error› (area : string) (id : int) (inserters : (unit -> string) list) : 'a = (
	raise Error(report area id inserters)
);
=TEX
\subsection{Printing Errors}

=SML
fun €get_message_text› (Message msg:MESSAGE) : string = (
	let	val {area:string, id:int, inserters:(unit->string)list} = msg;
		val inserts = map (fn f=> f())inserters;
	in	(get_error_message id inserts)
		handle Error _ => ("* " ^
			(get_error_message 2002 [string_of_int id]) ^ "[get_error_message.2002]  *")
	end
);
fun €get_message› ((arg as (Message msg)):MESSAGE) : string = (
	let	val {area:string, id:int, ...} = msg;
		val text = get_message_text arg;
		val number = string_of_int id;
	in	(get_error_message 2003 [number, area, text])
		handle Error _ => ("* " ^
			(get_error_message 2002 [string_of_int id]) ^ "[get_error_message.2002] *")
	end
);
=TEX
We arrange for PolyML automatically to format error reports
using the following function.
A simplistic coding here would process each space character
with a call on the Oppen formatting routine $space$ and each
other character with $addstring$, however this causes the
reader writer~\cite{DS/FMU/IED/DTD005} to output text having
capital letter~`Q's wrongly.  To avoid the reader writer
problem the characters are gathered together, spaces are
counted (via $p_int:PREV$) and non-spaces are assembled
(via $p_str:PREV$); then these gathered items are output.
=SML
fun €setup_pp› (():unit) : unit = (
	let
		fun error_pp (addstring, beginb, space, endb) (msg:MESSAGE) = (
			let
				datatype PREV	= p_str of string list
						| p_int of int;

				fun op_str nil = ()
				| op_str ss = addstring(implode(rev ss));

				fun aux (p_str ss) nil = op_str ss
				| aux (p_int n) nil = space(n, 0)
				| aux (p_str prev) (" " :: more) =
					(op_str prev; aux (p_int 1) more)
				| aux (p_str prev) (ch :: more) =
					aux (p_str(ch :: prev)) more
				| aux (p_int n) (" " :: more) =
					aux (p_int(n+1)) more
				| aux (p_int n) (ch :: more) =
					(space(n, 0); aux (p_str[ch]) more)
				;
			in
				beginb(0, false);
				aux (p_str nil) (explode(get_message msg));
				endb()
			end 
		);
	in
		PolyML.install_pp error_pp
	end
);
=TEX
\subsection{Support for Error Handling}
=SML
fun €divert› (exn : exn) (from : string) (to: string) (new_id:int) (new_inserters:(unit->string)list): 'a = (
	case exn of
		Fail (Message msg) => (
			raise Fail (Message(
	let	val {area, id, inserters} = msg;
	in	if area = from
		then {area=to, id=new_id, inserters = new_inserters}
		else msg
	end		))
		) | Other => raise Other
);
fun €list_divert› (exn : exn) (to : string)
	(triples :(string * int * ((unit -> string) list))list): 'a = (
	case exn of
		Fail (Message msg) => (
			raise Fail (Message(
	let	val {area, ...} = msg;
		fun aux [] = msg
		|  aux ((from, new_id, inserters)::rest) = (
			if area = from
			then {area=to, id=new_id, inserters = inserters}
			else aux rest
		);
	in	aux triples
	end		))
		) | Other => raise Other
);
fun €area_of› ((Fail(Message {area, ...})) : exn) : string= area
|   area_of Other = raise Other;
fun €reraise› ((Fail(Message {area, id, inserters})) : exn) (new_area: string) : 'a = (
	raise (Fail(Message{area=new_area, id=id, inserters=inserters}))
)
|   reraise Other _ = raise Other;
fun €pass_on› (e : exn) (fromnm : string) (tonm : string) : 'a = (
let 	val efrom = area_of e
in
	if efrom = fromnm
	then reraise e tonm
	else reraise e efrom
end);
=TEX
\subsection{Initialisation}
=SML
val _ = setup_pp();
=TEX
=SML
val €icl'error_init› : unit -> unit = setup_pp;
=TEX
=SML
end; (* Of structure BasicError *)
open BasicError;
=TEX
\section{SYSTEM CONTROL}
=SML
structure €SystemControl› : SystemControl = struct
=TEX
\subsection{Support Functions}
By including a check function even for the flags we
can handle all of the functions polymorphically.
=SML
type 'a €CONTROL_REC› = {name:string, control:'a ref, default:unit->'a, check:'a -> bool};
=TEX
These functions are not performance critical, so we use
very simple table access algorithms:
=SML
fun €lookup› (func_name : string) (table : 'a CONTROL_REC list) 
		(what : string) : 'a CONTROL_REC = (
	case table of
		(record as {name, ...}) :: rest => (
			if name = what
			then record
			else lookup func_name rest what
		) | [] => fail func_name 2011 [fn()=>what]
);
fun €new_control›
	(func_name : string)
	(var : 'a CONTROL_REC list ref)
	(record as {name, ...}:'a CONTROL_REC) : unit = (
	if ((lookup "" (!var) name; true) handle Fail _ => false) 
	then	fail func_name 2010 [fn()=>name]
	else	(var := record :: (!var))
);
fun €set_control›
	(func_name : string)
	(var : 'a CONTROL_REC list ref)
	(name : string, value : 'a) : 'a = (
	let	val {name, control, check, ...} = lookup func_name (!var) name;
		val old = !control
	in	if (check value)
		then control := value
		else fail func_name 2012 [fn()=>name];
		old
	end
);
fun €reset_control›
	(func_name : string)
	(var : 'a CONTROL_REC list ref)
	(name : string)
	: 'a = (
	let	val {name, control, default, ...} = lookup func_name (!var) name
		val old = !control
	in	control := default();
		old
	end
);
fun €get_control›
	(func_name : string)
	(var : 'a CONTROL_REC list ref)
	(name : string)
	: 'a = (
	let	val {control,...} = lookup func_name (!var) name
	in	!control
	end
);
fun €get_controls›
	(func_name : string)
	(var : 'a CONTROL_REC list ref)
	(():unit) : (string * 'a) list = (
	map (fn {name, control, ...} => (name, !control)) (!var)
);
fun €set_controls›
	(func_name : string)
	(var : 'a CONTROL_REC list ref)
	(lst : (string * 'a) list) : unit = (
	map (set_control func_name var) lst;
	()
);
fun €reset_controls›
	(func_name : string)
	(var : 'a CONTROL_REC list ref)
	: unit = (
	map (fn {name,...} => reset_control func_name var name) (!var);
	()
);
=TEX
\subsection{State Variables}
=SML
	val €flags› : bool CONTROL_REC list ref = ref[];
	val €int_controls› : int CONTROL_REC list ref = ref[];
	val €string_controls› : string CONTROL_REC list ref = ref[];
=TEX
\subsection{Visible Functions}
The function for introducing flags is the odd man out,
in that its parameter record does not have the $check$ field.
=SML
val €new_flag› : {name:string, control:bool ref, default:unit->bool, check:bool->bool} -> unit = (
	new_control
	"new_flag"
	flags
);
val €new_int_control› : {name:string, control:int ref, default:unit->int, check:int->bool} -> unit
	 = new_control "new_int_control" int_controls;
val €new_string_control› : 
	{name:string, control:string ref, default:unit->string, check:string->bool} -> unit
	 = new_control "new_string_control" string_controls;
val €set_flag› : (string * bool) -> bool
	= set_control "set_flag" flags;
val €set_int_control› : (string * int) -> int
	 = set_control "set_int_control" int_controls;
val €set_string_control› : (string * string) -> string
	= set_control "set_string_control" string_controls;
val €reset_flag› : string -> bool
	= reset_control "reset_flag" flags;
val €reset_int_control› : string -> int
	= reset_control "reset_int_control" int_controls;
val €reset_string_control› : string -> string
	= reset_control "reset_string_control" string_controls;
val €get_flag› : string -> bool
	= get_control "get_flag" flags;
val €get_int_control› : string -> int
	= get_control "get_int_control" int_controls;
val €get_string_control› : string -> string
	= get_control "get_string_control" string_controls;
val €get_flags› : unit -> (string * bool) list
	= get_controls "get_flag" flags;
val €set_flags› : (string * bool) list -> unit
	= set_controls "set_flags" flags;
fun €reset_flags› (): unit
	= reset_controls "reset_flags" flags;
val €get_int_controls› : unit -> (string * int) list
	= get_controls "get_int_controls" int_controls;
val €set_int_controls› : (string * int) list -> unit
	= set_controls "set_int_controls" int_controls;
fun €reset_int_controls› (): unit
	= reset_controls "reset_int_controls" int_controls;
val €get_string_controls› : unit -> (string * string) list
	= get_controls "get_string_control" string_controls;
val €set_string_controls› : (string * string) list -> unit
	= set_controls "set_string_control" string_controls;
fun €reset_string_controls› (): unit
	= reset_controls "reset_string_controls" string_controls;
fun €get_controls› ((): unit)
	:	((string * bool) list *
		(string * int) list *
		(string * string) list) = (
	(get_flags(), get_int_controls(), get_string_controls())
);
fun €set_controls› (sf : (string * bool) list,
		si : (string * int) list,
		ss : (string * string) list): unit = (
	(set_flags sf, set_int_controls si, set_string_controls ss);
	()
);
fun €reset_controls› (): unit = (
	(reset_flags(), reset_int_controls(), reset_string_controls());
	()
);
=TEX
That completes the structure:
=SML
end; (* of structure SystemControl *)
open SystemControl;
=TEX
\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}


