%  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Porting Strategy and Portability Infrastructure Detailed Design}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD108}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Draft}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & Lemma 1}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & Lemma 1}
\TPPabstract{This document defines the strategy for the port of {\Product} to SML'97 and gives the detailed design of the infrastructure to support the porting exercise.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Project Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issues 1.1-1.6]
Initial versions.
\end{description}
\subsection{Changes Forecast}
As determined by experience during the porting process.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Under contract CSM/927 with DERA Malvern, Lemma 1 Ltd. are undertaking a port of {\Product}
onto New Jersey ML v1.10. The technical background and requirements for
this work are discussed in the proposal \cite{LEMMA1/DAZ/PLN018}.

This document describes the strategy for this port and gives the design
of some new infrastructure which is intended to support the porting work.
This infrastructure offers a compiler-independent interface to the non-standard
compiler features needed by {\Product}.

\subsection{Introduction}

%\subsection{Purpose and Background}
See the proposal \cite{LEMMA1/DAZ/PLN018} for background and requirements.

%\subsection{Dependencies}

%\subsection{Possible Enhancements}

%\subsection{Deficiencies}

\section{Strategy}
\subsection{Standard ML Language Changes}
General guidelines for conversion from SML'90 to SML'97 are given
in the ``SML'97 Conversion Guide'' that is supplied with NJML.
In particular, the section ``Top Level Environment Comparison'' gives a useful
table.
The portability infrastructure whose design is given in section~\ref{Infrastructure} of this document covers many of the differences.
The basic idea behind this infrastructure as regards the language and basis changes is to reproduce the SML'90 facilities expected by the {\Product} code using the SML'97 ones.


\subsection{Conditional Compilation}
The {\Product} ML code is packaged in literate scripts.
The {\tt docsml} shell script is used to extract the ML source from the scripts.
{\tt docsml} decides which material to include in the source on the basis of a configuration file called the ``sieve view file''.

Where minor adjustments need to be made to the code, alternative sieve view files will be used to distinguish between the Poly/ML and NJML variants.
The directives used will be ``{\tt =POLYML}'' and ``{\tt =NJML}''' respectively.
The rules will be that code marked ``{\tt =SML}'' will be common to both
compilers whereas code marked for a particular compiler will be produced
for that compiler only.

Where the changes to a module are greater than can be accomodated with
the sieve view file mechanism, an alternate source file will be derived
for the NJML compiler. The build process will select the right version
based on the target compiler.

A sieve file ``hol.svf'' is available for initial  experimentation
in the IED SCCS directory.
A convenient way of doing a test build is to include a symbolic link
called ``sieveview'' to this file.


\section{Portability Infrastructure}\label{Infrastructure}
\subsection{Input/Output}
The SML'97 I/O features are richer than those of SML'90. Unfortunately,
the elementary features that are needed for {\tt Product} have been
renamed. The approach for the port is to implement the SML'90 interface
in terms of the SML'97 interface.
=DOC
signature ÛBasicIOÝ = sig
	type ÛinstreamÝ;
	type ÛoutstreamÝ;
	exception ÛIoÝ of {cause:exn, function:string, name:string}
	val Ûclose_inÝ : instream -> unit
	val Ûclose_outÝ : outstream -> unit
	val Ûend_of_streamÝ : instream -> bool
	val ÛinputÝ : instream * int -> string
	val ÛlookaheadÝ : instream -> string
	val Ûopen_inÝ : string -> instream
	val Ûopen_outÝ : string -> outstream
	val ÛoutputÝ : outstream * string -> unit
	val Ûstd_inÝ : instream
	val Ûstd_outÝ : outstream
end;
signature ÛExtendedIOÝ = sig
	type ÛinstreamÝ;
	type ÛoutstreamÝ;
	val Ûcan_inputÝ : instream * int -> bool
	val Ûflush_outÝ : outstream -> unit
	val Ûopen_appendÝ : string -> outstream
	val Ûis_term_inÝ : instream -> bool
	val ÛexecuteÝ : string -> instream * outstream
	val Ûinput_lineÝ : instream -> string
	val Ûis_term_outÝ : outstream -> bool
end;
=DESCRIBE
These are the signatures of the structures that implement SML'90-style I/O.
=INLINEFT
BasicIO
=TEX
\ is open.
=INLINEFT
ExtendedIO
=TEX
\ is not.
=ENDDOC

\subsection{Compiler Interface}
At V0.8, {\Product} uses the PolyML interface to invoke the compiler.
=GFT
	 PolyML.compiler : (unit -> string) * (string -> unit) -> unit -> unit
=TEX
The call:
=GFT
	 PolyML.compiler (infunc : unit -> string, outfunc : string -> unit)()
=TEX
invokes the compiler using $infunc$ to obtain input and $outfunc$ to
process compiler output. In fact, $PolyML.compiler$ only reads the
first top-level binding from the input obtained from $infunc$.
So for example:
=GFT
	 PolyML.compiler (fn () => "val x = 1; val y = 2", ...
=TEX
will not process the binding for $y$. To resolve this the V0.8 Reader/Writer
module in \cite{DS/FMU/IED/DTD005} in effect calls PolyML.compiler in
a while-loop. This approach does not port very well and so must change
during the present exercise.
However, in all cases (whether reading source from a string, from a file or
from a terminal), the Reader/Writer reads all of its input stream.

In NJML, the function giving access to the compiler is:
=GFT
	Compiler.Interact.useStream : TextIO.instream -> unit
=TEX
This is given an input stream as its parameter and causes the compiler
to process all the input in the stream. Since that is just what we want
to do in the Reader/Writer a portability interface based on streams
could be provided. However, the SML'90 I/O package does not provide a
means of generating a stream from a string (for example). We therefore
settle for the following design:

=DOC
signature ÛPPCompilerÝ = sig
	type instream;
	type ÛTEXT_SOURCEÝ (* = unit -> string *);
	type ÛTEXT_FILTERÝ (* = string -> string *);
	type ÛHANDLERÝ (* = exn -> unit *)
	val Ûcompile1Ý : string * TEXT_SOURCE * TEXT_FILTER * HANDLER -> unit;
	val Ûcompile2Ý : instream * TEXT_SOURCE * TEXT_FILTER * HANDLER -> unit;
	val ÛexitÝ : int -> unit;
	val Ûprint_depthÝ : int -> unit;
	type 'a ÛPP_SPECÝ; (* = compiler-dependent *)
	val Ûmake_ppÝ :
		string list ->
		((string -> unit) * (int * bool -> unit)
			* (int * int -> unit) * (unit -> unit) -> 'a -> unit)
				-> 'a PP_SPEC;
	val Ûinstall_ppÝ : 'a PP_SPEC -> unit;
end; 
=DESCRIBE
This is the signature of a structure that provides interfaces to 
the underlying Standard ML compiler.
This by-passes the pre- and post-processing carried out by the
{\Product} Reader/Writer interface and is only intended for use
by those extending the system in quite radical ways.
The components of the parameter to
=INLINEFT
PPCompiler.compile1
=TEX
\ are: a string that may be used to identify the origin of the ML source code
in compiler error messages, a function to obtain source code, a function to preprocess compiler messages before they are output and a function to handle
any exceptions generated.
Source is read repeatedly until the source function returns an empty string.
It is therefore that function's responsibility to wait if no input is
available, but input may become available later.

=INLINEFT
PPCompiler.compile2
=TEX
\ is very similar to
=INLINEFT
PPCompiler.compile1
=TEX
\ and should be used where the text source is actually associated with
a file or other input stream. It does not read the data from the stream
directly, it uses the source function passed as the second component
of the parameter to do that. However, it does attempt to pass the attributes
of the input stream into the underlying ML compiler interfaces where they
may be used to identify the origin of the ML source code in error messages.

$exit$ finishes a session returning the integer parameter value as an exit
status to the operating environment.

$print\_depth$ is intended to control the depth to which the values of top-level
expressions are traversed when they are pretty-printed.

The type $PP\_SPEC$ is the type of the parameter to the underlying function which installs a user defined pretty-printer. $make\_pp$ produces an appropriate value of this type given the path name of the type to be printed and an Oppen-style pretty-printing function for that type. The directive ``=INSTALLPP'' may be used to produce the name of the pretty-printer installation function.
Direct use of $install\_pp$ will not be portable.
=ENDDOC
$exit$ finishes a session returning the integer parameter value as an exit
status to the operating environment.

$print\_depth$ is intended to control the depth to which the values of top-level
expressions are traversed when they are pretty-printed.

The type $PP\_SPEC$ is the type of the parameter to the underlying function which installs a user defined pretty-printer. $make\_pp$ produces an appropriate value of this type given the path name of the type to be printed and an Oppen-style pretty-printing function for that type. The directive ``=INSTALLPP'' may be used to produce the name of the pretty-printer installation function.
Direct use of $install\_pp$ will not be portable.
=ENDDOC
\subsection{Build Interfaces}
=DOC
signature ÛPPBuildÝ = sig
	val Ûpp'save_nameÝ : string ref;
	val Ûpp'set_useÝ : (string -> unit) -> (string -> unit);
	val Ûpp'useÝ : string -> unit;
	val Ûpp'loadÝ : string -> bool;
	val Ûpp'saveÝ : unit -> bool;
end; 
=DESCRIBE
This is the signature of a structure that provides interfaces to 
the underlying Standard ML compilation system used to build {\Product}.

$pp'use$ is a command for loading a file without saving the state.
This is initially set to use the compiler's native comand for doing this.
It may subsequently changed using $pp'set\_use$.

$pp'save$ is the compiler's native command for saving its state
to filestore; on compilers that need it (e.g., NJML), $pp'save\_name$
gives any parameter needed by the function underlying $pp'save$.

$pp'load$ loads a file using $pp'use$ and then saves the state using $pp'save$.

=ENDDOC

\subsection{String Processing}
=DOC
signature ÛPPStringÝ = sig
	val implode : string list -> string;
	val explode : string -> string list;
	exception Ord;
	val ord : string -> int; 
	val chr : int -> string;
	val string_of_exn : exn -> string;
end; 
=DESCRIBE
This is the signature of an open structure that provides string functions
compatible with the {\Product} code (independent of the underlying compiler).
=ENDDOC

\subsection{Array Processing}
=DOC
signature ÛPPArrayÝ = sig
	exception Subscript
	type 'a array
	val arrayoflist: '_a list -> '_a array
	val array : int * '_a -> '_a array
	val length  : 'a array -> int
	val sub : 'a array * int -> 'a
	val tabulate : int * (int -> '_a) -> '_a array
	val update : 'a array * int * 'a -> unit
end; 
=DESCRIBE
This is the signature of an open structure that provides an array datatype
compatible with the {\Product} code (independent of the underlying compiler).
=ENDDOC

\subsection{Vector Processing}
=DOC
signature ÛPPVectorÝ = sig
	exception Subscript
	exception Size
	type '_a vector
	val vector: '_a list -> '_a vector
	val length  : 'a vector -> int
	val sub : 'a vector * int -> 'a
	val tabulate : int * (int -> '_a) -> '_a vector
end; 
=DESCRIBE
This is the signature of an open structure that provides a vector (read-only array) datatype
compatible with the {\Product} code (independent of the underlying compiler).
=ENDDOC

\subsection{Arithmetic}


\section{TEST POLICY}
The module tests for these modules are to follow the guidelines
laid down in the quality plan~\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}


