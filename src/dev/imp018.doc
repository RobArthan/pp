=IGN
********************************************************************************
imp018.doc: this file is part of the PPDev system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{SLR Parser Driver}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP018}  %% Mandatory field
\def\SCCSversion{$Revision: 1.15 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the implementation of the driver program the
detailed design of which is given in DS/FMU/IED/DTD018.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue 1.9-1.10, \FormatDate{91/05/16} ] First drafts for comment.

\item[Issue 1.10, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.11, \FormatDate{92/02/04} ] Changed
the error handling to enable error recovery to be
attempted in error handlers. Also changed $diag\_line$ to
$raw\_diag\_line$.

\item[Issue 1.12, \FormatDate{92/02/04} ] Removed
signature constraint on $SlrpDriver$.
\item[Issue 1.13] Bug-fix.
\item[Issue 1.14 (8th February 1998)] Updates for SML'97.
\item[Issue 1.15] Copyright and banner updates for open source release.
\item[Issue 1.16] PPDev-specific updates for open source release
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a defines a structure which is intended
for inclusion in parsers generated by the SLR parser generator
defined in \cite{DS/FMU/IED/DTD017}.
The detailed design for this structure is given in \cite{DS/FMU/IED/DTD018}.
\subsection{Introduction}
\subsection{Purpose and Background}
\subsection{Dependencies}
The code depends on the utilities defined in \cite{DS/FMU/IED/DTD001}.
\subsection{Possible Enhancements}
\subsection{Deficiencies}
None known.
\section{UTILITIES}
This structure has no signature constraint because it
is to be used in a context where the signature is
unavailable.
=SML
structure ÛSlrpDriverÝ = struct
=TEX
We use (a very few) functions from the functional
toolkit defined in \cite{DS/FMU/IED/DTD002}. 
=SML
open EfficientDictionary;
=TEX
=SML
exception ÛSLRP_ERRORÝ of string;
=TEX
=SML
fun ÛboundÝ list = length list - 1;
=TEX
\section{DATA TYPES FOR THE DRIVER}
We differ slightly from \cite{Aho77} in that we work with two stacks, one
for states and one for partially parsed input.
The state stack is just a list of numbers.
=SML
type ÛSTATEÝ = int;
type ÛSTATE_STACKÝ = STATE list;
=TEX
The partially parsed input stack contains entries of the following
type, $'tok$ being the type of the input token stream,
$'lc$ being the type of the lexical classes used, and $'pp$ being
the type preduced when a phrase is reduced.
=SML
datatype ('tok, 'lc, 'pp) ÛINPUT_STACK_ITEMÝ = Token of 'tok * 'lc | Parsed of 'pp;
=TEX
An $INPUT\_STACK$ is just a list of $INPUT\_STACK\_ITEM$s.
=SML
type('tok, 'lc, 'pp) ÛINPUT_STACKÝ = ('tok, 'lc, 'pp) INPUT_STACK_ITEM list;
=TEX
As in \cite{Aho77}, an action takes one of the following four options:

\begin{enumerate}
\item
Shift into a given state, $s$
\item
Reduce by some alternative, $\beta$, for the nonterminal $A$. This means
that the top most $n$ items, where $n$ is the length of the alternative $\beta$
have been recognised as an $A$. In our case this means that $n$ items
are popped from the input stack and some user-defined
code is invoked to compute a $'pp$, say $A$, from them, which is then
pushed (as $Parsed\,A$) back on the stack.
\item
Accept. I.e. Parsing has finished.
The input stack now contains a single $'pp$ which is the desired result.
\item
Error. The input to be parsed is invalid.
\end{enumerate}

Actions are encoded in the following datatype, in which we assume that the
user-defined reduction code may be accessed by the name of the non-terminal, $A$,
together with the index of the alternative, $\beta$ and in which we also
record the number of symbols to reduce by in the reduce case.
Note that as in \cite{Aho77} the parts of the goto tables concerned
with terminal symbols (i.e. lexical classes) are held in the shift
actions.
The ``dynamic'' option is for a shift/reduce conflict which is to be
resolved during parsing by a user-defined routine.
=SML
datatype ÛACTIONÝ	= ÛShiftÝ of STATE
			| ÛReduceÝ of ((string * int) * int)
			| ÛDynamicÝ of STATE * ((string * int) * int)
			| ÛAcceptÝ
			| ÛErrorÝ;
=TEX
The action tables described in \cite{Aho77} are two-dimensional arrays
indexed by states and lexical classes.
The action tables with which we work are held as one-dimensional
arrays of lists of lexical class-(action-state pair) pairs.
If the state index for these tables is out of range it is a design error.
User error entries correspond to valid state indices for which the
lexical class in question is not represented.
=SML
type ('lc)ÛACTION_TABLEÝ =  ('lc * ACTION) list PPArray.array;
=TEX
Similarly the goto tables (for the non-terminal symbols) are held
in a one-dimensional array of pairs each comprising a non-terminal name and a
state.
It is a design error if an invalid index pair is supplied for these tables.
=SML
type ÛGOTO_TABLEÝ = (string * STATE) list PPArray.array;
=TEX
We assume that the user-defined reduction code (indexed by non-terminal
names and alternative indices) is held in a table of the following type.
(This could be made more efficient if we represented non-terminals as
numeric offsets rather than by there names.)
=SML
type ('tok, 'lc, 'pp)ÛREDUCTION_TABLEÝ =
	(('tok, 'lc, 'pp)INPUT_STACK -> 'pp) list E_DICT;
=TEX
The user-defined dynamic conflict resolver takes an input stack and the
reduction information
contained in the dynamic action and returns a value 
of the following type indicating
whether the parser should shift, reduce or report an error:
=SML
datatype ÛRESOLUTIONÝ	= ÛDoShiftÝ
			| ÛDoReduceÝ
			| ÛDoErrorÝ;
=TEX
Thus the resolver has the following type.
=SML
type ('tok, 'lc, 'pp)ÛRESOLVERÝ =
	('tok * 'lc) * ('tok, 'lc, 'pp)INPUT_STACK * ((string * int) * int) -> RESOLUTION;
=TEX
We assume that a functions of the following types are available
to give the lexical class of an input token, to handle errors
and to generate the input stream.
=SML
type ('tok, 'lc)ÛCLASSIFIERÝ = 'tok -> 'lc;
type ('tok, 'lc, 'pp, 'st)ÛERROR_ROUTINEÝ =
	'tok * ('tok, 'lc, 'pp)INPUT_STACK * STATE_STACK * 'st -> ('tok*'st);
type ('tok, 'st)ÛREADERÝ = 'st -> ('tok * 'st);
=TEX
\section{THE DRIVER}
The following two exceptions may be raised by the driver. $SYNTAX\_ERROR$
is raised if an error in the input has been detected and passed to the
error routine and the error routine has not raised an exception.
$PARSER\_ERROR$ ``should not happen'': it indicates an error in the driver
or its tables.
=SML
exception ÛSYNTAX_ERRORÝ;
exception ÛPARSER_ERRORÝ of string;
local
	fun Ûget_actionÝ (actions : (''lc)ACTION_TABLE) (s:STATE) (lc:''lc) : ACTION = (
	(let	open PPArray
	in	lassoc3 (sub(actions, s)) lc
	end	handle Fail _ => Error)
	handle PPArray.Subscript => raise PARSER_ERROR "invalid state"
	);
in	fun Ûlookup_actionÝ
		(resolver : ('tok, ''lc, 'pp)RESOLVER)
		(actions : (''lc)ACTION_TABLE)
		(tok : 'tok)
		(stk : ('tok, ''lc, 'pp)INPUT_STACK)
		(s : STATE)
		(lc : ''lc) : ACTION = (
		case get_action actions s lc of
			Dynamic (s', altsymn) => (
				case resolver((tok, lc), stk, altsymn) of
					DoShift => Shift s'
				|	DoReduce => Reduce altsymn
				|	DoError => Error
			) |	easy => easy
	);
end;
=TEX
=SML
fun Ûlookup_gotoÝ (gotos : GOTO_TABLE) (s:STATE) (nt : string) : STATE = (
	(let	open PPArray
	in	lassoc3 (sub(gotos, s)) nt
	end	handle Fail _ => raise PARSER_ERROR "invalid non-terminal")
	handle PPArray.Subscript => raise PARSER_ERROR "invalid state"

);
=TEX
=SML
fun Ûlookup_reducerÝ (reducers : ('tok, ''lc, 'pp)REDUCTION_TABLE)
		(nt:string) (alt : int) : ('tok, ''lc, 'pp)INPUT_STACK -> 'pp = (
	case e_lookup nt reducers of
		Value tab => nth alt tab
	|	Nil  => raise PARSER_ERROR "invalid non-terminal/alternative"
);
=TEX
=SML
fun Ûslrp'parseÝ
	(s0 : STATE)
	(actions : (''lc)ACTION_TABLE)
	(gotos : GOTO_TABLE)
	(reducers : ('tok, ''lc, 'pp)REDUCTION_TABLE)
	(resolver : ('tok, ''lc, 'pp) RESOLVER)
	(classify : ('tok, ''lc)CLASSIFIER)
	(error : ('tok, ''lc, 'pp, 'st)ERROR_ROUTINE)
	(reader : ('tok, 'st) READER) : 'st -> 'pp = (
	let	open PPArray;
		val init_ss = [s0];
		val init_is = [];
		val fetch_action = lookup_action resolver actions;
		val fetch_reducer = lookup_reducer reducers;
		val fetch_goto = lookup_goto gotos;
		fun go (tok, st) = (fn (ss, is) =>
			let	val lc = classify tok;
				val s = hd ss;
			in	case fetch_action tok is s lc of 
					Shift s' => go (reader st)((s' :: ss), Token(tok, lc) :: is)
				|	Reduce((nt, alt), r) => (
						let	val reducer = fetch_reducer nt alt;
							val A = reducer is;
							val ss' = ss from r;
							val is' = is from r;
							val s' = fetch_goto (hd ss') nt;
						in go (tok, st) (s' :: ss', Parsed A :: is')
						end
				) |	Accept => ((ss, is)
				) |	Error =>(
					go (error (tok, is, ss, st)) (ss, is)
				) |	Dynamic _ => (
					raise PARSER_ERROR "conflict resolution error"
				)
			end
		);
	in
		(fn st => (
			case go (reader st) (init_ss, init_is)of
				(_, [Parsed res]) => res
			|	_ => raise PARSER_ERROR "stacks corrupt at end of parse"))
	end
);
=TEX
\section{AUXILIARIES FOR USER CODE}
In this section we define functions which support the user in defining
error handling and conflict resolution functions.
=SML
fun Ûformat_stackÝ (do_tok : 'tok -> string)(stk : ('tok, 'lc, 'pp)INPUT_STACK) : string = (
	format_list (fn Token (tk, _) => do_tok tk | _ => "...") (rev stk) " "
);
=TEX
The default error routine is parameterised by functions to print input
tokens:
=SML
fun Ûdefault_errorÝ
	(do_tok : 'tok -> string)
	(tok: 'tok, stk : ('tok, 'lc, 'pp)INPUT_STACK, _ : STATE_STACK, st : 'st) : ('tok*'st) = (
	raw_diag_line("*** ERROR Syntax error ***");
	if any stk (fn Token _ => true | _ => false)
	then raw_diag_line(do_tok tok ^ " not expected after: " ^ format_stack do_tok stk)
	else raw_diag_line(do_tok tok ^ " not expected here");
	raise SYNTAX_ERROR; (tok, st)
);
=TEX
The default resolver is one which raises $PARSER\_ERROR$ if it is called.
It is intended for use when there are no conflicts.
=SML
val (Ûdefault_resolverÝ : ('tok, 'lc, 'pp)RESOLVER) = (fn _ =>
	raise PARSER_ERROR "shift/reduce conflict"
);
=TEX
For grammars which do contain shift/reduce conflicts the commonest form of
conflict resolution simply compares the latest input token with the topmost
token on the stack. $simple\_resolver$ helps the user define such a
resolver. Its argument is a function which compares two tokens (which
are given as a pair in input order, i.e. the latest input token comes second).
The resulting resolver will report a syntax error if there are no tokens
on the stack, a situation which corresponds, for example, to an input whose
first symbol is an infix operator.
=SML
fun Ûsimple_resolverÝ (prec : (('tok * 'lc) * ('tok * 'lc)) -> RESOLUTION)
		: ('tok, 'lc, 'pp)RESOLVER = (fn (toklc, stk, ignored) =>
	case stk of
		Token toklc' :: _ => prec (toklc', toklc)
	|	_ :: more => simple_resolver prec (toklc, more, ignored)
	|	[] => DoError
);
=TEX
=SML
end; (* of structure SlrpDriver *)
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}


