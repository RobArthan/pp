=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{SLR Parser Driver}  %% Mandatory field
\TPPref{DS/FMU/IED/??}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywo	rds{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the driver program which is
used in conjunction with the
 simple SLR parser generator defined in DS/FMU/IED/???.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion (\FormatDate{$Date$%
})]
First draft for comment.
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a fragment of code which is intended
for inclusion in parsers generated by the SLR parser generator
defined in \cite{DS/FMU/IED/???}.
\subsection{Introduction}
\subsection{Purpose and Background}
\subsection{Dependencies}
\subsection{Interface}
=SML
signature icl'SlrpDriver = sig
exception SYNTAX_ERROR;
exception PARSER_ERROR of string;
eqtype STATE;
eqtype STATE_STACK;
datatype ('tok, 'lc, 'pp) INPUT_STACK_ITEM = Token of 'tok * 'lc | Parsed of 'pp;

type('tok, 'lc, 'pp) INPUT_STACK
 (* = ('tok, 'lc, 'pp) INPUT_STACK_ITEM list *);

datatype ACTION	= Shift of STATE
		| Reduce of ((string * int) * int)
		| Dynamic of STATE * ((string * int) * int)
		| Accept
		| Error;

type ('lc)ACTION_TABLE  (* =  ('lc * ACTION) list Array.array *);

type GOTO_TABLE (* = (string * STATE) list Array.array *);

type ('tok, 'lc, 'pp)REDUCTION_TABLE
	(* = (('tok, 'lc, 'pp)INPUT_STACK -> 'pp) list E_DICT *);

datatype RESOLUTION	= DoShift
			| DoReduce
			| DoError;

type ('tok, 'lc, 'pp)RESOLVER 
(* = 	('tok * 'lc) * ('tok, 'lc, 'pp)INPUT_STACK * ((string * int) * int) -> RESOLUTION *);

type ('tok, 'lc)CLASSIFIER (* = 'tok -> 'lc *);

type ('tok, 'lc, 'pp)ERROR_ROUTINE
 (* = 'tok * ('tok, 'lc, 'pp)INPUT_STACK * STATE_STACK -> unit *);

val default_error:
	('tok -> string) -> 'tok * ('tok, 'lc, 'pp) INPUT_STACK * STATE_STACK -> unit;

val simple_resolver:
	(('tok * 'lc) * ('tok * 'lc) -> RESOLUTION) -> ('tok, 'lc, 'pp) RESOLVER;

val default_resolver: ('tok, 'lc, 'pp) RESOLVER;

val format_stack : ('tok -> string) -> ('tok, 'lc, 'pp)INPUT_STACK -> string;

val slrp'parse:
	STATE ->
	''lc ACTION_TABLE ->
	GOTO_TABLE ->
	(''tok, ''lc, 'pp) REDUCTION_TABLE ->
	(''tok, ''lc, 'pp) RESOLVER ->
	(''tok, ''lc) CLASSIFIER ->
	(''tok, ''lc, 'pp) ERROR_ROUTINE -> (unit -> ''tok) -> 'pp;
end;
=TEX
\subsection{Possible Enhancements}
\subsection{Deficiencies}
\section{UTILITIES}
=TEX
=SML
structure icl'SlrpDriver : icl'SlrpDriver= struct
=TEX
=SML
open EfficientDictionary;
=TEX
=SML
exception SLRP_ERROR of string;
=TEX
=SML
val my_nth : 'a list -> int -> 'a = switch nth;
=TEX
=SML
val alpha_sort = Sort.sort Sort.stringorder;
=TEX
=SML
fun bound list = length list - 1;
=TEX
=SML
fun chat msg = (diag_line msg);
=TEX
=SML
fun indices (list : ''a list) (what : ''a) = (
	let	fun aux n (a :: more) = (
			if a = what
			then n :: aux (n+1) more
			else aux (n+1) more
		) | aux _ _ = [];
	in	aux 0 list
	end
);
=TEX
\section{DATA TYPES FOR THE DRIVER}
We differ slightly from \cite{Aho86} in that we work with two stacks, one
for states and one for partially parsed input.
The state stack is just a list of numbers.
=SML
type STATE = int;
type STATE_STACK = STATE list;
=TEX
The partially parsed input stack contains entries of the following
type, $'tok$ being the type of the input token stream,
$'lc$ being the type of the lexical classes used, and $'pp$ being
the type preduced when a phrase is reduced.
=SML
datatype ('tok, 'lc, 'pp) INPUT_STACK_ITEM = Token of 'tok * 'lc | Parsed of 'pp;
=TEX
An $INPUT\_STACK$ is just a list of $INPUT\_STACK\_ITEM$s.
=SML
type('tok, 'lc, 'pp) INPUT_STACK = ('tok, 'lc, 'pp) INPUT_STACK_ITEM list;
=TEX
As in \cite{Aho86}, an action takes one of the following four options:

\begin{enumerate}
\item
Shift into a given state, $s$
\item
Reduce by some alternative, $\beta$, for the nonterminal $A$. This means
that the top most $n$ items, where $n$ is the length of the alternative $\beta$
have been recognised as an $A$. In our case this means that $n$ items
are popped from the input stack and some user-defined
code is invoked to compute a $'pp$, say $A$, from them, which is then
pushed (as $Parsed\,A$) back on the stack.
\item
Accept. I.e. Parsing has finished.
The input stack now contains a single $'pp$ which is the desired result.
\item
Error. The input to be parsed is invalid.
\end{enumerate}

Actions are encoded in the following datatype, in which we assume that the
user-defined reduction code may be accessed by the name of the non-terminal, $A$,
together with the index of the alternative, $\beta$ and in which we also
record the number of symbols to reduce by in the reduce case.
Note that as in \cite{Aho86} the parts of the goto tables concerned
with terminal symbols (i.e. lexical classes) are held in the shift
actions.
The ``dynamic'' option is for a shift/reduce conflict which is to be
resolved during parsing by a user-defined routine.
=SML
datatype ACTION	= Shift of STATE
		| Reduce of ((string * int) * int)
		| Dynamic of STATE * ((string * int) * int)
		| Accept
		| Error;
=TEX
The action tables described in \cite{Aho86} are two-dimensional arrays
indexed by states and lexical classes.
The action tables with which we work are held as one-dimensional
arrays of lists of lexical class-(action-state pair) pairs.
If the state index for these tables is out of range it is a design error.
User error entries correspond to valid state indices for which the
lexical class in question is not represented.
=SML
type ('lc)ACTION_TABLE =  ('lc * ACTION) list Array.array;
=TEX
Similarly the goto tables (for the non-terminal symbols) are held
in a one-dimensional array of pairs each comprising a non-terminal name and a
state.
It is a design error if an invalid index pair is supplied for these tables.
=SML
type GOTO_TABLE = (string * STATE) list Array.array;
=TEX
We assume that the user-defined reduction code (indexed by non-terminal
names and alternative indices) is held in a table of the following type.
(This could be made more efficient if we represented non-terminals as
numeric offsets rather than by there names.)
=SML
type ('tok, 'lc, 'pp)REDUCTION_TABLE =
	(('tok, 'lc, 'pp)INPUT_STACK -> 'pp) list E_DICT;
=TEX
The user-defined dynamic conflict resolver takes an input stack and the
reduction information
contained in the dynamic action and returns a value 
of the following type indicating
whether the parser should shift, reduce or report an error:
=SML
datatype RESOLUTION	= DoShift
			| DoReduce
			| DoError;
=TEX
Thus the resolver has the following type.
=SML
type ('tok, 'lc, 'pp)RESOLVER =
	('tok * 'lc) * ('tok, 'lc, 'pp)INPUT_STACK * ((string * int) * int) -> RESOLUTION;
=TEX
Finally, we assume that a functions of the following types are available
to give the lexical class of an input token and to handle errors.
=SML
type ('tok, 'lc)CLASSIFIER = 'tok -> 'lc;
type ('tok, 'lc, 'pp)ERROR_ROUTINE =
	'tok * ('tok, 'lc, 'pp)INPUT_STACK * STATE_STACK -> unit;
=TEX
\section{THE DRIVER}
The following two exceptions may be raised by the driver. $SYNTAX\_ERROR$
is raised if an error in the input has been detected and passed to the
error routine and the error routine has not raised an exception.
$PARSER\_ERROR$ ``should not happen'': it indicates an error in the driver
or its tables.
=SML
exception SYNTAX_ERROR;
exception PARSER_ERROR of string;
=SML
local
	fun get_action (actions : (''lc)ACTION_TABLE) (s:STATE) (lc:''lc) : ACTION = (
	(let	open Array
	in	lassoc3 (sub(actions, s)) lc
	end	handle Fail _ => Error)
	handle Array.Subscript => raise PARSER_ERROR "invalid state"
	);
in	fun lookup_action
		(resolver : ('tok, ''lc, 'pp)RESOLVER)
		(actions : (''lc)ACTION_TABLE)
		(tok : 'tok)
		(stk : ('tok, ''lc, 'pp)INPUT_STACK)
		(s : STATE)
		(lc : ''lc) : ACTION = (
		case get_action actions s lc of
			Dynamic (s', altsymn) => (
				case resolver((tok, lc), stk, altsymn) of
					DoShift => Shift s'
				|	DoReduce => Reduce altsymn
				|	DoError => Error
			) |	easy => easy
	);
end;
=TEX
=SML
fun lookup_goto (gotos : GOTO_TABLE) (s:STATE) (nt : string) = (
	(let	open Array
	in	lassoc3 (sub(gotos, s)) nt
	end	handle Fail _ => raise PARSER_ERROR "invalid non-terminal")
	handle Array.Subscript => raise PARSER_ERROR "invalid state"

);
=TEX
=SML
fun lookup_reducer (reducers : (''tok, ''lc, 'pp)REDUCTION_TABLE)
		(nt:string) (alt : int) = (
	case e_lookup nt reducers of
		Value tab => my_nth tab alt
	|	Nil  => raise PARSER_ERROR "invalid non-terminal/alternative"
);
=TEX
=SML
fun slrp'parse
	(s0 : STATE)
	(actions : (''lc)ACTION_TABLE)
	(gotos : GOTO_TABLE)
	(reducers : (''tok, ''lc, 'pp)REDUCTION_TABLE)
	(resolver : (''tok, ''lc, 'pp) RESOLVER)
	(classify : (''tok, ''lc)CLASSIFIER)
	(error : (''tok, ''lc, 'pp)ERROR_ROUTINE) : (unit -> ''tok) ->'pp = (
	let	open Array;
		val init_ss = [s0];
		val init_is = [];
		val fetch_action = lookup_action resolver actions;
		val fetch_reducer = lookup_reducer reducers;
		val fetch_goto = lookup_goto gotos;
		fun go reader tok = (fn (ss, is) =>
			let	val lc = classify tok;
				val s = hd ss;
			in	case fetch_action tok is s lc of 
					Shift s' => go reader (reader())((s' :: ss), Token(tok, lc) :: is)
				|	Reduce((nt, alt), r) => (
						let	val reducer = fetch_reducer nt alt;
							val A = reducer is;
							val ss' = ss from r;
							val is' = is from r;
							val s' = fetch_goto (hd ss') nt;
						in go reader tok (s' :: ss', Parsed A :: is')
						end
				) |	Accept => ((ss, is)
				) |	Error =>(
					error (tok, is, ss);
					raise SYNTAX_ERROR
				) |	Dynamic _ => (
					raise PARSER_ERROR "conflict resolution error"
				)
			end
		);
	in
		(fn reader => (
			case go reader (reader()) (init_ss, init_is)of
				(_, [Parsed res]) => res
			|	_ => raise PARSER_ERROR "stacks corrupt at end of parse"))
	end
);
=TEX
=TEX
\section{AUXILIARIES FOR USER CODE}
In this section we define functions which support the user in defining
error handling and conflict resolution functions.
=SML
fun format_stack (do_tok : 'tok -> string)(stk : ('tok, 'lc, 'pp)INPUT_STACK) : string = (
	format_list (fn Token (tk, _) => do_tok tk | _ => "...") (rev stk) " "
);
=TEX
The default error routine is parameterised by functions to print input
tokens:
=SML
fun default_error
	(do_tok : 'tok -> string)
	(tok: 'tok, stk : ('tok, 'lc, 'pp)INPUT_STACK, _ : STATE_STACK) : unit = (
	diag_line("*** ERROR Syntax error ***");
	if any stk (fn Token _ => true | _ => false)
	then diag_line(do_tok tok ^ " not expected after: " ^ format_stack do_tok stk)
	else diag_line(do_tok tok ^ " not expected here")
);
=TEX
The default resolver is one which raises $PARSER\_ERROR$ if it is called.
It is intended for use when there are no conflicts.
=SML
val (default_resolver : ('tok, 'lc, 'pp)RESOLVER) = (fn _ =>
	raise PARSER_ERROR "shift/reduce conflict"
);
=TEX
For grammars which do contain shift/reduce conflicts the commonest form of
conflict resolution simply compares the latest input token with the topmost
token on the stack. $simple\_resolver$ helps the user define such a
resolver. Its argument is a function which compares two tokens (which
are given as a pair in input order, i.e. the latest input token comes second).
The resulting resolver will report a syntax error if there are no tokens
on the stack, a situation which corresponds, for example, to an input whose
first symbol is an infix operator.
=SML
fun simple_resolver (prec : (('tok * 'lc) * ('tok * 'lc)) -> RESOLUTION)
		: ('tok, 'lc, 'pp)RESOLVER = (fn (toklc, stk, ignored) =>
	case stk of
		Token toklc' :: _ => prec (toklc', toklc)
	|	_ :: more => simple_resolver prec (toklc, more, ignored)
	|	[] => DoError
);
=TEX
=SML
end; (* of structure icl'SlrpDriver *)
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
