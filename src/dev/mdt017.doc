=IGN
********************************************************************************
mdt017.doc: this file is part of the PPDev system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
%  mdt017.doc  %Z% $Date: 2002/10/17 15:10:58 $ $Revision: 2.8 $ $RCSfile: mdt017.doc,v $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=10000
\def\Slrp{{\bf SLRP}}
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for SLR Parser Generator}  %% Mandatory field
\TPPref{DS/FMU/IED/MDT017}  %% Mandatory field
\def\SCCSversion{$Revision: 2.8 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPdate{\FormatDate{$Date: 2002/10/17 15:10:58 $
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
%\TPPstatus{Approved}			%% Mandatory field
\TPPtype{Test Script}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{
The module tests for the simple SLR parser generator.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.3-1.4 (30 September - 7 October 1991)]
Initial  drafts for comment.
\item[Issue 2.1 (7 October 1991)]
First approved issue after deskcheck ID0087.
\item[Issue 2.2 (4 Febrary 1992)]
Added test case SLRP.4.
\item [Issue 2.3 (8th April 1992)]
Put SCCS keywords back in.
\item [Issue 2.4 (8th February 1999)] Update for SML'97. (Note: it is
still PolyML-specific in places, but the tests can be run by hand on NJML).
\item [Issue 2.5 (21st April 1999)] Update for Linux. (Note: still run tests by hand for NJML).
\item [Issue 2.6 (1st August 1999)] Now the {\tt slrp} shell script, can run tests automatically
in a portable way.
\item[Issue 2.8] Copyright and banner updates for open source release.
\item[Issue 2.9] PPDev-specific updates for open source release
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document gives the module test script for the SLR parser generator,
called \Slrp, defined in \cite{DS/FMU/IED/DTD017}.

\subsection{Introduction}
Since the parser generator is not included as part of the system,
but rather is used to build parts of it, the test coverage deliberately
aims only to check out the basic sanity of \Slrp\ on the simple examples
given in \cite{DS/FMU/IED/DTD017}. The parsers for the object languages which are constructed
by the program are to be comprehensively tested.

\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD017}.
\section{TEST CASES}
We consider just three test cases:

\begin{description}
\item[SLRP.1]
The most trivial grammar, with one production having an empty list of
alternatives, which generates the empty language;
\item[SLRP.2]
the first pocket calculator example from \cite{DS/FMU/IED/DTD017}
\item[SLRP.3]
the second pocket calculator example from \cite{DS/FMU/IED/DTD017}
(exhibiting dynamic shift/reduce conflict resolution)
\item[SLRP.4]
the same example as SLRP.3 but with an error routine
which permits  partial parsing of an input stream. 
\end{description}

\subsection{Test Environment}

The tests are intended to be run using the shell script {\tt slrp}
to invoke the parser generator.
Note that when the code is stripped from this document, using
the parser generator is run to generate auxiliary files
which are included in the resulting file $mdt017.sml$. $mdt017.sml$
is then to be loaded on the parser generator database to execute
the tests and check the results.


N.b. the run generates several
screenfuls of output from the compiler and from the parser generator. The latter
output includes some of the error messages printed by the generated parsers when
syntax errors are detected. The format of these error messages should
be checked against the description given in 
\cite{DS/FMU/IED/DTD017}, if it is desired to check that aspect of
the parser generator functionality.
\section{TEST DATA AND TEST CODE}
\subsection{Preamble}
The instructions of \cite{DS/FMU/IED/PLN007} are to use $usefile$;
however we do not have a Reader/Writer module in the parser generator,
and so we must use the portability module facilities (\cite{DS/FMU/IED/DTD108})
to load the test harness.
Also, it is sometimes necessary, and never harmful, to reopen the
error handling structure so that the correct value is accessed
by the name $Error$ when we load the test harness (i.e. not the
constructor $Error$ from \cite{DS/FMU/IED/DTD018}).
=SML
open BasicError;
PPBuild.pp'use"dtd013.sml";
PPBuild.pp'use"imp013.sml";
init_mt_results();
=TEX
\subsection{SLRP.1}
=TEX
First of all we set up the environment required in all cases:
=SML
open SlrpDriver;
=TEX
\subsection{CASE SLRP.1}
=DUMP mdt017a.grm.txt
(* Module Test mdt017 Case 1: Grammar for empty language *)
	E	=	();
=TEX
=SML
datatype SLRP_1_CLASS = Something | Eos;
=TEX
Now we invoke SLRP:
=SH
slrp -e Eos -f mdt017a.grm.txt | tee mdt017a.grm.run 1>&2
cat mdt017a.grm.sml
=TEX
The parser is essentially a recogniser for empty strings.
=SML
fun slrp_1_error x = default_error (fn s => s) x;
val slrp_1_classify = (fn "" => Eos | _ => Something);
fun slrp_1_reader s = (
	case explode s of
		(ch :: more) => (ch, implode more)
	|	[] => ("", "")
);
=TEX
=SML
fun slrp_1_parser x = slrp'gen_parser default_resolver
			slrp_1_classify slrp_1_error slrp_1_reader x;
=TEX
=SML
fun check_1 f  "" = (f ""; "OK")
|   check_1 f x = (f x; "Wrong") handle SYNTAX_ERROR =>  "OK";
=TEX
=SML
store_mt_results
mt_run
[("SLRP.1.1", check_1 slrp_1_parser, "", "OK"),
 ("SLRP.1.2", check_1 slrp_1_parser, "X", "OK")];
=TEX
\subsection{SLRP.2}
=TEX
We define the actions for the first pocket calculator parser:
=SML
fun add (Parsed (x:int)) (Parsed (y:int)) = x + y
|   add _ _ = raise PARSER_ERROR "corrupt stack";
fun mul (Parsed (x:int)) (Parsed (y:int)) = x * y
|   mul _ _ = raise PARSER_ERROR "corrupt stack";
fun fetch (Parsed (x:int)) = x
|   fetch _= raise PARSER_ERROR "corrupt stack";
fun conv (Token (n:string, _)) = nat_of_string n
|   conv _ = raise PARSER_ERROR "corrupt stack";
=TEX
=SML
=DUMP mdt017b.grm.txt
(* Grammar for a Pocket Calculator *)
	E	=	E, `Plus`, T			(add x1 x3)
		|	T 				(fetch x1);

	T	=	T, `Times`, F			(mul x1 x3)
		|	F				(fetch x1);

	F	=	`Lbrack`, E, `Rbrack`		(fetch x2)
		|	Num				(conv x1);
=TEX
We use the following datatype for the lexical classes here:
=SML
datatype SLRP_2_CLASS = Plus | Times | Lbrack | Rbrack | Num | Eos | Wrong;
=TEX
Now we invoke SLRP:
=SH
slrp -e Eos -f mdt017b.grm.txt | tee mdt017b.grm.run 1>&2
cat mdt017b.grm.sml
=TEX

=SML
fun slrp_2_classify "*" = Times
|   slrp_2_classify "+" = Plus
|   slrp_2_classify "(" = Lbrack
|   slrp_2_classify ")" = Rbrack
|   slrp_2_classify "<end-of-input>" = Eos
|   slrp_2_classify Other = if is_all_decimal Other then Num else Wrong;
=SML
fun slrp_2_error x = default_error (fn s => s) x;
=TEX
=SML
fun slrp_2_reader (ip : string list) : string * string list = (
	case ip of
		(h :: more) => (h, more)
	|	[] => ("<end-of-input>", [])
);
=TEX
=SML
fun slrp_2_parser x = slrp'gen_parser default_resolver
			slrp_2_classify slrp_2_error slrp_2_reader x;
=TEX

=SML
fun slrp_2_lex (s : string) : string list = (
	let	val chars = explode s;
		fun get_num acc (x :: more) = (
			if is_all_decimal x
			then get_num (acc ^ x) more
			else (acc, x :: more)
		)  | get_num acc [] = (acc, []);
		fun get_tok (x :: more) = (
			if is_all_decimal x
			then let val (num, rest) = get_num x more
			in	num :: get_tok rest
			end else if x = " "
			then get_tok more
			else x :: get_tok more
		) | get_tok [] = []
	in	get_tok chars
	end
);
=TEX
=SML
val slrp_2: string -> int = slrp_2_parser o slrp_2_lex;
=TEX
=SML
store_mt_results
mt_run
[("SLRP.2.1", slrp_2, "1", 1),
 ("SLRP.2.2", slrp_2, "2+2", 4),
 ("SLRP.2.3", slrp_2, "(2)+2", 4),
 ("SLRP.2.4", slrp_2, "(2+3)*6", (2+3)*6),
 ("SLRP.2.5", slrp_2, "(2*3)*6", 2*3*6),
 ("SLRP.2.6", slrp_2, "2*(3*6)", 2*3*6),
 ("SLRP.2.7", slrp_2, "2*((((( ((((( ((((( 3*6 ))))) ))))) )))))", 2*3*6),
 ("SLRP.2.8", slrp_2, "2+2", 4)];
=TEX
=SML
fun check_2 f s = (f s; "Wrong") handle SYNTAX_ERROR => "OK";
=TEX
=SML
store_mt_results
mt_run
[("SLRP.2a.1", check_2 slrp_2, "1)", "OK"),
 ("SLRP.2a.2", check_2 slrp_2, "", "OK"),
 ("SLRP.2a.3", check_2 slrp_2, "(2+2", "OK"),
 ("SLRP.2a.4", check_2 slrp_2, "(2++3)*6", "OK"),
 ("SLRP.2a.5", check_2 slrp_2, "(2*3)**6", "OK"),
 ("SLRP.2a.6", check_2 slrp_2, "2*3*6)", "OK"),
 ("SLRP.2a.7", check_2 slrp_2, "2*((((( (( (( ((((( 3*6 ))))) ))))) )))))", "OK"),
 ("SLRP.2a.8", check_2 slrp_2, "2+", "OK")];
=TEX
\subsection{SLRP.3}
=TEX
First we define the new action routine we will need:
=SML
fun apply (Token("+", _)) (Parsed (x:int)) (Parsed (y:int)) = x + y
|   apply (Token("*", _)) (Parsed (x:int)) (Parsed (y:int)) = x * y
|   apply (Token(s, _)) _ _ = raise PARSER_ERROR ("operator " ^ s  ^ " not recognised")
|   apply _ _ _ = raise PARSER_ERROR "corrupt stack";
=SML
=DUMP mdt017c.grm.txt
(* Module Test mdt017 Case 3: Grammar for a Pocket Calculator *)
E	=	 E, Op, E			(apply x2 x1 x3)
	|	 `Lbrack`, E, `Rbrack`		(fetch x2)
	|	 Num 				(conv x1);                        
=TEX

=SML
datatype SLRP_3_CLASS = Op | Lbrack | Rbrack | Num | Eos | Wrong;
=TEX
Now we invoke SLRP:
=SH
slrp -e Eos -f mdt017c.grm.txt | tee mdt017c.grm.run 1>&2
cat mdt017c.grm.sml
=TEX
=TEX
=SML
fun slrp_3_classify "*" = Op
|   slrp_3_classify "+" = Op
|   slrp_3_classify "(" = Lbrack
|   slrp_3_classify ")" = Rbrack
|   slrp_3_classify "<end-of-input>" = Eos
|   slrp_3_classify Other = if is_all_decimal Other then Num else Wrong;
=TEX
=SML
fun slrp_3_compare ((s1, _), (s2, _)) = (
	case (s1, s2) of
		("+", "+") => DoReduce
	|	("+", "*") => DoShift
	|	("*", "+") => DoReduce
	|	("*", "*") => DoReduce
	|	_ => raise PARSER_ERROR "unrecognised operator"
);
=TEX

=SML
val slrp_3_parser = slrp'gen_parser
    (simple_resolver slrp_3_compare) slrp_3_classify slrp_2_error slrp_2_reader;
val slrp_3: string -> int = slrp_3_parser o slrp_2_lex;
=TEX

=TEX
=SML
store_mt_results
mt_run
[("SLRP.3.1", slrp_3, "1", 1),
 ("SLRP.3.2", slrp_3, "2+2", 4),
 ("SLRP.3.3", slrp_3, "(2)+2", 4),
 ("SLRP.3.4", slrp_3, "(2+3)*6", (2+3)*6),
 ("SLRP.3.5", slrp_3, "(2*3)*6", 2*3*6),
 ("SLRP.3.6", slrp_3, "2*(3*6)", 2*3*6),
 ("SLRP.3.7", slrp_3, "2*((((( ((((( ((((( 3*6 ))))) ))))) )))))", 2*3*6),
 ("SLRP.3.8", slrp_3, "2+2", 4)];
=TEX
=SML
store_mt_results
mt_run
[("SLRP.3.11", check_2 slrp_3, "1)", "OK"),
 ("SLRP.3.12", check_2 slrp_3, "", "OK"),
 ("SLRP.3.13", check_2 slrp_3, "(2+2", "OK"),
 ("SLRP.2.14", check_2 slrp_3, "(2++3)*6", "OK"),
 ("SLRP.3.15", check_2 slrp_3, "(2*3)**6", "OK"),
 ("SLRP.3.16", check_2 slrp_3, "2*3*6)", "OK"),
 ("SLRP.3.17", check_2 slrp_3, "2*((((( (( (( ((((( 3*6 ))))) ))))) )))))", "OK"),
 ("SLRP.3.18", check_2 slrp_3, "2+", "OK")];
=TEX
\subsection{SLRP.4}
=SML
val instream : string list ref = ref [];
fun slrp_4_lex s = (instream := slrp_2_lex s);
fun slrp_4_reader () : string * unit = (
	case (!instream) of
		(h :: more) => (instream := more;(h, ()))
	|	[] => ("<end-of-input>", ())
);
=TEX
=SML
fun slrp_4_error (tok, _ , _ , _) = (
	(case tok of
	"<end-of-input>" =>
		(output(std_out, "*** ERROR Syntax error ***");
		raise SYNTAX_ERROR;(tok,()))
	| _ => ("<end-of-input>",())
	)
);

=TEX
$slrp\_4$ is a simple top-down parser which parses
valid sentences in the grammar separated by an
unrecognised symbol. The grammar is

=GFT BNF Syntax
SEN	=	E
	|	E, Un, E
=TEX
where $Un$ is an unexpected symbol in the pocket
calculator grammar.
=SML
val slrp_4_parser = slrp'gen_parser
    (simple_resolver slrp_3_compare) slrp_3_classify slrp_4_error slrp_4_reader;

fun slrp_4 (s : string) : int list =
let	val sd = slrp_4_lex s;
	fun aux res =
	case (!instream) of
	[] => res
	|Other => (aux (res@[slrp_4_parser()]));
in
	aux []
end;
=TEX
=SML
store_mt_results
mt_run
[("SLRP.4.1", slrp_4, "1+1|2+1", [2,3]),
 ("SLRP.4.2", slrp_4, "2+2|3", [4,3]),
 ("SLRP.4.3", slrp_4, "(2)+2|4+(3)", [4,7]),
 ("SLRP.4.4", slrp_4, "(2+3)*6|1", [(2+3)*6,1]),
 ("SLRP.4.5", slrp_4, "(2*3)*6|2", [2*3*6,2]),
 ("SLRP.4.6", slrp_4, "2*(3*6)", [2*3*6]),
 ("SLRP.4.7", slrp_4, "2*((((( ((((( ((((( 3*6 ))))) ))))) )))))|1", [2*3*6,1]),
 ("SLRP.4.8", slrp_4, "2+2", [4])];

fun check_4 f s = (f s; "Wrong") handle SYNTAX_ERROR => "OK";
store_mt_results
mt_run
[("SLRP.4.11", check_4 slrp_4, "1more", "OK"),
 ("SLRP.4.12", check_4 slrp_4, "|", "OK"),
 ("SLRP.4.13", check_4 slrp_4, "(2+2||", "OK"),
 ("SLRP.4.14", check_4 slrp_4, "(2++3)*6", "OK"),
 ("SLRP.4.15", check_4 slrp_4, "(2*3)**6", "OK"),
 ("SLRP.4.16", check_4 slrp_4, "2*3*)6", "OK"),
 ("SLRP.4.17", check_4 slrp_4, "2*((((( (((( (( ((((( 3*6 ))))) ))))) )))))", "OK"),
 ("SLRP.4.18", check_4 slrp_4, "2+", "OK")];
=TEX
\subsection{Epilogue}
=SML
raw_diag_string (summarize_mt_results()^"\n");
=TEX
\end{document}
