=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{SLR Parser Generator}  %% Mandatory field
\TPPref{DS/FMU/IED/??}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
A simple SLR parser generator is implemented.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion (\FormatDate{$Date$%
})]
First draft for comment.
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}

\subsection{Introduction}
\section{UTILITIES}
=TEX
=SML
fun is_NIL (NIL : 'a OPT) : bool = true
|   is_NIL _ = false;
=TEX
=SML
fun nth [] _ = scream "nth" "invalid index"
|   nth (a::_) 0 = a
|   nth (_ :: more) n = nth more (n-1);
=TEX
=SML
fun bound list = length list - 1;
=TEX
=SML
fun chat msg = (diag_line msg);
=TEX
=SML
fun indices (list : ''a list) (what : ''a) = (
	let	fun aux n (a :: more) = (
			if a = what
			then n :: aux (n+1) more
			else aux (n+1) more
		) | aux _ _ = [];
	in	aux 0 list
	end
);
=TEX
=SML
fun read_file (file : string) = (
	let	val ip = open_in file;
		fun aux () = (
			let	val whatgot = input(ip, 512)
			in	if size whatgot = 512
				then whatgot :: aux ()
				else [whatgot]
			end
		);
		val res = implode(aux());
	in	close_in ip; res
	end	handle Io msg => scream "read_file" ("i/o failure:" ^ msg)
);
=TEST
read_file "AARDVARK" (* FAILS *);
read_file "/etc/passwd";
let val str = read_file "slr.doc" in diag_line str end;
=TEX
=SML
set_terms[";", "=", "|", ","];
fun read_grammar (file : string) = (
	BNF_parse (read_file file)
);

=TEX
\section{THE SETS OF ITEMS CONSTRUCTION}
We represent an item by giving the name of the associated non-terminal
the index of the alternative for that non-terminal and the index within
that alternative:
=SML
type ''a item = ''a symbol * int * int;
=TEX
$follower\,g\,x$ returns the symbol immediately after the dot in the item $x$
for the grammar $g$
=SML
fun	follower (g : ''a grammar) ((sym, alt, dot): ''a item) : ''a symbol = (
	nth (nth (expand g sym) alt) dot
);
=TEX
=SML
fun show_item (g : ''a grammar) (sym, alt, dot) = (
	let	val x = nth (expand g sym) alt;
	in	(x to (dot-1), "DOT", x from dot)
	end
);
=TEX
=SML
fun set_eq (xs : ''a list) (ys : ''a list) : bool = (
	all xs (fn x => x mem ys) andalso all ys (fn y => y mem xs)
);
=TEX
The function $closure$ is just as in \cite{Aho86}.
=SML
fun closure (g : ''a grammar) (items : ''a item list) : ''a item list = (
	let	fun aux1 res symB = (
			res cup map (fn i => (symB, i, 0)) (interval 0 (bound (expand g symB)))
		);
		fun aux2 res (item::more) = (
			(aux2 (aux1 res (follower g item)) more)
			handle FAIL _ => aux2 res more
		) | aux2 res _ = res;
		val res = aux2 items items;
	in	if length res > length items
		then closure g res
		else res
	end
);
=TEX
The function $goto$ is just as in \cite{Aho86}.
=SML
fun goto (g: ''a grammar) (items : ''a item list) (sym : ''a symbol) : ''a item list = (
	let	fun aux ((item  as (symA, alt, dot)):: more) = (
			(if sym = follower g item
				then (symA, alt, dot+1) :: aux more
				else aux more)
			handle FAIL _ => aux more
		) | aux [] = [];
	in	closure g (aux items)
	end
);
=SML
=TEX
Again $items$ is as in \cite{Aho86}. We assume the grammar is already
augmented. The sentence symbol is supplied as an additional parameter.
=SML
fun items  (g : ''a grammar) (sen : string) : ''a item list list = (
	let	fun aux1 (item :: more) = (
			((follower g item) :: aux1 more) handle FAIL _ => aux1 more
		) | aux1 [] = [];
		fun aux2 res (items :: more) = (
			case aux1 items of
				[] => aux2 res more
			|	xs => aux2 (res cup map (goto g items) xs) more
		) | aux2 res [] = res;
		fun aux3 items = (
			let	val newitems = aux2 items items
			in	if length newitems > length items
				then aux3 newitems
				else items
			end
		);
	in	aux3 [closure g [(NonTerminal sen, 0, 0)]]
	end
);
=TEX
\section{DATA TYPES FOR THE DRIVER}
We differ slightly from \cite{Aho86} in that we work with two stacks, one
for states and one for partially parsed input.
The state stack is just a list of numbers.
=SML
type STATE = int;
type STATE_STACK = STATE list;
=TEX
The partially parsed input stack contains entries of the following
type, $'tok$ being the type of the input token stream,
$'lc$ being the type of the lexical classes used, and $'pp$ being
the type preduced when a phrase is reduced.
=SML
datatype ('tok, 'lc, 'pp) INPUT_STACK_ITEM = Token of 'tok * 'lc | Parsed of 'pp;
=TEX
An $INPUT\_STACK$ is just a list of $INPUT\_STACK\_ITEM$s.
=SML
type('tok, 'lc, 'pp) INPUT_STACK = ('tok, 'lc, 'pp) INPUT_STACK_ITEM list;
=TEX
As in \cite{Aho86}, an action takes one of the following four options:

\begin{enumerate}
\item
Shift into a given state, $s$
\item
Reduce by some alternative, $\beta$, for the nonterminal $A$. This means
that the top most $n$ items, where $n$ is the length of the alternative $\beta$
have been recognised as an $A$. In our case this means that $n$ items
are popped from the input stack and some user-defined
code is invoked to compute a $'pp$, say $A$, from them, which is then
pushed (as $Parsed\,A$) back on the stack.
\item
Accept. I.e. Parsing has finished.
The input stack now contains a single $'pp$ which is the desired result.
\item
Error. The input to be parsed is invalid.
\end{enumerate}

Actions are encoded in the following datatype, in which we assume that the
user-defined reduction code may be accessed by the name of the non-terminal, $A$,
together with the index of the alternative, $\beta$ and in which we also
record the number of symbols to reduce by in the reduce case.
Note that as in \cite{Aho83} the parts of the goto tables concerned
with terminal symbols (i.e. lexical classes) are held in the shift
actions.
=SML
datatype ACTION	= Shift of STATE
		| Reduce of ((string * int) * int)
		| Accept
		| Error;
=TEX
The action tables described in \cite{Aho83} are two-dimensional arrays
indexed by states and lexical classes.
The action tables with which we work are held as one-dimensional
arrays of lists of lexical class-(action-state pair) pairs.
If the state index for these tables is out of range it is a design error.
User error entries correspond to valid state indices for which the
lexical class in question is not represented.
=SML
type ('lc)ACTION_TABLE =  ('lc * ACTION) list Array.array;
=TEX
Similarly the goto tables (for the non-terminal symbols) are held
in a one-dimensional array of pairs each comprising a non-terminal name and a
state.
It is a design error if an invalid index pair is supplied for these tables.
=SML
type GOTO_TABLE = (string * STATE) list Array.array;
=TEX
We assume that the user-defined reduction code (indexed by non-terminal
names and alternative indices) is held in a table of the following type.
(This could be made more efficient if we represented non-terminals as
numeric offsets rather than by there names.)
=SML
type ('tok, 'lc, 'pp)REDUCTION_TABLE =
	(('tok, 'lc, 'pp)INPUT_STACK -> 'pp) list e_dict;
=TEX
Finally, we assume that a functions of the following types are available
to give the lexical class of an input token and to handle errors.
=SML
type ('tok, 'lc)CLASSIFIER = 'tok -> 'lc;
type ('tok, 'lc, 'pp)ERROR_ROUTINE = 'tok * ('tok, 'lc, 'pp)INPUT_STACK * STATE_STACK -> unit;
=TEX
\section{THE DRIVER}
=SML
fun lookup_action (actions : (''lc)ACTION_TABLE) (s:STATE) (lc:''lc) : ACTION = (
	(let	open Array
	in	lassoc3 (sub(actions, s)) lc
	end	handle FAIL _ => Error)
	handle Array.Subscript => DESIGN_ERROR "slr_parser" "invalid state"
);
=TEX
=SML
fun lookup_goto (gotos : GOTO_TABLE) (s:STATE) (nt : string) = (
	(let	open Array
	in	lassoc3 (sub(gotos, s)) nt
	end	handle FAIL _ => DESIGN_ERROR "slr_parser" "invalid non-terminal")
	handle Array.Subscript => DESIGN_ERROR "slr_parser" "invalid state"

);
=TEX
=SML
fun lookup_reducer (reducers : (''tok, ''lc, 'pp)REDUCTION_TABLE)
		(nt:string) (alt : int) = (
	case e_lookup nt reducers of
		VALUE tab => nth tab alt
	|	NIL => scream "slr_parser" "invalid non-terminal/alternative"
);
=SML
exception SYNTAX_ERROR;
=TEX
=SML
fun slr_parse
	(s0 : STATE)
	(actions : (''lc)ACTION_TABLE)
	(gotos : GOTO_TABLE)
	(reducers : (''tok, ''lc, 'pp)REDUCTION_TABLE)
	(classify : (''tok, ''lc)CLASSIFIER)
	(error : (''tok, ''lc, 'pp)ERROR_ROUTINE) : (unit -> ''tok) ->'pp = (
	let	open Array;
		val init_ss = [s0];
		val init_is = [];
		fun go reader tok = (fn (ss, is) =>
			let	val lc = classify tok;
				val s = hd ss;
			in	case lookup_action actions s lc of 
					Shift s' => go reader (reader())((s' :: ss), Token(tok, lc) :: is)
				|	Reduce((nt, alt), r) => (
						let	val reducer = lookup_reducer reducers nt alt;
							val A = reducer is;
							val ss' = ss from r;
							val is' = is from r;
							val s' = lookup_goto gotos (hd ss') nt;
						in go reader tok (s' :: ss', Parsed A :: is')
						end
				) |	Accept => ((ss, is)
				) |	Error =>(
					error (tok, is, ss);
					raise SYNTAX_ERROR
				)
			end handle SYNTAX_ERROR => (
				scream "slr_parser" "syntax error detected"
			)
		);
	in
		(fn reader => (
			case go reader (reader()) (init_ss, init_is)of
				(_, [Parsed res]) => res
			|	_ => scream "slr_parser" "internal error: stacks corrupt"))
	end
);
=TEX
\section{SLR TABLE COMPUTATION}
The following computes the $first$ function of \cite{Aho83}.
=SML
fun first (g : ''a grammar) : (''a symbol * (''a OPT list)) list = (
	let	val step1 = map (fn s => (Terminal s, [VALUE s])) (give_terms g);
		fun step2_aux1 alts = (
			case alts of
				(Terminal a :: _)  :: more => step2_aux1 more grab (VALUE a)
			|	[] :: more=> step2_aux1 more grab NIL
			|	_ :: more=> step2_aux1 more
			|	[] => []
		);
		fun step2_aux2 ((nt, alts) :: more) = (
			(NonTerminal nt, step2_aux1 alts) :: step2_aux2 more
		) | step2_aux2 [] = step1;
		val step2 = step2_aux2 g
		fun step3_aux1 tab alts = (
			case alts of
				((nt as (NonTerminal _)) :: alt')  :: more => (
					let	val new = lassoc3 tab nt
					in	if NIL mem new
						then (new less NIL)cup step3_aux1 tab (alt' :: more)
						else new cup step3_aux1 tab more
					end
			) |	[] :: more => [NIL] cup step3_aux1 tab more
			|	_ :: more => step3_aux1 tab more
			|	[] => []
		);
 		fun step3_aux2 tab ((nt, alts) :: more) = (
			let	val old = lassoc3 tab(NonTerminal nt);
				val new = step3_aux1 tab alts;
				val tab' = tab overwrite (NonTerminal nt, old cup new);
			in	step3_aux2 tab' more
			end
		) | step3_aux2 tab [] = tab;
		fun step3_aux3 tab = (
			let	val tab' = step3_aux2 tab g;
			in	if tab' = tab
				then tab
				else step3_aux3 tab'
			end
		);
	in	step3_aux3 step2
	end
);
=TEX
The following computes the $FOLLOW$ function of \cite{Aho83}.
=SML
fun follow (g : ''lc grammar) (sen : string) (eos : ''lc): (string * (''lc list)) list = (
	let	val first_tab = first g;
		fun first_syms (sym :: more) = (
			let	val firsts = lassoc3 first_tab sym;
			in	if NIL mem firsts
				then (firsts less NIL) cup first_syms more
				else firsts
			end
		) | first_syms [] = [NIL];
		fun doalt a tab alt = (
			(case alt of 
				(NonTerminal b :: more) => (
					let	val oldb = lassoc3 tab b;
						val firstmore = first_syms more;
						val newb = oldb cup 
							(if NIL mem firstmore
							then lassoc3 tab a cup map force_value(firstmore less NIL)
							else map force_value firstmore);
					in	doalt a (tab overwrite (b, newb)) more
					end
			) |	(_ :: more) => (doalt a tab more
			) |	[] => tab)
		);
		fun doprod tab (nt, alt :: more) = (
			doprod (doalt nt tab alt) (nt, more)
		) | doprod tab (_, []) = tab;
		fun again (prod :: more) tab = (
			again more (doprod tab prod)
		) | again [] tab = tab;
		fun go tab = (
			let	val tab' = again g tab;
			in	if tab' = tab
				then tab
				else go tab'
			end
		);
	in	go (map (fn (nt, _) => (nt, if nt = sen then [eos] else [])) g)
	end 
);

=TEX
=SML
fun slr_tables (g : ''_lc grammar) (eos : ''_lc) (sen : string) 
	: (''_lc)ACTION_TABLE * GOTO_TABLE * ((''_lc)item list * int) list * STATE = (
	let	open Array;
		val C = items g sen;
		val n = bound C;
		val js = interval 0 n
		val Ijs = combine C js;
		val actions = array (n+1, []:(''_lc * ACTION)list);
		val gotos = array (n+1, []: (string * STATE)list);
		fun my_follower item = (
			(VALUE (follower g item)) handle FAIL _ => NIL
		);
		fun item_index items = (
			snd(find Ijs (fn (items', _) => set_eq items items'))
		);
		fun make_actions items ((item as (NonTerminal nt, alt, dot)) :: more) = (
			case my_follower item of
				VALUE(a as (Terminal lc)) => (
					make_actions items more grab
					(lc, Shift(item_index(goto g items a)))
			) |	VALUE _ => (make_actions items more
			) |	NIL => (
					if nt <> sen
					then let	fun f lc = (lc, Reduce((nt, alt), dot));
							val lcs = lassoc3 (follow g sen eos) nt;
					in	make_actions items more cup map f lcs
					end else make_actions items more grab (eos, Accept) 
			)
		) | make_actions _ _ = [];
		val non_terms = map fst g;
		fun make_gotos items = (
			let	fun aux (nt :: more) = (
					case goto g items (NonTerminal nt) of
						[] => aux more
					|	items' => (nt, item_index items') :: aux more
				) | aux [] = [];
			in	aux non_terms
			end
		);
		val SideEffect1 = map (fn (items, j) => update(actions, j, make_actions items items)) Ijs;
		val SideEffect2 = map (fn (items, j) => update(gotos, j, make_gotos items)) Ijs;
		val init_state = snd (find Ijs (fn (items, _) => any items (fn (nt, _, _) => nt = NonTerminal sen)))
		handle FAIL _ =>
		DESIGN_ERROR "slr_tables"
		"the sentence symbol is not in the list of items";
	in	(actions, gotos, Ijs, init_state)
	end
);

=TEX
=SML
fun conflicts  (actions : (''_lc) ACTION_TABLE) : (''_lc * STATE * (ACTION list)) list = (
	let	open Array;
		fun aux i ((lc, act) :: more) = (
			if any more (fn (lc', _) => lc' = lc)
			then (lc, i, act :: map snd (more drop (fn (lc', _) => lc' <> lc)))
				:: aux i (more drop (fn (lc', _) => lc' = lc)) 
			else aux i more
		) | aux _ [] = [];
	in	flat(map (fn i => aux i (sub(actions, i)))(interval 0 (length actions - 1)))
	end
);
=TEX
=SML
fun augment (g : ''a grammar) (old_sen : string) (new_sen : string) : ''a grammar = (
	(new_sen, [[NonTerminal old_sen]]) :: g
);
=TEST
(	let	val outp = open_out "slr.tst";
	in	output (outp,
		"E = E, `+`, T | T; T = T, `*`, F | F; F = `(`, E, `)` | id;");

		close_out outp
	end);

val test_grm3 = read_grammar "slr.tst";

augment test_grm3 "E" "S" = test_grm1;
=TEST
val test_grm4 = augment (read_grammar "hol.grm") "Tm" "Tm'";

val (actions4, gotos4, Ijs4, init4) = slr_tables test_grm4 (PuncClass "$") "Tm'";

conflicts actions4;
=TEX
\section{DIAGNOSTICS}
It is helpful to have code which attempts to explain the conflicts which
arise.

Most things here are parametrised by a grammar
and/or a function to print out lexical classes.
=SML
fun format_symbol (p : ''lc -> string) (Terminal x) = p x
|   format_symbol _ (NonTerminal s) = s;
=TEX
=SML
fun format_alt (g: ''lc grammar, p : ''lc -> string) (alt : string, i : int) : string = (
	if all g (fn (s,_) => s <> alt)
	then "*** INTERNAL ERROR: invalid alternative: " ^ alt ^ " ***"
	else	let	val alts = expand g (NonTerminal alt);
			val len = length alts;
			val dots1 = if i > 0 then "... | " else "";
			val dots2 = if i < len-1 then " | ..." else "";
		in	if i < 0 orelse i >= len
			then "*** INTERNAL ERROR: invalid index ***"
			else alt ^ " = " ^ dots1 ^ format_list (format_symbol p)(nth alts i) " " ^ dots2
		end
);
=TEX
=SML
fun format_item (g : ''lc grammar, p : ''lc -> string) ((NonTerminal sym, alt, dot):''a item) = (
	if all g (fn (s,_) => s <> sym)
	then "*** INTERNAL ERROR: invalid alternative: " ^ sym ^ " ***"
	else	let	val alts = expand g (NonTerminal sym);
			val len = length alts;
		in	if alt < 0 orelse alt >= len
			then "*** INTERNAL ERROR: invalid item ***"
			else let val syms = nth alts alt
			in	if dot < 0 orelse dot > length syms
				then "*** INTERNAL ERROR: invalid index in item ***"
				else sym ^ " = " ^format_list (format_symbol p)
		((syms to (dot-1)) @ [NonTerminal "."] @ (syms from dot)) " "
			end
		end
) | format_item _ _ = "*** INTERNAL ERROR: invalid item ***";
=TEST
fun do_sym_class (PuncClass s) = s
|   do_sym_class (VarClass s) = s;
format_alt(test_grm1, do_sym_class) ("S", 0);
format_alt(test_grm1, do_sym_class) ("S", 1);
format_alt(test_grm2, do_sym_class) ("E", 2);
format_alt(test_grm2, do_sym_class) ("E", 3);
format_alt(test_grm1, do_sym_class) ("T", 0);
format_item(test_grm1, do_sym_class) (NonTerminal "T", 0, 0);
format_item(test_grm1, do_sym_class) (NonTerminal "T", 0, 1);
format_item(test_grm1, do_sym_class) (NonTerminal "T", 0, 2);
format_item(test_grm1, do_sym_class) (NonTerminal "T", 0, 3);
format_item(test_grm1, do_sym_class) (NonTerminal "F", 0, 0);
=SML
fun format_state(gp : ''lc grammar * (''lc -> string))
		((items, i) : (''lc) item list * int) : string list = (
	case items of
		[] => [string_of_int i ^ ":"]
	|	[item] => [string_of_int i ^ ":\t" ^ format_item gp item]
	|	item :: more => string_of_int i ^ ":  " ^ format_item gp item
			:: map (fn item => "\t" ^ format_item gp item) more
);
=TEX
=SML
fun print_states (gp : ''lc grammar * (''lc -> string))
		(states : (''lc item list * int) list): unit = (
	let	fun do1 state = map diag_line (format_state gp state);
	in	map do1 states; ()
	end 
);
=TEST
print_states (test_grm2, do_sym_class) Ijs;
=TEX
\section{DEFAULT REDUCTION TABLE}
The default reducer generates parse trees of the following type:
=SML
datatype ('tok, 'lc) PARSE_TREE =
	Tip of ('tok * 'lc) | Node of (string * int) * (('tok, 'lc)PARSE_TREE list);
=TEX
Each default reduction table entry is obtained by supplying the first three
arguments to the following function:
=SML
fun default_reducer (nt : string) (alt : int) (len : int) (stk:('tok, 'lc, ('tok, 'lc) PARSE_TREE)INPUT_STACK)
		: ('tok, 'lc) PARSE_TREE = (
	let	fun coerce (Token toklc) = Tip toklc
		|   coerce (Parsed Nde) = Nde;
	in	Node((nt, alt), map coerce (rev(stk to (len-1))))
	end
);
=TEX
Various intermediate forms of reduction tables have the following type:
=SML
type ('a) GEN_REDUCTION_TABLE = ('a) list e_dict;
=TEX
For testing purposes only the following function builds the actual default
reduction table for a grammar:
=SML
fun default_table (g: ('lc) grammar) :('tok, 'lc, ('tok, 'lc) PARSE_TREE)REDUCTION_TABLE = (
	let	fun do_prod nt i (alt :: more) = (
			default_reducer nt i (length alt) :: do_prod nt (i+1) more
		) | do_prod _ _ [] = [];
		fun do_grammar ((nt, alts) :: more) = (
			e_enter nt (do_prod nt 0 alts) (do_grammar more)
		) | do_grammar [] = initial_e_dict;
	in	do_grammar g
	end
);
=TEX
=SML
fun format_stack (do_tok : 'tok -> string)(stk : ('tok, 'lc, 'pp)INPUT_STACK) : string = (
	format_list (fn Token (tk, _) => do_tok tk | _ => "...") (rev stk) " "
);
=TEX
The default error routine is parameterised by functions to print input
tokens:
=SML
fun default_error
	(do_tok : 'tok -> string)
	(tok: 'tok, stk : ('tok, 'lc, 'pp)INPUT_STACK, _ : STATE_STACK) : unit = (
	diag_line("*** ERROR Syntax error ***");
	diag_line(do_tok tok ^ " not expected after:");
	diag_line(format_stack do_tok stk)
);
=SML

\section{BNF Parser}
\subsection{Action Grammars}
We need a parser for BNF.
The BNF dialect used for this
parser is an extension of a subset of the British Standard (\cite{BS6154}),
which allows fragments of ML code to be given with any alternative.
The subset is the one in which the only operators are concatenation
and alternation and in which grouping with parentheses is not allowed.
Empty alternatives are allowed.
We refer to such a grammar as an action grammar.

The concrete syntax
for action grammars is as follows:
=TEX
ó
	Grammar	=		Prod, `;`
			|	Prod, `;`, Grammar;

	Prod		=	Var, `=`, Def;

	Def		=	Alt, OptAction | Alt, OptAction, `|`, Def;

	Alt		=	Symbol | Symbol, `,`, Alt;

	Symbol		=	Var | Con;

	OptAction	=	Action | ;
æ
=TEX 
The result of parsing an action grammar with actions of type $'act$ has
the following type:
=SML
type ('lc, 'act) ACTION_GRAMMAR = (string * ((('lc)symbol list * ('act) OPT)list)) list;
=TEX
We derive an ordinary grammar from an action grammar as follows:
=SML
val strip_action : ('lc, 'act) ACTION_GRAMMAR ->  ('lc) grammar = map (Combinators.I ** map fst);
=TEX
Given a function $f:'act OPT->'a$ we can derive a $'a$-valued reduction table
from an action grammar(provided all its actions are present):
=SML
fun make_reduction_table (ag:('lc, 'act) ACTION_GRAMMAR) (f:'act OPT->'a) : ('a) GEN_REDUCTION_TABLE = (
	e_mergel initial_e_dict (map (Combinators.I ** (map f o map snd)) ag)
);
=TEX
\subsection{Implementing Action Grammars}
=TEX
The lexical categories are as follows:
=SML
datatype âBNF_lex_classá	=	BNF_var
			|	BNF_con
			|	BNF_eq
			|	BNF_semi
			|	BNF_vert
			|	BNF_comma
			|	BNF_action
			|	BNF_eos;
=TEX
=SML
type âBNF_lex_itemá = BNF_lex_class * string;
=TEX
=SML
val format_BNF_lex_item : BNF_lex_item -> string = snd;
=TEX
We use the following datatype for the partially parsed inputs when we parse
an action grammar:
=SML
datatype P_GRAMMAR	= PG_Grammar of (string * ((sym_class list * string OPT)list)) list
			| PG_Prod of string * ((sym_class list * string OPT)list)
			| PG_Def of(sym_class list * string OPT) list
			| PG_Alt of sym_class list
			| PG_Symbol of sym_class
			| PG_OptAction of string OPT;

type RT_ENTRY = (BNF_lex_item, BNF_lex_class, P_GRAMMAR)INPUT_STACK->P_GRAMMAR;
=TEX
The reduction functions are as follows:
=SML
fun pdiag stk area = (
	diag_line(format_stack format_BNF_lex_item stk);
	scream area "invalid match"
);

fun (grammar'0:RT_ENTRY) stk = pdiag stk "grammar'0";

fun (grammar0:RT_ENTRY) (_ :: Parsed(PG_Prod P) :: _) = PG_Grammar [P]
|   grammar0 stk = pdiag stk "grammar0";

fun (grammar1:RT_ENTRY) (Parsed(PG_Grammar G) :: _ :: Parsed(PG_Prod P) :: _) = PG_Grammar (P::G)
|   grammar1 stk = pdiag stk "grammar1";

fun (prod0:RT_ENTRY) (Parsed(PG_Def D)::_::Token((_, V), _)::_) = PG_Prod(V, D)
|   prod0 stk = pdiag stk "prod0";

fun (def0:RT_ENTRY) (Parsed(PG_OptAction act)::Parsed(PG_Alt alt)::_) = PG_Def[(alt, act)]
|   def0 stk = pdiag stk "def0";

fun (def1:RT_ENTRY) (Parsed(PG_Def D)::_::Parsed(PG_OptAction act)::Parsed(PG_Alt alt)::_) = PG_Def((alt, act)::D)
|   def1 stk = pdiag stk "def1";

fun (alt0:RT_ENTRY) (Parsed(PG_Symbol S)::_) = PG_Alt [S]
|   alt0 stk = pdiag stk "alt0";

fun (alt1:RT_ENTRY) (Parsed(PG_Alt alt)::_::Parsed(PG_Symbol S)::_) = PG_Alt (S::alt)
|   alt1 stk = pdiag stk "alt1";

fun (symbol0:RT_ENTRY) (Token((_, V), _)::_) = PG_Symbol(VarClass V)
|   symbol0 stk = pdiag stk "symbol0";

fun (symbol1:RT_ENTRY) (Token((_, V), _)::_) = PG_Symbol(PuncClass V)
|   symbol1 stk = pdiag stk "symbol1";

fun (optaction0:RT_ENTRY) (Token((_, V), _)::_) = PG_OptAction(VALUE V)
|   optaction0 stk = pdiag stk "optaction0";

fun (optaction1:RT_ENTRY) (_) = PG_OptAction NIL;

=TEX
The following value bindings help to abbreviate the
description of the grammar. We think of the
terminals $NonTerminal$ and $Terminal$ as variables
and constants in the notation below.
=SML
local
val âGrammará = NonTerminal "Grammar";
val âProdná = NonTerminal "Prod";
val âVará = Terminal BNF_var;
val âDefá = NonTerminal "Def";
val âAltá = NonTerminal "Alt";
val âSymbolá = NonTerminal "Symbol";
val âConá = Terminal BNF_con;
val âOptActioná = NonTerminal "OptAction";
val âActioná = Terminal BNF_action;
=TEX
We can now write down the agumented grammar for our BNF subset together with the
reduction table entries:
=SML
in
val âBNF_action_grammará : (BNF_lex_class, RT_ENTRY) ACTION_GRAMMAR = [
	("Grammar'", ([Grammar], VALUE grammar'0) :: nil),
	("Grammar", ([Prodn, Terminal BNF_semi], VALUE grammar0)
			:: ([Prodn, Terminal BNF_semi, Grammar], VALUE grammar1) :: nil),
	("Prod", ([Var, Terminal BNF_eq, Def], VALUE prod0) :: nil),
	("Def", ([Alt, OptAction], VALUE def0) ::
		([Alt, OptAction, Terminal BNF_vert, Def], VALUE def1) :: nil),
	("Alt", ([Symbol], VALUE alt0) :: ([Symbol, Terminal BNF_comma, Alt], VALUE alt1):: nil),
	("Symbol", ([Var], VALUE symbol0) :: ([Con], VALUE symbol1) :: nil),
	("OptAction", ([Action], VALUE optaction0) :: ([], VALUE optaction1) :: nil)
];
val BNF_reduction_table : (BNF_lex_item, BNF_lex_class, P_GRAMMAR) REDUCTION_TABLE
		= make_reduction_table BNF_action_grammar force_value;
val BNF_grammar : (BNF_lex_class)grammar = strip_action BNF_action_grammar;
end;
=TEX
Once we have coded the lexical analyser for our action grammar concrete syntax
it will be easy to use the above functions to make an SLR(1) parser for
the input to our parser generator.
We adopt the convention that the first production in the grammar gives
the sentence symbol.
The resulting parser will compute
a value of type $P\_GRAMMAR$. Such a value may be used to compute a
grammar and a reduction table as follows (where from now on we
use a standard ``impossible'' nonterminal as a sentence symbol to augment
the grammar):
=SML
val sentence_symbol ="*Sentence*";
val sentence_action ="(DESIGN_ERROR\"slr_parser\"\"invalid control\")";
=TEX
=SML
fun make_grammar_and_reduction_table (PG_Grammar(G as ((sen,_)::_)) : P_GRAMMAR) : sym_class grammar * string GEN_REDUCTION_TABLE OPT = (
	let	val no_actions = all G (fn(_, y)=>all y (is_NIL o snd));
		val sen_act = if no_actions then NIL else VALUE sentence_action;
		val G' =  (sentence_symbol, [([VarClass sen], sen_act)])::G;
		val nts = map fst G';
		fun make_sym(PuncClass s) = Terminal (PuncClass s)
		|   make_sym(VarClass s) =
			if s mem nts
			then NonTerminal s
			else Terminal(VarClass s);
		val Y = map (fn(x, y) => (x, map (fn (a,b) =>(map make_sym a, b)) y)) G';
		fun folder((def, alts), g) = g overwrite (def, lassoc4 g nil def cup alts);
		val AG = revfold folder Y nil;
	in	if no_actions
		then (strip_action AG, NIL)
		else if all AG (fn(_, y)=>all y (not o is_NIL o snd))
		then (strip_action AG, VALUE(make_reduction_table AG force_value))
		else scream "make_grammar_and_reduction_table"
		"it is invalid to give an action in some alternatives but not in others"
	end
) | make_grammar_and_reduction_table _ = scream "make_grammar_and_reduction_table" "invalid argument";
=TEX
\subsection{Lexical Analyser}
=TEX
The lexical analyser is very much a one-off.
It is called by the parser \cite{DS/FMU/IED/SML005}.
=TEX
subsection{Local Definitions}
Most of the lexical analyser is declared within this local block.
=SML
local

    exception âLEX_FAILá of string;

    val âord0á	= ord "0";
    val âord9á	= ord "9";
    val âordaá	= ord "a";
    val âordAá	= ord "A";
    val âordzá	= ord "z";
    val âordZá	= ord "Z";

    fun âchar_is_digitá(_, false) =  false
    |   char_is_digit(d, true) = (
	let	val ordd = ord d
	in	(ordd >= ord0) andalso (ordd <= ord9)
	end
    );
=TEX
A state, $lex\_state$, is used by most of the lexical analysis
functions, it is in two parts.  First the characters not yet tokenised,
actually a list of strings of single characters produced by exploding
the input text.  Second the token immediately preceeding the first
part.  The token may not be recognised (yet) so the token part of the
state carries a success indicator.  On entry to an analysis function
the state will be ``$(chars, (UNKNOWN, \hbox{``''}))$''.
=SML
    datatype âsuccessá = âKNOWNá of BNF_lex_class | âUNKNOWNá;

    type âtokená = success * string;

    type âlex_stateá  = (string list) * token;
=TEX
$collect$ adds the first character of the untokenised input text into the current token.
=SML
    fun âcollectá ( (cs, (cl, tk)) : lex_state ) : lex_state = (
        (tl cs, (cl, tk ^ (hd cs)))
    );
=TEX
The terminator characters for BNF are the following:
=SML
    val âterminatorsá : (string * BNF_lex_class) list =
	[(";", BNF_semi), ("=", BNF_eq), ("|", BNF_vert), (",", BNF_comma)];
=TEX
Quotes are introduced by the backquote character, \verb"`":
=SML
    val âquoterá : string = "`";

    fun ânext_is_termá (ch :: _) = any terminators (fn (c,_) => c = ch)
    |   next_is_term _ = false;

    fun ânext_is_quoterá (ch :: _) = ch = quoter
    |   next_is_quoter _ = false;

    fun ânext_is_spaceá (" " :: _) = true
    |   next_is_space ("\t" :: _) = true
    |   next_is_space ("\n" :: _) = true
    |   next_is_space _ = false;

    fun ânext_is_lbracká ("(" :: _) = true
    |   next_is_lbracká _ = false;
 
    fun ânext_is_rbracká (")" :: _) = true
    |   next_is_rbracká _ = false;
 
    fun âskip_spaceá (cs : string list) : string list = (
        if next_is_space cs
        then skip_space (tl cs)
        else cs
    );

    fun ânext_is_digitá ((ch :: _): string list) = (
        let
            val code = ord ch
        in
            (code >= ord0) andalso (code <= ord9)
        end
    ) | next_is_digit nil = false;
=TEX
We allow underscores and primes in names by treating them as letters:
=SML
    fun ânext_is_alphaá ((ch :: _): string list) = (
        let
            val code = ord ch
        in
            ((code >= orda) andalso (code <= ordz)) orelse
            ((code >= ordA) andalso (code <= ordZ)) orelse
            (ch = "_") orelse (ch = "'")
        end
    ) | next_is_alpha nil = false;

     fun ânext_is_otherá (cs as (_ :: _) : string list) = (
        (not (next_is_term cs)) andalso
        (not (next_is_space cs)) andalso
        (not (next_is_digit cs)) andalso
        (not (next_is_alpha cs)) andalso
        (not (next_is_quoter cs))
    ) | next_is_other nil = false;
=TEX
To perform the analysis a number of recognisers of tokens are provided,
they are tried in turn on the input characters until one of them
recognises one of more of the input characters as a token.  Those
characters are then removed, classified and added to the output list of
tokens.  Then the recognisers are applied to the remaining input, and
so on until there is no more input.

Function $rec_alphanum_rest$ recognises a list of alpha numerics, it is
an auxiliary for the other recognisers.
=SML
    fun ârec_alphanum_restá (cs, tok) = (
	if next_is_alpha cs orelse next_is_digit cs
	then rec_alphanum_rest (collect (cs, tok))
	else (cs, tok)
    );

    fun ârec_terminatorá ( (cs, tk) : lex_state ) : lex_state = (
        if next_is_term cs
        then (tl cs, (KNOWN(lassoc3 terminators (hd cs)), hd cs))
        else (cs, (UNKNOWN, ""))
    );
=TEX
=SML
    fun ârec_identifierá( (cs, tok) : lex_state ) : lex_state = (
	if next_is_alpha cs 
	then rec_alphanum_rest (tl cs, (KNOWN BNF_var, hd cs))
	else (cs, tok)
    );
=TEX
A string starts and finishes with $quoter$.
Within a string the escape character `$\backslash$' may be used to
provide characters not normally available.  The input to this lexical
analyser is an SML string.  All character in an SML string between the
HOL start and end quote characters will be reguarded as the HOL string,
so the SML escape sequences may be used for most characters.  The HOL
escape character `$\backslash$' is therefore only needed for itself and
the start quote character.
=SML
    fun ârec_quoteá ( (cs, (_, tk)) : lex_state ) : lex_state = (
        let
            fun rec_quote_rest qtch (cs, tok) = (
		case cs of
		("\\" :: _ :: rest) =>
			rec_quote_rest qtch (collect (tl cs, tok))
		| ("\\" :: _) =>
			raise (LEX_FAIL "escaped character at end of string")
		| (ch :: rest) =>
			if (ch = qtch)
			then (rest, tok)
			else rec_quote_rest qtch (collect (cs, tok))
		| _ => raise (LEX_FAIL "unmatched quote")
            );
        in
            if next_is_quoter cs
            then rec_quote_rest(hd cs) (tl cs, (KNOWN BNF_con, ""))
            else (cs, (UNKNOWN, ""))
        end
    );
=TEX
Actions are distinguished by their starting with a left bracket and are
finished by the matching right bracket.
=SML
    fun ârec_action_restá i (cs, tok) = (
	if next_is_lbrack cs
	then rec_action_rest (i+1) (collect (cs, tok))
	else if next_is_rbrack cs
	then	if i <= 0
		then (collect (cs, tok))
		else rec_action_rest (i-1) (collect (cs, tok))
	else if not (is_nil cs)
	then rec_action_rest i (collect(cs, tok))
	else raise (LEX_FAIL "unmatched left bracket")
    );
=TEX
=SML
    fun ârec_actioná (cs, tok) = (
	if next_is_lbrack cs
	then rec_action_rest 0 (tl cs, (KNOWN BNF_action, hd cs))
	else (cs, (UNKNOWN, ""))
    );
=TEX
Function $next\_token$ applies recogniser functions to the input
characters, returning the results of the first successful recogniser,
or an indicator of token unknown.
=SML
    fun ânext_tokená (recognisers : (lex_state -> lex_state) list)
                   (chars       : string list) : lex_state = (
        let
            fun try (recogniser : lex_state -> lex_state,
                     (cs, (cl, tk)) : lex_state) : lex_state = (case cl of
            UNKNOWN => recogniser(cs, (cl, tk))
          | KNOWN _ => (cs, (cl, tk))
    );
        in
            revfold try recognisers (chars, (UNKNOWN, ""))
        end
    );
=TEX
Function $tokenise$ converts the input characters into tokens by
repeatedly using $next\_token$ to identify the start of the remaining
part of the input.
=SML
    fun âtokeniseá (recognisers : (lex_state -> lex_state) list)
                 (chars       : string list) : BNF_lex_item list = (
       case skip_space chars
       of
           nil => nil
       |   cs as (_::_) => (
           let
               val (cs', tk) = next_token recognisers cs;
           in
               case tk of
                   (KNOWN cls, tk) => (cls, tk):: tokenise recognisers cs'
              |    (UNKNOWN, tk) =>  raise LEX_FAIL (": did not recognise: " ^ tk)
           end
       )
    );
=TEX
The various recognisers are gathered together in their order of application.
=SML
    val ârecognisersá = [rec_terminator,
                       rec_quote,
                       rec_identifier,
			rec_action];
in
=TEX
\subsection{Declared Functions} \label{Declared Functions}
The public interface to the lexical analyser in through three
functions.  The first two allow the characters used as terminators and
for quoting strings in the language to be altered.  The third is the
main interface to the lexical analyser, it is the function $lex$.
=SML

    fun âBNF_lex_stringá (text : string) : BNF_lex_item list = (
	(tokenise recognisers (explode text))
	handle (LEX_FAIL msg) => (
            output(std_out, "Lexical analysis error:" ^ msg ^ "\n");
            nil
        )
    );

end;
=TEST
BNF_lex_string "";
BNF_lex_string "a|,b";
BNF_lex_string "=|,`abc`";
BNF_lex_string "=|,`abc\\``";
BNF_lex_string "(=|,)`abc\\``";
BNF_lex_string "(=|,`abc\\``";
BNF_lex_string "(=|,`abc\\``) (((b(((a)))b)))";
=TEX
\subsection{Parser Auxiliaries}
=SML
val BNF_classify : BNF_lex_item -> BNF_lex_class = fst;
=TEX
=SML
val BNF_error : (BNF_lex_item, BNF_lex_class, 'a) ERROR_ROUTINE = default_error format_BNF_lex_item;
=TEX
=SML
val BNF_end_of_string : BNF_lex_item = (BNF_eos, "<End-of-Input>");
=TEX
=SML
local
val buff : BNF_lex_item list ref = ref [];
in
fun BNF_lex (s : string) : unit -> BNF_lex_item = (
	let	val SideEffect = buff := BNF_lex_string s
	in	(fn () =>
		let	val(res, rest) = (
				case !buff of
				x::rest => (x, rest)
			|	[] => (BNF_end_of_string, []));
		in 	buff := rest; res
		end)
	end
);
end;
=TEX
=SML
val (BNF_actions, BNF_gotos, BNF_Ijs, BNF_init) = slr_tables BNF_grammar BNF_eos "Grammar'";
=TEX
=SML
fun BNF_parse file =
	make_grammar_and_reduction_table(
		slr_parse
		BNF_init BNF_actions BNF_gotos BNF_reduction_table
		BNF_classify BNF_error (BNF_lex(read_file file)));
=TEST
dump_string "slr.tst""E = E, `+`, T | T; T = T, `*`, F | F; F = `(`, E, `)` | id;";

val (test_grm1, test_rt1) = BNF_parse "slr.tst";
val (actions1, gotos1, Ijs, init) = slr_tables test_grm1 (PuncClass "$") "S";
fun listofarray Xs = (
	let	open Array;
		val len = length Xs;
	in	map (fn i => sub (Xs, i)) (interval 0 (len-1))
	end
);

listofarray actions1;
listofarray gotos1;
conflicts actions1 (* shouldn't be any *);

dump_string "slr.tst""S = E; E = E, `+`, T | T; T = T, `*`, F | F; F = `(`, E, `)` | id;F = E | E, E;";
val (test_grm2, test_rt2) = BNF_parse "slr.tst";

val (actions2, gotos2, Ijs2, init2) = slr_tables test_grm2 (PuncClass "$") "S";

conflicts actions2 (* should get about 30 *);

dump_string "slr.tst"(
"E	= E, `+`, T (add x1 x3)			" ^
"	| T (fetch x1);			" ^
"T	= T, `*`, F (mul x1 x3)			" ^
"	| F (fetch x1);" ^
"F	= `(`, E, `)` (fetch x2)			" ^
"	| num (conv x1);			");

val (test_grm3, VALUE test_rt3) = BNF_parse "slr.tst";

val (actions3, gotos3, Ijs3, init3) = slr_tables test_grm3 (PuncClass "$") "S";

conflicts actions3 (* should get about 30 *);

fun add _ _ = scream "add" "not implemented";
fun mul _ _ = scream "mul" "not implemented";
fun fetch _ = scream "fetch" "not implemented";
fun conv _ = scream "conv" "not implemented";
fun parser_error _ = scream "parser_error" "not implemented";

=TEX
\section{CONFLICT RESOLUTION}
=TEX
\section{OUTPUT ROUTINES}
=SML
val parser_file : outstream ref = ref std_out;
=TEX
=SML
fun put_string (s:string):unit = (output(!parser_file, s));
fun put_line (s:string):unit = (output(!parser_file, s); output(!parser_file,"\n"));
=TEX
\subsection{Reduction Table}
=SML
fun make_action (body : string) (n : int) : string = (
	let	val is = map string_of_int(rev (interval 1 n));
		fun do1 i = "x" ^ i;
		val xs = format_list do1 is "::";
	in	if n = 0
		then "(fn _ =>" ^ body ^ ")"
		else "(fn(" ^ xs ^ "::_)=>" ^ body ^ "|_=>parser_error ())"
	end
);
=TEX
=SML
fun put_reduction_table
	(g: (''lc) grammar)
	(tab : string GEN_REDUCTION_TABLE) : unit = (
	let	fun aux1 nt i (act :: more) = (
			let	val n = length(nth(expand g (NonTerminal nt)) i);
				val func = make_action act n;
			in	if is_nil more
				then put_line func
				else (put_line(func ^ ","); aux1 nt (i+1) more)
			end
		) | aux1 _ _ [] = ();
		fun aux2 last (nt, acts) = (
			put_line("(\"" ^ nt ^ "\",[");
			aux1 nt 0 acts;
			put_line(if last then "])" else "]),")
		);
		fun aux3 (row :: more) = (
			if is_nil more
			then aux2 true row
			else(aux2 false row; aux3 more)
		) | aux3 [] = ();
	in	put_string "["; aux3 (e_flatten tab); put_line "]"
	end
);
=TEST
put_reduction_table test_grm3 test_rt3;
=TEX
\section{INTERFACE}
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
test_grm1
fun add _ _ = scream "add" "not implemented";
