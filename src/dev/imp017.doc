=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{SLR Parser Generator}  %% Mandatory field
\TPPref{DS/FMU/IED/??}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
A simple SLR parser generator is implemented.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion (\FormatDate{$Date$%
})]
First draft for comment.
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of the SLR(1) parser generator
the detailed design of which is given in \cite{DS/FMU/IED/DTD017}.
\subsection{Introduction}
\cite{DS/FMU/IED/DTD017} gives a ``black box'' description of the parser
generator. The implementation given here attempts to follow the treatment
in \cite{Aho77} fairly closely and the reader of this document is assumed
to be familiar with sections 6.1, 6.2 and 6.3 of that book. 

After beginning the definition of the structure $Slrp$ in section
\ref{PREAMBLE},
the implementation proper starts in section \ref{UTILITIES}
which collects together some
utilities needed throughout the material which follows.

In sections \ref{SLRTABLECOMPUTATION} and
\ref{DIAGNOSTICUTILITIES}, we define
the SLR(1) table construction algorithm together with some useful functions
for formatting the tables for inspection.
In section \ref{BNFPARSER} we apply the SLR(1) algorithm to construct a
parser for the extended BNF described in \cite{DS/FMU/IED/DTD017}.
Section \ref{CONFLICTRESOLUTION} contains further material for manipulating
the tables to resolve conflicts.
Section \ref{OUTPUTROUTINES} contains functions to write the tables out to
the output file (as fragments of Standard ML).

Finally, section \ref{INTERFACE} pulls all the earlier pieces together to
give the function $slrp$ which is the user interface to the parser
generator.

\subsection{Dependencies}
The code is dependent on \cite{DS/FMU/IED/DTD018}.

\section{PREAMBLE}\label{PREAMBLE}
=TEX
=SML
structure âSlrpá : Slrp = struct
=TEX
The following banner is written to the log file and to standard output
whenever the parser generator is run.
=SML
val âbannerá : string = "SLRP Parser Generator (0.$Revision$) Copyright (C) ICL 1991";
=TEX
=SML
open âEfficientDictionaryá;
open âSlrpDriverá;
=TEX
The following exception is raised in the event of, e.g., i/o errors.
It is caught in $slrp$ and so is never visible to the user.
=SML
exception âSLRP_ERRORá of string;
=TEX
\section{UTILITIES}\label{UTILITIES}
\subsection{Miscellany}
In order, (a) to make the output from the program more easily understood,
and (b) to make some as yet unidentified algorithm operate correctly,
it is helpful to have (i) a version of $grab$ which adds the new element
at the end of the list, and (ii) a version of $cup$ which accumulates its
second operand into its first:
=SML
infix 4 rgrab;
fun (x :: xs : ''a list) ârgrabá (what : ''a) = (
	if x = what
	then x :: xs
	else x :: (xs rgrab what)
) | ([] : ''a list) rgrab (what : ''a) = [what];
=TEX
=SML
infix 4 rcup;
fun (list1 : ''a list) ârcupá (list2 : ''a list) : ''a list = (
	revfold (fn(x, xs) => xs rgrab x) list2 list1
);
=TEX
The following formulation of $nth$ is more natural here:
=SML
val âmy_nthá : 'a list -> int -> 'a = switch nth;
=TEX
=SML
val âalpha_sortá = Sort.sort Sort.stringorder;
=TEX
=SML
fun âboundá list = length list - 1;
=TEX
=SML
fun âindicesá (list : ''a list) (what : ''a) = (
	let	fun aux n (a :: more) = (
			if a = what
			then n :: aux (n+1) more
			else aux (n+1) more
		) | aux _ _ = [];
	in	aux 0 list
	end
);
=TEX
=SML
fun âcountá (list : 'a list) (prop : 'a -> bool): int = (
	let	fun aux n (a :: more) = (
			if prop a
			then aux (n+1) more
			else aux n more
		) | aux n _ = n;
	in	aux 0 list
	end
);
=TEX
=SML
fun âlistofarrayá Xs = (
	let	open Array;
		val len = length Xs;
	in	map (fn i => sub (Xs, i)) (interval 0 (len-1))
	end
);
=TEX
\subsection{I/O and Formatting Utilities}
=SML
fun âso_manyá (true:bool) (0 : int) (thing : string) : string = "No " ^ thing ^ "s"
|   so_many false (0 : int) (thing : string) : string = "no " ^ thing ^ "s"
|   so_many _ 1 (thing : string) : string = "1 " ^ thing 
|   so_many _ n (thing : string) : string = string_of_int n ^ " " ^ thing ^ "s";
=TEX
=SML
fun âburstá (s : string) : string = "+++ " ^ s ^ " +++\n";
=TEX
=SML
fun âchatá msg = (output(std_out, msg));
=TEX
=SML
fun âread_fileá ("": string) : string = 
	raise SLRP_ERROR "an empty filename is not allowed for the input file"
|   read_file (file : string) = (
	let	val ip = open_in file;
		fun aux () = (
			let	val whatgot = input(ip, 512)
			in	if size whatgot = 512
				then whatgot :: aux ()
				else [whatgot]
			end
		);
		val res = implode(aux());
	in	close_in ip; res
	end	handle Io msg =>
		raise SLRP_ERROR("i/o failure on input file: " ^ file ^ " (" ^ msg ^ ")")
);
=TEST
read_file "" (* FAILS *);
read_file "/AARDVARK" (* FAILS *);
read_file "/etc/passwd";
let val str = read_file "slr.doc" in chat str end;
=SML
local
val âlog_fileá : outstream ref = ref std_out;
in
=TEX
=SML
fun âopen_logfileá (file : string) : unit = (
	(if file <> ""
	then log_file := open_out file
	else raise SLRP_ERROR "an empty filename is not allowed for the log file")
	handle Io msg =>
	raise SLRP_ERROR("i/o failure on log file: " ^ file ^ " (" ^ msg ^ ")")
);
=TEX
=SML
fun âclose_logfileá () : unit = (
	close_out (!log_file)
);
=TEX
=SML
fun âlogá (msg : string) = (
	output(!log_file, msg)
	handle Io msg =>
	raise SLRP_ERROR("i/o failure on output file (" ^ msg ^ ")")
);
end; (* of local ... in ... end *)
=TEX
\section{THE SETS OF ITEMS CONSTRUCTION}\label{THESETSOFITEMSCONSTRUCTION}
\subsection{Types and Operations for Grammars}
The following types are used to represent grammars etc.:
=SML
datatype ''a âSYMBOLá = Terminal of ''a | NonTerminal of string;
type ''a âPRODUCTIONá = string * (''a SYMBOL list list);
type ''a âGRAMMARá = ''a PRODUCTION list;
datatype âSYM_CLASSá = VarClass of string | PuncClass of string;
=TEX
=SML
fun âexpandá (g : ''a GRAMMAR) (sym as (NonTerminal name) : ''a SYMBOL)
						: ''a SYMBOL list list = (
	lassoc2 g (fn _ => nil) name
) | expand _ _ = nil;
=TEX
=SML
fun âgive_termsá (g : ''a GRAMMAR) : ''a list = (
	let	fun f(Terminal a :: rest) = a :: f rest
		|   f (_ :: rest) = f rest
		|   f nil = nil;
	in	list_cup(map (fn (x, y) => (list_cup (map f y))) g)
	end
);
=TEX
\subsection{Types and Operations on Sets for Items}
We represent an item by giving the name of the associated non-terminal
the index of the alternative for that non-terminal and the index within
that alternative:
=SML
type ''a âitemá = ''a SYMBOL * int * int;
=TEX
$follower\,g\,x$ returns the symbol immediately after the dot in the item $x$
for the grammar $g$
=SML
fun	follower (g : ''a GRAMMAR) ((sym, alt, dot): ''a item) : ''a SYMBOL = (
	my_nth (my_nth (expand g sym) alt) dot
);
=TEX
=SML
fun âshow_itemá (g : ''a GRAMMAR) (sym, alt, dot) = (
	let	val x = my_nth (expand g sym) alt;
	in	(x to (dot-1), "DOT", x from dot)
	end
);
=TEX
=SML
fun âset_eqá (xs : ''a list) (ys : ''a list) : bool = (
	all xs (fn x => x mem ys) andalso all ys (fn y => y mem xs)
);
=TEX
\subsection{CLOSURE Function}
The function $closure$ is just as in \cite{Aho77}.
=SML
fun âclosureá (g : ''a GRAMMAR) (items : ''a item list) : ''a item list = (
	let	fun aux1 res symB = (
			res rcup map (fn i => (symB, i, 0)) (interval 0 (bound (expand g symB)))
		);
		fun aux2 res (item::more) = (
			(aux2 (aux1 res (follower g item)) more)
			handle Fail _ => aux2 res more
		) | aux2 res _ = res;
		val res = aux2 items items;
	in	if length res > length items
		then closure g res
		else res
	end
);
=TEX
\subsection{GOTO Function}
The function $goto$ is just as in \cite{Aho77}.
=SML
fun âgotoá (g: ''a GRAMMAR) (items : ''a item list) (sym : ''a SYMBOL) : ''a item list = (
	let	fun aux ((item  as (symA, alt, dot)):: more) = (
			(if sym = follower g item
				then (symA, alt, dot+1) :: aux more
				else aux more)
			handle Fail _ => aux more
		) | aux [] = [];
	in	closure g (aux items)
	end
);
=TEX
\subsection{ITEMS Function}
=TEX
Again $items$ is as in \cite{Aho77}. We assume the grammar is already
augmented. The sentence symbol is supplied as an additional parameter.
=SML
fun âitemsá  (g : ''a GRAMMAR) (sen : string) : ''a item list list = (
	let	fun aux1 (item :: more) = (
			((follower g item) :: aux1 more) handle Fail _ => aux1 more
		) | aux1 [] = [];
		fun aux2 res (items :: more) = (
			case aux1 items of
				[] => aux2 res more
			|	xs => aux2 (res rcup map (goto g items) xs) more
		) | aux2 res [] = res;
		fun aux3 items = (
			let	val newitems = aux2 items items
			in	if length newitems > length items
				then aux3 newitems
				else items
			end
		);
	in	aux3 [closure g [(NonTerminal sen, 0, 0)]]
	end
);
=TEX
=TEX
\section{SLR TABLE COMPUTATION}\label{SLRTABLECOMPUTATION}
\subsection{FIRST and FOLLOW}
The following computes the $first$ function of \cite{Aho77}.
=SML
fun âfirstá (g : ''a GRAMMAR) : (''a SYMBOL * (''a OPT list)) list = (
	let	val step1 = map (fn s => (Terminal s, [Value s])) (give_terms g);
		fun step2_aux1 alts = (
			case alts of
				(Terminal a :: _)  :: more => step2_aux1 more rgrab (Value a)
			|	[] :: more=> step2_aux1 more rgrab Nil
			|	_ :: more=> step2_aux1 more
			|	[] => []
		);
		fun step2_aux2 ((nt, alts) :: more) = (
			(NonTerminal nt, step2_aux1 alts) :: step2_aux2 more
		) | step2_aux2 [] = step1;
		val step2 = step2_aux2 g
		fun step3_aux1 tab alts = (
			case alts of
				((nt as (NonTerminal _)) :: alt')  :: more => (
					let	val new = lassoc3 tab nt
					in	if Nil mem new
						then (new less Nil)rcup step3_aux1 tab (alt' :: more)
						else new rcup step3_aux1 tab more
					end
			) |	[] :: more => [Nil] rcup step3_aux1 tab more
			|	_ :: more => step3_aux1 tab more
			|	[] => []
		);
 		fun step3_aux2 tab ((nt, alts) :: more) = (
			let	val old = lassoc3 tab(NonTerminal nt);
				val new = step3_aux1 tab alts;
				val tab' = tab overwrite (NonTerminal nt, old rcup new);
			in	step3_aux2 tab' more
			end
		) | step3_aux2 tab [] = tab;
		fun step3_aux3 tab = (
			let	val tab' = step3_aux2 tab g;
			in	if tab' = tab
				then tab
				else step3_aux3 tab'
			end
		);
	in	step3_aux3 step2
	end
);
=TEX
The following computes the $FOLLOW$ function of \cite{Aho77}.
=SML
fun âfollowá (g : ''lc GRAMMAR) (sen : string) (eos : ''lc): (string * (''lc list)) list = (
	let	val first_tab = first g;
		fun first_syms (sym :: more) = (
			let	val firsts = lassoc3 first_tab sym;
			in	if Nil mem firsts
				then (firsts less Nil) rcup first_syms more
				else firsts
			end
		) | first_syms [] = [Nil];
		fun doalt a tab alt = (
			(case alt of 
				(NonTerminal b :: more) => (
					let	val oldb = lassoc3 tab b;
						val firstmore = first_syms more;
						val newb = oldb rcup 
							(if Nil mem firstmore
							then	lassoc3 tab a
							rcup map	force_value(firstmore less Nil)
							else map force_value firstmore);
					in	doalt a (tab overwrite (b, newb)) more
					end
			) |	(_ :: more) => (doalt a tab more
			) |	[] => tab)
		);
		fun doprod tab (nt, alt :: more) = (
			doprod (doalt nt tab alt) (nt, more)
		) | doprod tab (_, []) = tab;
		fun again (prod :: more) tab = (
			again more (doprod tab prod)
		) | again [] tab = tab;
		fun go tab = (
			let	val tab' = again g tab;
			in	if tab' = tab
				then tab
				else go tab'
			end
		);
	in	go (map (fn (nt, _) => (nt, if nt = sen then [eos] else [])) g)
	end 
);

=TEX
\subsection{The Table Construction}
=SML
fun âslr_tablesá (g : ''_lc GRAMMAR) (eos : ''_lc) (sen : string) 
	: (''_lc)ACTION_TABLE * GOTO_TABLE * ((''_lc)item list * int) list * STATE = (
	let	open Array;
		val C = items g sen;
		val n = bound C;
		val js = interval 0 n
		val Ijs = combine C js;
		val actions = array (n+1, []:(''_lc * ACTION)list);
		val gotos = array (n+1, []: (string * STATE)list);
		fun my_follower item = (
			(Value (follower g item)) handle Fail _ => Nil
		);
		fun item_index items = (
			snd(find Ijs (fn (items', _) => set_eq items items'))
		);
		fun make_actions items ((item as (NonTerminal nt, alt, dot)) :: more) = (
			case my_follower item of
				Value(a as (Terminal lc)) => (
					make_actions items more rgrab
					(lc, Shift(item_index(goto g items a)))
			) |	Value _ => (make_actions items more
			) |	Nil => (
					if nt <> sen
					then let	fun f lc = (lc, Reduce((nt, alt), dot));
							val lcs = lassoc3 (follow g sen eos) nt;
					in	make_actions items more rcup map f lcs
					end else make_actions items more rgrab (eos, Accept) 
			)
		) | make_actions _ _ = [];
		val non_terms = map fst g;
		fun make_gotos items = (
			let	fun aux (nt :: more) = (
					case goto g items (NonTerminal nt) of
						[] => aux more
					|	items' => (nt, item_index items') :: aux more
				) | aux [] = [];
			in	aux non_terms
			end
		);
		val SideEffect1 =
			map (fn (items, j) => update(actions, j, make_actions items items)) Ijs;
		val SideEffect2 =
			map (fn (items, j) => update(gotos, j, make_gotos items)) Ijs;
		val init_state = snd (find Ijs (fn (items, _) =>
					any items (fn (nt, _, _) => nt = NonTerminal sen)))
		handle Fail _ =>
		raise SLRP_ERROR
		"the sentence symbol is not in the list of items";
	in	(actions, gotos, Ijs, init_state)
	end
);

=TEX
\subsection{Conflict Detection}
The following function calculates whether there are any conflicts in an action table.
=SML
fun âconflictsá  (actions : (''_lc) ACTION_TABLE) : (''_lc * STATE * (ACTION list)) list = (
	let	open Array;
		fun aux i ((lc, act) :: more) = (
			if any more (fn (lc', _) => lc' = lc)
			then (lc, i, act :: map snd (more drop (fn (lc', _) => lc' <> lc)))
				:: aux i (more drop (fn (lc', _) => lc' = lc)) 
			else aux i more
		) | aux _ [] = [];
	in	flat(map (fn i => aux i (sub(actions, i)))(interval 0 (length actions - 1)))
	end
);
=TEX
\section{DIAGNOSTIC UTILITIES}\label{DIAGNOSTICUTILITIES}
It is helpful to have code which attempts to explain the conflicts which
arise.

Most things here are parametrised by a grammar
and/or a function to print out lexical classes.
=SML
fun âformat_symbolá (p : ''lc -> string) (Terminal x : (''lc) SYMBOL) = p x
|   format_symbol _ (NonTerminal s) = s;
=TEX
=SML
fun âformat_altá (g: ''lc GRAMMAR, p : ''lc -> string) (alt : string, i : int) : string = (
	if all g (fn (s,_) => s <> alt)
	then "*** INTERNAL ERROR: invalid alternative: " ^ alt ^ " ***"
	else	let	val alts = expand g (NonTerminal alt);
			val len = length alts;
			val dots1 = if i > 0 then "... | " else "";
			val dots2 = if i < len-1 then " | ..." else "";
		in	if i < 0 orelse i >= len
			then "*** INTERNAL ERROR: invalid index ***"
			else	alt ^ " = " ^ dots1
			^	format_list (format_symbol p)(my_nth alts i) ", " ^ dots2
		end
);
=TEX
=SML
fun âformat_itemá (g : ''lc GRAMMAR, p : ''lc -> string) ((NonTerminal sym, alt, dot):''a item) = (
	if all g (fn (s,_) => s <> sym)
	then "*** INTERNAL ERROR: invalid alternative: " ^ sym ^ " ***"
	else	let	val alts = expand g (NonTerminal sym);
			val len = length alts;
		in	if alt < 0 orelse alt >= len
			then "*** INTERNAL ERROR: invalid item ***"
			else let	val syms = my_nth alts alt;
					val slen = length syms;
			in	if dot < 0 orelse dot > slen
				then "*** INTERNAL ERROR: invalid index in item ***"
				else	sym ^ " = "
					^ format_list (format_symbol p)(syms to (dot-1)) ", "
					^ (if dot = 0 then "." else if dot = slen then "." else "., ")
					^ format_list (format_symbol p)(syms from dot) ", "
			end
		end
) | format_item _ _ = "*** INTERNAL ERROR: invalid item ***";
=SML
fun âformat_stateá(gp : ''lc GRAMMAR * (''lc -> string))
		((items, i) : (''lc) item list * int) : string list = (
	case items of
		[] => [string_of_int i ^ ":"]
	|	[item] => [string_of_int i ^ ":\t" ^ format_item gp item]
	|	item :: more => string_of_int i ^ ":\t" ^ format_item gp item
			:: map (fn item => "\t" ^ format_item gp item) more
);
=TEX
=SML
fun âprint_grammará (p : ''lc -> string)(g : ''lc GRAMMAR) : unit = (
	let	fun fmt_alt alt = (
			format_list (format_symbol p) alt ", "
		);
		fun fmt_prod (nt, alts) = (
			case alts of
				[] => [nt ^ "\t="]
			|	[alt] => [nt ^ "\t= " ^ fmt_alt alt]
			|	alt :: more => nt ^ "\t= " ^ fmt_alt alt ^ ""
					:: map (fn alt => "\t| " ^ fmt_alt alt) more
		);
		fun add_semi list = (
			let	val r = rev list;
			in	rev(hd r ^ ";" :: tl r)
			end
		);
		fun do_prod prod = map (fn s => (log s; log"\n"))
				(add_semi(fmt_prod prod));
	in	map do_prod g; ()
	end 
);
=SML
fun âprint_termsá (p : ''lc -> string)(g : ''lc GRAMMAR) : unit = (
	let	val names = Sort.sort Sort.stringorder (map p(give_terms g));
	in	map (fn n =>(log n; log "\n")) names; ()
	end 
);
=TEX
=SML
fun âprint_statesá (gp : ''lc GRAMMAR * (''lc -> string))
		(states : (''lc item list * int) list): unit = (
	let	fun do1 state = map (fn s => (log s; log"\n")) (format_state gp state);
	in	map do1 states; ()
	end 
);
=TEX
\section{BNF PARSER}\label{BNFPARSER}
\subsection{Action Grammars}
We need a parser for BNF.
The BNF dialect used for this
parser is an extension of a subset of the British Standard (\cite{BS6154}),
which allows fragments of ML code to be given with any alternative.
The subset is the one in which the only operators are concatenation
and alternation and in which grouping with parentheses is not allowed.
Empty alternatives are allowed.
We refer to such a grammar as an action grammar.

The concrete syntax
for action grammars is as follows:
=TEX
ó
	Grammar	=		Prod, `;`
			|	Prod, `;`, Grammar;

	Prod		=	Nam, `=`, Def;

	Def		=	OptAlt, OptAction | OptAlt, OptAction, `|`, Def;

	OptAlt		=	Alt |;

	Alt		=	Symbol | Symbol, `,`, Alt;

	Symbol		=	Nam | Con;

	OptAction	=	Action | ;
æ
=TEX 
The result of parsing an action grammar with actions of type $'act$ has
the following type:
=SML
type ('lc, 'act) âACTION_GRAMMARá = (string * ((('lc)SYMBOL list * 'act)list)) list;
=TEX
We derive an ordinary grammar from an action grammar as follows:
=SML
val âstrip_actioná : ('lc, 'act) ACTION_GRAMMAR ->  ('lc) GRAMMAR =
				map (Combinators.I ** map fst);
=TEX
We derive a $'a$-valued reduction table
from an action grammar as follows:
=SML
type ('act) âGEN_REDUCTION_TABLEá = ('act) list E_DICT;
=TEX
=SML
fun âmake_reduction_tableá (ag:('lc, 'act) ACTION_GRAMMAR)
					: ('act) GEN_REDUCTION_TABLE = (
	list_e_merge initial_e_dict (map (Combinators.I ** map snd) ag)
);
=TEX
\subsection{Implementing Action Grammars}
=TEX
The lexical categories are as follows:
=SML
datatype âBNF_lex_classá	=	BNF_var
			|	BNF_con
			|	BNF_eq
			|	BNF_semi
			|	BNF_vert
			|	BNF_comma
			|	BNF_action
			|	BNF_eos;
=TEX
=SML
type âBNF_lex_itemá = BNF_lex_class * string;
=TEX
=SML
val âformat_BNF_lex_itemá : BNF_lex_item -> string = snd;
=TEX
We use the following datatype for the partially parsed inputs when we parse
an action grammar. (Note we use "()" as the default action value. This corresponds
to a parser with the partially parsed input having type unit.)
=SML
datatype âP_GRAMMARá	= âPG_Grammará of (string * ((SYM_CLASS list * string)list)) list
			| âPG_Prodá of string * ((SYM_CLASS list * string)list)
			| âPG_Defá of(SYM_CLASS list * string) list
			| âPG_OptAltá of SYM_CLASS list
			| âPG_Symbolá of SYM_CLASS
			| âPG_OptActioná of string;

type âRT_ENTRYá =
	(BNF_lex_item, BNF_lex_class, P_GRAMMAR)INPUT_STACK->P_GRAMMAR;
=TEX
The reduction functions are as follows:
=SML
fun âpdiagá stk area = (
	raise PARSER_ERROR
	("invalid reduction (stack=" ^ (format_stack format_BNF_lex_item stk) ^ ")")
);

fun (âgrammar'0á:RT_ENTRY) stk = pdiag stk "grammar'0";

fun (âgrammar0á:RT_ENTRY) (_ :: Parsed(PG_Prod P) :: _) = PG_Grammar [P]
|   grammar0 stk = pdiag stk "grammar0";

fun (âgrammar1á:RT_ENTRY) (Parsed(PG_Grammar G) :: _ :: Parsed(PG_Prod P) :: _) =
							PG_Grammar (P::G)
|   grammar1 stk = pdiag stk "grammar1";

fun (âprod0á:RT_ENTRY) (Parsed(PG_Def D)::_::Token((_, V), _)::_) = PG_Prod(V, D)
|   prod0 stk = pdiag stk "prod0";

fun (âdef0á:RT_ENTRY) (Parsed(PG_OptAction act)::Parsed(PG_OptAlt alt)::_) =
							PG_Def[(alt, act)]
|   def0 stk = pdiag stk "def0";

fun (âdef1á:RT_ENTRY)
	(Parsed(PG_Def D)::_::Parsed(PG_OptAction act)::Parsed(PG_OptAlt alt)::_) =
							PG_Def((alt, act)::D)
|   def1 stk = pdiag stk "def1";

fun (âoptalt0á:RT_ENTRY) (Parsed alt::_) = alt
|   optalt0 stk = pdiag stk "optalt0";

fun (âoptalt1á:RT_ENTRY) _ = PG_OptAlt [];

fun (âalt0á:RT_ENTRY) (Parsed(PG_Symbol S)::_) = PG_OptAlt [S]
|   alt0 stk = pdiag stk "alt0";

fun (âalt1á:RT_ENTRY) (Parsed(PG_OptAlt alt)::_::Parsed(PG_Symbol S)::_) = PG_OptAlt (S::alt)
|   alt1 stk = pdiag stk "alt1";

fun (âsymbol0á:RT_ENTRY) (Token((_, V), _)::_) = PG_Symbol(VarClass V)
|   symbol0 stk = pdiag stk "symbol0";

fun (âsymbol1á:RT_ENTRY) (Token((_, V), _)::_) = PG_Symbol(PuncClass V)
|   symbol1 stk = pdiag stk "symbol1";

fun (âoptaction0á:RT_ENTRY) (Token((_, V), _)::_) = PG_OptAction V
|   optaction0 stk = pdiag stk "optaction0";

fun (âoptaction1á:RT_ENTRY) (_) = PG_OptAction "()";

=TEX
The following value bindings help to abbreviate the
description of the grammar. We think of the
terminals $NonTerminal$ and $Terminal$ as variables
and constants in the notation below.
=SML
local
val âGrammará = NonTerminal "Grammar";
val âProdná = NonTerminal "Prod";
val âNamá = Terminal BNF_var;
val âDefá = NonTerminal "Def";
val âAltá = NonTerminal "Alt";
val âSymbolá = NonTerminal "Symbol";
val âConá = Terminal BNF_con;
val âOptActioná = NonTerminal "OptAction";
val âOptAltá = NonTerminal "OptAlt";
val âActioná = Terminal BNF_action;
=TEX
We can now write down the agumented grammar for our BNF subset together with the
reduction table entries:
=SML
in
val âBNF_action_grammará : (BNF_lex_class, RT_ENTRY) ACTION_GRAMMAR = [
	("Grammar'", ([Grammar], grammar'0) :: nil),
	("Grammar", ([Prodn, Terminal BNF_semi], grammar0)
			:: ([Prodn, Terminal BNF_semi, Grammar], grammar1) :: nil),
	("Prod", ([Nam, Terminal BNF_eq, Def], prod0) :: nil),
	("Def", ([OptAlt, OptAction], def0) ::
		([OptAlt, OptAction, Terminal BNF_vert, Def], def1) :: nil),
	("OptAlt", ([Alt], optalt0) :: ([], optalt1):: nil),
	("Alt", ([Symbol], alt0) :: ([Symbol, Terminal BNF_comma, Alt], alt1):: nil),
	("Symbol", ([Nam], symbol0) :: ([Con], symbol1) :: nil),
	("OptAction", ([Action], optaction0) :: ([], optaction1) :: nil)
];
val âBNF_reduction_tableá
		: (BNF_lex_item, BNF_lex_class, P_GRAMMAR) REDUCTION_TABLE
		= make_reduction_table BNF_action_grammar;
val âBNF_grammará : (BNF_lex_class)GRAMMAR = strip_action BNF_action_grammar;
end;
=TEX
Once we have coded the lexical analyser for our action grammar concrete syntax
it will be easy to use the above functions to make an SLR(1) parser for
the input to our parser generator.
We adopt the convention that the first production in the grammar gives
the sentence symbol.
The resulting parser will compute
a value of type $P\_GRAMMAR$. Such a value may be used to compute a
grammar and a reduction table as follows (where from now on we
use a standard ``impossible'' nonterminal as a sentence symbol to augment
the grammar):
=SML
val âsentence_symbolá ="*Start*";
val âsentence_actioná ="(raise PARSER_ERROR\"invalid control\")";
=TEX
=SML
fun âmake_grammar_and_reduction_tableá (PG_Grammar(G as ((sen,_)::_)) : P_GRAMMAR)
			: SYM_CLASS GRAMMAR * string GEN_REDUCTION_TABLE = (
	let	val G' =  (sentence_symbol, [([VarClass sen], sentence_action)])::G;
		val nts = map fst G';
		fun make_sym(PuncClass s) = Terminal (PuncClass s)
		|   make_sym(VarClass s) =
			if s mem nts
			then NonTerminal s
			else Terminal(VarClass s);
		val Y = map (fn(x, y) => (x, map (fn (a,b) =>(map make_sym a, b)) y)) G';
		fun folder((def, alts), g) = g overwrite (def, lassoc4 g nil def rcup alts);
		val AG = revfold folder Y nil;
	in	(strip_action AG, make_reduction_table AG)
	end
) | make_grammar_and_reduction_table _ = raise SLRP_ERROR "invalid argument";
=TEX
\subsection{Lexical Analyser}
=TEX
The lexical analyser is very much a one-off.
It is called by the parser \cite{DS/FMU/IED/SML005}.
=TEX
subsection{Local Definitions}
Most of the lexical analyser is declared within this local block.
=SML
local

    exception âLEX_FAILá of string;

    val âord0á	= ord "0";
    val âord9á	= ord "9";
    val âordaá	= ord "a";
    val âordAá	= ord "A";
    val âordzá	= ord "z";
    val âordZá	= ord "Z";

=TEX
A state, $lex\_state$, is used by most of the lexical analysis
functions, it is in two parts.  First the characters not yet tokenised,
actually a list of strings of single characters produced by exploding
the input text.  Second the token immediately preceeding the first
part.  The token may not be recognised (yet) so the token part of the
state carries a success indicator.  On entry to an analysis function
the state will be ``$(chars, (UNKNOWN, \hbox{``''}))$''.
=SML
    datatype âsuccessá = âKNOWNá of BNF_lex_class | âCOMMENTá | âUNKNOWNá;

    type âtokená = success * string;

    type âlex_stateá  = (string list) * token;
=TEX
$collect$ adds the first character of the untokenised input text into the current token.
=SML
    fun âcollectá ( (cs, (cl, tk)) : lex_state ) : lex_state = (
        (tl cs, (cl, tk ^ (hd cs)))
    );
=TEX
The terminator characters for BNF are the following:
=SML
    val âterminatorsá : (string * BNF_lex_class) list =
	[(";", BNF_semi), ("=", BNF_eq), ("|", BNF_vert), (",", BNF_comma)];
=TEX
Quotes are introduced by the backquote character, \verb"`":
=SML
    val âquoterá : string = "`";

=SML
    fun ânext_is_termá (ch :: _) = any terminators (fn (c,_) => c = ch)
    |   next_is_term _ = false;

    fun ânext_is_quoterá (ch :: _) = ch = quoter
    |   next_is_quoter _ = false;

    fun ânext_is_spaceá (" " :: _) = true
    |   next_is_space ("\t" :: _) = true
    |   next_is_space ("\n" :: _) = true
    |   next_is_space _ = false;

    fun ânext_is_lbracká ("(" :: _) = true
    |   next_is_lbrack _ = false;
 
    fun ânext_is_rbracká (")" :: _) = true
    |   next_is_rbrack _ = false;
 
    fun âskip_spaceá (cs : string list) : string list = (
        if next_is_space cs
        then skip_space (tl cs)
        else cs
    );

    fun ânext_is_digitá ((ch :: _): string list) = (
        let
            val code = ord ch
        in
            (code >= ord0) andalso (code <= ord9)
        end
    ) | next_is_digit nil = false;
=TEX
We allow underscores and primes in names by treating them as letters:
=SML
    fun ânext_is_alphaá ((ch :: _): string list) = (
        let
            val code = ord ch
        in
            ((code >= orda) andalso (code <= ordz)) orelse
            ((code >= ordA) andalso (code <= ordZ)) orelse
            (ch = "_") orelse (ch = "'")
        end
    ) | next_is_alpha nil = false;
=TEX
Comments are enclosed in ``(*'' and ``*)''
=SML
	fun next_is_lcomment("(" :: "*" :: _) = true
	|   next_is_lcomment _ = false;

	fun next_is_rcomment("*" :: ")" :: _) = true
	|   next_is_rcomment _ = false;

     fun ânext_is_otherá (cs as (_ :: _) : string list) = (
        (not (next_is_term cs)) andalso
        (not (next_is_space cs)) andalso
        (not (next_is_digit cs)) andalso
        (not (next_is_alpha cs)) andalso
        (not (next_is_lcomment cs)) andalso
        (not (next_is_rcomment cs)) andalso
        (not (next_is_quoter cs))
    ) | next_is_other nil = false;
=TEX
To perform the analysis a number of recognisers of tokens are provided,
they are tried in turn on the input characters until one of them
recognises one of more of the input characters as a token.  Those
characters are then removed, classified and added to the output list of
tokens.  Then the recognisers are applied to the remaining input, and
so on until there is no more input.

Function $rec_alphanum_rest$ recognises a list of alpha numerics, it is
an auxiliary for the other recognisers.
=SML
    fun ârec_alphanum_restá (cs, tok) = (
	if next_is_alpha cs orelse next_is_digit cs
	then rec_alphanum_rest (collect (cs, tok))
	else (cs, tok)
    );

    fun ârec_terminatorá ( (cs, tk) : lex_state ) : lex_state = (
        if next_is_term cs
        then (tl cs, (KNOWN(lassoc3 terminators (hd cs)), hd cs))
        else (cs, (UNKNOWN, ""))
    );
=TEX
=SML
    fun ârec_identifierá( (cs, tok) : lex_state ) : lex_state = (
	if next_is_alpha cs 
	then rec_alphanum_rest (tl cs, (KNOWN BNF_var, hd cs))
	else (cs, tok)
    );
=TEX
A string starts and finishes with $quoter$.
Within a string the escape character `$\backslash$' may be used to
provide characters not normally available.  The input to this lexical
analyser is an SML string.  All character in an SML string between the
HOL start and end quote characters will be reguarded as the HOL string,
so the SML escape sequences may be used for most characters.  The HOL
escape character `$\backslash$' is therefore only needed for itself and
the start quote character.
=SML
    fun ârec_quoteá ( (cs, (_, tk)) : lex_state ) : lex_state = (
        let
            fun rec_quote_rest qtch (cs, tok) = (
		case cs of
		("\\" :: _ :: rest) =>
			rec_quote_rest qtch (collect (tl cs, tok))
		| ("\\" :: _) =>
			raise (LEX_FAIL "escaped character at end of string")
		| (ch :: rest) =>
			if (ch = qtch)
			then (rest, tok)
			else rec_quote_rest qtch (collect (cs, tok))
		| _ => raise (LEX_FAIL "unmatched quote")
            );
        in
            if next_is_quoter cs
            then rec_quote_rest(hd cs) (tl cs, (KNOWN BNF_con, ""))
            else (cs, (UNKNOWN, ""))
        end
    );
=TEX
Actions are distinguished by their starting with a left bracket and are
finished by the matching right bracket.
=SML
    fun ârec_action_restá i (cs, tok) = (
	if next_is_lbrack cs
	then rec_action_rest (i+1) (collect (cs, tok))
	else if next_is_rbrack cs
	then	if i <= 0
		then (collect (cs, tok))
		else rec_action_rest (i-1) (collect (cs, tok))
	else if not (is_nil cs)
	then rec_action_rest i (collect(cs, tok))
	else raise (LEX_FAIL "unmatched left bracket")
    );
=TEX
=SML
    fun ârec_actioná (cs, tok) = (
	if next_is_lbrack cs
	then rec_action_rest 0 (tl cs, (KNOWN BNF_action, hd cs))
	else (cs, (UNKNOWN, ""))
    );
=TEX
=TEX
Left and right comment symbols must balance. $rec\_comment\_rest$ arranges for this:
=SML
   fun ârec_comment_restá i cs = (
	if next_is_lcomment cs
	then rec_comment_rest (i+1) (tl(tl cs))
	else if next_is_rcomment cs
	then	if i <= 0
		then (tl(tl cs), (COMMENT, ""))
		else rec_comment_rest (i-1) (tl(tl cs))
	else if not (is_nil cs)
	then rec_comment_rest i (tl cs)
	else raise (LEX_FAIL "unmatched comment symbol")
    );
=TEX
=SML
    fun ârec_commentá (cs, tok) = (
	if next_is_lcomment cs
	then rec_comment_rest 0 (tl(tl cs))
	else (cs, (UNKNOWN, ""))
    );
=TEX
Function $next\_token$ applies recogniser functions to the input
characters, returning the results of the first successful recogniser,
or an indicator of token unknown.
=SML
    fun ânext_tokená (recognisers : (lex_state -> lex_state) list)
                   (chars       : string list) : lex_state = (
        let
            fun try (recogniser : lex_state -> lex_state,
                     (cs, (cl, tk)) : lex_state) : lex_state = (case cl of
            UNKNOWN => recogniser(cs, (cl, tk))
          |  _ => (cs, (cl, tk))
    );
        in
            revfold try recognisers (chars, (UNKNOWN, ""))
        end
    );
=TEX
Function $tokenise$ converts the input characters into tokens by
repeatedly using $next\_token$ to identify the start of the remaining
part of the input.
=SML
    fun âtokeniseá (recognisers : (lex_state -> lex_state) list)
                 (chars       : string list) : BNF_lex_item list = (
       case skip_space chars
       of
           nil => nil
       |   cs as (_::_) => (
           let
               val (cs', tk) = next_token recognisers cs;
           in
               case tk of
                   (KNOWN cls, tk) => (cls, tk):: tokenise recognisers cs'
	      |	   (COMMENT, _) => tokenise recognisers cs'
              |    (UNKNOWN, tk) =>  raise LEX_FAIL (": did not recognise: " ^ tk)
           end
       )
    );
=TEX
The various recognisers are gathered together in their order of application.
=SML
    val ârecognisersá = [rec_terminator,
                       rec_quote,
                       rec_identifier,
			rec_comment,
			rec_action];
in
=TEX
The interface to the lexical analyser is the following function.
=SML

    fun âBNF_lex_stringá (text : string) : BNF_lex_item list = (
	(tokenise recognisers (explode text))
	handle (LEX_FAIL msg) => (
            output(std_out, "Lexical analysis error:" ^ msg ^ "\n");
            nil
        )
    );
=TEX
That completes the lexical analyser:
=SML
end; (* of local ... in ... end *)
=TEST
BNF_lex_string "";
BNF_lex_string "a|,b";
BNF_lex_string "=|,`abc`";
BNF_lex_string "=|,`abc\\``";
BNF_lex_string "(=|,)`abc\\``";
BNF_lex_string "(=|,`abc\\``";
BNF_lex_string "(=|,`abc\\``) (((b(((a)))b)))";
BNF_lex_string "(* A C (* B C *) *) () () (jj)";
=TEX
\subsection{Parser Auxiliaries}
=SML
val âBNF_classifyá : BNF_lex_item -> BNF_lex_class = fst;
=TEX
=SML
val âBNF_errorá : (BNF_lex_item, BNF_lex_class, 'a) ERROR_ROUTINE =
					default_error format_BNF_lex_item;
=TEX
=SML
val âBNF_end_of_stringá : BNF_lex_item = (BNF_eos, "<End-of-Input>");
=TEX
=SML
fun BNF_reader (toks : BNF_lex_item list) : BNF_lex_item  * BNF_lex_item list = (
	case toks of
		(h :: more) => (h, more)
	|	[] => (BNF_end_of_string, [])
);
=TEX
=SML
val (BNF_actions, BNF_gotos, BNF_Ijs, BNF_init) =
					slr_tables BNF_grammar BNF_eos "Grammar'";
=TEX
The grammar has no conflicts so we may safely use the default
resolver to form a parser, which we set up to take its input from a file:
=SML
fun âBNF_parseá (file : string) : SYM_CLASS GRAMMAR * string GEN_REDUCTION_TABLE =
	make_grammar_and_reduction_table(
		slrp'parse
		BNF_init BNF_actions BNF_gotos BNF_reduction_table default_resolver
		BNF_classify BNF_error  BNF_reader
		(BNF_lex_string(read_file file)));
=TEX
The formatter for $sym\_class$ values is the following:
=SML
fun âformat_sym_classá (VarClass V) = V
|   format_sym_class (PuncClass P) = "`" ^ P ^ "`";
=TEST
fun dump_string file string = (
	let	val os = open_out file;
	in	(output(os, string); close_out os)
	end
);
dump_string "slr.tst""E = E, `+`, T | T; T = T, `*`, F | F; F = `(`, E, `)` | id;";

val (test_grm1, test_rt1) = BNF_parse "slr.tst";
val (actions1, gotos1, Ijs, init) = slr_tables test_grm1 (PuncClass "$") sentence_symbol;

print_states (test_grm1, format_sym_class) Ijs;
listofarray actions1;
listofarray gotos1;
conflicts actions1 (* shouldn't be any *);

dump_string "slr.tst""E = A | B; A = x | x, A; B = | x, B;";
val (test_grm2, test_rt2) = BNF_parse "slr.tst";

val (actions2, gotos2, Ijs2, init2) = slr_tables test_grm2 (PuncClass "$") sentence_symbol;
print_states (test_grm2, format_sym_class) Ijs2;

conflicts actions2;

=TEX
\section{CONFLICT RESOLUTION}\label{CONFLICTRESOLUTION}
=TEX
To resolve a reduce/reduce conflict we need to choose an alternative in
the list of possible alternatives by which to reduce. We choose
the one which appears earliest in the grammar.
=SML
fun âresolve_reduce_reduceá (g : ('lc)GRAMMAR) (acts : ACTION list) : ACTION list = (
	let	fun folder
			(x2 as Reduce(((nt2, alt2), _)), x1 as Reduce(((nt1, alt1), _))) = (
			let	fun index nt i ((nt', _)::more) = (
					if nt = nt'
					then i
					else index nt (i+1) more
				) | index _ _ [] = raise SLRP_ERROR "invalid non-terminal";
				val (i1, i2) = (index nt1 0 g, index nt2 0 g);
			in	if i1 = i2
				then	if alt1 <= alt2
					then x1
					else x2
				else if i1 <= i2
				then x1
				else x2
			end
		) | folder (x1, _) = x1;
		val winner = fold folder acts (find acts (fn Reduce _ => true | _ => false));
	in	acts drop (fn (x as (Reduce _)) => x <> winner | _ => false)
	end	handle Fail _  => acts
);
=TEX
After resolving reduce/reduce conflicts only shift/reduce conflicts
with a single shift and a single reduce will remain (the SLR(1) algorithm
cannot produce shift/shift conflicts).
The shift/reduce conflicts are replaced by dynamic actions
and we shout loudly when we do this.

The following functions are used to do the shouting:
=SML
fun âformat_actioná (gp : (''lc) GRAMMAR * (''lc -> string)) (act : ACTION) : string = (
	case act of
		Accept => "Accept"
	|	Error => "Error"
	|	Shift i => "Shift to " ^ string_of_int i
	|	Reduce(alt, _) => "Reduce by " ^ format_alt gp alt
	|	Dynamic (i, (alt, _)) => "Either shift to " ^ string_of_int i
					^ " or reduce by " ^ format_alt gp alt
);
=TEX
=SML
fun âprint_actionsá (put : string -> unit)
	(gp as (_, p) : (''lc) GRAMMAR * (''lc -> string))
	(lc : ''lc, s : STATE, acts : ACTION list) : unit = (
	put("State " ^ string_of_int s ^ " on symbol " ^ p lc ^ "\n");
	map put (alpha_sort(map(fn act => ("\t" ^ format_action gp act ^ "\n")) acts));
	()
);
=TEX
=SML
fun âprint_action_tableá (put : string -> unit)
	(gp as (_, p) : (''lc) GRAMMAR * (''lc -> string))
	(actions : (''lc)ACTION_TABLE) : unit = (
	let	open Array;
		fun aux1 i ((lc, act) :: more) = (
			(lc, i, act :: map snd (more drop (fn (lc', _) => lc' <> lc)))
				:: aux1 i (more drop (fn (lc', _) => lc' = lc)) 
		) | aux1 _ [] = [];
		val actionl = flat(map (fn i => aux1 i (sub(actions, i)))
			(interval 0 (length actions - 1)));
	
	in map (print_actions put gp) actionl; ()
	end
);
=TEX
=SML
fun âprint_conflictsá (put : string -> unit)
	(gp as (_, p) : (''lc) GRAMMAR * (''lc -> string))
	(confs : (''lc * STATE * (ACTION list)) list) : unit = (
	map (print_actions put gp) confs; ()
);
=TEX
=SML
fun âprint_dynamic_actionsá (put : string -> unit)
	(gp as (_, p) : (''lc) GRAMMAR * (''lc -> string))
	(actions : (''lc)ACTION_TABLE) : unit = (
	let	open Array;
		fun aux1 i ((lc, act as Dynamic _) :: more) = (
			(lc, i, [act]) :: aux1 i more
		) | aux1 i ((_, _)::more) = ( aux1 i more
		) | aux1 _ [] = [];
		val actionl = flat(map (fn i => aux1 i (sub(actions, i)))
			(interval 0 (length actions - 1)));
	
	in map (print_actions put gp) actionl; ()
	end
);
=TEX
=SML
fun âhas_rrá (Reduce _ :: more : ACTION list) : bool = (
	any more (fn Reduce _ => true |_ =>  false)
) | has_rr (_ :: more ) = has_rr more
|   has_rr [] = false;
=TEX
=SML
fun âhas_srá (Reduce _ :: more : ACTION list) : bool = (
	any more (fn Shift _ => true |_ =>  false)
) | has_sr (Shift _ :: more : ACTION list) : bool = (
	any more (fn Reduce _ => true |_ =>  false)
) | has_sr (_ :: more ) = has_sr more
|   has_sr [] = false;
=TEX
=SML
fun âconflict_summaryá (confs : ('lc * STATE * ACTION list) list) : string = (
	let	val tot = length confs;
		val rrs = count confs (fn (_, _, acts) => not(has_sr acts));
		val srs = tot - rrs;
	in	(so_many true tot "conflict" ^ " detected") ^ 
		(if tot <> 0
		then ((" (" ^ string_of_int srs ^ " shift/reduce, "
			^ string_of_int rrs ^ " reduce/reduce)"))
		else "") ^ "\n"
	end
);
=TEX
=SML
fun âresolve_eitherá(g : ('lc)GRAMMAR) (acts : ACTION list) : ACTION = (
	let	val acts' = if has_rr acts then resolve_reduce_reduce g acts else acts;
	in	case acts' of
			[(act1 as Reduce x), (act2 as Shift s)] => Dynamic(s, x)
		|	[(act1 as Shift s), (act2 as Reduce x)] => Dynamic(s, x)
		|	[act] => act
		|	other => raise SLRP_ERROR "failure in conflict resolution"
	end
);
=TEX
=SML
fun âresolve_conflictsá (g : (''_lc)GRAMMAR) (actions : (''_lc)ACTION_TABLE) : unit = (
	let	fun aux(lc, s, acts) = (
			let	val old = Array.sub(actions, s);
				val act = resolve_either g acts;
				val new = old drop (fn (lc', _) => lc = lc');
			in	Array.update(actions, s, new overwrite (lc, act))
			end
		);
	in	case conflicts actions of
			[] => ()
		|	todo => (map aux todo; ())
	end 
);
=TEX
\section{OUTPUT ROUTINES}\label{OUTPUTROUTINES}
=SML
local
val âout_fileá : outstream ref = ref std_out;
val âcursorá : int ref = ref 0;
in
=TEX
=SML
fun âopen_outfileá (file : string) : unit = (
	(if file <> ""
	then out_file := open_out file
	else raise SLRP_ERROR "an empty filename is not allowed for the output file")
	handle Io msg =>
	raise SLRP_ERROR("i/o failure on output file: " ^ file ^ " (" ^ msg ^ ")")
);
=TEX
=SML
fun âclose_outfileá () : unit = (
	close_out (!out_file)
);
=TEX
=SML
fun âput_stringá (s:string):unit = ((
	let	val len = size s;
		val next = !cursor + len;
	in	if next <= 80
		then (
			output(!out_file, s);
			cursor := next
		) else (
			output(!out_file, "\n");
			output(!out_file, s);
			cursor := size s
		)
	end
)	handle Io msg =>
	raise SLRP_ERROR("i/o failure on output file (" ^ msg ^ ")")
);
fun put_line (s:string):unit = ((
	output(!out_file, s);
	output(!out_file,"\n");
	cursor := 0
)	handle Io msg =>
	raise SLRP_ERROR("i/o failure on output file (" ^ msg ^ ")")
);
end; (* of local ... in ... end *)
=SML
fun âput_listá (sep : string) (s : string list) = (
	case s of
		x :: [] => put_string x
	|	x :: more => (put_string x; put_string sep; put_list sep more)
	|	[] => ()
);
=TEX
\subsection{Action Table}
=SML
fun âformat_action_entryá (p : ''lc -> string) (lc : ''lc, act : ACTION) : string = (
	"(" ^ p lc ^ "," ^ (
		case act of
			Shift s => (
				"Shift " ^ string_of_int s
		) |	Reduce ((nt, alt), n) => (
				"Reduce((\"" ^ nt ^ "\"," ^ string_of_int alt
				^	"),"^string_of_int n ^ ")"
		) |	Dynamic (s, ((nt, alt), n)) => (
				"Dynamic(" ^ string_of_int s ^ "," ^
				"((\"" ^ nt ^ "\"," ^ string_of_int alt ^ "),"^string_of_int n ^ "))"
		) |	Error => ("Error"
		) |	Accept => ("Accept"
		)
	) ^ ")"
);
=TEX
=SML
fun âoutput_action_entry_listá(p : ''lc -> string) (entries : (''lc * ACTION) list) : unit = (
	put_string "[";
	put_list "," (map (format_action_entry p) entries);
	put_string "]"
);
=TEX
=SML
fun âoutput_action_tableá (p : ''lc -> string) (actions : (''lc)ACTION_TABLE) : unit = (
	let	val tab = listofarray actions;
		fun aux (x :: []) = output_action_entry_list p x
		| aux (x :: more) = (output_action_entry_list p x; put_string ","; aux more)
		| aux [] = ();
	in	put_line "val slrp'actions = Array.arrayoflist[";
		aux tab;
		put_line "];"
	end
);
=TEX
=SML
fun âdo_sym_classá(VarClass x : SYM_CLASS) : string = x
|   do_sym_class(PuncClass x) = x;
=TEST
output_action_table do_sym_class actions3;
=TEX
\subsection{Goto Table}
=SML
fun âformat_goto_entryá (nt : string, s : STATE) : string = (
	"(\"" ^ nt ^ "\"," ^ string_of_int s ^ ")"
);
=TEX
=SML
fun âoutput_goto_entry_listá ( entries : (string * STATE) list) : unit = (
	put_string "[";
	put_string (format_list format_goto_entry entries ",");
	put_string "]"
);
=TEX
=SML
fun âoutput_goto_tableá (gotos : GOTO_TABLE) : unit = (
	let	val tab = listofarray gotos;
		fun aux (x :: []) = output_goto_entry_list x
		| aux (x :: more) = (output_goto_entry_list x; put_string ","; aux more)
		| aux [] = ();
	in	put_line "val slrp'gotos = Array.arrayoflist[";
		aux tab;
		put_line "];"
	end
);
=TEX
=TEST
output_goto_table gotos3;
=TEX
\subsection{Reduction Table}
=SML
fun âformat_reducerá (body : string) (n : int) : string = (
	let	val is = map string_of_int(rev (interval 1 n));
		fun do1 i = "x" ^ i;
		val xs = format_list do1 is "::";
	in	if n = 0
		then
	"(fn _ =>" ^ body ^ ")"
		else
	"(fn(" ^ xs ^ "::_)=>" ^ body ^ "|_=>raise PARSER_ERROR\"invalid reduction\")"
	end
);
=TEX
=SML
fun âoutput_reduction_tableá
	(g: (''lc) GRAMMAR)
	(tab : string GEN_REDUCTION_TABLE) : unit = (
	let	fun aux1 nt i (act :: more) = (
			let	val n = length(my_nth(expand g (NonTerminal nt)) i);
				val func = format_reducer act n;
			in	if is_nil more
				then put_string func
				else (put_string(func ^ ","); aux1 nt (i+1) more)
			end
		) | aux1 _ _ [] = ();
		fun aux2 last (nt, acts) = (
			put_string("(\"" ^ nt ^ "\",[");
			aux1 nt 0 acts;
			put_string(if last then "])" else "]),")
		);
		fun aux3 (row :: more) = (
			if is_nil more
			then aux2 true row
			else(aux2 false row; aux3 more)
		) | aux3 [] = ();
	in	put_string "val slrp'reducers = list_e_merge initial_e_dict";
		put_line "["; aux3 (e_flatten tab); put_line "];"
	end
);
=TEST
output_reduction_table test_grm3 test_rt3;
=TEX
\subsection{Driver Function}
=SML
fun âoutput_driverá (init : STATE) = (
	put_line
	("val slrp'gen_parser = slrp'parse "
	^ string_of_int init ^ " slrp'actions slrp'gotos slrp'reducers;")
);
=TEST
output_driver 42;
=TEX
\subsection{Interface}
=SML
fun âoutput_parserá
		(p : ''lc -> string) 
		(g : (''lc) GRAMMAR)
		(actions : (''lc) ACTION_TABLE)
		(gotos : GOTO_TABLE)
		(tab : string GEN_REDUCTION_TABLE)
		(init : STATE) : unit = (
	output_action_table p actions;
	output_goto_table gotos;
	output_reduction_table g tab;
	output_driver init
);
=TEST
=TEX
\section{INTERFACE} \label{INTERFACE}
The parser generator is invoked using the following function $slrp$.
Its first three parameters are the names of the input file, output file and
log file. The fourth parameter is the name of the
end of input lexical class.
The remaining parameter is an integer which determines the level
of log information as follows:

\begin{centering}
\begin{tabular}{|l|p{4in}|}\hline
Level & Information Logged \\ \hline\hline
$\leq 0$ & The log file parameter is ignored. \\ \hline
$1$ & This gives a summary of the conflict
resolution process and a listing of any conflicts requiring
dynamic resolution. \\ \hline
$2$ & As 1 together with a listing
of the grammar and its terminals and the state table and a listing of any conflicts
before resolution. \\ \hline
$\geq 3$ & As 2 together with a listing of the full action table before resolution. \\ \hline
\end{tabular}
\end{centering}
=SML
=SML
fun âslrpá {infile : string, outfile : string, logfile : string, eos:string, loglevel:int} : unit = (
	let	fun my_log msg = (if loglevel > 0 then log msg else ());
	in let	val se1 = chat(burst banner);
		val se2 = (open_outfile outfile;
			if loglevel > 0 then open_logfile logfile else ());
		val se3 = my_log (burst banner);
		val (grm, reducers) = BNF_parse infile;
		val (actions, gotos, Ijs, init) = slr_tables grm (PuncClass eos) sentence_symbol;
		val se4 = (if loglevel >= 2
			then (	log "\n"; log(burst "Grammar"); log"\n";
				print_grammar format_sym_class grm;
				log "\n"; log(burst "Terminal Symbols"); log"\n";
				print_terms format_sym_class grm;
				log "\n"; log(burst "State Table"); log"\n";
				print_states (grm, format_sym_class) Ijs)
			else ());
		val confs = conflicts actions;
		val conf_msg = conflict_summary confs;
		val se6 = (if loglevel >= 2
			then (	log "\n"; log(burst "Conflicts"); log"\n";
				chat conf_msg;
				my_log conf_msg; my_log "\n";
				print_conflicts log (grm, format_sym_class) confs)
			else(chat conf_msg; my_log"\n"; my_log conf_msg));
		val se7 = (if loglevel >= 3
			then (	log "\n"; log(burst "Action Table"); log"\n";
				print_action_table log (grm, format_sym_class) actions)
			else());
		val se8 = (if not(is_nil confs)
			then resolve_conflicts grm actions
			else ());
		val se9 = (if not(is_nil confs)
			then (	my_log "\n"; my_log(burst "Dynamic Actions"); my_log"\n";
				print_dynamic_actions my_log (grm, format_sym_class) actions;
				chat(burst "Dynamic Actions");
				print_dynamic_actions chat (grm, format_sym_class) actions)
			else());
		val se11 = output_parser do_sym_class grm actions gotos reducers init;
		val se12 = (chat (burst "End of Run"); my_log "\n"; my_log (burst "End of Run"));
	in	(close_logfile(); close_outfile())
	end	handle SLRP_ERROR msg =>
		(chat "*** ERROR "; chat msg; chat "\n";
		 my_log "*** ERROR "; my_log msg; my_log "\n")
	end
);
=TEX
=SML
end; (* of structure Slrp *)
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
=TEST
fun dump_string file string = (
	let	val os = open_out file;
	in	(output(os, string); close_out os)
	end
);

dump_string "slr.tst"(
"E	= E, `Plus`, T (add x1 x3)			\n" ^
"	| T (fetch x1);			\n" ^
"T	= T, `Times`, F (mul x1 x3)		\n	" ^
"	| F (fetch x1);\n" ^
"F	= `Lbrack`, E, `Rbrack` (fetch x2)	\n		" ^
"	| Num (conv x1);			\n");


datatype LC3 = Plus | Times | Lbrack | Rbrack | Num | Eos | Wrong;
open SlrpDriver;

fun add (Parsed (x:int)) (Parsed (y:int)) = x + y
|   add _ _ = raise PARSER_ERROR "corrupt stack";
fun mul (Parsed (x:int)) (Parsed (y:int)) = x * y
|   mul _ _ = raise PARSER_ERROR "corrupt stack";
fun fetch (Parsed (x:int)) = x
|   fetch _= raise PARSER_ERROR "corrupt stack";
fun conv (Token (n:string, _)) = nat_of_string n
|   conv _ = raise PARSER_ERROR "corrupt stack";
val resolver3 = default_resolver;
val error3 = default_error Combinators.I;
fun lex3 (s : string) : string list = (
	let	val chars = explode s;
		fun get_num acc (x :: more) = (
			if is_all_decimal x
			then get_num (acc ^ x) more
			else (acc, x :: more)
		)  | get_num acc [] = (acc, []);
		fun get_tok (x :: more) = (
			if is_all_decimal x
			then let val (num, rest) = get_num x more
			in	num :: get_tok rest
			end else if x = " "
			then get_tok more
			else x :: get_tok more
		) | get_tok [] = []
	in	get_tok chars
	end
);
fun reader3 (ip : string list) : string * string list = (
	case ip of
		(h :: more) => (h, more)
	|	[] => ("<end-of-input>", [])
);
fun classify3 "*" = Times
|   classify3 "+" = Plus
|   classify3 "(" = Lbrack
|   classify3 ")" = Rbrack
|   classify3 "<end-of-input>" = Eos
|   classify3 Other = if is_all_decimal Other then Num else Wrong;
Slrp.slrp {infile="slr.tst", outfile="slr.sml", logfile ="slr.log", eos ="Eos", loglevel=2};
open EfficientDictionary;
PolyML.use"slr.sml";
val parser3 = slrp'gen_parser resolver3 classify3 error3 reader3 o lex3;

parser3"1001+42";
parser3"1001 * 42";
parser3"(1001)";
parser3"1001";
parser3"(1*(2*(3*(4*(5*(6*(7*8)))))))";
parser3"(((((((1+2)+3)+4)+5)+6)+7)+8)";
parser3"((((((1+2)+3)+4)+5)+6)+7)+8)" (* error case *);
parser3"((((((((((1+2)+3)+4)+5)+6)+7)+8)" (* error case *);

Slrp.slrp {infile="", outfile="boo", logfile ="goo", eos ="Eos", loglevel=42};
Slrp.slrp {infile="/dev/null", outfile="boo", logfile ="goo", eos ="Eos", loglevel=42};

dump_string "slr.tst"(
"E	= E, `sub`, E, `sup`, E		\n" ^
"	| E, `sub`, E			\n" ^
"	| E, `sup`, E			\n" ^
"	| `{`, E, `}`;			\n");

Slrp.slrp {infile="slr.tst", outfile="slr.sml", logfile ="slr.log", eos ="Eos", loglevel=2};


