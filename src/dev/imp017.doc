=IGN
********************************************************************************
imp017.doc: this file is part of the PPDev system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
N.B. sieve may warn about "val ÛbannerÝ : string = ... " line 
Don't worry about this!
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{SLR Parser Generator}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP017}  %% Mandatory field
\def\SCCSversion{$Revision: 1.38 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
%\TPPauthor{}  %% Mandatory field
\TPPauthors{R.D.~Arthan & WIN01\\D.J.King&WIN01}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
A simple SLR parser generator is implemented.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.14] Initial Versions

\item[Issue 1.15 (21 January 1992)]
Performance improvements made. Introduced an
efficient representation of the grammar, and support
for sets and sets of set as ordered lists. This
gives a ten-fold improvement in performance.

\item[Issue 1.16 (22 January 1992)]
Textual content brought into line with changes to
the code. Also, modification made to the
code which generates the action table. The table
now compiles about 5 times faster than before.
\item[Issue 1.17 (27 January 1992)] Made $make\_items$ use new $rcup''$ operation and amended
computation of $init\_state$ in $slr\_tables$.
\item[Issue 1.18 (27 January 1992)] Changed $maprcup''$ to sort the results after they
are computed (using $Sort.sort$).
\item[Issue 1.19 (4 February 1992)] Changed type of
$BNF\_error$ in accordance with changes made to the parser
driver error handling mechanism.
\item[Issue 1.20 (4 February 1992)] Fixed a syntax error
in $maprcup''$!.
\item[Issue 1.21 (1 April 1992)] Fixed an error in the
printing of syntax errors in the input, whereby the symbol
rejected was never printed in the message reported to
the user. Also, the parse stack is now available to the
actions description in the input grammar under the name
$stk$, together with the existing names $x1$, $x2$ etc.
\item [Issue 1.22 (13th April 1992)]
Changes due to CR0017.
\item [Issue 1.23 (27th April 1992)]
The goto and reducer tables produced are now structured like the action tables of
version 1.16 and following of this document;
i.e., each table entry is assigned to a Standard ML
variable name, and the table is constructed by conjoining
the table entries.
\item [Issue 1.24 (26th May 1992)]
Renamings from version 1.5 of DS/FMU/IED/WRK038.
\item[Issue 1.25 (8th February 1999)] Updates for SML'97.
\item[Issue 1.26 (17th February 1999)] Corrected missing comma in reduction-table output code.
\item[Issue 1.27 (21st April 1999)] New strategy for code to generate tables to circumvent SML-NJ compile-time problem.
\item[Issues 1.28,1.29 (1st August 2000)]
A shell script to run the parser generator has been added and the error handling
of the ML interface has been rationalised to facilitate this --- after reporting
an error, the interface now raises an exception that can be trapped by the
code piped in from the script.
\item[Issues 1.30]
Port to Poly/ML.
\item[Issue 1.31] Copyright and banner updates for open source release.
\item[Issue 1.32] PPDev-specific updates for open source release
\item[Issue 1.33] Removed misplaced comment in the shell script.
\item[Issue 1.34] Improved {\it LaTeX} layout.
\item[Issues 1.35, 1.36] Tidy-up in preparation for implementing calculation of LALR(1) lookahead sets.
\item[Issue 1.37] Now calculates LALR(1) lookahead sets when the SLR(1) algorithm results in conflicts.
\item[Issues 1.38, 1.39] Added option to print out the LR(0) automaton and tidied up some
of the printing code.
\end{description}
\subsection{Changes Forecast}
None.

\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of the SLR(1)/LALR(1) parser generator
the detailed design of which is given in \cite{DS/FMU/IED/DTD017}.
\subsection{Introduction}
\cite{DS/FMU/IED/DTD017} gives a ``black box'' description of the parser
generator.
For historical reasons, and because it is quite a sensible and efficent design,
we first use the SLR(1) algorithm and only calculate the LALR(1) lookahead
if this gives rise to conflicts.
The SLR(1) implementation given here follows the treatment
in \cite{Aho77} fairly closely and the reader of this document is assumed
to be familiar with sections 6.1, 6.2 and 6.3 of that book. 
The calculation of LALR(1) lookahead sets is based on the excellent treatment
of \cite{Bermudez89}.
The key point, not stated explicitly in \cite{Aho77}, is that the LALR(1) states
are the same as the SLR(1) states as are the shift transitions while the
LALR(1) reduce transitions are a subset of the SLR(1) ones.
The approach to calculating them in \cite{Bermudez89} is based on repeating
parts of the SLR(1) calculations on a transformed grammar, which we
will call the state transition grammar or STG.
After beginning the definition of the structure $Slrp$ in section
\ref{PREAMBLE},
the implementation proper starts in section \ref{UTILITIES}
which collects together some
utilities needed throughout the material which follows.

In sections \ref{SLRTABLECOMPUTATION} and
\ref{DIAGNOSTICUTILITIES}, we define
the SLR(1) table construction algorithm together with some useful functions
for formatting the tables for inspection.
In section \ref{BNFPARSER} we apply the SLR(1) algorithm to construct a
parser for the extended BNF described in \cite{DS/FMU/IED/DTD017}.
Section \ref{CONFLICTRESOLUTION} contains further material for manipulating
the tables to resolve conflicts.
Section \ref{OUTPUTROUTINES} contains functions to write the tables out to
the output file (as fragments of Standard ML).

Finally, section \ref{INTERFACE} pulls all the earlier pieces together to
give the function {\it slrp} which is the ML user interface to the parser
generator and the {\it slrp} shell script which can be used to call it from make-files etc.

\subsection{Dependencies}
The code is dependent on \cite{DS/FMU/IED/DTD018}.
It also depends on the makefile (or a developer working interactively) to
define two strings at the ML top level: {\it system\_version} and {\it copyright}.

\section{PREAMBLE}\label{PREAMBLE}
=TEX
=SML
infix 4 rgrab;
infix 4 rcup;
infix 4 rcup';
infix 4 rcup'';
infix 4 rgrab';
structure ÛSlrpÝ : Slrp = struct
=TEX
The following banner is written to the log file and to standard output
whenever the parser generator is run.
=SML
val ÛbannerÝ : string = "SLRP Parser Generator  " ^ product_version ^ "  " ^ copyright;
=TEX
=SML
open EfficientDictionary SlrpDriver;
=TEX
The following exception is raised in the event of, e.g., i/o errors.
It is caught in {\it slrp} and so is never visible to the user.
=SML
exception ÛSlrpErrorÝ of string;
=TEX
The action, goto and reduction tables produced are constructed out of lists.
The length of those lists is configurable by changing the value of the reference
variable $slrp\_break$ defined below. Changing its value can have a significant
effect on the speed of compilation of these tables (apparent when building a parser).
This effect is compiler-dependent (and SML/NJ is more troublesome than Poly/ML).
The best compromise with the current compilers has been found to be when $slrp\_break$ is $1$.
=SML
val Ûslrp_breakÝ = ref 1;
val _ = if contains (map fst (get_int_controls()))
			"slrp_break"
	then	()
	else	new_int_control{name="slrp_break",
			control=slrp_break,
			default=(fn x => 1),
			check=(fn x =>
				if x > 0 then true
				else raise SlrpError
				  "slrp_break must be a positive number")
	};
=TEX
\section{UTILITIES}\label{UTILITIES}
\subsection{Miscellany}
In order to make the output from the program more easily understood
it is helpful to have (i) a version of $grab$ which adds the new element
at the end of the list, and (ii) a version of $cup$ which accumulates its
second operand into its first:
=SML
fun (xs : ''a list) ÛrgrabÝ (what : ''a) = (
	if	what mem xs
	then	xs
	else	xs @ [what]
);
=TEX
=SML
fun (list1 : ''a list) ÛrcupÝ (list2 : ''a list) : ''a list = (
	revfold (fn(x, xs) => xs rgrab x) list2 list1
);
=TEX
The following formulation of $nth$ is more natural here:
=SML
fun ÛkthÝ (xs : 'a list) : int -> 'a = switch nth xs;
=TEX
=SML
val Ûalpha_sortÝ = Sort.sort Sort.string_order;
=TEX
Given a list return the index of its last element (or ~1 for an empty list):
=SML
fun ÛboundÝ (list : 'a list)  : int = length list - 1;
=TEX
Count the elements of a list with a given property:
=SML
fun ÛcountÝ (list : 'a list) (prop : 'a -> bool): int = (
	let	fun aux n (a :: more) = (
			if prop a
			then aux (n+1) more
			else aux n more
		) | aux n _ = n;
	in	aux 0 list
	end
);
=TEX
Coerce an array into a list:
=SML
fun ÛlistofarrayÝ (Xs : 'a PPArray.array) : 'a list = (
	let	open PPArray;
		val len = length Xs;
	in	map (fn i => PPArray.sub (Xs, i)) (interval 0 (len-1))
	end
);
=TEX
The following function chops an array up into lists of a given length (or at most the given length
in the case of the last list).
=SML
fun ÛlistsofarrayÝ (Xs : 'a PPArray.array) (listsize : int) : 'a list list = (
let	open PPArray;
	val len = length Xs;
	fun aux start = (
	let	val last = start + listsize;
		val ext' = if last >= len
			then len
			else last;
	in
		map (fn i => PPArray.sub (Xs, i)) (interval start (ext'-1))
	end);
	val nlists = (len-1) div listsize;
	val stl  = fold (fn (i, acc) => i*listsize::acc)
		(interval 0 nlists) [];
in	map aux stl
end
);
=TEX
The following function does the same job as {\it listsofarray} but with the input given as
a list rather than an array.
=SML
fun ÛlistsoflistÝ xs listsize = (
let	fun aux (xs, res) = (
	let	val left = xs to listsize-1;
		val right = xs from listsize;
	in
		case left of
		[]	=> res
		|left'	=> aux (right, res@[left])
	end);
in
	fold aux [xs] []
end);
=TEX
\subsection{I/O and Formatting Utilities}
=SML
fun Ûso_manyÝ (true:bool) (0 : int) (thing : string) : string = "No " ^ thing ^ "s"
|   so_many false (0 : int) (thing : string) : string = "no " ^ thing ^ "s"
|   so_many _ 1 (thing : string) : string = "1 " ^ thing 
|   so_many _ n (thing : string) : string = string_of_int n ^ " " ^ thing ^ "s";
=TEX
=SML
fun ÛburstÝ (s : string) : string = "+++ " ^ s ^ " +++\n";
=TEX
=SML
fun ÛchatÝ (msg : string) = (output(std_out, msg));
=TEX
=SML
fun Ûread_fileÝ ("": string) : string = 
	raise SlrpError "an empty filename is not allowed for the input file"
|   read_file (file : string) = (
	let	val ip = open_in file;
		fun aux () = (
			let	val whatgot = input(ip, 512)
			in	if size whatgot = 512
				then whatgot :: aux ()
				else [whatgot]
			end
		);
		val res = implode(aux());
	in	close_in ip; res
	end	handle ex as Io _ =>
		raise SlrpError
			("i/o failure on input file: " ^ file ^ " (" ^ string_of_exn ex ^ ")")
);
=TEST
read_file "" (* FAILS *);
read_file "/AARDVARK" (* FAILS *);
read_file "/etc/passwd";
let val str = read_file "slr.doc" in chat str end;
=SML
local
val Ûlog_fileÝ : outstream OPT ref = ref Nil;
in
=TEX
=SML
fun Ûopen_log_fileÝ (file : string) : unit = (
	(if file <> ""
	then log_file := Value(open_out file)
	else ())
	handle ex as Io _ =>
	raise SlrpError("i/o failure on log file: " ^ file ^ " (" ^ string_of_exn ex ^ ")")
);
=TEX
=SML
fun Ûflush_log_fileÝ () : unit = (
	case !log_file of
		Value s => ExtendedIO.flush_out s
	|	Nil => ()
	
);
=TEX
=SML
fun Ûclose_log_fileÝ () : unit = (
	case !log_file of
		Value s => close_out s
	|	Nil => ()
);
=TEX
=SML
fun ÛlogÝ (msg : string) = (
	(case !log_file of
		Value s => output(s, msg)
	|	Nil => output(std_out, msg))
	handle ex as Io _ =>
	raise SlrpError("i/o failure on log file (" ^ string_of_exn ex ^ ")")
);
end; (* of local ... in ... end *)
=TEX
\section{THE SETS OF ITEMS CONSTRUCTION}\label{THESETSOFITEMSCONSTRUCTION}
\subsection{Types and Operations for Grammars}
The following types are used to represent grammars etc.:
=SML
type ÛNONTERMINALÝ = string;
datatype ''lc ÛSYMBOLÝ = ÛTerminalÝ of ''lc | ÛNonTerminalÝ of NONTERMINAL;
type ''lc ÛPRODUCTIONÝ = NONTERMINAL * (''lc SYMBOL list list);
type ''lc ÛGRAMMARÝ = ''lc PRODUCTION list;
datatype ÛSYM_CLASSÝ = ÛVarClassÝ of string | ÛPuncClassÝ of string;
=TEX
=SML
fun ÛexpandÝ (g : ''lc GRAMMAR) (name : NONTERMINAL) : ''lc SYMBOL list list = (
	lassoc2 g (fn _ => nil) name
);
=TEX
=SML
fun Ûgive_termsÝ (g : ''lc GRAMMAR) : ''lc list = (
	let	fun f(Terminal a :: rest) = a :: f rest
		|   f (_ :: rest) = f rest
		|   f nil = nil;
	in	list_cup(map (fn (x, y) => (list_cup (map f y))) g)
	end
);

=TEX
\subsection{Types and Operations on Sets for Items}
We represent an item by giving the name of the associated non-terminal
the index of the alternative for that non-terminal and the index within
that alternative. In the efficient representation of grammars that we are about
to define, names of non-terminals have become integer indexes into an array:
=SML
type ÛFNONTERMÝ = int;
type ÛITEMÝ = (FNONTERM * int * int);
type ÛALTÝ = (FNONTERM * int);
=TEX
We now introduce an efficient representation of the
grammar denoted by the type $FGRAMMAR$.
=SML
datatype ''a ÛFSYMÝ = ÛFTermÝ of ''a
	| ÛFNonTermÝ of FNONTERM;
type ''a ÛFPRODUCTIONÝ = NONTERMINAL * (''a FSYM array array);
type ''a ÛFGRAMMARÝ = ''a FPRODUCTION array;
=IGN

!!!FOLLOWING IS NOT USED AT THE MOMENT BUT MAY BE USEFUL
IN A FUTURE RE-ORGANISED VERSION OF SLRP!!!

fun f_give_terms (g : ''a FGRAMMAR) = (
let	fun aux symarr (i, acc) = (
		case PPArray.sub (symarr, i) of
			FNonTerm _ => 	acc
			|FTerm x =>		acc grab x
	);
	fun aux1 symarr = fold (aux symarr) (interval 0 (length symarr - 1)) [];
	fun aux2 altarr (i, acc) =
	let	val alt = PPArray.sub (altarr, i);
	in
		aux1 alt
	end;
	fun aux3 altarr = fold (aux2 altarr) (interval 0 (length altarr - 1)) [];
	fun aux4 prodarr (i, acc) =
	let	val prod = (snd o PPArray.sub) (prodarr, i);
	in
		aux3 prod
	end;
	fun aux5 prodarr = fold (aux4 prodarr) (interval 0 (length prodarr - 1)) [];
in
	aux5 g
end);
!!!!!!
=TEX

\subsection{Sets of Items as Ordered Lists}

=SML
fun Ûitem_orderÝ (((nt1, aux1, opt1), (nt2, aux2, opt2)):ITEM*ITEM) : int = (
	if nt1 = nt2
	then
		if aux1 = aux2
		then
			if opt1 = opt2
			then
				0
			else	if opt1 < opt2
				then	~1
				else	1
		else	if aux1 < aux2
			then	~1
			else	1
	else	if nt1 < nt2
		then	~1
		else	1
);

fun Ûitem_list_orderÝ ((list1, list2):ITEM list*ITEM list) : int = (
let	val l1 = length list1;
	val l2 = length list2;
	fun aux (x1::rest1) (x2::rest2) = (
		case item_order (x1, x2) of
		0 =>	aux rest1 rest2
		|Other => Other)
	  | aux _ _ = 0;
in
	if l1 = l2
	then
		aux list1 list2
	else	if l1 < l2
		then	~1
		else	1
end);

fun ÛmergeÝ (order:(''a*''a)->int) (xx:''a list) (yy:''a list) : ''a list = (
let	fun aux (x::xs) (y::ys) = (
		case order (x,y) of 
		0 =>	x::(aux xs ys)
		| ~1 =>	x::(aux xs (y::ys))
		|_ =>	y::(aux (x::xs) ys)
	) | aux xx nil = xx
	  | aux nil (yy) = yy;
in
	aux xx yy
end);

fun xx Ûrcup'Ý yy = merge item_order xx yy;


fun xx Ûrcup''Ý yy = merge item_list_order xx yy;

fun Ûmaprcup''Ý f = (Sort.sort (curry item_list_order)) o (map f);

fun xx Ûrgrab'Ý y = xx rcup' [y];

fun Ûgen_eqÝ (eqfn:(''a*''a)->int) (xx:''a list) (yy:''a list) : bool = (
let	fun aux (x::xs) (y::ys) = (
		case eqfn (x,y) of 
		0 =>	aux xs ys
		|_ =>	false
	) | aux nil nil = true
	  | aux _ _ = false;
in length xx = length yy
	andalso aux xx yy
end);

nonfix set_eq';
val Ûset_eq'Ý = gen_eq item_order;
=TEX
\subsection{Converting the Grammar to an Efficient Representation}
=SML
=SML
fun Ûnt_nameÝ (g : ''a FGRAMMAR) (nt : FNONTERM) 
		: NONTERMINAL = (
	fst (PPArray.sub(g, nt))
);
=TEX
=SML
fun Ûmake_grammarÝ (sen : NONTERMINAL)  (g : ''a GRAMMAR)
	: ''a FGRAMMAR * FNONTERM =
let	val Ûnt_dictÝ : FNONTERM E_DICT ref =
		ref initial_e_dict;	val sd = (nt_dict := initial_e_dict);
	val mapping = combine (map fst g) (interval 0 (bound g)) ;
	fun aux1 (s,i) = (nt_dict := e_extend s i (!nt_dict));
	val sd = map aux1 mapping;
	fun aux2 (Terminal x) = FTerm x
	  | aux2 (NonTerminal name) =
		FNonTerm (
			case e_lookup name (!nt_dict) of
			Value nt =>	nt
			| _ =>		raise SlrpError "make_grammar")
	fun aux3 rhs = map (map aux2) rhs;
	fun aux4 (nt, rhs) =
		(nt,  PPArray.arrayoflist
			(map PPArray.arrayoflist (aux3 rhs)));
	val sent = (case e_lookup sen (!nt_dict) of 
		Nil => raise SlrpError "SLR_TABLES"
		|Value x => x);
in
	(PPArray.arrayoflist (map aux4 g), sent)
end;
=TEX
$f\_expand$ is a version of the function $expand$ which
works on the efficient representation of the grammar.
=SML
fun Ûf_expandÝ (g : ''a FGRAMMAR) (name : FNONTERM) : ''a FSYM array array = (

	snd (PPArray.sub (g, name))
);
=TEX
$f\_follower\,g\,x$ returns the symbol immediately after the dot in the item $x$
for the grammar $g$
=SML
fun Ûf_followerÝ (g : ''a FGRAMMAR) ((sym, alt, dot) : ITEM) : ''a FSYM = (
	PPArray.sub(PPArray.sub(f_expand g sym, alt), dot)
);
=TEX
\subsection{CLOSURE Function}
The function $closure$ is just as in \cite{Aho77}.
=SML
fun Ûf_closureÝ (g : ''a FGRAMMAR) (items : ITEM list) : ITEM list = (
let	fun aux1 res (FNonTerm nt) = (
	let	val newitems = map (fn i => (nt, i, 0))
		  (interval 0 (PPArray.length (f_expand g nt) - 1));
	in
		res rcup' newitems
	end) | aux1 res _ = res;
	fun aux2 res (item::more) = (
		(aux2 (aux1 res (f_follower g item)) more)
		handle _ => aux2 res more
	) | aux2 res _ = res;
	val res = aux2 items items;
in	if length res > length items
	then f_closure g res
	else res
end);
=TEX
\subsection{GOTO Function}
The function $goto$ is just as in \cite{Aho77}.
=SML
fun Ûf_gotoÝ (g: ''a FGRAMMAR) (items : ITEM list) (sym : ''a FSYM) : ITEM list = (
let	fun aux ((item  as (name, alt, dot)):: more) = (
		(if sym = f_follower g item
		then
			(name, alt, dot+1) :: aux more
		else aux more)
		handle Any => aux more
	) | aux [] = [];
in	f_closure g (aux items)
end
);
=TEX
\subsection{ITEMS Function}
=TEX
Again $make\_items$ is as in \cite{Aho77} (under $items$). We assume the grammar is already
augmented. The sentence symbol is supplied as an additional parameter.
=SML
fun Ûmake_itemsÝ (g : ''a FGRAMMAR) (sen : FNONTERM) : ITEM list list = (
let	fun aux1 (item :: more) = (
		((f_follower g item) :: aux1 more) handle _ => aux1 more
	) | aux1 [] = [];
	fun aux2 res (items' :: more) = (
		case aux1 items' of
			[] => aux2 res more
		|	xs => aux2 (res rcup'' (maprcup'' 
				(f_goto g items') xs)) more
	) | aux2 res [] = res;
	fun aux3 items' = (
		let	val newitems = aux2 items' items'
		in	if length newitems > length items'
			then aux3 newitems
			else items'
		end
	);
in	aux3 [f_closure g [(sen, 0, 0)]]
end);
=TEX
\section{DIAGNOSTIC UTILITIES}\label{DIAGNOSTICUTILITIES}
It is helpful to have code which attempts to explain the conflicts which
arise.

Most things here are parametrised by a grammar
and/or a function to print out lexical classes.
=SML
fun Ûformat_symbolÝ (p : ''lc -> string) (Terminal x : (''lc) SYMBOL) 
	= p x
|   format_symbol _ (NonTerminal s) = s;
=TEX
=SML
fun Ûformat_altÝ (g: ''lc GRAMMAR, p : ''lc -> string) (alt : string, i : int) : string = (
	if all g (fn (s,_) => s <> alt)
	then "*** INTERNAL ERROR: invalid alternative: " ^ alt ^ " ***"
	else	let	val alts = expand g alt;
			val len = length alts;
			val dots1 = if i > 0 then "... | " else "";
			val dots2 = if i < len-1 then " | ..." else "";
		in	if i < 0 orelse i >= len
			then "*** INTERNAL ERROR: invalid index ***"
			else	alt ^ " = " ^ dots1
			^	format_list (format_symbol p)(kth alts i) ", " ^ dots2
		end
);
=TEX
=SML
fun Ûformat_itemÝ
	(g : ''lc GRAMMAR, p : ''lc -> string)
	((nt, alt, dot) : ITEM)
	(eff_grammar : ''lc FGRAMMAR) = (
let	val sym = nt_name eff_grammar nt;
in
	if all g (fn (s,_) => s <> sym)
	then "*** INTERNAL ERROR: invalid alternative: " ^ sym ^ " ***"
	else	let	val alts = expand g sym;
			val len = length alts;
		in	if alt < 0 orelse alt >= len
			then "*** INTERNAL ERROR: invalid item ***"
			else let	val syms = kth alts alt;
					val slen = length syms;
			in	if dot < 0 orelse dot > slen
				then "*** INTERNAL ERROR: invalid index in item ***"
				else	sym ^ " = "
					^ format_list (format_symbol p)(syms to (dot-1)) ", "
					^ (if dot = 0 then "." else 
					   if dot = slen then "." else "., ")
					^ format_list (format_symbol p)(syms from dot) ", "
			end
		end
end);
=SML
fun Ûformat_stateÝ(gp : ''lc GRAMMAR * (''lc -> string))
		((items, i) : ITEM list * int)
		(eff_grammar : ''lc FGRAMMAR) : string list = (
	case items of
		[] => [string_of_int i ^ ":"]
	|	[item] => [string_of_int i ^ ":\t" ^ format_item gp item eff_grammar]
	|	item :: more => string_of_int i ^ ":\t" ^ format_item gp item eff_grammar
			:: map (fn item => "\t" ^ format_item gp item eff_grammar) more
);
=TEX
=SML
fun Ûprint_grammarÝ (p : ''lc -> string)(g : ''lc GRAMMAR) : unit = (
	let	fun fmt_alt alt = (
			format_list (format_symbol p) alt ", "
		);
		fun fmt_prod (nt, alts) = (
			case alts of
				[] => [nt ^ "\t="]
			|	[alt] => [nt ^ "\t= " ^ fmt_alt alt]
			|	alt :: more => nt ^ "\t= " ^ fmt_alt alt ^ ""
					:: map (fn alt => "\t| " ^ fmt_alt alt) more
		);
		fun add_semi list = (
			let	val r = rev list;
			in	rev(hd r ^ ";" :: tl r)
			end
		);
		fun do_prod prod = map (fn s => (log s; log"\n"))
				(add_semi(fmt_prod prod));
	in	map do_prod g; ()
	end 
);
=SML
fun Ûprint_termsÝ (p : ''lc -> string)(g : ''lc GRAMMAR) : unit = (
	let	val names = Sort.sort Sort.string_order (map p(give_terms g));
	in	map (fn n =>(log n; log "\n")) names; ()
	end 
);
=TEX
=SML
fun Ûprint_statesÝ (gp : ''lc GRAMMAR * (''lc -> string))
		(states : (ITEM list * int) list) (eff_grammar : ''lc FGRAMMAR) : unit = (
	let	fun do1 state = (
			map (fn s => (log s; log"\n")) (format_state gp state eff_grammar)
		);
	in	map do1 states; ()
	end 
);
=TEX
The following function presents an LR(0) automaton given by an action table
and a goto table as a labelled directed graph.
=SML
fun Ûget_lr0_automaton_graphÝ
	(actions : ''lc ACTION_TABLE)
	(gotos : GOTO_TABLE)
	(init_state : STATE)
	: (STATE * (''lc SYMBOL * STATE OPT) list) list
	= (
	let	open PPArray;
		val done = array(length actions, false);
		fun do_goto_entry acc [] = rev acc
		|   do_goto_entry acc ((nt, q)::more)  =
			do_goto_entry ((NonTerminal nt, Value q) :: acc) more;
		fun do_action_entry ges acc [] = (do_goto_entry acc ges)
		| do_action_entry  ges acc ((lc, act)::more) = (
			case act of
				Shift q =>
				do_action_entry ges ((Terminal lc, Value q)::acc) more
			|	Dynamic (q, _) =>
				do_action_entry ges ( (Terminal lc, Value q)::acc) more
			|	Accept =>
				do_action_entry ges ((Terminal lc, Nil)::acc) more
			|	_ =>
				do_action_entry ges acc more
		);
		fun do_state acc [] = rev acc
		|   do_state acc (p::ps) = (
			update(done, p, true);
			let	val ges = sub(gotos, p);
				val aes = sub(actions, p);
				val new = do_action_entry ges [] aes;
				fun visited (Value q) = sub(done, q)
				|   visited Nil = true;
				val more = Sort.sort (curry (op -))
					(map force_value ((map snd new) drop visited));
			in	do_state ((p, new) :: acc) (ps @ more)
			end
		);
	in	do_state [] [init_state]
	end
);
=TEX
=SML
fun Ûprint_lr0_automaton_graphÝ
	(actions : ''lc ACTION_TABLE)
	(gotos : GOTO_TABLE)
	(init_state : STATE)
	(p : ''lc -> string) : unit = (
	let	val graph = get_lr0_automaton_graph actions gotos init_state;
		fun int_of_sso (Value p1) = p1
		|   int_of_sso Nil = ~1;
		fun fmt_state_opt sso = (string_of_int(int_of_sso sso));
		fun fmt_sym_state_opt (sym, po) =
			 format_symbol p sym ^ " -> " ^ fmt_state_opt po;
		fun int_of_sso (Value p1) = p1
		|   int_of_sso Nil = ~1;
		fun sso_sort ssos = (
			let	val marked = combine ssos (interval 1 (length ssos));
				fun order ((_, p1), i1) ((_, p2), i2) = (
					if	p1 <> p2
					then	int_of_sso p1 - int_of_sso p2
					else	i1 - i2
				);
			in	map fst (Sort.sort order marked)
			end
		);
		fun print1 (s, sso) = (
			log (string_of_int s); log ":\t";
			log (format_list fmt_sym_state_opt (sso_sort sso) "\n\t");
			log "\n"
		);
	in	log "\n"; log (burst "LR(0) automaton"); log "\n";
		map print1 graph; ()
	end
);
=TEX
\section{SLR TABLE COMPUTATION}\label{SLRTABLECOMPUTATION}
\subsection{FIRST and FOLLOW}
The following computes the $first$ function of \cite{Aho77}.
=SML
fun ÛfirstÝ (g : ''a GRAMMAR) : (''a SYMBOL * (''a OPT list)) list = (
	let	val step1 = map (fn s => (Terminal s, [Value s])) (give_terms g);
		fun step2_aux1 alts = (
			case alts of
				(Terminal a :: _)  :: more => step2_aux1 more rgrab (Value a)
			|	[] :: more=> step2_aux1 more rgrab Nil
			|	_ :: more=> step2_aux1 more
			|	[] => []
		);
		fun step2_aux2 ((nt, alts) :: more) = (
			(NonTerminal nt, step2_aux1 alts) :: step2_aux2 more
		) | step2_aux2 [] = step1;
		val step2 = step2_aux2 g
		fun step3_aux1 tab alts = (
			case alts of
				((nt as (NonTerminal _)) :: alt')  :: more => (
					let	val new = lassoc3 tab nt
					in	if Nil mem new
						then (new less Nil)rcup
							step3_aux1 tab (alt' :: more)
						else new rcup step3_aux1 tab more
					end
			) |	[] :: more => [Nil] rcup step3_aux1 tab more
			|	_ :: more => step3_aux1 tab more
			|	[] => []
		);
 		fun step3_aux2 tab ((nt, alts) :: more) = (
			let	val old = lassoc3 tab(NonTerminal nt);
				val new = step3_aux1 tab alts;
				val tab' = tab overwrite (NonTerminal nt, old rcup new);
			in	step3_aux2 tab' more
			end
		) | step3_aux2 tab [] = tab;
		fun step3_aux3 tab = (
			let	val tab' = step3_aux2 tab g;
			in	if tab' = tab
				then tab
				else step3_aux3 tab'
			end
		);
	in	step3_aux3 step2
	end
);
=TEX
The following computes the $FOLLOW$ function of \cite{Aho77}.
=SML
fun ÛfollowÝ (g : ''lc GRAMMAR) (sen : NONTERMINAL) (eos : ''lc)
	: ''lc list E_DICT = (
	let	val first_tab = first g;
		fun first_syms (sym :: more) = (
			let	val firsts = lassoc3 first_tab sym;
			in	if Nil mem firsts
				then (firsts less Nil) rcup first_syms more
				else firsts
			end
		) | first_syms [] = [Nil];
		fun doalt a tab alt = (
			(case alt of 
				(NonTerminal b :: more) => (
					let	val oldb = lassoc3 tab b;
						val firstmore = first_syms more;
						val newb = oldb rcup 
							(if Nil mem firstmore
							then	lassoc3 tab a
							rcup map
							 force_value(firstmore less Nil)
							else map force_value firstmore);
					in	doalt a (tab overwrite (b, newb)) more
					end
			) |	(_ :: more) => (doalt a tab more
			) |	[] => tab)
		);
		fun doprod tab (nt, alt :: more) = (
			doprod (doalt nt tab alt) (nt, more)
		) | doprod tab (_, []) = tab;
		fun again (prod :: more) tab = (
			again more (doprod tab prod)
		) | again [] tab = tab;
		fun go tab = (
			let	val tab' = again g tab;
			in	if tab' = tab
				then tab
				else go tab'
			end
		);
		val sd =	go (map (fn (nt, _) => (nt,  if nt = sen then [eos] else [])) g);
	in	list_e_merge initial_e_dict sd
	end 
);
=TEX

\subsection{The Table Construction}

=SML
fun Ûslr_tablesÝ (g : ''lc GRAMMAR) (eos : ''lc) (sen : NONTERMINAL) 
	: (''lc)ACTION_TABLE * GOTO_TABLE * (ITEM list * int) list *
			 ''lc FGRAMMAR * STATE = (
	let	open PPArray;
		val (g' , sent) = make_grammar sen g;
		val C = make_items g' sent;
		val n = bound C;
		val js = interval 0 n;
		val Ijs = combine C js;
		val actions = array (n+1, []:(''lc * ACTION)list);
		val gotos = array (n+1, []: (NONTERMINAL * STATE)list);
		val follow_tab = follow g sen eos;
		fun my_follower item = (
			(Value (f_follower g' item)) handle _ => Nil
		);
		fun item_index items = (
			snd(find Ijs (fn (items', _) => set_eq' items items'))
		);
		fun make_actions items ((item as (nt, alt, dot)) :: more) = (
			case my_follower item of
				Value(a as (FTerm lc)) => (
				make_actions items more rgrab
					(lc, Shift(item_index(f_goto g' items a)))
			) |	Value _ => (make_actions items more
			) |	Nil => (
				if nt <> sent
				then let	fun f lc = (lc, Reduce((nt_name g' nt, alt), dot));
					val lcs = force_value(e_lookup (nt_name g' nt) follow_tab);
				in	make_actions items more rcup map f lcs
				end else make_actions items more rgrab (eos, Accept) 
			)
		) | make_actions _ _ = [];
		val non_terms = interval 0 (PPArray.length g' - 1);
		fun make_gotos items = (
			let	fun aux (nt :: more) = (
					case f_goto g' items (FNonTerm nt) of
						[] => aux more
					|	items' => 
						(nt_name g' nt, item_index items') :: aux more
				) | aux [] = [];
			in	aux non_terms
			end
		);
		val SideEffect1 =
			map (fn (items, j) =>
				PPArray.update(actions, j, make_actions items items)) Ijs;
		val SideEffect2 =
			map (fn (items, j) => PPArray.update(gotos, j, make_gotos items)) Ijs;
		val init_state = snd (find Ijs (fn (items, _) =>
					any items (fn (nt, 0, 0) => nt = sent
						|   _ => false)))
		handle Fail _ =>
		raise SlrpError
		"the sentence symbol is not in the list of items";
	in	(actions, gotos, Ijs, g', init_state)
	end
);
=TEX
\subsection{Conflict Detection}
The following function calculates whether there are any conflicts in an action table.
=SML
fun ÛconflictsÝ  (actions : (''lc) ACTION_TABLE) : 
		(''lc * STATE * (ACTION list)) list = (
	let	open PPArray;
		fun aux i ((lc, act) :: more) = (
			if any more (fn (lc', _) => lc' = lc)
			then (lc, i, act :: map snd (more drop (fn (lc', _) => lc' <> lc)))
				:: aux i (more drop (fn (lc', _) => lc' = lc)) 
			else aux i more
		) | aux _ [] = [];
	in	flat
			(map (fn i => aux i (PPArray.sub(actions, i)))
				(interval 0 (length actions - 1)))
	end
);
=TEX
\newpage
\section{CALCULATING LALR(1) LOOKAHEAD SETS}\label{LALRLA}
The input to the functions in this section is the output of the SLR(1) table
construction of the previous section.
I.e., we have an action table, the goto table (for non-terminal transitions),
the sets of items that the parser states represent, and the grammar in the
efficient array-based representation.
Both the action table and the goto table are represented as arrays whose
index sets are the numeric representations of the states of the parser.
To avoid recalculating it, we are also given the list of states for
which conflicts have been detected.
We follow \cite{Bermudez89} for the calculation of the LALR(1) lookahead
sets and then use them to filter out unnecessary reductions from the action
table. 

Given the current structure of the overall process, there should not be any dynamic actions
in the action table at this stage, because they are only introduced if the LALR(1) calculations have
not removed all the conflicts. However, they have an obvious interpretation here and so we allow for them
in the event of future changes. There will be no error actions in the action table.

=TEX
To make the grammar more informative for the user, we include the target
state of each transition in the grammar symbols (only the source state
and edge-label are strictly needed). Thus,  we differ from \cite{Bermudez89}, by having triples
$[p:X:q]$ rather than pairs $[p:X]$. For $X$ terminal, $q$ is optional, a missing $q$ corresponds
to the accepting state. The following function computes the string representation of a non-terminal.
=SML
fun Ûmk_stg_nonterminalÝ ((s0 : STATE , nt : NONTERMINAL), s1 : STATE) : string  = (
	"[" ^ string_of_int s0 ^ ":" ^ nt ^ ":" ^ string_of_int s1 ^ "]"
);
=TEX
The following function takes a step along a terminal symol in an action table.
=SML
fun Ûstep_terminalÝ 
	(actions : ''lc ACTION_TABLE)
	(p : STATE)
	(lc : ''lc)
	: (STATE * ''lc * STATE OPT) list = (
	let	open PPArray;
		val lc_acts = sub(actions, p);
		fun aux acc [] = rev acc
		|   aux acc ((lc', Shift q)::more) =
			aux (if lc = lc' then (p, lc, Value q)::acc else acc) more
		|   aux acc ((lc', Dynamic(q, _))::more) =
			aux (if lc = lc' then (p, lc, Value q)::acc else acc) more
		|   aux acc ((lc', Accept)::more) =
			aux (if lc = lc' then (p, lc, Nil) ::acc else acc) more
		|   aux acc (_::more) = aux acc more;
	in	aux [] lc_acts
	end
);
=TEX
The following function takes a step along a non-terminal symol in a goto table.
=SML
fun Ûstep_nonterminalÝ 
	(gotos : GOTO_TABLE)
	(p : STATE)
	(nt : NONTERMINAL)
	: STATE list = (
	let	open PPArray;
		val nt_sts = sub(gotos, p);
		fun aux acc [] = rev acc
		|   aux acc ((nt', q)::more) =
			aux (if nt = nt' then q ::acc else acc) more;
	in	aux [] nt_sts
	end
);
=TEX
The following function walks along an alternative in a grammar starting at a given state and
produces the list of all paths through the LR(0) automaton starting in a given state with
a sequence of edge labels given by the symbols in the alternative. It is caller's responsibility
to supply a state/alternative pair that does actually correspond to a nonterminal transition
in the LR(0) automaton (else you will get a spurious production with an empty right-hand side
in the state transition grammar).
=SML
fun ÛwalkÝ 
	(actions : ''lc ACTION_TABLE)
	(gotos : GOTO_TABLE)
	(g : ''lc FGRAMMAR)
	(s0 : STATE)
	((nt, i) : ALT)
	:((STATE * ''lc * STATE OPT)  SYMBOL list * STATE OPT) list = (
	let	open PPArray;
		val alt = sub(f_expand g nt, i);
		val len = length alt;
		fun step p k = (
			case sub(alt, k) of
				FNonTerm fnt => (
				let	val nt_sts = sub(gotos, p);
					val nt = nt_name g fnt;
					fun aux q =
					(NonTerminal(mk_stg_nonterminal((p, nt), q)), Value q);
				in	map aux (step_nonterminal gotos p nt)
				end
			) |	FTerm lc =>  (
				map
				(fn x as (_,_, q)=> (Terminal x, q))
				(step_terminal actions p lc)
			)
		);
		fun gather_step k (syms, Value q)= (
			let	val new_sqs = step q k;
			in	map
				(fn (sym, q') => (sym::syms, q'))
				new_sqs
			end
		) | gather_step _ syms_nil = [syms_nil];
		fun gather_steps k (syms_qs) = (
			if	k = len
			then	rev(map (fn (syms, q) => (rev syms, q)) syms_qs)
			else	gather_steps(k+1)  (flat(map (gather_step k) syms_qs))
		);
	in	gather_steps 0 [([], Value s0)]
	end
);
=TEX

The main step is the construction of the state transition grammar.
In this step, we also construct some auxiliary items: a dictionary
mapping non-terminals, $A$, of the original grammar to the sets of states, $p$, for which
there is a transition $[p:A:q]$ for some state $q$;
a dictionary mapping non-terminals to their integer representations in the efficent grammar
representation; the sentence symbol for the state transition grammar; and the
end of stream symbol.


=SML
fun Ûmake_transition_grammarÝ 
	(actions : ''lc ACTION_TABLE)
	(gotos : GOTO_TABLE)
	(g : ''lc FGRAMMAR)
	(sen : NONTERMINAL)
	(eos : ''lc)
	(init_state : STATE) 
	: (STATE * ''lc * STATE OPT) GRAMMAR *
	  STATE list E_DICT *
	  FNONTERM E_DICT *
	  NONTERMINAL *
	   (STATE * ''lc * STATE OPT) = (
	let	open PPArray;
		val b = length gotos - 1;
		val states = interval 0 b;
		fun mk_nt_triples (s0, nts_s1s) = map (fn (nt, s1) => ((s0, nt), s1)) nts_s1s;
		val nt_triples = flat(map (fn s => mk_nt_triples (s, sub(gotos, s))) states);
		fun mk_st_edict acc [] = acc
		|   mk_st_edict acc (((s, nt), _)::more) = (
			case e_lookup nt acc of
				Nil => mk_st_edict (e_enter nt [s] acc) more
			|	Value sl => mk_st_edict (e_enter nt (sl rgrab s) acc) more
		);
		val st_edict = mk_st_edict initial_e_dict nt_triples;
		val fnts = interval 0 (length g - 1);
		val nt_sdict = map
				(fn fnt => (fst(sub(g, fnt)), fnt)) 
					(interval 0 (length g - 1));
		val nt_edict = list_e_merge initial_e_dict nt_sdict;
		fun do_prod (s0nts1 as ((s0, nt), s1)) = (
			let	val fnt = force_value(e_lookup nt nt_edict);
				val prod = snd(sub(g, fnt));
				val nalts = length prod;
				val alts = map (fn i => (fnt, i)) (interval 0 (nalts-1));
				val my_walk = map fst o walk actions gotos g s0;
			in	(mk_stg_nonterminal s0nts1, flat (map my_walk alts))
			end
		);
		val init_triple = ((init_state, sen), ~1);
		val g' = map do_prod (init_triple::nt_triples);
		val eos_triple = (~1, eos, Nil)
	in	(g', st_edict, nt_edict, mk_stg_nonterminal init_triple, eos_triple)
	end
);
=SML
fun Ûfmt_stg_terminalÝ
	(p : ''lc -> string)
	 (s0 : STATE, lc : ''lc, Value s1 : STATE OPT)  : string = (
	"[" ^ string_of_int s0 ^ ":" ^ p lc ^ ":" ^ string_of_int s1 ^"]"
) | fmt_stg_terminal p (s0, lc, Nil) = "[" ^ string_of_int s0 ^ ":" ^  p lc ^ ":]";
=TEX
The next step is the computation of the LALR(1) look-ahead (assuming the follow table
for the state transition grammar has already been calculated). It is caller's responsibiliity to provide an alternative
which does label a transition leading from the given state.
=SML
fun Ûlalr_lookahead_setÝ
	(actions : ''lc ACTION_TABLE)
	(gotos : GOTO_TABLE)
	(g : ''lc FGRAMMAR)
	 (st_ed : STATE list E_DICT)
	 (nt_ed : FNONTERM E_DICT)
	(follow_tab : (STATE * ''lc * STATE OPT) list E_DICT)
	(q : STATE)
	(alt as (a, i) : NONTERMINAL * int) : ''lc list = (
	let	open PPArray;
		val fnt = force_value(e_lookup a nt_ed);
		val ps = force_value(e_lookup a st_ed) handle Fail _ => [];
		fun unwanted_state p =  (
			all
			(walk actions gotos g p (fnt, i))
			(fn (_, Value q') => q <> q' | _ => true)
		);
		val ps' = ps drop unwanted_state;
		fun collect acc  [] = flat acc
		|   collect acc (p::more) = (
			let	val p1 = snd(find(sub(gotos, p)) (fn(a', _) => a = a'));
				val name = mk_stg_nonterminal((p, a), p1);
				val lcs =	case e_lookup name follow_tab of
						Value triples => map (fn(_, lc, _) => lc) triples
					|	Nil => [];
			in	collect (lcs::acc) more
			end
		);
	in	collect [] ps' cup []
	end
);
=TEX
As a diagnostic tool, we provide a function which will calculate all of the LALR(1) lookahead sets.
This involves much more calculation than is normally required just to resolve the shift/reduce and
reduce/reduce conflicts.
=SML
fun Ûlalr_lookahead_setsÝ
	(actions : ''lc ACTION_TABLE)
	(gotos : GOTO_TABLE)
	(g : ''lc FGRAMMAR)
	 (st_ed : STATE list E_DICT)
	 (nt_ed : FNONTERM E_DICT)
	(follow_tab : (STATE * ''lc * STATE OPT) list E_DICT)
	: ((STATE * (NONTERMINAL * int)) * ''lc list) list = (
	let	open PPArray;
		val nts = Sort.sort Sort.string_order (map fst(e_flatten nt_ed));
		fun num_alts a = (
			length(snd(sub(g, force_value(e_lookup a nt_ed))))
		);
		fun aux1 a p = (
			let	val ks = interval 0 (num_alts a - 1);
				val la = lalr_lookahead_set actions gotos g st_ed nt_ed follow_tab;
			in	map (fn i => ((p, (a, i)), la p (a, i))) ks
			end
		);
		fun aux2 acc a [] = flat (rev acc)
		|    aux2 acc a (p::ps) = (
			aux2 (aux1 a p::acc) a ps
		);
		val states = interval 0 (length gotos - 1);
		fun aux3 a = aux2 [] a states;
	in	flat (map aux3  nts)
	end
);
=IGN
lalr_lookahead_sets actions gotos g st_ed nt_ed follow_tab;
=SML
fun Ûlog_lookahead_setÝ
	(_ : ''lc -> string)
	((_, []) :  (STATE * (NONTERMINAL * int)) * ''lc list) : unit = ( ()
) |  Ûlog_lookahead_setÝ
	(p : ''lc -> string)
	(((s, (nt, i)), lcs) :  (STATE * (NONTERMINAL * int)) * ''lc list) : unit = (
	log nt; log "."; log (string_of_int i); log ", "; log (string_of_int s);
	log": "; log (format_list p lcs ", ");  log "\n"
);
=TEX
=SML
fun Ûlog_lookahead_setsÝ
	(actions : ''lc ACTION_TABLE)
	(gotos : GOTO_TABLE)
	(g : ''lc FGRAMMAR)
	 (st_ed : STATE list E_DICT)
	 (nt_ed : FNONTERM E_DICT)
	(follow_tab : (STATE * ''lc * STATE OPT) list E_DICT)
	(p : ''lc -> string) : unit= (
	let	val sets = lalr_lookahead_sets actions gotos g st_ed nt_ed follow_tab;
	in	log"\n";
		log (burst "LALR(1) Lookahead Sets");
		log "\n";
		map (log_lookahead_set p) sets; ()
	end

);
=TEX
=SML
fun Ûlog_transition_grammarÝ
	(p : ''lc -> string)
	(stg : (STATE * ''lc * STATE OPT) GRAMMAR) : unit= (
	log "\n";
	log (burst "Bermudez-Logothetis State Transition Grammar");
	log "\n";
	print_grammar (fmt_stg_terminal p) stg
);
=TEX
We can now define the function which carries out the resolution of conflicts using the LALR(1) look-ahead sets.
=SML
fun Ûlalr_resolve_conflictsÝ
	(_ : ''lc ACTION_TABLE)
	(_ : GOTO_TABLE)
	(_ : ''lc FGRAMMAR)
	(_ : NONTERMINAL)
	(_ : ''lc)
	(_ : STATE) 
	([] : (STATE * ''lc) list)
	(_ : ''lc -> string)
	(false : bool) 
	(false : bool) : unit = (
) | lalr_resolve_conflicts
	(actions : ''lc ACTION_TABLE)
	(gotos : GOTO_TABLE)
	(g : ''lc FGRAMMAR)
	(sen : NONTERMINAL)
	(eos : ''lc)
	(init_state : STATE) 
	(confs : (STATE * ''lc) list)
	(p : ''lc -> string)
	(log_tg : bool)
	(log_la_sets : bool)  : unit = (
	let	open PPArray;
		val (g', st_ed, nt_ed, sen', eos') =
			make_transition_grammar actions gotos g sen eos init_state;
		val follow_tab = follow g' sen' eos';
(*
		val lc_tab = array(length actions, []: SYM_CLASS list);
*)
		val lc_tab = array(length actions, []:''lc list);
		val _ = map (fn (s, lc) => update(lc_tab, s, lc::sub(lc_tab, s))) confs;
		val la = lalr_lookahead_set actions gotos g st_ed nt_ed follow_tab;
		fun do_action_entry p (entry as (lc, act)) = (
			if	lc mem sub(lc_tab, p)
			then	case act of
					Reduce((a, i), _) => (
					if	lc mem la p (a, i)
					then	[entry]
					else	[]
				) |	Dynamic (q, ((a, i), j)) => (
					if	lc mem la p (a, i)
					then	[entry]
					else	[(lc, Shift q)]
				) |	_ => [entry]
			else	[entry]
		);
		fun do_state p = (
			let	val action_entries = sub(actions, p);
				val action_entries' = flat
					(map (do_action_entry p) action_entries);
			in	update(actions, p, action_entries')
			end
		);
		val conf_states = Sort.sort (curry (op-)) (map fst confs);
	in	map do_state conf_states;
		(if	log_tg
		 then	log_transition_grammar p g' 
		 else ());
		(if	log_la_sets
		 then	log_lookahead_sets  actions gotos g st_ed nt_ed follow_tab p
		 else ())
	end
);
=TEX
\newpage
\section{BNF PARSER}\label{BNFPARSER}
\subsection{Action Grammars}
We need a parser for BNF.
The BNF dialect used for this
parser is an extension of a subset of the British Standard (\cite{BS6154}),
which allows fragments of ML code to be given with any alternative.
The subset is the one in which the only operators are concatenation
and alternation and in which grouping with parentheses is not allowed.
Empty alternatives are allowed.
We refer to such a grammar as an action grammar.

The concrete syntax
for action grammars is as follows:
=TEX
=GFT
	Grammar	=		Prod, `;`
			|	Prod, `;`, Grammar;

	Prod		=	Nam, `=`, Def;

	Def		=	OptAlt, OptAction | OptAlt, OptAction, `|`, Def;

	OptAlt		=	Alt |;

	Alt		=	Symbol | Symbol, `,`, Alt;

	Symbol		=	Nam | Con;

	OptAction	=	Action | ;
=TEX 
The result of parsing an action grammar with actions of type $'act$ has
the following type:
=SML
type ('lc, 'act) ÛACTION_GRAMMARÝ = 
	(string * ((('lc)SYMBOL list * 'act)list)) list;
=TEX
We derive an ordinary grammar from an action grammar as follows:
=SML
fun Ûstrip_actionÝ (x : ('lc, 'act) ACTION_GRAMMAR) :  ('lc) GRAMMAR =
				map (Combinators.I ** map fst) x;
=TEX
We derive a $'a$-valued reduction table
from an action grammar as follows:
=SML
type ('act) ÛGEN_REDUCTION_TABLEÝ = ('act) list E_DICT;
=TEX
=SML
fun Ûmake_reduction_tableÝ (ag:('lc, 'act) ACTION_GRAMMAR)
					: ('act) GEN_REDUCTION_TABLE = (
	list_e_merge initial_e_dict (map (Combinators.I ** map snd) ag)
);
=TEX
\subsection{Implementing Action Grammars}
=TEX
The lexical categories are as follows:
=SML
datatype ÛBNF_lex_classÝ	=	BNF_var
			|	BNF_con
			|	BNF_eq
			|	BNF_semi
			|	BNF_vert
			|	BNF_comma
			|	BNF_action
			|	BNF_eos;
=TEX
=IGN
fun fmt_BNF_lex_class (BNF_var : BNF_lex_class) : string = "Nam"
| fmt_BNF_lex_class BNF_con = "Con"
| fmt_BNF_lex_class BNF_eq = "="
| fmt_BNF_lex_class BNF_semi = ";"
| fmt_BNF_lex_class BNF_vert = "|"
| fmt_BNF_lex_class BNF_comma = ","
| fmt_BNF_lex_class BNF_action = "Action"
| fmt_BNF_lex_class BNF_eos = "$";

=SML
type ÛBNF_lex_itemÝ = BNF_lex_class * string;
=TEX
=SML
val Ûformat_BNF_lex_itemÝ : BNF_lex_item -> string = snd;
=TEX
We use the following datatype for the partially parsed inputs when we parse
an action grammar. (Note we use "()" as the default action value. This corresponds
to a parser with the partially parsed input having type unit.)
=SML
datatype ÛP_GRAMMARÝ	= ÛPG_GrammarÝ of 
			(string * ((SYM_CLASS list * string)list)) list
			| ÛPG_ProdÝ of string * ((SYM_CLASS list * string)list)
			| ÛPG_DefÝ of(SYM_CLASS list * string) list
			| ÛPG_OptAltÝ of SYM_CLASS list
			| ÛPG_SymbolÝ of SYM_CLASS
			| ÛPG_OptActionÝ of string;

type ÛRT_ENTRYÝ =
	(BNF_lex_item, BNF_lex_class, P_GRAMMAR)INPUT_STACK->P_GRAMMAR;
=TEX
The reduction functions are as follows:
=SML
fun ÛpdiagÝ stk area = (
	raise PARSER_ERROR
	("invalid reduction (stack=" ^ (format_stack format_BNF_lex_item stk) ^ ")")
);
=TEX
The following batch of functions all have type $RT\_ENTRY$. However, the
ML syntax makes it awkward to put in the type constraint, so we leave it out.
=SML
fun Ûgrammar'0Ý stk = pdiag stk "grammar'0";

fun Ûgrammar0Ý (_ :: Parsed(PG_Prod P) :: _) = PG_Grammar [P]
|   grammar0 stk = pdiag stk "grammar0";

fun Ûgrammar1Ý (Parsed(PG_Grammar G) :: _ :: Parsed(PG_Prod P) :: _) =
							PG_Grammar (P::G)
|   grammar1 stk = pdiag stk "grammar1";

fun Ûprod0Ý (Parsed(PG_Def D)::_::Token((_, V), _)::_) = PG_Prod(V, D)
|   prod0 stk = pdiag stk "prod0";

fun Ûdef0Ý (Parsed(PG_OptAction act)::Parsed(PG_OptAlt alt)::_) =
							PG_Def[(alt, act)]
|   def0 stk = pdiag stk "def0";

fun Ûdef1Ý
	(Parsed(PG_Def D)::_::Parsed(PG_OptAction act)::Parsed(PG_OptAlt alt)::_) =
							PG_Def((alt, act)::D)
|   def1 stk = pdiag stk "def1";

fun Ûoptalt0Ý (Parsed alt::_) = alt
|   optalt0 stk = pdiag stk "optalt0";

fun Ûoptalt1Ý _ = PG_OptAlt [];

fun Ûalt0Ý (Parsed(PG_Symbol S)::_) = PG_OptAlt [S]
|   alt0 stk = pdiag stk "alt0";

fun Ûalt1Ý (Parsed(PG_OptAlt alt)::_::Parsed(PG_Symbol S)::_) = PG_OptAlt (S::alt)
|   alt1 stk = pdiag stk "alt1";

fun Ûsymbol0Ý (Token((_, V), _)::_) = PG_Symbol(VarClass V)
|   symbol0 stk = pdiag stk "symbol0";

fun Ûsymbol1Ý (Token((_, V), _)::_) = PG_Symbol(PuncClass V)
|   symbol1 stk = pdiag stk "symbol1";

fun Ûoptaction0Ý (Token((_, V), _)::_) = PG_OptAction V
|   optaction0 stk = pdiag stk "optaction0";

fun Ûoptaction1Ý (_) = PG_OptAction "()";

=TEX
The following value bindings help to abbreviate the
description of the grammar. We think of the
terminals $NonTerminal$ and $Terminal$ as variables
and constants in the notation below.
=SML
local
val ÛGrammarÝ = NonTerminal "Grammar";
val ÛProdnÝ = NonTerminal "Prod";
val ÛNamÝ = Terminal BNF_var;
val ÛDefÝ = NonTerminal "Def";
val ÛAltÝ = NonTerminal "Alt";
val ÛSymbolÝ = NonTerminal "Symbol";
val ÛConÝ = Terminal BNF_con;
val ÛOptActionÝ = NonTerminal "OptAction";
val ÛOptAltÝ = NonTerminal "OptAlt";
val ÛActionÝ = Terminal BNF_action;
=TEX
We can now write down the agumented grammar for our BNF subset together with the
reduction table entries:
=SML
in
val ÛBNF_action_grammarÝ : (BNF_lex_class, RT_ENTRY) ACTION_GRAMMAR = [
	("Grammar'", ([Grammar], grammar'0) :: nil),
	("Grammar", ([Prodn, Terminal BNF_semi], grammar0)
		:: ([Prodn, Terminal BNF_semi, Grammar], grammar1) :: nil),
	("Prod", ([Nam, Terminal BNF_eq, Def], prod0) :: nil),
	("Def", ([OptAlt, OptAction], def0) ::
		([OptAlt, OptAction, Terminal BNF_vert, Def], def1) :: nil),
	("OptAlt", ([Alt], optalt0) :: ([], optalt1):: nil),
	("Alt", ([Symbol], alt0) :: ([Symbol, Terminal BNF_comma, Alt], alt1):: nil),
	("Symbol", ([Nam], symbol0) :: ([Con], symbol1) :: nil),
	("OptAction", ([Action], optaction0) :: ([], optaction1) :: nil)
];
val ÛBNF_reduction_tableÝ
		: (BNF_lex_item, BNF_lex_class, P_GRAMMAR) REDUCTION_TABLE
		= make_reduction_table BNF_action_grammar;
val ÛBNF_grammarÝ : (BNF_lex_class)GRAMMAR = strip_action BNF_action_grammar;
end;
=TEX
Once we have coded the lexical analyser for our action grammar concrete syntax
it will be easy to use the above functions to make an SLR(1) parser for
the input to our parser generator.
We adopt the convention that the first production in the grammar gives
the sentence symbol.
The resulting parser will compute
a value of type $P\_GRAMMAR$. Such a value may be used to compute a
grammar and a reduction table as follows (where from now on we
use a standard ``impossible'' non-terminal as a sentence symbol to augment
the grammar):
=SML
val Ûsentence_symbolÝ ="*Start*";
val Ûsentence_actionÝ ="(raise PARSER_ERROR\"invalid control\")";
=TEX
=SML
fun Ûmake_grammar_and_reduction_tableÝ
	(PG_Grammar(G as ((sen,_)::_)) : P_GRAMMAR)
	: SYM_CLASS GRAMMAR * string GEN_REDUCTION_TABLE = (
	let	val G' =  (sentence_symbol, [([VarClass sen], sentence_action)])::G;
		val nts = map fst G';
		fun make_sym(PuncClass s) = Terminal (PuncClass s)
		|   make_sym(VarClass s) =
			if s mem nts
			then NonTerminal s
			else Terminal(VarClass s);
		val Y = map (fn(x, y) => (x, map (fn (a,b) =>(map make_sym a, b)) y)) G';
		fun folder((def, alts), g) = g overwrite (def, lassoc4 g nil def rcup alts);
		val AG = revfold folder Y nil;
	in	(strip_action AG, make_reduction_table AG)
	end
) | make_grammar_and_reduction_table _ = raise SlrpError "invalid argument";
=TEX
\subsection{Lexical Analyser}
=TEX
The lexical analyser is very much a one-off.
It is called by the parser \cite{DS/FMU/IED/SML005}.
=TEX
Quotes in our concrete syntax for BNF are introduced by the backquote character, \verb"`"
and backslashes serve as escapes. These are needed later on so they are defined here
outside the local block containing the bulk of the lexical analyser.
=SML
    val ÛquoterÝ : string = "`";
    val ÛescapeÝ : string = "\\";
=TEX
\subsection{Local Definitions}
Most of the lexical analyser is declared within this local block.
=SML
local

    exception ÛLexFailÝ of string;

=TEX
A state, $lex\_state$, is used by most of the lexical analysis
functions, it is in two parts.  First the characters not yet tokenised,
actually a list of strings of single characters produced by exploding
the input text.  Second the token immediately preceeding the first
part.  The token may not be recognised (yet) so the token part of the
state carries a success indicator.  On entry to an analysis function
the state will be ``$(chars, (UNKNOWN, \hbox{``''}))$''.
=SML
    datatype ÛsuccessÝ = ÛKNOWNÝ of BNF_lex_class | ÛCOMMENTÝ | ÛUNKNOWNÝ;

    type ÛtokenÝ = success * string;

    type Ûlex_stateÝ  = (string list) * token;
=TEX
$collect$ adds the first character of the untokenised input text into the current token.
=SML
    fun ÛcollectÝ ( (cs, (cl, tk)) : lex_state ) : lex_state = (
        (tl cs, (cl, tk ^ (hd cs)))
    );
=TEX
The terminator characters for BNF are the following:
=SML
    val ÛterminatorsÝ : (string * BNF_lex_class) list =
	[(";", BNF_semi), ("=", BNF_eq), ("|", BNF_vert), (",", BNF_comma)];
=TEX
We lift some material here that was originally in the lexical analyser (and is still used there).
=TEX
=SML
    val Ûord0Ý	= ord "0";
    val Ûord9Ý	= ord "9";
    val ÛordaÝ	= ord "a";
    val ÛordAÝ	= ord "A";
    val ÛordzÝ	= ord "z";
    val ÛordZÝ	= ord "Z";
=SML
    fun Ûnext_is_digitÝ ((ch :: _): string list) : bool = (
        let
            val code = ord ch
        in
            (code >= ord0) andalso (code <= ord9)
        end
    ) | next_is_digit nil = false;
=TEX
We allow underscores and primes in names by treating them as letters:
=SML
    fun Ûnext_is_alphaÝ ((ch :: _): string list) : bool = (
        let
            val code = ord ch
        in
            ((code >= orda) andalso (code <= ordz)) orelse
            ((code >= ordA) andalso (code <= ordZ)) orelse
            (ch = "_") orelse (ch = "'")
        end
    ) | next_is_alpha nil = false;
=TEX
=SML
    fun Ûnext_is_termÝ (ch :: _) = any terminators (fn (c,_) => c = ch)
    |   next_is_term _ = false;

    fun Ûnext_is_quoterÝ (ch :: _) = ch = quoter
    |   next_is_quoter _ = false;

    fun Ûnext_is_spaceÝ (" " :: _) = true
    |   next_is_space ("\t" :: _) = true
    |   next_is_space ("\n" :: _) = true
    |   next_is_space _ = false;

    fun Ûnext_is_lbrackÝ ("(" :: _) = true
    |   next_is_lbrack _ = false;
 
    fun Ûnext_is_rbrackÝ (")" :: _) = true
    |   next_is_rbrack _ = false;
 
    fun Ûskip_spaceÝ (cs : string list) : string list = (
        if next_is_space cs
        then skip_space (tl cs)
        else cs
    );
=TEX
Comments are enclosed in ``(*'' and ``*)''
=SML
	fun next_is_lcomment("(" :: "*" :: _) = true
	|   next_is_lcomment _ = false;

	fun next_is_rcomment("*" :: ")" :: _) = true
	|   next_is_rcomment _ = false;

     fun Ûnext_is_otherÝ (cs as (_ :: _) : string list) = (
        (not (next_is_term cs)) andalso
        (not (next_is_space cs)) andalso
        (not (next_is_digit cs)) andalso
        (not (next_is_alpha cs)) andalso
        (not (next_is_lcomment cs)) andalso
        (not (next_is_rcomment cs)) andalso
        (not (next_is_quoter cs))
    ) | next_is_other nil = false;
=TEX
To perform the analysis a number of recognisers of tokens are provided,
they are tried in turn on the input characters until one of them
recognises one of more of the input characters as a token.  Those
characters are then removed, classified and added to the output list of
tokens.  Then the recognisers are applied to the remaining input, and
so on until there is no more input.

Function $rec_alphanum_rest$ recognises a list of alpha numerics, it is
an auxiliary for the other recognisers.
=SML
    fun Ûrec_alphanum_restÝ (cs, tok) = (
	if next_is_alpha cs orelse next_is_digit cs
	then rec_alphanum_rest (collect (cs, tok))
	else (cs, tok)
    );

    fun Ûrec_terminatorÝ ( (cs, tk) : lex_state ) : lex_state = (
        if next_is_term cs
        then (tl cs, (KNOWN(lassoc3 terminators (hd cs)), hd cs))
        else (cs, (UNKNOWN, ""))
    );
=TEX
=SML
    fun Ûrec_identifierÝ( (cs, tok) : lex_state ) : lex_state = (
	if next_is_alpha cs 
	then rec_alphanum_rest (tl cs, (KNOWN BNF_var, hd cs))
	else (cs, tok)
    );
=TEX
A string starts and finishes with $quoter$.
Within a string the escape character `$\backslash$' may be used to
provide characters not normally available.  The input to this lexical
analyser is an SML string.  All character in an SML string between the
HOL start and end quote characters will be reguarded as the HOL string,
so the SML escape sequences may be used for most characters.  The HOL
escape character `$\backslash$' is therefore only needed for itself and
the start quote character.
=SML
    fun Ûrec_quoteÝ ( (cs, (_, tk)) : lex_state ) : lex_state = (
        let
            fun rec_quote_rest qtch (cs, tok) = (
		case cs of
		("\\" :: _ :: rest) =>
			rec_quote_rest qtch (collect (tl cs, tok))
		| ("\\" :: _) =>
			raise (LexFail "escaped character at end of string")
		| (ch :: rest) =>
			if (ch = qtch)
			then (rest, tok)
			else rec_quote_rest qtch (collect (cs, tok))
		| _ => raise (LexFail "unmatched quote")
            );
        in
            if next_is_quoter cs
            then rec_quote_rest(hd cs) (tl cs, (KNOWN BNF_con, ""))
            else (cs, (UNKNOWN, ""))
        end
    );
=TEX
Actions are distinguished by their starting with a left bracket and are
finished by the matching right bracket.
=SML
    fun Ûrec_action_restÝ i (cs, tok) = (
	if next_is_lbrack cs
	then rec_action_rest (i+1) (collect (cs, tok))
	else if next_is_rbrack cs
	then	if i <= 0
		then (collect (cs, tok))
		else rec_action_rest (i-1) (collect (cs, tok))
	else if not (is_nil cs)
	then rec_action_rest i (collect(cs, tok))
	else raise (LexFail "unmatched left bracket")
    );
=TEX
=SML
    fun Ûrec_actionÝ (cs, tok) = (
	if next_is_lbrack cs
	then rec_action_rest 0 (tl cs, (KNOWN BNF_action, hd cs))
	else (cs, (UNKNOWN, ""))
    );
=TEX
=TEX
Left and right comment symbols must balance. $rec\_comment\_rest$ arranges for this:
=SML
   fun Ûrec_comment_restÝ i cs = (
	if next_is_lcomment cs
	then rec_comment_rest (i+1) (tl(tl cs))
	else if next_is_rcomment cs
	then	if i <= 0
		then (tl(tl cs), (COMMENT, ""))
		else rec_comment_rest (i-1) (tl(tl cs))
	else if not (is_nil cs)
	then rec_comment_rest i (tl cs)
	else raise (LexFail "unmatched comment symbol")
    );
=TEX
=SML
    fun Ûrec_commentÝ (cs, tok) = (
	if next_is_lcomment cs
	then rec_comment_rest 0 (tl(tl cs))
	else (cs, (UNKNOWN, ""))
    );
=TEX
Function $next\_token$ applies recogniser functions to the input
characters, returning the results of the first successful recogniser,
or an indicator of token unknown.
=SML
    fun Ûnext_tokenÝ (recognisers : (lex_state -> lex_state) list)
                   (chars       : string list) : lex_state = (
        let
            fun try (recogniser : lex_state -> lex_state,
                     (cs, (cl, tk)) : lex_state) : lex_state = (case cl of
            UNKNOWN => recogniser(cs, (cl, tk))
          |  _ => (cs, (cl, tk))
    );
        in
            revfold try recognisers (chars, (UNKNOWN, ""))
        end
    );
=TEX
Function $tokenise$ converts the input characters into tokens by
repeatedly using $next\_token$ to identify the start of the remaining
part of the input.
=SML
    fun ÛtokeniseÝ (recognisers : (lex_state -> lex_state) list)
                 (chars       : string list) : BNF_lex_item list = (
       case skip_space chars
       of
           nil => nil
       |   cs as (_::_) => (
           let
               val (cs', tk) = next_token recognisers cs;
           in
               case tk of
                   (KNOWN cls, tk) => (cls, tk):: tokenise recognisers cs'
	      |	   (COMMENT, _) => tokenise recognisers cs'
              |    (UNKNOWN, tk) =>  raise LexFail 
			("did not recognise: " ^ (hd cs'))
           end
       )
    );
=TEX
The various recognisers are gathered together in their order of application.
=SML
    val ÛrecognisersÝ = [rec_terminator,
                       rec_quote,
                       rec_identifier,
			rec_comment,
			rec_action];
in
=TEX
The interface to the lexical analyser is the following function.
=SML

    fun ÛBNF_lex_stringÝ (text : string) : BNF_lex_item list = (
	(tokenise recognisers (explode text))
	handle (LexFail msg) => (
            raise SlrpError ("Lexical analysis error: " ^ msg)
        )
    );
=TEX
That completes the lexical analyser:
=SML
end; (* of local ... in ... end *)
=TEST
BNF_lex_string "";
BNF_lex_string "a|,b";
BNF_lex_string "=|,`abc`";
BNF_lex_string "=|,`abc\\``";
BNF_lex_string "(=|,)`abc\\``";
BNF_lex_string "(=|,`abc\\``";
BNF_lex_string "(=|,`abc\\``) (((b(((a)))b)))";
BNF_lex_string "(* A C (* B C *) *) () () (jj)";
=TEX
\subsection{Parser Auxiliaries}
=SML
val ÛBNF_classifyÝ : BNF_lex_item -> BNF_lex_class = fst;
=TEX
=SML
=SML
val ÛBNF_errorÝ : (BNF_lex_item, BNF_lex_class, 'a, 'b) ERROR_ROUTINE = (
	fn (tok, stk, _, _) => 
	let	val do_tok = format_BNF_lex_item;
		val msg =
			if	any stk (fn Token _ => true | _ => false)
			then	do_tok tok ^ " not expected after: " ^ format_stack do_tok stk
			else	do_tok tok ^ " not expected here";
	in	raise SlrpError ("Syntax error: " ^ msg)
	end
);
=TEX
=SML
val ÛBNF_end_of_stringÝ : BNF_lex_item = (BNF_eos, "<End-of-Input>");
=TEX
=SML
fun ÛBNF_readerÝ (toks : BNF_lex_item list) : BNF_lex_item  * BNF_lex_item list = (
	case toks of
		(h :: more) => (h, more)
	|	[] => (BNF_end_of_string, [])
);
=TEX
=SML
val (ÛBNF_actionsÝ, ÛBNF_gotosÝ, ÛBNF_IjsÝ, ÛBNF_effgrammarÝ, ÛBNF_initÝ) =
					slr_tables BNF_grammar BNF_eos "Grammar'";
=TEX
The grammar has no conflicts so we may safely use the default
resolver to form a parser, which we set up to take its input from a file:
=SML
fun ÛBNF_parseÝ
	(file : string)
	: SYM_CLASS GRAMMAR * string GEN_REDUCTION_TABLE =
	make_grammar_and_reduction_table(
		slrp'parse
		BNF_init BNF_actions BNF_gotos BNF_reduction_table default_resolver
		BNF_classify BNF_error  BNF_reader
		(BNF_lex_string(read_file file)));
=TEX
The following function is used for formatting quoted terminal symbols.
=SML
fun ÛescapifyÝ  (x : string) : string = (
	let	val chars = explode x;
		fun aux acc [] = implode(rev acc)
		|   aux acc (ch :: chs) = (
			if	ch = quoter orelse ch = escape
			then	aux (ch::escape::acc) chs
			else	aux (ch::acc) chs
		);
	in	aux [] chars
	end
);
=TEX
The formatter for $sym\_class$ values is the following:
=SML
fun Ûformat_sym_classÝ (VarClass V) = V
|   format_sym_class (PuncClass P) = "`" ^ escapify P ^ "`";
=TEST
fun dump_string file string = (
	let	val os = open_out file;
	in	(output(os, string); close_out os)
	end
);
dump_string "slr.tst""E = E, `+`, T | T; T = T, `*`, F | F; F = `(`, E, `)` | id;";

val (test_grm1, test_rt1) = BNF_parse "slr.tst";
val (actions1, gotos1, Ijs, init) = slr_tables test_grm1 (PuncClass "$") sentence_symbol;

print_states (test_grm1, format_sym_class) Ijs;
listofarray actions1;
listofarray gotos1;
conflicts actions1 (* shouldn't be any *);

dump_string "slr.tst""E = A | B; A = x | x, A; B = | x, B;";
val (test_grm2, test_rt2) = BNF_parse "slr.tst";

val (actions2, gotos2, Ijs2, init2) = slr_tables test_grm2 (PuncClass "$") sentence_symbol;
print_states (test_grm2, format_sym_class) Ijs2;

conflicts actions2;

=TEX
\section{CONFLICT RESOLUTION}\label{CONFLICTRESOLUTION}
=TEX
To resolve a reduce/reduce conflict we need to choose an alternative in
the list of possible alternatives by which to reduce. We choose
the one which appears earliest in the grammar.
=SML
fun Ûresolve_reduce_reduceÝ (g : ('lc)GRAMMAR) (acts : ACTION list) : ACTION list = (
	let	fun folder
			(x2 as Reduce(((nt2, alt2), _)), x1 as Reduce(((nt1, alt1), _))) = (
			let	fun index nt i ((nt', _)::more) = (
					if nt = nt'
					then i
					else index nt (i+1) more
				) | index _ _ [] = raise SlrpError "invalid non-terminal";
				val (i1, i2) = (index nt1 0 g, index nt2 0 g);
			in	if i1 = i2
				then	if alt1 <= alt2
					then x1
					else x2
				else if i1 <= i2
				then x1
				else x2
			end
		) | folder (x1, _) = x1;
		val winner = fold folder acts (find acts (fn Reduce _ => true | _ => false));
	in	acts drop (fn (x as (Reduce _)) => x <> winner | _ => false)
	end	handle Fail _  => acts
);
=TEX
After resolving reduce/reduce conflicts only shift/reduce conflicts
with a single shift and a single reduce will remain (the SLR(1) algorithm
cannot produce shift/shift conflicts).
The shift/reduce conflicts are replaced by dynamic actions
and we shout loudly when we do this.

The following functions are used to do the shouting:
=SML
fun Ûformat_actionÝ (gp : (''lc) GRAMMAR * (''lc -> string)) (act : ACTION) : string = (
	case act of
		Accept => "Accept"
	|	Error => "Error"
	|	Shift i => "Shift to " ^ string_of_int i
	|	Reduce(alt, _) => "Reduce by " ^ format_alt gp alt
	|	Dynamic (i, (alt, _)) => "Either shift to " ^ string_of_int i
					^ " or reduce by " ^ format_alt gp alt
);
=TEX
=SML
fun Ûprint_actionsÝ (put : string -> unit)
	(gp as (_, p) : (''lc) GRAMMAR * (''lc -> string))
	(lc : ''lc, s : STATE, acts : ACTION list) : unit = (
	put("State " ^ string_of_int s ^ " on symbol " ^ p lc ^ "\n");
	map put (alpha_sort(map(fn act => ("\t" ^ format_action gp act ^ "\n")) acts));
	()
);
=TEX
=SML
fun Ûprint_action_tableÝ (put : string -> unit)
	(gp as (_, p) : (''lc) GRAMMAR * (''lc -> string))
	(actions : (''lc)ACTION_TABLE) : unit = (
	let	open PPArray;
		fun aux1 i ((lc, act) :: more) = (
			(lc, i, act :: map snd (more drop (fn (lc', _) => lc' <> lc)))
				:: aux1 i (more drop (fn (lc', _) => lc' = lc)) 
		) | aux1 _ [] = [];
		val actionl = flat(map (fn i => aux1 i (PPArray.sub(actions, i)))
			(interval 0 (length actions - 1)));
	
	in map (print_actions put gp) actionl; ()
	end
);
=TEX
=SML
fun Ûprint_conflictsÝ (put : string -> unit)
	(gp as (_, p) : (''lc) GRAMMAR * (''lc -> string))
	(confs : (''lc * STATE * (ACTION list)) list) : unit = (
	map (print_actions put gp) confs; ()
);
=TEX
=SML
fun Ûprint_dynamic_actionsÝ (put : string -> unit)
	(gp as (_, p) : (''lc) GRAMMAR * (''lc -> string))
	(actions : (''lc)ACTION_TABLE) : unit = (
	let	open PPArray;
		fun aux1 i ((lc, act as Dynamic _) :: more) = (
			(lc, i, [act]) :: aux1 i more
		) | aux1 i ((_, _)::more) = ( aux1 i more
		) | aux1 _ [] = [];
		val actionl = flat(map (fn i => aux1 i (PPArray.sub(actions, i)))
			(interval 0 (length actions - 1)));
	
	in map (print_actions put gp) actionl; ()
	end
);
=TEX
=SML
fun Ûhas_rrÝ (Reduce _ :: more : ACTION list) : bool = (
	any more (fn Reduce _ => true |_ =>  false)
) | has_rr (_ :: more ) = has_rr more
|   has_rr [] = false;
=TEX
=SML
fun Ûhas_srÝ (Reduce _ :: more : ACTION list) : bool = (
	any more (fn Shift _ => true |_ =>  false)
) | has_sr (Shift _ :: more : ACTION list) : bool = (
	any more (fn Reduce _ => true |_ =>  false)
) | has_sr (_ :: more ) = has_sr more
|   has_sr [] = false;
=TEX
=SML
fun Ûconflict_summaryÝ (confs : ('lc * STATE * ACTION list) list) : string = (
	let	val tot = length confs;
		val rrs = count confs (fn (_, _, acts) => not(has_sr acts));
		val srs = tot - rrs;
	in	(so_many true tot "conflict" ^ " detected") ^ 
		(if tot <> 0
		then ((" (" ^ string_of_int srs ^ " shift/reduce, "
			^ string_of_int rrs ^ " reduce/reduce)"))
		else "") ^ "\n"
	end
);
=TEX
=SML
fun Ûresolve_eitherÝ(g : ('lc)GRAMMAR) (acts : ACTION list) : ACTION = (
	let	val acts' = if has_rr acts then resolve_reduce_reduce 
			g acts else acts;
	in	case acts' of
			[(act1 as Reduce x), (act2 as Shift s)] => Dynamic(s, x)
		|	[(act1 as Shift s), (act2 as Reduce x)] => Dynamic(s, x)
		|	[act] => act
		|	other => raise SlrpError "failure in conflict resolution"
	end
);
=TEX
=SML
fun Ûresolve_conflictsÝ (g : (''lc)GRAMMAR) (actions : (''lc)ACTION_TABLE) : unit = (
	let	fun aux(lc, s, acts) = (
			let	val old = PPArray.sub(actions, s);
				val act = resolve_either g acts;
				val new = old drop (fn (lc', _) => lc = lc');
			in	PPArray.update(actions, s, new overwrite (lc, act))
			end
		);
	in	case conflicts actions of
			[] => ()
		|	todo => (map aux todo; ())
	end 
);
=TEX
\section{OUTPUT ROUTINES}\label{OUTPUTROUTINES}
=SML
local
val Ûout_fileÝ : outstream ref = ref std_out;
val ÛcursorÝ : int ref = ref 0;
in
=TEX
=SML
fun Ûopen_out_fileÝ (file : string) : unit = (
	(if file <> ""
	then out_file := open_out file
	else raise SlrpError "an empty filename is not allowed for the output file")
	handle ex as Io _ =>
	raise SlrpError("i/o failure on output file: " ^ file ^ " (" ^ string_of_exn ex ^ ")")
);
=TEX
=SML
fun Ûclose_out_fileÝ () : unit = (
	close_out (!out_file)
);
=TEX
=SML
fun Ûput_stringÝ (s:string):unit = ((
	let	val len = size s;
		val next = !cursor + len;
	in	if next <= 80
		then (
			output(!out_file, s);
			cursor := next
		) else (
			output(!out_file, "\n");
			output(!out_file, s);
			cursor := size s
		)
	end
)	handle ex as Io _ =>
	raise SlrpError("i/o failure on output file (" ^ string_of_exn ex ^ ")")
);
fun Ûput_lineÝ (s:string):unit = ((
	output(!out_file, s);
	output(!out_file,"\n");
	cursor := 0
)	handle ex as Io _ =>
	raise SlrpError("i/o failure on output file (" ^ string_of_exn ex ^ ")")
);
end; (* of local ... in ... end *)
=SML
fun Ûput_listÝ (sep : string) (s : string list) = (
	case s of
		x :: [] => put_string x
	|	x :: more => (put_string x; put_string sep; put_list sep more)
	|	[] => ()
);
=TEX
\subsection{Action Table}
=SML
fun Ûformat_action_entryÝ (p : ''lc -> string) (lc : ''lc, act : ACTION) : string = (
	"(" ^ p lc ^ "," ^ (
		case act of
			Shift s => (
				"Shift " ^ string_of_int s
		) |	Reduce ((nt, alt), n) => (
				"Reduce((\"" ^ nt ^ "\"," ^ string_of_int alt
				^	"),"^string_of_int n ^ ")"
		) |	Dynamic (s, ((nt, alt), n)) => (
				"Dynamic(" ^ string_of_int s ^ "," ^
				"((\"" ^ nt ^ "\"," ^ string_of_int alt ^ "),"^
				string_of_int n ^ "))"
		) |	Error => ("Error"
		) |	Accept => ("Accept"
		)
	) ^ ")"
);
=TEX
=SML
fun Ûoutput_action_entry_listÝ(p : ''lc -> string) (entries : (''lc * ACTION) list) : unit = (
	put_string "[";
	put_list "," (map (format_action_entry p) entries);
	put_string "]"
);
=TEX
The following functions are used to output the code to generate the action,
goto and reduction tables.
Given e.g.,
=GFT
	lists = [ [a, b], [c, d], [e] ]
	stem = "slrp'x"
	result = "slrp'array"
=TEX
The code generated by $output\_table$ will be:
=GFT
local
val slrp'x3=[e];
val slrp'x2=[c, d]@slrp'x2;
val slrp'x1=[a, b]@slrp'x1;
in
val slrp'array=PPArray.arrayoflist slrp'x1;
end;
=TEX
where the insides of the list expressions $[e]$, $[c, d]$ etc. are
output using $do1list$.
To get round the value polymorphism restriction in the case of the reduction tables
we need to defer actual construction of the values.
=TEX
=SML
fun output_loc_bindings
	(lists : 'a list)
	(do1list : 'a -> unit)
	(stem : string) (defer : bool) : unit = (
let	val nentries = length lists;
	val ns_lists = rev (combine (interval 1 nentries) lists);
	fun lvar i = stem ^ (string_of_int i);
	fun do_loc_binding (i, tab) = (
		put_string (if defer then "fun "^(lvar i)^ "()=[" else "val "^(lvar i)^"=[");
		do1list tab;
		if	i = nentries
		then	put_line "];"
		else	put_line ("]@" ^ lvar (i+1) ^ (if defer then "();" else ";"))
	);
in	map do_loc_binding ns_lists;
	()
end	
);
=TEX
=SML
fun output_table
	(lists : 'a list)
	(do1list : 'a -> unit)
	(stem : string)
	(result : string) : unit = (
let		fun do_glob_binding() = (
		put_string ("val " ^ result ^ "=PPArray.arrayoflist ");
		put_line (stem ^ string_of_int 1 ^ ";")
	);
in	put_line "local";
	output_loc_bindings lists do1list stem false;
	put_line "in";
	do_glob_binding();
	put_line "end;"
end	
);
=TEX
=SML
fun Ûoutput_action_tableÝ (p : ''lc -> string) (actions : (''lc)ACTION_TABLE) : unit = (
let	val tabs = listsofarray actions (get_int_control"slrp_break");
	fun aux (x :: []) = output_action_entry_list p x
	  | aux (x :: more) = (output_action_entry_list p x; put_string ","; aux more)
	  | aux [] = ();

in	output_table tabs aux "slrp'a" "slrp'actions"
end
);
=TEX
=SML
fun Ûdo_sym_classÝ(VarClass x : SYM_CLASS) : string = x
|   do_sym_class(PuncClass x) = x;
=TEST
output_action_table do_sym_class actions3;
=TEX
\subsection{Goto Table}
=SML
fun Ûformat_goto_entryÝ (nt : string, s : STATE) : string = (
	"(\"" ^ nt ^ "\"," ^ string_of_int s ^ ")"
);
=TEX
=SML
fun Ûoutput_goto_entry_listÝ ( entries : (string * STATE) list) : unit = (
	put_string "[";
	put_string (format_list format_goto_entry entries ",");
	put_string "]"
);
=TEX
=SML
fun Ûoutput_goto_tableÝ (gotos : GOTO_TABLE) : unit = (
let	val tabs = listsofarray gotos (get_int_control"slrp_break");
	fun aux (x :: []) = output_goto_entry_list x
	  | aux (x :: more) = (output_goto_entry_list x; put_string ","; aux more)
	  | aux [] = ();
in	output_table tabs aux "slrp'g" "slrp'gotos"
end
);
=TEST
output_goto_table gotos3;
=TEX
\subsection{Reduction Table}
=SML
fun Ûformat_reducerÝ (body : string) (n : int) : string = (
	let	val is = map string_of_int(rev (interval 1 n));
		fun do1 i = "x" ^ i;
		val xs = format_list do1 is "::";
	in	if n = 0
		then
	"(fn _ =>" ^ body ^ ")"
		else
	"(fn(" ^ xs ^ "::stk)=>" ^ body ^ 
		"|_=>raise PARSER_ERROR\"invalid reduction\")"
	end
);
=TEX
=SML
fun output_reduction_table
	(g: (''lc) GRAMMAR)
	(tab : string GEN_REDUCTION_TABLE) : unit = (
let	val tabs = listsoflist (e_flatten tab) (get_int_control"slrp_break");
	fun aux nt i (act :: more) = (
	let	val n = length(kth(expand g nt) i);
		val func = format_reducer act n;
	in	if is_nil more
		then put_string func
		else (put_string(func ^ ","); aux nt (i+1) more)
		end
	) | aux _ _ [] = ();
	fun aux1 i = "slrp'r"^(string_of_int i);

	fun aux2 (nt, acts) = (
		put_string("(\"" ^ nt ^ "\",[");
		aux nt 0 acts;
		put_string "])"
	);
	fun aux3 (row :: []) = (
		aux2 row
	) | aux3 (row :: more) = (
		aux2 row; put_string","; aux3 more
	) | aux3 [] = ();

in	put_line "local";
	output_loc_bindings tabs aux3 "slrp'r" true;
	put_line "in";
(* Value polymorphism! for SML 90 the following would work:
	put_line "val slrp'reducers = list_e_merge initial_e_dict slrp'r1;";
   but for SML 97 we must use: *)
	put_line
	"fun slrp'reducers () = list_e_merge initial_e_dict (slrp'r1());";
	put_line "end;"
end
);
=TEX
\subsection{Driver Function}
=SML
fun Ûoutput_driverÝ (init : STATE) = (
	put_line
(* Value polymorphism! for SML 90 the following would work:
	("val slrp'gen_parser = slrp'parse "
	^ string_of_int init ^ " slrp'actions slrp'gotos slrp'reducers;")
   but for SML 97 we must use: *)
	("fun slrp'gen_parser x = slrp'parse "
	^ string_of_int init ^ " slrp'actions slrp'gotos (slrp'reducers()) x;")
);
=TEST
output_driver 42;
=TEX
\subsection{Interface}
=SML
fun Ûoutput_parserÝ
		(p : ''lc -> string) 
		(g : (''lc) GRAMMAR)
		(actions : (''lc) ACTION_TABLE)
		(gotos : GOTO_TABLE)
		(tab : string GEN_REDUCTION_TABLE)
		(init : STATE) : unit = (
	output_action_table p actions;
	output_goto_table gotos;
	output_reduction_table g tab;
	output_driver init
);
=TEST
=TEX
\section{INTERFACE} \label{INTERFACE}
\subsection{ML Interface}
The parser generator is invoked using the following function {\it slrp}.
Its first three parameters are the names of the input file, output file and
the name of the
end of input lexical class.
The remaining parameters give the name of a log file and an integer which determines the level
of log information as follows:

\begin{centering}
\begin{tabular}{|l|p{4in}|}\hline
Level & Information Logged \\ \hline\hline
$\leq 0$ & The log file parameter is ignored. \\ \hline
$1$ & This gives a summary of the conflict
resolution process and a listing of any conflicts requiring
dynamic resolution. \\ \hline
$2$ & As 1 together with a listing
of the grammar and its terminals and the state table and a listing of any conflicts
before resolution. \\ \hline
$\geq 3$ & As 2 together with a listing of the full action table before resolution. \\ \hline
\end{tabular}
\end{centering}
=IGN
val in_file = "t.txt";
val out_file = "t.sml";
val log_file = "t.log";
val eos = "eos";
val log_level = 6;
val slr_only = false;
=SML
fun ÛslrpÝ {
	in_file : string,
	out_file : string,
	log_file : string,
	eos:string,
	log_level:int,
	slr_only : bool} : unit = (
	(let	val se00 = if log_level > 0 then open_log_file log_file else ();
		fun my_log msg = (if log_level > 0 then log msg else ());
	in let	val se01 = chat(burst banner);
		val se02 = my_log (burst banner);
		val se03 = open_out_file out_file;
		val (grm, reducers) = BNF_parse in_file;
		val se04 = (if log_level >= 2
			then (	log "\n"; log(burst "Grammar"); log"\n";
				print_grammar format_sym_class grm;
				log "\n"; log(burst "Terminal Symbols"); log"\n";
				print_terms format_sym_class grm;
				flush_log_file() )
			else ());
		val (actions, gotos, Ijs, eff_grammar, init) =
			slr_tables grm (PuncClass eos) sentence_symbol;
		val se05 = (if log_level >= 2
			then (	log "\n"; log(burst "State Table"); log"\n";
				print_states (grm, format_sym_class) Ijs eff_grammar)
			else ());
		val confs1 = conflicts actions;
		val se06 = if slr_only then () else 
				 lalr_resolve_conflicts
				actions gotos eff_grammar
				sentence_symbol (PuncClass eos) init
				(map (fn (s, l, _) => (l, s)) confs1)
				format_sym_class (log_level >= 5) (log_level >= 6);
		val confs2 = conflicts actions;
		val conf_msg = conflict_summary confs2;
		val se07 = (if log_level >= 2
			then (	log "\n"; log(burst "Conflicts"); log"\n";
				chat conf_msg;
				my_log conf_msg; my_log "\n";
				print_conflicts log (grm, format_sym_class) confs2)
			else(chat conf_msg; my_log"\n"; my_log conf_msg));
		val se08 = (if log_level >= 3
			then (	log "\n"; log(burst "Action Table"); log"\n";
				print_action_table log (grm, format_sym_class) actions)
			else());
		val se09 = (if not(is_nil confs2)
			then resolve_conflicts grm actions
			else ());
		val se10 = (if not(is_nil confs2)
			then (	my_log "\n"; my_log(burst "Dynamic Actions"); my_log"\n";
				print_dynamic_actions my_log (grm, format_sym_class) actions;
				chat(burst "Dynamic Actions");
				print_dynamic_actions chat (grm, format_sym_class) actions)
			else());
		val se11 = output_parser do_sym_class grm actions gotos reducers init;
		val se12 =
			if log_level >= 4
			then print_lr0_automaton_graph actions gotos init format_sym_class
			else ();
		val se13 = (chat (burst "End of Run");
				my_log "\n"; my_log (burst "End of Run"));
	in	(close_out_file(); close_log_file())
	end	handle ex as SlrpError msg =>
		(my_log "*** ERROR "; my_log msg; my_log "\n"; raise ex)
	end	handle ex as SlrpError msg =>
		(chat "*** ERROR "; chat msg; chat "\n"; raise ex))
	handle ex as PARSER_ERROR msg =>
	(chat "*** INTERNAL ERROR IN SLRP ";
	 chat msg; chat "\n"; raise SlrpError msg)
);
=TEX
=SML
end; (* of structure Slrp *)
=TEX
\subsection{Shell Interface}
=DUMP slrp
#!/bin/sh
# slrp From: $Id: imp017.doc,v 1.38 2003/02/22 22:12:50 rda Exp rda $
# Shell script to run the SLRP Parser Generator
if test -z "$PROGNAME"
then
	PROGNAME=`basename $0`
	USAGE="$PROGNAME [-l log_level] -e eos -f grammar_file"
fi
LOGLEVEL=2
EOS=
INFILE=
SLRONLY=false
while getopts l:e:f:s arg
do
	case $arg in
		l)	LOGLEVEL=$OPTARG ;;
		e)	EOS=$OPTARG ;;
		f)	INFILE=$OPTARG ;;
		s)	SLRONLY=true
	esac
done
shift `expr $OPTIND - 1`
if	test -n "$*" -o -z "$EOS" -o -z "$INFILE"
then
	echo "$PROGNAME: usage: $USAGE"
	exit 1
fi
if	test `expr "$INFILE" : ".*\\.txt\$"` -eq 0
then
	INFILE=$INFILE.txt
fi
if	test `expr "$LOGLEVEL" : "[0-9]*$"` -eq 0
then
	echo "$PROGNAME: the -l option must be a number"	
	exit 1
fi
DIR=`dirname $INFILE`
BASE=`basename $INFILE .txt`
OUTFILE=$DIR/$BASE.sml
LOGFILE=$DIR/$BASE.log
ML="(Slrp.slrp{\
	in_file=\"$INFILE\",\
	out_file=\"$OUTFILE\",\
	eos=\"$EOS\",\
	log_file=\"$LOGFILE\",\
	log_level=$LOGLEVEL,\
	slr_only=$SLRONLY}; PPCompiler.exit 0)\
	handle _ => PPCompiler.exit 1;"
=POLYDUMPMORE slrp
COMPILER=${PPCOMPILER:-POLYML}
=NJMLDUMPMORE slrp
COMPILER=${PPCOMPILER:-SMLNJ}
=DUMPMORE slrp
if test "$COMPILER" = POLYML
then
	RUNML="poly $MLFLAGS "
	HEAP_SUFFIX=polydb
elif test "$COMPILER" = SMLNJ
then
	RUNML="sml $MLFLAGS @SMLload="
	eval `.arch-n-opsys`
else
	echo "$PROGNAME: environment variable PPCOMPILER is" \
		 "$COMPILER"\
		"but should be POLYML or SMLNJ" >&2
	exit 1
fi
DBNAME=`findfile slrpdb.$HEAP_SUFFIX $PATH`
echo $ML | $RUNML$DBNAME
=TEX
=SH
chmod +x slrp
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
=TEST
fun dump_string file string = (
	let	val os = open_out file;
	in	(output(os, string); close_out os)
	end
);

dump_string "slr.tst"(
"E    = E, `Plus`, T (add x1 x3)            \n" ^
"    | T (fetch x1);            \n" ^
"T    = T, `Times`, F (mul x1 x3)        \n    " ^
"    | F (fetch x1);\n" ^
"F    = `Lbrack`, E, `Rbrack` (fetch x2)    \n        " ^
"    | Num (conv x1);            \n");


datatype LC3 = Plus | Times | Lbrack | Rbrack | Num | Eos | Wrong;
open SlrpDriver;

fun add (Parsed (x:int)) (Parsed (y:int)) = x + y
|   add _ _ = raise PARSER_ERROR "corrupt stack";
fun mul (Parsed (x:int)) (Parsed (y:int)) = x * y
|   mul _ _ = raise PARSER_ERROR "corrupt stack";
fun fetch (Parsed (x:int)) = x
|   fetch _= raise PARSER_ERROR "corrupt stack";
fun conv (Token (n:string, _)) = nat_of_string n
|   conv _ = raise PARSER_ERROR "corrupt stack";
val resolver3 = default_resolver;
fun error3 () = default_error Combinators.I;
fun lex3 (s : string) : string list = (
	let	val chars = explode s;
		fun get_num acc (x :: more) = (
			if is_all_decimal x
			then get_num (acc ^ x) more
			else (acc, x :: more)
		)  | get_num acc [] = (acc, []);
		fun get_tok (x :: more) = (
			if is_all_decimal x
			then let val (num, rest) = get_num x more
			in	num :: get_tok rest
			end else if x = " "
			then get_tok more
			else x :: get_tok more
		) | get_tok [] = []
	in	get_tok chars
	end
);
fun reader3 (ip : string list) : string * string list = (
	case ip of
		(h :: more) => (h, more)
	|	[] => ("<end-of-input>", [])
);
fun classify3 "*" = Times
|   classify3 "+" = Plus
|   classify3 "(" = Lbrack
|   classify3 ")" = Rbrack
|   classify3 "<end-of-input>" = Eos
|   classify3 Other = if is_all_decimal Other then Num else Wrong;
Slrp.slrp {in_file="slr.tst", out_file="slr.sml", log_file ="slr.log", eos ="Eos", log_level=2};
open EfficientDictionary;
use"slr.sml";
val parser3 = slrp'gen_parser resolver3 classify3 (error3()) reader3 o lex3;

parser3"1001+42";
parser3"1001 * 42";
parser3"(1001)";
parser3"1001";
parser3"(1*(2*(3*(4*(5*(6*(7*8)))))))";
parser3"(((((((1+2)+3)+4)+5)+6)+7)+8)";
parser3"((((((1+2)+3)+4)+5)+6)+7)+8)" (* error case *);
parser3"((((((((((1+2)+3)+4)+5)+6)+7)+8)" (* error case *);

Slrp.slrp {in_file="", out_file="boo", log_file ="goo", eos ="Eos", log_level=42};
Slrp.slrp {in_file="/dev/null", out_file="boo", log_file ="goo", eos ="Eos", log_level=42};
Slrp.slrp {in_file="test1.txt", out_file="boo", log_file ="goo", eos ="Eos", log_level=42};
Slrp.slrp {in_file="test2.txt", out_file="boo", log_file ="goo", eos ="Eos", log_level=42};
Slrp.slrp {in_file="test3.txt", out_file="boo", log_file ="goo", eos ="Eos", log_level=42};
Slrp.slrp {in_file="test4.txt", out_file="test4.sml", log_file ="goo", eos ="Eos", log_level=42};

dump_string "slr.tst"(
"E    = E, `sub`, E, `sup`, E        \n" ^
"    | E, `sub`, E            \n" ^
"    | E, `sup`, E            \n" ^
"    | `{`, E, `}`;            \n");

Slrp.slrp {in_file="slr.tst", out_file="slr.sml", log_file ="slr.log", eos ="Eos", log_level=2};
