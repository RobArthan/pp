%  %Z% $Date: 2002/07/25 16:11:05 $ $Revision: 1.18 $ $RCSfile: imp108.doc,v $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Portability Infrastructure Implementation}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP108}  %% Mandatory field
\def\SCCSversion{$Revision: 1.18 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2002/07/25 16:11:05 $%
}}
%\TPPstatus{Draft}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & Lemma 1}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & Lemma 1}
\TPPabstract{This document implements the detailed design given in DTD108.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Project Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issues 1.1-1.11]
Initial versions.
\item[Issue 1.12]
Added function to control garbage collector messages.
\item[Issues 1.13, 1.14, 1.15]
Port back to Poly/ML.
\item[Issue 1.16]
Updates to {\it ExtendedIO} structure to work better with SML 97 basis library.
\item[Issues 1.17--1.19] Adjusted Poly/ML pretty-printing defaults to
suppress structure names in types.
\end{description}
\subsection{Changes Forecast}
As determined by experience during the porting process.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Under contract CSM/927 with DERA Malvern, Lemma 1 Ltd. are undertaking a port of {\Product}
onto New Jersey ML v1.10. The technical background and requirements for
this work are discussed in the proposal \cite{LEMMA1/DAZ/PLN018}.

This document describes the implementation of the infrastructure supporting the port whose
design is given in \cite{DS/FMU/IED/DTD108}.


\subsection{Introduction}

See the design \cite{DS/FMU/IED/DTD108} for background and requirements.

\subsection{Dependencies}

\subsection{Possible Enhancements}

\subsection{Deficiencies}


\section{Portability Infrastructure}
\subsection{Input/Output}
=SML
structure €BasicIO› : BasicIO = struct
	type €outstream› = TextIO.outstream;
	type €instream› = TextIO.instream;
	val €close_in› : instream -> unit = TextIO.closeIn;
	val €end_of_stream› : instream -> bool = TextIO.endOfStream;
	val €std_in› : instream = TextIO.stdIn;
	val €std_out› : outstream = TextIO.stdOut;
	val €open_out› : string -> outstream = TextIO.openOut;
	val €input› : (instream * int -> string) = TextIO.inputN;
	val €lookahead› : instream -> string = (fn instrm =>
		case TextIO.lookahead instrm of
			SOME ch => str ch
		|	NONE => ""
	);
	exception €Io› = IO.Io;
	val €close_out› : outstream -> unit = TextIO.closeOut;
	val €open_in› : string -> instream = TextIO.openIn;
	val €output› : outstream * string -> unit = TextIO.output;
end (* of structure BasicIO *);
open BasicIO;
=TEX
=SML
structure €ExtendedIO› : ExtendedIO = struct 
	open BasicIO;
	val €flush_out› : outstream -> unit = TextIO.flushOut;
	val €open_append› : string -> outstream = TextIO.openAppend;
	val €input_line› : instream -> string = TextIO.inputLine;
	fun €can_input› (strm : instream, n : int) : bool = (
		case TextIO.canInput(strm, n) of
			NONE => false
		|	SOME k => k >= n
	);
	fun €is_term_in› (instream : instream) = (
		let 	val (rd as TextPrimIO.RD{ioDesc,...},buf) =
			TextIO.StreamIO.getReader(TextIO.getInstream instream);
			val _ = TextIO.setInstream
			(instream, TextIO.StreamIO.mkInstream(rd,
=NJML
				SOME
=SML
				buf));
		in	case ioDesc of
				NONE => false
			|	SOME desc => (OS.IO.kind desc = OS.IO.Kind.tty)
		end
	);
	fun €is_term_out› (outstream : outstream) = (
		let 	val (wr as TextPrimIO.WR{ioDesc,...},buf) =
			TextIO.StreamIO.getWriter(TextIO.getOutstream outstream);
		in	TextIO.setOutstream
			(outstream, TextIO.StreamIO.mkOutstream(wr, buf));
			case ioDesc of
			NONE => false
			|	SOME desc => (OS.IO.kind desc = OS.IO.Kind.tty)
		end
	);
	val €system› : string -> bool = (fn cmd =>
=NJML
		OS.Process.system cmd = OS.Process.success
=POLYML
		OS.Process.isSuccess( OS.Process.system cmd )
=SML
	);
	val €get_env› : string -> string = (fn var =>
		case OS.Process.getEnv var of
			NONE => ""
		|	SOME value => value
	);
	val €std_err› : outstream = TextIO.stdErr;
end (* of structure ExtendedIO *);
=TEX
=IGN
val (is, os) = ExtendedIO.execute "ls";
val line = ref (ExtendedIO.input_line is);
while !line <> "" do (line := ExtendedIO.input_line is; output(std_out, !line));
=TEX
\subsection{Compiler Reader Interface}
=SML
structure €PPCompiler› : PPCompiler = struct
	type €TEXT_SOURCE› = unit -> string;
	type €TEXT_FILTER› = string -> string;
	type €HANDLER› = exn -> unit;
	type €instream› = BasicIO.instream;
=TEX
For SML/NJ we must first do some fairly low-level stuff to turn a $TEXT\_SOURCE$ into an
input stream.
To get the compiler's read-eval-print loop to work properly with input
from a terminal, we need to copy the I/O descriptor out of the
stream that is actually being read into the input stream we are going to
create from the $TEXT\_SOURCE$ (the I/O descriptor and the name are the mysterious
``attributes'' mentioned in the DTD).
The following function gets the descriptor and name out for us.
The $setInstream$ call is there because getting the Reader out of the
file ``truncates'' it, i.e., in effect it really does ``get it out'' and
we have to put it back again or the file will in effect be closed.
=NJML
fun €get_io_desc› (instrm : TextIO.instream) : OS.IO.iodesc option * string = (
	let	val (rdr, bfr) =
		TextIO.StreamIO.getReader(TextIO.getInstream instrm);
		val TextPrimIO.RD {ioDesc = iod, name = name, ... } = rdr;
		val b = case bfr of "" => NONE | _ => SOME bfr;
	in	TextIO.setInstream(instrm, TextIO.StreamIO.mkInstream(rdr, b));
        	(iod, name)
	end
);
=TEX
The following function creates a primitive I/O reader from the information
supplied by either of the two compiler functions. The $name$ parameter
is ignored if the input stream parameter is supplied (when the name is taken from $get\_io\_desc$).
=NJML
fun €mk_text_reader› (
	f : TEXT_SOURCE,
	name : string,
	isopt : TextIO.instream option) : TextPrimIO.reader = (
let	val buf : string ref = ref "";
	fun read_vec i = (
		if	size (!buf) >= i
		then	let	val res = String.substring(!buf, 0, i);
			in	buf := String.extract(!buf, i, NONE); res
			end
		else	let	fun get_buf acc = (
					if	size acc >= i
					then	(acc, true)
					else	let	val str = f();
						in	if	str = ""
							then	(acc, false)
							else	get_buf (acc ^ str)
						end
				);
				val (newbuf, success) = get_buf (!buf);
			in	if	success
				then	let	val res = String.substring(newbuf, 0, i);
					in	buf := String.extract(newbuf, i, NONE);
						res
					end
				else	let	val res = newbuf;
					in	buf := "";
						res
					end
			end
	);
	val (iod, nm) = (
		case isopt of
			NONE => (NONE, name)
		|	SOME is => get_io_desc is
	);
in	TextPrimIO.augmentReader
	(TextPrimIO.RD{
		name = nm,
		avail = fn () => NONE,
		block = NONE,
		canInput = NONE,
		chunkSize = 1,
		close = fn() => (),
		endPos = NONE,
		getPos = NONE,
		ioDesc = iod,
		readArr = NONE,
		readArrNB = NONE,
		readVec = SOME read_vec,
		readVecNB = NONE,
		setPos = NONE,
		verifyPos = NONE})
end
);
=TEX
The next function underpins the two interface functions.
It's parameterisation is like that of $mk\_text\_reader$:
the name parameter is ignored if a stream is supplied.
=NJML
fun €compile_either› (
	f : TEXT_SOURCE,
	name : string,
	isopt : TextIO.instream option,
	handler : HANDLER) = (
	let	val reader = mk_text_reader(f, name, isopt);
		val strm = TextIO.mkInstream
			(TextIO.StreamIO.mkInstream(reader, NONE));
		fun go () = (
			Compiler.Interact.useStream strm
			handle ex => (
				handler ex
			)
		);
	in	go()
	end
);
=TEX
The two interface functions are now just a question of assembling
the pieces:
=NJML
fun €compile1› (name : string, f : TEXT_SOURCE, g : TEXT_FILTER, h : HANDLER)
				: unit = (
	let	fun say s = TextIO.output(std_out, g s);
		fun flush () = TextIO.flushOut std_out;
		val old = !Compiler.Control.Print.out;
	in	Compiler.Control.Print.out := {flush = flush, say = say};
		compile_either(f, name, NONE, h);
		Compiler.Control.Print.out := old
	end
);
fun €compile2› (strm : instream, f : TEXT_SOURCE, g : TEXT_FILTER, h : HANDLER)
				: unit = (
	let	fun say s = TextIO.output(std_out, g s);
		fun flush () = TextIO.flushOut std_out;
		val old = !Compiler.Control.Print.out;
	in	Compiler.Control.Print.out := {flush = flush, say = say};
		compile_either(f, "", SOME strm, h);
		Compiler.Control.Print.out := old
	end
);
=TEX
This is all very much easier for Poly/ML (which can't make any use of the
name or input stream supplied as the first component of the argument,
and doesn't need the handler, since Poly/ML prints exception values for us):
=POLYML
fun compile1 (_ : string, f : TEXT_SOURCE, g : TEXT_FILTER, _ : HANDLER)
				: unit = (
	let	fun say s = (TextIO.output(std_out, g s); TextIO.flushOut std_out);
	in	PolyML.compiler (f, say) ()
	end
);
fun compile2 (_ : instream, f : TEXT_SOURCE, g : TEXT_FILTER, _ : HANDLER)
				: unit = (
	let	fun say s = (TextIO.output(std_out, g s); TextIO.flushOut std_out);
	in	PolyML.compiler (f, say) ()
	end
);
=TEX
The rest of the compiler interface functions are little more than renamings of existing functions:
=SML
val €exit› : int -> unit =
=NJML
		OS.Process.exit;
=POLYML
	(fn res => 
		OS.Process.exit
		(if res = 0 then OS.Process.success else OS.Process.failure)
);
=TEX
=SML
val €print_depth› : int -> unit = 
=NJML
	fn d => (
	Compiler.Control.Print.printDepth := d;
	Compiler.Control.Print.printLength := d;
	Compiler.Control.Print.stringDepth := d
);
=POLYML
	PolyML.print_depth;
=TEX
=NJML
type 'a €PP_SPEC› = string list * (Compiler.PrettyPrint.ppstream -> 'a -> unit); 
=POLYML
type 'a PP_SPEC =
	(string -> unit) * (int * bool -> unit) * (int * int -> unit) * (unit -> unit)
		-> int -> unit -> 'a -> unit;
=TEX
=NJML
fun €install_pp› ((path, pp) : 'a PP_SPEC) : unit = (
	Compiler.PPTable.install_pp path pp
);
=TEX
=SML
fun €make_pp› (path : string list)
		(pprint :
			(string -> unit) * (int * bool -> unit)
			* (int * int -> unit) * (unit -> unit) -> 'a -> unit) :
		'a PP_SPEC =
=NJML
(	let	open Compiler.PrettyPrint;
		fun pp pps = (
			pprint 
			(add_string pps,
			fn (i, f) => begin_block pps (if f then CONSISTENT else INCONSISTENT) i,
			add_break pps,
			fn () => end_block pps));
    in
      (path, pp)
    end
);
=POLYML
(fn funs => fn _ => fn _ => fn obj => pprint funs obj);
=SML
val €gc_messages› : bool -> unit = 
=NJML
SMLofNJ.Internals.GC.messages;
=POLYML
fn _ => ();
=SML
val _ = gc_messages false;
=TEX
=SML
end (* of structure PPCompiler *);
=TEX
% \subsection{Arithmetic}

\subsection{String Processing}
=SML
structure €PPString› : PPString = struct
	open SML90;
	fun string_of_exn (ex : exn) : string = (
		let	val nm = exnName ex;
			val msg = exnMessage ex;
		in	"(Exception: " ^
			(if	msg = ""
			then	nm
			else	nm ^ ": " ^ msg) ^ ")"
		end
	);
end (* of structure PPString *);
open PPString;
=TEX
\subsection{Array Processing}
=SML
structure €PPArray› : PPArray = struct
	open Array;
	val arrayoflist : 'a list -> 'a array = fromList;
	open General;
end (* of structure PPArray *);
=TEX
\subsection{Vector Processing}
=SML
structure €PPVector› : PPVector = struct
	open Vector;
	val vector : 'a list -> 'a vector = fromList;
	open General;
end (* of structure PPVector *);

=TEX

\subsection{Build Interfaces}
=SML
structure €PPBuild› : PPBuild = struct
	val pp'save_name : string ref = ref "hol";
	val pp'use_function : (string -> unit) ref = ref use;
	fun €pp'set_use› (new : string -> unit) : string -> unit = (
		let	val old = !pp'use_function;
		in	pp'use_function := new;
			old
		end
	);
	fun €pp'save› () : bool =
=NJML
	(not(SMLofNJ.exportML (!pp'save_name)));
=POLYML
	(PolyML.commit ());
=SML
	val €loaded_files› : string list ref = ref ["dtd108.sml", "imp108.sml"];
	fun €pp'use› (file_name : string) : unit = (
		! pp'use_function file_name;
		loaded_files := !loaded_files @ [file_name]
	);
	fun €pp'load› (file_name : string) : bool = (
		pp'use file_name handle ex => (
			output(std_out, "*** " ^ string_of_exn ex ^ " ***\n");
			PPCompiler.exit 1
		);
		pp'save ()
	);
	fun €pp'loaded_file_names› () : string list = (
		!loaded_files
	);
end (* of structure PPBuild *);
=TEX
\subsection{Standard ML '97 Basis Library}
=SML
structure SML97BasisLibrary = struct
	structure Array  = Array ;
	structure BinIO  = BinIO ;
	structure BinPrimIO  = BinPrimIO ;
	structure Bool  = Bool ;
	structure Byte  = Byte ;
	structure Char  = Char ;
	structure CharArray  = CharArray ;
	structure CharVector  = CharVector ;
	structure CommandLine  = CommandLine ;
	structure Date  = Date ;
	structure General  = General ;
	structure IEEEReal  = IEEEReal ;
	structure Int  = Int ;
	structure IO  = IO ;
	structure LargeInt  = LargeInt ;
	structure LargeReal  = LargeReal ;
	structure LargeWord  = LargeWord ;
	structure List  = List ;
	structure ListPair  = ListPair ;
	structure Math  = Math ;
	structure Option  = Option ;
	structure OS  = OS ;
	structure Position  = Position ;
	structure Real  = Real ;
	structure SML90  = SML90 ;
	structure String  = String ;
	structure StringCvt  = StringCvt ;
	structure Substring  = Substring ;
	structure TextIO  = TextIO ;
	structure TextPrimIO  = TextPrimIO ;
	structure Time  = Time ;
	structure Timer  = Timer ;
	structure Vector  = Vector ;
	structure Word  = Word ;
	structure Word8  = Word8 ;
	structure Word8Array  = Word8Array ;
	structure Word8Vector  = Word8Vector ;
end (* of structure SML97BasisLibrary *);
=TEX
\section{COMPILER OPTIONS}
The following seems a bit over the top, but stops builds failing if the option setting goes awry,
e.g., because different compiler versions don't support some options.
=POLYML
local
	open PPCompiler;
	fun text_source_of_string (s : string) : TEXT_SOURCE = (
		let	val buffer : string list ref = ref (explode s);
		in	fn () => 
			case !buffer of
				ch::more => (buffer := more; ch)
			|	[] => ""
		end
	);
	val text_filter : TEXT_FILTER = fn s => s;
	val handler : HANDLER =  (fn ex => output(std_out, "**** " ^ string_of_exn ex ^ " ***\n"));
	fun execute_string (s : string) : unit = (
		compile1("", text_source_of_string s, text_filter, handler)
		handle ex =>  ()
	);
	val cmds = [
		"PolyML.Compiler.printTypesWithStructureName := false;"
	];
in
	val _ = map execute_string cmds;
end;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
