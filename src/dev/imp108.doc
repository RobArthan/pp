%  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Portability Infrastructure Implementation}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP108}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Draft}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & Lemma 1}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & Lemma 1}
\TPPabstract{This document implements the detailed design given in DTD108.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Project Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issues 1.1-1.7]
Initial versions.
\end{description}
\subsection{Changes Forecast}
As determined by experience during the porting process.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Under contract CSM/927 with DERA Malvern, Lemma 1 Ltd. are undertaking a port of {\Product}
onto New Jersey ML v1.10. The technical background and requirements for
this work are discussed in the proposal \cite{LEMMA1/DAZ/PLN018}.

This document describes the implementation of the infrastructure supporting the port whose
design is given in \cite{DS/FMU/IED/DTD108}.


\subsection{Introduction}

See the design \cite{DS/FMU/IED/DTD108} for background and requirements.

\subsection{Dependencies}

\subsection{Possible Enhancements}

\subsection{Deficiencies}


\section{Portability Infrastructure}
\subsection{Input/Output}
=SML
structure €BasicIO› : BasicIO = struct
	type €outstream› = TextIO.outstream;
	type €instream› = TextIO.instream;
	val €close_in› : instream -> unit = TextIO.closeIn;
	val €end_of_stream› : instream -> bool = TextIO.endOfStream;
	val €std_in› : instream = TextIO.stdIn;
	val €std_out› : outstream = TextIO.stdOut;
	val €open_out› : string -> outstream = TextIO.openOut;
	val €input› : (instream * int -> string) = TextIO.inputN;
	val €lookahead› : instream -> string = (fn instrm =>
		case TextIO.lookahead instrm of
			SOME ch => str ch
		|	NONE => ""
	);
	exception €Io› = IO.Io;
	val €close_out› : outstream -> unit = TextIO.closeOut;
	val €open_in› : string -> instream = TextIO.openIn;
	val €output› : outstream * string -> unit = TextIO.output;
end (* of structure BasicIO *);
open BasicIO;
=TEX
=SML
structure €ExtendedIO› : ExtendedIO = struct 
	open BasicIO;
	val €flush_out› : outstream -> unit = TextIO.flushOut;
	val €open_append› : string -> outstream = TextIO.openAppend;
	val €input_line› : instream -> string = TextIO.inputLine;
	fun €can_input› (strm : instream, n : int) : bool = (
		case TextIO.canInput(strm, n) of
			NONE => false
		|	SOME k => k >= n
	);
	fun €is_term_in› (instream : instream) = (
		let 	val (rd as TextPrimIO.RD{ioDesc,...},buf) =
			TextIO.StreamIO.getReader(TextIO.getInstream instream)
		in	TextIO.setInstream
			(instream, TextIO.StreamIO.mkInstream(rd, SOME buf));
			case ioDesc of
			NONE => false
			|	SOME desc => (OS.IO.kind desc = OS.IO.Kind.tty)
		end
	);
	fun €is_term_out› (outstream : outstream) = (
		let 	val (wr as TextPrimIO.WR{ioDesc,...},buf) =
			TextIO.StreamIO.getWriter(TextIO.getOutstream outstream)
		in	TextIO.setOutstream
			(outstream, TextIO.StreamIO.mkOutstream(wr, buf));
			case ioDesc of
			NONE => false
			|	SOME desc => (OS.IO.kind desc = OS.IO.Kind.tty)
		end
	);
	fun €execute› (cmd_args : string) : instream * outstream = (
		Unix.streamsOf(Unix.execute("/bin/sh", ["-c", cmd_args]))
	);
end (* of structure ExtendedIO *);
=TEX
=IGN
val (is, os) = ExtendedIO.execute "ls";
val line = ref (ExtendedIO.input_line is);
while !line <> "" do (line := ExtendedIO.input_line is; output(std_out, !line));
=TEX
\subsection{Compiler Reader Interface}
=SML
structure €PPCompiler› : PPCompiler = struct
	type €TEXT_SOURCE› = unit -> string;
	type €TEXT_FILTER› = string -> string;
	type €HANDLER› = exn -> unit;
	type €instream› = BasicIO.instream;
=TEX
First some fairly low-level stuff to turn a $TEXT\_SOURCE$ into an
input stream.
To get the compiler's read-eval-print loop to work properly with input
from a terminal, we need to copy the I/O descriptor out of the
stream that is actually being read into the input stream we are going to
create from the $TEXT\_SOURCE$ (the I/O descriptor and the name are the mysterious
``attributes'' mentioned in the DTD).
The following function gets the descriptor and name out for us.
The $setInstream$ call is there because getting the Reader out of the
file ``truncates'' it, i.e., in effect it really does ``get it out'' and
we have to put it back again or the file will in effect be closed.
=SML
fun €get_io_desc› (instrm : TextIO.instream) : OS.IO.iodesc option * string = (
	let	val (rdr, bfr) =
		TextIO.StreamIO.getReader(TextIO.getInstream instrm);
		val TextPrimIO.RD {ioDesc = iod, name = name, ... } = rdr;
		val b = case bfr of "" => NONE | _ => SOME bfr;
	in	TextIO.setInstream(instrm, TextIO.StreamIO.mkInstream(rdr, b));
        	(iod, name)
	end
);
=TEX
The following function creates a primitive I/O reader from the information
supplied by either of the two compiler functions. The $name$ parameter
is ignored if the input stream parameter is supplied (when the name is taken from $get\_io\_desc$).
=SML
fun €mk_text_reader› (
	f : TEXT_SOURCE,
	name : string,
	isopt : TextIO.instream option) : TextPrimIO.reader = (
let	val buf : string ref = ref "";
	fun read_vec i = (
		if	size (!buf) >= i
		then	let	val res = String.substring(!buf, 0, i);
			in	buf := String.extract(!buf, i, NONE); res
			end
		else	let	fun get_buf acc = (
					if	size acc >= i
					then	(acc, true)
					else	let	val str = f();
						in	if	str = ""
							then	(acc, false)
							else	get_buf (acc ^ str)
						end
				);
				val (newbuf, success) = get_buf (!buf);
			in	if	success
				then	let	val res = String.substring(newbuf, 0, i);
					in	buf := String.extract(newbuf, i, NONE);
						res
					end
				else	let	val res = newbuf;
					in	buf := "";
						res
					end
			end
	);
	val (iod, nm) = (
		case isopt of
			NONE => (NONE, name)
		|	SOME is => get_io_desc is
	);
in	TextPrimIO.augmentReader
	(TextPrimIO.RD{
		name = nm,
		avail = fn () => NONE,
		block = NONE,
		canInput = NONE,
		chunkSize = 1,
		close = fn() => (),
		endPos = NONE,
		getPos = NONE,
		ioDesc = iod,
		readArr = NONE,
		readArrNB = NONE,
		readVec = SOME read_vec,
		readVecNB = NONE,
		setPos = NONE,
		verifyPos = NONE})
end
);
=TEX
The next function underpins the two interface functions.
It's parameterisation is like that of $mk\_text\_reader$:
the name parameter is ignored if a stream is supplied.
=SML
fun €compile_either› (
	f : TEXT_SOURCE,
	name : string,
	isopt : TextIO.instream option,
	handler : HANDLER) = (
	let	val reader = mk_text_reader(f, name, isopt);
		val strm = TextIO.mkInstream
			(TextIO.StreamIO.mkInstream(reader, NONE));
		fun go () = (
			Compiler.Interact.useStream strm
			handle ex => (
				handler ex
			)
		);
	in	go()
	end
);
=TEX
The two interface functions are now just a question of assembling
the pieces:
=SML
fun €compile1› (name : string, f : TEXT_SOURCE, g : TEXT_FILTER, h : HANDLER)
				: unit = (
	let	fun say s = TextIO.output(std_out, g s);
		fun flush () = TextIO.flushOut std_out;
		val old = !Compiler.Control.Print.out;
	in	Compiler.Control.Print.out := {flush = flush, say = say};
		compile_either(f, name, NONE, h);
		Compiler.Control.Print.out := old
	end
);
fun €compile2› (strm : instream, f : TEXT_SOURCE, g : TEXT_FILTER, h : HANDLER)
				: unit = (
	let	fun say s = TextIO.output(std_out, g s);
		fun flush () = TextIO.flushOut std_out;
		val old = !Compiler.Control.Print.out;
	in	Compiler.Control.Print.out := {flush = flush, say = say};
		compile_either(f, "", SOME strm, h);
		Compiler.Control.Print.out := old
	end
);
=TEX
The rest of the compiler interface functions are just renamings of existing functions:
=SML
val €exit› : int -> unit = OS.Process.exit;
=TEX
=SML
val €print_depth› : int -> unit = fn d => Compiler.Control.Print.printDepth := d;
=TEX
=SML
type 'a €PP_SPEC› = string list * (Compiler.PrettyPrint.ppstream -> 'a -> unit); 
=TEX
=SML
fun €install_pp› ((path, pp) : 'a PP_SPEC) : unit = (
	Compiler.PPTable.install_pp path pp
);
=TEX
=SML
fun €make_pp› (path : string list)
		(pprint :
			(string -> unit) * (int * bool -> unit)
			* (int * int -> unit) * (unit -> unit) -> 'a -> unit) :
		'a PP_SPEC = (
	let	open Compiler.PrettyPrint;
		fun pp pps = (
			pprint 
			(add_string pps,
			fn (i, f) => begin_block pps (if f then CONSISTENT else INCONSISTENT) i,
			add_break pps,
			fn () => end_block pps));
    in
      (path, pp)
    end
);
=SML
end (* of structure PPCompiler *);
=TEX
% \subsection{Arithmetic}

\subsection{String Processing}
=SML
structure €PPString› : PPString = struct
	open SML90;
	fun string_of_exn (ex : exn) : string = (
		let	val nm = exnName ex;
			val msg = exnMessage ex;
		in	"(Exception: " ^
			(if	msg = ""
			then	nm
			else	nm ^ ": " ^ msg) ^ ")"
		end
	);
end (* of structure PPString *);
open PPString;
=TEX
\subsection{Array Processing}
=SML
structure €PPArray› : PPArray = struct
	open Array;
	val arrayoflist : 'a list -> 'a array = fromList;
	open General;
end (* of structure PPArray *);
=TEX
\subsection{Vector Processing}
=SML
structure €PPVector› : PPVector = struct
	open Vector;
	val vector : 'a list -> 'a vector = fromList;
	open General;
end (* of structure PPVector *);

=TEX

\subsection{Build Interfaces}
=SML
structure €PPBuild› : PPBuild = struct
	val pp'save_name : string ref = ref "hol";
	val pp'use_function : (string -> unit) ref = ref use;
	fun €pp'use› (file_name : string) : unit = (
		! pp'use_function file_name
	);
	fun €pp'set_use› (new : string -> unit) : string -> unit = (
		let	val old = !pp'use_function;
		in	pp'use_function := new;
			old
		end
	);
	fun €pp'save› () : bool = (
		SMLofNJ.exportML (!pp'save_name)
	);
	fun €pp'load› (file_name : string) : bool = (
		pp'use file_name handle ex => (
			output(std_out, "*** " ^ string_of_exn ex ^ " ***\n");
			PPCompiler.exit 1
		);
		pp'save ()
	);
end (* of structure PPBuild *);
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}

use"dtd108.sml";
use"imp108.sml";

structure S = struct
	datatype T = MkT of string list
end;
		((string -> unit) * (int * bool -> unit)
			* (int * int -> unit) * (unit -> unit) -> 'a -> unit)
fun ppS (add_str, begin_b, add_brk, end_block) (S.MkT ss) = (
	begin_b (2, false);
	add_str"("; add_brk(1,1);
	map (fn s => (add_str "["; add_str s; add_str "]"; add_brk(1,1))) ss;
	add_str ")";
	end_block()
);
val pp_spec = PPCompiler.make_pp ["S", "T"] ppS;
PPCompiler.install_pp pp_spec;
S.MkT[];
S.MkT["ABCDEF", "GHIJKL", "MNOPQR", "STUVWX"];
S.MkT["ABCDEF", "GHIJKL", "MNOPQR", "STUVWX",
	"ABCDEF", "GHIJKL", "MNOPQR", "STUVWX",
	"ABCDEF", "GHIJKL", "MNOPQR", "STUVWX",
	"ABCDEF", "GHIJKL", "MNOPQR", "STUVWX"];

fun f () = ExtendedIO.input_line std_in;

fun h ex = (
	output(std_out, "EXCEPTION: "^ string_of_exn ex ^ "\n")
);
fun handler (ex : exn) : unit = (
	case ex of 
		Fail msg =>  output(std_out, "EXCEPTION: "^ string_of_exn ex ^ "\n")
	|	Error msg => output(std_out, "EXCEPTION: "^ string_of_exn ex ^ "\n")
	|	_ => raise ex
);

PPCompiler.compile2(std_in, f, Combinators.I, handler);

val arr = arrayoflist [1,2,3];
sub(arr, 3);
1 div 0;
