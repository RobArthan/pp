% imp100.doc  %Z% $Date$ $Revision$ $RCSfile$

=TEX
% imp100.doc  %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[11pt,TQ,hol1]{article}

\TPPtitle{Implementation of Document Handling Commands for Solaris 2}
\TPPref{DS/FMU/IED/IMP100}
\def\SCCSissue{$Revision$%
}

=IGNORE

sieve sml < imp100.doc
mv docsml doctex texdvi doctch doctds sun4bin

doctex imp100 ; texdvi imp100
bibtex imp100
dvipage imp100 &
=TEX

\TPPissue{\SCCSissue}
\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{FST}

\TPPstatus{Draft}
\TPPtype{Literate Script}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of the shell scripts
		for document processing.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

\ftlinepenalty=9999
\tabstop=0.9\tabstop
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage
\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}

\begin{description}

\item[Issue 1.1] First version based on \cite{DS/IED/FMU/IMP055}. The difference is that on Solaris 2, saving the tty settings prior to calling LaTeX causes the processing to wait on the terminal when run as a background task.
\item[Issue 1.2 \FormatDate{94/12/13}] Bug fixing so that $docpr$ works under Solaris 2.
\item[Issue 1.3] Added the $-e$ flag to $doctex$ and $docdvi$.
\item[Issue 1.4] In $doctex$, modified the call to $ex$ and improved error handling to report to the user if use of the $-e$ flag fails.
\end{description}

%********************************************************************

%\subsection{Changes Forecast}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the implementation of the documents transforming
utility programs whose detailed design is in~\cite{DS/FMU/IED/DTD100}.

%********************************************************************

\subsection{Introduction}

\subsubsection{Purpose and Background}

A number of programs are provided here that call the sieve program,
see~\cite{DS/FMU/IED/DTD053}, to get various views of a document file.
Related programs here perform further processing of the outputs of the
sieving process.

\subsubsection{Dependencies}

These programs use the sieve program, see~\cite{DS/FMU/IED/DTD053},
they are written as Bourne Shell scripts (see {\tt sh(1)} of the Sun
UNIX manual set) and require some of the utilities found with the Unix
operating system.

%--------------------------------------------------------------------

\subsubsection{Interface}

Full details of the interfaces to these programs and functions
are given inthe user document for the document processing
system~\cite{DS/FMU/IED/USR001}.

%--------------------------------------------------------------------

%\subsubsection{Possible Enhancements}

%--------------------------------------------------------------------

%\subsubsection{Deficiencies}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{STRUCTURE OF THIS DOCUMENT}

This file contains a number of shell scripts.  These scripts are
extracted by using the sieve program as follows.

=GFT Shell commands
sieve sml < imp100.doc
=TEX

A side effect of this sieving action is the creation of the programs
and setting the executable flag in their file permissions.  The
standard output of the sieve program is empty.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{PROGRAM DOCTEX}

Shell script to strip {\tt.doc} files creating \LaTeX{} {\tt.tex} files.

=DUMP doctex
#! /bin/sh
#	doctex   From: %Z% $Date$ $Revision$ $RCSfile$
#
# Shell script to strip ".doc" files creating ".tex" files.

PROGNAME=`basename $0`
USAGE="$PROGNAME [-v] [-e edit_script] [-f view_file] [-K] [-k keyword_file] <file> ..."
USAGEMSG="$PROGNAME: usage: $USAGE"

VERBOSE="n"
EDITFILE=""
SIEVEFILE=""
KEYFILE=""
OPT_K=""

while true
do
	case $1 in
	-e)		EDITFILE="$EDITFILE $2"	; shift ; shift	;;
	-f)		SIEVEFILE="-f $2"		; shift ; shift	;;
	-K)		OPT_K="-K"			  shift		;;
	-k)		KEYFILE=$KEYFILE" -k $2"	; shift ; shift	;;
	-v)		VERBOSE="y"			; shift 	;;
	--)						  shift ; break ;;
	-*)		echo "Bad flag for $PROGNAME: $1"
			echo $USAGEMSG 1>&2
								  exit 1 ;;
	*)							  break ;;
	esac
done

if test $# -lt 1
then
	echo $USAGEMSG 1>&2
	exit 1
fi

EXITSTATUS=0

for FILE
do
	stem=`basename $FILE .doc`
	docfile=$stem.doc
	outfile=$stem.tex

	if test $VERBOSE = "y"
	then
		echo $PROGNAME: reading $docfile writing $outfile
	fi

	if test ! -r $docfile
	then
		echo "$PROGNAME:" $docfile "does not exist or cannot be read" 1>&2
		EXITSTATUS=1
	else
		sieve $OPT_K $KEYFILE $SIEVEFILE tex < $docfile > $outfile

		if test ! -s $outfile
		then
			echo $PROGNAME: Warning, file $outfile is empty
		fi
	fi
done

if [ "$EDITFILE" = "" ]
then	:
else
	for FILE
	do
		stem=`basename $FILE .doc`
		texfile=$stem.tex
		ex -s $texfile 2>&1 >/dev/null <<EOF
`cat $EDITFILE`
wq
EOF
		EXITSTATUS=$?
		if [ "$EXITSTATUS" -ne 0 ]
		then
		   echo $PROGNAME: Warning, $EDITFILE failed to modify $FILE
		else	:
		fi
	done
fi


exit $EXITSTATUS
=TEX

=SH
chmod +x doctex
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{PROGRAM DOCSML}

Shell script to strip {\tt.doc} files creating Standard~ML {\tt.sml}
files together with the extraction of error messages.

=DUMP docsml
#! /bin/sh
#	docsml   From: %Z% $Date$ $Revision$ $RCSfile$

PROGNAME=`basename $0`
USAGE="$PROGNAME [-v] [-f view_file] [-K] [-k keyword_file] <file> ..."
USAGEMSG="$PROGNAME: usage: $USAGE"

VERBOSE="n"
SIEVEFILE=""
KEYFILE=""
OPT_K=""

while true
do
	case $1 in
	-f)		SIEVEFILE="-f $2"		; shift ; shift	;;
	-K)		OPT_K="-K"			  shift		;;
	-k)		KEYFILE=$KEYFILE" -k $2"	; shift ; shift	;;
	-v)		VERBOSE="y"			; shift 	;;
	--)						  shift ; break ;;
	-*)		echo "Bad flag for $PROGNAME: $1"
			echo $USAGEMSG 1>&2
								  exit 1 ;;
	*)							  break ;;
	esac
done

if test $# -lt 1
then
	echo $USAGEMSG 1>&2
	exit 1
fi

EXITSTATUS=0

for FILE
do
	stem=`basename $FILE .doc`
	docfile=$stem.doc
	outfile=$stem.sml

	if test $VERBOSE = "y"
	then
		echo $PROGNAME: reading $docfile writing $outfile
	fi

	if test ! -r $docfile
	then
		echo "$PROGNAME:" $docfile "does not exist or cannot be read" 1>&2
		EXITSTATUS=1
	else
		sieve $OPT_K $KEYFILE $SIEVEFILE sml < $docfile > $outfile

		sieve $OPT_K $KEYFILE $SIEVEFILE errors < $docfile \
		| sed \
		-e '1,1s/^\([0-9][0-9]*\)		*\(.*\)/'\
'(new_error_message {id= \1, text = "\2\\/'\
		-e '2,$s/^		*\(.*\)/	\\ \1\\/' \
		-e '2,$s/^\([0-9][0-9]*\)		*\(.*\)/'\
'\\" }; new_error_message {id= \1, text = "\2\\/' \
		-e '$s/\\$/" });/' \
	>> $outfile

		if test ! -s $outfile
		then
			echo $PROGNAME: Warning, file $outfile is empty
		fi
	fi
done

exit $EXITSTATUS
=TEX

=SH
chmod +x docsml
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{PROGRAM DOCTCH}

Shell script to strip {\tt.doc} files creating theory checking
files {\tt.tch} files.

=DUMP doctch
#! /bin/sh
#	doctch   From: %Z% $Date$ $Revision$ $RCSfile$

PROGNAME=`basename $0`
USAGE="$PROGNAME [-v] [-f view_file] [-K] [-k keyword_file] <file> ..."
USAGEMSG="$PROGNAME: usage: $USAGE"

VERBOSE="n"
SIEVEFILE=""
KEYFILE=""
OPT_K=""

while true
do
	case $1 in
	-f)		SIEVEFILE="-f $2"		; shift ; shift	;;
	-K)		OPT_K="-K"			  shift		;;
	-k)		KEYFILE=$KEYFILE" -k $2"	; shift ; shift	;;
	-v)		VERBOSE="y"			; shift 	;;
	--)						  shift ; break ;;
	-*)		echo "Bad flag for $PROGNAME: $1"
			echo $USAGEMSG 1>&2
								  exit 1 ;;
	*)							  break ;;
	esac
done

if test $# -lt 1
then
	echo $USAGEMSG 1>&2
	exit 1
fi

if test ! \( -s dtd035.sml -a -s imp035.sml \)
then
	echo Files \"dtd035.sml\" and \"imp035.sml\" required 1>&2
	exit 1
fi

EXITSTATUS=0

for FILE
do
	stem=`basename $FILE .doc`
	docfile=$stem.doc
	outfile=$stem.tch

	if test $VERBOSE = "y"
	then
		echo $PROGNAME: reading $docfile writing $outfile
	fi

	if test ! -r $docfile
	then
		echo "$PROGNAME:" $docfile "does not exist or cannot be read" 1>&2
		EXITSTATUS=1
	else
		(	echo 'use_file "dtd035";'
			echo 'use_file "imp035";'
			echo 'req_flag := Check;'
			echo 'initialise_td_results ();'
			sieve $OPT_K $KEYFILE $SIEVEFILE thydoc < $docfile
			echo 'summarize_td_results ();'
		) > $outfile
	fi
done

exit $EXITSTATUS
=TEX

=SH
chmod +x doctch
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{PROGRAM DOCTDS}

Shell script to strip {\tt.doc} files creating theory design
{\tt.tds} files.

=DUMP doctds
#! /bin/sh
#	doctds   From: %Z% $Date$ $Revision$ $RCSfile$

PROGNAME=`basename $0`
USAGE="$PROGNAME [-v] [-f view_file] [-K] [-k keyword_file] <file> ..."
USAGEMSG="$PROGNAME: usage: $USAGE"

VERBOSE="n"
SIEVEFILE=""
KEYFILE=""
OPT_K=""

while true
do
	case $1 in
	-f)		SIEVEFILE="-f $2"		; shift ; shift	;;
	-K)		OPT_K="-K"			  shift		;;
	-k)		KEYFILE=$KEYFILE" -k $2"	; shift ; shift	;;
	-v)		VERBOSE="y"			; shift 	;;
	--)						  shift ; break ;;
	-*)		echo "Bad flag for $PROGNAME: $1"
			echo $USAGEMSG 1>&2
								  exit 1 ;;
	*)							  break ;;
	esac
done

if test $# -lt 1
then
	echo $USAGEMSG 1>&2
	exit 1
fi

if test ! \( -s dtd035.sml -a -s imp035.sml \)
then
	echo Files \"dtd035.sml\" and \"imp035.sml\" required 1>&2
	exit 1
fi

EXITSTATUS=0

for FILE
do
	stem=`basename $FILE .doc`
	docfile=$stem.doc
	outfile=$stem.tds

	if test $VERBOSE = "y"
	then
		echo $PROGNAME: reading $docfile writing $outfile
	fi

	if test ! -r $docfile
	then
		echo "$PROGNAME:" $docfile "does not exist or cannot be read" 1>&2
		EXITSTATUS=1
	else
		(	echo 'use_file "dtd035";'
			echo 'use_file "imp035";'
			echo 'req_flag := Declare;'
			echo 'initialise_td_results ();'
			sieve $OPT_K $KEYFILE $SIEVEFILE thydoc < $docfile
			echo 'summarize_td_results ();'
		) > $outfile
	fi
done

exit $EXITSTATUS
=TEX

=SH
chmod +x doctds
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{PROGRAM TEXDVI}

Shell script to run \LaTeX{} on a {\tt.tex} file creating as the main
output a {\tt.dvi} file.  Other files include the index {\tt.idx} file
which is sorted to create a {\tt.sid} file.

Note the sort of the index file.  First duplicates are removed, then
the page numbers are adjusted to be three characters with leading
spaces so that the final sort will place entries for the same name in
ascending order of page number.

=DUMP texdvi
#! /bin/sh
#	texdvi   From: %Z% $Date$ $Revision$ $RCSfile$

PROGNAME=`basename $0`
USAGE="$PROGNAME [-v] [-p TeX_program] <file> ..."
USAGEMSG="$PROGNAME : usage: $USAGE"

VERBOSE="n"
TEXPROGRAM="latex"

while true
do
	case $1 in
	-p)		TEXPROGRAM=$2			; shift ; shift	;;
	-v)		VERBOSE="y"			; shift 	;;
	--)						  shift ; break ;;
	-*)		echo "Bad flag for $PROGNAME: $1"
			echo $USAGEMSG 1>&2
								  exit 1 ;;
	*)							  break ;;
	esac
done

if test $# -lt 1
then
	echo $USAGEMSG 1>&2
	exit 1
fi

EXITSTATUS=0

for FILE
do
	stem=`basename $FILE .tex`
	dvifile=$stem.dvi
	idxfile=$stem.idx
	sidfile=$stem.sid
	texfile=$stem.tex

	if test $VERBOSE = "y"
	then
		echo $PROGNAME: reading $texfile writing $dvifile
	fi

	if test ! -r $texfile
	then
		echo "$PROGNAME:" $texfile "does not exist or cannot be read" 1>&2
		EXITSTATUS=1
	else
		touch $sidfile
		$TEXPROGRAM $stem
		if test -r $idxfile
		then
			sort -u $idxfile \
			| sed	-e 's/{\([0-9]}\)$/{  \1/' \
				-e 's/{\([0-9][0-9]}\)$/{ \1/' \
			| sort -f > $sidfile
		fi
	fi
done

exit $EXITSTATUS
=TEX

=SH
chmod +x texdvi
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{PROGRAM DOCDVI}

Shell script that combines the actions of {\tt doctex}, {\tt bibtex}
(which is part of the basic \TeX{} distribution) and {\tt texdvi} with
the intention of fully processing a simple document from its {\tt.doc}
form to a printable {\tt.dvi} file.

Shell script to strip {\tt.doc} files creating theory design
{\tt.tds} files.

=DUMP docdvi
#! /bin/sh
#	docdvi   From: %Z% $Date$ $Revision$ $RCSfile$

PROGNAME=`basename $0`
USAGE="$PROGNAME [-v] [-e edit_script] [-f view_file] [-K] [-k keyword_file]"
USAGE="$USAGE [-p TeX_program] <file> ..."
USAGEMSG="$PROGNAME: usage: $USAGE"

VERBOSE="n"
EDITFILE=""
SVARGS=""
TEXPROGRAM="latex"
DOLATEX="3"
OPT_K=""

while true
do
	case $1 in
	-e)		EDITFILE="$EDITFILE -e $2"	; shift ; shift	;;
	-f)		SVARGS=$SVARGS" -f $2"		; shift ; shift	;;
	-K)		SVARGS=$SVARGS" -K"		  shift		;;
	-k)		SVARGS=$SVARGS" -k $2"		; shift ; shift	;;
	-p)		TEXPROGRAM=$2			; shift ; shift	;;
	-v)		VERBOSE="y"			; shift 	;;
	-4)		DOLATEX="4"			  shift		;;
	-3)		DOLATEX="3"			  shift		;;
	-2)		DOLATEX="2"			  shift		;;
	-1)		DOLATEX="1"			  shift		;;
	--)						  shift ; break ;;
	-*)		echo "Bad flag for $PROGNAME: $1"
			echo $USAGEMSG 1>&2
								  exit 1 ;;
	*)							  break ;;
	esac
done

if test $# -lt 1
then
	echo $USAGEMSG 1>&2
	exit 1
fi

TEXARGS="-p "$TEXPROGRAM

EXITSTATUS=0

for FILE
do
	stem=`basename $FILE .doc`
	docfile=$stem.doc
	dvifile=$stem.dvi

	if test $VERBOSE = "y"
	then
		echo $PROGNAME: reading $docfile writing $dvifile
	fi

	doctex $EDITFILE $SVARGS $stem || { EX=$? ; EXITSTATUS=1 ; continue ; }
	texdvi $TEXARGS $stem < /dev/null || { EX=$? ; EXITSTATUS=1 ; continue ; }
	bibtex $stem < /dev/null || { EX=$? ; EXITSTATUS=1 ; continue ; }
	if	test $DOLATEX -ge 2
	then	texdvi $TEXARGS $stem < /dev/null \
		|| { EX=$? ; EXITSTATUS=1 ; continue ; }
	fi
	if	test $DOLATEX -ge 3
	then	texdvi $TEXARGS $stem < /dev/null \
		|| { EX=$? ; EXITSTATUS=1 ; continue ; }
	fi
	if	test $DOLATEX -ge 4
	then	texdvi $TEXARGS $stem < /dev/null \
		|| { EX=$? ; EXITSTATUS=1 ; continue ; }
	fi
done

exit $EXITSTATUS
=TEX

=SH
chmod +x docdvi
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{PROGRAM DOCPR}

Shell script to print a file containing extended characters in a
verbatim fashion.

{\hfuzz 2.2pt
=DUMP docpr
#! /bin/sh
#	docpr   From: %Z% $Date$ $Revision$ $RCSfile$

PROGNAME=`basename $0`
USAGE="$PROGNAME [-n] [-p] [-s] [-v] [-w width] <filename> ..."
USAGEMSG="$PROGNAME : usage: $USAGE"

VERBOSE="n"
SCREENVIEW="n"
PRESERVE="n"
WIDTH="80"
NUMBERED="n"
TEMPDIR=/tmp
TEMPSTEM=$PROGNAME$$
TEMPFILE=$TEMPDIR/$TEMPSTEM

while true
do
	case $1 in
	-n)		NUMBERED="y"			  shift		;;
	-p)		PRESERVE="y"			  shift		;;
	-s)		SCREENVIEW="y"			  shift		;;
	-v)		VERBOSE="y"			; shift 	;;
	-w)		WIDTH=$2			; shift ; shift	;;
	--)						  shift ; break ;;
	-*)		echo "Bad flag for $PROGNAME: $1"
			echo $USAGEMSG 1>&2
								  exit 1 ;;
	*)							  break ;;
	esac
done

tidyup() {
	rm -f	$TEMPFILE.doc $TEMPFILE.tex \
		$TEMPFILE.aux \
		$TEMPFILE.sid $TEMPFILE.log
	test $PRESERVE = "y" || rm -f $TEMPFILE.dvi
}
trap tidyup 0 1 2 3 15

NUMBERPROG="nl -ba"
test $NUMBERED = "n" && NUMBERPROG="cat"

(
	echo =TEX
	echo \\documentstyle[TQa4,hol1,11pt]{article}
	echo \\\\ftlinepenalty=0
	echo \\\\begin{document}
	echo \\ShowAllImages
	echo \\\\vertbarfalse
	echo \\underscoreoff

	if test $VERBOSE = "y" -a $PRESERVE = "y"
	then
		echo Listing to file $TEMPFILE.dvi 1>&2
	fi

	for FILE
	do
		if test $VERBOSE = "y"
		then
			echo Listing of file $FILE 1>&2
		fi

		echo \\setcounter{page}{1}
		echo \\section*{Listing of file $FILE}

		if [ -r $FILE ]
		then
			echo =GFTSHOW

			$NUMBERPROG $FILE | expand | fold -$WIDTH \
			| unexpand | sed -e "1,\$s/^/ /"

			echo =TEX
		else
			echo "File "$FILE" does not exist or cannot be read."
			echo "$PROGNAME: file "$FILE" does not exist or cannot be read" 1>&2
			EXITSTATUS=1
		fi

		echo \\\\newpage
	done

	echo =TEX
	echo \\end{document}

) > $TEMPFILE.doc

cd $TEMPDIR

doctex $TEMPSTEM
texdvi $TEMPSTEM < /dev/null

if test $SCREENVIEW = "n"
then
	dvips $TEMPSTEM
else
	xdvi $TEMPSTEM
fi

exit $EXITSTATUS
=TEX
}

=SH
chmod +x docpr
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{PROGRAMS CONV_ASCII AND CONV_EXTENDED}

The two conversion programs are so similar that we generate them by
running sed on a temporary file:

=DUMP conv_temp
#! /bin/sh
#	conv_ascii/conv_extended   From: %Z% $Date$ $Revision$ $RCSfile$

PROGNAME=`basename $0`
USAGE="$PROGNAME [-v] [-K] [-k keyword_file] <file> ..."
USAGEMSG="$PROGNAME: usage: $USAGE"

SIEVEFILE=""
KEYFILE=""
RENAME="y"
OPT_K=""

while true
do
	case $1 in
	-K)		OPT_K="-K"			  shift		;;
	-k)		KEYFILE=$KEYFILE" -k $2"	; shift ; shift	;;
	-r)		RENAME="n"			; shift 	;;
	--)						  shift ; break ;;
	-*)		echo "Bad flag for $PROGNAME: $1"
			echo $USAGEMSG 1>&2
								  exit 1 ;;
	*)							  break ;;
	esac
done

if test $# -lt 1
then
	echo $USAGEMSG 1>&2
	exit 1
fi

EXITSTATUS=0

convert(){
	{ echo '=CONVERT_FORMAT' ; sed -e '1,$s/^/ /' $2 ; echo '=IGN' ; } |
		sieve $OPT_K $KEYFILE $1 | sed -e '1,$s/ //'
}

for FILE
do
	stem=`basename $FILE .doc`
	docfile=$stem.doc
	outfile=$stem.SED_SUFFIX

	if test ! -r $docfile
	then
		echo "$PROGNAME:" $docfile "does not exist or cannot be read" 1>&2
		EXITSTATUS=1
	else
		convert SED_TO $docfile > $outfile
		if	test $RENAME = "y"
		then	if	(convert SED_FROM $outfile 2>/dev/null |
					cmp -s - $docfile)
			then	if	mv $outfile $docfile
				then	EXITSTATUS=0
				else	echo $PROGNAME:\
					"cannot rename $outfile as $docfile;"
					echo $PROGNAME:\
					"output of conversion is in $outfile" 1>&2
					EXITSTATUS=1
				fi
			else	echo $PROGNAME:\
				"conversion may not have been successful;"
				echo $PROGNAME:\
				"$docfile unchanged;" \
				"output of conversion is in $outfile" 1>&2
				EXITSTATUS=2
			fi
		fi
	fi
done

exit $EXITSTATUS
=TEX
=SH
sed	-e '/SED_FROM/s/SED_FROM/extended/' \
	-e '/SED_TO/s/SED_TO/ascii/' \
	-e '/SED_SUFFIX/s/SED_SUFFIX/asc/' \
	<conv_temp >conv_ascii
chmod +x conv_ascii

sed	-e '/SED_FROM/s/SED_FROM/ascii/' \
	-e '/SED_TO/s/SED_TO/extended/' \
	-e '/SED_SUFFIX/s/SED_SUFFIX/ext/' \
	<conv_temp >conv_extended
chmod +x conv_extended
rm conv_temp
=TEX
\newpage
\section{PROGRAM SHOW_PALETTE}

Shell script to show a palette of the extended characters used by ICL HOL.

=DUMP palette
#! /bin/sh
#	palette   From: %Z% $Date$ $Revision$ $RCSfile$

PROGNAME=`basename $0`
USAGE="$PROGNAME"
USAGEMSG="$PROGNAME : usage: $USAGE"

if test $# -ge 1
then
	echo $USAGEMSG 1>&2
	exit 1
fi

textedit -margin 0 \
	-Wn -read_only \
	-Es 0 \
	-Wp 929 130 \
	-Ws 200 770 \
	-WP 732   0 \
	-Wt `findfile holpalette.vfont $PATH` \
	`findfile holpalette $PATH` \
	&
=TEX

=SH
chmod +x palette
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
