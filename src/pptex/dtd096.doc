=IGN
********************************************************************************
dtd096.doc: this file is part of the PPHol system

Copyright (c) 2016 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex

\def\Title{Detailed Design for sieve and findfile utilities}

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document gives the detailed design for the sieve and finfile utilities.}
\end{center}}

\def\Reference{LEMMA1/HOL/DTD096}

\def\Author{R.B.~Jones}

\def\EMail{{\tt rbj@rbjones.com}}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{\VCVersion}
\def\Date{\FormatDate{\VCDate}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\newpage
\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[2016/08/27]
First working draft (as dtd123) arising from port of pputf8 contrib into pptex.
\item[2016/12/]
Conversion to dtd096 as imp123 is incorporated into imp096, providing a first cut implementation of pputf8 and utf8pp in {\Product} 

%%%% END OF CHANGES HISTORY %%%%
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}

Lemma 1 build system.

\newpage

\section{Introduction}
\subsection{Scope}
This document is the detailed design document for the sieve and findfile utilities in {\Product}.

However, its scope is limited, the principal documentation for these utilities being USR001.
It primarily covers the changes to {\Product} for the support of utf8, and initial drafts will be simple copies of the principal correspondence discussing how this should be done.

\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD011}.

This document is now being used as top level documentation for the proposed implementation of utf8 support in \Product{}, since the main action is in {\tt sieve}.

\section{Support for utf8 UNICODE in {\Product}}

\subsection{Goals}

The PPTex package is to support UTF-8 encoded Unicode mark-up in ProofPower documents.
It will continue to support the ProofPower 8-bit encoded extended character set (hereafter referred
to as EXT), with some qualification in relation to the distributed concatenation operator, which is being phased out.
It will continue to support the ProofPower ASCII encoding.
It will support conversion to and from all three formats.
The ASCII encoding can be used in documents that also use the EXT encoding and it will be supported in documents that use the UTF-8 encoding.
There is no requirement to support documents involving a mixture of UTF-8 and EXT.
The full UNICODE code set is supported in all document types, in the ASCII format through the use of percent keywords, either giving the UNICODE code point, or a keyword which has been declared in a {\tt sievekeyword} file to be synonymous with some code point.
A reconciliation will be undertaken between the keywords at present used in \Product{} and those in the set nominated in the MathML standard, and a {\tt sievekeyword} file will be supplied containing the resulting keyword definitions.

The PPXpp package is to support UTF-8 encoded Unicode mark-up as far as is possible with
the OpenMotif GUI technology.
This will be done by translation from the chosen file encoding to the \Product{} extended character set supplemented as required by percent keywords as names or for code points for which no name has been declared, as codes.


\subsubsection{Observations}

The use of a Byte-Order-Marker to identify a file as using UTF-8 encodings seems to
be deprecated.

The long term goal is for UTF-8 to supersede EXT.

MathML defines XML entity names for a lot of the symbols we need (and many more).
Adopting these names will give a user-friendly alternative to numeric code points.

Assumption: the distribution concatenation symbol can be removed and everywhere replaced
by its two character equivalent. 
The conversions from extended character set files will continue to accept the distributed concatenation code, but the conversion to the extended character set will not make use of the character, and the \Product{} Reader/Writer will expand it on input, but not compress on output.

At Phil Clayton‚Äôs (nice) suggestion, the ProofPower mapping currently maps the greek
letters to the corresponding code points for Mathematical Alphanumeric Symbols in the range
1D400‚Äì1D7FF. The MathML entities use the code points for Greek in the range 0370‚Äì03FF.
The Mathematical Greek Symbols do look nice, but to gain compatibility with MathML,
we would like to revert to using the code points for Greek in the range 0370-03FF.
This will also allow you to enter Greek by switching to a  standard Greek keyboard mapping.
In passing we will also use the right symbol for $\phi$ (the current mapping uses what LaTeX
calls ``\\varphi'' rather than ``\\phi'').

\subsubsection{Background}

The contrib package PPUtf8 defines a mapping from EXT and UTF-8 and provides filters
to convert between the two formats.

The PPHol packages provide support for input and output using either EXT or UTF-8.

The PPTex package provides a program called sieve which supports conversion
between EXT and ASCII encodings and projection onto SML, TeX and other formats
for further processing.

\subsubsection{Approach}

Removal of distributed concatenation character: remove uses of this character from PPZed.
Rationalise UTF-8 support in PPHol (module 122) as EXT characters now map to a single Unicode code point and not a list.

[Not convinced by this, it seems to me to raise difficulties on the transition, which are best avoided by continuing to expand the extended character.]

\subsubsection{sieve}

Sieve will be enhanced so that keywords of the form %#xXXXXXX% and %#NNNNNN%
are predefined (where XXXXXX and NNNNNN represent case-insensitive (?) hexadecimal
and decimal representations of a valid Unicode code point).
The optional numeric encoding of a code for a glyph in the sieve keyword file entries will now be interpreted as a Unicode code point.

A fixed mapping from extended characters to UNICODE code points will be used, rather than including this in the {\tt sievekeyword} file.

Using the existing sameas mechanism, we can then implement the MathML entity names.
This involves a certain amount of reconciliation in the handful of cases where existing
ProofPower entity names conflict with MathML. Some adjustments to the existing mapping
from EXT to UTF-8 might be needed (e.g., it was a nice idea to change to using
the mathematical greek characters, but it might be better to revert for conformance with MathML).

Module 122 from PPHol and the modules from PPDev that it depends on will
be moved into PPTex and replaced by links in PPHol and/or PPDev. They will
be used in a build-time script to generate the part of the sieve keyword file
that identifies Unicode code points with their EXT encoding. [Alternatively,
this could just be extracted with a sed or perl script. Or [RDA preference] we could do it the other
way round and generate the table in imp122.doc from a file of extchar entries in the PPTex
source.

sieve will have command line options to select between UTF-8 and EXT on inputs and
outputs (independently so all 4 directions of conversion are possible). The driver
scripts (doctex etc.) will define a new file name extension for UTF-8 encoded
documents. We need to think through the options for the outputs of these scripts
on case-by-case basis. E.g., would it be prudent for docsml to output ASCII only?

\subsection{Unicode Mapping for ProofPower}

The version documented in this subsection is the mapping for the original extended codes in which one of these codes maps to a sequence of two UNICODE code points.
It is now intended to eliminate this anomoly as part of the UNICODE support transition.

The mapping is defined in terms of a basic translation table, which,
subject to some additional rules, defines a translation
from ProofPower to Unicode or from Unicode to ProofPower.
There are some notes giving the rationale for the mapping.

\subsubsection{Basic Translation Table}

The following table gives a one-to-one mapping from a subset of
the ProofPower extended character set to the Unicode
character set.
The range of the mapping includes all the ProofPower extended characters
with the exception of the byte 0x8B.

The LaTeX column contains GIFs showing the typeset form of each character
(produced using dvipng). The GIFs should display properly in any browser
without any Unicode support.  The Unicode column shows the corresponding
Unicode glyph as rendered by your web browser.

\subsubsection{ProofPower to Unicode}

Translating ProofPower into Unicode converts a stream of bytes into a stream of Unicode code points.
An ASCII string of the form ''%x\emph{HHHHHH}%", where \emph{HHHHHH}
is a string of 6 upper-case hexadecimal digits representing a value in the range
0x000100 to 0x10FFFF, is translated into the Unicode code point with that value.
Strings of this form are identified reading from left to right.
Any byte in the range 0x00 to 0x7F not appearing in
such a string is translated into the Unicode code point with the same numeric value.

A byte in the range 0x80 to 0xFF other than 0x8B is translated
into the Unicode code point identified in the basic translation table above.
0x8B was previously translated into two characters but is now withdrawn and may be reassigned.

\subsubsection{Unicode to ProofPower}

Translating Unicode converts a stream of code points into a stream of bytes.

A Unicode code point in the range 0x000000 to 0x00007F is
translated into the byte with the same numeric value.
A Unicode code point listed in the Code Point column in the basic translation table is translated into the byte with the numeric value given in the Byte column.
A Unicode code point in the range 0x000080 to 0x10FFFF that is not listed in the basic translation table
is translated into the ASCII string "%x\emph{HHHHHH}%", where \emph{HHHHHH} represents the value of the code
point as 6 upper-case hexadecimal digits.

\subsubsection{Rationale}

The mapping for Z symbols (other than paragraph mark-up) follows the ISO Z
Standard Unicode mark-up.  An exception is that the ASCII minus sign is
translated unchanged while the unary minus sign 0xF8 is translated into SMALL
HYPHEN-MINUS. Unfortunately, SMALL HYPHEN-MINUS often seems to be rendered
bigger than HYPHEN-MINUS.

Unicode does not provide any single glyphs that resemble
the decorated Quine corners provided in the ProofPower character set
for quoting HOL types, ML and Z. Squared letters T, M and Z have been
used as a convenient single character translation for these.

The %x\emph{HHHHHH}% format allows any code point to be used in a ProofPower identifier.
Strings of this form are highly unlikely to occur in existing scripts and so there is no requirement for a string of this form to be translated into Unicode as 9 ASCII characters.

\section{CONVERSION TABLES}

Two conversion tables are required, in multiple forms.

The first is the mapping of \Product{} extended codes to unicode code points.
This is a fixed mapping, having one definitive version as an SML definition, which is used to generate other versions as required, and incorporated into the \Product{} build as required by inclusion from other parts of the build.
This is done for the structure Unicode, which makes the \Product{} to utf8 mapping in an SML structure in \Product{}, and may also be imported into the Reader/Writer.
The table is also used to generate C header files used by sieve to implement {\tt pputf8} and {\tt utf8pp}.

I had originally naively supposed the SML table could be included with a DUMP directive in imp096, but the dump would have to be done by {\tt sieve} so there is a chicken and egg problem here, so the following two little sections need to be reconsidered.

\subsection{SML PP to UNICODE Code Table}

This module supplies an SML file defining a conversion table from PP extended characters to their UNICODE code points.
This is the definitive mapping and should be used by any other part of the system which requires this mapping.
However, the mapping is made available in {\Product} via the structure \emph{Unicode} provided by {\tt dtd/imp122} and should be used through that structure where possible.
It is used by some code below to generate header files which are incorporated into the {\tt sieve} program.
Since this generation must take place after sieve has been built, the resulting files will be placed in the repository, so that sieve can be built without having to run this code, and the core will only be used if it is necessary to update the tables.

=DUMP basic_pp_to_unicode_table.sml
val √õbasic_pp_to_unicode_table√ù : (char * UNICODE) list = map (C.chr ** Combinators.I) [
	(0x80,	0wx002286 )	(* SUBSET OF OR EQUAL TO *),
	(0x81,	0wx002a65 )	(* Z NOTATION RANGE ANTIRESTRICTION *),
	(0x82,	0wx00228e )	(* MULTISET UNION *),
	(0x83,	0wx01d54c )	(* MATHEMATICAL DOUBLE-STRUCK CAPITAL U *),
	(0x84,	0wx01d6e5 )	(* MATHEMATICAL ITALIC CAPITAL DELTA *),
	(0x85,	0wx002218 )	(* RING OPERATOR *),
	(0x86,	0wx01d6f7 )	(* MATHEMATICAL ITALIC CAPITAL PHI *),
	(0x87,	0wx01d6e4 )	(* MATHEMATICAL ITALIC CAPITAL GAMMA *),
	(0x88,	0wx002514 )	(* BOX DRAWINGS LIGHT UP AND RIGHT *),
	(0x89,	0wx0022ce )	(* CURLY LOGICAL OR *),
	(0x8A,	0wx01d6e9 )	(* MATHEMATICAL ITALIC CAPITAL THETA *),
	(0x8C,	0wx01d6ec )	(* MATHEMATICAL ITALIC CAPITAL LAMDA *),
	(0x8D,	0wx002208 )	(* ELEMENT OF *),
	(0x8E,	0wx002209 )	(* NOT AN ELEMENT OF *),
	(0x8F,	0wx002916 )	(* RIGHTWARDS TWO-HEADED ARROW WITH TAIL *),
	(0x90,	0wx01d6f1 )	(* MATHEMATICAL ITALIC CAPITAL PI *),
	(0x91,	0wx0024dc )	(* CIRCLED LATIN SMALL LETTER M *),
	(0x92,	0wx0025b7 )	(* WHITE RIGHT-POINTING TRIANGLE *),
	(0x93,	0wx01d6f4 )	(* MATHEMATICAL ITALIC CAPITAL SIGMA *),
	(0x94,	0wx0024e3 )	(* CIRCLED LATIN SMALL LETTER T *),
	(0x95,	0wx01d6f6 )	(* MATHEMATICAL ITALIC CAPITAL UPSILON *),
	(0x96,	0wx01d539 )	(* MATHEMATICAL DOUBLE-STRUCK CAPITAL B *),
	(0x97,	0wx01d6fa )	(* MATHEMATICAL ITALIC CAPITAL OMEGA *),
	(0x98,	0wx01d6ef )	(* MATHEMATICAL ITALIC CAPITAL XI *),
	(0x99,	0wx01d6f9 )	(* MATHEMATICAL ITALIC CAPITAL PSI *),
	(0x9A,	0wx002205 )	(* EMPTY SET *),
	(0x9B,	0wx0022cf )	(* CURLY LOGICAL AND *),
	(0x9C,	0wx002550 )	(* BOX DRAWINGS DOUBLE HORIZONTAL *),
	(0x9D,	0wx002552 )	(* BOX DRAWINGS DOWN SINGLE AND RIGHT DOUBLE *),
	(0x9E,	0wx002915 )	(* RIGHTWARDS ARROW WITH TAIL WITH DOUBLE VERTICAL STROKE *),
	(0x9F,	0wx0021fb )	(* RIGHTWARDS ARROW WITH DOUBLE VERTICAL STROKE *),
	(0xA0,	0wx002282 )	(* SUBSET OF *),
	(0xA1,	0wx002229 )	(* INTERSECTION *),
	(0xA2,	0wx0027e9 )	(* MATHEMATICAL RIGHT ANGLE BRACKET *),
	(0xA3,	0wx002296 )	(* CIRCLED MINUS *),
	(0xA4,	0wx0021d4 )	(* LEFT RIGHT DOUBLE ARROW *),
	(0xA5,	0wx0022c2 )	(* N-ARY INTERSECTION *),
	(0xA6,	0wx00225c )	(* DELTA EQUAL TO *),
	(0xA7,	0wx0027e8 )	(* MATHEMATICAL LEFT ANGLE BRACKET *),
	(0xA8,	0wx002987 )	(* Z NOTATION LEFT IMAGE BRACKET *),
	(0xA9,	0wx002988 )	(* Z NOTATION RIGHT IMAGE BRACKET *),
	(0xAA,	0wx002194 )	(* LEFT RIGHT ARROW *),
	(0xAB,	0wx002295 )	(* CIRCLED PLUS *),
	(0xAC,	0wx00231c )	(* TOP LEFT CORNER *),
	(0xAD,	0wx002192 )	(* RIGHTWARDS ARROW *),
	(0xAE,	0wx00231d )	(* TOP RIGHT CORNER *),
	(0xAF,	0wx00211d )	(* DOUBLE-STRUCK CAPITAL R *),
	(0xB0,	0wx0025a0 )	(* BLACK SQUARE *),
	(0xB1,	0wx002227 )	(* LOGICAL AND *),
	(0xB2,	0wx002228 )	(* LOGICAL OR *),
	(0xB3,	0wx0000AC )	(* NOT SIGN *),
	(0xB4,	0wx0021d2 )	(* RIGHTWARDS DOUBLE ARROW *),
	(0xB5,	0wx002200 )	(* FOR ALL *),
	(0xB6,	0wx002203 )	(* THERE EXISTS *),
	(0xB7,	0wx002981 )	(* Z NOTATION SPOT *),
	(0xB8,	0wx0000d7 )	(* MULTIPLICATION SIGN *),
	(0xB9,	0wx0024c8 )	(* CIRCLED LATIN CAPITAL LETTER S *),
	(0xBA,	0wx002982 )	(* Z NOTATION TYPE COLON *),
	(0xBB,	0wx002a3e )	(* Z NOTATION RELATIONAL COMPOSITION *),
	(0xBC,	0wx002264 )	(* LESS-THAN OR EQUAL TO *),
	(0xBD,	0wx002260 )	(* NOT EQUAL TO *),
	(0xBE,	0wx002265 )	(* GREATER-THAN OR EQUAL TO *),
	(0xBF,	0wx01d54a )	(* MATHEMATICAL DOUBLE-STRUCK CAPITAL S *),
	(0xC0,	0wx00222a )	(* UNION *),
	(0xC1,	0wx01d6fc )	(* MATHEMATICAL ITALIC SMALL ALPHA *),
	(0xC2,	0wx01d6fd )	(* MATHEMATICAL ITALIC SMALL BETA *),
	(0xC3,	0wx002291 )	(* SQUARE IMAGE OF OR EQUAL TO *),
	(0xC4,	0wx01d6ff )	(* MATHEMATICAL ITALIC SMALL DELTA *),
	(0xC5,	0wx01d700 )	(* MATHEMATICAL ITALIC SMALL EPSILON *),
	(0xC6,	0wx01d711 )	(* MATHEMATICAL ITALIC SMALL PHI *),
	(0xC7,	0wx01d6fe )	(* MATHEMATICAL ITALIC SMALL GAMMA *),
	(0xC8,	0wx01d702 )	(* MATHEMATICAL ITALIC SMALL ETA *),
	(0xC9,	0wx01d704 )	(* MATHEMATICAL ITALIC SMALL IOTA *),
	(0xCA,	0wx01d703 )	(* MATHEMATICAL ITALIC SMALL THETA *),
	(0xCB,	0wx01d705 )	(* MATHEMATICAL ITALIC SMALL KAPPA *),
	(0xCC,	0wx01d706 )	(* MATHEMATICAL ITALIC SMALL LAMDA *),
	(0xCD,	0wx01d707 )	(* MATHEMATICAL ITALIC SMALL MU *),
	(0xCE,	0wx01d708 )	(* MATHEMATICAL ITALIC SMALL NU *),
	(0xCF,	0wx002900 )	(* RIGHTWARDS TWO-HEADED ARROW WITH VERTICAL STROKE *),
	(0xD0,	0wx01d70b )	(* MATHEMATICAL ITALIC SMALL PI *),
	(0xD1,	0wx01d712 )	(* MATHEMATICAL ITALIC SMALL CHI *),
	(0xD2,	0wx01d70c )	(* MATHEMATICAL ITALIC SMALL RHO *),
	(0xD3,	0wx01d70e )	(* MATHEMATICAL ITALIC SMALL SIGMA *),
	(0xD4,	0wx01d70f )	(* MATHEMATICAL ITALIC SMALL TAU *),
	(0xD5,	0wx01d710 )	(* MATHEMATICAL ITALIC SMALL UPSILON *),
	(0xD6,	0wx002102 )	(* DOUBLE-STRUCK CAPITAL C *),
	(0xD7,	0wx01d714 )	(* MATHEMATICAL ITALIC SMALL OMEGA *),
	(0xD8,	0wx01d709 )	(* MATHEMATICAL ITALIC SMALL XI *),
	(0xD9,	0wx01d713 )	(* MATHEMATICAL ITALIC SMALL PSI *),
	(0xDA,	0wx01d701 )	(* MATHEMATICAL ITALIC SMALL ZETA *),
	(0xDB,	0wx00298f )	(* LEFT SQUARE BRACKET WITH TICK IN BOTTOM CORNER *),
	(0xDC,	0wx002502 )	(* BOX DRAWINGS LIGHT VERTICAL *),
	(0xDD,	0wx00298e )	(* RIGHT SQUARE BRACKET WITH TICK IN BOTTOM CORNER *),
	(0xDE,	0wx0022c3 )	(* N-ARY UNION *),
	(0xDF,	0wx0021f8 )	(* RIGHTWARDS ARROW WITH VERTICAL STROKE *),
	(0xE0,	0wx0021a3 )	(* RIGHTWARDS ARROW WITH TAIL *),
	(0xE1,	0wx002a64 )	(* Z NOTATION DOMAIN ANTIRESTRICTION *),
	(0xE2,	0wx0022a5 )	(* UP TACK *),
	(0xE3,	0wx0021d0 )	(* LEFTWARDS DOUBLE ARROW *),
	(0xE4,	0wx002283 )	(* SUPERSET OF *),
	(0xE5,	0wx002287 )	(* SUPERSET OF OR EQUAL TO *),
	(0xE6,	0wx01d53d )	(* MATHEMATICAL DOUBLE-STRUCK CAPITAL F *),
	(0xE7,	0wx002197 )	(* NORTH EAST ARROW *),
	(0xE8,	0wx002198 )	(* SOUTH EAST ARROW *),
	(0xE9,	0wx002261 )	(* IDENTICAL TO *),
	(0xEA,	0wx002195 )	(* UP DOWN ARROW *),
	(0xEB,	0wx002040 )	(* CHARACTER TIE *),
	(0xEC,	0wx0021bf )	(* UPWARDS HARPOON WITH BARB LEFTWARDS *),
	(0xED,	0wx0021a6 )	(* RIGHTWARDS ARROW FROM BAR *),
	(0xEE,	0wx002115 )	(* DOUBLE-STRUCK CAPITAL N *),
	(0xEF,	0wx0021a0 )	(* RIGHTWARDS TWO HEADED ARROW *),
	(0xF0,	0wx002119 )	(* DOUBLE-STRUCK CAPITAL P *),
	(0xF1,	0wx0024e9 )	(* CIRCLED LATIN SMALL LETTER Z *),
	(0xF2,	0wx0025c1 )	(* WHITE LEFT-POINTING TRIANGLE *),
	(0xF3,	0wx00211a )	(* DOUBLE-STRUCK CAPITAL Q *),
	(0xF4,	0wx0022a2 )	(* RIGHT TACK *),
	(0xF5,	0wx002a3d )	(* RIGHTHAND INTERIOR PRODUCT *),
	(0xF6,	0wx002a3c )	(* INTERIOR PRODUCT *),
	(0xF7,	0wx00251c )	(* BOX DRAWINGS LIGHT VERTICAL AND RIGHT *),
	(0xF8,	0wx00fe63 )	(* SMALL HYPHEN-MINUS *),
	(0xF9,	0wx0021be )	(* UPWARDS HARPOON WITH BARB RIGHTWARDS *),
	(0xFA,	0wx002124 )	(* DOUBLE-STRUCK CAPITAL Z *),
	(0xFB,	0wx0027e6 )	(* MATHEMATICAL LEFT WHITE SQUARE BRACKET *),
	(0xFC,	0wx002500 )	(* BOX DRAWINGS LIGHT HORIZONTAL *),
	(0xFD,	0wx0027e7 )	(* MATHEMATICAL RIGHT WHITE SQUARE BRACKET *),
	(0xFE,	0wx002914 )	(* RIGHTWARDS ARROW WITH TAIL WITH VERTICAL STROKE *),
	(0xFF,	0wx00250c )	(* BOX DRAWINGS LIGHT DOWN AND RIGHT *)
];
=TEX

\subsection{C Header Files}

The following material is the SML program for generating .h files which contain translation tables.
At present this contains its own definition of the pp extended character to unicode mapping, but it will be updated to use the previous version, shared with imp122 and also used by the reader/writer.

This module creates two C header files pputf8tab.h and utf8pptab.h containing tables defining the mapping between \Product{} extended character codes and unicode points, and provides two programs which convert files between the two representations.

The header files are available for use by any other programs which might undertake similar translations, the programs are supplied as a part of \Product{} release.

This file generates C header files pputf8tab.h utf8pptab.h
containing definitions of tables mapping ProofPower extended characters
to and from UTF-8 encoded Unicode equivalents.
=SML
structure PPUtf8 = struct
local
structure €W› = Word;
structure €C› = SML97BasisLibrary.Char;
structure €S› = SML97BasisLibrary.String;
in
(*
=TEX
The following implements the full UCS encoding and does not impose the UTF-8 rules.
=SML
*)
fun €utf8_of_word› (w : W.word) : string = (
	S.implode (map (C.chr o W.toInt) (
	if	w <= 0wx7f	(* <= 7 bits *)
	then	[	w]
	else if	w <= 0wx7ff	(* <= 11 bits *)
	then	[	W.orb(0wxc0, W.>>(w, 0wx6)),
			W.orb(0wx80, W.andb(w, 0wx3f))]
	else if	w <= 0wxffff	(* <= 16 bits *)
	then	[	W.orb(0wxe0, W.>>(w, 0wxc)),
			W.orb(0wx80, W.>>(W.andb(w, 0wxfc0), 0wx6)),
			W.orb(0wx80, W.andb(w, 0wx3f))]
	else if	w <= 0wx1fffff	(* <= 21 bits *)
	then	[	W.orb(0wxf0, W.>>(w, 0wx12)),
			W.orb(0wx80, W.>>(W.andb(w, 0wx3f000), 0wxc)),
			W.orb(0wx80, W.>>(W.andb(w, 0wxfc0), 0wx6)),
			W.orb(0wx80, W.andb(w, 0wx3f))]
	else if	w <= 0wx3ffffff	(* <= 26 bits *)
	then	[	W.orb(0wxf8, W.>>(w, 0wx18)),
			W.orb(0wx80, W.>>(W.andb(w, 0wxfc0000), 0wx12)),
			W.orb(0wx80, W.>>(W.andb(w, 0wx3f000), 0wxc)),
			W.orb(0wx80, W.>>(W.andb(w, 0wxfc0), 0wx6)),
			W.orb(0wx80, W.andb(w, 0wx3f))]
	else	[	W.orb(0wxfc, W.>>(w, 0wx1e)),
			W.orb(0wx80, W.>>(W.andb(w, 0wx3f000000), 0wx18)),
			W.orb(0wx80, W.>>(W.andb(w, 0wxfc0000), 0wx12)),
			W.orb(0wx80, W.>>(W.andb(w, 0wx3f000), 0wxc)),
			W.orb(0wx80, W.>>(W.andb(w, 0wxfc0), 0wx6)),
			W.orb(0wx80, W.andb(w, 0wx3f))]))
);
(*
=TEX
\ftlinepenalty=9999
This is the basic translation table.
=SML
*)
val €pp_to_utf8_basic_translation› : ((string * W.word) * string) list = [
=SMLLITERAL
	(("≥",	0wx0000AC ),	"NOT SIGN"),
	(("∏",	0wx0000d7 ),	"MULTIPLICATION SIGN"),
	(("Î",	0wx002040 ),	"CHARACTER TIE"),
	(("÷",	0wx002102 ),	"DOUBLE-STRUCK CAPITAL C"),
	(("Ó",	0wx002115 ),	"DOUBLE-STRUCK CAPITAL N"),
	(("",	0wx002119 ),	"DOUBLE-STRUCK CAPITAL P"),
	(("Û",	0wx00211a ),	"DOUBLE-STRUCK CAPITAL Q"),
	(("Ø",	0wx00211d ),	"DOUBLE-STRUCK CAPITAL R"),
	(("˙",	0wx002124 ),	"DOUBLE-STRUCK CAPITAL Z"),
	(("≠",	0wx002192 ),	"RIGHTWARDS ARROW"),
	(("™",	0wx002194 ),	"LEFT RIGHT ARROW"),
	(("Í",	0wx002195 ),	"UP DOWN ARROW"),
	(("Á",	0wx002197 ),	"NORTH EAST ARROW"),
	(("Ë",	0wx002198 ),	"SOUTH EAST ARROW"),
	(("Ô",	0wx0021a0 ),	"RIGHTWARDS TWO HEADED ARROW"),
	(("‡",	0wx0021a3 ),	"RIGHTWARDS ARROW WITH TAIL"),
	(("Ì",	0wx0021a6 ),	"RIGHTWARDS ARROW FROM BAR"),
	(("˘",	0wx0021be ),	"UPWARDS HARPOON WITH BARB RIGHTWARDS"),
	(("Ï",	0wx0021bf ),	"UPWARDS HARPOON WITH BARB LEFTWARDS"),
	(("„",	0wx0021d0 ),	"LEFTWARDS DOUBLE ARROW"),
	(("¥",	0wx0021d2 ),	"RIGHTWARDS DOUBLE ARROW"),
	(("§",	0wx0021d4 ),	"LEFT RIGHT DOUBLE ARROW"),
	(("ﬂ",	0wx0021f8 ),	"RIGHTWARDS ARROW WITH VERTICAL STROKE"),
	(("ü",	0wx0021fb ),	"RIGHTWARDS ARROW WITH DOUBLE VERTICAL STROKE"),
	(("µ",	0wx002200 ),	"FOR ALL"),
	(("∂",	0wx002203 ),	"THERE EXISTS"),
	(("ö",	0wx002205 ),	"EMPTY SET"),
	(("ç",	0wx002208 ),	"ELEMENT OF"),
	(("é",	0wx002209 ),	"NOT AN ELEMENT OF"),
	(("Ö",	0wx002218 ),	"RING OPERATOR"),
	(("±",	0wx002227 ),	"LOGICAL AND"),
	(("≤",	0wx002228 ),	"LOGICAL OR"),
	(("°",	0wx002229 ),	"INTERSECTION"),
	(("¿",	0wx00222a ),	"UNION"),
	(("¶",	0wx00225c ),	"DELTA EQUAL TO"),
	(("Ω",	0wx002260 ),	"NOT EQUAL TO"),
	(("È",	0wx002261 ),	"IDENTICAL TO"),
	(("º",	0wx002264 ),	"LESS-THAN OR EQUAL TO"),
	(("æ",	0wx002265 ),	"GREATER-THAN OR EQUAL TO"),
	(("†",	0wx002282 ),	"SUBSET OF"),
	(("‰",	0wx002283 ),	"SUPERSET OF"),
	(("Ä",	0wx002286 ),	"SUBSET OF OR EQUAL TO"),
	(("Â",	0wx002287 ),	"SUPERSET OF OR EQUAL TO"),
	(("√",	0wx002291 ),	"SQUARE IMAGE OF OR EQUAL TO"),
	(("´",	0wx002295 ),	"CIRCLED PLUS"),
	(("£",	0wx002296 ),	"CIRCLED MINUS"),
	(("Ù",	0wx0022a2 ),	"RIGHT TACK"),
	(("‚",	0wx0022a5 ),	"UP TACK"),
	(("•",	0wx0022c2 ),	"N-ARY INTERSECTION"),
	(("ﬁ",	0wx0022c3 ),	"N-ARY UNION"),
	(("â",	0wx0022ce ),	"CURLY LOGICAL OR"),
	(("õ",	0wx0022cf ),	"CURLY LOGICAL AND"),
	(("¨",	0wx00231c ),	"TOP LEFT CORNER"),
	(("Æ",	0wx00231d ),	"TOP RIGHT CORNER"),
	(("ë",	0wx0024dc ),	"CIRCLED LATIN SMALL LETTER M"),
	(("î",	0wx0024e3 ),	"CIRCLED LATIN SMALL LETTER T"),
	(("Ò",	0wx0024e9 ),	"CIRCLED LATIN SMALL LETTER Z"),
	(("π",	0wx0024c8 ),	"CIRCLED LATIN CAPITAL LETTER S"),
	(("¸",	0wx002500 ),	"BOX DRAWINGS LIGHT HORIZONTAL"),	
	(("‹",	0wx002502 ),	"BOX DRAWINGS LIGHT VERTICAL"),	
	(("ˇ",	0wx00250c ),	"BOX DRAWINGS LIGHT DOWN AND RIGHT"),	
	(("à",	0wx002514 ),	"BOX DRAWINGS LIGHT UP AND RIGHT"),
	(("˜",	0wx00251c ),	"BOX DRAWINGS LIGHT VERTICAL AND RIGHT"),	
	(("ú",	0wx002550 ),  "BOX DRAWINGS DOUBLE HORIZONTAL"),
	(("ù",	0wx002552 ),	"BOX DRAWINGS DOWN SINGLE AND RIGHT DOUBLE"),	
	(("∞",	0wx0025A0 ),	"BLACK SQUARE"),
	(("í",	0wx0025b7 ),	"WHITE RIGHT-POINTING TRIANGLE"),
	(("Ú",	0wx0025c1 ),	"WHITE LEFT-POINTING TRIANGLE"),
	(("˚",	0wx0027e6 ),	"MATHEMATICAL LEFT WHITE SQUARE BRACKET"),
	(("˝",	0wx0027e7 ),	"MATHEMATICAL RIGHT WHITE SQUARE BRACKET"),
	(("œ",	0wx002900 ),	"RIGHTWARDS TWO-HEADED ARROW WITH VERTICAL STROKE"),
	(("˛",	0wx002914 ),	"RIGHTWARDS ARROW WITH TAIL WITH VERTICAL STROKE"),
	(("û",	0wx002915 ),	"RIGHTWARDS ARROW WITH TAIL WITH DOUBLE VERTICAL STROKE"),
	(("è",	0wx002916 ),	"RIGHTWARDS TWO-HEADED ARROW WITH TAIL"),
	(("∑",	0wx002981 ),	"Z NOTATION SPOT"),
	(("∫",	0wx002982 ),	"Z NOTATION TYPE COLON"),
	(("®",	0wx002987 ),	"Z NOTATION LEFT IMAGE BRACKET"),
	(("©",	0wx002988 ),	"Z NOTATION RIGHT IMAGE BRACKET"),
	(("›",	0wx00298e ),	"RIGHT SQUARE BRACKET WITH TICK IN BOTTOM CORNER"),
	(("€",	0wx00298f ),	"LEFT SQUARE BRACKET WITH TICK IN BOTTOM CORNER"),
	(("Ç",	0wx002a04 ),	"N-ARY UNION OPERATOR WITH PLUS"),
	(("ˆ",	0wx002a3c ),	"INTERIOR PRODUCT"),
	(("ı",	0wx002a3d ),	"RIGHTHAND INTERIOR PRODUCT"),
	(("ª",	0wx002a3e ),	"Z NOTATION RELATIONAL COMPOSITION"),
	(("·",	0wx002a64 ),	"Z NOTATION DOMAIN ANTIRESTRICTION"),
	(("Å",	0wx002a65 ),	"Z NOTATION RANGE ANTIRESTRICTION"),
	(("ß",	0wx0027E8 ),	"MATHEMATICAL LEFT ANGLE BRACKET"),
	(("¢",	0wx0027E9 ),	"MATHEMATICAL RIGHT ANGLE BRACKET"),
	(("¯",	0wx00fe63 ),	"SMALL HYPHEN-MINUS"),
	(("ñ",	0wx01d539 ),	"MATHEMATICAL DOUBLE-STRUCK CAPITAL B"),
	(("Ê",	0wx01d53d ),	"MATHEMATICAL DOUBLE-STRUCK CAPITAL F"),
	(("ø",	0wx01d54a ),	"MATHEMATICAL DOUBLE-STRUCK CAPITAL S"),
	(("É",	0wx01d54c ),	"MATHEMATICAL DOUBLE-STRUCK CAPITAL U"),
	(("á",	0wx01d6e4 ),	"MATHEMATICAL ITALIC CAPITAL GAMMA"),
	(("Ñ",	0wx01d6e5 ),	"MATHEMATICAL ITALIC CAPITAL DELTA"),
	(("ä",	0wx01d6e9 ),	"MATHEMATICAL ITALIC CAPITAL THETA"),
	(("å",	0wx01d6ec ),	"MATHEMATICAL ITALIC CAPITAL LAMDA"),
	(("ò",	0wx01d6ef ),	"MATHEMATICAL ITALIC CAPITAL XI"),
	(("ê",	0wx01d6f1 ),	"MATHEMATICAL ITALIC CAPITAL PI"),
	(("ì",	0wx01d6f4 ),	"MATHEMATICAL ITALIC CAPITAL SIGMA"),
	(("ï",	0wx01d6f6 ),	"MATHEMATICAL ITALIC CAPITAL UPSILON"),
	(("Ü",	0wx01d6f7 ),	"MATHEMATICAL ITALIC CAPITAL PHI"),
	(("ô",	0wx01d6f9 ),	"MATHEMATICAL ITALIC CAPITAL PSI"),
	(("ó",	0wx01d6fa ),	"MATHEMATICAL ITALIC CAPITAL OMEGA"),
	(("¡",	0wx01d6fc ),	"MATHEMATICAL ITALIC SMALL ALPHA"),
	(("¬",	0wx01d6fd ),	"MATHEMATICAL ITALIC SMALL BETA"),
	(("«",	0wx01d6fe ),	"MATHEMATICAL ITALIC SMALL GAMMA"),
	(("ƒ",	0wx01d6ff ),	"MATHEMATICAL ITALIC SMALL DELTA"),
	(("≈",	0wx01d700 ),	"MATHEMATICAL ITALIC SMALL EPSILON"),
	(("⁄",	0wx01d701 ),	"MATHEMATICAL ITALIC SMALL ZETA"),
	(("»",	0wx01d702 ),	"MATHEMATICAL ITALIC SMALL ETA"),
	((" ",	0wx01d703 ),	"MATHEMATICAL ITALIC SMALL THETA"),
	(("…",	0wx01d704 ),	"MATHEMATICAL ITALIC SMALL IOTA"),
	(("À",	0wx01d705 ),	"MATHEMATICAL ITALIC SMALL KAPPA"),
	(("Ã",	0wx01d706 ),	"MATHEMATICAL ITALIC SMALL LAMDA"),
	(("Õ",	0wx01d707 ),	"MATHEMATICAL ITALIC SMALL MU"),
	(("Œ",	0wx01d708 ),	"MATHEMATICAL ITALIC SMALL NU"),
	(("ÿ",	0wx01d709 ),	"MATHEMATICAL ITALIC SMALL XI"),
	(("–",	0wx01d70b ),	"MATHEMATICAL ITALIC SMALL PI"),
	(("“",	0wx01d70c ),	"MATHEMATICAL ITALIC SMALL RHO"),
	(("”",	0wx01d70e ),	"MATHEMATICAL ITALIC SMALL SIGMA"),
	(("‘",	0wx01d70f ),	"MATHEMATICAL ITALIC SMALL TAU"),
	(("’",	0wx01d710 ),	"MATHEMATICAL ITALIC SMALL UPSILON"),
	(("∆",	0wx01d711 ),	"MATHEMATICAL ITALIC SMALL PHI"),
	(("—",	0wx01d712 ),	"MATHEMATICAL ITALIC SMALL CHI"),
	(("Ÿ",	0wx01d713 ),	"MATHEMATICAL ITALIC SMALL PSI"),
	(("◊",	0wx01d714 ),	"MATHEMATICAL ITALIC SMALL OMEGA")
];
(*
=TEX
=SML
*)
val byte_string_order : string ORDER = (fn s1 => fn s2 =>
	lexicographic (fn c1 => fn c2 => ord c1 - ord c2) (explode s1) (explode s2)
);
val €pp_to_utf8_tab› : (string * string) list = 
	(sort (pair_order byte_string_order byte_string_order) o
		map (fn ((c, w), _) => (c, utf8_of_word w))) 
		pp_to_utf8_basic_translation;
(*
=TEX
The following have no Unicode equivalent, but have equivalent
ProofPower forms that do.
=SML
*)
val €pp_to_pp_replacement› : (string * string) list = 
	map (fn (c, s) => (c, implode (map (lassoc1 pp_to_utf8_tab) (explode s)))) [
=SMLLITERAL
	("ã",	"Î/" )
=SML
];
(*
=TEX
=SML
*)
val €pp_to_utf8› : string array =
	PPArray.arrayoflist
		(map (lassoc1 (pp_to_pp_replacement @ pp_to_utf8_tab))
			(map chr (interval 0 255)));
(*
=TEX
=SML
*)
val €word_order› : word ORDER = fn w1 => fn w2 => W.toInt w1 - W.toInt w2;

val €utf8_to_pp_tab› : (word * string) list =
	(sort (pair_order word_order byte_string_order)) 
		(map (swap o fst) pp_to_utf8_basic_translation);
(*
=TEX
The rest of the code outputs the two C header files: pputf8tab.h and utf8pptab.h
=SML
*)

fun €word_to_string› (width : int)  (w : word) : string = (
	let	fun zeroes i = if i <= 0 then "" else "0" ^ zeroes (i-1);
		val s = Word.toString w;
	in	zeroes (width - size s) ^ s
	end
);

fun €c_hex_char_of_char› (c : char) : string = (
	"\\x" ^ (word_to_string 2 o W.fromInt o C.ord) c
);

fun €c_hex_string_of_string› (s : string) : string = (
	implode(map c_hex_char_of_char(S.explode s))
);

fun €c_hex_int_of_code_point› (w : word) : string = (
	"0x" ^ word_to_string 6 w
);

fun €c_pp_to_utf8› (outfile : string) : unit = (
	let	val strm = open_out outfile;
		fun say s = output(strm, s);
		fun aux i = (
			let	val s = PPArray.sub(pp_to_utf8, i);
				val text = c_hex_string_of_string s;
			in	say "\t\"";
				say text;
				(if	i < 255
				then	(say "\",\n";
					aux (i+1))
				else	say "\"\n")
			end
		);
	in	say (
"/*\n * " ^
 outfile ^ ": automatically generated by utf8.ML.\n * " ^
 Date.toString (Date.fromTimeLocal(Time.now())) ^ "\n" ^
" * Conversion from ProofPower characters to UTF-8 strings is done\n" ^
" * by an indexed lookup in the following array:\n" ^
" */\n");
		say "static const char *pp_to_utf8 [256] = {\n";
		aux 0;
		say "};\n";
		close_out strm
	end
);


fun €c_utf8_to_pp› (outfile : string) : unit = (
	let	val strm = open_out outfile;
		fun say s = output(strm, s);
		fun aux ((w, s) :: more) = (
			let	val text1 = c_hex_int_of_code_point w;
				val text2 = c_hex_string_of_string s;
			in	say "\t{";
				say text1;
				say ", \"";
				say text2;
				(case more of
				 _ :: _	=> 	(
					say "\"},\n";
					aux more
				) | _	=>	say "\"}\n")
			end
		) | aux [] = ();
	in	say (
"/*\n * " ^
 outfile ^ ": automatically generated by utf8.ML.\n * " ^
  Date.toString (Date.fromTimeLocal(Time.now())) ^ "\n" ^
" * Conversion from UTF-8 encoded character to a string of 1 or more\n" ^
" * ProofPower extended characters is done by an associative lookup\n" ^
" * in the following sorted array of records:\n" ^
" */\n" ^
"typedef int unicode;\n" ^
"typedef struct {\n" ^
"\tunicode code_point;\n" ^
"\tconst char *pp_string;} utf8_to_pp_entry;\n");
		say "#define UTF8_TO_PP_LEN ";
		say(string_of_int (128 + length utf8_to_pp_tab));
		say "\nstatic utf8_to_pp_entry utf8_to_pp [UTF8_TO_PP_LEN] = {\n";
		aux (map (fn i => (W.fromInt i, chr i)) (interval 0 127) @ utf8_to_pp_tab);
		say "};\n";
		close_out strm
	end
);

val _ =
(*	if length utf8_to_pp_tab <> length pp_to_utf8_tab
	then	diag_line "WARNING: duplicate entries lost from utf8_to_pp_tab"
	else *)	();

val _ = c_pp_to_utf8 "pputf8tab.h";
val _ = c_utf8_to_pp "utf8pptab.h";

end (* of local ... in ... end *);
end (* of structure PPUtf8 *);
=TEX


\section{TEST POLICY}
There are no special module test requirements.
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}







