=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Release 1 ICL HOL: Module Tests for Standard ML Utilities}  %% Mandatory field
\def\TPPheadtitle{Release 1 ICL HOL \cr Module Tests for Standard ML Utilities}
\TPPref{DS/FMU/IED/MDT001}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the utility functions for use in the prototype HOL
system in this document.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue 1.1]
First draft version.
\end{description}
%\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the functional tool-kit, required by Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The design is in \cite{DS/FMU/IED/DTD001}
and it is
implemented in \cite{DS/FMU/IED/IMP001}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD001},
following the test specification given in that document.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD001},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP001}.
\subsubsection{Deficiencies}
The coverage of the tests, as called for by the test specification, may currently be incomplete.
\subsubsection{Possible Enhancements}

\section{UTILITIES USED FOR TESTING}

\section{THE TESTS}
\subsection{Tests for $ListUtilities$}
=SML
force_value (Value "OK"); 
force_value Nil;  (* fails *)

is_Nil (Value "OK"); 
is_Nil Nil;

hd[]; (* fails *)
hd [1,2,3];

tl[]; (* fails *)
tl[1,2,3];

fold (fn (a,b) => a :: b) [] [1];
fold (fn (a,b) => a :: b) [1,2,3] [0];

revfold (fn (a,b) => a :: b) [] [1];
revfold (fn (a,b) => a :: b) [1,2,3] [0];

length [];
length [1,2,4];
=TEX
=SML
[] drop (fn x => x > 3);
[5,2,3,4,1] drop (fn x => x > 3);

[] less 3;
[5,3,4,3,2]  less 3;

[] grab 3;
[1,2] grab 3;
[1,3,2] grab 3;

union (op <) [1,2,4,8] [3,6,12,25,24]; (* [1,2,4,8,12,25] *)
union (op <) [] [3,3,2,5,1,4]; (* [3,3,5] *)

[1,3,5] cup  [2,3,4,2];

list_union (op <) [[0,3], [2,3], [1,4,0]]; (* [0,3,4] *)

list_cup[[0,3], [2,3], [1,4,0,2]];
=TEX
=SML
find [] (fn x => x > 3); (* fails *)
find [1,2] (fn x => x > 3); (* fails *)
find [5,2,3,1,6] (fn x => x > 3);

contains [] 3;
contains [1,3] 2;
contains [1,2,3] 2;

3 mem [];
2 mem [1,3];
2 mem [1,2,3];

any [] (fn x => x > 3);
any [1,2] (fn x => x > 3);
any [1,4,2] (fn x => x > 3);

all [] (fn x => x > 3);
all [1,4] (fn x => x > 3);
all [5,4] (fn x => x > 3);

[] subset [1];
[2,3,4] subset [1,3,4];
[2,3] subset [1,2,3,4];
[1] subset [];

[] diff [1];
[2,3,4] diff [1,3,4];
[2,3] diff [1,3,4];
[1] diff [];
=TEX
=SML
val alist1 = [(3,4), (1,2), (5,6)];
lassoc1 alist1 3; (* 4 *)
lassoc1 alist1 6; (* 6 *)

rassoc1 alist1 4; (* 3 *)
rassoc1 alist1 3; (* 3 *)

lassoc2 alist1 (fn x => x+ 10) 3; (* 4 *)
lassoc2 alist1 (fn x => x+ 10) 6; (* 16 *)

rassoc2 alist1 (fn x => x+ 10) 4; (* 3 *)
rassoc2 alist1 (fn x => x+ 10) 3; (* 13 *)

lassoc3 alist1 3; (* 4 *)
lassoc3 alist1 6; (* fails *)

rassoc3 alist1 4; (* 3 *)
rassoc3 alist1 3; (* fails *)

lassoc4 alist1 0 3; (* 4 *)
lassoc4 alist1 0 6; (* 0 *)

rassoc4 alist1 0 4; (* 3 *)
rassoc4 alist1 0 3; (* 0 *)

lassoc5 alist1 3; (* Value 4 *)
lassoc5 alist1 6; (* Nil *)

rassoc5 alist1 4; (* Value 3 *)
rassoc5 alist1 3; (* Nil *)
=TEX
=SML
alist1 overwrite (1,6);
alist1 overwrite (6,6);

alist1 roverwrite (1,6);
alist1 roverwrite (6,6);

alist1 list_overwrite [(1,6),(4,6),(1,0)];

alist1 list_roverwrite [(1,6),(4,5),(4,0)];

is_nil [];
is_nil [1,2,3];

flat [[1,2],[],[3,4]];

split alist1;

split3 [(1,2,3), (3,4,5)];

(uncurry combine(split alist1)) = alist1;

combine [1] [1,2]; (* fails *)

all_different [];
all_different [1,3,1,3,2];
all_different [1,2,3];

all_distinct (fn (x,y) => (x - y = 5)) [1,3,9];
all_distinct (fn (x,y) => (x - y = 5)) [1,3,6];
all_distinct (fn (x,y) => (x - y = 5)) [6,3,1];

[0,1,2,3] from 2;
[0,1,2,3] from 6;
[0,1,2,3] from ~5;

[0,1,2,3] to 2;
[0,1,2,3] to 6;
[0,1,2,3] to ~5;

interval 2 4;
interval 4 2;
interval 2 2;

mapfilter (lassoc3 alist1) [1,4,2,3]; (* [2,4] *)

zip [(fn x => x+1), (fn x => x+2),(fn x => x+3)] [1,2,3];
zip [(fn x => x+1), (fn x => x+2)] [1,2,3]; (* fails *)
zip [(fn x => x+1), (fn x => x+2),(fn x => x+3)] [1,2]; (* fails *)

nth 2 [1,2,4];
nth 6 [1,2,4]; (* fails *)
nth ~5 [1,2,4]; (* fails *)

which (op =) 3 [1,3,5];
which (op =) 3 [2,4,6];
=TEX
\subsection{Tests for $FunctionUtilities$}
=SML
fst(1,2);

snd(1,2);

swap (1,2);

curry (op mem) 3 [1,2,3,4];

uncurry contains ([1,2,3,4], 3);

switch contains 3 [1,2,3,4];

((fn x => x+1) ** (fn x => x+2)) (2,2);

funpow 3 (fn x => x+1) 2;
funpow ~5 (fn x => x+1) 2;
=TEX
\subsection{Tests for $Combinators$}
=SML
Combinators.I 5;

Combinators.S (fn x => fn y => x + y) (fn x => x + 2) 3; (* 8 *)

Combinators.K 3 5;
=TEX
\subsection{Tests for $InputOutput$}
=SML
get_line_length ();

val teststring = "sdljfv lkirhnf d;fljnq lkwedjfn ldkfjbnwqd;kfjn  " ^
" ;ouinwefw  ;kiweujnbfwqel  iwe;lnfbu	 wedjbnfkl; l;dkifcujbn l" ^
"	kwjedb lk jbn	el;i	uew bhnl;kij we bljhweb ,";

diag_string teststring;
val gll = set_line_length 20;
diag_string teststring;
set_line_length gll;
diag_string teststring;

list_diag_string ["abc","def","gh ij"];

map diag_line ["one", "two", "three"];
map diag_string ["one", "two", "three"];
=TEX
$dump\_string$ is not tested by this script as it involves file
modification.
=SML
format_list (Combinators.I) ["abc","def","gh ij"] ":";

=TEX
\subsection{Tests for $CharacterUtilities$}
=SML
is_all_graphical "a\005c";
is_all_graphical "a\040c";
is_all_graphical "a\127c";
is_all_graphical "a\230c";

is_all_decimal "12a3";
is_all_decimal "123";
is_all_decimal ""; (* = false *)

strip_spaces " abc     def gh";
strip_spaces "";
strip_spaces "abc";
=TEX
As $gensym$ is perhaps used during system build, the result of the
following may well vary, but the three numbers must be
$n,\ n+1,\ n+2$.
=SML
gensym();gensym();gensym();

nat_of_string "1a3"; (* fails *)
nat_of_string "123";
nat_of_string ""; (* fails *)

string_of_int ~5;
string_of_int 0;
string_of_int 5;
string_of_int 123;
=TEX
\subsection{Tests for $SimpleDictionary$}
=SML
open SimpleDictionary;
s_enter "is1" 1 [];
s_enter "is2" 2 it;
s_enter "is3" 3 it;
s_enter "is5" 5 it;
s_enter "is2" 4 it;
val base_simple = it;
s_lookup "is3" base_simple;
s_lookup "is4" base_simple; (* Nil *)
s_lookup "is6" base_simple; (* Nil *)
s_delete "is8" base_simple = base_simple;
s_lookup "is3" (s_delete "is3" base_simple); (* Nil *)
s_lookup "is2" (s_delete "is3" base_simple); (* Value 4 *)

val next_simple = s_merge (s_enter "is8" 8 []) base_simple;
s_lookup "is8" next_simple;
s_lookup "is3" next_simple;
s_lookup "is4" next_simple; (* Nil *)
s_merge (s_enter "is2" 2 []) base_simple;
s_merge (s_enter "is7" 7 []) base_simple;
=TEX
\subsection{Tests for $EfficientDictionary$}
=SML
open EfficientDictionary;
e_enter "is1" 1 initial_E_DICT;
e_enter "is5" 5 it;
e_enter "is2" 2 it;
e_enter "is3" 3 it;
e_enter "is2" 4 it;
val base_eff = it;
e_lookup "is3" base_eff; (* 3 *)
e_lookup "is2" base_eff; (* 4 *)
e_lookup "is4" base_eff; (* Nil *)
e_lookup "is6" base_eff; (* Nil *)
e_delete "is8" base_eff;
e_flatten base_eff;
e_lookup "is3" (e_delete "is3" base_eff); (* Nil *)
e_lookup "is2" (e_delete "is3" base_eff);

val next_eff = e_merge (e_enter "is8" 8 initial_E_DICT) 
	base_eff;
e_lookup "is8" next_eff;
e_lookup "is3" next_eff;
e_lookup "is4" next_eff; (* Nil *)
e_merge (e_enter "is2" 2 initial_E_DICT) base_eff; (* fails *)
list_e_merge base_eff (s_enter "is8" 2 []);
list_e_merge base_eff (s_enter "is2" 2 []); (* fails *)
=TEX
\subsection{Tests for $Profiling$}
=SML
print_stats ();
counts "test";
prof "test";prof "test1";prof "test";
set_flag ("profiling", false);
prof "test";prof "test1";prof "test";
set_flag ("profiling", true);
prof "test";prof "test1";prof "test";
print_stats ();
counts "test";
counts "not_tested";
give_stats();
=TEX
\subsection{Tests for $Sort$}
$lexicographic$ is tested by $stringorder$ calls.
=SML
open Sort;
sort (curry (op -)) [3,2,5,1,8,2,3,6];
stringorder "a" "b";
stringorder "b" "A";
stringorder " " "c";
stringorder ">" "c";
stringorder "ab" "abc";
stringorder "ab" "ab";
stringorder "abd" "abc";
=TEX
\subsection{End of Tests}
=SML
PolyML.quit();
=TEX
\end{document}
