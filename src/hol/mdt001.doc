=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Standard ML Utilities}  %% Mandatory field
\def\TPPheadtitle{Module Tests for Standard ML Utilities}
\TPPref{DS/FMU/IED/MDT001}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the utility functions for use in the prototype HOL
system in this document.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1]
First draft version.
\item [Issue 1.2]
$dump\_string$ comment removed.
Indicated what tests are intended to achieve.
Tightened test on $gensym$.
\item [Issue 1.3]
Changes to reflect changes in issue 1.7 of \cite{DS/FMU/IED/IMP001}.
\item [Issue 1.4]
Changes to reflect changes in issue 1.8 of \cite{DS/FMU/IED/IMP001}.
\item [Issue 1.5]
Changed to use material from \cite{DS/FMU/IED/DTD013}.
\item [Issue 1.6]
Corrected a reference.
\item [Issue 1.7]
Changes in response to inspection IR0012.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the functional tool-kit, required by Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The design is in \cite{DS/FMU/IED/DTD001}
and it is
implemented in \cite{DS/FMU/IED/IMP001}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD001},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

It uses the test harness from \cite{DS/FMU/IED/DTD013}.
This harness is implemented in part by functions from 
\cite{DS/FMU/IED/DTD001}, but it is thought that this will not compromise the tests made.
\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD001},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP001}.
\subsubsection{Deficiencies}
The coverage of the tests, as called for by the test specification, may currently be incomplete.

\section{INITIALISATION}
Initialise the test package:
=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results();
=TEX
\section{VALUE BINDINGS}
=SML
val alist1 = [(3,4), (1,2), (5,6)];
=TEX
\section{THE TESTS}
\subsection{Tests for $ListUtilities$}
\section{LIST UTILITIES}
\subsection{Some Useful Datatypes and Functions upon them}
=SML
store_mt_results mt_run [ 
	("force_value",
	force_value,
	Value "OK",
	"OK")];
store_mt_results mt_run_fail [
	("force_value 1001",
	force_value,
	Nil,
	gen_fail_msg "force_value" 1001 [])];
store_mt_results mt_run [ 
	("is_Nil 1",
	is_Nil,
	Value "OK",
	false),
	("is_Nil 2",
	is_Nil,
	Nil,
	true)];
=TEX
\subsection{List Processing Functions}
\subsubsection{A Miscellany}
=SML
store_mt_results mt_run [ 
	("hd 1",
	hd,
	[1,2,3],
	1),
	("hd 2",
	hd,
	[1],
	1)];
store_mt_results mt_run_fail [
	("hd 1002",
	hd,
	[],
	gen_fail_msg "hd" 1002 [])];

store_mt_results mt_run [ 
	("tl 1",
	tl,
	[1,2,3],
	[2,3]),
	("tl 2",
	tl,
	[1],
	[])];
store_mt_results mt_run_fail [
	("tl 1003",
	tl,
	[],
	gen_fail_msg "tl" 1003 [])];

store_mt_results mt_run [ 
	("fold 1",
	fold (fn (a,b) => a :: b) [],
	[1],
	[1]),
	("fold 2",
	fold (fn (a,b) => a :: b) [1,2,3],
	[0],
	[1,2,3,0])
	];
store_mt_results mt_run [ 
	("revfold 1",
	revfold (fn (a,b) => a :: b) [],
	[1],
	[1]),
	("revfold 2",
	revfold (fn (a,b) => a :: b) [1,2,3],
	[0],
	[3,2,1,0])
	];
store_mt_results mt_run [ 
	("length 1",
	length,
	[],
	0),
	("length 2",
	length,
	[1,2,3],
	3)
	];
=TEX
=SML
store_mt_results mt_run [ 
	("drop 1",
	(op drop),
	([],(fn x => x > 3)),
	[]),
	("drop 2",
	(op drop),
	([5,2,3,4,1],(fn x => x > 3)),
	[2,3,1])
	];
store_mt_results mt_run [ 
	("less 1",
	(op less),
	([],3),
	[]),
	("less 2",
	(op less),
	([5,2,3,4,3,1],3),
	[5,2,4,1])
	];
store_mt_results mt_run [ 
	("grab 1",
	(op grab),
	([],3),
	[3]),
	("grab 2",
	(op grab),
	([1,2],3),
	[3,1,2]),
	("grab 3",
	(op grab),
	([1,3,2],3),
	[1,3,2])
	];
=TEX
Note that $union$ removes all bar the rightmost duplicate.
=SML
store_mt_results mt_run [ 
	("union 1",
	union (op <) [3,6,12,25,24],
	[1,2,4,8],
	[25,24,1,2,4,8]),
	("union 2",
	union (op <) [3,3,2,5,1,4],
	[],
	[5,4])	
	];
store_mt_results mt_run [ 
	("cup",
	(op cup),
	([1,3,5],[2,3,4,2]),
	[1,5,2,3,4,2])
	];
store_mt_results mt_run [ 
	("list_union",
	list_union (op <),
	[[0,3], [4,3], [1,3,0]],
	[4,3,3,0])
	];
store_mt_results mt_run [ 
	("list_cup",
	list_cup,
	[[0,5], [2,3], [1,4,0,2]],
	[5, 3, 1, 4, 0, 2])
	];
=TEX
=SML
store_mt_results mt_run [ 
	("find",
	find [5,2,3,1,6],
	(fn x => x > 3),
	5)
	];
store_mt_results mt_run_fail [
	("find 1004 a",
	find [],
	(fn x => x > 3),
	gen_fail_msg "find" 1004 []),
	("find 1004 b",
	find [1,2],
	(fn x => x > 3),
	gen_fail_msg "find"1004  [])
	];
store_mt_results mt_run [ 
	("contains 1",
	contains [],
	2,
	false),
	("contains 2",
	contains [1,3],
	2,
	false),
	("contains 3",
	contains [1,2,3],
	2,
	true)
	];
store_mt_results mt_run [ 
	("mem 1",
	(op mem),
	(2,[]),
	false),
	("mem 2",
	(op mem),
	(2,[1,3]),
	false),
	("mem 3",
	(op mem),
	(2,[1,2,3]),
	true)
	];
store_mt_results mt_run [ 
	("present 1",
	present (op =) 2,
	[],
	false),
	("present 2",
	present (op =) 2,
	[1,3],
	false),
	("present 3",
	present (op =) 2,
	[1,2,3],
	true)
	];
store_mt_results mt_run [ 
	("any 1",
	any [],
	(fn x => x > 3),
	false),
	("any 2",
	any [1,2],
	(fn x => x > 3),
	false),
	("any 3",
	any [1,4,2],
	(fn x => x > 3),
	true)
	];
store_mt_results mt_run [ 
	("all 1",
	all [],
	(fn x => x > 3),
	true),
	("all 2",
	all [1,4],
	(fn x => x > 3),
	false),
	("all 3",
	all [5,4],
	(fn x => x > 3),
	true)
	];
store_mt_results mt_run [ 
	("subset 1",
	(op subset),
	([],[1]),
	true),
	("subset 2",
	(op subset),
	([2,3,4],[1,3,4]),
	false),
	("subset 3",
	(op subset),
	([2,3],[1,2,3,4]),
	true),
	("subset 4",
	(op subset),
	([1],[]),
	false)
	];
store_mt_results mt_run [ 
	("set_eq 1",
	(op set_eq),
	([1,1],[1]),
	true),
	("set_eq 2",
	(op set_eq),
	([1],[1,1]),
	true),
	("set_eq 3",
	(op set_eq),
	([1,2,3],[3,2,1]),
	true),
	("set_eq 4",
	(op set_eq),
	([1,2,2,3],[3,1,2,3]),
	true),
	("set_eq 5",
	(op set_eq),
	([1,2,3,4,5],[1,2,4,5]),
	false),
	("set_eq 6",
	(op set_eq),
	([1,2,4,5],[1,5,3,2,4]),
	false),
	("set_eq 7",
	(op set_eq),
	([1,2,4,5],[1,3,4,5]),
	false)
	];
store_mt_results mt_run [ 
	("diff 1",
	(op diff),
	([],[1]),
	[]),
	("diff 2",
	(op diff),
	([2,3,4],[1,3,4]),
	[2]),
	("diff 3",
	(op diff),
	([2,3],[1,3,4]),
	[2]),
	("diff 4",
	(op diff),
	([1],[]),
	[1])
	];
=TEX
\subsection{Lists of Pairs as Functions and Relations}
=SML
store_mt_results mt_run [ 
	("lassoc1 1",
	lassoc1 alist1,
	3,
	4),
	("lassoc1 2",
	lassoc1 alist1,
	6,
	6)
	];
store_mt_results mt_run [ 
	("rassoc1 1",
	rassoc1 alist1,
	4,
	3),
	("rassoc1 2",
	rassoc1 alist1,
	3,
	3)
	];
store_mt_results mt_run [ 
	("lassoc2 1",
	lassoc2 alist1 (fn x => x+ 10),
	3,
	4),
	("lassoc2 2",
	lassoc2 alist1 (fn x => x+ 10),
	6,
	16)
	];
store_mt_results mt_run [ 
	("rassoc2 1",
	rassoc2 alist1 (fn x => x+ 10),
	4,
	3),
	("rassoc2 2",
	rassoc2 alist1 (fn x => x+ 10),
	3,
	13)
	];
store_mt_results mt_run [ 
	("lassoc3",
	lassoc3 alist1,
	3,
	4),
	("rassoc3",
	rassoc3 alist1,
	4,
	3)
	];
store_mt_results mt_run_fail [ 
	("lassoc3 1005",
	lassoc3 alist1,
	6,
	gen_fail_msg "lassoc3" 1005 []),
	("rassoc3 1005",
	rassoc3 alist1,
	3,
	gen_fail_msg "rassoc3" 1005 [])
	];
store_mt_results mt_run [ 
	("lassoc4 1",
	lassoc4 alist1 0,
	3,
	4),
	("lassoc4 2",
	lassoc4 alist1 0,
	6,
	0)
	];
store_mt_results mt_run [ 
	("rassoc4 1",
	rassoc4 alist1 0,
	4,
	3),
	("rassoc4 2",
	rassoc4 alist1 0,
	3,
	0)
	];
store_mt_results mt_run [ 
	("lassoc5 1",
	lassoc5 alist1,
	3,
	Value 4),
	("lassoc5 2",
	lassoc5 alist1,
	6,
	Nil)
	];
store_mt_results mt_run [ 
	("rassoc5 1",
	rassoc5 alist1,
	4,
	Value 3),
	("rassoc5 2",
	rassoc5 alist1,
	3,
	Nil)
	];
=TEX
=SML
store_mt_results mt_run [ 
	("overwrite 1",
	(op overwrite),
	(alist1, (1,6)),
	[(3, 4), (1, 6), (5, 6)]),
	("overwrite 2",
	(op overwrite),
	(alist1, (6,6)),
	[(3, 4), (1, 2), (5, 6), (6, 6)]),
	("overwrite 3",
	(op overwrite),
	(alist1, (6, 1)),
	[(3, 4), (1, 2), (5, 6), (6,1)])
	];
store_mt_results mt_run [ 
	("roverwrite 1",
	(op roverwrite),
	(alist1, (1,6)),
	[(3, 4), (1, 2), (1, 6)]),
	("roverwrite 2",
	(op roverwrite),
	(alist1, (6,6)),
	[(3, 4), (1, 2), (6, 6)]),
	("roverwrite 3",
	(op roverwrite),
	(alist1, (6,1)),
	[(3, 4), (1, 2), (5, 6), (6,1)])
	];
store_mt_results mt_run [ 
	("list_overwrite",
	(op list_overwrite),
	(alist1,[(1,6),(4,6),(1,0)]),
	[(3, 4), (1, 6), (5, 6), (4, 6)])
	];
store_mt_results mt_run [ 
	("list_roverwrite",
	(op list_roverwrite),
	(alist1,[(1,6),(4,5),(4,0)]),
	[(3, 4), (1, 2), (1, 6),(4, 0), (4, 5)])
	];
=TEX
\subsection{Another Miscellany}
=SML
store_mt_results mt_run [ 
	("is_nil 1",
	is_nil,
	[],
	true),
	("is_nil 2",
	is_nil,
	[1,2,3],
	false)
	];
store_mt_results mt_run [ 
	("flat",
	flat,
	[[1,2],[],[2,3,4]],
	[1,2,2,3,4])
	];
store_mt_results mt_run [ 
	("split",
	split,
	alist1,
	([3,1,5],[4,2,6]))
	];
store_mt_results mt_run [ 
	("split3",
	split3,
	[(1,2,3), (3,4,5)],
	([1,3],[2,4],[3,5]))
	];
store_mt_results mt_run [ 
	("combine",
	uncurry combine o split,
	alist1,
	alist1)
	];
store_mt_results mt_run_fail [
	("combine 1007",
	combine [1],
	[1,2],
	gen_fail_msg "combine" 1007 [])
	];
store_mt_results mt_run [ 
	("all_different 1",
	all_different,
	[],
	true),
	("all_different 2",
	all_different,
	[1,3,1,3,2],
	false),
	("all_different 3",
	all_different,
	[1,2,3],
	true)
	];
store_mt_results mt_run [ 
	("all_distinct 1",
	all_distinct (fn (x,y) => (x - y = 5)),
	[1,3,9],
	true),
	("all_distinct 2",
	all_distinct (fn (x,y) => (x - y = 5)),
	[1,3,6],
	true),
	("all_distinct 3",
	all_distinct (fn (x,y) => (x - y = 5)),
	[6,3,1],
	false)
	];

store_mt_results mt_run [ 
	("from 1",
	(op from),
	([0,1,2,3],2),
	[2,3]),
	("from 2",
	(op from),
	([0,1,2,3],6),
	[]),
	("from 3",
	(op from),
	([0,1,2,3],~5),
	[0,1,2,3])
	];
store_mt_results mt_run [ 
	("to 1",
	(op to),
	([0,1,2,3],2),
	[0,1,2]),
	("to 2",
	(op to),
	([0,1,2,3],6),
	[0,1,2,3]),
	("to 3",
	(op to),
	([0,1,2,3],~5),
	[])
	];
store_mt_results mt_run [ 
	("interval 1",
	interval 2,
	4,
	[2,3,4]),
	("interval 2",
	interval 4,
	2,
	[]),
	("interval 3",
	interval 2,
	2,
	[2])
	];
store_mt_results mt_run [ 
	("mapfilter",
	mapfilter (lassoc3 alist1),
	[1,4,2,3],
	[2,4])
	];
store_mt_results mt_run [ 
	("zip",
	zip [(fn x => x+1), (fn x => x+2),(fn x => x+3)],
	[1,2,3],
	[2,4,6])
	];
store_mt_results mt_run_fail [
	("zip 1008 a",
	zip [(fn x => x+1), (fn x => x+2)],
	[1,2,3],
	gen_fail_msg "zip" 1008 []),
	("zip 1008 b",
	zip [(fn x => x+1), (fn x => x+2),(fn x => x+3)],
	[1,2],
	gen_fail_msg "zip" 1008 [])
	];
store_mt_results mt_run [ 
	("nth",
	nth 2,
	[1,2,4],
	4)
	];
store_mt_results mt_run_fail [
	("nth 1009 a",
	nth 6,
	[1,2,4],
	gen_fail_msg "nth" 1009 []),
	("nth 1009 b",
	nth ~5,
	[1,2,4],
	gen_fail_msg "nth" 1009 [])
	];
store_mt_results mt_run [ 
	("which 1",
	which (op =) 3,
	[1,3,5],
	Value 1),
	("which 2",
	which (op =) 3,
	[2,4,6],
	Nil)
	];
=TEX
\subsection{Tests for $FunctionUtilities$}
=SML
store_mt_results mt_run [ 
	("fst",
	fst,
	(1,2),
	1),
	("snd",
	snd,
	(1,2),
	2)
	];
store_mt_results mt_run [ 
	("swap",
	swap,
	(1,2),
	(2,1))
	];
store_mt_results mt_run [ 
	("curry",
	curry (op mem) 3 ,
	[1,2,3,4],
	true)
	];
store_mt_results mt_run [ 
	("uncurry",
	uncurry contains,
	([1,2,3,4], 3),
	true)
	];
store_mt_results mt_run [ 
	("switch",
	switch contains 3 ,
	[1,2,3,4],
	true)
	];
store_mt_results mt_run [ 
	("**",
	((fn x => x+1) ** (fn x => x+5)),
	(1,2),
	(2,7))
	];
store_mt_results mt_run [ 
	("funpow",
	funpow 3 (fn x => x+1),
	2,
	5)
	];
store_mt_results mt_run_fail [
	("funpow 1010",
	funpow ~5 (fn x => x+1),
	2,
	gen_fail_msg "funpow" 1010 [])
	];
store_mt_results mt_run [ 
	("fun_and 1",
	(fn x => x > 2) fun_and (fn x => x < 6),
	4,
	true),
	("fun_and 2",
	(fn x => x > 2) fun_and (fn x => x < 6),
	1,
	false),
	("fun_and 3",
	(fn x => x > 2) fun_and (fn x => x < 6),
	7,
	false)
	];
store_mt_results mt_run [ 
	("fun_or 1",
	(fn x => x < 2) fun_or (fn x => x > 6),
	4,
	false),
	("fun_or 2",
	(fn x => x < 2) fun_or (fn x => x > 6),
	1,
	true),
	("fun_or 3",
	(fn x => x < 2) fun_or (fn x => x > 6),
	7,
	true)
	];
store_mt_results mt_run [ 
	("fun_not 1",
	fun_not (fn x => x < 2),
	4,
	true),
	("fun_not 2",
	fun_not (fn x => x < 2) ,
	1,
	false)
	];
store_mt_results mt_run [ 
	("fun_true",
	fun_true,
	false,
	true),
	("fun_false",
	fun_false,
	true,
	false)
	];
let
	val tref1 : int ref = ref 4;
	val tref2 : int ref = ref 2;
	fun f () = (if (!tref1) = 0 
		then fail "f" 0 []
		else (tref1 :=  (!tref1) - 1; 
			tref2 := (!tref2) + 1)
		);
	val side_effect = repeat f;
in
store_mt_results mt_run [ 
	("repeat",
	Combinators.I,
	(!tref2),
	6)]
end;
let
	fun f (a,b) = if a = 0
		then fail "f" 0 []
		else (a - 1, b + 1)
in
store_mt_results mt_run [ 
	("iterate",
	iterate f,
	(4, 2),
	(0, 6))]
end;
=TEX
\subsection{Tests for $Combinators$}
=SML
store_mt_results mt_run [ 
	("I",
	Combinators.I,
	5,
	5)
	];
store_mt_results mt_run [ 
	("S",
	Combinators.S (fn x => fn y => x + y) (fn x => x + 2),
	3,
	8)
	];
store_mt_results mt_run [ 
	("K",
	Combinators.K 3,
	5,
	3)
	];
=TEX
\subsection{Tests for $InputOutput$}
These can only be checked by eye:
=SML
val orig_line_length = get_line_length ();

val teststring = "sdljfv lkirhnf d;fljnq lkwedjfn ldkfjbnwqd;kfjn  " ^
" ;ouinwefw  ;kiweujnbfwqel  iwe;lnfbu	 wedjbnfkl; l;dkifcujbn l" ^
"	kwjedb lk jbn	el;i	uew bhnl;kij we bljhweb ,";

diag_string teststring;
store_mt_results mt_run [("set_line_length 1",
	set_line_length,
	20,
	orig_line_length)
	];
store_mt_results mt_run_fail [("set_line_length 1015",
	set_line_length,
	10,
	gen_fail_msg "set_line_length" 1015 [])];
diag_string teststring;
store_mt_results mt_run [("set_line_length 2",
	set_line_length,
	orig_line_length,
	20)
	];
diag_string teststring;

list_diag_string ["abc","def","gh ij"];

map diag_line ["one", "two", "three"];
map diag_string ["one", "two", "three"];
=TEX
=SML
store_mt_results mt_run [ 
	("format_list",
	format_list (Combinators.I) ["abc","def","gh ij"],
	":",
	"abc:def:gh ij")
	];
=TEX
\subsection{Tests for $CharacterUtilities$}
=SML
store_mt_results mt_run [ 
	("is_all_decimal 1",
	is_all_decimal,
	"12a3",
	false),
	("is_all_decimal 2",
	is_all_decimal,
	"123",
	true),
	("is_all_decimal 3",
	is_all_decimal,
	"",
	false)
	];
=TEX
As $gensym$ is perhaps used during system build, the immediate results of calling it may well vary, but the output of the following
test should be constant.
=SML
store_mt_results mt_run [ 
	("gensym",
	Combinators.I,
	let val g1 = gensym();
		val g2 = gensym();
		val g3 = gensym()
	in
		((g3 - g2),(g2 - g1))
	end,
	(1,1))
	];
store_mt_results mt_run [ 
	("nat_of_string 1",
	nat_of_string,
	"123",
	123),
	("nat_of_string 2",
	nat_of_string,
	"1234567890123456789012345678901234567890",
	1234567890123456789012345678901234567890)
	];
store_mt_results mt_run_fail [
	("nat_of_string 1012",
	nat_of_string,
	"1a3",
	gen_fail_msg "nat_of_string" 1012 ["1a3"]),
	("nat_of_string 1013",
	nat_of_string,
	"",
	gen_fail_msg "nat_of_string" 1013 [])
	];
store_mt_results mt_run [ 
	("string_of_int 1",
	string_of_int,
	~5,
	"-5"),
	("string_of_int 2",
	string_of_int,
	0,
	"0"),
	("string_of_int 3",
	string_of_int,
	5,
	"5"),
	("string_of_int 4",
	string_of_int,
	123,
	"123")
	];
=TEX
\subsection{Tests for $SimpleDictionary$}
$s\_enter$ and $initial\_s\_dict$ are tested by side effect.
=SML
s_enter "is1" 1 initial_s_dict;
s_enter "is2" 2 it;
s_enter "is3" 3 it;
s_enter "is5" 5 it;
s_enter "is2" 4 it;
val base_simple = it;
store_mt_results mt_run [ 
	("s_lookup 1",
	s_lookup "is3",
	base_simple,
	Value 3),
	("s_lookup 2",
	s_lookup "is4",
	base_simple,
	Nil),
	("s_lookup 3",
	s_lookup "is6",
	base_simple,
	Nil)
	];
store_mt_results mt_run [ 
	("s_delete 1",
	s_delete "is8",
	base_simple,
	base_simple)
	];
store_mt_results mt_run [ 
	("s_delete 2",
	s_lookup "is3",
	(s_delete "is3" base_simple),
	Nil),
	("s_delete 3",
	s_lookup "is2",
	(s_delete "is3" base_simple),
	Value 4)
	];
store_mt_results mt_run [ 
	("s_extend",
	s_lookup "is6",
	s_extend "is6" 6 base_simple,
	Value 6)
	];
store_mt_results mt_run_fail [
	("s_extend 1014",
	s_extend "is3" 4,
	base_simple,
	gen_fail_msg "s_extend" 1014 ["is3"])
	];
store_mt_results mt_run [ 
	("s_merge 1",
	s_lookup "is8",
	s_merge (s_enter "is8" 8 initial_s_dict) base_simple,
	Value 8),
	("s_merge 2",
	s_lookup "is3",
	s_merge (s_enter "is8" 8 initial_s_dict) base_simple,
	Value 3)
	];
store_mt_results mt_run [ 
	("s_merge 3",
	s_merge [],
	[("a",1),("a",2)],
	[("a",1),("a",2)])
	];
store_mt_results mt_run_fail [
	("s_merge 1014 a",
	s_merge (s_enter "is2" 2 initial_s_dict),
	base_simple,
	gen_fail_msg "s_extend" 1014 ["is2"]),
	("s_merge 1014 b",
	s_merge [("a",1),("a",2)],
	[],
	gen_fail_msg "s_extend" 1014 ["a"])
	];
=TEX
\subsection{Tests for $EfficientDictionary$}
$e\_enter$ and $initial\_e\_dict$ are tested by side effect.
=SML
e_enter "is1" 1 initial_e_dict;
e_enter "is2" 2 it;
e_enter "is3" 3 it;
e_enter "is5" 5 it;
e_enter "is2" 4 it;
val base_eff = it;
store_mt_results mt_run [ 
	("e_lookup 1",
	e_lookup "is3",
	base_eff,
	Value 3),
	("e_lookup 2",
	e_lookup "is4",
	base_eff,
	Nil),
	("e_lookup 3",
	e_lookup "is6",
	base_eff,
	Nil)
	];
store_mt_results mt_run [ 
	("e_delete 1",
	e_lookup "is3",
	(e_delete "is3" base_eff),
	Nil),
	("e_delete 2",
	e_lookup "is2",
	(e_delete "is3" base_eff),
	Value 4)
	];
store_mt_results mt_run [ 
	("e_extend",
	e_lookup "is6",
	e_extend "is6" 6 base_eff,
	Value 6)
	];
store_mt_results mt_run_fail [
	("e_extend 1014",
	e_extend "is3" 4,
	base_eff,
	gen_fail_msg "e_extend" 1014 ["is3"])
	];
store_mt_results mt_run [ 
	("e_merge 1",
	e_lookup "is8",
	e_merge (e_enter "is8" 8 initial_e_dict) base_eff,
	Value 8),
	("e_merge 2",
	e_lookup "is3",
	e_merge (e_enter "is8" 8 initial_e_dict) base_eff,
	Value 3)
	];
store_mt_results mt_run_fail [
	("e_merge 1014",
	e_merge (e_enter "is2" 2 initial_e_dict),
	base_eff,
	gen_fail_msg "e_extend" 1014 ["is2"])
	];
store_mt_results mt_run [ 
	("e_flatten",
	e_flatten,
	base_eff,
	base_simple)
	];
store_mt_results mt_run [ 
	("list_e_merge 1",
	e_lookup "is8",
	list_e_merge base_eff (s_enter "is8" 8 initial_s_dict),
	Value 8),
	("list_e_merge 2",
	e_lookup "is3",
	list_e_merge base_eff (s_enter "is8" 8 initial_s_dict),
	Value 3)
	];
store_mt_results mt_run_fail [
	("list_e_merge",
	list_e_merge base_eff,
	(s_enter "is2" 2 initial_s_dict),
	gen_fail_msg "e_extend" 1014 ["is2"])
	];
=TEX
\subsection{Tests for $Profiling$}
We test $prof$, $print\_stats$ and $init\_stats$ by side effect.
=SML
init_stats();
store_mt_results mt_run [ 
	("get_stats 1",
	get_stats,
	(),
	[])
	];
print_stats(get_stats());
store_mt_results mt_run [ 
	("counts 1",
	counts,
	"test",
	Nil)
	];
prof "test";prof "test1";prof "test";
set_flag ("profiling", false);
prof "test";prof "test1";prof "test";
set_flag ("profiling", true);
prof "test";prof "test1";prof "test";
print_stats(get_stats());
store_mt_results mt_run [ 
	("counts 2",
	counts,
	"test",
	Value 4)
	];
store_mt_results mt_run [ 
	("counts 3",
	counts,
	"not tested",
	Nil)
	];
store_mt_results mt_run [ 
	("get_stats 2",
	get_stats,
	(),
	[("test", 4), ("test1", 2)])
	];

=TEX
\subsection{Tests for $Sort$}
$lexicographic$ is tested by $stringorder$ calls.
=SML
open Sort;
store_mt_results mt_run [ 
	("sort 1",
	sort (curry (op -)),
	[3,2,5,1,8,2,3,6],
	[1, 2, 3, 5, 6, 8]),
	("sort 2",
	sort (curry (op -)),
	[],
	[])
	];
store_mt_results mt_run [ 
	("stringorder 1",
	stringorder "a",
	"c",
	~2),
	("stringorder 2",
	stringorder "c",
	"a",
	2),
	("stringorder 3",
	stringorder "A",
	"C",
	~2),
	("stringorder 4",
	stringorder "C",
	"A",
	2),
	("stringorder 5",
	stringorder "a",
	"C",
	~2),
	("stringorder 6",
	stringorder "C",
	"a",
	2),
	("stringorder 7",
	stringorder "A",
	"c",
	~2),
	("stringorder 8",
	stringorder "C",
	"a",
	2),
	("stringorder 9",
	stringorder " ",
	"c",
	1),
	("stringorder 10",
	stringorder ">",
	"c",
	1),
	("stringorder 11",
	stringorder "c",
	" ",
	~1),
	("stringorder 12",
	stringorder "c",
	">",
	~1),
	("stringorder 13",
	stringorder " ",
	"C",
	1),
	("stringorder 14",
	stringorder ">",
	"C",
	1),
	("stringorder 15",
	stringorder "C",
	" ",
	~1),
	("stringorder 16",
	stringorder "C",
	">",
	~1),
	("stringorder 17",
	stringorder ">",
	" ",
	30),
	("stringorder 18",
	stringorder " ",
	">",
	~30),
	("stringorder 19",
	stringorder "a",
	"a",
	0),
	("stringorder 20",
	stringorder "A",
	"A",
	0),
	("stringorder 21",
	stringorder "a",
	"A",
	32),
	("stringorder 22",
	stringorder "A",
	"a",
	~32),
	("stringorder 23",
	stringorder "ab",
	"ab",
	0),
	("stringorder 24",
	stringorder "abfd",
	"abcd",
	3),
	("stringorder 25",
	stringorder "aaAap",
	"aaaaP",
	~32),
	("stringorder 26",
	stringorder "aaAap",
	"aaaaq",
	~1),
	("stringorder 27",
	stringorder "abc",
	"ab",
	1),
	("stringorder 28",
	stringorder "ab",
	"abc",
	~1)
	];
=TEX
\section{END OF TESTS}
=SML
summarize_mt_results();
=TEX
\end{document}
