% mdt058.doc $Id$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Automatic Existence Proofs}  %% Mandatory field
\def\TPPheadtitle{Module Tests for Automatic Existence Proofs}
\TPPref{DS/FMU/IED/MDT058}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the 
the automatic existence proof tools.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1]
First draft.

\item[Issue 1.2, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.3]
Removed duplicate labels.

\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the automatic existence proof tools.
The design is in \cite{DS/FMU/IED/DTD058}
and it is
implemented in \cite{DS/FMU/IED/IMP058}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD058},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD058},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP058}.
\subsubsection{Deficiencies}
None known.
\section{TEST CASES}
We test each function of the signature of \cite{DS/FMU/IED/DTD058}
in turn, where possible in the same order as in the design document, testing both successful, and all error, cases.
We do not test for design errors, or the ``special case''
message 58015, in the later case as it is not certain that it can be provoked.
\section{PROLOGUE}
Initialise the test package:
=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results();
=TEX
=SML
open_theory "sum";
=TEX
\section{SETTING THE PROOF CONTEXT}
To make the tests independent of some outside changes, we give a local 
proof context:
=SML
pop_proof_context();
push_proof_context prove_¶_epc;
=TEX
\section{THE TESTS OF COMPONENT FUNCTIONS}
\subsection{ALL$\_$SIMPLE$\_$µ$\_$C}
=SML
store_mt_results mt_run [
	("ALL_SIMPLE_µ_C 1",
	dest_thm o ALL_SIMPLE_µ_C eq_sym_conv,
	¬µ a b c:'a · a = b®,
	([],¬(µ a b c:'a · a = b) = (µ a b c:'a · b = a)®)),
	("ALL_SIMPLE_µ_C 2",
	dest_thm o ALL_SIMPLE_µ_C eq_sym_conv,
	¬µ a· a = b®,
	([],¬(µ a· a = b) = (µ a· b = a)®)),
	("ALL_SIMPLE_µ_C 3",
	dest_thm o ALL_SIMPLE_µ_C eq_sym_conv,
	¬a = b®,
	([],¬(a = b) = (b = a)®))
	];
store_mt_results mt_run_fail [
	("ALL_SIMPLE_µ_C 3014",
	ALL_SIMPLE_µ_C eq_sym_conv,
	mk_t,
	gen_fail_msg "eq_sym_conv" 3014 ["¬T®"])
	];
=TEX
\subsection{ALL$\_$SIMPLE$\_$¶$\_$C}
=SML
store_mt_results mt_run [
	("ALL_SIMPLE_¶_C 1",
	dest_thm o ALL_SIMPLE_¶_C eq_sym_conv,
	¬¶ a b c:'a · a = b®,
	([],¬(¶ a b c:'a · a = b) = (¶ a b c:'a · b = a)®)),
	("ALL_SIMPLE_¶_C 2",
	dest_thm o ALL_SIMPLE_¶_C eq_sym_conv,
	¬¶ a· a = b®,
	([],¬(¶ a· a = b) = (¶ a· b = a)®)),
	("ALL_SIMPLE_¶_C 3",
	dest_thm o ALL_SIMPLE_¶_C eq_sym_conv,
	¬a = b®,
	([],¬(a = b) = (b = a)®))
	];
store_mt_results mt_run_fail [
	("ALL_SIMPLE_¶_C 3014",
	ALL_SIMPLE_¶_C eq_sym_conv,
	mk_t,
	gen_fail_msg "eq_sym_conv" 3014 ["¬T®"])
	];
=TEX
\subsection{ALL$\_$±$\_$C}
=SML
store_mt_results mt_run [
	("ALL_±_C 1",
	dest_thm o ALL_±_C eq_sym_conv,
	¬a ± (a ¤ b) ± c®,
	([],¬(a ± (a ¤ b) ± c) ¤ (a ± (b ¤ a) ± c)®)),
	("ALL_±_C 2",
	dest_thm o ALL_±_C eq_sym_conv,
	¬(a ¤ b)®,
	([],¬(a ¤ b) ¤ (b ¤ a)®))
	];
store_mt_results mt_run_fail [
	("ALL_±_C 3014",
	ALL_±_C eq_sym_conv,
	¬a ± b®,
	gen_fail_msg "eq_sym_conv" 3014 ["¬b®"])
	];
=TEX
\subsection{ALL$\_$²$\_$C}
=SML
store_mt_results mt_run [
	("ALL_²_C 1",
	dest_thm o ALL_²_C eq_sym_conv,
	¬a ² (a ¤ b) ² c®,
	([],¬(a ² (a ¤ b) ² c) ¤ (a ² (b ¤ a) ² c)®)),
	("ALL_²_C 2",
	dest_thm o ALL_²_C eq_sym_conv,
	¬(a ¤ b)®,
	([],¬(a ¤ b) ¤ (b ¤ a)®))
	];
store_mt_results mt_run_fail [
	("ALL_²_C 3014",
	ALL_²_C eq_sym_conv,
	¬a ² b®,
	gen_fail_msg "eq_sym_conv" 3014 ["¬b®"])
	];
=TEX
\subsection{simple$\_$¶$\_$²$\_$conv}
=SML
store_mt_results mt_run [
	("simple_¶_²_conv 1",
	dest_thm o simple_¶_²_conv,
	¬¶ x y · f x ² g y®,
	([],¬(¶ x y · f x ² g y) ¤ (¶ x · f x) ² (¶ y · g y)®)),
	("simple_¶_²_conv 2",
	dest_thm o simple_¶_²_conv,
	¬¶ x y · f x ² g y ² h x y ² i®,
	([],¬(¶ x y · f x ² g y ² h x y ² i) ¤ 
		(¶ x · f x) 
		² (¶ y · g y)
		² (¶ x y · h x y)
		² i®))
	];
store_mt_results mt_run_fail [
	("simple_¶_²_conv",
	simple_¶_²_conv,
	mk_t,
	gen_fail_msg "simple_¶_²_conv" 58010 ["¬T®"])
	];
=TEX

\subsection{simple$\_$¶$\_$±$\_$conv}
=SML
store_mt_results mt_run [
	("simple_¶_±_conv 1",
	dest_thm o simple_¶_±_conv,
	¬¶ x · P x ± Q®,
	([],¬(¶ x · P x ± Q) ¤ (¶ x · P x) ± Q®)),
	("simple_¶_±_conv 2",
	dest_thm o simple_¶_±_conv,
	¬¶ x · P ± Q x®,
	([],¬(¶ x:'a · P ± Q x) ¤ (¶ x:'a · Q x) ± P®)),
	("simple_¶_±_conv 3",
	dest_thm o simple_¶_±_conv,
	¬¶ x y:'a · P x ± Q y®,
	([],¬(¶ x y :'a· P x ± Q y) ¤ (¶ y:'a · Q y) ± (¶ x:'a ·P x)®)),
	("simple_¶_±_conv 4",
	dest_thm o simple_¶_±_conv,
	¬¶ x y z:'a · P x z ± Q y z®,
	([],¬(¶ x y z :'a· P x z ± Q y z) ¤ 
	¶ z :'a· (¶ y :'a· Q y z) ± (¶ x :'a·P x z)®))
	];
store_mt_results mt_run_fail [
	("simple_¶_±_conv",
	simple_¶_±_conv,
	mk_t,
	gen_fail_msg "simple_¶_±_conv" 58012 ["¬T®"])
	];
=TEX
\subsection{µ$\_$±$\_$conv}
=SML
store_mt_results mt_run [
	("simple_µ_±_conv 1",
	dest_thm o µ_±_conv,
	¬µ x y · f x ± g y®,
	([],¬(µ x y · f x ± g y) ¤ (µ x · f x) ± (µ y · g y)®)),
	("µ_±_conv 2",
	dest_thm o µ_±_conv,
	¬µ x y · f x ± g y ± h x y ± i®,
	([],¬(µ x y · f x ± g y ± h x y ± i) ¤ 
		(µ x · f x) 
		± (µ y · g y)
		± (µ x y · h x y)
		± i®)),
	("simple_µ_±_conv 3",
	dest_thm o µ_±_conv,
	¬µ (x, y) · f x ± g y®,
	([],¬(µ (x,y) · f x ± g y) ¤ (µ x · f x) ± (µ y · g y)®))
	];
store_mt_results mt_run_fail [
	("µ_±_conv",
	µ_±_conv,
	mk_t,
	gen_fail_msg "µ_±_conv" 58020 ["¬T®"])
	];
=TEX
\subsection{simple$\_$µ$\_$¶$\_$conv}
=SML
store_mt_results mt_run [
	("simple_µ_¶_conv 1",
	dest_thm o simple_µ_¶_conv,
	¬µ x :'a· ¶ y:'b · f x ± g y®,
	([],¬(µ x :'a· ¶ y :'b· f x ± g y) ¤ (¶ y' · µ x:'a · f x ± g (y' x))®))
	];
store_mt_results mt_run_fail [
	("simple_µ_¶_conv",
	simple_µ_¶_conv,
	mk_t,
	gen_fail_msg "simple_µ_¶_conv" 58016 ["¬T®"])
	];
=TEX
\subsection{simple$\_$¶$\_$µ$\_$conv}
=SML
store_mt_results mt_run [
	("simple_¶_µ_conv 1",
	dest_thm o simple_¶_µ_conv,
	¬¶ x :'b· µ y:'a · f x ± g y®,
	([],¬(¶ x:'b · µ y:'a · f x ± g y) ¤ (µ y' · ¶ x:'b · f x ± g (y' x))®))
	];
store_mt_results mt_run_fail [
	("simple_¶_µ_conv",
	simple_¶_µ_conv,
	mk_t,
	gen_fail_msg "simple_¶_µ_conv" 58017 ["¬T®"])
	];
=TEX
\subsection{simple$\_$¶$\_$µ$\_$conv1}
=SML
store_mt_results mt_run [
	("simple_¶_µ_conv1 1",
	dest_thm o simple_¶_µ_conv1,
	¬¶ y :'c ­ 'b · µ x :'c· f x ± g (y x)®,
	([],¬(¶ y :'c ­ 'b · µ x :'c· f x ± g (y x)) ¤ (µ x · ¶ y'· f x ± g y')®))
	];
store_mt_results mt_run_fail [
	("simple_¶_µ_conv1",
	simple_¶_µ_conv1,
	mk_t,
	gen_fail_msg "simple_¶_µ_conv1" 58019 ["¬T®"])
	];
=TEX
\subsection{simple$\_$¶$\_$equation$\_$conv}
=SML
store_mt_results mt_run [
	("simple_¶_equation_conv 1",
	dest_thm o simple_¶_equation_conv,
	¬¶ f · f = x®,
	([],¬(¶ f · f = x) ¤ (T)®)),
	("simple_¶_equation_conv 2",
	dest_thm o simple_¶_equation_conv,
	¬¶ f · x = f®,
	([],¬(¶ f · x = f) ¤ (T)®)),
	("simple_¶_equation_conv 3",
	dest_thm o simple_¶_equation_conv,
	¬¶ f · (f = x) ± P f®,
	([],¬(¶ f · (f = x) ± P f) ¤ (P x)®)),
	("simple_¶_equation_conv 4",
	dest_thm o simple_¶_equation_conv,
	¬¶ f g · (f = g) ± P f®,
	([],¬(¶ f g · (f = g) ± P f) ¤ (¶ g · P g)®)),
	("simple_¶_equation_conv 5",
	dest_thm o simple_¶_equation_conv,
	¬¶ f · f ± P f®,
	([],¬(¶ f · f ± P f) ¤ (P T)®)),
	("simple_¶_equation_conv 6",
	dest_thm o simple_¶_equation_conv,
	¬¶ f · ³ f ± P f®,
	([],¬(¶ f · ³ f ± P f) ¤ (P F)®))
	];
store_mt_results mt_run_fail [
	("simple_¶_equation_conv 3034",
	simple_¶_equation_conv,
	mk_t,
	gen_fail_msg "simple_¶_equation_conv" 3034 ["¬T®"]),
	("simple_¶_equation_conv 58013 1",
	simple_¶_equation_conv,
	¬¶ x · f x®,
	gen_fail_msg "simple_¶_equation_conv" 58013 ["¬¶ x· f x®"]),
	("simple_¶_equation_conv 58013 2",
	simple_¶_equation_conv,
	¬¶ x · µ f · f = x®,
	gen_fail_msg "simple_¶_equation_conv" 58013 ["¬¶ x· µ f· f = x®"])
	];
=TEX
\section{THE TESTS OF MAIN FUNCTIONS}
\subsection{prove$\_$¶$\_$conv}
=SML
store_mt_results mt_run [
	("prove_¶_conv 1",
	dest_thm o prove_¶_conv,
	¬¶ f · f®,
	([],¬(¶ f · f) ¤ (T)®)),
	("prove_¶_conv 2",
	dest_thm o prove_¶_conv,
	¬¶ f · (a = f) ± f g®,
	([],¬(¶ f · (a = f) ± f g) ¤ (a g)®)),
	("prove_¶_conv 3",
	dest_thm o prove_¶_conv,
	¬¶ f · µ z · (z h ± (a = f) ± z f) ± f g®,
	([],¬(¶ f · µ z · (z h ± (a = f) ± z f) ± f g) ¤ 
		((µ z · z h) ± (µ z · z a) ± a g)®)),
	("prove_¶_conv 4",
	dest_thm o prove_¶_conv,
	¬¶ f:'a ­ BOOL · µ (z, x) · (z h ± (a = f) ± z (f x)) ± (µ g :'a· f g)®,
	([],¬(¶ f:'a ­ BOOL · µ (z, x) · (z h ± (a = f) ± z (f x)) ± (µ g :'a· f g)) ¤ 
	(((µ z x · z (a x)) ± (µ g:'a· a g)) ± (µ z · z h))®)),
	("prove_¶_conv 5",
	dest_thm o prove_¶_conv,
	¬¶ f:'b ­ 'c · (µ x · f x = g) ± (µ y · h (f  y))®,
	([],¬(¶ f :'b ­ 'c· (µ x · f x = g) ± (µ y · h (f  y))) ¤ 
		(h g)®)),
	("prove_¶_conv 6",
	dest_thm o prove_¶_conv,
	¬¶ f:((BOOL ¸ BOOL) ¸ (BOOL ¸ BOOL)) ­ BOOL ­ BOOL · 
		(µ a b c p · f (a,(b,c)) p ¤ Fst a ± c ± p) ±
		(µ d e g p · f ((d,e),g) p ¤ Snd g ± p ± d)  ±
		(µ a g q · f(a,g) q ¤ q ± Snd g ± Fst a)®,
	([],¬(¶ f:((BOOL ¸ BOOL) ¸ (BOOL ¸ BOOL)) ­ BOOL ­ BOOL · 
		(µ a b c p · f (a,(b,c)) p ¤ Fst a ± c ± p) ±
		(µ d e g p · f ((d,e),g) p ¤ Snd g ± p ± d)
±
		(µ a g q · f(a,g) q ¤ q ± Snd g ± Fst a)) 
	¤ 
		((µ (x:(BOOL ¸ BOOL) ¸ (BOOL ¸ BOOL)) p'· (Fst (Fst x)
	 ± Snd (Snd x) ± p' ¤ Snd (Snd x) ± p' ± Fst (Fst x))
  ± (Fst (Fst x) ± Snd (Snd x) ± p' ¤ p' ± Snd (Snd x) ± Fst (Fst x))))®))
	];

=TEX
=SML
store_mt_results mt_run_fail [
	("prove_¶_conv 58001",
	prove_¶_conv,
	mk_t,
	gen_fail_msg "prove_¶_conv" 58001 ["¬T®"]),
	("prove_¶_conv 58002",
	prove_¶_conv,
	¬¶ f · P f®,
	gen_fail_msg "prove_¶_conv" 58002 ["¬¶ f· P f®"])
	];
=TEX

\subsection{prove$\_$¶$\_$rule}
=SML
fun test tm = (concl(prove_¶_rule tm) = tm);
store_mt_results mt_run [
	("prove_¶_rule 1",
	test,
	¬¶ a (b, c) d e · (a = b) ± (a = d) ± (b = 1) ± (c = d) ± (e = c)®,
	true),
	("prove_¶_rule 2",
	test,
	¬¶ f ·f®,
	true),
	("prove_¶_rule 3",
	test,
	¬¶ f · f ¤ T®,
	true),
	("prove_¶_rule 4",
	test,
	¬¶ f · a = f®,
	true),
	("prove_¶_rule 5",
	test,
	¬¶ f · µ x · f x®,
	true),
	("prove_¶_rule 6",
	test,
	¬¶ f g h · (µ x · f x = g) ± (µ y · h (f  y))®,
	true),
	("prove_¶_rule 7",
	test,
	¬¶ g h f · (µ x y z · f x y z = g y z x) ± (µ a b c · h (f c a) b)®,
	true),
	("prove_¶_rule 8",
	test,
	¬¶ fst snd · µ x y · (fst(x,y) = x) ± (snd(x,y) = y)®,
	true),
	("prove_¶_rule 9",
	test,
	¬¶ app · µ p q r · (app [] q = q) ±
	(app (Cons p q) r = (Cons p (app q r))) ± T®,
	true),
	("prove_¶_rule 10",
	test,
	¬¶ app · (µ q · (app [] q = q)) ±
	(µ p q r · (app (Cons p q) r = (Cons p (app q r))))®,
	true),
	("prove_¶_rule 11",
	test,
	¬¶ mp · µ f · (mp f [] = []) ± (µ p q · mp f (Cons p q) = Cons (f p) (mp f q))®,
	true),
	("prove_¶_rule 12",
	test,
	¬¶ ce ·µ p q r s · 
	(ce (Cons p r) (Cons q s) ¤ (p = q) ± (ce r s)) ±
	(ce [] []) ±
	(³ ce (Cons p r) []) ±
	(³ ce [] (Cons p r))®,
	true),
	("prove_¶_rule 13",
	test,
	¬¶ fact · µ n · (fact 0 = 1) ± (fact (n+1) = (n + 1) *  fact n)®,
	true),
	("prove_¶_rule 14",
	test,
	¬¶ limit_it · µ n a x · 
	(limit_it (n + 1) (Cons a x) = Cons a (limit_it n x)) ±
	(limit_it (n + 1) [] = []) ±
	(limit_it 0 [] = []) ±
	(limit_it 0 (Cons a x) = [])®,
	true),
	("prove_¶_rule 15",
	test,
	¬¶ limit_it · µ n a x · 
	(limit_it (n + 1) (Cons a x) = Cons a (limit_it n x)) ±
	(limit_it (n + 1) [] = []) ±
	(limit_it 0 x = [])®,
	true),
	("prove_¶_rule 16",
	test,
	¬¶ f · µ x y · (f(InL x) = g x)± (f(InR y) = h y)®,
	true),
	("prove_¶_rule 17",
	test,
	¬¶ f ·f [] = 1®,
	true),
	("prove_¶_rule 18",
	test,
	¬¶ f ·µ x a · f (Cons a x) = a®,
	true),
	("prove_¶_rule 19",
	test,
	¬¶ f ·µ x a · f (a+1) = a®,
	true),
	("prove_¶_rule 20",
	test,
	¬¶ f ·f 0 = a®,
	true),
	("prove_¶_rule 21",
	test,
	¬¶ ce ·µ p q r s · 
	(ce (Cons p r, Cons q s) ¤ (p = q) ± (ce (r, s))) ±
	(ce ([], [])) ±
	(³ ce (Cons p r,[])) ±
	(³ ce ([], Cons p r))®,
	true)
	];

=TEX
=SML
store_mt_results mt_run_fail [
	("prove_¶_rule 58001",
	prove_¶_rule,
	mk_t,
	gen_fail_msg "prove_¶_rule" 58001 ["¬T®"]),
	("prove_¶_rule 58002",
	prove_¶_rule,
	¬¶ f · P f®,
	gen_fail_msg "prove_¶_rule" 58002 ["¬¶ f· P f®"]),
	("prove_¶_rule 58003",
	prove_¶_rule,
	¬¶ f · f ± P®,
	gen_fail_msg "prove_¶_rule" 58003 ["¬¶ f· f ± P®"])
	];
=TEX

\subsection{prove$\_$¶$\_$tac}
=SML
fun test tm = (concl(tac_proof(([],tm),prove_¶_tac)) = tm);
store_mt_results mt_run [
	("prove_¶_tac 1",
	test,
	¬¶ a (b, c) d e · (a = b) ± (a = d) ± (b = 1) ± (c = d) ± (e = c)®,
	true),
	("prove_¶_tac 2",
	test,
	¬¶ f ·f®,
	true),
	("prove_¶_tac 3",
	test,
	¬¶ f · f ¤ T®,
	true),
	("prove_¶_tac 4",
	test,
	¬¶ f · a = f®,
	true),
	("prove_¶_tac 5",
	test,
	¬¶ f · µ x · f x®,
	true),
	("prove_¶_tac 6",
	test,
	¬¶ f g h · (µ x · f x = g) ± (µ y · h (f  y))®,
	true),
	("prove_¶_tac 7",
	test,
	¬¶ g h f · (µ x y z · f x y z = g y z x) ± (µ a b c · h (f c a) b)®,
	true),
	("prove_¶_tac 8",
	test,
	¬¶ fst snd · µ x y · (fst(x,y) = x) ± (snd(x,y) = y)®,
	true),
	("prove_¶_tac 9",
	test,
	¬¶ app · µ p q r · (app [] q = q) ±
	(app (Cons p q) r = (Cons p (app q r))) ± T®,
	true),
	("prove_¶_tac 10",
	test,
	¬¶ app · (µ q · (app [] q = q)) ±
	(µ p q r · (app (Cons p q) r = (Cons p (app q r))))®,
	true),
	("prove_¶_tac 11",
	test,
	¬¶ mp · µ f · (mp f [] = []) ± (µ p q · mp f (Cons p q) = Cons (f p) (mp f q))®,
	true),
	("prove_¶_tac 12",
	test,
	¬¶ ce ·µ p q r s · 
	(ce (Cons p r) (Cons q s) ¤ (p = q) ± (ce r s)) ±
	(ce [] []) ±
	(³ ce (Cons p r) []) ±
	(³ ce [] (Cons p r))®,
	true),
	("prove_¶_tac 13",
	test,
	¬¶ fact · µ n · (fact 0 = 1) ± (fact (n+1) = (n + 1) *  fact n)®,
	true),
	("prove_¶_tac 14",
	test,
	¬¶ limit_it · µ n a x · 
	(limit_it (n + 1) (Cons a x) = Cons a (limit_it n x)) ±
	(limit_it (n + 1) [] = []) ±
	(limit_it 0 [] = []) ±
	(limit_it 0 (Cons a x) = [])®,
	true),
	("prove_¶_tac 15",
	test,
	¬¶ limit_it · µ n a x · 
	(limit_it (n + 1) (Cons a x) = Cons a (limit_it n x)) ±
	(limit_it (n + 1) [] = []) ±
	(limit_it 0 x = [])®,
	true),
	("prove_¶_tac 16",
	test,
	¬¶ f · µ x y · (f(InL x) = g x)± (f(InR y) = h y)®,
	true),
	("prove_¶_tac 17",
	test,
	¬¶ f ·f [] = 1®,
	true),
	("prove_¶_tac 18",
	test,
	¬¶ f ·µ x a · f (Cons a x) = a®,
	true),
	("prove_¶_tac 19",
	test,
	¬¶ f ·µ x a · f (a+1) = a®,
	true),
	("prove_¶_tac 20",
	test,
	¬¶ f ·f 0 = a®,
	true),
	("prove_¶_tac 21",
	test,
	¬¶ ce ·µ p q r s · 
	(ce (Cons p r, Cons q s) ¤ (p = q) ± (ce (r, s))) ±
	(ce ([], [])) ±
	(³ ce (Cons p r,[])) ±
	(³ ce ([], Cons p r))®,
	true)
	];

=TEX
=SML
store_mt_results mt_run_fail [
	("prove_¶_tac 58004",
	prove_¶_tac,
	([],mk_t),
	gen_fail_msg "prove_¶_tac" 58004 []),
	("prove_¶_tac 58005",
	prove_¶_tac,
	([],¬¶ f · P f®),
	gen_fail_msg "prove_¶_tac" 58005 []),
	("prove_¶_tac 58006",
	prove_¶_tac,
	([],¬¶ f · f ± P®),
	gen_fail_msg "prove_¶_tac" 58006 [])
	];
=TEX
\section{PROOF CONTEXTS}
We first create a new theory:
=SML
open_theory "sum";
delete_theory "mdt058_test_theory" handle (Fail _) => ();
new_theory "mdt058_test_theory";
new_type ("NARY",1);
new_const("NNode",¬:('a NARY)LIST ­ 'a NARY®);
new_const("NLeaf",¬:'a ­ 'a NARY®);
val nary_axiom = new_axiom("nary_axiom",
	¬µ node leaf · ¶%down%1 f · 
	(µ n · f (NLeaf n) = leaf n) ±
	(µ l · f (NNode l) = node l (Map f l))®);

new_type ("OPS",1);
new_const("Op1",¬:'a OPS ­ 'a OPS ­ 'a OPS®);
new_const("Op2",¬:'a OPS ­ 'a OPS ­ 'a OPS®);
new_const("Atom",¬:'a ­ 'a OPS®);
val ops_axiom = new_axiom("ops_axiom",
	¬µ a op1 op2 · ¶%down%1 f ·
	(µ x · f (Atom x) = a x) ±
	(µ p q · f (Op1 p q) = op1 p q (f p) (f q)) ±
	(µ p q · f (Op2 p q) = op2 (f p) (f q) p q)®);

new_type("TRIPLE",3);
val triple = new_const("Triple",¬:'a ­ 'b ­ 'c ­ ('a, 'b, 'c)TRIPLE®);
val tripe1 = new_const("Tripe1",¬:('a, 'b, 'c)TRIPLE ­ 'a®);
val tripe2 = new_const("Tripe2",¬:('a, 'b, 'c)TRIPLE ­ 'b®);
val tripe3 = new_const("Tripe3",¬:('a, 'b, 'c)TRIPLE ­ 'c®);
val tripe_rw = new_axiom("tripe_rw",
	¬µ a b c x · 
	(Triple(Tripe1 x)(Tripe2 x)(Tripe3 x) = x)
	±
	(Tripe1(Triple a b c) = a)
	±
	(Tripe2(Triple a b c) = b)
	±
	(Tripe3(Triple a b c) = c)®);
=TEX
Now create a new context (incidentally testing $evaluate\_¶\_cd\_thm$:
=SML
val new_prove_¶_epc = (
	set_epc_¶_vs_thm 
	(("Triple",([tripe1, tripe2, tripe3],tripe_rw)) ::
		(get_epc_¶_vs_thm(get_proof_context())))
	(set_epc_¶_cd_thm
	(evaluate_¶_cd_thm nary_axiom :: 
		evaluate_¶_cd_thm ops_axiom :: 
		(get_epc_¶_cd_thm(get_proof_context())))
	prove_¶_epc)
);
push_proof_context new_prove_¶_epc;
=TEX
Now test it:
=SML
fun test tm = (concl(prove_¶_rule tm) = tm);
store_mt_results mt_run [
	("prove_¶_rule 1 a",
	test,
	¬¶ g · µ p q a · (g (Op2 p q) ¤ h p ± g q)
	± 
	(g (Op1 p q) ¤ h q ± g p)
	± 
	g(Atom a) = (a=0)®,
	true),
	("prove_¶_rule 2 a",
	test,
	¬¶ sum_tree ·
	(µ n · sum_tree (NLeaf n) = n) ±
	(µ l · sum_tree (NNode l) = Fold ($+) (Map sum_tree l) 0)®,
	true),
	("prove_¶_rule 3 a",
	test,
	¬¶ map_tree · µ f l n · 
	(map_tree f (NLeaf n) = NLeaf (f n))
	±
	(map_tree f (NNode l) = NNode (Map (map_tree f) l))®,
	true),
	("prove_¶_rule 4 a",
	test,
	¬¶ f · µ a b c n x · (f 0 (Triple a b c) ¤ a ± b ± c) ±
		(f (n+1) x ¤ h n ± f n x)®,
	true)
	];
=TEX
\subsection{evaluate$\_$¶$\_$cd$\_$thm}
Successful evaluation of this function is tested above.
Failures:
=SML
store_mt_results mt_run_fail [
	("evaluate_¶_cd_thm 58007",
	evaluate_¶_cd_thm,
	t_thm,
	gen_fail_msg "evaluate_¶_cd_thm" 58007 ["ô T"]),
	("evaluate_¶_cd_thm 58008",
	evaluate_¶_cd_thm,
	asm_rule ¬µ P · ¶%down%1 f · P f®,
	gen_fail_msg "evaluate_¶_cd_thm" 58008 
		["µ P· ¶%down%1 f· P f ô µ P· ¶%down%1 f· P f"]),
	("evaluate_¶_cd_thm 58009",
	evaluate_¶_cd_thm,
	asm_rule ¬µ P· ¶%down%1 f· g 0 = P f®,
	gen_fail_msg "evaluate_¶_cd_thm" 58009
		["µ P· ¶%down%1 f· g 0 = P f ô µ P· ¶%down%1 f· g 0 = P f"]),
	("evaluate_¶_cd_thm 58021",
	evaluate_¶_cd_thm,
	asm_rule ¬µ P R· ¶%down%1 f· (f 0 = P f) ± 
		(f 0 = R f) ®,
	gen_fail_msg "evaluate_¶_cd_thm" 58021 
		[("µ P R· ¶%down%1 f· f 0 = P f ± f 0 = R f " ^ 
		"ô µ P R· ¶%down%1 f· f 0 = P f ± f 0 = R f")]),
	("evaluate_¶_cd_thm 58023",
	evaluate_¶_cd_thm,
	asm_rule ¬µ P· ¶%down%1 f· f 0 = R®,
	gen_fail_msg "evaluate_¶_cd_thm" 58023 
		["µ P· ¶%down%1 f· f 0 = R ô µ P· ¶%down%1 f· f 0 = R"])
	];
=TEX

\subsection{End of Tests}
=SML
diag_string(summarize_mt_results());
=TEX
\end{document}


