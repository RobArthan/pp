=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of Constant Specification Tools}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD046}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthors{R.D. Arthan & WIN01 \\ K.Blackburn & WIN01}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the detailed design
of the tools supporting specification of constants in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item[Issue 1.1] 
First experimental version.
\item [Issue 1.2]
First ``real'' design.
\end{description}
\subsection{Changes Forecast}

Under development.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Tools supporting specification of constants will be required in ICL HOL
and are called for in \cite{DS/FMU/IED/HLD010}.This document provides a detailed design for these tools.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the
tools supporting specification of constants.
\subsubsection{Dependencies}
This document depends upon the paired-abstraction inference rules of
\cite{DS/FMU/IED/DTD027}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Conventions}
The tools described in this document work best when certain conventions are obeyed.
All ICL supplied material will follow these conventions, though 
the user may choose to break convention, though we would advise against it.

These conventions are that:
\begin{itemize}
\item
Any definition will be saved under at least the keys that are the
defined constant's names, and that additional keys are not, and will not be the names
of other constants.
\item
If a predicate used in $new\_term\_specification$ is proven
consistent by hand then the result is of the form `$Ö$ $Consistent$
$(ç (x1,...,xn)\ é\ p$', and is saved under the keys
$x1\_consistent$, ..., $xn\_consistent$.
\end{itemize}
\section{METHODS AND ISSUES}

There are some theoretical and practical
issues to be taken into account in designing tools
to support specification.

Ideally we would like to let the user define object
language constants by giving arbitrary
predicates.
The resulting theories would, in general, be inconsistent.
(i.e. it would be possible to prove $F$ in them).
Moreover, there is no decision procedure to determine
whether or not an arbitrary predicate gives
rise to a consistent (or conservative)
extension.
The conservative extension mechanism $new\_specification$, 
of \cite{DS/FMU/IED/DTD012},
therefore, imposes a restriction on the predicates which
may be used and require the user to supply a theorem
of a certain form, which can be viewed as justifying
the consistency of the definition.
(In an appendix (\ref{COUNTEREXAMPLES} below) we give
some examples which show the need for the restrictions
on the predicates).

The main concern in this document is to enable the
user to defer the task of proving the consistency
of his specification until the specification is
complete. To do this we turn each defining
predicate supplied by the user into one which
can automatically be proved consistent and which is
coextensive with the user's predicate
provided that is consistent.
We also
try to prove the consistency automatically by a tool indicated by the current proof context (see \cite{DS/FMU/IED/DTD051}), so as to
simplify the definition which is actually stored
on the theory.

The details of the conservative extension interfaces
prevent us from making the defining theorems for
constants in the precise forms usually
required by the user. As an expedient we supply an
interface function, $get\-\_speci\-fication$,
(analagous to $get\-\_defn$),
which derives a theorem in a convenient form from
the defining theorem.
\section{PREAMBLE}
=THDOC
req_name "const_spec" (Value "pair");
=DESCRIBE
Theory ``‚const\_spec·'' holds the utilities concerned with
providing the constant specification tools.
=ENDDOC
=DOC
signature ‚ConstantSpecification·  = sig
=DESCRIBE
This is the signature of a structure supporting specification of
constants.
=ENDDOC
\section{THE DESIGN}
\subsection{(Paired) Definitions}
=DOC
val ‚new_defn· : string list * TERM -> THM;
=DESCRIBE
$new\_defn(keys,ªtmº)$ introduces a new constant into the
current theory with 
its defining theorem derived from $tm$ as explained
below, saving the definition under each member of $keys$.
$tm$ is expected to have one of the following forms:
Û
	Éx1 x2 ... xméx v1 v2 ... vn = t
Ê
Either of $m$ or $n$ here may be 0. The $v_i$ must all be
allowed variable structures. $x$ must not appear free in $t$ or in the $x_i$.
The new constant has the same name and type as the variable $x$.
=FAILURE
6037	Theory ?0 is locked
6049	There is a constant called ?0 already in scope
6061	the body of ?0 contains type variables not found in type
	of constants to be defined, the variables being: ?1
6063	There is a constant called ?0 in the descendants of the
	current theory
6071	Theory ?0 is a read-only ancestor
46000	Defining term contains the following free variables: ?0
46001	Defining term ?0 is not of the form: ªÉx1 x2 ... xméx v1 v2 ... vn = tº
46002	The left hand side of the defining equation, ?0, must have the form
	ªxº or ªx a1 ... akº, where ªxº is a variable
46003	?0 appears twice as a dummy argument
46004	?0 is not a variable or variable structure
46005	RHS of definition must not contain free variables which do not appear
	on the LHS (?0)
=ENDDOC
\subsection{Specification of Constants by Terms}
=DOC
val ‚HOL_axiomatic_recogniser· : string * string * Lex.INPUT list * string
	-> THM;
=DESCRIBE
From the argument (which will be supplied by the reader/writer)
this function will derive a list of varstructs, and a predicate.
These will then be passed to $new\_term\_specification$ (q.v.)
which will attempt the requested specification.
The keys under which the result will be saved are just the names 
of the variables concerned.
=USES
As an interface between the HOL reader/writer and $new\-\_term\-\_speci\-fication$ - it is not intended for
direct use.
It is used to process text of the form
{\makeatletter
\par\@HOLprelim{Example Constant Specification}\@formaltext
\+	decls\\
\crossbar
\+	pred\\
\@endformaltext}

=FAILURE
46010	Input not of right form
46011	Could not parse declarations
46012	Could not parse predicate
=FAILUREC
Errors from $new\_term\_specification$ may also occur: the messages area of origin will not be changed.
=ENDDOC
=THDOC
req_const("Consistent",ª:('a -> BOOL) -> BOOLº);
req_defn("Consistent",([],ªÉ p:'a -> BOOL é Consistent p Ç Ñ x é p xº));
=DESCRIBE
The constant $‚Consistent·$ is used to express the fact that
a predicate is satisfiable.
=ENDDOC
=THDOC
req_const("ConstSpec",ª:('a -> BOOL) -> 'a -> BOOLº);
req_defn("ConstSpec",([],
	ªÉ (p:'a -> BOOL) (c:'a) é 
	ConstSpec p c Ç (Consistent p ä p c)º);
=DESCRIBE
The constant $‚ConstSpec·$ applied to $p$ and $c$ is used to express the fact that
if the predicate $p$ is consistent (see $Consistent$)
then $c$ satisfies the predicate.
=ENDDOC
=THDOC
req_thm("const_spec_thm",([],
	ªÉ (p:'a -> BOOL) é Ñ x : 'a é ConstSpec p xº));
=DESCRIBE
The theorem ``$‚const\_spec\_thm·$'' expresses the fact that 
there always exists something that satisfies $ConstSpec$ applied to any predicate (whether consistent or not).
=ENDDOC
In the following we allow a list of arbitrary variable structures
just for the convenience of calling functions and the user.
A list of variables would be sufficient, pushing pre-processing elsewhere.
=DOC
val ‚new_term_specification· : string list * TERM list * TERM -> THM;
=DESCRIBE
$new\_term\_specification$ $(keys$, $varstructs$, $predicate)$
will declare the constants matching the names and types of those in the
list of varstructs, with the property that, if the predicate
holds for some list of values, then it holds for the constants
in question.
In addition, if the existence prover held in the current proof context, and accessed by $get\_epc\_sp\_existence$, can
prove the predicate is satisfied for some list of variables, the
specification will instead be made without the caveat.

In more detail, if the list of free variables in $varstructs$ is
$x_1$ $...$ $x_n$, and the predicate is of the form $P[$ $x_1$ $...$ $x_n$ $]:BOOL$, then the specification of constants $c_1$ $...$ $c_n$
(with same names and types as the $x_i$)
will be:
Û
Ö ConstSpec (ç (x_1, ..., x_n) é P[x1,...,xn]) (c1,...,cn)
Ê
though if we can automatically prove:
Û
Ñ x1' ... xn' é P[x1',...,xn']
Ê
Then instead the specification will be:
Û
Ö P [c1,...,cn]
Ê
The resulting theorem will be saved under each string of $keys$.

There are a number of caveats on the production of the specification:
there must be no duplicates in the varstructs;
all the constant's types must have the same set of type variables;
there must be no type variables in the body of the predicate other
than those already in the constant's types;
and there must be at least one key.
=SEEALSO
$HOL\_axiomatic\_recogniser$,
$get\_specification$.
=FAILURE
6031	Key list may not be empty
6037	Theory ?0 is locked
6044	Must define at least one constant
6049	There is a constant called ?0 already in scope
6051	Key ?0 has already been used for a definition in theory ?1
6056	?0 contains the free variables: ?1
6061	the body of ?0 contains type variables not found in type
	of constants to be defined, the variables being: ?1
6063	There is a constant called ?0 in the descendants of the current theory
6071	Theory ?0 is a read-only ancestor
6081	Sets of type variables in ?0 and ?1 differ
46013	Variable name ?0 is repeated in varstructs
46018	?0 is not a varstruct
=ENDDOC
=DOC
val ‚get_specification· : string -> THM;
=DESCRIBE
$get\_specification$ $const$ will find the (first) definition in scope
stored under key $Const$, in the theory in which the in-scope constant named $const$ was defined.
If ICL conventions have been followed, then such a definition should be the definition of the constant named $const$.
In addition, there can only be one definition of a particular constant in scope (though the conventional key might be used elsewhere, or not at all).
If there is no such constant in scope, or no definition with the given key, then the function fails.

If the definitional theorem is not of the form 
Û
Ö ConstSpec p c
Ê
then the theorem is returned un-processed - if properly saved then it either comes from
$(simple\_)$ $new\-\_defn$ , $new\-\_speci\-fication$, or predicate $p$ was automatically proven
consistent by $new\-\_term\-\_speci\-fication$.

Otherwise, the function will seek for a theorem stored with key
``$const\-\_consistent$'', starting at the theory in which the definition was found, and working ``out'' to the current theory.
If conventions have been followed this theorem should be of the form:
Û
ˆ Ö Consistent p
Ê
(Ideally there should be no assumptions in the theorem, but
the function caters for their presence.)
If a theorem of this form is found then the function returns:
Û
%beta%_rule `ˆ Ö p c`
Ê
If not, then the function returns a theorem of the form:
Û
%beta%_rule `Consistent p Ö p c`
Ê
=SEEALSO
$push\_consistency\_goal$ to set the appropriate consistency goal, $(ˆ,\ ªConsistent\ pº)$, for a given constant name.
=FAILURE
46014	There is no constant with name ?0 in scope
46015	There is no definition with key ?0 in scope
=ENDDOC
\subsection{Supporting the Conventions}
To help follow the conventions on consistency theorems we provide
the following two functions:
=DOC
val ‚push_consistency_goal·: string -> unit;
=DESCRIBE
$push\_consistency\_goal$ $const$ will find the (first) definition in scope
stored under key $const$, in the theory in which the in-scope constant named $const$ was defined.
If ICL conventions have been followed, then such a definition should be the definition of the constant named $const$.
In addition, there can only be one definition of a particular constant in scope (though the conventional key might be used elsewhere, or not at all).
If there is no such constant in scope, or no definition with the given key, then the function fails.

If this finds a definitional theorem of the form:
Û
ˆ Ö ConstSpec (ç vs[x1,...,xn]ép[x1,...,xn]) c
Ê
then it will push onto the stack of subgoals (using $push\_subgoal$, q.v.)
the goal:
Û
(ˆ, ªConsistent (ç vs[x1,...,xn]ép[x1,...,xn])º)
Ê
It will then apply a tactic (that may be undone by $undo$) which
rewrites the goal to precisely:
Û
(ˆ, ªÑ vs[x1,...,xn]ép[x1,...,xn]º)
Ê
If not, the function fails.
=SEEALSO
$save\_consistency\_thm$ to save the result in a conventional manner.
=FAILURE
46014	There is no constant with name ?0 in scope
46015	There is no definition with key ?0 in scope
46016	Definitional theorem ?0 is not of the form: 
	`ˆ Ö ConstSpec (ç vs[x1,...,xn]ép[x1,...,xn]) c`
=ENDDOC
=DOC
val ‚save_consistency_thm· : THM -> unit;
=DESCRIBE
$save\_consistency\_thm$ $thm$ expects $thm$ to be of the form
Û
ˆ Ö Consistent (ç vs[x1,...,xn]ép[x1,...,xn])
Ê
where $vs$ forms a varstruct from the simple variables $x_i$.
If so, the theorem will be saved under the keys
$x1\_consistent$, ..., $xn\_consistent$.

Ideally there should be no assumptions in the theorem, but
the function caters for their presence.
=SEEALSO
$push\_consistency\_goal$ to set a goal suitable for saving with this theorem.
=FAILURE
6037	Theory ?0 is locked
6071	Theory ?0 is a read-only ancestor
46016	?0 is not of the form: `ˆ Ö Consistent (ç vs[x1,...,xn]ép[x1,...,xn])`
46019	Unable to save theorem under any conventional key
=FAILUREC
This function is content to only partially succeed, and thus 
the warning message may be issued:
=FAILURE
46017	unable to save theorem under the following keys: ?0
=ENDDOC
\section{EPILOGUE}
=SML
end; (* of signature ConstantSpecification *)
=TEX
=THSML
diag_string(summarize_td_results ());
=TEX
\appendix
\section{COUNTEREXAMPLES} \label{COUNTEREXAMPLES}
The conditions imposed by the primitive
conservative extension mechanisms.
lead to restrictions on the forms of predicates
allowed in constant specifications. Examples showing the need for these
restrictions are given in this appendix.

The restrictions which are imposed on constant
specifications are that no types appear in the predicate
which do not appear in the type of each new constant
and that the predicate contains no free variables other
than those corresponding to the new constants (this latter
restriction being taken to mean that the universal
closure over any such variables is used if necessary).

To understand the restrictions on the types consider
the following:
{\makeatletter
\par\@HOLprelim{Example of Restriction on Types in Constant Specification}\@formaltext
\+	c\,:\,bool,\\
\crossbar
\+	c\,Ç\,(Ñx\,y:*éå(x\,=\,y)\\
\@endformaltext}

If this were allowed, then there would be no
difficulty in proving the consistency proposition and
the defining theorem resulting would be:
Û{Example Defining Theorem}
Ö	c Ç (Ñx y:*éå(x = y)
Ê
By instantiating ``$:*$'' to the one element type ``$:one$'
and the two element type ``$:bool$'', we could
could infer the following theorems
Û{Example Theorems}
Ö	c Ç (Ñx y:oneéå(x = y)
Ö	c Ç F
Ö	åc
Ê
and 
Û{Example Theorems}
Ö	c Ç (Ñx y:booléå(x = y)
Ö	c Ç T
Ö	c
Ê
Thus the resulting theory is inconsistent.

To understand the restrictions on the free variables consider
the following:
{\makeatletter
\par\@HOLprelim{Example of Restriction on Types in Constant Specification}\@formaltext
\+	d\,:\,bool,\\
\crossbar
\+	d Ç x\\
\@endformaltext}

(where x is a variable). Again the consistency
proposition would be easy to prove and this would lead to the following
defining theorem:
Û{Example Defining Theorem}
Ö	d Ç x
Ê
By instantiating $x$ here to $T$ and then $F$ we may
derive the contradictory theorems:
Û{Example Theorems}
Ö	d
Ö	åd
Ê
and again we have an inconsistent theory.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
