=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design for Tactics I}
\TPPref{DS/FMU/IED/DTD009}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthors{R.D.~Arthan & WIN01 \\ K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
first group of tactics and tacticals in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue \SCCSversion (\FormatDate{$Date$%
})]
Draft issue for comment after shipping out less basic material to
\cite{DS/FMU/IED/DTD028} and adding treatment of theorem tacticals etc.
\end{description}
\subsection{Changes forecast}
When more advanced tactics have been coded, there may well be a requirement
for more (or different) utilities.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the first group of tactics
and tacticals.
This is called for in \cite{DS/FMU/IED/HLD009}.
The design is implemented in \cite{DS/FMU/IED/IMP009}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
first group of tactics and tacticals for ICL HOL.
This first group is mainly concerned with supplying facilities
for constructing the tactics which the interactive user uses.

\subsubsection{Dependencies}
This document depends on the type definitions in \cite{DS/FMU/IED/DTD006}.
The implementation is dependent on the derived rules of
inference in \cite{DS/FMU/IED/IMP007}.

\subsubsection{Deficiencies}
None known.

\pagebreak
\section{GENERAL REMARKS}
\subsection{Terminology}
A {\em tactic} is a function which attempts to prove a goal. Here a {\em goal} is
just a sequent. Given a goal of a form which it finds acceptable, a tactic
returns a list of new goals (often referred to as
the {\em subgoals}), together with a {\em proof}, i.e. a function
value which given theorems achieving the subgoals can compute a theorem
matching the original goal. Here, roughly speaking,
a theorem, $\Gamma…t$, {\em achieves} a goal, $gl$,
iff. $gl = (\Gamma, t)$ (see section \ref{OnUsingTactics} below for
more information).

A {\em tactical} is a function which composes one or more tactics in
some way (e.g. by repetition until failure) to produce a new tactic.

By a minor abuse of terminology the term tactic is frequently used to
describe a function which takes one or more arguments which are not tactics
and computes a tactic. 
A very common form of tactic in this broader sense is a
{\em theorem tactic}, i.e., a function which takes a theorem and returns
a tactic.
{\em Theorem tacticals} are functions which compose one or more
theorem tactics in some way to produce a new theorem tactic.
{\em Theorem tactical combinators} are functions which produce
new theorem tacticals from old.

\subsection{On Using Tactics}\label{OnUsingTactics}
In the previous section we said that a theorem $\Gamma…t$,
achieves a goal, $gl$, iff. $gl = (\Gamma, t)$. In fact, there would be
a significant performance cost if tactics were required to achieve goals
in this strict sense. Instead, the theorem, $\Gamma…t$, is actually taken to
achieve a goal, $(asms, conc)$, if $\Gamma\subseteq asms$ and $t = conc$
modulo $\alpha$-conversion. Thus, the theorem proved by a tactical proof
of a given goal may require a certain amount of additional inferences (
$\alpha$-conversions and addition of assumptions) to give a theorem which
achieves the goal in the strict sense.

Both the subgoal package and
the utility $tac\_proof$ (which is used for non-interactive tactical proofs) take
the necessary measures to give the user the theorem he asked for.

\subsection{Treatment of Assumptions}

The general policy to be adopted in tactics which add new assumptions is
that the new assumptions are always to be added at the head of the list
even if this gives rise to duplicated assumptions (modulo $\alpha$-convertibility).
This helps the interactive user manage the assumption list as a stack or an array
without having to predict the effect of a given tactic.
Tactics should not assume
that the assumptions in a goal are all distinct,
e.g. tactics which remove assumptions
should remove all instances of the assumptions to be removed.

Some tacticals must assume that their tactic arguments generate proofs which
are not sensitive to the presence of additional assumptions in the theorems
presented to them as arguments. All proofs generated by ICL-supplied tactics
will have this property (which is easily effected by avoiding use of rules
which do global operations on the assumption lists).

\section{INFIX DIRECTIVES}
A Standard ML $infix$ directive must be given at the ``top level''.
Thus we give the directives here for those functions declared in the following signatures.
=SML
infix 4 THEN_T;
infix 4 THEN;
infix 4 THEN_LIST_T;
infix 4 THEN_LIST;
infix 4 ORELSE_T;
infix 4 ORELSE;
infix 4 THEN_TTCL;
infix 4 ORELSE_TTCL;
=TEX
\section{PREAMBLE}
=DOC
signature âTactics1á = sig
=DESCRIBE
This provides the first group of tactics and tacticals in ICL HOL.
=ENDDOC
\section{UTILITIES}
This document exports several utilities which are of use in constructing other
tactics:
=DOC
val âmapshapeá : (('a list -> 'b) * int) list -> 'a list -> 'b list
=DESCRIBE
$mapshape$ is a means of composing functions on lists.
It is intended for composing the proofs produced by tactics
in tacticals such as $THEN$.
Its effect is as follows:
ó
		mapshape [(f1, n1), (f2, n2)... ] [a1, a2, ...]
	=	[f1[a1, ..., a(n1)], f2[a(n1+1), ..., a(n1+n2)], ...]
æ
where, if there are not enough $a_i$, then unused $f_j$ are ignored and the
last $f_j$ to be used may receive less than $n_j$ elements in its argument.
(This case is not expected to occur in the application of mapshape
in tactic programming.)
=USES
Specialised low-level tactic programming.
=ENDDOC
=DOC
val âbad_proofá : string -> 'a
=DESCRIBE
$bad\_proof\,name$ is equivalent to $error\,name\,9001\,[]$.
$bad\_proof$ is for use in low level tactical programming to report
the error situation when the proof generated by a tactic is supplied with
the wrong number of arguments.
(This will not happen for the usual use of tactics with $tac\_proof$ or
within the subgoal package):
=FAILURE
9001	the proof of the subgoals has produced the wrong number of theorems
=USES
Specialised low-level tactic programming.
=ENDDOC

\section{TYPE ABBREVIATIONS}
=DOC
type GOAL		(*	=	SEQ	*);
type PROOF		(*	=	THM list -> THM *);
type TACTIC		(*	=	GOAL -> (GOAL list * PROOF) *);
=DESCRIBE
$TACTIC$ is the type of tactics.
=ENDDOC
=ENDDOC
\section{ELEMENTARY TACTICALS}
In this section we define the most commonly used functions for composing
tactics. 

(Errors in this section begin with 91.)
=DOC
val âTHEN_Tá : (TACTIC * TACTIC) -> TACTIC;
val âTHENá : (TACTIC * TACTIC) -> TACTIC;
=DESCRIBE
$THEN\_T$ is a tactical used as an infix operator.
$tac1$ $THEN\_T$ $tac2$ is the tactic that applies $tac1$
and then applies $tac2$ to each resulting subgoal (perhaps none).
$THEN$ is an alias for $THEN\_T$.
=FAILUREC
\paragraph{Errors}
As the errors of $tac1$ and $tac2$.
=ENDDOC
($THEN$ in Cambridge HOL)
=DOC
val âEVERY_Tá : TACTIC list -> TACTIC;
val âEVERYá : TACTIC list -> TACTIC;
=DESCRIBE
$EVERY_T\_T$ $tlist$ is a tactic that applies the head of $tlist$ to its subgoal, and
recursively applies the tail of $tlist$ to each resulting subgoal.
$EVERY$ is an alias for $EVERY_T\_T$.
=EXAMPLE
ó
EVERY [ƒ_tac, €_tac, ƒ_tac] 
	is equivalent to
ƒ_tac THEN €_tac THEN ƒ_tac
æ
=FAILUREC
\paragraph{Errors}
As for the tactics in the list.
=ENDDOC
=DOC
val âTHEN_LIST_Tá : (TACTIC * TACTIC list) -> TACTIC;
val âTHEN_LISTá : (TACTIC * TACTIC list) -> TACTIC;
=DESCRIBE
$THEN\_LIST\_T$ is a tactical used as an infix operator.
$tac$ $THEN\_LIST\_T$ $tlist$ is a tactic that applies $tac$, and
then applies the first member of $tlist$ to the first resulting subgoal, the second to the second, etc.
If there are not the correct number of tactics in the list then an error will be raised.
$THEN\_LIST$ is an alias for $THEN\_LIST\_T$.
=FAILURE
9101	number of tactics must equal number of subgoals
=FAILUREC
\paragraph{Errors}

As failures of the initial tactic or the tactics in the list.
=ENDDOC
($THENL$ in Cambridge HOL)
This could instead give a warning if the number of subgoals and
tactics differ, using $always\_tac$ if there is no corresponding tactic, 
and ignoring excess tactics.
=DOC
val âMAP_EVERY_Tá : ( 'a -> TACTIC) -> 'a list -> TACTIC;
val âMAP_EVERYá : ( 'a -> TACTIC) -> 'a list -> TACTIC;
=DESCRIBE
$MAP\_EVERY\_T$ $mapf$ $alist$ maps $mapf$ over $alist$,
and then applies the resulting list of tactics to the goal
in sequence (in the same manner as $EVERY$, q.v.).
$MAP\_EVERY$ is an alias for $MAP\_EVERY\_T$.
=FAILUREC
\paragraph{Errors}
As the individual items generated by mapping the tactic over the
list.
=ENDDOC

=DOC
val âORELSE_Tá : (TACTIC * TACTIC) -> TACTIC;
val âORELSEá : (TACTIC * TACTIC) -> TACTIC;
=DESCRIBE
$ORELSE\_T$ is a tactical used as an infix operator.
$tac1$ $ORELSE\_T$ $tac2$ is the tactic that attempts to apply $tac1$.
If this fails then the tactic attempts to apply $tac2$.
If this also fails, then the tactic fails.
If either application attempt succeeds, then the result will be the
result of the tactic.
$ORELSE$ is an alias for $ORELSE\_T$
=SEEALSO
$LIST\_ORELSE\_T$
=FAILUREC
\paragraph{Errors}
As the failure of $tac2$.
=ENDDOC
=DOC
val âFIRST_Tá : TACTIC list -> TACTIC;
val âFIRSTá : TACTIC list -> TACTIC;
=DESCRIBE
$FIRST\_T$ $tlist$ is a tactic that attempts to apply each tactics in $tlist$ until one succeeds, or all fail.
The first successful application will be the result of the tactic,
and it fails if all the attempts fail.
$FIRST$ is an alias for $FIRST\_T$.
=SEEALSO

=FAILURE
9005	the list of tactics is empty
=FAILUREC
Also as the failure of last member of a non-empty list.
=ENDDOC
($FIRST$ in Cambridge HOL)
=DOC
val âMAP_FIRST_Tá : ('a -> TACTIC) -> 'a list -> TACTIC;
val âMAP_FIRSTá : ('a -> TACTIC) -> 'a list -> TACTIC;
=DESCRIBE
$MAP\_FIRST\_T$ $mapf$ $alist$ maps $mapf$ over $alist$,
and then attempts to apply each resulting tactic in order, until
one succeeds or all fail
(in the same manner as $FIRST$, q.v.).
$MAP\_FIRST$ is an alias for $MAP\_FIRST\_T$.
=FAILUREC
\paragraph{Errors}
As the last tactic.
=ENDDOC
($MAP\_FIRST$ in Cambridge HOL)
=DOC
val âREPEAT_Tá : TACTIC -> TACTIC;
val âREPEATá : TACTIC -> TACTIC;
=DESCRIBE
$REPEAT\_T$ is a tactical which repeatedly applies its tactic argument
until it fails.
This may cause an infinite loop of evaluation, or even no change,
if the tactic fails on the first application.
$REPEAT$ is an alias for $REPEAT\_T$.
=ENDDOC
($REPEAT$ in Cambridge HOL)
=DOC
val âREPEAT_N_Tá : int -> TACTIC -> TACTIC;
val âREPEAT_Ná : int -> TACTIC -> TACTIC;
=DESCRIBE
$REPEAT\_N\_T\,n$ is a tactical which repeatedly applies its tactic argument
$n$ times. Unlike $REPEAT$ it fails if the tactic fails.
If $n$ is not greater than 0 then $REPEAT\_N\_T\,n\,tac$ is a tactic which
has no effect.

$REPEAT\_N$ is an alias for $REPEAT\_N\_T$.
=FAILUREC
\paragraph{Errors} As for the tactic being repeated.
=ENDDOC
=TEX
\section{BASIC THEOREM TACTICALS AND COMBINATORS}

(Errors in this section begin with 94.)
=DOC
type âTHM_TACTICá		(*	= THM -> TACTIC			*);

type âTHM_TACTICALá	(*	= THM_TACTIC -> THM_TACTIC	*);
=DESCRIBE
These are the types of theorem tactics and theorem tacticals.
=ENDDOC
=DOC
val âTHEN_TTCLá : (THM_TACTICAL * THM_TACTICAL) -> THM_TACTICAL;
=DESCRIBE
$THEN\_TTCL$ is a theorem tactical combinator. It is an infix operator
which composes two theorem tacticals using ordinary function composition:
ó
(tcl1 THEN_TTCL tcl2) thmtac thm = (tcl1(tcl2 thmtac)) thm
æ
=USES
For use in programming theorem tacticals.
=ENDDOC
=DOC
val âORELSE_TTCLá : (THM_TACTICAL * THM_TACTICAL) -> THM_TACTICAL;
=DESCRIBE
$ORELSE\_TTCL$ is a theorem tactical combinator. It is an infix operator.
$(tcl1\,ORELSE\_TTCL\,tcl2)th$ is $tcl1\,th$ unless evaluation of
$tcl1\,th$ fails, in which case it is $tcl2\,th$.
=USES
For use in programming theorem tacticals.
=ENDDOC
=DOC
val âalways_ttclá : THM_TACTICAL;
=DESCRIBE
This is the identity for the theorem tactical combinator $THEN\_TTCL$.
ó
(always_ttcl) thmtac = thmtac
æ
=USES
For use in programming theorem tacticals.
=ENDDOC
=DOC
val âfail_ttclá : THM_TACTICAL;
=DESCRIBE
This is a theorem tactical which always fails. It acts as the identity
for the theorem tactical combinator $ORELSE\_TTCL$.
=USES
For use in programming theorem tacticals.
=FAILURE
9401	failed as requested
=ENDDOC
=DOC
val âfail_with_ttclá : string -> int -> (unit -> string) list -> THM_TACTICAL;
=DESCRIBE
$fail\_with\_ttcl\,area\,msg\,inserts$
is a theorem tactical that always fails, reporting an error message via the
call $fail\,area\,msg\,inserts$.
=USES
For constructing larger theorem tacticals.
=SEEALSO
$fail$
=FAILUREC
\paragraph{Errors}
As determined by the arguments.
=ENDDOC
=DOC
val âREPEAT_TTCLá : THM_TACTICAL -> THM_TACTICAL;
=DESCRIBE
$REPEAT\_TTCL\,ttcl$ is a theorem tactical which applies $ttcl$
repeatedly until it fails.
=USES
For use in programming theorem tacticals.
=FAILUREC
As for the argument theorem tactic.
=ENDDOC
=DOC
val âEVERY_TTCLá : THM_TACTICAL list -> THM_TACTICAL;
=DESCRIBE
$EVERY\_TTCL$ is a theorem tactical combinator.
ó
EVERY_TTCL [ttcl1, ttcl2, ...] = ttcl1 THEN_TTCL ttcl2 THEN_TTCL ...
æ
=USES
For use in programming theorem tacticals.
=FAILURE
9402	the list of theorem tactics is empty
=ENDDOC
=DOC
val âFIRST_TTCLá : THM_TACTICAL list -> THM_TACTICAL;
=DESCRIBE
$FIRST\_TTCL$ is a theorem tactical combinator.
ó
FIRST_TTCL [ttcl1, ttcl2, ...] = ttcl1 ORELSE_TTCL ttcl2 ORELSE_TTCL ...
æ
=USES
For use in programming theorem tacticals.
=FAILURE
9402	the list of theorem tactics is empty
=ENDDOC
\section{BASIC TACTICS}
(Errors in this section begin with 92.)
=DOC
val âalways_tacá : TACTIC;
=DESCIRBE
A tactic that always succeeds, having no effect.
This is the identity for the tactical $THEN\_T$.
=TACTIC
always_tac
É
{ ö } t
É
{ ö } t
=TEX
=USES
For constructing larger tactics.
=ENDDOC
($ALL\_TAC$ in Cambridge HOL)
=DOC
val âfail_tacá : TACTIC;
=DESCRIBE
A tactic that always fails.
This is the identity for the tactical $ORELSE\_T$
=USES
For constructing larger tactics.
=FAILURE
9201	failed as requested
=ENDDOC
($NO\_TAC$ in Cambridge HOL)
=DOC
val âfail_with_tacá : string -> int -> (unit -> string) list -> TACTIC;
=DESCRIBE
$fail\_with\_tac\,area\,msg\,inserts$
is a tactic that always fails, reporting an error message via the
call $fail\,area\,msg\,inserts$.
=USES
For constructing larger tactics.
=SEEALSO
$fail$
=FAILUREC
\paragraph{Errors}
As determined by the arguments.
=ENDDOC
($FAIL\_TAC$ in Cambridge HOL)
=DOC
val âaccept_tacá : THM -> TACTIC;
=DESCRIBE
Prove a goal by a theorem which is $\alpha$-convertible to it.
=TACTIC
accept_tac
ö1 … t1
É
{ ö2 } t2
É
=TEX
where the theorem is $\alpha$-convertible to $ö1' … t2$.
=FAILURE
9102	the theorem is not alpha-convertible to the goal
=ENDDOC

=DOC
val âasm_tacá : THM -> TACTIC;
=DESCRIBE
$asm\_tac\,thm$ is a tactic which adds the conclusion of the theorem, $thm$,
into the assumptions of a goal:
=TACTIC
asm_tac
ö1 … t1
É
{ ö2 } t2
É
{ t1, ö2 } t2
=TEX
=ENDDOC
\section{BASIC TACTICALS}
(Errors in this section begin with 93.)

\subsection{Using Assumptions}
We supply tacticals which give the user several ways of
using assumptions as arguments to tactic generating functions.
The options are which assumptions to select and whether or not
the assumptions are to be removed. The combinations are then as shown
in the following table:

\begin{tabular}{|l|l|l|l|}\hline
 & Select Given Asm.  & Select Top Asm. & Select All Asms. \\ \hline
Remove Asms. & $DROP\_ASM\_T$ & $POP\_ASM\_T$ & $DROP\_ASMS\_T$\\ \hline
Leave Asms. & $GET\_ASM\_T$ & $TOP\_ASM\_T$ & $GET\_ASMS\_T$\\ \hline
\end{tabular}

Note that the tactic generating function
supplied as an argument to the tactical may
elect to remove assumptions of its own accord --- the above table refers
to the assumptions passed to the tactic generating function.

Other options, e.g., selection of a subset of the assumptions, may
be coded in terms of $GET\_ASMS\_T$ by applying a tactic
generating function with an appropriate filtering action.

=DOC
val âGET_ASM_Tá : TERM -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
$GET\_ASM\_T$ $asm$ $thmtac$ is a tactic which checks that $asm$
is in the assumption list and then acts as  $thmtac(asm … asm)$.
=TACTIC
GET_ASM_T
»asm¼
thmtac
É
{ ö, asm' } t
É
thmtac (asm … asm) ({ ö, asm' } t)
=TEX
where $asm$ and $asm'$ are $\alpha$-convertible.
=USES
To use an assumption as a theorem
=FAILURE
9301	the term ?0 is not in the assumption list
=ENDDOC

=DOC
val âDROP_ASM_Tá : TERM -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
$DROP\_ASM\_T$ $asm$ $thmtac$ is a tactic which removes $asm$
from the assumption list and then acts as  $thmtac(asm … asm)$.
=TACTIC
DROP_ASM_T
»asm¼
thmtac
É
{ ö, asm' } t
É
thmtac (asm … asm) ({ ö } t)
=TEX
where $asm$ and $asm'$ are $\alpha$-convertible.
=USES
To use an assumption as a theorem
=FAILURE
9301	the term ?0 is not in the assumption list
=ENDDOC

=DOC
val âTOP_ASM_Tá : (THM -> TACTIC) -> TACTIC;
=DESCRIBE
If the top entry in the assumption list is $asm$ say,
$TOP\_ASM\_T$ $thmtac$ acts as  $thmtac(asm … asm)$.
=TACTIC
TOP_ASM_T
»asm¼
thmtac
É
{ asm, ö } t
É
thmtac (asm … asm) ({ asm, ö } t)
=USES
To use an assumption as a theorem
=FAILURE
9303	the assumption list is empty
=ENDDOC

=DOC
val âPOP_ASM_Tá : (THM -> TACTIC) -> TACTIC;
=DESCRIBE
$POP\_ASM\_T$ $thmtac$ is a tactic which removes the top entry,
$asm$ say, from the assumption list and then acts as  $thmtac(asm … asm)$.
=TACTIC
POP_ASM_T
»asm¼
thmtac
É
{ asm, ö } t
É
thmtac (asm … asm) ({ ö, asm' } t)
=USES
To use an assumption as a theorem
=FAILURE
9303	the assumption list is empty
=ENDDOC

=DOC
val âGET_ASMS_Tá : (THM list -> TACTIC) -> TACTIC;
=DESCRIBE
$GET\_ASMS\_T$ $thmstac$ is a tactic which applies $asm\_rule$ to each assumption
of the goal, giving a list of theorems, $thms$ say,
and then acts as  $thmstac\,thms$.
=TACTIC
GET_ASMS_T
thmstac
É
{ a1, ..., an } t
É
thmstac (map asm_rule [a1,...,an]) ({ ö } t)
=TEX
=USES
To use all the assumptions as theorems.
=FAILUREC
\paragraph{Errors}
As for $thmstac$.
=ENDDOC

=DOC
val âDROP_ASMS_Tá : (THM list -> TACTIC) -> TACTIC;
=DESCRIBE
$DROP\_ASMS\_T$ $thmstac$ is a tactic which applies $asm\_rule$ to each assumption
of the subgoal, giving a list of theorems, $thms$ say, then removes
all the assumptions of the goal
and then acts as  $thmstac\,thms$.
=TACTIC
DROP_ASMS_T
thmstac
É
{ a1, ..., an } t
É
thmstac (map asm_rule [a1,...,an]) ({ ö } t)
=TEX
=USES
To use all the assumptions as theorems.
=FAILUREC
\paragraph{Errors}
As for $thmstac$.
=ENDDOC

\subsection{Utility Tacticals}
In this section we supply some miscellaneous tactics which are useful
in tactic programming and/or in general use.
=DOC
val âROTATE_Tá : int -> TACTIC -> TACTIC;
=DESCRIBE
$ROTATE\_T\,i\,tac$ is a tactic which first applies $tac$ and, if
this does not achieve the goal, rotates
the resulting subgoals by $i$ places. $i$ is taken modulo the number
of subgoals produced by $tac$.

Thus if the result of $tac$ is:
=TACTIC
tac
É
{ ö } t
É
{ ö1 } t1; ... { ök } tk
=TEX
then the result of $ROTATE\_T\,i\,t$ will be:
=TACTIC
ROTATE_T i tac
É
{ ö } t
É
{ ö(i+1) } t(i+1); ..., { ök } tk;
{ ö1 } t1; ... { öi } ti
=TEX
=USES
For use in tactic programming to handle tactics which return their subgoals
in an inconvenient order for the task at hand.
=FAILUREC
\paragraph{Errors}
As for $tac$.
=ENDDOC
=DOC
val âTRY_Tá : TACTIC -> TACTIC;
=DESCRIBE
$TRY_T\,tac$ is a tactic which applies $tac$ to the goal and if that
fails leaves the goal unchanged. It is the same as
$tac\,ORELSE\,always\_tac$.
=ENDDOC

=DOC
val âCHANGED_Tá : TACTIC -> TACTIC;
=DESCRIBE
$CHANGED_T\,tac$ is a tactic which applies $tac$ to the goal and fails
if the new goal is $\alpha-$convertible to the original one.
=USES
$CHANGED\_T$ can be a useful way of ensuring termination of, e.g., rewriting
tactics.
=FAILURE
9302	the tactic did not change the goal
=ENDDOC

=DOC
val âLEMMA_Tá : TERM -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
$LEMMA\_T\,i\,newsg\,thmtac$ is a tactic which sets $newsg$ as a new
subgoal and applies $thmtac (newsg … newsg)$ to the original goal.
=TACTIC
LEMMA_T
newsg thmtac
É
{ ö } t
É
{ ö } newsg;
thmtac(newsg … newsg) ({ ö } t)
=TEX
=USES
For use in tactic programming and in interactive use where $lemma\_tac$
is not appropriate.
=FAILUREC
\paragraph{Errors}
As for $thmtac$.
=SEEALSO
$lemma\_tac$.
=ENDDOC

\section{USING TACTICS}
(Errors in this section start with 95.)
=DOC
val âsimple_tac_proofá : (GOAL * TACTIC) -> THM;
=DESCRIBE
$simple\_tac\_proof(gl, tac)$ applies the tactic $tac$ to the goal $gl$, and, if
the tactic returns no unsolved subgoals returns the theorem proved by
the tactic.

Infelicities in the coding of the tactic may cause the theorem
returned to be different from the specified goal (e.g. it may return
an $alpha$-equivalent theorem).
$tac\_proof$ should be used rather than $simple\_tac\_proof$ if it is important
that this should not happen.
=USES
In programming tactics or other proof procedures where speed is important
and the extra care taken by $tac\_proof$ is not required.
=FAILURE
9501	the tactic returned unsolved subgoals
9502	evaluation of the tactic failed: ?0
9503	the proof returned by the tactic failed: ?0
=SEEALSO
$tac\_proof$
=ENDDOC

=DOC
val âtac_proofá : (GOAL * TACTIC) -> THM;
=DESCRIBE
$tac\_proof(gl, tac)$ applies the tactic $tac$ to the goal $gl$, and, if
the tactic succeeds in proving the goal returns the resulting theorem.

$tac\_proof$ performs $\alpha$-conversion, 
introduces additional assumptions, and reorders assumptions as necessary
to ensure that the theorem returned has the same form as the specified
goal. In circumstances where these adjustments are known not to be necessary, 
$simple\_tac\_proof$ may be used to avoid this overhead.

=USES
The subgoal package is the normal interactive mechanism for developing
tactical proofs. $tac\_proof$ is typically used in
tactic programming and other proof procedures, in cases where it is necessary
to ensure that the correct goal is proved. 
=FAILURE
9501	the tactic returned unsolved subgoals
9502	evaluation of the tactic failed: ?0
9503	the proof returned by the tactic failed: ?0
9504	the proof returned by the tactic proved a theorem which could not be
	converted into the desired goal.
9505	the goal contains alpha-equivalent assumptions (?0 and ?1)
9506	the assumption ?0 is not of type BOOL
9507	the conclusion ?0 is not of type BOOL
=SEEALSO
$simple\_tac\_proof$
=ENDDOC

=TEX
=SML
end; (* of signature Tactics1 *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested according to
the general criteria set out in \cite{DS/FMU/IED/PLN008}.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
