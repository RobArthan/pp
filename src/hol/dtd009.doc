=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design for Tactics I}
\TPPref{DS/FMU/IED/DTD009}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{91/03/11 %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
first group of tactics and tacticals in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
\end{description}
\subsection{Changes forecast}
Most of the text outside the documentation boxes is a discussion
of the design process, rather than being part of the final design.
It will thus be removed or rephrased in later issues.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
derived rules of inference.
This is called for in section ??? of ???.
The high-level specification for the code is
given in ???.
The design is
implemented in \cite{DS/FMU/IED/IMP009}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
first of tactics and tacticals in Release 001 of ICL HOL.
This first group is mainly concerned with supplying facilities
for constructing the tactics which the interactive user uses.

been 
\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.

\subsubsection{Deficiencies}
The design is sometimes vague about the power and order of
some simplifications, when an implementor might wish to know
a precise set of rules.

We do not address the Cambridge HOL functions:
\begin{itemize}
\item $DEF\_RES\_TAC$,
\item $DISCARD\_TAC$,
\item $ASSUM\_LIST$,
$FIRST\_ASSUM$,
\item induction,
\item $RULE\_ASSUM\_TAC$,
\item $STRIP\_GOAL\_THEN$.
\end{itemize}
\subsubsection{Possible Enhancements}
We need to know what ordering and indexing will be available
upon the assumption list, and supply appropriate tactics
for this case.
For instance, the ``last added'' assumption to the assumption list may be
absorbed by some other assumption to which it is $\alpha$-convertible, making it not the head of the assumption list.
This makes the point of Cambridge HOL's $POP\_ASSUM$ and $POP\_ASSUM\_LIST$ tactic
continuations somewhat problematical.
Other ordering approaches may make ``numbered'' assumptions
an unusable concept.

\section{GENERAL REMARKS}
\subsection{Terminology}
A {\em tactic} is a function which attempts to prove a goal. Here a {\em goal} is
just a sequent. Given a goal of a form which it finds acceptable, a tactic
returns a list of new goals (often referred to as
the {\em subgoals}), together with a {\em proof}, i.e. a function
value which given theorems achieving the subgoals can compute a theorem
matching the original goal. (A theorem, $\Gamma…t$, {\em achieves} a goal, $gl$,
iff. $gl = (\Gamma, t)$.)

A {\em tactical} is a function which composes one or more tactics in
some way (e.g. by repetition until failure) to produce a new tactic.

By a minor abuse of terminology the term tactic is frequently used to
describe a function which takes one or more arguments which are not tactics
and computes a tactic. 
A very common form of tactic in this broader sense is a
{\em theorem tactic}, i.e., a function which takes a theorem and returns
a tactic.
{\em Theorem tacticals} are functions which compose one or more
theorem tactics in some way to produce a new theorem tactic.

\subsection{Treatment of Assumptions}

This issue assumes no more than that the assumption list is maintained as a set, with no $\alpha$-convertible assumptions.

All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP009}.

All tactics must maintain their assumption lists free of duplicate
assumptions (including $\alpha$-convertible assumptions).
However, this is not directly mentioned in the statements of individual tactics.

Some tactics take as an argument one or more theorems. In typical use any
assumptions of such theorems would be present as assumptions for the goal
to which the tactic is applied; if this is not the case then the tactics in
question will, by convention, cause the extra assumptions to be introduced
as new subgoals at the end of the list of subgoals which would otherwise
be introduced.
To assist in describing these tactics the notation: 
ó
{ ö } ExtraSG {a1,...,an}
æ
is used is an abbreviation for the subgoals:
ó
{ ö } a1; ... ; { ö } an
æ
Many possible tactics based on inference rules are no more
than rewrites with tautologically true theorems,
and
we do not include these, preferring to recommend the use of
$taut\_tac$ and its cousins.
We will only consider it appropriate to give a tactic if it
provides an effect that could not easily be gained using
$rewrite\_tac$, $taut\_eq\_tac$, $conv\_tac$, $REPEAT\_T$, 
and similar,
or the effect is so commonly desired
that supplying a function is worth while.
Most conversions can be given a satisfactory tactic equivalents by $conv\_tac$, and will not have explicitly named tactics
(only exceptions will be noted).

The phrase ``N.B. loses information.'' in a tactics description
indicates that the tactic strengthens the goal to be proven,
by losing some information that \underline{might} have been necessary
to complete the proof.
This is, of course, a standard proof approach, but it is worth knowing when
such tactics have been used to correctly interpret the state of
having reached an unprovable goal - does it indicate the main
goal unprovable, or just that an incorrect choice of proof has been made.
All information-losing tactics will be noted.
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the ``top level''.
Thus we give the commands here for those functions declared in the following signatures.
=SML
infix 4 THEN_T;
infix 4 THEN;
infix 4 THEN_LIST_T;
infix 4 THEN_L;
infix 4 ORELSE_T;
infix 4 ORELSE;
infix 4 THEN_TTCL;
infix 4 ORELSE_TTCL;
=TEX
(The priorities given are probably not appropriate)
\section{PREAMBLE}
=DOC
signature âTactics1á = sig
=DESCRIBE
This provides the initial group of tactics and tacticals in Release 001 of ICL HOL.
=ENDDOC
\section{UTILITIES}
This document exports several utilities which are of use in constructing other
tactics:
=DOC
val âmapshapeá : (('a list -> 'b) * int) list -> 'a list -> 'b list
=DESCRIBE
$mapshape$ is a means of composing functions on lists.
It is intended for composing the proofs produced by tactics
in tacticals such as $THEN$.
Its effect is as follows:
ó
		mapshape [(f1, n1), (f2, n2)... ] [a1, a2, ...]
	=	[f1[a1, ..., a(n1)], f2[a(n1+1), ..., a(n1+n2)], ...]
æ
where, if there are not enough $a_i$, unused $f_j$ are ignored and the
last $f_j$ to be used may receive a shorter list than specified.
=USES
Specialised low-level tactic programming.
=ENDDOC
=DOC
val âbad_proofá : string -> 'a
=DESCRIBE
$bad\_proof\,name$ is equivalent to $error\,name\,9001\,[]$.
$bad\_proof$ is for use in low level tactical programming to report
the error situation when the proof generated by a tactic is supplied with
the wrong number of arguments.
(This will not happen for the usual use of tactics with $tac\_proof$ or
within the subgoal package):
=FAILURE
9001	the proof of the subgoals has produced the wrong number of theorems
=USES
Specialised low-level tactic programming.
=ENDDOC

\section{TYPE ABBREVIATIONS}
=DOC
type GOAL		(*	=	SEQ	*);
type PROOF		(*	=	THM list -> THM *);
type TACTIC		(*	=	GOAL -> (GOAL list * PROOF) *);
=DESCRIBE
$TACTIC$ is the type of tactics.
=ENDDOC
=ENDDOC
\section{ELEMENTARY TACTICALS}
(Errors in this section begin with 91.)
=DOC
val âTHEN_Tá : (TACTIC * TACTIC) -> TACTIC;
val âTHENá : (TACTIC * TACTIC) -> TACTIC;
=DESCRIBE
$THEN\_T$ is a tactical used as an infix operator.
$tac1$ $THEN\_T$ $tac2$ is the tactic that applies $tac1$
and then applies $tac2$ to each resulting subgoal (perhaps none).
$THEN$ is an alias for $THEN\_T$.
=FAILUREC
\paragraph{Errors}
As the errors of $tac1$ and $tac2$.
=ENDDOC
($THEN$ in Cambridge HOL)
=DOC
val âLIST_THEN_Tá : TACTIC list -> TACTIC;
val âEVERYá : TACTIC list -> TACTIC;
=DESCRIBE
$LIST\_THEN\_T$ $tlist$ is a tactic that applies the head of $tlist$ to its subgoal, and
recursively applies the tail of $tlist$ to each resulting subgoal.
$EVERY$ is an alias for $LIST\_THEN\_T$.
=EXAMPLE
ó
LIST_THEN_T [ƒ_tac, €_tac, ƒ_tac] 
	is equivalent to
ƒ_tac THEN €_tac THEN ƒ_tac
æ
=FAILUREC
\paragraph{Errors}
As for the tactics in the list.
=ENDDOC
=DOC
val âTHEN_LIST_Tá : (TACTIC * TACTIC list) -> TACTIC;
val âTHEN_Lá : (TACTIC * TACTIC list) -> TACTIC;
=DESCRIBE
$THEN\_LIST\_T$ is a tactical used as an infix operator.
$tac$ $THEN\_LIST\_T$ $tlist$ is a tactic that applies $tac$, and
then applies the first member of $tlist$ to the first resulting subgoal, the second to the second, etc.
If there are not the correct number of tactics in the list then an error will be raised.
$THEN\_L$ is an alias for $THEN\_LIST\_T$.
=FAILURE
9101	Number of tactics must equal number of subgoals
=FAILUREC
As failures of the initial tactic or the tactics in the list.
=ENDDOC
($THENL$ in Cambridge HOL)
This could instead give a warning if the number of subgoals and
tactics differ, using $always\_tac$ if there is no corresponding tactic, 
and ignoring excess tactics.
=DOC
val âMAP_THEN_Tá : ( 'a -> TACTIC) -> 'a list -> TACTIC;
val âMAP_EVERYá : ( 'a -> TACTIC) -> 'a list -> TACTIC;
=DESCRIBE
$MAP\_THEN\_T$ $mapf$ $alist$ maps $mapf$ over $alist$,
and then applies the resulting list of tactics to the goal
in sequence (in the same manner as $LIST\_THEN\_T$, q.v.).
$MAP\_EVERY$ is an alias for $MAP\_THEN\_T$.
=FAILUREC
\paragraph{Errors}
As the individual items generated by mapping the tactic over the
list.
=ENDDOC
($MAP\_EVERY$ in Cambridge HOL)
=DOC
val âORELSE_Tá : (TACTIC * TACTIC) -> TACTIC;
val âORELSEá : (TACTIC * TACTIC) -> TACTIC;
=DESCRIBE
$ORELSE\_T$ is a tactical used as an infix operator.
$tac1$ $ORELSE\_T$ $tac2$ is the tactic that attempts to apply $tac1$.
If this fails then the tactic attempts to apply $tac2$.
If this also fails, then the tactic fails.
If either application attempt succeeds, then the result will be the
result of the tactic.
$ORELSE$ is an alias for $ORELSE\_T$
=SEEALSO
$LIST\_ORELSE\_T$
=FAILUREC
\paragraph{Errors}
As the failure of $tac2$.
=ENDDOC
=DOC
val âLIST_ORELSE_Tá : TACTIC list -> TACTIC;
val âFIRSTá : TACTIC list -> TACTIC;
=DESCRIBE
$LIST\_ORELSE\_T$ $tlist$ is a tactic that attempts to apply each tactics in $tlist$ until one succeeds, or all fail.
The first successful application will be the result of the tactic,
and it fails if all the attempts fail.
$FIRST$ is an alias for $LIST\_ORELSE\_T$.
=SEEALSO
$LIST\_MAP\_ORELSE\_T$
=FAILURE
9005	List of tactics is empty
=FAILUREC
Also as the failure of last member of a non-empty list.
=ENDDOC
($FIRST$ in Cambridge HOL)
=DOC
val âMAP_ORELSE_Tá : ('a -> TACTIC) -> 'a list -> TACTIC;
val âMAP_FIRSTá : ('a -> TACTIC) -> 'a list -> TACTIC;
=DESCRIBE
$MAP\_ORELSE\_T$ $mapf$ $alist$ maps $mapf$ over $alist$,
and then attempts to apply each resulting tactic in order, until
one succeeds or all fail
(in the same manner as $LIST\_ORELSE\_T$, q.v.).
$MAP\_FIRST$ is an alias for $MAP\_ORELSE\_T$.
=FAILUREC
\paragraph{Errors}
As the last tactic.
=ENDDOC
($MAP\_FIRST$ in Cambridge HOL)
=DOC
val âREPEAT_Tá : TACTIC -> TACTIC;
val âREPEATá : TACTIC -> TACTIC;
=DESCRIBE
$REPEAT\_T$ is a tactical that applies its tactic argument
until it fails.
This may cause an infinite loop of evaluation, or even no change,
if the tactic fails on the first application.
$REPEAT$ is an alias for $REPEAT\_T$.
=ENDDOC
($REPEAT$ in Cambridge HOL)
=TEX
\section{BASIC THEOREM TACTICALS AND COMBINATORS}
(Errors in this section begin with 94.)
=DOC
type âTHM_TACTICá	(*	= THM -> TACTIC			*);

type âTHM_TACTICALá	(*	= THM_TACTIC -> THM_TACTIC	*);
=DESCRIBE
These are the types of theorem tactics and theorem tacticals.
=ENDDOC
=DOC
val âTHEN_TTCLá : (THM_TACTICAL * THM_TACTICAL) -> THM_TACTICAL;
=DESCRIBE
$THEN\_TTCL$ is a theorem tactical combinator. It is an infix operator
which composes two theorem tacticals using ordinary function composition:
ó
(tcl1 THEN_TTCL tcl2) thmtac thm = (tcl1(tcl2 thmtac)) thm
æ
=USES
For use in programming theorem tacticals.
=ENDDOC
=DOC
val âORELSE_TTCLá : (THM_TACTICAL * THM_TACTICAL) -> THM_TACTICAL;
=DESCRIBE
$ORELSE\_TTCL$ is a theorem tactical combinator. It is an infix operator.
$(tcl1\,ORELSE\_TTCL\,tcl2)th$ is $tcl1\,th$ unless evaluation of
$tcl1\,th$ fails, in which case it is $tcl2\,th$.
=USES
For use in programming theorem tacticals.
=ENDDOC
=DOC
val âalways_ttclá : THM_TACTICAL;
=DESCRIBE
This is the identity for the theorem tactical combinator $THEN\_TTCL$.
ó
(always_ttcl) thmtac = thmtac
æ
=USES
For use in programming theorem tacticals.
=ENDDOC
=DOC
val âfail_ttclá : THM_TACTICAL;
=DESCRIBE
This is a theorem tactical which always fails. It acts as the identity
for the theorem tactical combinator $ORELSE\_TTCL$.
=USES
For use in programming theorem tacticals.
=FAILURE
9401	Failed as requested
=ENDDOC
=DOC
val âfail_with_ttclá : string -> int -> (unit -> string) list -> THM_TACTICAL;
=DESCRIBE
$fail\_with\_ttcl\,area\,msg\,inserts$
is a theorem tactical that always fails, reporting an error message via the
call $fail\,area\,msg\,inserts$.
=USES
For constructing larger theorem tacticals.
=SEEALSO
$fail$
=FAILUREC
\paragraph{Errors}
As determined by the arguments.
=ENDDOC
=DOC
val âREPEAT_TTCLá : THM_TACTICAL -> THM_TACTICAL;
=DESCRIBE
$REPEAT\_TTCL\,ttcl$ is a theorem tactical which applies $ttcl$
repeatedly until it fails.
=USES
For use in programming theorem tacticals.
=FAILUREC
As for the argument theorem tactic.
=ENDDOC
=DOC
val âEVERY_TTCLá : THM_TACTICAL list -> THM_TACTICAL;
=DESCRIBE
$EVERY\_TTCL$ is a theorem tactical combinator.
ó
$EVERY_TTCL [ttcl1, ttcl2, ...] = ttcl1 THEN_TTCL ttcl2 THEN_TTCL ...
æ
=USES
For use in programming theorem tacticals.
=FAILURE
9402	the list of theorem tactics is empty
=ENDDOC
=DOC
val âFIRST_TTCLá : THM_TACTICAL list -> THM_TACTICAL;
=DESCRIBE
$FIRST\_TTCL$ is a theorem tactical combinator.
ó
$FIRST_TTCL [ttcl1, ttcl2, ...] = ttcl1 ORELSE_TTCL ttcl2 ORELSE_TTCL ...
æ
=USES
For use in programming theorem tacticals.
=FAILURE
9402	the list of theorem tactics is empty
=ENDDOC
\section{BASIC TACTICS}
(Errors in this section begin with 92.)
=DOC
val âalways_tacá : TACTIC;
=DESCIRBE
A tactic that always succeeds, having no effect.
This is the identity for the tactical $THEN\_T$.
=TACTIC
always_tac
É
{ ö } t
É
{ ö } t
=TEX
=USES
For constructing larger tactics.
=ENDDOC
($ALL\_TAC$ in Cambridge HOL)
=DOC
val âfail_tacá : TACTIC;
=DESCRIBE
A tactic that always fails.
This is the identity for the tactical $ORELSE\_T$
=USES
For constructing larger tactics.
=FAILURE
9201	Failed as requested
=ENDDOC
($NO\_TAC$ in Cambridge HOL)
=DOC
val âfail_with_tacá : string -> int -> (unit -> string) list -> TACTIC;
=DESCRIBE
$fail\_with\_tac\,area\,msg\,inserts$
is a tactic that always fails, reporting an error message via the
call $fail\,area\,msg\,inserts$.
=USES
For constructing larger tactics.
=SEEALSO
$fail$
=FAILUREC
\paragraph{Errors}
As determined by the arguments.
=ENDDOC
($FAIL\_TAC$ in Cambridge HOL)
=DOC
val âaccept_tacá : THM -> TACTIC;
=DESCRIBE
Prove a subgoal by a theorem which is $\alpha$-convertible to it.
=TACTIC
accept_tac
ö1 … t1
É
{ ö2 } t2
É
{ ö2 } ExtraSG { ö1' \ ö2 }
=TEX
where the theorem is $\alpha$-convertible
to $ö1' … t1'$ so that $t1'$ equals $t2$ and the hypotheses $ö1'$ are
contained in the assumptions of the goal.
=FAILURE
9102	the theorem is not alpha-convertible to the goal
=ENDDOC
($ACCEPT\_TAC$ in Cambridge HOL)
\section{UTILITY TACTICALS}
This section contains tacticals which are of general utility in tactical
programming.

(Errors in this section begin with 93.)

=DOC
val âMAP_ASM_Tá : (THM list -> TACTIC) -> TACTIC;
=DESCRIBE
$MAP\_CHECK\_ASM_T$ $thmstac$ applies $asm\_rule$ to each assumption
of the subgoal, and returns the tactic obtained by
applying $thmstac$ to the resulting list of theorems.
=TACTIC
MAP_ASM_T
thmstac
É
{ a1, ..., an } t
É
thmstac (map asm_rule [a1,...,an]) ({ ö } t)
=TEX
=FAILUREC
\paragraph{Errors}
As for $thmstac$.
=ENDDOC
=DOC
val âROTATE_Tá : int -> TACTIC -> TACTIC;
=DESCRIBE
$ROTATE\_T\,i\,tac$ is a tactic which first applies $tac$ and, if
this does not achieve the goal, rotates
the resulting subgoals by $i$ places. $i$ is taken modulo the number
of subgoals produced by $tac$.

Thus if the result of $tac$ is:
=TACTIC
tac
É
{ ö } t
É
{ ö1 } t1; ... { ök } tk
=TEX
then the result of $ROTATE\_T\,i\,t$ will be:
=TACTIC
ROTATE_T i tac
É
{ ö } t
É
{ ö(i+1) } t(i+1); ..., { ök } tk;
{ ö1 } t1; ... { öi } ti
=TEX
=FAILUREC
\paragraph{Errors}
As for $tac$.
=ENDDOC
=DOC
val âCHECK_THM_Tá : THM -> TACTIC -> TACTIC;
=DESCRIBE
$CHECK\_THM\_T$ is a tactical for use in coding tactics which use a theorem.
It is used to ensure that the theorem may validly be used with the goal.

$CHECK\_THM\_T\,thms\,tac$ is the same as $tac$ on goals
whose assumptions include the assumptions of the theorems $thm$.
If $thm$ has assumptions which are not present in
the goal, these extra assumptions are introduced as additional subgoals (to 
be proved after the ``main'' subgoals introduced by $tac$).
=SEEALSO
$LIST\_CHECK\_THM\_T$
=ENDDOC
=DOC
val âLIST_CHECK_THM_Tá : THM list -> TACTIC -> TACTIC;
=DESCRIBE
$LIST\_CHECK\_THM\_T$ is intended to be used in coding tactics which use theorems.
$LIST\_CHECK\_THM\_T\,thms\,tac$ is the same as $tac$ on goals
whose assumptions include the assumptions of all the theorems $thms$.
If $thms$ contains theorems with assumptions which are not present in
the goal, these extra assumptions are introduced as additional subgoals (to 
be proved after the ``main'' subgoals introduced by $tac$).
=SEEALSO
$CHECK\_THM\_T$
=ENDDOC
=DOC
val âTRY_Tá : TACTIC -> TACTIC;
=DESCRIBE
$TRY_T\,tac$ is a tactic which applies $tac$ to the goal and if that
fails leaves the goal unchanged. It is the same as
$tac\,ORELSE\,always\_tac$.
=ENDDOC
=DOC
val âCHANGED_Tá : TACTIC -> TACTIC;
=DESCRIBE
$CHANGED_T\,tac$ is a tactic which applies $tac$ to the goal and fails
if the new goal is $\alpha-$convertible to the original one.
=FAILURE
9302	the tactic did not change the goal
=ENDDOC
=DOC
val âCHECK_ASM_Tá : TERM -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
$CHECK\_ASM\_T$ $asm$ $thmtac$ is a tactic which checks that $asm$
is in the assumption list and then applies $asm\_rule$ to it.
The tactic returned is $thmtac(asm … asm)$ (i.e. $thmtac$ applied
to $asm\_rule\,asm$).
=TACTIC
CHECK_ASM_T
»asm¼
thmtac
É
{ ö, asm' } t
É
thmtac (asm … asm) ({ ö, asm' } t)
=TEX
where $asm$ and $asm'$ are $\alpha$-convertible.
=USES
To use an assumption as a theorem
=FAILURE
9301	The term ?0 is not in the assumption list
=FAILUREC
Also failure messages from $thmtac$.
=ENDDOC
=DOC
val âLEMMA_Tá : TERM -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
$LEMMA\_T\,i\,newsg\,thmtac$ is a tactic which sets $newsg$ as a new
subgoal and applies $thmtac (newsg … newsg)$ to the original goal.

=TACTIC
LEMMA_T
newsg thmtac
É
{ ö } t
É
{ ö } newsg;
thmtac(newsg … newsg) ({ ö } t)
=TEX
=FAILUREC
\paragraph{Errors}
As for $thmtac$.
=ENDDOC
\section{USING TACTICS}
(Errors in this section start with 95.)
=DOC
val âsimple_tac_proofá : (GOAL * TACTIC) -> THM;
=DESCRIBE
$simple\_tac\_proof(gl, tac)$ applies the tactic $tac$ to the goal $gl$, and, if
the tactic returns no unsolved subgoals returns the theorem proved by
the tactic.

Infelicities in the coding of the tactic may cause the theorem
returned to be different from the specified goal (e.g. it may return
an $alpha$-equivalent theorem).
$tac\_proof$ should be used rather than $simple\_tac\_proof$ if it is important
that this should not happen.
=FAILURE
9501	the tactic returned unsolved subgoals
9502	evaluation of the tactic failed: ?0
9503	the proof returned by the tactic failed: ?0
=ENDDOC
=DOC
val âtac_proofá : (GOAL * TACTIC) -> THM;
=DESCRIBE
$tac\_proof(gl, tac)$ applies the tactic $tac$ to the goal $gl$, and, if
the tactic succeeds in proving the goal returns the resulting theorem.

$tac\_proof$ performs $\alpha$-conversion, 
introduces additional assumptions, and reorders assumptions as necessary
to ensure that the theorem returned has the same form as the specified
goal. In circumstances where these adjustments are known not to be necessary, 
$simple\_tac\_proof$ may be used to avoid this overhead.
=FAILURE
9501	the tactic returned unsolved subgoals
9502	evaluation of the tactic failed: ?0
9503	the proof returned by the tactic failed: ?0
9504	the proof returned by the tactic proved a theorem which could not be
	converted into the desired goal.
9505	the goal contains alpha-equivalent assumptions (?0 and ?1)
9506	the assumption ?0 is not of type BOOL
9507	the conclusion ?0 is not of type BOOL
=ENDDOC

=TEX
=SML
end; (* of signature Tactics1 *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
