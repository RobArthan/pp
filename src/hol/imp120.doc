=IGN
********************************************************************************
imp120.doc: this file is part of the PPHol system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex

\def\Title{ Higher-Order Matching: Implementation }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document gives the implementation of a higher-order matching function for HOL terms.}
\end{center}}

\def\Reference{LEMMA1/HOL/IMP120}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.5 $
}
\def\Date{\FormatDate{$Date: 2011/02/20 13:32:20 $
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\newpage
\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issue 1.1-1.3] Initial drafts.
\item[Issue 1.4] Moved conversions out into \cite{DS/FMU/IED/IMP007}.
\item[Issue 1.5, 1.6] Fixed problems in cases where the pattern contains $\eta$-redexes.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}

Lemma 1 build system.

\newpage

\section{Introduction}
\subsection{Scope}
This document gives the implementation of higher-order matching for HOL terms and
of proof procedures based on it.

\subsection{Purpose and Background}
See \cite{LEMMA1/HOL/DTD120}.

\subsection{Algorithms}
We follow Nipkow's
``Functional Unification of Higher-Order Patterns''
\cite{Nipkow93}.
As Nipkow says matching turns out to be significantly
easier than unification.

\section{THE STRUCTURE}
=TEX
=SML
structure ÛHigherOrderMatchingÝ : HigherOrderMatching = struct
=TEX
The narrative here refers mainly to the implementation
of unification given in figures 9 and 10 in Nipkow's paper.
Equivalents of the functional programming utilities of his figure 7
and the term manipulation functions of his figure 8
are provided with {\Product}.
=TEX
Nipkow's {\tt foldl} is our {\tt revfold} and
his {\tt foldr} is our {\tt fold}.

Nipkow distinguishes between free variables and loose bound variables in his syntax, the free variables being the variables that are subject to substitution, while the loose bound variables are treated as constants.
We work in an environment containing the current substitution and the list of loose bound variables.
Here and throughout we follow the {\Product}
convention of putting things relating to the target of the match to the left of things relating to the pattern:
so we represent a substition $[t_1/F_1, \ldots, t_k/F_k]$
using the pairs $(t_i, F_i)$ not $(F_i, t_i)$ as Nipkow does.
We carry around the type instantiation $\sigma$ and
term substitution $\theta$ (which becomes {\tt S}
in Nipkow's final code).
Each free variable appearing on the right-hand
side of a pair $(t_i, F_i)$ in $\theta$ has already been
instantiated to its final target type when it is
put in $\theta$ and no further instantation can apply to it.
The bound variables never need instantiation.
=SML
type ÛHOM_ENVÝ = {
	theta : (TERM * TERM) list,
	sigma : (TYPE * TYPE) list,
	bvars : TERM list
};
=TEX
=SML
fun Ûenv_assocÝ ({theta, ...} : HOM_ENV) (f : TERM) : TERM OPT = (
	rassoc5 theta f
);
=TEX
=SML
fun ÛredÝ (s : TERM) ([] : TERM list) : TERM = s
|   red (t : TERM) (yys as (y :: ys)) = (
	let	val (x, s) = dest_simple_Ì t;
	in	red (subst [(y, x)] s) ys
	end	handle Fail _ => list_mk_app (t, yys)
);
=TEX
In the following we do not need to test whether $t$ is a free variable: if it is in the domain of $\sigma$ it must be a free variable.
=SML
fun ÛdevarÝ (env : HOM_ENV) (t : TERM) = (
	let	val (f, ys) = strip_app t;
	in	case env_assoc env f of
			Value t => devar env (red t ys)
		|	Nil => t
	end
);
=TEX
We use the following local exception in place of Nipkow's {\tt Unif}.
=SML
exception HOMatch;
=TEX
We implement a preprocessing phase that $\eta$-normalises
the constituents of a function application $f\,y_1\,\ldots y_n$ in the pattern.
Nipkow mentions an $\eta$-normalisation phase on the $y_m$ as a possibility, and there seems to be no reason not do $f$ as well, thereby making our notion of
a linear pattern closed under $\eta$-conversion.
=SML
fun È_norm_fun_arg tm = (
	case dest_simple_term tm of
		SimpleÌ(x, b) => (
			let	val (g, y) = dest_app b;
			in	if	x = y
				then	È_norm_fun_arg g
				else	tm
			end	handle Fail _ => tm
		) |	_ => tm
);
=TEX
To keep the pattern to the right of the target, we do {\tt rigidflex} rather than {\tt flexrigid}.
=SML
fun ÛrigidflexÝ ({theta, sigma, bvars} : HOM_ENV)
	(t : TERM) (f : TERM, ym : TERM list) : HOM_ENV = (
	let	fun ok v = v mem ym orelse not(v mem bvars);
	in	case frees t drop ok of
			[] => (
				let	val ym' = map È_norm_fun_arg ym;
					val s = list_mk_Ì(ym', t);
					val theta' = (s, f)::theta;
				in	{theta = theta',
					 sigma = sigma,
					 bvars = bvars}
				end
		) |	_ =>	raise HOMatch
	end
);
=TEX
{\tt matchtypes} is used in the rigid-rigid case to
maintain the invariant that the two terms have the
same type. Note the type-matching here is necessary
even if $a$ and $b$ are Á-equivalent since we must not further instantiate
the type variables in the type of $a$.
The code drops redundant entries from $\sigma'$ here
to avoid the type instantiations doing unnecessary copying.
=SML
fun ÛmatchtypesÝ ({theta, sigma, bvars} : HOM_ENV)
	(a : TERM, ss : TERM list)
	(b : TERM, ts : TERM list) : HOM_ENV * TERM list = (
	let	val ty_a = type_of a;
		val ty_b = type_of b;
		val sigma'= type_match1 sigma ty_a ty_b;
		val env' = {
			theta = theta,
			sigma = sigma',
			bvars = bvars};
	in	if	a ~=$ b
		then	(env', ts)
		else if	fst(dest_const a) = fst(dest_const b)
		then	let	val i = inst [] (sigma' drop (op =));
				val ts' = map i ts;
			in	(env', ts')
			end
		else	raise HOMatch
	end	handle Fail _ => raise HOMatch	
);
=TEX
=SML
fun ÛpushbvarÝ ({theta, sigma, bvars} : HOM_ENV)
	(x : TERM) : HOM_ENV = (
	{theta = theta,
	 sigma = sigma,
	 bvars = x :: bvars}
);
=TEX
=SML
fun ÛpopbvarÝ ({theta, sigma, bvars} : HOM_ENV) : HOM_ENV = (
	{theta = theta,
	 sigma = sigma,
	 bvars = tl bvars}
);
=TEX
{\tt hom} is Nipkow's {\tt unif} simplified to do matching rather than unification.
It assumes caller has ensured that $s$ and $t$ have the same type and has recorded the type instantiation
used to do this in $\theta$.

=SML
fun ÛhomÝ ((s : TERM, t : TERM), env : HOM_ENV) : HOM_ENV = (
	let	val t1 = devar env t;
	in	case (dest_simple_term s, dest_simple_term t1) of
			(SimpleÌ(x, bs), SimpleÌ(y, bt)) => (
				let	val bt1 =
					if	x = y
					then	bt
					else	subst [(x, y)] bt;
					val env1 = pushbvar env x;
					val env2 = hom ((bs, bt1), env1);
				in	popbvar env2
				end
		) |	(SimpleÌ(x, bs), _) => (
				let	val t_x = mk_app(t1, x);
					val env1 = pushbvar env x;
					val env2 = hom ((bs, t_x), env1);
				in	popbvar env2
				end
		) |	(_, SimpleÌ(y, bt)) => (
				let	val s_y = mk_app(s, y);
					val env1 = pushbvar env y;
					val env2 = hom((s_y, bt), env1);
				in	popbvar env2
				end
		) |	_ => cases ((s, t1), env)
	end
)
and ÛcasesÝ ((s : TERM, t : TERM), env : HOM_ENV) : HOM_ENV = (
	let	val (g, zn) = strip_app t;
		val g' = È_norm_fun_arg g;
	in	if	is_var g'
		andalso	not(g' mem #bvars env)
		then	rigidflex env s (g', zn)
		else	rigidrigid env (strip_app s) (g', zn)
	end
)
and ÛrigidrigidÝ (env : HOM_ENV)
	(a_ss as (_, ss) : TERM * TERM list)
	(b_ts : TERM * TERM list) : HOM_ENV = (
	let	val (env1, ts) = matchtypes env a_ss b_ts;
		val ss_ts = combine ss ts;
	in	revfold hom ss_ts env1
	end	handle Fail _ => raise HOMatch
);
=TEX
=SML
fun Ûho_matchÝ (s : TERM) (t : TERM) : (TYPE * TYPE) list * (TERM * TERM) list = (
	let	val s_ty = type_of s;
		val t_ty = type_of t;
		val sigma = type_match1 [] s_ty t_ty;
		val t = inst [] sigma t;
		val env = {
			theta = [],
			sigma = sigma,
			bvars = []
		};
		val {theta, sigma, ...} = hom ((s, t), env);
	in	(sigma drop (op =), theta drop (op =))
	end	handle HOMatch => (
			term_fail "ho_match" 120001 [s, t]
		) | Fail _ => term_fail "ho_match" 120001 [s, t]
);


=TEX
=SML
end (* of structure HigherOrderMatching *);
open HigherOrderMatching;
=TEX

\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}


=IGN

val (m1, s1) = term_match ¬(Ì(b:'b)·(a:'a))® ¬x:'a®;

ho_match ¬ x ® ¬ x ®;
ho_match ¬ 1 ® ¬ x ®;
ho_match ¬ µx· x < 1 ² x = y ® ¬ µx· P x ®;
ho_match ¬ µx· x < 1 ² Fst (T, (T, F))® ¬ µx· P x ² Fst y®;
ho_match ¬ µx· x < 1 ± x = y ® ¬ µx· P x ± Q x®;
ho_match ¬ (t : 'a ­ 'b) ® ¬ Ìx:'a·(f x : 'b)®;
ho_match ¬ (t : î ­ î ¸ î ­ BOOL) ® ¬ Ìx:'a; y : 'b·(f x y: 'c)®;


simple_È_norm_conv ¬ x ®;
simple_È_norm_conv ¬ 1 ®;
simple_È_norm_conv ¬ Ìx·f x ®;
simple_È_norm_conv ¬ (Ìx·x + 1) 2 ®;
simple_È_norm_conv ¬ (Ìf g·f 1 + g 2) ($* 2) ($- 2)®;
simple_È_norm_conv ¬ (Ìf·f 1 + f(f(f((Ìj· f j) k)))) (Ìi·2 * i)®;
simple_È_norm_conv ¬ ((Ìx·$+ x), (Ìx·Fst x), (Ìx·Succ x)) ®;
simple_Â_È_conv ¬ (Ìx·$+ x) ® ¬ ($+) ®;

val ³_µ_thm =
	prove_rule[]¬µP·³(µx· P x) ¤ (¶x·³P x) ®;
val µ_±_thm =
	prove_rule[]¬µP Q·((µx· P x) ± (µx·Q x)) ¤ (µx·P x ± Q x) ®;
val µ_²_thm =
	prove_rule[]¬µP Q·((µx· P x) ² (µx·Q x)) ¤ (µx y·P x ² Q y) ®;
val ³_¶_thm =
	prove_rule[]¬µP·³(¶x· P x) ¤ (µx·³P x) ®;
val ¶_±_thm =
	prove_rule[]¬µP Q·((¶x· P x) ± (¶x·Q x)) ¤ (¶x y·P x ± Q y) ®;
val ¶_²_thm =
	prove_rule[]¬µP Q·(P ² (¶x·Q x)) ¤ (¶x·P ² Q x) ®;

val ³_³_thm =
	prove_rule[]¬µa·³³a ¤ a®;
val ³_±_thm =
	prove_rule[]¬µa b·³(a ± b) ¤ ³a ² ³b®;
val ³_²_thm =
	prove_rule[]¬µa b·³(a ² b) ¤ ³a ± ³b®;
val ´_thm =
	prove_rule[]¬µa b·a ´ b ¤ ³a ² b®;
val ¤_thm =
	prove_rule[]¬µa b·(a ¤ b) ¤ (³a ² b) ± (a ² ³b)®;

val thms1 = [³_µ_thm, µ_±_thm, µ_²_thm, ³_¶_thm, ¶_±_thm,
	¶_²_thm, ³_³_thm, ³_±_thm, ³_²_thm, ´_thm, ¤_thm];

val µ_±_thm2a =
	prove_rule[]¬µa Q·(a ± (µx· Q x)) ¤ (µx·a ± Q x) ®;
val µ_±_thm2b =
	prove_rule[]¬µP b·((µx· P x) ± b) ¤ (µx·P x ± b) ®;
val µ_²_thm2a =
	prove_rule[]¬µa Q·(a ² (µx· Q x)) ¤ (µx·a ² Q x) ®;
val µ_²_thm2b =
	prove_rule[]¬µP b·((µx· P x) ² b) ¤ (µx·P x ² b) ®;
val ¶_±_thm2a =
	prove_rule[]¬µa Q·(a ± (¶x· Q x)) ¤ (¶x·a ± Q x) ®;
val ¶_±_thm2b =
	prove_rule[]¬µP b·((¶x· P x) ± b) ¤ (¶x·P x ± b) ®;
val ¶_²_thm2a =
	prove_rule[]¬µa Q·(a ² (¶x· Q x)) ¤ (¶x·a ² Q x) ®;
val ¶_²_thm2b =
	prove_rule[]¬µP b·((¶x· P x) ² b) ¤ (¶x·P x ² b) ®;

val thms2 = [
	µ_±_thm2a, µ_±_thm2b, µ_²_thm2a, µ_²_thm2b, ¶_±_thm2a, ¶_±_thm2b, ¶_²_thm2a, ¶_²_thm2b];

val quant_out_conv = TOP_MAP_C
	(FIRST_C (map simple_ho_eq_match_conv thms) ORELSE_C
	 FIRST_C (map simple_ho_eq_match_conv thms2));

quant_out_conv ¬(µx· x < 1) ± (µx·x > 2)®;

quant_out_conv ¬(¶x·x < 1) ² (¶x·x = 0)®;

quant_out_conv ¬(¶x·x < 1) ´ (¶x·x = 0)®;
quant_out_conv ¬¶x· (µ x· ³ x < 1) ² x = 0®;

simple_ho_eq_match_conv µ_²_thm ¬(µ x· ³ x < 1) ² x = 0®;
simple_ho_eq_match_conv µ_²_thm ¬(µx· x < 1) ² (µx·x > 2)®;






