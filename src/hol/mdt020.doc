% mdt020.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for ICL HOL Symbol Table}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD020}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the implementation for the
symbol table module for ICL HOL.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library\\RDA\\AJH\\DJK}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.6, \FormatDate{91/07/30} ]
First draft for comment.

\item[Issue 1.7, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.8 (23rd January 1992)]
$new\_axiom$, $simple\_new\_type\_defn$ and $new\_type\_defn$
all changed to take lists of keys, rather than single ones.
\item [Issue 1.9 (31st January 1992)]
Fixed duplicated identities.
\item [Issue 1.10 (8th April 1992)]
Changes required by CR0016.
\item [Issue 1.11 (14th April 1992)]
Changes required by CR0017.
\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the module tests for the symbol table module for ICL HOL
as specified in \cite{DS/FMU/IED/DTD020}.
\subsection{Introduction}

\section{TEST CASES}
The structure of the test cases broadly follows the structure of the
detailed design \cite{DS/FMU/IED/DTD020}. Since the symbol table module
is essentially a black box and so, for example, the precise format used
to represent symbol table information in the theory database is taken
as implementation-dependent, we test the module against itself.
The tests therefore come in three groups, each group being subdivided
according to the structure of \cite{DS/FMU/IED/DTD020}. The first group
tests the basic sanity of each interface.
The second group checks out error cases.
The third group
tests out the treatment of context changes.

\section{TEST DATA AND TEST CODE}
=SML
use_file"dtd013";
use_file"imp013";
init_mt_results();
open Lex;
set_flag("ignore_warnings", true);
open_theory"min";
val thys_to_go = rev(tl (rev (get_descendants "min")));
map delete_theory thys_to_go;
delete_type"­";
=TEX
=SML
fun list_eq (eq:'a * 'a -> bool) ((a :: x), (b :: y)) : bool = (
	eq(a,b) andalso list_eq eq (x, y)
) | list_eq eq ([], []) = true
| list_eq _ _ = false;
=TEX
=SML
fun gci_eq (Value (a,b),Value (c,d)) = a =: c andalso
	list_eq (fn ((p,q),(r,s)) => p = r andalso q =: s) (b,d)
| gci_eq (Nil, Nil) = true
| gci_eq _ = false;
=TEX
=SML
fun gti_eq (Value (a,Value(b,c)),Value (d,Value(e,f))) = a = d andalso
	b = e andalso c =: f
| gti_eq(Value (a,Nil),Value (d,Nil)) = (a = d)
| gti_eq (Nil, Nil) = true
| gti_eq _ = false;
=TEX
\subsection{Group 1}
\subsubsection{Terminators}
=SML
map (undeclare_terminator o implode) (get_current_terminators());
store_mt_results_show mt_run
[("SymbolTable.1.1.1", get_current_terminators, (), [])];
declare_terminator "==";
store_mt_results_show mt_run
[("SymbolTable.1.1.2", get_current_terminators, (), [["=", "="]])];
store_mt_results_show mt_run
[("SymbolTable.1.1.2a", get_terminators, "-", ["=="])];
undeclare_terminator "==";
store_mt_results_show mt_run
[("SymbolTable.1.1.3", get_current_terminators, (), [])];
store_mt_results_show mt_run
[("SymbolTable.1.1.3a", get_terminators, "-", [])];
=TEX
\subsubsection{Fixity}
=SML
store_mt_results_show mt_run
[("SymbolTable.1.2.1", get_fixity, "±", Nonfix)];
declare_binder "µ";
declare_infix (10, "±");
declare_prefix(5, "³");
declare_postfix(20, "!");
store_mt_results_show mt_run
[("SymbolTable.1.2.2", get_fixity, "!", Postfix 20),
 ("SymbolTable.1.2.3", get_fixity, "³", Prefix 5),
 ("SymbolTable.1.2.4", get_fixity, "±", Infix 10),
 ("SymbolTable.1.2.5", get_fixity, "µ", Binder)];
=TEX
=SML
map declare_nonfix ["µ", "±", "³", "!"];
store_mt_results_show mt_run
[("SymbolTable.1.2.6", get_fixity, "!", Nonfix),
 ("SymbolTable.1.2.7", get_fixity, "³", Nonfix),
 ("SymbolTable.1.2.8", get_fixity, "±", Nonfix),
 ("SymbolTable.1.2.9", get_fixity, "µ", Nonfix)];
=TEX
\subsubsection{Constants and Aliases}
=SML
store_mt_results_show (mt_runf gci_eq)
[("SymbolTable.1.3.1", get_const_info, "T", Nil)];
new_type("BOOL", 0);
new_type("­", 2);
new_const("T", BOOL);
store_mt_results_show (mt_runf gci_eq)
[("SymbolTable.1.3.2", get_const_info, "T", Value(BOOL, [("T", BOOL)]))];
=TEX
=SML
fun eqty (ty : TYPE) : TYPE = (
	mk_­_type(ty, mk_­_type(ty, BOOL))
);
val vartya = mk_vartype"'a";
val vartyb = mk_vartype"'b";

new_const("=", eqty vartya);
val ty_of_iff = mk_­_type(BOOL, mk_­_type(BOOL, BOOL));
declare_alias("¤", mk_const("=", ty_of_iff));
store_mt_results_show (mt_runf gci_eq)
[("SymbolTable.1.3.3", get_const_info, "¤", Value(ty_of_iff, [("=", ty_of_iff)]))];
store_mt_results_show (mt_runf (op =$))
[("SymbolTable.1.3.4", resolve_alias, ("¤", ty_of_iff), mk_const("=", ty_of_iff))];

=TEX
=SML
declare_alias("¤", mk_const("T", BOOL));
store_mt_results_show (mt_runf gci_eq) 
[("SymbolTable.1.3.5", get_const_info, "¤", 
	Value(mk_vartype"'0", [("T", BOOL), ("=", ty_of_iff)]))];
store_mt_results_show (mt_runf (op =$))
[("SymbolTable.1.3.6", resolve_alias, ("¤", ty_of_iff), 
	mk_const("=", ty_of_iff)),
 ("SymbolTable.1.3.7", resolve_alias, ("¤", BOOL), 
	mk_const("T", BOOL))];
=TEX
=SML
undeclare_alias("¤", mk_const("T", BOOL));
store_mt_results_show (mt_runf gci_eq) 
[("SymbolTable.1.3.8", get_const_info, "¤", Value(ty_of_iff, [("=", ty_of_iff)]))];
=TEX
=SML
undeclare_alias("¤", mk_const("=", ty_of_iff));
store_mt_results_show (mt_runf gci_eq) 
[("SymbolTable.1.3.9", get_const_info, "¤", Nil)];
=TEX
=SML
declare_alias("¤", mk_const("=", ty_of_iff));
store_mt_results_show mt_run
[("SymbolTable.1.3.10", get_alias, ("=", ty_of_iff), "¤")];
=TEX
=SML
fun funeqty (ty1 : TYPE) (ty2 : TYPE) : TYPE = eqty (mk_­_type (ty1, ty2));

declare_alias("funeq", mk_const("=", funeqty vartya vartyb));
store_mt_results_show mt_run
[("SymbolTable.1.3.11", get_alias, ("=", funeqty vartya vartya), "funeq"),
 ("SymbolTable.1.3.12", get_alias, ("=", ty_of_iff ), "¤")];
=TEX
\subsubsection{Types and Type Abbreviations}
=SML
store_mt_results_show (mt_runf gti_eq) 
[("SymbolTable.1.4.1", get_type_info, "ENDO", Nil)];
val ty_endo = mk_­_type(mk_vartype"'a", mk_vartype"'a");
=TEX
=SML
declare_type_abbrev("ENDO", ["'a"], ty_endo);
store_mt_results_show (mt_runf gti_eq) 
[("SymbolTable.1.4.2", get_type_info, "ENDO", Value(1, Value(["'a"], ty_endo)))];
=TEX
=SML
store_mt_results_show (mt_runf gti_eq) 
[("SymbolTable.1.4.3", get_type_info, "­", Value(2, Nil))];
=TEX
=SML
undeclare_type_abbrev"ENDO";
store_mt_results_show (mt_runf gti_eq) 
[("SymbolTable.1.4.4", get_type_info, "ENDO", Nil)];
=TEX
=SML
declare_type_abbrev("­", ["'a"], ty_endo);
store_mt_results_show (mt_runf gti_eq) 
[("SymbolTable.1.4.5", get_type_info, "­", Value(1, Value(["'a"], ty_endo)))];
undeclare_type_abbrev"­";
store_mt_results_show (mt_runf gti_eq) 
[("SymbolTable.1.4.6", get_type_info, "­", Value(2, Nil))];
=TEX
\subsubsection{Languages}
=SML
store_mt_results_show mt_run
[("SymbolTable.1.5.1", get_type_language, "­", "HOL")];
=TEX
=SML
new_theory"x";
set_current_language"Greek";
new_type("TYPE", 42);
new_const("CONST", BOOL);
store_mt_results_show mt_run
[("SymbolTable.1.5.2", get_type_language, "TYPE", "Greek"),
 ("SymbolTable.1.5.3", get_type_language, "­", "HOL"),
 ("SymbolTable.1.5.4", get_const_language, "=", "HOL"),
 ("SymbolTable.1.5.5", get_const_language, "CONST", "Greek")];
set_current_language"Japanese";
store_mt_results_show mt_run
[("SymbolTable.1.5.6", get_type_language, "TYPE", "Japanese"),
 ("SymbolTable.1.5.7", get_type_language, "­", "HOL"),
 ("SymbolTable.1.5.8", get_const_language, "=", "HOL"),
 ("SymbolTable.1.5.9", get_const_language, "CONST", "Japanese")];
open_theory"min";
store_mt_results_show mt_run
[("SymbolTable.1.5.10", get_type_language, "TYPE", "HOL"),
 ("SymbolTable.1.5.11", get_type_language, "­", "HOL"),
 ("SymbolTable.1.5.12", get_const_language, "=", "HOL"),
 ("SymbolTable.1.5.13", get_const_language, "CONST", "HOL")];
open_theory"x";
store_mt_results_show mt_run
[("SymbolTable.1.5.14", get_type_language, "TYPE", "Japanese"),
 ("SymbolTable.1.5.15", get_type_language, "­", "HOL"),
 ("SymbolTable.1.5.16", get_const_language, "=", "HOL"),
 ("SymbolTable.1.5.17", get_const_language, "CONST", "Japanese")];
store_mt_results_show mt_run
[("SymbolTable.1.5.18", get_language, "x", "Japanese"),
 ("SymbolTable.1.5.19", get_language, "min", "HOL")];
open_theory"min";
delete_theory"x";
=TEX
\subsubsection{Miscellaneous}
=SML
declare_binder"E";
declare_binder"E1";
new_theory"x";
declare_binder "A";
declare_infix (10, "±");
declare_prefix(5, "³");
declare_postfix(20, "!");
declare_nonfix"E";

declare_binder "A1";
declare_infix (100, "±1");
declare_prefix(50, "³1");
declare_postfix(200, "!1");
declare_nonfix"E1";

store_mt_results_show mt_run
[("SymbolTable.1.6.1", get_binders, "x", ["A1", "A"])];
store_mt_results_show mt_run
[("SymbolTable.1.6.2", get_infixes, "x", [(100, "±1"), (10, "±")]),
 ("SymbolTable.1.6.3", get_prefixes, "x", [(50, "³1"), (5, "³")]),
 ("SymbolTable.1.6.4", get_postfixes, "x", [(200, "!1"), (20, "!")])];
store_mt_results_show mt_run
[("SymbolTable.1.6.5", get_nonfixes, "x", ["E1", "E"])];

open_theory"min";
delete_theory"x";
=TEX
=SML
new_theory"x";
new_const("A", BOOL);
new_type("Z", 1);
store_mt_results_show mt_run
[("SymbolTable.1.6.6", get_const_theory, "A", "x"),
 ("SymbolTable.1.6.7", get_type_theory, "Z", "x")];
open_theory"min";
delete_theory"x";
=TEX
\subsection{Group 3}
To check out the context handling we first set up a more complex theory hierarchy
than we have used previously:
=SML
new_theory"level1";
new_theory"level2a";
new_theory"level3a";
open_theory"level1";
new_theory"level2b";
new_theory"level3b";
open_theory"level1";
declare_binder"level1binder";
open_theory"level2a";
new_const("level1binder", BOOL);
open_theory"level3a";
declare_nonfix"level1binder";
store_mt_results_show mt_run
[("SymbolTable.3.1.1", get_fixity, "level1binder", Nonfix)];
open_theory"level2a";
store_mt_results_show mt_run
[("SymbolTable.3.1.2", get_fixity, "level1binder", Binder)];
open_theory"level3b";
store_mt_results_show mt_run
[("SymbolTable.3.1.3", get_fixity, "level1binder", Binder)];
=TEX
=SML
open_theory"min";
map delete_theory["level3a", "level2a", "level3b", "level2b", "level1"];
=TEX
=SML
new_theory"x";
new_type("T", 2);
new_const("A", BOOL);
new_const("¶", mk_­_type(mk_­_type(mk_vartype"'a", BOOL), BOOL));
val A = mk_const("A", BOOL);
val ¶ = mk_const("¶", mk_­_type(mk_­_type(mk_vartype"'a", BOOL), BOOL));
val B = mk_var("B", BOOL);
val x = mk_var("x", BOOL);

new_axiom(["ax"], list_mk_¶([B, x], A));
new_spec(["spec"], 1, get_axiom "x" "ax");
store_mt_results_show mt_run
[("SymbolTable.3.2.1", get_const_theory, "B", "x"),
 ("SymbolTable.3.2.2", get_type_theory, "T", "x")];

new_theory"y";
store_mt_results_show mt_run
[("SymbolTable.3.2.3", get_const_theory, "B", "x"),
 ("SymbolTable.3.2.4", get_type_theory, "T", "x")];

open_theory"x";
delete_theory"y";

delete_type"T";

store_mt_results_show mt_run_fail
[
 ("SymbolTable.3.2.5", get_const_theory, "B", gen_fail_msg "get_const_theory" 20701 ["B"]),
 ("SymbolTable.3.2.6", get_type_theory, "T", gen_fail_msg "get_type_theory" 20702 ["T"])
];

=TEX
=SML
diag_string(summarize_mt_results());
=TEX

\end{document}


