% mdt020.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for ICL HOL Symbol Table}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD020}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the implementation for the
symbol table module for ICL HOL.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library\\RDA\\AJH\\DJK}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion (\FormatDate{$Date$%
})]
First draft for comment.
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the module tests for the symbol table module for ICL HOL
as specified in \cite{DS/FMU/IED/DTD020}.
\subsection{Introduction}

\section{TEST CASES}
The structure of the test cases broadly follows the structure of the
detailed design \cite{DS/FMU/IED/DTD020}. Since the symbol table module
is essentially a black box and so, for example, the precise format used
to represent symbol table information in the theory database is taken
as implementation-dependent, we test the module against itself.
The tests therefore come in three groups, each group being subdivided
according to the structure of \cite{DS/FMU/IED/DTD020}. The first group
tests the basic sanity of each interface.
The second group checks out error cases.
The third group
tests out the treatment of context changes.

\section{TEST DATA AND TEST CODE}
=SML
usefile"dtd013";
usefile"imp013";
init_mt_results();
open Lex;
set_flag("ignore_warnings", true);
open_theory"min";
val thys_to_go = rev(tl (rev (get_descendants "min")));
map delete_theory thys_to_go;
delete_type"‹";
=TEX
\subsection{Group 1}
\subsubsection{Terminators}
=SML
map (undeclare_terminator o implode) (get_current_terminators());
store_mt_results_show mt_run
[("SymbolTable.1.1.1", get_current_terminators, (), [])];
declare_terminator "==";
store_mt_results_show mt_run
[("SymbolTable.1.1.2", get_current_terminators, (), [["=", "="]])];
store_mt_results_show mt_run
[("SymbolTable.1.1.2a", get_terminators, "-", ["=="])];
undeclare_terminator "==";
store_mt_results_show mt_run
[("SymbolTable.1.1.3", get_current_terminators, (), [])];
store_mt_results_show mt_run
[("SymbolTable.1.1.3a", get_terminators, "-", [])];
=TEX
\subsubsection{Fixity}
=SML
store_mt_results_show mt_run
[("SymbolTable.1.2.1", get_fixity, "€", Nonfix)];
declare_binder "ƒ";
declare_infix (10, "€");
declare_prefix(5, "Œ");
declare_postfix(20, "!");
store_mt_results_show mt_run
[("SymbolTable.1.2.2", get_fixity, "!", Postfix 20),
 ("SymbolTable.1.2.3", get_fixity, "Œ", Prefix 5),
 ("SymbolTable.1.2.4", get_fixity, "€", Infix 10),
 ("SymbolTable.1.2.5", get_fixity, "ƒ", Binder)];
=TEX
=SML
map declare_nonfix ["ƒ", "€", "Œ", "!"];
store_mt_results_show mt_run
[("SymbolTable.1.2.6", get_fixity, "!", Nonfix),
 ("SymbolTable.1.2.7", get_fixity, "Œ", Nonfix),
 ("SymbolTable.1.2.8", get_fixity, "€", Nonfix),
 ("SymbolTable.1.2.9", get_fixity, "ƒ", Nonfix)];
=TEX
\subsubsection{Constants and Aliases}
=SML
store_mt_results_show mt_run
[("SymbolTable.1.3.1", get_const_info, "T", Nil)];
new_type("BOOL", 0);
new_type("‹", 2);
new_const("T", BOOL);

store_mt_results_show mt_run
[("SymbolTable.1.3.2", get_const_info, "T", Value(BOOL, [("T", BOOL)]))];
=TEX
=SML
fun eqty (ty : TYPE) : TYPE = (
	mk_fun(ty, mk_fun(ty, BOOL))
);
val vartya = mk_vartype"'a";
val vartyb = mk_vartype"'b";

new_const("=", eqty vartya);
val ty_of_iff = mk_fun(BOOL, mk_fun(BOOL, BOOL));
declare_alias("‚", mk_const("=", ty_of_iff));
store_mt_results_show mt_run
[("SymbolTable.1.3.3", get_const_info, "‚", Value(ty_of_iff, [("=", ty_of_iff)]))];
store_mt_results_show mt_run
[("SymbolTable.1.3.4", resolve_alias, ("‚", ty_of_iff), mk_const("=", ty_of_iff))];

=TEX
=SML
declare_alias("‚", mk_const("T", BOOL));
store_mt_results_show mt_run
[("SymbolTable.1.3.5", get_const_info, "‚", Value(mk_vartype"'0", [("T", BOOL), ("=", ty_of_iff)]))];
store_mt_results_show mt_run
[("SymbolTable.1.3.6", resolve_alias, ("‚", ty_of_iff), mk_const("=", ty_of_iff)),
 ("SymbolTable.1.3.7", resolve_alias, ("‚", BOOL), mk_const("T", BOOL))];
=TEX
=SML
undeclare_alias("‚", mk_const("T", BOOL));
store_mt_results_show mt_run
[("SymbolTable.1.3.8", get_const_info, "‚", Value(ty_of_iff, [("=", ty_of_iff)]))];
=TEX
=SML
undeclare_alias("‚", mk_const("=", ty_of_iff));
store_mt_results_show mt_run
[("SymbolTable.1.3.9", get_const_info, "‚", Nil)];
=TEX
=SML
declare_alias("‚", mk_const("=", ty_of_iff));
store_mt_results_show mt_run
[("SymbolTable.1.3.10", get_alias, ("=", ty_of_iff), "‚")];
=TEX
=SML
fun funeqty (ty1 : TYPE) (ty2 : TYPE) : TYPE = eqty (mk_fun (ty1, ty2));

declare_alias("funeq", mk_const("=", funeqty vartya vartyb));
store_mt_results_show mt_run
[("SymbolTable.1.3.11", get_alias, ("=", funeqty vartya vartya), "funeq"),
 ("SymbolTable.1.3.12", get_alias, ("=", ty_of_iff ), "‚")];
=TEX
\subsubsection{Types and Type Abbreviations}
=SML
store_mt_results_show mt_run
[("SymbolTable.1.4.1", get_type_info, "ENDO", Nil)];
val ty_endo = mk_fun(mk_vartype"'a", mk_vartype"'a");
=TEX
=SML
declare_type_abbrev("ENDO", ["'a"], ty_endo);
store_mt_results_show mt_run
[("SymbolTable.1.4.2", get_type_info, "ENDO", Value(1, Value(["'a"], ty_endo)))];
=TEX
=SML
store_mt_results_show mt_run
[("SymbolTable.1.4.3", get_type_info, "‹", Value(2, Nil))];
=TEX
=SML
undeclare_type_abbrev"ENDO";
store_mt_results_show mt_run
[("SymbolTable.1.4.4", get_type_info, "ENDO", Nil)];
=TEX
=SML
declare_type_abbrev("‹", ["'a"], ty_endo);
store_mt_results_show mt_run
[("SymbolTable.1.4.5", get_type_info, "‹", Value(1, Value(["'a"], ty_endo)))];
undeclare_type_abbrev"‹";
store_mt_results_show mt_run
[("SymbolTable.1.4.6", get_type_info, "‹", Value(2, Nil))];
=TEX
\subsubsection{Languages}
=SML
store_mt_results_show mt_run
[("SymbolTable.1.5.1", get_type_language, "‹", "HOL")];
=TEX
=SML
new_theory"x";
set_current_language"Greek";
new_type("TYPE", 42);
new_const("CONST", BOOL);
store_mt_results_show mt_run
[("SymbolTable.1.5.2", get_type_language, "TYPE", "Greek"),
 ("SymbolTable.1.5.3", get_type_language, "‹", "HOL"),
 ("SymbolTable.1.5.4", get_const_language, "=", "HOL"),
 ("SymbolTable.1.5.5", get_const_language, "CONST", "Greek")];
set_current_language"Japanese";
store_mt_results_show mt_run
[("SymbolTable.1.5.6", get_type_language, "TYPE", "Japanese"),
 ("SymbolTable.1.5.7", get_type_language, "‹", "HOL"),
 ("SymbolTable.1.5.8", get_const_language, "=", "HOL"),
 ("SymbolTable.1.5.9", get_const_language, "CONST", "Japanese")];
open_theory"min";
store_mt_results_show mt_run
[("SymbolTable.1.5.10", get_type_language, "TYPE", "HOL"),
 ("SymbolTable.1.5.11", get_type_language, "‹", "HOL"),
 ("SymbolTable.1.5.12", get_const_language, "=", "HOL"),
 ("SymbolTable.1.5.13", get_const_language, "CONST", "HOL")];
open_theory"x";
store_mt_results_show mt_run
[("SymbolTable.1.5.14", get_type_language, "TYPE", "Japanese"),
 ("SymbolTable.1.5.15", get_type_language, "‹", "HOL"),
 ("SymbolTable.1.5.16", get_const_language, "=", "HOL"),
 ("SymbolTable.1.5.17", get_const_language, "CONST", "Japanese")];
store_mt_results_show mt_run
[("SymbolTable.1.5.18", get_language, "x", "Japanese"),
 ("SymbolTable.1.5.19", get_language, "min", "HOL")];
open_theory"min";
delete_theory"x";
=TEX
\subsubsection{Miscellaneous}
=SML
declare_binder"E";
declare_binder"E1";
new_theory"x";
declare_binder "A";
declare_infix (10, "€");
declare_prefix(5, "Œ");
declare_postfix(20, "!");
declare_nonfix"E";

declare_binder "A1";
declare_infix (100, "€1");
declare_prefix(50, "Œ1");
declare_postfix(200, "!1");
declare_nonfix"E1";

store_mt_results_show mt_run
[("SymbolTable.1.6.1", get_binders, "x", ["A1", "A"]),
 ("SymbolTable.1.6.2", get_infixes, "x", ["€1", "€"]),
 ("SymbolTable.1.6.3", get_prefixes, "x", ["Œ1", "Œ"]),
 ("SymbolTable.1.6.4", get_postfixes, "x", ["!1", "!"]),
 ("SymbolTable.1.6.5", get_nonfixes, "x", ["E1", "E"])];

open_theory"min";
delete_theory"x";
=TEX
=SML
new_theory"x";
new_const("A", BOOL);
new_type("Z", 1);
store_mt_results_show mt_run
[("SymbolTable.1.6.1", get_const_theory, "A", "x"),
 ("SymbolTable.1.6.2", get_type_theory, "Z", "x")];
open_theory"min";
delete_theory"x";
=TEX
\subsection{Group 3}
To check out the context handling we first set up a more complex theory hierarchy
than we have used previously:
=SML
new_theory"level1";
new_theory"level2a";
new_theory"level3a";
open_theory"level1";
new_theory"level2b";
new_theory"level3b";
open_theory"level1";
declare_binder"level1binder";
open_theory"level2a";
new_const("level1binder", BOOL);
open_theory"level3a";
declare_nonfix"level1binder";
store_mt_results_show mt_run
[("SymbolTable.3.1.1", get_fixity, "level1binder", Nonfix)];
open_theory"level2a";
store_mt_results_show mt_run
[("SymbolTable.3.1.2", get_fixity, "level1binder", Binder)];
open_theory"level3b";
store_mt_results_show mt_run
[("SymbolTable.3.1.3", get_fixity, "level1binder", Binder)];
=TEX
=SML
open_theory"min";
map delete_theory["level3a", "level2a", "level3b", "level2b", "level1"];
=TEX
=SML
new_theory"x";
new_type("T", 2);
new_const("A", BOOL);
new_const("„", mk_fun(mk_fun(mk_vartype"'a", BOOL), BOOL));
val A = mk_const("A", BOOL);
val „ = mk_const("„", mk_fun(mk_fun(mk_vartype"'a", BOOL), BOOL));
val B = mk_var("B", BOOL);
val x = mk_var("x", BOOL);

new_axiom("ax", list_mk_„([B, x], A));
new_specification(["spec"], 1, get_axiom "x" "ax");
store_mt_results_show mt_run
[("SymbolTable.3.2.1", get_const_theory, "B", "x"),
 ("SymbolTable.3.2.2", get_type_theory, "T", "x")];

new_theory"y";
store_mt_results_show mt_run
[("SymbolTable.3.2.3", get_const_theory, "B", "x"),
 ("SymbolTable.3.2.4", get_type_theory, "T", "x")];

open_theory"x";
delete_theory"y";

delete_type"T";

store_mt_results_show mt_run_fail
[
 ("SymbolTable.3.2.5", get_const_theory, "B", gen_fail_msg "get_const_theory" 20701 ["B"]),
 ("SymbolTable.3.2.6", get_type_theory, "T", gen_fail_msg "get_type_theory" 20702 ["T"])
];

=TEX
=SML
diag_string(summarize_mt_results());
=TEX

\end{document}
