=IGNORE
           % U s e f u l C o m m a n d s

/hat/nih/bin/poly_2.04/poly  -r ~ied/rel001/latest/sun3hol.db
cp  ~ied/rel001/latest/sun3hol.db example.db; chmod +w example.db
/hat/nih/bin/poly_2.04/poly  example.db
poly sun3hol.db
rm -f *.aux *.dvi *.idx *.log *.sid 
doctex usr004
texdvi usr004
texdvi usr004
bibtex usr004
texdvi usr004
dvipage usr004
=TEX



%%%%  111111   for internal document

\documentstyle[hol1,11pt,twoside,TQ]{article}
\raggedbottom
\ftlinepenalty=9999
\makeindex
     \TPPproject{FST PROJECT}  %% Mandatory field
%     \TPPvolume{}
%       \TPPpart{}
       \TPPtitle{INTRODUCTION TO ICL HOL}  %% Mandatory field
         \TPPref{DS/FMU/IED/USR004}  %% Mandatory field
\def\SCCSversion{
}
        \TPPissue{$Revision$%
}  
         \TPPdate{\FormatDate{$Date$
}}
       \TPPstatus{Informal}			%% Mandatory field
         \TPPtype{Technical Note}
     \TPPkeywords{}
       \TPPauthor{R. Stokes & WIN01}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & Project Leader}
     \TPPabstract{}
 \TPPdistribution{\parbox[t]{4.0in}{%
	    HAT Team Members
}}


\makeatletter
% \def
% =GRUMBLE
% cannot convert character code 220 'Ü'
% =TEX
% {\@Mm{\mid\!\equiv}}
% \defò{\@Mm{\hbox{\Large$\triangleleft$}}}
% \def
% =GRUMBLE
% cannot convert character code 183 '·'
% =TEX
% {\@Mm{\mid\!\sim}}
% \def
% =GRUMBLE
% cannot convert character code 239 'ï'
% =TEX
% {\@Mm{\mid\!\Rightarrow}}
% \def
% =GRUMBLE
% cannot convert character code 170 'ª'
% =TEX
% {\@Mm{{\#}}}
% \defª{\@Mm{\leftrightarrow}}
% \defí{\@Mm{\mapsto}}
%\defí{\@Mm{\stackrel{\hbox{\scriptsize ?}}{\mapsto}}}
% \def
% =GRUMBLE
% cannot convert character code 185 '¹'
% =TEX
% {\@Mm{\rightleftharpoons}}
% \def
% =GRUMBLE
% cannot convert character code 228 'ä'
% =TEX
% {\@Mm{\{\}}}
% \def¨{\@Mm{\langle\rangle}}

% \def
% =GRUMBLE
% cannot convert character code 211 'Ó'
% =TEX
% {\@Mm{^{-1}}}
\makeatother





=TEX
\begin{document}
\makeTPPfrontpage
% \vfill
% \begin{centering}
% \bf Copyright \copyright\ : International Computers Ltd \number\year
% \end{centering}

\clearpage
\section{Document control}
\subsection{Contents}
\tableofcontents

\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu} 

\subsection{Changes history} 
\begin{description}
\item[1.1] Initial Draft.
\item[1.3] First draft released. 
\item[2.1] Draft.  Beginning of attempt to conform to ``House Style''. 

\end{description}
\subsection{Changes forecast}
Closer convergence with the house style  -- the ICL Visual Identity Manual -- is to be achieved. Items outstanding are:
\begin{itemize}
\item wide-column format
\item page headers and footers
\item removal of this document-control section so that the present section 0.5 (`About this Document') becomes the whole of 
an un-numbered opening `chapter'.
\end{itemize}




%%%% 222222    for book-style

\documentstyle[hol1]{book}
    \advance\parskip by 0.5\baselineskip
    \parindent 0pt  
    \oddsidemargin 17pt   % was 44pt
    \evensidemargin 36pt  % was 82pt
    \marginparwidth 0pt   % was 107pt

\columnsep 10pt
\columnseprule 0pt
\footskip 30pt
\headheight 45pt
\headsep 10pt
\advance\hoffset by -0.3in
\marginparpush 5pt
\marginparsep 0pt
\textheight = 9.15in
\textwidth 6.6in
\topmargin 0pt
\topsep 0pt
\advance\voffset by -0.6in


\raggedbottom
\ftlinepenalty=9999
\makeindex

\title{ICL HOL \\  \  \\t u t o r i a l}
\author{ }

\begin{document}

\begin{titlepage}
\vspace*{4in}
\begin{center}

{\Large ICL HOL \\  \  \\ TUTORIAL  \\  \  \\ \today}

\vfill

\bf Copyright \copyright\ : International Computers Ltd 1992

\end{center}

\end{titlepage}

% \maketitle
%  \vfill
% \begin{centering}
% \bf Copyright \copyright\ : International Computers Ltd 1992
% \end{centering}

% \cleardoublepage
\setcounter{chapter}{-1}

\section{ABOUT THIS PUBLICATION} \label{intro}
\subsection{Purpose}

This document, one of several making up the user documentation for the ICL HOL system,  contains a tutorial introduction to the  system.
\subsection{Readership}

This document is intended to be the first item read by new users of HOL. It takes the form of a tutorial for learning the basic points of the structure and use of the system.  It is assumed that the reader is familiar with predicate logic.


\subsection{Related Publications}

\newcommand\DESCRIPTION{{\footnotesize\sl DESCRIPTION}}
\newcommand\REFERENCE{{\footnotesize\sl REFERENCE MANUAL}}

\begin{enumerate}
\item {\em DESCRIPTION}: \cite{DS/FMU/IED/USR005}, a description of higher order logic
 and theorem proving methods in the HOL system;
\item {\em REFERENCE}: \cite{DS/FMU/IED/USR006}, the reference documentation of the tools available in HOL.
\item Supplementary Guides: a collection of documents on special topics, notably the Installation Guide, \cite{DS/FMU/IED/USR007}.
\end{enumerate}

 The first two of these publications will be referred to as \DESCRIPTION\ and \REFERENCE\ throughout.  A bibliography is given at the end of this document.

\subsection{Area Covered}

The tutorial  is an introductory HOL course which gives an idea of the way HOL is used, but which does not systematically explain the underlying principles. (The second document, {\em DESCRIPTION}, explains the principles.)
After working through  this tutorial,
the reader should be capable of using HOL for simple tasks, and should also be in a
position to approach the other two documents.


Once the HOL system is installed on the user's workstation,  this tutorial should enable the potential HOL user to become familiar with the following subjects:

\begin{enumerate}
\item The programming metalanguage Standard ML, and how to interact
with it through an editor.  The description of  Standard ML given here is very brief, only intended to be sufficient to support the exposition of HOL. For a more complete introduction to Standard ML the reader is referred to  \cite{WIKSTROM87}, \cite{HARPER88} or  \cite{PAULSON91}. 
\item The formal logic supported by 
the HOL system (higher order logic) and its manipulation via Standard ML.
\item Forward proof and derived rules of inference.
\item Goal directed proof, and tactics and tacticals.
\end{enumerate}

The sections that follow cover these topics in the sequence shown above. This tutorial has been kept as short as possible so that
the installation of the system and
steps 1
to 4 can be mastered reasonably quickly. 

\subsection{Assumptions}

It is presumed  in what follows, if the reader is following the tutorial at a workstation and trying out the examples interactively,  that the installation procedure  been performed  successfully and that the user has available an installed HOL system.


\subsection{Acknowledgements}

These documents have drawn very heavily on \cite{SRI89B}, \cite{SRI89A} and \cite{SRI89C}.

\cleardoublepage
\tableofcontents


%%%% 333333
%%%% 444444

%  Mike Gordon's original Definitions

% =====================================================================
%
% Macros for typesetting the HOL system manual
%
% =====================================================================

% ---------------------------------------------------------------------
% Abbreviations for words and phrases
% ---------------------------------------------------------------------
\newcommand\VERSION{{\small\tt 1.10}}
\newcommand\TUTORIAL{{\footnotesize\sl INTRODUCTION}}
% \newcommand\DESCRIPTION{{\footnotesize\sl DESCRIPTION}}
% \newcommand\REFERENCE{{\footnotesize\sl REFERENCE MANUAL}}

\def\HOL{{\small HOL}}
\def\LCF{{\small LCF}}
\def\LCFLSM{{\small LCF{\kern-.2em}{\normalsize\_}{\kern0.1em}LSM}}
\def\PPL{{\small PP}{\kern-.095em}$\lambda$}
\def\PPLAMBDA{{\small PPLAMBDA}}
\def\SML{{\small Standard ML}}

\newcommand\ie{\mbox{i{.}e{.}}}
\newcommand\eg{\mbox{e{.}g{.}}}
\newcommand\viz{\mbox{viz{.}}}
\newcommand\adhoc{\mbox{\it ad hoc}}
\newcommand\etal{{\it et al.\/}}
\newcommand\etc{\mbox{etc{.}}}
\def\see#1#2{{\em see\/} #1}

% ---------------------------------------------------------------------
% Simple abbreviations and macros for mathematical typesetting
% ---------------------------------------------------------------------

\newcommand\fun{{\to}}
\newcommand\prd{{\times}}

\newcommand\conj{\ \wedge\ }
\newcommand\disj{\ \vee\ }
\newcommand\imp{ \Rightarrow }
\newcommand\eqv{\ \equiv\ }
\newcommand\cond{\rightarrow}
\newcommand\vbar{\mid}
\newcommand\turn{\ \vdash\ }
\newcommand\hilbert{\varepsilon}
\newcommand\eqdef{\ \equiv\ }

\newcommand\natnums{\mbox{${\sf N}\!\!\!\!{\sf N}$}}
\newcommand\bools{\mbox{${\sf T}\!\!\!\!{\sf T}$}}

\newcommand\p{$\prime$}
\newcommand\f{$\forall$\ }
\newcommand\e{$\exists$\ }

\newcommand\orr{$\vee$\ }
\newcommand\negg{$\neg$\ }

\newcommand\arrr{$\rightarrow$}
\newcommand\hex{$\sharp $}

\newcommand{\uquant}[1]{\forall #1.\ }
\newcommand{\equant}[1]{\exists #1.\ }
\newcommand{\hquant}[1]{\hilbert #1.\ }
\newcommand{\iquant}[1]{\exists ! #1.\ }
\newcommand{\lquant}[1]{\lambda #1.\ }

\newcommand{\leave}[1]{\\[#1]\noindent}
\newcommand\entails{\mbox{\rule{.3mm}{4mm}\rule[2mm]{.2in}{.3mm}}}

% --------------------------------------------------------------------- 
% Font-changing commands
% ---------------------------------------------------------------------

\newcommand{\theory}[1]{\hbox{{\small\tt #1}}}

\newcommand{\con}[1]{{\sf #1}}
\newcommand{\rul}[1]{{\tt #1}}
\newcommand{\ty}[1]{{\sl #1}}
\newcommand{\ml}[1]{\mbox{\small\tt #1}}
\newcommand\ms{\tt}
\newcommand{\s}[1]{{\small #1}}
\newcommand{\pin}[1]{{\bf #1}}
\def\m#1{\mbox{\normalsize$#1$}}

% ---------------------------------------------------------------------
% Abbreviations for particular mathematical constants etc.
% ---------------------------------------------------------------------

\newcommand\T{\con{T}}
\newcommand\F{\con{F}}
\newcommand\OneOne{\con{One\_One}}
\newcommand\OntoSubset{\con{Onto\_Subset}}
\newcommand\Onto{\con{Onto}}
\newcommand\TyDef{\con{Type\_Definition}}
\newcommand\Inv{\con{Inv}}
\newcommand\com{\con{o}}
\newcommand\Id{\con{I}}
\newcommand\MkPair{\con{Mk\_Pair}}
\newcommand\IsPair{\con{Is\_Pair}}
\newcommand\Fst{\con{Fst}}
\newcommand\Snd{\con{Snd}}
\newcommand\Suc{\con{Suc}}
\newcommand\Nil{\con{Nil}}
\newcommand\Cons{\con{Cons}}
\newcommand\Hd{\con{Hd}}
\newcommand\Tl{\con{Tl}}
\newcommand\Null{\con{Null}}
\newcommand\ListPrimRec{\con{List\_Prim\_Rec}}
\newcommand\SimpRec{\con{Simp\_Rec}}
\newcommand\SimpRecRel{\con{Simp\_Rec\_Rel}}
\newcommand\SimpRecFun{\con{Simp\_Rec\_Fun}}
\newcommand\PrimRec{\con{Prim\_Rec}}
\newcommand\PrimRecRel{\con{Prim\_Rec\_Rel}}
\newcommand\PrimRecFun{\con{Prim\_Rec\_Fun}}
\newcommand\bool{\ty{bool}}
\newcommand\num{\ty{num}}
\newcommand\ind{\ty{ind}}
\newcommand\lst{\ty{list}}

% ---------------------------------------------------------------------
% \minipagewidth = \textwidth minus 1.02 em
% ---------------------------------------------------------------------

\newlength{\minipagewidth}
\setlength{\minipagewidth}{\textwidth}
\addtolength{\minipagewidth}{-1.02em}

% ---------------------------------------------------------------------
% Environment for the items on the title page of a case study
% ---------------------------------------------------------------------

\newenvironment{inset}[1]{\noindent{\large\bf #1}\begin{list}%
{}{\setlength{\leftmargin}{\parindent}%
\setlength{\topsep}{-.1in}}\item }{\end{list}\vskip .4in}

% ---------------------------------------------------------------------
% Macros for little HOL sessions displayed in boxes.
%
% Usage: (1) \setcounter{sessioncount}{1} resets the session counter
%
%	 (2) \begin{session}\begin{verbatim}
%	      .
%	       < lines from hol session >
%	      .
%	     \end{verbatim}\end{session}   
%
%            typesets the session in a numbered box.
% ---------------------------------------------------------------------

\newlength{\hsbw}
\setlength{\hsbw}{\textwidth}
\addtolength{\hsbw}{-\arrayrulewidth}
\addtolength{\hsbw}{-\tabcolsep}
\addtolength{\hsbw}{-0.5in}
 % \addtolength{\hsbw}{0.25in}
\newcommand\HOLSpacing{13pt}

\newcounter{sessioncount}
\setcounter{sessioncount}{1}

\newenvironment{session}{\begin{center}
 \begin{tabular}{@{}|c@{}|@{}}\hline 
 \begin{minipage}[b]{\hsbw}
 \vspace*{-.5pt}
 \begin{flushright}
 \rule{0.01in}{.15in}\rule{0.3in}{0.01in}\hspace{-0.35in}
 \raisebox{0.04in}{\makebox[0.3in][c]{\footnotesize\sl \thesessioncount}}
 \end{flushright}

  \vspace*{-.25in}

 \begingroup\small\baselineskip\HOLSpacing}{\endgroup\end{minipage}\\ \hline 
 \end{tabular}
 \end{center}
 \stepcounter{sessioncount}}

% ---------------------------------------------------------------------
% Macro for boxed ML functions, etc.
%
% Usage: (1) \begin{boxed}\begin{verbatim}
%	        .
%	        < lines giving names and types of mk functions >
%	        .
%	     \end{verbatim}\end{boxed}   
%
%            typesets the given lines in a box.  
%
%            Conventions: lines are left-aligned under the "g" of begin, 
%	     and used to highlight primary reference for the ml function(s)
%	     that appear in the box.
% ---------------------------------------------------------------------

\newenvironment{boxed}{\begin{flushleft}
 \begin{tabular}{@{}|c@{}|@{}}\hline 
 \begin{minipage}[b]{\hsbw}
% \vspace*{-.55in}
 \vspace*{.06in}
 \begingroup\small\baselineskip\HOLSpacing}{\endgroup\end{minipage}\\ \hline 
 \end{tabular}
 \end{flushleft}}

% ---------------------------------------------------------------------
% Macro for unboxed ML functions, etc.
%
% Usage: (1) \begin{hol}\begin{verbatim}
%	        .
%	        < lines giving names and types of mk functions >
%	        .
%	     \end{verbatim}\end{hol}   
%
%            typesets the given lines exactly like {boxed}, except there's
%	     no box.  
%
%            Conventions: lines are left-aligned under the "g" of begin, 
%	     and used to display ML code in verbatim, left aligned.
% ---------------------------------------------------------------------

\newenvironment{hol}{\begin{flushleft}
 \begin{tabular}{c@{}@{}}
 \begin{minipage}[b]{\hsbw}
% \vspace*{-.55in}
 \vspace*{.06in}
 \begingroup\small\baselineskip\HOLSpacing}{\endgroup\end{minipage}\\
 \end{tabular}
 \end{flushleft}}

% ---------------------------------------------------------------------
% Emphatic brackets
% ---------------------------------------------------------------------

\newcommand\leb{\lbrack\!\lbrack}
\newcommand\reb{\rbrack\!\rbrack}

% ---------------------------------------------------------------------
% Snow watching lantern
% ---------------------------------------------------------------------

\newcommand\medlantern{{\makebox[3.652in][l]{
  \vbox to 3.875in{\vfill\special{psfile=../LaTeX/HOL_med.ps}}
  \vspace{-\baselineskip}}}}

% The stuff below does not work
% ---------------------------------------------------------------------
% New \part with JVT's snow watching lantern
% ---------------------------------------------------------------------

%\def\part{\cleardoublepage \thispagestyle{plain} \if@twocolumn \onecolumn
%\@tempswatrue \else \@tempswafalse \fi \hbox{}\vfil \secdef\@part\@spart} 


%\def\@part[#1]#2{\ifnum \c@secnumdepth >-2\relax \refstepcounter{part}
%\addcontentsline{toc}{part}{\thepart \hspace{1em}#1}\else
%\addcontentsline{toc}{part}{#1}\fi \markboth{}{}
% {\centering \ifnum \c@secnumdepth >-2\relax \huge\bf Part \thepart \par
%\vskip 20pt \fi \Huge \bf #1\par}\@endpart} 
%\def\@endpart{\medlantern\vfil\newpage \if@twoside \hbox{} \thispagestyle{empty} 
% \newpage 
% \fi \if@tempswa \twocolumn \fi} 
%\def\@spart#1{{\centering \Huge WONK \bf #1\par}\@endpart}

% Counter Peano used in logic.tex 
\newcounter{Peano} 
\setcounter{Peano}{1}


   \setlength{\unitlength}{1mm}		  % unit of length = 1mm
   \setlength{\baselineskip}{16pt}        % line spacing = 16pt



\ftaboveboxskip=5pt plus 2pt minus 2pt
\ftbelowboxskip=5pt plus 2pt minus 2pt

\long\def\suppress#1{}

\pagebreak

% *********************************************************************
% HOL Manual LaTeX Source: tutorial
% *********************************************************************
   
%   \pagenumbering{arabic}		 % arabic page numbers
%   \setcounter{page}{1}	         % start at page 1

   \label{getting-started}

% section General Introduction goes here
%  \include{new-preface}
% \chapter*{Preface}\markboth{Preface}{Preface}

	  
\cleardoublepage

\cleardoublepage
\section{GETTING STARTED} \label{install}

\subsection{Configuring the Screen}
A convenient way to interact with \SML\ is to configure the workstation screen so that
there are two windows:
\begin{itemize}
\item A text-editor window into which \SML\ commands are initially typed and recorded.
\item A shell window which is used to execute the
commands.
\end{itemize}


After typing a command into the text-editor window it can be transferred  by `cut-and-paste' to the
shell window and executed in {\HOL}. The advantage of working through an editor is that
if the command contains an error, then the text can simply be edited and used again.  In addition, the editor
also records the commands in a file which can then be used again later as a script. 



\subsection{Keyboard}
This section covers the layout of the keyboard for the extended character set.

{\ShowAllImages
A representative keyboard is arranged in the pattern below.  On each key is shown the following information. 
\begin{itemize}
\item Top left: The main engraving on the
key. 
\item Top right: The name of any keyboard accelerator associated with the
key.  
\item Line beginning {\tt M} : The character resulting from the key when pressed together with the META key.
\item Line beginning {\tt +S} : The character resulting from the key when pressed together with the META and SHIFT keys.
\item Line beginning {\tt +C} : The character resulting from the key when pressed together with the META and CONTROL keys.
\end{itemize}

Thus, META+`{\tt W}' yields ``\PrPH'',
META+SHIFT+`{\tt W}' yields ``\PrNH'' and META+CONTROL+`{\tt W}' yields
``\PrJH''. {} Enclosing a character in parentheses indicates that
it is not returned when keyboard accelerators are active. Note that META+CONTROL+`{\tt E}' is is shown as a solid bar which
indicates that the key is not assigned.  }

%  \vfill
\vspace*{0.25in}

{\input{usr001A.tex}
\makeatletter
\def\@moan#1{\nuldef}
\makeatother
\UNITHEIGHT=2\UNITHEIGHT
\ShowAllImages
\let\KEY=\LONGSHOWKEY
\let\SHIFT=\LONGSHIFTKEY
\KEYBOARDiv
}

\subsection{Entering HOL}


The HOL system is entered by a command at the UNIX prompt, invoking the \SML\ system and giving as parameter the name of a {\em database}.  Here a database is a UNIX file containing  a comparatively large collection  of \SML\ definitions which constitutes the HOL system. The user will need to identify the name of a suitable database, and this may depend upon how \HOL\ has been installed.   An example of a suitable command is :

\begin{quote}
     {\tt poly  example.db}
\end{quote}

Note that the name of the command as well as the name of a suitable database may depend on how the \HOL\ system has been installed.  After entering  the  \HOL\  system,  the  user  is  prompted 
 for an expression  or command of the  \HOL\ metalanguage \SML.  A line of user input following a prompt will (in this tutorial) be marked by a vertical line on the left, with `SML` in small letters to symbolize a prompt for the input of Standard ML, thus: 
 
\vspace*{0.25in}

=SML

=TEX  

The system response which follows the user's input will be marked by a vertical line on the left, thus:

\vspace*{0.25in}

=GFT

=TEX 

The reader may find it desirable to have to hand vendor-specific documentation on the \SML\ system in use.  This may show, for example, how to recover from a syntax error in input.

\subsection{Leaving HOL}
To leave the \HOL\ system and return to UNIX, the user types, at the \SML\ prompt: 
=SML
      hol_quit();
=TEX
\subsection{Sessions}

Throughout this tutorial, the sequences of user's interactions with the system and the system's responses are called `sessions'. 
All sessions in this documentation are displayed in numbered boxes.
This number indicates whether the session  is a new
one (when the number will be {\small\sl  1}) or  the continuation  of a session
started in an earlier box.  Consecutively numbered boxes are assumed to be part
of a single continuous session. In particular, variable bindings made in earlier boxes are assumed
to persist to later ones in the same sequence. 


=TEX
\cleardoublepage
\section{INTRODUCTION TO STANDARD ML}
\label{ML}

This chapter is a brief introduction to the metalanguage \SML.  The aim  of this chapter is to explain  only enough of \SML\ to make the following chapters comprehensible.   For a more complete introduction to \SML\ the reader is referred to  \cite{WIKSTROM87}, \cite{HARPER88} or  \cite{PAULSON91}. 

\SML\ is an interactive programming language.  When interacting directly with the system, (which is called `at the top level') one can
evaluate expressions and perform declarations.  

\subsection{Expressions}

\setcounter{sessioncount}{1}

\begin{session}
=SML 
    1+1;
=TEX
=GFT
    val it = 2 : int   
=TEX
\end{session}

This box shows an example of entering a \SML\ expression through the keyboard (that is, `at the top level'), which is then evaluated and the result displayed.  The  semicolon `\ml{;}'  is used to terminate a top-level phrase. The display of the result can be seen\footnote{with the version of Standard ML currently in use} to consist of:
\begin{itemize}
\item The letters 
=INLINEFT
val
=TEX
, indicating that a value is to follow.
\item A name for the value.  In this case the user has not supplied any name, having merely typed in the anonymous expression 
=INLINEFT
1+1
=TEX
, and so the system supplies the name $it$.   The value of the most-recently-entered anonymous expression at the top level can always be referred to as $it$.
\item  The symbol $=$. 
\item The value, in this case $2$.  
\item A colon followed by an indication of the type of the value.  In this case, the value 2 is of type integer, abbreviated to $int$.  The \SML\ type checker infers the type of expressions using methods invented by Robin Milner, \cite{MILNER78}. 
\end{itemize}

\subsection{Lists and Strings}.
The  \SML\ expression 
=INLINEFT
[2,3,4,5]
=TEX
{}  is a list of four integers. 
\begin{session}
=SML 
    [2,3,4,5];
=GFT
    val it = [2, 3, 4, 5] : int list   
=TEX
\end{session}

The type 
=INLINEFT
int list
=TEX
{} is the type of `lists of
integers'; 
=INLINEFT
list
=TEX
{} is a unary type operator.  The type system of \SML\
is very similar to the type system of the \HOL\ logic which is explained in
Chapter~\ref{HOLlogic}.


Expressions such as
=INLINEFT
"a", "b", "foo"
=TEX
{}   are {\it strings\/} and have type
=INLINEFT
string
=TEX
.  Any sequence of {\small ASCII} characters can be
written between the quotes. The  infix function  
=INLINEFT
^
=TEX
{} concatenates two strings to form a single string.

\begin{session}
=SML 
    "tog" ^ "ether";
=GFT
    val it = "together" : string   
=TEX
\end{session}

\subsection{Declarations}
A declaration may have the form 
=INLINEFT
val n = e 
=TEX 
,  which results in the value of the expression 
=INLINEFT
e
=TEX
{} being bound to the name
=INLINEFT
n
=TEX
. 

\begin{session}
=SML 
      val x = 42;
=GFT
      val x = 42 : int

=SML
      x + 1;
=GFT
      val it = 43 : int   
=TEX

\end{session}


\subsection{Function Applications}
The application of a function
$f$ to an argument $x$ can be written as $f\ x$. The more conventional  $f$ \ml{(}$x$\ml{)} 
is also allowed.  The expression $f\ x_1\ x_2\ \cdots\ x_n$ abbreviates the less
intelligible expression {\small\verb%(%}$\cdots${\small\verb%((%}$f\ 
x_1${\small\verb%)%}$x_2${\small\verb%)%}$\cdots${\small\verb%)%}$x_n$. That is, function application is left associative. 

Functions may be infix, as in the case of 
=INLINEFT
+
=TEX
, or the function 
=INLINEFT
::
=TEX
{} which constructs  a list from its left argument as head and right argument (a list) as tail. 

Other list processing functions include 
=INLINEFT
hd
=TEX
{} (take the head of a list), 
=INLINEFT
tl
=TEX
{} (take the tail of a list)  and 
=INLINEFT
is_nil
=TEX
{} (which tests for an empty list).  



\begin{session}
=SML 
    val L = 1:: [2, 3, 4, 5];
=GFT
    val L = [1, 2, 3, 4, 5] : int list   
=SML 
    hd L;
=GFT
    val it = 1 : int   
=SML 
    tl L;
=GFT
    val it = [2, 3, 4, 5] : int list   
=SML 
    tl(tl(tl(tl it)));
=GFT
    val it = [] : int list   
=TEX
\end{session}



\subsection{Pairs and Tuples}

An expression of the form
=INLINEFT
(e‰1, e‰2)
=TEX
{} evaluates to a
pair of the values of
=INLINEFT
e‰1
=TEX
{} and 
=INLINEFT
e‰2
=TEX
. If
=INLINEFT
e‰1
=TEX
{} has type 
=INLINEFT
Ó‰1
=TEX
{} and
=INLINEFT
e‰2
=TEX
{} has type 
=INLINEFT
Ó‰2
=TEX
{}  then
=INLINEFT
(e‰1, e‰2)
=TEX
{} has type
=INLINEFT
Ó‰1 * Ó‰2
=TEX
.  A tuple
=INLINEFT
(e‰1, ..., e‰n)
=TEX
{} is  NOT in general  equivalent to
=INLINEFT
(e‰1, (e‰2, ..., e‰n))
=TEX
.  The first and
second components of a pair (but not a tuple of length greater than two)  can be extracted with the \SML\ functions
=INLINEFT
fst
=TEX
{} and 
=INLINEFT
snd
=TEX
{} respectively. The i'th component of a tuple can be extracted with a function the name of which is of the form 
=INLINEFT
#i
=TEX
. 

\begin{session}
=SML 
    (1, 2, (true, "abc"));
=GFT
    val it = (1, 2, (true, "abc")) : int * int * (bool * string) 
=TEX

=SML 
    #3 it;
=GFT
    val it = (true, "abc") : bool * string   
=TEX

=SML 
    snd it;
=GFT
    val it = "abc" : string   
=TEX
\end{session}

\noindent The \SML\ expressions
=INLINEFT
true
=TEX
{} and 
=INLINEFT
false
=TEX
{} 
denote the two truth values of type {
=INLINEFT
bool
=TEX
.

\subsection{Polymorphic Types}


\SML\ types can contain the {\it type variables\/}
=INLINEFT
'a
=TEX
,  
=INLINEFT
'b
=TEX
,  \etc\ Such types are called {\it
polymorphic\/}. A function with a polymorphic type should be thought of as
possessing all the types obtainable by replacing type variables by types.
An example of a function with polymorphic  type is   
=INLINEFT
hd
=TEX
{} (head of a list), which is applicable to lists of any type:

\begin{session}
=SML
      hd;
=GFT
      val it = fn : 'a list -> 'a   
=TEX
\end{session}

\subsection{Declarations of Functions}


The function which, for example, computes $x+1$ from $x$ can be defined and given a name, say,    
=INLINEFT
step
=TEX
, as follows:

\begin{session}
=SML 
      fun step x = x + 1;
=GFT
      val step = fn : int -> int   
=SML
      step 6;
=GFT
      val it = 7 : int   
=TEX
\end{session}

The declaration 
=INLINEFT
fun step x = x + 1
=TEX
{} is a convenient abbreviation for 
=INLINEFT
val step = fn x => x + 1
=TEX
. 

\begin{session}
=SML 
      val step = fn x => x + 1;
=GFT
      val step = fn : int -> int   
=SML
      step 6;
=GFT
      val it = 7 : int   
=TEX
\end{session}


Here 
=INLINEFT
fn x => x + 1
=TEX
{} is an expression of which the value is a function.  In what follows, it will be common  for the arguments or results of functions themselves to be functions.   This is an important feature of \SML\  which makes it suitable as a metalanguage for {\HOL}. The following example illustrates how  function-valued expressions may be used to define functions which return functions as results.   In this example,   
=INLINEFT
twice
=TEX
{} is a function which takes a function as argument and returns another as a result, such that applying the result-function is equivalent  to applying the argument-function twice.  

\begin{session}
=SML 
      fun twice f = fn x => f (f x);
=GFT
      val twice = fn : ('a -> 'a) -> 'a -> 'a   
=SML
      val hop = twice step;
=GFT
      val hop = fn : int -> int 
=SML
      hop 6; 
=GFT
      val it = 8 : int  
=SML
      (twice tl) [1, 3, 5, 7];
=GFT
      val it = [5, 7] : int list   
=TEX
\end{session}

Again the syntactic abbreviation may be employed to give a neater definition of twice:

\begin{session}
=SML 
      fun twice f x = f (f x);
=GFT
      val twice = fn : ('a -> 'a) -> 'a -> 'a   
=SML
      twice step 6;
=GFT
      val it = 8 : int   
=TEX
\end{session}

Note particularly that the expression 
=INLINEFT
twice step 6
=TEX 
{} is equivalent to
=INLINEFT 
(twice step) 6
=TEX
.  The  declaration above,  
=INLINEFT
fun twice f x = f (f x)
=TEX
,  is an example of the general form of declaration of a function,  
=INLINEFT
fun f v‰1 ... v‰n = e
=TEX
{} where each 
=INLINEFT
v‰i
=TEX
{} is an argument and 
=INLINEFT
e 
=TEX
{} is an expression. 

As a final example, a useful built-in function is 
=INLINEFT
map
=TEX
{} which applies its function-argument to each member of a list to produce a list:

\begin{session}
=SML 
      map step [1, 3, 5];
=GFT
      val it = [2, 4, 6] : int list   
 
=TEX
\end{session}



The sessions  above  are enough  to give  an idea of \SML.   
In the  next sections,  the logic  supported by  the \HOL\  system (higher order
logic) will be introduced, together with the tools in \SML\ for manipulating it.

=TEX
\cleardoublepage
\section{INTRODUCTION TO THE HOL LOGIC}
\label{HOLlogic}

The \HOL\  system  supports {\it  higher order  logic}.   This is  a version of
predicate calculus with three main extensions:

\begin{itemize}
\item Variables can range over functions and predicates
(hence `higher order').
\item The logic is {\it typed}.
\item There is no separate syntactic category of {\it formulae\/}
(terms of type \ml{bool} fulfil their role).
\end{itemize}

\subsection{Overview of higher order logic}

It is assumed  the reader  is familiar  with predicate  logic.   The syntax and
semantics of  the particular  logical  system  supported  by \HOL\  is described in
detail in  \DESCRIPTION.   The table  below summarizes the
notation used.


\bigskip

\begin{center}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{3}{|c|}{ } \\
\multicolumn{3}{|c|}{\bf Terms of the HOL Logic} \\
\multicolumn{3}{|c|}{ } \\
{\it Kind of term} & {\it \HOL\ notation} & {\it Description} \\ \hline
                   &                      &                    \\ 
Truth              & $T$                  & {\it true}        \\ \hline
Falsity            &  $F$                 & {\it false}       \\ \hline
Negation           & ³$t$                 & {\it not}$\ t$       \\ \hline
Disjunction        & $t_1$²$t_2$          & $t_1\ ${\it or}$\ t_2$    \\ \hline
Conjunction        & $t_1$±$t_2$         & $t_1\ ${\it and}$\ t_2$     \\ \hline
Implication        & $t_1$´$t_2$         & $t_1\ ${\it implies}$\ t_2$ \\ \hline
Equality           & $t_1 \ = \ t_2$      & $t_1\ ${\it equals}$\ t_2$   \\ \hline
$\forall$-quantification & µ$x$·$t$            & {\it for\ all\ }$x: t$       \\ \hline
$\exists$-quantification & ¶$x$·$t$            & {\it for\ some\ }$x: t$       \\ \hline
$\hilbert$-term   & $ \hilbert \ x$·$t$        &  {\it an}$\ x\ ${\it such\ that:}$\ t$ \\ \hline
Conditional       & {\it if\ }$t${\it \ then\ }$t_1${\it\ else\ }$t_2$  & {\it if\ }$t${\it \ then\ }$t_1${\it\ else\ }$t_2$  \\ \hline
\end{tabular}
\end{center}\label{logic-table}

\bigskip


Terms of the \HOL\ logic are represented in \SML\ by an {\it abstract
type\/}\footnote{Abstract types appear to  the user  as primitive  types with a
collection of operations}   called 
=INLINEFT
TERM
=TEX
.   They are represented as character strings which are input, not between the  usual quotation symbols but  rather  between
the symbols 
=INLINEFT
¬ 
=TEX
{} and
=INLINEFT
®
=TEX
.   For example,  the expression  
=INLINEFT
¬ x ± y ´ z® 
=TEX
{} evaluates in \SML\ to a term representing 
=INLINEFT
x ± y ´ z 
=TEX
. Terms can be manipulated by various built-in \SML\ functions.   For  example, the \SML\ function 
=INLINEFT
dest_´
=TEX
{}  with  \SML\  type 
=INLINEFT
TERM -> TERM * TERM
=TEX
{} splits an implication into  a pair  of terms  consisting of  its antecedent and
consequent, and the \SML\ function 
=INLINEFT
dest_±
=TEX
{} of  type 
=INLINEFT
TERM -> TERM * TERM
=TEX
{} splits a conjunction into its two conjuncts.

\setcounter{sessioncount}{1}
\begin{session}

=SML 
      ¬x±y´z®;
=TEX
=GFT
      val it = ¬x ± y ´ z® : TERM   
=SML 
      dest_´ it; 
=GFT
      val it = (¬x ± y®, ¬z®) : TERM * TERM   
=SML 
      dest_± (fst it);
=GFT
      val it = (¬x®, ¬y®) : TERM * TERM   
=TEX
\end{session}

Terms of the \HOL\ logic are quite similar in appearance to \SML\ expressions, but the distinction must be carefully observed.  Indeed, terms of the logic have types  in a way which is similar  to the way in which
\SML\ expressions have types.   For example, 
=INLINEFT
¬1®
=TEX
{} is  a \SML\ expression with \SML\ type 
=INLINEFT
TERM
=TEX
.  The \HOL\ type of this term is 
=INLINEFT
:î
=TEX
, the type of the natural numbers. 

The types of \HOL\ terms form a \SML\ type called 
=INLINEFT
TYPE
=TEX
. Expressions having the form
=INLINEFT
¬: ....® 
=TEX
{} evaluate to logical  (that is, \HOL\ ) types.  The built-in function  
=INLINEFT
type_of
=TEX
{} has \SML\ type 
=INLINEFT
TERM -> TYPE
=TEX
{} and returns the logical type of a term.

\begin{session}
=SML 
      ¬(1,2)®;
=GFT
      val it = ¬(1, 2)® : TERM   
=SML 
      type_of it;
=GFT
      val it = ¬:î ¸ î® : TYPE   
=SML 
      (¬1®, ¬2®);
=GFT
      val it = (¬1®, ¬2®) : TERM * TERM
=SML 
      type_of (fst it);
=GFT
      val it = ¬:î® : TYPE   
=TEX
\end{session}


To emphasise the distinction between between   the \SML\ types of \SML\ expressions and the logical types of \HOL\ terms 
, the former will be referred to as {\it metalanguage types\/} and the latter as {\it object language types\/}.

\index{metalanguage} \index{object language}


\HOL\ terms can be input using explicit {\it quotation\/}, as above, using 
=INLINEFT
¬ 
=TEX
{} and 
=INLINEFT
® 
=TEX
{} for quotation marks,  or they can be constructed using \SML\ constructor functions. The function
=INLINEFT
mk_var
=TEX
{}  constructs a variable from a string and a type.  In the example below, three  terms are constructed, each representing a single object-language variable  of type  
=INLINEFT
BOOL
=TEX
, and  metalanguage names  are chosen for the terms  to  coincide with the names of the object-language variables.  These are used later.

\begin{session}
=SML 
      val x = mk_var("x",¬:BOOL®) 
      and y = mk_var("y",¬:BOOL®)
      and z = mk_var("z",¬:BOOL®);
=GFT
      val x = ¬x® : TERM 
      val y = ¬y® : TERM  
      val z = ¬z® : TERM   
=TEX
\end{session}

\typeout{logic point 8}

The constructors 
=INLINEFT
mk_±
=TEX
{} and  
=INLINEFT
mk_´
=TEX
{} construct conjunctions and implications respectively.

\begin{session}
=SML 
      val t = mk_´(mk_±(x,y),z);
=GFT
      val t = ¬x ± y ´ z® : TERM   
=TEX
\end{session}

\subsection{Terms}

There are only four different kinds of terms:
\begin{enumerate}
\item Variables.
\item Constants.
\item Function applications: 
=INLINEFT
¬t‰1 t‰2®
=TEX
\item $\lambda$-abstractions: 
=INLINEFT
¬Ì x · t ®
=TEX
.
\end{enumerate}
\index{Terms, four different kinds of}

Both variables and constants have a name and a type; the difference is that
constants cannot be bound by quantifiers, and their type is fixed when they are
declared (see below). The type checking algorithm uses the types of constants to
infer the types of variables in the same quotation. If there is not enough type
information to constrain the assignment of a type, then an assignment of the most general type, that is,   involving a {\em type-variable}, will result:


\begin{session}
=SML 
      ¬³x®;
=GFT
      val it = ¬³ x® : TERM   
=SML 
      dest_³ it;
=GFT
      val it = ¬x® : TERM   
=SML 
      type_of it;
=GFT
      val it = ¬:BOOL® : TYPE   
=SML 
      ¬x®;
=GFT
      val it = ¬x® : TERM   
=SML 
      type_of it;
=GFT
      val it = ¬:'a® : TYPE   
=TEX
\end{session}

In the first case, the \HOL\ type checker  used the  known type 
=INLINEFT
BOOL ­ BOOL
=TEX
{} of 
=INLINEFT
³
=TEX
{} to  deduce  that  the  variable 
=INLINEFT
x
=TEX
{} must  have  type
=INLINEFT
BOOL
=TEX
.  In the second case, it assigns the most general  type to
=INLINEFT
x
=TEX
.      The    `scope'  of type  information for type
checking is a single quotation, so a  type in  one quotation  cannot effect the
type checking of another.     If there  is not enough
contextually-determined type information to resolve the types  of all variables
in a quotation, then it may be necessary to explicitly indicate  the required types
by using 
=INLINEFT
¬term:type®
=TEX
{} as illustrated below.

\typeout{logic point 9}

\begin{session}
=SML 
      ¬x:î®;
=GFT
      val it = ¬x® : TERM 
=SML 
      type_of it;
=GFT
      val it = ¬:î® : TYPE   
=TEX
\end{session}

Functions have types of the form 
=INLINEFT
Ó‰1­Ó‰2
=TEX
, where 
=INLINEFT
Ó‰1
=TEX
{} and
=INLINEFT
Ó‰2
=TEX
{} are the types of the domain and range of the function, respectively.


Before considering an example of the types of functions, an aside is appropriate on  a purely syntactic matter.
 Functions may be defined with a special syntactic status, such as being  an infix operator, in the case of 
=INLINEFT
+
=TEX
{} or  
=INLINEFT
±
=TEX
,  or having non-standard precedence, in the case  of 
=INLINEFT
³
=TEX
.  In such cases, putting  
=INLINEFT
$ 
=TEX
{} in front of the name of the function causes the parser to ignore any special syntactic status it may have.   
 This means that the naked symbol 
=INLINEFT
±
=TEX
{} is not  in itself a syntactically well-formed expression,  because it denotes the application of the function to arguments which are missing. 
However the expression 
=INLINEFT
$±
=TEX
{} is well-formed in itself, denoting a function, and it can be applied to arguments.

\begin{session}
=SML 
      ¬±®;
=GFT
      Syntax error in: ¬  <?> ± 
      ± is not expected after ¬ 
      Exception- Fail * Syntax error [HOL-Parser.19000] * raised=TEX
=SML 
      ¬$±®;
=GFT
      val it = ¬$±® : TERM   
=SML 
      type_of it;
=GFT
      val it = ¬:BOOL ­ BOOL ­ BOOL® : TYPE   
=SML  
      ¬$± t1 t2®;
=GFT
      val it = ¬t1 ± t2® : TERM   
=TEX
\end{session}

After that aside, we return now to the subject of the types of  functions.  Functions can be denoted by  Lambda-terms (or $\lambda$-terms).  For example,
=INLINEFT
¬Ìx· x+1®
=TEX
{} is a term that denotes the function which maps a number $x$ to a number $x+1$, and is thus of type 
=INLINEFT
î ­ î
=TEX
.

\begin{session}
=SML  
      ¬Ìx · x+1®;
=GFT
      val it = ¬Ì x· x + 1® : TERM   
=SML  
      type_of it;
=GFT
      val it = ¬:î ­ î® : TYPE   
=TEX
\end{session}


The next box provides further examples of metalanguage and object-language types. 


\begin{session}
=SML 
      ¬(x+1), (t1´t2)®;
=GFT
      val it = ¬(x + 1, t1 ´ t2)® : TERM 
=SML 
      type_of it;
=GFT
      val it = ¬:î ¸ BOOL® : TYPE   
=SML 
      (¬x=1®, ¬t1´t2®);
=GFT
      val it = (¬x = 1®, ¬t1 ´ t2®) : TERM * TERM   
=SML 
      (type_of(fst it), type_of(snd it));
=GFT
      val it = (¬:BOOL®, ¬:BOOL®) : TYPE * TYPE   
=TEX
\end{session}


The types of constants are declared in {\it theories}; this is described
in Section~\ref{theories}.

An application
=INLINEFT
t‰1 t‰2
=TEX
{} is badly typed if 
=INLINEFT
t‰1 
=TEX
{} is not a function:


\begin{session}
=SML 
      ¬1 2®;
=GFT
      Type error in ¬1 2®
      The operator must have type Ó ­ Ô
      Cannot apply ¬1:î®
                to ¬2:î®
      Exception- Fail * Type error [HOL-Parser.16000] * raised
=TEX

\end{session}

or if it is a function, but 
=INLINEFT
t‰2
=TEX
{} is not in its domain:

\begin{session}

=SML 
       ¬³1®;
=GFT
      Type error in ¬³ 1®
      The operator and the operand have incompatible types
      Cannot apply ¬³:(BOOL­BOOL)®
                to ¬1:î®
      Exception- Fail * Type error [HOL-Parser.16000] * raised
=TEX
\end{session}



\subsection{Boolean Terms, Theorems and  Sequents}

So far, in the language of \HOL\ terms, we have seen terms of different object-language types, including  those of object-language type 
=INLINEFT
¬:BOOL®
=TEX
.

The \HOL\ system supports a process of  inference which results in the production of {\em theorems}.  Theorems are objects of metalanguage type 
=INLINEFT
THM
=TEX
. Terms are not theorems, that is, the metalanguage types
=INLINEFT
TERM
=TEX
{} and 
=INLINEFT
THM
=TEX
{} are distinct. The form taken by  a theorem in this system of inference is not simply as  a boolean-valued term but rather as a composite of:
\begin{itemize}
\item  a list of assumptions, each of which represents a boolean-valued term
\item  a conclusion, which represents a single boolean-valued term.  
\end{itemize}

The following session produces an example  of a theorem  to illustrate this structure of assumptions and conclusion.   The example is produced by means which are yet to be described, but will be covered in following sections.  


\begin{session}
=SML 
      tac_proof (([¬x=y®, ¬y=z®], ¬x=z®), (asm_rewrite_tac[]));
=GFT
      val it = x = y, y = z ô x = z : THM   
=TEX
\end{session}

It can be seen that the turnstile symbol, 
=INLINEFT
ô
=TEX
, separates assumptions from conclusion.  This theorem can be understood as meaning: on the assumption that x=y and the further assumption  that y=z, it may be concluded that x=z.   The theorem is about the relationship between assumptions and conclusion (that the latter follows from the former).  The ``truth'' of the theorem is the truth of an assertion about what follows from what.


Strictly speaking, all theorems in this system are about the relationship between assumptions and conclusions, but in practice  many theorems have no assumptions.  Here is another example of a theorem produced by means yet to be described:

\begin{session}
=SML 
      refl_conv ¬x®;
=GFT
      val it = ô x = x : THM   
=TEX
\end{session}

This can be understood as meaning ``without making any assumptions, it may be concluded  that x=x''.   Here the list of assumptions mentioned above is  present, but is empty and so nothing is displayed for it.

Terms can be constructed at will, (subject only to the constraint of being well-typed.)
 On the other hand, theorems can be constructed only by a proof which appeals to the rules of inference supported by the system.\index{theorems, construction only by proof}   The soundness of the system of inference and the correctness of the implementation guarantee the  ``truth'' (theoremhood) of any theorems produced, and ensure that theorems can only be produced by the prescribed system of inference.

Objects structured according to the pattern described above as a list of assumptions followed by a conclusion are called ``sequents''.  In this sense, theorems may be called sequents, so that the \HOL\ system of inference is described as a sequent calculus; see e.g. \cite{SRI89B}.  

The system  supports ``sequents''  by providing, as an abbreviation for 
=INLINEFT
TERM list * TERM
=TEX
,  the name
=INLINEFT
SEQ
=TEX
.  Sequents  in this other sense are, needless to say, NOT theorems, just data-structures.  Their usefulness is (as shown in the example of producing the first theorem above) in convenience in stating goals for a proof process, so much so that the system also supports the abbreviation \ml{GOAL} for the same type.   This is illustrated in the next session, where the same object is ascribed a type which is reported in three different ways. 


\begin{session}
=SML 
      val s =([¬x=y®, ¬y=z®], ¬x=z®);
=GFT
      val s = ([¬x = y®, ¬y = z®], ¬x = z®) : TERM list * TERM 
=SML 
      s:SEQ;
=GFT
      val it = ([¬x = y®, ¬y = z®], ¬x = z®) : SEQ   
=SML 
      s:GOAL;
=GFT
      val it = ([¬x = y®, ¬y = z®], ¬x = z®) : GOAL  
=TEX
\end{session}



\typeout{logic point 13}

\subsection{Theories}
\label{theories}  \index{theories, in HOL}
\subsubsection{Introduction}

The result of a session with the \HOL\ system is an object called a {\it
theory\/}.  This object is closely related to what a logician would call a
theory, but there are some differences arising from the needs of mechanical
proof. 
 A \HOL\ theory, like a logician's theory, contains sets of types,
constants, definitions and axioms.  In addition, however, a \HOL\ theory
contains an explicit list of theorems that have been proved from the axioms
and definitions.
 Logicians normally do not need to distinguish theorems that
have actually been proved from those that could be proved, hence they do not
normally consider sets of proven theorems as part of a theory; rather, they
take the theorems of a theory to be the (often infinite) set of all
consequences of the axioms and definitions. 
 Another difference between
logicians' theories and \HOL\ theories is that, for logicians, theories are
relatively static objects, but in \HOL\ they can be thought of as potentially
extendable. For example, the \HOL\ system provides tools for adding to
theories and combining theories. 
 A typical interaction with HOL consists in
combining some existing theories, making some definitions, proving some
theorems and then saving the resulting new theory.

The purpose of the \HOL\ system is to provide tools to enable well-formed
theories to be constructed.  All the theorems of such theories are logical
consequences of the definitions and axioms of the theory.  The \HOL\ system
ensures that only well-formed theories can be constructed by allowing
theorems to be created by {\it formal proof\/} only. 


A theory is stored in the \HOL\ system in what is called a theory database, where a theory database itself is represented by files in the filing system of the computer.  Thus a theory database is what is stored between sessions of interaction with the \HOL\ system.

Theories are related  to each other by a hierarchy so as  to represent sequences of extensions of
an initial theory called 
=INLINEFT
hol
=TEX
.  By  ``extension'' is meant that one theory may make use of definitions, axioms or theorems of another, ``parent'',  theory, and thus in effect incorporate them into itself.
Each theory  contains
some types, constants, axioms and
theorems, together with
pointers to other theories, its {\it parents\/}. 
The parents, parents of parents and so on  are  called the {\it
ancestry\/} of the theory. Axioms, definitions
and theorems are named in the \HOL\ system by two strings: the name of the theory
 where they are stored, together with a name within that theory for the particular axiom, definition or theorem,  supplied by the
user.

Specifically,
axioms, definitions and theorems
are named by a pair of strings $\langle thy,name\rangle$ 
where $thy$ is the name of the
theory current when the item was declared and $name$
is a specific name supplied by the user.

A typical piece of work with the \HOL\ system consists in a number of sessions. In
the first of these a new theory, ${\cal T}$ say, is created by extending existing
theories with a number of definitions.   In subsequent
sessions this theory is extended by proving new theorems which will become part of 
the theory ${\cal T}$. The logical meaning of these sessions is that a new
extended version of ${\cal T}$ is created which replaces the old version.  Subsequent
pieces of work can build on (\ie\ extend) the definitions and theorems of ${\cal
T}$ by making ${\cal T}$ a parent of further new theories.

In principle a whole hierarchy of theories can be stored in a single theory database. 
 In practice however it may be more convenient to distribute a theory-hierarchy over several databases,  themselves organised into a hierarchy.  
For example, such an arrangement would allow a common database to be read-only,  and others deriving from it to be, in the course of  development,  updatable. 
 Similar arrangements are possible  within a single database: an individual theory may have a status of ``locked'' to prevent casual changes. 
 Thus facilities for the management of theories are available both at the level of the individual theory and at the level of the database. No more will be said on this topic in this tutorial, which will proceed on the assumption of a single database.

At any stage in the development of a theory, a stored record can be made, recording  what has been achieved so far,  by causing an update to the  current database, which is called ``committing'' the whole current state of the \HOL\ system to the database.  This is effected by issuing the single \SML\ command which, in the case of the system in use at the time of writing, is,  
=INLINEFT
PolyML.commit();
=TEX
. 


There is always a {\it current theory\/}; its name can be discovered by the function
=INLINEFT
get_current_theory_name
=TEX
.  This function maps the value called {\em unit}, written
=INLINEFT
()
=TEX
{} in \SML, to a string giving the name of the current theory.
Thus the \SML\ expression
=INLINEFT
get_current_theory_name ()
=TEX
{} evaluates to a string giving the name of the current
theory.  Initially the  current theory is
called 
=INLINEFT
hol
=TEX
.   So evaluating 
=INLINEFT
get_current_theory_name()
=TEX
{} immediately after initiating a \HOL\ session gives a value dependent upon the state of the database in use:

\setcounter{sessioncount}{1}
\begin{session}
=SML 
      get_current_theory_name();
=GFT
      val it = "hol" : string   
=TEX
\end{session}

One more point remains to be made.  It has been explained that the state of a \HOL\ session can be saved,  and then retrieved on a later occasion.  Within the state of the \HOL\ session, there will be theorems and other objects: axioms, definitions, constants and so on.   Now a  theorem, for example,  can be associated with a name, in the state of the \HOL\ session, in either or both of two ways, which are distinct.

Firstly, a theorem is a \SML\ value like any other, in that it can be associated with a \SML\ name by the familiar process, seen many times above, of making a declaration:

\begin{session} 
=SML 
      val thm99 = refl_conv ¬x®;
=GFT
      val thm99 = ô x = x : THM   
=TEX
\end{session}

The value, and the association with the name, will survive the saving and retrieving of the state of the \HOL\ session.

Secondly,  the current theory is represented by a data structure within the state of the current session.   This data structure has no \SML\ name, but is instead provided with a number of access functions by which its contents may be inspected, extracted, and updated. 
 For example, the function 
=INLINEFT
print_theory
=TEX
{} enables the content of the theory to be inspected.  There is a function 
=INLINEFT
save_thm
=TEX
{} which takes two arguments, a string and a theorem, and causes the theorem to be saved in the data structure which is the theory and  to be stored within the theory under the name given by the string. 
The theorem can be recovered from the theory by another access function, 
=INLINEFT
get_thm
=TEX
, which takes as arguments the  theory name (the current theory can be referred to by the name
=INLINEFT
"-"
=TEX
) and the name under which the theorem was stored. 
 Note that there is no necessary connection between this string and the name of any \SML\ variable used to hold a theorem.  To emphasize the point, note that the string need not be a well-formed name.
\index{theorems, saving  with \ml{save\_thm}}  
\index{theorems, retrieving with \ml{get\_thm}} 
\index{theories, viewing with \ml{print\_theory}}

\begin{session}
=SML 
      save_thm ("theorem of 5 September 91", thm99);
=GFT
      val it = ô x = x : THM   
=SML 
      get_thm "-" "theorem of 5 September 91";
=GFT
      val it = ô x = x : THM 
=TEX
\end{session} 

\subsubsection{Example of Developing a New Theory}

In this section an example is given of developing a new theory, which is chosen to be a treatment of Peano's postulates as axioms for the natural numbers.    It is to be noted that there is already a theory built into HOL, called 
=INLINEFT
î
=TEX
, which covers natural numbers and arithmetic, (in which Peano's postulates  are  in  fact  derived  theorems rather  than postulated as axioms).  To emphasize that this example theory is just an example, and has no relation to
=INLINEFT
î
=TEX
{} except superficial resemblance, the example theory will be called 
=INLINEFT
Peanissimo
=TEX
.  

Executing  
=INLINEFT
new_theory "thy"
=TEX
{} creates a new  theory called  
=INLINEFT
thy
=TEX
; it fails if there already exists a theory so named in the current theory hierarchy.


\begin{session}
=SML 
      new_theory "Peanissimo";
=GFT
      val it = () : unit
=TEX
\end{session}

\typeout{point 16}

This starts a theory called 
=INLINEFT
Peanissimo
=TEX
,  which is to be  made into a
theory containing Peano's postulates as axioms for the natural
numbers. These postulates, stated informally, are:

\begin{list}{{\small\bf P\arabic{Peano}}}{\usecounter{Peano}
\setlength{\leftmargin}{12mm}
\setlength{\rightmargin}{7mm}
\setlength{\labelwidth}{6mm}
\setlength{\labelsep}{2mm}
\setlength{\listparindent}{0mm}
\setlength{\itemsep}{14pt plus1pt minus1pt}
\setlength{\topsep}{3mm}
\setlength{\parsep}{0mm}}

\item There is a number which we will call $zero$.
\item There is a function  which we will call $successor$  such that 
if $n$ is a number then  the successor of $n$ is a number.
\item $zero$ is not the $successor$ of any number.
\item If two numbers have the same $successor$ then they are equal.
\item If a property holds of $zero$, and if whenever it holds of a number then it
also holds of the $successor$ of that number, then the property holds of all
numbers. This postulate is called {\it Mathematical Induction}.
\end{list}

To formalize this in \HOL\ a new type is introduced called 
=INLINEFT
nat
=TEX
{} (for natural number)

\index{types, object-language, introducing with \ml{new\_type}}

\begin{session}
=SML 
      new_type ("nat", 0);
=GFT
      val it = ¬:nat® : TYPE 
=TEX
\end{session}

In general 
=INLINEFT
new_type ("op" n) 
=TEX
{} makes
=INLINEFT
op
=TEX
{} a new $n$-ary type operator in the current theory. 
Constant types  (such as
=INLINEFT
BOOL
=TEX
{} or 
=INLINEFT
î
=TEX
) are regarded as degenerate type operators with no arguments, thus
the new type 
=INLINEFT
nat
=TEX
{} is declared to be a $0$-ary type operator. An example of a $1$-ary type operator is  
=INLINEFT
LIST
=TEX
, occurring in for example  
=INLINEFT
¬[a;b;c] : î LIST®;
=TEX
{} and an example of a 2-ary type operator is
=INLINEFT
¸
=TEX
{} occurring in for example 
=INLINEFT
¬(x,y) : BOOL ¸ î®;
=TEX
. 


The axioms {\small\bf P1} and {\small\bf P2} can now be formalized by declaring
two new constants to represent $zero$ and $successor$. 

Evaluating 
=INLINEFT
new_const("c", Ó)
=TEX
{} makes 
=INLINEFT
c
=TEX
{} a new constant of type 
=INLINEFT
Ó
=TEX
{} in the current theory.
This fails if there already exists a constant named  
=INLINEFT
c
=TEX
{} in the current theory (or a parent  of the current theory).

\begin{session}
=SML 
      new_const ("zero", ¬:nat®);
=GFT
      val it = ¬zero® : TERM
=SML 
      new_const ("successor", ¬:nat­nat®);
=GFT
      val it = ¬successor® : TERM
=TEX
\end{session}



The \HOL\ type checker ensures that {\small\bf P1} and {\small\bf P2} hold.
{\small\bf P3} is now asserted as an axiom:
\index{axioms, introducing with \ml{new\_axiom}}

\begin{session}
=SML 
       new_axiom(["P3"], ¬µn· ³(zero = successor n)® );
=GFT
       val it = ô µ n· ³ zero = successor n : THM
=TEX
\end{session}

\noindent This creates an axiom in the current theory (that is,  in 
=INLINEFT
Peanissimo
=TEX
) called
=INLINEFT
P3
=TEX
. Axiom  
=INLINEFT
P4
=TEX
{} can be declared similarly:


\begin{session}

=SML 
       new_axiom(["P4"], ¬µm n ·(successor m = successor n) ´ (m = n)®);
=GFT
       val it = ô µ m n· successor m = successor n ´ m = n : THM
=TEX

\end{session}

The final Peano axiom is Mathematical Induction:

\begin{session}
=SML 
      new_axiom(["P5"],¬µ P· P zero ± (µ n · P n ´ P(successor n)) ´ (µn· P n)®);
=GFT
      val it = ô µ P· P zero ± (µ n· P n ´ P (successor n)) ´ (µ n· P n) : THM   
=TEX
\end{session}

\typeout{point 21}
\clearpage
To inspect the theory, the function 
=INLINEFT
print_theory
=TEX
{} can be used:

\begin{session}
=SML 
print_theory "-";
=GFT
       === The theory Peanissimo ===

       --- Parents ---

                hol

       --- Constants ---

        zero            nat
        successor       nat ­ nat

       --- Types ---

       nat

       --- Axioms ---

       P3              ô µ n· ³ zero = successor n
       P4              ô µ m n· successor m = successor n ´ m = n
       P5              ô µ P· P zero ± (µ n· P n ´ P (successor n)) ´ (µ n· P n)

       === End of listing of theory Peanissimo ===
=TEX
\end{session}


To end the session and make an  update to the database in use, recording all the work of the session including the new theory,  the current state of the session is saved to the database,  by executing 
=INLINEFT
hol_save();
=TEX
{} after which an exit can be made back to UNIX, by executing the \SML\ command 
=INLINEFT
hol_quit();
=TEX
.

\begin{session}

=SML 
      hol_save();
=GFT
      10104 bytes copied
      example.db:3670016 bytes
      Closing example.db now
      Opening example.db
      Opening /hat/nih/bin/poly_2.04/ML_dbase
=SML 
      hol_quit();
=TEX
\end{session}


The preceding session set up a first version of a theory,  
=INLINEFT
Peanissimo
=TEX
. It is usual to include in `Peano arithmetic' axioms defining addition and multiplication.
To do this a new session can be started and the theory further developed.  

\begin{session}

\begin{verbatim}
UNIX>  poly example.db
\end{verbatim}

=GFT
      .... sign-on message ....
=SML 
      get_current_theory_name();
=GFT
      val it = "Peanissimo" : string   
=TEX

\end{session}

The two new axioms can now be added, but first constants 
 must  be  declared  to  represent  addition  and  multiplication.   Let us choose the names 
=INLINEFT
pplus
=TEX
{} and
=INLINEFT
ptimes
=TEX
{} respectively for these.  Since we wish to use these  syntactically in the same way as 
=INLINEFT
+
=TEX
{} and
=INLINEFT
*
=TEX
, that is,  as infix operators with appropriate values for syntactic precedence, they are declared as such with  {\em fixity} declarations
=INLINEFT
declare_infix 
=TEX
{}  followed by 
=INLINEFT
new_const
=TEX
. Constants declared with 
=INLINEFT
declare_infix
=TEX
{} must have a type of the form
\ml{$\sigma_1$­$\sigma_2$­$\sigma_3$}.

\index{fixity, of constants, declaring} \index{constants, introducing with \ml{new\_const}}

\begin{session}
=SML 
      declare_infix (300, "pplus");
      declare_infix (310, "ptimes");
=GFT
      val it = () : unit   
      val it = () : unit
=SML 
      new_const ("pplus", ¬:nat­nat­nat®);
      new_const ("ptimes", ¬:nat­nat­nat®);

=GFT
      val it = ¬$pplus® : TERM   
      val it = ¬$ptimes® : TERM
=TEX
\end{session}



Axioms defining 
=INLINEFT
pplus
=TEX
{} and \
=INLINEFT
ptimes
=TEX
{} can now be given.

\begin{session}
=SML 
      new_axiom(["pplus_def"],
         ¬(µn· (zero pplus n) = n) ± 
          (µm n·((successor m) pplus n) = successor (m pplus n) )® );
=GFT
      val it = ô (µ n· (zero pplus n) = n) ±
                 (µ m n· (successor m pplus n) = successor (m pplus n)) : THM
=TEX

=SML 
      new_axiom(["ptimes_def"],
          ¬(µn· (zero ptimes n) = zero) ± 
           (µm n·((successor m) ptimes n) = ((m ptimes n) pplus n)  )® );
=GFT
      val it = ô (µ n· (zero ptimes n) = zero) ±
                 (µ m n· (successor m ptimes n) = (m ptimes n pplus n)) : THM
=TEX
 
\end{session}

The theory 
=INLINEFT
Peanissimo
=TEX
{} has now been extended to contain the new definitions.

This example shows how a theory is set up. How to prove consequences of axioms and
definitions is described later. The \HOL\ system contains a built-in
theory of numbers called 
=INLINEFT
î
=TEX
{} which contains Peano's postulates and  the definitions of addition 
=INLINEFT
(+)
=TEX
{} and multiplication 
=INLINEFT
(*)
=TEX
{} amongst others.
In fact, Peano's 
postulates are theorems not axioms in the theory 
=INLINEFT
î
=TEX
. The  constants
=INLINEFT
0
=TEX
{} and 
=INLINEFT
Suc
=TEX
{} (corresponding to 
=INLINEFT
zero
=TEX
{} and 
=INLINEFT
successor
=TEX 
in 
=INLINEFT
Peanissimo
=TEX
)  are {\it defined\/} in terms of purely logical notions.
In \HOL, {\it definitions\/} are a special kind of axiom that are
guaranteed to be consistent. The commonest (but not only) form of a definition is: 

\[f\ x_1\ \ldots\ x_n = t\]

where $f$ is declared to be a new constant satisfying this
equation (and $t$ is a term whose free variables are included in the set
$\{x_1,\ldots,x_n\}$).  Such definitions cannot be recursive because, for
example: 

\[ f\ x = (f\ x)+1 \]

\noindent would imply $0=1$ (subtract $f\ x$ from both sides)
and is therefore inconsistent. An example of a definition is:

\begin{session}
=SML 
      simple_new_defn  (["Double_def"], "Double", ¬Ìx· (x pplus x)®);
=GFT
      val it = ô Double = (Ì x· x pplus x) : THM
=TEX

\end{session}

This definition both declares 
=INLINEFT
Double
=TEX 
{} as a new constant of the
appropriate type and asserts the defining equation as a definitional axiom.  The theory is now shown by:

\typeout{point 050}
\clearpage
\begin{session}
=SML 
print_theory "-";
=GFT
 === The theory Peanissimo ===

--- Parents ---

                hol

--- Constants ---

zero            nat
successor       nat ­ nat
$pplus          nat ­ nat ­ nat
$ptimes         nat ­ nat ­ nat
Double          nat ­ nat

--- Types ---

nat

--- Fixity ---

Infix 40:       pplus
Infix 41:       ptimes

--- Axioms ---

P3              ô µ n· ³ zero = successor n
P4              ô µ m n· successor m = successor n ´ m = n
P5              ô µ P· P zero ± (µ n· P n ´ P (successor n)) ´ (µ n· P n)
pplus_def       ô (µ n· (zero pplus n) = n) ±
                  (µ m n· (successor m pplus n) = successor (m pplus n))
ptimes_def      ô (µ n· (zero ptimes n) = zero) ±
                  (µ m n· (successor m ptimes n) = (m ptimes n pplus n))

--- Definitions ---

Double_def      ô Double = (Ì x· x pplus x)

 === End of listing of theory Peanissimo ===
val it = () : unit   
=TEX
   

\end{session}


To repeat the point made earlier, the theory 
=INLINEFT
Peanissimo
=TEX
{} is presented here solely as small example of the development of a theory.  In one important respect it is atypical, and that is in the introduction of axioms. The use of axioms, as illustrated here, carries considerable  danger in general
because it is very easy to assert inconsistent axioms.  It is thus safer to use
only definitions.  At first sight this might appear impossible, but in fact all
of ordinary  mathematics  can  be  developed  from  logic  by definition alone.
Showing this was  the achievement  of Russell  and Whitehead  in their treatise
{\sl Principia  Mathematica}  \cite{WHITEHEAD10}.   

A theory  containing  only
definitions is called a {\it definitional theory\/}.   
A number of useful definitional theories  are built-in to the \HOL\ system, and are shown in the {\REFERENCE}.   Examples
include theories of numbers, sets, pairs and lists.   Indeed it is particularly important to note that with a single exception,  {\em all} the built-in theories are purely definitional.  The exception is the built-in theory 
=INLINEFT
init
=TEX
{} which contains the five primitive axioms of {\HOL}.  By inspecting the theories listed in the {\REFERENCE}, it may be seen that 
=INLINEFT
init
=TEX
{} is the only theory containing axioms, and all else is built up by  a process of definition.


\cleardoublepage 
\section{INTRODUCTION TO PROOF WITH HOL}
\label{proof}


For a logician, a formal proof is a sequence, each of whose  elements is
either an {\it axiom\/} or follows from earlier members of the sequence by a
{\it rule of inference\/}.  A theorem is the last element of a proof.


Theorems are represented in \HOL\ by values of an abstract
type called 
=INLINEFT
THM
=TEX
.  The  only way  to create theorems is by generating a
proof.  In \HOL\ (following \LCF), this consists in applying \SML\ functions
representing {\it rules of inference\/} to  axioms or previously generated
theorems.  The sequence of such applications  directly corresponds to a
logician's proof.

There are five axioms of the \HOL\ logic and eight primitive
inference rules. The axioms are bound to \SML\ names. For example, the Law of
Excluded Middle is bound to the \SML\ name 
=INLINEFT
bool_cases_axiom
=TEX
:

\begin{session}
=SML 
      bool_cases_axiom;
=GFT
      val it = ô µ b· (b ¤ T) ² (b ¤ F) : THM   
=TEX
\end{session}

Theorems are printed with a turnstile
=INLINEFT
ô
=TEX
{} as illustrated above.   Rules of inference are \SML\ functions that
return values of type 
=INLINEFT
THM
=TEX
.  An example of a rule of inference is {\it
specialization\/} (or $\forall - elimination$). 
In standard `natural deduction'
notation this might be:

\[ \Gamma\turn \uquant{x}t\over \Gamma\turn t[t'/x]\]

where
 $t[t'/x]$ denotes the result of substituting $t'$ for free
occurrences of $x$ in $t$, with the restriction that no free variables in $t'$
become bound after substitution.

\typeout{proof point 1}

A rule very similar to this is represented in \SML\ 
by a function
=INLINEFT
simple_µ_elim
=TEX
\footnote{This function is not a 
primitive rule of inference in the HOL logic, but is a derived rule. Derived rules
are described in Section~\ref{forward}.  Further, 
=INLINEFT
simple_µ_elim
=TEX
{} differs from the rule shown above in that the capture of bound variables is automatically avoided by renaming where necessary.} 
which takes as arguments a term
=INLINEFT
¬a®
=TEX
{} and a theorem 
=INLINEFT
ôµx·t[x]
=TEX
{} and returns the theorem 
=INLINEFT
ôt[a]
=TEX
, the result of substituting
=INLINEFT
a
=TEX
{} for 
=INLINEFT
x
=TEX
{} in 
=INLINEFT
t[x]
=TEX
. 

\setcounter{sessioncount}{1}

\begin{session}
=SML 
      val Th1 = bool_cases_axiom;  
=GFT
      val Th1 = ô µ b· (b ¤ T) ² (b ¤ F) : THM   
=SML 
      val Th2 = simple_µ_elim ¬1 = 2® Th1;
=GFT
      val Th2 = ô (1 = 2 ¤ T) ² (1 = 2 ¤ F) : THM   
=TEX
\end{session}


This session consists of a proof of two steps: using an axiom and
applying the rule  
=INLINEFT
simple_µ_elim
=TEX
; it interactively performs the following proof:


\begin{enumerate}
\item $\turn \uquant{t} t= T \ \disj\  t= F $ \hfill
[Axiom 
=INLINEFT
bool_cases_axiom
=TEX
]
\item $\turn (1{=}2)=T\ \disj\ (1{=}2)=F$\hfill [Specializing line 1 to `$1{=}2$']
\end{enumerate}

If the argument to an \SML\ function representing a rule of inference is of the
wrong kind, or violates a condition of the rule, then the application fails.
For example, 
=INLINEFT
µ_elim t th 
=TEX
{} will fail if 
=INLINEFT
th
=TEX
{} is not of the form  $ô µ x· \cdots$ 
or if it is of this form but the type of 
=INLINEFT
t
=TEX
{} is not the same
as the type of 
=INLINEFT
x
=TEX
.
\begin{session}
=SML  
      simple_µ_elim ¬1 = 2®  Th2; 
=GFT
      Exception-
         Fail
            * ô (1 = 2 ¤ T) ² (1 = 2 ¤ F) is not of the form: `‡ ô µ x · t' where
            ¬x® is a variable [simple_µ_elim.7039] * raised
=SML 
      simple_µ_elim ¬1®  Th1;
=GFT
      Exception-
         Fail * ¬b® and ¬1® do not have the same types [simple_µ_elim.3012] *    raised
=TEX
\end{session}



A proof in the \HOL\ system is constructed by repeatedly applying inference
rules to axioms or to previously proved theorems.
Since proofs may consist of millions of steps, it is necessary to provide
tools to make proof construction easier for the user.  The proof generating
tools in the \HOL\ system are described later.


The general form of a theorem is  $t_1,\ldots,t_n\ $\ml{ô}$\  t$, where $t_1$,
$\ldots$ , $t_n$ are boolean terms called  the {\it  assumptions} and  $t$ is a
boolean term called the {\it conclusion\/}.  Such a theorem asserts that if its
assumptions are true then so is its conclusion.  Its truth  conditions are thus
the same as those for the single term \ml{$(t_1$ ± $\ldots $ ± $t_n$) ´ $t$. } Theorems  with  no  assumptions are printed
out in the form \ml{ô$\ t$}.


The five  axioms and  eight primitive  inference rules  of the  \HOL\ logic are
described in  detail in  the document \DESCRIPTION.  Every
value of  type 
=INLINEFT
THM
=TEX
{} in  the  \HOL\ system  can be  obtained by repeatedly
applying primitive inference rules to axioms.  When the \HOL\  system is built,
the eight  primitive rules  of inference  are defined  and the  five axioms are
bound to their \SML\ names. All other predefined theorems are proved using rules
of inference as the system is made.\footnote{This is a slight
over-simplification.} 

In the rest of this section, the  process of  {\it forward  proof\/}, which has
just been sketched, is decribed in more detail.   In section~\ref{tactics} below, {\it
goal directed proof\/} is  described, including  the important  notions of {\it
tactics\/} and {\it tacticals\/}, due to Robin Milner.

\subsection{Forward proof}
\label{forward}

Three of the primitive inference rules of the \HOL\ logic are
\begin{itemize}
\item  
=INLINEFT
asm_rule
=TEX
{} (assumption introduction),
\item 
=INLINEFT
´_intro 
=TEX
{} (discharging, that is, eliminating,  an assumption by introducing an implication) and
\item
=INLINEFT
´_elim
=TEX
{} (eliminating an implication, that is, Modus Ponens).
\end{itemize}

These rules will be used to illustrate forward proof and the writing of derived
rules. 
The inference rule 
=INLINEFT
asm_rule
=TEX
{} generates theorems of the form \ml{$t$ ô $t$}.  The function
=INLINEFT
dest_thm
=TEX
{} decomposes a theorem into a pair consisting of list of
assumptions and the conclusion. The \SML\ type 
=INLINEFT
SEQ
=TEX
, or  
=INLINEFT
GOAL
=TEX
,  abbreviates 
=INLINEFT
TERM list * TERM
=TEX
; this is motivated in Section~\ref{tactics}.

\begin{session}
=SML 
      val Th3 = asm_rule ¬t1´t2®;
=GFT
      val Th3 = t1 ´ t2 ô t1 ´ t2 : THM   
=SML 
      dest_thm Th3;
=GFT
      val it = ([¬t1 ´ t2®], ¬t1 ´ t2®) : SEQ   
=TEX
\end{session}

The primitive inference rule
=INLINEFT
´_intro
=TEX
{} (discharging, assumption elimination) infers from
a theorem of the form $\cdots t_1\cdots \ml{ô}t_2$ the new theorem
$\cdots\ \cdots\ \ml{ô}\ t_1\ml{´}t_2$. 
=INLINEFT
´_intro
=TEX
{} takes as arguments
the term to be discharged (\ie\ $t_1$) and the theorem from whose
assumptions it is to be discharged and returns the result of the discharging.
The following session illustrates this:
\begin{session}
=SML 
      val Th4 = ´_intro ¬t1´t2® Th3;
=GFT
      val Th4 = ô (t1 ´ t2) ´ t1 ´ t2 : THM   
=TEX
    
\end{session}


In \HOL\,  the  rule   of  Modus  Ponens  is  specified in conventional
notation by:  

\[ \Gamma_1 \turn t_1 \imp t_2 \qquad\qquad \Gamma_2\turn t_1\over
\Gamma_1 \cup \Gamma_2 \turn t_2\]

Corresponding to Modus Ponens, the \SML\ function
=INLINEFT
´_elim
=TEX
{} takes argument theorems of the
form \ml{$\cdots\ $ ô $\ t_1$\ ´\ $t_2$} and \ml{$\cdots\ $ ô $\ t_1$}
and returns \ml{$\cdots\ $ ô $\ t_2$}. The next session illustrates the use of
=INLINEFT
´_elim
=TEX
{}  and  illustrates also a common error, namely not supplying the \HOL\ logic type
checker with enough information. 

\begin{session}
=SML 
      val Th5 = asm_rule  ¬t1®;
=GFT
      Exception- Fail * ¬t1® is not of type ¬:BOOL® [asm_rule.3031] * raised
=SML 
      val Th5 = asm_rule  ¬t1:BOOL®;
=GFT
      val Th5 = t1 ô t1 : THM   
=SML 
      val Th6 = ´_elim Th3 Th5;
=GFT
      val Th6 = t1 ´ t2, t1 ô t2 : THM   
=TEX

\end{session}

The assumptions of 
=INLINEFT
Th6
=TEX
{} can be extracted with the \SML\ function 
=INLINEFT
hyps
=TEX
, (``hypotheses'')
which returns the list of assumptions of a theorem. The conclusion  of a theorem is returned by the function 
=INLINEFT
concl
=TEX
.

\begin{session}
=SML 
      hyps Th6;
=GFT
      val it = [¬t1 ´ t2®, ¬t1®] : TERM list   
=TEX
\end{session}

Discharging 
=INLINEFT
Th6
=TEX
{} twice establishes the theorem $ ô \ t1  \ ´ \  (t1 ´ t2) ´ t2 $.

\begin{session}
=SML  
      val  Th7 = ´_intro  ¬t1´t2® Th6; 
=GFT
      val Th7 = t1 ô (t1 ´ t2) ´ t2 : THM   
=TEX

=SML 
val  Th8 = ´_intro ¬t1:BOOL® Th7; 
=GFT
val Th8 = ô t1 ´ (t1 ´ t2) ´ t2 : THM   
=TEX

\end{session}



The sequence:  $Th3, \ Th5, \ Th6,  \ Th7, \ Th8 $
 constitutes a proof in \HOL\ of
the theorem \[ô \ t1 ´ (t1 ´ t2) ´ t2 \]   This
proof could be written:

\begin{enumerate}
\item $ t_1\imp t_2\turn t_1\imp t_2$ \hfill
[Assumption introduction]
\item $ t_1\turn t_1$ \hfill
[Assumption introduction]
\item $t_1\imp t_2,\ t_1 \turn t_2 $ \hfill
[Modus Ponens applied to lines 1 and 2]
\item $t_1 \turn (t_1\imp t_2)\imp t_2$ \hfill
[Discharging the first assumption of line 3]
\item $\turn t_1 \imp (t_1 \imp t_2) \imp t_2$ \hfill
[Discharging the only assumption of line 4]
\end{enumerate}

\subsection{Derived rules}


A {\it proof from hypothesis $th_1, \ldots, th_n$} is a sequence each of whose
elements is either an axiom, or one of the hypotheses $th_i$, or follows from
earlier elements by a rule of inference.

For example, a proof of $\Gamma,\ t'\turn t$ from the hypothesis
$\Gamma\turn t$ is:


\begin{enumerate}
\item $t'\turn t'$ \hfill [Assumption introduction]
\item $\Gamma\turn t$ \hfill [Hypothesis]
\item $\Gamma\turn t'\imp t$ \hfill [`Discharge' $t'$ from line 2]
\item $\Gamma,\ t'\turn t$ \hfill [Modus Ponens applied to lines 3 and 1]
\end{enumerate}

Note that line 3 above mentions `discharging' the assumption $t'$, but $t'$ is not actually amongst the assumptions.  The rule 
=INLINEFT
´_intro
=TEX
{} does not in fact require its term argument ($t'$) to be present in the assumptions of its theorem argument (line 2).

This proof works for any hypothesis of the form $\Gamma\turn t$ 
and any boolean term $t'$ and
shows that the result of adding an arbitary hypothesis to a theorem is another
theorem (because the four lines above can be added to any proof of
$\Gamma\turn t$ to get a proof of $\Gamma,\ t'\turn t$).\footnote{This property
of the logic is called {\it monotonicity}.} For example,
the next session uses this proof to add the hypothesis 
=INLINEFT
t3
=TEX
{} to
=INLINEFT
Th6
=TEX
.


\begin{session}
 
=SML 
      val  Th9 = asm_rule ¬t3:BOOL®; 
=GFT
      val Th9 = t3 ô t3 : THM   
=SML 
      val  Th10 = ´_intro ¬t3:BOOL® Th6; 
=GFT
      val Th10 = t1 ´ t2, t1 ô t3 ´ t2 : THM   
=SML 
      val Th11 = ´_elim Th10 Th9; 
=GFT
      val Th11 = t1 ´ t2, t1, t3 ô t2 : THM   
=TEX
\end{session}


A {\it derived rule\/} is a \SML\ procedure that generates a proof from given hypotheses
each time it is invoked. The hypotheses are the arguments of the rule.
To illustrate this, a rule, called 
=INLINEFT
ADD_ASSUM
=TEX
, will now be defined as an \SML\ procedure that carries
out the proof above. In standard notation this would be described by:

\[ \Gamma\turn t\over \Gamma,\ t'\turn t \]

The \SML\ definition is:

\begin{session} 
=SML 
      fun  ADD_ASSUM t th =
       let val th9  = asm_rule t
           val th10 = ´_intro t th
       in
       ´_elim th10 th9
       end; 
=GFT
      val ADD_ASSUM = fn : TERM -> THM -> THM
=SML 
      ADD_ASSUM ¬t3:BOOL® Th6; 
=GFT
      val it = t1 ´ t2, t1, t3 ô t2 : THM   
=TEX
\end{session}

The body of 
=INLINEFT
ADD_ASSUM
=TEX
{} has been coded  to mirror  the proof done
in session~9 above, so as to show how an interactive proof  can be generalized
into a  procedure.   But 
=INLINEFT
ADD_ASSUM
=TEX
{} can be  written much more concisely as:

\begin{session} 
=SML 
      fun  ADD_ASSUM t th = ´_elim (´_intro t th) (asm_rule t);
=GFT
      val ADD_ASSUM = fn : TERM -> THM -> THM   
=SML 
      ADD_ASSUM  ¬t3:BOOL® Th6;
=GFT
      val it = t1 ´ t2, t1, t3 ô t2 : THM   
=TEX
\end{session}


Another example of  a derived  inference rule  is shown below as  
=INLINEFT
UNDISCH
=TEX
;  this moves the antecedent of an implication to the assumptions.

\[ \Gamma\turn t_1\imp t_2 \over\Gamma,\ t_1\turn t_2 \]

A \SML\ derived rule that implements this is:

\typeout{ --- section 4.2 ---- }
\begin{session} 
=SML 
      fun  UNDISCH th =  ´_elim th (asm_rule(fst(dest_´(concl th)))); 
=GFT
      val UNDISCH = fn : THM -> THM
=SML 
      Th10; 
=GFT
      val it = t1 ´ t2, t1 ô t3 ´ t2 : THM   
=SML 
      UNDISCH Th10; 
=GFT
      val it = t1 ´ t2, t1, t3 ô t2 : THM   
=TEX
\end{session}

Each time 
=INLINEFT
UNDISCH
=TEX 
{} $\Gamma\turn t_1\imp t_2$ is executed,
the following proof is performed:

\begin{enumerate}
\item $t_1\turn t_1$ \hfill [Assumption introduction]
\item $\Gamma\turn t_1\imp t_2$ \hfill [Hypothesis]
\item $\Gamma,\ t_1\turn t_2$ \hfill [Modus Ponens applied to lines 2 and 1]
\end{enumerate}

Rules  equivalent to 
=INLINEFT
ADD_ASSUM
=TEX
{}} and 
=INLINEFT
UNDISCH
=TEX
{} (named respectively 
=INLINEFT
asm_intro
=TEX
{} and 
=INLINEFT
undisch_rule
=TEX
) are  derived rules
 defined when the \HOL\ system is built. For a description
of the main rules see the section on derived rules in
\DESCRIPTION.

\subsection{Rewriting}

An important derived rule  is  
=INLINEFT
rewrite_rule
=TEX
.    This takes  as arguments
\begin{itemize}
\item a collection of equations represented by  a list of theorems, such that each theorem is an equation or a conjunction of equations, and 
\item   a theorem $\Delta\turn t$ 
\end{itemize}
 and  repeatedly  replaces in  $t$  instances  of  the lefthand side of an equation  by the
corresponding instance of the righthand side until no further change occurs.   The result is
a theorem $\Gamma\cup\Delta\turn t'$ where $t'$ is the result  of rewriting $t$
in this way. 


 The session below illustrates the use of 
=INLINEFT
rewrite_rule
=TEX
.  In it the list of equations is a list 
=INLINEFT
rewrite_list
=TEX
{} containing the  theorems   of the theory 
=INLINEFT
î
=TEX 
{} defining addition and multiplication.


\begin{session}
=SML  
      val  rewrite_list =  map (get_defn "î") ["+", "*"]; 
=GFT
      val rewrite_list = [
          ô µ m n· 0 + n = n ± 
                   (m + 1) + n = (m + n) + 1 ± 
                   Suc m =  m + 1, 
          ô µ m n· 0 * n = 0 ± 
                  (m + 1) * n = m * n + n] : THM list
=TEX
\end{session}

In the following example,  the conclusion of a theorem (an arbitrary theorem just for this example) is rewritten using these definitions to produce a simpler theorem. 

\begin{session} 
=SML 
      val th = asm_rule ¬(0 + m) = ((0* n) +1)®;
=GFT
      val th = 0 + m = 0 * n + 1 ô 0 + m = 0 * n + 1 : THM   
=SML 
      rewrite_rule rewrite_list th;
=GFT
      val it = 0 + m = 0 * n + 1 ô m = 1 : THM   
=TEX
\end{session}

=INLINEFT
rewrite_rule 
=TEX 
{} is not a primitive in \HOL, but is a derived rule.   In addition to the supplied equations,
=INLINEFT
rewrite_rule
=TEX
{} has some built-in standard simplifications:

\begin{session} 
=SML 
      (asm_rule ¬(T ± x) ² F ´ F®);
=GFT
      val it = T ± x ² F ´ F ô T ± x ² F ´ F : THM   
=SML 
      rewrite_rule [] it;
=GFT
      val it = T ± x ² F ´ F ô ³ x : THM   
=TEX
\end{session}


There are elaborate facilities in \HOL\ for producing customized rewriting tools
which scan through terms in user programmed orders; 
=INLINEFT
rewrite_rule
=TEX
{} is the tip
of an iceberg, see \DESCRIPTION\ for more details.

\pagebreak

\subsection{Goal Oriented Proof: Tactics and Tacticals}
\label{backward}\label{tactics}

The style of forward proof described in the previous chapter is unnatural and
too laborious for many applications. An important advance in proof generating
methodology was made by Robin Milner in the early 1970s when he invented the
notion of {\it tactics\/}. A tactic is a function which does two things:
\begin{itemize}
\item It splits a `goal' into `subgoals'.
\item It keeps track of the reason why solving the subgoals will solve the goal.
\end{itemize}

\noindent Consider, for example, the  rule of $\wedge$-introduction\footnote{In
higher order logic this is a derived rule; in first  order logic  it is usually
primitive.  In HOL the rule is called  
=INLINEFT
±_intro
=TEX
{}  and its derivation is given in
\DESCRIPTION.}  shown below:  

\[ \Gamma_1\turn
t_1\qquad\qquad\qquad\Gamma_2\turn t_2\over \Gamma_1\cup\Gamma_2 \turn t_1\conj
t_2 \]


\noindent In \HOL,  $\wedge$-introduction is  represented by  the \SML\ function
=INLINEFT
±_intro
=TEX
, such that
  \[ ±\_intro \ (\Gamma_1\turn t_1)\ (\Gamma_2\turn t_2) \ \ is \ (\Gamma_1\cup\Gamma_2\turn  t_1\conj  t_2)\]

This  is   illustrated  in  the
following new  session  (note  that  the  session  number  has  been  reset  to
{\small\sl 1}):

\setcounter{sessioncount}{1}
\begin{session}
=SML 
      val  Th1 = asm_rule ¬A:BOOL® and Th2 = asm_rule ¬B:BOOL®;
=GFT
      val Th1 = A ô A : THM  
      val Th2 = B ô B : THM   
=SML 
      val  Th3 = ±_intro Th1 Th2; 
=GFT
      val Th3 = A, B ô A ± B : THM
=TEX
\end{session}

Suppose the goal is to prove $A\conj B$, then this rule says 
that it is sufficient
to prove the two subgoals $A$ and $B$, because from $\turn A$ and $\turn B$
the theorem $\turn A\conj B$ can be deduced. Thus:

\begin{description}
\item[(i)] To prove $\turn A \conj B$ it is sufficient to 
      prove $\turn A$ and $\turn B$.
\item [(ii)]The justification for the reduction of the 
goal  $\turn A \conj B$  to the two  subgoals  $\turn A$ 
and $\turn B$ is the rule of $\wedge$-introduction.
\end{description}

A {\it goal\/} in \HOL\ is a pair
([$t_1$,\ldots,$t_n$],$t$) of \SML\ type 
=INLINEFT
TERM list * TERM
=TEX
. An {\it achievement\/} of such a goal
is a theorem
$t_1$,$\ldots$,$t_n$\ $ô$ \ $t$. 
A tactic is a \SML\ function that when applied to a goal generates subgoals
together with a {\it justification function\/} or {\it validation\/}, 
which will be a \SML\ derived inference
rule, that can be used to infer an achievement of the original goal from
achievements
of the subgoals. 



\SML\ has a type abbreviating mechanism which is used to give mnemonic
names to the various types associated with goal oriented proof.  Some type abbreviations are as follows:

\def\aa{
=INLINEFT
CONV
=TEX
}
\def\ab{
=INLINEFT
TERM -> THM
=TEX
}
\def\ba{
=INLINEFT
GOAL
=TEX
}
\def\bb{
=INLINEFT
(TERM list) * TERM
=TEX
}
\def\ca{
=INLINEFT
GOAL_STATE
=TEX
}
\def\cb{
=INLINEFT
an abstract type
=TEX
}
\def\da{
=INLINEFT
PROOF
=TEX
}
\def\db{
=INLINEFT
THM list -> THM
=TEX
}

\def\ea{
=INLINEFT
SEQ
=TEX
}
\def\eb{
=INLINEFT
(TERM list) * TERM
=TEX
}
\def\fa{
=INLINEFT
TACTIC
=TEX
}
\def\fb{
=INLINEFT
GOAL -> (GOAL list * PROOF)
=TEX
}
\def\ga{
=INLINEFT
THM_TACTIC
=TEX
}
\def\gb{
=INLINEFT
THM -> TACTIC
=TEX
}
\def\ha{
=INLINEFT
THM_TACTICAL
=TEX
}
\def\hb{
=INLINEFT
THM_TACTIC -> THM_TACTIC
=TEX
}

\begin{tabular}{|l|l|}  \hline 
{\bf Abbreviation} & {\bf Type} \\ \hline \hline
% \ml{CONV}          & \verb+TERM -> THM+    \\        \hline
% \ml{GOAL}          & \verb+(TERM list ) * TERM + \\  \hline
% \ml{GOAL\_STATE}   & an abstract type \\  \hline
% \ml{PROOF}         & \verb+THM list -> THM+    \\    \hline
% \ml{SEQ}           & \verb+(TERM list ) * TERM+   \\ \hline
% \ml{TACTIC}        & \verb+GOAL -> (GOAL list * PROOF)+  \\ \hline
% \ml{THM\_TACTIC}   & \verb+THM -> TACTIC+  \\ \hline
% \ml{THM\_TACTICAL} & \verb+THM_TACTIC -> THM_TACTIC+  \\ \hline
\aa & 
=INLINEFT
TERM -> THM
=TEX
 \\ \hline
\ba & 
=INLINEFT
(TERM list) * TERM
=TEX
\\ \hline
\ca & 
=INLINEFT
an abstract type
=TEX
\\ \hline
\da & 
=INLINEFT
THM list -> THM
=TEX
 \\ \hline
\ea & 
=INLINEFT
(TERM list) * TERM
=TEX
 \\ \hline
\fa & 
=INLINEFT
GOAL -> (GOAL list * PROOF)
=TEX
\\ \hline
\ga & 
=INLINEFT
THM -> TACTIC
=TEX
 \\ \hline
\ha & 
=INLINEFT
THM_TACTIC -> THM_TACTIC
=TEX
\\ \hline
\end{tabular}


The left hand side of these abbreviations can be used anywhere that the
right hand side can. 



If $T$ is a tactic (\ie\ a \SML\ function of type 
=INLINEFT
TACTIC
=TEX
) and $g$ is a goal (\ie\ a \SML\ function of type 
=INLINEFT
GOAL
=TEX
), then
applying $T$ to $g$ (\ie\ evaluating the \SML\ 
expression 
=INLINEFT
T g
=TEX
{} will result in an object of \SML\ type 
=INLINEFT
GOAL list * PROOF
=TEX
{} that is,  a pair whose 
first component is a list of 
goals and whose second component is a justification function, \ie\ has \SML\ type 
=INLINEFT
PROOF
=TEX
.

An example tactic is 
=INLINEFT
±_tac
=TEX
.  For example, consider the trivial goal of showing 
=INLINEFT
T ± T
=TEX
, where 
=INLINEFT
T 
=TEX
{} is a constant that stands for $true$:

\begin{session} 

=SML 
      val  goal =([], ¬T ± T®);
=GFT
      val goal = ([], ¬T ± T®) : 'a list * TERM 
  
=SML 
      ±_tac goal;
=GFT
      val it = ([([], ¬T®), ([], ¬T®)], fn) : GOAL list * PROOF

=SML 
      val  (goal_list,just_fn) = it; 
=GFT
      val goal_list = [([], ¬T®), ([], ¬T®)] : GOAL list
      val just_fn = fn : PROOF
=TEX
\end{session}


Applying
=INLINEFT
±_tac
=TEX
{} has produced a goal  list consisting  of two identical
subgoals, each of which is to show 
=INLINEFT
([],¬T®)
=TEX
.  Now, there  is a  preproved theorem in
\HOL, which is recorded in theory  
=INLINEFT
misc
=TEX
{} under the name of 
=INLINEFT
t_thm
=TEX
.  It can be produced and bound to a \SML\ name, say 
=INLINEFT
TRUTH
=TEX
, as follows:


\begin{session} 

=SML 
val TRUTH = get_thm "misc" "t_thm";
=GFT
val TRUTH = ô T : THM   
=TEX

\end{session}

Applying the justification function 
=INLINEFT
just_fn
=TEX
{} to a list of theorems achieving the goals in 
=INLINEFT
goal_list
=TEX
{} results in a theorem achieving the original goal:

\begin{session} 
=SML 
      just_fn [TRUTH, TRUTH];
=GFT
      val it = ô T ± T : THM   
=TEX
\end{session}

Although this  example  is trivial,  it does  illustrate the  essential idea of
tactics.  Note that  tactics are  not special  theorem-proving primitives; they
are just  \SML\  functions.   For example,  the definition  of  a tactic equivalent to the built-in 
=INLINEFT
±_tac
=TEX
{} would be:


=GFT
 
    fun ±_tac_equivalent (asl,w) =
	let  val (l,r) = dest_± w 
	in
	([(asl,l), (asl,r)], 
	 fn [th1, th2] => ±_intro th1 th2)
	end;

=TEX

In this definition, the \SML\ function 
=INLINEFT
dest_±
=TEX
{} splits a conjunctive term into its
two conjuncts, 
=INLINEFT
l
=TEX
{} and  
=INLINEFT
r
=TEX
. If  
=INLINEFT
(asl,¬l±r®)
=TEX
{} is a goal, then 
=INLINEFT
±_tac_equivalent
=TEX
 splits it into the list of two subgoals  
=INLINEFT
(asl,¬l®)
=TEX
{} and 
=INLINEFT
(asl,¬r®)
=TEX
. 

The justification function,


=GFT
      fn [th1, th2] => ±_intro th1 th2

=TEX
 
takes a list 
=INLINEFT
[th1, th2]
=TEX
{} of theorems and applies the rule 
=INLINEFT
±_intro
=TEX
{} to  
=INLINEFT
th1
=TEX
{} and 
=INLINEFT
th_2
=TEX
. 

To summarize:
if $T$ is a tactic and $g$ 
is a goal, then
applying $T$ to $g$ will result in
an object of \SML\ type 
=INLINEFT
GOAL list * PROOF
=TEX
, \ie\ a pair whose first component is a list of 
goals and whose second component is a justification function. 

Suppose $T \ g = ([g_1 ,  \ldots , g_n], \ p ) $. 
The idea is that $g_1 , \ldots , g_n$ are subgoals and $p$
is a `justification' of the reduction of goal $g$ to subgoals 
$g_1 , \ldots , g_n$.
Suppose further that the subgoals $g_1 , \ldots , g_n$ have been solved. 
This would mean that 
theorems $th_1$ , $\ldots$ , $th_n$ had been proved
such that each $th_i$ ($1\leq i\leq n$) `achieves' the goal $g_i$. 
The justification $p$ (produced
by applying $T$ to $g$) is a \SML\ 
function which when applied to the list
$[th_1$, $\ldots$, $th_n]$ returns a theorem, $th$, 
which `achieves' the original goal $g$.
Thus $p$ is a function for converting a solution of the subgoals to a
solution of the original goal. If $p$ 
does this successfully, then the tactic $T$ is
called {\it valid\/}. 

Invalid tactics cannot result in the proof of invalid theorems;
the worst they can do is result in insolvable goals or unintended theorems
being proved.
If tactic $T$ were invalid and were used
to reduce goal $g$ to subgoals $g_1$ , $\ldots$ , $g_n$,
then  effort might be spent proving
theorems $th_1$ , $\ldots$ , $th_n$ to
achieve the subgoals $g_1$ , $\ldots$ , $g_n$, 
only to find out after the work is done that this is a blind alley
because $p \ [th_1$, \ldots$ ,th_n]$  
doesn't achieve $g$ (\ie\ it fails, 
or else it achieves some other goal).

A theorem {\it achieves\/} a goal if the assumptions of the theorem are
included in the assumptions of the goal {\it and\/} if the conclusion of the
theorem is equal (up to the renaming of bound variables) to the conclusion of
the goal. More precisely, a theorem 
$t_1, \dots, t_m  \ ô \ t $ achieves a goal
$([u_1; \ldots ; u_n], \ u)$

 
if and only if {\small\verb%{%}$t_1,\ldots,t_m${\small\verb%}%} is a subset of
{\small\verb%{%}$u_1,\ldots,u_n${\small\verb%}%} and $t$ is equal to $u$ (up
to renaming of bound variables).  For example, the goal
\begin{quotation}
\ml{([¬x=y®, ¬y=z®, ¬z=w®],   ¬x=z®)}
\end{quotation}
 is achieved by the theorem
\begin{quotation}
\ml{x=y, y=z ô x=z} 
\end{quotation}the assumption \ml{z=w} being not
needed.

A tactic {\it solves\/} a goal if it reduces the goal 
to the empty list
of subgoals. Thus $T$ solves $g$ if  $T\ g${\small\verb% = ([],%}$p${\small\verb%)%}.
If this is the case and if $T$ is valid, then $p${\small\verb%[]%} 
will evaluate to a theorem achieving $g$.
Thus if $T$ solves $g$ then the \SML\ expression 
=INLINEFT
snd(T g)[ ]
=TEX
{} evaluates to
a theorem achieving $g$.

Tactics are specified using the following notation:

\begin{center}
\begin{tabular}{c} \\
$goal$ \\ \hline \hline
$goal_1\ \ \ goal_2 \ \ \ \cdots\ \ \ goal_n$ \\
\end{tabular}
\end{center}

For example, a tactic called 
=INLINEFT
±_tac
=TEX
{} is described by

\begin{center}
\begin{tabular}{c} \\
$ t_1$ \ml{±} $t_2$ \\ \hline \hline
$t_1\ \ \ \ \ \ \ t_2$ \\
\end{tabular}
\end{center}

Thus  
=INLINEFT
±_tac
=TEX
{} reduces a goal of the form 
\ml{$\Gamma$, ¬$t_1$±$t_2$®} 
to subgoals \ml{$\Gamma$, ¬$t_1$®} and \ml{$\Gamma$, ¬$t_2$®}
.
The fact that the assumptions of the top-level goal
are propagated unchanged to the two subgoals is indicated by the absence
of assumptions in the notation.

\pagebreak

Another example is  
=INLINEFT
induction_tac
=TEX
, the tactic for doing mathematical induction on the natural numbers.

\begin{center}
\begin{tabular}{c} \\
$t[n]$ \\ \hline \hline
$t[${\small\verb%0%}$]$ {\small\verb%     %} $\{t[n]\}\ t[${\small\verb%Suc %}$n]$
\end{tabular}
\end{center}

Given the name of a variable, n say,  which is to be the induction variable, 
=INLINEFT
induction_tac ¬n:î®
=TEX
{} reduces a goal $( \Gamma, \ t[n]) $ to
\begin{itemize}
\item  a basis subgoal , $( \Gamma, \ t[0]) $ and 
\item  an induction step subgoal $(\Gamma \ \cup  \ \{ t[n] \}, t[n+1]) $.  Here the set of assumptions are the original set $\Gamma$ together  with the extra assumption, written in the tactic-notation as  a singleton set, $\{ t[n] \}$ 
\end{itemize} 

\begin{session} 

=SML 
      (induction_tac ¬m:î®)  ([], ¬(m + n) = (n + m)®);
=GFT
      val it = ([([],                ¬0 + n = n + 0®),
                 ([¬m + n = n + m®], ¬(m + 1) + n = n + m + 1®)],
               fn) : GOAL list * PROOF
=TEX
\end{session}

The first subgoal is the basis case and the second subgoal is
the step case.

Tactics generally fail (in the \SML\ sense) if they are applied to 
inappropriate
goals. For example, 
=INLINEFT
±_tac
=TEX
{} will fail if it is applied to a goal whose
conclusion is not a conjunction. 



\subsection{Using tactics to prove theorems}   
\label{using-tactics}

Suppose goal $g$  is to be solved. If $g$
is simple it might be possible
to immediately think up a tactic, $T$ 
say, which reduces it to the empty list of
subgoals. If this is the case then executing:

=GFT
	val (gl,p) = T g;
=TEX
 will 
\begin{itemize}
\item bind $gl$ to the empty list of goals, and 
\item bind $p$ to a function which when applied to the empty list
of theorems yields a theorem $th$ achieving $g$.
\end{itemize}

Thus a theorem achieving 
$g$ can be computed by executing:

=GFT
	val th = p [];
=TEX

This will be illustrated using 
=INLINEFT
rewrite_tac
=TEX
{} which takes a list
of equations (empty in the example that follows) and tries to prove a goal
by rewriting with these equations togther with built-in rewrites:

\begin{session}
=SML  
      val g = ([], ¬T ± x ´ x ² (y ± F)®);
=GFT
      val g = ([], ¬T ± x ´ x ² y ± F®) : 'a list * TERM

=SML 
      val T = rewrite_tac [];
=GFT
      val T = fn : TACTIC
 
=SML 
      val (gl, p) = T g;
=GFT
      val gl = [] : GOAL list val p = fn : PROOF
   
=SML 
      val th = p[];
=GFT
      val th = ô T ± x ´ x ² y ± F : THM   
=TEX
\end{session}

 
There is a useful built-in  function 
=INLINEFT
tac_proof
=TEX
{} of \SML\ type 
=INLINEFT
GOAL * TACTIC -> THM
=TEX
{} such that
=INLINEFT
tac_proof (G, T)
=TEX
{}  proves the goal  $G$  using  tactic  $T$  and  returns the resulting theorem.



When conducting a proof that involves many subgoals and tactics, it is necessary
to keep track of all the justification functions  
and compose them in the correct order.  While
this is feasible even in large proofs, it is tedious.  \HOL\ provides a package
for building and traversing the tree of subgoals, stacking the justification functions and
applying them properly; such package was originally implemented for \LCF\ by 
Larry Paulson.

The subgoal package implements a simple framework for interactive proof. A proof
tree is created and traversed top-down.  The current goal can be expanded
into subgoals using a tactic; the subgoals are pushed onto a goal
stack and the justification function onto a proof stack.
Subgoals can be considered in any order.  If the tactic solves a
subgoal (\ie\ returns an empty subgoal list), then the package proceeds to the
next subgoal in the tree. 

The function 
=INLINEFT
push_goal
=TEX
{} of type  
=INLINEFT
GOAL -> unit
=TEX
{} initializes the subgoal package with a new goal. Usually
top-level goals have no assumptions; the function 
=INLINEFT
g
=TEX 
{} is useful
in this case and is defined by:

=SML  
      fun g t = push_goal([ ],t);
=TEX

To illustrate the subgoal package the trivial theorem
$m+0=m$ will be proved from the definition   of addition: 

\begin{session}

=SML  
      val ADD = [get_defn "î" "+"];
=GFT
      val ADD = [ô  µ m n·
                       0 + n = n ±
                       (m + 1) + n = (m + n) + 1 ± 
                       Suc m = m + 1] : THM list
=TEX
\end{session}

Notice that 
=INLINEFT
ADD
=TEX
{} specifies $0+n=n$
 but not  $n+0=n$. 

\setcounter{sessioncount}{1}
\begin{session} 
=SML 
      g ¬(m + 0) = m®; 
=GFT
      Now 1 goal on the main goal stack

      (* *** Goal "" *** *)

      (* ?ô *)  ¬m + 0 = m®

      val it = (): unit

=TEX
\end{session}


This sets up the goal. Next the goal is split into a basis and step case with 
=INLINEFT
induction_tac
=TEX
. To do this, use is made of the function  
=INLINEFT
apply_tactic 
=TEX
{} (abbreviating this frequently-used  name to 
=INLINEFT
a
=TEX
. This applies a tactic to the top goal on the stack, then
pushes the resulting subgoals onto the goal stack, then prints the resulting
subgoals. If there are no subgoals, the justification function is applied to the
theorems solving the subgoals that have been proved and the resulting theorems are
printed.

\begin{session}
=SML 
      val a = apply_tactic; 
=GFT
      val a = fn : TACTIC -> unit   

=SML 
      a  (induction_tac ¬m:î®) ;
=GFT
      Tactic produced 2 subgoals:

      (* *** Goal "2" *** *)

      (*  1 *)  ¬m + 0 = m®

      (* ?ô *)  ¬(m + 1) + 0 = m + 1®


      (* *** Goal "1" *** *)

      (* ?ô *)  ¬0 + 0 = 0®

=TEX

\end{session}


The top of the goal stack is printed last. The basis case
is an instance of the definition of addition, so is solved by rewriting with
=INLINEFT
ADD
=TEX
.

\begin{session}
=SML 
      a (rewrite_tac ADD);
=GFT
      Tactic produced 0 subgoals:
      Current goal achieved, next goal is:

      (* *** Goal "2" *** *)

      (*  1 *)  ¬m + 0 = m®

      (* ?ô *)  ¬(m + 1) + 0 = m + 1®

=TEX
\end{session}


The basis is solved and the goal
stack popped so that its top is now the step case, namely showing
that $(SUC \ m)  +  0 = SUC \ m$  on the assumption that
$m + 0 = m$. This goal can be solved by rewriting first
with the definition of addition:

\begin{session}
=SML 
      a (rewrite_tac ADD);
=GFT
      Tactic produced 1 subgoal:

      (* *** Goal "2" *** *)

      (*  1 *)  ¬m + 0 = m®

      (* ?ô *)  ¬(m + 0) + 1 = m + 1®

=TEX
\end{session}


and then by rewriting with the assumption $m+0 = m$.  The tactic 
=INLINEFT
asm_rewrite_tac
=TEX
{} is used to rewrite with the assumptions of a goal. It is
just like  
=INLINEFT
rewrite_tac
=TEX
{} except that it adds the assumptions to the list of
equations used for rewriting. For the example here no equations besides the
assumptions are needed, so 
=INLINEFT
asm_rewrite_tac
=TEX
{} is given the empty list of equations.

\begin{session}
=SML 
      a (asm_rewrite_tac []);
=GFT
      Tactic produced 0 subgoals:
      Current and main goal achieved
=TEX
\end{session}

The top goal is solved, hence the preceding goal (the step case)
is solved too, and since the basis is already solved, the main goal is solved. 
The theorem achieving the goal can be extracted from the subgoal package with 
=INLINEFT
top_thm
=TEX
:

\index{theorems, \ retrieving \ from  \goal  \ state  \ with top\_thm}
\begin{session}
=SML 
      top_thm(); 
=GFT
      val it = ô m + 0 = m : THM   
=TEX
\end{session}


The proof just done can be improved. For example, instead
of first rewriting with 
=INLINEFT
ADD
=TEX
{} (box 4) and then with the assumptions
(box 5), a single rewriting with 
=INLINEFT
ADD
=TEX
{} together with the assumptions would suffice.
To illustrate, the last two steps of the proof will be `undone' using the function
=INLINEFT
undo
=TEX
{} which restores the previous state of the goal and theorem stacks.  The argument to 
=INLINEFT
undo
=TEX
{} is the number of proof-steps to be undone:

\begin{session} 

=SML 
      undo 2;
=GFT
      Current goal is:

      (* *** Goal "2" *** *)

      (*  1 *)  ¬m + 0 = m®

      (* ?ô *)  ¬(m + 1) + 0 = m + 1®

=TEX
\end{session}

The proof can now be completed in one step instead of two:

\begin{session}
=SML 
      a (asm_rewrite_tac ADD);
=GFT
      Tactic produced 0 subgoals:
      Current and main goal achieved
      val it = () : unit  
=TEX
\end{session}


The order in which goals are attacked can be adjusted. Firstly the goal stack is backed up by two steps, back to the point at which there are two subgoals.   

\begin{session}
=SML 
      undo 2;
=GFT
      Current goal is:

      (* *** Goal "1" *** *)

      (* ?ô *)  ¬0 + 0 = 0®

=TEX
\end{session}

The system offers the basis case as the current subgoal.  In order to survey all the possible subgoals, the command 
=INLINEFT
print_goal_state  (top_goal_state())
=TEX
{} is used:
\index{goal state, examining with \ml{print\_goal\_state}}

\begin{session}
=SML 
      print_goal_state (top_goal_state());
=GFT
      Main goal is:
      (* ?ô *)  ¬m + 0 = m®

      Goals to be proven are:

      (* *** Goal "1" *** *)

      (* ?ô *)  ¬0 + 0 = 0®


      (* *** Goal "2" *** *)

      (*  1 *)  ¬m + 0 = m®

      (* ?ô *)  ¬(m + 1) + 0 = m + 1®


      Current goal is:

      (* *** Goal "1" *** *)

      (* ?ô *)  ¬0 + 0 = 0®

=TEX
\end{session}

It can be seen that the current goal is labelled "1" and the other goal is labelled "2".  To choose the other goal to work on, it is made current with the command 
=INLINEFT
set_labelled_goal
=TEX
, providing an argument value of, in this case, "2".
\begin{session}
=SML 
      set_labelled_goal "2";
=GFT
      Current goal is:

      (* *** Goal "2" *** *)

      (*  1 *)  ¬m + 0 = m®

      (* ?ô *)  ¬(m + 1) + 0 = m + 1®

=TEX
\end{session}


The top goal is now the step case not the basis case, so the appropriate tactic can be applied:

\begin{session}
=SML 
      a (asm_rewrite_tac ADD);
=GFT
      Tactic produced 0 subgoals:
      Current goal achieved, next goal is:

      (* *** Goal "1" *** *)

      (* ?ô *)  ¬0 + 0 = 0®

=TEX
\end{session}

The topmost goal on the stack can be discarded by using the function
=INLINEFT
drop_main_goal
=TEX
{}
The discarded goal is returned by the function. Repeated calls of this function will empty the goal stack.

\begin{session}
=SML
      drop_main_goal ();
=GFT
      Now 0 goals on the main goal stack
      val it = ([], ¬m + 0 = m®) : GOAL
=TEX
\end{session}

\subsection{Tacticals}
\label{tacticals}

It is possible to do the whole of the above proof in one step, by using a compound
tactic built with the {\it tactical\/}\footnote{This word was invented by Robin
Milner: `tactical' is to `tactic` as `functional' is to `function'.} called 
=INLINEFT
THEN_LIST
=TEX
. 

Tacticals are higher order operations for combining tactics. Thus a tactical is an \SML\ function that returns a tactic (or tactics) as result.
Tacticals may take various parameters; this is reflected in the various
\SML\ types that the built-in tacticals have. Some important tacticals in  the \HOL\ system are listed below.




\subsubsection{The Tactical $THEN\_LIST$}

The type of 
=INLINEFT
THEN_LIST
=TEX
{} is 
=INLINEFT
TACTIC * TACTIC list -> TACTIC 
=TEX
     
If $T$ is a tactic which produces $n$ subgoals and $T_1$, $\ldots$ ,
$T_n$ are tactics
then 
=INLINEFT
T THEN_LIST [T‰1,  ...  ,T‰n]
=TEX
{} is a tactic which first applies $T$ and then
applies $T_i$ to the $i$th subgoal produced by $T$. 
The tactical 
=INLINEFT
THEN_LIST
=TEX
{} is useful if one wants to do different
things to different subgoals.

The tactical 
=INLINEFT
THEN_LIST
=TEX
{} can be illustrated by doing the proof of $m+0=m$ in
one step.  (From now on the proof-sessions will be shown just in essentials, that is,  omitting some of the annotations provided by the system.)



\setcounter{sessioncount}{1}
\begin{session}
=SML  
      g ¬(m +0) = m®;
=GFT
      (* ?ô *)  ¬m + 0 = m®

=SML 
      a ((induction_tac ¬m:î®) THEN_LIST [(rewrite_tac ADD), (asm_rewrite_tac  ADD)]); 
=GFT
      Tactic produced 0 subgoals:
      Current and main goal achieved
=TEX

\end{session}


The compound tactic:

=INLINEFT
      (induction_tac ¬m:î®) THEN_LIST [(rewrite_tac ADD), (asm_rewrite_tac ADD)]
=TEX


first applies 
=INLINEFT
induction_tac ¬m:î® 
=TEX
{} and then applies
=INLINEFT
rewrite_tac ADD
=TEX
{} to the first resulting subgoal (the basis) and
=INLINEFT
asm_rewrite_tac ADD
=TEX
{} to the second subgoal (the step). 

\subsubsection{The Tactical $THEN$}


The tactical  
=INLINEFT
THEN_LIST
=TEX
, described in the previous section,  is useful for doing different things to different
subgoals.  By contrast, the tactical  
=INLINEFT
THEN 
=TEX
{} can be used to apply the same tactic to all
subgoals. The type of 
=INLINEFT
THEN 
=TEX
{} is 
=INLINEFT
TACTIC * TACTIC -> TACTIC
=TEX
.




If $T_1$ and $T_2$ are tactics,
then the \SML\ expression 
=INLINEFT
T‰1 THEN T‰2
=TEX
{} evaluates to a tactic
which first applies $T_1$ and then applies $T_2$ to all the subgoals produced by
$T_1$. 

To illustrate, note that since 
=INLINEFT
asm_rewrite_tac ADD
=TEX
{}  will solve the basis as well as the step
case of the induction for $m+0=m$,  there is an even
simpler one-step proof than the one above:
\setcounter{sessioncount}{1}


\begin{session}
=SML 
      g ¬(m + 0) = m®; 
=GFT
      (* ?ô *)  ¬m + 0 = m®

      val it = () : unit   

=SML 
      a ((induction_tac ¬m:î®) THEN  (asm_rewrite_tac ADD));
=GFT
      Tactic produced 0 subgoals:
      Current and main goal achieved
=TEX
\end{session}




This is typical: it is common to use a single tactic for several
goals. Here is a sequence of examples:

\begin{session}
=SML 
      val ADD_0 =
          tac_proof  (([],¬ (m + 0) = m®),
	     (induction_tac ¬m:î®) THEN (asm_rewrite_tac ADD));
=GFT
      val ADD_0 = ô m + 0 = m : THM

=SML 
      val ADD_SUC =
          tac_proof (([],¬((m + n) + 1) = (m + (n+1))®),
            (induction_tac ¬m:î®) THEN (asm_rewrite_tac ADD));
=GFT
      val ADD_SUC = ô (m + n) + 1 = m + n + 1 : THM

=SML 
      val ADD_CLAUSES =
       tac_proof (([],  ¬ ((0 + m) = m		)        ±
          	           ((m + 0) = m		)        ±
                          (((m+1) + n) = ((m + n) + 1))  ±
                          ((m + (n+1)) = ((m + n) + 1))    ® ) ,
            rewrite_tac (ADD_0:: (ADD_SUC::ADD))            );
=GFT
      val ADD_CLAUSES = ô 
	0 + m = m ± 
	m + 0 = m ± 
	(m + 1) + n = (m + n) + 1 ±
        m + n + 1 = (m + n) + 1 : THM
=TEX
\end{session}



\subsubsection{The Tactical $REPEAT$}

The type of 
=INLINEFT
REPEAT  
=TEX
is 
=INLINEFT
TACTIC -> TACTIC
=TEX
. If 
=INLINEFT
T
=TEX
{} is a 
tactic then 
=INLINEFT
REPEAT T 
=TEX
{} is a tactic which repeatedly applies
=INLINEFT
T
=TEX
{} until it fails. This can be illustrated in conjunction with 
=INLINEFT
simple_µ_tac
=TEX
, which is specified by:


\begin{center}
\begin{tabular}{c} \\
$µx·t[x]$
\\ \hline \hline
$t[x']$
\\
\end{tabular}
\end{center}


where $x'$ is a variant of $x$ 
not free in the goal or the assumptions.

=INLINEFT
simple_µ_tac
=TEX
{} strips off one quantifier; 
=INLINEFT
REPEAT simple_µ_tac
=TEX
{} strips off all quantifiers:

\begin{session}
 
=SML 
      g ¬ µx y z· (x + (y + z)) = ((x + y) + z ) ®;
 
=GFT
      (* ?ô *)  ¬µ x y z· x + y + z = (x + y) + z®

=SML 
      a  simple_µ_tac; 
=GFT
      (* *** Goal "" *** *)

      (* ?ô *)  ¬µ y z· x + y + z = (x + y) + z®

=SML 
      a (REPEAT simple_µ_tac ); 
=GFT
      (* ?ô *)  ¬x + y + z = (x + y) + z®
=TEX
\end{session}

\cleardoublepage
\section{FURTHER TACTICS}

This section describes some of the tactics built-in to the \HOL\ system in addition to those discussed above.  This section is not meant to provide complete coverage of the available tactics, but rather to acquaint the reader with more of the effects to be achieved in transforming goals,and some tactics to achieve those  effects.   There are many more available tactics, and variations of tactics,  than are covered here.  
.

\subsection{Simplifying the Goal}

An important tactic is that which `strips' or simplifies a goal.  The tactic
=INLINEFT
strip_tac
=TEX
{} performs a variety of simplifications, and is often usefully applied at the outset of  embarking on a proof.  The simplifications achieved by
=INLINEFT
strip_tac
=TEX
{} include the following:
\begin{itemize}
\item moving the antecedent of an implication from the conclusion to the assumptions of the goal:
\item proving tautologies
\item removing leading universal quantifiers
\item using, where possible relevant, assumptions in the assumption-list
\end{itemize}

\begin{session}
=SML
      g ¬(P 3) ´ µx·  x = 3 ´ P x®;
=GFT
      (* ?ô *)  ¬P 3 ´ (µ x· x = 3 ´ P x)®

=SML
      a strip_tac;
=GFT
      (*  1 *)  ¬P 3®

      (* ?ô *)  ¬µ x· x = 3 ´ P x®

=SML
      a strip_tac;
=GFT
      (*  1 *)  ¬P 3®

      (* ?ô *)  ¬x = 3 ´ P x®

=SML
      a strip_tac;
=GFT
      (*  2 *)  ¬P 3®
      (*  1 *)  ¬x = 3®

      (* ?ô *)  ¬P x®

=SML
      a strip_tac;
=GFT
      Exception-
         Fail
            * There is no stripping technique for ¬P x® in the current proof
             context [strip_tac.28003] * raised

=SML
       a (asm_rewrite_tac []);
=GFT
      Tactic produced 0 subgoals:
      Current and main goal achieved
=TEX
\end{session}

The foregoing session showed 4 successive applications of
=INLINEFT
strip_tac
=TEX
{} of which the first three each had an effect and the fourth failed, leaving a goal amenable to 
=INLINEFT
asm_rewrite_tac
=TEX
.  With the knowledge provided by hindsight, we can see that a single compound tactic to achieve this goal would be to repeat 
=INLINEFT
strip_tac
=TEX
{} until failure, and then apply 
=INLINEFT
asm_rewrite_tac
=TEX
, thus:

\begin{session}
=SML
      g ¬(P 3) ´ µx·  x = 3 ´ P x®;
=GFT
      (* ?ô *)  ¬P 3 ´ (µ x· x = 3 ´ P x)®

=SML
      a ((REPEAT strip_tac)  THEN (asm_rewrite_tac []));
=GFT
      Tactic produced 0 subgoals:
      Current and main goal achieved
=TEX
\end{session}

Although this particular example is specific to the goal, nevertheless  
=INLINEFT
(REPEAT strip_tac)
=TEX
{} is often useful as an opening gambit. 


The tactic 
=INLINEFT
strip_tac
=TEX
{} reduces the complexity in the conclusion of the goal, but does nothing to simplify the assumptions.  In order to give
=INLINEFT
strip_tac
=TEX
{}  as much as possible to work on, it may be useful  in the early stage of a proof to move complexity from the assumptions into the conclusion.  A tactic, 
=INLINEFT
all_undisch_tac
=TEX
, is available to achieve this effect.  In the following example, 
=INLINEFT
strip_tac
=TEX
{} is ineffective on a goal with such a simple conclusion(
=INLINEFT
U = V
=TEX
), but moving the assumptions into the conclusion with
=INLINEFT
all_undisch_tac
=TEX 
{} will make the conclusion amenable to 
=INLINEFT
(REPEAT strip_tac)
=TEX
.
\begin{session}

=SML
      push_goal ([¬P=Q®, ¬³ P = Q®],  ¬U = V®);
=GFT
      (*  2 *)  ¬³ P = Q®
      (*  1 *)  ¬P = Q®

      (* ?ô *)  ¬U = V®

=SML
      a all_undisch_tac;
=GFT
      (* ?ô *)  ¬³ P = Q ´ P = Q ´ U = V®

=SML
      a (REPEAT strip_tac);
=GFT
      Tactic produced 0 subgoals:
      Current and main goal achieved
=TEX
\end{session}

In this example, the conclusion of the final goal is in fact a tautology, so it would be amenable to other tactics, notably
=INLINEFT
taut_tac
=TEX
.
\begin{session}
=SML
      push_goal ([¬P=Q®, ¬³ P = Q®],  ¬U = V®);
=GFT
      (*  2 *)  ¬³ P = Q®
      (*  1 *)  ¬P = Q®

      (* ?ô *)  ¬U = V®

=SML
      a (all_undisch_tac THEN taut_tac);
=GFT
      Tactic produced 0 subgoals:
      Current and main goal achieved
=TEX
\end{session}

\subsection{Specializing the Assumptions}

Consider the following:
\begin{session}
=SML
      g ¬(µx·P x) ´ P y®;
=GFT
      (* ?ô *)  ¬(µ x· P x) ´ P y®

=SML
      a (REPEAT strip_tac);
=GFT
      (*  1 *)  ¬µ x· P x®

      (* ?ô *)  ¬P y®
=TEX
\end{session}

Here there is a universally-quantified assumption of which the conclusion is an instance.  There is an applicable tactic, called 
=INLINEFT
spec_nth_asm_tac
=TEX
{} which takes two arguments: 
\begin{itemize}
\item the assumption-number of the  relevant universal assumption (in this case, 1)
\item  a term in which to instantiate  the universal, so as to yield the conclusion. In this case the appropriate term would be 
=INLINEFT
¬y®
=TEX
.
\end{itemize}

\begin{session}
=SML
      a (spec_nth_asm_tac 1 ¬y®);
=GFT
      Tactic produced 0 subgoals:
      Current and main goal achieved.
=TEX
\end{session}

If specializing the universal is not sufficient to achieve the goal, the result is  simply to add the new specialized assumption to the list of assumptions.  This in itself may be a useful step towards achieving the goal, as the following example is contrived to show.
\begin{session}
=SML
      g ¬ (R = Q ±  (P y) ± µx· P x  ´ Q x) ´ R y®;
=GFT
      (* ?ô *)  ¬R = Q ± P y ± (µ x· P x ´ Q x) ´ R y®

=SML
      a (REPEAT strip_tac);
=GFT
      (*  3 *)  ¬R = Q®
      (*  2 *)  ¬P y®
      (*  1 *)  ¬µ x· P x ´ Q x®

      (* ?ô *)  ¬R y®

=SML
      a (spec_nth_asm_tac 1 ¬y®);
=GFT
      (*  4 *)  ¬R = Q®
      (*  3 *)  ¬P y®
      (*  2 *)  ¬µ x· P x ´ Q x®
      (*  1 *)  ¬Q y®

      (* ?ô *)  ¬R y®

=SML
      a (asm_rewrite_tac []);
=GFT
      Tactic produced 0 subgoals:
      Current and main goal achieved
=TEX
\end{session}

\subsection{Existentially Quantified Goals}

Consider the case when the conclusion of the goal is of the form 
=INLINEFT
¶x· P x
=TEX
.  It will commonly be the case that propositions of this form are achievable by producing a witness $w$ which has property $P$, so the goal becomes one of showing that 
=INLINEFT
P w
=TEX
{} is true.  The tactic 
=INLINEFT
¶_tac
=TEX
{} has the purpose of transforming the goal in this way, from  
=INLINEFT
¶x· P x
=TEX
{} to
=INLINEFT
P w
=TEX
.  The following  example takes the goal of proving that there is a number less than 1, and the required witness will be the number 0.
\begin{session}

=SML
      g ¬¶x·x < 1®;
=GFT
      (* ?ô *)  ¬¶ x· x < 1®

=SML
      a (¶_tac ¬0®);
=GFT
      (* ?ô *)  ¬0 < 1®
=TEX
\end{session}

This tactic has had the expected effect, but to proceed further we will need some facts about 
=INLINEFT
<
=TEX
,  that is, a theorem to rewrite with,  which defines 
=INLINEFT
<
=TEX
.  By inspecting the listing of the theory 
=INLINEFT
î
=TEX
{} we see that an appropriate theorem is available under the name  
=INLINEFT
<
=TEX
, and also  that we will need further facts about 
=INLINEFT
¼
=TEX
{} and 
+
=TEX
.  Thus it will be useful to gather up the necessary facts for use in rewriting:

\begin{session}
=SML
      val facts = (map (get_defn "î" ) ["<","¼", "+"]);
=GFT
      val facts = [
	ô µ m n· m < n ¤ m + 1 ¼ n,
	ô µ m n· m ¼ n ¤ (¶ i· m + i = n),
	ô µ m n· 0 + n = n ± 
	        (m + 1) + n = (m + n) + 1 ± 
                Suc m = m + 1] : THM list

=SML
      a (rewrite_tac facts);
=GFT
      (* ?ô *)  ¬¶ i· i + 1 = 1®
=TEX
\end{session}

The original existential goal has been transformed into another existential.  We continue in the same way, offering the same witness again and using the same facts for rewriting:

\begin{session}

=SML
      a (¶_tac ¬0®);
=GFT
      (* ?ô *)  ¬0 + 1 = 1®

=SML
      a (rewrite_tac facts);
=GFT
      Tactic produced 0 subgoals:
      Current and main goal achieved.
=TEX

\end{session}
\subsection{Contradiction and Resolution}

{\em to be supplied}


\cleardoublepage

\section{HOW TO GO ABOUT DOING A PROOF}

{\em (Perhaps about one  page here.  Suggestions welcomed.  Something along the following lines.  It is meant for learners.) }

The \HOL\ system does not purport to be a fully automatic theorem prover, and to a greater or lesser degree some non-trivial input on the part of the user may be necessary to achieve a proof of a given goal.  This section offers some recommendations, of a general nature, and is not meant to be systematically complete.
\begin{enumerate}
\item  Use the subgoaling package rather than forward proofs.
\item Use 
=INLINEFT
(REPEAT strip_tac)
=TEX
{} early and often to reduce the complexity of the goal.
\item Make use of the resources represented by the  theorems and definitions of the built-in theories. These can be seen in \REFERENCE\ or by executing 
=INLINEFT 
print_theory 
=TEX
.
\item Rewrite judiciously: that is, it is probably better to wait until it is evident that some rewriting with the definitions of terms is needed, rather than immediately rewriting with everything possible.

\item Look for contradictions in the assumptions: if found, then use resolution. 

\item If the conclusion is existentially quantified and a witness is readily to hand, use 
=INLINEFT
¶_tac
=TEX
.   If no ready witness, try 
=INLINEFT
contr_tac
=TEX
.
\item etc

\end{enumerate}

\bibliographystyle{fmu}
\bibliography{fmu} 

%%%% 999999

\end{document}

}

\item 




a (rewrite_tac (map (get_defn "î" ) ["¼", "+"] ) );
a (¶_tac ¬0®);
a (rewrite_tac (map (get_defn "î" ) ["+"] ) );


g ¬ (µx· (P x)  ´ Q x) ´  (R = Q) ´ P y ´ R y®;
a (REPEAT strip_tac);
a (spec_nth_asm_tac 1 ¬y®);
a (asm_rewrite_tac []);
g ¬ (R = Q ±  (P y) ± µx· P x  ´ Q x) ´ R y®;

Recall that the \SML\ type {\small\verb%thm_tactic%} abbreviates {\small\verb%theorem->tactic%}, 
and the type {\small\verb%conv%}\footnote{The type
{\small{\tt conv}} comes from Larry Paulson's theory of conversions
\cite{PAULSON83}.} abbreviates {\small\verb%term->thm%}.

\subsubsection{\tt rewrite\_tac:  THM list -> TACTIC}
\label{rewrite}

\begin{itemize}
\item{\bf Summary:} \ml{rewrite\_tac [} $th_1, \ldots ,th_n$  \ml{]}
simplifies the goal by rewriting
it with the explicitly given theorems $th_1$, $\ldots$ , $th_n$, 
and various built-in rewriting rules.


\begin{center}
\begin{tabular}{c} \\
$\{t_1, \ldots , t_m\}t$
\\ \hline \hline
$\{t_1, \ldots , t_m\}t'$
\\
\end{tabular}
\end{center}

\noindent where $t'$ is obtained from $t$ by rewriting with
\begin{enumerate}
\item  $th_1$, $\ldots$ , $th_n$ and
\item  the standard rewrites held in the \SML\ variable {\small\verb%basic_rewrites%}.
\end{enumerate}

\item{\bf Uses:} Simplifying goals using previously proved theorems.

\item{\bf Other rewriting tactics} (based on \ml{rewrite\_tac}):
\begin{enumerate}
\item \ml{asm\_rewrite\_tac} adds the assumptions of the goal to the list of
theorems used for rewriting.
\item \ml{fasm\_rewrite\_tac}{\small\verb% [%}$th_1${\small\verb%;%}$\ldots${\small\verb%;%}$th_n${\small\verb%]%} $p$
simplifies the goal by rewriting
it with the explicitly given theorems $th_1$ , $\ldots$ , $th_n$ , 
together with those
assumptions of the goal which satisfy the predicate $p$ and also
the built-in rewrites given by {\small\verb%get_basic_rewrites%}.
\item \ml{pure\_asm\_rewrite\_tac} is like \ml{asm\_rewrite\_tac}, but it
doesn't use any built-in rewrites.
\item \ml{pure\_rewrite\_tac} uses neither the assumptions nor the built-in
rewrites
\end{enumerate}
\end{itemize}


\subsubsection{\tt taut\_tac: TACTIC}




\begin{itemize}

\item{\bf Summary:} Solves a goal the conclusion of which is a tautology

\item{\bf Uses:} Solving tautological goals. \ml{taut\_tac} is invoked by other built-in tactics.  

\end{itemize}

Example:
\begin{session}
% =SML 
g ¬ ( x = 3) ²  ³ (x = 3)®;
=GFT
Now 4 goals on the main goal stack

(* *** Goal "" *** *)

(* ?ô *)  ¬x = 3 ² ³ x = 3®

val it = () : unit 
=TEX
%=SML 
a taut_tac;
=GFT
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit  
=TEX

%=SML 
g ¬µx· (x = 3 ) ²  ³(x = 3)®;
=GFT
Now 5 goals on the main goal stack

(* *** Goal "" *** *)

(* ?ô *)  ¬µ x· x = 3 ² ³ x = 3®

val it = () : unit
=TEX

%=SML 
a taut_tac;
=GFT
Exception-
   Fail * Conclusion of the goal is not a tautology [taut_tac.28121] * raised

=TEX
\end{session}

\subsubsection{\tt ±\_tac: TACTIC}

\begin{itemize}

\item{\bf Summary:} Splits a 
goal \ml{¬$t_1$ ± $t_2$®} into two subgoals  \ml{¬$t_1$ ®} 
and  \ml{¬ $t_2$®}.

\begin{center}
\begin{tabular}{c} \\
$t_1${\small\verb% /\ %}$t_2$
\\ \hline \hline
$t_1\ \ \ \ \ \ t_2$
\\
\end{tabular}
\end{center}

\item{\bf Uses:} Solving conjunctive goals. 
\ml{±\_tac} is invoked by \ml{strip\_tac} (see below).

\end{itemize}




\subsubsection{\tt ´\_tac: TACTIC }

\begin{itemize}

\item{\bf Summary:} Moves the antecedant 
of an implicative goal into the assumptions.

\begin{center}
\begin{tabular}{c} \\
$u$ \ml{´}$v$
\\ \hline \hline
$\{u\}v$
\\
\end{tabular}
\end{center}


\item{\bf Uses:} Solving goals of the form 
\ml{¬$u$´$v$®} by assuming \ml{¬$u$®}  and then solving \ml{¬$v$® }.
\ml{strip\_tac} (see below) will invoke \ml{´\_tac} on implicative goals.
\end{itemize}

\subsubsection{\tt simple\_µ\_tac: TACTIC}

\begin{itemize}

\item{\bf  Summary:} Strips off one universal quantifier.
   

\begin{center}
\begin{tabular}{c} \\
$µx·t[x]$
\\ \hline \hline
$t[x']$
\\
\end{tabular}
\end{center}

\noindent Where $x'$ is a variant of $x$ 
not free in the goal or the assumptions.

\item{\bf   Uses:} Solving universally quantified goals. 
\ml{REPEAT simple\_µ\_tac } strips off all
universal quantifiers and is often the first thing one does in a proof.

\ml{strip\_tac} (see below)  applies \ml{simple\_µ\_tac} to universally quantified goals.
\end{itemize}


\subsubsection{\tt IMP\_RES\_TAC : tactic}

This section to be rewritten.

\begin{itemize}

\item{\bf Summary:} {\small\verb%IMP_RES_TAC %}$th$
`resolves' (see below) $th$ with the 
assumptions of the goal
and then adds the results to the assumptions.


\begin{center}
\begin{tabular}{c} \\
$\{t_1,\ldots,t_m\}t$
\\ \hline \hline
$\{t_1,\ldots,t_m,u_1,\ldots,u_n\}t$
\\
\end{tabular}
\end{center}

\noindent  where $u_1$, $\ldots$ , $u_n$ 
are derived by `resolving' $th$ with $t_1$, $\ldots$ , $t_m$. 
Resolution in \HOL\ 
is not classical resolution, but just Modus Ponens
with a bit of one-way pattern matching (not unification). The usual case
is where $th$ is of the form

$\ \ \ ${\small\verb%|- !%}$x_1$$\ldots x_p${\small\verb%.%}$v_1${\small\verb%==>%}$v_2${\small\verb%==>%}$\ldots${\small\verb%==>%}$v_q${\small\verb%==>%}$v$. 

\noindent {\small\verb%IMP_RES_TAC %}$th$ then tries
to specialize $x_1$, $\ldots$ , $x_p$ 
so that  $v_1$, $\ldots$ , $v_q$ 
match members of $\{t_1,\ldots ,t_m\}$.
If such a match is found then the appropriate instance of $v$ is added
to the assumptions, together with all appropriate instances of 
$v_i${\small\verb%==>%}$\ldots v_n${\small\verb%==>%}$v$ ($2 \leq i \leq n$). 
{\small\verb%IMP_RES_TAC%} can also be given a conjunction of implications,
 in which case 
it will do
`resolution' with each of the conjuncts. In fact, 
it applies a canonicalization
rule to its argument to split it into a list of theorems.
Each theorem produced by this canonicalization process 
is resolved with the assumptions. Full details can be found in 
\REFERENCE\ (the canonicalization in \HOL\
is based on that done in Cambridge \LCF \cite{PAULSON87}, 
but differs slightly from it).

\item{\bf Uses:} Deriving new assumptions from existing 
ones and previously proved theorems
so that subsequent tactics (\eg\ \ml{asm\_rewrite\_tac}) have 
more to work with.
\end{itemize}


        
\subsubsection{\tt strip\_tac  : TACTIC}

\begin{itemize}

\item{\bf Summary:} Breaks a goal apart.
\ml{strip\_tac} removes one outer connective from the goal, using
\ml{±\_tac}, \ml{´\_tac},  \ml{simple\_µ\_tac}, \etc\  
If the goal has the form\ml{ $t_1$  ± $\cdots$ ± $t_n$ ´ $t$}
then each  $t_i$  is made into a  separate assumption.

\item{\bf Uses:} Useful for spliting a goal up into manageable pieces. 
Often the best thing to do first is \ml{REPEAT strip\_tac}.
\end{itemize}



\subsubsection{\tt id\_tac : tactic}

\begin{itemize}
\item{\bf Summary:} Identity tactic for the tactical {\small\verb%THEN%}
(see end of Section~\ref{tactics}).

\item{\bf Uses:}
\begin{enumerate}
\item Writing tacticals (see description of {\small\verb%REPEAT%} 
in Section~\ref{tacticals}). 
\item With {\small\verb%THEN_LIST%}; for example, if tactic $T$ produces two subgoals 
and we want to apply $T_1$ 
to the first one but to do nothing to the second, then 
the tactic to use is $T${\small\verb% THEN_LIST[%}$T_1${\small\verb%;id_tac]%}.
\end{enumerate}
\end{itemize}

\subsubsection{\tt fail\_tac : tactic}

\begin{itemize}
\item{\bf Summary:} Tactic that always fails.

\item{\bf Uses:} Writing tacticals.
\end{itemize}

\makeatletter   




% \newpage
% \twocolumn[\section{INDEX}]
% \small
% \printindex

\end{document}







