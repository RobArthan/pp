=IGNORE
 % U s e f u l C o m m a n d s

poly -r ~ied/rel001/latest/sun3hol.db
poly sun3hol.db
PolyML.quit();
rm -f *.aux *.dvi *.idx *.log *.sid 
doc4tex usr004
tex4dvi usr004
tex4dvi usr004
bibtex usr004
tex4dvi usr004
dvipage usr004
=TEX
\documentstyle[foo,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
    \TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
      \TPPtitle{INTRODUCTION TO ICL HOL}  %% Mandatory field
         \TPPref{DS/FMU/IED/USR004}  %% Mandatory field
\def\SCCSversion{
}
        \TPPissue{$Revision$%
}  %% Mandatory field
%        \TPPdate{\FormatDate{$Date$
}}
\TPPstatus{Informal}			%% Mandatory field
\TPPtype{Technical Note}
\TPPkeywords{}
\TPPauthor{R. Stokes & WIN01}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & Project Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    HAT Team Members
}}

\makeatletter
\def‹{\@Mm{\mid\!\equiv}}
\defö{\@Mm{\hbox{\Large$\triangleleft$}}}
\def∑{\@Mm{\mid\!\sim}}
\defÔ{\@Mm{\mid\!\Rightarrow}}
\def™{\@Mm{{\#}}}
\defê{\@Mm{\leftrightarrow}}
\defó{\@Mm{\mapsto}}
%\defó{\@Mm{\stackrel{\hbox{\scriptsize ?}}{\mapsto}}}
\defπ{\@Mm{\rightleftharpoons}}
\def‰{\@Mm{\{\}}}
\def—{\@Mm{\langle\rangle}}

\def”{\@Mm{^{-1}}}
\makeatother


\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\newpage
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu} 

\subsection{Changes history} 
\begin{description}
\item[1.1]
Initial Draft.

\end{description}
\subsection{Changes forecast}



% =====================================================================
%
% Macros for typesetting the HOL system manual
%
% =====================================================================

% ---------------------------------------------------------------------
% Abbreviations for words and phrases
% ---------------------------------------------------------------------
\newcommand\VERSION{{\small\tt 1.10}}
\newcommand\TUTORIAL{{\footnotesize\sl INTRODUCTION}}
\newcommand\DESCRIPTION{{\footnotesize\sl DESCRIPTION}}
\newcommand\REFERENCE{{\footnotesize\sl REFERENCE MANUAL}}

\def\HOL{{\small HOL}}
\def\LCF{{\small LCF}}
\def\LCFLSM{{\small LCF{\kern-.2em}{\normalsize\_}{\kern0.1em}LSM}}
\def\PPL{{\small PP}{\kern-.095em}$\lambda$}
\def\PPLAMBDA{{\small PPLAMBDA}}
\def\SML{{\small Standard ML}}

\newcommand\ie{\mbox{i{.}e{.}}}
\newcommand\eg{\mbox{e{.}g{.}}}
\newcommand\viz{\mbox{viz{.}}}
\newcommand\adhoc{\mbox{\it ad hoc}}
\newcommand\etal{{\it et al.\/}}
\newcommand\etc{\mbox{etc{.}}}
\def\see#1#2{{\em see\/} #1}

% ---------------------------------------------------------------------
% Simple abbreviations and macros for mathematical typesetting
% ---------------------------------------------------------------------

\newcommand\fun{{\to}}
\newcommand\prd{{\times}}

\newcommand\conj{\ \wedge\ }
\newcommand\disj{\ \vee\ }
\newcommand\imp{ \Rightarrow }
\newcommand\eqv{\ \equiv\ }
\newcommand\cond{\rightarrow}
\newcommand\vbar{\mid}
\newcommand\turn{\ \vdash\ }
\newcommand\hilbert{\varepsilon}
\newcommand\eqdef{\ \equiv\ }

\newcommand\natnums{\mbox{${\sf N}\!\!\!\!{\sf N}$}}
\newcommand\bools{\mbox{${\sf T}\!\!\!\!{\sf T}$}}

\newcommand\p{$\prime$}
\newcommand\f{$\forall$\ }
\newcommand\e{$\exists$\ }

\newcommand\orr{$\vee$\ }
\newcommand\negg{$\neg$\ }

\newcommand\arrr{$\rightarrow$}
\newcommand\hex{$\sharp $}

\newcommand{\uquant}[1]{\forall #1.\ }
\newcommand{\equant}[1]{\exists #1.\ }
\newcommand{\hquant}[1]{\hilbert #1.\ }
\newcommand{\iquant}[1]{\exists ! #1.\ }
\newcommand{\lquant}[1]{\lambda #1.\ }

\newcommand{\leave}[1]{\\[#1]\noindent}
\newcommand\entails{\mbox{\rule{.3mm}{4mm}\rule[2mm]{.2in}{.3mm}}}

% --------------------------------------------------------------------- 
% Font-changing commands
% ---------------------------------------------------------------------

\newcommand{\theory}[1]{\hbox{{\small\tt #1}}}

\newcommand{\con}[1]{{\sf #1}}
\newcommand{\rul}[1]{{\tt #1}}
\newcommand{\ty}[1]{{\sl #1}}

\newcommand{\ml}[1]{\mbox{\small\tt #1}}
\newcommand\ms{\tt}
\newcommand{\s}[1]{{\small #1}}

\newcommand{\pin}[1]{{\bf #1}}
\def\m#1{\mbox{\normalsize$#1$}}

% ---------------------------------------------------------------------
% Abbreviations for particular mathematical constants etc.
% ---------------------------------------------------------------------

\newcommand\T{\con{T}}
\newcommand\F{\con{F}}
\newcommand\OneOne{\con{One\_One}}
\newcommand\OntoSubset{\con{Onto\_Subset}}
\newcommand\Onto{\con{Onto}}
\newcommand\TyDef{\con{Type\_Definition}}
\newcommand\Inv{\con{Inv}}
\newcommand\com{\con{o}}
\newcommand\Id{\con{I}}
\newcommand\MkPair{\con{Mk\_Pair}}
\newcommand\IsPair{\con{Is\_Pair}}
\newcommand\Fst{\con{Fst}}
\newcommand\Snd{\con{Snd}}
\newcommand\Suc{\con{Suc}}
\newcommand\Nil{\con{Nil}}
\newcommand\Cons{\con{Cons}}
\newcommand\Hd{\con{Hd}}
\newcommand\Tl{\con{Tl}}
\newcommand\Null{\con{Null}}
\newcommand\ListPrimRec{\con{List\_Prim\_Rec}}


\newcommand\SimpRec{\con{Simp\_Rec}}
\newcommand\SimpRecRel{\con{Simp\_Rec\_Rel}}
\newcommand\SimpRecFun{\con{Simp\_Rec\_Fun}}
\newcommand\PrimRec{\con{Prim\_Rec}}
\newcommand\PrimRecRel{\con{Prim\_Rec\_Rel}}
\newcommand\PrimRecFun{\con{Prim\_Rec\_Fun}}

\newcommand\bool{\ty{bool}}
\newcommand\num{\ty{num}}
\newcommand\ind{\ty{ind}}
\newcommand\lst{\ty{list}}

% ---------------------------------------------------------------------
% \minipagewidth = \textwidth minus 1.02 em
% ---------------------------------------------------------------------

\newlength{\minipagewidth}
\setlength{\minipagewidth}{\textwidth}
\addtolength{\minipagewidth}{-1.02em}

% ---------------------------------------------------------------------
% Environment for the items on the title page of a case study
% ---------------------------------------------------------------------

\newenvironment{inset}[1]{\noindent{\large\bf #1}\begin{list}%
{}{\setlength{\leftmargin}{\parindent}%
\setlength{\topsep}{-.1in}}\item }{\end{list}\vskip .4in}

% ---------------------------------------------------------------------
% Macros for little HOL sessions displayed in boxes.
%
% Usage: (1) \setcounter{sessioncount}{1} resets the session counter
%
%	 (2) \begin{session}\begin{verbatim}
%	      .
%	       < lines from hol session >
%	      .
%	     \end{verbatim}\end{session}   
%
%            typesets the session in a numbered box.
% ---------------------------------------------------------------------

\newlength{\hsbw}
\setlength{\hsbw}{\textwidth}
\addtolength{\hsbw}{-\arrayrulewidth}
\addtolength{\hsbw}{-\tabcolsep}
\addtolength{\hsbw}{-0.5in}
 % \addtolength{\hsbw}{0.25in}
\newcommand\HOLSpacing{13pt}

\newcounter{sessioncount}
\setcounter{sessioncount}{1}

\newenvironment{session}{\begin{center}
 \begin{tabular}{@{}|c@{}|@{}}\hline 
 \begin{minipage}[b]{\hsbw}
 \vspace*{-.5pt}
 \begin{flushright}
 \rule{0.01in}{.15in}\rule{0.3in}{0.01in}\hspace{-0.35in}
 \raisebox{0.04in}{\makebox[0.3in][c]{\footnotesize\sl \thesessioncount}}
 \end{flushright}

  \vspace*{-.25in}

 \begingroup\small\baselineskip\HOLSpacing}{\endgroup\end{minipage}\\ \hline 
 \end{tabular}
 \end{center}
 \stepcounter{sessioncount}}

% ---------------------------------------------------------------------
% Macro for boxed ML functions, etc.
%
% Usage: (1) \begin{boxed}\begin{verbatim}
%	        .
%	        < lines giving names and types of mk functions >
%	        .
%	     \end{verbatim}\end{boxed}   
%
%            typesets the given lines in a box.  
%
%            Conventions: lines are left-aligned under the "g" of begin, 
%	     and used to highlight primary reference for the ml function(s)
%	     that appear in the box.
% ---------------------------------------------------------------------

\newenvironment{boxed}{\begin{flushleft}
 \begin{tabular}{@{}|c@{}|@{}}\hline 
 \begin{minipage}[b]{\hsbw}
% \vspace*{-.55in}
 \vspace*{.06in}
 \begingroup\small\baselineskip\HOLSpacing}{\endgroup\end{minipage}\\ \hline 
 \end{tabular}
 \end{flushleft}}

% ---------------------------------------------------------------------
% Macro for unboxed ML functions, etc.
%
% Usage: (1) \begin{hol}\begin{verbatim}
%	        .
%	        < lines giving names and types of mk functions >
%	        .
%	     \end{verbatim}\end{hol}   
%
%            typesets the given lines exactly like {boxed}, except there's
%	     no box.  
%
%            Conventions: lines are left-aligned under the "g" of begin, 
%	     and used to display ML code in verbatim, left aligned.
% ---------------------------------------------------------------------

\newenvironment{hol}{\begin{flushleft}
 \begin{tabular}{c@{}@{}}
 \begin{minipage}[b]{\hsbw}
% \vspace*{-.55in}
 \vspace*{.06in}
 \begingroup\small\baselineskip\HOLSpacing}{\endgroup\end{minipage}\\
 \end{tabular}
 \end{flushleft}}

% ---------------------------------------------------------------------
% Emphatic brackets
% ---------------------------------------------------------------------

\newcommand\leb{\lbrack\!\lbrack}
\newcommand\reb{\rbrack\!\rbrack}

% ---------------------------------------------------------------------
% Snow watching lantern
% ---------------------------------------------------------------------

\newcommand\medlantern{{\makebox[3.652in][l]{
  \vbox to 3.875in{\vfill\special{psfile=../LaTeX/HOL_med.ps}}
  \vspace{-\baselineskip}}}}

% The stuff below does not work
% ---------------------------------------------------------------------
% New \part with JVT's snow watching lantern
% ---------------------------------------------------------------------

%\def\part{\cleardoublepage \thispagestyle{plain} \if@twocolumn \onecolumn
%\@tempswatrue \else \@tempswafalse \fi \hbox{}\vfil \secdef\@part\@spart} 


%\def\@part[#1]#2{\ifnum \c@secnumdepth >-2\relax \refstepcounter{part}
%\addcontentsline{toc}{part}{\thepart \hspace{1em}#1}\else
%\addcontentsline{toc}{part}{#1}\fi \markboth{}{}
% {\centering \ifnum \c@secnumdepth >-2\relax \huge\bf Part \thepart \par
%\vskip 20pt \fi \Huge \bf #1\par}\@endpart} 
%\def\@endpart{\medlantern\vfil\newpage \if@twoside \hbox{} \thispagestyle{empty} 
% \newpage 
% \fi \if@tempswa \twocolumn \fi} 
%\def\@spart#1{{\centering \Huge WONK \bf #1\par}\@endpart}



\long\def\suppress#1{}

\pagebreak

% *********************************************************************
% HOL Manual LaTeX Source: tutorial
% *********************************************************************
% Counter Peano used in logic.tex 
\newcounter{Peano} 
\setcounter{Peano}{1}


   \setlength{\unitlength}{1mm}		  % unit of length = 1mm
   \setlength{\baselineskip}{16pt}        % line spacing = 16pt

\ftaboveboxskip=5pt plus 2pt minus 2pt
\ftbelowboxskip=5pt plus 2pt minus 2pt
   
%   \pagenumbering{arabic}		 % arabic page numbers
%   \setcounter{page}{1}	         % start at page 1

   \label{getting-started}

% section General Introduction goes here
%  \include{new-preface}	  
=TEX

\section{GENERAL INTRODUCTION}

% \chapter*{Preface}\markboth{Preface}{Preface}
\label{intro}

This volume contains the introduction to the \HOL\ system.  It is one of several documents making up the documentation for \HOL:

\begin{enumerate}
\item \TUTORIAL: (this volume), a tutorial introduction to \HOL.
\item \DESCRIPTION: \cite{DS/FMU/IED/USR005}, a description of higher order logic,
the \SML\ programming language, and theorem proving methods in the \HOL\ system;
\item \REFERENCE: \cite{DS/FMU/IED/USR006}, the reference documentation of the tools available in \HOL.
\item Supplementary Guides: a collection of documents on special topics, most notably the Installation Guide, \cite{DS/FMU/IED/USR007}.
\end{enumerate}


\noindent The first  three of these documents will be referred to by the short names (in
small slanted capitals) given above.

This document, \TUTORIAL, is intended
to be the first item read by new users of of \HOL.
It provides a 
study package for learning the basic points of the structure and  
use of the system.

The tutorial  is an introductory \HOL\ course which gives 
a `hands-on' feel for the way \HOL\ is used,
but which does not systematically explain the underlying priciples.
(The second document, \DESCRIPTION, explains the principles.)
After working through  the tutorial,
the reader should be capable of using \HOL\ for simple tasks, and 
should also be in a
position to approach the other two documents.


Once the \HOL\ system is installed on the target workstation,
the potential \HOL\ user should become familiar with the following subjects:

\begin{enumerate}
\item The programming meta-language \SML, and how to interact
with it through an editor.  The description of  \SML\ given here is very brief, only intended to be sufficient to support the exposition of \HOL. For a more complete introduction to \SML\ the reader is referred to \cite{HARPER88} or \cite{WIKSTROM87}. 
\item The formal logic supported by 
the \HOL\ system (higher order logic) and its manipulation via \SML.
\item Forward proof and derived rules of inference.
\item Goal directed proof, and tactics and tacticals.
\end{enumerate}

\noindent The sections that follow cover these topics in the sequence shown above. This tutorial has been kept as short as possible so that
the installation of the system and
steps 1
to 4 can be mastered reasonably quickly. 
\subsection{Acknowledgements}

These documents have drawn very heavily on \cite{SRI89B}, \cite{SRI89A} and \cite{SRI89C}



=TEX
\section{TUTORIAL: GETTING STARTED}
\label{install}

Reference \cite{DS/FMU/IED/USR007} , the Installation Guide, describes the procedure for the installation of HOL. 

It is presumed  in what follows, if the reader is following the tutorial at a workstation and trying out the examples interactively,  that the installation procedure  been performed  successfully and that the user has available an installed HOL system.

In this tutorial, the sequences of user's interactions with the system and the system's responses are called ``sessions''. 
All sessions in this documentation will be displayed in boxes with  a number in
the top right hand corner.
This number indicates whether the session  is a new
one (when the number will be {\small\sl  1}) or  the continuation  of a session
started in an earlier box.  Consecutively numbered boxes are assumed to be part
of a single continuous session. 

 The Unix prompt for the sessions is shown as 
{\small\verb+Unix>+}, so lines beginning with this prompt  were typed  by the user.  On the user's actual system, the Unix prompt may be different from what is shown here.


After entering  the  \HOL\  system  (see  below),  the  user  is  prompted 
 for an expression  or command of the  \HOL\ meta-language \SML.

In this tutorial,  this prompt is  (nearly always) symbolized by  \verb+:>+.  

The system's response which follows the user's input is indicated by a different typeface. 

{\em At this point, a description of the use of the keyboard with the extended character-set  is to be provided.} 

The following shows an example of entering the \HOL\ system.   It should be noted that this example is specific to a particular vendor of the \SML\ system in use, and also to any local arrangements made during or after installation, for example, for the naming of Unix directories. 

The HOL system is entered by a command at the Unix prompt, invoking the \SML\ system and giving as parameter the name of a {\em database}.  The system supplied database is named (tbs). It contains  the \SML\ functions and other defined objects which constitute the \HOL\ system.
The reader may find it desirable to have to hand vendor-specific documentation on the \SML\ system in use, which shows,  for example, how to recover from a syntax error in input, how to return from \SML\ back to Unix, or how to effect updates to the database.

     

\setcounter{sessioncount}{1}
\begin{session}

\begin{verbatim}
Unix>  poly example.db   (for example !)
\end{verbatim}

Û
here will appear a sign-on message from the Standard ML system, followed by a prompt
Ê

Â
    (*  here the user types in Standard ML  *)
Ê

Û
here the response of the system will appear
Ê

Â
    (*  here the user types in more  Standard ML  *)
Ê

Û
here another response of the system will appear
Ê

Â
 (*  after repeated exchanges as above, to terminate and return to Unix ,
     the user types .... *)

PolyML.quit();  (for example !)  
Ê

\begin{verbatim}
Unix>
\end{verbatim}

\end{session}


 %  \include{new-ml}			 % intro to ml

=TEX
\section{TUTORIAL: INTRODUCTION TO STANDARD ML}
\label{ML}

This chapter is a brief introduction to the meta-language \SML.  The aim is just
to give a feel  for what  it is  like to  interact with  the language.   For a more complete introduction to \SML\ the reader is referred to \cite{HARPER88} or \cite{WIKSTROM87}.

\SML\ is an interactive programming language . At top level one can
evaluate expressions and perform declarations. The former results in the
expression's value and type being printed, the latter in a value being
bound to a name.  

The normal way to interact with \SML\ is to configure the workstation screen so that
there are two windows:
\begin{enumerate}
\item An editor window into which \SML\ commands are initially typed and recorded.
\item A shell window (or non-Unix equivalent) which is used to evaluate the
commands.
\end{enumerate}


After typing a command into the edit (text) window it can be transferred to the
shell and evaluated in \HOL\ by `cut-and-paste'. The advantage of working via an editor is that
if the command has an error, then the text can simply be edited and used again; it
also records the commands in a file which can then be used again (via a batch load)
later.  The sessions in this tutorial are split into segments displayed in boxes with a
number in their top right hand corner (to indicate their position in the complete
session).

The interactions in these boxes should be understood as occurring in
sequence.  For example, variable bindings made in earlier boxes are assumed
to persist to later ones.  To enter the \HOL\ system one types
a command to Unix, as explained above.  When this has been done, a dialogue with  \SML\ and \HOL\ can begin, as shown in the following sessions.
\setcounter{sessioncount}{1}

\begin{session}
Â
1+1;
Ê
Û
val it = 2 : int   
Ê
\end{session}

This session shows an example of entering a \SML\ expression, ``at the top level'', which is then evaluated and the result displayed.  The  semicolon `\ml{;}' terminates a top-level phrase. The display of the result can be seen\footnote{with the version of Standard ML currently in use} to consist of:
\begin{itemize}
\item The letters ``val'', indicating that a value is to follow.
\item A name for the value.  In this case the user has not supplied any name, having merely typed in the anonymous expression \ml{1+1}, and so the system supplies the name $it$.   The value of the most-recently-entered anonymous expression at the top level can always be referred to as $it$.
\item  The symbol $=$. 
\item The value, in this case 2.  \footnote{Note: as will be seen below, when the value to be displayed is that of a function, all that is displayed is merely the letters ``fn''}.
\item A colon followed by an indication of the type of the value.  In this case, the value 2 is of type integer, abbreviated to $int$.  The \SML\ type checker infers the type of expressions using methods invented by Robin Milner, \cite{MILNER78}. 
\end{itemize}

Here is another example.

\begin{session}
Â
1::[2,3,4,5];
Ê
Û
val it = [1, 2, 3, 4, 5] : int list   
Ê

\end{session}


The \SML\ expression  \ml{1::[2,3,4,5]} has the form $e_1\ op\ e_2$ where
$e_1$ is the expression \ml{1} (whose value is the integer $1$), $e_2$ is
the expression \ml{[2,3,4,5]} (whose value is a list of four integers)
and $op$ is the infixed operator \ml{::}, which forms a list with  the  left-argument as head and right argument (a list) as tail. Other list processing functions include \ml{hd}  (take the head of a list), \ml{tl}  (take the tail of a list)  and \ml{is\_nil} (which tests for an empty list).
  
The type \ml{int list} is the type of `lists of
integers'; \ml{list} is a unary type operator.  The type system of \SML\
is very similar to the type system of the \HOL\ logic which is explained in
Chapter~\ref{HOLlogic}.



\begin{session}
Â
val L = it;
Ê
Û
val L = [1, 2, 3, 4, 5] : int list   
Ê

Â
tl L;
Ê
Û
val it = [2, 3, 4, 5] : int list   
Ê

Â
hd it;
Ê
Û
val it = 2 : int   
Ê

Â
tl(tl(tl(tl(tl L))));
Ê
Û
val it = [] : int list   
Ê
\end{session}

Following standard $\lambda$-calculus usage, the application of a function
$f$ to an argument $x$ can be written without brackets as $f\ x$ (although
the more conventional $f$ \ml{(}$x$\ml{)} is also
allowed).  The expression $f\ x_1\ x_2\ \cdots\ x_n$ abbreviates the less
intelligible expression {\small\verb%(%}$\cdots${\small\verb%((%}$f\ 
x_1${\small\verb%)%}$x_2${\small\verb%)%}$\cdots${\small\verb%)%}$x_n$
(function application is left associative).

Declarations have the form {\small\verb%val
%}$x_1${\small\verb%=%}$e_1${\small\verb% and %}$\cdots
${\small\verb% and %}$x_n${\small\verb%=%}$e_n$ and result in the value of
each expression $e_i$ being bound to the name $x_i$.

\begin{session}
Â
val L1 = [1,2,3] and L2 = ["a","b","c"];
Ê
Û
val L1 = [1, 2, 3] : int list   val L2 = ["a", "b", "c"] : string list   
Ê

\end{session}


\SML\ expressions like {\small\verb%"a"%}, {\small\verb%"b"%},
{\small\verb%"foo"%} \etc\ are {\it strings\/} and have type
{\small\verb%string%}. Any sequence of {\small ASCII} characters can be
written between the quotes. The function {\small\verb%^%} concatenates two strings to form a single string.
\begin{session}
Â
"tog" ^ "ether";
Ê
Û
val it = "together" : string   
Ê
\end{session}

An expression of the form
{\small\verb%(%}$e_1${\small\verb%,%}$e_2${\small\verb%)%} evaluates to a
pair of the values of $e_1$ and $e_2$. If $e_1$ has type $\sigma_1$ and
$e_2$ has type $\sigma_2$ then
{\small\verb%(%}$e_1${\small\verb%,%}$e_2${\small\verb%)%} has type
$\sigma_1${\small\verb%*%}$\sigma_2$.  A tuple
{\small\verb%(%}$e_1${\small\verb%,%}$\ldots${\small\verb%,%}$e_n${\small\verb%)%}
is  NOT in general  equivalent to
{\small\verb%(%}$e_1${\small\verb%,(%}$e_2${\small\verb%,%}$\ldots${\small\verb%,%}$e_n${\small\verb%))%}
. The first and
second components of a pair (but not a tuple of length greater than two)  can be extracted with the \SML\ functions
{\small\verb%fst%} and {\small\verb%snd%} respectively. The i'th component of a tuple can be extracted with a function the name of which is of the form  {\small\verb%#i%}.

\begin{session}
Â
(1, 2, (true, "abc"));
Ê
Û
val it = (1, 2, (true, "abc")) : int * int * (bool * string) 
Ê

Â
#3 it;
Ê
Û
val it = (true, "abc") : bool * string   
Ê

Â
snd it;
Ê
Û
val it = "abc" : string   
Ê


\end{session}

\noindent The \SML\ expressions {\small\verb%true%} and {\small\verb%false%}
denote the two truth values of type {\small\verb%bool%}.

\SML\ types can contain the {\it type variables\/} {\small\verb%'a%},
{\small\verb%'b%},  \etc\ Such types are called {\it
polymorphic\/}. A function with a polymorphic type should be thought of as
possessing all the types obtainable by replacing type variables by types.
This is illustrated below with the function {\small\verb%zip%}.

Functions can be defined with declarations of the form {\small\verb%fun%}$\ f\
v_1\ \ldots\ v_n$ \ml{=} $e$ where each $v_i$ is either a variable or a pattern
build out of variables.\footnote{The chapters on ML in \DESCRIPTION\ give
exact details.} 
The function {\small\verb%zip%}, below, converts a pair of lists
{\small\verb%([%}$x_1${\small\verb%,%}$\ldots${\small\verb%,%}$x_n${\small\verb%],
[%}$y_1${\small\verb%,%}$\ldots${\small\verb%,%}$y_n${\small\verb%])%} to a
list of pairs
{\small\verb%[(%}$x_1${\small\verb%,%}$y_1${\small\verb%),%}$\ldots${\small\verb%,(%}$x_n${\small\verb%,%}$y_n${\small\verb%)]%}.

\begin{session}


Â
fun zip (x,y) = 
	if is_nil x orelse is_nil y 
	then nil 
	else (hd x, hd y):: zip(tl x, tl y);
Ê
Û
val zip = fn : 'a list * 'b list -> ('a * 'b) list
Ê

Â
zip([1,2,3],["a","b","c"]);
Ê
Û
val it = [(1, "a"), (2, "b"), (3, "c")] : (int * string) list  
Ê
\end{session}

Functions may be {\it curried\/}, \ie\ take their arguments `one at a time'
instead of as a tuple.  This is illustrated with the function
{\small\verb%curried_zip%} below:

\typeout{point 1}

\begin{session}
Â
fun curried_zip x y = zip(x,y);
Ê
Û
val curried_zip = fn : 'a list -> 'b list -> ('a * 'b) list
Ê

Â
val zip_num  = curried_zip [0,1,2];
Ê
Û
val zip_num = fn : 'a list -> (int * 'a) list   
Ê

Â
zip_num ["a","b","c"];
Ê
Û
val it = [(0, "a"), (1, "b"), (2, "c")] : (int * string) list
Ê
\end{session}


\typeout{point 2}

Note that in the definition of {\small\verb%zip_num%} above
the definition begins {\small\verb%val zip_num %} and not 
 {\small\verb%fun zip_num%}, because we do not wish to mention parameters on the left of the $=$, and thus  cannot use the syntactic form beginning {\small\verb%fun name param ... = ... %}.

\typeout{point 3}

Curried function are useful because they can be `partially applied' as
illustrated above by the partial application of {\small\verb%curried_zip%}
to {\small\verb%[0,1,2]%} which results in the function
{\small\verb%zip_num%}.

The evaluation of an expression either {\it succeeds\/} or {\it fails\/}.
In the former case, the evaluation returns a value; in the latter case the
evaluation is aborted and a failure string (usually the name of the
function that caused the failure) is passed to whatever invoked the
evaluation. This context can either propagate the failure (this is the
default) or it can {\it trap\/} it. These two possibilities are illustrated
below.  A failure trap is an expression of the form
$e_1${\small\verb% handle exception-name => %}$e_2$. An expression of this form is evaluated by
first evaluating $e_1$. If the evaluation succeeds (\ie\ doesn't fail) then
the value of $e_1${\small\verb%handle exception-name =>%}$e_2$ is the value of $e_1$.  If the
evaluation of $e_1$ fails in such a way as to raise the exception condition associated with  {\small\verb%  exception-name%}, then the value of $e_1${\small\verb% handle exception-name => %}$e_2$ is
obtained by evaluating $e_2$.

Exceptions and their names can be system-defined or user-defined. If the name of a possible exception is not known beforehand, then "?" can be used as a general name, as illustrated in the 
example below.

\begin{session}

Â
hd[];
Ê

Û
Exception- Fail *** ERROR 1002 raised by hd: An empty list has no head ***   raised
Exception+ failure handled by useterminal
Ê

Â
hd [] handle ? => [];
Ê

Û
val it = [] : 'a list   

Ê


\end{session}

The sessions  above  are enough  to give  a feel  for \SML.   
In the  nextsections,  the logic  supported by  the \HOL\  system (higher order
logic) will be introduced, together with the tools in \SML\ for manipulating it.

 %  \include{new-logic}			 % the HOL logic
=TEX
\section{TUTORIAL: THE HOL LOGIC}
\label{HOLlogic}

The \HOL\  system  supports {\it  higher order  logic}.   This is  a version of
predicate calculus with three main extensions:

\begin{itemize}
\item Variables can range over functions and predicates
(hence `higher order').
\item The logic is {\it typed}.
\item There is no separate syntactic category of {\it formulae\/}
(terms of type \ml{bool} fulfil their role).
\end{itemize}

\subsection{Overview of higher order logic}

It is assumed  the reader  is familiar  with predicate  logic.   The syntax and
semantics of  particular  logical  system  supported  by \HOL\  is described in
detail in  \DESCRIPTION.   The table  below summarizes the
notation used.


\bigskip

\begin{center}
\begin{tabular}{|l|l|l|l|} \hline
\multicolumn{4}{|c|}{ } \\
\multicolumn{4}{|c|}{\bf Terms of the HOL Logic} \\
\multicolumn{4}{|c|}{ } \\
{\it Kind of term} & {\it \HOL\ notation} & 
{\it Standard notation} &
{\it Description} \\ \hline
 & & & \\ 
Truth & {\small\verb14:34:01} & $\top$ & {\it true}\\ \hline
Falsity & {\small\verb/hat/projects/ied/SCCS/s.usr004.doc} & $\bot$ & {\it false}\\ \hline
Negation & å$t$ & $\neg t$ & {\it not}$\ t$\\ \hline
Disjunction & $t_1$Å$t_2$ & $t_1\vee t_2$ &
$t_1\ ${\it or}$\ t_2$ \\ \hline
Conjunction & $t_1$Ä$t_2$ & $t_1\wedge t_2$ &
$t_1\ ${\it and}$\ t_2$ \\ \hline
Implication & $t_1$ä$t_2$ & $t_1\imp t_2$ &
$t_1\ ${\it implies}$\ t_2$ \\ \hline
Equality & $t_1${\small\verb%=%}$t_2$ & $t_1 = t_2$ &
$t_1\ ${\it equals}$\ t_2$ \\ \hline
$\forall$-quantification & É$x$é$t$ &
$\uquant{x}t$ & {\it for\ all\ }$x: t$ \\ \hline
$\exists$-quantification & Ñ$x$é$t$ &
$\equant{x}\ t$ & {\it for\ some\ }$x: t$ \\ \hline
$\hilbert$-term & á $x$é$t$ &
$\hquant{x}t$ & {\it an}$\ x\ ${\it such\ that:}$\ t$ \\ \hline
Conditional & {\small\verb%(%}$t${\small\verb%=>%}$t_1${\small\verb%|%}$t_2${\small\verb%)%} &
$(t\rightarrow t_1, t_2)$ & {\it if\ }$t${\it \ then\ }$t_1${\it\ else\ }$t_2$
 \\ \hline
\end{tabular}
\end{center}\label{logic-table}

\bigskip


Terms of the \HOL\ logic are represented in \SML\ by an {\it abstract
type\/}\footnote{Abstract types appear to  the user  as primitive  types with a
collection of operations; they are described in 
\DESCRIPTION}  called  {\small\verb%TERM%}.   They are represented as character strings which are input, not between the  usual quotations symbols but  rather  between
the symbols ª and º.  
 For example,  the expression  \ml{ ª x Ä y ä zº } evaluates in \SML\ to a term representing \ml{  x Ä y ä z }. Terms
can be manipulated by various built-in \SML\ functions.   For  example, the \SML\
function \ml{dest\_ä}  with  \SML\  type  \ml{TERM -> TERM * TERM} splits an implication into  a pair  of terms  consisting of  its antecedent and
consequent, and the \SML\ function \ml{dest\_Ä} of  type \ml{TERM -> TERM * TERM} splits a conjunction into its two conjuncts.

\setcounter{sessioncount}{1}
\begin{session}

Â
ªxÄyäzº;
Ê
Û
val it = ªx Ä y ä zº : TERM   
Ê

Â
dest_ä it; 
Ê
Û
val it = (ªx Ä yº, ªzº) : TERM * TERM   
Ê

Â
dest_Ä (fst it);
Ê
Û
val it = (ªxº, ªyº) : TERM * TERM   
Ê
\end{session}

Terms of the \HOL\ logic are quite similar in appearance to \SML\ expressions, but the distinction must be carefully observed.  Indeed, terms of the logic have types  in a way which is similar  to the way in which
\SML\ expressions have types.   For example,  \ml{ª1º} is  a \SML\ expression
with \SML\ type {\small\verb%TERM%}.  The \HOL\ type of this term is  \ml{:Ü}, the type of the natural numbers. 

The types of \HOL\ terms form a \SML\ type called \ml{TYPE}.
Expressions having the form \ml{ª: ....º }
evaluate to logical types.  The built-in function {\small\verb%type_of%}
has \SML\ type {\small\verb%TERM -> TYPE%} and returns the logical type of a
term.

\typeout{logic point 5}

\begin{session}
Â
ª(1,2)º;
Ê
Û
val it = ª(1, 2)º : TERM   
Ê

Â
type_of it;
Ê

Û
val it = ª:Ü â Üº : TYPE   
Ê

Â
(ª1º, ª2º);
Ê

Û
val it = (ª1º, ª2º) : TERM * TERM
Ê

Â
type_of (fst it);
Ê

Û
val it = ª:Üº : TYPE   
Ê

\end{session}

\typeout{logic point 6}


To emphasise the distinction between between   the \SML\ types of \SML\ expressions and the logical types of \HOL\ terms 
, the former will be referred to as {\it meta-language types\/} and the latter as {\it object language types\/}.

\index{meta-language} \index{object language}

For example,  \ml{ª(1,T)º}
 is a \SML\ expression that has meta-language type \ml{TERM}
 and evaluates to a term with object language type
\ml{ ª:Ü â BOOLº}.  The expression \ml{ ª:Ü â BOOLº} itself denotes a value of metalanguage type  \ml{TYPE}.



\begin{session}
Â
ª(1,T)º;
Ê
Û
val it = ª(1, T)º : TERM   
Ê

Â
type_of it;
Ê
Û
val it = ª:Ü â BOOLº : TYPE   
Ê

Â
ª:Ü â BOOLº; 
Ê
Û 
val it = ª:Ü â BOOLº : TYPE   
Ê
\end{session}


\typeout{logic point 7}

\HOL\ terms can be input using explicit {\it quotation\/}, as above, using ª and º \  for quotation marks,  or
they can be constructed using \SML\ constructor functions. The function
{\small\verb%mk_var%} constructs a variable from a string and a type.  In
the example below, three  terms are constructed, each representing a single object-language variable  of type {\small\verb%BOOL%} are
constructed, and  metalanguage names  are chosen for the terms  to  coincide with the names of the object-language variables.  These are used later.

\begin{session}
Â
val x = mk_var("x",ª:BOOLº) 
and y = mk_var("y",ª:BOOLº)
and z = mk_var("z",ª:BOOLº);
Ê

Û
val x = ªxº : TERM 
val y = ªyº : TERM  
val z = ªzº : TERM   
Ê
\end{session}

\typeout{logic point 8}

The constructors \ml{mk\_Ä} and \ml{mk\_ä} construct
conjunctions and implications respectively.

\begin{session}
Â
val t = mk_ä(mk_Ä(x,y),z);
Ê
Û
val t = ªx Ä y ä zº : TERM   
Ê

\end{session}

\subsection{Terms}

There are only four different kinds of terms:
\begin{enumerate}
\item Variables.
\item Constants.
\item Function applications: \ml{ª$t_1$\ $t_2$º}.
\item $\lambda$-abstractions: \ml{ªç $x$é$t$ º}.
\end{enumerate}
\index{Terms, four different kinds of}

Both variables and constants have a name and a type; the difference is that
constants cannot be bound by quantifiers, and their type is fixed when they are
declared (see below). The type checking algorithm uses the types of constants to
infer the types of variables in the same quotation. If there is not enough type
information to constrain the assignment of a type, then an assignment of the most general type, that is,   involving a {\em type-variable}, will result:


\begin{session}
Â
ªåxº;
Ê
Û
val it = ªå xº : TERM   
Ê

Â
dest_å it;
Ê
Û
val it = ªxº : TERM   
Ê

Â
type_of it;
Ê
Û
val it = ª:BOOLº : TYPE   
Ê

Â
ªxº;
Ê
Û
val it = ªxº : TERM   
Ê

Â
type_of it;
Ê
Û
val it = ª:'aº : TYPE   
Ê
\end{session}

In the first case, the \HOL\ type checker  used the  known type \ml{BOOL ã BOOL}
of \ml{å}  to  deduce  that  the  variable  \ml{x}   must  have  type
\ml{BOOL}.  In the second case, it assigns the most general  type to \ml{x}.      The    `scope'  of type  information for type
checking is a single quotation, so a  type in  one quotation  cannot effect the
type checking of another.     If there  is not enough
contextually-determined type information to resolve the types  of all variables
in a quotation, then it may be necessary to explicitly indicate  the required types
by using \ml{ª$term$:$type$º} as illustrated below.


\typeout{logic point 9}

\begin{session}

Â
ªx:Üº;
Ê
Û
val it = ªxº : TERM 
Ê 

Â
type_of it;
Ê
Û
val it = ª:Üº : TYPE   
Ê

\end{session}

\typeout{logic point 9.1}

Functions have types of the form \ml{$\sigma_1$ã$\sigma_2$}, where
$\sigma_1$ and $\sigma_2$ are the types of the domain and range of the function,
respectively.



Before considering an example of the types of functions, an aside is appropriate on  a purely syntactic matter.
 Functions may be defined with a special syntactic status, such as being  an infix operator, in the case of \ml{+} or \ml{Ä},  or having non-standard precedence, in the case  of å.   
  In such cases, putting  \$ in front of the name of the function  causes the parser to ignore any special syntactic status it may have.   
 This means that the naked symbol \ml{Ä}  is not  in itself a syntactically well-formed expression,  because it denotes the application of the function to arguments which are missing. 
However the expression \ml{\$Ä} is well-formed in itself, denoting a function, and it can be applied to arguments.

\begin{session}

Â
ªÄº;
Ê

Û 
*** ERROR Syntax error ***
Ä not expected here
Exception-
   Fail *** ERROR 17000 raised by HOL parser: syntax error in quotation ***
   raised
Exception+ failure handled by useterminal
Ê

Â
ª$Äº;
Ê

Û 
val it = ª$Äº : TERM   
Ê

Â
type_of it;
Ê
Û 
val it = ª:BOOL ã BOOL ã BOOLº : TYPE   
Ê

Â 
ª$Ä t1 t2º;
Ê
Û 
val it = ªt1 Ä t2º : TERM   
Ê
\end{session}



=TEX

\typeout{logic point 9.15}

\begin{session}

Â
type_of ªçxéx+1º;

Ê
Û 
val it = ª:Ü ã Üº : TYPE   
Ê
\end{session}



\typeout{logic point 9.2}

The  session below illustrates
this; it also illustrates object language versus meta-language types. 



\begin{session}
Â
ª(x+1), (t1ät2)º;
Ê
Û
val it = ª(x + 1, t1 ä t2)º : TERM 
Ê 
 
Â
type_of it;
Ê
Û
val it = ª:Ü â BOOLº : TYPE   
Ê

Â
(ªx=1º, ªt1ät2º);
Ê
Û
val it = (ªx = 1º, ªt1 ä t2º) : TERM * TERM   
Ê
Â
(type_of(fst it), type_of(snd it));
Ê
Û
val it = (ª:BOOLº, ª:BOOLº) : TYPE * TYPE   
Ê
\end{session}

\typeout{logic point 9.3}

\noindent The types of constants are declared in {\it theories}; this is described
in Section~\ref{theories}.

An application $t_1\ t_2$ is badly typed if $t_1$ is not a function:

\typeout{logic point 10}

\begin{session}


Â
ª1 2º;
Ê

Û

**** TYPE CHECKING ERROR  ****
type error in ª1 2º
cannot unify ª:Üº with ª:(Ü ã 'a)º
(ERROR 14001 raised by unify: Failed to unify type constructors Ü with ã. )
Exception-
   Fail
      *** ERROR 16000 raised by HOL type inferrer: type checking error in
      quotation *** raised
Exception+ failure handled by useterminal

Ê

\end{session}

\noindent or if it is a function, but $t_2$ is not in its range:

\begin{session}

Â
ªå1º;
Ê


Û

**** TYPE CHECKING ERROR  ****
type error in ª(å 1)º
cannot unify ª:(BOOL ã BOOL)º with ª:(Ü ã 'a)º
(ERROR 14001 raised by unify: Failed to unify type constructors BOOL with Ü. )
Exception-
   Fail
      *** ERROR 16000 raised by HOL type inferrer: type checking error in
      quotation *** raised
Exception+ failure handled by useterminal

Ê

\end{session}

\typeout{logic point 11}



Lambda-terms, or $\lambda$-terms, denote functions.  For example,
\ml{ªçxé x+1º } is a term that denotes the function
$n\mapsto n{+}1$.

\begin{session}
Â 
ªçx é x+1º;
Ê 
Û 
val it = ªç xé x + 1º : TERM   
Ê

Â 
type_of it;
Ê 
Û 
val it = ª:('a ã Ü ã 'b) ã 'bº : TYPE    this will change 
Ê

\end{session}

\typeout{logic point 12}

\subsection{Boolean Terms, Theorems and  Sequents}

So far, in the language of \HOL\ terms, we have seen terms of different object-language types, including  those of object-language type \ml{ª:BOOLº} .

The \HOL\ system supports a process of  inference which results in the production of {\em theorems}.  Theorems are objects of metalanguage  type \ml{THM}. Terms are not theorems, that is, the metalanguage types \ml{TERM} and \ml{THM} are distinct. The form taken by  a theorem in this system of inference is not simply as  a boolean-valued term but rather as a composite of:
\begin{itemize}
\item  a list of assumptions, each of which represents a boolean-valued term
\item  a conclusion, which represents a single boolean-valued term.  
\end{itemize}

The following session produces an example  of a theorem  to illustrate this structure of assumptions and conclusion.   The example is produced by means which are yet to be described, but will be covered in following sections.  


\begin{session}
Â
tac_proof (([ªx=yº, ªy=zº], ªx=zº), (asm_rewrite_tac[]));
Ê
Û
val it = x = y, y = z Ö x = z : THM   

Ê
\end{session}

This theorem can be understood as meaning: on the assumption that x=y and the further assumption  that y=z, it may be concluded that x=z.   The theorem is about the relationship between assumptions and conclusion (that the latter follows from the former).  The ``truth'' of the theorem is the truth of an assertion about what follows from what.

It can be seen that the turnstile symbol, \ml{Ö}, separates assumptions from conclusion.



Strictly speaking, all theorems in this system are about the relationship between assumptions and conclusions, but in practice  many theorems have no assumptions.  Here is another example of a theorem produced by means yet to be described:

\begin{session}
Â
refl_conv ªxº;
Ê
Û
val it = Ö x = x : THM   
Ê
\end{session}

This can be understood as meaning ``without making any assumptions, it may be concluded  that x=x''.   Here the list of assumptions mentioned above is  present, but is empty and so nothing is displayed for it.


.  Terms can be constructed at will, (subject only to the constraint of being well-typed.)
 On the other hand, theorems can be constructed only by a proof which appeals to the rules of inference supported by the system.\index{theorems, construction only by proof}   The soundness of the system of inference and the correctness of the implementation guarantee the  ``truth'' (theoremhood) of any theorems produced, and ensure that theorems can only be produced by the prescribed system of inference.

Objects structured according to the pattern described above as a list of assumptions followed by a conclusion are called ``sequents''.  In this sense, theorems may be called sequents, so that the \HOL\ system of inference is described as a sequent calculus; see e.g. \cite{SRI89B}.  

The system  supports ``sequents''  by providing, as an abbreviation for \ml{TERM list * TERM},  the name \ml{SEQ} .  Sequents 
in this other sense are, needless to say, NOT theorems, just data-structures.  Their usefulness is (as shown in the example of producing the first theorem above) in convenience in stating goals for a proof process, so much so that the system also supports the abbreviation \ml{GOAL} for the same type.   This is illustrated in the next session, where the same object is ascribed a type which is reported in three different ways. 

\typeout{logic point 12.1}  

\begin{session}

Â
val s =([ªx=yº, ªy=zº], ªx=zº);
Ê
Û
val s = ([ªx = yº, ªy = zº], ªx = zº) : TERM list * TERM 
Ê  
Â
s:SEQ;
Ê
Û
val it = ([ªx = yº, ªy = zº], ªx = zº) : SEQ   
Ê
Â
s:GOAL;
Ê
Û
val it = ([ªx = yº, ªy = zº], ªx = zº) : GOAL  
Ê
\end{session}



\typeout{logic point 13}

\subsection{Theories}
\label{theories}  \index{theories, in HOL}
\subsubsection{Introduction}

The result of a session with the \HOL\ system is an object called a {\it
theory\/}.  This object is closely related to what a logician would call a
theory, but there are some differences arising from the needs of mechanical
proof. 
 A \HOL\ theory, like a logician's theory, contains sets of types,
constants, definitions and axioms.  In addition, however, a \HOL\ theory
contains an explicit list of theorems that have been proved from the axioms
and definitions.
 Logicians normally do not need to distinguish theorems that
have actually been proved from those that could be proved, hence they do not
normally consider sets of proven theorems as part of a theory; rather, they
take the theorems of a theory to be the (often infinite) set of all
consequences of the axioms and definitions. 
 Another difference between
logicians' theories and \HOL\ theories is that, for logicians, theories are
relatively static objects, but in \HOL\ they can be thought of as potentially
extendable. For example, the \HOL\ system provides tools for adding to
theories and combining theories. 
 A typical interaction with HOL consists in
combining some existing theories, making some definitions, proving some
theorems and then saving the resulting new theory.

The purpose of the \HOL\ system is to provide tools to enable well-formed
theories to be constructed.  All the theorems of such theories are logical
consequences of the definitions and axioms of the theory.  The \HOL\ system
ensures that only well-formed theories can be constructed by allowing
theorems to be created by {\it formal proof\/} only. 


A theory is stored in the \HOL\ system in what is called a theory database, where a theory database itself is represented by files in the filing system of the workstation.  Thus a theory database is what is stored between sessions of interaction with the \HOL\ system.

Theories are related  to each other by a hierarchy so as  to represent sequences of extensions of
an initial theory called \ml{HOL}. (Check this).  By  ``extension'' is meant that one theory may make use of definitions, axioms or theorems of another, ``parent'',  theory, and thus in effect incorporate them into itself.
Each theory  contains
some types, constants, axioms and
theorems, together with
pointers to other theories, its {\it parents\/}. 
This collection of reachable theories is called the {\it
ancestry\/} of the theory. Axioms, definitions
and theorems are named in the \HOL\ system by two strings: the name of the theory
 where they are stored, together with a name within that theory for the particular axiom, definition or theorem,  supplied by the
user.

Specifically,
axioms, definitions and theorems
are named by a pair of strings $\langle thy,name\rangle$ 
where $thy$ is the name of the
theory current when the item was declared and $name$
is a specific name supplied by the user (see the functions
\ml{new\_axiom}, \ml{new\_definition} \etc\ below).


A typical piece of work with the \HOL\ system consists in a number of sessions. In
the first of these a new theory, ${\cal T}$ say, is created by extending existing
theories with a number of definitions.   In subsequent
sessions this theory is extended by proving new theorems which will become part of 
the theory ${\cal T}$. The logical meaning of these sessions is that a new
extended version of ${\cal T}$ is created which replaces the old version.  Subsequent
pieces of work can build on (\ie\ extend) the definitions and theorems of ${\cal
T}$ by making ${\cal T}$ a parent of  new theories.

In principle a whole hierarchy of theories can be stored in a single theory database. 
 In practice however it may be more convenient to distribute a theory-hierarchy over several databases,  themselves organised into a hierarchy.  
For example, such an arrangement would allow a common database to be read-only,  and others deriving from it to be, in the course of  development,  updatable. 
 Similar arrangements are possible  within a single database: an individual theory may have a status of ``locked'' to prevent casual changes. 
 Thus facilities for the management of theories are available both at the level of the individual theory and at the level of the database.

At any stage in the development of a theory, a stored record of what has been achieved so far is obtained by causing an update to the  current database, or ``committing'' the whole current state of the \HOL\ system to the database.  This is effected by issuing the single \SML\ command, which, in the case of the system in use at the time of writing is,  \ml{PolyML.commit();}. 


No more will be said on this topic in this tutorial, which will proceed on the assumption of a single database.     


{\em Check our position on the following:}

There are two modes of working with \HOL:   {\it  draft mode\/}  and {\it proof
mode\/}.  In  draft  mode,  inconsistencies  can  be  introduced  by  asserting
inconsistent axioms,  but  in  proof  mode only  consistency preserving actions
(namely valid proof) can be done.  Draft mode is analogous to `super user mode'
in Unix, in that it gives access to dangerous facilities.   Everything that can
be done in proof mode can be done in draft mode, but not vice versa.

\typeout{logic point 14}

There is always a {\it current theory\/}, whose name  is given  by the function
\ml{get\_current\_theory\_name}.  This function maps the value called {\em unit}, written
`\ml{()}' in \SML, to a string giving the name of the current theory.
Thus the \SML\ expression
\ml{get\_current\_theory\_name ()} evaluates to a string giving the name of the current
theory.  Initially  \HOL\  is in  proof mode  with current theory
called \ml{HOL}. {\em Check this.}  So evaluating \ml{get\_current\_theory \_name()} immediately after
initiating a \HOL\ session gives a value dependent upon the state of the database in use, as is can be seen in
the session shown below:

\typeout{logic point 15}

\setcounter{sessioncount}{1}
\begin{session}
Â
get_current_theory_name();
Ê
Û
val it = "misc" : string   
Ê
\end{session}

One more point remains to be made.  It has been explained that the state of a \HOL\ session can be saved,  and then retrieved on a later occasion.  Within the state of the \HOL\ session, there will be theorems and other objects: axioms, definitions, constants and so on.   Now a  theorem, for example,  can be associated with a name, in the state of the \HOL\ session, in either or both of two ways, which are distinct.

Firstly, a theorem is a \SML\ value like any other, in that it can be associated with a \SML\ name by the familiar process, seen many times above, of making a declaration:

\begin{session} 
Â
val thm99 = refl_conv ªxº;
Ê
Û
val thm99 = Ö x = x : THM   
Ê
\end{session}

The value, and the association with the name, will survive the saving and retrieving of the state of the \HOL\ session.

Secondly,  the current theory is represented by a data structure within thestate of the current session.   This data structure has no \SML\ name, but is instead provided with a number of access functions by which its contents may be inspected, extracted, and updated. 
 For example, the function \ml{print\_theory} enables the content of the theory to be inspected.  There is a function \ml{save\_thm} which takes two arguments, a string and a theorem , and causes the theorem to be saved in the data structure which is the theory and  to be stored within the theory under the name given by the string. 
The theorem can be recovered from the theory by another access function, \ml{get\_thm}, which takes as arguments the  theory name (the current theory can be referred to by the name \ml{"-"}) and the name under which the theorem was stored. 
 Note that there is no necessary connection between this string and the name of any \SML\ variable used to hold a theorem.  To emphaize the point, note that the string need not be a well-formed name.
\index{theorems, saving  with \ml{save\_thm}}  
\index{theorems, retrieving with \ml{get\_thm}} 
\index{theories, viewing with \ml{print\_theory}}

\begin{session}
Â
save_thm ("theorem of 5 September 91", thm99);
Ê
Û
val it = Ö x = x : THM   
Ê

Â
get_thm "-" "theorem of 5 September 91";
Ê
Û
val it = Ö x = x : THM 
Ê
\end{session} 

\subsubsection{Example of Developing a New Theory}

In this section an example is given of developing a new theory, which is chosen to be a treatment of Peano's postulates as axioms for the natural numbers.    It is to be noted that there is already a theory built-in to HOL, called  \ml{Ü}, which covers natural numbers and arithmetic, (in which Peano's postulates  are  in  fact  derived  theorems rather  than postulated as axioms).  To emphasize that this example theory is just an example, and has no relation to \ml{Ü} except  superficial resemblance , the example theory will be called ``Peanissimo''.  

Executing \ml{new\_theory "$thy$"} creates a new  theory called  $thy$; it fails
if there already exists a theory so named in the current theory hierarchy; 
for a description of  which, see  the appropriate  section of  
\DESCRIPTION).


\begin{session}
Â
new_theory "Peanissimo";
Ê
Û
val it = () : unit
Ê
\end{session}

\typeout{point 16}

\noindent This starts a theory called \ml{Peanissimo},  which is  to be  made into a
theory containing Peano's postulates as axioms for the natural
numbers. These postulates, stated informally, are:

\begin{list}{{\small\bf P\arabic{Peano}}}{\usecounter{Peano}
\setlength{\leftmargin}{12mm}
\setlength{\rightmargin}{7mm}
\setlength{\labelwidth}{6mm}
\setlength{\labelsep}{2mm}
\setlength{\listparindent}{0mm}
\setlength{\itemsep}{14pt plus1pt minus1pt}
\setlength{\topsep}{3mm}
\setlength{\parsep}{0mm}}

\item There is a number which we will call $zero$.
\item There is a function  which we will call $successor$  such that 
if $n$ is a number then  the successor of $n$ is a number.
\item $zero$ is not the successor of any number.
\item If two numbers have the same successor then they are equal.
\item If a property holds of $zero$, and if whenever it holds of a number then it
also holds of the successor of that number, then the property holds of all
numbers. This postulate is called {\it Mathematical Induction}.
\end{list}

To formalize this in \HOL\ a new type is introduced called \ml{nat}:

\index{types, object-language, introducing with \ml{new\_type}}

\typeout{point 17}

\begin{session}
Â
new_type ("nat", 0);
Ê
Û
val it = ª:natº : TYPE 
Ê
\end{session}

In general \ml{new\_type}$\ n\ \ml{`\ty{op}`}$ makes \ty{op}
a new $n$-ary type operator in the current theory. 
Constant types are regarded as degenerate type operators with no arguments, thus
the new type \ml{nat}
is declared to be a $0$-ary type operator. The type operator \ml{list} is 
an example of a $1$-ary operator,
types built with \ml{list} are written as \ml{$\sigma\ $list}. 

The type
operator {\small\verb%prod%} is $2$-ary, types using it are written
as \ml{($\sigma_1$,$\sigma_2$)prod} (which can, in fact, be written as
$\sigma_1${\small\verb%*%}$\sigma_2$).\footnote{Check this out when pairs implemented.}

The axioms {\small\bf P1} and {\small\bf P2} can now be formalized by declaring
two new constants of type \ml{nat}
to represent $0$ and \Suc. 

Evaluating \ml{new\_const("\con{c}",}$\sigma$\ml{)} makes
$\con{c}$ a new constant of type $\sigma$ in the current theory.
This fails if there already exists a constant named $\con{c}$  in the current theory (or a parent  of the current theory).


\typeout{point 19}

\begin{session}
Â
new_const ("zero", ª:natº);
Ê
Û
val it = ªzeroº : TERM
Ê

Â
new_const ("successor", ª:natãnatº);
Ê
Û
val it = ªsuccessorº : TERM
Ê
\end{session}



The \HOL\ type checker ensures that {\small\bf P1} and {\small\bf P2} hold.
{\small\bf P3} is now asserted as an axiom:
\index{axioms, introducing with \ml{new\_axiom}}

\begin{session}
Â
new_axiom("P3", ªÉné å(zero = successor n)º );
Ê
Û
val it = Ö É né å zero = successor n : THM
Ê
\end{session}

\noindent This creates an axiom in the current theory (\ie\ in \ml{Peano}) called
\ml{P3}. Axiom {\small\bf P4} can be declared similarly:

\typeout{point 20}

\begin{session}

Â
  new_axiom("P4", ªÉm n é(successor m = successor n) ä (m = n)º);
Ê

Û
val it = Ö É m né successor m = successor n ä m = n : THM

Ê

\end{session}

\typeout{point 20.5}

The final Peano axiom is Mathematical Induction:

\begin{session}
Â
new_axiom("P5",ªÉ Pé P zero Ä (É n é P n ä P(successor n)) ä (Éné P n)º);
Ê

Û
val it = Ö É Pé P zero Ä (É né P n ä P (successor n)) ä (É né P n) : THM   
Ê

\end{session}

\typeout{point 21}

To inspect the theory, the function \ml{print\_theory} can be used:

\begin{session}
Â
print_theory "-";
Ê


\end{session}

\typeout{ page 20 a}

\begin{session}
Û

*** The theory Peanissimo ***

--- Parents ---

                sum

--- Constants ---

zero            nat
successor       nat ã nat

--- Types ---

nat

--- Axioms ---

P3              Ö É né å zero = successor n
P4              Ö É m né successor m = successor n ä m = n
P5              Ö É Pé P zero Ä (É né P n ä P (successor n)) ä (É né P n)

*** End of listing of theory Peanissimo ***
Ê

\end{session}


\typeout{point 22}

To end the session and make an  update to the database in use, recording all the work of the session including the new theory, the new theory, the current state of the session is {\em committed} to the database, after which an exit can be made back to Unix:

\begin{session}
Â
PolyML.commit();
Ê
Û
9696 bytes copied
sun3hol.db:3235840 bytes
Closing sun3hol.db now
Opening sun3hol.db
Opening /hat/nih/bin/poly_2.02/ML_dbase
val it = () : unit  
Ê

Â
PolyML.quit();
Ê
Û
Unix>
Ê
\end{session}

\noindent The function \ml{quit} exits from the \HOL\ system.

The preceding session set up a theory called \ml{Peano}. It is usual
to include in `Peano arithmetic' axioms defining addition and multiplication.
To do this a new session can be started and the theory further developed.  

\begin{session}
\begin{verbatim}
Unix>  poly example.db
\end{verbatim}

Û
.... sign-on message ....
Ê

Â
get_current_theory_name();
Ê
Û
val it = "Peanissimo" : string   
Ê

\end{session}

\noindent The two new axioms can now be added, but first constants and
 must  be  declared  to  represent  addition  and  multiplication.   Let us choose the names $pplus$ and $ptimes$  respectively for these.  These can  be declared as
infixes using \ml{declare\_infix} as well as \ml{new\_constant}.

\index{fixity, of constants, declaring} \index{constants, introducing with \ml{new\_const}}

\begin{session}
Â
declare_infix (40, "pplus"); declare_infix (41, "ptimes");
Ê
Û
val it = () : unit   
val it = () : unit
Ê

Â
new_const ("pplus", ª:natãnatãnatº);
new_const ("ptimes", ª:natãnatãnatº);
Ê

Û
val it = ª$pplusº : TERM   
val it = ª$ptimesº : TERM
Ê



\end{session}

\noindent Constants declared with \ml{new\_infix}
must have a type of the form
\ml{$\sigma_1$ã($\sigma_2$ã$\sigma_3$)}.

Axioms defining \ml{plus} and \ml{times} can now be defined.

\begin{session}
Â
new_axiom("pplus_def",
   ª(Éné (zero pplus n) = n) Ä 
    (Ém né((successor m) pplus n) = successor (m pplus n) )º );
Ê
Û
val it = Ö (É né (zero pplus n) = n) Ä
  (É m né (successor m pplus n) = successor (m pplus n)) : THM
Ê

Â
new_axiom("ptimes_def",
   ª(Éné (zero ptimes n) = zero) Ä 
    (Ém né((successor m) ptimes n) = ((m ptimes n) pplus n)  )º );
Ê
Û
val it = Ö (É né (zero ptimes n) = zero) Ä
  (É m né (successor m ptimes n) = (m ptimes n pplus n)) : THM
Ê
 
\end{session}

\noindent The theory \ml{Peanissimo} has now been extended to contain the new
definitions.

This example shows how a theory is set up. How to prove consequences of axioms and
definitions is described later. The \HOL\ system contains a built-in
theory of numbers called \ml{Ü} which contains Peano's postulates and  the definitions of addition
(\ml{+}) and multiplication (\ml{*}) and other things.
In fact, Peano's 
postulates are theorems not axioms in the theory \ml{Ü}. The  constants
\ml{0} and \ml{Suc} (corresponding to \ml{zero} and \ml{successor} in \ml{Peanissimo}) are
{\it defined\/} in terms of purely logical notions.
In \HOL, {\it definitions\/} are a special kind of axiom that are
guaranteed to be consistent. The commonest (but not only) form of a definition is: 

\[f\ x_1\ \ldots\ x_n = t\]

\noindent where $f$ is declared to be a new constant satisfying this
equation (and $t$ is a term whose free variables are included in the set
$\{x_1,\ldots,x_n\}$).  Such definitions cannot be recursive because, for
example: 

\[ f\ x = (f\ x)+1 \]

\noindent would imply $0=1$ (subtract $f\ x$ from both sides)
and is therefore inconsistent. An example of a definition is:

\begin{session}
Â
simple_new_defn 
  ("Double_def", "Double", ªçxé (x pplus x)º);
Ê
Û
val it = Ö Double = (ç xé x pplus x) : THM
Ê

\end{session}

\noindent This definition both declares \ml{Double} as a new constant of the
appropriate type and asserts the defining equation as a definitional axiom.

\typeout{point 050}

\begin{session}
Â
print_theory "-";
Ê
Û
*** The theory Peanissimo ***

--- Parents ---

                sum

--- Constants ---

zero            nat
successor       nat ã nat
$pplus          nat ã nat ã nat
$ptimes         nat ã nat ã nat
Double          nat ã nat

--- Types ---

nat

--- Fixity ---

Infix 40:       pplus
Infix 41:       ptimes

--- Axioms ---

P3              Ö É né å zero = successor n
P4              Ö É m né successor m = successor n ä m = n
P5              Ö É Pé P zero Ä (É né P n ä P (successor n)) ä (É né P n)
pplus_def       Ö (É né (zero pplus n) = n) Ä
                  (É m né (successor m pplus n) = successor (m pplus n))
ptimes_def      Ö (É né (zero ptimes n) = zero) Ä
                  (É m né (successor m ptimes n) = (m ptimes n pplus n))

--- Definitions ---

Double_def      Ö Double = (ç xé x pplus x)

*** End of listing of theory Peanissimo ***
val it = () : unit 
Ê
   

\end{session}

\typeout{point 051}

The use of axioms, as illustrated here, carries considerable  danger in general
because it is very easy to assert inconsistent axioms.  It is thus safer to use
only definitions.  At first sight this might appear impossible, but in fact all
of ordinary  mathematics  can  be  developed  from  logic  by definition alone.
Showing this was  the achievement  of Russell  and Whitehead  in their treatise
{\sl Principia  Mathematica}  \cite{WHITEHEAD10}.    A   theory  containing  only
definitions is called a {\it definitional theory\/}.   Many useful definitional
theories are built-in to the \HOL\ system, or available as libraries.  Examples
include theories of numbers  (both natural  numbers and  integers), sets, bags,
finite trees, group theory, properties of fixed points and more.  

\newpage % PBHACK

The theory of numbers built-in to \HOL\  is called Ü, and is a definitional theory that defines
numbers logically. Peano's postulates are proved from the definitions of
the type \ml{num} and the constants \ml{0} and \ml{Suc}.
It follows from Peano's postulates that certain kinds of recursion equations are
equivalent to non-recursive definitions. There is a  theorem  called
\ml{prim\_rec\_thm} (for `primitive recursion') that supports this,
together with tools for automatically transforming recursion equations into
definitions. This is illustrated later but, for example, here are the built-in
the definitions
of addition and multiplication

\begin{session}

Â
get_defn "Ü" "+";
Ê
Û
val it = Ö É m né (0 + n) = n Ä ((m + 1) + n) = ((m + n) + 1) Ä Suc m =
  (m + 1) : THM
Ê

Â
get_defn "Ü" "*";
Ê
Û
val it = Ö É m né 0 * n = 0 Ä (m + 1) * n = (m * n + n) : THM   
Ê

\end{session}

\newpage % PBHACK

The theory  \ml{Ü} contains  too many  pre-proved theorems  to show in
full, but  here are (some of)  the constants and  definitions, and  the first  few theorems.

\begin{session}
Â
print_theory "Ü";
Ê
Û
*** The theory Ü ***

--- Parents ---

                pair

--- Children ---

                list

--- Constants ---

Is_Ü_Rep IND ã BOOL
Suc             Ü ã Ü
Zero            Ü
$+              Ü ã Ü ã Ü
$û               Ü ã Ü ã BOOL
$ü               Ü ã Ü ã BOOL
$<              Ü ã Ü ã BOOL
$>              Ü ã Ü ã BOOL
$*              Ü ã Ü ã Ü
$Mod            Ü ã Ü ã Ü
$Div            Ü ã Ü ã Ü
$-              Ü ã Ü ã Ü

--- Types ---

Ü

--- Fixity ---

Infix 210:      <       >       û        ü
Infix 300:      +       -
Infix 310:      Div     Mod     *

--- Definitions ---

Is_Ü_Rep Ö Ñ zero sucé
                  (Is_Ü_Rep zero Ä (É né Is_Ü_Rep n ä Is_Ü_Rep (suc n))) Ä
                  (É né Is_Ü_Rep n ä å suc n = zero) Ä OneOne suc Ä
                  (É pé p zero Ä (É mé p m ä p (suc m)) ä
                  (É né Is_Ü_Rep n ä p n))
Ü                Ö Ñ fé TypeDefn Is_Ü_Rep f
Zero
Suc             Ö (É né å Suc n = Zero) Ä OneOne Suc Ä
                  (É pé p Zero Ä (É mé p m ä p (Suc m)) ä (É né p n))
+               Ö É m né (0 + n) = n Ä ((m + 1) + n) = ((m + n) + 1) Ä Suc m =
                  (m + 1)
û                Ö É m né m û n Ç (Ñ ié (m + i) = n)
ü                Ö É m né m ü n Ç n û m
<               Ö É m né m < n Ç (m + 1) û n
>               Ö É m né m > n Ç m < n
*               Ö É m né 0 * n = 0 Ä (m + 1) * n = (m * n + n)
Mod             Ö É m né 0 < n ä 0 Mod n = 0 Ä (m + 1) Mod n =
                  (if (m Mod n + 1) < n then m Mod n + 1 else 0)
Div             Ö É m né 0 < n ä 0 Div n = 0 Ä (m + 1) Div n =
                  (if (m Mod n + 1) < n then m Div n else m Div n + 1)
-               Ö É m né (m + n) - n = m

--- Theorems ---

induction_thm   Ö É pé p 0 Ä (É mé p m ä p (m + 1)) ä (É né p n)
å_plus1_thm      Ö É né å (n + 1) = 0
one_one_plus1_thm
                Ö É x1 x2é (x1 + 1) = (x2 + 1) ä x1 = x2
prim_rec_thm    Ö É z sé Ñ„1 fé f 0 = z Ä (É né f (n + 1) = s (f n) n)
plus_assoc_thm  Ö É i m né ((i + m) + n) = (i + m + n)
plus_assoc_thm1 Ö É i m né (i + m + n) = ((i + m) + n)
plus_comm_thm   Ö É m né (m + n) = (n + m)
plus_order_thm  Ö É i m né (m + i) = (i + m) Ä ((i + m) + n) = (i + m + n) Ä
                  (m + i + n) = (i + m + n)
plus_clauses    Ö É m n ié ((m + i) = (n + i) Ç m = n) Ä
                  ((i + m) = (n + i) Ç m = n) Ä ((m + i) = (i + n) Ç m = n) Ä
                  ((i + m) = (i + n) Ç m = n) Ä ((m + i) = i Ç m = 0) Ä
                  ((i + m) = i Ç m = 0) Ä (i = (i + n) Ç n = 0) Ä
                  (i = (n + i) Ç n = 0) Ä ((m + i) = 0 Ç m = 0 Ä i = 0) Ä
.
.
.

*** End of listing of theory Ü ***


Ê
\end{session}




=TEX

\pagebreak 
\section{TUTORIAL: INTRODUCTION TO PROOF WITH HOL}
\label{proof}


For a logician, a formal proof is a sequence, each of whose  elements is
either an {\it axiom\/} or follows from earlier members of the sequence by a
{\it rule of inference\/}.  A theorem is the last element of a proof.


Theorems are represented in \HOL\ by values of an abstract
type\footnote{Abstract types are explained in \DESCRIPTION.}
{\small\verb%thm%}.  The  only way  to create theorems is by generating a
proof.  In \HOL\ (following \LCF), this consists in applying \SML\ functions
representing {\it rules of inference\/} to  axioms or previously generated
theorems.  The sequence of such applications  directly corresponds to a
logician's proof.

There are five axioms of the \HOL\ logic and eight primitive
inference rules. The axioms are bound to \SML\ names. For example, the Law of
Excluded Middle is bound to the \SML\ name \ml{bool\_cases\_axiom}:

\begin{session}
Â
bool_cases_axiom;
Ê
Û
val it = Ö É bé (b Ç T) Å (b Ç F) : THM   
Ê
\end{session}

Theorems are printed with a preceding turnstile  \ml{Ö} as
illustrated above.   Rules of inference are \SML\ functions that
return values of type \ml{THM}.  
An example of a rule of inference is {\it
specialization\/} (or $\forall$-elimination). 
In standard `natural deduction'
notation this is:

\[ \Gamma\turn \uquant{x}t\over \Gamma\turn t[t'/x]\]

\begin{itemize}
\item $t[t'/x]$ denotes the result of substituting $t'$ for free
occurrences of $x$ in $t$, with the restriction that no free variables in $t'$
become bound after substitution.
\end{itemize}

\typeout{proof point 1}

\noindent This rule is represented in \SML\ 
by a function
\ml{simple\_É\_elim},\footnote{This function is not a 
primitive rule of inference in the HOL logic, but is a derived rule. Derived rules
are described in Section~\ref{forward}.}
which takes as arguments a term
\ml{ª$a$º} and a theorem 
\ml{ÖÉ$x$é$t[x]$} and returns the theorem 
\ml{Ö$t[a]$} , the result of substituting $a$ for $x$ in $t[x]$. 

\setcounter{sessioncount}{1}

\begin{session}
Â
val Th1 = bool_cases_axiom;  
Ê
Û
val Th1 = Ö É bé (b Ç T) Å (b Ç F) : THM   
Ê
Â
val Th2 = simple_É_elim ª1 = 2º Th1;
Ê
Û 
val Th2 = Ö (1 = 2 Ç T) Å (1 = 2 Ç F) : THM   
Ê
\end{session}


\typeout{proof point 2}

This session consists of a proof of two steps: using an axiom and
applying the rule \ml{simple\_É\_elim}; it interactively performs the following proof:


\begin{enumerate}
\item $\turn \uquant{t} t= T \ \disj\  t= F $ \hfill
[Axiom \ml{bool\_cases\_axiom}]
\item $\turn (1{=}2)=T\ \disj\ (1{=}2)=F$\hfill [Specializing line 1 to `$1{=}2$']
\end{enumerate}

If the argument to an \SML\ function representing a rule of inference is of the
wrong kind, or violates a condition of the rule, then the application fails.
For example, $\ml{simple\_É\_elim}\ t\ th$ will fail if $th$ is not of the form  \ml{Ö É $x$é $\cdots$ }
or if it is of this form but the type of $t$ is not the same
as the type of $x$, or if the free variable restriction is not met.

\begin{session}
Â 
simple_É_elim ª1 = 2º  Th2; 
Ê
Û
Exception-
   Fail
      *** ERROR 7039 raised by simple_É_elim: Theorem is not of the form: `ˆ
      Ö É x é t' where ªxº is a variable *** raised
Exception+ failure handled by useterminal
Ê

Â
simple_É_elim ª1º  Th1;
Ê
Û
Exception-
   Fail
      *** ERROR 7046 raised by simple_É_elim: Theorem is not of the form: `ˆ
      Ö É b é t' where the type of ªbº  is the type of the term argument ***
   raised
Exception+ failure handled by useterminal
Ê 
\end{session}



A proof in the \HOL\ system is constructed by repeatedly applying inference
rules to axioms or to previously proved theorems.
Since proofs may consist of millions of steps, it is necessary to provide
tools to make proof construction easier for the user.  The proof generating
tools in the \HOL\ system are described later.


The general form of a theorem is  $t_1,\ldots,t_n\ $\ml{Ö}$\  t$, where $t_1$,
$\ldots$ , $t_n$ are boolean terms called  the {\it  assumptions} and  $t$ is a
boolean term called the {\it conclusion\/}.  Such a theorem asserts that if its
assumptions are true then so is its conclusion.  Its truth  conditions are thus
the same as those for the single term \ml{$(t_1$ Ä $\ldots $ Ä $t_n$) ä $t$. } Theorems  with  no  assumptions are printed
out in the form \ml{Ö$\ t$}.


The five  axioms and  eight primitive  inference rules  of the  \HOL\ logic are
described in  detail in  the document \DESCRIPTION.  Every
value of  type  \ml{THM}  in  the  \HOL\ system  can be  obtained by repeatedly
applying primitive inference rules to axioms.  When the \HOL\  system is built,
the eight  primitive rules  of inference  are defined  and the  five axioms are
bound to their \SML\ names, all other predefined theorems are proved using rules
of inference as the system is made.\footnote{This is a slight
over-simplification.} 

In the rest of this chapter, the  process of  {\it forward  proof\/}, which has
just been sketched, is decribed in more detail.   In Chapter~\ref{tactics} {\it
goal directed proof\/} is  described, including  the important  notions of {\it
tactics\/} and {\it tacticals\/}, due to Robin Milner.

\subsection{Forward proof}
\label{forward}

Three of the primitive  (check this) inference rules of the
\HOL\ logic are \ml{asm\_rule} (assumption introduction),
\ml{disch\_rule} (discharging or assumption elimination) and \ml{ä\_mp\_rule} (Modus Ponens).
These rules will be used to illustrate forward proof and the writing of derived
rules.

The inference rule \ml{asm\_rule} generates theorems of the form
\ml{$t$ Ö $t$}. 

\suppress{Note, however, that the \SML\ printer prints each
assumption as a dot (but this default can be changed; see below).
}

The function
{\small\verb%dest_thm%} decomposes a theorem into a pair consisting of list of
assumptions and the conclusion. The \SML\ type \ml{SEQ}, or \ml{GOAL},  abbreviates \ml{TERM list * TERM}, this is motivated in Section~\ref{tactics}.

\begin{session}
Â
val Th3 = asm_rule ªt1ät2º;
Ê

Û
val Th3 = t1 ä t2 Ö t1 ä t2 : THM   
Ê

Â
dest_thm Th3;
Ê

Û
val it = ([ªt1 ä t2º], ªt1 ä t2º) : SEQ   
Ê
\end{session}

The primitive inference rule
\ml{disch\_rule} (discharging, assumption elimination) infers from
a theorem of the form $\cdots t_1\cdots \ml{Ö}t_2$ the new theorem
$\cdots\ \cdots\ \ml{Ö}\ t_1\ml{ä}t_2$. \ml{disch\_rule} takes as arguments
the term to be discharged (\ie\ $t_1$) and the theorem from whose
assumptions it is to be discharged and returns the result of the discharging.
The following session illustrates this; it also illustrates what happens when
\ml{=>}, which is part of the syntax of conditional terms
(see the table on page~\pageref{logic-table}), 
is erroneously typed instead of the implication symbol \ml{ä}.

\begin{session}
Â
val Th4 = disch_rule ªt1=>t2º Th3; 
Ê

Û
*** ERROR Syntax error ***
> not expected after: ... =
Exception-
   Fail *** ERROR 17000 raised by HOL parser: syntax error in quotation ***
   raised
Exception+ failure handled by useterminal
 
Ê

Â
val Th4 = disch_rule ªt1ät2º Th3;
Ê

Û
val Th4 = Ö (t1 ä t2) ä t1 ä t2 : THM   
Ê
    
\end{session}

typeout{point 1000}

\noindent Note that the term being discharged must be in the assumptions.

\begin{session}
Â
disch_rule ª1=2º Th3;
Ê

Û

Exception-
   Fail
      *** ERROR 7031 raised by disch_rule: Term not alpha-convertibly present
      in assumption list *** raised
Exception+ failure handled by useterminal

Ê

\end{session}


In \HOL\,  the  rule   of  Modus  Ponens  is  specified in conventional
notation by:  

\[ \Gamma_1 \turn t_1 \imp t_2 \qquad\qquad \Gamma_2\turn t_1\over
\Gamma_1 \cup \Gamma_2 \turn t_2\]

\noindent The  corresponding \SML\ function \ml{ä\_mp\_rule} takes argument theorems of the
form \ml{$\cdots\ $ Ö $\ t_1$\ ä\ $t_2$} and \ml{$\cdots\ $ Ö $\ t_1$}
and returns \ml{$\cdots\ $ Ö $\ t_2$}. The next session illustrates the use of
\ml{ä\_mp\_rule} and also a common error, namely not supplying the \HOL\ logic type
checker with enough information. 

\begin{session}
Â
val Th5 = asm_rule  ªt1º;
Ê


Û
Exception-
   Fail *** ERROR 3031 raised by asm_rule: ªt1º is not of type ª:BOOLº ***
   raised
Exception+ failure handled by useterminal
Ê

Â
val Th5 = asm_rule  ªt1:BOOLº;
Ê

Û
val Th5 = t1 Ö t1 : THM   
Ê


Â
val Th6 = ä_mp_rule Th3 Th5;
Ê

Û
val Th6 = t1 ä t2, t1 Ö t2 : THM   
Ê

 \end{session}

The assumptions of \ml{Th6} can be extracted with the \SML\ function \ml{hyps}, (``hypotheses'')
which returns the list of assumptions of a theorem (the conclusion is returned by the function \ml{concl}).

\begin{session}

Â
hyps Th6;
Ê

Û
val it = [ªt1 ä t2º, ªt1º] : TERM list   
Ê
\end{session}



\noindent Discharging \ml{Th6} twice establishes the theorem
\ml{Ö \ t1 ä (t1 ä t2) ä t2}.

\begin{session}
Â 
val  Th7 =  disch_rule ªt1ät2º Th6; 
Ê

Û
val Th7 = t1 Ö (t1 ä t2) ä t2 : THM   
Ê

Â
val  Th8 = disch_rule ªt1:BOOLº Th7; 
Ê

Û
val Th8 = Ö t1 ä (t1 ä t2) ä t2 : THM   
Ê

\end{session}



The sequence: \ml{Th3},
\ml{Th5}, \ml{Th6}, \ml{Th7}, \ml{Th8} constitute a proof in \HOL\ of
the theorem \[Ö \ t1 ä (t1 ä t2) ä t2 \].   This
proof could be written:

\begin{enumerate}
\item $ t_1\imp t_2\turn t_1\imp t_2$ \hfill
[Assumption introduction]
\item $ t_1\turn t_1$ \hfill
[Assumption introduction]
\item $t_1\imp t_2,\ t_1 \turn t_2 $ \hfill
[Modus Ponens applied to lines 1 and 2]
\item $t_1 \turn (t_1\imp t_2)\imp t_2$ \hfill
[Discharging the first assumption of line 3]
\item $\turn t_1 \imp (t_1 \imp t_2) \imp t_2$ \hfill
[Discharging the only assumption of line 4]
\end{enumerate}

\subsection{Derived rules}


A {\it proof from hypothesis $th_1, \ldots, th_n$} is a sequence each of whose
elements is either an axiom, or one of the hypotheses $th_i$, or follows from
earlier elements by a rule of inference.

For example, a proof of $\Gamma,\ t'\turn t$ from the hypothesis
$\Gamma\turn t$ is:


\begin{enumerate}
\item $t'\turn t'$ \hfill [Assumption introduction]
\item $\Gamma\turn t$ \hfill [Hypothesis]
\item $\Gamma\turn t'\imp t$ \hfill [Discharge $t'$ from line 2]
\item $\Gamma,\ t'\turn t$ \hfill [Modus Ponens applied to lines 3 and 1]
\end{enumerate}

Line 3 above mentions ``discharging'' the assumption $t'$, but if $t'$ is not actually amongst the assumptions, \ml{disch\_rule} will fail.  A variation of \ml{disch\_rule} is  called  \ml{ä\_intro}, which is used in the same way, that is, after use of the rule $t'$ is not present amongst the assumptions and it is present as the antecedent of an implication, which is true of \ml{disch\_rule} as well, but $t'$ need not be present in the original assumptions.

\noindent This proof works for any hypothesis of the form $\Gamma\turn t$ 
and any boolean term $t'$ and
shows that the result of adding an arbitary hypothesis to a theorem is another
theorem (because the four lines above can be added to any proof of
$\Gamma\turn t$ to get a proof of $\Gamma,\ t'\turn t$).\footnote{This property
of the logic is called {\it monotonicity}.} For example,
the next session uses this proof to add the hypothesis \ml{"t3"} to
\ml{Th6}.


\begin{session} 

Â
val  Th9 = asm_rule ªt3:BOOLº; 
Ê
Û
val Th9 = t3 Ö t3 : THM   
Ê


Â
val  Th10 = ä_intro ªt3:BOOLº Th6; 
Ê
Û
val Th10 = t1 ä t2, t1 Ö t3 ä t2 : THM   
Ê


Â
val Th11 = ä_mp_rule Th10 Th9; 
Ê
Û
val Th11 = t1 ä t2, t1, t3 Ö t2 : THM   
Ê
\end{session}


A {\it derived rule\/} is a \SML\ procedure that generates a proof from given hypotheses
each time it is invoked. The hypotheses are the arguments of the rule.
To illustrate this, a rule, called \ml{ADD\_ASSUM}, will now
be defined as an \SML\ procedure that carries
out the proof above. In standard notation this would be described by:

\[ \Gamma\turn t\over \Gamma,\ t'\turn t \]

\noindent The \SML\ definition is:

\begin{session} 
Â
fun  ADD_ASSUM t th =
 let val th9  = asm_rule t
     val th10 = ä_intro t th
 in
 ä_mp_rule th10 th9
 end; 
Ê
Û
val ADD_ASSUM = fn : TERM -> THM -> THM
Ê

Â
ADD_ASSUM ªt3:BOOLº Th6; 
Ê
Û
val it = t1 ä t2, t1, t3 Ö t2 : THM   
Ê

\end{session}

\noindent The body of \ml{ADD\_ASSUM} has been coded  to mirror  the proof done
in session~10 above, so as to show how an interactive proof  can be generalized
into a  procedure.   But \ml{ADD\_ASSUM}  can be  written much more
concisely as:

\begin{session} 
Â
fun  ADD_ASSUM t th = ä_mp_rule (ä_intro t th) (asm_rule t); 
Ê
Û
val ADD_ASSUM = fn : TERM -> THM -> THM   
Ê  

Â
ADD_ASSUM  ªt3:BOOLº Th6;
Ê
Û
val it = t1 ä t2, t1, t3 Ö t2 : THM   
Ê 

\end{session}


Another example of  a derived  inference rule  is shown below as \ml{UNDISCH};  this moves the
antecedant of an implication to the assumptions.

\[ \Gamma\turn t_1\imp t_2 \over\Gamma,\ t_1\turn t_2 \]

\noindent A \SML\ derived rule that implements this is:


\begin{session} 
Â
fun  UNDISCH th =  ä_mp_rule th (asm_rule(fst(dest_ä(concl th)))); 
Ê
Û
val UNDISCH = fn : THM -> THM
Ê
Â
Th10; 
Ê
Û
val it = t1 ä t2, t1 Ö t3 ä t2 : THM   
Ê

Â
UNDISCH Th10; 
Ê
Û
val it = t1 ä t2, t1, t3 Ö t2 : THM   
Ê

Â
undisch_rule Th10;
Ê
Û
val it = t1 ä t2, t1, t3 Ö t2 : THM   
Ê

\end{session}

\noindent Each time \ml{UNDISCH\ $\Gamma\turn t_1\imp t_2$} is executed,
the following proof is performed:

\begin{enumerate}
\item $t_1\turn t_1$ \hfill [Assumption introduction]
\item $\Gamma\turn t_1\imp t_2$ \hfill [Hypothesis]
\item $\Gamma,\ t_1\turn t_2$ \hfill [Modus Ponens applied to lines 2 and 1]
\end{enumerate}

Rules  equivalent to \ml{ADD\_ASSUM} and \ml{UNDISCH} (named respectively \ml{asm\_intro} and \ml{undisch\_rule}) are  derived rules
 defined when the \HOL\ system is built. For a description
of the main rules see the section on derived rules in
\DESCRIPTION.

\typeout{.... page 38 approx ....}

\subsection{Rewriting}

An important derived rule  is  \ml{rewrite\_rule}.    This takes  as arguments
\begin{itemize}
\item a collection of equations represented by  a list of theorems, such that each theorem is an equation or a conjunction of equations, and 
\item   a theorem $\Delta\turn t$ 
\end{itemize}
 and  repeatedly  replaces in  $t$  instances  of  the lefthand side of an equation  by the
corresponding instance of the righthand side until no further change occurs.   The result is
a theorem $\Gamma\cup\Delta\turn t'$ where $t'$ is the result  of rewriting $t$
in this way. 


 The session below illustrates the use of  \ml{rewrite\_rule}.  In
it the list of equations is a list \ml{rewrite\_list} containing the 
theorems  produced earlier as the axioms defining \ml{plus} and \ml{times}.


\begin{session}


Â 
val  rewrite_list =  map (get_axiom "Peano") ["plus_def", "times_def"]; 
Ê
Â 
val  rewrite_list =  map (get_defn "Ü") ["+", "*"]; 
Ê

Û
val rewrite_list = 
   [Ö (É né (O plus n) = n) Ä  (É m né (Suc m plus n) = Suc (m plus n)),
    Ö (É né (O times n) = O) Ä (É m né (Suc m times n) = (m times n plus n))] : THM list
Ê
Û
val rewrite_list = 
[Ö É m né (0 + n) = n Ä ((m + 1) + n) = ((m + n) + 1) Ä
     Suc m = (m + 1),
 Ö É m né 0 * n = 0 Ä (m + 1) * n = (m * n + n)] 

: THM list
Ê

\end{session}

In the following example,  the conclusion of a theorem (an arbitrary theorem just for this example) is rewritten using the definitions of \ml{plus} and \ml{times} to produce a simpler theorem. 

\begin{session} 
Â
val th = asm_rule ª(0 + m) = ((0* n) +1)º;
Ê
Û
val th = (0 + m) = (0 * n + 1) Ö (0 + m) = (0 * n + 1) : THM   
Ê

Â
rewrite_rule rewrite_list th;
Ê
Û
val it = (0 + m) = (0 * n + 1) Ö m = 1 : THM  
Ê
\end{session}


\ml{rewrite\_rule} is not a primitive in \HOL, but is a derived rule.   In addition to the supplied equations,
\ml{rewrite\_rule} has some built in standard simplifications:

\begin{session} 
Â
 (asm_rule ª(T Ä x) Å F ä Fº);
Ê
Û
val it = T Ä x Å F ä F Ö T Ä x Å F ä F : THM   
Ê

Â
rewrite_rule [] it;
Ê
Û
val it = T Ä x Å F ä F Ö å x : THM   
Ê

 \end{session}

\noindent The complete list of these built-in rewrites is produced by executing \ml{get\_basic\_rewrites}:  

\newpage % PBHACK

\begin{session}
Â
get_basic_rewrites();
Ê
Û
val it = 
  [Ö É xé x = x Ç T,
   Ö É té ((T Ç t) Ç t) Ä ((t Ç T) Ç t) Ä ((F Ç t) Ç å t) Ä ((t Ç F) Ç å t),
   Ö É té (å å t Ç t) Ä (å T Ç F) Ä (å F Ç T),
   Ö É té (T Ä t Ç t) Ä (t Ä T Ç t) Ä å (F Ä t) Ä å (t Ä F) Ä (t Ä t Ç t),
   Ö É té (T Å t) Ä (t Å T) Ä (F Å t Ç t) Ä (t Å F Ç t) Ä (t Å t Ç t),
   Ö É té (T ä t Ç t) Ä (F ä t Ç T) Ä (t ä T Ç T) Ä (t ä t Ç T) Ä 
            (t ä F Ç å t),
   Ö É t1 t2é (if T then t1 else t2) = t1 Ä (if F then t1 else t2) = t2,
   Ö É té (É xé t) Ç t, Ö É té (Ñ xé t) Ç t, Ö É t1 t2é (ç xé t1) t2 = t1]

 : THM list
Ê
 
\end{session}

There are elaborate facilities in \HOL\ for producing customized rewriting tools
which scan through terms in user programmed orders; \ml{rewrite\_rule} is the tip
of an iceberg, see \DESCRIPTION\ for more details.




\pagebreak

\subsection{Goal Oriented Proof: Tactics and Tacticals}
\label{backward}\label{tactics}

The style of forward proof described in the previous chapter is unnatural and
too `low level' for many applications. An important advance in proof generating
methodology was made by Robin Milner in the early 1970s when he invented the
notion of {\it tactics\/}. A tactic is function that does two things.
\begin{enumerate}
\item Splits a `goal' into `subgoals'.
\item Keeps track of the reason why solving the subgoals will solve the goal.
\end{enumerate}

\noindent Consider, for example, the  rule of $\wedge$-introduction\footnote{In
higher order logic this is a derived rule; in first  order logic  it is usually
primitive.  In HOL the rule is called \ml{Ä\_intro} and its derivation is given in
\DESCRIPTION.}  shown below:  

\[ \Gamma_1\turn
t_1\qquad\qquad\qquad\Gamma_2\turn t_2\over \Gamma_1\cup\Gamma_2 \turn t_1\conj
t_2 \]


\noindent In \HOL,  $\wedge$-introduction is  represented by  the \SML\ function
\ml{Ä\_intro}:  

\[\ml{Ä\_intro}\ (\Gamma_1\turn t_1)\ (\Gamma_2\turn t_2) \ \ \leadsto\
\ (\Gamma_1\cup\Gamma_2\turn  t_1\conj  t_2)\]

\noindent  This  is   illustrated  in  the
following new  session  (note  that  the  session  number  has  been  reset  to
{\small\sl 1}):

\setcounter{sessioncount}{1}
\begin{session}

Â
val  Th1 = asm_rule ªA:BOOLº and Th2 = asm_rule ªB:BOOLº; 
Ê
Û
val Th1 = A Ö A : THM  
val Th2 = B Ö B : THM   
Ê

Â
val  Th3 = Ä_intro Th1 Th2; 
Ê
Û
val Th3 = A, B Ö A Ä B : THM
Ê   
\end{session}

Suppose the goal is to prove $A\conj B$, then this rule says 
that it is sufficient
to prove the two subgoals $A$ and $B$, because from $\turn A$ and $\turn B$
the theorem $\turn A\conj B$ can be deduced. Thus:

\begin{description}
\item[(i)] To prove $\turn A \conj B$ it is sufficient to 
      prove $\turn A$ and $\turn B$.
\item [(ii)]The justification for the reduction of the 
goal  $\turn A \conj B$  to the two  subgoals  $\turn A$ 
and $\turn B$ is the rule of $\wedge$-introduction.
\end{description}

A {\it goal\/} in \HOL\ is a pair
\ml{([$t_1$,\ldots,$t_n$],$t$)} of \SML\ type \ml{TERM list * TERM} . An {\it achievement\/} of such a goal
is a theorem
\ml{$t_1$,$\ldots$,$t_n$\ |-\ $t$}. 
A tactic is an \SML\ function that when applied to a goal generates subgoals
together with a {\it justification function\/} or {\it validation\/}, 
which will be a \SML\ derived inference
rule, that can be used to infer an achievement of the original goal from
achievements
of the subgoals. 



\SML\ has a type abbreviating mechanism which is used to give mnemonic
names to the various types associated with goal oriented proof.  Some type abbreviations are as follows:

\begin{tabular}{|l|l|}  \hline 
{\bf Abbreviation} & {\bf Type} \\ \hline \hline
\ml{CONV}          & \verb+TERM -> THM+    \\        \hline
\ml{GOAL}          & \verb+(TERM list ) * TERM + \\  \hline
\ml{GOAL\_STATE}   & an abstract type \\  \hline
\ml{PROOF}         & \verb+THM list -> THM+    \\    \hline
\ml{SEQ}           & \verb+(TERM list ) * TERM+   \\ \hline
\ml{TACTIC}        & \verb+GOAL -> (GOAL list * PROOF)+  \\ \hline
\ml{THM\_TACTIC}   & \verb+THM -> TACTIC+  \\ \hline
\ml{THM\_TACTICAL} & \verb+THM_TACTIC -> THM_TACTIC+  \\ \hline
\end{tabular}


The left hand side of these abbreviations can be used anywhere that the
right hand side can. 



If $T$ is a tactic (\ie\ a \SML\ function of type \ml{tactic})  and $g$ 
is a goal (\ie\ a \SML\ function of type \ml{goal}), then
applying $T$ to $g$ (\ie\ evaluating the \SML\ 
expression $T\ g$) will result in
an object of \SML\ type \ml{(GOAL list * PROOF) } \ie\ a pair whose 
first component is a list of 
goals and whose second component is a justification function, \ie\ has
\SML\ type \ml{PROOF}.


An example tactic is  \ml{Ä\_tac} which implements (i) and (ii) above.
For example, consider the utterly trivial goal of showing \ml{T Ä T},
where \ml{T} is a constant that stands for $true$:

\begin{session} 
Â
val  goal =([], ªT Ä Tº);
Ê 
Û
val goal = ([], ªT Ä Tº) : 'a list * TERM   
Ê

Â
Ä_tac goal;
Ê
Û
val it = ([([], ªTº), ([], ªTº)], fn) : GOAL list * PROOF   
Ê

Â
val  (goal_list,just_fn) = it; 
Ê
Û
val goal_list = [([], ªTº), ([], ªTº)] : GOAL list
val just_fn = fn : PROOF
Ê

\end{session}


\noindent \ml{Ä\_tac} has produced a goal  list consisting  of two identical
subgoals of just showing \ml{([],"T")}.  Now, there  is a  preproved theorem in
\HOL, which is recorded in theory  \ml{misc} under the name of \ml{t\_thm}.  It can be produced and bound to a \SML\ name,  say \ml{TRUTH}, as follows:


\begin{session} 

Â
val TRUTH = get_thm "misc" "t_thm";
Ê
Û
val TRUTH = Ö T : THM   
Ê

\end{session}



\noindent Applying the justification function \ml{just\_fn} to a list
of theorems achieving the goals in \ml{goal\_list} results
in a theorem achieving the original goal:

\begin{session} 
Â
just_fn [TRUTH, TRUTH];
Ê
Û
val it = Ö T Ä T : THM   
Ê
\end{session}

Although this  example  is trivial,  it does  illustrate the  essential idea of
tactics.  Note that  tactics are  not special  theorem-proving primitives; they
are just  \SML\  functions.   For example,  the definition  of  a tactic equivalent to the built-in \ml{Ä\_tac} would be:
simply:

Û
 
    fun Ä_tac_equivalent (asl,w) =
	let  val (l,r) = dest_Ä w 
	in
	([(asl,l), (asl,r)], 
	 fn [th1, th2] => Ä_intro th1 th2)
	end;

Ê

In this definition, the \SML\ function \ml{dest\_Ä} splits a conjunctive term into its
two conjuncts, \ml{l} and \ml{r}.
If \ml{(asl,ª$l$Ä$r$º} 
is a goal, then \ml{Ä\_tac\_equivalent} splits
it into the list of two subgoals \ml{(asl,ª$l$º)} and
\ml{(asl,ª$r$º)}. The justification function, 
\ml{fn [th1, th2] => Ä_intro th1 th2}
takes
a list \ml{[$th_1$,$th_2$]} of theorems and applies the rule \ml{Ä\_intro}
to $th_1$ and $th_2$.

To summarize:
if $T$ is a tactic and $g$ 
is a goal, then
applying $T$ to $g$ will result in
an object of \SML\ type  \ml{GOAL list * PROOF}, \ie\ a pair whose 
first component is a list of 
goals and whose second component is a justification function. 

Suppose \ml{$T\ g$ = ([$g_1$ , $\ldots$ , $g_n$], $p$ )}. 
The idea is that $g_1$ , $\ldots$ , $g_n$ are subgoals and $p$
is a `justification' of the reduction of goal $g$ to subgoals 
$g_1$ , $\ldots$ , $g_n$.
Suppose further that the subgoals $g_1$ , $\ldots$ , $g_n$ have been solved. 
This would mean that 
theorems $th_1$ , $\ldots$ , $th_n$ had been proved
such that each $th_i$ ($1\leq i\leq n$) `achieves' the goal $g_i$. 
The justification $p$ (produced
by applying $T$ to $g$) is a \SML\ 
function which when applied to the list
{\small\verb%[%}$th_1${\small\verb%,%}$\ldots${\small\verb%,%}$th_n${\small\verb%]%} returns a theorem, $th$, 
which `achieves' the original goal $g$.
Thus $p$ is a function for converting a solution of the subgoals to a
solution of the original goal. If $p$ 
does this successfully, then the tactic $T$ is
called {\it valid\/}. 
Invalid tactics cannot result in the proof of invalid theorems;
the worst they can do is result in insolvable goals or unintended theorems
being proved.
If tactic $T$ were invalid and were used
to reduce goal $g$ to subgoals $g_1$ , $\ldots$ , $g_n$,
then  effort might be spent proving
theorems $th_1$ , $\ldots$ , $th_n$ to
achieve the subgoals $g_1$ , $\ldots$ , $g_n$, 
only to find out after the work is done that this is a blind alley
because $p${\small\verb%[%}$th_1${\small\verb%,%}$\ldots${\small\verb%,%}$th_n${\small\verb%]%} 
doesn't achieve $g$ (\ie\ it fails, 
or else it achieves some other goal).

A theorem {\it achieves\/} a goal if the assumptions of the theorem are
included in the assumptions of the goal {\it and\/} if the conclusion of the
theorem is equal (up to the renaming of bound variables) to the conclusion of
the goal. More precisely, a theorem 
$t_1$, $\dots$, $t_m${\small\verb% |- %}$t$ achieves a goal
{\small\verb%([%}$u_1${\small\verb%;%}$\ldots${\small\verb%;%}$u_n${\small\verb%],%}$u${\small\verb%)%} 
if and only if {\small\verb%{%}$t_1,\ldots,t_m${\small\verb%}%} is a subset of
{\small\verb%{%}$u_1,\ldots,u_n${\small\verb%}%} and $t$ is equal to $u$ (up
to renaming of bound variables).  For example, the goal
\begin{quotation}
\ml{([ªx=yº, ªy=zº, ªz=wº],   ªx=zº)}
\end{quotation}
 is achieved by the theorem
\begin{quotation}
\ml{x=y, y=z Ö x=z} 
\end{quotation}the assumption \ml{z=w} being not
needed.

A tactic {\it solves\/} a goal if it reduces the goal 
to the empty list
of subgoals. Thus $T$ solves $g$ if  $T\ g${\small\verb% = ([],%}$p${\small\verb%)%}.
If this is the case and if $T$ is valid, then $p${\small\verb%[]%} 
will evaluate to a theorem achieving $g$.
Thus if $T$ solves $g$ then the \SML\ expression 
{\small\verb%snd(%}$T\ g${\small\verb%)[]%} evaluates to
a theorem achieving $g$.

Tactics are specified using the following notation:

\begin{center}
\begin{tabular}{c} \\
$goal$ \\ \hline \hline
$goal_1\ \ \ goal_2 \ \ \ \cdots\ \ \ goal_n$ \\
\end{tabular}
\end{center}

\noindent For example, a tactic called \ml{Ä\_tac} is described by

\begin{center}
\begin{tabular}{c} \\
$ t_1$ \ml{Ä} $t_2$ \\ \hline \hline
$t_1\ \ \ \ \ \ \ t_2$ \\
\end{tabular}
\end{center}



\noindent Thus \ml{Ä\_tac} reduces a goal of the form 
\ml{$\Gamma$, ª$t_1$Ä$t_2$º} 
to subgoals\ml{$\Gamma$, ª$t_1$º} and \ml{$\Gamma$, ª$t_2$º}
.
The fact that the assumptions of the top-level goal
are propagated unchanged to the two subgoals is indicated by the absence
of assumptions in the notation.

\pagebreak

Another example is  \ml{induction\_tac}, the tactic for doing mathematical induction
on the natural numbers.

\begin{center}
\begin{tabular}{c} \\
$t[n]$ \\ \hline \hline
$t[${\small\verb%0%}$]$ {\small\verb%     %} $\{t[n]\}\ t[${\small\verb%Suc %}$n]$
\end{tabular}
\end{center}

Given the name of a variable, n say,  which is to be the indiction variable,  \ml{induction\_tac ªn:Üº} reduces a goal ($\Gamma$,\ml{$t[n]$}) to
\begin{itemize}
\item  a basis subgoal ($\Gamma$,\ml{t[0]}), and 
\item  an induction step subgoal ($\Gamma\cup$ \{ t[n] \}, \ml{t[n+1]})

\end{itemize}The extra induction assumption \ml{t[n]}
is indicated in the tactic notation with set brackets.

\begin{session} 

Â
(induction_tac ªm:Üº)  ([], ª(m + n) = (n + m)º);
Ê

Û
val it = ([
	([], ª(0 + n) = (n + 0)º),
        ([ª(m + n) = (n + m)º], ª((m + 1) + n) = (n + m + 1)º)
	  ],
	fn) : GOAL list * PROOF
Ê
\end{session}

\noindent The first subgoal is the basis case and the second subgoal is
the step case.

Tactics generally fail (in the \SML\ sense) if they are applied to 
inappropriate
goals. For example, \ml{Ä\_tac} will fail if it is applied to a goal whose
conclusion is not a conjunction. Some tactics never fail, for example
{\small\verb%ALL_TAC%}\footnote{check this out}


\begin{center}
\begin{tabular}{c} \\
$t$ \\ \hline \hline
$t$
\end{tabular}
\end{center}

\noindent is the `identity tactic'; it reduces a goal 
{\small\verb%(%}$\Gamma${\small\verb%,%}$t${\small\verb%)%} 
to the single
subgoal {\small\verb%(%}$\Gamma${\small\verb%,%}$t${\small\verb%)%}---\ie\ 
it has no effect. {\small\verb%ALL_TAC%} is useful for writing
complex tactic using tacticals (\eg\ see the definition of {\small\verb%REPEAT%} in
Section~\ref{tacticals}).


\subsection{Using tactics to prove theorems}   
\label{using-tactics}

Suppose goal $g$  is to be solved. If $g$
is simple it might be possible
to immediately think up a tactic, $T$ 
say, which reduces it to the empty list of
subgoals. If this is the case then executing:

\ml{val (gl,p) = T g ;}


\noindent will bind $p$ to a function which when applied to the empty list
of theorems yields a theorem $th$ achieving $g$. 
(The declaration above
will also bind $gl$ to the empty list of goals.) Thus a theorem achieving 
$g$ can be computed by executing:

\ml{val th = p [];}


\noindent This will be illustrated using \ml{rewrite\_tac} which takes a list
of equations (empty in the example that follows) and tries to prove a goal
by rewriting with these equations togther with
\ml{basic\_rewrites}:

\begin{session}
Â 
val g = ([], ªT Ä x ä x Å (y Ä F)º);
Ê

Û
val g = ([], ªT Ä x ä x Å y Ä Fº) : 'a list * TERM   
Ê

Â
val T = rewrite_tac [];
Ê
Û
val T = fn : TACTIC   
Ê

Â
 val (gl, p) = T g;
Ê
Û
val gl = [] : GOAL list   val p = fn : PROOF   
Ê

Â
 val th = p[];
Ê
Û
val th = Ö T Ä x ä x Å y Ä F : THM   
Ê
\end{session}

\noindent Proved theorems are usually stored in the current theory 
so that
they can be used in subsequent sessions.

To simplify the use of tactics there is a built-in  function \ml{tac\_proof} of
\SML\ type \ml{GOAL * TACTIC -> THM} such that

\ml{tac\_proof ($G$, $T$)} 
 proves
the goal  $G$  using  tactic  $T$  and  returns the resulting theorem.

If the theorem is  to be saved on the current theory, the function \ml{save\_thm} of type \ml{string * THM -> THM}  can be used. Evaluating \ml{save\_thm ("foo", th)}  will cause theorem \ml{th} to be saved in the current theory under the name of \ml{foo}.  The theorem can be removed from the current theory by evaluating \ml{delete\_thm "foo"}.  Both \ml{save\_thm} and \ml{delete\_thm} return a value which is the theorem in question.


When conducting a proof that involves many subgoals and tactics, it is necessary
to keep track of all the justification functions  
and compose them in the correct order.  While
this is feasible even in large proofs, it is tedious.  \HOL\ provides a package
for building and traversing the tree of subgoals, stacking the justification functions and
applying them properly; such package was originally implemented for \LCF\ by 
Larry Paulson.

The subgoal package implements a simple framework for interactive proof. A proof
tree is created and traversed top-down.  The current goal can be expanded
into subgoals using a tactic; the subgoals are pushed onto a goal
stack and the justification function onto a proof stack.
Subgoals can be considered in any order.  If the tactic solves a
subgoal (\ie\ returns an empty subgoal list), then the package proceeds to the
next subgoal in the tree. 

The function  \ml{push\_goal} of type \ml{goal -> void}
initializes the subgoal package with a new goal. Usually
top-level goals have no assumptions; the function \ml{g} is useful
in this case and is defined by:

Â 
   fun g t = push_goal([],t);
Ê

\typeout{ point 100}

To illustrate the subgoal package the trivial theorem
$\vdash \uquant{m}m+0=m$ will be proved from the definition   of addition: 

\begin{session}

Â 
val ADD = [get_defn "Ü" "+"];
Ê

Û
val ADD =  [
Ö É m né (0 + n) = n Ä ((m + 1) + n) = ((m + n) + 1) Ä Suc m =  (m + 1)
   ] : THM list
Ê
\end{session}

\noindent Notice that \ml{ADD} specifies $0+n=n$
 but not  $n+0=n$. Of course, $\uquant{m\ n}m+n = n+m$ is true, but the first
step of the proof of this from the definition of addition is showing  $\uquant{m}m+0=m$.

\typeout{point 101}

\setcounter{sessioncount}{1}
\begin{session} 
Â
g ª(m + 0) = mº; 
Ê


Û
Now 1 goal on the main goal stack

(* *** Goal "" *** *)

(* ?Ö *)  ª(m + 0) = mº

val it = () : unit 

Ê

\end{session}

\typeout{point 102}

\noindent This sets up the goal. Next the goal is split into a basis and step case
with \ml{INDUCT\_TAC}. To do this the function \ml{apply\_tactic} (abbreviating this freqently-used name to \ml{a}) is used. This applies a tactic to the top goal on the stack, then
pushes the resulting subgoals onto the goal stack, then prints the resulting
subgoals. If there are no subgoals, the justification function is applied to the
theorems solving the subgoals that have been proved and the resulting theorems are
printed.

\begin{session}
Â
val a = apply_tactic; 
Ê
Û
val a = fn : TACTIC -> unit   
Ê

Â
a  (induction_tac ªm:Üº) ;
Ê

Û
Tactic produced 2 subgoals:

(* *** Goal "2" *** *)

(*  1 *)  ª(m + 0) = mº

(* ?Ö *)  ª((m + 1) + 0) = (m + 1)º


(* *** Goal "1" *** *)

(* ?Ö *)  ª(0 + 0) = 0º

val it = () : unit
Ê
  
\end{session}

\typeout{point 103}

\noindent The top of the goal stack is printed last. The basis case
is an instance of the definition of addition, so is solved by rewriting with
\ml{ADD}.

\begin{session}
Â
a (rewrite_tac ADD);
Ê
Û
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "2" *** *)

(*  1 *)  ª(m + 0) = mº

(* ?Ö *)  ª((m + 1) + 0) = (m + 1)º

val it = () : unit 
Ê
  

\end{session}

\typeout{point 104}

\noindent The basis is solved and the goal
stack popped so that its top is now the step case, namely showing
that {\small\verb%(SUC m) + 0 = SUC m%}  on the assumption thatt
{\small\verb%n + 0 = n%}. This goal can be solved by rewriting first
with the definition of addition:

\begin{session}
Â
a (rewrite_tac ADD);
Ê
Û
Tactic produced 1 subgoal:

Tactic produced 1 subgoal:

(* *** Goal "2" *** *)

(*  1 *)  ª(m + 0) = mº

(* ?Ö *)  ª((m + 0) + 1) = (m + 1)º

val it = () : unit
Ê  

\end{session}

\typeout{ point 105}

and then by rewriting with the assumption \ml{n  + 0 = n}. The tactic
\ml{asm\_rewrite\_tac} is used to rewrite with the assumptions of a goal. It is
just like \ml{rewrite\_tac} except that it adds the assumptions to the list of
equations used for rewriting. For the example here no equations besides the
assumptions are needed, so \ml{asm\_rewrite\_tac} is given the empty list of
equations.

\begin{session}
Â
a (asm_rewrite_tac []);
Ê
Û
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit 
Ê 
  
\end{session}

\noindent The top goal is solved, hence the preceding goal (the step case)
is solved too, and since the basis is already solved, the main goal is solved.

The theorem achieving the goal can be extracted from the subgoal package with \ml{top\_thm}:


\index{theorems, retrieving from goal state with \ml{top\_thm}}
\begin{session}
Â
top_thm(); 
Ê
Û
val it = Ö (m + 0) = m : THM   
Ê
\end{session}


\typeout{point 106}
The proof just done can be `optimized'. For example, instead
of first rewriting with \ml{ADD} (box 4) and then with the assumptions
(box 5), a single rewriting with \ml{ADD} and the assumptions would suffice.
To illustrate, the last two steps of the proof will be `undone' using the function
\ml{undo} which restores the previous state of the goal and theorem stacks.

\begin{session} 
Â
undo 1;
Ê
Û
Current goal is:

(* *** Goal "2" *** *)

(*  1 *)  ª(m + 0) = mº

(* ?Ö *)  ª((m + 0) + 1) = (m + 1)º

val it = () : unit
Ê

Â
undo 1;
Ê
Û
Current goal is:

(* *** Goal "2" *** *)

(*  1 *)  ª(m + 0) = mº

(* ?Ö *)  ª((m + 1) + 0) = (m + 1)º

val it = () : unit 
Ê  
\end{session}

\noindent The proof can now be completed in one step instead of two:

\begin{session}
Â
a (asm_rewrite_tac ADD);
Ê
Û
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit  
Ê
\end{session}


The order in which goals are attacked can be adjusted. Firstly the goal stack is backed up by two steps, back to the point at which there are two subgoals.   Note that the  previous example showed two separate calls of \ml{undo},  each of a single stepto show the effect, any number of steps can be backed up by giving an argument to \ml{undo}:

\begin{session}
Â
undo 2;
Ê
Û
Current goal is:

(* *** Goal "1" *** *)

(* ?Ö *)  ª(0 + 0) = 0º

val it = () : unit
Ê
\end{session}

The system offers the basis case as the current subgoal.  In order to survey all the possible subgoals, the command \ml{print\_goal\_state  (top\_goal\_state())} is used:
\index{goal state, examining with \ml{print\_goal\_state}}

\begin{session}
Â
print_goal_state (top_goal_state());
Ê
Û
Main goal is:
(* ?Ö *)  ª(m + 0) = mº

Goals to be proven are:

(* *** Goal "1" *** *)

(* ?Ö *)  ª(0 + 0) = 0º


(* *** Goal "2" *** *)

(*  1 *)  ª(m + 0) = mº

(* ?Ö *)  ª((m + 1) + 0) = (m + 1)º


Current goal is:

(* *** Goal "1" *** *)

(* ?Ö *)  ª(0 + 0) = 0º

val it = () : unit  
Ê
\end{session}

It can be seen that the current goal is labelled "1" and the other goal is labelled "2".  To choose the other goal to work on, it is made current with the command \ml{set\_labelled\_goal}, providing an argument value of, in this case, "2".
\begin{session}
Â
set_labelled_goal "2";
Ê
Û
Current goal is:

(* *** Goal "2" *** *)

(*  1 *)  ª(m + 0) = mº

(* ?Ö *)  ª((m + 1) + 0) = (m + 1)º

val it = () : unit  
Ê
\end{session}

\typeout{point 199}

\noindent The top goal is now the step case not the basis case, so the appropriate tactic can be applied:

\begin{session}
Â
 a (asm_rewrite_tac ADD);
Ê
Û
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "1" *** *)

(* ?Ö *)  ª(0 + 0) = 0º

val it = () : unit 
Ê  
\end{session}

\typeout{point 200}
\pagebreak
\subsection{Tacticals}
\label{tacticals}

It is possible to do the whole of the above proof in one step, but this requires a compound
tactic built using the {\it tactical\/}\footnote{This word was invented by Robin
Milner: `tactical' is to `tactic` as `functional' is to `function'.} \ml{THEN\_LIST}.
Tacticals are higher order operations for combining tactics.


A {\it tactical\/} 
is an \SML\ function that returns a tactic (or tactics) as result.
Tacticals may take various parameters; this is reflected in the various
\SML\ types that the built-in tacticals have. Some important tacticals in 
the \HOL\ system
are listed below.



\typeout{point 210}

\subsubsection{\tt THEN\_LIST: TACTIC * TACTIC list -> TACTIC}
 
\typeout{point 211}
     
If $T$ is a tactic which produces $n$ subgoals and $T_1$, $\ldots$ ,
$T_n$ are tactics
then $T$\ml{THEN\_LIST } $[T_1, $ \ldots $ ,T_n]$ 

is a tactic which first applies $T$ and then
applies $T_i$ to the $i$th subgoal produced by $T$. 
The tactical \ml{THEN\_LIST} is useful if one wants to do different
things to different subgoals.

\ml{THEN\_LIST} can be illustrated by doing the proof of $\vdash \uquant{m}m+0=m$ in
one step.


\typeout{point 220}

\setcounter{sessioncount}{1}
\begin{session}
Â 
g ª(m +0) = mº;
Ê
Û
Now 2 goals on the main goal stack

(* *** Goal "" *** *)

(* ?Ö *)  ª(m + 0) = mº

val it = () : unit 
Ê

Â

a ((induction_tac ªm:Üº) THEN_LIST [(rewrite_tac ADD), (asm_rewrite_tac  ADD)]); 
Ê
Û
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit  
Ê

\end{session}

\typeout{point 230}

\noindent The compound tactic:
\begin{quote}
\ml{ ((induction\_tac ªm:Üº) THEN\_LIST [(rewrite\_tac ADD), (asm\_rewrite\_tac ADD)])}
\end{quote}

first applies \ml{induction\_tac ªm:Üº} and then applies
\ml{rewrite\_tac ADD} to the first subgoal (the basis) and
\ml{asm\_rewrite\_tac ADD} to the second subgoal (the step). 

The tactical \ml{THEN\_LIST} is useful for doing different things to different
subgoals. The tactical \ml{THEN} can be used to apply the same tactic to all
subgoals.

\typeout{point 240}

\subsubsection{\tt THEN :TACTIC * TACTIC -> TACTIC }


The tactical {\small\verb%THEN%} is an \SML\ infix. If $T_1$ and $T_2$ are tactics,
then the \SML\ expression $T_1${\small\verb% THEN %}$T_2$ evaluates to a tactic
which first applies $T_1$ and then applies $T_2$ to all the subgoals produced by
$T_1$. 

In fact,
\ml{asm\_rewrite\_tac[ADD]} will solve the basis as well as the step
case of the induction for $m+0=m$, so there is an even
simpler one-step proof than the one above:
\setcounter{sessioncount}{1}

 % got to here 

\begin{session}
Â
g ª(m + 0) = mº; 
Ê
Û
Now 3 goals on the main goal stack

(* *** Goal "" *** *)

(* ?Ö *)  ª(m + 0) = mº

val it = () : unit 
Ê

Â
a ((induction_tac ªm:Üº) THEN  (asm_rewrite_tac ADD));
Ê
Û
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit   
Ê
\end{session}


\typeout{point 250}


\noindent This is typical: it is common to use a single tactic for several
goals. Here is a sequence of examples:

\begin{session}
Â
val ADD_0 =
 tac_proof  (([],ª (m + 0) = mº),
	     (induction_tac ªm:Üº) THEN (asm_rewrite_tac ADD));
Ê
Û
val ADD_0 = Ö (m + 0) = m : THM
Ê

Â
val ADD_SUC =
 tac_proof 
   (([],ª((m + n) + 1) = (m + (n+1))º),
    (induction_tac ªm:Üº) THEN (asm_rewrite_tac ADD));
Ê
Û
val ADD_SUC = Ö ((m + n) + 1) = (m + n + 1) : THM
Ê

Â
val ADD_CLAUSES =
  tac_proof 
    ( ( [],  ª ((0 + m) = m				)  Ä
       	       ((m + 0) = m				)  Ä
               (((m+1) + n) = ((m + n) + 1)	)  Ä
               ((m + (n+1)) = ((m + n) + 1)	) º
      )
    ,
     rewrite_tac (ADD_0:: (ADD_SUC::ADD)) 
    );
Ê
Û
val ADD_CLAUSES =
 Ö (0 + m) = m Ä
   (m + 0) = m Ä 
   ((m + 1) + n) = ((m + n) + 1)
  Ä (m + n + 1) = ((m + n) + 1) : THM
Ê



\subsubsection{\tt REPEAT : TACTIC -> TACTIC}

If $T$ is a 
tactic then {\small\verb%REPEAT %}$T$ is a tactic which repeatedly applies
$T$ until it fails. This can be illustrated in conjunction with
\ml{simple\_É\_tac}, which is specified by:


\begin{center}
\begin{tabular}{c} \\
$Éxét[x]$
\\ \hline \hline
$t[x']$
\\
\end{tabular}
\end{center}

\begin{itemize}
\item Where $x'$ is a variant of $x$ 
not free in the goal or the assumptions.
\end{itemize}

\noindent \ml{simple\_É\_tac} strips off one quantifier; 
\ml{REPEAT\ simple\_É\_tac} strips off all quantifiers:

\begin{session}
 
Â
g ª Éx y zé (x + (y + z)) = ((x + y) + z ) º; 
Ê
Û
Now 5 goals on the main goal stack

(* *** Goal "" *** *)

(* ?Ö *)  ªÉ x y zé (x + y + z) = ((x + y) + z)º


val it = () : unit   
Ê

Â
a  simple_É_tac; 
Ê
Û
Tactic produced 1 subgoal:

(* *** Goal "" *** *)

(* ?Ö *)  ªÉ y zé (x + y + z) = ((x + y) + z)º

val it = () : unit
Ê

Â
a (REPEAT simple_É_tac ); 
Ê
Û
Tactic produced 1 subgoal:

(* *** Goal "" *** *)

(* ?Ö *)  ª(x + y + z) = ((x + y) + z)º
val it = () : unit  
Ê 
\end{session}

\typeout{point 300}

\pagebreak
\subsection{Some tactics built into HOL}

This section contains a summary of some of the tactics built-in to the \HOL\ system
(including those already discussed).


Recall that the \SML\ type {\small\verb%thm_tactic%} abbreviates {\small\verb%theorem->tactic%}, 
and the type {\small\verb%conv%}\footnote{The type
{\small{\tt conv}} comes from Larry Paulson's theory of conversions
\cite{PAULSON83}.} abbreviates {\small\verb%term->thm%}.

\subsubsection{\tt rewrite\_tac:  THM list -> TACTIC}
\label{rewrite}

\begin{itemize}
\item{\bf Summary:} \ml{rewrite\_tac [} $th_1, \ldots ,th_n$  \ml{]}
simplifies the goal by rewriting
it with the explicitly given theorems $th_1$, $\ldots$ , $th_n$, 
and various built-in rewriting rules.


\begin{center}
\begin{tabular}{c} \\
$\{t_1, \ldots , t_m\}t$
\\ \hline \hline
$\{t_1, \ldots , t_m\}t'$
\\
\end{tabular}
\end{center}

\noindent where $t'$ is obtained from $t$ by rewriting with
\begin{enumerate}
\item  $th_1$, $\ldots$ , $th_n$ and
\item  the standard rewrites held in the \SML\ variable {\small\verb%basic_rewrites%}.
\end{enumerate}

\item{\bf Uses:} Simplifying goals using previously proved theorems.

\item{\bf Other rewriting tactics} (based on \ml{rewrite\_tac}):
\begin{enumerate}
\item \ml{asm\_rewrite\_tac} adds the assumptions of the goal to the list of
theorems used for rewriting.
\item \ml{fasm\_rewrite\_tac}{\small\verb% [%}$th_1${\small\verb%;%}$\ldots${\small\verb%;%}$th_n${\small\verb%]%} $p$
simplifies the goal by rewriting
it with the explicitly given theorems $th_1$ , $\ldots$ , $th_n$ , 
together with those
assumptions of the goal which satisfy the predicate $p$ and also
the built-in rewrites given by {\small\verb%get_basic_rewrites%}.
\item \ml{pure\_asm\_rewrite\_tac} is like \ml{asm\_rewrite\_tac}, but it
doesn't use any built-in rewrites.
\item \ml{pure\_rewrite\_tac} uses neither the assumptions nor the built-in
rewrites
\end{enumerate}
\end{itemize}


\subsubsection{\tt taut\_tac: TACTIC}




\begin{itemize}

\item{\bf Summary:} Solves a goal the conclusion of which is a tautology

\item{\bf Uses:} Solving tautological goals. \ml{taut\_tac} is invoked by other built-in tactics.  

\end{itemize}

Example:
\begin{session}
Â
g ª ( x = 3) Å  å (x = 3)º;
Ê
Û
Now 4 goals on the main goal stack

(* *** Goal "" *** *)

(* ?Ö *)  ªx = 3 Å å x = 3º

val it = () : unit 
Ê 
Â
a taut_tac;
Ê
Û
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit  
Ê

Â
g ªÉxé (x = 3 ) Å  å(x = 3)º;
Ê
Û
Now 5 goals on the main goal stack

(* *** Goal "" *** *)

(* ?Ö *)  ªÉ xé x = 3 Å å x = 3º

val it = () : unit
Ê

Â
a taut_tac;
Ê
Û
Exception-
   Fail
      *** ERROR 28121 raised by simple_taut_tac: Conclusion of the goal is
      not a tautology *** raised
Exception+ failure handled by useterminal

 Note the error message refers to  simple_taut_tac; presumably this will succeed in later versions of the product
Ê
\end{session}

\subsubsection{\tt Ä\_tac: TACTIC}

\begin{itemize}

\item{\bf Summary:} Splits a 
goal \ml{ª$t_1$ Ä $t_2$º} into two subgoals  \ml{ª$t_1$ º} 
and  \ml{ª $t_2$º}.

\begin{center}
\begin{tabular}{c} \\
$t_1${\small\verb% /\ %}$t_2$
\\ \hline \hline
$t_1\ \ \ \ \ \ t_2$
\\
\end{tabular}
\end{center}

\item{\bf Uses:} Solving conjunctive goals. 
\ml{Ä\_tac} is invoked by \ml{strip\_tac} (see below).

\end{itemize}




\subsubsection{\tt ä\_tac: TACTIC }

\begin{itemize}

\item{\bf Summary:} Moves the antecedant 
of an implicative goal into the assumptions.

\begin{center}
\begin{tabular}{c} \\
$u$ \ml{ä}$v$
\\ \hline \hline
$\{u\}v$
\\
\end{tabular}
\end{center}


\item{\bf Uses:} Solving goals of the form 
\ml{ª$u$ä$v$º} by assuming \ml{ª$u$º}  and then solving \ml{ª$v$º }.
\ml{strip\_tac} (see below) will invoke \ml{ä\_tac} on implicative goals.
\end{itemize}

\subsubsection{\tt simple\_É\_tac: TACTIC}

\begin{itemize}

\item{\bf  Summary:} Strips off one universal quantifier.
   

\begin{center}
\begin{tabular}{c} \\
$Éxét[x]$
\\ \hline \hline
$t[x']$
\\
\end{tabular}
\end{center}

\noindent Where $x'$ is a variant of $x$ 
not free in the goal or the assumptions.

\item{\bf   Uses:} Solving universally quantified goals. 
\ml{REPEAT simple\_É\_tac } strips off all
universal quantifiers and is often the first thing one does in a proof.

\ml{strip\_tac} (see below)  applies \ml{simple\_É\_tac} to universally quantified goals.
\end{itemize}


\subsubsection{\tt IMP\_RES\_TAC : tactic}

This section to be rewritten.

\begin{itemize}

\item{\bf Summary:} {\small\verb%IMP_RES_TAC %}$th$
`resolves' (see below) $th$ with the 
assumptions of the goal
and then adds the results to the assumptions.


\begin{center}
\begin{tabular}{c} \\
$\{t_1,\ldots,t_m\}t$
\\ \hline \hline
$\{t_1,\ldots,t_m,u_1,\ldots,u_n\}t$
\\
\end{tabular}
\end{center}

\noindent  where $u_1$, $\ldots$ , $u_n$ 
are derived by `resolving' $th$ with $t_1$, $\ldots$ , $t_m$. 
Resolution in \HOL\ 
is not classical resolution, but just Modus Ponens
with a bit of one-way pattern matching (not unification). The usual case
is where $th$ is of the form

$\ \ \ ${\small\verb%|- !%}$x_1$$\ldots x_p${\small\verb%.%}$v_1${\small\verb%==>%}$v_2${\small\verb%==>%}$\ldots${\small\verb%==>%}$v_q${\small\verb%==>%}$v$. 

\noindent {\small\verb%IMP_RES_TAC %}$th$ then tries
to specialize $x_1$, $\ldots$ , $x_p$ 
so that  $v_1$, $\ldots$ , $v_q$ 
match members of $\{t_1,\ldots ,t_m\}$.
If such a match is found then the appropriate instance of $v$ is added
to the assumptions, together with all appropriate instances of 
$v_i${\small\verb%==>%}$\ldots v_n${\small\verb%==>%}$v$ ($2 \leq i \leq n$). 
{\small\verb%IMP_RES_TAC%} can also be given a conjunction of implications,
 in which case 
it will do
`resolution' with each of the conjuncts. In fact, 
it applies a canonicalization
rule to its argument to split it into a list of theorems.
Each theorem produced by this canonicalization process 
is resolved with the assumptions. Full details can be found in 
\REFERENCE\ (the canonicalization in \HOL\
is based on that done in Cambridge \LCF \cite{PAULSON87}, 
but differes slightly from it).

\item{\bf Uses:} Deriving new assumptions from existing 
ones and previously proved theorems
so that subsequent tactics (\eg\ \ml{asm\_rewrite\_tac}) have 
more to work with.
\end{itemize}


        
\subsubsection{\tt strip\_tac  : TACTIC}

\begin{itemize}

\item{\bf Summary:} Breaks a goal apart.
\ml{strip\_tac} removes one outer connective from the goal, using
\ml{Ä\_tac}, \ml{ä\_tac},  \ml{simple\_É\_tac}, \etc\  
If the goal has the form\ml{ $t_1$  Ä $\cdots$ Ä $t_n$ ä $t$}
then each  $t_i$  is made into a  separate assumption.

\item{\bf Uses:} Useful for spliting a goal up into manageable pieces. 
Often the best thing to do first is \ml{REPEAT strip\_tac}.
\end{itemize}



\subsubsection{\tt id\_tac : tactic}

\begin{itemize}
\item{\bf Summary:} Identity tactic for the tactical {\small\verb%THEN%}
(see end of Section~\ref{tactics}).

\item{\bf Uses:}
\begin{enumerate}
\item Writing tacticals (see description of {\small\verb%REPEAT%} 
in Section~\ref{tacticals}). 
\item With {\small\verb%THEN_LIST%}; for example, if tactic $T$ produces two subgoals 
and we want to apply $T_1$ 
to the first one but to do nothing to the second, then 
the tactic to use is $T${\small\verb% THEN_LIST[%}$T_1${\small\verb%;id_tac]%}.
\end{enumerate}
\end{itemize}

\subsubsection{\tt fail\_tac : tactic}

\begin{itemize}
\item{\bf Summary:} Tactic that always fails.

\item{\bf Uses:} Writing tacticals.
\end{itemize}

\makeatletter   




\newpage
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}




=IGNORE
:\footnote{At the time of writing the corresponding tactic is not available in the product, and when it is will not be called \ml{INDUCT\_TAC}.  As a temporary measure, just to see how the examples come out, we use an ad-hoc definition of a tactic, calling it \ml{INDUCT\_TAC} for the time being.

Â
fun  I_fn  (asl,c) =
  let val p = mk_ç (dest_É c)
      val P5 = get_axiom  "Peano" "P5"
  in
      undisch_rule (rewrite_rule [] (simple_É_elim  p P5))
  end;

fun I_tac (g : GOAL) =
  let val K = I_fn g 
      val h = hd (hyps K)
      val (h1,h2) = dest_Ä h
  in 
      ([((fst g),h1), ((fst g), h2)],    fn [g1, g2] =>  ä_elim (disch_rule h  K) (Ä_intro g1 g2)  )
  end; 

val INDUCT_TAC = (I_tac THEN (REPEAT strip_tac));
Ê

}   % end footnote
=TEX
