
=IGNORE
 % U s e f u l C o m m a n d s

/hat/nih/bin/poly_2.04/poly  -r ~ied/rel001/latest/sun3hol.db
cp  ~ied/rel001/latest/sun3hol.db example.db; chmod +w example.db
/hat/nih/bin/poly_2.04/poly  example.db
poly sun3hol.db
PolyML.quit();
rm -f *.aux *.dvi *.idx *.log *.sid 
doctex usr004
texdvi usr004
texdvi usr004
bibtex usr004
texdvi usr004
dvipage usr004
=TEX
\documentstyle[hol1,11pt,twoside,TQ]{article}
\ftlinepenalty=9999
\makeindex
     \TPPproject{FST PROJECT}  %% Mandatory field
%     \TPPvolume{}
%       \TPPpart{}
       \TPPtitle{INTRODUCTION TO ICL HOL}  %% Mandatory field
         \TPPref{DS/FMU/IED/USR004}  %% Mandatory field
\def\SCCSversion{
}
        \TPPissue{$Revision$%
}  
         \TPPdate{\FormatDate{$Date$
}}
       \TPPstatus{Informal}			%% Mandatory field
         \TPPtype{Technical Note}
     \TPPkeywords{}
       \TPPauthor{R. Stokes & WIN01}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & Project Leader}
     \TPPabstract{}
 \TPPdistribution{\parbox[t]{4.0in}{%
	    HAT Team Members
}}

\makeatletter
% \def
% =GRUMBLE
% cannot convert character code 220 'Ü'
% =TEX
% {\@Mm{\mid\!\equiv}}
% \defò{\@Mm{\hbox{\Large$\triangleleft$}}}
% \def
% =GRUMBLE
% cannot convert character code 183 '·'
% =TEX
% {\@Mm{\mid\!\sim}}
% \def
% =GRUMBLE
% cannot convert character code 239 'ï'
% =TEX
% {\@Mm{\mid\!\Rightarrow}}
% \def
% =GRUMBLE
% cannot convert character code 170 'ª'
% =TEX
% {\@Mm{{\#}}}
% \defª{\@Mm{\leftrightarrow}}
% \defí{\@Mm{\mapsto}}
%\defí{\@Mm{\stackrel{\hbox{\scriptsize ?}}{\mapsto}}}
% \def
% =GRUMBLE
% cannot convert character code 185 '¹'
% =TEX
% {\@Mm{\rightleftharpoons}}
% \def
% =GRUMBLE
% cannot convert character code 228 'ä'
% =TEX
% {\@Mm{\{\}}}
% \def¨{\@Mm{\langle\rangle}}

% \def
% =GRUMBLE
% cannot convert character code 211 'Ó'
% =TEX
% {\@Mm{^{-1}}}
\makeatother


=TEX

\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}

\cleardoublepage
\section{Document control}

\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu} 

\subsection{Changes history} 
\begin{description}
\item[1.1] Initial Draft.
\item[1.3] First draft released. 
\item[2.1] Draft.  Beginning of attempt to conform to ``House Style''. 

\end{description}
\subsection{Changes forecast}
Closer convergence with the house style  -- the ICL Visual Identity Manual -- is to be achieved. Items outstanding are:
\begin{itemize}
\item wide-column format
\item page headers and footers
\item removal of this document-control section so that the present section 0.5 (`About this Document') becomes the whole of 
an un-numbered opening `chapter'.
\end{itemize}


% =====================================================================
%
% Macros for typesetting the HOL system manual
%
% =====================================================================

% ---------------------------------------------------------------------
% Abbreviations for words and phrases
% ---------------------------------------------------------------------
\newcommand\VERSION{{\small\tt 1.10}}
\newcommand\TUTORIAL{{\footnotesize\sl INTRODUCTION}}
\newcommand\DESCRIPTION{{\footnotesize\sl DESCRIPTION}}
\newcommand\REFERENCE{{\footnotesize\sl REFERENCE MANUAL}}

\def\HOL{{\small HOL}}
\def\LCF{{\small LCF}}
\def\LCFLSM{{\small LCF{\kern-.2em}{\normalsize\_}{\kern0.1em}LSM}}
\def\PPL{{\small PP}{\kern-.095em}$\lambda$}
\def\PPLAMBDA{{\small PPLAMBDA}}
\def\SML{{\small Standard ML}}

\newcommand\ie{\mbox{i{.}e{.}}}
\newcommand\eg{\mbox{e{.}g{.}}}
\newcommand\viz{\mbox{viz{.}}}
\newcommand\adhoc{\mbox{\it ad hoc}}
\newcommand\etal{{\it et al.\/}}
\newcommand\etc{\mbox{etc{.}}}
\def\see#1#2{{\em see\/} #1}

% ---------------------------------------------------------------------
% Simple abbreviations and macros for mathematical typesetting
% ---------------------------------------------------------------------

\newcommand\fun{{\to}}
\newcommand\prd{{\times}}

\newcommand\conj{\ \wedge\ }
\newcommand\disj{\ \vee\ }
\newcommand\imp{ \Rightarrow }
\newcommand\eqv{\ \equiv\ }
\newcommand\cond{\rightarrow}
\newcommand\vbar{\mid}
\newcommand\turn{\ \vdash\ }
\newcommand\hilbert{\varepsilon}
\newcommand\eqdef{\ \equiv\ }

\newcommand\natnums{\mbox{${\sf N}\!\!\!\!{\sf N}$}}
\newcommand\bools{\mbox{${\sf T}\!\!\!\!{\sf T}$}}

\newcommand\p{$\prime$}
\newcommand\f{$\forall$\ }
\newcommand\e{$\exists$\ }

\newcommand\orr{$\vee$\ }
\newcommand\negg{$\neg$\ }

\newcommand\arrr{$\rightarrow$}
\newcommand\hex{$\sharp $}

\newcommand{\uquant}[1]{\forall #1.\ }
\newcommand{\equant}[1]{\exists #1.\ }
\newcommand{\hquant}[1]{\hilbert #1.\ }
\newcommand{\iquant}[1]{\exists ! #1.\ }
\newcommand{\lquant}[1]{\lambda #1.\ }

\newcommand{\leave}[1]{\\[#1]\noindent}
\newcommand\entails{\mbox{\rule{.3mm}{4mm}\rule[2mm]{.2in}{.3mm}}}

% --------------------------------------------------------------------- 
% Font-changing commands
% ---------------------------------------------------------------------

\newcommand{\theory}[1]{\hbox{{\small\tt #1}}}

\newcommand{\con}[1]{{\sf #1}}
\newcommand{\rul}[1]{{\tt #1}}
\newcommand{\ty}[1]{{\sl #1}}

\newcommand{\ml}[1]{\mbox{\small\tt #1}}
\newcommand\ms{\tt}
\newcommand{\s}[1]{{\small #1}}

\newcommand{\pin}[1]{{\bf #1}}
\def\m#1{\mbox{\normalsize$#1$}}

% ---------------------------------------------------------------------
% Abbreviations for particular mathematical constants etc.
% ---------------------------------------------------------------------

\newcommand\T{\con{T}}
\newcommand\F{\con{F}}
\newcommand\OneOne{\con{One\_One}}
\newcommand\OntoSubset{\con{Onto\_Subset}}
\newcommand\Onto{\con{Onto}}
\newcommand\TyDef{\con{Type\_Definition}}
\newcommand\Inv{\con{Inv}}
\newcommand\com{\con{o}}
\newcommand\Id{\con{I}}
\newcommand\MkPair{\con{Mk\_Pair}}
\newcommand\IsPair{\con{Is\_Pair}}
\newcommand\Fst{\con{Fst}}
\newcommand\Snd{\con{Snd}}
\newcommand\Suc{\con{Suc}}
\newcommand\Nil{\con{Nil}}
\newcommand\Cons{\con{Cons}}
\newcommand\Hd{\con{Hd}}
\newcommand\Tl{\con{Tl}}
\newcommand\Null{\con{Null}}
\newcommand\ListPrimRec{\con{List\_Prim\_Rec}}


\newcommand\SimpRec{\con{Simp\_Rec}}
\newcommand\SimpRecRel{\con{Simp\_Rec\_Rel}}
\newcommand\SimpRecFun{\con{Simp\_Rec\_Fun}}
\newcommand\PrimRec{\con{Prim\_Rec}}
\newcommand\PrimRecRel{\con{Prim\_Rec\_Rel}}
\newcommand\PrimRecFun{\con{Prim\_Rec\_Fun}}

\newcommand\bool{\ty{bool}}
\newcommand\num{\ty{num}}
\newcommand\ind{\ty{ind}}
\newcommand\lst{\ty{list}}

% ---------------------------------------------------------------------
% \minipagewidth = \textwidth minus 1.02 em
% ---------------------------------------------------------------------

\newlength{\minipagewidth}
\setlength{\minipagewidth}{\textwidth}
\addtolength{\minipagewidth}{-1.02em}

% ---------------------------------------------------------------------
% Environment for the items on the title page of a case study
% ---------------------------------------------------------------------

\newenvironment{inset}[1]{\noindent{\large\bf #1}\begin{list}%
{}{\setlength{\leftmargin}{\parindent}%
\setlength{\topsep}{-.1in}}\item }{\end{list}\vskip .4in}

% ---------------------------------------------------------------------
% Macros for little HOL sessions displayed in boxes.
%
% Usage: (1) \setcounter{sessioncount}{1} resets the session counter
%
%	 (2) \begin{session}\begin{verbatim}
%	      .
%	       < lines from hol session >
%	      .
%	     \end{verbatim}\end{session}   
%
%            typesets the session in a numbered box.
% ---------------------------------------------------------------------

\newlength{\hsbw}
\setlength{\hsbw}{\textwidth}
\addtolength{\hsbw}{-\arrayrulewidth}
\addtolength{\hsbw}{-\tabcolsep}
\addtolength{\hsbw}{-0.5in}
 % \addtolength{\hsbw}{0.25in}
\newcommand\HOLSpacing{13pt}

\newcounter{sessioncount}
\setcounter{sessioncount}{1}

\newenvironment{session}{\begin{center}
 \begin{tabular}{@{}|c@{}|@{}}\hline 
 \begin{minipage}[b]{\hsbw}
 \vspace*{-.5pt}
 \begin{flushright}
 \rule{0.01in}{.15in}\rule{0.3in}{0.01in}\hspace{-0.35in}
 \raisebox{0.04in}{\makebox[0.3in][c]{\footnotesize\sl \thesessioncount}}
 \end{flushright}

  \vspace*{-.25in}

 \begingroup\small\baselineskip\HOLSpacing}{\endgroup\end{minipage}\\ \hline 
 \end{tabular}
 \end{center}
 \stepcounter{sessioncount}}

% ---------------------------------------------------------------------
% Macro for boxed ML functions, etc.
%
% Usage: (1) \begin{boxed}\begin{verbatim}
%	        .
%	        < lines giving names and types of mk functions >
%	        .
%	     \end{verbatim}\end{boxed}   
%
%            typesets the given lines in a box.  
%
%            Conventions: lines are left-aligned under the "g" of begin, 
%	     and used to highlight primary reference for the ml function(s)
%	     that appear in the box.
% ---------------------------------------------------------------------

\newenvironment{boxed}{\begin{flushleft}
 \begin{tabular}{@{}|c@{}|@{}}\hline 
 \begin{minipage}[b]{\hsbw}
% \vspace*{-.55in}
 \vspace*{.06in}
 \begingroup\small\baselineskip\HOLSpacing}{\endgroup\end{minipage}\\ \hline 
 \end{tabular}
 \end{flushleft}}

% ---------------------------------------------------------------------
% Macro for unboxed ML functions, etc.
%
% Usage: (1) \begin{hol}\begin{verbatim}
%	        .
%	        < lines giving names and types of mk functions >
%	        .
%	     \end{verbatim}\end{hol}   
%
%            typesets the given lines exactly like {boxed}, except there's
%	     no box.  
%
%            Conventions: lines are left-aligned under the "g" of begin, 
%	     and used to display ML code in verbatim, left aligned.
% ---------------------------------------------------------------------

\newenvironment{hol}{\begin{flushleft}
 \begin{tabular}{c@{}@{}}
 \begin{minipage}[b]{\hsbw}
% \vspace*{-.55in}
 \vspace*{.06in}
 \begingroup\small\baselineskip\HOLSpacing}{\endgroup\end{minipage}\\
 \end{tabular}
 \end{flushleft}}

% ---------------------------------------------------------------------
% Emphatic brackets
% ---------------------------------------------------------------------

\newcommand\leb{\lbrack\!\lbrack}
\newcommand\reb{\rbrack\!\rbrack}

% ---------------------------------------------------------------------
% Snow watching lantern
% ---------------------------------------------------------------------

\newcommand\medlantern{{\makebox[3.652in][l]{
  \vbox to 3.875in{\vfill\special{psfile=../LaTeX/HOL_med.ps}}
  \vspace{-\baselineskip}}}}

% The stuff below does not work
% ---------------------------------------------------------------------
% New \part with JVT's snow watching lantern
% ---------------------------------------------------------------------

%\def\part{\cleardoublepage \thispagestyle{plain} \if@twocolumn \onecolumn
%\@tempswatrue \else \@tempswafalse \fi \hbox{}\vfil \secdef\@part\@spart} 


%\def\@part[#1]#2{\ifnum \c@secnumdepth >-2\relax \refstepcounter{part}
%\addcontentsline{toc}{part}{\thepart \hspace{1em}#1}\else
%\addcontentsline{toc}{part}{#1}\fi \markboth{}{}
% {\centering \ifnum \c@secnumdepth >-2\relax \huge\bf Part \thepart \par
%\vskip 20pt \fi \Huge \bf #1\par}\@endpart} 
%\def\@endpart{\medlantern\vfil\newpage \if@twoside \hbox{} \thispagestyle{empty} 
% \newpage 
% \fi \if@tempswa \twocolumn \fi} 
%\def\@spart#1{{\centering \Huge WONK \bf #1\par}\@endpart}



\long\def\suppress#1{}

\pagebreak

% *********************************************************************
% HOL Manual LaTeX Source: tutorial
% *********************************************************************
% Counter Peano used in logic.tex 
\newcounter{Peano} 
\setcounter{Peano}{1}


   \setlength{\unitlength}{1mm}		  % unit of length = 1mm
   \setlength{\baselineskip}{16pt}        % line spacing = 16pt

\ftaboveboxskip=5pt plus 2pt minus 2pt
\ftbelowboxskip=5pt plus 2pt minus 2pt
   
%   \pagenumbering{arabic}		 % arabic page numbers
%   \setcounter{page}{1}	         % start at page 1

   \label{getting-started}

% section General Introduction goes here
%  \include{new-preface}
% \chapter*{Preface}\markboth{Preface}{Preface}

	  
\cleardoublepage
\subsection{ABOUT THIS DOCUMENT} \label{intro}
\subsubsection{Purpose}

This document, one of several making up the user documentation for the ICL HOL system,  contains a tutorial introduction to the  system.
\subsubsection{Readership}

This document is intended to be the first item read by new users of of \HOL. It takes the form of a tutorial for learning the basic points of the structure and use of the system.


\subsubsection{Related Publications}
\begin{enumerate}
\item \DESCRIPTION: \cite{DS/FMU/IED/USR005}, a description of higher order logic,
the \SML\ programming language, and theorem proving methods in the \HOL\ system;
\item \REFERENCE: \cite{DS/FMU/IED/USR006}, the reference documentation of the tools available in \HOL.
\item Supplementary Guides: a collection of documents on special topics, most notably the Installation Guide, \cite{DS/FMU/IED/USR007}.
\end{enumerate}

 The first two of these documents will be referred to by the short names (in italicised text) given above.

\subsubsection{Area Covered}

The tutorial  is an introductory \HOL\ course which gives a `hands-on' feel for the way \HOL\ is used, but which does not systematically explain the underlying priciples. (The second document, \DESCRIPTION, explains the principles.)
After working through  this tutorial,
the reader should be capable of using \HOL\ for simple tasks, and should also be in a
position to approach the other two documents.


Once the \HOL\ system is installed on the user's workstation,  this tutorial should enable the potential \HOL\ user to become familiar with the following subjects:

\begin{enumerate}
\item The programming meta-language \SML, and how to interact
with it through an editor.  The description of  \SML\ given here is very brief, only intended to be sufficient to support the exposition of \HOL. For a more complete introduction to \SML\ the reader is referred to \cite{HARPER88} or \cite{WIKSTROM87}. 
\item The formal logic supported by 
the \HOL\ system (higher order logic) and its manipulation via \SML.
\item Forward proof and derived rules of inference.
\item Goal directed proof, and tactics and tacticals.
\end{enumerate}

The sections that follow cover these topics in the sequence shown above. This tutorial has been kept as short as possible so that
the installation of the system and
steps 1
to 4 can be mastered reasonably quickly. 

\subsubsection{Assumptions}

It is presumed  in what follows, if the reader is following the tutorial at a workstation and trying out the examples interactively,  that the installation procedure  been performed  successfully and that the user has available an installed HOL system.


\subsubsection{Acknowledgements}

These documents have drawn very heavily on \cite{SRI89B}, \cite{SRI89A} and \cite{SRI89C}

\cleardoublepage
\subsection{Contents}
\tableofcontents

\cleardoublepage
\section{GETTING STARTED} \label{install}

Throughout this tutorial, the sequences of user's interactions with the system and the system's responses are called `sessions'. 
All sessions in this documentation are displayed in numbered boxes.
This number indicates whether the session  is a new
one (when the number will be {\small\sl  1}) or  the continuation  of a session
started in an earlier box.  Consecutively numbered boxes are assumed to be part
of a single continuous session. 

 The UNIX prompt for the sessions is shown as 
{\small\verb+UNIX>+}, so lines beginning with this prompt  were typed  by the user.  On the user's actual system, the UNIX prompt may be different from what is shown here.


After entering  the  \HOL\  system  (see  below),  the  user  is  prompted 
 for an expression  or command of the  \HOL\ meta-language \SML. A line of consisting of such a promptfollowed by keystrokes typed by the user will be shown in this document thus:  


=SML
keystrokes typed by the user
=TEX  

The system response which follows the user's input will be shown thus:
=GFT
system response which follows the user's input
=TEX 

On the user's actual system, both the UNIX prompt and the \SML\ prompt will differ from what is shown here.

{\em At this point, a description of the use of the keyboard with the extended character-set  is to be provided.} 
\subsection{Entering the System}
The following shows an example of entering the \HOL\ system.   It should be noted that this example is specific to a particular vendor of the \SML\ system in use, and also to any local arrangements made during or after installation, for example, for the naming of UNIX directories. 

The HOL system is entered by a command at the UNIX prompt, invoking the \SML\ system and giving as parameter the name of a {\em database}.  The system supplied database is named (tbs). It contains  the \SML\ functions and other defined objects which constitute the \HOL\ system.

The reader may find it desirable to have to hand vendor-specific documentation on the \SML\ system in use.  This will show, for example, how to recover from a syntax error in input, how to return from \SML\ back to UNIX, or how to effect updates to the database.

     

\setcounter{sessioncount}{1}
\begin{session}

\begin{verbatim}
UNIX>  poly example.db   
\end{verbatim}

=GFT
here will appear a sign-on message from the Standard ML system, followed by a prompt
=TEX

=SML 
    (*  here the user types in Standard ML  *)

=GFT
here the response of the system will appear, followed by a prompt
=TEX

=SML 
    (*  here the user types in more  Standard ML  *)

=GFT
here another response of the system will appear, followed by a prompt
=TEX

\end{session}
\subsection{Leaving the System}

The following shows an example of leaving the ICL HOL system and returing to UNIX:
\begin{session}
=SML 

PolyML.quit();    
=TEX

\begin{verbatim}
UNIX>
\end{verbatim}

\end{session}


=TEX
\cleardoublepage
\section{INTRODUCTION TO STANDARD ML}
\label{ML}

This chapter is a brief introduction to the meta-language \SML.  The aim is just
to give the user an idea of what  it is  like to  interact with  the language.   For a more complete introduction to \SML\ the reader is referred to \cite{HARPER88} or \cite{WIKSTROM87}.

\subsection{Standard ML}

\SML\ is an interactive programming language.  When interacting directly with the system, (which is called `at the top level') one can
evaluate expressions and perform declarations. The former results in the
expression's value and type being printed, the latter in a value being
bound to a name.  
\subsection{Configuring the Screen}
The normal way to interact with \SML\ is to configure the workstation screen so that
there are two windows:
\begin{itemize}
\item An editor window into which \SML\ commands are initially typed and recorded.
\item A shell window (or non-UNIX equivalent) which is used to evaluate the
commands.
\end{itemize}


After typing a command into the edit (text) window it can be transferred to the
shell and evaluated in \HOL\ by `cut-and-paste'. The advantage of working through an editor is that
if the command contains an error, then the text can simply be edited and used again.  In addition, the editor
also records the commands in a file which can then be used again (via a batch load)
later. 

 The sessions in this tutorial are split into segments displayed in boxes with a
number in their top right hand corner (to indicate their position in the complete
session). 
The interactions in these boxes should be understood as occurring in
sequence.  For example, variable bindings made in earlier boxes are assumed
to persist to later ones.  

To enter the \HOL\ system one types
a command to UNIX, as explained above.  After entering the HOL system, a dialogue with  \SML\ and \HOL\ can begin, as shown in the following sessions.

\subsection{Dialogue}

\setcounter{sessioncount}{1}

\begin{session}
=SML 
1+1;
=TEX
=GFT
val it = 2 : int   
=TEX
\end{session}

This session shows an example of entering a \SML\ expression through the keyboard (that is, `at the top level'), which is then evaluated and the result displayed.  The  semicolon `\ml{;}'  is used to terminate a top-level phrase. The display of the result can be seen\footnote{with the version of Standard ML currently in use} to consist of:
\begin{itemize}
\item The letters 
=INLINEFT
val
=TEX
, indicating that a value is to follow.
\item A name for the value.  In this case the user has not supplied any name, having merely typed in the anonymous expression 
=INLINEFT
1+1
=TEX
, and so the system supplies the name $it$.   The value of the most-recently-entered anonymous expression at the top level can always be referred to as $it$.
\item  The symbol $=$. 
\item The value, in this case $2$.  
\item A colon followed by an indication of the type of the value.  In this case, the value 2 is of type integer, abbreviated to $int$.  The \SML\ type checker infers the type of expressions using methods invented by Robin Milner, \cite{MILNER78}. 
\end{itemize}

Here is another example.

\begin{session}
=SML 
1::[2,3,4,5];
=GFT
val it = [1, 2, 3, 4, 5] : int list   
=TEX

\end{session}


The \SML\ expression 
=INLINEFT
1::[2,3,4,5]
=TEX
{} has the form 
=INLINEFT
e1 op e2 
=TEX
where
\begin{description}
\item [{}]
=INLINEFT
e1
=TEX 
is the expression 
=INLINEFT
1
=TEX
{} (of which the value is the integer $1$), 
\item[{}]
=INLINEFT
e2
=TEX 
{} is the expression 
=INLINEFT
[2,3,4,5]
=TEX
{} (of which the value  is a list of four integers), and 
\item[{}]
=INLINEFT
op
=TEX
{} is the infixed operator 
=INLINEFT
::
=TEX
{}, which forms a list with  the  left-argument as head and right argument (a list) as tail. 
\end{description}

Other list processing functions include 
=INLINEFT
hd
=TEX
{} (take the head of a list), 
=INLINEFT
tl
=TEX
{} (take the tail of a list)  and 
=INLINEFT
is_nil
=TEX
{} (which tests for an empty list).
  
The type 
=INLINEFT
int list
=TEX
{} is the type of `lists of
integers'; 
=INLINEFT
list
=TEX
{} is a unary type operator.  The type system of \SML\
is very similar to the type system of the \HOL\ logic which is explained in
Chapter~\ref{HOLlogic}.



\begin{session}
=SML 
val L = it;
=GFT
val L = [1, 2, 3, 4, 5] : int list   
=TEX

=SML 
hd L;
=GFT
val it = 1 : int   
=TEX

=SML 
tl L;
=GFT
val it = [2, 3, 4, 5] : int list   
=TEX


=SML 
tl(tl(tl(tl it)));
=GFT
val it = [] : int list   
=TEX
\end{session}

Following standard $\lambda$-calculus usage, the application of a function
$f$ to an argument $x$ can be written without brackets as $f\ x$ (although
the more conventional $f$ \ml{(}$x$\ml{)} is also
allowed).  The expression $f\ x_1\ x_2\ \cdots\ x_n$ abbreviates the less
intelligible expression {\small\verb%(%}$\cdots${\small\verb%((%}$f\ 
x_1${\small\verb%)%}$x_2${\small\verb%)%}$\cdots${\small\verb%)%}$x_n$
(function application is left associative).

Declarations have the form 
=INLINEFT
val x1 = e1 and ...  and xn = en
=TEX 
{} and result in the value of
each expression 
=INLINEFT
ei
=TEX
{} being bound to the name
=INLINEFT
xi
=TEX
. 

\begin{session}
=SML 
val L1 = [1,2,3] and L2 = ["a","b","c"];
=GFT
val L1 = [1, 2, 3] : int list   val L2 = ["a", "b", "c"] : string list   
=TEX

\end{session}


\SML\ expressions like
=INLINEFT
"a", "b", "foo"
=TEX
{} etc  are {\it strings\/} and have type
=INLINEFT
string
=TEX
.  Any sequence of {\small ASCII} characters can be
written between the quotes. The function  
=INLINEFT
^
=TEX
{} concatenates two strings to form a single string.
\begin{session}
=SML 
"tog" ^ "ether";
=GFT
val it = "together" : string   
=TEX
\end{session}

An expression of the form
=INLINEFT
(e1, e2)
=TEX
{} evaluates to a
pair of the values of
=INLINEFT
e1
=TEX
{} and 
=INLINEFT
e2
=TEX
. If
=INLINEFT
e1
=TEX
{} has type 
=INLINEFT
Ó1
=TEX
{} and
=INLINEFT
e2
=TEX
{} has type 
=INLINEFT
Ó2
=TEX
{}  then
=INLINEFT
(e1, e2)
=TEX
{} has type
=INLINEFT
Ó1 * Ó2
=TEX
.  A tuple
=INLINEFT
(e1, ..., en)
=TEX
{} is  NOT in general  equivalent to
=INLINEFT
(e1, (e2, ..., en))
=TEX
.  The first and
second components of a pair (but not a tuple of length greater than two)  can be extracted with the \SML\ functions
=INLINEFT
fst
=TEX
{} and 
=INLINEFT
snd
=TEX
{} respectively. The i'th component of a tuple can be extracted with a function the name of which is of the form 
=INLINEFT
#i
=TEX
. 

\begin{session}
=SML 
(1, 2, (true, "abc"));
=GFT
val it = (1, 2, (true, "abc")) : int * int * (bool * string) 
=TEX

=SML 
#3 it;
=GFT
val it = (true, "abc") : bool * string   
=TEX

=SML 
snd it;
=GFT
val it = "abc" : string   
=TEX


\end{session}

\noindent The \SML\ expressions
=INLINEFT
true
=TEX
{} and 
=INLINEFT
false
=TEX
{} 
denote the two truth values of type {
=INLINEFT
bool
=TEX
.

\SML\ types can contain the {\it type variables\/}
=INLINEFT
'a
=TEX
,  
=INLINEFT
'b
=TEX
,  \etc\ Such types are called {\it
polymorphic\/}. A function with a polymorphic type should be thought of as
possessing all the types obtainable by replacing type variables by types.
This is illustrated below with the function 
=INLINEFT
zip
=TEX
.

Functions can be defined with declarations of the form 
=INLINEFT
fun f v1 ... vn = e
=TEX
{} where each 
=INLINEFT
vi
=TEX
is either a variable or a pattern build out of variables.  
The function 
=INLINEFT
zip
=TEX
{}, below, converts a pair of lists 
=INLINEFT
([x1, ... , xn],[y1, ... , yn])
=TEX
{} to a list of pairs
=INLINEFT
[(x1, y1), ...  ,(xn, yn)]
=TEX
.

\begin{session}


=SML 
fun zip (x,y) = 
	if is_nil x orelse is_nil y 
	then nil 
	else (hd x, hd y):: zip(tl x, tl y);
=GFT
val zip = fn : 'a list * 'b list -> ('a * 'b) list
=TEX

=SML 
zip([1,2,3],["a","b","c"]);
=GFT
val it = [(1, "a"), (2, "b"), (3, "c")] : (int * string) list  
=TEX
\end{session}

Functions may be {\it curried\/}, \ie\ take their arguments `one at a time'
instead of as a tuple.  This is illustrated with the function
=INLINEFT
curried_zip
=TEX
{} below:

\typeout{point 1}

\begin{session}
=SML 
fun curried_zip x y = zip(x,y);
=GFT
val curried_zip = fn : 'a list -> 'b list -> ('a * 'b) list
=TEX

=SML 
val zip_num  = curried_zip [0,1,2];
=GFT
val zip_num = fn : 'a list -> (int * 'a) list   
=TEX

=SML 
zip_num ["a","b","c"];
=GFT
val it = [(0, "a"), (1, "b"), (2, "c")] : (int * string) list
=TEX
\end{session}


\typeout{point 2}

Note that in the definition of
=INLINEFT
zip_num
=TEX
{} above the definition begins 
=INLINEFT
val zip_num 
=TEX
{} and not 
=INLINEFT
fun zip_num
=TEX
, because we do not wish to mention parameters on the left of the $=$, and thus cannot use the syntactic form 
=INLINEFT
fun name param ... = ... 
=TEX
.

\typeout{point 3}

Curried function are useful because they can be `partially applied' as
illustrated above by the partial application of 
=INLINEFT
curried_zip
=TEX
{} to 
=INLINEFT
[0,1,2]
=TEX
{} which results in the function
=INLINEFT
zip_num
=TEX
.

The evaluation of an expression either {\it succeeds\/} or {\it fails\/}.
In the former case, the evaluation returns a value; in the latter case the
evaluation is aborted and a failure string (usually the name of the
function that caused the failure) is passed to whatever invoked the
evaluation. This context can either propagate the failure (this is the
default) or it can {\it trap\/} it. These two possibilities are illustrated
below.  A failure trap is an expression of the form
=INLINEFT
e1 handle exception-name => e2
=TEX
. An expression of this form is evaluated by
first evaluating  
=INLINEFT
e1
=TEX
. If the evaluation succeeds (\ie\ doesn't fail) then
the value of
=INLINEFT
e1 handle exception-name => e2
=TEX
{} is the value of 
=INLINEFT
e1
=TEX
.  
=INLINEFT
e1
=TEX
{} fails in such a way as to raise the exception condition associated with 
=INLINEFT
exception-name
=TEX
, then the value of 
=INLINEFT
e1 handle exception-name => e2
=TEX
{} is obtained by evaluating 
=INLINEFT
e2
=TEX
.

Exceptions and their names can be system-defined or user-defined. If the name of a possible exception is not known beforehand, then "?" can be used as a general name, as illustrated in the 
example below.

\begin{session}

=SML 
hd[];
=GFT
Exception- Fail * An empty list has no head [hd.1002] * raised
=TEX

=SML 
hd [] handle ? => [];
=GFT
val it = [] : 'a list   
=TEX
\end{session}

The sessions  above  are enough  to give  a feel  for \SML.   
In the  next sections,  the logic  supported by  the \HOL\  system (higher order
logic) will be introduced, together with the tools in \SML\ for manipulating it.

=TEX
\cleardoublepage
\section{INTRODUCTION TO THE HOL LOGIC}
\label{HOLlogic}

The \HOL\  system  supports {\it  higher order  logic}.   This is  a version of
predicate calculus with three main extensions:

\begin{itemize}
\item Variables can range over functions and predicates
(hence `higher order').
\item The logic is {\it typed}.
\item There is no separate syntactic category of {\it formulae\/}
(terms of type \ml{bool} fulfil their role).
\end{itemize}

\subsection{Overview of higher order logic}

It is assumed  the reader  is familiar  with predicate  logic.   The syntax and
semantics of  particular  logical  system  supported  by \HOL\  is described in
detail in  \DESCRIPTION.   The table  below summarizes the
notation used.


\bigskip

\begin{center}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{3}{|c|}{ } \\
\multicolumn{3}{|c|}{\bf Terms of the HOL Logic} \\
\multicolumn{3}{|c|}{ } \\
{\it Kind of term} & {\it \HOL\ notation} & {\it Description} \\ \hline
                   &                      &                    \\ 
Truth              & $T$                  & {\it true}        \\ \hline
Falsity            &  $F$                 & {\it false}       \\ \hline
Negation           & ³$t$                 & {\it not}$\ t$       \\ \hline
Disjunction        & $t_1$²$t_2$          & $t_1\ ${\it or}$\ t_2$    \\ \hline
Conjunction        & $t_1$±$t_2$         & $t_1\ ${\it and}$\ t_2$     \\ \hline
Implication        & $t_1$´$t_2$         & $t_1\ ${\it implies}$\ t_2$ \\ \hline
Equality           & $t_1 \ = \ t_2$      & $t_1\ ${\it equals}$\ t_2$   \\ \hline
$\forall$-quantification & µ$x$·$t$            & {\it for\ all\ }$x: t$       \\ \hline
$\exists$-quantification & ¶$x$·$t$            & {\it for\ some\ }$x: t$       \\ \hline
$\hilbert$-term   & $ \hilbert \ x$·$t$        &  {\it an}$\ x\ ${\it such\ that:}$\ t$ \\ \hline
Conditional       & $(t$ {\it => } $t_1|t_2)$  & {\it if\ }$t${\it \ then\ }$t_1${\it\ else\ }$t_2$  \\ \hline
\end{tabular}
\end{center}\label{logic-table}

\bigskip


Terms of the \HOL\ logic are represented in \SML\ by an {\it abstract
type\/}\footnote{Abstract types appear to  the user  as primitive  types with a
collection of operations; they are described in 
\DESCRIPTION}  called 
=INLINEFT
TERM
=TEX
.   They are represented as character strings which are input, not between the  usual quotations symbols but  rather  between
the symbols 
=INLINEFT
¬ 
=TEX
{} and
=INLINEFT
®
=TEX
.   For example,  the expression  
=INLINEFT
¬ x ± y ´ z® 
=TEX
{} evaluates in \SML\ to a term representing 
=INLINEFT
x ± y ´ z 
=TEX
. Terms can be manipulated by various built-in \SML\ functions.   For  example, the \SML\ function 
=INLINEFT
dest_´
=TEX
{}  with  \SML\  type 
=INLINEFT
TERM -> TERM * TERM
=TEX
{} splits an implication into  a pair  of terms  consisting of  its antecedent and
consequent, and the \SML\ function 
=INLINEFT
dest_±
=TEX
{} of  type 
=INLINEFT
TERM -> TERM * TERM
=TEX
{} splits a conjunction into its two conjuncts.
\typeout{point 3.001}
\setcounter{sessioncount}{1}
\begin{session}

=SML 
¬x±y´z®;
=TEX
=GFT
val it = ¬x ± y ´ z® : TERM   
=TEX

=SML 
dest_´ it; 
=GFT
val it = (¬x ± y®, ¬z®) : TERM * TERM   
=TEX

=SML 
dest_± (fst it);
=GFT
val it = (¬x®, ¬y®) : TERM * TERM   
=TEX
\end{session}

Terms of the \HOL\ logic are quite similar in appearance to \SML\ expressions, but the distinction must be carefully observed.  Indeed, terms of the logic have types  in a way which is similar  to the way in which
\SML\ expressions have types.   For example, 
=INLINEFT
¬1®
=TEX
{} is  a \SML\ expression with \SML\ type 
=INLINEFT
TERM
=TEX
.  The \HOL\ type of this term is 
=INLINEFT
:î
=TEX
, the type of the natural numbers. 

The types of \HOL\ terms form a \SML\ type called 
=INLINEFT
TYPE
=TEX
. Expressions having the form
=INLINEFT
¬: ....® 
=TEX
{} evaluate to logical types.  The built-in function  
=INLINEFT
type_of
=TEX
{} has \SML\ type 
=INLINEFT
TERM -> TYPE
=TEX
{} and returns the logical type of a term.

\typeout{logic point 5}

\begin{session}
=SML 
¬(1,2)®;
=GFT
val it = ¬(1, 2)® : TERM   
=TEX

=SML 
type_of it;
=GFT
val it = ¬:î ¸ î® : TYPE   
=TEX

=SML 
(¬1®, ¬2®);
=GFT
val it = (¬1®, ¬2®) : TERM * TERM
=TEX

=SML 
type_of (fst it);
=GFT
val it = ¬:î® : TYPE   
=TEX

\end{session}

\typeout{logic point 6}


To emphasise the distinction between between   the \SML\ types of \SML\ expressions and the logical types of \HOL\ terms 
, the former will be referred to as {\it meta-language types\/} and the latter as {\it object language types\/}.

\index{meta-language} \index{object language}

For example, 
=INLINEFT
¬(1,T)®
=TEX
{} is a \SML\ expression that has meta-language type 
=INLINEFT
TERM
=TEX
{} and evaluates to a term with object language type
=INLINEFT
¬:î ¸ BOOL®
=TEX
.  The expression  
=INLINEFT
 ¬:î ¸ BOOL®
=TEX
{} itself denotes a value of metalanguage type 
=INLINEFT
TYPE
=TEX
.



\begin{session}
=SML 
¬(1,T)®;
=GFT
val it = ¬(1, T)® : TERM   
=TEX

=SML 
type_of it;
=GFT
val it = ¬:î ¸ BOOL® : TYPE   
=TEX

=SML 
¬:î ¸ BOOL®; 
=GFT
val it = ¬:î ¸ BOOL® : TYPE   
=TEX
\end{session}


\typeout{logic point 7}

\HOL\ terms can be input using explicit {\it quotation\/}, as above, using 
=INLINEFT
¬ 
=TEX
{} and 
=INLINEFT
® 
=TEX
{} for quotation marks,  or they can be constructed using \SML\ constructor functions. The function
=INLINEFT
mk_var
=TEX
{}  constructs a variable from a string and a type.  In the example below, three  terms are constructed, each representing a single object-language variable  of type  
=INLINEFT
BOOL
=TEX
, and  metalanguage names  are chosen for the terms  to  coincide with the names of the object-language variables.  These are used later.

\begin{session}
=SML 
val x = mk_var("x",¬:BOOL®) 
and y = mk_var("y",¬:BOOL®)
and z = mk_var("z",¬:BOOL®);
=GFT
val x = ¬x® : TERM 
val y = ¬y® : TERM  
val z = ¬z® : TERM   
=TEX
\end{session}

\typeout{logic point 8}

The constructors 
=INLINEFT
mk_±
=TEX
{} and  
=INLINEFT
mk_´
=TEX
{} construct conjunctions and implications respectively.

\begin{session}
=SML 
val t = mk_´(mk_±(x,y),z);
=GFT
val t = ¬x ± y ´ z® : TERM   
=TEX

\end{session}

\subsection{Terms}

There are only four different kinds of terms:
\begin{enumerate}
\item Variables.
\item Constants.
\item Function applications: 
=INLINEFT
¬t1 t2®
=TEX
\item $\lambda$-abstractions: 
=INLINEFT
¬Ì x · t ®
=TEX
.
\end{enumerate}
\index{Terms, four different kinds of}

Both variables and constants have a name and a type; the difference is that
constants cannot be bound by quantifiers, and their type is fixed when they are
declared (see below). The type checking algorithm uses the types of constants to
infer the types of variables in the same quotation. If there is not enough type
information to constrain the assignment of a type, then an assignment of the most general type, that is,   involving a {\em type-variable}, will result:


\begin{session}
=SML 
¬³x®;
=GFT
val it = ¬³ x® : TERM   
=TEX

=SML 
dest_³ it;
=GFT
val it = ¬x® : TERM   
=TEX

=SML 
type_of it;
=GFT
val it = ¬:BOOL® : TYPE   
=TEX

=SML 
¬x®;
=GFT
val it = ¬x® : TERM   
=TEX

=SML 
type_of it;
=GFT
val it = ¬:'a® : TYPE   
=TEX
\end{session}

In the first case, the \HOL\ type checker  used the  known type 
=INLINEFT
BOOL ­ BOOL
=TEX
{} of 
=INLINEFT
³
=TEX
{} to  deduce  that  the  variable 
=INLINEFT
x
=TEX
{} must  have  type
=INLINEFT
BOOL
=TEX
.  In the second case, it assigns the most general  type to
=INLINEFT
x
=TEX
.      The    `scope'  of type  information for type
checking is a single quotation, so a  type in  one quotation  cannot effect the
type checking of another.     If there  is not enough
contextually-determined type information to resolve the types  of all variables
in a quotation, then it may be necessary to explicitly indicate  the required types
by using 
=INLINEFT
¬term:type®
=TEX
{} as illustrated below.

\typeout{logic point 9}

\begin{session}

=SML 
¬x:î®;
=GFT
val it = ¬x® : TERM 
=TEX

=SML 
type_of it;
=GFT
val it = ¬:î® : TYPE   
=TEX

\end{session}

\typeout{logic point 9.1}

Functions have types of the form 
=INLINEFT
Ó1­Ó2
=TEX
, where 
=INLINEFT
Ó1
=TEX
{} and
=INLINEFT
Ó2
=TEX
{} are the types of the domain and range of the function, respectively.


Before considering an example of the types of functions, an aside is appropriate on  a purely syntactic matter.
 Functions may be defined with a special syntactic status, such as being  an infix operator, in the case of 
=INLINEFT
+
=TEX
{} or  
=INLINEFT
±
=TEX
,  or having non-standard precedence, in the case  of 
=INLINEFT
³
=TEX
.  In such cases, putting  
=INLINEFT
$ 
=TEX
{} in front of the name of the function causes the parser to ignore any special syntactic status it may have.   
 This means that the naked symbol 
=INLINEFT
±
=TEX
{} is not  in itself a syntactically well-formed expression,  because it denotes the application of the function to arguments which are missing. 
However the expression 
=INLINEFT
$±
=TEX
{} is well-formed in itself, denoting a function, and it can be applied to arguments.

\begin{session}

=SML 
¬±®;
=GFT
Syntax error in: ¬  <?> ± 
± is not expected after ¬ 
Exception- Fail * Syntax error [HOL-Parser.19000] * raised=TEX

=SML 
¬$±®;
=GFT
val it = ¬$±® : TERM   
=TEX

=SML 
 type_of it;
=GFT
val it = ¬:BOOL ­ BOOL ­ BOOL® : TYPE   
=TEX

=SML  
¬$± t1 t2®;
=GFT
val it = ¬t1 ± t2® : TERM   
=TEX
\end{session}

\typeout{logic point 9.15}

\begin{session}

=SML 
type_of ¬Ìx·x+1®;
=TEX
=GFT
val it = ¬:î ­ î® : TYPE   
=TEX
\end{session}



\typeout{logic point 9.2}

The  session below illustrates
this; it also illustrates object language versus meta-language types. 



\begin{session}
=SML 
¬(x+1), (t1´t2)®;
=GFT
val it = ¬(x + 1, t1 ´ t2)® : TERM 
=TEX
 
=SML 
type_of it;
=GFT
val it = ¬:î ¸ BOOL® : TYPE   
=TEX

=SML 
(¬x=1®, ¬t1´t2®);
=GFT
val it = (¬x = 1®, ¬t1 ´ t2®) : TERM * TERM   
=TEX
=SML 
(type_of(fst it), type_of(snd it));
=GFT
val it = (¬:BOOL®, ¬:BOOL®) : TYPE * TYPE   
=TEX
\end{session}

\typeout{logic point 9.3}

\noindent The types of constants are declared in {\it theories}; this is described
in Section~\ref{theories}.

An application
=INLINEFT
t1 t2
=TEX
{} is badly typed if 
=INLINEFT
t1 
=TEX
{} is not a function:

\typeout{logic point 10}

\begin{session}
=SML 
¬1 2®;
=GFT
Type error in ¬1 2®
The operator must have type Ó ­ Ô
Cannot apply ¬1:î®
          to ¬2:î®
Exception- Fail * Type error [HOL-Parser.16000] * raised
=TEX

\end{session}

or if it is a function, but 
=INLINEFT
t2
=TEX
{} is not in its range:

\begin{session}

=SML 
¬³1®;
=GFT
Type error in ¬³ 1®
The operator and the operand have incompatible types
Cannot apply ¬³:(BOOL­BOOL)®
          to ¬1:î®
Exception- Fail * Type error [HOL-Parser.16000] * raised
=TEX

\end{session}

\typeout{logic point 11}



Lambda-terms, or $\lambda$-terms, denote functions.  For example,
=INLINEFT
¬Ìx· x+1®
=TEX
{} is a term that denotes the function $n\mapsto n{+}1$.

\begin{session}
=SML  
¬Ìx · x+1®;
=GFT
val it = ¬Ì x· x + 1® : TERM   
=TEX

=SML  
type_of it;
=GFT
val it = ¬:î ­ î® : TYPE   
=TEX

\end{session}

\typeout{logic point 12}

\subsection{Boolean Terms, Theorems and  Sequents}

So far, in the language of \HOL\ terms, we have seen terms of different object-language types, including  those of object-language type 
=INLINEFT
¬:BOOL®
=TEX
.

The \HOL\ system supports a process of  inference which results in the production of {\em theorems}.  Theorems are objects of metalanguage type 
=INLINEFT
THM
=TEX
. Terms are not theorems, that is, the metalanguage types=INLINEFT
TERM
=TEX
{} and 
=INLINEFT
THM
=TEX
{} are distinct. The form taken by  a theorem in this system of inference is not simply as  a boolean-valued term but rather as a composite of:
\begin{itemize}
\item  a list of assumptions, each of which represents a boolean-valued term
\item  a conclusion, which represents a single boolean-valued term.  
\end{itemize}

The following session produces an example  of a theorem  to illustrate this structure of assumptions and conclusion.   The example is produced by means which are yet to be described, but will be covered in following sections.  


\begin{session}
=SML 
tac_proof (([¬x=y®, ¬y=z®], ¬x=z®), (asm_rewrite_tac[]));
=GFT
val it = x = y, y = z ô x = z : THM   

=TEX
\end{session}

It can be seen that the turnstile symbol, 
=INLINEFT
ô
=TEX
, separates assumptions from conclusion.  This theorem can be understood as meaning: on the assumption that x=y and the further assumption  that y=z, it may be concluded that x=z.   The theorem is about the relationship between assumptions and conclusion (that the latter follows from the former).  The ``truth'' of the theorem is the truth of an assertion about what follows from what.

It can be seen that the turnstile symbol, \ml{ô}, separates assumptions from conclusion.



Strictly speaking, all theorems in this system are about the relationship between assumptions and conclusions, but in practice  many theorems have no assumptions.  Here is another example of a theorem produced by means yet to be described:

\begin{session}
=SML 
refl_conv ¬x®;
=GFT
val it = ô x = x : THM   
=TEX
\end{session}

This can be understood as meaning ``without making any assumptions, it may be concluded  that x=x''.   Here the list of assumptions mentioned above is  present, but is empty and so nothing is displayed for it.

Terms can be constructed at will, (subject only to the constraint of being well-typed.)
 On the other hand, theorems can be constructed only by a proof which appeals to the rules of inference supported by the system.\index{theorems, construction only by proof}   The soundness of the system of inference and the correctness of the implementation guarantee the  ``truth'' (theoremhood) of any theorems produced, and ensure that theorems can only be produced by the prescribed system of inference.

Objects structured according to the pattern described above as a list of assumptions followed by a conclusion are called ``sequents''.  In this sense, theorems may be called sequents, so that the \HOL\ system of inference is described as a sequent calculus; see e.g. \cite{SRI89B}.  

The system  supports ``sequents''  by providing, as an abbreviation for 
=INLINEFT
TERM list * TERM
=TEX
,  the name
=INLINEFT
SEQ
=TEX
.  Sequents  in this other sense are, needless to say, NOT theorems, just data-structures.  Their usefulness is (as shown in the example of producing the first theorem above) in convenience in stating goals for a proof process, so much so that the system also supports the abbreviation \ml{GOAL} for the same type.   This is illustrated in the next session, where the same object is ascribed a type which is reported in three different ways. 

\typeout{logic point 12.1}  

\begin{session}

=SML 
val s =([¬x=y®, ¬y=z®], ¬x=z®);
=GFT
val s = ([¬x = y®, ¬y = z®], ¬x = z®) : TERM list * TERM 
=TEX
=SML 
s:SEQ;
=GFT
val it = ([¬x = y®, ¬y = z®], ¬x = z®) : SEQ   
=TEX
=SML 
s:GOAL;
=GFT
val it = ([¬x = y®, ¬y = z®], ¬x = z®) : GOAL  
=TEX
\end{session}



\typeout{logic point 13}

\subsection{Theories}
\label{theories}  \index{theories, in HOL}
\subsubsection{Introduction}

The result of a session with the \HOL\ system is an object called a {\it
theory\/}.  This object is closely related to what a logician would call a
theory, but there are some differences arising from the needs of mechanical
proof. 
 A \HOL\ theory, like a logician's theory, contains sets of types,
constants, definitions and axioms.  In addition, however, a \HOL\ theory
contains an explicit list of theorems that have been proved from the axioms
and definitions.
 Logicians normally do not need to distinguish theorems that
have actually been proved from those that could be proved, hence they do not
normally consider sets of proven theorems as part of a theory; rather, they
take the theorems of a theory to be the (often infinite) set of all
consequences of the axioms and definitions. 
 Another difference between
logicians' theories and \HOL\ theories is that, for logicians, theories are
relatively static objects, but in \HOL\ they can be thought of as potentially
extendable. For example, the \HOL\ system provides tools for adding to
theories and combining theories. 
 A typical interaction with HOL consists in
combining some existing theories, making some definitions, proving some
theorems and then saving the resulting new theory.

The purpose of the \HOL\ system is to provide tools to enable well-formed
theories to be constructed.  All the theorems of such theories are logical
consequences of the definitions and axioms of the theory.  The \HOL\ system
ensures that only well-formed theories can be constructed by allowing
theorems to be created by {\it formal proof\/} only. 


A theory is stored in the \HOL\ system in what is called a theory database, where a theory database itself is represented by files in the filing system of the workstation.  Thus a theory database is what is stored between sessions of interaction with the \HOL\ system.

Theories are related  to each other by a hierarchy so as  to represent sequences of extensions of
an initial theory called \ml{HOL}. (Check this).  By  ``extension'' is meant that one theory may make use of definitions, axioms or theorems of another, ``parent'',  theory, and thus in effect incorporate them into itself.
Each theory  contains
some types, constants, axioms and
theorems, together with
pointers to other theories, its {\it parents\/}. 
This collection of reachable theories is called the {\it
ancestry\/} of the theory. Axioms, definitions
and theorems are named in the \HOL\ system by two strings: the name of the theory
 where they are stored, together with a name within that theory for the particular axiom, definition or theorem,  supplied by the
user.

Specifically,
axioms, definitions and theorems
are named by a pair of strings $\langle thy,name\rangle$ 
where $thy$ is the name of the
theory current when the item was declared and $name$
is a specific name supplied by the user (see the functions
=INLINEFT
new_axiom
=TEX
,  
=INLINEFT
new_definition
=TEX
{} \etc\ below).

A typical piece of work with the \HOL\ system consists in a number of sessions. In
the first of these a new theory, ${\cal T}$ say, is created by extending existing
theories with a number of definitions.   In subsequent
sessions this theory is extended by proving new theorems which will become part of 
the theory ${\cal T}$. The logical meaning of these sessions is that a new
extended version of ${\cal T}$ is created which replaces the old version.  Subsequent
pieces of work can build on (\ie\ extend) the definitions and theorems of ${\cal
T}$ by making ${\cal T}$ a parent of  new theories.

In principle a whole hierarchy of theories can be stored in a single theory database. 
 In practice however it may be more convenient to distribute a theory-hierarchy over several databases,  themselves organised into a hierarchy.  
For example, such an arrangement would allow a common database to be read-only,  and others deriving from it to be, in the course of  development,  updatable. 
 Similar arrangements are possible  within a single database: an individual theory may have a status of ``locked'' to prevent casual changes. 
 Thus facilities for the management of theories are available both at the level of the individual theory and at the level of the database. No more will be said on this topic in this tutorial, which will proceed on the assumption of a single database.

At any stage in the development of a theory, a stored record of what has been achieved so far is obtained by causing an update to the  current database, or ``committing'' the whole current state of the \HOL\ system to the database.  This is effected by issuing the single \SML\ command which, in the case of the system in use at the time of writing, is,  
=INLINEFT
PolyML.commit();
=TEX
. 

\typeout{logic point 14}

There is always a {\it current theory\/}; its name can be discovered by the function
=INLINEFT
get_current_theory_name
=TEX
.  This function maps the value called {\em unit}, written
=INLINEFT
()
=TEX
{} in \SML, to a string giving the name of the current theory.
Thus the \SML\ expression
=INLINEFT
get_current_theory_name ()
=TEX
{} evaluates to a string giving the name of the current
theory.  Initially the  current theory is
called 
=INLINEFT
hol
=TEX
.   So evaluating 
=INLINEFT
get_current_theory_name()
=TEX
{} immediately after initiating a \HOL\ session gives a value dependent upon the state of the database in use, as is can be seen in the session shown below:

\typeout{logic point 15}

\setcounter{sessioncount}{1}
\begin{session}
=SML 
get_current_theory_name();
=GFT
val it = "hol" : string   
=TEX
\end{session}

One more point remains to be made.  It has been explained that the state of a \HOL\ session can be saved,  and then retrieved on a later occasion.  Within the state of the \HOL\ session, there will be theorems and other objects: axioms, definitions, constants and so on.   Now a  theorem, for example,  can be associated with a name, in the state of the \HOL\ session, in either or both of two ways, which are distinct.

Firstly, a theorem is a \SML\ value like any other, in that it can be associated with a \SML\ name by the familiar process, seen many times above, of making a declaration:

\begin{session} 
=SML 
val thm99 = refl_conv ¬x®;
=GFT
val thm99 = ô x = x : THM   
=TEX
\end{session}

The value, and the association with the name, will survive the saving and retrieving of the state of the \HOL\ session.

Secondly,  the current theory is represented by a data structure within the state of the current session.   This data structure has no \SML\ name, but is instead provided with a number of access functions by which its contents may be inspected, extracted, and updated. 
 For example, the function 
=INLINEFT
print_theory
=TEX
{} enables the content of the theory to be inspected.  There is a function 
=INLINEFT
save_thm
=TEX
{} which takes two arguments, a string and a theorem, and causes the theorem to be saved in the data structure which is the theory and  to be stored within the theory under the name given by the string. 
The theorem can be recovered from the theory by another access function, 
=INLINEFT
get_thm
=TEX
, which takes as arguments the  theory name (the current theory can be referred to by the name
=INLINEFT
"-"
=TEX
) and the name under which the theorem was stored. 
 Note that there is no necessary connection between this string and the name of any \SML\ variable used to hold a theorem.  To emphasize the point, note that the string need not be a well-formed name.
\index{theorems, saving  with \ml{save\_thm}}  
\index{theorems, retrieving with \ml{get\_thm}} 
\index{theories, viewing with \ml{print\_theory}}

\begin{session}
=SML 
save_thm ("theorem of 5 September 91", thm99);
=GFT
val it = ô x = x : THM   
=TEX

=SML 
get_thm "-" "theorem of 5 September 91";
=GFT
val it = ô x = x : THM 
=TEX
\end{session} 

\subsubsection{Example of Developing a New Theory}

In this section an example is given of developing a new theory, which is chosen to be a treatment of Peano's postulates as axioms for the natural numbers.    It is to be noted that there is already a theory built into HOL, called 
=INLINEFT
î
=TEX
, which covers natural numbers and arithmetic, (in which Peano's postulates  are  in  fact  derived  theorems rather  than postulated as axioms).  To emphasize that this example theory is just an example, and has no relation to
 =INLINEFT
î
=TEX
{} except  superficial resemblance, the example theory will be called 
=INLINEFT
Peanissimo
=TEX
.  

Executing  
=INLINEFT
new_theory "thy"
=TEX
{} creates a new  theory called  
=INLINEFT
thy
=TEX
; it fails if there already exists a theory so named in the current theory hierarchy; 
for a description of  which, see  the appropriate  section of  
\DESCRIPTION).


\begin{session}
=SML 
new_theory "Peanissimo";
=GFT
val it = () : unit
=TEX
\end{session}

\typeout{point 16}

This starts a theory called 
=INLINEFT
Peanissimo
=TEX
,  which is to be  made into a
theory containing Peano's postulates as axioms for the natural
numbers. These postulates, stated informally, are:

\begin{list}{{\small\bf P\arabic{Peano}}}{\usecounter{Peano}
\setlength{\leftmargin}{12mm}
\setlength{\rightmargin}{7mm}
\setlength{\labelwidth}{6mm}
\setlength{\labelsep}{2mm}
\setlength{\listparindent}{0mm}
\setlength{\itemsep}{14pt plus1pt minus1pt}
\setlength{\topsep}{3mm}
\setlength{\parsep}{0mm}}

\item There is a number which we will call $zero$.
\item There is a function  which we will call $successor$  such that 
if $n$ is a number then  the successor of $n$ is a number.
\item $zero$ is not the successor of any number.
\item If two numbers have the same successor then they are equal.
\item If a property holds of $zero$, and if whenever it holds of a number then it
also holds of the successor of that number, then the property holds of all
numbers. This postulate is called {\it Mathematical Induction}.
\end{list}

To formalize this in \HOL\ a new type is introduced called 
=INLINEFT
nat
=TEX
:

\index{types, object-language, introducing with \ml{new\_type}}

\typeout{point 17}

\begin{session}
=SML 
new_type ("nat", 0);
=GFT
val it = ¬:nat® : TYPE 
=TEX
\end{session}

In general 
=INLINEFT
new_type ("op" n) 
=TEX
{} makes
=INLINEFT
op
=TEX
{} a new $n$-ary type operator in the current theory. 
Constant types  (such as
=INLINEFT
BOOL
=TEX
{} or 
=INLINEFT
î
=TEX
) are regarded as degenerate type operators with no arguments, thus
the new type 
=INLINEFT
nat
=TEX
is declared to be a $0$-ary type operator. An example of a $1$-ary type operator is  
=INLINEFT
LIST
=TEX
, occurring in for example  
=INLINEFT
¬[a;b;c] : î LIST®;
=TEX
{} and an example of a 2-ary type operator is
=INLINEFT
¸
=TEX
{} occurring in for example 
=INLINEFT
¬(x,y) : BOOL ¸ î®;
=TEX
. 


The axioms {\small\bf P1} and {\small\bf P2} can now be formalized by declaring
two new constants of type 
=INLINEFT
nat
=TEX
{} to represent $zero$ and $successor$. 

Evaluating 
=INLINEFT
new_const("c", Ó)
=TEX
{} makes 
=INLINEFT
c
=TEX
{} a new constant of type 
=INLINEFT
Ó
=TEX
{} in the current theory.
This fails if there already exists a constant named  
=INLINEFT
c
=TEX
{} in the current theory (or a parent  of the current theory).


\typeout{point 19}

\begin{session}
=SML 
new_const ("zero", ¬:nat®);
=GFT
val it = ¬zero® : TERM
=TEX

=SML 
new_const ("successor", ¬:nat­nat®);
=GFT
val it = ¬successor® : TERM
=TEX
\end{session}



The \HOL\ type checker ensures that {\small\bf P1} and {\small\bf P2} hold.
{\small\bf P3} is now asserted as an axiom:
\index{axioms, introducing with \ml{new\_axiom}}

\begin{session}
=SML 
new_axiom(["P3"], ¬µn· ³(zero = successor n)® );
=GFT
val it = ô µ n· ³ zero = successor n : THM
=TEX
\end{session}

\noindent This creates an axiom in the current theory (\ie\ in 
=INLINEFT
Peanissimo
=TEX
{} called
=INLINEFT
P3
=TEX
. Axiom  
=INLINEFT
P4
=TEX
{} can be declared similarly:

\typeout{point 20}

\begin{session}

=SML 
new_axiom(["P4"], ¬µm n ·(successor m = successor n) ´ (m = n)®);
=GFT
val it = ô µ m n· successor m = successor n ´ m = n : THM
=TEX

\end{session}

\typeout{point 20.5}

The final Peano axiom is Mathematical Induction:

\begin{session}
=SML 
new_axiom(["P5"],¬µ P· P zero ± (µ n · P n ´ P(successor n)) ´ (µn· P n)®);
=GFT
val it = ô µ P· P zero ± (µ n· P n ´ P (successor n)) ´ (µ n· P n) : THM   
=TEX
\end{session}

\typeout{point 21}
\clearpage
To inspect the theory, the function 
=INLINEFT
print_theory
=TEX
{} can be used:

\begin{session}
=SML 
print_theory "-";
=TEX
\end{session}

\typeout{ page 20 a}

\begin{session}
=GFT
 === The theory Peanissimo ===

--- Parents ---

                hol

--- Constants ---

zero            nat
successor       nat ­ nat

--- Types ---

nat

--- Axioms ---

P3              ô µ n· ³ zero = successor n
P4              ô µ m n· successor m = successor n ´ m = n
P5              ô µ P· P zero ± (µ n· P n ´ P (successor n)) ´ (µ n· P n)

 === End of listing of theory Peanissimo ===
val it = () : unit   
=TEX
\end{session}


\typeout{point 22}

To end the session and make an  update to the database in use, recording all the work of the session including the new theory, the new theory, the current state of the session is {\em committed} to the database, after which an exit can be made back to UNIX:

\begin{session}

=SML 
PolyML.commit();
=GFT
10104 bytes copied
example.db:3670016 bytes
Closing example.db now
Opening example.db
Opening /hat/nih/bin/poly_2.04/ML_dbase
val it = () : unit   
=TEX

=SML 
PolyML.quit();
=GFT
UNIX>
=TEX
\end{session}

\noindent The function 
=INLINEFT
quit
=TEX
{} exits from the \HOL\ system.

The preceding session set up a theory called 
=INLINEFT
Peanissimo
=TEX
. It is usual to include in `Peano arithmetic' axioms defining addition and multiplication.
To do this a new session can be started and the theory further developed.  

\begin{session}

\begin{verbatim}
UNIX>  poly example.db
\end{verbatim}

=GFT
      .... sign-on message ....
=TEX

=SML 
get_current_theory_name();
=GFT
val it = "Peanissimo" : string   
=TEX

\end{session}

\noindent The two new axioms can now be added, but first constants 
 must  be  declared  to  represent  addition  and  multiplication.   Let us choose the names 
=INLINEFT
pplus
=TEX
{} and
=INLINEFT
ptimes
=TEX
{} respectively for these.  These can  be declared as
infixes using 
=INLINEFT
declare_infix 
=+TEX
{} as well as 
=INLINEFT
new_constant
=TEX
.

\index{fixity, of constants, declaring} \index{constants, introducing with \ml{new\_const}}

\begin{session}
=SML 
declare_infix (40, "pplus"); declare_infix (41, "ptimes");
=GFT
val it = () : unit   
val it = () : unit
=TEX

=SML 
new_const ("pplus", ¬:nat­nat­nat®);
new_const ("ptimes", ¬:nat­nat­nat®);

=GFT
val it = ¬$pplus® : TERM   
val it = ¬$ptimes® : TERM
=TEX



\end{session}

Constants declared with 
=INLINEFT
new_infix
=TEX
{} must have a type of the form
\ml{$\sigma_1$­$\sigma_2$­$\sigma_3$}.

Axioms defining 
=INLINEFT
pplus
=TEX
{} and \
=INLINEFT
ptimes
=TEX
{} can now be given.

\begin{session}
=SML 
new_axiom(["pplus_def"],
   ¬(µn· (zero pplus n) = n) ± 
    (µm n·((successor m) pplus n) = successor (m pplus n) )® );
=GFT
val it = ô (µ n· (zero pplus n) = n) ±
  (µ m n· (successor m pplus n) = successor (m pplus n)) : THM
=TEX

=SML 
new_axiom(["ptimes_def"],
   ¬(µn· (zero ptimes n) = zero) ± 
    (µm n·((successor m) ptimes n) = ((m ptimes n) pplus n)  )® );
=GFT
val it = ô (µ n· (zero ptimes n) = zero) ±
  (µ m n· (successor m ptimes n) = (m ptimes n pplus n)) : THM
=TEX
 
\end{session}

The theory 
=INLINEFT
Peanissimo
=TEX
{} has now been extended to contain the new definitions.

This example shows how a theory is set up. How to prove consequences of axioms and
definitions is described later. The \HOL\ system contains a built-in
theory of numbers called 
=INLINEFT
î
=TEX
{} which contains Peano's postulates and  the definitions of addition 
=INLINEFT
(+)
=TEX
{} and multiplication 
=INLINEFT
(*)
=TEX
{} amongst others.
In fact, Peano's 
postulates are theorems not axioms in the theory 
=INLINEFT
î
=TEX
. The  constants
=INLINEFT
0
=TEX
{} and 
=\ml{Suc} (corresponding to \ml{zero} and \ml{successor} in \ml{Peanissimo}) are
{\it defined\/} in terms of purely logical notions.
In \HOL, {\it definitions\/} are a special kind of axiom that are
guaranteed to be consistent. The commonest (but not only) form of a definition is: 

\[f\ x_1\ \ldots\ x_n = t\]

where $f$ is declared to be a new constant satisfying this
equation (and $t$ is a term whose free variables are included in the set
$\{x_1,\ldots,x_n\}$).  Such definitions cannot be recursive because, for
example: 

\[ f\ x = (f\ x)+1 \]

\noindent would imply $0=1$ (subtract $f\ x$ from both sides)
and is therefore inconsistent. An example of a definition is:

\begin{session}
=SML 
simple_new_defn  (["Double_def"], "Double", ¬Ìx· (x pplus x)®);
=GFT
val it = ô Double = (Ì x· x pplus x) : THM
=TEX

\end{session}

\noindent This definition both declares \ml{Double} as a new constant of the
appropriate type and asserts the defining equation as a definitional axiom.  The theory is now shown by:

\typeout{point 050}
\clearpage
\begin{session}
=SML 
print_theory "-";
=GFT
 === The theory Peanissimo ===

--- Parents ---

                hol

--- Constants ---

zero            nat
successor       nat ­ nat
$pplus          nat ­ nat ­ nat
$ptimes         nat ­ nat ­ nat
Double          nat ­ nat

--- Types ---

nat

--- Fixity ---

Infix 40:       pplus
Infix 41:       ptimes

--- Axioms ---

P3              ô µ n· ³ zero = successor n
P4              ô µ m n· successor m = successor n ´ m = n
P5              ô µ P· P zero ± (µ n· P n ´ P (successor n)) ´ (µ n· P n)
pplus_def       ô (µ n· (zero pplus n) = n) ±
                  (µ m n· (successor m pplus n) = successor (m pplus n))
ptimes_def      ô (µ n· (zero ptimes n) = zero) ±
                  (µ m n· (successor m ptimes n) = (m ptimes n pplus n))

--- Definitions ---

Double_def      ô Double = (Ì x· x pplus x)

 === End of listing of theory Peanissimo ===
val it = () : unit   
=TEX
   

\end{session}

\typeout{point 051}

The use of axioms, as illustrated here, carries considerable  danger in general
because it is very easy to assert inconsistent axioms.  It is thus safer to use
only definitions.  At first sight this might appear impossible, but in fact all
of ordinary  mathematics  can  be  developed  from  logic  by definition alone.
Showing this was  the achievement  of Russell  and Whitehead  in their treatise
{\sl Principia  Mathematica}  \cite{WHITEHEAD10}.    A   theory  containing  only
definitions is called a {\it definitional theory\/}.   Many useful definitional
theories are built-in to the \HOL\ system, or available as libraries.  Examples
include theories of numbers  (both natural  numbers and  integers), sets, bags,
finite trees, group theory, properties of fixed points and more.  

\newpage % PBHACK

The theory of numbers built-in to \HOL\  is called î, and is a definitional theory that defines
numbers logically. Peano's postulates are proved from the definitions of
the type \ml{num} and the constants \ml{0} and \ml{Suc}.
It follows from Peano's postulates that certain kinds of recursion equations are
equivalent to non-recursive definitions. There is a  theorem  called
\ml{prim\_rec\_thm} (for `primitive recursion') that supports this,
together with tools for automatically transforming recursion equations into
definitions. This is illustrated later but, for example, here are the built-in
the definitions
of addition and multiplication

\begin{session}

=SML 
get_defn "î" "+";
=GFT
val it = ô µ m n· 0 + n = n ± (m + 1) + n = (m + n) + 1 ± Suc m = m + 1 : THM
=TEX

=SML 
get_defn "î" "*";
=GFT
val it = ô µ m n· 0 * n = 0 ± (m + 1) * n = m * n + n : THM   
=TEX

\end{session}

\newpage % PBHACK

The theory  \ml{î} contains  too many  pre-proved theorems  to show in
full, but  here is a shortened version:
\clearpage

\begin{session}
=SML 
print_theory "î";
=GFT
 === The theory î ===

--- Parents ---

                pair

--- Children ---

                list

--- Constants ---

Suc             î ­ î
Zero            î
$+              î ­ î ­ î
$¼              î ­ î ­ BOOL
etc
--- Types ---

î

--- Fixity ---

Infix 210:      <       >       ¼       ¾
etc
--- Definitions ---

Zero
Suc
zero_suc_def    ô (µ n· ³ Suc n = Zero) ± OneOne Suc ±
                  (µ p· p Zero ± (µ m· p m ´ p (Suc m)) ´ (µ n· p n))
+
plus_def        ô µ m n· 0 + n = n ± (m + 1) + n = (m + n) + 1 ± Suc m = m + 1
etc
--- Theorems ---

induction_thm   ô µ p· p 0 ± (µ m· p m ´ p (m + 1)) ´ (µ n· p n)
³_plus1_thm     ô µ n· ³ n + 1 = 0
one_one_plus1_thm
                ô µ x1 x2· x1 + 1 = x2 + 1 ´ x1 = x2
prim_rec_thm    ô µ z s· ¶1 f· f 0 = z ± (µ n· f (n + 1) = s (f n) n)
plus_assoc_thm  ô µ i m n· (i + m) + n = i + m + n
plus_assoc_thm1 ô µ i m n· i + m + n = (i + m) + n
etc

 === End of listing of theory î ===
val it = () : unit   
=TEX
\end{session}

=TEX

\cleardoublepage 
\section{INTRODUCTION TO PROOF WITH HOL}
\label{proof}


For a logician, a formal proof is a sequence, each of whose  elements is
either an {\it axiom\/} or follows from earlier members of the sequence by a
{\it rule of inference\/}.  A theorem is the last element of a proof.


Theorems are represented in \HOL\ by values of an abstract
type\footnote{Abstract types are explained in \DESCRIPTION.}
{\small\verb%thm%}.  The  only way  to create theorems is by generating a
proof.  In \HOL\ (following \LCF), this consists in applying \SML\ functions
representing {\it rules of inference\/} to  axioms or previously generated
theorems.  The sequence of such applications  directly corresponds to a
logician's proof.

There are five axioms of the \HOL\ logic and eight primitive
inference rules. The axioms are bound to \SML\ names. For example, the Law of
Excluded Middle is bound to the \SML\ name \ml{bool\_cases\_axiom}:

\begin{session}
=SML 
bool_cases_axiom;
=TEX
=GFT
val it = ô µ b· (b ¤ T) ² (b ¤ F) : THM   
=TEX
\end{session}

Theorems are printed with a preceding turnstile  \ml{ô} as
illustrated above.   Rules of inference are \SML\ functions that
return values of type \ml{THM}.  
An example of a rule of inference is {\it
specialization\/} (or $\forall$-elimination). 
In standard `natural deduction'
notation this is:

\[ \Gamma\turn \uquant{x}t\over \Gamma\turn t[t'/x]\]

\begin{itemize}
\item $t[t'/x]$ denotes the result of substituting $t'$ for free
occurrences of $x$ in $t$, with the restriction that no free variables in $t'$
become bound after substitution.
\end{itemize}

\typeout{proof point 1}

\noindent This rule is represented in \SML\ 
by a function
\ml{simple\_µ\_elim},\footnote{This function is not a 
primitive rule of inference in the HOL logic, but is a derived rule. Derived rules
are described in Section~\ref{forward}.}
which takes as arguments a term
\ml{¬$a$®} and a theorem 
\ml{ôµ$x$·$t[x]$} and returns the theorem 
\ml{ô$t[a]$} , the result of substituting $a$ for $x$ in $t[x]$. 

\setcounter{sessioncount}{1}

\begin{session}
=SML 
val Th1 = bool_cases_axiom;  
=GFT
val Th1 = ô µ b· (b ¤ T) ² (b ¤ F) : THM   
=TEX
=SML 
val Th2 = simple_µ_elim ¬1 = 2® Th1;
=GFT
val Th2 = ô (1 = 2 ¤ T) ² (1 = 2 ¤ F) : THM   
=TEX
\end{session}


\typeout{proof point 2}

This session consists of a proof of two steps: using an axiom and
applying the rule \ml{simple\_µ\_elim}; it interactively performs the following proof:


\begin{enumerate}
\item $\turn \uquant{t} t= T \ \disj\  t= F $ \hfill
[Axiom \ml{bool\_cases\_axiom}]
\item $\turn (1{=}2)=T\ \disj\ (1{=}2)=F$\hfill [Specializing line 1 to `$1{=}2$']
\end{enumerate}

If the argument to an \SML\ function representing a rule of inference is of the
wrong kind, or violates a condition of the rule, then the application fails.
For example, $\ml{simple\_µ\_elim}\ t\ th$ will fail if $th$ is not of the form  \ml{ô µ $x$· $\cdots$ }
or if it is of this form but the type of $t$ is not the same
as the type of $x$, or if the free variable restriction is not met.

\begin{session}
=SML  
simple_µ_elim ¬1 = 2®  Th2; 
=GFT
Exception-
   Fail
      * ô (1 = 2 ¤ T) ² (1 = 2 ¤ F) is not of the form: ` ô µ x · t' where
      ¬x® is a variable [simple_µ_elim.7039] * raised
=TEX

=SML 
simple_µ_elim ¬1®  Th1;
=GFT
Exception-
   Fail * ¬b® and ¬1® do not have the same types [simple_µ_elim.3012] *    raised
=TEX
\end{session}



A proof in the \HOL\ system is constructed by repeatedly applying inference
rules to axioms or to previously proved theorems.
Since proofs may consist of millions of steps, it is necessary to provide
tools to make proof construction easier for the user.  The proof generating
tools in the \HOL\ system are described later.


The general form of a theorem is  $t_1,\ldots,t_n\ $\ml{ô}$\  t$, where $t_1$,
$\ldots$ , $t_n$ are boolean terms called  the {\it  assumptions} and  $t$ is a
boolean term called the {\it conclusion\/}.  Such a theorem asserts that if its
assumptions are true then so is its conclusion.  Its truth  conditions are thus
the same as those for the single term \ml{$(t_1$ ± $\ldots $ ± $t_n$) ´ $t$. } Theorems  with  no  assumptions are printed
out in the form \ml{ô$\ t$}.


The five  axioms and  eight primitive  inference rules  of the  \HOL\ logic are
described in  detail in  the document \DESCRIPTION.  Every
value of  type  \ml{THM}  in  the  \HOL\ system  can be  obtained by repeatedly
applying primitive inference rules to axioms.  When the \HOL\  system is built,
the eight  primitive rules  of inference  are defined  and the  five axioms are
bound to their \SML\ names, all other predefined theorems are proved using rules
of inference as the system is made.\footnote{This is a slight
over-simplification.} 

In the rest of this chapter, the  process of  {\it forward  proof\/}, which has
just been sketched, is decribed in more detail.   In Chapter~\ref{tactics} {\it
goal directed proof\/} is  described, including  the important  notions of {\it
tactics\/} and {\it tacticals\/}, due to Robin Milner.

\subsection{Forward proof}
\label{forward}

Three of the primitive  (check this) inference rules of the
\HOL\ logic are \ml{asm\_rule} (assumption introduction),
\ml{disch\_rule} (discharging or assumption elimination) and \ml{´\_mp\_rule} (Modus Ponens).
These rules will be used to illustrate forward proof and the writing of derived
rules.

The inference rule \ml{asm\_rule} generates theorems of the form
\ml{$t$ ô $t$}. 

\suppress{Note, however, that the \SML\ printer prints each
assumption as a dot (but this default can be changed; see below).
}

The function
{\small\verb%dest_thm%} decomposes a theorem into a pair consisting of list of
assumptions and the conclusion. The \SML\ type \ml{SEQ}, or \ml{GOAL},  abbreviates \ml{TERM list * TERM}, this is motivated in Section~\ref{tactics}.

\begin{session}
=SML 
val Th3 = asm_rule ¬t1´t2®;

=GFT
val Th3 = t1 ´ t2 ô t1 ´ t2 : THM   
=TEX

=SML 
dest_thm Th3;

=GFT
val it = ([¬t1 ´ t2®], ¬t1 ´ t2®) : SEQ   
=TEX
\end{session}

The primitive inference rule
\ml{disch\_rule} (discharging, assumption elimination) infers from
a theorem of the form $\cdots t_1\cdots \ml{ô}t_2$ the new theorem
$\cdots\ \cdots\ \ml{ô}\ t_1\ml{´}t_2$. \ml{disch\_rule} takes as arguments
the term to be discharged (\ie\ $t_1$) and the theorem from whose
assumptions it is to be discharged and returns the result of the discharging.
The following session illustrates this; it also illustrates what happens when
\ml{=>}, which is part of the syntax of conditional terms
(see the table on page~\pageref{logic-table}), 
is erroneously typed instead of the implication symbol \ml{´}.

\begin{session}
=SML 
val Th4 = disch_rule ¬t1=>t2® Th3; 

=GFT
Syntax error in: ¬ t1 = <?> > 
> is not expected after ¬ ... =
Exception- Fail * Syntax error [HOL-Parser.19000] * raised
=TEX

=SML 
val Th4 = disch_rule ¬t1´t2® Th3;

=GFT
val Th4 = ô (t1 ´ t2) ´ t1 ´ t2 : THM   
=TEX
    
\end{session}

Note that the term being discharged must be in the assumptions.

\begin{session}
=SML 
disch_rule ¬1=2® Th3;

=GFT
Exception-
   Fail
      * ¬1 = 2® not Á-convertibly present in assumption list
      [disch_rule.7031] * raised
=TEX

\end{session}


In \HOL\,  the  rule   of  Modus  Ponens  is  specified in conventional
notation by:  

\[ \Gamma_1 \turn t_1 \imp t_2 \qquad\qquad \Gamma_2\turn t_1\over
\Gamma_1 \cup \Gamma_2 \turn t_2\]

The  corresponding \SML\ function \ml{´\_mp\_rule} takes argument theorems of the
form \ml{$\cdots\ $ ô $\ t_1$\ ´\ $t_2$} and \ml{$\cdots\ $ ô $\ t_1$}
and returns \ml{$\cdots\ $ ô $\ t_2$}. The next session illustrates the use of
\ml{´\_mp\_rule} and also a common error, namely not supplying the \HOL\ logic type
checker with enough information. 

\begin{session}
=SML 
val Th5 = asm_rule  ¬t1®;
=GFT
Exception- Fail * ¬t1® is not of type ¬:BOOL® [asm_rule.3031] * raised
=TEX

=SML 
val Th5 = asm_rule  ¬t1:BOOL®;

=GFT
val Th5 = t1 ô t1 : THM   
=TEX


=SML 
val Th6 = ´_mp_rule Th3 Th5;

=GFT
val Th6 = t1 ´ t2, t1 ô t2 : THM   
=TEX

 \end{session}

The assumptions of \ml{Th6} can be extracted with the \SML\ function \ml{hyps}, (``hypotheses'')
which returns the list of assumptions of a theorem (the conclusion is returned by the function \ml{concl}).

\begin{session}

=SML 
hyps Th6;

=GFT
val it = [¬t1 ´ t2®, ¬t1®] : TERM list   
=TEX
\end{session}



\noindent Discharging \ml{Th6} twice establishes the theorem
\ml{ô \ t1 ´ (t1 ´ t2) ´ t2}.

\begin{session}
=SML  
val  Th7 =  disch_rule ¬t1´t2® Th6; 

=GFT
val Th7 = t1 ô (t1 ´ t2) ´ t2 : THM   
=TEX

=SML 
val  Th8 = disch_rule ¬t1:BOOL® Th7; 

=GFT
val Th8 = ô t1 ´ (t1 ´ t2) ´ t2 : THM   
=TEX

\end{session}



The sequence: \ml{Th3},
\ml{Th5}, \ml{Th6}, \ml{Th7}, \ml{Th8} constitute a proof in \HOL\ of
the theorem \[ô \ t1 ´ (t1 ´ t2) ´ t2 \].   This
proof could be written:

\begin{enumerate}
\item $ t_1\imp t_2\turn t_1\imp t_2$ \hfill
[Assumption introduction]
\item $ t_1\turn t_1$ \hfill
[Assumption introduction]
\item $t_1\imp t_2,\ t_1 \turn t_2 $ \hfill
[Modus Ponens applied to lines 1 and 2]
\item $t_1 \turn (t_1\imp t_2)\imp t_2$ \hfill
[Discharging the first assumption of line 3]
\item $\turn t_1 \imp (t_1 \imp t_2) \imp t_2$ \hfill
[Discharging the only assumption of line 4]
\end{enumerate}

\subsection{Derived rules}


A {\it proof from hypothesis $th_1, \ldots, th_n$} is a sequence each of whose
elements is either an axiom, or one of the hypotheses $th_i$, or follows from
earlier elements by a rule of inference.

For example, a proof of $\Gamma,\ t'\turn t$ from the hypothesis
$\Gamma\turn t$ is:


\begin{enumerate}
\item $t'\turn t'$ \hfill [Assumption introduction]
\item $\Gamma\turn t$ \hfill [Hypothesis]
\item $\Gamma\turn t'\imp t$ \hfill [Discharge $t'$ from line 2]
\item $\Gamma,\ t'\turn t$ \hfill [Modus Ponens applied to lines 3 and 1]
\end{enumerate}

Line 3 above mentions ``discharging'' the assumption $t'$, but if $t'$ is not actually amongst the assumptions, \ml{disch\_rule} will fail.  A variation of \ml{disch\_rule} is  called  \ml{´\_intro}, which is used in the same way, that is, after use of the rule $t'$ is not present amongst the assumptions and it is present as the antecedent of an implication, which is true of \ml{disch\_rule} as well, but $t'$ need not be present in the original assumptions.

\noindent This proof works for any hypothesis of the form $\Gamma\turn t$ 
and any boolean term $t'$ and
shows that the result of adding an arbitary hypothesis to a theorem is another
theorem (because the four lines above can be added to any proof of
$\Gamma\turn t$ to get a proof of $\Gamma,\ t'\turn t$).\footnote{This property
of the logic is called {\it monotonicity}.} For example,
the next session uses this proof to add the hypothesis \ml{"t3"} to
\ml{Th6}.


\begin{session} 

=SML 
val  Th9 = asm_rule ¬t3:BOOL®; 
=GFT
val Th9 = t3 ô t3 : THM   
=TEX


=SML 
val  Th10 = ´_intro ¬t3:BOOL® Th6; 
=GFT
val Th10 = t1 ´ t2, t1 ô t3 ´ t2 : THM   
=TEX


=SML 
val Th11 = ´_mp_rule Th10 Th9; 
=GFT
val Th11 = t1 ´ t2, t1, t3 ô t2 : THM   
=TEX
\end{session}


A {\it derived rule\/} is a \SML\ procedure that generates a proof from given hypotheses
each time it is invoked. The hypotheses are the arguments of the rule.
To illustrate this, a rule, called \ml{ADD\_ASSUM}, will now
be defined as an \SML\ procedure that carries
out the proof above. In standard notation this would be described by:

\[ \Gamma\turn t\over \Gamma,\ t'\turn t \]

\noindent The \SML\ definition is:

\begin{session} 
=SML 
fun  ADD_ASSUM t th =
 let val th9  = asm_rule t
     val th10 = ´_intro t th
 in
 ´_mp_rule th10 th9
 end; 
=GFT
val ADD_ASSUM = fn : TERM -> THM -> THM
=TEX

=SML 
ADD_ASSUM ¬t3:BOOL® Th6; 
=GFT
val it = t1 ´ t2, t1, t3 ô t2 : THM   
=TEX

\end{session}

\noindent The body of \ml{ADD\_ASSUM} has been coded  to mirror  the proof done
in session~10 above, so as to show how an interactive proof  can be generalized
into a  procedure.   But \ml{ADD\_ASSUM}  can be  written much more
concisely as:

\begin{session} 
=SML 
fun  ADD_ASSUM t th = ´_mp_rule (´_intro t th) (asm_rule t); 
=GFT
val ADD_ASSUM = fn : TERM -> THM -> THM   
=TEX

=SML 
ADD_ASSUM  ¬t3:BOOL® Th6;
=GFT
val it = t1 ´ t2, t1, t3 ô t2 : THM   
=TEX

\end{session}


Another example of  a derived  inference rule  is shown below as \ml{UNDISCH};  this moves the
antecedant of an implication to the assumptions.

\[ \Gamma\turn t_1\imp t_2 \over\Gamma,\ t_1\turn t_2 \]

\noindent A \SML\ derived rule that implements this is:

\typeout{ --- section 4.2 ---- }
\begin{session} 
=SML 
fun  UNDISCH th =  ´_mp_rule th (asm_rule(fst(dest_´(concl th)))); 
=GFT
val UNDISCH = fn : THM -> THM
=TEX
=SML 
Th10; 
=GFT
val it = t1 ´ t2, t1 ô t3 ´ t2 : THM   
=TEX

=SML 
UNDISCH Th10; 
=GFT
val it = t1 ´ t2, t1, t3 ô t2 : THM   
=TEX

=SML 
undisch_rule Th10;
=GFT
val it = t1 ´ t2, t1, t3 ô t2 : THM   
=TEX
\end{session}

\noindent Each time \ml{UNDISCH\ $\Gamma\turn t_1\imp t_2$} is executed,
the following proof is performed:

\begin{enumerate}
\item $t_1\turn t_1$ \hfill [Assumption introduction]
\item $\Gamma\turn t_1\imp t_2$ \hfill [Hypothesis]
\item $\Gamma,\ t_1\turn t_2$ \hfill [Modus Ponens applied to lines 2 and 1]
\end{enumerate}

Rules  equivalent to \ml{ADD\_ASSUM} and \ml{UNDISCH} (named respectively \ml{asm\_intro} and \ml{undisch\_rule}) are  derived rules
 defined when the \HOL\ system is built. For a description
of the main rules see the section on derived rules in
\DESCRIPTION.

\typeout{.... page 38 approx ....}

\subsection{Rewriting}

An important derived rule  is  \ml{rewrite\_rule}.    This takes  as arguments
\begin{itemize}
\item a collection of equations represented by  a list of theorems, such that each theorem is an equation or a conjunction of equations, and 
\item   a theorem $\Delta\turn t$ 
\end{itemize}
 and  repeatedly  replaces in  $t$  instances  of  the lefthand side of an equation  by the
corresponding instance of the righthand side until no further change occurs.   The result is
a theorem $\Gamma\cup\Delta\turn t'$ where $t'$ is the result  of rewriting $t$
in this way. 


 The session below illustrates the use of  \ml{rewrite\_rule}.  In
it the list of equations is a list \ml{rewrite\_list} containing the 
theorems  produced earlier as the axioms defining \ml{plus} and \ml{times}.


\begin{session}
=SML  
val  rewrite_list =  map (get_defn "î") ["+", "*"]; 
=GFT
val rewrite_list = [ô µ m n· 0 + n = n ± (m + 1) + n = (m + n) + 1 ± Suc m =
     m + 1, ô µ m n· 0 * n = 0 ± (m + 1) * n = m * n + n] : THM list
=TEX
\end{session}

In the following example,  the conclusion of a theorem (an arbitrary theorem just for this example) is rewritten using the definitions of \ml{plus} and \ml{times} to produce a simpler theorem. 

\begin{session} 
=SML 
val th = asm_rule ¬(0 + m) = ((0* n) +1)®;
=GFT
val th = 0 + m = 0 * n + 1 ô 0 + m = 0 * n + 1 : THM   
=TEX

=SML 
rewrite_rule rewrite_list th;
=GFT
val it = 0 + m = 0 * n + 1 ô m = 1 : THM   
=TEX
\end{session}


\ml{rewrite\_rule} is not a primitive in \HOL, but is a derived rule.   In addition to the supplied equations,
\ml{rewrite\_rule} has some built-in standard simplifications:

\begin{session} 
=SML 
 (asm_rule ¬(T ± x) ² F ´ F®);
=GFT
val it = T ± x ² F ´ F ô T ± x ² F ´ F : THM   
=TEX

=SML 
rewrite_rule [] it;
=GFT
val it = T ± x ² F ´ F ô ³ x : THM   
=TEX
\end{session}


There are elaborate facilities in \HOL\ for producing customized rewriting tools
which scan through terms in user programmed orders; \ml{rewrite\_rule} is the tip
of an iceberg, see \DESCRIPTION\ for more details.

\typeout{ ---- end of section 4.3 ---- }


\pagebreak

\subsection{Goal Oriented Proof: Tactics and Tacticals}
\label{backward}\label{tactics}

The style of forward proof described in the previous chapter is unnatural and
too `low level' for many applications. An important advance in proof generating
methodology was made by Robin Milner in the early 1970s when he invented the
notion of {\it tactics\/}. A tactic is function that does two things.
\begin{enumerate}
\item Splits a `goal' into `subgoals'.
\item Keeps track of the reason why solving the subgoals will solve the goal.
\end{enumerate}

\noindent Consider, for example, the  rule of $\wedge$-introduction\footnote{In
higher order logic this is a derived rule; in first  order logic  it is usually
primitive.  In HOL the rule is called \ml{±\_intro} and its derivation is given in
\DESCRIPTION.}  shown below:  

\[ \Gamma_1\turn
t_1\qquad\qquad\qquad\Gamma_2\turn t_2\over \Gamma_1\cup\Gamma_2 \turn t_1\conj
t_2 \]


\noindent In \HOL,  $\wedge$-introduction is  represented by  the \SML\ function
\ml{±\_intro}:  

\[\ml{±\_intro}\ (\Gamma_1\turn t_1)\ (\Gamma_2\turn t_2) \ \ \leadsto\
\ (\Gamma_1\cup\Gamma_2\turn  t_1\conj  t_2)\]

\noindent  This  is   illustrated  in  the
following new  session  (note  that  the  session  number  has  been  reset  to
{\small\sl 1}):

\setcounter{sessioncount}{1}
\begin{session}
=SML 
val  Th1 = asm_rule ¬A:BOOL® and Th2 = asm_rule ¬B:BOOL®;
=GFT
val Th1 = A ô A : THM  
val Th2 = B ô B : THM   
=TEX

=SML 
val  Th3 = ±_intro Th1 Th2; 
=GFT
val Th3 = A, B ô A ± B : THM
=TEX
\end{session}

Suppose the goal is to prove $A\conj B$, then this rule says 
that it is sufficient
to prove the two subgoals $A$ and $B$, because from $\turn A$ and $\turn B$
the theorem $\turn A\conj B$ can be deduced. Thus:

\begin{description}
\item[(i)] To prove $\turn A \conj B$ it is sufficient to 
      prove $\turn A$ and $\turn B$.
\item [(ii)]The justification for the reduction of the 
goal  $\turn A \conj B$  to the two  subgoals  $\turn A$ 
and $\turn B$ is the rule of $\wedge$-introduction.
\end{description}

A {\it goal\/} in \HOL\ is a pair
\ml{([$t_1$,\ldots,$t_n$],$t$)} of \SML\ type \ml{TERM list * TERM} . An {\it achievement\/} of such a goal
is a theorem
\ml{$t_1$,$\ldots$,$t_n$\ |-\ $t$}. 
A tactic is an \SML\ function that when applied to a goal generates subgoals
together with a {\it justification function\/} or {\it validation\/}, 
which will be a \SML\ derived inference
rule, that can be used to infer an achievement of the original goal from
achievements
of the subgoals. 



\SML\ has a type abbreviating mechanism which is used to give mnemonic
names to the various types associated with goal oriented proof.  Some type abbreviations are as follows:

\begin{tabular}{|l|l|}  \hline 
{\bf Abbreviation} & {\bf Type} \\ \hline \hline
\ml{CONV}          & \verb+TERM -> THM+    \\        \hline
\ml{GOAL}          & \verb+(TERM list ) * TERM + \\  \hline
\ml{GOAL\_STATE}   & an abstract type \\  \hline
\ml{PROOF}         & \verb+THM list -> THM+    \\    \hline
\ml{SEQ}           & \verb+(TERM list ) * TERM+   \\ \hline
\ml{TACTIC}        & \verb+GOAL -> (GOAL list * PROOF)+  \\ \hline
\ml{THM\_TACTIC}   & \verb+THM -> TACTIC+  \\ \hline
\ml{THM\_TACTICAL} & \verb+THM_TACTIC -> THM_TACTIC+  \\ \hline
\end{tabular}


The left hand side of these abbreviations can be used anywhere that the
right hand side can. 



If $T$ is a tactic (\ie\ a \SML\ function of type \ml{tactic})  and $g$ 
is a goal (\ie\ a \SML\ function of type \ml{goal}), then
applying $T$ to $g$ (\ie\ evaluating the \SML\ 
expression $T\ g$) will result in
an object of \SML\ type \ml{(GOAL list * PROOF) } \ie\ a pair whose 
first component is a list of 
goals and whose second component is a justification function, \ie\ has
\SML\ type \ml{PROOF}.


An example tactic is  \ml{±\_tac} which implements (i) and (ii) above.
For example, consider the utterly trivial goal of showing \ml{T ± T},
where \ml{T} is a constant that stands for $true$:

\begin{session} 
=SML 
val  goal =([], ¬T ± T®);
=GFT
val goal = ([], ¬T ± T®) : 'a list * TERM   
=TEX

=SML 
±_tac goal;
=GFT
val it = ([([], ¬T®), ([], ¬T®)], fn) : GOAL list * PROOF
=TEX

=SML 
val  (goal_list,just_fn) = it; 
=GFT
val goal_list = [([], ¬T®), ([], ¬T®)] : GOAL list
val just_fn = fn : PROOF
=TEX
\end{session}


\noindent \ml{±\_tac} has produced a goal  list consisting  of two identical
subgoals of just showing \ml{([],"T")}.  Now, there  is a  preproved theorem in
\HOL, which is recorded in theory  \ml{misc} under the name of \ml{t\_thm}.  It can be produced and bound to a \SML\ name,  say \ml{TRUTH}, as follows:


\begin{session} 

=SML 
val TRUTH = get_thm "misc" "t_thm";
=GFT
val TRUTH = ô T : THM   
=TEX

\end{session}



\noindent Applying the justification function \ml{just\_fn} to a list
of theorems achieving the goals in \ml{goal\_list} results
in a theorem achieving the original goal:

\begin{session} 
=SML 
just_fn [TRUTH, TRUTH];
=GFT
val it = ô T ± T : THM   
=TEX
\end{session}

Although this  example  is trivial,  it does  illustrate the  essential idea of
tactics.  Note that  tactics are  not special  theorem-proving primitives; they
are just  \SML\  functions.   For example,  the definition  of  a tactic equivalent to the built-in \ml{±\_tac} would be:
simply:

=GFT
 
    fun ±_tac_equivalent (asl,w) =
	let  val (l,r) = dest_± w 
	in
	([(asl,l), (asl,r)], 
	 fn [th1, th2] => ±_intro th1 th2)
	end;

=TEX

In this definition, the \SML\ function \ml{dest\_±} splits a conjunctive term into its
two conjuncts, \ml{l} and \ml{r}.
If \ml{(asl,¬$l$±$r$®} 
is a goal, then \ml{±\_tac\_equivalent} splits
it into the list of two subgoals \ml{(asl,¬$l$®)} and
\ml{(asl,¬$r$®)}. 

The justification function,
=GFT
 
 fn [th1, th2] => ±_intro th1 th2


=TEX
 
takes
a list \ml{[$th_1$,$th_2$]} of theorems and applies the rule \ml{±\_intro}
to $th_1$ and $th_2$.

To summarize:
if $T$ is a tactic and $g$ 
is a goal, then
applying $T$ to $g$ will result in
an object of \SML\ type  \ml{GOAL list * PROOF}, \ie\ a pair whose 
first component is a list of 
goals and whose second component is a justification function. 

Suppose \ml{$T\ g$ = ([$g_1$ , $\ldots$ , $g_n$], $p$ )}. 
The idea is that $g_1$ , $\ldots$ , $g_n$ are subgoals and $p$
is a `justification' of the reduction of goal $g$ to subgoals 
$g_1$ , $\ldots$ , $g_n$.
Suppose further that the subgoals $g_1$ , $\ldots$ , $g_n$ have been solved. 
This would mean that 
theorems $th_1$ , $\ldots$ , $th_n$ had been proved
such that each $th_i$ ($1\leq i\leq n$) `achieves' the goal $g_i$. 
The justification $p$ (produced
by applying $T$ to $g$) is a \SML\ 
function which when applied to the list
{\small\verb%[%}$th_1${\small\verb%,%}$\ldots${\small\verb%,%}$th_n${\small\verb%]%} returns a theorem, $th$, 
which `achieves' the original goal $g$.
Thus $p$ is a function for converting a solution of the subgoals to a
solution of the original goal. If $p$ 
does this successfully, then the tactic $T$ is
called {\it valid\/}. 
Invalid tactics cannot result in the proof of invalid theorems;
the worst they can do is result in insolvable goals or unintended theorems
being proved.
If tactic $T$ were invalid and were used
to reduce goal $g$ to subgoals $g_1$ , $\ldots$ , $g_n$,
then  effort might be spent proving
theorems $th_1$ , $\ldots$ , $th_n$ to
achieve the subgoals $g_1$ , $\ldots$ , $g_n$, 
only to find out after the work is done that this is a blind alley
because $p${\small\verb%[%}$th_1${\small\verb%,%}$\ldots${\small\verb%,%}$th_n${\small\verb%]%} 
doesn't achieve $g$ (\ie\ it fails, 
or else it achieves some other goal).

A theorem {\it achieves\/} a goal if the assumptions of the theorem are
included in the assumptions of the goal {\it and\/} if the conclusion of the
theorem is equal (up to the renaming of bound variables) to the conclusion of
the goal. More precisely, a theorem 
$t_1$, $\dots$, $t_m${\small\verb% |- %}$t$ achieves a goal
{\small\verb%([%}$u_1${\small\verb%;%}$\ldots${\small\verb%;%}$u_n${\small\verb%],%}$u${\small\verb%)%} 
if and only if {\small\verb%{%}$t_1,\ldots,t_m${\small\verb%}%} is a subset of
{\small\verb%{%}$u_1,\ldots,u_n${\small\verb%}%} and $t$ is equal to $u$ (up
to renaming of bound variables).  For example, the goal
\begin{quotation}
\ml{([¬x=y®, ¬y=z®, ¬z=w®],   ¬x=z®)}
\end{quotation}
 is achieved by the theorem
\begin{quotation}
\ml{x=y, y=z ô x=z} 
\end{quotation}the assumption \ml{z=w} being not
needed.

A tactic {\it solves\/} a goal if it reduces the goal 
to the empty list
of subgoals. Thus $T$ solves $g$ if  $T\ g${\small\verb% = ([],%}$p${\small\verb%)%}.
If this is the case and if $T$ is valid, then $p${\small\verb%[]%} 
will evaluate to a theorem achieving $g$.
Thus if $T$ solves $g$ then the \SML\ expression 
{\small\verb%snd(%}$T\ g${\small\verb%)[]%} evaluates to
a theorem achieving $g$.

Tactics are specified using the following notation:

\begin{center}
\begin{tabular}{c} \\
$goal$ \\ \hline \hline
$goal_1\ \ \ goal_2 \ \ \ \cdots\ \ \ goal_n$ \\
\end{tabular}
\end{center}

\noindent For example, a tactic called \ml{±\_tac} is described by

\begin{center}
\begin{tabular}{c} \\
$ t_1$ \ml{±} $t_2$ \\ \hline \hline
$t_1\ \ \ \ \ \ \ t_2$ \\
\end{tabular}
\end{center}



\noindent Thus \ml{±\_tac} reduces a goal of the form 
\ml{$\Gamma$, ¬$t_1$±$t_2$®} 
to subgoals\ml{$\Gamma$, ¬$t_1$®} and \ml{$\Gamma$, ¬$t_2$®}
.
The fact that the assumptions of the top-level goal
are propagated unchanged to the two subgoals is indicated by the absence
of assumptions in the notation.

\pagebreak

Another example is  \ml{induction\_tac}, the tactic for doing mathematical induction
on the natural numbers.

\begin{center}
\begin{tabular}{c} \\
$t[n]$ \\ \hline \hline
$t[${\small\verb%0%}$]$ {\small\verb%     %} $\{t[n]\}\ t[${\small\verb%Suc %}$n]$
\end{tabular}
\end{center}

Given the name of a variable, n say,  which is to be the indiction variable,  \ml{induction\_tac ¬n:î®} reduces a goal ($\Gamma$,\ml{$t[n]$}) to
\begin{itemize}
\item  a basis subgoal ($\Gamma$,\ml{t[0]}), and 
\item  an induction step subgoal ($\Gamma\cup$ \{ t[n] \}, \ml{t[n+1]})

\end{itemize}The extra induction assumption \ml{t[n]}
is indicated in the tactic notation with set brackets.

\begin{session} 

=SML 
(induction_tac ¬m:î®)  ([], ¬(m + n) = (n + m)®);

=GFT
val it = ([([], ¬0 + n = n + 0®),
      ([¬m + n = n + m®], ¬(m + 1) + n = n + m + 1®)],
   fn) : GOAL list * PROOF
=TEX
\end{session}

\noindent The first subgoal is the basis case and the second subgoal is
the step case.

Tactics generally fail (in the \SML\ sense) if they are applied to 
inappropriate
goals. For example, \ml{±\_tac} will fail if it is applied to a goal whose
conclusion is not a conjunction. Some tactics never fail, for example
{\small\verb%ALL_TAC%}\footnote{check this out}


\begin{center}
\begin{tabular}{c} \\
$t$ \\ \hline \hline
$t$
\end{tabular}
\end{center}

\noindent is the `identity tactic'; it reduces a goal 
{\small\verb%(%}$\Gamma${\small\verb%,%}$t${\small\verb%)%} 
to the single
subgoal {\small\verb%(%}$\Gamma${\small\verb%,%}$t${\small\verb%)%}---\ie\ 
it has no effect. {\small\verb%ALL_TAC%} is useful for writing
complex tactic using tacticals (\eg\ see the definition of {\small\verb%REPEAT%} in
Section~\ref{tacticals}).


\subsection{Using tactics to prove theorems}   
\label{using-tactics}

Suppose goal $g$  is to be solved. If $g$
is simple it might be possible
to immediately think up a tactic, $T$ 
say, which reduces it to the empty list of
subgoals. If this is the case then executing:

\ml{val (gl,p) = T g ;}


\noindent will bind $p$ to a function which when applied to the empty list
of theorems yields a theorem $th$ achieving $g$. 
(The declaration above
will also bind $gl$ to the empty list of goals.) Thus a theorem achieving 
$g$ can be computed by executing:

\ml{val th = p [];}


\noindent This will be illustrated using \ml{rewrite\_tac} which takes a list
of equations (empty in the example that follows) and tries to prove a goal
by rewriting with these equations togther with
\ml{basic\_rewrites}:

\begin{session}
=SML  
val g = ([], ¬T ± x ´ x ² (y ± F)®);

=GFT
val g = ([], ¬T ± x ´ x ² y ± F®) : 'a list * TERM   
=TEX

=SML 
val T = rewrite_tac [];
=GFT
val T = fn : TACTIC   
=TEX

=SML 
 val (gl, p) = T g;
=GFT
val gl = [] : GOAL list   val p = fn : PROOF   
=TEX

=SML 
 val th = p[];
=GFT
val th = ô T ± x ´ x ² y ± F : THM   
=TEX
\end{session}

\noindent Proved theorems are usually stored in the current theory 
so that
they can be used in subsequent sessions.

To simplify the use of tactics there is a built-in  function \ml{tac\_proof} of
\SML\ type \ml{GOAL * TACTIC -> THM} such that

\ml{tac\_proof ($G$, $T$)} 
 proves
the goal  $G$  using  tactic  $T$  and  returns the resulting theorem.

If the theorem is  to be saved on the current theory, the function \ml{save\_thm} of type \ml{string * THM -> THM}  can be used. Evaluating \ml{save\_thm ("foo", th)}  will cause theorem \ml{th} to be saved in the current theory under the name of \ml{foo}.  The theorem can be removed from the current theory by evaluating \ml{delete\_thm "foo"}.  Both \ml{save\_thm} and \ml{delete\_thm} return a value which is the theorem in question.


When conducting a proof that involves many subgoals and tactics, it is necessary
to keep track of all the justification functions  
and compose them in the correct order.  While
this is feasible even in large proofs, it is tedious.  \HOL\ provides a package
for building and traversing the tree of subgoals, stacking the justification functions and
applying them properly; such package was originally implemented for \LCF\ by 
Larry Paulson.

The subgoal package implements a simple framework for interactive proof. A proof
tree is created and traversed top-down.  The current goal can be expanded
into subgoals using a tactic; the subgoals are pushed onto a goal
stack and the justification function onto a proof stack.
Subgoals can be considered in any order.  If the tactic solves a
subgoal (\ie\ returns an empty subgoal list), then the package proceeds to the
next subgoal in the tree. 

The function  \ml{push\_goal} of type \ml{goal -> void}
initializes the subgoal package with a new goal. Usually
top-level goals have no assumptions; the function \ml{g} is useful
in this case and is defined by:

=SML  
   fun g t = push_goal([],t);
=TEX

\typeout{  ----- point 100 -----}

To illustrate the subgoal package the trivial theorem
$\vdash \uquant{m}m+0=m$ will be proved from the definition   of addition: 

\begin{session}

=SML  
val ADD = [get_defn "î" "+"];

=GFT
val ADD = [ô µ m n· 0 + n = n ± (m + 1) + n = (m + n) + 1 ± Suc m = m + 1] : THM list
=TEX
\end{session}

Notice that \ml{ADD} specifies $0+n=n$
 but not  $n+0=n$. Of course, $\uquant{m\ n}m+n = n+m$ is true, but the first
step of the proof of this from the definition of addition is showing  $\uquant{m}m+0=m$.

\typeout{point 101}

\setcounter{sessioncount}{1}
\begin{session} 
=SML 
g ¬(m + 0) = m®; 
=GFT
Now 1 goal on the main goal stack

(* *** Goal "" *** *)

(* ?ô *)  ¬m + 0 = m®

val it = () : unit   
=TEX

\end{session}

\typeout{point 102}

\noindent This sets up the goal. Next the goal is split into a basis and step case
with \ml{INDUCT\_TAC}. To do this the function \ml{apply\_tactic} (abbreviating this freqently-used name to \ml{a}) is used. This applies a tactic to the top goal on the stack, then
pushes the resulting subgoals onto the goal stack, then prints the resulting
subgoals. If there are no subgoals, the justification function is applied to the
theorems solving the subgoals that have been proved and the resulting theorems are
printed.

\begin{session}
=SML 
val a = apply_tactic; 
=GFT
val a = fn : TACTIC -> unit   
=TEX

=SML 
a  (induction_tac ¬m:î®) ;
=GFT
Tactic produced 2 subgoals:

(* *** Goal "2" *** *)

(*  1 *)  ¬m + 0 = m®

(* ?ô *)  ¬(m + 1) + 0 = m + 1®


(* *** Goal "1" *** *)

(* ?ô *)  ¬0 + 0 = 0®

val it = () : unit   
=TEX
  
\end{session}

\typeout{point 103}

\noindent The top of the goal stack is printed last. The basis case
is an instance of the definition of addition, so is solved by rewriting with
\ml{ADD}.

\begin{session}
=SML 
a (rewrite_tac ADD);
=GFT
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "2" *** *)

(*  1 *)  ¬m + 0 = m®

(* ?ô *)  ¬(m + 1) + 0 = m + 1®

val it = () : unit   
=TEX
  

\end{session}

\typeout{point 104}

\noindent The basis is solved and the goal
stack popped so that its top is now the step case, namely showing
that {\small\verb%(SUC m) + 0 = SUC m%}  on the assumption thatt
{\small\verb%n + 0 = n%}. This goal can be solved by rewriting first
with the definition of addition:

\begin{session}
=SML 
a (rewrite_tac ADD);
=GFT
Tactic produced 1 subgoal:

(* *** Goal "2" *** *)

(*  1 *)  ¬m + 0 = m®

(* ?ô *)  ¬(m + 0) + 1 = m + 1®

val it = () : unit   
=TEX

\end{session}

\typeout{ point 105}

and then by rewriting with the assumption \ml{n  + 0 = n}. The tactic
\ml{asm\_rewrite\_tac} is used to rewrite with the assumptions of a goal. It is
just like \ml{rewrite\_tac} except that it adds the assumptions to the list of
equations used for rewriting. For the example here no equations besides the
assumptions are needed, so \ml{asm\_rewrite\_tac} is given the empty list of
equations.

\begin{session}
=SML 
a (asm_rewrite_tac []);
=GFT
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit 
=TEX
  
\end{session}

\noindent The top goal is solved, hence the preceding goal (the step case)
is solved too, and since the basis is already solved, the main goal is solved.

The theorem achieving the goal can be extracted from the subgoal package with \ml{top\_thm}:


\index{theorems, retrieving from goal state with \ml{top\_thm}}
\begin{session}
=SML 
top_thm(); 
=GFT
val it = ô m + 0 = m : THM   
=TEX
\end{session}


\typeout{point 106}
The proof just done can be `optimized'. For example, instead
of first rewriting with \ml{ADD} (box 4) and then with the assumptions
(box 5), a single rewriting with \ml{ADD} and the assumptions would suffice.
To illustrate, the last two steps of the proof will be `undone' using the function
\ml{undo} which restores the previous state of the goal and theorem stacks.

\begin{session} 
=SML 
undo 1;
=GFT
(* *** Goal "2" *** *)

(*  1 *)  ¬m + 0 = m®

(* ?ô *)  ¬(m + 0) + 1 = m + 1®

val it = () : unit   
=TEX

=SML 
undo 1;
=GFT
Current goal is:

(* *** Goal "2" *** *)

(*  1 *)  ¬m + 0 = m®

(* ?ô *)  ¬(m + 1) + 0 = m + 1®

val it = () : unit   
=TEX
\end{session}

The proof can now be completed in one step instead of two:

\begin{session}
=SML 
a (asm_rewrite_tac ADD);
=GFT
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit  
=TEX
\end{session}


The order in which goals are attacked can be adjusted. Firstly the goal stack is backed up by two steps, back to the point at which there are two subgoals.   Note that the  previous example showed two separate calls of \ml{undo},  each of a single stepto show the effect, any number of steps can be backed up by giving an argument to \ml{undo}:

\begin{session}
=SML 
undo 2;
=GFT
Current goal is:

(* *** Goal "1" *** *)

(* ?ô *)  ¬0 + 0 = 0®

val it = () : unit   
=TEX
\end{session}

The system offers the basis case as the current subgoal.  In order to survey all the possible subgoals, the command \ml{print\_goal\_state  (top\_goal\_state())} is used:
\index{goal state, examining with \ml{print\_goal\_state}}

\begin{session}
=SML 
print_goal_state (top_goal_state());
=GFT
Main goal is:
(* ?ô *)  ¬m + 0 = m®

Goals to be proven are:

(* *** Goal "1" *** *)

(* ?ô *)  ¬0 + 0 = 0®


(* *** Goal "2" *** *)

(*  1 *)  ¬m + 0 = m®

(* ?ô *)  ¬(m + 1) + 0 = m + 1®


Current goal is:

(* *** Goal "1" *** *)

(* ?ô *)  ¬0 + 0 = 0®

val it = () : unit   
=TEX
\end{session}

It can be seen that the current goal is labelled "1" and the other goal is labelled "2".  To choose the other goal to work on, it is made current with the command \ml{set\_labelled\_goal}, providing an argument value of, in this case, "2".
\begin{session}
=SML 
set_labelled_goal "2";
=GFT
Current goal is:

(* *** Goal "2" *** *)

(*  1 *)  ¬m + 0 = m®

(* ?ô *)  ¬(m + 1) + 0 = m + 1®

val it = () : unit   
=TEX
\end{session}

\typeout{point 199}

\noindent The top goal is now the step case not the basis case, so the appropriate tactic can be applied:

\begin{session}
=SML 
a (asm_rewrite_tac ADD);
=GFT
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "1" *** *)

(* ?ô *)  ¬0 + 0 = 0®

val it = () : unit   
=TEX
\end{session}

The topmost goal on the stack can be discarded by using the function
=INLINEFT
drop_main_goal
=TEX
{}
The discarded goal is returned by the function. Repeated calls of this function will empty the goal stack.

\begin{session}
=SML
drop_main_goal ();
=TEX
=GFT
Now 0 goals on the main goal stack
val it = ([], ¬m + 0 = m®) : GOAL
=TEX
\end{session}

\typeout{point 200}
\subsection{Tacticals}
\label{tacticals}

It is possible to do the whole of the above proof in one step, but this requires a compound
tactic built using the {\it tactical\/}\footnote{This word was invented by Robin
Milner: `tactical' is to `tactic` as `functional' is to `function'.} \ml{THEN\_LIST}.
Tacticals are higher order operations for combining tactics.


A {\it tactical\/} 
is an \SML\ function that returns a tactic (or tactics) as result.
Tacticals may take various parameters; this is reflected in the various
\SML\ types that the built-in tacticals have. Some important tacticals in 
the \HOL\ system
are listed below.



\typeout{point 210}

\subsubsection{\tt THEN\_LIST: TACTIC * TACTIC list -> TACTIC}
 
\typeout{point 211}
     
If $T$ is a tactic which produces $n$ subgoals and $T_1$, $\ldots$ ,
$T_n$ are tactics
then $T$\ml{THEN\_LIST } $[T_1, $ \ldots $ ,T_n]$ 

is a tactic which first applies $T$ and then
applies $T_i$ to the $i$th subgoal produced by $T$. 
The tactical \ml{THEN\_LIST} is useful if one wants to do different
things to different subgoals.

\ml{THEN\_LIST} can be illustrated by doing the proof of $\vdash \uquant{m}m+0=m$ in
one step.


\typeout{point 220}

\setcounter{sessioncount}{1}
\begin{session}
=SML  
g ¬(m +0) = m®;
=GFT
Now 1 goal on the main goal stack

(* *** Goal "" *** *)

(* ?ô *)  ¬m + 0 = m®

val it = () : unit   
=TEX

=SML 

a ((induction_tac ¬m:î®) THEN_LIST [(rewrite_tac ADD), (asm_rewrite_tac  ADD)]); 
=GFT
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit  
=TEX

\end{session}

\typeout{point 230}

\noindent The compound tactic:
\begin{quote}
\ml{ ((induction\_tac ¬m:î®) THEN\_LIST [(rewrite\_tac ADD), (asm\_rewrite\_tac ADD)])}
\end{quote}

first applies \ml{induction\_tac ¬m:î®} and then applies
\ml{rewrite\_tac ADD} to the first subgoal (the basis) and
\ml{asm\_rewrite\_tac ADD} to the second subgoal (the step). 

The tactical \ml{THEN\_LIST} is useful for doing different things to different
subgoals. The tactical \ml{THEN} can be used to apply the same tactic to all
subgoals.

\typeout{point 240}

\subsubsection{\tt THEN :TACTIC * TACTIC -> TACTIC }


The tactical {\small\verb%THEN%} is an \SML\ infix. If $T_1$ and $T_2$ are tactics,
then the \SML\ expression $T_1${\small\verb% THEN %}$T_2$ evaluates to a tactic
which first applies $T_1$ and then applies $T_2$ to all the subgoals produced by
$T_1$. 

In fact,
\ml{asm\_rewrite\_tac[ADD]} will solve the basis as well as the step
case of the induction for $m+0=m$, so there is an even
simpler one-step proof than the one above:
\setcounter{sessioncount}{1}


\begin{session}
=SML 
g ¬(m + 0) = m®; 
=GFT
Now 2 goals on the main goal stack

(* *** Goal "" *** *)

(* ?ô *)  ¬m + 0 = m®

val it = () : unit   
=TEX

=SML 
a ((induction_tac ¬m:î®) THEN  (asm_rewrite_tac ADD));
=GFT
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit   
=TEX
\end{session}


\typeout{point 250}


\noindent This is typical: it is common to use a single tactic for several
goals. Here is a sequence of examples:

\begin{session}
=SML 
val ADD_0 =
 tac_proof  (([],¬ (m + 0) = m®),
	     (induction_tac ¬m:î®) THEN (asm_rewrite_tac ADD));
=GFT
val ADD_0 = ô m + 0 = m : THM
=TEX

=SML 
val ADD_SUC =
 tac_proof 
   (([],¬((m + n) + 1) = (m + (n+1))®),
    (induction_tac ¬m:î®) THEN (asm_rewrite_tac ADD));
=GFT
val ADD_SUC = ô (m + n) + 1 = m + n + 1 : THM
=TEX

=SML 
val ADD_CLAUSES =
  tac_proof 
    ( ( [],  ¬ ((0 + m) = m				)  ±
       	       ((m + 0) = m				)  ±
               (((m+1) + n) = ((m + n) + 1)	)  ±
               ((m + (n+1)) = ((m + n) + 1)	) ®
      )
    ,
     rewrite_tac (ADD_0:: (ADD_SUC::ADD)) 
    );
=GFT
val ADD_CLAUSES = ô 
	0 + m = m ± m + 0 = m ± 
	(m + 1) + n = (m + n) + 1 ±
        m + n + 1 = (m + n) + 1 : THM
=TEX

\end{session}



\subsubsection{\tt REPEAT : TACTIC -> TACTIC}

If $T$ is a 
tactic then {\small\verb%REPEAT %}$T$ is a tactic which repeatedly applies
$T$ until it fails. This can be illustrated in conjunction with
\ml{simple\_µ\_tac}, which is specified by:


\begin{center}
\begin{tabular}{c} \\
$µx·t[x]$
\\ \hline \hline
$t[x']$
\\
\end{tabular}
\end{center}

\begin{itemize}
\item Where $x'$ is a variant of $x$ 
not free in the goal or the assumptions.
\end{itemize}

\noindent \ml{simple\_µ\_tac} strips off one quantifier; 
\ml{REPEAT\ simple\_µ\_tac} strips off all quantifiers:

\begin{session}
 
=SML 
g ¬ µx y z· (x + (y + z)) = ((x + y) + z ) ®; 
=GFT
Now 3 goals on the main goal stack

(* *** Goal "" *** *)

(* ?ô *)  ¬µ x y z· x + y + z = (x + y) + z®

val it = () : unit   
 
=TEX

=SML 
a  simple_µ_tac; 
=GFT
Tactic produced 1 subgoal:

(* *** Goal "" *** *)

(* ?ô *)  ¬µ y z· x + y + z = (x + y) + z®

val it = () : unit  =TEX

=SML 
a (REPEAT simple_µ_tac ); 
=GFT
(* ?ô *)  ¬x + y + z = (x + y) + z®
=TEX
\end{session}

\typeout{point 300}

\pagebreak
\subsection{Some tactics built into HOL}

This section contains a summary of some of the tactics built-in to the \HOL\ system
(including those already discussed).


Recall that the \SML\ type {\small\verb%thm_tactic%} abbreviates {\small\verb%theorem->tactic%}, 
and the type {\small\verb%conv%}\footnote{The type
{\small{\tt conv}} comes from Larry Paulson's theory of conversions
\cite{PAULSON83}.} abbreviates {\small\verb%term->thm%}.

\subsubsection{\tt rewrite\_tac:  THM list -> TACTIC}
\label{rewrite}

\begin{itemize}
\item{\bf Summary:} \ml{rewrite\_tac [} $th_1, \ldots ,th_n$  \ml{]}
simplifies the goal by rewriting
it with the explicitly given theorems $th_1$, $\ldots$ , $th_n$, 
and various built-in rewriting rules.


\begin{center}
\begin{tabular}{c} \\
$\{t_1, \ldots , t_m\}t$
\\ \hline \hline
$\{t_1, \ldots , t_m\}t'$
\\
\end{tabular}
\end{center}

\noindent where $t'$ is obtained from $t$ by rewriting with
\begin{enumerate}
\item  $th_1$, $\ldots$ , $th_n$ and
\item  the standard rewrites held in the \SML\ variable {\small\verb%basic_rewrites%}.
\end{enumerate}

\item{\bf Uses:} Simplifying goals using previously proved theorems.

\item{\bf Other rewriting tactics} (based on \ml{rewrite\_tac}):
\begin{enumerate}
\item \ml{asm\_rewrite\_tac} adds the assumptions of the goal to the list of
theorems used for rewriting.
\item \ml{fasm\_rewrite\_tac}{\small\verb% [%}$th_1${\small\verb%;%}$\ldots${\small\verb%;%}$th_n${\small\verb%]%} $p$
simplifies the goal by rewriting
it with the explicitly given theorems $th_1$ , $\ldots$ , $th_n$ , 
together with those
assumptions of the goal which satisfy the predicate $p$ and also
the built-in rewrites given by {\small\verb%get_basic_rewrites%}.
\item \ml{pure\_asm\_rewrite\_tac} is like \ml{asm\_rewrite\_tac}, but it
doesn't use any built-in rewrites.
\item \ml{pure\_rewrite\_tac} uses neither the assumptions nor the built-in
rewrites
\end{enumerate}
\end{itemize}


\subsubsection{\tt taut\_tac: TACTIC}




\begin{itemize}

\item{\bf Summary:} Solves a goal the conclusion of which is a tautology

\item{\bf Uses:} Solving tautological goals. \ml{taut\_tac} is invoked by other built-in tactics.  

\end{itemize}

Example:
\begin{session}
=SML 
g ¬ ( x = 3) ²  ³ (x = 3)®;
=GFT
Now 4 goals on the main goal stack

(* *** Goal "" *** *)

(* ?ô *)  ¬x = 3 ² ³ x = 3®

val it = () : unit 
=TEX
=SML 
a taut_tac;
=GFT
Tactic produced 0 subgoals:
Current and main goal achieved
val it = () : unit  
=TEX

=SML 
g ¬µx· (x = 3 ) ²  ³(x = 3)®;
=GFT
Now 5 goals on the main goal stack

(* *** Goal "" *** *)

(* ?ô *)  ¬µ x· x = 3 ² ³ x = 3®

val it = () : unit
=TEX

=SML 
a taut_tac;
=GFT
Exception-
   Fail * Conclusion of the goal is not a tautology [taut_tac.28121] * raised

=TEX
\end{session}

\subsubsection{\tt ±\_tac: TACTIC}

\begin{itemize}

\item{\bf Summary:} Splits a 
goal \ml{¬$t_1$ ± $t_2$®} into two subgoals  \ml{¬$t_1$ ®} 
and  \ml{¬ $t_2$®}.

\begin{center}
\begin{tabular}{c} \\
$t_1${\small\verb% /\ %}$t_2$
\\ \hline \hline
$t_1\ \ \ \ \ \ t_2$
\\
\end{tabular}
\end{center}

\item{\bf Uses:} Solving conjunctive goals. 
\ml{±\_tac} is invoked by \ml{strip\_tac} (see below).

\end{itemize}




\subsubsection{\tt ´\_tac: TACTIC }

\begin{itemize}

\item{\bf Summary:} Moves the antecedant 
of an implicative goal into the assumptions.

\begin{center}
\begin{tabular}{c} \\
$u$ \ml{´}$v$
\\ \hline \hline
$\{u\}v$
\\
\end{tabular}
\end{center}


\item{\bf Uses:} Solving goals of the form 
\ml{¬$u$´$v$®} by assuming \ml{¬$u$®}  and then solving \ml{¬$v$® }.
\ml{strip\_tac} (see below) will invoke \ml{´\_tac} on implicative goals.
\end{itemize}

\subsubsection{\tt simple\_µ\_tac: TACTIC}

\begin{itemize}

\item{\bf  Summary:} Strips off one universal quantifier.
   

\begin{center}
\begin{tabular}{c} \\
$µx·t[x]$
\\ \hline \hline
$t[x']$
\\
\end{tabular}
\end{center}

\noindent Where $x'$ is a variant of $x$ 
not free in the goal or the assumptions.

\item{\bf   Uses:} Solving universally quantified goals. 
\ml{REPEAT simple\_µ\_tac } strips off all
universal quantifiers and is often the first thing one does in a proof.

\ml{strip\_tac} (see below)  applies \ml{simple\_µ\_tac} to universally quantified goals.
\end{itemize}


\subsubsection{\tt IMP\_RES\_TAC : tactic}

This section to be rewritten.

\begin{itemize}

\item{\bf Summary:} {\small\verb%IMP_RES_TAC %}$th$
`resolves' (see below) $th$ with the 
assumptions of the goal
and then adds the results to the assumptions.


\begin{center}
\begin{tabular}{c} \\
$\{t_1,\ldots,t_m\}t$
\\ \hline \hline
$\{t_1,\ldots,t_m,u_1,\ldots,u_n\}t$
\\
\end{tabular}
\end{center}

\noindent  where $u_1$, $\ldots$ , $u_n$ 
are derived by `resolving' $th$ with $t_1$, $\ldots$ , $t_m$. 
Resolution in \HOL\ 
is not classical resolution, but just Modus Ponens
with a bit of one-way pattern matching (not unification). The usual case
is where $th$ is of the form

$\ \ \ ${\small\verb%|- !%}$x_1$$\ldots x_p${\small\verb%.%}$v_1${\small\verb%==>%}$v_2${\small\verb%==>%}$\ldots${\small\verb%==>%}$v_q${\small\verb%==>%}$v$. 

\noindent {\small\verb%IMP_RES_TAC %}$th$ then tries
to specialize $x_1$, $\ldots$ , $x_p$ 
so that  $v_1$, $\ldots$ , $v_q$ 
match members of $\{t_1,\ldots ,t_m\}$.
If such a match is found then the appropriate instance of $v$ is added
to the assumptions, together with all appropriate instances of 
$v_i${\small\verb%==>%}$\ldots v_n${\small\verb%==>%}$v$ ($2 \leq i \leq n$). 
{\small\verb%IMP_RES_TAC%} can also be given a conjunction of implications,
 in which case 
it will do
`resolution' with each of the conjuncts. In fact, 
it applies a canonicalization
rule to its argument to split it into a list of theorems.
Each theorem produced by this canonicalization process 
is resolved with the assumptions. Full details can be found in 
\REFERENCE\ (the canonicalization in \HOL\
is based on that done in Cambridge \LCF \cite{PAULSON87}, 
but differs slightly from it).

\item{\bf Uses:} Deriving new assumptions from existing 
ones and previously proved theorems
so that subsequent tactics (\eg\ \ml{asm\_rewrite\_tac}) have 
more to work with.
\end{itemize}


        
\subsubsection{\tt strip\_tac  : TACTIC}

\begin{itemize}

\item{\bf Summary:} Breaks a goal apart.
\ml{strip\_tac} removes one outer connective from the goal, using
\ml{±\_tac}, \ml{´\_tac},  \ml{simple\_µ\_tac}, \etc\  
If the goal has the form\ml{ $t_1$  ± $\cdots$ ± $t_n$ ´ $t$}
then each  $t_i$  is made into a  separate assumption.

\item{\bf Uses:} Useful for spliting a goal up into manageable pieces. 
Often the best thing to do first is \ml{REPEAT strip\_tac}.
\end{itemize}



\subsubsection{\tt id\_tac : tactic}

\begin{itemize}
\item{\bf Summary:} Identity tactic for the tactical {\small\verb%THEN%}
(see end of Section~\ref{tactics}).

\item{\bf Uses:}
\begin{enumerate}
\item Writing tacticals (see description of {\small\verb%REPEAT%} 
in Section~\ref{tacticals}). 
\item With {\small\verb%THEN_LIST%}; for example, if tactic $T$ produces two subgoals 
and we want to apply $T_1$ 
to the first one but to do nothing to the second, then 
the tactic to use is $T${\small\verb% THEN_LIST[%}$T_1${\small\verb%;id_tac]%}.
\end{enumerate}
\end{itemize}

\subsubsection{\tt fail\_tac : tactic}

\begin{itemize}
\item{\bf Summary:} Tactic that always fails.

\item{\bf Uses:} Writing tacticals.
\end{itemize}

\makeatletter   




% \newpage
% \twocolumn[\section{INDEX}]
% \small
% \printindex

\end{document}




=IGNORE
:\footnote{At the time of writing the corresponding tactic is not available in the product, and when it is will not be called \ml{INDUCT\_TAC}.  As a temporary measure, just to see how the examples come out, we use an ad-hoc definition of a tactic, calling it \ml{INDUCT\_TAC} for the time being.

=SML 
fun  I_fn  (asl,c) =
  let val p = mk_Ì (dest_µ c)
      val P5 = get_axiom  "Peano" "P5"
  in
      undisch_rule (rewrite_rule [] (simple_µ_elim  p P5))
  end;

fun I_tac (g : GOAL) =
  let val K = I_fn g 
      val h = hd (hyps K)
      val (h1,h2) = dest_± h
  in 
      ([((fst g),h1), ((fst g), h2)],    fn [g1, g2] =>  ´_elim (disch_rule h  K) (±_intro g1 g2)  )
  end; 

val INDUCT_TAC = (I_tac THEN (REPEAT strip_tac));
=TEX

}   % end footnote
=TEX


