To be included as the section `THE ICL HOL GRAMMAR'
=TEX

The grammar of the ICL~HOL language is divided into a number of
parts which build to form the whole language. These are given
in the subsection of section~\ref{CollectedGrammar} below.
Section~\ref{FurtherExplanation}
completes the explanation of the grammar by describing the purpose of
those alternatives not fully described with their definition.

%********************************************************************

\subsection{Collected Grammar} \label{CollectedGrammar}

The grammar for HOL is given in sections~\ref{Term}-\ref{LocalDef}
below in terms of the following terminal symbols:

{\it AqTm,
AqTy,
Binder,
InTmOp,
InTyOp,
Name,
PostOp,
PreOp,
`and',
`else',
`if',
`in',
`let',
`then',
`$·$',
`\verb","',
`\verb"("',
`\verb")"',
`\verb":"',
`\verb";"',
`\verb"["',
`\verb"]"',
`\verb"{"',
`\verb"|"',
`\verb"}"'.}

The rules whereby a fragment of text is construed as a sequence of
these terminal symbols are given in section~\ref{LEXICALANALYSIS} below.

Sections~\ref{Term} and \ref{Types} give productions for HOL terms
and types.
Sections~\ref{PairedAbs}-\ref{LocalDef} give productions for certain
auxiliary nonterminals used in the productions for terms.

\subsubsection{Terms} \label{Term}

To specify the concrete syntax for terms an ambiguous grammar is given,
together with rules to say how any ambiguity in parsing a sentence
should be resolved.  The comments against the grammar productions refer
to the sections where additional grammar rules and explanations are
given.  The order of presentation of the additional grammar rules and
the explanatory text is chosen to aid the reader, a consequence of this
ordering is that the section numbers referenced in the comments in the
grammar below are not in ascending order.

% The identities of the notes below are surrounded by ! and . characters to
% make them easier to find with editors etc.  The ! and . are redefined
% to allow access to the LaTeX command \ref{} within formal text.
{\catcode`\!=\active
\def!#1.{\ref{#1}}

{
\ftlinepenalty=10000
=GFT BNF
	Tm	=	Binder, BndVars, `·`, Tm		(* !BinderAbbrev. *)
		|	`let`, L, { `and`, L }, `in`, Tm	(* !LocalDef. *)
		|	`if`, Tm, `then`, Tm, `else`, Tm	(* !NOTEcond. *)
		|	OTm					(* !NOTEInTmOp. *)
		|	Tm, `:`, Ty				(* !Types. *)
		|	Tm, Tm				(* !NOTEjuxta. *)
		|	Name					(* !NOTEname. *)
		|	AqTm					(* !Antiquotation. *)
		|	`{`, OptTms, `}`			(* !SetExpr. *)
		|	`{`, V, `|`, Tm, `}`			(* !SetExpr. *)
		|	`(`, Tm, `)`				(* !NOTEbracket. *)
		|	`[`, OptTms, `]`;			(* !ListExpr. *)

	OTm	=	(	Tm, InTmOp, Tm		(* !NOTEInTmOp. *)
				| PreOp, Tm			(* !NOTEpreop. *)
				| Tm, PostOp	)		(* !NOTEpostop. *)
	OptTms   =	[ Tm, { `;`, Tm } ];
=TEX
}

Ambiguities are to be resolved by the following rules:

\begin{enumerate}

\item The alternatives for $Tm$ above are listed in order of increasing
	precedence, i.e. if a given sentence can be parsed according to
	two distinct alternatives then the alternative which comes earlier
	in the list above is to be preferred.  For example, the sentence
		`$ Ìx· t  = u $' would be parsed as
		`$ Ìx·(t  = u)$' rather than as
		`$(Ìx· t) = u $' by this rule.
	Note that this rule does not apply to the alternatives for $OTm$,
	which are disambiguated by a system of numeric
	precedences, see rule~\ref{PriorityRule} below.

\item \label{TypeRule} A term containing a type must be parsed so that
	each type extends as far to the right as possible.  For
	example, `$t:Ó‰1\;Ó‰2:Ó‰3$' must be parsed so that the types it
	contains are `$Ó‰1\;Ó‰2$' and `$Ó‰3$' (not `$Ó‰1$' and `$Ó‰3$').
	This term might be rewritten as `$(t:Ó‰1\;Ó‰2):Ó‰3$' indicating
	that types `$Ó‰1\;Ó‰2$' and `$Ó‰3$' are equivalent, and that
	`$t$' has that type.


%	Also, sections !NOTEpreop.\ and !NOTEpostop.
\item \label{PriorityRule} Infix, prefix and postfix function
	applications (see section~!NOTEInTmOp.) associate according to their
	associated precedences.  Higher values of precedence bind more
	tightly than lower values.  Equal values of precedence associate
	to the right.  Brackets may be used to force a different order
	of association.  Defining the precedences of the standard HOL
	operators is outside the scope of this document.

\item Juxtaposition (see section~!NOTEjuxta.) associates to the
	left.  For example, if a sentence can be parsed as both
	`$(f\;t)\;u$' and `$f(t\;u)$', the former is preferred.

\end{enumerate}
}
%********************************************************************

\subsubsection{Types} \label{Types}

Terms may be explicitly given a type, perhaps to aid a reader of the HOL, or
to assist with type inference.

The syntax for types is given by the nonterminal $Ty$ in the following
grammar.
Note that the
grammar for types is ambiguous, but the text that follows shows how to
disambiguate it.

=GFT BNF
	Ty	=	Name		| AqTy			| Typars, Name
		|	Ty, InTyOp, Ty	| `(`, Ty, `)`;
	Typars	=	Ty		| `(`, Ty, { `,`, Ty }, `)`;
=TEX

Type variables and nullary type constants
are included under the first alternative, $Name$, here.
In general a type is either such a name or an antiquotation
(see section~\ref{Antiquotation}), or a
type constructor applied to a list of types.
Binary type constructors may be written with infix or postfix syntax;
other type constructors are always written as postfix operators, and if
they take more than one argument, the arguments are given as a comma-separated
list enclosed in brackets.
Brackets may be used, e.g., to group the arguments of infix type constructors.

The binary type
constructors for product, sum, and function (written as `¸',
`$+$' and `­' respectively) are typical examples of infix type operators.

Ambiguities in the grammar are resolved using the following rules:

\begin{enumerate}
\item
The postfix form is of higher precedence than the infix.
\item
Infix type constructors are assigned a precedence when their infix status
is declared (see section~\ref{ControlofLexicalAnalysisandParsing}.
Higher values of precedence bind more tightly than lower
values.
Equal values of precedence associate to the right. 
\end{enumerate}

%********************************************************************

\subsubsection{Paired Abstractions} \label{PairedAbs}

Paired abstractions are used, for example, in {\bf let} terms
(see section~\ref{LocalDef}) where several (possibly typed) values are
to be defined at one time, and similarly in binder terms.  For
example we wish to write fragments of HOL such as the following.

=GFT HOL fragments
	let (a,b) = ...
	let (a,(b,(c,d),e)) = ...
	Ì (a,b) · ...
	Ì (a,(b,(c,d),e)) ·  ...
=TEX

This leads to the BNF syntax rule for the nonterminal $V$
for these paired abstractions --- note the $V$ denotes `varstruct.'

=GFT BNF
	V	= 	V1, [ `:`, Ty ];
	V1	= 	Name	|	`(`, V, { `,`, V }, `)`;
=TEX

\subsubsection*{Interpretation}

A paired abstraction stands for an application of the constant
$Uncurry$ which turns a function of two arguments into
a function of a single argument pair. For example,
$Ì (a, b) · t$ denotes $Uncurry(Ìa\,b·t)$.
Similarly $let (a,b) = c\,in\,t$ denotes
$Let(Uncurry(Ì (a, b) · t))c$ (cf. section~\ref{LocalDef} below).

%********************************************************************

%\newpage
\subsubsection{Binder Abbreviation} \label{BinderAbbrev}

Within binder constructs we allow paired abstractions.  We also allow
the abbreviation of a nested set of binders so that the binder name is
only given once.  These names may be explicitly typed in the same way
as paired abstractions, or lists of paired abstractions may typed
together, using semicolons to separate the lists.
For example we wish to write fragments of HOL such as the
following.

=GFT HOL fragments
	µ x y z x‰1 y‰1 ·
	µ x : bool ·
	µ (x,y) ·
	µ x y : bool; ·
	µ x y : bool; z x‰1 : î ·
	µ (x : bool, y : num) ·
	µ (x,y) : (bool ¸ bool) ·
	µ (x,y) ((z,x‰1),y‰1) ·
	µ (x,y) (z,x‰1) (y‰1,z‰1) : bool ¸ bool; x‰2 y‰2; z‰2 : î ·
=TEX

Note that the effect of the second semicolon in the last example is
to stop the type constraint on $z‰2$ applying to $x‰2$ and $y‰2$.

The intention of the grammar of binders is that the binder ranges over
a series of blocks of bound variables, which are given by rule $BndVars$
below.  Each block may declare many names or many paired abstractions
and is optionally typed. The blocks are separated by semicolons.

=GFT BNF
	BndVars		=	Block, {`;`, Block };
	Block		=	V1, { V1 }, [ `:`, Ty ];
=TEX


%--------------------------------------------------------------------

\subsubsection*{Interpretation}

The binder term `$Ìx·t$' denotes a use of the `$mk\_abs$'
constructor with the terms $x$ and $t$ as its arguments.  More complex
uses of binders can be understood from the following four HOL fragments
which have equivalent meanings.

=GFT HOL fragments
	µ x‰1 x‰2 x‰3 x‰4 · T
	µ x‰1· µ x‰2· µ x‰3· µ x‰4 · T
	µ x‰1· (µ x‰2· (µ x‰3· (µ x‰4· T)))
	($ µ)(Ì x‰1·(($ µ) Ì x‰2·(($ µ) Ì x‰3·(($ µ) Ì x‰4 · T))))
=TEX

The use of `\$' in the above to suppress the binder status of
the name\footnote
{Note that, in contrast to Cambridge HOL, binder names are not restricted to constants
but may also be variables.}
`$µ$' is discussed in section~\ref{LexicalAnalysis} below.

%********************************************************************

\subsubsection{Local Definitions} \label{LocalDef}

Terms may have local definitions, within {\bf let} clauses.  These
definitions may be of functions.  One {\bf let} clause may have several local
definitions.  For example we wish to write fragments of HOL such as the
following.

=GFT HOL fragments
	let x = ... in ...
	let f x = ... in ...
	let f (x‰1,x‰2) (y‰1,(y‰2,y‰3),y‰4) = ... in ...
	let x = ... and f x = ... and g f (x,b) (y‰1,(y‰2,y‰3),y‰4) = ... in ...
=TEX

For a local function the intention is that we give its name followed by
its argument patterns, which are a sequence of (optionally typed)
paired abstractions.  Production $L$ below gives
the part of the clauses between the {\bf let} or {\bf and} keywords and
the `in'.

=GFT BNF
	L	=	Vs `=`, Tm;
	Vs	=	V		| Name, V1s;
	V1s	=	V1		| V1s, V1;
=TEX
Thus if there is a list of varstructs after the {\bf let} or {\bf and}
the first one must just be a name. 
%--------------------------------------------------------------------

\subsubsection*{Interpretation}

A {\bf let} clause actually denotes the application of the constant
$Let$ to a lambda abstraction.  The following pairs of HOL fragments
are equivalent.

=GFT Equivalent HOL terms
	let x = t in u
	Let(Ì x · u) t
=TEX

=GFT Equivalent HOL terms
	let x = t and y = u and z = v in w
	Let(Let(Let(Ì x y z · w)t)u)v
=TEX

=GFT Equivalent HOL terms
	let x = t in let y = u in let z = v in w
	Let(Ì x · Let(Ì y · Let(Ì z · w)v)u)t
=TEX

Note that the left-hand side of a local definition is not in scope
in the right-hand side. Thus in e.g.,
$let\,f\,x=f\,x\, in\,b$, the local definition is not recursive since
the second occurrence  of
$f$ is treated as a free occurrence of $f$ rather than being
bound by the first occurrence of $f$.

\subsection{Explanations of the Grammar} \label{FurtherExplanation}

The above sections gave the full grammar of ICL~HOL and the description
of parts of it.  The next sections complete the description.

%********************************************************************

%********************************************************************

\subsubsection{Lists} \label{ListExpr}

The square bracket notation is for lists.  Elements of lists
are separated by semicolons, and the empty list is allowed.

%--------------------------------------------------------------------

\subsubsection*{Interpretation}

The list `$[t;\;u;\;v\;\ldots]$' denotes
`$Cons\;t(Cons\;u(Cons\;v(\ldots Nil)\ldots)))$', and the empty list
`$[\;]$' denotes `$Nil$.'

%********************************************************************

\subsubsection{Set Terms} \label{SetExpr}

Set terms may be given in two forms.  Either by enumeration of
the values, or by set comprehension.  See also
section~\ref{CompareSets}.  Examples of set terms are as
follows.

=GFT HOL fragments
	{1; 4; 9; 16; 55}
	{x | ¶ y : î · y ¼ 5 ± x = y * y}
	{(x,y) | x ¾ y}
=TEX

%--------------------------------------------------------------------

\subsubsection*{Interpretation}

The set `$\{t;\;u;\;v\;\ldots\}$' denotes
`$Insert\;t(Insert\;u(Insert\;v(\ldots Empty)\ldots)))$', and the empty
set `$\{\;\}$' denotes `$Empty$.'

A set comprehension denotes the constant $SetComp$ applied to a lambda
term.  The set  `$\{x|p\}$' denotes `$SetComp(Ì x
· p)$.'

%********************************************************************

\subsubsection{Conditionals} \label{NOTEcond}

Conditionals are of the form `$if$ condition $then$ consequence
$else$ alternative.'  See also section~\ref{CompareCond}.

%--------------------------------------------------------------------

\subsubsection*{Interpretation}

The conditional form denotes an application of the polymorphic constant
`$Cond$'.  The conditional `$if\;t\;then\;u\;else\;v$' denotes the term
`$Cond\;\;t\;\;u\;\;v$.'

%********************************************************************

\subsubsection{Juxtaposition} \label{NOTEjuxta}

Juxtaposition denotes the application of a function
to an argument, e.g. $f\,a$ denotes application of $f$ to $a$.
This corresponds to the primitive $mk\_comb$.

%--------------------------------------------------------------------

%\subsubsection*{Interpretation}

%********************************************************************

\subsubsection{Infix, Prefix and Postfix Operators}
\label{NOTEInTmOp} \label{NOTEpreop} \label{NOTEpostop}

As described in section~\ref{ControlofLexicalAnalysisandParsing} below
the user may declare that a name\footnote
{Note that, in contrast to Cambridge HOL, operator names need not necessarily be constants;
they may be variables with associated fixity syntax.}
is to be used with infix,
prefix or postfix syntax.
A numeric precedence is assigned to the name in such a declaration
and is used to determine the order of
application, as described in rule~\ref{PriorityRule} of
section~\ref{Term}, and illustrated by the following examples.

Assuming that `$I1$', `$I4$', `$R2$', `$R5$', `$S3$' and `$S6$' are two
infix, two prefix and two postfix operators respectively with
precedences as given in the name (i.e., precedences of 1, 4, 2, 5, 3 and
6 respectively) then the brackets in the following examples are
redundant.

=GFT HOL fragments
	(t I4 u) I1 v		t I1 (u I4 v)		(t I4 u) I4 v
	R2 (R5 t)		R5 (R2 t)
	(t S6) S3		(t S3) S6
	(R5 t) S3		R2 (t S6)
	(R5 t) I1 (u S6)	R2 ((t I4 u) S3)
=TEX

%--------------------------------------------------------------------

\subsubsection*{Interpretation}

These forms simply provide additional ways of expressing
function application. For example, in each of the following three
examples the two terms shown are equivalent. In these examples,
we use the `\verb"$"' symbol to suppress the infix, prefix or
postfix status of an identifier (as described in
section~\ref{LEXICALANALYSIS} below).

=GFT Equivalent HOL terms
	 l   i_op   r 
	 ($i_op   l)   r 
=TEX

=GFT Equivalent HOL terms
	 pre_op   a 
	$pre_op   a 
=TEX

=GFT Equivalent HOL terms
	 a   post_op 
	 $post_op   a 
=TEX


%********************************************************************

\subsubsection{Names of Variables and Constants} \label{NOTEname}

This alternative is for variables and constants, it includes any identifier
which has not been declared to have special syntactic status
(as defined in section~\ref{ControlofLexicalAnalysisandParsing} below)
and which is not escaped by preceding it with a `\verb"$"'.

For example with typical binder declarations, `\verb"$"$µ$' is the name of
the universal quantification operation considered as a constant in
its own right, whereas `$µ$' is not a name.
%--------------------------------------------------------------------

%\subsubsection*{Interpretation}

%********************************************************************

\subsubsection{Grouping} \label{NOTEbracket}

Brackets may be used to override the precedence and precedence rules.

%--------------------------------------------------------------------

%\subsubsection*{Interpretation}

%********************************************************************

\subsubsection{Antiquotation} \label{Antiquotation}

ICL~HOL on some systems will provide antiquotation.  This allows a
metalanguage value representing a HOL term or a HOL type to be taken as part
of a term or type. The metalanguage value may be the result of evaluating
a metalanguage expression or of invoking a parser for some other language
such as Z.

The precise format of antiquotations is implementation dependent.
They will typically be implemented using the macro-processing facilities
defined in \cite{DS/FMU/IED/DEF002}.
Antiquotations are treated as terminal symbols in the grammar, with the
names `$AqTm$' and `$AqTy$' for term and type antiquotations
respectively.

%--------------------------------------------------------------------

%\subsubsection*{Interpretation}

