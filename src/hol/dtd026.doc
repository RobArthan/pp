=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design of Rewriting Rules and Tactics}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Rewriting Inference Rules}
\TPPref{DS/FMU/IED/DTD026}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
\TPPauthors{K.~Blackburn & WIN01\\R.D.Arthan & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the detailed design for the 
rewriting rules (including conversions) and tactics for ICL HOL.
It also describes canonicalisation.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Moved tautology material to \cite{DS/FMU/IED/DTD027}.
Some issues clarified in text.
Introduced $set\_rewrite\-\_convs$.
\item [Issue 1.3]
Added failure 26001 to inference rules.
\item [Issue 1.4]
Added tactics.
\item [Issue 1.8)]
Added canonicalisation and basic rewrites.
\item [Issue 1.9]
Added theorem tactic formulations of rewriting.
\item [Issue 1.10]
Various minor mods as a result of testing canons.
\item [Issue 1.11]
All rewrite functions now fail when applying an equation produces no change.
\item [Issue 1.12]
Tidying up.
\item [Issue 1.13]
Re-implementation to follow ideas of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.14]
Reacting to issue 1.5/6 of \cite{DS/FMU/IED/DTD051}.
\end{description}
\subsection{Changes Forecast}
The move of $evaluate\_proof\_context$ to after the resolution
material, when it arrives.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
rewriting rules, conversions and tactics, and some auxiliary material.
This is called for in section \cite{DS/FMU/IED/HLD009}.
The design is implemented in \cite{DS/FMU/IED/IMP026}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the rewriting
derived rules, conversions and tactics for ICL HOL.

``Rewriting'' is a process of traversing a goal, theorem or term instantiating members of a set of equational theorems to match sub-terms encountered, and using the instantiations to infer a new goal, theorem, or an equational theorem.
We have enhanced the rewriting facilities in ICL HOL to apply
conversions.
In this context a conversion is viewed as a function capable of deriving an equational theorem, which is given
as an argument the LHS that the resulting equation must have.

An auxiliary topic needs covering to describe
rewriting.
It is canonicalisation, which is basically
the process of taking a theorem and producing equational theorems from it.
The process is configurable.

All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP026}.
\subsubsection{Dependencies}
Though this document depends upon \cite{DS/FMU/IED/IMP028}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Terminology}
A {\em conversion net} is more properly called a conversion discrimination net: discrimination nets are described in 
\cite{DS/FMU/IED/DTD008}.
\section{INFIX DIRECTIVES}
The following canonicalisation function combinators are used with
infix notation:
=SML
infix 4 THEN_CAN;
infix 4 ORELSE_CAN;
infix 4 THEN_LIST_CAN;
=TEX
\section{START OF THE SIGNATURE}
=DOC
signature âRewritingá = sig
=DESCRIBE
This provides the derived rewriting rule, conversions and
tactics for ICL HOL.
=ENDDOC
\section{CANONICALISATION}
\subsection{Discussion}\label{CANONICALISATIONDiscussion}
We will use the term
{\em canonicalisation} for an operation which transforms a theorem (or list
of theorems) into a list of theorems all of which share some property.
An example of a canonicalisation is the parameter to
the primitive rewrite conversion which transforms
lists of theorems into lists of equational theorems.
Another example might be reduction to clausal form.
 
For the present example,
the rewriting canonicalisation might be something like the following:

\begin{enumerate}
\item
stripping universal quantifiers;
\item
dividing conjunctive theorems into their conjuncts (and then recursively
transforming these);
\item
changing $…Œt$ to $t ‚ F$;
\item
if none of the above apply, changing $…t$ to $…t ‚ T$.
\end{enumerate}

however, application-specific transformations might apply, e.g. removing
universal quantifiers in languages other than HOL. In fact the above is
a simplification of what we actually propose
(in section \ref{CanonicalisationForRewriting} below)
for the rewriting canonicalisation.

To give a simple but general framework for handling canonicalisation, we
introduce a family of combinators for functions of type
$THM->THM\,list$. These allow a recursive process like the above-mentioned
rewriting canonicalisation to be extended piecemeal: 
for instance the code
for the standard rewriting canonicalisation contains the fragment:
ó
REPEAT_CAN (FIRST_CAN <list of canonicalisations>)
æ

The canonicalisation combinators are very straightforward to implement; indeed,
they are even simpler than the combinators for tactics and conversions.
They may also prove useful in other contexts.

\subsection{The Canonicalisation Combinators}

=DOC
type âCANONá 		(* 	= THM -> (THM list)	*);
=DESCRIBE
This is the type abbreviation for a canonicalisation function; such functions
are typically used to derive consequences of a theorem meeting some desired
criteria. An example is the rewriting canonicalisations which are used to transform theorems
into lists of equational theorems for use in the rewriting conversions, rules
and tactics.

Combinators are available to assist in the construction of new
canonicalisation functions from old.
=SEEALSO
$id\_can$, $fail\_can$, $THEN\_CAN$, $ORELSE\_CAN$, $REPEAT\_CAN$, $FIRST\_CAN$,
$EVERY\_CAN$.
=ENDDOC

=DOC
val âid_canoná 	: CANON
=DESCRIBE
This is the identity for the canonicalisation function combinator
$THEN\_CAN$:
ó
id_canon thm = [thm]
æ
=SEEALSO
$fail\_can$, $THEN\_CAN$, $ORELSE\_CAN$, $REPEAT\_CAN$, $FIRST\-\_CAN$,
$EVERY\-\_CAN$.
=ENDDOC

=DOC
val âfail_canoná 	: CANON
=DESCRIBE
This is a canonicalisation function which always fails.
It is the identity for $ORELSE\_CAN$.
=SEEALSO
$id\_can$, $fail\_with\_can$, $THEN\_CAN$, $ORELSE\_CAN$, $REPEAT\_CAN$, $FIRST\_CAN$,
$EVERY\_CAN$.
=FAILURE
26201	Failed as requested
=ENDDOC

=DOC
val âfail_with_canoná :	string -> int -> (unit -> string) list -> CANON
=DESCRIBE
This is a canonicalisation function which always fails by passing its
arguments to $fail$ (q.v.).
=SEEALSO
$fail\_can$
=ENDDOC
=DOC
val âTHEN_CANá : (CANON * CANON) -> CANON
=DESCRIBE
$THEN\_CAN$ is a canonicalisation function combinator written as an infix
operator. $(can1\,THEN\_CAN\,can2)thm$ is the result of
applying $can2$ to each of the theorems in the list $can1\,thm$ and then
flattening the resulting list of lists.
=SEEALSO
$id\_can$, $fail\_can$, $THEN\_LIST\_CAN$, $ORELSE\_CAN$, $REPEAT\-\_CAN$, $FIRST\-\_CAN$,
$EVERY\-\_CAN$.
=ENDDOC

=DOC
val âTHEN_LIST_CANá : (CANON * CANON list) -> CANON
=DESCRIBE
$THEN\_LIST\_CAN$ is a canonicalisation function combinator written as an infix
operator. $(can1\,THEN\_CAN\,cans)thm$ is the result of
applying each element of the list $cans$ to the
corresponding element of the list $can1\,thm$ and then
flattening the resulting list of lists.
=SEEALSO
$id\_can$, $fail\_can$, $THEN\_CAN$, $ORELSE\_CAN$, $REPEAT\_CAN$, $FIRST\_CAN$, $THEN\-\_CAN$,
$EVERY\-\_CAN$.
=FAILURE
26204	wrong number of canonicalisation functions in the list
=ENDDOC

=DOC
val âORELSE_CANá : (CANON * CANON) -> CANON
=DESCRIBE
$ORELSE\_CAN$ is a canonicalisation function combinator written as an infix
operator. $(can1\,ORELSE\_CAN\,can2)thm$ is the same $can1\,thm$ unless evaluation
of $can1\,thm$ fails in which case it is the same as $can2\,thm$.
=SEEALSO
$id\_can$, $fail\_can$, $THEN\_CAN$, $REPEAT\_CAN$, $FIRST\_CAN$,
$EVERY\-\_CAN$.
=ENDDOC

=DOC
val âEVERY_CANá : CANON list -> CANON
=DESCRIBE
$EVERY\_CAN$ is a canonicalisation function combinator which combines
the elements of its argument using $THEN\_CAN$:
ó
EVERY_CAN [can1, can2, ...] = can1 THEN_CAN can2 THEN_CAN ...
æ
=SEEALSO
$id\_can$, $fail\_can$, $THEN\_CAN$, $REPEAT\_CAN$, $FIRST\-\_CAN$.
=ENDDOC

=DOC
val âFIRST_CANá : CANON list -> CANON
=DESCRIBE
$FIRST\_CAN$ is a canonicalisation function combinator which combines
the elements of its argument using $ORELSE\_CAN$:
ó
FIRST_CAN [can1, can2, ...] = can1 ORELSE_CAN can2 ORELSE_CAN ...
æ
=SEEALSO
$id\_can$, $fail\_can$, $THEN\_CAN$, $REPEAT\_CAN$, $EVERY\-\_CAN$,
=FAILURE
26202	the list of canonicalisation functions is empty
=ENDDOC

=DOC
val âREPEAT_CANá : CANON -> CANON
=DESCRIBE
$REPEAT\_CAN$ is a canonicalisation function combinator which repeatedly
applies its argument until it fails:
ó
REPEAT_CAN can thm =
	((can THEN_CAN REPEAT_CAN can) ORELSE_CAN id_can) thm
æ
=SEEALSO
$id\_can$, $fail\_can$, $THEN\_CAN$, $REPEAT\_CAN$, $EVERY\-\_CAN$,
=ENDDOC
\subsection{Canonicalisation For Rewriting}\label{CanonicalisationForRewriting}
The discussion in section \ref{CANONICALISATIONDiscussion}
of canonicalisation for rewriting actually
described a simpler process than the one which we adopt for standard use
(i.e. place in the initial rewriting proof context
with $set\_epc\_rw\_canon$).

We adopt the following criteria for the rewriting canonicalisations that ICL will supply:

\begin{enumerate}
\item
given $…a$, they should guarantee that $rewrite\_tac$ will prove a goal
with conclusion $a$ providing it terminates;
\item
they should be relatively efficient (say, linear in the number of connectives
in the theorem being rewritten);
\item
they should generate as many useful equations as can conveniently be done
within the above constraints.
\end{enumerate}

Given the basic rewrites discussed in section \ref{BASICREWRITES}
below, the criteria are met by repeated application of the first applicable
operation in the following list:

\begin{enumerate}
\item
stripping universal quantifiers;
\item
dividing conjunctive theorems into their conjuncts;
\item
changing $…Œ(t1  t2)$ to $Œt1 € Œt2$;
\item
changing $…Œ„xt$ to $ƒxŒt$;
\item
changing $…Œt$ to $t ‚ F$;
\item
if none of the above apply, changing $…t$ to $…t ‚ T$.
\end{enumerate}

The point here is that we move negations through disjunctions and existential
quantifiers because that can increase the number of useful equations we get
without prejudicing criterion 1 (by dint of the basic rewrites which
can evaluate disjunctions and existential terms in which the operands or body
is $T$).

After all this canonicalisation we then universally quantify
the resulting theorems in all free variables only in the conclusions, other than those
that were free in the original.

A variant canonicalisation would strip implications
into the assumption list, as well as adding the unstripped form.
The effects caused by this could be unfortunate if unconstrained,
and so it is not adopted as the default action.

=DOC
val â€_rewrite_canoná : THM -> THM list
val âsimple_Œ_rewrite_canoná : THM -> THM list
val â‚_t_rewrite_canoná : THM -> THM list
val âsimple_ƒ_rewrite_canoná : THM -> THM list
=DESCRIBE
These are some of the standard canonicalisation functions used for breaking theorems up into
lists of equations for use in rewriting. They perform the following
transformations:
ó
€_rewrite_canon			(ö … t1 € t2)		= ö … t1 ; ö … t2
simple_Œ_rewrite_canon		(ö … Œ(t1  t2))	= (ö … Œt1 € Œt2)	
simple_Œ_rewrite_canon		(ö … Œ„xt)		= (ö … ƒxŒt)	
simple_Œ_rewrite_canon		(ö … Œt)		= (ö … t ‚ F)	
‚_t_rewrite_canon		(ö … t1 = t2)		= < failure >
‚_t_rewrite_canon		(ö … t)			= (ö … t ‚ T)
simple_ƒ_rewrite_canon		(ö … ƒxt)		= ö … t
æ


Note that the functions whose names begin with $simple$  do not handle paired quantifiers.
Versions which do handle these quantifiers are also available, as follows.
=SEEALSO
$Œ\_rewrite\_canon$, $simple\_ƒ\_rewrite\_canon$.
=FAILURE
26203	the conclusion of the theorem is already an equation
=ENDDOC
=DOC
val âREWRITE_CANá : CANON -> CANON;
=DESCRIBE
For rewriting, after all other canonicalisation we will usually
wish to then universally quantify
the resulting theorems in all free variables that are only in in the conclusion, other than those
that were free anywhere in the original theorem, before
any canonicalisation.
A canonicalisation is transformed to work this way by $REWRITE\_CAN$.

When evaluating proof contexts (see $evaluate\_proof\_context$) the list of rewrite canonicalisations
in the argument (see $get\_pc\_rw\_canons$), $arg$, will be converted to a single canonicalisation
in the result by:
ó
REWRITE_CAN
	(REPEAT_CAN(FIRST_CAN (arg @
		[‚_t_rewrite_canon])));
æ

=ENDDOC
=DOC
val âinitial_rw_canoná : CANON;
=DESCRIBE
This is the initial rewrite canonicalisation function,
defined as
ó
val initial_rw_canon =
	REWRITE_CAN
	(REPEAT_CAN(FIRST_CAN [
	simple_ƒ_rewrite_canon,
	€_rewrite_canon,
	simple_Œ_rewrite_canon,
	‚_t_rewrite_canon]));
æ
This is the repeated application of the first applicable
operation in the following list:
\begin{enumerate}
\item
stripping universal quantifiers;
\item
dividing conjunctive theorems into their conjuncts;
\item
changing $…Œ(t1  t2)$ to $Œt1 € Œt2$;
\item
changing $…Œ„xt$ to $ƒxŒt$;
\item
changing $…Œt$ to $t ‚ F$;
\item
if none of the above apply, changing $…t$ to $…t = T$.

Finally, after all this canonicalisation we then universally quantify
the resulting theorems in all free variables other than those
that were free in the original.

\end{enumerate}

=ENDDOC
\subsection{Canonicalisation and Equational Contexts}
We can now express the function that creates an equational context of of a theorem canonicalised by the
other parameter:
=DOC
val âcthm_eqn_cxtá : CANON -> THM -> EQN_CXT;
=DESCRIBE
A canonicalised theorem (giving a list of theorems)
may be converted into an equational context by $cthm\_eqn\_cxt$.
ó
fun cthm_eqn_cxt canon thm = map thm_eqn_cxt (canon thm);
æ
Canoncalised theorems that do not match the necessary pattern
for an equational context will be discarded.
=SEEALSO
$thm\_eqn\_cxt$ for working without canonicalisation.
=ENDDOC
\section{THE REWRITING FUNCTIONS}
\subsection{The Underlying Conversion}
The following general and powerful conversion is at the heart of all the other
rewriting functions.
=DOC
val âprim_rewrite_convá : CONV NET -> CANON -> 
	(CONV -> CONV) -> EQN_CXT -> THM list -> CONV;
=DESCRIBE
The primitive rewrite conversion.
=CONVERSION
prim_rewrite_conv
(initial_net: CONV NET)
(canon : CANON)
(traverse : CONV -> CONV)
(with_eqn_cxt : EQN_CXT)
(with_thms : THM list) »t¼
É
É
ö … t = t'
=TEX
where »t'¼ is »t¼, rewritten according to the parameters of the
conversion, and $ö$ are the assumptions required to allow the
rewriting. The failure of the conversion constructed by $prim\_rewrite\_conv$ will not be caught by $prim\_rewrite\_conv$.

The arguments have the following effects:
\begin{description}
\item[initial\_net]
This is a pre-calculated conversion net, that will serve
as the initial rewriting that may be done.
\item[canon]
This canonicalisation function
will be applied to all of the $with\_thms$ theorems, to produce a list of theorems to be rewritten with from these inputs.
This will generally involve producing canonical or simplified
forms of the original theorems.

The resulting theorems are intended to be simply universally 
quantified equations, and theorems which are not of this form are discarded.
Rewriting attempts to instantiate some or all of the 
universally quantified variables, or any type variables (which do
not appear in the assumptions), so as to
to match the left-hand side of an equation to the term being rewritten.
N.b. free variables are not instantiated.
An equation whose left-hand side matches the term being rewritten
in such a way that rewriting would not change the term
is treated as if it did not match the term.
\item[traverse]
This is a conversional, which defines the traversal of term $t$ by the
rewriting conversion derived from $prim\_rewrite\_conv$'s other arguments.
\item [with$\_$eqn$\_$cxt]
This is additional equational context to be
added directly into the rewriting conversion net.
\item[with$\_$thms]
This is an additional set of theorems to be processed by $canon$
and the results used in added directly into the rewriting conversion net.
\end{description}
=USES
This is the basis of all the primary rewriting tools, by using
a variety of the first four parameters.

Note that $prim\_rewrite\_conv$ preprocesses its arguments in various ways.
The preprocessing for an argument
takes place as soon as that argument is supplied, so, for example,
the overhead of preprocessing $with\_eqn\_cxt$ need not be incurred in calls with
the same $with\_eqn\_cxt$ but different $with\_thms$.
=ENDDOC
\subsection{Rules}
=DOC
val âprim_rewrite_ruleá : CONV NET -> CANON -> 
	(CONV -> CONV) -> EQN_CXT -> THM list -> THM -> THM;
=DESCRIBE
This is the inference rule based on $prim\_rewrite\_conv$ (q.v.),
with the same parameters as that function, except for the last
argument:
=RULE
prim_rewrite_rule
(initial_net: CONV NET)
(canon : CANON)
(traverse : CONV -> CONV)
(with_eqn_cxt : EQN_CXT)
(with_thms : THM list)
É
ö … t
É
ö ¡ ö1 … t'
=TEX
where »t'¼ is the result of rewriting »t¼ in the manner prescribed
by the arguments, and $ö1$ are the assumptions required to allow this rewriting.
=ENDDOC
=DOC
val ârewrite_ruleá : THM list -> THM -> THM;
val âpure_rewrite_ruleá : THM list -> THM -> THM;
val âonce_rewrite_ruleá : THM list -> THM -> THM;
val âpure_once_rewrite_ruleá : THM list -> THM -> THM;
val âasm_rewrite_ruleá : THM list -> THM -> THM;
val âpure_asm_rewrite_ruleá : THM list -> THM -> THM;
val âonce_asm_rewrite_ruleá : THM list -> THM -> THM;
val âpure_once_asm_rewrite_ruleá : THM list -> THM -> THM;
val âfasm_rewrite_ruleá : THM list -> (TERM -> bool) -> THM -> THM;
val âpure_fasm_rewrite_ruleá : THM list -> (TERM -> bool) -> THM -> THM;
val âonce_fasm_rewrite_ruleá : THM list -> (TERM -> bool) -> THM -> THM;
val âpure_once_fasm_rewrite_ruleá : THM list -> (TERM -> bool) -> THM -> THM;
=DESCRIBE
These are the standard rewriting rules.
They use the canonicalisation rule held by the proof context (see, e.g, $push\-\_proof\-\_context$)
to
preprocess the theorem list.
The context is accessed at the point when the rules are given a list of
theorems.

If a rule is ``pure'' then there is no default rewriting,
otherwise the default rewriting conversion net
held by the proof context will be used
in addition to user supplied material.

If a rule is ``once'' then rewriting will proceed from the root
of the of the conclusion of the theorem to be rewritten, towards the leaves,
and will not descend through any rewritten subterm.
If not, rewriting will continue, moving from the root to the leaves, repeating if any rewriting is successful, until there is no rewriting redex
anywhere within the rewritten conclusion.
This may cause non-terminating looping.

If a rule is ``asm'' then the theorems rewritten with will include
the canonicalised $asm\_rule$d assumptions of the theorem being rewritten.

If a rule is ``fasm'' then the theorems rewritten with will include
the canonicalised $asm\_rule$d assumptions which satisfy the predicate on terms supplied of the theorem being rewritten.
=SEEALSO
$prim\_rewrite\_rule$
=FAILURE
26001	no rewriting occurred
=ENDDOC
\subsection{Conversions}
=DOC
val ârewrite_convá : THM list -> CONV;
val âpure_rewrite_convá : THM list -> CONV;
val âonce_rewrite_convá : THM list -> CONV;
val âpure_once_rewrite_convá : THM list -> CONV;
=DESCRIBE
These are the standard rewriting conversions.
They use the canonicalisation rule held by the proof context (see, e.g, $push\-\_proof\-\_context$)
preprocess the theorem list.
The context is accessed at the point when the rules are given a list of
theorems.

If a conversion is ``pure'' then there is no default rewriting,
otherwise the default rewriting conversion net
held by the proof context will be used
in addition to user supplied material.

If a conversion is ``once'' then rewriting will proceed from the root
of the rewritten conversion's term argument, towards the leaves,
and will not descend through any rewritten subterm.
If not, rewriting will continue moving from the root to the leaves, repeating if any rewriting is successful, until there is no rewriting redex
anywhere within the rewritten term.
This may cause non-terminating looping.
=FAILURE
26001	no rewriting occurred
=ENDDOC
\subsection{Tactics}
=DOC
val âprim_rewrite_tacá : CONV NET -> CANON -> 

	(CONV -> CONV) -> EQN_CXT -> THM list -> TACTIC;
=DESCRIBE
This is the inference rule based on $prim\_rewrite\_conv$ (q.v.),
with the same parameters as that function, except for the last
argument:
=TACTIC
prim_rewrite_tac
(initial_net: CONV NET)
(canon : CANON)
(traverse : CONV -> CONV)
(with_eqn_cxt : EQN_CXT)
(with_thms : THM list)
É
{ ö } … t
É
{ ö } … t'
=TEX
where »t'¼ is the result of rewriting »t¼ in the manner prescribed
by the arguments.
=ENDDOC
=DOC
val ârewrite_tacá : THM list -> TACTIC;
val âpure_rewrite_tacá : THM list -> TACTIC;
val âonce_rewrite_tacá : THM list -> TACTIC;
val âpure_once_rewrite_tacá : THM list -> TACTIC;
val âasm_rewrite_tacá : THM list -> TACTIC;
val âpure_asm_rewrite_tacá : THM list -> TACTIC;
val âonce_asm_rewrite_tacá : THM list -> TACTIC;
val âpure_once_asm_rewrite_tacá : THM list -> TACTIC;
val âfasm_rewrite_tacá : THM list -> (TERM -> bool) -> TACTIC;
val âpure_fasm_rewrite_tacá : THM list -> (TERM -> bool) -> TACTIC;
val âonce_fasm_rewrite_tacá : THM list -> (TERM -> bool) -> TACTIC;
val âpure_once_fasm_rewrite_tacá : THM list -> (TERM -> bool) -> TACTIC;
=DESCRIBE
These are the rewriting tactics.
They use the canonicalisation rule held by the current proof context (see, e.g., $push\-\_proof\-\_context$)
to
preprocess the theorem list.
The context is accessed at the point when the rules are given a list of
theorems.

If a tactic is ``pure'' then there is no default rewriting,
otherwise the default rewriting conversion net
held by the current proof context will be used
in addition to user supplied material.

If a tactic is ``once'' then rewriting will proceed from the root
of the conclusion of the goal to be rewritten, towards the leaves,
and will not descend through any rewritten subterm.
If not, rewriting will continue, moving from the root to the leaves, repeating if any rewriting is successful, until there is no rewriting redex
anywhere within the rewritten conclusion.
This may cause non-terminating looping.

If a tactic is ``asm'' then the theorems rewritten with will include
the canonicalised $asm\_rule$d assumptions of the goal.

If a rule is ``fasm'' then the theorems rewritten with will include
the canonicalised $asm\_rule$d assumptions which satisfy the predicate on terms supplied of the theorem being rewritten.
=FAILURE
26001	no rewriting occurred
=ENDDOC
=DOC
val ârewrite_thm_tacá : THM -> TACTIC;
val âpure_rewrite_thm_tacá : THM -> TACTIC;
val âonce_rewrite_thm_tacá : THM -> TACTIC;
val âpure_once_rewrite_thm_tacá : THM -> TACTIC;
val âasm_rewrite_thm_tacá : THM -> TACTIC;
val âpure_asm_rewrite_thm_tacá : THM -> TACTIC;
val âonce_asm_rewrite_thm_tacá : THM -> TACTIC;
val âpure_once_asm_rewrite_thm_tacá : THM -> TACTIC;
val âfasm_rewrite_thm_tacá : (TERM -> bool) -> THM -> TACTIC;
val âpure_fasm_rewrite_thm_tacá : (TERM -> bool) -> THM -> TACTIC;
val âonce_fasm_rewrite_thm_tacá : (TERM -> bool) -> THM -> TACTIC;
val âpure_once_fasm_rewrite_thm_tacá : (TERM -> bool) -> THM -> TACTIC;
=DESCRIBE
These are rewriting tactics parameterised to take only one theorem.
This parameterisation is convenient to use with the many tactic
generating functions, such as $LEMMA\_T$, which take a theorem tactic
as an argument.

See, e.g. $rewrite\_tac$ for the details of the differences
between these tactics.
=FAILURE
26001	no rewriting occurred
=FAILUREC
Errors will be reported as if from the corresponding $\_tac$:
e.g. from $rewrite\_tac$ rather than $rewrite\_thm\_tac$.
This allows a simple implementation, and for there to be
no functionality change even in errors between
using singleton lists with the originals, and these functions.
=ENDDOC
\section{BASIC REWRITES}\label{BASICREWRITES}
The following portmanteau box contains the basic rewriting theorems which
are to be proved and set up as the basic rewrites in the implementation
of this module.
=DOC
val âeq_rewrite_thmá : THM
val â‚_rewrite_thmá : THM
val âŒ_rewrite_thmá : THM
val â€_rewrite_thmá : THM
val â_rewrite_thmá : THM
val âŠ_rewrite_thmá : THM
val âif_rewrite_thmá : THM
val âƒ_rewrite_thmá : THM
val â„_rewrite_thmá : THM
val â%beta%_rewrite_thmá : THM
=DESCRIBE
These are some of the default list of theorems used by those rewriting
rules, conversions and tactics whose names do not begin with `$pure\_$':
ó
eq_rewrite_thm … ƒ x(x = x) ‚ T

‚_rewrite_thm … ƒ t((T ‚ t) = t) € ((t ‚ T) = t) € ((F ‚ t) = (Œ t)) € (t ‚ F) = (Œ t)

Œ_rewrite_thm … ƒ t(ŒŒt) = t € ((Œ T) = F) € (Œ F) = T

€_rewrite_thm … ƒ t((T € t) = t) € ((t € T) = t) €
		(Œ (F € t)) € (Œ (t € F)) € (t € t) = t

_rewrite_thm … ƒ t(T  t) € (t  T) € ((F  t) = t) € ((t  F) = t) € (t  t) = t

Š_rewrite_thm … ƒ t((T Š t) = t) € ((F Š t) = T) € ((t Š T) = T) € ((t Š t) = T)
  € (t Š F) = (Œ t)

if_rewrite_thm … ƒ t1 t2:'a((if T then t1 else t2) = t1) € (if F then t1 else t2) = t2

ƒ_rewrite_thm … ƒ t(ƒ xt) = t
„_rewrite_thm … ƒ t(„ xt) = t

simple_%beta%_rewrite_thm … ƒ t1:'a; t2:'b(( xt1)t2) = t1
æ
The theorems are saved in the theory ``misc'',
and given their design in the design for that theory.
=SEEALSO
$fst\_rewrite\_thm$, $snd\_rewrite\_thm$, $fst\_snd\_rewrite\_thm$.
=ENDDOC
=DOC
val âinitial_rewrite_pcá : PROOF_CONTEXT;
val âinitial_rewrite_epcá : EPROOF_CONTEXT;
=DESCRIBE
$initial\_rewrite\_pc$ takes $initial\_strip\_pc$,
and replaces the rewriting canonicalisation list with 
ó
	[simple_ƒ_rewrite_canon,
	€_rewrite_canon,
	simple_Œ_rewrite_canon]
æ
so that the evaluated canonicalisation is $initial\_rw\_canon$,
and $set\_epc\_rw\_eqn\_cxt$ with:
ó
(flat(map (cthm_eqn_cxt initial_rw_canon) [
	eq_rewrite_thm,
	‚_rewrite_thm,
	Œ_rewrite_thm,
	€_rewrite_thm,
	_rewrite_thm,
	Š_rewrite_thm,
	if_rewrite_thm,
	ƒ_rewrite_thm,
	„_rewrite_thm,
	%beta%_rewrite_thm])) @
[ (»( x  y) z¼, simple_%beta%_conv) ];
æ
$initial\_rewrite\_epc$ takes $initial\_strip\_epc$,
and replaces the entry for $rw\_canon$ with $initial\-\_rw\-\_canon$
and $rw\-\_eqn\-\_cxt$ with
the net formed from the above equational context, $cxt$, by 
$make\_net$.

The names of the contexts are the same as the ML variables to which they are bound.
=ENDDOC
\section{EVALUATION OF PROOF CONTEXTS}
The following function needs implementing after the
methods of initialising all configurable proof tools have been introduced.
Thus it will probably migrate from this document in the future.
The need for this function is discussed in \cite{DS/FMU/IED/DTD051}.
=DOC
val âevaluate_proof_contextá : string -> PROOF_CONTEXT -> EPROOF_CONTEXT;
=DESCRIBE
This function converts the user-presentation style of a 
proof context into one that may be set using $push\_proof\_context$ (q.v).
The string argument is the name of the resulting context.
=ENDDOC
=TEX
\section{END OF THE SIGNATURE}
=SML
end; (* signature of Rewriting *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
