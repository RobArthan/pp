=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design of Rewriting Inference Rules}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Rewriting Inference Rules}
\TPPref{DS/FMU/IED/DTD026}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
rewriting rules of inference in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
\end{description}
\subsection{Changes forecast}
Most of the text outside the documentation boxes is a discussion
of the design process, rather than being part of the final design.
It will thus be removed or rephrased in later issues.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
rewriting rules of inference.
This is called for in section ??? of ???.
The design is
implemented in \cite{DS/FMU/IED/IMP026}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the rewriting
derived rules of inference in Release 001 of ICL HOL.

All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP026}.
\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.

This document places requirements upon the constants handled by the
inference rules discussed.
In summary, the requirements are that the definitions of the constants must be such that the designs of the rules are satisfiable.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}
\section{INFIX DIRECTIVES}

\section{THE DERIVED RULES OF REASONING}
=DOC
signature âRewritingInferenceRulesá = sig
=DESCRIBE
This provides the derived rewriting rules of inference in Release 001 of ICL HOL.
=ENDDOC
=DOC
val âprim_rewrite_convá : (TERM * CONV) list -> (THM list -> THM list) -> 
	THM list -> (CONV -> CONV) -> THM list -> TERM -> THM
=DESCRIBE
The primitive rewrite conversion.
=CONVERSION
prim_rewrite_conv
(other_conv : (TERM * CONV) list)
(canon : THM list -> THM list)
(basis : THM list)
(traverse : CONV -> CONV)
(with : THM list)
»t¼
É
É
ö … t = t'
=TEX
where »t'¼ is »t¼, rewritten according to the parameters of the
conversion, and $ö$ are the assumptions required to allow the
rewriting.

The function is partially evaluable with any number of its arguments present, though in some cases partial evaluation is not considered
likely to be of use.
The parameters have the following effects:
\begin{description}
\item[other\_conv]
If a particular sub-term
matches (by free variable and type instantiation) any terms of this
list, then the associated conversions will be added to the applicable rewrite conversions generated by the following arguments.
Members of the list will be applied to the sub-term until
one succeeds, or all fail.
This can be used to cause, e.g., $\beta$ reduction, during rewriting.
\item[canon]
This function will be applied to both the $basis$ and $with$ theorems, to produce a list of theorems to be rewritten with from these inputs.
This will generally involve producing canonical or simplified
forms of the original theorems.

The resulting theorems will be (perhaps) universally 
quantified theorems, that the rewriting may instantiate in any or all of their 
universally quantified variables, or any of their type variables,
to match the term being rewritten.
They will not be instantiated in any free variables.
\item[basis]
This is a basic set of theorems to rewrite with.
$prim\_rewrite\_conv$ will be partially evaluable with just
$canon$ and $basis$ as arguments, which is the only reason for having two theorem list arguments.
\item[traverse]
This is a conversional, which defines the traversal of term $t$ by the
rewriting conversion derived from $prim\_rewrite\_conv$'s other arguments.
\item[with]
This is an additional set of theorems to be processed by $canon$
and the results used in rewriting.
\end{description}
=USES
This is the basis of all the primary rewriting tools, by using
a variety of the first four parameters.
=ENDDOC
=DOC
val âprim_rewrite_ruleá : (TERM * CONV) list -> (THM list -> THM list) -> 

	THM list -> (CONV -> CONV) -> THM list -> THM -> THM;
=DESCRIBE
This is the inference rule based on $prim\_rewrite\_conv$ (q.v.),
with the same parameters as that function, except for the last
argument:
=RULE
prim_rewrite_rule
(other_conv : (TERM * CONV) list)
(canon : THM list -> THM list)
(basis : THM list)
(traverse : CONV -> CONV)
(with : THM list)
É
ö … t
É
ö ¡ ö1 … t'
=TEX
where »t'¼ is the result of rewriting »t¼ in the manner prescribed
by the arguments, and $ö1$ are the assumptions required to allow this rewriting.
=ENDDOC
=DOC
val ârewrite_ruleá : THM list -> THM -> THM;
val âpure_rewrite_ruleá : THM list -> THM -> THM;
val âonce_rewrite_ruleá : THM list -> THM -> THM;
val âpure_once_rewrite_ruleá : THM list -> THM -> THM;
val âasm_rewrite_ruleá : THM list -> THM -> THM;
val âpure_asm_rewrite_ruleá : THM list -> THM -> THM;
val âonce_asm_rewrite_ruleá : THM list -> THM -> THM;
val âpure_once_asm_rewrite_ruleá : THM list -> THM -> THM;
val âfasm_rewrite_ruleá : THM list -> (TERM -> bool) -> THM -> THM;
val âpure_fasm_rewrite_ruleá : THM list -> (TERM -> bool) -> THM -> THM;
val âonce_fasm_rewrite_ruleá : THM list -> (TERM -> bool) -> THM -> THM;
val âpure_once_fasm_rewrite_ruleá : THM list -> (TERM -> bool) -> THM -> THM;
=DESCRIBE
These are the standard patterns of rewriting inference rules,
all based upon $prim\_rewrite\_rule$(q.v.).
They all use the canonicalisation rule $rewrite\_canon$(q.v.) to
process their theorems.

If a rule is ``pure'' then there are no default rewrite theorems,
otherwise the rewriting theorems given by $set\_basic\_rewrites$
(q.v.) will be the default rewriting theorems, and any $\beta$ redexes will be reduced.

If a rule is ``once'' then rewriting will proceed from the root
of the rewritten conclusion's theorem, towards the leaves,
and will not descend through any rewritten subterm.
If not, rewriting will continue, moving from the root to the leaves, repeating if any rewriting is successful, until there is no rewriting redex
anywhere within the rewritten conclusion.
This may cause non-terminating looping.

If a rule is ``asm'' then the theorems rewritten with will include
the $asm\_rule$d assumptions of the theorem being rewritten.

If a rule is ``fasm'' then the theorems rewritten with will include
the $asm\_rule$d assumptions which satisfy the predicate on terms supplied of the theorem being rewritten.
=ENDDOC
=DOC
val ârewrite_convá : THM list -> CONV;
val âpure_rewrite_convá : THM list -> CONV;
val âonce_rewrite_convá : THM list -> CONV;
val âpure_once_rewrite_convá : THM list -> CONV;
=DESCRIBE
These are the standard patterns of rewriting conversions,
all based upon $prim\_rewrite\_conv$(q.v.).
They all use the canonicalisation rule $rewrite\_canon$(q.v.) to
process their theorems.

If a conversion is ``pure'' then there are no default rewrite theorems,
otherwise the $basic\_rewrites$ (of $set\_basic\_rewrites$(q.v.))
will be the default rewriting theorems and any $\beta$ redexes will be reduced.

If a conversion is ``once'' then rewriting will proceed from the root
of the rewritten conversion's term argument, towards the leaves,
and will not descend through any rewritten subterm.
If not, rewriting will continue moving from the root to the leaves, repeating if any rewriting is successful, until there is no rewriting redex
anywhere within the rewritten term.
This may cause non-terminating looping.
=ENDDOC
=DOC
val âtaut_ruleá : TERM -> THM;
=DESCRIBE
A tautology prover.
If its argument is a tautologically true term, then the
function will return that term as a theorem.
=RULE
taut_rule
»t¼
É
É
… t
=TEX
=FAILURE
7002	Term is not boolean
26001	Term is not tautologically true
=ENDDOC
This is not a conversion, but there are two conversions leading
from it:
=DOC
val âtaut_convá : CONV;
=DESCRIBE
A tautology prover.
If its argument is a tautologically true term, then the
function will return a theorem that the term is equivalent to $T$.
=CONVERSION
taut_conv
»t¼
É
É
… t ‚ T
=TEX
=FAILURE
7002	Term is not boolean
26001	Term is not tautologically true
=ENDDOC
=DOC
val âtaut_eq_convá : TERM -> CONV;
=DESCRIBE
A tautology prover.
If its two boolean arguments are tautologically equal terms, then the
function will return a theorem that the terms are equal.
=CONVERSION
taut_eq_conv
»t1¼
»t2¼
É
É
… t2 ‚ t1
=TEX
=FAILURE
26002	Cannot prove equation
26003	First term is not boolean
26004	Second term is not boolean
=ENDDOC

\subsection{Parameterising Rewriting}
The following two functions allow the user to modify the
standard pattern of rewriting.
=DOC
val âset_rewrite_canoná : (THM list -> THM list) -> unit;
=DESCRIBE
This sets the canonicalisation function used in $rewrite\_conv$ and
its relatives.
The list is produced by processing each member of the list, resulting in a list of theorems. 
This list will be added to those produced so far, bar duplicates.
=ENDDOC
We would expect this to be set to something that at least does the following:

The individual theorem processing is as follows:
\begin{enumerate}
\item
Strip universal quantifiers (by $strip\_ƒ\_rule$) and conjuncts 
($strip\_€\_rule$) until the result theorems are neither
conjunctions nor universally quantified.
\item
Theorems of the form `$ö\ … t1 = t2$` and `$ö\ … t1 ‚ t2$`
will be left alone, those of the form `$ö\ … Œ t$` will
be changed to `$ö\ … t ‚ F$`, and all others will be changed to
the form `$ö\ … t ‚ T$` by $‚\_t\_intro$.
\item
All the resulting theorems then will be made closed 
(universally quantified in all free variables).
\end{enumerate}

A variant canonicalisation would strip implications
into the assumption list, as well as adding the unstripped form.
The effects caused by this could be unfortunate if unconstrained,
and so it is not a default action.
=DOC
val âset_basic_rewritesá : THM list -> THM list;
=DESCRIBE
This sets the list of default rewrites used by $rewrite\_conv$,
$rewrite\_rule$, $rewrite\_tac$, etc.
It returns the previously set value.
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of RewritingInferenceRules *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
