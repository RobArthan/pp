=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design of Rewriting Rules and Tactics}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Rewriting Inference Rules}
\TPPref{DS/FMU/IED/DTD026}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
\TPPauthors{K.~Blackburn & WIN01\\R.D.Arthan & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the detailed design for the 
rewriting rules (including conversions) and tactics for ICL HOL.
It also describes canonicalisation.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Moved tautology material to \cite{DS/FMU/IED/DTD027}.
Some issues clarified in text.
Introduced $set\_rewrite\-\_convs$.
\item [Issue 1.3]
Added failure 26001 to inference rules.
\item [Issue 1.4]
Added tactics.
\item [Issue 1.8)]
Added canonicalisation and basic rewrites.
\item [Issue 1.9]
Added theorem tactic formulations of rewriting.
\item [Issue 1.10]
Various minor mods as a result of testing canons.
\item [Issue 1.11]
All rewrite functions now fail when applying an equation produces no change.
\item [Issue 1.12]
Tidying up.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
rewriting rules, conversions and tactics, and some auxiliary material.
This is called for in section \cite{DS/FMU/IED/HLD009}.
The design is implemented in \cite{DS/FMU/IED/IMP026}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the rewriting
derived rules, conversions and tactics for ICL HOL.

``Rewriting'' is a process of traversing a goal, theorem or term instantiating members of a set of equational theorems to match sub-terms encountered, and using the instantiations to infer a new goal, theorem, or an equational theorem.
We have enhanced the rewriting facilities in ICL HOL to apply
conversions.
In this context a conversion is viewed as a function capable of deriving an equational theorem, which is given
as an argument the LHS that the resulting equation must have.

An auxiliary topic needs covering to describe
rewriting.
It is canonicalisation, which is basically
the process of taking a theorem and producing equational theorems from it.
The process is configurable.

All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP026}.
\subsubsection{Dependencies}
Though this document is only dependent on \cite{DS/FMU/IMP008}
and \cite{DS/FMU/IMP007},
it is placed after \cite{DS/FMU/IMP028} in the system build makefile.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{INFIX DIRECTIVES}
The following canonicalisation function combinators are used with
infix notation:
=SML
infix 4 THEN_CAN;
infix 4 ORELSE_CAN;
infix 4 THEN_LIST_CAN;
=TEX
\section{START OF THE SIGNATURE}
=DOC
signature ‚Rewriting· = sig
=DESCRIBE
This provides the derived rewriting rule, conversions and
tactics for ICL HOL.
=ENDDOC
\section{CANONICALISATION}
\subsection{Discussion}\label{CANONICALISATIONDiscussion}
We will use the term
{\em canonicalisation} for an operation which transforms a theorem (or list
of theorems) into a list of theorems all of which share some property.
An example of a canonicalisation is the parameter to
the primitive rewrite conversion which transforms
lists of theorems into lists of equational theorems.
Another example might be reduction to clausal form.
 
For the present example,
the rewriting canonicalisation might be something like the following:

\begin{enumerate}
\item
stripping universal quantifiers;
\item
dividing conjunctive theorems into their conjuncts (and then recursively
transforming these);
\item
changing $Öåt$ to $t Ç F$;
\item
if none of the above apply, changing $Öt$ to $Öt Ç T$.
\end{enumerate}

however, application-specific transformations might apply, e.g. removing
universal quantifiers in languages other than HOL. In fact the above is
a simplification of what we actually propose
(in section \ref{CanonicalisationForRewriting} below)
for the rewriting canonicalisation.

To give a simple but general framework for handling canonicalisation, we
introduce a family of combinators for functions of type
$THM->THM\,list$. These allow a recursive process like the above-mentioned
rewriting canonicalisation to be extended piecemeal: the code
for the rewriting canonicalisation might include a line like:
Û
	REPEAT_CAN (FIRST_CAN (!rewrite_canons))
Ê
where the variable $rewrite\_canons$ initially contains the four standard
processes.

The canonicalisation combinators are very straightforward to implement; indeed,
they are even simpler than the combinators for tactics and conversions.
They may also prove useful in other contexts.

\subsection{The Canonicalisation Combinators}

=DOC
type ‚CANON· 		(* 	= THM -> (THM list)	*);
=DESCRIBE
This is the type abbreviation for a canonicalisation function; such functions
are typically used to derive consequences of a theorem meeting some desired
criteria. An example is $rewrite\_canon$ which is used to transform theorems
into lists of equational theorems for use in the rewriting conversions, rules
and tactics.

Combinators are available to assist in the construction of new
canonicalisation functions from old.
=SEEALSO
$id\_can$, $fail\_can$, $THEN\_CAN$, $ORELSE\_CAN$, $REPEAT\_CAN$, $FIRST\_CAN$,
$EVERY\_CAN$.
=ENDDOC

=DOC
val ‚id_canon· 	: CANON
=DESCRIBE
This is the identity for the canonicalisation function combinator
$THEN\_CAN$:
Û
id_canon thm = [thm]
Ê
=SEEALSO
$id\_can$, $fail\_can$, $THEN\_CAN$, $ORELSE\_CAN$, $REPEAT\_CAN$, $FIRST\_CAN$,
$EVERY\_CAN$.
=ENDDOC

=DOC
val ‚fail_canon· 	: CANON
=DESCRIBE
This is a canonicalisation function which always fails.
It is the identity for $ORELSE\_CAN$.
=SEEALSO
$id\_can$, $fail\_can$, $THEN\_CAN$, $ORELSE\_CAN$, $REPEAT\_CAN$, $FIRST\_CAN$,
$EVERY\_CAN$.
=FAILURE
26201	Failed as requested
=ENDDOC

=DOC
val ‚fail_with_canon· :	string -> int -> (unit -> string) list -> CANON
=DESCRIBE
This is a canonicalisation function which always fails by passing its
arguments to $fail$ (q.v.).
=SEEALSO
$id\_can$, $fail\_can$, $THEN\_CAN$, $ORELSE\_CAN$, $REPEAT\_CAN$, $FIRST\_CAN$,
$EVERY\_CAN$.
=ENDDOC
=DOC
val ‚THEN_CAN· : (CANON * CANON) -> CANON
=DESCRIBE
$THEN\_CAN$ is a canonicalisation function combinator written as an infix
operator. $(can1\,THEN\_CAN\,can2)thm$ is the result of
applying $can2$ to each of the theorems in the list $can1\,thm$ and then
flattening the resulting list of lists.
=SEEALSO
$id\_can$, $fail\_can$, $ORELSE\_CAN$, $REPEAT\_CAN$, $FIRST\_CAN$,
$EVERY\_CAN$.
=ENDDOC

=DOC
val ‚THEN_LIST_CAN· : (CANON * CANON list) -> CANON
=DESCRIBE
$THEN\_LIST\_CAN$ is a canonicalisation function combinator written as an infix
operator. $(can1\,THEN\_CAN\,cans)thm$ is the result of
applying each element of the list $cans$ to the
corresponding element of the list $can1\,thm$ and then
flattening the resulting list of lists.
=SEEALSO
$id\_can$, $fail\_can$, $ORELSE\_CAN$, $REPEAT\_CAN$, $FIRST\_CAN$, $THEN\_CAN$,
$EVERY\_CAN$.
=FAILURE
26204	wrong number of canonicalisation functions in the list
=ENDDOC

=DOC
val ‚ORELSE_CAN· : (CANON * CANON) -> CANON
=DESCRIBE
$ORELSE\_CAN$ is a canonicalisation function combinator written as an infix
operator. $(can1\,ORELSE\_CAN\,can2)thm$ is the same $can1\,thm$ unless evaluation
of $can1\,thm$ fails in which case it is the same as $can2\,thm$.
=SEEALSO
$id\_can$, $fail\_can$, $THEN\_CAN$, $REPEAT\_CAN$, $FIRST\_CAN$,
$EVERY\_CAN$.
=ENDDOC

=DOC
val ‚EVERY_CAN· : CANON list -> CANON
=DESCRIBE
$EVERY\_CAN$ is a canonicalisation function combinator which combines
the elements of its argument using $THEN\_CAN$:
Û
EVERY_CAN [can1, can2, ...] = can1 THEN_CAN can2 THEN_CAN ...
Ê
=SEEALSO
$id\_can$, $fail\_can$, $THEN\_CAN$, $REPEAT\_CAN$, $FIRST\_CAN$.
=ENDDOC

=DOC
val ‚FIRST_CAN· : CANON list -> CANON
=DESCRIBE
$FIRST\_CAN$ is a canonicalisation function combinator which combines
the elements of its argument using $ORELSE\_CAN$:
Û
FIRST_CAN [can1, can2, ...] = can1 ORELSE_CAN can2 ORELSE_CAN ...
Ê
=SEEALSO
$id\_can$, $fail\_can$, $THEN\_CAN$, $REPEAT\_CAN$, $EVERY\_CAN$,
=FAILURE
26202	the list of canonicalisation functions is empty
=ENDDOC

=DOC
val ‚REPEAT_CAN· : CANON -> CANON
=DESCRIBE
$REPEAT\_CAN$ is a canonicalisation function combinator which repeatedly
applies its argument until it fails:
Û
REPEAT_CAN can thm =
	((can THEN_CAN REPEAT_CAN can) ORELSE_CAN id_can) thm
Ê
=SEEALSO
$id\_can$, $fail\_can$, $THEN\_CAN$, $REPEAT\_CAN$, $EVERY\_CAN$,
=ENDDOC
\subsection{Canonicalisation For Rewriting}\label{CanonicalisationForRewriting}
The discussion in section \ref{CANONICALISATIONDiscussion}
of canonicalisation for rewriting actually
described a simpler process than the one which we adopt for standard use.

We adopt the following criteria for the rewriting canonicalisation:

\begin{enumerate}
\item
given $Öa$, it should guarantee that $rewrite\_tac$ will prove a goal
with conclusion $a$ providing it terminates;
\item
it should be relatively efficient (say, linear in the number of connectives
in the theorem being rewritten);
\item
it should generate as many useful equations as can conveniently be done
within the above constraints.
\end{enumerate}

Given the basic rewrites discussed in section \ref{BASICREWRITES}
below, the criteria are met by repeated application of the first applicable
operation in the following list:

\begin{enumerate}
\item
stripping universal quantifiers;
\item
dividing conjunctive theorems into their conjuncts;
\item
changing $Öå(t1 Å t2)$ to $åt1 Ä åt2$;
\item
changing $ÖåÑxét$ to $Éxéåt$;
\item
changing $Öåt$ to $t Ç F$;
\item
if none of the above apply, changing $Öt$ to $Öt = T$.
\end{enumerate}

The point here is that we move negations through disjunctions and existential
quantifiers because that can increase the number of useful equations we get
without prejudicing criterion 1 (by dint of the basic rewrites which
can evaluate disjunctions and existential terms in which the operands or body
is $T$).

A variant canonicalisation would strip implications
into the assumption list, as well as adding the unstripped form.
The effects caused by this could be unfortunate if unconstrained,
and so it is not adopted as the default action.

=DOC
val ‚Ä_rewrite_canon· : THM -> THM list
val ‚simple_å_rewrite_canon· : THM -> THM list
val ‚Ç_t_rewrite_canon· : THM -> THM list
val ‚simple_É_rewrite_canon· : THM -> THM list
=DESCRIBE
These are some of the standard canonicalisation functions used for breaking theorems up into
lists of equations for use in rewriting. The first four perform the following
transformations:
Û
Ä_rewrite_canon			(ˆ Ö t1 Ä t2)		= ˆ Ö t1 ; ˆ Ö t2
simple_å_rewrite_canon		(ˆ Ö å(t1 Å t2))	= (ˆ Ö åt1 Ä åt2)	
simple_å_rewrite_canon		(ˆ Ö åÑxét)		= (ˆ Ö Éxéåt)	
simple_å_rewrite_canon		(ˆ Ö åt)		= (ˆ Ö t Ç F)	
Ç_t_rewrite_canon		(ˆ Ö t1 = t2)		= < failure >
Ç_t_rewrite_canon		(ˆ Ö t)			= (ˆ Ö t Ç T)
simple_É_rewrite_canon		(ˆ Ö Éxét)		= ˆ Ö t
Ê


Note that the functions whose names begin with $simple$  do not handle paired quantifiers.
Versions which do handle these quantifiers are also available, as follows.
=SEEALSO
$set\_rewrite\_canons$,
$å\_rewrite\_canon$, $simple\_É\_rewrite\_canon$.
=FAILURE
26203	the conclusion of the theorem is already an equation
=ENDDOC
=TEX
\section{THE REWRITING FUNCTIONS}
\subsection{The Underlying Conversion}
The following general and powerful conversion is at the heart of all the other
rewriting functions.
=DOC
val ‚prim_rewrite_conv· : (TERM * CONV) list -> CANON -> 
	THM list -> (CONV -> CONV) -> THM list -> CONV
=DESCRIBE
The primitive rewrite conversion.
=CONVERSION
prim_rewrite_conv
(other_conv : (TERM * CONV) list)
(canon : CANON)
(basis : THM list)
(traverse : CONV -> CONV)
(with_thms : THM list)
ªtº
…
…
ˆ Ö t = t'
=TEX
where ªt'º is ªtº, rewritten according to the parameters of the
conversion, and $ˆ$ are the assumptions required to allow the
rewriting. The failure of the conversion constructed by $prim\_rewrite\_conv$ will not be caught by $prim\_rewrite\_conv$.

The arguments have the following effects:
\begin{description}
\item[other\_conv]
If a particular sub-term
matches (by free variable and type instantiation) any terms of this
list, then the associated conversions will be added to the applicable rewrite conversions generated by the following arguments.
Members of the list will be applied to the sub-term until
one succeeds, or all fail.
This can be used to cause, e.g., $\beta$ reduction, during rewriting.
\item[canon]
This is the canonicalisation functions
 will be applied to all of the $basis$ and $with\_thms$ theorems, to produce a list of theorems to be rewritten with from these inputs.
This will generally involve producing canonical or simplified
forms of the original theorems.

The resulting theorems are intended to be simply universally 
quantified equations, and theorems which are not of this form are discarded.
Rewriting attempts to instantiate some or all of the 
universally quantified variables, or any type variables (which do
not appear in the assumptions), so as to
to match the left-hand side of an equation to the term being rewritten.
N.b. free variables are not instantiated.
An equation whose left-hand side matches the term being rewritten
in such a way that rewriting would not change the term
is treated as if it did not match the term.
\item[basis]
This is a basic set of theorems to rewrite with.
\item[traverse]
This is a conversional, which defines the traversal of term $t$ by the
rewriting conversion derived from $prim\_rewrite\_conv$'s other arguments.
\item[with$\_$thms]
This is an additional set of theorems to be processed by $canon$
and the results used in rewriting.
\end{description}
=USES
This is the basis of all the primary rewriting tools, by using
a variety of the first four parameters.

Note that $prim\_rewrite\_conv$ preprocesses its arguments in various ways.
The preprocessing for an argument
takes place as soon as that argument is supplied, so, for example,
the overhead of preprocessing $basis$ need not be incurred in calls with
the same $basis$ but different $with\_thms$.
=ENDDOC
\subsection{Rules}
=DOC
val ‚prim_rewrite_rule· : (TERM * CONV) list -> CANON -> 

	THM list -> (CONV -> CONV) -> THM list -> THM -> THM;
=DESCRIBE
This is the inference rule based on $prim\_rewrite\_conv$ (q.v.),
with the same parameters as that function, except for the last
argument:
=RULE
prim_rewrite_rule
(other_conv : (TERM * CONV) list)
(canon : CANON)
(basis : THM list)
(traverse : CONV -> CONV)
(with_thms : THM list)
…
ˆ Ö t
…
ˆ ° ˆ1 Ö t'
=TEX
where ªt'º is the result of rewriting ªtº in the manner prescribed
by the arguments, and $ˆ1$ are the assumptions required to allow this rewriting.
=ENDDOC
=DOC
val ‚rewrite_rule· : THM list -> THM -> THM;
val ‚pure_rewrite_rule· : THM list -> THM -> THM;
val ‚once_rewrite_rule· : THM list -> THM -> THM;
val ‚pure_once_rewrite_rule· : THM list -> THM -> THM;
val ‚asm_rewrite_rule· : THM list -> THM -> THM;
val ‚pure_asm_rewrite_rule· : THM list -> THM -> THM;
val ‚once_asm_rewrite_rule· : THM list -> THM -> THM;
val ‚pure_once_asm_rewrite_rule· : THM list -> THM -> THM;
val ‚fasm_rewrite_rule· : THM list -> (TERM -> bool) -> THM -> THM;
val ‚pure_fasm_rewrite_rule· : THM list -> (TERM -> bool) -> THM -> THM;
val ‚once_fasm_rewrite_rule· : THM list -> (TERM -> bool) -> THM -> THM;
val ‚pure_once_fasm_rewrite_rule· : THM list -> (TERM -> bool) -> THM -> THM;
=DESCRIBE
These are the standard rewriting rules.
They use the canonicalisation rule set up by $set\_rewrite\_canons$(q.v.) to
preprocess their theorems.

If a rule is ``pure'' then there are no default rewrite theorems,
otherwise the rewriting theorems given by $set\_basic\_rewrites$
(q.v.) will be the default rewriting theorems, and 
the conversions set by $set\_rewrite\_convs$(q.v.)
will be used.

If a rule is ``once'' then rewriting will proceed from the root
of the of the conclusion of the theorem to be rewritten, towards the leaves,
and will not descend through any rewritten subterm.
If not, rewriting will continue, moving from the root to the leaves, repeating if any rewriting is successful, until there is no rewriting redex
anywhere within the rewritten conclusion.
This may cause non-terminating looping.

If a rule is ``asm'' then the theorems rewritten with will include
the $asm\_rule$d assumptions of the theorem being rewritten.

If a rule is ``fasm'' then the theorems rewritten with will include
the $asm\_rule$d assumptions which satisfy the predicate on terms supplied of the theorem being rewritten.
=SEEALSO
$prim\_rewrite\_rule$
=FAILURE
26001	no rewriting occurred
=ENDDOC
\subsection{Conversions}
=DOC
val ‚rewrite_conv· : THM list -> CONV;
val ‚pure_rewrite_conv· : THM list -> CONV;
val ‚once_rewrite_conv· : THM list -> CONV;
val ‚pure_once_rewrite_conv· : THM list -> CONV;
=DESCRIBE
These are the standard rewriting conversions.
They all use the canonicalisation rule $rewrite\_canon$(q.v.) to
preprocess their theorems.

If a conversion is ``pure'' then there are no default rewrite theorems,
otherwise the $basic\_rewrites$ (of $set\_basic\_rewrites$(q.v.))
will be the default rewriting theorems and 
the conversions set by $set\_rewrite\_convs$(q.v.)
will be used.

If a conversion is ``once'' then rewriting will proceed from the root
of the rewritten conversion's term argument, towards the leaves,
and will not descend through any rewritten subterm.
If not, rewriting will continue moving from the root to the leaves, repeating if any rewriting is successful, until there is no rewriting redex
anywhere within the rewritten term.
This may cause non-terminating looping.
=FAILURE
26001	no rewriting occurred
=ENDDOC
\subsection{Tactics}
=DOC
val ‚prim_rewrite_tac· : (TERM * CONV) list -> CANON -> 

	THM list -> (CONV -> CONV) -> THM list -> TACTIC;
=DESCRIBE
This is the inference rule based on $prim\_rewrite\_conv$ (q.v.),
with the same parameters as that function, except for the last
argument:
=TACTIC
prim_rewrite_tac
(other_conv : (TERM * CONV) list)
(canon : CANON)
(basis : THM list)
(traverse : CONV -> CONV)
(with_thms : THM list)
…
{ ˆ } Ö t
…
{ ˆ } Ö t'
=TEX
where ªt'º is the result of rewriting ªtº in the manner prescribed
by the arguments.
=ENDDOC
=DOC
val ‚rewrite_tac· : THM list -> TACTIC;
val ‚pure_rewrite_tac· : THM list -> TACTIC;
val ‚once_rewrite_tac· : THM list -> TACTIC;
val ‚pure_once_rewrite_tac· : THM list -> TACTIC;
val ‚asm_rewrite_tac· : THM list -> TACTIC;
val ‚pure_asm_rewrite_tac· : THM list -> TACTIC;
val ‚once_asm_rewrite_tac· : THM list -> TACTIC;
val ‚pure_once_asm_rewrite_tac· : THM list -> TACTIC;
val ‚fasm_rewrite_tac· : THM list -> (TERM -> bool) -> TACTIC;
val ‚pure_fasm_rewrite_tac· : THM list -> (TERM -> bool) -> TACTIC;
val ‚once_fasm_rewrite_tac· : THM list -> (TERM -> bool) -> TACTIC;
val ‚pure_once_fasm_rewrite_tac· : THM list -> (TERM -> bool) -> TACTIC;
=DESCRIBE
These are the rewriting tactics.
They all use the canonicalisation rule $rewrite\_canon$(q.v.) to
preprocess their theorems.

If a rule is ``pure'' then there are no default rewrite theorems,
otherwise the rewriting theorems given by $set\_basic\_rewrites$
(q.v.) will be the default rewriting theorems, and 
the conversions set by $set\_rewrite\_convs$(q.v.)
will be used.

If a rule is ``once'' then rewriting will proceed from the root
of the conclusion of the goal to be rewritten, towards the leaves,
and will not descend through any rewritten subterm.
If not, rewriting will continue, moving from the root to the leaves, repeating if any rewriting is successful, until there is no rewriting redex
anywhere within the rewritten conclusion.
This may cause non-terminating looping.

If a rule is ``asm'' then the theorems rewritten with will include
the $asm\_rule$d assumptions of the goal.

If a rule is ``fasm'' then the theorems rewritten with will include
the $asm\_rule$d assumptions which satisfy the predicate on terms supplied of the theorem being rewritten.
=FAILURE
26001	no rewriting occurred
=ENDDOC
=DOC
val ‚rewrite_thm_tac· : THM -> TACTIC;
val ‚pure_rewrite_thm_tac· : THM -> TACTIC;
val ‚once_rewrite_thm_tac· : THM -> TACTIC;
val ‚pure_once_rewrite_thm_tac· : THM -> TACTIC;
val ‚asm_rewrite_thm_tac· : THM -> TACTIC;
val ‚pure_asm_rewrite_thm_tac· : THM -> TACTIC;
val ‚once_asm_rewrite_thm_tac· : THM -> TACTIC;
val ‚pure_once_asm_rewrite_thm_tac· : THM -> TACTIC;
val ‚fasm_rewrite_thm_tac· : (TERM -> bool) -> THM -> TACTIC;
val ‚pure_fasm_rewrite_thm_tac· : (TERM -> bool) -> THM -> TACTIC;
val ‚once_fasm_rewrite_thm_tac· : (TERM -> bool) -> THM -> TACTIC;
val ‚pure_once_fasm_rewrite_thm_tac· : (TERM -> bool) -> THM -> TACTIC;
=DESCRIBE
These are rewriting tactics parameterised to take only one theorem.
This parameterisation is convenient to use with the many tactic
generating functions, such as $LEMMA\_T$, which take a theorem tactic
as an argument.
They all use the canonicalisation rule $rewrite\_canon$(q.v.) to
preprocess the theorem.

If a rule is ``pure'' then there are no default rewrite theorems,
otherwise the rewriting theorems given by $set\_basic\_rewrites$
(q.v.) will be the default rewriting theorems, and 
the conversions set by $set\_rewrite\_convs$(q.v.)
will be used.

If a rule is ``once'' then rewriting will proceed from the root
of the conclusion of the goal to be rewritten, towards the leaves,
and will not descend through any rewritten subterm.
If not, rewriting will continue, moving from the root to the leaves, repeating if any rewriting is successful, until there is no rewriting redex
anywhere within the rewritten conclusion.
This may cause non-terminating looping.

If a rule is ``asm'' then the theorems rewritten with will include
the $asm\_rule$d assumptions of the goal.

If a rule is ``fasm'' then the theorems rewritten with will include
the $asm\_rule$d assumptions which satisfy the predicate on terms supplied of the theorem being rewritten.
=FAILURE
26001	no rewriting occurred
=ENDDOC
\section{PARAMETERISING REWRITING}
The following functions allow the user to modify the
standard pattern of rewriting.
=DOC
val ‚set_rewrite_canons· : (string * CANON) list -> unit;
=DESCRIBE
This sets the canonicalisation functions used in $rewrite\_conv$ and
its relatives.
The functions are applied repeatedly to each theorem
until none of them are applicable. The
resulting theorems are then generalised (using
$simple\_É\_intro$) over all free variables which did not appear free
in the original theorem.

$set\_rewrite\_canon$ does not effect instances of the rewrite rules and conversions that which have already been applied to the list of theorems to rewrite with.

The strings are for information only.
=SEEALSO
$basic\_rewrite\_canon$
=ENDDOC

=DOC
val ‚get_rewrite_canons· : unit -> (string * CANON) list;
=DESCRIBE
This returns the list of
canonicalisation functions used in $rewrite\_conv$ and
its relatives.
=SEEALSO
$set\_rewrite\_canons$
=ENDDOC

=DOC
val ‚set_basic_rewrites· : THM list -> THM list;
=DESCRIBE
This sets the list of default rewrites used by $rewrite\_conv$,
$rewrite\_rule$, $rewrite\_tac$, etc.
It returns the previously set value.

This will only take effect for instances of the rewrite rules and conversions that have not yet been applied to 
the list of theorems to rewrite with.
=ENDDOC

=DOC
val ‚get_basic_rewrites· : unit -> THM list;
=DESCRIBE
This returns the list of default rewrites used by $rewrite\_conv$,
=SEEALSO
$set\_basic\_rewrites$
=ENDDOC

=DOC
val ‚set_rewrite_convs· : ((TERM * CONV) list) -> unit;
=DESCRIBE
This sets the list of conversions used by $rewrite\_conv$,
$rewrite\_rule$, $rewrite\_tac$, etc,
in addition to rewriting with equations.


This will only take effect for instances of the rewrite rules and conversions that have not yet been applied to 
the list of theorems to rewrite with.
=ENDDOC

=DOC
val ‚get_rewrite_convs· : unit -> ((TERM * CONV) list);
=DESCRIBE
This returns the list of conversions used in addition to
the rewriting theorems by $rewrite\_conv$,
$rewrite\_rule$, $rewrite\_tac$, etc.
=SEEALSO
$set\_rewrite\_convs$
=ENDDOC
=TEX
\section{BASIC REWRITES}\label{BASICREWRITES}
The following portmanteau box contains the basic rewriting theorems which
are to be proved and set up as the basic rewrites in the implementation
of this module. When the theory of pairs is set up, basic rewrites for
$fst$ and $snd$ are also set up.
=DOC
val ‚eq_rewrite_thm· : THM
val ‚Ç_rewrite_thm· : THM
val ‚å_rewrite_thm· : THM
val ‚Ä_rewrite_thm· : THM
val ‚Å_rewrite_thm· : THM
val ‚ä_rewrite_thm· : THM
val ‚if_rewrite_thm· : THM
val ‚É_rewrite_thm· : THM
val ‚Ñ_rewrite_thm· : THM
val ‚%beta%_rewrite_thm· : THM
=DESCRIBE
These are some of the default list of theorems used by those rewriting
rules, conversions and tactics whose names do not begin with `$pure\_$':
Û
eq_rewrite_thm Ö É xé(x = x) Ç T

Ç_rewrite_thm Ö É té((T Ç t) = t) Ä ((t Ç T) = t) Ä ((F Ç t) = (å t)) Ä (t Ç F) = (å t)

å_rewrite_thm Ö É té(ååt) = t Ä ((å T) = F) Ä (å F) = T

Ä_rewrite_thm Ö É té((T Ä t) = t) Ä ((t Ä T) = t) Ä
		(å (F Ä t)) Ä (å (t Ä F)) Ä (t Ä t) = t

Å_rewrite_thm Ö É té(T Å t) Ä (t Å T) Ä ((F Å t) = t) Ä ((t Å F) = t) Ä (t Å t) = t

ä_rewrite_thm Ö É té((T ä t) = t) Ä ((F ä t) = T) Ä ((t ä T) = T) Ä ((t ä t) = T)
  Ä (t ä F) = (å t)

if_rewrite_thm Ö É t1 t2:'aé((if T then t1 else t2) = t1) Ä (if F then t1 else t2) = t2

É_rewrite_thm Ö É té(É xét) = t

Ñ_rewrite_thm Ö É té(Ñ xét) = t

simple_%beta%_rewrite_thm Ö É t1:'a; t2:'bé((ç xét1)t2) = t1
Ê
The theorems are saved in the theory ``misc''.
=SEEALSO
$fst\_rewrite_thm$, $snd\_rewrite_thm$, $fst\_snd\_rewrite_thm$.
=ENDDOC
=TEX
\section{END OF THE SIGNATURE}
=SML
end; (* signature of Rewriting *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
