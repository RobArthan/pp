% imp007.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Implementation for the Derived Rules of Inference}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Derived Rules of Inference}
\TPPref{DS/FMU/IED/IMP007}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
% \TPPauthors{K.~Blackburn & WIN01\\D.J.~King & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}

\item [29 May 1991 Issue 1.1]
First version.
Primitive and built-in inference rules, and conversionals
all module tested to these implementations.

\item [30 May 1991 Issue 1.2] Added material up to $€$.

\item [31 May 1991 Issue 1.3] Added up to $Š\_trans\_rule$, corrected $»Œ¼$.

\item [7 June 1991 Issue 1.4] Added up to $Œ\_eq\_sym\_rule$, and DJK work.

\item [7 June 1991 Issue 1.5]
Corrected the description of $Œ\_1\_thm$,
and corrected $list\_simple\_ƒ\_intro$.
Added material up to $asm\_inst\_type\_rule$.

\item [10 June 1991 Issue 1.6] Corrected $simple\_„_elim$.

\item [10 June 1991 Issue 1.7] Added most of the rest.

\item [17 June 1991 Issue 1.8] Added the rest.

\item [18 June 1991 Issue 1.9]
Renamed $LIST\_THEN\_C$ to $EVERY\_C$, $LIST\_ORELSE\_C$ to $FIRST\_C$,
and added $COMB\_C$.
Tidying up, profiling put about successful calls.

\item [18 June 1991 Issue 1.10] Added author's names.

\item [19 June 1991 Issue 1.12]
Bought $TOP\_TRAVERSE\_C$ into line with prototype's 
$TOP\-\_DEPTH\-\_CONV$.
$prove\-\_asm\-\_rule$ doesn't worry about missing assumptions.
Corrected $\_match$ functions.

\item [19 June 1991 Issue 1.13] Corrected a use of $all\_simple\_ƒ\_elim$.

\item [21 June 1991 Issue 1.14]
Corrected $apply\_matches\_rule$.
Corrected various error messages.
Corrected $Œ\_intro$ and $Œ\_elim$.

\item [24 June 1991 Issue 1.15] Corrected $COMB\_C$ error message.

\item [27 June 1991 Issue 1.16]
Corrected indexing of saved theorems.
Changed $\_TRAVERSE\_C$ to $\_MAP\_C$.
Removed informal test material from ``=IGN'' sections.
$?\_MAP\_C$ all have failure 7005 added.
The prefix $simple$ is moved to being the first prefix, bar $icl'$.
Changed order of $all\_ƒ\_intro$ introduced variables.

\item[03 July 1991 Issue 1.17] $simple\_„\_elim$ changed in accord with issue 1.15 detailed design change.

\item[03 July 1991 Issue 1.18] Added $id\_conv$.

\item[25 July 1991 Issue 1.19] Split into two structures, see section~\ref{SplitStructure}.

\item [29 July 1991 Issue 1.20]
Changed as result of changes caused by IR0016.

\item [5 August 1991 Issue 1.21]
Reacting to issue 1.18 of \cite{DS/FMU/IED/DTD006}.

\item [8 August 1991 Issue 1.22]
Reacting to changes from ID0021.

\item [15th August 1991 Issue 1.23]
Renamings of functions containing the name atom $simple$,
and renaming of $aconv$.

\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the derived rules of inference.
This includes user versions of the
primitive and built-in inference rules.
The design is in \cite{DS/FMU/IED/DTD007}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the 
This includes user versions of the
primitive and built-in inference rules.
A ``primitive'' inference rule is considered to be part of the logic,
whereas a ``built-in'' rule is one that, though it could be coded in terms 
of the primitive rules, will actually be part of the abstract data type $THM$, and thus taken as holding true without checking.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD007},
and also requires those files indicated as preceding it in the 
rel001 makefile.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Compilation Note}
\label{SplitStructure}

Issues~1.18 and earlier of this document declared a single structure,
by issue~1.18 this had almost~2300 lines of Standard~ML.  Unfortunately
this structure failed to compile on Sun~3 computers although it did
compile on Sun~4 computers.  Investigations failed to find the exact
cause of the compilation failure apart from a code generation limit was
exceeded.

The resolution of the compilation failure was to divide the structure
into two pieces, as follows.

óSML example
structure DerivedInferenceRules = struct
	(* First set of declarations *)
	...
end;

structure âDerivedInferenceRulesá : DerivedInferenceRules = struct
	(* Second set of declarations *)
	open DerivedInferenceRules;
	...
end;

open DerivedInferenceRules;
æ

Here the two structures have the same name, there is a signature
constraint only on the second, the first structure is opened within the
second, the second structure declaration hides the first.  The effect
is to create one structure having the required signature.

\section{THE ABSTRACT DATA TYPE $THM$}
=SML
structure âDerivedInferenceRulesá = struct
=TEX
Temporary:
=SML
fun string_of_term (tm : TERM) = PolyML.makestring tm;
fun string_of_type (ty : TYPE) = PolyML.makestring ty;
=TEX
\subsection{Primitive and Built-in Rules}
This, and only this, part is done in the context
of an open kernel:
=SML
local
	open icl'Kernel;
in
=TEX
\subsubsection{Primitive Rules}
=SML
fun âsubst_ruleá (thm_var_lst : (THM * TERM) list) :
	TERM -> THM -> THM = (
	let val s1 = icl'subst_rule thm_var_lst
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule"
	in
	(fn (tm:TERM) =>
	let val s2 = s1 tm
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule"
	in
	(fn (thm : THM) =>
	(let
		val s3 = s2 thm
	in
		(prof "subst_rule";
		s3)
	end
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule")
	)
	end)
	end
);
=TEX
=SML
fun âsimple__eq_ruleá (tm : TERM) (thm : THM) : THM = (
let	val s1 = icl'simple__eq_rule tm thm
in
	(prof "simple__eq_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'simple__eq_rule" "simple__eq_rule"
);
=SML
fun âinst_type_ruleá (ty_list : (TYPE * TYPE) list) (thm : THM) : THM = (
let	val s1 = icl'inst_type_rule ty_list thm
in
	(prof "inst_type_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'inst_type_rule" "inst_type_rule"
);
=TEX
=SML
fun âŠ_introá (tm : TERM) (thm : THM) : THM = (
let	val s1 = icl'Š_intro tm thm
in
	(prof "Š_intro";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'Š_intro" "Š_intro"
);
=TEX
=SML
fun âŠ_elimá (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = icl'Š_elim thm1 thm2
in
	(prof "Š_elim";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'Š_elim" "Š_elim"
);
=TEX
=SML
fun âasm_ruleá (tm : TERM) : THM = (
let	val s1 = icl'asm_rule tm
in
	(prof "asm_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'asm_rule" "asm_rule"
);
=TEX
=SML
val ârefl_convá : CONV = (fn (tm:TERM) =>
let	val s1 = icl'refl_conv tm
in
	(prof "refl_conv";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'refl_conv" "refl_conv"
);
=TEX
=SML
val âsimple_%beta%_convá : CONV = (fn (tm:TERM) =>
let	val s1 = icl'simple_%beta%_conv tm
in
	(prof "simple_%beta%_conv";
	s1)
end
		handle complaint => 
		pass_on complaint "icl'simple_%beta%_conv" "simple_%beta%_conv"
);
=TEX
\subsubsection{Definitional Schemata}
=SML
local
	val N0 = mk_† 0;
in
val âsuc_convá : CONV = (fn (tm:TERM) =>
let	val s1 = if tm = N0
		then term_fail "suc_conv" 7100 [tm]
		else icl'suc_conv tm
in
	(prof "suc_conv";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'suc_conv" "suc_conv"
);
end;
=TEX
=SML
val âstring_convá : CONV = (fn (tm:TERM) =>
let	val s1 = icl'string_conv tm
in
	(prof "string_conv";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'string_conv" "string_conv"
);

=TEX
=SML
val âchar_convá : CONV = (fn (tm:TERM) =>
let	val s1 = icl'char_conv tm
in
	(prof "char_conv";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'char_conv" "char_conv"
);
=TEX
\subsubsection{Built-In Rules of Inference}
=SML
fun âeq_sym_ruleá (thm : THM) : THM = (
let	val s1 = icl'eq_sym_rule thm
in
	(prof "eq_sym_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'eq_sym_rule" "eq_sym_rule"
);
=TEX
=SML
fun âlist_simple_ƒ_elimá (tml : TERM list) (thm : THM) : THM = (
let	val s1 = icl'list_simple_ƒ_elim tml thm
in
	(prof "list_simple_ƒ_elim";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'list_simple_ƒ_elim" "list_simple_ƒ_elim"
);
=TEX
=SML
fun âeq_trans_ruleá (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = icl'eq_trans_rule thm1 thm2
in
	(prof "eq_trans_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'eq_trans_rule" "eq_trans_rule"
);
=TEX
=SML
fun âmk_app_ruleá (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = icl'mk_app_rule thm1 thm2
in
	(prof "mk_app_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'mk_app_rule" "mk_app_rule"
);
=TEX
=SML
fun â‚_mp_ruleá (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = icl'‚_mp_rule thm1 thm2
in
	(prof "‚_mp_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'‚_mp_rule" "‚_mp_rule"
);
=TEX
=SML
fun âsimple_ƒ_introá (tm : TERM) (thm : THM) : THM = (
let	val s1 = icl'simple_ƒ_intro tm thm
in
	(prof "simple_ƒ_intro";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'simple_ƒ_intro" "simple_ƒ_intro"
);
=TEX
=SML
fun âinst_term_ruleá (tml : (TERM * TERM) list) (thm : THM) : THM = (
let	val s1 = icl'inst_term_rule tml thm
in
	(prof "inst_term_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'inst_term_rule" "inst_term_rule"
);
=TEX
=SML
val âdiv2_convá : CONV = (fn (tm:TERM) =>
let	val s1 = icl'div2_conv tm
in
	(prof "div2_conv";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'div2_conv" "div2_conv"
);
=TEX
=SML
val âmod2_convá : CONV = (fn (tm:TERM) =>
let	val s1 = icl'mod2_conv tm
in
	(prof "mod2_conv";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'mod2_conv" "mod2_conv"
);
=TEX
It seems best to implement the following using $icl'list\_simple\_ƒ\_elim$ directly, rather than go through its interface, and thus an additional profiling call.
=RULE
simple_ƒ_elim
»t1¼
É
ö … ƒ x Ž t2[x]
É
ö … t2'[t1]
=TEX
where $x$ is a simple variables.
=SML
fun âsimple_ƒ_elimá (tm: TERM) (thm:THM) = (
let	val s1 = icl'list_simple_ƒ_elim [tm] thm
in
	(prof "simple_ƒ_elim";
	s1)
end
handle complaint =>
let 	val efrom = area_of complaint
in
	if efrom = "icl'list_simple_ƒ_elim"
	then (if not(is_simple_ƒ (concl thm))
		then thm_fail "simple_ƒ_elim" 7039 [thm]
		else let val (v,_) = dest_simple_ƒ (concl thm)
		in
			if type_of v <> type_of tm
			then term_fail "simple_ƒ_elim" 3012 [v,tm]
			else reraise complaint "simple_ƒ_elim"
		end)
	else reraise complaint efrom
end);

=TEX
=SML
end; (* local open icl'Kernel *)
=TEX
\subsection{Inference Rules For Conversions}
Two "proper" failures come from $mk\-\_app\-\_rule$,
each with their own failure message from
$ap\-\_fun\-\_rule$.
We need to do some calculation to determine which error
is given: but we only do this if we get a failure.
=SML
fun âap_fun_ruleá (tm : TERM) (thm : THM) : THM = ((
let	val s1 = refl_conv tm;
	val s2 = mk_app_rule s1 thm
in
	(prof "ap_fun_rule";
	s2)
end)
handle complaint =>
if is_eq(concl thm)
then divert complaint "mk_app_rule" "ap_fun_rule" 7024 [fn () => string_of_term tm]
else divert complaint "mk_app_rule" "ap_fun_rule" 6020 [fn () => string_of_thm thm]
);
=TEX
Two "proper" failures come from $mk\-\_app\-\_rule$,
each with their own failure message from
$ap\-\_arg\-\_rule$.
We need to do some calculation to determine which error
is given: but we only do this if we get a failure.
=SML
fun âap_arg_ruleá (tm : TERM) (thm : THM) : THM = (
let	val s1 = refl_conv tm;
	val s2 = mk_app_rule thm s1;
in
	(prof "ap_arg_rule";
	s2)
end
handle complaint =>
if is_eq(concl thm)
then divert complaint "mk_app_rule" "ap_arg_rule" 7025 [fn () => string_of_term tm]
else divert complaint "mk_app_rule" "ap_arg_rule" 6020 [fn () => string_of_thm thm]
);
=TEX

\subsection{Conversions}
\subsubsection{Building Blocks}
=SML
val âid_convá : CONV = refl_conv;

val âfail_convá : CONV = (fn (tm:TERM) => fail "fail_conv" 7061 []);

fun âfail_with_convá (str : string) : CONV = (
	fn (tm:TERM) => fail "fail_with_conv" 7075 [fn () => str]
);
=TEX
\subsubsection{Conversionals}
=SML
fun (cnv1 : CONV) âTHEN_Cá (cnv2 : CONV) : CONV = (fn (tm: TERM) =>
let	val s1 = cnv1 tm;
	val rhs_s1 = snd(dest_eq (concl s1))
		handle complaint =>
		divert complaint "dest_eq" "THEN_C" 7101 [fn () => string_of_thm s1];
	val s2 = cnv2 rhs_s1;
	val s3 = eq_trans_rule s1 s2
		handle complaint =>
		divert complaint "eq_trans_rule" "THEN_C" 7102 [fn () => string_of_thm s2,
			fn () => string_of_thm s1];
in
	s3
end);
=TEX
=SML
fun (cnv1 : CONV) âFURTHER_Cá (cnv2 : CONV) : CONV = (fn (tm: TERM) =>
let	val s1 = cnv1 tm
in
	(let
		val rhs_s1 = snd(dest_eq (concl s1));
		val s2 = cnv2 rhs_s1;
		val s3 = eq_trans_rule s1 s2
	in
		s3
	end
	handle (Fail _) => s1)
end);
=TEX
=SML
fun (cnv1 : CONV) âORELSE_Cá (cnv2 : CONV) : CONV = (fn (tm: TERM) =>
	cnv1 tm
handle (Fail _) =>
	cnv2 tm
);
=TEX
=SML
fun (cnv1 : CONV) âEITHER_Cá (cnv2 : CONV) : CONV = (fn (tm: TERM) =>
(let	val s1 = cnv1 tm
in
	(let
		val rhs_s1 = snd(dest_eq (concl s1));
		val s2 = cnv2 rhs_s1;
		val s3 = eq_trans_rule s1 s2;
	in
		s3
	end
	handle (Fail _) => s1)
end
handle (Fail _) => cnv2 tm)
);
=TEX
=SML
fun âTRY_Cá (cnv : CONV) : CONV = (fn (tm:TERM) =>
	cnv tm
	handle (Fail _) =>
	refl_conv tm
);
=TEX
=SML
fun âREPEAT1_Cá (cnv : CONV)  : CONV = (fn (tm:TERM) =>
	(cnv FURTHER_C (REPEAT1_C cnv)) tm
);
=TEX
Notice that the following is carefully coded to avoid
redundant $refl\_conv$'s.
There is a minor partial evaluation effect with 
only the conversion argument.
=SML
fun âREPEAT_Cá (cnv : CONV) : CONV = (fn (tm:TERM) =>
	TRY_C (REPEAT1_C cnv) tm
);
=TEX
Partially evaluated given only a list.
=SML
fun âEVERY_Cá ([cnv] : CONV list) : CONV = cnv
| EVERY_C (cnv :: crest) = cnv THEN_C (EVERY_C crest)
| EVERY_C [] = fail "EVERY_C" 7103 [];
=TEX
Partially evaluated given only a list.
=SML
fun âFIRST_Cá ([cnv] : CONV list) : CONV = cnv
| FIRST_C (cnv :: crest) = cnv ORELSE_C (FIRST_C crest)
| FIRST_C [] = fail "FIRST_C" 7103 [];
=TEX
=SML
fun âCHANGED_Cá (cnv : CONV) : CONV = (fn (tm:TERM) =>
let 	val s1 = cnv tm;
	val rhs_s1 = (snd o dest_eq o concl) s1;
in
	if rhs_s1 <> tm
	then s1
	else fail "CHANGED_C" 7032 []
end
handle complaint =>
divert complaint "dest_eq" "CHANGED_C" 7104[]);
=TEX
\subsubsection{Term Traversal Algorithms for Conversions}
=SML
fun  âRAND_Cá (cnv : CONV) : CONV = (fn (tm:TERM) =>
let
	val (f,x) = dest_app tm
		handle complaint =>
		pass_on complaint "dest_app" "RAND_C";
	val s1 = cnv x;
	val s2 = ap_fun_rule f s1;
in
	s2
end
handle complaint =>
divert complaint "ap_fun_rule" "RAND_C" 7104 []
);
=TEX
=SML
fun  âRATOR_Cá (cnv : CONV) : CONV = (fn (tm:TERM) =>
let
	val (f,x) = dest_app tm
		handle complaint =>
		pass_on complaint "dest_app" "RATOR_C";
	val s1 = cnv f;
	val s2 = ap_arg_rule x s1;
in
	s2
end
handle complaint =>
divert complaint "ap_arg_rule" "RATOR_C" 7104 []
);
=TEX
=SML
fun  âAPP_Cá (cnv1 : CONV, cnv2 : CONV) : CONV = (fn (tm:TERM) =>
let
	val (f,x) = dest_app tm
		handle complaint =>
		pass_on complaint "dest_app" "APP_C";
	val s1 = cnv1 f;
	val s2 = cnv2 x;
	val s3 = mk_app_rule s1 s2;
in
	s3
end
handle complaint =>
divert complaint "mk_app_rule" "APP_C" 7104 []
);
=TEX
=SML
fun  âSIMPLE__Cá (cnv : CONV) : CONV = (fn (tm:TERM) =>
let
	val (x,b) = dest_simple_ tm
		handle complaint =>
		pass_on complaint "dest_simple_" "SIMPLE__C";
	val s1 = cnv b;
	val s2 = simple__eq_rule x s1
in
	s2
end
handle complaint =>
divert complaint "simple__eq_rule" "SIMPLE__C" 7104 []
);
=TEX
We do the following in full to be able to determine the
correct error message, if necessary.
It could just be $RAND\_C\ o\ SIMPLE\_\_C$.
=SML
fun  âBINDER_Cá (cnv : CONV) : CONV = (fn (tm:TERM) =>
let
	val (binder,abs) = dest_app tm;
	val (x,b) = dest_simple_ abs;
	val s1 = cnv b;
	val s2 = ap_fun_rule binder (simple__eq_rule x s1);
in
	s2
end
handle complaint =>
list_divert complaint "BINDER_C" [
	("dest_simple_",7059,[fn () => string_of_term tm]),
	("dest_app",7059,[fn () => string_of_term tm]),
	("simple__eq_rule",7104,[]),
	("ap_fun_rule",7104,[])]
);
=TEX
We could build the following using the above building blocks,
but prefer to keep it fast.
=SML
fun âSUB_Cá (cnv : CONV) : CONV = (fn (tm:TERM) =>
let
	fun aux (Var _) = refl_conv tm
	| aux (Const _) = refl_conv tm
	| aux (App (f,x)) = (
		((let val thm1 = cnv f
		in
		 (let val thm2 = cnv x
		 in
			mk_app_rule thm1 thm2
		 end
		 handle (Fail _) =>
		 ap_arg_rule x thm1)
		end)
		handle (Fail _) =>
		(let val thm2 = cnv x
		in
			ap_fun_rule f thm2
		end))
		handle (Fail _) => refl_conv tm
	) | aux (Simple (x,b)) = (
		let val thm1 = cnv b
		in
			simple__eq_rule x thm1
		end
		handle (Fail _) =>
		refl_conv tm
	);
in
	aux(dest_simple_term tm)
end
handle complaint =>
list_divert complaint "SUB_C" [
	("mk_app_rule",7104,[]),
	("simple__eq_rule",7104,[])]
);
=TEX
There is a mild partial evaluation with only a conversion.
=SML
fun âSUB1_Cá (cnv : CONV) : CONV = (fn (tm:TERM) => 
let
	fun aux (Var _) = term_fail "SUB1_C"  7105 [tm]
	| aux (Const _) = term_fail "SUB1_C"  7105 [tm]
	| aux (App (f,x)) = (
		let val thm1 = cnv f
		in
		 (let val thm2 = (cnv x
			handle (Fail _) => refl_conv x)
		 in
			mk_app_rule thm1 thm2
		 end)
		end
		handle (Fail _) =>
		(let val thm2 = cnv x
		in
			ap_fun_rule f thm2
		end)
	) | aux (Simple (x,b)) = (
		let val thm1 = cnv b
		in
			simple__eq_rule x thm1
		end
	);
in
	aux(dest_simple_term tm)
end
handle complaint =>
list_divert complaint "SUB1_C" [
	("ap_fun_rule",7104,[]),
	("simple__eq_rule",7104,[])]
);
=TEX
N.B. the $fn\ (tm: TERM) \ldots tm$ might look $\eta$-convertible away, but actually prevents an infinite loop.
=SML
fun âONCE_MAP_Cá (cnv : CONV) : CONV = (fn (tm: TERM) => 
let	fun aux (tm : TERM) = (cnv ORELSE_C (SUB1_C aux)) tm
in
	aux tm
end
handle (Fail _) => fail "ONCE_MAP_C" 7005 []
);
=TEX
=SML
fun âMAP_Cá (cnv : CONV) : CONV = (fn (tm: TERM) => 
let	fun aux (tm : TERM) = ((SUB1_C (MAP_C cnv)) EITHER_C (REPEAT1_C cnv)) tm
in
	(aux tm)
end
handle (Fail _) => fail "MAP_C" 7005 []
);
=TEX
=SML
fun âREPEAT_MAP_Cá (cnv : CONV) : CONV = (fn (tm: TERM) => 
let	fun aux (tm : TERM) = ((SUB1_C (REPEAT_MAP_C cnv))
	EITHER_C (cnv FURTHER_C (REPEAT_MAP_C cnv))) tm
in
	(aux tm)
end
handle (Fail _) => fail "REPEAT_MAP_C" 7005 []
);
=TEX
=SML
fun âTOP_MAP_Cá (cnv : CONV) : CONV = (fn (tm: TERM) => 
let	fun aux (tm : TERM) = ((REPEAT1_C cnv) EITHER_C 
	((CHANGED_C (SUB1_C(TOP_MAP_C cnv)))
		FURTHER_C
		(cnv FURTHER_C (TOP_MAP_C cnv)))) tm
in
	(aux tm)
end
handle (Fail _) => fail "TOP_MAP_C" 7005 []
);
=TEX
\subsubsection{Conversions as Rules}
=SML
fun âconv_ruleá (cnv : CONV) (thm : THM) : THM = (
let	val s1 = cnv(concl thm);
	val s2 = ‚_mp_rule s1 thm
in
	(prof "conv_rule";
	s2)
end
handle complaint =>
divert complaint "‚_mp_rule" "conv_rule" 7104 []);
=TEX 
\section{DERIVED INFERENCE RULES}
We will be saving theorems as we go along, so we need to ensure we are saving them into theory misc:
=SML
val sideeffect = open_theory "misc";
=TEX
An alias:
=SML
val âŠ_mp_ruleá = Š_elim;
=TEX
The following is out of place, but useful if declared immediately:
=SML
fun âundisch_ruleá (thm : THM) : THM = (
let
	val (a,b) = dest_Š(concl thm);
	val s1 = asm_rule a;
	val s2 = Š_elim thm s1
in
	(prof "undisch_rule";
	s2)
end
handle complaint =>
divert complaint "dest_Š" "undisch_rule" 7011 [fn () => string_of_thm thm]
);
=TEX
Something else out of sequence:
=SML
fun âdisch_ruleá (tm : TERM) (thm : THM) : THM = (
	if tm term_mem (hyps thm)
	then (let val s1 = Š_intro tm thm
		in
			(prof "disch_rule";
			s1)
		end
		handle complaint =>
		pass_on complaint "Š_intro" "disch_rule")
	else fail "disch_rule" 7031 [fn () => string_of_term tm]
);
=TEX
		
\subsection{Concerning $T$}
Proof of $T$ (as 12.3.9)
=SML
local
	val s1 = t_def;
	val s2 = eq_sym_rule s1;
	val s3 = refl_conv » x : BOOL Ž x¼;
	val s4 = ‚_mp_rule s2 s3;
in
	val ât_thmá = save_thm("t_thm",s4)
end;
=TEX
We could work by a local theorem:
ó
… ƒ x Ž x ‚ (x ‚ T)
æ
but choose to work by the more primitive route of 12.3.12
=SML
fun â‚_t_introá (thm : THM) : THM = (
let
	val t = concl thm;
	val s3 = list_simple_ƒ_elim [t, mk_t] Š_antisym_axiom;
	val s5 = Š_intro t t_thm;
	val s5 = Š_elim s3 s5;
	val s8 = Š_intro mk_t thm;
	val s9 = Š_elim s5 s8;
in
	(prof "‚_t_intro";
	s9)
end);
=TEX
In the following we could chose to try eliminating
all outermost $\ldots ‚ T$ and $T ‚ \ldots$.
D.I.Y. form:
=SML
fun â‚_t_elimá (thm : THM) : THM = (
let	val s1 = eq_sym_rule thm;
	val s2 = ‚_mp_rule s1 t_thm;
in
	(prof "‚_t_elim";
	s2)
end
handle complaint =>
list_divert complaint "‚_t_elim" [
	("eq_sym_rule",7106,[fn () => string_of_thm thm]),
	("‚_mp_rule",7106,[fn () => string_of_thm thm])]);
=TEX
D.I.Y. form:
=SML
fun âcontr_ruleá (tm : TERM) (thm : THM) : THM = (
let	val s1 = ‚_mp_rule f_def thm;
	val s2 = simple_ƒ_elim tm s1;
in
	(prof "contr_rule";
	s2)
end
handle complaint =>
list_divert complaint "contr_rule" [
	("‚_mp_rule", 7001, [fn () => string_of_thm thm]),
	("simple_ƒ_elim",3031,[fn () => string_of_term tm])]
);
=TEX
The following is out of sequence, but necessary at this point:
we first prove theorem:
ó
_thm = … ƒ t1 t2 Ž (t1  t2) = (ƒ b Ž (t1 Š b) Š (t2 Š b) Š b)
æ
=SML
local
	val s1 = ap_arg_rule »t1 : BOOL¼ _def;
	val s2 = ap_arg_rule »t2 : BOOL¼ s1;
	val s3 = conv_rule (MAP_C simple_%beta%_conv) s2;
	val s4 = simple_ƒ_intro »t2 : BOOL¼ s3;
	val s5 = simple_ƒ_intro »t1 : BOOL¼ s4;
in
	val â_thmá = save_thm("_thm",s5)
end;
=TEX
Then the out of place rule
(roughly as \cite{DS/FMU/IED/SML009} 5.14):
=SML
fun â_elimá (a__b  : THM) (a_thm : THM) (b_thm : THM) = (
let
	val (a,b) = dest_(concl a__b);
	val s1 = Š_intro a a_thm;
	val s2 = Š_intro b b_thm;
	val s3 = list_simple_ƒ_elim [a, b] _thm;
	val s4 = ‚_mp_rule s3 a__b;
	val s5 = simple_ƒ_elim (concl a_thm) s4;
	val s6 = Š_elim s5 s1;
	val s7 = Š_elim s6 s2;
in
	(prof "_elim";
	s7)
end
handle complaint =>
list_divert complaint "_elim" [
	("dest_",7010,[fn () => string_of_thm a__b]),
	("Š_elim",7083,[fn () => string_of_thm a__b, 
		fn () => string_of_thm a_thm, fn () => string_of_thm b_thm])]
);
=TEX
Then another out of place theorem:
ó
Œ_thm = … ƒ t Ž (Œ t) = (t Š F)
æ
=SML
local
	val s1 = ap_arg_rule »t : BOOL¼ Œ_def;
	val s2 = conv_rule (MAP_C simple_%beta%_conv) s1;
	val s3 = simple_ƒ_intro »t : BOOL¼ s2;
in
	val âŒ_thmá = save_thm("Œ_thm", s3)
end;
=TEX
Roughly as 5.17 of \cite{DS/FMU/IED/SML009}:
First prove the local theorem:
ó
ƒ t Ž (Œ t Š F) Š t
æ
=SML
local
	val s1 = asm_rule »(t Š F) Š F¼;
	val s2 = asm_rule »t ‚ F¼;
	val s4 = subst_rule[(s2,»t : BOOL¼)] (concl s1) s1;
	val s5 = asm_rule mk_f;
	val s6 = Š_intro mk_f s5;
	val s7 = Š_elim s4 s6;
	val s8 = eq_sym_rule s2;
	val s9 = ‚_mp_rule s8 s7;
	val s10 = asm_rule »t = T¼;
	val s11 = ‚_t_elim s10;
	val s13 = simple_ƒ_elim »t : BOOL¼ bool_cases_axiom;
	val s14 = _elim s13 s11 s9;
	val s15 = Š_intro »(t Š F) Š F¼ s14;
	val s16 = simple_ƒ_elim »t : BOOL¼ Œ_thm;
	val s17 = eq_sym_rule s16;
	val s18 = conv_rule (ONCE_MAP_C (fn x =>
		if x = »t Š F¼ then s17 else (fail_conv x))) s15;
	val s19 = simple_ƒ_intro »t : BOOL¼ s18;
in
=TEX
now the main function:
=SML
fun âc_contr_ruleá (tm : TERM) (thm : THM) : THM = (
let
	val mf_s1 = simple_ƒ_elim tm s19;
	val Œ_tm = mk_Œ tm;
	val mf_s2 = disch_rule Œ_tm thm;
	val mf_s3 = Š_elim mf_s1 mf_s2
in
	(prof "c_contr_rule";
	mf_s3)
end
handle complaint =>
list_divert complaint "c_contr_rule" [
	("Š_elim", 7001, [fn () => string_of_thm thm]),
	("simple_ƒ_elim", 3031, [fn () => string_of_term tm]),
	("disch_rule", 7003, [fn () => string_of_term tm])]
);
end;
=TEX
\subsection{Concerning Negation}
This is entirely new:
we first prove the local theorem:
ó
… ƒ a Ž (Œ a) ‚ (a Š ƒ b Ž b)
æ
=SML
local
	val s1 = conv_rule(ONCE_MAP_C(fn x =>
		if x = mk_f then f_def else fail_conv x))
		Œ_thm;
in
fun âŒ_elimá (tm : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let
	val sideeffect = if type_of tm <> BOOL
		then term_fail "Œ_elim" 3031 [tm]
		else ();
in
(let
	val s2 = simple_ƒ_elim (concl thm1) s1;
	val s3 = ‚_mp_rule s2 thm2;
	val s4 = Š_elim s3 thm1;
	val s5 = simple_ƒ_elim tm s4
in
	(prof "Œ_elim";
	s5)
end
handle (Fail _) =>
let
	val s2 = simple_ƒ_elim (concl thm2) s1;
	val s3 = ‚_mp_rule s2 thm1;
	val s4 = Š_elim s3 thm2;
	val s5 = simple_ƒ_elim tm s4
in
	(prof "Œ_elim";
	s5)
end
handle complaint =>
list_divert complaint "Œ_elim" [
	("‚_mp_rule",7004,[fn () => string_of_thm thm1, fn () => string_of_thm thm2]),
	("Š_elim",7004,[fn () => string_of_thm thm1, fn () => string_of_thm thm2])
	]
)
end
);
end;
=TEX
	
This is entirely new:
we first prove:
ó
s13 = … ƒ a b Ž (a Š b) Š (a Š Œb) Š Œa
æ
=SML
local
	val s1 = asm_rule »a Š b¼;
	val s2 = undisch_rule s1;
	val s3 = asm_rule »a Š Œ b¼;
	val s4 = undisch_rule s3;
	val s5 = Œ_elim mk_f s2 s4;
	val s6 = Š_intro »a : BOOL¼ s5;
	val s7 = simple_ƒ_elim »a : BOOL¼ Œ_thm;
	val s8 = eq_sym_rule s7;
	val s9 = conv_rule (ONCE_MAP_C (fn x =>
		if x = »a Š F¼ then s8 else (fail_conv x))) s6;
	val s10 = Š_intro »a Š Œ b¼ s9;
	val s11 = Š_intro »a Š b¼ s10;
	val s12 = simple_ƒ_intro »b : BOOL¼ s11;
	val s13 = simple_ƒ_intro »a : BOOL¼ s12;
in
=TEX
Main function:
=SML
fun âŒ_introá (tm : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let
	val mf_s1 = Š_intro tm thm1;
	val mf_s2 = Š_intro tm thm2;
in
((let
	val mf_s3 = list_simple_ƒ_elim [tm, concl thm1] s13;
	val mf_s4 = Š_elim mf_s3 mf_s1;
	val mf_s5 = Š_elim mf_s4 mf_s2
in
	(prof "Œ_intro";
	mf_s5)
end)
handle (Fail _) => 
(let
	val mf_s3 = list_simple_ƒ_elim [tm, concl thm2] s13;
	val mf_s4 = Š_elim mf_s3 mf_s2;
	val mf_s5 = Š_elim mf_s4 mf_s1
in
	(prof "Œ_intro";
	mf_s5)
end))
end
handle complaint =>
list_divert complaint "Œ_intro" [
	("Š_elim", 7004, [fn () => string_of_thm thm1, fn () => string_of_thm thm2]),
	("Š_intro", 3031, [fn () => string_of_term tm]),
	("simple_ƒ_elim", 3031, [fn () => string_of_term tm])
	]
);
end;
=TEX
Prove the following (out of sequence)
ó
f_thm = … Œ F
æ
=SML
local
	val s1 = asm_rule mk_f;
	val s2 = Š_intro mk_f s1;
	val s3 = simple_ƒ_elim mk_f Œ_thm;
	val s4 = eq_sym_rule s3;
	val s5 = ‚_mp_rule s4 s2;
in
	val âf_thmá = save_thm("f_thm",s5)
end;
=TEX
Prove the following (out of sequence)
ó
Œ_t_thm = … Œ T ‚ F
æ
=SML
local
	val s1 = simple_ƒ_elim »Œ T¼ bool_cases_axiom;
	val s2 = asm_rule »(Œ T) ‚ F¼;
	val s3 = asm_rule »Œ T ‚ T¼;
	val s4 = ‚_t_elim s3;
	val s5 = Œ_elim  »Œ T ‚ F¼ t_thm s4;
	val s6 = _elim s1  s5 s2;
in
	val âŒ_t_thmá = save_thm("Œ_t_thm",s6)
end;
=TEX
We prove the local theorems:
ó
s14 = … Œ(Œ t) ‚ t
s16 = … t ‚ Œ(Œ t)
æ
=SML
local
	val s1 = ‚_t_intro f_thm;
	val s2 = ap_fun_rule »$Œ¼ s1;
	val s3 = eq_trans_rule s2 Œ_t_thm;
	val s4 = ap_fun_rule »$Œ¼ Œ_t_thm;
	val s5 = eq_trans_rule s4 s1;
	val s6 = asm_rule »t ‚ T¼;
	val s7 = eq_sym_rule s6;
	val s8 = subst_rule [(s7,»x : BOOL¼)] »Œ(Œ x) ‚ x¼ s5;
	val s9 = asm_rule »t ‚ F¼;
	val s10 = eq_sym_rule s9;
	val s11 = subst_rule [(s10,»x : BOOL¼)] »Œ(Œ x) ‚ x¼ s3;
	val s12 = simple_ƒ_elim »t : BOOL¼ bool_cases_axiom;
	val s13 = _elim s12 s8 s11;
	val s14 = simple_ƒ_intro »t : BOOL¼ s13;
	val s15 = eq_sym_rule s13;
	val s16 = simple_ƒ_intro »t : BOOL¼ s15;
in
=TEX
Main functions:
=SML
fun âŒ_Œ_introá (thm : THM) : THM = (
let
	val mf_s1 = simple_ƒ_elim (concl thm) s16;
	val mf_s2 = ‚_mp_rule mf_s1 thm
in
	(prof "Œ_Œ_intro";
	mf_s2)
end);

fun âŒ_Œ_elimá (thm : THM) : THM = (
let
	val bdy = dest_Œ(dest_Œ(concl thm));
	val mf_s1 = simple_ƒ_elim bdy s14;
	val mf_s2 = ‚_mp_rule mf_s1 thm
in
	(prof "Œ_Œ_elim";
	mf_s2)
end
handle complaint =>
divert complaint "dest_Œ" "Œ_Œ_elim" 7006 [fn () => string_of_thm thm]
);
end; (* local *)
=TEX
\subsection{Concerning €}
ó
€_thm = … ƒ t1 t2 Ž (t1 € t2) = (ƒ b Ž (t1 Š t2 Š b) Š b)
æ
=SML
local
	val s1 = ap_arg_rule »t1 : BOOL¼ €_def;
	val s2 = ap_arg_rule »t2 : BOOL¼ s1;
	val s3 = conv_rule (MAP_C simple_%beta%_conv) s2;
	val s4 = simple_ƒ_intro »t2 : BOOL¼ s3;
	val s5 = simple_ƒ_intro »t1 : BOOL¼ s4;
in
	val â€_thmá = save_thm("€_thm",s5)
end;
=TEX
Following \cite{DS/FMU/IED/SML009} 5.10:
We prove the local theorem:
ó
s14 = ƒ t1 t2 Ž t1 Š t2 Š (t1 € t2)
æ
=SML
local
	val s1 = asm_rule »t1 Š t2 Š b¼;
	val s3 = undisch_rule s1;
	val s5 = undisch_rule s3;
	val s6 = Š_intro »t1 Š t2 Š b¼ s5;
	val s7 = simple_ƒ_intro »b : BOOL¼ s6;
	val s8 = list_simple_ƒ_elim [»t1 : BOOL¼, »t2 : BOOL¼] €_thm;
	val s9 = eq_sym_rule s8;
	val s10 = ‚_mp_rule s9 s7;
	val s11 = Š_intro »t2 : BOOL¼ s10;
	val s12 = Š_intro »t1 : BOOL¼ s11;
	val s13 = simple_ƒ_intro »t2 : BOOL¼ s12;
	val s14 = simple_ƒ_intro »t1 : BOOL¼ s13;
in
fun â€_introá (thm1 : THM) (thm2 : THM) : THM = (
let
	val mf_s1 = list_simple_ƒ_elim[concl thm1, concl thm2] s14;
	val mf_s2 = Š_elim mf_s1 thm1;
	val mf_s3 = Š_elim mf_s2 thm2;
in
	(prof "€_intro";
	mf_s3)
end);
end;
=TEX
We prove the local theorem:
ó
s11 = ƒ t1 t2 Ž (t1 € t2) Š t1
æ
=SML
local 
	val s1 = list_simple_ƒ_elim [»t1 : BOOL¼, »t2 : BOOL¼] €_thm;
	val s2 = asm_rule »t1 € t2¼;
	val s3 = ‚_mp_rule s1 s2;
	val s4 = simple_ƒ_elim »t1 : BOOL¼ s3;
	val s5 = asm_rule »t1 : BOOL¼;
	val s6 = Š_intro »t2 : BOOL¼ s5;
	val s7 = Š_intro »t1 : BOOL¼ s6;
	val s8 = Š_elim s4 s7;
	val s9 = Š_intro »t1 € t2¼ s8;
	val s10 = simple_ƒ_intro »t2 : BOOL¼ s9;
	val s11 = simple_ƒ_intro »t1 : BOOL¼ s10;
in
fun â€_left_elimá (thm :THM) : THM = (
let
	val (t1,t2) = dest_€(concl thm);
	val mf_s1 = list_simple_ƒ_elim [t1, t2] s11;
	val mf_s2 = Š_elim mf_s1 thm;
in
	(prof "€_left_elim";
	mf_s2)
end
handle complaint =>
divert complaint "dest_€" "€_left_elim" 7007 [fn () => string_of_thm thm]
);
end;
=TEX
We prove the local theorem:
ó
s11 = ƒ t1 t2 Ž (t1 € t2) Š t2
æ
=SML
local 
	val s1 = list_simple_ƒ_elim [»t1 : BOOL¼, »t2 : BOOL¼] €_thm;
	val s2 = asm_rule »t1 € t2¼;
	val s3 = ‚_mp_rule s1 s2;
	val s4 = simple_ƒ_elim »t2 : BOOL¼ s3;
	val s5 = asm_rule »t2 : BOOL¼;
	val s6 = Š_intro »t2 : BOOL¼ s5;
	val s7 = Š_intro »t1 : BOOL¼ s6;
	val s8 = Š_elim s4 s7;
	val s9 = Š_intro »t1 € t2¼ s8;
	val s10 = simple_ƒ_intro »t2 : BOOL¼ s9;
	val s11 = simple_ƒ_intro »t1 : BOOL¼ s10;
in
fun â€_right_elimá (thm :THM) : THM = (
let
	val (t1,t2) = dest_€(concl thm);
	val mf_s1 = list_simple_ƒ_elim [t1, t2] s11;
	val mf_s2 = Š_elim mf_s1 thm;
in
	(prof "€_right_elim";
	mf_s2)
end
handle complaint =>
divert complaint "dest_€" "€_right_elim" 7007 [fn () => string_of_thm thm]
);
end;
=TEX
=SML
fun âlist_€_introá ([] : THM list) : THM = (
	fail "list_€_intro" 7107 []
) | list_€_intro thm_lst = (
let
	fun aux [thm] = thm
	| aux (thm :: rest) = €_intro thm (aux rest)
	| aux _ = error "list_€_intro" 0000 [];
	val s1 = aux thm_lst;
in
	(prof "list_€_intro";
	s1)
end);

=TEX
=SML
fun âstrip_€_ruleá (thm : THM) : THM list = (
let
	fun aux thm1 = (
	let	val s1 = €_left_elim thm1;
		val s2 = €_right_elim thm1;
	in
		aux s1 @ aux s2
	end
	handle (Fail _) => [thm1]
	);
	val s1 = aux thm;
in
	(prof "strip_€_rule";
	s1)
end);
=TEX
\subsection{Concerning }
As \cite{DS/FMU/IED/SML009} 5.13.
We prove the local theorem:
ó
s12 … ƒ t1 t2 Ž t1 Š (t1  t2)
æ
=SML
local
	val s1 = asm_rule »t1 Š b¼;
	val s3 = undisch_rule s1;
	val s4 = Š_intro »t2 Š b¼ s3;
	val s5 = Š_intro »t1 Š b¼ s4;
	val s6 = simple_ƒ_intro »b :BOOL¼ s5;
	val s7 = list_simple_ƒ_elim [»t1 : BOOL¼,»t2 : BOOL¼] _thm;
	val s8 = eq_sym_rule s7;
	val s9 =  ‚_mp_rule s8 s6;
	val s10 = Š_intro »t1 : BOOL¼ s9;
	val s11 = simple_ƒ_intro »t2 : BOOL¼ s10;
	val s12 = simple_ƒ_intro »t1 : BOOL¼ s11;
in
fun â_right_introá (tm : TERM) (thm : THM) : THM = (
let
	val mf_s1 = list_simple_ƒ_elim [concl thm, tm] s12 ;
	val mf_s2 = Š_elim mf_s1 thm
in
	(prof "_right_intro";
	mf_s2)
end
handle complaint =>
divert complaint "list_simple_ƒ_elim" "_right_intro" 3031 [fn () => string_of_term tm]
);
end;
=TEX
We prove the local theorem:
ó
s12 … ƒ t1 t2 Ž t2 Š (t1  t2)
æ
=SML
local
	val s1 = asm_rule »t2 Š b¼;
	val s3 = undisch_rule s1;
	val s4 = Š_intro »t2 Š b¼ s3;
	val s5 = Š_intro »t1 Š b¼ s4;
	val s6 = simple_ƒ_intro »b :BOOL¼ s5;
	val s7 = list_simple_ƒ_elim [»t1 : BOOL¼,»t2 : BOOL¼] _thm;
	val s8 = eq_sym_rule s7;
	val s9 =  ‚_mp_rule s8 s6;
	val s10 = Š_intro »t2 : BOOL¼ s9;
	val s11 = simple_ƒ_intro »t2 : BOOL¼ s10;
	val s12 = simple_ƒ_intro »t1 : BOOL¼ s11;
in
fun â_left_introá (tm : TERM) (thm : THM) : THM = (
let
	val mf_s1 = list_simple_ƒ_elim [tm, concl thm] s12 ;
	val mf_s2 = Š_elim mf_s1 thm
in
	(prof "_left_intro";
	mf_s2)
end
handle complaint =>
divert complaint "list_simple_ƒ_elim" "_left_intro" 3031 [fn () => string_of_term tm]
);
end;
=TEX
Entirely new:
We prove the prove the local theorem:
ó
Œ_1_thm =  … ƒ t Ž (Œ t) ‚ (t ‚ F)
æ
=SML
local
	val s1 = asm_rule mk_f;
	val s2 = contr_rule »t : BOOL¼ s1;
	val s3 = Š_intro mk_f s2;
	val s4 = asm_rule »t Š F¼;
	val s5 = list_simple_ƒ_elim [»t : BOOL¼, mk_f] Š_antisym_axiom;
	val s6 = Š_elim s5 s4;
	val s7 = Š_elim s6 s3;
	val s8 = Š_intro »t Š F¼ s7;
	val s9 = simple_ƒ_elim  »t : BOOL¼ Œ_thm;
	val s10 = eq_sym_rule s9;
	val s11 = subst_rule[(s10,»x : BOOL¼)] »x Š (t ‚ F)¼ s8;
	val s12  = asm_rule »t ‚ F¼;
	val s13 = eq_sym_rule s12;
	val s14 = subst_rule[(s13,»x : BOOL¼)]»Œ x¼  f_thm;
	val s15 = Š_intro »t ‚ F¼ s14;
	val s16 = list_simple_ƒ_elim [»Œ t¼, »t ‚ F¼] Š_antisym_axiom;
	val s17 = Š_elim s16 s11;
	val s18 = Š_elim s17 s15;
	val s19 = simple_ƒ_intro »t : BOOL¼ s18;
in
val  âŒ_1_thmá = save_thm("Œ_1_thm",s19);
end;
=TEX
We then locally prove:
ó
s10 … ƒ t1 t2 Ž (t1  t2) Š (Œ t2) Š t1
s17 … ƒ t1 t2 Ž (t1  t2) Š (Œ t1) Š t2
æ
=SML
local
	val s1 = asm_rule »t1  t2¼;
	val s2 = asm_rule »t1 : BOOL¼;
	val s3 = asm_rule »t2 : BOOL¼;
	val s4 = asm_rule »Œ t2¼;
	val s5 = Œ_elim »t1 : BOOL¼ s3 s4;
	val s6 = _elim s1 s2 s5;
	val s7 = Š_intro »Œ t2¼ s6;
	val s8 = Š_intro »t1  t2¼ s7;
	val s9 = simple_ƒ_intro »t2 : BOOL¼ s8;
	val s10 = simple_ƒ_intro »t1 : BOOL¼ s9;

	val s11 = asm_rule  »Œ t1¼;
	val s12 = Œ_elim »t2 : BOOL¼ s2 s11;
	val s13 = _elim s1 s12 s3;
	val s14 = Š_intro »Œ t1¼ s13;
	val s15 = Š_intro »t1  t2¼ s14;
	val s16 = simple_ƒ_intro »t2 : BOOL¼ s15;
	val s17 = simple_ƒ_intro »t1 : BOOL¼ s16;
in
fun â_cancel_ruleá (thm1 : THM) (thm2 : THM) : THM = (
let
	val (t1,t2) = dest_ (concl thm1);
in
(let
	val mf_s1 = list_simple_ƒ_elim [t1,t2] s10;
	val mf_s2 = Š_elim mf_s1 thm1;
	val mf_s2 = Š_elim mf_s2 thm2;
in
	(prof "_cancel_rule";
	mf_s2)
end
handle Fail _ =>
let
	val mf_s1 = list_simple_ƒ_elim [t1,t2] s17;
	val mf_s2 = Š_elim mf_s1 thm1;
	val mf_s2 = Š_elim mf_s2 thm2;
in
	(prof "_cancel_rule";
	mf_s2)
end)
end
handle complaint =>
list_divert complaint "_cancel_rule" [
	("dest_",7010,[fn () => string_of_thm thm1]),
	("Š_elim",7050,[fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
end;
=TEX
\subsection{Concerning Š}
Can only do $Š\_match\_mp\_rule$ after we have $ƒ\_elim$.
=SML
fun âstrip_Š_ruleá (thm : THM) : THM = (
let
	val (p, q) = dest_Š (concl thm);
	val s1 = asm_rule p;
	val s2 = Š_elim thm s1;
in
	strip_Š_rule s2
end
handle (Fail _) => thm
);
=TEX
=SML
fun âall_Š_introá (thm : THM) : THM = (
let	
	val hs = hyps thm;
	val s1 = fold (uncurry Š_intro) hs thm;
in
	(prof "all_Š_intro";
	s1)
end);
=TEX
Local theorem:
ó
s10 … ƒ t1 t2 t3 Ž (t1 Š t2) Š (t2 Š t3) Š (t1 Š t3)
æ
=SML
local
	val s1 = asm_rule »t1 Š t2¼;
	val s2 = asm_rule »t2 Š t3¼;
	val s3 = undisch_rule s1;
	val s4 = Š_elim s2 s3;
	val s5 = Š_intro »t1 : BOOL¼ s4;
	val s6 = Š_intro »t2 Š t3¼ s5;
	val s7 = Š_intro »t1 Š t2¼ s6;
	val s8 = simple_ƒ_intro »t3 : BOOL¼ s7;
	val s9 = simple_ƒ_intro »t2 : BOOL¼ s8;
	val s10 = simple_ƒ_intro »t1 : BOOL¼ s9;
in
fun âŠ_trans_ruleá (thm1 : THM) (thm2 : THM) : THM = (
let
	val (t1,t2) = dest_Š(concl thm1)
		handle complaint =>
		divert complaint "dest_Š" "Š_trans_rule" 7040
			[fn () => string_of_thm thm1];
	val (t2',t3) = dest_Š(concl thm2)
		handle complaint =>
		divert complaint "dest_Š" "Š_trans_rule" 7040
			[fn () => string_of_thm thm2];
	val mf_s1 = list_simple_ƒ_elim[t1, t2, t3] s10;
	val mf_s2 = Š_elim mf_s1 thm1;
	val mf_s3 = Š_elim mf_s2 thm2
		handle complaint =>
		divert complaint "Š_elim" "Š_trans_rule" 7042
			[fn () => string_of_thm thm1, fn () => string_of_thm thm2];
in
	(prof "Š_trans_rule";
	mf_s3)
end);
end;
=TEX
ó
s13 … ƒ t1 t2 Ž (t1 Š t2) Š (Œ t2) Š (Œ t1)
æ
=SML
local
	val s1 = asm_rule »t1 : BOOL¼;
	val s2 = asm_rule »t1 Š t2¼;
	val s3 = Š_elim s2 s1;
	val s4 = asm_rule »Œ t2¼;
	val s5 = Œ_elim mk_f s3 s4;
	val s6 = Š_intro »t1 : BOOL¼ s5;
	val s7 = simple_ƒ_elim »t1 : BOOL¼ Œ_thm;
	val s8 = eq_sym_rule s7;
	val s9 = ‚_mp_rule s8 s6;
	val s10 = Š_intro »Œ t2¼ s9;
	val s11 = Š_intro »t1 Š t2¼ s10;
	val s12 = simple_ƒ_intro »t2 : BOOL¼ s11;
	val s13 = simple_ƒ_intro »t1 : BOOL¼ s12;
in
fun âmodus_tollens_ruleá (thm1 : THM) (thm2 : THM) : THM = (
let
	val (t1,t2) = dest_Š(concl thm1);
	val mf_s1 = list_simple_ƒ_elim[t1,t2] s13;
	val mf_s2 = Š_elim mf_s1 thm1;
	val mf_s3 = Š_elim mf_s2 thm2;
in
	(prof "modus_tollens_rule";
	mf_s3)
end
handle complaint =>
list_divert complaint "modus_tollens_rule" [
	("dest_Š",7040,[fn () => string_of_thm thm1]),
	("Š_elim",7051,[fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
end;
=TEX
\subsection{Concerning ‚}
=SML
fun â‚_introá (thm1 : THM) (thm2 : THM) : THM = (
let 	val (t1,t2) = dest_Š (concl thm1)
		handle complaint =>
		divert complaint "dest_Š" "‚_intro" 7040 [fn () => string_of_thm thm1];
	val (t2',t1') = dest_Š (concl thm2) (* dummy test *)
		handle complaint =>
		divert complaint "dest_Š" "‚_intro" 7040 [fn () => string_of_thm thm2];
	val s1 = list_simple_ƒ_elim[t1,t2] Š_antisym_axiom;
	val s2 = Š_elim s1 thm1;
	val s3 = Š_elim s2 thm2
		handle complaint =>
		divert complaint "Š_elim" "‚_intro" 7064 
		[fn () => string_of_thm thm1, fn () => string_of_thm thm2];
in
	(prof "‚_intro";
	s3)
end);
=TEX
We prove the local theorems (two of them because getting
the two conjuncts if we did one would take similar, if not greater effort)
ó
s8 … (t1 ‚ t2) Š (t1 Š t2)
s14 … (t1 ‚ t2) Š (t2 Š t1)
æ
=SML
local
	val s1 = asm_rule »t1 ‚ t2¼;
	val s2 = asm_rule »t1 : BOOL¼;
	val s3 = asm_rule »t2 : BOOL¼;
	val s4 = ‚_mp_rule s1 s2;
	val s5 = Š_intro »t1 : BOOL¼ s4;
	val s6 = Š_intro »t1 ‚ t2¼  s5;
	val s7 = simple_ƒ_intro»t2 : BOOL¼ s6;
	val s8 = simple_ƒ_intro»t1 : BOOL¼ s7;
	
	val s9 = eq_sym_rule s1;
	val s10 = ‚_mp_rule s9 s3;
	val s11 = Š_intro »t2 : BOOL¼ s10;
	val s12 = Š_intro »t1 ‚ t2¼  s11;
	val s13 = simple_ƒ_intro»t2 : BOOL¼ s12;
	val s14 = simple_ƒ_intro»t1 : BOOL¼ s13;
in
fun â‚_elimá (thm : THM) : (THM * THM) = (
let
	val (t1,t2) = dest_‚(concl thm);
	val mf_s1 = list_simple_ƒ_elim[t1,t2]s8;
	val mf_s2 = Š_elim mf_s1 thm;
	val mf_s3 = list_simple_ƒ_elim[t1,t2]s14;
	val mf_s4 = Š_elim mf_s3 thm;
in
	(prof "‚_elim";
	(mf_s2, mf_s4))
end
handle complaint =>
divert complaint "dest_‚" "‚_elim" 7062 [fn () => string_of_thm thm]
);
end;
=TEX
\subsection{Concerning =}
=SML
fun âsubst_convá (thm_lst : (THM * TERM) list) : (TERM -> CONV) = (
let
		val s1 = subst_rule thm_lst
			handle complaint =>
			pass_on complaint "subst_rule" "subst_conv";
in
	(fn (template : TERM) =>
	(fn (tm:TERM) =>
	let
		val new_template = mk_eq(tm,template)
			handle complaint =>
			divert complaint "mk_eq" "subst_conv" 3012 
			[fn () => string_of_term tm, fn () => string_of_term template];
		val s2 = refl_conv tm;
		val s3 = s1 new_template s2					handle complaint =>
			pass_on complaint "subst_rule" "subst_conv";
	in
		(prof "subst_conv";
		s3)
	end))
end);
=TEX

We prove a local theorem:
ó
s9 … ƒ t1 t2 Ž (t1 = t2) ‚ (t2 = t1)
æ
=SML
local
	val s1 = asm_rule »(t1 : 'a) = t2¼;
	val s2 = eq_sym_rule s1;
	val s3 = Š_intro »(t1 : 'a) = t2¼ s2;
	val s4 = asm_rule »(t2 : 'a) = t1¼;
	val s5 = eq_sym_rule s4;
	val s6 = Š_intro »(t2 : 'a) = t1¼ s5;
	val s7 = ‚_intro s3 s6;
	val s8 = simple_ƒ_intro »t2 : 'a¼ s7;
	val s9 = simple_ƒ_intro »t1 : 'a¼ s8;
in
val âeq_sym_convá : CONV = (fn (tm:TERM) =>
let
	val (t1,t2) = dest_eq tm;
	val mf_s1 = inst_type_rule[(type_of t1,mk_vartype"'a")] s9;
	val mf_s2 = list_simple_ƒ_elim[t1,t2] mf_s1;
in
	(prof "eq_sym_conv";
	mf_s2)
end
handle complaint =>
pass_on complaint "dest_eq" "eq_sym_conv"
);
end;
=TEX
We prove a local theorem:
ó
s … ƒ t1 t2 :'a Ž Œ(t1 = t2) ‚ Œ(t2 = t1)
æ
=SML
local
	val s1 = eq_sym_conv »(t1 : 'a) = t2¼;
	val s2 = ap_fun_rule »$Œ¼ s1;
	val s3 = simple_ƒ_intro »t2 : 'a¼ s2;
	val s4 = simple_ƒ_intro »t1 : 'a¼ s3;
in
fun âŒ_eq_sym_ruleá (thm : THM) : THM = (
let
	val (t1,t2) = dest_eq(dest_Œ(concl thm));
	val mf_s1 = inst_type_rule[(type_of t1,mk_vartype "'a")] s4;
	val mf_s2 = list_simple_ƒ_elim [t1,t2] mf_s1;
	val mf_s3 = ‚_mp_rule mf_s2 thm;
in
	(prof "Œ_eq_sym_rule";
	mf_s3)
end
handle complaint =>
list_divert complaint "Œ_eq_sym_rule" [
	("dest_eq",7091,[fn () => string_of_thm thm]),
	("dest_Œ",7091,[fn () => string_of_thm thm])]
);
end;
=TEX

\subsection{Concerning ƒ}
=RULE
list_simple_ƒ_intro
[»x1¼, ..., »xn¼]
É
ö … t[x1, ..., xn]
É
ö … ƒ x1 ... xn Ž t[x1, ..., xn]
=TEX
=SML
fun âlist_simple_ƒ_introá (tml : TERM list) (thm :THM) : THM = (
	fold (uncurry simple_ƒ_intro) tml thm
	handle complaint =>
	pass_on complaint "simple_ƒ_intro" "list_simple_ƒ_intro"
);
=TEX
=SML
fun âall_ƒ_introá (thm : THM) : THM = (
let	val cfrees = rev(frees(concl thm));
	val afrees = list_cup (map frees (hyps thm));
	val nfrees = cfrees diff afrees;
	val s1 = list_simple_ƒ_intro nfrees thm;
in
	(prof "all_ƒ_intro";
	s1)
end);
=TEX
=SML
fun âall_simple_ƒ_elimá (thm : THM) : THM = (
let	val c = concl thm;
	val cfrees = frees c;
	val all_frees = cfrees cup (list_cup (map frees (hyps thm)));
	val qvs = fst(strip_ƒ c);
	val qvs' = list_variant all_frees qvs;
	val s1 = list_simple_ƒ_elim qvs' thm;
in
	(prof "all_simple_ƒ_elim";
	s1)
end);
=TEX
\subsection{Concerning ‡}
=SML
fun â‡_intro_ruleá (thm : THM) : THM = (
let
	val (tm1, tm2) = dest_app (concl thm);
	val s1 = inst_type_rule [(type_of tm2, mk_vartype "'a")] ‡_axiom;
	val s2 = simple_ƒ_elim tm1 s1;
	val s3 = simple_ƒ_elim tm2 s2;
	val s4 = Š_elim s3 thm;
in
	(prof "‡_intro_rule";
	s4)
end
handle complaint =>
divert complaint "dest_app" "‡_intro_rule" 7016 [fn () => string_of_thm thm]
);
=TEX

=SML
fun â‡_elim_ruleá (tm : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let
	val sideeffect = dest_var tm
		handle complaint =>
		pass_on complaint "dest_var" "‡_elim_rule";
	val (tm1, ctm1) = dest_app (concl thm1);
	val tm1tm = mk_app (tm1, tm)
	val s1 = disch_rule tm1tm thm2;
	val s2 = simple_ƒ_intro tm s1
		handle complaint =>
		pass_on complaint "simple_ƒ_intro" "‡_elim_rule";
	val s3 = simple_ƒ_elim ctm1 s2;
	val s4 = Š_elim s3 thm1;
in
	(prof "‡_elim_rule";
	s4)
end
handle complaint =>
list_divert complaint "‡_elim_rule" [
	("dest_app",7019,[fn () => string_of_thm thm1]),
	("mk_app",7054,[fn () => string_of_term tm]),
	("disch_rule",7108,[fn () => fst(dest_var tm)])
	]
);
=TEX
\subsection{Concerning „}
=SML
fun âsimple_„_introá (tm : TERM) (thm : THM) : THM = (
let
	val (x, t1x) = dest_simple_„ tm
		handle complaint =>
		pass_on complaint "dest_simple_„" "simple_„_intro";
	val abs = snd(dest_app tm);
	val t2 = (case term_match (concl thm) t1x of
		(_, [(ltm, _)]) => ltm
		|(_, []) => x
		|Other	  => fail "simple_„_intro" 7047 [
			fn () => string_of_term tm,
			fn () => string_of_thm thm])
		handle complaint =>
		divert complaint "term_match" "simple_„_intro" 7047 [
			fn () => string_of_term tm,
			fn () => string_of_thm thm];
	val abst2 = mk_app (abs, t2);
	val s1 = simple_%beta%_conv abst2;
	val s2 = eq_sym_rule s1;
	val s3 = ‚_mp_rule s2 thm;
	val s4 = ‡_intro_rule s3;
	val s5 = inst_type_rule [(type_of x, mk_vartype "'a")] „_def;
	val s6 = ap_arg_rule abs s5;
	val s7 = simple_%beta%_conv (snd(dest_eq(concl s6)));
	val s8 = eq_trans_rule s6 s7;
	val s9 = eq_sym_rule s8;
	val s10 = ‚_mp_rule s9 s4;
in
	(prof "simple_„_intro";
	s10)
end);
=TEX

=SML
fun âsimple_„_elimá (v : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let
	val cthm1 = concl thm1;
	val (x, tx) = dest_simple_„ cthm1;
	val t1 = snd(dest_app cthm1);
	val t1v = mk_app (t1, v);
	val tvx = (case gen_vars [BOOL] ([(concl thm1), (concl thm2), v] 
		@ hyps thm1 @ hyps thm2) of
		[term] => term
		| _ => error "simple_„_elim" 6032 [])
		handle complaint =>
		pass_on complaint "gen_vars" "simple_„_elim";
	val s1 = inst_type_rule [(type_of x, mk_vartype "'a")] „_def;
	val s2 = ap_arg_rule t1 s1;
	val s3 = ‚_mp_rule s2 thm1;
	val s5 = conv_rule simple_%beta%_conv s3;
	val s6 = simple_%beta%_conv t1v;
	val s7 = eq_sym_rule s6;
	val asm = fst(dest_eq(concl s7))
	val s8 = Š_intro asm thm2;
	val s9 = mk_Š (tvx, concl thm2);
	val s10 = subst_rule [(s7, tvx)] s9 s8;
	val s11 = undisch_rule s10;
	val s12 = (‡_elim_rule v s5 s11)
		handle complaint =>
		pass_on complaint "‡_elim_rule" "simple_„_elim";
in
	(prof "simple_„_elim";
	s12)
end
handle complaint =>
list_divert complaint "simple_„_elim" [
	("dest_simple_„",7109,[fn () => string_of_thm thm1]),
	("mk_app",7014,[fn () => string_of_term v])
	]
);
=TEX

=SML
val âsimple_„_‡_convá : CONV = (fn (tm:TERM) =>
let
	val (x, tx) = (dest_simple_„ tm)
		handle complaint =>
		pass_on complaint "dest_simple_„" "simple_„_‡_conv";
	val t1 = mk_simple_ (x, tx);
	val s1 = inst_type_rule [(type_of x, mk_vartype "'a")] „_def;
	
	val s2 = ap_arg_rule t1 s1;
	val s3 = concl s2;
	val conv1 = (RAND_C simple_%beta%_conv THEN_C
			RAND_C simple_%beta%_conv)
	val s4 = conv1 s3;
	val s5 = ‚_mp_rule s4 s2;
in
	(prof "simple_„_‡_conv";
	s5)
end);
=TEX

=SML
fun âsimple_„_‡_ruleá (thm : THM) : THM = (
let	val s1 = conv_rule simple_„_‡_conv thm
in
	(prof "simple_„_‡_rule";
	s1)
end
	handle complaint =>
	divert complaint "simple_„_‡_conv" "simple_„_‡_rule" 7092 [fn () => string_of_thm thm]
);
=TEX

See section~\ref{SplitStructure} for an explanation of the
structure declarations in the next piece of Standard~ML.

=SML
end; (* of structure DerivedInferenceRules *)

structure âDerivedInferenceRulesá : DerivedInferenceRules = struct

open DerivedInferenceRules;
=TEX

\subsection{Concerning $if\ldots then\ldots else \ldots$}
=SML
local
	val s1 = ap_arg_rule »a : BOOL¼ cond_def;
	val s2 = ap_arg_rule »t1 : 'a¼ s1;
	val s3 = ap_arg_rule »t2 : 'a¼ s2;
	val s4 = conv_rule (MAP_C simple_%beta%_conv) s3;
	val s5 = simple_ƒ_intro »t2 : 'a¼ s4;
	val s6 = simple_ƒ_intro »t1 : 'a¼ s5;
	val s7 = simple_ƒ_intro »a : BOOL¼ s6;

in
	val âcond_thmá = save_thm("cond_thm", s7);
end;
=TEX
A local function:
=RULE
if_intro_rule
»a¼
É
ö1, a … x = tt ;  ö2, Œa' … x = et
É
ö1 ¡ ö2 … x = if a then tt else et
=TEX
ó
s35 … ƒ x a t1 t2 Ž (a Š (x = t1)) Š (Œ a Š (x = t2)) Š 
	(x = if a then t1 else t2)
æ
=SML
local
	val s1 = asm_rule »a Š ((x:'a) = t1)¼;
	val s2 = asm_rule »a ‚ T¼;
	val s3 = ‚_t_elim s2;
	val s4 = Š_elim s1 s3;
	val s5 = Š_intro »a ‚ T¼ s4;
	val s6 = asm_rule »Œ a Š ((x:'a) = t2)¼;
	val s7 = asm_rule »a ‚ F¼;
	val s8 = simple_ƒ_elim  »a : BOOL¼ Œ_1_thm;
	val s9 = eq_sym_rule s8;
	val s10 = ‚_mp_rule s9 s7;
	val s11 = Š_elim s6 s10;
	val s12 = Š_intro »a ‚ F¼ s11;
	val s13 = €_intro s5 s12;
	val s14 = simple_%beta%_conv 
		(mk_app(
		(mk_simple_(»x : 'a¼, concl s13),
		»x : 'a¼)));
	val s15 = eq_sym_rule s14;
	val s16 = ‚_mp_rule s15 s13;
	val s17 = ‡_intro_rule s16;
	val s18 = list_simple_ƒ_elim[»a : BOOL¼, »t1 : 'a¼, »t2 : 'a¼] cond_thm;
	val s19 = eq_sym_rule s18;
	val s20 = subst_rule[(s19,»y : 'a¼)]
		(mk_app(fst(dest_app(concl s17)),»y : 'a¼))
		s17;
	val s21 = conv_rule simple_%beta%_conv s20;

	val s22 = €_left_elim s21;
	val s23 = undisch_rule s22;
	val s24 = eq_sym_rule s4;
	val s25 = subst_rule[(s24,»y : 'a¼)]
		(mk_app(fst(dest_app(concl s23)),»y : 'a¼))
		s23;
	
	val s26 = €_right_elim s21;
	val s27 = undisch_rule s26;
	val s28 = eq_sym_rule s11;
	val s29 = subst_rule[(s28,»y : 'a¼)]
		(mk_app(fst(dest_app(concl s27)),»y : 'a¼))
		s27;

	val s30 = simple_ƒ_elim »a : BOOL¼ bool_cases_axiom;
	val s31 = _elim s30 s25 s29;
	val s32 = eq_sym_rule s31;
	val s33 = Š_intro »Œ a Š ((x:'a) = t2)¼ s32;
	val s34 = Š_intro »a Š ((x:'a) = t1)¼ s33;
	val s35 = list_simple_ƒ_intro[»x : 'a¼, »a : BOOL¼, »t1 : 'a¼, »t2 : 'a¼] s34;
in
fun âif_intro_ruleá (a : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let
	val (x,t1) = dest_eq(concl thm1)
		handle complaint =>
		divert complaint "dest_eq" "if_intro_rule" 6020 
			[fn () => string_of_thm thm1];
	val (x',t2) = dest_eq(concl thm2)
		handle complaint =>
		divert complaint "dest_eq" "if_intro_rule" 6020 
			[fn () => string_of_thm thm2];
	val mf_s1 = Š_intro a thm1
		handle complaint =>
		divert complaint "Š_intro" "if_intro_rule" 3031 
			[fn () => string_of_term a];
	val mf_s2 = Š_intro (mk_Œ a) thm2;
	val mf_s3 = inst_type_rule[(type_of x,mk_vartype"'a")]
		s35;
	val mf_s4 = list_simple_ƒ_elim[x,a,t1,t2]mf_s3;
	val mf_s5 = Š_elim mf_s4 mf_s1;
	val mf_s6 = Š_elim mf_s5 mf_s2;
in
	(prof "if_intro_rule";
	mf_s6)
end);
end; (* of local val s1 ... *)
=TEX
=RULE
if_then_elim_rule
É
ö … x = if tc then tt else te
É
ö … tc Š x = tt
=TEX
Prove the local theorem:
ó
s28 … ƒ x a t1 t2 Ž (x = if a then t1 else t2) Š (a Š x = t1)
æ
=SML
local
	val s1 = asm_rule »a : BOOL¼;
	val s2 = asm_rule »a ‚ F¼;
	val s3 = simple_ƒ_elim »a : BOOL¼ Œ_1_thm;
	val s4 = eq_sym_rule s3;
	val s5 = ‚_mp_rule s4 s2;
	val s6 = Œ_elim »(t1 : 'a) = t2¼ s1 s5;
	val s7 = Š_intro »a ‚ F¼ s6;
	val s8 = refl_conv »t1 : 'a¼;
	val s9 = Š_intro  »a ‚ T¼ s8;
	val s10 = €_intro s9 s7;

	val s11 = simple_%beta%_conv 
		»( y: 'a Ž ((a ‚ T) Š y = t1) € ((a ‚ F) Š y = t2)) t1¼;
	val s12 = eq_sym_rule s11;
	val s13 = ‚_mp_rule s12 s10;
	val s14 = ‡_intro_rule s13;
	val s15 = list_simple_ƒ_elim [»a : BOOL¼, »t1 : 'a¼, »t2 : 'a¼] cond_thm;
	val s16 = eq_sym_rule s15;
	val s17 = subst_rule[(s16,»z : 'a¼)]
		(mk_app(fst(dest_app(concl s14)),»z : 'a¼))
		s14;
	val s18 = asm_rule »(x:'a) = if a then t1 else t2¼;
	val s19 = eq_sym_rule s18;
	val s20 = subst_rule[(s19,»z : 'a¼)]
		(mk_app(fst(dest_app(concl s17)),»z : 'a¼))
		s17;
	val s21 =  conv_rule simple_%beta%_conv s20;
	val s22 = €_left_elim s21;
	val s23 = ‚_t_intro s1;
	val s25 = Š_elim s22 s23;
	val s26 = Š_intro »a : BOOL¼ s25;
	val s27 = Š_intro »(x:'a) = if a then t1 else t2¼ s26;
	val s28 = list_simple_ƒ_intro[»x : 'a¼, »a : BOOL¼, »t1 : 'a¼, »t2 : 'a¼] s27;
in
fun âif_then_elim_ruleá (thm : THM) = (
let
	val (x,ifa)= dest_eq(concl thm)
		handle complaint =>
		pass_on complaint "dest_eq" "if_then_elim_rule";
	val (a,t1,t2) = dest_if ifa
		handle complaint =>
		pass_on complaint "dest_if" "if_then_elim_rule";
	val mf_s1 = inst_type_rule[(type_of x,mk_vartype "'a")] s28;
	val mf_s2 = list_simple_ƒ_elim[x,a,t1,t2] mf_s1;
	val mf_s3 = Š_elim mf_s2 thm;
in
	(prof "if_then_elim_rule";
	mf_s3)
end);
end; (* of local val s1 = ... *)
=TEX
=RULE
if_else_elim_rule
É
ö … x = if tc then tt else te
É
ö … Œ tc Š x = te
=TEX
ó
s29 … ƒ x a t1 t2 Ž x = (if a then t1 else t2) Š Œ a Š x = t2
æ
=SML
local
	val s1 = asm_rule »Œ a ¼;
	val s2 = asm_rule »a ‚ T¼;
	val s4 = ‚_t_elim s2;
	val s6 = Œ_elim »(t2 : 'a) = t1¼ s4 s1;
	val s7 = Š_intro »a ‚ T¼ s6;
	val s8 = refl_conv »t2 : 'a¼;
	val s9 = Š_intro  »a ‚ F¼ s8;
	val s10 = €_intro s7 s9;

	val s11 = simple_%beta%_conv 
		»( y: 'a Ž ((a ‚ T) Š y = t1) € ((a ‚ F) Š y = t2)) t2¼;
	val s12 = eq_sym_rule s11;
	val s13 = ‚_mp_rule s12 s10;
	val s14 = ‡_intro_rule s13;
	val s15 = list_simple_ƒ_elim [»a : BOOL¼, »t1 : 'a¼, »t2 : 'a¼] cond_thm;
	val s16 = eq_sym_rule s15;
	val s17 = subst_rule[(s16,»z : 'a¼)]
		(mk_app(fst(dest_app(concl s14)),»z : 'a¼))
		s14;
	val s18 = asm_rule »(x:'a) = if a then t1 else t2¼;
	val s19 = eq_sym_rule s18;
	val s20 = subst_rule[(s19,»z : 'a¼)]
		(mk_app(fst(dest_app(concl s17)),»z : 'a¼))
		s17;
	val s21 =  conv_rule simple_%beta%_conv s20;
	val s22 = €_right_elim s21;
	val s23 = simple_ƒ_elim »a : BOOL¼ Œ_1_thm;
	val s24 = fst(‚_elim s23);
	val s25 = Š_trans_rule s24 s22;
	val s26 = Š_elim s25 s1;
	val s27 = Š_intro »Œ a¼ s26;
	val s28 = Š_intro »(x:'a) = if a then t1 else t2¼ s27;
	val s29 = list_simple_ƒ_intro[»x : 'a¼, »a : BOOL¼, »t1 : 'a¼, »t2 : 'a¼] s28;
in
fun âif_else_elim_ruleá (thm : THM) = (
let
	val (x,ifa)= dest_eq(concl thm)
		handle complaint =>
		pass_on complaint "dest_eq" "if_else_elim_rule";
	val (a,t1,t2) = dest_if ifa
		handle complaint =>
		pass_on complaint "dest_if" "if_else_elim_rule";
	val mf_s1 = inst_type_rule[(type_of x,mk_vartype "'a")] s29;
	val mf_s2 = list_simple_ƒ_elim[x,a,t1,t2] mf_s1;
	val mf_s3 = Š_elim mf_s2 thm;
in
	(prof "if_else_elim_rule";
	mf_s3)
end);
end; (* of local val s1 = ... *)
=TEX
ó
s9 … ƒ f a t1 t2 Ž f(if a then t1 else t2) =
	if a then (f t1) else (f t2)
s11 … ƒ f a t1 t2 Ž if a then (f t1) else (f t2) =
	f(if a then t1 else t2)
æ
=SML
local
	val s1 = refl_conv »if a then (t1:'a) else t2¼;
	val s2 = if_then_elim_rule s1;
	val s3 = undisch_rule s2;
	val s4 = ap_fun_rule »f : 'a ‹ 'b¼ s3;
	val s5 = if_else_elim_rule s1;
	val s6 = undisch_rule s5;
	val s7 = ap_fun_rule »f : 'a ‹ 'b¼ s6;
	val s8 = if_intro_rule »a : BOOL¼ s4 s7;
	val s9 = list_simple_ƒ_intro[»f : 'a ‹ 'b¼, »a : BOOL¼, »t1 : 'a¼, »t2 : 'a¼] s8;
	val s10 = eq_sym_rule s8;
	val s11 = list_simple_ƒ_intro[»f : 'a ‹ 'b¼, »a : BOOL¼, »t1 : 'a¼, »t2 : 'a¼] s10;
in
val âfun_if_convá : CONV = (fn (tm:TERM) =>
let
	val (f,ifa) = dest_app tm;
	val (a,t1,t2) = dest_if ifa;
	val (aty,bty) = dest_‹_type(type_of f);
	val mf_s1 = inst_type_rule[(aty,mk_vartype"'a"),(bty,mk_vartype"'b")]s9;
	val mf_s2 = list_simple_ƒ_elim[f,a,t1,t2] mf_s1;
in
	(prof "fun_if_conv";
	mf_s2)
end
handle complaint =>
list_divert complaint "fun_if_conv" [
	("dest_app",7098,[fn () => string_of_term tm]),
	("dest_if",7098,[fn () => string_of_term tm])]
);
val âif_fun_convá : CONV = (fn (tm:TERM) =>
let
	val (a,ft1,ft2) = dest_if tm;
	val (f,t1) = dest_app ft1;
	val (f',t2) = dest_app ft2;
	val (aty,bty) = dest_‹_type(type_of f);
	val mf_s1 = inst_type_rule[(aty,mk_vartype"'a"),(bty,mk_vartype"'b")]s11;
	val mf_s2 = list_simple_ƒ_elim[f,a,t1,t2] mf_s1;
	val mf_s3 = refl_conv tm;
	val mf_s4 = eq_trans_rule mf_s3 mf_s2;
in
	(prof "if_fun_conv";
	mf_s4)
end
handle complaint =>
list_divert complaint "if_fun_conv" [
	("dest_app",7037,[fn () => string_of_term tm]),
	("dest_if",7037,[fn () => string_of_term tm]),
	("eq_trans_rule",7038,[fn () => string_of_term tm])]
);
end; (* local val s1 = ... *)
=TEX
We prove the local theorem:
ó
s12 … ƒ a t1 t2 Ž (a Š t1) Š (Œ a Š t2) Š 
	(if a then t1 else t2)
æ
=SML
local
	val s1 = asm_rule »a Š t1¼;
	val s2 = undisch_rule s1;
	val s3 = ‚_t_intro s2;
	val s4 = eq_sym_rule s3;

	val s5 = asm_rule »Œ a Š t2¼;
	val s6 = undisch_rule s5;
	val s7 = ‚_t_intro s6;
	val s8 = eq_sym_rule s7;

	val s9 = if_intro_rule »a:BOOL¼ s4 s8;
	val s10 = eq_sym_rule s9;
	val s11 = ‚_t_elim s10;
	val s12 = Š_intro »Œ a Š t2¼ s11;
	val s13 = Š_intro »a Š t1¼ s12;
	val s14= list_simple_ƒ_intro[»a : BOOL¼, »t1 : BOOL¼, »t2 : BOOL¼] s13;
in
fun âif_introá (a : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let
	val mf_s1 = Š_intro a thm1
		handle complaint =>
		divert complaint "Š_intro" "if_intro" 3031 [fn () => string_of_term a];
	val mf_s2 = Š_intro (mk_Œ a) thm2;
	val mf_s3 = list_simple_ƒ_elim[a,concl thm1, concl thm2]s14
		handle complaint =>
		divert complaint "list_simple_ƒ_elim" "if_intro" 3031
			[fn () => string_of_term a];
	val mf_s4 = Š_elim mf_s3 mf_s1;
	val mf_s5 = Š_elim mf_s4 mf_s2;
in
	(prof "if_intro";
	mf_s5)
end);
end; (* of local val s1 ... *)
=TEX
Prove the local theorem:
ó
s10 … ƒ a t1 t2 Ž (if a then t1 else t2) Š (a Š t1)
æ
=SML
local
	val s1 = asm_rule »if a then (t1:BOOL) else t2¼;
	val s2 = ‚_t_intro s1;
	val s3 = eq_sym_rule s2;
	val s4 = if_then_elim_rule s3;
	val s5 = undisch_rule s4;
	val s6 = eq_sym_rule s5;
	val s7 = ‚_t_elim s6;
	val s8 = Š_intro »a : BOOL¼ s7;
	val s9 = Š_intro »if a then (t1:BOOL) else t2¼ s8;
	val s10 = list_simple_ƒ_intro[»a : BOOL¼, »t1 : BOOL¼, »t2 : BOOL¼] s9;
in
fun âif_then_elimá (thm : THM) = (
let
	val (a,t1,t2) = dest_if (concl thm);
	val mf_s2 = list_simple_ƒ_elim[a,t1,t2] s10;
	val mf_s3 = Š_elim mf_s2 thm;
in
	(prof "if_then_elim";
	mf_s3)
end
handle complaint =>
list_divert complaint "if_then_elim" [
	("dest_if",7012,[fn () => string_of_thm thm])]
);
end; (* of local val s1 = ... *)
=TEX
ó
s10 … ƒ a t1 t2 Ž (if a then t1 else t2) Š Œ a Š t2
æ
=SML
local
	val s1 = asm_rule »if a then (t1:BOOL) else t2¼;
	val s2 = ‚_t_intro s1;
	val s3 = eq_sym_rule s2;
	val s4 = if_else_elim_rule s3;
	val s5 = undisch_rule s4;
	val s6 = eq_sym_rule s5;
	val s7 = ‚_t_elim s6;
	val s8 = Š_intro »Œ a¼ s7;
	val s9 = Š_intro »if a then (t1:BOOL) else t2¼ s8;
	val s10 = list_simple_ƒ_intro[»a : BOOL¼, »t1 : BOOL¼, »t2 : BOOL¼] s9;
in
fun âif_else_elimá (thm : THM) = (
let
	val (a,t1,t2) = dest_if (concl thm);
	val mf_s2 = list_simple_ƒ_elim[a,t1,t2] s10;
	val mf_s3 = Š_elim mf_s2 thm;
in
	(prof "if_else_elim";
	mf_s3)
end
handle complaint =>
list_divert complaint "if_else_elim" [
	("dest_if",7012,[fn () => string_of_thm thm])]
);
end; (* of local val s1 = ... *)
=TEX
=TEX
\subsection{Concerning Functional Application}
=SML
fun âext_ruleá (thm : THM) = (
let
	val (h,c) =dest_thm thm;
	val (f,g) = dest_eq c;
	val mgv = hd(gen_vars [fst(dest_‹_type(type_of f))]
		(c :: h));
	val s1 = ap_arg_rule mgv thm;
	val s2 = simple_ƒ_intro mgv s1;
in
	(prof "ext_rule";
	s2)
end
handle complaint =>
list_divert complaint "ext_rule" [
	("dest_eq",6020,[fn () => string_of_thm thm]),
	("dest_‹_type",7026,[fn () => string_of_thm thm])]
);
=TEX
\subsection{Concerning Assumptions}
=SML
fun âasm_introá (tm : TERM) (thm : THM) : THM = (
let	val s1 = Š_intro tm thm
		handle complaint =>
		pass_on complaint "Š_intro" "asm_intro";
	val s2 = asm_rule tm;
	val s3 = Š_elim s1 s2;
in
	(prof "asm_intro";
	s3)
end);
=TEX
ó
s15 … ƒ a t Ž (a Š t) Š (Œ a Š t) Š t
æ
=SML
local 
	val s1 = simple_ƒ_elim »a : BOOL¼ bool_cases_axiom;
	val s2 = asm_rule »a Š t¼;
	val s3 = asm_rule »a ‚ T¼;
	val s4 = ‚_t_elim s3;
	val s5 = Š_elim s2 s4;
	val s6 = asm_rule »Œa Š t¼;
	val s7 = asm_rule »a ‚ F¼;
	val s8 = simple_ƒ_elim »a : BOOL¼ Œ_1_thm;
	val s9 = eq_sym_rule s8;
	val s10 = ‚_mp_rule s9 s7;
	val s11 = Š_elim s6 s10;
	val s12 = _elim s1 s5 s11;
	val s13 = Š_intro »Œa Š t¼ s12;
	val s14 = Š_intro »a Š t¼ s13;
	val s15 = list_simple_ƒ_intro[»a : BOOL¼,»t : BOOL¼] s14;
in
fun âasm_elimá (tm : TERM) (thm1 : THM) (thm2 : THM) = (
let
	val t = concl thm1;
	val mf_s1 = list_simple_ƒ_elim [tm,t] s15;
	val mf_s2 = Š_intro tm thm1;
	val mf_s3 = Š_intro (mk_Œ tm) thm2;
	val mf_s4 = Š_elim mf_s1 mf_s2;
	val mf_s5 = Š_elim mf_s4 mf_s3;
in
	(prof "asm_elim";
	mf_s5)
end
handle complaint =>
list_divert complaint "asm_elim" [
	("list_simple_ƒ_elim", 3031, [fn () => string_of_term tm]),
	("Š_elim",7029,[fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
end; (* local val s1 = ... *)
=TEX
=SML
fun âprove_asm_ruleá (thm1 : THM) (thm2 : THM) : THM = (
let
	val c1 = concl thm1;
	val s1 = Š_intro c1 thm2;
	val s2 = Š_elim s1 thm1;
in
	(prof "prove_asm_rule";
	s2)
end);
=TEX
=SML
fun âasm_inst_type_ruleá  (tyl : (TYPE * TYPE) list) (thm : THM) : THM = (
let
	val nhyps = length(strip_Š (concl thm));
	val s1 = all_Š_intro thm;
	val nhyps1 = length(strip_Š (concl s1));
	val s2 = inst_type_rule tyl s1;
	val s3 = fold (fn (_,x) => undisch_rule x)
		(interval 1 (nhyps1 - nhyps)) s2;
in
	(prof "asm_inst_type_rule";
	s3)
end
handle complaint =>
pass_on complaint "inst_type_rule" "asm_inst_type_rule"
);
=TEX
\subsection{Concerning Matching Functions}
The function $apply\_matches\_rule$ encodes the matching attempt, should
a simple use of the rule fail.
It is given a term to match against,
a method of extracting the part to match,and the theorem
that is to be instantiated.
It presumes that the theorem it is passed is stripped
of all outer universal quanitifers.
It brings up to the conclusion all the hypotheses.
It instantiates types to the minimum required,
instantiates free variables to the minimum required
(notice that we must not instantiate the universally quantified variables of $thm$ that occur free in the assumptions:
thus $tmm'$)
and then returns are the hypotheses to the assumption list.

Note that $term\_match$ is not infallible.
=SML
local
	fun strip_n_Š 0 tm = tm
	| strip_n_Š n tm = strip_n_Š (n-1) (snd(dest_Š tm));
in
fun âapply_matches_ruleá (caller : string) 
	(match_against : TERM)
	(extract : TERM -> TERM)
	(thm : THM) : THM = (
let
	val cnc = concl thm;
	val cfrees = frees cnc;
	val all_frees = cfrees cup (list_cup (map frees (hyps thm)));
	val qvs = fst(strip_ƒ cnc);
	val subs_for = qvs @ all_frees;
	val subs_with = list_variant [] subs_for;
	val length_qvs = length qvs;
	val qvs' = subs_with to (length_qvs -1);
	val all_frees' = subs_with from length_qvs;
	val s1 = list_simple_ƒ_elim qvs' thm;
	val c = concl s1;
	val nhyps = length(strip_Š c);
	val s2 = all_Š_intro s1;
	val nhyps1 = length(strip_Š (concl s2));
	val s3 = inst_term_rule(combine all_frees' all_frees) s2;
	val t1 = extract (strip_n_Š (nhyps1 - nhyps)(concl s3));
	val (tym,tmm) = term_match match_against t1;
	val s4 = inst_type_rule tym s3;
	val s5 = inst_term_rule tmm s4;
	val s6 = fold (fn (_,x) => undisch_rule x)
		(interval 1 (nhyps1 - nhyps)) s5;
in
	s6
end
handle (Fail _) => fail caller 7044 [fn () => string_of_term match_against, 
		fn () => string_of_thm thm]
);
end;
=TEX
Now we use the above in the various forms of matching.
=SML
local
fun aux (thm1 : THM) (thm2 : THM) : THM = (
let
	val s1 = apply_matches_rule "simple_Š_match_mp_rule" 
		(concl thm2) (fst o dest_Š) thm1;
	val s2 = Š_elim s1 thm2;
in
	(prof "simple_Š_match_mp_rule";
	s2)
end
handle complaint =>
list_divert complaint "simple_Š_match_mp_rule" [
	("Š_elim", 7044, [fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
in
fun âsimple_Š_match_mp_ruleá (thm1 : THM) (thm2 : THM) : THM = (	
let val s1 = Š_elim thm1 thm2;
in
	 (prof "simple_Š_match_mp_rule";
	s1)
end
	handle complaint =>
	aux thm1 thm2
);
end;
=TEX
=SML
local
fun aux (thm1 : THM) (thm2 : THM) : THM = (
let
	val s1 = apply_matches_rule "simple_‚_match_mp_rule" (concl thm2) (fst o dest_‚) thm1;
	val s2 = ‚_mp_rule s1 thm2;
in
	(prof "simple_‚_match_mp_rule";
	s2)
end
handle complaint =>
list_divert complaint "simple_‚_match_mp_rule" [
	("‚_mp_rule", 7044, [fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
in
fun âsimple_‚_match_mp_ruleá (thm1 : THM) (thm2 : THM) : THM = (
let val s1 = ‚_mp_rule thm1 thm2;
in
	(prof "simple_‚_match_mp_rule";
	s1)
end
	handle complaint =>
	aux thm1 thm2
);
end;
=TEX
=SML
local
fun aux (thm : THM) : CONV = (fn (tm :TERM) =>
let
	val s1 = apply_matches_rule "simple_eq_match_conv" tm (fst o dest_eq) thm;
	val s2 = eq_trans_rule (refl_conv tm) s1;
in
	(prof "simple_eq_match_conv";
	s2)
end
handle complaint =>
list_divert complaint "simple_eq_match_conv" [
	("eq_trans_rule", 7076, [fn () => string_of_term tm,
		fn () => string_of_thm thm])]
);
in
fun âsimple_eq_match_convá (thm : THM) : CONV = (fn (tm :TERM) =>
let val s1 = eq_trans_rule (refl_conv tm) thm;
in
	 (prof "simple_eq_match_conv";
	s1)
end
	handle complaint =>
	aux thm tm
);
end;
=TEX
In the following we just map all failures bar $dest\_eq$
onto 7076, without working out whether the error is 
an ``expected'' one.
This is because we want this function to fail fast as well are succeed fast.
=SML
fun âsimple_eq_match_1_convá (thm : THM) : CONV = (
let
	val (qvs,body) = strip_ƒ (concl thm);
	val (t1,_) = dest_eq body;
in
(fn (tm :TERM) =>
let	val (tym,tmm) = term_match tm t1;
	val s2 = inst_type_rule tym thm;

	fun aux1 (qv :: rest) : TERM list = (
	let
		val qv' = inst [] tym qv;
	in
		(rassoc1 tmm qv') :: aux1 rest 
	end
	) | aux1 [] = [];

	val s3 = list_simple_ƒ_elim (aux1 qvs) s2;
	val s4 = eq_trans_rule (refl_conv tm) s3;
in
	(prof "simple_eq_match_1_conv";
	s4)
end
handle (Fail _) => fail "simple_eq_match_1_conv" 7076 [fn () => string_of_term tm,
	fn () => string_of_thm thm]
)
end
handle complaint =>
divert complaint "dest_eq" "simple_eq_match_1_conv" 7095 
	[fn () => string_of_thm thm]
);
=TEX
\subsection{Concerning }
=SML
fun â_ruleá (tm : TERM) (thm : THM) : THM = (
let
	val mgv = hd(gen_vars [type_of tm] [tm]);
	val sx = subst [(mgv,tm)] (concl thm);
	val mgv_sx = mk_app(mk_simple_(mgv,sx),tm)
	val s1 = simple_%beta%_conv mgv_sx;
	val s2 = eq_sym_rule s1;
	val s3 = ‚_mp_rule s2 thm
in
	(prof "_rule";
	s3)
end);
=TEX
In assessing the following, note that requesting, say, $ap\_arg\_rule$
is equivalent to requesting a $refl\_conv$ and a $mk\_app\_rule$ as far as efficiency goes.
In addition, note that the original term, $tm$ is in the sco[pe of $aux2$, saving a $mk\_app$.
=SML
val âall_simple_%beta%_convá  : CONV = (
let
fun rhs (thm: THM) : TERM = snd(dest_eq(concl thm));
fun asbc (tm : TERM) : THM OPT = (
let 	val dt = dest_simple_term tm;

	fun aux1 thm1 thm2 = (
	let val s1 = mk_app_rule thm1 thm2
	in
		Value (
		if not(is_simple_(rhs thm1))
		then s1
		else (let val s2 = conv_rule (RAND_C simple_%beta%_conv) s1;
		in
		if is_simple_(rhs thm2)
		then (
			case (asbc (rhs s2)) of
			Nil => s2
			| Value s3 => eq_trans_rule s2 s3
		) else s2
		end)
		)
	end);

	fun aux2 (f : TERM) (x : TERM) : THM OPT = (
	if is_simple_ f
	then 	(Value(
		if is_simple_ x
		then ((simple_%beta%_conv FURTHER_C(fn tm1 =>
			force_value (asbc tm1))) tm)
		else (simple_%beta%_conv tm)
		))
	else Nil);

	fun aux (App (f, x)) = (
	let 	val fr = asbc f;
		val xr = asbc x;
	in
		case (fr,xr) of
		(Nil, Nil) => aux2 f x
		| (Value frt,Nil) => aux1 frt (refl_conv x)
		| (Nil, Value xrt) => aux1 (refl_conv f) xrt
		| (Value frt, Value xrt) => aux1 frt xrt
	end
	) | aux (Simple (x, b)) = (
	let	val br = asbc b
	in
		case br of
		Nil => Nil
		| (Value brt) => Value(simple__eq_rule x brt)
	end
	) | aux _ = Nil;
in
	aux dt
end);
in
	(fn (tm:TERM) => case (asbc tm) of
		Value red => red
		| Nil => term_fail "all_simple_%beta%_conv" 7020 [tm])
end);
=TEX
=SML
fun âall_simple_%beta%_ruleá (thm : THM) =(
	conv_rule all_simple_%beta%_conv thm
	handle complaint =>
	divert complaint "all_simple_%beta%_conv"
		"all_simple_%beta%_rule" 7021 [fn () => string_of_thm thm]
);
=TEX

\subsection{Concerning $\alpha$-conversion}
=SML
val â%alpha%_convá : TERM -> CONV = (
let val ar = subst_rule [];
in
(fn (tm1 : TERM) =>
 fn (tm2 : TERM) =>
let
	val new_template = mk_eq(tm2, tm1)
		handle complaint =>
		pass_on complaint "mk_eq" "%alpha%_conv"
	val s2 = refl_conv tm2;
	val s3 = ar new_template s2;
in
	(prof "%alpha%_conv";
	s3)
end
handle complaint =>
list_divert complaint "%alpha%_conv" [
	("subst_rule",7034,[fn () => string_of_term tm1,
		fn () => string_of_term tm2])]
)
end);
=TEX
=SML
val âsimple_%alpha%_convá : string -> CONV = (
let val ar = subst_rule [];
in
(fn (v : string) =>
 fn (tm:TERM) =>
let
	val (x,b) = dest_simple_ tm
		handle complaint =>
		pass_on complaint "dest_simple_" "simple_%alpha%_conv";
	val vtm = mk_var(v, type_of x);
	val abs = mk_simple_(vtm,subst[(vtm,x)]b);
	val new_template = mk_eq(tm, abs);
	val s2 = refl_conv tm;
	val s3 = ar new_template s2
		handle complaint =>
		divert complaint "subst_rule" "simple_%alpha%_conv" 7035
		[fn () => string_of_term x,(fn () => v)];
in
	(prof "%alpha%_conv";
	s3)
end)
end);
=TEX
\subsection{Concerning Œ (part II)}
We prove the local theorem:
ó
s8 … ƒ p Ž Œ(Œ p) = p
æ
=SML
local
	val s1 = asm_rule »p : BOOL¼;
	val s2 = Œ_Œ_intro s1;
	val s3 = Š_intro »p : BOOL¼ s2;
	val s4 = asm_rule »Œ(Œ p)¼;
	val s5 = Œ_Œ_elim s4;
	val s6 = Š_intro »Œ(Œ p)¼ s5;
	val s7 = ‚_intro s6 s3;
	val s8 = simple_ƒ_intro »p : BOOL¼ s7;
in
val Œ_Œ_conv : CONV = (fn (tm:TERM) =>
let
	val p = dest_Œ(dest_Œ tm);
	val mf_s1 = simple_ƒ_elim p s8;
in
	(prof "Œ_Œ_conv";
	mf_s1)
end
handle complaint =>
divert complaint "dest_Œ" "Œ_Œ_conv" 7022 [fn () => string_of_term tm]
);
end;
=TEX
Local theorems:
ó
s22 … ƒ p Ž Œ („ x Ž Œ (p x)) ‚ (ƒ x Ž p x)

s27 … Œ (ƒ x Ž Œ (p x)) ‚ („ x Ž p x)

s31 … ƒ p Ž Œ (ƒ x Ž p x) ‚ („ x Ž Œ (p x))

s35 … ƒ p Ž Œ („ x Ž p x) ‚ (ƒ x Ž Œ (p x))
æ
=SML
local
val s1 = asm_rule »( x : 'a Ž Œ(p x)) x¼;
val s2 = simple_„_intro »„ x : 'a Ž ( x Ž Œ(p x)) x¼ s1;
val s3 = all_Š_intro s2;
val s4 = all_simple_%beta%_rule s3;
val s5 = asm_rule »Œ(„ x Ž Œ (p x))¼;
val s6 = modus_tollens_rule s4  s5;
val s7 = Œ_Œ_elim s6;
val s8 = simple_ƒ_intro »x : 'a¼ s7;
val s9 =  all_Š_intro s8;

val s10 = asm_rule »ƒ x : 'a Ž p x¼;
val s11 = all_simple_ƒ_elim s10;
val s12 = asm_rule »Œ(p (x : 'a))¼;
val s13 = asm_rule »„ x : 'a Ž Œ(p x)¼;
val s14 = Œ_elim »F¼ s11 s12;
val s15 = simple_„_elim  »x : 'a¼ s13 s14;
val s16 = Š_intro »„ x : 'a Ž Œ(p x)¼ s15;
val s17 = simple_ƒ_elim »„ x : 'a Ž Œ(p x)¼ Œ_thm;
val s18 = eq_sym_rule s17;
val s19 = ‚_mp_rule s18 s16;
val s20 = all_Š_intro s19;
val s21 = ‚_intro s9 s20;
val s22 = all_ƒ_intro s21;

val s23 = simple_ƒ_elim »( x : 'a Ž Œ(p x))¼ s22;
val s24 = all_simple_%beta%_rule s23;
val s25 = ap_fun_rule »$Œ¼ s24;
val s26 = conv_rule (TOP_MAP_C Œ_Œ_conv) s25;
val s27 = eq_sym_rule s26;

val s28 = ap_fun_rule »$Œ¼ s21;
val s29 = conv_rule (TOP_MAP_C Œ_Œ_conv) s28;
val s30 = eq_sym_rule s29;
val s31 = all_ƒ_intro s30; (* Œ_ƒ_thm *)

val s32 = ap_fun_rule »$Œ¼  s27;
val s33 = conv_rule (TOP_MAP_C Œ_Œ_conv) s32;
val s34 = eq_sym_rule s33;
val s35 = all_ƒ_intro s34; (* Œ_„_thm *)

=TEX
Now the main functions:
=SML
in
val âsimple_Œ_ƒ_convá : CONV = (fn (tm:TERM) =>
let
	val neg = (dest_Œ tm);
	val (v,b) = dest_simple_ƒ neg;
	val vstr = fst(dest_var v);
	val abs = snd(dest_app neg);
	val mf_s1 = inst_type_rule[(type_of v,mk_vartype "'a")] s31;
	val mf_s2 = simple_ƒ_elim abs mf_s1;
	val mf_s3 = conv_rule(ONCE_MAP_C simple_%beta%_conv
		THEN_C ONCE_MAP_C (simple_%alpha%_conv vstr)) mf_s2;
	val mf_s4 = refl_conv tm;
	val mf_s5 = eq_trans_rule mf_s4 mf_s3;
in
	(prof "simple_Œ_ƒ_conv";
	mf_s5)
end
handle complaint =>
list_divert complaint "simple_Œ_ƒ_conv" [
	("dest_Œ",7036,[fn () => string_of_term tm]),
	("dest_ƒ",7036,[fn () => string_of_term tm])]
);

val âsimple_Œ_„_convá : CONV = (fn (tm:TERM) =>
let
	val neg = (dest_Œ tm);
	val (v,b) = dest_simple_„ neg;
	val vstr = fst(dest_var v);
	val abs = snd(dest_app neg);
	val mf_s1 = inst_type_rule[(type_of v,mk_vartype "'a")] s35;
	val mf_s2 = simple_ƒ_elim abs mf_s1;
	val mf_s3 = conv_rule(ONCE_MAP_C simple_%beta%_conv
		THEN_C ONCE_MAP_C (simple_%alpha%_conv vstr)) mf_s2;
	val mf_s4 = refl_conv tm;
	val mf_s5 = eq_trans_rule mf_s4 mf_s3;
in
	(prof "Œ_„_conv";
	mf_s5)
end
handle complaint =>
list_divert complaint "simple_Œ_„_conv" [
	("dest_Œ",7058,[fn () => string_of_term tm]),
	("dest_„",7058,[fn () => string_of_term tm])]
);
end; (* of local val s1 = ... *)
=TEX
\subsection{Concerning € and Š}
ó
s … ƒ a b c Ž ((a € b) Š c) ‚ (a Š b Š c)
s … ƒ a b c Ž (a Š b Š c) ‚ ((a € b) Š c)
æ
=SML
local
	val s1 = asm_rule »a € b¼;
	val s2 = €_left_elim s1;
	val s3 = €_right_elim s1;
	val s4 = asm_rule »a : BOOL¼;
	val s5 = asm_rule »b : BOOL¼;
	val s6 = €_intro s4 s5;
	val s7 = asm_rule »(a € b) Š c¼;
	val s8 = Š_elim s7 s6;
	val s9 = Š_intro »b : BOOL¼ s8;
	val s10 = Š_intro »a : BOOL¼ s9;
	val s11 = Š_intro »(a € b) Š c¼ s10;

	val s12 = asm_rule »a Š b Š c¼;
	val s13 = Š_elim s12 s2;
	val s14 = Š_elim s13 s3;
	val s15 = Š_intro »a € b¼ s14;
	val s16 = Š_intro »a Š b Š c¼ s15;
	
	val s17 = ‚_intro s11 s16;
	val s18 = list_simple_ƒ_intro [»a : BOOL¼, »b : BOOL¼, »c : BOOL¼] s17;
	val s19 = eq_sym_rule s17;
	val s20 = list_simple_ƒ_intro [»a : BOOL¼, »b : BOOL¼, »c : BOOL¼] s19;
in
fun âŠ_€_ruleá (thm : THM) : THM = (
let val (a,(b,c)) = (Combinators.I ** dest_Š)(dest_Š (concl thm));
	val mf_s1 = list_simple_ƒ_elim [a,b,c] s20;
	val mf_s2 = ‚_mp_rule mf_s1 thm;
in
	(prof "Š_€_rule";
	mf_s2)
end
handle complaint =>
divert complaint "dest_Š" "Š_€_rule" 7008 [fn () => string_of_thm thm]
);

fun â€_Š_ruleá (thm : THM) : THM = (
let val ((a,b),c) = (dest_€ ** Combinators.I)(dest_Š (concl thm));
	val mf_s1 = list_simple_ƒ_elim [a,b,c] s18;
	val mf_s2 = ‚_mp_rule mf_s1 thm;
in
	(prof "Š_€_rule";
	mf_s2)
end
handle complaint =>
list_divert complaint "€_Š_rule" [
	("dest_€",7009,[fn () => string_of_thm thm]),
	("dest_Š",7009,[fn () => string_of_thm thm])]
);
end;
=TEX
\subsection{Concerning „$_1$}
=SML
local
	val s1 = ap_arg_rule »P : 'a ‹ BOOL¼ „%down%1_def;
	val s2 = all_simple_%beta%_rule s1;
	val s3 = simple_ƒ_intro »P : 'a ‹ BOOL¼ s2;
in
	val â„%down%1_thmá = save_thm("„%down%1_thm",s3)
end;
=TEX
=SML
fun simple_„%down%1_intro (thm1 : THM) (thm2 : THM) : THM = (
let
	val (x,rest) = dest_simple_ƒ (concl thm2);
	val (Px,(x',t)) = (Combinators.I ** dest_eq)(dest_Š rest);
	val sideeffect = if x = x'
		then ()
		else fail "simple_„%down%1_intro" 7066 [];
	val witness = case (term_match (concl thm1) Px) of
		([],[(w,_)]) => w
		| ([],[]) => t
		| _ => fail "simple_„%down%1_intro" 7067 [];
	val abs = mk_simple_(x,Px);
	val P_t = mk_app(abs, witness);
	val P_x = mk_app(abs, x);
	val s1 = simple_%beta%_conv P_t;
	val s2 = eq_sym_rule s1;
	val s3 = ‚_mp_rule s2 thm1;
	val s4 = simple_%beta%_conv P_x;
	val s5 = eq_sym_rule s4;
	val mgvs = gen_vars [BOOL, type_of x] (frees rest);
	val mgv = hd mgvs;
	val mgv1 = hd(tl mgvs);
	val s6 = all_simple_ƒ_elim thm2;
	val template = mk_Š(mgv,mk_eq(x,t));
	val s7 = subst_rule [(s5,mgv)] template s6;
	val s8 = simple_ƒ_intro x s7;
	val s9 = €_intro s3 s8;
	val template2 = mk_simple_„(mgv1,
		mk_€(mk_app(abs,mgv1),
		mk_simple_ƒ(x,
		mk_Š(
		P_x, mk_eq(x,mgv1)))));
	val s10 = simple_„_intro template2 s9;
	val s11 = inst_type_rule[(type_of x,mk_vartype "'a")] „%down%1_thm;
	val s12 = simple_ƒ_elim abs s11;
	val s13 = eq_sym_rule s12;
	val s14 = ‚_mp_rule s13 s10;
	val s15 = conv_rule(RAND_C (simple_%alpha%_conv (fst(dest_var x)))) s14;
in
	(prof "simple_„%down%1_intro";
	s15)
end
handle complaint =>
list_divert complaint "simple_„%down%1_intro" [
	("term_match",7067,[fn () => string_of_thm thm1, fn () => string_of_thm thm2]),
	("dest_simple_ƒ",7066,[fn () => string_of_thm thm2]),
	("dest_Š",7066,[fn () => string_of_thm thm2])
]
);
=TEX
=SML
fun âsimple_„%down%1_elimá (thm : THM) : THM = (
let 
	val (_,bdy) = dest_app (concl thm);
	val (x,_) = dest_simple_ bdy;
	val (xt,bt) = dest_‹_type(type_of bdy);
	val s1 = inst_type_rule [(xt,mk_vartype "'a")] „%down%1_thm;
	val s2 = simple_ƒ_elim bdy s1;
	val s3 = ‚_mp_rule s2 thm;
	val s4 = conv_rule (BINDER_C
		((RAND_C(BINDER_C(RATOR_C(RAND_C simple_%beta%_conv))))
		THEN_C
		(RATOR_C(RAND_C simple_%beta%_conv)))) s3;
	val s5 = conv_rule(RAND_C (simple_%alpha%_conv (fst(dest_var x)))) s4;
in
	(prof "simple_„%down%1_elim";
	s5)
end
handle complaint =>
list_divert complaint "simple_„%down%1_elim" [
	("dest_app",7015,[fn () => string_of_thm thm]),
	("dest_simple_",7015,[fn () => string_of_thm thm]),
	("dest_fun",7015,[fn () => string_of_thm thm]),
	("‚_mp_rule",7015,[fn () => string_of_thm thm])]
);
=TEX
\section{END OF THE STRUCTURE}
=SML
end; (* of structure DerivedInferenceRules *)
open DerivedInferenceRules; 
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN
Statistics:

open Sort;
fun comp_stats (s1,n1) (s2,n2) = (
	if n1 = n2
	then stringorder s1 s2
	else (n1 - n2)
);

sort comp_stats (get_stats ());
