=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Implementation for the Derived Rules of Inference}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Derived Rules of Inference}
\TPPref{DS/FMU/IED/IMP007}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{K.~Blackburn & WIN01\\D.J.~King & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
Primitive and built-in inference rules, and conversionals
all module tested to these implementations.
\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the derived rules of inference.
This includes user versions of the
primitive and built-in inference rules.
The design is in \cite{DS/FMU/IED/DTD007}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the 
This includes user versions of the
primitive and built-in inference rules.
A ``primitive'' inference rule is considered to be part of the logic,
whereas a ``built-in'' rule is one that, though it could be coded in terms 
of the primitive rules, will actually be part of the abstract data type $THM$, and thus taken as holding true without checking.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD007},
and also requires those files indicated as preceding it in the 
rel001 makefile.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}


\section{THE ABSTRACT DATA TYPE $THM$}
=SML
(* structure âDerivedInferenceRulesá : DerivedInferenceRules = struct *)
=TEX
\subsection{Utilities}
We will often wish to just pass on error messages,
just changing the source area of the message if it is from
particular function.
Thus:
=SML
fun âpass_oná (e : exn) (fromnm : string) (tonm : string) : 'a = (
let val efrom = area_of e
in
	if efrom = fromnm
	then reraise e tonm
	else reraise e efrom
end);
=TEX
The following two should be visible to the outside world:
=SML
val âconclá :  THM -> TERM = snd o dest_thm;
val âhypsá : THM -> TERM list = fst o dest_thm;
=TEX
\subsection{Primitive and Built-in Rules}
This, and only this, part is done in the context
of an open kernel:
=SML
local
	open icl'Kernel;
in
=TEX
\subsubsection{Primitive Rules}
=SML
fun âsubst_ruleá (thm_var_lst : (THM * TERM) list) :
	TERM -> THM -> THM = (
	let val s1 = icl'subst_rule thm_var_lst
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule"
	in
	(fn (tm : TERM) =>
	let val s2 = s1 tm
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule"
	in
	(fn (thm : THM) =>
	(prof "subst_rule";
	s2 thm
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule")
	)
	end)
	end
);
=TEX
=SML
fun âsimple_abs_ruleá (tm : TERM) (thm : THM) : THM = (
	prof "simple_abs_rule";
	icl'simple_abs_rule tm thm
		handle complaint => 
		pass_on complaint "icl'simple_abs_rule" "simple_abs_rule"
);
=SML
fun âinst_type_ruleá (ty_list : (TYPE * TYPE) list) (thm : THM) : THM = (
	prof "inst_type_rule";
	icl'inst_type_rule ty_list thm
		handle complaint => 
		pass_on complaint "icl'inst_type_rule" "inst_type_rule"
);
=TEX
=SML
fun âŠ_introá (tm : TERM) (thm : THM) : THM = (
	prof "Š_intro";
	icl'Š_intro tm thm
		handle complaint => 
		pass_on complaint "icl'Š_intro" "Š_intro"
);
=TEX
=SML
fun âŠ_elimá (thm1 : THM) (thm2 : THM) : THM = (
	prof "Š_elim";
	icl'Š_elim thm1 thm2
		handle complaint => 
		pass_on complaint "icl'Š_elim" "Š_elim"
);
=TEX
=SML
fun âasm_ruleá (tm : TERM) : THM = (
	prof "asm_rule";
	icl'asm_rule tm
		handle complaint => 
		pass_on complaint "icl'asm_rule" "asm_rule"
);
=TEX
=SML
val ârefl_convá : CONV = (
	fn (tm : TERM) =>
	(prof "refl_conv";
	icl'refl_conv tm
		handle complaint => 
		pass_on complaint "icl'refl_conv" "refl_conv")
);
=TEX
=SML
val âsimple_%beta%_convá : CONV = (
	fn (tm : TERM) =>
	(prof "simple_%beta%_conv";
	icl'simple_%beta%_conv tm
		handle complaint => 
		pass_on complaint "icl'simple_%beta%_conv" "simple_%beta%_conv")
);
=TEX
\subsubsection{Definitional Schemata}
=SML
local
	val N0 = »0¼;
in
val âsuc_convá : CONV = (
	fn (tm : TERM) =>
	(prof "suc_conv";
	if tm = N0
	then fail "suc_conv" 7100 []
	else icl'suc_conv tm
		handle complaint => 
		pass_on complaint "icl'suc_conv" "suc_conv")
);
end;
=TEX
=SML
val âstring_convá : CONV = (
	fn (tm : TERM) =>
	(prof "string_conv";
	icl'string_conv tm
		handle complaint => 
		pass_on complaint "icl'string_conv" "string_conv")
);
=TEX
=SML
val âchar_convá : CONV = (
	fn (tm : TERM) =>
	(prof "char_conv";
	icl'char_conv tm
		handle complaint => 
		pass_on complaint "icl'char_conv" "char_conv")
);
=TEX
\subsubsection{Built-In Rules of Inference}
=SML
fun âeq_sym_ruleá (thm : THM) : THM = (
	prof "eq_sym_rule";
	icl'eq_sym_rule thm
		handle complaint => 
		pass_on complaint "icl'eq_sym_rule" "eq_sym_rule"
);
=TEX
=SML
fun âsimple_ƒ_elimá (tm : TERM) (thm : THM) : THM = (
	prof "simple_ƒ_elim";
	icl'simple_ƒ_elim tm thm
		handle complaint => 
		pass_on complaint "icl'simple_ƒ_elim" "simple_ƒ_elim"
);
=TEX
=SML
fun âeq_trans_ruleá (thm1 : THM) (thm2 : THM) : THM = (
	prof "eq_trans_rule";
	icl'eq_trans_rule thm1 thm2
		handle complaint => 
		pass_on complaint "icl'eq_trans_rule" "eq_trans_rule"
);
=TEX
=SML
fun âmk_comb_ruleá (thm1 : THM) (thm2 : THM) : THM = (
	prof "mk_comb_rule";
	icl'mk_comb_rule thm1 thm2
		handle complaint => 
		pass_on complaint "icl'mk_comb_rule" "mk_comb_rule"
);
=TEX
=SML
fun â‚_mp_ruleá (thm1 : THM) (thm2 : THM) : THM = (
	prof "‚_mp_rule";
	icl'‚_mp_rule thm1 thm2
		handle complaint => 
		pass_on complaint "icl'‚_mp_rule" "‚_mp_rule"
);
=TEX
=SML
fun âsimple_ƒ_introá (tm : TERM) (thm : THM) : THM = (
	prof "simple_ƒ_intro";
	icl'simple_ƒ_intro tm thm
		handle complaint => 
		pass_on complaint "icl'simple_ƒ_intro" "simple_ƒ_intro"
);
=TEX
=SML
fun âinst_term_ruleá (tml : (TERM * TERM) list) (thm : THM) : THM = (
	prof "inst_term_rule";
	icl'inst_term_rule tml thm
		handle complaint => 
		pass_on complaint "icl'inst_term_rule" "inst_term_rule"
);
=TEX
=SML
val âdiv2_convá : CONV = (
	fn (tm : TERM) =>
	(prof "div2_conv";
	icl'div2_conv tm
		handle complaint => 
		pass_on complaint "icl'div2_conv" "div2_conv")
);
=TEX
=SML
val âmod2_convá : CONV = (
	fn (tm : TERM) =>
	(prof "mod2_conv";
	icl'mod2_conv tm
		handle complaint => 
		pass_on complaint "icl'mod2_conv" "mod2_conv")
);
=TEX
=SML
end; (* local open icl'Kernel *)
=TEX
\subsection{Inference Rules For Conversions}
Two "proper" failures come from $mk\_comb\_rule$,
each with their own failure message from
$ap\_fun\_rule$.
We need to do some calculation to determine which error
is given: but we only do this if we get a failure.
=SML
fun âap_fun_ruleá (tm : TERM) (thm : THM) : THM = ((
let
	val thm1 = refl_conv tm;
in
	(prof "ap_fun_rule";
	mk_comb_rule thm1 thm)
end)
handle complaint =>
if is_eq(concl thm)
then divert complaint "mk_comb_rule" "ap_fun_rule" 7024 []
else divert complaint "mk_comb_rule" "ap_fun_rule" 7023 []
);
=TEX
Two "proper" failures come from $mk\_comb\_rule$,
each with their own failure message from
$ap\_arg\_rule$.
We need to do some calculation to determine which error
is given: but we only do this if we get a failure.
=SML
fun âap_arg_ruleá (tm : TERM) (thm : THM) : THM = (
let
	val thm1 = refl_conv tm;
in
	(prof "ap_arg_rule";
	mk_comb_rule thm thm1)
end
handle complaint =>
if is_eq(concl thm)
then divert complaint "mk_comb_rule" "ap_arg_rule" 7025 []
else divert complaint "mk_comb_rule" "ap_arg_rule" 7023 []
);
=TEX

\subsection{Conversions}
\subsubsection{Building Blocks}
=SML
val âfail_convá : CONV = (fn tm => fail "fail_conv" 7061 []);

fun âfail_with_convá (str : string) : CONV = (
	fn tm => fail "fail_with_conv" 7075 [fn () => str]
);
=TEX
\subsubsection{Conversionals}
=SML
fun (cnv1 : CONV) âTHEN_Cá (cnv2 : CONV) = (fn (tm: TERM) =>
let
	val thm1 = cnv1 tm;
	val rhs_thm1 = snd(dest_eq (concl thm1));
	val thm2 = cnv2 rhs_thm1;
in
	eq_trans_rule thm1 thm2
end
handle complaint =>
list_divert complaint "THEN_C" [
	("dest_eq",7101,[]),
	("eq_trans_rule",7102,[])]);
=TEX
=SML
fun (cnv1 : CONV) âFURTHER_Cá (cnv2 : CONV) = (fn (tm: TERM) =>
let
	val thm1 = cnv1 tm
in
	(let
		val rhs_thm1 = snd(dest_eq (concl thm1));
		val thm2 = cnv2 rhs_thm1;
	in
		eq_trans_rule thm1 thm2
	end
	handle (Fail _) => thm1)
end);
=TEX
=SML
fun (cnv1 : CONV) âORELSE_Cá (cnv2 : CONV) = (fn (tm: TERM) =>
	cnv1 tm
handle (Fail _) =>
	cnv2 tm
);
=TEX
=SML
fun (cnv1 : CONV) âEITHER_Cá (cnv2 : CONV) : CONV = (fn (tm: TERM) =>
(let
	val thm1 = cnv1 tm
in
	(let
		val rhs_thm1 = snd(dest_eq (concl thm1));
		val thm2 = cnv2 rhs_thm1;
	in
		eq_trans_rule thm1 thm2
	end
	handle (Fail _) => thm1)
end
handle (Fail _) => cnv2 tm)
);
=TEX
=SML
fun âTRY_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
	cnv tm
	handle (Fail _) =>
	refl_conv tm
);
=TEX
=SML
fun âREPEAT1_Cá (cnv : CONV) = (fn (tm : TERM) =>
	(cnv FURTHER_C (REPEAT1_C cnv)) tm
);
=TEX
Notice that the following is carefully coded to avoid
redundant $refl\_conv$'s.
There is a minor partial evaluation effect with 
only the conversion argument.
=SML
fun âREPEAT_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
	TRY_C (REPEAT1_C cnv) tm
);
=TEX
Partially evaluated given only a list.
=SML
fun âLIST_THEN_Cá ([cnv] : CONV list) : CONV = cnv
| LIST_THEN_C (cnv :: crest) = cnv THEN_C (LIST_THEN_C crest)
| LIST_THEN_C [] = fail "LIST_THEN_C" 7103 [];
=TEX
Partially evaluated given only a list.
=SML
fun âLIST_ORELSE_Cá ([cnv] : CONV list) : CONV = cnv
| LIST_ORELSE_C (cnv :: crest) = cnv ORELSE_C (LIST_ORELSE_C crest)
| LIST_ORELSE_C [] = fail "LIST_ORELSE_C" 7103 [];
=TEX
=SML
fun âCHANGED_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let val thm = cnv tm;
	val rhs_thm = (snd o dest_eq o concl) thm;
in
	if rhs_thm <> tm
	then thm
	else fail "CHANGED_C" 7032 []
end
handle complaint =>
divert complaint "dest_eq" "CHANGED_C" 7104[]);
=TEX
\subsubsection{Term Traversal Algorithms for Conversions}
=SML
fun  âRAND_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let
	val (f,x) = dest_comb tm;
	val thm1 = cnv x;
in
	ap_fun_rule f thm1
end
handle complaint =>
list_divert complaint "RAND_C" [
	("dest_comb",7045,[]),
	("ap_fun_rule",7104,[])]
);
=TEX
=SML
fun  âRATOR_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let
	val (f,x) = dest_comb tm;
	val thm1 = cnv f;
in
	ap_arg_rule x thm1
end
handle complaint =>
list_divert complaint "RATOR_C" [
	("dest_comb",7045,[]),
	("ap_arg_rule",7104,[])]
);
=TEX
=SML
fun  âABS_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let
	val (x,b) = simple_dest_abs tm;
	val thm1 = cnv b;
in
	simple_abs_rule x thm1
end
handle complaint =>
list_divert complaint "ABS_C" [
	("simple_dest_abs",7030,[]),
	("simple_abs_rule",7104,[])]
);
=TEX
We do the following in full to be able to determine the
correct error message, if necessary.
It could just be $RAND\_C\ o\ ABS\_C$.
=SML
fun  âBINDER_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let
	val (binder,abs) = dest_comb tm;
	val (x,b) = simple_dest_abs abs;
	val thm1 = cnv b;
in
	ap_fun_rule binder (simple_abs_rule x thm1)
end
handle complaint =>
list_divert complaint "BINDER_C" [
	("simple_dest_abs",7059,[]),
	("dest_comb",7059,[]),
	("simple_abs_rule",7104,[]),
	("ap_fun_rule",7104,[])]
);
=TEX
We could build the following using the above building blocks,
but prefer to keep it fast.
=SML
fun âSUB_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let
	fun aux (Var _) = refl_conv tm
	| aux (Const _) = refl_conv tm
	| aux (Comb (f,x)) = (
		((let val thm1 = cnv f
		in
		 (let val thm2 = cnv x
		 in
			mk_comb_rule thm1 thm2
		 end
		 handle (Fail _) =>
		 ap_arg_rule x thm1)
		end)
		handle (Fail _) =>
		(let val thm2 = cnv x
		in
			ap_fun_rule f thm2
		end))
		handle (Fail _) => refl_conv tm
	) | aux (Abs (x,b)) = (
		let val thm1 = cnv b
		in
			simple_abs_rule x thm1
		end
		handle (Fail _) =>
		refl_conv tm
	);
in
	aux(simple_dest_term tm)
end
handle complaint =>
list_divert complaint "SUB_C" [
	("mk_comb_rule",7104,[]),
	("simple_abs_rule",7104,[])]
);
=TEX
There is a mild partial evaluation with only a conversion.
=SML
fun âSUB1_Cá (cnv : CONV) : CONV = (fn (tm : TERM) => 
let
	fun aux (Var _) = fail "SUB1_C"  7105 []
	| aux (Const _) = fail "SUB1_C"  7105 []
	| aux (Comb (f,x)) = (
		let val thm1 = cnv f
		in
		 (let val thm2 = (cnv x
			handle (Fail _) => refl_conv x)
		 in
			mk_comb_rule thm1 thm2
		 end)
		end
		handle (Fail _) =>
		(let val thm2 = cnv x
		in
			ap_fun_rule f thm2
		end)
	) | aux (Abs (x,b)) = (
		let val thm1 = cnv b
		in
			simple_abs_rule x thm1
		end
	);
in
	aux(simple_dest_term tm)
end
handle complaint =>
list_divert complaint "SUB1_C" [
	("ap_fun_rule",7104,[]),
	("simple_abs_rule",7104,[])]
);
=TEX
N.B. the $fn\ (tm: TERM) \ldots tm$ might look $\eata$-convertible away, but actually prevents an infinite loop.
=SML
fun âONCE_TRAVERSE_Cá (cnv : CONV) : CONV = (fn (tm: TERM) =>
	(cnv ORELSE_C (SUB1_C (ONCE_TRAVERSE_C cnv))) tm
);
=TEX
=SML
fun âTRAVERSE_Cá (cnv : CONV) : CONV = (fn tm =>
	((SUB1_C (TRAVERSE_C cnv)) EITHER_C (REPEAT1_C cnv)) tm
);
=TEX
=SML
fun âREPEAT_TRAVERSE_Cá (cnv : CONV) : CONV = (fn tm =>
	((SUB1_C (REPEAT_TRAVERSE_C cnv))
	EITHER_C (cnv FURTHER_C (REPEAT_TRAVERSE_C cnv))) tm
);
=TEX
=SML
fun âTOP_TRAVERSE_Cá (cnv : CONV) : CONV = (fn (tm:TERM) =>
	((REPEAT1_C cnv) EITHER_C (SUB1_C(TOP_TRAVERSE_C cnv)))tm
);
=TEX
\subsubsection{Conversions as Rules}
=SML
fun âconv_ruleá (cnv : CONV) (thm : THM) : THM = (
let
	val thm1 = cnv(concl thm)
in
	‚_mp_rule thm1 thm
end
handle complaint =>
divert complaint "‚_mp_rule" "conv_rule" 7104 []);
=TEX 
\section{END OF THE STRUCTURE}
=SML
(* end; structure DerivedInferenceRules *)
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
