% imp007.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the Derived Rules of Inference}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Derived Rules of Inference}
\TPPref{DS/FMU/IED/IMP007}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
% \TPPauthors{K.~Blackburn & WIN01\\D.J.~King & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}

\item [29 May 1991 Issue 1.1]
First version.
Primitive and built-in inference rules, and conversionals
all module tested to these implementations.

\item [30 May 1991 Issue 1.2] Added material up to $Ä$.

\item [31 May 1991 Issue 1.3] Added up to $ä\_trans\_rule$, corrected $ªåº$.

\item [7 June 1991 Issue 1.4] Added up to $å\_eq\_sym\_rule$, and DJK work.

\item [7 June 1991 Issue 1.5]
Corrected the description of $å\_1\_thm$,
and corrected $list\_simple\_É\_intro$.
Added material up to $asm\_inst\_type\_rule$.

\item [10 June 1991 Issue 1.6] Corrected $simple\_Ñ_elim$.

\item [10 June 1991 Issue 1.7] Added most of the rest.

\item [17 June 1991 Issue 1.8] Added the rest.

\item [18 June 1991 Issue 1.9]
Renamed $LIST\_THEN\_C$ to $EVERY\_C$, $LIST\-\_ORELSE\-\_C$ to $FIRST\-\_C$,
and added $COMB\-\_C$.
Tidying up, profiling put about successful calls.

\item [18 June 1991 Issue 1.10] Added author's names.

\item [19 June 1991 Issue 1.12]
Bought $TOP\_TRAVERSE\_C$ into line with prototype's 
$TOP\-\_DEPTH\-\_CONV$.
$prove\-\_asm\-\_rule$ doesn't worry about missing assumptions.
Corrected $\_match$ functions.

\item [19 June 1991 Issue 1.13] Corrected a use of $all\_simple\_É\_elim$.

\item [21 June 1991 Issue 1.14]
Corrected $apply\_matches\_rule$.
Corrected various error messages.
Corrected $å\_intro$ and $å\_elim$.

\item [24 June 1991 Issue 1.15] Corrected $COMB\_C$ error message.

\item [27 June 1991 Issue 1.16]
Corrected indexing of saved theorems.
Changed $\_TRAVERSE\_C$ to $\_MAP\_C$.
Removed informal test material from ``=IGN'' sections.
$?\_MAP\_C$ all have failure 7005 added.
The prefix $simple$ is moved to being the first prefix, bar $icl'$.
Changed order of $all\_É\_intro$ introduced variables.

\item[03 July 1991 Issue 1.17] $simple\_Ñ\_elim$ changed in accord with issue 1.15 detailed design change.

\item[03 July 1991 Issue 1.18] Added $id\_conv$.

\item[25 July 1991 Issue 1.19] Split into two structures, see section~\ref{SplitStructure}.

\item [29 July 1991 Issue 1.20]
Changed as result of changes caused by IR0016.

\item [5 August 1991 Issue 1.21]
Reacting to issue 1.18 of \cite{DS/FMU/IED/DTD006}.

\item [8 August 1991 Issue 1.22]
Reacting to changes from ID0021.

\item [15th August 1991 Issue 1.23]
Renamings of functions containing the name atom $simple$,
and renaming of $aconv$.

\item [5th September 1991 Issue 1.24]
Tidying up.
\item [24th September 1991 Issue 1.25]
Changes in reaction to issue 1.25 of \cite{DS/FMU/IED/DTD007}.
\item [14th October 1991 Issue 1.26]
Corrected a bug in $á\_elim\_rule$.
\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the derived rules of inference.
This includes user versions of the
primitive and built-in inference rules.
The design is in \cite{DS/FMU/IED/DTD007}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the 
This includes user versions of the
primitive and built-in inference rules.
A ``primitive'' inference rule is considered to be part of the logic,
whereas a ``built-in'' rule is one that, though it could be coded in terms 
of the primitive rules, will actually be part of the abstract data type $THM$, and thus taken as holding true without checking.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD007},
and also requires those files indicated as preceding it in the 
rel001 makefile.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Compilation Note}
\label{SplitStructure}

Issues~1.18 and earlier of this document declared a single structure,
by issue~1.18 this had almost~2300 lines of Standard~ML. Unfortunately
this structure failed to compile on Sun~3 computers although it did
compile on Sun~4 computers. Investigations failed to find the exact
cause of the compilation failure apart from a code generation limit was
exceeded.

The resolution of the compilation failure was to divide the structure
into two pieces, as follows.

ÛSML example
structure DerivedInferenceRules = struct
	(* First set of declarations *)
	...
end;

structure ‚DerivedInferenceRules· : DerivedInferenceRules = struct
	(* Second set of declarations *)
	open DerivedInferenceRules;
	...
end;

open DerivedInferenceRules;
Ê

Here the two structures have the same name, there is a signature
constraint only on the second, the first structure is opened within the
second, the second structure declaration hides the first. The effect
is to create one structure having the required signature.

\section{THE ABSTRACT DATA TYPE $THM$}
=SML
structure ‚DerivedRules1· = struct
=TEX
\subsection{Primitive and Built-in Rules}
This, and only this, part is done in the context
of an open kernel:
=SML
local
	open icl'Kernel;
in
=TEX
\subsubsection{Primitive Rules}
=SML
fun ‚subst_rule· (thm_var_lst : (THM * TERM) list) :
	TERM -> THM -> THM = (
	let val s1 = icl'subst_rule thm_var_lst
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule"
	in
	(fn (tm:TERM) =>
	let val s2 = s1 tm
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule"
	in
	(fn (thm : THM) =>
	(let
		val s3 = s2 thm
	in
		(prof "subst_rule";
		s3)
	end
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule")
	)
	end)
	end
);
=TEX
=SML
fun ‚simple_ç_eq_rule· (tm : TERM) (thm : THM) : THM = (
let	val s1 = icl'simple_ç_eq_rule tm thm
in
	(prof "simple_ç_eq_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'simple_ç_eq_rule" "simple_ç_eq_rule"
);
=SML
fun ‚inst_type_rule· (ty_list : (TYPE * TYPE) list) (thm : THM) : THM = (
let	val s1 = icl'inst_type_rule ty_list thm
in
	(prof "inst_type_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'inst_type_rule" "inst_type_rule"
);
=TEX
=SML
fun ‚ä_intro· (tm : TERM) (thm : THM) : THM = (
let	val s1 = icl'ä_intro tm thm
in
	(prof "ä_intro";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'ä_intro" "ä_intro"
);
=TEX
=SML
fun ‚ä_elim· (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = icl'ä_elim thm1 thm2
in
	(prof "ä_elim";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'ä_elim" "ä_elim"
);
=TEX
=SML
fun ‚asm_rule· (tm : TERM) : THM = (
let	val s1 = icl'asm_rule tm
in
	(prof "asm_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'asm_rule" "asm_rule"
);
=TEX
=SML
val ‚refl_conv· : CONV = (fn (tm:TERM) =>
let	val s1 = icl'refl_conv tm
in
	(prof "refl_conv";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'refl_conv" "refl_conv"
);
=TEX
=SML
val ‚simple_%beta%_conv· : CONV = (fn (tm:TERM) =>
let	val s1 = icl'simple_%beta%_conv tm
in
	(prof "simple_%beta%_conv";
	s1)
end
		handle complaint => 
		pass_on complaint "icl'simple_%beta%_conv" "simple_%beta%_conv"
);
=TEX
\subsubsection{Definitional Schemata}
=SML
local
	val N0 = mk_Ü 0;
in
val ‚suc_conv· : CONV = (fn (tm:TERM) =>
let	val s1 = if tm = N0
		then term_fail "suc_conv" 7100 [tm]
		else icl'suc_conv tm
in
	(prof "suc_conv";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'suc_conv" "suc_conv"
);
end;
=TEX
=SML
val ‚string_conv· : CONV = (fn (tm:TERM) =>
let	val s1 = icl'string_conv tm
in
	(prof "string_conv";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'string_conv" "string_conv"
);

=TEX
=SML
val ‚char_conv· : CONV = (fn (tm:TERM) =>
let	val s1 = icl'char_conv tm
in
	(prof "char_conv";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'char_conv" "char_conv"
);
=TEX
\subsubsection{Built-In Rules of Inference}
=SML
fun ‚eq_sym_rule· (thm : THM) : THM = (
let	val s1 = icl'eq_sym_rule thm
in
	(prof "eq_sym_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'eq_sym_rule" "eq_sym_rule"
);
=TEX
=SML
fun ‚list_simple_É_elim· (tml : TERM list) (thm : THM) : THM = (
let	val s1 = icl'list_simple_É_elim tml thm
in
	(prof "list_simple_É_elim";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'list_simple_É_elim" "list_simple_É_elim"
);
=TEX
=SML
fun ‚eq_trans_rule· (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = icl'eq_trans_rule thm1 thm2
in
	(prof "eq_trans_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'eq_trans_rule" "eq_trans_rule"
);
=TEX
=SML
fun ‚mk_app_rule· (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = icl'mk_app_rule thm1 thm2
in
	(prof "mk_app_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'mk_app_rule" "mk_app_rule"
);
=TEX
=SML
fun ‚Ç_mp_rule· (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = icl'Ç_mp_rule thm1 thm2
in
	(prof "Ç_mp_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'Ç_mp_rule" "Ç_mp_rule"
);
=TEX
=SML
fun ‚simple_É_intro· (tm : TERM) (thm : THM) : THM = (
let	val s1 = icl'simple_É_intro tm thm
in
	(prof "simple_É_intro";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'simple_É_intro" "simple_É_intro"
);
=TEX
=SML
fun ‚inst_term_rule· (tml : (TERM * TERM) list) (thm : THM) : THM = (
let	val s1 = icl'inst_term_rule tml thm
in
	(prof "inst_term_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'inst_term_rule" "inst_term_rule"
);
=TEX
=SML
val ‚div2_conv· : CONV = (fn (tm:TERM) =>
let	val s1 = icl'div2_conv tm
in
	(prof "div2_conv";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'div2_conv" "div2_conv"
);
=TEX
=SML
val ‚mod2_conv· : CONV = (fn (tm:TERM) =>
let	val s1 = icl'mod2_conv tm
in
	(prof "mod2_conv";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'mod2_conv" "mod2_conv"
);
=TEX
It seems best to implement the following using $icl'list\_simple\_É\_elim$ directly, rather than go through its interface, and thus an additional profiling call.
=RULE
simple_É_elim
ªt1º
…
ˆ Ö É x é t2[x]
…
ˆ Ö t2'[t1]
=TEX
where $x$ is a simple variables.
=SML
fun ‚simple_É_elim· (tm: TERM) (thm:THM) = (
let	val s1 = icl'list_simple_É_elim [tm] thm
in
	(prof "simple_É_elim";
	s1)
end
handle complaint =>
let	val efrom = area_of complaint
in
	if efrom = "icl'list_simple_É_elim"
	then (if not(is_simple_É (concl thm))
		then thm_fail "simple_É_elim" 7039 [thm]
		else let val (v,_) = dest_simple_É (concl thm)
		in
			if type_of v <> type_of tm
			then term_fail "simple_É_elim" 3012 [v,tm]
			else reraise complaint "simple_É_elim"
		end)
	else reraise complaint efrom
end);

=TEX
=SML
end; (* local open icl'Kernel *)
=TEX
\subsection{Inference Rules For Conversions}
Two "proper" failures come from $mk\-\_app\-\_rule$,
each with their own failure message from
$ap\-\_fun\-\_rule$.
We need to do some calculation to determine which error
is given: but we only do this if we get a failure.
=SML
fun ‚ap_fun_rule· (tm : TERM) (thm : THM) : THM = ((
let	val s1 = refl_conv tm;
	val s2 = mk_app_rule s1 thm
in
	(prof "ap_fun_rule";
	s2)
end)
handle complaint =>
if is_eq(concl thm)
then divert complaint "mk_app_rule" "ap_fun_rule" 7024 [fn () => string_of_term tm]
else divert complaint "mk_app_rule" "ap_fun_rule" 6020 [fn () => string_of_thm thm]
);
=TEX
Two "proper" failures come from $mk\-\_app\-\_rule$,
each with their own failure message from
$ap\-\_arg\-\_rule$.
We need to do some calculation to determine which error
is given: but we only do this if we get a failure.
=SML
fun ‚ap_arg_rule· (tm : TERM) (thm : THM) : THM = (
let	val s1 = refl_conv tm;
	val s2 = mk_app_rule thm s1;
in
	(prof "ap_arg_rule";
	s2)
end
handle complaint =>
if is_eq(concl thm)
then divert complaint "mk_app_rule" "ap_arg_rule" 7025 [fn () => string_of_term tm]
else divert complaint "mk_app_rule" "ap_arg_rule" 6020 [fn () => string_of_thm thm]
);
=TEX

\subsection{Conversions}
\subsubsection{Building Blocks}
=SML
val ‚id_conv· : CONV = refl_conv;

val ‚fail_conv· : CONV = (fn (tm:TERM) => fail "fail_conv" 7061 []);

fun ‚fail_with_conv· (str : string) : CONV = (
	fn (tm:TERM) => fail "fail_with_conv" 7075 [fn () => str]
);
=TEX
\subsubsection{Conversionals}
=SML
fun (cnv1 : CONV) ‚THEN_C· (cnv2 : CONV) : CONV = (fn (tm: TERM) =>
let	val s1 = cnv1 tm;
	val rhs_s1 = snd(dest_eq (concl s1))
		handle complaint =>
		divert complaint "dest_eq" "THEN_C" 7101 [fn () => string_of_thm s1];
	val s2 = cnv2 rhs_s1;
	val s3 = eq_trans_rule s1 s2
		handle complaint =>
		divert complaint "eq_trans_rule" "THEN_C" 7102 [fn () => string_of_thm s2,
			fn () => string_of_thm s1];
in
	s3
end);
=TEX
=SML
fun (cnv1 : CONV) ‚FURTHER_C· (cnv2 : CONV) : CONV = (fn (tm: TERM) =>
let	val s1 = cnv1 tm
in
	(let
		val rhs_s1 = snd(dest_eq (concl s1));
		val s2 = cnv2 rhs_s1;
		val s3 = eq_trans_rule s1 s2
	in
		s3
	end
	handle (Fail _) => s1)
end);
=TEX
=SML
fun (cnv1 : CONV) ‚ORELSE_C· (cnv2 : CONV) : CONV = (fn (tm: TERM) =>
	cnv1 tm
handle (Fail _) =>
	cnv2 tm
);
=TEX
=SML
fun (cnv1 : CONV) ‚EITHER_C· (cnv2 : CONV) : CONV = (fn (tm: TERM) =>
(let	val s1 = cnv1 tm
in
	(let
		val rhs_s1 = snd(dest_eq (concl s1));
		val s2 = cnv2 rhs_s1;
		val s3 = eq_trans_rule s1 s2;
	in
		s3
	end
	handle (Fail _) => s1)
end
handle (Fail _) => cnv2 tm)
);
=TEX
=SML
fun ‚TRY_C· (cnv : CONV) : CONV = (fn (tm:TERM) =>
	cnv tm
	handle (Fail _) =>
	refl_conv tm
);
=TEX
=SML
fun ‚COND_C· (pred:TERM -> bool) (cnv1 : CONV) (cnv2:CONV) : CONV = (fn (tm:TERM) =>
	if pred tm
	then cnv1 tm
	else cnv2 tm
);
=TEX
=SML
fun ‚REPEAT1_C· (cnv : CONV) : CONV = (fn (tm:TERM) =>
	(cnv FURTHER_C (REPEAT1_C cnv)) tm
);
=TEX
Notice that the following is carefully coded to avoid
redundant $refl\_conv$'s.
There is a minor partial evaluation effect with 
only the conversion argument.
=SML
fun ‚REPEAT_C· (cnv : CONV) : CONV = (fn (tm:TERM) =>
	TRY_C (REPEAT1_C cnv) tm
);
=TEX
Partially evaluated given only a list.
=SML
fun ‚EVERY_C· ([cnv] : CONV list) : CONV = cnv
| EVERY_C (cnv :: crest) = cnv THEN_C (EVERY_C crest)
| EVERY_C [] = fail "EVERY_C" 7103 [];
=TEX
Partially evaluated given only a list.
=SML
fun ‚FIRST_C· ([cnv] : CONV list) : CONV = cnv
| FIRST_C (cnv :: crest) = cnv ORELSE_C (FIRST_C crest)
| FIRST_C [] = fail "FIRST_C" 7103 [];
=TEX
=SML
fun ‚CHANGED_C· (cnv : CONV) : CONV = (fn (tm:TERM) =>
let	val s1 = cnv tm;
	val rhs_s1 = (snd o dest_eq o concl) s1
		handle complaint =>
		divert complaint "dest_eq" "CHANGED_C" 7104[fn () => string_of_thm s1]		
in
	if rhs_s1 <> tm
	then s1
	else fail "CHANGED_C" 7032 []
end);
=TEX
\subsubsection{Term Traversal Algorithms for Conversions}
=SML
fun ‚RAND_C· (cnv : CONV) : CONV = (fn (tm:TERM) =>
let	val (f,x) = dest_app tm
		handle complaint =>
		pass_on complaint "dest_app" "RAND_C";
	val s1 = cnv x;
	val s2 = ap_fun_rule f s1
		handle complaint =>
		divert complaint "ap_fun_rule" "RAND_C" 7104 
			[fn () => string_of_thm s1];
in
	s2
end);
=TEX
=SML
fun ‚RATOR_C· (cnv : CONV) : CONV = (fn (tm:TERM) =>
let	val (f,x) = dest_app tm
		handle complaint =>
		pass_on complaint "dest_app" "RATOR_C";
	val s1 = cnv f;
	val s2 = ap_arg_rule x s1
		handle complaint =>
		divert complaint "ap_arg_rule" "RATOR_C" 7104
			[fn () => string_of_thm s1];
in
	s2
end);
=TEX
=SML
fun ‚APP_C· (cnv1 : CONV, cnv2 : CONV) : CONV = (fn (tm:TERM) =>
let	val (f,x) = dest_app tm
		handle complaint =>
		pass_on complaint "dest_app" "APP_C";
	val s1 = cnv1 f;
	val s2 = cnv2 x;
	val s3 = mk_app_rule s1 s2
		handle complaint =>
		divert complaint "mk_app_rule" "APP_C" 7110
			[fn () => string_of_thm s1,
			 fn () => string_of_thm s2];
in
	s3
end);
=TEX
=SML
fun ‚SIMPLE_ç_C· (cnv : CONV) : CONV = (fn (tm:TERM) =>
let	val (x,b) = dest_simple_ç tm
		handle complaint =>
		pass_on complaint "dest_simple_ç" "SIMPLE_ç_C";
	val s1 = cnv b;
	val s2 = simple_ç_eq_rule x s1
		handle complaint =>
		divert complaint "simple_ç_eq_rule" "SIMPLE_ç_C" 7104 
			[fn () => string_of_thm s1];
in
	s2
end);
=TEX
We do the following in full to be able to determine the
correct error message, if necessary.
It could just be $RAND\_C\ o\ SIMPLE\_ç\_C$.
=SML
fun ‚BINDER_C· (cnv : CONV) : CONV = (fn (tm:TERM) =>
let	val (binder,abs) = dest_app tm;
	val (x,b) = dest_simple_ç abs;
	val s1 = cnv b;
	val s2 = ap_fun_rule binder (simple_ç_eq_rule x s1)
		handle complaint =>
		list_divert complaint "BINDER_C" [
			("simple_ç_eq_rule",7104,[fn () => string_of_thm s1]),
			("ap_fun_rule",7104,[fn () => string_of_thm s1])];	
in
	s2
end
handle complaint =>
list_divert complaint "BINDER_C" [
	("dest_simple_ç",7059,[fn () => string_of_term tm]),
	("dest_app",7059,[fn () => string_of_term tm])]
);
=TEX
We could build the following using the above building blocks,
but prefer to keep it fast.
=SML
fun ‚SUB_C· (cnv : CONV) : CONV = (fn (tm:TERM) =>
let	fun aux (Var _) = refl_conv tm
	| aux (Const _) = refl_conv tm
	| aux (App (f,x)) = (
		((let val thm1 = cnv f
		in
		 (let val thm2 = cnv x
		 in
			mk_app_rule thm1 thm2
		 end
		 handle (Fail _) =>
		 ap_arg_rule x thm1)
		end)
		handle (Fail _) =>
		(let val thm2 = cnv x
		in
			ap_fun_rule f thm2
		end))
		handle (Fail _) => refl_conv tm
	) | aux (Simpleç (x,b)) = (
		let val thm1 = cnv b
		in
			simple_ç_eq_rule x thm1
		end
		handle (Fail _) =>
		refl_conv tm
	);
in
	aux(dest_simple_term tm)
end);
=TEX
There is a mild partial evaluation with only a conversion.
=SML
fun ‚SUB1_C· (cnv : CONV) : CONV = (fn (tm:TERM) => 
let	fun aux (Var _) = term_fail "SUB1_C" 7105 [tm]
	| aux (Const _) = term_fail "SUB1_C" 7105 [tm]
	| aux (App (f,x)) = (
		let val thm1 = cnv f
		in
		 (let val thm2 = (cnv x
			handle (Fail _) => refl_conv x)
		 in
			mk_app_rule thm1 thm2
		 end)
		end
		handle (Fail _) =>
		(let val thm2 = cnv x
		in
			(ap_fun_rule f thm2
			handle complaint =>
			divert complaint "ap_fun_rule" "SUB1_C" 7104
			[fn () => string_of_thm thm2])
		end)
	) | aux (Simpleç (x,b)) = (
		let val thm1 = cnv b
		in
			(simple_ç_eq_rule x thm1
			handle complaint =>
			divert complaint "simple_ç_eq_rule" "SUB1_C" 7104
			[fn () => string_of_thm thm1])
		end
	);
in
	aux(dest_simple_term tm)
end);
=TEX
N.B. the $fn\ (tm: TERM) \ldots tm$ might look $\eta$-convertible away, but actually prevents an infinite loop.
=SML
fun ‚ONCE_MAP_C· (cnv : CONV) : CONV = (fn (tm: TERM) => 
let	fun aux (tm : TERM) = (cnv ORELSE_C (SUB1_C aux)) tm
in
	aux tm
end
handle (Fail _) => fail "ONCE_MAP_C" 7005 []
);
=TEX
=SML
fun ‚MAP_C· (cnv : CONV) : CONV = (fn (tm: TERM) => 
let	fun aux (tm : TERM) = ((SUB1_C (MAP_C cnv)) EITHER_C (REPEAT1_C cnv)) tm
in
	(aux tm)
end
handle (Fail _) => fail "MAP_C" 7005 []
);
=TEX
=SML
fun ‚REPEAT_MAP_C· (cnv : CONV) : CONV = (fn (tm: TERM) => 
let	fun aux (tm : TERM) = ((SUB1_C (REPEAT_MAP_C cnv))
	EITHER_C (cnv FURTHER_C (REPEAT_MAP_C cnv))) tm
in
	(aux tm)
end
handle (Fail _) => fail "REPEAT_MAP_C" 7005 []
);
=TEX
=SML
fun ‚TOP_MAP_C· (cnv : CONV) : CONV = (fn (tm: TERM) => 
let	fun aux (tm : TERM) = ((REPEAT1_C cnv) EITHER_C 
	((CHANGED_C (SUB1_C(TOP_MAP_C cnv)))
		FURTHER_C
		(cnv FURTHER_C (TOP_MAP_C cnv)))) tm
in
	(aux tm)
end
handle (Fail _) => fail "TOP_MAP_C" 7005 []
);
=TEX
\subsubsection{Conversions as Rules}
=SML
fun ‚conv_rule· (cnv : CONV) (thm : THM) : THM = (
let	val s1 = cnv(concl thm);
	val s2 = Ç_mp_rule s1 thm
		handle complaint =>
		divert complaint "Ç_mp_rule" "conv_rule" 7104
		[fn () => string_of_thm s1];
in
	(prof "conv_rule";
	s2)
end);
=TEX 
\section{DERIVED INFERENCE RULES}
We will be saving theorems as we go along, so we need to ensure we are saving them into theory misc:
=SML
val sideeffect = open_theory "misc";
=TEX
An alias:
=SML
val ‚ä_mp_rule· : THM -> THM -> THM = ä_elim;
=TEX
The following is out of place, but useful if declared immediately:
=SML
fun ‚undisch_rule· (thm : THM) : THM = (
let	val (a,b) = dest_ä(concl thm);
	val s1 = asm_rule a;
	val s2 = ä_elim thm s1
in
	(prof "undisch_rule";
	s2)
end
handle complaint =>
divert complaint "dest_ä" "undisch_rule" 7011 [fn () => string_of_thm thm]
);
=TEX
Something else out of sequence:
=SML
fun ‚disch_rule· (tm : TERM) (thm : THM) : THM = (
	if tm term_mem (hyps thm)
	then (let val s1 = ä_intro tm thm
		in
			(prof "disch_rule";
			s1)
		end
		handle complaint =>
		pass_on complaint "ä_intro" "disch_rule")
	else fail "disch_rule" 7031 [fn () => string_of_term tm]
);
=TEX
		
\subsection{Concerning $T$}
Proof of $T$ (as 12.3.9)
=SML
local
	val s1 = t_def;
	val s2 = eq_sym_rule s1;
	val s3 = refl_conv ªç x : BOOL é xº;
	val s4 = Ç_mp_rule s2 s3;
in
	val ‚t_thm· = save_thm("t_thm",s4)
end;
=TEX
We could work by a local theorem:
Û
Ö É x é x Ç (x Ç T)
Ê
but choose to work by the more primitive route of 12.3.12
=SML
fun ‚Ç_t_intro· (thm : THM) : THM = (
let	val t = concl thm;
	val s3 = list_simple_É_elim [t, mk_t] ä_antisym_axiom;
	val s5 = ä_intro t t_thm;
	val s5 = ä_elim s3 s5;
	val s8 = ä_intro mk_t thm;
	val s9 = ä_elim s5 s8;
in
	(prof "Ç_t_intro";
	s9)
end);
=TEX
In the following we could chose to try eliminating
all outermost $\ldots Ç T$ and $T Ç \ldots$.
D.I.Y. form:
=SML
fun ‚Ç_t_elim· (thm : THM) : THM = (
let	val s1 = eq_sym_rule thm;
	val s2 = Ç_mp_rule s1 t_thm;
in
	(prof "Ç_t_elim";
	s2)
end
handle complaint =>
list_divert complaint "Ç_t_elim" [
	("eq_sym_rule",7106,[fn () => string_of_thm thm]),
	("Ç_mp_rule",7106,[fn () => string_of_thm thm])]);
=TEX
D.I.Y. form:
=SML
fun ‚contr_rule· (tm : TERM) (thm : THM) : THM = (
let	val s1 = Ç_mp_rule f_def thm;
	val s2 = simple_É_elim tm s1;
in
	(prof "contr_rule";
	s2)
end
handle complaint =>
list_divert complaint "contr_rule" [
	("Ç_mp_rule", 7001, [fn () => string_of_thm thm]),
	("simple_É_elim",3031,[fn () => string_of_term tm])]
);
=TEX
The following is out of sequence, but necessary at this point:
we first prove theorem:
Û
Å_thm = Ö É t1 t2 é (t1 Å t2) = (É b é (t1 ä b) ä (t2 ä b) ä b)
Ê
=SML
local
	val s1 = ap_arg_rule ªt1 : BOOLº Å_def;
	val s2 = ap_arg_rule ªt2 : BOOLº s1;
	val s3 = conv_rule (MAP_C simple_%beta%_conv) s2;
	val s4 = simple_É_intro ªt2 : BOOLº s3;
	val s5 = simple_É_intro ªt1 : BOOLº s4;
in
	val ‚Å_thm· = save_thm("Å_thm",s5)
end;
=TEX
Then the out of place rule
(roughly as \cite{DS/FMU/IED/SML009} 5.14):
=SML
fun ‚Å_elim· (a_Å_b : THM) (a_thm : THM) (b_thm : THM) = (
let	val (a,b) = dest_Å(concl a_Å_b);
	val s1 = ä_intro a a_thm;
	val s2 = ä_intro b b_thm;
	val s3 = list_simple_É_elim [a, b] Å_thm;
	val s4 = Ç_mp_rule s3 a_Å_b;
	val s5 = simple_É_elim (concl a_thm) s4;
	val s6 = ä_elim s5 s1;
	val s7 = ä_elim s6 s2;
in
	(prof "Å_elim";
	s7)
end
handle complaint =>
list_divert complaint "Å_elim" [
	("dest_Å",7010,[fn () => string_of_thm a_Å_b]),
	("ä_elim",7083,[fn () => string_of_thm a_Å_b, 
		fn () => string_of_thm a_thm, fn () => string_of_thm b_thm])]
);
=TEX
Then another out of place theorem:
Û
å_thm = Ö É t é (å t) = (t ä F)
Ê
=SML
local
	val s1 = ap_arg_rule ªt : BOOLº å_def;
	val s2 = conv_rule (MAP_C simple_%beta%_conv) s1;
	val s3 = simple_É_intro ªt : BOOLº s2;
in
	val ‚å_thm· = save_thm("å_thm", s3)
end;
=TEX
Roughly as 5.17 of \cite{DS/FMU/IED/SML009}:
First prove the local theorem:
Û
É t é (å t ä F) ä t
Ê
=SML
local
	val s1 = asm_rule ª(t ä F) ä Fº;
	val s2 = asm_rule ªt Ç Fº;
	val s4 = subst_rule[(s2,ªt : BOOLº)] (concl s1) s1;
	val s5 = asm_rule mk_f;
	val s6 = ä_intro mk_f s5;
	val s7 = ä_elim s4 s6;
	val s8 = eq_sym_rule s2;
	val s9 = Ç_mp_rule s8 s7;
	val s10 = asm_rule ªt = Tº;
	val s11 = Ç_t_elim s10;
	val s13 = simple_É_elim ªt : BOOLº bool_cases_axiom;
	val s14 = Å_elim s13 s11 s9;
	val s15 = ä_intro ª(t ä F) ä Fº s14;
	val s16 = simple_É_elim ªt : BOOLº å_thm;
	val s17 = eq_sym_rule s16;
	val s18 = conv_rule (ONCE_MAP_C (fn x =>
		if x = ªt ä Fº then s17 else (fail_conv x))) s15;
	val s19 = simple_É_intro ªt : BOOLº s18;
in
=TEX
now the main function:
=SML
fun ‚c_contr_rule· (tm : TERM) (thm : THM) : THM = (
let	val mf_s1 = simple_É_elim tm s19;
	val å_tm = mk_å tm;
	val mf_s2 = disch_rule å_tm thm;
	val mf_s3 = ä_elim mf_s1 mf_s2
in
	(prof "c_contr_rule";
	mf_s3)
end
handle complaint =>
list_divert complaint "c_contr_rule" [
	("ä_elim", 7001, [fn () => string_of_thm thm]),
	("simple_É_elim", 3031, [fn () => string_of_term tm]),
	("disch_rule", 7003, [fn () => string_of_term tm])]
);
end;
=TEX
\subsection{Concerning Negation}
This is entirely new:
we first prove the local theorem:
Û
Ö É a é (å a) Ç (a ä É b é b)
Ê
=SML
local
	val s1 = conv_rule(ONCE_MAP_C(fn x =>
		if x = mk_f then f_def else fail_conv x))
		å_thm;
in
fun ‚å_elim· (tm : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let	val sideeffect = if type_of tm <> BOOL
		then term_fail "å_elim" 3031 [tm]
		else ();
in
(let
	val s2 = simple_É_elim (concl thm1) s1;
	val s3 = Ç_mp_rule s2 thm2;
	val s4 = ä_elim s3 thm1;
	val s5 = simple_É_elim tm s4
in
	(prof "å_elim";
	s5)
end
handle (Fail _) =>
let	val s2 = simple_É_elim (concl thm2) s1;
	val s3 = Ç_mp_rule s2 thm1;
	val s4 = ä_elim s3 thm2;
	val s5 = simple_É_elim tm s4
in
	(prof "å_elim";
	s5)
end
handle complaint =>
list_divert complaint "å_elim" [
	("Ç_mp_rule",7004,[fn () => string_of_thm thm1, fn () => string_of_thm thm2]),
	("ä_elim",7004,[fn () => string_of_thm thm1, fn () => string_of_thm thm2])
	]
)
end
);
end;
=TEX
	
This is entirely new:
we first prove:
Û
s13 = Ö É a b é (a ä b) ä (a ä åb) ä åa
Ê
=SML
local
	val s1 = asm_rule ªa ä bº;
	val s2 = undisch_rule s1;
	val s3 = asm_rule ªa ä å bº;
	val s4 = undisch_rule s3;
	val s5 = å_elim mk_f s2 s4;
	val s6 = ä_intro ªa : BOOLº s5;
	val s7 = simple_É_elim ªa : BOOLº å_thm;
	val s8 = eq_sym_rule s7;
	val s9 = conv_rule (ONCE_MAP_C (fn x =>
		if x = ªa ä Fº then s8 else (fail_conv x))) s6;
	val s10 = ä_intro ªa ä å bº s9;
	val s11 = ä_intro ªa ä bº s10;
	val s12 = simple_É_intro ªb : BOOLº s11;
	val s13 = simple_É_intro ªa : BOOLº s12;
in
=TEX
Main function:
=SML
fun ‚å_intro· (tm : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let	val mf_s1 = ä_intro tm thm1;
	val mf_s2 = ä_intro tm thm2;
in
((let
	val mf_s3 = list_simple_É_elim [tm, concl thm1] s13;
	val mf_s4 = ä_elim mf_s3 mf_s1;
	val mf_s5 = ä_elim mf_s4 mf_s2
in
	(prof "å_intro";
	mf_s5)
end)
handle (Fail _) => 
(let
	val mf_s3 = list_simple_É_elim [tm, concl thm2] s13;
	val mf_s4 = ä_elim mf_s3 mf_s2;
	val mf_s5 = ä_elim mf_s4 mf_s1
in
	(prof "å_intro";
	mf_s5)
end))
end
handle complaint =>
list_divert complaint "å_intro" [
	("ä_elim", 7004, [fn () => string_of_thm thm1, fn () => string_of_thm thm2]),
	("ä_intro", 3031, [fn () => string_of_term tm]),
	("simple_É_elim", 3031, [fn () => string_of_term tm])
	]
);
end;
=TEX
Prove the following (out of sequence)
Û
f_thm = Ö å F
Ê
=SML
local
	val s1 = asm_rule mk_f;
	val s2 = ä_intro mk_f s1;
	val s3 = simple_É_elim mk_f å_thm;
	val s4 = eq_sym_rule s3;
	val s5 = Ç_mp_rule s4 s2;
in
	val ‚f_thm· = save_thm("f_thm",s5)
end;
=TEX
Prove the following (out of sequence)
Û
å_t_thm = Ö å T Ç F
Ê
=SML
local
	val s1 = simple_É_elim ªå Tº bool_cases_axiom;
	val s2 = asm_rule ª(å T) Ç Fº;
	val s3 = asm_rule ªå T Ç Tº;
	val s4 = Ç_t_elim s3;
	val s5 = å_elim ªå T Ç Fº t_thm s4;
	val s6 = Å_elim s1 s5 s2;
in
	val ‚å_t_thm· = save_thm("å_t_thm",s6)
end;
=TEX
We prove the local theorems:
Û
s14 = Ö å(å t) Ç t
s16 = Ö t Ç å(å t)
Ê
=SML
local
	val s1 = Ç_t_intro f_thm;
	val s2 = ap_fun_rule ª$åº s1;
	val s3 = eq_trans_rule s2 å_t_thm;
	val s4 = ap_fun_rule ª$åº å_t_thm;
	val s5 = eq_trans_rule s4 s1;
	val s6 = asm_rule ªt Ç Tº;
	val s7 = eq_sym_rule s6;
	val s8 = subst_rule [(s7,ªx : BOOLº)] ªå(å x) Ç xº s5;
	val s9 = asm_rule ªt Ç Fº;
	val s10 = eq_sym_rule s9;
	val s11 = subst_rule [(s10,ªx : BOOLº)] ªå(å x) Ç xº s3;
	val s12 = simple_É_elim ªt : BOOLº bool_cases_axiom;
	val s13 = Å_elim s12 s8 s11;
	val s14 = simple_É_intro ªt : BOOLº s13;
	val s15 = eq_sym_rule s13;
	val s16 = simple_É_intro ªt : BOOLº s15;
in
=TEX
Main functions:
=SML
fun ‚å_å_intro· (thm : THM) : THM = (
let	val mf_s1 = simple_É_elim (concl thm) s16;
	val mf_s2 = Ç_mp_rule mf_s1 thm
in
	(prof "å_å_intro";
	mf_s2)
end);

fun ‚å_å_elim· (thm : THM) : THM = (
let	val bdy = dest_å(dest_å(concl thm));
	val mf_s1 = simple_É_elim bdy s14;
	val mf_s2 = Ç_mp_rule mf_s1 thm
in
	(prof "å_å_elim";
	mf_s2)
end
handle complaint =>
divert complaint "dest_å" "å_å_elim" 7006 [fn () => string_of_thm thm]
);
end; (* local *)
=TEX
\subsection{Concerning Ä}
Û
Ä_thm = Ö É t1 t2 é (t1 Ä t2) = (É b é (t1 ä t2 ä b) ä b)
Ê
=SML
local
	val s1 = ap_arg_rule ªt1 : BOOLº Ä_def;
	val s2 = ap_arg_rule ªt2 : BOOLº s1;
	val s3 = conv_rule (MAP_C simple_%beta%_conv) s2;
	val s4 = simple_É_intro ªt2 : BOOLº s3;
	val s5 = simple_É_intro ªt1 : BOOLº s4;
in
	val ‚Ä_thm· = save_thm("Ä_thm",s5)
end;
=TEX
Following \cite{DS/FMU/IED/SML009} 5.10:
We prove the local theorem:
Û
s14 = É t1 t2 é t1 ä t2 ä (t1 Ä t2)
Ê
=SML
local
	val s1 = asm_rule ªt1 ä t2 ä bº;
	val s3 = undisch_rule s1;
	val s5 = undisch_rule s3;
	val s6 = ä_intro ªt1 ä t2 ä bº s5;
	val s7 = simple_É_intro ªb : BOOLº s6;
	val s8 = list_simple_É_elim [ªt1 : BOOLº, ªt2 : BOOLº] Ä_thm;
	val s9 = eq_sym_rule s8;
	val s10 = Ç_mp_rule s9 s7;
	val s11 = ä_intro ªt2 : BOOLº s10;
	val s12 = ä_intro ªt1 : BOOLº s11;
	val s13 = simple_É_intro ªt2 : BOOLº s12;
	val s14 = simple_É_intro ªt1 : BOOLº s13;
in
fun ‚Ä_intro· (thm1 : THM) (thm2 : THM) : THM = (
let	val mf_s1 = list_simple_É_elim[concl thm1, concl thm2] s14;
	val mf_s2 = ä_elim mf_s1 thm1;
	val mf_s3 = ä_elim mf_s2 thm2;
in
	(prof "Ä_intro";
	mf_s3)
end);
end;
=TEX
We prove the local theorem:
Û
s11 = É t1 t2 é (t1 Ä t2) ä t1
Ê
=SML
local 
	val s1 = list_simple_É_elim [ªt1 : BOOLº, ªt2 : BOOLº] Ä_thm;
	val s2 = asm_rule ªt1 Ä t2º;
	val s3 = Ç_mp_rule s1 s2;
	val s4 = simple_É_elim ªt1 : BOOLº s3;
	val s5 = asm_rule ªt1 : BOOLº;
	val s6 = ä_intro ªt2 : BOOLº s5;
	val s7 = ä_intro ªt1 : BOOLº s6;
	val s8 = ä_elim s4 s7;
	val s9 = ä_intro ªt1 Ä t2º s8;
	val s10 = simple_É_intro ªt2 : BOOLº s9;
	val s11 = simple_É_intro ªt1 : BOOLº s10;
in
fun ‚Ä_left_elim· (thm :THM) : THM = (
let	val (t1,t2) = dest_Ä(concl thm);
	val mf_s1 = list_simple_É_elim [t1, t2] s11;
	val mf_s2 = ä_elim mf_s1 thm;
in
	(prof "Ä_left_elim";
	mf_s2)
end
handle complaint =>
divert complaint "dest_Ä" "Ä_left_elim" 7007 [fn () => string_of_thm thm]
);
end;
=TEX
We prove the local theorem:
Û
s11 = É t1 t2 é (t1 Ä t2) ä t2
Ê
=SML
local 
	val s1 = list_simple_É_elim [ªt1 : BOOLº, ªt2 : BOOLº] Ä_thm;
	val s2 = asm_rule ªt1 Ä t2º;
	val s3 = Ç_mp_rule s1 s2;
	val s4 = simple_É_elim ªt2 : BOOLº s3;
	val s5 = asm_rule ªt2 : BOOLº;
	val s6 = ä_intro ªt2 : BOOLº s5;
	val s7 = ä_intro ªt1 : BOOLº s6;
	val s8 = ä_elim s4 s7;
	val s9 = ä_intro ªt1 Ä t2º s8;
	val s10 = simple_É_intro ªt2 : BOOLº s9;
	val s11 = simple_É_intro ªt1 : BOOLº s10;
in
fun ‚Ä_right_elim· (thm :THM) : THM = (
let	val (t1,t2) = dest_Ä(concl thm);
	val mf_s1 = list_simple_É_elim [t1, t2] s11;
	val mf_s2 = ä_elim mf_s1 thm;
in
	(prof "Ä_right_elim";
	mf_s2)
end
handle complaint =>
divert complaint "dest_Ä" "Ä_right_elim" 7007 [fn () => string_of_thm thm]
);
end;
=TEX
=SML
fun ‚list_Ä_intro· ([] : THM list) : THM = (
	fail "list_Ä_intro" 7107 []
) | list_Ä_intro thm_lst = (
let	fun aux [thm] = thm
	| aux (thm :: rest) = Ä_intro thm (aux rest)
	| aux _ = error "list_Ä_intro" 0000 [];
	val s1 = aux thm_lst;
in
	(prof "list_Ä_intro";
	s1)
end);

=TEX
=SML
fun ‚strip_Ä_rule· (thm : THM) : THM list = (
let	fun aux thm1 = (
	let	val s1 = Ä_left_elim thm1;
		val s2 = Ä_right_elim thm1;
	in
		aux s1 @ aux s2
	end
	handle (Fail _) => [thm1]
	);
	val s1 = aux thm;
in
	(prof "strip_Ä_rule";
	s1)
end);
=TEX
\subsection{Concerning Å}
As \cite{DS/FMU/IED/SML009} 5.13.
We prove the local theorem:
Û
s12 Ö É t1 t2 é t1 ä (t1 Å t2)
Ê
=SML
local
	val s1 = asm_rule ªt1 ä bº;
	val s3 = undisch_rule s1;
	val s4 = ä_intro ªt2 ä bº s3;
	val s5 = ä_intro ªt1 ä bº s4;
	val s6 = simple_É_intro ªb :BOOLº s5;
	val s7 = list_simple_É_elim [ªt1 : BOOLº,ªt2 : BOOLº] Å_thm;
	val s8 = eq_sym_rule s7;
	val s9 = Ç_mp_rule s8 s6;
	val s10 = ä_intro ªt1 : BOOLº s9;
	val s11 = simple_É_intro ªt2 : BOOLº s10;
	val s12 = simple_É_intro ªt1 : BOOLº s11;
in
fun ‚Å_right_intro· (tm : TERM) (thm : THM) : THM = (
let	val mf_s1 = list_simple_É_elim [concl thm, tm] s12 ;
	val mf_s2 = ä_elim mf_s1 thm
in
	(prof "Å_right_intro";
	mf_s2)
end
handle complaint =>
divert complaint "list_simple_É_elim" "Å_right_intro" 3031 [fn () => string_of_term tm]
);
end;
=TEX
We prove the local theorem:
Û
s12 Ö É t1 t2 é t2 ä (t1 Å t2)
Ê
=SML
local
	val s1 = asm_rule ªt2 ä bº;
	val s3 = undisch_rule s1;
	val s4 = ä_intro ªt2 ä bº s3;
	val s5 = ä_intro ªt1 ä bº s4;
	val s6 = simple_É_intro ªb :BOOLº s5;
	val s7 = list_simple_É_elim [ªt1 : BOOLº,ªt2 : BOOLº] Å_thm;
	val s8 = eq_sym_rule s7;
	val s9 = Ç_mp_rule s8 s6;
	val s10 = ä_intro ªt2 : BOOLº s9;
	val s11 = simple_É_intro ªt2 : BOOLº s10;
	val s12 = simple_É_intro ªt1 : BOOLº s11;
in
fun ‚Å_left_intro· (tm : TERM) (thm : THM) : THM = (
let	val mf_s1 = list_simple_É_elim [tm, concl thm] s12 ;
	val mf_s2 = ä_elim mf_s1 thm
in
	(prof "Å_left_intro";
	mf_s2)
end
handle complaint =>
divert complaint "list_simple_É_elim" "Å_left_intro" 3031 [fn () => string_of_term tm]
);
end;
=TEX
Entirely new:
We prove the prove the local theorem:
Û
å_1_thm = Ö É t é (å t) Ç (t Ç F)
Ê
=SML
local
	val s1 = asm_rule mk_f;
	val s2 = contr_rule ªt : BOOLº s1;
	val s3 = ä_intro mk_f s2;
	val s4 = asm_rule ªt ä Fº;
	val s5 = list_simple_É_elim [ªt : BOOLº, mk_f] ä_antisym_axiom;
	val s6 = ä_elim s5 s4;
	val s7 = ä_elim s6 s3;
	val s8 = ä_intro ªt ä Fº s7;
	val s9 = simple_É_elim ªt : BOOLº å_thm;
	val s10 = eq_sym_rule s9;
	val s11 = subst_rule[(s10,ªx : BOOLº)] ªx ä (t Ç F)º s8;
	val s12 = asm_rule ªt Ç Fº;
	val s13 = eq_sym_rule s12;
	val s14 = subst_rule[(s13,ªx : BOOLº)]ªå xº f_thm;
	val s15 = ä_intro ªt Ç Fº s14;
	val s16 = list_simple_É_elim [ªå tº, ªt Ç Fº] ä_antisym_axiom;
	val s17 = ä_elim s16 s11;
	val s18 = ä_elim s17 s15;
	val s19 = simple_É_intro ªt : BOOLº s18;
in
val ‚å_1_thm· = save_thm("å_1_thm",s19);
end;
=TEX
We then locally prove:
Û
s10 Ö É t1 t2 é (t1 Å t2) ä (å t2) ä t1
s17 Ö É t1 t2 é (t1 Å t2) ä (å t1) ä t2
Ê
=SML
local
	val s1 = asm_rule ªt1 Å t2º;
	val s2 = asm_rule ªt1 : BOOLº;
	val s3 = asm_rule ªt2 : BOOLº;
	val s4 = asm_rule ªå t2º;
	val s5 = å_elim ªt1 : BOOLº s3 s4;
	val s6 = Å_elim s1 s2 s5;
	val s7 = ä_intro ªå t2º s6;
	val s8 = ä_intro ªt1 Å t2º s7;
	val s9 = simple_É_intro ªt2 : BOOLº s8;
	val s10 = simple_É_intro ªt1 : BOOLº s9;

	val s11 = asm_rule ªå t1º;
	val s12 = å_elim ªt2 : BOOLº s2 s11;
	val s13 = Å_elim s1 s12 s3;
	val s14 = ä_intro ªå t1º s13;
	val s15 = ä_intro ªt1 Å t2º s14;
	val s16 = simple_É_intro ªt2 : BOOLº s15;
	val s17 = simple_É_intro ªt1 : BOOLº s16;
in
fun ‚Å_cancel_rule· (thm1 : THM) (thm2 : THM) : THM = (
let	val (t1,t2) = dest_Å (concl thm1);
in
(let
	val mf_s1 = list_simple_É_elim [t1,t2] s10;
	val mf_s2 = ä_elim mf_s1 thm1;
	val mf_s2 = ä_elim mf_s2 thm2;
in
	(prof "Å_cancel_rule";
	mf_s2)
end
handle Fail _ =>
let	val mf_s1 = list_simple_É_elim [t1,t2] s17;
	val mf_s2 = ä_elim mf_s1 thm1;
	val mf_s2 = ä_elim mf_s2 thm2;
in
	(prof "Å_cancel_rule";
	mf_s2)
end)
end
handle complaint =>
list_divert complaint "Å_cancel_rule" [
	("dest_Å",7010,[fn () => string_of_thm thm1]),
	("ä_elim",7050,[fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
end;
=TEX
\subsection{Concerning ä}
Can only do $ä\_match\_mp\_rule$ after we have $É\_elim$.
=SML
fun ‚strip_ä_rule· (thm : THM) : THM = (
let	val (p, q) = dest_ä (concl thm);
	val s1 = asm_rule p;
	val s2 = ä_elim thm s1;
in
	strip_ä_rule s2
end
handle (Fail _) => thm
);
=TEX
=SML
fun ‚all_ä_intro· (thm : THM) : THM = (
let	
	val hs = hyps thm;
	val s1 = fold (uncurry ä_intro) hs thm;
in
	(prof "all_ä_intro";
	s1)
end);
=TEX
Local theorem:
Û
s10 Ö É t1 t2 t3 é (t1 ä t2) ä (t2 ä t3) ä (t1 ä t3)
Ê
=SML
local
	val s1 = asm_rule ªt1 ä t2º;
	val s2 = asm_rule ªt2 ä t3º;
	val s3 = undisch_rule s1;
	val s4 = ä_elim s2 s3;
	val s5 = ä_intro ªt1 : BOOLº s4;
	val s6 = ä_intro ªt2 ä t3º s5;
	val s7 = ä_intro ªt1 ä t2º s6;
	val s8 = simple_É_intro ªt3 : BOOLº s7;
	val s9 = simple_É_intro ªt2 : BOOLº s8;
	val s10 = simple_É_intro ªt1 : BOOLº s9;
in
fun ‚ä_trans_rule· (thm1 : THM) (thm2 : THM) : THM = (
let	val (t1,t2) = dest_ä(concl thm1)
		handle complaint =>
		divert complaint "dest_ä" "ä_trans_rule" 7040
			[fn () => string_of_thm thm1];
	val (t2',t3) = dest_ä(concl thm2)
		handle complaint =>
		divert complaint "dest_ä" "ä_trans_rule" 7040
			[fn () => string_of_thm thm2];
	val mf_s1 = list_simple_É_elim[t1, t2, t3] s10;
	val mf_s2 = ä_elim mf_s1 thm1;
	val mf_s3 = ä_elim mf_s2 thm2
		handle complaint =>
		divert complaint "ä_elim" "ä_trans_rule" 7042
			[fn () => string_of_thm thm1, fn () => string_of_thm thm2];
in
	(prof "ä_trans_rule";
	mf_s3)
end);
end;
=TEX
Û
s13 Ö É t1 t2 é (t1 ä t2) ä (å t2) ä (å t1)
Ê
=SML
local
	val s1 = asm_rule ªt1 : BOOLº;
	val s2 = asm_rule ªt1 ä t2º;
	val s3 = ä_elim s2 s1;
	val s4 = asm_rule ªå t2º;
	val s5 = å_elim mk_f s3 s4;
	val s6 = ä_intro ªt1 : BOOLº s5;
	val s7 = simple_É_elim ªt1 : BOOLº å_thm;
	val s8 = eq_sym_rule s7;
	val s9 = Ç_mp_rule s8 s6;
	val s10 = ä_intro ªå t2º s9;
	val s11 = ä_intro ªt1 ä t2º s10;
	val s12 = simple_É_intro ªt2 : BOOLº s11;
	val s13 = simple_É_intro ªt1 : BOOLº s12;
in
fun ‚modus_tollens_rule· (thm1 : THM) (thm2 : THM) : THM = (
let	val (t1,t2) = dest_ä(concl thm1);
	val mf_s1 = list_simple_É_elim[t1,t2] s13;
	val mf_s2 = ä_elim mf_s1 thm1;
	val mf_s3 = ä_elim mf_s2 thm2;
in
	(prof "modus_tollens_rule";
	mf_s3)
end
handle complaint =>
list_divert complaint "modus_tollens_rule" [
	("dest_ä",7040,[fn () => string_of_thm thm1]),
	("ä_elim",7051,[fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
end;
=TEX
\subsection{Concerning Ç}
=SML
fun ‚Ç_intro· (thm1 : THM) (thm2 : THM) : THM = (
let	val (t1,t2) = dest_ä (concl thm1)
		handle complaint =>
		divert complaint "dest_ä" "Ç_intro" 7040 [fn () => string_of_thm thm1];
	val (t2',t1') = dest_ä (concl thm2) (* dummy test *)
		handle complaint =>
		divert complaint "dest_ä" "Ç_intro" 7040 [fn () => string_of_thm thm2];
	val s1 = list_simple_É_elim[t1,t2] ä_antisym_axiom;
	val s2 = ä_elim s1 thm1;
	val s3 = ä_elim s2 thm2
		handle complaint =>
		divert complaint "ä_elim" "Ç_intro" 7064 
		[fn () => string_of_thm thm1, fn () => string_of_thm thm2];
in
	(prof "Ç_intro";
	s3)
end);
=TEX
We prove the local theorems (two of them because getting
the two conjuncts if we did one would take similar, if not greater effort)
Û
s8 Ö (t1 Ç t2) ä (t1 ä t2)
s14 Ö (t1 Ç t2) ä (t2 ä t1)
Ê
=SML
local
	val s1 = asm_rule ªt1 Ç t2º;
	val s2 = asm_rule ªt1 : BOOLº;
	val s3 = asm_rule ªt2 : BOOLº;
	val s4 = Ç_mp_rule s1 s2;
	val s5 = ä_intro ªt1 : BOOLº s4;
	val s6 = ä_intro ªt1 Ç t2º s5;
	val s7 = simple_É_introªt2 : BOOLº s6;
	val s8 = simple_É_introªt1 : BOOLº s7;
	
	val s9 = eq_sym_rule s1;
	val s10 = Ç_mp_rule s9 s3;
	val s11 = ä_intro ªt2 : BOOLº s10;
	val s12 = ä_intro ªt1 Ç t2º s11;
	val s13 = simple_É_introªt2 : BOOLº s12;
	val s14 = simple_É_introªt1 : BOOLº s13;
in
fun ‚Ç_elim· (thm : THM) : (THM * THM) = (
let	val (t1,t2) = dest_Ç(concl thm);
	val mf_s1 = list_simple_É_elim[t1,t2]s8;
	val mf_s2 = ä_elim mf_s1 thm;
	val mf_s3 = list_simple_É_elim[t1,t2]s14;
	val mf_s4 = ä_elim mf_s3 thm;
in
	(prof "Ç_elim";
	(mf_s2, mf_s4))
end
handle complaint =>
divert complaint "dest_Ç" "Ç_elim" 7062 [fn () => string_of_thm thm]
);
end;
=TEX
\subsection{Concerning =}
=SML
fun ‚subst_conv· (thm_lst : (THM * TERM) list) : (TERM -> CONV) = (
let		val s1 = subst_rule thm_lst
			handle complaint =>
			pass_on complaint "subst_rule" "subst_conv";
in
	(fn (template : TERM) =>
	(fn (tm:TERM) =>
	let
		val new_template = mk_eq(tm,template)
			handle complaint =>
			divert complaint "mk_eq" "subst_conv" 3012 
			[fn () => string_of_term tm, fn () => string_of_term template];
		val s2 = refl_conv tm;
		val s3 = s1 new_template s2					handle complaint =>
			pass_on complaint "subst_rule" "subst_conv";
	in
		(prof "subst_conv";
		s3)
	end))
end);
=TEX

We prove a local theorem:
Û
s9 Ö É t1 t2 é (t1 = t2) Ç (t2 = t1)
Ê
=SML
local
	val s1 = asm_rule ª(t1 : 'a) = t2º;
	val s2 = eq_sym_rule s1;
	val s3 = ä_intro ª(t1 : 'a) = t2º s2;
	val s4 = asm_rule ª(t2 : 'a) = t1º;
	val s5 = eq_sym_rule s4;
	val s6 = ä_intro ª(t2 : 'a) = t1º s5;
	val s7 = Ç_intro s3 s6;
	val s8 = simple_É_intro ªt2 : 'aº s7;
	val s9 = simple_É_intro ªt1 : 'aº s8;
in
val ‚eq_sym_conv· : CONV = (fn (tm:TERM) =>
let	val (t1,t2) = dest_eq tm;
	val mf_s1 = inst_type_rule[(type_of t1,mk_vartype"'a")] s9;
	val mf_s2 = list_simple_É_elim[t1,t2] mf_s1;
in
	(prof "eq_sym_conv";
	mf_s2)
end
handle complaint =>
pass_on complaint "dest_eq" "eq_sym_conv"
);
end;
=TEX
We prove a local theorem:
Û
s Ö É t1 t2 :'a é å(t1 = t2) Ç å(t2 = t1)
Ê
=SML
local
	val s1 = eq_sym_conv ª(t1 : 'a) = t2º;
	val s2 = ap_fun_rule ª$åº s1;
	val s3 = simple_É_intro ªt2 : 'aº s2;
	val s4 = simple_É_intro ªt1 : 'aº s3;
in
fun ‚å_eq_sym_rule· (thm : THM) : THM = (
let	val (t1,t2) = dest_eq(dest_å(concl thm));
	val mf_s1 = inst_type_rule[(type_of t1,mk_vartype "'a")] s4;
	val mf_s2 = list_simple_É_elim [t1,t2] mf_s1;
	val mf_s3 = Ç_mp_rule mf_s2 thm;
in
	(prof "å_eq_sym_rule";
	mf_s3)
end
handle complaint =>
list_divert complaint "å_eq_sym_rule" [
	("dest_eq",7091,[fn () => string_of_thm thm]),
	("dest_å",7091,[fn () => string_of_thm thm])]
);
end;
=TEX

\subsection{Concerning É}
=RULE
list_simple_É_intro
[ªx1º, ..., ªxnº]
…
ˆ Ö t[x1, ..., xn]
…
ˆ Ö É x1 ... xn é t[x1, ..., xn]
=TEX
=SML
fun ‚list_simple_É_intro· (tml : TERM list) (thm :THM) : THM = (
	fold (uncurry simple_É_intro) tml thm
	handle complaint =>
	pass_on complaint "simple_É_intro" "list_simple_É_intro"
);
=TEX
=SML
fun ‚all_É_intro· (thm : THM) : THM = (
let	val cfrees = rev(frees(concl thm));
	val afrees = list_cup (map frees (hyps thm));
	val nfrees = cfrees diff afrees;
	val s1 = list_simple_É_intro nfrees thm;
in
	(prof "all_É_intro";
	s1)
end);
=TEX
=SML
fun ‚all_simple_É_elim· (thm : THM) : THM = (
let	val c = concl thm;
	val cfrees = frees c;
	val all_frees = cfrees cup (list_cup (map frees (hyps thm)));
	val qvs = fst(strip_É c);
	val qvs' = list_variant all_frees qvs;
	val s1 = list_simple_É_elim qvs' thm;
in
	(prof "all_simple_É_elim";
	s1)
end);
=TEX
\subsection{Concerning á}
=SML
fun ‚á_intro_rule· (thm : THM) : THM = (
let	val (tm1, tm2) = dest_app (concl thm);
	val s1 = inst_type_rule [(type_of tm2, mk_vartype "'a")] á_axiom;
	val s2 = simple_É_elim tm1 s1;
	val s3 = simple_É_elim tm2 s2;
	val s4 = ä_elim s3 thm;
in
	(prof "á_intro_rule";
	s4)
end
handle complaint =>
divert complaint "dest_app" "á_intro_rule" 7016 [fn () => string_of_thm thm]
);
=TEX

=SML
fun ‚á_elim_rule· (tm : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let	val sideeffect = dest_var tm
		handle complaint =>
		pass_on complaint "dest_var" "á_elim_rule";
	val sideeffect = if tm mem (frees (concl thm2))
		then fail "á_elim_rule" 7120 [
			fn () => string_of_term tm,
			fn () => string_of_thm thm2]
		else ();
	val (tm1, ctm1) = dest_app (concl thm1);
	val sideeffect = if tm mem (frees tm1)
		then fail "á_elim_rule" 7122 [
			fn () => string_of_term tm,
			fn () => string_of_thm thm1]
		else ();
	val tm1tm = mk_app (tm1, tm);
	val s1 = disch_rule tm1tm thm2;
	val s2 = simple_É_intro tm s1
		handle complaint =>
		if area_of complaint = "simple_É_intro"
		then fail "á_elim_rule" 7121 [
			fn () => string_of_term tm,
			fn () => string_of_thm thm2,
			fn () => string_of_term tm1tm]
		else reraise complaint (area_of complaint);
	val s3 = simple_É_elim ctm1 s2;
	val s4 = ä_elim s3 thm1;
in
	(prof "á_elim_rule";
	s4)
end
handle complaint =>
list_divert complaint "á_elim_rule" [
	("dest_app",7019,[fn () => string_of_thm thm1]),
	("mk_app",7054,[fn () => string_of_term tm]),
	("disch_rule",7108,[fn () => fst(dest_var tm)])
	]
);
=TEX
\subsection{Concerning Ñ}
=SML
fun ‚simple_Ñ_intro· (tm : TERM) (thm : THM) : THM = (
let	val (x, t1x) = dest_simple_Ñ tm
		handle complaint =>
		pass_on complaint "dest_simple_Ñ" "simple_Ñ_intro";
	val abs = snd(dest_app tm);
	val t2 = (case term_match (concl thm) t1x of
		(_, [(ltm, _)]) => ltm
		|(_, []) => x
		|Other => fail "simple_Ñ_intro" 7047 [
			fn () => string_of_term tm,
			fn () => string_of_thm thm])
		handle complaint =>
		divert complaint "term_match" "simple_Ñ_intro" 7047 [
			fn () => string_of_term tm,
			fn () => string_of_thm thm];
	val abst2 = mk_app (abs, t2);
	val s1 = simple_%beta%_conv abst2;
	val s2 = eq_sym_rule s1;
	val s3 = Ç_mp_rule s2 thm;
	val s4 = á_intro_rule s3;
	val s5 = inst_type_rule [(type_of x, mk_vartype "'a")] Ñ_def;
	val s6 = ap_arg_rule abs s5;
	val s7 = simple_%beta%_conv (snd(dest_eq(concl s6)));
	val s8 = eq_trans_rule s6 s7;
	val s9 = eq_sym_rule s8;
	val s10 = Ç_mp_rule s9 s4;
in
	(prof "simple_Ñ_intro";
	s10)
end);
=TEX

=SML
fun ‚simple_Ñ_elim· (v : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let	val sideeffect = if is_var v
		then ()
		else term_fail "simple_Ñ_elim" 3007 [v];
	val cthm1 = concl thm1;
	val (x, tx) = dest_simple_Ñ cthm1;
	val t1 = snd(dest_app cthm1);
	val t1v = mk_app (t1, v);
	val tvx = (case gen_vars [BOOL] ([(concl thm1), (concl thm2), v] 
		@ hyps thm1 @ hyps thm2) of
		[term] => term
		| _ => error "simple_Ñ_elim" 6032 [])
		handle complaint =>
		pass_on complaint "gen_vars" "simple_Ñ_elim";
	val s1 = inst_type_rule [(type_of x, mk_vartype "'a")] Ñ_def;
	val s2 = ap_arg_rule t1 s1;
	val s3 = Ç_mp_rule s2 thm1;
	val s5 = conv_rule simple_%beta%_conv s3;
	val s6 = simple_%beta%_conv t1v;
	val s7 = eq_sym_rule s6;
	val asm = fst(dest_eq(concl s7))
	val s8 = ä_intro asm thm2;
	val s9 = mk_ä (tvx, concl thm2);
	val s10 = subst_rule [(s7, tvx)] s9 s8;
	val s11 = undisch_rule s10;
	val s12 = (á_elim_rule v s5 s11)
		handle complaint =>
		if area_of complaint <> "á_elim_rule"
		then reraise complaint (area_of complaint)
		else if v mem frees cthm1
		then fail "simple_Ñ_elim" 7120 [
			fn () => string_of_term v,
			fn () => string_of_thm thm1]
		else if v mem frees (concl thm2)
		then fail "simple_Ñ_elim" 7120 [
			fn () => string_of_term v,
			fn () => string_of_thm thm2]
		else fail "simple_Ñ_elim" 7121 [
			fn () => string_of_term v,
			fn () => string_of_thm thm2,
			fn () => string_of_term asm];
in
	(prof "simple_Ñ_elim";
	s12)
end
handle complaint =>
list_divert complaint "simple_Ñ_elim" [
	("dest_simple_Ñ",7109,[fn () => string_of_thm thm1]),
	("mk_app",7014,[fn () => string_of_term v])
	]
);
=TEX

=SML
val ‚simple_Ñ_á_conv· : CONV = (fn (tm:TERM) =>
let	val (x, tx) = (dest_simple_Ñ tm)
		handle complaint =>
		pass_on complaint "dest_simple_Ñ" "simple_Ñ_á_conv";
	val t1 = mk_simple_ç (x, tx);
	val s1 = inst_type_rule [(type_of x, mk_vartype "'a")] Ñ_def;
	
	val s2 = ap_arg_rule t1 s1;
	val s3 = concl s2;
	val conv1 = (RAND_C simple_%beta%_conv THEN_C
			RAND_C simple_%beta%_conv)
	val s4 = conv1 s3;
	val s5 = Ç_mp_rule s4 s2;
in
	(prof "simple_Ñ_á_conv";
	s5)
end);
=TEX

=SML
fun ‚simple_Ñ_á_rule· (thm : THM) : THM = (
let	val s1 = conv_rule simple_Ñ_á_conv thm
in
	(prof "simple_Ñ_á_rule";
	s1)
end
	handle complaint =>
	divert complaint "simple_Ñ_á_conv" "simple_Ñ_á_rule" 7092 [fn () => string_of_thm thm]
);
=TEX

See section~\ref{SplitStructure} for an explanation of the
structure declarations in the next piece of Standard~ML.

=SML
end; (* of structure DerivedRules1 *)

structure ‚DerivedRules1· : DerivedRules1 = struct

open DerivedRules1;
=TEX

\subsection{Concerning $if\ldots then\ldots else \ldots$}
=SML
local
	val s1 = ap_arg_rule ªa : BOOLº cond_def;
	val s2 = ap_arg_rule ªt1 : 'aº s1;
	val s3 = ap_arg_rule ªt2 : 'aº s2;
	val s4 = conv_rule (MAP_C simple_%beta%_conv) s3;
	val s5 = simple_É_intro ªt2 : 'aº s4;
	val s6 = simple_É_intro ªt1 : 'aº s5;
	val s7 = simple_É_intro ªa : BOOLº s6;

in
	val ‚cond_thm· = save_thm("cond_thm", s7);
end;
=TEX
A local function:
=RULE
if_intro_rule
ªaº
…
ˆ1, a Ö x = tt ; ˆ2, åa' Ö x = et
…
ˆ1 ° ˆ2 Ö x = if a then tt else et
=TEX
Û
s35 Ö É x a t1 t2 é (a ä (x = t1)) ä (å a ä (x = t2)) ä 
	(x = if a then t1 else t2)
Ê
=SML
local
	val s1 = asm_rule ªa ä ((x:'a) = t1)º;
	val s2 = asm_rule ªa Ç Tº;
	val s3 = Ç_t_elim s2;
	val s4 = ä_elim s1 s3;
	val s5 = ä_intro ªa Ç Tº s4;
	val s6 = asm_rule ªå a ä ((x:'a) = t2)º;
	val s7 = asm_rule ªa Ç Fº;
	val s8 = simple_É_elim ªa : BOOLº å_1_thm;
	val s9 = eq_sym_rule s8;
	val s10 = Ç_mp_rule s9 s7;
	val s11 = ä_elim s6 s10;
	val s12 = ä_intro ªa Ç Fº s11;
	val s13 = Ä_intro s5 s12;
	val s14 = simple_%beta%_conv 
		(mk_app(
		(mk_simple_ç(ªx : 'aº, concl s13),
		ªx : 'aº)));
	val s15 = eq_sym_rule s14;
	val s16 = Ç_mp_rule s15 s13;
	val s17 = á_intro_rule s16;
	val s18 = list_simple_É_elim[ªa : BOOLº, ªt1 : 'aº, ªt2 : 'aº] cond_thm;
	val s19 = eq_sym_rule s18;
	val s20 = subst_rule[(s19,ªy : 'aº)]
		(mk_app(fst(dest_app(concl s17)),ªy : 'aº))
		s17;
	val s21 = conv_rule simple_%beta%_conv s20;

	val s22 = Ä_left_elim s21;
	val s23 = undisch_rule s22;
	val s24 = eq_sym_rule s4;
	val s25 = subst_rule[(s24,ªy : 'aº)]
		(mk_app(fst(dest_app(concl s23)),ªy : 'aº))
		s23;
	
	val s26 = Ä_right_elim s21;
	val s27 = undisch_rule s26;
	val s28 = eq_sym_rule s11;
	val s29 = subst_rule[(s28,ªy : 'aº)]
		(mk_app(fst(dest_app(concl s27)),ªy : 'aº))
		s27;

	val s30 = simple_É_elim ªa : BOOLº bool_cases_axiom;
	val s31 = Å_elim s30 s25 s29;
	val s32 = eq_sym_rule s31;
	val s33 = ä_intro ªå a ä ((x:'a) = t2)º s32;
	val s34 = ä_intro ªa ä ((x:'a) = t1)º s33;
	val s35 = list_simple_É_intro[ªx : 'aº, ªa : BOOLº, ªt1 : 'aº, ªt2 : 'aº] s34;
in
fun ‚if_intro_rule· (a : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let	val (x,t1) = dest_eq(concl thm1)
		handle complaint =>
		divert complaint "dest_eq" "if_intro_rule" 6020 
			[fn () => string_of_thm thm1];
	val (x',t2) = dest_eq(concl thm2)
		handle complaint =>
		divert complaint "dest_eq" "if_intro_rule" 6020 
			[fn () => string_of_thm thm2];
	val mf_s1 = ä_intro a thm1
		handle complaint =>
		divert complaint "ä_intro" "if_intro_rule" 3031 
			[fn () => string_of_term a];
	val mf_s2 = ä_intro (mk_å a) thm2;
	val mf_s3 = inst_type_rule[(type_of x,mk_vartype"'a")]
		s35;
	val mf_s4 = list_simple_É_elim[x,a,t1,t2]mf_s3;
	val mf_s5 = ä_elim mf_s4 mf_s1;
	val mf_s6 = ä_elim mf_s5 mf_s2;
in
	(prof "if_intro_rule";
	mf_s6)
end);
end; (* of local val s1 ... *)
=TEX
=RULE
if_then_elim_rule
…
ˆ Ö x = if tc then tt else te
…
ˆ Ö tc ä x = tt
=TEX
Prove the local theorem:
Û
s28 Ö É x a t1 t2 é (x = if a then t1 else t2) ä (a ä x = t1)
Ê
=SML
local
	val s1 = asm_rule ªa : BOOLº;
	val s2 = asm_rule ªa Ç Fº;
	val s3 = simple_É_elim ªa : BOOLº å_1_thm;
	val s4 = eq_sym_rule s3;
	val s5 = Ç_mp_rule s4 s2;
	val s6 = å_elim ª(t1 : 'a) = t2º s1 s5;
	val s7 = ä_intro ªa Ç Fº s6;
	val s8 = refl_conv ªt1 : 'aº;
	val s9 = ä_intro ªa Ç Tº s8;
	val s10 = Ä_intro s9 s7;

	val s11 = simple_%beta%_conv 
		ª(ç y: 'a é ((a Ç T) ä y = t1) Ä ((a Ç F) ä y = t2)) t1º;
	val s12 = eq_sym_rule s11;
	val s13 = Ç_mp_rule s12 s10;
	val s14 = á_intro_rule s13;
	val s15 = list_simple_É_elim [ªa : BOOLº, ªt1 : 'aº, ªt2 : 'aº] cond_thm;
	val s16 = eq_sym_rule s15;
	val s17 = subst_rule[(s16,ªz : 'aº)]
		(mk_app(fst(dest_app(concl s14)),ªz : 'aº))
		s14;
	val s18 = asm_rule ª(x:'a) = if a then t1 else t2º;
	val s19 = eq_sym_rule s18;
	val s20 = subst_rule[(s19,ªz : 'aº)]
		(mk_app(fst(dest_app(concl s17)),ªz : 'aº))
		s17;
	val s21 = conv_rule simple_%beta%_conv s20;
	val s22 = Ä_left_elim s21;
	val s23 = Ç_t_intro s1;
	val s25 = ä_elim s22 s23;
	val s26 = ä_intro ªa : BOOLº s25;
	val s27 = ä_intro ª(x:'a) = if a then t1 else t2º s26;
	val s28 = list_simple_É_intro[ªx : 'aº, ªa : BOOLº, ªt1 : 'aº, ªt2 : 'aº] s27;
in
fun ‚if_then_elim_rule· (thm : THM) = (
let	val (x,ifa)= dest_eq(concl thm)
		handle complaint =>
		pass_on complaint "dest_eq" "if_then_elim_rule";
	val (a,t1,t2) = dest_if ifa
		handle complaint =>
		pass_on complaint "dest_if" "if_then_elim_rule";
	val mf_s1 = inst_type_rule[(type_of x,mk_vartype "'a")] s28;
	val mf_s2 = list_simple_É_elim[x,a,t1,t2] mf_s1;
	val mf_s3 = ä_elim mf_s2 thm;
in
	(prof "if_then_elim_rule";
	mf_s3)
end);
end; (* of local val s1 = ... *)
=TEX
=RULE
if_else_elim_rule
…
ˆ Ö x = if tc then tt else te
…
ˆ Ö å tc ä x = te
=TEX
Û
s29 Ö É x a t1 t2 é x = (if a then t1 else t2) ä å a ä x = t2
Ê
=SML
local
	val s1 = asm_rule ªå a º;
	val s2 = asm_rule ªa Ç Tº;
	val s4 = Ç_t_elim s2;
	val s6 = å_elim ª(t2 : 'a) = t1º s4 s1;
	val s7 = ä_intro ªa Ç Tº s6;
	val s8 = refl_conv ªt2 : 'aº;
	val s9 = ä_intro ªa Ç Fº s8;
	val s10 = Ä_intro s7 s9;

	val s11 = simple_%beta%_conv 
		ª(ç y: 'a é ((a Ç T) ä y = t1) Ä ((a Ç F) ä y = t2)) t2º;
	val s12 = eq_sym_rule s11;
	val s13 = Ç_mp_rule s12 s10;
	val s14 = á_intro_rule s13;
	val s15 = list_simple_É_elim [ªa : BOOLº, ªt1 : 'aº, ªt2 : 'aº] cond_thm;
	val s16 = eq_sym_rule s15;
	val s17 = subst_rule[(s16,ªz : 'aº)]
		(mk_app(fst(dest_app(concl s14)),ªz : 'aº))
		s14;
	val s18 = asm_rule ª(x:'a) = if a then t1 else t2º;
	val s19 = eq_sym_rule s18;
	val s20 = subst_rule[(s19,ªz : 'aº)]
		(mk_app(fst(dest_app(concl s17)),ªz : 'aº))
		s17;
	val s21 = conv_rule simple_%beta%_conv s20;
	val s22 = Ä_right_elim s21;
	val s23 = simple_É_elim ªa : BOOLº å_1_thm;
	val s24 = fst(Ç_elim s23);
	val s25 = ä_trans_rule s24 s22;
	val s26 = ä_elim s25 s1;
	val s27 = ä_intro ªå aº s26;
	val s28 = ä_intro ª(x:'a) = if a then t1 else t2º s27;
	val s29 = list_simple_É_intro[ªx : 'aº, ªa : BOOLº, ªt1 : 'aº, ªt2 : 'aº] s28;
in
fun ‚if_else_elim_rule· (thm : THM) = (
let	val (x,ifa)= dest_eq(concl thm)
		handle complaint =>
		pass_on complaint "dest_eq" "if_else_elim_rule";
	val (a,t1,t2) = dest_if ifa
		handle complaint =>
		pass_on complaint "dest_if" "if_else_elim_rule";
	val mf_s1 = inst_type_rule[(type_of x,mk_vartype "'a")] s29;
	val mf_s2 = list_simple_É_elim[x,a,t1,t2] mf_s1;
	val mf_s3 = ä_elim mf_s2 thm;
in
	(prof "if_else_elim_rule";
	mf_s3)
end);
end; (* of local val s1 = ... *)
=TEX
Û
s9 Ö É f a t1 t2 é f(if a then t1 else t2) =
	if a then (f t1) else (f t2)
s11 Ö É f a t1 t2 é if a then (f t1) else (f t2) =
	f(if a then t1 else t2)
Ê
=SML
local
	val s1 = refl_conv ªif a then (t1:'a) else t2º;
	val s2 = if_then_elim_rule s1;
	val s3 = undisch_rule s2;
	val s4 = ap_fun_rule ªf : 'a ã 'bº s3;
	val s5 = if_else_elim_rule s1;
	val s6 = undisch_rule s5;
	val s7 = ap_fun_rule ªf : 'a ã 'bº s6;
	val s8 = if_intro_rule ªa : BOOLº s4 s7;
	val s9 = list_simple_É_intro[ªf : 'a ã 'bº, ªa : BOOLº, ªt1 : 'aº, ªt2 : 'aº] s8;
	val s10 = eq_sym_rule s8;
	val s11 = list_simple_É_intro[ªf : 'a ã 'bº, ªa : BOOLº, ªt1 : 'aº, ªt2 : 'aº] s10;
in
val ‚fun_if_conv· : CONV = (fn (tm:TERM) =>
let	val (f,ifa) = dest_app tm;
	val (a,t1,t2) = dest_if ifa;
	val (aty,bty) = dest_ã_type(type_of f);
	val mf_s1 = inst_type_rule[(aty,mk_vartype"'a"),(bty,mk_vartype"'b")]s9;
	val mf_s2 = list_simple_É_elim[f,a,t1,t2] mf_s1;
in
	(prof "fun_if_conv";
	mf_s2)
end
handle complaint =>
list_divert complaint "fun_if_conv" [
	("dest_app",7098,[fn () => string_of_term tm]),
	("dest_if",7098,[fn () => string_of_term tm])]
);
val ‚if_fun_conv· : CONV = (fn (tm:TERM) =>
let	val (a,ft1,ft2) = dest_if tm;
	val (f,t1) = dest_app ft1;
	val (f',t2) = dest_app ft2;
	val (aty,bty) = dest_ã_type(type_of f);
	val mf_s1 = inst_type_rule[(aty,mk_vartype"'a"),(bty,mk_vartype"'b")]s11;
	val mf_s2 = list_simple_É_elim[f,a,t1,t2] mf_s1;
	val mf_s3 = refl_conv tm;
	val mf_s4 = eq_trans_rule mf_s3 mf_s2;
in
	(prof "if_fun_conv";
	mf_s4)
end
handle complaint =>
list_divert complaint "if_fun_conv" [
	("dest_app",7037,[fn () => string_of_term tm]),
	("dest_if",7037,[fn () => string_of_term tm]),
	("eq_trans_rule",7038,[fn () => string_of_term tm])]
);
end; (* local val s1 = ... *)
=TEX
We prove the local theorem:
Û
s12 Ö É a t1 t2 é (a ä t1) ä (å a ä t2) ä 
	(if a then t1 else t2)
Ê
=SML
local
	val s1 = asm_rule ªa ä t1º;
	val s2 = undisch_rule s1;
	val s3 = Ç_t_intro s2;
	val s4 = eq_sym_rule s3;

	val s5 = asm_rule ªå a ä t2º;
	val s6 = undisch_rule s5;
	val s7 = Ç_t_intro s6;
	val s8 = eq_sym_rule s7;

	val s9 = if_intro_rule ªa:BOOLº s4 s8;
	val s10 = eq_sym_rule s9;
	val s11 = Ç_t_elim s10;
	val s12 = ä_intro ªå a ä t2º s11;
	val s13 = ä_intro ªa ä t1º s12;
	val s14= list_simple_É_intro[ªa : BOOLº, ªt1 : BOOLº, ªt2 : BOOLº] s13;
in
fun ‚if_intro· (a : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let	val mf_s1 = ä_intro a thm1
		handle complaint =>
		divert complaint "ä_intro" "if_intro" 3031 [fn () => string_of_term a];
	val mf_s2 = ä_intro (mk_å a) thm2;
	val mf_s3 = list_simple_É_elim[a,concl thm1, concl thm2]s14
		handle complaint =>
		divert complaint "list_simple_É_elim" "if_intro" 3031
			[fn () => string_of_term a];
	val mf_s4 = ä_elim mf_s3 mf_s1;
	val mf_s5 = ä_elim mf_s4 mf_s2;
in
	(prof "if_intro";
	mf_s5)
end);
end; (* of local val s1 ... *)
=TEX
Prove the local theorem:
Û
s10 Ö É a t1 t2 é (if a then t1 else t2) ä (a ä t1)
Ê
=SML
local
	val s1 = asm_rule ªif a then (t1:BOOL) else t2º;
	val s2 = Ç_t_intro s1;
	val s3 = eq_sym_rule s2;
	val s4 = if_then_elim_rule s3;
	val s5 = undisch_rule s4;
	val s6 = eq_sym_rule s5;
	val s7 = Ç_t_elim s6;
	val s8 = ä_intro ªa : BOOLº s7;
	val s9 = ä_intro ªif a then (t1:BOOL) else t2º s8;
	val s10 = list_simple_É_intro[ªa : BOOLº, ªt1 : BOOLº, ªt2 : BOOLº] s9;
in
fun ‚if_then_elim· (thm : THM) : THM = (
let	val (a,t1,t2) = dest_if (concl thm);
	val mf_s2 = list_simple_É_elim[a,t1,t2] s10;
	val mf_s3 = ä_elim mf_s2 thm;
in
	(prof "if_then_elim";
	mf_s3)
end
handle complaint =>
list_divert complaint "if_then_elim" [
	("dest_if",7012,[fn () => string_of_thm thm])]
);
end; (* of local val s1 = ... *)
=TEX
Û
s10 Ö É a t1 t2 é (if a then t1 else t2) ä å a ä t2
Ê
=SML
local
	val s1 = asm_rule ªif a then (t1:BOOL) else t2º;
	val s2 = Ç_t_intro s1;
	val s3 = eq_sym_rule s2;
	val s4 = if_else_elim_rule s3;
	val s5 = undisch_rule s4;
	val s6 = eq_sym_rule s5;
	val s7 = Ç_t_elim s6;
	val s8 = ä_intro ªå aº s7;
	val s9 = ä_intro ªif a then (t1:BOOL) else t2º s8;
	val s10 = list_simple_É_intro[ªa : BOOLº, ªt1 : BOOLº, ªt2 : BOOLº] s9;
in
fun ‚if_else_elim· (thm : THM) : THM = (
let	val (a,t1,t2) = dest_if (concl thm);
	val mf_s2 = list_simple_É_elim[a,t1,t2] s10;
	val mf_s3 = ä_elim mf_s2 thm;
in
	(prof "if_else_elim";
	mf_s3)
end
handle complaint =>
list_divert complaint "if_else_elim" [
	("dest_if",7012,[fn () => string_of_thm thm])]
);
end; (* of local val s1 = ... *)
=TEX
=TEX
\subsection{Concerning Functional Application}
=SML
fun ‚ext_rule· (thm : THM): THM  = (
let	val (h,c) =dest_thm thm;
	val (f,g) = dest_eq c;
	val mgv = hd(gen_vars [fst(dest_ã_type(type_of f))]
		(c :: h));
	val s1 = ap_arg_rule mgv thm;
	val s2 = simple_É_intro mgv s1;
in
	(prof "ext_rule";
	s2)
end
handle complaint =>
list_divert complaint "ext_rule" [
	("dest_eq",6020,[fn () => string_of_thm thm]),
	("dest_ã_type",7026,[fn () => string_of_thm thm])]
);
=TEX
\subsection{Concerning Assumptions}
=SML
fun ‚asm_intro· (tm : TERM) (thm : THM) : THM = (
let	val s1 = ä_intro tm thm
		handle complaint =>
		pass_on complaint "ä_intro" "asm_intro";
	val s2 = asm_rule tm;
	val s3 = ä_elim s1 s2;
in
	(prof "asm_intro";
	s3)
end);
=TEX
Û
s15 Ö É a t é (a ä t) ä (å a ä t) ä t
Ê
=SML
local 
	val s1 = simple_É_elim ªa : BOOLº bool_cases_axiom;
	val s2 = asm_rule ªa ä tº;
	val s3 = asm_rule ªa Ç Tº;
	val s4 = Ç_t_elim s3;
	val s5 = ä_elim s2 s4;
	val s6 = asm_rule ªåa ä tº;
	val s7 = asm_rule ªa Ç Fº;
	val s8 = simple_É_elim ªa : BOOLº å_1_thm;
	val s9 = eq_sym_rule s8;
	val s10 = Ç_mp_rule s9 s7;
	val s11 = ä_elim s6 s10;
	val s12 = Å_elim s1 s5 s11;
	val s13 = ä_intro ªåa ä tº s12;
	val s14 = ä_intro ªa ä tº s13;
	val s15 = list_simple_É_intro[ªa : BOOLº,ªt : BOOLº] s14;
in
fun ‚asm_elim· (tm : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let	val t = concl thm1;
	val mf_s1 = list_simple_É_elim [tm,t] s15;
	val mf_s2 = ä_intro tm thm1;
	val mf_s3 = ä_intro (mk_å tm) thm2;
	val mf_s4 = ä_elim mf_s1 mf_s2;
	val mf_s5 = ä_elim mf_s4 mf_s3;
in
	(prof "asm_elim";
	mf_s5)
end
handle complaint =>
list_divert complaint "asm_elim" [
	("list_simple_É_elim", 3031, [fn () => string_of_term tm]),
	("ä_elim",7029,[fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
end; (* local val s1 = ... *)
=TEX
=SML
fun ‚prove_asm_rule· (thm1 : THM) (thm2 : THM) : THM = (
let	val c1 = concl thm1;
	val s1 = ä_intro c1 thm2;
	val s2 = ä_elim s1 thm1;
in
	(prof "prove_asm_rule";
	s2)
end);
=TEX
=SML
fun ‚asm_inst_term_rule· (tml : (TERM * TERM) list) (thm : THM) : THM = (
let	val nhyps = length(strip_ä (concl thm));
	val s1 = all_ä_intro thm;
	val nhyps1 = length(strip_ä (concl s1));
	val s2 = inst_term_rule tml s1;
	val s3 = fold (fn (_,x) => undisch_rule x)
		(interval 1 (nhyps1 - nhyps)) s2;
in
	(prof "asm_inst_term_rule";
	s3)
end
handle complaint =>
pass_on complaint "inst_term_rule" "asm_inst_term_rule"
);
=TEX
=SML
fun ‚asm_inst_type_rule· (tyl : (TYPE * TYPE) list) (thm : THM) : THM = (
let	val nhyps = length(strip_ä (concl thm));
	val s1 = all_ä_intro thm;
	val nhyps1 = length(strip_ä (concl s1));
	val s2 = inst_type_rule tyl s1;
	val s3 = fold (fn (_,x) => undisch_rule x)
		(interval 1 (nhyps1 - nhyps)) s2;
in
	(prof "asm_inst_type_rule";
	s3)
end
handle complaint =>
pass_on complaint "inst_type_rule" "asm_inst_type_rule"
);
=TEX
\subsection{Concerning Matching Functions}
The function $apply\_matches\_rule$ encodes the matching attempt, should
a simple use of the rule fail.
It is given a term to match against,
a method of extracting the part to match,and the theorem
that is to be instantiated.
It presumes that the theorem it is passed is stripped
of all outer universal quantifers.
It brings up to the conclusion all the hypotheses.
It instantiates types to the minimum required,
instantiates free variables to the minimum required
(notice that we must not instantiate the universally quantified variables of $thm$ that occur free in the assumptions:
thus $tmm'$)
and then returns are the hypotheses to the assumption list.

The order of arguments to $@$ in $subs\_for$ is closely
tied to whether we do $inst\-\_term\-\_rule$
or $list\-\_simple\-\_É\-\_elim$ first.

Note that $term\_match$ is not infallible.
=SML
local
	fun strip_n_ä 0 tm = tm
	| strip_n_ä n tm = strip_n_ä (n-1) (snd(dest_ä tm));
in
fun ‚apply_matches_rule· (caller : string) 
	(match_against : TERM)
	(extract : TERM -> TERM)
	(thm : THM) : THM = (
let	val cnc = concl thm;
	val cfrees = frees cnc;
	val all_frees = cfrees cup (list_cup (map frees (hyps thm)));
	val qvs = fst(strip_É cnc);
	val subs_for = all_frees @ qvs;
	val subs_with = list_variant [] subs_for;
	val length_all_frees = length all_frees;
	val qvs' = subs_with from length_all_frees;
	val all_frees' = subs_with to (length_all_frees - 1);
	val s1 = list_simple_É_elim qvs' thm;
	val c = concl s1;
	val nhyps = length(strip_ä c);
	val s2 = all_ä_intro s1;
	val nhyps1 = length(strip_ä (concl s2));
	val s3 = inst_term_rule(combine all_frees' all_frees) s2;
	val t1 = extract (strip_n_ä (nhyps1 - nhyps)(concl s3));
	val (tym,tmm) = term_match match_against t1;
	val s4 = inst_type_rule tym s3;
	val s5 = inst_term_rule tmm s4;
	val s6 = fold (fn (_,x) => undisch_rule x)
		(interval 1 (nhyps1 - nhyps)) s5;
in
	s6
end
handle (Fail _) => fail caller 7044 [fn () => string_of_term match_against, 
		fn () => string_of_thm thm]
);
end;
=TEX
The function $apply\_matches\_rule1$ encodes the matching attempt, should
a simple use of the rule fail, but unlike the above does not attempt
to modify the assumptions.
It is given a term to match against,
a method of extracting the part to match,and the theorem
that is to be instantiated.
The theorem it is passed is stripped
of all outer universal quantifers.
It instantiates types to the minimum required,
instantiates free variables to the minimum required
(notice that we must not instantiate the universally quantified variables of $thm$ that occur free in the assumptions:
thus $tmm'$).

The order of arguments to $@$ in $subs\_for$ is closely
tied to whether we do $inst\-\_term\-\_rule$
or $list\-\_simple\-\_É\-\_elim$ first.

Note that $term\_match$ is not infallible.
=SML
fun ‚apply_matches_rule1· (caller : string) 
	(match_against : TERM)
	(extract : TERM -> TERM)
	(thm : THM) : THM = (
let	val cnc = concl thm;
	val cfrees = frees cnc;
	val afrees = (list_cup (map frees (hyps thm)));
	val just_c_frees = cfrees diff afrees;
	val qvs = fst(strip_É cnc);
	val subs_for = just_c_frees @ qvs;
	val subs_with = list_variant afrees subs_for;
	val length_just_c_frees = length just_c_frees;
	val qvs' = subs_with from length_just_c_frees;
	val just_c_frees' = subs_with to (length_just_c_frees-1);
	val s1 = list_simple_É_elim qvs' thm;
	val s3 = inst_term_rule(combine just_c_frees' just_c_frees) s1;
	val t1 = extract (concl s3);
	val (tym,tmm) = term_match match_against t1;
	val s4 = inst_type_rule tym s3;
	val s5 = inst_term_rule tmm s4;
in
	s5
end
handle (Fail _) => fail caller 7044 [fn () => string_of_term match_against, 
		fn () => string_of_thm thm]
);
=TEX
Now we use the above two in the various forms of matching.
=SML
local
fun aux (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = apply_matches_rule "simple_ä_match_mp_rule" 
		(concl thm2) (fst o dest_ä) thm1;
	val s2 = ä_elim s1 thm2;
in
	(prof "simple_ä_match_mp_rule";
	s2)
end
handle complaint =>
list_divert complaint "simple_ä_match_mp_rule" [
	("ä_elim", 7044, [fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
in
fun ‚simple_ä_match_mp_rule· (thm1 : THM) (thm2 : THM) : THM = (	
let	val s1 = ä_elim thm1 thm2;
in
	 (prof "simple_ä_match_mp_rule";
	s1)
end
	handle complaint =>
	aux thm1 thm2
);
end;
=TEX
=SML
local
fun aux (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = apply_matches_rule1 "simple_ä_match_mp_rule1" 
		(concl thm2) (fst o dest_ä) thm1;
	val s2 = ä_elim s1 thm2;
in
	(prof "simple_ä_match_mp_rule1";
	s2)
end
handle complaint =>
list_divert complaint "simple_ä_match_mp_rule1" [
	("ä_elim", 7044, [fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
in
fun ‚simple_ä_match_mp_rule1· (thm1 : THM) (thm2 : THM) : THM = (	
let	val s1 = ä_elim thm1 thm2;
in
	 (prof "simple_ä_match_mp_rule1";
	s1)
end
	handle complaint =>
	aux thm1 thm2
);
end;
=TEX
=SML
local
fun aux (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = apply_matches_rule "simple_Ç_match_mp_rule" (concl thm2) (fst o dest_Ç) thm1;
	val s2 = Ç_mp_rule s1 thm2;
in
	(prof "simple_Ç_match_mp_rule";
	s2)
end
handle complaint =>
list_divert complaint "simple_Ç_match_mp_rule" [
	("Ç_mp_rule", 7044, [fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
in
fun ‚simple_Ç_match_mp_rule· (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = Ç_mp_rule thm1 thm2;
in
	(prof "simple_Ç_match_mp_rule";
	s1)
end
	handle complaint =>
	aux thm1 thm2
);
end;
local
fun aux (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = apply_matches_rule1 "simple_Ç_match_mp_rule1" (concl thm2) (fst o dest_Ç) thm1;
	val s2 = Ç_mp_rule s1 thm2;
in
	(prof "simple_Ç_match_mp_rule1";
	s2)
end
handle complaint =>
list_divert complaint "simple_Ç_match_mp_rule1" [
	("Ç_mp_rule", 7044, [fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
in
fun ‚simple_Ç_match_mp_rule1· (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = Ç_mp_rule thm1 thm2;
in
	(prof "simple_Ç_match_mp_rule1";
	s1)
end
	handle complaint =>
	aux thm1 thm2
);
end;
=TEX
=SML
local
fun aux (thm : THM) : CONV = (fn (tm :TERM) =>
let	val s1 = apply_matches_rule "simple_eq_match_conv" tm (fst o dest_eq) thm;
	val s2 = eq_trans_rule (refl_conv tm) s1;
in
	(prof "simple_eq_match_conv";
	s2)
end
handle complaint =>
list_divert complaint "simple_eq_match_conv" [
	("eq_trans_rule", 7076, [fn () => string_of_term tm,
		fn () => string_of_thm thm])]
);
in
fun ‚simple_eq_match_conv· (thm : THM) : CONV = (fn (tm :TERM) =>
let	val s1 = eq_trans_rule (refl_conv tm) thm;
in
	 (prof "simple_eq_match_conv";
	s1)
end
	handle complaint =>
	aux thm tm
);
end;
=TEX
In the following we just map all failures bar $dest\_eq$
onto 7076, without working out whether the error is 
an ``expected'' one.
This is because we want this function to fail fast as well are succeed fast.
=SML
fun ‚simple_eq_match_1_conv· (thm : THM) : CONV = (
let	val (qvs,body) = strip_É (concl thm);
	val (t1,_) = dest_eq body;
in
(fn (tm :TERM) =>
let	val (tym,tmm) = term_match tm t1;
	val s2 = inst_type_rule tym thm;

	fun aux1 (qv :: rest) : TERM list = (
	let	val qv' = inst [] tym qv;
	in
		(rassoc1 tmm qv') :: aux1 rest 
	end
	) | aux1 [] = [];

	val s3 = list_simple_É_elim (aux1 qvs) s2;
	val s4 = eq_trans_rule (refl_conv tm) s3;
in
	(prof "simple_eq_match_1_conv";
	s4)
end
handle (Fail _) => fail "simple_eq_match_1_conv" 7076 [fn () => string_of_term tm,
	fn () => string_of_thm thm]
)
end
handle complaint =>
divert complaint "dest_eq" "simple_eq_match_1_conv" 7095 
	[fn () => string_of_thm thm]
);
=TEX
\subsection{Concerning ç}
=SML
fun ‚ç_rule· (tm : TERM) (thm : THM) : THM = (
let	val mgv = hd(gen_vars [type_of tm] [tm]);
	val sx = subst [(mgv,tm)] (concl thm);
	val mgv_sx = mk_app(mk_simple_ç(mgv,sx),tm)
	val s1 = simple_%beta%_conv mgv_sx;
	val s2 = eq_sym_rule s1;
	val s3 = Ç_mp_rule s2 thm
in
	(prof "ç_rule";
	s3)
end);
=TEX
In assessing the following, note that requesting, say, $ap\_arg\_rule$
is equivalent to requesting a $refl\_conv$ and a $mk\_app\_rule$ as far as efficiency goes.
In addition, note that the original term, $tm$ is in the sco[pe of $aux2$, saving a $mk\_app$.
=SML
val ‚all_simple_%beta%_conv· : CONV = (
let
fun rhs (thm: THM) : TERM = snd(dest_eq(concl thm));
fun asbc (tm : TERM) : THM OPT = (
let	val dt = dest_simple_term tm;

	fun aux1 thm1 thm2 = (
	let	val s1 = mk_app_rule thm1 thm2
	in
		Value (
		if not(is_simple_ç(rhs thm1))
		then s1
		else (let val s2 = conv_rule (RAND_C simple_%beta%_conv) s1;
		in
		if is_simple_ç(rhs thm2)
		then (
			case (asbc (rhs s2)) of
			Nil => s2
			| Value s3 => eq_trans_rule s2 s3
		) else s2
		end)
		)
	end);

	fun aux2 (f : TERM) (x : TERM) : THM OPT = (
	if is_simple_ç f
	then 	(Value(
		if is_simple_ç x
		then ((simple_%beta%_conv FURTHER_C(fn tm1 =>
			force_value (asbc tm1))) tm)
		else (simple_%beta%_conv tm)
		))
	else Nil);

	fun aux (App (f, x)) = (
	let	val fr = asbc f;
		val xr = asbc x;
	in
		case (fr,xr) of
		(Nil, Nil) => aux2 f x
		| (Value frt,Nil) => aux1 frt (refl_conv x)
		| (Nil, Value xrt) => aux1 (refl_conv f) xrt
		| (Value frt, Value xrt) => aux1 frt xrt
	end
	) | aux (Simpleç (x, b)) = (
	let	val br = asbc b
	in
		case br of
		Nil => Nil
		| (Value brt) => Value(simple_ç_eq_rule x brt)
	end
	) | aux _ = Nil;
in
	aux dt
end);
in
	(fn (tm:TERM) => case (asbc tm) of
		Value red => red
		| Nil => term_fail "all_simple_%beta%_conv" 7020 [tm])
end);
=TEX
=SML
fun ‚all_simple_%beta%_rule· (thm : THM) =(
	conv_rule all_simple_%beta%_conv thm
	handle complaint =>
	divert complaint "all_simple_%beta%_conv"
		"all_simple_%beta%_rule" 7020 [fn () => string_of_thm thm]
);
=TEX

\subsection{Concerning $\alpha$-conversion}
=SML
val ‚%alpha%_conv· : TERM -> CONV = (
let	val ar = subst_rule [];
in
(fn (tm1 : TERM) =>
 fn (tm2 : TERM) =>
let	val new_template = mk_eq(tm2, tm1)
		handle complaint =>
		pass_on complaint "mk_eq" "%alpha%_conv"
	val s2 = refl_conv tm2;
	val s3 = ar new_template s2;
in
	(prof "%alpha%_conv";
	s3)
end
handle complaint =>
list_divert complaint "%alpha%_conv" [
	("subst_rule",7034,[fn () => string_of_term tm1,
		fn () => string_of_term tm2])]
)
end);
=TEX
=SML
val ‚simple_%alpha%_conv· : string -> CONV = (
let	val ar = subst_rule [];
in
(fn (v : string) =>
 fn (tm:TERM) =>
let	val (x,b) = dest_simple_ç tm
		handle complaint =>
		pass_on complaint "dest_simple_ç" "simple_%alpha%_conv";
	val vtm = mk_var(v, type_of x);
	val abs = mk_simple_ç(vtm,subst[(vtm,x)]b);
	val new_template = mk_eq(tm, abs);
	val s2 = refl_conv tm;
	val s3 = ar new_template s2
		handle complaint =>
		divert complaint "subst_rule" "simple_%alpha%_conv" 7035
		[fn () => string_of_term x,(fn () => v)];
in
	(prof "%alpha%_conv";
	s3)
end)
end);
=TEX
\subsection{Concerning å (part II)}
We prove the local theorem:
Û
s8 Ö É p é å(å p) = p
Ê
=SML
local
	val s1 = asm_rule ªp : BOOLº;
	val s2 = å_å_intro s1;
	val s3 = ä_intro ªp : BOOLº s2;
	val s4 = asm_rule ªå(å p)º;
	val s5 = å_å_elim s4;
	val s6 = ä_intro ªå(å p)º s5;
	val s7 = Ç_intro s6 s3;
	val s8 = simple_É_intro ªp : BOOLº s7;
in
val å_å_conv : CONV = (fn (tm:TERM) =>
let	val p = dest_å(dest_å tm);
	val mf_s1 = simple_É_elim p s8;
in
	(prof "å_å_conv";
	mf_s1)
end
handle complaint =>
divert complaint "dest_å" "å_å_conv" 7022 [fn () => string_of_term tm]
);
end;
=TEX
Local theorems:
Û
s22 Ö É p é å (Ñ x é å (p x)) Ç (É x é p x)

s27 Ö å (É x é å (p x)) Ç (Ñ x é p x)

s31 Ö É p é å (É x é p x) Ç (Ñ x é å (p x))

s35 Ö É p é å (Ñ x é p x) Ç (É x é å (p x))
Ê
=SML
local
val s1 = asm_rule ª(ç x : 'a é å(p x)) xº;
val s2 = simple_Ñ_intro ªÑ x : 'a é (ç x é å(p x)) xº s1;
val s3 = all_ä_intro s2;
val s4 = all_simple_%beta%_rule s3;
val s5 = asm_rule ªå(Ñ x é å (p x))º;
val s6 = modus_tollens_rule s4 s5;
val s7 = å_å_elim s6;
val s8 = simple_É_intro ªx : 'aº s7;
val s9 = all_ä_intro s8;

val s10 = asm_rule ªÉ x : 'a é p xº;
val s11 = all_simple_É_elim s10;
val s12 = asm_rule ªå(p (x : 'a))º;
val s13 = asm_rule ªÑ x : 'a é å(p x)º;
val s14 = å_elim ªFº s11 s12;
val s15 = simple_Ñ_elim ªx : 'aº s13 s14;
val s16 = ä_intro ªÑ x : 'a é å(p x)º s15;
val s17 = simple_É_elim ªÑ x : 'a é å(p x)º å_thm;
val s18 = eq_sym_rule s17;
val s19 = Ç_mp_rule s18 s16;
val s20 = all_ä_intro s19;
val s21 = Ç_intro s9 s20;
val s22 = all_É_intro s21;

val s23 = simple_É_elim ª(ç x : 'a é å(p x))º s22;
val s24 = all_simple_%beta%_rule s23;
val s25 = ap_fun_rule ª$åº s24;
val s26 = conv_rule (TOP_MAP_C å_å_conv) s25;
val s27 = eq_sym_rule s26;

val s28 = ap_fun_rule ª$åº s21;
val s29 = conv_rule (TOP_MAP_C å_å_conv) s28;
val s30 = eq_sym_rule s29;
val s31 = all_É_intro s30; (* å_É_thm *)

val s32 = ap_fun_rule ª$åº s27;
val s33 = conv_rule (TOP_MAP_C å_å_conv) s32;
val s34 = eq_sym_rule s33;
val s35 = all_É_intro s34; (* å_Ñ_thm *)

=TEX
Now the main functions:
=SML
in
val ‚simple_å_É_conv· : CONV = (fn (tm:TERM) =>
let	val neg = (dest_å tm);
	val (v,b) = dest_simple_É neg;
	val vstr = fst(dest_var v);
	val abs = snd(dest_app neg);
	val mf_s1 = inst_type_rule[(type_of v,mk_vartype "'a")] s31;
	val mf_s2 = simple_É_elim abs mf_s1;
	val mf_s3 = conv_rule(ONCE_MAP_C simple_%beta%_conv
		THEN_C ONCE_MAP_C (simple_%alpha%_conv vstr)) mf_s2;
	val mf_s4 = refl_conv tm;
	val mf_s5 = eq_trans_rule mf_s4 mf_s3;
in
	(prof "simple_å_É_conv";
	mf_s5)
end
handle complaint =>
list_divert complaint "simple_å_É_conv" [
	("dest_å",7036,[fn () => string_of_term tm]),
	("dest_É",7036,[fn () => string_of_term tm])]
);

val ‚simple_å_Ñ_conv· : CONV = (fn (tm:TERM) =>
let	val neg = (dest_å tm);
	val (v,b) = dest_simple_Ñ neg;
	val vstr = fst(dest_var v);
	val abs = snd(dest_app neg);
	val mf_s1 = inst_type_rule[(type_of v,mk_vartype "'a")] s35;
	val mf_s2 = simple_É_elim abs mf_s1;
	val mf_s3 = conv_rule(ONCE_MAP_C simple_%beta%_conv
		THEN_C ONCE_MAP_C (simple_%alpha%_conv vstr)) mf_s2;
	val mf_s4 = refl_conv tm;
	val mf_s5 = eq_trans_rule mf_s4 mf_s3;
in
	(prof "å_Ñ_conv";
	mf_s5)
end
handle complaint =>
list_divert complaint "simple_å_Ñ_conv" [
	("dest_å",7058,[fn () => string_of_term tm]),
	("dest_Ñ",7058,[fn () => string_of_term tm])]
);
end; (* of local val s1 = ... *)
=TEX
\subsection{Concerning Ä and ä}
Û
s Ö É a b c é ((a Ä b) ä c) Ç (a ä b ä c)
s Ö É a b c é (a ä b ä c) Ç ((a Ä b) ä c)
Ê
=SML
local
	val s1 = asm_rule ªa Ä bº;
	val s2 = Ä_left_elim s1;
	val s3 = Ä_right_elim s1;
	val s4 = asm_rule ªa : BOOLº;
	val s5 = asm_rule ªb : BOOLº;
	val s6 = Ä_intro s4 s5;
	val s7 = asm_rule ª(a Ä b) ä cº;
	val s8 = ä_elim s7 s6;
	val s9 = ä_intro ªb : BOOLº s8;
	val s10 = ä_intro ªa : BOOLº s9;
	val s11 = ä_intro ª(a Ä b) ä cº s10;

	val s12 = asm_rule ªa ä b ä cº;
	val s13 = ä_elim s12 s2;
	val s14 = ä_elim s13 s3;
	val s15 = ä_intro ªa Ä bº s14;
	val s16 = ä_intro ªa ä b ä cº s15;
	
	val s17 = Ç_intro s11 s16;
	val s18 = list_simple_É_intro [ªa : BOOLº, ªb : BOOLº, ªc : BOOLº] s17;
	val s19 = eq_sym_rule s17;
	val s20 = list_simple_É_intro [ªa : BOOLº, ªb : BOOLº, ªc : BOOLº] s19;
in
fun ‚ä_Ä_rule· (thm : THM) : THM = (
let val (a,(b,c)) = (Combinators.I ** dest_ä)(dest_ä (concl thm));
	val mf_s1 = list_simple_É_elim [a,b,c] s20;
	val mf_s2 = Ç_mp_rule mf_s1 thm;
in
	(prof "ä_Ä_rule";
	mf_s2)
end
handle complaint =>
divert complaint "dest_ä" "ä_Ä_rule" 7008 [fn () => string_of_thm thm]
);

fun ‚Ä_ä_rule· (thm : THM) : THM = (
let val ((a,b),c) = (dest_Ä ** Combinators.I)(dest_ä (concl thm));
	val mf_s1 = list_simple_É_elim [a,b,c] s18;
	val mf_s2 = Ç_mp_rule mf_s1 thm;
in
	(prof "ä_Ä_rule";
	mf_s2)
end
handle complaint =>
list_divert complaint "Ä_ä_rule" [
	("dest_Ä",7009,[fn () => string_of_thm thm]),
	("dest_ä",7009,[fn () => string_of_thm thm])]
);
end;
=TEX
\subsection{Concerning Ñ$_1$}
=SML
local
	val s1 = ap_arg_rule ªP : 'a ã BOOLº Ñ%down%1_def;
	val s2 = all_simple_%beta%_rule s1;
	val s3 = simple_É_intro ªP : 'a ã BOOLº s2;
in
	val ‚Ñ%down%1_thm· = save_thm("Ñ%down%1_thm",s3)
end;
=TEX
=SML
fun simple_Ñ%down%1_intro (thm1 : THM) (thm2 : THM) : THM = (
let	val (x,rest) = dest_simple_É (concl thm2);
	val (Px,(x',t)) = (Combinators.I ** dest_eq)(dest_ä rest);
	val sideeffect = if x = x'
		then ()
		else fail "simple_Ñ%down%1_intro" 7066 [];
	val witness = case (term_match (concl thm1) Px) of
		([],[(w,_)]) => w
		| ([],[]) => t
		| _ => fail "simple_Ñ%down%1_intro" 7067 [];
	val abs = mk_simple_ç(x,Px);
	val P_t = mk_app(abs, witness);
	val P_x = mk_app(abs, x);
	val s1 = simple_%beta%_conv P_t;
	val s2 = eq_sym_rule s1;
	val s3 = Ç_mp_rule s2 thm1;
	val s4 = simple_%beta%_conv P_x;
	val s5 = eq_sym_rule s4;
	val mgvs = gen_vars [BOOL, type_of x] (frees rest);
	val mgv = hd mgvs;
	val mgv1 = hd(tl mgvs);
	val s6 = all_simple_É_elim thm2;
	val template = mk_ä(mgv,mk_eq(x,t));
	val s7 = subst_rule [(s5,mgv)] template s6;
	val s8 = simple_É_intro x s7;
	val s9 = Ä_intro s3 s8;
	val template2 = mk_simple_Ñ(mgv1,
		mk_Ä(mk_app(abs,mgv1),
		mk_simple_É(x,
		mk_ä(
		P_x, mk_eq(x,mgv1)))));
	val s10 = simple_Ñ_intro template2 s9;
	val s11 = inst_type_rule[(type_of x,mk_vartype "'a")] Ñ%down%1_thm;
	val s12 = simple_É_elim abs s11;
	val s13 = eq_sym_rule s12;
	val s14 = Ç_mp_rule s13 s10;
	val s15 = conv_rule(RAND_C (simple_%alpha%_conv (fst(dest_var x)))) s14;
in
	(prof "simple_Ñ%down%1_intro";
	s15)
end
handle complaint =>
list_divert complaint "simple_Ñ%down%1_intro" [
	("term_match",7067,[fn () => string_of_thm thm1, fn () => string_of_thm thm2]),
	("dest_simple_É",7066,[fn () => string_of_thm thm2]),
	("dest_ä",7066,[fn () => string_of_thm thm2])
]
);
=TEX
=SML
fun ‚simple_Ñ%down%1_elim· (thm : THM) : THM = (
let	val (_,bdy) = dest_app (concl thm);
	val (x,_) = dest_simple_ç bdy;
	val (xt,bt) = dest_ã_type(type_of bdy);
	val s1 = inst_type_rule [(xt,mk_vartype "'a")] Ñ%down%1_thm;
	val s2 = simple_É_elim bdy s1;
	val s3 = Ç_mp_rule s2 thm;
	val s4 = conv_rule (BINDER_C
		((RAND_C(BINDER_C(RATOR_C(RAND_C simple_%beta%_conv))))
		THEN_C
		(RATOR_C(RAND_C simple_%beta%_conv)))) s3;
	val s5 = conv_rule(RAND_C (simple_%alpha%_conv (fst(dest_var x)))) s4;
in
	(prof "simple_Ñ%down%1_elim";
	s5)
end
handle complaint =>
list_divert complaint "simple_Ñ%down%1_elim" [
	("dest_app",7015,[fn () => string_of_thm thm]),
	("dest_simple_ç",7015,[fn () => string_of_thm thm]),
	("dest_fun",7015,[fn () => string_of_thm thm]),
	("Ç_mp_rule",7015,[fn () => string_of_thm thm])]
);
=TEX
\section{END OF THE STRUCTURE}
=SML
end; (* of structure DerivedRules1 *)
open DerivedRules1; 
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN
Statistics:

open Sort;
fun comp_stats (s1,n1) (s2,n2) = (
	if n1 = n2
	then stringorder s1 s2
	else (n1 - n2)
);

sort comp_stats (get_stats ());
