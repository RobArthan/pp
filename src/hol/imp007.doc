=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Implementation for the Derived Rules of Inference}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Derived Rules of Inference}
\TPPref{DS/FMU/IED/IMP007}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{K.~Blackburn & WIN01\\D.J.~King & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
Primitive and built-in inference rules, and conversionals
all module tested to these implementations.
\item [Issue 1.2]
Added material up to $€$.
\item [Issue 1.3]
Added up to $Š\_trans\_rule$, corrected $»Œ¼$.
\item [Issue 1.4]
Added up to $Œ\_eq\_sym\_rule$,
and DJK work.
\item [Issue 1.5]
Corrected $Œ\_1\_thm$ description,
corrected $simple\_list\_ƒ\_intro$.
Added up to $asm\_inst\_type\_rule$.
\item [Issue 1.6]
Corrected $simple\_„_elim$.
\item [Issue 1.7]
Added most of the rest.
\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the derived rules of inference.
This includes user versions of the
primitive and built-in inference rules.
The design is in \cite{DS/FMU/IED/DTD007}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the 
This includes user versions of the
primitive and built-in inference rules.
A ``primitive'' inference rule is considered to be part of the logic,
whereas a ``built-in'' rule is one that, though it could be coded in terms 
of the primitive rules, will actually be part of the abstract data type $THM$, and thus taken as holding true without checking.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD007},
and also requires those files indicated as preceding it in the 
rel001 makefile.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}


\section{THE ABSTRACT DATA TYPE $THM$}
=SML
(* structure âDerivedInferenceRulesá : DerivedInferenceRules = struct *)
=TEX
\subsection{Utilities}
We will often wish to just pass on error messages,
just changing the source area of the message if it is from
particular function.
Thus:
=SML
fun âpass_oná (e : exn) (fromnm : string) (tonm : string) : 'a = (
let 	val efrom = area_of e
in
	if efrom = fromnm
	then reraise e tonm
	else reraise e efrom
end);
=TEX
The following two should be visible to the outside world:
=SML
val âconclá :  THM -> TERM = snd o dest_thm;
val âhypsá : THM -> TERM list = fst o dest_thm;
=TEX
As should the following:
=SML
val T = »T¼;
val F = »F¼;
=TEX
\subsection{Primitive and Built-in Rules}
This, and only this, part is done in the context
of an open kernel:
=SML
local
	open icl'Kernel;
in
=TEX
\subsubsection{Primitive Rules}
=SML
fun âsubst_ruleá (thm_var_lst : (THM * TERM) list) :
	TERM -> THM -> THM = (
	let val s1 = icl'subst_rule thm_var_lst
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule"
	in
	(fn (tm : TERM) =>
	let val s2 = s1 tm
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule"
	in
	(fn (thm : THM) =>
	(prof "subst_rule";
	s2 thm
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule")
	)
	end)
	end
);
=TEX
=SML
fun âsimple_abs_ruleá (tm : TERM) (thm : THM) : THM = (
	prof "simple_abs_rule";
	icl'simple_abs_rule tm thm
		handle complaint => 
		pass_on complaint "icl'simple_abs_rule" "simple_abs_rule"
);
=SML
fun âinst_type_ruleá (ty_list : (TYPE * TYPE) list) (thm : THM) : THM = (
	prof "inst_type_rule";
	icl'inst_type_rule ty_list thm
		handle complaint => 
		pass_on complaint "icl'inst_type_rule" "inst_type_rule"
);
=TEX
=SML
fun âŠ_introá (tm : TERM) (thm : THM) : THM = (
	prof "Š_intro";
	icl'Š_intro tm thm
		handle complaint => 
		pass_on complaint "icl'Š_intro" "Š_intro"
);
=TEX
=SML
fun âŠ_elimá (thm1 : THM) (thm2 : THM) : THM = (
	prof "Š_elim";
	icl'Š_elim thm1 thm2
		handle complaint => 
		pass_on complaint "icl'Š_elim" "Š_elim"
);
=TEX
=SML
fun âasm_ruleá (tm : TERM) : THM = (
	prof "asm_rule";
	icl'asm_rule tm
		handle complaint => 
		pass_on complaint "icl'asm_rule" "asm_rule"
);
=TEX
=SML
val ârefl_convá : CONV = (
	fn (tm : TERM) =>
	(prof "refl_conv";
	icl'refl_conv tm
		handle complaint => 
		pass_on complaint "icl'refl_conv" "refl_conv")
);
=TEX
=SML
val âsimple_%beta%_convá : CONV = (
	fn (tm : TERM) =>
	(prof "simple_%beta%_conv";
	icl'simple_%beta%_conv tm
		handle complaint => 
		pass_on complaint "icl'simple_%beta%_conv" "simple_%beta%_conv")
);
=TEX
\subsubsection{Definitional Schemata}
=SML
local
	val N0 = »0¼;
in
val âsuc_convá : CONV = (
	fn (tm : TERM) =>
	(prof "suc_conv";
	if tm = N0
	then fail "suc_conv" 7100 []
	else icl'suc_conv tm
		handle complaint => 
		pass_on complaint "icl'suc_conv" "suc_conv")
);
end;
=TEX
=SML
val âstring_convá : CONV = (
	fn (tm : TERM) =>
	(prof "string_conv";
	icl'string_conv tm
		handle complaint => 
		pass_on complaint "icl'string_conv" "string_conv")
);
=TEX
=SML
val âchar_convá : CONV = (
	fn (tm : TERM) =>
	(prof "char_conv";
	icl'char_conv tm
		handle complaint => 
		pass_on complaint "icl'char_conv" "char_conv")
);
=TEX
\subsubsection{Built-In Rules of Inference}
=SML
fun âeq_sym_ruleá (thm : THM) : THM = (
	prof "eq_sym_rule";
	icl'eq_sym_rule thm
		handle complaint => 
		pass_on complaint "icl'eq_sym_rule" "eq_sym_rule"
);
=TEX
=SML
fun âsimple_ƒ_elimá (tm : TERM) (thm : THM) : THM = (
	prof "simple_ƒ_elim";
	icl'simple_ƒ_elim tm thm
		handle complaint => 
		pass_on complaint "icl'simple_ƒ_elim" "simple_ƒ_elim"
);
=TEX
=SML
fun âeq_trans_ruleá (thm1 : THM) (thm2 : THM) : THM = (
	prof "eq_trans_rule";
	icl'eq_trans_rule thm1 thm2
		handle complaint => 
		pass_on complaint "icl'eq_trans_rule" "eq_trans_rule"
);
=TEX
=SML
fun âmk_comb_ruleá (thm1 : THM) (thm2 : THM) : THM = (
	prof "mk_comb_rule";
	icl'mk_comb_rule thm1 thm2
		handle complaint => 
		pass_on complaint "icl'mk_comb_rule" "mk_comb_rule"
);
=TEX
=SML
fun â‚_mp_ruleá (thm1 : THM) (thm2 : THM) : THM = (
	prof "‚_mp_rule";
	icl'‚_mp_rule thm1 thm2
		handle complaint => 
		pass_on complaint "icl'‚_mp_rule" "‚_mp_rule"
);
=TEX
=SML
fun âsimple_ƒ_introá (tm : TERM) (thm : THM) : THM = (
	prof "simple_ƒ_intro";
	icl'simple_ƒ_intro tm thm
		handle complaint => 
		pass_on complaint "icl'simple_ƒ_intro" "simple_ƒ_intro"
);
=TEX
=SML
fun âinst_term_ruleá (tml : (TERM * TERM) list) (thm : THM) : THM = (
	prof "inst_term_rule";
	icl'inst_term_rule tml thm
		handle complaint => 
		pass_on complaint "icl'inst_term_rule" "inst_term_rule"
);
=TEX
=SML
val âdiv2_convá : CONV = (
	fn (tm : TERM) =>
	(prof "div2_conv";
	icl'div2_conv tm
		handle complaint => 
		pass_on complaint "icl'div2_conv" "div2_conv")
);
=TEX
=SML
val âmod2_convá : CONV = (
	fn (tm : TERM) =>
	(prof "mod2_conv";
	icl'mod2_conv tm
		handle complaint => 
		pass_on complaint "icl'mod2_conv" "mod2_conv")
);
=TEX
=SML
end; (* local open icl'Kernel *)
=TEX
\subsection{Inference Rules For Conversions}
Two "proper" failures come from $mk\-\_comb\-\_rule$,
each with their own failure message from
$ap\-\_fun\-\_rule$.
We need to do some calculation to determine which error
is given: but we only do this if we get a failure.
=SML
fun âap_fun_ruleá (tm : TERM) (thm : THM) : THM = ((
let
	val thm1 = refl_conv tm;
in
	(prof "ap_fun_rule";
	mk_comb_rule thm1 thm)
end)
handle complaint =>
if is_eq(concl thm)
then divert complaint "mk_comb_rule" "ap_fun_rule" 7024 []
else divert complaint "mk_comb_rule" "ap_fun_rule" 7023 []
);
=TEX
Two "proper" failures come from $mk\-\_comb\-\_rule$,
each with their own failure message from
$ap\-\_arg\-\_rule$.
We need to do some calculation to determine which error
is given: but we only do this if we get a failure.
=SML
fun âap_arg_ruleá (tm : TERM) (thm : THM) : THM = (
let
	val thm1 = refl_conv tm;
in
	(prof "ap_arg_rule";
	mk_comb_rule thm thm1)
end
handle complaint =>
if is_eq(concl thm)
then divert complaint "mk_comb_rule" "ap_arg_rule" 7025 []
else divert complaint "mk_comb_rule" "ap_arg_rule" 7023 []
);
=TEX

\subsection{Conversions}
\subsubsection{Building Blocks}
=SML
val âfail_convá : CONV = (fn tm => fail "fail_conv" 7061 []);

fun âfail_with_convá (str : string) : CONV = (
	fn tm => fail "fail_with_conv" 7075 [fn () => str]
);
=TEX
\subsubsection{Conversionals}
=SML
fun (cnv1 : CONV) âTHEN_Cá (cnv2 : CONV) = (fn (tm: TERM) =>
let
	val thm1 = cnv1 tm;
	val rhs_thm1 = snd(dest_eq (concl thm1));
	val thm2 = cnv2 rhs_thm1;
in
	eq_trans_rule thm1 thm2
end
handle complaint =>
list_divert complaint "THEN_C" [
	("dest_eq",7101,[]),
	("eq_trans_rule",7102,[])]);
=TEX
=SML
fun (cnv1 : CONV) âFURTHER_Cá (cnv2 : CONV) = (fn (tm: TERM) =>
let
	val thm1 = cnv1 tm
in
	(let
		val rhs_thm1 = snd(dest_eq (concl thm1));
		val thm2 = cnv2 rhs_thm1;
	in
		eq_trans_rule thm1 thm2
	end
	handle (Fail _) => thm1)
end);
=TEX
=SML
fun (cnv1 : CONV) âORELSE_Cá (cnv2 : CONV) = (fn (tm: TERM) =>
	cnv1 tm
handle (Fail _) =>
	cnv2 tm
);
=TEX
=SML
fun (cnv1 : CONV) âEITHER_Cá (cnv2 : CONV) : CONV = (fn (tm: TERM) =>
(let
	val thm1 = cnv1 tm
in
	(let
		val rhs_thm1 = snd(dest_eq (concl thm1));
		val thm2 = cnv2 rhs_thm1;
	in
		eq_trans_rule thm1 thm2
	end
	handle (Fail _) => thm1)
end
handle (Fail _) => cnv2 tm)
);
=TEX
=SML
fun âTRY_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
	cnv tm
	handle (Fail _) =>
	refl_conv tm
);
=TEX
=SML
fun âREPEAT1_Cá (cnv : CONV) = (fn (tm : TERM) =>
	(cnv FURTHER_C (REPEAT1_C cnv)) tm
);
=TEX
Notice that the following is carefully coded to avoid
redundant $refl\_conv$'s.
There is a minor partial evaluation effect with 
only the conversion argument.
=SML
fun âREPEAT_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
	TRY_C (REPEAT1_C cnv) tm
);
=TEX
Partially evaluated given only a list.
=SML
fun âLIST_THEN_Cá ([cnv] : CONV list) : CONV = cnv
| LIST_THEN_C (cnv :: crest) = cnv THEN_C (LIST_THEN_C crest)
| LIST_THEN_C [] = fail "LIST_THEN_C" 7103 [];
=TEX
Partially evaluated given only a list.
=SML
fun âLIST_ORELSE_Cá ([cnv] : CONV list) : CONV = cnv
| LIST_ORELSE_C (cnv :: crest) = cnv ORELSE_C (LIST_ORELSE_C crest)
| LIST_ORELSE_C [] = fail "LIST_ORELSE_C" 7103 [];
=TEX
=SML
fun âCHANGED_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let 	val thm = cnv tm;
	val rhs_thm = (snd o dest_eq o concl) thm;
in
	if rhs_thm <> tm
	then thm
	else fail "CHANGED_C" 7032 []
end
handle complaint =>
divert complaint "dest_eq" "CHANGED_C" 7104[]);
=TEX
\subsubsection{Term Traversal Algorithms for Conversions}
=SML
fun  âRAND_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let
	val (f,x) = dest_comb tm;
	val thm1 = cnv x;
in
	ap_fun_rule f thm1
end
handle complaint =>
list_divert complaint "RAND_C" [
	("dest_comb",7045,[]),
	("ap_fun_rule",7104,[])]
);
=TEX
=SML
fun  âRATOR_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let
	val (f,x) = dest_comb tm;
	val thm1 = cnv f;
in
	ap_arg_rule x thm1
end
handle complaint =>
list_divert complaint "RATOR_C" [
	("dest_comb",7045,[]),
	("ap_arg_rule",7104,[])]
);
=TEX
=SML
fun  âABS_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let
	val (x,b) = simple_dest_abs tm;
	val thm1 = cnv b;
in
	simple_abs_rule x thm1
end
handle complaint =>
list_divert complaint "ABS_C" [
	("simple_dest_abs",7030,[]),
	("simple_abs_rule",7104,[])]
);
=TEX
We do the following in full to be able to determine the
correct error message, if necessary.
It could just be $RAND\_C\ o\ ABS\_C$.
=SML
fun  âBINDER_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let
	val (binder,abs) = dest_comb tm;
	val (x,b) = simple_dest_abs abs;
	val thm1 = cnv b;
in
	ap_fun_rule binder (simple_abs_rule x thm1)
end
handle complaint =>
list_divert complaint "BINDER_C" [
	("simple_dest_abs",7059,[]),
	("dest_comb",7059,[]),
	("simple_abs_rule",7104,[]),
	("ap_fun_rule",7104,[])]
);
=TEX
We could build the following using the above building blocks,
but prefer to keep it fast.
=SML
fun âSUB_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let
	fun aux (Var _) = refl_conv tm
	| aux (Const _) = refl_conv tm
	| aux (Comb (f,x)) = (
		((let val thm1 = cnv f
		in
		 (let val thm2 = cnv x
		 in
			mk_comb_rule thm1 thm2
		 end
		 handle (Fail _) =>
		 ap_arg_rule x thm1)
		end)
		handle (Fail _) =>
		(let val thm2 = cnv x
		in
			ap_fun_rule f thm2
		end))
		handle (Fail _) => refl_conv tm
	) | aux (Abs (x,b)) = (
		let val thm1 = cnv b
		in
			simple_abs_rule x thm1
		end
		handle (Fail _) =>
		refl_conv tm
	);
in
	aux(simple_dest_term tm)
end
handle complaint =>
list_divert complaint "SUB_C" [
	("mk_comb_rule",7104,[]),
	("simple_abs_rule",7104,[])]
);
=TEX
There is a mild partial evaluation with only a conversion.
=SML
fun âSUB1_Cá (cnv : CONV) : CONV = (fn (tm : TERM) => 
let
	fun aux (Var _) = fail "SUB1_C"  7105 []
	| aux (Const _) = fail "SUB1_C"  7105 []
	| aux (Comb (f,x)) = (
		let val thm1 = cnv f
		in
		 (let val thm2 = (cnv x
			handle (Fail _) => refl_conv x)
		 in
			mk_comb_rule thm1 thm2
		 end)
		end
		handle (Fail _) =>
		(let val thm2 = cnv x
		in
			ap_fun_rule f thm2
		end)
	) | aux (Abs (x,b)) = (
		let val thm1 = cnv b
		in
			simple_abs_rule x thm1
		end
	);
in
	aux(simple_dest_term tm)
end
handle complaint =>
list_divert complaint "SUB1_C" [
	("ap_fun_rule",7104,[]),
	("simple_abs_rule",7104,[])]
);
=TEX
N.B. the $fn\ (tm: TERM) \ldots tm$ might look $\eta$-convertible away, but actually prevents an infinite loop.
=SML
fun âONCE_TRAVERSE_Cá (cnv : CONV) : CONV = (fn (tm: TERM) =>
	(cnv ORELSE_C (SUB1_C (ONCE_TRAVERSE_C cnv))) tm
);
=TEX
=SML
fun âTRAVERSE_Cá (cnv : CONV) : CONV = (fn tm =>
	((SUB1_C (TRAVERSE_C cnv)) EITHER_C (REPEAT1_C cnv)) tm
);
=TEX
=SML
fun âREPEAT_TRAVERSE_Cá (cnv : CONV) : CONV = (fn tm =>
	((SUB1_C (REPEAT_TRAVERSE_C cnv))
	EITHER_C (cnv FURTHER_C (REPEAT_TRAVERSE_C cnv))) tm
);
=TEX
=SML
fun âTOP_TRAVERSE_Cá (cnv : CONV) : CONV = (fn (tm:TERM) =>
	((REPEAT1_C cnv) EITHER_C (SUB1_C(TOP_TRAVERSE_C cnv)))tm
);
=TEX
\subsubsection{Conversions as Rules}
=SML
fun âconv_ruleá (cnv : CONV) (thm : THM) : THM = (
let
	val thm1 = cnv(concl thm)
in
	‚_mp_rule thm1 thm
end
handle complaint =>
divert complaint "‚_mp_rule" "conv_rule" 7104 []);
=TEX 
\section{DERIVED INFERENCE RULES}
We will be saving theorems as we go along, so we need to ensure we are saving them into theory misc:
=SML
open_theory "misc";
=TEX
An alias:
=SML
val âŠ_mp_ruleá = Š_elim;
=TEX
Something we will want locally:
=RULE
simple_list_ƒ_elim
[»t1¼, ..., »tn¼]
É
ö … ƒ x1 ... xn Ž t[x1, ..., xn]
É
t[t1, ..., tn]
=TEX
where the $x_i$ are simple variables.
=SML
val âsimple_list_ƒ_elimá = revfold (uncurry simple_ƒ_elim);
=TEX
The following is out of place, but useful if declared immediately:
=SML
fun âundisch_ruleá (thm : THM) : THM = (
let
	val (a,b) = dest_Š(concl thm);
	val s1 = asm_rule a;
	val s2 = Š_elim thm s1
in
	(prof "undisch_rule";
	s2)
end
handle complaint =>
divert complaint "dest_Š" "undisch_rule" 7011 []
);
=TEX
Something else out of sequence:
=SML
fun âdisch_ruleá (tm : TERM) (thm : THM) : THM = (
	if any (hyps thm) (aconv tm)
	then (prof "disch_rule";
		 Š_intro tm thm
		handle complaint =>
		pass_on complaint "Š_intro" "disch_rule")
	else fail "disch_rule" 7031 []
);
=TEX
		
\subsection{Concerning $T$}
Proof of $T$ (as 12.3.9)
=SML
local
	val s1 = t_def;
	val s2 = eq_sym_rule s1;
	val s3 = refl_conv » x : BOOL Ž x¼;
	val s4 = ‚_mp_rule s2 s3;
in
	val t_thm = save_thm("ât_thmá",s4)
end;
=TEX
We could work by a local theorem:
ó
… ƒ x Ž x ‚ (x ‚ T)
æ
but choose to work by the more primitive route of 12.3.12
=SML
fun â‚_t_introá (thm : THM) : THM = (
let
	val t = concl thm;
	val s3 = simple_list_ƒ_elim [t, T] Š_antisym_axiom;
	val s5 = Š_intro t t_thm;
	val s5 = Š_elim s3 s5;
	val s8 = Š_intro T thm;
	val s9 = Š_elim s5 s8;
in
	(prof "‚_t_intro";
	s9)
end);
=TEX
In the following we could chose to try eliminating
all outermost $\ldots ‚ T$ and $T ‚ \ldots$.
D.I.Y. form:
=SML
fun â‚_t_elimá (thm : THM) : THM = (
let
	val s1 = eq_sym_rule thm;
	val s2 = ‚_mp_rule s1 t_thm;
in
	(prof "‚_t_elim";
	s2)
end
handle complaint =>
list_divert complaint "‚_t_elim" [
	("eq_sym_rule",7106,[]),
	("‚_mp_rule",7106,[])]);
=TEX
D.I.Y. form:
=SML
fun âcontr_ruleá (t : TERM) (thm : THM) : THM = (
let
	val s1 = ‚_mp_rule f_def thm;
	val s2 = simple_ƒ_elim t s1;
in
	(prof "contr_rule";
	s2)
end
handle complaint =>
list_divert complaint "contr_rule" [
	("‚_mp_rule", 7001, []),
	("simple_ƒ_elim",7002,[])]
);
=TEX
The following is out of sequence, but necessary at this point:
we first prove theorem:
ó
_thm = … ƒ t1 t2 Ž (t1  t2) = (ƒ b Ž (t1 Š b) Š (t2 Š b) Š b)
æ
=SML
local
	val s1 = ap_arg_rule »t1 : BOOL¼ _def;
	val s2 = ap_arg_rule »t2 : BOOL¼ s1;
	val s3 = conv_rule (TRAVERSE_C simple_%beta%_conv) s2;
	val s4 = simple_ƒ_intro »t2 : BOOL¼ s3;
	val s5 = simple_ƒ_intro »t1 : BOOL¼ s4;
in
	val _thm = save_thm("â_thmá",s5)
end;
=TEX
Then the out of place rule
(roughly as \cite{DS/FMU/IED/SML009} 5.14):
=SML
fun â_elimá (a__b  : THM) (a_thm : THM) (b_thm : THM) = (
let
	val (a,b) = dest_(concl a__b);
	val s1 = Š_intro a a_thm;
	val s2 = Š_intro b b_thm;
	val s3 = simple_list_ƒ_elim [a, b] _thm;
	val s4 = ‚_mp_rule s3 a__b;
	val s5 = simple_ƒ_elim (concl a_thm) s4;
	val s6 = Š_elim s5 s1;
	val s7 = Š_elim s6 s2;
in
	(prof "_elim";
	s7)
end
handle complaint =>
list_divert complaint "_elim" [
	("dest_",7010,[]),
	("Š_elim",7083,[])]
);
=TEX
Then another out of place theorem:
ó
Œ_thm = … ƒ t Ž (Œ t) = (t Š F)
æ
=SML
local
	val s1 = ap_arg_rule »t : BOOL¼ Œ_def;
	val s2 = conv_rule (TRAVERSE_C simple_%beta%_conv) s1;
	val s3 = simple_ƒ_intro »t : BOOL¼ s2;
in
	val Œ_thm = save_thm("âŒ_thmá", s3)
end;
=TEX
Roughly as 5.17 of \cite{DS/FMU/IED/SML009}:
First prove the local theorem:
ó
ƒ t Ž (Œ t Š F) Š t
æ
=SML
local
	val s1 = asm_rule »(t Š F) Š F¼;
	val s2 = asm_rule »t ‚ F¼;
	val s4 = subst_rule[(s2,»t : BOOL¼)] (concl s1) s1;
	val s5 = asm_rule F;
	val s6 = Š_intro F s5;
	val s7 = Š_elim s4 s6;
	val s8 = eq_sym_rule s2;
	val s9 = ‚_mp_rule s8 s7;
	val s10 = asm_rule »t = T¼;
	val s11 = ‚_t_elim s10;
	val s13 = simple_ƒ_elim »t : BOOL¼ bool_cases_axiom;
	val s14 = _elim s13 s11 s9;
	val s15 = Š_intro »(t Š F) Š F¼ s14;
	val s16 = simple_ƒ_elim »t : BOOL¼ Œ_thm;
	val s17 = eq_sym_rule s16;
	val s18 = conv_rule (ONCE_TRAVERSE_C (fn x =>
		if x = »t Š F¼ then s17 else (fail_conv x))) s15;
	val s19 = simple_ƒ_intro »t : BOOL¼ s18;
in
=TEX
now the main function:
=SML
fun âc_contr_ruleá (t : TERM) (thm : THM) : THM = (
let
	val mf_s1 = simple_ƒ_elim t s19;
	val Œ_t = mk_Œ t;
	val mf_s2 = disch_rule Œ_t thm;
	val mf_s3 = Š_elim mf_s1 mf_s2
in
	(prof "c_contr_rule";
	mf_s3)
end
handle complaint =>
list_divert complaint "c_contr_rule" [
	("simple_ƒ_elim", 7002, []),
	("disch_rule", 7003, [])]
);
end;
=TEX
\subsection{Concerning Negation}
This is entirely new:
we first prove the local theorem:
ó
… ƒ a Ž (Œ a) ‚ (a Š ƒ b Ž b)
æ
=SML
local
	val s1 = conv_rule(ONCE_TRAVERSE_C(fn x =>
		if x = F then f_def else fail_conv x))
		Œ_thm;
in
fun âŒ_elimá (tm : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let
	val s2 = simple_ƒ_elim (concl thm1) s1;
	val s3 = ‚_mp_rule s2 thm2;
	val s4 = Š_elim s3 thm1;
	val s5 = simple_ƒ_elim tm s4
in
	(prof "Œ_elim";
	s5)
end
handle complaint =>
list_divert complaint "Œ_elim" [
	("‚_mp_elim",7060,[]),
	("simple_ƒ_elim",7002,[])
	]
);
end;
=TEX
	
This is entirely new:
we first prove:
ó
s13 = … ƒ a b Ž (a Š b) Š (a Š Œb) Š Œa
æ
=SML
local
	val s1 = asm_rule »a Š b¼;
	val s2 = undisch_rule s1;
	val s3 = asm_rule »a Š Œ b¼;
	val s4 = undisch_rule s3;
	val s5 = Œ_elim F s2 s4;
	val s6 = Š_intro »a : BOOL¼ s5;
	val s7 = simple_ƒ_elim »a : BOOL¼ Œ_thm;
	val s8 = eq_sym_rule s7;
	val s9 = conv_rule (ONCE_TRAVERSE_C (fn x =>
		if x = »a Š F¼ then s8 else (fail_conv x))) s6;
	val s10 = Š_intro »a Š Œ b¼ s9;
	val s11 = Š_intro »a Š b¼ s10;
	val s12 = simple_ƒ_intro »b : BOOL¼ s11;
	val s13 = simple_ƒ_intro »a : BOOL¼ s12;
in
=TEX
Main function:
=SML
fun âŒ_introá (t : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let
	val mf_s1 = Š_intro t thm1;
	val mf_s2 = Š_intro t thm2;
	val mf_s3 = simple_list_ƒ_elim [t, concl thm1] s13;
	val mf_s4 = Š_elim mf_s3 mf_s1;
	val mf_s5 = Š_elim mf_s4 mf_s2
in
	(prof "Œ_intro";
	mf_s5)
end
handle complaint =>
list_divert complaint "Œ_intro" [
	("Š_elim", 7004, []),
	("simple_ƒ_elim", 7002, [])]
);
end;
=TEX
Prove the following (out of sequence)
ó
f_thm = … Œ F
æ
=SML
local
	val s1 = asm_rule F;
	val s2 = Š_intro F s1;
	val s3 = simple_ƒ_elim F Œ_thm;
	val s4 = eq_sym_rule s3;
	val s5 = ‚_mp_rule s4 s2;
in
	val f_thm = save_thm("f_thm",s5)
end;
=TEX
Prove the following (out of sequence)
ó
Œ_t_thm = … Œ T ‚ F
æ
=SML
local
	val s1 = simple_ƒ_elim »Œ T¼ bool_cases_axiom;
	val s2 = asm_rule »(Œ T) ‚ F¼;
	val s3 = asm_rule »Œ T ‚ T¼;
	val s4 = ‚_t_elim s3;
	val s5 = Œ_elim  »Œ T ‚ F¼ t_thm s4;
	val s6 = _elim s1  s5 s2;
in
	val Œ_t_thm = save_thm("âŒ_t_thmá",s6)
end;
=TEX
We prove the local theorems:
ó
s14 = … Œ(Œ t) ‚ t
s16 = … t ‚ Œ(Œ t)
æ
=SML
local
	val s1 = ‚_t_intro f_thm;
	val s2 = ap_fun_rule »$Œ¼ s1;
	val s3 = eq_trans_rule s2 Œ_t_thm;
	val s4 = ap_fun_rule »$Œ¼ Œ_t_thm;
	val s5 = eq_trans_rule s4 s1;
	val s6 = asm_rule »t ‚ T¼;
	val s7 = eq_sym_rule s6;
	val s8 = subst_rule [(s7,»x : BOOL¼)] »Œ(Œ x) ‚ x¼ s5;
	val s9 = asm_rule »t ‚ F¼;
	val s10 = eq_sym_rule s9;
	val s11 = subst_rule [(s10,»x : BOOL¼)] »Œ(Œ x) ‚ x¼ s3;
	val s12 = simple_ƒ_elim »t : BOOL¼ bool_cases_axiom;
	val s13 = _elim s12 s8 s11;
	val s14 = simple_ƒ_intro »t : BOOL¼ s13;
	val s15 = eq_sym_rule s13;
	val s16 = simple_ƒ_intro »t : BOOL¼ s15;
in
=TEX
Main functions:
=SML
fun âŒ_Œ_introá (thm : THM) : THM = (
let
	val mf_s1 = simple_ƒ_elim (concl thm) s16;
	val mf_s2 = ‚_mp_rule mf_s1 thm
in
	(prof "Œ_Œ_intro";
	mf_s2)
end);

fun âŒ_Œ_elimá (thm : THM) : THM = (
let
	val bdy = dest_Œ(dest_Œ(concl thm));
	val mf_s1 = simple_ƒ_elim bdy s14;
	val mf_s2 = ‚_mp_rule mf_s1 thm
in
	(prof "Œ_Œ_elim";
	mf_s2)
end
handle complaint =>
divert complaint "dest_Œ" "Œ_Œ_elim" 7006 []
);
end; (* local *)
=TEX
\subsection{Concerning €}
ó
€_thm = … ƒ t1 t2 Ž (t1 € t2) = (ƒ b Ž (t1 Š t2 Š b) Š b)
æ
=SML
local
	val s1 = ap_arg_rule »t1 : BOOL¼ €_def;
	val s2 = ap_arg_rule »t2 : BOOL¼ s1;
	val s3 = conv_rule (TRAVERSE_C simple_%beta%_conv) s2;
	val s4 = simple_ƒ_intro »t2 : BOOL¼ s3;
	val s5 = simple_ƒ_intro »t1 : BOOL¼ s4;
in
	val €_thm = save_thm("â€_thmá",s5)
end;
=TEX
Following \cite{DS/FMU/IED/SML009} 5.10:
We prove the local theorem:
ó
s14 = ƒ t1 t2 Ž t1 Š t2 Š (t1 € t2)
æ
=SML
local
	val s1 = asm_rule »t1 Š t2 Š b¼;
	val s3 = undisch_rule s1;
	val s5 = undisch_rule s3;
	val s6 = Š_intro »t1 Š t2 Š b¼ s5;
	val s7 = simple_ƒ_intro »b : BOOL¼ s6;
	val s8 = simple_list_ƒ_elim [»t1 : BOOL¼, »t2 : BOOL¼] €_thm;
	val s9 = eq_sym_rule s8;
	val s10 = ‚_mp_rule s9 s7;
	val s11 = Š_intro »t2 : BOOL¼ s10;
	val s12 = Š_intro »t1 : BOOL¼ s11;
	val s13 = simple_ƒ_intro »t2 : BOOL¼ s12;
	val s14 = simple_ƒ_intro »t1 : BOOL¼ s13;
in
fun â€_introá (thm1 : THM) (thm2 : THM) : THM = (
let
	val mf_s1 = simple_list_ƒ_elim[concl thm1, concl thm2] s14;
	val mf_s2 = Š_elim mf_s1 thm1;
	val mf_s3 = Š_elim mf_s2 thm2;
in
	(prof "€_intro";
	mf_s3)
end);
end;
=TEX
We prove the local theorem:
ó
s11 = ƒ t1 t2 Ž (t1 € t2) Š t1
æ
=SML
local 
	val s1 = simple_list_ƒ_elim [»t1 : BOOL¼, »t2 : BOOL¼] €_thm;
	val s2 = asm_rule »t1 € t2¼;
	val s3 = ‚_mp_rule s1 s2;
	val s4 = simple_ƒ_elim »t1 : BOOL¼ s3;
	val s5 = asm_rule »t1 : BOOL¼;
	val s6 = Š_intro »t2 : BOOL¼ s5;
	val s7 = Š_intro »t1 : BOOL¼ s6;
	val s8 = Š_elim s4 s7;
	val s9 = Š_intro »t1 € t2¼ s8;
	val s10 = simple_ƒ_intro »t2 : BOOL¼ s9;
	val s11 = simple_ƒ_intro »t1 : BOOL¼ s10;
in
fun â€_left_elimá (thm :THM) : THM = (
let
	val (t1,t2) = dest_€(concl thm);
	val mf_s1 = simple_list_ƒ_elim [t1, t2] s11;
	val mf_s2 = Š_elim mf_s1 thm;
in
	(prof "€_left_elim";
	mf_s2)
end
handle complaint =>
divert complaint "dest_€" "€_left_elim" 7007 []
);
end;
=TEX
We prove the local theorem:
ó
s11 = ƒ t1 t2 Ž (t1 € t2) Š t2
æ
=SML
local 
	val s1 = simple_list_ƒ_elim [»t1 : BOOL¼, »t2 : BOOL¼] €_thm;
	val s2 = asm_rule »t1 € t2¼;
	val s3 = ‚_mp_rule s1 s2;
	val s4 = simple_ƒ_elim »t2 : BOOL¼ s3;
	val s5 = asm_rule »t2 : BOOL¼;
	val s6 = Š_intro »t2 : BOOL¼ s5;
	val s7 = Š_intro »t1 : BOOL¼ s6;
	val s8 = Š_elim s4 s7;
	val s9 = Š_intro »t1 € t2¼ s8;
	val s10 = simple_ƒ_intro »t2 : BOOL¼ s9;
	val s11 = simple_ƒ_intro »t1 : BOOL¼ s10;
in
fun â€_right_elimá (thm :THM) : THM = (
let
	val (t1,t2) = dest_€(concl thm);
	val mf_s1 = simple_list_ƒ_elim [t1, t2] s11;
	val mf_s2 = Š_elim mf_s1 thm;
in
	(prof "€_right_elim";
	mf_s2)
end
handle complaint =>
divert complaint "dest_€" "€_right_elim" 7007 []
);
end;
=TEX
=SML
fun âlist_€_introá ([] : THM list) : THM = (
	fail "list_€_intro" 0000 []
) | list_€_intro thm_lst = (
let
	fun aux [thm] = thm
	| aux (thm :: rest) = €_intro thm (aux rest)
	| aux _ = error "list_€_intro" 0000 []
in
	(prof "list_€_intro";
	aux thm_lst)
end);

=TEX
=SML
fun âstrip_€_ruleá (thm : THM) : THM list = (
let
	fun aux thm1 = (
	let	val s1 = €_left_elim thm1;
		val s2 = €_right_elim thm1;
	in
		aux s1 @ aux s2
	end
	handle (Fail _) => [thm1]
	);
in
	(prof "strip_€_rule";
	aux thm)
end);
=TEX
Leave $€\_Š\_rule$ and $Š\_€\_rule$ until
later as of minor import, and tautology proving makes them simple.
\subsection{Concerning }
As \cite{DS/FMU/IED/SML009} 5.13.
We prove the local theorem:
ó
s12 … ƒ t1 t2 Ž t1 Š (t1  t2)
æ
=SML
local
	val s1 = asm_rule »t1 Š b¼;
	val s3 = undisch_rule s1;
	val s4 = Š_intro »t2 Š b¼ s3;
	val s5 = Š_intro »t1 Š b¼ s4;
	val s6 = simple_ƒ_intro »b :BOOL¼ s5;
	val s7 = simple_list_ƒ_elim [»t1 : BOOL¼,»t2 : BOOL¼] _thm;
	val s8 = eq_sym_rule s7;
	val s9 =  ‚_mp_rule s8 s6;
	val s10 = Š_intro »t1 : BOOL¼ s9;
	val s11 = simple_ƒ_intro »t2 : BOOL¼ s10;
	val s12 = simple_ƒ_intro »t1 : BOOL¼ s11;
in
fun â_right_introá (tm : TERM) (thm : THM) : THM = (
let
	val mf_s1 = simple_list_ƒ_elim [concl thm, tm] s12 ;
	val mf_s2 = Š_elim mf_s1 thm
in
	(prof "_right_intro";
	mf_s2)
end
handle complaint =>
divert complaint "simple_list_ƒ_elim" "_right_intro" 7002 []
);
end;
=TEX
We prove the local theorem:
ó
s12 … ƒ t1 t2 Ž t2 Š (t1  t2)
æ
=SML
local
	val s1 = asm_rule »t2 Š b¼;
	val s3 = undisch_rule s1;
	val s4 = Š_intro »t2 Š b¼ s3;
	val s5 = Š_intro »t1 Š b¼ s4;
	val s6 = simple_ƒ_intro »b :BOOL¼ s5;
	val s7 = simple_list_ƒ_elim [»t1 : BOOL¼,»t2 : BOOL¼] _thm;
	val s8 = eq_sym_rule s7;
	val s9 =  ‚_mp_rule s8 s6;
	val s10 = Š_intro »t2 : BOOL¼ s9;
	val s11 = simple_ƒ_intro »t2 : BOOL¼ s10;
	val s12 = simple_ƒ_intro »t1 : BOOL¼ s11;
in
fun â_left_introá (tm : TERM) (thm : THM) : THM = (
let
	val mf_s1 = simple_list_ƒ_elim [tm, concl thm] s12 ;
	val mf_s2 = Š_elim mf_s1 thm
in
	(prof "_left_intro";
	mf_s2)
end
handle complaint =>
divert complaint "simple_list_ƒ_elim" "_left_intro" 7002 []
);
end;
=TEX
Entirely new:
We prove the prove the local theorem:
ó
Œ_1_thm =  … ƒ t Ž (Œ t) ‚ (t ‚ F)
æ
=SML
local
	val s1 = asm_rule F;
	val s2 = contr_rule »t : BOOL¼ s1;
	val s3 = Š_intro F s2;
	val s4 = asm_rule »t Š F¼;
	val s5 = simple_list_ƒ_elim [»t : BOOL¼, F] Š_antisym_axiom;
	val s6 = Š_elim s5 s4;
	val s7 = Š_elim s6 s3;
	val s8 = Š_intro »t Š F¼ s7;
	val s9 = simple_ƒ_elim  »t : BOOL¼ Œ_thm;
	val s10 = eq_sym_rule s9;
	val s11 = subst_rule[(s10,»x : BOOL¼)] »x Š (t ‚ F)¼ s8;
	val s12  = asm_rule »t ‚ F¼;
	val s13 = eq_sym_rule s12;
	val s14 = subst_rule[(s13,»x : BOOL¼)]»Œ x¼  f_thm;
	val s15 = Š_intro »t ‚ F¼ s14;
	val s16 = simple_list_ƒ_elim [»Œ t¼, »t ‚ F¼] Š_antisym_axiom;
	val s17 = Š_elim s16 s11;
	val s18 = Š_elim s17 s15;
	val s19 = simple_ƒ_intro »t : BOOL¼ s18;
in
val  Œ_1_thm = save_thm("âŒ_1_thmá",s19);
end;
=TEX
We then locally prove:
ó
s10 … ƒ t1 t2 Ž (t1  t2) Š (Œ t2) Š t1
s17 … ƒ t1 t2 Ž (t1  t2) Š (Œ t1) Š t2
æ
=SML
local
	val s1 = asm_rule »t1  t2¼;
	val s2 = asm_rule »t1 : BOOL¼;
	val s3 = asm_rule »t2 : BOOL¼;
	val s4 = asm_rule »Œ t2¼;
	val s5 = Œ_elim »t1 : BOOL¼ s3 s4;
	val s6 = _elim s1 s2 s5;
	val s7 = Š_intro »Œ t2¼ s6;
	val s8 = Š_intro »t1  t2¼ s7;
	val s9 = simple_ƒ_intro »t2 : BOOL¼ s8;
	val s10 = simple_ƒ_intro »t1 : BOOL¼ s9;

	val s11 = asm_rule  »Œ t1¼;
	val s12 = Œ_elim »t2 : BOOL¼ s2 s11;
	val s13 = _elim s1 s12 s3;
	val s14 = Š_intro »Œ t1¼ s13;
	val s15 = Š_intro »t1  t2¼ s14;
	val s16 = simple_ƒ_intro »t2 : BOOL¼ s15;
	val s17 = simple_ƒ_intro »t1 : BOOL¼ s16;
in
fun â_cancel_ruleá (thm1 : THM) (thm2 : THM) : THM = (
let
	val (t1,t2) = dest_ (concl thm1);
in
(let
	val mf_s1 = simple_list_ƒ_elim [t1,t2] s10;
	val mf_s2 = Š_elim mf_s1 thm1;
	val mf_s2 = Š_elim mf_s2 thm2;
in
	(prof "_cancel_rule";
	mf_s2)
end
handle Fail _ =>
let
	val mf_s1 = simple_list_ƒ_elim [t1,t2] s17;
	val mf_s2 = Š_elim mf_s1 thm1;
	val mf_s2 = Š_elim mf_s2 thm2;
in
	(prof "_cancel_rule";
	mf_s2)
end)
end
handle complaint =>
list_divert complaint "_cancel_rule" [
	("dest_",7010,[]),
	("Š_elim",7050,[])]
);
end;
=TEX
\subsection{Concerning Š}
Can only do $Š\_match\_mp\_rule$ after we have $ƒ\_elim$.
=SML
fun âstrip_Š_ruleá (thm : THM) : THM = (
	if is_Š(concl thm)
	then strip_Š_rule(undisch_rule thm)
	else thm
);
=TEX
Note that the following will merge $\alpha$-convertible
assumptions into single hypotheses.
=SML
fun âall_Š_introá (thm : THM) : THM = (
	if is_nil(hyps thm)
	then thm
	else all_Š_intro(Š_intro (hd(hyps thm)) thm)
);
=TEX
Local theorem:
ó
s10 … ƒ t1 t2 t3 Ž (t1 Š t2) Š (t2 Š t3) Š (t1 Š t3)
æ
=SML
local
	val s1 = asm_rule »t1 Š t2¼;
	val s2 = asm_rule »t2 Š t3¼;
	val s3 = undisch_rule s1;
	val s4 = Š_elim s2 s3;
	val s5 = Š_intro »t1 : BOOL¼ s4;
	val s6 = Š_intro »t2 Š t3¼ s5;
	val s7 = Š_intro »t1 Š t2¼ s6;
	val s8 = simple_ƒ_intro »t3 : BOOL¼ s7;
	val s9 = simple_ƒ_intro »t2 : BOOL¼ s8;
	val s10 = simple_ƒ_intro »t1 : BOOL¼ s9;
in
fun âŠ_trans_ruleá (thm1 : THM) (thm2 : THM) : THM = (
let
	val (t1,t2) = dest_Š(concl thm1)
		handle complaint =>
		divert complaint "dest_Š" "Š_trans_rule" 7040 [];
	val (t2',t3) = dest_Š(concl thm2)
		handle complaint =>
		divert complaint "dest_Š" "Š_trans_rule" 7041 [];
	val mf_s1 = simple_list_ƒ_elim[t1, t2, t3] s10;
	val mf_s2 = Š_elim mf_s1 thm1;
	val mf_s3 = Š_elim mf_s2 thm2
		handle complaint =>
		divert complaint "Š_elim" "Š_trans_rule" 7042 [];
in
	(prof "Š_trans_rule";
	mf_s3)
end);
end;
=TEX
ó
s13 … ƒ t1 t2 Ž (t1 Š t2) Š (Œ t2) Š (Œ t1)
æ
=SML
local
	val s1 = asm_rule »t1 : BOOL¼;
	val s2 = asm_rule »t1 Š t2¼;
	val s3 = Š_elim s2 s1;
	val s4 = asm_rule »Œ t2¼;
	val s5 = Œ_elim F s3 s4;
	val s6 = Š_intro »t1 : BOOL¼ s5;
	val s7 = simple_ƒ_elim »t1 : BOOL¼ Œ_thm;
	val s8 = eq_sym_rule s7;
	val s9 = ‚_mp_rule s8 s6;
	val s10 = Š_intro »Œ t2¼ s9;
	val s11 = Š_intro »t1 Š t2¼ s10;
	val s12 = simple_ƒ_intro »t2 : BOOL¼ s11;
	val s13 = simple_ƒ_intro »t1 : BOOL¼ s12;
in
fun âmodus_tollens_ruleá (thm1 : THM) (thm2 : THM) : THM = (
let
	val (t1,t2) = dest_Š(concl thm1);
	val mf_s1 = simple_list_ƒ_elim[t1,t2] s13;
	val mf_s2 = Š_elim mf_s1 thm1;
	val mf_s3 = Š_elim mf_s2 thm2;
in
	(prof "modus_tollens_rule";
	mf_s3)
end
handle complaint =>
list_divert complaint "modus_tollens_rule" [
	("dest_Š",7040,[]),
	("Š_elim",7051,[])]
);
end;
=TEX
\subsection{Concerning ‚}
=SML
fun â‚_introá (thm1 : THM) (thm2 : THM) : THM = (
let 	val (t1,t2) = dest_Š (concl thm1)
		handle complaint =>
		divert complaint "dest_Š" "‚_intro" 7040 [];
	val (t2',t1') = dest_Š (concl thm2) (* dummy test *)
		handle complaint =>
		divert complaint "dest_Š" "‚_intro" 7041 [];
	val s1 = simple_list_ƒ_elim[t1,t2] Š_antisym_axiom;
	val s2 = Š_elim s1 thm1;
	val s3 = Š_elim s2 thm2
		handle complaint =>
		divert complaint "Š_elim" "‚_intro" 7064 [];
in
	(prof "‚_intro";
	s3)
end);
=TEX
We prove the local theorems (two of them because getting
the two conjuncts if we did one would take similar, if not greater effort)
ó
s8 … (t1 ‚ t2) Š (t1 Š t2)
s14 … (t1 ‚ t2) Š (t2 Š t1)
æ
=SML
local
	val s1 = asm_rule »t1 ‚ t2¼;
	val s2 = asm_rule »t1 : BOOL¼;
	val s3 = asm_rule »t2 : BOOL¼;
	val s4 = ‚_mp_rule s1 s2;
	val s5 = Š_intro »t1 : BOOL¼ s4;
	val s6 = Š_intro »t1 ‚ t2¼  s5;
	val s7 = simple_ƒ_intro»t2 : BOOL¼ s6;
	val s8 = simple_ƒ_intro»t1 : BOOL¼ s7;
	
	val s9 = eq_sym_rule s1;
	val s10 = ‚_mp_rule s9 s3;
	val s11 = Š_intro »t2 : BOOL¼ s10;
	val s12 = Š_intro »t1 ‚ t2¼  s11;
	val s13 = simple_ƒ_intro»t2 : BOOL¼ s12;
	val s14 = simple_ƒ_intro»t1 : BOOL¼ s13;
in
fun â‚_elimá (thm : THM) : (THM * THM) = (
let
	val (t1,t2) = dest_‚(concl thm);
	val mf_s1 = simple_list_ƒ_elim[t1,t2]s8;
	val mf_s2 = Š_elim mf_s1 thm;
	val mf_s3 = simple_list_ƒ_elim[t1,t2]s14;
	val mf_s4 = Š_elim mf_s3 thm;
in
	(prof "‚_elim";
	(mf_s2, mf_s4))
end
handle complaint =>
divert complaint "dest_‚" "‚_elim" 7062 []
);
end;
=TEX
\subsection{Concerning =}
=SML
fun âsubst_convá (thm_lst : (THM * TERM) list) : (TERM -> CONV) = (
let
		val s1 = subst_rule thm_lst
			handle complaint =>
			pass_on complaint "subst_rule" "subst_conv";
in
	(fn (template : TERM) =>
	(fn (tm : TERM) =>
	let
		val new_template = mk_eq(tm,template)
			handle complaint =>
			divert complaint "mk_eq" "subst_conv" 7084 [];
		val s2 = refl_conv tm;
		val s3 = s1 new_template s2					handle complaint =>
			pass_on complaint "subst_rule" "subst_conv";
	in
		(prof "subst_conv";
		s3)
	end))
end);
=TEX

We prove a local theorem:
ó
s9 … ƒ t1 t2 Ž (t1 = t2) ‚ (t2 = t1)
æ
=SML
local
	val s1 = asm_rule »(t1 : 'a) = t2¼;
	val s2 = eq_sym_rule s1;
	val s3 = Š_intro »(t1 : 'a) = t2¼ s2;
	val s4 = asm_rule »(t2 : 'a) = t1¼;
	val s5 = eq_sym_rule s4;
	val s6 = Š_intro »(t2 : 'a) = t1¼ s5;
	val s7 = ‚_intro s3 s6;
	val s8 = simple_ƒ_intro »t2 : 'a¼ s7;
	val s9 = simple_ƒ_intro »t1 : 'a¼ s8;
in
val âeq_sym_convá : CONV = (fn (tm : TERM) =>
let
	val (t1,t2) = dest_eq tm;
	val mf_s1 = inst_type_rule[(type_of t1,mk_vartype"'a")] s9;
	val mf_s2 = simple_list_ƒ_elim[t1,t2] mf_s1;
in
	(prof "eq_sym_conv";
	mf_s2)
end
handle complaint =>
divert complaint "dest_eq" "eq_sym_conv" 7090 []
);
end;
=TEX
We prove a local theorem:
ó
s … ƒ t1 t2 :'a Ž Œ(t1 = t2) ‚ Œ(t2 = t1)
æ
=SML
local
	val s1 = eq_sym_conv »(t1 : 'a) = t2¼;
	val s2 = ap_fun_rule »$Œ¼ s1;
	val s3 = simple_ƒ_intro »t2 : 'a¼ s2;
	val s4 = simple_ƒ_intro »t1 : 'a¼ s3;
in
fun âŒ_eq_sym_ruleá (thm : THM) : THM = (
let
	val (t1,t2) = dest_eq(dest_Œ(concl thm));
	val mf_s1 = inst_type_rule[(type_of t1,mk_vartype "'a")] s4;
	val mf_s2 = simple_list_ƒ_elim [t1,t2] mf_s1;
	val mf_s3 = ‚_mp_rule mf_s2 thm;
in
	(prof "Œ_eq_sym_rule";
	mf_s3)
end
handle complaint =>
list_divert complaint "Œ_eq_sym_rule" [
	("dest_eq",7091,[]),
	("dest_Œ",7091,[])]
);
end;
=TEX

\subsection{Concerning ƒ}
=RULE
simple_list_ƒ_intro
[»x1¼, ..., »xn¼]
É
ö … t[x1, ..., xn]
É
ö … ƒ x1 ... xn Ž t[x1, ..., xn]
=TEX
=SML
val âsimple_list_ƒ_introá = fold (uncurry simple_ƒ_intro);
=TEX
\subsection{Concerning ‡}
=SML
fun â‡_intro_ruleá (thm : THM) : THM = (
let
	val (tm1, tm2) = dest_comb (concl thm);
	val s1 = inst_type_rule [(type_of tm2, mk_vartype "'a")] ‡_axiom;
	val s2 = simple_ƒ_elim tm1 s1;
	val s3 = simple_ƒ_elim tm2 s2;
	val s4 = Š_elim s3 thm;
in
	(prof "‡_intro_rule";
		s4)
end
handle complaint =>
divert complaint "dest_comb" "‡_intro_rule" 7016 []
);
=TEX

=SML
fun â‡_elim_ruleá (tm : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let
	val (tm1, ctm1) = dest_comb (concl thm1);
	val tm1tm = mk_comb (tm1, tm)
		handle complaint =>
		divert complaint "mk_comb" "‡_elim_rule" 7005 [];
	val s1 = Š_intro tm1tm thm2;
	val s2 = simple_ƒ_intro tm s1;
	val s3 = simple_ƒ_elim ctm1 s2;
	val s4 = Š_elim s3 thm1;
in
	(prof "‡_elim_rule";
		s4)
end
handle complaint =>
list_divert complaint "‡_elim_rule" [
	("term_match",3054,[]),
	("‚_mp_rule",6024,[])
	]
);
=IGN
A test:
‡_elim_rule »x:BOOL¼ (asm_rule »( q Ž q  F)(‡ r Ž r  F)¼)
	(undisch_rule(simple_ƒ_elim »x:BOOL¼ (asm_rule
		»ƒ x : BOOL Ž ( s Ž s  F) x Š rubbish¼)));
=TEX
\subsection{Concerning „}
=SML
fun âsimple_„_introá (tm : TERM) (thm : THM) : THM = (
let
	val (x, t1x) = simple_dest_„ tm;
	val abs = snd(dest_comb tm);
	val t2 = case term_match (concl thm) t1x of
		(_, [(ltm, _)]) => ltm
		|(_, []) => x
		|Other	  => fail "simple_„_intro" 7047 [];
	val abst2 = mk_comb (abs, t2);
	val s1 = simple_%beta%_conv abst2;
	val s2 = eq_sym_rule s1;
	val s3 = ‚_mp_rule s2 thm;
	val s4 = ‡_intro_rule s3;
	val s5 = inst_type_rule [(type_of x, mk_vartype "'a")] „_def;
	val s6 = ap_arg_rule abs s5;
	val s7 = simple_%beta%_conv (snd(dest_eq(concl s6)));
	val s8 = eq_trans_rule s6 s7;
	val s9 = eq_sym_rule s8;
	val s10 = ‚_mp_rule s9 s4;
in
	(prof "simple_„_intro";
		s10)
end
handle complaint =>
list_divert complaint "simple_„_intro" [
	("simple_dest_„", 7094, []),
	("term_match", 7047, [])
	]
);
=IGN
simple_„_intro »„ p:BOOL Ž p ‚ (( x:BOOL Ž x) = ( x:BOOL Ž x))¼ t_def;

=TEX

=SML
fun âsimple_„_elimá (asm : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let
	val side_effect = if not(any (hyps thm2) (aconv asm) )
		then fail "simple_„_elim" 7013 []
		else();
	val cthm1 = concl thm1;
	val (x, tx) = simple_dest_„ cthm1;
	val t1 = snd(dest_comb cthm1);
	val tvx = case mg_variables [BOOL] ([(concl thm1), (concl thm2), asm] 
		@ hyps thm1 @ hyps thm2) of
		[term] => term
		| _ => error "simple_„_elim" 6032 [];
	val s1 = inst_type_rule [(type_of x, mk_vartype "'a")] „_def;
	val s2 = ap_arg_rule t1 s1;
	val s3 = ‚_mp_rule s2 thm1;
	val s5 = conv_rule simple_%beta%_conv s3;
	val v = case term_match asm tx of
		(_, [(ltm, _)]) => ltm
		|(_, []) => x
		|Other	  => fail "simple_„_elim" 7047 [];
	val s6 = mk_comb (t1, v);
	val s7 = simple_%beta%_conv s6;
	val s8 = eq_sym_rule s7;
	val s9 = Š_intro asm thm2;
	val s10 = mk_Š (tvx, concl thm2);
	val s11 = subst_rule [(s8, tvx)] s10 s9;
	val s12 = undisch_rule s11;
	val s13 = ‡_elim_rule v s5 s12;
in
	(prof "simple_„_elim";
		s13)
end
handle complaint =>
list_divert complaint "simple_„_elim" [
	("term_match",7109,[]),
	("mk_comb",7002,[]),
	("‚_mp_rule",7014,[])
	]
);
=IGN
A test:
simple_„_elim »x  F¼ (asm_rule »„ r Ž r  F¼)
	(undisch_rule(simple_ƒ_elim »x:BOOL¼ (asm_rule
		»ƒ x : BOOL Ž x  F Š rubbish¼)));
=TEX

=SML
val âsimple_„_‡_convá : CONV = (fn tm =>
let
	val (x, tx) = (simple_dest_„ tm);
	val t1 = simple_mk_abs (x, tx);
	val s1 = inst_type_rule [(type_of x, mk_vartype "'a")] „_def;
	
	val s2 = ap_arg_rule t1 s1;
	val s3 = concl s2;
	val conv1 = (RAND_C simple_%beta%_conv THEN_C
			RAND_C simple_%beta%_conv)
	val s4 = conv1 s3;
	val s5 = ‚_mp_rule s4 s2;
in
	(prof "simple_„_‡_conv";
		s5)
end
handle complaint =>
divert complaint "simple_dest_„" "simple_„_‡_conv" 7093 []
);
=IGN
simple_„_‡_conv »„ x Ž x € y  x¼;
=TEX

=SML
fun âsimple_„_‡_ruleá (thm : THM) : THM = (
	(prof "simple_„_‡_rule";
		conv_rule simple_„_‡_conv thm)
	handle complaint =>
	divert complaint "simple_„_‡_conv" "simple_„_‡_rule" 7092 []
);
=TEX
\subsection{Concerning $if\ldots then\ldots else \ldots$}
=SML
local
	val s1 = ap_arg_rule »a : BOOL¼ cond_def;
	val s2 = ap_arg_rule »t1 : 'a¼ s1;
	val s3 = ap_arg_rule »t2 : 'a¼ s2;
	val s4 = conv_rule (TRAVERSE_C simple_%beta%_conv) s3;
	val s5 = simple_ƒ_intro »t2 : 'a¼ s4;
	val s6 = simple_ƒ_intro »t1 : 'a¼ s5;
	val s7 = simple_ƒ_intro »a : BOOL¼ s6;

in
	val cond_thm = save_thm("âcond_thmá", s7);
end;
=TEX
We prove the local theorem:
ó
s35 … ƒ x a t1 t2 Ž (a Š (x = t1)) Š (Œ a Š (x = t2)) Š 
	(x = if a then t1 else t2)
æ
=SML
local
	val s1 = asm_rule »a Š ((x:'a) = t1)¼;
	val s2 = asm_rule »a ‚ T¼;
	val s3 = ‚_t_elim s2;
	val s4 = Š_elim s1 s3;
	val s5 = Š_intro »a ‚ T¼ s4;
	val s6 = asm_rule »Œ a Š ((x:'a) = t2)¼;
	val s7 = asm_rule »a ‚ F¼;
	val s8 = simple_ƒ_elim  »a : BOOL¼ Œ_1_thm;
	val s9 = eq_sym_rule s8;
	val s10 = ‚_mp_rule s9 s7;
	val s11 = Š_elim s6 s10;
	val s12 = Š_intro »a ‚ F¼ s11;
	val s13 = €_intro s5 s12;
	val s14 = simple_%beta%_conv 
		(mk_comb(
		(simple_mk_abs(»x : 'a¼, concl s13),
		»x : 'a¼)));
	val s15 = eq_sym_rule s14;
	val s16 = ‚_mp_rule s15 s13;
	val s17 = ‡_intro_rule s16;
	val s18 = simple_list_ƒ_elim[»a : BOOL¼, »t1 : 'a¼, »t2 : 'a¼] cond_thm;
	val s19 = eq_sym_rule s18;
	val s20 = subst_rule[(s19,»y : 'a¼)]
		(mk_comb(fst(dest_comb(concl s17)),»y : 'a¼))
		s17;
	val s21 = conv_rule simple_%beta%_conv s20;

	val s22 = €_left_elim s21;
	val s23 = undisch_rule s22;
	val s24 = eq_sym_rule s4;
	val s25 = subst_rule[(s24,»y : 'a¼)]
		(mk_comb(fst(dest_comb(concl s23)),»y : 'a¼))
		s23;
	
	val s26 = €_right_elim s21;
	val s27 = undisch_rule s26;
	val s28 = eq_sym_rule s11;
	val s29 = subst_rule[(s28,»y : 'a¼)]
		(mk_comb(fst(dest_comb(concl s27)),»y : 'a¼))
		s27;

	val s30 = simple_ƒ_elim »a : BOOL¼ bool_cases_axiom;
	val s31 = _elim s30 s25 s29;
	val s32 = eq_sym_rule s31;
	val s33 = Š_intro »Œ a Š ((x:'a) = t2)¼ s32;
	val s34 = Š_intro »a Š ((x:'a) = t1)¼ s33;
	val s35 = simple_list_ƒ_intro[»x : 'a¼, »a : BOOL¼, »t1 : 'a¼, »t2 : 'a¼] s34;
in
fun âif_introá (a : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let
	val (x,t1) = dest_eq(concl thm1);
	val (x',t2) = dest_eq(concl thm2);
	val mf_s1 = Š_intro a thm1;
	val mf_s2 = Š_intro (mk_Œ a) thm2;
	val mf_s3 = inst_type_rule[(type_of x,mk_vartype"'a")]
		s35;
	val mf_s4 = simple_list_ƒ_elim[x,a,t1,t2]mf_s3;
	val mf_s5 = Š_elim mf_s4 mf_s1;
	val mf_s6 = Š_elim mf_s5 mf_s2;
in
	(prof "if_intro";
	mf_s6)
end
handle complaint =>
list_divert complaint "if_intro" [
	("dest_eq",7065,[]),
	("Š_intro",7002,[])]
);
end; (* of local val s1 ... *)
=IGN
Tests:
if_intro »a : BOOL¼ (asm_rule »x  = p1¼)(asm_rule »x = p2¼);
if_intro  »b  : BOOL¼ (undisch_rule(asm_rule »b Š x = p1¼))
	(undisch_rule (asm_rule »Œ b Š x = p2¼));
=TEX
Prove the local theorem:
ó
s … ƒ x a t1 t2 Ž (x = if a then t1 else t2) Š (a Š x = t1)
æ
=SML
local
	val s1 = asm_rule »a : BOOL¼;
	val s2 = asm_rule »a ‚ F¼;
	val s3 = simple_ƒ_elim »a : BOOL¼ Œ_1_thm;
	val s4 = eq_sym_rule s3;
	val s5 = ‚_mp_rule s4 s2;
	val s6 = Œ_elim »(t1 : 'a) = t2¼ s1 s5;
	val s7 = Š_intro »a ‚ F¼ s6;
	val s8 = refl_conv »t1 : 'a¼;
	val s9 = Š_intro  »a ‚ T¼ s8;
	val s10 = €_intro s9 s7;

	val s11 = simple_%beta%_conv 
		»( y: 'a Ž ((a ‚ T) Š y = t1) € ((a ‚ F) Š y = t2)) t1¼;
	val s12 = eq_sym_rule s11;
	val s13 = ‚_mp_rule s12 s10;
	val s14 = ‡_intro_rule s13;
	val s15 = simple_list_ƒ_elim [»a : BOOL¼, »t1 : 'a¼, »t2 : 'a¼] cond_thm;
	val s16 = eq_sym_rule s15;
	val s17 = subst_rule[(s16,»z : 'a¼)]
		(mk_comb(fst(dest_comb(concl s14)),»z : 'a¼))
		s14;
	val s18 = asm_rule »(x:'a) = if a then t1 else t2¼;
	val s19 = eq_sym_rule s18;
	val s20 = subst_rule[(s19,»z : 'a¼)]
		(mk_comb(fst(dest_comb(concl s17)),»z : 'a¼))
		s17;
	val s21 =  conv_rule simple_%beta%_conv s20;
	val s22 = €_left_elim s21;
	val s23 = ‚_t_intro s1;
	val s25 = Š_elim s22 s23;
	val s26 = Š_intro »a : BOOL¼ s25;
	val s27 = Š_intro »(x:'a) = if a then t1 else t2¼ s26;
	val s28 = simple_list_ƒ_intro[»x : 'a¼, »a : BOOL¼, »t1 : 'a¼, »t2 : 'a¼] s27;
in
fun âif_then_elimá (thm : THM) = (
let
	val (x,ifa)= dest_eq(concl thm);
	val (a,t1,t2) = dest_if ifa;
	val mf_s1 = inst_type_rule[(type_of x,mk_vartype "'a")] s28;
	val mf_s2 = simple_list_ƒ_elim[x,a,t1,t2] mf_s1;
	val mf_s3 = Š_elim mf_s2 thm;
in
	(prof "if_then_elim";
	mf_s3)
end
handle complaint =>
list_divert complaint "if_then_elim" [
	("dest_eq",7012,[]),
	("dest_if",7012,[])]
);
end; (* of local val s1 = ... *)
=IGN
if_then_elim (asm_rule »5 = if T then 5 else 6¼);
=TEX
ó
s29 … ƒ x a t1 t2 Ž x = (if a then t1 else t2) Š Œ a Š x = t2
æ
=SML
local
	val s1 = asm_rule »Œ a ¼;
	val s2 = asm_rule »a ‚ T¼;
	val s4 = ‚_t_elim s2;
	val s6 = Œ_elim »(t2 : 'a) = t1¼ s4 s1;
	val s7 = Š_intro »a ‚ T¼ s6;
	val s8 = refl_conv »t2 : 'a¼;
	val s9 = Š_intro  »a ‚ F¼ s8;
	val s10 = €_intro s7 s9;

	val s11 = simple_%beta%_conv 
		»( y: 'a Ž ((a ‚ T) Š y = t1) € ((a ‚ F) Š y = t2)) t2¼;
	val s12 = eq_sym_rule s11;
	val s13 = ‚_mp_rule s12 s10;
	val s14 = ‡_intro_rule s13;
	val s15 = simple_list_ƒ_elim [»a : BOOL¼, »t1 : 'a¼, »t2 : 'a¼] cond_thm;
	val s16 = eq_sym_rule s15;
	val s17 = subst_rule[(s16,»z : 'a¼)]
		(mk_comb(fst(dest_comb(concl s14)),»z : 'a¼))
		s14;
	val s18 = asm_rule »(x:'a) = if a then t1 else t2¼;
	val s19 = eq_sym_rule s18;
	val s20 = subst_rule[(s19,»z : 'a¼)]
		(mk_comb(fst(dest_comb(concl s17)),»z : 'a¼))
		s17;
	val s21 =  conv_rule simple_%beta%_conv s20;
	val s22 = €_right_elim s21;
	val s23 = simple_ƒ_elim »a : BOOL¼ Œ_1_thm;
	val s24 = fst(‚_elim s23);
	val s25 = Š_trans_rule s24 s22;
	val s26 = Š_elim s25 s1;
	val s27 = Š_intro »Œ a¼ s26;
	val s28 = Š_intro »(x:'a) = if a then t1 else t2¼ s27;
	val s29 = simple_list_ƒ_intro[»x : 'a¼, »a : BOOL¼, »t1 : 'a¼, »t2 : 'a¼] s28;
in
fun âif_else_elimá (thm : THM) = (
let
	val (x,ifa)= dest_eq(concl thm);
	val (a,t1,t2) = dest_if ifa;
	val mf_s1 = inst_type_rule[(type_of x,mk_vartype "'a")] s29;
	val mf_s2 = simple_list_ƒ_elim[x,a,t1,t2] mf_s1;
	val mf_s3 = Š_elim mf_s2 thm;
in
	(prof "if_else_elim";
	mf_s3)
end
handle complaint =>
list_divert complaint "if_else_elim" [
	("dest_eq",7012,[]),
	("dest_if",7012,[])]
);
end; (* of local val s1 = ... *)
=IGN
if_else_elim (asm_rule »5 = if T then 5 else 6¼);
=TEX
ó
s … ƒ f a t1 t2 Ž f(if a then t1 else t2) =
	if a then (f t1) else (f t2)
æ
=SML
local
	val s1 = refl_conv »if a then (t1:'a) else t2¼;
	val s2 = if_then_elim s1;
	val s3 = undisch_rule s2;
	val s4 = ap_fun_rule »f : 'a ‹ 'b¼ s3;
	val s5 = if_else_elim s1;
	val s6 = undisch_rule s5;
	val s7 = ap_fun_rule »f : 'a ‹ 'b¼ s6;
	val s8 = if_intro »a : BOOL¼ s4 s7;
	val s9 = simple_list_ƒ_intro[»f : 'a ‹ 'b¼, »a : BOOL¼, »t1 : 'a¼, »t2 : 'a¼] s8;
in
val âfun_if_convá : CONV = (fn (tm : TERM) =>
let
	val (f,ifa) = dest_comb tm;
	val (a,t1,t2) = dest_if ifa;
	val (aty,bty) = dest_funtype(type_of f);
	val mf_s1 = inst_type_rule[(aty,mk_vartype"'a"),(bty,mk_vartype"'b")]s9;
	val mf_s2 = simple_list_ƒ_elim[f,a,t1,t2] mf_s1;
in
	(prof "fun_if_conv";
	mf_s2)
end
handle complaint =>
list_divert complaint "fun_if_conv" [
	("dest_comb",7098,[]),
	("dest_if",7098,[])]
);
end; (* local val s1 = ... *)
=IGN
fun_if_conv »( x Ž x = 1)(if T then 3 else 4)¼;
=TEX
=SML
fun âfun_if_ruleá (thm : THM) : THM = (
	conv_rule fun_if_conv thm
	handle complaint =>
	divert complaint "fun_if_conv" "fun_if_rule" 7053 []
);
=TEX
=SML
fun âif_fun_ruleá (thm : THM) : THM = (
let
	val (a,ft1,ft2) = dest_if(concl thm);
	val (f,t1) = dest_comb ft1;
	val (f',t2) = dest_comb ft2;
	val s1 = fun_if_conv (mk_comb(f,mk_if(a,t1,t2)));
	val s2 = eq_sym_rule s1;
	val s3 = ‚_mp_rule s2 thm;
in
	(prof "if_fun_rule";
	s3)
end
handle complaint =>
list_divert complaint "if_fun_rule" [
	("dest_if",7012,[]),
	("dest_comb",7052,[]),
	("‚_mp_rule",7052,[])]
);
=IGN
if_fun_rule (asm_rule »if a then (( x Ž x = 1) 2) else (( x Ž x = 1) 3)¼);
if_fun_rule (asm_rule »if a then (( x Ž x = 1) 2) else (( x Ž x = 2) 3)¼);
if_fun_rule (asm_rule »if a then T else Œ F¼);
=TEX
\subsection{Concerning Functional Application}
=SML
fun âext_ruleá (thm : THM) = (
let
	val (h,c) =dest_thm thm;
	val (f,g) = dest_eq c;
	val mgv = hd(mg_variables [fst(dest_funtype(type_of f))]
		(c :: h));
	val s1 = ap_arg_rule mgv thm;
	val s2 = simple_ƒ_intro mgv s1;
in
	(prof "ext_rule";
	s2)
end
handle complaint =>
list_divert complaint "ext_rule" [
	("dest_eq",7023,[]),
	("dest_funtype",7026,[])]
);
=IGN
ext_rule (refl_conv (hd(mg_variables [mk_fun(mk_vartype"'a",BOOL)][])));
=TEX
\subsection{Concerning Assumptions}
=SML
fun âasm_introá (tm : TERM) (thm : THM) : THM = (
let
	val s1 = Š_intro tm thm;
	val s2 = asm_rule tm;
	val s3 = Š_elim s1 s2;
in
	(prof "asm_intro";
	s3)
end
handle complaint =>
divert complaint "Š_intro" "asm_intro" 7002 []
);
=TEX
ó
s15 … ƒ a t Ž (a Š t) Š (Œ a Š t) Š t
æ
=SML
local 
	val s1 = simple_ƒ_elim »a : BOOL¼ bool_cases_axiom;
	val s2 = asm_rule »a Š t¼;
	val s3 = asm_rule »a ‚ T¼;
	val s4 = ‚_t_elim s3;
	val s5 = Š_elim s2 s4;
	val s6 = asm_rule »Œa Š t¼;
	val s7 = asm_rule »a ‚ F¼;
	val s8 = simple_ƒ_elim »a : BOOL¼ Œ_1_thm;
	val s9 = eq_sym_rule s8;
	val s10 = ‚_mp_rule s9 s7;
	val s11 = Š_elim s6 s10;
	val s12 = _elim s1 s5 s11;
	val s13 = Š_intro »Œa Š t¼ s12;
	val s14 = Š_intro »a Š t¼ s13;
	val s15 = simple_list_ƒ_intro[»a : BOOL¼,»t : BOOL¼] s14;
in
fun âasm_elimá (tm : TERM) (thm1 : THM) (thm2 : THM) = (
let
	val t = concl thm1;
	val mf_s1 = simple_list_ƒ_elim [tm,t] s15;
	val mf_s2 = Š_intro tm thm1;
	val mf_s3 = Š_intro (mk_Œ tm) thm2;
	val mf_s4 = Š_elim mf_s1 mf_s2;
	val mf_s5 = Š_elim mf_s4 mf_s3;
in
	(prof "asm_elim";
	mf_s5)
end
handle complaint =>
list_divert complaint "asm_elim" [
	("simple_ƒ_intro", 7002, []),
	("Š_elim",7029,[])]
);
end; (* local val s1 = ... *)
=IGN
asm_elim »a : BOOL¼ (undisch_rule (asm_rule » a Š b¼)) (undisch_rule (asm_rule » Œa Š b¼));
=TEX
=SML
fun âprove_asm_ruleá (thm1 : THM) (thm2 : THM) : THM = (
let
	val c1 = concl thm1;
	val s1 = disch_rule c1 thm2;
	val s2 = Š_elim s1 thm1;
in
	(prof "prove_asm_rule";
	s2)
end
handle complaint =>
divert complaint "disch_rule" "prove_asm_rule" 7037 []);
=IGN
prove_asm_rule (‚_t_elim(asm_rule»a ‚ T¼)) 
	(undisch_rule (asm_rule » a Š b¼));
=TEX
=SML
fun âasm_inst_type_ruleá  (tyl : (TYPE * TYPE) list) (thm : THM) : THM = (
let
	val nhyps = length(strip_Š (concl thm));
	val s1 = all_Š_intro thm;
	val nhyps1 = length(strip_Š (concl s1));
	val s2 = inst_type_rule tyl s1;
	val s3 = fold (fn (_,x) => undisch_rule x)
		(interval 1 (nhyps1 - nhyps)) s2;
in
	(prof "asm_inst_type_rule";
	s3)
end
handle complaint =>
pass_on complaint "inst_type_rule" "asm_inst_type_rule"
);
=IGN
val t1 = asm_rule »(x = y)Š (y = z)¼;
term_tyvars (concl t1);
val t2 = asm_inst_type_rule  [(BOOL,mk_vartype "'a")] t1;
term_tyvars (concl t2);
=TEX
\subsection{Concerning Matching Functions}
The function $apply\_matches\_rule$ encodes the matching attempt, should
a simple use of the rule fail.
It brings up to the conclusion all the hypotheses.
It instantiates types to the minimum required,
instantiates free variables to the minimum required
(notice that we must not instantiate the universally quantified variables of $thm$ that occur free in the assumptions:
thus $tmm'$)
and then returns are the hypotheses to the assumption list.
It then eliminates the universal quantifications either
to the requirement of the match, or the bound variable
if none.

Notice that the prototype used $GSPEC$ and $INST$
to do the same as $aux1$ - I suspect our mixed approach is faster.
=SML
fun âapply_matches_ruleá (caller : string) 
	(tym : (TYPE * TYPE)list)
	(tmm : (TERM * TERM)list) 
	(thm : THM) : THM = (
let
	val c = concl thm;
	val nhyps = length(strip_Š c);
	val s1 = all_Š_intro thm;
	val nhyps1 = length(strip_Š (concl s1));
	val s2 = inst_type_rule tym s1;
	val bvs = fst(strip_ƒ (hd(rev(strip_Š (concl s2)))));
	val tmm' = tmm drop (fn (_,x) => x mem bvs);
	val s3 = inst_term_rule tmm' s2;
	val s4 = fold (fn (_,x) => undisch_rule x)
		(interval 1 (nhyps1 - nhyps)) s3;

	fun aux1 (athm : THM) : THM = (
	let
		val (qv,b) = simple_dest_ƒ(concl athm);
	in
		aux1 (simple_ƒ_elim (rassoc1 tmm qv) athm)
	end
	handle (Fail _) => athm);

	val s5 = aux1 s4;
in
	s5
end
handle (Fail _) => fail caller 7044 []
);
=TEX
Now we use the above in the various forms of matching.
=SML
local
fun aux (thm1 : THM) (thm2 : THM) : THM = (
let
	val (t1,_) = dest_Š (snd(strip_ƒ (concl thm1)));
	val (tym,tmm) = term_match (concl thm2) t1;
	val s1 = apply_matches_rule "simple_Š_match_mp_rule" tym tmm thm1;
	val s2 = Š_elim s1 thm2;
in
	(prof "simple_Š_match_mp_rule";
	s2)
end
handle complaint =>
list_divert complaint "simple_Š_match_mp_rule" [
	("dest_Š", 7042, []),
	("term_match", 7044, [])]
);
in
fun âsimple_Š_match_mp_ruleá (thm1 : THM) (thm2 : THM) : THM = (	
	let val s1 = Š_elim thm1 thm2;
	in
	 	(prof "simple_Š_match_mp_rule";
		s1)
	end
	handle complaint =>
	aux thm1 thm2
);
end;
=IGN
val thm1 = simple_ƒ_elim »x : 'a¼ (asm_rule »ƒ x y Ž f x y Š b¼);
val thm2 = asm_rule »f 1 2 : BOOL¼;
simple_Š_match_mp_rule thm1 thm2;
val thm1 = simple_ƒ_elim »x : 'a¼ (asm_rule »ƒ x y Ž f x y Š b Š c¼);
val thm2 = asm_rule »f 1 2 : BOOL¼;
simple_Š_match_mp_rule thm1 thm2;
=TEX
=SML
local
fun aux (thm1 : THM) (thm2 : THM) : THM = (
let
	val (t1,_) = dest_‚ (snd(strip_ƒ (concl thm1)));
	val (tym,tmm) = term_match (concl thm2) t1;
	val s1 = apply_matches_rule "simple_‚_match_mp_rule" tym tmm thm1;
	val s2 = ‚_mp_rule s1 thm2;
in
	(prof "simple_‚_match_mp_rule";
	s2)
end
handle complaint =>
list_divert complaint "simple_‚_match_mp_rule" [
	("dest_‚", 7099, []),
	("term_match", 7044, [])]
);
in
fun âsimple_‚_match_mp_ruleá (thm1 : THM) (thm2 : THM) : THM = (
	let val s1 = ‚_mp_rule thm1 thm2;
	in
	 	(prof "simple_‚_match_mp_rule";
		s1)
	end
	handle complaint =>
	aux thm1 thm2
);
end;
=IGN
val thm1 = simple_ƒ_elim »x : 'a¼ (asm_rule »ƒ x y Ž f x y ‚ b¼);
val thm2 = asm_rule »f 1 2 : BOOL¼;
simple_‚_match_mp_rule thm1 thm2;
simple_‚_match_mp_rule t_def t_thm;
=TEX
=SML
local
fun aux (thm : THM) : CONV = (fn (tm :TERM) =>
let
	val (t1,_) = dest_eq (snd(strip_ƒ (concl thm)));
	val (tym,tmm) = term_match tm t1;
	val s1 = apply_matches_rule "simple_‚_match_mp_rule" tym tmm thm;
	val s2 = eq_trans_rule (refl_conv tm) s1;
in
	(prof "simple_eq_match_conv";
	s2)
end
handle complaint =>
list_divert complaint "simple_eq_match_conv" [
	("dest_eq", 7095, []),
	("term_match", 7076, [])]
);
in
fun âsimple_eq_match_convá (thm : THM) : CONV = (fn (tm :TERM) =>
	let val s1 = eq_trans_rule (refl_conv tm) thm;
	in
	 	(prof "simple_eq_match_conv";
		s1)
	end
	handle complaint =>
	aux thm tm
);
end;
=IGN

val thm = simple_ƒ_elim »x : 'a¼ (asm_rule »ƒ x y Ž f x y ‚ b¼);
simple_eq_match_conv thm »f 1 2 : BOOL¼;
=TEX
In the following we just map all failures bar $dest\_eq$
onto 7076, without working out whether the error is 
an ``expected'' one.
This is because we want this function to fail fast as well are succeed fast.
=SML
fun âsimple_eq_match_1_convá (thm : THM) : CONV = (
let
	val (t1,_) = dest_eq (snd(strip_ƒ (concl thm)))

	fun aux1 (athm : THM) : THM = (
	let
		val (qv,b) = simple_dest_ƒ(concl athm);
	in
		aux1 (simple_ƒ_elim (rassoc1 tmm qv) athm)
	end
	handle (Fail _) => athm);
in
(fn (tm :TERM) =>
let	val (tym,tmm) = term_match tm t1;
	val s2 = inst_type_rule tym thm;	
	val s3 = aux1 s2;
	val s4 = eq_trans_rule (refl_conv tm) s3;
in
	(prof "simple_eq_match_1_conv";
	s4)
end
handle (Fail _) => fail "simple_eq_match_conv" 7076 []
)
end
handle complaint =>
divert complaint "dest_eq" "simple_eq_match_1_conv" 7095 []
);
=IGN
val thm = simple_ƒ_elim »x : 'a¼ (asm_rule »ƒ x y Ž f x y ‚ b¼);
val thm1 = simple_ƒ_elim »x : †¼ (asm_rule »ƒ x y :† Ž f x y ‚ b¼);
val thm2 = (asm_rule »ƒ x y :† Ž f x y ‚ b¼);
val thm3 = (asm_rule »ƒ x y :† Ž (( f Žf)f) x y ‚ b¼);
simple_eq_match_1_conv thm »f 1 2 : BOOL¼;
simple_eq_match_1_conv thm1 »f 1 2 : BOOL¼;
simple_eq_match_1_conv thm2 »f 1 2 : BOOL¼;
simple_eq_match_1_conv thm3 »( g Žg)f 1 2 : BOOL¼;
=TEX
\subsection{Concerning }
=SML
fun â_ruleá (tm : TERM) (thm : THM) : THM = (
let
	val mgv = hd(mg_variables [type_of tm] [tm]);
	val sx = subst [(mgv,tm)] (concl thm);
	val mgv_sx = mk_comb(simple_mk_abs(mgv,sx),tm)
	val s1 = simple_%beta%_conv mgv_sx;
	val s2 = eq_sym_rule s1;
	val s3 = ‚_mp_rule s2 thm
in
	(prof "_rule";
	s3)
end);
=TEX
In assessing the following, note that requesting, say, $ap\_arg\_rule$
is equivalent to requesting a $refl\_conv$ and a $mk\_comb\_rule$ as far as efficiency goes.
In addition, note that the original term, $tm$ is in the sco[pe of $aux2$, saving a $mk\_comb$.
=SML
val âall_simple_%beta%_convá  : CONV = (
let
fun rhs (thm: THM) : TERM = snd(dest_eq(concl thm));
fun asbc (tm : TERM) : THM OPT = (
let 	val dt = simple_dest_term tm;

	fun aux1 thm1 thm2 = (
	let val s1 = mk_comb_rule thm1 thm2
	in
		Value (
		if not(simple_is_abs(rhs thm1))
		then s1
		else (let val s2 = conv_rule (RAND_C simple_%beta%_conv) s1;
		in
		if simple_is_abs(rhs thm2)
		then (
			case (asbc (rhs s2)) of
			Nil => s2
			| Value s3 => eq_trans_rule s2 s3
		) else s2
		end)
		)
	end);

	fun aux2 (f : TERM) (x : TERM) : THM OPT = (
	if simple_is_abs f
	then 	(Value(
		if simple_is_abs x
		then ((simple_%beta%_conv FURTHER_C(fn tm1 =>
			force_value (asbc tm1))) tm)
		else (simple_%beta%_conv tm)
		))
	else Nil);

	fun aux (Comb (f, x)) = (
	let 	val fr = asbc f;
		val xr = asbc x;
	in
		case (fr,xr) of
		(Nil, Nil) => aux2 f x
		| (Value frt,Nil) => aux1 frt (refl_conv x)
		| (Nil, Value xrt) => aux1 (refl_conv f) xrt
		| (Value frt, Value xrt) => aux1 frt xrt
	end
	) | aux (Abs (x, b)) = (
	let	val br = asbc b
	in
		case br of
		Nil => Nil
		| (Value brt) => Value(simple_abs_rule x brt)
	end
	) | aux _ = Nil;
in
	aux dt
end);
in
	(fn (tm : TERM) => case (asbc tm) of
		Value red => red
		| Nil => fail "all_simple_%beta%_conv" 7020 [])
end);
=IGN
all_simple_%beta%_conv » 1 ¼;
all_simple_%beta%_conv » ( x Ž (plus x y)) 1¼;
all_simple_%beta%_conv » ( x Ž (plus x x)) 1¼;
all_simple_%beta%_conv » ( f x Ž (f x x)) ( y z Ž aplus y z) 1¼;
all_simple_%beta%_conv »( f x y Ž (f x € y) € ( p Ž p) q)( x Ž Œ x) T (( p Ž p) q)¼;
all_simple_%beta%_conv » ( y x : BOOL Ž x  € y)(plus(x :†) 1 ) ¼;
=TEX
=SML
fun âall_simple_%beta%_ruleá (thm : THM) =(
	conv_rule all_simple_%beta%_conv thm
	handle complaint =>
	divert complaint "all_simple_%beta%_conv"
		"all_simple_%beta%_rule" 7021 []
);
=TEX

\subsection{Concerning ƒ (part II)}
=SML
fun âall_ƒ_introá (thm : THM) : THM = (
let	val cfrees = frees(concl thm);
	val afrees = list_cup (map frees (hyps thm));
	val nfrees = cfrees diff afrees;
	val s1 = simple_list_ƒ_intro nfrees thm;
in
	(prof "all_ƒ_intro";
	s1)
end);
=IGN
all_ƒ_intro(simple_list_ƒ_elim[»x:'b¼, »y:'a¼]
	(asm_rule » ƒ x : 'b Ž ƒ y :'a Ž ƒ z Ž f x € z € g y¼));
=TEX
=SML
fun âall_simple_ƒ_elimá (thm : THM) : THM = (
let	val c = concl thm;
	val cfrees = frees c;
	val all_frees = cfrees cup (list_cup (map frees (hyps thm)));
	val qvs = fst(strip_ƒ c);
	val qvs' = list_variant all_frees qvs;
	val s1 = simple_list_ƒ_elim qvs' thm;
in
	(prof "all_simple_ƒ_elim";
	s1)
end);
=IGN
all_simple_ƒ_elim (undisch_rule (simple_ƒ_elim »r : BOOL¼ (asm_rule
	»ƒ r Ž (ƒ x: 'a Ž p x € q € r) Š (ƒ q r : BOOL Ž p x € q € r)¼)));
=TEX
\subsection{Concerning $\alpha$-conversion}
=SML
val â%alpha%_convá : TERM -> CONV = (
let val ar = subst_rule [];
in
(fn (tm1 : TERM) =>
 fn (tm2 : TERM) =>
let
	val new_template = mk_eq(tm2, tm1);
	val s2 = refl_conv tm2;
	val s3 = ar new_template s2;
in
	(prof "%alpha%_conv";
	s3)
end
handle complaint =>
list_divert complaint "%alpha%_conv" [
	("mk_eq", 7033, []),
	("subst_rule",7034,[])]
)
end);
=IGN 
%alpha%_conv » x Žx¼ » y Ž y¼;
=TEX
=SML
val âsimple_%alpha%_convá : string -> CONV = (
let val ar = subst_rule [];
in
(fn (v : string) =>
 fn (tm : TERM) =>
let
	val (x,b) = simple_dest_abs tm
		
	val vtm = mk_var(v, type_of x);
	val abs = simple_mk_abs(vtm,subst[(vtm,x)]b);
	val new_template = mk_eq(tm, abs);
	val s2 = refl_conv tm;
	val s3 = ar new_template s2;
in
	(prof "%alpha%_conv";
	s3)
end
handle complaint =>
list_divert complaint "simple_%alpha%_conv"  [
	("simple_dest_abs",7030,[]),
	("subst_rule", 7035, [(fn () => v)])]
)
end);
=IGN
simple_%alpha%_conv "new" » x Žx¼;
simple_%alpha%_conv "new" » x new : 'aŽ x¼;
simple_%alpha%_conv "new" » x : 'aŽ x = new ¼; (* fails *)
=TEX
\subsection{Concerning Œ (part II)}
We prove the local theorem:
ó
s8 … ƒ p Ž Œ(Œ p) = p
æ
=SML
local
	val s1 = asm_rule »p : BOOL¼;
	val s2 = Œ_Œ_intro s1;
	val s3 = Š_intro »p : BOOL¼ s2;
	val s4 = asm_rule »Œ(Œ p)¼;
	val s5 = Œ_Œ_elim s4;
	val s6 = Š_intro »Œ(Œ p)¼ s5;
	val s7 = ‚_intro s6 s3;
	val s8 = simple_ƒ_intro »p : BOOL¼ s7;
in
val Œ_Œ_conv : CONV = (fn (tm : TERM) =>
let
	val p = dest_Œ(dest_Œ tm);
	val mf_s1 = simple_ƒ_elim p s8;
in
	(prof "Œ_Œ_conv";
	mf_s1)
end
handle complaint =>
divert complaint "dest_Œ" "Œ_Œ_conv" 7022 []
);
end;
=IGN
Œ_Œ_conv »Œ(Œ T)¼;
=TEX
Local theorems:
ó
s22 … ƒ p Ž Œ („ x Ž Œ (p x)) ‚ (ƒ x Ž p x)

s27 … Œ (ƒ x Ž Œ (p x)) ‚ („ x Ž p x)

s31 … ƒ p Ž Œ (ƒ x Ž p x) ‚ („ x Ž Œ (p x))

s35 … ƒ p Ž Œ („ x Ž p x) ‚ (ƒ x Ž Œ (p x))
æ
=SML
local
val s1 = asm_rule »( x : 'a Ž Œ(p x)) x¼;
val s2 = simple_„_intro »„ x : 'a Ž ( x Ž Œ(p x)) x¼ s1;
val s3 = all_Š_intro s2;
val s4 = all_simple_%beta%_rule s3;
val s5 = asm_rule »Œ(„ x Ž Œ (p x))¼;
val s6 = modus_tollens_rule s4  s5;
val s7 = Œ_Œ_elim s6;
val s8 = simple_ƒ_intro »x : 'a¼ s7;
val s9 =  all_Š_intro s8;

val s10 = asm_rule »ƒ x : 'a Ž p x¼;
val s11 = all_simple_ƒ_elim s10;
val s12 = asm_rule »Œ(p (x : 'a))¼;
val s13 = asm_rule »„ x : 'a Ž Œ(p x)¼;
val s14 = Œ_elim »F¼ s11 s12;
val s15 = simple_„_elim  »Œ(p (x : 'a))¼ s13 s14;
val s16 = Š_intro »„ x : 'a Ž Œ(p x)¼ s15;
val s17 = simple_ƒ_elim »„ x : 'a Ž Œ(p x)¼ Œ_thm;
val s18 = eq_sym_rule s17;
val s19 = ‚_mp_rule s18 s16;
val s20 = all_Š_intro s19;
val s21 = ‚_intro s9 s20;
val s22 = all_ƒ_intro s21;

val s23 = simple_ƒ_elim »( x : 'a Ž Œ(p x))¼ s22;
val s24 = all_simple_%beta%_rule s23;
val s25 = ap_fun_rule »$Œ¼ s24;
val s26 = conv_rule (TOP_TRAVERSE_C Œ_Œ_conv) s25;
val s27 = eq_sym_rule s26;

val s28 = ap_fun_rule »$Œ¼ s21;
val s29 = conv_rule (TOP_TRAVERSE_C Œ_Œ_conv) s28;
val s30 = eq_sym_rule s29;
val s31 = all_ƒ_intro s30; (* Œ_ƒ_thm *)

val s32 = ap_fun_rule »$Œ¼  s27;
val s33 = conv_rule (TOP_TRAVERSE_C Œ_Œ_conv) s32;
val s34 = eq_sym_rule s33;
val s35 = all_ƒ_intro s34; (* Œ_„_thm *)

=TEX
Now the main functions:
=SML
in
val âsimple_Œ_ƒ_convá : CONV = (fn (tm : TERM) =>
let
	val neg = (dest_Œ tm);
	val (v,b) = simple_dest_ƒ neg;
	val vstr = fst(dest_var v);
	val abs = snd(dest_comb neg);
	val mf_s1 = inst_type_rule[(type_of v,mk_vartype "'a")] s31;
	val mf_s2 = simple_ƒ_elim abs mf_s1;
	val mf_s3 = conv_rule(ONCE_TRAVERSE_C simple_%beta%_conv
		THEN_C ONCE_TRAVERSE_C (simple_%alpha%_conv vstr)) mf_s2;
	val mf_s4 = refl_conv tm;
	val mf_s5 = eq_trans_rule mf_s4 mf_s3;
in
	(prof "simple_Œ_ƒ_conv";
	mf_s5)
end
handle complaint =>
list_divert complaint "simple_Œ_ƒ_conv" [
	("dest_Œ",7036,[]),
	("dest_ƒ",7036,[])]
);

val âsimple_Œ_„_convá : CONV = (fn (tm : TERM) =>
let
	val neg = (dest_Œ tm);
	val (v,b) = simple_dest_„ neg;
	val vstr = fst(dest_var v);
	val abs = snd(dest_comb neg);
	val mf_s1 = inst_type_rule[(type_of v,mk_vartype "'a")] s35;
	val mf_s2 = simple_ƒ_elim abs mf_s1;
	val mf_s3 = conv_rule(ONCE_TRAVERSE_C simple_%beta%_conv
		THEN_C ONCE_TRAVERSE_C (simple_%alpha%_conv vstr)) mf_s2;
	val mf_s4 = refl_conv tm;
	val mf_s5 = eq_trans_rule mf_s4 mf_s3;
in
	(prof "Œ_„_conv";
	mf_s5)
end
handle complaint =>
list_divert complaint "simple_Œ_„_conv" [
	("dest_Œ",7058,[]),
	("dest_„",7058,[])]
);
end; (* of local val s1 = ... *)
=IGN
simple_Œ_ƒ_conv »Œ(ƒ z : 'b Ž f z (x:'b))¼;
simple_Œ_„_conv »Œ(„ z : 'b Ž f z (x:'b))¼;
=TEX


\section{END OF THE STRUCTURE}
=SML
(* end; structure DerivedInferenceRules *)
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
