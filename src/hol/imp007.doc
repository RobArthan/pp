% imp007.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the Derived Rules of Inference}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Derived Rules of Inference}
\TPPref{DS/FMU/IED/IMP007}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
% \TPPauthors{K.~Blackburn & WIN01\\D.J.~King & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}

\item [29 May 1991 Issue 1.1]
First version.
Primitive and built-in inference rules, and conversionals
all module tested to these implementations.

\item [30 May 1991 Issue 1.2] Added material up to $±$.

\item [31 May 1991 Issue 1.3] Added up to $¥\_trans\_rule$, corrected $¨≥Æ$.

\item [7 June 1991 Issue 1.4] Added up to $≥\_eq\_sym\_rule$, and DJK work.

\item [7 June 1991 Issue 1.5]
Corrected the description of $≥\_1\_thm$,
and corrected $list\_simple\_µ\_intro$.
Added material up to $asm\_inst\_type\_rule$.

\item [10 June 1991 Issue 1.6] Corrected $simple\_∂_elim$.

\item [10 June 1991 Issue 1.7] Added most of the rest.

\item [17 June 1991 Issue 1.8] Added the rest.

\item [18 June 1991 Issue 1.9]
Renamed $LIST\_THEN\_C$ to $EVERY\_C$, $LIST\-\_ORELSE\-\_C$ to $FIRST\-\_C$,
and added $COMB\-\_C$.
Tidying up, profiling put about successful calls.

\item [18 June 1991 Issue 1.10] Added author's names.

\item [19 June 1991 Issue 1.12]
Bought $TOP\_TRAVERSE\_C$ into line with prototype's 
$TOP\-\_DEPTH\-\_CONV$.
$prove\-\_asm\-\_rule$ doesn't worry about missing assumptions.
Corrected $\_match$ functions.

\item [19 June 1991 Issue 1.13] Corrected a use of $all\_simple\_µ\_elim$.

\item [21 June 1991 Issue 1.14]
Corrected $apply\_matches\_rule$.
Corrected various error messages.
Corrected $≥\_intro$ and $≥\_elim$.

\item [24 June 1991 Issue 1.15] Corrected $COMB\_C$ error message.

\item [27 June 1991 Issue 1.16]
Corrected indexing of saved theorems.
Changed $\_TRAVERSE\_C$ to $\_MAP\_C$.
Removed informal test material from ``=IGN'' sections.
$?\_MAP\_C$ all have failure 7005 added.
The prefix $simple$ is moved to being the first prefix, bar $icl'$.
Changed order of $all\_µ\_intro$ introduced variables.

\item[03 July 1991 Issue 1.17] $simple\_∂\_elim$ changed in accord with issue 1.15 detailed design change.

\item[03 July 1991 Issue 1.18] Added $id\_conv$.

\item[25 July 1991 Issue 1.19] Split into two structures, see section~\ref{SplitStructure}.

\item [29 July 1991 Issue 1.20]
Changed as result of changes caused by IR0016.

\item [5 August 1991 Issue 1.21]
Reacting to issue 1.18 of \cite{DS/FMU/IED/DTD006}.

\item [8 August 1991 Issue 1.22]
Reacting to changes from ID0021.

\item [15th August 1991 Issue 1.23]
Renamings of functions containing the name atom $simple$,
and renaming of $aconv$.

\item [5th September 1991 Issue 1.24]
Tidying up.
\item [24th September 1991 Issue 1.25]
Changes in reaction to issue 1.25 of \cite{DS/FMU/IED/DTD007}.
\item [14th October 1991 Issue 1.26]
Corrected a bug in $Õ\_elim\_rule$.
\item [8th November 1991 Issue 1.27]
Added $plus\_conv$, removed $div2\_conv$ and $mod2\_conv$,
following change request CR007.
\item [20th Decemember 1991 Issue 1.28]
Changed implementation of $simple\-\_∂\-\_intro$ and $simple\-\_∂\-\_elim$.

\item[Issue 1.29, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.30]
Change to profile only primitive and built-in inference rules with $prof$.
\item [Issue 1.31 (12th March 1992)] Various minor additions and extensions.
\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the derived rules of inference.
This includes user versions of the
primitive and built-in inference rules.
The design is in \cite{DS/FMU/IED/DTD007}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the 
This includes user versions of the
primitive and built-in inference rules.
A ``primitive'' inference rule is considered to be part of the logic,
whereas a ``built-in'' rule is one that, though it could be coded in terms 
of the primitive rules, will actually be part of the abstract data type $THM$, and thus taken as holding true without checking.
These functions will be profiled with $prof$.
Inference rules other than these are called ``derived'' rules 
(derived from primitive and built-in rules).
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD007},
and also requires those files indicated as preceding it in the 
rel001 makefile.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Compilation Note}
\label{SplitStructure}

Issues~1.18 and earlier of this document declared a single structure,
by issue~1.18 this had almost~2300 lines of Standard~ML. Unfortunately
this structure failed to compile on Sun~3 computers although it did
compile on Sun~4 computers. Investigations failed to find the exact
cause of the compilation failure apart from a code generation limit was
exceeded.

The resolution of the compilation failure was to divide the structure
into two pieces, as follows.

=GFT SML example
structure DerivedInferenceRules = struct
	(* First set of declarations *)
	...
end;

structure €DerivedInferenceRules› : DerivedInferenceRules = struct
	(* Second set of declarations *)
	open DerivedInferenceRules;
	...
end;

open DerivedInferenceRules;
=TEX

Here the two structures have the same name, there is a signature
constraint only on the second, the first structure is opened within the
second, the second structure declaration hides the first. The effect
is to create one structure having the required signature.

\section{THE ABSTRACT DATA TYPE $THM$}
=SML
structure €DerivedRules1› = struct
=TEX
\subsection{Primitive and Built-in Rules}
This, and only this, part is done in the context
of an open kernel:
=SML
local
	open icl'Kernel;
in
=TEX
\subsubsection{Primitive Rules}
=SML
fun €subst_rule› (thm_var_lst : (THM * TERM) list) :
	TERM -> THM -> THM = (
	let val s1 = icl'subst_rule thm_var_lst
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule"
	in
	(fn (tm:TERM) =>
	let val s2 = s1 tm
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule"
	in
	(fn (thm : THM) =>
	(let
		val s3 = s2 thm
	in
		(prof "subst_rule";
		s3)
	end
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule")
	)
	end)
	end
);
=TEX
=SML
fun €simple_Ã_eq_rule› (tm : TERM) (thm : THM) : THM = (
let	val s1 = icl'simple_Ã_eq_rule tm thm
in
	(prof "simple_Ã_eq_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'simple_Ã_eq_rule" "simple_Ã_eq_rule"
);
fun €inst_type_rule› (ty_list : (TYPE * TYPE) list) (thm : THM) : THM = (
let	val s1 = icl'inst_type_rule ty_list thm
in
	(prof "inst_type_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'inst_type_rule" "inst_type_rule"
);
=TEX
=SML
fun €¥_intro› (tm : TERM) (thm : THM) : THM = (
let	val s1 = icl'¥_intro tm thm
in
	(prof "¥_intro";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'¥_intro" "¥_intro"
);
=TEX
=SML
fun €¥_elim› (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = icl'¥_elim thm1 thm2
in
	(prof "¥_elim";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'¥_elim" "¥_elim"
);
=TEX
=SML
fun €asm_rule› (tm : TERM) : THM = (
let	val s1 = icl'asm_rule tm
in
	(prof "asm_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'asm_rule" "asm_rule"
);
=TEX
=SML
val €refl_conv› : CONV = (fn (tm:TERM) =>
let	val s1 = icl'refl_conv tm
in
	(prof "refl_conv";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'refl_conv" "refl_conv"
);
=TEX
=SML
val €simple_¬_conv› : CONV = (fn (tm:TERM) =>
let	val s1 = icl'simple_¬_conv tm
in
	(prof "simple_¬_conv";
	s1)
end
		handle complaint => 
		pass_on complaint "icl'simple_¬_conv" "simple_¬_conv"
);
=TEX
\subsubsection{Definitional Schemata}
=SML
local
	val N0 = mk_Ó 0;
in
val €suc_conv› : CONV = (fn (tm:TERM) =>
let	val s1 = if tm = N0
		then term_fail "suc_conv" 7100 [tm]
		else icl'suc_conv tm
in
	(prof "suc_conv";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'suc_conv" "suc_conv"
);
end;
=TEX
=SML
val €string_conv› : CONV = (fn (tm:TERM) =>
let	val s1 = icl'string_conv tm
in
	(prof "string_conv";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'string_conv" "string_conv"
);

=TEX
=SML
val €char_conv› : CONV = (fn (tm:TERM) =>
let	val s1 = icl'char_conv tm
in
	(prof "char_conv";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'char_conv" "char_conv"
);
=TEX
\subsubsection{Built-In Rules of Inference}
=SML
fun €eq_sym_rule› (thm : THM) : THM = (
let	val s1 = icl'eq_sym_rule thm
in
	(prof "eq_sym_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'eq_sym_rule" "eq_sym_rule"
);
=TEX
=SML
fun €list_simple_µ_elim› (tml : TERM list) (thm : THM) : THM = (
let	val s1 = icl'list_simple_µ_elim tml thm
in
	(prof "list_simple_µ_elim";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'list_simple_µ_elim" "list_simple_µ_elim"
);
=TEX
=SML
fun €eq_trans_rule› (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = icl'eq_trans_rule thm1 thm2
in
	(prof "eq_trans_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'eq_trans_rule" "eq_trans_rule"
);
=TEX
=SML
fun €mk_app_rule› (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = icl'mk_app_rule thm1 thm2
in
	(prof "mk_app_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'mk_app_rule" "mk_app_rule"
);
=TEX
=SML
fun €§_mp_rule› (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = icl'§_mp_rule thm1 thm2
in
	(prof "§_mp_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'§_mp_rule" "§_mp_rule"
);
=TEX
=SML
fun €simple_µ_intro› (tm : TERM) (thm : THM) : THM = (
let	val s1 = icl'simple_µ_intro tm thm
in
	(prof "simple_µ_intro";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'simple_µ_intro" "simple_µ_intro"
);
=TEX
=SML
fun €inst_term_rule› (tml : (TERM * TERM) list) (thm : THM) : THM = (
let	val s1 = icl'inst_term_rule tml thm
in
	(prof "inst_term_rule";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'inst_term_rule" "inst_term_rule"
);
=TEX
=SML
val €plus_conv› : CONV = (fn (tm:TERM) =>
let	val s1 = icl'plus_conv tm
in
	(prof "plus_conv";
	s1)
end
	handle complaint => 
	pass_on complaint "icl'plus_conv" "plus_conv"
);
=TEX
It seems best to implement the following using $icl'list\_simple\_µ\_elim$ directly, rather than go through its interface, and thus an additional profiling call.
=FRULE 1 Rule
simple_µ_elim
¨t1Æ
˜
á Ù µ x ∑ t2[x]
˜
á Ù t2'[t1]
=TEX
where $x$ is a simple variables.
=SML
fun €simple_µ_elim› (tm: TERM) (thm:THM) = (
let	val s1 = icl'list_simple_µ_elim [tm] thm
in
	(prof "simple_µ_elim";
	s1)
end
handle complaint =>
let	val efrom = area_of complaint
in
	if efrom = "icl'list_simple_µ_elim"
	then (if not(is_simple_µ (concl thm))
		then thm_fail "simple_µ_elim" 7039 [thm]
		else let val (v,_) = dest_simple_µ (concl thm)
		in
			if type_of v <> type_of tm
			then term_fail "simple_µ_elim" 3012 [v,tm]
			else reraise complaint "simple_µ_elim"
		end)
	else reraise complaint efrom
end);

=TEX
=SML
end; (* local open icl'Kernel *)
=TEX
\subsection{Inference Rules For Conversions}
Two "proper" failures come from $mk\-\_app\-\_rule$,
each with their own failure message from
$ap\-\_fun\-\_rule$.
We need to do some calculation to determine which error
is given: but we only do this if we get a failure.
=SML
fun €ap_fun_rule› (tm : TERM) (thm : THM) : THM = ((
let	val s1 = refl_conv tm;
	val s2 = mk_app_rule s1 thm
in
	s2
end)
handle complaint =>
if is_eq(concl thm)
then divert complaint "mk_app_rule" "ap_fun_rule" 7024 [fn () => string_of_term tm]
else divert complaint "mk_app_rule" "ap_fun_rule" 6020 [fn () => string_of_thm thm]
);
=TEX
Two "proper" failures come from $mk\-\_app\-\_rule$,
each with their own failure message from
$ap\-\_arg\-\_rule$.
We need to do some calculation to determine which error
is given: but we only do this if we get a failure.
=SML
fun €ap_arg_rule› (tm : TERM) (thm : THM) : THM = (
let	val s1 = refl_conv tm;
	val s2 = mk_app_rule thm s1;
in
	s2
end
handle complaint =>
if is_eq(concl thm)
then divert complaint "mk_app_rule" "ap_arg_rule" 7025 [fn () => string_of_term tm]
else divert complaint "mk_app_rule" "ap_arg_rule" 6020 [fn () => string_of_thm thm]
);
=TEX

\subsection{Conversions}
\subsubsection{Building Blocks}
=SML
val €id_conv› : CONV = refl_conv;

val €fail_conv› : CONV = (fn (tm:TERM) => fail "fail_conv" 7061 []);

fun €fail_with_conv› (str : string) : CONV = (
	fn (tm:TERM) => fail "fail_with_conv" 7075 [fn () => str]
);
=TEX
\subsubsection{Conversionals}
=SML
fun (cnv1 : CONV) €THEN_C› (cnv2 : CONV) : CONV = (fn (tm: TERM) =>
let	val s1 = cnv1 tm;
	val rhs_s1 = snd(dest_eq (concl s1))
		handle complaint =>
		divert complaint "dest_eq" "THEN_C" 7101 [fn () => string_of_thm s1];
	val s2 = cnv2 rhs_s1;
	val s3 = eq_trans_rule s1 s2
		handle complaint =>
		divert complaint "eq_trans_rule" "THEN_C" 7102 [fn () => string_of_thm s2,
			fn () => string_of_thm s1];
in
	s3
end);
=TEX
=SML
fun (cnv1 : CONV) €FURTHER_C› (cnv2 : CONV) : CONV = (fn (tm: TERM) =>
let	val s1 = cnv1 tm
in
	(let
		val rhs_s1 = snd(dest_eq (concl s1));
		val s2 = cnv2 rhs_s1;
		val s3 = eq_trans_rule s1 s2
	in
		s3
	end
	handle (Fail _) => s1)
end);
=TEX
=SML
fun (cnv1 : CONV) €ORELSE_C› (cnv2 : CONV) : CONV = (fn (tm: TERM) =>
	cnv1 tm
handle (Fail _) =>
	cnv2 tm
);
=TEX
=SML
fun (cnv1 : CONV) €EITHER_C› (cnv2 : CONV) : CONV = (fn (tm: TERM) =>
(let	val s1 = cnv1 tm
in
	(let
		val rhs_s1 = snd(dest_eq (concl s1));
		val s2 = cnv2 rhs_s1;
		val s3 = eq_trans_rule s1 s2;
	in
		s3
	end
	handle (Fail _) => s1)
end
handle (Fail _) => cnv2 tm)
);
=TEX
=SML
fun €TRY_C› (cnv : CONV) : CONV = (fn (tm:TERM) =>
	cnv tm
	handle (Fail _) =>
	refl_conv tm
);
=TEX
=SML
fun €COND_C› (pred:TERM -> bool) (cnv1 : CONV) (cnv2:CONV) : CONV = 
(fn (tm:TERM) =>
	if pred tm
	then cnv1 tm
	else cnv2 tm
);
=TEX
=SML
fun €REPEAT1_C› (cnv : CONV) : CONV = (fn (tm:TERM) =>
	(cnv FURTHER_C (REPEAT1_C cnv)) tm
);
=TEX
Notice that the following is carefully coded to avoid
redundant $refl\_conv$'s.
There is a minor partial evaluation effect with 
only the conversion argument.
=SML
fun €REPEAT_C› (cnv : CONV) : CONV = (fn (tm:TERM) =>
	TRY_C (REPEAT1_C cnv) tm
);
=TEX
Partially evaluated given only a list.
=SML
fun €EVERY_C› ([cnv] : CONV list) : CONV = cnv
| EVERY_C (cnv :: crest) = cnv THEN_C (EVERY_C crest)
| EVERY_C [] = fail "EVERY_C" 7103 [];
=TEX
Partially evaluated given only a list.
=SML
fun €FIRST_C› ([cnv] : CONV list) : CONV = cnv
| FIRST_C (cnv :: crest) = cnv ORELSE_C (FIRST_C crest)
| FIRST_C [] = fail "FIRST_C" 7103 [];
=TEX
=SML
fun €CHANGED_C› (cnv : CONV) : CONV = (fn (tm:TERM) =>
let	val s1 = cnv tm;
	val rhs_s1 = (snd o dest_eq o concl) s1
		handle complaint =>
		divert complaint "dest_eq" "CHANGED_C" 7104
			[fn () => string_of_thm s1]
in
	if rhs_s1 <> tm
	then s1
	else fail "CHANGED_C" 7032 []
end);
=TEX
\subsubsection{Term Traversal Algorithms for Conversions}
=SML
fun €RAND_C› (cnv : CONV) : CONV = (fn (tm:TERM) =>
let	val (f,x) = dest_app tm
		handle complaint =>
		pass_on complaint "dest_app" "RAND_C";
	val s1 = cnv x;
	val s2 = ap_fun_rule f s1
		handle complaint =>
		divert complaint "ap_fun_rule" "RAND_C" 7104 
			[fn () => string_of_thm s1];
in
	s2
end);
=TEX
=SML
fun €RIGHT_C› (cnv : CONV) : CONV = (fn (tm:TERM) =>
let	val (fa,b) = (dest_app tm)
		handle (Fail _) =>
		term_fail "RIGHT_C" 3013 [tm];
	val dummy = if is_app fa
		then ()
		else term_fail "RIGHT_C" 3013 [tm];
	val s1 = cnv b;
	val s2 = ap_fun_rule fa s1
		handle complaint =>
		divert complaint "ap_fun_rule" "RIGHT_C" 7104 
			[fn () => string_of_thm s1];
in
	s2
end);
=TEX
=SML
fun €LEFT_C› (cnv : CONV) : CONV = (fn (tm:TERM) =>
let	val ((f,a),b) = (dest_app ** Combinators.I)(dest_app tm)
		handle (Fail _) =>
		term_fail "LEFT_C" 3013 [tm];
	val s1 = cnv a;
	val s2 = ap_arg_rule b(ap_fun_rule f s1)
		handle complaint =>
		divert complaint "ap_fun_rule" "LEFT_C" 7104 
			[fn () => string_of_thm s1];
in
	s2
end);
=TEX
=SML
local 
fun list_mk_app_rule thm [] = thm
| list_mk_app_rule thm (a :: x) = (list_mk_app_rule (mk_app_rule thm a) x
	handle complaint =>
	divert complaint "mk_app_rule" "RANDS_C" 7104 
			[fn () => string_of_thm a]);
in
fun €RANDS_C› (cnv : CONV) : CONV = (fn (tm:TERM) =>
let	val (f,xs) = strip_app tm;
	val xs' = map cnv xs;
	val s2 = (if is_nil xs
		then refl_conv f
		else list_mk_app_rule (ap_fun_rule f (hd xs')) (tl xs')
		handle complaint =>
		divert complaint "ap_fun_rule" "RANDS_C" 7104 
			[fn () => string_of_thm (hd xs')]);
in
	s2
end);
end;
=TEX
=SML
fun €RATOR_C› (cnv : CONV) : CONV = (fn (tm:TERM) =>
let	val (f,x) = dest_app tm
		handle complaint =>
		pass_on complaint "dest_app" "RATOR_C";
	val s1 = cnv f;
	val s2 = ap_arg_rule x s1
		handle complaint =>
		divert complaint "ap_arg_rule" "RATOR_C" 7104
			[fn () => string_of_thm s1];
in
	s2
end);
=TEX
=SML
fun €APP_C› (cnv1 : CONV, cnv2 : CONV) : CONV = (fn (tm:TERM) =>
let	val (f,x) = dest_app tm
		handle complaint =>
		pass_on complaint "dest_app" "APP_C";
	val s1 = cnv1 f;
	val s2 = cnv2 x;
	val s3 = mk_app_rule s1 s2
		handle complaint =>
		divert complaint "mk_app_rule" "APP_C" 7110
			[fn () => string_of_thm s1,
			 fn () => string_of_thm s2];
in
	s3
end);
=TEX
=SML
fun €SIMPLE_Ã_C› (cnv : CONV) : CONV = (fn (tm:TERM) =>
let	val (x,b) = dest_simple_Ã tm
		handle complaint =>
		pass_on complaint "dest_simple_Ã" "SIMPLE_Ã_C";
	val s1 = cnv b;
	val s2 = simple_Ã_eq_rule x s1
		handle complaint =>
		divert complaint "simple_Ã_eq_rule" "SIMPLE_Ã_C" 7104 
			[fn () => string_of_thm s1];
in
	s2
end);
=TEX
We do the following in full to be able to determine the
correct error message, if necessary.
It could just be $RAND\_C\ o\ SIMPLE\_Ã\_C$.
=SML
fun €BINDER_C› (cnv : CONV) : CONV = (fn (tm:TERM) =>
let	val (binder,abs) = dest_app tm;
	val (x,b) = dest_simple_Ã abs;
	val s1 = cnv b;
	val s2 = ap_fun_rule binder (simple_Ã_eq_rule x s1)
		handle complaint =>
		list_divert complaint "BINDER_C" [
			("simple_Ã_eq_rule",7104,[fn () => string_of_thm s1]),
			("ap_fun_rule",7104,[fn () => string_of_thm s1])];	
in
	s2
end
handle complaint =>
list_divert complaint "BINDER_C" [
	("dest_simple_Ã",7059,[fn () => string_of_term tm]),
	("dest_app",7059,[fn () => string_of_term tm])]
);
=TEX
We could build the following using the above building blocks,
but prefer to keep it fast.
=SML
fun €SUB_C› (cnv : CONV) : CONV = (fn (tm:TERM) =>
let	fun aux (Var _) = refl_conv tm
	| aux (Const _) = refl_conv tm
	| aux (App (f,x)) = (
		((let val thm1 = cnv f
		in
		 (let val thm2 = cnv x
		 in
			mk_app_rule thm1 thm2
		 end
		 handle (Fail _) =>
		 ap_arg_rule x thm1)
		end)
		handle (Fail _) =>
		(let val thm2 = cnv x
		in
			ap_fun_rule f thm2
		end))
		handle (Fail _) => refl_conv tm
	) | aux (SimpleÃ (x,b)) = (
		let val thm1 = cnv b
		in
			simple_Ã_eq_rule x thm1
		end
		handle (Fail _) =>
		refl_conv tm
	);
in
	aux(dest_simple_term tm)
end);
=TEX
There is a mild partial evaluation with only a conversion.
=SML
fun €SUB1_C› (cnv : CONV) : CONV = (fn (tm:TERM) => 
let	fun aux (Var _) = term_fail "SUB1_C" 7105 [tm]
	| aux (Const _) = term_fail "SUB1_C" 7105 [tm]
	| aux (App (f,x)) = (
		let val thm1 = cnv f
		in
		 (let val thm2 = (cnv x
			handle (Fail _) => refl_conv x)
		 in
			mk_app_rule thm1 thm2
		 end)
		end
		handle (Fail _) =>
		(let val thm2 = cnv x
		in
			(ap_fun_rule f thm2
			handle complaint =>
			divert complaint "ap_fun_rule" "SUB1_C" 7104
			[fn () => string_of_thm thm2])
		end)
	) | aux (SimpleÃ (x,b)) = (
		let val thm1 = cnv b
		in
			(simple_Ã_eq_rule x thm1
			handle complaint =>
			divert complaint "simple_Ã_eq_rule" "SUB1_C" 7104
			[fn () => string_of_thm thm1])
		end
	);
in
	aux(dest_simple_term tm)
end);
=TEX
N.B. the $fn\ (tm: TERM) \ldots tm$ might look $\eta$-convertible away, but actually prevents an infinite loop.
=SML
fun €ONCE_MAP_C› (cnv : CONV) : CONV = (fn (tm: TERM) => 
let	fun aux (tm : TERM) = (cnv ORELSE_C (SUB1_C aux)) tm
in
	aux tm
end
handle (Fail _) => fail "ONCE_MAP_C" 7005 []
);
=TEX
=SML
fun €MAP_C› (cnv : CONV) : CONV = (fn (tm: TERM) => 
let	fun aux (tm : TERM) = (
		(SUB1_C (MAP_C cnv)) 
		EITHER_C (REPEAT1_C cnv)) tm
in
	(aux tm)
end
handle (Fail _) => fail "MAP_C" 7005 []
);
=TEX
=SML
fun €REPEAT_MAP_C› (cnv : CONV) : CONV = (fn (tm: TERM) => 
let	fun aux (tm : TERM) = ((SUB1_C (REPEAT_MAP_C cnv))
	EITHER_C (cnv FURTHER_C (REPEAT_MAP_C cnv))) tm
in
	(aux tm)
end
handle (Fail _) => fail "REPEAT_MAP_C" 7005 []
);
=TEX
=SML
fun €TOP_MAP_C› (cnv : CONV) : CONV = (fn (tm: TERM) => 
let	fun aux (tm : TERM) = ((REPEAT1_C cnv) EITHER_C 
	((CHANGED_C (SUB1_C(TOP_MAP_C cnv)))
		FURTHER_C
		(cnv FURTHER_C (TOP_MAP_C cnv)))) tm
in
	(aux tm)
end
handle (Fail _) => fail "TOP_MAP_C" 7005 []
);
=TEX
\subsubsection{Conversions as Rules}
=SML
fun €conv_rule› (cnv : CONV) (thm : THM) : THM = (
let	val s1 = cnv(concl thm);
	val s2 = §_mp_rule s1 thm
		handle complaint =>
		divert complaint "§_mp_rule" "conv_rule" 7104
		[fn () => string_of_thm s1];
in
	s2
end);
=TEX
\section{DERIVED INFERENCE RULES}
We will be saving theorems as we go along, so we need to ensure we are saving them into theory misc:
=SML
val sideeffect = open_theory "misc";
=TEX
An alias:
=SML
val €¥_mp_rule› : THM -> THM -> THM = ¥_elim;
=TEX
The following is out of place, but useful if declared immediately:
=SML
fun €undisch_rule› (thm : THM) : THM = (
let	val (a,b) = dest_¥(concl thm);
	val s1 = asm_rule a;
	val s2 = ¥_elim thm s1
in
	s2
end
handle complaint =>
divert complaint "dest_¥" "undisch_rule" 7011 [fn () => string_of_thm thm]
);
=TEX
Something else out of sequence:
=SML
fun €disch_rule› (tm : TERM) (thm : THM) : THM = (
	if tm term_mem (hyps thm)
	then (let val s1 = ¥_intro tm thm
		in
			s1
		end
		handle complaint =>
		pass_on complaint "¥_intro" "disch_rule")
	else fail "disch_rule" 7031 [fn () => string_of_term tm]
);
=TEX
		
\subsection{Concerning $T$}
Proof of $T$ (as 12.3.9)
=SML
local
	val s1 = t_def;
	val s2 = eq_sym_rule s1;
	val s3 = refl_conv ¨Ã x : BOOL ∑ xÆ;
	val s4 = §_mp_rule s2 s3;
in
	val €t_thm› = save_thm("t_thm",s4)
end;
=TEX
We could work by a local theorem:
=GFT
Ù µ x ∑ x § (x § T)
=TEX
but choose to work by the more primitive route of 12.3.12
=SML
fun €§_t_intro› (thm : THM) : THM = (
let	val t = concl thm;
	val s3 = list_simple_µ_elim [t, mk_t] ¥_antisym_axiom;
	val s5 = ¥_intro t t_thm;
	val s5 = ¥_elim s3 s5;
	val s8 = ¥_intro mk_t thm;
	val s9 = ¥_elim s5 s8;
in
	s9
end);
=TEX
In the following we could chose to try eliminating
all outermost $\ldots § T$ and $T § \ldots$.
D.I.Y. form:
=SML
fun €§_t_elim› (thm : THM) : THM = (
let	val s1 = eq_sym_rule thm;
	val s2 = §_mp_rule s1 t_thm;
in
	s2
end
handle complaint =>
list_divert complaint "§_t_elim" [
	("eq_sym_rule",7106,[fn () => string_of_thm thm]),
	("§_mp_rule",7106,[fn () => string_of_thm thm])]);
=TEX
D.I.Y. form:
=SML
fun €contr_rule› (tm : TERM) (thm : THM) : THM = (
let	val s1 = §_mp_rule f_def thm;
	val s2 = simple_µ_elim tm s1;
in
	s2
end
handle complaint =>
list_divert complaint "contr_rule" [
	("§_mp_rule", 7001, [fn () => string_of_thm thm]),
	("simple_µ_elim",3031,[fn () => string_of_term tm])]
);
=TEX
The following is out of sequence, but necessary at this point:
we first prove theorem:
=GFT
≤_thm = Ù µ t1 t2 ∑ (t1 ≤ t2) = (µ b ∑ (t1 ¥ b) ¥ (t2 ¥ b) ¥ b)
=TEX
=SML
local
	val s1 = ap_arg_rule ¨t1 : BOOLÆ ≤_def;
	val s2 = ap_arg_rule ¨t2 : BOOLÆ s1;
	val s3 = conv_rule (MAP_C simple_¬_conv) s2;
	val s4 = simple_µ_intro ¨t2 : BOOLÆ s3;
	val s5 = simple_µ_intro ¨t1 : BOOLÆ s4;
in
	val €≤_thm› = save_thm("≤_thm",s5)
end;
=TEX
Then the out of place rule
(roughly as \cite{DS/FMU/IED/SML009} 5.14):
=SML
fun €≤_elim› (a_≤_b : THM) (a_thm : THM) (b_thm : THM) = (
let	val (a,b) = dest_≤(concl a_≤_b);
	val s1 = ¥_intro a a_thm;
	val s2 = ¥_intro b b_thm;
	val s3 = list_simple_µ_elim [a, b] ≤_thm;
	val s4 = §_mp_rule s3 a_≤_b;
	val s5 = simple_µ_elim (concl a_thm) s4;
	val s6 = ¥_elim s5 s1;
	val s7 = ¥_elim s6 s2;
in
	s7
end
handle complaint =>
list_divert complaint "≤_elim" [
	("dest_≤",7010,[fn () => string_of_thm a_≤_b]),
	("¥_elim",7083,[fn () => string_of_thm a_≤_b, 
		fn () => string_of_thm a_thm, fn () => string_of_thm b_thm])]
);
=TEX
Then another out of place theorem:
=GFT
≥_thm = Ù µ t ∑ (≥ t) = (t ¥ F)
=TEX
=SML
local
	val s1 = ap_arg_rule ¨t : BOOLÆ ≥_def;
	val s2 = conv_rule (MAP_C simple_¬_conv) s1;
	val s3 = simple_µ_intro ¨t : BOOLÆ s2;
in
	val €≥_thm› = save_thm("≥_thm", s3)
end;
=TEX
Roughly as 5.17 of \cite{DS/FMU/IED/SML009}:
First prove the local theorem:
=GFT
µ t ∑ (≥ t ¥ F) ¥ t
=TEX
=SML
local
	val s1 = asm_rule ¨(t ¥ F) ¥ FÆ;
	val s2 = asm_rule ¨t § FÆ;
	val s4 = subst_rule[(s2,¨t : BOOLÆ)] (concl s1) s1;
	val s5 = asm_rule mk_f;
	val s6 = ¥_intro mk_f s5;
	val s7 = ¥_elim s4 s6;
	val s8 = eq_sym_rule s2;
	val s9 = §_mp_rule s8 s7;
	val s10 = asm_rule ¨t = TÆ;
	val s11 = §_t_elim s10;
	val s13 = simple_µ_elim ¨t : BOOLÆ bool_cases_axiom;
	val s14 = ≤_elim s13 s11 s9;
	val s15 = ¥_intro ¨(t ¥ F) ¥ FÆ s14;
	val s16 = simple_µ_elim ¨t : BOOLÆ ≥_thm;
	val s17 = eq_sym_rule s16;
	val s18 = conv_rule (ONCE_MAP_C (fn x =>
		if x = ¨t ¥ FÆ then s17 else (fail_conv x))) s15;
	val s19 = simple_µ_intro ¨t : BOOLÆ s18;
in
=TEX
now the main function:
=SML
fun €c_contr_rule› (tm : TERM) (thm : THM) : THM = (
let	val mf_s1 = simple_µ_elim tm s19;
	val ≥_tm = mk_≥ tm;
	val mf_s2 = disch_rule ≥_tm thm;
	val mf_s3 = ¥_elim mf_s1 mf_s2
in
	mf_s3
end
handle complaint =>
list_divert complaint "c_contr_rule" [
	("¥_elim", 7001, [fn () => string_of_thm thm]),
	("simple_µ_elim", 3031, [fn () => string_of_term tm]),
	("disch_rule", 7003, [fn () => string_of_term tm])]
);
end;
=TEX
\subsection{Concerning Negation}
This is entirely new:
we first prove the local theorem:
=GFT
Ù µ a ∑ (≥ a) § (a ¥ µ b ∑ b)
=TEX
=SML
local
	val s1 = conv_rule(ONCE_MAP_C(fn x =>
		if x = mk_f then f_def else fail_conv x))
		≥_thm;
in
fun €≥_elim› (tm : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let	val sideeffect = if type_of tm <> BOOL
		then term_fail "≥_elim" 3031 [tm]
		else ();
in
(let
	val s2 = simple_µ_elim (concl thm1) s1;
	val s3 = §_mp_rule s2 thm2;
	val s4 = ¥_elim s3 thm1;
	val s5 = simple_µ_elim tm s4
in
	s5
end
handle (Fail _) =>
let	val s2 = simple_µ_elim (concl thm2) s1;
	val s3 = §_mp_rule s2 thm1;
	val s4 = ¥_elim s3 thm2;
	val s5 = simple_µ_elim tm s4
in
	s5
end
handle complaint =>
list_divert complaint "≥_elim" [
	("§_mp_rule",7004,[fn () => string_of_thm thm1, fn () => string_of_thm thm2]),
	("¥_elim",7004,[fn () => string_of_thm thm1, fn () => string_of_thm thm2])
	]
)
end
);
end;
=TEX
	
This is entirely new:
we first prove:
=GFT
s13 = Ù µ a b ∑ (a ¥ b) ¥ (a ¥ ≥b) ¥ ≥a
=TEX
=SML
local
	val s1 = asm_rule ¨a ¥ bÆ;
	val s2 = undisch_rule s1;
	val s3 = asm_rule ¨a ¥ ≥ bÆ;
	val s4 = undisch_rule s3;
	val s5 = ≥_elim mk_f s2 s4;
	val s6 = ¥_intro ¨a : BOOLÆ s5;
	val s7 = simple_µ_elim ¨a : BOOLÆ ≥_thm;
	val s8 = eq_sym_rule s7;
	val s9 = conv_rule (ONCE_MAP_C (fn x =>
		if x = ¨a ¥ FÆ then s8 else (fail_conv x))) s6;
	val s10 = ¥_intro ¨a ¥ ≥ bÆ s9;
	val s11 = ¥_intro ¨a ¥ bÆ s10;
	val s12 = simple_µ_intro ¨b : BOOLÆ s11;
	val s13 = simple_µ_intro ¨a : BOOLÆ s12;
in
=TEX
Main function:
=SML
fun €≥_intro› (tm : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let	val mf_s1 = ¥_intro tm thm1;
	val mf_s2 = ¥_intro tm thm2;
in
((let
	val mf_s3 = list_simple_µ_elim [tm, concl thm1] s13;
	val mf_s4 = ¥_elim mf_s3 mf_s1;
	val mf_s5 = ¥_elim mf_s4 mf_s2
in
	mf_s5
end)
handle (Fail _) => 
(let
	val mf_s3 = list_simple_µ_elim [tm, concl thm2] s13;
	val mf_s4 = ¥_elim mf_s3 mf_s2;
	val mf_s5 = ¥_elim mf_s4 mf_s1
in
	mf_s5
end))
end
handle complaint =>
list_divert complaint "≥_intro" [
	("¥_elim", 7004, [fn () => string_of_thm thm1, fn () => string_of_thm thm2]),
	("¥_intro", 3031, [fn () => string_of_term tm]),
	("simple_µ_elim", 3031, [fn () => string_of_term tm])
	]
);
end;
=TEX
Prove the following (out of sequence)
=GFT
f_thm = Ù ≥ F
=TEX
=SML
local
	val s1 = asm_rule mk_f;
	val s2 = ¥_intro mk_f s1;
	val s3 = simple_µ_elim mk_f ≥_thm;
	val s4 = eq_sym_rule s3;
	val s5 = §_mp_rule s4 s2;
in
	val €f_thm› = save_thm("f_thm",s5)
end;
=TEX
Prove the following (out of sequence)
=GFT
≥_t_thm = Ù ≥ T § F
=TEX
=SML
local
	val s1 = simple_µ_elim ¨≥ TÆ bool_cases_axiom;
	val s2 = asm_rule ¨(≥ T) § FÆ;
	val s3 = asm_rule ¨≥ T § TÆ;
	val s4 = §_t_elim s3;
	val s5 = ≥_elim ¨≥ T § FÆ t_thm s4;
	val s6 = ≤_elim s1 s5 s2;
in
	val €≥_t_thm› = save_thm("≥_t_thm",s6)
end;
=TEX
We prove the local theorems:
=GFT
s14 = Ù ≥(≥ t) § t
s16 = Ù t § ≥(≥ t)
=TEX
=SML
local
	val s1 = §_t_intro f_thm;
	val s2 = ap_fun_rule ¨$≥Æ s1;
	val s3 = eq_trans_rule s2 ≥_t_thm;
	val s4 = ap_fun_rule ¨$≥Æ ≥_t_thm;
	val s5 = eq_trans_rule s4 s1;
	val s6 = asm_rule ¨t § TÆ;
	val s7 = eq_sym_rule s6;
	val s8 = subst_rule [(s7,¨x : BOOLÆ)] ¨≥(≥ x) § xÆ s5;
	val s9 = asm_rule ¨t § FÆ;
	val s10 = eq_sym_rule s9;
	val s11 = subst_rule [(s10,¨x : BOOLÆ)] ¨≥(≥ x) § xÆ s3;
	val s12 = simple_µ_elim ¨t : BOOLÆ bool_cases_axiom;
	val s13 = ≤_elim s12 s8 s11;
	val s14 = simple_µ_intro ¨t : BOOLÆ s13;
	val s15 = eq_sym_rule s13;
	val s16 = simple_µ_intro ¨t : BOOLÆ s15;
in
=TEX
Main functions:
=SML
fun €≥_≥_intro› (thm : THM) : THM = (
let	val mf_s1 = simple_µ_elim (concl thm) s16;
	val mf_s2 = §_mp_rule mf_s1 thm
in
	mf_s2
end);

fun €≥_≥_elim› (thm : THM) : THM = (
let	val bdy = dest_≥(dest_≥(concl thm));
	val mf_s1 = simple_µ_elim bdy s14;
	val mf_s2 = §_mp_rule mf_s1 thm
in
	mf_s2
end
handle complaint =>
divert complaint "dest_≥" "≥_≥_elim" 7006 [fn () => string_of_thm thm]
);
end; (* local *)
=TEX
\subsection{Concerning ±}
=GFT
±_thm = Ù µ t1 t2 ∑ (t1 ± t2) = (µ b ∑ (t1 ¥ t2 ¥ b) ¥ b)
=TEX
=SML
local
	val s1 = ap_arg_rule ¨t1 : BOOLÆ ±_def;
	val s2 = ap_arg_rule ¨t2 : BOOLÆ s1;
	val s3 = conv_rule (MAP_C simple_¬_conv) s2;
	val s4 = simple_µ_intro ¨t2 : BOOLÆ s3;
	val s5 = simple_µ_intro ¨t1 : BOOLÆ s4;
in
	val €±_thm› = save_thm("±_thm",s5)
end;
=TEX
Following \cite{DS/FMU/IED/SML009} 5.10:
We prove the local theorem:
=GFT
s14 = µ t1 t2 ∑ t1 ¥ t2 ¥ (t1 ± t2)
=TEX
=SML
local
	val s1 = asm_rule ¨t1 ¥ t2 ¥ bÆ;
	val s3 = undisch_rule s1;
	val s5 = undisch_rule s3;
	val s6 = ¥_intro ¨t1 ¥ t2 ¥ bÆ s5;
	val s7 = simple_µ_intro ¨b : BOOLÆ s6;
	val s8 = list_simple_µ_elim [¨t1 : BOOLÆ, ¨t2 : BOOLÆ] ±_thm;
	val s9 = eq_sym_rule s8;
	val s10 = §_mp_rule s9 s7;
	val s11 = ¥_intro ¨t2 : BOOLÆ s10;
	val s12 = ¥_intro ¨t1 : BOOLÆ s11;
	val s13 = simple_µ_intro ¨t2 : BOOLÆ s12;
	val s14 = simple_µ_intro ¨t1 : BOOLÆ s13;
in
fun €±_intro› (thm1 : THM) (thm2 : THM) : THM = (
let	val mf_s1 = list_simple_µ_elim[concl thm1, concl thm2] s14;
	val mf_s2 = ¥_elim mf_s1 thm1;
	val mf_s3 = ¥_elim mf_s2 thm2;
in
	mf_s3
end);
end;
=TEX
We prove the local theorem:
=GFT
s11 = µ t1 t2 ∑ (t1 ± t2) ¥ t1
=TEX
=SML
local 
	val s1 = list_simple_µ_elim [¨t1 : BOOLÆ, ¨t2 : BOOLÆ] ±_thm;
	val s2 = asm_rule ¨t1 ± t2Æ;
	val s3 = §_mp_rule s1 s2;
	val s4 = simple_µ_elim ¨t1 : BOOLÆ s3;
	val s5 = asm_rule ¨t1 : BOOLÆ;
	val s6 = ¥_intro ¨t2 : BOOLÆ s5;
	val s7 = ¥_intro ¨t1 : BOOLÆ s6;
	val s8 = ¥_elim s4 s7;
	val s9 = ¥_intro ¨t1 ± t2Æ s8;
	val s10 = simple_µ_intro ¨t2 : BOOLÆ s9;
	val s11 = simple_µ_intro ¨t1 : BOOLÆ s10;
in
fun €±_left_elim› (thm :THM) : THM = (
let	val (t1,t2) = dest_±(concl thm);
	val mf_s1 = list_simple_µ_elim [t1, t2] s11;
	val mf_s2 = ¥_elim mf_s1 thm;
in
	mf_s2
end
handle complaint =>
divert complaint "dest_±" "±_left_elim" 7007 [fn () => string_of_thm thm]
);
end;
=TEX
We prove the local theorem:
=GFT
s11 = µ t1 t2 ∑ (t1 ± t2) ¥ t2
=TEX
=SML
local 
	val s1 = list_simple_µ_elim [¨t1 : BOOLÆ, ¨t2 : BOOLÆ] ±_thm;
	val s2 = asm_rule ¨t1 ± t2Æ;
	val s3 = §_mp_rule s1 s2;
	val s4 = simple_µ_elim ¨t2 : BOOLÆ s3;
	val s5 = asm_rule ¨t2 : BOOLÆ;
	val s6 = ¥_intro ¨t2 : BOOLÆ s5;
	val s7 = ¥_intro ¨t1 : BOOLÆ s6;
	val s8 = ¥_elim s4 s7;
	val s9 = ¥_intro ¨t1 ± t2Æ s8;
	val s10 = simple_µ_intro ¨t2 : BOOLÆ s9;
	val s11 = simple_µ_intro ¨t1 : BOOLÆ s10;
in
fun €±_right_elim› (thm :THM) : THM = (
let	val (t1,t2) = dest_±(concl thm);
	val mf_s1 = list_simple_µ_elim [t1, t2] s11;
	val mf_s2 = ¥_elim mf_s1 thm;
in
	mf_s2
end
handle complaint =>
divert complaint "dest_±" "±_right_elim" 7007 [fn () => string_of_thm thm]
);
end;
=TEX
=SML
fun €list_±_intro› ([] : THM list) : THM = (
	fail "list_±_intro" 7107 []
) | list_±_intro thm_lst = (
let	fun aux [thm] = thm
	| aux (thm :: rest) = ±_intro thm (aux rest)
	| aux _ = error "list_±_intro" 0000 [];
	val s1 = aux thm_lst;
in
	s1
end);

=TEX
=SML
fun €strip_±_rule› (thm : THM) : THM list = (
let	fun aux thm1 = (
	let	val s1 = ±_left_elim thm1;
		val s2 = ±_right_elim thm1;
	in
		aux s1 @ aux s2
	end
	handle (Fail _) => [thm1]
	);
	val s1 = aux thm;
in
	s1
end);
=TEX
\subsection{Concerning ≤}
As \cite{DS/FMU/IED/SML009} 5.13.
We prove the local theorem:
=GFT
s12 Ù µ t1 t2 ∑ t1 ¥ (t1 ≤ t2)
=TEX
=SML
local
	val s1 = asm_rule ¨t1 ¥ bÆ;
	val s3 = undisch_rule s1;
	val s4 = ¥_intro ¨t2 ¥ bÆ s3;
	val s5 = ¥_intro ¨t1 ¥ bÆ s4;
	val s6 = simple_µ_intro ¨b :BOOLÆ s5;
	val s7 = list_simple_µ_elim [¨t1 : BOOLÆ,¨t2 : BOOLÆ] ≤_thm;
	val s8 = eq_sym_rule s7;
	val s9 = §_mp_rule s8 s6;
	val s10 = ¥_intro ¨t1 : BOOLÆ s9;
	val s11 = simple_µ_intro ¨t2 : BOOLÆ s10;
	val s12 = simple_µ_intro ¨t1 : BOOLÆ s11;
in
fun €≤_right_intro› (tm : TERM) (thm : THM) : THM = (
let	val mf_s1 = list_simple_µ_elim [concl thm, tm] s12 ;
	val mf_s2 = ¥_elim mf_s1 thm
in
	mf_s2
end
handle complaint =>
divert complaint "list_simple_µ_elim" "≤_right_intro" 3031 [fn () => string_of_term tm]
);
end;
=TEX
We prove the local theorem:
=GFT
s12 Ù µ t1 t2 ∑ t2 ¥ (t1 ≤ t2)
=TEX
=SML
local
	val s1 = asm_rule ¨t2 ¥ bÆ;
	val s3 = undisch_rule s1;
	val s4 = ¥_intro ¨t2 ¥ bÆ s3;
	val s5 = ¥_intro ¨t1 ¥ bÆ s4;
	val s6 = simple_µ_intro ¨b :BOOLÆ s5;
	val s7 = list_simple_µ_elim [¨t1 : BOOLÆ,¨t2 : BOOLÆ] ≤_thm;
	val s8 = eq_sym_rule s7;
	val s9 = §_mp_rule s8 s6;
	val s10 = ¥_intro ¨t2 : BOOLÆ s9;
	val s11 = simple_µ_intro ¨t2 : BOOLÆ s10;
	val s12 = simple_µ_intro ¨t1 : BOOLÆ s11;
in
fun €≤_left_intro› (tm : TERM) (thm : THM) : THM = (
let	val mf_s1 = list_simple_µ_elim [tm, concl thm] s12 ;
	val mf_s2 = ¥_elim mf_s1 thm
in
	mf_s2
end
handle complaint =>
divert complaint "list_simple_µ_elim" "≤_left_intro" 3031 [fn () => string_of_term tm]
);
end;
=TEX
Entirely new:
We prove the prove the local theorem:
=GFT
≥_1_thm = Ù µ t ∑ (≥ t) § (t § F)
=TEX
=SML
local
	val s1 = asm_rule mk_f;
	val s2 = contr_rule ¨t : BOOLÆ s1;
	val s3 = ¥_intro mk_f s2;
	val s4 = asm_rule ¨t ¥ FÆ;
	val s5 = list_simple_µ_elim [¨t : BOOLÆ, mk_f] ¥_antisym_axiom;
	val s6 = ¥_elim s5 s4;
	val s7 = ¥_elim s6 s3;
	val s8 = ¥_intro ¨t ¥ FÆ s7;
	val s9 = simple_µ_elim ¨t : BOOLÆ ≥_thm;
	val s10 = eq_sym_rule s9;
	val s11 = subst_rule[(s10,¨x : BOOLÆ)] ¨x ¥ (t § F)Æ s8;
	val s12 = asm_rule ¨t § FÆ;
	val s13 = eq_sym_rule s12;
	val s14 = subst_rule[(s13,¨x : BOOLÆ)]¨≥ xÆ f_thm;
	val s15 = ¥_intro ¨t § FÆ s14;
	val s16 = list_simple_µ_elim [¨≥ tÆ, ¨t § FÆ] ¥_antisym_axiom;
	val s17 = ¥_elim s16 s11;
	val s18 = ¥_elim s17 s15;
	val s19 = simple_µ_intro ¨t : BOOLÆ s18;
in
val €≥_1_thm› = save_thm("≥_1_thm",s19);
end;
=TEX
We then locally prove:
=GFT
s10 Ù µ t1 t2 ∑ (t1 ≤ t2) ¥ (≥ t2) ¥ t1
s17 Ù µ t1 t2 ∑ (t1 ≤ t2) ¥ (≥ t1) ¥ t2
=TEX
=SML
local
	val s1 = asm_rule ¨t1 ≤ t2Æ;
	val s2 = asm_rule ¨t1 : BOOLÆ;
	val s3 = asm_rule ¨t2 : BOOLÆ;
	val s4 = asm_rule ¨≥ t2Æ;
	val s5 = ≥_elim ¨t1 : BOOLÆ s3 s4;
	val s6 = ≤_elim s1 s2 s5;
	val s7 = ¥_intro ¨≥ t2Æ s6;
	val s8 = ¥_intro ¨t1 ≤ t2Æ s7;
	val s9 = simple_µ_intro ¨t2 : BOOLÆ s8;
	val s10 = simple_µ_intro ¨t1 : BOOLÆ s9;

	val s11 = asm_rule ¨≥ t1Æ;
	val s12 = ≥_elim ¨t2 : BOOLÆ s2 s11;
	val s13 = ≤_elim s1 s12 s3;
	val s14 = ¥_intro ¨≥ t1Æ s13;
	val s15 = ¥_intro ¨t1 ≤ t2Æ s14;
	val s16 = simple_µ_intro ¨t2 : BOOLÆ s15;
	val s17 = simple_µ_intro ¨t1 : BOOLÆ s16;
in
fun €≤_cancel_rule› (thm1 : THM) (thm2 : THM) : THM = (
let	val (t1,t2) = dest_≤ (concl thm1);
in
(let
	val mf_s1 = list_simple_µ_elim [t1,t2] s10;
	val mf_s2 = ¥_elim mf_s1 thm1;
	val mf_s2 = ¥_elim mf_s2 thm2;
in
	mf_s2
end
handle Fail _ =>
let	val mf_s1 = list_simple_µ_elim [t1,t2] s17;
	val mf_s2 = ¥_elim mf_s1 thm1;
	val mf_s2 = ¥_elim mf_s2 thm2;
in
	mf_s2
end)
end
handle complaint =>
list_divert complaint "≤_cancel_rule" [
	("dest_≤",7010,[fn () => string_of_thm thm1]),
	("¥_elim",7050,[fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
end;
=TEX
\subsection{Concerning ¥}
Can only do $¥\_match\_mp\_rule$ after we have $µ\_elim$.
=SML
fun €strip_¥_rule› (thm : THM) : THM = (
let	val (p, q) = dest_¥ (concl thm);
	val s1 = asm_rule p;
	val s2 = ¥_elim thm s1;
in
	strip_¥_rule s2
end
handle (Fail _) => thm
);
=TEX
=SML
fun €all_¥_intro› (thm : THM) : THM = (
let	
	val hs = hyps thm;
	val s1 = fold (uncurry ¥_intro) hs thm;
in
	s1
end);
=TEX
Local theorem:
=GFT
s10 Ù µ t1 t2 t3 ∑ (t1 ¥ t2) ¥ (t2 ¥ t3) ¥ (t1 ¥ t3)
=TEX
=SML
local
	val s1 = asm_rule ¨t1 ¥ t2Æ;
	val s2 = asm_rule ¨t2 ¥ t3Æ;
	val s3 = undisch_rule s1;
	val s4 = ¥_elim s2 s3;
	val s5 = ¥_intro ¨t1 : BOOLÆ s4;
	val s6 = ¥_intro ¨t2 ¥ t3Æ s5;
	val s7 = ¥_intro ¨t1 ¥ t2Æ s6;
	val s8 = simple_µ_intro ¨t3 : BOOLÆ s7;
	val s9 = simple_µ_intro ¨t2 : BOOLÆ s8;
	val s10 = simple_µ_intro ¨t1 : BOOLÆ s9;
in
fun €¥_trans_rule› (thm1 : THM) (thm2 : THM) : THM = (
let	val (t1,t2) = dest_¥(concl thm1)
		handle complaint =>
		divert complaint "dest_¥" "¥_trans_rule" 7040
			[fn () => string_of_thm thm1];
	val (t2',t3) = dest_¥(concl thm2)
		handle complaint =>
		divert complaint "dest_¥" "¥_trans_rule" 7040
			[fn () => string_of_thm thm2];
	val mf_s1 = list_simple_µ_elim[t1, t2, t3] s10;
	val mf_s2 = ¥_elim mf_s1 thm1;
	val mf_s3 = ¥_elim mf_s2 thm2
		handle complaint =>
		divert complaint "¥_elim" "¥_trans_rule" 7042
			[fn () => string_of_thm thm1, fn () => string_of_thm thm2];
in
	mf_s3
end);
end;
=TEX
=GFT
s13 Ù µ t1 t2 ∑ (t1 ¥ t2) ¥ (≥ t2) ¥ (≥ t1)
=TEX
=SML
local
	val s1 = asm_rule ¨t1 : BOOLÆ;
	val s2 = asm_rule ¨t1 ¥ t2Æ;
	val s3 = ¥_elim s2 s1;
	val s4 = asm_rule ¨≥ t2Æ;
	val s5 = ≥_elim mk_f s3 s4;
	val s6 = ¥_intro ¨t1 : BOOLÆ s5;
	val s7 = simple_µ_elim ¨t1 : BOOLÆ ≥_thm;
	val s8 = eq_sym_rule s7;
	val s9 = §_mp_rule s8 s6;
	val s10 = ¥_intro ¨≥ t2Æ s9;
	val s11 = ¥_intro ¨t1 ¥ t2Æ s10;
	val s12 = simple_µ_intro ¨t2 : BOOLÆ s11;
	val s13 = simple_µ_intro ¨t1 : BOOLÆ s12;
in
fun €modus_tollens_rule› (thm1 : THM) (thm2 : THM) : THM = (
let	val (t1,t2) = dest_¥(concl thm1);
	val mf_s1 = list_simple_µ_elim[t1,t2] s13;
	val mf_s2 = ¥_elim mf_s1 thm1;
	val mf_s3 = ¥_elim mf_s2 thm2;
in
	mf_s3
end
handle complaint =>
list_divert complaint "modus_tollens_rule" [
	("dest_¥",7040,[fn () => string_of_thm thm1]),
	("¥_elim",7051,[fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
end;
=TEX
\subsection{Concerning §}
=SML
fun €§_intro› (thm1 : THM) (thm2 : THM) : THM = (
let	val (t1,t2) = dest_¥ (concl thm1)
		handle complaint =>
		divert complaint "dest_¥" "§_intro" 7040 
		[fn () => string_of_thm thm1];
	val (t2',t1') = dest_¥ (concl thm2) (* dummy test *)
		handle complaint =>
		divert complaint "dest_¥" "§_intro" 7040 
		[fn () => string_of_thm thm2];
	val s1 = list_simple_µ_elim[t1,t2] ¥_antisym_axiom;
	val s2 = ¥_elim s1 thm1;
	val s3 = ¥_elim s2 thm2
		handle complaint =>
		divert complaint "¥_elim" "§_intro" 7064 
		[fn () => string_of_thm thm1, 
		 fn () => string_of_thm thm2];
in
	s3
end);
=TEX
We prove the local theorems (two of them because getting
the two conjuncts if we did one would take similar, if not greater effort)
=GFT
s8 Ù (t1 § t2) ¥ (t1 ¥ t2)
s14 Ù (t1 § t2) ¥ (t2 ¥ t1)
=TEX
=SML
local
	val s1 = asm_rule ¨t1 § t2Æ;
	val s2 = asm_rule ¨t1 : BOOLÆ;
	val s3 = asm_rule ¨t2 : BOOLÆ;
	val s4 = §_mp_rule s1 s2;
	val s5 = ¥_intro ¨t1 : BOOLÆ s4;
	val s6 = ¥_intro ¨t1 § t2Æ s5;
	val s7 = simple_µ_intro¨t2 : BOOLÆ s6;
	val s8 = simple_µ_intro¨t1 : BOOLÆ s7;
	
	val s9 = eq_sym_rule s1;
	val s10 = §_mp_rule s9 s3;
	val s11 = ¥_intro ¨t2 : BOOLÆ s10;
	val s12 = ¥_intro ¨t1 § t2Æ s11;
	val s13 = simple_µ_intro¨t2 : BOOLÆ s12;
	val s14 = simple_µ_intro¨t1 : BOOLÆ s13;
in
fun €§_elim› (thm : THM) : (THM * THM) = (
let	val (t1,t2) = dest_§(concl thm);
	val mf_s1 = list_simple_µ_elim[t1,t2]s8;
	val mf_s2 = ¥_elim mf_s1 thm;
	val mf_s3 = list_simple_µ_elim[t1,t2]s14;
	val mf_s4 = ¥_elim mf_s3 thm;
in
	(mf_s2, mf_s4)
end
handle complaint =>
divert complaint "dest_§" "§_elim" 7062 
	[fn () => string_of_thm thm]
);
end;
=TEX
\subsection{Concerning =}
=SML
fun €subst_conv› (thm_lst : (THM * TERM) list) : 
	(TERM -> CONV) = (
let		val s1 = subst_rule thm_lst
			handle complaint =>
			pass_on complaint "subst_rule" "subst_conv";
in
	(fn (template : TERM) =>
	(fn (tm:TERM) =>
	let
		val new_template = mk_eq(tm,template)
			handle complaint =>
			divert complaint "mk_eq" "subst_conv" 3012 
			[fn () => string_of_term tm, 
			 fn () => string_of_term template];
		val s2 = refl_conv tm;
		val s3 = s1 new_template s2
			handle complaint =>
			pass_on complaint "subst_rule" "subst_conv";
	in
		s3
	end))
end);
=TEX

We prove a local theorem:
=GFT
s9 Ù µ t1 t2 ∑ (t1 = t2) § (t2 = t1)
=TEX
=SML
local
	val s1 = asm_rule ¨(t1 : 'a) = t2Æ;
	val s2 = eq_sym_rule s1;
	val s3 = ¥_intro ¨(t1 : 'a) = t2Æ s2;
	val s4 = asm_rule ¨(t2 : 'a) = t1Æ;
	val s5 = eq_sym_rule s4;
	val s6 = ¥_intro ¨(t2 : 'a) = t1Æ s5;
	val s7 = §_intro s3 s6;
	val s8 = simple_µ_intro ¨t2 : 'aÆ s7;
	val s9 = simple_µ_intro ¨t1 : 'aÆ s8;
in
val €eq_sym_conv› : CONV = (fn (tm:TERM) =>
let	val (t1,t2) = dest_eq tm;
	val mf_s1 = inst_type_rule[(type_of t1,mk_vartype"'a")] s9;
	val mf_s2 = list_simple_µ_elim[t1,t2] mf_s1;
in
	mf_s2
end
handle complaint =>
pass_on complaint "dest_eq" "eq_sym_conv"
);
end;
=TEX
We prove a local theorem:
=GFT
s Ù µ t1 t2 :'a ∑ ≥(t1 = t2) § ≥(t2 = t1)
=TEX
=SML
local
	val s1 = eq_sym_conv ¨(t1 : 'a) = t2Æ;
	val s2 = ap_fun_rule ¨$≥Æ s1;
	val s3 = simple_µ_intro ¨t2 : 'aÆ s2;
	val s4 = simple_µ_intro ¨t1 : 'aÆ s3;
in
fun €≥_eq_sym_rule› (thm : THM) : THM = (
let	val (t1,t2) = dest_eq(dest_≥(concl thm));
	val mf_s1 = inst_type_rule[(type_of t1,mk_vartype "'a")] s4;
	val mf_s2 = list_simple_µ_elim [t1,t2] mf_s1;
	val mf_s3 = §_mp_rule mf_s2 thm;
in
	mf_s3
end
handle complaint =>
list_divert complaint "≥_eq_sym_rule" [
	("dest_eq",7091,[fn () => string_of_thm thm]),
	("dest_≥",7091,[fn () => string_of_thm thm])]
);
end;
=TEX

\subsection{Concerning µ}
=FRULE 1 Rule
list_simple_µ_intro
[¨x1Æ, ..., ¨xnÆ]
˜
á Ù t[x1, ..., xn]
˜
á Ù µ x1 ... xn ∑ t[x1, ..., xn]
=TEX
=SML
fun €list_simple_µ_intro› (tml : TERM list) (thm :THM) : THM = (
	fold (uncurry simple_µ_intro) tml thm
	handle complaint =>
	pass_on complaint "simple_µ_intro" "list_simple_µ_intro"
);
=TEX
=SML
fun €all_µ_intro› (thm : THM) : THM = (
let	val cfrees = rev(frees(concl thm));
	val afrees = list_cup (map frees (hyps thm));
	val nfrees = cfrees diff afrees;
	val s1 = list_simple_µ_intro nfrees thm;
in
	s1
end);
=TEX
=SML
fun €all_simple_µ_elim› (thm : THM) : THM = (
let	val c = concl thm;
	val cfrees = frees c;
	val all_frees = cfrees cup (list_cup (map frees (hyps thm)));
	val qvs = fst(strip_µ c);
	val qvs' = list_variant all_frees qvs;
	val s1 = list_simple_µ_elim qvs' thm;
in
	s1
end);
=TEX
\subsection{Concerning Õ}
=SML
fun €Õ_intro_rule› (thm : THM) : THM = (
let	val (tm1, tm2) = dest_app (concl thm);
	val s1 = inst_type_rule [(type_of tm2, mk_vartype "'a")] Õ_axiom;
	val s2 = simple_µ_elim tm1 s1;
	val s3 = simple_µ_elim tm2 s2;
	val s4 = ¥_elim s3 thm;
in
	s4
end
handle complaint =>
divert complaint "dest_app" "Õ_intro_rule" 7016 [fn () => string_of_thm thm]
);
=TEX

=SML
fun €Õ_elim_rule› (tm : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let	val sideeffect = dest_var tm
		handle complaint =>
		pass_on complaint "dest_var" "Õ_elim_rule";
	val sideeffect = if tm mem (frees (concl thm2))
		then fail "Õ_elim_rule" 7120 [
			fn () => string_of_term tm,
			fn () => string_of_thm thm2]
		else ();
	val (tm1, ctm1) = dest_app (concl thm1);
	val sideeffect = if tm mem (frees tm1)
		then fail "Õ_elim_rule" 7122 [
			fn () => string_of_term tm,
			fn () => string_of_thm thm1]
		else ();
	val tm1tm = mk_app (tm1, tm);
	val s1 = disch_rule tm1tm thm2;
	val s2 = simple_µ_intro tm s1
		handle complaint =>
		if area_of complaint = "simple_µ_intro"
		then fail "Õ_elim_rule" 7121 [
			fn () => string_of_term tm,
			fn () => string_of_thm thm2,
			fn () => string_of_term tm1tm]
		else reraise complaint (area_of complaint);
	val s3 = simple_µ_elim ctm1 s2;
	val s4 = ¥_elim s3 thm1;
in
	s4
end
handle complaint =>
list_divert complaint "Õ_elim_rule" [
	("dest_app",7019,[fn () => string_of_thm thm1]),
	("mk_app",7054,[fn () => string_of_term tm]),
	("disch_rule",7108,[fn () => fst(dest_var tm)])
	]
);
=TEX
\subsection{Concerning ∂}
=GFT
val simple_∂_intro_thm = Ù µ P x∑ P x ¥ $∂ P
=TEX
=SML
val €simple_∂_intro_thm› = (let 
	val tva = mk_vartype "'a";
	val tvb = mk_vartype "'b";
	val P = mk_var("P",mk_≠_type(tva,BOOL));
	val x = mk_var("x",tva);
	val Px = mk_app(P, x);
	val s1 = asm_rule Px;
	val s2 = Õ_intro_rule s1;
	val abs = mk_simple_Ã(x,Px);
	val s3 = ap_arg_rule P ∂_def;
	val s4 = simple_¬_conv (snd(dest_eq(concl s3)));
	val s5 = eq_trans_rule s3 s4;
	val s6 = eq_sym_rule s5;
	val s7 = §_mp_rule s6 s2;
	val s8 = ¥_intro Px s7;
	val s9 = simple_µ_intro x s8;
	val s10 = simple_µ_intro P s9;
in
	s10
end);

local
	val tva = mk_vartype "'a";
in
fun €simple_∂_intro› (tm : TERM) (thm : THM) : THM = (
let	val (x, t1x) = dest_simple_∂ tm
		handle complaint =>
		pass_on complaint "dest_simple_∂" "simple_∂_intro";
	val abs = snd(dest_app tm);
	val t2 = (case term_match (concl thm) t1x of
		(_, [(ltm, _)]) => ltm
		|(_, []) => x
		|Other => fail "simple_∂_intro" 7047 [
			fn () => string_of_term tm,
			fn () => string_of_thm thm])
		handle complaint =>
		divert complaint "term_match" "simple_∂_intro" 7047 [
			fn () => string_of_term tm,
			fn () => string_of_thm thm];
	val s1 = inst_type_rule[(type_of x, tva)]simple_∂_intro_thm;
	val s2 = list_simple_µ_elim[abs,t2]s1;
	val abst2 = fst(dest_¥(concl s2));
	val s3 = simple_¬_conv abst2;
	val s4 = eq_sym_rule s3;
	val s5 = §_mp_rule s4 thm;
	val s6 = ¥_elim s2 s5;
in
	s6
end);
end;
=TEX

=IGN
Old style implementation:
fun €simple_∂_intro› (tm : TERM) (thm : THM) : THM = (
let	val (x, t1x) = dest_simple_∂ tm
		handle complaint =>
		pass_on complaint "dest_simple_∂" "simple_∂_intro";
	val abs = snd(dest_app tm);
	val t2 = (case term_match (concl thm) t1x of
		(_, [(ltm, _)]) => ltm
		|(_, []) => x
		|Other => fail "simple_∂_intro" 7047 [
			fn () => string_of_term tm,
			fn () => string_of_thm thm])
		handle complaint =>
		divert complaint "term_match" "simple_∂_intro" 7047 [
			fn () => string_of_term tm,
			fn () => string_of_thm thm];
	val abst2 = mk_app (abs, t2);
	val s1 = simple_¬_conv abst2;
	val s2 = eq_sym_rule s1;
	val s3 = §_mp_rule s2 thm;
	val s4 = Õ_intro_rule s3;
	val s5 = inst_type_rule [(type_of x, mk_vartype "'a")] ∂_def;
	val s6 = ap_arg_rule abs s5;
	val s7 = simple_¬_conv (snd(dest_eq(concl s6)));
	val s8 = eq_trans_rule s6 s7;
	val s9 = eq_sym_rule s8;
	val s10 = §_mp_rule s9 s4;
in
	s10
end);
=TEX
=GFT
val simple_∂_elim_thm = Ù µ t1 t2∑ $∂ t1 ¥ 
	(µ y∑ t1 y ¥ t2) ¥ t2
=TEX
=SML
val €simple_∂_elim_thm› = (let 
	val tva = mk_vartype "'a";
	val tvb = mk_vartype "'b";
	val t1 = mk_var("t1",mk_≠_type(tva,BOOL));
	val t2 = mk_var("t2",BOOL);
	val y = mk_var("y",tva);
	val µt1y = mk_simple_µ(y,mk_¥(mk_app(t1,y),t2));
	
	val ∂t1 = mk_app(mk_const("∂",mk_≠_type(mk_≠_type
		(tva,BOOL),BOOL)),t1);
	
	val s1 = asm_rule ∂t1;
	val s2 = ap_arg_rule t1 ∂_def;
	val s3 = §_mp_rule s2 s1;
	val s4 = simple_¬_conv (concl s3);
	val s5 = §_mp_rule s4 s3;
	val s6 = asm_rule µt1y;
	val s7 = simple_µ_elim (snd(dest_app(concl s5))) s6;
	val s8 = ¥_elim s7 s5;
	val s9 = ¥_intro µt1y s8;
	val s10 = ¥_intro ∂t1 s9;
	val s11 = simple_µ_intro t2 s10;
	val s12 = simple_µ_intro t1 s11;
in
	s12
end);
=TEX
=SML
local
	val tva = mk_vartype "'a";
in
fun €simple_∂_elim› (v : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let	val sideeffect = if is_var v
		then ()
		else term_fail "simple_∂_elim" 3007 [v];
	val cthm1 = concl thm1;
	val (x, tx) = dest_simple_∂ cthm1;
	val t1 = snd(dest_app cthm1);
	val t1v = mk_app (t1, v);
	val t2 = concl thm2;
	val sideeffect = if is_free_in v t2
		then fail "simple_∂_elim" 7120 [
			fn () => string_of_term v,
			fn () => string_of_thm thm2]
		else if is_free_in v cthm1
		then fail "simple_∂_elim" 7120 [
			fn () => string_of_term v,
			fn () => string_of_thm thm1]
		else ();
	val s1 = inst_type_rule [(type_of x,tva)] simple_∂_elim_thm;
	val s2 = list_simple_µ_elim[t1,t2] s1;
	val s3 = ¥_elim s2 thm1;
	val s4 = simple_¬_conv t1v;
	val t1y = snd(dest_eq(concl s4));
	val s5 = asm_rule t1v; (* fst(§_elim...) *)
	val s6 = §_mp_rule s4 s5;
	val s8 = ¥_intro t1y thm2;
	val s9 = ¥_elim s8 s6;
	val s10 = ¥_intro t1v s9;
	val s11 = simple_µ_intro v s10
		handle complaint =>
		divert complaint "simple_µ_intro" "simple_∂_elim" 7121 [
			fn () => string_of_term v,
			fn () => string_of_thm thm2,
			fn () => string_of_term t1y];
	val s12 = ¥_elim s3 s11;
in
	s12
end
handle complaint =>
list_divert complaint "simple_∂_elim" [
	("dest_simple_∂",7109,[fn () => string_of_thm thm1]),
	("mk_app",7014,[fn () => string_of_term v])
	]
);
end;
=TEX

=IGN
Old style implementation:
fun €simple_∂_elim› (v : TERM) (thm1 : THM) (thm2 : THM) 
	: THM = (
let	val sideeffect = if is_var v
		then ()
		else term_fail "simple_∂_elim" 3007 [v];
	val cthm1 = concl thm1;
	val (x, tx) = dest_simple_∂ cthm1;
	val t1 = snd(dest_app cthm1);
	val t1v = mk_app (t1, v);
	val tvx = (case gen_vars [BOOL] ([(concl thm1), (concl thm2), v] 
		@ hyps thm1 @ hyps thm2) of
		[term] => term
		| _ => error "simple_∂_elim" 6032 [])
		handle complaint =>
		pass_on complaint "gen_vars" "simple_∂_elim";
	val s1 = inst_type_rule [(type_of x, mk_vartype "'a")] ∂_def;
	val s2 = ap_arg_rule t1 s1;
	val s3 = §_mp_rule s2 thm1;
	val s5 = conv_rule simple_¬_conv s3;
	val s6 = simple_¬_conv t1v;
	val s7 = eq_sym_rule s6;
	val asm = fst(dest_eq(concl s7))
	val s8 = ¥_intro asm thm2;
	val s9 = mk_¥ (tvx, concl thm2);
	val s10 = subst_rule [(s7, tvx)] s9 s8;
	val s11 = undisch_rule s10;
	val s12 = (Õ_elim_rule v s5 s11)
		handle complaint =>
		if area_of complaint <> "Õ_elim_rule"
		then reraise complaint (area_of complaint)
		else if v mem frees cthm1
		then fail "simple_∂_elim" 7120 [
			fn () => string_of_term v,
			fn () => string_of_thm thm1]
		else if v mem frees (concl thm2)
		then fail "simple_∂_elim" 7120 [
			fn () => string_of_term v,
			fn () => string_of_thm thm2]
		else fail "simple_∂_elim" 7121 [
			fn () => string_of_term v,
			fn () => string_of_thm thm2,
			fn () => string_of_term asm];
in
	s12
end
handle complaint =>
list_divert complaint "simple_∂_elim" [
	("dest_simple_∂",7109,[fn () => string_of_thm thm1]),
	("mk_app",7014,[fn () => string_of_term v])
	]
);
=TEX

=SML
val €simple_∂_Õ_conv› : CONV = (fn (tm:TERM) =>
let	val (x, tx) = (dest_simple_∂ tm)
		handle complaint =>
		pass_on complaint "dest_simple_∂" "simple_∂_Õ_conv";
	val t1 = mk_simple_Ã (x, tx);
	val s1 = inst_type_rule [(type_of x, mk_vartype "'a")] ∂_def;
	
	val s2 = ap_arg_rule t1 s1;
	val s3 = concl s2;
	val conv1 = (RAND_C simple_¬_conv THEN_C
			RAND_C simple_¬_conv)
	val s4 = conv1 s3;
	val s5 = §_mp_rule s4 s2;
in
	s5
end);
=TEX

=SML
fun €simple_∂_Õ_rule› (thm : THM) : THM = (
let	val s1 = conv_rule simple_∂_Õ_conv thm
in
	s1
end
	handle complaint =>
	divert complaint "simple_∂_Õ_conv" "simple_∂_Õ_rule" 7092 
	[fn () => string_of_thm thm]
);
=TEX

See section~\ref{SplitStructure} for an explanation of the
structure declarations in the next piece of Standard~ML.

=SML
end; (* of structure DerivedRules1 *)

structure €DerivedRules1› : DerivedRules1 = struct

open DerivedRules1;
=TEX

\subsection{Concerning $if\ldots then\ldots else \ldots$}
=SML
local
	val s1 = ap_arg_rule ¨a : BOOLÆ cond_def;
	val s2 = ap_arg_rule ¨t1 : 'aÆ s1;
	val s3 = ap_arg_rule ¨t2 : 'aÆ s2;
	val s4 = conv_rule (MAP_C simple_¬_conv) s3;
	val s5 = simple_µ_intro ¨t2 : 'aÆ s4;
	val s6 = simple_µ_intro ¨t1 : 'aÆ s5;
	val s7 = simple_µ_intro ¨a : BOOLÆ s6;

in
	val €cond_thm› = save_thm("cond_thm", s7);
end;
=TEX
A local function:
=FRULE 1 Rule
if_intro_rule
¨aÆ
˜
á1, a Ù x = tt ; á2, ≥a' Ù x = et
˜
á1 ¿ á2 Ù x = if a then tt else et
=TEX
=GFT
s35 Ù µ x a t1 t2 ∑ (a ¥ (x = t1)) ¥ (≥ a ¥ (x = t2)) ¥ 
	(x = if a then t1 else t2)
=TEX
=SML
local
	val s1 = asm_rule ¨a ¥ ((x:'a) = t1)Æ;
	val s2 = asm_rule ¨a § TÆ;
	val s3 = §_t_elim s2;
	val s4 = ¥_elim s1 s3;
	val s5 = ¥_intro ¨a § TÆ s4;
	val s6 = asm_rule ¨≥ a ¥ ((x:'a) = t2)Æ;
	val s7 = asm_rule ¨a § FÆ;
	val s8 = simple_µ_elim ¨a : BOOLÆ ≥_1_thm;
	val s9 = eq_sym_rule s8;
	val s10 = §_mp_rule s9 s7;
	val s11 = ¥_elim s6 s10;
	val s12 = ¥_intro ¨a § FÆ s11;
	val s13 = ±_intro s5 s12;
	val s14 = simple_¬_conv 
		(mk_app(
		(mk_simple_Ã(¨x : 'aÆ, concl s13),
		¨x : 'aÆ)));
	val s15 = eq_sym_rule s14;
	val s16 = §_mp_rule s15 s13;
	val s17 = Õ_intro_rule s16;
	val s18 = list_simple_µ_elim[¨a : BOOLÆ, ¨t1 : 'aÆ, ¨t2 : 'aÆ] cond_thm;
	val s19 = eq_sym_rule s18;
	val s20 = subst_rule[(s19,¨y : 'aÆ)]
		(mk_app(fst(dest_app(concl s17)),¨y : 'aÆ))
		s17;
	val s21 = conv_rule simple_¬_conv s20;

	val s22 = ±_left_elim s21;
	val s23 = undisch_rule s22;
	val s24 = eq_sym_rule s4;
	val s25 = subst_rule[(s24,¨y : 'aÆ)]
		(mk_app(fst(dest_app(concl s23)),¨y : 'aÆ))
		s23;
	
	val s26 = ±_right_elim s21;
	val s27 = undisch_rule s26;
	val s28 = eq_sym_rule s11;
	val s29 = subst_rule[(s28,¨y : 'aÆ)]
		(mk_app(fst(dest_app(concl s27)),¨y : 'aÆ))
		s27;

	val s30 = simple_µ_elim ¨a : BOOLÆ bool_cases_axiom;
	val s31 = ≤_elim s30 s25 s29;
	val s32 = eq_sym_rule s31;
	val s33 = ¥_intro ¨≥ a ¥ ((x:'a) = t2)Æ s32;
	val s34 = ¥_intro ¨a ¥ ((x:'a) = t1)Æ s33;
	val s35 = list_simple_µ_intro[¨x : 'aÆ, ¨a : BOOLÆ, ¨t1 : 'aÆ, ¨t2 : 'aÆ] s34;
in
fun €if_intro_rule› (a : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let	val (x,t1) = dest_eq(concl thm1)
		handle complaint =>
		divert complaint "dest_eq" "if_intro_rule" 6020 
			[fn () => string_of_thm thm1];
	val (x',t2) = dest_eq(concl thm2)
		handle complaint =>
		divert complaint "dest_eq" "if_intro_rule" 6020 
			[fn () => string_of_thm thm2];
	val mf_s1 = ¥_intro a thm1
		handle complaint =>
		divert complaint "¥_intro" "if_intro_rule" 3031 
			[fn () => string_of_term a];
	val mf_s2 = ¥_intro (mk_≥ a) thm2;
	val mf_s3 = inst_type_rule[(type_of x,mk_vartype"'a")]
		s35;
	val mf_s4 = list_simple_µ_elim[x,a,t1,t2]mf_s3;
	val mf_s5 = ¥_elim mf_s4 mf_s1;
	val mf_s6 = ¥_elim mf_s5 mf_s2;
in
	mf_s6
end);
end; (* of local val s1 ... *)
=TEX
=FRULE 1 Rule
if_then_elim_rule
˜
á Ù x = if tc then tt else te
˜
á Ù tc ¥ x = tt
=TEX
Prove the local theorem:
=GFT
s28 Ù µ x a t1 t2 ∑ (x = if a then t1 else t2) ¥ (a ¥ x = t1)
=TEX
=SML
local
	val s1 = asm_rule ¨a : BOOLÆ;
	val s2 = asm_rule ¨a § FÆ;
	val s3 = simple_µ_elim ¨a : BOOLÆ ≥_1_thm;
	val s4 = eq_sym_rule s3;
	val s5 = §_mp_rule s4 s2;
	val s6 = ≥_elim ¨(t1 : 'a) = t2Æ s1 s5;
	val s7 = ¥_intro ¨a § FÆ s6;
	val s8 = refl_conv ¨t1 : 'aÆ;
	val s9 = ¥_intro ¨a § TÆ s8;
	val s10 = ±_intro s9 s7;

	val s11 = simple_¬_conv 
		¨(Ã y: 'a ∑ ((a § T) ¥ y = t1) ± ((a § F) ¥ y = t2)) t1Æ;
	val s12 = eq_sym_rule s11;
	val s13 = §_mp_rule s12 s10;
	val s14 = Õ_intro_rule s13;
	val s15 = list_simple_µ_elim [¨a : BOOLÆ, ¨t1 : 'aÆ, ¨t2 : 'aÆ] cond_thm;
	val s16 = eq_sym_rule s15;
	val s17 = subst_rule[(s16,¨z : 'aÆ)]
		(mk_app(fst(dest_app(concl s14)),¨z : 'aÆ))
		s14;
	val s18 = asm_rule ¨(x:'a) = if a then t1 else t2Æ;
	val s19 = eq_sym_rule s18;
	val s20 = subst_rule[(s19,¨z : 'aÆ)]
		(mk_app(fst(dest_app(concl s17)),¨z : 'aÆ))
		s17;
	val s21 = conv_rule simple_¬_conv s20;
	val s22 = ±_left_elim s21;
	val s23 = §_t_intro s1;
	val s25 = ¥_elim s22 s23;
	val s26 = ¥_intro ¨a : BOOLÆ s25;
	val s27 = ¥_intro ¨(x:'a) = if a then t1 else t2Æ s26;
	val s28 = list_simple_µ_intro[¨x : 'aÆ, ¨a : BOOLÆ, ¨t1 : 'aÆ, ¨t2 : 'aÆ] s27;
in
fun €if_then_elim_rule› (thm : THM) = (
let	val (x,ifa)= dest_eq(concl thm)
		handle complaint =>
		pass_on complaint "dest_eq" "if_then_elim_rule";
	val (a,t1,t2) = dest_if ifa
		handle complaint =>
		pass_on complaint "dest_if" "if_then_elim_rule";
	val mf_s1 = inst_type_rule[(type_of x,mk_vartype "'a")] s28;
	val mf_s2 = list_simple_µ_elim[x,a,t1,t2] mf_s1;
	val mf_s3 = ¥_elim mf_s2 thm;
in
	mf_s3
end);
end; (* of local val s1 = ... *)
=TEX
=FRULE 1 Rule
if_else_elim_rule
˜
á Ù x = if tc then tt else te
˜
á Ù ≥ tc ¥ x = te
=TEX
=GFT
s29 Ù µ x a t1 t2 ∑ x = (if a then t1 else t2) ¥ ≥ a ¥ x = t2
=TEX
=SML
local
	val s1 = asm_rule ¨≥ a Æ;
	val s2 = asm_rule ¨a § TÆ;
	val s4 = §_t_elim s2;
	val s6 = ≥_elim ¨(t2 : 'a) = t1Æ s4 s1;
	val s7 = ¥_intro ¨a § TÆ s6;
	val s8 = refl_conv ¨t2 : 'aÆ;
	val s9 = ¥_intro ¨a § FÆ s8;
	val s10 = ±_intro s7 s9;

	val s11 = simple_¬_conv 
		¨(Ã y: 'a ∑ ((a § T) ¥ y = t1) ± ((a § F) ¥ y = t2)) t2Æ;
	val s12 = eq_sym_rule s11;
	val s13 = §_mp_rule s12 s10;
	val s14 = Õ_intro_rule s13;
	val s15 = list_simple_µ_elim [¨a : BOOLÆ, ¨t1 : 'aÆ, ¨t2 : 'aÆ] cond_thm;
	val s16 = eq_sym_rule s15;
	val s17 = subst_rule[(s16,¨z : 'aÆ)]
		(mk_app(fst(dest_app(concl s14)),¨z : 'aÆ))
		s14;
	val s18 = asm_rule ¨(x:'a) = if a then t1 else t2Æ;
	val s19 = eq_sym_rule s18;
	val s20 = subst_rule[(s19,¨z : 'aÆ)]
		(mk_app(fst(dest_app(concl s17)),¨z : 'aÆ))
		s17;
	val s21 = conv_rule simple_¬_conv s20;
	val s22 = ±_right_elim s21;
	val s23 = simple_µ_elim ¨a : BOOLÆ ≥_1_thm;
	val s24 = fst(§_elim s23);
	val s25 = ¥_trans_rule s24 s22;
	val s26 = ¥_elim s25 s1;
	val s27 = ¥_intro ¨≥ aÆ s26;
	val s28 = ¥_intro ¨(x:'a) = if a then t1 else t2Æ s27;
	val s29 = list_simple_µ_intro[¨x : 'aÆ, ¨a : BOOLÆ, ¨t1 : 'aÆ, ¨t2 : 'aÆ] s28;
in
fun €if_else_elim_rule› (thm : THM) = (
let	val (x,ifa)= dest_eq(concl thm)
		handle complaint =>
		pass_on complaint "dest_eq" "if_else_elim_rule";
	val (a,t1,t2) = dest_if ifa
		handle complaint =>
		pass_on complaint "dest_if" "if_else_elim_rule";
	val mf_s1 = inst_type_rule[(type_of x,mk_vartype "'a")] s29;
	val mf_s2 = list_simple_µ_elim[x,a,t1,t2] mf_s1;
	val mf_s3 = ¥_elim mf_s2 thm;
in
	mf_s3
end);
end; (* of local val s1 = ... *)
=TEX
=GFT
s9 Ù µ f a t1 t2 ∑ f(if a then t1 else t2) =
	if a then (f t1) else (f t2)
s11 Ù µ f a t1 t2 ∑ if a then (f t1) else (f t2) =
	f(if a then t1 else t2)
=TEX
=SML
local
	val s1 = refl_conv ¨if a then (t1:'a) else t2Æ;
	val s2 = if_then_elim_rule s1;
	val s3 = undisch_rule s2;
	val s4 = ap_fun_rule ¨f : 'a ≠ 'bÆ s3;
	val s5 = if_else_elim_rule s1;
	val s6 = undisch_rule s5;
	val s7 = ap_fun_rule ¨f : 'a ≠ 'bÆ s6;
	val s8 = if_intro_rule ¨a : BOOLÆ s4 s7;
	val s9 = list_simple_µ_intro[¨f : 'a ≠ 'bÆ, ¨a : BOOLÆ, ¨t1 : 'aÆ, ¨t2 : 'aÆ] s8;
	val s10 = eq_sym_rule s8;
	val s11 = list_simple_µ_intro[¨f : 'a ≠ 'bÆ, ¨a : BOOLÆ, ¨t1 : 'aÆ, ¨t2 : 'aÆ] s10;
in
val €fun_if_conv› : CONV = (fn (tm:TERM) =>
let	val (f,ifa) = dest_app tm;
	val (a,t1,t2) = dest_if ifa;
	val (aty,bty) = dest_≠_type(type_of f);
	val mf_s1 = inst_type_rule[(aty,mk_vartype"'a"),(bty,mk_vartype"'b")]s9;
	val mf_s2 = list_simple_µ_elim[f,a,t1,t2] mf_s1;
in
	mf_s2
end
handle complaint =>
list_divert complaint "fun_if_conv" [
	("dest_app",7098,[fn () => string_of_term tm]),
	("dest_if",7098,[fn () => string_of_term tm])]
);
val €if_fun_conv› : CONV = (fn (tm:TERM) =>
let	val (a,ft1,ft2) = dest_if tm;
	val (f,t1) = dest_app ft1;
	val (f',t2) = dest_app ft2;
	val (aty,bty) = dest_≠_type(type_of f);
	val mf_s1 = inst_type_rule[(aty,mk_vartype"'a"),(bty,mk_vartype"'b")]s11;
	val mf_s2 = list_simple_µ_elim[f,a,t1,t2] mf_s1;
	val mf_s3 = refl_conv tm;
	val mf_s4 = eq_trans_rule mf_s3 mf_s2;
in
	mf_s4
end
handle complaint =>
list_divert complaint "if_fun_conv" [
	("dest_app",7037,[fn () => string_of_term tm]),
	("dest_if",7037,[fn () => string_of_term tm]),
	("eq_trans_rule",7038,[fn () => string_of_term tm])]
);
end; (* local val s1 = ... *)
=TEX
We prove the local theorem:
=GFT
s12 Ù µ a t1 t2 ∑ (a ¥ t1) ¥ (≥ a ¥ t2) ¥ 
	(if a then t1 else t2)
=TEX
=SML
local
	val s1 = asm_rule ¨a ¥ t1Æ;
	val s2 = undisch_rule s1;
	val s3 = §_t_intro s2;
	val s4 = eq_sym_rule s3;

	val s5 = asm_rule ¨≥ a ¥ t2Æ;
	val s6 = undisch_rule s5;
	val s7 = §_t_intro s6;
	val s8 = eq_sym_rule s7;

	val s9 = if_intro_rule ¨a:BOOLÆ s4 s8;
	val s10 = eq_sym_rule s9;
	val s11 = §_t_elim s10;
	val s12 = ¥_intro ¨≥ a ¥ t2Æ s11;
	val s13 = ¥_intro ¨a ¥ t1Æ s12;
	val s14= list_simple_µ_intro[¨a : BOOLÆ, ¨t1 : BOOLÆ, ¨t2 : BOOLÆ] s13;
in
fun €if_intro› (a : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let	val mf_s1 = ¥_intro a thm1
		handle complaint =>
		divert complaint "¥_intro" "if_intro" 3031 [fn () => string_of_term a];
	val mf_s2 = ¥_intro (mk_≥ a) thm2;
	val mf_s3 = list_simple_µ_elim[a,concl thm1, concl thm2]s14
		handle complaint =>
		divert complaint "list_simple_µ_elim" "if_intro" 3031
			[fn () => string_of_term a];
	val mf_s4 = ¥_elim mf_s3 mf_s1;
	val mf_s5 = ¥_elim mf_s4 mf_s2;
in
	mf_s5
end);
end; (* of local val s1 ... *)
=TEX
Prove the local theorem:
=GFT
s10 Ù µ a t1 t2 ∑ (if a then t1 else t2) ¥ (a ¥ t1)
=TEX
=SML
local
	val s1 = asm_rule ¨if a then (t1:BOOL) else t2Æ;
	val s2 = §_t_intro s1;
	val s3 = eq_sym_rule s2;
	val s4 = if_then_elim_rule s3;
	val s5 = undisch_rule s4;
	val s6 = eq_sym_rule s5;
	val s7 = §_t_elim s6;
	val s8 = ¥_intro ¨a : BOOLÆ s7;
	val s9 = ¥_intro ¨if a then (t1:BOOL) else t2Æ s8;
	val s10 = list_simple_µ_intro[¨a : BOOLÆ, ¨t1 : BOOLÆ, ¨t2 : BOOLÆ] s9;
in
fun €if_then_elim› (thm : THM) : THM = (
let	val (a,t1,t2) = dest_if (concl thm);
	val mf_s2 = list_simple_µ_elim[a,t1,t2] s10;
	val mf_s3 = ¥_elim mf_s2 thm;
in
	mf_s3
end
handle complaint =>
list_divert complaint "if_then_elim" [
	("dest_if",7012,[fn () => string_of_thm thm])]
);
end; (* of local val s1 = ... *)
=TEX
=GFT
s10 Ù µ a t1 t2 ∑ (if a then t1 else t2) ¥ ≥ a ¥ t2
=TEX
=SML
local
	val s1 = asm_rule ¨if a then (t1:BOOL) else t2Æ;
	val s2 = §_t_intro s1;
	val s3 = eq_sym_rule s2;
	val s4 = if_else_elim_rule s3;
	val s5 = undisch_rule s4;
	val s6 = eq_sym_rule s5;
	val s7 = §_t_elim s6;
	val s8 = ¥_intro ¨≥ aÆ s7;
	val s9 = ¥_intro ¨if a then (t1:BOOL) else t2Æ s8;
	val s10 = list_simple_µ_intro[¨a : BOOLÆ, ¨t1 : BOOLÆ, ¨t2 : BOOLÆ] s9;
in
fun €if_else_elim› (thm : THM) : THM = (
let	val (a,t1,t2) = dest_if (concl thm);
	val mf_s2 = list_simple_µ_elim[a,t1,t2] s10;
	val mf_s3 = ¥_elim mf_s2 thm;
in
	mf_s3
end
handle complaint =>
list_divert complaint "if_else_elim" [
	("dest_if",7012,[fn () => string_of_thm thm])]
);
end; (* of local val s1 = ... *)
=TEX
\subsection{Concerning Functional Application}
=SML
fun €ext_rule› (thm : THM): THM  = (
let	val (h,c) =dest_thm thm;
	val (f,g) = dest_eq c;
	val mgv = hd(gen_vars [fst(dest_≠_type(type_of f))]
		(c :: h));
	val s1 = ap_arg_rule mgv thm;
	val s2 = simple_µ_intro mgv s1;
in
	s2
end
handle complaint =>
list_divert complaint "ext_rule" [
	("dest_eq",6020,[fn () => string_of_thm thm]),
	("dest_≠_type",7026,[fn () => string_of_thm thm])]
);
=TEX
\subsection{Concerning Assumptions}
=SML
fun €asm_intro› (tm : TERM) (thm : THM) : THM = (
let	val s1 = ¥_intro tm thm
		handle complaint =>
		pass_on complaint "¥_intro" "asm_intro";
	val s2 = asm_rule tm;
	val s3 = ¥_elim s1 s2;
in
	s3
end);
=TEX
=GFT
s15 Ù µ a t ∑ (a ¥ t) ¥ (≥ a ¥ t) ¥ t
=TEX
=SML
local 
	val s1 = simple_µ_elim ¨a : BOOLÆ bool_cases_axiom;
	val s2 = asm_rule ¨a ¥ tÆ;
	val s3 = asm_rule ¨a § TÆ;
	val s4 = §_t_elim s3;
	val s5 = ¥_elim s2 s4;
	val s6 = asm_rule ¨≥a ¥ tÆ;
	val s7 = asm_rule ¨a § FÆ;
	val s8 = simple_µ_elim ¨a : BOOLÆ ≥_1_thm;
	val s9 = eq_sym_rule s8;
	val s10 = §_mp_rule s9 s7;
	val s11 = ¥_elim s6 s10;
	val s12 = ≤_elim s1 s5 s11;
	val s13 = ¥_intro ¨≥a ¥ tÆ s12;
	val s14 = ¥_intro ¨a ¥ tÆ s13;
	val s15 = list_simple_µ_intro[¨a : BOOLÆ,¨t : BOOLÆ] s14;
in
fun €asm_elim› (tm : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let	val t = concl thm1;
	val mf_s1 = list_simple_µ_elim [tm,t] s15;
	val mf_s2 = ¥_intro tm thm1;
	val mf_s3 = ¥_intro (mk_≥ tm) thm2;
	val mf_s4 = ¥_elim mf_s1 mf_s2;
	val mf_s5 = ¥_elim mf_s4 mf_s3;
in
	mf_s5
end
handle complaint =>
list_divert complaint "asm_elim" [
	("list_simple_µ_elim", 3031, [fn () => string_of_term tm]),
	("¥_elim",7029,[fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
end; (* local val s1 = ... *)
=TEX
=SML
fun €prove_asm_rule› (thm1 : THM) (thm2 : THM) : THM = (
let	val c1 = concl thm1;
	val s1 = ¥_intro c1 thm2;
	val s2 = ¥_elim s1 thm1;
in
	s2
end);
=TEX
=SML
fun €asm_inst_term_rule› (tml : (TERM * TERM) list) (thm : THM) : THM = (
let	val nhyps = length(strip_¥ (concl thm));
	val s1 = all_¥_intro thm;
	val nhyps1 = length(strip_¥ (concl s1));
	val s2 = inst_term_rule tml s1;
	val s3 = fold (fn (_,x) => undisch_rule x)
		(interval 1 (nhyps1 - nhyps)) s2;
in
	s3
end
handle complaint =>
pass_on complaint "inst_term_rule" "asm_inst_term_rule"
);
=TEX
=SML
fun €asm_inst_type_rule› (tyl : (TYPE * TYPE) list) (thm : THM) : THM = (
let	val nhyps = length(strip_¥ (concl thm));
	val s1 = all_¥_intro thm;
	val nhyps1 = length(strip_¥ (concl s1));
	val s2 = inst_type_rule tyl s1;
	val s3 = fold (fn (_,x) => undisch_rule x)
		(interval 1 (nhyps1 - nhyps)) s2;
in
	s3
end
handle complaint =>
pass_on complaint "inst_type_rule" "asm_inst_type_rule"
);
=TEX
\subsection{Concerning Matching Functions}
The function $apply\_matches\_rule$ encodes the matching attempt, should
a simple use of the rule fail.
It is given a term to match against,
a method of extracting the part to match,and the theorem
that is to be instantiated.
It presumes that the theorem it is passed is stripped
of all outer universal quantifers.
It brings up to the conclusion all the hypotheses.
It instantiates types to the minimum required,
instantiates free variables to the minimum required
(notice that we must not instantiate the universally quantified variables of $thm$ that occur free in the assumptions:
thus $tmm'$)
and then returns are the hypotheses to the assumption list.

The order of arguments to $@$ in $subs\_for$ is closely
tied to whether we do $inst\-\_term\-\_rule$
or $list\-\_simple\-\_µ\-\_elim$ first.

Note that $term\_match$ is not infallible.
=SML
local
	fun strip_n_¥ 0 tm = tm
	| strip_n_¥ n tm = strip_n_¥ (n-1) (snd(dest_¥ tm));
in
fun €apply_matches_rule› (caller : string) 
	(match_against : TERM)
	(extract : TERM -> TERM)
	(thm : THM) : THM = (
let	val cnc = concl thm;
	val cfrees = frees cnc;
	val all_frees = cfrees cup (list_cup (map frees (hyps thm)));
	val qvs = fst(strip_µ cnc);
	val subs_for = all_frees @ qvs;
	val subs_with = list_variant [] subs_for;
	val length_all_frees = length all_frees;
	val qvs' = subs_with from length_all_frees;
	val all_frees' = subs_with to (length_all_frees - 1);
	val s1 = list_simple_µ_elim qvs' thm;
	val c = concl s1;
	val nhyps = length(strip_¥ c);
	val s2 = all_¥_intro s1;
	val nhyps1 = length(strip_¥ (concl s2));
	val s3 = inst_term_rule(combine all_frees' all_frees) s2;
	val t1 = extract (strip_n_¥ (nhyps1 - nhyps)(concl s3));
	val (tym,tmm) = term_match match_against t1;
	val s4 = inst_type_rule tym s3;
	val s5 = inst_term_rule tmm s4;
	val s6 = fold (fn (_,x) => undisch_rule x)
		(interval 1 (nhyps1 - nhyps)) s5;
in
	s6
end
handle (Fail _) => fail caller 7044 [fn () => string_of_term match_against,
		fn () => string_of_thm thm]
);
end;
=TEX
The function $apply\_matches\_rule1$ encodes the matching attempt, should
a simple use of the rule fail, but unlike the above does not attempt
to modify the assumptions.
It is given a term to match against,
a method of extracting the part to match,and the theorem
that is to be instantiated.
The theorem it is passed is stripped
of all outer universal quantifers.
It instantiates types to the minimum required,
instantiates free variables to the minimum required
(notice that we must not instantiate the universally quantified variables of $thm$ that occur free in the assumptions:
thus $tmm'$).

The order of arguments to $@$ in $subs\_for$ is closely
tied to whether we do $inst\-\_term\-\_rule$
or $list\-\_simple\-\_µ\-\_elim$ first.

Note that $term\_match$ is not infallible.
=SML
fun €apply_matches_rule1› (caller : string) 
	(match_against : TERM)
	(extract : TERM -> TERM)
	(thm : THM) : THM = (
let	val cnc = concl thm;
	val cfrees = frees cnc;
	val afrees = (list_cup (map frees (hyps thm)));
	val just_c_frees = cfrees diff afrees;
	val qvs = fst(strip_µ cnc);
	val subs_for = just_c_frees @ qvs;
	val subs_with = list_variant afrees subs_for;
	val length_just_c_frees = length just_c_frees;
	val qvs' = subs_with from length_just_c_frees;
	val just_c_frees' = subs_with to (length_just_c_frees-1);
	val s1 = list_simple_µ_elim qvs' thm;
	val s3 = inst_term_rule(combine just_c_frees' just_c_frees) s1;
	val t1 = extract (concl s3);
	val (tym,tmm) = term_match match_against t1;
	val s4 = inst_type_rule tym s3;
	val s5 = inst_term_rule tmm s4;
in
	s5
end
handle (Fail _) => fail caller 7044 [
		fn () => string_of_term match_against, 
		fn () => string_of_thm thm]
);
=TEX
Now we use the above two in the various forms of matching.
=SML
local
fun aux (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = apply_matches_rule "simple_¥_match_mp_rule" 
		(concl thm2) (fst o dest_¥) thm1;
	val s2 = ¥_elim s1 thm2;
in
	s2
end
handle complaint =>
list_divert complaint "simple_¥_match_mp_rule" [
	("¥_elim", 7044, [fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
in
fun €simple_¥_match_mp_rule› (thm1 : THM) (thm2 : THM) : THM = (	
let	val s1 = ¥_elim thm1 thm2;
in
	s1
end
	handle complaint =>
	aux thm1 thm2
);
end;
=TEX
=SML
local
fun aux (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = apply_matches_rule1 "simple_¥_match_mp_rule1" 
		(concl thm2) (fst o dest_¥) thm1;
	val s2 = ¥_elim s1 thm2;
in
	s2
end
handle complaint =>
list_divert complaint "simple_¥_match_mp_rule1" [
	("¥_elim", 7044, [fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
in
fun €simple_¥_match_mp_rule1› (thm1 : THM) (thm2 : THM) : THM = (	
let	val s1 = ¥_elim thm1 thm2;
in
	s1
end
	handle complaint =>
	aux thm1 thm2
);
end;
=TEX
=SML
local
fun aux (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = apply_matches_rule "simple_§_match_mp_rule" 
		(concl thm2) (fst o dest_§) thm1;
	val s2 = §_mp_rule s1 thm2;
in
	s2
end
handle complaint =>
list_divert complaint "simple_§_match_mp_rule" [
	("§_mp_rule", 7044, [fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
in
fun €simple_§_match_mp_rule› (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = §_mp_rule thm1 thm2;
in
	s1
end
	handle complaint =>
	aux thm1 thm2
);
end;
local
fun aux (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = apply_matches_rule1 "simple_§_match_mp_rule1" 
		(concl thm2) (fst o dest_§) thm1;
	val s2 = §_mp_rule s1 thm2;
in
	s2
end
handle complaint =>
list_divert complaint "simple_§_match_mp_rule1" [
	("§_mp_rule", 7044, [fn () => string_of_thm thm1, fn () => string_of_thm thm2])]
);
in
fun €simple_§_match_mp_rule1› (thm1 : THM) (thm2 : THM) : THM = (
let	val s1 = §_mp_rule thm1 thm2;
in
	s1
end
	handle complaint =>
	aux thm1 thm2
);
end;
=TEX
=SML
local
fun aux (thm : THM) : CONV = (fn (tm :TERM) =>
let	val s1 = apply_matches_rule "simple_eq_match_conv" tm (fst o dest_eq) thm;
	val s2 = eq_trans_rule (refl_conv tm) s1;
in
	s2
end
handle complaint =>
list_divert complaint "simple_eq_match_conv" [
	("eq_trans_rule", 7076, [fn () => string_of_term tm,
		fn () => string_of_thm thm])]
);
in
fun €simple_eq_match_conv› (thm : THM) : CONV = (fn (tm :TERM) =>
let	val s1 = eq_trans_rule (refl_conv tm) thm;
in
	s1
end
	handle complaint =>
	aux thm tm
);
end;
=TEX
In the following we just map all failures bar $dest\_eq$
onto 7076, without working out whether the error is 
an ``expected'' one.
This is because we want this function to fail fast as well are succeed fast.
=SML
fun €simple_eq_match_1_conv› (thm : THM) : CONV = (
let	val (qvs,body) = strip_µ (concl thm);
	val (t1,_) = dest_eq body;
in
(fn (tm :TERM) =>
let	val (tym,tmm) = term_match tm t1;
	val s2 = inst_type_rule tym thm;

	fun aux1 (qv :: rest) : TERM list = (
	let	val qv' = inst [] tym qv;
	in
		(rassoc1 tmm qv') :: aux1 rest 
	end
	) | aux1 [] = [];

	val s3 = list_simple_µ_elim (aux1 qvs) s2;
	val s4 = eq_trans_rule (refl_conv tm) s3;
in
	s4
end
handle (Fail _) => fail "simple_eq_match_1_conv" 7076 [fn () => string_of_term tm,
	fn () => string_of_thm thm]
)
end
handle complaint =>
divert complaint "dest_eq" "simple_eq_match_1_conv" 7095 
	[fn () => string_of_thm thm]
);
=TEX
\subsection{Concerning Ã}
=SML
fun €Ã_rule› (tm : TERM) (thm : THM) : THM = (
let	val mgv = hd(gen_vars [type_of tm] [tm]);
	val sx = subst [(mgv,tm)] (concl thm);
	val mgv_sx = mk_app(mk_simple_Ã(mgv,sx),tm)
	val s1 = simple_¬_conv mgv_sx;
	val s2 = eq_sym_rule s1;
	val s3 = §_mp_rule s2 thm
in
	s3
end);
=TEX
In assessing the following, note that requesting, say, $ap\_arg\_rule$
is equivalent to requesting a $refl\_conv$ and a $mk\_app\_rule$ as far as efficiency goes.
In addition, note that the original term, $tm$ is in the sco[pe of $aux2$, saving a $mk\_app$.
=SML
val €all_simple_¬_conv› : CONV = (
let
fun rhs (thm: THM) : TERM = snd(dest_eq(concl thm));
fun asbc (tm : TERM) : THM OPT = (
let	val dt = dest_simple_term tm;

	fun aux1 thm1 thm2 = (
	let	val s1 = mk_app_rule thm1 thm2
	in
		Value (
		if not(is_simple_Ã(rhs thm1))
		then s1
		else (let val s2 = conv_rule (RAND_C simple_¬_conv) s1;
		in
		if is_simple_Ã(rhs thm2)
		then (
			case (asbc (rhs s2)) of
			Nil => s2
			| Value s3 => eq_trans_rule s2 s3
		) else s2
		end)
		)
	end);

	fun aux2 (f : TERM) (x : TERM) : THM OPT = (
	if is_simple_Ã f
	then 	(Value(
		if is_simple_Ã x
		then ((simple_¬_conv FURTHER_C(fn tm1 =>
			force_value (asbc tm1))) tm)
		else (simple_¬_conv tm)
		))
	else Nil);

	fun aux (App (f, x)) = (
	let	val fr = asbc f;
		val xr = asbc x;
	in
		case (fr,xr) of
		(Nil, Nil) => aux2 f x
		| (Value frt,Nil) => aux1 frt (refl_conv x)
		| (Nil, Value xrt) => aux1 (refl_conv f) xrt
		| (Value frt, Value xrt) => aux1 frt xrt
	end
	) | aux (SimpleÃ (x, b)) = (
	let	val br = asbc b
	in
		case br of
		Nil => Nil
		| (Value brt) => Value(simple_Ã_eq_rule x brt)
	end
	) | aux _ = Nil;
in
	aux dt
end);
in
	(fn (tm:TERM) => case (asbc tm) of
		Value red => red
		| Nil => term_fail "all_simple_¬_conv" 7020 [tm])
end);
=TEX
=SML
fun €all_simple_¬_rule› (thm : THM) =(
	conv_rule all_simple_¬_conv thm
	handle complaint =>
	divert complaint "all_simple_¬_conv"
		"all_simple_¬_rule" 7020 [fn () => string_of_thm thm]
);
=TEX

\subsection{Concerning $\alpha$-conversion}
=SML
val €¡_conv› : TERM -> CONV = (
let	val ar = subst_rule [];
in
(fn (tm1 : TERM) =>
 fn (tm2 : TERM) =>
let	val new_template = mk_eq(tm2, tm1)
		handle complaint =>
		pass_on complaint "mk_eq" "¡_conv"
	val s2 = refl_conv tm2;
	val s3 = ar new_template s2;
in
	s3
end
handle complaint =>
list_divert complaint "¡_conv" [
	("subst_rule",7034,[fn () => string_of_term tm1,
		fn () => string_of_term tm2])]
)
end);
=TEX
=SML
val €simple_¡_conv› : string -> CONV = (
let	val ar = subst_rule [];
in
(fn (v : string) =>
 fn (tm:TERM) =>
let	val (x,b) = dest_simple_Ã tm
		handle complaint =>
		pass_on complaint "dest_simple_Ã" "simple_¡_conv";
	val vtm = mk_var(v, type_of x);
	val abs = mk_simple_Ã(vtm,subst[(vtm,x)]b);
	val new_template = mk_eq(tm, abs);
	val s2 = refl_conv tm;
	val s3 = ar new_template s2
		handle complaint =>
		divert complaint "subst_rule" "simple_¡_conv" 7035
		[fn () => string_of_term x,(fn () => v)];
in
	s3
end)
end);
=TEX
\subsection{Concerning ≥ (part II)}
We prove the local theorem:
=GFT
s8 Ù µ p ∑ ≥(≥ p) = p
=TEX
=SML
local
	val s1 = asm_rule ¨p : BOOLÆ;
	val s2 = ≥_≥_intro s1;
	val s3 = ¥_intro ¨p : BOOLÆ s2;
	val s4 = asm_rule ¨≥(≥ p)Æ;
	val s5 = ≥_≥_elim s4;
	val s6 = ¥_intro ¨≥(≥ p)Æ s5;
	val s7 = §_intro s6 s3;
	val s8 = simple_µ_intro ¨p : BOOLÆ s7;
in
val ≥_≥_conv : CONV = (fn (tm:TERM) =>
let	val p = dest_≥(dest_≥ tm);
	val mf_s1 = simple_µ_elim p s8;
in
	mf_s1
end
handle complaint =>
divert complaint "dest_≥" "≥_≥_conv" 7022 [fn () => string_of_term tm]
);
end;
=TEX
Local theorems:
=GFT
s22 Ù µ p ∑ ≥ (∂ x ∑ ≥ (p x)) § (µ x ∑ p x)

s27 Ù ≥ (µ x ∑ ≥ (p x)) § (∂ x ∑ p x)

s33 Ù µ p∑ ≥ $µ p § (∂ x∑ ≥ p x)

s38 Ù µ p∑ ≥ $∂ p § (µ x∑ ≥ p x)
=TEX
=SML
local
val s1 = asm_rule ¨(Ã x : 'a ∑ ≥(p x)) xÆ;
val s2 = simple_∂_intro ¨∂ x : 'a ∑ (Ã x ∑ ≥(p x)) xÆ s1;
val s3 = all_¥_intro s2;
val s4 = all_simple_¬_rule s3;
val s5 = asm_rule ¨≥(∂ x ∑ ≥ (p x))Æ;
val s6 = modus_tollens_rule s4 s5;
val s7 = ≥_≥_elim s6;
val s8 = simple_µ_intro ¨x : 'aÆ s7;
val s9 = all_¥_intro s8;

val s10 = asm_rule ¨µ x : 'a ∑ p xÆ;
val s11 = all_simple_µ_elim s10;
val s12 = asm_rule ¨≥(p (x : 'a))Æ;
val s13 = asm_rule ¨∂ x : 'a ∑ ≥(p x)Æ;
val s14 = ≥_elim ¨FÆ s11 s12;
val s15 = simple_∂_elim ¨x : 'aÆ s13 s14;
val s16 = ¥_intro ¨∂ x : 'a ∑ ≥(p x)Æ s15;
val s17 = simple_µ_elim ¨∂ x : 'a ∑ ≥(p x)Æ ≥_thm;
val s18 = eq_sym_rule s17;
val s19 = §_mp_rule s18 s16;
val s20 = all_¥_intro s19;
val s21 = §_intro s9 s20;
val s22 = all_µ_intro s21;

val s23 = simple_µ_elim ¨(Ã x : 'a ∑ ≥(p x))Æ s22;
val s24 = all_simple_¬_rule s23;
val s25 = ap_fun_rule ¨$≥Æ s24;
val s26 = conv_rule (TOP_MAP_C ≥_≥_conv) s25;
val s27 = eq_sym_rule s26;

val s28 = ap_fun_rule ¨$≥Æ s21;
val s29 = conv_rule (TOP_MAP_C ≥_≥_conv) s28;
val s30 = eq_sym_rule s29;
val s31 = simple_µ_elim ¨p:'a ≠ BOOLÆ (inst_type_rule[(BOOL,mk_vartype"'b")]eta_axiom);
val lxpx = fst(dest_eq(concl s31));
val s32 = conv_rule(ONCE_MAP_C (fn tm => if tm = lxpx
		then s31
		else fail "" 0 [])) s30;
val s33 = all_µ_intro s32; (* ≥_µ_thm *)

val s34 = ap_fun_rule ¨$≥Æ s27;
val s35 = conv_rule (TOP_MAP_C ≥_≥_conv) s34;
val s36 = eq_sym_rule s35;
val s37 = conv_rule(ONCE_MAP_C (fn tm => if tm = lxpx
		then s31
		else fail "" 0 [])) s36;
val s38 = all_µ_intro s37; (* ≥_∂_thm *)

=TEX
Now the main functions:
=SML
in
val €≥_µ_thm› = save_thm("≥_µ_thm",s33);
val €≥_∂_thm› = save_thm("≥_∂_thm",s38);

val €simple_≥_µ_conv› : CONV = (fn (tm:TERM) =>
let	val neg = (dest_≥ tm);
	val (v,b) = dest_simple_µ neg;
	val vstr = fst(dest_var v);
	val abs = snd(dest_app neg);
	val mf_s1 = inst_type_rule[(type_of v,mk_vartype "'a")] ≥_µ_thm;
	val mf_s2 = simple_µ_elim abs mf_s1;
	val mf_s3 = conv_rule(RAND_C(RAND_C
		(SIMPLE_Ã_C(RAND_C simple_¬_conv) THEN_C
		simple_¡_conv vstr))) mf_s2;
in
	mf_s3
end
handle complaint =>
list_divert complaint "simple_≥_µ_conv" [
	("dest_≥",7036,[fn () => string_of_term tm]),
	("dest_µ",7036,[fn () => string_of_term tm])]
);

val €simple_≥_∂_conv› : CONV = (fn (tm:TERM) =>
let	val neg = (dest_≥ tm);
	val (v,b) = dest_simple_∂ neg;
	val vstr = fst(dest_var v);
	val abs = snd(dest_app neg);
	val mf_s1 = inst_type_rule[(type_of v,mk_vartype "'a")] ≥_∂_thm;
	val mf_s2 = simple_µ_elim abs mf_s1;
	val mf_s3 = conv_rule(RAND_C(RAND_C
		(SIMPLE_Ã_C(RAND_C simple_¬_conv) THEN_C
		simple_¡_conv vstr))) mf_s2;
in
	mf_s3
end
handle complaint =>
list_divert complaint "simple_≥_∂_conv" [
	("dest_≥",7058,[fn () => string_of_term tm]),
	("dest_∂",7058,[fn () => string_of_term tm])]
);
end; (* of local val s1 = ... *)
=TEX
\subsection{Concerning ± and ¥}
=GFT
s Ù µ a b c ∑ ((a ± b) ¥ c) § (a ¥ b ¥ c)
s Ù µ a b c ∑ (a ¥ b ¥ c) § ((a ± b) ¥ c)
=TEX
=SML
local
	val s1 = asm_rule ¨a ± bÆ;
	val s2 = ±_left_elim s1;
	val s3 = ±_right_elim s1;
	val s4 = asm_rule ¨a : BOOLÆ;
	val s5 = asm_rule ¨b : BOOLÆ;
	val s6 = ±_intro s4 s5;
	val s7 = asm_rule ¨(a ± b) ¥ cÆ;
	val s8 = ¥_elim s7 s6;
	val s9 = ¥_intro ¨b : BOOLÆ s8;
	val s10 = ¥_intro ¨a : BOOLÆ s9;
	val s11 = ¥_intro ¨(a ± b) ¥ cÆ s10;

	val s12 = asm_rule ¨a ¥ b ¥ cÆ;
	val s13 = ¥_elim s12 s2;
	val s14 = ¥_elim s13 s3;
	val s15 = ¥_intro ¨a ± bÆ s14;
	val s16 = ¥_intro ¨a ¥ b ¥ cÆ s15;
	
	val s17 = §_intro s11 s16;
	val s18 = list_simple_µ_intro [¨a : BOOLÆ, ¨b : BOOLÆ, ¨c : BOOLÆ] s17;
	val s19 = eq_sym_rule s17;
	val s20 = list_simple_µ_intro [¨a : BOOLÆ, ¨b : BOOLÆ, ¨c : BOOLÆ] s19;
in
fun €¥_±_rule› (thm : THM) : THM = (
let val (a,(b,c)) = (Combinators.I ** dest_¥)(dest_¥ (concl thm));
	val mf_s1 = list_simple_µ_elim [a,b,c] s20;
	val mf_s2 = §_mp_rule mf_s1 thm;
in
	mf_s2
end
handle complaint =>
divert complaint "dest_¥" "¥_±_rule" 7008 [fn () => string_of_thm thm]
);

fun €±_¥_rule› (thm : THM) : THM = (
let val ((a,b),c) = (dest_± ** Combinators.I)(dest_¥ (concl thm));
	val mf_s1 = list_simple_µ_elim [a,b,c] s18;
	val mf_s2 = §_mp_rule mf_s1 thm;
in
	mf_s2
end
handle complaint =>
list_divert complaint "±_¥_rule" [
	("dest_±",7009,[fn () => string_of_thm thm]),
	("dest_¥",7009,[fn () => string_of_thm thm])]
);
end;
=TEX
\subsection{Concerning ∂$_1$}
=SML
local
	val s1 = ap_arg_rule ¨P : 'a ≠ BOOLÆ ∂â1_def;
	val s2 = all_simple_¬_rule s1;
	val s3 = simple_µ_intro ¨P : 'a ≠ BOOLÆ s2;
in
	val €∂â1_thm› = save_thm("∂â1_thm",s3)
end;
=TEX
=SML
fun simple_∂â1_intro (thm1 : THM) (thm2 : THM) : THM = (
let	val (x,rest) = dest_simple_µ (concl thm2);
	val (Px,(x',t)) = (Combinators.I ** dest_eq)(dest_¥ rest);
	val sideeffect = if x = x'
		then ()
		else fail "simple_∂â1_intro" 7066 [];
	val witness = case (term_match (concl thm1) Px) of
		([],[(w,_)]) => w
		| ([],[]) => t
		| _ => fail "simple_∂â1_intro" 7067 [];
	val abs = mk_simple_Ã(x,Px);
	val P_t = mk_app(abs, witness);
	val P_x = mk_app(abs, x);
	val s1 = simple_¬_conv P_t;
	val s2 = eq_sym_rule s1;
	val s3 = §_mp_rule s2 thm1;
	val s4 = simple_¬_conv P_x;
	val s5 = eq_sym_rule s4;
	val mgvs = gen_vars [BOOL, type_of x] (frees rest);
	val mgv = hd mgvs;
	val mgv1 = hd(tl mgvs);
	val s6 = all_simple_µ_elim thm2;
	val template = mk_¥(mgv,mk_eq(x,t));
	val s7 = subst_rule [(s5,mgv)] template s6;
	val s8 = simple_µ_intro x s7;
	val s9 = ±_intro s3 s8;
	val template2 = mk_simple_∂(mgv1,
		mk_±(mk_app(abs,mgv1),
		mk_simple_µ(x,
		mk_¥(
		P_x, mk_eq(x,mgv1)))));
	val s10 = simple_∂_intro template2 s9;
	val s11 = inst_type_rule[(type_of x,mk_vartype "'a")] ∂â1_thm;
	val s12 = simple_µ_elim abs s11;
	val s13 = eq_sym_rule s12;
	val s14 = §_mp_rule s13 s10;
	val s15 = conv_rule(RAND_C (simple_¡_conv (fst(dest_var x)))) s14;
in
	s15
end
handle complaint =>
list_divert complaint "simple_∂â1_intro" [
	("term_match",7067,[fn () => string_of_thm thm1, fn () => string_of_thm thm2]),
	("dest_simple_µ",7066,[fn () => string_of_thm thm2]),
	("dest_¥",7066,[fn () => string_of_thm thm2])
]
);
=TEX
=SML
fun €simple_∂â1_elim› (thm : THM) : THM = (
let	val (_,bdy) = dest_app (concl thm);
	val (x,_) = dest_simple_Ã bdy;
	val (xt,bt) = dest_≠_type(type_of bdy);
	val s1 = inst_type_rule [(xt,mk_vartype "'a")] ∂â1_thm;
	val s2 = simple_µ_elim bdy s1;
	val s3 = §_mp_rule s2 thm;
	val s4 = conv_rule (BINDER_C
		((RAND_C(BINDER_C(RATOR_C(RAND_C simple_¬_conv))))
		THEN_C
		(RATOR_C(RAND_C simple_¬_conv)))) s3;
	val s5 = conv_rule(RAND_C (simple_¡_conv (fst(dest_var x)))) s4;
in
	s5
end
handle complaint =>
list_divert complaint "simple_∂â1_elim" [
	("dest_app",7015,[fn () => string_of_thm thm]),
	("dest_simple_Ã",7015,[fn () => string_of_thm thm]),
	("dest_fun",7015,[fn () => string_of_thm thm]),
	("§_mp_rule",7015,[fn () => string_of_thm thm])]
);
=TEX
\section{END OF THE STRUCTURE}
=SML
end; (* of structure DerivedRules1 *)
open DerivedRules1; 
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN
Statistics:

open Sort;
fun comp_stats (s1,n1) (s2,n2) = (
	if n1 = n2
	then stringorder s1 s2
	else (n1 - n2)
);

sort comp_stats (get_stats ());


