=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Implementation for the Derived Rules of Inference}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Derived Rules of Inference}
\TPPref{DS/FMU/IED/IMP007}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{K.~Blackburn & WIN01\\D.J.~King & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
Primitive and built-in inference rules, and conversionals
all module tested to these implementations.
\item [Issue 1.2]
Added material up to $€$.
\item [Issue 1.3]
Added up to $Š\_trans\_rule$, corrected $»Œ¼$.
\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the derived rules of inference.
This includes user versions of the
primitive and built-in inference rules.
The design is in \cite{DS/FMU/IED/DTD007}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the 
This includes user versions of the
primitive and built-in inference rules.
A ``primitive'' inference rule is considered to be part of the logic,
whereas a ``built-in'' rule is one that, though it could be coded in terms 
of the primitive rules, will actually be part of the abstract data type $THM$, and thus taken as holding true without checking.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD007},
and also requires those files indicated as preceding it in the 
rel001 makefile.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}


\section{THE ABSTRACT DATA TYPE $THM$}
=SML
(* structure âDerivedInferenceRulesá : DerivedInferenceRules = struct *)
=TEX
\subsection{Utilities}
We will often wish to just pass on error messages,
just changing the source area of the message if it is from
particular function.
Thus:
=SML
fun âpass_oná (e : exn) (fromnm : string) (tonm : string) : 'a = (
let val efrom = area_of e
in
	if efrom = fromnm
	then reraise e tonm
	else reraise e efrom
end);
=TEX
The following two should be visible to the outside world:
=SML
val âconclá :  THM -> TERM = snd o dest_thm;
val âhypsá : THM -> TERM list = fst o dest_thm;
=TEX
As should the following:
=SML
val T = »T¼;
val F = »F¼;
=TEX
\subsection{Primitive and Built-in Rules}
This, and only this, part is done in the context
of an open kernel:
=SML
local
	open icl'Kernel;
in
=TEX
\subsubsection{Primitive Rules}
=SML
fun âsubst_ruleá (thm_var_lst : (THM * TERM) list) :
	TERM -> THM -> THM = (
	let val s1 = icl'subst_rule thm_var_lst
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule"
	in
	(fn (tm : TERM) =>
	let val s2 = s1 tm
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule"
	in
	(fn (thm : THM) =>
	(prof "subst_rule";
	s2 thm
		handle complaint => 
		pass_on complaint "icl'subst_rule" "subst_rule")
	)
	end)
	end
);
=TEX
=SML
fun âsimple_abs_ruleá (tm : TERM) (thm : THM) : THM = (
	prof "simple_abs_rule";
	icl'simple_abs_rule tm thm
		handle complaint => 
		pass_on complaint "icl'simple_abs_rule" "simple_abs_rule"
);
=SML
fun âinst_type_ruleá (ty_list : (TYPE * TYPE) list) (thm : THM) : THM = (
	prof "inst_type_rule";
	icl'inst_type_rule ty_list thm
		handle complaint => 
		pass_on complaint "icl'inst_type_rule" "inst_type_rule"
);
=TEX
=SML
fun âŠ_introá (tm : TERM) (thm : THM) : THM = (
	prof "Š_intro";
	icl'Š_intro tm thm
		handle complaint => 
		pass_on complaint "icl'Š_intro" "Š_intro"
);
=TEX
=SML
fun âŠ_elimá (thm1 : THM) (thm2 : THM) : THM = (
	prof "Š_elim";
	icl'Š_elim thm1 thm2
		handle complaint => 
		pass_on complaint "icl'Š_elim" "Š_elim"
);
=TEX
=SML
fun âasm_ruleá (tm : TERM) : THM = (
	prof "asm_rule";
	icl'asm_rule tm
		handle complaint => 
		pass_on complaint "icl'asm_rule" "asm_rule"
);
=TEX
=SML
val ârefl_convá : CONV = (
	fn (tm : TERM) =>
	(prof "refl_conv";
	icl'refl_conv tm
		handle complaint => 
		pass_on complaint "icl'refl_conv" "refl_conv")
);
=TEX
=SML
val âsimple_%beta%_convá : CONV = (
	fn (tm : TERM) =>
	(prof "simple_%beta%_conv";
	icl'simple_%beta%_conv tm
		handle complaint => 
		pass_on complaint "icl'simple_%beta%_conv" "simple_%beta%_conv")
);
=TEX
\subsubsection{Definitional Schemata}
=SML
local
	val N0 = »0¼;
in
val âsuc_convá : CONV = (
	fn (tm : TERM) =>
	(prof "suc_conv";
	if tm = N0
	then fail "suc_conv" 7100 []
	else icl'suc_conv tm
		handle complaint => 
		pass_on complaint "icl'suc_conv" "suc_conv")
);
end;
=TEX
=SML
val âstring_convá : CONV = (
	fn (tm : TERM) =>
	(prof "string_conv";
	icl'string_conv tm
		handle complaint => 
		pass_on complaint "icl'string_conv" "string_conv")
);
=TEX
=SML
val âchar_convá : CONV = (
	fn (tm : TERM) =>
	(prof "char_conv";
	icl'char_conv tm
		handle complaint => 
		pass_on complaint "icl'char_conv" "char_conv")
);
=TEX
\subsubsection{Built-In Rules of Inference}
=SML
fun âeq_sym_ruleá (thm : THM) : THM = (
	prof "eq_sym_rule";
	icl'eq_sym_rule thm
		handle complaint => 
		pass_on complaint "icl'eq_sym_rule" "eq_sym_rule"
);
=TEX
=SML
fun âsimple_ƒ_elimá (tm : TERM) (thm : THM) : THM = (
	prof "simple_ƒ_elim";
	icl'simple_ƒ_elim tm thm
		handle complaint => 
		pass_on complaint "icl'simple_ƒ_elim" "simple_ƒ_elim"
);
=TEX
=SML
fun âeq_trans_ruleá (thm1 : THM) (thm2 : THM) : THM = (
	prof "eq_trans_rule";
	icl'eq_trans_rule thm1 thm2
		handle complaint => 
		pass_on complaint "icl'eq_trans_rule" "eq_trans_rule"
);
=TEX
=SML
fun âmk_comb_ruleá (thm1 : THM) (thm2 : THM) : THM = (
	prof "mk_comb_rule";
	icl'mk_comb_rule thm1 thm2
		handle complaint => 
		pass_on complaint "icl'mk_comb_rule" "mk_comb_rule"
);
=TEX
=SML
fun â‚_mp_ruleá (thm1 : THM) (thm2 : THM) : THM = (
	prof "‚_mp_rule";
	icl'‚_mp_rule thm1 thm2
		handle complaint => 
		pass_on complaint "icl'‚_mp_rule" "‚_mp_rule"
);
=TEX
=SML
fun âsimple_ƒ_introá (tm : TERM) (thm : THM) : THM = (
	prof "simple_ƒ_intro";
	icl'simple_ƒ_intro tm thm
		handle complaint => 
		pass_on complaint "icl'simple_ƒ_intro" "simple_ƒ_intro"
);
=TEX
=SML
fun âinst_term_ruleá (tml : (TERM * TERM) list) (thm : THM) : THM = (
	prof "inst_term_rule";
	icl'inst_term_rule tml thm
		handle complaint => 
		pass_on complaint "icl'inst_term_rule" "inst_term_rule"
);
=TEX
=SML
val âdiv2_convá : CONV = (
	fn (tm : TERM) =>
	(prof "div2_conv";
	icl'div2_conv tm
		handle complaint => 
		pass_on complaint "icl'div2_conv" "div2_conv")
);
=TEX
=SML
val âmod2_convá : CONV = (
	fn (tm : TERM) =>
	(prof "mod2_conv";
	icl'mod2_conv tm
		handle complaint => 
		pass_on complaint "icl'mod2_conv" "mod2_conv")
);
=TEX
=SML
end; (* local open icl'Kernel *)
=TEX
\subsection{Inference Rules For Conversions}
Two "proper" failures come from $mk\-\_comb\-\_rule$,
each with their own failure message from
$ap\-\_fun\-\_rule$.
We need to do some calculation to determine which error
is given: but we only do this if we get a failure.
=SML
fun âap_fun_ruleá (tm : TERM) (thm : THM) : THM = ((
let
	val thm1 = refl_conv tm;
in
	(prof "ap_fun_rule";
	mk_comb_rule thm1 thm)
end)
handle complaint =>
if is_eq(concl thm)
then divert complaint "mk_comb_rule" "ap_fun_rule" 7024 []
else divert complaint "mk_comb_rule" "ap_fun_rule" 7023 []
);
=TEX
Two "proper" failures come from $mk\-\_comb\-\_rule$,
each with their own failure message from
$ap\-\_arg\-\_rule$.
We need to do some calculation to determine which error
is given: but we only do this if we get a failure.
=SML
fun âap_arg_ruleá (tm : TERM) (thm : THM) : THM = (
let
	val thm1 = refl_conv tm;
in
	(prof "ap_arg_rule";
	mk_comb_rule thm thm1)
end
handle complaint =>
if is_eq(concl thm)
then divert complaint "mk_comb_rule" "ap_arg_rule" 7025 []
else divert complaint "mk_comb_rule" "ap_arg_rule" 7023 []
);
=TEX

\subsection{Conversions}
\subsubsection{Building Blocks}
=SML
val âfail_convá : CONV = (fn tm => fail "fail_conv" 7061 []);

fun âfail_with_convá (str : string) : CONV = (
	fn tm => fail "fail_with_conv" 7075 [fn () => str]
);
=TEX
\subsubsection{Conversionals}
=SML
fun (cnv1 : CONV) âTHEN_Cá (cnv2 : CONV) = (fn (tm: TERM) =>
let
	val thm1 = cnv1 tm;
	val rhs_thm1 = snd(dest_eq (concl thm1));
	val thm2 = cnv2 rhs_thm1;
in
	eq_trans_rule thm1 thm2
end
handle complaint =>
list_divert complaint "THEN_C" [
	("dest_eq",7101,[]),
	("eq_trans_rule",7102,[])]);
=TEX
=SML
fun (cnv1 : CONV) âFURTHER_Cá (cnv2 : CONV) = (fn (tm: TERM) =>
let
	val thm1 = cnv1 tm
in
	(let
		val rhs_thm1 = snd(dest_eq (concl thm1));
		val thm2 = cnv2 rhs_thm1;
	in
		eq_trans_rule thm1 thm2
	end
	handle (Fail _) => thm1)
end);
=TEX
=SML
fun (cnv1 : CONV) âORELSE_Cá (cnv2 : CONV) = (fn (tm: TERM) =>
	cnv1 tm
handle (Fail _) =>
	cnv2 tm
);
=TEX
=SML
fun (cnv1 : CONV) âEITHER_Cá (cnv2 : CONV) : CONV = (fn (tm: TERM) =>
(let
	val thm1 = cnv1 tm
in
	(let
		val rhs_thm1 = snd(dest_eq (concl thm1));
		val thm2 = cnv2 rhs_thm1;
	in
		eq_trans_rule thm1 thm2
	end
	handle (Fail _) => thm1)
end
handle (Fail _) => cnv2 tm)
);
=TEX
=SML
fun âTRY_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
	cnv tm
	handle (Fail _) =>
	refl_conv tm
);
=TEX
=SML
fun âREPEAT1_Cá (cnv : CONV) = (fn (tm : TERM) =>
	(cnv FURTHER_C (REPEAT1_C cnv)) tm
);
=TEX
Notice that the following is carefully coded to avoid
redundant $refl\_conv$'s.
There is a minor partial evaluation effect with 
only the conversion argument.
=SML
fun âREPEAT_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
	TRY_C (REPEAT1_C cnv) tm
);
=TEX
Partially evaluated given only a list.
=SML
fun âLIST_THEN_Cá ([cnv] : CONV list) : CONV = cnv
| LIST_THEN_C (cnv :: crest) = cnv THEN_C (LIST_THEN_C crest)
| LIST_THEN_C [] = fail "LIST_THEN_C" 7103 [];
=TEX
Partially evaluated given only a list.
=SML
fun âLIST_ORELSE_Cá ([cnv] : CONV list) : CONV = cnv
| LIST_ORELSE_C (cnv :: crest) = cnv ORELSE_C (LIST_ORELSE_C crest)
| LIST_ORELSE_C [] = fail "LIST_ORELSE_C" 7103 [];
=TEX
=SML
fun âCHANGED_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let val thm = cnv tm;
	val rhs_thm = (snd o dest_eq o concl) thm;
in
	if rhs_thm <> tm
	then thm
	else fail "CHANGED_C" 7032 []
end
handle complaint =>
divert complaint "dest_eq" "CHANGED_C" 7104[]);
=TEX
\subsubsection{Term Traversal Algorithms for Conversions}
=SML
fun  âRAND_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let
	val (f,x) = dest_comb tm;
	val thm1 = cnv x;
in
	ap_fun_rule f thm1
end
handle complaint =>
list_divert complaint "RAND_C" [
	("dest_comb",7045,[]),
	("ap_fun_rule",7104,[])]
);
=TEX
=SML
fun  âRATOR_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let
	val (f,x) = dest_comb tm;
	val thm1 = cnv f;
in
	ap_arg_rule x thm1
end
handle complaint =>
list_divert complaint "RATOR_C" [
	("dest_comb",7045,[]),
	("ap_arg_rule",7104,[])]
);
=TEX
=SML
fun  âABS_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let
	val (x,b) = simple_dest_abs tm;
	val thm1 = cnv b;
in
	simple_abs_rule x thm1
end
handle complaint =>
list_divert complaint "ABS_C" [
	("simple_dest_abs",7030,[]),
	("simple_abs_rule",7104,[])]
);
=TEX
We do the following in full to be able to determine the
correct error message, if necessary.
It could just be $RAND\_C\ o\ ABS\_C$.
=SML
fun  âBINDER_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let
	val (binder,abs) = dest_comb tm;
	val (x,b) = simple_dest_abs abs;
	val thm1 = cnv b;
in
	ap_fun_rule binder (simple_abs_rule x thm1)
end
handle complaint =>
list_divert complaint "BINDER_C" [
	("simple_dest_abs",7059,[]),
	("dest_comb",7059,[]),
	("simple_abs_rule",7104,[]),
	("ap_fun_rule",7104,[])]
);
=TEX
We could build the following using the above building blocks,
but prefer to keep it fast.
=SML
fun âSUB_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let
	fun aux (Var _) = refl_conv tm
	| aux (Const _) = refl_conv tm
	| aux (Comb (f,x)) = (
		((let val thm1 = cnv f
		in
		 (let val thm2 = cnv x
		 in
			mk_comb_rule thm1 thm2
		 end
		 handle (Fail _) =>
		 ap_arg_rule x thm1)
		end)
		handle (Fail _) =>
		(let val thm2 = cnv x
		in
			ap_fun_rule f thm2
		end))
		handle (Fail _) => refl_conv tm
	) | aux (Abs (x,b)) = (
		let val thm1 = cnv b
		in
			simple_abs_rule x thm1
		end
		handle (Fail _) =>
		refl_conv tm
	);
in
	aux(simple_dest_term tm)
end
handle complaint =>
list_divert complaint "SUB_C" [
	("mk_comb_rule",7104,[]),
	("simple_abs_rule",7104,[])]
);
=TEX
There is a mild partial evaluation with only a conversion.
=SML
fun âSUB1_Cá (cnv : CONV) : CONV = (fn (tm : TERM) => 
let
	fun aux (Var _) = fail "SUB1_C"  7105 []
	| aux (Const _) = fail "SUB1_C"  7105 []
	| aux (Comb (f,x)) = (
		let val thm1 = cnv f
		in
		 (let val thm2 = (cnv x
			handle (Fail _) => refl_conv x)
		 in
			mk_comb_rule thm1 thm2
		 end)
		end
		handle (Fail _) =>
		(let val thm2 = cnv x
		in
			ap_fun_rule f thm2
		end)
	) | aux (Abs (x,b)) = (
		let val thm1 = cnv b
		in
			simple_abs_rule x thm1
		end
	);
in
	aux(simple_dest_term tm)
end
handle complaint =>
list_divert complaint "SUB1_C" [
	("ap_fun_rule",7104,[]),
	("simple_abs_rule",7104,[])]
);
=TEX
N.B. the $fn\ (tm: TERM) \ldots tm$ might look $\eta$-convertible away, but actually prevents an infinite loop.
=SML
fun âONCE_TRAVERSE_Cá (cnv : CONV) : CONV = (fn (tm: TERM) =>
	(cnv ORELSE_C (SUB1_C (ONCE_TRAVERSE_C cnv))) tm
);
=TEX
=SML
fun âTRAVERSE_Cá (cnv : CONV) : CONV = (fn tm =>
	((SUB1_C (TRAVERSE_C cnv)) EITHER_C (REPEAT1_C cnv)) tm
);
=TEX
=SML
fun âREPEAT_TRAVERSE_Cá (cnv : CONV) : CONV = (fn tm =>
	((SUB1_C (REPEAT_TRAVERSE_C cnv))
	EITHER_C (cnv FURTHER_C (REPEAT_TRAVERSE_C cnv))) tm
);
=TEX
=SML
fun âTOP_TRAVERSE_Cá (cnv : CONV) : CONV = (fn (tm:TERM) =>
	((REPEAT1_C cnv) EITHER_C (SUB1_C(TOP_TRAVERSE_C cnv)))tm
);
=TEX
\subsubsection{Conversions as Rules}
=SML
fun âconv_ruleá (cnv : CONV) (thm : THM) : THM = (
let
	val thm1 = cnv(concl thm)
in
	‚_mp_rule thm1 thm
end
handle complaint =>
divert complaint "‚_mp_rule" "conv_rule" 7104 []);
=TEX 
\section{DERIVED INFERENCE RULES}
We will be saving theorems as we go along, so we need to ensure we are saving them into theory misc:
=SML
open_theory "misc";
=TEX
An alias:
=SML
val âŠ_mp_ruleá = Š_elim;
=TEX
Something we will want locally:
=RULE
simple_list_ƒ_elim
[»t1¼, ..., »tn¼]
É
ö … ƒ x1 ... xn Ž t[x1, ..., xn]
É
t[t1, ..., tn]
=TEX
where the $x_i$ are simple variables.
=SML
val âsimple_list_ƒ_elimá = revfold (uncurry simple_ƒ_elim);
=TEX
The following is out of place, but useful if declared immediately:
=SML
fun âundisch_ruleá (thm : THM) : THM = (
let
	val (a,b) = dest_Š(concl thm);
	val s1 = asm_rule a;
	val s2 = Š_elim thm s1
in
	(prof "undisch_rule";
	s2)
end
handle complaint =>
divert complaint "dest_Š" "undisch_rule" 7011 []
);
=TEX
\subsection{Concerning $T$}
Proof of $T$ (as 12.3.9)
=SML
local
	val s1 = t_def;
	val s2 = eq_sym_rule s1;
	val s3 = refl_conv » x : BOOL Ž x¼;
	val s4 = ‚_mp_rule s2 s3;
in
	val t_thm = save_thm("ât_thmá",s4)
end;
=TEX
We could work by a local theorem:
ó
… ƒ x Ž x ‚ (x ‚ T)
æ
but choose to work by the more primitive route of 12.3.12
=SML
fun â‚_t_introá (thm : THM) : THM = (
let
	val t = concl thm;
	val s3 = simple_list_ƒ_elim [t, T] Š_antisym_axiom;
	val s5 = Š_intro t t_thm;
	val s5 = Š_elim s3 s5;
	val s8 = Š_intro T thm;
	val s9 = Š_elim s5 s8;
in
	(prof "‚_t_intro";
	s9)
end);
=TEX
In the following we could chose to try eliminating
all outermost $\ldots ‚ T$ and $T ‚ \ldots$.
D.I.Y. form:
=SML
fun â‚_t_elimá (thm : THM) : THM = (
let
	val s1 = eq_sym_rule thm;
	val s2 = ‚_mp_rule s1 t_thm;
in
	(prof "‚_t_elim";
	s2)
end
handle complaint =>
list_divert complaint "‚_t_elim" [
	("eq_sym_rule",7106,[]),
	("‚_mp_rule",7106,[])]);
=TEX
D.I.Y. form:
=SML
fun âcontr_ruleá (t : TERM) (thm : THM) : THM = (
let
	val s1 = ‚_mp_rule f_def thm;
	val s2 = simple_ƒ_elim t s1;
in
	(prof "contr_rule";
	s2)
end
handle complaint =>
list_divert complaint "contr_rule" [
	("‚_mp_rule", 7001, []),
	("simple_ƒ_elim",7002,[])]
);
=TEX
The following is out of sequence, but necessary at this point:
we first prove theorem:
ó
_thm = … ƒ t1 t2 Ž (t1  t2) = (ƒ b Ž (t1 Š b) Š (t2 Š b) Š b)
æ
=SML
local
	val s1 = ap_arg_rule »t1 : BOOL¼ _def;
	val s2 = ap_arg_rule »t2 : BOOL¼ s1;
	val s3 = conv_rule (TRAVERSE_C simple_%beta%_conv) s2;
	val s4 = simple_ƒ_intro »t2 : BOOL¼ s3;
	val s5 = simple_ƒ_intro »t1 : BOOL¼ s4;
in
	val _thm = save_thm("â_thmá",s5)
end;
=TEX
Then the out of place rule
(roughly as \cite{DS/FMU/IED/SML009} 5.14):
=SML
fun â_elimá (a__b  : THM) (a_thm : THM) (b_thm : THM) = (
let
	val (a,b) = dest_(concl a__b);
	val s1 = Š_intro a a_thm;
	val s2 = Š_intro b b_thm;
	val s3 = simple_list_ƒ_elim [a, b] _thm;
	val s4 = ‚_mp_rule s3 a__b;
	val s5 = simple_ƒ_elim (concl a_thm) s4;
	val s6 = Š_elim s5 s1;
	val s7 = Š_elim s6 s2;
in
	(prof "_elim";
	s7)
end
handle complaint =>
list_divert complaint "_elim" [
	("dest_",7010,[]),
	("Š_elim",7083,[])]
);
=TEX
Then another out of place theorem:
ó
Œ_thm = … ƒ t Ž (Œ t) = (t Š F)
æ
=SML
local
	val s1 = ap_arg_rule »t : BOOL¼ Œ_def;
	val s2 = conv_rule (TRAVERSE_C simple_%beta%_conv) s1;
	val s3 = simple_ƒ_intro »t : BOOL¼ s2;
in
	val Œ_thm = save_thm("âŒ_thmá", s3)
end;
=TEX
Roughly as 5.17 of \cite{DS/FMU/IED/SML009}:
First prove the local theorem:
ó
ƒ t Ž (Œ t Š F) Š t
æ
=SML
local
	val s1 = asm_rule »(t Š F) Š F¼;
	val s2 = asm_rule »t ‚ F¼;
	val s4 = subst_rule[(s2,»t : BOOL¼)] (concl s1) s1;
	val s5 = asm_rule F;
	val s6 = Š_intro F s5;
	val s7 = Š_elim s4 s6;
	val s8 = eq_sym_rule s2;
	val s9 = ‚_mp_rule s8 s7;
	val s10 = asm_rule »t = T¼;
	val s11 = ‚_t_elim s10;
	val s13 = simple_ƒ_elim »t : BOOL¼ bool_cases_axiom;
	val s14 = _elim s13 s11 s9;
	val s15 = Š_intro »(t Š F) Š F¼ s14;
	val s16 = simple_ƒ_elim »t : BOOL¼ Œ_thm;
	val s17 = eq_sym_rule s16;
	val s18 = conv_rule (ONCE_TRAVERSE_C (fn x =>
		if x = »t Š F¼ then s17 else (fail_conv x))) s15;
	val s19 = simple_ƒ_intro »t : BOOL¼ s18;
in
=TEX
now the main function:
=SML
fun âc_contr_ruleá (t : TERM) (thm : THM) : THM = (
let
	val mf_s1 = simple_ƒ_elim t s19;
	val Œ_t = mk_Œ t;
	val side_effect = if not (present (uncurry aconv) Œ_t (hyps thm))
		then fail "c_contr_rule" 7003 []
		else();

	val mf_s2 = Š_intro Œ_t thm;
	val mf_s3 = Š_elim mf_s1 mf_s2
in
	(prof "c_contr_rule";
	mf_s3)
end
handle complaint =>
divert complaint "simple_ƒ_elim" "c_contr_rule" 7002 []
);
end;
=TEX
\subsection{Concerning Negation}
This is entirely new:
we first prove the local theorem:
ó
… ƒ a Ž (Œ a) ‚ (a Š ƒ b Ž b)
æ
=SML
local
	val s1 = conv_rule(ONCE_TRAVERSE_C(fn x =>
		if x = F then f_def else fail_conv x))
		Œ_thm;
in
fun âŒ_elimá (tm : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let
	val s2 = simple_ƒ_elim (concl thm1) s1;
	val s3 = ‚_mp_rule s2 thm2;
	val s4 = Š_elim s3 thm1;
	val s5 = simple_ƒ_elim tm s4
in
	(prof "Œ_elim";
	s5)
end
handle complaint =>
list_divert complaint "Œ_elim" [
	("‚_mp_elim",7060,[]),
	("simple_ƒ_elim",7002,[])
	]
);
end;
=TEX
	
This is entirely new:
we first prove:
ó
s13 = … ƒ a b Ž (a Š b) Š (a Š Œb) Š Œa
æ
=SML
local
	val s1 = asm_rule »a Š b¼;
	val s2 = undisch_rule s1;
	val s3 = asm_rule »a Š Œ b¼;
	val s4 = undisch_rule s3;
	val s5 = Œ_elim F s2 s4;
	val s6 = Š_intro »a : BOOL¼ s5;
	val s7 = simple_ƒ_elim »a : BOOL¼ Œ_thm;
	val s8 = eq_sym_rule s7;
	val s9 = conv_rule (ONCE_TRAVERSE_C (fn x =>
		if x = »a Š F¼ then s8 else (fail_conv x))) s6;
	val s10 = Š_intro »a Š Œ b¼ s9;
	val s11 = Š_intro »a Š b¼ s10;
	val s12 = simple_ƒ_intro »b : BOOL¼ s11;
	val s13 = simple_ƒ_intro »a : BOOL¼ s12;
in
=TEX
Main function:
=SML
fun âŒ_introá (t : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let
	val mf_s1 = Š_intro t thm1;
	val mf_s2 = Š_intro t thm2;
	val mf_s3 = simple_list_ƒ_elim [t, concl thm1] s13;
	val mf_s4 = Š_elim mf_s3 mf_s1;
	val mf_s5 = Š_elim mf_s4 mf_s2
in
	(prof "Œ_intro";
	mf_s5)
end
handle complaint =>
list_divert complaint "Œ_intro" [
	("Š_elim", 7004, []),
	("simple_ƒ_elim", 7002, [])]
);
end;
=TEX
Prove the following (out of sequence)
ó
f_thm = … Œ F
æ
=SML
local
	val s1 = asm_rule F;
	val s2 = Š_intro F s1;
	val s3 = simple_ƒ_elim F Œ_thm;
	val s4 = eq_sym_rule s3;
	val s5 = ‚_mp_rule s4 s2;
in
	val f_thm = save_thm("f_thm",s5)
end;
=TEX
Prove the following (out of sequence)
ó
Œ_t_thm = … Œ T ‚ F
æ
=SML
local
	val s1 = simple_ƒ_elim »Œ T¼ bool_cases_axiom;
	val s2 = asm_rule »(Œ T) ‚ F¼;
	val s3 = asm_rule »Œ T ‚ T¼;
	val s4 = ‚_t_elim s3;
	val s5 = Œ_elim  »Œ T ‚ F¼ t_thm s4;
	val s6 = _elim s1  s5 s2;
in
	val Œ_t_thm = save_thm("âŒ_t_thmá",s6)
end;
=TEX
We prove the local theorems:
ó
s14 = … Œ(Œ t) ‚ t
s16 = … t ‚ Œ(Œ t)
æ
=SML
local
	val s1 = ‚_t_intro f_thm;
	val s2 = ap_fun_rule »$Œ¼ s1;
	val s3 = eq_trans_rule s2 Œ_t_thm;
	val s4 = ap_fun_rule »$Œ¼ Œ_t_thm;
	val s5 = eq_trans_rule s4 s1;
	val s6 = asm_rule »t ‚ T¼;
	val s7 = eq_sym_rule s6;
	val s8 = subst_rule [(s7,»x : BOOL¼)] »Œ(Œ x) ‚ x¼ s5;
	val s9 = asm_rule »t ‚ F¼;
	val s10 = eq_sym_rule s9;
	val s11 = subst_rule [(s10,»x : BOOL¼)] »Œ(Œ x) ‚ x¼ s3;
	val s12 = simple_ƒ_elim »t : BOOL¼ bool_cases_axiom;
	val s13 = _elim s12 s8 s11;
	val s14 = simple_ƒ_intro »t : BOOL¼ s13;
	val s15 = eq_sym_rule s13;
	val s16 = simple_ƒ_intro »t : BOOL¼ s15;
in
=TEX
Main functions:
=SML
fun âŒ_Œ_introá (thm : THM) : THM = (
let
	val mf_s1 = simple_ƒ_elim (concl thm) s16;
	val mf_s2 = ‚_mp_rule mf_s1 thm
in
	(prof "Œ_Œ_intro";
	mf_s2)
end);

fun âŒ_Œ_elimá (thm : THM) : THM = (
let
	val bdy = dest_Œ(dest_Œ(concl thm));
	val mf_s1 = simple_ƒ_elim bdy s14;
	val mf_s2 = ‚_mp_rule mf_s1 thm
in
	(prof "Œ_Œ_elim";
	mf_s2)
end
handle complaint =>
divert complaint "dest_Œ" "Œ_Œ_elim" 7006 []
);
end; (* local *)
=TEX
\subsection{Concerning €}
ó
€_thm = … ƒ t1 t2 Ž (t1 € t2) = (ƒ b Ž (t1 Š t2 Š b) Š b)
æ
=SML
local
	val s1 = ap_arg_rule »t1 : BOOL¼ €_def;
	val s2 = ap_arg_rule »t2 : BOOL¼ s1;
	val s3 = conv_rule (TRAVERSE_C simple_%beta%_conv) s2;
	val s4 = simple_ƒ_intro »t2 : BOOL¼ s3;
	val s5 = simple_ƒ_intro »t1 : BOOL¼ s4;
in
	val €_thm = save_thm("â€_thmá",s5)
end;
=TEX
Following \cite{DS/FMU/IED/SML009} 5.10:
We prove the local theorem:
ó
s14 = ƒ t1 t2 Ž t1 Š t2 Š (t1 € t2)
æ
=SML
local
	val s1 = asm_rule »t1 Š t2 Š b¼;
	val s3 = undisch_rule s1;
	val s5 = undisch_rule s3;
	val s6 = Š_intro »t1 Š t2 Š b¼ s5;
	val s7 = simple_ƒ_intro »b : BOOL¼ s6;
	val s8 = simple_list_ƒ_elim [»t1 : BOOL¼, »t2 : BOOL¼] €_thm;
	val s9 = eq_sym_rule s8;
	val s10 = ‚_mp_rule s9 s7;
	val s11 = Š_intro »t2 : BOOL¼ s10;
	val s12 = Š_intro »t1 : BOOL¼ s11;
	val s13 = simple_ƒ_intro »t2 : BOOL¼ s12;
	val s14 = simple_ƒ_intro »t1 : BOOL¼ s13;
in
fun â€_introá (thm1 : THM) (thm2 : THM) : THM = (
let
	val mf_s1 = simple_list_ƒ_elim[concl thm1, concl thm2] s14;
	val mf_s2 = Š_elim mf_s1 thm1;
	val mf_s3 = Š_elim mf_s2 thm2;
in
	(prof "€_intro";
	mf_s3)
end);
end;
=TEX
We prove the local theorem:
ó
s11 = ƒ t1 t2 Ž (t1 € t2) Š t1
æ
=SML
local 
	val s1 = simple_list_ƒ_elim [»t1 : BOOL¼, »t2 : BOOL¼] €_thm;
	val s2 = asm_rule »t1 € t2¼;
	val s3 = ‚_mp_rule s1 s2;
	val s4 = simple_ƒ_elim »t1 : BOOL¼ s3;
	val s5 = asm_rule »t1 : BOOL¼;
	val s6 = Š_intro »t2 : BOOL¼ s5;
	val s7 = Š_intro »t1 : BOOL¼ s6;
	val s8 = Š_elim s4 s7;
	val s9 = Š_intro »t1 € t2¼ s8;
	val s10 = simple_ƒ_intro »t2 : BOOL¼ s9;
	val s11 = simple_ƒ_intro »t1 : BOOL¼ s10;
in
fun â€_left_elimá (thm :THM) : THM = (
let
	val (t1,t2) = dest_€(concl thm);
	val mf_s1 = simple_list_ƒ_elim [t1, t2] s11;
	val mf_s2 = Š_elim mf_s1 thm;
in
	(prof "€_left_elim";
	mf_s2)
end
handle complaint =>
divert complaint "dest_€" "€_left_elim" 7007 []
);
end;
=TEX
We prove the local theorem:
ó
s11 = ƒ t1 t2 Ž (t1 € t2) Š t2
æ
=SML
local 
	val s1 = simple_list_ƒ_elim [»t1 : BOOL¼, »t2 : BOOL¼] €_thm;
	val s2 = asm_rule »t1 € t2¼;
	val s3 = ‚_mp_rule s1 s2;
	val s4 = simple_ƒ_elim »t2 : BOOL¼ s3;
	val s5 = asm_rule »t2 : BOOL¼;
	val s6 = Š_intro »t2 : BOOL¼ s5;
	val s7 = Š_intro »t1 : BOOL¼ s6;
	val s8 = Š_elim s4 s7;
	val s9 = Š_intro »t1 € t2¼ s8;
	val s10 = simple_ƒ_intro »t2 : BOOL¼ s9;
	val s11 = simple_ƒ_intro »t1 : BOOL¼ s10;
in
fun â€_right_elimá (thm :THM) : THM = (
let
	val (t1,t2) = dest_€(concl thm);
	val mf_s1 = simple_list_ƒ_elim [t1, t2] s11;
	val mf_s2 = Š_elim mf_s1 thm;
in
	(prof "€_right_elim";
	mf_s2)
end
handle complaint =>
divert complaint "dest_€" "€_right_elim" 7007 []
);
end;
=TEX
=SML
fun âlist_€_introá ([] : THM list) : THM = (
	fail "list_€_intro" 0000 []
) | list_€_intro thm_lst = (
let
	fun aux [thm] = thm
	| aux (thm :: rest) = €_intro thm (aux rest)
	| aux _ = error "list_€_intro" 0000 []
in
	(prof "list_€_intro";
	aux thm_lst)
end);

=TEX
=SML
fun âstrip_€_ruleá (thm : THM) : THM list = (
let
	fun aux thm1 = (
	let	val s1 = €_left_elim thm1;
		val s2 = €_right_elim thm1;
	in
		aux s1 @ aux s2
	end
	handle (Fail _) => [thm1]
	);
in
	(prof "strip_€_rule";
	aux thm)
end);
=TEX
Leave $€\_Š\_rule$ and $Š\_€\_rule$ until
later as of minor import, and tautology proving makes them simple.
\subsection{Concerning }
As \cite{DS/FMU/IED/SML009} 5.13.
We prove the local theorem:
ó
s12 … ƒ t1 t2 Ž t1 Š (t1  t2)
æ
=SML
local
	val s1 = asm_rule »t1 Š b¼;
	val s3 = undisch_rule s1;
	val s4 = Š_intro »t2 Š b¼ s3;
	val s5 = Š_intro »t1 Š b¼ s4;
	val s6 = simple_ƒ_intro »b :BOOL¼ s5;
	val s7 = simple_list_ƒ_elim [»t1 : BOOL¼,»t2 : BOOL¼] _thm;
	val s8 = eq_sym_rule s7;
	val s9 =  ‚_mp_rule s8 s6;
	val s10 = Š_intro »t1 : BOOL¼ s9;
	val s11 = simple_ƒ_intro »t2 : BOOL¼ s10;
	val s12 = simple_ƒ_intro »t1 : BOOL¼ s11;
in
fun â_right_introá (tm : TERM) (thm : THM) : THM = (
let
	val mf_s1 = simple_list_ƒ_elim [concl thm, tm] s12 ;
	val mf_s2 = Š_elim mf_s1 thm
in
	(prof "_right_intro";
	mf_s2)
end
handle complaint =>
divert complaint "simple_list_ƒ_elim" "_right_intro" 7002 []
);
end;
=TEX
We prove the local theorem:
ó
s12 … ƒ t1 t2 Ž t2 Š (t1  t2)
æ
=SML
local
	val s1 = asm_rule »t2 Š b¼;
	val s3 = undisch_rule s1;
	val s4 = Š_intro »t2 Š b¼ s3;
	val s5 = Š_intro »t1 Š b¼ s4;
	val s6 = simple_ƒ_intro »b :BOOL¼ s5;
	val s7 = simple_list_ƒ_elim [»t1 : BOOL¼,»t2 : BOOL¼] _thm;
	val s8 = eq_sym_rule s7;
	val s9 =  ‚_mp_rule s8 s6;
	val s10 = Š_intro »t2 : BOOL¼ s9;
	val s11 = simple_ƒ_intro »t2 : BOOL¼ s10;
	val s12 = simple_ƒ_intro »t1 : BOOL¼ s11;
in
fun â_left_introá (tm : TERM) (thm : THM) : THM = (
let
	val mf_s1 = simple_list_ƒ_elim [tm, concl thm] s12 ;
	val mf_s2 = Š_elim mf_s1 thm
in
	(prof "_left_intro";
	mf_s2)
end
handle complaint =>
divert complaint "simple_list_ƒ_elim" "_left_intro" 7002 []
);
end;
=TEX
Entirely new:
We prove the prove the local theorem:
ó
Œ_1_thm =  … (Œ t) ‚ (t ‚ F)
æ
=SML
local
	val s1 = asm_rule F;
	val s2 = contr_rule »t : BOOL¼ s1;
	val s3 = Š_intro F s2;
	val s4 = asm_rule »t Š F¼;
	val s5 = simple_list_ƒ_elim [»t : BOOL¼, F] Š_antisym_axiom;
	val s6 = Š_elim s5 s4;
	val s7 = Š_elim s6 s3;
	val s8 = Š_intro »t Š F¼ s7;
	val s9 = simple_ƒ_elim  »t : BOOL¼ Œ_thm;
	val s10 = eq_sym_rule s9;
	val s11 = subst_rule[(s10,»x : BOOL¼)] »x Š (t ‚ F)¼ s8;
	val s12  = asm_rule »t ‚ F¼;
	val s13 = eq_sym_rule s12;
	val s14 = subst_rule[(s13,»x : BOOL¼)]»Œ x¼  f_thm;
	val s15 = Š_intro »t ‚ F¼ s14;
	val s16 = simple_list_ƒ_elim [»Œ t¼, »t ‚ F¼] Š_antisym_axiom;
	val s17 = Š_elim s16 s11;
	val s18 = Š_elim s17 s15;
	val s19 = simple_ƒ_intro »t : BOOL¼ s18;
in
val  Œ_1_thm = save_thm("âŒ_1_thmá",s19);
end;
=TEX
We then locally prove:
ó
s10 … ƒ t1 t2 Ž (t1  t2) Š (Œ t2) Š t1
s17 … ƒ t1 t2 Ž (t1  t2) Š (Œ t1) Š t2
æ
=SML
local
	val s1 = asm_rule »t1  t2¼;
	val s2 = asm_rule »t1 : BOOL¼;
	val s3 = asm_rule »t2 : BOOL¼;
	val s4 = asm_rule »Œ t2¼;
	val s5 = Œ_elim »t1 : BOOL¼ s3 s4;
	val s6 = _elim s1 s2 s5;
	val s7 = Š_intro »Œ t2¼ s6;
	val s8 = Š_intro »t1  t2¼ s7;
	val s9 = simple_ƒ_intro »t2 : BOOL¼ s8;
	val s10 = simple_ƒ_intro »t1 : BOOL¼ s9;

	val s11 = asm_rule  »Œ t1¼;
	val s12 = Œ_elim »t2 : BOOL¼ s2 s11;
	val s13 = _elim s1 s12 s3;
	val s14 = Š_intro »Œ t1¼ s13;
	val s15 = Š_intro »t1  t2¼ s14;
	val s16 = simple_ƒ_intro »t2 : BOOL¼ s15;
	val s17 = simple_ƒ_intro »t1 : BOOL¼ s16;
in
fun â_cancel_ruleá (thm1 : THM) (thm2 : THM) : THM = (
let
	val (t1,t2) = dest_ (concl thm1);
in
(let
	val mf_s1 = simple_list_ƒ_elim [t1,t2] s10;
	val mf_s2 = Š_elim mf_s1 thm1;
	val mf_s2 = Š_elim mf_s2 thm2;
in
	(prof "_cancel_rule";
	mf_s2)
end
handle Fail _ =>
let
	val mf_s1 = simple_list_ƒ_elim [t1,t2] s17;
	val mf_s2 = Š_elim mf_s1 thm1;
	val mf_s2 = Š_elim mf_s2 thm2;
in
	(prof "_cancel_rule";
	mf_s2)
end)
end
handle complaint =>
list_divert complaint "_cancel_rule" [
	("dest_",7010,[]),
	("Š_elim",7050,[])]
);
end;
=TEX
\subsection{Concerning Š}
Can only do $Š\_match\_mp\_rule$ after we have $ƒ\_elim$.
=SML
fun âstrip_Š_ruleá (thm : THM) : THM = (
	if is_Š(concl thm)
	then strip_Š_rule(undisch_rule thm)
	else thm
);
=TEX
Note that the following will merge $\alpha$-convertible
assumptions into single hypotheses.
=SML
fun âall_Š_introá (thm : THM) : THM = (
	if is_nil(hyps thm)
	then thm
	else all_Š_intro(Š_intro (hd(hyps thm)) thm)
);
=TEX
Local theorem:
ó
s10 … ƒ t1 t2 t3 Ž (t1 Š t2) Š (t2 Š t3) Š (t1 Š t3)
æ
=SML
local
	val s1 = asm_rule »t1 Š t2¼;
	val s2 = asm_rule »t2 Š t3¼;
	val s3 = undisch_rule s1;
	val s4 = Š_elim s2 s3;
	val s5 = Š_intro »t1 : BOOL¼ s4;
	val s6 = Š_intro »t2 Š t3¼ s5;
	val s7 = Š_intro »t1 Š t2¼ s6;
	val s8 = simple_ƒ_intro »t3 : BOOL¼ s7;
	val s9 = simple_ƒ_intro »t2 : BOOL¼ s8;
	val s10 = simple_ƒ_intro »t1 : BOOL¼ s9;
in
fun âŠ_trans_ruleá (thm1 : THM) (thm2 : THM) : THM = (
let
	val (t1,t2) = dest_Š(concl thm1)
		handle complaint =>
		divert complaint "dest_Š" "Š_trans_rule" 7040 [];
	val (t2',t3) = dest_Š(concl thm2)
		handle complaint =>
		divert complaint "dest_Š" "Š_trans_rule" 7041 [];
	val mf_s1 = simple_list_ƒ_elim[t1, t2, t3] s10;
	val mf_s2 = Š_elim mf_s1 thm1;
	val mf_s3 = Š_elim mf_s2 thm2
		handle complaint =>
		divert complaint "Š_elim" "Š_trans_rule" 7042 [];
in
	(prof "Š_trans_rule";
	mf_s3)
end);
end;
=TEX

\section{END OF THE STRUCTURE}
=SML
(* end; structure DerivedInferenceRules *)
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
