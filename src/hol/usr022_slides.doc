=TEX
% usr022.doc   %Z% $Date$ $Revision$ $RCSfile$
% COPYRIGHT (c) International Computers Limited, 1992

\def\SCCSissue{$Revision$
}


% =====================================================================

\begin{slide}{1}

\vfill

\begin{center}

\vfill
\label{intro}
{\bf An Introduction\\
to\\
{\huge ProofPower}\\}

\vfill

A Specification and Proof Tool\\
for Higher Order Logic

\vfill

\end{center}

\end{slide}

% =====================================================================

\begin{slide}{2}
\begin{center}

{\bf Course Objectives}

\end{center}
\vfill

\begin{itemize}
\item
to describe the basic principles and concepts underlying ProofPower
\item
to enable the student to write simple specifications and undertake elementary proofs in HOL using ProofPower
\item
to enable the student to make effective use of the reference documentation 
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{3}
\begin{center}

{\bf Course Outline}

\end{center}
\vfill

\begin{itemize}
\item
Introduction

{\small
\begin{itemize}
\item
an overview of ProofPower
\item
propositional and predicate calculus proofs
\end{itemize}
}%\small

\item
Specification using ProofPower HOL

{\small
\begin{itemize}
\item
Primitive Syntax for TYPEs and TERMs
\item
Derived Syntax for TYPEs and TERMs
\item
Paragraphs (declarations) and Theories
\end{itemize}
}%\small

\item
Proof in HOL

{\small
\begin{itemize}
\item
Basics of Proof
\item
Rules, Conversions, Tactics...
\item
Stripping, Rewriting
\item
Induction
\end{itemize}
}%\small

\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{4}
\begin{center}
\bf Schedule
\end{center}
\vfill
\vertbarfalse
{\tiny
=GFT
slide	topic			time

01	introduction		9:00
20	exercises 1: proof		9:45
28	HOL TYPEs		10:10

	COFFEE			10:30

33	HOL TERMs		10:45
39	Derived syntax for TERMS	11:05
50	Theories			11:30
53	Exercises 2		11:45
54	Declarations/Paragraphs	12:05
59	Exercises 3		12:20

	LUNCH			12:30
	
59	Exercises 3 (cont)		13:30
60	Forward Proof		13:45
66	Exercises 4		14:10
68	Goal Oriented Proof
	/Rewriting			14:35
71	Exercises 5 & 6		14:50
75	Stripping			15:15

	COFFEE			15:30
	
78	Exercises 7		15:45
79	Induction			16:05
83	Exercises 8		16:20
85	TACTICALs et.al.		16:45
87	Exercises 9		16:55
=TEX
}%\tiny
\vertbartrue
\vfill
\end{slide}
% =====================================================================

\begin{slide}{5}
\begin{center}

{\bf Course Prerequisites}

\end{center}
\vfill

Some familiarity with:
\begin{itemize}
\item
first order predicate calculus
=GFT
¨(µx∑ P x ¥ R x) ¥ ((µ x∑ P x) ¥ (µx∑ R x))Æ;
=TEX
\item
elementary set theory
=GFT
¨µa b c∑ a ° (b ° c) = (a ° b) ° cÆ;
=TEX
\item
functional programming
=SML
fun	fact 0 = 1
|	fact n = n * (fact (n - 1));
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{6}
\begin{center}

{\bf Using Sunview}
\end{center}
\vfill
{\small
\begin{itemize}
\item
``login'' to user ``rj'' with password ``proofpow'', then type ``sunview''.
\item
To {\bf open} icon: press ``open'' button {\tiny (with cursor on icon)}.
\item
To {\bf close} window: press ``open'' button {\tiny (with cursor in window)}.
\item
To {\bf move} window: {\bf grab} {\tiny a corner} using {\bf middle button} and drag.
\item
To {\bf resize} window: {\bf grab} {\tiny a corner} using {\bf ``control'' and middle button} and drag.
\item
To {\bf select}: {\tiny press} {\bf left button} {\tiny at left of selection} {\bf and middle button} {\tiny at right}.
\item
To select {\bf single line}: triple click with left button.
\item
To {\bf copy and paste}: {\bf select} source, press {\bf copy} and {\tiny (with cursor in destination window)} {\bf paste}.
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================
\begin{slide}{7}
\begin{center}

{\bf Using ProofPower}

\end{center}
{\small
\vfill
\begin{itemize}
\item
To load {\bf ProofPower} type ``hol'' in command tool.
\item
To leave type ``quit();'' (or ``save\_and\_quit();'').
\item
MetaLanguage prompt is: ``$:>$''.
\item
ML commands (or top level expressions) are terminated by ``;''.
\item
ML continuation prompt is: ``$:\#$''.
\item
In case of mismatching brackets or quotes you may get stuck with the ``$:\#$'' prompt.
In this case break-in and type ``f'' (for ``fail'').
\item
To {\bf break-in} type Control-and-C.
\end{itemize}
\vfill
}%\small
\end{slide}


% =====================================================================

\begin{slide}{8}
\begin{center}

{\bf Features of ProofPower}

\end{center}
\vfill

\begin{itemize}
\item
Pedigree
\item
Power
\item
Assurance
\item
Openness
\item
Extensibility
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{9}
\begin{center}
{\bf Pedigree}
\end{center}
\vfill

\begin{itemize}
\item
In tradition of Principia Mathematica.
\item
Based on Church's Simple Theory of Types.
\item
Milner style polymorphism
\item
Implementation builds on research at Universities of Edinburgh, Cambridge and Oxford.
\item
Follows ``LCF paradigm''.
\item
Metalanguage is Standard ML.
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{10}
\begin{center}

{\bf Power}

\end{center}
\vfill

ProofPower HOL is:

\begin{itemize}
\item
Logically as expressive as Z.
\item
Notationally almost as concise as Z.
\item
Much less complex than Z.
\end{itemize}
ProofPower HOL has:
\begin{itemize}
\item 
\begin{center}
80\% of the power of Z\\
for\\
20\% of the complexity.
\end{center}
\item
Modern functional metalanguage (Standard ML) for programming proofs and system extensions.
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{11}
\begin{center}

{\bf Assurance}

\end{center}
\vfill

\begin{itemize}
\item
Simple uncontroversial classical logical system.
\item
Mathematical and formal specifications of syntax and semantics of formal system.
\item
Good support for specification by conservative extension.
\item
Small ($<$10\% system code) logical kernel, implemented as abstract datatype, enforces logical soundness of proofs.
\item
Formal specifications of logical kernel.
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{12}
\begin{center}

{\bf Openness}

\end{center}
\vfill

\begin{itemize}
\item
support for standard well documented languages targetted (Standard ML, HOL, Z, SAL/SPARK)
\item
most of the functions used to build system are available for re-use by the user
\item
comprehensive reference manual (500 + pages) documenting all the functions supplied ($>$1000 ML names)
\item
libraries of theories and ``proof contexts'' provided for re-use
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{13}
\begin{center}

{\bf Extensibility}

\end{center}
\vfill

\begin{itemize}
\item
User has access to metalanguage (Standard ML) for:
\begin{itemize}
\item
developing proofs
\item
extending system
\item
domain specific proof automation
\end{itemize}
\item
extendible definitional forms
\item
customisable ``proof contexts''
\item
designed to support multiple object languages
\item
parser generator available
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{14}
\begin{center}

{\bf Languages Supported}

\end{center}
\vfill

\begin{itemize}
\item
NOW:
\begin{itemize}
\item
Standard ML (as metalanguage)
\item
Higher Order Logic
\end{itemize}

\item
SOON:
\begin{itemize}
\item
Z
\item
SAL (SPARK Annotation Language)
\end{itemize}

\item
EVENTUALLY (we hope):
\begin{itemize}
\item
ISO Standard Z
\item
others
\end{itemize}
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{15}
\begin{center}

{\bf Functionality}

\end{center}

\begin{itemize}
\vfill

{\small
\item
document preparation/printing:

\begin{itemize}
\item
using LaTeX ``literate scripts'' with extended fonts for document sources
\item
indexes, cross reference and theory listings
\end{itemize}

\item
syntax check/type check (interactive or batch)

\item
formal reasoning (interactive or batch)

\item
theory management:

\begin{itemize}
\item
specifications and theorems held in theory hierarchy
\item
programmable access to theory hierarchy
\end{itemize}
}

\end{itemize}
\vfill

\end{slide}

% =====================================================================
\begin{slide}{16}
\begin{center}

{\bf Levels of Use of ProofPower}

\end{center}
\vfill

\begin{itemize}
\item
Education

{\tiny ProofPower is suitable for hands on interactive courses in mathematical logic, discrete mathematics and formal methods eventually including Z.
(however, course material needs to be developed)}

\item
Specification

{\tiny ProofPower HOL can be used as a specification language without the need to understand the proof development facilities.}

\item
Proof Development

{\tiny Most application proofs require knowledge of a modest subset of the proof facilities.}

\item
Research/ Proof tool development

{\tiny ProofPower, like Cambridge HOL, is a good vehicle for research in a number of areas.
Research, or other developments to the capabilities of the tool, can be undertaken by users, but requires deeper knowledge and understanding of the system.}
\end{itemize}
\vfill
\end{slide}
% =====================================================================

\begin{slide}{17}
\begin{center}
\vfill

{\bf Some Proofs are Easy with ProofPower}
\end{center}

\begin{itemize}
\item
propositional tautologies

{\tiny ProofPower proves these automatically, and uses propositional reasoning to simplify non-propositional goals automatically.}

\item
first order predicate calculus

{\tiny Often these will also be automatically provable using resolution.
Where resolution fails, there is a simple systematic approach to proving these results using ProofPower.}

\item
elementary set theory

{\tiny A useful class of results from elementary set theory are automatically provable.}

\item
other classes of results

{\tiny Whenever a new theory is introduced one or more proof contexts may be developed to solve automatically a range of results in that theory.
``Decision procedures'' for such classes of results can be made available via "prove\_tac".}
\end{itemize}
\vfill
\end{slide}

% =====================================================================
\begin{slide}{18}
\begin{center}

{\bf Simple Predicate Calculus Proofs}
\end{center}
\vfill
{\small

\begin{itemize}
\item
use the subgoaling package

\item
set the goal

=SML
set_goal([],¨(µx y∑ P x ¥ R y)
	§ (µv w∑ ≥ P w ≤ R v)Æ);
=IGN
set_goal([],¨(µx y∑ P x ¥ R y) § (µv w∑ P w ≤ R v)Æ);
=TEX
\item
initiate proof by contradiction
=SML
a contr_tac;
=TEX
=GFT ProofPower output
Tactic produced 2 subgoals:
...
(* *** Goal "1" *** *)

(*  3 *)  ¨µ x y∑ P x ¥ R yÆ
(*  2 *)  ¨P wÆ
(*  1 *)  ¨≥ R vÆ

(* ?Ù *)  ¨FÆ
=TEX
\item
instantiate assumptions as required
=SML
a (list_spec_asm_tac ¨µ x y∑ P x ¥ R yÆ [¨wÆ,¨vÆ]);
=TEX
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{19}
\vfill
{\small
=GFT ProofPower output
Tactic produced 0 subgoals:
(* *** Goal "2" *** *)

(*  3 *)  ¨µ v w∑ ≥ P w ≤ R vÆ
(*  2 *)  ¨P xÆ
(*  1 *)  ¨≥ R yÆ

(* ?Ù *)  ¨FÆ
=SML
a (list_spec_asm_tac ¨µ v w∑ ≥ P w ≤ R vÆ [¨yÆ,¨xÆ]);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=SML
pop_thm();
=GFT ProofPower output
Now 0 goals on the main goal stack
val it = Ù (µ x y∑ P x ¥ R y)
		§ (µ v w∑ ≥ P w ≤ R v) : THM   
=TEX
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{20}
\begin{center}
{\bf Exercises 1: Proof}
\end{center}
{\small
\vfill
Set the proof context:
=SML
set_pc "hol1";
=TEX
Set the goal (from the examples supplied):
=GFT
set_goal([],¨conjectureÆ);
=TEX
Then try the following methods of proof:
\begin{itemize}
\item
Two tactic method using:
=GFT
a contr_tac; (* once *)
a (list_spec_asm_tac [¨t1Æ, ¨t2Æ]);
  (* as many as necessary *)
=TEX
\item or
=GFT
a (prove_tac[]); (* once *)
=TEX
\item or
=GFT
a step_strip_tac; (* many times *)
=IGN 
drop_main_goal();
repeat drop_main_goal;
=TEX
\end{itemize}
in case of difficulty, revert to the two tactic method.
\vfill
}%\small
\end{slide}

% =====================================================================
{\tiny
\begin{slide}{21}
\vfill
=IGN bits and pieces
set_goal([],¨Æ);
a contr_tac;
a strip_tac;
a step_strip_tac;
prove_rule []
;
map (prove_rule [])
;
map (fn t => tac_proof (([],t),(REPEAT step_strip_tac))) ZRM2
;
map (fn t => tac_proof (([],t),prove_tac[])) ZRM3
;
a (list_spec_nth_asm_tac 1 [¨Æ]);
=TEX
=SML
(* Results from Principia Mathematica *2 *)
val PM2 =[
¨(* *2.02 *) q ¥ ( p ¥ q)Æ,
¨(* *2.03 *) (p ¥ ≥ q) ¥ (q ¥ ≥ p)Æ,
¨(* *2.15 *) (≥ p ¥ q) ¥ (≥ q ¥ p)Æ,
¨(* *2.16 *) (p ¥ q) ¥ (≥ q ¥ ≥ p)Æ,
¨(* *2.17 *) (≥ q ¥ ≥ p) ¥ (p ¥ q)Æ,
¨(* *2.04 *) (p ¥ q ¥ r) ¥ (q ¥ p ¥ r)Æ,
¨(* *2.05 *) (q ¥ r) ¥ (p ¥ q) ¥ (p ¥ r)Æ,
¨(* *2.06 *) (p ¥ q) ¥ (q ¥ r) ¥ (p ¥ r)Æ,
¨(* *2.08 *) p ¥ pÆ,
¨(* *2.21 *) ≥ p ¥ (p ¥ q)Æ];
=TEX
\vfill
=SML
(* Results from Principia Mathematica *3 *)
val PM3 =[
(* *3.01 *) ¨p ± q § ≥(≥ p ≤ ≥ q)Æ,
(* *3.2  *) ¨p ¥ q ¥ p ± qÆ,
(* *3.26 *) ¨p ± q ¥ pÆ,
(* *3.27 *) ¨p ± q ¥ qÆ,
(* *3.3  *) ¨(p ± q ¥ r) ¥ (p ¥ q ¥ r)Æ,
(* *3.31 *) ¨(p ¥ q ¥ r) ¥ (p ± q ¥ r)Æ,
(* *3.35 *) ¨(p ± (p ¥ q)) ¥ qÆ,
(* *3.43 *) ¨(p ¥ q) ± (p ¥ r) ¥ (p ¥ q ± r)Æ,
(* *3.45 *) ¨(p ¥ q) ¥ (p ± r ¥ q ± r)Æ,
(* *3.47 *) ¨(p ¥ r) ± (q ¥ s) ¥ (p ± q ¥ r ± s)Æ];
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{22}
\vfill
=SML
(* Results from Principia Mathematica *4 *)
val PM4 =[
(* *4.1  *) ¨p ¥ q § ≥ q ¥ ≥ pÆ,
(* *4.11 *) ¨(p § q) § (≥ p § ≥ q)Æ,
(* *4.13 *) ¨p § ≥≥ pÆ,
(* *4.2  *) ¨p § pÆ,
(* *4.21 *) ¨(p § q) § (q § p)Æ,
(* *4.22 *) ¨(p § q) ± (q § r) ¥ (p § r)Æ,
(* *4.24 *) ¨p § p ± pÆ,
(* *4.25 *) ¨p § p ≤ pÆ,
(* *4.3  *) ¨p ± q § q ± pÆ,
(* *4.31 *) ¨p ≤ q § q ≤ pÆ,
(* *4.33 *) ¨(p ± q) ± r § p ± (q ± r)Æ,
(* *4.4  *) ¨p ± (q ≤ r) § (p ± q) ≤ (p ± r)Æ,
(* *4.41 *) ¨p ≤ (q ± r) § (p ≤ q) ± (p ≤ r)Æ,
(* *4.71 *) ¨(p ¥ q) § (p § (p ± q))Æ,
(* *4.73 *) ¨q ¥ (p § (p ± q))Æ];
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{23}
\vfill
=SML
(* Results from Principia Mathematica *5 *)
val PM5 =[
(* *5.1  *) ¨p ± q ¥ (p § q)Æ,
(* *5.32 *) ¨(p ¥ (q § r)) ¥ ((p ± q) § (p ± r))Æ,
(* *5.6  *) ¨(p ± ≥ q ¥ r) ¥ (p ¥ (q ≤ r))Æ];
=TEX
=SML
(* Definitions from Principia Mathematica *9 *)
val PM9 =[
(* *9.01 *) ¨≥ (µx∑ ∆x) § (∂x∑ ≥ ∆x)Æ,
(* *9.02 *) ¨≥ (∂x∑ ∆x) § (µx∑ ≥ ∆x)Æ,
(* *9.03 *) ¨(µx∑ ∆x ≤ p) § (µx∑ ∆x) ≤ pÆ,
(* *9.04 *) ¨p ≤ (µx∑ ∆x) § (µx∑ p ≤ ∆x)Æ,
(* *9.05 *) ¨(∂x∑ ∆x ≤ p) § (∂x∑ ∆x) ≤ pÆ,
(* *9.06 *) ¨p ≤ (∂x∑ ∆x) § p ≤ (∂x∑ ∆x)Æ];
val PM9b =[
(* *9.07 *) ¨(µx∑ ∆x) ≤ (∂y∑ Ÿy) § (µx∑∂y∑ ∆x ≤ Ÿy)Æ,
(* *9.08 *) ¨(∂y∑ Ÿy) ≤ (µx∑ ∆x) § (µx∑∂y∑ Ÿy ≤ ∆x)Æ];
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{24}
\vfill
=SML
(* Results from Principia Mathematica *10 *)
val PM10 =[
(* *10.01  *) ¨(∂x∑ ∆x) § ≥ (µy∑ ≥ ∆y)Æ,
(* *10.1   *) ¨(µx∑ ∆x) ¥ ∆yÆ,
(* *10.21  *) ¨(µx∑ p ¥ ∆x) § p ¥ (µy∑ ∆y)Æ,
(* *10.22  *) ¨(µx∑ ∆x ± Ÿx) § (µy∑ ∆y) ± (µz∑ Ÿz)Æ,
(* *10.24  *) ¨(µx∑ ∆x ¥ p) § (∂y∑ ∆y) ¥ pÆ,
(* *10.27  *) ¨(µx∑ ∆x ¥ Ÿx) ¥ ((µy∑ ∆y) ¥ (µz∑ Ÿz))Æ,
(* *10.271 *) ¨(µx∑ ∆x § Ÿx) ¥ ((µy∑ ∆y) § (µz∑ Ÿz))Æ,
(* *10.28  *) ¨(µx∑ ∆x ¥ Ÿx) ¥ ((∂y∑ ∆y) ¥ (∂z∑ Ÿz))Æ,
(* *10.281 *) ¨(µx∑ ∆x § Ÿx) ¥ ((∂y∑ ∆y) § (∂z∑ Ÿz))Æ,
(* *10.35  *) ¨(∂x∑ p ± ∆x) § p ± (∂y∑ ∆y)Æ,
(* *10.42  *) ¨(∂x∑ ∆x) ≤ (∂y∑ Ÿy) § (∂z∑ ∆z ≤ Ÿz)Æ,
(* *10.5   *) ¨(∂x∑ ∆x ± Ÿx) ¥ (∂y∑ ∆y) ± (∂z∑ Ÿz)Æ,
(* *10.51  *) ¨≥(∂x∑ ∆x ± Ÿx) ¥ (µy∑ ∆y ¥ ≥ Ÿy)Æ];
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{25}
\vfill
=SML
(* Results from Principia Mathematica *11 *)
val PM11 =[
(* *11.1  *) ¨(µx y∑ ∆(x,y)) ¥ ∆(z,w)Æ,
(* *11.2  *) ¨(µx y∑ ∆(x,y)) § µy x∑ ∆(x,y)Æ,
(* *11.3  *) ¨(p ¥ (µx y∑ ∆(x,y)))
		§ (µx y∑ p ¥ ∆(x,y))Æ,
(* *11.32 *) ¨(µx y∑ ∆(x,y) ¥ Ÿ(x,y))
		¥ (µx y∑ ∆(x,y)) ¥ (µx y∑ Ÿ(x,y))Æ,
(* *11.35 *) ¨(µx y∑ ∆(x,y) ¥ p) § (∂x y∑ ∆(x,y)) ¥ pÆ,
(* *11.45 *) ¨(∂x y∑ p ¥ ∆(x,y))
		§ (p ¥ (∂x y∑ ∆(x,y)))Æ,
(* *11.54 *) ¨(∂x y∑ ∆x ± Ÿy) § (∂x∑ ∆x) ± (∂y∑ Ÿy)Æ,
(* *11.55 *) ¨(∂x y∑ ∆x ± Ÿ(x,y))
		§ (∂x∑ ∆x ± (∂y∑ Ÿ(x,y)))Æ,
(* *11.6  *) ¨(∂x∑ (∂y∑ ∆(x,y) ± Ÿy) ± —x)
		§ (∂y∑ (∂x∑ ∆(x,y) ± —x) ± Ÿy)Æ,
(* *11.62 *) ¨(µx y∑ ∆x ± Ÿ(x,y) ¥ —(x,y))
  		§ (µx∑ ∆x ¥ (µy∑ Ÿ(x,y) ¥ —(x,y)))Æ
];
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{26}
\vfill
=SML
(* results from ZRM provable by stripping *)
val ZRM1 = [
¨a ¿ a = a ¿ {}Æ,
¨a ¿ {} = a ° aÆ,
¨a ° a = a \ {}Æ,
¨a \ {} = aÆ,
¨a ° {} = a \ aÆ,
¨a \ a = {} \ aÆ,
¨{} \ a = {}Æ,
¨a ¿ b = b ¿ aÆ,
¨a ° b = b ° aÆ,
¨a ¿ (b ¿ c) = (a ¿ b) ¿ cÆ,
¨a ° (b ° c) = (a ° b) ° cÆ,
¨a ¿ (b ° c) = (a ¿ b) ° (a ¿ c)Æ,
¨a ° (b ¿ c) = (a ° b) ¿ (a ° c)Æ,
¨(a ° b) ¿ (a \ b) = aÆ,
¨(a \ b) ° b = {}Æ,
¨a \ (b \ c) = (a \ b) ¿ (a ° c)Æ,
¨(a \ b) \ c = (a \ (b ¿ c))Æ,
¨a ¿ (b \ c) = (a ¿ b) \ (c \ a)Æ,
¨a ° (b \ c) = (a ° b) \ cÆ,
¨(a ¿ b) \ c = (a \ c) ¿ (b \ c)Æ];
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{27}
\vfill
=SML
val ZRM2 = [
¨a \ (b ° c) = (a \ b) ¿ (a \ c)Æ,
¨≥ x ç {}Æ,
¨a Ä aÆ,
¨≥ a † aÆ,
¨{} Ä aÆ,
¨ﬁ {} = {}Æ,
¨• {} = UniverseÆ];
=TEX
\vfill
=SML
(* results from ZRM *)
val ZRM3 = [
¨a Ä b § a ç  bÆ,
¨a Ä b ± b Ä a § a = bÆ,
¨≥ (a † b ± b † a)Æ,
¨a Ä b ± b Ä c ¥ a Ä cÆ,
¨a † b ± b † c ¥ a † cÆ,
¨{} † a § ≥ a = {}Æ,
¨ﬁ (a ¿ b) = (ﬁ a) ¿ (ﬁ b)Æ,
¨• (a ¿ b) = (• a) ° (• b)Æ,
¨ a Ä b ¥ ﬁ a Ä ﬁ b Æ,
¨ a Ä b ¥ • b Ä • a Æ];
=TEX
\vfill
\end{slide}

}%\tiny
% =====================================================================

\begin{slide}{28}
\begin{center}

{\bf The HOL Type System}

\end{center}
{\small
\vfill

\begin{itemize}
\item
abstract syntax/computation
=SML
mk_vartype	: string			-> TYPE;  
mk_ctype	: string * TYPE list	-> TYPE;
=TEX
\item
concrete syntax
=GFT BNF
	Type	=	Name	
		|	Typars, Name
		|	Type, InfixName, Type
		| 	`(`, Type, `)`;
	Typars	=	Type
		|	`(`, Type, { `,`, Type }, `)`;
=TEX
{\tiny
Type variables must begin with a prime.\\
Infix status and priority determined by fixity declarations.
}%\tiny
\item
semantics
\begin{itemize}
\item
Types denote non-empty sets of values.
\item
Type variables range over non-empty sets of values.
\item
Type constructors denote functions from\\
tuples of sets to sets.
\end{itemize}
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{29}
\begin{center}

{\bf Examples of Types}

\end{center}
\vfill
{\tiny
=SML
î'aÆ;
		(* parsed type variable *)
val t = mk_vartype "'a";
		(* computed type variable *)
val u = îBOOLÆ;
		(* 0-ary type constructor *)
mk_ctype ("BOOL",[]);
		(* computed 0-ary type construction *)
îÓÆ;
		(* 0-ary type constructor *)
î'a LISTÆ;
		(* polymorphic list type *)
î(Ó) LISTÆ;
		(* lists of natural numbers *)
îÓ ≠ ÓÆ;
		(* infix type constructor *)
mk_ctype ("≠",[îÓÆ,îÓÆ]);
		(* computed function space *)
î ¨ËSML:Í tÆ ≠ ¨ËSML:Í uÆÆ;
	(* another way of writing ëmk_ctype("≠",[t,u])Æ *)
îÓ ∏ ÓÆ;
		(* pairs of natural numbers *)
îÓ + BOOLÆ;
		(* disjoint union of Ó and BOOL *)
î(Ó, Ó) $∏Æ;
		(* suspending infix status *)
=TEX
}%\tiny
\vfill
\end{slide}

% =====================================================================

\begin{slide}{30}
\begin{center}

{\bf Computation with TYPEs (I)\\
recognisers and destructors}
\end{center}
\vfill

\begin{itemize}
\item constructors
=SML
mk_vartype :string		-> TYPE;  
mk_ctype   :string*TYPE list	-> TYPE;
=TEX
\item recognisers
=SML
is_vartype	:TYPE -> bool;  
is_ctype	:TYPE -> bool;
=TEX
\item destructors
=SML
dest_vartype	:TYPE -> string;  
dest_ctype	:TYPE -> string * TYPE list;
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{31}
\begin{center}

{\bf Computation with TYPEs (II)\\
sample functions}

\end{center}
\vfill
\begin{itemize}
\item type equality
=SML
op =: : TYPE * TYPE -> bool;
=TEX
\item type variables in a type
=SML
type_tyvars : TYPE -> string list;
=TEX
\item type constructors in a type
=SML
type_tycons : TYPE -> (string * int) list;
=TEX
\item type instantiation
=SML
inst_type : (TYPE * TYPE) list
		-> TYPE -> TYPE;  
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{32}
\begin{center}

{\bf Computation with TYPEs (III)\\
support for pattern matching}
\end{center}
\vfill

{\small
\begin{itemize}
\item DEST\_SIMPLE\_TYPE
=GFT
datatype DEST_SIMPLE_TYPE =
	Vartype of string
|	Ctype of (string * TYPE list);
=TEX
\item generalised destructor
=SML
dest_simple_type: TYPE -> DEST_SIMPLE_TYPE;  
=TEX
\item generalised constructor
=SML
mk_simple_type : DEST_SIMPLE_TYPE -> TYPE;  
=TEX
\item pattern matching recursive functions
=SML
fun type_tyvars2 t = 
 (fn Vartype s	=> [s]
 |   Ctype (s,tl)	=> list_cup (map type_tyvars2 tl))
 (dest_simple_type t);
=TEX
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{33}
\begin{center}

{\bf HOL Terms}

\end{center}
\vfill
{\small

\begin{itemize}
\item
abstract syntax/computation
=GFT
datatype DEST_SIMPLE_TERM =
		Var	of string * TYPE
	|	Const	of string * TYPE
	|	App	of TERM * TERM
	|	SimpleÃ	of TERM * TERM;

dest_simple_term: TERM -> DEST_SIMPLE_TERM;
mk_simple_term: DEST_SIMPLE_TERM -> TERM;
=TEX
\item
concrete syntax
=GFT BNF
Term	=
		`Ã`, Name, [`:`, Type], `∑`, Term
	|	Term, Term 
	|	Term, InfixName, Term
	|	Term, `:`, Type
	|	Name
	|	`(`, Term, `)`;		
=TEX
{\tiny
Names are treated as variables unless declared as constants.\\
Infix status and priority determined by fixity declarations.
}%\tiny
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{34}
\begin{center}

{\bf Types of Terms}

\end{center}
\vfill
Terms must be well typed.\\
The type of a term is determined by type inference using the following rules:
\begin{itemize}
\item variables
=FRULE 1
˜
˜
¨v:¡Æ : ¡
=TEX
\item constants
=FRULE 1
˜
˜
¨c:¡Æ : ¡
=TEX
\item lambda abstractions
=FRULE 1
˜
t : ¡
˜
¨Ã x:¬ ∑ tÆ : ¬ ≠ ¡
=TEX
\item applications
=FRULE 1
˜
f : ¡ ≠ ¬; x : ¡
˜
¨f xÆ : ¬
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{35}
\begin{center}

{\bf Types of Terms}

\end{center}
\vfill
{\small
The same rules may be rendered in ML as follows:
\begin{itemize}
=IGN
(* if you execute the following declarations first then
the expressions in the rules below will evaluate *)
val vname = "var";
val vtype = îBOOLÆ;
val cname = "0";
val ctype = îÓÆ;
val term = ¨0Æ;
val ttype = îÓÆ;
val funterm = ¨fun : 'a ≠ 'bÆ;
val arg = ¨arg : 'aÆ;
=TEX
\item variables
=FRULE 1
˜
˜
type_of (mk_var(vname,vtype)) =: vtype;
=TEX
\item constants
=FRULE 1
˜
˜
type_of (mk_const(cname,ctype)) =: ctype;
=TEX
\item lambda abstractions
=FRULE 1
˜
type_of term =: ttype;
˜
type_of ¨Ã x:'a ∑ ëtermÆÆ =: î'a ≠ ¨ËSML:Í ttypeÆÆ;
=TEX
\item applications
=FRULE 1
˜
type_of funterm =: î'a ≠ 'bÆ;
type_of arg =: î'aÆ;
˜
type_of ¨ëfuntermÆ ëargÆÆ =: î'bÆ;
=TEX
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{36}
\begin{center}

{\bf Types of Terms - Examples}

\end{center}
{\small
\vfill
=SML
type_of ¨x:ÓÆ		=: îÓÆ;
type_of ¨x:'aÆ		=: î'aÆ;
type_of ¨0Æ		=: îÓÆ;
type_of ¨Ãx:Ó ∑ x + 1Æ	=: îÓ ≠ ÓÆ;
type_of ¨Ãx ∑ x + 1Æ	=: îÓ ≠ ÓÆ;
type_of ¨(Ãx ∑ x + 1) 3Æ	=: îÓÆ;
type_of ¨$+ 1Æ		=: îÓ ≠ ÓÆ;
type_of ¨$+Æ		=: îÓ ≠ Ó ≠ ÓÆ;
type_of ¨TÆ	=: îBOOLÆ;
type_of ¨≥ TÆ	=: îBOOLÆ;
type_of ¨$≥Æ	=: îBOOL ≠ BOOLÆ;
type_of ¨$±Æ	=: îBOOL ≠ BOOL ≠ BOOLÆ;
type_of ¨$µÆ	=: î('a ≠ BOOL) ≠ BOOLÆ;
=TEX
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{37}
\begin{center}

{\bf Semantics of Terms}

\end{center}
\vfill

\begin{itemize}
\item
{\bf Variables}\\
{\small range over the set denoted by their type.}
\item
{\bf Constants}\\
{\small denote particular values in the set denoted by their type.}
\item
{\bf Lambda Abstractions}\\
{\small denote total functions from the set denoted by the type of the variable to the set denoted by the type of the body.}

{\small The value at point ``p'' is the value of the body when the variable is assigned value ``p''.}
\item
{\bf Applications}\\
{\small denote the value of the function denoted by the first term at the point which is the value denoted by the second term.}
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{38}
\begin{center}

{\bf Semantics of Terms - Examples}

\end{center}
{\small
\vfill
=SML
¬_conv ¨(Ãx ∑ x + 1) 3Æ;
=GFT Hol Output
val it = Ù (Ã x∑ x + 1) 3 = 3 + 1 : THM   
=SML
rewrite_conv[] ¨(Ãx ∑ x + 1) 3Æ;
=GFT Hol Output
val it = Ù (Ã x∑ x + 1) 3 = 4 : THM   
=SML
»_axiom;
=GFT Hol Output
val it = Ù µ f∑ (Ã x∑ f x) = f : THM   
=SML
ext_thm;
=GFT Hol Output
val it = Ù µ f g∑ f = g § (µ x∑ f x = g x) : THM   
=SML
prove_rule[] ¨∂ x:Ó ∑	43 = xÆ;
prove_rule[] ¨∂ b:BOOL ∑	T = bÆ;
prove_rule[] ¨µ x:Ó ∑	x æ 0Æ;
prove_rule[] ¨µ b:BOOL ∑	b = T ≤ b = FÆ;
=TEX
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{39}
\begin{center}

{\bf Derived Syntax - DEST\_TERM}

\end{center}
{\small
\vfill
=GFT
datatype €DEST_TERM› =
   €DVar›		of string * TYPE
|  €DConst›	of string * TYPE
|  €DApp›		of TERM * TERM
|  €DÃ›		of TERM * TERM
|  €DEq›		of TERM * TERM
|  €D¥›		of TERM * TERM
|  €DT›
|  €DF›
|  €D≥›		of TERM
|  €DPair›		of TERM * TERM
|  €D±›		of TERM * TERM
|  €D≤›		of TERM * TERM
|  €D§›		of TERM * TERM
|  €DLet›		of ((TERM * TERM)list * TERM)
|  €DEnumSet›	of TERM list
|  €Dö›		of TYPE
|  €DSetComp›	of TERM * TERM
|  €DList›		of TERM list
|  €DEmptyList›	of TYPE
|  €Dµ›		of TERM * TERM
|  €D∂›		of TERM * TERM
|  €D∂â1›		of TERM * TERM
|  €D≈›		of TERM * TERM
|  €DIf›		of (TERM * TERM * TERM)
|  €DÓ›		of int
|  €DChar›		of string
|  €DString›	of string;
=TEX
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{40}
\begin{center}
{\bf Derived Syntax}
\end{center}
\vfill

\begin{itemize}
\item
prefix, infix and postfix operators 
\item
binders
\item
pair matching lambda abstractions
\item
conditionals
\item
local definitions
\item
set displays and abstractions
\item
list displays
\item
literals (numeric, character, and string)
\end{itemize}
\vfill

\end{slide}

% =====================================================================

\begin{slide}{41}
\begin{center}
{\bf binders}
\end{center}
\vfill
\begin{itemize}
\item
Constants having type: î('a ≠ 'b) ≠ 'cÆ\\
(or any instance of this)\\
may be declared as ``binders''.
\vfill
\item
Normally a ``binder'' is applied to a lambda expression, in which case the $Ã$ is omitted.
\vfill
\item
binder status may be suspended by use of $\$$.
=SML
¨∂ x∑ x = 4Æ =$ ¨$∂ Ã x∑ x = 4Æ;
=IGN
new_theory"temp";
new_const ("¡", î('a ≠ 'b) ≠ 'cÆ);
declare_binder"¡";
¨¡ x∑ x = 4Æ =$ ¨$∂ (Ã x∑ x = 4)Æ;
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{42}
\begin{center}
{\bf nested paired abstractions}
\end{center}
\vfill
{\small
\begin{itemize}
\item
nested lambda abstractions can be abbreviated as follows:
=SML
¨Ãx:Ó∑Ãy:Ó∑ (x,y)Æ =$ ¨Ã x y:Ó∑ (x,y)Æ;
=TEX
This function takes two natural numbers and returns a pair.
(``,'' is the infix pairing operator.)
\item
functions taking pairs may be written:\\
=SML
rewrite_conv[] ¨(Ã(x,y):Ó ∏ Ó∑ x)=FstÆ;
=GFT ProofPower output
val it = Ù (Ã (x, y)∑ x) = Fst § T : THM   
=TEX
This function takes an argument which is an ordered pair, and returns the first element of the pair.
\item
these effects can be iterated or combined.
=SML
rewrite_conv []
	¨(Ã(x,y):Ó ∏ Ó; ((v,w),z)∑ x + y + v + w + z)
	(1,2) ((3,4),5)Æ;
=GFT ProofPower output
val it =
	Ù (Ã (x, y) ((v, w), z)∑ x + y + v + w + z)
	(1, 2) ((3, 4), 5) = 15 : THM
=TEX
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{43}
\begin{center}
{\bf Conditionals}
\end{center}
\vfill
\begin{itemize}
\item
Conditionals may be written:

{\bf if} t1 {\bf then} t2 {\bf else} t3
=SML
rewrite_conv[] ¨if T then 0 else 1Æ;
=GFT ProofPower output
val it = Ù (if T then 0 else 1) = 0 : THM   
=TEX
=SML
rewrite_conv[] ¨if F then 0 else 1Æ;
=GFT ProofPower output
val it = Ù (if T then 0 else 1) = 1 : THM   
=TEX
=SML
rewrite_conv[] ¨if 3>6 then x else yÆ;
=GFT ProofPower output
val it = Ù (if 3 > 6 then x else y) = y : THM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{44}
\begin{center}
{\bf Let Clauses (I)}
\end{center}
\vfill
\begin{itemize}
\item
Local declarations may be made in the form:

{\bf let} defs {\bf in} term
=SML
rewrite_conv[let_def]¨let a = "Peter" in a,aÆ;
=GFT ProofPower output
val it = Ù (let a = "Peter" in (a, a))
		= ("Peter", "Peter") : THM   
=TEX
\item
The left hand side of a definition may be a ``varstruct'':
=SML
rewrite_conv[let_def]
	¨let (x,y) = (1,T) in (y,x)Æ;
=GFT ProofPower output
val it = Ù (let (x, y) = (1, T) in (y, x))
		= (T, 1) : THM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{45}
\begin{center}
{\bf Let Clauses (II)}
\end{center}
\vfill
\begin{itemize}
\item
The left hand side of a definition may be a function definition:
=SML
rewrite_conv[let_def]¨let f x = x*x in f 3Æ;
=GFT ProofPower output
val it = Ù (let f x = x * x in f 3)
		= 9 : THM   
=TEX
\item
Multiple definitions may be given in a single let clause.
=SML
rewrite_conv[let_def]
	¨let a = 1 and b = 2 in (a,b)Æ;
=GFT ProofPower output
val it = Ù (let a = 1 and b = 2 in (a, b))
		= (1, 2) : THM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{46}
\begin{center}
{\bf Set Displays}
\end{center}
\vfill

{\small
\begin{itemize}
\item
Sets may be entered as terms by enumeration:
=SML
rewrite_conv[]¨9 ç {1*1; 2*2; 3*3; 4*4}Æ;
=GFT ProofPower Output
val it = Ù 9 ç {1 * 1; 2 * 2; 3 * 3; 4 * 4}
	§ T : THM   
=TEX
=SML
rewrite_conv[]¨10 ç {1*1; 2*2; 3*3; 4*4}Æ;
=GFT ProofPower Output
val it = Ù 10 ç {1 * 1; 2 * 2; 3 * 3; 4 * 4}
	§ F : THM   
=TEX
\item
Sets may also be entered as set abstractions:
=SML
rewrite_conv[]¨9 ç {x | x < 12}Æ;
=GFT ProofPower Output
val it = Ù 9 ç {x|x < 12} § T : THM   
=TEX
=SML
rewrite_conv[]¨z ç {(x, y) | x < y}Æ;
=GFT ProofPower Output
val it = Ù z ç {(x, y)|x < y}
	§ Fst z < Snd z : THM   
=TEX
\end{itemize}
\vfill
}%\small

\end{slide}

% =====================================================================

\begin{slide}{47}
\begin{center}
{\bf List Displays}
\end{center}
\vfill
\begin{itemize}
\item
A similar syntax is available for lists:\\
\vfill
=SML
rewrite_conv[append_def]
	¨[1*1; 2*2; 3*3; 4*4] @ [5*5]Æ;
=GFT ProofPower Output
val it = Ù
	[1 * 1; 2 * 2; 3 * 3; 4 * 4] @ [5 * 5]
	= [1; 4; 9; 16; 25] : THM
=TEX
\vfill
=SML
¨Cons 1 [2;3;4;5]Æ;
=GFT ProofPower Output
val it = ¨[1; 2; 3; 4; 5]Æ : TERM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{48}
\begin{center}
{\bf Literals (I)}
\end{center}
\vfill
\begin{itemize}
\item
Numeric literals consist of a sequence of decimal digits (no sign):
=SML
dest_simple_term ¨123Æ;
=GFT ProofPower output
val it = Const ("123", îÓÆ)
	: DEST_SIMPLE_TERM   
=TEX
\vfill
\item
Character literals consisting of a single character in \verb!`! characters:
=SML
dest_simple_term ¨`¡`Æ;
=GFT ProofPower output
val it = Const ("`¡", îCHARÆ) (* ` *)
	: DEST_SIMPLE_TERM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{49}
\begin{center}
{\bf Literals (II)}
\end{center}
\vfill
{\small
\begin{itemize}
\item
String literals consisting of zero or more characters in ``\verb!"!'' characters:
=SML
dest_simple_term ¨"many characters ¡¬«"Æ;
=GFT ProofPower output
val it = Const ("\"many characters ¡¬«", (* " *)
	îCHAR LISTÆ) : DEST_SIMPLE_TERM
=TEX
% "
\vfill
\item
A string literal denotes a LIST of characters:
=SML
TOP_MAP_C string_conv ¨"characters ¡¬«"Æ;
=GFT ProofPower output
val it = Ù "characters ¡¬«"
    = [`c`; `h`; `a`; `r`; `a`; `c`; `t`; `e`; `r`; `s`;
    ` `; `¡`; `¬`; `«`] : THM
=TEX
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{50}
\begin{center}
{\bf Theories/Declarations/Definitions\\
Specifications/Paragraphs}
\end{center}
\vfill
\begin{itemize}
\item
Information about specifications is held in the theory database.
\vfill
\item
The information is mainly put in the theories using various declarations, and definitions which are calls to ML functions.
\vfill
\item
Some specifications may be effected using ``paragraphs'' in the object language (HOL).
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{51}
\begin{center}
{\bf Theories}
\end{center}
\vfill
A theory contains the following information:
\begin{itemize}
\item
The theory name and the names of the theories parents and children.
\item
The names and arities of type constructors declared in the theory.
\item
The names and types of constants declared in the theory.
\item
Fixity and aliasing information.
\item
Definitions of constants.
\item
A collection of saved theorems.
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{52}
\begin{center}
{\bf Access to Theories}
\end{center}
\vfill
\begin{itemize}
\item
To use a theory it must be ``in context'', this can be achieved be opening the theory or one of its descendents:
=SML
open_theory : string -> unit;
=TEX
\item
To display the contents of a theory:
=SML
print_theory : string -> unit;
=TEX
\item
To get things from the theory:
=SML
get_aliases; get_ancestors; get_axiom; get_axioms;
get_binders; get_children; get_consts; get_defn;
get_defns; get_descendants; get_parents; get_thm;
get_thms; get_spec;
=TEX
\item
To save things in the theory use declarations, definitions, specifications or paragraphs (see below).
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{53}
\begin{center}
{\bf Exercises 2:
HOL Theory Explorations}
\end{center}
\vfill
{\small
\begin{itemize}
\item
Find the names of all the theories:
=SML
theory_names();
=TEX
\item
Print selected theories, e.g.:
=SML
open_theory"sets";
print_theory"sets";
=TEX
\item
Get the terms from the definitions in a theory, e.g.:
=SML
open_theory "bin_rel";
(map concl o map snd o get_defns) "bin_rel";
=TEX
\item
Now select interesting terms and take them apart using, e.g.:
=SML
dest_simple_term ¨µ r s∑ r ´ s = (Dom s · r) ¿ sÆ;
dest_term ¨µ r s∑ r ´ s = (Dom s · r) ¿ sÆ;
dest_simple_type î'a SETÆ;
=TEX
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{54}
\begin{center}
{\bf Declarations (I)}
\end{center}

\vfill

\begin{itemize}
\item
theories and parents
=SML
open_theory	: string -> unit;
new_theory	: string -> unit;
new_parent	: string -> unit;
=TEX
\item
types
=SML
new_type
 : string * int -> TYPE;
new_type_defn
 : string list * string * string list * THM -> THM;
declare_type_abbrev
 : string * string list * TYPE -> unit;
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{55}
\begin{center}
{\bf Declarations (II)}
\end{center}

\vfill

\begin{itemize}
\item
constants
=SML
new_const
  : string * TYPE -> TERM;
simple_new_defn
  : string list * string * TERM -> THM;
new_spec
  : string list * int * THM -> THM;
const_spec
  : string list * TERM list * TERM -> THM;
=TEX
\item
types and constants
=SML
unlabelled_product_spec;
	(* mainly for use with Z *)
labelled_product_spec;
	(* see paragraphs below *)
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{56}
\begin{center}
{\bf Declarations (III)}
\end{center}

\vfill

Any identifier can be declared:

\begin{itemize}
\item
prefix, infix, postfix (with a priority)
\item
a binder (like ``µ'' and ``∂'')
\end{itemize}
=SML
declare_prefix	: int * string -> unit;
declare_infix	: int * string -> unit;
declare_postfix	: int * string -> unit;
declare_binder	: string -> unit;
get_fixity	: string -> Lex.FIXITY;
declare_nonfix	: string -> unit;
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{57}
\begin{center}
{\bf Paragraphs}
\end{center}
\vfill

Some declarations may be done without resort to the metalanguage:

\begin{itemize}
\item
constant declarations (based on $const\_spec$)
=SML
new_theory"temp";
πHOLCONST
‹
‹ fact : Ó ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹		fact 0 = 1
‹±	µn:Ó∑	fact (n+1) = (fact n) * (n+1)
∞
=TEX
\item
labelled product declarations
πHOLLABPROD Date¸¸¸¸¸¸¸
‹	day month year:Ó
∞¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{58}
\begin{center}
{\bf Paragraphs - example}
\end{center}

\vfill

πHOLCONST
‹ length : 'a LIST ≠ Ó
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	length [] = 0
‹± µ h t∑
‹	length (Cons h t) = length t + 1
‹
∞
=SML
print_theory"temp";
rewrite_conv[get_spec¨lengthÆ]
	¨length [1;2;3;4;5]Æ;
=TEX
\vfill
\end{slide}

% =====================================================================

\begin{slide}{59}
\begin{center}
{\bf Exercises 3: Specification}
\end{center}

\vfill

\begin{itemize}
\item
Create a new theory as a child of ``hol''.
=GFT
open_theory"hol";
new_theory"temp";
=TEX
\item
Write a specification in HOL of a function to add the elements of a list of numbers.

{\tiny HINT: if your specification goes in as a ``Constspec'' then they system could not prove it consistent, and its probably either wrong or poorly structured.
Try to make it clearly `primitive recursive'.}
\item
Use it to ``evaluate'' the term\\
$¨list\_sum [1;2;3;4;5]Æ$.
=GFT
rewrite_conv[get_spec¨list_sumÆ]
	¨list_sum [1;2;3;4;5]Æ;
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{60}
\begin{center}
\bf Forward Proof in ProofPower
\end{center}
\vfill
\begin{itemize}
\item
{\bf theorems} - {\small values of type THM computed from {\bf axioms} and {\bf definitions} using {\bf rules} and {\bf conversions}.}
\item
{\bf axioms} - {\small theorems introduced without proof.}
\item
{\bf definitions} - {\small axioms introduced by ``conservative'' mechanisms.}
\item
{\bf rules} - {\small functions which compute theorems.}
\item
{\bf conversions} - {\small rules which prove equations from terms.}
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{61}
\begin{center}
\bf Theorems
\end{center}
\vfill
{\small
\begin{itemize}
\item
The {\bf HOL logic} is a ``sequent calculus''.
\item
A {\bf sequent} is a ``(TERM list) * TERM''(=SEQ) where each term must have type îBOOLÆ.
\item
The list of TERMs are known as ``assumptions'' the single term is the conclusion of the sequent.
\item
A sequent is valid if whenever the assumptions are all true the conclusion is also true.
\item
A theorem is a sequent which has been derived from axioms and definitions using the rules of the logic.
Theorems are tagged with an indicator of the context in which they were derived.
\item
The sequent part of a theorem may be accessed using:
=SML
dest_thm	: THM -> SEQ;
asms		: THM -> TERM list;
concl		: THM -> TERM;
=TEX
\item
Theorems are displayed without ``quine corners''; they cannot be parsed, they must be proven (or introduced as axioms).
\item
To see the primitive constants and axioms look in theories ``min'', ``log'' and ``init''.
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{62}
\begin{center}
\bf Naming Conventions for Theorems and Rules
\end{center}
\vfill
\begin{itemize}
\item $\_axiom$\\
ML names ending with $\_axiom$ are used for axioms and for functions (e.g. $new\_axiom$) for introducing or accessing axioms.
\item $\_def$ $\_spec$\\
ML name suffixes used for definitions.
\item $\_thm$ $\_clauses$\\
ML name suffixes for theorems.
\item $\_rule$ $\_elim$ $\_intro$\\
used for inference rules.
\item $\_conv$\\
for conversions, rules having type TERM -$>$ THM where the THM is an equation with the TERM as its left hand operand.
\end{itemize}
\vfill
\end{slide}

% =====================================================================

{\small
\begin{slide}{63}
\begin{center}
\bf A Selection of Useful Rules (I)
\end{center}
\vfill
\begin{itemize}
\item assume rule:
=SML
val thm1 = asm_rule ¨µx y:Ó∑ x*y > 0Æ;
=GFT ProofPower Output
val thm1 = µ x y∑ x * y > 0
		Ù µ x y∑ x * y > 0 : THM   
=TEX
\item modus ponens
=SML
val thm_a = asm_rule¨a:BOOLÆ;
val thm_b = asm_rule¨a¥bÆ;
=GFT ProofPower Output
val thm_a = a Ù a : THM
val thm_b = a ¥ b Ù a ¥ b : THM   
=SML
val thm_c = ¥_elim thm_b thm_a;
=GFT ProofPower Output
val thm_c = a ¥ b, a Ù b : THM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{64}
\begin{center}
\bf A Selection of Useful Rules (II)
\end{center}
\vfill
\begin{itemize}
\item specialisation
=SML
val thm2 = µ_elim ¨455Æ thm1;
=GFT ProofPower Output
val thm2 = µ x y∑ x * y > 0
		Ù µ y∑ 455 * y > 0 : THM   
=TEX
\item multiple specialisation
=SML
val thm3 = list_µ_elim [¨455Æ,¨0Æ] thm1;
=GFT ProofPower Output
val thm3 = µ x y∑ x * y > 0
		Ù 455 * 0 > 0 : THM   
=TEX
\item removing outermost universals
=SML
val thm4 = all_µ_elim thm1;
=GFT ProofPower Output
val thm4 = µ x y∑ x * y > 0 Ù x * y > 0 : THM   
=TEX
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{65}
\begin{center}
\bf A Selection of Useful Rules (III)
\end{center}
\vfill
\begin{itemize}
\item splitting conjunctions
=SML
val thm5 = all_µ_elim plus_order_thm;
=GFT ProofPower output
val thm5 = Ù m + i = i + m
	± (i + m) + n = i + m + n
	± m + i + n = i + m + n : THM
=SML
val thms1 = strip_±_rule thm5;
=GFT ProofPower output
val thms1 = [Ù m + i = i + m,
	Ù (i + m) + n = i + m + n,
	Ù m + i + n = i + m + n] : THM list
=TEX
\item adding universals (I)
=SML
val thm6 = all_µ_intro (nth 2 thms1);
=GFT ProofPower output
val thm6 = Ù µ m i n∑ m + i + n = i + m + n : THM   
=TEX
\item adding universals (II)
=SML
val thm7 = list_µ_intro [¨iÆ,¨mÆ,¨nÆ] (nth 2 thms1);
=GFT ProofPower output
val thm7 = Ù µ i m n∑ m + i + n = i + m + n : THM   
=TEX
\end{itemize}
\vfill
\end{slide}
}%\small
% =====================================================================

\begin{slide}{66}
\begin{center}
\bf Exercises 4: Forward Proof
\end{center}
\vfill
{\small
=IGN
asm_rule
strip_±_rule
¥_elim
µ_elim
all_µ_elim
list_µ_elim
all_µ_intro
list_µ_intro
≥_plus1_thm
º_trans_thm
≥_less_thm
=TEX
\begin{enumerate}
\item
Using $¥\_elim$ and $asm\_rule$ prove:
\begin{enumerate}
\item
$ b¥c, a¥b, a Ù c$
\item
$ a¥b¥c, a, b Ù c$
\end{enumerate}
\item
Using $µ\_elim$ with $≥\_plus1\_thm$ prove:
\begin{enumerate}
\item
$ Ù ≥ 0+1=0 $
\item
$ Ù ≥ x*x+1=0 $
\end{enumerate}
\item
Using $all\_µ\_elim$ with $º\_trans\_thm$ prove:
\begin{enumerate}
\item
$Ù m º i ± i º n ¥ m º n $
\end{enumerate}
\item
Using $list\_µ\_elim$ prove:
\begin{enumerate}
\item (with $≥\_less\_thm$)\\
$Ù ≥ 0 < 1 § 1 º 0$
\item (with $º\_trans\_thm$)\\
Ù µ n∑ 3 º x * x ± x * x º n ¥ 3 º n   
\end{enumerate}
\item
Using $all\_µ\_elim$, $strip\_±\_rule$, $nth$, $all\_µ\_intro$:
\begin{enumerate}
\item (with $º\_clauses$)\\
Ù µ i m n∑ i + m º i + n § m º n
\item (using $list\_µ\_intro$)\\
Ù µ m i n∑ i + m º i + n § m º n
\end{enumerate}
\end{enumerate}
}%\small
\vfill
\end{slide}

% =====================================================================

{\tiny
\begin{slide}{67}
\begin{center}
\bf Exercises 4: Solutions
\end{center}
\vfill
\begin{enumerate}
\item -
=SML
(* (a) *)
val ext1_thm1 = asm_rule ¨a¥bÆ;
val ext1_thm2 = asm_rule ¨b¥cÆ;
val ext1_thm3 = asm_rule ¨a:BOOLÆ;
val ext1_thm4 = ¥_elim ext1_thm1 ext1_thm3;
val ext1_thm5 = ¥_elim ext1_thm2 ext1_thm4;
(* (b) *)
val ext2_thm1 =
 ¥_elim (asm_rule ¨a¥b¥cÆ)(asm_rule ¨a:BOOLÆ);
=TEX
\item -
=SML
(* (a) *)
val ext3_thm1 = µ_elim ¨0Æ ≥_plus1_thm;
(* (b) *)
val ext4_thm1 = µ_elim ¨x*xÆ ≥_plus1_thm;
=TEX
\item -
=SML
(* (a) *)
val ext5_thm1 = all_µ_elim º_trans_thm;
=TEX
\item -
=SML
(* (a) *)
val ext6_thm1 = list_µ_elim [¨0Æ,¨1Æ] ≥_less_thm;
(* (b) *)
val ext7_thm1 = list_µ_elim [¨3Æ,¨x*xÆ] º_trans_thm;
=TEX
\item -
=SML
(* (a) *)
val ext8_thm1 = strip_±_rule (all_µ_elim º_clauses);
val ext8_thm2 = all_µ_intro (nth 3 ext8_thm1);
(* (b) *)
val ext8_thm2 = list_µ_intro [¨mÆ,¨iÆ,¨nÆ](nth 3 ext8_thm1);
=TEX
\end{enumerate}
\vfill
\end{slide}
}%\tiny

% =====================================================================

\begin{slide}{68}
\begin{center}
\bf Goal Oriented Proof
\end{center}
\vfill
{\small
\begin{itemize}
\item a GOAL,

is just a sequent, viz:
\begin{itemize}
\item
a list of assumptions (BOOLean TERMs)
\item
a conclusion (also a BOOLean TERM)
\end{itemize}

GOAL = TERM list * TERM = SEQ
\item a PROOF,

is a function which computes a theorem from a list of theorems.

PROOF = THM list -$>$ THM
\item a TACTIC,

is a function which:
\begin{itemize}
\item
takes a GOAL
\item
returns
\begin{itemize}
\item
a list of sub-GOALs
\item
a PROOF which will compute a theorem corresponding to (``achieving'') the input goal from theorems corresponding to the sub-GOALs.
\end{itemize}
\end{itemize}

TACTIC = GOAL -$>$ (GOAL list * PROOF)
\end{itemize}
\vfill
}%\small
\end{slide}

% =====================================================================

\begin{slide}{69}
\begin{center}
\bf Using the Subgoal Package
\end{center}
\vfill
{\small
\begin{itemize}
\item
Getting started:
=SML
set_goal : GOAL -> unit;
push_goal : GOAL -> unit;
=TEX
\item
Moving along:
=SML
apply_tactic : TACTIC -> unit;
a : TACTIC -> unit;
undo : int -> unit;
set_labelled_goal : string -> unit;
lemma_tac : TERM -> TACTIC;
=TEX
\item
Finishing off:
=SML
top_thm : unit -> THM;
pop_thm : unit -> THM;
save_pop_thm : string -> THM;
=TEX
\item
by the way I should have mentioned:
=SML
save_thm : string * THM -> THM;
list_save_thm
	: string list * THM -> THM;
=TEX
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{70}
\begin{center}
\bf Rewriting
\vfill

$$ [pure\_] [once\_] [asm\_] rewrite\_ \cases{conv \cr rule \cr tac \cr} $$
	
$$ :THM\ list -> \cases{conv (= TERM -> THM)\cr THM -> THM\cr TACTIC\cr } $$
	
\end{center}
\vfill
rewrites term, theorem or goal using:

\begin{itemize}
\item
conversions in ``proof context'' (unless {\bf pure})
\item
assumptions (if {\bf asm}) (after context sensitive pre-processing)
\item
theorems in $THM\ list$ parameter (after context sensitive pre-processing)
\end{itemize}

Rewriting continues until no more rewrites are possible (unless {\bf once}).
\end{slide}

% =====================================================================

\begin{slide}{71}
\begin{center}
\bf Exercises 5:
Rewriting with the Subgoal Package
\end{center}
\vfill
{\small
\begin{enumerate}
\item
set a goal from the examples on set theory, e.g.:
=SML
set_goal([],¨a \ (b ° c) = (a \ b) ¿ (a \ c)Æ);
=TEX
\item
rewrite the goal using the current proof context:
=SML
a (rewrite_tac[]);
=TEX
\item
step back using undo:
=SML
undo 1;
=TEX
\item
now try rewriting without using the proof context:
=GFT
a (pure_rewrite_tac[]);
=TEX
(this should fail)
\end{enumerate}
}%\small
\vfill

\end{slide}

% =====================================================================

\begin{slide}{72}
\begin{center}
\bf Exercises 5 continued
\end{center}
\vfill
{\small
\begin{enumerate}
\setcounter{enumi}{4}
\item
try rewriting one layer at a time:
=SML
a (once_rewrite_tac[]);
=TEX
repeat until it fails.
\item
now try rewriting with specific theorems:
=SML
set_goal([],¨a \ (b ° c) = (a \ b) ¿ (a \ c)Æ);
a (pure_rewrite_tac[sets_ext_clauses]);
a (pure_rewrite_tac[set_dif_def]);
a (pure_rewrite_tac[°_def, ¿_def]);
a (pure_rewrite_tac[set_dif_def]);
=TEX
\item
finish the proof by stripping:
=SML
a (REPEAT strip_tac);
=TEX
\item
extract the theorem
=SML
top_thm();
=TEX
\item repeat the above then try repeating:
=SML
pop_thm();
=TEX
\end{enumerate}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{73}
\begin{center}
\bf Exercises 6:
combining forward and backward proof
\end{center}
\vfill
{\small
Prove the following results by rewriting using the goal package:
{\tiny for each example try the previous methods to see how they fail before following the hint
}%\tiny
\begin{enumerate}
\item :
=SML
set_goal([],¨x + y = y + xÆ);
=TEX
\item :
=SML
set_goal([],¨x + y + z = (x + y) + zÆ);
(* hint : try using plus_assoc_thm *)
=TEX
\item :
=SML
set_goal([],¨z + y + x = y + z + xÆ);
(* hint : try using plus_assoc_thm1 *)
=TEX
\item :
=SML
set_goal([],¨x + y + z = y + z + xÆ);
(* hint : try using µ_elim with plus_assoc_thm1 *)
=TEX
\item :
=SML
set_goal([],¨x + y + z + v = y + v + z + xÆ);
(* hint : try using µ_elim with plus_order_thm *)
=TEX
\end{enumerate}
}%\small
\vfill
\end{slide}

% =====================================================================

{\small
\begin{slide}{74}
\begin{center}
\bf Exercises 6: Solutions
\end{center}
\vfill
\begin{enumerate}
\item :
=SML
set_goal([],¨x + y = y + xÆ);
a (rewrite_tac[]);
=TEX
\item :
=SML
set_goal([],¨x + y + z = (x + y) + zÆ);
a (rewrite_tac[plus_assoc_thm]);
=TEX
\item :
=SML
set_goal([],¨z + y + x = y + z + xÆ);
a (rewrite_tac[plus_assoc_thm1]);
=TEX
\item :
=SML
set_goal([],¨x + y + z = y + z + xÆ);
a (rewrite_tac[µ_elim ¨yÆ plus_assoc_thm1]);
=TEX
\item :
=SML
set_goal([],¨x + y + z + v = y + v + z + xÆ);
a (rewrite_tac[µ_elim ¨xÆ plus_order_thm]);
=TEX
\end{enumerate}
\vfill
\end{slide}
}%\small

% =====================================================================

\begin{slide}{75}
\begin{center}
\bf Stripping
\end{center}
\vfill
\begin{itemize}
\item
``stripping'' facilities incorporate automatic propositional reasoning and enable domain specific knowledge to be invoked automatically during proof.
\item
$strip\_tac$ processes the conclusion of the current goal
\item
When new assumptions are created, by $strip\_tac$ or otherwise, they are normally stripped before being entered into the assumption list.
\item
Stripping of assumptions is different to stripping of conclusions.  
\end{itemize}
\vfill
\end{slide}

% =====================================================================

\begin{slide}{76}
\begin{center}
\bf Stripping Conclusions (concl's)
\end{center}
\vfill
{\small
\begin{enumerate}
\item
apply conclusion stripping conversions from proof context
\item
if no conversion applies then attempt one of the following:
\begin{enumerate}
\item :
=GFT
	.. ?Ù µx∑ P x ===> .. ?Ù P x'
=TEX
\item :
=GFT
	.. ?Ù P1 ± P2 ===>
		.. ?Ù P1 and .. ?Ù P2 (two subgoals)
=TEX
\item :
=GFT
	.. ?Ù P1 ¥ P2 ===>
		strip_asm_tac(P1), .. ?Ù P2
=TEX
\end{enumerate}
\item
then check if:
\begin{enumerate}
\item conclusion of the goal is ¨TÆ
\item conclusion is in the assumptions
\end{enumerate}
if so, prove the result
\end{enumerate}
}%\small
\vfill
\end{slide}

% =====================================================================

{\small
\begin{slide}{77}
\begin{center}
\bf Stripping Assumptions (asm's)
\end{center}
\vfill
\begin{enumerate}
\item
Repeat the following transformations untill no further changes occur:
apply assumption stripping conversions from proof context
\begin{enumerate}
\item :
apply assumption stripping conversions from proof context
\item :
=GFT
	∂x∑ P x Ù? .. ===> P x' Ù? ..
=TEX
\item :
=GFT
	P1 ≤ P2 Ù? .. ===>
		P1 Ù? .. and P2 Ù? .. (two subgoals)
=TEX
\item :
=GFT
	P1 ± P2 Ù? .. ===>
		P1, P2 Ù? .. (two assumptions)
=TEX
\end{enumerate}
\item
then for each resulting assumption, check if:
\begin{enumerate}
\item assumption = F
\item assumption = concl
\item contradicts an existing assumption
\end{enumerate}
if so, prove the result.
\item
also check if:
\begin{enumerate}
\item assumption = T
\item is same as an existing assumption
\end{enumerate}
if so, discard the assumption.
\end{enumerate}
\vfill
\end{slide}
}%\small

% =====================================================================

\begin{slide}{78}
\begin{center}
\bf Exercises 7: Stripping
\end{center}
\vfill
{\small
\begin{itemize}
\item
Use the examples from Principia Mathematica \& ZRM given earlier, e.g.:
=SML
	set_goal([],¨p ± q ¥ (p § q)Æ);
=TEX
with
\begin{enumerate}
\item :
=SML
	a strip_tac;
=TEX
\item and/or:
=SML
	a step_strip_tac;
=TEX
\end{enumerate}
\item
Observe the steps taken and try to identify the reasons for discharge of subgoals.
\item
Select the weakest ``proof context'':
=SML
	push_pc"initial";
=TEX
then retry the examples (or previous exercises).
\item
When you have finished restore the original proof context by:
=SML
	pop_pc();
=TEX
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{79}
\begin{center}
\bf Induction
\end{center}
\vfill
Induction priciples can be expressed as theorems in Higher Order Logic, e.g.:
\vfill
{\small
\begin{itemize}
\item $induction\_thm$
=GFT
	Ù µ p∑	p 0	±
	  (µ m∑ p m ¥ p (m + 1))
	¥	(µ n∑ p n) : THM   
=TEX
\item $cov\_induction\_thm$
=GFT
	Ù µ p∑	(µ n∑ (µ m∑ m < n ¥ p m) ¥ p n)
	¥	(µ n∑ p n) : THM   
=TEX
\item $list\_induction\_thm$
=GFT
	Ù µ p∑	p [] ±
	  (µ list∑ p list ¥ (µ x∑ p (Cons x list)))
	¥	(µ list∑ p list) : THM
=TEX
\end{itemize}
}%\small
\vfill
Using $µ\_elim$ and $all\_¬\_rule$ these can be specialised for use in forward proofs.
\vfill
\end{slide}

% =====================================================================

\begin{slide}{80}
\begin{center}
\bf Induction Tactics
\end{center}
\vfill
{\small
Special tactics are available to facilitate the use\\
of induction principles:
\begin{itemize}
\item induction over natural numbers using\\
$induction\_tac$
=FRULE 2
induction_tac ¨xÆ
˜
{ á } t
˜
{ á } t[0/x]; strip{t, á} t[x+1/x]
=TEX
\item induction over natural numbers using\\
$cov\_induction\_tac$
=FRULE 2
cov_induction_tac ¨xÆ
˜
{á} t
˜
strip{¨µm∑ m < x ¥ t[m/x]Æ, á} t
=TEX
\item $list\_induction\_tac$
=FRULE 2
list_induction_tac ¨xÆ
˜
{á} t
˜
{á} t[[]/x]; strip{t, á} t[Cons h x/x]
=TEX
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{81}
\begin{center}
\bf Induction - Example (I)
\end{center}
\vfill
Prove the associativity of append.
\vfill
{\small
=SML
set_goal([],¨µl1 l2 l3 ∑
	(l1 @ l2) @ l3 = l1 @ (l2 @ l3)Æ);
(* remove universal quantifiers *)
a (REPEAT strip_tac);
=GFT ProofPower output
(* *** Goal "" *** *)

(* ?Ù *)  ¨(l1 @ l2) @ l3 = l1 @ l2 @ l3Æ
=SML
(* induct on ¨l1Æ *)
a (list_induction_tac ¨l1Æ);
=GFT ProofPower output
(* *** Goal "2" *** *)

(*  1 *)  ¨(l1 @ l2) @ l3 = l1 @ l2 @ l3Æ

(* ?Ù *)  ¨µ x∑ (Cons x l1 @ l2) @ l3
		= Cons x l1 @ l2 @ l3Æ

(* *** Goal "1" *** *)

(* ?Ù *)  ¨([] @ l2) @ l3 = [] @ l2 @ l3Æ
=TEX
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{82}
\begin{center}
{\bf induction example (II)}
\end{center}
\vfill
{\small
=SML
a (rewrite_tac [append_def]);
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "2" *** *)

(*  1 *)  ¨(l1 @ l2) @ l3 = l1 @ l2 @ l3Æ

(* ?Ù *)  ¨µ x∑ (Cons x l1 @ l2) @ l3
		= Cons x l1 @ l2 @ l3Æ
=TEX
\vfill
=SML
a (asm_rewrite_tac [append_def]);
val append_assoc_thm = pop_thm();
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
val append_assoc_thm =
 Ù µ l1 l2 l3∑ (l1 @ l2) @ l3 = l1 @ l2 @ l3 : THM   
=TEX
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{83}
\begin{center}
\bf Exercises 8: Induction
\end{center}
\vfill
\begin{enumerate}
\item
Appending the empty list has no effect:
=SML
set_goal([], ¨µl1 ∑ l1 @ [] = l1Æ);
=TEX
\item
``Reverse'' distributes over ``@'' (sort of):
=SML
set_goal([], ¨µl1 l2 ∑
  Rev (l1 @ l2) = (Rev l2) @ (Rev l1)Æ);
=TEX
\item
``Map'' distributes over ``@'':
=SML
set_goal([], ¨µf l1 l2 ∑
  Map f (l1 @ l2) = (Map f l1) @ (Map f l2)Æ);
=TEX
\item
``Length'' distributes over ``@'':
=SML
set_goal([], ¨µl1 l2∑ Length (l1 @ l2)
	= Length l1 + Length l2Æ);
=TEX
\end{enumerate}
\vfill
\end{slide}

% =====================================================================

{\tiny
\begin{slide}{84}
\begin{center}
\bf Exercises 8: Solutions
\end{center}
\vfill
=SML
set_goal([],¨µl1 ∑ l1 @ [] = l1Æ);		(* no. 1 *)
a strip_tac;
a (list_induction_tac ¨l1Æ
  THEN asm_rewrite_tac [append_def]);
val empty_append_thm = pop_thm();
=TEX
=SML
set_goal([],¨µl1 l2 ∑ Rev (l1 @ l2) =
	(Rev l2) @ (Rev l1)Æ);	(* no. 2 *)
a (REPEAT strip_tac);
a (list_induction_tac ¨l1Æ THEN asm_rewrite_tac
  [append_assoc_thm, empty_append_thm,
	append_def, rev_def]);
val rev_distrib_thm = pop_thm();
=TEX
=SML
set_goal([],¨µf l1 l2 ∑ Map f (l1 @ l2) =
	(Map f l1) @ (Map f l2)Æ);	(* no. 3 *)
a (REPEAT strip_tac);
a (list_induction_tac ¨l1Æ THEN asm_rewrite_tac
  [map_def, empty_append_thm, append_def]);
val rev_distrib_thm = pop_thm();
=TEX
=SML
set_goal([],¨µl1 l2∑ Length (l1 @ l2) =
	Length l1 + Length l2Æ);	(* no. 4 *)
a (REPEAT strip_tac);
a (list_induction_tac ¨l1Æ THEN asm_rewrite_tac
  [append_def, length_def, plus_assoc_thm]);
val length_distrib_thm = pop_thm();
=TEX
\vfill
\end{slide}
}%\tiny

% =====================================================================

\begin{slide}{85}
\begin{center}
\bf TACTICALs and other -ALs
\end{center}
{\small
\vfill
\begin{itemize}
\item
TACTICALs may be used to combine the available tactics.
\item
Expressions using TACTICALs may be used directly in proofs, e.g.:
=GFT
	a (REPEAT strip_tac);
=TEX
\item
named tactics may be defined using TACTICALs:
=SML
	val repeat_strip_tac = REPEAT strip_tac;
=TEX
\item
TACTICALs may be used to define parameterised tactics:
=SML
	fun list_induct_tac t = REPEAT strip_tac
			THEN list_induction_tac t;
=TEX
\item
tacticals usually have capitalised names ending in ``\_T'', though the most common (e.g. REPEAT, THEN) have aliases omitting the ``\_T''
\item
other higher order functions are available:

conversionals (\_C suffix)\\
THM\_TACTICALs (\_THEN suffix)\\
THM\_TACTICAL combinators (\_TTCL suffix)
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{86}
\begin{center}
\bf commonly used TACTICals
\end{center}
{\small
\vfill
\begin{itemize}
\item
REPEAT - takes a tactic and returns a tactic which repeats that tactic until it fails.

If goal splits occur the repeating continues on all subgoals.

\item

THEN - an infix tactical which composes two tactics together.
The second tactic is applied to all subgoals arising from the first tactic.
If any applications of the operand tactics fail then the resulting tactic fails.

\item

ORELSE - an infix tactical which attempts to apply its first argument, and if this fails applies its second argument.
If both arguments fail then the resulting tactic fails.

\item
TRY\_T - a tactical taking one argument which will do nothing (but succeed!) if it argument tactic fails.

\item
THEN$\_$TRY - variant on THEN which does not fail even if the second tactic fails.

t1 THEN$\_$TRY t2 = t1 THEN (TRY\_T t2)
\end{itemize}
}%\small
\vfill
\end{slide}

% =====================================================================

\begin{slide}{87}
\begin{center}
\bf Exercises 9: TACTICALs
\end{center}
{\small
\vfill
\begin{enumerate}
\item
Write a tactic which does $strip\_tac$ three times.

test it on:
=SML
set_goal([],¨(a ¥ b ¥ c) ¥ a ¥ b ¥ cÆ);
set_goal([],¨(a ¥ b) ¥ a ¥ cÆ);
=TEX
\item
Write a tactic which does $strip\_tac$ up to 3 times.

Try it on the same examples.
\item
Write a tactic which takes two arguments:
\begin{itemize}
\item
a term which is a variable
\item
a list of theorems
\end{itemize}
and performs an inductive proof of a theorem concerning lists by:
\begin{itemize}
\item
stripping the goal
\item
inducting on the variable
\item
rewriting with the assumptions and the list of theorems
\end{itemize}

Use it to shorten the earlier proofs about lists.
\end{enumerate}
}%\small
\vfill
\end{slide}

% =====================================================================
\begin{slide}{88}
\begin{center}
\bf Exercises 9: Solutions
\end{center}
{\tiny
\vfill
=SML
(* no. 1 *)
val strip3_tac = strip_tac THEN strip_tac THEN strip_tac;
set_goal([],¨(a ¥ b ¥ c) ¥ a ¥ b ¥ cÆ);
a strip3_tac;
=TEX
\vfill
=SML
(* no. 2 *)
val stripto3_tac = strip_tac THEN_TRY strip_tac
		THEN_TRY strip_tac;
set_goal([],¨(a ¥ b) ¥ a ¥ cÆ);
a stripto3_tac;
=TEX
\vfill
=SML
(* no. 3 *)
fun list_induct_tac var thl =
	REPEAT strip_tac
	THEN list_induction_tac var
	THEN_TRY asm_rewrite_tac thl;

set_goal([],¨µl1 l2 l3 ∑
  (l1 @ l2) @ l3 = l1 @ (l2 @ l3)Æ);
a (list_induct_tac ¨l1:'a LISTÆ [append_def]);
val append_assoc_thm = pop_thm ();

set_goal([], ¨µl1:'a LIST ∑ l1 @ [] = l1Æ);
a (list_induct_tac ¨l1:'a LISTÆ [append_def]);
val empty_append_thm = pop_thm();
=TEX
=IGN
set_goal([], ¨µl1 l2:'a LIST  ∑
  Rev (l1 @ l2) = (Rev l2) @ (Rev l1)Æ);
a (list_induct_tac ¨l1:'a LISTÆ
  [append_def, rev_def, append_assoc_thm, empty_append_thm]);
set_goal([], ¨µf; l1 l2:'a LIST∑
  Map f (l1 @ l2) = (Map f l1) @ (Map f l2)Æ);
a (list_induct_tac ¨l1:'a LISTÆ
  [append_def, map_def, append_assoc_thm, empty_append_thm]);
set_goal([], ¨µl1 l2:'a LIST∑ Length (l1 @ l2)
	= Length l1 + Length l2Æ);
a (list_induct_tac ¨l1:'a LISTÆ
  [append_def, length_def, append_assoc_thm,
  empty_append_thm, plus_assoc_thm]);
=TEX
}%\tiny
\vfill
\end{slide}

% =====================================================================

\begin{slide}{89}
\begin{center}
\bf Proof Strategy
\end{center}
{\small
\vfill
\begin{itemize}
\item

A large application proof will take several man years of effort to complete.

\item

Top level proof strategy for large proofs must be carefully thought out.

{\tiny
The lemmas are best proven separately, stored in the theory, and combined in a top level proof delivering the required result from the major lemmas.
Exploration may be forwards or backwards.
}%\tiny

\item

Lemmas of moderate size may be proven using the goal package.

{\tiny
Such a proof would consist of a combination of stripping, rewriting with definitions, assumptions and previously proven results, and other uses of previous results.

A key topic is ``how to use and manipulate assumptions and previous results'' which is addressed below.
}%\tiny
\end{itemize}
}%\small
\vfill

\end{slide}

% =====================================================================

\begin{slide}{90}
\begin{center}
\bf Using Assumptions and Theorems
\end{center}
\vfill
{\tiny
\begin{itemize}
\item
rewriting will use either or both of assumptions and previously proved theorems
\vfill
\item
$list\_spec\_asm\_tac$ may be used to specialise assumptions (and strip results).
\vfill
\item
Assumptions can be used as a basis for forward proof using $asm\_rule$, or by $GET\_ASM\_T$ et. al.
\vfill
\item
Theorems may be stripped into assumptions using\\
$strip\_asm\_tac$ (or $check\_asm\_tac$).
\vfill
\item
Assumptions may be taken out to be rewritten using $asm\_ante\_tac$.
\end{itemize}
}%\tiny
\vfill
\end{slide}

% =====================================================================

=IGN
push_pc "hol1";
set_goal([],¨µl1 l2∑ Length (l1 @ l2) = Length l1 + Length l2Æ);
a (REPEAT strip_tac);
a (list_induction_tac ¨l1Æ THEN asm_rewrite_tac
  [append_def, length_def, plus_assoc_thm]);
=TEX
πHOLCONST
‹ interleave : 'a LIST ≠ 'a LIST ≠ 'a LIST
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹(µ h1 t1 h2 t2∑
‹	interleave [] [] = []
‹±	interleave [] (Cons h2 t2) = (Cons h2 t2)
‹±	interleave (Cons h1 t1) [] = (Cons h1 t1)
‹± 	interleave (Cons h1 t1) (Cons h2 t2) =
‹	Cons h1 (Cons h2 (interleave t1 t2)))
‹
∞
=SML
rewrite_conv[get_spec¨interleaveÆ]
  ¨interleave[1;2;3;4;5][10;11;12]Æ;
=TEX
\end{document}
