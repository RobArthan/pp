=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the Interface to the Abstract Data Type $THM$}  %% Mandatory field
\def\TPPheadtitle{Implementation for the \cr Interface to the Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/IMP012}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}
%\TPPstatus{Approved}
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issues 1.1 to 1.17]
First drafts, leading up to desk check ID0083, and responses.
\item [Issue 2.1 (27th September 1991)]
Approved version of issue 1.17.

\item[Issue \SCCSversion, \FormatDate{92/01/20} ] Updated to use new fonts.

\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the interface to the abstract data type $THM$, in particular the theory management material.
This does not however include the
primitive and built-in inference rules, which may be found in
\cite{DS/FMU/IED/DTD007}.
This is called for in section 4 of \cite{DS/FMU/IED/HLD007}.
The high-level specification for the code is
given in \cite{DS/FMU/IED/SPC003}, \cite{DS/FMU/IED/SPC004} and \cite{DS/FMU/IED/SPC005}.
The design is in \cite{DS/FMU/IED/DTD012}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the interface to the abstract data type $THM$, in particular the theory management material.
The interface is to provide a user- and implementor- friendly
interface to the Kernel of the system, as the kernel is designed
with only correctness, functionality and compactness in mind.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD012},
and also requires those files indicated as preceding it in the
rel001 makefile.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\newpage
\section{THEORY MANAGEMENT OPERATIONS}
We first start the structure:
=SML
structure KernelInterface : KernelInterface = struct
=TEX
Then we open up the Kernel:
=SML
open icl'Kernel;
open SimpleDictionary;
=TEX
\subsection{Kernel State Change Material}
As any operation that changes the kernel state must notify
the list of functions managed by the functions $on\_kernel\_state\_change$,
we need to provide that material first.

First the type itself:
=SML
datatype €KERNEL_STATE_CHANGE›
		=	€OpenTheory› of string * ((string list) * (string list))
		|	€DeleteTheory› of string
		|	€NewTheory› of string
		|	€NewParent› of string * (string list)
		|	€LockTheory› of string
		|	€UnlockTheory› of string
		|	€DuplicateTheory› of string * string
		|	€SaveThm› of string * THM
		|	€ListSaveThm› of string list * THM
		|	€DeleteConst› of TERM
		|	€DeleteType› of string
		|	€DeleteAxiom› of string
		|	€DeleteThm› of string
		|	€NewAxiom› of ((string * TERM)*THM)
		|	€NewConst› of string * TYPE
		|	€NewType› of string * int
		|	€SimpleNewDefn› of (string * string * TERM) * THM
		|	€NewTypeDefn› of (string * string * (string list) * THM) * THM
		|	€NewSpecification› of (string list * int * THM) * THM
		|	€SetUserDatum› of string * USER_DATUM;

=TEX
The notifier functions are called $notify\_on\_ksc$ and
$notify\_before\_ksc$, and the list of
functions to be notified is hidden, named $on\_ksc\_functions$
and $before\_ksc\_functions$.
=SML
local
	val €on_ksc_functions› : ((KERNEL_STATE_CHANGE -> unit) list) ref = ref [];
	val €before_ksc_functions› : ((KERNEL_STATE_CHANGE -> unit) list) ref = ref [];
in
	fun €on_kernel_state_change› (to_notify : KERNEL_STATE_CHANGE -> unit) : unit = (
		on_ksc_functions := (!on_ksc_functions) @ [to_notify]
	);

	fun €notify_on_ksc› (ksc : KERNEL_STATE_CHANGE) : unit = (
		map (fn f => f ksc) (!on_ksc_functions);
		()
	);

	fun €before_kernel_state_change› (to_notify : KERNEL_STATE_CHANGE -> unit) 
		: unit = (
		before_ksc_functions := (!before_ksc_functions) @ [to_notify]
	);

	fun €notify_before_ksc› (ksc : KERNEL_STATE_CHANGE) : unit = (
		map (fn f => f ksc) (!before_ksc_functions);
		()
	);
end; (* local *)
=TEX
\subsection{Operations on Theory Attributes}
These are generally straight forward:
=SML
fun €open_theory› (nm : string) : unit = (
let	val sideeffect = notify_before_ksc (OpenTheory (nm, ([],[])));
	val ot_res = icl'open_theory nm;
	val ot_res' = (map icl'get_theory_name ** map icl'get_theory_name) ot_res;
in
	notify_on_ksc (OpenTheory (nm, ot_res'));
	()
end
handle complaint => pass_on complaint "icl'open_theory" "open_theory");
=TEX
=SML
fun €delete_theory› (nm : string) : unit = (
let	val sideeffect = notify_before_ksc (DeleteTheory nm);
	val dummy = icl'delete_theory nm;
in
	notify_on_ksc (DeleteTheory nm);
	()
end
handle complaint => pass_on complaint "icl'delete_theory" "delete_theory");
=TEX
=SML
fun €new_theory› (nm : string) : unit = (
let	val sideeffect = notify_before_ksc (NewTheory nm);
	val dummy = (icl'new_theory nm; icl'open_theory nm);
in
	notify_on_ksc (NewTheory nm);
	()
end
handle complaint => pass_on complaint "icl'new_theory" "new_theory");
=TEX
=SML
fun €new_parent› (nm : string) : unit = (
let	val sideeffect = notify_before_ksc (NewParent (nm, []));
	val np_res = icl'new_parent nm;
	val np_res' = map icl'get_theory_name np_res;
in
	notify_on_ksc (NewParent (nm, np_res'));
	()
end
handle complaint => pass_on complaint "icl'new_parent" "new_parent");
=TEX
=SML
fun €lock_theory› (nm : string) : unit = (
let	val sideeffect = notify_before_ksc (LockTheory nm);
	val dummy = icl'lock_theory nm;
in
	notify_on_ksc (LockTheory nm);
	()
end
handle complaint => pass_on complaint "icl'lock_theory" "lock_theory");
=TEX
=SML
fun €unlock_theory› (nm : string) : unit = (
let	val sideeffect = notify_before_ksc (UnlockTheory nm);
	val dummy = icl'unlock_theory nm;
in
	notify_on_ksc (UnlockTheory nm);
	()
end
handle complaint => pass_on complaint "icl'unlock_theory" "unlock_theory");
=TEX
=SML
fun €duplicate_theory› (fromnm : string, tonm : string) : unit = (
let	val sideeffect = notify_before_ksc (DuplicateTheory (fromnm, ""));
	val dummy = icl'duplicate_theory fromnm tonm;
in
	notify_on_ksc (DuplicateTheory (fromnm, tonm));
	()
end
handle complaint => pass_on complaint "icl'duplicate_theory" "duplicate_theory");
=TEX
\subsection{Operations on Theory Contents}
$dest\_thm$ passes through without problem.
=SML
val €hyps› : THM -> TERM list = fst o dest_thm;
val €concl› : THM -> TERM = snd o dest_thm;
=TEX
=SML
fun €thm_theory› (thm : THM) : string = (
let	val {theory = {name = iname,...},...} = icl'dest_thm thm;
in
	icl'get_theory_name iname
	handle complaint => 
	divert complaint "icl'get_theory_name" "thm_theory" 12007 
		[fn () => string_of_thm thm,fn () => string_of_int iname]	
end);
=TEX
=SML
fun €save_thm› (key : string, thm : THM) : THM = (
let	val sideeffect = notify_before_ksc (SaveThm (key, thm));
	val saved = icl'list_save_thm ([key], thm);
in
	notify_on_ksc (SaveThm (key, thm));
	saved
end
handle complaint => pass_on complaint "icl'list_save_thm" "save_thm");
=TEX
=SML
fun €list_save_thm› (keys : string list, thm : THM) : THM = (
let	val sideeffect = notify_before_ksc (ListSaveThm (keys, thm));
	val saved = icl'list_save_thm (keys, thm);
in
	notify_on_ksc (ListSaveThm (keys, thm));
	saved
end
handle complaint => pass_on complaint "icl'list_save_thm" "list_save_thm");
=TEX
=SML
fun €delete_thm› (key : string) : THM = (
let	val sideeffect = notify_before_ksc (DeleteThm key);
	val thm = icl'delete_thm key;
in
	notify_on_ksc (DeleteThm key);
	thm
end
handle complaint => pass_on complaint "icl'delete_thm" "delete_thm");
=TEX
It is convenient to provide the following function ``out of order'':
=SML
fun €get_current_theory_name› (() : unit) : string = (
	icl'get_theory_name(icl'get_current_theory_name ())
);
=TEX
Given a level, give a list of the levels that need deleting.
We presume a well-formed $del\_levels$ list.
=SML
fun €deleted_levels› (level : int) : int list = (
let	val {del_levels = del_levels,current_level = current_level, ...} = icl'get_theory "-";

	fun get_levels llevel ((lb,ub) :: lst) = (
		if llevel < lb
		then (interval llevel (lb -1) @
			get_levels (ub+1) lst)
		else (get_levels (ub+1) lst)
	) | get_levels llevel [] = interval llevel current_level;

in
	get_levels level del_levels
end);
=TEX
For the following $delete\_$ functions we need an auxiliary ``delete to level'' function.
This will find out what is to be deleted, and do all the
kernel and user notification required.
=SML
fun €delete_to_level› (caller : string) (target : string) (level : int) : unit = (
let	val dummy = case (get_current_theory_status()) of
		TSNormal => ()
		| TSDeleted => error caller 6008 
			[fn () => get_current_theory_name()]
		| TSLocked => fail caller 6037
			[fn () => get_current_theory_name()]
		| TSAncestor => fail caller 6071
			[fn () => get_current_theory_name()];

	val {children = children,...} = icl'get_theory_info "-";

	val dummy = if children <> [] 
		then fail caller 6076 [fn () => get_current_theory_name()]
		else ();

	val {con_env = con_env,ty_env = ty_env,
		axiom_dict = axiom_dict, thm_dict = thm_dict,
		defn_dict = defn_dict,...} = icl'get_theory "-";

	val (del_con,del_lev1) = split (map (fn (name,{ty = ty,level = lev,...}) => ((name, ty),lev))
		(con_env drop (fn (_,{level = lev,...}) => lev < level)));

	val (del_type,del_lev2) = split(map (fn (name,{level = lev,...}) => (name,lev))
		(ty_env drop (fn (_,{level = lev,...}) => lev < level)));

	val del_thms = map (fn (key,_) => key)
		(thm_dict drop (fn (_,thm) => 
			let val {level = lev,...} = icl'dest_thm thm
			in lev < level end));

	val (del_axioms, del_lev3) = split(map (fn (key,thm) => (key,
			let val {level = lev,...} = icl'dest_thm thm
			in lev end))
		(axiom_dict drop (fn (_,thm) => 
			let val {level = lev,...} = icl'dest_thm thm
			in lev < level end)));

	val (del_defns, del_lev4) = split(map (fn (key,thm) => (key,
			let val {level = lev,...} = icl'dest_thm thm
			in lev end))
		(defn_dict drop (fn (_,thm) => 
			let val {level = lev,...} = icl'dest_thm thm
			in lev < level end)));

	val I = Combinators.I;

	val to_be_d = (
		format_list Combinators.I 
		(flat [
		if is_nil del_con
		then []
		else [get_error_message 12100 
			[if length del_con = 1 then "" else "s"] ^ 
			(format_list fst del_con ", ")],
		if is_nil del_type
		then []
		else [get_error_message 12101 
			[if length del_type = 1 then "" else "s"] ^ 
			(format_list I del_type ", ")],
		if is_nil del_thms
		then []
		else [get_error_message 12102 
			[if length del_thms = 1 then "" else "s"] ^ 
			(format_list I del_thms ", ")],
		if is_nil del_axioms
		then []
		else [get_error_message 12103 
			[if length del_axioms = 1 then "" else "s"] ^ 
			(format_list I del_axioms ", ")],
		if is_nil del_defns
		then []
		else [get_error_message 12104 
			[if length del_defns = 1 then "" else "s"] ^ 
			(format_list I del_defns ", ")]])
		) "; ";
=TEX
We now ask the interactive user whether he wishes everything
necessary to be deleted.
=SML
	val dummy = warn caller 12012 [(fn () => target),(fn () => to_be_d)];
=TEX
We now have permission to proceed:
=SML
	val dl = list_cup[del_lev1, del_lev2, del_lev3, del_lev4];

	val dummy = (map (fn xt => notify_before_ksc (DeleteConst (mk_const xt))) del_con;
		map (fn t => notify_before_ksc (DeleteType t)) del_type;
		map (fn ax => notify_before_ksc (DeleteAxiom ax)) del_axioms;
		map (fn thm => notify_before_ksc (DeleteThm thm)) del_thms;
		());

	val dummy = map icl'delete_thm del_thms;

	val dummy = map (fn x => icl'delete_extension ()) dl;
in
	map (fn xt => notify_on_ksc (DeleteConst (mk_const xt))) del_con;
	map (fn t => notify_on_ksc (DeleteType t)) del_type;
	map (fn ax => notify_on_ksc (DeleteAxiom ax)) del_axioms;
	map (fn thm => notify_on_ksc (DeleteThm thm)) del_thms;
	()
end);
=TEX
We can now give the deletion functions:
=SML
fun €delete_const› (cnt : TERM) : unit = (
let	val (cnm, cty) = dest_const cnt
		handle complaint =>
		pass_on complaint "dest_const" "delete_const";

	val {con_env = con_env,...} = icl'get_theory "-";

	val {level = level, ty = ty} = force_value(s_lookup cnm con_env)
		handle complaint =>
		divert complaint "force_value" "delete_const" 12001 
			[fn () => get_current_theory_name (),
			 fn () => cnm];

	val dummy = if not(is_type_instance ty cty andalso 
			is_type_instance cty ty)
		then fail "delete_const" 12001 
			[fn () => get_current_theory_name (),
			 fn () => cnm]
		else ();
in
	delete_to_level "delete_const" cnm level
end);
=TEX
=SML
fun €delete_type› (tnm : string) : unit = (
let	val {ty_env = ty_env,...} = icl'get_theory "-";

	val {level = level, ...} = force_value(s_lookup tnm ty_env)
		handle complaint =>
		divert complaint "force_value" "delete_type" 12002 
			[fn () => get_current_theory_name (),
			 fn () => tnm];
in
	delete_to_level "delete_type" tnm level
end);
=TEX
=SML
fun €delete_axiom› (anm : string) : unit = (
let	val {axiom_dict = axiom_dict,...} = icl'get_theory "-";

	val ax = force_value(s_lookup anm axiom_dict)
		handle complaint =>
		divert complaint "force_value" "delete_axiom" 12003
			[fn () => get_current_theory_name (),
			 fn () => anm];

	val {level = level,...} = icl'dest_thm ax;
in
	delete_to_level "delete_axiom" anm level
end);
=TEX
=SML
fun €new_axiom› (key : string, tm : TERM) : THM = (
let	val sideeffect = notify_before_ksc (NewAxiom ((key, tm),
		(icl'Kernel.icl'asm_rule mk_t)));
	val saved = icl'new_axiom ([key], tm);
in
	notify_on_ksc (NewAxiom ((key, tm),saved));
	saved
end
handle complaint => pass_on complaint "icl'new_axiom" "new_axiom");
=TEX
=SML
fun €new_const› (cnm : string, ty : TYPE) : TERM = (
let	val sideeffect = notify_before_ksc (NewConst (cnm, ty));
	val saved = icl'new_const (cnm, ty);
in
	notify_on_ksc (NewConst (cnm, ty));
	saved
end
handle complaint => pass_on complaint "icl'new_const" "new_const");
=TEX
=SML
fun €new_type› (cnm : string, arity : int) : TYPE = (
let	val sideeffect = notify_before_ksc (NewType (cnm, arity));
	val saved = icl'new_type (cnm, arity);
in
	notify_on_ksc (NewType (cnm, arity));
	saved
end
handle complaint => pass_on complaint "icl'new_type" "new_type");
=TEX
=SML
fun €set_user_datum› (key : string, ud : USER_DATUM) : unit = (
let	val sideeffect = notify_before_ksc (SetUserDatum (key,ud));
	val {user_data = user_data,...} = icl'get_theory "-";

	val dummy = case (get_current_theory_status()) of
		TSNormal => ()
		| TSDeleted => error "set_user_datum" 6008 
			[fn () => get_current_theory_name()]
		| TSLocked => fail "set_user_datum" 6037
			[fn () => get_current_theory_name()]
		| TSAncestor => fail "set_user_datum" 6071
			[fn () => get_current_theory_name()];

	val dummy = (user_data := s_enter key (ref ud) (!user_data);
		());
in
	notify_on_ksc (SetUserDatum (key,ud))
end);
=TEX
=SML
fun €get_user_datum› (thynm : string) (key : string) : USER_DATUM = (
let	val {user_data = user_data,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_user_datum";

	val res = s_lookup key (!user_data);
in
	case res of
	Value ud => (!ud)
	| _ => fail "get_user_datum" 12009 [(fn () => key),
		(fn () => thynm)]
end);
=TEX
\subsection{Definitional Mechanisms}
=SML
fun €simple_new_defn› (key : string, cnm : string, tm : TERM) : THM = (
let	val sideeffect = notify_before_ksc (SimpleNewDefn ((key, cnm, tm), 
		(icl'Kernel.icl'asm_rule mk_t)));
	val saved = icl'new_defn ([key], cnm, tm);
in
	notify_on_ksc (SimpleNewDefn ((key, cnm, tm), saved));
	saved
end
handle complaint => pass_on complaint "icl'new_defn" "simple_new_defn");
=TEX
=SML
fun €new_type_defn› (key : string, name : string, 
	typars : string list, defthm : THM): THM = (
let	val sideeffect = notify_before_ksc (NewTypeDefn ((key, name, typars, defthm), 
		(icl'Kernel.icl'asm_rule mk_t)));
	val saved = icl'new_type_defn ([key], name, typars, defthm);
in
	notify_on_ksc (NewTypeDefn ((key, name, typars, defthm), saved));
	saved
end
handle complaint => pass_on complaint "icl'new_type_defn" "new_type_defn");
=TEX
=SML
fun €new_specification› (keys : string list, ndef : int, defthm : THM) : THM = (
let	val sideeffect = notify_before_ksc (NewSpecification ((keys, ndef, defthm), 
		(icl'Kernel.icl'asm_rule mk_t)));
	val saved = icl'new_specification (keys, ndef, defthm);
in
	notify_on_ksc (NewSpecification ((keys, ndef, defthm), saved));
	saved
end
handle complaint => pass_on complaint "icl'new_specification" "new_specification");
=TEX
\subsection{Theory Access Functions}

\subsubsection{Accessing Individual Theorems}
=SML
fun €get_defn› (thynm : string) ( key : string) : THM = (
let	val {defn_dict = defn_dict,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_defn";

	val {inscope = inscope,...} = icl'get_theory_info thynm;

	val dummy = if not inscope 
		then fail "get_defn" 12010 [(fn () => thynm)]
		else ();

	val res = s_lookup key defn_dict;
in
	case res of
	Value thm => thm
	| _ => fail "get_defn" 12004 [(fn () => thynm),(fn () => key)]
end);
=TEX
=SML
fun €get_axiom› (thynm : string) ( key : string) : THM = (
let	val {axiom_dict = axiom_dict,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_axiom";

	val {inscope = inscope,...} = icl'get_theory_info thynm;

	val dummy = if not inscope 
		then fail "get_axiom" 12010 [(fn () => thynm)]
		else ();

	val res = s_lookup key axiom_dict;
in
	case res of
	Value thm => thm
	| _ => fail "get_axiom" 12005 [(fn () => thynm),(fn () => key)]
end);
=TEX
=SML
fun €get_thm› (thynm : string) ( key : string) : THM = (
let	val {thm_dict = thm_dict,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_thm";

	val {inscope = inscope,...} = icl'get_theory_info thynm;

	val dummy = if not inscope 
		then fail "get_thm" 12010 [(fn () => thynm)]
		else ();

	val res = s_lookup key thm_dict;
in
	case res of
	Value thm => thm
	| _ => fail "get_thm" 12006 [(fn () => thynm),(fn () => key)]
end);
=TEX
\subsubsection{Theory Names and Ancestry}
=SML
fun €theory_names› ((): unit) : string list = (
let	val hier = icl'get_hierarchy();
in
	map fst (hier drop 
		(fn (_,{status = status,...}) => status = TSDeleted))
end);
=TEX
In the following we are really only finding out whether a theory name exists when we do $icl'get\_theory$, but we pick out 
its parents just to start off the process that $all\_anc$ could do by itself.
=SML
fun €get_ancestors› (thynm : string) : string list = (
let	val hier = icl'get_hierarchy();

	fun aux ((nm:string), (sofar:string list)) = (
	if nm mem sofar
	then sofar
	else (
	let	val parents = case (s_lookup nm hier) of
			Value {contents={parents=pnts,...},...} => pnts
			| _ => fail "get_ancestors" 6035 [fn () => nm];
	in
		fold aux (map icl'get_theory_name parents) (nm :: sofar)
	end));
in
	aux 
	((if thynm = "-"
	then get_current_theory_name ()
	else thynm),
	[])
end);
=TEX
=SML
fun €is_theory_ancestor› (thy1 : string) (thy2 : string) : bool = (
let	val hier = icl'get_hierarchy();
	val nm1 = (if thy1 = "-"
		then get_current_theory_name ()
		else thy1);
	val nm2 = (if thy2 = "-"
		then get_current_theory_name ()
		else thy2);
	val sideeffect = case (s_lookup nm1 hier) of
		Value _ => ()
		| _ => fail "is_theory_ancestor" 6035 [fn () => nm1];

	fun aux (nm :string) = (
	(nm1 = nm) orelse
	(let	val parents = case (s_lookup nm hier) of
			Value {contents={parents=pnts,...},...} => pnts
			| _ => fail "is_theory_ancestor" 6035 [fn () => nm];
		val nmparents = map icl'get_theory_name parents
	in
		nm1 mem nmparents
		orelse
		(any nmparents aux)
	end));
in
	aux nm2
end);
=TEX
=SML
fun €get_parents› (thynm : string) : string list = (
let	val {parents = parents,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_parents";
in
	map icl'get_theory_name parents
end);
=TEX
=SML
fun €get_children› (thynm : string) : string list = (
let	val {children=children,...} = icl'get_theory_info thynm
		handle complaint =>
		pass_on complaint "icl'get_theory_info" "get_children";
in
	map icl'get_theory_name children
end);
=TEX
=SML
fun €get_descendants› (thynm : string) : string list = (
let	val hier = icl'get_hierarchy();

	val {children=children,...} = icl'get_theory_info thynm
		handle complaint =>
		pass_on complaint "icl'get_theory_info" "get_descendants";

	fun all_des (acc :: rest) sofar = (
		if acc mem sofar
		then all_des rest sofar
		else let val res = case (s_lookup acc hier) of
			Value {children=chn,...} => chn
			| _ => error "get_descendants" 6041 []
		in
			all_des (rest cup (map icl'get_theory_name res))
				(acc :: sofar)
		end
	) | all_des [] sofar = sofar;
in
	if thynm = "-"
	then all_des (map icl'get_theory_name children) [get_current_theory_name()]
	else all_des (map icl'get_theory_name children) [thynm]
end);
=TEX
\subsection{Accessing Theory Contents}
We want something to compact a dictionary of theorems:
=SML
fun €compact_tsd› ([] : THM S_DICT) : (string list * THM) list = []
| compact_tsd ((nm, thm) :: tsd_list) = (
let	fun compact (accnms: string list) (accthm: THM) (((nm1,thm1) :: rest): THM S_DICT) : 
			(string list * THM) list = (
		if dest_thm accthm = dest_thm thm1
		then compact (nm1 :: accnms) accthm rest
		else (((rev accnms), accthm) :: 
			compact [nm1] thm1 rest)
	) | compact accnms accthm [] = [((rev accnms), accthm)];
in
	compact [nm] thm tsd_list
end);
=TEX

=SML
fun €get_defns› (thynm : string) : (string list * THM) list = (
let	val {defn_dict = defn_dict,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_defns";

in
	compact_tsd defn_dict
end);
=TEX
=SML
fun €get_axioms› (thynm : string) : (string list * THM) list = (
let	val {axiom_dict = axiom_dict,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_axioms";

in
	compact_tsd axiom_dict
end);
=TEX
=SML
fun €get_thms› (thynm : string) : (string list * THM) list = (
let	val {thm_dict = thm_dict,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_thms";

in
	compact_tsd thm_dict
end);
=TEX
=SML
fun €get_consts› (thynm : string) : TERM list = (
let	val {con_env = con_env,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_consts";

	fun env_to_term (nm,{ty=ty,level=level}) = mk_const(nm,ty);
in
	map env_to_term con_env
end);
=TEX
=SML
fun €get_types› (thynm : string) : TYPE list = (
let	val {ty_env = ty_env,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_types";

	fun env_to_type (nm,{arity = arity,level=level}) = mk_ctype(nm,
		map (fn n => mk_vartype("'" ^ string_of_int n))(interval 1 arity));
in
	map env_to_type ty_env
end);
=TEX
=SML
fun €get_theory_status› (thynm : string) : THEORY_STATUS = (
let	val {status = status,...} = icl'get_theory_info thynm
		handle complaint =>
		pass_on complaint "icl'get_theory_info" "get_theory_status";
in
	status
end);
=TEX
\subsection{End of Structure}
=SML
end; (* structure KernelInterface *)

open KernelInterface;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


