=IGN
********************************************************************************
imp012.doc: this file is part of the PPHol system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the Interface to the Abstract Data Type $THM$}  %% Mandatory field
\def\TPPheadtitle{Implementation for the \cr Interface to the Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/IMP012}  %% Mandatory field
\def\SCCSversion{$Revision: 2.22 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2002/12/15 14:39:29 $ %
}}  %% Mandatory field
\TPPstatus{Draft}
%\TPPstatus{Approved}
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issues 1.1 to 1.17]
First drafts, leading up to desk check ID0083, and responses.
\item [Issue 2.1 (27th September 1991)]
Approved version of issue 1.17.

\item[Issue 2.2, \FormatDate{92/01/20} ] Updated to use new fonts.

\item[Issue 2.3 (23rd January 1992)]
$new\_axiom$, $simple\_new\_type\_defn$, $new\-\_type\-\_defn$
all changed to take lists of keys, rather than single ones.
\item [Issue 2.4 (1st April 1992)]
Changes required by CR0016.
\item [Issue 2.5 (13th April 1992)]
Changes due to CR0017.
\item [Issue 2.6(26th May 1992)]
Renamings from version 1.5 of DS/FMU/IED/WRK038.
\item [Issue 2.7,2.8 (31st July 1992)]
Added $do\_in\_theory$.
\item [Issue 2.9 (14th December 1992)]
Added $pending\_reset\_ksc\_functions$.
\item [Issue 2.10 (18th February 1993)]
$delete\_const$ will now delete constant at head of application.
\item [Issues 2.11-2.12 (16th August 1993)]
Added type, term and theorem compactification.
\item [Issue 2.13 (8th December 1993)]
Added $get\_theory\_names$.
\item [Issue 2.14 (9th August 2001)]
Implemented caching for {\it get\_defn}, {\it get\_thm} and {\it get\_axiom}.
\item[Issue 2.15]
Allowed for use of ordered efficient dictionaries in theory data type.
\item[Issue 2.16] Copyright and banner updates for open source release.
\item[Issue 2.17] PPHol-specific updates for open source release
\item[Issue 2.18] Removed unnecessary level of indirection from the {\it USER\_DATA} data type.
\item[Issues 2.19--2.21] Introduced checkpointing.
\item[Issue 2.22] Relaxed restrictions on checkpointing.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the interface to the abstract data type $THM$, in particular the theory management material.
This does not however include the
primitive and built-in inference rules, which may be found in
\cite{DS/FMU/IED/DTD007}.
This is called for in section 4 of \cite{DS/FMU/IED/HLD007}.
The high-level specification for the code is
given in \cite{DS/FMU/IED/SPC003}, \cite{DS/FMU/IED/SPC004} and \cite{DS/FMU/IED/SPC005}.
The design is in \cite{DS/FMU/IED/DTD012}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the interface to the abstract data type $THM$, in particular the theory management material.
The interface is to provide a user- and implementor- friendly
interface to the Kernel of the system, as the kernel is designed
with only correctness, functionality and compactness in mind.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD012},
and also requires those files indicated as preceding it in the
rel001 makefile.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\newpage
\section{THEORY MANAGEMENT OPERATIONS}
We first start the structure:
=SML
structure KernelInterface : KernelInterface = struct
=TEX
Then we open up the Kernel:
=SML
open icl'Kernel;
open SimpleDictionary;
=TEX
It is convenient to provide the following function ``out of order'':
=SML
fun €get_current_theory_name› (() : unit) : string = (
	icl'get_theory_name(icl'get_current_theory_name ())
);
=TEX
\subsection{Kernel State Change Material}
As any operation that changes the kernel state must notify
the list of functions managed by the functions $on\_kernel\_state\_change$,
we need to provide that material first.

First the type itself:
=SML
datatype €KERNEL_STATE_CHANGE›
		=	€OpenTheory› of string * ((string list) * (string list))
		|	€DeleteTheory› of string
		|	€NewTheory› of string
		|	€NewParent› of string * (string list)
		|	€LockTheory› of string
		|	€UnlockTheory› of string
		|	€DuplicateTheory› of string * string
		|	€SaveThm› of string * THM
		|	€ListSaveThm› of string list * THM
		|	€DeleteConst› of TERM
		|	€DeleteType› of string
		|	€DeleteAxiom› of string
		|	€DeleteThm› of string
		|	€NewAxiom› of ((string list * TERM)*THM)
		|	€NewConst› of string * TYPE
		|	€NewType› of string * int
		|	€SimpleNewDefn› of (string list * string * TERM) * THM
		|	€NewTypeDefn› of (string list * string * (string list) * THM) * THM
		|	€NewSpec› of (string list * int * THM) * THM
		|	€SetUserDatum› of string * USER_DATUM;

=TEX
The notifier functions are called $notify\_on\_ksc$ and
$notify\_before\_ksc$, and the list of
functions to be notified is hidden, named $on\_ksc\_functions$
and $before\_ksc\_functions$.
=SML
local
	val €on_ksc_functions› : ((KERNEL_STATE_CHANGE -> unit) list) ref = ref [];
	val €before_ksc_functions› : ((KERNEL_STATE_CHANGE -> unit) list) ref = ref [];
in
	fun €on_kernel_state_change› (to_notify : KERNEL_STATE_CHANGE -> unit) 
		: unit = (
		on_ksc_functions := (!on_ksc_functions) @ [to_notify]
	);

	fun €notify_on_ksc› (ksc : KERNEL_STATE_CHANGE) : unit = (
		map (fn f => f ksc) (!on_ksc_functions);
		()
	);

	fun €before_kernel_state_change› (to_notify : KERNEL_STATE_CHANGE -> unit) 
		: unit = (
		before_ksc_functions := (!before_ksc_functions) @ [to_notify]
	);

	fun €notify_before_ksc› (ksc : KERNEL_STATE_CHANGE) : unit = (
		map (fn f => f ksc) (!before_ksc_functions);
		()
	);

fun €pending_reset_ksc_functions› () : unit -> unit =(
let	val f1 = (!on_ksc_functions);
	val f2 = (!before_ksc_functions);
in
	fn () => (
	on_ksc_functions := f1;
	before_ksc_functions := f2;
	()
	)
end);
=TEX
\subsection{Temporary Working in Other Theories}
Note the multiple attempts to catch errors 
that are not from $fail$ or $error$.
=SML
fun €do_in_theory› (thy: string) (f : 'a -> 'b) (arg : 'a) : 'b = (
let	val curr_theory = get_current_theory_name();
	val was_before_ksc_functions = (!before_ksc_functions);
	fun stop_theory_change (OpenTheory _: KERNEL_STATE_CHANGE): unit = (
		before_ksc_functions := was_before_ksc_functions;

		error "do_in_theory" 12011 []
	) | stop_theory_change (NewTheory _) = (
		before_ksc_functions := was_before_ksc_functions;
		error "do_in_theory" 12011 []
	) | stop_theory_change (DeleteTheory _) = (
		before_ksc_functions := was_before_ksc_functions;
		error "do_in_theory" 12011 []
	) | stop_theory_change _ = ();

in
	let	val side = icl'open_theory thy;
		val side = before_kernel_state_change stop_theory_change;
		val result = f arg;
		val side = (before_ksc_functions := was_before_ksc_functions);
		val side = (icl'open_theory curr_theory
			handle (Error _) =>
			error "do_in_theory" 12013 []
			handle (Fail _) =>
			error "do_in_theory" 12013 []
			);
	in
		result
	end
	handle ex => (
		before_ksc_functions := was_before_ksc_functions;
		(icl'open_theory curr_theory
			handle (Error _) =>
			error "do_in_theory" 12013 []
			handle (Fail _) =>
			error "do_in_theory" 12013 []
		);
		raise ex)
	handle ex => (case ex of
		(Fail _) => raise ex
		| (Error _) => raise ex
		| _ => (
		before_ksc_functions := was_before_ksc_functions;
		icl'open_theory curr_theory; 
		raise ex))
	handle ex => (case ex of
		(Fail _) => raise ex
		| (Error _) => raise ex
		| _ => (
		before_ksc_functions := was_before_ksc_functions;
		icl'open_theory curr_theory; 
		raise ex))
	handle ex => (case ex of
		(Fail _) => raise ex
		| (Error _) => raise ex
		| _ => (
		before_ksc_functions := was_before_ksc_functions;
		icl'open_theory curr_theory; 
		raise ex))
	end);

=TEX
=SML
end; (* local *)
=TEX
\subsection{Operations on Theory Attributes}
These are generally straight forward:
=SML
fun €open_theory› (nm : string) : unit = (
let	val sideeffect = notify_before_ksc (OpenTheory (nm, ([],[])));
	val ot_res = icl'open_theory nm;
	val ot_res' = (map icl'get_theory_name ** map icl'get_theory_name) ot_res;
in
	notify_on_ksc (OpenTheory (nm, ot_res'));
	()
end
handle complaint => pass_on complaint "icl'open_theory" "open_theory");
=TEX
=SML
fun €delete_theory› (nm : string) : unit = (
let	val sideeffect = notify_before_ksc (DeleteTheory nm);
	val dummy = icl'delete_theory nm;
in
	notify_on_ksc (DeleteTheory nm);
	()
end
handle complaint => pass_on complaint "icl'delete_theory" "delete_theory");
=TEX
=SML
fun €new_theory› (nm : string) : unit = (
let	val sideeffect = notify_before_ksc (NewTheory nm);
	val dummy = (icl'new_theory nm; icl'open_theory nm);
in
	notify_on_ksc (NewTheory nm);
	()
end
handle complaint => pass_on complaint "icl'new_theory" "new_theory");
=TEX
=SML
fun €new_parent› (nm : string) : unit = (
let	val sideeffect = notify_before_ksc (NewParent (nm, []));
	val np_res = icl'new_parent nm;
	val np_res' = map icl'get_theory_name np_res;
in
	notify_on_ksc (NewParent (nm, np_res'));
	()
end
handle complaint => pass_on complaint "icl'new_parent" "new_parent");
=TEX
=SML
fun €lock_theory› (nm : string) : unit = (
let	val sideeffect = notify_before_ksc (LockTheory nm);
	val dummy = icl'lock_theory nm;
in
	notify_on_ksc (LockTheory nm);
	()
end
handle complaint => pass_on complaint "icl'lock_theory" "lock_theory");
=TEX
=SML
fun €unlock_theory› (nm : string) : unit = (
let	val sideeffect = notify_before_ksc (UnlockTheory nm);
	val dummy = icl'unlock_theory nm;
in
	notify_on_ksc (UnlockTheory nm);
	()
end
handle complaint => pass_on complaint "icl'unlock_theory" "unlock_theory");
=TEX
=SML
fun €duplicate_theory› (fromnm : string, tonm : string) : unit = (
let	val sideeffect = notify_before_ksc (DuplicateTheory (fromnm, ""));
	val dummy = icl'duplicate_theory fromnm tonm;
in
	notify_on_ksc (DuplicateTheory (fromnm, tonm));
	()
end
handle complaint => pass_on complaint "icl'duplicate_theory" "duplicate_theory");
=TEX
\subsection{Compactification}
This material is required in $save\_thm$ and thereafter and so is given next.
=TEX
Throughout the following we consider type variables just as a distinguished
sort of nullary constructors. Constructors in general are represented
as pairs: the name and its arity. The arity is required because deletion
of types allows the user to define the same constructor with different
arities at different times and we do not wish to have the extra complexity
of restructuring the database when a type is deleted. The arities are
not actually used in the algorithms except when two constructors are
compared. We may therefore adopt the convention of distinguishing type
variables from nullary constructors by pretending that their arity is $-1$.
From now on, the discussion of the algorithm will usually use the term
``constructor'' to include both type variables and constructors together
with their arities. The following ML type definition reflects this convention.
=SML
type €CON› = string * int;
=TEX

We use search trees to represent partial functions from types to
elements of type $'a$. The search trees are arbitrarily branching finite
trees whose edges are labelled with constructors and whose nodes are optionally
labelled with values of type $'a$. 

For any type, $\tau$ consider the list, $c\sb{\tau}$ of constructors
one encounters in a post-order (a.k.a. reverse Polish) traversal of the
type. Since we consider constructors with the same name but different
arities to be different, the function sending $\tau$ to $c\sb{\tau}$ is
an injection (indeed, there is an obvious ``parsing'' function which is
a left inverse to it). To look up the value associated with $\tau$ in
a search tree, $T$, one looks for a path starting at the root of the tree
whose sequence of edge labels is $c\sb{\tau}$; if there is such a path,
then it ends at some node of the tree and the value associated
with $\tau$ is the label on that node, if any; if there is no label, then
$\tau$ is not in the domain of the function represented by $T$;
in fact, the trees we will use are so constructed that unlabelled nodes
only appear in positions which cannot be reached by such a path, so that
there always will be a label on the node if the path to it exists.

We will frequently need to carry out {\it in situ} updates of
the children of a node. We therefore use the following ML data type to
represent the trees.

=SML
datatype '_a €S_TREE› = €Node› of ('_a OPT * (CON * '_a S_TREE) list) ref;
=TEX
Given a constructor and a reference to a node, $follow$ finds the
edge leading out of the node labelled with the constructor (creating it if
necessary) and updates the reference to refer to the node which that
edge points to.
=SML
fun	€follow›
	(c : CON)
	(r as (ref (Node (n as (ref (lab, nodes))))) : '_a S_TREE ref)
	: unit = (
	(	r := lassoc3 nodes c
	)	handle	Fail _ =>
	let	val new_node = Node (ref(Nil, []));
	in	n := (lab, (c, new_node) :: nodes);
		r := new_node
	end
);
=TEX
Mainly for clarity of exposition and for testing purposes, we have formulated
the search trees to store an arbitrary imperative type. In practice,
this type will be the type $TYPE$ of HOL types.

Now we define the function to establish a value in a search tree.  In
essence, by ``establishing'' a value in a tree, we mean the operation,
parameterised by a type, $\tau$, and a value, $v$, which computes the
value associated with $\tau$ in a search tree and returns that value if
there is one, and otherwise, installs $\tau \mapsto v$ in the tree and
returns $v$. In fact, we wish to install simultaneously values to
be associated with $\tau$ and all its subtypes, and so,
the operation is parameterised by a function
which computes the values to be installed from a list of values
retrieved from the tree and a constructor. In practice, this function
will be essentially the constructor function $mk\_ctype$. For testing purposes, we
cater for an arbitrary function so that the internals of the algorithm can
be monitored more easily.

The work of the function, $establish$ is done by an auxiliary function
$aux$, which has a parameter which is a stack recording the
nodes in the tree which have been reached for each of the super-types
of the type, $\tau$, we are working on. Initially this is empty.  The
root of the tree in which we are establishing values is supplied as a
parameter.  As we pass through a constructor, a new entry
referencing the root is pushed onto the stack to allow each recursive
invocation of $establish$ to push forward the traversal for $\tau$ as
well as the component type it is working on, so that when the component
types have been processed by the recursive invocations, we are in the
right position to find, or install, the value for $\tau$ in the tree.
=SML
fun €establish›
	(mk_v : (CON * '_a list) -> '_a) (root : '_a S_TREE) (ty : TYPE) : '_a = (
let	fun aux (stk : '_a S_TREE ref list) (ty : TYPE) : '_a = (
		let	val (con, args) = (
				case dest_simple_type ty of
					Vartype n => ((n, ~1), [])
				|	Ctype(n, args) => ((n, length args), args)
			);
			val newpath = ref root;
			val newstk = newpath :: stk;
			val rs = map (aux newstk) args;
			val side_effect = map (follow con) newstk;
			val Node(n as (ref(v, nodes))) = !newpath;
		in	case v of
				Value x => x
			|	Nil => 
					let	val res = mk_v(con, rs);
					in	n := (Value res, nodes);
						res
					end
		end
	);
in	aux [] ty
end
);
=TEX
=SML
val compactification_cache : TYPE S_TREE = Node(ref (Nil, []));
=TEX
N.b. the following assumes a check that the cache is an acyclic
graph, and might loop, if not; this should never happen in practice
given the way that the trees are constructed by $establish$ and
by $set\_compatification\_cache$.
The algorithm only delivers the types stored in the leaf nodes of the tree.
This is because types stored at internal nodes are necessarily duplicated
elsewhere in the tree.
=SML
fun €get_compactification_cache› () : TYPE list = (
	let	fun aux (Node (ref(_, (cts as (_ :: _))))) = (
			flat (map (aux o snd) cts)
		) | aux (Node (ref(Value ty, []))) = [ty]
		|   aux (Node (ref(Nil, []))) = [];	(* shouldn't happen *)
	in	aux compactification_cache
	end
);
=TEX
=SML
fun €mk_ty› ((n, i), tys) = (
	if i = ~1
	then mk_vartype n
	else mk_ctype(n, tys)
);
=TEX
=SML
val €compact_type› : TYPE -> TYPE = establish mk_ty compactification_cache;
=TEX
=SML
fun €clear_compactification_cache› () : unit = (
	let	val Node rv = compactification_cache;
	in	rv := (Nil, [])
	end
);
=TEX
=SML
fun €set_compactification_cache› (tys : TYPE list) : unit = (
	map compact_type tys; ()
);
=TEX
=SML
fun €compact_term› (tm : TERM) = (
	case dest_simple_term tm of
		App(f, a) => mk_app(compact_term f, compact_term a)
	|	Const (n, ty) => mk_const (n, compact_type ty)
	|	Var (n, ty) => mk_var(n, compact_type ty)
	|	SimpleÃ(v, b) => mk_simple_Ã(compact_term v, compact_term b)
);
=TEX
Perhaps, the following should profile the inference it does. At the moment
it does not. It assumes two things about the implementation of the primitive
rules: {\em(i)} $¥\_intro$ must construct the conclusion of its result theorem
using the argument rather than the eliminated assumption (this is virtually
guaranteed by its specification); and, {\em(ii)}, $subst\_rule$ should
take the conclusion of its result theorem to be the template argument
if the list of substitutions is empty (the current implementation does
indeed do this).
=SML
fun €compact_thm› (thm : THM) : THM = (
	let	val (asms, conc) = dest_thm thm;
		val newasms = map compact_term asms;
		val newconc = compact_term conc;
		val thm2 = fold (uncurry icl'¥_intro) newasms thm;
		fun aux [] th = th
		|   aux (asm :: more) th = aux more (icl'¥_elim th (icl'asm_rule asm));
		val thm3 = aux newasms thm2;
		val thm4 = icl'subst_rule [] newconc thm3;
	in	thm4
	end	handle Fail _ => thm
);
=TEX
=SML
val €compactification_mask› : int ref = ref 0;
val side_effect =
	(new_int_control{name = "compactification_mask",
		check = fun_true,
		control=compactification_mask,
		default = (fn () => 0)}) handle Fail _ => ();
=TEX
=SML
fun €compactification_mask_bit› (i : int) : bool = (
	(!compactification_mask div i) mod 2 = 1
);
=TEX
=SML
fun €cond_compact› (i : int) (f : 'a -> 'a) (x : 'a) : 'a = (
	if	compactification_mask_bit i
	then	x
	else	f x
);
=TEX
\subsection{Operations on Theory Contents}

$dest\_thm$ passes through without problem.
=SML
val €asms› : THM -> TERM list = fst o dest_thm;
val €concl› : THM -> TERM = snd o dest_thm;
=TEX
=SML
fun €thm_theory› (thm : THM) : string = (
let	val {theory = {name = iname,...},...} = icl'dest_thm thm;
in
	icl'get_theory_name iname
	handle complaint => 
	divert complaint "icl'get_theory_name" "thm_theory" 12007 
		[fn () => string_of_thm thm,fn () => string_of_int iname]	
end);
=TEX
=SML
fun €save_thm› (key : string, thm : THM) : THM = (
let	val sideeffect = notify_before_ksc (SaveThm (key, thm));
	val thm' = cond_compact 16 compact_thm thm;
	val saved = icl'list_save_thm ([key], thm');
in
	notify_on_ksc (SaveThm (key, thm'));
	saved
end
handle complaint => pass_on complaint "icl'list_save_thm" "save_thm");
=TEX
=SML
fun €list_save_thm› (keys : string list, thm : THM) : THM = (
let	val sideeffect = notify_before_ksc (ListSaveThm (keys, thm));
	val thm' = cond_compact 16 compact_thm thm;
	val saved = icl'list_save_thm (keys, thm');
in
	notify_on_ksc (ListSaveThm (keys, thm'));
	saved
end
handle complaint => pass_on complaint "icl'list_save_thm" "list_save_thm");
=TEX
=SML
fun €delete_thm› (key : string) : THM = (
let	val sideeffect = notify_before_ksc (DeleteThm key);
	val thm = icl'delete_thm key;
in
	notify_on_ksc (DeleteThm key);
	thm
end
handle complaint => pass_on complaint "icl'delete_thm" "delete_thm");
=TEX
Given a level, give a list of the levels that need deleting.
We presume a well-formed $del\_levels$ list.
=SML
fun €deleted_levels› (level : int) : int list = (
let	val {del_levels = del_levels,current_level = current_level, ...} = icl'get_theory "-";

	fun get_levels llevel ((lb,ub) :: lst) = (
		if llevel < lb
		then (interval llevel (lb -1) @
			get_levels (ub+1) lst)
		else (get_levels (ub+1) lst)
	) | get_levels llevel [] = interval llevel current_level;

in
	get_levels level del_levels
end);
=TEX
For the following $delete\_$ functions we need an auxiliary ``delete to level'' function.
This delete everything whose level is greater than or equal to the level supplied
as an argument.
This will find out what is to be deleted, and do all the
kernel and, if {\it do\_warn} is true, user notification required.
If {\it do\_warn} is false, the kernel notifications are done, but there is
no feedback to the user.

=SML
fun €delete_to_level› (do_warn : bool)
	(caller : string) (target : string) (level : int) : unit = (
let	val dummy = case (get_current_theory_status()) of
		TSNormal => ()
		| TSDeleted => error caller 6008 
			[fn () => get_current_theory_name()]
		| TSLocked => fail caller 6037
			[fn () => get_current_theory_name()]
		| TSAncestor => fail caller 6071
			[fn () => get_current_theory_name()];

	val {children = children,...} = icl'get_theory_info "-";

	val dummy = if children <> []
		then fail caller 6076 [fn () => get_current_theory_name()]
		else ();

	val {con_env = oe_con_env,ty_env = oe_ty_env,
		axiom_dict = oe_axiom_dict, thm_dict = oe_thm_dict,
		defn_dict = oe_defn_dict,...} = icl'get_theory "-";

	val con_env = oe_flatten oe_con_env;

	val ty_env = oe_flatten oe_ty_env;

	val axiom_dict = oe_flatten oe_axiom_dict;

	val thm_dict = oe_flatten oe_thm_dict;

	val defn_dict = oe_flatten oe_defn_dict;

	val (del_con,del_lev1) = split (map (fn (name,{ty = ty,level = lev,...}) => 
			((name, ty),lev))
		(con_env drop (fn (_,{level = lev,...}) => lev < level)));

	val (del_type,del_lev2) = split(map (fn (name,{level = lev,...}) => (name,lev))
		(ty_env drop (fn (_,{level = lev,...}) => lev < level)));

	val del_thms = map (fn (key,_) => key)
		(thm_dict drop (fn (_,thm) => 
			let val {level = lev,...} = icl'dest_thm thm
			in lev < level end));

	val (del_axioms, del_lev3) = split(map (fn (key,thm) => (key,
			let val {level = lev,...} = icl'dest_thm thm
			in lev end))
		(axiom_dict drop (fn (_,thm) => 
			let val {level = lev,...} = icl'dest_thm thm
			in lev < level end)));

	val (del_defns, del_lev4) = split(map (fn (key,thm) => (key,
			let val {level = lev,...} = icl'dest_thm thm
			in lev end))
		(defn_dict drop (fn (_,thm) => 
			let val {level = lev,...} = icl'dest_thm thm
			in lev < level end)));

	val I = Combinators.I;

	val to_be_d = (
		format_list Combinators.I 
		(flat [
		if is_nil del_con
		then []
		else [get_error_message 12100 
			[if length del_con = 1 then "" else "s"] ^ 
			(format_list fst del_con ", ")],
		if is_nil del_type
		then []
		else [get_error_message 12101 
			[if length del_type = 1 then "" else "s"] ^ 
			(format_list I del_type ", ")],
		if is_nil del_thms
		then []
		else [get_error_message 12102 
			[if length del_thms = 1 then "" else "s"] ^ 
			(format_list I del_thms ", ")],
		if is_nil del_axioms
		then []
		else [get_error_message 12103 
			[if length del_axioms = 1 then "" else "s"] ^ 
			(format_list I del_axioms ", ")],
		if is_nil del_defns
		then []
		else [get_error_message 12104 
			[if length del_defns = 1 then "" else "s"] ^ 
			(format_list I del_defns ", ")]])
		) "; ";
(*
=TEX
We now ask the interactive user whether he wishes everything
necessary to be deleted.
=SML
*)
	val dummy =
		if	do_warn
		then	warn caller 12012 [(fn () => target),(fn () => to_be_d)]
		else	();
(*
=TEX
We now have permission to proceed:
=SML
*)
	val dl = list_cup[del_lev1, del_lev2, del_lev3, del_lev4];

	val dummy = (map (fn xt => notify_before_ksc (DeleteConst (mk_const xt))) del_con;
		map (fn t => notify_before_ksc (DeleteType t)) del_type;
		map (fn ax => notify_before_ksc (DeleteAxiom ax)) del_axioms;
		map (fn thm => notify_before_ksc (DeleteThm thm)) del_thms;
		());

	val dummy = map icl'delete_thm del_thms;

	val dummy = map (fn x => icl'delete_extension ()) dl;
in
	map (fn xt => notify_on_ksc (DeleteConst (mk_const xt))) del_con;
	map (fn t => notify_on_ksc (DeleteType t)) del_type;
	map (fn ax => notify_on_ksc (DeleteAxiom ax)) del_axioms;
	map (fn thm => notify_on_ksc (DeleteThm thm)) del_thms;
	()
end);
=TEX
We can now give the deletion functions:
=SML
fun €delete_const› (icnt : TERM) : unit = (
let	val cnt = fst(strip_app icnt);
	val (cnm, cty) = dest_const cnt
		handle complaint =>
		term_fail "delete_const" 12014 [icnt];
	val {con_env = con_env,...} = icl'get_theory "-";

	val {level = level, ty = ty} = force_value(oe_lookup cnm con_env)
		handle complaint =>
		divert complaint "force_value" "delete_const" 12001 
			[fn () => get_current_theory_name (),
			 fn () => cnm];

	val dummy = if not(is_type_instance ty cty andalso 
			is_type_instance cty ty)
		then fail "delete_const" 12001 
			[fn () => get_current_theory_name (),
			 fn () => cnm]
		else ();
in
	delete_to_level true "delete_const" cnm level
end);
=TEX
=SML
fun €delete_type› (tnm : string) : unit = (
let	val {ty_env = ty_env,...} = icl'get_theory "-";

	val {level = level, ...} = force_value(oe_lookup tnm ty_env)
		handle complaint =>
		divert complaint "force_value" "delete_type" 12002 
			[fn () => get_current_theory_name (),
			 fn () => tnm];
in
	delete_to_level true "delete_type" tnm level
end);
=TEX
=SML
fun €delete_axiom› (anm : string) : unit = (
let	val {axiom_dict = axiom_dict,...} = icl'get_theory "-";

	val ax = force_value(oe_lookup anm axiom_dict)
		handle complaint =>
		divert complaint "force_value" "delete_axiom" 12003
			[fn () => get_current_theory_name (),
			 fn () => anm];

	val {level = level,...} = icl'dest_thm ax;
in
	delete_to_level true "delete_axiom" anm level
end);
=TEX
=SML
fun €new_axiom› (keys : string list, tm : TERM) : THM = (
let	val sideeffect = notify_before_ksc (NewAxiom ((keys, tm),
		(icl'Kernel.icl'asm_rule mk_t)));
	val tm' = cond_compact 1 compact_term tm;
	val saved = icl'new_axiom (keys, tm');
in
	notify_on_ksc (NewAxiom ((keys, tm'),saved));
	saved
end
handle complaint => pass_on complaint "icl'new_axiom" "new_axiom");
=TEX
=SML
fun €new_const› (cnm : string, ty : TYPE) : TERM = (
let	val sideeffect = notify_before_ksc (NewConst (cnm, ty));
	val ty' = cond_compact 4 compact_type ty;
	val saved = icl'new_const (cnm, ty');
in
	notify_on_ksc (NewConst (cnm, ty'));
	saved
end
handle complaint => pass_on complaint "icl'new_const" "new_const");
=TEX
=SML
fun €new_type› (cnm : string, arity : int) : TYPE = (
let	val sideeffect = notify_before_ksc (NewType (cnm, arity));
	val saved = icl'new_type (cnm, arity);
in
	notify_on_ksc (NewType (cnm, arity));
	saved
end
handle complaint => pass_on complaint "icl'new_type" "new_type");
=TEX
=SML
fun €set_user_datum› (key : string, ud : USER_DATUM) : unit = (
let	val sideeffect = notify_before_ksc (SetUserDatum (key,ud));
	val {user_data = user_data,...} = icl'get_theory "-";

	val dummy = case (get_current_theory_status()) of
		TSNormal => ()
		| TSDeleted => error "set_user_datum" 6008 
			[fn () => get_current_theory_name()]
		| TSLocked => fail "set_user_datum" 6037
			[fn () => get_current_theory_name()]
		| TSAncestor => fail "set_user_datum" 6071
			[fn () => get_current_theory_name()];

	val dummy = (user_data := s_enter key ud (!user_data);
		());
in
	notify_on_ksc (SetUserDatum (key,ud))
end);
=TEX
=SML
fun €get_user_datum› (thynm : string) (key : string) : USER_DATUM = (
let	val {user_data = user_data,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_user_datum";

	val res = s_lookup key (!user_data);
in
	case res of
	Value ud => ud
	| _ => fail "get_user_datum" 12009 [(fn () => key),
		(fn () => thynm)]
end);
=TEX
\subsection{Definitional Mechanisms}
=SML
fun €simple_new_defn› (keys : string list, cnm : string, tm : TERM) : THM = (
let	val sideeffect = notify_before_ksc (SimpleNewDefn ((keys, cnm, tm), 
		(icl'Kernel.icl'asm_rule mk_t)));
	val tm' = cond_compact 32 compact_term tm;
	val saved = icl'new_defn (keys, cnm, tm');
in
	notify_on_ksc (SimpleNewDefn ((keys, cnm, tm'), saved));
	saved
end
handle complaint => pass_on complaint "icl'new_defn" "simple_new_defn");
=TEX
=SML
fun €new_type_defn› (keys : string list, name : string, 
	typars : string list, defthm : THM): THM = (
let	val sideeffect = notify_before_ksc (NewTypeDefn ((keys, name, typars, defthm), 
		(icl'Kernel.icl'asm_rule mk_t)));
	val defthm' = cond_compact 4 compact_thm defthm;
	val saved = icl'new_type_defn (keys, name, typars, defthm');
in
	notify_on_ksc (NewTypeDefn ((keys, name, typars, defthm'), saved));
	saved
end
handle complaint => pass_on complaint "icl'new_type_defn" "new_type_defn");
=TEX
=SML
fun €new_spec› (keys : string list, ndef : int, defthm : THM) : THM = (
let	val sideeffect = notify_before_ksc (NewSpec ((keys, ndef, defthm), 
		(icl'Kernel.icl'asm_rule mk_t)));
	val defthm' = cond_compact 8 compact_thm defthm;
	val saved = icl'new_spec (keys, ndef, defthm');
in
	notify_on_ksc (NewSpec ((keys, ndef, defthm'), saved));
	saved
end
handle complaint => pass_on complaint "icl'new_spec" "new_spec");
=TEX
\subsection{Theory Access Functions}

\subsubsection{Accessing Individual Theorems}
The functions in this section become time-critical in applications like
{\ProductZ} where definition and axiom schemata are implemented by
demand-driven introduction of types and constants. To make them efficient
the definitions, theorems and axioms are cached. This is considered to
be worthwhile even now that efficient dictionaries are used within the
individual theories, since the current theory may have many ancestors and
the average number of types and constants etc. in each ancestor is likely
to be fairly small.


If the theorem being sought
is not in the cache, the following uncached versions of the functions are used.
=SML
fun €uncached_get_defn› (thynm : string) ( key : string) : THM = (
let	val {defn_dict = defn_dict,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_defn";

	val {inscope = inscope,...} = icl'get_theory_info thynm;

	val dummy = if not inscope 
		then fail "get_defn" 12010 [(fn () => thynm)]
		else ();

	val res = oe_lookup key defn_dict;
in
	case res of
	Value thm => thm
	| _ => fail "get_defn" 12004 [(fn () => thynm),(fn () => key)]
end);
=TEX
=SML
fun €uncached_get_axiom› (thynm : string) ( key : string) : THM = (
let	val {axiom_dict = axiom_dict,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_axiom";

	val {inscope = inscope,...} = icl'get_theory_info thynm;

	val dummy = if not inscope 
		then fail "get_axiom" 12010 [(fn () => thynm)]
		else ();

	val res = oe_lookup key axiom_dict;
in
	case res of
	Value thm => thm
	| _ => fail "get_axiom" 12005 [(fn () => thynm),(fn () => key)]
end);
=TEX
=SML
fun €uncached_get_thm› (thynm : string) ( key : string) : THM = (
let	val {thm_dict = thm_dict,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_thm";

	val {inscope = inscope,...} = icl'get_theory_info thynm;

	val dummy = if not inscope 
		then fail "get_thm" 12010 [(fn () => thynm)]
		else ();

	val res = oe_lookup key thm_dict;
in
	case res of
	Value thm => thm
	| _ => fail "get_thm" 12006 [(fn () => thynm),(fn () => key)]
end);
=TEX
Now for the caching. Because the signatures of the three {\it get\_XXX} functions
are the same, we can do most of the work generically. The caches are efficient
dictionaries indexed by the definition, theorem or axiom keys whose entries
are simple look-up tables mapping theory names to the definitions, theorems
or axioms in question. In typical use, it will be rare for the same key to
be used for a definition (or whatever) in two different theories, so the simple
look-up tables will usually have just one entry.
=SML
type €THM_CACHE› = THM S_DICT E_DICT;
type €GETTER› = string -> string -> THM;
=TEX
{\it cached\_get} does the look-up. It is parameterised by a {\it GETTER}, which
will be the uncached version of the look-up function. The uncached getter is
intended to have made all necessary checks on the validity of the theorem it returns.
However, the cached copies of the theorems could be invalid because of an
unnotified change of theory, or because a constant or a type has been deleted. In this
case, the entry for this key is cleared from the cache and we try again --- the
uncached getter function will then either fail or, in the case of a definition that
has been deleted and then remade, fix the problem.
This case is expected to be rare, so we do not optimise for it.
=SML
fun €cached_get› (ug : GETTER) (cache : THM_CACHE ref) : GETTER = (fn thynm => fn key =>
	let	fun cache_it sd = (
			let	val thm = ug thynm key;
				val sd' = (thynm, thm) :: sd;
				val cache' = e_enter key sd' (!cache);
			in	cache := cache'; thm
			end
		);
		fun uncache_and_retry() = (
			cache := e_delete key (!cache);
			cached_get ug cache thynm key 
		);
	in	case e_lookup key (!cache) of
			Value sd => (
				case s_lookup thynm sd of
					Nil => cache_it sd
				|	Value thm =>
						if	valid_thm thm
						then	thm
						else	uncache_and_retry()
		) |	Nil => cache_it []
	end
);
=TEX
The cache is rebuilt when an {\it open\_theory} is notified.
Based on the (currently true) assumption that {\it valid\_thm} is a fast function
the cache is rebuilt simply by removing theorems that are no longer valid.
Note that according to the above algorithm, this is not functionally necessary,
but it will reclaim space.
=SML
fun €rebuild_cache› (cache : THM_CACHE) : THM_CACHE = (
	let	val entries = e_flatten cache;
		val unwanted1 = not o valid_thm o snd;
		val unwanted2 = is_nil o snd;
		val entries' = map (fn (k, e) => (k, e drop unwanted1)) entries drop unwanted2;
	in	list_e_merge initial_e_dict entries'
	end
);
=TEX
Now we can define the caches and the notify function:
=SML
val €get_defn_cache› : THM_CACHE ref = ref initial_e_dict;
val €get_axiom_cache› : THM_CACHE ref = ref initial_e_dict;
val €get_thm_cache› : THM_CACHE ref = ref initial_e_dict;
=TEX
=SML
fun €rebuild_caches_on_open_theory› (OpenTheory _) = (
	get_defn_cache := rebuild_cache (!get_defn_cache);
	get_axiom_cache := rebuild_cache (!get_axiom_cache);
	get_thm_cache := rebuild_cache (!get_thm_cache)
) | rebuild_caches_on_open_theory _ = ();

val _ = on_kernel_state_change rebuild_caches_on_open_theory;
=TEX
Finally, we can define the interface functions:
=SML
val €get_defn› : string -> string -> THM = cached_get uncached_get_defn get_defn_cache;
val €get_axiom› : string -> string -> THM = cached_get uncached_get_axiom get_axiom_cache;
val €get_thm› : string -> string -> THM = cached_get uncached_get_thm get_thm_cache;
=TEX
\subsubsection{Theory Names and Ancestry}
=SML
fun €get_theory_names› ((): unit) : string list = (
let	val hier = icl'get_hierarchy();
in
	map fst (hier drop 
		(fn (_,{status = status,...}) => status = TSDeleted))
end);
fun €theory_names› ((): unit) : string list = get_theory_names();
=TEX
In the following we are really only finding out whether a theory name exists when we do $icl'get\_theory$, but we pick out 
its parents just to start off the process that $all\_anc$ could do by itself.
=SML
fun €get_ancestors› (thynm : string) : string list = (
let	val hier = icl'get_hierarchy();

	fun aux ((nm:string), (sofar:string list)) = (
	if nm mem sofar
	then sofar
	else (
	let	val parents = case (s_lookup nm hier) of
			Value {contents={parents=pnts,...},...} => pnts
			| _ => fail "get_ancestors" 6035 [fn () => nm];
	in
		fold aux (map icl'get_theory_name parents) (nm :: sofar)
	end));
in
	aux 
	((if thynm = "-"
	then get_current_theory_name ()
	else thynm),
	[])
end);
=TEX
=SML
fun €is_theory_ancestor› (thy1 : string) (thy2 : string) : bool = (
let	val hier = icl'get_hierarchy();
	val nm1 = (if thy1 = "-"
		then get_current_theory_name ()
		else thy1);
	val nm2 = (if thy2 = "-"
		then get_current_theory_name ()
		else thy2);
	val sideeffect = case (s_lookup nm1 hier) of
		Value _ => ()
		| _ => fail "is_theory_ancestor" 6035 [fn () => nm1];

	fun aux (nm :string) = (
	(nm1 = nm) orelse
	(let	val parents = case (s_lookup nm hier) of
			Value {contents={parents=pnts,...},...} => pnts
			| _ => fail "is_theory_ancestor" 6035 [fn () => nm];
		val nmparents = map icl'get_theory_name parents
	in
		nm1 mem nmparents
		orelse
		(any nmparents aux)
	end));
in
	aux nm2
end);
=TEX
=SML
fun €get_parents› (thynm : string) : string list = (
let	val {parents = parents,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_parents";
in
	map icl'get_theory_name parents
end);
=TEX
=SML
fun €get_children› (thynm : string) : string list = (
let	val {children=children,...} = icl'get_theory_info thynm
		handle complaint =>
		pass_on complaint "icl'get_theory_info" "get_children";
in
	map icl'get_theory_name children
end);
=TEX
=SML
fun €get_descendants› (thynm : string) : string list = (
let	val hier = icl'get_hierarchy();

	val {children=children,...} = icl'get_theory_info thynm
		handle complaint =>
		pass_on complaint "icl'get_theory_info" "get_descendants";

	fun all_des (acc :: rest) sofar = (
		if acc mem sofar
		then all_des rest sofar
		else let val res = case (s_lookup acc hier) of
			Value {children=chn,...} => chn
			| _ => error "get_descendants" 6041 []
		in
			all_des (rest cup (map icl'get_theory_name res))
				(acc :: sofar)
		end
	) | all_des [] sofar = sofar;
in
	if thynm = "-"
	then all_des (map icl'get_theory_name children) [get_current_theory_name()]
	else all_des (map icl'get_theory_name children) [thynm]
end);
=TEX
\subsection{Accessing Theory Contents}
We want something to compact a dictionary of theorems:
=SML
fun €compact_tsd› ([] : THM S_DICT) : (string list * THM) list = []
| compact_tsd ((nm, thm) :: tsd_list) = (
let	fun compact (accnms: string list) (accthm: THM) 
			(((nm1,thm1) :: rest): THM S_DICT) : 
			(string list * THM) list = (
		if accthm =|- thm1
		then compact (nm1 :: accnms) accthm rest
		else (((rev accnms), accthm) :: 
			compact [nm1] thm1 rest)
	) | compact accnms accthm [] = [((rev accnms), accthm)];
in
	compact [nm] thm tsd_list
end);
=TEX

=SML
fun €get_defns› (thynm : string) : (string list * THM) list = (
let	val {defn_dict = defn_dict,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_defns";

in
	compact_tsd (oe_flatten defn_dict)
end);
=TEX
=SML
fun €get_defn_dict› (thynm : string) : THM OE_DICT = (
let	val {defn_dict = defn_dict,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_defn_dict";

in
	defn_dict
end);
=TEX
=SML
fun €get_axioms› (thynm : string) : (string list * THM) list = (
let	val {axiom_dict = axiom_dict,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_axioms";

in
	compact_tsd (oe_flatten axiom_dict)
end);
=TEX
=SML
fun €get_axiom_dict› (thynm : string) : THM OE_DICT = (
let	val {axiom_dict = axiom_dict,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_axiom_dict";

in
	axiom_dict
end);
=TEX
=SML
fun €get_thms› (thynm : string) : (string list * THM) list = (
let	val {thm_dict = thm_dict,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_thms";

in
	compact_tsd (oe_flatten thm_dict)
end);
=TEX
=SML
fun €get_thm_dict› (thynm : string) : THM OE_DICT = (
let	val {thm_dict = thm_dict,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_thm_dict";

in
	thm_dict
end);
=TEX
=SML
fun €get_consts› (thynm : string) : TERM list = (
let	val {con_env = con_env,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_consts";

	fun env_to_term (nm,{ty=ty,level=level}) = mk_const(nm,ty);
in
	map env_to_term (oe_flatten con_env)
end);
=TEX
=SML
fun €get_types› (thynm : string) : TYPE list = (
let	val {ty_env = ty_env,...} = icl'get_theory thynm
		handle complaint =>
		pass_on complaint "icl'get_theory" "get_types";

	fun env_to_type (nm,{arity = arity,level=level}) = mk_ctype(nm,
		map (fn n => mk_vartype("'" ^ string_of_int n))(interval 1 arity));
in
	map env_to_type (oe_flatten ty_env)
end);
=TEX
=SML
fun €get_theory_status› (thynm : string) : THEORY_STATUS = (
let	val {status = status,...} = icl'get_theory_info thynm
		handle complaint =>
		pass_on complaint "icl'get_theory_info" "get_theory_status";
in
	status
end);
=TEX
\subsection{Checkpointing}
=TEX
The representation of the checkpoint data type is 
the theory name together with a dictionary mapping
theory names to pairs each comprising a level number and the user data.
We make it an abstype so that the compiler won't print the values.
=SML
type €CP_INFO› = {
	name : string,
	int_name : int,
	level : int,
	user_data : USER_DATA,
	read_only : bool,
	thms : string list
};

abstype €CHECKPOINT› =
	Checkpoint of string * CP_INFO list
with
	fun €mk_checkpoint›
	(d : string * CP_INFO list) : CHECKPOINT = (
		Checkpoint d
	);
	fun €dest_checkpoint›
	(Checkpoint d : CHECKPOINT) :  string * CP_INFO list = (
		d
	);
end;
=TEX
=SML
fun €checkpoint› (cp_thy : string) : CHECKPOINT = (
	let	val thys = get_descendants cp_thy
			handle ex => pass_on ex "get_descendants" "checkpoint";
		fun aux t : CP_INFO = (
			let	val {	contents = {
						name = int_name,
						current_level = level,
						user_data = ref user_data,
						thm_dict = thm_dict,
						...},
					children = children,
					status, ...} = icl'get_theory_info t;
				val read_only = children <> [] orelse status = TSAncestor;
				val thms = if read_only then [] else map fst (oe_flatten thm_dict);
			in {	name = t,
				int_name = int_name,
				level = level,
				user_data = user_data,
				read_only = read_only,
				thms = thms }
			end
		);
		val real_name = if cp_thy = "-" then get_current_theory_name() else cp_thy;
	in	mk_checkpoint (cp_thy, map aux thys)
	end
);
=TEX
Now for {\it rollback}. In the function  {\it rec\_del} the outermost handler
is for the {\it get\_descendants} call and is trapping the situation where
the theory has already been deleted by an earlier call.
=SML
fun €rollback› (cp : CHECKPOINT) : unit = (
	let	fun check_internal_name ({name, int_name, ...} : CP_INFO) = (
			let	val  new_int_name =
					#name(#contents(icl'get_theory_info name))
					handle Fail _ => int_name;
			in	if	int_name <>  new_int_name
				then 	fail "rollback" 12020 [fn () => name]
				else	()
			end
		);
		fun rec_del thy = (
			let	val _ = unlock_theory thy handle Fail _ => ();
				val thys = get_descendants thy less thy;
			in	map rec_del thys;
				delete_theory thy
				handle Fail _ =>
				comment "rollback" 12015
				[fn () => thy]
			end	handle Fail _ => ()
		);
		val (cp_thy, infos) = dest_checkpoint cp;
		val _ = map check_internal_name infos;
		val old_descs = map #name infos;
		val new_descs = get_descendants cp_thy
			handle Fail _ =>
			(comment "rollback" 12016 [fn  () => cp_thy]; []);
		val ancs = flat (map get_ancestors old_descs);
	in	case new_descs of
			[] => ()
		|	_ =>
	let	val to_delete = new_descs diff ancs;
		val _ = open_theory cp_thy
			handle ex => pass_on ex "open_theory" "rollback";
		val _ = map rec_del to_delete;
		fun restore ({name, level, thms, read_only = false, user_data, ...} : CP_INFO ) = (
			let	val _ = open_theory name;
				val _ = unlock_theory name handle Fail _ => ();
				val {user_data = ud,...} = icl'get_theory name;
				val _ = delete_to_level false "rollback" name (level+1);
				val new_thms = flat (map fst (get_thms name));
				val thms_to_go = new_thms diff thms;
				fun del_thm n = (delete_thm n; ()) handle Fail _ => ();
			in	map del_thm thms_to_go;
				ud := user_data
			end	handle  Fail msg =>
				comment "rollback" 12017 [
					fn  () => name,
					fn () =>  get_message_text msg]

		) | restore {read_only = true, ...} = ();
	in	map restore infos;  ()
	end
	end
);
=SML
=TEX
\subsection{End of Structure}
=SML
end; (* structure KernelInterface *)

open KernelInterface;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


