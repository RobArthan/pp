=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Implementation for the Subgoal Package}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Subgoal Package}
\TPPref{DS/FMU/IED/IMP030}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
% \TPPauthors{K.~Blackburn & WIN01\\D.J.~King & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version, working but untested.
\item [Issue 1.2]
Changes during testing.
Added a local $nat\_of\_string$.
Corrected errors.
\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the subgoal package.
The design is in \cite{DS/FMU/IED/DTD030}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the subgoal package.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}


\section{THE SUBGOAL PACKAGE}
=SML
structure âSubgoalPackageá : SubgoalPackage = struct
=TEX
\subsection{Labels}
A label of a goal within the subgoal package state is a list of integers,
though the user will view it as a string.
=SML
type âLABELá = int list;

fun âstring_of_labelá (lab : LABEL) : string = (
	format_list string_of_int lab "."
);
=TEX
As $nat\_of\_string$ initially explodes and reverses its
string, and we already have an exploded, reversed list of
characters, we give a local version of that function,
using the same error numbers as the original
=SML
local
	val ord0 = ord "0";

	fun exr_nat_of_string (s : string list) : int = (
	let	fun aux (dig :: digs) = (
			let	val n = ord dig - ord0;
			in	if n >= 0 andalso n <= 9
				then n + (10 * aux digs)
				else fail "label_of_string" 1012 [(fn (():unit) => implode(rev s))]
			end
		) | aux [] = 0;
	in	case s of
			[] => fail "label_of_string" 1013 []
		|	_ => aux s
	end
	);

	fun aux acc ("." :: x) = (
	let
		val n = exr_nat_of_string acc
	in
		if n = 0
		then fail "label_of_string" 30042 []
		else n :: aux [] x
	end
	) | aux acc (a :: x) = (
		aux (a :: acc) x
	) | aux [] [] = []
	| aux acc [] = [exr_nat_of_string acc];
in
fun âlabel_of_stringá (st : string) : LABEL = (
	aux [] (explode st)
);
end;
=TEX
The top label is jsu the empty list:
=SML
val âtop_labelá :LABEL = [];
=TEX
\subsection{Labelled Graphs}
The following is one approach to providing the functionality we want.
A different approach, with its own advantages and drawbacks
would be just to have a graph with nodes, leafs, and indications of proof.

The following is an association list of labels and terms,
combined with a list of ``achieved'' labels.
A label is present if it is in the association list;
it is achieved if it is in the second list (of just labels);
and it is superseded if it is a proper initial portion
of a label in either list.
A label cannot be both superseded and present or achieved,
by the functions that maintain the type.
=SML
type LABELLED = (LABEL * TERM) list * LABEL list;
=TEX
We now give some functions on this structure:

Look up the label:
=SML
fun âlookup_in_labelledá (caller : string) (lab : LABEL) ((assoc,ach) : LABELLED) : TERM = (
let	fun lab_eq (a1 :: x1) (a2 :: x2) =
		(a1 = a2) andalso
		lab_eq x1 x2
	| lab_eq [] (a2 :: x2) = fail caller 30041 [fn () => string_of_label lab]
	| lab_eq (a1 :: x1) [] = fail caller 30017 [fn () => string_of_label lab]
	| lab_eq [] [] = true;

in
	snd(find assoc (fn (x,_) => lab_eq lab x))
	handle complaint => (
	if area_of complaint = "find"
	then (	if any ach (lab_eq lab) 
		then fail caller 30043 [fn () => string_of_label lab]
		else fail caller 30017 [fn () => string_of_label lab]
	) else reraise complaint caller)
end);
=TEX
=SML
fun âreplace_by_1_in_labelledá (old : TERM) (new : TERM) 
	((assoc,ach) : LABELLED) : LABELLED = (
let	fun aux ((lab, tm) :: x) = (
		if aconv old tm
		then (lab,new) :: aux x
		else (lab,tm) :: aux x
	) | aux [] = [];
in
	(aux assoc, ach)
end);
=TEX
=SML
fun âreplace_by_1_in_labelledá (old : TERM) (new : TERM) 
	((assoc,ach) : LABELLED) : LABELLED = (
let	fun aux ((lab, tm) :: x) = (
		if aconv old tm
		then (lab,new) :: aux x
		else (lab,tm) :: aux x
	) | aux [] = [];
in
	(aux assoc, ach)
end);
=TEX
=SML
fun âreplace_by_many_in_labelledá (old : TERM) (newl : TERM list)
	((assoc,ach) : LABELLED) : LABELLED = (
let	val n_newl = length newl;
	val nl_newl = map (fn x => [x]) (interval 1 n_newl);
	val tm_nl_newl = combine nl_newl newl;
	fun aux ((lab, tm) :: x) = (
		if aconv old tm
		then  ((map (fn (lb,tm) => (lab @ lb, tm)) tm_nl_newl)
			@ aux x)
		else (lab,tm) :: aux x
	) | aux [] = [];
in
	(aux assoc, ach)
end);
=TEX
=SML
fun âachieve_in_labelledá (old : TERM) ((assoc,ach) : LABELLED) : LABELLED = (
let	fun aux ((lab, tm) :: x) ass prv = (
		if aconv old tm
		then  aux x ass (lab :: prv)
		else aux x ((lab,tm) :: ass) prv
	) | aux [] ass prv = (rev ass, prv);
in
	(aux assoc [] ach)
end);
=TEX
Find the labels of a given term:
=SML
fun âlabels_in_labelledá (vl : TERM) ((assoc,_) :LABELLED) : LABEL list = (
let	fun aux ((lab, tm) :: x) = (
		if aconv vl tm
		then lab :: aux x
		else aux x
	) | aux [] = [];
in
	aux assoc
end);
=TEX
Find the ``next'' label in labelled to a given one.
This is done by comparing the closest so far to each subsequent label, updating the closest as necessary.
The label for which one wants the next may be present.
=SML
fun ânext_labelá (label : LABEL) ((assoc,_) : LABELLED) : LABEL OPT = (
=TEX
This auxiliary function returns true if the first label is ``smaller'' than the second.
=SML
let	fun aux_first ((a1 :: x1):LABEL) (a2 :: x2) = (
		if a1 = a2
		then aux_first x1 x2
		else a1 < a2
	) | aux_first [] (a2 :: x2) = error "next_label" 30031 []
	| aux_first (a1 :: x1) [] = error "next_label" 30031 []
	| aux_first [] [] = error "next_label" 30015 [];
=TEX
This auxiliary function returns true if the first label is ``closer'' to the third.
=SML
	fun aux ((a1 :: x1):LABEL) (a2 :: x2) (a :: x) = (
		if (a1 = a2)
		then 	(if a1 = a
			then aux x1 x2 x
			else aux_first x1 x2)
		else if a1 = a
		then true
		else if a2 = a
		then false
		else if (a1 > a)
		then 	(if (a2 > a)
			then (a1 < a2)
			else false)
		else if (a2 > a)
		then false
		else (a1 < a2)
	) | aux [] (a2 :: x2) _ = error "next_label" 30031 []
	| aux (a1 :: x1) [] _ = error "next_label" 30031 []
	| aux [] [] _ = error "next_label" 30015 []
	| aux a1x1 a2x2 []  = aux_first a1x1 a2x2;

	fun closest ((lab1,_), lab2) = (
		if aux lab1 lab2 label
		then lab1
		else lab2
	);
in
	if assoc = []
	then Nil
	else Value(fold closest (tl assoc) (fst(hd assoc)))
end);
=TEX		
\subsection{Term Form Goals}
First introduce $icl'TS$:
=SML
val âicl'ts_defá = simple_new_defn("icl'TS","icl'TS",» x : BOOL Ž x¼);
val âicl'ts_thmá = save_thm("icl'ts_thm",
	all_ƒ_intro(simple_all_%beta%_rule (ap_arg_rule »x : BOOL¼ icl'ts_def)));
val âicl'tsá = »icl'TS¼;
val âicl'ts_rev_thmá = all_ƒ_intro(eq_sym_rule(
	simple_all_%beta%_rule (ap_arg_rule »x : BOOL¼ icl'ts_def)));

=TEX
We can now provide a function to make a term form of a goal.
This does not check that all the assumptions are $\alpha$-convertably 
distinct.
=SML
fun âmk_term_form_goalá ((asms, conc) : GOAL) : TERM = (
let	val tm =  list_mk_Š (asms @ [mk_comb(icl'ts, conc)]);
	val frees_tm = frees tm;
in
	simple_list_mk_ƒ (rev frees_tm, tm)
end
handle complaint =>
list_divert complaint "mk_term_form_goal" [
	("mk_comb",30002,[fn () => PolyML.makestring conc]),
	("list_mk_Š",30003,[fn () => PolyML.makestring(find asms (fn x => type_of x <> BOOL))])]
);
=TEX
Test of whether something is a term-form goal.
=SML
fun âis_term_form_goalá (tm : TERM) : bool = (
	((let	val tm1 = snd(simple_strip_ƒ tm);
		val tm2 = hd(rev(strip_Š tm1));
		val icl'ts' = fst(dest_comb tm2);
	in
		icl'ts' = icl'ts
	end)
	andalso (frees tm = []))
	handle (Fail _) => false
);
=TEX
Make a goal from a term:
=SML
local
	fun aux acc [tm] = (rev acc,tm)
	| aux acc (a :: x) = aux (a :: acc) x
	| aux acc _ = error "mk_goal_from_term" 0 []
in
fun âmk_goal_from_termá (tm : TERM) : GOAL = (
let	val tm1 = snd(simple_strip_ƒ tm);
	val (asms, ts_conc) = aux [] (strip_Š tm1);
	val (ts,conc) = dest_comb ts_conc;
in
	if ts = icl'ts
	then (asms,conc)
	else term_fail "mk_goal_from_term" 30023 [tm]
end
handle (Fail _) =>
term_fail "mk_goal_from_term" 30023 [tm]
);
end;
=TEX

\subsection{The Types of the Goal State and Package State}
The four components of the goal state are:
\begin{description}
\item [labelling]
This is an association list of term form goals and labels,
as well as a list of achieved labels.
\item [current\_goal]
The current goal, held as an optional label.
If its value is $Nil$ it indicates there are no remaining goals to be achieved.
\item [goal\_state\_thm]
This is the current state of the proof held as a theorem.
All successful inferences have had their effect here.
\item [mgst]
If this is true then the state's goal state theorem has 
been manipulated by $modify\_goal\_state\_thm$.
This may have changed the main goal from its original setting,
and the user is informed if this has occurred at the point of
change, and when extracting the theorem of an achieved main goal.
\end{description}
=SML
abstype âGOAL_STATEá = GS of {labelling : LABELLED,
		current_goal : LABEL OPT,
		goal_state_thm : THM,
		mgst : bool}
with
type âPACKAGE_STATEá = {main_goal_stack : GOAL_STATE list,
		undo_buffer : GOAL_STATE list,
		redo : GOAL_STATE list};
=TEX
A test for the equality of two goal states:
=SML
fun âgs_equalá (GS{labelling = lg1, current_goal = cg1, goal_state_thm = gst1,...})
	(GS{labelling = lg2, current_goal = cg2, goal_state_thm = gst2,...}) = (
	(lg1 = lg2) andalso
	(cg1 = cg2) andalso
	(dest_thm gst1 = dest_thm gst2)
);
=TEX
	

Now the current state of the subgoal package:
=SML
val current : PACKAGE_STATE ref = ref {main_goal_stack = [], 
	undo_buffer = [],
	redo = []};
=TEX
\subsection{Handling the buffer}
We have a non-negative size of buffer:
=SML
local
	val undo_buffer_length : int ref = ref 12;
	val side_effect = new_int_control {
		name="undo_buffer_length",
		control=undo_buffer_length,
		default=(fn () => 12),
		check= (fn x => x>= 0)};
in
fun âadd_to_bufferá (s:GOAL_STATE) (ub : GOAL_STATE list) : GOAL_STATE list = (
	(s :: ub) to (!undo_buffer_length - 1)
);
end;
=TEX
\subsection{Printing Some Labelled Subgoals}
The following should have all $»$  for assumptions in the same column,
and all multi-line assumptions have following lines starting 
one character further in.
In the following we use the text for ``error'' messages 30053 and
30054 to define the layout.
We presume that ``?0'' precedes ``?1'' in message 3054,
and we obey the detailed design in setting ``?0'' to ``\\n''..
=SML
local
	fun last_line_of (str : string) : string = (
	let	val estr = explode str;
		fun strip_to_n ("\n" :: x) = []
		| strip_to_n (a :: x) = a :: strip_to_n x
		| strip_to_n [] = [];
	in
		implode(rev(strip_to_n (rev estr)))
	end);
in
fun âprint_goalá ((asms, conc): GOAL) : unit = (
let	val orig_line_length = get_line_length();
	val lasms = length asms;
	val nasms = combine (interval 1 lasms) asms;
	val asm_mess = get_error_message 30053 [""];
	val max_nasm_length = size(string_of_int lasms);
	val min_asm_length = size asm_mess;
	val max_asm_length = max_nasm_length + min_asm_length;
	val init_ts = get_error_message 30054 ["\n",""];
	val init_ts_length = size(last_line_of init_ts);
	val str_length = if max_asm_length > init_ts_length
		then max_asm_length
		else init_ts_length;
	val pad_asms_by = str_length - (min_asm_length+1);

	val padding = map (fn _=>" ") (interval 1 str_length);
	val tpadding = implode padding ^ " ";
	val ts = get_error_message 30054 ["\n",implode(padding to (str_length - (init_ts_length+1)))];


	fun print_asm (n,asm) = (
	let 	val asml = (PrettyPrinter.format_term) asm;
		val nstr = string_of_int n;
		val pad = implode(padding to (pad_asms_by - size nstr));
		val hstring = get_error_message 30053 [pad ^ nstr];
	in
		(diag_line (hstring ^ hd asml);
		map (fn x => diag_line (tpadding ^ x)) (tl asml))
	end);
	val sideeffect = set_line_length(orig_line_length - str_length);

	val form_conc = PrettyPrinter.format_term conc;
in
	(map print_asm (rev nasms);
	diag_line (ts ^(hd form_conc));
	map(fn x =>  diag_line(tpadding ^ x)) (tl form_conc);
	set_line_length orig_line_length;
	())
end);
end;
=TEX
We presume 3052 contains that ``?0'' precedes ``?1'' in message 3052,
and we obey the detailed design in setting ``?0'' to ``\\n''..
=SML
fun âprint_goal_with_labelá (lab: LABEL) (gl : TERM) : unit = (
	diag_line(get_error_message 30052 ["\n",string_of_label lab]);
	print_goal (mk_goal_from_term gl)
	
);
=TEX
=SML
fun âprint_labelled_goalá (lab: LABEL) : unit = (
let	val {main_goal_stack = main_goal_stack, ...} = !current;
	val GS{labelling = lg,...} = case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "print_labelled_goal" 30010 [];
	val gl = lookup_in_labelled "print_labelled_goal" lab lg;
in
	print_goal_with_label lab gl
end);
=TEX
=SML
fun âprint_goals_labelledá (labs: LABEL list) : unit = (
let	val {main_goal_stack = main_goal_stack, ...} = !current;
	val GS{labelling = lg,...} = case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "print_labelled_goal" 30010 [];
	fun aux (lab :: x) = (
	let	val gl = lookup_in_labelled "print_goals_labelled" lab lg;
	in
		(print_goal_with_label lab gl;
		aux x)
	end) | aux [] = ();
in
	aux labs
end);
=TEX
\subsection{Starting a New Main Goal}
Return two $\alpha$-convertible terms:
=SML
local
fun âtwo_aconvá ((a :: x): TERM list) : unit = (
	if a term_mem x
	then fail "push_goal" 30004 [(fn () => PolyML.makestring a), 
		(fn () => PolyML.makestring(find x (fn y => aconv a y)))]
	else two_aconv x
) | two_aconv _ = ();
=TEX

=SML
in
fun âpush_goalá (goal as (asms,conc) : GOAL) : unit = (
let	val {main_goal_stack = main_goal_stack, ...} = !current;
	val side_effect = two_aconv asms;
	val tm_goal = mk_term_form_goal goal
		handle complaint =>
		pass_on complaint "mk_term_form_goal" "push_goal";
	val lg = ([(top_label,tm_goal)],[]);
	val cg = Value top_label;
	val gst = asm_rule tm_goal;
	val new_goal_state = GS{labelling = lg, current_goal = cg, goal_state_thm = gst, mgst = false};
	val len_stack = 1+ length main_goal_stack;
	val opts = if len_stack = 1 then "" else "s";
in
	(current := {main_goal_stack = (new_goal_state :: main_goal_stack), 
		undo_buffer = [], redo = []};
	diag_line(get_error_message 30001 [string_of_int len_stack, opts]);
	print_labelled_goal [];
	())
end);
end;
=TEX
=SML
fun âpush_goal_state_thmá (goal_state_thm : THM) : unit = (
let	val {main_goal_stack = main_goal_stack, ...} = !current;
	val hys = hyps goal_state_thm;
	val side_effect = map (fn x => mk_goal_from_term x
			handle complaint =>
			divert complaint "mk_goal_from_term" "push_goal_state_thm" 30005 [])
		hys;
	val side_effect = mk_goal_from_term (concl goal_state_thm)
		handle complaint =>
		divert complaint "mk_goal_from_term" "push_goal_state_thm" 30005 [];
	val (cg,lg) = case hys of
		[] => (Nil,([],[]))
		| [h] => (Value top_label,
			([(top_label, h)],[]))
		| _ => (Value [1],
			((combine (map (fn x=>[x]) (interval 1 (length hys))) hys),
			[]));
	val new_goal_state = GS{labelling = lg, current_goal = cg, 
		goal_state_thm = goal_state_thm, mgst = false};
	val len_stack = 1+ length main_goal_stack;
	val opts = if len_stack = 1 then "" else "s";
in
	(current := {main_goal_stack = (new_goal_state :: main_goal_stack), 
		undo_buffer = [], redo = []};
	diag_line(get_error_message 30001 [string_of_int len_stack, opts]);
	case hys of
	[] => diag_line(get_error_message 30048 [])
	| [_] => (diag_line(get_error_message 30047 []);
		print_labelled_goal [])
	| _ => (diag_line(get_error_message 30047 []);
		print_goals_labelled(map (fn x => [x]) (rev(interval 1 (length hys)))));
	())
end);
=TEX
\subsection{Applying Tactics}
Create a theorem whose conclusion is the conclusion of a goal,
which contains the goals assumptions, but in addition has
the goal in term form as an assumption.
=SML
fun âgoal_ruleá (goal as (asms,conc) : GOAL) : THM = (
let	val tm_goal = mk_term_form_goal goal;
	val s1 = asm_rule tm_goal;
	val s2 = simple_all_ƒ_elim s1;
	val s3 = strip_Š_rule s2;
	val s4 = simple_ƒ_elim conc icl'ts_thm;
	val s5 = ‚_mp_rule s4 s3;
in
	s5
end);
=TEX
=SML
fun âtop_thm_ruleá (thm : THM) : THM = (
let	val s1 = simple_all_ƒ_elim thm;
	val s2 = strip_Š_rule s1;
	val s3 = simple_ƒ_elim (snd(dest_comb(concl s2))) icl'ts_thm;
	val s4 = ‚_mp_rule s3 s2;
in
	s4
end);
=TEX
If a tactic has introduced its own assumptions then we need
to make them kosher:
=SML
fun âmake_all_asms_term_formá (expected_tfg : TERM list) 
	(proper_asms : TERM list) (thm : THM) : THM = (
let	val (asms, conc) = dest_thm thm;
	fun do_one (asm, thm) = (
		if (asm term_mem proper_asms) orelse
			(asm term_mem expected_tfg) orelse 
			is_term_form_goal asm
		then thm
		else (let 
			val tm = mk_term_form_goal (proper_asms,asm);
			val s1 = asm_rule tm;
			val s2 = top_thm_rule s1;
			val s3 = prove_asm_rule s2 thm
		in
			s3
		end)
	);
in
	fold do_one asms thm
end);
=TEX
=SML
fun âterm_form_goal_ruleá (expected_tfg : TERM list) 
	(asms : TERM list) (thm : THM) : THM = (
let	val s1 = simple_ƒ_elim (concl thm) icl'ts_rev_thm;
	val s2 = ‚_mp_rule s1 thm;
	val s3 = make_all_asms_term_form expected_tfg asms s2;
	val s4 = fold (uncurry Š_intro) asms s3;
	val s5 = all_ƒ_intro s4;
in
	s5
end);
=TEX
=SML
fun âpartition_by_overlapá (set1 : TERM list) (set2 : TERM list) : 
	((TERM list) * (TERM list) * (TERM list)) = (
let	fun aux acc1 acc2 acc3 (a :: x) = (
		if a term_mem set2
		then aux acc1 (a :: acc2) (acc3 term_less a) x
		else aux (a :: acc1) acc2 acc3 x
	) | aux acc1 acc2 acc3 [] = (rev acc1, rev acc2, acc3);
in
	aux [] [] set2 set1
end);

=TEX
The following adds the appropriate new labelling information
for any newly introduced goals, giving the user information about
duplicates, introduced and unnecessary subgoals.
Note that $generated$ will contain no duplicates.
=SML
fun âadd_new_goalsá (expected: TERM list) 
	(generated : TERM list)
	(previous : TERM list) 
	(old_label : LABEL)
	(old_goal : TERM)
	(labelled as (assoc,ach): LABELLED) : (LABEL OPT * LABELLED) = (
let	val (unnecessary,used,additional) = (
		partition_by_overlap expected generated
	);
=TEX
Note that $additional$ will contain no duplicates, nor 
any members of $used$.
Declare the number of subgoals:
=SML
	val other_goals = used @ additional;
	
	val lother_goals = length other_goals;

	val sideeffect = if lother_goals = 1
		then diag_line(get_error_message 30037 ["1",""])
		else diag_line(get_error_message 30037 [string_of_int lother_goals,"s"]);
=TEX
We only want to note duplicates of pre-existing subgoals,
other than the goal being worked on: it is not a duplication
to recreate this goal as a new subgoal.
=SML
	val previous' = previous term_less old_goal;
=TEX
Then announce the unnecessary subgoals:
=SML
	val sideeffect = map (fn x => 
		(diag_line(get_error_message 30033 []);
		print_goal(mk_goal_from_term x)))
		unnecessary;
=TEX
Then put the new goals into the labelling:
=SML
	val labelled' = case other_goals of
		[] => achieve_in_labelled old_goal labelled
		| [ng] => replace_by_1_in_labelled old_goal ng labelled
		| _ => replace_by_many_in_labelled old_goal other_goals labelled;

	val new_label  = if lother_goals = 1
		then (fn x => old_label)
		else if lother_goals > 1
		then (fn x => old_label @ [x])
		else (fn x => error "add_new_goals" 30020 []);
=TEX
The following auxiliary declares those additional subgoals not requested
by the tactic, but which are present in the result.
=SML
	fun add_aux (a :: x) accm n = (
	let val new_lab = new_label n;
		val snew_lab = string_of_label new_lab;
	in	
	if a term_mem previous'
	then (let val other_labs = (labels_in_labelled a labelled) less new_lab;
		val other_labss = format_list string_of_label other_labs ", ";
		val opts = case other_labs of
			[] => error "add_new_goals" 30020 []
			| [_] => ""
			| _ => "s";
	in	
		(print_goal_with_label new_lab a;
		add_aux x (get_error_message 30030 [snew_lab, opts, other_labss] :: accm) 
			(n-1)
		)
	end)
	else 	(print_goal_with_label new_lab a;
		add_aux x 
			(if aconv a old_goal 
			then (	get_error_message 30006 [snew_lab] ::
				get_error_message 30029 [snew_lab] ::
				accm)
			else (	get_error_message 30029 [snew_lab] ::
				accm))
			(n-1))
	end
	) | add_aux [] accm n = (accm, n);
=TEX
The following auxiliary declares those subgoals requested
by the tactic, except when unused.
=SML
	fun aux (a :: x) prev accm n = (
	let val new_lab = new_label n;
		val snew_lab = string_of_label new_lab;
	in
	(if a term_mem prev
	then (let val other_labs = (labels_in_labelled a labelled') less new_lab;
		val other_labss = format_list string_of_label other_labs ", ";
		val opts = case other_labs of
			[] => error "add_new_goals" 30020 []
			| [_] => ""
			| _ => "s";
	in	
		(print_goal_with_label new_lab a;
		aux x prev (get_error_message 30032 [snew_lab, opts, other_labss] :: accm)
			(n-1)
		)
	end)
	else (	print_goal_with_label new_lab a;
		aux x (a :: prev) 
			(if aconv a old_goal 
			then (get_error_message 30006 [snew_lab] ::
				accm)
			else accm)
			(n-1))
	)
	end
	) | aux [] _ accm _  = accm;
=TEX
Then give the additional subgoals:
=SML
	val (accm,index) = add_aux additional [] lother_goals;
=TEX
Now give the requested goals, making sure the first requested and used goal is presented last, with label ``label.1''.
=SML
	val accm' = aux (rev used) previous' accm index;
=TEX
Calculate the new current goal:
=SML
	val new_cg = (case lother_goals of
		0 => next_label old_label labelled'
		| 1 => Value old_label
		| _ => Value (new_label 1));
=TEX
Now present the accumulated information messages:
=SML
	val sideeffect = map diag_line accm';
=TEX
and return the new current goal label, and the new labelling.
=SML
in
	(new_cg,labelled')
end);
=TEX
Now the important function: apply a tactic:
=SML
fun âapply_tacticá (tac : TACTIC) : unit = (
let	val {main_goal_stack = main_goal_stack,
		undo_buffer = undo_buffer,...} = !current;
	val current_goal_state as GS{labelling = labelling as (assoc,ach),
		current_goal = current_goal,
		goal_state_thm=goal_state_thm, mgst = mgst} = (case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "apply_tactic" 30007 []);
	val cg = (case current_goal of
		Value lcg => lcg
		| Nil => fail "apply_tactic" 30007 []);
	val cg_term = (lookup_in_labelled "apply_tactic" cg labelling
			handle (Fail complaint) =>
			error "apply_tactic" 30020 []);
	val (asms,conc) = (mk_goal_from_term cg_term
		handle complaint =>
		error "apply_tactic" 30020 []);
	val (sgs,proof) = tac (asms,conc);
	val sgs_thms = map goal_rule sgs;
	val expected_sgs = map mk_term_form_goal sgs;
	val proof_thm = proof sgs_thms;
	val proof_thm' = term_form_goal_rule expected_sgs asms proof_thm;
	val super_conc = concl proof_thm';
	val sideeffect = (if aconv super_conc cg_term
		then ()
		else fail "apply_tactic" 30008 []);
	val new_gst = prove_asm_rule proof_thm' goal_state_thm;
	val generated_sgs = hyps proof_thm';
	val old_sgs = hyps goal_state_thm;
	val (new_cg,new_lg) = add_new_goals expected_sgs 
		generated_sgs old_sgs cg cg_term labelling;
	val new_gs = GS{labelling = new_lg,
		current_goal = new_cg,
		goal_state_thm = new_gst,
		mgst = mgst};
	val side_effect = if gs_equal new_gs current_goal_state
		then diag_line(get_error_message 30034 [])
		else ();
in
	(current := {main_goal_stack = new_gs :: tl main_goal_stack,
		undo_buffer = add_to_buffer current_goal_state undo_buffer,
		redo = []};
	if generated_sgs = []
	then (case new_cg of
		Nil => diag_line(get_error_message 30036 [])
		| Value v => (diag_line(get_error_message 30035 []);
			print_labelled_goal v))
	else ();
	())
end);
=TEX
And the alias:
=SML
val âaá = apply_tactic;
=TEX
\subsection{The Results of the Package}
=SML
fun âpop_thmá () : THM = (
let	val {main_goal_stack = main_goal_stack,...} = !current;
	val current_goal_state as GS{goal_state_thm=goal_state_thm,mgst = mgst,...} = 
		(case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "pop_thm" 30010 []);
	
	val sideeffect = if is_nil(hyps goal_state_thm)
		then ()
		else fail "pop_thm" 30011 [];

	val res = top_thm_rule goal_state_thm;
	val new_mgs = tl main_goal_stack;
	val lnew_mgs = length new_mgs;
in
	(current := {main_goal_stack = new_mgs, 
		undo_buffer = [],redo = []};
	if mgst then diag_line(get_error_message 30024 []) else ();
	diag_line(get_error_message 30001 [
		string_of_int lnew_mgs,
		if lnew_mgs = 1 then "" else "s"]);
	res)
end);
=TEX
=SML
fun âsave_pop_thmá (key : string) : THM = (
let	val {main_goal_stack = main_goal_stack,...} = !current;
	val current_goal_state as GS{goal_state_thm=goal_state_thm,mgst = mgst,...} = 
		(case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "save_pop_thm" 30010 []);
	
	val sideeffect = if is_nil(hyps goal_state_thm)
		then ()
		else fail "save_pop_thm" 30011 [];

	val res = top_thm_rule goal_state_thm;
	val res' = save_thm(key,res)
		handle complaint =>
		pass_on complaint "save_thm" "save_pop_thm";

	val new_mgs = tl main_goal_stack;
	val lnew_mgs = length new_mgs;
in
	(current := {main_goal_stack = new_mgs, undo_buffer = [],redo = []};
	if mgst then diag_line(get_error_message 30024 []) else ();
	diag_line(get_error_message 30001 [
		string_of_int lnew_mgs,
		if lnew_mgs = 1 then "" else "s"]);
	top_thm_rule goal_state_thm)
end);
=TEX
=SML
fun âtop_thmá () : THM = (
let	val {main_goal_stack = main_goal_stack,...} = !current;
	val current_goal_state as GS{goal_state_thm=goal_state_thm,mgst = mgst,...} = 
		(case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "top_thm" 30010 []);
	
	val sideeffect = if is_nil(hyps goal_state_thm)
		then ()
		else fail "top_thm" 30011 [];

	val res = top_thm_rule goal_state_thm;
in
	(if mgst then diag_line(get_error_message 30024 []) else ();
	res)
end);
=TEX
=SML
fun âtop_goal_state_thmá () : THM = (
let	val {main_goal_stack = main_goal_stack,...} = !current;
	val current_goal_state as GS{goal_state_thm=goal_state_thm,mgst = mgst,...} = 
		(case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "top_goal_state_thm" 30010 []);
in
	(if mgst then diag_line(get_error_message 30024 []) else ();
	if is_nil(hyps goal_state_thm) then diag_line(get_error_message 30028 []) else ();
	goal_state_thm)
end);
=TEX
=SML
local
	fun strip_n_Š 0 thm = thm
	| strip_n_Š n thm = strip_n_Š (n-1) (undisch_rule thm);
in
fun âsimplify_goal_state_thmá (thm : THM) : THM = (
let	val hys = hyps thm;
	val hgoals = map (fn x => 
		let	val (asms,conc) = mk_goal_from_term x;
			val bse = list_mk_Š (asms @ [conc]);
			val gl = simple_list_mk_ƒ(rev(frees bse),bse);
			val s1 = asm_rule gl;
			val s2 = simple_all_ƒ_elim s1;
			val s3 = strip_n_Š (length asms) s2;
			val s4 = term_form_goal_rule [gl] asms s3;
		in
			s4
		end)
		hys;
	val replace_hyps = fold (uncurry prove_asm_rule) (rev hgoals) thm;
	val mf_s1 = simple_all_ƒ_elim replace_hyps;
	val mf_s2 = strip_Š_rule mf_s1;
	val mf_s3 = simple_ƒ_elim (snd(dest_comb(concl mf_s2))) icl'ts_thm
	val mf_s4 = ‚_mp_rule mf_s3 mf_s2;
in
	mf_s4
end
handle complaint =>
list_divert complaint "simplify_goal_state_thm" [
	("mk_goal_from_term",30005,[]),
	("dest_comb",30005,[]),
	("‚_mp_rule",30005,[])]
);
end;
=TEX
=SML
fun âdrop_main_goalá () : GOAL = (
let	val {main_goal_stack = main_goal_stack,...} = !current;
	val GS{goal_state_thm = goal_state_thm,...} = 
		(case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "drop_main_goal" 30010 []);
	
	val old_main_goal = mk_goal_from_term(concl goal_state_thm);
	val new_mgs = tl main_goal_stack;
	val lnew_mgs = length new_mgs;
in
	(current := {main_goal_stack = new_mgs, 
		undo_buffer = [], redo = []};
	diag_line(get_error_message 30001 [
		string_of_int lnew_mgs,
		if lnew_mgs = 1 then "" else "s"]);
	old_main_goal)
end);
=TEX
\subsection{Undoing and Redoing}
=SML
fun âundoá (n : int) : unit = (
let	val {main_goal_stack = main_goal_stack,
		undo_buffer = undo_buffer,...} = !current;
	val current_gs = 
		(case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "undo" 30010 []);
	val lub = length undo_buffer;
	val sideeffect = if n <= 0 
		then fail "undo" 30013 []
		else if n > lub
		then fail "undo" 30012 [(fn () => string_of_int n),
			(fn () => if n = 1 then "" else "s"),
			(fn () => string_of_int lub),
			(fn () => if lub = 1 then "y" else "ies")
			]
		else ();
	val new_gs as GS{current_goal = new_cg,...} = nth (n-1) undo_buffer;
	val new_undo = undo_buffer from n;
	val new_redo = current_gs :: undo_buffer to (n-1);
in
	(current := {main_goal_stack = new_gs :: tl main_goal_stack,
		undo_buffer = new_undo,
		redo = new_redo};
	(case new_cg of
		Nil => diag_line(get_error_message 30048 [])
		| Value v => (diag_line(get_error_message 30047 []);
			print_labelled_goal v));
	())
end);
=TEX
=SML
fun âredoá () : unit = (
let	val {main_goal_stack = main_goal_stack,
		undo_buffer = undo_buffer,redo = redo} = !current;
	val current_gs = 
		(case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "undo" 30010 []);
	val lub = length undo_buffer;
	val sideeffect = if is_nil redo
		then fail "redo" 30014 []
		else  ();
	val new_states = redo @ [current_gs] @ undo_buffer;
	val new_gs  as GS{current_goal = new_cg,...} = hd new_states;
	val new_undo = (tl new_states) to (get_int_control "undo_buffer_length" -1);
	val new_redo = [];
in
	(current := {main_goal_stack = new_gs :: tl main_goal_stack,
		undo_buffer = new_undo,
		redo = new_redo};
	(case new_cg of
		Nil => diag_line(get_error_message 30048 [])
		| Value v => (diag_line(get_error_message 30047 []);
			print_labelled_goal v));
	())
end);
=TEX
\subsection{Navigation}
=SML
fun âset_labelled_goalá (label : string) : unit = (
let	val nlabel = label_of_string label
		handle complaint =>
		divert complaint "label_of_string" "set_labelled_goal" 30016 [fn () => label];
	val {main_goal_stack = main_goal_stack,
		undo_buffer = undo_buffer,redo = redo} = !current;
	val current_gs = 
		(case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "set_labelled_goal" 30010 []);
	val GS{labelling = labelling, 
		current_goal = current_goal, 
		goal_state_thm = goal_state_thm,mgst = mgst} = current_gs;
	val sideeffect = lookup_in_labelled "set_labelled_goal" nlabel labelling;
	val new_gs = GS{labelling = labelling, 
		current_goal = Value nlabel, 
		goal_state_thm = goal_state_thm,mgst = mgst};
	val new_undo = add_to_buffer current_gs undo_buffer;
	val new_redo = [];
in
	(current := {main_goal_stack = new_gs :: tl main_goal_stack,
		undo_buffer = new_undo,
		redo = new_redo};
	(diag_line(get_error_message 30047 []);
	print_labelled_goal nlabel);
	())
end);
=TEX
\subsection{Handling Goal States}
=SML
fun âtop_goal_stateá () : GOAL_STATE = (
let	val {main_goal_stack = main_goal_stack,
		undo_buffer = undo_buffer,redo = redo} = !current;
	val current_gs = 
		(case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "top_goal_state" 30010 []);
in
	current_gs
end);
=TEX
We use $‚\_t\_intro$ to see if we have an invalid theorem
(e.g. out of scope).
If so, we cannot catch the failure, but at least it happens before
the undo buffer is emptied.
=SML
fun âpush_goal_stateá (new_gs as GS{goal_state_thm = goal_state_thm,...}: 
	GOAL_STATE) : unit = (
let	val {main_goal_stack = main_goal_stack,...} = !current;
	val side_effect = ‚_t_intro goal_state_thm;
	val GS{current_goal = current_goal,...} = new_gs;
	val new_mgs = new_gs :: main_goal_stack;
	val lnew_mgs = length new_mgs;
in
	(current := {main_goal_stack = new_mgs, undo_buffer = [], redo = []};
	diag_line(get_error_message 30001 [
		string_of_int lnew_mgs,
		if lnew_mgs = 1 then "" else "s"]);
	(case current_goal of
		Nil => diag_line(get_error_message 30048 [])
		| Value v => (diag_line(get_error_message 30047 []);
			print_labelled_goal v));
	())
end);
=TEX
\subsection{Information Requests}
=SML
fun âtop_main_goalá () : GOAL = (
let	val {main_goal_stack = main_goal_stack,...} = !current;
	val GS{goal_state_thm = goal_state_thm,...} = 
		(case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "top_main_goal" 30025 []);
in
	mk_goal_from_term(concl goal_state_thm)
end);
=TEX
=SML
fun âtop_current_goalá () : GOAL = (
let	val {main_goal_stack = main_goal_stack,...} = !current;
	val GS{labelling = labelling,
		current_goal = current_goal,...} = 
		(case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "top_current_goal" 30026 []);
	val cg = case current_goal of
		Value v => v
		| Nil => fail "top_current_goal" 30026 [];
	val cg_term = lookup_in_labelled "top_current_goal" cg labelling;
in
	mk_goal_from_term cg_term
end);
=TEX
=SML
fun âprint_current_goalá () : unit = (
let	val {main_goal_stack = main_goal_stack,...} = !current;
	val GS{labelling = labelling,
		current_goal = current_goal,...} = 
		(case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "print_current_goal" 30026 []);
	val cg = case current_goal of
		Value v => v
		| Nil => fail "print_current_goal" 30026 [];
in
	print_labelled_goal cg
end);
=TEX
=SML
fun âtop_current_labelá () : string = (
let	val {main_goal_stack = main_goal_stack,...} = !current;
	val GS{labelling = labelling,
		current_goal = current_goal,...} = 
		(case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "top_current_label" 30026 []);
	val cg = case current_goal of
		Value v => v
		| Nil => fail "top_current_label" 30026 [];
in
	string_of_label cg
end);
=TEX
=SML
fun âtop_labelled_goalá (label : string) : GOAL = (
let	val nlabel = label_of_string label
		handle complaint =>
		divert complaint "label_of_string" "top_labelled_goal" 30016 [fn () => label];
	val {main_goal_stack = main_goal_stack,...} = !current;
	val GS{labelling = labelling,...} = 
		(case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "top_labelled_goal" 30026 []);
	val gterm = lookup_in_labelled "top_labelled_goal" nlabel labelling;
in
	 mk_goal_from_term gterm
end);
=TEX
=SML
fun âget_asmá ( n : int) : TERM = (
let	val {main_goal_stack = main_goal_stack,...} = !current;
	val GS{labelling = labelling,
		current_goal = current_goal,...} = 
		(case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "get_asm" 30026 []);
	val cg = case current_goal of
		Value v => v
		| Nil => fail "get_asm" 30026 [];
	val cg_term = lookup_in_labelled "get_asm" cg labelling;
	val cg_term' = snd(simple_strip_ƒ cg_term);
	val hys_plus_conc = (strip_Š cg_term');
	val sideeffect = if (n >= length hys_plus_conc) orelse (n < 1)
		then fail "get_asm" 30027 [fn () => string_of_int n]
		else ();
in
	nth (n-1) hys_plus_conc
end);
=TEX
=SML
local
	fun compact acc ((lab,gl) :: x) = (
	let	fun aux ((labs,tm) :: rest) = (
			if aconv gl tm
			then ((lab :: labs),tm) :: rest
			else (labs,tm) :: aux rest
		) | aux [] = [([lab],gl)];
	in
		compact (aux acc) x
	end
	) | compact acc [] = acc;
in
fun âtop_goalsá () : (string list * GOAL)list = (
let	val {main_goal_stack = main_goal_stack,...} = !current;
	val GS{labelling = labelling,...} = 
		(case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "top_goals" 30010 []);
in
	map (fn (x,y) => (map string_of_label x, 
			mk_goal_from_term y))
		(compact [] (fst labelling))
end);
end;
=TEX
=SML
fun âprint_goal_stateá (gs as GS{labelling = labelling,
	current_goal = current_goal,
	goal_state_thm = goal_state_thm,...}: GOAL_STATE) : unit = (
	diag_line(get_error_message 30049 []);
	print_goal (mk_goal_from_term(concl goal_state_thm));
	case current_goal of
	Nil => diag_line(get_error_message 30048 [])
	| Value v => (
		diag_line(get_error_message 30050 []);
		map (uncurry print_goal_with_label) (fst labelling);
		diag_line "";
		diag_line(get_error_message 30047 []);
		print_goal_with_label v (lookup_in_labelled "print_goal_state" 
			v labelling)
	);
	()
);
=TEX
=SML
local
	fun label1 ((labs:LABEL list,tm) :: rest) ltm = (
		if aconv tm ltm
		then labs cup (label1 rest ltm)
		else label1 rest ltm
	) | label1 [] ltm = [];

	fun lab_distinct ((lab1 : LABEL),(lab2 : LABEL)) = (
	let	fun aux (a1 :: x1) (a2 :: x2) =
		(a1 <> a2) orelse
		aux x1 x2
		| aux _ _ = if lab1 = lab2
			then fail "modify_goal_state_thm" 30040 
				[fn () => string_of_label lab1]
			else fail "modify_goal_state_thm" 30039 
				[fn () => string_of_label lab1,
				fn () => string_of_label lab2];
	in
		aux lab1 lab2
	end);

	fun aux ((([]:LABEL list),(tm:TERM)),(sofar, ll)) = ((([[ll]:LABEL],tm)::sofar),ll+1)
	| aux ((lls_tm),(sofar, ll)) = ((lls_tm :: sofar),ll);
in
fun âmodify_goal_state_thmá (ir : THM -> THM) (
	ulabs : (string list * GOAL)list) : unit = (
let	val ulabs' = (map (fn (ls,tm) => 
		(map label_of_string ls, mk_term_form_goal tm)) ulabs)
		handle complaint =>
		pass_on complaint "label_of_string" "modify_goal_state_thm";

	val {main_goal_stack = main_goal_stack,
		undo_buffer = undo_buffer,...} = !current;

	val current_goal_state as GS{labelling = labelling as (assoc,ach),
		current_goal = current_goal,
		goal_state_thm=goal_state_thm,mgst=mgst} = (case main_goal_stack of
		(a :: _) => a
		| [] =>  fail "apply_tactic" 30007 []);

	val new_gst = ir goal_state_thm;
	val (hys,conc) = dest_thm new_gst;
	val sideeffect = if is_term_form_goal conc andalso
			all hys is_term_form_goal
		then ()
		else fail "modify_goal_state_thm" 30051 
			[fn () => PolyML.makestring new_gst];
	val new_labelling1 = map (fn tm => (label1 ulabs' tm,tm)) hys;
	val labs_used = flat(map fst new_labelling1);
	val sideeffect = all_distinct lab_distinct labs_used;
	val last_label = fold (fn ((a::x),y) => if a > y
			then a
			else y
			| (_,y) => y)
			labs_used 0;
	val sideeffect = if (length hys > 1) andalso ([] mem labs_used)
		then fail "modify_goal_state_thm" 30039 
				[fn () => "",
				fn () => "1"]
		else ();
	val new_labelling2 = fst(fold aux new_labelling1 ([],last_label+1));
	val new_labelling3:LABELLED = 
		((flat (map (fn (labs,tm) => 
		map (fn l => (l,tm)) labs) new_labelling2)),[]);

	val new_cg = next_label [] new_labelling3;
	val changed_main_goal = concl goal_state_thm <> concl new_gst;
	val new_gs = GS{labelling = new_labelling3,
		current_goal = new_cg,
		goal_state_thm = new_gst,
		mgst = changed_main_goal orelse mgst};
	val side_effect = if gs_equal new_gs current_goal_state
		then diag_line(get_error_message 30034 [])
		else ();
in
	(current := {main_goal_stack = new_gs :: tl main_goal_stack,
		undo_buffer = add_to_buffer current_goal_state undo_buffer,
		redo = []};
	if changed_main_goal 
	then diag_line(get_error_message 30024 [])
	else ();
	(case new_cg of
		Nil => diag_line(get_error_message 30048 [])
		| Value v => (diag_line(get_error_message 30047 []);
			print_labelled_goal v));
	())
end);
end;
	
=TEX
\section{END OF THE STRUCTURE}
=SML
end; (* of abstract data type *)
end; (* of structure SubgoalPackage *)
open SubgoalPackage;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN
Statistics:

open Sort;
fun comp_stats (s1,n1) (s2,n2) = (
	if n1 = n2
	then stringorder s1 s2
	else (n1 - n2)
);

sort comp_stats (get_stats ());
