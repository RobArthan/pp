=TEX
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex

\def\Title{ Detailed Design: Theory of Real Numberss }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document gives the detailed design for the theory
of real numbers in \ProductHOL.}
\end{center}}

\def\Reference{LEMMA1/HOL/DTD116}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.2 $%
}
\def\Date{\FormatDate{$Date: 2000/12/06 10:36:24 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\newpage
\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1, 1.2] Initial development drafts.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

Some of the material in this document might more usefully be shipped into a separate
document extending the facilities for natural numbers.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}

Lemma 1 build system.

\newpage

\section{Introduction}
\subsection{Scope}
The real numbers are constructed in HOL using the positive dyadic rational numbers
under multiplication to provide an ordered algebraic system whose completion
provides the reals.
This construction is carried out in \cite{LEMMA1/HOL/DTD116}.
This module provides the necessary algebraic and order-theoretic facts about
this system of numbers.


\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD011}.


\section{PREAMBLE}
=SML
force_delete_theory"reals" handle Fail _ => ();
open_theory"dyadic";
set_merge_pcs["basic_hol", "'ú", "'sets_alg"];
new_theory"¯";
new_parent"orders";
=THDOC
req_name Û"¯"İ (Value "dyadic");
req_parent "orders";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $reals$ contains a theory of real numbers for HOL.
=ENDDOC

=TEX
\section {DEFINITION OF FIXITY}
=SML
declare_infix(210, "<‰R");
declare_infix(210, "¼‰R");
declare_infix(210, ">‰R");
declare_infix(210, "¾‰R");
declare_infix(300, "+‰R");
declare_infix(300, "-‰R");
declare_infix(310, "*‰R");
declare_infix(315, "/");
declare_infix(315, "/‰R");
declare_infix(315, "/‰N");
declare_infix(320, "^‰N");
=TEX
\section{DEFINITIONS}
\subsection{The New Type}

¹HOLCONST
Ü	Is_¯_Rep : DYADIC SET ­ BOOL
÷
Ü	µa· Is_¯_Rep a ¤ a  Cuts(Universe, $dy_less)
°
=TEX
We now show that the above definition is consistent.
The only tiny difficulty is using the balance theorems to show
that the universe of dyadics is bounded neither above nor below.
In particular, the latter property lets us apply the result from the theory of orders that
says when a downset is a cut:
=SML
local
open Dyadic;
in
val _ = (
set_goal([], ¬
	LinearOrder (Universe, $dy_less) ±
	UnboundedBelow (Universe, $dy_less) ±
	UnboundedAbove (Universe, $dy_less) ±
	Universe DenseIn (Universe, $dy_less)®);
a(rewrite_tac(dy_less_dense_thm::dy_less_irrefl_thm::
	dy_less_antisym_thm::dy_less_trans_thm::dy_less_trich_thm::
	(map get_spec[¬Irrefl®, ¬Antisym®, ¬Trans®, ¬Trich®, 
		¬PartialOrder®, ¬LinearOrder®, ¬UnboundedBelow®,
	¬UnboundedAbove®, ¬$DenseIn®])));
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac(µ_elim¬x:DYADIC® dy_balance_thm2));
a(all_fc_tac[µ_elim¬b®dy_times_mono_thm]);
a(SPEC_NTH_ASM_T 1 ¬b® ante_tac THEN rewrite_tac[dy_times_unit_clauses]);
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac(µ_elim¬x:DYADIC® dy_balance_thm1));
a(all_fc_tac[µ_elim¬b®dy_times_mono_thm]);
a(SPEC_NTH_ASM_T 1 ¬b® ante_tac THEN rewrite_tac[dy_times_unit_clauses]);
a(contr_tac THEN all_asm_fc_tac[]);
save_thm("dy_less_order_lemmas_thm", pop_thm())
);
=SML
val _ = (
set_goal([], ¬¶a·Is_¯_Rep a®);
a(lemma_tac¬
	Trans (Universe, $dy_less) ±
	UnboundedBelow (Universe, $dy_less) ±
	Universe DenseIn (Universe, $dy_less)®);
(* *** Goal "1" *** *)
a(strip_asm_tac (get_thm"-""dy_less_order_lemmas_thm") THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 4 ante_tac THEN rewrite_tac[get_spec¬LinearOrder®, get_spec¬PartialOrder®]
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LEMMA_T ¬dy_one  Universe® asm_tac THEN1 rewrite_tac[]);
a(all_fc_tac[downset_cut_thm]);
a(¶_tac¬DownSet (Universe, $dy_less, dy_one)® THEN asm_rewrite_tac[get_spec¬Is_¯_Rep®]);
save_thm("is_¯_rep_consistent_thm", pop_thm())
);
end;
=TEX
Now we can define the new type:
=SML
val _ = new_type_defn(["¯", "¯_def"], "¯", [],
	get_thm"-""is_¯_rep_consistent_thm");
=TEX
\subsection{Constants}
We now define the ordering relation. Its characterising property is
that it its a complete linear order which admits an inyection
of the dyadic rationals as a dense subset.
¹HOLCONST
Ü	$<‰R: ¯ ­ ¯ ­ BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	LinearOrder(Universe, $<‰R)
Ü±	UnboundedBelow(Universe, $<‰R)
Ü±	UnboundedAbove(Universe, $<‰R)
Ü±	Complete(Universe, $<‰R)
Ü
Ü± 	¶É : DYADIC ­ ¯·
Ü		(µa b· É a <‰R É b ¤ a dy_less b)
Ü	±	{x | ¶a·É a = x} DenseIn (Universe, $<‰R)
°
=SML
declare_alias("<", ¬$<‰R®);
=TEX
The other relational operators are then defined in terms of less-than.

¹HOLCONST
Ü	$¼‰R: ¯ ­ ¯ ­ BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µx y· x ¼‰R y ¤ x < y ² x = y
°
=SML
declare_alias("¼", ¬$¼‰R®);
¹HOLCONST
Ü	$>‰R: ¯ ­ ¯ ­ BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µx y· x >‰R y ¤ y < x
°
=SML
declare_alias(">", ¬$>‰R®);
¹HOLCONST
Ü	$¾‰R: ¯ ­ ¯ ­ BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µx y· x ¾‰R y ¤ y ¼ x
°
=SML
declare_alias("¾", ¬$¾‰R®);
=TEX

¹HOLCONST
Ü	Sup: ¯ SET ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
ÜµA·	³A = {} ±  (¶b· µx· x  A ´ x ¼ b)
Ü´	 (µx·x  A ´ x ¼ Sup A) ± (µb· (µx·x  A ´ x ¼ b) ´ Sup A ¼ b)
°

Addition is then characterised by the ordered group axioms together with the
existence of a positive element in the group.

¹HOLCONST
Ü	$+‰R: ¯ ­ ¯ ­ ¯;
Ü	0‰R 1‰R: ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	(µx y z· (x +‰R y) +‰R z = x +‰R (y +‰R z))
Ü
Ü±	(µx y· x +‰R y = y +‰R x)
Ü
Ü±	(µx· x +‰R 0‰R = x)
Ü
Ü±	(µx· ¶y· x +‰R y = 0‰R)
Ü
Ü±	(µx y z· y <‰R z ´ x +‰R y <‰R x +‰R z)
Ü
Ü±	0‰R <‰R 1‰R
°
=SML
declare_alias("+", ¬$+‰R®);
=TEX
Negation:

¹HOLCONST
Ü	$~‰R: ¯ ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µx· x + ~‰R x = 0‰R
°
=SML
declare_alias("~", ¬~‰R®);
=TEX
Subtraction:

¹HOLCONST
Ü	$-‰R: ¯ ­ ¯ ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µx y· x -‰R y = x + ~y
°
=SML
declare_alias("-", ¬$-‰R®);
=TEX
Embedding of the natural numbers:

¹HOLCONST
Ü	î¯: î ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	î¯ 0 = 0‰R
Ü±	(µm· î¯ (m + 1) = î¯ m +  1‰R)
°
=TEX
Absolute value:

¹HOLCONST
Ü	Abs‰R: ¯ ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Üµx·	Abs‰R x = if î¯ 0 ¼ x then x else ~ x
°
=SML
declare_alias("Abs", ¬Abs‰R®);
=TEX
Multiplication:

¹HOLCONST
Ü	$*‰R: ¯ ­ ¯ ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	(µx y z· (x *‰R y) *‰R z = x *‰R (y *‰R z))
Ü
Ü±	(µx·x *‰R î¯ 1 = x)
Ü
Ü±	(µx y z· x *‰R (y + z) = x *‰R y + x *‰R z)
Ü
Ü±	(µx y· x *‰R y = y *‰R x)
Ü
Ü±	(µx y· î¯ 0 < x ± î¯ 0 < y ´ î¯ 0 < x *‰R y)
°
=SML
declare_alias("*", ¬$*‰R®);
=TEX
Division:

¹HOLCONST
Ü	$/‰R: ¯ ­ ¯ ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	(µy z· ³z = î¯ 0 ´ (y * z) /‰R z = y)
Ü±	(µx y z· ³z = î¯ 0 ´ (x * y) /‰R z = x * (y /‰R z))
°
=SML
declare_alias("/", ¬$/‰R®);
=TEX
Division of one natural number by another

¹HOLCONST
Ü	$/‰N: î ­ î ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	(µm n· m /‰N n = î¯ m / î¯ n)
°
=SML
declare_alias("/", ¬$/‰N®);
=SML
declare_postfix(320, "›-›1");

=TEX
Reciprocal:

¹HOLCONST
Ü	$›-›1: ¯ ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Üµx·	x ›-›1 = î¯ 1/x
°
=TEX
Exponentiation (with natural number exponents):

¹HOLCONST
Ü	$^‰N: ¯ ­ î ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	(µx· x ^‰N 0 = î¯ 1)
Ü±	(µx m· x ^‰N (m + 1) = x * x ^‰N m)
°
=SML
declare_alias("^", ¬$^‰N®);
=TEX
\section{THEOREMS}
=THDOC
req_thm("dy_less_order_lemmas_thm",
		([], ¬ LinearOrder (Universe, $dy_less)
		    ± UnboundedBelow (Universe, $dy_less)
		    ± UnboundedAbove (Universe, $dy_less)
		    ± Universe DenseIn (Universe, $dy_less)®));
req_thm("is_¯_rep_consistent_thm",
		([], ¬ ¶ a· Is_¯_Rep a®));
req_consistency_thm¬ $<‰R ®;
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_unbounded_below_thm",
		([], ¬ µ x: ¯· ¶ y· y < x®));
req_thm("¯_unbounded_above_thm",
		([], ¬ µ x: ¯· ¶ y· x < y®));
req_thm("¯_less_irrefl_thm",
		([], ¬ µ x: ¯· ³ x < x®));
req_thm("¯_less_antisym_thm",
		([], ¬ µ x y: ¯· ³ (x < y ± y < x)®));
req_thm("¯_less_trans_thm",
		([], ¬ µ x y z: ¯· x < y ± y < z ´ x < z®));
req_thm("¯_less_cases_thm",
		([], ¬ µ x y: ¯· x < y ² x = y ² y < x®));
req_thm("¯_¼_cases_thm",([], ¬ µ x y: ¯· x ¼ y ² y ¼ x ®));
req_thm("¯_¼_less_cases_thm",
		([], ¬ µ x y: ¯· x ¼ y ² y < x®));
req_thm("¯_eq_¼_thm",([], ¬ µ x y: ¯· x = y ¤ x ¼ y ± y ¼ x ®));
req_thm("¯_less_¼_trans_thm",
		([], ¬ µ x y z: ¯· x < y ± y ¼ z ´ x < z®));
req_thm("¯_¼_less_trans_thm",
		([], ¬ µ x y z: ¯· x ¼ y ± y < z ´ x < z®));
req_thm("¯_¼_refl_thm",([], ¬ µ x: ¯· x ¼ x ®));
req_thm("¯_¼_trans_thm",([], ¬ µ x y z: ¯· x ¼ y ± y ¼ z ´ x ¼ z ®));
req_thm("¯_¼_³_less_thm",([], ¬ µ x y: ¯· x ¼ y ¤ ³ y < x ®));
req_thm("¯_³_¼_less_thm",([], ¬ µ x y: ¯· ³ x ¼ y ¤ y < x ®));
req_thm("¯_less_³_eq_thm",([], ¬ µ x y: ¯· x < y ´ ³ x = y ®));
req_thm("¯_less_dense_thm",
		([], ¬ µ x y: ¯· x < y ´ (¶ z: ¯· x < z ± z < y)®));
req_thm("¯_complete_thm",([], ¬ µ A 
		  · ³ A = {} ± (¶ b· µ x· x  A ´ x ¼ b)
		      ´ (¶ s: ¯· (µ x· x  A ´ x ¼ s)
		          ± (µ b· (µ x· x  A ´ x ¼ b) ´ s ¼ b))®));
=DESCRIBE
=ENDDOC
=THDOC
req_consistency_thm¬ Sup ®;
req_thm("¯_sup_thm",([], ¬ µ A a 
		  · ³ A = {} ± (µ x: ¯· x  A ´ x ¼ a)
		      ´ (µ x· x  A ´ x ¼ Sup A)
		        ± (µ b· (µ x· x  A ´ x ¼ b) ´ Sup A ¼ b)®));
req_thm("¯_less_sup_thm",([], ¬ µ A 
		  · ³ A = {} ± (¶ a: ¯· µ x· x  A ´ x ¼ a)
		      ´ (µ x: ¯· x < Sup A ¤ (¶ y· y  A ± x < y))®));
req_thm("¯_less_sup_bc_thm",
		([], ¬ µ A
		  · ³ A = {} ± (¶ a: ¯· µ x· x  A ´ x ¼ a) ± (¶ y· y  A ± x < y)
		      ´ x < Sup A®));
req_thm("¯_¼_sup_thm",([], ¬ µ A a 
		  · ³ A = {} ± (¶ a: ¯· µ x· x  A ´ x ¼ a)
		      ´ (µ x· x ¼ Sup A ¤ (µ y· (µ z· z  A ´ z ¼ y) ´ x ¼ y))®));
req_thm("¯_¼_sup_bc_thm",([], ¬ µ A a x 
		  · ³ A = {}
		        ± (¶ a: ¯· µ x· x  A ´ x ¼ a)
		        ± (µ y· (µ z· z  A ´ z ¼ y) ´ x ¼ y)
		      ´ x ¼ Sup A®));
req_thm("¯__¼_sup_bc_thm",
		([], ¬ µ A x· x  A ± (¶ a: ¯· µ x· x  A ´ x ¼ a) ´ x ¼ Sup A®));
req_thm("¯_€_sup_thm",([], ¬ µ A B 
		  · ³ A = {}
		        ± (¶ a: ¯· µ x· x  A ´ x ¼ a)
		        ± ³ B = {}
		        ± (¶ b· µ y· y  B ´ y ¼ b)
		        ± A € B
		      ´ Sup A ¼ Sup B®));
req_thm("¯_sup_¼_bc_thm",([], ¬ µ A a x 
		  · ³ A = {} ± (¶ a: ¯· µ x· x  A ´ x ¼ a) ± (µ y· y  A ´ y ¼ x)
		      ´ Sup A ¼ x®));
req_thm("¯_sup_less_bc_thm",
		([], ¬ µ A x z
		  · ³ A = {}
		        ± (¶ a: ¯· µ x· x  A ´ x ¼ a)
		        ± (µ y· y  A ´ y ¼ x)
		        ± x < z
		      ´ Sup A < z®));
req_thm("¯_sup_eq_bc_thm",([], ¬ µ A a s 
		  · ³ A = {}
		        ± (µ x: ¯· x  A ´ x ¼ s)
		        ± (µ x· (µ y· y  A ´ y ¼ x) ´ s ¼ x)
		      ´ Sup A = s®));
req_thm("¯_eq_sup_bc_thm",([], ¬ µ A a s 
		  · ³ A = {}
		        ± (µ x: ¯· x  A ´ x ¼ s)
		        ± (µ x· (µ y· y  A ´ y ¼ x) ´ s ¼ x)
		      ´ s = Sup A®));
req_thm("¯_less_sup__thm",
		([], ¬ µ A a
		  · ³ A = {} ± (µ x: ¯· x  A ´ x ¼ a) ± ³ Sup A  A
		      ´ (µ x· x < Sup A ´ (¶ y· x < y ± y < Sup A ± y  A))®));
=DESCRIBE
=ENDDOC
=THDOC
req_consistency_thm¬$+‰R®;
req_consistency_thm¬0‰R®;
req_consistency_thm¬1‰R®;
req_consistency_thm¬~‰R®;
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_plus_assoc_thm",
		([], ¬ µ x y z: ¯· (x + y) + z = x + y + z®));
req_thm("¯_plus_comm_thm",([], ¬ µ x y: ¯· x + y = y + x ®));
req_thm("¯_plus_unit_thm",([], ¬ µ x: ¯· x + 0‰R = x ®));
req_thm("¯_plus_mono_thm",([], ¬ µ x y z: ¯· y < z ´ x + y < x + z ®));
req_thm("¯_plus_assoc_thm1",
		([], ¬ µ x y z: ¯· x + y + z = (x + y) + z®));
req_thm("¯_plus_mono_thm1",
		([], ¬ µ x y z: ¯· y < z ´ y + x < z + x®));
req_thm("¯_plus_mono_thm2",
		([], ¬ µ x y s t: ¯· x < y ± s < t ´ x + s < y + t®));
req_thm("¯_plus_0_thm",([], ¬ µ x: ¯· x + î¯ 0 = x ± î¯ 0 + x = x ®));
req_thm("¯_0_1_thm",([], ¬ 0‰R = î¯ 0 ± 1‰R = î¯ 1 ®));
req_thm("¯_plus_order_thm",
		([], ¬ µ x y z: ¯· y + x = x + y
		      ± (x + y) + z = x + y + z
		      ± y + x + z = x + y + z®));
req_thm("¯_plus_minus_thm",
		([], ¬ µ x: ¯· x + ~ x = î¯ 0 ± ~ x + x = î¯ 0®));
req_thm("¯_eq_thm",([], ¬ µ x y: ¯· x = y ¤ x + ~ y = î¯ 0 ®));
req_thm("î¯_plus_homomorphism_thm",
		([], ¬ µ m n· î¯ (m + n) = î¯ m + î¯ n®));
req_thm("¯_minus_clauses",([], ¬ µ x y 
		  · ~ (~ x) = x
		      ± x + ~ x = î¯ 0
		      ± ~ x + x = î¯ 0
		      ± ~ (x + y) = ~ x + ~ y
		      ± ~ (î¯ 0) = î¯ 0®));
req_thm("¯_minus_eq_thm",([], ¬ µ x y: ¯· ~ x = ~ y ¤ x = y ®));
req_thm("î¯_0_less_thm",([], ¬ µ m· î¯ 0 < î¯ (m + 1) ®));
req_thm("î¯_one_one_thm",([], ¬ µ m n· î¯ m = î¯ n ¤ m = n ®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_plus_clauses",([], ¬ µ x y z : ¯·
		         (x + z = y + z ¤ x = y)
		      ± (z + x = y + z ¤ x = y)
		      ± (x + z = z + y ¤ x = y)
		      ± (z + x = z + y ¤ x = y)
		      ± (x + z = z ¤ x = î¯ 0)
		      ± (z + x = z ¤ x = î¯ 0)
		      ± (z = z + y ¤ y = î¯ 0)
		      ± (z = y + z ¤ y = î¯ 0)
		      ± x + î¯ 0 = x
		      ± î¯ 0 + x = x
		      ± ³ î¯ 1 = î¯ 0
		      ± ³ î¯ 0 = î¯ 1®));
req_thm("¯_less_less_0_thm",
		([], ¬ µ x y· x < y ¤ x + ~ y < î¯ 0®));
req_thm("¯_less_clauses",([], ¬ µ x y z : ¯·
		        (x + z < y + z ¤ x < y)
		      ± (z + x < y + z ¤ x < y)
		      ± (x + z < z + y ¤ x < y)
		      ± (z + x < z + y ¤ x < y)
		      ± (x + z < z ¤ x < î¯ 0)
		      ± (z + x < z ¤ x < î¯ 0)
		      ± (x < z + x ¤ î¯ 0 < z)
		      ± (x < x + z ¤ î¯ 0 < z)
		      ± ³ x < x
		      ± î¯ 0 < î¯ 1
		      ± ³ î¯ 1 < î¯ 0®));
req_thm("¯_less_0_less_thm",
		([], ¬ µ x y· x < y ¤ î¯ 0 < y + ~ x®));
req_thm("¯_¼_clauses",([], ¬ µ x y z: ¯·
		        (x + z ¼ y + z ¤ x ¼ y)
		      ± (z + x ¼ y + z ¤ x ¼ y)
		      ± (x + z ¼ z + y ¤ x ¼ y)
		      ± (z + x ¼ z + y ¤ x ¼ y)
		      ± (x + z ¼ z ¤ x ¼ î¯ 0)
		      ± (z + x ¼ z ¤ x ¼ î¯ 0)
		      ± (x ¼ z + x ¤ î¯ 0 ¼ z)
		      ± (x ¼ x + z ¤ î¯ 0 ¼ z)
		      ± x ¼ x
		      ± î¯ 0 ¼ î¯ 1
		      ± ³ î¯ 1 ¼ î¯ 0®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_¼_¼_0_thm",([], ¬ µ x y· x ¼ y ¤ x + ~ y ¼ î¯ 0 ®));
req_thm("¯_¼_0_¼_thm",([], ¬ µ x y· x ¼ y ¤ î¯ 0 ¼ y + ~ x ®));
req_thm("î¯_less_thm",([], ¬ µ m n· î¯ m < î¯ n ¤ m < n ®));
req_thm("¯_less_strong_dense_thm",
		([], ¬ µ x y· x < y ´ (¶ d· î¯ 0 < d ± x + d < y)®));
req_thm("î¯_¼_thm",([], ¬ µ m n· î¯ m ¼ î¯ n ¤ m ¼ n ®));
req_thm("¯_sup_plus_thm",([], ¬ µ A a x 
		  · ³ A = {} ± (µ x· x  A ´ x ¼ a)
		      ´ Sup A + x = Sup {t|¶ a· a  A ± t < a + x}®));
req_thm("¯_sup_plus_sup_thm",
		([], ¬ µ A a B b
		  · ³ A = {}
		        ± (µ x· x  A ´ x ¼ a)
		        ± ³ B = {}
		        ± (µ y· y  B ´ y ¼ b)
		      ´ Sup A + Sup B = Sup {t|¶ a b· a  A ± b  B ± t < a + b}®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_delta_induction_thm",
		([], ¬ µ x p
		  · (¶ d
		      · î¯ 0 < d
		          ± (¶ e· d < e ± (µ t· x < t ± t < x + e ´ p t))
		          ± (µ s· x < s ± p s ´ p (s + d)))
		      ´ (µ y· x < y ´ p y)®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_ord_pres_strict_thm",
		([], ¬ µ f : ¯ ­ ¯·
	(µ x y· x < y ´ f x < f y) ´ (µ x y· f x < f y ´ x < y)®));
req_thm("¯_add_hom_0_thm",([], ¬ µ f : ¯ ­ ¯·
	(µ x y· f (x + y) = f x + f y) ´ (µ x· f (î¯ 0) = î¯ 0) ®));
req_thm("¯_add_hom_minus_thm",
		([], ¬ µ f : ¯ ­ ¯·
	(µ x y· f (x + y) = f x + f y) ´ (µ x· f (~ x) = ~ (f x))®));
req_thm("¯_add_hom_extension_thm",
		([], ¬ µ f : ¯ ­ ¯· (µ x y· î¯ 0 ¼ x ± î¯ 0 ¼ y ´ f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 ¼ x ´ f (~ x) = ~ (f x))
		      ´ (µ x y· f (x + y) = f x + f y)®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_monoid_delta_dense_thm",
		([], ¬ µ G d
		  · î¯ 0  G
		        ± (µ g h· g  G ± h  G ´ g + h  G)
		        ± d  G
		        ± î¯ 0 < d
		      ´ (µ x· î¯ 0 < x ´ (¶ g· g  G ± g ¼ x ± x < g + d))®));
req_thm("¯_monoid_dense_thm",
		([], ¬ µ G
		  · î¯ 0  G
		        ± (µ g h· g  G ± h  G ´ g + h  G)
		        ± (µ x· î¯ 0 < x ´ (¶ g· g  G ± î¯ 0 < g ± g < x))
		      ´ (µ x y· î¯ 0 < x ± x < y ´ (¶ g· g  G ± x < g ± g < y))®));
req_thm("¯_subgroup_dense_thm",
		([], ¬ µ G
		  · î¯ 0  G
		        ± (µ g h· g  G ± h  G ´ g + h  G)
		        ± (µ g· g  G ´ ~ g  G)
		        ± (µ x· î¯ 0 < x ´ (¶ g· g  G ± î¯ 0 < g ± g < x))
		      ´ (µ x y· x < y ´ (¶ g· g  G ± x < g ± g < y))®));
req_thm("¯_semigroup_dense_thm",
		([], ¬ µ G
		  · (µ g h· g  G ± h  G ´ g + h  G)
		        ± (µ x· î¯ 0 < x ´ (¶ g· g  G ± î¯ 0 < g ± g < x))
		      ´ (µ x y· î¯ 0 < x ± x < y ´ (¶ g· g  G ± x < g ± g < y))®));
req_thm("¯_add_hom_image_group_thm",
		([], ¬ µ f : ¯ ­ ¯· (µ x y· f (x + y) = f x + f y) ± I = {b|¶ a· b = f a}
		      ´ î¯ 0  I
		        ± (µ g h· g  I ± h  I ´ g + h  I)
		        ± (µ g· g  I ´ ~ g  I)®));
req_thm("¯_add_hom_kernel_group_thm",
		([], ¬ µ f
		  · (µ x y· f (x + y) = f x + f y) ± K = {a|f a = î¯ 0}
		      ´ î¯ 0  K
		        ± (µ g h· g  K ± h  K ´ g + h  K)
		        ± (µ g· g  K ´ ~ g  K)®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_opah_thm",([], ¬ µ f : ¯ ­ ¯· (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		      ´ (µ x y· x < y ´ f x < f y)®));
req_thm("¯_opah_strict_thm",
		([], ¬ µ f : ¯ ­ ¯· (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		      ´ (µ x y· f x < f y ´ x < y)®));
req_thm("¯_opah_one_one_thm",
		([], ¬ µ f : ¯ ­ ¯· (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		      ´ OneOne f®));
req_thm("¯_opah_dense_image_thm",
		([], ¬ µ f : ¯ ­ ¯; e· (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		        ± î¯ 0 < e
		      ´ (¶ d· î¯ 0 < d ± f d < e)®));
req_thm("¯_opah_onto_thm",([], ¬ µ f  : ¯ ­ ¯· (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		      ´ Onto f®));
req_thm("¯_opah_inverse_add_hom_thm",
		([], ¬ µ f g : ¯ ­ ¯· (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		        ± (µ x· g (f x) = x)
		        ± (µ x· f (g x) = x)
		      ´ (µ x y· g (x + y) = g x + g y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < g x)®));
req_thm("¯_opah_inverse_thm",
		([], ¬ µ f : ¯ ­ ¯· (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		      ´ (¶ g: ¯ ­ ¯·
			   (µ x· g (f x) = x)
		          ± (µ x· f (g x) = x)
		          ± (µ x y· g (x + y) = g x + g y)
		          ± (µ x· î¯ 0 < x ´ î¯ 0 < g x))®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_copah_id_thm",([], ¬ ¶ É 
		  · (µ x· É x = x)
		      ± (µ x y· É (x + y) = É x + É y)
		      ± (µ x· î¯ 0 < x ´ î¯ 0 < É x)
		      ± (µ f
		      · (µ x y· f (x + y) = f x + f y)
		          ´ (µ x· É (f x) = f (É x)))®));
req_thm("¯_copah_double_thm",
		([], ¬ ¶ Á
		  · (µ x· Á x = x + x)
		      ± (µ x y· Á (x + y) = Á x + Á y)
		      ± (µ x· î¯ 0 < x ´ î¯ 0 < Á x)
		      ± (µ x· î¯ 0 < x ´ x < Á x)
		      ± (µ f
		      · (µ x y· f (x + y) = f x + f y)
		          ´ (µ x· Á (f x) = f (Á x)))®));
req_thm("¯_copah_halve_thm",
		([], ¬ ¶ Â
		  · (µ x· Â x + Â x = x)
		      ± (µ x y· Â (x + y) = Â x + Â y)
		      ± (µ x· î¯ 0 < x ´ î¯ 0 < Â x)
		      ± (µ x· î¯ 0 < x ´ Â x < x)
		      ± (µ f
		      · (µ x y· f (x + y) = f x + f y)
		          ´ (µ x· Â (f x) = f (Â x)))®));
req_thm("¯_copah_comp_thm",
		([], ¬ µ Á Â
		  · (µ x y· Á (x + y) = Á x + Á y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < Á x)
		        ± (µ f
		        · (µ x y· f (x + y) = f x + f y)
		            ´ (µ x· Á (f x) = f (Á x)))
		        ± (µ x y· Â (x + y) = Â x + Â y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < Â x)
		        ± (µ f
		        · (µ x y· f (x + y) = f x + f y)
		            ´ (µ x· Â (f x) = f (Â x)))
		      ´ (¶ Ç
		      · (µ x· Ç x = Á (Â x))
		          ± (µ x· î¯ 0 < x ´ î¯ 0 < Ç x)
		          ± (µ x y· Ç (x + y) = Ç x + Ç y)
		          ± (µ f
		          · (µ x y· f (x + y) = f x + f y)
		              ´ (µ x· Ç (f x) = f (Ç x))))®));
req_thm("¯_copah_sum_thm",([], ¬ µ Á Â 
		  · (µ x y· Á (x + y) = Á x + Á y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < Á x)
		        ± (µ f
		        · (µ x y· f (x + y) = f x + f y)
		            ´ (µ x· Á (f x) = f (Á x)))
		        ± (µ x y· Â (x + y) = Â x + Â y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < Â x)
		        ± (µ f
		        · (µ x y· f (x + y) = f x + f y)
		            ´ (µ x· Â (f x) = f (Â x)))
		      ´ (¶ Ç
		      · (µ x· Ç x = Á x + Â x)
		          ± (µ x· î¯ 0 < x ´ î¯ 0 < Ç x)
		          ± (µ x y· Ç (x + y) = Ç x + Ç y)
		          ± (µ f
		          · (µ x y· f (x + y) = f x + f y)
		              ´ (µ x· Ç (f x) = f (Ç x))))®));
req_thm("¯_halve_closed_dense_thm",
		([], ¬ µ A e
		  · î¯ 0 < e ± e  A ± (µ y· y  A ´ (¶ z· z  A ± z + z = y))
		      ´ (µ d· î¯ 0 < d ´ (¶ a· a  A ± î¯ 0 < a ± a < d))®));
req_thm("¯_copah_dense_thm",
		([], ¬ µ d x y
		  · î¯ 0 < d ± î¯ 0 < x ± x < y
		      ´ (¶ Ç
		      · (µ x y· Ç (x + y) = Ç x + Ç y)
		          ± (µ x· î¯ 0 < x ´ î¯ 0 < Ç x)
		          ± (µ f
		          · (µ x y· f (x + y) = f x + f y)
		              ´ (µ x· Ç (f x) = f (Ç x)))
		          ± x < Ç d
		          ± Ç d < y)®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_opah_extension_thm1",
		([], ¬ µ f
		  · (µ x y· î¯ 0 < x ± î¯ 0 < y ´ f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		      ´ (¶ Æ
		      · Æ (î¯ 0) = î¯ 0
		          ± (µ x· î¯ 0 < x ´ Æ x = f x)
		          ± (µ x y
		          · î¯ 0 ¼ x ± î¯ 0 ¼ y ´ Æ (x + y) = Æ x + Æ y))®));
req_thm("¯_opah_extension_thm2",
		([], ¬ µ f
		  · f (î¯ 0) = î¯ 0
		        ± (µ x y· î¯ 0 ¼ x ± î¯ 0 ¼ y ´ f (x + y) = f x + f y)
		      ´ (¶ Ù
		      · (µ x· î¯ 0 ¼ x ´ Ù x = f x)
		          ± (µ x y· Ù (x + y) = Ù x + Ù y))®));
req_thm("¯_opah_extension_thm",
		([], ¬ µ f
		  · (µ x y· î¯ 0 < x ± î¯ 0 < y ´ f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		      ´ (¶ Æ
		      · (µ x· î¯ 0 < x ´ Æ x = f x)
		          ± (µ x y· Æ (x + y) = Æ x + Æ y)
		          ± (µ x· î¯ 0 < x ´ î¯ 0 < Æ x))®));
req_thm("¯_opah_order_thm",
		([], ¬ µ f g d
		  · (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		        ± (µ x y· g (x + y) = g x + g y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < g x)
		        ± î¯ 0 < d
		        ± f d < g d
		      ´ (µ x· î¯ 0 < x ´ f x < g x)®));
req_thm("¯_opah_eq_thm",([], ¬ µ f g d 
		  · (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		        ± (µ x y· g (x + y) = g x + g y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < g x)
		        ± î¯ 0 < d
		        ± f d = g d
		      ´ f = g®));
req_thm("¯_opah_complete_thm",
		([], ¬ µ d e
		  · î¯ 0 < d ± î¯ 0 < e
		      ´ (¶ f
		      · (µ x y· f (x + y) = f x + f y)
		          ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		          ± f d = e)®));
=DESCRIBE
=ENDDOC
=THDOC
req_consistency_thm¬ $*‰R ®;
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_times_assoc_thm",
		([], ¬ µ x y z: ¯· (x * y) * z = x * y * z®));
req_thm("¯_times_comm_thm",
		([], ¬ µ x y: ¯· x * y = y * x®));
req_thm("¯_times_unit_thm",
		([], ¬ µ x· x * î¯ 1 = x®));
req_thm("¯_0_less_0_less_times_thm",
		([], ¬ µ x y· î¯ 0 < x ± î¯ 0 < y ´ î¯ 0 < x * y®));
req_thm("¯_times_assoc_thm1",
		([], ¬ µ x y z: ¯· x * y * z = (x * y) * z®));
req_thm("¯_times_plus_distrib_thm",
		([], ¬ µ x y z: ¯·
	x * (y + z) = x * y + x * z ± (x + y) * z = x * z + y * z®));
req_thm("¯_times_order_thm",
		([], ¬ µ x y z: ¯· y * x = x * y
		      ± (x * y) * z = x * y * z
		      ± y * x * z = x * y * z®));
req_thm("¯_times_0_thm",([], ¬ µ x· x * î¯ 0 = î¯ 0 ± î¯ 0 * x = î¯ 0 ®));
req_thm("¯_times_1_thm",([], ¬ µ x· x * î¯ 1 = x ± î¯ 1 * x = x ®));
req_thm("î¯_times_homomorphism_thm",
		([], ¬ µ m n· î¯ (m * n) = î¯ m * î¯ n®));
=DESCRIBE
=ENDDOC
=THDOC
req_consistency_thm¬ $/‰R ®;
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_over_times_recip_thm",
		([], ¬ µ z· ³ z = î¯ 0 ´ (µ x· x / z = x * z ›-›1)®));
req_thm("¯_times_recip_thm",
		([], ¬ µ z· ³ z = î¯ 0 ´ z * z ›-›1 = î¯ 1®));
req_thm("¯_eq_recip_thm",([], ¬ µ z· ³ z = î¯ 0 ´ (µ y· y = z ¤ y * z ›-›1 = î¯ 1) ®));
req_thm("¯_times_cancel_thm",
		([], ¬ µ x y z· ³ z = î¯ 0 ´ (x * z = y * z ¤ x = y)®));
req_thm("¯_times_eq_0_thm",
		([], ¬ µ x y· x * y = î¯ 0 ¤ x = î¯ 0 ² y = î¯ 0®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_times_clauses",([], ¬ µ x 
		  · î¯ 0 * x = î¯ 0
		      ± x * î¯ 0 = î¯ 0
		      ± x * î¯ 1 = x
		      ± î¯ 1 * x = x®));
req_thm("¯_times_mono_¤_thm",
		([], ¬ µ x· î¯ 0 < x ´ (µ y z· y < z ¤ x * y < x * z)®));
req_thm("¯_times_mono_thm",
		([], ¬ µ x y z· î¯ 0 < x ± y < z ´ x * y < x * z®));
req_thm("¯_0_¼_0_¼_times_thm",
		([], ¬ µ x y· î¯ 0 ¼ x ± î¯ 0 ¼ y ´ î¯ 0 ¼ x * y®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_³_recip_0_thm",([], ¬ µ z· ³ z = î¯ 0 ´ ³ z ›-›1 = î¯ 0 ®));
req_thm("¯_recip_clauses",([], ¬ (î¯ 1 ›-›1 = î¯ 1 
		      ± (µ w
		      · ³ w = î¯ 0
		          ´ w ›-›1 ›-›1 = w
		            ± w * w ›-›1 = î¯ 1
		            ± w ›-›1 * w = î¯ 1))
		    ± (µ w z
		    · ³ w = î¯ 0 ± ³ z = î¯ 0 ´ (w * z) ›-›1 = w ›-›1 * z ›-›1)®));
req_thm("¯_cross_mult_eq_thm",
		([], ¬ µ w z
		  · ³ w = î¯ 0 ± ³ z = î¯ 0
		      ´ (µ x y· x / w = y / z ¤ x * z = w * y)®));
req_thm("¯_less_³_eq_0_thm",
		([], ¬ µ z· î¯ 0 < z ´ ³ z = î¯ 0®));
req_thm("¯_0_less_0_less_recip_thm",
		([], ¬ µ z· î¯ 0 < z ´ î¯ 0 < z ›-›1®));
req_thm("¯_cross_mult_less_thm",
		([], ¬ µ w z
		  · î¯ 0 < w ± î¯ 0 < z ´ (µ x y· x / w < y / z ¤ x * z < w * y)®));
req_thm("¯_over_cancel_eq_thm",
		([], ¬ µ w z
		  · ³ w = î¯ 0 ± ³ z = î¯ 0 ´ (µ x· (x * z) / (w * z) = x / w)®));
req_thm("¯_over_plus_over_thm",
		([], ¬ µ x y u v
		  · ³ u = î¯ 0 ± ³ v = î¯ 0
		      ´ x / u + y / v = (x * v + y * u) / (u * v)®));
req_thm("¯_0_over_thm",([], ¬ µ z· ³ z = î¯ 0 ´ î¯ 0 / z = î¯ 0 ®));
req_thm("¯_over_1_thm",([], ¬ µ x· x / î¯ 1 = x ®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("î¯_plus_homomorphism_thm1",
		([], ¬ µ m n· î¯ m + î¯ n = î¯ (m + n)®));
req_thm("î¯_times_homomorphism_thm1",
		([], ¬ µ m n· î¯ m * î¯ n = î¯ (m * n)®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_frac_cross_mult_eq_thm",
		([], ¬ µ m n i j
		  · i / (m + 1) = j / (n + 1) ¤ i * (n + 1) = j * (m + 1)®));
req_thm("¯_frac_cancel_eq_thm",
		([], ¬ µ i m n· (i * (n + 1)) / ((m + 1) * (n + 1)) = i / (m + 1)®));
req_thm("¯_frac_0_thm",([], ¬ µ m· 0 / (m + 1) = î¯ 0 ®));
req_thm("¯_frac_î_thm",([], ¬ µ i· i / 1 = î¯ i ®));
req_thm("¯_frac_plus_frac_thm",
		([], ¬ µ i j k m n
		  · i / (m + 1) + j / (n + 1)
		      = (i * (n + 1) + j * (m + 1)) / ((m + 1) * (n + 1))®));
req_thm("¯_frac_minus_frac_thm",
		([], ¬ µ i j k m n
		  · j * (m + 1) ¼ i * (n + 1)
		      ´ i / (m + 1) + ~ (j / (n + 1))
		        = (i * (n + 1) - j * (m + 1)) / ((m + 1) * (n + 1))®));
req_thm("¯_frac_minus_frac_thm1",
		([], ¬ µ i j m n
		  · i * (n + 1) ¼ j * (m + 1)
		      ´ i / (m + 1) + ~ (j / (n + 1))
		        = ~ ((j * (m + 1) - i * (n + 1)) / ((m + 1) * (n + 1)))®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_over_times_over_thm",
		([], ¬ µ x y u v
		  · ³ u = î¯ 0 ± ³ v = î¯ 0 ´ x / u * y / v = (x * y) / (u * v)®));
req_thm("¯_frac_times_frac_thm",
		([], ¬ µ i j m n
		  · i / (m + 1) * j / (n + 1) = (i * j) / ((m + 1) * (n + 1))®));
req_thm("¯_over_recip_thm",
		([], ¬ µ u v· ³ u = î¯ 0 ± ³ v = î¯ 0 ´ (u / v) ›-›1 = v / u®));
req_thm("¯_frac_recip_thm",
		([], ¬ µ m n· ((m + 1) / (n + 1)) ›-›1 = (n + 1) / (m + 1)®));
req_thm("¯_minus_recip_thm",
		([], ¬ µ z· ³ z = î¯ 0 ´ ~ z ›-›1 = ~ (z ›-›1)®));
req_thm("¯_over_eq_0_thm",([], ¬ µ u v· ³ u = î¯ 0 ± ³ v = î¯ 0 ´ ³ u / v = î¯ 0 ®));
req_thm("¯_over_over_over_thm",
		([], ¬ µ x y u v
		  · ³ u = î¯ 0 ± ³ v = î¯ 0 ± ³ y = î¯ 0
		      ´ (x / u) / y / v = (x * v) / (u * y)®));
req_thm("¯_frac_less_frac_thm",
		([], ¬ µ i j m n
		  · i / (m + 1) < j / (n + 1) ¤ i * (n + 1) < j * (m + 1)®));
req_thm("¯_minus_frac_less_frac_thm",
		([], ¬ µ i j m n· ~ (i / (m + 1)) < j / (n + 1) ¤ 0 < i + j®));
req_thm("¯_frac_less_minus_frac_thm",
		([], ¬ µ i j m n· ³ i / (m + 1) < ~ (j / (n + 1))®));
=DESCRIBE
=ENDDOC

=TEX
\section{SIGNATURE}
=SML
signature Û¯İ = sig
=TEX

\subsection{Syntax Functions}
Detailed design fragments to be shipped into the DTD on productisation:
=DOC
val Ûdest_¯_lessİ : TERM -> TERM * TERM;	(* <‰R *)
val Ûdest_¯_¼İ : TERM -> TERM * TERM	(* ¼‰R *);
val Ûdest_¯_greaterİ : TERM -> TERM * TERM	(* >‰R *);
val Ûdest_¯_¾İ : TERM -> TERM * TERM	(* ¾‰R *);
val Ûdest_¯_plusİ : TERM -> TERM * TERM	(* +‰R *);
val Ûdest_¯_subtractİ : TERM -> TERM * TERM	(* -‰R *);
val Ûdest_¯_timesİ : TERM -> TERM * TERM	(* *‰R *);
val Ûdest_¯_overİ : TERM -> TERM * TERM	(* /‰R *);
val Ûdest_¯_fracİ : TERM -> TERM * TERM	(* /‰N *);
val Ûdest_¯_minusİ : TERM -> TERM		(* ~‰R *);
val Ûdest_¯_absİ : TERM -> TERM		(* Abs‰R *);
val Ûdest_¯_recipİ : TERM -> TERM		(* ›-›1 *);
=DESCRIBE
These are the derived destructor functions for the basic
arithmetic operators on the real numbers. The ML comments
above give the name of the corresponding operators.
These names all have aliases without the subscript.
=FAILURE
116101	?0 is not of the form ¬x <‰R y®
116102	?0 is not of the form ¬x ¼‰R y®
116103	?0 is not of the form ¬x >‰R y®
116104	?0 is not of the form ¬x ¼‰R y®
116105	?0 is not of the form ¬x +‰R y®
116106	?0 is not of the form ¬x -‰R y®
116107	?0 is not of the form ¬x *‰R y®
116108	?0 is not of the form ¬x /‰R y®
116109	?0 is not of the form ¬x /‰N y®
116111	?0 is not of the form ¬~‰R y®
116112	?0 is not of the form ¬Abs‰R x®
116113	?0 is not of the form ¬x ›-›1®
=TEX
=SML
val Ûis_¯_lessİ : TERM -> bool	(* <‰R *);
val Ûis_¯_¼İ : TERM -> bool	(* ¼‰R *);
val Ûis_¯_greaterİ : TERM -> bool	(* >‰R *);
val Ûis_¯_¾İ : TERM -> bool	(* ¾‰R *);
val Ûis_¯_plusİ : TERM -> bool	(* +‰R *);
val Ûis_¯_subtractİ : TERM -> bool	(* -‰R *);
val Ûis_¯_timesİ : TERM -> bool	(* *‰R *);
val Ûis_¯_overİ : TERM -> bool	(* /‰R *);
val Ûis_¯_fracİ : TERM -> bool	(* /‰N *);
val Ûis_¯_minusİ : TERM -> bool	(* ~‰R *);
val Ûis_¯_absİ : TERM -> bool	(* Abs‰R *);
val Ûis_¯_recipİ : TERM -> bool	(* ›-›1 *);
=DESCRIBE
These are the derived discriminating functions for the basic
arithmetic operators on the real numbers. The ML comments
above give the name of the corresponding operators.
These names all have aliases without the subscript.
=ENDDOC

=DOC
val Ûmk_¯_lessİ : TERM * TERM -> TERM;	(* <‰R *)
val Ûmk_¯_¼İ : TERM * TERM -> TERM		(* ¼‰R *);
val Ûmk_¯_greaterİ : TERM * TERM -> TERM	(* >‰R *);
val Ûmk_¯_¾İ : TERM * TERM -> TERM	(* ¾‰R *);
val Ûmk_¯_plusİ : TERM * TERM -> TERM	(* +‰R *);
val Ûmk_¯_subtractİ : TERM * TERM -> TERM	(* -‰R *);
val Ûmk_¯_timesİ : TERM * TERM -> TERM	(* *‰R *);
val Ûmk_¯_overİ : TERM * TERM -> TERM	(* /‰R *);
val Ûmk_¯_fracİ : TERM * TERM -> TERM	(* /‰N *);
val Ûmk_¯_minusİ : TERM -> TERM		(* ~‰R *);
val Ûmk_¯_absİ : TERM -> TERM		(* Abs‰R *);
val Ûmk_¯_recipİ : TERM -> TERM		(* ›-›1 *);
=DESCRIBE
These are the derived constructor functions for the basic
arithmetic operators on the real numbers. The ML comments
above give the name of the corresponding operators.
These names all have aliases without the subscript.

The operands of
=INLINEFT
mk_¯_frac
=TEX
\ must be of type î.
All the other functions must have operands of type ¯.

=FAILURE
116201	?0 does not have type ”¯®
116202	?0 does not have type ”î®
=ENDDOC
\subsection{Definitions}
=DOC
val Û¯_plus_defİ : THM;		val Û¯_subtract_defİ : THM;
val Û¯_¼_defİ : THM;		val Û¯_less_defİ : THM;
val Û¯_greater_defİ : THM;		val Û¯_¾_defİ : THM;
val Û¯_minus_defİ : THM;		val Û¯_times_defİ : THM;
val Û¯_over_defİ : THM;		val Û¯_frac_defİ : THM;
val Ûî¯_defİ : THM;
=DESCRIBE
These are the ML bindings for the definitions in the theory ¯.
=ENDDOC
\subsection{Theorems}
=DOC
val Û¯_unbounded_below_thmİ : THM;	val Û¯_unbounded_above_thmİ : THM;
val Û¯_less_irrefl_thmİ : THM;	val Û¯_less_antisym_thmİ : THM;
val Û¯_less_trans_thmİ : THM;	val Û¯_less_cases_thmİ : THM;
val Û¯_¼_cases_thmİ : THM;		val Û¯_¼_less_cases_thmİ : THM;
val Û¯_eq_¼_thmİ : THM;		val Û¯_less_¼_trans_thmİ : THM;
val Û¯_¼_less_trans_thmİ : THM;	val Û¯_¼_refl_thmİ : THM;
val Û¯_¼_trans_thmİ : THM;		val Û¯_¼_³_less_thmİ : THM;
val Û¯_³_¼_less_thmİ : THM;	val Û¯_less_³_eq_thmİ : THM;
val Û¯_³_less_¼_thmİ : THM;	val Û¯_less_dense_thmİ : THM;
val Û¯_complete_thmİ : THM;
=DESCRIBE
These are the ML bindings for theorems in the theory ¯ concerned with basic properties
of the ordering relations. Note that $>$ and ¾ are defined in terms of $<$ and ¼
and the latter are the preferred form in all theorems in this theory.
=ENDDOC
=DOC
val Û¯_sup_thmİ : THM;		val Û¯_less_sup_thmİ : THM;
val Û¯_less_sup_bc_thmİ : THM;	val Û¯_¼_sup_thmİ : THM;
val Û¯_¼_sup_bc_thmİ : THM;	val Û¯__¼_sup_bc_thmİ : THM;
val Û¯_€_sup_thmİ : THM;		val Û¯_sup_¼_bc_thmİ : THM;
val Û¯_sup_less_bc_thmİ : THM;	val Û¯_sup_eq_bc_thmİ : THM;
val Û¯_eq_sup_bc_thmİ : THM;	val Û¯_less_sup__thmİ : THM;
=DESCRIBE
These are the ML bindings for theorems in the theory ¯ to assist with
reasoning about the values of the supremum function.
=ENDDOC
=DOC
val Û¯_plus_assoc_thmİ : THM;		val Û¯_plus_comm_thmİ : THM;
val Û¯_plus_unit_thmİ : THM;		val Û¯_plus_mono_thmİ : THM;
val Û¯_plus_assoc_thm1İ : THM;		val Û¯_plus_mono_thm1İ : THM;
val Û¯_plus_mono_thm2İ : THM;		val Û¯_plus_0_thmİ : THM;
val Û¯_0_1_thmİ : THM;			val Û¯_plus_order_thmİ : THM;
val Û¯_plus_minus_thmİ : THM;		val Û¯_eq_thmİ : THM;
val Û¯_plus_clausesİ : THM;		val Û¯_minus_clausesİ : THM;
val Û¯_less_clausesİ : THM;		val Û¯_¼_clausesİ : THM;
val Ûî¯_plus_homomorphism_thmİ : THM;	val Ûî¯_plus_homomorphism_thm1İ : THM;
val Û¯_minus_eq_thmİ : THM;		val Ûî¯_0_less_thmİ : THM;
val Ûî¯_one_one_thmİ : THM;		val Û¯_less_less_0_thmİ : THM;
val Û¯_less_0_less_thmİ : THM;		val Û¯_¼_¼_0_thmİ : THM;
val Û¯_¼_0_¼_thmİ : THM;			val Ûî¯_less_thmİ : THM;
val Û¯_less_strong_dense_thmİ : THM;	val Ûî¯_¼_thmİ : THM;
val Û¯_sup_plus_thmİ : THM;		val Û¯_sup_plus_sup_thmİ : THM;
val Û¯_less_³_eq_0_thmİ : THM;
=DESCRIBE
These are the ML bindings for basic theorems about the additive structure
of the real numbers and its relationship with the ordering relations
and the supremum function.
=ENDDOC
=DOC
val Û¯_delta_induction_thmİ : THM;		
=DESCRIBE
This is the theorem that supports
=INLINEFT
¯_delta_induction_tac
=TEX
\ (q.v.).
=ENDDOC
=DOC
val Û¯_ord_pres_strict_thmİ : THM;
val Û¯_add_hom_0_thmİ : THM;
val Û¯_add_hom_minus_thmİ : THM;
val Û¯_add_hom_extension_thmİ : THM;
=DESCRIBE
These are ML bindings for theorems
about order-preserving functions and additive endomorphisms from ¯ to ¯.
=ENDDOC
=DOC
val Û¯_monoid_delta_dense_thmİ : THM;
val Û¯_monoid_dense_thmİ : THM;
val Û¯_subgroup_dense_thmİ : THM;
val Û¯_semigroup_dense_thmİ : THM;
val Û¯_add_hom_image_group_thmİ : THM;
val Û¯_add_hom_kernel_group_thmİ : THM;
=DESCRIBE
These are the ML bindings for theorems giving
various properties of substructures of the additive group ¯ and of
(additive) homomorphisms from ¯ to ¯.
=ENDDOC
=DOC
val Û¯_opah_thmİ : THM;		val Û¯_opah_strict_thmİ : THM;
val Û¯_opah_one_one_thmİ : THM;	val Û¯_opah_dense_image_thmİ : THM;
val Û¯_opah_onto_thmİ : THM;	val Û¯_opah_inverse_add_hom_thmİ : THM;
val Û¯_opah_inverse_thmİ : THM;	val Û¯_opah_extension_thm1İ : THM;
val Û¯_opah_extension_thm2İ : THM;	val Û¯_opah_extension_thmİ : THM;
val Û¯_opah_order_thmİ : THM;	val Û¯_opah_eq_thmİ : THM;
val Û¯_opah_complete_thmİ : THM;
=DESCRIBE
These are the ML bindings for theorems giving
various properties of order-preserving additive
homomorphisms from ¯ to ¯.
=ENDDOC
=DOC
val Û¯_copah_id_thmİ : THM;	val Û¯_copah_double_thmİ : THM;
val Û¯_copah_halve_thmİ : THM;	val Û¯_copah_comp_thmİ : THM;
val Û¯_copah_sum_thmİ : THM;	val Û¯_halve_closed_dense_thmİ : THM;
val Û¯_copah_dense_thmİ : THM;
=DESCRIBE
An order-preserving additive homomorphism from ¯ to ¯ is said to be ``central''
if it commutes with any homomorphism from ¯ to ¯.
These are the ML bindings for theorems giving
various properties of central order-preserving additive from ¯ to ¯.
=ENDDOC

=DOC
val Û¯_times_assoc_thmİ : THM;		val Û¯_times_unit_thmİ : THM;
val Û¯_times_distrib_lemmaİ : THM;		val Û¯_times_comm_thmİ : THM;
val Û¯_times_assoc_thm1İ : THM;		val Û¯_times_plus_distrib_thmİ : THM;
val Û¯_0_less_0_less_times_thmİ : THM;	val Û¯_times_order_thmİ : THM;
val Û¯_times_clausesİ : THM;		val Û¯_times_0_thm1İ : THM;
val Û¯_times_0_thmİ : THM;			val Û¯_times_1_thmİ : THM;
val Û¯_times_cancel_thmİ : THM;		val Û¯_times_eq_0_thmİ : THM;
val Û¯_times_minus_thmİ : THM;		val Û¯_times_minus_thm1İ : THM;
val Ûî¯_times_homomorphism_thmİ : THM;	val Ûî¯_times_homomorphism_thm1İ : THM;
val Û¯_times_mono_¤_thmİ : THM;		val Û¯_times_mono_thmİ : THM;
val Û¯_0_¼_0_¼_times_thmİ : THM;		val Û¯_cross_mult_less_thmİ : THM;
val Û¯_cross_mult_eq_thmİ : THM;
=DESCRIBE
These are the ML bindings for some basic theorems about the multiplicative structure
of the real numbers and its relationship with the additive and order structure.
=ENDDOC

=DOC
val Û¯_over_times_recip_thmİ : THM;		val Û¯_times_recip_thmİ : THM;
val Û¯_eq_recip_thmİ : THM;		val Û¯_recip_clausesİ : THM;
val Û¯_0_less_0_less_recip_thmİ : THM;	val Û¯_over_cancel_thmİ : THM;
val Û¯_over_plus_over_thmİ : THM;		val Û¯_0_over_thmİ : THM;
val Û¯_over_1_thmİ : THM;
val Û¯_³_recip_0_thmİ : THM;
=DESCRIBE
These are the ML bindings for some basic theorems about reciprocals (multiplicative
inverses) in the real numbers and their relationship with the other structure.
=ENDDOC

=DOC
val Û¯_frac_cross_mult_eq_thmİ : THM;
val Û¯_frac_cancel_thmİ : THM;
val Û¯_frac_0_thmİ : THM;
val Û¯_frac_î_thmİ : THM;
val Û¯_frac_plus_frac_thmİ : THM;
val Û¯_frac_minus_frac_thmİ : THM;
val Û¯_frac_minus_frac_thm1İ : THM;
val Û¯_over_times_over_thmİ : THM;
val Û¯_frac_times_frac_thmİ : THM;
val Û¯_over_recip_thmİ : THM;
val Û¯_frac_recip_thmİ : THM;
val Û¯_minus_recip_thmİ : THM;
val Û¯_over_eq_0_thmİ : THM;
val Û¯_over_over_over_thmİ : THM;
val Û¯_frac_less_frac_thmİ : THM;
val Û¯_minus_frac_less_frac_thmİ : THM;
val Û¯_frac_less_minus_frac_thmİ : THM;
=DESCRIBE
These are the ML bindings for some theorems about rational numbers (in ¯) expressed as
fractions with natural number numerators and denominators.
=ENDDOC
\subsection{Conversions and Tactics}

=DOC
val Û¯_delta_induction_tacİ  : TERM -> TACTIC;
=DESCRIBE
This is an induction-like tactic that can be used to prove that a property
holds in a half-open interval of the real numbers.
:
to prove that 
=INLINEFT
t[y]
=TEX
holds whenever $x < y$, it suffices to exhibit a positive number $d$ suc
that {\em(i)} $t[u/y]$ holds
for each $u$ with $x < u < x + e$ where $e < d$ and
{\em(ii)} $t[s+d/y]$ holds if $t[s/y]$ holds, for any $s$ with $x < s$.


The term argument $y$ must be a variable that appears free in the conclusion of the goal.
The variable must also appear free once, and only once, in the assumptions, in an
assumption of the form $x < y$.
=FRULE 2 Tactic
¯_delta_induction_tac ¬y®
÷
{ ‡; x < y } t [y/y]
÷
{ ‡ } ¶d·î¯ 0 < d
	±	(¶e·d < e ± (µu·x < u ± u < x + e ´ t[u/y]))
	±	(µs·x < s ± p s ´ t[s + d/y]))
=TEX
=FAILURE
116001	?0 is not a variable of type ”¯®
116002	A term of the form ñx < y® where y is the induction variable
	could not be found in the assumptions
116003	?0 does not appear free in the conclusions of the goal
116004	?0 appears free in more than one assumption of the goal
=ENDDOC


\subsection{Computational Conversions}
=DOC
val Û¯_frac_norm_convİ : CONV;
val Û¯_frac_plus_frac_convİ : CONV;
val Û¯_plus_convİ : CONV;
val Û¯_times_convİ : CONV;
val Û¯_recip_convİ : CONV;
val Û¯_less_convİ : CONV;
val Û¯_¼_convİ : CONV;
val Û¯_eq_convİ : CONV;
val Û¯_over_convİ : CONV;
=DESCRIBE
=FAILURE
116301	?0 is not of the form ¬m /‰N n® or ¬î¯ m®
116302	cannot simplify ?0 because it denominator is 0
116303	?0 is already in normal form
116304	?0 is not of the form ¬(i /‰N m) +‰R (j /‰N n)®
116305	?0 is not of the form ¬x +‰R y® where ¬x® and ¬y®
	are rational literals
116306	?0 is not of the form ¬x *‰R y® where ¬x® and ¬y®
	are rational literals
116307	cannot take the reciprocal of ?0 because it denominator
	or numerator is 0
116308	?0 is not of the form ¬x ›-›1® where ¬x® is
	a rational literal
116309	?0 is not of the form ¬x < y® where ¬x® and ¬y®
	are rational literals
116310	?0 is not of the form ¬x ¼ y® where ¬x® and ¬y®
	are rational literals
116311	?0 is not of the form ¬x = y® where ¬x® and ¬y®
	are rational literals
116312	?0 is not of the form ¬x / y® where ¬y®
	is a rational literal
=ENDDOC
=SML
end (* of signature ¯ *);
=TEX
\section{TEST POLICY}
The module tests for this module are to follow the guidelines
laid down in the quality plan~\cite{DS/FMU/IED/PLN007}.
The various conversions, tactics etc. need to be tested in addition to the
check of the theory design.


\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}







