=IGN
********************************************************************************
dtd116.doc: this file is part of the PPHol system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex

\def\Title{ Detailed Design: Theory of Real Numbers }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document gives the detailed design for the theory
of real numbers in \ProductHOL.}
\end{center}}

\def\Reference{LEMMA1/HOL/DTD116}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.18 $%
}
\def\Date{\FormatDate{$Date: 2006/04/19 12:19:04 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\newpage
\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1--1.6] Initial development drafts.
\item[Issue 1.7] Added linear arithmetic decision procedure.
\item[Issue 1.8] Added documentation for proof contexts.
\item[Issue 1.9] Corrections after integration testing.
\item[Issue 1.10] Added more documentation on normal forms for literals.
\item[Issue 1.11] Added new evaluation conversion and regrouped the documentation boxes.
\item[Issue 1.12] Added missing ML bindings for definitions of absolute value
and exponentiation.
\item[Issue 1.13] Copyright and banner updates for open source release.
\item[Issue 1.14] PPHol-specific updates for open source release
\item[Issue 1.15] Allowed for rationalisation of names in the theory {\it orders};
made sure that no theorems have free variables.
\item[Issue 1.16] HOL now supports left-associative operators.
\item[Issue 1.17] Defined the embedding of the integers.
\item[Issue 1.18] Added exponentiation with integer coefficients.
\item[Issue 1.19] Added normalisation of literal fractions into the proof context.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}

Lemma 1 build system.

\newpage

\section{Introduction}
\subsection{Scope}
This document provides the detailed design of the theory of real numbers in \ProductHOL.


\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD011}.


\section{PREAMBLE}
=SML
force_delete_theory"¯" handle Fail _ => ();
open_theory"dyadic";
set_merge_pcs["basic_hol", "'ú", "'sets_alg"];
new_theory"¯";
new_parent"orders";
=THDOC
req_name Û"¯"İ (Value "dyadic");
req_parent "orders";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $reals$ contains a theory of real numbers for HOL.
=ENDDOC

=TEX
\section {DEFINITION OF FIXITY}
=SML
declare_infix(210, "<‰R");
declare_infix(210, "¼‰R");
declare_infix(210, ">‰R");
declare_infix(210, "¾‰R");
declare_infix(300, "+‰R");
declare_left_infix(305, "-‰R");
declare_infix(310, "*‰R");
declare_left_infix(315, "/");
declare_left_infix(315, "/‰R");
declare_left_infix(315, "/‰N");
declare_infix(320, "^‰N");
declare_infix(320, "^‰Z");
=TEX
\section{DEFINITIONS}
\subsection{The New Type}

¹HOLCONST
Ü	Is_¯_Rep : DYADIC SET ­ BOOL
÷
Ü	µa· Is_¯_Rep a ¤ a  Cuts(Universe, $dy_less)
°
=TEX
We now show that the above definition is consistent.
The only tiny difficulty is using the balance theorems to show
that the universe of dyadics is bounded neither above nor below.
In particular, the latter property lets us apply the result from the theory of orders that
says when a downset is a cut:
=SML
local
open Dyadic;
in
val _ = (
set_goal([], ¬
	StrictLinearOrder (Universe, $dy_less) ±
	UnboundedBelow (Universe, $dy_less) ±
	UnboundedAbove (Universe, $dy_less) ±
	Universe DenseIn (Universe, $dy_less)®);
a(rewrite_tac(dy_less_dense_thm::dy_less_irrefl_thm::
	dy_less_antisym_thm::dy_less_trans_thm::dy_less_trich_thm::
	(map get_spec[¬Irrefl®, ¬Antisym®, ¬Trans®, ¬Trich®, 
		¬StrictPartialOrder®, ¬StrictLinearOrder®, ¬UnboundedBelow®,
	¬UnboundedAbove®, ¬$DenseIn®])));
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac(µ_elim¬x:DYADIC® dy_balance_thm2));
a(all_fc_tac[µ_elim¬b®dy_times_mono_thm]);
a(SPEC_NTH_ASM_T 1 ¬b® ante_tac THEN rewrite_tac[dy_times_unit_clauses]);
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac(µ_elim¬x:DYADIC® dy_balance_thm1));
a(all_fc_tac[µ_elim¬b®dy_times_mono_thm]);
a(SPEC_NTH_ASM_T 1 ¬b® ante_tac THEN rewrite_tac[dy_times_unit_clauses]);
a(contr_tac THEN all_asm_fc_tac[]);
save_thm("dy_less_order_lemmas_thm", pop_thm())
);
=TEX
=SML
val _ = (
set_goal([], ¬¶a·Is_¯_Rep a®);
a(lemma_tac¬
	Trans (Universe, $dy_less) ±
	UnboundedBelow (Universe, $dy_less) ±
	Universe DenseIn (Universe, $dy_less)®);
(* *** Goal "1" *** *)
a(strip_asm_tac (get_thm"-""dy_less_order_lemmas_thm") THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 4 ante_tac
	THEN rewrite_tac[get_spec¬StrictLinearOrder®, get_spec¬StrictPartialOrder®]
	THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LEMMA_T ¬dy_one  Universe® asm_tac THEN1 rewrite_tac[]);
a(all_fc_tac[downset_cut_thm]);
a(¶_tac¬DownSet (Universe, $dy_less, dy_one)®
	THEN asm_rewrite_tac[get_spec¬Is_¯_Rep®]);
save_thm("is_¯_rep_consistent_thm", pop_thm())
);
end;
=TEX
Now we can define the new type:
=SML
val _ = new_type_defn(["¯", "¯_def"], "¯", [],
	get_thm"-""is_¯_rep_consistent_thm");
=TEX
\subsection{Constants}
We now define the ordering relation. Its characterising property is
that it its a complete linear order which admits an inyection
of the dyadic rationals as a dense subset.
¹HOLCONST
Ü	$Û<‰Rİ: ¯ ­ ¯ ­ BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	StrictLinearOrder(Universe, $<‰R)
Ü±	UnboundedBelow(Universe, $<‰R)
Ü±	UnboundedAbove(Universe, $<‰R)
Ü±	Complete(Universe, $<‰R)
Ü
Ü± 	¶É : DYADIC ­ ¯·
Ü		(µa b· É a <‰R É b ¤ a dy_less b)
Ü	±	{x | ¶a·É a = x} DenseIn (Universe, $<‰R)
°
=SML
declare_alias("<", ¬$<‰R®);
=TEX
The other relational operators are then defined in terms of less-than.

¹HOLCONST
Ü	$Û¼‰Rİ: ¯ ­ ¯ ­ BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µx y· x ¼‰R y ¤ x < y ² x = y
°
=SML
declare_alias("¼", ¬$¼‰R®);
¹HOLCONST
Ü	$Û>‰Rİ: ¯ ­ ¯ ­ BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µx y· x >‰R y ¤ y < x
°
=SML
declare_alias(">", ¬$>‰R®);
¹HOLCONST
Ü	$Û¾‰Rİ: ¯ ­ ¯ ­ BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µx y· x ¾‰R y ¤ y ¼ x
°
=SML
declare_alias("¾", ¬$¾‰R®);
=TEX

¹HOLCONST
Ü	ÛSupİ: ¯ SET ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
ÜµA·	³A = {} ±  (¶b· µx· x  A ´ x ¼ b)
Ü´	 (µx·x  A ´ x ¼ Sup A) ± (µb· (µx·x  A ´ x ¼ b) ´ Sup A ¼ b)
°

Addition is then characterised by the ordered group axioms together with the
existence of a positive element in the group.

¹HOLCONST
Ü	$Û+‰Rİ: ¯ ­ ¯ ­ ¯;
Ü	Û0‰Rİ Û1‰Rİ: ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	(µx y z· (x +‰R y) +‰R z = x +‰R (y +‰R z))
Ü
Ü±	(µx y· x +‰R y = y +‰R x)
Ü
Ü±	(µx· x +‰R 0‰R = x)
Ü
Ü±	(µx· ¶y· x +‰R y = 0‰R)
Ü
Ü±	(µx y z· y <‰R z ´ x +‰R y <‰R x +‰R z)
Ü
Ü±	0‰R <‰R 1‰R
°
=SML
declare_alias("+", ¬$+‰R®);
=TEX
Negation:

¹HOLCONST
Ü	$Û~‰Rİ: ¯ ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µx· x + ~‰R x = 0‰R
°
=SML
declare_alias("~", ¬~‰R®);
=TEX
Subtraction:

¹HOLCONST
Ü	$Û-‰Rİ: ¯ ­ ¯ ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µx y· x -‰R y = x + ~y
°
=SML
declare_alias("-", ¬$-‰R®);
=TEX
Embedding of the natural numbers:

¹HOLCONST
Ü	Ûî¯İ: î ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	î¯ 0 = 0‰R
Ü±	(µm· î¯ (m + 1) = î¯ m +  1‰R)
°
=TEX
Absolute value:

¹HOLCONST
Ü	ÛAbs‰Rİ: ¯ ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Üµx·	Abs‰R x = if î¯ 0 ¼ x then x else ~ x
°
=SML
declare_alias("Abs", ¬Abs‰R®);
=TEX
Multiplication:

¹HOLCONST
Ü	$Û*‰Rİ: ¯ ­ ¯ ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	(µx y z· (x *‰R y) *‰R z = x *‰R (y *‰R z))
Ü
Ü±	(µx·x *‰R î¯ 1 = x)
Ü
Ü±	(µx y z· x *‰R (y + z) = x *‰R y + x *‰R z)
Ü
Ü±	(µx y· x *‰R y = y *‰R x)
Ü
Ü±	(µx y· î¯ 0 < x ± î¯ 0 < y ´ î¯ 0 < x *‰R y)
°
=SML
declare_alias("*", ¬$*‰R®);
=TEX
Division:

¹HOLCONST
Ü	$Û/‰Rİ: ¯ ­ ¯ ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	(µy z· ³z = î¯ 0 ´ (y * z) /‰R z = y)
Ü±	(µx y z· ³z = î¯ 0 ´ (x * y) /‰R z = x * (y /‰R z))
°
=SML
declare_alias("/", ¬$/‰R®);
=TEX
Division of one natural number by another

¹HOLCONST
Ü	$Û/‰Nİ: î ­ î ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	(µm n· m /‰N n = î¯ m / î¯ n)
°
=SML
declare_alias("/", ¬$/‰N®);
=SML
declare_postfix(320, "›-›1");

=TEX
Reciprocal:

¹HOLCONST
Ü	$Û›-›1İ: ¯ ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Üµx·	x ›-›1 = î¯ 1/x
°
=TEX
Exponentiation (with natural number exponents):

¹HOLCONST
Ü	$Û^‰Nİ: ¯ ­ î ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	(µx· x ^‰N 0 = î¯ 1)
Ü±	(µx m· x ^‰N (m + 1) = x * x ^‰N m)
°
=SML
declare_alias("^", ¬$^‰N®);
=TEX
Embedding of the integers:

¹HOLCONST
Ü Ûú¯İ :  ú ­ ¯
÷üüüüüü
Ü 	ú¯ (îú 0) = î¯ 0
Ü ±	ú¯ (îú 1) = î¯ 1
Ü ±	µ i j· ú¯(i + j) = ú¯ i + ú¯ j
°
=TEX
Exponentiation (with integer exponents):

¹HOLCONST
Ü	$Û^‰Zİ: ¯ ­ ú ­ ¯
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü µx m·
Ü	x ^‰Z (îú m) = x ^‰N m
Ü ±	x ^‰Z ~(îú(m+1)) = (x ^‰N (m+1)) ›-›1
°
=SML
declare_alias("^", ¬$^‰Z®);
=TEX
=TEX
\section{THEOREMS}
=THDOC
req_thm("dy_less_order_lemmas_thm",
		([], ¬ StrictLinearOrder (Universe, $dy_less)
		    ± UnboundedBelow (Universe, $dy_less)
		    ± UnboundedAbove (Universe, $dy_less)
		    ± Universe DenseIn (Universe, $dy_less)®));
req_thm("is_¯_rep_consistent_thm",
		([], ¬ ¶ a· Is_¯_Rep a®));
req_consistency_thm¬ $<‰R ®;
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_unbounded_below_thm",
		([], ¬ µ x: ¯· ¶ y· y < x®));
req_thm("¯_unbounded_above_thm",
		([], ¬ µ x: ¯· ¶ y· x < y®));
req_thm("¯_less_irrefl_thm",
		([], ¬ µ x: ¯· ³ x < x®));
req_thm("¯_less_antisym_thm",
		([], ¬ µ x y: ¯· ³ (x < y ± y < x)®));
req_thm("¯_less_trans_thm",
		([], ¬ µ x y z: ¯· x < y ± y < z ´ x < z®));
req_thm("¯_less_cases_thm",
		([], ¬ µ x y: ¯· x < y ² x = y ² y < x®));
req_thm("¯_¼_cases_thm",([], ¬ µ x y: ¯· x ¼ y ² y ¼ x ®));
req_thm("¯_¼_less_cases_thm",
		([], ¬ µ x y: ¯· x ¼ y ² y < x®));
req_thm("¯_eq_¼_thm",([], ¬ µ x y: ¯· x = y ¤ x ¼ y ± y ¼ x ®));
req_thm("¯_less_¼_trans_thm",
		([], ¬ µ x y z: ¯· x < y ± y ¼ z ´ x < z®));
req_thm("¯_¼_less_trans_thm",
		([], ¬ µ x y z: ¯· x ¼ y ± y < z ´ x < z®));
req_thm("¯_¼_refl_thm",([], ¬ µ x: ¯· x ¼ x ®));
req_thm("¯_¼_antisym_thm",([], ¬ µ x y: ¯· x ¼ y ± y ¼ x ´ x = y®));
req_thm("¯_¼_trans_thm",([], ¬ µ x y z: ¯· x ¼ y ± y ¼ z ´ x ¼ z ®));
req_thm("¯_¼_³_less_thm",([], ¬ µ x y: ¯· x ¼ y ¤ ³ y < x ®));
req_thm("¯_³_¼_less_thm",([], ¬ µ x y: ¯· ³ x ¼ y ¤ y < x ®));
req_thm("¯_less_³_eq_thm",([], ¬ µ x y: ¯· x < y ´ ³ x = y ®));
req_thm("¯_less_dense_thm",
		([], ¬ µ x y: ¯· x < y ´ (¶ z: ¯· x < z ± z < y)®));
req_thm("¯_complete_thm",([], ¬
µ A · ³ A = {} ± (¶ b· µ x· x  A ´ x ¼ b) ´
	(¶ s: ¯· (µ x· x  A ´ x ¼ s) ±
	(µ b· (µ x· x  A ´ x ¼ b) ´ s ¼ b))®));
=DESCRIBE
=ENDDOC
=THDOC
req_consistency_thm¬ Sup ®;
req_thm("¯_sup_thm",([], ¬ µ A a 
		  · ³ A = {} ± (µ x: ¯· x  A ´ x ¼ a)
		      ´ (µ x· x  A ´ x ¼ Sup A)
		        ± (µ b· (µ x· x  A ´ x ¼ b) ´ Sup A ¼ b)®));
req_thm("¯_less_sup_thm",([], ¬ µ A 
		  · ³ A = {} ± (¶ a: ¯· µ x· x  A ´ x ¼ a)
		      ´ (µ x: ¯· x < Sup A ¤ (¶ y· y  A ± x < y))®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_less_sup_bc_thm",
		([], ¬
µA x·	³ A = {} ±
	(¶ a: ¯· µ x· x  A ´ x ¼ a) ±
	(¶ y· y  A ± x < y) ´ x < Sup A®));
req_thm("¯_¼_sup_thm",([], ¬
µA a·	³ A = {} ±
	(¶ a: ¯· µ x· x  A ´ x ¼ a) ´
	(µ x· x ¼ Sup A ¤ (µ y· (µ z· z  A ´ z ¼ y) ´ x ¼ y))®));
req_thm("¯_¼_sup_bc_thm",([], ¬
µA a x·	³ A = {} ± (¶ a: ¯· µ x· x  A ´ x ¼ a) ±
	(µ y· (µ z· z  A ´ z ¼ y) ´ x ¼ y) ´ x ¼ Sup A®));
req_thm("¯__¼_sup_bc_thm",
	([], ¬ µ A x· x  A ± (¶ a: ¯· µ x· x  A ´ x ¼ a) ´ x ¼ Sup A®));
req_thm("¯_€_sup_thm",([], ¬
µA B·	³ A = {} ±
	(¶ a: ¯· µ x· x  A ´ x ¼ a) ±
	³ B = {} ± (¶ b· µ y· y  B ´ y ¼ b) ± A € B ´
	Sup A ¼ Sup B®));
req_thm("¯_sup_¼_bc_thm",([], ¬
µA a x·	³ A = {} ±
	(¶ a: ¯· µ x· x  A ´ x ¼ a) ±
	(µ y· y  A ´ y ¼ x) ´ Sup A ¼ x®));
req_thm("¯_sup_less_bc_thm",
		([], ¬
µA x z·	³ A = {} ± (¶ a: ¯· µ x· x  A ´ x ¼ a) ±
	(µ y· y  A ´ y ¼ x) ± x < z ´ Sup A < z®));
req_thm("¯_sup_eq_bc_thm",([], ¬
µA a s· ³ A = {} ± (µ x: ¯· x  A ´ x ¼ s) ±
	(µ x· (µ y· y  A ´ y ¼ x) ´ s ¼ x) ´
	Sup A = s®));
req_thm("¯_eq_sup_bc_thm",([], ¬
µA a s·	³ A = {} ± (µ x: ¯· x  A ´ x ¼ s) ±
	(µ x· (µ y· y  A ´ y ¼ x) ´ s ¼ x) ´
	s = Sup A®));
req_thm("¯_less_sup__thm",
		([], ¬
µ A a·	³ A = {} ± (µ x: ¯· x  A ´ x ¼ a) ± ³ Sup A  A ´
	(µ x· x < Sup A ´ (¶ y· x < y ± y < Sup A ± y  A))®));
=DESCRIBE
=ENDDOC
=THDOC
req_consistency_thm¬$+‰R®;
req_consistency_thm¬0‰R®;
req_consistency_thm¬1‰R®;
req_consistency_thm¬~‰R®;
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_plus_assoc_thm",
		([], ¬ µ x y z: ¯· (x + y) + z = x + y + z®));
req_thm("¯_plus_comm_thm",([], ¬ µ x y: ¯· x + y = y + x ®));
req_thm("¯_plus_unit_thm",([], ¬ µ x: ¯· x + 0‰R = x ®));
req_thm("¯_plus_mono_thm",([], ¬ µ x y z: ¯· y < z ´ x + y < x + z ®));
req_thm("¯_plus_assoc_thm1",
		([], ¬ µ x y z: ¯· x + y + z = (x + y) + z®));
req_thm("¯_plus_mono_thm1",
		([], ¬ µ x y z: ¯· y < z ´ y + x < z + x®));
req_thm("¯_plus_mono_thm2",
		([], ¬ µ x y s t: ¯· x < y ± s < t ´ x + s < y + t®));
req_thm("¯_plus_0_thm",([], ¬ µ x: ¯· x + î¯ 0 = x ± î¯ 0 + x = x ®));
req_thm("¯_0_1_thm",([], ¬ 0‰R = î¯ 0 ± 1‰R = î¯ 1 ®));
req_thm("¯_plus_order_thm",
		([], ¬ µ x y z: ¯· y + x = x + y
		      ± (x + y) + z = x + y + z
		      ± y + x + z = x + y + z®));
req_thm("¯_plus_minus_thm",
		([], ¬ µ x: ¯· x + ~ x = î¯ 0 ± ~ x + x = î¯ 0®));
req_thm("¯_eq_thm",([], ¬ µ x y: ¯· x = y ¤ x + ~ y = î¯ 0 ®));
req_thm("î¯_plus_homomorphism_thm",
		([], ¬ µ m n· î¯ (m + n) = î¯ m + î¯ n®));
req_thm("¯_minus_clauses",([], ¬ µ x y 
		  · ~ (~ x) = x
		      ± x + ~ x = î¯ 0
		      ± ~ x + x = î¯ 0
		      ± ~ (x + y) = ~ x + ~ y
		      ± ~ (î¯ 0) = î¯ 0®));
req_thm("¯_minus_eq_thm",([], ¬ µ x y: ¯· ~ x = ~ y ¤ x = y ®));
req_thm("î¯_0_less_thm",([], ¬ µ m· î¯ 0 < î¯ (m + 1) ®));
req_thm("î¯_one_one_thm",([], ¬ µ m n· î¯ m = î¯ n ¤ m = n ®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_plus_clauses",([], ¬ µ x y z : ¯·
		         (x + z = y + z ¤ x = y)
		      ± (z + x = y + z ¤ x = y)
		      ± (x + z = z + y ¤ x = y)
		      ± (z + x = z + y ¤ x = y)
		      ± (x + z = z ¤ x = î¯ 0)
		      ± (z + x = z ¤ x = î¯ 0)
		      ± (z = z + y ¤ y = î¯ 0)
		      ± (z = y + z ¤ y = î¯ 0)
		      ± x + î¯ 0 = x
		      ± î¯ 0 + x = x
		      ± ³ î¯ 1 = î¯ 0
		      ± ³ î¯ 0 = î¯ 1®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_less_less_0_thm",
		([], ¬ µ x y· x < y ¤ x + ~ y < î¯ 0®));
req_thm("¯_less_clauses",([], ¬ µ x y z : ¯·
		        (x + z < y + z ¤ x < y)
		      ± (z + x < y + z ¤ x < y)
		      ± (x + z < z + y ¤ x < y)
		      ± (z + x < z + y ¤ x < y)
		      ± (x + z < z ¤ x < î¯ 0)
		      ± (z + x < z ¤ x < î¯ 0)
		      ± (x < z + x ¤ î¯ 0 < z)
		      ± (x < x + z ¤ î¯ 0 < z)
		      ± ³ x < x
		      ± î¯ 0 < î¯ 1
		      ± ³ î¯ 1 < î¯ 0®));
req_thm("¯_less_0_less_thm",
		([], ¬ µ x y· x < y ¤ î¯ 0 < y + ~ x®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_¼_clauses",([], ¬ µ x y z: ¯·
		        (x + z ¼ y + z ¤ x ¼ y)
		      ± (z + x ¼ y + z ¤ x ¼ y)
		      ± (x + z ¼ z + y ¤ x ¼ y)
		      ± (z + x ¼ z + y ¤ x ¼ y)
		      ± (x + z ¼ z ¤ x ¼ î¯ 0)
		      ± (z + x ¼ z ¤ x ¼ î¯ 0)
		      ± (x ¼ z + x ¤ î¯ 0 ¼ z)
		      ± (x ¼ x + z ¤ î¯ 0 ¼ z)
		      ± x ¼ x
		      ± î¯ 0 ¼ î¯ 1
		      ± ³ î¯ 1 ¼ î¯ 0®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_¼_¼_0_thm",([], ¬ µ x y· x ¼ y ¤ x + ~ y ¼ î¯ 0 ®));
req_thm("¯_¼_0_¼_thm",([], ¬ µ x y· x ¼ y ¤ î¯ 0 ¼ y + ~ x ®));
req_thm("î¯_less_thm",([], ¬ µ m n· î¯ m < î¯ n ¤ m < n ®));
req_thm("¯_less_strong_dense_thm",
		([], ¬ µ x y· x < y ´ (¶ d· î¯ 0 < d ± x + d < y)®));
req_thm("î¯_¼_thm",([], ¬ µ m n· î¯ m ¼ î¯ n ¤ m ¼ n ®));
req_thm("¯_sup_plus_thm",([], ¬µ A a x·
	³ A = {} ± (µ x· x  A ´ x ¼ a)
´	Sup A + x = Sup {t|¶ a· a  A ± t < a + x}®));
req_thm("¯_sup_plus_sup_thm",
		([], ¬µ A a B b·
	³ A = {} ± (µ x· x  A ´ x ¼ a)
±	³ B = {} ± (µ y· y  B ´ y ¼ b)
´	Sup A + Sup B = Sup {t|¶ a b· a  A ± b  B ± t < a + b}®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_delta_induction_thm",
		([], ¬ µ x p
		  · (¶ d
		      · î¯ 0 < d
		          ± (¶ e· d < e ± (µ t· x < t ± t < x + e ´ p t))
		          ± (µ s· x < s ± p s ´ p (s + d)))
		      ´ (µ y· x < y ´ p y)®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_ord_pres_strict_thm",
		([], ¬ µ f : ¯ ­ ¯·
	(µ x y· x < y ´ f x < f y) ´ (µ x y· f x < f y ´ x < y)®));
req_thm("¯_add_hom_0_thm",([], ¬ µ f : ¯ ­ ¯·
	(µ x y· f (x + y) = f x + f y) ´ (µ x· f (î¯ 0) = î¯ 0) ®));
req_thm("¯_add_hom_minus_thm",
		([], ¬ µ f : ¯ ­ ¯·
	(µ x y· f (x + y) = f x + f y) ´ (µ x· f (~ x) = ~ (f x))®));
req_thm("¯_add_hom_extension_thm",
		([], ¬
µ f : ¯ ­ ¯·
	(µ x y· î¯ 0 ¼ x ± î¯ 0 ¼ y ´ f (x + y) = f x + f y)
±	(µ x· î¯ 0 ¼ x ´ f (~ x) = ~ (f x))
´	(µ x y· f (x + y) = f x + f y)®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_monoid_delta_dense_thm",
		([], ¬ µ G d
		  · î¯ 0  G
		        ± (µ g h· g  G ± h  G ´ g + h  G)
		        ± d  G
		        ± î¯ 0 < d
		      ´ (µ x· î¯ 0 < x ´ (¶ g· g  G ± g ¼ x ± x < g + d))®));
req_thm("¯_monoid_dense_thm",
		([], ¬µG·
	î¯ 0  G
±	(µ g h· g  G ± h  G ´ g + h  G)
±	(µ x· î¯ 0 < x ´ (¶ g· g  G ± î¯ 0 < g ± g < x))
´	(µ x y· î¯ 0 < x ± x < y ´ (¶ g· g  G ± x < g ± g < y))®));
req_thm("¯_subgroup_dense_thm",
		([], ¬ µG·
	î¯ 0  G
±	(µ g h· g  G ± h  G ´ g + h  G)
±	(µ g· g  G ´ ~ g  G)
±	(µ x· î¯ 0 < x ´ (¶ g· g  G ± î¯ 0 < g ± g < x))
´	(µ x y· x < y ´ (¶ g· g  G ± x < g ± g < y))®));
req_thm("¯_semigroup_dense_thm",
		([], ¬ µ G·
	(µ g h· g  G ± h  G ´ g + h  G)
±	(µ x· î¯ 0 < x ´ (¶ g· g  G ± î¯ 0 < g ± g < x))
´	(µ x y· î¯ 0 < x ± x < y ´ (¶ g· g  G ± x < g ± g < y))®));
req_thm("¯_add_hom_image_group_thm",
		([], ¬ µ f : ¯ ­ ¯; I·
	(µ x y· f (x + y) = f x + f y)
±	I = {b|¶ a· b = f a}
´	î¯ 0  I
±	(µ g h· g  I ± h  I ´ g + h  I)
±	(µ g· g  I ´ ~ g  I)®));
req_thm("¯_add_hom_kernel_group_thm",
		([], ¬ µ f K·
	(µ x y· f (x + y) = f x + f y)
±	K = {a|f a = î¯ 0}
´	î¯ 0  K
±	(µ g h· g  K ± h  K ´ g + h  K)
±	(µ g· g  K ´ ~ g  K)®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_opah_thm",([], ¬ µ f : ¯ ­ ¯· (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		      ´ (µ x y· x < y ´ f x < f y)®));
req_thm("¯_opah_strict_thm",
		([], ¬ µ f : ¯ ­ ¯· (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		      ´ (µ x y· f x < f y ´ x < y)®));
req_thm("¯_opah_one_one_thm",
		([], ¬ µ f : ¯ ­ ¯· (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		      ´ OneOne f®));
req_thm("¯_opah_dense_image_thm",
		([], ¬ µ f : ¯ ­ ¯; e· (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		        ± î¯ 0 < e
		      ´ (¶ d· î¯ 0 < d ± f d < e)®));
req_thm("¯_opah_onto_thm",([], ¬ µ f  : ¯ ­ ¯· (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		      ´ Onto f®));
req_thm("¯_opah_inverse_add_hom_thm",
		([], ¬ µ f g : ¯ ­ ¯· (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		        ± (µ x· g (f x) = x)
		        ± (µ x· f (g x) = x)
		      ´ (µ x y· g (x + y) = g x + g y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < g x)®));
req_thm("¯_opah_inverse_thm",
		([], ¬ µ f : ¯ ­ ¯· (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		      ´ (¶ g: ¯ ­ ¯·
			   (µ x· g (f x) = x)
		          ± (µ x· f (g x) = x)
		          ± (µ x y· g (x + y) = g x + g y)
		          ± (µ x· î¯ 0 < x ´ î¯ 0 < g x))®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_copah_id_thm",([], ¬ ¶ É 
		  · (µ x· É x = x)
		      ± (µ x y· É (x + y) = É x + É y)
		      ± (µ x· î¯ 0 < x ´ î¯ 0 < É x)
		      ± (µ f
		      · (µ x y· f (x + y) = f x + f y)
		          ´ (µ x· É (f x) = f (É x)))®));
req_thm("¯_copah_double_thm",
		([], ¬ ¶ Á
		  · (µ x· Á x = x + x)
		      ± (µ x y· Á (x + y) = Á x + Á y)
		      ± (µ x· î¯ 0 < x ´ î¯ 0 < Á x)
		      ± (µ x· î¯ 0 < x ´ x < Á x)
		      ± (µ f
		      · (µ x y· f (x + y) = f x + f y)
		          ´ (µ x· Á (f x) = f (Á x)))®));
req_thm("¯_copah_halve_thm",
		([], ¬ ¶ Â
		  · (µ x· Â x + Â x = x)
		      ± (µ x y· Â (x + y) = Â x + Â y)
		      ± (µ x· î¯ 0 < x ´ î¯ 0 < Â x)
		      ± (µ x· î¯ 0 < x ´ Â x < x)
		      ± (µ f
		      · (µ x y· f (x + y) = f x + f y)
		          ´ (µ x· Â (f x) = f (Â x)))®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_copah_comp_thm",
		([], ¬ µ Á Â
		  · (µ x y· Á (x + y) = Á x + Á y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < Á x)
		        ± (µ f
		        · (µ x y· f (x + y) = f x + f y)
		            ´ (µ x· Á (f x) = f (Á x)))
		        ± (µ x y· Â (x + y) = Â x + Â y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < Â x)
		        ± (µ f
		        · (µ x y· f (x + y) = f x + f y)
		            ´ (µ x· Â (f x) = f (Â x)))
		      ´ (¶ Ç
		      · (µ x· Ç x = Á (Â x))
		          ± (µ x· î¯ 0 < x ´ î¯ 0 < Ç x)
		          ± (µ x y· Ç (x + y) = Ç x + Ç y)
		          ± (µ f
		          · (µ x y· f (x + y) = f x + f y)
		              ´ (µ x· Ç (f x) = f (Ç x))))®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_copah_sum_thm",([], ¬ µ Á Â 
		  · (µ x y· Á (x + y) = Á x + Á y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < Á x)
		        ± (µ f
		        · (µ x y· f (x + y) = f x + f y)
		            ´ (µ x· Á (f x) = f (Á x)))
		        ± (µ x y· Â (x + y) = Â x + Â y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < Â x)
		        ± (µ f
		        · (µ x y· f (x + y) = f x + f y)
		            ´ (µ x· Â (f x) = f (Â x)))
		      ´ (¶ Ç
		      · (µ x· Ç x = Á x + Â x)
		          ± (µ x· î¯ 0 < x ´ î¯ 0 < Ç x)
		          ± (µ x y· Ç (x + y) = Ç x + Ç y)
		          ± (µ f
		          · (µ x y· f (x + y) = f x + f y)
		              ´ (µ x· Ç (f x) = f (Ç x))))®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_halve_closed_dense_thm",
		([], ¬ µ A e
		  · î¯ 0 < e ± e  A ± (µ y· y  A ´ (¶ z· z  A ± z + z = y))
		      ´ (µ d· î¯ 0 < d ´ (¶ a· a  A ± î¯ 0 < a ± a < d))®));
req_thm("¯_copah_dense_thm",
		([], ¬ µ d x y
		  · î¯ 0 < d ± î¯ 0 < x ± x < y
		      ´ (¶ Ç
		      · (µ x y· Ç (x + y) = Ç x + Ç y)
		          ± (µ x· î¯ 0 < x ´ î¯ 0 < Ç x)
		          ± (µ f
		          · (µ x y· f (x + y) = f x + f y)
		              ´ (µ x· Ç (f x) = f (Ç x)))
		          ± x < Ç d
		          ± Ç d < y)®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_opah_extension_thm1",
		([], ¬ µ f
		  · (µ x y· î¯ 0 < x ± î¯ 0 < y ´ f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		      ´ (¶ Æ
		      · Æ (î¯ 0) = î¯ 0
		          ± (µ x· î¯ 0 < x ´ Æ x = f x)
		          ± (µ x y
		          · î¯ 0 ¼ x ± î¯ 0 ¼ y ´ Æ (x + y) = Æ x + Æ y))®));
req_thm("¯_opah_extension_thm2",
		([], ¬ µ f
		  · f (î¯ 0) = î¯ 0
		        ± (µ x y· î¯ 0 ¼ x ± î¯ 0 ¼ y ´ f (x + y) = f x + f y)
		      ´ (¶ Ù
		      · (µ x· î¯ 0 ¼ x ´ Ù x = f x)
		          ± (µ x y· Ù (x + y) = Ù x + Ù y))®));
req_thm("¯_opah_extension_thm",
		([], ¬ µ f
		  · (µ x y· î¯ 0 < x ± î¯ 0 < y ´ f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		      ´ (¶ Æ
		      · (µ x· î¯ 0 < x ´ Æ x = f x)
		          ± (µ x y· Æ (x + y) = Æ x + Æ y)
		          ± (µ x· î¯ 0 < x ´ î¯ 0 < Æ x))®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_opah_order_thm",
		([], ¬ µ f g d
		  · (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		        ± (µ x y· g (x + y) = g x + g y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < g x)
		        ± î¯ 0 < d
		        ± f d < g d
		      ´ (µ x· î¯ 0 < x ´ f x < g x)®));
req_thm("¯_opah_eq_thm",([], ¬ µ f g d 
		  · (µ x y· f (x + y) = f x + f y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		        ± (µ x y· g (x + y) = g x + g y)
		        ± (µ x· î¯ 0 < x ´ î¯ 0 < g x)
		        ± î¯ 0 < d
		        ± f d = g d
		      ´ f = g®));
req_thm("¯_opah_complete_thm",
		([], ¬ µ d e
		  · î¯ 0 < d ± î¯ 0 < e
		      ´ (¶ f
		      · (µ x y· f (x + y) = f x + f y)
		          ± (µ x· î¯ 0 < x ´ î¯ 0 < f x)
		          ± f d = e)®));
=DESCRIBE
=ENDDOC
=THDOC
req_consistency_thm¬ $*‰R ®;
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_times_assoc_thm",
		([], ¬ µ x y z: ¯· (x * y) * z = x * y * z®));
req_thm("¯_times_comm_thm",
		([], ¬ µ x y: ¯· x * y = y * x®));
req_thm("¯_times_unit_thm",
		([], ¬ µ x· x * î¯ 1 = x®));
req_thm("¯_0_less_0_less_times_thm",
		([], ¬ µ x y· î¯ 0 < x ± î¯ 0 < y ´ î¯ 0 < x * y®));
req_thm("¯_times_assoc_thm1",
		([], ¬ µ x y z: ¯· x * y * z = (x * y) * z®));
req_thm("¯_times_plus_distrib_thm",
		([], ¬ µ x y z: ¯·
	x * (y + z) = x * y + x * z ± (x + y) * z = x * z + y * z®));
req_thm("¯_times_order_thm",
		([], ¬ µ x y z: ¯· y * x = x * y
		      ± (x * y) * z = x * y * z
		      ± y * x * z = x * y * z®));
req_thm("¯_times_0_thm",([], ¬ µ x· x * î¯ 0 = î¯ 0 ± î¯ 0 * x = î¯ 0 ®));
req_thm("¯_times_1_thm",([], ¬ µ x· x * î¯ 1 = x ± î¯ 1 * x = x ®));
req_thm("î¯_times_homomorphism_thm",
		([], ¬ µ m n· î¯ (m * n) = î¯ m * î¯ n®));
=DESCRIBE
=ENDDOC
=THDOC
req_consistency_thm¬ $/‰R ®;
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_over_times_recip_thm", ([],
	¬ µ z· ³ z = î¯ 0 ´ (µ x· x / z = x * z ›-›1)®));
req_thm("¯_times_recip_thm", ([],
	¬ µ z· ³ z = î¯ 0 ´ z * z ›-›1 = î¯ 1®));
req_thm("¯_eq_recip_thm",([],
	¬ µ z· ³ z = î¯ 0 ´ (µ y· y = z ¤ y * z ›-›1 = î¯ 1) ®));
req_thm("¯_times_cancel_thm", ([],
	¬ µ x y z· ³ z = î¯ 0 ´ (x * z = y * z ¤ x = y)®));
req_thm("¯_times_eq_0_thm", ([],
	¬ µ x y· x * y = î¯ 0 ¤ x = î¯ 0 ² y = î¯ 0®));
req_thm("¯_times_minus_thm", ([],
	¬ µ x y : ¯·
		~ x * y = ~ (x * y)
	±	x * ~ y = ~ (x * y) 
	±	~ x * ~ y = x * y®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_times_clauses",([], ¬ µ x 
		  · î¯ 0 * x = î¯ 0
		      ± x * î¯ 0 = î¯ 0
		      ± x * î¯ 1 = x
		      ± î¯ 1 * x = x®));
req_thm("¯_times_mono_¤_thm",
		([], ¬ µ x· î¯ 0 < x ´ (µ y z· y < z ¤ x * y < x * z)®));
req_thm("¯_times_mono_thm",
		([], ¬ µ x y z· î¯ 0 < x ± y < z ´ x * y < x * z®));
req_thm("¯_0_¼_0_¼_times_thm",
		([], ¬ µ x y· î¯ 0 ¼ x ± î¯ 0 ¼ y ´ î¯ 0 ¼ x * y®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_³_recip_0_thm",([], ¬ µ z· ³ z = î¯ 0 ´ ³ z ›-›1 = î¯ 0 ®));
req_thm("¯_recip_clauses",([], ¬ (î¯ 1 ›-›1 = î¯ 1 
		      ± (µ w
		      · ³ w = î¯ 0
		          ´ w ›-›1 ›-›1 = w
		            ± w * w ›-›1 = î¯ 1
		            ± w ›-›1 * w = î¯ 1))
		    ± (µ w z
		    · ³ w = î¯ 0 ± ³ z = î¯ 0 ´ (w * z) ›-›1 = w ›-›1 * z ›-›1)®));
req_thm("¯_cross_mult_eq_thm",
		([], ¬ µ w z
		  · ³ w = î¯ 0 ± ³ z = î¯ 0
		      ´ (µ x y· x / w = y / z ¤ x * z = w * y)®));
req_thm("¯_less_³_eq_0_thm",
		([], ¬ µ z· î¯ 0 < z ´ ³ z = î¯ 0®));
req_thm("¯_0_less_0_less_recip_thm",
		([], ¬ µ z· î¯ 0 < z ´ î¯ 0 < z ›-›1®));
req_thm("¯_cross_mult_less_thm",
		([], ¬
µw z·	î¯ 0 < w ± î¯ 0 < z
´	(µ x y· x / w < y / z ¤ x * z < w * y)®));
req_thm("¯_over_cancel_eq_thm",
		([], ¬
µw z·	³ w = î¯ 0 ± ³ z = î¯ 0
´	(µ x· (x * z) / (w * z) = x / w)®));
req_thm("¯_over_plus_over_thm",
		([], ¬ µ x y u v
		  · ³ u = î¯ 0 ± ³ v = î¯ 0
		      ´ x / u + y / v = (x * v + y * u) / (u * v)®));
req_thm("¯_0_over_thm",([], ¬ µ z· ³ z = î¯ 0 ´ î¯ 0 / z = î¯ 0 ®));
req_thm("¯_over_1_thm",([], ¬ µ x· x / î¯ 1 = x ®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("î¯_plus_homomorphism_thm1",
		([], ¬ µ m n· î¯ m + î¯ n = î¯ (m + n)®));
req_thm("î¯_times_homomorphism_thm1",
		([], ¬ µ m n· î¯ m * î¯ n = î¯ (m * n)®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_frac_cross_mult_eq_thm",
		([], ¬ µ m n i j
		  · i / (m + 1) = j / (n + 1) ¤ i * (n + 1) = j * (m + 1)®));
req_thm("¯_frac_cancel_eq_thm",
		([], ¬ µ i m n· (i * (n + 1)) / ((m + 1) * (n + 1)) = i / (m + 1)®));
req_thm("¯_frac_0_thm",([], ¬ µ m· 0 / (m + 1) = î¯ 0 ®));
req_thm("¯_frac_î_thm",([], ¬ µ i· i / 1 = î¯ i ®));
req_thm("¯_frac_plus_frac_thm",
		([], ¬ µ i j k m n
		  · i / (m + 1) + j / (n + 1)
		      = (i * (n + 1) + j * (m + 1)) / ((m + 1) * (n + 1))®));
req_thm("¯_frac_minus_frac_thm",
		([], ¬ µ i j k m n
		  · j * (m + 1) ¼ i * (n + 1)
		      ´ i / (m + 1) + ~ (j / (n + 1))
		        = (i * (n + 1) - j * (m + 1)) / ((m + 1) * (n + 1))®));
req_thm("¯_frac_minus_frac_thm1",
		([], ¬ µ i j m n
		  · i * (n + 1) ¼ j * (m + 1)
		      ´ i / (m + 1) + ~ (j / (n + 1))
		        = ~ ((j * (m + 1) - i * (n + 1)) / ((m + 1) * (n + 1)))®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¯_over_times_over_thm",
		([], ¬ µ x y u v·
	³ u = î¯ 0 ± ³ v = î¯ 0
´	x / u * y / v = (x * y) / (u * v)®));
req_thm("¯_frac_times_frac_thm",
		([], ¬ µ i j m n
		  · i / (m + 1) * j / (n + 1) = (i * j) / ((m + 1) * (n + 1))®));
req_thm("¯_over_recip_thm",
		([], ¬ µ u v· ³ u = î¯ 0 ± ³ v = î¯ 0 ´ (u / v) ›-›1 = v / u®));
req_thm("¯_frac_recip_thm",
		([], ¬ µ m n· ((m + 1) / (n + 1)) ›-›1 = (n + 1) / (m + 1)®));
req_thm("¯_minus_recip_thm",
		([], ¬ µ z· ³ z = î¯ 0 ´ ~ z ›-›1 = ~ (z ›-›1)®));
req_thm("¯_over_eq_0_thm",([], ¬
	µ u v· ³ u = î¯ 0 ± ³ v = î¯ 0 ´ ³ u / v = î¯ 0 ®));
req_thm("¯_over_over_over_thm",
		([], ¬ µ x y u v
		  · ³ u = î¯ 0 ± ³ v = î¯ 0 ± ³ y = î¯ 0
		      ´ (x / u) / (y / v) = (x * v) / (u * y)®));
req_thm("¯_frac_less_frac_thm",
		([], ¬ µ i j m n
		  · i / (m + 1) < j / (n + 1) ¤ i * (n + 1) < j * (m + 1)®));
req_thm("¯_minus_frac_less_frac_thm",
		([], ¬ µ i j m n· ~ (i / (m + 1)) < j / (n + 1) ¤ 0 < i + j®));
req_thm("¯_frac_less_minus_frac_thm",
		([], ¬ µ i j m n· ³ i / (m + 1) < ~ (j / (n + 1))®));
req_thm("¯_0_¼_frac_thm",
		([], ¬µi m· î¯ 0 ¼ i/(m+1)®));
req_thm("¯_abs_frac_thm",
		([], ¬µi m· Abs(i/(m+1)) = i/(m+1)®));
req_thm("¯_abs_minus_thm",
		([], ¬µ x : ¯ · Abs (~x) = Abs x®));
=DESCRIBE
=ENDDOC
=THDOC
req_consistency_thm¬ ú¯ ®;
req_thm("ú¯_plus_homomorphism_thm",
		([], ¬ µ i j· ú¯ (i + j) = ú¯ i + ú¯ j®));
req_thm("ú¯_minus_thm",
		([], ¬ µi·ú¯(~i) = ~(ú¯ i) ®));
req_thm("ú¯_îú_thm",
		([], ¬
	µm·	ú¯(îú m) = î¯ m
	±	ú¯(~(îú m)) = ~(î¯ m) ®));
req_thm("ú¯_times_homomorphism_thm",
		([], ¬ µ i j· ú¯ (i * j) = ú¯ i * ú¯ j®));
req_consistency_thm¬ $^‰Z ®;
=DESCRIBE
=ENDDOC

=TEX
\section{SIGNATURE}
=SML
signature Û¯İ = sig
=TEX

\subsection{Syntax Functions}
=DOC
val Ûdest_¯_lessİ : TERM -> TERM * TERM;	(* <‰R *)
val Ûdest_¯_¼İ : TERM -> TERM * TERM	(* ¼‰R *);
val Ûdest_¯_greaterİ : TERM -> TERM * TERM	(* >‰R *);
val Ûdest_¯_¾İ : TERM -> TERM * TERM	(* ¾‰R *);
val Ûdest_¯_plusİ : TERM -> TERM * TERM	(* +‰R *);
val Ûdest_¯_subtractİ : TERM -> TERM * TERM	(* -‰R *);
val Ûdest_¯_timesİ : TERM -> TERM * TERM	(* *‰R *);
val Ûdest_¯_overİ : TERM -> TERM * TERM	(* /‰R *);
val Ûdest_¯_fracİ : TERM -> TERM * TERM	(* /‰N *);
val Ûdest_¯_minusİ : TERM -> TERM		(* ~‰R *);
val Ûdest_¯_absİ : TERM -> TERM		(* Abs‰R *);
val Ûdest_¯_recipİ : TERM -> TERM		(* ›-›1 *);
val Ûdest_¯_î_expİ : TERM -> TERM * TERM;	(* ^‰N *)
val Ûdest_¯_ú_expİ : TERM -> TERM * TERM;	(* ^‰Z *)
val Ûdest_î¯İ : TERM -> TERM;		(* î¯ *)
=DESCRIBE
These are the derived destructor functions for the basic
arithmetic operators on the real numbers. The ML comments
above give the name of the corresponding operators.
These names all have aliases without the subscript.
=FAILURE
116101	?0 is not of the form ¬x <‰R y®
116102	?0 is not of the form ¬x ¼‰R y®
116103	?0 is not of the form ¬x >‰R y®
116104	?0 is not of the form ¬x ¼‰R y®
116105	?0 is not of the form ¬x +‰R y®
116106	?0 is not of the form ¬x -‰R y®
116107	?0 is not of the form ¬x *‰R y®
116108	?0 is not of the form ¬x /‰R y®
116109	?0 is not of the form ¬x /‰N y®
116111	?0 is not of the form ¬~‰R y®
116112	?0 is not of the form ¬Abs‰R x®
116113	?0 is not of the form ¬x ›-›1®
116114	?0 is not of the form ¬x ^‰N m®
116115	?0 is not of the form ¬î¯ m®
116116	?0 is not of the form ¬x ^‰Z i®
=ENDDOC
=DOC
val Ûis_¯_lessİ : TERM -> bool		(* <‰R *);
val Ûis_¯_¼İ : TERM -> bool		(* ¼‰R *);
val Ûis_¯_greaterİ : TERM -> bool	(* >‰R *);
val Ûis_¯_¾İ : TERM -> bool		(* ¾‰R *);
val Ûis_¯_plusİ : TERM -> bool		(* +‰R *);
val Ûis_¯_subtractİ : TERM -> bool	(* -‰R *);
val Ûis_¯_timesİ : TERM -> bool		(* *‰R *);
val Ûis_¯_overİ : TERM -> bool		(* /‰R *);
val Ûis_¯_fracİ : TERM -> bool	(* /‰N *);
val Ûis_¯_minusİ : TERM -> bool	(* ~‰R *);
val Ûis_¯_absİ : TERM -> bool		(* Abs‰R *);
val Ûis_¯_recipİ : TERM -> bool	(* ›-›1 *);
val Ûis_¯_î_expİ : TERM -> bool	(* ^‰N *);
val Ûis_¯_ú_expİ : TERM -> bool	(* ^‰Z *);
val Ûis_î¯İ : TERM -> bool		(* î¯ *);
=DESCRIBE
These are the derived discriminating functions for the basic
arithmetic operators on the real numbers. The ML comments
above give the name of the corresponding operators.
These names all have aliases without the subscript.
=ENDDOC

=DOC
val Ûmk_¯_lessİ : TERM * TERM -> TERM;	(* <‰R *)
val Ûmk_¯_¼İ : TERM * TERM -> TERM		(* ¼‰R *);
val Ûmk_¯_greaterİ : TERM * TERM -> TERM	(* >‰R *);
val Ûmk_¯_¾İ : TERM * TERM -> TERM	(* ¾‰R *);
val Ûmk_¯_plusİ : TERM * TERM -> TERM	(* +‰R *);
val Ûmk_¯_subtractİ : TERM * TERM -> TERM	(* -‰R *);
val Ûmk_¯_timesİ : TERM * TERM -> TERM	(* *‰R *);
val Ûmk_¯_overİ : TERM * TERM -> TERM	(* /‰R *);
val Ûmk_¯_fracİ : TERM * TERM -> TERM	(* /‰N *);
val Ûmk_¯_minusİ : TERM -> TERM			(* ~‰R *);
val Ûmk_¯_absİ : TERM -> TERM			(* Abs‰R *);
val Ûmk_¯_recipİ : TERM -> TERM			(* ›-›1 *);
val Ûmk_¯_î_expİ : TERM * TERM -> TERM;	(* ^‰N *)
val Ûmk_¯_ú_expİ : TERM * TERM -> TERM;	(* ^‰Z *)
val Ûmk_î¯İ : TERM -> TERM;			(* î¯*)
=DESCRIBE
These are the derived constructor functions for the basic
arithmetic operators on the real numbers. The ML comments
above give the name of the corresponding operators.
These names all have aliases without the subscript.

Both operands of
=INLINEFT
mk_¯_frac
=TEX
and the second operand of
=INLINEFT
mk_¯_î_exp
=TEX
\ must be of type î.
All the other operands of type ¯.
All other operands must have type ¯.

=FAILURE
116201	?0 does not have type ”¯®
116202	?0 does not have type ”î®
=ENDDOC
\subsection{Definitions}
=DOC
val Û¯_plus_defİ : THM;		val Û¯_subtract_defİ : THM;
val Û¯_¼_defİ : THM;		val Û¯_less_defİ : THM;
val Û¯_greater_defİ : THM;	val Û¯_¾_defİ : THM;
val Û¯_minus_defİ : THM;	val Û¯_times_defİ : THM;
val Û¯_over_defİ : THM;		val Û¯_frac_defİ : THM;
val Ûî¯_defİ : THM;		val Û¯_î_exp_defİ : THM;
val Û¯_abs_defİ : THM;		val Ûú¯_defİ : THM;
val Û¯_ú_exp_defİ : THM;
=DESCRIBE
These are the ML bindings for the definitions in the theory ¯.
=ENDDOC
\subsection{Theorems}
=DOC
val Û¯_unbounded_below_thmİ : THM;
val Û¯_unbounded_above_thmİ : THM;
val Û¯_less_irrefl_thmİ : THM;	val Û¯_less_antisym_thmİ : THM;
val Û¯_less_trans_thmİ : THM;	val Û¯_less_cases_thmİ : THM;
val Û¯_¼_cases_thmİ : THM;	val Û¯_¼_less_cases_thmİ : THM;
val Û¯_eq_¼_thmİ : THM;		val Û¯_less_¼_trans_thmİ : THM;
val Û¯_¼_less_trans_thmİ : THM;val Û¯_¼_refl_thmİ : THM;
val Û¯_¼_antisym_thmİ : THM;	val Û¯_¼_trans_thmİ : THM;	
val Û¯_¼_³_less_thmİ : THM;	val Û¯_³_¼_less_thmİ : THM;
val Û¯_less_³_eq_thmİ : THM;	val Û¯_³_less_¼_thmİ : THM;
val Û¯_less_dense_thmİ : THM;	val Û¯_complete_thmİ : THM;
=DESCRIBE
These are the ML bindings for theorems in the theory ¯ concerned with basic properties
of the ordering relations. Note that $>$ and ¾ are defined in terms of $<$ and ¼
and the latter are the preferred form in all theorems in this theory.
=ENDDOC
=DOC
val Û¯_sup_thmİ : THM;		val Û¯_less_sup_thmİ : THM;
val Û¯_less_sup_bc_thmİ : THM;	val Û¯_¼_sup_thmİ : THM;
val Û¯_¼_sup_bc_thmİ : THM;	val Û¯__¼_sup_bc_thmİ : THM;
val Û¯_€_sup_thmİ : THM;	val Û¯_sup_¼_bc_thmİ : THM;
val Û¯_sup_less_bc_thmİ : THM;	val Û¯_sup_eq_bc_thmİ : THM;
val Û¯_eq_sup_bc_thmİ : THM;	val Û¯_less_sup__thmİ : THM;
=DESCRIBE
These are the ML bindings for theorems in the theory ¯ to assist with
reasoning about the values of the supremum function.
=ENDDOC
=DOC
val Û¯_plus_assoc_thmİ : THM;		val Û¯_plus_comm_thmİ : THM;
val Û¯_plus_unit_thmİ : THM;	val Û¯_plus_mono_thmİ : THM;
val Û¯_plus_assoc_thm1İ : THM;	val Û¯_plus_mono_thm1İ : THM;
val Û¯_plus_mono_thm2İ : THM;		val Û¯_plus_0_thmİ : THM;
val Û¯_0_1_thmİ : THM;			val Û¯_plus_order_thmİ : THM;
val Û¯_plus_minus_thmİ : THM;	val Û¯_eq_thmİ : THM;
val Û¯_plus_clausesİ : THM;		val Û¯_minus_clausesİ : THM;
val Û¯_less_clausesİ : THM;		val Û¯_¼_clausesİ : THM;
val Ûî¯_plus_homomorphism_thmİ : THM;
val Ûî¯_plus_homomorphism_thm1İ : THM;
val Û¯_minus_eq_thmİ : THM;		val Ûî¯_0_less_thmİ : THM;
val Ûî¯_one_one_thmİ : THM;		val Û¯_less_less_0_thmİ : THM;
val Û¯_less_0_less_thmİ : THM;		val Û¯_¼_¼_0_thmİ : THM;
val Û¯_¼_0_¼_thmİ : THM;		val Ûî¯_less_thmİ : THM;
val Û¯_less_strong_dense_thmİ : THM;val Ûî¯_¼_thmİ : THM;
val Û¯_sup_plus_thmİ : THM;		val Û¯_sup_plus_sup_thmİ : THM;
val Û¯_less_³_eq_0_thmİ : THM;
=DESCRIBE
These are the ML bindings for basic theorems about the additive structure
of the real numbers and its relationship with the ordering relations
and the supremum function.
=ENDDOC
=DOC
val Û¯_delta_induction_thmİ : THM;		
=DESCRIBE
This is the theorem that supports
=INLINEFT
¯_delta_induction_tac
=TEX
\ (q.v.).
=ENDDOC
=DOC
val Û¯_ord_pres_strict_thmİ : THM;
val Û¯_add_hom_0_thmİ : THM;
val Û¯_add_hom_minus_thmİ : THM;
val Û¯_add_hom_extension_thmİ : THM;
=DESCRIBE
These are ML bindings for theorems
about order-preserving functions and additive endomorphisms from ¯ to ¯.
=ENDDOC
=DOC
val Û¯_monoid_delta_dense_thmİ : THM;
val Û¯_monoid_dense_thmİ : THM;
val Û¯_subgroup_dense_thmİ : THM;
val Û¯_semigroup_dense_thmİ : THM;
val Û¯_add_hom_image_group_thmİ : THM;
val Û¯_add_hom_kernel_group_thmİ : THM;
=DESCRIBE
These are the ML bindings for theorems giving
various properties of substructures of the additive group ¯ and of
(additive) homomorphisms from ¯ to ¯.
=ENDDOC
=DOC
val Û¯_opah_thmİ : THM;		val Û¯_opah_strict_thmİ : THM;
val Û¯_opah_one_one_thmİ : THM;	val Û¯_opah_dense_image_thmİ : THM;
val Û¯_opah_onto_thmİ : THM;	val Û¯_opah_inverse_add_hom_thmİ : THM;
val Û¯_opah_inverse_thmİ : THM;	val Û¯_opah_extension_thm1İ : THM;
val Û¯_opah_extension_thm2İ : THM;	val Û¯_opah_extension_thmİ : THM;
val Û¯_opah_order_thmİ : THM;	val Û¯_opah_eq_thmİ : THM;
val Û¯_opah_complete_thmİ : THM;
=DESCRIBE
These are the ML bindings for theorems giving
various properties of order-preserving additive
homomorphisms from ¯ to ¯.
=ENDDOC
=DOC
val Û¯_copah_id_thmİ : THM;	val Û¯_copah_double_thmİ : THM;
val Û¯_copah_halve_thmİ : THM;	val Û¯_copah_comp_thmİ : THM;
val Û¯_copah_sum_thmİ : THM;	val Û¯_halve_closed_dense_thmİ : THM;
val Û¯_copah_dense_thmİ : THM;
=DESCRIBE
An order-preserving additive homomorphism from ¯ to ¯ is said to be ``central''
if it commutes with any homomorphism from ¯ to ¯.
These are the ML bindings for theorems giving
various properties of central order-preserving additive from ¯ to ¯.
=ENDDOC

=DOC
val Û¯_times_assoc_thmİ : THM;		val Û¯_times_unit_thmİ : THM;
val Û¯_times_comm_thmİ : THM;		val Û¯_times_assoc_thm1İ : THM;
val Û¯_times_plus_distrib_thmİ : THM;
val Û¯_0_less_0_less_times_thmİ : THM;	val Û¯_times_order_thmİ : THM;
val Û¯_times_clausesİ : THM;
val Û¯_times_0_thmİ : THM;			val Û¯_times_1_thmİ : THM;
val Û¯_times_cancel_thmİ : THM;		val Û¯_times_eq_0_thmİ : THM;
val Û¯_times_minus_thmİ : THM;
val Ûî¯_times_homomorphism_thmİ : THM;
val Ûî¯_times_homomorphism_thm1İ : THM;
val Û¯_times_mono_¤_thmİ : THM;		val Û¯_times_mono_thmİ : THM;
val Û¯_0_¼_0_¼_times_thmİ : THM;		val Û¯_cross_mult_less_thmİ : THM;
val Û¯_cross_mult_eq_thmİ : THM;
=DESCRIBE
These are the ML bindings for some basic theorems about the multiplicative structure
of the real numbers and its relationship with the additive and order structure.
=ENDDOC

=DOC
val Û¯_over_times_recip_thmİ : THM;		val Û¯_times_recip_thmİ : THM;
val Û¯_eq_recip_thmİ : THM;		val Û¯_recip_clausesİ : THM;
val Û¯_0_less_0_less_recip_thmİ : THM;	val Û¯_over_cancel_thmİ : THM;
val Û¯_over_plus_over_thmİ : THM;		val Û¯_0_over_thmİ : THM;
val Û¯_over_1_thmİ : THM;			val Û¯_³_recip_0_thmİ : THM;
=DESCRIBE
These are the ML bindings for some basic theorems about reciprocals (multiplicative
inverses) in the real numbers and their relationship with the other structure.
=ENDDOC

=DOC
val Û¯_frac_cross_mult_eq_thmİ : THM;
val Û¯_frac_cancel_thmİ : THM;
val Û¯_frac_0_thmİ : THM;
val Û¯_frac_î_thmİ : THM;
val Û¯_frac_plus_frac_thmİ : THM;
val Û¯_frac_minus_frac_thmİ : THM;
val Û¯_frac_minus_frac_thm1İ : THM;
val Û¯_over_times_over_thmİ : THM;
val Û¯_frac_times_frac_thmİ : THM;
val Û¯_over_recip_thmİ : THM;
val Û¯_frac_recip_thmİ : THM;
val Û¯_minus_recip_thmİ : THM;
val Û¯_over_eq_0_thmİ : THM;
val Û¯_over_over_over_thmİ : THM;
val Û¯_frac_less_frac_thmİ : THM;
val Û¯_minus_frac_less_frac_thmİ : THM;
val Û¯_frac_less_minus_frac_thmİ : THM;
val Û¯_0_¼_frac_thmİ : THM;
val Û¯_abs_frac_thmİ : THM;
val Û¯_abs_minus_thmİ : THM;
=DESCRIBE
These are the ML bindings for some theorems about rational numbers (in ¯) expressed as
fractions with natural number numerators and denominators.

The very last theorem is a general fact about absolute values.
=ENDDOC
=DOC
val Ûú¯_plus_homomorphism_thmİ : THM;
val Ûú¯_minus_thmİ : THM;
val Ûú¯_îú_thmİ : THM;
val Ûú¯_times_homomorphism_thmİ : THM;
=DESCRIBE
These are the ML bindings for theorems in the theory ¯ to assist with
reasoning about the embedding of the integers in the reals.
=ENDDOC
\subsection{Tactics}

=DOC
val Û¯_delta_induction_tacİ  : TERM -> TACTIC;
=DESCRIBE
This is an induction-like tactic that can be used to prove that a property
holds in a half-open interval of the real numbers: to prove that 
=INLINEFT
t[y]
=TEX
holds whenever $x < y$, it suffices to exhibit a positive number $d$ suc
that {\em(i)} $t[u/y]$ holds
for each $u$ with $x < u < x + e$ where $d < e$ and
{\em(ii)} $t[s+d/y]$ holds if $t[s/y]$ holds, for any $s$ with $x < s$.


The term argument $y$ must be a variable that appears free in the conclusion of the goal.
The variable must also appear free once, and only once, in the assumptions, in an
assumption of the form $x < y$.
=FRULE 2 Tactic
¯_delta_induction_tac ¬y®
÷
{ ‡; x < y } t [y/y]
÷
{ ‡ } ¶d·î¯ 0 < d
± (¶e·d < e ±
    (µu·x < u ± u < x + e ´
	t[u/y]))
± (µs·x < s ± p s ´
	t[s + d/y]))
=TEX
=FAILURE
116001	?0 is not a variable of type ”¯®
116002	A term of the form ñx < y® where y is the induction variable
	could not be found in the assumptions
116003	?0 does not appear free in the conclusions of the goal
116004	?0 appears free in more than one assumption of the goal
=ENDDOC


\subsection{Computational Conversions}
The computational conversions deal with real literals which have the
one of the forms:
=GFT
	î¯ m
	m / n
=TEX
where $m$ and $n$ are natural number literals with $n \neq 0$. A literal of the
second form is said to be in normal form when $m$ and $n$ are
coprime and $n \neq 1$.
=DOC
val Û¯_frac_norm_convİ : CONV;	val Û¯_frac_plus_frac_convİ : CONV;
=DESCRIBE
=INLINEFT
¯_frac_norm_conv
=TEX
\ proves theorems giving a normal form for real literals expressed as numeric
fractions. The theorems have the form:
=GFT
ô m /‰N n = î¯ m'
ô m /‰N n = m' /‰N n' 
=TEX
\ where $m$, $n$, $m'$ and $n'$ are natural number literals and, in the second case,
$m'$ and $n'$ are coprime and $n' > 1$.

=INLINEFT
¯_frac_plus_frac_conv
=TEX
\ proves theorems of the forms:

=GFT
ô m /‰N n +  m' /‰N n' = t
=TEX
\ where $m$, $n$, $m'$ and $n'$ are natural number literals and $t$ is in the same
kind of normal form as produced by
=INLINEFT
¯_frac_norm_conv
=TEX
.
=FAILURE
116301	?0 is not of the form ¬m /‰N n® or ¬î¯ m®
116302	cannot simplify ?0 because it denominator is 0
116303	?0 is already in normal form
116304	?0 is not of the form ¬(i /‰N m) +‰R (j /‰N n)®
=ENDDOC

=DOC
val Û¯_plus_convİ : CONV;		val Û¯_times_convİ : CONV;
val Û¯_less_convİ : CONV;
val Û¯_¼_convİ : CONV;			val Û¯_eq_convİ : CONV;
val Û¯_over_convİ : CONV;		val Û¯_î_exp_convİ : CONV;
=DESCRIBE
These conversions compute theorems of the form
=GFT
ô x op y = z
=TEX
\ where $x$ and $y$ are rational literals and $op$ is the operation indicated by
the name of the conversion.
A rational literal is taken to be an optionally signed expression made
up from natural number literals using
=INLINEFT
î¯
=TEX
\ or
=INLINEFT
/‰N
=TEX
.
The term $z$ is a truth value or an optionally signed rational literal in normal form (see
=INLINEFT
¯_frac_norm_conv
=TEX
\ as appropriate.

=FAILURE
116305	?0 is not of the form ¬x +‰R y® where ¬x® and ¬y® are rational literals
116306	?0 is not of the form ¬x *‰R y® where ¬x® and ¬y® are rational literals
116309	?0 is not of the form ¬x < y® where ¬x® and ¬y® are rational literals
116310	?0 is not of the form ¬x ¼ y® where ¬x® and ¬y® are rational literals
116311	?0 is not of the form ¬x = y® where ¬x® and ¬y® are rational literals
116312	?0 is not of the form ¬x / y® where ¬y® is a rational literal
116317	?0 is not of the form ¬x ^‰N m® where ¬x® is a rational number literal
	and ¬m® is a natural number literal
=ENDDOC
=DOC
val Û¯_ú_exp_convİ : CONV;
=DESCRIBE
This conversions computes theorems of the form and
=GFT
ô x ^‰Z îú m = x ^‰N m
ô x ^‰Z ~(îú m) = (x ^‰N m)›-›1
=TEX

=FAILURE
116321	?0 is not of the form ¬x ^‰Z m®
=ENDDOC
=DOC
val Û¯_abs_convİ : CONV;	val Û¯_recip_convİ : CONV;	
=DESCRIBE
These conversions compute theorems of the form:
=GFT
ô Abs x = z
ô x ›-›1 = z
=TEX
where $x$ and $z$ are rational literals (see%
=INLINEFT
¯_plus_conv
=TEX
.
=FAILURE
116307	cannot take the reciprocal of ?0 because its denominator
	or numerator is 0
116308	?0 is not of the form ¬x ›-›1® where ¬x® is
	a rational literal
116316	?0 is not of the form ¬Abs (i/m)®
	where ¬m® is a natural number literal
=ENDDOC
=DOC
val Û¯_minus_convİ : CONV;
=DESCRIBE
This conversion simplifies expressions involving real negation.
It returns theorems of the form:
=GFT
ô ~(~ x ) = x
ô ~(0/1) = î¯ 0
ô ~(î¯ 0) = î¯ 0
=TEX

=FAILURE
116319	?0 is not of the form ¬~ (~ x)® or ¬~(î¯ 0)®
=ENDDOC
=DOC
val Û¯_greater_convİ : CONV;	val Û¯_¾_convİ : CONV;
val Û¯_subtract_convİ : CONV;
=DESCRIBE
These conversions prove theorems of the following forms:
=GFT
ô x > y ¤ y < x
ô x ¾ y ¤ y ¼ x
ô x - y ¤ y + ~x
=TEX
=FAILURE
116313	?0 is not of the form ¬x > y® where ¬x® and ¬y® have type ”¯®
116314	?0 is not of the form ¬x ¾ y® where ¬x® and ¬y® have type ”¯®
116315	?0 is not of the form ¬x - y® where ¬x® and ¬y® have type ”¯®
=ENDDOC
=DOC
val Û¯_eval_convİ : CONV;	val Û¯_EVAL_Cİ : CONV -> CONV;
=DESCRIBE
=INLINEFT
¯_eval_conv
=TEX
\ computes theorems of the form
=INLINEFT
ô t1 = t2
=TEX
\ where $t1$ is an expression made up from rational literals (see
=INLINEFT
¯_plus_conv
=TEX
) using real addition, subtraction, multiplication, division, reciprocal,
absolute value and unary negation.
$t2$ will be an optionally signed rational literal in normal form.
The conversion fails if the expression cannot be evaluated (e.g., because
it contains variables).

=INLINEFT
¯_EVAL_C conv
=TEX
\ is similar to
=INLINEFT
¯_eval_conv
=TEX
\ but it also applies
=INLINEFT
conv
=TEX
\ to any subterm that cannot be evaluated using the conversions for the
arithmetic operations listed above.
E.g.,
=INLINEFT
¯_EVAL_C ¯_î_exp_conv
=TEX
\ will evaluate expressions involving the usual arithmetic operations and
also exponentiation of rational literals by natural number literals.
=FAILURE
116320	?0 cannot be evaluated
=ENDDOC

=DOC 
	val Û¯_term_orderİ : TERM -> TERM -> int;
=DESCRIBE
=INLINEFT
¯_term_order
=TEX
\ gives an ordering relation on HOL terms analogous to that given by $term\_order$, q.v., but which takes special arrangements for certain terms of type ¯.
In particular it has a special treatment of monomials
whose first items are rational literals (formed using î¯ or natural number
division with natural number literal operands) and of terms formed from rational
literals using unary minus and the reciprocal operator.
A rational literal immediately precedes
the same monomial with any combination of signs or reciprocals,
and these in turn precedes the same monomial with a signed literal multiplier, e.g.:

=GFT
	a*b < ~a * b < î¯ 2 * a * b < ~(2/1)›-›1 * a * b < ....
=TEX
=ENDDOC
=DOC
val Û¯_ANF_Cİ : CONV -> CONV;
val Û¯_anf_convİ : CONV;
=DESCRIBE
=INLINEFT
¯_anf_conv
=TEX
\ is a conversion which proves theorems of the form
=INLINEFT
ô t1 = t2
=TEX
\ where $t1$ is a term formed from atoms of type ¯ and
$t2$ is in what we may call additive normal form, i.e. it has the form:
=INLINEFT
t‰1 + t‰2 + ...
=TEX
, where the 
=INLINEFT
t‰i
=TEX
\ have the form
=INLINEFT
s‰1 * s‰2 * ...
=TEX
where the
=INLINEFT
s‰i
=TEX
\ are atoms.
Here, by atom
we mean a term which is not of the form
=INLINEFT
t‰1 + t‰2 + ...
=TEX
or
=INLINEFT
s‰1 * s‰2 * ...
=TEX
.

The summands
=INLINEFT
t‰i
=TEX
\ and,
within them,
the factors
=INLINEFT
s‰j
=TEX
\ are given in increasing order with respect to the ordering
on terms given by the function 
=INLINEFT
¯_term_order
=TEX
, q.v. Arithmetic computation is carried out on atoms to ensure
that at most one of the summands is a rational literal and that, within
each summand, at most one factor is a rational literal. Any literal appears
at the beginning of its factor or summand and addition of $0$
or multiplication by $1$ is simplified out.

=INLINEFT
¯_ANF_C conv
=TEX
\ is a conversion which acts like
=INLINEFT
¯_anf_conv
=TEX
\ but which applies
=INLINEFT
conv
=TEX
\ to each atom as it is encountered (and normalises the result recursively).
The argument conversion  may signal that it does not
wish to change a subterm, $t$ say, either by failing or by returning $t = t$,
the former approach is more efficient.

The conversions fail with error number 116318 if there are no changes to be
made to the term.

=FAILURE
116318	?0 is not of type ”¯® or is already in additive normal form
=ENDDOC
=DOC
	val Û¯_eq_cancel_convİ : CONV
	val Û¯_¼_cancel_convİ : CONV
	val Û¯_less_cancel_convİ : CONV
=DESCRIBE
=INLINEFT
¯_eq_cancel_conv
=TEX
\ (resp.
=INLINEFT
¯_¼_cancel_conv
=TEX
, resp.
=INLINEFT
¯_less_cancel_conv
=TEX
) puts arithmetic equations (resp. inequalities formed with $¼$) in
a normal form in which the right-hand side is a signed literal and
the left-hand side is in additive normal form, in the
sense of
=INLINEFT
¯_anf_conv
=TEX
, q.v.

For example, the calls:
=GFT ProofPower Input
¯_eq_cancel_conv¬x + î¯ 2*y + î¯ 3 = î¯ 1 + î¯ 6*y®;
¯_¼_cancel_conv¬x + î¯ 2*y + x + î¯  3 ¼ y + î¯ 2 + î¯ 2*x + y®;
¯_less_cancel_conv¬x + î¯ 2*y + x + î¯  3 < y + î¯ 2 + î¯ 2*x + y®;
=TEX
produce the following output
=GFT ProofPower Output
val it = ô x + î¯ 2 * y + î¯ 3 = î¯ 1 + î¯ 6 * y
	¤ x + ~ (î¯ 4) * y = ~ (î¯ 2) : THM
val it = ô x + î¯ 2 * y + x + î¯ 3 ¼ y + î¯ 2 + î¯ 2 * x + y
	¤ î¯ 1 ¼ î¯ 0 : THM
val it = ô x + î¯ 2 * y + x + î¯ 3 ¼ y + î¯ 2 + î¯ 2 * x + y
	¤ î¯ 1 < î¯ 0 : THM
=TEX

Note that if the left-hand side reduces to $0$ the truth value is not evaluated.
However,
=INLINEFT
¯_eq_conv
=TEX
,
=INLINEFT
¯_¼_conv
=TEX
\ or
=INLINEFT
¯_less_conv
=TEX
\ may be used to perform the evaluation, where required.

=USES
The conversions are intended for use in tactic and conversion programming.
The normal interactive interface is via rewriting or stripping in the proof context
=INLINEFT
¯_lin_arith
=TEX
, which performs other useful simplifications.
=FAILURE
116520	?0 is not of the form (t1:¯) = t2 or is already in normal form
116521	?0 is not of the form (t1:¯) ¼ t2 or is already in normal form
116522	?0 is not of the form (t1:¯) < t2 or is already in normal form
=SEEALSO
=INLINEFT
¯_lin_arith (proof context)
=TEX
=ENDDOC




=DOC
	val Û¯_lin_arith_ruleİ : TERM list -> THM;
	val Û¯_lin_arith_tacİ : TACTIC;
	val Û¯_lin_arith_prove_tacİ : THM list -> TACTIC;
=DESCRIBE
Given a system,
=INLINEFT
‡ = [r‰1, r‰2, ...]
=TEX
, of numeric constraints,
=INLINEFT
r‰i
=TEX
, of the form
=INLINEFT
(s‰i:¯) = c‰i
=TEX
or
=INLINEFT
s‰i ¼ c‰i
=TEX
, where the
=INLINEFT
c‰i
=TEX
\ are rational literals,
the rule attempts to prove a theorem of the form
=INLINEFT
‡ ô F
=TEX
. Terms in ‡ which are not of either of these forms are ignored and
do not appear in the assumptions of the result theorem.


The tactics use the rule in much the same way as the integer linear
arithmetics use
=INLINEFT
ú_lin_arith_rule
=TEX
\ (see
=INLINEFT
ú_lin_arith_tac
=TEX
).
The usual interface to these functions is via the decision procedures in the
proof context $¯\_lin\_arith$, q.v., e.g. as invoked by
=INLINEFT
PC_T1"¯_lin_arith"prove_tac[]
=TEX

The algorithm for the decision procedure is very similar to the one used in $lin\_arith\_rule$, q.v.

=FAILURE
116341	The linear arithmetic proof procedure cannot prove this conjecture
=ENDDOC

=SML
end (* of signature ¯ *);
=TEX


\section{PROOF CONTEXTS}
=DOC
(* Proof Context: Û'¯İ *)
=DESCRIBE
A component proof context for handling the basic arithmetic operations
for real numbers in HOL. 

Expressions and predicates treated by this proof context are constructs formed from:
=GFT
+, *, -, Abs‰R, /‰R, ¼, <, ¾, >, =
=TEX

\paragraph{Contents}\ 

Rewriting:
=GFT
¯_plus_conv, ¯_times_conv, ¯_subtract_minus_conv
¯_abs_conv, ¯_over_conv, ¯_recip_conv, ¯_î_exp_conv, ¯_ú_exp_conv,
¯_eq_conv, ¯_¼_conv, ¯_less_conv
¯_¾_conv, ¯_greater_conv,
¯_plus_clauses, ¯_minus_clauses, ¯_¼_clauses
¯_less_clauses, ¯_frac_norm_conv 
=TEX
Stripping theorems:
=GFT
¯_eq_conv, ¯_¼_conv, ¯_less_conv
¯_¾_conv, ¯_greater_conv,
¯_plus_clauses, ¯_minus_clauses, ¯_¼_clauses
¯_less_clauses, 
and all the above pushed through ³

=TEX

Stripping conclusions: as for stripping theorems.

Rewriting canonicalisation: blank.

=TEX
Automatic proof procedures:
=INLINEFT
basic_prove_tac
=TEX
,
=INLINEFT
basic_prove_conv
=TEX
.

Automatic existence prover: blank.
=ENDDOC


=DOC
(* Proof Context: Û¯_lin_arithİ *)
=DESCRIBE
This is a proof context whose main purpose is to supply a decision procedure
for problems in linear arithmetic over the HOL integers.
\paragraph{Contents}
The rewriting, theorem stripping and conclusion stripping components are
as for the proof context $predicates$, q.v, each augmented with conversions
effecting the following transformations, where $a$ and $b$ stand for
numeric literals.
=GFT
a = b	­	¯_eq_conv¬a = b®
a ¼ b	­	¯_¼_conv¬a ¼ b®
t1 = t2		­	¯_eq_cancel_conv¬t1 = t2®
t1 ¼ t2		­	¯_¼_cancel_conv¬t1 ¼ t2®
³ t1 = t2	­	t1 < t2 ² t2 < t1
³ t1 ¼ t2	­	t2 < t1
t1 < t2	­	t1 + 1 ¼ t2
t1 ¾ t2	­	t2 ¼ t1
t1 > t2	­	t2 < t
³ t1 < t2	­	t2 ¼ t1
³ t1 ¾ t2	­	³ t2 ¼ t1
³ t1 > t2	­	t1 ¼ t2
t1 = t2	­	t1 = t2
t1 ¼ t2	­	t1 ¼ t2
=TEX
(where all variables are of type ¯).

The automatic proof tactic works by {\em(i)} restripping all the
assumptions of the goal, {\em(ii)} adding the argument theorems
to the stock of assumptions using $strip\_asm\_tac$, {\em(iii)} applying
$contr\_tac$, and {\em(iv)} searching for a linear combination of
the assumptions which will reduce, by multiplying out and cancelling like terms,
to a contradiction of the form $a = b$ or
$a ¼ b$ with $a$ and $b$ numeric literals.
The automatic proof conversion just tries to prove its argument, $t$ say, using
the automatic proof tactic and returns $t = T$ if it succeeds.

Other components of the proof context are as for $predicates$.

For example, 
=INLINEFT
PC_T1"¯_lin_arith"prove_tac[]
=TEX
\ will prove any of the following goals:
=GFT
	([], ¬µa b c:¯·a ¼ b ± (a + b < c + a) ´ a < c®)
	([], ¬µa b c:¯·a ¾ b ± ³ b < c ´ (1/2) * a ¾(1/2) * c®)
	([], ¬µa b c:¯·a + î¯ 2*b < î¯ 2*a ´ b + b < a®)
	([], ¬µ x y:¯· ³ (î¯ 2*x + y = 1/3 ± î¯ 4*x + î¯ 2*y = 2/5)®)
=TEX
=SEEALSO
=INLINEFT
'¯_lin_arith
=ENDDOC
=DOC
(* Proof Context: Û'¯_lin_arithİ *)
=DESCRIBE
This is a component
proof context whose main purpose is to supply a decision procedure
for problems in linear arithmetic for the HOL integers.
\paragraph{Contents}
The rewriting, theorem stripping and conclusion stripping components
are as for the proof context $¯\_lin\_arith$ but without any of the
material from the proof context $predicates$.
The automatic proof components are as for $lin\_arith$.
Other components are blank.

A typical use of the proof context would be to solve problems containing
a mixture of linear real number arithmetic and set theory.
=ENDDOC


\section{TEST POLICY}
The module tests for this module are to follow the guidelines
laid down in the quality plan~\cite{DS/FMU/IED/PLN007}.
The various conversions, tactics etc. need to be tested in addition to the
check of the theory design.


\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}







