=IGN
********************************************************************************
imp105.doc: this file is part of the PPHol system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\def\TPPheadtitle{Integer Arithmetic}
\TPPtitle{Implementation of Arithmetic Proof Procedures for HOL Integers}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP105}  %% Mandatory field
\def\SCCSversion{$Revision: 1.11 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2005/04/24 16:01:30 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D.~Arthan & WIN01}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the implementation of proof
procedures the HOL integers.
These include arithmetic normalisation and a linear arithmetic prover.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item[1.1-1.3] First drafts.
\item[1.4] First product version.
\item[1.5] Update for new INTEGER type.
\item[1.6] Removed premature end of document.
\item[1.7] Fixed bug in {\it add\_simp\_conv}.
\item[1.8] Fixed {\LaTeX} errors.
\item[Issue 1.9 (2002/10/17)] Copyright and banner updates for open source release.
\item[Issue 1.10 (2002/10/17)] PPHol-specific updates for open source release
\item[Issue 1.11 (2005/04/24)] Now uses {\tt app} rather than {\tt map} when appropriate.
\item[Issue 1.12 (2005/05/31)] Now allow for adding theorems into the theory ú here.
\item[2014/07/23]
Augmented old RCS version numbers in the changes history with dates.
Dates will be used in place of version numbers in future.

%%%% END OF CHANGES HISTORY %%%%
\end{description}
\subsection{Changes forecast}
As determined by comment and review.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of part of the \ProductHOL\ system.
The document responds to \cite{DS/FMU/IED/DTD105}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
\subsubsection{Dependencies}
This document depends on the theory $basic\_hol$ defined in
\cite{DS/FMU/IED/DTD045}, on the conversions in
\cite{DS/FMU/IED/DTD081}, and on the tactics and rules of
\cite{DS/FMU/IED/DTD027,DS/FMU/IED/DTD029}.
\subsubsection{Algorithms}
See the detailed design document \cite{DS/FMU/IED/DTD105} for
a general description of the algorithm and the remarks between code
fragments below for
more detailed discussion of implementation techniques, such as the
representation of the problems.

The arithmetic normaliser is similar to, but more complex  than, that in \cite{DS/FMU/IED/IMP082}.
The linear arithmetic prover is similar to, but simpler than, that in \cite{DS/FMU/IED/IMP082}.
In both cases, the difference in complexity is due to negation, which leads to more cases in normalisation, but a simpler normal form, and hence fewer cases, in the linear arithmetic prover.
\subsubsection{Known Deficiencies}
See \cite{DS/FMU/IED/DTD105}.
\subsubsection{Possible Enhancements}
See \cite{DS/FMU/IED/DTD105}.
\section{PREAMBLE}
=SML
structure ÛúArithmeticToolsİ : úArithmeticTools = struct
=TEX
\section{PREAMBLE}
=SML
open ú;
val Ûold_theoryİ = get_current_theory_name();
val _ = open_theory"ú";
val _ = push_merge_pcs ["'ú", "'î", "predicates"];
=TEX
\section{TERM NORMALISATION}
The material in this section implements the treatment of polynomial
normalisation for the integers and is modelled quite closely on the
treatment for the natural numbers given in \cite{DS/FMU/IED/DTD081}.
\subsection{Discussion}
The normal form we use applies to the set of terms described informally
by the following (ambiguous) BNF grammar, in which, of course, all the operations are the
integer versions:
=GFT
	IntTerm		= IntTerm, "*", IntTerm
			| IntTerm, "-", IntTerm
			| IntTerm, "+", IntTerm
			| "~", IntTerm
			| IntAtom;
	IntAtom		= ? Anything not of the form IntTerm ?;
=TEX
Such a term is normalised by ``multiplying out and collecting like terms'' to
give a normal form described by the following grammar:
=GFT
	NormIntTerm	= Monomial, {"+", Monomial};
	Monomial	= HeadFactor, {"*", TailFactor};
	HeadFactor	= ["~"], (IntLit | TailFactor);
	TailFactor	= IntAtom - IntLit;
=TEX
The above grammar is intended to be interpreted with the usual HOL rules
for precedence and assocation. Thus, the monadic minus in a head factor
has as its argument the rest of the head factor (not including the product of
the tail factors).

All the tail factors in a normalised monomial are ordered with respect to a fixed total ordering of HOL terms as are the monomials within a $NormIntTerm$.
This ordering is defined in the next section.
An $IntLit$ as the head factor of a normalised monomial is never $0$, $1$ or
=INLINEFT
~1
=TEX
\ unless the monomial contains no tail factors.

Like monomials are ``collected'' in the sense that there are no repetitions
amongst the monomials obtainable from a $NormIntTerm$ by deleting any
monadic minuses and $IntLit$s which appear in it.
(I.e. terms like
=INLINEFT
~x + x
=TEX
\ or
=INLINEFT
~x + y + ~2*x
=TEX
\ do not arise).
A $NormIntTerm$ will contain at most one monomial comprising of a single
signed literal. The $IntLit$s in a monomial are never zero unless the
whole $NormIntTerm$ consists of the single literal zero (i.e. ¬îú\,0®).
\section{TERM ORDERING FOR ú}
The ordering must bring together signed literals and like monomials.
We arrange things so that a monomial with a sign comes immediately after the monomial, and with a literal multiplier immediately after that, e.g.:

=GFT
	a*b < ~a * b < 0 * a * b < ~1 * a * b < 1 * a * b < ....
=TEX
.
=SML
local
val Ûbottomİ : TERM = mk_const("", mk_vartype "");
val Ûmk_0İ = ¬0®;
val two = @@"2";
fun int_to_nat (i : INTEGER) : INTEGER = (
	if i @>= zero
	then two@*i @+ two
	else (two @* @~i) @+ one
)
fun Ûpervertİ (tm : TERM) : TERM * INTEGER = (
	let	val (a, b) = dest_ú_times tm
	in	(b, int_to_nat(dest_ú_signed_int a))
		handle Fail _ => (mk_ú_times(dest_ú_minus a, b), one)
		handle Fail _ => (tm, zero)
	end	handle Fail _ => (bottom, int_to_nat(dest_ú_signed_int tm))
		handle Fail _ => (dest_ú_minus tm, one)
		handle Fail _ => (tm, zero)
);
in
val Ûú_term_orderİ : TERM -> TERM -> int = gen_term_order pervert;
end;

=TEX
\section{ANF FOR ú}
We need conversions and supporting theorems which do collection of
like terms.
First of all we need to provide conversions which, given a (sorted) sum,
=INLINEFT
m‰1 + m‰2
=TEX
\ of two normalised monomials will do all applicable simplifications which can reduce the sum to a single monomial.
We find the following cases, in which $c$d and $d$ denote literals, and where, on the right hand-side of the equations, literal arithmetic expressions are intended to have been evaluated:
=GFT
1.	c*m +d*m 	=	(c + d)*m
2.	m +d*m 		=	(1 + d)*m
3.	0 + m		=	m
4.	c + d		=	c + d
5.	m + m 		=	2*m
6.	m + ~m 		=	0
7.	m*n + ~m*n	=	0
8.	~m + d*m	=	(~1 + d)*m	
9.	~m*n + d*m*n	=	(~1 + d)*m*n
10.	m + 0		=	0
=TEX
Here case 4 is directly supported by $plus\_conv$ (note that the order
here is important since case 4 overlaps case 5).
Note that case 5 may introduce a monadic minus in the wrong place.
The others will not do this unless their input has the same flaw.
Note also that cases 1, 2, 8 and 9 may introduce multiplication
by $1$,
=INLINEFT
~1
=TEX
, or $0$ which must be simplified away.
Case 10 only arises when cancellation during in the polynomial normalisation has caused a sub-polynomial to become $0$.
=SML
val Ûcase1_thmİ = tac_proof(([], ¬µc d m:ú·c*m + d*m = (c + d)*m®),
	rewrite_tac[ú_times_plus_distrib_thm]);
val Ûcase2_thmİ = tac_proof(([], ¬µd m:ú·m + d*m = (îú 1 + d)*m®),
	rewrite_tac[ú_times_plus_distrib_thm, ú_plus_assoc_thm]);
val Ûcase3_thmİ = tac_proof(([], ¬µm·îú 0 + m = m®),
	rewrite_tac[]);
val Ûcase5_thmİ = tac_proof(([], ¬µm:ú·m + m = îú 2*m®),
	pure_rewrite_tac[prove_rule[]¬îú 2 = îú 1 + îú 1®,
		 ú_times_plus_distrib_thm]
	THEN rewrite_tac[]);
val Ûcase5a_thmİ = tac_proof(([], ¬µm n:ú·m * ~ n= ~m * n®),
	rewrite_tac[ú_times_minus_thm]);
val Ûcase5b_thmİ = tac_proof(([], ¬µm n p:ú·m * ~ n * p = ~m * n *p®),
	rewrite_tac[ú_times_minus_thm]);
val Ûcase6_thmİ = tac_proof(([], ¬µm:ú·m + ~m = îú 0®),
	rewrite_tac[ú_minus_clauses]);
val Ûcase7_thmİ = tac_proof(([], ¬µm n:ú·m*n + ~m*n = îú 0®),
	rewrite_tac[ú_minus_clauses, ú_times_minus_thm]);
val Ûcase8_thmİ = tac_proof(([], ¬µm:ú·~m + d*m = (~(îú 1) + d)*m®),
	rewrite_tac[ú_times_minus_thm,
		ú_times1_thm, ú_times_plus_distrib_thm]);
val Ûcase9_thmİ = tac_proof(([], ¬µm n:ú·~m*n + d*m*n = (~(îú 1) + d)*m*n®),
	rewrite_tac[ú_times_minus_thm,
		ú_times1_thm, ú_times_plus_distrib_thm]);
val Ûcase10_thmİ = tac_proof(([], ¬µm:ú·m + îú 0 = m®),
	rewrite_tac[ú_plus0_thm]);
val Ûcase1289a_thmİ = tac_proof(([], ¬µm:ú·îú 1 *m = m®),
	rewrite_tac[ú_times1_thm]);
val Ûcase1289b_thmİ = tac_proof(([], ¬µm:ú·~(îú 1) * m = ~m®),
	rewrite_tac[ú_times1_thm, ú_times_minus_thm]);
val Ûcase1289c_thmİ = tac_proof(([], ¬µm:ú·(îú 0) * m = îú 0®),
	rewrite_tac[ú_times0_thm]);
=TEX
Now we provide the conversions to support the 8 cases:
=SML
val Ûcase1289_convİ : CONV = (
	(simple_eq_match_conv case1289a_thm ORELSE_C
		simple_eq_match_conv case1289b_thm ORELSE_C
		simple_eq_match_conv case1289c_thm)
);
val Ûcase1_convİ : CONV = (fn tm => (
	(((dest_ú_signed_int o fst o dest_ú_times) **
		(dest_ú_signed_int o fst o dest_ú_times))
		o dest_ú_plus) tm;
	(simple_eq_match_conv case1_thm THEN_C LEFT_C ú_plus_conv
		THEN_TRY_C case1289_conv) tm
));
val Ûcase2_convİ : CONV = (fn tm => (
	(dest_ú_signed_int o fst o dest_ú_times o snd o dest_ú_plus) tm;
	(simple_eq_match_conv case2_thm THEN_C LEFT_C ú_plus_conv
		THEN_TRY_C case1289_conv) tm
));
val Ûcase3_convİ : CONV = (fn tm =>
	if (dest_ú_signed_int o fst o dest_ú_plus) tm = zero
	then (simple_eq_match_conv case3_thm) tm
	else fail_conv tm
);
val Ûcase4_convİ = ú_plus_conv;
val Ûcase5_convİ = simple_eq_match_conv case5_thm
	THEN_TRY_C (simple_eq_match_conv case5a_thm ORELSE_C
			simple_eq_match_conv case5b_thm);
val Ûcase6_convİ = simple_eq_match_conv case6_thm;
val Ûcase7_convİ = simple_eq_match_conv case7_thm;
val Ûcase8_convİ : CONV = (fn tm => (
	(dest_ú_signed_int o fst o dest_ú_times o snd o dest_ú_plus) tm;
	(simple_eq_match_conv case8_thm THEN_C LEFT_C ú_plus_conv
		THEN_TRY_C case1289_conv) tm
));
val Ûcase9_convİ : CONV = (fn tm => (
	(dest_ú_signed_int o fst o dest_ú_times o snd o dest_ú_plus) tm;
	(simple_eq_match_conv case9_thm THEN_C LEFT_C ú_plus_conv
		THEN_TRY_C case1289_conv) tm
));
val Ûcase10_convİ = simple_eq_match_conv case10_thm;
=TEX
=SML
=TEX
The following conversional converts a conversion acting on $x + y$, say,
to one which will also act on $x + y + z$ (by rewriting it as $(x + y) + z$
and then applying the conversion to the subterm $x + y$).
=SML
val Ûú_plusİ = ¬$+‰Z®;
fun ÛA_Cİ (c : CONV) : CONV = (fn tm =>
	let	val (ltm, rtm) = dest_ú_plus tm;
		exception BaseCase;
	in let	val (rtm1, rtm2) = dest_ú_plus rtm handle Fail _ => raise BaseCase;
		val thm = c (mk_ú_plus(ltm, rtm1));
	in	eq_trans_rule
		(list_µ_elim[ltm, rtm1, rtm2] ú_plus_assoc_thm1)
		(app_arg_rule rtm2 (app_fun_rule ú_plus thm))
	end 	handle BaseCase => c tm
	end
);
=TEX
We want to simplify multiplication according to the following scheme, where $x$ and $y$ denotes atoms (and other variables are as in the list of simplifications for addition):
=GFT
1.	c*d		= c*d
2.	0*x		= 0
3.	1*x		= x
4.	~1*~x		= x
5.	~1*x		= ~x
6.	~x*~y		= x*y
7.	x*~y		= ~x*y
=TEX
=SML
val Ûtimes234567_thmİ = tac_proof(([],
	¬µx y:ú·îú
		0 * x = îú 0
	±	îú 1 * x = x
	±	~(îú 1) * ~x = x
	±	~(îú 1) * x = ~x
	±	~x * ~y = x*y
	±	x * ~y = ~x*y ®),
		rewrite_tac[ú_times_clauses, ú_times_minus_thm]);
=TEX
=SML
val Ûtimes1234567_convİ : CONV =
	FIRST_C (ú_times_conv :: map simple_eq_match_conv (current_ad_rw_canon() times234567_thm));
=TEX
$M\_C$ is analogous to $A\_C$ but for multiplication rather than addition.
There are additional cases to worry about.
=SML
val Ûtimes0_thmİ = tac_proof(([],
	¬µx:ú·îú 0 * x = îú 0®),
		rewrite_tac[ú_times_clauses]);

val Ûú_timesİ = ¬$*‰Z®;
fun ÛM_C1İ (c : CONV) : CONV = (fn tm =>
	let	val (ltm, rtm) = dest_ú_times tm;
		exception BaseCase;
	in let	val (rtm1, rtm2) = dest_ú_times rtm handle Fail _ => raise BaseCase;
		val thm = c (mk_ú_times(ltm, rtm1));
	in	eq_trans_rule
		(list_µ_elim[ltm, rtm1, rtm2] ú_times_assoc_thm1)
		(app_arg_rule rtm2 (app_fun_rule ú_times thm))
	end 	handle BaseCase => c tm
	end
);
fun ÛM_Cİ (c : CONV) : CONV =
	M_C1 c THEN_TRY_C
	FIRST_C (map simple_eq_match_conv [times0_thm, ú_times_assoc_thm]
);
=TEX
Pulling these bits together we get the following:.
=SML
val Ûadd_simp_convİ =
	FIRST_C(map A_C[
		case1_conv, case2_conv, case3_conv, case4_conv,
		case5_conv, case6_conv, case7_conv, case8_conv,
		case9_conv, case10_conv]) THEN_C TRY_C case3_conv;
val Ûtimes_simp_convİ = M_C times1234567_conv;

=TEX
Unlike the natural number case, we have some  non-trivial work to
do trying to make non-atoms from what $poly\_conv$ will see as
atoms if we don't push monadic and dyadic minus around.
The transformation is done according to the following schema:
=GFT
1. ~ (~ m)		= m			(repeatedly)
2. ~(m + n)		= ~m + ~n
3. ~(m * n)		= ~m * n
4. (m - n)		= m + ~n
5. ~(m - n)		= ~m + n
6. ~0			= 0
=TEX
Note that the first of these must be performed repeatedly, since $poly\_conv$
will only apply it once, and, if there are more than four monadic minuses
this may be insufficient to reveal a non-atom for $poly\_conv$ to attack.
=SML
val Ûminus1_thmİ = tac_proof(([], ¬µm:ú·~ (~ m) = m®),
	rewrite_tac[ú_minus_thm]);
val Ûminus23456_thmİ = tac_proof(([],
	¬µm:ú·~(m + n) =~m + ~n
	±	~(m * n) = ~m * n
	±	m - n = m + ~n
	±	~(m - n) = ~m + n
	±	~(îú 0) = îú 0®),
	rewrite_tac[ú_minus_thm, ú_times_minus_thm, get_spec¬$-‰Z®]);
=TEX
=SML
val Ûminus1_convİ = REPEAT_C1 (simple_eq_match_conv minus1_thm);
val Ûminus23456_convsİ = map simple_eq_match_conv (current_ad_rw_canon()minus23456_thm);
val Ûminus_simp_convİ = minus1_conv AND_OR_C FIRST_C minus23456_convs;
=TEX
We need the following theorem:
=SML
val Ûú_left_times_plus_distrib_thmİ =
	all_µ_intro(±_left_elim(all_µ_elim ú_times_plus_distrib_thm));
=TEX
Now we can define the external interfaces:
=SML
local
val  Ûú_ANF_C_AUXİ : CONV -> CONV = (
	poly_conv
	ú_term_order
	ú_plus_comm_thm
	ú_plus_assoc_thm
	ú_times_comm_thm
	ú_times_assoc_thm
	ú_left_times_plus_distrib_thm
	(add_simp_conv)
	(times_simp_conv)
);
in
fun  Ûú_ANF_Cİ (conv : CONV) : CONV = (fn tm =>
	(ú_ANF_C_AUX (conv ORELSE_C minus_simp_conv) tm)
	handle Fail _ => term_fail "ú_ANF_C" 105032 [tm]
);
val Ûú_anf_convİ : CONV = (fn tm =>
	(ú_ANF_C fail_conv tm)
		handle ex => (
			if area_of ex = "ú_ANF_C"
			then reraise ex "ú_anf_conv"
			else raise ex
	)
);
end;
=TEX
\section{LINEAR ARITHMETIC DECISION PROCEDURE}
The material in this section implements the linear
arithmetic decision procedure for integers and is modelled  on the
treatment for the natural numbers given in \cite{DS/FMU/IED/DTD082}.
\subsection{Preliminaries}
=IGN
open LinearArithmeticTools;
=TEX
We need lots of theorems:
=SML
val Ûú_³_eq_thmİ = tac_proof(([], ¬µm n : ú·³m = n ¤ m < n ² n < m®),
		REPEAT µ_tac THEN rewrite_tac[taut_rule¬µa b·(³a¤b)¤(a¤³b)®]
		THEN REPEAT strip_tac THEN_LIST
	[asm_rewrite_tac[],
	asm_rewrite_tac[],
	strip_asm_tac(list_µ_elim[¬m:ú®, ¬n:ú®]ú_less_cases_thm)
	THEN all_fc_tac [ú_¼_antisym_thm]]);
val Ûadd_eq_eq_thmİ = tac_proof(([],
	¬µm n i j:ú·m = n ± i = j ´ m + i = n + j®),
	REPEAT strip_tac THEN asm_rewrite_tac[]);
val Ûadd_eq_¼_thmİ = tac_proof(([],
	¬µm n i j:ú·m = n ± i ¼ j ´ m + i ¼ n + j®),
	REPEAT strip_tac THEN asm_rewrite_tac[]);
=TEX
=SML
val Ûadd_¼_¼_thmİ = tac_proof(
	([], ¬µm n i j:ú·m ¼ n ± i ¼ j ´ m + i ¼ n + j®),
	REPEAT µ_tac THEN STRIP_T (strip_asm_tac o pure_rewrite_rule[ú_¼_def])
THEN	all_var_elim_asm_tac1
THEN	rewrite_tac[µ_elim¬i:ú® ú_plus_order_thm, ú_plus_assoc_thm,
		conv_rule (ONCE_MAP_C eq_sym_conv) îú_plus_homomorphism_thm,
		îú_¼_thm]);
=TEX
=SML
val Ûminus_in_thmİ = tac_proof(
	([], ¬µi j:ú·~(i*j) = ~i*j®),
	rewrite_tac[ú_times_minus_thm]);
=TEX
=SML
val Ûscale_eq_thmİ  = tac_proof(
	([], ¬µk:ú; i j:ú·i = j ´ k * i = k * j®),
	REPEAT strip_tac THEN asm_rewrite_tac[]);
val Ûpos_scale_¼_thmİ = tac_proof(
	([], ¬µm:î; i j:ú·i ¼ j ´ îú m * i ¼ îú m * j®),
	rewrite_tac[ú_¼_def] THEN REPEAT strip_tac
	THEN ¶_tac¬m:î * m'® THEN all_var_elim_asm_tac1
	THEN rewrite_tac[ú_times_plus_distrib_thm, îú_times_homomorphism_thm]);
=TEX
=SML
fun Ûsum2_rule_auxİ (th1 : THM) (th2: THM) : THM = (
	let	val rator1 = (fst o dest_const o fst o strip_app o concl) th1;
		val rator2 = (fst o dest_const o fst o strip_app o concl) th2;
		val (add_th, conj_th) = (
			case (rator1, rator2) of
				("=", "=") => (add_eq_eq_thm, ±_intro th1 th2)
			|	("=", "¼‰Z") => (add_eq_¼_thm, ±_intro th1 th2)
			|	("¼‰Z", "¼‰Z") => (add_¼_¼_thm, ±_intro th1 th2)
			|	("¼‰Z", "=") => (add_eq_¼_thm, ±_intro th2 th1)
			|	_ => thm_fail "sum2_rule" 999 [th1, th2]
		);
	in	(conv_rule (RAND_C ú_plus_conv) o ´_match_mp_rule add_th)
		conj_th
	end
	handle Fail _ => thm_fail "sum2_rule" 999 [th1, th2]
(* ?0 and ?1 are not both of the form ô a = b, ô a < b, ô a ¼ b ô a > b or ôa ¾ b *)
);
=IGN
val th1 = asm_rule ¬x + y = îú 5®;
val th2 = asm_rule ¬a + b ¼ îú 12®;
sum2_rule_aux th1 th1;
sum2_rule_aux th1 th2;
sum2_rule_aux th2 th1;
sum2_rule_aux th2 th2;
=TEX
Note: notwithstanding the rather complex coding of the version of these functions
for the natural numbers, Hodes' algorithm as implemented in \cite{DS/FMU/IED/IMP082} produces a polynomial in which the only negative coefficients correspond to equations in the original input.
The following function does not therefore need a case for negating a ¼.
=SML
fun Ûlit_scale_ruleİ (a : INTEGER) (th : THM) : THM = (
	let	val scale_th =  (
			case (fst o dest_const o fst o strip_app o concl) th of
				"¼‰Z" => (
				simple_µ_elim (mk_î a) pos_scale_¼_thm
			) |	_ => (
				simple_µ_elim (mk_ú_signed_int a) scale_eq_thm
			)
		);
	in	(conv_rule (RAND_C ú_times_conv) o ´_match_mp_rule scale_th) th
	end
);
=IGN
lit_scale_rule one th1;
lit_scale_rule (@@"2") th1;
lit_scale_rule (@@"~3") th1;
lit_scale_rule (@@"2") th2;
=TEX
=SML
fun Ûscale_and_sum2_ruleİ (a1 : INTEGER) (th1 : THM) (th2: THM) : THM = (
	sum2_rule_aux (lit_scale_rule a1 th1) th2
);
=TEX
=SML
fun Ûscaled_sum_ruleİ (aths : (INTEGER * THM) list) : THM = (
	let 	fun r aths = (
			case aths of
				[] => fail "sum2_rule" 9089 []
			|	[(a, th)] =>
					lit_scale_rule a th
			|	(a, th) :: more =>
					scale_and_sum2_rule a th (r more)
		);
	in	conv_rule (TRY_C (LEFT_C ú_anf_conv)
			THEN_C TRY_C (ú_¼_conv ORELSE_C ú_eq_conv)) (r aths)
	end
);
=IGN
val th3 = asm_rule ¬(x + îú 1) * (x - îú 1) = îú 20®;
val th4 = asm_rule ¬(x + îú 1) * ~(x - îú 1) = îú 20®;
scaled_sum_rule [(@@"42", th1)];
scaled_sum_rule [(@@"42", th2)];
scaled_sum_rule [(@@"42", th1), (@@"9", th2), (@@"5", th3)];
scaled_sum_rule [(@@"6", th3), (@@"6", th4)];
scaled_sum_rule [(@@"6", th3), (@@"~6", th4)];
scaled_sum_rule [(@@"1", th3)];
scaled_sum_rule [(@@"~1", th3)];
=TEX
\subsection{The Linear Arithmetic Rule}
=TEX
We use the following type to represent a scaled sum of linear arithmetic
atoms:
=SML
open LinearArithmeticTools;
type ÛSCALED_SUMİ = (INTEGER * TERM) list;
=TEX
=SML
fun Ûstrip_ú_plusİ (tm : TERM) : TERM list = (
	((op :: o (Combinators.I ** strip_ú_plus) o dest_ú_plus) tm)
	handle Fail _ => [tm]
);
=IGN
strip_ú_plus¬x:ú®;
strip_ú_plus¬x:ú + y + îú 42 * v + q®;
=TEX
Note that the following is intended to operate on a term which is either
in additive normal form.
=SML
val Ûminus_oneİ = @~one;
fun Ûdest_summandİ (tm : TERM) : INTEGER * TERM = (
	let val nt = ((dest_ú_signed_int ** Combinators.I) o dest_ú_times) tm;
	in	if (fst nt) = one
		then (one, tm)
		else nt
	end	handle Fail _ => (
			let 	val (x, y) = (dest_ú_times tm);
				val x' = dest_ú_minus x;
			in	(minus_one, mk_ú_times(x', y))
			end
		)
		handle Fail _ => (minus_one, dest_ú_minus tm)
		handle Fail _ => (one, tm)
);
=IGN
(string_of_integer ** Combinators.I o dest_summand)¬~(x:ú)®;
(string_of_integer ** Combinators.I o dest_summand)¬îú 42 * v®;
(string_of_integer ** Combinators.I o dest_summand)¬~(îú 42) * v®;
(string_of_integer ** Combinators.I o dest_summand)¬~(îú 42) * v®;
(string_of_integer ** Combinators.I o dest_summand)¬~(x:ú) * v®;
=TEX
=SML
val Ûdest_sumİ : TERM -> SCALED_SUM = map dest_summand o strip_ú_plus;
=TEX
=SML
val Ûmk_ú0İ = ¬îú 0®;
fun Ûmk_sumİ ([] : SCALED_SUM) = mk_ú0
|   mk_sum [(i, t)] = (
	if i = one
	then t
	else if i = minus_one
	then mk_ú_minus t
	else mk_ú_times(mk_ú_signed_int i, t)
) | mk_sum ((i, t) :: more) = (
	if i = one
	then mk_ú_plus(t, mk_sum more)
	else if i = minus_one
	then mk_ú_plus(mk_ú_minus t, mk_sum more)
	else mk_ú_plus(mk_ú_times(mk_ú_signed_int i, t), mk_sum more)
);
=IGN
mk_sum(dest_sum¬îú 42 * v + a * b + c + ~(îú 5) * d®);
=TEX
=TEX
We use the following type to represent a constraint (with HOL terms rather
than variables as its atoms):
=SML
type ÛTERM_CONSTRAINTİ = SCALED_SUM * TERM * INTEGER;
=TEX
The next function extracts a term constraint from an equation
or a ¼.
=SML
val ú = ”ú®;
fun Ûdest_constraintİ (tm : TERM) : TERM_CONSTRAINT OPT = (
	let	val ((rel, l), r) =
			((dest_app ** Combinators.I) o dest_app)tm;
	in	case fst(dest_const rel) of
			"=" => (
				if type_of l =: ú
				then Value (dest_sum l, rel, dest_ú_signed_int r)
				else Nil
		) |	"¼‰Z" => (Value (dest_sum l, rel, dest_ú_signed_int r)
		) |	_ => Nil
	end	handle Fail _ => Nil
);
=IGN
dest_constraint¬a + îú 7 * b + ~(îú 5) * c = îú 9®;
dest_constraint¬~a = îú 9®;
=TEX
Given a term constraint, the following function assigns variables numbers
for $lin\_arith\_contr$ to the atoms:
=SML
fun Ûatom_mapİ
	(x : TERM_CONSTRAINT list)
	: (int * TERM) list = (
	let	fun aux1 acc [] = acc
		|   aux1 acc ((i, t) :: more) = (
			aux1 (acc term_grab t) more
		);
		fun aux2 acc [] = acc
		|   aux2 acc ((s1, _, _) :: more) = (
			aux2 (aux1 acc s1) more
		);
		val tms = aux2 [] x;
	in	combine (interval 1 (length tms)) tms
	end
);
=IGN
atom_map [force_value (dest_constraint
		¬a + îú 7 * b + ~(îú 5) * c * d = îú 9®),
	force_value (dest_constraint
		¬a*b + îú 7 * b + ~(îú 5) * c * d = îú 9®)];
=TEX
=SML
fun Ûterm_rassocİ
	((i, t) :: more : ('a * TERM) list)
	(tm : TERM) : 'a = (
	if t ~=$ tm then i else term_rassoc more tm
) | Ûterm_rassocİ [] _ = (
	fail "term_rassoc" 9090 []
);
=TEX
=SML
fun Ûterm_lassocİ
	((t, i) :: more : (TERM * 'a) list)
	(tm : TERM) : 'a = (
	if t ~=$ tm then i else term_lassoc more tm
) | Ûterm_lassocİ [] _ = (
	fail "term_lassoc" 9090 []
);
=TEX
Given the mapping of variable numbers to HOL terms and
a scaled sum, the following
function computes the corresponding polynomial for $lin\_arith\_contr$
=SML
fun Ûmake_polyİ (inds : (int * TERM) list) (ss : SCALED_SUM) : POLY = (
	let	fun collect p ((i, tm) :: more) = (
			collect ((i, term_rassoc inds tm) :: p) more
		) | collect acc [] = acc;
	in	normalise_poly (collect [] ss)
	end
);
=TEX
The following function makes a constraint for $lin\_arith\_contr$,
given the mapping of variable numbers to HOL terms and
a term constraint:
=SML
fun Ûmake_constraintİ (inds : (int * TERM) list)
		((ind, (l, rel, r)) : int * TERM_CONSTRAINT)
		: CONSTRAINT = (
	let	val rator = (
			case fst(dest_const rel) of
				"=" => Eq
			|	"¼‰Z" => LessEq
			|	_ => error "make_constraint" 9090 []
(* Unexpected error *)
		);
	in	(make_poly inds l, rator,  r, [(one, ind)])
	end
);
=TEX
Given a list of terms, the following function extracts all the information
needed by $lin\_arith\_contr$ and subsequently to process its output.
Note we generate variable names for each of the linear arithmetic atoms
to speed up proof of the theorem after a successful call of $lin\_arith\_contr$.
=SML
fun Ûmake_problemİ (tml : TERM list) :
		((int * TERM) * TERM) list
	*	((	CONSTRAINT
		*	(int * TERM_CONSTRAINT)) list) = (
	let	fun aux1 [] = []
		|   aux1 (Nil :: more) = aux1 more
		|   aux1 (Value v :: more) = v :: aux1 more;
		val stsl = aux1(map dest_constraint tml);
		val inds = atom_map stsl;
		val istsl = combine (interval 1 (length stsl)) stsl;
		val ctl = map (make_constraint inds) istsl;
	in	(map(fn (i, t)=> ((i, mk_var("@_"^string_of_int i, ú)), t)) inds,
			combine ctl istsl)
	end
);
=TEX
Given the relevant information about variable numbers and generated
variable names and a scaled sum the following function computes the
corresponding term:
=SML
fun Ûmake_var_sumİ (ivtl : ((int * TERM) * TERM) list) (ss : SCALED_SUM) : TERM = (
	let	fun name t = (
			snd(term_rassoc ivtl t)
		);
		fun aux1 (i, t) = (
			if i = one
			then name t
			else if i = minus_one
			then mk_ú_minus (name t)
			else mk_ú_times(mk_ú_signed_int i, name t)
		);
		fun aux2 [] = mk_ú_signed_int zero
		|   aux2 [s] = aux1 s
		|   aux2 (s :: more) = mk_ú_plus(aux1 s, aux2 more);
	in	aux2 ss
	end
);
=TEX
We are now concerned with
proving the theorem corresponding to one of the constraints passed
as input to $lin\_arith\_contr$.
=SML
fun Ûmake_var_thmİ
	(ivtl : ((int * TERM) * TERM) list)
	((l, rel, r) : TERM_CONSTRAINT) : THM = (
	asm_rule(mk_app(mk_app(rel, make_var_sum ivtl l),
			mk_ú_signed_int r))
);
=TEX
The following function uses the results of $lin\_arith\_contr$ and
the substitution implicit in the results of $make\_problem$ to prove
the actual theorem that the assumptions entail $F$.
We have to patch up things of the form
=INLINEFT
~(x*y)
=TEX
the code below attempts to do this with reasonable efficiency and
simplicity, although more work and longer code would enable it to be done even faster.
=SML
fun Ûmake_actual_thmİ
	(ivtl : ((int * TERM) * TERM) list)
	(p : POLY)
	(ts : (int * TERM_CONSTRAINT) list)
	: THM = (
	let	fun aux (i, t) = (i, make_var_thm ivtl (lassoc3 ts t));
		val subs = map (fn ((_, v), t) => (t, v)) ivtl;
		val thm = asm_inst_term_rule subs (scaled_sum_rule (map aux p));
		val conv = (fn tm =>
			if	type_of tm =: ú
				andalso not (is_ú_plus tm)
			then	TRY_C (simple_eq_match_conv minus_in_thm) tm
			else	fail_conv tm
		);
		fun rule th = rule (undisch_rule th) handle Fail _ => th;
	in	(rule (conv_rule (ONCE_MAP_C conv) 	(all_´_intro thm)))
		handle Fail _ => thm
	end
);

=TEX
=SML
fun Ûdiagnoseİ
	(who : string)
	(tml : TERM list)
	(ivtl : ((int * TERM) * TERM) list)
	(cts : CONSTRAINT list) : 'a = (
	let	fun format_ivt ((i,_), tm) = (
			"X" ^ string_of_int i ^ " = " ^ string_of_term tm
		);
		fun diag () = (
			diag_string(get_error_message 82100 []);
			(map diag_line o flat)
			(map (PrettyPrinter.format_term true) tml);
			case ivtl of [] => () | _ => (
				diag_string(get_error_message 82101 []);
				(app (diag_string o format_ivt) ivtl)
			);
			diag_string(get_error_message 82102 []);
			map (diag_string o format_constraint) cts;
				""
		);
	in	if	is_nil tml
		then	fail who 82111 []
		else	if is_nil cts
		then	fail who 105112 []
		else 	fail who 82110 [diag]
	end
);
fun Ûú_lin_arith_rule_auxİ (who : string) (tml : TERM list) : THM = (
	let	val (ivtl, ctetcl) = make_problem tml;
		val cts = (map fst ctetcl);
		val p =	(lin_arith_contr cts)
			handle Fail _ => diagnose who tml ivtl cts;
	in	make_actual_thm ivtl p (map snd ctetcl)
	end
);
=TEX
=SML
val Ûú_lin_arith_ruleİ : TERM list -> THM = ú_lin_arith_rule_aux "ú_lin_arith_rule";
=IGN
ú_lin_arith_rule [
	¬a + b = îú 0®
];
val tml = [
	¬a + b = îú 0®,
	¬a = îú 1®,
	¬b = îú 1®
];
ú_lin_arith_rule[
	¬a + b = îú 0®,
	¬a = îú 1®,
	¬b = îú 1®
];
ú_lin_arith_rule [
	¬a + b ¼ îú 0®,
	¬~a ¼ ~(îú 1)®,
	¬~b ¼ ~(îú 1)®
];
val th20 = ú_lin_arith_rule [
	¬a*a + b = îú 0®,
	¬~a*a ¼ ~(îú 1)®,
	¬~b ¼ ~(îú 1)®
];
val th20 = ú_lin_arith_rule [
	¬a*a + b = îú 1®,
	¬~a*a ¼ ~(îú 98765443210)®,
	¬~b ¼ ~(îú 1)®
];
=TEX
=SML
val Ûú_lin_arith_tacİ : TACTIC = (fn gl =>
	(GET_ASMS_T (f_thm_tac o ú_lin_arith_rule o map concl) gl)
	handle ex => reraise ex "ú_lin_arith_tac"
);
=TEX
Now the tactic which is the automatic proof tactic
=SML
val Ûú_lin_arith_prove_tacİ : THM list -> TACTIC = (fn thl => fn gl =>
	((	DROP_ASMS_T (MAP_EVERY strip_asm_tac)
	THEN	MAP_EVERY  strip_asm_tac thl
	THEN	contr_tac
	THEN	ú_lin_arith_tac) gl)
	handle	Fail msg => fail "ú_lin_arith_prove_tac" 82200
			[(fn () =>get_message msg),
			 (fn () => string_of_term (snd gl))]
);
=TEX
and the associated conversion:
=SML
val Ûú_lin_arith_prove_convİ : THM list -> CONV = (fn thl => fn tm =>
	let	val th = tac_proof(([], tm), ú_lin_arith_prove_tac thl);
	in	¤_t_intro  th
	end	handle ex => reraise ex "ú_lin_arith_prove_conv"
);
=TEX
\section{OTHER RULES}
=TEX
=SML
val Ûú_eqİ = ¬$=:ú­ú­BOOL®;
val ú_cancel_conv_thm1 = ú_eq_thm;
val ú_cancel_conv_thm2 = tac_proof(
	([], ¬µm : î; j k:ú·îú m + j = k ¤ j = k + ~ (îú m)®),
	REPEAT strip_tac THEN all_var_elim_asm_tac1 THEN
	rewrite_tac[µ_elim¬k:ú®ú_plus_order_thm, µ_elim¬j:ú®ú_plus_order_thm]);
val ú_cancel_conv_thm3 = tac_proof(
	([], ¬µm:î; j k:ú·~(îú m) + j = k ¤ j = k + îú m®),
	REPEAT strip_tac THEN all_var_elim_asm_tac1 THEN
	rewrite_tac[µ_elim¬k:ú®ú_plus_order_thm, µ_elim¬j:ú®ú_plus_order_thm]);
=TEX
=SML
val Ûú_¼İ = ¬$¼:ú­ú­BOOL®;
val ú_¼_cancel_conv_thm1 = ú_¼_¼_0_thm;
val ú_¼_cancel_conv_thm2 = tac_proof(
	([], ¬µm : î; j k:ú·îú m + j ¼ k ¤ j ¼ k + ~ (îú m)®),
	once_rewrite_tac[ú_¼_¼_0_thm]
	THEN rewrite_tac[µ_elim¬~k:ú® ú_plus_order_thm]
	THEN rewrite_tac[µ_elim¬j:ú® ú_plus_order_thm]);
val ú_¼_cancel_conv_thm3 = tac_proof(
	([], ¬µm:î; j k:ú·~(îú m) + j ¼ k ¤ j ¼ k + îú m®),
	once_rewrite_tac[ú_¼_¼_0_thm]
	THEN rewrite_tac[µ_elim¬~k:ú® ú_plus_order_thm]
	THEN rewrite_tac[µ_elim¬j:ú® ú_plus_order_thm]);
=TEX
=SML
fun Ûgen_cancel_convİ (r : TERM) (conv_thm1 : THM) (conv_thm2 : THM) (conv_thm3: THM)
	: CONV = (fn tm =>
	let	val (rela, b) = dest_app tm;
		val (rel, a) = dest_app rela;
	in 	if rel =$ r
		then
	let	val thm1 = (
			if	is_ú_signed_int b
			then	Nil
			else	Value (list_µ_elim[a, b] conv_thm1)
		);
		val arb1 =
			case thm1 of
				Value thm => snd(dest_app(concl thm))
			|	Nil => tm;
		val thm2 = Value (RATOR_C (RAND_C ú_anf_conv) arb1)
				handle Fail _ => Nil;
		val arb2 =
			case thm2 of
				Value th => snd(dest_eq (concl th))
		|	_ => arb1;
		val (_, a2) = dest_app (fst(dest_app arb2));
		val thm3 = (
			let	val c = dest_ú_signed_int(fst (dest_ú_plus a2));
			in	Value
				(if	c @>= zero
				then	(simple_eq_match_conv conv_thm2
					THEN_C RIGHT_C ú_plus_conv) arb2
				else	(simple_eq_match_conv conv_thm3
					THEN_C RIGHT_C ú_plus_conv) arb2)
			end	handle Fail _ => Nil
		);
		fun chain (Value th1) (Value th2)= Value(eq_trans_rule th1 th2)
		|   chain (Value th1) Nil = Value th1
		|   chain Nil (Value th2) = Value th2
		|   chain Nil Nil = Nil;
	in	case chain thm1 (chain thm2 thm3)of
			Value th => th
		|	Nil => fail_conv tm
	end	else	fail_conv tm
	end
);
=TEX
=SML
val Ûú_eq_cancel_convİ : CONV = (fn tm =>
	(gen_cancel_conv
		ú_eq ú_cancel_conv_thm1 ú_cancel_conv_thm2
			ú_cancel_conv_thm3 tm)
	handle Fail _ => term_fail "ú_eq_cancel_conv" 105120 [tm]
);
=TEX
=SML
val Ûú_¼_cancel_convİ : CONV = (fn tm =>
	(gen_cancel_conv
		ú_¼ ú_¼_cancel_conv_thm1 ú_¼_cancel_conv_thm2
			ú_¼_cancel_conv_thm3 tm)
	handle Fail _ => term_fail "ú_eq_cancel_conv" 105121 [tm]
);
=IGN
ú_eq_cancel_conv¬a + b + îú 4 = îú 9 + y®;
ú_eq_cancel_conv¬a + b + îú 20 = îú 9 + y®;
ú_eq_cancel_conv¬b + a = îú 9 + y®;
ú_eq_cancel_conv¬b + a = îú 9®;
ú_eq_cancel_conv¬a + b = îú 9®   (* should fail *);
ú_eq_cancel_conv¬îú 0 = îú 9®   (* should fail *);
ú_eq_cancel_conv¬T = F®   (* should fail *);
ú_eq_cancel_conv¬T ² F®   (* should fail *);
ú_¼_cancel_conv¬a + b + îú 4 ¼ îú 9 + y®;
ú_¼_cancel_conv¬a + b + îú 20 ¼ îú 9 + y®;
ú_¼_cancel_conv¬b + a ¼ îú 9 + y®;
ú_¼_cancel_conv¬b + a ¼ îú 9®;
ú_¼_cancel_conv¬a + b ¼ îú 9®   (* should fail *);
ú_¼_cancel_conv¬îú 0 ¼ îú 9®   (* should fail *);
ú_¼_cancel_conv¬T = F®   (* should fail *);
ú_¼_cancel_conv¬T ² F®   (* should fail *);
=TEX
\section{THE PROOF CONTEXTS}
The equational contexts required are the same for stripping goals and stripping
theorems. We take numeric $=$ and $¼$ as the atomic
predicates which we will deal with. The possibilities are:
{\em(i)} put the a ground atomic predicate into normal form with the appropriate canncellation conversion;
{\em(ii)} convert a negated atomic predicate into an atomic one;
{\em(iii)} convert a predicate formed with $<$, $¾$ or $>$ into an atomic one;
{\em(iv)} convert the negation of a predicate formed with $<$, $¾$ or $>$ into an atomic one;
and
{\em(v)} attempt to evaluate ground inequalities.
=TEX
The following is a little bit more leisurely than the natural numbers versions;
it does the conversion into atomic predicates in easy stages.
=SML
val strip_cxt = [

	(¬(x:ú) = y®, ú_eq_conv),
	(¬(x:ú) ¼ y®, ú_¼_conv),

	(¬³(x:ú) = y®, simple_eq_match_conv ú_³_eq_thm),
	(¬³(x:ú) ¼ y®, simple_eq_match_conv ú_³_¼_thm),

	(¬(x:ú) < y®, simple_eq_match_conv ú_less_def),
	(¬(x:ú) ¾ y®, simple_eq_match_conv ú_¾_def),
	(¬(x:ú) > y®, simple_eq_match_conv ú_greater_def),

	(¬³ (x:ú) < y®, simple_eq_match_conv ú_³_less_thm),
	(¬³ (x:ú) ¾ y®, RAND_C(simple_eq_match_conv ú_¾_def)),
	(¬³ (x:ú) > y®, RAND_C(simple_eq_match_conv ú_greater_def)),


	(¬(x:ú) = y®, ú_eq_cancel_conv),
	(¬(x:ú) ¼ y®, ú_¼_cancel_conv)];
=IGN
map (fn (t, c) => TRY_C c t) strip_cxt;
=TEX
=SML
val _ = delete_pc "'ú_lin_arith" handle Fail _ => ();
val _ = new_pc Û"'ú_lin_arith"İ;
val _ = set_rw_eqn_cxt strip_cxt "'ú_lin_arith";
val _ = set_st_eqn_cxt strip_cxt "'ú_lin_arith";
val _ = set_sc_eqn_cxt strip_cxt "'ú_lin_arith";
val _ = set_pr_tac ú_lin_arith_prove_tac "'ú_lin_arith";
val _ = set_pr_conv ú_lin_arith_prove_conv "'ú_lin_arith";
val _ = commit_pc "'ú_lin_arith";
=TEX
=SML
val _ = delete_pc "ú_lin_arith" handle Fail _ => ();
val _ = new_pc Û"ú_lin_arith"İ;
val _ = merge_pcs ["predicates","'ú_lin_arith"] "ú_lin_arith";
val _ = commit_pc "ú_lin_arith";
=TEX
=IGN
map (PC_C1 "ú_lin_arith" rewrite_conv[]) [
	¬îú 1 = îú 2®, ¬îú 3 ¼ îú 2®, ¬îú 2 = îú 2®, ¬îú 1 ¼ îú 2®
,	¬a + b = b + a + îú 1®, ¬a + îú 20 + b = (a+ îú 10)+(b+ îú 10)®
,	¬a + b ¼ b + a - îú 1®, ¬a + îú 20 + b ¼ (a+ îú 14)+(b+ îú 10)®
,	¬³îú 10 = îú 20®, ¬³(a:ú) + b = b + a®
,	¬³îú 10 ¼ îú 20®, ¬³(a:ú) + b ¼ b + a®
,	¬îú 10 < îú 20®, ¬(a:ú) + b ¾ b + a®, ¬(a:ú) + b > b + a®
,	¬³îú 10 < îú 20®, ¬³(a:ú) + b ¾ b + a®, ¬³(a:ú) + b > b + a®
,	¬(a:ú +b)*(a-b) = a*a - b*b®, ¬(a:ú +b)*(a-b) = a*a - b*b ®
];
map (PC_C1 "ú_lin_arith" prove_rule[]) [
	¬a*a ¾ îú 0 ± b*b ¾ îú 0 ´ (a+b)*(a+b) ¾ îú 2 * a * b®
];
map (PC_C1 "ú_lin_arith" rewrite_conv[]) [
	¬a*a ¾ îú 0 ± b*b ¾ îú 0 ´ (a+b)*(a+b) ¾ îú 2 * a * b®
];
=SML
val _ = pop_pc();
end (* of structure úArithmeticTools *);
open úArithmeticTools;
=TEX
\section{MORE THEOREMS THE THEORY OF INTEGERS}
This section contains theorems required in DTD093 which are more conveniently proved using the tools introduced here.
=SML
structure Ûúİ : ú = struct;
=TEX
=SML
open ú;
val _ =  push_merge_pcs["basic_hol1", "'ú"];
=TEX
=SML
val Ûú_fun_¶_thmİ = (
set_goal([], ¬µf g : 'a ­ 'a; z: 'a·
	(µx· g(f x) = x)
±	(µy· f(g y) = y)
´	¶‰1h : ú ­ 'a·
	h(îú 0) = z
±	(µi·h(i + îú 1) = f(h i))
±	(µi·h(i - îú 1) = g(h i))
®);
a(lemma_tac¬
	(¶p·µm·p(îú m) = m)
±	(¶n·µm·n(~(îú m)) = m)®
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(¶_tac¬Ìi·(Å n·i = îú n)® THEN rewrite_tac[] THEN REPEAT strip_tac);
a(Å_tac¬Å n· îú m = îú n® THEN prove_tac[]);
a(POP_ASM_T ante_tac THEN rewrite_tac[îú_one_one_thm]);
a(STRIP_T (fn th => conv_tac(RIGHT_C (once_rewrite_conv[th]))) THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(¶_tac¬Ìi·(Å n·i = ~(îú n))® THEN rewrite_tac[] THEN REPEAT strip_tac);
a(Å_tac¬Å n· ~(îú m) = ~(îú n)® THEN prove_tac[]);
a(POP_ASM_T ante_tac THEN rewrite_tac[
	pc_rule1"ú_lin_arith" prove_rule[] ¬µa b:ú·~a = ~b ¤ a = b®,
	îú_one_one_thm]);
a(STRIP_T (fn th => conv_tac(RIGHT_C (once_rewrite_conv[th]))) THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(lemma_tac¬
	(¶hp· hp 0 = z ± µm·hp (m+1) = f(hp m))
±	(¶hn· hn 0 = z ± µm·hn (m+1) = g(hn m))
® THEN1 (REPEAT strip_tac THEN prove_¶_tac));
a(¶‰1_tac¬Ìi·if îú 0 ¼ i then hp(p i) else hn(n i)® THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(cases_tac¬îú 0 ¼ i®);
(* *** Goal "3.1.1" *** *)
a(all_fc_tac[ú__î_thm] THEN all_var_elim_asm_tac1);
a(lemma_tac¬îú 0 ¼ îú m + îú 1® THEN1 PC_T1 "ú_lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[] THEN asm_rewrite_tac[îú_plus_homomorphism_thm1]);
(* *** Goal "3.1.2" *** *)
a(lemma_tac¬îú 0 ¼ ~i® THEN1 PC_T1 "ú_lin_arith" asm_prove_tac[]);
a(all_fc_tac[ú__î_thm] THEN all_var_elim_asm_tac1);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[
	pc_rule1 "ú_lin_arith" prove_rule[]¬~i  = îú m ¤ i = ~(îú m)®])
	THEN all_var_elim_asm_tac1);
a(POP_ASM_T discard_tac);
a(LEMMA_T ¬³îú 0 ¼ ~(îú m)® rewrite_thm_tac THEN1 PC_T1 "ú_lin_arith" asm_prove_tac[]);
a(cases_tac¬îú m = îú 0® THEN1 asm_rewrite_tac[]);
(* *** Goal "3.1.2.1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[îú_one_one_thm]) THEN all_var_elim_asm_tac1);
(* *** Goal "3.1.2.2" *** *)
a(cases_tac¬îú m = îú 1® THEN1 asm_rewrite_tac[]);
(* *** Goal "3.1.2.2.1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[îú_one_one_thm]) THEN all_var_elim_asm_tac1);
a(SPEC_NTH_ASM_T 1¬0® ante_tac THEN rewrite_tac[] THEN STRIP_T asm_rewrite_thm_tac);
(* *** Goal "3.1.2.2.2" *** *)
a(LEMMA_T¬³îú 0 ¼ ~ (îú m) + îú 1®rewrite_thm_tac THEN1
	PC_T1 "ú_lin_arith" asm_prove_tac[]);
a(asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[îú_one_one_thm]));
a(strip_asm_tac (µ_elim¬m® î_cases_thm));
a(DROP_NTH_ASM_T 2 discard_tac THEN all_var_elim_asm_tac1);
a(asm_rewrite_tac[îú_plus_homomorphism_thm]);
a(conv_tac (ONCE_MAP_C ú_anf_conv) THEN asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(cases_tac¬îú 0 ¼ i®);
(* *** Goal "3.2.1" *** *)
a(all_fc_tac[ú__î_thm] THEN all_var_elim_asm_tac1);
a(cases_tac¬ îú m = îú 0® THEN asm_rewrite_tac[]);
(* *** Goal "3.2.1.1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[îú_one_one_thm]) THEN all_var_elim_asm_tac1);
a(SPEC_NTH_ASM_T 1 ¬0® ante_tac THEN rewrite_tac[] THEN STRIP_T asm_rewrite_thm_tac);
(* *** Goal "3.2.1.2" *** *)
a(cases_tac¬ îú m = îú 1® THEN1 asm_rewrite_tac[]);
(* *** Goal "3.2.1.2.1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[îú_one_one_thm]) THEN all_var_elim_asm_tac1);
a(SPEC_NTH_ASM_T 3 ¬0® ante_tac THEN rewrite_tac[] THEN STRIP_T asm_rewrite_thm_tac);
(* *** Goal "3.2.1.2.2" *** *)
a(LEMMA_T¬îú 0 ¼ îú m + ~(îú 1)®rewrite_thm_tac THEN1
	PC_T1 "ú_lin_arith" asm_prove_tac[]);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[îú_one_one_thm]));
a(strip_asm_tac (µ_elim¬m® î_cases_thm));
a(DROP_NTH_ASM_T 2 discard_tac THEN all_var_elim_asm_tac1);
a(asm_rewrite_tac[îú_plus_homomorphism_thm]);
a(conv_tac (ONCE_MAP_C ú_anf_conv) THEN asm_rewrite_tac[]);
(* *** Goal "3.2.2" *** *)
a(LEMMA_T¬³îú 0 ¼ i + ~(îú 1) ± ³îú 0 ¼ i®rewrite_thm_tac THEN1
	PC_T1 "ú_lin_arith" asm_prove_tac[]);
a(lemma_tac¬îú 0 ¼ ~i® THEN1 PC_T1 "ú_lin_arith" asm_prove_tac[]);
a(all_fc_tac[ú__î_thm]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[
	pc_rule1 "ú_lin_arith" prove_rule[]¬~i  = îú m ¤ i = ~(îú m)®])
	THEN all_var_elim_asm_tac1);
a(POP_ASM_T discard_tac);
a(pure_asm_rewrite_tac[
	pc_rule1 "ú_lin_arith" prove_rule[]¬µa b:ú·~a + ~b = ~(a+b)®,
	îú_plus_homomorphism_thm1]);
a(REPEAT strip_tac);
(* *** Goal "3.3" *** *)
a(strip_asm_tac (µ_elim ¬x® ú_cases_thm)
	THEN all_var_elim_asm_tac1);
(* *** Goal "3.3.1" *** *)
a(rewrite_tac[îú_¼_thm]);
a(induction_tac¬m® THEN
	asm_rewrite_tac[îú_plus_homomorphism_thm]);
(* *** Goal "3.3.2" *** *)
a(cases_tac¬m = 0® THEN1
	asm_rewrite_tac[]);
a(asm_rewrite_tac[pc_rule1"ú_lin_arith"
	prove_rule[]
	¬µb:ú· îú 0 ¼ ~b ¤ b ¼ îú 0®,
	îú_¼_thm]);
a(POP_ASM_T discard_tac THEN
	induction_tac¬m® THEN asm_rewrite_tac[îú_plus_homomorphism_thm]);
save_pop_thm "ú_fun_¶_thm"
);
=TEX
=SML
val _ = pop_pc();
=TEX
=SML
end (* of structure ú *)
open ú;


=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

