=IGN
********************************************************************************
imp105.doc: this file is part of the ProofPower system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\def\TPPheadtitle{Integer Arithmetic}
\TPPtitle{Implementation of Arithmetic Proof Procedures for HOL Integers}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP105}  %% Mandatory field
\def\SCCSversion{$Revision: 1.8 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2002/10/16 16:17:10 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D.~Arthan & WIN01}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the implementation of proof
procedures the HOL integers.
These include arithmetic normalisation and a linear arithmetic prover.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item[1.1-1.3] First drafts.
\item[1.4] First product version.
\item[1.5] Update for new INTEGER type.
\item[1.6] Removed premature end of document.
\item[1.7] Fixed bug in {\it add\_simp\_conv}.
\item[1.8] Fixed {\LaTeX} errors.
\item[Issue 1.9] Copyright and banner updates for open source release.
\end{description}
\subsection{Changes forecast}
As determined by comment and review.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of part of the \ProductHOL\ system.
The document responds to \cite{DS/FMU/IED/DTD105}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
\subsubsection{Dependencies}
This document depends on the theory $basic\_hol$ defined in
\cite{DS/FMU/IED/DTD045}, on the conversions in
\cite{DS/FMU/IED/DTD081}, and on the tactics and rules of
\cite{DS/FMU/IED/DTD027,DS/FMU/IED/DTD029}.
\subsubsection{Algorithms}
See the detailed design document \cite{DS/FMU/IED/DTD105} for
a general description of the algorithm and the remarks between code
fragments below for
more detailed discussion of implementation techniques, such as the
representation of the problems.

The arithmetic normaliser is similar to, but more complex  than, that in \cite{DS/FMU/IED/IMP082}.
The linear arithmetic prover is similar to, but simpler than, that in \cite{DS/FMU/IED/IMP082}.
In both cases, the difference in complexity is due to negation, which leads to more cases in normalisation, but a simpler normal form, and hence fewer cases, in the linear arithmetic prover.
\subsubsection{Known Deficiencies}
See \cite{DS/FMU/IED/DTD105}.
\subsubsection{Possible Enhancements}
See \cite{DS/FMU/IED/DTD105}.
\section{PREAMBLE}
=SML
structure ÛúArithmeticToolsÝ : úArithmeticTools = struct
=TEX
\section{PREAMBLE}
=SML
val Ûold_theoryÝ = get_current_theory_name();
val _ = open_theory"ú";
val _ = push_merge_pcs ["'ú", "'î", "predicates"];
=TEX
\section{TERM NORMALISATION}
The material in this section implements the treatment of polynomial
normalisation for the integers and is modelled quite closely on the
treatment for the natural numbers given in \cite{DS/FMU/IED/DTD081}.
\subsection{Discussion}
The normal form we use applies to the set of terms described informally
by the following (ambiguous) BNF grammar, in which, of course, all the operations are the
integer versions:
=GFT
	IntTerm		= IntTerm, "*", IntTerm
			| IntTerm, "-", IntTerm
			| IntTerm, "+", IntTerm
			| "~", IntTerm
			| IntAtom;
	IntAtom		= ? Anything not of the form IntTerm ?;
=TEX
Such a term is normalised by ``multiplying out and collecting like terms'' to
give a normal form described by the following grammar:
=GFT
	NormIntTerm	= Monomial, {"+", Monomial};
	Monomial	= HeadFactor, {"*", TailFactor};
	HeadFactor	= ["~"], (IntLit | TailFactor);
	TailFactor	= IntAtom - IntLit;
=TEX
The above grammar is intended to be interpreted with the usual HOL rules
for precedence and assocation. Thus, the monadic minus in a head factor
has as its argument the rest of the head factor (not including the product of
the tail factors).

All the tail factors in a normalised monomial are ordered with respect to a fixed total ordering of HOL terms as are the monomials within a $NormIntTerm$.
This ordering is defined in the next section.
An $IntLit$ as the head factor of a normalised monomial is never $0$, $1$ or
=INLINEFT
~1
=TEX
\ unless the monomial contains no tail factors.

Like monomials are ``collected'' in the sense that there are no repetitions
amongst the monomials obtainable from a $NormIntTerm$ by deleting any
monadic minuses and $IntLit$s which appear in it.
(I.e. terms like
=INLINEFT
~x + x
=TEX
\ or
=INLINEFT
~x + y + ~2*x
=TEX
\ do not arise).
A $NormIntTerm$ will contain at most one monomial comprising of a single
signed literal. The $IntLit$s in a monomial are never zero unless the
whole $NormIntTerm$ consists of the single literal zero (i.e. ¬îú\,0®).
\section{TERM ORDERING FOR ú}
The ordering must bring together signed literals and like monomials.
We arrange things so that a monomial with a sign comes immediately after the monomial, and with a literal multiplier immediately after that, e.g.:

=GFT
	a*b < ~a * b < 0 * a * b < ~1 * a * b < 1 * a * b < ....
=TEX
.
=SML
local
val ÛbottomÝ : TERM = mk_const("", mk_vartype "");
val Ûmk_0Ý = ¬0®;
val two = @@"2";
fun int_to_nat (i : INTEGER) : INTEGER = (
	if i @>= zero
	then two@*i @+ two
	else (two @* @~i) @+ one
)
fun ÛpervertÝ (tm : TERM) : TERM * INTEGER = (
	let	val (a, b) = dest_ú_times tm
	in	(b, int_to_nat(dest_ú_signed_int a))
		handle Fail _ => (mk_ú_times(dest_ú_minus a, b), one)
		handle Fail _ => (tm, zero)
	end	handle Fail _ => (bottom, int_to_nat(dest_ú_signed_int tm))
		handle Fail _ => (dest_ú_minus tm, one)
		handle Fail _ => (tm, zero)
);
in
val Ûú_term_orderÝ : TERM -> TERM -> int = gen_term_order pervert;
end;

=TEX
\section{ANF FOR ú}
We need conversions and supporting theorems which do collection of
like terms.
First of all we need to provide conversions which, given a (sorted) sum,
=INLINEFT
m‰1 + m‰2
=TEX
\ of two normalised monomials will do all applicable simplifications which can reduce the sum to a single monomial.
We find the following cases, in which $c$d and $d$ denote literals, and where, on the right hand-side of the equations, literal arithmetic expressions are intended to have been evaluated:
=GFT
1.	c*m +d*m 	=	(c + d)*m
2.	m +d*m 		=	(1 + d)*m
3.	0 + m		=	m
4.	c + d		=	c + d
5.	m + m 		=	2*m
6.	m + ~m 		=	0
7.	m*n + ~m*n	=	0
8.	~m + d*m	=	(~1 + d)*m	
9.	~m*n + d*m*n	=	(~1 + d)*m*n
10.	m + 0		=	0
=TEX
Here case 4 is directly supported by $plus\_conv$ (note that the order
here is important since case 4 overlaps case 5).
Note that case 5 may introduce a monadic minus in the wrong place.
The others will not do this unless their input has the same flaw.
Note also that that cases 1, 2, 8 and 9 may introduce multiplication
by $1$,
=INLINEFT
~1
=TEX
, or $0$ which must be simplified away.
Case 10 only arises when cancellation during in the polynomial normalisation has caused a sub-polynomial to become $0$.
=SML
val Ûcase1_thmÝ = tac_proof(([], ¬µc d m:ú·c*m + d*m = (c + d)*m®),
	rewrite_tac[ú_times_plus_distrib_thm]);
val Ûcase2_thmÝ = tac_proof(([], ¬µd m:ú·m + d*m = (îú 1 + d)*m®),
	rewrite_tac[ú_times_plus_distrib_thm, ú_plus_assoc_thm]);
val Ûcase3_thmÝ = tac_proof(([], ¬µm·îú 0 + m = m®),
	rewrite_tac[]);
val Ûcase5_thmÝ = tac_proof(([], ¬µm:ú·m + m = îú 2*m®),
	pure_rewrite_tac[prove_rule[]¬îú 2 = îú 1 + îú 1®,
		 ú_times_plus_distrib_thm]
	THEN rewrite_tac[]);
val Ûcase5a_thmÝ = tac_proof(([], ¬µm n:ú·m * ~ n= ~m * n®),
	rewrite_tac[ú_times_minus_thm]);
val Ûcase5b_thmÝ = tac_proof(([], ¬µm n p:ú·m * ~ n * p = ~m * n *p®),
	rewrite_tac[ú_times_minus_thm]);
val Ûcase6_thmÝ = tac_proof(([], ¬µm:ú·m + ~m = îú 0®),
	rewrite_tac[ú_minus_clauses]);
val Ûcase7_thmÝ = tac_proof(([], ¬µm n:ú·m*n + ~m*n = îú 0®),
	rewrite_tac[ú_minus_clauses, ú_times_minus_thm]);
val Ûcase8_thmÝ = tac_proof(([], ¬µm:ú·~m + d*m = (~(îú 1) + d)*m®),
	rewrite_tac[ú_times_minus_thm,
		ú_times1_thm, ú_times_plus_distrib_thm]);
val Ûcase9_thmÝ = tac_proof(([], ¬µm n:ú·~m*n + d*m*n = (~(îú 1) + d)*m*n®),
	rewrite_tac[ú_times_minus_thm,
		ú_times1_thm, ú_times_plus_distrib_thm]);
val Ûcase10_thmÝ = tac_proof(([], ¬µm:ú·m + îú 0 = m®),
	rewrite_tac[ú_plus0_thm]);
val Ûcase1289a_thmÝ = tac_proof(([], ¬µm:ú·îú 1 *m = m®),
	rewrite_tac[ú_times1_thm]);
val Ûcase1289b_thmÝ = tac_proof(([], ¬µm:ú·~(îú 1) * m = ~m®),
	rewrite_tac[ú_times1_thm, ú_times_minus_thm]);
val Ûcase1289c_thmÝ = tac_proof(([], ¬µm:ú·(îú 0) * m = îú 0®),
	rewrite_tac[ú_times0_thm]);
=TEX
Now we provide the conversions to support the 8 cases:
=SML
val Ûcase1289_convÝ : CONV = (
	(simple_eq_match_conv case1289a_thm ORELSE_C
		simple_eq_match_conv case1289b_thm ORELSE_C
		simple_eq_match_conv case1289c_thm)
);
val Ûcase1_convÝ : CONV = (fn tm => (
	(((dest_ú_signed_int o fst o dest_ú_times) **
		(dest_ú_signed_int o fst o dest_ú_times))
		o dest_ú_plus) tm;
	(simple_eq_match_conv case1_thm THEN_C LEFT_C ú_plus_conv
		THEN_TRY_C case1289_conv) tm
));
val Ûcase2_convÝ : CONV = (fn tm => (
	(dest_ú_signed_int o fst o dest_ú_times o snd o dest_ú_plus) tm;
	(simple_eq_match_conv case2_thm THEN_C LEFT_C ú_plus_conv
		THEN_TRY_C case1289_conv) tm
));
val Ûcase3_convÝ : CONV = (fn tm =>
	if (dest_ú_signed_int o fst o dest_ú_plus) tm = zero
	then (simple_eq_match_conv case3_thm) tm
	else fail_conv tm
);
val Ûcase4_convÝ = ú_plus_conv;
val Ûcase5_convÝ = simple_eq_match_conv case5_thm
	THEN_TRY_C (simple_eq_match_conv case5a_thm ORELSE_C
			simple_eq_match_conv case5b_thm);
val Ûcase6_convÝ = simple_eq_match_conv case6_thm;
val Ûcase7_convÝ = simple_eq_match_conv case7_thm;
val Ûcase8_convÝ : CONV = (fn tm => (
	(dest_ú_signed_int o fst o dest_ú_times o snd o dest_ú_plus) tm;
	(simple_eq_match_conv case8_thm THEN_C LEFT_C ú_plus_conv
		THEN_TRY_C case1289_conv) tm
));
val Ûcase9_convÝ : CONV = (fn tm => (
	(dest_ú_signed_int o fst o dest_ú_times o snd o dest_ú_plus) tm;
	(simple_eq_match_conv case9_thm THEN_C LEFT_C ú_plus_conv
		THEN_TRY_C case1289_conv) tm
));
val Ûcase10_convÝ = simple_eq_match_conv case10_thm;
=TEX
=SML
=TEX
The following conversional converts a conversion acting on $x + y$, say,
to one which will also act on $x + y + z$ (by rewriting it as $(x + y) + z$
and then applying the conversion to the subterm $x + y$).
=SML
val Ûú_plusÝ = ¬$+‰Z®;
fun ÛA_CÝ (c : CONV) : CONV = (fn tm =>
	let	val (ltm, rtm) = dest_ú_plus tm;
		exception BaseCase;
	in let	val (rtm1, rtm2) = dest_ú_plus rtm handle Fail _ => raise BaseCase;
		val thm = c (mk_ú_plus(ltm, rtm1));
	in	eq_trans_rule
		(list_µ_elim[ltm, rtm1, rtm2] ú_plus_assoc_thm1)
		(app_arg_rule rtm2 (app_fun_rule ú_plus thm))
	end 	handle BaseCase => c tm
	end
);
=TEX
We want to simplify multiplication according to the following scheme, where $x$ and $y$ denotes atoms (and other variables are as in the list of simplifications for addition):
=GFT
1.	c*d		= c*d
2.	0*x		= 0
3.	1*x		= x
4.	~1*~x		= x
5.	~1*x		= ~x
6.	~x*~y		= x*y
7.	x*~y		= ~x*y
=TEX
=SML
val Ûtimes234567_thmÝ = tac_proof(([],
	¬µx y:ú·îú
		0 * x = îú 0
	±	îú 1 * x = x
	±	~(îú 1) * ~x = x
	±	~(îú 1) * x = ~x
	±	~x * ~y = x*y
	±	x * ~y = ~x*y ®),
		rewrite_tac[ú_times_clauses, ú_times_minus_thm]);
=TEX
=SML
val Ûtimes1234567_convÝ : CONV = 
	FIRST_C (ú_times_conv :: map simple_eq_match_conv (current_ad_rw_canon() times234567_thm));
=TEX
$M\_C$ is analogous to $A\_C$ but for multiplication rather than addition.
There are additional cases to worry about.
=SML
val Ûtimes0_thmÝ = tac_proof(([],
	¬µx:ú·îú 0 * x = îú 0®),
		rewrite_tac[ú_times_clauses]);

val Ûú_timesÝ = ¬$*‰Z®;
fun ÛM_C1Ý (c : CONV) : CONV = (fn tm =>
	let	val (ltm, rtm) = dest_ú_times tm;
		exception BaseCase;
	in let	val (rtm1, rtm2) = dest_ú_times rtm handle Fail _ => raise BaseCase;
		val thm = c (mk_ú_times(ltm, rtm1));
	in	eq_trans_rule
		(list_µ_elim[ltm, rtm1, rtm2] ú_times_assoc_thm1)
		(app_arg_rule rtm2 (app_fun_rule ú_times thm))
	end 	handle BaseCase => c tm
	end
);
fun ÛM_CÝ (c : CONV) : CONV = 
	M_C1 c THEN_TRY_C
	FIRST_C (map simple_eq_match_conv [times0_thm, ú_times_assoc_thm]
);
=TEX
Pulling these bits together we get the following:.
=SML
val Ûadd_simp_convÝ =
	FIRST_C(map A_C[
		case1_conv, case2_conv, case3_conv, case4_conv,
		case5_conv, case6_conv, case7_conv, case8_conv,
		case9_conv, case10_conv]) THEN_C TRY_C case3_conv;
val Ûtimes_simp_convÝ = M_C times1234567_conv;

=TEX
Unlike the natural number case, we have some  non-trivial work to
do trying to make non-atoms from what $poly\_conv$ will see as
atoms if we don't push monadic and dyadic minus around.
The transformation is done according to the following schema:
=GFT
1. ~ (~ m)		= m			(repeatedly)
2. ~(m + n)		= ~m + ~n
3. ~(m * n)		= ~m * n
4. (m - n)		= m + ~n
5. ~(m - n)		= ~m + n
6. ~0			= 0
=TEX
Note that the first of these must be performed repeatedly, since $poly\_conv$
will only apply it once, and, if there are more than four monadic minuses
this may be insufficient to reveal a non-atom for $poly\_conv$ to attack.
=SML
val Ûminus1_thmÝ = tac_proof(([], ¬µm:ú·~ (~ m) = m®),
	rewrite_tac[ú_minus_thm]);
val Ûminus23456_thmÝ = tac_proof(([],
	¬µm:ú·~(m + n) =~m + ~n
	±	~(m * n) = ~m * n
	±	m - n = m + ~n
	±	~(m - n) = ~m + n
	±	~(îú 0) = îú 0®),
	rewrite_tac[ú_minus_thm, ú_times_minus_thm, get_spec¬$-‰Z®]);
=TEX
=SML
val Ûminus1_convÝ = REPEAT_C1 (simple_eq_match_conv minus1_thm);
val Ûminus23456_convsÝ = map simple_eq_match_conv (current_ad_rw_canon()minus23456_thm);
val Ûminus_simp_convÝ = minus1_conv AND_OR_C FIRST_C minus23456_convs;
=TEX
We need the following theorem:
=SML
val Ûú_left_times_plus_distrib_thmÝ =
	all_µ_intro(±_left_elim(all_µ_elim ú_times_plus_distrib_thm));
=TEX
Now we can define the external interfaces:
=SML
local
val  Ûú_ANF_C_AUXÝ : CONV -> CONV = ( 
	poly_conv
	ú_term_order
	ú_plus_comm_thm
	ú_plus_assoc_thm
	ú_times_comm_thm
	ú_times_assoc_thm
	ú_left_times_plus_distrib_thm
	(add_simp_conv)
	(times_simp_conv)
);
in
fun  Ûú_ANF_CÝ (conv : CONV) : CONV = (fn tm =>
	(ú_ANF_C_AUX (conv ORELSE_C minus_simp_conv) tm)
	handle Fail _ => term_fail "ú_ANF_C" 105032 [tm]
);
val Ûú_anf_convÝ : CONV = (fn tm =>
	(ú_ANF_C fail_conv tm)
		handle ex => (
			if area_of ex = "ú_ANF_C"
			then reraise ex "ú_anf_conv"
			else raise ex
	)
);
end;
=TEX
\section{LINEAR ARITHMETIC DECISION PROCEDURE}
The material in this section implements the linear
arithmetic decision procedure for integers and is modelled  on the
treatment for the natural numbers given in \cite{DS/FMU/IED/DTD082}.
\subsection{Preliminaries}
=IGN
open LinearArithmeticTools;
=TEX
We need lots of theorems:
=SML
val Ûú_³_eq_thmÝ = tac_proof(([], ¬µm n : ú·³m = n ¤ m < n ² n < m®),
		REPEAT µ_tac THEN rewrite_tac[taut_rule¬µa b·(³a¤b)¤(a¤³b)®]
		THEN REPEAT strip_tac THEN_LIST
	[asm_rewrite_tac[],
	asm_rewrite_tac[],
	strip_asm_tac(list_µ_elim[¬m:ú®, ¬n:ú®]ú_less_cases_thm)
	THEN all_fc_tac [ú_¼_antisym_thm]]);
val Ûadd_eq_eq_thmÝ = tac_proof(([],
	¬µm n i j:ú·m = n ± i = j ´ m + i = n + j®),
	REPEAT strip_tac THEN asm_rewrite_tac[]);
val Ûadd_eq_¼_thmÝ = tac_proof(([],
	¬µm n i j:ú·m = n ± i ¼ j ´ m + i ¼ n + j®),
	REPEAT strip_tac THEN asm_rewrite_tac[]);
=TEX
=SML
val Ûadd_¼_¼_thmÝ = tac_proof(
	([], ¬µm n i j:ú·m ¼ n ± i ¼ j ´ m + i ¼ n + j®),
	REPEAT µ_tac THEN STRIP_T (strip_asm_tac o pure_rewrite_rule[ú_¼_def])
THEN	all_var_elim_asm_tac1
THEN	rewrite_tac[µ_elim¬i:ú® ú_plus_order_thm, ú_plus_assoc_thm,
		conv_rule (ONCE_MAP_C eq_sym_conv) îú_plus_homomorphism_thm,
		îú_¼_thm]);
=TEX
=SML
val Ûminus_in_thmÝ = tac_proof(
	([], ¬µi j:ú·~(i*j) = ~i*j®),
	rewrite_tac[ú_times_minus_thm]);
=TEX
=SML
val Ûscale_eq_thmÝ  = tac_proof(
	([], ¬µk:ú; i j:ú·i = j ´ k * i = k * j®),
	REPEAT strip_tac THEN asm_rewrite_tac[]);
val Ûpos_scale_¼_thmÝ = tac_proof(
	([], ¬µm:î; i j:ú·i ¼ j ´ îú m * i ¼ îú m * j®),
	rewrite_tac[ú_¼_def] THEN REPEAT strip_tac
	THEN ¶_tac¬m:î * m'® THEN all_var_elim_asm_tac1
	THEN rewrite_tac[ú_times_plus_distrib_thm, îú_times_homomorphism_thm]);
=TEX
=SML
fun Ûsum2_rule_auxÝ (th1 : THM) (th2: THM) : THM = (
	let	val rator1 = (fst o dest_const o fst o strip_app o concl) th1;
		val rator2 = (fst o dest_const o fst o strip_app o concl) th2;
		val (add_th, conj_th) = (
			case (rator1, rator2) of
				("=", "=") => (add_eq_eq_thm, ±_intro th1 th2)
			|	("=", "¼‰Z") => (add_eq_¼_thm, ±_intro th1 th2)
			|	("¼‰Z", "¼‰Z") => (add_¼_¼_thm, ±_intro th1 th2)
			|	("¼‰Z", "=") => (add_eq_¼_thm, ±_intro th2 th1)
			|	_ => thm_fail "sum2_rule" 999 [th1, th2]
		);
	in	(conv_rule (RAND_C ú_plus_conv) o ´_match_mp_rule add_th)
		conj_th
	end
	handle Fail _ => thm_fail "sum2_rule" 999 [th1, th2]
(* ?0 and ?1 are not both of the form ô a = b, ô a < b, ô a ¼ b ô a > b or ôa ¾ b *)
);
=IGN
val th1 = asm_rule ¬x + y = îú 5®;
val th2 = asm_rule ¬a + b ¼ îú 12®;
sum2_rule_aux th1 th1;
sum2_rule_aux th1 th2;
sum2_rule_aux th2 th1;
sum2_rule_aux th2 th2;
=TEX
Note: notwithstanding the rather complex coding of the version of these functions
for the natural numbers, Hodes' algorithm as implemented in \cite{DS/FMU/IED/IMP082} produces a polynomial in which the only negative coefficients correspond to equations in the original input.
The following function does not therefore need a case for negating a ¼.
=SML
fun Ûlit_scale_ruleÝ (a : INTEGER) (th : THM) : THM = (
	let	val scale_th =  (
			case (fst o dest_const o fst o strip_app o concl) th of
				"¼‰Z" => (
				simple_µ_elim (mk_î a) pos_scale_¼_thm
			) |	_ => (
				simple_µ_elim (mk_ú_signed_int a) scale_eq_thm
			)
		);
	in	(conv_rule (RAND_C ú_times_conv) o ´_match_mp_rule scale_th) th
	end
);
=IGN
lit_scale_rule one th1;
lit_scale_rule (@@"2") th1;
lit_scale_rule (@@"~3") th1;
lit_scale_rule (@@"2") th2;
=TEX
=SML
fun Ûscale_and_sum2_ruleÝ (a1 : INTEGER) (th1 : THM) (th2: THM) : THM = (
	sum2_rule_aux (lit_scale_rule a1 th1) th2
);
=TEX
=SML
fun Ûscaled_sum_ruleÝ (aths : (INTEGER * THM) list) : THM = (
	let 	fun r aths = (
			case aths of
				[] => fail "sum2_rule" 9089 []
			|	[(a, th)] =>
					lit_scale_rule a th
			|	(a, th) :: more =>
					scale_and_sum2_rule a th (r more)
		);
	in	conv_rule (TRY_C (LEFT_C ú_anf_conv)
			THEN_C TRY_C (ú_¼_conv ORELSE_C ú_eq_conv)) (r aths)
	end
);
=IGN
val th3 = asm_rule ¬(x + îú 1) * (x - îú 1) = îú 20®;
val th4 = asm_rule ¬(x + îú 1) * ~(x - îú 1) = îú 20®;
scaled_sum_rule [(@@"42", th1)];
scaled_sum_rule [(@@"42", th2)];
scaled_sum_rule [(@@"42", th1), (@@"9", th2), (@@"5", th3)];
scaled_sum_rule [(@@"6", th3), (@@"6", th4)];
scaled_sum_rule [(@@"6", th3), (@@"~6", th4)];
scaled_sum_rule [(@@"1", th3)];
scaled_sum_rule [(@@"~1", th3)];
=TEX
\subsection{The Linear Arithmetic Rule}
=TEX
We use the following type to represent a scaled sum of linear arithmetic
atoms:
=SML
open LinearArithmeticTools;
type ÛSCALED_SUMÝ = (INTEGER * TERM) list;
=TEX
=SML
fun Ûstrip_ú_plusÝ (tm : TERM) : TERM list = (
	((op :: o (Combinators.I ** strip_ú_plus) o dest_ú_plus) tm)
	handle Fail _ => [tm]
);
=IGN
strip_ú_plus¬x:ú®;
strip_ú_plus¬x:ú + y + îú 42 * v + q®;
=TEX
Note that the following is intended to operate on a term which is either
in additive normal form. 
=SML
val Ûminus_oneÝ = @~one;
fun Ûdest_summandÝ (tm : TERM) : INTEGER * TERM = (
	let val nt = ((dest_ú_signed_int ** Combinators.I) o dest_ú_times) tm;
	in	if (fst nt) = one
		then (one, tm)
		else nt
	end	handle Fail _ => (
			let 	val (x, y) = (dest_ú_times tm);
				val x' = dest_ú_minus x;
			in	(minus_one, mk_ú_times(x', y))
			end
		)
		handle Fail _ => (minus_one, dest_ú_minus tm)
		handle Fail _ => (one, tm)
);
=IGN
(string_of_integer ** Combinators.I o dest_summand)¬~(x:ú)®;
(string_of_integer ** Combinators.I o dest_summand)¬îú 42 * v®;
(string_of_integer ** Combinators.I o dest_summand)¬~(îú 42) * v®;
(string_of_integer ** Combinators.I o dest_summand)¬~(îú 42) * v®;
(string_of_integer ** Combinators.I o dest_summand)¬~(x:ú) * v®;
=TEX
=SML
val Ûdest_sumÝ : TERM -> SCALED_SUM = map dest_summand o strip_ú_plus;
=TEX
=SML
val Ûmk_ú0Ý = ¬îú 0®;
fun Ûmk_sumÝ ([] : SCALED_SUM) = mk_ú0
|   mk_sum [(i, t)] = (
	if i = one
	then t
	else if i = minus_one
	then mk_ú_minus t
	else mk_ú_times(mk_ú_signed_int i, t)
) | mk_sum ((i, t) :: more) = (
	if i = one
	then mk_ú_plus(t, mk_sum more)
	else if i = minus_one
	then mk_ú_plus(mk_ú_minus t, mk_sum more)
	else mk_ú_plus(mk_ú_times(mk_ú_signed_int i, t), mk_sum more)
);
=IGN
mk_sum(dest_sum¬îú 42 * v + a * b + c + ~(îú 5) * d®);
=TEX
=TEX
We use the following type to represent a constraint (with HOL terms rather
than variables as its atoms):
=SML
type ÛTERM_CONSTRAINTÝ = SCALED_SUM * TERM * INTEGER;
=TEX
The next function extracts a term constraint from an equation
or a ¼. 
=SML
val ú = ”ú®;
fun Ûdest_constraintÝ (tm : TERM) : TERM_CONSTRAINT OPT = (
	let	val ((rel, l), r) =
			((dest_app ** Combinators.I) o dest_app)tm;
	in	case fst(dest_const rel) of 
			"=" => (
				if type_of l =: ú
				then Value (dest_sum l, rel, dest_ú_signed_int r)
				else Nil
		) |	"¼‰Z" => (Value (dest_sum l, rel, dest_ú_signed_int r)
		) |	_ => Nil
	end	handle Fail _ => Nil
);
=IGN
dest_constraint¬a + îú 7 * b + ~(îú 5) * c = îú 9®;
dest_constraint¬~a = îú 9®;
=TEX
Given a term constraint, the following function assigns variables numbers
for $lin\_arith\_contr$ to the atoms:
=SML
fun Ûatom_mapÝ
	(x : TERM_CONSTRAINT list)
	: (int * TERM) list = (
	let	fun aux1 acc [] = acc
		|   aux1 acc ((i, t) :: more) = (
			aux1 (acc term_grab t) more
		);
		fun aux2 acc [] = acc
		|   aux2 acc ((s1, _, _) :: more) = (
			aux2 (aux1 acc s1) more
		);
		val tms = aux2 [] x;
	in	combine (interval 1 (length tms)) tms
	end
);
=IGN
atom_map [force_value (dest_constraint
		¬a + îú 7 * b + ~(îú 5) * c * d = îú 9®),
	force_value (dest_constraint
		¬a*b + îú 7 * b + ~(îú 5) * c * d = îú 9®)];
=TEX
=SML
fun Ûterm_rassocÝ
	((i, t) :: more : ('a * TERM) list)
	(tm : TERM) : 'a = (
	if t ~=$ tm then i else term_rassoc more tm
) | Ûterm_rassocÝ [] _ = (
	fail "term_rassoc" 9090 []
);
=TEX
=SML
fun Ûterm_lassocÝ
	((t, i) :: more : (TERM * 'a) list)
	(tm : TERM) : 'a = (
	if t ~=$ tm then i else term_lassoc more tm
) | Ûterm_lassocÝ [] _ = (
	fail "term_lassoc" 9090 []
);
=TEX
Given the mapping of variable numbers to HOL terms and
a scaled sum, the following
function computes the corresponding polynomial for $lin\_arith\_contr$
=SML
fun Ûmake_polyÝ (inds : (int * TERM) list) (ss : SCALED_SUM) : POLY = (
	let	fun collect p ((i, tm) :: more) = (
			collect ((i, term_rassoc inds tm) :: p) more
		) | collect acc [] = acc;
	in	normalise_poly (collect [] ss)
	end
);
=TEX
The following function makes a constraint for $lin\_arith\_contr$, 
given the mapping of variable numbers to HOL terms and
a term constraint:
=SML
fun Ûmake_constraintÝ (inds : (int * TERM) list)
		((ind, (l, rel, r)) : int * TERM_CONSTRAINT)
		: CONSTRAINT = (
	let	val rator = (
			case fst(dest_const rel) of
				"=" => Eq
			|	"¼‰Z" => LessEq
			|	_ => error "make_constraint" 9090 []
(* Unexpected error *)
		);
	in	(make_poly inds l, rator,  r, [(one, ind)])
	end
);
=TEX
Given a list of terms, the following function extracts all the information
needed by $lin\_arith\_contr$ and subsequently to process its output.
Note we generate variable names for each of the linear arithmetic atoms
to speed up proof of the theorem after a successful call of $lin\_arith\_contr$.
=SML
fun Ûmake_problemÝ (tml : TERM list) :
		((int * TERM) * TERM) list
	*	((	CONSTRAINT
		*	(int * TERM_CONSTRAINT)) list) = (
	let	fun aux1 [] = []
		|   aux1 (Nil :: more) = aux1 more
		|   aux1 (Value v :: more) = v :: aux1 more;
		val stsl = aux1(map dest_constraint tml);
		val inds = atom_map stsl;
		val istsl = combine (interval 1 (length stsl)) stsl;
		val ctl = map (make_constraint inds) istsl;
	in	(map(fn (i, t)=> ((i, mk_var("@_"^string_of_int i, ú)), t)) inds,
			combine ctl istsl)
	end
);
=TEX
Given the relevant information about variable numbers and generated
variable names and a scaled sum the following function computes the
corresponding term:
=SML
fun Ûmake_var_sumÝ (ivtl : ((int * TERM) * TERM) list) (ss : SCALED_SUM) : TERM = ( 
	let	fun name t = (
			snd(term_rassoc ivtl t)
		);
		fun aux1 (i, t) = (
			if i = one
			then name t
			else if i = minus_one
			then mk_ú_minus (name t)
			else mk_ú_times(mk_ú_signed_int i, name t)
		);
		fun aux2 [] = mk_ú_signed_int zero
		|   aux2 [s] = aux1 s
		|   aux2 (s :: more) = mk_ú_plus(aux1 s, aux2 more);
	in	aux2 ss
	end
);
=TEX
We are now concerned with
proving the theorem corresponding to one of the constraints passed
as input to $lin\_arith\_contr$.
=SML
fun Ûmake_var_thmÝ
	(ivtl : ((int * TERM) * TERM) list)
	((l, rel, r) : TERM_CONSTRAINT) : THM = (
	asm_rule(mk_app(mk_app(rel, make_var_sum ivtl l),
			mk_ú_signed_int r))
);
=TEX
The following function uses the results of $lin\_arith\_contr$ and
the substitution implicit in the results of $make\_problem$ to prove
the actual theorem that the assumptions entail $F$.
We have to patch up things of the form
=INLINEFT
~(x*y)
=TEX
the code below attempts to do this with reasonable efficiency and
simplicity, although more work and longer code would enable it to be done even faster.
=SML
fun Ûmake_actual_thmÝ
	(ivtl : ((int * TERM) * TERM) list)
	(p : POLY)
	(ts : (int * TERM_CONSTRAINT) list)
	: THM = (
	let	fun aux (i, t) = (i, make_var_thm ivtl (lassoc3 ts t));
		val subs = map (fn ((_, v), t) => (t, v)) ivtl;
		val thm = asm_inst_term_rule subs (scaled_sum_rule (map aux p));
		val conv = (fn tm =>
			if	type_of tm =: ú
				andalso not (is_ú_plus tm)
			then	TRY_C (simple_eq_match_conv minus_in_thm) tm
			else	fail_conv tm
		);
		fun rule th = rule (undisch_rule th) handle Fail _ => th;
	in	(rule (conv_rule (ONCE_MAP_C conv) 	(all_´_intro thm)))
		handle Fail _ => thm
	end
);

=TEX
=SML
fun ÛdiagnoseÝ
	(who : string)
	(tml : TERM list)
	(ivtl : ((int * TERM) * TERM) list)
	(cts : CONSTRAINT list) : 'a = (
	let	fun format_ivt ((i,_), tm) = (
			"X" ^ string_of_int i ^ " = " ^ string_of_term tm
		);
		fun diag () = (
			diag_string(get_error_message 82100 []);
			(map diag_line o flat)
			(map (PrettyPrinter.format_term true) tml);
			case ivtl of [] => () | _ => (
				diag_string(get_error_message 82101 []);
				(map (diag_string o format_ivt) ivtl; ())
			);
			diag_string(get_error_message 82102 []);
			map (diag_string o format_constraint) cts;
				""
		);
	in	if	is_nil tml
		then	fail who 82111 []
		else	if is_nil cts
		then	fail who 105112 []
		else 	fail who 82110 [diag]
	end
);
fun Ûú_lin_arith_rule_auxÝ (who : string) (tml : TERM list) : THM = (
	let	val (ivtl, ctetcl) = make_problem tml;
		val cts = (map fst ctetcl);
		val p =	(lin_arith_contr cts)
			handle Fail _ => diagnose who tml ivtl cts;
	in	make_actual_thm ivtl p (map snd ctetcl)
	end
);
=TEX
=SML
val Ûú_lin_arith_ruleÝ : TERM list -> THM = ú_lin_arith_rule_aux "ú_lin_arith_rule";
=IGN
ú_lin_arith_rule [
	¬a + b = îú 0®
];
val tml = [
	¬a + b = îú 0®,
	¬a = îú 1®,
	¬b = îú 1®
];
ú_lin_arith_rule[
	¬a + b = îú 0®,
	¬a = îú 1®,
	¬b = îú 1®
];
ú_lin_arith_rule [
	¬a + b ¼ îú 0®,
	¬~a ¼ ~(îú 1)®,
	¬~b ¼ ~(îú 1)®
];
val th20 = ú_lin_arith_rule [
	¬a*a + b = îú 0®,
	¬~a*a ¼ ~(îú 1)®,
	¬~b ¼ ~(îú 1)®
];
val th20 = ú_lin_arith_rule [
	¬a*a + b = îú 1®,
	¬~a*a ¼ ~(îú 98765443210)®,
	¬~b ¼ ~(îú 1)®
];
=TEX
=SML
val Ûú_lin_arith_tacÝ : TACTIC = (fn gl =>
	(GET_ASMS_T (f_thm_tac o ú_lin_arith_rule o map concl) gl)
	handle ex => reraise ex "ú_lin_arith_tac"
);
=TEX
Now the tactic which is the automatic proof tactic
=SML
val Ûú_lin_arith_prove_tacÝ : THM list -> TACTIC = (fn thl => fn gl =>
	((	DROP_ASMS_T (MAP_EVERY strip_asm_tac)
	THEN	MAP_EVERY  strip_asm_tac thl
	THEN	contr_tac
	THEN	ú_lin_arith_tac) gl)
	handle	Fail msg => fail "ú_lin_arith_prove_tac" 82200
			[(fn () =>get_message msg),
			 (fn () => string_of_term (snd gl))]
);
=TEX
and the associated conversion:
=SML
val Ûú_lin_arith_prove_convÝ : THM list -> CONV = (fn thl => fn tm =>
	let	val th = tac_proof(([], tm), ú_lin_arith_prove_tac thl);
	in	¤_t_intro  th
	end	handle ex => reraise ex "ú_lin_arith_prove_conv"
);
=TEX
\section{OTHER RULES}
=TEX
=SML
val Ûú_eqÝ = ¬$=:ú­ú­BOOL®;
val ú_cancel_conv_thm1 = ú_eq_thm;
val ú_cancel_conv_thm2 = tac_proof(
	([], ¬µm : î; j k:ú·îú m + j = k ¤ j = k + ~ (îú m)®),
	REPEAT strip_tac THEN all_var_elim_asm_tac1 THEN
	rewrite_tac[µ_elim¬k:ú®ú_plus_order_thm, µ_elim¬j:ú®ú_plus_order_thm]);
val ú_cancel_conv_thm3 = tac_proof(
	([], ¬µm:î; j k:ú·~(îú m) + j = k ¤ j = k + îú m®),
	REPEAT strip_tac THEN all_var_elim_asm_tac1 THEN
	rewrite_tac[µ_elim¬k:ú®ú_plus_order_thm, µ_elim¬j:ú®ú_plus_order_thm]);
=TEX
=SML
val Ûú_¼Ý = ¬$¼:ú­ú­BOOL®;
val ú_¼_cancel_conv_thm1 = ú_¼_¼_0_thm;
val ú_¼_cancel_conv_thm2 = tac_proof(
	([], ¬µm : î; j k:ú·îú m + j ¼ k ¤ j ¼ k + ~ (îú m)®),
	once_rewrite_tac[ú_¼_¼_0_thm]
	THEN rewrite_tac[µ_elim¬~k:ú® ú_plus_order_thm]
	THEN rewrite_tac[µ_elim¬j:ú® ú_plus_order_thm]);
val ú_¼_cancel_conv_thm3 = tac_proof(
	([], ¬µm:î; j k:ú·~(îú m) + j ¼ k ¤ j ¼ k + îú m®),
	once_rewrite_tac[ú_¼_¼_0_thm]
	THEN rewrite_tac[µ_elim¬~k:ú® ú_plus_order_thm]
	THEN rewrite_tac[µ_elim¬j:ú® ú_plus_order_thm]);
=TEX
=SML
fun Ûgen_cancel_convÝ (r : TERM) (conv_thm1 : THM) (conv_thm2 : THM) (conv_thm3: THM)
	: CONV = (fn tm =>
	let	val (rela, b) = dest_app tm;
		val (rel, a) = dest_app rela;
	in 	if rel =$ r
		then
	let	val thm1 = (
			if	is_ú_signed_int b
			then	Nil
			else	Value (list_µ_elim[a, b] conv_thm1)
		);
		val arb1 =
			case thm1 of 
				Value thm => snd(dest_app(concl thm))
			|	Nil => tm;
		val thm2 = Value (RATOR_C (RAND_C ú_anf_conv) arb1)
				handle Fail _ => Nil;
		val arb2 =
			case thm2 of
				Value th => snd(dest_eq (concl th))
		|	_ => arb1;
		val (_, a2) = dest_app (fst(dest_app arb2));
		val thm3 = (
			let	val c = dest_ú_signed_int(fst (dest_ú_plus a2));
			in	Value
				(if	c @>= zero
				then	(simple_eq_match_conv conv_thm2
					THEN_C RIGHT_C ú_plus_conv) arb2
				else	(simple_eq_match_conv conv_thm3
					THEN_C RIGHT_C ú_plus_conv) arb2)
			end	handle Fail _ => Nil
		);
		fun chain (Value th1) (Value th2)= Value(eq_trans_rule th1 th2)
		|   chain (Value th1) Nil = Value th1 
		|   chain Nil (Value th2) = Value th2
		|   chain Nil Nil = Nil;
	in	case chain thm1 (chain thm2 thm3)of 
			Value th => th
		|	Nil => fail_conv tm
	end	else	fail_conv tm
	end
);
=TEX
=SML
val Ûú_eq_cancel_convÝ : CONV = (fn tm =>
	(gen_cancel_conv
		ú_eq ú_cancel_conv_thm1 ú_cancel_conv_thm2
			ú_cancel_conv_thm3 tm)
	handle Fail _ => term_fail "ú_eq_cancel_conv" 105120 [tm]
);
=TEX
=SML
val Ûú_¼_cancel_convÝ : CONV = (fn tm =>
	(gen_cancel_conv
		ú_¼ ú_¼_cancel_conv_thm1 ú_¼_cancel_conv_thm2
			ú_¼_cancel_conv_thm3 tm)
	handle Fail _ => term_fail "ú_eq_cancel_conv" 105121 [tm]
);
=IGN
ú_eq_cancel_conv¬a + b + îú 4 = îú 9 + y®;   
ú_eq_cancel_conv¬a + b + îú 20 = îú 9 + y®;   
ú_eq_cancel_conv¬b + a = îú 9 + y®;   
ú_eq_cancel_conv¬b + a = îú 9®;   
ú_eq_cancel_conv¬a + b = îú 9®   (* should fail *); 
ú_eq_cancel_conv¬îú 0 = îú 9®   (* should fail *); 
ú_eq_cancel_conv¬T = F®   (* should fail *); 
ú_eq_cancel_conv¬T ² F®   (* should fail *); 
ú_¼_cancel_conv¬a + b + îú 4 ¼ îú 9 + y®;   
ú_¼_cancel_conv¬a + b + îú 20 ¼ îú 9 + y®;   
ú_¼_cancel_conv¬b + a ¼ îú 9 + y®;   
ú_¼_cancel_conv¬b + a ¼ îú 9®;   
ú_¼_cancel_conv¬a + b ¼ îú 9®   (* should fail *); 
ú_¼_cancel_conv¬îú 0 ¼ îú 9®   (* should fail *); 
ú_¼_cancel_conv¬T = F®   (* should fail *); 
ú_¼_cancel_conv¬T ² F®   (* should fail *); 
=TEX
\section{THE PROOF CONTEXTS}
The equational contexts required are the same for stripping goals and stripping
theorems. We take numeric $=$ and $¼$ as the atomic
predicates which we will deal with. The possibilities are:
{\em(i)} put the a ground atomic predicate into normal form with the appropriate canncellation conversion;
{\em(ii)} convert a negated atomic predicate into an atomic one;
{\em(iii)} convert a predicate formed with $<$, $¾$ or $>$ into an atomic one;
{\em(iv)} convert the negation of a predicate formed with $<$, $¾$ or $>$ into an atomic one;
and
{\em(v)} attempt to evaluate ground inequalities.
=TEX
The following is a little bit more leisurely than the natural numbers versions;
it does the conversion into atomic predicates in easy stages.
=SML
val strip_cxt = [

	(¬(x:ú) = y®, ú_eq_conv),
	(¬(x:ú) ¼ y®, ú_¼_conv),

	(¬³(x:ú) = y®, simple_eq_match_conv ú_³_eq_thm),
	(¬³(x:ú) ¼ y®, simple_eq_match_conv ú_³_¼_thm),

	(¬(x:ú) < y®, simple_eq_match_conv ú_less_def),
	(¬(x:ú) ¾ y®, simple_eq_match_conv ú_¾_def),
	(¬(x:ú) > y®, simple_eq_match_conv ú_greater_def),

	(¬³ (x:ú) < y®, simple_eq_match_conv ú_³_less_thm),
	(¬³ (x:ú) ¾ y®, RAND_C(simple_eq_match_conv ú_¾_def)),
	(¬³ (x:ú) > y®, RAND_C(simple_eq_match_conv ú_greater_def)),


	(¬(x:ú) = y®, ú_eq_cancel_conv),
	(¬(x:ú) ¼ y®, ú_¼_cancel_conv)];
=IGN
map (fn (t, c) => TRY_C c t) strip_cxt;
=TEX
=SML
val _ = delete_pc "'ú_lin_arith" handle Fail _ => ();
val _ = new_pc Û"'ú_lin_arith"Ý;
val _ = set_rw_eqn_cxt strip_cxt "'ú_lin_arith";
val _ = set_st_eqn_cxt strip_cxt "'ú_lin_arith";
val _ = set_sc_eqn_cxt strip_cxt "'ú_lin_arith";
val _ = set_pr_tac ú_lin_arith_prove_tac "'ú_lin_arith";
val _ = set_pr_conv ú_lin_arith_prove_conv "'ú_lin_arith";
val _ = commit_pc "'ú_lin_arith";
=TEX
=SML
val _ = delete_pc "ú_lin_arith" handle Fail _ => ();
val _ = new_pc Û"ú_lin_arith"Ý;
val _ = merge_pcs ["predicates","'ú_lin_arith"] "ú_lin_arith";
val _ = commit_pc "ú_lin_arith";
=TEX
=IGN
map (PC_C1 "ú_lin_arith" rewrite_conv[]) [
	¬îú 1 = îú 2®, ¬îú 3 ¼ îú 2®, ¬îú 2 = îú 2®, ¬îú 1 ¼ îú 2®
,	¬a + b = b + a + îú 1®, ¬a + îú 20 + b = (a+ îú 10)+(b+ îú 10)®
,	¬a + b ¼ b + a - îú 1®, ¬a + îú 20 + b ¼ (a+ îú 14)+(b+ îú 10)®
,	¬³îú 10 = îú 20®, ¬³(a:ú) + b = b + a®
,	¬³îú 10 ¼ îú 20®, ¬³(a:ú) + b ¼ b + a®
,	¬îú 10 < îú 20®, ¬(a:ú) + b ¾ b + a®, ¬(a:ú) + b > b + a®
,	¬³îú 10 < îú 20®, ¬³(a:ú) + b ¾ b + a®, ¬³(a:ú) + b > b + a®
,	¬(a:ú +b)*(a-b) = a*a - b*b®, ¬(a:ú +b)*(a-b) = a*a - b*b ®
]; 
map (PC_C1 "ú_lin_arith" prove_rule[]) [
	¬a*a ¾ îú 0 ± b*b ¾ îú 0 ´ (a+b)*(a+b) ¾ îú 2 * a * b®
];
map (PC_C1 "ú_lin_arith" rewrite_conv[]) [
	¬a*a ¾ îú 0 ± b*b ¾ îú 0 ´ (a+b)*(a+b) ¾ îú 2 * a * b®
];
=SML
val _ = pop_pc();
end (* of structure úArithmeticTools *);
open úArithmeticTools;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

