%  dtd093.doc  %Z% $Revision$ $RCSfile$ $Date$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Theory of Integers}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD093}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthors{R.D.~Arthan & WIN01\\A.C.~Hayward & WIN01}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design of
a theory of integers for HOL.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\load{\scriptsize}{\msyChar}
\load{\footnotesize}{\msyChar}

\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issue 1.1 (25th March 1993)]
First (incomplete) draft.
\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design
of  theory of integers for \ProductHOL, and elementary
(computational) proof support.
The high level design for this material is given in \cite{DS/FMU/IED/HLD011}.
\subsection{Introduction}
The document prevents a (conservative) treatment of the integers. The
treatment is close to the (currently axiomatic) account given for Z in
\cite{DS/FMU/IED/DTD086}.
\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD011}.
\subsection{Dependencies}
Loading this document and its implementation relies on having loaded
the theory $basic\_hol$ of \cite{DS/FMU/IED/IMP045}.

\subsection{Possible Enhancements}
Course-of-values induction might be a valuable addition.
\subsection{Deficiencies}
\section{PROLOGUE}

=SML
open_theory"hol";
set_pc"hol";
new_theory"ú";
=TEX
\section {DEFINITION OF FIXITY}


\section{DEFINITIONS}
The integer operations are distinguished from the natural number ones
by a subscript Z.
Later on the unsubscripted forms are declared as aliases.
\subsection{Fixity}
=SML
declare_infix(210, "<‰Z");
declare_infix(210, "¼‰Z");
declare_infix(210, ">‰Z");
declare_infix(210, "¾‰Z");
declare_infix(300, "+‰Z");
declare_infix(310, "*‰Z");
declare_infix(310, "Div‰Z");
declare_infix(310, "Mod‰Z");
declare_prefix(350, "~‰Z");
declare_prefix(350, "Abs‰Z");
=TEX
\subsection{The New Type}
The integers are defined to be represented by equivalences classes of
pairs of natural numbers under the equivalence relation, $R$, given by
=GFT
	(m, n) R (a, b) ¤ m + y = n + x
=TEX
The equivalence class of a pair $(m, n)$ represents the integer $m - n$.

The following property holds of a set of pairs of natural numbers iff.
the set is an equivalence class of $R$.
(There is no need to define a constant for $R$: $R$ is only need during
the consistency proof for the definition of addition, and is easily written
out in full there as needed.)

¹HOLCONST
	Is_ú_Rep : (î ¸ î) SET ­ BOOL
÷
	µa· Is_ú_Rep a ¤ ¶m n· a = { (x, y) | m + y = n + x }
°
We now prove the consistency of the above definition as needed to define
a new type:
=SML
set_goal([], ¬¶a·Is_ú_Rep a®);
a(¶_tac¬{(i, j) | j = i}® THEN rewrite_tac[get_spec¬Is_ú_Rep®]);
a(¶_tac ¬0® THEN ¶_tac ¬0® THEN rewrite_tac[]);
save_thm("is_ú_rep_consistent_thm", pop_thm());
=TEX
Now we define the type:
=SML
val ú_def = new_type_defn(["ú", "ú_def"], "ú", [],
	get_thm"-""is_ú_rep_consistent_thm");
=TEX
\subsection{Constants}
We define simultaneously addition, unary minus, and the usual
injection, îú, of the natural numbers into the integers, thus:
¹HOLCONST
Ü	$+‰Z: ú ­ ú ­ ú;
Ü	$~‰Z: ú ­ ú;
Ü	îú: î ­ ú
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	(µi j k:ú·
Ü		(i +‰Z j) +‰Z k = i +‰Z (j +‰Z k)
Ü	±	i +‰Z j = j +‰Z i
Ü	±	i +‰Z ~‰Z i = îú 0
Ü	±	i +‰Z îú 0 = i)
Ü±	(µm n· îú m +‰Z îú n = îú(m + n))
Ü±	OneOne îú
Ü±	(µi·¶m· i = îú m ² i = ~‰Z îú m)
°
The four clauses of the above definition characterise the additive structure
of the integers as follows:

\begin{enumerate}
\item they form an abelian group under addition, with the inverse operation
given by unary minus, and the unit given by the image under îú of $0$.
\item îú is a homomorphism of monoids (w.r.t. addition).
\item îú is an injection
\item Any integer either equal tois is (the image of) a natural number or
is the negative (i.e. additive inverse) of (the image of) a natural number.
\end{enumerate}

(Note that the fact that the group is abelian could actually be derived
from the other properties, which are sufficient to ensure that the group
is the free group on one generator, namely $îú 1$, and so is commutative;
however, it is marginally easier to prove the commutativity using the
representation type.)
=TEX
Now we make shorter symbols overloaded aliases for the additive operations:
=SML
declare_alias("+", ¬$+‰Z®);
declare_alias("~", ¬$~‰Z®);
¹HOLCONST
Ü	$*‰Z: ú ­ ú ­ ú
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µi j k:ú·i*‰Z(j + k) = i*‰Z j + i*‰Z k
Ü	±	i *‰Z îú 1 = i
°
=TEX
=SML
declare_alias("*", ¬$*‰Z®);
=TEX
We now define the usual ordering relations. As with the treatment
of natural numbers for HOL, we take $¼$ as basic and define
the others in terms of it.
=SML
¹HOLCONST
Ü	$¼‰Z: ú ­ ú ­ BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µi j:ú·i ¼‰Z j ¤ ¶m:î· i + îú m = j
°
=TEX
¹HOLCONST
Ü	$<‰Z: ú ­ ú ­ BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µi j:ú·i <‰Z j ¤ i + îú 1 ¼‰Z j
°
=TEX
¹HOLCONST
Ü	$¾‰Z: ú ­ ú ­ BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µi j:ú·i ¾‰Z j ¤ j ¼‰Z i
°
=TEX
¹HOLCONST
Ü	$>‰Z: ú ­ ú ­ BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µi j:ú·i >‰Z j ¤ j <‰Z i
°
=TEX
Now we give aliases for the above:
=SML
declare_alias("¼", ¬$¼‰Z®);
declare_alias("<", ¬$<‰Z®);
declare_alias("¾", ¬$¾‰Z®);
declare_alias(">", ¬$>‰Z®);
=TEX
Finally, we define the absolute value function and use it to define $Div$
and $Mod$.
Note that as defined below, $Mod$ always take non-negative values.
(See the discussion in \cite{DS/FMU/IED/DTD086}.)

¹HOLCONST
Ü	$Abs‰Z: ú ­ ú
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µi:ú·Abs‰Z i = if îú 0 ¼ i then i else ~i
°
=TEX
¹HOLCONST
Ü	$Div‰Z: ú ­ ú ­ ú;
Ü	$Mod‰Z: ú ­ ú ­ ú
÷üüüüüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	µi j:ú·	³j = îú 0
Ü	´	i = (i Div‰Z j) * j + i Mod‰Z j
Ü	±	îú 0 ¼ i Mod‰Z j
Ü	±	i Mod‰Z j < Abs‰Z j
°
=SML
declare_alias("Abs", ¬$Abs‰Z®);
declare_alias("Div", ¬$Div‰Z®);
declare_alias("Mod", ¬$Mod‰Z®);
=TEX


\section{THEOREMS}
{\huge
Most of the following has been imperfectly adapted from the Z treatment
of \cite{DS/FMU/IED/DTD086}.
}%\huge
The current offering is restricted to some
fairly basic facts.
In particular, the following simplifying assumptions are made:

\begin{enumerate}
\item
Dyadic minus will be eliminated in favour of addition and monadic minus
as a matter of course. Thus theorems like
=INLINEFT
ú_plus_order_thm
=TEX
, but handling dyadic minus are not required.
\item
$<$ will usually be eliminated in favour of $¼$, and if not basic facts such
as irreflexivity for $<$ will be derivable by a decision procedure for linear
arithmetic.
\item
In the, rare, cases where they are needed,
inductive proofs for the integers as a whole will usually be handled by the user
combining more primitive things (e.g. natural number induction over the
absolute value). (However, a sort of induction tactic based on the fact that the
integers are a cyclic group is supplied.)
\end{enumerate}
=THDOC
req_thm(Û"ú_plus_comm_thm"İ, ([],
	¬µ i j : ú · i + j = j + i®));
=DESCRIBE
Commutativity of addition.
=ENDDOC
=THDOC
req_thm(Û"ú_plus_assoc_thm"İ, ([],
	¬µ i j k : ú · (i + j) + k = i + j + k®));
req_thm(Û"ú_plus_assoc_thm1"İ, ([],
	¬µ i j k : ú · i + j + k = (i + j) + k®));
=DESCRIBE
=DESCRIBE
Associativity of addition: first form moves brackets to the right;
second moves brackets to the left.
=ENDDOC
=THDOC
req_thm(Û"ú_plus_order_thm"İ, ([],
	¬µ i : ú · µ j k : ú ·
	j + i = i + j ± (i + j) + k = i + j + k ± j + i + k = i + j + k®));
=DESCRIBE
Magic theorem for reordering sums. If $i$ is specialised to $t$, rewriting
with the result floats $t$ to the beginning of the sum.
=ENDDOC
=THDOC
req_thm(Û"ú_plus0_thm"İ, ([],
	¬µ i : ú · i + 0 = i ± 0 + i = i®));
=DESCRIBE
0 is the additive identity.
=ENDDOC
=THDOC
req_thm(Û"ú_plus_minus_thm"İ, ([],
	¬µ i : ú · i + ~ i = 0 ± ~ i + i = 0®));
=DESCRIBE
=INLINEFT
~x
=TEX
\ is the additive inverse of $x$.
=ENDDOC
=THDOC
req_thm(Û"ú_plus_clauses"İ, ([],
	¬µ i j k : ú·	(i + k = j + k ¤ i = j)
			±	(k + i = j + k ¤ i = j)
			±	(i + k = k + j ¤ i = j)
			±	(k + i = k + j ¤ i = j)
			±	(i + k = k ¤ i = 0)
			±	(k + i = k ¤ i = 0)
			±	(k = k + j ¤ j = 0)
			±	(k = j + k ¤ j = 0)
			±	i + 0 = i
			±	0 + i = i
			±	³ 1 = 0
			±	³ 0 = 1®));
=DESCRIBE
Facts about addition of ubiquitous utility.
=ENDDOC
=THDOC
req_thm(Û"îú_plus_homomorphism_thm"İ, ([],
	µm n: î· îú(m + n) = îú m + îú n));
=DESCRIBE
The fact that $îú$ is a homomorphism of the additive monoids.
=ENDDOC
=THDOC
req_thm(Û"îú_times_homomorphism_thm"İ, ([],
	µm n: î· îú(m * n) = îú m * îú n));
=DESCRIBE
The fact that $îú$ is a homomorphism of the multiplicative monoids.
=ENDDOC
=THDOC
req_thm(Û"ú_induction_thm"İ, ([],
	¬µp : ú ­ BOOL·
		p (îú 1)
	±	(µi· p i ´ p (~ i))
	±	(µi j· p i ± p j ´ p (i + j))
	´	(µi· p i)®));
=DESCRIBE
An induction principle for the integers: any property which holds for $1$, and
which is preserved under negation and addition, holds everywhere.
The theorem is stated in a mixture of HOL and Z suitable for use as an
argument to $gen\_induction\_tac$.
=ENDDOC
=THDOC
req_thm(Û"ú_î_plus1_thm"İ, ([],
	¬µ i : î · îú 0 ¼ i + 1®));
=DESCRIBE
Closure of the natural numbers under addition of $1$.
=ENDDOC
=THDOC
req_thm(Û"ú_î_induction_thm"İ, ([],
	¬µ p· p (îú 0) ± (µ i· îú 0 ¼ i ± p i ´ p (i + 1)) ´ (µ m· 0 ¼ m ´ p m)®));
=DESCRIBE
Ordinary induction for the natural numbers.
The theorem is stated in a mixture of HOL and Z suitable for use as an
argument to $gen\_induction\_tac1$.
=ENDDOC
=THDOC
req_thm(Û"ú_î_plus_thm"İ, ([],
	¬µ i j · îú 0 ¼ i ± îú j ¼ i ´ îú 0 ¼ (i + j)®));
=DESCRIBE
The natural numbers are closed under addition.
=ENDDOC
=THDOC
req_thm(Û"ú_eq_thm"İ, ([],
	¬µ i j :  ú · i = j ¤ i + ~ j = 0®));
=DESCRIBE
Reduction of an equation between integers to one with the simplest
possible right-hand side. N.b. the theorem is intended for use
with
=INLINEFT
once_rewrite_tac
=TEX
, since repeated rewriting would loop.
=ENDDOC
=THDOC
req_thm(Û"ú_minus_thm"İ, ([],
	¬µ i j :  ú ·
		~ (~ i) = i
	±	i + ~ i = 0
	±	~ i + i = 0
	±	~ (i + j) = ~ i + ~ j
	±	~ 0 = 0®));
=DESCRIBE
Standard facts about negation and addition. Rewriting with this moves negation inside
addition.
=ENDDOC
=THDOC
req_thm(Û"ú_minus_clauses"İ, ([],
	¬µ i : ú · ~ ~ i = i ± ~ 0 = 0 ± i + ~ i = 0 ± ~ i + i = 0®));
=DESCRIBE
Facts about negation which are nearly always wanted as rewrite rules
for use in the proof context $z\_numbers$.
(This is like $z\_minus\_thm$, but with the equation which makes an
expansive rewrite rule omitted.)
=ENDDOC
=THDOC
req_thm(Û"ú_î_cases_thm"İ, ([],
	¬µ i : î · i = 0 ² (¶ j : î · i = j + 1)®));
req_thm(Û"ú_î_³_minus_thm"İ, ([],
	¬µ i : î · i = 0 ² ³ ~ i  î®));
=DESCRIBE
Case analyses for the natural numbers.
=ENDDOC
=THDOC
req_thm(Û"ú_³_î_thm"İ, ([],
	¬µ i : ú · ³ i  î ´ ~ i  î®));
=DESCRIBE
Integers which are not natural numbers are the negatives of natural numbers.
=ENDDOC
=THDOC
req_thm(Û"ú_ú_cases_thm"İ, ([],
	¬µ i : ú · ¶ j : î · i = j ² i = ~ j®));
req_thm(Û"ú_ú_cases_thm1"İ, ([],
	¬µ i : ú · i  î ² (¶ j : î · i = ~ (j + 1))®));
=DESCRIBE
Two forms of case analysis for the integers.
=ENDDOC
=THDOC
req_thm(Û"ú_î_³_plus1_thm"İ, ([],
	¬µ i : î · ³ i + 1 = 0®));
=DESCRIBE
$1$ is not the additive inverse of any natural number.
=ENDDOC
=THDOC
req_thm(Û"ú_times_comm_thm"İ, ([],
	¬µ i j :  ú · i * j = j * i®));
=DESCRIBE
Commutativity of multiplication.
=ENDDOC
=THDOC
req_thm(Û"ú_times_assoc_thm"İ, ([],
	¬µ i j k : ú · (i * j) * k = i * j * k®));
req_thm(Û"ú_times_assoc_thm1"İ, ([],
	¬µ i j k : ú · i * j * k = (i * j) * k®));
=DESCRIBE
Associativity of multiplication: first form moves brackets to the right;
second moves brackets to the left.
=ENDDOC
=THDOC
req_thm(Û"ú_times_order_thm"İ, ([],
	¬µ i : ú · µ j, k : ú ·
	j * i = i * j ± (i * j) * k = i * j * k ± j * i * k = i * j * k®));
=DESCRIBE
Magic theorem for reordering products. If $i$ is specialised to $t$, rewriting
with the result floats $t$ to the beginning of the product.
=ENDDOC
=THDOC
req_thm(Û"ú_times1_thm"İ, ([],
	¬µ i : ú · i * 1 = i ± 1 * i = i®));
=DESCRIBE
1 is the identity for multiplication.
=ENDDOC
=THDOC
req_thm(Û"ú_times_plus_distrib_thm"İ, ([],
	¬µ i j k : ú · i * (j + k) = i * j + i * k ± (i + j) * k = i * k + j * k®));
=DESCRIBE
Multiplication is distributive over addition. Rewriting with this expands
all subterms of the form
=INLINEFT
t1*(t2 + t3)
=TEX
\ or
=INLINEFT
(t1 + t2)*t3
=TEX
.
=ENDDOC
=THDOC
req_thm(Û"ú_times0_thm"İ, ([],
	¬µ i : ú · 0 * i = 0 ± i * 0 = 0®));
req_thm(Û"ú_times_eq_0_thm"İ, ([],
	¬µ i j :  ú · i * j = 0 ¤ i = 0 ² j = 0®));
=DESCRIBE
0 is an annihilator of any element, and moreover, by the second theorem
it is the only annihilator of any element apart from itself.
=ENDDOC
=THDOC
req_thm(Û"ú_minus_times_thm"İ, ([],
	¬µ i j :  ú · ~ i * j = ~ (i * j) ± i * ~ j = ~ (i * j) ± ~ i * ~ j = i * j®));
=DESCRIBE
Standard facts about negation and multiplication.
Rewriting with this moves negation outside multiplication.
=ENDDOC
=THDOC
req_thm(Û"ú_times_clauses"İ, ([],
	¬µ i j :  ú · 0 * i = 0 ± i * 0 = 0 ± i * 1 = i ± 1 * i = i®));
=DESCRIBE
Ubiquitously useful facts about multiplication.
=ENDDOC
=THDOC
req_thm(Û"ú_î_times_thm"İ, ([],
	¬µ i j :  î · i * j  î®));
=DESCRIBE
The natural numbers are closed under multiplication.
=ENDDOC
=THDOC
req_thm(Û"ú_¼_trans_thm"İ, ([],
	¬µ i j k : ú · i ¼ j ± j ¼ k ´ i ¼ k®));
req_thm(Û"ú_¼_cases_thm"İ, ([],
	¬µ i j :  ú · i ¼ j ² j ¼ i®));
req_thm(Û"ú_¼_refl_thm"İ, ([],
	¬µ i : ú · i ¼ i®));
req_thm(Û"ú_¼_antisym_thm"İ, ([],
	¬µi j :  ú | i ¼ j ± j ¼ i · i = j®));
=DESCRIBE
¼ is transitive, reflexive, antisymmetric and total.
=ENDDOC
=THDOC
req_thm(Û"ú_less_trans_thm"İ, ([],
	¬µ i j k : ú · i < j ± j < k ´ i < k®));
req_thm(Û"ú_less_irrefl_thm"İ, ([],
	¬µ i j :  ú · ³ (i < j ± j < i)®));
=DESCRIBE
$<$ is transitive and irreflexive.
=ENDDOC
=THDOC
req_thm(Û"ú_¼_less_eq_thm"İ,([],
	¬µ x, y : ú · x ¼ y ¤ (x < y ² x = y)®));
=DESCRIBE
The natural definition of $¼$ in terms of $<$.
=ENDDOC
=THDOC
req_thm(Û"ú_less_¼_trans_thm"İ, ([],
	¬µ i j k : ú · i < j ± j ¼ k ´ i < k®));
req_thm(Û"ú_¼_less_trans_thm"İ, ([],
	¬µ i j k : ú | i ¼ j ± j < k · i < k®));
=DESCRIBE
Forms of ``transitivity'' in which
s strict and a non-strict inequality give a strict inequality.
=ENDDOC
=THDOC
req_thm(Û"ú_minus_î_¼_thm"İ, ([],
	¬µ i : ú; j : î · i + ~ j ¼ i®));
req_thm(Û"ú_¼_plus_î_thm"İ, ([],
	¬µ i : ú; j : î · i ¼ i + j®));
=DESCRIBE
Subtracting a natural number from any integer gives a smaller one,
and adding  a natural number to any integer gives a larger one.
=ENDDOC
=THDOC
req_thm(Û"ú__î_thm"İ, ([],
	¬µ i : ú · i  î ¤ 0 ¼ i®));
=DESCRIBE
The natural numbers are precisely those which are bounded below by $0$.
=ENDDOC
=THDOC
req_thm(Û"ú_¼_¼_0_thm"İ, ([],
	¬µi j :  ú · i ¼ j ¤ i + ~j ¼ 0®));
=DESCRIBE
Reduction of an inequality between integers to one with the simplest
possible right-hand side. N.b. the theorem is intended for use
with
=INLINEFT
once_rewrite_tac
=TEX
, since repeated rewriting would loop.

=ENDDOC
=THDOC
req_thm(Û"ú_¼_clauses"İ, ([],
	¬µ i j k : ú·	(i + k ¼ j + k ¤ i ¼ j)
	 	±	(k + i ¼ j + k ¤ i ¼ j)
	 	±	(i + k ¼ k + j ¤ i ¼ j)
	 	±	(k + i ¼ k + j ¤ i ¼ j)
	 	±	(i + k ¼ k ¤ i ¼ 0)
	 	±	(k + i ¼ k ¤ i ¼ 0)
	 	±	(i ¼ k + i ¤ 0 ¼ k)
	 	±	(i ¼ i + k ¤ 0 ¼ k)
	 	±	i ¼ i
	 	±	³ 1 ¼ 0
	 	±	0 ¼ 1
®));
=DESCRIBE
Facts about ¼ of ubiquitous utility
=ENDDOC
=THDOC
req_thm(Û"ú_less_clauses"İ, ([],
	¬µ i j k : ú ·	(i + k < j + k ¤ i < j)
		±	(k + i < j + k ¤ i < j)
		±	(i + k < k + j ¤ i < j)
		±	(k + i < k + j ¤ i < j)
		±	(i + k < k ¤ i < 0)
		±	(k + i < k ¤ i < 0)
		±	(i < k + i ¤ 0 < k)
		±	(i < i + k ¤ 0 < k)
		±	³ i < i
		±	0 < 1
		±	³ 1 < 0
®));
=DESCRIBE
Facts about $<$ of ubiquitous utility
=ENDDOC
=THDOC
req_thm(Û"ú_³_¼_thm"İ, ([], ¬µ i j :  ú · ³ i ¼ j ¤ j < i®));
req_thm(Û"ú_³_less_thm"İ, ([], ¬µ i j :  ú · ³ i < j ¤ j ¼ i®));
=DESCRIBE
Facts about < of ubiquitous utility
=ENDDOC
=THDOC
req_thm(Û"ú_abs_thm"İ, ([],
	¬µ i : î · abs i = i ± abs ~ i = i®));
req_thm(Û"ú_abs_î_thm"İ, ([],
	¬µ i : ú · abs i  î®));
req_thm(Û"ú_abs_eq_0_thm"İ, ([],
	¬µ i : ú · abs i = 0 ¤ i = 0®));
req_thm(Û"ú_abs_minus_thm"İ, ([],
	¬µ i : ú · abs ~ i = abs i®));
req_thm(Û"ú_î_abs_minus_thm"İ, ([],
	¬µ i j :  î · j ¼ i ´ abs (i + ~ j) ¼ i®));
req_thm(Û"ú_abs_times_thm"İ, ([],
	¬µ i j :  ú · abs (i * j) = abs i * abs j®));
req_thm(Û"ú_abs_plus_thm"İ, ([],
	¬µ i j :  ú · abs (i + j) ¼ abs i + abs j®));
=DESCRIBE
Standard properties of the absolute value function. The last of these is
commonly known as the {\em triangle inequality}.
=ENDDOC
=THDOC
req_thm(Û"ú_div_mod_unique_thm"İ, ([],
	¬
	µ i, j, d, r : ú
		³ j = 0
	´		i = d * j + r ± 0 ¼ r ± r < abs j
		¤	d = i div j ± r = i mod j®));
=DESCRIBE
The defining property of the division and modulo operations characterises
those operations.
=ENDDOC
\section{START OF SIGNATURE}
=DOC
=DOC
signature Ûúİ = sig
=DESCRIBE
This provides the basic definitions proof support for the HOL
theory of integers.
It creates the theory $ú$.
=ENDDOC
\section{THEOREM BINDINGS}

=DOC
val Ûú__î_thmİ : THM;			val Ûú_³_¼_thmİ : THM;
val Ûú_³_î_thmİ : THM;			val Ûú_³_less_thmİ : THM;
val Ûú_¼_¼_0_thmİ : THM;			val Ûú_¼_antisym_thmİ : THM;
val Ûú_¼_cases_thmİ : THM;			val Ûú_¼_clausesİ : THM;
val Ûú_¼_less_trans_thmİ : THM;		val Ûú_¼_plus_î_thmİ : THM;
val Ûú_¼_refl_thmİ : THM;			val Ûú_¼_trans_thmİ : THM;
val Ûú_î_³_minus_thmİ : THM;		val Ûú_î_³_plus1_thmİ : THM;
val Ûú_î_abs_minus_thmİ : THM;		val Ûú_î_cases_thmİ : THM;
val Ûú_î_induction_thmİ : THM;		val Ûú_î_plus1_thmİ : THM;
val Ûú_î_plus_thmİ : THM;			val Ûú_î_thmİ : THM;
val Ûú_î_times_thmİ : THM;			val Ûú_ú_cases_thmİ : THM;
val Ûú_ú_cases_thm1İ : THM;		val Ûú_ú_eq_thmİ : THM;
val Ûú_ú_induction_thmİ : THM;		val Ûú_0_î_thmİ : THM;
val Ûú_abs_î_thmİ : THM;			val Ûú_abs_eq_0_thmİ : THM;
val Ûú_abs_minus_thmİ : THM;		val Ûú_abs_plus_thmİ : THM;
val Ûú_abs_thmİ : THM;			val Ûú_abs_times_thmİ : THM;
val Ûú_div_mod_unique_thmİ : THM;	val Ûú_int_homomorphism_thmİ : THM;
val Ûú_less_¼_trans_thmİ : THM;		val Ûú_less_clausesİ : THM;
val Ûú_less_irrefl_thmİ : THM;		val Ûú_less_trans_thmİ : THM;
val Ûú_minus_î_¼_thmİ : THM;		val Ûú_minus_clausesİ : THM;
val Ûú_minus_thmİ : THM;			val Ûú_minus_times_thmİ : THM;
val Ûú_plus0_thmİ : THM;			val Ûú_plus_assoc_thmİ : THM;
val Ûú_plus_assoc_thm1İ : THM;		val Ûú_plus_clausesİ : THM;
val Ûú_plus_comm_thmİ : THM;		val Ûú_plus_cyclic_group_thmİ : THM;
val Ûú_plus_minus_thmİ : THM;		val Ûú_plus_order_thmİ : THM;
val Ûú_times0_thmİ : THM;			val Ûú_times1_thmİ : THM;
val Ûú_times_assoc_thmİ : THM;		val Ûú_times_assoc_thm1İ : THM;
val Ûú_times_clausesİ : THM;		val Ûú_times_comm_thmİ : THM;
val Ûú_times_eq_0_thmİ : THM;		val Ûú_times_order_thmİ : THM;
val Ûú_times_plus_distrib_thmİ : THM;	val Ûú_¼_less_eq_thmİ : THM;
val Ûú_æ_thmİ : THM;				val Ûú_æ‰1_thmİ : THM;
val Ûú_æ_empty_thmİ : THM;
=DESCRIBE
These are the ML value bindings for the theorems saved in the theory
=INLINEFT
ú_numbers
=TEX
.
=ENDDOC

\section{DEFINITION BINDINGS}
=DOC
val Ûú_ú_defİ : THM;					val Ûú_î_defİ : THM;
val Ûú_arith_defİ : THM;				val Ûú_inequality_defİ : THM;
val Ûú_î‰1_defİ : THM;
=DESCRIBE
These are the ML bindings of the definitions of the theory $z\_numbers$.
=ENDDOC
\section{TACTICS}
=DOC
val Ûú_î_induction_tacİ : TACTIC
=DESCRIBE
This tactic implements induction over the natural numbers in Z:
to prove
=INLINEFT
x  î ´ t
=TEX
, it suffices to prove $t[0/x]$ and to prove $t[x+1/x]$ on the
assumption that $t$. The conclusion of the goal must have the
form
=INLINEFT
x  î ´ t
=TEX
.
=FRULE 2 Tactic
ú_î_induction_tac 
÷
{ ‡ } x  î ´ t 
÷
{ ‡ } t[0/x] ; strip{t, ‡} t[x+1/x]
=TEX
=SEEALSO
=INLINEFT
ú_ú_cases_thm
=TEX
,
=INLINEFT
ú_intro_µ_tac
=TEX
, 
=INLINEFT
ú_ú_induction_tac
=TEX
=FAILUREC
\paragraph{Errors} As for $gen\_induction\_tac1$.

=ENDDOC
=DOC
val Ûú_ú_induction_tacİ : TERM -> TACTIC
=DESCRIBE
An induction-like tactic for the integers, based on the fact that
any subset of the integers containing $1$ and closed under negation and
addition must contain every integer.
=FRULE 2 Tactic
ú_î_induction_tac ¬x®
÷
{ ‡ } t 
÷
{ ‡ } t[1/x] ;
strip{t[i/x], ‡} t[~i/x] ;
strip{t[i/x] ± t[j/x], ‡} t[i+j/x]
=TEX
=SEEALSO
=INLINEFT
ú_î_induction_tac
=TEX
,
=INLINEFT
ú_intro_µ_tac
=TEX
, 
=INLINEFT
ú_ú_cases_thm
=TEX
=FAILUREC
\paragraph{Errors} As for $gen\_induction\_tac$.

=ENDDOC
\section{SYNTAX FUNCTIONS}

=DOC
val dest_ú_¼ : TERM -> TERM * TERM;
val dest_ú_¾ : TERM -> TERM * TERM;
val dest_ú_abs : TERM -> TERM;
val dest_ú_div : TERM -> TERM * TERM;
val dest_ú_greater : TERM -> TERM * TERM;
val dest_ú_less : TERM -> TERM * TERM;
val dest_ú_minus : TERM -> TERM;
val dest_ú_mod : TERM -> TERM * TERM;
val dest_ú_plus : TERM -> TERM * TERM;
val dest_ú_signed_int : TERM -> int;
val dest_ú_subtract : TERM -> TERM * TERM;
val dest_ú_times : TERM -> TERM * TERM;
=DESCRIBE
These are derived destructor
functions for the Z basic arithmetic operations.
An optionally signed integer literal, $signed\_int$, is taken to be either a numeric
literal or the result of applying
=INLINEFT
(~_)
=TEX
\ to a numeric literal. The other constructors correspond directly
to the arithmetic operations of the theory $z\_numbers$ with alphabetic
names assigned to give valid ML name as needed
($greater: <$,
$less: >$,
=INLINEFT
minus: ~
=TEX
,
$plus: +$,
$subtract: -$,
$times: *$).

As usual, there are also corresponding discriminator ($is\_\ldots$) and
constructor functions ($dest\_\ldots$).
For programming convenience, $dest\_z\_signed\_int$ returns $0$  and
$mk\_z\_signed\_int$ returns $true$ when
applied to
=INLINEFT
~0
=TEX
, but $mk\_z\_signed\_int$ cannot be used to construct such a term.
=FAILURE
93101	?0 is not of the form ¬i ¼ j®
93102	?0 is not of the form ¬i ¾ j®
93103	?0 is not of the form ¬abs i®
93104	?0 is not of the form ¬i div j®
93105	?0 is not of the form ¬i > j®
93106	?0 is not of the form ¬i < j®
93107	?0 is not of the form ¬~i®
93108	?0 is not of the form ¬i mod j®
93109	?0 is not of the form ¬i + j®
93110	?0 is not an optionally signed integer literal
93111	?0 is not of the form ¬i - j®
93112	?0 is not of the form ¬i * j®
=ENDDOC

=DOC
val is_ú_¼ : TERM -> bool;
val is_ú_¾ : TERM -> bool;
val is_ú_abs : TERM -> bool;
val is_ú_div : TERM -> bool;
val is_ú_greater : TERM -> bool;
val is_ú_less : TERM -> bool;
val is_ú_minus : TERM -> bool;
val is_ú_mod : TERM -> bool;
val is_ú_plus : TERM -> bool;
val is_ú_signed_int : TERM -> bool;
val is_ú_subtract : TERM -> bool;
val is_ú_times : TERM -> bool;
=DESCRIBE
These are derived discriminator
functions for the Z basic arithmetic operations.
See the documentation for the destructor functions ($dest\_z\_plus$ etc.)
for more information.
=ENDDOC

=DOC
val mk_ú_¼ : TERM * TERM -> TERM;
val mk_ú_¾ : TERM * TERM -> TERM;
val mk_ú_abs : TERM -> TERM;
val mk_ú_div : TERM * TERM -> TERM;
val mk_ú_greater : TERM * TERM -> TERM;
val mk_ú_less : TERM * TERM -> TERM;
val mk_ú_minus : TERM -> TERM;
val mk_ú_mod : TERM * TERM -> TERM;
val mk_ú_plus : TERM * TERM -> TERM;
val mk_ú_signed_int : int -> TERM;
val mk_ú_subtract : TERM * TERM -> TERM;
val mk_ú_times : TERM * TERM -> TERM;
=DESCRIBE
These are derived constructor
functions for the Z basic arithmetic operations.
See the documentation for the destructor functions ($dest\_z\_plus$ etc.)
for more information.
=FAILURE
93201	?0 does not have type ú
=ENDDOC

\section{CONVERSIONS}
=DOC
val Ûú_î_plus_convİ : CONV;		val Ûú_î_times_convİ : CONV;

val Ûú_subtract_minus_convİ : CONV;	val Ûú_greater_less_convİ : CONV
val Ûú_¾_¼_convİ : CONV;			val Ûú__î_convİ : CONV;

val Ûú_plus_convİ : CONV;			val Ûú_times_convİ : CONV
val Ûú_abs_convİ : CONV;			val Ûú_div_convİ : CONV
val Ûú_mod_convİ : CONV;			val Ûú_¼_convİ : CONV
val Ûú_less_convİ : CONV			val Ûú_ú_eq_convİ : CONV
=DESCRIBE
These conversions are used to perform evaluation of arithmetic expressions involving
numeric literal operands. The normal interface to the conversion is
via the proof context $'z\_numbers$ and other proof contexts which contain
it.

The first block above gives conversions to evaluate
expressions of the form $i\,op\,j$ where
$i$ and $j$ are numeric literals and $op$ is one of $+$ or $*$.
The second block gives conversions to transform terms of the form
$i\,-\,j$, $i\,>\,j$, $i\,>\,j$ and $i\,\,î$ into
=INLINEFT
i + ~j
=TEX
, \ $j\,<\,i$, $j\,¼\,i$ and $0\,¼\,i$
respectively. The third block give conversions which evaluate
expressions of the form $i\,op\,j$ or $abs\,i$, where $op$ is
one of $+$, $*$, $div$, $mod$, $¼$, $<$, or $=$, and where $i$
and $j$ are signed integer literals (i.e., either numeric literals or of the form
=INLINEFT
~k
=TEX
, where $k$ is a numeric literal).
Thus the second block of conversions transform expressions
of the form $i\,-\,j$, $i\,>\,j$, $i\,¾\,j$ and $i\,\,î$ into a form which
can be evaluated by the conversions in the third block if $i$ and $j$ are
signed literals.

=FAILURE
93301	?0 is not of the form ?1 where ¬i® and ¬j® are numeric literals
93302	?0 is not of the form ?1
93303	?0 is not of the form ?1 where ¬i® and ¬j® are optionally signed
	numeric literals
=ENDDOC
=DOC
val Ûú_dots_convİ : CONV;
val Ûú__dots_convİ : CONV;
=DESCRIBE
The first of these two conversions simplifies certain $dots$
terms, 
the second, given a membership of a $dodts$ expression,
first tries the simplifications, and
whether or not that succeeds, expands the membership.
=FRULE 1 Conversion
ú_dots_conv
¬x .. x®
÷
÷
ô (x .. x) = {x}
=TEX
and
=FRULE 1 Conversion
ú_dots_conv
¬n1 .. n2®
÷
÷
ô (n1 .. n2) = {}
=TEX
where $n1$ is a numeric literal less than the numeric literal $n2$.

=FRULE 1 Conversion
ú__dots_conv
¬x  y .. y®
÷
÷
ô x  y .. y ¤ x = y
=TEX
=FRULE 1 Conversion
ú__dots_conv
¬x  n1 .. n2®
÷
÷
ô x  n1 .. n2 ¤ false
=TEX
where $n1$ is a numeric literal less than the numeric literal $n2$.
=FRULE 1 Conversion
ú__dots_conv
¬x  low .. high®
÷
÷
ô x  low .. high ¤ low ¼ x ± x ¼ high
=TEX
=FAILURE
93001	?0 is not of the form: ¬low .. high® where the 
	expresion can be simplified
93002	?0 is not of the form: ¬x  low .. high®
=ENDDOC
\section{PROOF CONTEXTS}
=DOC
(* Proof Context: Û'ú_numbersİ *)
=DESCRIBE
A component proof context for handling the basic arithmetic operations
for Z. 

Expressions and predicates treated by this proof context are constructs formed from:
=GFT
+, *, -, abs, div, mod, ú, ¼, <, ¾, >, =, î
=TEX

\paragraph{Contents}\ 

Rewriting:
=GFT
ú_plus_conv, ú_times_conv, ú_subtract_minus_conv
ú_abs_conv, ú_div_conv, ú_mod_conv
ú_ú_eq_conv, ú_¼_conv, ú_less_conv
ú_¾_¼_conv, ú_greater_less_conv, ú__î_conv
ú_plus_clauses, ú_minus_clauses, ú_¼_clauses
ú_less_clauses, ú_³_¼_thm, ú_³_less_thm, 
ú__î‰1_thm, ú_dots_conv, ú__dots_conv
=TEX
Stripping theorems:
=GFT
ú_ú_eq_conv, ú_¼_conv, ú_less_conv
ú_¾_¼_conv, ú_greater_less_conv, ú__î_conv
ú_plus_clauses, ú_minus_clauses, ú_¼_clauses
ú_less_clauses, ú__î‰1_thm, ú__dots_conv
and all the above pushed through ³

ú_³_¼_thm, ú_³_less_thm, ú_¼_conv, ú_less_conv
=TEX

Stripping conclusions: as for stripping theorems.

Rewriting canonicalisation: blank.

$U$-simplification:
=GFT
ô ú = U
=TEX
Automatic proof procedures: $z\-\_basic\-\_prove\-\_tac$,
$z\-\_basic\-\_prove\-\_conv$.

Automatic existence prover: blank.
=ENDDOC
Should evaluable arithmetic expressions on one or both sides of a stripped equation
be evaluated during stripping?
\section{EPILOGUE}
=SML
end (* of signature ú *);
=SML
=TEX

\section{TEST POLICY}
The module tests for this module are to follow the guidelines
laid down in the quality plan~\cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
