% dtd005.doc %Z% $Date$ $Revision$ $RCSfile$

=TEX
% dtd005.doc %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol,11pt,TQ]{article}

\TPPtitle{File and Terminal Reader Writer}
\TPPref{DS/FMU/IED/DTD005}
\TPPissue{$Revision$%
}

\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{IED 1563}

=IGN

Commands to process this document in various ways.

doc4tex dtd005
tex4dvi dtd005
bibtex dtd005
doc4tex dtd005 ; tex4dvi dtd005
pstex dtd005

lasp -s dtd005.doc > zz1
lasp -s -u dtd005.OKwords dtd005.doc > zz1

=TEX
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Standard}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the detailed design for the reading
	and writing functions that form the outermost level of user
	interface for Release~1 of ICL~HOL.  These functions are
	concerned with the differentiation of the various languages
	(initially Standard~ML and HOL), and the extensions to support
	pretty characters in Standard~ML identifiers and in strings.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

%\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage
\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [1 February 1991, issue 1.1 ]  First draft version, providing a
	place holder pending the creation of the proper document.

\item[21 February 1991, issue 1.2 ]  Added some extra details.

\item[6 March 1991, issue 1.3 ]  Add structures $ReaderWriterSupport$
	and $HOLReaderWriter$, and details of error messages.

\item[28 March 1991, issue 1.4 ]  Extensions to the narrative.
	Changes to details.

\end{description}
%\subsection{Changes forecast}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\newpage

\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains a detailed design of the file and terminal
reading and writing functions, called for by~\cite{DS/FMU/IED/DEF002}
which discusses the lexical nature of the Release 1 ICL HOL.  The
design is implemented in \cite{DS/FMU/IED/IMP005}.

%********************************************************************

\subsection{Introduction}

The `basic reader writer' of the Release 1 ICL HOL system supports an
extension to Standard~ML that allows `pretty characters' to be used in
Standard~ML text; in particular, in Standard~ML identifiers and
strings.  This interface is provided by three functions, see
section~\ref{PrimaryUserInterface}, which allow the enhanced ML text to
be read from the terminal, from a named text file, or from a
Standard~ML string.

A second part of the basic reader writer, the `embedding interface',
allows readers for other languages to be embedded, allowing the
(enhanced) Standard~ML to be used as a metalanguage for supporting work
in other languages.  Part of the embedding interface provides for
characters in the users source text to switch between languages, text
in an embedded language is treated as a Standard~ML string that is
passed as an argument to a language specific analysis routine ---
typically for lexical analysis, parsing, etc.

Within this document a reader writer for the HOL language is detailed,
it is added to the basic reader writer using the embedding interface.
Supporting the HOL language is a primary goal of the whole system,
within the reader writer it serves as a guide for the technique for
embedding other languages.

%--------------------------------------------------------------------

%\subsubsection{Purpose and Background}

%A brief description of the purpose of the objects defined in the
%document.  The high level design document for the detailed design
%should be referenced here.

%--------------------------------------------------------------------

%\subsubsection{Dependencies}

%An indication on which other documents  this document is dependent on.

%--------------------------------------------------------------------

%\subsubsection{Interface}

%A brief explanation of the external interface presented by the
%document.  This should identify the signatures defined in the
%document.

%--------------------------------------------------------------------

%\subsubsection{Possible Enhancements}

%A discussion of ways the facilities offered by the document might be
%improved.

%--------------------------------------------------------------------

%\subsubsection{Deficiencies}

%An indication of any shortcomings in the facilities offered by the
%document.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{BASIC READER WRITER}

%--------------------------------------------------------------------
=DOC
signature ‚ReaderWriter· = sig
=DESCRIBE
File and terminal reading and writing functions.
=FAILURE
5001	End of file found in comment
5002	Unexpected symbol `?0` (a symbol of type $Invalid$ has been read)
5003	Unknown keyword `?0`
5004	Unknown pretty character `?0` (decimal ?1)
5005	Bracket mismatch.  `?0` found after an opening `?1`
5007	End of file found in string
5014	No closing `%` after keyword: `?0`
5017	Unknown keyword starting with: ?0
5018	Pretty characters passed to ML compiler in: `?0`
=IGN
Spare error codes
5012	Character literal is empty or too long
5013	Character literal unexpected character `?0` after `\^`
5019--5999
=FAILUREC
Several error messages are provided to report faults in the users
textual input to the ICL HOL system, they may be produced from all of
the routines $usefile$, $usestring$ and $useterminal$.  Some error
messages might be associated with particular routines in the reader
writer support $ReaderWriterSupport$ structure but that is incidental
to most users, so they are all gathered here.
=ENDDOC

%********************************************************************

\subsection{Primary User Interface} \label{PrimaryUserInterface}

%--------------------------------------------------------------------
=DOC
val ‚usefile· : string -> unit;
=DESCRIBE
Read Standard~ML with pretty characters allowed, from the named file.
=SEEALSO
Error messages given with signature for $ReaderWriter$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚usestring· : string -> unit;
=DESCRIBE
Read Standard~ML with pretty characters allowed, from the given string.
=SEEALSO
Error messages given with signature for $ReaderWriter$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚useterminal· : unit -> unit;
=DESCRIBE
Read Standard~ML with pretty characters allowed, from the terminal.
This routine takes over the terminal, it handles all exceptions as the
outermost level of the ML system.  To return to the default PolyML
terminal reader use $abandon_reader_writer$.

This routine prompts to the conventions of PolyML but uses the strings
``{\tt:>~}'' and ``{\tt:>~}'', the PolyML prompts do not have the
colon.

Typing control-D, or reading the end-of-file, causes the function
$PolyML.quit$ to be called.

Typing control-X to this routine (when it is looking for input)
abandons the current {\em topdec.}
=SEEALSO
Error messages given with signature for $ReaderWriter$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚abandon_reader_writer· : unit -> unit;
=DESCRIBE
Only meaningfully used after $useterminal$ has been called, when it
forces an exit from that routine.
=ENDDOC
%--------------------------------------------------------------------

%********************************************************************

\subsection{Supporting Other Languages}

A large part of the reader writer interface allows the embedding
of other languages.

The style of the interface should\footnote{To be done, perhaps as a new
document describing how to embed new languages.  Most of the required
information is contained within the implementation
document~\cite{DS/FMU/IED/IMP005}, but it is too bulky to be placed in
this document.} be documented.  The descriptions that follow assume
that such a description has been seen by the reader of this document.

Many routines have an argument of type $READER_ENV$ which provides the
functions to read characters from the current input stream.  This
argument is not detailed with each function, but a reference to the
type declaration is made.

%--------------------------------------------------------------------
=DOC
structure ‚ReaderWriterSupport· : sig
=DESCRIBE
A set of declarations that allows the addition of new embedded
languages.  The HOL language is an example of a language embedded into
a basic system that understands Standard~ML with pretty characters and
percent keywords.
=ENDDOC
%--------------------------------------------------------------------
=DOC
type ‚READER_ENV·;
=DESCRIBE
All of the parsing functions in the reader writer support use the functions
provided in this record type to read characters from the current input stream.
Attempting to read characters by any other method will have unpredictable
results.
=ENDDOC
%--------------------------------------------------------------------
=DOC
structure ‚PrettyNames· : sig
=DESCRIBE
A structure within $ReaderWriterSupport$ that gathers all the
information relating the pretty characters and percent keywords
understood by the system, together with the interfaces for
interrogating and extending the information.
=ENDDOC
%--------------------------------------------------------------------
=DOC
	datatype ‚NAME_CLASS·
		=	‚Simple·
		|	‚Starting·	of (READER_ENV -> string list -> string list)
						* string * string
		|	‚Middle·	of string
		|	‚Ending·	of string * string
		|	‚Ignore·
		|	‚Invalid·;
=DESCRIBE
These detail the characteristics of a symbol.  $Simple$ is used for
symbols that may be part of identifiers.  $Starting$, $Middle$ and $Ending$
relate to the symbols position when embedding text of other languages.
The symbol is effectively macro expanded to produce the string value of these
three constructors.  The function with $Starting$ is the reader routine for
the particular embedded language.  Details of how this function should be
written are given in the implementation document corresponding to this
design.  $Ignore$ is used for characters that are completely ignored in the
input, the pretty characters for indexing come in this category.  $Invalid$
will cause an error message.
=SEEALSO
Error 5002
=ENDDOC
%--------------------------------------------------------------------
=DOC
	type ‚PRETTY_NAME·;
=DESCRIBE
Each symbol is defined in a three-element tuple of this type.  Elements
of the tuple are as follows.  First, a non-empty list of the keywords
that may used for this symbol, the preferred keyword is at the head of
the list.  These keywords exclude the enclosing percent signs.
Second, an optional pretty character
for the symbol.  Third:  a value of datatype $NAME_CLASS$ indicating
the characteristics of the symbol.
=SEEALSO
Function $add_new_symbols$, for details of the validation of values
of this type.
=EXAMPLE
	([	"fn",
		"lambda"],	Value "ç",			Simple),
=ENDDOC
%--------------------------------------------------------------------
=DOC
	val ‚add_new_symbols· : PRETTY_NAME list -> unit;
=DESCRIBE
Adds details of new symbols to the data structures characterising all
known symbols.  There is some validation of the symbols added, the list
of names should not be empty, the individual names should not be a
single ``{\tt Q}'', should not contain two adjacent ``{\tt Q}''s, and
the pretty character field should have
a single character with value greater than decimal~127.
=FAILURE
5006	Keyword `?0` has single `Q` or has adjacent `Q`s
5015	Empty keyword list
5016	Invalid pretty character with keyword: ?0
=ENDDOC
%--------------------------------------------------------------------
=DOC
	val ‚find_name· : string -> PRETTY_NAME OPT
	val ‚find_char· : string -> PRETTY_NAME OPT

end (* of signature for structure PrettyNames *)
=DESCRIBE
Finds the characteristics of a symbol based on its keyword or character.
Both functions return $Nil$ if the symbol is not known.  They return
the tuple given to $add_new_symbols$ for known symbols.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚skip_comment· : READER_ENV -> unit;
=DESCRIBE
Skip over a comment which comprises a sequence of characters within
which the comment braces `{\tt (*}' and `{\tt *)}' are properly
balanced.  This routine is entered when the opening round bracket of
the comment has been read, the opening asterisk is the first unread
character.
=FAILURE
5001	End of file found in comment
=SEEALSO
Type $READER_ENV$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚skip_format· : (READER_ENV -> string list -> string list)
		-> READER_ENV -> string list -> string -> string list;
=DESCRIBE
Read and discard any formatting characters in the initial part of the
input and replace them with a single space.  When a non-formatting
character is found continue by calling the parsing routine given as the
first argument.  The third argument is the left hand context which
must be passed on.  The fourth argument, the string, is required to be
the first unread character of the current input.  The result is the
concatenation of the left hand context, a space, and the results from
calling the first argument.
=SEEALSO
Type $READER_ENV$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚get_ML_string· : READER_ENV -> string list -> string list;
val ‚get_primed_string· : READER_ENV -> string list -> string list;
=DESCRIBE
Assemble a string literal and add it to the left hand context given in the
second argument.  On entry the opening string quote has been read, exit
when the closing string quote has been read.  The goal of this routine
is to form an equivalent string that can be read by a Standard~ML
compiler, and to defer as much validation of the string as possible to
that compiler.  Minimal validation is performed on escape sequences.
Well-formed layout sequences (i.e., the sequence ``{\hbox{\verb|\|{\em
f..f\/}\verb|\|}}'' from~\cite[section~2.2, page~3]{Milner90}) are
removed, characters not recognised as formatting ones are retained and
wrapped between ``\verb|\ |'' and ``\verb| \|'' for later checking by
the Standard~ML compiler.  Pretty characters are translated to their
three digit decimal form.

Function $get_ML_string$ reads a string as specified
in~\cite[section~2.2, page~3]{Milner90}

Function $get_primed_string$ reads a string enclosed with single
left-hand primes~(~{\tt`}~).  These are as in~\cite[section~2.2,
page~3]{Milner90} but with the meanings of the single~(~{\tt`}~) and
double~(~{\tt"}~) prime characters interchanged.
=FAILURE
5007	End of file found in string
5010	Character code of ?0 is too big
=SEEALSO
Type $READER_ENV$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚get_percent_name· : READER_ENV
	-> (string * PrettyNames.PRETTY_NAME OPT * bool * string);
=DESCRIBE
Assemble a percent keyword and look it up in the list of known
keywords.  On entry the percent ({\tt\%}) is the first unread
character. The tuple returned contains:
(1) the keyword read, but without the {\tt\%} character;
(2) the symbols entry as given to $add_new_symbols$ or $Nil$ for
	an unknown keyword;
(3) a flag set true if the keyword was alphanumeric, false otherwise;
(4) if the keyword is well-formed (i.e., has a trailing percent
	({\tt\%}) as expected) then the empty string, else text to be
	included in the generated string which is based on the warning
	message given.
Non-alphanumeric keywords may contain the characters
``\verb"!  &  $  #  +  -  /  :  <  =  >  ?  @  \  ~  '  ^  |  *"''
which are the same as in~\cite[section~2.4, page~4]{Milner90} apart
from the omission of the {\tt\%} character.
=FAILURE
5014	No closing `%` after keyword: `?0`
=SEEALSO
Type $PRETTY_NAME$.
Type $READER_ENV$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚get_box_braces· : (READER_ENV -> string list -> string list)
		-> READER_ENV -> string list -> string list;
val ‚get_curly_braces· : (READER_ENV -> string list -> string list)
		-> READER_ENV -> string list -> string list;
val ‚get_round_braces· : (READER_ENV -> string list -> string list)
		-> READER_ENV -> string list -> string list;
=DESCRIBE
These functions assemble a section of bracketed text.  The opening
bracket has been read, the first unread character is the first
character within the brackets.  Each routine reads text upto and
including the matching closing bracket.  The first argument is the
parsing routine for reading items of text within the brackets.  The
third argument is the left hand context, which is returned with the
bracketed text read by these functions, and the enclosing braces.  The
three pairs of brackets: ``\verb|[ ]|'', ``\verb|{ }|'' and ``\verb|(
)|'' are handled by functions $get_box_braces$, $get_curly_braces$ and
$get_round_braces$ respectively.
=FAILURE
5005	Bracket mismatch.  `?0` found after an opening `?1`
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚get_ML_any· : READER_ENV -> string list -> string list
=DESCRIBE
Assemble a section of Standard~ML text starting with the first unread
character.  Text is read upto the first semi colon `{\tt;}' or
unmatched closing bracket.  A semi colon will be read and added to the
returned text, a closing bracket is left unread for the calling
routine.  The syntax error where too many closing bracket are presented
must be resolved by the outermost routine that calls function.  The
second argument gives the left hand context, the new text read is added
to that context and returned.
=FAILURE
5002	Unexpected symbol `?0` (a symbol of type $Invalid$ has been read)
5003	Unknown keyword `?0`
5004	Unknown pretty character `?0` (decimal ?1)
=SEEALSO
Type $READER_ENV$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
exception ‚EndOfInput·;
=DESCRIBE
Associated with the reader functions is the exception $EndOfInput$
which is raised when the parser has read the end of the file and
has passed the end of file character at least once to the compiler.
Raising this exception signifies that nothing more can usefully be
done with the current input stream.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚string_of_int3· : int -> string
=DESCRIBE
The string representation of small positive integers is needed in
various places, particularly within Standard~ML strings where some
characters are denoted by their decimal code in three digits, preceded
by a backslash.  Function $string_of_int3$ gives a three character with
leading zeros representation of small positive numbers.  In general the
routine $PolyML.makestring$ cannot be used, if the value last passed to
of $PolyML.print_depth$ is zero then $PolyML.makestring$ converts
numbers into three dots.
=FAILURE
5010	Character code of ?0 is too big
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚to_ML_string· : string -> string
=DESCRIBE
Converts any string into a another string which may be read by a
Standard~ML compiler and has the same meaning.  This is intended to
form the string representation of pretty characters for passing them
through to a Standard~ML compiler.  Characters other than space, tab
and newline which are outside the range~32 to~126 (decimal) inclusive
are converted to their four character equivalent of a backslash
followed by a three digit decimal number with leading zeroes.
=ENDDOC
%--------------------------------------------------------------------


%--------------------------------------------------------------------
=SML
end (* of signature for structure ReaderWriterSupport *)
end (* of signature ReaderWriter *);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{HOL READER WRITER}

%--------------------------------------------------------------------
=DOC
signature ‚HOLReaderWriter· = sig
end;
=DESCRIBE
There are no visible declarations in this structure, its purpose is to
add new entries to the structure that holds all the information
relating the symbols for pretty characters and percent keywords
understood by the system, together with the functions that understand
how to read HOL text.
=FAILUREC
All the errors that the basic reader writer may raise may also be raised
by the HOL reader writer.
=FAILURE
5008	Unknown keyword `?0` in anti quotation
5009	Unexpected `?0` at start of anti quotation
5011	Empty anti quotation, from `^(*`
=ENDDOC
%--------------------------------------------------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
