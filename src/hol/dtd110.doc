% dtd005.doc %Z% $Date$ $Revision$ $RCSfile$

=TEX
% dtd005.doc %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol,11pt,TQ]{article}

\TPPtitle{File and Terminal Reader Writer}
\TPPref{DS/FMU/IED/DTD005}
\TPPissue{$Revision$%
}

\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{IED 1563}

=IGN

Commands to process this document in various ways.

doc4tex dtd005
tex4dvi dtd005
bibtex dtd005
doc4tex dtd005 ; tex4dvi dtd005
pstex dtd005

lasp -s dtd005.doc > zz1
lasp -s -u dtd005.OKwords dtd005.doc > zz1

=TEX
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Standard}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the detailed design for the reading
	and writing functions that form the outermost level of user
	interface for Release~1 of ICL~HOL.  These functions are
	concerned with the differentiation of the various languages
	(initially Standard~ML and HOL), and the extensions to support
	pretty characters in Standard~ML identifiers and in strings.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

%\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage
\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [1 February 1991, issue 1.1 ]  First draft version, providing a
	place holder pending the creation of the proper document.

\item[21 February 1991, issue 1.2 ]  Added some extra details.

\item[6 March 1991, issue 1.3 ]  Add structures $ReaderWriterSupport$
	and $HOLReaderWriter$, and details of error messages.

\item[28 March 1991, issue 1.4 ]  Extensions to the narrative.
	Changes to details.

\item[14 May 1991, issue 1.5 ]  Extensive changes.  New form of
	quotation of other languages.  More extensive documentation of
	the interfaces.

\item[17 May, issue 1.7 ] Add function $ask_at_terminal$.

\end{description}
%\subsection{Changes forecast}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\newpage

\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains a detailed design of the file and terminal
reading and writing functions, called for by~\cite{DS/FMU/IED/DEF002}
which discusses the lexical nature of the Release 1 ICL HOL.  The
design is implemented in \cite{DS/FMU/IED/IMP005}.

%********************************************************************

\subsection{Introduction}

The `basic reader writer' of the Release 1 ICL HOL system supports an
extension to Standard~ML that allows `pretty characters' to be used in
Standard~ML text; in particular, in Standard~ML identifiers and
strings.  This interface is provided by three functions, see
section~\ref{PrimaryUserInterface}, which allow the enhanced ML text to
be read from the terminal, from a named text file, or from a
Standard~ML string.

A second part of the basic reader writer, the `embedding interface',
allows readers for other languages to be embedded, allowing the
(enhanced) Standard~ML to be used as a metalanguage for supporting work
in other languages.  Part of the embedding interface provides for
characters in the users source text to switch between languages, text
in an embedded language is treated as a Standard~ML string that is
passed as an argument to a language specific analysis routine ---
typically for lexical analysis, parsing, etc.

Within this document a reader writer for the HOL language is detailed,
it is added to the basic reader writer using the embedding interface.
Supporting the HOL language is a primary goal of the whole system,
within the reader writer it serves as a guide for the technique for
embedding other languages.

%--------------------------------------------------------------------

\subsubsection{Purpose and Background}

Some extensions to Standard~ML are given in~\cite{DS/FMU/IED/DEF002}
where they are described in terms of ``macro processing'' of the
extended Standard~ML to form Standard~ML.  The extensions are as
follows.

\begin{itemize}

\item An extended character set.  Many of the new characters may be
	used in ML identifiers, all may be used in strings.

\item Keywords enclosed in percent `{\tt\%}' signs may be used as
	equivalents for any of the extended characters.  Additional
	keywords are supported to provide access to many of the
	characters supported by \LaTeX{} to give flexibility in the
	form of a documents printed output.

\item Standard~ML programs may be read as extended Standard~ML {\em
	provided\/} all percent `{\tt\%}' signs in the original program
	are replaced by two adjacent percent signs.

\item Other languages may be embedded in the extended Standard~ML text,
	their text is surrounded by the appropriate language embedding
	symbols (i.e., by the extended characters or their equivalent
	keywords).

\end{itemize}

%--------------------------------------------------------------------

%\subsubsection{Dependencies}

%An indication on which other documents  this document is dependent on.

%--------------------------------------------------------------------

%\subsubsection{Interface}

%A brief explanation of the external interface presented by the
%document.  This should identify the signatures defined in the
%document.

%--------------------------------------------------------------------

\subsubsection{Possible Enhancements}

A journaling system that records all inputs and/or outputs
into a named file.

%--------------------------------------------------------------------

%\subsubsection{Deficiencies}

%An indication of any shortcomings in the facilities offered by the
%document.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{BASIC READER WRITER}

The basic reader writer offers a small number of interfaces, basically
those for directing the ICL~HOL to its source text.  Additional
interfaces are provided in the support structure for embedding
additional languages.

%--------------------------------------------------------------------
=DOC
signature ‚ReaderWriter· = sig
=DESCRIBE
File and terminal reading and writing functions.
=FAILURE
5001	End of file found in comment
5002	End of file found in string
5003	Unknown keyword `?0` after `?1`
5004	Unknown keyword `?0`
5005	Unknown extended character `?0` (decimal ?1) after `?2`
5006	Unknown extended character `?0` (decimal ?1)
5007	Unexpected symbol `?0` (a symbol of type $Invalid$ has been read)
5008	Bracket mismatch, `?0` found after an opening `?1`
5009	Output of unknown keyword that starts with ?0
5010	Unknown language requested by symbol `?0` with language name `?1`
5011	Unknown language requested
=IGN
Spare error codes
5014-5029
5033-5039
5041-5049
5051-5099
5102-5999
=FAILUREC
Several error messages are provided to report faults in the users
textual input to the ICL HOL system, they may be produced from all of
the routines $usefile$, $usestring$ and $useterminal$.  Some error
messages might be associated with particular routines in the reader
writer support $ReaderWriterSupport$ structure but that is incidental
to most users, so they are all gathered here.
=ENDDOC

%********************************************************************

\subsection{Primary User Interface} \label{PrimaryUserInterface}

%--------------------------------------------------------------------
=DOC
val ‚usefile· : string -> unit;
=DESCRIBE
Read Standard~ML with pretty characters allowed, from the named file.
If the file does not exist then the it will read the file with the
given name and suffix ``{\tt.ML}'', if that file does not exist it will
try the suffix ``{\tt.sml}''.
=SEEALSO
Error messages given with signature for $ReaderWriter$.
Flag $usefile_non_stop_mode$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚usestring· : string -> unit;
=DESCRIBE
Read Standard~ML with pretty characters allowed, from the given string.
=SEEALSO
Error messages given with signature for $ReaderWriter$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚useterminal· : unit -> unit;
=DESCRIBE
Read Standard~ML with pretty characters allowed, from the terminal.
This routine takes over the terminal, it handles all exceptions as the
outermost level of the ML system.  To return to the default PolyML
terminal reader use $abandon_reader_writer$.

This routine prompts to the conventions of PolyML but uses the strings
``{\tt:>~}'' and ``{\tt:>~}'', the PolyML prompts do not have the
colon.

Typing control-D, or reading the end-of-file, causes the function
$PolyML.quit$ to be called.

Typing control-X to this routine (when it is looking for input)
abandons the current {\em topdec.}
=SEEALSO
Error messages given with signature for $ReaderWriter$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚abandon_reader_writer· : unit -> unit;
=DESCRIBE
Only meaningfully used after $useterminal$ has been called, when it
forces an exit from that routine.
=ENDDOC
%--------------------------------------------------------------------
=DOC
(* ‚usefile_non_stop_mode·  - boolean flag declared by new_flag, default: false *)
=DESCRIBE
Makes $usefile$ continue reading text (if the flag is true) or stop
reading (if false) from the file after an error is reported.  Default
is to stop reading.
=ENDDOC
%--------------------------------------------------------------------
=DOC
(* ‚writer_convert·  - boolean flag declared by new_flag, default: true *)
=DESCRIBE
Controls whether the reader writer makes any changes to the text output
from the PolyML compiler.  This control is similar but not the same as
that required when running Release 1 ICL HOL on a glass teletype ---
the controls for that mode are not yet available.
=ENDDOC
%--------------------------------------------------------------------
=DOC
(* ‚RWchars_read·  - boolean flag declared by new_flag, default: false *)
(* ‚RWchars_written·  - boolean flag declared by new_flag, default: false *)
(* ‚RWphrases_read·  - boolean flag declared by new_flag, default: false *)
(* ‚RWtext_read·  - boolean flag declared by new_flag, default: false *)
=DESCRIBE
Flags declared by the reader writer for debugging purposes.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚ask_at_terminal· : string -> string;
=DESCRIBE
Asks a question at the terminal by writing out the given string then
reading a single line of text which is returned.

Any characters in the type ahead buffer of the terminal input stream
are read and saved for later analysis by the normal reading functions
before the prompt is output and the response is read.

This function uses the PolyML function $ExtendedIO.can_input$ to
determine how many characters are available in the type ahead buffer,
they are read.  It next outputs the prompt, and finally makes a single
call of $ExtendedIO.input_line$.
=FAILURE
5012	Function `useterminal` is not active
5013	Input stream is not a terminal, nothing read
=ENDDOC
%--------------------------------------------------------------------

=SML
end (* of signature ReaderWriter *);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{SUPPORTING OTHER LANGUAGES}

A large part of the reader writer interface allows the embedding
of other languages.

The style of the interface should\footnote{To be done, perhaps as a new
document describing how to embed new languages.  Most of the required
information is contained within the implementation
document~\cite{DS/FMU/IED/IMP005}, but it is too bulky to be placed in
this document.} be documented.  The descriptions that follow assume
that such a description has been seen by the reader of this document.

Many routines have an argument of type $READER_ENV$ which provides the
functions to read characters from the current input stream.  This
argument is not detailed with each function, but a reference to the
type declaration is made.

%--------------------------------------------------------------------
=DOC
signature ‚ReaderWriterSupport· = sig
=DESCRIBE
A set of declarations that allows the addition of new embedded
languages.  The HOL language is an example of a language embedded into
a basic system that understands Standard~ML with pretty characters and
percent keywords.
=ENDDOC

\subsection{Diagnostic Support}

Reader function should avoid producing fault messages, where possible
they should be left to the language recogniser to report.  Some faults
can only be reported by reader functions, for these cases the following
functions are available.

In general a fault is reported by calling either $local_error$ or
$local_warn$ and adding details of the error code to the text produced
and continuing.  In the macro processing analogy a short fault report
is written into the macro processors output at the place of detection
of an error.  Functions $add_error_code$ and $add_error_codes$ are
provided to give a uniform style for these short reports.

%--------------------------------------------------------------------
=DOC
val ‚local_error· : string -> int -> (unit -> string) list -> unit;
val ‚local_warn· : string -> int -> (unit -> string) list -> unit;
=DESCRIBE
An error or warning message is written to the standard output, then the
function returns.  The arguments are identical in form to functions
$error$ and $fail$ of~\cite{DS/FMU/IED/DTD002}.
=SEEALSO
Functions $error$ and $fail$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚add_error_code· : int * string list -> string list;
val ‚add_error_codes· : int list * string list -> string list;
=DESCRIBE
For each error number ``$nn$'' given as the first argument an
entry of the form ``\verb*| ERROR__|$nn$\verb*| |'' is added
to the head of the second argument.
=ENDDOC
%--------------------------------------------------------------------

\subsection{Character Input --- Part 1}

%--------------------------------------------------------------------
=DOC
type ‚READER_ENV· (* = {
	‚advance·			: unit -> string,
	‚look_at_next·			: unit -> string,
	‚skip_and_look_at_next·	: unit -> string
} *) ;
=DESCRIBE
All of the parsing functions in the reader writer support use the
functions provided in this record type to read characters from the
current input stream.  Attempting to read characters by any other
method will have unpredictable results.
=ENDDOC
%--------------------------------------------------------------------
=DOC
exception ‚EndOfInput·;
=DESCRIBE
Associated with the reader functions is the exception $EndOfInput$
which is raised when the parser has read the end of the file and
has passed the end of file character at least once to the compiler.
Raising this exception signifies that nothing more can usefully be
done with the current input stream.
=ENDDOC
%--------------------------------------------------------------------

\subsection{Data Base of Keywords and Extended Characters}

%--------------------------------------------------------------------
=DOC
structure ‚PrettyNames· : sig
=DESCRIBE
A structure within $ReaderWriterSupport$ that gathers all the
information relating the pretty characters and percent keywords
understood by the system, together with the interfaces for
interrogating and extending the information.
=ENDDOC
%--------------------------------------------------------------------
=DOC
	datatype ‚NAME_CLASS·
		=	‚Simple·
		|	‚Starting·	of (READER_ENV -> (string * bool)
						-> string -> bool -> string list
						-> string list) * string
		|	‚Middle·	of string
		|	‚Ending·	of string
		|	‚Ignore·
		|	‚Invalid·;
=DESCRIBE
These detail the characteristics of a symbol.  $Simple$ is used for
symbols that may be part of identifiers.  $Starting$, $Middle$ and $Ending$
relate to the symbols position when embedding text of other languages.
The function with $Starting$ is the reader routine for
the particular embedded language.  Details of how this function should be
written (and of it arguments) are given in the implementation document
corresponding to this
design.  $Ignore$ is used for characters that are completely ignored in the
input, the pretty characters for indexing come in this category.  $Invalid$
will cause an error message.
=SEEALSO
Error 5007
=ENDDOC
%--------------------------------------------------------------------
=DOC
	type ‚PRETTY_NAME· (* = ( string list * string OPT * NAME_CLASS )  *)  ;
=DESCRIBE
Each symbol is defined in a three-element tuple of this type.  Elements
of the tuple are as follows.  First, a non-empty list of the keywords
that may used for this symbol, the preferred keyword is at the head of
the list.  These keywords exclude the enclosing percent signs.
Second, an optional pretty character
for the symbol.  Third:  a value of datatype $NAME_CLASS$ indicating
the characteristics of the symbol.
=SEEALSO
Function $add_new_symbols$, for details of the validation of values
of this type.
=EXAMPLE
	([	"fn",
		"lambda"],	Value "ç",			Simple),
=ENDDOC
%--------------------------------------------------------------------
=DOC
	val ‚add_new_symbols· : PRETTY_NAME list -> unit;
=DESCRIBE
Adds details of new symbols to the data structures characterising all
known symbols.  There is some validation of the symbols added, the list
of names should not be empty, the individual names should not be a
single ``{\tt Q}'', should not contain two adjacent ``{\tt Q}''s, and
the pretty character field should have
a single character with value greater than decimal~127.
=FAILURE
5100	Keyword `?0` has single `Q` or has adjacent `Q`s
5101	Empty keyword list
5102	Invalid pretty character with keyword ?0
=ENDDOC
%--------------------------------------------------------------------
=DOC
	val ‚find_name· : string -> PRETTY_NAME OPT
	val ‚find_char· : string -> PRETTY_NAME OPT

end (* of signature for structure PrettyNames *)
=DESCRIBE
Finds the characteristics of a symbol based on its keyword or character.
Both functions return $Nil$ if the symbol is not known.  They return
the tuple given to $add_new_symbols$ for known symbols.
=ENDDOC
%--------------------------------------------------------------------

\subsection{Character Input --- Part 2}

%--------------------------------------------------------------------
=DOC
val ‚get_percent_name· : READER_ENV
	-> string * PrettyNames.PRETTY_NAME OPT * bool;
=DESCRIBE
Assemble a percent keyword and look it up in the list of known
keywords.  On entry the opening percent ({\tt\%}) is the first unread
character.

The tuple returned contains:
(1) the keyword read, but without the percent characters;
(2) the symbols entry as given to $add_new_symbols$ or $Nil$ for
	an unknown keyword;
(3) a flag set true if the keyword had a closing percent character,
	false otherwise, error reporting is left to the calling
	functions.
Non-alphanumeric keywords may contain the characters
``\verb"!  &  $  #  +  -  /  :  <  =  >  ?  @  \  ~  '  ^  |  *"''
which are the same as in~\cite[section~2.4, page~4]{Milner90} apart
from the omission of the `{\tt\%}' character.
=SEEALSO
Type $PRETTY_NAME$.
Type $READER_ENV$.
=ENDDOC
%--------------------------------------------------------------------

Some character sequences may occur in many contexts in the input text,
for these a higher level of input than simple characters is
appropriate.  These character sequences are primarily inspired by
needing to read keywords enclosed in percent signs.

Data type $SYMBOL$ gives the various sequences that may be read.
Keywords and extended characters that have been declared via
$add_new_symbols$ are returned with constructor $SymKnown$, the string
hold the keyword (without the enclosing percents) or the extended
character read, the boolean being $true$ for a keyword and %false$for
an extended character.

%--------------------------------------------------------------------
=DOC
datatype ‚SYMBOL·
	=	‚SymKnown·			of string * bool
						* PrettyNames.PRETTY_NAME
	|	‚SymUnknownChar·		of string
	|	‚SymUnknownKw·		of string * bool
	|	‚SymDoublePercent·
	|	‚SymWhite·			of string
	|	‚SymCharacter· of string
	;
=DESCRIBE
$SymKnown$ indicates a symbol declared via $add_new_symbols$, if a keyword was
read the string hold the characters without the enclosing percents and the
boolean is $true$. {} Otherwise, when an extended character is read the
string holds the character and the boolean is $false$.

$SymUnknownChar$ indicates an extended character not declared
via $add_new_symbols$.

$SymUnknownKw$ indicates a keyword not declared
via $add_new_symbols$ or a badly formed keyword with no closing percent sign.
The boolean is $true$ for a well-formed keyword.

$SymDoublePercent$ indicates an empty keyword, i.e., two adjacent
percent signs.

$SymWhite$ indicates a non-empty sequence of formatting characters (space, tab,
newline, and formfeed) which are passed in the string.

All other cases are passed back as a single character in $SymCharacter$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚read_symbol· : READER_ENV -> SYMBOL;
=DESCRIBE
Reads one or more characters and returns a value of type $SYMBOL$.  No
fault reports are made by this routine.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚expand_symbol· : SYMBOL -> string;
=DESCRIBE
A value of type $SYMBOL$ is expanded into the corresponding character string.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚skip_comment· : READER_ENV -> unit;
=DESCRIBE
Skip over a comment which comprises a sequence of characters within
which the comment braces `{\tt (*}' and `{\tt *)}' are properly
balanced.  This routine is entered when the opening round bracket of
the comment has been read, the opening asterisk is the first unread
character.
Note that Standard~ML comments separate lexical items,
see~\cite[section~2.5]{Milner90}, thus the calling routine should not
simply discard the comment.
=FAILURE
5001	End of file found in comment
=SEEALSO
Type $READER_ENV$.
=ENDDOC
%--------------------------------------------------------------------

\subsection{Reading Higher Level Objects}

%--------------------------------------------------------------------
=DOC
val ‚get_ML_string· : READER_ENV -> string list -> string list * int list;
val ‚get_primed_string· : READER_ENV -> string list -> string list * int list;
=DESCRIBE
Assemble a string literal and add it to the left hand context given in the
second argument.  On entry the opening string quote has been read, exit
when the closing string quote has been read.  The goal of this routine
is to form an equivalent string that can be read by a Standard~ML
compiler, and to defer as much validation of the string as possible to
that compiler.  Minimal validation is performed on escape sequences.
Well-formed layout sequences (i.e., the sequence ``{\hbox{\verb|\|{\em
f..f\/}\verb|\|}}'' from~\cite[section~2.2, page~3]{Milner90}) are
removed, characters not recognised as formatting ones are retained and
wrapped between ``\verb|\ |'' and ``\verb| \|'' for later checking by
the Standard~ML compiler.  Pretty characters are translated to their
three digit decimal form.

Function $get_ML_string$ reads a string as specified
in~\cite[section~2.2, page~3]{Milner90}

Function $get_primed_string$ reads a string enclosed with single
left-hand primes~(~{\tt`}~).  These are as in~\cite[section~2.2,
page~3]{Milner90} but with the meanings of the single~(~{\tt`}~) and
double~(~{\tt"}~) prime characters interchanged.

An end of file found in the string indicates that there is no more
input available, and so an immediate failure (error 5002) is raised.
All other errors detected in strings are reported when found,
additionally their numbers passed back in the result.
=FAILURE
5002	End of file found in string
=SEEALSO
Type $READER_ENV$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚get_box_braces· : (READER_ENV -> string list -> string list)
		-> READER_ENV -> string list -> string list;
val ‚get_curly_braces· : (READER_ENV -> string list -> string list)
		-> READER_ENV -> string list -> string list;
val ‚get_round_braces· : (READER_ENV -> string list -> string list)
		-> READER_ENV -> string list -> string list;
=DESCRIBE
These functions assemble a section of bracketed text.  The opening
bracket has been read, the first unread character is the first
character within the brackets.  Each routine reads text upto and
including the matching closing bracket.  The first argument is the
parsing routine for reading items of text within the brackets.  The
third argument is the left hand context, which is returned with the
bracketed text read by these functions, and the enclosing braces.  The
three pairs of brackets: ``\verb|[ ]|'', ``\verb|{ }|'' and ``\verb|(
)|'' are handled by functions $get_box_braces$, $get_curly_braces$ and
$get_round_braces$ respectively.
=FAILURE
5008	Bracket mismatch, `?0` found after an opening `?1`
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚get_ML_any· : READER_ENV -> string list -> string list
=DESCRIBE
Assemble a section of Standard~ML text starting with the first unread
character.  Text is read upto the first semi colon `{\tt;}', unmatched
closing bracket or ending keyword.  A semi colon will be read and added
to the returned text, a closing bracket or ending keyword is left
unread for the calling
routine.  The syntax error where too many closing bracket are presented
must be resolved by the outermost routine that calls function.  The
second argument gives the left hand context, the new text read is added
to that context and returned.
=FAILURE
5003	Unknown keyword `?0` after `?1`
5005	Unknown extended character `?0` (decimal ?1) after `?2`
5007	Unexpected symbol `?0` (a symbol of type $Invalid$ has been read)
=SEEALSO
Type $READER_ENV$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚string_of_int3· : int -> string
=DESCRIBE
The string representation of small positive integers is needed in
various places, particularly within Standard~ML strings where some
characters are denoted by their decimal code in three digits, preceded
by a backslash.  Function $string_of_int3$ gives a three character with
leading zeros representation of small positive numbers.  In general the
routine $PolyML.makestring$ cannot be used, if the value last passed to
of $PolyML.print_depth$ is zero then $PolyML.makestring$ converts
numbers into three dots.
=FAILURE
5040	Number ?0 is too big
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚to_ML_string· : string -> string
=DESCRIBE
Converts any string into a another string which may be read by a
Standard~ML compiler and has the same meaning.  This is intended to
form the string representation of pretty characters for passing them
through to a Standard~ML compiler.  Characters other than space, tab
and newline which are outside the range~32 to~126 (decimal) inclusive
are converted to their four character equivalent of a backslash
followed by a three digit decimal number with leading zeroes.
=ENDDOC
%--------------------------------------------------------------------

\subsection{Supporting Other Languages}

Other languages may be embedded

Embedding other languages is achieved by providing a reader for the new
language, then making it and its enclosing symbols known to the
language embedding mechanisms.

There are two styles of embedding provided.  ``General quotations'' use
the keywords ``{\tt\%<\%}'' and ``{\tt\%>\%}'' (or the corresponding
extended characters) to enclose the embedded text, the language is
indicated by the characters immediately following the opening keyword.
The BNF syntax, see~\cite{ds/fmu/ied/pln009}, of general quotations is
as follows.

ÛBNF
quotation	=	'%<%', [ language_code ], quoted_text, '%>%';

language_code	=	'%down%', name, white_space
		|	':' ;
Ê

Where:

\begin{description}

\item[$name$ ] is a identifier in the extended Standard~ML.

\item[$white_space$ ] is a space or a tab character.

\item[$quoted_text$ ] is text in the named language.

\end{description}

The $name$ identifies the quoted language.  The default quotation,
where the $language_code$ is not given, is of a HOL term, which may
also be indicated by a name of ``{\tt HOL}''.  The colon form is
equivalent to using the name ``{\tt HOL:}''.

Conventionally, languages which yield HOL types should have a colon as
the last character of their name.

Note that including any space or tab characters before the
$language_code$ will cause the default interpretation, namely as a HOL term.

\bigskip

``Specific quotations'' have individual keywords and corresponding
extended characters to enclose their text, for example a HOL
axiomatic definition is enclosed by the keywords ``{\tt\%SHA\%}'' and
``{\tt\%EHA\%}''.

The third string argument is provided primarily for these forms of
definition where the text is macro processed into a call of a
Standard~ML function with a HOL term as argument.  The HOL term being a
pair with first component a name (or names) and its type, second
component a predicate defining the properties of that name.  The source
text looks is of the form ``{\tt\%SHA\% x : num \%BT\% x > 3 \%EHA\%}''
and is processed into the HOL term ``{\tt(( x : num ), ( x > 3 ))}''
where the brackets are provided by the macro processing, the two
leading brackets from the third string argument, the two final brackets
from the particular end keyword used.

%--------------------------------------------------------------------
=DOC
type ‚READER_FUNCTION· (*
	= READER_ENV
	-> (string * bool)	(* Starting symbol *)
	-> string		(* Language name *)
	-> string		(* Opening text *)
	-> string list		(* Left hand context *)
	-> string list *);
=DESCRIBE
The type of the reader functions for embedded languages.  The first
string argument gives the symbol that started the quotation.  For a
keyword enclosing percent signs are omitted and the boolean is true.
For an extended character the boolean is false.  The second string
holds the language name without the leading ``{\tt\%down\%}'' or
trailing white space, the default language and type are expanded to
give their full names, namely ``{\tt HOL}'' or ``{\tt HOL:}'' for the
colon form.  The third string is text to be included at the start of
the quoted text, in the case of a HOL quotation it is the first
characters that are to be read by the HOL recogniser.  The string list
is the left hand context of the call and must be returned with the text
of the quotation added to its head.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚add_general_reader· : string * string * READER_FUNCTION -> unit;
val ‚add_specific_reader· : string * string * READER_FUNCTION -> unit;
=DESCRIBE
Adds reader functions to the data base of known readers.  The first
string is the language name, e.g., ``{\tt HOL}'' and ``{\tt HOL:}'',
the second string holds the name of a Standard~ML constructor which is
to be written before the quotation when it occurs in within languages
other than Standard~ML.  Expected values of the second string are
``{\tt Lex.Term}'' and ``{\tt Lex.Type}''.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚look_up_general_reader· : string -> (READER_FUNCTION * string) OPT;
val ‚look_up_specific_reader· : string -> (READER_FUNCTION * string) OPT;
=DESCRIBE
Looks up readers in the data base of known readers.  The argument
string is matched against the first string given in the call of the
$add_\ldots_reader$, if the reader is known then the corresponding
constructor string and reader function are returned.  The value $Nil$
is returned for an unknown reader.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚general_quotation· : READER_ENV
	-> (string * bool)	(* Start of quotation symbol *)
	-> string		(* Opening characters *)
	-> bool		(* Context, true => in Standard ML *)
	-> string list		(* Left hand context *)
	-> string list;
val ‚specific_quotation· : READER_ENV
	-> (string * bool)	(* Start of quotation symbol *)
	-> string		(* Opening characters *)
	-> bool		(* Context, true => in Standard ML *)
	-> string list		(* Left hand context *)
	-> string list;
=DESCRIBE
Process the text of a quotation and add it to the left hand context
given.  The opening quotation symbol has been read and is passed as the
first string argument, a keyword is passed without its enclosing
percent signs and the boolean is true, for an extended character the
boolean is false.  For a general quotation the next characters to be
read denote the language of the quotation.  The boolean argument
indicates whether the left hand context is in Standard~ML text or in a
quotation of another language.
=FAILURE
5031	End of file in language name of general quotation
=ENDDOC
%--------------------------------------------------------------------
=DOC
(* val ‚SML_reader· : READER_FUNCTION; *)
=DESCRIBE
This routine is not intended to be called by any user code, it
is used when reading Standard~ML quotations.
=FAILURE
5032	End of file found in Standard~ML quotation
=ENDDOC
%--------------------------------------------------------------------
=DOC
(* val ‚skipping_reader· : READER_FUNCTION; *)
=DESCRIBE
This routine is not intended to be called by any user code, it
is provided for error recovery purposes.  It is used for any quotation
for which no reader has been provided, it just reads text discarding
its input until an unmatched quotation ending symbol is found.
Quotation opening symbols read during the skipping must be matched by
balancing ending symbol.  This routine does not attempt to understand
string or character literals, or comments.  All characters are
considered significant.

This routine is designed to assist in error recovery by consuming the
text of large quotations rather than stopping reading at the first
detected problem.  Thus the language recognisers (probably the
Standard~ML compiler in this case) will not receive large amounts of
text they cannot handle, and will not produce copious error messages.
=FAILURE
5030	End of file in quotation
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚SML_recogniser· : string * string * 'a * string -> 'a;
=DESCRIBE
This routine is not intended to be directly called by any user code, it
is provided to allow the quotation of Standard~ML text.  The context of
use of this routine is that the ``macro processing'' of the Standard~ML
quotation ``{\tt\%down\%SML 42 }'' yields the text
``{\tt(ReaderWriterSupport.SML_recogniser ("", "SML", 42 , ""))}''
which is read by the Standard~ML compiler.
=FAILURE
5050	Incorrect symbols starting or ending of Standard ML quotation: `?0`, `?1`, `?2`
=ENDDOC

%--------------------------------------------------------------------

\subsection{Completion of Reader Writer Support}
=SML
end (* of signature for structure ReaderWriterSupport *);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{HOL READER WRITER}

%--------------------------------------------------------------------
=DOC
signature ‚HOLReaderWriter· = sig
end;
=DESCRIBE
There are no visible declarations in this structure, its purpose is to
add new entries to the structure that holds all the information
relating the symbols for pretty characters and percent keywords
understood by the system, together with the functions that understand
how to read HOL text.
=FAILUREC
All the errors that the basic reader writer may raise may also be raised
by the HOL reader writer.
=ENDDOC
%--------------------------------------------------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
