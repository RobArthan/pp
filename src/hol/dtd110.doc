% dtd005.doc %Z% $Date$ $Revision$ $RCSfile$

=TEX
% dtd005.doc %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol,11pt,TQ]{article}

\TPPtitle{File and Terminal Reader Writer}
\TPPref{DS/FMU/IED/DTD005}
\TPPissue{$Revision$%
}

\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{IED 1563}

=IGN

Commands to process this document in various ways.

doc4tex dtd005
tex4dvi dtd005
bibtex dtd005
doc4tex dtd005 ; tex4dvi dtd005
pstex dtd005

lasp -s dtd005.doc > zz1
lasp -s -u dtd005.OKwords dtd005.doc > zz1

=TEX
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Standard}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the detailed design for the reading
	and writing functions that form the outermost level of user
	interface for Release~1 of ICL~HOL.  These functions are
	concerned with the differentiation of the various languages
	(initially Standard~ML and HOL), and the extensions to support
	pretty characters in Standard~ML identifiers and in strings.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

%\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage
\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [1 February 1991, issue 1.1 ]  First draft version, providing a
	place holder pending the creation of the proper document.

\item[21 February 1991, issue 1.2 ]  Added some extra details.

\item[6 March 1991, issue 1.3 ]  Add structures $ReaderWriterSupport$
	and $HOLReaderWriter$, and details of error messages.

\item[28 March 1991, issue 1.4 ]  Extensions to the narrative.
	Changes to details.

\item[14 May 1991, issue 1.5 ]  Extensive changes.  New form of
	quotation of other languages.  More extensive documentation of
	the interfaces.

\item[17 May 1991, issue 1.6 ] Add function $ask_at_terminal$.

{\sloppy
\item[14 August 1991, issue 1.7 ] Add:
	functions $translate_for_output$ and $is_special_char$;
	the test strategy section; strings for textual outputs;
	control flag $use_extended_chars$.

}%

\end{description}

%********************************************************************

\subsection{Changes forecast}

Some of the text in this document and in the
implementation~\cite{DS/FMU/IED/IMP005} is more appropriate to the
system builder's guide~\cite{DS/FMU/IED/USR008} and should be
moved into that document.  When that happens the descriptions in the
reference manual entries should be rewritten to refer to the system
builder's guide.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\newpage

\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains a detailed design of the file and terminal
reading and writing functions, called for by~\cite{DS/FMU/IED/HLD008}.
These functions implement the extensions to Standard~ML detailed
in~\cite{DS/FMU/IED/DEF002}
which discusses the lexical nature of the Release 1 ICL HOL.  The
design is implemented in~\cite{DS/FMU/IED/IMP005}.

%********************************************************************

\subsection{Introduction}

The `basic reader writer' of the Release 1 ICL HOL system supports an
extension to Standard~ML that allows `pretty characters' to be used in
Standard~ML text; in particular, in Standard~ML identifiers and
strings.  This interface is provided by three functions, see
section~\ref{PrimaryUserInterface}, which allow the enhanced ML text to
be read from the terminal, from a named text file, or from a
Standard~ML string.

A second part of the basic reader writer, the `embedding interface',
allows readers for other languages to be embedded, allowing the
(enhanced) Standard~ML to be used as a metalanguage for supporting work
in other languages.  Part of the embedding interface provides for
characters in the users source text to switch between languages, text
in an embedded language is treated as a Standard~ML string that is
passed as an argument to a language specific analysis routine ---
typically for lexical analysis, parsing, etc.

Within this document a reader writer for the HOL language is detailed,
it is added to the basic reader writer using the embedding interface.
Supporting the HOL language is a primary goal of the whole system,
within the reader writer it serves as a guide for the technique for
embedding other languages.

%--------------------------------------------------------------------

\subsubsection{Purpose and Background}

Some extensions to Standard~ML are given in~\cite{DS/FMU/IED/DEF002}
where they are described in terms of ``macro processing'' of the
extended Standard~ML to form Standard~ML.  The extensions are as
follows.

\begin{itemize}

\item An extended character set.  Many of the new characters may be
	used in ML identifiers, all may be used in strings.

\item Keywords enclosed in percent `{\tt\%}' signs may be used as
	equivalents for any of the extended characters.  Additional
	keywords are supported to provide access to many of the
	characters supported by \LaTeX{} to give flexibility in the
	form of a documents printed output.

\item Standard~ML programs may be read as extended Standard~ML {\em
	provided\/} all percent `{\tt\%}' signs in the original program
	are replaced by two adjacent percent signs.

\item Other languages may be embedded in the extended Standard~ML text,
	their text is surrounded by the appropriate language embedding
	symbols (i.e., by the extended characters or their equivalent
	keywords).

\end{itemize}

%--------------------------------------------------------------------

%\subsubsection{Dependencies}

%An indication on which other documents  this document is dependent on.

%--------------------------------------------------------------------

%\subsubsection{Interface}

%A brief explanation of the external interface presented by the
%document.  This should identify the signatures defined in the
%document.

%--------------------------------------------------------------------

\subsubsection{Possible Enhancements}

A journaling system that records all inputs and/or outputs
into a named file.

%--------------------------------------------------------------------

%\subsubsection{Deficiencies}

%An indication of any shortcomings in the facilities offered by the
%document.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{BASIC READER WRITER}

The basic reader writer offers a small number of interfaces, basically
those for directing the ICL~HOL to its source text.  Additional
interfaces are provided in the support structure for embedding
additional languages.

%--------------------------------------------------------------------
=DOC
signature ‚ReaderWriter· = sig
=DESCRIBE
File and terminal reading and writing functions.
=FAILURE
5001	End of file found in comment
5002	End of file found in string
5003	Unknown keyword `?0` after `?1`
5004	Unknown keyword `?0`
5005	Unknown extended character `?0` (decimal ?1) after `?2`
5006	Unknown extended character `?0` (decimal ?1)
5007	Unexpected symbol `?0` (a symbol of type $Invalid$ has been read)
5008	Bracket mismatch, `?0` found after an opening `?1`
5010	Unknown language requested by symbol `?0` with language name `?1`
5011	Unknown language requested
5014	Newline found in string after `?0`
=IGN
Spare error codes
5009
5015-5029
5034-5039
5041-5049
5051-5099
5105-5499
Codes 5500-5599 reserved for sections of text.
5504-5510
5513-5520
5526-5530
5533-5999
=FAILUREC
Several error messages are provided to report faults in the users
textual input to the ICL HOL system, they may be produced from all of
the routines $usefile$, $usestring$ and $useterminal$.  Some error
messages might be associated with particular routines in the reader
writer support $ReaderWriterSupport$ structure but that is incidental
to most users, so they are all gathered here.
=ENDDOC

%********************************************************************

\subsection{Primary User Interface} \label{PrimaryUserInterface}

%--------------------------------------------------------------------
=DOC
val ‚usefile· : string -> unit;
=DESCRIBE
Read Standard~ML with pretty characters allowed, from the named file.
If the file does not exist then the it will read the file with the
given name and suffix ``{\tt.ML}'', if that file does not exist it will
try the suffix ``{\tt.sml}''.
=SEEALSO
Error messages given with signature for $ReaderWriter$.
Flag $usefile_non_stop_mode$.
=ENDDOC

=FAILURE
5501	Character `?0` read too often, abandoning file ?1 at character number ?2
5502	Exception+ ?0 handled by usefile at line ?1 when in `non_stop_mode`
5503	Exception+, abandoning file ?0 at line ?1
=TEX

%--------------------------------------------------------------------
=DOC
val ‚usestring· : string -> unit;
=DESCRIBE
Read Standard~ML with pretty characters allowed, from the given string.
=SEEALSO
Error messages given with signature for $ReaderWriter$.
=ENDDOC

=FAILURE
5511	Character `?0` read too often, abandoning string at character number ?1
5512	Exception+, abandoning string at character number ?0
=TEX

%--------------------------------------------------------------------
=DOC
val ‚useterminal· : unit -> unit;
=DESCRIBE
Read Standard~ML with pretty characters allowed, from the terminal.
This routine takes over the terminal, it handles all exceptions as the
outermost level of the ML system.  To return to the default PolyML
terminal reader use $abandon_reader_writer$.

This routine prompts to the conventions of PolyML but uses the strings
``{\tt:>~}'' and ``{\tt:>~}'', the PolyML prompts do not have the
colon.

Typing control-D, or reading the end-of-file, causes the function
$PolyML.quit$ to be called.

Typing control-X to this routine (when it is looking for input)
abandons the current {\em topdec.}
=SEEALSO
Error messages given with signature for $ReaderWriter$.
=ENDDOC

=FAILURE
5521	Exception+ ?0 handled by useterminal
5522	Exception+ ?0 ?1 raised
5523	End of input to useterminal.  Quit.
5524	Character `?0` read too often, abandoning current input
5525	Abandoning reader writer
=TEX

%--------------------------------------------------------------------
=DOC
val ‚abandon_reader_writer· : unit -> unit;
=DESCRIBE
Only meaningfully used after $useterminal$ has been called, when it
forces an exit from that routine.
=ENDDOC
%--------------------------------------------------------------------
=DOC
(* ‚usefile_non_stop_mode·  - boolean flag declared by new_flag, default: false *)
=DESCRIBE
Makes $usefile$ continue reading text (if the flag is true) or stop
reading (if false) from the file after an error is reported.  Default
is to stop reading.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚ask_at_terminal· : string -> string;
=DESCRIBE
Asks a question at the terminal by writing out the given string then
reading a single line of text which is returned.

Any characters in the type ahead buffer of the terminal input stream
are read and saved for later analysis by the normal reading functions
before the prompt is output and the response is read.

This function uses the PolyML function $ExtendedIO.can_input$ to
determine how many characters are available in the type ahead buffer,
they are read.  It next outputs the prompt, and finally makes a single
call of $ExtendedIO.input_line$.
=FAILURE
5012	Function `useterminal` is not active
5013	Input stream is not a terminal, nothing read
=ENDDOC
%--------------------------------------------------------------------

Strings produced by, for example, converting parts of HOL terms into
textual form may contain keywords that should be converted into other
forms, in some cases these keywords may be wrapped in double letter
`{\tt QQ}'' characters, see~\cite{DS/FMU/IED/DEF002} for an
explanation.  Translation is automatically performed by the reader
writer for all text that the PolyML system writes to the standard
output.  Text written by $BasicIO.output$ to the standard output is not
converted --- this is because of how PolyML controls its output
streams.  Function $translate_for_output$ performs the conversions.  It
is forgiving with its processing: unknown keywords are left in their
keyword form; unexpected letter `{\tt Q}'s are converted to an
equivalent keyword, namely `{\tt\%Q\%}'; escape sequences used in
Standard~ML strings are echoed literally if they are malformed.

A forgiving behaviour is appropriate given the expected context of use
of the function.  The ICL~HOL system or the user has created some text
to be output.  The text is often the display of a top-level binding,
frequently it indicates some change in the state of the Standard~ML
bindings.  It is appropriate to show as much as possible of these
changes to the user even if occasionally the results contain a few
unconverted characters.

=DOC
val ‚translate_for_output· : string -> string;
=DESCRIBE
Translates a string according to the macro processing rules used when
outputting text.  The output produced depends on the setting of the
control flag $use_extended_chars$, when false the result will have no
extended characters, the keyword forms will be used.
=ENDDOC
%--------------------------------------------------------------------
=DOC
(* ‚use_extended_chars·  - boolean flag declared by new_flag, default: true *)
=DESCRIBE
Controls how the writer changes the text output from the PolyML
compiler.  When $true$ extended characters are written, when $false$
the corresponding keywords are written.
=ENDDOC
%--------------------------------------------------------------------

=SML
end (* of signature ReaderWriter *);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{SUPPORTING OTHER LANGUAGES}

A large part of the reader writer interface allows the embedding
of other languages.

The style of the interface is to be documented
in~\cite{DS/FMU/IED/USR008}, most of the required information is
contained within this document and the implementation
document~\cite{DS/FMU/IED/IMP005}, but it is too bulky to be placed in
this document.  The descriptions that follow assume that such a
description has been seen by the reader of this document.

Many routines have an argument of type $READER_ENV$ which provides the
functions to read characters from the current input stream.  This
argument is not detailed with each function, but a reference to the
type declaration is made.

%--------------------------------------------------------------------
=DOC
signature ‚ReaderWriterSupport· = sig
=DESCRIBE
A set of declarations that allows the addition of new embedded
languages.  The HOL language is an example of a language embedded into
a basic system that understands Standard~ML with pretty characters and
percent keywords.
=ENDDOC

%--------------------------------------------------------------------

\subsection{Diagnostic Support}

Reader function should avoid producing fault messages, where possible
they should be left to the language recogniser to report.  Some faults
can only be reported by reader functions, for these cases the following
functions are available.

In general a fault is reported by calling either $local_error$ or
$local_warn$ and adding details of the error code to the text produced
and continuing.  In the macro processing analogy a short fault report
is written into the macro processors output at the place of detection
of an error.  Functions $add_error_code$ and $add_error_codes$ are
provided to give a uniform style for these short reports.

%--------------------------------------------------------------------
=DOC
val ‚local_error· : string -> int -> (unit -> string) list -> unit;
val ‚local_warn· : string -> int -> (unit -> string) list -> unit;
=DESCRIBE
An error or warning message is written to the standard output, then the
function returns.  The arguments are identical in form to functions
$error$ and $fail$ of {\tt DS/FMU/IED/DTD002}.
=SEEALSO
Functions $error$ and $fail$.
=ENDDOC

=FAILURE
5531	*** WARNING ?0 from ?1: ?2
5532	*** ERROR ?0 from ?1: ?2
=TEX

%--------------------------------------------------------------------
=DOC
val ‚add_error_code· : int * string list -> string list;
val ‚add_error_codes· : int list * string list -> string list;
=DESCRIBE
For each error number ``$nn$'' given as the first argument an
entry of the form ``\verb*| ERROR__|$nn$\verb*| |'' is added
to the head of the second argument.
=ENDDOC
%--------------------------------------------------------------------

Diagnostic control $RW_diagnostics$ is interpreted as a series of
`bits'  each controlling some diagnostic output which is written to the
PolyML standard output.  A zero value indicates no diagnostics.  The
value is selected by adding numbers from the following table according
to the diagnostic outputs required.

\begin{center}
\begin{tabular}{crp{4in}}
\multicolumn{2}{c}{Value}&	Purpose\\
$2^0$&1&	Text passed to PolyML.\\
$2^1$&2&        Text passed to PolyML, but showing the list structure
		passed by routines such as $get_ML_any$.\\
$2^2$&4&	Characters as they are read.\\
$2^3$&8&	Text passed to the writer function before any
		translation is performed.\\
$2^4$&16&	Prevents text from being translated before output by the
		writer function.\\
\end{tabular}
\end{center}

=DOC
(* ‚RW_diagnostics·  - integer control declared by new_int_control, default: 0 *)
=DESCRIBE
For reader writer diagnostic purposes.
=ENDDOC
%--------------------------------------------------------------------

\subsection{Character Input --- Part 1}

%--------------------------------------------------------------------
=DOC
type ‚READER_ENV· (* = {
	‚advance·			: unit -> string,
	‚look_at_next·			: unit -> string,
	‚skip_and_look_at_next·	: unit -> string
} *) ;
=DESCRIBE
All of the parsing functions in the reader writer support use the
functions provided in this record type to read characters from the
current input stream.  Attempting to read characters by any other
method will have unpredictable results.
=ENDDOC
%--------------------------------------------------------------------
=DOC
exception ‚EndOfInput·;
=DESCRIBE
Associated with the reader functions is the exception $EndOfInput$
which is raised when the parser has read the end of the file and
has passed the end of file character at least once to the compiler.
Raising this exception signifies that nothing more can usefully be
done with the current input stream.
=ENDDOC
%--------------------------------------------------------------------

\subsection{Data Base of Keywords and Extended Characters}

%--------------------------------------------------------------------
=DOC
structure ‚PrettyNames· : sig
=DESCRIBE
A structure within $ReaderWriterSupport$ that gathers all the
information relating the pretty characters and percent keywords
understood by the system, together with the interfaces for
interrogating and extending the information.
=ENDDOC
%--------------------------------------------------------------------
=DOC
	datatype ‚NAME_CLASS·
		=	‚Simple·
		|	‚Starting·	of (READER_ENV -> (string * bool)
						-> string -> bool -> string list
						-> string list) * string
		|	‚Middle·	of string
		|	‚Ending·	of string
		|	‚Ignore·
		|	‚Invalid·;
=DESCRIBE
These detail the characteristics of a symbol.  $Simple$ is used for
symbols that may be part of identifiers.  $Starting$, $Middle$ and $Ending$
relate to the symbols position when embedding text of other languages.
The function with $Starting$ is the reader routine for
the particular embedded language.  Details of how this function should be
written (and of it arguments) are given in the implementation document
corresponding to this
design.  $Ignore$ is used for characters that are completely ignored in the
input, the pretty characters for indexing come in this category.  $Invalid$
will cause an error message.
=SEEALSO
Error 5007
=ENDDOC
%--------------------------------------------------------------------
=DOC
	type ‚PRETTY_NAME· (* = ( string list * string OPT * NAME_CLASS )  *)  ;
=DESCRIBE
Each symbol is defined in a three-element tuple of this type.  Elements
of the tuple are as follows.  First, a non-empty list of the keywords
that may used for this symbol, the preferred keyword is at the head of
the list.  These keywords exclude the enclosing percent signs.
Second, an optional character (normally an extended character)
for the symbol.  Third, a value of datatype $NAME_CLASS$ indicating
the characteristics of the symbol.

The pretty character field, when used, contains a single character.
Normally it has decimal code greater than 127.  Lower values may be
used to achieve keywords for single characters, care should be taken to
avoid converting such characters into keywords on output when using
this facility.
=SEEALSO
Function $add_new_symbols$, for details of the validation of values
of this type.
=EXAMPLE
	([	"fn",
		"lambda"],	Value "ç",			Simple),
=ENDDOC
%--------------------------------------------------------------------
=DOC
	val ‚add_new_symbols· : PRETTY_NAME list -> unit;
=DESCRIBE
Adds details of new symbols to the data structures characterising all
known symbols.  There is some validation of the symbols added, the list
of names should not be empty, the individual names should not
contain two adjacent ``{\tt Q}''s, duplicates and
the character field should have
a single character.
=FAILURE
5100	Keyword `?0` has adjacent `Q`s
5101	Empty keyword list
5102	Invalid pretty character `?0` with keyword `?1`
5103	Keyword `?0` duplicated
5104	Character `?0` duplicated
=ENDDOC
%--------------------------------------------------------------------
=DOC
	val ‚find_name· : string -> PRETTY_NAME OPT
	val ‚find_char· : string -> PRETTY_NAME OPT

end (* of signature for structure PrettyNames *)
=DESCRIBE
Finds the characteristics of a symbol based on its keyword or character.
Both functions return $Nil$ if the symbol is not known.  They return
the tuple given to $add_new_symbols$ for known symbols.
=ENDDOC
%--------------------------------------------------------------------

\subsection{Character Input --- Part 2}

%--------------------------------------------------------------------
=DOC
val ‚is_special_char· : string -> bool;
=DESCRIBE
Checks whether the string contains a single non-alphanumeric character
that is allowed in a keyword.  Returns $true$ if the argument contains
exactly one of the characters listed in the description of function
$get_percent_name$, otherwise $false$ is returned.
=SEEALSO
Function $get_percent_name$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚get_percent_name· : READER_ENV
	-> string * PrettyNames.PRETTY_NAME OPT * bool;
=DESCRIBE
Assemble a percent keyword and look it up in the list of known
keywords.  On entry the opening percent ({\tt\%}) is the first unread
character.

The tuple returned contains:
(1) the keyword read, but without the percent characters;
(2) the symbols entry as given to $add_new_symbols$ or $Nil$ for
	an unknown keyword;
(3) a flag set true if the keyword had a closing percent character,
	false otherwise, error reporting is left to the calling
	functions.
Non-alphanumeric keywords may contain the characters
``\verb"!  &  $  #  +  -  /  :  <  =  >  ?  @  \  ~  '  ^  |  *"''
which are the same as in~\cite[section~2.4, page~4]{Milner90} apart
from the omission of the `{\tt\%}' character.
=SEEALSO
Type $PRETTY_NAME$.
Type $READER_ENV$.
Function $is_special_char$.
=ENDDOC
%--------------------------------------------------------------------

Some character sequences may occur in many contexts in the input text,
for these a higher level of input than simple characters is
appropriate.  These character sequences are primarily inspired by
needing to read keywords enclosed in percent signs.

Data type $SYMBOL$ gives the various sequences that may be read.
Keywords and extended characters that have been declared via
$add_new_symbols$ are returned with constructor $SymKnown$, the string
hold the keyword (without the enclosing percents) or the extended
character read, the boolean being $true$ for a keyword and %false$for
an extended character.

%--------------------------------------------------------------------
=DOC
datatype ‚SYMBOL·
	=	‚SymKnown·			of string * bool
						* PrettyNames.PRETTY_NAME
	|	‚SymUnknownChar·		of string
	|	‚SymUnknownKw·		of string * bool
	|	‚SymDoublePercent·
	|	‚SymWhite·			of string
	|	‚SymCharacter· of string
	;
=DESCRIBE
$SymKnown$ indicates a symbol declared via $add_new_symbols$, if a keyword was
read the string hold the characters without the enclosing percents and the
boolean is $true$. {} Otherwise, when an extended character is read the
string holds the character and the boolean is $false$.

$SymUnknownChar$ indicates an extended character not declared
via $add_new_symbols$.

$SymUnknownKw$ indicates a keyword not declared
via $add_new_symbols$ or a badly formed keyword with no closing percent sign.
The boolean is $true$ for a well-formed keyword.

$SymDoublePercent$ indicates an empty keyword, i.e., two adjacent
percent signs.

$SymWhite$ indicates a non-empty sequence of formatting characters (space, tab,
newline, and formfeed) which are passed in the string.

All other cases are passed back as a single character in $SymCharacter$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚read_symbol· : READER_ENV -> SYMBOL;
=DESCRIBE
Reads one or more characters and returns a value of type $SYMBOL$.  No
fault reports are made by this routine.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚expand_symbol· : SYMBOL -> string;
=DESCRIBE
A value of type $SYMBOL$ is expanded into the corresponding character string.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚skip_comment· : READER_ENV -> unit;
=DESCRIBE
Skip over a comment which comprises a sequence of characters within
which the comment braces `{\tt (*}' and `{\tt *)}' are properly
balanced.  This routine is entered when the opening round bracket of
the comment has been read, the opening asterisk is the first unread
character.
Note that Standard~ML comments separate lexical items,
see~\cite[section~2.5]{Milner90}, thus the calling routine should not
simply discard the comment.
=FAILURE
5001	End of file found in comment
=SEEALSO
Type $READER_ENV$.
=ENDDOC
%--------------------------------------------------------------------

\subsection{Reading Higher Level Objects}

%--------------------------------------------------------------------
=DOC
val ‚get_ML_string· : READER_ENV -> string list -> string list * int list;
val ‚get_primed_string· : READER_ENV -> string list -> string list * int list;
=DESCRIBE
Assemble a string literal and add it to the left hand context given in the
second argument.  On entry the opening string quote has been read, exit
when the closing string quote has been read.  The goal of this routine
is to form an equivalent string that can be read by a Standard~ML
compiler, and to defer as much validation of the string as possible to
that compiler.  Minimal validation is performed on escape sequences.
Well-formed layout sequences (i.e., the sequence ``{\hbox{\verb|\|{\em
f..f\/}\verb|\|}}'' from~\cite[section~2.2, page~3]{Milner90}) are
removed, characters not recognised as formatting ones are retained and
wrapped between ``\verb|\ |'' and ``\verb| \|'' for later checking by
the Standard~ML compiler.  Pretty characters are translated to their
three digit decimal form.

Function $get_ML_string$ reads a string as specified
in~\cite[section~2.2, page~3]{Milner90}

Function $get_primed_string$ reads a string enclosed with single
left-hand primes~(~{\tt`}~).  These are as in~\cite[section~2.2,
page~3]{Milner90} but with the meanings of the single~(~{\tt`}~) and
double~(~{\tt"}~) prime characters interchanged.

An end of file found in the string indicates that there is no more
input available, and so an immediate failure (error 5002) is raised.
Error code 5014 is included to aid in understanding where errors occur,
this error is not actually generated until the first non white-space
character after the newline is processed.
All other errors detected in strings are reported when found,
additionally their numbers passed back in the result.
=FAILURE
5002	End of file found in string
5014	Newline found in string after `?0`
=SEEALSO
Type $READER_ENV$.
=ENDDOC

Note that error code 5014 could be deferred for detection and reporting
by the Standard~ML compiler but the PolyML compiler's error messages is
not very helpful in this case.  The delay in its production is due to
how function $read_symbol$ gathers white-space characters.

\bigskip

%--------------------------------------------------------------------
=DOC
val ‚get_box_braces· : (READER_ENV -> string list -> string list)
		-> READER_ENV -> string list -> string list;
val ‚get_curly_braces· : (READER_ENV -> string list -> string list)
		-> READER_ENV -> string list -> string list;
val ‚get_round_braces· : (READER_ENV -> string list -> string list)
		-> READER_ENV -> string list -> string list;
=DESCRIBE
These functions assemble a section of bracketed text.  The opening
bracket has been read, the first unread character is the first
character within the brackets.  Each routine reads text upto and
including the matching closing bracket.  The first argument is the
parsing routine for reading items of text within the brackets.  The
third argument is the left hand context, which is returned with the
bracketed text read by these functions, and the enclosing braces.  The
three pairs of brackets: ``\verb|[ ]|'', ``\verb|{ }|'' and ``\verb|(
)|'' are handled by functions $get_box_braces$, $get_curly_braces$ and
$get_round_braces$ respectively.
=FAILURE
5008	Bracket mismatch, `?0` found after an opening `?1`
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚get_ML_any· : READER_ENV -> string list -> string list
=DESCRIBE
Assemble a section of Standard~ML text starting with the first unread
character.  Text is read upto the first semi colon `{\tt;}', unmatched
closing bracket or ending keyword.  A semi colon will be read and added
to the returned text, a closing bracket or ending keyword is left
unread for the calling
routine.  The syntax error where too many closing bracket are presented
must be resolved by the outermost routine that calls function.  The
second argument gives the left hand context, the new text read is added
to that context and returned.
=FAILURE
5003	Unknown keyword `?0` after `?1`
5005	Unknown extended character `?0` (decimal ?1) after `?2`
5007	Unexpected symbol `?0` (a symbol of type $Invalid$ has been read)
=SEEALSO
Type $READER_ENV$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚string_of_int3· : int -> string
=DESCRIBE
The string representation of small positive integers is needed in
various places, particularly within Standard~ML strings where some
characters are denoted by their decimal code in three digits, preceded
by a backslash.  Function $string_of_int3$ gives a three character with
leading zeros representation of small positive numbers.  In general the
routine $PolyML.makestring$ cannot be used, if the value last passed to
of $PolyML.print_depth$ is zero then $PolyML.makestring$ converts
numbers into three dots.
=FAILURE
5040	DESIGN ERROR:Number ?0 is too big or is negative
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚to_ML_string· : string -> string
=DESCRIBE
Converts characters which are to form part of a string literal into
another string which may be read by a Standard~ML compiler and which
has the same meaning.  This is intended to form the string
representation of extended characters for passing them
through to a Standard~ML compiler.  Characters other than space, tab
and newline which are outside the range~32 to~126 (decimal) inclusive
are converted to their four character equivalent of a backslash
followed by a three digit decimal number with leading zeroes.
=ENDDOC
%--------------------------------------------------------------------

\subsection{Embedding Other Languages}

Other languages may be embedded

Embedding other languages is achieved by providing a reader for the new
language, then making it and its enclosing symbols known to the
language embedding mechanisms.

There are two styles of embedding provided.  ``General quotations'' use
the keywords ``{\tt\%<\%}'' and ``{\tt\%>\%}'' (or the corresponding
extended characters) to enclose the embedded text, the language is
indicated by the characters immediately following the opening keyword.
The BNF syntax, see~\cite{DS/FMU/IED/PLN009}, of general quotations is
as follows.

ÛBNF
quotation	=	'%<%', [ language_code ], quoted_text, '%>%';

language_code	=	'%down%', name, white_space
		|	':' ;
Ê

Where:

\begin{description}

\item[$name$ ] is a identifier in the extended Standard~ML.

\item[$white_space$ ] is a space or a tab character.

\item[$quoted_text$ ] is text in the named language.

\end{description}

The $name$ identifies the quoted language.  The default quotation,
where the $language_code$ is not given, is of a HOL term, which may
also be indicated by a name of ``{\tt HOL}''.  The colon form is
equivalent to using the name ``{\tt HOL:}''.

Conventionally, languages which yield HOL types should have a colon as
the last character of their name.

Note that including any space or tab characters before the
$language_code$ will cause the default interpretation, namely as a HOL term.

\bigskip

``Specific quotations'' have individual keywords and corresponding
extended characters to enclose their text, for example a HOL
axiomatic definition is enclosed by the keywords ``{\tt\%SHA\%}'' and
``{\tt\%EHA\%}''.

The third string argument is provided primarily for these forms of
definition where the text is macro processed into a call of a
Standard~ML function with a HOL term as argument.  The HOL term being a
pair with first component a name (or names) and its type, second
component a predicate defining the properties of that name.  The source
text looks is of the form ``{\tt\%SHA\% x : num \%BT\% x > 3 \%EHA\%}''
and is processed into the HOL term ``{\tt(( x : num ), ( x > 3 ))}''
where the brackets are provided by the macro processing, the two
leading brackets from the third string argument, the two final brackets
from the particular end keyword used.

%--------------------------------------------------------------------
=DOC
type ‚READER_FUNCTION· (*
	= READER_ENV
	-> (string * bool)	(* Starting symbol *)
	-> string		(* Language name *)
	-> string		(* Opening text *)
	-> string list		(* Left hand context *)
	-> string list *);
=DESCRIBE
The type of the reader functions for embedded languages.  The first
string argument gives the symbol that started the quotation.  For a
keyword enclosing percent signs are omitted and the boolean is true.
For an extended character the boolean is false.  The second string
holds the language name without the leading ``{\tt\%down\%}'' or
trailing white space, the default language and type are expanded to
give their full names, namely ``{\tt HOL}'' or ``{\tt HOL:}'' for the
colon form.  The third string is text to be included at the start of
the quoted text, in the case of a HOL quotation it is the first
characters that are to be read by the HOL recogniser.  The string list
is the left hand context of the call and must be returned with the text
of the quotation added to its head.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚add_general_reader· : string * string * READER_FUNCTION -> unit;
val ‚add_specific_reader· : string * string * READER_FUNCTION -> unit;
=DESCRIBE
Adds reader functions to the data base of known readers.  The first
string is the language name, e.g., ``{\tt HOL}'' and ``{\tt HOL:}'',
the second string holds the name of a Standard~ML constructor which is
to be written before the quotation when it occurs in within languages
other than Standard~ML.  Expected values of the second string are
``{\tt Lex.Term}'' and ``{\tt Lex.Type}''.
=FAILURE
5033	Reader already present for language `?0`
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚look_up_general_reader· : string -> (READER_FUNCTION * string) OPT;
val ‚look_up_specific_reader· : string -> (READER_FUNCTION * string) OPT;
=DESCRIBE
Looks up readers in the data base of known readers.  The argument
string is matched against the first string given in the call of the
$add_\ldots_reader$, if the reader is known then the corresponding
constructor string and reader function are returned.  The value $Nil$
is returned for an unknown reader.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚general_quotation· : READER_ENV
	-> (string * bool)	(* Start of quotation symbol *)
	-> string		(* Opening characters *)
	-> bool		(* Context, true => in Standard ML *)
	-> string list		(* Left hand context *)
	-> string list;
val ‚specific_quotation· : READER_ENV
	-> (string * bool)	(* Start of quotation symbol *)
	-> string		(* Opening characters *)
	-> bool		(* Context, true => in Standard ML *)
	-> string list		(* Left hand context *)
	-> string list;
=DESCRIBE
Process the text of a quotation and add it to the left hand context
given.  The opening quotation symbol has been read and is passed as the
first string argument, a keyword is passed without its enclosing
percent signs and the boolean is true, for an extended character the
boolean is false.  For a general quotation the next characters to be
read denote the language of the quotation.  The boolean argument
indicates whether the left hand context is in Standard~ML text or in a
quotation of another language.
=FAILURE
5031	End of file in language name of general quotation
=ENDDOC
%--------------------------------------------------------------------
=DOC
(* val ‚SML_reader· : READER_FUNCTION; *)
=DESCRIBE
This routine is not intended to be called by any user code, it
is used when reading Standard~ML quotations.
=FAILURE
5032	End of file found in Standard~ML quotation
=ENDDOC
%--------------------------------------------------------------------
=DOC
(* val ‚skipping_reader· : READER_FUNCTION; *)
=DESCRIBE
This routine is not intended to be called by any user code, it
is provided for error recovery purposes.  It is used for any quotation
for which no reader has been provided, it just reads text discarding
its input until an unmatched quotation ending symbol is found.
Quotation opening symbols read during the skipping must be matched by
balancing ending symbol.  This routine does not attempt to understand
string or character literals, or comments.  All characters are
considered significant.

This routine is designed to assist in error recovery by consuming the
text of large quotations rather than stopping reading at the first
detected problem.  Thus the language recognisers (probably the
Standard~ML compiler in this case) will not receive large amounts of
text they cannot handle, and will not produce copious error messages.
=FAILURE
5030	End of file in quotation
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚SML_recogniser· : string * string * 'a * string -> 'a;
=DESCRIBE
This routine is not intended to be directly called by any user code, it
is provided to allow the quotation of Standard~ML text.  The context of
use of this routine is that the ``macro processing'' of the Standard~ML
quotation ``{\tt\%down\%SML 42 }'' yields the text
``{\tt(ReaderWriterSupport.SML_recogniser ("", "SML", 42 , ""))}''
which is read by the Standard~ML compiler.
=FAILURE
5050	Incorrect symbols starting or ending of Standard ML quotation: `?0`, `?1`, `?2`
=ENDDOC

%--------------------------------------------------------------------

\subsection{Completion of Reader Writer Support}
=SML
end (* of signature for structure ReaderWriterSupport *);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{HOL READER WRITER}

%--------------------------------------------------------------------
=DOC
signature ‚HOLReaderWriter· = sig
end;
=DESCRIBE
There are no visible declarations in this structure, its purpose is to
add new entries to the structure that holds all the information
relating the symbols for pretty characters and percent keywords
understood by the system, together with the functions that understand
how to read HOL text.
=FAILUREC
All the errors that the basic reader writer may raise may also be raised
by the HOL reader writer.
=ENDDOC
%--------------------------------------------------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TEST STRATEGY}

There are three main test areas for the reader writer.

\begin{itemize}

\item Reasonable behaviour.  Does the reader writer do the correct task
	most of the time, does it allow the compiling and execution of
	programs written in enhanced Standard~ML.

\item Correct processing.  Are the input and output streams correctly
	manipulated and passed on to or received from from the PolyML system?

\item Functional interfaces.  Do the functional interfaces do the
	correct task?

\end{itemize}

These areas are distinguished by the sort of testing that sensible to
do.  Many aspects of the first two could probably be tested using the
module test harness~\cite{DS/FMU/IED/DTD013}, but doing so would
involve excessive work and would result in opaque test scripts.

Reasonable behaviour is determined by actually using the reader writer
during the compilation of the much of the ICL~HOL system.  This is
because it is written using the extended Standard~ML supported by the
reader writer.  If the modules of the ICL~HOL system compile
successfully producing the correct signatures then a large portion of
the reader writer must be executing reasonably and properly.  The
reader writer is similarly needed during the development of other
modules, its reasonable behaviour is indicated by how it supports the
development activity in the context of error detection and recovery.

Thus, tests for reasonable behaviour are:

\begin{itemize}

\item Compilation and execution of much of the ICL~HOL system.

\item Compilation and execution of module tests of the reader writer
	and the rest of the ICL~HOL system.

\end{itemize}

Correct processing concerns the manipulation of text that is to be
passed to the read phase of the (conventional) read-evaluate-print
cycle of the PolyML system, followed by the manipulation of system
outputs.  In this context much of the reader writer deals with text
that may not successfully parse as Standard~ML: the reader writer is
required to behave itself in the presence of any text the user presents
and to either report the problems itself or to pass the problem onto
the PolyML compiler for it to report.  The reader writer works by side
effect on the input output streams and via an interface to the
read-evaluate-print cycle of the PolyML system.  Accordingly the reader
writer deals with text that cannot easily be tested using the
facilities of the module test harness~\cite{DS/FMU/IED/DTD013}.

Tests for correct processing are part of integration testing of
the ICL~HOL system, they include demonstrating that the
following cases are correctly handled on both input and output.
Much of the input processing can be tested with function
$usestring$ under control of the module test
harness~\cite{DS/FMU/IED/DTD013}.

\begin{itemize}

\item Strings.  Empty strings.  Escape sequences: ignored white space,
	newline characters, decimal codes, control (caret
	``{\verb|^|}'') codes.  Extended characters.  Percent
	``{\tt\%}'' characters.  Percent keywords.

\item Simple Standard~ML expressions.

\item Extended characters.  Use of equivalent keywords.  Use in
	extended Standard~ML identifiers.

\item Quotations.  Comments strings and character literals.  Nested
	quotations.  Quotations of Standard~ML.  Quotations of unknown
	languages.  Term and type quotations.  Declarative quotations,
	i.e., with schema boxes and similar.

\item Malformed variants of most of the preceding items.

\end{itemize}

Parts of the reader writer may be tested with the module test
harness~\cite{DS/FMU/IED/DTD013} and a module test document is
used for these.  Note that successful execution of the module tests
also demonstrates both reasonable behaviour and correct processing.
Functions with an argument of type $READER_ENV$ cannot easily be
tested here since they work by side effect upon that argument.

\begin{itemize}

\item $usestring$.

\item Comments.  Nested comments.  Comments containing asterisks.

\item Function $translate_for_output$ with both settings of control
	flag $use_extended_chars$.

{\sloppy\hbadness 1500
\item Simple functions from structure $ReaderWriterSupport$, namely:
	$local_error$, $local_warn$, $add_error_code$,
	$add_error_codes$, $is_special_char$, $string_of_int3$, and
	$to_ML_string$.

}%

\item Accessing extended characters and keywords from structure
	$PrettyNames$:  accessing predefined symbols by character and
	by keyword; adding and accessing some new symbols; unknown
	characters and keywords.

{\sloppy\hbadness 1500
\item The following functions from structure $ReaderWriterSupport$ can
	be invoked but cannot be easily tested for their correct side
	effects:  $add_general_reader$, $add_specific_reader$,
	$look_up_general_reader$, and $look_up_specific_reader$.

}%

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
