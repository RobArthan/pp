% dtd005.doc %Z% $Date$ $Revision$ $RCSfile$

=TEX
% dtd005.doc %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol,11pt,TQ]{article}

\TPPtitle{File and Terminal Reader Writer}
\TPPref{DS/FMU/IED/DTD005}
\TPPissue{$Revision$%
}

\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{IED 1563}

=IGN

Commands to process this document in various ways.

doc4tex dtd005
tex4dvi dtd005
bibtex dtd005
doc4tex dtd005 ; tex4dvi dtd005
pstex dtd005

lasp -s dtd005.doc > zz1
lasp -s -u dtd005.OKwords dtd005.doc > zz1

=TEX
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Standard}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the detailed design for the reading
	and writing functions that form the outermost level of user
	interface for Release~1 of ICL~HOL.  These functions are
	concerned with the differentiation of the various languages
	(initially Standard~ML and HOL), and the extensions to support
	pretty characters in Standard~ML identifiers and in strings.}
\TPPabstractB{This version of the document should be regarded as a
	placeholder, pending the creation of the proper document.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

%\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage
\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [1 February 1991, issue 1.1 ]  First draft version, providing a
	place holder pending the creation of the proper document.

\item[21 February 1991, issue 1.2 ]  Added some extra details.

\item[6 March 1991, issue 1.3 ]  Add structures $ReaderWriterSupport$
	and $HOLReaderWriter$, and details of error messages.

\end{description}
%\subsection{Changes forecast}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{GENERAL}
\subsection{Scope}

This document contains a detailed design of the file and terminal
reading and writing functions, called for by~\cite{DS/FMU/IED/DEF002}
which discusses the lexical nature of the Release 1 ICL HOL.  The
design is implemented in \cite{DS/FMU/IED/IMP005}.

This version of the document should be regarded as a
placeholder, pending the creation of the proper document.

\subsection{Introduction}

Three routines for reading Standard~ML text with embedded pretty
characters are provided.  There is some incomplete support for
languages other than Standard~ML, attempting to use it will provoke a
failure exception from this package, or an error message from the
PolyML parser.


\section{READER WRITER}

%--------------------------------------------------------------------
=DOC
signature ‚ReaderWriter· = sig
=DESCRIBE
File and terminal reading and writing functions.
=FAILUREC
Several error messages are provided to report faults in the users
textual input to the ICL HOL system, they may be produced from all of
the routines $usefile$, $usestring$ and $useterminal$.  Some error
messages might be associated with particular routines in the reader
writer support $ReaderWriterSupport$ structure but that is incidental
to most users, so they are all gathered here.
=FAILURE
5001	End of file found in comment
5002	Unexpected symbol ?0 (a symbol of type $Invalid$ has been read)
5003	Unknown keyword %?0
5004	Unknown pretty character `?0' (decimal ?1)
5005	Bracket mismatch.  `?0' found after an opening `?1'
5007	End of file found in string
5008	Improper `QQ' keyword found at start of: `?1'
5009	Given ?0 but expected a positive value
5010	Unexpected length of ?1 for value ?0
5011	Character literal without closing prime
5012	Character literal is empty or too long 
5013	Character literal unexpected character `?0' after `\\^'
=ENDDOC
=IGN
5006	-- unused --
5014	-- unused --
%--------------------------------------------------------------------
=DOC
val ‚usefile· : string -> unit;
=DESCRIBE
Read Standard~ML with pretty characters allowed, from the named file.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚usestring· : string -> unit;
=DESCRIBE
Read Standard~ML with pretty characters allowed, from the given string.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚useterminal· : unit -> unit;
=DESCRIBE
Read Standard~ML with pretty characters allowed, from the terminal.
This routine takes over the terminal, it handles all exceptions as the
outermost level of the ML system.  To return to the default PolyML
terminal reader use $abandon_reader_writer$.

This routine prompts to the conventions of PolyML but uses the strings
``{\tt:>~}'' and ``{\tt:>~}'', the PolyML prompts do not have the
colon.

Typing control-D, or reading the end-of-file, causes the function
$PolyML.quit$ to be called.

Typing control-X to this routine (when it is looking for input)
abandons the current {\em topdec.}
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚abandon_reader_writer· : unit -> unit;
=DESCRIBE
Only meaningfully used after $useterminal$ has been called, when it
forces an exit from that routine.
=ENDDOC
%--------------------------------------------------------------------

\subsection{Supporting Other Languages}

A large part of the reader writer interface allows the embedding
of other languages.

The style of the interface should\footnote{To be done.} be documented
here.  Most of the required information is contained within the
implementation document.  The descriptions that follow assume that such
a description has been seen by the reader of this document.

Many routines have an argument of type $READER_ENV$ which provides the
functions to read characters from the current input stream.  This 
argument is not detailed with each function, but a reference to the
type declaration is made.

%--------------------------------------------------------------------
=DOC
structure ‚ReaderWriterSupport· : sig
=DESCRIBE
A set of declarations that allows the addition of new embedded
languages.  The HOL language is an example of a language embedded into
a basic system that understands Standard~ML with pretty characters and
percent keywords.
=ENDDOC
%--------------------------------------------------------------------
=DOC
type ‚READER_ENV·;
=DESCRIBE
All of the parsing functions in the reader writer support use the functions
provided in this record type to read characters from the current input stream.
Attempting to read characters by any other method will have unpredictable
results.
=ENDDOC
%--------------------------------------------------------------------
=DOC
structure ‚PrettyNames· : sig
=DESCRIBE
A structure within $ReaderWriterSupport$ that gathers all the
information relating the pretty characters and percent keywords
understood by the system, together with the interfaces for
interrogating and extending the information.
=ENDDOC
%--------------------------------------------------------------------
=DOC
	datatype ‚AFFINITY· = ‚Affable· | ‚Singular·;

	datatype ‚NAME_CLASS·
		=	‚Simple·	of AFFINITY
		|	‚Starting·	of string * (READER_ENV -> string list -> string list)
		|	‚Middle·	of string
		|	‚Ending·	of string
		|	‚Ignore·
		|	‚Invalid·
		|	‚Separator·;
=DESCRIBE
These detail the characteristics of a symbol.  $Simple$ is used for
symbols that may be part of identifiers.  $Starting$, $Middle$ and $Ending$
relate to the symbols position when embedding text of other languages.
The symbol is effectively macro expanded to produce the string value of these
three constructors.  The function with $Starting$ is the reader routine for
the particular embedded language.  Details of how this function should be
written are given in the implementation document corresponding to this
design.  $Ignore$ is used for characters that are completely ignored in the
input, the pretty characters for indexing come in this category.  $Invalid$
will cause an error message.  $Separator$ is used for symbols that
are always treated as separators, such symbols will have space characters
inserted before and after.
=SEEALSO
Error 5002
=ENDDOC
%--------------------------------------------------------------------
=DOC
	type ‚PRETTY_NAME·;
=DESCRIBE
Each symbol is defined in a three-element tuple of this type.  Elements
of the tuple are as follows.  First, a non-empty list of the keywords
that may used for this symbol, the preferred keyword is at the head of
the list.  These keywords exclude the leading percent sign.  Keywords
must be entirely alphanumeric except for the three special cases
``\verb|%<|'', ``\verb|%>|''and ``\verb|%=>|'', no validation is
performed to enforce this rule.  Second, an optional pretty character
for the symbol.  Third:  a value of datatype $NAME_CLASS$ indicating
the characteristics of the symbol.
=EXAMPLE
	([	"fn",
		"lambda"],	Value "ç",			Simple Singular),
=ENDDOC
%--------------------------------------------------------------------
=DOC
	val ‚add_new_symbols· : PRETTY_NAME list -> unit;
=DESCRIBE
Adds details of new symbols to the data structures characterising all
known symbols.  There is some validation of the symbols added, the list
of names should not be empty and the pretty character field should have
a single character with value greater than decimal~127.
=FAILURE
5015	Symbol has no keywords
5016	Invalid pretty character with keyword: ?0
=ENDDOC
%--------------------------------------------------------------------
=DOC
	val ‚find_name· : string -> PRETTY_NAME OPT
	val ‚find_char· : string -> PRETTY_NAME OPT

end (* of signature for structure PrettyNames *)
=DESCRIBE
Finds the characteristics of a symbol based on its keyword or character.
Both functions return $Nil$ if the symbol is not known.  They return
the tuple given to $add_new_symbols$ for known symbols.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚skip_comment· : READER_ENV -> unit;
=DESCRIBE
Skip over a comment which comprises a sequence of characters within
which the comment braces `{\tt (*}' and `{\tt *)}' are properly
balanced.  This routine is entered when the opening round bracket of
the comment has been read, the opening asterisk is the first unread
character.
=SEEALSO
Error 5001.
Type $READER_ENV$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚skip_format· : (READER_ENV -> string list -> string list)
		-> READER_ENV -> string list -> string -> string list;
=DESCRIBE
Read and discard any formatting characters in the initial part of the
input and replace them with a single space.  When a non-formatting
character is found continue by calling the parsing routine given as the
first argument.  The third argument is the left hand context which
must be passed on.  The fourth argument, the string, is required to be
the first unread character of the current input.  The result is the
concatenation of the left hand context, a space, and the results from
calling the first argument.
=SEEALSO
Type $READER_ENV$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚get_string· : READER_ENV -> string list -> string list;
=DESCRIBE
Assemble a string literal, as defined in~\cite[section~2.2,
page~3]{Milner90}, and add it to the left hand context given in the
second argument.  On entry the opening string quote has been read, exit
when the closing string quote has been read.  The goal of this routine
is to form an equivalent string that can be read by a Standard~ML
compiler, and to defer as much validation of the string as possible to
that compiler.  Minimal validation is performed on escape sequences.
Well-formed layout sequences (i.e., the sequence ``{\hbox{\verb|\|{\em
f..f\/}\verb|\|}}'' from~\cite[section~2.2, page~3]{Milner90}) are
removed, characters not recognised as formatting ones are retained and
wrapped between ``\verb|\ |'' and ``\verb| \|'' for later checking by
the Standard~ML compiler.  Pretty characters are translated to their
three digit decimal form.
=SEEALSO
Type $READER_ENV$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚get_percent_name· : READER_ENV
	-> (string * PrettyNames.PRETTY_NAME OPT * bool);
=DESCRIBE
Assemble a percent keyword and look it up in the list of known
keywords.  On entry the percent ({\tt\%}) is the first unread
character. The tuple returned contains:  the keyword read, but without
the {\tt\%} character; the symbols entry as given to $add_new_symbols$
or $Nil$ for an unknown keyword; and, a flag set true if the keyword
was alphanumeric, false otherwise.  Three non-alphanumeric keywords are
recognised``\verb|%<|'', ``\verb|%>|''and ``\verb|%=>|''.
=SEEALSO
Type $READER_ENV$.
Type $PRETTY_NAME$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚get_box_braces· : (READER_ENV -> string list -> string list)
		-> READER_ENV -> string list -> string list;
val ‚get_curly_braces· : (READER_ENV -> string list -> string list)
		-> READER_ENV -> string list -> string list;
val ‚get_round_braces· : (READER_ENV -> string list -> string list)
		-> READER_ENV -> string list -> string list;
=DESCRIBE
These functions assemble a section of bracketed text.  The opening
bracket has been read, the first unread character is the first
character within the brackets.  Each routine reads text upto and
including the matching closing bracket.  The first argument is the
parsing routine for reading items of text within the brackets.  The
third argument is the left hand context, which is returned with the
bracketed text read by these functions, and the enclosing braces.  The
three pairs of brackets: ``\verb|[ ]|'', ``\verb|{ }|'' and ``\verb|(
)|'' are handled by functions $get_box_braces$, $get_curly_braces$ and
$get_round_braces$ respectively.  The functions will report
error~5005 if the wrong closing bracket is supplied in the input
text.
=SEEALSO
Error 5005.
=ENDDOC
%--------------------------------------------------------------------
=DOC
val ‚get_ML_any· : READER_ENV -> string list -> string list
=DESCRIBE
Assemble a section of Standard~ML text starting with the first unread
character.  Text is read upto the first semi colon `{\tt;}' or
unmatched closing bracket.  A semi colon will be read and added to the
returned text, a closing bracket is left unread for the calling
routine.  The syntax error where too many closing bracket are presented
must be resolved by the outermost routine that calls function.  The
second argument gives the left hand context, the new text read is added
to that context and returned.
=SEEALSO
Type $READER_ENV$.
=ENDDOC
%--------------------------------------------------------------------
=DOC
exception ‚EndOfInput·;
=DESCRIBE
Associated with the reader functions is the exception $EndOfInput$
which is raised when the parser has read the end of the file and
has passed the end of file character at least once to the compiler.
Raising this exception signifies that nothing more can usefully be
done with the current input stream.
=ENDDOC
%--------------------------------------------------------------------


%--------------------------------------------------------------------
=SML
end (* of signature for structure ReaderWriterSupport *)
end (* of signature ReaderWriter *);
=TEX

\section{HOL READER WRITER}

%--------------------------------------------------------------------
=DOC
signature ‚HOLReaderWriter· = sig
end;
=DESCRIBE
There are no visible declarations in this structure, its purpose is to
add new entries to the structure that holds all the information
relating the symbols for pretty characters and percent keywords
understood by the system, together with the functions that understand
how to read HOL text.
=ENDDOC
%--------------------------------------------------------------------


\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
