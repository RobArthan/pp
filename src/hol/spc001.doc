% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{TECHNOLOGY PROJECTS}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{A Formal Specification of HOL}  %% Mandatory field
\TPPref{DS/FMU/IED/SPC001}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{
A formal specification, in HOL, of the HOL logic is presented.
Some high level aspects of the HOL proof development system
are also formalised.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      R.D. Arthan \\ M.J.C. Gordon (Cambridge) \\ R.B.Jones \\ K. Blackburn \\ G.M. Prout
}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue 1.7 (19/10/89)]
First draft for comment.
\item[Issue 1.11 (6/11/89)]
The second draft. A number of errors have been corrected
(mainly in the definitions of substitution and type
instantiation). Comments on the first draft have been
taken into account. The initial theory $INIT$ containing
the standard axioms is defined together with the set of
theories which are extensions of it via the conservative
extension mechanisms $new\_definition$ etc.
\item[Issue \SCCSversion (21/11/89)]
A number of errors have been corrected as a result
of work done on the Z translation.
The document reference and theory name have been changed for IED library structure.
The appendix discussing reformulations of the logic
has been removed. It will probably
be used as a starting point for a supplementary document.
\end{description}
\subsection{Changes forecast}
Some brief description of the Z-like notations used may
be added for the benefit of readers who are not familiar with it.
\newpage
\section{GENERAL}
\subsection{Scope}
This document is an attempt to specify the
syntactic aspects of the
HOL logic using the HOL system.
The document should be viewed as a formal treatment
of chapters 3, 4 and 5 of Mike Gordon's
description (\cite{gordon87}) of the HOL logic and proof development system.
The bulk of the document is concerned with defining the
logic. Some high level aspects of the implementation
of the proof development system are also discussed.
\subsection{Introduction}
Initially we had hoped to present the
specification to serve
both as a specification of the logic
(i.e. the formal theory
in the sense of a mathematical structure with terms,
well-formed terms, inference rules etc.) and the
system (i.e. the program which enable one
to calculate theorems).
However, in defining the logic
we frequently  found that attempts to
make the specification ``constructive'' tended to
obscure some issues. We have consequently erred on the
side of abstraction in most cases. For example, many
of the functions we need are partial functions: we
represent these as binary relations, rather than
approximate them with total functions.
This approach was felt to lead to a clearer
specification than would be obtained by using approximating
total functions together with checks on the arguments
supplied in each application.

In formalising the system we have, on occasion, felt
that certain changes would be desirable for one reason
or another. We have resisted all such urges ---
what is presented here is meant to be a rigorous
formulation of the logic as described in \cite{gordon87}.
Where \cite{gordon87} has proved a little too loose for our
purposes (e.g. in the details of type instantiation),
we have tried to follow the spirit of the HOL system.

During preparation of the specification we received
a draft of relevant chapters of the new HOL manual which
is currently being prepared at Cambridge. 
There are some differences of terminology
between the new manual and our treatment.
However, we have tried to adopt the treatment of the basic
theories given in the new manual.

\subsection{Defining Logics}
It may be helpful to discuss some generalities about
the definition of logics, in order to set in context the
specific constructions we will make to specify HOL.
Readers who know what to expect are invited to skip this
section.

If we apply Occam's Razor fairly viciously to the
sort of definition one finds in, e.g., Mendelson's
textbook on logic \cite{mendelson87},
one finds that
a logic\footnote{
Mendelson calls it a {\it formal theory}. The terms
{\it deductive system}, {\it formal system} and others are also used.}
is
given by a set, $S$, whose elements we will call sentences
in this section, and a subset
$I$ of $\bigcup_{n=1}^{\infty}S^n$.
One says that $x \in S$ is {\em directly derivable} from
$X \subseteq S$ if for some $n$,
$(X^{n-1} \times \{x\}) \cap S \not= §$. One then says that
$x \in S$ is {\em derivable} from $X \subseteq S$,
if for some sequence $x_1,x_2, \ldots, x_k$ of elements
of $S$, $x_k = x$ and, for each $i$, $x_i$ is
either in $X$ or is directly derivable from
$\{x_1,x_2, \ldots, x_{i-1}\}$.
One says that $x \in S$ is a {\em theorem} if it
is derivable from $§$.

In practice, $S$ is usually defined by a decidable
``well-formedness'' predicate on the free algebra, $F(\Omega)$,
over some signature, $\Omega$, and
$I$ is given as the union of a set of decidable
$n$-ary relations (the rules of inference).

The above ideas, while of theoretical value, are not
sufficient for a practical proof development system like
HOL, since, in such a system, the user can introduce
new constructs into the language $S$ by modifying
the signature $\Omega$, and can assert that certain
sentences in the extended language,
$S(\Omega)$, are axioms. For example, when a new constant
is defined in HOL, the language is extended to include
the new constant and an axiom that the constant
is equal to the value given in its definition is asserted.

Let us assume that the well-formedness predicates
and inference rules are defined so as to apply to
sentences over any signature the user can define.
This may be achieved by restricting the signatures
to be subsignatures of a signature $\Sigma_{max}$.
A predicate over $F(\Sigma_{max})$ 
then restricts to a predicate over $F(\Omega)$ for
any subsignature, $\Omega$, of $\Sigma_{max}$, and,
similarly, any set of rules of inference over
$L(\Sigma_{max})$ restricts to a set of rules of inference
over $S(\Sigma_{max})$.
Let us assume that a well-formedness predicate and
a set of rules of inference have been defined for
some signature $\Sigma_{max}$.

Let us define a  {\it theory}. to be a
pair $(\Omega, X)$, where $\Omega$ is a subsignature
of $\Sigma_{max}$ as above,
and $X \subseteq S(\Omega)$. X is the set of axioms
of the theory.
A {\it theorem} in a theory, $(\Omega, X)$, is a
sentence in $S(\Omega)$ which is derivable from $X$
(with respect to the rules of inference restricted
to $S(\Omega)$).
Thus the axioms, $X$, act as additional unary rules of
inference.
Theories form a partially ordered set with respect to
inclusion. We will actually use {\it extension}: the relation
inverse to inclusion.

(The signature part of a theory can in many cases of
interest be omitted. For example, treatments of first-order
logic commonly offer an infinite supply of constant
letters and predicate letters for use in constructing
sentences. This corresponds to insisting
that each signature $\Omega$ is equal to $\Sigma_{max}$
in the above formulation. The more general
treatment discussed here seems more appropriate to HOL.)


The rules of inference over $S(\Sigma_{max})$
induce rules of inference on the sentences in the
language of a given theory. The theorems of the theory
$(\Omega, X)$ are then precisely the sentences in
$S(\Omega)$ which are derivable from $X$ using the
induced inference rules. 

A theory is {\em consistent} if
not every sentence in its language is a theorem.
Of particular interest in a practical proof development
system are mechanisms for extending a theory which
preserve consistency.
A theory $T_1$ is a {\it conservative
extension} of a theory $T$ if $T_1$ extends $T$
and all sentences in $L(T)$ which are theorems
in $T_1$ are also theorems in $T$. Clearly conservative
extensions preserve consistency. 

\subsection{Overview of the Specification}
\subsubsection{The Logic}
Our treatment of the HOL logic follows approximately
the pattern discussed in the previous section.
However, since we are only interested in a particular
class of languages we do not do any general universal
algebra.
Thus, apart from a minor complication, defining our
version of
$F(\Sigma_{max})$ and $L(\Sigma_{max})$
amounts
to specifying the abstract syntax for HOL terms and
the subset of terms which are well-typed (ignoring
context-sensitive constraints such as the agreement
of the arity of a type with that given in some definition). This is done in section \ref{TYPESANDTERMS}.

The minor complication is that
HOL is defined as a sequent calculus.
Sequents are defined in section \ref{SEQUENTS}.
It is the sequents which make up our $L(\Sigma_{max})$.

In our general discussion above we have not
prohibited unary rules of inference, i.e. axioms by
another name. Such rules are a convenient home
for those axioms which we wish to have in every theory.
The HOL logic has three axiom schemata which are naturally
given as unary rules. These
are defined in section \ref{AXIOMSCHEMATA}.
The other rules of inference are defined in section
\ref{RULESOFINFERENCE}.

With the rules of inference over $L(\Sigma_{max})$
in hand, we define derivability in section
\ref{DERIVABILITY} and then move on to consider
theories in section \ref{THEORIES}.
In our case, the signature part of a theory amounts to 
two ``environments'', one giving the arity of the type
constructors in the theory and the other giving
the types of the constants\footnote{
These correspond to the {\it type structures} and
{\it signatures} respectively in the new manual.}.
In addition to the environments and the axioms, our
theories also contain a set of theorems of the theory.
This enables the same notion of theory to be used in
describing the proof development system: the theorems
in the sets represent the theorems that the user has proved in that theory.
We then define the type of theorems of HOL as those pairs
$(s, T)$ where $T$ is a theory and $s$ is a sequent in the
language of $T$ derivable from the axioms of $T$.

Section \ref{CONSISTENCY},
defines the type of all theorems and
specifies the notions of consistency and conservative
extension.

Mechanisms for extending theories by
making definitions are of great practical
importance, particularly those which preserve consistency.
Section \ref{DEFINITIONS} discusses
the means by which theories may be extended in the HOL
system. Of particular importance are certain mechanisms
for introducing new constants and types.

In section \ref{INIT} we define the individual axioms
of the HOL logic.
The resulting theory is of special
interest, as are what we call its standard extensions,
which we define in section \ref{STANDARD}:
they are all consistent and have
a common standard set-theoretic model;
their theorems comprise what are normally taken to
be the theorems of HOL by those who shun axiomatic
extensions.

\subsubsection{The HOL System}

In sections \ref{RULESOFINFERENCEREVISITED}
and \ref{THEORYHIERARCHIES}
we turn to specifying some high level aspects of
the HOL proof development system.
Many of the types and functions used to specify
the logic may already be viewed as specifying
corresponding parts of the implementation.
We now wish to specify a generic type representing
the state of the HOL system together with some
useful operations for modifying that state.


The designer of a proof development system
is interested in ensuring
that the theorems which the users compute are indeed
derivable from the axioms of the theory involved.
The LCF approach to this problem is to use
a programming language supporting the
abstract data type concept. Theorems are represented
as elements of an abstract
data type whose constructor functions consist
precisely of the rules of inference (suitably parameterised
so that they are partial functions rather than arbitrary
relations).
In this way, the type system of the programming
language helps to ensure that only valid theorems may be
derived. In section \ref{RULESOFINFERENCEREVISITED} we
define the action of the rules of inference on
our type of theorems. These definitions can be viewed as a high level
specification of the constructor functions of the
abstract data type.
Such functions are used to
extend the set of theorems stored within a theory.


Finally, section \ref{THEORYHIERARCHIES} discusses
an abstraction of the database side of the proof development
system.
The concept of a named hierarchy of theories
is introduced and an abstraction of the state of
an HOL proof development system is presented.
Given this, we can define the generic type of an HOL
system and so define general predicates on such systems,
e.g., {\it safety:} the property of those HOL systems
which only allow consistent extensions.
In producing a very high assurance implementation
of HOL, this would give the starting point for some
meaningful proof work: one might attempt to prove 
the safety of a design which was founded on
the theorem proving mechanisms of section
\ref{RULESOFINFERENCEREVISITED} and the (conservative)
definitional mechanisms of section \ref{DEFINITIONS}.

\subsection{Introducing the new theory}

\Hide{
extend_theory`spc001`;;
map loadf [`TAUT`;`infra`];;
lemmas_on := false;;
garbage_collection_diags false;;
}
We introduce the new theory. Its parents are
library theories which we will use later.
We set some controls for the infrastructure which
supports the Z-like definition mechanism and for the
ML system. We 
Â
new_theory`spc001`;;
map new_parent [`string`; `infra`; `set`];;
map loadf [`infra`];;
lemmas_on := false;;
garbage_collection_diags false;;
Ê
The following ML detects what was a common source of
error in earlier versions of this document.
It adds an extra check to the handling of constant and schema
definition boxes.
Â
let standard_const_def = const_def;;
let standard_schema_def = schema_def;;
let check_def tm = 
	let msg1 =`check_def: free variable `
	in let msg2 = ` found in predicate of definition`
	in let (names, def_frees) = ((frees # frees) o dest_pair) tm
	in (map (çxémem x names => () | prt_string (msg1^(fst(dest_var x))^msg2)) def_frees; ());; 
let const_def tm = (check_def tm; standard_const_def tm);;
let schema_def name abb tm = (check_def tm; standard_schema_def name abb tm);;
Ê
The generalised union operation and the function $card$,
which assigns to a finite set the number of its elements,
are currently not available in the particular version of
the HOL infrastructure used here. We specify them here
for completeness. The definitions will be removed when
a more up-to-date version of the infrastructure is
available for use here.
»
	£ : ((* ã bool) ã bool) ã (* ã bool)
…
	É sets x é x ù £ sets = Ñsetéx ù set Ä set ù sets
À

»
	card : (* ã bool) ã Ü
…
		(card § = 0)
	Ä	É x é (card(singleton_set x) = 1)
	Ä	É set xé card(set ƒ singleton_set x) = card set - card (set † singleton_set x)
À

\section{THE SYNTAX OF TYPES AND TERMS} \label{TYPESANDTERMS}

In this section we define the abstract syntax of HOL terms
and of the types which they contain.
The terms will be given as a subtype of a type of ``free
terms''. The subtype will comprise the terms which
are well-typed in a sense we will define shortly.

The well-formedness check does not consider
context-sensitive issues such as
conformance of the type of a
constant or the arity of a type
with the definition of the constant or type ---
such considerations are deferred until we have defined the
notion of a theory.
To some extent this approach is forced on us
since we wish to define a type of well-formed terms.
Since the system does not permit dependent types the
well-formedness predicate cannot be parameterised by
any form of context.

To define types for the various syntactic classes,
we use {\tt new\_type}. To populate them, we use
{\tt new\_constant} to define constructor functions.
To lend verisimilitude to our
account, we formulate an axiom for each new type which
characterises its constructor functions. The axiom
gives a principle of definition by structural recursion,
which might be used to justify the functions which we
will later specify on the types.
The consistency of the specification
could, we hope, be demonstrated using T.~Melham's
system for defining recursive types.
As things stand the rigour of our specification is on a
par with that of a VDM or Z specification.

\subsection{Types}
As a consequence of our approach,
the syntactic class of HOL types is a free algebra.
It is only in the context of the type definitions within
a theory that a type can be ill-formed.

Â
new_type 0 `TYPE`;;

new_constant (`‚mk_vartype·`,":string ã TYPE");;

new_constant (`‚mk_type·`,":string â TYPE list ã TYPE");;

let ‚TYPE_axiom· = new_axiom(`TYPE_axiom`,"
	É(f0:string ã *) (f1: string â TYPE list ã * list ã *)é
        ¿ (fn:TYPE ã *)é
         (Ésé fn(mk_vartype s) = f0 s) Ä
         (És tlé fn(mk_type (s,tl)) = f1 (s, tl) (map fn tl))
");;
Ê

We have need of the following destructor
function for composite types

»
	‚dest_type·: TYPE ã string â (TYPE list)
…
		dest_type o mk_type = I
À

\subsection{Free Terms}

The type {\it FTERM} is the syntactic class 
for the free algebra comprising
``HOL terms which are well-formed enough to parse, but
which are not necessarily well-typed''.
The syntactic class of HOL terms will be defined
as  a subset of {\it FTERM}.

Â
new_type 0 `FTERM`;;

new_constant (`‚mk_fvar·`,":string â TYPE ã FTERM");;

new_constant (`‚mk_fconst·`,":string â TYPE ã FTERM");;

new_constant (`‚mk_fcomb·`,":FTERM â FTERM  ã FTERM");;

new_constant (`‚mk_fabs·`,":string â TYPE â FTERM  ã FTERM");;

let ‚FTERM_axiom· = new_axiom(`FTERM_axiom`,"
	É
	(f0:string â TYPE ã *)
	(f1:string â TYPE ã *)
	(f2: FTERM â FTERM ã * â * ã *)
	(f3: string â TYPE â FTERM ã * ã *)é
        ¿ (fn:FTERM ã *)é
         (És tyé	fn (mk_fvar (s, ty))
			= f0 (s, ty))
	Ä  (És tyé	fn(mk_fconst (s, ty))
			= f1 (s, ty))
	Ä  (Éf aé	fn(mk_fcomb (f, a))
			= f2 (f, a) (fn f, fn a))
	Ä  (Év ty bé	fn(mk_fabs (v, ty, b))
			= f3 (v, ty, b) (fn b))
");;
Ê

\subsection{Free Variables}
To illustrate how the principle of definition
by structural recursion for the type {\it FTERM}
might be used, we specify some simple functions
which are useful later and whose specifications could
be proved consistent using it.

{\it freevars\_fset} returns the set of free variables
of a term.
We use it in cases where the order of appearance
of the free variables in the term is immaterial.

»
	‚freevars_fset·: FTERM ã (string â TYPE ã bool)
…
	É(s : string) (t : TYPE) (f : FTERM)
	(a : FTERM) (v : string) (b : FTERM) é
	(freevars_fset (mk_fvar(s,t)) = çxé x = (s,t))
Ä	(freevars_fset (mk_fconst(s,t)) = çxé F)
Ä	(freevars_fset (mk_fcomb(f, a)) =
			(freevars_fset f) ° (freevars_fset a))
Ä	(freevars_fset (mk_fabs(v, t, b)) =
			(freevars_fset b) ƒ çxé x = (v,t))
À

{\it freevars\_flist} returns the free variables of a term
listed in order of first appearance (from left to
right in the usual concrete syntax).

»
	‚freevars_flist·: FTERM ã ((string â TYPE)list)
…
	É(s : string) (t : TYPE) (f : FTERM)
	(a : FTERM) (v : string) (b : FTERM) é
	(freevars_flist (mk_fvar(s,t)) = [(s,t)])
Ä	(freevars_flist (mk_fconst(s,t)) = [])
Ä	(freevars_flist (mk_fcomb(f, a)) =
			freevars_flist f µ
			(freevars_flist a ¡ çxéx ∆ freevars_flist f))
Ä	(freevars_flist (mk_fabs(v, t, b)) =
			freevars_flist b ¡ çxé x à (v,t))
À

\subsection{Typing Terms}

We now give the relation which relates a free term
to its type, if it has one.

Note that two variables
with the same name but different types are simply
considered as different. This agrees with both
the HOL logic and the HOL system (in which, while a term
containing two such names in the same scope cannot
be entered directly  via the parser, the constructor functions 
may be used to achieve the effect).

We do not check here that the type assigned to
a constant is an instance of the type with which it
is declared. Indeed, the mechanisms needed to do
this involve the notion of a theory, which is defined
in a later section.

A function returning object language\footnote{
The observant reader will notice at least
four languages in this document: English as a
metametametalanguage, ML as a metametalanguage,
HOL as a metalanguage and the HOL language we are defining.
We will use the term {\it object language} exclusively
for the last of these.} function types is useful:

»
	‚Fun· : TYPE ã TYPE ã TYPE
…
	É ty1 ty2éFun ty1 ty2 = mk_type(`ã`, [ty1; ty2])
À
Note that, since we think if $type\_of\_fterm$ as a binary
relation rather than a set valued function, we use a slightly
different style for its definition from that used for, say,
$freevars\_fset$.
»
	‚type_of_fterm·: FTERM ã TYPE ã bool
…
	É(s : string) (t : TYPE) (ty: TYPE)
	 (f : FTERM) (a : FTERM) (v : string)
	 (b : FTERM) é
	(type_of_fterm (mk_fvar(s,t)) ty = (t = ty))
Ä	(type_of_fterm (mk_fconst(s,t)) ty = (t = ty))
Ä	(type_of_fterm (mk_fcomb(f, a)) ty = 
		Ñt1é(type_of_fterm f (Fun t1 ty)) Ä (type_of_fterm a t1))
Ä	(type_of_fterm (mk_fabs(v, t, b)) ty = 
		Ñt1é(type_of_fterm b t1) Ä (Fun t t1 = ty))
À

\subsection{Well-Formedness and the Type of Well-Formed Terms}

A term is well-formed if it has a type:

»
	‚is_wf_term· : FTERM ã bool
…
	Éterm:FTERMé
	is_wf_term term = Ñtype:TYPEé type_of_fterm term type
À

We now define the type {\it TERM} of well-formed terms
as a subtype of the type {\it FTERM} of free terms.

Â
	sim_type_def `‚TERM·` ("x:FTERM, is_wf_term x");;
Ê

Constructor functions for the type $TERM$
could be defined as composites in terms of
the constructor functions for $FTERM$ and
the abstraction and representation functions for
$TERM$. E.g., $\it mk\_comb\,\,=\,\,ABS\_TERM\,o\,mk\_fcomb$
Unfortunately the resulting function
$mk\_comb$ is not a total function.
Attempts to use an approximating total function turn out
to lead to difficulties when we wish to define functions
on terms by cases.
Thus we must use relations, at least for $\it mk\_comb$.
For uniformity we do this in all four cases.
The implementations will exploit the fact
that these relations correspond to partial functions.

In our informal discussions below we will often use the
names $mk\_var$, $mk\_const$, $mk\_comb$ and $mk\_abs$
to refer to these relations viewed as partial functions
(i.e. with applicative notation). We actually define
total functions which approximate the partial functions
when we need, later on, to define a number of particular
terms.

The names chosen for the relations are intended to be
suggestive of phrases like: {\it(`1', ``:num'') has mk\_var 
``1''}.
»
	‚has_mk_var· : string â TYPE ã TERM ã bool
…
	É s ty tm é has_mk_var (s, ty) tm = tm = ABS_TERM (mk_fvar(s, ty))
À
»
	‚has_mk_const· : string â TYPE ã TERM ã bool
…
	É s ty tm é has_mk_const (s, ty) tm = tm = ABS_TERM (mk_fconst(s, ty))
À
»
	‚has_mk_comb· : (TERM â TERM) ã TERM ã bool
…
	É f a tm é
	has_mk_comb (f, a) tm =
	let rep = mk_fcomb(REP_TERM f, REP_TERM tm)
	in
	(is_wf_term rep Ä (tm = ABS_TERM rep))
	
À
»
	‚has_mk_abs· : (TERM â TERM) ã TERM ã bool
…
	Év b tm é has_mk_abs (v, b) tm =
	(Ñ s ty é has_mk_var (s, ty) v Ä (tm = ABS_TERM(mk_fabs(s, ty, REP_TERM b))))
À

We also define functions for typing terms and extracting
free variables using the ones we have already defined
for free terms:

»
	‚type_of_term· : TERM ã TYPE
…
	É tm é  type_of_fterm (REP_TERM tm) (type_of_term tm)
À
»
	‚freevars_set· : TERM ã (string â TYPE ã bool)
…
	freevars_set = freevars_fset o REP_TERM 
À
»
	‚freevars_list· : TERM ã ((string â TYPE) list)
…
	freevars_list = freevars_flist o REP_TERM 
À

\section{SYNTAX OF SEQUENTS} \label{SEQUENTS}
A sequent is simply a set of assumptions
and a conclusion. Assumptions
and conclusion alike are just terms.
The following definition allows infinite
assumption sets, since they are easier for us to define.
However the axioms with which we shall work all have
finite sets of assumptions and the inference rules
will preserve this property.
Another pleasant property of sequents is for their
constituent terms to have type \Bool. This property,
too, holds of our axioms and is preserved by our inference
rules. When we define theories we insist that the
sequents in them have the latter property.

Â
new_type_abbrev(`‚SEQ·`, ":(TERM ã bool) â TERM");;
Ê

The following functions on sequents are useful for reasons
of clarity. Their names are as in the HOL system. 
»
	‚concl· : SEQ ã TERM
…
	concl = SND 
À

»
	‚hyp· : SEQ ã (TERM ã bool)
…
	hyp = FST 
À


\section{THE RULES OF INFERENCE} \label{RULESOFINFERENCE}

In this section we treat the syntax manipulating
functions required to define the various rules of
inference. We consider each inference rule in turn.
In the HOL system the inference rules are functions
which take theorems (and other things) as arguments
and return theorems. Since we cannot define
the type of theorems until we have defined the inference
rules we define the rules as functions taking
sequents (and other things) as arguments and returning
sequents.

\subsection{Object Language Constructs}

To define the rules of inference we need to form
certain object language types and terms.
We have already defined the function space type
constructor.
The other definitions needed are given in this
section.

We need the constant type \Bool:
»
	‚Bool· : TYPE
…
	Bool = mk_type(`bool`, [])
À

We need to form instances of the polymorphic constant
``='':

»
	‚Equality· : TYPE ã TERM
…
	É ty é Equality ty = átéhas_mk_const(`=`, Fun ty (Fun ty Bool)) t
À

The following is our analogue of the derived
constructor function for equations in the HOL system.

»
	‚has_mk_eq· : (TERM â TERM) ã TERM ã bool
…
	É lhs rhs tm é has_mk_eq(lhs, rhs) tm =
	(Ñ tm2 é
		has_mk_comb(Equality(type_of_term lhs), lhs) tm2
	Ä	has_mk_comb(tm2, rhs) tm)
À

We also need to form implications. The following functions
are analogous to those treating equality above.
»
	‚Implication· : TERM
…
	Implication = átéhas_mk_const(`ä`, Fun Bool (Fun Bool Bool))t
À

»
	‚has_mk_imp· : (TERM â TERM) ã TERM ã bool
…
	É lhs rhs tm é has_mk_imp(lhs, rhs) tm =
	(Ñ tm2 é
		has_mk_comb(Implication, lhs) tm2
	Ä	has_mk_comb(tm2, rhs) tm)
À


\subsection{Substitution of Equals: SUBST}

In this section we define the inference rule {\it SUBST}.

In essence, {\it SUBST} says that given a
theorem whose conclusion is an equation, ${\cal A} = {\cal B}$, where
$\cal A$ and $\cal B$ are arbitrary terms of the same
type, and given any other theorem with conclusion
$\cal C$, we may obtain a new theorem by substituting
$\cal B$ for 
any subterm of $\cal C$ which is identical with $\cal A$. This is subject to the proviso that no variable
capture problems arise, i.e. no
free variables of $\cal B$ should become bound in the
conclusion of the new theorem. (The assumption set of the
consequent theorem is the union of the assumption sets of
the antecedent theorems.)

The inference rule is, in fact, slightly more
general. It allows one to use a whole set of theorems
whose conclusions are equations to perform (simultaneous)
substitutions for many subterms of $\cal C$. Moreover,
it is implemented as a functional relation, effectively by
renaming any bound variables of $\cal C$ which would
give rise to the capture problem.

The inference rule is parametrised by a template term
and a set of some of its free variables, one for each equation.
The actual statement of the rule is, essentially, that, 
if the result of substituting the left hand sides
of the equations for the corresponding variables
in the template term
is equal to $\cal C$ ({\it modulo} renaming bound
variables), then we may infer the result of substituting
the right hand sides of the equations for the
corresponding template variables in the template term
(providing we rename bound variables to avoid the capture
problem).


The notions we must formalise are therefore: (i) renaming a variable in a term; (ii) testing equivalence of
terms {\it modulo} renaming of bound variables (aka.
$\alpha$-conversion); (iii) substituting terms for
free variables in a term according to a given mapping
of variables to terms avoiding variable capture.


\subsubsection{Renaming}
We will need to choose new names for variables.
More precisely,
given a variable and a set of same we will
wish to rename the variable, when necessary,
to ensure that the result
does not lie in the set.
In practice in an implementation we would insist that the new name
be derived from the old one in a specified way.

»
	‚variant· : (string â TYPE ã bool) ã (string â TYPE) ã string
…
	É vs v ty é ((v, ty) ì vs) => (variant vs (v, ty) = v) | (variant vs (v, ty), ty) ì vs
À

$rename (v, ty) w\, e$ is the result of changing
the name in every free occurrence of the
variable with name $v$, and type $ty$, in the
term $e$, to $w$, renaming any bound variables
as necessary.

»
	‚rename· : (string â TYPE) ã string ã TERM ã TERM
…
	É
	(v : string) (ty : TYPE) (w: string) (tm : TERM)
	(s :string) (tty : TYPE)
	(f : TERM) (a : TERM) (vty : TERM) (bb : TERM)
	é
	(has_mk_var (s, tty) tm ä
	(rename (v, ty) w tm =
			((v = s) Ä (ty = tty)) =>
			(átéhas_mk_var(w, ty)t) | tm))
	Ä
	(has_mk_const(s, tty) tm ä (rename (v, ty) w tm = tm))
	Ä
	(has_mk_comb(f, a) tm ä
	(rename (v, ty) w tm = átéhas_mk_comb(rename(v, ty) w f, rename(v, ty) w a)t))
	Ä
	((has_mk_abs (vty, bb) tm Ä has_mk_var(s, tty) vty) ä
	(rename (v, ty) w tm =
		((v = s) Ä (ty = tty)) =>
			tm |
		((w = s) Ä (ty = tty) Ä ((v, ty) ù freevars_set bb)) =>
			(let s' = variant (freevars_set bb ƒ singleton_set (v, ty) °
							singleton_set (s, ty)) (s, ty)
			in let vty' = rename (s, ty)s' vty
			in let bb' = rename (s, ty)s' bb
			in
			(átéhas_mk_abs(vty', rename (v, ty) w bb')t)) |
			(átéhas_mk_abs(vty, rename (v, ty) w bb)t)))

À


\subsubsection{$\alpha$-conversion}

»
	‚aconv· : TERM ã TERM ã bool
…
	É(t1 : TERM) (t2 : TERM)é
	aconv t1 t2 =
		(t1 = t2)
	Å	(Ñt1f t1a t2f t2aé
			has_mk_comb(t1f, t1a)t1
		Ä	has_mk_comb(t2f, t2a)t2
		Ä	aconv t1f t2f Ä aconv t1a t2a)
	Å	(Ñv1 v2 ty v1ty v2ty b1 b2é
			has_mk_abs(v1ty, b1)t1	Ä	has_mk_abs(v2ty, b2)t2
		Ä	has_mk_var(v1, ty)v1ty	Ä	has_mk_var(v2, ty)v2ty
		Ä	aconv b1 (rename (v2, ty) v1 b2)
		Ä	((v1 = v2) Å ((v1, ty) ì freevars_set b2)))
À

\subsubsection{Substitution}

The following function is useful in {\it subst} and
elsewhere. It sends a function to the function it induces
on the powersets of its domain and codomain.

»
›	‚image· :  (* ã **) ã (* ã bool) ã (** ã bool)
…
›	Éfunction seté image function set = 
›		çx:**é Ñy:*é (x = function y) Ä y ù set
À

Now we can define $subst$. $subst F t1$ gives the
term resulting from replacing every free variable
$mk\_var(s, t)$
in {\it t1} by $\it F(mk\_var(s, t))$ with bound
variables renamed as necessary to avoid capture.
Variables which are not to be changed correspond
to pairs $(s, t)$ with $F (s, t) =  mk\_var (s, t)$.
Note that we rely on $variant$
not to change bound variable names unnecessarily.

»
	‚subst· : (string â TYPE ã TERM) ã TERM ã TERM
…
	É (R :string â TYPE ã TERM) (tm : TERM)
	(s : string) (ty : TYPE) (vty : TERM)
	(f : TERM) (a : TERM) (b : TERM)
	é
	 
	(has_mk_var(s, ty)tm ä (subst R tm = R(s,ty)))
	Ä
	(has_mk_const(s, ty)tm ä (subst R tm = tm))
	Ä
	(has_mk_comb(f, a) tm ä
	(subst R tm = átéhas_mk_comb(subst R f, subst R a)t))
	Ä
	((has_mk_abs(vty, b) tm Ä has_mk_var(s, ty) vty) ä
	(subst R tm =
		let new_frees = £(image (freevars_set o R) (freevars_set b ƒ singleton_set (s, ty)))
		in  let s' = variant new_frees (s, ty)
		in let RR = çxé (x = (s', ty)) => (átéhas_mk_var x t) | R x
		in
			áté
			has_mk_abs
			((ávvttyéhas_mk_var(s', ty)vvtty), subst RR (rename (s, ty) s' b))t
	))
À

We can now define the inference rule.
Its first argument gives the correspondence between the
template variables and equation theorems.
We could take this argument to 
behave as {\it REFL\_axiom o mk\_var} on variables which
are not template variables . 
Note that, to allow implementation as a partial function,
we test up to $\alpha$-convertibility on the first
sequent argument only.

»
	‚SUBST_rule· : ((string â TYPE) ã SEQ) ã
			TERM ã SEQ ã SEQ ã bool
…
	É eqs tm old_asms old_conc new_asms  new_concé
	SUBST_rule eqs tm (old_asms, old_conc) (new_asms, new_conc) = 
	(Év ty é 
		Ñlhs rhsé
		has_mk_eq(lhs, rhs)(concl(eqs(v, ty))) Ä
		(type_of_term lhs = ty))
	Ä
	(aconv old_conc (subst(ç(v,ty)éálhséÑrhséhas_mk_eq(lhs, rhs)(concl(eqs(v,ty))))tm))
	Ä
	(new_conc = subst (ç(v,ty)éárhséÑlhséhas_mk_eq(lhs, rhs)(concl(eqs(v,ty))))tm)
	Ä
	(new_asms = old_asms ° £ (çasmséÑvtyéasms = (hyp (eqs vty))))
À



\subsection{Abstraction: ABS}

Again {\it ABS} is a partial function which we
specify as a relation:

»
	‚ABS_rule· : (string â TYPE) ã SEQ ã SEQ ã bool
…
	É vty old_asms old_conc new_asms new_conc é
	ABS_rule vty (old_asms, old_conc) (new_asms, new_conc) =
	(Ñ old_lhs old_rhs new_lhs new_rhs vé
		has_mk_eq(old_lhs, old_rhs)old_conc Ä
		has_mk_eq(new_lhs, new_rhs)new_conc Ä
		has_mk_var vty v Ä
		has_mk_abs(v, old_lhs) new_lhs Ä
		has_mk_abs(v, old_rhs) new_rhs)
	Ä
	(vty ì £(image freevars_set old_asms))
	Ä
	(new_asms = old_asms)
À



\subsection{Type Instantiation: INST\_TYPE}

The ability to prove and use general (polymorphic)
theorems  is one of the great strengths of the HOL
system. The feature in the inference system which
gives this strength is the inference rule {\it INST\_TYPE}
which allows us to instantiate the type variables
in the conclusion of a polymorphic theorem.

In essence, the inference rule says that, given a theorem
with conclusion $\cal A$ say we may infer the theorem
which has the same assumption set and whose conclusion
results from instantiating every type in $\cal A$
according to a given mapping of type variables to types.
This is subject to two provisos: (i) no type variable may
be changed which appears in the assumption set for the
theorem; (ii) no two variables in the assumptions or
conclusion of the antecedent theorem, which are
different, by virtue of their type,  should become
identified in the consequent theorem as a result of
the transformation.

The first proviso is, we believe, only enforced to preserve
a convention of natural deduction systems,
whereby inference rules
involve only simple set operations on the assumption
sets. It would seem to be quite in order for the first
proviso to be dropped provided we insisted that the
type instantiation be applied to every term in the sequent
(we have, of course, not done this).

The second proviso cannot be avoided. Consider for
example: $ç(x:**)éç(x:*)é(x:**)$. If the types in this were
instantiated according to $\{:** ó :*, :* ó :*\}$,
then from:
$$Ö É(y:**)(z:*)é(ç(x:**)éç(x:*)é(x:**))y z = y$$
we could infer that:
$$Ö É(y:*)(z:*)é(ç(x:*)éç(x:*)é(x:*))y z = y$$
whence, by $\beta$-conversions:
$$Ö É(y:*)(z:*)éz = y.$$
This leads to a contradiction whenever $:*$ is instantiated
to a type with more than one inhabitant.

To permit an implementation which is convenient to use,
the inference rule is actually formulated without the
second proviso. Instead, variables (both free and bound,
in general) in the conclusion of the consequent theorem,
which would violate the rule are renamed to
avoid the problem. It is valid to rename free variables
in these circumstances, given the first proviso, since
the variables in question cannot occur free in the
assumption set. Note that it would be invalid to
rename free variables in $\cal A$
which are not changed by the type instantiation
(since these may appear free in the assumption set).

Formalising these notions is a little tricky. We present
here a highly unconstructive specification, reminiscent
of $\alpha$-conversion.
The two notions to be formalised are: (i) the type
instantiation of a type given by a mapping of
type variables to types and (ii) the predicate on
pairs of terms which says that one is a type instance
of another according to a given mapping of type
variables to types and with respect to a set of
variables with which clashes must not occur (this
will be the set of free variables of the assumptions
in practice).

It is entertaining and instructive to consider
algorithms meeting these specifications.


\subsubsection{Instantiation of Types}
This is straightforward:
»
	‚inst_type· : (string ã TYPE) ã TYPE ã TYPE
…
	É(f: string ã TYPE) é
		(Ésé  inst_type f (mk_vartype s) = f s)
	Ä	(És tléinst_type f (mk_type(s, tl)) =
			mk_type(s, map (inst_type f) tl))
À

\subsubsection{Instantiation of Terms}

Instantiation of terms is a little tricky.
The following two functions should be viewed as
local to the function {\it inst}.
{\it inst\_loc1} is very similar to an
$\alpha$-convertibility test. Indeed {\it aconv} could
have been defined as $\it inst\_loc1\,I$.
The first {\it TERM} argument of {\it inst\_loc1}
and {\it inst\_loc2}
gives the terms whose types are being instantiated (i.e.
it is the ``more polymorphic'' term).

$inst\_loc1$ checks that one term, $tm2$, is a type
instance of $tm1$, according to a mapping from
type variable names to types given by $tysubs$,
under the assumption that the free variable names
agree, i.e. that the first occurrence of each variable which
may need renaming will be its binding occurrence in
a $ç-abstraction$.
»
	‚inst_loc1· : (string ã TYPE) ã TERM ã TERM ã bool
…
	É
	(tysubs : string ã TYPE)
	(tm1 : TERM) (tm2 : TERM)é
	inst_loc1 tysubs tm1 tm2 =
		(Ñtm1s tm1t tm2s tm2t has_Xé
			((has_X = has_mk_var) Å (has_X = has_mk_const))
		Ä	has_X(tm1s, tm1t)tm1 Ä has_X(tm2s, tm2t)tm2
		Ä	(tm1s = tm2s) Ä (tm2t = inst_type tysubs tm1t))
	Å	(Ñtm1f tm1a tm2f tm2aé
			has_mk_comb(tm1f, tm1a)tm1 Ä has_mk_comb(tm2f, tm2a)tm2
		Ä	inst_loc1 tysubs tm1f tm2f Ä inst_loc1 tysubs tm1a tm2a)
	Å	(Ñv1 v2 ty1 ty2 b1 b2 v1ty1 v2ty2 é
			has_mk_var(v1, ty1) v1ty1 Ä has_mk_abs(v1ty1, b1)tm1
		Ä	has_mk_var(v2, ty2) v2ty2 Ä has_mk_abs(v2ty2, b2)tm2
		Ä	inst_loc1 tysubs (rename (v1, ty1) v2 b1) b2
		Ä	(ty2 = inst_type tysubs ty1)
		Ä	åÑ ty3 v2ty3 é
				has_mk_var(v2, ty3) v2ty3
			Ä	(v2, ty3) ù freevars_set b1
			Ä	(ty2 = inst_type tysubs ty3)
			Ä	(v2ty3 à v1ty1) )
À

$inst\_loc2$ uses $inst\_loc1$ to check that a term $tm2$
is a type instance of the result of renaming free
variables of a term $tm2$ according to a mapping
given by a list of pairs. It also checks that
the type of the second variable in each pair in the list
is a type instance of the type of the first variable
in the pair,
and that the second variable in each pair
is not in the set, $avoid$, unless both names and types
agree for that pair.
In the application of $inst\_loc2$ in $inst$ the list
of pairs is obtained by combining the free variable lists
of the two terms side by side.
The set $avoid$ is a set of variables (coming from
the assumptions of a sequent) whose free occurrences
must not change as a result of the type instantiation.
»
	‚inst_loc2· : ((string â TYPE) ã bool) ã 
		(string ã TYPE) ã
		(((string â TYPE) â (string â TYPE)) list) ã
		TERM ã TERM ã bool
…
	É(avoid : (string â TYPE) ã bool)
	(tysubs :string ã TYPE)
	(v1 : string) (ty1 : TYPE)
	(v2 : string) (ty2 : TYPE)
	(rest : ((string â TYPE) â (string â TYPE)) list)
	(tm1 : TERM) (tm2 : TERM)é
	(inst_loc2 avoid tysubs [] tm1 tm2 =
		inst_loc1 tysubs tm1 tm2)
	Ä
	(inst_loc2 avoid tysubs (CONS ((v1, ty1),(v2, ty2)) rest) tm1 tm2 =
		((v2, ty2) ù avoid ä ((v1, ty1) = (v2, ty2)))
	Ä	(ty2 = inst_type tysubs ty1)
	Ä	inst_loc2 avoid tysubs rest
		(rename (v1, ty1) v2 tm1) tm2)
À

The following simple list processing function is
needed:

»
	‚combine· : (* list) ã (** list) ã ((* â **) list)
…
	É hd1 hd2 tl1 tl2é
	(combine [] [] = [])
	Ä
	(combine (CONS hd1 tl1) (CONS hd2 tl2) =
			CONS (hd1, hd2) (combine tl1 tl2))
À

With the above preliminaries we can now define {\it inst}.
Note that the condition that the free variable lists of
the two terms have the same length is required to ensure
that $inst\_loc2$ examines each free variable of each
term.

»
	‚inst· : ((string â TYPE) ã bool) ã
		(string ã TYPE) ã TERM ã TERM
…
	É((avoid : (string â TYPE) ã bool))
	(tysubs :string ã TYPE) (tm1 : TERM)é
	let tm2 = inst avoid tysubs tm1
	in let fl1 = freevars_list tm1
	in let fl2 = freevars_list tm2
	in
		((length fl1 = length fl2)
	Ä	inst_loc2 avoid tysubs (combine fl1 fl2) tm1 tm2)
À

We need to detect the type variables in a term.
We use some auxiliary functions to
do this: $type\_tyvars$ detects the type variables in
a type.

»
	‚type_tyvars· :  TYPE ã (string ã bool)
…
		(És:stringé  type_tyvars (mk_vartype s) = singleton_set s)
	Ä	(És tlé type_tyvars (mk_type(s, tl)) =
			£ çxé x ≈ (map type_tyvars tl))
À
$term\_types$ detects the types in a term.
»
	‚term_types· :  TERM ã (TYPE ã bool)
…
	É (tm : TERM) (s: string) (ty : TYPE)
	(f : TERM) (a : TERM) (v: TERM) (b: TERM)é
	(has_mk_var(s, ty)tm ä (term_types tm = singleton_set ty))
	Ä
	(has_mk_const(s, ty)tm ä (term_types tm = singleton_set ty))
	Ä
	(has_mk_comb(f, a) tm ä (term_types tm = term_types f ° term_types a))
	Ä
	(has_mk_abs(v, b) tm ä (term_types tm = term_types v ° term_types b))
À
$term\_tyvars$ detects all the type variables
in a term using the previous two functions.
»
	‚term_tyvars· :  TERM ã (string ã bool)
…
	Étm é term_tyvars tm = £(image type_tyvars (term_types tm))
À
$INST\_TYPE\_rule$ is now readily defined:
»
	‚INST_TYPE_rule· : (string ã TYPE) ã SEQ ã SEQ ã bool
…
	É tysubs old_asms old_conc new_seqé
	INST_TYPE_rule tysubs (old_asms, old_conc) new_seq =
	(É (tyv : string) é
		tyv ù £ (image term_tyvars old_asms) ä
		(tysubs tyv = mk_vartype tyv))
	Ä
	(let asms_frees = £ (image freevars_set old_asms)
	in
		(new_seq = (old_asms, inst asms_frees tysubs old_conc)))
À


\subsection{Discharging an Assumption: DISCH}

{\it DISCH} is, in essence,
the usual rule of natural deduction
which allows one to infer from a proof of $\cal B$
on the assumption $\cal A$, that
${\cal A} ä \cal B$ on no assumption.
The actual rule is suitably generalised to cover
sequents and their assumption sets. It is not
required that $\cal A$ be in the assumption set,
and the logic would probably not be complete
otherwise.

»
	‚DISCH_rule· : TERM ã SEQ ã SEQ ã bool
…
	É tm old_asms old_conc new_seq é
	DISCH_rule tm (old_asms, old_conc) new_seq =
	(type_of_term tm = Bool) Ä
	(new_seq = (old_asms ƒ singleton_set tm, átéhas_mk_imp(tm, old_conc)t))
À

\subsection{Modus Ponens: MP}

This is the usual rule: from ${\cal A} ä {\cal B}$
and ${\cal A}$, infer ${\cal B}$.
This generalises to sequents by taking the union
of the assumption sets.
 
»
	‚MP_rule· : SEQ ã SEQ ã SEQ ã bool
…
	É imp_asms imp_conc ant_asms ant_conc new_asms new_conc é
	MP_rule (imp_asms, imp_conc) (ant_asms, ant_conc) (new_asms, new_conc) =
	(has_mk_imp(ant_conc, new_conc)imp_conc) Ä
	(new_asms = imp_asms ° ant_asms)
À


\section{THE AXIOM SCHEMATA} \label{AXIOMSCHEMATA}


\subsection{The Axiom Schema ASSUME}

{\it ASSUME} allows us to infer
for any boolean term $\cal A$, that $\cal A$
holds on the assumptions $\{{\cal A}\}$.
This is straightforward to formalise. We must check
that the term being assumed is of the right type.
»
	‚ASSUME_axiom· : TERM ã SEQ ã bool
…
	É tm seq é ASSUME_axiom tm seq =
	(type_of_term tm = Bool) Ä 
	(seq = (singleton_set tm, tm))
À

\subsection{The Axiom Schema REFL}
{\it REFL} says that for any term $\cal A$,
we may infer that ${\cal A} = {\cal A}$ without
assumptions.

»
	‚REFL_axiom· : TERM ã SEQ
…
	É tm é REFL_axiom tm = (§, átéhas_mk_eq(tm, tm)t)
À

\subsection{The Axiom Schema BETA\_CONV}

{\it BETA\_CONV} says that, without any assumptions,
any $\beta$-redex is
equal to its $\beta$-reduction.
This is straightforward
to define, given the apparatus we used to define
{\it SUBST}.

»
	‚BETA_CONV_axiom· : TERM ã SEQ ã bool
…
	É tm new_seqé
	BETA_CONV_axiom tm new_seq =
	Ñ v ty vty b abs a é
	has_mk_var(v, ty) vty Ä
	has_mk_abs(vty, b)abs Ä
	has_mk_comb(abs, a)tm Ä
	(new_seq = 
	let subs: ((string â TYPE) ã TERM) =
		(ç(vx, tyx)é((vx = v) Ä (tyx = ty)) => a | átéhas_mk_var(vx, tyx)t)
	in
		(§, (átéhas_mk_eq(tm, subst subs b)t)))
À


\section{DERIVABILITY} \label{DERIVABILITY}


In this section we will define derivability.
This is a relation between sets of sequents
and sequents. As usual, we first define direct
derivability.
We include instances of the axiom schemata as valid
direct derivations from no premisses. This is merely
for convenience, we could equally well include all
instances of the axiom schemata as axioms in every theory
when theories are defined.

»
	‚directly_derivable_from· : SEQ ã (SEQ ã bool) ã bool
…
	É seq seqs é
	directly_derivable_from seq seqs = 
	(Ñ eqs tm old_seq é
	(image eqs (çxéT) • seqs) Ä (old_seq ù seqs) Ä SUBST_rule eqs tm old_seq seq)
	Å
	(Ñ vty old_seq é (old_seq ù seqs) Ä ABS_rule vty old_seq seq)
	Å
	(Ñ tysubs old_seq é (old_seq ù seqs) Ä INST_TYPE_rule tysubs old_seq seq)
	Å
	(Ñ tm old_seq é (old_seq ù seqs) Ä DISCH_rule tm old_seq seq)
	Å
	(Ñ imp_seq ant_seq é (imp_seq ù seqs) Ä (ant_seq ù seqs) Ä MP_rule imp_seq ant_seq seq)
	Å
	(Ñ tm é ASSUME_axiom tm seq)
	Å
	(Ñ tm é seq = REFL_axiom tm)
	Å
	(Ñ tm é BETA_CONV_axiom tm seq)
À
We need the following utility:

»
	‚elems· :  (* list) ã (* ã bool)
…
	É e s é e ù elems s Ç e ≈ s
À

Proofs will just be lists of sequents. Any non-empty
list is a valid proof (of the sequent at its
head) on the premisses given by those elements
of the list which are not directly derivable
from elements later in the list.
There is little point in making the relevant type
definition for a syntactic class of proofs in this sense,
since they contain so little information.
We simply define the function which extracts the set
of premisses.

»
	‚premisses· :  (SEQ list) ã (SEQ ã bool)
…
	É seq rest é
	(premisses [] = §)
	Ä
	(premisses (CONS seq rest) =
		(directly_derivable_from seq (elems rest) => § | singleton_set seq) ° premisses rest)
À


»
	‚derivable_from· : SEQ ã (SEQ ã bool) ã bool
…
	É seq seqs é
	derivable_from seq seqs =
	Ñ seql é premisses (CONS seq seql) • seqs
À

\section{THEORIES} \label{THEORIES}

The following type definitions help us to
formalise the context-sensitive aspects of the
well-formedness of terms, which we have avoided until
now. Once this is done we can define the type of all
well-formed HOL theories.

Â
new_type_abbrev(`‚TY_ENV·`, ":string ã num ã bool");;

new_type_abbrev(`‚CON_ENV·`, ":string ã TYPE ã bool");;

new_type_abbrev(`‚SEQS·`, ":SEQ ã bool");;
Ê


We can now define the well-formedness of types and terms with
respect to a type environment. We assume that
the names for type variables and type constructors
are in distinct lexical classes, and so all we
check is the arity of constructors.
(This agrees with the HOL system, except that the HOL
system imposes additional lexical constraints on the
names).
 
»
	‚wf_type· : TYPE ã TY_ENV ã bool
…
	É ty tyenv é
	wf_type ty tyenv = 
	(Ñs é ty = mk_vartype s)
	Å
	(Ñs tyl é (tyenv s (length tyl)) Ä É t é t ≈ tyl ä wf_type t tyenv)
À

For terms we place no restrictions on the names of
variables. (The HOL system tries to prevent constant
names being used as variable names but does not
always succeed, e.g, if the constant is declared after
a theorem using a variable with the same name has been
saved on a theory).

»
	‚wf_term·: TERM ã TY_ENV ã CON_ENV ã bool
…
	É s ty f a v b  tyenv conenv é
	let ok = çtmé wf_term tm tyenv conenv
	in
	É tm s ty f a v b é
	(has_mk_var(s, ty) tm ä (ok tm = (wf_type ty tyenv) Ä É t é å(conenv s t)))
Ä	(has_mk_const(s, ty) tm ä (ok tm = 
		(wf_type ty tyenv) Ä
		(Ñ ty' tysubsé (conenv s ty') Ä (inst_type tysubs ty' = ty))))
Ä	(has_mk_comb(f, a) tm ä (ok tm = (ok f) Ä (ok a)))
Ä	(has_mk_abs(v, b) tm ä (ok tm  = (ok v) Ä (ok b)))
À

The well-formedness of terms extends straightforwardly
to sequents and to sets thereof. We impose an
additional constraint for sequents: they must be
made up from terms of type \Bool.

»
	‚wf_seq·: SEQ ã TY_ENV ã CON_ENV ã bool
…
	É seq tyenv conenvé
	let ok = çtmé (wf_term tm tyenv conenv) Ä (type_of_term tm = Bool)
	in 
	(wf_seq seq tyenv conenv =
	((ok (concl seq)) Ä (Étmé (tm ù (hyp seq)) ä (ok tm))))
À

»
	‚wf_seqs·: SEQS ã TY_ENV ã CON_ENV ã bool
…
	É seqs tyenv conenvé
	wf_seqs seqs tyenv conenv = É seq é (seq ù seqs) ä (wf_seq seq tyenv conenv)
À

For the constant environments, we insist that the
type associated with each name be well-formed and
that at most one type is associated with each name.
Overloaded constant names could, in principle, be allowed,
as an extension to the system. This function would then be
modified to impose some weaker condition.

»
	‚wf_con_env·: CON_ENV ã TY_ENV ã bool
…
	É conenv tyenvé
	wf_con_env conenv tyenv =
	(É con tyé (conenv con ty) ä (wf_type ty tyenv)) Ä
	(É con ty1 ty2 é (conenv con ty1) ä (conenv con ty2) ä (ty1 = ty2))
À

We insist that at most one arity be associated with
each name in a well-formed type environment:

»
	‚wf_ty_env·: TY_ENV ã bool
…
	É tyenvé
	wf_ty_env tyenv =
	É ty n1 n2 é (tyenv ty n1) ä (tyenv ty n2) ä (n1 = n2)
À

We can now define the type of all theories whose
components are well-formed. We will then take the subtype
of this consisting of all theories which extend the
minimal one (with just the constants for equality
and implication and the type of propositions).

Note that a theory can contain infinitely many
types, constants, axioms or theorems. This possibility
occurs in practice, at least for constants and axioms.
The theory Ü of natural numbers is an example, since
it contains an axiom defining the decimal representation
of each positive number. 

«Õ`‚FTHEORY·``T`ÕÕÕÕÕÕÕÕÕÕﬂ
	ty_env		:TY_ENV,
	con_env	:CON_ENV,
	axioms		:SEQS,
	theorems	:SEQS
…ÕÕÕÕÕÕÕÕÕÕÕÕ
	(wf_ty_env ty_env) Ä
	(wf_con_env con_env ty_env) Ä
	(wf_seqs axioms ty_env con_env) Ä
	(wf_seqs theorems ty_env con_env) Ä
	(theorems • çseqéderivable_from seq axioms)
 ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ‡

The above introduces a new type S which may be
viewed as the labelled product of the types
$TY\_ENV$, $CON\_ENV$ etc.
New constants $T\_ty\_env$, $T\_con\_env$ are
also introduced. These are the projection functions
for the produce.

»
	‚Star· : TYPE
…
	Star = mk_vartype `*`
À

$MIN$ will be the minimal theory. It contains only
what is needed to define the inference rules.
Its representative in $FTHEORY$ is called
$FMIN$.
»
	‚FMIN· : FTHEORY
…
	(	FMIN.T_ty_env = çty n é
		(	(ty = FST(dest_type Bool)) Ä
			(n  = length(SND(dest_type Bool)))
		) Å (	(ty = FST(dest_type(Fun Bool Bool))) Ä
			(n  = length(SND(dest_type(Fun Bool Bool))))
		)
	) Ä (	FMIN.T_con_env = çs tyé
			(has_mk_const(s, ty)(Equality Star)) Å
			(has_mk_const(s, ty)Implication)
	) Ä (	FMIN.T_axioms = §
	) Ä (	FMIN.T_theorems = §
	)
À

Extension for objects of type {\it FTHEORY} is
the following binary relation:

Á
	fextends : FTHEORY ã FTHEORY ã bool
…
	É thy1 thy2é
	fextends thy1 thy2 =
	(UNCURRY(thy2.T_ty_env) • UNCURRY(thy1.T_ty_env)) Ä
	(UNCURRY(thy2.T_con_env) • UNCURRY(thy1.T_con_env)) Ä
	((thy2.T_axioms) • (thy1.T_axioms)) Ä 
	((thy2.T_theorems) • (thy1.T_theorems))
À

We restrict attention to theories which extend the
minimal theory {\it MIN}. Note that we do not
exclude inconsistent theories here. (This corresponds
to the possibility of introducing inconsistent axioms
in the HOL system).

Â
	sim_type_def `‚THEORY·`
	"(fthy : FTHEORY), (fthy fextends FMIN)";;
Ê

The definitions for the theory {\it MIN} and extension
of theories are derived from the
corresponding definitions for the representation type
{\it FTHEORY}.

»
	‚MIN· : THEORY
…
	MIN = ABS_THEORY FMIN
À
Á
	‚extends· : THEORY ã THEORY ã bool
…
	É thy1 thy2é
	extends (ABS_THEORY thy1) (ABS_THEORY thy2) =
	thy1 fextends thy2
À
The following functions on theories are useful in 
later definitions.
Note that {\it theorems} just gives the theorems
component of a theory. It does not return all the
consequences of the axioms of a theory.

»
	‚axioms· : THEORY ã SEQS
…
	É thy é axioms (ABS_THEORY thy) = (thy.T_axioms)
À
»
	‚types· : THEORY ã TY_ENV
…
	É thy é types (ABS_THEORY thy) = (thy.T_ty_env)
À
»
	‚constants· : THEORY ã CON_ENV
…
	É thy é constants (ABS_THEORY thy) = (thy.T_con_env)
À
»
	‚theorems· : THEORY ã SEQS
…
	É thy é theorems (ABS_THEORY thy) = (thy.T_theorems)
À

»
	‚sequents· : THEORY ã SEQS
…
	É seq fthy é
		(seq ù sequents (ABS_THEORY fthy)) Ç
		(wf_seq seq (fthy.T_ty_env) (fthy.T_con_env))
	
À

\section{THEOREMS, CONSISTENCY AND CONSERVATIVE EXTENSIONS}
\label{CONSISTENCY}

We can, at last, define the type of all HOL theorems.
A theorem will consist of a sequent and a theory.
The type is the subtype of the type of all such  pairs
in which the sequent is well-formed with respect to the
type and constant environments of the theory and in which
the sequent may be derived from the axioms of the theory.

«Õ`‚THM·``thm`ÕÕÕÕÕÕÕÕÕÕﬂ
	seq	: SEQ,
	thy	: THEORY
…ÕÕÕÕÕÕÕÕÕÕÕÕ
	(seq ù sequents thy)
	Ä
	(derivable_from seq ((REP_THEORY thy).T_axioms))
 ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ‡

(The projection functions for the above
type are called $thm\_seq$ and $thm\_thy$.)


A theory is consistent if not every sequent which
is well-formed in it can be derived from the axioms:

»
	‚consistent_theory· : THEORY ã bool
…
	É thy é
	consistent_theory thy =
	Ñ seq é
	(seq ù sequents thy)
	Ä
	å(derivable_from seq (axioms thy))
À
An extension of a theory is conservative if no sequent
of the smaller theory is provable in the larger but not
in the smaller.
Á
	‚conservatively_extends· : THEORY ã THEORY ã bool
…
	É thy1 thy2é
	conservatively_extends thy1 thy2 =
	(thy1 extends thy2) Ä
	(É seq é
	(seq ù sequents thy2) ä
	(derivable_from seq (axioms thy1)) ä
	(derivable_from seq (axioms thy2)))
	
À


\section{THE RULES OF INFERENCE REVISITED} \label{RULESOFINFERENCEREVISITED}

Given our type of theorems, we can now define
the inference rules as relations between theorems, rather
than sequences.  Essentially, we say that
if, by rule {\bf X}{\it\_rule}, we may infer the sequent $S$
from $S_1, S_2, \ldots$, then, by {\bf X}, we
may infer $(S, T)$ from
$(S_1, T_1), (S_2, T_2), \ldots$ provided
the theory $T$ is an extension of each $T_i$.

Proof theoretically this is no different from
a rule which insists that $T_i = T$ for all $i$.
The more general formulation is meant to accord a 
little better with the thinking of the user of the
proof development system and may allow more freedom
in an implementation. An implementation need
not exploit the full generality.
For example, in the current HOL proof development system
all proofs are, I believe, conducted in the context
of a particular theory called the {\it current} theory.
Thus the abstract data type representing theorems
does not need a theory component and the current theory
is, effectively, an implicit and unused parameter to
the constructor functions of the abstract data type.

The definitions of the inference rules for theorems
are derived directly and tediously from the corresponding
rules for sequences. In each case, we simply change
the sequent arguments to theorem arguments, and check
that the corresponding rule for sequents holds for
the sequent components of the theorems and that the
theory component of the theorem inferred extends that
of all the other theorem arguments.

»
	‚SUBST· : ((string â TYPE) ã THM) ã
			TERM ã THM ã THM ã bool
…
	É eqs tm old_thm new_thm é
	SUBST eqs tm old_thm new_thm =
	let old_seq = thm_seq old_thm in let old_thy = thm_thy old_thm
	in let new_seq = thm_seq new_thm in let new_thy = thm_thy new_thm
	in
	(SUBST_rule (thm_seq o eqs) tm old_seq new_seq
	Ä
	(new_thy extends old_thy) Ä
	(image (thm_thy o eqs)(çxéT) • $extends new_thy))
À
»
	‚ABS· : (string â TYPE) ã THM ã THM ã bool
…
	É vty old_thm new_thm é
	ABS vty old_thm new_thm =
	let old_seq = thm_seq old_thm in let old_thy = thm_thy old_thm
	in let new_seq = thm_seq new_thm in let new_thy = thm_thy new_thm
	in
	(ABS_rule vty old_seq new_seq Ä
	(new_thy extends old_thy)) 
À
»
	‚INST_TYPE· : (string ã TYPE) ã THM ã THM ã bool
…
	É tysubs old_thm new_thm é
	INST_TYPE tysubs old_thm new_thm =
	let old_seq = thm_seq old_thm in let old_thy = thm_thy old_thm
	in let new_seq = thm_seq new_thm in let new_thy = thm_thy new_thm
	in
	(INST_TYPE_rule tysubs old_seq new_seq Ä
	(new_thy extends old_thy)) 
À
»
	‚DISCH· : TERM ã THM ã THM ã bool
…
	É tm old_thm new_thm é
	DISCH tm old_thm new_thm =
	let old_seq = thm_seq old_thm in let old_thy = thm_thy old_thm
	in let new_seq = thm_seq new_thm in let new_thy = thm_thy new_thm
	in
	(DISCH_rule tm old_seq new_seq Ä
	(new_thy extends old_thy))
À
»
	‚MP· : THM ã THM ã THM ã bool
…
	É imp_thm ant_thm new_thm é
	MP imp_thm ant_thm new_thm =
	let imp_seq = thm_seq imp_thm in let imp_thy = thm_thy imp_thm
	in let ant_seq = thm_seq ant_thm in let ant_thy = thm_thy ant_thm
	in let new_seq = thm_seq new_thm in let new_thy = thm_thy new_thm
	in
	(MP_rule imp_seq ant_seq new_seq Ä
	(new_thy extends imp_thy) Ä (new_thy extends ant_thy))
À
The axiom schemata for theorems are even more straightforward
to define, since they hold in every theory. 
»
	‚ASSUME· : TERM ã THM ã bool
…
	É tm thm é ASSUME tm thm = ASSUME_axiom tm (thm_seq thm)
À
»
	‚REFL· : TERM ã THM ã bool
…
	É tm thm é REFL tm thm = ((thm_seq thm) = REFL_axiom tm)
À
»
	‚BETA_CONV· : TERM ã THM ã bool
…
	É tm thm é BETA_CONV tm thm = BETA_CONV_axiom tm (thm_seq thm)
À

\section{DEFINITIONAL EXTENSIONS} \label{DEFINITIONS}

\subsection{More Object Language Constructs}

A theory {\it LOG}
in which more of the standard logical apparatus is
available will be needed to define some of the definitional
extension mechanisms.

For example, {\it new\_type\_definition}
works with a theorem whose conclusion must be an
existentially quantified term of a particular form.
To define {\it LOG} we need some more object language
types and terms and these are defined in this section.
(It is convenient to leave the definition of {\it LOG}
itself until we have defined {\it new\_definition}.)

The formulation of the various logical connectives
follows the draft manual.

It is helpful now to
have the following term constructor functions.
Note that we are now using total functions to
approximate partial ones; we must, therefore, be
careful only to apply them to appropriate arguments.

»
	‚mk_var· : string â TYPE ã TERM
…
	mk_var = $á o has_mk_var 
À
»
	‚mk_const· : string â TYPE ã TERM
…
	mk_const = $á o has_mk_const 
À
»
	‚mk_comb· : TERM â TERM ã TERM
…
	mk_comb = $á o has_mk_comb 
À
»
	‚mk_abs· : TERM â TERM ã TERM
…
	mk_abs = $á o has_mk_abs 
À
»
	‚mk_eq· : TERM â TERM ã TERM
…
	mk_eq = $á o has_mk_eq 
À
»
	‚mk_imp· : TERM â TERM ã TERM
…
	mk_imp = $á o has_mk_imp 
À

We can now define the object language constructs needed.

% The following ML fragments are useful for checking %
% these definitions - they enable one to execute bits %
% of the HOL as ML and so see the terms pretty-printed%
% Note that this is a LaTeX and an ML comment. %
% The lines below are LaTeX comments %
% and each one starts with an ML comment! %
%% let Fun a b = mk_type(`fun`,[a; b]);;
%% let Bool = ":bool";; 
%% let Star = ":*";; let StarStar = ":**";;
\subsubsection{Truth}
The constant $T : bool$ is defined by the following equation:
$$T = ((ç(x:bool) é x) = (ç(x:bool) é x))$$

»
	‚Truth· : TERM
…
	Truth = mk_const(`T`, Bool)
À
»
	‚Truth_def· : TERM
…
	Truth_def = 
	let x = mk_var(`x`, Bool)
	in
	mk_eq(mk_abs(x, x), mk_abs(x, x))
À
\subsubsection{Universal Quantification}
The constant $É : (* ã bool) ã bool$ is defined by
the following equation:
$$\$É = (ç(P : * ã bool) é P = (ç(x:*) é T)$$

»
	‚Forall· : TYPE ã TERM
…
	É tyéForall ty = mk_const(`É`, Fun (Fun ty Bool) Bool)
À
»
	‚Forall_def· : TERM
…
	Forall_def =
	let P = mk_var(`P`, Fun Star Bool)
	in let x = mk_var(`x`, Star)
	in
	mk_abs(P, mk_eq(P, mk_abs(x,  Truth)))
À
»
	‚mk_forall· : (TERM â TERM) ã TERM
…
	É tm1 tm2émk_forall(tm1, tm2) = 	mk_comb(Forall (type_of_term tm1), mk_abs(tm1, tm2))
À
\subsubsection{Existential Quantification}
The constant $Ñ : (* ã bool) ã bool$ is defined
by the following equation, which defines $Ñ$ in terms
of the choice function $á: (* ã bool) ã*$:
$$\$Ñ = ç(P : * ã bool) é P(áP)$$
(This may be a little perplexing at first sight.
In the intended interpretations, given a predicate
$P : * ã bool$, if there is some $x : *$ for which $P$
is true (i.e. for which $P x = T$), then $á P$ is such
an $x$. I.e. taking as known the intuitive notion of
``whether or not something with a given property exists'',
$á$ chooses
something with a given property if such a thing exists.
The above definition can be viewed as taking as known
the informal notion of ``choosing something with a given
property'' and defining $Ñ$ to determine
whether or not something with a given property exists
by attempting to choose something with the given property and checking whether the attempt succeeded.)
»
	‚Choice· : TERM
…
	Choice = mk_const(`á`, Fun (Fun Star Bool) Star)
À
»
	‚Exists· : TYPE ã TERM
…
	É ty é Exists ty = mk_const(`Ñ`, Fun (Fun ty Bool) Bool)
À

»
	‚Exists_def· : TERM
…
	Exists_def = 
	let P = mk_var(`P`, Fun Star Bool)
	in let PchoiceP = mk_comb(P,mk_comb(Choice, P))
	in
	mk_abs(P, PchoiceP)
À
»
	‚has_mk_exists· : (TERM â TERM) ã TERM ã bool
…
	É tm1 tm2 tm3 é
	has_mk_exists(tm1, tm2) tm3 =
	has_mk_comb(Exists (type_of_term tm1), mk_abs(tm1, tm2))tm3
À
»
	‚mk_exists· : (TERM â TERM) ã TERM
…
	É tm1 tm2émk_exists(tm1, tm2) = 	mk_comb(Exists (type_of_term tm1), mk_abs(tm1, tm2))
À
\subsubsection{Falsity}
The constant $F:bool$ is defined by the following equation:
$$F = É(x:bool) é x$$
(Again this may seem perplexing. The type $bool$
is intended to contain the truth values. The above definition
says that false is the truth value of the proposition that
every truth value is true!)
»
	‚Falsity· : TERM
…
	Falsity = mk_const(`F`, Bool)
À
»
	‚Falsity_def· : TERM
…
	Falsity_def =
	let x = mk_var(`x`, Bool)
	in
	mk_forall(x, x)
À
\subsubsection{Negation}
The constant $å:bool ã bool$ is defined by the following
equation:
$$\$å = ç(b:bool)éb ä F$$
»
	‚Negation· : TERM
…
	Negation = mk_const(`å`, Fun Bool Bool)
À
»
	‚Negation_def· : TERM
…
	Negation_def =
	let b = mk_var(`b`, Bool)
	in
	mk_abs(b, mk_imp(b, Falsity))
À
\subsubsection{Conjunction}
The constant $Ä: bool ã bool ã bool$
is defined by the following equation:
$$\$Ä = çb1éçb2éÉbé(b1 ä (b2 ä b)) ä b$$
(I assume, but do not know, that the above formulation
has some practical advantage in the present
context over the more obvious definition
in terms of $å$ and $ä$.)

The name of the constant is a slash, $/$, followed by a
backslash, $\backslash$. The backslash character
must be escaped by another backslash character within
an HOL string.
»
	‚Conjunction· : TERM
…
	Conjunction = mk_const(`/\\`, Fun Bool (Fun Bool Bool))
À
»
	‚Conjunction_def· : TERM
…
	Conjunction_def =
	let b = mk_var(`b`, Bool)
	in let b1 = mk_var(`b1`, Bool)
	in let b2 = mk_var(`b2`, Bool)
	in
	mk_abs(b1, mk_abs(b2, mk_forall(b, mk_imp(mk_imp(b1, mk_imp(b2, b)), b))))
À
A derived constructor function for conjunctions is
useful.
»
	‚mk_conj· : (TERM â TERM) ã TERM
…
	É tm1 tm2é
	mk_conj(tm1, tm2) = mk_comb(mk_comb(Conjunction, tm1),tm2)
À

\subsubsection{Disjunction}
The constant $Å: bool ã bool ã bool$
is defined by the following equation:
$$\$Å = çb1éçb2éÉbé((b1 ä b) ä (b2 ä b)) ä b$$
(As for conjunction I assume this has some advantage
over a definition from the propositional calculus.)

The name of the constant is a
backslash, $\backslash$, followed by a slash, $/$.
The backslash character
must be escaped by another backslash character within
an HOL string.

»
	‚Disjunction· : TERM
…
	Disjunction = mk_const(`\\/`, Fun Bool (Fun Bool Bool))
À
»
	‚Disjunction_def· : TERM
…
	Disjunction_def =
	let b = mk_var(`b`, Bool)
	in let b1 = mk_var(`b1`, Bool)
	in let b2 = mk_var(`b2`, Bool)
	in
	mk_abs(b1, mk_abs(b2, mk_forall(b, mk_imp(mk_imp(b1, b), mk_imp(mk_imp(b2, b), b)))))
À
A derived constructor function for disjunctions is
useful later.
»
	‚mk_disj· : (TERM â TERM) ã TERM
…
	É tm1 tm2é
	mk_disj(tm1, tm2) = mk_comb(mk_comb(Disjunction, tm1),tm2)
À

\subsubsection{ONE\_ONE}
The definition of $Type\_Definition$ below requires the notion of
a one-to-one function. The constant $ONE\_ONE$
is defined by the following equation:
$$ONE\_ONE = ç(f:* ã **)éÉ(x1:*)éÉ(x2:*)é(f\,x1 = f\,x2) ä (x1 = x2)$$
»
	‚StarStar· : TYPE
…
	StarStar = mk_vartype `**`
À
»
	‚One_One· : TERM
…
	One_One = mk_const(`ONE_ONE`, Fun(Fun Star StarStar)Bool)
À
»
	‚One_One_def· : TERM
…
	One_One_def = 
	let f = mk_var(`f`,Fun Star StarStar)
	in let x1 = mk_var(`x1`,Star)
	in let x2 = mk_var(`x2`,Star) in
	mk_abs(f, mk_forall(x1, mk_forall(x2,
		mk_imp(mk_eq(mk_comb(f, x1), mk_comb(f, x2)),
			mk_eq(x1, x2)))))
À
\subsubsection{ONTO}
The axiom of infinity requires the notion of
an onto function. The constant $ONTO$
is defined by the following equation:
$$ONTO = ç(f:* ã **)éÉ(y:**)éÑ(x:*)éy = f\,x$$
»
	‚Onto· : TERM
…
	Onto = mk_const(`ONTO`, Fun(Fun Star StarStar)Bool)
À
»
	‚Onto_def· : TERM
…
	Onto_def =
	let f = mk_var(`f`,Fun Star StarStar)
	in let x = mk_var(`x`,Star)
	in let y = mk_var(`y`,StarStar) in
	mk_abs(f, mk_forall(y, mk_exists(x, mk_eq(y, mk_comb(f, x)))))
À
\subsubsection{Type\_Definition}

{\it Type\_Definition} may be new to some readers.
It is a term asserting that a function  represents
one type as a subtype of another. It is used
in defining {\it new\_type\_definition}.
It has type $(**ãbool)ã(*ã**)ãbool$ and
is defined by the following equation:
\begin{eqnarray*}
Type\_Definition = &ç(P:**ãbool)é(rep:*ã**)é&ONE\_ONE\,rep \\
	&&Ä É(x:**)éP\,x = Ñ(y:*)éx = rep\,y
\end{eqnarray*}

It is useful later to have a version of {\it Type\_Definition}
parameterised over the types involved.
»
	‚Type_Definition· : TYPE ã TYPE ã TERM
…
	É ty1 ty2 é
	Type_Definition ty1 ty2 = mk_const(`Type_Definition`, (Fun (Fun ty2 Bool) (Fun(Fun ty1 ty2)Bool)))
À
»
	‚Type_Definition_def· : TERM
…
	Type_Definition_def = 
	let P = mk_var(`P`,Fun StarStar Bool)
	in let rep = mk_var(`rep`,Fun Star StarStar)
	in let x = mk_var(`x`,StarStar)
	in let y = mk_var(`y`,Star) in
	mk_abs(P, mk_abs(rep,
		mk_conj(mk_comb(One_One, rep),
			mk_forall(x, mk_eq(mk_comb(P, x), mk_exists(y, mk_eq(x, mk_comb(rep, y))))))))
À

\subsection{{\it new\_type} and {\it new\_constant}}

The first two definitional extension mechanisms,
{\it new\_type} and {\it new\_constant} are
conservative, but not very powerful.

{\it new\_type}  is used to declare a name to be used
as a type constructor. No axioms about the type are
introduced so that only instances of polymorphic
functions may be applied to it.
The only constraint is that the name should not
be a type constructor in the theory to be extended.

»
	‚new_type· : Ü ã string ã THEORY ã THEORY ã bool
…
	É arity name thy1 thy2 é
	new_type arity name thy1 thy2 =
	(É n é å (types thy1 name n)) Ä
	(É s n é types thy2 s n = ((s = name) Ä (n = arity)) Å (types thy1 s n)) Ä
	(constants thy2 = constants thy1) Ä
	(axioms thy2 = axioms thy1) Ä
	(theorems thy2 = theorems thy1)
À
{\it new\_constant}  is used to declare a name to be used
as a constant of a given type.
No axioms about the constant are
introduced so that it behaves as a value
which we cannot determine.
The only constraint is that the name should not
be a constant in the theory to be extended.

»
	‚new_constant· : string ã TYPE ã THEORY ã THEORY ã bool
…
	É name type thy1 thy2 é
	new_constant name type thy1 thy2 =
	(É ty é å (constants thy1 name ty)) Ä
	(É s ty é constants thy2 s ty = ((s = name) Ä (ty = type)) Å (constants thy1 s ty)) Ä
	(types thy2 = types thy1) Ä
	(axioms thy2 = axioms thy1) Ä
	(theorems thy2 = theorems thy1)

À

\subsection{{\it new\_axiom}}

{\it new\_axiom} is both powerful and dangerous!
It allows a sequent with no hypotheses and a
given conclusion to be taken as an axiom.
The only constraint is that the sequent be well-formed
with respect to the environments of the theory being
extended.

»
	‚new_axiom· : TERM ã THEORY ã THEORY ã bool
…
	É tm thy1 thy2 é
	new_axiom tm thy1 thy2 =
	let seq = (§, tm)
	in
	((seq ù sequents thy1) Ä
	(types thy2 = types thy1) Ä
	(constants thy2 = constants thy1) Ä
	(axioms thy2 = axioms thy1 ° singleton_set seq) Ä
	(theorems thy2 = theorems thy1))

À
\subsection{{\it new\_definition}}
{\it new\_definition} is useful and conservative.
It allows the simultaneous introduction of a new constant
and an axiom asserting that the new constant is equal
to a given term.
The constraints imposed are {\it (a)} the name must satisfy the
check made in {\it new\_constant}, {\it (b)} the term
must be closed and {\it (c)} the term must contain
no bound variables whose types contain type variables
which do not appear in the type of the new constant.
Condition {\it (c)} ensures that different type instances
of the term result in different instances of the
constant; this avoids a possible inconsistency.
»
	‚new_definition· : string ã TERM ã THEORY ã THEORY ã bool
…
	É name tm thy1 thy2 é
	new_definition name tm thy1 thy2 =
	let ty = type_of_term tm
	in 
	Ñ thy1a é
	(new_constant name ty thy1 thy1a) Ä
	(freevars_set tm = §) Ä
	(term_tyvars tm • type_tyvars ty) Ä
	(new_axiom (mk_eq(mk_const(name, ty), tm)) thy1a thy2)
À


\subsection{{\it new\_specification}}

{\it new\_specification} allows the simultaneous
introduction of a set of new constants satisfying a
given predicate provided that a theorem asserting
the existence of some set of values satisfying the
constants is given. An axiom asserting the predicate
for the new constants is introduced.
Like {\it new\_definition}, {\it new\_specification}
is useful and conservative.

The constraints imposed are analogous to those imposed
in {\it new\_definition}: {\it (a)} the constant
names must be pairwise distinct and different from
any constant name in the theory being extended,
{\it (b)} the predicate must have
no free variables apart from those corresponding
to the new constants, {\it (c)} any type variable
contained in a bound variable of the predicate must
appear as a type variable of each of the new constants.
Also, of course, the theorem must have the right form.

Since we now need to work with existential quantifiers
it is necessary to introduce the theory {\it LOG}.
We impose the restriction that {\it new\_specification}
may only be used  to extend theories which extend {\it LOG}.
»
	‚LOG· : THEORY
…
	Ñ thy1 thy2 thy3 thy4 thy5 thy6 thy7 thy8 thy9é
	let Name = çconéáséÑtyéhas_mk_const(s, ty)con
	in
	(new_definition (Name Truth) Truth_def MIN thy1
Ä	new_definition (Name (Forall Star)) Forall_def thy1 thy2
Ä	new_definition (Name (Exists Star)) Exists_def thy2 thy3
Ä	new_definition (Name Falsity) Falsity_def thy3 thy4
Ä	new_definition (Name Negation) Negation_def thy4 thy5
Ä	new_definition (Name Conjunction) Conjunction_def thy5 thy6
Ä	new_definition (Name Disjunction) Disjunction_def thy6 thy7
Ä	new_definition (Name One_One) One_One_def thy7 thy8
Ä	new_definition (Name Onto) Onto_def thy8 thy9
Ä	new_definition (Name (Type_Definition Star StarStar)) Type_Definition_def thy9 LOG)
À

To define {\it new\_specification} we need a list
processing utility ,{\it split}, the relation
{\it has\_list\_mk\_exists}, and the relation {\it new\_constants}
which is like {\it new\_constant} but handles a
set of new constants.

»
	‚split· : ((* â **) list) ã (* list â ** list)
…
	(split [] = ([], []))
	Ä
	(É FSThd SNDhd rest é
	split (CONS(FSThd, SNDhd)rest) =
		let splitrest = split rest
		in
		(CONS FSThd (FST splitrest), CONS SNDhd (SND splitrest)))
À
»
	‚has_list_mk_exists· : (TERM list) ã TERM ã TERM ã bool
…
	(Étm1 tm2é has_list_mk_exists [] tm1 tm2 = (tm1 = tm2))
	Ä
	(É v rest tm1 tm2 é 
	has_list_mk_exists (CONS v rest) tm1 tm2 =
	Ñ rem é has_mk_exists(v, rem) tm2 Ä
		has_list_mk_exists rest rem tm1)
	
À

»
	‚new_constants· : ((string â TYPE) ã bool) ã THEORY ã THEORY ã bool
…
	É cons thy1 thy2 é
	new_constants cons thy1 thy2 =
	(É s ty1 ty2 é ((s, ty1) ù cons) ä å(constants thy1 s ty2)) Ä
	(É s ty é constants thy2 s ty = ((s, ty) ù cons) Å constants thy1 s ty) Ä
	(types thy2 = types thy1) Ä
	(axioms thy2 = axioms thy1) Ä
	(theorems thy2 = theorems thy1)

À

We can now define {\it new\_specification}.
We use the cardinality function $card$ here to help
in asserting that certain lists contain no repeats.
»
	‚new_specification· : ((string â (string â TYPE)) list) ã
	TERM ã THM ã THEORY ã THEORY ã bool
…
	É pairs tm thm thy1 thy2 é
	new_specification pairs tm thm thy1 thy2 =
	let conl = FST(split pairs)
	in let varl = map mk_var (SND(split pairs))
	in let tyl = map SND (SND(split pairs))
	in let subs = ç(s, ty) é
		(Ñ c é (c, (s, ty)) ≈ pairs)
		 =>	mk_const((ácé(c, (s, ty)) ≈ pairs), ty)
		| 	mk_var(s, ty)
	in let axiom = subst subs tm
	in (Ñ concé
	(has_list_mk_exists varl tm conc)
	Ä (thy1 extends LOG)
	Ä
	(freevars_set conc = §)
	Ä
	(card (elems conl) = length varl) Ä (card(elems varl) = length varl)
	Ä
	(thm_seq thm = (§, conc)) Ä (thy1 extends thm_thy thm)
	Ä
	(É tyé (ty ≈ tyl) ä (term_tyvars conc • type_tyvars ty))
	Ä
	(Ñ thy1a é
	new_constants (elems (combine conl tyl)) thy1 thy1a Ä
	new_axiom axiom thy1a thy2) )
À

\subsection{{\it new\_type\_definition}}
{\it new\_type\_definition} allows the introduction
of a new type in one-to-one correspondence with
the subset of an existing type satisfying a given
predicate, given a theorem asserting that the subset
is not empty. A new axiom asserting the existence
of a representation function for the new type is introduced.
Like {\it new\_definition}, {\it new\_type\_definition}
is useful and conservative.

For simplicity, we have made the list of type variable
names to be used as the parameters of the type being
defined, a parameter to {\it new\_type}.
The constraints imposed are {\it (a)} that the list
of type parameter names contain
no repeats, {\it (b)} the theorem must have the right form
and {\it (c)} all type variables contained in the
predicate must be contained in the list of type parameters
names.
Condition {\it (c)} ensures that different type instances
of the new axiom involve different type instances of
the new type.

»
	‚new_type_definition· : string ã (string list) ã THM ã THEORY ã THEORY ã bool
…
	É name typars thm thy1 thy2 é
	new_type_definition name typars thm thy1 thy2=
	Ñ p xty x ty px thy1a axiom newty é
	let f = mk_var(`f`, Fun newty ty)
	in let newty = mk_type(name, map mk_vartype typars)
	in (
	(thy1 extends LOG)
	Ä
	(hyp (thm_seq thm) = §) Ä
	has_mk_exists (xty, px) (concl (thm_seq thm)) Ä
	has_mk_var (x, ty) xty Ä
	has_mk_comb (p, xty) px
	Ä
	(freevars_set p = §) Ä
	(term_tyvars p • elems typars)
	Ä
	(length typars = card(elems typars))
	Ä
	has_mk_exists(f, mk_comb(mk_comb(Type_Definition newty ty, p), f)) axiom
	Ä
	(new_type (length typars) name thy1 thy1a) Ä
	(new_axiom axiom thy1a thy2) )
À
\section{The theory INIT}
\label{INIT}
By extending the theory $LOG$ with five axioms
we will arrive at the theory $INIT$. In a typical
HOL proof development system all theories will be
extensions of this theory. 


\subsection{The Axioms}
\subsubsection{BOOL\_CASES\_AX}
This is the law of the excluded middle:
\begin{eqnarray*}
BOOL\_CASES\_AX&Ö&É(b : bool)é(b = T)\;Å\;(b = F)
\end{eqnarray*}
»
	‚BOOL_CASES_AX· : TERM
…
	BOOL_CASES_AX =
	let b = mk_var(`b`, Bool)
	in mk_forall(b, mk_disj(mk_eq(b, Truth), mk_eq(b, Falsity)))
À

\subsubsection{IMP\_ANTISYM\_AX}

This says that implication is an antisymmetric
relation:
\begin{eqnarray*}
IMP\_ANTISYM\_AX&Ö&
É(b1:bool)éÉ(b2:bool)é(b1\,ä\,b2)\,ä\,(b2\,ä\,b1)\,ä\,(b1=b2)
\end{eqnarray*}
»
	‚IMP_ANTISYM_AX· : TERM
…
	IMP_ANTISYM_AX =
	let b1 = mk_var(`b1`, Bool)
	in let b2 = mk_var(`b2`, Bool)
	in mk_forall(b1, mk_forall(b2,
		mk_imp(mk_imp(mk_imp(b1, b2), mk_imp(b2, b1)), mk_eq(b1, b2))))
À

\subsubsection{ETA\_AX}
This says that an $\eta$-redex is equal to
its $\eta$-reduction.
\begin{eqnarray*}
ETA\_AX&Ö&É(f: * ã **)é(ç(x:*)éf\,x) = f
\end{eqnarray*}
»
	‚ETA_AX· : TERM
…
	ETA_AX =
	let f = mk_var(`f1`, Fun Star StarStar)
	in let x = mk_var(`x`, Star)
	in mk_forall(f, mk_eq(mk_abs(x, mk_comb(f, x)), f))
À
\subsubsection{SELECT\_AX}
This is the defining property of the choice function $á$.
\begin{eqnarray*}
SELECT\_AX&Ö&É(P:*ãbool)éÉ(x:*)éP\,x\;ä\;P(á P)
\end{eqnarray*}
»
	‚SELECT_AX· : TERM
…
	SELECT_AX =
	let P = mk_var(`P`, Fun Star Bool)
	in let x = mk_var(`x`, Star)
	in mk_forall(P,mk_forall(x, mk_imp(mk_comb(P, x), mk_comb(P, mk_comb(Choice, P)))))
À
\subsubsection{INFINITY\_AX}
This is the axiom of infinity. It asserts that the
type $ind$ is in one-to-one correspondence with
a proper subset of itself:
\begin{eqnarray*}
INFINITY\_AX&Ö&Ñ(f:indãind)éONE\_ONE\,f\;Ä\;åONTO\,f
\end{eqnarray*}
We need first to define the new type $ind$:
»
	‚Ind· : TYPE
…
	Ind = mk_type(`Ind`, [])
À
»
	‚INFINITY_AX· : TERM
…
	INFINITY_AX =
	let f = mk_var(`f`, Fun Ind Ind)
	in mk_conj(mk_comb(One_One, f), mk_comb(Negation, mk_comb(Onto, f)))
À

\subsection{The Theory INIT}
»
	‚INIT· : THEORY
…
	Ñ thy1 thy2 thy3 thy4 thy5 thy6 é
	new_axiom BOOL_CASES_AX LOG thy1
Ä	new_axiom IMP_ANTISYM_AX thy1 thy2
Ä	new_axiom ETA_AX thy2 thy3
Ä	new_axiom SELECT_AX thy4 thy5
Ä	new_type 0 (FST(dest_type Ind)) thy5 thy6
Ä	new_axiom INFINITY_AX thy6 INIT
À


\section{The Type STANDARD\_THEORY} \label{STANDARD}

Of particular importance are theories which
may be obtained from $INIT$ by the {\em conservative}
extension mechanisms defined in section \ref{DEFINITIONS}
above.
These theories are of interest since, we
assert, they form a sound formalism
in which much of the practical machine-checked
proof work one might wish to do can be carried out.
We define this set of theories as a subtype,
$STANDARD\_THEORY$ of $THEORY$.

\subsection{Relations}

We need some generalities about relations.
First the standard notion of antisymmetry:


»
	‚antisymmetric· : (* ã * ã bool) ã bool
…
	É R é antisymmetric R = É x y é (R x y) ä (R y x) ä (x = y)
À

Next domain and codomain:

»
	‚domain· : (* ã ** ã bool) ã (* ã bool)
…
	É R x é (x ù domain R)  Ç Ñyé R x y
À

»
	‚codomain· : (* ã ** ã bool) ã (** ã bool)
…
	É R x é (x ù codomain R)  Ç Ñyé R y x
À
The {\it field}
of a relation is the union of its domain and codomain.

»
	‚field· : (* ã * ã bool) ã (* ã bool)
…
	É R é field R = domain R ° codomain R
À

We need the notion of a path between two elements in a
relation. 
 
»
	‚path· : (* list) ã (* ã * ã bool) ã * ã * ã bool
…
	É l R x y é
	path l R x y Ç 
	( (l = [x; y]) Ä R x y ) Å
	(Ñ x1 rest é (l = CONS x (CONS x1 rest)) Ä R x x1 Ä path rest R x1 y)
À
Using {\it path} we can define the ancestral of a relation:
 
»
	‚ancestral· : (* ã * ã bool) ã * ã * ã bool
…
	É R x y é
	ancestral R x y Ç Ñl é path l R x y
À

\subsection{STANDARD\_THEORY}

If a theory $thy1$ extends a theory $thy2$, let
us say the extension is
{\em by proof} if the theories only differ in
their theorems component:
»
	‚extends_by_proof· : THEORY ã THEORY ã bool
…
	Éthy1 thy2é
	extends_by_proof thy1 thy2 = 
		(theorems thy2 • theorems thy1)
	Ä	(types thy2 = types thy1)
	Ä	(constants thy2 = constants thy1)
	Ä	(axioms thy2 = axioms thy1)
À
We will say that a theory $thy1$ is a $standard$ extension
of a theory $thy2$ if one may go from $thy2$ to $thy1$ by
some sequence of
extensions either by proof or by the functions 
$new\_type$, $new\_constant$, $new\_definition$,
$new\_specification$ and $new\_type\_definition$:

»
	‚standard_extension· : THEORY ã THEORY ã bool
…
	let one_step =
		(çthy1 thy2é
		(extends_by_proof thy1 thy2)
		Å
		(Ñ arity name é new_type arity name thy2 thy1)
		Å
		(Ñ name type é new_constant name type thy2 thy1)
		Å
		(Ñname tm é new_definition name tm thy2 thy1)
		Å
		(Ñ pairs tm thm é new_specification pairs tm thm thy2 thy1)
		Å
		(Ñname typars thm é new_type_definition name typars thm thy2 thy1))
	in
	(standard_extension = ancestral one_step)
À

We may now define STANDARD\_THEORY as the subtype of
THEORY comprising the theories which are standard
extensions of $INIT$.
Â
sim_type_def `STANDARD_THEORY`
		"thy : THEORY,
		standard_extension thy INIT";;
Ê
\section{THEORY HIERARCHIES AND THE HOL SYSTEM} \label{THEORYHIERARCHIES}

The HOL system operates not with the totality
of the type {\it THEORY}, but with subsets of it.
The subsets are structured as hierarchies in which
each theory has a unique name and a parenthood relation is
given on the names. We will view this structure
as a function from names to theories. The function
is required to be order-preserving with respect
to parenthood (of names) and extension (of theories).

\subsection{More on Relations}
We will use the term {\it root} for a least element
of the ancestral of a relation. Such an element is
necessarily unique for a non-empty relation whose ancestral is
antisymmetric.

»
	‚root· : (* ã * ã bool) ã * ã bool
…
	É R min é root R min = Éy é (y à min) ä (y ù field R) ä ancestral R min y
À

»
	‚rooted· : (* ã * ã bool) ã bool
…
	É R é rooted R = Ñ min é root R min
À
We will need the idea of an order-preserving function:
»
	‚order_preserving· : (* ã **) ã (* ã * ã bool) ã (** ã ** ã bool) ã bool
…
	É f R1 F2 é order_preserving f R1 R2 = É x y é R1 x y ä R2 (f x) (f y)
À


\subsection{The Abstract State of a HOL System}

We can now give an abstract model for the state of
an implementation of an HOL system. The part of the
state which is to do with the theory hierarchy
is as follows:

«Õ`‚HOL_STATE·``HSt`ÕÕÕÕÕÕÕÕÕÕﬂ
	parent	: string ã string ã bool,
	theory	: string ã THEORY
…ÕÕÕÕÕÕÕÕÕÕÕÕ
	(antisymmetric (ancestral parent)) Ä
	(rooted parent) Ä
	(Éinit é root parent init ä (theory init = INIT)) Ä
	(order_preserving theory parent $extends)
 ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ‡

(The projection functions for the above type are
$HSt\_parent$ and $HSt\_theory$.)

In using the above definition we will only consider
theories associated with names within the field
of the parenthood relation. Thus the implementation
need not include an infinite database.

A HOL system would then be an
instance of the following datatype:

«`‚HOL_SYSTEM·``HSy`ÕÕÕÕÕÕÕÕﬂ
	transitions :(*INPUT â HOL_STATE) ã (HOL_STATE â *OUTPUT)
…ÕÕÕÕÕÕÕÕÕÕÕÕ
	T
 ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ‡

Note that, the types ``${:}{*}INPUT$''
and ``${:}{*}OUTPUT$'' are meant to model more than just
commands from a keyboard and responses on a screen.
For instance, the metalanguage interpreter and associated
state might be a component of both types.

Moreover, if we wish,
we can restrict our attention to ``safe'' systems,
i.e. those permitting only consistent theories, using
the following predicates.
We say a state is consistent if all the theories named
in it are consistent.


»
	‚consistent_state· : HOL_STATE ã bool
…
	É hol_stateé
	consistent_state hol_state = 
	É thy é
	(Ñ name é
		(name ù field (hol_state.HSt_parent)) Ä
		((hol_state.HSt_theory) name = thy)
	) ä 	consistent_theory thy
À

»
	‚safe· : (*INPUT, *OUTPUT)HOL_SYSTEM ã bool
…
	É hol_system é
	safe hol_system =
	É input hol_state é
	consistent_state hol_state ä
	consistent_state (FST((hol_system.HSy_transitions)(input, hol_state)))
À
Perhaps of even more importance are the HOL systems
whose transitions only introduce theories which are
standard extensions of existing theories.
In the following definition we also allow deletion of theorems
from theories (i.e. the inverse of
extension by proof).
»
	‚standard· : (*INPUT, *OUTPUT)HOL_SYSTEM ã bool
…
	É hol_system é
	standard hol_system =
	É new_name input old_state é
	let thy = ((FST((hol_system.HSy_transitions)(input, old_state))).HSt_theory) new_name
	in
	Ñold_nameé
	(standard_extension thy ((old_state.HSt_theory) old_name)
	Å
	extends_by_proof ((old_state.HSt_theory) old_name)thy)
À

%\section{THE THEORY}
%\begin{FT}{}
% \input{holsyn.th.prt}
%\end{FT}

\twocolumn
\section{Index of Defined Terms}
\printindex
\end{document}

