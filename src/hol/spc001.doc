% TQtemplate.tex
\documentstyle[hol,11pt,/escher/DSL/usr4/ajh/docs/style/TQ]{article}
\ftlinepenalty=9500
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\pagestyle{TPP}
\makeindex
\TPPproject{TECHNOLOGY PROJECTS}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{HOL in HOL}  %% Mandatory field
\TPPref{DS/FMU/RDA/16}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{
I'll think up something later.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      R.B.Jones
}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'

First version.

\subsection{Changes forecast}

Under development, highly incomplete, totally volatile.

\subsection{Abbreviations and notation}
\begin{tabular}{ll}
HOL & Higher Order Logic\\
\end{tabular}
\newpage
\section{INTRODUCTION}
This document is an attempt to specify the
syntactic aspects of the
HOL logic using the HOL system.
The document should be viewed as a formal treatment
of chapters 3, 4 and 5 of Mike Gordon's
description of the HOL logic and system
(\cite{gordon87}).

Where possible we have tried to present the
specification to serve
both as a specification of the logic
(i.e. the formal theory
in the sense of a mathematical structure with terms,
well-formed terms, inference rules etc.) and the
system (i.e. the program which enable one
to calculate theorems).
We have erred on the side of abstraction whenever
presentation of a constructive formulation would
lead to inappropriate complexity.

In formalising the system we have, on occasion, felt
that certain changes would be desirable for one reason
or another. We have resisted all such urges ---
what is presented here is meant to be a rigorous
formulation of the logic as described in \cite{gordon87}.
Where \cite{gordon87} has proved a little too loose for our
purposes (e.g. in the details of type instantiation),
we have tried to follow the spirit of the HOL system.
An appendix discusses some of the issues.

\subsection{Defining Logics}
It may be helpful to discuss some generalities about
the definition of logics, in order to set in context the
specific constructions we will make to specify HOL.
Readers who know what to expect are invited to skip this
section.

If we apply Occam's Razor fairly viciously to the
sort of definition one finds in, e.g., \cite{mendelson87},
one finds that
a logic (formal system, formal theory etc.) is
given by a set $S$, whose elements we will call sentences
in this section, and a subset
$I$ of $\bigcup_{n=1}^{\infty}S$.
One says that $x \in S$ is {\em directly derivable} from
$X \subseteq S$ if for some $n$,
$X^{n-1} \times \{x\} \cap S \not= §$. One then says that
$x \in S$ is {\em derivable} from $X \subseteq S$,
if for some seqence $x_1,x_2, \ldots, x_k$ of elements
of $S$, $x_k = x$ and, for each $i$, $x_i$ is
either in $X$ or is directly derivable from
$\{x_1,x_2, \ldots, x_{k-1}\}$.
One says that $x \in S$ is a {\em theorem} if it
is derivable from $§$.

In practice, $S$ is usually defined by a decidable
``well-formedness'' predicate on the free algebra $F(\Omega)$ 
over some signature $\Omega$, and
$I$ is given as the union of a set of decidable
$n$-ary relations (the inference rules).

The above ideas, while of theoretical value, are not
sufficient for a practical proof development system like
HOL, since in such a system the user can introduce
new constructs into the language $S$ by modifying
the signature $\Omega$, and can assert that certain
sentences in the extended language
$S(\Omega)$ are axioms. For example, when a new constant
is defined in HOL, the language is extended to include
the new constant and an axiom that the constant
is equal to the value given in its definition is asserted.

Let us assume that the well-formedness predicates
and inference rules are defined so as to apply to
sentences over any signature the user can define.
This may be achieved by restricting the signatures
to be subsignatures of a signature $\Sigma_{max}$.
A predicate over $F(\Sigma_{max})$ 
then restricts to a predicate over $F(\Omega)$ for
any subsignature $\Omega$ of $\Sigma_{max}$, and
similarly for any set of inference rules over
$L(\Sigma_{max})$.

Theorems are proved within what we are called theories.
These are
pairs $(\Omega, X)$, where $\Omega$ is a signature
as above,
and $X \subseteq S(\Omega)$. X is the set of axioms
of the theory.
Theories form a partially ordered set with respect
inclusion (or the inverse relation: extension).

The inference rules over $S(\Sigma_{max})$
induce inference rules on the sentences in the
language of a given theory. The theorems of the theory
$(\Omega, X)$ are then precisely the sentences in
$S(\Omega)$ which are derivable from $X$ using the
induced inference rules. 

A theory is {\em consistent} if
not every sentence in its language is a theorem.
Of particular interest in a practical proof development
system are mechanisms for extending a theory which
preserve consistency.
A theory $T_1$ is a {\it conservative
extension} of a theory $T$ if $T_1$ extends $T$
and all sentences in $L(T)$ which are theorems
in $T_1$ are also theorems in $T$. Clearly conservative
extension preserve consistency. 

\subsection{Overview of the Specification}
\subsubsection{The Logic}
Our treatment of HOL logic follows approximately
the pattern discussed in the previous section.
We first define our version of
$F(\Sigma_{max})$ and $L(\Sigma_{max})$.
Apart from a minor complication, this amounts
to specifying the abstract syntax for HOL terms and
the subset of terms which are well-typed (ignoring
context-sensitive constraints such as the agreement
of the arity of a type with that given in some definition). This is done in sections \ref{TYPESANDTERMS} and

The minor complication is that
HOL is defined as a sequent calculus.
Sequents are defined in section \ref{SEQUENTS}.
It is the sequents which make up our $L(\Sigma_{max})$.

In our general discussion above we have not
prohibited unary rules of inference, i.e. axioms by
another name. Such rules are a convenient home
for those axioms which we wish to have in every theory.
These rules, which consist of three axiom schemata,
are defined in section \ref{AXIOMSCHEMATA}.
The remaining rules of inference are defined in section
\ref{RULESOFINFERENCE}.

With the rules of inference over $L(\Sigma_{max})$
in hand, we define derivability in section
\ref{DERIVABILITY} and then move on to consider
theories and theorems in section \ref{THEORIESANDTHEOREMS}.
In our case, the signature part of a theory amounts to 
two ``environments'', one giving the arity of the type
constructors in the theory and the other giving
the types of the constants.
In addition to the environments and the axioms, a
theory also contains a set of theorems of the theory.
This enables the same notion of theory to be used in
describing the proof development system.
We then define the theorems of HOL as those pairs
$(s, T)$ where $T$ is a theory and $s$ is a sequent in the
language of $T$ derivable from the axioms of $T$.

Our final section on the logic, section \ref{CONSISTENCY},
defines the type of all theorems and
specifies the notions of consistency and conservative
extension.

\subsubsection{The HOL System}

From section \ref{RULESOFINFERENCEREVISITED} onwards
we turn to specifying some high level aspects of
the HOL proof development system.

The designer of a proof development system
is interested in ensuring
that the theorems which the users compute are indeed
derivable from the axioms of the theory involved.
The LCF approach to this problem is to have the users
compute using a programming language supporting the
abstract data type concept and to represent theorems
as elements of an abstract
data type whose constructor functions consist
precisely of the rules of inference (suitably parameterised
so that they are partial functions rather than arbitrary
functions).
In this way, the type system of the programming
language helps to ensure that only valid theorems may be
derived. In section \ref{RULESOFINFERENCEREVISITED} we
define the action of the rules of inference on
our type of theorems (although not as partial
functions).

As we have already mentioned, mechanisms for
extending theories are of great practical
importance, particular those which preserve consistency.
Section \ref{DEFINITIONS} discusses
the means by which theories may be extended in the HOL
system.

Finally, section \ref{THEORYHIERARCHIES} discusses
an abstraction of the database side of the proof development
system. The concept of a named hierarchy of theories
is introduced and an abstraction of the state of
an HOL proof development system is presented.

\subsection{Introducing the new theory}

\Hide{
extend_theory`holsyn`;;
map loadf [`TAUT`;`infra`];;
lemmas_on := false;;
garbage_collection_diags false;;
}
We intoduce the new theory. Its parents are
library theories which we will use later.
We set some controls for the infrastructure which
supports the Z-like definition mechanism and for the
ML system.
Â
new_theory`holsyn`;;
map new_parent [`string`; `infra`; `set`];;
map loadf [`infra`];;
lemmas_on := false;;
garbage_collection_diags false;;
Ê
»
	£ : ((* ã bool) ã bool) ã (* ã bool)
…
	É sets x é x ù £ sets = Ñsetéx ù set Ä set ù sets
À

»
	card : (* ã bool) ã Ü
…
	T
À

\section{THE SYNTAX OF TYPES AND TERMS} \label{TYPESANDTERMS}

In this section we define the abstract syntax of HOL terms
and of the types which they contain.
The terms will be given as that subtype of a type of ``free
terms'' which comprises the terms which are well-formed
(i.e. well-typed) in a sense we will define.

The well-formedness check does not consider
context-sensitive issues such
conformance of the type of a
constant or the arity of a type
with the definition of the constant or type ---
such considerations are deferred until we have defined the
notion of a theory.
To some extent this approach is forced on us
since we wish to define a type of well-formed terms.
Since the system does not permit dependent types the
well-formedness predicate cannot be parameterised by
any form of context.

To define types for the various syntactic classes,
we use {\tt new\_type}. To populate them, we use
{\tt new\_constant} to define constructor functions.
To lend verisimilitude to our
account, we formulate an axiom for each new type which
characterises its constructor functions. The axiom
gives a principle of definition by structural recursion,
which might be used to justify the functions which we
will later specify on the types.
The consistency of the specification
could, we hope, be demonstrated using T.~Melham's
system for defining recursive types.
As things stand the rigour of our specification is on a
par with that of a VDM or Z specification.

\subsection{Types}
As a consequence of our approach,
the HOL types constitute a free algebra.
It is only in the context of the type definitions within
a theory that a type can be ill-formed.

Â
new_type 0 `TYPE`;;

new_constant (`‚mk_vartype·`,":string ã TYPE");;

new_constant (`‚mk_type·`,":string â TYPE list ã TYPE");;

let ‚TYPE_axiom· = new_axiom(`TYPE_axiom`,"
	É(f0:string ã *) (f1: string â TYPE list ã * list ã *)é
        ¿ (fn:TYPE ã *)é
         (Ésé fn(mk_vartype s) = f0 s) Ä
         (És tlé fn(mk_type (s,tl)) = f1 (s, tl) (map fn tl))
");;
Ê

We will usually define destructor
functions whenever we define constructor functions.
For example:

»
	‚dest_vartype·: TYPE ã string 
…
		dest_vartype o mk_vartype = I
À
»
	‚dest_type·: TYPE ã string â (TYPE list)
…
		dest_type o mk_type = I
À

\subsection{Free Terms}

The type {\it FTERM} is the syntactic class for what we
will call free terms, i.e.
``HOL terms which are well-formed enough to parse, but
which are not necessarily well-typed''.

Â
new_type 0 `FTERM`;;

new_constant (`‚mk_fvar·`,":string â TYPE ã FTERM");;

new_constant (`‚mk_fconst·`,":string â TYPE ã FTERM");;

new_constant (`‚mk_fcomb·`,":FTERM â FTERM  ã FTERM");;

new_constant (`‚mk_fabs·`,":string â TYPE â FTERM  ã FTERM");;

let ‚FTERM_axiom· = new_axiom(`FTERM_axiom`,"
	É
	(f0:string â TYPE ã *)
	(f1:string â TYPE ã *)
	(f2: FTERM â FTERM ã * â * ã *)
	(f3: string â TYPE â FTERM ã * ã *)é
        ¿ (fn:FTERM ã *)é
         (És tyé	fn (mk_fvar (s, ty))
			= f0 (s, ty))
	Ä  (És tyé	fn(mk_fconst (s, ty))
			= f1 (s, ty))
	Ä  (Éf aé	fn(mk_fcomb (f, a))
			= f2 (f, a) (fn f, fn a))
	Ä  (Év ty bé	fn(mk_fabs (v, ty, b))
			= f3 (v, ty, b) (fn b))
");;
Ê

We now define the destructor functions which are
left inverse to the constructor functions
{\it mk\_fvar} etc. The destructor functions
would most naturally be implemented as partial
functions --- i.e. they would treat as erroneous
arguments which
are not in the codomain of the corresponding constructor.

»
	‚dest_fvar·: FTERM ã string â TYPE
…
		dest_fvar o mk_fvar = I
À
»
	‚dest_fconst·: FTERM ã string â TYPE
…
		dest_fconst o mk_fconst = I
À
»
	‚dest_fcomb·: FTERM ã FTERM â FTERM
…
		dest_fcomb o mk_fcomb = I
À
»
	‚dest_fabs·: FTERM ã string â TYPE â FTERM
…
		dest_fabs o mk_fabs = I
À

\subsection{Free Variables}
To illustrate how the principle of definition
by structural recursion for the type {\it FTERM}
might be used, we specify some simple functions
which are useful later and whose specifications could
be proved consistent using it.

{\it freevars\_fset} returns the set of free variables
of a term.
We use it in cases where the order of appearance
of the free variables in the term is immaterial.

»
	‚freevars_fset·: FTERM ã (string â TYPE ã bool)
…
	É(s : string) (t : TYPE) (f : FTERM)
	(a : FTERM) (v : string) (b : FTERM) é
	(freevars_fset (mk_fvar(s,t)) = çxé x = (s,t))
Ä	(freevars_fset (mk_fconst(s,t)) = çxé F)
Ä	(freevars_fset (mk_fcomb(f, a)) =
			(freevars_fset f) ° (freevars_fset a))
Ä	(freevars_fset (mk_fabs(v, t, b)) =
			(freevars_fset b) ƒ çxé x = (v,t))
À

{\it freevars\_flist} returns the free variables of a term
listed in order of first appearance (from left to
right in the usual concrete syntax).

»
	‚freevars_flist·: FTERM ã ((string â TYPE)list)
…
	É(s : string) (t : TYPE) (f : FTERM)
	(a : FTERM) (v : string) (b : FTERM) é
	(freevars_flist (mk_fvar(s,t)) = [(s,t)])
Ä	(freevars_flist (mk_fconst(s,t)) = [])
Ä	(freevars_flist (mk_fcomb(f, a)) =
			freevars_flist f µ
			(freevars_flist a ¡ çxéx ∆ freevars_flist f))
Ä	(freevars_flist (mk_fabs(v, t, b)) =
			freevars_flist b ¡ çxé x à (v,t))
À

\subsection{Typing Terms}

We now give the relation which relates a free term
to its type, if it has one.

Note that two variables
with the same name but different types are simply
considered as different. This agrees with both
the HOL logic and the HOL system (in which, while a term
containing two such names in the same scope cannot
be entered directly  via the parser, the constructor functions 
may be used to achieve the effect).

We do not check here that the type assigned to
a constant is an instance of the type with which it
is declared. Indeed, we have not yet defined the
mechanisms required to do this.

A function returning object language
function types is useful:

»
	‚Fun· : TYPE ã TYPE ã TYPE
…
	É ty1 ty2éFun ty1 ty2 = mk_type(`ã`, [ty1; t2])
À

»
	‚type_of_fterm·: FTERM ã TYPE ã bool
…
	É(s : string) (t : TYPE) (ty: TYPE)
	 (f : FTERM) (a : FTERM) (v : string)
	 (b : FTERM) é
	(type_of_fterm (mk_fvar(s,t)) ty = (t = ty))
Ä	(type_of_fterm (mk_fconst(s,t)) ty = (t = ty))
Ä	(type_of_fterm (mk_fcomb(f, a)) ty = 
		Ñt1é(type_of_fterm f (Fun t1 ty)) Ä (type_of_fterm a t1))
Ä	(type_of_fterm (mk_fabs(v, t, b)) ty = 
		Ñt1é(type_of_fterm b t1) Ä (Fun t t1 = ty))
À

\subsection{Well-Formedness And The Type of Well-Formed Terms}

A term is well-formed if it has a type:

»
	‚is_wf_term· : FTERM ã bool
…
	Éterm:FTERMé
	is_wf_term term = Ñtype:TYPEé type_of_fterm term type
À

We now define the type {\it TERM} of well-formed terms
as a subtype of the type {\it FTERM} of free terms.

Â
	sim_type_def `‚TERM·` ("x:FTERM, is_wf_term x");;
Ê

The constructor functions for the type {\it TERM}
are easily defined as composites in terms of
the constructor functions for {\it FTERM} and
the abstraction and representation functions for
{\it TERM}:

»
	‚mk_var· : string â TYPE ã TERM
…
	mk_var = ABS_TERM o mk_fvar 
À
»
	‚mk_const· : string â TYPE ã TERM
…
	mk_const = ABS_TERM o mk_fconst 
À
»
	‚mk_comb· : TERM â TERM ã TERM
…
	mk_comb = (ABS_TERM o mk_fcomb) o ç(x,y)é (REP_TERM x, REP_TERM y)
À
»
	‚mk_abs· : TERM â TERM ã TERM
…
	mk_abs = (ABS_TERM o mk_fabs) o
			ç(x,y)é (FST(dest_var x), SND(dest_var x), REP_TERM y)
À
As for {\it FTERM,} the destructor functions are
specified as left inverses of the corresponding
constructor functions:

»
	‚dest_var·: TERM ã string â TYPE
…
		dest_var o mk_var = I
À
»
	‚dest_const·: TERM ã string â TYPE
…
		dest_const o mk_const = I
À
»
	‚dest_comb·: TERM ã TERM â TERM
…
		dest_comb o mk_comb = I
À
»
	‚dest_abs·: TERM ã TERM â TERM
…
		dest_abs o mk_abs = I
À

We specify functions which test the class of a term.
These will not all be needed here, but, as the definitions
are a little tricky, we keep them close to the
constructor functions to which they are
related\footnote{This is the price of the fiction
that the constructor and destructor functions are total.}.
The first two are easy (because the constructor functions
are one-to-one).
»
	‚is_var·: TERM ã bool
…
	É tm é is_var tm = (mk_var(dest_var tm)) = tm
À
»
	‚is_const·: TERM ã bool
…
	É tm é is_const tm = (mk_const(dest_const tm)) = tm
À
For {\it is\_comb} we need to check when one term may be
applied to another:
»
	‚applicable·:  TERM ã TERM ã bool
…
	É f a é applicable f a = Ñ ty é type_of_term f = Fun (type_of_term a) ty
À
»
	‚is_comb·: TERM ã bool
…
	É tm é is_comb tm = Ñf aé applicable f a Ä (mk_comb(f, a) = tm)
À
»
	‚is_abs·: TERM ã bool
…
	É tm é is_abs tm = Ñvty bé is_var vty Ä (mk_abs(vty, b) = tm)
À


We can also define functions for typing terms and extracting
free variables using the ones we have already defined
for free terms:

»
	‚type_of_term· : TERM ã TYPE
…
	É tm é  type_of_fterm (REP_TERM tm) (type_of_term tm)
À
»
	‚freevars_set· : TERM ã (string â TYPE ã bool)
…
	freevars_set = freevars_fset o REP_TERM 
À
»
	‚freevars_list· : TERM ã ((string â TYPE) list)
…
	freevars_list = freevars_flist o REP_TERM 
À

\section{SYNTAX OF SEQUENTS} \label{SEQUENTS}
A sequent is simply a set of assumptions
and a conclusion. Assumptions
and conclusion alike are just terms.
The following definition allows infinite
assumption sets, since they are easier for us to define.
However the axioms with which we shall work all have
finite sets of assumptions and the inference rules
will preserve this property.
Another pleasant property of sequents is for their
constituent terms to have type \Bool. This property,
too, holds of our axioms and is preserved by our inference
rules. When we define theories we insist that the
sequents in them have the latter property.


{\tiny Should we have taken a subtype?}

Â
new_type_abbrev(`‚SEQ·`, ":(TERM ã bool) â TERM");;
Ê

The destructor functions for sequents are as follows.
(Their names are as in the HOL system) 
»
	‚concl· : SEQ ã TERM
…
	concl = SND 
À

»
	‚hyp· : SEQ ã (TERM ã bool)
…
	hyp = FST 
À


\section{THE RULES OF INFERENCE} \label{RULESOFINFERENCE}

In this section we treat the syntax manipulating
functions required to define the various rules of
inference. We consider each inference rule in turn.
In the HOL system the inference rules are functions
which take theorems (and other things) as arguments
and return theorems. Since we cannot define
the type of theorems until we have defined the inference
rules we define the rules as functions taking
sequents (and other things) as arguments and returning
sequents.

\subsection{Object Language Constructs}

To define the rules of inference we need to form
certain object language types and terms.
We have already defined the function space type
constructor.
The other definitions needed are given in this
section.

We need the constant type \Bool:
»
	‚Bool· : TYPE
…
	Bool = mk_type(`bool`, [])
À

We need to form instances of the polymorphic constant
``='':

»
	‚Equality· : TYPE ã TERM
…
	É ty é Equality ty = mk_const(`=`, Fun ty (Fun ty Bool))
À

As in the HOL system it is convenient to have the derived
constructor and destructor functions for equations:

»
	‚mk_eq· : (TERM â TERM) ã TERM
…
	É tm1 tm2 é mk_eq(tm1, tm2) = mk_comb(mk_comb(Equality (type_of_term tm1), tm1), tm2)

À
»
	‚dest_eq· : TERM ã (TERM â TERM)
…
	dest_eq o mk_eq = I
À
»
	‚is_eq· : TERM ã bool
…
	Étm é is_eq tm = Ñlhs rhsé (type_of_term lhs = type_of_term rhs) Ä (mk_eq(lhs, rhs) = tm)
À

We also need to form implications. The following functions
are analagous to those treating equality above.
»
	‚Implication· : TERM
…
	Implication = mk_const(`=>`, Fun Bool (Fun Bool Bool))
À

»
	‚mk_imp· : (TERM â TERM) ã TERM
…
	É tm1 tm2 é mk_imp(tm1, tm2) = mk_comb(mk_comb(Implication, tm1), tm2)

À

»
	‚dest_imp· : TERM ã (TERM â TERM)
…
	dest_imp o mk_imp = I
À

»
	‚is_imp· : TERM ã bool
…
	É tm é is_imp tm = Ñ tm1 tm2 é
	(type_of_term tm1 = Bool) Ä (type_of_term tm2 = Bool) Ä
	(mk_imp(tm1, tm2) = tm)

À

\subsection{The Inference Rule SUBST}

In this section we define the inference rule {\it SUBST}.

In essence, {\it SUBST} says that given a
theorem whose conclusion is an equation ${\cal A} = {\cal B}$, where
$\cal A$ and $\cal B$ are arbitrary terms of the same
type, and given any other theorem with conclusion
$\cal C$ say, we may obtain a new theorem by substituting
$\cal B$ for 
any subterm of $\cal C$ which is identical with $\cal A$. This is subject to the proviso that no variable
capture problems arise, i.e. no
free variables of $\cal B$ should become bound in the
conclusion of the new theorem. (The assumption set of the
consequent theorem is the union of the assumption sets of
the antecedent theorems.)

The inference rule is, in fact, slightly more
general. It allows one to use a whole set of theorems
whose conclusions are equations to perform (simultaneous)
substitutions for many subterms of $\cal C$. Moreover,
it is implemented as a functional relation, effectively by
renaming any bound variables of $\cal C$ which would
give rise to the capture problem.

The inference rule is parametrised by a template term
and a set of some of its free variables, one for each equation.
The actual statement of the rule is, essentially, that, 
if the result of substituting the left hand sides
of the equations for the corresponding variables
in the template term
is equal to $\cal C$ ({\it modulo} renaming bound
variables), then we may infer the result of substituting
the right hand sides of the equations for the
corresponding template variables in the template term
(providing we rename bound variables to avoid the capture
problem).


The notions we must formalise are therefore: (i) renaming a variable in a term; (ii) testing equivalence of
terms {\it modulo} renaming of bound variables (aka.
$\alpha$-conversion); (iii) substituting terms for
free variables in a term according to a given mapping
of variables to terms avoiding variable capture.


\subsubsection{Renaming}
$\it rename (v, ty) w\, e$ is the result of changing
the name in every free occurrence of the
variable with name {\it v} and type {\it ty} in the
term {\it e} to {\it w}.

»
	‚rename· : (string â TYPE) ã string ã TERM ã TERM
…
	É
	(v : string) (ty : TYPE) (w: string)
	(vv :string) (tty : TYPE) (cc : string)
	(ff : TERM) (aa : TERM) (bb : TERM)
	é
	(rename (v, ty) w (mk_var(vv, tty)) =
		((v = vv) Ä (ty = tty)) =>
			mk_var(w, ty) | mk_var(vv, tty))
	Ä
	(rename (v, ty) w (mk_const(cc, tty)) =
		mk_const(cc, tty))
	Ä
	(rename (v, ty) w (mk_comb(ff, aa)) =
		mk_comb(rename (v, ty) w ff, rename (v, ty) w aa))
	Ä
	(rename (v, ty) w (mk_abs(mk_var(vv, tty), bb)) =
		((v = vv) Ä (ty = tty)) =>
			mk_abs(mk_var(vv, tty), bb) |
			mk_abs(mk_var(vv, tty), rename (v, ty) w bb))
À

\subsubsection{$\alpha$-conversion}

»
	‚aconv· : TERM ã TERM ã bool
…
	É(t1 : TERM) (t2 : TERM)é
	aconv t1 t2 =
		(t1 = t2)
	Å	(Ñt1f t1a t2f t2aé
			(t1 = mk_comb(t1f, t1a))
		Ä	(t2 = mk_comb(t2f, t2a))
		Ä	(aconv t1f t2f Ä aconv t1a t2a))
	Å	(Ñv1 v2 ty b1 b2é
			(t1 = mk_abs(mk_var(v1, ty), b1))
		Ä	(t2 = mk_abs(mk_var(v2, ty), b2))
		Ä	aconv t1 (mk_abs(mk_var(v1, ty), rename (v2, ty) v1 b2)))

À

\subsubsection{Substitution}

We will need to choose new names for variables.
More precisely,
given a variable and a set of same we will
wish to rename the variable, when necessary,
to ensure that the result
does not lie in the set.
In practice in an implementation we would insist that the new name
be derived from the old one in a specified way.

»
	‚variant· : (string â TYPE ã bool) ã (string â TYPE) ã string
…
	É vs v ty é ((v, ty) ì vs) => (variant vs (v, ty) = v) | (variant vs (v, ty), ty) ì vs
À

The following function is useful in {\it subst} and
elsewhere.

»
›	‚image· :  (* ã **) ã (* ã bool) ã (** ã bool)
…
›	Éfunction seté image function set = 
›		çx:**é Ñy:*é (x = f y) Ä y ù set
À

Now we can define {\it subst}. {\it subst F t1} gives the
term resulting from replacing every free variable
$\it mk\_var(s, t)$
in {\it t1} by $\it F(mk\_var(s, t))$ with bound
variables renamed as necessary to avoid capture.
Variables which are not to be changed correspond
to pairs $(s, t)$ with $\it F (s, t) =  mk\_fvar (s, t)$.
Note that we rely on {\it variant}
not to change bound variable names unnecessarily.

»
	‚subst· : (string â TYPE ã TERM) ã TERM ã TERM
…
	É
	(v : string) (ty : TYPE) (c : string)
	(f : TERM) (a : TERM) (b : TERM)
	é
	(subst R (mk_var(v, ty)) = R (v,ty))
	Ä
	(subst R (mk_const(c, ty)) = mk_const(c, ty))
	Ä
	(subst R (mk_comb(f, a)) = mk_comb(subst R f, subst R a))
	Ä
	(subst R (mk_abs(mk_var(v, ty), b)) =
		let new_frees = £(image (freevars_set o R) (freevars_set b ƒ singleton_set (v, ty)))
		in  let v' = variant new_frees (v, ty)
		in let RR = çxé (x = (v', ty)) => (mk_var x) | R x
		in
			mk_abs(mk_var(v', ty), subst RR (rename (v, ty) v' b))
	)
À

We can now define the inference rule.
Its first argument gives the correspondence between the
template variables and equation theorems.
We could take this argument to 
behave as {\it REFL\_rule o mk\_var} on variables which
are not template variables . 
Note that, to allow implementation as a partial function,
we test up to $\alpha$-convertibility on the first
sequent argument only.

»
	‚SUBST_rule· : ((string â TYPE) ã SEQ) ã
			TERM ã SEQ ã SEQ ã bool
…
	É eqs tm old_asms old_conc new_asms  new_concé
	SUBST_rule eqs tm (old_asms, old_conc) (new_asms, new_conc) = 
	(Éasms conc v ty é (eqs(v, ty) = (asms, conc)) ä
		(Ñlhs rhsé(conc = mk_eq(lhs, rhs)) Ä
		(type_of_term lhs = ty)))
	Ä
	(aconv old_conc (subst (FST o dest_eq o SND o eqs) tm))
	Ä
	(new_conc = subst (SND o dest_eq o SND o eqs) tm)
	Ä
	(new_asms = old_asms ° £ (çasmséÑvtyéasms =  (FST (eqs vty))))
À





\subsection{Abstraction: ABS}

Again {\it ABS} is a partial function which we
specify as a relation:

»
	‚ABS_rule· : (string â TYPE) ã SEQ ã SEQ ã bool
…
	É vty old_asms old_conc new_asms new_conc é
	ABS_rule vty (old_asms, old_conc) (new_asms, new_conc) =
	(Ñ lhs rhs é
		(old_conc = mk_eq(lhs, rhs)) Ä
		(let abstract = (çx é mk_abs(mk_var vty, x))
		in (new_conc = mk_eq(abstract lhs, abstract rhs))))
	Ä
	(vty ì £(image freevars_set old_asms))
	Ä
	(new_asms = old_asms)
À



\subsection{Type Instantiation: INST\_TYPE}

The ability to prove and use general (polymorphic)
theorems  is one of the great strengths of the HOL
system. The feature in the inference system which
gives this strength is the inference rule {\it INST\_TYPE}
which allows us to instantiate the type variables
in the conclusion of a polymorphic theorem.

In essence, the inference rule says that, given a theorem
with conclusion $\cal A$ say we may infer the theorem
which has the same assumption set and whose conclusion
results from instantiating every type in $\cal A$
according to a given mapping of type variables to types.
This is subject to two provisos: (i) no type variable may
be changed which appears in the assumption set for the
theorem; (ii) no two variables in the assumptions or
conclusion of the antecedent theorem, which are
different, by virtue of their type,  should become
identified in the consequent theorem as a result of
the transformation.

The first proviso is, we believe, only enforced to preserve
the convention of natural deduction systems
by which inference rules
involve only simple set operations on the assumption
sets. It would seem to be quite in order for the first
proviso to be dropped provided we insisted that the
type instantiation be applied to every term in the sequent
(we have, of course, not done this).

The second proviso cannot be avoided. Consider for
example: $ç(x:**)éç(x:*)é(x:**)$. If this were type
instantiated according to $\{:** ó :*, :* ó :*\}$,
then from:
$$Ö É(y:**)(z:*)é(ç(x:**)éç(x:*)é(x:**))y z = y$$
we could infer that:
$$Ö É(y:*)(z:*)é(ç(x:*)éç(x:*)é(x:*))y z = y$$
whence, by $\beta$-conversions:
$$Ö É(y:*)(z:*)éz = y.$$
This leads to a contradiction whenever $:*$ is instantiated
to a type with more than one inhabitant.

To permit an implementation which is convenient to use,
the inference rule is actually formulated without the
second proviso. Instead, variables (both free and bound,
in general) in the conclusion of the consequent theorem,
which would violate the rule are renamed to
avoid the problem. It is valid to rename free variables
in these circumstances, given the first proviso, since
the variables in question cannot occur free in the
assumption set. Note that it would be invalid to
rename free variables in $\cal A$
which are not changed by the type instantiation
(since these may appear free in the assumption set).

Formalising these notions is a little tricky. We present
here a highly unconstructive specification, reminiscent
of $\alpha$-conversion.
The two notions to be formalised are: (i) the type
instantiation of a type given by a mapping of
type variables to types and (ii) the predicate on
pairs of terms which says that one is a type instance
of another according to a given mapping of type
variables to types and with respect to a set of
variables with which clashes must not occur (this
will be the set of free variables of the assumptions
in practice).

It is entertaining and instructive to consider
algorithms meeting these specifications.


\subsubsection{Instantiation Of Types}
This is straightforward:
»
	‚inst_type· : (string ã TYPE) ã TYPE ã TYPE
…
	É(f: string ã TYPE) é
		(Ésé  inst_type f (mk_vartype s) = f s)
	Ä	(És tléinst_type f (mk_type(s, tl)) =
			mk_type(s, map (inst_type f) tl))
À

\subsubsection{Instantiation Of Terms}

Instantiation of terms is a little tricky.
The following two functions should be viewed as
local to the function {\it inst}.
{\it inst\_loc1} is very similar to an
$\alpha$-convertibility test. Indeed {\it aconv} could
have been defined as $\it inst\_loc1\,I$.
The first {\it TERM} argument of {\it inst\_loc1}
and {\it inst\_loc2}
gives the terms whose types are being instantiated (i.e.
it is the ``more polymorphic'' term).

»
	‚inst_loc1· : (string ã TYPE) ã TERM ã TERM ã bool
…
	É
	(tysubs : string ã TYPE)
	(tm1 : TERM) (tm2 : TERM)é
	inst_loc1 tysubs tm1 tm2 =
		(Ñtm1s tm1t tm2s tm2t mk_Xé
			((mk_X = mk_var) Å (mk_X = mk_const))
		Ä	(tm1 = mk_X(tm1s, tm1t)) Ä (tm2 = mk_X(tm2s, tm2t))
		Ä	(tm1s = tm2s) Ä (tm2t = inst_type tysubs tm1t))
	Å	(Ñtm1f tm1a tm2f tm2aé
			(tm1 = mk_comb(tm1f, tm1a)) Ä (tm2 = mk_comb(tm2f, tm2a))
		Ä	(inst_loc1 tysubs tm1f tm2f Ä inst_loc1 tysubs tm1a tm2a))
	Å	(Ñv1 v2 ty1 ty2 b1 b2é
			(tm1 = mk_abs(mk_var(v1, ty1), b1))
		Ä	(tm2 = mk_abs(mk_var(v2, ty2), b2))
		Ä	inst_loc1
			tysubs
	(mk_abs(mk_var(v2, ty1), rename (v1, ty1) v2 b1))
			tm2)
À


»
	‚inst_loc2· : ((string â TYPE) ã bool) ã 
		(string ã TYPE) ã
		(((string â TYPE) â (string â TYPE)) list) ã
		TERM ã TERM ã bool
…
	É(avoid : (string â TYPE) ã bool)
	(tysubs :string ã TYPE)
	(v1 : string) (ty1 : TYPE)
	(v2 : string) (ty2 : TYPE)
	(rest : ((string â TYPE) â (string â TYPE)) list)
	(tm1 : TERM) (tm2 : TERM)é
	(inst_loc2 avoid tysubs [] tm1 tm2 =
		inst_loc1 tysubs tm1 tm2)
	Ä
	(inst_loc2 avoid tysubs (CONS ((v1, ty1),(v2, ty2)) rest) tm1 tm2 =
		((v2, ty2) ù avoid ä ((v1, ty1) = (v2, ty2)))
	Ä	(ty2 = inst_type tysubs ty1)
	Ä	inst_loc2 avoid tysubs rest
		(rename (v1, ty1) v2 tm1) tm2)
À

The following simple list processing function is
needed:

»
	‚combine· : (* list) ã (** list) ã ((* â **) list)
…
	É hd1 hd2 tl1 tl2é
	(combine [] [] = [])
	Ä
	(combine (CONS hd1 tl1) (CONS hd2 tl2) =
			CONS (hd1, hd2) (combine tl1 tl2))
À

With the above preliminaries we can now define {\it inst}.

»
	‚inst· : ((string â TYPE) ã bool) ã
		(string ã TYPE) ã TERM ã TERM
…
	É((avoid : (string â TYPE) ã bool))
	(tysubs :string ã TYPE) (tm1 : TERM)é
	let tm2 = inst avoid tysubs tm1
	in let fl1 = freevars_list tm1
	in let fl2 = freevars_list tm2
	in	(length fl1 = length fl2)
	Ä	inst_loc2 avoid tysubs (combine fl1 fl2) tm1 tm2
À

We need to detect the type variables in a term:

»
	‚type_tyvars· :  TYPE ã (string ã bool)
…
		(És:stringé  type_tyvars (mk_vartype s) = singleton_set s)
	Ä	(És tlé type_tyvars (mk_type(s, tl)) =
			£ çxé x ≈ (map term_tyvars tl))
À

»
	term_types :  TERM ã (TYPE ã bool)
…
		(És té term_types (mk_var (s,t)) = singleton_set t)
	Ä	(És té term_types (mk_const (s,t)) = singleton_set t)
	Ä	(Éf aé term_types (mk_comb (f,a)) =
			(term_types f) ° (term_types a))
	Ä	(Év bé term_types (mk_abs(v,b)) =
			(term_types v) ° (term_types b))
À
»
	term_tyvars :  TERM ã (string ã bool)
…
	Étm é term_tyvars tm = £(image type_tyvars (term_types tm))
À

Yet again the rule is a partial function:

»
	‚INST_TYPE_rule· : (string ã TYPE) ã SEQ ã SEQ ã bool
…
	É tysubs old_asms old_conc new_seqé
	INST_TYPE_rule tysubs (old_asms, old_conc) new_seq =
	(É (tyv : string) é
		tyv ù £ (image term_tyvars old_asms) ä
		(tysubs tyv = mk_vartype tyv))
	Ä
	(let asms_frees = £ (image freevars_set old_asms)
	in
		(new_seq = (old_asms, inst asms_frees tysubs old_conc)))
À


\subsection{Discharging an Assumption: DISCH}


The rule may now be defined. We tacitly assume that
the old theorem has a conclusion of type $\it:bool$.
»
	‚DISCH_rule· : TERM ã SEQ ã SEQ ã bool
…
	É tm old_asms old_conc new_seq é
	DISCH_rule tm (old_asms, old_conc) new_seq =
	(type_of_term tm = Bool) Ä
	(new_seq = (old_asms ƒ singleton_set tm, mk_imp(tm, old_conc)))
À

\subsection{Modus Ponens: MP}

This is straightforward. But, note the tacit assumption
that the conclusion of the antecedent theorem is a term
of type $\it:bool$.

»
	‚MP_rule· : SEQ ã SEQ ã SEQ ã bool
…
	É imp_asms imp_conc ant_asms ant_conc new_seq é
	MP_rule (imp_asms, imp_conc) (ant_asms, ant_conc) (new_asms, new_conc) =
	(is_imp imp_conc) Ä
	(imp_conc = mk_imp(ant_conc, new_conc)) Ä
	(new_asms = imp_asms ° ant_asms)
À


\section{THE AXIOM SCHEMATA} \label{AXIOMSCHEMATA}


\subsection{The Axiom Schema ASSUME}
This is straightforward, except that we must check
that the term being assumed is of the right type.
»
	‚ASSUME_axiom'· : TERM ã SEQ ã bool
…
	É tm é ASSUME_axiom' tm seq =
	(type_of_term tm = Bool) Ä 
	(seq = (singleton_set tm, tm))
À

\subsection{The Axiom Schema REFL}
This too is straightforward:
»
	‚REFL_axiom· : TERM ã SEQ
…
	É tm é REFL_axiom tm = (§, mk_eq(tm, tm))
À

\subsection{The Axiom Schema BETA\_CONV}

It is necessarily a partial rather than total,
function, given the way it
is parameterised. There is no obvious reparameterisation
to
avoid the problem. (If you supply the subterms of the
abstraction as parameters the types must be right).
It is, of course, useful for the implementers of the
HOL system to know that the relation we specify for it is in
fact a partial function:.

»
	‚BETA_CONV_axiom· : TERM ã SEQ ã bool
…
	É tm new_seqé
	BETA_CONV_axiom tm new_seq =
	Ñ v ty b a é
	(tm = mk_comb(mk_abs(mk_var(v, ty), b), a)) Ä
	(new_seq = 
	let subs: ((string â TYPE) ã TERM) = (ç(vx, tyx)é((vx = v) Ä (tyx = ty)) => a | mk_var(vx, tyx))
	in
		(§, (mk_eq(tm, subst subs b))))
À


\section{DERIVABILITY} \label{DERIVABILITY}


In this section we will define derivability.
This is a relation between sets of sequents
and sequents. As usual, we first define direct
derivability:
»
	‚directly_derivable_from· : SEQ ã (SEQ ã bool) ã bool
…
	É seq seqs é
	directly_derivable_from seq seqs = 
	(Ñ eqs tm old_seq é
	(image eqs (çxéT) • seqs) Ä (old_seq ù seqs) Ä SUBST_rule eqs tm old_seq seq)
	Å
	(Ñ vty old_seq é (old_seq ù seqs) Ä ABS_rule vty old_seqs seq)
	Å
	(Ñ tysubs old_seq é (old_seq ù seqs) Ä INST_TYPE_rule tysubs old_seqs seq)
	Å
	(Ñ tm old_seq é (old_seq ù seqs) Ä DISCH_rule tm old_seqs seq)
	Å
	(Ñ imp_seq ant_seq é (imp_seq ù seqs) Ä (ant_seq ù seqs) Ä MP_rule imp_seq ant_seq seq)
	Å
	(Ñ tm é ASSUME_axiom' tm seq)
	Å
	(Ñ tm é seq = REFL_axiom tm)
	Å
	(Ñ tm é BETA_CONV_axiom tm seq)
À
We need the following utility:

»
	‚elems· :  (* list) ã (* ã bool)
…
	e ù elems s Ç e ≈ s
À

Proofs will just be lists of sequents. Any non-empty
list is is a valid proof (of the sequent at its
head) on the premisses given by those elements
of the list which are not directly derivable
from elements later in the list.
There is little point in making the relevant type
definition for a syntactic class of proofs in this sense,
since they contain so little information.
We simply define the function which extracts the set
of premisses.

»
	‚premisses· :  (SEQ list) ã (SEQ ã bool)
…
	É seq rest é
	(premisses [] = §)
	Ä
	(premisses (CONC seq rest) =
		(directly_derivable_from seq (elems rest) => § | singleton_set seq) ° premisses rest)
À


»
	‚derivable_from· : SEQ ã (SEQ ã bool) ã bool
…
	É seq seqs é
	derivable_from seq seqs =
	Ñ seql é premisses (CONS seq seql) • seqs
À

\section{THEORIES AND THEOREMS} \label{THEORIESANDTHEOREMS}

The following type definitions help us to
formalise the context-sensitive aspects of the
well-formedness of terms, which we have avoided until
now. Once this is done we can define the type of all
well-formed HOL theories.

Â
new_type_abbrev(`‚TY_ENV·`, ":string ã num ã bool");;

new_type_abbrev(`‚CON_ENV·`, ":string ã TYPE ã bool");;

new_type_abbrev(`‚SEQS·`, ":SEQ ã bool");;
Ê


We can now define the well-formedness of types and terms with
respect to a type environment. We assume that
the names for type variables and type constructors
are in distinct lexical classes, and so all we
check is the arity of constructors.
(This agrees with the HOL system, except that the HOL
system imposes additional lexical constraints on the
names).
 
»
	‚wf_type· : TYPE ã TY_ENV ã bool
…
	É ty tyenv é
	wf_type ty tyenv = 
	(Ñs é ty = mk_vartype s)
	Ä
	(Ñs tyl é (tyenv s (length tyl)) Ä É t é t ≈ tyl ä wf_type t tyenv)
À

For terms we place no restrictions on the names of
variables. (The HOL system tries to prevent constant
names being used as variable names but does not
always succeed, e.g, if the constant is declared after
a theorem using a variable with the same name has been
saved on a theory).

»
	‚wf_term·: TERM ã TY_ENV ã CON_ENV ã bool
…
	É s ty f a v b  tyenv conenv é
	let ok = çtmé wf_term tm tyenv conenv
	in 
	((ok (mk_var(s,ty)) = (wf_type ty tyenv) Ä É t é å(conenv s t))
Ä	(ok (mk_const(s,ty)) = 
		(wf_type ty tyenv) Ä
		(Ñ ty' tysubsé (conenv s ty') Ä (inst_type tysubs ty' = ty)))
Ä	(ok (mk_comb(f, a)) = (ok f) Ä (ok a))
Ä	(ok (mk_abs(v, b)) = (ok v) Ä (ok b)))
À

The well-formedness of terms extends straightforwardly
to sequents and to sets thereof. We impose an
additional constraint for sequents: they must be
made up from terms of type \Bool.

»
	‚wf_seq·: SEQ ã TY_ENV ã CON_ENV ã bool
…
	É seq tyenv conenvé
	let ok = çtmé (wf_term tm tyenv conenv) Ä (type_of_term tm = Bool)
	in 
	(wf_seq seq tyenv conenv =
	((ok (concl seq)) Ä (Étmé (tm ù (hyp seq)) ä (ok tm))))
À

»
	‚wf_seqs·: SEQS ã TY_ENV ã CON_ENV ã bool
…
	É seqs tyenv conenvé
	wf_seqs seqs tyenv conenv =
	É seq é (seq ù seqs) ä (wf_seq seq tyenv conenv)
À

For the constant environments, we insist that the
type associated with each name be well-formed and
that at most one type is associated with each name.
Overloaded constant names could, in principle, be allowed,
as an extension to the system. This function would be
modified to impose some weaker condition.

»
	‚wf_con_env·: CON_ENV ã TY_ENV ã bool
…
	É conenv tyenvé
	wf_con_env conenv tyenv =
	(É con tyé (conenv con ty) ä (wf_type ty tyenv)) Ä
	(É con ty1 ty2 é (conenv con ty1) ä (conenv con ty2) ä (ty1 = ty2))
À

We insist that at most one arity be associated with
each name in a well-formed type environment:

»
	‚wf_ty_env·: TY_ENV ã bool
…
	É tyenvé
	wf_ty_env tyenv =
	É ty n1 n2 é (tyenv ty n1) ä (tyenv ty n2) ä (n1 = n2)
À

We can now define the type of all theories whose
components are well-formed. We will then take the subtype
of this consisting of all theories which extend the
minimal one (with just the constants for equality
and implication and the type of propositions).

Note that any of the a theory can contain infinitely many
of types, constants, axioms or theorems. This possibility
occurs in practice, at least for constants and axioms.
The theory {\it num} of natural numbers is an example.

«Õ`‚FTHEORY·``T`ÕÕÕÕÕÕÕÕÕÕﬂ
	ty_env		:TY_ENV,
	con_env		:CON_ENV,
	axioms		:SEQS,
	theorems	:SEQS
…ÕÕÕÕÕÕÕÕÕÕÕÕ
	(wf_ty_env ty_env) Ä
	(wf_con_env con_env ty_env) Ä
	(wf_seqs axioms ty_env con_env) Ä
	(wf_seqs theorems ty_env con_env) Ä
	(theorems • çseqéderivable_from seq axioms)
 ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ‡

»
	‚Star· : TYPE
…
	Star = mk_vartype `*`
À

{\it MIN} will be the minimal theory. It contains only
what is needed to define the inference rules.

»
	‚FMIN· : FTHEORY
…
	(	FMIN.T_ty_env = çty n é
		(	(ty = FST(dest_type Bool)) Ä
			(n  = length(SND(dest_type Bool)))
		) Å (	(ty = FST(dest_type(Fun Bool Bool))) Ä
			(n  = length(SND(dest_type(Fun Bool Bool))))
		)
	) Ä (	FMIN.T_con_env = çs tyé
			((s, ty) = dest_const (Equality Star)) Å
			((s, ty) = dest_const Implication)
	) Ä (	FMIN.T_axioms = §
	) Ä (	FMIN.T_theorems = §
	)
À

Á
	fextends : FTHEORY ã FTHEORY ã bool
…
	É thy1 thy2é
	fextends thy1 thy2 =
	(UNCURRY(thy2.T_ty_env) • UNCURRY(thy1.T_ty_env)) Ä
	(UNCURRY(thy2.T_con_env) • UNCURRY(thy1.T_con_env)) Ä
	((thy2.T_axioms) • (thy1.T_axioms)) Ä 
	((thy2.T_theorems) • (thy1.T_theorems))
À

We restrict attention to theories which extend the
minimal theory {\it FMIN}. Note that we do not
exclude inconsistent theories here. (This corresponds
to the possibility of introducing inconsistent axioms
in the HOL system).

Â
	sim_type_def `‚THEORY·`
	"(fthy : FTHEORY), (fthy fextends FMIN)";;
Ê

The following definitions are straightforward:

»
	‚MIN· : THEORY
…
	MIN = ABS_THEORY FMIN
À
Á
	‚extends· : THEORY ã THEORY ã bool
…
	É thy1 thy2é
	extends (ABS_THEORY thy1) (ABS_THEORY thy2) =
	thy1 fextends thy2
À
»
	‚axioms· : THEORY ã SEQS
…
	É thy é axioms (ABS_THEORY thy) = (thy.T_axioms)
À
»
	‚types· : THEORY ã TY_ENV
…
	É thy é types (ABS_THEORY thy) = (thy.T_ty_env)
À
»
	‚constants· : THEORY ã CON_ENV
…
	É thy é constants (ABS_THEORY thy) = (thy.T_conv_env)
À
»
	‚theorems· : THEORY ã SEQS
…
	É thy é theorems (ABS_THEORY thy) = (thy.T_theorems)
À

»
	‚sequents· : THEORY ã SEQS
…
	É thy é
		(seq ù sequents (ABS_THEORY thy)) Ç
		(wf_seq seq (fthy.T_ty_env) (fthy.T_con_env))
	
À

\section{THEOREMS, CONSISTENCY AND CONSERVATIVE EXTENSIONS}
\label{CONSISTENCY}

We can, at last, define the type of all HOL theorems.
A theorem will consist of a sequent and a theory.
The type is the subtype of the type of all such  pairs
in which the sequent is well-formed with respect to the
type and constant environments of the theory and in which
the sequent may be derived from the axioms of the theory.

«Õ`‚THM·``thm`ÕÕÕÕÕÕÕÕÕÕﬂ
	theorem	: SEQ,
	theory	: THEORY
…ÕÕÕÕÕÕÕÕÕÕÕÕ
	let fthy = REP_THEORY theory
	in
	(theorem ù sequents theory)
	Ä
	(derivable_from theorem (fthy.T_axioms))
 ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ‡
The following utility functions are useful:

»
	‚thm_seq· : THM -> SEQ
…
	É thm é thm_seq thm = FST (REP_THM thm)
À
»
	‚thm_thy· : THM -> THEORY
…
	É thm é thm_thy thm = SND (REP_THM thm)
À


A theory is consistent if not every sequent which
is well-formed in it can be derived from the axioms:

»
	‚consistent_theory· : THEORY ã bool
…
	É thy é
	consistent_theory thy =
	Ñ seq é
	(seq ù sequents thy)
	Ä
	å(derivable_from seq (axioms thy))
À

Á
	‚conservatively_extends· : THEORY ã THEORY ã bool
…
	É thy1 thy2é
	conservatively_extends thy1 thy2 =
	(thy1 extends thy2) Ä
	(É seq é
	(seq ù sequents thy2) ä
	(derivable_from seq (axioms thy1)) ä
	(derivable_from seq (axioms thy2)))
	
À


\section{THE RULES OF INFERENCE REVISITED} \label{RULESOFINFERENCEREVISITED}

Given our type of theorems, we can now define
the inference rules as relations between theorems, rather
than sequences.
»
	‚SUBST· : ((string â TYPE) ã THM) ã
			TERM ã THM ã THM ã bool
…
	É eqs tm old_thm new_thm é
	SUBST eqs tm old_thm new_thm =
	let old_seq = thm_seq old_thm in let old_thy = thm_thy old_thm
	in let new_seq = thm_seq new_thm in let new_thy = thm_thy new_thm
	in
	(SUBST_rule (thm_seq o eqs) tm old_seq new_seq
	Ä
	(new_thy extends old_thy) Ä
	(image (thm_thy o eqs)(çxéT) • $extends new_thy))
À
»
	‚ABS· : (string â TYPE) ã THM ã THM ã bool
…
	É vty old_thm new_thm é
	ABS vty old_thm new_thm =
	let old_seq = thm_seq old_thm in let old_thy = thm_thy old_thm
	in let new_seq = thm_seq new_thm in let new_thy = thm_thy new_thm
	in
	(ABS_rule vty old_seq new_seq Ä
	(new_thy extends old_thy)) 
À
»
	‚INST_TYPE· : (string ã TYPE) ã THM ã THM ã bool
…
	É tysubs old_thm new_thm é
	INST_TYPE tysubs old_thm new_thm =
	let old_seq = thm_seq old_thm in let old_thy = thm_thy old_thm
	in let new_seq = thm_seq new_thm in let new_thy = thm_thy new_thm
	in
	(INST_TYPE_rule tysubs old_seq new_seq Ä
	(new_thy extends old_thy)) 
À
»
	‚DISCH· : TERM ã THM ã THM ã bool
…
	É tm old_thm new_thm é
	DISCH tm old_thm new_thm =
	let old_seq = thm_seq old_thm in let old_thy = thm_thy old_thm
	in let new_seq = thm_seq new_thm in let new_thy = thm_thy new_thm
	in
	(DISCH_rule tm old_seq new_seq Ä
	(new_thy extends old_thy))
À
»
	‚MP· : THM ã THM ã THM ã bool
…
	É imp_thm ant_thm new_thm é
	MP imp_thm ant_thm new_thm =
	let imp_seq = thm_seq imp_thm in let imp_thy = thm_thy imp_thm
	in let ant_seq = thm_seq ant_thm in let ant_thy = thm_thy ant_thm
	in let new_seq = thm_seq new_thm in let new_thy = thm_thy new_thm
	in
	(MP_rule imp_seq ant_seq new_seq Ä
	(new_thy extends imp_thy) Ä (new_thy extends ant_thy))
À
{\tiny axiom schemata too}
\section{DEFINITIONAL EXTENSIONS} \label{DEFINITIONS}



\subsection{{\it new\_type} and {\it new\_constant}}

The first two definitional extension mechanisms,
{\it new\_type} and {\it new\_constant} are
conservative, but not very powerful.

»
	‚new_type· : num ã string ã THEORY ã THEORY ã bool
…
	É arity name thy1 thy2 é
	new_type arity name thy1 thy2 =
	(É n é å (types thy1 name n)) Ä
	(É s n é types thy2 s n = ((s = name) Ä (n = arity)) Å (types thy1 s n)) Ä
	(constants thy2 = constants thy1) Ä
	(axioms thy2 = axioms thy1) Ä
	(theorems thy2 = theorems thy1)

À
»
	‚new_constant· : string ã TYPE ã THEORY ã THEORY ã bool
…
	É name type thy1 thy2 é
	new_constant name type thy1 thy2 =
	(É ty é å (constants thy1 name ty)) Ä
	(É s ty é constants thy2 s ty = ((s = name) Ä (ty = type)) Å (constants thy1 s ty)) Ä
	(types thy2 = types thy1) Ä
	(axioms thy2 = axioms thy1) Ä
	(theorems thy2 = theorems thy1)

À

\subsection{{\it new\_axiom}}

{\it new\_axiom} is both powerful and dangerous!

»
	‚new_axiom· : TERM ã THEORY ã THEORY ã bool
…
	É tm thy1 thy2 é
	new_axiom tm thy1 thy2 =
	let seq = (§, tm)
	in
	((seq ù sequents thy1) Ä
	(types thy2 = types thy1) Ä
	(constants thy2 = constants thy1) Ä
	(axioms thy2 = axioms thy1 ° singleton_set seq) Ä
	(theorems thy2 = theorems thy1))

À
\subsection{{\it new\_definition}}
{\it new\_definition} is useful and safe
»
	‚new_definition· : string ã TERM ã THEORY ã THEORY ã bool
…
	É name tm thy1 thy2 é
	new_definition name tm thy1 thy2 =
	let ty = type_of_term tm
	in 
	Ñ thy1a é
	(new_constant name ty thy1 thy1a) Ä
	(freevars_set tm = §) Ä
	(term_tyvars tm • type_tyvars ty) Ä
	(new_axiom (mk_eq(mk_const(name, ty), tm)) thy1a thy2)
À

Too complete our specification of the basic definition
mechanisms, we need first to define a theory {\it LOG}
in which more of the standard logical apparatus is
available.

\subsection{THE THEORY {\it LOG}}

We need some more object language constructs:
»
	Truth : TERM
…
	Truth = mk_const(`T`, Bool)
À
»
	Truth_def : TERM
…
	let x = mk_var(`x`, Bool)
	in
	Truth_def = mk_eq(mk_abs(x, x), mk_abs(x, x))
À
»
	Forall : TERM
…
	Forall = mk_const(`É`, Fun (Fun Star Bool) Bool)
À
»
	Forall_def : TERM
…
	let P = mk_var(`P`, Fun Star Bool)
	in let x = mk_var(`x`, Star)
	in
	Forall_def = mk_abs(P, mk_eq(P, mk_abs(x,  Truth)))
À
»
	mk_forall : (TERM â TERM) ã TERM
…
	É tm1 tm2émk_forall(tm1, tm2) = 	mk_comb(Forall, mk_abs(tm1, tm2))
À
»
	dest_forall : TERM ã (TERM â TERM)
…
	É tm tm1tm2 é
	(tm = mk_forall tm1tm2) ä (dest_forall tm = tm1tm2)
À
»
	Choice : TERM
…
	Choice = mk_const(`á`, Fun (Fun Star Bool) Star)
À
»
	Exists_def : TERM
…
	let P = mk_var(`P`, Fun Star Bool)
	in let PchoiceP = mk_comb(P,mk_comb(Choice, P))
	in
	Exists_def = mk_abs(P, PchoiceP)
À
»
	Exists : TERM
…
	Exists = mk_const(`Ñ`, Fun (Fun Star Bool) Bool)
À

»
	mk_exists : (TERM â TERM) ã TERM
…
	É tm1 tm2émk_exists(tm1, tm2) = 	mk_comb(Exists, mk_abs(tm1, tm2))
À
»
	dest_exists : TERM ã (TERM â TERM)
…
	É tm tm1tm2 é
	(tm = mk_exists tm1tm2) ä (dest_exists tm = tm1tm2)
À

»
	Falsity : TERM
…
	Falsity = mk_const(`F`, Bool)
À
»
	Falsity_def : TERM
…
	let x = mk_var(`x`, Bool)
	in
	Falsity_def = mk_forall(x, x)
À
»
	Negation : TERM
…
	Negation = mk_const(`å`, Fun Bool Bool)
À
»
	Negation_def : TERM
…
	let x = mk_var(`x`, Bool)
	in
	Negation_def = mk_abs(x, mk_imp(x, Falsity))
À
»
	Conjunction : TERM
…
	Conjunction = mk_const(`/\\`, Fun Bool (Fun Bool Bool))
À
»
	Conjunction_def : TERM
…
	let x = mk_var(`x`, Bool)
	in let x1 = mk_var(`x1`, Bool)
	in let x2 = mk_var(`x2`, Bool)
	in
	Conjunction_def =
	mk_abs(x1, mk_abs(x2, mk_forall(x, mk_imp(mk_imp(x1, mk_imp(x2, x)), x))))
À
»
	Disjunction : TERM
…
	Disjunction = mk_const(`\\/`, Fun Bool (Fun Bool Bool))
À
»
	Disjunction_def : TERM
…
	let x = mk_var(`x`, Bool)
	in let x1 = mk_var(`x1`, Bool)
	in let x2 = mk_var(`x2`, Bool)
	in
	Disjunction_def =
	mk_abs(x1, mk_abs(x2, mk_forall(x, mk_imp(mk_imp(x1, x), mk_imp(mk_imp(x2, x), x)))))
À

{\tiny also need ONE\_ONE etc. to agree with draft manual}
»
	LOG : THEORY
…
	Ñ thy1 thy2 thy3 thy4 thy5 thy6 é
	let Name = FST o dest_const
	in
	(new_definition (Name Truth) Truth_def MIN thy1

Ä	new_definition (Name Forall) Forall_def thy1 thy2
Ä	new_definition (Name Exists) Exists_def thy2 thy3
Ä	new_definition (Name Falsity) Falsity_def thy3 thy4
Ä	new_definition (Name Negation) Negation_def thy4 thy5
Ä	new_definition (Name Conjunction) Conjunction_def thy5 thy6
Ä	new_definition (Name Disjunction) Disjunction_def thy6 LOG)
À

\subsection{{\it new\_specification}}
To define {\it new\_specification} we need a list
processing utility {\it split}, the function
{\it list\_mk\_exists} and a relation {\it new_constants}
which is like {\it new\_constant} but handles a
set of new constants.

»
	‚split· : ((* â **) list) ã (* list â ** list)
…
	(split [] = ([], []))
	Ä
	(É FSThd SNDhd rest é
	split (CONS(FSThd, SNDhd)rest) =
		let splitrest = split rest
		in
		(CONS FSThd (FST splitrest), CONS SNDhd (SND splitrest)))
À
»
	‚list_mk_exists· : (TERM list) ã TERM ã TERM
…
	(Étm é list_mk_abs [] tm = tm)
	Ä
	(É v rest tm é
	list_mk_exists (CONS v rest) tm = mk_exists(v, list_mk_exists rest tm))
	
À
»
	‚new_constants· : ((string â TYPE) ã bool) ã THEORY ã THEORY ã bool
…
	É cons thy1 thy2 é
	new_constants cons thy1 thy2 =
	(É s ty1 ty2 é ((s, ty1) ù cons) ä å(constants thy1 s ty2)) Ä
	(É s ty é constants thy2 s ty = ((s, ty) ù cons) Å constants thy1 s ty) Ä
	(types thy2 = types thy1) Ä
	(axioms thy2 = axioms thy1) Ä
	(theorems thy2 = theorems thy1)

À

We can now define {\it new\_specification}
»
	‚new_specification· : ((string â (string â TYPE)) list) ã
	TERM ã THM ã THEORY ã THEORY ã bool
…
	É pairs tm thm thy1 thy2 é
	new_specification pairs tm thm thy1 thy2 =
	let conl = FST(split pairs)
	in let varl = map mk_var (SND(split pairs))
	in let conc = list_mk_exists varl tm
	in let tyl = map SND (SND(split pairs))
	in let subs = ç(s, ty) é
		(Ñ c é (c, (s, ty)) ≈ pairs)
		 =>	mk_const((ácé(c, (s, ty)) ≈ pairs), ty)
		| 	mk_var(s, ty)
	in let axiom = subst subs tm
	in
	((freevars_set conc = §)
	Ä
	(card (elems conl) = length varl) Ä (card(elems varl) = length varl)
	Ä
	(thm_seq thm = (§, conc)) Ä (thy1 extends thm_thy thm)
	Ä
	(É tyé (ty ≈ tyl) ä (term_tyvars conc • type_tyvars ty))
	Ä
	(Ñ thy1a é
	new_constants (elems (combine conl tyl)) thy1 thy1a Ä
	new_axiom axiom thy1a thy2)
)
À

\subsection{{\it new\_type\_definition}}
%!!! GOT HERE !!! N.b. need 
»
	‚new_type_definition· : string ã
	TERM ã THM ã THEORY ã THEORY ã bool
…
	É name tm thm thy1 thy2 é
	new_specification name tm thm thy1 thy2 =
	let ty = hd(SND(dest_type(type_of_term tm)))
	in let let axiom = mk_exists()
À
\section{THEORY HIERARCHIES AND THE HOL SYSTEM} \label{THEORYHIERARCHIES}

The HOL system operates not with the totality
of the type {\it THEORY}, but with subsets of it.
The subsets are structured as hierarchies in which
each theory has a unique name and a parenthood relation is
given on the names. We will view this structure
as a function from names to theories. The function
is required to be order-preserving with respect
to parenthood (of names) and extension (of theories).

\subsection{Relations}

We need some generalities about relations.
First the standard notion of antisymmetry:


»
	‚antisymmetric· : (* ã * ã bool) ã bool
…
	antisymmetric R = É x y é (R x y) ä (R y x) ä (x = y)
À

Next domain and codomain:

»
	‚domain· : (* ã * ã bool) ã (* ã bool)
…
	É R x é (x ù domain R)  Ç Ñyé R x y
À

»
	‚codomain· : (* ã * ã bool) ã (* ã bool)
…
	É R x é (x ù codomain R)  Ç Ñyé R y x
À
We make the {\it ad hoc} definition that the {\it field}
of a relation is the union of its domain and codomain.

»
	‚field· : (* ã * ã bool) ã (* ã bool)
…
	É R é field R = domain R ° codomain R
À

We need the notion of a path between two elements in a
relation. 
 
»
	‚path· : (* list) ã (* ã * ã bool) ã * ã * ã bool
…
	É l R x y é
	path l R x y Ç 
	( (l = [x; y]) Ä R x y ) Å
	(Ñ x1 rest é (l = CONS x (CONS x1 rest)) Ä R x x1 Ä path rest R x1 y)
À
Using {\it path} we can define the ancestral of a relation:
 
»
	‚ancestral· : (* ã * ã bool) ã * ã * ã bool
…
	É R x y é
	ancestral R x y Ç Ñl é path l R x y
À

We will use the term {\it root} for a least element
of the ancestral of a relation. Such an element is
necessarily unique for a relation whose ancestral is
antisymmetric.

»
	‚root· : (* ã * ã bool) ã * ã bool
…
	É R min é root R min = Éy é (y ù field R) ä ancestral R min y
À

»
	‚rooted· : (* ã * ã bool) ã bool
…
	É R é rooted R = Ñ min é root R min
À

The final generality that we need is the idea of
an order-preserving function:
»
	‚order_preserving· : (* ã **) ã (* ã * ã bool) ã (** ã ** ã bool) ã bool
…
	order_preserving f R1 R2 = É x y é R1 x y ä R2 (f x) (f y)
À


\subsection{The Abstract State of a HOL System}

We can now give an abstract model for the state of
an implementation of an HOL system. The part of the
state which is to do with the theory hierarchy
is as follows:

«Õ`‚HOL_STATE·``HSt`ÕÕÕÕÕÕÕÕÕÕﬂ
	parent	: string ã string ã bool,
	theory	: string ã THEORY
…ÕÕÕÕÕÕÕÕÕÕÕÕ
	(antisymmetric (ancestral parent)) Ä
	(rooted parent) Ä
	(Émin é root parent min ä (theory min = MIN)) Ä
	(order_preserving theory parent $extends)
 ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ‡

In using the above definition we will only consider
theories associated with names within the field
of the parenthood relation. Thus the implementation
need not include an infinite database.

A HOL system would then be an
instance of the following datatype:

«`‚HOL_SYSTEM·``HSy`ÕÕÕÕÕÕÕÕﬂ
	transitions :(*INPUT â HOL_STATE) ã (HOL_STATE â *OUTPUT)
…ÕÕÕÕÕÕÕÕÕÕÕÕ
	T
 ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ‡

Moreover, if we wish,
we can restrict our attention to ``safe'' systems,
i.e. those permitting only consistent theories, using
the following predicates.
We say a state is consistent if all the theories named
in it are consistent.


»
	‚consistent_state· : HOL_STATE ã bool
…
	É hol_stateé
	consistent_state hol_state = 
	É thy é
	(Ñ name é
		(name ù field (hol_state.HSt_parents)) Ä
		((hol_state.HSt_theory) name = thy)
	) ä 	consistent_theory thy
À

»
	‚safe· : (*INPUT, *OUTPUT)HOL_SYSTEM ã bool
…
	É hol_system é
	safe hol_system =
	É input hol_state é
	consistent_state hol_state ä
	consistent_state (FST((hol_system.HSy_transitions)(input, hol_state)))
À


%\section{THE THEORY}
%\begin{FT}{}
% \input{holsyn.th.prt}
%\end{FT}

\twocolumn
\section{Index of Defined Terms}
\printindex
\end{document}

