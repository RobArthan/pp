=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{TECHNOLOGY PROJECTS}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{HOL Formalised: Language and Overview}  %% Mandatory field
\TPPref{DS/FMU/IED/SPC001}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{
This document is the first in a suite of documents
which give a formal specification of HOL. It acts as an overview
to the formal treatment and includes the detailed treatment
of the HOL language.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      R.D. Arthan \\ M.J.C. Gordon (Cambridge) \\ R.B.Jones \\ K. Blackburn \\ G.M. Prout
}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue 1.7 (19/10/89)]
First draft for comment.
\item[Issue 1.11 (6/11/89)]
The second draft. A number of errors have been corrected
(mainly in the definitions of substitution and type
instantiation). Comments on the first draft have been
taken into account. The initial theory $INIT$ containing
the standard axioms is defined together with the set of
theories which are extensions of it via the conservative
extension mechanisms $new\_definition$ etc.
\item[Issue 1.14 (21/11/89)]
A number of errors have been corrected as a result
of work done on the Z translation.
The document reference and theory name have been changed for IED library structure.
The appendix discussing reformulations of the logic
has been removed. It will probably
be used as a starting point for a supplementary document.
\item[Issue 1.16 (20/4/90)] Further corrections.
\item[Issue 1.17 (17/7/90)] Adapted for prototype ICL HOL. For the
time being this requires the support theories defined
in \cite{DS/FMU/IED/SML027}.
\item[Issue \SCCSversion (\FormatDate{$Date$%
})] Result of major revision. Material on inference rules
etc. has been shipped out to \cite{DS/FMU/IED/SPC003}.
Introduction now gives an overview of the documents which
make up the formalisation of HOL. The
representation of types and terms is now constructed
rather than axiomatised.
\end{description}
\subsection{Changes forecast}
Some brief description of the Z-like notations used may
be added for the benefit of readers who are not familiar with it.
\newpage
\section{GENERAL}
\subsection{Scope}
This document is part of a formal specification of the
HOL logic using the HOL system.
The formal specification is a formal treatment
of chapters 9 and 10 of the Cambridge
description \cite{SRI89a} of the HOL logic and proof development system.

This document contains an overview of the specification.
It also specifies the HOL language and the notion of
an HOL theory which are used throughout the specification.

\subsection{Introduction}
Section \ref{OVERVIEW}
of this document contains an overview
and a general discussion of the specification (which
because of its size is spread over several documents).

The remaining sections of the document are concerned
with defining types representing the main syntactic
structures used throughout the rest of the specification.
\pagebreak
\section{OVERVIEW OF THE SPECIFICATION}\label{OVERVIEW}
\subsection{Structure of the Specification}
Each document in the specification contributes an HOL theory.
The theories are as follows:

\begin{center}
\begin{tabular}{|l|l|l|p{4in}|}\hline
Name&Document & Parents & Description\\\hline
spc001&\cite{DS/FMU/IED/SPC001}&sml027\footnote{%
This is a support theory for this document containing
definitions of operations on sets, lists, strings etc.
It is defined in \cite{DS/FMU/IED/SML027}.}%
& This contains definitions pertaining to what we call the
HOL language. It defines the types $TYPE$, $TERM$ which
give an abstract syntax for HOL types, terms and
sequents (which are the sentences of the logic).
It also defines a type, $THEORY$, which is the simplest
variant of the notion of an HOL theory which we consider.
$THEORY$s correspond to the sets of axioms one works
with in treatments of first-order logic. \\\hline
spc002&\cite{DS/FMU/IED/SPC001}&spc001&
This specifies the semantics of the HOL language.
The main definitions are of a predicate $is\_set\_theory$
which specifies the sorts of universe
in which the semantics can be given and a predicate
$is\_model$ which specifies what it means to be a model
of an $THEORY$ in some such universe.
From this is defined a semantic notion of a theory,
a structure which consists of a $THEORY$
together with all the sequents which must be true
in any of its models. \\\hline
spc003&\cite{DS/FMU/IED/SPC003}&spc001&
This specifies the HOL deductive system. That is to say
it defines the notion of derivability (with respect
to a formalisation of the primitive inference rules
of HOL as described in \cite{SRI89a}). From this
a syntactic notion of a theory, a structure consisting
of a $THEORY$ together with all the sequents in teh
deductive closure of the axioms it contains. \\\hline
\end{tabular}
\end{center}

\subsection{Approach}
Initially we had hoped to specify
both the deductive system
(i.e. the formal theory
in the sense of a mathematical structure with sentences,
inference rules etc.) and the
system (i.e. the program which enable one
to calculate theorems).
However, in defining the deductive system
we frequently  found that attempts to
make the specification ``constructive'' tended to
obscure some issues. We have consequently erred on the
side of abstraction in most cases. For example, many
of the functions we need are partial functions: we
represent these as binary relations, rather than
approximate them with total functions.
This approach was felt to lead to a clearer
specification than would be obtained by using approximating
total functions together with checks on the arguments
supplied in each application.

In formalising the system we have, on occasion, felt
that certain changes would be desirable for one reason
or another. We have resisted all such urges ---
what is presented here is meant to be a rigorous
formulation of the logic as described in \cite{SRI89a}.
Where \cite{SRI89a} has proved a little too loose for our
purposes (e.g. in the details of type instantiation),
we have tried to follow the spirit of the HOL system.

There are occasionally differences in terminology
between our usage and \cite{SRI89a}. We have attempted
to indicate these as they arise.
This is most evident in the semantics since our treatment
is in HOL rather than ZF set theory as used in \cite{SRI89a}.

\pagebreak
\section{PREAMBLE}
\Hide{
extend_theory"SPC001";
}
We introduce the new theory. Its parents is a
library theory containing various definitions we need.
Â
close_theory();
load_theory"sml027";
new_theory"spc001";
Ê
\section{THE SYNTAX OF TYPES AND TERMS} \label{TYPESANDTERMS}

The HOL language of types and terms is given in \cite{SRI89a}
by a grammar similar to the following%

ÛBNF
	type	=	tyvar
		|	tycon
		|	type, `ã`, type
		|	`(`, type, {`,`, type}, `)`, tyop;
	term	=	var, `:`, type
		|	con, `:`, type
		|	term, term
		|	`ç`, var, `:`, type, `é`, term;
Ê
Here, we have translated the grammar to use the BS BNF notation
and renamed some of the symbols in the grammar
(e.g. I have used $type$ for $\sigma$).

We observe that the second and fourth alternatives
for $type$ may be merged if we view a type constant
as a nullary type operator and modify the fourth alternative
to allow for an empty list of parameters between the
brackets. Moreover, the third and fourth
alternatives may be merged by viewing `ã' as a binary
type operator (i.e. taking $\sigma_1 ã \sigma_2$ as
$(\sigma_1, \sigma_2)ã$).
The resulting grammar gives the language of
HOL types which we will itself represent as an HOL type
(called $TYPE$). 

We have asked for each variable or constant in a term to
be decorated with a type (for typographical convenience
written after a `:' rather
than as a subscript). Thus the grammar here is half
way between the untyped grammar given in \cite{SRI89a}
and the ``more accurate'' grammar in which every subterm
is decorated with type decorations which
respect the usual typing rules of the typed ç-calculus.
We will form a HOL type (called $TERM$)
to represent the language of HOL
terms by imposing these well-typing rules on the language
of candidate HOL terms given by
the grammar above.  

The well-typing rules we use do not consider
context-sensitive issues such as
conformance of the type of a
constant or the arity of a type
with a definition of the constant or type ---
such considerations are deferred until we have defined the
notion of a theory.
To some extent this approach is forced on us
since we wish to define a type of well-formed terms.
Since the system does not permit dependent types the
well-formedness predicate cannot be parameterised by
any form of context.

The terminal symbols $tyvar$, $tyop$, $var$ and $con$
which appear in the grammar stand for names of various
sorts of object. We will use the type $string$ to
represent names.

We construct the types $TYPE$ and $TERM$  as
subsets of the type of strings.
To do this we need to define an
unambiguous and irredundant concrete syntax for 
the HOL type and term languages\footnote{%
This approach has been followed
since T.~Melham's system for defining recursive types does not
currently support
recursion through the $list$ type constructor (and no analogue
is currently available for the ICL prototype HOL).%
}.
This concrete syntax is purely a technical device needed in
the present specification, and this document should not be considered
as specifying concrete syntax for actual use.

The concrete syntax we will use is given by the following
grammar:   
ÛBNF
	name	=	``
		|	(char - (`$` | `(` | `)` | `,` | `:` | `çç` | `é`)), name
		|	`$`, char, name;
	type	=	name
		|	`(`, [type, {`,`, type}], `)`, name;
	term	=	`V`, name, `:`, type
		|	`C`, name, `:`, type
		|	`(`, term, `)(`, term, `)`
		|	`çV`, name, `:`, type, `é`, term;
Ê

Here we the only undefined symbol is $char$ which stands for
the character set used to form strings.
We form names using a `$\$$' character
to protect occurrences of the characters `(', `)' etc.
which are used as delimiters in the grammar. This allows
arbitrary strings to be represented as names, which is
convenient for technical reasons.
N.B. this is not intended
to indicate that HOL proof development systems do use, or should
use, any such convention.

The following sections formalise the constructions we
have sketched above.

\subsubsection{Names}

It is technically convenient to allow arbitrary strings
to be used as names (since this lets us formulate and
use the constructors of the abstract syntax in a natural way).
To enable this we use
an encoding of names in the concrete representation which
allows an arbitrary string to be viewed as a name.
To do this we use an escape character to
protect any occurrences of the characters which act
as delimiters in the concrete representation of types
or terms.

We use `$\$$' as the escape character (in fact any
character other than `(', `)', `,', `:', `çç' or `é' would
do).
The encoding of is then given by the following function:
»
	‚encode· : string ã string
…
	encode `` = ``
Ä	Éch sé
	encode (ch ++ s) =
		(string_of_char ch ≈[`$`; `(`; `)`; `,`; `:`; `çç`; `é`]
		=>  `$` & (ch ++ encode s)
		| ch ++ encode s)
À
\subsection{Types}
Our concrete representations for types are the strings which
satisfy the predicate $is\_type$ defined below. This correspods
to the production $type$ in the grammar.

The following utility function is used to define the
representation of the constructor function for
to composite types.
»
	comma_list : string list ã string
…
	comma_list [] = ``
Ä	Éx t é comma_list (CONS x t) = (t = [] => x | x & `,` & comma_list t)
À
We now define the operations on strings which will
represent the constructor functions of the type $TYPE$.
»
	‚mk_vartype_rep·: string ã string

…
	Ésémk_vartype_rep s = encode s
À
»
	‚mk_type_rep·: string â string list  ã string
…
	És tlémk_type_rep(s, tl) = `(` & comma_list tl & `)` & (encode s)
À
We may now define $is\_type$ as the smallest set
which is closed under the constructors $mk\_vartype\_rep$
and $mk\_type\_rep$.
»
	‚is_type· : string ã bool
…
	is_type = ¢(çX:stringãboolé
	(Ésé(mk_vartype_rep s) ù X)
Ä	(Épars tyconé
		(Éparépar ≈ pars ä par ù X)
	ä	(mk_type_rep(tycon, pars)) ù X))
À
We now prove that $is\_type$ is non-empty and use
the result to define a new type, $TYPE$.
Â
val thm1 = TAC_PROOF( ([], ªÉséencode s ù is_typeº),
	EVERY[REWRITE_TAC[specification"-" "is_type", specification"sml027""¢", specification"-""mk_vartype_rep"],
	CONV_TAC(DEPTH_CONV SET_BETA_CONV) THEN REPEAT STRIP_TAC,
	ASM_REWRITE_TAC[]]);
Ê
The definition of the new type follows the usual pattern:  
Â
val TYPE_DEF = new_type_definition "TYPE_DEF" "TYPE" []
	(TAC_PROOF( ([], ªÑtyéis_type tyº),
		(EXISTS_TAC ªencode sº THEN
		REWRITE_TAC[PURE_ONCE_REWRITE_RULE[specification"sml027""ù"]thm1])))
	NORMAL;
Ê
Â
val TYPE_lemmas = show(
	define_new_type_isomorphisms TYPE_DEF "TYPE_lemmas"
	("ABS_TYPE", NORMAL) ("REP_TYPE", NORMAL) );
Ê
The constructor functions for the new type are as follows:
»
	‚mk_vartype·: string ã TYPE

…
	Ésémk_vartype s = ABS_TYPE (mk_vartype_rep s)
À
»
	‚mk_type·: string â TYPE list  ã TYPE
…
	És tlémk_type(s, tl) = ABS_TYPE(mk_type_rep(s, map REP_TYPE tl))
À
We will also need a destructor function for
types and the constant type \Bool:
»
	‚dest_type·: TYPE ã string â (TYPE list)
…
	És tylédest_type(mk_type(s, tyl)) = (s, tyl)
À
»
	‚Bool· : TYPE
…
	Bool = mk_type(`bool`, [])
À
\subsection{Terms}

The constructor functions for the type of terms will be
represented by the following operations on strings.

»
	mk_var_rep : string â TYPE ã string
…
	És ty é mk_var_rep (s, ty) = 
		`V` & encode s & `:` & REP_TYPE ty
À
»
	mk_const_rep : string â TYPE ã string
…
		És ty é mk_const_rep (s, ty) = 
		`C` & encode s & `:` & REP_TYPE ty
À
»
	mk_comb_rep : string â string ã string
…
	Étm1 tm2 é mk_comb_rep (tm1, tm2) = 
		`(` & tm1 & `)(` & tm2 &`)`
À
»
	mk_abs_rep : string â TYPE â string ã string
…
	És ty tm é mk_abs_rep (s, ty, tm) =
		 `ççV` & s & `:` & REP_TYPE ty & `é` & tm
À
The following utility for forming function types is useful:
»
	‚Fun· : TYPE ã TYPE ã TYPE
…
	É ty1 ty2éFun ty1 ty2 = mk_type(`ã`, [ty1; ty2])
À
The representation type for the well-formed terms will
be $stringâTYPE$. The first component gives the
concrete representation of the term according to
our grammar and the second component gives the type
of the term.  This representation is analogous to the terms
subscripted with their types one finds in \cite{SRI89a}.
The following predicate picks out the well-formed
terms, by imposing the appropriate typing rules.
»
	is_wf_term : (string â TYPE) ã bool
…
	is_wf_term = ¢(çX:(string â TYPE) ã boolé
	(És tyé(mk_var_rep(s, ty), ty) ù X)
Ä
	(És tyé(mk_const_rep(s, ty), ty) ù X)
Ä
	(Éf a tya tyé((f, Fun tya ty) ù X Ä (a, tya) ù X) ä (mk_comb_rep(f, a), ty) ù X)
Ä
	(És b tys tybé (b, tyb) ù X ä (mk_abs_rep(s, tys, b), Fun tys tyb) ù X))
À
Â
val thm2 = TAC_PROOF( ([], ªÉs tyé(mk_var_rep(s, ty), ty) ù is_wf_termº),
	EVERY[REWRITE_TAC[specification"-" "is_wf_term", specification"sml027""¢"],
	CONV_TAC(DEPTH_CONV SET_BETA_CONV) THEN REPEAT STRIP_TAC,
	ASM_REWRITE_TAC[]]);
Ê
The definition of the new type follows the usual pattern:  
Â
val TERM_DEF = new_type_definition "TERM_DEF" "TERM" []
	(TAC_PROOF( ([], ªÑtméis_wf_term tmº),
		(EXISTS_TAC ª(mk_var_rep(s, ty), ty)º THEN
		REWRITE_TAC[PURE_ONCE_REWRITE_RULE[specification"sml027""ù"]thm2])))
	NORMAL;
Ê
Â
val TERM_lemmas = show(
	define_new_type_isomorphisms TERM_DEF "TERM_lemmas"
	("ABS_TERM", NORMAL) ("REP_TERM", NORMAL) );
Ê
We can now define a function which assigns to any term
its type:
»
	‚type_of_term· : TERM ã TYPE
…
	É tm é  type_of_term tm = SND(REP_TERM tm)
À
The constructor functions for the type $TERM$, namely
$mk\_var$, $mk\_const$, $mk\_comb$ and $mk\_abs$,
could be defined as composites of
$mk\_cand\_var$ etc. and
the abstraction and representation functions for $TERM$.
Unfortunately the resulting function
$mk\_comb$ is not a total function.
Attempts to use an approximating total function turn out
to lead to difficulties when we wish to define functions
on terms by cases.
Thus we must use relations, at least for $\it mk\_comb$.
For uniformity we do this in all four cases.
Implementations exploit the fact
that these relations correspond to partial functions.

In our informal discussions below we will often use the
names $mk\_var$, $mk\_const$, $mk\_comb$ and $mk\_abs$
to refer to these relations viewed as partial functions
(i.e. with applicative notation).

The names chosen for the relations are intended to be
suggestive of phrases like: {\it(`1', ``:num'') has mk\_var 
``1''}.
»
	‚has_mk_var· : (string â TYPE) ã TERM ã bool
…
	É s ty tm é has_mk_var (s, ty) tm Ç tm = ABS_TERM (mk_var_rep(s, ty), ty)
À
»
	‚has_mk_const· : (string â TYPE) ã TERM ã bool
…
	É s ty tm é has_mk_const (s, ty) tm Ç tm = ABS_TERM (mk_const_rep(s, ty), ty)
À
»
	‚has_mk_comb· : (TERM â TERM) ã TERM ã bool
…
	É f a tm é
	has_mk_comb (f, a) tm Ç
	ÑtyéREP_TERM tm = (mk_comb_rep(FST(REP_TERM f), FST(REP_TERM a)), ty)
	
À
»
	‚has_mk_abs· : (TERM â TERM) ã TERM ã bool
…
	Év b tm é has_mk_abs (v, b) tm Ç
	(Ñ s tys tytm é has_mk_var (s, tys) v Ä (REP_TERM tm = (mk_abs_rep(s, tys, FST(REP_TERM b)), tytm)))
À

\subsection{Instantiation of Types}
When we define the type of HOL theories
we will need the following
function to formulate some of context-sensitive conditions
that we will wish to impose.
»
	‚inst_type· : (string ã TYPE) ã TYPE ã TYPE
…
	É(f: string ã TYPE) é
		(Ésé  inst_type f (mk_vartype s) = f s)
	Ä	(És tléinst_type f (mk_type(s, tl)) =
			mk_type(s, map (inst_type f) tl))
À


\section{SYNTAX OF SEQUENTS} \label{SEQUENTS}
A sequent is simply a set of assumptions
and a conclusion. Assumptions
and conclusion alike are just terms.
The following definition allows infinite
assumption sets, since they are easier for us to define.
However the axioms with which we shall work all have
finite sets of assumptions and the inference rules
will preserve this property.
Another pleasant property of sequents is for their
constituent terms to have type \Bool. This property,
too, holds of our axioms and is preserved by our inference
rules. When we define theories we insist that the
sequents in them have the latter property.

Â
TypeInference.new_type_abbrev"‚SEQ·" ª:(TERM ã bool) â TERMº;
Ê

The following functions on sequents are useful for reasons
of clarity. Their names are as in the HOL system. 
»
	‚concl· : SEQ ã TERM
…
	concl = SND 
À

»
	‚hyp· : SEQ ã (TERM ã bool)
…
	hyp = FST 
À


\section{THEORIES} \label{THEORIES}
In this section we define a type $THEORY$ whose
elements are what we shall think
of as the well-formed HOL theories.


The following type definitions help us to
formalise the context-sensitive aspects of the
well-formedness of terms, which we have avoided until
now. Once this is done we can define the type of all
well-formed HOL theories.

Â
TypeInference.new_type_abbrev "‚TY_ENV·" ª:string ã num ã boolº;

TypeInference.new_type_abbrev "‚CON_ENV·" ª:string ã TYPE ã boolº;

TypeInference.new_type_abbrev "‚SEQS·" ª:SEQ ã boolº;
Ê


We can now define the well-formedness of types and terms with
respect to a type environment. We assume that
the names for type variables and type constructors
are in distinct lexical classes, and so all we
check is the arity of constructors.
(HOL implementations may impose additional lexical
constraints on the names. ).
 
»
	‚wf_type· : TYPE ã TY_ENV ã bool
…
	É ty tyenv é
	wf_type ty tyenv = 
	((Ñs é ty = mk_vartype s)
	Å
	(Ñs tyl é (tyenv s (length tyl)) Ä É t é (t ≈ tyl) ä wf_type t tyenv))
À

For terms we place no restrictions on the names of
variables. (The HOL system tries to prevent constant
names being used as variable names but does not
always succeed, e.g, if the constant is declared after
a theorem using a variable with the same name has been
saved on a theory).

»
	‚wf_term·: TERM ã TY_ENV ã CON_ENV ã bool
…
	É tm s ty f a v b  tyenv conenv é
	let ok = çtmé wf_term tm tyenv conenv
	in
	(has_mk_var(s, ty) tm ä (ok tm = (wf_type ty tyenv) Ä É t é å(conenv s t)))
Ä	(has_mk_const(s, ty) tm ä (ok tm = 
		(wf_type ty tyenv) Ä
		(Ñ ty' tysubsé (conenv s ty') Ä (inst_type tysubs ty' = ty))))
Ä	(has_mk_comb(f, a) tm ä (ok tm = (ok f) Ä (ok a)))
Ä	(has_mk_abs(v, b) tm ä (ok tm  = (ok v) Ä (ok b)))
À

The well-formedness of terms extends straightforwardly
to sequents and to sets thereof. We impose an
additional constraint for sequents: they must be
made up from terms of type \Bool.

»
	‚wf_seq·: SEQ ã TY_ENV ã CON_ENV ã bool
…
	É seq tyenv conenvé
	let ok = çtmé (wf_term tm tyenv conenv) Ä (type_of_term tm = Bool)
	in 
	(wf_seq seq tyenv conenv =
	((ok (concl seq)) Ä (Étmé (tm ù (hyp seq)) ä (ok tm))))
À

»
	‚wf_seqs·: SEQS ã TY_ENV ã CON_ENV ã bool
…
	É seqs tyenv conenvé
	wf_seqs seqs tyenv conenv = É seq é (seq ù seqs) ä (wf_seq seq tyenv conenv)
À

For the constant environments, we insist that the
type associated with each name be well-formed and
that at most one type is associated with each name.
Overloaded constant names could, in principle, be allowed,
as an extension to the system. This function would then be
modified to impose some weaker condition.

»
	‚wf_con_env·: CON_ENV ã TY_ENV ã bool
…
	É conenv tyenvé
	wf_con_env conenv tyenv =
	(É con tyé (conenv con ty) ä (wf_type ty tyenv)) Ä
	(É con ty1 ty2 é (conenv con ty1) ä (conenv con ty2) ä (ty1 = ty2))
À

We insist that at most one arity be associated with
each name in a well-formed type environment:

»
	‚wf_ty_env·: TY_ENV ã bool
…
	É tyenvé
	wf_ty_env tyenv =
	É ty n1 n2 é (tyenv ty n1) ä (tyenv ty n2) ä (n1 = n2)
À

We can now define the type of all theories whose
components are well-formed.

Note that a theory can contain infinitely many
types, constants, or axioms. This possibility
occurs in practice, at least for constants and axioms.
The theory Ü of natural numbers is an example, since
it contains an axiom defining the decimal representation
of each positive number. 

«Õ"‚THEORY·""T"ÕÕÕÕÕÕÕÕÕÕﬂ
	ty_env		:TY_ENV,
	con_env	:CON_ENV,
	axioms		:SEQS
…ÕÕÕÕÕÕÕÕÕÕÕÕ
	(wf_ty_env ty_env) Ä
	(wf_con_env con_env ty_env) Ä
	(wf_seqs axioms ty_env con_env)
 ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ‡

The above introduces a new type S which may be
viewed as the labelled product of the types
$TY\_ENV$, $CON\_ENV$ etc.
New constants $T\_ty\_env$, $T\_con\_env$ are
also introduced. These are the projection functions
for the produce.

\pagebreak
\section{THEORY LISTING}
{\catcode`\_=\active
\gdef\underscoreoff{% make _ a normal char
        \catcode`\_=\active \let_=\_}}
{\underscoreoff
\def\Xref#1#2{\hbox to \hsize{$#1$\leaders\hbox to1em{\hss.\hss}\hfill $#2$}}
\input{\jobname.thp}}

\twocolumn
\section{INDEX OF DEFINED TERMS}
\printindex
\end{document}

=IGN
fun do_type (mk_vartype s) = s
|   do_type (mk_type (tycon, tys)) = "(" ^ format_list do_type tys "," ^ ")" ^ tycon;

fun do_term tm = (
	if is_comb tm
	then let val (tm1, tm2) = dest_comb tm
	in	"(" ^ do_term tm1 ^ ")(" ^ do_term tm2 ^ ")"
	end else if is_abs tm
	then let val ((s, ty), b) = (dest_var ** Combinators.I)(dest_abs tm)
	in	"çV" ^ s ^ ":" ^ do_type ty ^ "é" ^ do_term b
	end else  if is_var tm
	then let val (s, ty) = dest_var tm
	in	"V" ^ s ^ ":" ^ do_type ty
	end else let val (s, ty) = dest_const tm
	in	"C" ^ s ^ ":" ^ do_type ty
	end
);
val dt = diag_line o TRANSLATER.translate o do_term;

fun const_refs (thy : string) (what : TERM) : (string * SEQ) list = (
	let	val (s, _) = dest_const what;
		val tc = map fst o term_constants;
		fun aux (_, seq) = (
			not(s mem tc(snd seq) orelse
			any (fst seq) (fn tm => s mem tc tm))
		);
	in	(axioms thy drop aux) @ (definitions thy drop aux) @ (theorems thy drop aux)
	end handle msg => divert msg "dest_const" "const_refs"
	"term argument must be a constant"
);
