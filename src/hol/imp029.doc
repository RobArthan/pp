% imp029.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for Tactics III}  %% Mandatory field
\def\TPPheadtitle{Implementation for Tactics III}
\TPPref{DS/FMU/IED/IMP029}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First draft: place holder for tautology material.
\item [Issue 1.2]
Added rest of material.
\item [Issue 1.3]
Modified $spec\_asm\_tac$, et al.
\item [Issue 1.4]
Reacting to issue 1.5 of \cite{DS/FMU/IED/DTD051}.

\item[Issue 1.5, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.6]
Changed working theory.
\item [Issue 1.8(11th March 1992)]
Various minor additions and extensions.
\item [Issue 1.9(18th March 1992)]
Corrected ordering of implementation.
\item [Issue 1.10 (26th March 1992)]
Changed to use proof context material of issue 1.13 of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.11 (31st March 1992)]
Added understanding of double negation
to $≥\-\_rewrite\-\_canon$.
\item [Issue 1.12 (2nd April 1992)]
Changes required by CR0016.
\item [Issue 1.13 (14th April 1992)]
Changes due to CR0017.
\item [Issue 1.14 (12th May 1992)]
Changed theory.
\item [Issue 1.15 (14th May 1992)]
Tidying up proof contexts.
\item [Issue 1.16,1.17 (20th May 1992)]
Rearranging build proof contexts.
\item [Issue 1.18 (26th May 1992)]
Renamings from version 1.5 of DS/FMU/IED/WRK038.
\item [Issue 1.19 (27th May 1992)]
Added $all\_¬\_tac$.
\item [Issue 1.20 (2nd June 1992)]
Changed ``native'' theory. 
\item[Issue 1.21 (24th June 1992)]
Renamings from issue 1.6 of \cite{DS/FMU/IED/WRK038},
mostly proof context name changes.
\item [Issue 1.22 (5th July 1992)]
Added $step\_strip\_tac$ and $THEN1$.
\end{description}
\subsection{Changes Forecast}
None known.
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of third group of tactics.
This primarily concerns adding paired abstraction handling
to the functions of \cite{DS/FMU/IED/DTD028}.
This is called for in \cite{DS/FMU/IED/HLD012}.
The design is in \cite{DS/FMU/IED/DTD029},
and the functions tested in {DS/FMU/IED/MDT029}
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the third group of tactics.
This primarily concerns adding paired abstraction handling
to the functions of \cite{DS/FMU/IED/DTD028}.
\subsubsection{Dependencies}
This documents signature is found in \cite{DS/FMU/IED/DTD029}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.

\section{THE CODE}
=SML
structure €Tactics3› : Tactics3 = struct
=TEX
=SML
val €was_theory› = get_current_theory_name ();
val _ = open_theory "basic_hol";
val _ = set_merge_pcs ["'propositions",
	"'simple_abstractions"];
=TEX
\subsection{Utilities}
=SML
fun €mk_fst› tm = (
let	val ttm = type_of tm;
	val (ta,tb) = dest_∏_type ttm;
in
	mk_app(mk_const("Fst", mk_≠_type(ttm,ta)), tm)
end);
fun €mk_snd› tm = (
let	val ttm = type_of tm;
	val (ta,tb) = dest_∏_type ttm;
in
	mk_app(mk_const("Snd", mk_≠_type(ttm,tb)), tm)
end);
=TEX
The following makes a term follow the pairing structure  of a variant structure, using $Fst$ and $Snd$.
=SML
fun €varstruct_match› (caller : string) (fmsg : int) (tm : TERM) (vs : TERM) : TERM = (
let	val sideeffect = if not(type_of tm =: type_of vs)
		then term_fail caller fmsg [tm,vs]
		else ();
	fun aux (ltm : TERM) (lvs : TERM) = (
		if is_var lvs
		then ltm
		else let val (vs1,vs2) = dest_pair lvs;
			val (tm1,tm2) = if is_pair ltm
				then dest_pair ltm
				else (mk_fst ltm, mk_snd ltm);
		in
			mk_pair(aux tm1 vs1, aux tm2 vs2)
		end);
in
	aux tm vs
end
handle complaint =>
divert complaint "dest_pair" caller fmsg 
	[fn () => string_of_term tm,
	 fn () => string_of_term vs]
);
=TEX
\subsection{Concerning ≥}
=SML
val €≥_simple_∂â1_conv› : CONV = (fn tm =>
	((RAND_C simple_∂â1_conv THEN_C ≥_simple_∂_conv) tm)
	handle  Fail _ => term_fail "≥_∂â1_conv" 28091 [tm]
);
val €≥_∂â1_conv› : CONV = (fn tm =>
	((RAND_C ∂â1_conv THEN_C ≥_∂_conv) tm)
	handle  Fail _ => term_fail "≥_∂â1_conv" 28091 [tm]
);
=TEX
=SML
local
	val c = eqn_cxt_conv ((map thm_eqn_cxt
		[≥_≥_thm, ≥_±_thm, ≥_≤_thm, ≥_¥_thm,
		 ≥_§_thm, ≥_if_thm, ≥_t_thm, ≥_f_thm]) @
		[(¨≥(µ x ∑ y)Æ, ≥_simple_µ_conv),
		(¨≥(∂ x ∑ y)Æ, ≥_simple_∂_conv),
		(¨≥(∂â1 x ∑ y)Æ, ≥_simple_∂â1_conv),
		(¨≥($µ (Uncurry x))Æ, ≥_µ_conv),
		(¨≥($∂ (Uncurry x))Æ, ≥_∂_conv),
		(¨≥($∂â1 (Uncurry x))Æ, ≥_∂â1_conv)]);
in
val €≥_in_conv› : CONV = (fn tm =>
	c tm
	handle complaint =>
	divert complaint "eqn_cxt_conv" "≥_in_conv" 28131
		[fn () => string_of_term tm]
);
end;
=TEX
=SML
val €≥_in_tac› : TACTIC = (fn ag => conv_tac ≥_in_conv ag
	handle complaint =>
	divert complaint "≥_in_conv" "≥_in_tac" 28025 []
);
=TEX
=SML
val €≥_IN_THEN› : THM_TACTICAL = (fn ttac => fn thm =>
	(ttac(conv_rule ≥_in_conv thm))
	handle Fail _ => thm_fail "≥_IN_THEN" 29010 [thm]
);
=TEX
\subsection{Concerning µ}
=SML
val €µ_tac› : TACTIC = (fn (seqasms, conc) =>
	let	val (x, b) = dest_µ conc;
		val x' = varstruct_variant (flat(map frees(conc::seqasms))) x;
		val xtm = snd(term_match x' x);
	in
		([(seqasms, var_subst xtm b)],
		(fn [thm] => µ_intro x' thm | _ => bad_proof "µ_tac"))
	end handle ex => divert ex "dest_µ" "µ_tac" 29001 []
);
=TEX
\subsection{Concerning ∂}
=SML
fun €∂_tac› (tm : TERM) : TACTIC = (fn (seqasms, conc) =>
let	val (x, b) = dest_∂ conc;
	val tym = type_match (type_of x) (type_of tm);
	val tm' = inst [] tym tm;
	val tm'' = varstruct_match "∂_tac" 29008 tm' x;
	val tmsubs = snd(term_match tm'' x);
in
		([(seqasms, var_subst tmsubs b)],
		(fn [thm] => ∂_intro conc thm | _ => bad_proof "∂_tac"))
end
handle ex =>
list_divert ex "∂_tac" [
	("type_match", 29008, 
		[fn () => string_of_term tm,
		fn () => string_of_term (fst(dest_∂ conc))]),
	("dest_∂", 29002, [])]
);
=TEX
=SML
fun €∂_THEN› (ttac : THM -> TACTIC): THM -> TACTIC = (fn thm =>
let	val (x, b) = dest_∂(concl thm);
in	(fn (seqasms, conc) =>
	let	val x' = varstruct_variant (flat(map frees
			(conc :: concl thm :: asms thm @ seqasms))) x;
		val xtm = snd(term_match x' x);
		val (sgs, pf) = ttac (asm_rule (var_subst xtm b)) (seqasms, conc);
	in	(sgs, (∂_elim x' thm) o pf)
	end)
end
handle ex => divert ex "dest_∂" "∂_THEN" 29003 
		[fn () => string_of_thm thm]
);
=TEX
\subsection{Concerning ∂$_1$}
=SML
fun €∂â1_tac› (tm : TERM): TACTIC = (fn (seqasms,gl) =>
	((conv_tac ∂â1_conv
	THEN ∂_tac tm)	(seqasms,gl)
	handle complaint =>
	pass_on complaint "∂_tac" "∂â1_tac")
	handle complaint =>
	divert complaint "∂â1_conv" "∂â1_tac" 29004 []
);
=TEX
=SML
fun €∂â1_THEN› (ttac : THM -> TACTIC): THM -> TACTIC = (fn thm =>
	∂_THEN ttac (conv_rule ∂â1_conv thm)
	handle complaint =>
	divert complaint "∂â1_conv" "∂â1_THEN"
		29005 [fn ()=> string_of_thm thm]
);
=TEX
\subsection{Concerning Ã}
=SML
val €all_¬_tac› : TACTIC = (fn gl =>
	conv_tac all_¬_conv gl
	handle complaint =>
	pass_on complaint "all_¬_conv" "all_¬_tac"
);
=TEX
\subsection{Concerning Assumptions}
=SML
fun €spec_asm_tac› (asm : TERM) (instance : TERM)  :TACTIC = (
	GET_ASM_T asm (strip_asm_tac o µ_elim instance)
);
fun €list_spec_asm_tac› (asm : TERM) (instances : TERM list)  :TACTIC = (
	GET_ASM_T asm (strip_asm_tac o list_µ_elim instances)
);
fun €spec_nth_asm_tac› (n : int) (instance : TERM)  :TACTIC = (
	GET_NTH_ASM_T n (strip_asm_tac o µ_elim instance)
);
fun €list_spec_nth_asm_tac› (n : int) (instances : TERM list)  :TACTIC = (
	GET_NTH_ASM_T n (strip_asm_tac o list_µ_elim instances)
);
=TEX
=SML
fun €SPEC_ASM_T› (asm : TERM) (instance : TERM) 
	(thmtac:THM -> TACTIC):TACTIC = (
	GET_ASM_T asm (thmtac o µ_elim instance)
);
fun €LIST_SPEC_ASM_T› (asm : TERM) (instances : TERM list) 
	(thmtac:THM -> TACTIC) :TACTIC = (
	GET_ASM_T asm (thmtac o list_µ_elim instances)
);
fun €SPEC_NTH_ASM_T› (n : int) (instance : TERM) 
	(thmtac:THM -> TACTIC)  :TACTIC = (
	GET_NTH_ASM_T n (thmtac o µ_elim instance)
);
fun €LIST_SPEC_NTH_ASM_T› (n : int) (instances : TERM list) 
	(thmtac:THM -> TACTIC) :TACTIC = (
	GET_NTH_ASM_T n (thmtac o list_µ_elim instances)
);
=TEX
\subsection{Concerning Tautologies}
=SML
val €taut_tac› : TACTIC = (fn gl =>
	(REPEAT µ_tac THEN simple_taut_tac) gl
	handle complaint =>
	if area_of complaint = "simple_taut_tac"
	then fail "taut_tac" 29020 []
	else reraise complaint (area_of complaint)
);
=TEX
=SML
fun €taut_rule› (tm : TERM) : THM = (
	tac_proof(([],tm),taut_tac)
handle complaint =>
divert complaint "tac_proof" "taut_rule" 27037 [fn () => string_of_term tm]
);
=TEX
=SML
val €taut_conv› : CONV = (fn (tm : TERM) =>
let	val thm = tac_proof(([],tm),taut_tac)
in
	§_t_intro thm
end
handle complaint =>
term_fail "taut_conv" 27037 [tm]
);
=TEX
\subsection{Single Stepping $strip\_tac$}
=SML
fun €right_strip_±_rule› (thm : THM) : THM list = (
let	val s1 = ±_left_elim thm;
	val s2 = ±_right_elim thm;
in
	(s1 :: right_strip_±_rule s2)
end
handle (Fail _) => [thm]
);
=TEX
=SML
fun €ante_±_tac› ([]:THM list) : TACTIC = id_tac
| ante_±_tac x = ante_tac (list_±_intro x);
=TEX
=SML
fun €step_check_asm_tac› (thm : THM) : TACTIC = (fn gl as (seqasms, conc) =>
let	val cnjs = right_strip_±_rule thm;
	val t = concl (hd cnjs);
in	if t ~=$ conc
	then (accept_tac (hd cnjs))
	else if is_t t
	then ante_±_tac (tl cnjs)
	else if is_f t
	then f_thm_tac (hd cnjs)
	else if is_≥ t
	then	let	val t' = dest_≥ t;
			fun aux (asm :: more) = (
				if t ~=$ asm
				then ante_±_tac (tl cnjs)
				else if asm ~=$ t'
				then accept_tac (≥_elim conc (asm_rule asm) (hd cnjs))
				else if asm ~=$ conc
				then (accept_tac (asm_rule asm))
				else aux more
			) | aux [] = asm_tac (hd cnjs) THEN
				ante_±_tac (tl cnjs);
		in	aux seqasms
		end
	else	let	fun aux (asm :: more) = (
				if t ~=$ asm
				then ante_±_tac (tl cnjs)
				else if is_≥ asm andalso (dest_≥ asm) ~=$ t
				then accept_tac (≥_elim conc (hd cnjs) (asm_rule asm))
				else if asm ~=$ conc
				then (accept_tac (asm_rule asm))
				else aux more
				) | aux [] = asm_tac (hd cnjs) THEN
					ante_±_tac (tl cnjs);
		in	aux seqasms
		end
end	gl
);
=TEX
=SML
fun €step_conv_¥_tac› (cnv : CONV) : THM -> TACTIC = (fn thm =>
let	val cnjs = right_strip_±_rule thm;
	val cnj1 = conv_rule (CHANGED_C cnv) (hd cnjs);
in
	ante_±_tac (cnj1 :: tl cnjs)
end);
=TEX
=SML
val €step_≤_¥_tac› : THM -> TACTIC = (fn thm => 
let	val cnjs = right_strip_±_rule thm;
	val (t1,t2) = dest_≤ (concl (hd cnjs));
in	(fn (seqasms, conc) =>
	let	val (sgs1, pf1) = ante_±_tac (asm_rule t1 :: tl cnjs) (seqasms, conc);
		val (sgs2, pf2) = ante_±_tac (asm_rule t2 :: tl cnjs) (seqasms, conc);
	in	(sgs1 @ sgs2,
			(fn thl =>
			let	val len = length sgs1;
			in ≤_elim (hd cnjs) (pf1(thl to (len - 1))) 
				(pf2(thl from len))
			end
			))
	end)
end
handle ex => divert ex "dest_≤" "step_≤_¥_tac" 28042 
	[fn () => string_of_thm thm]
);
=TEX

=SML
val €step_±_¥_tac› : THM -> TACTIC = (fn thm =>
let	val cnjs = right_strip_±_rule thm;
	val thm1 = ±_left_elim (hd cnjs);
	val thm2 = ±_right_elim (hd cnjs);
in
	ante_±_tac (thm1 :: thm2 :: tl cnjs)
end
handle ex => divert ex "±_left_elim" "step_±_¥_tac" 28032 
	[fn () => string_of_thm thm]
);
=TEX
=SML
val €step_simple_∂_¥_tac› : THM_TACTIC = (fn thm =>
let	val cnjs = right_strip_±_rule thm;
	val (x, b) = dest_simple_∂(concl (hd cnjs));
in	(fn (seqasms, conc) =>
	let	val x' = variant (flat(map frees
			(conc :: concl thm :: asms thm @ seqasms))) x;
		val (sgs, pf) = ante_±_tac ((asm_rule (var_subst[(x', x)] b)) :: (tl cnjs)) 
			(seqasms, conc);
	in	
		(sgs, (simple_∂_elim x' (hd cnjs)) o pf)
	end)
end
handle ex => divert ex "dest_simple_∂" "step_simple_∂_¥_tac" 28093 
	[fn () => string_of_thm thm]
);
=TEX

=SML
fun MAP_FIRST1 [] v = (
	fail_with_tac "step_strip_asm_tac" 28003 
		[fn () => string_of_thm v]
) | MAP_FIRST1 (a :: x) v = a v handle (Fail _) => 
	MAP_FIRST1 x v;
=TEX
If the theorem given is a conjunct then this
should operate on the first conjunct, returning the second
unchanged.
This may cause compatibility problems for a proof context conversion that
matches against conjuncts.
=SML
val €step_strip_asm_tac› : THM_TACTIC = (fn thm :THM =>
	MAP_FIRST1
	[step_conv_¥_tac (current_ad_st_conv()),
		step_±_¥_tac, 
		step_≤_¥_tac, 
		step_simple_∂_¥_tac,
		step_check_asm_tac]
	thm
);
=TEX
=SML
val €step_strip_tac› : TACTIC = (fn gl =>
	(FIRST[ conv_tac(current_ad_sc_conv()),
		simple_µ_tac,
		±_tac,
		¥_T step_strip_asm_tac,
		t_tac,
		concl_in_asms_tac]
	ORELSE_T
		fail_with_tac "step_strip_tac" 28003 
		[fn () => string_of_term(snd gl)])
	gl
);
=TEX
\section{TACTICALS}
=SML
fun ((tac1 : TACTIC) €THEN_T1› (tac2 : TACTIC)) : TACTIC = (fn gl =>
	let	val (sgs1, pf) = tac1 gl;
		val (sgs2pfs2) = case sgs1 of
			(a :: x) => (tac2 a :: map id_tac x)
			| _ => [];
	in	(flat (map fst sgs2pfs2),
		pf o map_shape (map (fn (sgs, pf) => (pf, length sgs))sgs2pfs2))
	end
);
=TEX
=SML
val op €THEN1› : (TACTIC * TACTIC) -> TACTIC = op THEN_T1;

=TEX
\section{CANONICALISATION}
=SML
fun €≥_rewrite_canon› (thm : THM) : THM list = (
	(dest_≥(concl thm);
	[conv_rule (FIRST_C[
		simple_eq_match_conv ≥_≤_thm,
		≥_∂_conv,
		≥_≥_conv,
		simple_eq_match_conv ≥_thm1])thm])
	handle complaint =>
	fail_canon thm
);
=TEX
=SML
fun €µ_rewrite_canon› (thm : THM) : THM list = (
	if is_µ (concl thm)
	then [all_µ_elim thm]
	else fail_canon thm
);
=TEX
=SML
val €pair_rw_canon› : CANON =
	REWRITE_CAN
	(REPEAT_CAN(FIRST_CAN [
	µ_rewrite_canon,
	±_rewrite_canon,
	≥_rewrite_canon,
	f_rewrite_canon,
	§_t_rewrite_canon]));
=TEX
\section{PROOF CONTEXTS}
\subsection{Local Theorems}
=SML
fun €sprove› (tm : TERM) = tac_proof(([],tm),REPEAT strip_tac);
val €lif_thm› = sprove ¨µ a t1 t2∑ (if a then t1 else t2) § (a ¥ t1) ± (≥ a ¥ t2)Æ;
val €l≤_≥_thm› = sprove ¨µ t1 t2 ∑ (t1 ≤ ≥ t2) § (t2 ¥ t1)Æ;
val €l≥_≤_thm› = sprove ¨µ t1 t2 ∑ (≥ t1 ≤ t2) § (t1 ¥ t2)Æ;
val €l≤_thm› = sprove ¨µ t1 t2 ∑ (t1 ≤ t2) § (≥ t1 ¥ t2)Æ;
=TEX
\subsection{The Contexts}
Now create a build proof contexts (which will be completed and commited in 
\cite{DS/FMU/IED/IMP076}).
=SML
val _ = new_pc "€'paired_abstractions›";
val _ = set_st_eqn_cxt [
		 (¨≥ xÆ, ≥_in_conv),
		 (¨$∂â1(Uncurry f)Æ, ∂â1_conv),
		 (¨$µ (Uncurry f)Æ, µ_uncurry_conv),
		 (¨$∂ (Uncurry f)Æ, ∂_uncurry_conv)
		 ] "'paired_abstractions";
val _ = set_sc_eqn_cxt [(¨≥ xÆ, ≥_in_conv),
		 (¨$µ (Uncurry f)Æ, µ_uncurry_conv)] "'paired_abstractions";
val _ = set_rw_canons [µ_rewrite_canon,
		≥_rewrite_canon] "'paired_abstractions";
val _ = set_rw_eqn_cxt [(¨Uncurry x yÆ, ¬_conv)] 
	"'paired_abstractions";
=TEX
Now set this context plus ``build$\-\_$propositions''as the current ones:
=SML
val _ = set_merge_pcs ["'propositions",
	"'paired_abstractions"];
=TEX
Restore the previous theory:
=SML
val _ = open_theory was_theory;
=TEX
\section{END OF THE STRUCTURE}
=SML
end; (* of structure Tactics3 *)
open Tactics3;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


