% imp019.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation for ICL HOL Parser}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP019}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the implementation for the
parser for ICL HOL.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion (\FormatDate{$Date$%
})]
First draft for comment.
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the parser for ICL HOL.
The detailed design for this material is in \cite{DS/FMU/IED/DTD019}.
\subsection{Introduction}

\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD019}.

\subsection{Dependencies}
The parser is dependent on the lexical analyser, \cite{DS/FMU/IED/DTD015}, 
and on the symbol table, \cite{DS/FMU/IED/DTD020}.
\subsection{Possible Enhancements}
The error messages could be improved by using a hand-coded function to
print out the parsing stack.
\subsection{Deficiencies}
The parser accepts a slightly larger language than that specified in
\cite{DS/FMU/IED/DEF001} in that it allows infix, prefix and
postfix syntax and type constraints in local function definitions.
It also allows antiquotation in local definitions and bound variable
declarations.
\subsection{PREAMBLE}
=SML
structure âParserá : Parser = struct
=SML
=TEX
We need to include the SLRP driver code at this point:
=INCLUDE
imp018.sml
=SML
open EfficientDictionary Lex SlrpDriver;
=TEX
\subsection{Utilities}
=SML
fun âparse_errorá (msg : int) (insert : string) : 'a = (
	diag_line (get_error_message 17001 []);
	diag_line (get_error_message msg [insert]);
	fail "HOL parser"  17000 []
);
=TEX
=SML
fun âstack_errorá (insert : string) : 'a = (
	error "HOL parser"  17005 [fn() => insert]
);
=TEX
\section{THE GRAMMAR}\label{THEGRAMMAR}
The reference grammar given in \cite{DS/FMU/IED/DEF001} requires a certain
amount of adaptation. First of all we identify several subcategories of
the category $Tm$ as follows (each one of which includes the next):

\begin{tabular}{|l|p{4in}|}\hline
Name & Description \\ \hline
$Tm$ & The low precedence mixfix term constructs, viz. binders, conditionals, 
and let-terms,
together with applications of nonfix functions to such constructs.
\\\hline
$Tm1$ & The infix, prefix and postfix term constructs, with comma identified
as a special case of infix (since it plays a special role in types).
\\\hline
$Tm2$ & Nonfix function applications, possibly with type constraints.
\\\hline
$Tm3$ & The atomic term constructs such as names, string literals etc. and the
various bracketed term constructs
\end{tabular}

This makes the grammar reflect roughly the precedence rules of
\cite{DS/FMU/IED/DEF001}. We then spell out the iteration constructs which
are used in \cite{DS/FMU/IED/DEF001}. To abbreviate the grammar, we choose
to use $Tm2$ and $Tm4$ instead of the categories $V$ and $V1$, leaving the
check on the form of the variable structure to be handled by the reduction
functions. Similarly we use $Tm1$ instead of $L$.

The resulting grammar, together with the actions we assocate with each
alternative is as follows:

=IGN
cat >imp019.grm.txt
=DUMP
imp019.grm.txt
(* Terms *)
	Tm	=	HLBinder, BndVars, `HLBlob`, Tm		(red_binder x1 x2 x4)
		|	`HLLet`, Tm1, AndLet, `HLIn`, Tm		(red_let2 x2 x3 x5)
		|	`HLIf`, Tm, `HLThen`, Tm, `HLElse`, Tm 	(red_cond x2 x4 x6)
		|	Tm2, HLBinder, BndVars, `HLBlob`, Tm		(red_tm2_binder x1 x2 x3 x5)
		|	Tm2, `HLLet`, Tm1, AndLet, `HLIn`, Tm	(red_tm2_let2 x1 x3 x4 x6)
		|	Tm2, `HLIf`, Tm, `HLThen`, Tm, `HLElse`, Tm 	(red_tm2_cond x1 x3 x5 x7)
		|	Tm1					(red_fetch x1);

	Tm1	=	Tm1, HLInOp, Tm				(red_inop x1 x2 x3)
		|	Tm1, `HLComma`, Tm			(red_pair x1 x3)
		|	HLPreOp, Tm				(red_preop x1 x2)
		|	Tm1, HLPostOp				(red_postop x1 x2)
		|	Tm2					(red_fetch x1);

	Tm2	=	Tm2, `HLColon`, Ty			(red_typed x1 x3)
		|	Tm2, Tm3				(red_app x1 x2)
		|	Tm3					(red_fetch x1);

	Tm3	=	HLName					(red_tmname x1)
		|	HLString				(red_string x1)
		|	HLChar					(red_char x1)
		|	HLAqTm					(red_tmaq x1)
		|	`HLLbrace`, OptTms, `HLRbrace`		(red_setdisplay x2)
		|	`HLLbrace`, Tm, `HLVert`, Tm, `HLRbrace`(red_setcomprehension x2 x4)
		|	`HLLbrack`, Tm, `HLRbrack`		(red_fetch x2)
		|	`HLLsqbrack`, OptTms, `HLRsqbrack`		(red_listdisplay x2);

	BndVars	=	Block					(red_bndvars1 x1)
		|	Block, `HLSemi`, BndVars		(red_bndvars2 x1 x3);

	Block	=	Tm3s 					(red_block1 x1)
		|	Tm3s, `HLColon`, Ty			(red_block2 x1 x3);

	Tm3s	=	Tm3					(red_tms1 x1)
		|	Tm3, Tm3s				(red_tms2 x1 x2);

	Tms  	=	Tm					(red_tms1 x1)
		|	Tm, `HLSemi`, Tms			(red_tms2 x1 x3);

	OptTms	=						(red_empty_tms)
		|	Tms					(red_fetch x1);

	AndLet	=						(red_andlet1)
		|	`HLAnd`, Tm1, AndLet			(red_andlet2 x2 x3);

(* Types *)

	Ty	=	Ty1					(red_fetch x1)
		|	Ty, HLInOp, Ty				(red_tyinop x1 x2 x3)
		|	HLAqTy					(red_tyaq x1);

	Ty1	=	HLName					(red_tyname x1)
		|	`HLLbrack`, Ty, `HLRbrack`		(red_fetch x2)
		|	Ty1, HLName				(red_tycompound1 x1 x2)
		|	`HLLbrack`, Tys, `HLRbrack`, HLName	(red_tycompound2 x2 x4);
	Tys	=	Ty, `HLComma`, Ty			(red_tys1 x1 x3)
		|	Ty, `HLComma`, Tys			(red_tys2 x1 x3);
=TEX

=TEX
The following shell script runs the SLRP parser generator on the grammar
and puts the generated parser code in the file `imp019.grm.sml'. This file
is included in this document later on.
=SH
poly `arch`slrp.db >imp019.grm.run <<!
Slrp.slrp{infile="imp019.grm.txt", outfile="imp019.grm.sml",
		logfile="imp019.grm.log",  eos="HLEos", loglevel=2};
PolyML.quit();
!
=TEX
The resulting grammar produces 6 shift/reduce conflicts (and no reduce/reduce
conflicts) when we run it through SLRP, as follows:
óSLRP Output
State 6 on symbol HLPostOp
        Either shift to 30 or reduce by Tm = ... | Tm1
State 6 on symbol `HLComma`
        Either shift to 29 or reduce by Tm = ... | Tm1
State 6 on symbol HLInOp
        Either shift to 28 or reduce by Tm = ... | Tm1
State 48 on symbol HLInOp
        Either shift to 69 or reduce by Tm2 = Tm2, `HLColon`, Ty | ...
State 49 on symbol HLName
        Either shift to 70 or reduce by Ty = Ty1 | ...
State 81 on symbol HLInOp
        Either shift to 69 or reduce by Ty = ... | Ty, HLInOp, Ty | ...
æ.

The first three of these correspond to disambiguation rule 3
in section 2.1.1 of \cite{DS/FMU/IED/DEF001}
and are resolved by the numeric precedences for
infix, prefix and postfix operators (and comma).
The remaining conflicts are resolved using the numeric precedences
and the rule that
``a term containing a type must be parsed so that each type extends
as far to the right as possible'' (rule 2 in section 2.1.1 of \cite{DS/FMU/IED/DEF001}).
=TEX
\section{TYPE DEFINITIONS}
\subsection{Lexical Classes}
The type of tokens for the HOL parser is the following:
=TEX
The lexical classes have the following type (cf. the listing of terminals
in the grammar produced by SLRP).
=SML
datatype âHOL_LEX_CLASSá	=	âHLAqTmá
			|	âHLAqTyá
			|	âHLBinderá 
			|	âHLInOpá
			|	âHLNameá
			|	âHLStringá
			|	âHLChará
			|	âHLPostOpá
			|	âHLPreOpá
			|	âHLCommaá
			|	âHLAndá 
			|	âHLBlobá
			|	HLColon
			|	âHLElseá
			|	âHLIfá
			|	âHLIná
			|	âHLLbraceá
			|	âHLLbracká
			|	âHLLetá
			|	âHLLsqbracká
			|	âHLRbraceá
			|	âHLRbracká
			|	âHLRsqbracká
			|	âHLSemiá
			|	âHLThená
			|	âHLVertá
			|	âHLEosá;
=TEX
\subsection{Abstract Representation}
The first phase of the parser will return a value of type $TM$ defined
as follows
(in which we remember fixity and bracketing solely for the purposes of error messages).
=SML
datatype âTYá	=	âTyAtomá of string
		|	âTyCompoundá of (TY list) * string * FIXITY
		|	âTyAqá of TYPE;

datatype ('ty) âTMá	=	âBinderá of string * ('ty)TM * ('ty)TM 
		|	âLetá of (('ty)TM * ('ty)TM) list * ('ty)TM
		|	âCondá of  ('ty)TM * ('ty)TM * ('ty)TM
		|	âAppá of ('ty)TM * ('ty)TM * FIXITY
		|	âTmTypedá of ('ty)TM * 'ty
		|	âTmAqá of TERM
		|	âSetDisplayá of ('ty)TM list
		|	âSetComprehensioná of ('ty)TM * ('ty)TM
		|	âListDisplayá of ('ty)TM list
		|	âIdá of string
		|	âCharLitá of string
		|	âStringLitá of string
		|	âNumLitá of int;
=TEX
The partially parsed inputs for the parser will therefore have the following
type:
=SML
datatype âPPá	=	âTyá of TY
		|	âTysá of TY list
		|	âTmá of (TY)TM
		|	âTmsá of (TY)TM list
		|	âTmssá of (TY)TM list list
		|	âDefsá of ((TY)TM * (TY)TM) list;
=TEX
\subsection{Pretty Printing Functions}
=SML
fun âbrktá (s : string) : string = "(" ^ s ^ ")";
=TEX
=SML
fun âformat_tyá (ty : TY) : string = (
	case ty of	
		TyAtom s => s
	|	TyCompound(tys as [_, _], s, Infix _) => (
			brkt(format_list format_ty tys (" "^ s ^" "))
	) |	TyCompound(tys, s, _) => (
			brkt(format_list format_ty tys ", ") ^ s
	) |	TyAq _ => ( "<type antiquotation>"
	)
);
=TEX
=SML
fun âformat_tmá (do_ty : 'ty -> string) (tm :('ty) TM) : string = (
	case tm of
		Binder (s, v, tm) => (
			brkt(	s
			^ 	format_tm do_ty v
			^	"" ^ format_tm do_ty tm)
	) |	Let (defs, tm) => (
			brkt(	"let "
			^	format_list (format_def do_ty)defs " and "
			^	" in "
			^	format_tm do_ty tm)
	) |	Cond(tm1, tm2, tm3) => (
			brkt(	"if "
			^	format_tm do_ty tm1
			^	" then "
			^	format_tm do_ty tm2
			^	" else "
			^	format_tm do_ty tm3)
	) |	App (App(Id s, tm1, _), tm2, Infix _) => (
			brkt(format_tm do_ty tm1 ^ " " ^ s ^ " " ^ format_tm do_ty tm2)
	) |	App (Id s, tm, Prefix _)  => (
			brkt(s ^ " " ^ format_tm do_ty tm)
	) |	App (Id s, tm, Postfix _)  => (
			brkt(format_tm do_ty tm ^ " " ^ s)
	) |	App (tm1, tm2, _)  => (
			(format_tm do_ty tm1 ^ " " ^format_tm do_ty tm2)
	) |	TmTyped(tm, ty) => (
			brkt(format_tm do_ty tm ^ ":" ^ do_ty ty)
	) |	TmAq _ => ( "<term antiquotation>"
	) |	SetDisplay tms => ("{" ^ format_list(format_tm do_ty)tms "; " ^ "}"
	) |	SetComprehension (v, tm) => (
			"{" ^ format_tm do_ty v ^ "|" ^ format_tm do_ty tm ^ "}"
	) |	ListDisplay tms => ("[" ^ format_list(format_tm do_ty)tms "; " ^ "]"
	) |	Id s => (s
	) |	CharLit s =>( "`" ^ s ^ "`"
	) |	StringLit s => ("\"" ^ s ^ "\""
	) |	NumLit s => (string_of_int s
	)
) and âformat_defá (do_ty : ('ty) -> string) ((v, tm) : ('ty)TM * ('ty)TM) : string = (
	format_tm do_ty v ^ " = " ^ format_tm do_ty tm
);
=TEX
\subsection{Reduction Functions}
\subsubsection{Auxiliaries}
The reduction functions which will appear in the decorated grammar use
various auxiliaries.`

$mk\_v$ checks whether a $TM$ is a varstruct. I.e. it checks that the term is
formed from identifiers using only bracketing and comma (as an infix).
If the term is a varstruct then $mk\_v$ acts as an identify function, if not
it raises an error.
=SML
fun âmk_vá (tm : (TY)TM) :(TY) TM = (
	case tm of
		Id s => tm
	|	TmTyped (tm, ty) => TmTyped(mk_v tm, ty)
	|	App(App(Id ",", tm1, fix1), tm2, Infix p) => App(App(Id ",", mk_v tm1, fix1), mk_v tm2, Infix p)
	|	_ => parse_error 17002 (format_tm format_ty tm)
);
=TEX
$mk\_block$ handles a block of declarations.
=SML
fun âmk_blocká (tms : (TY)TM list) : (TY)TM list = (
	map mk_v tms
);
=TEX
$mk\_binder$ makes a binder given a binder name,
a list of $TM$s which are the blocks of bound variables and the body
=SML
fun âmk_binderá (n : string) (blks : (TY)TM list list)  (b : (TY)TM) : (TY)TM = (
	let	fun aux [] = b
		|   aux (v :: more) = Binder(n, v, aux more);
	in	aux (flat (map mk_block blks))
	end
);
=TEX
$mk\_def$ handles a term considered as a defining equation (in a $let$-term).
It is a little complicated. The local function $aux$ is a 
$strip\_comb$ operation for $TM$s which, however, treats an application of
the comma operator as indivisible. It is used to break apart the left hand
side of the defining equation. The result should either be a singleton list,
corresponding to a single varstruct, or a list which begins with an identifier
(possibly typed), corresponding to local definition of a function.
=SML
fun âmk_defá (tm : (TY)TM) : (TY)TM * (TY)TM = (
	let	fun aux tm = (
			case tm of
				TmTyped (tm, ty) => [TmTyped(mk_v tm, ty)]
			|	App(App(Id ",", _, _),  _, Infix _) => [mk_v tm]
			|	App(tm1,  tm2, _) => aux tm1 @ [mk_v tm2]
			|	tm => [mk_v tm]
		);
		fun mk_blocks bs = map (fn b => [b]) bs;
	in	case tm	 of
			App(App(Id "=", tm1, _), tm2, Infix _) => (
				case aux tm1 of
					[v] => (v, tm2)
				|	Id s :: more => (Id s, mk_binder"" (mk_blocks more) tm2)
				|	TmTyped(Id s, ty) :: more => (Id s, TmTyped(mk_binder"" (mk_blocks more) tm2, ty))
				|	_ => parse_error 17004 (format_tm format_ty tm)
		) |	_ => parse_error 17004 (format_tm format_ty tm)
	end
);
=TEX
\subsubsection{The Reduction Functions}
The types of the reduction functions are rather long. To avoid cluttering
the definitions, we deliberately violate standards by omitting the arguments
types from the definitions. The arguments of the functions all have type
$(HOL\_TOKEN, HOL\_LEX\_CLASS, PP)INPUT\_STACK\_ITEM$.
=SML
fun âred_binderá (Token (HTBinder s, _)) (Parsed(Tmss tmss)) (Parsed (Tm tm)) : PP = (
	Tm(mk_binder s tmss tm)
) | red_binder _ _ _ = stack_error "red_binder";
=TEX
=SML
fun âred_let2á (Parsed(Tm tm1)) (Parsed (Defs defs)) (Parsed (Tm tm2)) : PP = (
	Tm(Let(mk_def tm1 :: defs, tm2))
) | red_let2 _ _ _ = stack_error "red_let2";
=TEX
=SML
fun âred_condá (Parsed(Tm tm1)) (Parsed (Tm tm2)) (Parsed (Tm tm3)) : PP = (
	Tm(Cond(tm1, tm2, tm3))
) | red_cond _ _ _ = stack_error "red_cond";
=TEX
=SML
fun âred_tm2_binderá (Parsed (Tm f)) (Token (HTBinder s, _)) (Parsed(Tmss tmss)) (Parsed (Tm tm)) : PP = (
	Tm(App(f, (mk_binder s tmss tm), Nonfix))
) | red_tm2_binder _ _ _ _ = stack_error "red_tm2_binder";
=TEX
=SML
fun âred_tm2_let2á (Parsed (Tm f)) (Parsed(Tm tm1)) (Parsed (Defs defs)) (Parsed (Tm tm2)) : PP = (
	Tm(App(f, (Let(mk_def tm1 :: defs, tm2)), Nonfix))
) | red_tm2_let2 _ _ _ _ = stack_error "red_tm2_let2";
=TEX
=SML
fun âred_tm2_condá (Parsed (Tm f)) (Parsed(Tm tm1)) (Parsed (Tm tm2)) (Parsed (Tm tm3)) : PP = (
	Tm(App(f, (Cond(tm1, tm2, tm3)), Nonfix))
) | red_tm2_cond _ _ _ _ = stack_error "red_tm2_cond";
=TEX
=SML
fun âred_inopá (Parsed(Tm tm1)) (Token (HTInOp{name, prec, ...}, _)) (Parsed (Tm tm2)) : PP = (
	Tm(App(App(Id name, tm1, Nonfix), tm2, Infix prec))
) | red_inop _ _ _ = stack_error "red_inop";
=TEX
The symbol table functions for declaring fixity should not allow the fixity of
comma to be changed. The parser will, in fact, treat comma as infix regardless
of what the symbol table says.
=SML
fun âred_pairá (Parsed(Tm tm1)) (Parsed (Tm tm2)) : PP = (
	case get_fixity "," of
		Infix prec => Tm(App(App(Id ",", tm1, Nonfix), tm2, Infix prec))
	|	_ => Tm(App(App(Id ",", tm1, Nonfix), tm2, Infix 0))
) | red_pair _ _ = stack_error "red_pair";
=TEX
=SML
fun âred_preopá (Token (HTPreOp{name, prec, ...}, _)) (Parsed (Tm tm)) : PP = (
	Tm(App(Id name, tm, Prefix prec))
) | red_preop _ _ = stack_error "red_preop";
=TEX
=SML
fun âred_postopá (Parsed (Tm tm)) (Token (HTPostOp{name, prec, ...}, _)) : PP = (
	Tm(App(Id name, tm, Postfix prec))
) | red_postop _ _ = stack_error "red_postop";
=TEX
=SML
fun âred_typedá (Parsed (Tm tm)) (Parsed (Ty ty)) : PP = (
	Tm(TmTyped(tm, ty))
) | red_typed _ _ = stack_error "red_typed";
=TEX
=SML
fun âred_appá (Parsed (Tm tm1)) (Parsed (Tm tm2)) : PP = (
	Tm(App(tm1, tm2, Nonfix))
) | red_app _ _ = stack_error "red_app";
=TEX
=SML
fun âred_tmnameá (Token (HTName s, _)) : PP = (
	Tm((if is_all_decimal s then NumLit o nat_of_string else Id) s)
) | red_tmname _ = stack_error "red_tmname";
=TEX
=SML
fun âred_stringá (Token (HTString s, _)) : PP = (
	Tm(StringLit s)
) | red_string _ = stack_error "red_string";
=TEX
=SML
fun âred_chará (Token (HTChar s, _)) : PP = (
	Tm(CharLit s)
) | red_char _ = stack_error "red_char";
=TEX
=SML
fun âred_tmaqá (Token (HTAqTm t, _)) : PP = (
	Tm(TmAq t)
) | red_tmaq _ = stack_error "red_tmaq";
=TEX
=SML
fun âred_setdisplayá (Parsed(Tms tms)) : PP = (
	Tm(SetDisplay tms)
) | red_setdisplay _ = stack_error "red_setdisplay";
=TEX
=SML
fun red_fetch (Parsed pp) : PP = ( pp
) | red_fetch _ = stack_error "red_fetch";
=TEX
=SML
fun âred_setcomprehensioná (Parsed(Tm tm1)) (Parsed(Tm tm2)) : PP = (
	Tm(SetComprehension(mk_v tm1, tm2))
) | red_setcomprehension _ _ = stack_error "red_setcomprehension";
=TEX
=SML
fun âred_listdisplayá (Parsed(Tms tms)) : PP = (
	Tm(ListDisplay tms)
) | red_listdisplay _ = stack_error "red_listdisplay";
=TEX
=SML
fun âred_bndvars1á (Parsed (Tms tms)) : PP = (
	Tmss[tms]
) | red_bndvars1 _ = stack_error "red_bndvars1";
=TEX
=SML
fun âred_bndvars2á (Parsed (Tms tms)) (Parsed (Tmss tmss)) : PP = (
	Tmss(tms :: tmss)
) | red_bndvars2 _ _ = stack_error "red_bndvars2";
=TEX
=SML
fun âred_block1á (Parsed (Tms tms)) : PP = (
	Tms tms
) | red_block1 _ = stack_error "red_block1";
=TEX
=SML
fun âred_block2á (Parsed(Tms tms)) (Parsed(Ty ty)) : PP = (
	Tms (map(fn tm =>  TmTyped(tm, ty)) tms)
) | red_block2 _ _ = stack_error "red_block2";
=TEX
=SML
fun âred_tms1á (Parsed(Tm tm)) : PP = (
	Tms[tm]
) | red_tms1 _ = stack_error "red_tms1";
=TEX
=SML
fun âred_tms2á (Parsed(Tm tm)) (Parsed(Tms tms)) : PP = (
	Tms(tm :: tms)
) | red_tms2 _ _ = stack_error "red_tms2";
=TEX
=SML
val âred_empty_tmsá : PP = Tms[];
=TEX
=SML
val âred_andlet1á  : PP = Defs [];
=TEX
=SML
fun âred_andlet2á (Parsed(Tm tm)) (Parsed(Defs defs)) : PP = (
	Defs(mk_def tm :: defs)
) | red_andlet2 _ _ = stack_error "red_andlet2";
=TEX
=SML
fun âred_tynameá (Token (HTName s, _)) : PP = (
	Ty(TyAtom s)
) | red_tyname _ = stack_error "red_tyname";
=TEX
=SML
fun âred_tyinopá (Parsed(Ty ty1)) (Token (HTInOp{name, prec, ...}, _)) (Parsed(Ty ty2)) : PP = (
	Ty(TyCompound([ty1, ty2], name, Infix prec))
) | red_tyinop _ _ _ = stack_error "red_tyinop";
=TEX
=SML
fun âred_tyaqá (Token (HTAqTy t, _)) : PP = (
	Ty(TyAq t)
) | red_tyaq _ = stack_error "red_tyaq";
=TEX
=SML
fun âred_tycompound1á  (Parsed(Ty ty)) (Token (HTName s, _)) : PP = (
	Ty(TyCompound([ty], s, Nonfix))
) | red_tycompound1 _ _ = stack_error "red_tycompound1";
=TEX
=SML
fun âred_tycompound2á  (Parsed(Tys tys)) (Token (HTName s, _)) : PP = (
	Ty(TyCompound(tys, s, Nonfix))
) | red_tycompound2 _ _ = stack_error "red_tycompound2";
=TEX
=SML
fun âred_tys1á  (Parsed(Ty ty1)) (Parsed(Ty ty2)) : PP = (
	Tys [ty1, ty2]
) | red_tys1 _ _ = stack_error "red_tys1";
=TEX
=SML
fun âred_tys2á  (Parsed(Ty ty)) (Parsed(Tys tys)) : PP = (
	Tys (ty :: tys)
) | red_tys2 _ _ = stack_error "red_tys2";
=INCLUDE
imp019.grm.sml
=TEX
=SML
fun by_num (Value prec1 : int OPT) (prec2 : int) : RESOLUTION = (
		if prec1 <= prec2
		then DoShift
		else DoReduce
) | by_num Nil _ = DoShift;
=TEX
$top\_prec$ is used to when a conflict is to be resolved using the numerical
precedences. It finds the precedence of the operator on the stack with which
the current symbol is to be compared. It returns $Nil$ if there is no appropriate
operator on the stack.

By consideration of the grammar
and the state and conflict listings from SLRP (see section \ref{THEGRAMMAR}
above) we can see that
the relevant operator will always be the second item on the stack (and
must be an infix or prefix operator).

Maintainers should beware the fact that a reworking of the grammar may require
the algorithm of $top\_prec$ to be changed.
=SML
fun âtop_precá (stk : (HOL_TOKEN, 'lc, 'pp)INPUT_STACK) : int OPT = (
	case stk of
		_ :: Token(HTInOp{prec, ...}, _) :: _ => Value prec
	|	_ :: Token(HTPreOp{prec, ...}, _) :: _ => Value prec
	|	_ => Nil
);
=TEX
The following function implements the conflict resolution as discussed
in section \cite{THEGRAMMAR} above. Note that the case marked
with a comma occurs when a comma is encountered in an environment in
which comma is not declared as an infix --- the symbol table is
expected to prevent this --- the parser just treats it as infix in any case.
=SML
val rec âHOL_resolverá : (HOL_TOKEN, HOL_LEX_CLASS, 'pp)RESOLVER = (
fn ((tok, _), stk, red as ((nonterm, _), _)) =>
	case nonterm of
		"Tm" => (
			case tok of
				HTInOp{prec, ...} => (
					by_num (top_prec stk) prec
			) |	HTPostOp{prec, ...} => (
					by_num (top_prec stk) prec
			) |	_ => (by_num (top_prec stk) 0	 (* , *)
			)
	) |	"Tm2" => (
			case tok of
				HTInOp {name = s, prec=prec, ...} => (
						case get_type_info s of
							Value _ => DoShift
						|	Nil => DoReduce
			) |	_ => stack_error "HOL_resolver(1)"
	) |	"Ty" => (
			case tok of
				HTName s => (
					case get_type_info s of
						Value _ => DoShift
					|	Nil => DoReduce
			) |	HTInOp {name = s, prec=prec, ...} => (
						case get_type_info s of
							Value _ => by_num (top_prec stk) prec
						|	Nil => DoReduce
			) |	_ => stack_error "HOL_resolver(2)"
	) |	_ => stack_error "HOL_resolver(3)"
);
=TEX
\subsection{Lexical Classification}
Tokens are classified by the following function.
Note that if the user declares ``,'' to have fixity other than infix
then it will no longer be possible to parse the alternative for $Tys$
involving $HLComma$.
=SML
fun âHOL_classifyá  (tok : HOL_TOKEN) : HOL_LEX_CLASS = (
	case tok of
		HTAqTm _	=> HLAqTm
	|	HTAqTy _	=> HLAqTy
	|	HTBinder  _	=> HLBinder 
	|	HTInOp {name=",", ...}	=> HLComma
	|	HTInOp _	=> HLInOp
	|	HTName _	=> HLName
	|	HTString _	=> HLString
	|	HTChar _	=> HLChar
	|	HTPostOp _	=> HLPostOp
	|	HTPreOp _	=> HLPreOp
	|	HTAnd 		=> HLAnd 
	|	HTBlob		=> HLBlob
	|	HTColon		=> HLColon
	|	HTElse		=> HLElse
	|	HTIf		=> HLIf
	|	HTIn		=> HLIn
	|	HTLbrace	=> HLLbrace
	|	HTLbrack	=> HLLbrack
	|	HTLet		=> HLLet
	|	HTLsqbrack	=> HLLsqbrack
	|	HTRbrace	=> HLRbrace
	|	HTRbrack	=> HLRbrack
	|	HTRsqbrack	=> HLRsqbrack
	|	HTSemi		=> HLSemi
	|	HTThen		=> HLThen
	|	HTVert		=> HLVert
	|	HTEos		=> HLEos
);
=TEX
=SML
fun âformat_hol_tokená  (tok : HOL_TOKEN) : string = (
	case tok of
		HTAqTm _	=> "<antiquoted term>"
	|	HTAqTy _	=> "<antiquoted type>"
	|	HTBinder  name	=> name 
	|	HTInOp {name, ...}	=> name
	|	HTName name	=> name
	|	HTString s	=> "\"" ^ s ^ "\""
	|	HTChar c	=> "`" ^ c ^ "`"
	|	HTPostOp {name, ...}	=> name
	|	HTPreOp {name, ...}	=> name
	|	HTAnd 		=> "and" 
	|	HTBlob		=> ""
	|	HTColon		=> ":"
	|	HTElse		=> "else"
	|	HTIf		=> "if"
	|	HTIn		=> "in"
	|	HTLbrace	=> "{"
	|	HTLbrack	=> "("
	|	HTLet		=> "let"
	|	HTLsqbrack	=> "["
	|	HTRbrace	=> "}"
	|	HTRbrack	=> ")"
	|	HTRsqbrack	=> "]"
	|	HTSemi		=> ";"
	|	HTThen		=> "then"
	|	HTVert		=> "|"
	|	HTEos		=> "<end of quotation>"
);
=TEX
=SML
fun âHOL_readerá (ip : HOL_TOKEN list) : HOL_TOKEN * (HOL_TOKEN list) = (
	case ip of
		(h :: more) => (h, more)
	|	[] => (HTEos, [])
);
=TEX
=SML
fun âHOL_parserá (ip : HOL_TOKEN list) : (TY)TM = (
	(case (slrp'gen_parser
			HOL_resolver HOL_classify
			(default_error format_hol_token)
			HOL_reader) ip of
		Tm tm => tm
	|	_ => error "HOL parser" 17006 [])
	handle	SYNTAX_ERROR => fail "HOL parser" 17000 []
	|	PARSER_ERROR msg => error "HOL parser" 17007 [fn()=>msg]
);
=TEX
=SML
end; (* of structure Parser *)
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}
=IGN
