=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
\TPPtitle{Detailed Design for the Abstract Data Type $THM$}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/DTD006}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Approved}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
abstract data type $THM$.
This includes its
primitive and built-in inference rules,
and its theory management material.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 2.1 (16th August 1991)]
Approved version of issue 1.23.
\item [Issue 2.2 (17th September 1991)]
Approved version of issue 2.1, differing only in changed
error messages: 6017, 6026, and 6042.
\item [Issue 2.3 (8th November 1991)]
Added $icl'plus\_conv$, removed $icl'div2\_conv$ and $icl'mod2\_conv$,
following change request CR007.
\item [Issue 2.4 (12th November 1991)]
Tidying up layout.
\item [Issue 2.5 (6th December 1991)]
Approved version of issue 2.4.
\end{description}
% \subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
abstract data type $THM$.
This includes its
primitive and built-in inference rules,
and its theory management material.
This is called for in section 4 of \cite{DS/FMU/IED/HLD007}.
The high-level specification for the code is
given in \cite{DS/FMU/IED/SPC003}, \cite{DS/FMU/IED/SPC004} and \cite{DS/FMU/IED/SPC005}.
The design is
implemented in \cite{DS/FMU/IED/IMP006}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
abstract data type $THM$.
This includes its
primitive and built-in inference rules,
and its theory management material.
None of the material, other than certain types, is for other than ICL use, and thus most description boxes merely state this.
This is indicated by using the $icl'$ prefix in the names.

The functions provided in this document allow the implementation
of a theory tools interface document \cite{DS/FMU/IED/DTD012},
and a derived inference rule document \cite{DS/FMU/IED/DTD007}.
Those two documents contain only non-critical code,
and should be the only direct use made of the material given a design
in this document.
This is because a design goal for this document has been to minimise the functions provided within the
abstract data type for theorems (which is critical code), while still providing enough
to allow the implementation of a fast set of interfaces
(non-critical code).
To this end we only note the signatures of the functions, and that the functions should not be used by other than ICL,
in documentation boxes, with signatures grouped by subsection.

We wish to reserve the potential for various forms of notification to occur by side effect whenever a theory is modified.
These notification mechanisms are to be provided outside of the
abstract data type $THM$.
Thus we prefix the names all functions that modify the theory database with $icl'$,
for all that in some cases initial implementations may set the user interface
functions just to equal the ones provided in this document.
We also give an $icl'$ prefix to any function we gather
profile information about, as the profiling is better done outside the Abstract Data Type.

A ``primitive'' inference rule is considered to be part of the logic,
whereas a built-in rule is one that, though it could be coded in terms 
of the primitive rules, will actually be part of the abstract data type $THM$, and thus taken as holding true without being checked by using the primitive rules.

All functions require all their arguments before they can be evaluated,
unless otherwise noted.
This is in contrast to functions which may be ``partially evaluated'' with less than their full compliment of arguments.
For instance $icl'subst\_rule$ will check the well-formedness of its
list argument, and break apart the equational theorems within the list, even if not applied to the further two arguments
it requires to derive a theorem.
Thus it is said that we may partially evaluate $icl'subst\_rule$ with one argument.

\subsubsection{Dependencies}
Loading this document is dependent on \cite{DS/FMU/IED/IMP003}.

This document is placing requirements on the properties of the
constants it invokes.
The following constants have their definition specified in \cite{DS/FMU/IED/SPC003}:
$ƒ$, $„$, $TypeDefn$ (as $Type\_Definition$).
$=$ and $Š$ are given their properties by the primitive inference rules, rather than by definition.
$‚$ is later declared (in \cite{DS/FMU/IED/IMP023})
as an alias for boolean equality, and thus all functions that handle equality will 
properly handle terms and theorems containing $‚$.
Thus $‚$ is only used in this document when specific reference is intended to boolean equality.

The remaining constants: $Suc$, $Zero$, $Mod$, $Div$, $Cons$,
$Nil$, and $AbsChar$, are given their properties in
the declarations of theories $†$, $list$ and $char$.

\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Terminology}
The following supplements the terminology used in those documents
upon which this one depends.
\begin{tabular}{l l}
key & a string index into a dictionary \\
equational theorem & a theorem whose conclusion is an equation \\
implicative theorem & a theorem whose conclusion is an implication \\
bi-implicative theorem & a theorem whose conclusion is an bi-implication (formed by $‚$) \\
universally quantified theorem & a theorem whose conclusion is a $ƒ$-term \\
\end{tabular}
\section{CORRESPONDENCE TO THE SPECIFICATIONS}
As noted in the scope of this document, the material within it is specified within \cite{DS/FMU/IED/SPC003}, \cite{DS/FMU/IED/SPC004} and \cite{DS/FMU/IED/SPC005}.
We must ensure two things with regard to these specifications:
\begin{itemize}
\item
That all the relevant functionality in the specifications is reflected in this document.
A function is relevant if the specification intends the
function to be available to ``a user''.
For instance, the function $mk\_thm$ is used in the specification, but is clearly not intended for the user.
We can ignore auxiliary functions in the specification whose only purpose is to
simplify the declaration of further functions.
\item
That no additional facilities are made available by this document that could be derived from the relevant specified functions.
\end{itemize}
As a step towards this we provide the following tables detailing
 the relationship between specified and design functions.
The items are presented in the same order as within \cite{DS/FMU/IED/SPC005}, and then in turn the relevant parts from
\cite{DS/FMU/IED/SPC004} and \cite{DS/FMU/IED/SPC003}.
Then we give the material that is declared in this design with no corresponding item in the specifications.

\begin{tabular}{p{2.1in} | p{4.1in}} \hline
Specification & Design \\ \hline
Dictionary material & auxiliary \\
Store material & auxiliary \\
$*UD$ & $USER\_DATA$, a dictionary of datatype $USER\-\_DATUM$ \\
$*IP$ & This corresponds to a user executing the functions provided. \\
$THEORY\_CONTENTS$ & $THEORY$, a labelled record type \\
$TSNormal$, $TSLocked$, & $THEORY\-\_STATUS$ and its constructors \\
$TSAncestor$, $TSDeleted$ &  \\
$THEORY\_INFO$ & $THEORY\_INFO$, a labelled record type \\
$HIERARCHY$ & $icl'HIERARCHY$, an abstract data type \\
$PDS\_THM$ & $THM$, an abstract data type \\
$pt\_theory$ & extract contents (not address) of theory of the theorem via $icl'dest\-\_thm$ \\
$pt\_level$ & extract level of theorem via $icl'dest\-\_thm$ \\
$pt\_sequent$ & $dest\_thm$ \\
$PDS\_STATE$ & components are directly accessed with no intervening type \\
$current\_theory$ & $icl'get\-\_current\-\_theory\-\_name$ used with $icl'get\-\_theory$ \\
$current\_hierarchy$ & $icl'new\_hierarchy$ and $icl'get\-\_hierarchy$\\
$theory\_store$ & $icl'get\_theory$ \\
$hierarchy\_store$ & hierarchies assigned to Standard ML
variables \\
$theorem\_store$ & theorems assigned to Standard ML
variables \\
$initial\_theory$ & theory ``min'' before any theory functions have been used \\
$initial\_state$ & implementation initialisation of components of current state \\
$theory\_contents$ & $icl'get\_theory$ \\
$theory\_names$ & extract via $icl'get\_hierarchy$ \\
$theory\_ancestors$ & extract via $icl'get\_hierarchy$ \\
$interpret\_?$ & only formal constructs of the specification
\\
$dest\_state$ & auxiliary \\
$dest\_theory\_contents$ & type $THEORY$ is a labelled record type, and therefore its contents already may be accessed by Standard ML pattern-matching \\
$current\_theory\_contents$ & use $icl'get\-\_current\-\_theory\-\_name$ in combination with $icl'get\-\_theory$ \\
$current\_theory\_name$ & $icl'get\_current\_theory\_name$ \\
$current\_abstract\_theory$ & only a formal construct of the specification \\
$theory\_info$ & $icl'get\_theory\_info$ \\
$current\_theory\_status$ & $get\_current\_theory\_status$ \\
$check\_thm$ & $valid\_thm$ \\
$check\_thm\_address$ & auxiliary \\
\end{tabular}

\begin{tabular}{p{2.1in} | p{4.1in}} \hline
Specification & Design \\ \hline
$fetch\_thms$ & use appropriate Standard ML variable names:
no full list exists \\
$hierarchy\_ancestor$ & auxiliary - used in $icl'load\-\_hierarchy$ \\
$mk\_thm$ & auxiliary - effect is not directly available! \\
$freeze\_hierarchy$ & $icl'freeze\_hierarchy$ \\
$new\_hierarchy$ & $icl'new\_hierarchy$ \\
$load\_hierarchy$ & $icl'load\_hierarchy$ \\
$open\_theory$ & $icl'open\_theory$ \\
$empty\_theory$ & auxiliary \\
$arbitrary\_ud$ & an empty dictionary of $USER\-\_DATUM$ \\
$delete\_theory$ & $icl'delete\_theory$ \\
$new\_theory$ & $icl'new\_theory$ \\
$new\_parent$ & $icl'new\_parent$ \\
$duplicate\_theory$ & $icl'duplicate\_theory$ \\
$lock\_theory$ & $icl'lock\_theory$ \\
$unlock\_theory$ & $icl'unlock\_theory$ \\
$save\_thm$ & $icl'list\_save\_thm$ - it is more convenient to make the list version primitive \\
$is\_latest\_level$ & auxiliary \\
$delete\_extension$ & $icl'delete\_extension$ \\
$delete\_thm$ & $icl'delete\_thm$ \\
$pds\_new\_axiom$ & $icl'new\_axiom$ \\
$SUBSYS\_INPUT$ & auxiliary \\
$PDS\_INPUT$ & auxiliary \\
$DEFINER$ & auxiliary \\
$make\_definition$ & three instantiations:
$icl'new\-\_defn$, $icl'new\-\_type\-\_defn$, $icl'new\-\_specification$ \\
$pds\_new\_type$ & $icl'new\_type$ \\
$pds\_new\_constant$ & $icl'new\_const$ \\
$make\_inference$ & instantiations to those primitive inference rules
of \cite{DS/FMU/IED/SPC004} and further built-in rules \\
System Construction & this material corresponds to compiling the HOL implementation \\
$SUBST$ & $icl'subst\_rule$ \\
$ABS$ & $icl'\_eq\_rule$ \\
$INST\_TYPE$ & $icl'inst\_type\_rule$ \\
$DISCH$ & $icl'Š\_intro$ \\
$MP$ & $icl'Š\_elim$ \\
$ASSUME$ & $icl'asm\_rule$ \\
$REFL$ & $icl'refl\_conv$ \\
$BETA\_CONV$ & $icl'simple\_\beta\_conv$ \\
All other material in \cite{DS/FMU/IED/SPC003} and \cite{DS/FMU/IED/SPC004} & auxiliary to other parts of specification,
formal constructs, or not within the scope of this document \\
\end{tabular}

The following lists items that are found in the design,
but have no corresponding specification.
A summary of the reason for their inclusion is given in each case:
``built-in'' items are given justifications in their
individual sections in this document.
A set of built-in inference rules are called for by \cite{DS/FMU/IED/HLD007}: the ones below were chosen by being demonstrated helpful by experiment.

\begin{tabular}{p{2.1in} | p{4.1in}} \hline
Item & Reason \\ \hline
$SEQ$ & a type abbreviation, introduced in \cite{DS/FMU/IED/SPC001}, but this design uses a list of assumptions, instead of that document's function \\
$CONV$ & just a type abbreviation \\
$icl'suc\_conv$ & a built-in definitional schemata \\
$icl'string\_conv$ & a built-in definitional schemata \\
$icl'char\_conv$ & a built-in definitional schemata \\
$icl'eq\_sym\_rule$ & a built-in inference rule \\
$icl'list\_simple\_ƒ\_elim$ & a built-in inference rule \\
$icl'eq\_trans\_rule$ & a built-in inference rule \\
$icl'mk\_app\_rule$ & a built-in inference rule \\
$icl'‚\_mp\_rule$&  a built-in inference rule \\
$icl'simple\_ƒ\_intro$ & a built-in inference rule \\
$icl'inst\_term\_rule$ & a built-in inference rule \\
$icl'plus\_conv$ & a built-in inference rule \\
$icl'seal\_hierarchy$ & a mechanism for ensuring that certain declarations will always be in scope, as discussed in section 2.2 of \cite{DS/FMU/IED/SPC005} \\
$icl'get\_theory\_name$ & a fast method of doing what is
already possible with $icl'get\-\_hierarchy$ \\
$get\_const\_type$ & a fast route of getting something
that could be extracted by $icl'get\-\_hierarchy$ \\
$get\_type\_arity$ & a fast route of getting something
that could be extracted by $icl'get\-\_hierarchy$ \\
$thm\_fail$ & a fast route of getting something that could be extracted by $dest\-\_thm$ \\
$string\_of\_thm$ & a fast route of getting something
that could be extracted by $dest\_thm$ \\
\end{tabular}

That we implement the types of theorem, theory, etc., internally as a single
abstract datatype is our strongest reason for presuming that
we have added no additional functionality - the only functions
that can manipulate the protected values must work ``through''
the functions and values provided by the abstract datatype,
and each is justified by reference to the specification.
Some of the types, e.g. $THEORY$, are presented to the user as labelled record types or other types whose contents may be extracted by pattern-matching - this does not 
reflect the internal forms which are abstract data types.
One particular kind of value that we have to be careful with is
the addresses of assignable variables. The implementation
uses such assignable variables in a number of places and we must
ensure that none become available to the user if assignment
to the addresses could cause inconsistency.
The only addresses used within that are visible outside of the abstract data type are to user data stores, which are judged to be 
non-critical values.

\section{TYPES OF THE KERNEL}
=DOC
signature âKernelTypesá = sig
=DESCRIBE
This is the signature for the types of the kernel.
It has no associated structure: it is included into
the signatures $icl'Kernel$ and $KernelInterface$.
=ENDDOC
\subsection{The Type of Theorems}
=DOC
type âTHMá;
=DESCRIBE
This is the abstract data type of theorems in ICL HOL, whose primitive constructors are the inference rules and extensional mechanisms
of the abstract data type.
No equality test is provided upon this type.
=ENDDOC
This is not an equality type as a variety of interpretations of equality are possible for theorems.
Alternative equality tests include testing the results of $dest\_thm$ or $icl'dest\_thm$ for equality.
=DOC
eqtype âSEQá;
=DESCRIBE
This is the type of sequents, consisting of a list of assumptions and a conclusion.
óDefinition
type SEQ = (TERM list) * TERM;
æ
=ENDDOC
=DOC
type âCONVá;
=DESCRIBE
This is the type name conventionally used for conversions, that is, inference rules
whose last argument is a term, and whose result is an equation
whose LHS is precisely that term (no $\alpha$-conversion).
Though it would be type correct, we conventionally do not use this type name for other functions of type $\ldots\ ->\ TERM\ ->\ THM$.
óDefinition
type CONV = TERM -> THM;
æ
=ENDDOC
=TEX
\subsection{Types for User Data}
=DOC
datatype âUSER_DATUMá =
	âUD_Termá of TERM * (USER_DATUM list)
|	âUD_Typeá of TYPE * (USER_DATUM list)
|	âUD_Stringá of string * (USER_DATUM list)
|	âUD_Intá of int * (USER_DATUM list);
=DESCRIBE
This provides a monomorphic type of trees whose nodes are labelled by terms, types,
strings or integers.
=USES
This type is used in the type $USER\_DATA$, and may be used elsewhere, as a means of storing data that may be represented in a ``reasonably general'' structure for ICL HOL related purposes, which also is
not polymorphic.
=ENDDOC
In some implementations we will wish to save objects of this type in files,
and thus we could not have objects of a monomorphic function type as a new kind of label (though encodings of them are possible).
=DOC
type âUSER_DATAá;
=DESCRIBE
This is the type of a store for objects of type $USER\_DATUM$.
It is implemented as:
óML
type USER_DATA = (USER_DATUM ref) S_DICT;
æ
=USES
Within the type $THEORY$ it is used to include such details as the fixity of types and 
constants.
=ENDDOC
By making this a dictionary of references the structure, as well as the garbage created by modifying the structure, is lessened.
On the other hand, it does allow 
the implementer to cause modifications
without checking whether the theory is locked, deleted, etc
(though they are strongly recommended not to, but to use the interfaces of \cite{DS/FMU/IED/DTD012}).
\subsection{The Type of Theories}
=ENDDOC
=DOC
type âTHEORYá;
=DESCRIBE
A theory is a collection of type names, constants, and theorems,
plus some information about these things (such as fixity),
and a context of parent theories.

It is implemented as a labelled record type, as follows:

\begin{tabular}{|p{0.7in}|p{1.7in}|p{3.3in}|} \hline
Label & Type & Description \\ \hline
$name$ & $int$ & Internal representation of theory name. \\
$ty\_env$ & $\{arity:int,$ $level:int\}$ $S\_DICT$ & 
A dictionary indexed by type constructor names, returning arity, and definition level. \\
$con\_env$ & $\{ty:TYPE,$ $level:int\}$ $S\_DICT$ & A dictionary indexed by constant name, returning the type and definition level. \\
$parents$ & $int$ $list$ & Internal representations of names of parents of theory. \\
$del\_levels$ & $(int * int)$ $list$ &
A list of ranges of deleted definition levels - if empty then
no levels have been deleted. \\
$axiom\_$ $dict$ & $THM$ $S\_DICT$ &
A dictionary of axioms. \\
$defn\_dict$ & $THM$ $S\_DICT$ &
A dictionary of definitions. \\
$thm\_dict$ & $THM$ $S\_DICT$ &
A dictionary of theorems. \\
$current\_$ $level$ & $int$ & The current definition level. \\
$user\_data$ & $USER\_DATA$ $ref$ & The user data stored
in the theory. \\ \hline
\end{tabular}

=ENDDOC
Users will start their HOL sessions within a current theory,
which perhaps possesses some parent theories.
They may then add to the theory by operations upon its contents,
or change the current theory by an operation upon theory attributes.
The user is recommended to use the access functions provided,
rather than manipulate this ``raw'' theory type.

The user will see each theory as named by a string.
Internally however this name is represented and manipulated 
as an integer (that is an index to the internal representation of
a theory hierarchy).
This internal representation of names is visible from various functions.

Similarly, a theory will contain a current definition level,
which is incremented by 1 at each definition, axiom, etc., saved in the
theory.
Various things, in particular theorems, are created and saved with a field
set to their current definition level.
This definition level mechanism is used to allow sound deletion of 
definitions and theorems.
These declaration levels will also be integers.
\subsection{The Type of Hierarchies}
=DOC
datatype âTHEORY_STATUSá =
	âTSNormalá | âTSLockedá | âTSAncestorá | âTSDeletedá;
=DESCRIBE
Objects of this datatype indicate the status of a theory within a hierarchy, being:

\begin{tabular}{| l | p{5.0in} |} \hline
Constructor & Description \\ \hline
TSNormal & Theory is present and may be written to. \\
TSLocked & Theory is present, and cannot be written to as it is locked. \\
TSAncestor & Theory is present, and cannot be written to as it is in an ancestor for some hierarchy. \\
TSDeleted & Theory has been deleted: the theory name may be reused for a new theory. \\ \hline
\end{tabular}

=ENDDOC
It is possible that the list of statuses will be added to in
later releases, and thus this type should be used with caution.
=DOC
type âTHEORY_INFOá;
=DESCRIBE
This is a labelled record type containing certain information associated with a theory.

\begin{tabular}{|l|p{1.6in}|p{3.6in}|} \hline
Label & Type & Description \\ \hline
status & $THEORY\_STATUS$ & Current status of the theory. \\
inscope & $bool$ & True if the theory is currently in scope (i.e. can
its theorems, types and constants be usefully referred to). \\
contents & $THEORY$ & The theory contents. \\
children & $int$ $list$ & List of the immediate children of the theory. \\
name & $string$ & The name of the theory, as a string. \\ \hline
\end{tabular}

=ENDDOC
This is not the type used internally, but is modified
to allow no access to addresses of dangerous assignable variables.
However, the user is recommended to use the access functions provided,
rather than manipulate this ``raw'' $THEORY\_INFO$.
\subsection{End of Kernel Types}
=SML
end; (* KernelTypes *)
=TEX
\section{THE ABSTRACT DATA TYPE $THM$}
=DOC
signature âicl'Kernelá = sig
=DESCRIBE
This provides the abstract data type $THM$.
It includes the
primitive and built-in inference rules,
and theory management material.
=FAILURE
6083	STATE RENDERED INCONSISTENT: state is now read-only, and
	you are advised to quit ICL HOL. Do not commit the ML database.
=FAILUREC
Error 6083 occurs when an interrupt has rendered the state of ICL HOL inconsistent.
This is an implementation issue, and is fully discussed
in the implementation document for the structure
associated with this signature.
=FAILURE
6036	?0 is from deleted theory ?1 (internally theory ?2)
6065	?0 not valid as it may depend on a deleted axiom or definition of theory ?1
6066	?0 was created in the context of theory ?1 which is not in scope
6072	The theory of ?0, ?1, is not in current hierarchy
=FAILUREC
The above errors are common to most of the inference rules of this document,
and some other functions within the signature.
All are raised by $error$ not $fail$.
Thus they will be raised with exceptions that name functions in this document, as conventionally exceptions raised by $error$ are not caught or processed by the ICL implementation.
=ENDDOC
The following are various kinds of well-formedness check failures - their exceptions are caught and handled by
interface functions, and so should never be seen by the user as raised by functions from this document.
A well-formedness check occurs on any types, terms and theorems saved in a theory.
=FAILURE
6013	?0 is ill-formed in current theory: type name ?1 is not declared
6014	?0 is ill-formed in current theory: type name ?1 does not have arity used
6015	?0 is ill-formed in current theory: constant name ?1 not declared
6038	?0 is ill-formed in current theory: constant name ?1 cannot have type used
=FAILUREC
The following are conceivable design errors, which
are common to many of the functions.
They arise where the implementation gives rise to tests
some of whose results are considered ``impossible'' - such
branches give design errors (which may in fact be, for instance, implementation errors).
As they should never be seen they are not part of the user documentation.
=FAILURE
6008	DESIGN ERROR : Current theory ?0 has status TSDeleted
6032	DESIGN ERROR
6041	DESIGN ERROR : Current hierarchy corrupted
6070	DESIGN ERROR : Infinite Array Package failed
6073	DESIGN ERROR : corrupted constant scope
6074	DESIGN ERROR : corrupted type scope
=TEX
Include the types of the kernel:
=SML
include KernelTypes;
=TEX
=DOC
type âicl'HIERARCHYá;
=DESCRIBE
$icl'HIERARCHY$ is an abstract data type, which provides
communication between the functions $icl'new\_hierarchy$ and $icl'load\_hierarchy$ (q.v.).
Objects of this type should not become visible to the user.
=ENDDOC
A theory hierarchy is a collection of theories, together with
information about those theories.
In particular, it records whether theories are in scope, and whether
they may be modified.

Users will start their HOL sessions within a current theory hierarchy,
which perhaps possesses some parent hierarchies.

\subsection{Primitive Rules of Inference}
All the inference rules will check that the theorems they
are given are valid (i.e. do not belong to theories that are out
of scope, nor were they potentially derived from now deleted
definitions or axioms).
They will not check that their term arguments are well-formed, however,
as even if they are malformed, this cannot introduce logical inconsistencies.
Theorems saved in, or otherwise associated with changes in, a theory are checked for well-formedness however.

All of these inference rules will have corresponding
entries in the derived rules of inference, with names
formed by dropping the $icl'$.
These are the sole interface to the kernel's inference rules.
\subsubsection{icl'subst\_rule}
óSignature
val âicl'subst_ruleá : (THM * TERM) list -> TERM -> THM -> THM;
æ
=DESCRIBE
Substitution of equational theorems according to a template.
=RULE
icl'subst_rule
É
[ö1 … t1=t1', ... , ön … tn=tn']
ö … t[t1,...tn]
É
ö1 ¡ ... ön ¡ ö … t[t1',...tn']
=TEX
$icl'subst\_rule$ $[(thm_1, x_1),\ldots,(thm_n, x_n)]$ $template$ $thm$
returns a theorem in which $template$ determines where in $thm$ the $thm_i$ are substituted.
The $x_i$ must be variables.
The template is of the form $t[x_1,\ldots,x_n]$, and wherever the $x_i$ occur free in $template$ their associated equational theorem, $thm_i$,
is substituted into $thm$.
The rule will rename as necessary to avoid variable capture,
in the same manner as $var\_subst$ (q.v).
The assumption list of the resulting theorem is the union of all
substitution theorems, regardless of use.

The conclusion of the resulting theorem will take its bound variable names
from $template$, not $thm$, as shown in the following example.
This provides an $\alpha$-conversion facility.

The function may be usefully partially evaluated with one or two arguments.
=EXAMPLE
icl'subst_rule [(`… p = q`, »x1¼), (`… r = s`, »x2¼)] 
	(»ƒ y Ž f x1 r y + g x2 p = h y¼)
	(`… ƒ x Ž f p r x + g r p = h x`)
	=
	`… ƒ y Ž f q r y + g s p = h y`
=SEEALSO
$subst\_conv$
=FAILURE
3007	?0 is not a term variable
6001	?0 does not substitute to conclusion of theorem ?1
6002	Substitution theorem ?0 is not of the form: `ö … t1 = t2`
6029	Substitution list contains entry (?0,?1) where the type of the variable
	differs from the type of the LHS of the theorem
=TEX
($SUBST$ in Cambridge HOL)

The $(\ldots * TERM)$ argument in the specification is a $string$ $*$ $TYPE$, representing destroyed variables.
A list is used to represent the specification's (partial) function,
on the assumption that its domain is finite.
\subsubsection{icl'simple\_\_eq\_rule}
óSignature
val âicl'simple__eq_ruleá : TERM -> THM -> THM;
æ
=DESCRIBE
Given an equational theorem, return the equation formed by abstracting the term argument (which must be a variable) from both sides.
=RULE
icl'simple__eq_rule
»x¼
É
ö … t1[x] = t2[x]
É
ö … ( x Ž t1[x]) = ( x Ž t2[x])
=TEX
=SEEALSO
$abs\_conv$, $abs\_rule$
=FAILURE
3007	?0 is not a term variable
6005	?0 occurs free in assumption list
6020	?0 is not of the form: `ö … t1 = t2`
=TEX
($ABS$ in Cambridge HOL)

The $TERM$ argument in the specification is a $string$ $*$ $TYPE$, representing destroyed variables.
\subsubsection{icl'inst\_type\_rule}
óSignature
val âicl'inst_type_ruleá : (TYPE * TYPE) list -> THM -> THM;
æ
=DESCRIBE
Parallel instantiation of some of the type variables of the conclusion of a theorem.
=RULE
icl'inst_type_rule
[(þ1, tyv1), ..., (þn,tyvn)]
É
ö … t[tyv1,...tyvn]
É
ö … t[þ1,...þn]
=TEX
$icl'inst\_type\_rule$ $talist$ $thm$ will instantiate each type variable in
$talist$ with its associated type.
It will decorate free variables that would become identified with
other variables (both in conclusion and assumptions)
by their types becoming the same and the names originally being the same.
To instantiate types in the assumption list, see $asm\_inst\_type\_rule$.
=FAILURE
3019	?0 is not a type variable
6006	Trying to instantiate type variable ?0, which occurs in assumption list
=TEX
($INST\_TYPE$ in Cambridge HOL)

The $(\ldots * TYPE)$ argument in the specification is a $string$, representing the name of a type variable.
A list is used to represent the specification's (partial) function,
on the assumption that its domain is finite.
\subsubsection{icl'Š\_intro}
óSignature
val âicl'Š_introá : TERM -> THM -> THM;
æ
=DESCRIBE
Prove an implicative theorem, removing, if $\alpha$-convertibly present, the antecedent of the implication from the assumption list.
=RULE
icl'Š_intro
»t1¼
É
ö … t2
É
ö - {t1} … t1 Š t2
=TEX
=FAILURE
3031	?0 is not of type »:BOOL¼
=TEX
($DISCH$ in Cambridge HOL)
\subsubsection{icl'Š\_elim}
óSignature
val âicl'Š_elimá : THM -> THM -> THM;
æ
=DESCRIBE
Modus Ponens
=RULE
icl'Š_elim
É
ö1 … t1 Š t2; ö2 … t1'
É
ö1 ¡ ö2 … t2
=TEX
where $t1$ and $t1'$ must be $\alpha$-convertible.
=SEEALSO
$‚\_mp\_rule$(reminiscent of Modus Ponens on $‚$)
=FAILURE
6010	?0 is not of the form: `ö … t1 Š t2`
6011	?0 and ?1 are not of the forms: `ö1 … t1 Š t2` and `ö2 … t1'` where
	»t1¼ and »t1'¼ are %alpha%-convertible
=TEX
($MP$ in Cambridge HOL)

\subsubsection{icl'asm\_rule}
óSignature
val âicl'asm_ruleá : TERM -> THM;
æ
=DESCRIBE
``A term is true on the assumption that it is true''.
=RULE
icl'asm_rule
»t¼
É
É
t … t
=TEX
=FAILURE
3031	?0 is not of type »:BOOL¼
=TEX
($ASSUME$ in Cambridge HOL)
\subsubsection{icl'refl\_conv}
óSignature
val âicl'refl_convá : CONV;
æ
=DESCRIBE
The reflexivity of equality implemented as a conversion.
=RULE
icl'refl_conv
»t¼
É
É
… t = t
=TEX
($ALL\_CONV$ and $REFL$ in Cambridge HOL)
\subsubsection{icl'simple\_$\beta$\_conv}
óSignature
val âicl'simple_%beta%_convá : CONV;
æ
=DESCRIBE
Apply a $\beta$-reduction to a simple abstraction.
=CONVERSION
icl'simple_%beta%_conv
»( x Ž t1[x]) t2¼
É
É
… ( x Ž t1[x]) t2 = t1[t2]
=TEX
=SEEALSO
$\beta\_conv$
=FAILURE
6012	?0 is not of the form: »( x Ž t1[x])t2¼ where »x¼ is a variable
=TEX
($BETA\_CONV$ in Cambridge HOL)
\subsubsection{Summary}
=DOC
val icl'subst_rule : (THM * TERM) list -> TERM -> THM -> THM;
val icl'simple__eq_rule : TERM -> THM -> THM;
val icl'inst_type_rule : (TYPE * TYPE) list -> THM -> THM;
val icl'Š_intro : TERM -> THM -> THM;
val icl'Š_elim : THM -> THM -> THM;
val icl'asm_rule : TERM -> THM;
val icl'refl_conv : CONV;
val icl'simple_%beta%_conv : CONV;
=DESCRIBE
These primitive inference rules are for ICL use only.
They are used to implement the inference rules named by dropping
the $icl'$ prefix from the above names.
=ENDDOC
\subsection{Definition Schemata}
\subsubsection{icl'suc\_conv}
óSignature
val âicl'suc_convá : CONV;
æ
=DESCRIBE
This function defines the constants with names consisting only of decimal digits, and type $†$.
=RULE
icl'suc_conv
(mk_† (m+1))
É
É
… »%down%SML (mk_†(m+1))¼ = 
	Suc »%down%SML mk_† m¼
=TEX
=RULE
icl'suc_conv
(mk_† 0)
É
É
… 0 = Zero
=TEX
=FAILURE
3026	?0 is not a numeric literal
=SEEALSO
$suc\_conv$, $mk\_num$
=TEX
($num\_CONV$ in Cambridge HOL)

$suc\_conv$ will not have the clause for $0$.
\subsubsection{icl'string\_conv}
óSignature
val âicl'string_convá : CONV;
æ
=DESCRIBE
This function defines the string literal constants.
A string literal constant is indicated by the constant name starting with a double quote($"$), and being of type $CHAR\ LIST$.
Later a type abbreviation, $STRING$ will be introduced
for $CHAR\ LIST$, but it is not available in the documents
upon which this one depends.
This is equivalent to a list of character literal constants,
one for each but the first ($"$) character of the string constant's name.
This conversion defines this relationship, by returning the head and unexploded tail of the list of characters.
A character literal constant is indicated by the constant's name starting with single backquote ($`$), having a single other character, and being of type $CHAR$.
=RULE
icl'string_conv
(mk_string ("c..."))
É
É
… »%down%SML (mk_string("c..."))¼ = 
Cons »%down%SML (mk_char("c"))¼ 
	»%down%SML (mk_string("..."))¼
=TEX
Or:
=RULE
icl'string_conv
(mk_string "")
É
É
… »%down%SML (mk_string(""))¼ = Nil
=TEX
=SEEALSO
$mk\_string$
=FAILURE
3025	?0 is not a string literal
=TEX
\subsubsection{icl'char\_conv}
óSignature
val âicl'char_convá : CONV;
æ
=DESCRIBE
This function defines the character literal constants, by giving a relationship between character literal constants and their ASCII code (derived by the Standard ML function $ord$).
A character literal is indicated by the constant's name starting with single backquote ($`$), having a single other character, and being of type $CHAR$.
=RULE
icl'char_conv
(mk_char("c"))
É
É
… »%down%SML (mk_char("c"))¼ = 
	AbsChar »%down%SML ord "c"¼
=TEX
=SEEALSO
$mk\_char$
=FAILURE
3024	?0 is not a character literal
=TEX
\subsubsection{Summary}
=DOC
val icl'suc_conv : CONV;
val icl'string_conv : CONV;
val icl'char_conv : CONV;
=DESCRIBE
These definitional schemata are for ICL use only.
They are used to implement the inference rules named by dropping
the $icl'$ prefix from the above names.
=ENDDOC

\subsection{Built-In Rules of Inference}
Each of the following inference rules is justified in terms of the primitive inference rules
and definitional schemata, or derived rules declared and justified prior to the new declaration.
We will give an informal proof 
in each case, following the documentation of the rule.
This provides a partial order of introduction on the rules that follow.
We will ignore the distinction between $=$ and $‚$ in our proofs when
either could be present, and present the proof in terms of $=$.
\subsubsection{icl'eq\_sym\_rule}
óSignature
val âicl'eq_sym_ruleá : THM -> THM;
æ
=DESCRIBE
Symmetry of equality:
=RULE
icl'eq_sym_rule
É
ö … t1 = t2
É
ö … t2 = t1
=TEX
=SEEALSO
$eq\_sym\_conv$
=FAILURE
6020	?0 is not of the form: `ö … t1 = t2`
=TEX
($SYM$ in Cambridge HOL)
ó
1.	ö … t1 = t2			Hypothesis
2.	… t1 = t1			icl'eq_refl_conv
3.	ö … t2 = t1			icl'subst_rule 1,2
æ
\subsubsection{t\_thm}
We will use the theorem
ó definition
t_thm = … T
æ
in our following work.
It is proven by
óInformal Proof
1.	… T ‚ (( xŽ x) = ( xŽ x))			definition of T
2.	… ( xŽ x) = ( xŽ x)				icl'refl_conv
3.	… (( xŽ x) = ( xŽ x)) Š (( xŽ x) = ( xŽ x))	icl'Š_intro 2
4.	… (( xŽ x) = ( xŽ x)) ‚ T			icl'eq_sym_rule 1.
5.	… (( xŽ x) = ( xŽ x)) Š T			icl'subst_rule 1,4
6.	… T						icl'Š_elim 
æ
where the context must contain the theorem:
ó
t_def = … T ‚ (( xŽ x) = ( xŽ x))
æ
\subsubsection{icl'‚\_T\_elim}
We later use the following rule of inference (which is not built in):
=RULE
icl'‚_T_elim
É
ö … t ‚ T
É
ö … t
=TEX
Justified by:
óInformal Proof
1.	ö … t ‚ T					Hypothesis
2.	ö … T ‚ t					icl'eq_sym_rule 1
3.	… T						t_thm
4.	ö … t						icl'subst_rule 3,2
æ
\subsubsection{icl'list\_simple\_ƒ\_elim}
óSignature
val âicl'list_simple_ƒ_elimá : TERM list -> THM -> THM;
æ
=DESCRIBE
Instantiate a (multiply) universally quantified term to a given value.
=RULE
icl'list_simple_ƒ_elim
[...,»tn¼,...]
É
ö … ƒ ...xn ... Ž t2[...,xn,...]
É
ö … t2'[...,tn,...]
=TEX
where $t2'$ is renamed from $t2$ to prevent bound variable capture,
and the $x_i$ are variables.
The terms must have the same types as the corresponding
universally quantified variables.
The instantiation is done by simultaneous substitution (as if by $var\_subst$, q.v.), rather than by
iteration of a single instantiation.
=FAILURE
3012	?0 and ?1 do not have the same types
6018	?0 is not of the form: `ö … ƒ ...xi... Ž t` where
	the »xi¼ are ?1 variables
=TEX
($SPECL$ in Cambridge HOL)

The following is a justification for a single instantiation.
It may, with some care due to the simultaneous instantiation, be iterated to gain an appropriate finite list case.
ó
1.	… $ƒ = (P Ž P = x.T)			icl'inst_type applied to Definition
2.	ö … ƒ x Ž t2[x]					Hypothesis
3.	ö … (P Ž P = x.T)( x Ž t2[x])		icl'subst_rule 1,2
4.	… (P Ž P = x Ž T)( x Ž t2[x]) = (( x Ž t2[x]) = x.T)
							icl'simple_%beta%_conv
5.	ö … ( x Ž t2[x]) = x Ž T			icl'subst_rule 4,3
6.	… ( x Ž t2[x]) t1 ‚ ( x Ž t2[x]) t1		icl'eq_refl_conv
7.	ö … ( x Ž t2[x]) t1 ‚ (x Ž T) t1		icl'subst_rule 5,6
8.	ö … ( x Ž t2[x]) t1 ‚ t2'[t1]			icl'simple_%beta%_conv
9.	ö … t2'[t1] ‚ ( x Ž t2[x]) t1			icl'eq_sym_rule 8
10.	ö … t2'[t1] ‚ (x Ž T) t1			icl'subst_rule 9,5
11.	… (x Ž T) t1 ‚ T				icl'simple_%beta%_conv
12.	ö … t2'[t1] ‚ T				icl'subst_rule 10,11
13.	ö … t2'[t1]					icl'‚_T_elim 12
æ
Notice in step 8. where $simple\_\beta\_conv$ may introduce some renaming
(changing $t2$ to $t2'$)
to prevent bound variable capture.
\subsubsection{icl'eq\_trans\_rule}
óSignature
val âicl'eq_trans_ruleá : THM -> THM -> THM;
æ
=DESCRIBE
Transitivity of equality:
=RULE
icl'eq_trans_rule
É
ö1 … t1 = t2; ö2 … t2' = t3
É
ö1 ¡ ö2 … t3
=TEX
where »t2¼ and »t2'¼ are $\alpha$ convertible.
=FAILURE
6020	?0 is not of the form: `ö … t1 = t2`
6022	?0 and ?1 are not of the form: `ö1 … t1 = t2` and `ö2 … t2a = t3`
	where »t2¼ and »t2a¼ are %alpha%-convertible
=FAILUREC
Error 6020 is used if either the first or second theorems are
not equations. 
=TEX
($TRANS$ in Cambridge HOL)
ó
1.	ö1 … t1 = t2			Hypothesis
2.	ö2 … t2' = t3			Hypothesis
3.	ö1 ¡ ö2 … t1 = t3		icl'subst_rule 2,1
æ
\subsubsection{icl'mk\_app\_rule}
óSignature
val âicl'mk_app_ruleá : THM -> THM -> THM;
æ
=DESCRIBE
Given two equational theorems, one being between two functions, apply the two functions
to the LHS and RHS of the other equation.
=RULE
icl'mk_app_rule
É
ö1 … u1 = u2; ö2 … v1 = v2
É
ö1 ¡ ö2 … u1 v1 = u2 v2
=TEX
=FAILURE
6020	?0 is not of the form: `ö … t1 = t2`
6023	?0 and ?1 are not of the form :`ö1 … u1 = u2` and `ö2 … v1 = v2`
	where »u1¼ can be functionally applied to »v1¼
=FAILUREC
Error 6020 is used if either the first or second theorems are
not equational.
=TEX
($MK\_COMB$ in Cambridge HOL)
óInformal Proof
1.	ö1 … u1 = u2					Hypothesis
2.	ö2 … v1 = v2					Hypothesis
3.	… u1 v1 = u1 v1				icl'eq_refl_conv
4.	ö1 ¡ ö2 … u1 v1 = u2 v2			icl'subst_rule [1,2] 3
æ
\subsubsection{icl'‚\_T\_intro}
We later use the following rule of inference (which is not built in):
=RULE
icl'‚_T_intro
É
ö … t
É
ö … t ‚ T
=TEX
which is justified by:
óInformal Proof
1.	… ƒ b1 b2 Ž (b1 Š b2) Š (b2 Š b1) Š (b1 ‚ b2)	
							icl'Š_antisym_axiom
2.	… ƒ b2 Ž (t Š b2) Š (b2 Š t) Š (t ‚ b2)	
							icl'simple_ƒ_elim 1
3.	… (t Š T) Š (T Š t) Š (t ‚ T)		icl'simple_ƒ_elim 2
4.	… T						t_thm
5.	… t Š T					icl'Š_intro 4
6.	… (T Š t) Š (t ‚ T)				icl'Š_elim 3,5
7.	ö … t						Hypothesis
8.	ö … T Š t					icl'Š_intro 7
9.	ö … t ‚ T					icl'Š_elim 6,8
æ
where the context must contain the theorem:
ó
Š_antisym_axiom = 
	… ƒ b1 b2 Ž (b1 Š b2) Š (b2 Š b1) Š (b1 ‚ b2)
æ

\subsubsection{icl'‚\_mp\_rule}
óSignature
val âicl'‚_mp_ruleá : THM -> THM -> THM;
æ
=DESCRIBE
This is an inference rule reminiscent of Modus Ponens, but using a bi-implicative theorem rather than an implicative one.
=RULE
icl'‚_mp_rule
É
ö1 … t1 ‚ t2; ö2 … t1'
É
ö1 ¡ ö2 … t2
=TEX
where $t1$ and $t1'$ must be $\alpha$-convertible.
=SEEALSO
$Š\_elim$ (true Modus Ponens, on $Š$)
=FAILURE
6024	?0 and ?1 are not of the form: `ö1 … t1 ‚ t2` and `ö2 … t1'`
	where »t1¼ and »t1'¼ are %alpha%-convertible
6030	?0 is not of the form: `ö … t1 ‚ t2`
=TEX
($EQ\_MP$ in Cambridge HOL)
óInformal Proof
1.	ö1 … t1 ‚ t2					Hypothesis
2.	ö2 … t1'					Hypothesis
3.	ö2 … t1' ‚ T					icl'‚_T_intro 2
4.	ö1 ¡ ö2 … t2 ‚ T				icl'subst_rule 1,3
5.	ö1 ¡ ö2 … t2					icl'‚_T_elim 4
æ
\subsubsection{icl'simple\_ƒ\_intro}
óSignature
val âicl'simple_ƒ_introá : TERM -> THM -> THM;
æ
=DESCRIBE
Prove a simple universally quantified theorem.
=RULE
icl'simple_ƒ_intro
»x¼
É
ö … t
É
ö … ƒ x Ž t
=TEX
=SEEALSO
$ƒ\_intro$
=FAILURE
3007	?0 is not a term variable
6005	?0 occurs free in assumption list
=TEX
($GEN$ in Cambridge HOL)

In the following we use $icl'subst\_rule$ where the HOL description uses $TRANS$( Ü $icl'eq\_trans\_rule$).

First we prove $ƒx Ž T$
óInformal Proof
1.	… (x Ž T) = x Ž T				icl'eq_refl_conv
2.	… ((x Ž T) = x Ž T) ‚ T			icl'‚_T_intro 1
3.	… (P Ž P = x Ž T)(x Ž T) ‚ ((x Ž T) = x Ž T)
							icl'simple_%beta%_conv
4.	… (P Ž P = x Ž T)(x Ž T) ‚ T		icl'subst_rule 3, 2
5.	… $ƒ = (P Ž P = x Ž T)			icl'inst_type applied to Definition
6.	… (P Ž P = x Ž T) = $ƒ			icl'eq_sym_rule 5
7.	… (ƒx Ž T) ‚ T					icl'subst_rule 6, 4
8.	… (ƒx Ž T)					icl'‚_T_elim 7
æ
where the context must contain the stated definition of $ƒ$.
Then we can prove $ƒ\_intro$:
óInformal Proof
1.	ö … t						Hypothesis
2.	ö … t ‚ T					icl'‚_T_intro 1
3.	ö … (y Ž t) = y Ž T				icl'abs_rule 2
4.	… (ƒy Ž t) ‚ (ƒy Ž t)				icl'eq_refl_conv
5.	ö … (ƒy Ž t) ‚ ƒy Ž T				icl'subst_rule 3,4
6.	ö … (ƒy Ž T) ‚ ƒy Ž t				icl'eq_sym_rule 5
7.	… ƒx Ž T					icl'inst_type_rule(… ƒx Ž T)
8.	… ƒy Ž T					icl'subst_rule[] 7
9.	… ƒy Ž t						icl'subst_rule 6, 8
æ
Note that $subst\_rule\;[]\;t\;(…\,t')$ returns $…\,t$ only when
$t$ and $t'$ are $\alpha$-convertible.
\subsubsection{icl'inst\_term\_rule}
óSignature
val âicl'inst_term_ruleá : (TERM * TERM) list -> THM -> THM;
æ
=DESCRIBE
Parallel instantiation of term variables within a theorem's conclusion to some other values.
=RULE
icl'inst_term_rule
[..., (»ti¼, »xi¼), ...]
É
ö … t[x1, ..., xn]
É
ö … t[t1, ..., tn]
=TEX
=FAILURE
3007	?0 is not a term variable
6027	Types of element (?0, ?1) in term association list differ
6028	Instantiation variable ?0 free in assumption list
=TEX
($INST$ in Cambridge HOL)

A list is used to represent the specification's (partial) function,
on the assumption that its domain is finite.
óInformal Proof
1.	ö … t[x1, ..., xn]			Hypothesis
2.	ö … ƒ x1 ... xn Ž t[x1, ..., xn]		repeated icl'simple_intro on 1
3.	ö … t[t1, ..., tn]				repeated icl'simple_ƒ_elim on 2
æ
It is important to do all the generalisations before any  specialisations to gain the effect of instantiation in parallel.
Without this, if a variable to be instantiated is introduced by
a specialisation, and then generalised along with those already
present, then that variable occurrence will also be instantiated. 
\subsubsection{icl'plus\_conv}
óSignature
val âicl'plus_convá : CONV;
æ
=DESCRIBE
This conversion provides the value of the addition of two numeric literals.
=RULE
icl'plus_conv
»»%down%SML mk_† m¼ + 
 »%down%SML mk_† n¼¼
É
É
… »»%down%SML mk_† m¼ + 
	»%down%SML mk_† n¼¼ =
	»%down%SML mk_†(m + n)¼
=TEX
=USES
For doing fast arithmetic proofs.
=FAILURE
6085	?0 is not of the form: »»%down%SML mk_† m¼ + »%down%SML mk_† n¼¼
=TEX
This rule should only be used in a context that contains the definitions of $+$ and $Suc$:.
ó
ƒ m nŽ 0 + n = n € (m + 1) + n = (m + n) + 1 € Suc m = m + 1

… (ƒ nŽ Œ Suc n = Zero) €
	OneOne Suc €
	(ƒ pŽ p Zero € (ƒ mŽ p m Š p (Suc m)) Š (ƒ nŽ p n))
æ
From these we must be able to derive $plus\_assoc$
ó
… ƒ m n p Ž (m + n) + p = m + (n + p)
æ
(a simpler result than $plus\_assoc$ might well do).
From these, and the inference rules already declared we could justify any single
instance of this theorem schemata.
E.g.
óInformal Proof of ?… 2 + 2 = 4
1.	… 3 = Suc 2			icl'suc_conv
2.	… 4 = Suc 3			icl'suc_conv
3.	… Suc 3 = 3 + 1		defn +
4.	… 4 = 3 + 1			icl'eq_trans_rule 2,3
5.	… Suc 2 = 2 + 1		defn +
6.	… 3 = 2 + 1			icl'eq_trans_rule 1,6
7.	… (+) = (+)			icl'refl_conv
8.	… 1 = 1				icl'refl_conv
9.	… (+) 3 = (+) (2 + 1)		icl'mk_app_rule 6,7
10.	… 3 + 1 = (2 + 1) + 1		icl'mk_app_rule 9,8
11.	… 4 = (2 + 1) + 1		icl'eq_trans_rule 4,10
12.	… (2 + 1) + 1 = 2 + (1 + 1)	plus_assoc
13.	… 4 = 2 + (1 + 1)		icl'eq_trans_rule 11,12
14.	… 2 = Suc 1			icl'suc_conv
15.	… Suc 1 = 1 + 1		defn +
16.	… 2 = 1 + 1			icl'eq_trans_rule 14,15
17.	… (+) 2 = (+) 2		icl'refl_conv
18.	… 2 + 2 = 2 + (1 + 1)		icl'mk_app_rule 17,16
19.	… 2 + (1 + 1) = 2 + 2		icl'eq_sym_rule 18
20.	… 4 = 2 + 2			icl'eq_trans_rule 13,19
21.	… 2 + 2 = 4			icl'eq_sym_rule 20
æ
\subsubsection{Summary}
=DOC
val icl'eq_sym_rule : THM -> THM;
val icl'list_simple_ƒ_elim : TERM list -> THM -> THM;
val icl'eq_trans_rule : THM -> THM -> THM;
val icl'mk_app_rule : THM -> THM -> THM;
val icl'‚_mp_rule : THM -> THM -> THM;
val icl'simple_ƒ_intro : TERM -> THM -> THM;
val icl'inst_term_rule : (TERM * TERM) list -> THM -> THM;
val icl'plus_conv : CONV;
=DESCRIBE
These built-in inference rules are for ICL use only.
They are used to implement the functions named by dropping
the $icl'$ prefix from the above names.
=ENDDOC

\section{THEORY MANAGEMENT}
\subsection{Operations on Hierarchies}
The user will not see the effects of these
functions.
In particular, the user will find that they stay within one
hierarchy during what they see as a session.
\subsubsection{icl'freeze$\_$hierarchy}
óSignature
val âicl'freeze_hierarchyá : unit -> unit;
æ
=DESCRIBE
$icl'freeze\_hierarchy$ modifies the current hierarchy,
setting all undeleted theories in that hierarchy as an ancestor, and so read-only.
This resulting hierarchy is an ancestor hierarchy, appropriate for copying by $icl'new\_hierarchy$ (q.v.).
=TEX
\subsubsection{icl'new$\_$hierarchy}
óSignature
val âicl'new_hierarchyá : unit -> icl'HIERARCHY;
æ
=DESCRIBE
$icl'new\_hierarchy$ takes a copy of an ancestor hierarchy as produced by $icl'freeze\-\_hierarchy$(q.v.),
in which all undeleted theories in that hierarchy are marked as ancestors, and so read-only.
This new hierarchy may be later loaded by $icl'load\-\_hierarchy$ (q.v.).
=FAILURE
6090	Theory with internal number ?0 is neither an ancestor nor deleted
=TEX
\subsubsection{icl'load$\_$hierarchy}
óSignature
val âicl'load_hierarchyá : icl'HIERARCHY -> unit;
æ
=DESCRIBE
The current hierarchy is set to the stated hierarchy,
if that new hierarchy is a descendant of the current hierarchy.
A hierarchy is a descendant if it contains all the theories
in the current hierarchy, with the same name, contents and status,
though not necessarily same ``in scope'' or children.
The specification only requires the contents to be equal,
on the expectation that in such a case the rest cannot differ.
We put in further checks as an act of ``defensive programming''.
The current theory remains unchanged.
A hierarchy is formed by $icl'new\_hierarchy$ (q.v.).
=FAILURE
6033	Hierarchy is not a descendant of the current hierarchy
=TEX
\subsubsection{icl'get$\_$hierarchy}
óSignature
val âicl'get_hierarchyá : unit -> (string * THEORY_INFO) list;
æ
=DESCRIBE
Returns the current hierarchy, presented as a list of theory names and the information associated with those theory names.
=TEX
\subsubsection{icl'seal$\_$hierarchy}
óSignature
val âicl'seal_hierarchyá : unit -> unit;
æ
=DESCRIBE
This command ``seals'' the current theory.
Once sealed, no theory may successfully be opened (i.e. have $icl'open\_theory$ applied to it) that does not have the sealed theory as a parent,
or is the sealed theory itself.
By the nature of the command a subsequent $icl'seal\_hierarchy$ can only be done on
a theory that takes the sealed theory as a parent,
or is the same theory,
because the current theory can no longer not satisfy this constraint.
A theory cannot be sealed if an undeleted theory in the theory database is neither an ancestor nor descendant.

This is similar to the effect of a $icl'new\_hierarchy$,
but with more precision and more effect.
=FAILURE
6004	?0 is neither an ancestor nor descendant of current theory
=TEX
\subsubsection{icl'get$\_$theory$\_$info}
óSignature
val âicl'get_theory_infoá : string -> THEORY_INFO;
æ
=DESCRIBE
$icl'get\_theory\_info$ $theory$ returns a presentation of the information about the theory named $theory$ 
held within the current hierarchy.
The string ``-'' is understood by this function to mean the current theory.
=SEEALSO
$HIERARCHY$
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=TEX
\subsubsection{icl'get$\_$theory$\_$name}
óSignature
val âicl'get_theory_nameá : int -> string;
æ
=DESCRIBE
$icl'get\_theory\_name$ $nm$ returns the actual theory name associated with $nm$, an internal representation of a theory name.
This may return the name of a deleted theory,
which won't be recognised by those functions that
take a string represented theory names.
=FAILURE
6043	There is no theory associated with internal name ?0
6089	The theory with internal name ?0 has been deleted
=TEX
\subsubsection{Summary}
=DOC
val icl'freeze_hierarchy : unit -> unit;
val icl'new_hierarchy : unit -> icl'HIERARCHY;
val icl'load_hierarchy : icl'HIERARCHY -> unit;
val icl'get_hierarchy : unit -> (string * THEORY_INFO) list;
val icl'seal_hierarchy : unit -> unit;
val icl'get_theory_info : string -> THEORY_INFO;
val icl'get_theory_name : int -> string;
=DESCRIBE
These hierarchy theory management tools are for ICL use only.
There are no corresponding user functions.
=ENDDOC

\subsection{Operations on Theory Attributes}
In the specification, whenever a theory is modified a copy is made of the current hierarchy, that copy is modified,
and the copy is then made the current theory.
In our implementation we can sometimes shortcut this 
process, as our hierarchy is implemented as an array of addresses, so that we can modify theories ``in place'',
without taking a copy of the hierarchy.
The functionality doesn't change, merely the process achieving the effect.
\subsubsection{icl'open$\_$theory}
óSignature
val âicl'open_theoryá : string -> (int list * int list);
æ
=DESCRIBE
This makes an existing theory of the current theory hierarchy the current theory,
making only it and those theories that are its ancestors in scope.
The function returns a pair of lists that are the internal form of theory names.
The first list is those theories that have passed out of scope,
the second is those that have come into scope.
=FAILURE
6017	Theory ?0 may not be opened (it is not a descendant of ?1 which must be in scope)
6035	Theory ?0 is not present in the current hierarchy
=TEX
Error 6017 arises from attempting to open a theory that doesn't have the last theory sealed by $icl'seal\_hierarchy$ as an ancestor.

Note that the Cambridge HOL $load\_theory$ would be implemented by
using $icl'open\_theory$ and $icl'lock\_theory$.
\subsubsection{icl'delete$\_$theory}
óSignature
val âicl'delete_theoryá : string -> unit;
æ
=DESCRIBE
If the named theory is present in the current hierarchy,
is not in scope (and in particular is not the current theory),
is writable, and has no child theories, then delete it.
This means that all theorems that were proven with the deleted 
theory as the current theory will become unusable.
In addition, the theory name will be ``not present''
(error 6035)
for all purposes, including allowing it to be reused for a
new theory.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6037	Theory ?0 is locked
6071	Theory ?0 is a read-only ancestor
6076	Theory ?0 has child theories
6069	Theory ?0 is in scope
=TEX
\subsubsection{icl'new$\_$theory}
óSignature
val âicl'new_theoryá : string -> int;
æ
=DESCRIBE
This adds a new, empty, theory to the current theory hierarchy,
with the given name.
The name must not previously have been used in the current hierarchy as a theory name, unless it has since been deleted.
The empty theory has no declarations within it,
but does have the current theory as its sole parent.
The function returns the internal form of the new theory's name.
The current theory does not change, unlike the user interface function $new\_theory$ (q.v). 
=FAILURE
6040	Theory ?0 is already present in current theory hierarchy
=TEX
The specification calls for a ``user data'' parameter: we instead always use a default ``empty'' user data value.
\subsubsection{icl'new$\_$parent}
óSignature
val âicl'new_parentá : string -> int list;
æ
=DESCRIBE
Adds the given parent theory to the list of parents of the current
theory, considered as a set.
It will fail if the parent theory does not exist,
is already a parent,
or if making it a parent causes clashes in the current theory
or its children.
This will bring the parent theory and its ancestors into scope.

The function returns the theories bought into scope.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6037	Theory ?0 is locked
6071	Theory ?0 is a read-only ancestor
6067	Making ?0 a parent would cause a clash
6082	Theory ?0 is already a parent
6084	Suggested parent ?0 is a child of the current theory
=FAILUREC
Error 6035 refers to the parent,
errors 6037 and 6071 refer to the current theory.
=TEX
Error 6067 should be more informative.
\subsubsection{icl'lock$\_$theory}
óSignature
val âicl'lock_theoryá : string -> unit;
æ
=DESCRIBE
If the named theory exists, and is currently writable,
then it is made locked.
This locking may be unlocked using $icl'unlock\_theory$(q.v.).
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6037	Theory ?0 is locked
6071	Theory ?0 is a read-only ancestor
=TEX
\subsubsection{icl'unlock$\_$theory}
óSignature
val âicl'unlock_theoryá : string -> unit;
æ
=DESCRIBE
If the named theory exists and has been locked by $icl'lock\_theory$(q.v.),
then this function unlocks it.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6068	Theory ?0 has not been locked
=TEX
\subsubsection{icl'duplicate$\_$theory}
óSignature
val âicl'duplicate_theoryá : string -> string -> int;
æ
=DESCRIBE
$icl'duplicate\_theory$ $source$ $duplicate$ creates a new theory,
called $duplicate$
with identical contents and parents to $source$,
but without its children, a status of $TSNormal$, and it will not be initially in scope.
Note that unless $source$ contains no declarations, then neither
theory could be made an ancestor of the other, because of clashing
declarations.
The function returns the internal form of the new theory's name.
Note that the theorems (including axioms and definitions)
will have as their theory $source$, not the duplicate.
The sealed theory and its ancestors (see $icl'seal\_hierarchy$) may not be duplicated, as the result could 
not be opened.
Attempts to do this will give rise to errors 6026 and 6042.
Thus in particular theory ``min'' can never be duplicated, 
as it is the initial sealed theory.
=USES
To allow the user to modify and experiment with a theory that
has child theories that are not involved in the experiment,
and would perhaps clash with the experiment.
=FAILURE
6026	Theory ?0 may not be duplicated (it must always be in the scope of any opened theory)
6042	Theory ?0 may not be duplicated (the duplicate would not be a descendant of ?1)
6035	Theory ?0 is not present in the current hierarchy
6040	Theory ?0 is already present in current theory hierarchy
=TEX
\subsubsection{Summary}
=DOC
val icl'open_theory : string -> (int list * int list);
val icl'delete_theory : string -> unit;
val icl'new_theory : string -> int;
val icl'new_parent : string -> int list;
val icl'lock_theory : string -> unit;
val icl'unlock_theory : string -> unit;
val icl'duplicate_theory : string -> string -> int;
=DESCRIBE
These operations of theory attributes are for ICL use only.
They are used to implement the functions named by dropping
the $icl'$ prefix from the above names.
=ENDDOC
\subsection{Operations on Theory Contents}
\subsubsection{dest$\_$thm}
óSignature
val âdest_thmá : THM -> SEQ;
æ
=DESCRIBE
This returns the representation of a theorem as a sequent, which is a list of assumptions and a conclusion.
=SEEALSO
$icl'dest\_thm$
=TEX
This will not test whether the theorem is valid while destroying
it, as the result is ``harmless'' even if the theorem is invalid.
\subsubsection{icl'dest$\_$thm}
óSignature
val âicl'dest_thmá : THM -> {level:int, theory:THEORY, sequent :SEQ};
æ
=DESCRIBE
This returns the full representation of a theorem, in a safe, interface, form.
The level is the definition level at which the theorem was created, the theory is
that in which the theorem was created, and the sequent is the assumptions and conclusion
of the theorem.
=TEX
This will not test whether the theorem is valid while destroying
it, as the result is ``harmless'' even if the theorem is invalid.
\subsubsection{icl'list$\_$save$\_$thm}
óSignature
val âicl'list_save_thmá : (string list * THM) -> THM;
æ
=DESCRIBE
$icl'list\_save\_thm$ $(key list, thm)$ attempts to save $thm$ under the keys in $key$ $list$ 
in the current theory.
It will fail if $thm$ is not valid, the current theory is locked, there are no keys, or if any $key$ has already been used to save a theorem in
the current theory.
The function returns $thm$.
=FAILURE
6037	Theory ?0 is locked
6071	Theory ?0 is a read-only ancestor
6031	Key list may not be empty
6039	Key ?0 has already been used for a theorem in theory ?1
=FAILUREC
Error 6039 will also occur if the list of keys has duplicates.
=TEX
\subsubsection{icl'delete$\_$extension}
óSignature
val âicl'delete_extensioná : unit -> int;
æ
=DESCRIBE
$icl'delete\_extension$ $key$ will delete the last extension to the
current theory.
This will undo the effect of the last execution of any of:

\begin{tabular}{l p{4.0in}}
$icl'new\_type$ & \\
$icl'new\_const$ & \\
$icl'new\_axiom$ & \\
$icl'new\_defn$ & Deleting the definition (under all its keys), and the constant declared. \\
$icl'new\_specification$ & Deleting the specification (under all its keys), and the constants declared. \\
$icl'new\_type\_defn$ & Deleting the definition (under all its keys) and type declared. \\
\end{tabular}

Note that, amongst other effects, all theorems created in the theory since the deleted extension was created
will become unusable after the deletion.
However, $icl'delete\-\_extension$ will fail if it would cause a saved theorem to
become unusable: 
the user should first delete the theorem.

The function returns the level number deleted.
=FAILURE
6037	Theory ?0 is locked
6071	Theory ?0 is a read-only ancestor
6050	Theory ?0 contains no extensions
6076	Theory ?0 has child theories
6077	Theory ?0 has a saved theorem with key ?1 created after 
	the extension was made
=TEX
There is no point in the function returning the deleted
definition, etc, because the theorem is unusable.

It is up to the interface to this package to determine what a 
user wants to delete, check that the deletions required are indeed desired, and do sufficient $icl'delete\_extension$s
to delete the original offending declaration.
This may be done by examining the results of $icl'get\_theory$.
\subsubsection{icl'delete$\_$thm}
óSignature
val âicl'delete_thmá : string -> THM;
æ
=DESCRIBE
$icl'delete\_thm$ $key$ attempts to delete the theorem
saved in the current theory under $key$.
It will fail if the key does not refer to a theorem, or the theory
is locked.
=FAILURE
6037	Theory ?0 is locked
6071	Theory ?0 is a read-only ancestor
6046	Key ?0 is not used for a theorem in theory ?1
=TEX
\subsubsection{icl'new$\_$axiom}
óSignature
val âicl'new_axiomá : (string list * TERM) -> THM;
æ
=DESCRIBE
$icl'new\_axiom$ $(key list, term)$ attempts to save as an axiom the theorem `$… term$'
on the current theory under each of the keys provided.
It fails if the term is ill-formed (e.g. it uses an undeclared
or incorrectly typed constant),
the current theory is locked, the key list is empty, or a $key$ has already been used for
an axiom.
Adding a new axiom increments the level number of the current theory.
=FAILURE
3031	?0 is not of type »:BOOL¼
6031	Key list may not be empty
6037	Theory ?0 is locked
6047	Key ?0 has already been used for an axiom in theory ?1
6071	Theory ?0 is a read-only ancestor
=TEX
\subsubsection{icl'new$\_$const}
óSignature
val âicl'new_constá : (string * TYPE) -> TERM;
æ
=DESCRIBE
$icl'new\_const$ $(name, type)$ introduces a new constant
(with no defining theorem) called $name$, with most general type
$TYPE$, into the current theory.
The function returns the constant as a term, with the stated
most general type.
Adding a new constant increments the level number of the current theory.

The constant required cannot be one that $mk\_const$ will refuse to form, thus error messages 3002, 3003 and 3004 below.
=FAILURE
3002	Type of constant with name "=" must be of form:»ty1 ‹ ty1 ‹ BOOL¼
3003	Type of constant with name "Š" must be of form:»BOOL ‹ BOOL ‹ BOOL¼
3004	Type of constant with name ?0 must be of form:»(ty1 ‹ BOOL) ‹ BOOL¼
6037	Theory ?0 is locked
6049	There is a constant called ?0 already in scope
6063	There is a constant called ?0 in the descendants of the
	current theory
6071	Theory ?0 is a read-only ancestor
=TEX
A constant's fixity is set by a separate 
function call, rather than being bound in a user-level
$icl'new\_const$.
\subsubsection{icl'new$\_$type}
óSignature
val âicl'new_typeá : (string * int) -> TYPE;
æ
=DESCRIBE
$icl'new\_type$ $(name, arity)$ introduces a new type (constructor) 
(with no defining theorem) called $name$ with arity $arity$ into the
current theory.
The function returns the new type with sufficient arguments $'1, '2, \ldots$
to provide a well formed type.
Adding a new type increments the level number of the current theory.
=FAILURE
6034	There is a type called ?0 in the descendants of the current theory
6037	Theory ?0 is locked
6045	There is a type called ?0 already in scope
6071	Theory ?0 is a read-only ancestor
6088	The arity of a type must be Ÿ 0
=TEX
A type's fixity is set by a separate 
function call, rather than being bound in a user-level
$icl'new\_type$ function.
\subsubsection{Summary}
=DOC
val dest_thm : THM -> SEQ;
val icl'dest_thm : THM -> {level:int, theory:THEORY, sequent :SEQ};
val icl'list_save_thm : (string list * THM) -> THM;
val icl'delete_extension : unit -> int;
val icl'delete_thm : string -> THM;
val icl'new_axiom : (string list * TERM) -> THM;
val icl'new_const : (string * TYPE) -> TERM;
val icl'new_type : (string * int) -> TYPE;
=DESCRIBE
These operations on theory contents are for ICL use only.
They are used to implement the functions named by dropping
the $icl'$ prefix, except for $dest\_thm$ which is echoed
in the signature $KernelInterface$.
=ENDDOC
\subsection{Definitional Mechanisms for Theories}
\subsubsection{icl'new$\_$defn}
óSignature
val âicl'new_defná : (string list * string * TERM) -> THM;
æ
=DESCRIBE
$icl'new\_defn$ $(key\ list, name, value)$ declares a new
constant with name $name$, and with most general type being
the type of $value$ in the current theory.
It also creates a theorem of the form `$… name = value$'
(equivalent to `$…\ name\ ‚\ value$' if $value$ is boolean), and saves it as a definition
with the keys in $key\ list$, again in the current theory,
presuming that the theorem is well-formed.
If either the constant or theorem introduction fails then
the function will not change the current theory.
Adding a new definition increments the level number of the current theory.
The body of $value$ may not contain type variables that are not in the type of $value$ itself.

The constants required cannot be ones that $mk\_const$ will refuse to form, thus error messages 3002, 3003 and 3004 below.
=FAILURE
3002	Type of constant with name "=" must be of form:»ty1 ‹ ty1 ‹ BOOL¼
3003	Type of constant with name "Š" must be of form:»BOOL ‹ BOOL ‹ BOOL¼
3004	Type of constant with name ?0 must be of form:»(ty1 ‹ BOOL) ‹ BOOL¼
6031	Key list may not be empty
6037	Theory ?0 is locked
6049	There is a constant called ?0 already in scope
6051	Key ?0 has already been used for a definition in theory ?1
6058	the body of ?0 contains type variables not found in type of term itself, the variables being: ?1
6059	?0 contains the following free variables: ?1
6063	There is a constant called ?0 in the descendants of the
	current theory
6071	Theory ?0 is a read-only ancestor
=TEX
The fixity of the definition is not given at the point of definition,
but by a separate user directive, in the non-critical code.
\subsubsection{icl'new$\_$type$\_$defn}
óSignature
val âicl'new_type_defná : 
	(string list * string * string list * THM) -> THM;
æ
=DESCRIBE
$icl'new\_type\_defn$ $(key\ list, name, typars, defthm)$
declares a new type with name $name$, and arity the length of
$typars$.
It also creates a defining theorem for the type, saves it in the current theory under the keys in $key\ list$, and also returns it.
$defthm$ must be a valid well-formed theorem of the form:
ó
… „ x : type Ž p x
æ
with no assumptions.
The defining theorem will then be of the form:
ó
… „ f : typars name ‹ type Ž 
	TypeDefn (p: type ‹ BOOL) f
æ
where $TypeDefn$ asserts that its predicate argument 
$p$ is non-empty, and its function argument $f$ is a bijection
between the new type and the subset of $type$ delineated by $p$.
Adding a new type definition increments the level number of the current theory.
=FAILURE
6031	Key list may not be empty
6034	There is a type called ?0 in the descendants of the current theory
6037	Theory ?0 is locked
6045	There is a type called ?0 already in scope
6052	Key ?0 has already been used for an type definition theorem in theory ?1
6053	?0 must not have assumptions
6054	?0 is not of the form: `… „ x Ž px`
6055	?0 is not of the form: `… „ x Ž p y` where »x¼  is a variable
6056	?0 contains the free variables: ?1
6057	?0 contains type variables not found in type variable parameter list,
	type variables being: ?1
6071	Theory ?0 is a read-only ancestor
6079	?0 repeated in type parameter list
6080	?0 is not of the form: `… „ x Ž p y` where »x¼ equals »y¼
=TEX
\subsubsection{icl'new$\_$specification}
óSignature
val âicl'new_specificationá : (string list * int * THM) -> THM;
æ
=DESCRIBE
$icl'new\_specification$ $(keylist$, $ndef$, `$… „ x_1,\ldots,x_n\ Ž\ p[x_1,\ldots,x_n])$'
will introduce $ndef$ new constants named and typed from the $x_i$.
It will also save a defining theorem under each of the names in
$keylist$ in the current theory of the
form `$… p[c_1,\ldots,c_n]$' where $c_i$ is the constant with the
name and type of $x_i$.
If either the constant or theorem introduction fails then
the function will not change the current theory.
Adding a new specification increments the level number of the current theory.
The set of type variables in the types of the $x_i$ must all be equal,
and the body of $p[x_1,\ldots,x_n]$ must not contain type variables that are not in these sets.

The constants required cannot be ones that $mk\_const$ will refuse to form, thus error messages 3002, 3003 and 3004 below.
=FAILURE
3002	Type of constant with name "=" must be of form:»ty1 ‹ ty1 ‹ BOOL¼
3003	Type of constant with name "Š" must be of form:»BOOL ‹ BOOL ‹ BOOL¼
3004	Type of constant with name ?0 must be of form:»(ty1 ‹ BOOL) ‹ BOOL¼
6016	Existentially bound variable ?0 is repeated in theorem ?1
6031	Key list may not be empty
6037	Theory ?0 is locked
6044	Must define at least one constant
6049	There is a constant called ?0 already in scope
6051	Key ?0 has already been used for a definition in theory ?1
6053	?0 must not have assumptions
6056	?0 contains the free variables: ?1
6060	?0 is not of the form: `… „ x1 ... xn Ž p[x1,...,xn]`
	where the »xi¼ are variables, and n( = ?1) is the number of
	constants to be defined
6061	the body of ?0 contains type variables not found in type
	of constants to be defined, the variables being: ?1
6063	There is a constant called ?0 in the descendants of the
	current theory
6071	Theory ?0 is a read-only ancestor
6081	Sets of type variables in ?0 and ?1 differ
=TEX
$ndef$ could be allowed to be $0$, which forms an odd way of 
saving a theorem as a definition, though we do not currently allow this option.

We do not need Cambridge HOL's $flag\_name\_list$ parameter, which lists
the names of the new constants, and their lexical properties.
The names come from the existential quantifiers, the number from $ndef$, the properties
from separate user directives.
\subsubsection{Summary}
=DOC
val icl'new_defn : (string list * string * TERM) -> THM;
val icl'new_type_defn : 
	(string list * string * string list * THM) -> THM;
val icl'new_specification : (string list * int * THM) -> THM;
=DESCRIBE
These definitional mechanisms are for ICL use only.
$icl'new\_defn$ is used to implement $simple\_new\_defn$, and the others are used to implement the functions named by dropping
the $icl'$ prefix from the above names.
=ENDDOC
\subsection{Theory Access Functions}
Many of the theory access functions are found only
in the interface document, \cite{DS/FMU/IED/DTD012}.
The ones below are provided as they may be more efficiently
implemented within the abstract data type, than by
an interface function accessing the results of just
$icl'get\_theory\_hierarchy$.

\subsubsection{icl'get$\_$theory}
óSignature
val âicl'get_theoryá : string -> THEORY;
æ
=DESCRIBE
This returns the named theory in its ``raw'' state.
This cannot lead to logical inconsistencies,
e.g. by returning addresses of ``trusted'' ML variables that the user
could modify without going through the interface functions.
However, the user is recommended to use the interface functions,
rather than directly access the theory.

This function recognises ``-'' as indicating the current theory name.
=SEEALSO
$THEORY$ for the structure of the result
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=TEX
\subsubsection{icl'get$\_$current$\_$theory$\_$name}
óSignature
val âicl'get_current_theory_nameá : unit -> int;
æ
=DESCRIBE
Returns the current theory's name, in an internal form.
=TEX
\subsubsection{icl'get$\_$current$\_$theory$\_$status}
óSignature
val âget_current_theory_statusá : unit -> THEORY_STATUS;
æ
=DESCRIBE
Returns the current theory's status.
=TEX
\subsubsection{get$\_$const$\_$type}
óSignature
val âget_const_typeá : string -> TYPE OPT;
æ
=DESCRIBE
If a constant with the given name is in scope, then its type is returned, otherwise $Nil$.
=USES
This is also useful just as a rapid test for a constant being in scope.
=TEX
\subsubsection{get$\_$type$\_$arity}
óSignature
val âget_type_arityá : string -> int OPT;
æ
=DESCRIBE
If a type with the given name is in scope, then its arity is returned, otherwise $Nil$.
=USES
This is also useful just as a rapid test for a type being in scope.
=TEX
\subsubsection{valid$\_$thm}
óSignature
val âvalid_thmá : THM -> bool;
æ
=DESCRIBE
This function uses the check for the validity of theorems
that can give rise to errors 6036, 6065, 6066 and 6072,
returning false if such errors would be caused by processing
the theorem, and true otherwise.
=USES
To preempt errors caused by the primitive inference rules, et al.,
to allow the raising of more helpful error messages.
=TEX
\subsubsection{thm$\_$fail}
óSignature
val âthm_failá : string -> int -> THM list -> 'a;
æ
=DESCRIBE
$thm\_fail$ $area$ $msg$ $thml$ first creates a list of functions from $unit$ to $string$, providing displays of the list of theorems.
It then calls $fail$ with the $area$, $msg$ and this list of functions.
This allows theorems to be presented in error messages.
=TEX
\subsubsection{string$\_$of$\_$thm}
óSignature
val âstring_of_thmá : THM -> string;
æ
=DESCRIBE
This returns a display of a theorem in the form of a string,
with no inserted new lines, suitable for use with $diag\_string$ and $fail$.
=SEEALSO
$format\_thm$ is a formatted string display of a theorem.
=TEX
\subsubsection{Summary}
=DOC
val icl'get_theory : string -> THEORY;
val icl'get_current_theory_name : unit -> int;
val get_current_theory_status : unit -> THEORY_STATUS;
val get_const_type : string -> TYPE OPT;
val get_type_arity : string -> int OPT;
val valid_thm : THM -> bool;
val thm_fail : string -> int -> THM list -> 'a;
val string_of_thm : THM -> string;
=DESCRIBE
These theorem access functions are for ICL use only.
$icl'get\_theory$ and $icl'get\_current\_theory\_name$ are used to implement the functions named by dropping
the $icl'$ prefix from the above names.
The rest are made visible through the signature $KernelInterface$, are documented with that signature.
=ENDDOC
=SML
end(* signature of icl'Kernel *);
=TEX
\section{TEST POLICY}
The functions in this document should be tested according to the general criteria described in
\cite{DS/FMU/IED/PLN008}.
The partial evaluation of $icl'subst\_rule$ needs checking to ensure that it doesn't allow the encoding of a rule that doesn't check theorems in the scope it is used in.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
=IGN
Coverage of error numbers:

val estore : ({id : int, text :string } list) ref = ref [];
fun new_error_message x = (estore :=  (x :: (!estore)));

open Sort;
fun ern x = map (fn{id=id,...}=>id)(get_error_messages x);
sort (curry(op -))(ern ());
sort(fn {id=id1,text=text1} =>
	fn {id=id2,text=text2} => 
		if (id1 <> id2) 
		then id1 - id2
		else stringorder text1 text2) (!estore);
sort(fn {id=id1,text=text1} =>
	fn {id=id2,text=text2} => 
		if (text1 <> text2) 
		then stringorder text1 text2
		else id1 - id2) (!estore);



=TEX
\end{document}
