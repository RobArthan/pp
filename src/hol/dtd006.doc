=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
\TPPtitle{Detailed Design for the Abstract Data Type $THM$}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/DTD006}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
abstract data type $THM$.
This includes its
primitive and built-in inference rules,
and its theory management material.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Changes after RDA comments.
\item [Issue 1.3]
Moved statements about Cambridge HOL outside of documentation
boxes.
Noted conversions paralleling some rules.
Some minor tidying up.
Quoted theorems now quoted in $`...`$
\item [Issue 1.4,1.5]
Added theory management material.
\item [Issue 1.6]
Changes after discussions with RDA on structure of ADT $THM$.
Added $get\_type\_arity$, $icl'order\-\_of\_\-defn\_and\-\_axiom$, modified $icl'new\-\_specification$.
\item [Issue 1.7]
Changes after RDA comments on issue 1.6.
\end{description}
\subsection{Changes forecast}
There may be debate about which functions should be named $icl'\ldots$.
Some of the text outside of the documentation boxes is phrased as
questions of design or implementation, and later issues should
have these questions resolved.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
abstract data type $THM$.
This includes its
primitive and built-in inference rules,
and its theory management material.
This is called for in section 4 of \cite{DS/FMU/IED/HLD007}.
The high-level specification for the code is
given in \cite{DS/FMU/IED/SPC003}, \cite{DS/FMU/IED/SPC004} and \cite{DS/FMU/IED/SPC005}.
The design is
implemented in \cite{DS/FMU/IED/IMP006}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
abstract data type $THM$.
This includes its
primitive and built-in inference rules,
and its theory management material.
A ``primitive'' inference rule is considered to be part of the logic,
whereas a built-in rule is one that, though it could be coded in terms 
of the primitive rules, will actually be part of the abstract data type $THM$, and thus taken as holding true without checking.

The choice of functions provided in this document presumes the existence of an
interface document, that provides user-friendly ways
of carrying out all the operations desired on theorems and theories.
This is because a design goal for this document has been to minimise the functions provided within the
abstract data type for theorems, while still providing enough
to allow the implementation of a fast set of interfaces.

In addition, we wish to reserve the potential for various forms of notification to occur by side effect whenever a theory is modified.
These notification mechanisms are to be provided outside of the
abstract data type $THM$.
Thus we $icl'$ all functions that modify the ``theory store'',
for all that in some cases initial implementations may set the user interface
functions just to equal the ones provided in this document.

All functions require all their arguments to begin evaluation,
unless otherwise noted.
\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.

This document is placing requirements on the properties of the
constants it invokes.
These are: $Š$, $=$, $‚$, $Suc$, $Zero$, $Mod$, $Div$, $Cons$,
$Nil$, $AbsChar$, $ƒ$, $„$ and $TypeDefinition$.
It also requires the logic to subsume the typed lambda calculus.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}

\section{THE ABSTRACT DATA TYPE $THM$}
=DOC
signature âicl'Theoremsá = sig
=DESCRIBE
This provides the abstract data type $THM$.
This includes its
primitive and built-in inference rules,
and its theory management material.
=FAILURE
6008	DESIGN ERROR : Current theory corrupted
6041	DESIGN ERROR : Current hierarchy corrupted
6066	Theorem was created in the context of theory ?0 which is not in scope
6065	Theorem not valid as it may depend on a deleted axiom or definition
=FAILUREC
The first two of above are two conceivable design errors, which
are common to many of the functions.
The second two are errors common to most the inference rules,
and some other functions within the signature.
All the errors will be left with the source being the original 
raiser of the error,
but are collected here for conciseness.
=ENDDOC
\subsection{The Type of Theorems}
=DOC
type âTHMá;
=DESCRIBE
This is the type of theorems in ICL HOL, which can only be created by functions that maintain consistency.
No equality test is provided upon this type, as a variety of interpretations of equality are possible for theorems.
Alternative equality tests include testing the results of $dest\_thm$ or $icl'dest\_thm$ for equality.
=ENDDOC
=DOC
eqtype âSEQá;
=DESCRIBE
This is the type of sequents, the representation type of theorems.
óDefinition
type SEQ = (TERM list) * TERM;
æ
=ENDDOC
=DOC
type âCONVá;
=DESCRIBE
This is the type of conversions, that is, inference rules
whose last argument is a term, and whose result is an equation
whose LHS is precisely that term (no $\alpha$-conversion).
All conversion names will have $\_conv$ as their conventional suffix.
The type is to be used as a subset of $:TERM\ ->\ THM$.
=ENDDOC
=TEX
\subsection{Types for User Data}
=DOC
datatype âUSER_DATUMá =
	âUD_Termá of TERM * (USER_DATUM list) |
	âUD_Typeá of TYPE * (USER_DATUM list) |
	âUD_Stringá of string * (USER_DATUM list) |
	âUD_Intá of int * (USER_DATUM list);
=DESCRIBE
This provides a monomorphic type of trees whose leaves may be labelled by terms, types,
strings or integers, where the type of label may differ from leaf to leaf.
=USES
This type is used in the type $USER\_DATA$, and may be used elsewhere, as a means of storing data that may be represented in a ``reasonably general'' structure for ICL HOL related purposes, that also is
not polymorphic.
=ENDDOC
Note that we wish to be able to save objects of this type in files,
and thus we could not have objects of a monomorphic function type as a new kind of label (though encodings of them might be possible).
=DOC
type âUSER_DATAá;
=DESCRIBE
This is the type of a store for objects of type $USER\_DATUM$.
It will be implemented as:
óML
type USER_DATA = (USER_DATUM ref) S_DICT;
æ
=USES
Within the type $THEORY$ it will be used to include such details as the fixity of types and 
constants.
=ENDDOC
By making this a dictionary of references the structure, and the garbage created by modifying the structure, is kept at a minimum.
On the other hand, it does allow 
the implementor to cause modifications
without checking whether the theory is locked, deleted, etc
(though they are strongly recommended not to, but to use the interfaces).
\subsection{The Type of Theories}
The user will see each theory named by a string.
Internally however this name will be represented and manipulated 
as integers (that are indexes to the internal representation of
a theory hierarchy).
This internal representation is visible from various functions.

Similarly, a theory will contain a current definition level,
that is incremented by 1 at each definition or axiom saved in the
theory.
Various things, in particular theorems, are created and saved with a field
set to their current definition level.
This definition level mechanism is used to allow sound deletion of 
definitions and theorems.
These will also be integers.
=ENDDOC
=DOC
type âTHEORYá;
=DESCRIBE
A theory is a collection of type names, constants, and theorems,
plus some information about these things (such as fixity),
and a context of parent theories.
The user will start their HOL session within a current theory,
that perhaps possesses some parent theories.
They may then add to the theory by operations upon its contents,
or change theory by an operation upon theory attributes.
The user is recommended to use the access functions provided,
rather than manipulate a ``raw'' theory.

It is implemented as a labelled record type, as follows:

\begin{tabular}{|p{0.7in}|p{1.7in}|p{3.3in}|} \hline
Label & Type & Description \\ \hline
$name$ & $int$ & Internal representation of theory name. \\
$ty\_env$ & $\{arity:int,$ $level:int\}$ $S\_DICT$ & 
A dictionary indexed by type constructor names, returning arity, and definition level. \\
$con\_env$ & $\{ty:TYPE,$ $level:int\}$ $S\_DICT$ & A dictionary indexed by constant name, returning the type and definition level. \\
$parents$ & $int$ $list$ & Internal representations of names of parents of theory. \\
$ud\_levels$ & $(int * int)$ $list$ &
A list of ranges of undeleted definition levels - if empty then
no levels have been deleted. \\
$axiom\_$ $dict$ & $THM$ $S\_DICT$ &
A dictionary indexed by axiom keys, returning an axiom's theorem. \\
$definition\_$ $dict$ & $THM$ $S\_DICT$ &
A dictionary indexed by definition keys, returning a definition's theorem. \\
$theorem\_$ $dict$ & $THM$ $S\_DICT$ &
A dictionary indexed by theorem keys, returning a theorem. \\
$current\_$ $level$ & $int$ & The current definition level. \\
$user\_data$ & $USER\_DATA$ $ref$ & The user data stored
in the theory. \\ \hline
\end{tabular}
=ENDDOC
\subsection{The Type of Hierarchies}
=DOC
datatype âTHEORY_STATUSá =
	âTSNormalá | âTSLockedá | âTSAncestorá | âTSDeletedá;
=DESCRIBE
Objects of this datatype indicate the status of a theory within a hierarchy, being:

\begin{tabular}{| l | p{5.0in} |} \hline
Constructor & Description \\ \hline
TSNormal & Theory is present and may be written to. \\
TSLocked & Theory is present, and cannot be written to as it is locked by $icl'lock\_theory$ (q.v.). \\
TSAncestor & Theory is present, and cannot be written to as it is an in an ancestor hierarchy to the current one \\
TSDeleted & Theory has been deleted. \\ \hline
\end{tabular}

It is possible that the list of statuses will be added to in
the future, and thus this should be used with caution.
=ENDDOC
=DOC
type âTHEORY_INFOá;
=DESCRIBE
This is an interface presentation of the information about a theory
held in a hierarchy.
It provides no means to cause inconsistencies, which the internal
representation would have.
However, the user is recommended to use the access functions provided,
rather than manipulate a ``raw'' $THEORY\_INFO$.
It is a labelled record type, as follows:

\begin{tabular}{|l|p{1.6in}|p{3.6in}|} \hline
Label & Type & Description \\ \hline
status & $THEORY\_STATUS$ & Current status of the theory. \\
inscope & $bool$ & Is the theory currently in scope (i.e. can
its theorems, types and constants be usefully referred to). \\
contents & $THEORY$ & The theory contents. \\
children & $int$ $list$ & List of the immediate children of the theory. \\
name & $string$ & The name of the theory, as a string. \\ \hline
\end{tabular}
=ENDDOC
=DOC
type âicl'HIERARCHYá;
type âHIERARCHYá;
=DESCRIBE
These are the two types associated with theory hierarchies.
A theory hierarchy is a collection of theories, together with
information about those theories.
In particular, it records whether theories are in scope, and whether
they may be modified.
The user will start their HOL session within a current theory hierarchy,
that perhaps possesses some parent hierarchies.

$icl'HIERARCHY$ is an abstract data type, that provides
communication between the functions $icl'new\_hierarchy$ and $icl'load\_hierarchy$ (q.v.).

$HIERARCHY$ is an interface presentation of the information about the current theory hierarchy, a form returned by $icl'get\_hierarchy$ (q.v.).
It provides no means to cause inconsistencies, which the internal
representation would have.
The user is recommended to use the access functions provided,
rather than manipulate a ``raw'' $HIERARCHY$.
This interface type is defined as an association list of theory names
and their information:
ó
type HIERARCHY = (string * THEORY_INFO) list
æ
=ENDDOC

\subsection{Primitive Rules of Inference}
All the inference rules will check that the theorems they
are given are valid (i.e. do not belong to theories that are out
of scope, nor were they potentially derived from now deleted
definitions or axioms).
They will not check that their term arguments are well-formed, however,
as this cannot introduce logical inconsistencies.
\subsubsection{subst\_rule}
=DOC
val âsubst_ruleá : (THM * TERM) list -> TERM -> THM -> THM;
=DESCRIBE
Substitution of equality theorems according to a template.
=RULE
subst_rule
É
[ö1 … t1=t1', ... , ön … tn=tn']
ö … t[t1,...tn]
É
ö1 ¡ ... ön ¡ ö … t[t1',...tn']
=TEX
$subst\_rule$ $[(thm_1, x_1),\ldots,(thm_n, x_n)]$ $template$ $thm$
returns a theorem in which $template$ determines where in $thm$ the $thm_i$ are substituted.
The $x_i$ must be variables.
The template is of the form $t[x_1,\ldots,x_n]$, and wherever the $x_i$ are free in $template$ their associated equality theorem, $thm_i$,
is substituted into $thm$.
The rule will rename as necessary to avoid bound variable capture.
The assumption list of the resulting theorem will be the union of all
substitution theorems, regardless of use.

The conclusion of the resulting theorem will take its bound variable names
from $template$, not $thm$, as shown in the following example.
This provides an $\alpha$-conversion facility.
=EXAMPLE
subst_rule [(`… p = q`, »x1¼), (`… r = s`, »x2¼)] 
	(»ƒ y Ž f x1 r y + g x2 p = h y¼)
	(`… ƒ x Ž f p r x + g r p = h x`)
	=
	`… ƒ y Ž f q r y + g s p = h y`
=SEEALSO
$subst\_conv$
=FAILURE
6001	Template term does not substitute to conclusion of theorem
6002	A substitution theorem is not of the form: `ö … t1 = t2` or `ö … t1 ‚ t2`
6003	First argument is not of the form: `[...,(thm1,»x¼),...]` where »x¼ is a variable
6029	First argument is not of the form: `[...,(ö … t1 = t2,»?0¼),...]` 
	where the type of »?0¼ is the same as the type of »t1¼ 
=ENDDOC
($SUBST$ in Cambridge HOL)
The $(\ldots * TERM)$ argument in the specification is a $string$ $*$ $TYPE$, representing destroyed variables.
A list is used to represent the specification's (partial) function,
on the assumption that its domain is finite.

Partial evaluation with only the list of theorem-variable pairs might 
be a useful feature.
\subsubsection{abs\_rule}
=DOC
val âsimple_abs_ruleá : TERM -> THM -> THM;
=DESCRIBE
Given an equality theorem, return the equation formed by abstracting the term argument (which must be a variable) from both sides.
=RULE
simple_abs_rule
»x¼
É
ö … t1[x] = t2[x]
É
ö … ( x Ž t1[x]) = ( x Ž t2[x])
=TEX
And:
=RULE
simple_abs_rule
»x¼
É
ö … t1[x] ‚ t2[x]
É
ö … ( x Ž t1[x]) = ( x Ž t2[x])
=TEX
=SEEALSO
$abs\_conv$, $abs\_rule$
=FAILURE
6004	Term is not a variable
6005	?0 occurs free in assumption list
=ENDDOC
($ABS$ in Cambridge HOL)
The $TERM$ argument in the specification is a $string$ $*$ $TYPE$, representing destroyed variables.
\subsubsection{inst\_type\_rule}
=DOC
val âinst_type_ruleá : (TYPE * TYPE) list -> THM -> THM;
=DESCRIBE
Parallel instantiation of some of the type variables of the conclusion of a theorem.
=RULE
inst_type_rule
[(þ1, tyv1), ..., (þn,tyvn)]
É
ö … t[tyv1,...tyvn]
É
ö … t[þ1,...þn]
=TEX
$inst\_type\_rule$ $talist$ $thm$ will instantiate each type variable in
$talist$ with its associated type.
It will decorate free variables that would become identified with
other variables by their types becoming the same and the names originally being the same.
To instantiate types in the assumption list, see $asm\_inst\_type\_rule$.
=FAILURE
6006	May not instantiate type variables occurring in assumption list
6007	Type association list is not of the form: `[...,(»:tyi¼, »:tyvi¼),...]`
	where the »:tyvi¼ are all type-variables
=ENDDOC
($INST\_TYPE$ in Cambridge HOL)
The $(\ldots * TYPE)$ argument in the specification is a $string$, representing the name of a type variable.
A list is used to represent the specification's (partial) function,
on the assumption that its domain is finite.
\subsubsection{Š\_intro}
=DOC
val âŠ_introá : TERM -> THM -> THM;
=DESCRIBE
Create an implication theorem, removing, if $\alpha$-convertibly present, the hypothesis of the implication from the assumption list.
=RULE
Š_intro
»t1¼
É
ö … t2
É
ö - {t1} … t1 Š t2
=TEX
=FAILURE
6009	Term is not boolean
=ENDDOC
($DISCH$ in Cambridge HOL)
\subsubsection{Š\_elim}
=DOC
val âŠ_elimá : THM -> THM -> THM;
=DESCRIBE
Modus Ponens upon an implication.
=RULE
Š_elim
É
ö1 … t1 Š t2; ö2 … t1'
É
ö1 ¡ ö2 … t2
=TEX
where $t1$ and $t1'$ must be $\alpha$-convertible.
=SEEALSO
$‚\_mp\_rule$(Modus Ponens on $‚$)
=FAILURE
6010	First argument is not of the form: `ö … t1 Š t2`
6011	Theorems are not of the form: `ö1 … t1 Š t2` and `ö2 … t1'` where
	»t1¼ and »t1'¼ are %alpha-convertible
=ENDDOC
($MP$ in Cambridge HOL)

\subsubsection{asm\_rule}
=DOC
val âasm_ruleá : TERM -> THM;
=DESCRIBE
A term is true on the assumption that it is true.
=RULE
asm_rule
»t¼
É
É
t … t
=TEX
=FAILURE
6009	Term is not boolean
=ENDDOC
($ASSUME$ in Cambridge HOL)
\subsubsection{refl\_conv}
=DOC
val ârefl_convá : CONV;
=DESCRIBE
The reflexivity of equality considered as a conversion.
=RULE
refl_conv
»t¼
É
É
… t = t
=TEX
Or, if $t$ is boolean:
=RULE
refl_conv
»t¼
É
É
… t ‚ t
=TEX
=ENDDOC
($ALL\_CONV$ and $REFL$ in Cambridge HOL)
\subsubsection{simple\_$\beta$\_conv}
=DOC
val âsimple_%beta%_convá : TERM -> THM;
=DESCRIBE
Apply a $\beta$-reduction to a simple abstraction.
=CONVERSION
simple_%beta%_conv
»( x Ž t1[x]) t2¼
É
É
… ( x Ž t1[x]) t2 = t1[t2]
=TEX
Or, if the term is of type $BOOL$:
=CONVERSION
simple_%beta%_conv
»( x Ž t1[x]) t2¼
É
É
… ( x Ž t1[x]) t2 ‚ t1[t2]
=TEX
=SEEALSO
$\beta\_conv$
=FAILURE
6012	Term is not of the form: »( x Ž t1[x])t2¼ where »x¼ is a variable
=ENDDOC
($BETA\_CONV$ in Cambridge HOL)
\subsection{Definition Schemata}
\subsubsection{icl'suc\_conv}
=DOC
val âicl'suc_convá : TERM -> THM;
=DESCRIBE
This function defines the meaning of the constants with names consisting only of decimal digits, and type $NUM$.
=RULE
icl'suc_conv
(mk_num (m+1))
É
É
… ^(mk_num(m+1)) = Suc ^(mk_num m)
=TEX
=RULE
icl'suc_conv
(mk_num 0)
É
É
… 0 = Zero
=TEX
=FAILURE
6013	Term is not a literal numeric constant
=SEEALSO
$suc\_conv$
=ENDDOC
($num\_CONV$ in Cambridge HOL)
$suc\_conv$ will not have the clause for $0$.
\subsubsection{string\_conv}
=DOC
val âstring_convá : TERM -> THM;
=SYNOPSIS
This function defines the meaning of the constants with name starting with $"$, and type $STRING$.
=DESCRIBE
A literal string constant is indicated by the constant's name starting with $"$, as well as being of type $STRING$.
This is equivalent to a list of literal character constants,
one for each but the first ($"$) character of the string constant's name.
This conversion defines this relationship, by returning the head and unexploded tail of the list of characters.
=RULE
string_conv
(mk_string ("c" :: t))
É
É
… ^(mk_string("c" :: t)) = 
Cons ^(mk_char("c")) ^(mk_string(t))
=TEX
Or:
=RULE
string_conv
(mk_string "")
É
É
… ^(mk_string("")) = Nil
=TEX
=FAILURE
6014	Term is not a literal string constant
=ENDDOC
\subsubsection{char\_conv}
=DOC
val âchar_convá : TERM -> THM;
=DESCRIBE
This function gives a relationship between literal character constants and their ASCII code (derived by the Standard ML function $ord$):
=RULE
char_conv
(mk_char("c"))
É
É
… ^(mk_char("c")) = AbsChar ^(ord "c")
=TEX
=FAILURE
6015	Term is not a literal character constant
=ENDDOC

\subsection{Built-In Rules of Inference}
Each of the following inference rules may be justified in terms of the primitive inference rules
and definitional schemata, or derived rules proven prior to the new declaration.
We will give an informal proof 
in each case, following the documentation of the rule.
This provides a partial order of introduction on the rules that follow.
We will ignore the distinction between $=$ and $‚$ in our proofs when
either could be present, and present the proof in terms of $=$.
\subsubsection{eq\_sym\_rule}
=DOC
val âeq_sym_ruleá : THM -> THM;
=DESCRIBE
Symmetry of equality and $‚$
=RULE
eq_sym_rule
É
ö … t1 = t2
É
ö … t2 = t1
=TEX
And:
=RULE
eq_sym_rule
É
ö … t1 ‚ t2
É
ö … t2 ‚ t1
=TEX
=SEEALSO
$eq\_sym\_conv$
=FAILURE
6025	Theorem is not of the form: `ö … t1 = t2` or `ö … t1 ‚ t2`
=ENDDOC
($SYM$ in Cambridge HOL)
ó
1.	ö … t1 = t2			Hypothesis
2.	… t1 = t1			eq_refl_rule
3.	ö … t2 = t1			subst_rule 1,2
æ
\subsubsection{‚\_T\_elim}
We wish for the following rule of inference (that is not built in):
=RULE
‚_T_elim
É
ö … t ‚ T
É
ö … t
=TEX
Justified by:
óInformal Proof
1.	ö … t ‚ T					Hypothesis
2.	ö … T ‚ t					eq_sym_rule 1
3.	… T						t_thm
4.	ö … t						subst_rule 3,2
æ
\subsubsection{simple\_ƒ\_elim}
=DOC
val âsimple_ƒ_elimá : TERM -> THM -> THM;
=DESCRIBE
Instantiate a universally quantified variable to a given value.
=RULE
simple_ƒ_elim
»t1¼
É
ö … ƒ x Ž t2[x]
É
ö … t2'[t1]
=TEX
where $t2'$ is renamed from $t2$ to prevent bound variable capture,
and $x$ is a variable.
=FAILURE
6018	Theorem is not of the form: `ö … ƒ x Ž t` where »x¼ is a variable
6019	Theorem is not of the form: `ö … ƒ ?0 Ž t` where the type of »?0¼ 
	is the type of the term argument
=ENDDOC
($SPEC$ in Cambridge HOL)
ó
1.	… $ƒ = (P Ž P = x.T)			inst_type applied to Definition
2.	ö … ƒ x Ž t2[x]					Hypothesis
3.	ö … (P Ž P = x.T)( x Ž t2[x])		subst_rule 1,2
4.	… (P Ž P = x Ž T)( x Ž t2[x]) = (( x Ž t2[x]) = x.T)
							simple_%beta%_conv
5.	ö … ( x Ž t2[x]) = x Ž T			subst_rule 4,3
6.	… ( x Ž t2[x]) t1 ‚ ( x Ž t2[x]) t1		eq_refl_rule
7.	ö … ( x Ž t2[x]) t1 ‚ (x Ž T) t1		subst_rule 5,6
8.	ö … ( x Ž t2[x]) t1 ‚ t2'[t1]			simple_%beta%_conv
9.	ö … t2'[t1] ‚ ( x Ž t2[x]) t1			eq_sym_rule 8
10.	ö … t2'[t1] ‚ (x Ž T) t1			subst_rule 9,5
11.	… (x Ž T) t1 ‚ T				simple_%beta%_conv
12.	ö … t2'[t1] ‚ T				subst_rule 10,11
13.	ö … t2'[t1]					‚_T_elim 12
æ
Notice in step 8. where $simple_\beta\_conv$ may introduce some renaming
(changing $t2$ to $t2'$)
to prevent bound variable capture.
\subsubsection{eq\_trans\_rule}
=DOC
val âeq_trans_ruleá : THM -> THM -> THM;
=DESCRIBE
Transitivity of equality and $‚$:
=RULE
eq_trans_rule
É
ö1 … t1 = t2; ö2 … t2' = t3
É
ö1 ¡ ö2 … t3
=TEX
And:
=RULE
eq_trans_rule
É
ö1 … t1 ‚ t2; ö2 … t2' ‚ t3
É
ö1 ¡ ö2 … t1 ‚ t3
=TEX
where »t2¼ and »t2'¼ are $\alpha$ convertible.
=FAILURE
6020	First theorem is not of the form: `ö … t1 = t2` or `ö … t1 ‚ t2`
6021	Second theorem is not of the form: `ö … t1 = t2` or `ö … t1 ‚ t2`
6022	Theorems are not of the form: `ö1 … t1 = t2` and `ö2 … t2' = t3`
	where »t2¼ and »t2'¼ are %alpha-convertible
=ENDDOC
($TRANS$ in Cambridge HOL)
ó
1.	ö1 … t1 = t2			Hypothesis
2.	ö2 … t2' = t3			Hypothesis
3.	ö1 ¡ ö2 … t1 = t3		subst_rule 2,1
æ
\subsubsection{mk\_comb\_rule}
=DOC
val âmk_comb_ruleá : THM -> THM -> THM;
=DESCRIBE
Given two equations, one being of two functions, apply the two functions
to the LHS and RHS of the other equation.
=RULE
mk_comb_rule
É
ö1 … u1 = u2; ö2 … v1 = v2
É
ö1 ¡ ö2 … u1 v1 = u2 v2
=TEX
The second input theorem or the result may be expressed using $‚$.
=FAILURE
6020	First theorem is not of the form: `ö … t1 = t2` or `ö … t1 ‚ t2`
6021	Second theorem is not of the form: `ö … t1 = t2` or `ö … t1 ‚ t2`
6023	Theorems are not of the form `ö1 … u1 = u2` and `ö2 … v1 = v2`
	where »u1¼ can be functionally applied to »v1¼
=ENDDOC
($MK\_COMB$ in Cambridge HOL)
óInformal Proof
1.	ö1 … u1 = u2					Hypothesis
2.	ö2 … v1 = v2					Hypothesis
3.	… u1 v1 = u1 v1				eq_refl_rule
4.	ö1 ¡ ö2 … u1 v1 = u2 v2			subst_rule [1,2] 3
æ
\subsubsection{‚\_T\_intro}
We wish for the following rule of inference (that is not built in):
=RULE
‚_T_intro
É
ö … t
É
ö … t ‚ T
=TEX
which is justified by:
óInformal Proof
1.	… ƒ b1 b2 Ž (b1 Š b2) Š (b2 Š b1) Š (b1 ‚ b2)	
							Š_antisym_axiom
2.	… ƒ b2 Ž (t Š b2) Š (b2 Š t) Š (t ‚ b2)	
							simple_ƒ_elim 1
3.	… (t Š T) Š (T Š t) Š (t ‚ T)		simple_ƒ_elim 2
4.	… T						t_thm
5.	… t Š T					Š_intro 4
6.	… (T Š t) Š (t ‚ T)				Š_elim 3,5
7.	ö … t						Hypothesis
8.	ö … T Š t					Š_intro 7
9.	ö … t ‚ T					Š_elim 6,8
æ
where the context must contain the theorems:
ó
Š_antisym_axiom = 
	… ƒ b1 b2 Ž (b1 Š b2) Š (b2 Š b1) Š (b1 ‚ b2)

t_thm = 
	… T
æ

\subsubsection{‚\_mp\_rule}
=DOC
val â‚_mp_ruleá : THM -> THM -> THM;
=DESCRIBE
Modus Ponens on $‚$.
=RULE
‚_mp_rule
É
ö1 … t1 ‚ t2; ö2 … t1'
É
ö1 ¡ ö2 … t2
=TEX
where $t1$ and $t1'$ must be $\alpha$-convertible.
=SEEALSO
$Š\_elim$ (Modus Ponens on $Š$)
=FAILURE
6030	First theorem is not of the form: `ö … t1 ‚ t2`
6024	Theorems are not of the form: `ö1 … t1 ‚ t2` and `ö2 … t1'`
	where »t1¼ and »t1'¼ are %alpha-convertible
=ENDDOC
($EQ\_MP$ in Cambridge HOL)
óInformal Proof
1.	ö1 … t1 ‚ t2					Hypothesis
2.	ö2 … t1'					Hypothesis
3.	ö2 … t1' ‚ T					‚_T_intro 2
4.	ö1 ¡ ö2 … t2 ‚ T				subst_rule 1,3
5.	ö1 ¡ ö2 … t2					‚_T_elim 4
æ
\subsubsection{simple\_ƒ\_intro}
=DOC
val âsimple_ƒ_introá : TERM -> THM -> THM;
=DESCRIBE
Introduce a simple universal quantification.
=RULE
simple_ƒ_intro
»x¼
É
ö … t
É
ö … ƒ x Ž t
=TEX
=SEEALSO
$ƒ\_intro$
=FAILURE
6004	Term is not a variable
6005	?0 occurs free in assumption list
=ENDDOC
($GEN$ in Cambridge HOL)
In the following we use $subst\_rule$ where the HOL description uses $TRANS$( Ü $eq\_trans\_rule$).

First we prove $ƒx Ž T$
óInformal Proof
1.	… (x Ž T) = x Ž T				eq_refl_rule
2.	… ((x Ž T) = x Ž T) ‚ T			‚_T_intro 1
3.	… (P Ž P = x Ž T)(x Ž T) ‚ ((x Ž T) = x Ž T)
							simple_%beta%_conv
4.	… (P Ž P = x Ž T)(x Ž T) ‚ T		subst_rule 3, 2
5.	… $ƒ = (P Ž P = x Ž T)			inst_type applied to Definition
6.	… (P Ž P = x Ž T) = $ƒ			eq_sym_rule 5
7.	… (ƒx Ž T) ‚ T					subst_rule 6, 4
8.	… (ƒx Ž T)					‚_T_elim 7
æ
where the context must contain the stated definition of $ƒ$.
Then we can prove $ƒ\_intro$:
óInformal Proof
1.	ö … t						Hypothesis
2.	ö … t ‚ T					‚_T_intro 1
3.	ö … (y Ž t) = y Ž T				abs_rule 2
4.	… (ƒy Ž t) ‚ (ƒy Ž t)				eq_refl_rule
5.	ö … (ƒy Ž t) ‚ ƒy Ž T				subst_rule 3,4
6.	ö … (ƒy Ž T) ‚ ƒy Ž t				eq_sym_rule 5
7.	… ƒx Ž T					inst_type_rule(… ƒx Ž T)
8.	… ƒy Ž T					subst_rule[] 7
9.	… ƒy Ž t						subst_rule 6, 8
æ
Note that $subst\_rule\;[]\;t\;(…\,t')$ returns $…\,t$ only when
$t$ and $t'$ are $\alpha$-convertible.
\subsubsection{inst\_term\_rule}
=DOC
val âinst_term_ruleá : (TERM * TERM) list -> THM -> THM;
=DESCRIBE
Parallel instantiation of term variables within a theorem's conclusion to some other values.
=RULE
inst_term_rule
[..., (»ti¼, »xi¼), ...]
É
ö … t[x1, ..., xn]
É
ö … t[t1, ..., tn]
=TEX
=FAILURE
6026	Term association list is not of the form: `[..., (»t¼, »x¼), ...]`
	where »x¼ is a variable
6027	Types of element (»t¼, »?0¼) in term association list differ
6028	Instantiation variable ?0 free in assumption list
=ENDDOC
($INST$ in Cambridge HOL)
Perhaps this should be called $inst\_rule$.
A list is used to represent the specification's (partial) function,
on the assumption that its domain is finite.
óInformal Proof
1.	ö … t[x1, ..., xn]			Hypothesis
2.	ö … ƒ x1 ... xn Ž t[x1, ..., xn]		repeated simple_intro on 1
3.	ö … t[t1, ..., tn]				repeated simple_ƒ_elim on 2
æ
It is important to do all the generalisations before any  specialisations to gain the instantiation in parallel effect.
Without this, if a variable to be instantiated is introduced by
a specialisation, and then generalised along with those already
present, then that variable occurrence will also be instantiated. 
\subsubsection{div2\_conv}
=DOC
val âdiv2_convá : TERM -> THM;
=DESCRIBE
Provides the value of $Div\ 2$ of a natural number.
=RULE
div2_conv
(mk_num n)
É
É
… ^(mk_num n) Div 2 = ^(mk_num(n div 2))
=TEX
=USES
For doing fast arithmetic proofs.
=FAILURE
6013	Term is not a literal numeric constant
=ENDDOC
This rule should only be used in a context that contains definitions of $Div$ and $Mod$ from which we can prove:
ó
(ƒnŽ n > 0 Š 0 Mod n = 0)
€
(ƒm nŽ n > 0 Š (Suc m) Mod n = if Suc(m Mod n) < n 
	then Suc(m Mod n) 
	else  0)
æ
ó
… (ƒ n Ž n > 0 Š 0 Div n = 0)
€
(ƒm nŽn > 0 Š 
 (Suc m) Div n = if Suc(m Mod n) < n 
	then m Div n 
	else Suc(m Div n))
æ
as well as appropriate definitions of $+$ and $*$.
From these we would derive (after some effort) the theorems:
ó
A.	… 0 Div 2 = 0
B.	… 1 Div 2 = 0
C.	… ƒ n Ž (Suc(Suc n)) Div 2 = Suc(n Div 2)
æ
From these, $icl'suc\_conv$, and $eq\_refl\_rule$ we could justify any single
instance of this theorem schemata.
E.g.
óInformal Proof of ?… 5 Div 2 = 2
1.	… Suc(Suc 0) = 2			eq_sym_rule(repeated icl'suc_conv)
2.	… 0 = 1 Div 2				eq_sym_rule (B)
3.	… Suc(Suc (1 Div 2)) = 2		subst_rule 1,2
4.	… Suc (1 Div 2) = (Suc(Suc 1)) Div 2 
						eq_sym_rule(simple_elim on (C))
5.	… Suc((Suc(Suc 1)) Div 2) = 2		subst_rule 3,4
6.	… Suc ((Suc(Suc 1)) Div 2) = (Suc(Suc (Suc(Suc 1)))) Div 2
						eq_sym_rule(simple_elim on (C))
7.	… (Suc(Suc (Suc(Suc 1)))) Div 2 = 2
						subst_rule 5,6
8.	… (Suc(Suc (Suc(Suc 1)))) = 5		repeated icl'suc_conv
9.	… 5 Div 2 = 2				subst_rule 7, 8
æ
\subsubsection{mod2\_conv}
=DOC
val âmod2_convá : TERM -> THM;
=DESCRIBE
Provides the value of $Mod\ 2$ of a natural number.
=RULE
mod2_conv
(mk_num n)
É
É
… ^(mk_num n) Mod 2 = ^(mk_num(n mod 2))
=TEX
=USES
For doing fast arithmetic proofs.
=FAILURE
6013	Term is not a literal numeric constant
=ENDDOC
This is only justified in the context of a theory containing
the above definitions of $Div$ and $Mod$
and ``proper'' definitions of $+$ and $*$.
From these we would derive (after some effort) the theorems:
ó
A.	… 0 Mod 2 = 0
B.	… 1 Mod 2 = 1
C.	… ƒ n Ž (Suc(Suc n)) Mod 2 = (n Mod 2)
æ
From these, $icl'suc\_conv$, and $eq\_refl\_rule$ we could justify any single
instance of this theorem schemata.
E.g.
óInformal Proof of ?… 5 Mod 2 = 1
1.	… 1 Mod 2 = 1					(B)
2.	… (Suc(Suc 1)) Mod 2 = (1 Mod 2)		simple_ƒ_elim on (C)
3.	… (Suc(Suc 1)) Mod 2 = 1			subst_rule 1,2
4.	… (Suc(Suc (Suc(Suc 1)))) Mod 2 = ((Suc(Suc 1)) Mod 2)
							simple_ƒ_elim on (C)
5.	… (Suc(Suc (Suc(Suc 1)))) Mod 2 = 1		eq_trans_rule 3,4
6.	… (Suc(Suc (Suc(Suc 1)))) = 5			repeated use of subst_rule
							and icl'suc_conv
7.	… 5 Mod 2 = 1
æ


\subsection{Theory Management}
This material specified in \cite{DS/FMU/IED/SPC005}.
Various items of that specification will be ML $ref$ variables,
that will not be directly accessible to the user, and do not appear
in the documentation below,
or are not given a design for other reasons.
We list such items now:
\begin{description}
\item[items of type $PDS\_STATE$]
These are modelled by hidden ML $ref$ variables, and are described
under their labels in the following list.
The interfaces to these are such that they cannot compromise the soundness of the system.
\item[$icl'current\_theory$ and $current\_theory\_contents$]\ 

Interface: $get\_current\_theory\_name$, mixed with $icl'get\_theory$.
Modelled by the hidden ref variable $icl'current\-\_theory$
\item[$icl'current\_hierarchy$]
Interface: $icl'get\_hierarchy$ and $icl'get\_theory\_info$.
This is modelled by the hidden ref variable $icl'current\_hierarchy$.
\item[$icl'theory\_store$ and $(dest\_)theory\_contents$]\

Interface: $icl'get\_theory$.
Modelled as part of the ML database - a theory is a labelled record
type and so does not need a $dest\_$ function.
\item[$icl'hierarchy\_store$]
Modelled as part of the ML database, not accessible to the user.
\item[$icl'theorem\_store$]
There is no interface to $icl'theorem\_store$.
Modelled as part of the ML database.
and hidden from the user.
\item[$initial\_state$]
Modelled by the initialisation of the components of state.
\item[$interpret\_...$]
Only formal constructs of the specification.
\item[$dest\_state$]
Hidden, as they would provide uncontrolled access to critical material.
\item[$current\_abstract\_theory$]
Only a formal construct of the specification.
\item[$theory\_info$]
Interface: $icl'get\_theory\_info$.
Hidden, as it would provide uncontrolled access to critical material.
\item[$current\_theory\_status$]
Interface: $get\_current\_theory\_status$.
\item[$check\_thm$, $check\_thm\_address$, $fetch\_thms$]
No external use.
\item[$arbitrary\_theory$, $empty\_theory$]
Only a formal construct of the specification.
\item[Material from section 6:]
This is purely concerned with ``good'' systems and a formal construct of the specification.
\end{description}

\subsubsection{Operations on Hierarchies}
Note that all of these operations will be highly compiler-dependent,
and that the user will not actually see the calls made to these
functions.
In particular, the user will find that they stay within one
hierarchy during their session.
=DOC
val âicl'new_hierarchyá : unit -> icl'HIERARCHY;
=DESCRIBE
$icl'new\_hierarchy$ computes a modified hierarchy from the current one,
setting all undeleted theories in that previous hierarchy as locked.
It may be later loaded by $icl'load\_hierarchy$ (q.v.).
=ENDDOC
=DOC
val âicl'load_hierarchyá : icl'HIERARCHY -> unit;
=DESCRIBE
The current hierarchy is made the stated hierarchy.
The current theory remains unchanged.
A hierarchy is formed by $icl'new\_hierarchy$ (q.v.).
=FAILURE
6032	?0 is not a known hierarchy
6033	?0 is not a descendant of the current hierarchy, ?1
=ENDDOC
=DOC
val âicl'get_hierarchyá : unit -> HIERARCHY;
=DESCRIBE
Returns an interface presentation of the current hierarchy.
=SEEALSO
$HIERARCHY$
=ENDDOC
=DOC
val âicl'get_theory_infoá : string -> THEORY_INFO;
=DESCRIBE
$icl'get\_theory\_info$ $theory$ returns an interface presentation of the information about the theory named $theory$ 
held within the current hierarchy.
The string ``-'' is understood by this function to mean the current theory.
=SEEALSO
$HIERARCHY$
=FAILURE
6042	There is no theory ?0 in the current hierarchy
=ENDDOC
=DOC
val âicl'get_theory_nameá : int -> string;
=DESCRIBE
$icl'get\_theory\_name$ $nm$ returns the actual theory name associated with $nm$, an internal representation of a theory name.
=FAILURE
6043	There is no theory associated with ?0
=ENDDOC

\subsubsection{Operations of Theory Attributes}
The specification presumes that a new theory hierarchy is created as the result of
each of the following operations, which will be a replacement for
the current one.
This design, however, assumes that the current theory hierarchy
is modified, not a new one created.
=DOC
val âicl'open_theoryá : string -> (int list * int list);
=DESCRIBE
This makes an existing theory of the current theory hierarchy the current theory,
making only it and those theories that are its ancestors in scope.
The function returns a pair of lists that are the internal form of theory names.
The first list is those theories that have passed out of scope,
the second is those that have come into scope.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6036	Theory ?0 has been deleted from the current hierarchy
=ENDDOC
Note that the Cambridge HOL $load\_theory$ would be implemented by
using $icl'open\_theory$ and $icl'lock\_theory$.
=DOC
val âicl'delete_theoryá : string -> unit;
=DESCRIBE
If the named theory is present in the current hierarchy,
is not in scope (and in particular is not the current theory),
is writable, and has no children, then delete it.
This means that all theorems that were proven with the deleted 
theory as the current theory will become unusable.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6036	Theory ?0 has been deleted from the current hierarchy
6037	Theory ?0 is locked
6038	Theory ?0 has child theories
6069	Theory ?0 is in scope
=ENDDOC
=DOC
val âicl'new_theoryá : string -> int;
=DESCRIBE
This adds a new, empty, theory to the current theory hierarchy,
with the given name.
The name must not previously have been used in the current hierarchy as a theory name, even if it has since been deleted.
The empty theory has no declarations within it,
but does have the current theory as its sole parent.
The function returns the internal form of the new theories name.
=FAILURE
6040	Theory ?0 is already present in current theory hierarchy
=ENDDOC
=DOC
val âicl'lock_theoryá : string -> unit;
=DESCRIBE
If the named theory exists, and is currently writable,
then it is made locked.
This locking may be unlocked using $icl'unlock\_theory$(q.v.).
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6036	Theory ?0 has been deleted from the current hierarchy
6037	Theory ?0 is locked
=ENDDOC
=DOC
val âicl'unlock_theoryá : string -> unit;
=DESCRIBE
If the named theory exists and has been locked by $icl'lock\_theory$(q.v.),
then this function unlocks it.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6036	Theory ?0 has been deleted from the current hierarchy
6068	Theory ?0 has not been locked
=ENDDOC
=DOC
val âicl'duplicate_theoryá : string -> string -> int;
=DESCRIBE
$icl'duplicate\_theory$ $source$ $duplicate$ creates a new theory,
called $duplicate$
with identical contents and parents to $source$,
but without its children.
Note that unless $source$ contains no declarations, then neither
theory could be an ancestor of the other, because of clashing 
declarations.
The function returns the internal form of the new theories name.
=USES
To allow the user to modify and experiment with a theory that
has child theories that are not involved in the experiment,
and would perhaps clash with the experiment.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6036	Theory ?0 has been deleted from the current hierarchy
=ENDDOC
\subsubsection{Operations on Theory Contents}
=DOC
val âdest_thmá : THM -> SEQ;
=DESCRIBE
This returns the representation of a theorem as a sequent, which is a list of assumptions and a conclusion.
=SEEALSO
$icl'dest\_thm$
=ENDDOC
This will not test whether the theorem is valid while destroying
it, as the result is ``harmless'' even if the theorem is invalid.
=DOC
val âicl'dest_thmá : THM -> {level:int, theory:THEORY, sequent :SEQ};
=DESCRIBE
This returns the full representation of a theorem, in a safe, interface, form.
The level is the definition level at which the theorem was created,the theory is the 
that which the theorem was created, and the sequent is the assumptions and conclusion
of the theorem.
=ENDDOC
This will not test whether the theorem is valid while destroying
it, as the result is ``harmless'' even if the theorem is invalid.
=DOC
val âicl'list_save_thmá : (string list * THM) -> THM;
=DESCRIBE
$icl'list\_save\_thm$ $(key list, thm)$ attempts to save $thm$ under the keys in $key$ $list$ 
in the current theory.
It will fail if $thm$ is not valid, the current theory is locked, there are no keys, or if any $key$ has already been used to save a theorem in
the current theory.
The function returns $thm$.
=FAILURE
6037	Theory ?0 is locked
6031	Key list may not be empty
6039	Key ?0 has already been used for a theorem in theory ?1
=ENDDOC
It is tempting to call this $icl'new\_thm$, by analogy to,
say, $icl'new\_definition$.
=DOC
val âicl'delete_extensioná : unit -> unit;
=DESCRIBE
$icl'delete\_extension$ $key$ will delete the last extension to the
current theory.
This will undo the effect of the last execution of any of:

\begin{tabular}{l p{4.0in}}
$icl'new\_type$ & \\
$icl'new\_const$ & \\
$icl'new\_axiom$ & \\
$icl'new\_definition$ & Deleting the definition (under all its keys), and the constant declared. \\
$icl'new\_specification$ & Deleting the specification (under all its keys), and the constants declared. \\
$icl'new\_type\_definition$ & Deleting the definition (under all its keys) and type declared. \\
\end{tabular}

Note that, amongst other effects, all theorems created in the theory since the deleted extension was created
will become unusable after the deletion.
=FAILURE
6037	Theory ?0 is locked
6050	Theory ?0 contains no extensions
=ENDDOC
There is no point in the function returning the deleted
definition, etc, because the theorem is unusable.

It is up to the interface to this package to determine what a 
user wants to delete, check that the deletions required are indeed desired, and do sufficient $icl'delete\_extension$s
to delete the original offending declaration.
This may be done by examining the results of $icl'get\_theory$.
=DOC
val âicl'delete_thmá : string -> unit;
=DESCRIBE
$icl'delete\_thm$ $key$ attempts to delete the theorem
saved in the current theory under $key$.
It will fail if the key does not refer to a theorem, or the theory
is locked.
=FAILURE
6037	Theory ?0 is locked
6046	Key ?0 is not used for an theorem in theory ?1
=ENDDOC
=DOC
val âicl'new_axiomá : (string list * TERM) -> THM;
=DESCRIBE
$icl'new\_axiom$ $(key list, term)$ attempts to save as an axiom the theorem `$… term$'
on the current theory under each of the keys provided.
It fails if the theorem is ill-formed (e.g. it uses an undeclared
or incorrectly typed constant),
the current theory is locked, the key list is empty, or a $key$ has already been used for
an axiom.
=FAILURE
6037	Theory ?0 is locked
6031	Key list may not be empty
6047	Key ?0 has already been used for an axiom in theory ?1
6048	Term argument is ill-formed in theory ?0
6017	Term is not boolean
=ENDDOC
We might look for a more informative error message for 6048.
=DOC
val âicl'new_constá : (string * TYPE) -> TERM;
=DESCRIBE
$icl'new\_const$ $(name, type)$ introduces a new constant
(with no defining theorem) called $name$, with most general type
$TYPE$, into the current theory.
The function returns the constant as a term, with the stated
most general type.
=FAILURE
6049	There is a constant called ?0 already in scope
6063	There is a constant called ?0 in the descendants of the
	current theory
=ENDDOC
We expect that a constant's fixity will be set by a separate 
function call, rather than being bound up in a user-level
$icl'new\_const$.
=DOC
val âicl'new_typeá : (string * int) -> TYPE;
=DESCRIBE
$icl'new\_type$ $(name, arity)$ introduces a new type (constructor) 
(with no defining theorem) called $name$ with arity $arity$ into the
current theory.
The function returns the new type with sufficient arguments $'1, '2, \ldots$
to provide a well formed type.
=FAILURE
6045	There is a type called ?0 already in scope
6034	There is a type called ?0 in the descendants of the current theory
=ENDDOC
We expect that a type's fixity will be set by a separate 
function call, rather than being bound up in a user-level
$icl'new\_type$ function.
\subsubsection{Definitional Mechanisms for Theories}
=DOC
val âicl'new_definitioná : (string list * string * TERM) -> THM;
=DESCRIBE
$icl'new\_definition$ $(key\ list, name, value)$ declares a new
constant with name $name$, and with most general type being
the type of $value$ in the current theory.
It also creates a theorem of the form `$… name = value$'
(or `$… name ‚ value$' if $value$ is boolean), and saves it as a definition
with the keys in $key\ list$, again in the current theory,
presuming that the theorem is well-formed.
If either the constant or theorem introduction fails then
the function will not change the current theory.
=FAILURE
6031	Key list may not be empty
6037	Theory ?0 is locked
6048	Term argument is ill-formed in theory ?0
6049	There is a constant called ?0 already in scope
6063	There is a constant called ?0 in the descendants of the
	current theory
6051	Key ?0 has already been used for an definition in theory ?1
6058	Term contains type variables not found in type of term itself
6059	Term contains free variables
=ENDDOC
The fixity of the definition is not given at the point of definition,
but by a separate user directive, in the non-critical code.
=DOC
val âicl'new_type_definitioná : 
	(string * string * string list * THM) -> THM;
=DESCRIBE
$icl'new\_type\_definition$ $(key\ list, name, typars, defthm)$
declares a new type with name $name$, and arity the length of
$typars$.
It also creates a defining theorem for the type, saves it in the current theory under the keys in $key\ list$, and also returns it.
$defthm$ must be of the form:
ó
… „ x : type Ž p x
æ
with no assumptions.
The defining theorem will then be of the form:
ó
… „ f : typars name ‹ type Ž 
	TypeDefinition (p: type ‹ BOOL) f
æ
where $TypeDefinition$ is defined so as to state that its predicate argument 
$p$ is non-empty, and its function argument $f$ is a bijection
between the new type and the subset of $type$ delineated by $p$.
=FAILURE
6037	Theory ?0 is locked
6045	There is a type called ?0 already in scope
6034	There is a type called ?0 in the descendants of the current theory
6052	Key ?0 has already been used for an type definition theorem in theory ?1
6053	Theorem must not have assumptions
6054	Theorem is not of the form: `… „ x Ž p x`
6055	Theorem is not of the form: `… „ x Ž p x` where »x¼  is a variable
6056	Theorem contains free variables
6057	Theorem contains type variables not found in type variable parameter list
6031	Key list may not be empty
=ENDDOC
=DOC
val âicl'new_specificationá : (string list * int * THM) -> THM;
=DESCRIBE
$icl'new\_specification$ $(keylist$, $ndef$, $`… „ x_1,\ldots,x_n\ Ž\ p[x_1,\ldots,x_n]')$
will introduce $ndef$ new constants named and typed from the $x_i$.
It will also save a defining theorem under each of the names in
$keylist$ in the current theory of the
form `$… p[c_1,\ldots,c_n]$' where $c_i$ is the constant with the
name and type of $x_i$.
If either the constant or theorem introduction fails then
the function will not change the current theory.
=FAILURE
6031	Key list may not be empty
6037	Theory ?0 is locked
6049	There is a constant called ?0 already in scope
6063	There is a constant called ?0 in the descendants of the
	current theory
6060	Theorem is not of the form `… „ x1,...,xn Ž p[x1,...,xn]`
6051	Key ?0 has already been used for an definition in theory ?1
6053	Theorem must not have assumptions
6056	Theorem contains free variables
6044	Must define at least one constant
6064	Theorem must be existentially quantified at least ?0 times
6061	Theorem contains type variables ?0 not found in the type of
	all the constants to be defined
6016	Theorem is not of the form `… „ x1,...,xn Ž p[x1,...,xn]`
	where the »xi¼ are all distinct
=ENDDOC
$ndef$ could be allowed to be $0$, which forms an odd way of 
saving a theorem as a definition, though we do not currently allow this option.

We do not need Cambridge HOL's $flag\_name\_list$ parameter, that lists
the names of the new constants, and their lexical properties.
The names come from the existential quantifiers, the number from $ndef$, the properties
from separate user directives.
=DOC
val âicl'new_parentá : string -> unit;
=DESCRIBE
Adds the given parent theory to the list of parents of the current
theory, considered as a set.
It will fail if the parent theory does not exist,
or if making it a parent causes clashes in the current theory
or its children.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6036	Theory ?0 has been deleted from the current hierarchy
6037	Theory ?0 is locked
6067	Making ?0 a parent would cause a clash
=ENDDOC
Error 6067 should be more informative.
Error 6035 and 6036 could be called because of either the current theory,
or the new parent.
\subsubsection{Theory Access Functions}
Many of the theory access functions will be found
in the interface document, \cite{DS/FMU/IED/DTD012}.
The ones below are provided as they may be more efficiently
implemented within the abstract data type, than by
an interface function accessing the results of just
$icl'get\_theory\_hierarchy$.

=DOC
val âicl'get_theoryá : string -> THEORY;
=DESCRIBE
This returns the named theory in its ``raw'' state.
This cannot lead to logical inconsistencies,
e.g. by returning addresses of ``trusted'' ML variables that the user
could modify without going through the proper interface functions.
However, the user is recommended to use the interface functions,
rather than directly access the theory.

This function recognises ``-'' as indicating the current theory name.
=SEEALSO
$THEORY$ for the structure of the result
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6036	Theory ?0 has been deleted from the current hierarchy
6062	Theory ?0 is not in scope
=ENDDOC
=DOC
val âget_current_theory_nameá : unit -> string;
=DESCRIBE
Returns the current theories name.
=ENDDOC
=DOC
val âget_current_theory_statusá : unit -> THEORY_STATUS;
=DESCRIBE
Returns the current theories status.
=ENDDOC

=SML
end(* signature of icl'Theorems *);
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
=IGN
Coverage of error numbers:

open Sort;
fun ern x = map (fn{id=id,...}=>id)(get_error_messages x);
sort(curry(op -)) (ern ());

=TEX
\end{document}
