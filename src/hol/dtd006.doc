=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
\TPPtitle{Release 1 ICL HOL: Detailed Design for the Abstract Data Type $THM$}  %% Mandatory field
\def\TPPheadtitle{Release 1 ICL HOL \cr Detailed Design for the Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/DTD006}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
abstract data type $THM$.
This includes its
primitive and built-in inference rules,
and its theory management material.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Changes after RDA comments.
\end{description}
\subsection{Changes forecast}
Many, in particular, the addition of the theory management section,
and the axioms.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
abstract data type $THM$.
This includes its
primitive and built-in inference rules,
and its theory management material.
This is called for in section 4 of \cite{DS/FMU/IED/HLD007}.
The high-level specification for the code is
given in \cite{DS/FMU/IED/SPC003}, \cite{DS/FMU/IED/SPC004} and \cite{DS/FMU/IED/SPC005}.
The design is
implemented in \cite{DS/FMU/IED/IMP006}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
abstract data type $THM$.
This includes its
primitive and built-in inference rules,
and its theory management material.
A ``primitive'' inference rule is considered to be part of the logic,
whereas a built-in rule is one that, though it could be coded in terms 
of the primitive rules, will actually be part of the abstract data type $THM$, and thus taken as holding true without checking.

All functions require all their arguments to begin evaluation,
unless otherwise noted.
\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.

This document is placing requirements on the properties on the
constants it invokes.
These are: $ä$, $=$, $Ç$, $Suc$, $Zero$, $Mod$, $Div$, $Cons$,
$Nil$, $AbsChar$, $É$.
It also requires the logic to subsume the typed lambda calculus.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}

\section{THE ABSTRACT DATA TYPE $THM$}
=DOC
signature ‚icl'Theorems· = sig
=DESCRIBE
This provides the abstract data type $THM$.
This includes its
primitive and built-in inference rules,
and its theory management material.
=ENDDOC
\subsection{The Type of Theorems}
=DOC
type ‚THM·;
=DESCRIBE
This is the type of theorems in ICL HOL, which can only be created by functions that maintain consistency.
=ENDDOC
=DOC
type ‚SEQ·;
=DESCRIBE
This is the type of sequents, the representation type of theorems.
ÛDefinition
type SEQ = (TERM list) * TERM;
Ê
=ENDDOC
=DOC
type ‚CONV·;
=DESCRIBE
This is the type of conversions, that is, inference rules
whose last argument is a term, and whose result is an equation
whose LHS is precisely that term (no $\alpha$-conversion).
All conversion names will have $\_conv$ as their conventional suffix.
The type is to be used as a subset of $TERM\ ->\ THM$.
=ENDDOC
=DOC
val ‚dest_thm· : THM -> SEQ;
=DESCRIBE
This returns the representation of a theorem, as a list of assumptions and a conclusion.
=ENDDOC
=IGN
And whatever else seems appropriate - $hyp$, $concl$, etc.
=TEX
\subsection{Primitive Rules of Inference}
=DOC
val ‚subst_rule· : (THM * TERM) list -> TERM -> THM -> THM;
=DESCRIBE
Substitution of equality theorems according to a template.
=RULE
subst_rule
…
[ˆ1 Ö t1=t1', ... , ˆn Ö tn=tn']
ˆ Ö t[t1,...tn]
…
ˆ1 ° ... ˆn ° ˆ Ö t[t1',...tn']
=TEX

$subst\_rule$ $[(thm_1, v_1),\ldots,(thm_n, v_n)]$ $template$ $thm$
returns a theorem in which $template$ determines where in $thm$ the $thm_i$ are substituted.
The $v_i$ must be variables.
The template is of the form $t[v_1,\ldots,v_n]$, and wherever the $v_i$ are free in $template$ their associated equality theorem, $thm_i$,
is substituted into $thm$.
The rule will rename as necessary to avoid bound variable capture.
The assumption list of the resulting theorem will be the union of all
substitution theorems, regardless of use.

The conclusion of the resulting theorem will take its bound variable names
from $template$, not $thm$, as shown in the following example.
This provides an $\alpha$-conversion facility.
($SUBST$ in Cambridge HOL)
=EXAMPLE
subst_rule [(`Ö p = q', ªx1º), (`Ö r = s', ªx2º)] 
	(ªÉ y é f x1 r y + g x2 p = h yº)
	(`Ö É x é f p r x + g r p = h x')
	=
	`Ö É y é f q r y + g s p = h y'
=FAILURE
6001	Template term does not substitute to conclusion of theorem
6002	A substitution theorem is not of the form: `ˆ Ö t1 = t2' or `ˆ Ö t1 Ç t2'
6003	First argument is not of the form: `[...,(thm1,ªxº),...]' where ªxº is a variable
6029	First argument is not of the form: `[...,(ˆ Ö t1 = t2,ª?0º),...]' 
	where the type of ª?0º is the same as the type of ªt1º 
=ENDDOC
The $(\ldots * TERM)$ argument in the specification is a $string$ $*$ $TYPE$, representing destroyed variables.
A list is used to represent the specification's (partial) function,
on the assumption that its domain is finite.

Partial evaluation with only the list of theorem-variable pairs might 
be a useful feature.
=DOC
val ‚abs_rule· : TERM -> THM -> THM;
=DESCRIBE
Given an equality theorem, return the equation formed by abstracting the term argument (which must be a variable) from both sides.
=RULE
abs_rule
(x : TERM)
…
ˆ Ö t1 = t2
…
ˆ Ö (ç x é t1) = (ç x é t2)
=TEX
And:
=RULE
abs_rule
(x : TERM)
…
ˆ Ö t1 Ç t2
…
ˆ Ö (ç x é t1) = (ç x é t2)
=TEX

($ABS$ in Cambridge HOL).
=FAILURE
6004	Term is not a variable
6005	?0 occurs free in assumption list
=ENDDOC
The $TERM$ argument in the specification is a $string$ $*$ $TYPE$, representing destroyed variables.
We could rename this $simple\_abs\_rule$ and write a derived rule for paired abstractions.
=DOC
val ‚inst_type_rule· : (TYPE * TYPE) list -> THM -> THM;
=DESCRIBE
Parallel instantiation of some of the type variables of the conclusion of a theorem.
=RULE
inst_type_rule
[(˛1, tyv1), ..., (˛n,tyvn)]
…
ˆ Ö t[tyv1,...tyvn]
…
ˆ Ö t[˛1,...˛n]
=TEX
$inst\_type\_rule$ $talist$ $thm$ will instantiate each type variable in
$talist$ with its associated type.
It will decorate free variables that would become identified with
other variables by their types becoming the same and the names originally being the same.
To instantiate types in the assumption list, see $asm\_inst\_type\_rule$.
($INST\_TYPE$ in Cambridge HOL).
=FAILURE
6006	May not instantiate type variables occurring in assumption list
6007	Type association list is not of the form: `[...,(tyi, tyvi),...]'
	where the `tyvi' are all type-variables
=ENDDOC
The $(\ldots * TYPE)$ argument in the specification is a $string$, representing the name of a type variable.
A list is used to represent the specification's (partial) function,
on the assumption that its domain is finite.
=DOC
val ‚ä_intro· : TERM -> THM -> THM;
=DESCRIBE
Create an implication theorem, removing, if $\alpha$-convertibly present, the hypothesis of the implication from the assumption list.
=RULE
ä_intro
(t1 : TERM)
…
ˆ Ö t2
…
ˆ - {t1} Ö t1 ä t2
=TEX
($DISCH$ in Cambridge HOL)
=FAILURE
6009	Term is not boolean
=ENDDOC
=DOC
val ‚ä_elim· : THM -> THM -> THM;
=DESCRIBE
Modus Ponens upon an implication.
=RULE
ä_elim
…
ˆ1 Ö t1 ä t2; ˆ2 Ö t1'
…
ˆ1 ° ˆ2 Ö t2
=TEX
where $t1$ and $t1'$ must be $\alpha$-convertible.
($MP$ in Cambridge HOL)
=SEEALSO
$Ç\_mp\_rule$(Modus Ponens on $Ç$)
=FAILURE
6010	First argument is not of the form: `ˆ Ö t1 ä t2'
6011	Theorems are not of the form: `ˆ1 Ö t1 ä t2' and `ˆ2 Ö t3' where
	ªt1º and ªt3º are alpha-convertible
=ENDDOC
The specification calls for equality rather than $\alpha$-convertibility.
=DOC
val ‚asm_rule· : TERM -> THM;
=DESCRIBE
A term is true on the assumption that it is true.
=RULE
asm_rule
(t : TERM)
…
…
t Ö t
=TEX
($ASSUME$ in Cambridge HOL)
=FAILURE
6009	Term is not boolean
=ENDDOC
=DOC
val ‚refl_conv· : CONV;
=DESCRIBE
The reflexivity of equality considered as a conversion.
=RULE
refl_conv
(t : TERM)
…
…
Ö t = t
=TEX
Or, if $t$ is boolean:
=RULE
refl_conv
(t : TERM)
…
…
Ö t Ç t
=TEX
($ALL\_CONV$ and $REFL$ in Cambridge HOL).
=ENDDOC
=DOC
val ‚simple_beta_conv· : TERM -> THM;
=DESCRIBE
Apply a $\beta$-reduction to a simple abstraction.
=CONVERSION
simple_beta_conv
((ç x é t1[x]) t2)
…
…
Ö (ç x é t1[x]) t2 = t1[t2]
=TEX
Or, if the term is of type $BOOL$:
=CONVERSION
simple_beta_conv
((ç x é t1[x]) t2)
…
…
Ö (ç x é t1[x]) t2 Ç t1[t2]
=TEX
($BETA\_CONV$ in Cambridge HOL)
=SEEALSO
$beta\_conv$
=FAILURE
6012	Term is not of the form: ª(ç x é t1[x])t2º where ªxº is a variable
=ENDDOC
Later versions will be called $simple\_\beta\_conv$.
\subsection{Definition Schemata}
=DOC
val ‚icl'suc_conv· : TERM -> THM;
=DESCRIBE
This function defines the meaning of the constants with names consisting only of decimal digits, and type $NUM$.
=RULE
icl'suc_conv
(mk_num (m+1))
…
…
Ö ^(mk_num(m+1)) = Suc ^(mk_num m)
=TEX
=RULE
icl'suc_conv
(mk_num 0)
…
…
Ö 0 = Zero
=TEX
($num\_CONV$ in Cambridge HOL)
=FAILURE
6013	Term is not a literal numeric constant
=SEEALSO
$suc\_conv$
=ENDDOC
$suc\_conv$ will not have the clause for $0$.
=DOC
val ‚string_conv· : TERM -> THM;
=SYNOPSIS
This function defines the meaning of the constants with name starting with $"$, and type $STRING$.
=DESCRIBE
A literal string constant is indicated by the constant's name starting with $"$, as well as being of type $STRING$.
This is equivalent to a list of literal character constants,
one for each but the first ($"$) character of the string constant's name.
This conversion defines this relationship, by returning the head and unexploded tail of the list of characters.
=RULE
string_conv
(mk_string ("c" :: t))
…
…
Ö ^(mk_string("c" :: t)) = 
Cons ^(mk_char("c")) ^(mk_string(t))
=TEX
Or:
=RULE
string_conv
(mk_string "")
…
…
Ö ^(mk_string("")) = Nil
=TEX
=FAILURE
6014	Term is not a literal string constant
=ENDDOC
=DOC
val ‚char_conv· : TERM -> THM;
=DESCRIBE
This function gives a relationship between literal character constants and their ASCII code (derived by the Standard ML function $ord$):
=RULE
char_conv
(mk_char("c"))
…
…
Ö ^(mk_char("c")) = AbsChar ^(ord "c")
=TEX
=FAILURE
6015	Term is not a literal character constant
=ENDDOC

\subsection{Built-In Rules of Inference}
Each of the following inference rules may be justified in terms of the primitive inference rules
and definitional schemata, or derived rules proven prior to the new declaration.
We will give an informal proof 
in each case, following the documentation of the rule.
This provides a partial order of introduction on the rules that follow.
We will ignore the distinction between $=$ and $Ç$ in our proofs when
either could be present, and present the proof in terms of $=$.
\subsubsection{$eq\_sym\_rule$}
=DOC
val ‚eq_sym_rule· : THM -> THM;
=DESCRIBE
Symmetry of equality and $Ç$
=RULE
eq_sym_rule
…
ˆ Ö t1 = t2
…
ˆ Ö t2 = t1
=TEX
And:
=RULE
eq_sym_rule
…
ˆ Ö t1 Ç t2
…
ˆ Ö t2 Ç t1
=TEX
($SYM$ in Cambridge HOL)
=FAILURE
6025	Theorem is not of the form: `ˆ Ö t1 = t2' or `ˆ Ö t1 Ç t2'
=ENDDOC
Û
1.	ˆ Ö t1 = t2			Hypothesis
2.	Ö t1 = t1			eq_refl_rule
3.	ˆ Ö t2 = t1			subst_rule 1,2
Ê
\subsubsection{Ç\_T\_elim}
We wish for the following rule of inference (that is not built in):
=RULE
Ç_T_elim
…
ˆ Ö t Ç T
…
ˆ Ö t
=TEX
Justified by:
ÛInformal Proof
1.	ˆ Ö t Ç T					Hypothesis
2.	ˆ Ö T Ç t					eq_sym_rule 1
3.	Ö T						t_thm
4.	ˆ Ö t						subst_rule 3,2
Ê
\subsubsection{simple\_É\_elim}
=DOC
val ‚simple_É_elim· : TERM -> THM -> THM;
=DESCRIBE
Instantiate a universally quantified variable to a given value.
=RULE
simple_É_elim
(t1 : TERM)
…
ˆ Ö É x é t2[x]
…
ˆ Ö t2'[t1]
=TEX
where $t2'$ is renamed from $t2$ to prevent bound variable capture,
and $x$ is a variable.
($SPEC$ in Cambridge HOL)
=FAILURE
6018	Theorem is not of the form: `ˆ Ö É x é t' where ªxº is a variable
6019	Theorem is not of the form: `ˆ Ö É ?0 é t' where the type of ª?0º 
	is the type of the term argument
=ENDDOC
Û
1.	Ö $É = (çP é P = çx.T)			inst_type applied to Definition
2.	ˆ Ö É x é t2[x]					Hypothesis
3.	ˆ Ö (çP é P = çx.T)(ç x é t2[x])		subst_rule 1,2
4.	Ö (çP é P = çx é T)(ç x é t2[x]) = ((ç x é t2[x]) = çx.T)
							beta_conv
5.	ˆ Ö (ç x é t2[x]) = çx é T			subst_rule 4,3
6.	Ö (ç x é t2[x]) t1 Ç (ç x é t2[x]) t1		eq_refl_rule
7.	ˆ Ö (ç x é t2[x]) t1 Ç (çx é T) t1		subst_rule 5,6
8.	ˆ Ö (ç x é t2[x]) t1 Ç t2'[t1]			beta_conv
9.	ˆ Ö t2'[t1] Ç (ç x é t2[x]) t1			eq_sym_rule 8
10.	ˆ Ö t2'[t1] Ç (çx é T) t1			subst_rule 9,5
11.	Ö (çx é T) t1 Ç T				beta_conv
12.	ˆ Ö t2'[t1] Ç T				subst_rule 10,11
13.	ˆ Ö t2'[t1]					Ç_T_elim 12
Ê
Notice in step 8. where $beta\_conv$ may introduce some renaming
(changing $t2$ to $t2'$)
to prevent bound variable capture.
\subsubsection{$eq\_trans\_rule$}
=DOC
val ‚eq_trans_rule· : THM -> THM -> THM;
=DESCRIBE
Transitivity of equality and $Ç$:
=RULE
eq_trans_rule
…
ˆ1 Ö t1 = t2; ˆ2 Ö t2' = t3
…
ˆ1 ° ˆ2 Ö t3
=TEX
And:
=RULE
eq_trans_rule
…
ˆ1 Ö t1 Ç t2; ˆ2 Ö t2' Ç t3
…
ˆ1 ° ˆ2 Ö t1 Ç t3
=TEX
where ªt2º and ªt2'º are $\alpha$ convertible.
($TRANS$ in Cambridge HOL)
=FAILURE
6020	First theorem is not of the form: `ˆ Ö t1 = t2' or `ˆ Ö t1 Ç t2'
6021	Second theorem is not of the form: `ˆ Ö t1 = t2' or `ˆ Ö t1 Ç t2'
6022	Theorems are not of the form: `ˆ1 Ö t1 = t2' and `ˆ2 Ö t3 = t4'
	where ªt2º and ªt3º are alpha-convertible
=ENDDOC
Û
1.	ˆ1 Ö t1 = t2			Hypothesis
2.	ˆ2 Ö t2' = t3			Hypothesis
3.	ˆ1 ° ˆ2 Ö t1 = t3		subst_rule 2,1
Ê
\subsubsection{$mk\_comb\_rule$}
=DOC
val ‚mk_comb_rule· : THM -> THM -> THM;
=DESCRIBE
Given two equations, one being of two functions, apply the two functions
to the LHS and RHS of the other equation.
=RULE
mk_comb_rule
…
ˆ1 Ö u1 = u2; ˆ2 Ö v1 = v2
…
ˆ1 ° ˆ2 Ö u1 v1 = u2 v2
=TEX
The second input theorem or the result may be expressed using $Ç$.
($MK\_COMB$ in Cambridge HOL)
=FAILURE
6020	First theorem is not of the form: `ˆ Ö t1 = t2' or `ˆ Ö t1 Ç t2'
6021	Second theorem is not of the form: `ˆ Ö t1 = t2' or `ˆ Ö t1 Ç t2'
6023	Theorems are not of the form `ˆ1 Ö u1 = u2' and `ˆ2 Ö v1 = v2'
	where ªu1º can be applied to ªv1º
=ENDDOC
ÛInformal Proof
1.	ˆ1 Ö u1 = u2					Hypothesis
2.	ˆ2 Ö v1 = v2					Hypothesis
3.	Ö u1 v1 = u1 v1				eq_refl_rule
4.	ˆ1 ° ˆ2 Ö u1 v1 = u2 v2			subst_rule [1,2] 3
Ê
\subsubsection{Ç\_T\_intro}
We wish for the following rule of inference (that is not built in):
=RULE
Ç_T_intro
…
ˆ Ö t
…
ˆ Ö t Ç T
=TEX
which is justified by:
ÛInformal Proof
1.	Ö É b1 b2 é (b1 ä b2) ä (b2 ä b1) ä (b1 Ç b2)	
							ä_antisym_axiom
2.	Ö É b2 é (t ä b2) ä (b2 ä t) ä (t Ç b2)	
							simple_É_elim 1
3.	Ö (t ä T) ä (T ä t) ä (t Ç T)		simple_É_elim 2
4.	Ö T						t_thm
5.	Ö t ä T					ä_intro 4
6.	Ö (T ä t) ä (t Ç T)				ä_elim 3,5
7.	ˆ Ö t						Hypothesis
8.	ˆ Ö T ä t					ä_intro 7
9.	ˆ Ö t Ç T					ä_elim 6,8
Ê
where the context must contain the theorems:
Û
ä_antisym_axiom = 
	Ö É b1 b2 é (b1 ä b2) ä (b2 ä b1) ä (b1 Ç b2)

t_thm = 
	Ö T
Ê

\subsubsection{Ç\_mp\_rule}
=DOC
val ‚Ç_mp_rule· : THM -> THM -> THM;
=DESCRIBE
Modus Ponens on $Ç$.
=RULE
Ç_mp_rule
…
ˆ1 Ö t1 Ç t2; ˆ2 Ö t1'
…
ˆ1 ° ˆ2 Ö t2
=TEX
where $t1$ and $t1'$ must be $\alpha$-convertible.
($EQ\_MP$ in Cambridge HOL)
=SEEALSO
$ä\_elim$ (Modus Ponens on $ä$)
=FAILURE
6030	First theorem is not of the form: `ˆ Ö t1 Ç t2'
6024	Theorems are not of the form: `ˆ1 Ö t1 Ç t2' and `ˆ2 Ö t3'
	where ªt1º and ªt3º are alpha-convertible
=ENDDOC
ÛInformal Proof
1.	ˆ1 Ö t1 Ç t2					Hypothesis
2.	ˆ2 Ö t1'					Hypothesis
3.	ˆ2 Ö t1' Ç T					Ç_T_intro 2
4.	ˆ1 ° ˆ2 Ö t2 Ç T				subst_rule 1,3
5.	ˆ1 ° ˆ2 Ö t2					Ç_T_elim 4
Ê
\subsubsection{simple\_É\_intro}
=DOC
val ‚simple_É_intro· : TERM -> THM -> THM;
=DESCRIBE
Introduce a simple universal quantification.
=RULE
simple_É_intro
(x : TERM)
…
ˆ Ö t
…
ˆ Ö É x é t
=TEX
($GEN$ in Cambridge HOL)
=SEEALSO
$É\_intro$
=FAILURE
6004	Term is not a variable
6005	?0 occurs free in assumption list
=ENDDOC
In the following we use $subst\_rule$ where the HOL description uses $TRANS$( ‹ $eq\_trans\_rule$).

First we prove $Éx é T$
ÛInformal Proof
1.	Ö (çx é T) = çx é T				eq_refl_rule
2.	Ö ((çx é T) = çx é T) Ç T			Ç_T_intro 1
3.	Ö (çP é P = çx é T)(çx é T) Ç ((çx é T) = çx é T)
							beta_conv
4.	Ö (çP é P = çx é T)(çx é T) Ç T		subst_rule 3, 2
5.	Ö $É = (çP é P = çx é T)			inst_type applied to Definition
6.	Ö (çP é P = çx é T) = $É			eq_sym_rule 5
7.	Ö (Éx é T) Ç T					subst_rule 6, 4
8.	Ö (Éx é T)					Ç_T_elim 7
Ê
where the context must contain the stated definition of $É$.
Then we can prove $É\_intro$:
ÛInformal Proof
1.	ˆ Ö t						Hypothesis
2.	ˆ Ö t Ç T					Ç_T_intro 1
3.	ˆ Ö (çy é t) = çy é T				abs_rule 2
4.	Ö (Éy é t) Ç (Éy é t)				eq_refl_rule
5.	ˆ Ö (Éy é t) Ç Éy é T				subst_rule 3,4
6.	ˆ Ö (Éy é T) Ç Éy é t				eq_sym_rule 5
7.	Ö Éx é T					inst_type_rule(Ö Éx é T)
8.	Ö Éy é T					subst_rule[] 7
9.	Ö Éy é t						subst_rule 6, 8
Ê
Note that $subst\_rule\;[]\;t\;(Ö\,t')$ returns $Ö\,t$ iff.
$t$ and $t'$ are $\alpha$-convertible.
\subsubsection{$inst\_term\_rule$}
=DOC
val ‚inst_term_rule· : (TERM * TERM) list -> THM -> THM;
=DESCRIBE
Parallel instantiation of term variables within a theorem's conclusion to some other values.
=RULE
inst_term_rule
[(t1, v1), ..., (tn, vn)]
…
ˆ Ö t[v1, ..., vn]
…
ˆ Ö t[t1, ..., tn]
=TEX
($INST$ in Cambridge HOL)
=FAILURE
6026	Term association list must be [..., (term, term-variable), ...]
6027	Types of element (ªtº, ª?0º) in term association list differ
6028	Instantiation variable ?0 free in assumption list
=ENDDOC
Perhaps this should be called $inst\_rule$.
A list is used to represent the specification's (partial) function,
on the assumption that its domain is finite.
ÛInformal Proof
1.	ˆ Ö t[v1, ..., vn]			Hypothesis
2.	ˆ Ö É v1 ... vn é t[v1, ..., vn]		repeated simple_intro on 1
3.	ˆ Ö t[t1, ..., tn]				repeated simple_É_elim on 2
Ê
It is important to do all the generalisations before any  specialisations to gain the instantiation in parallel effect.
Without this, if a variable to be instantiated is introduced by
a specialisation, and then generalised along with those already
present, then that variable occurrence will also be instantiated. 
\subsubsection{$div2\_conv$}
=DOC
val ‚div2_conv· : TERM -> THM;
=DESCRIBE
Provides the value of $Div\ 2$ of a natural number.
=RULE
div2_conv
(mk_num n)
…
…
Ö ^(mk_num n) Div 2 = ^(mk_num(n div 2))
=TEX
=USES
For doing fast arithmetic proofs.
=FAILURE
6013	Term is not a literal numeric constant
=ENDDOC
This rule should only be used in a context that contains definitions of $Div$ and $Mod$ from which we can prove:
Û
(Éné n > 0 ä 0 Mod n = 0)
Ä
(Ém né n > 0 ä (Suc m) Mod n = if Suc(m Mod n) < n 
	then Suc(m Mod n) 
	else  0)
Ê
Û
Ö (É n é n > 0 ä 0 Div n = 0)
Ä
(Ém nén > 0 ä 
 (Suc m) Div n = if Suc(m Mod n) < n 
	then m Div n 
	else Suc(m Div n))
Ê
as well as appropriate definitions of $+$ and $*$.
From these we would derive (after some effort) the theorems:
Û
A.	Ö 0 Div 2 = 0
B.	Ö 1 Div 2 = 0
C.	Ö É n é (Suc(Suc n)) Div 2 = Suc(n Div 2)
Ê
From these, $icl'suc\_conv$, and $eq\_refl\_rule$ we could justify any single
instance of this theorem schemata.
E.g.
ÛInformal Proof of ?Ö 5 Div 2 = 2
1.	Ö Suc(Suc 0) = 2			eq_sym_rule(repeated icl'suc_conv)
2.	Ö 0 = 1 Div 2				eq_sym_rule (B)
3.	Ö Suc(Suc (1 Div 2)) = 2		subst_rule 1,2
4.	Ö Suc (1 Div 2) = (Suc(Suc 1)) Div 2 
						eq_sym_rule(simple_elim on (C))
5.	Ö Suc((Suc(Suc 1)) Div 2) = 2		subst_rule 3,4
6.	Ö Suc ((Suc(Suc 1)) Div 2) = (Suc(Suc (Suc(Suc 1)))) Div 2
						eq_sym_rule(simple_elim on (C))
7.	Ö (Suc(Suc (Suc(Suc 1)))) Div 2 = 2
						subst_rule 5,6
8.	Ö (Suc(Suc (Suc(Suc 1)))) = 5		repeated icl'suc_conv
9.	Ö 5 Div 2 = 2				subst_rule 7, 8
Ê
\subsubsection{$mod2\_conv$}
=DOC
val ‚mod2_conv· : TERM -> THM;
=DESCRIBE
Provides the value of $Mod\ 2$ of a natural number.
=RULE
mod2_conv
(mk_num n)
…
…
Ö ^(mk_num n) Mod 2 = ^(mk_num(n mod 2))
=TEX
=USES
For doing fast arithmetic proofs.
=FAILURE
6013	Term is not a literal numeric constant
=ENDDOC
This is only justified in the context of a theory containing
the above definitions of $Div$ and $Mod$
and ``proper'' definitions of $+$ and $*$.
From these we would derive (after some effort) the theorems:
Û
A.	Ö 0 Mod 2 = 0
B.	Ö 1 Mod 2 = 1
C.	Ö É n é (Suc(Suc n)) Mod 2 = (n Mod 2)
Ê
From these, $icl'suc\_conv$, and $eq\_refl\_rule$ we could justify any single
instance of this theorem schemata.
E.g.
ÛInformal Proof of ?Ö 5 Mod 2 = 1
1.	Ö 1 Mod 2 = 1					(B)
2.	Ö (Suc(Suc 1)) Mod 2 = (1 Mod 2)		simple_É_elim on (C)
3.	Ö (Suc(Suc 1)) Mod 2 = 1			subst_rule 1,2
4.	Ö (Suc(Suc (Suc(Suc 1)))) Mod 2 = ((Suc(Suc 1)) Mod 2)
							simple_É_elim on (C)
5.	Ö (Suc(Suc (Suc(Suc 1)))) Mod 2 = 1		eq_trans_rule 3,4
6.	Ö (Suc(Suc (Suc(Suc 1)))) = 5			repeated use of subst_rule
							and icl'suc_conv
7.	Ö 5 Mod 2 = 1
Ê


\subsection{Theory Management}
T.B.S.
=SML
end(* signature of icl'Theorems *);
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
