%  $RCSfile$ $Date$ $Revision$
% def007A: include file for def007 and usr005
%
=TEX
\section{STANDARD AND EXTENDED Z}\label{ZStandardAndExtendedZ}
% want to show bar, box and subscription characters throughtout this file:
{\ShowBars
\ShowBoxes
\def\Us#1{\hbox{\underbar{{\footnotesize\tt#1}}}}
\def\Ax{\Us{AX}}
\def\Sch{\Us{SCH}}
\def\Bar{\Us{BAR}}
\def\SuchThat{\Us{ST}}
\def\Is{\Us{IS}}
\def\Semi{\Us{END}}
\def\SQuote{{\hbox{\tt\char'015}}}
\def\DQuote{{\hbox{\tt\char'042}}}
\def\NT#1{{\footnotesize[#1]}}
% pro tem need to define the free type brackets here:
\def\lchevron{\MMM{{<}\mkern-8mu{<}}}
\def\rchevron{\MMM{{>}\mkern-8mu{>}}}

The \ProductZ\ language is an extension of an approximation to
the Z language of the ongoing standardisation activity for Z.
In this document the term {\em extended Z} is used to refer to the
full \ProductZ\ language, and the term {\em standard Z} for the subset which
approximates the language of the standard.

Normally, the \Product\ parser and type checker prohibit the
use of non-standard features within the paragraphs of a specification
but allow them within predicates and expressions entered as
term quotations (see \ref{ZEnteringSpecification} and \ref{ZGrammar} below).
(This default behaviour may be modified by changing the settings of
the system control flags
=INLINEFT
standard_z_paras
=TEX
\ and
=INLINEFT
standard_z_terms
=TEX
.)

The main differences between standard and extended Z are as follows;

\begin{itemize}
\item
Extended Z is higher-order, in effect the \ProductHOL\ type, 
=INLINEFT
îBOOLÆ
=TEX
, of truth values acts as a given set, so removing the
distinction between the syntactic categories of predicates and expressions
in standard Z. In particular, in extended Z, one can state and prove
theorems involving propositional variables.
\item
Nested term quotations are allowed in extended Z, permitting mixed
language working.
\end{itemize}

\section{ENTERING A Z SPECIFICATION}\label{ZEnteringSpecification}
% want to show subscription characters in this section
{\ShowScripts
A \ProductZ\ is presented as a \LaTeX\ document using
the facilities described in \cite{DS/FMU/IED/USR001} and
familiarity is assumed in what follows with the use of the extended character
set discussed in that document.

The lexical rules for \ProductZ\ are defined in section \ref{ZLexicalAnalysis} in
terms of the slightly abstract view of the Z character
set shown in table \ref{ZCharacterSetTable}. Each of these characters may
be entered into a \ProductZ\ document or into the
\Product\ system using a single key-stroke with the following exceptions:


\begin{itemize}
\item
The free type chevrons,``%
=INLINEFT
%lchevron%
=TEX
'' and ``%
=INLINEFT
%rchevron%
=TEX
'' are entered as \verb"%lchevron%" and \verb"%rchevron%".
\item
A calligraphic letter such as ``%
=INLINEFT
%calM%
=TEX
'' is entered as \verb"%calM%".
\item
Most of the additional symbols from the \LaTeX\ manual mentioned under $Symbol$ 
are entered by enclosing the alphabetic part of the \LaTeX\
name in percent characters. E.g. the infinity symbol, ``%
=INLINEFT
%infty%
=TEX
'', which
is invoked by the macro \verb"\infty" in \LaTeX, is entered as
\verb"%infty%". There are some exceptions to this rule, mainly
because \LaTeX\ has more than one name for some of the symbols.
The exceptions are listed in the file \verb"sievekeyword"
provided in the subdirectory \verb"sun3bin" or
\verb"sun4bin" of the installation directory.
\item
A character is entered as a subscript by preceding it with
the character â.
\item
{\ShowBoxes
The $Box$ characters are entered simply by laying the box out as formal
Z material in the sense of \cite{DS/FMU/IED/USR001}. 
Note that the paragraph forms which do not use a box, namely, fixity
paragraphs, give set definitions abbreviation definitions
and free type definitions, must be preceded by a line containing
the two characters ``$πZ$'' and followed by a line containing
the single character ``∞''. Boxes beginning with ``ˇ'' or ``ù'' must be
terminated with a line beginning ``à'' (not ``∞'').
}
\end{itemize}

The paragraph forms behave like ML functions executed at the top-level
for their side-effects (and the formatting directive characters which terminate
the boxes implicitly insert the semi-colon required to cause the
function to be executed by the ML compiler after them).

Z term quotations, see section \ref{ZGrammar} below,
are entered bracketed with the characters Ò and 
 Æ, for example,
=INLINEFT
Òß1, 2, 3¢Æ
=TEX
.
Z term quotations
behave like ML functions executed for their result value.



As described in \cite{DS/FMU/IED/USR001}, the normal effect of the
characters Á and Í is to begin and end sections of superscripted text.
Thus, for example, the name of the iteration operation is ``%
=INLINEFT
_ Á _ Í
=TEX
'', so that, something entered as
=INLINEFT
R Á i Í
=TEX
\ prints as $R\,\sp{i}$.

\begin{table}
\centering
\begin{tabular}{|l|l|}\hline
=INLINEFT
€Letter›
=TEX
&
\begin{tabular}{*{12}{p{0.4in}@{}}}
A &	B &	C &	D &
E &	F &	G &	H &
I &	J &	K &	L \\
M &	N &	O &	P &
Q &	R &	S &	T &
U &	V &	W &	X \\
Y &	Z\\
a &	b &	c &	d &
e &	f &	g &	h &
i &	j &	k &	l \\
m &	n &	o &	p &
q &	r &	s &	t &
u &	v &	w &	x \\
y &	z \\
\end{tabular}
\\\hline
=INLINEFT
€GreekLetter›
=TEX
&
\begin{tabular}{*{12}{p{0.4in}@{}}}
¡ &	¬ &	« &	ƒ &
≈ &	⁄ &	» &	  &
… &	À &	Ã &	Õ \\
Œ &	ÿ &	 &	– &
“ &	” &	‘ &	’ &
∆ &	— &	Ÿ &	◊ \\
 &	 &	á &	Ñ &
 &	 &	 &	ä &
 &	 &	å &	  \\
 &	ò &	 &	ê &
 &	ì &	 &	ï &
Ü &	 &	ô &	ó \\
\end{tabular}
\\\hline
=INLINEFT
€Digit›
=TEX
&
\begin{tabular}{*{12}{p{0.4in}@{}}}
0 &	1 &	2 &	3 &	4 &	5 &	6 &	7 &	8 &	9\\
\end{tabular}
\\\hline
=INLINEFT
€Symbol›
=TEX
&
\begin{tabular}{*{12}{p{0.4in}@{}}}
¿ &	° &	ﬁ &	• &
Ä &	† &	ö &	é &
® &	© &	· &	Å \\
Ú &	í &	Ù &	ª &
´ &	ﬂ &	≠ &	˛ &
‡ &	œ &	Ô &	è \\
™ &	º &	æ &	$<$ &
$>$ &	Î &	ã &	Ω &
$+$ &	$-$ &	$*$ &	\# \\
$.$ &	$\sim$ &	Ç & 	˚ &
˝ &	$/$ &	$\backslash$  &	\leavevmode\_ &
% the \leavevmode above defeats a bizarre LaTeX problem.
± &	≤ &	≥ &	¥ \\
§ &	$=$ &	ç &	µ &
∂ &	∏ &	¶ &	\& &
?Ù &	ª &	˘ &	∫ \\
\multicolumn{12}{p{4.8in}}{and the calligraphic letters and any other symbols from tables 3.4, 3.5, 3.6 and 3.7 of
the  \LaTeX\ User's Guide and Reference Manual, \cite{Lamport86}} \\
\end{tabular}
\\\hline
=INLINEFT
€Stop›
=TEX
&
\begin{tabular}{*{12}{p{0.4in}@{}}}
$,$ &	$;$ &	$:$ &	$($ &
$)$ &	Ê &	Ó &	 &
˙ &	$[$ &	$]$ &	$\{$ \\
$\}$ &	$ß$ &	$¢$ &	∑ &
=INLINEFT
%lchevron%
=TEX
&
=INLINEFT
%rchevron%
=TEX
 & $\vert$ &	$::=$ \\
\end{tabular}
\\\hline
=INLINEFT
€Underscore›
=TEX
&
\begin{tabular}{*{12}{p{0.4in}@{}}}
$\_$ \\
\end{tabular}
\\\hline
=INLINEFT
€Stroke›
=TEX
&
\begin{tabular}{*{12}{p{0.4in}@{}}}
$'$ &	$?$ &	$!$\\
\end{tabular}
\\\hline
=INLINEFT
€Subscript›
=TEX
& Subscripted forms of any of the above characters.
\\\hline
=INLINEFT
€Shift›
=TEX
&
\begin{tabular}{*{12}{p{0.4in}@{}}}
Á &	Í &\\
\end{tabular}
\\\hline
=INLINEFT
€Box›
=TEX
&
\begin{tabular}{*{12}{p{0.4in}@{}}}
\Ax &	\Sch &	\Semi &	\Is &	\SuchThat&	\Bar\\
\end{tabular}
\\\hline
=INLINEFT
€Quote›
=TEX
&
\begin{tabular}{*{12}{p{0.4in}@{}}}
\DQuote &\\
\end{tabular}
\\\hline
=INLINEFT
€Format›
=TEX
& A format character such as space, tab, line-break or page-break.
\\\hline
\end{tabular}
\caption{Character Set}\label{ZCharacterSetTable}
\end{table}


} % Matches the brace at the beginning of this section
% From now on want to see subscripts as subscripts.
\newpage
\section{LEXICAL ANALYSIS}\label{ZLexicalAnalysis}
\paragraph{Token} A {\em token} is a sequence of characters,
as shown in table~\ref{ZCharacterSetTable}, conforming to the
grammar given in this section. The terminal symbols of
the grammar are the sets of characters
defined in the table, and the sentence symbol is $Token$.
The different sorts of token correspond to the sorts of terminal
symbols of the grammar for Z given in section \ref{ZGrammar}, together with an extra sort of space
tokens.

A sequence of characters is interpreted as a sequence of non-space tokens
by a left-to-right scan taking tokens which are as long as
possible and then discarding any $Space$ tokens.
If it is not
possible to do this then the sequence of characters is erroneous.

ProofPower-Z supports inline comments within both paragraphs
and terms. These comments follow
the same rules as for comments in \ProductHOL\ and \ProductML.

As an extension to Z, quotation of HOL terms (perhaps using the HOL parser
or the parser for some other language) is allowed.

=GFT BNF
	€Token›		=	Identifier
			|	Decor
			|	Narrative
			|	Number
			|	String
			|	Punctuation
			|	Quotation
			|	Space;
=TEX

	

\paragraph{Identifier} There are three sorts of identifier:
=GFT BNF
	€Identifier›	=	Alphanumeric
			|	Greek
			|	Symbolic;

	€Alphanumeric›
			=	Letter, {Letter | Digit | (`_`, (Letter | Digit)}), {Subscript};

	€Greek›		=	GreekLetter, {subscript};

	€Symbolic›	=	(Symbol | Shift), {(Symbol | Shift)}, {Subscript}
			|	Punctuation, Subscript, {Subscript};
=TEX

=TEX
\paragraph{Decoration} Decoration comprises just a sequence of stroke characters
=GFT BNF
	€Decor›		=	Stroke, {Stroke};
=TEX


\paragraph{Numbers} A numeric literal is a non-empty sequence of decimal digits
=GFT BNF
	€Number›	=	Digit, {Digit};
=TEX
Negative numeric literal values may be obtained by applying the negation
operator to a numeric literal using the above syntax.
\paragraph{Strings}
A string literal denotes a sequence of arbitary text.
String literals conform to the same syntax as HOL string literals as defined
in \cite{DS/FMU/IED/DEF001}, which follows Standard ML.
=GFT BNF
	€String›		=	`%DQuote%`, {StringItems}, `%DQuote%`;
	€StringItems›	=	? As in Standard ML ?;
=TEX
\paragraph{Narrative} The means for delimiting the narrative sections between
formal material in a Z document is defined in \cite{DS/FMU/IED/USR001}:
=GFT BNF
	€Narrative›	= 	? See Document Preparation User Guide ?
=TEX
\paragraph{Punctuation} This kind of token includes the stop and box characters
of section~\ref{ZCharacterSet} symbols and an underscore on its own.
=GFT BNF
	€Punctuation›	=	Stop
			|	Box
			|	`_`;
=TEX
\paragraph{Quotation} A quotation must be a term valued quotation .
E.g. an HOL type quotation is not allowed, while an HOL term
quotation is.
=GFT BNF
	€Quotation›	=	? A term valued quotation ?;
=TEX
\paragraph{Space} A space token is a sequence of one or more white space characters or a comment.
=GFT BNF
	€Space›		=	Format, {Format}
			|	Comment;
=TEX
Comments follow the syntax for comments in Standard ML:
=GFT BNF
	€Comment›	=	? As in Standard ML ?;
=TEX
=TEX
\newpage
\section{GRAMMAR}\label{ZGrammar}
The following grammar defines two languages over the set of all non-space
tokens as defined in section \ref{ZLexicalAnalysis}.
The languages are the language of Z specifications corresponding to
the non-terminal $Specification$ in section \ref{ZSpecification}
and the language of Z terms corresponding to
the non-terminal $Term$ in section \ref{Term}. The language of terms
is, in a sense, an extension to standard Z permitting entry of Z constructs
needed as parameters to proof procedures etc.

The specific terminal symbols of the grammar are the punctuation symbols
and reserved identifiers listed below.

=GFT Punctuation
	``	`:`	`;`	`\`	`(`	`)`	`[`	`]`	`{`	`}`	`ß`	`¢`
	`%lchevron%`	`%rchevron%`	`∑`	`_`	`::=`	`%Ax%`	`%Sch%`	`%Semi%`	`%Is%`	`%SuchThat%`	`%Bar%`
=TEX
=GFT Reserved Identifiers
	`∂â1`	` `	`Ã`	`Õ`	`Ñ`	`ò`	`.`	`...`	`>>`	`§`	`±`	`≤`
	`≥`	`¥`	`µ`	`∂`	`|`	`∏`	`&`	`,`	`/`	`ç`	`=`	`¶`
	`?Ù`	`˘âs`	`ªâs`	`\âs`
	`false`	`fun`	`gen`	`pre`	`rel`	`true`
=TEX

The only difference between punctuation symbols and reserved identifiers
is that the former are not identifiers according to the lexical rules
given in section \ref{ZLexicalAnalysis} whereas the latter are. The grammar
prohibits attempts to use the reserved identifiers as variables.

The general terminal symbols of the grammar are as shown in
table \ref{TerminalSymbols}.

\begin{table}[h]
\centering
\begin{tabular}{|l|l|}\hline
Symbol & Description \\\hline
$Id$ & Identifier other than the reserved identifiers\\\hline
$Decor$ & A sequence of decoration characters\\\hline
$Narrative$ & Narrative text.\\\hline
$Number$ & Numeric literal\\\hline
$Character$ & Character literal\\\hline
$String$ & String literal\\\hline
$Narrative$& Informal text\\\hline
\end{tabular}
\caption{Terminal Symbols for the Grammar} \label{TerminalSymbols}
\end{table}


\subsection{Specification}\label{ZSpecification}
A specification comprises a sequence of {\em paragraphs} interleaved
with narrative text
=GFT BNF
	€Specification›	=	[Narrative], {Paragraph, Narrative}, [Paragraph];
=TEX
\subsection{Paragraphs}
A paragraph takes one of 7 forms:
=GFT BNF
	€Paragraph›	=	Fixity
			|	GivenSet
			|	AbbDef
			|	FreeTypeDef
			|	AxBox
			|	Constraint
			|	Conjecture;
=TEX
\subsection{Term}\label{Term}
This non-terminal is an extension to Z enabling expressions, predicates
and schemas to be supplied as parameters to proof procedures etc.

A term comprises a Z predicate (which, in extended Z, includes
expression and schema) together with optional generic parameters.
=GFT BNF
	€Term›	=	[GenFormals], Pred;
=TEX
Note that the above is actually the same as the $Constraint$ paragraph.
No ambiguity arises because of the use of different beginning and end markers
for the two forms as described in section~\ref{ZEnteringSpecification} above.
\subsection{Fixity Paragraph}
A fixity paragraph describes syntactic abbreviations which are to be used
in the specification. The constructs which can be abbreviated are application
of a function to a tuple of arguments, explicit instantation of a generic constant
and the membership predicate. These three possibilities are given by
the $fun$, $gen$ and $rel$ options in the following, in which
the $Number$ gives a numeric precedence for the abbreviations being
described. Omitting the $Number$ is equivalent to supplying it as $0$.

=GFT BNF
	€Fixity›		=	`fun` , [Number], Template, {`,`, Template}
			|	`gen`, [Number], GTemplate, {`,`, Template}
			|	`rel`, Template, {`,`, Template};
=TEX
A template has the form of a sample use of the abbreviation with placeholders
for the arguments. The placeholders are either `$\_$', corresponding to an argument
position where a single expression is expected, or `$...$', corresponding to
an argument position requiring a list of expressions (a possibility which
does not arise in $gen$ fixity paragraphs).
=GFT BNF
	€Template›	=	([`_`], {Id, (`_` | `...`)}, Id, [`_`]) - Id;

	€GTemplate›	=	([`_`], {Id, `_`}, Id, [`_`]) - Id;
=TEX


The syntactic abbreviations introduced by a fixity paragraph are in
force throughout the entire specification containing them.
The following rules apply to the identifiers which appear in
a template:

\begin{enumerate}
\item the first and last identifiers in the template must not appear
anywhere in any other template in any fixity paragraph
in the specification, unless that template
introduces exactly the same syntactic abbreviation.
\item identifiers other than the first and last in the template must
not appear as the first, or last, identifier in any template in the
specification.
\end{enumerate}

We use the term {\em fancy-fix syntax} to refer to
a use of a syntactic abbreviation.

\subsection{Given Set Definition}
A given set definition lists the names of the given sets
being defined, optionally followed by a constraint:
=GFT BNF
	€GivenSet›	=	`[`, DecName, {`,`, DecName}, `]`, [`&`, Constraint];
=TEX
\subsection{Abbreviation Definition}
=GFT BNF
	€AbbDef›	=	EqDef
			|	SchemaBox;

	€EqDef›		=	DefLhs, `¶`, Expression;

	€SchemaBox›	=	%Sch%, DefLhs, %Is%, Decl, [%SuchThat%, Pred], %Semi%;

	€DefLhs›	=	([VarName], {Id, VarName}, IdDec, [VarName]) - Id
			|	VarName, [GenFormals];

	€GenFormals›	=	`[`, DecName, {`,`, DecName}, `]`;
=TEX
An instance of the first alternative for $DefLhs$ must match
some template in some $gen$ fixity paragraph in the specification, in the
sense that the template results if we delete any decoration from the $DefLhs$
and replace each $VarName$ in it by `$\_$'.

\subsection{FreeType Definition}
In a free type definition, constructors which appear in a $fun$ fixity
paragraph may be written using fancy-fix syntax:
=GFT BNF
	€FreeTypeDef›	=	DecName, `::=`, Branch, {, `|`, Branch}, [`&`, FreeTypeDef];

	€Branch›	=	([FreeTypePar], {Id, FreeTypePar}, IdDec, [FreeTypePar])
			|	VarName, [FreeTypePar];

	€FreeTypePar›	=	`%lchevron%`, Expr, `%rchevron%`;
=TEX
We say that the first alternative for a branch matches a template if the template
may be obtained from the branch by deleting any decoration and replacing each
$FreeTypePar$ by
=INLINEFT
`...`
=TEX
\ or
=INLINEFT
`_`
=TEX
.
Each branch construed under the first alternative for $Branch$
must match some template in some $fun$ fixity paragraph
in the specification.


\subsection{Axiomatic Box}
An axiomatic box has an optional list of generic formal parameters
a declaration and an optional predicate.
=GFT BNF
	€AxBox›	=	%Ax%, [GenFormals, %Bar%], Decl, [%SuchThat%, Pred], %Semi%;
=TEX

\subsection{Constraint}
A constraint may optionally start with a list of generic formal parameters. 
=GFT BNF
	€Constraint›	=	[GenFormals], Pred;
=TEX
There is an ambiguity between this rule and the second alternative
of the rule for the non-terminal $Expr3$, since a phrase of the
form $[X]Y$ could be interpreted either as a constraint with generic
formals $[X]$ or as a phrase beginning
with an application of a horizontal schema expression
to $Y$. The former interpretation is to be preferred (and, indeed, the
second interpretation cannot be well-typed).


\subsection{Conjecture}
A conjecture comprises an optional label, an optional list of
formal parameters and a predicate. A conjecture is purely for
documentary purposes and has no effect on the abstract syntax form
of the specification.
=GFT BNF
	€Conjecture›	=	[Id], `?Ù`, [GenFormals], Pred;
=TEX
As with $Constraint$ there is an ambiguity
between this rule and the second alternative
of the rule for the non-terminal $Expr3$.
The interpretation as a generic conjecture rather than as a phrase beginning
with an application of a horizontal schema expression is to be preferred.
\subsection{Declaration}
A declaration is a sequence of basic declarations each of which is
either an explicit declaration of a list of variables ranging over
some set or a schema-as-declaration.
=GFT BNF
	€Decl›		=	BasicDecl, {`;`, BasicDecl};

	€BasicDecl›	=	DecName, {`,`, DecName}, `:`, Expr
			|	Schema;
=TEX
\subsection{Schema}\label{Schema}
The syntax for schema-expressions is as follows:

=GFT BNF
	€Schema›	=	Schema2
			|	Quant, SchemaText, `∑`, Schema;

	€Quant›		=	`µ` | `∂` | `∂â1`;

	€Schema2›	=	Schema3
			|	Schema2, SchInOp, Schema2;

	€SchInOp›	=	`±` | `≤` | `¥` | `§` | `˘âs` | `ªâs`;

	€Schema3›	=	Schema4
			|	SchPreOp, Schema3;

	€SchPreOp›	=	`≥` | `pre` | `Ñ` | `ò`;

	€Schema4›	=	Expr
			|	Schema4, [RenameList]
			|	`[`, SchemaText, `]`				(* Schema4.A *)
			|	Schema4, `\âs`, `(`, DecName, {`,`, DecName}, `)`;

	€RenameList›	=	`[`, DecName, `/`, DecName, {`,` DecName, `/`, DecName}, `]`;
=TEX
The grammar for $Schema2$ is ambiguous.
The ambiguities are resolved by taking the alternatives
for $SchInOp$ as listed in decreasing order of precedence and taking
each $SchInOp$ as right associative.


\subsection{Schema Text}
=GFT BNF
	€SchemaText›	=	Decl, [ `|`, Pred ];
=TEX
\subsection{Predicate}\label{ZPredicate}
The syntax for predicate is as follows. Note that a schema-expression,
and so an arbitrary expression, is one of the possibilities for a predicate.
=GFT BNF
	€Pred›		=	Pred1, { `;`, Pred1 }


	€Pred1›		=	Pred2
			|	Quant, SchemaText, `∑`, Pred1;

	€Pred2›		=	Pred3
			|	Pred2, LogInOp, Pred2;

	€LogInOp›	=	`±` | `≤` | `¥` | `§`;

	€Pred3›		=	Pred4
			|	`≥`, Pred3;
	
	€Pred4›		=	Expr, Rel, Expr {Rel, Expr}			(* Pred4.A *)
			|	([Expr], {Id, Exprs}, Id, [Expr])
				- (Id | (Expr, Id, Expr))			(* Pred4.B *)
			|	Schema
			|	`true`
			|	`false`
			|	`(`, Pred, `)`;

	€Rel›		=	Id | `ç` | `=`;


=TEX
The grammar for predicates is ambiguous.
The ambiguities are resolved by imposing the following rules:

\begin{enumerate}
\item
The operators in the production
for $LogInOp$ are listed in decreasing order of precedence,
and are right associative.
\item
In $Pred4.A$ the $Id$ in each $Rel$ must appear in a template of
the form $\_Id\_$ in a $rel$ fixity paragraph.
\item
The alternative $Pred4.B$ is only allowed when the resulting phrase matches a template
in a $rel$ fixity paragraph
in the specification. Here the phrase is said to match a template if the template can
be obtained from it by 
replacing each direct constituent $Expr$ in the phrase by `$\_$' and
replacing each direct constituent
$Exprs$ by `$...$'.

\item
Negation is to have higher precedence than the infix schema operators
of section \ref{Schema}
\item
A phrase which can be construed both as a $Pred$ and a $Schema$ should
be construed as a $Pred$, unless this makes some enclosing phrase
impossible to construe.
\end{enumerate}


\subsection{Expression}\label{Expression}
The syntax for expressions is as follows. Note that a predicate
in brackets is one of the alternatives for expressions.
This is because extended Z is higher-order not first-order.
Except in extended Z, such a predicate must actually take the schema alternative
of $Pred4$, reflecting the fact that standard Z is first-order.
=GFT BNF
	€Expr›		=	Expr0;

	€Expr0›		=	Expr1
			|	`Õ`, SchemaText, `∑`, Expr
			|	`Ã`, SchemaText, `∑`, Expr;

	€Expr1›		=	Expr2	
			|	([Expr1], {Id, Exprs}, Id, [Expr1]) - Id;	(* Expr1.A *)
			|	Expr1, `∏`, Expr1, {`∏`, Expr1};			(* Expr1.B *)

	€Expr2›		=	Expr3	
			|	``, Expr2;

	€Exprs›		=	[Expr, {`,`, Expr}];

	€Expr3›		=	Expr4
			|	Expr3, Expr4
			|	` `, Expr4, [Decor];

	€Expr4›		=	VarName, [GenActuals]
			|	Literal
			|	Quotation
			|	`(`, Pred, `)`
			|	`(`, Schema, `)`, [Decor]
			|	`(`, `Õ`, SchemaText, `)`
			|	`(`, Expr, {`,`, Expr}, `)`
			|	Schema
			|	`(`, EqDef, {`,` EqDef}, `)`
			|	`ß`, [Expr, {`,`, Expr}], `¢`
			|	`{`, [Expr, {`,`, Expr}], `}`				(* Expr4.A *)
			|	`{`, SchemaText, [`∑`, Expr], `}`			(* Expr4.B *)
			|	Expr4, `.`, VarName;
			|	Expr4, `.`, Number;

	€GenActuals›	= `[`, Expr, {`,`, Expr}, `]`;

	€Literal›	= 	Number | Character | String;

=TEX
The third alternative for $Expr4$ here is part of extended Z and is not allowed in
standard Z.

The grammar for expressions is ambiguous, the ambiguities are to be resolved using the following rules.

\begin{enumerate}
\item
The alternative $Expr1.A$ is only allowed when the resulting phrase matches a template
in a $gen$ or $fun$ fixity paragraph
in the specification. Here the phrase is said to match a template if the template can
be obtained from it by
replacing each direct constituent $Expr$ in the phrase by `$\_$' and
replacing each direct constituent
$Exprs$ by `$...$'.
(In extended Z, $Expr1.A$ is also allowed when the phrase matches a template
in a $rel$ fixity paragraph.)
\item
The precedences in the fixity paragraphs give the precedence to apply
for a phrase which can be interpreted in 
two ways using $Expr1.A$.
(In extended Z, a $rel$ fixity paragraph should be treated as having fixity $0$).
\item
If a phrase has two interpretations under $Expr1.A$ with the same template,
then the right-associative interpretation is
to be taken.
\item
A phrase of the form $\{S\}$ where $S$ is a $Name$ could be
interpreted as a set display ($Expr4.A$) or as a set comprehension
($Expr4.B$). The set display is to be preferred.
\item
A phrase of the form $V[S]$ where $V$ is a $Name$ could be
interpreted as a generic instantiation ($Expr4.A$) or as application
of $V$ to a horizontal schema
($Schema4.A$). The generic instantiation is to be preferred.
\item
A phrase which can be construed both as a $Schema$ and an $Exp$ should
be construed as an $Exp$, wherever possible (this is not a source of
semantic ambiguity).

\item
In extended Z, the ambiguity between the fourth and fifth alternatives of
$Expr4$ is to be resolved in favour of the former (there is no semantic
ambiguity here).
\end{enumerate}

\subsection{Casts}

The identifier `%
=INLINEFT
_ ∫ _
=TEX
' is defined in the library of \Product\ theories
which support \ProductZ\ using the following two paragraphs;
however, it is treated specially by the parser and type checker.

πIZ
 	fun	_ ∫ _
=TEX
ù[X]
	_ ∫ _ : X ∏  X ≠ X
˜
	(_ ∫ _) = first
à

`%
=INLINEFT
_ ∫ _
=TEX
' is an operator which acts as a type cast,
i.e., it ensures that its left operand has the same type
as the elements of its second operand and it takes the same value as
its left operand. This is intended for use during
proof when it is necessary to enter
Z expressions which do not contain enough information to
fix the types of all their sub-expressions. For this reason, an expression
of the form
=INLINEFT
x ∫ s
=TEX
\ is treated as identical with $x$, except that during type-checking
the type constraints imposed by the above definition of `%
=INLINEFT
_ ∫ _
=TEX
' are enforced.


In entering Z terms, one occasionally needs to 
provide a syntactic context where an expression is permitted
but a predicate is not allowed in order that the last of
the disambiguation rules of section \ref{ZPredicate}
will force an operation to be taken as a schema operation.
The left-hand operand of `%
=INLINEFT
_ ∫ _
=TEX
' supplies such a context.
For example,
=INLINEFT
Ò[x:˙] ± [x:˙]Æ
=TEX
\ is a predicate conjunction, whereas
=INLINEFT
Ò([x:˙] ± [x:˙]) ∫ UÆ
=TEX
\ is a schema conjunction.

If for some reason, it is necessary to construct a Z term which actually
has `%
=INLINEFT
_ ∫ _
=TEX
' as a sub-term, this may be done by not using the fancy-fix
notation, for example,
while
=INLINEFT
Ò1 ∫ ˙Æ
=TEX
\ is just the same as
=INLINEFT
Ò1Æ
=TEX
,
=INLINEFT
Ò(_∫_)(1, ˙)Æ
=TEX
\ really is an application of
=INLINEFT
Ò(_∫_)Æ
=TEX
\ to the pair
=INLINEFT
Ò(1,˙)Æ
=TEX
.
\subsection{Names}\label{Names}
=GFT BNF
	€VarName›		=	IdDec
			|	`(`, (([`_`], {Id, (`_` | `...`)}, IdDec, [`_`]) - IdDec), `)`;
=TEX
=GFT BNF
	€DecName›		=	IdDec
			|		(([`_`], {Id, (`_` | `...`)}, IdDec, [`_`]) - IdDec);
=TEX
In the first alternative in both of these productions the $Id$ in the $IdDec$
must not appear in any fixity
paragraph in the specification. In the second alternative the result of deleting
any decoration must make the phrase between the brackets the same as some
template in some fixity paragraph in the specification.



=GFT BNF
	€IdDec›		=	Id, [Decor];
=TEX
} % matches the brace at the head of the file.
