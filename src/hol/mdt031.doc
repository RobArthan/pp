% mdt031.doc   %Z% $Date$ $Revision$ $RCSfile$

=TEX
% mdt031.doc   %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol1,11pt,TQ]{article}

\TPPtitle{Module Tests for Pretty Printer Support Structure}
\TPPref{DS/FMU/IED/MDT031}
\def\SCCSissue{$Revision$%
}
\TPPissue{\SCCSissue}
\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{FST PROJECT}

=IGN

Commands to process this document in various ways.

docsml mdt031
use_file "mdt031.sml";

make -f rel001.mkf mdt031.dvi
doctex mdt031
texdvi mdt031
bibtex mdt031
doctex mdt031 ; texdvi mdt031
doctex mdt031 ; texdvi mdt031 ; bibtex mdt031
dvipage mdt031 &

docsml mdt031
use_file "mdt031.sml";

=TEX
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{SML Literate Script}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the module tests for the ICL~HOL
	Pretty Printer Support Structure.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

%********************************************************************

\subsection{Contents List}
\tableofcontents
% \listoftables

%********************************************************************

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

%********************************************************************

\subsection{Changes History}

\begin{description}

\item[Issues 1.1 to 1.3] Initial drafts.

\item[\FormatDate{91/09/12}, issue 2.1 ] First approved version.

\item[Issue 2.2, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 2.3 (14th April 1992)]
Changes required by CR0017.

\item[\FormatDate{$Date$%
	}, issue \SCCSissue~]
	Add checks on depth fields in $PP_ENV$. {}
	Test the language choice functions.

%\item[\FormatDate{$Date$%
%}, issue \SCCSissue~]

\end{description}

%********************************************************************

%\subsection{Changes Forecast} \label{ChangesForecast}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the module tests for the pretty printing support
routines for the ICL HOL system which are discussed
in~\cite{DS/FMU/IED/DTD031}.  The tests use the module testing system
of~\cite{DS/FMU/IED/DTD013} and~\cite{DS/FMU/IED/IMP013}.

%********************************************************************

\subsection{Introduction}

\subsubsection{Purpose and Background}

To test the simple functional interfaces of the pretty printing support
routines.

\subsubsection{Deficiencies}

As described in the test policy for this module
(in~\cite{DS/FMU/IED/DTD031}) the tests here cover only those functions
that have with simple functional interfaces that can readily be
tested.  Extensive tests of the other interfaces are implicit in the
tests in~\cite{DS/FMU/IED/MDT025}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TEST HARNESS INITIALISATION}

=IGN
Get the test harness files
sccs -d ~ied get dtd013.doc imp013.doc
docsml dtd013
docsml imp013

docsml mdt031
use_file "mdt031.sml";

=TEX

Load and initialise the module test system.

=SML
use_file "dtd013.sml";
use_file "imp013.sml";
new_theory"mdt031";
init_mt_results ();
=TEX

Open the structure;

=SML
open PrettyPrinterSupport;
infix gt_prec;
=TEX

To avoid PolyML problems with comparing values of type unit.

=SML
fun UT () = true;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{PRECEDANCE TESTS}

Tests of function $gt_prec$, locally we set it to nonfix so that the
module test harness is easy to use.

=SML
nonfix gt_prec;

set_flag("pp_add_brackets", false);

store_mt_results_show mt_run[
("gep_1_1f", gt_prec, (PcHighest, PcHighest), false),
("gep_1_2f", gt_prec, (PcHighest, PcNormal(1,1,false)), true),
("gep_1_3f", gt_prec, (PcHighest, PcLowest), true),
("gep_1_4f", gt_prec, (PcHighest, PcVeryLow(32,32,false)), true),

("gep_1_5f", gt_prec, (PcNormal(1,1,false), PcNormal(1,1,false)), false),
("gep_1_6f", gt_prec, (PcNormal(1,1,false), PcLowest), true),
("gep_1_7f", gt_prec, (PcNormal(1,1,false), PcVeryLow(32,32,false)), true),

("gep_1_8f", gt_prec, (PcLowest, PcLowest), false),
("gep_1_9f", gt_prec, (PcLowest, PcVeryLow(32,32,false)), true),

("gep_1_10f", gt_prec, (PcVeryLow(32,32,false), PcVeryLow(32,32,false)), false),

("gep_2_1f", gt_prec, (PcNormal(2,1,false), PcNormal(1,1,false)), true),
("gep_2_2f", gt_prec, (PcNormal(1,2,false), PcNormal(1,1,false)), true),
("gep_2_3f", gt_prec, (PcNormal(1,1,true), PcNormal(1,1,true)), true),

("gep_2_4f", gt_prec, (PcNormal(1,1,false), PcNormal(2,1,false)), false),
("gep_2_5f", gt_prec, (PcNormal(1,1,false), PcNormal(1,2,false)), false)
];

set_flag("pp_add_brackets", true);

store_mt_results_show mt_run[
("gep_1_1t", gt_prec, (PcHighest, PcHighest), true),
("gep_1_2t", gt_prec, (PcHighest, PcNormal(1,1,false)), true),
("gep_1_3t", gt_prec, (PcHighest, PcLowest), true),
("gep_1_4t", gt_prec, (PcHighest, PcVeryLow(32,32,false)), true),

("gep_1_5t", gt_prec, (PcNormal(1,1,false), PcNormal(1,1,false)), true),
("gep_1_6t", gt_prec, (PcNormal(1,1,false), PcLowest), true),
("gep_1_7t", gt_prec, (PcNormal(1,1,false), PcVeryLow(32,32,false)), true),

("gep_1_8t", gt_prec, (PcLowest, PcLowest), false),
("gep_1_9t", gt_prec, (PcLowest, PcVeryLow(32,32,false)), true),

("gep_1_10t", gt_prec, (PcVeryLow(32,32,false), PcVeryLow(32,32,false)), true),

("gep_2_1t", gt_prec, (PcNormal(2,1,false), PcNormal(1,1,false)), true),
("gep_2_2t", gt_prec, (PcNormal(1,2,false), PcNormal(1,1,false)), true),
("gep_2_3t", gt_prec, (PcNormal(1,1,true), PcNormal(1,1,true)), true),

("gep_2_4t", gt_prec, (PcNormal(1,1,false), PcNormal(2,1,false)), true),
("gep_2_5t", gt_prec, (PcNormal(1,1,false), PcNormal(1,2,false)), true)
];

set_flag("pp_add_brackets", false);

infix gt_prec;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{PRINTER FUNCTION CONTROLS}

=SML
let
fun (dummy_fun_cv : PP_ENV -> TERM -> string -> TYPE -> TERM list
	-> PFUN_ANS) _ _ _ _ _ = PfOk;
fun (dummy_Ì : PP_ENV -> TERM -> TERM -> PFUN_ANS) _ _ _ = PfOk;
fun (dummy_app : PP_ENV -> TERM -> TERM list -> PFUN_ANS) _ _ _ = PfOk;
fun (dummy_var_const : PP_ENV -> TERM -> string -> TYPE -> PFUN_ANS) 
	_ _ _ _ = PfOk;

val d_funs = (dummy_Ì, dummy_app, dummy_var_const, dummy_fun_cv,
	dummy_fun_cv, dummy_var_const);
in

store_mt_results_show mt_run[
("sp_1", UT o set_printers, ("junk", d_funs), true)
];

set_flag("ignore_warnings", true);

store_mt_results_show mt_run[
("sp_2", UT o set_printers, ("junk", d_funs), true)
];

set_flag("ignore_warnings", false);

store_mt_results_show mt_run_fail[
("sp_3", set_printers, ("junk", d_funs), gen_fail_msg "set_printers" 31002 ["junk"])
]

end;
=TEX

=SML
store_mt_results_show mt_run[
("eap_1", UT o enable_all_printers, (), true)
];
=TEX

=SML
store_mt_results_show mt_run[
("edp_11", UT o disable_printer, "junk", true),
("edp_12", UT o disable_printer, "junk", true),
("edp_13", UT o enable_printer, "junk", true),
("edp_14", UT o enable_printer, "junk", true),
("edp_15", UT o enable_printer, "HOL", true)
];
=TEX

=SML
store_mt_results_show mt_run_fail[
("edp_21", disable_printer, "lang", gen_fail_msg "disable_printer" 31005 ["lang"]),
("edp_22", disable_printer, "HOL", gen_fail_msg "disable_printer" 31006 nil),
("edp_23", enable_printer, "lang", gen_fail_msg "enable_printer" 31005 ["lang"])
];
=TEX

These tests are normally run when the whole pretty printing suite is
loaded which means that error code~31001 cannot be generated.  As a
consequence there are no useful tests of functions $initial_env$ and
$set_env_for_language$, however we can use them whilst checking other
functions.

=SML
let
val opf : OppenFormatting.OPPEN_FUNS = (fn _ => (), fn _ => (), fn _ => (), fn _ => ());

val init_env = initial_env "absent" Nil opf;

val next_env = set_env_for_language "HOL" init_env;

val e2 = set_prec PcHighest next_env;
val e3 = set_prec PcLowest e2;
val e4 = set_prec (PcNormal(1,1,false)) e3;
val e5 = set_prec (PcVeryLow(32,32,false)) e4;

fun get_prec(PpEnv{pe_prec=p, ...}) = p;
fun get_depth(PpEnv{pe_depth=d, ...}) = d;

val env_Nil = set_depth Nil init_env;
val env_V27 = set_depth (Value 27) init_env;
val env_V26 = decrement_depth env_V27;
val env_Nil_dec = decrement_depth env_Nil;

in

store_mt_results_show mt_run[
("ie_1", get_prec, e2, PcHighest),
("ie_2", get_prec, e3, PcLowest),
("ie_3", get_prec, e4, PcNormal(1,1,false)),
("ie_4", get_prec, e5, PcVeryLow(32,32,false))
];

store_mt_results_show mt_run[
("ie_5", get_depth, env_Nil, Nil),
("ie_6", get_depth, env_V27, Value 27),
("ie_7", get_depth, env_V26, Value 26),
("ie_8", get_depth, env_Nil_dec, Nil)
]

end;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TERM ACCESSING}

=SML
let
val gfc_1 = ¬if a then b else c®;
val gfc_2 = ¬let a = b in c®;
val gfc_3 = ¬Ì a · if a then b else c®;
val gfc_4 = ¬Ì a · let a = b in c®;
val gfc_5 = ¬µ a · if a then b else c®;
val gfc_6 = ¬µ a · let a = b in c®;
val gfc_7 = ¬T®;

in

store_mt_results_show mt_run[
("gfc_1", get_first_const, gfc_1, Value "Cond"),
("gfc_2", get_first_const, gfc_2, Value "Let"),
("gfc_3", get_first_const, gfc_3, Nil),
("gfc_4", get_first_const, gfc_4, Nil),
("gfc_5", get_first_const, gfc_5, Value "µ"),
("gfc_6", get_first_const, gfc_6, Value "µ"),
("gfc_7", get_first_const, gfc_7, Value "T")
]

end;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{LANGUAGE NAMES}

First some initialisations.

We need to have several languages and have constants `claiming' to be
of those languages.

Declare local names for constants, languages and terms.  Use first
letter of `C'~for the constants, `L'~for the languages and `T'~for the
terms.

=SML
val CT = "T";
val CA = "±";
val CM = "";

val LH = "HOL";
val LZ = "Z";
val LW = "WW";
val LX = "XXX";

val TT = ¬ T ®;
val TA = ¬ a ± b ®;
val TM = ¬ c  d ®;
=TEX

=SML
let
fun set_lang(lang:string, names:string list) : string OPT list = (
	(map	(fn s => (	declare_const_language(s, lang);
				Nil
			) handle _ => Value s
		)
		names
	) drop is_Nil
);

in

store_mt_results_show mt_run[
("ln_init_01", set_lang, (LZ, [CT, "´"]), nil),
("ln_init_02", set_lang, (LW, [CT, CA]), nil),
("ln_init_03", set_lang, (LX, [CT, CM]), nil)
]
end;
=TEX

=SML
(* HERE *)
fun ccl (set_lang:string) (const:string, prefs:string list) : string = (
	set_current_language set_lang;
	choose_const_language(const, prefs)
);

fun cct (set_lang:string) (tm:TERM, prefs:string list) : string = (
	set_current_language set_lang;
	choose_term_language(tm, prefs)
);
=TEX

=SML
fun do_test(lab, ff, lang, (input, input_list), exp_ans) = (
	let
		val act_ans = ff lang (input, input_list)
	in
		if act_ans <> exp_ans
		then
			diag_line(	lab
				^	":  set="
				^	lang
				^	"   with "
				^	(format_list Combinators.I input_list "+")
				^	"   exp_ans="
				^	exp_ans
				^	"   act_ans="
				^	(ff lang (input, input_list))
			)
		else ()
	end;
	(lab, ff lang, (input, input_list), exp_ans)
);

=TEX

=SML
store_mt_results_show mt_run(map do_test [
("lnl_001", ccl, LZ, (CT, nil), LZ),
("lnl_002", ccl, LZ, (CT, LH::nil), LH),
("lnl_003", ccl, LZ, (CT, LZ::nil), LZ),
("lnl_004", ccl, LZ, (CT, LH::LZ::nil), LH),
("lnl_005", ccl, LZ, (CT, LZ::LH::nil), LZ),

("lnl_011", ccl, LH, (CT, nil), LH),
("lnl_012", ccl, LH, (CT, LH::nil), LH),
("lnl_013", ccl, LH, (CT, LZ::nil), LZ),
("lnl_014", ccl, LH, (CT, LH::LZ::nil), LH),
("lnl_015", ccl, LH, (CT, LZ::LH::nil), LZ),

("lnl_021", ccl, LW, (CT, nil), LW),
("lnl_022", ccl, LW, (CT, LH::nil), LH),
("lnl_023", ccl, LW, (CT, LZ::nil), LZ),
("lnl_024", ccl, LW, (CT, LH::LZ::nil), LH),
("lnl_025", ccl, LW, (CT, LZ::LH::nil), LZ),

("lnl_101", ccl, LZ, (CA, nil), LH),
("lnl_102", ccl, LZ, (CA, LH::nil), LH),
("lnl_103", ccl, LZ, (CA, LZ::nil), LH),
("lnl_104", ccl, LZ, (CA, LH::LZ::nil), LH),
("lnl_105", ccl, LZ, (CA, LZ::LH::nil), LH),

("lnl_111", ccl, LH, (CA, nil), LH),
("lnl_112", ccl, LH, (CA, LH::nil), LH),
("lnl_113", ccl, LH, (CA, LZ::nil), LH),
("lnl_114", ccl, LH, (CA, LH::LZ::nil), LH),
("lnl_115", ccl, LH, (CA, LZ::LH::nil), LH),

("lnl_121", ccl, LW, (CA, nil), LW),
("lnl_122", ccl, LW, (CA, LH::nil), LH),
("lnl_123", ccl, LW, (CA, LZ::nil), LW),
("lnl_124", ccl, LW, (CA, LH::LZ::nil), LH),
("lnl_125", ccl, LW, (CA, LZ::LH::nil), LH),

("lnl_201", ccl, LZ, (CM, nil), LH),
("lnl_202", ccl, LZ, (CM, LH::nil), LH),
("lnl_203", ccl, LZ, (CM, LZ::nil), LH),
("lnl_204", ccl, LZ, (CM, LH::LZ::nil), LH),
("lnl_205", ccl, LZ, (CM, LZ::LH::nil), LH),

("lnl_211", ccl, LH, (CM, nil), LH),
("lnl_212", ccl, LH, (CM, LH::nil), LH),
("lnl_213", ccl, LH, (CM, LZ::nil), LH),
("lnl_214", ccl, LH, (CM, LH::LZ::nil), LH),
("lnl_215", ccl, LH, (CM, LZ::LH::nil), LH),

("lnl_221", ccl, LW, (CM, nil), LH),
("lnl_222", ccl, LW, (CM, LH::nil), LH),
("lnl_223", ccl, LW, (CM, LZ::nil), LH),
("lnl_224", ccl, LW, (CM, LH::LZ::nil), LH),
("lnl_225", ccl, LW, (CM, LZ::LH::nil), LH)

]);

=SML
store_mt_results_show mt_run(map do_test [
("lnt_001", cct, LZ, (TT, nil), LZ),
("lnt_002", cct, LZ, (TT, LH::nil), LH),
("lnt_003", cct, LZ, (TT, LZ::nil), LZ),
("lnt_004", cct, LZ, (TT, LH::LZ::nil), LH),
("lnt_005", cct, LZ, (TT, LZ::LH::nil), LZ),

("lnt_011", cct, LH, (TT, nil), LH),
("lnt_012", cct, LH, (TT, LH::nil), LH),
("lnt_013", cct, LH, (TT, LZ::nil), LZ),
("lnt_014", cct, LH, (TT, LH::LZ::nil), LH),
("lnt_015", cct, LH, (TT, LZ::LH::nil), LZ),

("lnt_021", cct, LW, (TT, nil), LW),
("lnt_022", cct, LW, (TT, LH::nil), LH),
("lnt_023", cct, LW, (TT, LZ::nil), LZ),
("lnt_024", cct, LW, (TT, LH::LZ::nil), LH),
("lnt_025", cct, LW, (TT, LZ::LH::nil), LZ),

("lnt_101", cct, LZ, (TA, nil), LH),
("lnt_102", cct, LZ, (TA, LH::nil), LH),
("lnt_103", cct, LZ, (TA, LZ::nil), LH),
("lnt_104", cct, LZ, (TA, LH::LZ::nil), LH),
("lnt_105", cct, LZ, (TA, LZ::LH::nil), LH),

("lnt_111", cct, LH, (TA, nil), LH),
("lnt_112", cct, LH, (TA, LH::nil), LH),
("lnt_113", cct, LH, (TA, LZ::nil), LH),
("lnt_114", cct, LH, (TA, LH::LZ::nil), LH),
("lnt_115", cct, LH, (TA, LZ::LH::nil), LH),

("lnt_121", cct, LW, (TA, nil), LW),
("lnt_122", cct, LW, (TA, LH::nil), LH),
("lnt_123", cct, LW, (TA, LZ::nil), LW),
("lnt_124", cct, LW, (TA, LH::LZ::nil), LH),
("lnt_125", cct, LW, (TA, LZ::LH::nil), LH),

("lnt_201", cct, LZ, (TM, nil), LH),
("lnt_202", cct, LZ, (TM, LH::nil), LH),
("lnt_203", cct, LZ, (TM, LZ::nil), LH),
("lnt_204", cct, LZ, (TM, LH::LZ::nil), LH),
("lnt_205", cct, LZ, (TM, LZ::LH::nil), LH),

("lnt_211", cct, LH, (TM, nil), LH),
("lnt_212", cct, LH, (TM, LH::nil), LH),
("lnt_213", cct, LH, (TM, LZ::nil), LH),
("lnt_214", cct, LH, (TM, LH::LZ::nil), LH),
("lnt_215", cct, LH, (TM, LZ::LH::nil), LH),

("lnt_221", cct, LW, (TM, nil), LH),
("lnt_222", cct, LW, (TM, LH::nil), LH),
("lnt_223", cct, LW, (TM, LZ::nil), LH),
("lnt_224", cct, LW, (TM, LH::LZ::nil), LH),
("lnt_225", cct, LW, (TM, LZ::LH::nil), LH)

]);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{SUMMARY OF RESULTS}

=SML
diag_string(summarize_mt_results());
=TEX

\end{document}


