=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Elementary Theory of Arithmetic}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD038}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & HAT Team Leader}
\TPPabstract{
This document contains the detailed design for the elementary
theory of arithmetic for ICL HOL.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issue 1.3 (10 October 1991)]
First draft.
\item [Issue 1.5\ (16 October 1991)]
Corrected definition of subtraction and added a theorem about it.
$Div$ and $Mod$ and subtraction are now all loosely defined.
\item [Issue 1.7 (15 November 1991)] Corrected definition of $>$. Corrected $lt\_trans\_thm$.
\item [Issue \SCCSversion\ (\FormatDate{$Date$%
})] Change names of complete induction material (now called
course-of-values induction). Added theorem about uniqueness of
division and modulus.
\end{description}
\subsection{Changes Forecast}
Theorems on subtraction and on linearity of $<$ and ž
with respect to addition to be added.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the
elementary theory of arithmetic ICL HOL.
The high level design for this material is given in \cite{DS/FMU/IED/HLD011}.

\subsection{Introduction}
This document develops an elementary theory of arithmetic. Here
the subject matter of ``arithmetic'' is taken to be the type ${:}†$
of natural (i.e. non-negative) numbers together with the operations
of addition, subtraction, multiplication and modulus and the usual
ordering relation in its four guises.

The type ${:}†$ is characterised using the successor function $Suc$,
however it is the intention that $Suc$ should be little used
outside this theory, the more natural $+1$ being what is supported
systematically by the theorems provided here.

The theory contains theorems under the following headings:

\begin{itemize}
\item
Peano postulates
\item
primitive recursion theorem
\item
theorems about addition
\item
theorems about subtraction
\item
theorems about $ž$
\item
theorems about $<$
\item
theorems about multiplication
\item
theorems about division and modulus
\end{itemize}

We also give a conversion (allowing reasoning with numeric literals)
and induction tactics and tacticals.

Thus all we have for $>$ and $Ÿ$ are the definitions.
This is deliberate: the definitions
simply turn $>$ and $Ÿ$ around to yield $<$ and $ž$ and the theorems
about these may then be used.
\subsubsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD011}.
\subsubsection{Dependencies}
This document depends on the theory design support
tools in \cite{DS/FMU/IED/DTD035}. The implementation
will depend on the theory of pairs in \cite{DS/FMU/IED/IMP037}
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Deficiencies}
None known.
=TEX
\section{THE THEORY CONTENTS}
\subsection{Theory Name}
=THDOC
req_name "†" (Value "pair");
=DESCRIBE
The theory ``â†á'' contains the definitions
of  the type, ${:}†$, of natural numbers and of
the usual arithmetic operations. It also contains theorems giving
the Peano postulates, the principle of definition by primitive recursion
together with a number of theorems giving elementary properties
of the arithmetic operations.
=ENDDOC
\subsection{Basic Definitions}
=THDOC
req_const ("Is_†_Rep", »:IND ‹ BOOL¼);
req_defn("Is_†_Rep",([], »
	„ zero: IND; suc: IND ‹ INDŽ
		  (Is_†_Rep zero € (ƒ nŽ Is_†_Rep n Š Is_†_Rep (suc n))) €
		  (ƒ nŽ Is_†_Rep n Š Œ suc n = zero) €
		  (OneOne suc) €
		  (ƒ pŽ p zero € (ƒ mŽ p m Š p (suc m)) Š
		  (ƒ nŽ Is_†_Rep n Š p n))
¼));
=DESCRIBE
This is the defining property for the representation of the natural
numbers within the type of individuals. The slight over-specification
of $Suc$ (which need not, in fact, be one-one on the whole type) eases
later proofs slightly and is of no interest to any user of the theory.

Note here and elsewhere in the very early stages of the theory that
we use $OneOne$ for clarity rather than giving an expanded form which is useful
as a rewrite rule. $plus\_clauses$ gives the relevant rewrite rule which
is intended for general use.

=ENDDOC
=THDOC
req_type ("†", 0);
req_defn("†", ([], »
	„f:† ‹ INDŽTypeDefn Is_†_Rep f
¼));
=DESCRIBE
The HOL type $â{:}†á$ is the type of natural numbers: $0, 1, 2, \ldots$.
=ENDDOC
=THDOC
req_const ("Zero", »:†¼);
req_const ("Suc", »:† ‹ †¼);
list_req_defn(["Zero","Suc"], ([], »
		(ƒ nŽ Œ Suc n = Zero) €
		OneOne Suc €
		(ƒ pŽ p Zero € (ƒ mŽ p m Š p (Suc m)) Š (ƒ nŽ p n))
¼));
=DESCRIBE
This gives a loose specification of $Zero$ and $Suc$ as any two constants
satisfying the Peano Postulates.

The definition schema $icl'suc\_conv$
described in \cite{DS/FMU/IED/DTD006}, defines the numeric literal $0$ to
be equal to $Zero$ and defines all other numeric literals in terms of
$Suc$ and the preceding literal.

$Zero$ and $Suc$ are not intended for general use outside this theory
--- the more homely $0$ and $+1$ are preferred.
However, to increase confidence that the correct definitions have been given
(and to shorten and simplify the proofs), we work in terms of $Zero$ and
$Suc$ initially. In fact, $Zero$ only appears here and
there is just one other mention of $Suc$ (in the definition of $+$). 
=ENDDOC
\subsection{Definitions of the Arithmetic Operators}
=THDOC
map (curry req_infix 210) ["<", ">", "ž", "Ÿ"];
map (curry req_infix 300) ["+", "-"];
map (curry req_infix 310) ["Div", "Mod", "*"];

map (switch (curry req_const) »:†‹†‹BOOL¼) ["<", ">", "ž", "Ÿ"];
map (switch (curry req_const) »:†‹†‹†¼) ["+", "-"];
map (switch (curry req_const) »:†‹†‹†¼) ["*", "Div", "Mod"];
map req_defn[
("+", ([],	»ƒ m nŽ 0 + n = n € (m + 1) + n = (m + n) + 1 € Suc m = m + 1¼)),
("ž", ([],	»ƒ m nŽ m ž n ‚ („ iŽ m + i = n)¼)),
("<", ([],	»ƒ m nŽ m < n ‚ m + 1 ž n¼)),
(">", ([],	»ƒ m nŽ m > n ‚ n < m¼)),
("Ÿ", ([],	»ƒ m nŽ m Ÿ n ‚ n ž m¼)),
("-", ([],	»ƒ m nŽ (m + n) - n = m¼)),
("*", ([],	»ƒ m nŽ 0 * n = 0 € (m + 1) * n = m * n + n¼)),
("Mod", ([],	»ƒ m nŽ 0 < n Š
		0 Mod n = 0 € (m + 1) Mod n =
		(if m Mod n + 1 < n then m Mod n + 1 else 0)¼)),
("Div", ([],	»ƒ m nŽ 0 < n Š 
		0 Div n = 0 € (m + 1) Div n =
		(if m Mod n + 1 < n then m Div n else m Div n + 1)¼))
];
=DESCRIBE
These are the precedences, types and defining
theorems for the arithmetic operators.
The definitions are given in an order which gives a possible
linearisation of the dependencies between them.

=ENDDOC
$ž$ has been chosen as the most primitive of the arithmetic relations,
since {\em(a)} we prefer $ž$ and $<$ to $Ÿ$ and $>$ for fairly
arbitrary reasons and {\em(b)} the definition of $ž$ in terms
of an existential assertion is shorter than that for $<$.
(A poll of user opinion also showed a slight preference for reflexive
relations.)
It is envisaged that low-level proofs
will work with the relations by converting $Ÿ$ and $>$
to $ž$ and $<$ and then either use the definitions or with
the cancellation theorems etc. which are proved in this document.

There seems to be no benefit (and some loss in ease of proof)
in not specifying $Div$, $Mod$ when the divisor is $0$ and $-$ when
the subtrahend is greater than the diminuend and so the definitions give
a value in these cases. 
\subsection{Theorems}
\subsubsection{Peano Postulates}
=THDOC
req_thm("induction_thm",
	([], »ƒ pŽ p 0 € (ƒ mŽ p m Š p (m + 1)) Š (ƒ nŽ p n)¼));
req_thm("Œ_plus1_thm",
	([], »ƒ nŽ Œ n + 1 = 0¼));
req_thm("one_one_plus1_thm",
	([], »ƒ x1 x2Ž x1 + 1 = x2 + 1 Š x1 = x2¼));
=DESCRIBE
The first two of the Peano postulates (see e.g. \cite{Halmos74})
are captured by the types of $0$ and $+$.
The remaining three are given by these theorems.
=ENDDOC
\subsubsection{Primitive Recursion}
=THDOC
req_thm("prim_rec_thm",
	([], »ƒ z:'a; s:'a ‹ † ‹ 'aŽ „ã1 fŽ f 0 = z € (ƒ nŽ f (n + 1) = s (f n) n)¼));
=DESCRIBE
This is the principle of primitive recursion for the natural numbers.
=ENDDOC
\subsubsection{Course-of-Values Induction}
=THDOC
req_thm("cov_induction_thm",
	([], »ƒ pŽ (ƒ nŽ (ƒ mŽ m < n Š p m) Š p n) Š (ƒ nŽ p n)¼));
=DESCRIBE
This is the principle of course-of-values induction
(also called complete induction)  for the natural numbers.
=ENDDOC
\subsubsection{Case Analysis}
=THDOC
req_thm("†_cases_thm",
	([], »ƒ mŽ m = 0  („ iŽ m = i + 1)¼));
=DESCRIBE
This is the fundamental case analysis for the natural numbers.
=ENDDOC

\subsubsection{Theorems about Addition}
=THDOC
req_thm("plus_assoc_thm",
	([], »ƒ i m nŽ (i + m) + n = i + (m + n)¼));
req_thm("plus_assoc_thm1",
	([], »ƒ i m nŽ i + m + n = (i + m) + n¼));
req_thm("plus_comm_thm",
	([], »ƒ m nŽ m + n = n + m¼));
req_thm("plus_order_thm",
	([], »ƒ i m nŽ m + i = i + m €
		(i + m) + n = i + (m + n) €
		m + (i + n) = i + (m + n)¼));
=DESCRIBE
Associativity and commutativity of addition. Associativity is given in
two forms, one which moves the brackets right and one which moves them
left.

The final theorem is a useful way of using associativity and commutativity
in low-level proofs.
Rewriting with the theorem obtained by specialising $i$ to $t$, say, in
$plus\_order\_thm$,
causes all instances of $t$
to move to the beginning of each (maximal) subterm of the form $a + b + \ldots + t \ldots$.
=ENDDOC
=THDOC
req_thm("plus_clauses",
	([], »ƒm n iŽ
		(m + i = n + i ‚ m = n)
	€	(i + m = n + i ‚ m = n)
	€	(m + i = i + n ‚ m = n)
	€	(i + m = i + n ‚ m = n)
	€	(m + i = i ‚ m = 0)
	€	(i + m = i ‚ m = 0)
	€	(i = i + n ‚ n = 0)
	€	(i = n + i ‚ n = 0)
	€	(m + i = 0 ‚ m = 0 € i = 0)
	€	(m + 0 = m € 0 + m = m)
	€	Œ1 = 0
	€	Œ0 = 1
¼));
=DESCRIBE
This theorem gives cancellation rules for addition expressed as rewrite rules.
The theorem includes clauses which allow cancellation
on the left or the right of the $+$, which obviates detailed
manipulations of ordering of summands (using $plus\_order\_thm$) in many
simple cases.
=ENDDOC
\subsubsection{Theorems about Subtraction}
=THDOC
req_thm("minus_clauses",
	([], »ƒm nŽ
		m - m = 0
	€	m - 0 = m
	€	(m + n) - n = m
¼));
=DESCRIBE
This theorem gives rewrite rules for simplifying terms involving
subtraction. Note that because we are working in † not í, subtraction
is not a left inverse for addition.
=ENDDOC
\subsubsection{Theorems about ž}
=THDOC
req_thm("le_trans_thm",
	([], »ƒ m i nŽ m ž i € i ž n Š m ž n¼));
req_thm("le_cases_thm",
	([], »ƒ m nŽ m ž n  n ž m¼));
req_thm("le_antisym_thm",
	([], »ƒ m nŽ m ž n € n ž m ‚ m = n¼));
req_thm("le_well_order_thm",
	([], »ƒ pŽ („ iŽ p i) ‚ („ mŽ p m € (ƒ iŽ p i Š m ž i))¼));
=DESCRIBE
These theorems give standard order-theoretic properties of
$ž$, namely that it is transitive, connected, antisymmetric and a
well-ordering (where we use the terms
{\em connected} and {\em well-ordering} in the sense
appropriate to reflexive orderings).
Note that the above formulation of antisymmetry
implies reflexivity (which is also given explicitly in the
cancellation theorem $lt\_clauses$, as is the fact that $0$ is a least
element for $ž$).
=ENDDOC
=THDOC
req_thm("le_clauses",
	([], »ƒm n iŽ
		(m + i ž n + i ‚ m ž n)
	€	(i + m ž n + i ‚ m ž n)
	€	(m + i ž i + n ‚ m ž n)
	€	(i + m ž i + n ‚ m ž n)
	€	(m + i ž i ‚ m = 0)
	€	(i + m ž i ‚ m = 0)
	€	(m + i ž 0 ‚ m = 0 € i = 0)
	€	(m ž 0 ‚ m = 0)
	€	m ž m + i
	€	m ž i + m
	€	m ž m
	€	0 ž m
	€	Œ1 ž 0
¼));
=DESCRIBE
This theorem gives cancellation rules for $ž$ expressed as rewrite rules.
Like $plus\_clauses$, the theorem includes clauses which allow cancellation
on the left or the right of the $+$.
=ENDDOC

=THDOC
req_thm("le_plus1_thm",
	([], »ƒ m nŽ m ž n + 1 ‚ m = n + 1  m ž n¼));
req_thm("plus1_le_thm",
	([], »ƒ m nŽ m + 1 ž n ‚ m ž n € Œ m = n¼));
=DESCRIBE
These two theorems give the step cases of the two ways of defining
$ž$ by primitive recursion. The base cases are part of
$le\_clauses$. The theorems are sometimes of use in reasoning
about $ž$ by induction.
=ENDDOC
\subsubsection{Theorems about $<$}
=THDOC
req_thm("lt_trans_thm",
	([], »ƒ m i nŽ m < i € i < n Š m < n¼));
req_thm("lt_cases_thm",
	([], »ƒ m nŽ m < n  m = n  n < m¼));
req_thm("lt_irrefl_thm",
	([], »ƒ m nŽ Œ (m < n € n < m)¼));
req_thm("lt_well_order_thm",
	([], »ƒ pŽ („ iŽ p i) ‚ („ mŽ p m € (ƒ iŽ p i Š Œi < m))¼));
=DESCRIBE
These theorems give standard order-theoretic properties of
$<$, namely that it is transitive, connected, irreflexive and a
well-ordering, (where we use the terms {\em connected} and
{\em well-ordering} in the sense appropriate to irreflexive orderings).
The fact that $0$ is a least element for $<$ is contained
in $lt\_clauses$.
=ENDDOC
=THDOC
req_thm("lt_clauses",
	([], »ƒm n iŽ
		(m + i < n + i ‚ m < n)
	€	(i + m < n + i ‚ m < n)
	€	(m + i < i + n ‚ m < n)
	€	(i + m < i + n ‚ m < n)
	€	(m < m + i ‚ 0 < i)
	€	(m < i + m ‚ 0 < i)
	€	Œm + i < m
	€	Œm + i < i
	€	Œm < 0
	€	Œm < m
	€	0 < m + 1
	€	0 < 1 + m
	€	0 < 1
¼));
=DESCRIBE
This theorem gives cancellation rules for $<$ expressed as rewrite rules.
Like $plus\_clauses$, the theorem includes clauses which allow cancellation
on the left or the right of the $+$.
=ENDDOC

=THDOC
req_thm("lt_plus1_thm",
	([], »ƒ m nŽ m < n + 1 ‚ m = n  m < n¼));
req_thm("plus1_lt_thm",
	([], »ƒ m nŽ m + 1 < n ‚ m < n € Œ m + 1 = n¼));
=DESCRIBE
These two theorems give the step cases of the two ways of defining
$<$ by primitive recursion. The base cases are part of
$lt\_clauses$. The theorems are sometimes of use in reasoning
about $<$ by induction.
=ENDDOC
\subsubsection{Theorems about ž and $<$ and Œ}
=THDOC
req_thm("Œ_le_thm",
	([], »ƒm nŽ Œm ž n ‚ n < m¼));
req_thm("Œ_lt_thm",
	([], »ƒm nŽ Œm < n ‚ n ž m¼));
req_thm("Œ_plus1_le_thm",
	([], »ƒ m nŽ Œ m + 1 ž n ‚ n ž m¼));
req_thm("Œ_lt_plus1_thm",
	([], »ƒ m nŽ Œ m < n + 1 ‚ n < m¼));
=DESCRIBE
These theorems may be used in low-level reasoning about $ž$ and $<$
to remove negations.
=ENDDOC
\subsubsection{Theorems about Multiplication}
=THDOC
req_thm("times_comm_thm",
	([], »ƒ m nŽ m * n = n * m¼));
req_thm("times_assoc_thm",
	([], »ƒ i m nŽ (i * m) * n = i * (m * n)¼));
req_thm("times_plus_distrib_thm",
	([], »ƒ i m nŽ
		(i + m) * n = i * n + m * n
	€	i * (m + n) = i * m + i  * n¼));
req_thm("times_clauses",
	([], »ƒ mŽ
		m * 0 = 0
	€	0 * m = 0
	€	m * 1 = m
	€	1 * m = m¼));
=DESCRIBE
These four theorems give standard facts about multiplication. 
=ENDDOC
We do not supply the analogues of $plus\_assoc\_thm1$ and
$plus\_order\_thm$ on the assumption that the type of
arguments in which they might be used will not be necessary until term
normalisation machinery to do them automatically is available.
\subsection{Theorems about Division and Modulus}
=THDOC
req_thm("mod_lt_thm",
	([], »ƒm nŽ 0 < n Š m Mod n < n¼));
req_thm("div_mod_thm",
	([], »ƒ m nŽ 0 < n Š m = (m Div n) * n + m Mod n¼));
req_thm("div_mod_unique_thm",
	([], »ƒm n d rŽ r < n Š
		(m = d * n + r Š d = m Div n € r = m Mod n)¼));
=DESCRIBE
These theorems together give the characterising property for division
and modulus with a non-zero divisor.
=ENDDOC
\section{THE SIGNATURE}
=DOC
signature â†á = sig
=TEX
\subsection{Definitions}
=DESCRIBE
This is the signature in which the theory ``†'' is declared.
=ENDDOC
=DOC
val â†_defá : THM;
val âdiv_defá : THM;
val âge_defá : THM;
val âgt_defá : THM;
val âis_†_rep_defá : THM;
val âle_defá : THM;
val âlt_defá : THM;
val âminus_defá : THM;
val âmod_defá : THM;
val âplus_defá : THM;
val âtimes_defá : THM;
val âzero_suc_defá : THM;
=DESCRIBE
These Standard ML variables are bound to the definitions in the
theory ``†''.
=ENDDOC
\subsection{Theorems}
=DOC
val â†_cases_thmá : THM;
val âŒ_le_thmá : THM;
val âŒ_lt_plus1_thmá : THM;
val âŒ_lt_thmá : THM;
val âŒ_plus1_le_thmá : THM;
val âŒ_plus1_thmá : THM;
val âcov_induction_thmá : THM;
val âdiv_mod_thmá : THM;
val âdiv_mod_unique_thmá : THM;
val âinduction_thmá : THM;
val âle_antisym_thmá : THM;
val âle_cases_thmá : THM;
val âle_clausesá : THM;
val âle_plus1_thmá : THM;
val âle_trans_thmá : THM;
val âle_well_order_thmá : THM;
val âlt_cases_thmá : THM;
val âlt_clausesá : THM;
val âlt_irrefl_thmá : THM;
val âlt_plus1_thmá : THM;
val âlt_trans_thmá : THM;
val âlt_well_order_thmá : THM;
val âminus_clausesá : THM;
val âmod_lt_thmá : THM;
val âone_one_plus1_thmá : THM;
val âplus1_le_thmá : THM;
val âplus1_lt_thmá : THM;
val âplus_assoc_thmá : THM;
val âplus_assoc_thm1á : THM;
val âplus_clausesá : THM;
val âplus_comm_thmá : THM;
val âplus_order_thmá : THM;
val âprim_rec_thmá : THM;
val âtimes_comm_thmá : THM;
val âtimes_assoc_thmá : THM;
val âtimes_plus_distrib_thmá : THM;
val âtimes_clausesá : THM;
=DESCRIBE
These Standard ML variables are bound to the theorems in the
theory ``†''.
=ENDDOC
\subsection{Conversions}
=DOC
val âplus1_convá : CONV;
=DESCRIBE
This conversion proves theorems of the form $m = n + 1$ where
$m$ and $n$ are numeric literals.
=TACTIC
plus1_conv (mk_† m)
É
É
…   »%down%ML mk_† m¼
  = »%down%ML mk_† (m-1)¼ + 1 
=TEX
=ENDDOC
\subsection{Tactics}
=DOC
val âinduction_tacá : TERM -> TACTIC;
=DESCRIBE
This tactic implements induction over the natural numbers:
to prove $t[x]$ it suffices to prove $t[0]$ and to prove $t[x+1]$ on the
assumption that $t[x]$. The term argument must be a variable of type
»:†¼  and must appear free in the conclusion of the
goal but not in its assumptions.
=TACTIC
induction_tac »x¼
É
{ ö } t[x] 
É
{ ö } t[0] ; strip{t[x], ö} t[x+1]
=TEX
=SEEALSO
$cov\_induction\_tac$,
$INDUCTION\_T$
=FAILURE
38001	?0 is not a variable of type »:†¼
38002	?0 does not appear free in the conclusion of the goal
38003	?0 appears free in the assumptions of the goal
=ENDDOC
=DOC
val âcov_induction_tacá : TERM -> TACTIC;
=DESCRIBE
This tactic implements course-of-values induction over the natural numbers.
To prove $t[x]$ it suffices to prove $t[x]$ on the
assumption $ƒmŽm < x Š t[m]$.
(Course-of-values induction is also sometimes called as complete induction.)
The term argument must be a variable of type
»:†¼ and must appear free in the conclusion of the
goal but not in its assumptions.
=TACTIC
cov_induction_tac »x¼
É
{ ö } t[x] 
É
strip{¼ƒmŽ m < x Š t m¼, ö} t[x]
=TEX
=FAILURE
38001	?0 is not a variable of type »:†¼
38002	?0 does not appear free in the conclusion of the goal
38003	?0 appears free in the assumptions of the goal
=SEEALSO
$induction\_tac$
=ENDDOC
=DOC
val âINDUCTION_Tá : TERM -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
This implements induction over the natural numbers as
a tactical. The term argument must be a variable of type
»:†¼ and must appear free in the conclusion of the
goal but not in its assumptions.
The inductive hypothesis is passed to the tactic generating function
given by the second argument.
=TACTIC
INDUCTION_T »x¼ ttac
É
{ ö } t[x] 
É
{ ö } t[0] ; ttac(t[x] … t[x])({ ö } t[x+1])
=TEX
=USES
Most commonly used with $asm\_tac$ to avoid the stripping up of
the inductive hypothesis which occurs with $induction\_tac$.
=SEEALSO
$induction\_tac$,
$COV\_INDUCTION\_T$
=FAILURE
38001	?0 is not a variable of type »:†¼
38002	?0 does not appear free in the conclusion of the goal
38003	?0 appears free in the assumptions of the goal
=ENDDOC
=DOC
val âCOV_INDUCTION_Tá : TERM -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
This implements course-of-values induction over the natural numbers
as a tactical.
The term argument must be a variable of type
»:†¼ and must appear free in the conclusion of the
goal but not in its assumptions.
The inductive hypothesis is passed to the tactic generating function
given by the second argument.
=TACTIC
COV_INDUCTION_T »x¼ ttac
É
{ ö } t[x] 
É
ttac
(»ƒmŽ m < x Š t m¼ … »ƒmŽ m < x Š t m¼)
({ ö } t[x])
=TEX
=USES
Tactic programming.
=SEEALSO
$cov\_induction\_tac$,
$INDUCTION\_T$
=FAILURE
38001	?0 is not a variable of type »:†¼
38002	?0 does not appear free in the conclusion of the goal
38003	?0 appears free in the assumptions of the goal
=ENDDOC
=SML
end; (* of signature † *)
=TEX
\section{TEST POLICY}

Any functions are to be tested according to then
general criteria laid down in the quality plan, \cite{DS/FMU/IED/PLN008}.
The theory implemented is to be checked by the theory design tools
of \cite{DS/FMU/IED/DTD035}.
\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}
