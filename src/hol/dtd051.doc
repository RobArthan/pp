=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Proof Contexts}  %% Mandatory field
\def\TPPheadtitle{Proof Contexts}
\TPPref{DS/FMU/IED/DTD051}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{K.~Blackburn & WIN01\\R.D.Arthan & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the detailed design for providing proof contexts.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Try again.
\item [Issue 1.3]
And again.
\end{description}
\subsection{Changes Forecast}
This document needs to know which functions it may
configure, and the type of the proof context details.
Thus if a new configurable tool is added to the system then this document will need
modification.

In particular, the expected resolution tool will be parameterised in some manner yet to be decided,
and when introduced will require changes to this document
and its implementation.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
provision of proof contexts.
This is called for in section \cite{DS/FMU/IED/HLD???}.
The design is implemented in \cite{DS/FMU/IED/IMP051}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
A proof context is a setting of various configurable
parameters of proof tools to support a particular mode of proof.
For instance, both $rewrite\_tac$ and $strip\_tac$ 
are configurable proof tools.
In particular, proof contexts will be later made available,
through the tools supplied here,
that supply a good environment to reason about Z,
or within a particular theory (e.g. set theory),
and alter the default environment.

An alternative approach to the one chosen is to take a 
proof context to be a labeled list of functions of type $:unit\ ->\ unit$.
A proof context would then be set by applying each function in the proof context to $()$.
This has the advantage that new configurable tools could be
introduced within a system rebuild.
However, one loses the ability to display even parts
of the context, or access to the data to which
an individual configurable function could be configured.
\subsubsection{Dependencies}
This document is dependent on \cite{DS/FMU/IED/IMP008}.
It also depends on knowledge of what configurable tools it 
needs to cover.
It further depends on being able to create at least dummy
configuration values for these functions.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
Proof contexts are often associated with theories,
so it might be nice if the theory lister tells you the names
of those objects associated with the theory listed.

We fail to give the developer of a configurable tool the means to modify all relevant pre-existing proof contexts to understand the
new tool.
They will have to modify this document and its implementation, and all existing contexts, and then rebuild the system
(an approach only available to someone supplied with the means to do a system build), or provide their own proof context
tools, perhaps ``piggy backing'' upon the ones supplied here.
\section{THE DESIGN}
=DOC
signature âProofContextá = sig
=DESCRIBE
This provides the basic tools for handling proof contexts.
=ENDDOC
The goal of the following functions is:
\begin{enumerate}
\item
To give a naive user a simple command to change
the proof context.
This will change the configuration of all configurable proof tools,
to provide the best context available for the style of work they are to then carry out.
\item
To give the developer of, say, a new theory the means
to create a proof context to provide a context suitable for reasoning in that theory.
\item
To allow a piece of proof automation to change the context,
do some work, and then revert to the previous context.
\item
To provide a single place where all configurable tools look
for their configuration data.
\end{enumerate}
We then first have the user presentation of a proof context:
=DOC
type âPROOF_CONTEXTá;
=DESCRIBE
This is the type of a proof context, which holds the data used to configure certain proof tools.
ó
type PROOF_CONTEXT = {
	rw_eqn_cxt: (TERM * CONV)list,	(* EQN_CXT *)
	rw_canon: THM -> THM list,	(* CANON *)
	sa_eqn_cxt: (TERM * CONV)list,	(* EQN_CXT *)
	sg_eqn_cxt: (TERM * CONV)list,	(* EQN_CXT *)}; 
æ
These are, in sequence:
\begin{itemize}
\item
An equational context for rewriting (see e.g. $rewrite\_tac$);
\item
A canonicalisation function for rewriting (see e.g. $rewrite\_tac$);
\item
An equational context for stripping theorems into the
assumption list (see e.g. $strip\_tac$);
\item
And an equational context for stripping goals (see e.g. $strip\_tac$).
\end{itemize}
A proof context is set to such a configuration by first evaluating something of
this type, using $evaluate\_proof\_context$ (q.v.),
and then setting the result using $push\_proof\_context$ (q.v.)
=ENDDOC
It is intended that a designer of, say, a theory would 
work out a few (maybe only one) proof contexts
for working with the theory.
They would bind these to ML variables, and would
likewise bind the evaluated forms (see below).
If a user then wanted, say, the standard rewriting equational context
for that theory they would extract it from the ML variable bound to the appropriate unevaluated proof context,
rather than expecting to find it
separately stored.

We wish to be able to set such a proof context
with no more evaluation cost than a few assignments.
This implies that we must to do any pre-evaluation
at the point of creation of a context, rather than the setting of the context.
This evaluated proof context is of type:
=DOC
type âEPROOF_CONTEXTá;
=DESCRIBE
This is the type of an evaluated proof context, which holds the data used to configure certain proof tools
in a form where configuration only requires assignment to variables.
Objects of this type are created by $evaluate\_proof\_context$ (q.v.),
or ``by hand'',
and may be set by $push\_proof\_context$
(q.v.).
ó
type EPROOF_CONTEXT = {
	rw_net: CONV NET,
	rw_canon: THM -> THM list,	(* CANON *)
	sa_conv: CONV,
	sg_conv: CONV}; 
æ
=ENDDOC

Pre-evaluation will be done by combining functions supplied
by individual tools into the single function.
This implies that all configurable proof tools will be
supplied with: a single individual pre-evaluation function
 which takes as argument all the tool's configuration parameters bundled into one value;
and with a way of configuring the tool to the result of this pre-evaluation function.

Thus this function, $evaluate\_proof\_context$ cannot be defined until after all the configured tools are implemented.
=IGN
 =DOC
val âevaluate_proof_contextá : PROOF_CONTEXT -> EPROOF_CONTEXT;
 =DESCRIBE
This function does all possible pre-evaluation
of the material stored in an object of type $PROOF\_CONTEXT$,
leaving the result in a form where configuration only requires assignment to variables.
Such a configuration is then set by $push\_proof\_context$
(q.v.).
 =FAILUREC
\paragraph{Errors}
Any error messages given by the constituent pre-evaluation
functions will be transparently passed through this function.
 =ENDDOC
Our current proof context, to which all configurable tools look
to find their configuration data, is accessed by:
=DOC
val âget_proof_contextá : unit -> EPROOF_CONTEXT;
=DESCRIBE
This function gets the current proof context, to which all configurable tools look
to find their configuration data.
=SEEALSO
$push\_proof\_context$, $pop\_proof\_context$
=ENDDOC
=TEX
We use a stack of (temporaily) superceded proof contexts to simplify the task 
of ``change the context,
do some work, and then revert to the previous context'',
for this is the obvious approach.
=DOC
val âpush_proof_contextá : EPROOF_CONTEXT -> unit;
=DESCRIBE
This function stacks the previous proof context, and
and configures the system according to the new proof 
context.
=SEEALSO
$pop\_proof\_context$, $get\_proof\_context$
=ENDDOC
=DOC
val âpop_proof_contextá : unit -> EPROOF_CONTEXT;
=DESCRIBE
This function unstacks the top of the proof context stack,
configures the system to it, and returns the previous current proof context.
=SEEALSO
$push\_proof\_context$, $get\_proof\_context$
=FAILURE
51001	The proof context stack is empty
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of ProofContext *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
