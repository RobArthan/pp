=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Proof Contexts}  %% Mandatory field
\def\TPPheadtitle{Proof Contexts}
\TPPref{DS/FMU/IED/DTD051}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{K.~Blackburn & WIN01\\R.D.Arthan & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the detailed design for providing proof contexts.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Try again.
\item [Issue 1.3]
And again.
\item [Issue 1.4]
Tidying up after doing implementation.
\item [Issue 1.5]
Moved to using abstract data types.
\item [Issue 1.6]
Gains equational context material.
\item [Issue 1.7]
Added $get\_(e)pc\_cs\_¶\_rule$.
\item [Issue 1.8]
Added existence prover parameterisation.

\item[Issue 1.9, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.10]
Changed to using a dictionary of proof contexts.
\item [Issue 1.11]
Variation on a theme.
\end{description}
\subsection{Changes Forecast}
The designer of this document needs to know which functions it may
give context for, and the type of the proof context details.
Thus if a new tool using context is added to the system then this document will need
modification.

In particular, the expected resolution tool will be parameterised in some manner yet to be decided,
and when introduced will require changes to this document
and its implementation.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
provision of proof contexts.
This is called for in \cite{DS/FMU/IED/HLD???}.
The design is implemented in \cite{DS/FMU/IED/IMP051}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
A proof context is a setting of various
parameters of proof tools to support a particular mode of proof.
For instance, both $rewrite\_tac$ and $strip\_tac$ 
are proof tools that may be parameterised.
In particular, proof contexts will be later made available,
through the tools supplied here,
that supply a helpful environment to reason about Z,
or within a particular theory (e.g. set theory),
and alter the default environment.

An alternative approach to the one chosen is to take a 
proof context to be a labeled list of functions of type $:unit\ ->\ unit$.
A proof context would then be ``set'' by applying each function in the proof context to $()$.
This has the advantage that new context-sensitive tools could be
introduced without a system rebuild.
However, one loses the ability to display even parts
of the context, or access to the data to which
an individual function could be set.
\subsubsection{Dependencies}
This document is dependent on \cite{DS/FMU/IED/IMP008}.
It also depends on knowledge of what context-sensitive tools it
needs to cover.
It further depends on being able to create at least dummy
values for the parameters of these functions.
\subsubsection{Deficiencies}
We fail to give the developer of a context-sensitive proof tool the ability to add an ``understanding'' of the new tool without
modifying this document and its implementation.
They will have to modify this document and its implementation and then rebuild the system
(an approach only available to someone supplied with the ability to do a system build), or provide their own proof context
tools, perhaps ``piggy backing'' upon the ones supplied here.

\subsubsection{Possible Enhancements}
Proof contexts are often associated with theories,
so it might be nice if the theory lister tells you the names
of those contexts associated with the theory listed.
\subsubsection{Terminology}
An {\em equational context} is a list of conversions,
each paired with term index. It represents a context that states
how to
rewrite a term to result in an equational theorem,
guided by the outermost form of the term to be rewritten.
An equational context will be of type $EQN\_CXT$
(== $(TERM\ *\ CONV)list$).

A {\em proof context} holds the data used to provide context for selected proof tools.

\section{THE DESIGN}
=DOC
signature ÛProofContextÝ = sig
=DESCRIBE
This provides the basic tools for handling equational and proof contexts.
=ENDDOC
\subsection{Equational Contexts}
=DOC
type ÛEQN_CXTÝ;
=DESCRIBE
This is the type of equational contexts.
An equational context is a list of conversions,
each paired with term index. It represents a statement of
how to
rewrite a term to result in an equational theorem,
guided by the outermost form of the term to be rewritten,
which is matched against the term index of each conversion.
It is used to create a single conversion via $eqn\_cxt\_conv$ (q.v.).

A theorem may be converted into a member of 
an equational context by $thm\_eqn\_cxt$.
A pre-existing conversion may be converted by determining
the term index that matches at least all terms that 
the conversion must work on
(see $net\_enter$ for details), and pair it with the conversion.
=GFT
type EQN_CXT = (TERM * CONV) list;
=TEX
Note that equational contexts can be merged by appending.
An equational context may be transformed into a conversion 
discrimination net by $make\_net$ or $list\_net\_enter$(q.v.).
=ENDDOC
=DOC
val Ûthm_eqn_cxtÝ : THM -> (TERM * CONV);
=DESCRIBE
A theorem may be transformed into a suitable member of 
an equational context ($EQN\_CXT$ q.v.)
by $thm\_eqn\_cxt$:
=GFT
thm_eqn_cxt `‡ ô µ x1 ... · LHS = RHS` ­
	(LHS, simple_eq_match_1_conv `‡ ô µ x1 ... · LHS = RHS`)
=TEX
where the universal quantifiers must be simple.
=SEEALSO
$cthm\_eqn\_cxt$ which canonicalises
a theorem before transformation.
=FAILURE
7095	?0 is not of the form `‡ ô µ x1 ... xn · u = v' where ¬xi® are variables
=ENDDOC
=DOC
val Ûeqn_cxt_convÝ : EQN_CXT -> CONV;
=DESCRIBE
This function creates a single conversion from an equational
context.
This is done via $make\_net$ and $net\_lookup$(q.v).
There is an implicit $CHANGED\_C$ wrapped around each
conversion in the equational context.
=FAILURE
51005	Equational context gave no conversions that succeeded for ?0
=ENDDOC

\subsection{Proof Contexts}
The goal of the following functions is:
\begin{enumerate}
\item
To give a naive user a simple command to change
the proof context.
This will change the individual context of all context-sensitive proof tools,
to provide the best context available for the style of work they are to then carry out.
\item
To give a more experienced user the ability to merge
together the effect of a number of proof contexts into the current proof context.
\item
To give the developer of, say, a new theory the means
to create a proof context suitable for reasoning in that theory.
\item
To allow a piece of proof automation to change the proof context,
do some work, and then revert to the previous context.
\item
To provide a single place where all context-sensitive tools look
for their contexts.
\end{enumerate}
We implement proof contexts by maintaining two data structures:
a database of proof contexts, in which a proof context is a record
in the database, and a particular part of the proof context is
a field of the proof context;
and a stack of proof contexts, which has the current proof context as the top record.
Proof contexts are pushed onto the stack from the database,
they have no existence apart from within these two structures.

A proof context has a number of fields, each field relating
to some single area of context for a context-sensitive
proof tool.
A proof context is created by $new\-\_pc$.
Its fields are populated by data that comes from other
proof contexts in the database (by $merge\-\_pc$ and
$merge\-\_pc\-\_fields$), and that is entered by
the proof contexts creator.
A proof context in is in the middle of its creation may still be
pushed onto the proof context stack, but it may not be used
as the origin of data for a field of another proof context.
When a proof context is considered complete it is ``committed''
by $commit\-\_pc$, and it then becomes an
acceptable origin of data for other proof contexts.

Mechanisms keep track of the origin of data in each of a 
proof contexts fields by splitting it into subfields, to allow duplicated information to
be discarded when merging data from a number of proof contexts in a single field.
Each subfield is indexed by the proof context name from which it came.
This is also why we commit proof contexts, and why they may
only have data extracted for other proof contexts after their commital.
More than one proof context may be uncommitted at one time.

The data a user might enter into a proof context
is not in the same form as context-sensitive applications accessing the proof context wish to see:
there is an evaluation step in between.
We therefore must provide methods of evaluating the 
user data to extract the application data.
As we cannot in all cases state this evaluation process
at the point of implementing this document
we provide the functions prefixed $icl'set\_eval\_???$ to allow
evaluation functions to be entered at a later date.
Uncommitted proof contexts are evaluated by the current
evaluation function when they are pushed onto the proof context stack,
committed contexts are evaluated at the point of commital
by the evaluation functions current at the time of commital
(saving the cost of multiple evaluations upon multiple pushes).
\subsection{Summary of Tools Supported and Provided}
Three tools have context-sensitive  behaviour supported
by proof contexts:
=GFT
rewrite_tac and its cousins
strip_tac and its cousins
prove_¶_rule and its users
=TEX

The user data tools are:
=GFT
set_rw_eqn_cxt		get_rw_eqn_cxt
set_rw_canons		get_rw_canons
set_st_eqn_cxt		get_st_eqn_cxt
set_sg_eqn_cxt		get_sg_eqn_cxt
set_cs_¶_rule		get_cs_¶_rule
set_¶_cd_thm		get_¶_cd_thm
set_¶_vs_thm		get_¶_vs_thm
=TEX
In naming the interface functions we use the convention:
=GFT
<set|get>_<proof tool>_<modifier>
=TEX
The proof tools in the above are: $rw$ for rewriting,
$st$ for stripping theorems, $sg$ for stripping goals,
$cs$ for constant specifications,
and $¶$ for the existence prover $prove\-\_¶\-\_conv$.
$set$ and $get$ functions overwrite or access the database respectively.

The applications data tools are:
=GFT
icl'set_eval_ad_rw_net		current_ad_rw_net
icl'set_eval_ad_rw_canon		current_ad_rw_canon
icl'set_eval_ad_st_conv		current_ad_st_conv
icl'set_eval_ad_sg_conv		current_ad_sg_conv
icl'set_eval_ad_cs_¶_rule		current_ad_cs_¶_rule
icl'set_eval_ad_¶_cd_thm		current_ad_¶_cd_thm
icl'set_eval_ad_¶_vs_thm		current_ad_¶_vs_thm
=TEX
In naming the applications data interface functions we use the convention:
=GFT
<icl'set_eval|current>_ad_<proof tool>_<modifier>
=TEX
The proof tools in the above are: $rw$ for rewriting,
$st$ for stripping theorems, $sg$ for stripping goals,
$cs$ for constant specifications,
and $¶$ for the existence prover $prove\-\_¶\-\_conv$.
$icl'set\_eval$
sets the method of evaluating the associated user data into application data,
and $current$ gives the current proof contexts application data.

Note that the application data fields could be directly modified, to $v$ say,
by setting the evaluation function to 
=INLINEFT
(fn _ => v)
=TEX
, committing the proof context,
and restoring the evaluation function to its previous value.
This might be a system builder's necessary trick,
it is certainly not a standard pattern of use.

To allow certain patterns of context changes, we have
a stack of proof contexts, with the current proof context at the top.
We provide applications with hooks to look into this current proof
context,
but no way to modify stacked proof contexts ``in place''.
In particular, if a proof context is stacked, then it
is in fact a copy that is stacked, so that later changes to the original do not affect the stack.

The database of proof contexts is initialised to contain
a single context with key ``initial'', which is also the initial current proof context

=DOC
val Ûnew_pcÝ : string -> unit;
=DESCRIBE
$new\_pc$ $new$
creates a new 
entry with key $to$.
A note will be made of the current theory,
and its current definition level at the time of
creation, and an error will be raised
if an attempt is made to push the new proof context (see $push\_pc$) when
that theory is not in scope, or when the definition level
has been recorded as deleted.
The definition level will recorded as deleted if, e.g., some definition
or axiom that was in scope in the original theory has since been deleted.

One responsibility of the creator of a proof context is to ensure that the theorems used within, or created by, the new context are also
in scope: this is not automatically checked.
=FAILURE
51011	There is already a proof context with key ?0
=ENDDOC
=DOC
val Ûdelete_pcÝ : string -> unit;
=DESCRIBE
This deletes an entry from the proof context database.
Entry ``initial'' may not be deleted.
=FAILURE
51010	There is no proof context with key ?0
51012	Initial proof context may not be deleted
=ENDDOC
=DOC
val Ûshow_pcsÝ : unit -> (string * string) list;
=DESCRIBE
This lists the names of the proof contexts held in the proof context
database, and the theory that was current at their time of creation.
If the theory has since been deleted then the theory name will be given as ``(deleted)''.
=ENDDOC
=DOC
val Ûcurrent_ad_nameÝ : unit -> string;
=DESCRIBE
Returns the key of the entry from which the
current proof context was copied.
Note that the key may no longer access a proof context in the database identical to the current proof context.

Merged proof contexts upon the stack  (from $push\_pcs$ and  $set\_pcs$) will have ``current proof context name'' of the names of the constituent proof contexts, comma'ed together.
=ENDDOC
=DOC
val Ûset_rw_eqn_cxtÝ : EQN_CXT -> string -> unit;
val Ûget_rw_eqn_cxtÝ : string -> (EQN_CXT * string) list;
=DESCRIBE
These functions provide the interface to the equational context for rewriting (see e.g. $rewrite\_tac$)
held in the user data of a proof context.
``setting'' overwrites the subfield whose key is the proof context's name,
``getting'' returns the entire field (which pairs data with
proof context names).
=FAILURE
51010	There is no proof context with key ?0
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val Ûicl'set_eval_ad_rw_netÝ : (EQN_CXT -> CONV NET) -> unit;
val Ûcurrent_ad_rw_netÝ : unit -> CONV NET;
=DESCRIBE
These functions provide the interface to the initial conversion net for rewriting (see e.g. $rewrite\_tac$)
held in the application data of a proof context.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_rw\_eqn\_cxt$ for the associated user data.
=ENDDOC
=DOC
val Ûset_rw_canonsÝ : (THM -> THM list) list -> 
	string -> unit;
val Ûget_rw_canonsÝ : string -> ((THM -> THM list) list * string) list;
=DESCRIBE
These functions provide the interface to the individual canonicalisation functions used to create the canonicalisation function applied to rewriting theorems (see e.g. $rewrite\_tac$)
held in the user data of a proof context.

``setting'' overwrites the subfield whose key is the proof context's name,
``getting'' returns the entire field (which pairs data with
proof context names).
=FAILURE
51010	There is no proof context with key ?0
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val Ûicl'set_eval_ad_rw_canonÝ : ((THM -> THM list) list -> (THM -> THM list)) 
	-> unit;
val Ûcurrent_ad_rw_canonÝ : unit -> (THM -> THM list);
=DESCRIBE
These functions provide the interface to the canonicalisation function applied to rewriting theorems (see e.g. $rewrite\_tac$)
held in the application data of a proof context.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_rw\_canons$ for the associated user data.
=ENDDOC
=DOC
val Ûset_st_eqn_cxtÝ : EQN_CXT -> string -> unit;
val Ûget_st_eqn_cxtÝ : string -> (EQN_CXT * string)list;
=DESCRIBE
These functions provide the interface to the equational context for stripping theorems into the
assumption list (see e.g. $strip\_tac$)
held in the user data of a proof context.
``setting'' overwrites the subfield whose key is the proof context's name,
``getting'' returns the entire field (which pairs data with
proof context names).
=FAILURE
51010	There is no proof context with key ?0
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val Ûicl'set_eval_ad_st_convÝ : (EQN_CXT -> CONV) -> unit;
val Ûcurrent_ad_st_convÝ : unit -> CONV;
=DESCRIBE
These functions provide the interface to the conversion for stripping theorems into the
assumption list (see e.g. $strip\_tac$)
held in the application data of a proof context.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_st\_conv$ for the associated user data.
=ENDDOC
=DOC
val Ûset_sg_eqn_cxtÝ : EQN_CXT -> string -> unit;
val Ûget_sg_eqn_cxtÝ : string -> (EQN_CXT * string) list;
=DESCRIBE
These functions provide the interface to the equational context for stripping goal conclusions (see e.g. $strip\_tac$)
held in the user data of a proof context.
``setting'' overwrites the subfield whose key is the proof context's name,
``getting'' returns the entire field (which pairs data with
proof context names).
=FAILURE
51010	There is no proof context with key ?0
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val Ûicl'set_eval_ad_sg_convÝ : (EQN_CXT -> CONV) -> unit;
val Ûcurrent_ad_sg_convÝ : unit -> CONV;
=DESCRIBE
These functions provide the interface to the conversion for stripping goal conclusions (see e.g. $strip\_tac$)
held in the application data of a proof context.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_sg\_conv$ for the associated user data.
=ENDDOC
=DOC
val Ûset_cs_¶_ruleÝ : ((TERM -> THM) list) -> 
	string -> unit;
val Ûget_cs_¶_ruleÝ : string -> 
	((((TERM -> THM) list)*string) list);
=DESCRIBE
These functions provide the interface to the 
existence provers for constant specifications (see $const\_spec$)
held in the user data of a proof context.
Each existence prover will be used in turn.

``setting'' overwrites the subfield whose key is the proof context's name,
``getting'' returns the entire field (which pairs data with
proof context names).
=FAILURE
51010	There is no proof context with key ?0
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val Ûicl'set_eval_ad_cs_¶_ruleÝ : (((TERM -> THM) * string)list -> (TERM -> THM))
	 -> unit;
val Ûcurrent_ad_cs_¶_ruleÝ : unit -> (TERM -> THM);
=DESCRIBE
These functions provide the interface to the 
existence prover for constant specifications (see $const\_spec$)
held in the application data of a proof context.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_cs\_¶\_rule$ for the associated user data.
=ENDDOC
=DOC
val Ûset_¶_cd_thmÝ : THM list -> string -> unit;
val Ûget_¶_cd_thmÝ : string -> THM list;
=DESCRIBE
These functions provide the interface to the
unevaluated  
clausal definition theorems held for the existence prover
$prove\_¶\_conv$.
There are no subfields to this field, so
``setting'' overwrites the field with the proof context's name,
``getting'' returns the field.
=SEEALSO
See $evaluate\_¶\_cd\_thm$ for details upon the form
of the theorems.
$set\-\_ad\-\_¶\-\_cd\-\_thm$ for the associated application data.
=FAILURE
51010	There is no proof context with key ?0
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val Ûicl'set_eval_ad_¶_cd_thmÝ : (THM list -> 
	(TERM list * int list * TYPE * (TERM list)list * THM) list) -> unit;
val Ûcurrent_ad_¶_cd_thmÝ : unit -> 
	(TERM list * int list * TYPE * (TERM list)list * THM) list;
=DESCRIBE
These functions provide the interface to the 
clausal definition theorem information for the existence prover
$prove\_¶\_conv$.
See $evaluate\_¶\_cd\_thm$ for details upon the form
of the information.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_¶_cd_thm$ for the associated user data.
=ENDDOC
=DOC
val Ûset_¶_vs_thmÝ : (string * (TERM list * THM)) list
 	-> string -> unit;
val Ûget_¶_vs_thmÝ : string -> (string * (TERM list * THM)) list;
=DESCRIBE
These functions provide the interface to the
variable structure information for the existence prover
$prove\_¶\_conv$.
An individual entry in the list gives a method of handling
an extended variable structure.
It consists of the name of the constructor;
a list of functions that extract each field of the constructor,
and a theorem that states 
how the extraction functions extract from a data construction,
and that the data constructor may be applied to the extracted
values to regain the original value.
For instance, for pairs the information is:
=GFT
	(",",
	([¬Fst®,¬Snd®],
	`ô µ x y p ·
		Fst (x, y) = x ± Snd (x, y) = y ±
		(Fst p, Snd p) = p)`))
=TEX
There are no subfields to this field, so
``setting'' overwrites the field with the proof context's name,
``getting'' returns the field.
=FAILURE
51010	There is no proof context with key ?0
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val Ûicl'set_eval_ad_¶_vs_thmÝ : ((string * (TERM list * THM)) ->
	(string * (TERM list * THM)) list) -> unit;
val Ûcurrent_ad_¶_vs_thmÝ : unit -> 
	(string * (TERM list * THM)) list;
=DESCRIBE
These functions provide the interface to the application data
variable structure information for the existence prover
$prove\_¶\_conv$.
The first sets the evaluator, the second extracts the field
in the current proof context.
=ENDDOC
=DOC
val Ûmerge_pcÝ : string list -> string -> unit;
=DESCRIBE
$merge\_pc$ $keys$ $tokey$ takes a list of committed proof contexts named by $keys$,
and merges their fields into the named proof context's fields,
discarding duplicates.
For each field that has subfields the lists of subfields from each proof context are appended, discarding
subfields with duplicate keys,
and if a field is not divided into subfields, then the proof contexts fields are appended, discarding duplicates.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 which is not in scope
51015	Proof context ?0 was created in theory ?1 in a now deleted definition level
51016	Proof context ?0 has been committed
51017	Proof context ?0 has not been committed
=ENDDOC
=DOC
val Ûmerge_pc_fieldsÝ : {context:string,fields:string list}list -> string -> unit;
=DESCRIBE
$merge\_pcs$ $fields$ $tokey$ 
merges the fields noted for each committed proof context into the named proof context's fields,
discarding duplicates.
Merging for each field that has subfields the lists of subfields is appending the proof contexts fields, discarding
subfields with duplicate keys,
and if a field is not divided into subfields, then the proof contexts fields are appended, discarding duplicates.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 which is not in scope
51015	Proof context ?0 was created in theory ?1 in a now deleted definition level
51016	Proof context ?0 has been committed
51017	Proof context ?0 has not been committed
=ENDDOC
=TEX
We use a stack of (temporarily) superseded proof contexts to simplify the task 
of ``change the context,
do some work, and then revert to the previous context'',
for this is an obvious approach.
=DOC
val Ûpush_pcÝ : string -> unit;
val Ûset_pcÝ : string -> unit;
=DESCRIBE
$push\_pc$ stacks the previous proof context, and
and sets the proof context of the system to the proof 
context with the given key.
$set\_pc$ discards the previous proof context, and
and sets the proof context of the system to the proof 
context with the given key.

The current proof context is accessed by the functions prefixed $current\_ad\_$.
=SEEALSO
$pop\_pc$, $push\_pcs$, $set\_pcs$
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 which is not in scope
51015	Proof context ?0 was created in theory ?1 in a now deleted definition level
=ENDDOC
=DOC
val Ûpush_pcsÝ : string list -> unit;
val Ûset_pcsÝ : string list -> unit;
=DESCRIBE
$push\_pcs$ stacks the previous proof context, and
and sets the proof context of the system to the merge of the proof 
contexts with the given keys.
$set\_pcs$ discards the previous proof context, and
and sets the proof context of the system to the merge of the proof 
contexts with the given keys.
Merged proof contexts upon the stack will have ``current proof context name'' of the names of the constituent proof contexts, comma'ed together,
and will be formed in the same manner as $merge\_pc$ would
merge the named proof contexts into a empty proof context.
However, the proof contexts used need not have been committed.
=SEEALSO
$pop\_pc$
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 which is not in scope
51015	Proof context ?0 was created in theory ?1 in a now deleted definition level
=ENDDOC
=DOC
val Ûpop_pcÝ : unit -> unit;
=DESCRIBE
This function unstacks the top of the proof context stack,
sets the proof context of the system to it, and returns the previous current proof context.
There will always be a current proof context, though it may be the trivial ``initial'' proof context.
=SEEALSO
$push\_pc$, $set\_pc$
=FAILURE
51001	The proof context stack is empty
=ENDDOC
=DOC
(* proof context key "ÛinitialÝ" *)
=DESCRIBE
This is the ``empty'' proof context, formed with empty lists.
It thus has no default rewriting or stripping theorems,
no default rewriting canonicalisation, and its automated existence
prover fails on any input.
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of ProofContext *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


