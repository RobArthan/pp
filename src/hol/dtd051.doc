=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Proof Contexts}  %% Mandatory field
\def\TPPheadtitle{Proof Contexts}
\TPPref{DS/FMU/IED/DTD051}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{K.~Blackburn & WIN01\\R.D.Arthan & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the detailed design for providing proof contexts.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Try again.
\item [Issue 1.3]
And again.
\item [Issue 1.4]
Tidying up after doing implementation.
\item [Issue 1.5]
Moved to using abstract data types.
\item [Issue 1.6]
Gains equational context material.
\item [Issue 1.7]
Added $get\_(e)pc\_cs\_¶\_rule$.
\item [Issue 1.8]
Added existence prover parameterisation.

\item[Issue \SCCSversion, \FormatDate{92/01/20} ] Updated to use new fonts.

\end{description}
\subsection{Changes Forecast}
This document needs to know which functions it may
give context for, and the type of the proof context details.
Thus if a new tool using context is added to the system then this document will need
modification.

In particular, the expected resolution tool will be parameterised in some manner yet to be decided,
and when introduced will require changes to this document
and its implementation.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
provision of proof contexts.
This is called for in section \cite{DS/FMU/IED/HLD???}.
The design is implemented in \cite{DS/FMU/IED/IMP051}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
A proof context is a setting of various
parameters of proof tools to support a particular mode of proof.
For instance, both $rewrite\_tac$ and $strip\_tac$ 
are proof tools that may be parameterised.
In particular, proof contexts will be later made available,
through the tools supplied here,
that supply a good environment to reason about Z,
or within a particular theory (e.g. set theory),
and alter the default environment.

An alternative approach to the one chosen is to take a 
proof context to be a labeled list of functions of type $:unit\ ->\ unit$.
A proof context would then be ``set'' by applying each function in the proof context to $()$.
This has the advantage that new context-sensitive tools could be
introduced without a system rebuild.
However, one loses the ability to display even parts
of the context, or access to the data to which
an individual function could be set.
\subsubsection{Dependencies}
This document is dependent on \cite{DS/FMU/IED/IMP008}.
It also depends on knowledge of what context-sensitive tools it
needs to cover.
It further depends on being able to create at least dummy
values for the parameters of these functions.
\subsubsection{Deficiencies}
We fail to give the developer of a context-sensitive proof tool the means to add an ``understanding'' of the new tool without
modifying this document and its implemetation.
They will have to modify this document and its implementation and then rebuild the system
(an approach only available to someone supplied with the means to do a system build), or provide their own proof context
tools, perhaps ``piggy backing'' upon the ones supplied here.

\subsubsection{Possible Enhancements}
Proof contexts are often associated with theories,
so it might be nice if the theory lister tells you the names
of those contexts associated with the theory listed.
\subsubsection{Terminology}
An {\em equational context} is a list of conversions,
each paired with term index. It represents a context that states
how to
rewrite a term to result in an equational theorem,
guided by the outermost form of the term to be rewritten.
An equational context will be of type $EQN\_CXT$
(== $(TERM\ *\ CONV)list$).

A {\em proof context} holds the data used to provide context for selected proof tools
(currently rewriting and stripping).
It may either be in a user-interface form, with type $PROOF\_CONTEXT$,
or in an evaluated form, with type $EPROOF\_CONTEXT$.

\section{THE DESIGN}
=DOC
signature ÛProofContextÝ = sig
=DESCRIBE
This provides the basic tools for handling proof contexts.
=ENDDOC
\subsection{Equational Contexts}
=DOC
type ÛEQN_CXTÝ;
=DESCRIBE
This is the type of equational contexts.
An equational context is a list of conversions,
each paired with term index. It represents a statement of
how to
rewrite a term to result in an equational theorem,
guided by the outermost form of the term to be rewritten,
which is matched against the term index of each conversion.
It is used to create a single conversion via $eqn\_cxt\_conv$ (q.v.).

A theorem may be converted into a member of 
an equational context by $thm\_eqn\_cxt$.
A pre-existing conversion may be converted by determining
the term index that matches at least all terms that 
the conversion must work on
(see $net\_enter$ for details), and pair it with the conversion.
=GFT
type EQN_CXT = (TERM * CONV) list;
=TEX
Note that equational contexts can be merged by appending.
An equational context may be transformed into a conversion 
discrimination net by $make\_net$ or $list\_net\_enter$(q.v.).
=ENDDOC
=DOC
val Ûthm_eqn_cxtÝ : THM -> (TERM * CONV);
=DESCRIBE
A theorem may be transformated into a suitable member of 
an equational context ($EQN\_CXT$ q.v.)
by $thm\_eqn\_cxt$:
=GFT
thm_eqn_cxt `‡ ô µ x1 ... · LHS = RHS` ­
	(LHS, simple_eq_match_1_conv `‡ ô µ x1 ... · LHS = RHS`)
=TEX
where the universal quantifiers must be simple.
=SEEALSO
$cthm\_eqn\_cxt$ which canonicalises
a theorem before transformation.
=FAILURE
7095	?0 is not of the form `‡ ô µ x1 ... xn · u = v' where ¬xi® are variables
=ENDDOC
=DOC
val Ûeqn_cxt_convÝ : EQN_CXT -> CONV;
=DESCRIBE
This function creates a single conversion from an equational
context.
This is done via $make\_net$ and $net\_lookup$(q.v).
There is an implicit $CHANGED\_C$ wrapped around each
conversion in the equational context.
=FAILURE
51005	Equational context gave no conversions that succeeded for ?0
=ENDDOC

\subsection{Proof Contexts}
The goal of the following functions is:
\begin{enumerate}
\item
To give a naive user a simple command to change
the proof context.
This will change the individual context of all context-sensitive proof tools,
to provide the best context available for the style of work they are to then carry out.
\item
To give the developer of, say, a new theory the means
to create a proof context suitable for reasoning in that theory.
\item
To allow a piece of proof automation to change the proof context,
do some work, and then revert to the previous context.
\item
To provide a single place where all context-sensitive tools look
for their contexts.
\end{enumerate}
We then first have the user presentation of a proof context:
=DOC
type ÛPROOF_CONTEXTÝ;
=DESCRIBE
This is the type of a proof context, which holds the data used to provide context for selected proof tools
(currently rewriting and stripping).
A proof context is set by first evaluating something of
this type, using $evaluate\_proof\_context$ (q.v.),
and then setting the result using $push\_proof\_context$ (q.v.)
This is an abstract data type, with interface functions:
=GFT
set_pc_name			get_pc_name
set_pc_rw_eqn_cxt		get_pc_rw_eqn_cxt
set_pc_rw_canons		get_pc_rw_canons
set_pc_st_eqn_cxt		get_pc_st_eqn_cxt
set_pc_sg_eqn_cxt		get_pc_sg_eqn_cxt
set_pc_cs_¶_rule			get_pc_cs_¶_rule
set_pc_¶_cd_thm			get_pc_¶_cd_thm
set_pc_¶_vs_thm			get_pc_¶_vs_thm
=TEX
(see descriptions of individual functions for details)

In naming the interface functions (other than $set\_pc\_name$) we use the convention:
=GFT
<set|get>_pc_<proof tool>_<modifier>
=TEX
The proof tools in the above are: $rw$ for rewriting,
$st$ for stripping theorems, $sg$ for stripping goals,
$cs$ for constant specifications,
and $¶$ for the exitence prover $prove\-\_¶\-\_conv$.
$initial\_pc$(q.v.) is a ``no effect'' proof context.
=ENDDOC

It is intended that a designer of, say, a theory would 
work out a few (often only one) proof contexts
for working with the theory.
They would bind these to ML variables, and would
likewise bind the evaluated forms (see below).
If a user then wanted, say, the standard rewriting equational context
for that theory they would extract it from the ML variable bound to the appropriate unevaluated proof context,
rather than expecting to find it
separately stored.
We wish to be able to set such a proof context
with no more evaluation cost than a few assignments.
This implies that we must to do any pre-evaluation
at the point of creation of a context, rather than the setting of the context.
This evaluated proof context is of type:
=DOC
type ÛEPROOF_CONTEXTÝ;
=DESCRIBE
This is the type of an evaluated proof context, which holds the data used to provide individual contexts for certain proof tools,
in a form where setting context only requires an assignment to a variable.
Objects of this type are created by $evaluate\_proof\_context$ (q.v.),
or ``by hand'',
and may be set by $push\_proof\_context$
(q.v.).
This is an abstract data type, with interface functions:
=GFT
set_epc_name			get_epc_name
set_epc_rw_net		get_epc_rw_net
set_epc_rw_canon		get_epc_rw_canon
set_epc_st_conv		get_epc_st_conv
set_epc_sg_conv		get_epc_sg_conv
set_epc_cs_¶_rule		get_epc_cs_¶_rule
set_epc_¶_cd_thm			get_epc_¶_cd_thm
set_epc_¶_vs_thm			get_epc_¶_vs_thm
=TEX
(see descriptions of individual functions for details)

In naming the interface functions (other than $set\_epc\_name$)
we use the convention:
=GFT
<set|get>_epc_<proof tool>_<modifier>
=TEX
The proof tools in the above are: $rw$ for rewriting,
$st$ for stripping theorems, $sg$ for stripping goals,
$cs$ for constant specifications,
and $¶$ for the exitence prover $prove\-\_¶\-\_conv$.
$initial\_epc$(q.v.) is a ``no effect'' evaluated proof context
(not the same as the evaluation of $initial\_pc$ however).
=ENDDOC

=DOC
val Ûset_pc_nameÝ : string -> 
	PROOF_CONTEXT -> PROOF_CONTEXT;
val Ûget_pc_nameÝ : PROOF_CONTEXT -> string;
=DESCRIBE
These functions provide the obvious interface to the name of a proof context
=SEEALSO
$PROOF\_CONTEXT$
=ENDDOC
=DOC
val Ûset_epc_nameÝ : string -> 
	EPROOF_CONTEXT -> EPROOF_CONTEXT;
val Ûget_epc_nameÝ : EPROOF_CONTEXT -> string;
=DESCRIBE
These functions provide the obvious interface to the name
held in an evaluated proof context.
=SEEALSO
$EPROOF\_CONTEXT$
=ENDDOC
=DOC
val Ûset_pc_rw_eqn_cxtÝ : EQN_CXT -> 
	PROOF_CONTEXT -> PROOF_CONTEXT;
val Ûget_pc_rw_eqn_cxtÝ : PROOF_CONTEXT -> EQN_CXT;
=DESCRIBE
These functions provide the obvious interface to the equational context for rewriting (see e.g. $rewrite\_tac$)
held in a proof context
=SEEALSO
$PROOF\_CONTEXT$, $EQN\_CXT$
=ENDDOC
=DOC
val Ûset_epc_rw_netÝ : CONV NET -> 
	EPROOF_CONTEXT -> EPROOF_CONTEXT;
val Ûget_epc_rw_netÝ : EPROOF_CONTEXT -> CONV NET;
=DESCRIBE
These functions provide the obvious interface to the initial conversion net for rewriting (see e.g. $rewrite\_tac$)
held in an evaluated proof context.
=SEEALSO
$EPROOF\_CONTEXT$
=ENDDOC
=DOC
val Ûset_pc_rw_canonsÝ : (THM -> THM list) list -> 
	PROOF_CONTEXT -> PROOF_CONTEXT;
val Ûget_pc_rw_canonsÝ : PROOF_CONTEXT -> (THM -> THM list) list;
=DESCRIBE
These functions provide the obvious interface to the individual canonicalisation functions used to create the canonicalisation function applied to rewriting theorems (see e.g. $rewrite\_tac$)
held in a proof context.
=SEEALSO
$PROOF\_CONTEXT$, $CANON$
=ENDDOC
=DOC
val Ûset_epc_rw_canonÝ : (THM -> THM list) -> 
	EPROOF_CONTEXT -> EPROOF_CONTEXT;
val Ûget_epc_rw_canonÝ : EPROOF_CONTEXT -> 
	(THM -> THM list);
=DESCRIBE
These functions provide the obvious interface to the canonicalisation function applied to rewriting theorems (see e.g. $rewrite\_tac$)
held in an evaluated proof context.

The evaluated canonicalisation can be formed from the unevaluated
list of arguments as described in the documentation of $REWRITE\_CAN$.
=SEEALSO
$EPROOF\_CONTEXT$, $CANON$
=ENDDOC
=DOC
val Ûset_pc_st_eqn_cxtÝ : EQN_CXT -> 
	PROOF_CONTEXT -> PROOF_CONTEXT;
val Ûget_pc_st_eqn_cxtÝ : PROOF_CONTEXT -> EQN_CXT;
=DESCRIBE
These functions provide the obvious interface to the equational context for stripping theorems into the
assumption list (see e.g. $strip\_tac$)
held in a proof context.
=SEEALSO
$PROOF\_CONTEXT$, $EQN\_CXT$
=ENDDOC
=DOC
val Ûset_epc_st_convÝ : CONV -> 
	EPROOF_CONTEXT -> EPROOF_CONTEXT;
val Ûget_epc_st_convÝ : EPROOF_CONTEXT -> CONV;
=DESCRIBE
These functions provide the obvious interface to the conversion for stripping theorems into the
assumption list (see e.g. $strip\_tac$)
held in an evaluated proof context.
=SEEALSO
$EPROOF\_CONTEXT$
=ENDDOC
=DOC
val Ûset_pc_sg_eqn_cxtÝ : EQN_CXT -> 
	PROOF_CONTEXT -> PROOF_CONTEXT;
val Ûget_pc_sg_eqn_cxtÝ : PROOF_CONTEXT -> EQN_CXT;
=DESCRIBE
These functions provide the obvious interface to the equational context for stripping goals (see e.g. $strip\_tac$)
held in a proof context.
=SEEALSO
$PROOF\_CONTEXT$, $EQN\_CXT$
=ENDDOC
=DOC
val Ûset_epc_sg_convÝ : CONV -> 
	EPROOF_CONTEXT -> EPROOF_CONTEXT;
val Ûget_epc_sg_convÝ : EPROOF_CONTEXT -> CONV;
=DESCRIBE
These functions provide the obvious interface to the conversion for stripping goals (see e.g. $strip\_tac$)
held in an evaluated proof context.
=SEEALSO
$EPROOF\_CONTEXT$
=ENDDOC
=DOC
val Ûset_pc_cs_¶_ruleÝ : (TERM -> THM) -> 
	PROOF_CONTEXT -> PROOF_CONTEXT;
val Ûget_pc_cs_¶_ruleÝ : PROOF_CONTEXT -> (TERM -> THM);
=DESCRIBE
These functions provide the obvious interface to the 
existence prover for constant specifications (see $const\_spec$)
held in a proof context.
=SEEALSO
$EPROOF\_CONTEXT$
=ENDDOC
=DOC
val Ûset_epc_cs_¶_ruleÝ : (TERM -> THM) -> 
	EPROOF_CONTEXT -> EPROOF_CONTEXT;
val Ûget_epc_cs_¶_ruleÝ : EPROOF_CONTEXT -> (TERM -> THM);
=DESCRIBE
These functions provide the obvious interface to the 
existence prover for constant specifications (see $const\_spec$)
held in an evaluated proof context.
=SEEALSO
$EPROOF\_CONTEXT$
=ENDDOC
=DOC
val Ûset_pc_¶_cd_thmÝ : THM list -> PROOF_CONTEXT 
	-> PROOF_CONTEXT;
val Ûget_pc_¶_cd_thmÝ : PROOF_CONTEXT -> THM list;
=DESCRIBE
These functions provide the obvious interface to the
unevaluated  
clausal definition theorems held for the existence prover
$prove\_¶\_conv$.
=SEEALSO
$PROOF\_CONTEXT$
See $evaluate\_¶\_cd\_thm$ for details upon the form
of the theorems.
=ENDDOC
=DOC
val Ûset_epc_¶_cd_thmÝ : 
	(TERM list * int list * TYPE * (TERM list)list * THM) list 
	-> EPROOF_CONTEXT 
	-> EPROOF_CONTEXT;
val Ûget_epc_¶_cd_thmÝ : EPROOF_CONTEXT -> 
	(TERM list * int list * TYPE * (TERM list)list * THM) list;
=DESCRIBE
These functions provide the obvious interface to the 
clausal definition theorem information for the existence prover
$prove\_¶\_conv$.
=SEEALSO
$EPROOF\_CONTEXT$
See $evaluate\_¶\_cd\_thm$ for details upon the form
of the information.
=ENDDOC
=DOC
val Ûset_pc_¶_vs_thmÝ : (string * (TERM list * THM)) list
 	-> PROOF_CONTEXT 
	-> PROOF_CONTEXT;
val Ûget_pc_¶_vs_thmÝ : PROOF_CONTEXT ->
	(string * (TERM list * THM)) list;
val Ûset_epc_¶_vs_thmÝ : (string * (TERM list * THM)) list
 	-> EPROOF_CONTEXT 
	-> EPROOF_CONTEXT;
val Ûget_epc_¶_vs_thmÝ : EPROOF_CONTEXT ->
	(string * (TERM list * THM)) list;
=DESCRIBE
These functions provide the obvious interface to the
variable structure information for the existence prover
$prove\_¶\_conv$.
The nature of the information handled is the same 
for both the evaluated and unevaluated forms.
An individual entry in the list gives a method of handling
an extended variable structure.
It consists of the name of the constructor;
a list of functions that extract each field of the constructor,
and a theorem that states 
how the extraction functions extract from a data construction,
and that the data contructor may be applied to the extracted
values to regain the orignal value.
For instance, for pairs the information is:
=GFT
	(",",
	([¬Fst®,¬Snd®],
	`ô µ x y p ·
		Fst (x, y) = x ± Snd (x, y) = y ±
		(Fst p, Snd p) = p)`))
=TEX
=ENDDOC
=DOC
val Ûinitial_pcÝ : PROOF_CONTEXT;
val Ûinitial_epcÝ : EPROOF_CONTEXT;
=DESCRIBE
These are the initial proof context, and the initial evaluated proof context.
They contain the appropriate ``no effect'' data for each
part of the contexts.
They are named ``$initial\_pc$'' and ``$initial\_epc$''.
Note that $evaluate\_proof\_context$ $initial\_pc$ is not
equal to $initial\_epc$, as the later does no
canonicalisation, whereas the former will place $...\ ¤\ T$
in theorems that are not universally quantified equations.
=ENDDOC
=DOC
val Ûmerge_proof_contextÝ : PROOF_CONTEXT -> 
	PROOF_CONTEXT -> PROOF_CONTEXT;
=DESCRIBE
This function merges two unevaluated proof contexts
to gain a third, that is the sum of their effects.
The merging is simplistic (e.g. if merging list components then the second list is appended to the end of the first), and therefore the merged context
may be inefficient compared to a ``hand-crafted'' one,
and there may be interference between the components of
the two contexts (e.g. hiding of effects or introduction
of the possibility of looping).
The name of the result will be
=GFT
<name1> ^ " and " ^ <name2>
=TEX
=SEEALSO
$PROOF\_CONTEXT$
=ENDDOC

Pre-evaluation will be done by combining functions supplied
by individual tools into the single function.
This implies that all context-sensitive proof tools will be
supplied with pre-evaluation functions
(perhaps of more general use than for the individual function);
and will get their individual context by accessing the current proof context
via $get\_proof\_context$.

Thus the function, $evaluate\_proof\_context$ cannot be defined until after all the context-sensitive tools are implemented.
=IGN
 =DOC
val Ûevaluate_proof_contextÝ : PROOF_CONTEXT -> EPROOF_CONTEXT;
 =DESCRIBE
This function does all possible pre-evaluation
of the material stored in an object of type $PROOF\_CONTEXT$,
leaving the result in a form where setting the context only requires assignment to variables.
Such a context is then set by $push\_proof\_context$
(q.v.).
 =FAILUREC
\paragraph{Errors}
Any error messages given by the constituent pre-evaluation
functions will be transparently passed through this function.
 =ENDDOC
=TEX
Our current proof context, to which all context-sensitive tools look
to find their contextual data, is accessed by:
=DOC
val Ûget_proof_contextÝ : unit -> EPROOF_CONTEXT;
=DESCRIBE
This function gets the current (evaluated) proof context, to which all context-sensitive tools look
to find their contextual data.
=SEEALSO
$push\_proof\_context$, $pop\_proof\_context$
=ENDDOC
=TEX
We use a stack of (temporarily) superseded proof contexts to simplify the task 
of ``change the context,
do some work, and then revert to the previous context'',
for this is the obvious approach.
=DOC
val Ûpush_proof_contextÝ : EPROOF_CONTEXT -> unit;
=DESCRIBE
This function stacks the previous proof context, and
and sets the proof context of the system to the new proof 
context.
=SEEALSO
$pop\_proof\_context$, $get\_proof\_context$
=ENDDOC
=DOC
val Ûpop_proof_contextÝ : unit -> EPROOF_CONTEXT;
=DESCRIBE
This function unstacks the top of the proof context stack,
sets the proof context of the system to it, and returns the previous current proof context.
=SEEALSO
$push\_proof\_context$, $get\_proof\_context$
=FAILURE
51001	The proof context stack is empty
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of ProofContext *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


