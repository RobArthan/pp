=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Proof Contexts}  %% Mandatory field
\def\TPPheadtitle{Proof Contexts}
\TPPref{DS/FMU/IED/DTD051}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{K.~Blackburn & WIN01\\R.D.Arthan & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the detailed design for providing proof contexts.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Try again.
\item [Issue 1.3]
And again.
\item [Issue 1.4]
Tidying up after doing implementation.
\item [Issue 1.5]
Moved to using abstract data types.
\item [Issue 1.6]
Gains equational context material.
\item [Issue 1.7]
Added $get\_(e)pc\_cs\_∂\_rule$.
\item [Issue 1.8]
Added existence prover parameterisation.

\item[Issue 1.9, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.10]
Changed to using a dictionary of proof contexts.
\item [Issue 1.11]
Variation on a theme.
\item [Issue 1.12]
Changes after comments on 1.11.
\item [Issue 1.13]
Changes after RBJ comments.
\item [Issue 1.14]
Changes after RBJ/RDA comments.
\item [Issue 1.15]
Typo fixed.
\item [Issue 1.16 (13th April 1992)]
Changes due to CR0017.
\end{description}
\subsection{Changes Forecast}
The designer of this document needs to know which functions it may
give context for, and the type of the proof context details.
Thus if a new tool using context is added to the system then this document will need
modification.

In particular, the expected resolution tool will be parameterised in some manner yet to be decided,
and when introduced will require changes to this document
and its implementation.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
provision of proof contexts.
This is called for in \cite{DS/FMU/IED/HLD009}.
The design is implemented in \cite{DS/FMU/IED/IMP051}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
A proof context is a setting of various
parameters of proof tools to support a particular mode of proof.
For instance, both $rewrite\_tac$ and $strip\_tac$ 
are proof tools that may be parameterised.
In particular, proof contexts will be later made available,
through the tools supplied here,
that supply a helpful environment to reason about Z,
or within a particular theory (e.g. set theory),
and alter the default environment.

An alternative approach to the one chosen is to take a 
proof context to be a labeled list of functions of type $:unit\ ->\ unit$.
A proof context would then be ``set'' by applying each function in the proof context to $()$.
This has the advantage that new context-sensitive tools could be
introduced without a system rebuild.
However, one loses the ability to display even parts
of the context, or access to the data to which
an individual function could be set.
\subsubsection{Dependencies}
This document is dependent on \cite{DS/FMU/IED/IMP008}.
It also depends on knowledge of what context-sensitive tools it
needs to cover.
It further depends on being able to create at least dummy
values for the parameters of these functions.
\subsubsection{Deficiencies}
We fail to give the developer of a context-sensitive proof tool the ability to add an ``understanding'' of the new tool without
modifying this document and its implementation.
They will have to modify this document and its implementation and then rebuild the system
(an approach only available to someone supplied with the ability to do a system build), or provide their own proof context
tools, perhaps building upon the ones supplied here.

\subsubsection{Possible Enhancements}
Proof contexts are often associated with theories,
so it might be nice if the theory lister tells you the names
of those contexts associated with the theory listed.
Such a feature would probably require an interface in this document.
\subsubsection{Terminology}
An {\em equational context} is a list of conversions,
each paired with term index. It represents a context that states
how to
rewrite a term to result in an equational theorem,
guided by the outermost form of the term to be rewritten.
An equational context will be of type $EQN\_CXT$
(= $(TERM\ *\ CONV)list$).

A {\em proof context} holds the data used to provide context for selected proof tools.

\section{THE SIGNATURE}
=DOC
signature €ProofContext› = sig
=DESCRIBE
This provides the basic tools for handling equational and proof contexts.
To keep them short, the names in the structure are heavily abbreviated.
The abbreviations used are:

\begin{centering}

\begin{tabular}{| l | l |} \hline
pc(s) & proof context(s) \\
rw & rewriting \\
cs & constant specification \\
$∂$ & existential theorem prover \\
sg & goal stripping \\
st & theorem stripping \\
cd & clausal definition \\
vs & variable structure \\
ad & application data \\
net & discrimination net \\
eqn$\_$cxt & equational context \\
canon(s) & theorem canonicalisation \\ \hline
\end{tabular}

\end{centering}
=ENDDOC
\section{EQUATIONAL CONTEXTS}
=DOC
type €EQN_CXT›;
=DESCRIBE
This is the type of equational contexts.
An equational context is a list of conversions,
each paired with term index. It represents a statement of
how to
rewrite a term to result in an equational theorem,
guided by the outermost form of the term to be rewritten,
which is matched against the term index of each conversion.
It is used to create a single conversion via $eqn\_cxt\_conv$ (q.v.).

A theorem may be converted into a member of 
an equational context by $thm\_eqn\_cxt$.
A pre-existing conversion may be converted by determining
the term index that matches at least all terms that 
the conversion must work on
(see $net\_enter$ for details), and pair it with the conversion.
=GFT
type EQN_CXT = (TERM * CONV) list;
=TEX
Note that equational contexts can be merged by appending.
An equational context may be transformed into a conversion 
discrimination net by $make\_net$ or $list\_net\_enter$(q.v.).
=ENDDOC
=DOC
val €thm_eqn_cxt› : THM -> (TERM * CONV);
=DESCRIBE
A theorem may be transformed into a suitable member of 
an equational context ($EQN\_CXT$ q.v.)
by $thm\_eqn\_cxt$:
=GFT
thm_eqn_cxt `á Ù µ x1 ... ∑ LHS = RHS` ≠
	(LHS, simple_eq_match_conv1 `á Ù µ x1 ... ∑ LHS = RHS`)
=TEX
where the universal quantifiers must be simple binders.
=SEEALSO
$cthm\_eqn\_cxt$ which canonicalises
a theorem before transformation.
=FAILURE
7095	?0 is not of the form `á Ù µ x1 ... xn ∑ u = v' where ¨xiÆ are variables
=ENDDOC
=DOC
val €eqn_cxt_conv› : EQN_CXT -> CONV;
=DESCRIBE
This function creates a single conversion from an equational
context.
This is done via $make\_net$ and $net\_lookup$(q.v).
There is a $CHANGED\_C$ wrapped around each
conversion in the equational context.
=FAILURE
51005	Equational context gave no conversions that succeeded for ?0
=ENDDOC

\section{PROOF CONTEXTS}
\subsection{Discussion}
The goal of the following functions is:
\begin{enumerate}
\item
To give a naive user a simple command to change
the proof context.
This will change the individual context of all context-sensitive proof tools,
to provide the best context available for the style of work they are to then carry out.
The new context may be a merge of various supplied prof contexts.
\item
To give a more experienced user the ability to merge
together the effect of various proof contexts into the current proof context.
\item
To give the developer of, say, a new theory the means
to create a proof context suitable for reasoning in that theory.
\item
To allow a piece of proof automation to change the proof context,
do some work, and then revert to the previous context.
\item
To provide a single place where all context-sensitive tools look
for their contexts.
\end{enumerate}
We implement proof contexts by maintaining two data structures:
a database of proof contexts, in which a proof context is a record
in the database, and a particular part of the proof context is
a field of the proof context;
and a stack of proof contexts, which has the current proof context as the top record.
Proof contexts are pushed onto the stack from the database,
they have no existence apart from within these two structures.

A proof context has a number of fields, each field relating
to some single area of context for a context-sensitive
proof tool.
A proof context is created by $new\-\_pc$.
Its fields are populated by data that comes from other
proof contexts in the database (by $merge\-\_pc$ and
$merge\-\_pc\-\_fields$), and that is entered by
the proof contexts creator.
A proof context in is in the middle of its creation may still be
pushed onto the proof context stack, but it may not be used
as the origin of data for a field of another proof context.
When a proof context is considered complete it is ``committed''
by $commit\-\_pc$, and it then becomes an
acceptable origin of data for other proof contexts.

Mechanisms keep track of the origin of data in each of a 
proof contexts fields by splitting it into subfields, to allow duplicated information to
be discarded when merging data from various proof contexts in a single field.
Each subfield is indexed by the proof context name from which it came.
This is also why we commit proof contexts, and why they may
only have data extracted for other proof contexts after their commital.
More than one proof context may be uncommitted at the same time.

The data a user might enter into a proof context
is not in the same form as context-sensitive applications accessing the proof context wish to see:
there is an evaluation step in between.
We therefore must provide methods of evaluating the 
user data to extract the application data.
As we cannot in all cases state this evaluation process
at the point of implementing this document
we provide the functions prefixed $icl'set\_eval\_???$ to allow
evaluation functions to be entered at a later date.
Uncommitted proof contexts are evaluated by the current
evaluation function when they are pushed onto the proof context stack,
committed contexts are evaluated at the point of commital
by the evaluation functions current at the time of commital
(saving the cost of multiple evaluations upon multiple pushes).
\subsection{Summary of Tools Supported and Provided}
Three tools have context-sensitive  behaviour supported
by proof contexts:
=GFT
rewrite_tac and its cousins
strip_tac and its cousins
prove_∂_conv and its users
=TEX

The user data tools are:
=GFT
set_rw_eqn_cxt	get_rw_eqn_cxt		add_rw_thms
set_rw_canons		get_rw_canons
set_st_eqn_cxt		get_st_eqn_cxt		add_st_thms
set_sg_eqn_cxt		get_sg_eqn_cxt		add_sg_thms
set_cs_∂_convs		get_cs_∂_convs
set_∂_cd_thms		get_∂_cd_thms		add_∂_cd_thms
set_∂_vs_thms		get_∂_vs_thms
=TEX
In naming the interface functions we use the convention:
=GFT
<set|get|add>_<proof tool>_<modifier>
=TEX
The proof tools in the above are: $rw$ for rewriting,
$st$ for stripping theorems, $sg$ for stripping goals,
$cs$ for constant specifications,
and $∂$ for the existence prover $prove\-\_∂\-\_conv$.
$set$ and $get$ functions overwrite or access the database respectively.
$add$ functions add unprocessed theorems
into a proof context, using some form of automated processing.

The applications data tools are:
=GFT
icl'set_eval_ad_rw_net		current_ad_rw_net
icl'set_eval_ad_rw_canon		current_ad_rw_canon
icl'set_eval_ad_st_conv		current_ad_st_conv
icl'set_eval_ad_sg_conv		current_ad_sg_conv
icl'set_eval_ad_cs_∂_conv		current_ad_cs_∂_conv
icl'set_eval_ad_∂_cd_thms		current_ad_∂_cd_thms
icl'set_eval_ad_∂_vs_thms		current_ad_∂_vs_thms
=TEX
In naming the applications data interface functions we use the convention:
=GFT
<icl'set_eval|current>_ad_<proof tool>_<modifier>
=TEX
The proof tools in the above are: $rw$ for rewriting,
$st$ for stripping theorems, $sg$ for stripping goals,
$cs$ for constant specifications,
and $∂$ for the existence prover $prove\-\_∂\-\_conv$.
$icl'set\_eval$
sets the method of evaluating the associated user data into application data,
and $current$ gives the current proof context's application data.

Note that an application data field in an uncommitted proof context could be directly modified, to $v$ say,
by setting its evaluation function to 
=INLINEFT
(fn _ => v)
=TEX
, committing the proof context,
and restoring the evaluation function to its previous value.
This might be a system builder's necessary trick,
it is certainly not a standard pattern of use.

To allow certain patterns of context changes, we have
a stack of proof contexts, with the current proof context at the top.
We provide applications with hooks to look into this current proof
context,
but no way to modify stacked proof contexts ``in place''.
In particular, if a proof context is stacked, then it
is in fact a copy that is stacked, so that later changes to the original do not affect the stack.

The database of proof contexts is initialised to contain
a single context with key ``initial'', which is also the initial current proof context
\subsection{Proof Context Database Functions}
=DOC
val €new_pc› : string -> unit;
=DESCRIBE
$new\_pc$ $new$
creates a new 
record in the proof context database, with key $new$.
The fields of the proof context are set to default values.
A note will be made of the current theory,
and its current definition level at the time of
creation, and an error will be raised
if an attempt is made to push the new proof context (see $push\_pc$) when
that theory is not in scope, or when the definition level
has been recorded as deleted.
The definition level will be recorded as deleted if, e.g., some definition
or axiom that was in scope in the original theory has since been deleted.

One responsibility of the creator of a proof context is to ensure that the theorems used within, or created by, the new context are also
in scope: this is not automatically checked.
=FAILURE
51011	There is already a proof context with key ?0
=ENDDOC
=DOC
val €delete_pc› : string -> unit;
=DESCRIBE
This deletes a record from the proof context database.
The record with key ``initial'' may not be deleted.
=FAILURE
51010	There is no proof context with key ?0
51012	Initial proof context may not be deleted
=ENDDOC
=DOC
val €commit_pc› : string -> unit;
=DESCRIBE
This commits a record of the proof context database,
preventing further change, and allowing it to be used in
the creation of further records.
=FAILURE
51010	There is no proof context with key ?0
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val €show_pcs› : unit -> (string * string) list;
=DESCRIBE
This lists the names of the proof contexts held in the proof context
database, and the theory that was current at their time of creation.
If the theory has since been deleted or if the definition level becomes deleted, e.g.
because an axiom or definition has been deleted,
then this will output 
=INLINEFT
("context name","theory name (out of scope, deleted, or modified)")
=TEX
=ENDDOC
=DOC
val €merge_pcs› : string list -> string -> unit;
=DESCRIBE
$merge\_pcs$ $keys$ $tokey$ takes a list of committed proof contexts named by $keys$,
and merges their fields into proof context $tokey$'s fields,
discarding duplicates.
For each field that has subfields the lists of subfields from each proof context are appended, discarding
subfields with duplicate keys,
and if a field is not divided into subfields, then the proof contexts fields are appended, discarding duplicates.
The head of the list of proof contexts to merge into $tokey$
will be merged in last.

Failure to extract any proof context for merging will result in the
proof context $tokey$ being unchanged.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
51017	Proof context ?0 has not been committed
=ENDDOC
=DOC
val €merge_pc_fields› : {context:string,fields:string list}list -> string -> unit;
=DESCRIBE
$merge\_pc\_fields$ $fields$ $tokey$ 
merges the fields noted for each committed proof context in $fields$ into proof context $tokey$'s fields,
discarding duplicates.
Merging for each field that has subfields the lists of subfields is appending the proof contexts fields, discarding
subfields with duplicate keys,
and if a field is not divided into subfields, then the proof contexts fields are appended, discarding duplicates.
The head of the list of proof contexts to merge into $tokey$
will be merged in last.

Failure to extract any proof context for merging will result in the
proof context $tokey$ being unchanged.

Valid field names are:
=GFT
"rw_eqn_cxt","rw_canons","st_eqn_cxt","sg_eqn_cxt",
"cs_∂_rules","∂_cd_thms","∂_vs_thms"
=TEX
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
51017	Proof context ?0 has not been committed
51019	There is no field called ?0
=ENDDOC
\subsection{Proof Context Field Functions}
The following functions relate to individual fields
of proof contexts:
=DOC
val €set_rw_eqn_cxt› : EQN_CXT -> string -> unit;
val €get_rw_eqn_cxt› : string -> (EQN_CXT * string) list;
val €add_rw_thms› : THM list -> string -> unit;
=DESCRIBE
These functions provide the interface to the equational context for rewriting (see e.g. $rewrite\_tac$)
held in the user data of a proof context.
``setting'' overwrites the subfield whose key is the proof context's name,
``getting'' returns the entire field (which pairs data with
proof context names).
``adding'' processes its theorems by first canonicalising according to the stated proof contexts canonicalisation function, and then with $thm\_eqn\_cxt$ and
then adds them into the subfield whose key is the proof context's name.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val €icl'set_eval_ad_rw_net› : (EQN_CXT -> CONV NET) -> unit;
val €current_ad_rw_net› : unit -> CONV NET;
=DESCRIBE
These functions provide the interface to the initial conversion net for rewriting (see e.g. $rewrite\_tac$)
held in the application data of a proof context.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_rw\_eqn\_cxt$ for the associated user data.
=ENDDOC
=DOC
val €set_rw_canons› : (THM -> THM list) list -> 
	string -> unit;
val €get_rw_canons› : string -> ((THM -> THM list) list * string) list;
=DESCRIBE
These functions provide the interface to the individual canonicalisation functions used to create the canonicalisation function applied to rewriting theorems (see e.g. $rewrite\_tac$)
held in the user data of a proof context.

``setting'' overwrites the subfield whose key is the proof context's name,
``getting'' returns the entire field (which pairs data with
proof context names).
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val €icl'set_eval_ad_rw_canon› : ((THM -> THM list) list -> (THM -> THM list)) 
	-> unit;
val €current_ad_rw_canon› : unit -> (THM -> THM list);
=DESCRIBE
These functions provide the interface to the canonicalisation function applied to rewriting theorems (see e.g. $rewrite\_tac$)
held in the application data of a proof context.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_rw\_canons$ for the associated user data.
=ENDDOC
=DOC
val €set_st_eqn_cxt› : EQN_CXT -> string -> unit;
val €get_st_eqn_cxt› : string -> (EQN_CXT * string)list;
val €add_st_thms› : THM list -> string -> unit;
=DESCRIBE
These functions provide the interface to the equational context for stripping theorems into the
assumption list (see e.g. $strip\_tac$)
held in the user data of a proof context.
``setting'' overwrites the subfield whose key is the proof context's name,
``getting'' returns the entire field (which pairs data with
proof context names).
``adding'' processes its theorems  by first canonicalising according to the stated proof contexts canonicalisation function, and then with $thm\_eqn\_cxt$ and
then adds them into the subfield whose key is the proof context's name.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val €icl'set_eval_ad_st_conv› : (EQN_CXT -> CONV) -> unit;
val €current_ad_st_conv› : unit -> CONV;
=DESCRIBE
These functions provide the interface to the conversion for stripping theorems into the
assumption list (see e.g. $strip\_tac$)
held in the application data of a proof context.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_st\_conv$ for the associated user data.
=ENDDOC
=DOC
val €set_sg_eqn_cxt› : EQN_CXT -> string -> unit;
val €get_sg_eqn_cxt› : string -> (EQN_CXT * string) list;
val €add_sg_thms› : THM list -> string -> unit;
=DESCRIBE
These functions provide the interface to the equational context for stripping goal conclusions (see e.g. $strip\_tac$)
held in the user data of a proof context.
``setting'' overwrites the subfield whose key is the proof context's name,
``getting'' returns the entire field (which pairs data with
proof context names).
``adding'' processes its theorems by first canonicalising according to the stated proof contexts canonicalisation function, and then with $thm\_eqn\_cxt$ and
then adds them into the subfield whose key is the proof context's name.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val €icl'set_eval_ad_sg_conv› : (EQN_CXT -> CONV) -> unit;
val €current_ad_sg_conv› : unit -> CONV;
=DESCRIBE
These functions provide the interface to the conversion for stripping goal conclusions (see e.g. $strip\_tac$)
held in the application data of a proof context.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_sg\_conv$ for the associated user data.
=ENDDOC
=DOC
val €set_cs_∂_convs› : (CONV list) -> 
	string -> unit;
val €get_cs_∂_convs› : string -> 
	(((CONV list) * string) list);
=DESCRIBE
These functions provide the interface to the 
existence provers for constant specifications (see $const\_spec$)
held in the user data of a proof context.
Under the initial evaluator, the existence proving conversion supplied by $current\-\_cs\-\_∂\-\_conv$ will have each of the conversions 
tried, in the reverse order of their entry, 
being applied to the RHS of the result of the previous successful application, or the initial term to which the conversion was applied, until the RHS is $¨TÆ$, or no conversions remain.
=GFT Example
If get_cs_∂_convs of the current proof context returns

[([conv1, conv2],"pc1"),([conv3, conv4],"pc2")]

Then current_ad_cs_∂_conv  will return

conv1 AND_OR_C conv2 AND_OR_C conv3 AND_OR_C conv4
=TEX

``setting'' overwrites the subfield whose key is the proof context's name,
``getting'' returns the entire field (which pairs data with
proof context names).
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val €icl'set_eval_ad_cs_∂_convs› : (CONV list -> CONV)
	 -> unit;
val €current_ad_cs_∂_conv› : unit -> CONV;
=DESCRIBE
These functions provide the interface to the 
existence prover for constant specifications (see $const\_spec$)
held in the application data of a proof context.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_cs\_∂\_rule$ for the associated user data.
=FAILURE
51015	No automated existence prover in the current proof context succeeds
=ENDDOC
=DOC
val €set_∂_cd_thms› : THM list -> string -> unit;
val €get_∂_cd_thms› : string -> THM list;
val €add_∂_cd_thms› : THM list -> string -> unit;
=DESCRIBE
These functions provide the interface to the
unevaluated  
clausal definition theorems held for the existence prover
$prove\_∂\_conv$.
There are no subfields to this field, so
``setting'' overwrites the field with the proof context's name,
``getting'' returns the field.
``adding'' unions its theorem list with the proof contexts field.
=SEEALSO
See $evaluate\_∂\_cd\_thms$ for details upon the form
of the theorems.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val €icl'set_eval_ad_∂_cd_thms› : (THM list -> 
	(TERM list * int list * TYPE * (TERM list)list * THM) list) -> unit;
val €current_ad_∂_cd_thms› : unit -> 
	(TERM list * int list * TYPE * (TERM list)list * THM) list;
=DESCRIBE
These functions provide the interface to the 
clausal definition theorem information for the existence prover
$prove\_∂\_conv$.
See $evaluate\_∂\_cd\_thms$ for details upon the form
of the information.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_∂_cd_thms$ for the associated user data.
=ENDDOC
=DOC
val €set_∂_vs_thms› : (string * (TERM list * THM)) list
 	-> string -> unit;
val €get_∂_vs_thms› : string -> (string * (TERM list * THM)) list;
=DESCRIBE
These functions provide the interface to the
variable structure information for the existence prover
$prove\_∂\_conv$.
An individual entry in the list gives a method of handling
an extended variable structure.
It consists of the name of the constructor;
a list of functions that extract each field of the constructor,
and a theorem that states 
how the extraction functions extract from a data construction,
and that the data constructor may be applied to the extracted
values to regain the original value.
For instance, for pairs the information is:
=GFT
	(",",
	([¨FstÆ,¨SndÆ],
	`Ù µ x y p ∑
		Fst (x, y) = x ± Snd (x, y) = y ±
		(Fst p, Snd p) = p)`))
=TEX
There are no subfields to this field, so
``setting'' overwrites the field with the proof context's name,
``getting'' returns the field.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val €icl'set_eval_ad_∂_vs_thms› : ((string * (TERM list * THM)) list ->
	(string * (TERM list * THM)) list) -> unit;
val €current_ad_∂_vs_thms› : unit -> 
	(string * (TERM list * THM)) list;
=DESCRIBE
These functions provide the interface to the application data
variable structure information for the existence prover
$prove\_∂\_conv$.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_∂\_vs\_thms$ for user data.
=ENDDOC
=TEX
\subsection{Proof Context Stack Functions}
We use a stack of (temporarily) superseded proof contexts to simplify the task 
of ``change the context,
do some work, and then revert to the previous context'',
for this is an obvious approach.
=DOC
val €show_stack_pcs› : unit -> (string list * string) list;
=DESCRIBE
This lists the keys of the proof contexts held in the proof context
stack, and the theory that was current at their time of creation.
If a proof context is pushed onto the stack by, e.g. $push\_pc$, the ``keys'' will be the singleton list of the name of the source proof context.
If a proof context is pushed onto the stack by, e.g. $push\_merge\_pcs$, the ``keys'' will be the list of the names of the source proof contexts.
If the theory has since been deleted or if the definition level becomes deleted, e.g.
because an axiom or definition has been deleted,
then this will output 
=GFT
(["context name"],"theory name (out of scope, deleted, or modified)")
=TEX
Note that this function does not report on the current proof context - 
see $show\-\_current\-\_pc$ for this.
=ENDDOC
=FAILURE
51018	?0 (out of scope, deleted, or modified)
=TEX
=DOC
val €show_current_pc› : unit -> (string list * string);
=DESCRIBE
Returns the key(s) of the entries from which the
current proof context was copied, and the theory in which the single
proof context was created.
If the theory has since been placed out of scope, deleted or if the definition level becomes deleted, e.g.
because an axiom or definition has been deleted,
then this will output 
=GFT
(["context name"],"theory name (out of scope, deleted, or modified)")
=TEX
Note that the key may no longer access a proof context in the database identical to the current proof context.

Merged proof contexts upon the stack  (from $push\_merge\_pcs$ and  $set\_merge\_pcs$) will have the list of names of the constituent proof contexts, singleton contexts will have singleton lists.
=ENDDOC
=DOC
val €push_pc› : string -> unit;
val €set_pc› : string -> unit;
=DESCRIBE
$push\_pc$ stacks the previous proof context, and
and sets the proof context of the system to the proof 
context with the given key.
$set\_pc$ discards the previous proof context, and
and sets the proof context of the system to the proof 
context with the given key.

The current proof context is accessed by the functions prefixed $current\_ad\_$, and by $show\-\_current\-\_pc$.
=SEEALSO
$pop\_pc$, $push\_merge\_pcs$, $set\_merge\_pcs$
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
=ENDDOC
=DOC
val €push_merge_pcs› : string list -> unit;
val €set_merge_pcs› : string list -> unit;
=DESCRIBE
$push\_merge\_pcs$ stacks the previous proof context, and
and sets the proof context of the system to the merge of the proof 
contexts with the given keys.
$set\_merge\_pcs$ discards the previous proof context, and
and sets the proof context of the system to the merge of the proof 
contexts with the given keys.
Merged proof contexts upon the stack will have $current\-\_ad\-\_names$ giving the list of names of the constituent proof contexts, singleton contexts will have singleton lists.
The proof contexts used need not have been committed.

The current proof context is accessed by the functions prefixed $current\_ad\_$, and by $show\-\_current\-\_pc$.
=SEEALSO
$pop\_pc$, $push\_pc$, $set\_pc$
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51020	Must be at least one key in list
=ENDDOC
=DOC
val €pop_pc› : unit -> unit;
=DESCRIBE
This function unstacks the top of the proof context stack,
sets the proof context of the system to it, and returns the previous current proof context.
There will always be a current proof context, though it may be the trivial ``initial'' proof context.
=SEEALSO
$push\_pc$, $set\_pc$, $push\_merge\_pcs$, $set\_merge\_pcs$
=FAILURE
51001	The proof context stack is empty
=ENDDOC
=DOC
(* proof context key "€initial›" *)
=DESCRIBE
This is the ``empty'' proof context, formed with empty lists.
It thus has no default rewriting or stripping theorems,
no default rewriting canonicalisation, and its automated existence
prover fails on any input.
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of ProofContext *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


