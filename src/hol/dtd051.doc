=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Proof Contexts}  %% Mandatory field
\def\TPPheadtitle{Proof Contexts}
\TPPref{DS/FMU/IED/DTD051}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{K.~Blackburn & WIN01\\R.D.Arthan & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the detailed design for providing proof contexts.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Try again.
\item [Issue 1.3]
And again.
\item [Issue 1.4]
Tidying up after doing implementation.
\item [Issue 1.5]
Moved to using abstract data types.
\item [Issue 1.6]
Gains equational context material.
\item [Issue 1.7]
Added $get\_(e)pc\_cs\_∂\_rule$.
\item [Issue 1.8]
Added existence prover parameterisation.

\item[Issue 1.9, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.10]
Changed to using a dictionary of proof contexts.
\end{description}
\subsection{Changes Forecast}
The designer of this document needs to know which functions it may
give context for, and the type of the proof context details.
Thus if a new tool using context is added to the system then this document will need
modification.

In particular, the expected resolution tool will be parameterised in some manner yet to be decided,
and when introduced will require changes to this document
and its implementation.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
provision of proof contexts.
This is called for in \cite{DS/FMU/IED/HLD???}.
The design is implemented in \cite{DS/FMU/IED/IMP051}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
A proof context is a setting of various
parameters of proof tools to support a particular mode of proof.
For instance, both $rewrite\_tac$ and $strip\_tac$ 
are proof tools that may be parameterised.
In particular, proof contexts will be later made available,
through the tools supplied here,
that supply a helpful environment to reason about Z,
or within a particular theory (e.g. set theory),
and alter the default environment.

An alternative approach to the one chosen is to take a 
proof context to be a labeled list of functions of type $:unit\ ->\ unit$.
A proof context would then be ``set'' by applying each function in the proof context to $()$.
This has the advantage that new context-sensitive tools could be
introduced without a system rebuild.
However, one loses the ability to display even parts
of the context, or access to the data to which
an individual function could be set.
\subsubsection{Dependencies}
This document is dependent on \cite{DS/FMU/IED/IMP008}.
It also depends on knowledge of what context-sensitive tools it
needs to cover.
It further depends on being able to create at least dummy
values for the parameters of these functions.
\subsubsection{Deficiencies}
We fail to give the developer of a context-sensitive proof tool the ability to add an ``understanding'' of the new tool without
modifying this document and its implementation.
They will have to modify this document and its implementation and then rebuild the system
(an approach only available to someone supplied with the ability to do a system build), or provide their own proof context
tools, perhaps ``piggy backing'' upon the ones supplied here.

\subsubsection{Possible Enhancements}
Proof contexts are often associated with theories,
so it might be nice if the theory lister tells you the names
of those contexts associated with the theory listed.
\subsubsection{Terminology}
An {\em equational context} is a list of conversions,
each paired with term index. It represents a context that states
how to
rewrite a term to result in an equational theorem,
guided by the outermost form of the term to be rewritten.
An equational context will be of type $EQN\_CXT$
(== $(TERM\ *\ CONV)list$).

A {\em proof context} holds the data used to provide context for selected proof tools.

\section{THE DESIGN}
=DOC
signature €ProofContext› = sig
=DESCRIBE
This provides the basic tools for handling equational and proof contexts.
=ENDDOC
\subsection{Equational Contexts}
=DOC
type €EQN_CXT›;
=DESCRIBE
This is the type of equational contexts.
An equational context is a list of conversions,
each paired with term index. It represents a statement of
how to
rewrite a term to result in an equational theorem,
guided by the outermost form of the term to be rewritten,
which is matched against the term index of each conversion.
It is used to create a single conversion via $eqn\_cxt\_conv$ (q.v.).

A theorem may be converted into a member of 
an equational context by $thm\_eqn\_cxt$.
A pre-existing conversion may be converted by determining
the term index that matches at least all terms that 
the conversion must work on
(see $net\_enter$ for details), and pair it with the conversion.
=GFT
type EQN_CXT = (TERM * CONV) list;
=TEX
Note that equational contexts can be merged by appending.
An equational context may be transformed into a conversion 
discrimination net by $make\_net$ or $list\_net\_enter$(q.v.).
=ENDDOC
=DOC
val €thm_eqn_cxt› : THM -> (TERM * CONV);
=DESCRIBE
A theorem may be transformed into a suitable member of 
an equational context ($EQN\_CXT$ q.v.)
by $thm\_eqn\_cxt$:
=GFT
thm_eqn_cxt `á Ù µ x1 ... ∑ LHS = RHS` ≠
	(LHS, simple_eq_match_1_conv `á Ù µ x1 ... ∑ LHS = RHS`)
=TEX
where the universal quantifiers must be simple.
=SEEALSO
$cthm\_eqn\_cxt$ which canonicalises
a theorem before transformation.
=FAILURE
7095	?0 is not of the form `á Ù µ x1 ... xn ∑ u = v' where ¨xiÆ are variables
=ENDDOC
=DOC
val €eqn_cxt_conv› : EQN_CXT -> CONV;
=DESCRIBE
This function creates a single conversion from an equational
context.
This is done via $make\_net$ and $net\_lookup$(q.v).
There is an implicit $CHANGED\_C$ wrapped around each
conversion in the equational context.
=FAILURE
51005	Equational context gave no conversions that succeeded for ?0
=ENDDOC

\subsection{Proof Contexts}
The goal of the following functions is:
\begin{enumerate}
\item
To give a naive user a simple command to change
the proof context.
This will change the individual context of all context-sensitive proof tools,
to provide the best context available for the style of work they are to then carry out.
\item
To give the developer of, say, a new theory the means
to create a proof context suitable for reasoning in that theory.
\item
To allow a piece of proof automation to change the proof context,
do some work, and then revert to the previous context.
\item
To provide a single place where all context-sensitive tools look
for their contexts.
\end{enumerate}
The data a normal user might enter into a proof context
is not in the same form as context-sensitive applications accessing the proof context wish to see:
there is an evaluation step in between.

However there are cases when a system builder wishes to directly
enter the material that a context-sensitive application
will extract.
These cases occur either early in the system build,
when evaluation of the proof context is difficult,
or for exotic proof context effects.
We therefore must distinguish between ``user data'' and
``application data'' within proof contexts, and provide
a set of tools to handle both.
We further must provide methods of evaluating the 
user data to extract the application data.
As we cannot in all cases state this evaluation process
at the point of implementing this document
we provide the functions prefixed $set\_eval\_$ to allow
evaluation functions to be entered at a later date.
When an evaluation function is changed then all the
proof contexts in the database whose associated user data was set last (rather than the application data) will have their application data re-evaluated.
This has the advantage of keeping user and application data in step,
but the disadvantage of perhaps modifying the applications data of earlier proof contexts (DISCUSS THIS!!!).

The user data tools are:
=GFT
set_ud_rw_eqn_cxt		get_ud_rw_eqn_cxt
set_ud_rw_canons		get_ud_rw_canons
set_ud_st_eqn_cxt		get_ud_st_eqn_cxt
set_ud_sg_eqn_cxt		get_ud_sg_eqn_cxt
set_ud_cs_∂_rule		get_ud_cs_∂_rule
set_ud_∂_cd_thm		get_ud_∂_cd_thm
set_ud_∂_vs_thm		get_ud_∂_vs_thm
=TEX
In naming the interface functions (other than $set\_ud\_name$) we use the convention:
=GFT
<set|get>_ud_<proof tool>_<modifier>
=TEX
The proof tools in the above are: $rw$ for rewriting,
$st$ for stripping theorems, $sg$ for stripping goals,
$cs$ for constant specifications,
and $∂$ for the existence prover $prove\-\_∂\-\_conv$.
$set$ and $get$ functions overwrite or access the database respectively.

The application data tools are:
=GFT
set_ad_rw_net			get_ad_rw_net
set_eval_ad_rw_net		current_ad_rw_net
set_ad_rw_canon		get_ad_rw_canon
set_eval_ad_rw_canon		current_ad_rw_canon
set_ad_st_conv		get_ad_st_conv
set_eval_ad_st_conv		current_ad_st_conv
set_ad_sg_conv		get_ad_sg_conv
set_eval_ad_sg_conv		current_ad_sg_conv
set_ad_cs_∂_rule		get_ad_cs_∂_rule
set_eval_ad_cs_∂_rule		current_ad_cs_∂_rule
set_ad_∂_cd_thm		get_ad_∂_cd_thm
set_eval_ad_∂_cd_thm		current_ad_∂_cd_thm
set_ad_∂_vs_thm		get_ad_∂_vs_thm
set_eval_ad_∂_vs_thm		current_ad_∂_vs_thm
=TEX
In naming the interface functions (other than $set\_ad\_name$)
we use the convention:
=GFT
<set|get|set_eval|current>_ad_<proof tool>_<modifier>
=TEX
The proof tools in the above are: $rw$ for rewriting,
$st$ for stripping theorems, $sg$ for stripping goals,
$cs$ for constant specifications,
and $∂$ for the existence prover $prove\-\_∂\-\_conv$.
$set$ and $get$ functions overwrite or access the database respectively, $set\_eval$
sets the method of evaluating the associated user data into application data,
and $current$ gives the current proof contexts application data.

To allow more advanced patterns of context changes, we have
a stack of proof contexts, with the current proof context at the top.
We provide applications with hooks to look into this current proof
context,
but no way to modify stacked proof contexts ``in place''.
In particular, if a proof context is stacked, then it
is in fact a copy that is stacked, so that later changes to the original do not affect the stack.

We store the proof contexts in a database that is
accessed by the above tools, on their being given a key.
Thus there are no objects of type ``proof context'' within the system.
New entries in the database are formed by copying old entries,
and then overwriting selected fields.
Overwriting user data fields will propagate changes 
into the associated application data fields.
However, overwriting application data fields will make
the associated user data fields unreadable, unless they
in turn are overwritten once more.
This is because in general the evaluation of the user data is ``one-way''.
The applications methods of extracting the current data are:
=GFT
current_ad_name		current_ad_rw_net
current_ad_rw_canon		current_ad_st_conv
current_ad_sg_conv		current_ad_cs_∂_rule
current_ad_∂_cd_thm		current_ad_∂_vs_thm
=TEX

The database of proof contexts is initialised to contain
a single context with key ``initial'', which is also the initial current proof context

=DOC
val €copy_proof_context› : string -> string -> unit;
=DESCRIBE
$copy\_proof\_context$ $from$ $to$
copies the proof context with key $from$ into a new 
entry with key $to$.
A note will be made of the current theory at the time of
copying, and an error will be raised
if an attempt is made to push the new proof context (see $push\_proof\_context$) when
that theory is not in scope.
One responsibility of the creator of a proof context is to ensure that the theorems used within the new context are also
in scope: this is not automatically checked.
=FAILURE
51010	There is no proof context with key ?0
51011	There is already a proof context with key ?0
=ENDDOC
=DOC
val €delete_proof_context› : string -> unit;
=DESCRIBE
This deletes an entry from the proof context database.
Entry ``initial'' may not be deleted.
=FAILURE
51010	There is no proof context with key ?0
51012	Initial proof context may not be deleted
=ENDDOC
=DOC
val €show_proof_contexts› : unit -> (string * string) list;
=DESCRIBE
This lists the names of the proof contexts held in the proof context
database, and the theory that was current at their time of creation.
=FAILURE
51010	There is no proof context with key ?0
51012	Proof context initial may not be deleted
=ENDDOC
=DOC
val €current_ad_name› : unit -> string;
=DESCRIBE
Returns the key of the entry from which the
current proof context was copied.
Note that the key may no longer access a proof context in the database identical to the current proof context.
=ENDDOC
=DOC
val €set_ud_rw_eqn_cxt› : EQN_CXT -> string -> unit;
val €get_ud_rw_eqn_cxt› : string -> EQN_CXT;
=DESCRIBE
These functions provide the interface to the equational context for rewriting (see e.g. $rewrite\_tac$)
held in the user data of a proof context.
=SEEALSO
$set\_ad\_rw\_net$ for the associated application data.
=FAILURE
51010	There is no proof context with key ?0
51013	Cannot access ?0 user data in proof context ?1
=FAILUREC
Error 51013 indicates that it was application data associated with this field of the proof context that was last written.
=ENDDOC
=DOC
val €set_ad_rw_net› : CONV NET -> string -> unit;
val €get_ad_rw_net› : string -> CONV NET;
val €set_eval_ad_rw_net› : (EQN_CXT -> CONV NET) -> unit;
val €current_ad_rw_net› : unit -> CONV NET;
=DESCRIBE
These functions provide the interface to the initial conversion net for rewriting (see e.g. $rewrite\_tac$)
held in the application data of a proof context.
=SEEALSO
$set\_ud\_rw\_eqn\_cxt$ for the associated user data.
=FAILURE
51010	There is no proof context with key ?0
=ENDDOC
=DOC
val €set_ud_rw_canons› : ((THM -> THM list) * string) list -> 
	string -> unit;
val €get_ud_rw_canons› : string -> ((THM -> THM list) * string) list;
=DESCRIBE
These functions provide the interface to the individual canonicalisation functions used to create the canonicalisation function applied to rewriting theorems (see e.g. $rewrite\_tac$)
held in the user data of a proof context.

The string argument paired with each function is an identifier for the function,
$merge\-\_proof\-\_rule$ will discard user data entries
with already added identifiers in the order the the proof contexts are supplied to
$merge\-\_proof\-\_context$.
This provides a means of cutting down duplication during merging.
=SEEALSO
$set\_ad\_rw\_canons$ for the associated application data.
=FAILURE
51010	There is no proof context with key ?0
51013	Cannot access ?0 user data in proof context ?1
=FAILUREC
Error 51013 indicates that it was application data associated with this field of the proof context that was last written.
=ENDDOC
=DOC
val €set_ad_rw_canon› : (THM -> THM list) -> string -> unit;
val €get_ad_rw_canon› : string -> (THM -> THM list);
val €set_eval_ad_rw_canon› : ((THM -> THM list) list -> (THM -> THM list)) 
	-> unit;
val €current_ad_rw_canon› : unit -> (THM -> THM list);
=DESCRIBE
These functions provide the interface to the canonicalisation function applied to rewriting theorems (see e.g. $rewrite\_tac$)
held in the application data of a proof context.
=SEEALSO
$set\_ud\_rw\_canons$ for the associated user data.
=FAILURE
51010	There is no proof context with key ?0
=ENDDOC
=DOC
val €set_ud_st_eqn_cxt› : EQN_CXT -> string -> unit;
val €get_ud_st_eqn_cxt› : string -> EQN_CXT;
=DESCRIBE
These functions provide the interface to the equational context for stripping theorems into the
assumption list (see e.g. $strip\_tac$)
held in the user data of a proof context.
=SEEALSO
$set\_ad\_st\_conv$ for the associated application data.
=FAILURE
51010	There is no proof context with key ?0
51013	Cannot access ?0 user data in proof context ?1
=FAILUREC
Error 51013 indicates that it was application data associated with this field of the proof context that was last written.
=ENDDOC
=DOC
val €set_ad_st_conv› : CONV -> string -> unit;
val €get_ad_st_conv› : string -> CONV;
val €set_eval_ad_st_conv› : (EQN_CXT -> CONV) -> unit;
val €current_ad_st_conv› : unit -> CONV;
=DESCRIBE
These functions provide the interface to the conversion for stripping theorems into the
assumption list (see e.g. $strip\_tac$)
held in the application data of a proof context.
=SEEALSO
$set\_ud\_st\_conv$ for the associated user data.
=FAILURE
51010	There is no proof context with key ?0
=ENDDOC
=DOC
val €set_ud_sg_eqn_cxt› : EQN_CXT -> string -> unit;
val €get_ud_sg_eqn_cxt› : string -> EQN_CXT;
=DESCRIBE
These functions provide the interface to the equational context for stripping goals (see e.g. $strip\_tac$)
held in the user data of a proof context.
=SEEALSO
$set\_ad\_sg\_conv$ for the associated application data.
=FAILURE
51010	There is no proof context with key ?0
51013	Cannot access ?0 user data in proof context ?1
=FAILUREC
Error 51013 indicates that it was application data associated with this field of the proof context that was last written.
=ENDDOC
=DOC
val €set_ad_sg_conv› : CONV -> string -> unit;
val €get_ad_sg_conv› : string -> CONV;
val €set_eval_ad_sg_conv› : (EQN_CXT -> CONV) -> unit;
val €current_ad_sg_conv› : unit -> CONV;
=DESCRIBE
These functions provide the interface to the conversion for stripping goals (see e.g. $strip\_tac$)
held in the application data of a proof context.
=SEEALSO
$set\_ud\_sg\_conv$ for the associated user data.
=FAILURE
51010	There is no proof context with key ?0
=ENDDOC
=DOC
val €set_ud_cs_∂_rule› : (((TERM -> THM) * string) list) -> 
	string -> unit;
val €get_ud_cs_∂_rule› : string -> 
	(((TERM -> THM) * string) list);
=DESCRIBE
These functions provide the interface to the 
existence provers for constant specifications (see $const\_spec$)
held in the user data of a proof context.
Each existence prover will be used in turn.

The string argument paired with each function is an identifier for the function,
$merge\-\_proof\-\_rule$ will discard user data entries
with already added identifiers in the order the the proof contexts are supplied to
$merge\-\_proof\-\_context$.
This provides a means of cutting down duplication during merging.
=SEEALSO
$set\_ad\_cs\_∂\_rule$ for the associated application data.
=FAILURE
51010	There is no proof context with key ?0
51013	Cannot access ?0 user data in proof context ?1
=FAILUREC
Error 51013 indicates that it was application data associated with this field of the proof context that was last written.
=ENDDOC
=DOC
val €set_ad_cs_∂_rule› : (TERM -> THM) -> string -> unit;
val €get_ad_cs_∂_rule› : string -> (TERM -> THM);
val €set_eval_ad_cs_∂_rule› : (((TERM -> THM) * string)list -> (TERM -> THM))
	 -> unit;
val €current_ad_cs_∂_rule› : unit -> (TERM -> THM);
=DESCRIBE
These functions provide the interface to the 
existence prover for constant specifications (see $const\_spec$)
held in the application data of a proof context.
=SEEALSO
$set\_ud\_cs\_∂\_rule$ for the associated user data.
=FAILURE
51010	There is no proof context with key ?0
=ENDDOC
=DOC
val €set_ud_∂_cd_thm› : THM list -> string -> unit;
val €get_ud_∂_cd_thm› : string -> THM list;
=DESCRIBE
These functions provide the interface to the
unevaluated  
clausal definition theorems held for the existence prover
$prove\_∂\_conv$.
=SEEALSO
See $evaluate\_∂\_cd\_thm$ for details upon the form
of the theorems.
$set\-\_ad\-\_∂\-\_cd\-\_thm$ for the associated application data.
=FAILURE
51010	There is no proof context with key ?0
51013	Cannot access ?0 user data in proof context ?1
=FAILUREC
Error 51013 indicates that it was application data associated with this field of the proof context that was last written.
=ENDDOC
=DOC
val €set_ad_∂_cd_thm› : 
	(TERM list * int list * TYPE * (TERM list)list * THM) list 
	-> string 
	-> unit;
val €get_ad_∂_cd_thm› : string -> 
	(TERM list * int list * TYPE * (TERM list)list * THM) list;
val €set_eval_ad_∂_cd_thm› : (THM list -> 
	(TERM list * int list * TYPE * (TERM list)list * THM) list) -> unit;
val €current_ad_∂_cd_thm› : unit -> 
	(TERM list * int list * TYPE * (TERM list)list * THM) list;
=DESCRIBE
These functions provide the interface to the 
clausal definition theorem information for the existence prover
$prove\_∂\_conv$.
See $evaluate\_∂\_cd\_thm$ for details upon the form
of the information.
=SEEALSO
$set\_ud\_∂_cd_thm$ for the associated user data.
=FAILURE
51010	There is no proof context with key ?0
=ENDDOC
=DOC
val €set_ud_∂_vs_thm› : (string * (TERM list * THM)) list
 	-> string -> unit;
val €get_ud_∂_vs_thm› : string -> (string * (TERM list * THM)) list;
val €set_ad_∂_vs_thm› : (string * (TERM list * THM)) list
 	-> string -> unit;
val €get_ad_∂_vs_thm› : string ->
	(string * (TERM list * THM)) list;
val €set_eval_ad_∂_vs_thm› : ((string * (TERM list * THM)) ->
	(string * (TERM list * THM)) list) -> unit;
val €current_ad_∂_vs_thm› : unit -> 
	(string * (TERM list * THM)) list;
=DESCRIBE
These functions provide the interface to the
variable structure information for the existence prover
$prove\_∂\_conv$.
The nature of the information handled is the same 
for both the evaluated and unevaluated forms.
An individual entry in the list gives a method of handling
an extended variable structure.
It consists of the name of the constructor;
a list of functions that extract each field of the constructor,
and a theorem that states 
how the extraction functions extract from a data construction,
and that the data constructor may be applied to the extracted
values to regain the original value.
For instance, for pairs the information is:
=GFT
	(",",
	([¨FstÆ,¨SndÆ],
	`Ù µ x y p ∑
		Fst (x, y) = x ± Snd (x, y) = y ±
		(Fst p, Snd p) = p)`))
=TEX
=FAILURE
51010	There is no proof context with key ?0
51013	Cannot access ?0 user data in proof context ?1
=FAILUREC
Error 51013 indicates that it was application data associated with this field of the proof context that was last written.
=ENDDOC
=DOC
val €merge_proof_context› : string list -> string -> unit;
=DESCRIBE
$merge\_proof\_context$ $keys$ $tokey$, if it can, a list of proof contexts named by $keys$,
to gain a new one named $tokey$, that is the sum of their effects.
The merging is simplistic (e.g. if merging list components then the second list is appended, or at best union'ed to the end of the first), and therefore the merged context
may be inefficient compared to a ``hand-crafted'' one,
and there may be interference between the components of
the two contexts (e.g. hiding of effects or introduction
of the possibility of looping).
Some user data fields use strings to identify functions,
allowing them duplicates to be eliminated during merging.

The pre-existing proof contexts must have been created in theories that are currently in scope.
=FAILURE
51014	Proof context ?0 was created in theory ?1 which is not in scope
=ENDDOC
=TEX
We use a stack of (temporarily) superseded proof contexts to simplify the task 
of ``change the context,
do some work, and then revert to the previous context'',
for this is an obvious approach.
=DOC
val €push_proof_context› : string -> unit;
val €set_proof_context› : string -> unit;
=DESCRIBE
$push\_proof\_context$ stacks the previous proof context, and
and sets the proof context of the system to the proof 
context with the given key.
$set\_proof\_context$ discards the previous proof context, and
and sets the proof context of the system to the proof 
context with the given key.

The current proof context is accessed by the functions prefixed $current\_ad\_$.
=SEEALSO
$pop\_proof\_context$
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 which is not in scope
=ENDDOC
=DOC
val €pop_proof_context› : unit -> unit;
=DESCRIBE
This function unstacks the top of the proof context stack,
sets the proof context of the system to it, and returns the previous current proof context.
There will always be a current proof context, though it may be the trivial ``initial''.
=SEEALSO
$push\_proof\_context$
=FAILURE
51001	The proof context stack is empty
=ENDDOC
=DOC
(* proof context key "€initial›" *)
=DESCRIBE
This is the ``empty'' proof context, formed with empty lists
or failing functions, as appropriate.
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of ProofContext *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


