=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Proof Contexts}  %% Mandatory field
\def\TPPheadtitle{Proof Contexts}
\TPPref{DS/FMU/IED/DTD051}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{K.~Blackburn & WIN01\\R.D.Arthan & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the detailed design for providing proof contexts.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Try again.
\item [Issue 1.3]
And again.
\item [Issue 1.4]
Tidying up after doing implementation.
\item [Issue 1.5]
Moved to using abstract data types.
\item [Issue 1.6]
Gains equational context material.
\item [Issue 1.7]
Added $get\_(e)pc\_cs\_¶\_rule$.
\item [Issue 1.8]
Added existence prover parameterisation.

\item[Issue 1.9, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.10]
Changed to using a dictionary of proof contexts.
\item [Issue 1.11]
Variation on a theme.
\item [Issue 1.12]
Changes after comments on 1.11.
\item [Issue 1.13]
Changes after RBJ comments.
\item [Issue 1.14]
Changes after RBJ/RDA comments.
\item [Issue 1.15]
Typo fixed.
\item [Issue 1.16 (13th April 1992)]
Changes due to CR0017.
\item [Issue 1.17 (15th April 1992)]
Change to $get\_stack\_pcs$, added $delete\_pc\_fields$.
\item [Issue 1.18 (7th May 1992)]
Act on CR0009.
\item [Issue 1.19 (8th May 1992)]
Reorganised after RBJ comments.
\item [Issue 1.20 (12th May 1992)]
Minor tinkering.
\item [Issue 1.22 (26th May 1992)]
Renamings from version 1.5 of DS/FMU/IED/WRK038.
\item [Issue 1.23 (27th May 1992)]
Corrected description.
\item [Issue 1.24 (28th May 1992)]
Added $prove\-\_tac$ and $prove\-\_¶\-\_tac$.
\item [Issue 1.25 (29th May 1992)]
And took them out again!
\item [Issue 1.26 (3rd June 1992)]
Improved design of $add\_?\_thms$.
\end{description}
\subsection{Changes Forecast}
The designer of this document needs to know which functions it may
give context for, and the type of the proof context details.
Thus if a new tool using context is added to the system then this document will need
modification.

In particular, the expected resolution tool will be parameterised in some manner yet to be decided,
and when introduced will require changes to this document
and its implementation.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
provision of proof contexts.
This is called for in \cite{DS/FMU/IED/HLD009}.
The design is implemented in \cite{DS/FMU/IED/IMP051}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
A proof context is a setting of various
parameters of proof tools to support a particular mode of proof.
For instance, both $rewrite\_tac$ and $strip\_tac$ 
are proof tools that may be parameterised.
In particular, proof contexts will be later made available,
through the tools supplied here,
that supply a helpful environment to reason about Z,
or within a particular theory (e.g. set theory),
and alter the default environment.

An alternative approach to the one chosen is to take a 
proof context to be a labeled list of functions of type $:unit\ ->\ unit$.
A proof context would then be ``set'' by applying each function in the proof context to $()$.
This has the advantage that new context-sensitive tools could be
introduced without a system rebuild.
However, one loses the ability to display even parts
of the context, or access to the data to which
an individual function could be set.
\subsubsection{Dependencies}
This document is dependent on \cite{DS/FMU/IED/IMP008}.
It also depends on knowledge of what context-sensitive tools it
needs to cover.
It further depends on being able to create at least dummy
values for the parameters of these functions.
\subsubsection{Deficiencies}
We fail to give the developer of a context-sensitive proof tool the ability to add an ``understanding'' of the new tool without
modifying this document and its implementation.
They will have to modify this document and its implementation and then rebuild the system
(an approach only available to someone supplied with the ability to do a system build), or provide their own proof context
tools, perhaps building upon the ones supplied here.

\subsubsection{Possible Enhancements}
Proof contexts are often associated with theories,
so it might be nice if the theory lister tells you the names
of those contexts associated with the theory listed.
Such a feature would probably require an interface in this document.
\subsubsection{Terminology}
An {\em equational context} is a list of conversions,
each paired with term index. It represents a context that states
how to
rewrite a term to result in an equational theorem,
guided by the outermost form of the term to be rewritten.
An equational context will be of type $EQN\_CXT$
(= $(TERM\ *\ CONV)list$).

A {\em proof context} holds the data used to provide context for selected proof tools.

\section{THE SIGNATURE}
=DOC
signature ÛProofContextÝ = sig
=DESCRIBE
This provides the basic tools for handling equational and proof contexts.
To keep them short, the names in the structure are heavily abbreviated.
The abbreviations used are:

\begin{centering}

\begin{tabular}{| l | l |} \hline
pc(s) & proof context(s) \\
rw & rewriting \\
cs & constant specification \\
$¶$ & existential theorem prover \\
pr & $prove\_tac$ and related tools\\
sg & goal stripping \\
st & theorem stripping \\
cd & clausal definition \\
vs & variable structure \\
ad & application data \\
net & discrimination net \\
eqn$\_$cxt & equational context \\
canon(s) & theorem canonicalisation \\ \hline
\end{tabular}

\end{centering}
=ENDDOC
\section{EQUATIONAL CONTEXTS}
=DOC
type ÛEQN_CXTÝ;
=DESCRIBE
This is the type of equational contexts.
An equational context is a list of conversions,
each paired with term index. It represents a statement of
how to
rewrite a term to result in an equational theorem,
guided by the outermost form of the term to be rewritten,
which is matched against the term index of each conversion.
It is used to create a single conversion via $eqn\_cxt\_conv$ (q.v.).

A theorem may be converted into a member of 
an equational context by $thm\_eqn\_cxt$.
A pre-existing conversion may be converted by determining
the term index that matches at least all terms that 
the conversion must work on
(see $net\_enter$ for details), and pair it with the conversion.
=GFT
type EQN_CXT = (TERM * CONV) list;
=TEX
Note that equational contexts can be merged by appending.
An equational context may be transformed into a conversion 
discrimination net by $make\_net$ or $list\_net\_enter$(q.v.).
=ENDDOC
=DOC
val Ûthm_eqn_cxtÝ : THM -> (TERM * CONV);
=DESCRIBE
A theorem may be transformed into a suitable member of 
an equational context ($EQN\_CXT$ q.v.)
by $thm\_eqn\_cxt$:
=GFT
thm_eqn_cxt `‡ ô µ x1 ... · LHS = RHS` ­
	(LHS, simple_eq_match_conv1 `‡ ô µ x1 ... · LHS = RHS`)
=TEX
where the universal quantifiers must be simple binders.
=SEEALSO
$cthm\_eqn\_cxt$ which canonicalises
a theorem before transformation.
=FAILURE
7095	?0 is not of the form `‡ ô µ x1 ... xn · u = v' where ¬xi® are variables
=ENDDOC
=DOC
val Ûeqn_cxt_convÝ : EQN_CXT -> CONV;
=DESCRIBE
This function creates a single conversion from an equational
context.
This is done via $make\_net$ and $net\_lookup$(q.v).
There is a $CHANGED\_C$ wrapped around each
conversion in the equational context.
=FAILURE
51005	Equational context gave no conversions that succeeded for ?0
=ENDDOC

\section{PROOF CONTEXTS}
\subsection{Discussion}
The goal of the following functions is:
\begin{enumerate}
\item
To give a naive user a simple command to change
the proof context.
This will change the individual context of all context-sensitive proof tools,
to provide the best context available for the style of work they are to then carry out.
The new context may be a merge of various supplied prof contexts.
\item
To give a more experienced user the ability to merge
together the effect of various proof contexts into the current proof context.
\item
To give the developer of, say, a new theory the means
to create a proof context suitable for reasoning in that theory.
\item
To allow a piece of proof automation to change the proof context,
do some work, and then revert to the previous context.
\item
To provide a single place where all context-sensitive tools look
for their contexts.
\end{enumerate}
We implement proof contexts by maintaining two data structures:
a database of proof contexts, in which a proof context is a record
in the database, and a particular part of the proof context is
a field of the proof context;
and a stack of proof contexts, which has the current proof context as the top record.
Proof contexts are pushed onto the stack from the database,
they have no existence apart from within these two structures.

A proof context has various fields, each field relating
to some single area of context for a context-sensitive
proof tool.
A proof context is created by $new\-\_pc$.
Its fields are populated by data that comes from other
proof contexts in the database (by $merge\-\_pc$ and
$merge\-\_pc\-\_fields$), and that is entered by
the proof contexts creator.
A proof context in is in the middle of its creation may still be
pushed onto the proof context stack, but it may not be used
as the origin of data for a field of another proof context.
When a proof context is considered complete it is ``committed''
by $commit\-\_pc$, and it then becomes an
acceptable origin of data for other proof contexts.

Mechanisms keep track of the origin of data in each of a 
proof contexts fields by splitting it into subfields, to allow duplicated information to
be discarded when merging data from various proof contexts in a single field.
Each subfield is indexed by the proof context name from which it came.
This is also why we commit proof contexts, and why they may
only have data extracted for other proof contexts after their commital.
More than one proof context may be uncommitted at the same time.

The data a user might enter into a proof context
is not in the same form as context-sensitive applications accessing the proof context need to see:
there is an evaluation step in between.
We therefore must provide methods of evaluating the 
user data to extract the application data.
As we cannot in all cases state this evaluation process
at the point of implementing this document
we provide the functions prefixed $icl'set\_eval\_???$ to allow
evaluation functions to be entered at a later date.
Uncommitted proof contexts are evaluated by the current
evaluation function when they are pushed onto the proof context stack,
committed contexts are evaluated at the point of commital
by the evaluation functions current at the time of commital
(saving the cost of multiple evaluations upon multiple pushes).
\subsection{Summary of Tools Supported and Provided}
Four sets of tools have context-sensitive  behaviour supported
by proof contexts:
=GFT
rewrite_tac and its cousins
strip_tac and its cousins
basic_prove_¶_conv and its users
prove_tac, prove_conv, prove_rule 
=TEX

The user data tools are:
=GFT
set_rw_eqn_cxt	get_rw_eqn_cxt		add_rw_thms
set_rw_canons		get_rw_canons
set_st_eqn_cxt		get_st_eqn_cxt		add_st_thms
set_sc_eqn_cxt		get_sc_eqn_cxt		add_sc_thms
set_cs_¶_convs		get_cs_¶_convs
set_¶_cd_thms		get_¶_cd_thms		add_¶_cd_thms
set_¶_vs_thms		get_¶_vs_thms
set_pr_tac		get_pr_tac
set_pr_conv		get_pr_conv
=TEX
In naming the interface functions we use the convention:
=GFT
<set|get|add>_<proof tool>_<modifier>
=TEX
The proof tools in the above are: $rw$ for rewriting,
$st$ for stripping theorems, $sg$ for stripping goals,
$cs$ for constant specifications,
$pr$ for $prove\_tac$ and cousins,
and $¶$ for the existence prover $prove\-\_¶\-\_conv$.
$set$ and $get$ functions overwrite or access the database respectively.
$add$ functions add unprocessed theorems
into a proof context, using some form of automated processing.

The applications data tools are:
=GFT
icl'set_eval_ad_rw_net		current_ad_rw_net
icl'set_eval_ad_rw_canon		current_ad_rw_canon
icl'set_eval_ad_st_conv		current_ad_st_conv
icl'set_eval_ad_sc_conv		current_ad_sc_conv
icl'set_eval_ad_cs_¶_conv		current_ad_cs_¶_conv
icl'set_eval_ad_¶_cd_thms		current_ad_¶_cd_thms
icl'set_eval_ad_¶_vs_thms		current_ad_¶_vs_thms
current_ad_pr_tac
current_ad_pr_conv

=TEX
In naming the applications data interface functions we use the convention:
=GFT
<icl'set_eval|current>_ad_<proof tool>_<modifier>
=TEX
The proof tools in the above are: $rw$ for rewriting,
$st$ for stripping theorems, $sg$ for stripping goals,
$cs$ for constant specifications,
and $¶$ for the existence prover $prove\-\_¶\-\_conv$.
$icl'set\_eval$
sets the method of evaluating the associated user data into application data
(note that there is no such function for fields $pr\_tac$ and $pr\_conv$)
and $current$ gives the current proof context's application data, if it is in scope, and otherwise error 51021.

Note that an application data field in an uncommitted proof context could be directly modified, to $v$ say,
by setting its evaluation function to 
=INLINEFT
(fn _ => v)
=TEX
, committing the proof context,
and restoring the evaluation function to its previous value.
This might be a system builder's necessary trick,
it is certainly not a standard pattern of use.

To allow certain patterns of context changes, we have
a stack of proof contexts, with the current proof context at the top.
We provide applications with hooks to look into this current proof
context,
but no way to modify stacked proof contexts ``in place''.
In particular, if a proof context is stacked, then it
is in fact a copy that is stacked, so that later changes to the original do not affect the stack.

The database of proof contexts is initialised to contain
a single context with key ``initial'', which is also the initial current proof context
\subsection{Proof Context Database Functions}
=DOC
val Ûnew_pcÝ : string -> unit;
=DESCRIBE
$new\_pc$ $new$
creates a new 
record in the proof context database, with key $new$.
The fields of the proof context are set to default values.
A note will be made of the current theory,
and its current definition level at the time of
creation, and an error will be raised
if an attempt is made to push the new proof context (see $push\_pc$) when
that theory is not in scope, or when the definition level
has been recorded as deleted.
The definition level will be recorded as deleted if, e.g., some definition
or axiom that was in scope in the original theory has since been deleted.

One responsibility of the creator of a proof context is to ensure that the theorems used within, or created by, the new context are also
in scope: this is not automatically checked.
=FAILURE
51011	There is already a proof context with key ?0
=ENDDOC
=DOC
val Ûdelete_pcÝ : string -> unit;
=DESCRIBE
This deletes a record from the proof context database.
The record with key ``initial'' may not be deleted.
=FAILURE
51010	There is no proof context with key ?0
51012	Initial proof context may not be deleted
=ENDDOC
=DOC
val Ûcommit_pcÝ : string -> unit;
=DESCRIBE
This commits a record of the proof context database,
preventing further change, and allowing it to be used in
the creation of further records.
The context must be loadable at the point of commiting
(i.e. was created at a point now in scope),
and after commital the proof context can only be loaded
at a point when the point of commital is in scope,
rather than the point of its initial creation (i.e. doing $new\_pc$).
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val Ûget_pcsÝ : unit -> (string * string) list;
=DESCRIBE
This lists the names of the proof contexts held in the proof context
database, and the theory that was current at their time of creation.
If the theory has since been deleted or if the definition level becomes deleted, e.g.
because an axiom or definition has been deleted,
then this will output 
=INLINEFT
("context name","theory name (out of scope, deleted, or modified)")
=TEX
=SEEALSO
$get\_stack\_pcs$, $get\_current\_pc$.
=ENDDOC
=DOC
val Ûmerge_pcsÝ : string list -> string -> unit;
=DESCRIBE
$merge\_pcs$ $keys$ $tokey$ takes a list of committed proof contexts named by $keys$,
and merges their fields into proof context $tokey$'s fields,
discarding duplicates.
For each field that has subfields the lists of subfields from each proof context are appended, discarding
subfields with duplicate keys,
and if a field is not divided into subfields, then the proof contexts fields are appended, discarding duplicates.
The head of the list of proof contexts to merge into $tokey$
will be merged in last.
The $pr\_conv$ and $pr\_tac$ fields will take the value of the
last of the list of proof contexts, rather than being a merge.

Failure to extract any proof context for merging will result in the
proof context $tokey$ being unchanged.
=SEEALSO
$merge\_pc\_fields$, $delete\_pc\_fields$
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
51017	Proof context ?0 has not been committed
=ENDDOC
=DOC
val Ûmerge_pc_fieldsÝ : {context:string,fields:string list}list -> string -> unit;
=DESCRIBE
$merge\_pc\_fields$ $fields$ $tokey$ 
merges the fields noted for each committed proof context in $fields$ into proof context $tokey$'s fields,
discarding duplicates.
Merging for each field that has subfields the lists of subfields is appending the proof contexts fields, discarding
subfields with duplicate keys,
and if a field is not divided into subfields, then the proof contexts fields are appended, discarding duplicates.
The head of the list of proof contexts to merge into $tokey$
will be merged in last.
The $pr\_conv$ and $pr\_tac$ fields will take the value of the
last of the list of proof contexts, rather than being a merge.

Failure to extract any proof context for merging will result in the
proof context $tokey$ being unchanged.

Valid field names are:
=GFT
"rw_eqn_cxt","rw_canons","st_eqn_cxt","sc_eqn_cxt",
"cs_¶_convs","¶_cd_thms","¶_vs_thms","pr_tac","pr_conv"
=TEX
=SEEALSO
$delete\_pc\_fields$ and $merge\_pcs$, which used together in a particular order can give the same functionality as this function.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
51017	Proof context ?0 has not been committed
51019	There is no field called ?0
=ENDDOC
=DOC
val Ûdelete_pc_fieldsÝ : string list -> string -> unit;
=DESCRIBE
$delete\_pc\_fields$ $fields$ $key$ 
empties 
(sets to the value of proof context ``initial'') the named fields, $fields$ of the proof context with key $key$.
If any field is divided into subfields, this deletion includes deleting the subfields of the field gained from
merging in other proof contexts,
as well as the proof context's ``own'' subfield.

Valid field names are:
=GFT
"rw_eqn_cxt","rw_canons","st_eqn_cxt","sc_eqn_cxt",
"cs_¶_convs","¶_cd_thms","¶_vs_thms","pr_tac","pr_conv"
=TEX
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
51019	There is no field called ?0
=ENDDOC
\subsection{Proof Context Field Functions}
The following functions relate to individual fields
of proof contexts:
=DOC
val Ûset_rw_eqn_cxtÝ : EQN_CXT -> string -> unit;
val Ûget_rw_eqn_cxtÝ : string -> (EQN_CXT * string) list;
val Ûadd_rw_thmsÝ : THM list -> string -> unit;
=DESCRIBE
These functions provide the interface to the equational context for rewriting (see e.g. $rewrite\_tac$)
held in the user data of a proof context.
``setting'' overwrites the subfield whose key is the proof context's name,
``getting'' returns the entire field (which pairs data with
proof context names).
``adding'' processes its theorems by first canonicalising according to the current proof context's canonicalisation function, and then with $thm\_eqn\_cxt$ and
then adds them into the subfield whose key is the proof context's name.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val Ûicl'set_eval_ad_rw_netÝ : (EQN_CXT -> CONV NET) -> unit;
val Ûcurrent_ad_rw_netÝ : unit -> CONV NET;
=DESCRIBE
These functions provide the interface to the initial conversion net for rewriting (see e.g. $rewrite\_tac$)
held in the application data of a proof context.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_rw\_eqn\_cxt$ for the associated user data.
=FAILURE
51021	The current proof context was created in theory ?0 at a 
	point now either not in scope, deleted or modified
=ENDDOC
=DOC
val Ûset_rw_canonsÝ : (THM -> THM list) list -> 
	string -> unit;
val Ûget_rw_canonsÝ : string -> ((THM -> THM list) list * string) list;
=DESCRIBE
These functions provide the interface to the individual canonicalisation functions used to create the canonicalisation function applied to rewriting theorems (see e.g. $rewrite\_tac$)
held in the user data of a proof context.

``setting'' overwrites the subfield whose key is the proof context's name,
``getting'' returns the entire field (which pairs data with
proof context names).
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val Ûicl'set_eval_ad_rw_canonÝ : ((THM -> THM list) list -> (THM -> THM list)) 
	-> unit;
val Ûcurrent_ad_rw_canonÝ : unit -> THM -> THM list;
=DESCRIBE
These functions provide the interface to the canonicalisation function applied to rewriting theorems (see e.g. $rewrite\_tac$)
held in the application data of a proof context.
The proof context is accessed after providing the theorem.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_rw\_canons$ for the associated user data.
=FAILURE
51021	The current proof context was created in theory ?0 at a 
	point now either not in scope, deleted or modified
=ENDDOC
=DOC
val Ûset_st_eqn_cxtÝ : EQN_CXT -> string -> unit;
val Ûget_st_eqn_cxtÝ : string -> (EQN_CXT * string)list;
val Ûadd_st_thmsÝ : THM list -> string -> unit;
=DESCRIBE
These functions provide the interface to the equational context for stripping theorems into the
assumption list (see e.g. $strip\_tac$)
held in the user data of a proof context.
``setting'' overwrites the subfield whose key is the proof context's name,
``getting'' returns the entire field (which pairs data with
proof context names).
``adding'' processes its theorems  by first canonicalising according to the current proof context's canonicalisation function, and then with $thm\_eqn\_cxt$ and
then adds them into the subfield whose key is the proof context's name.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val Ûicl'set_eval_ad_st_convÝ : (EQN_CXT -> CONV) -> unit;
val Ûcurrent_ad_st_convÝ : unit -> CONV;
=DESCRIBE
These functions provide the interface to the conversion for stripping theorems into the
assumption list (see e.g. $strip\_tac$)
held in the application data of a proof context.
The proof context is accessed before provision of a term.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_st\_conv$ for the associated user data.
=FAILURE
51021	The current proof context was created in theory ?0 at a 
	point now either not in scope, deleted or modified
=ENDDOC
=DOC
val Ûset_sc_eqn_cxtÝ : EQN_CXT -> string -> unit;
val Ûget_sc_eqn_cxtÝ : string -> (EQN_CXT * string) list;
val Ûadd_sc_thmsÝ : THM list -> string -> unit;
=DESCRIBE
These functions provide the interface to the equational context for stripping goal conclusions (see e.g. $strip\_tac$)
held in the user data of a proof context.
``setting'' overwrites the subfield whose key is the proof context's name,
``getting'' returns the entire field (which pairs data with
proof context names).
``adding'' processes its theorems by first canonicalising according to the current proof context's canonicalisation function, and then with $thm\_eqn\_cxt$ and
then adds them into the subfield whose key is the proof context's name.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val Ûicl'set_eval_ad_sc_convÝ : (EQN_CXT -> CONV) -> unit;
val Ûcurrent_ad_sc_convÝ : unit -> CONV;
=DESCRIBE
These functions provide the interface to the conversion for stripping goal conclusions (see e.g. $strip\_tac$)
held in the application data of a proof context.
The proof context is accessed before provision of a term.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_sg\_conv$ for the associated user data.
=ENDDOC
=DOC
val Ûset_cs_¶_convsÝ : (CONV list) -> 
	string -> unit;
val Ûget_cs_¶_convsÝ : string -> 
	(((CONV list) * string) list);
=DESCRIBE
These functions provide the interface to the 
existence provers for constant specifications (see $const\_spec$)
held in the user data of a proof context.
Under the initial evaluator, the existence proving conversion supplied by $current\-\_cs\-\_¶\-\_conv$ will have each of the conversions 
tried, in the reverse order of their entry, 
being applied to the RHS of the result of the previous successful application, or the initial term to which the conversion was applied, until the RHS is $¬T®$, or no conversions remain.
=GFT Example
If get_cs_¶_convs of the current proof context returns

[([conv1, conv2],"pc1"),([conv3, conv4],"pc2")]

Then current_ad_cs_¶_conv  will return

conv4 AND_OR_C conv3 AND_OR_C conv2 AND_OR_C conv1
=TEX

``setting'' overwrites the subfield whose key is the proof context's name,
``getting'' returns the entire field (which pairs data with
proof context names).
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val Ûicl'set_eval_ad_cs_¶_convsÝ : (CONV list -> CONV)
	 -> unit;
val Ûcurrent_ad_cs_¶_convÝ : unit -> CONV;
=DESCRIBE
These functions provide the interface to the 
existence prover for constant specifications (see $const\_spec$)
held in the application data of a proof context.
The proof context is accessed before provision of a term.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_cs\_¶\_rule$ for the associated user data.
=FAILURE
51015	No automated existence prover in the current proof context succeeds
51021	The current proof context was created in theory ?0 at a 
	point now either not in scope, deleted or modified
=ENDDOC
=DOC
val Ûset_¶_cd_thmsÝ : THM list -> string -> unit;
val Ûget_¶_cd_thmsÝ : string -> THM list;
val Ûadd_¶_cd_thmsÝ : THM list -> string -> unit;
=DESCRIBE
These functions provide the interface to the
unevaluated  
clausal definition theorems held for the existence prover
$prove\_¶\_conv$.
There are no subfields to this field, so
``setting'' overwrites the field with the proof context's name,
``getting'' returns the field.
``adding'' unions its theorem list with the proof contexts field.
=SEEALSO
See $evaluate\_¶\_cd\_thms$ for details upon the form
of the theorems.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val Ûicl'set_eval_ad_¶_cd_thmsÝ : (THM list -> 
	(TERM list * int list * TYPE * (TERM list)list * THM) list) -> unit;
val Ûcurrent_ad_¶_cd_thmsÝ : unit -> 
	(TERM list * int list * TYPE * (TERM list)list * THM) list;
=DESCRIBE
These functions provide the interface to the 
clausal definition theorem information for the existence prover
$prove\_¶\_conv$.
See $evaluate\_¶\_cd\_thms$ for details upon the form
of the information.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_¶_cd_thms$ for the associated user data.
=FAILURE
51021	The current proof context was created in theory ?0 at a 
	point now either not in scope, deleted or modified
=ENDDOC
=DOC
val Ûset_¶_vs_thmsÝ : (string * (TERM list * THM)) list
 	-> string -> unit;
val Ûget_¶_vs_thmsÝ : string -> (string * (TERM list * THM)) list;
=DESCRIBE
These functions provide the interface to the
variable structure information for the existence prover
$prove\_¶\_conv$.
An individual entry in the list gives a method of handling
an extended variable structure.
It consists of the name of the constructor;
a list of functions that extract each field of the constructor,
and a theorem that states 
how the extraction functions extract from a data construction,
and that the data constructor may be applied to the extracted
values to regain the original value.
For instance, for pairs the information is:
=GFT
	(",",
	([¬Fst®,¬Snd®],
	`ô µ x y p ·
		Fst (x, y) = x ± Snd (x, y) = y ±
		(Fst p, Snd p) = p)`))
=TEX
There are no subfields to this field, so
``setting'' overwrites the field with the proof context's name,
``getting'' returns the field.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val Ûicl'set_eval_ad_¶_vs_thmsÝ : ((string * (TERM list * THM)) list ->
	(string * (TERM list * THM)) list) -> unit;
val Ûcurrent_ad_¶_vs_thmsÝ : unit -> 
	(string * (TERM list * THM)) list;
=DESCRIBE
These functions provide the interface to the application data
variable structure information for the existence prover
$prove\_¶\_conv$.
The first sets the evaluator, the second extracts the field
in the current proof context.
=SEEALSO
$set\_¶\_vs\_thms$ for user data.
=FAILURE
51021	The current proof context was created in theory ?0 at a 
	point now either not in scope, deleted or modified
=ENDDOC
=DOC
val Ûset_pr_tacÝ : (THM list -> TACTIC) -> string -> unit;
val Ûget_pr_tacÝ : string -> (THM list -> TACTIC);
=DESCRIBE
These functions provide the interface to the
proof contexts for
$prove\_tac$.
Note that setting overwrites all previous data in this field,
including from merged in proof contexts,
and merged proof contexts will take their value for this field from the last proof context merged in.

Note that when using these functions that the standard rewriting functions (obvious candidates for inclusion in
automatic proof) access the current
proof context at the point of being given their theorem list
argument.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val Ûcurrent_ad_pr_tacÝ : unit -> THM list -> TACTIC;
=DESCRIBE
This function returns the application data of the current proof context
to the
proof contexts for
$prove\_tac$.
=SEEALSO
$set\_pr\_tac$ for user data.
=FAILURE
51021	The current proof context was created in theory ?0 at a 
	point now either not in scope, deleted or modified
=ENDDOC
=DOC
val Ûset_pr_convÝ : (THM list -> CONV) -> string -> unit;
val Ûget_pr_convÝ : string -> (THM list -> CONV);
=DESCRIBE
These functions provide the interface to the
proof contexts for
$prove\_conv$.
Note that setting overwrites all previous data in this field,
including from merged in proof contexts,
and merged proof contexts will take their value for this field from the last proof context merged in.

Note that when using these functions that the standard rewriting functions (obvious candidates for inclusion in
automatic proof) access the current
proof context at the point of being given their theorem list
argument.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51016	Proof context ?0 has been committed
=ENDDOC
=DOC
val Ûcurrent_ad_pr_convÝ : unit -> THM list -> CONV;
=DESCRIBE
This function returns the application data of the current proof context
to the
proof contexts for
$prove\_conv$.
ly, and likely to remain, the
identity function.
=SEEALSO
$set\_pr\_conv$ for user data.
=FAILURE
51021	The current proof context was created in theory ?0 at a 
	point now either not in scope, deleted or modified
=ENDDOC
=TEX
\subsection{Proof Context Stack Functions}
We use a stack of (temporarily) superseded proof contexts to simplify the task 
of ``change the context,
do some work, and then revert to the previous context'',
for this is an obvious approach.
=DOC
val Ûget_stack_pcsÝ : unit -> (string list * string) list;
=DESCRIBE
This lists the keys of the proof contexts held in the proof context
stack, and the theory that was current at their time of creation.
If a proof context is pushed onto the stack by, e.g. $push\_pc$, the ``keys'' will be the singleton list of the name of the source proof context.
If a proof context is pushed onto the stack by, e.g. $push\_merge\_pcs$, the ``keys'' will be the list of the names of the source proof contexts.
If the theory has since been deleted or if the definition level becomes deleted, e.g.
because an axiom or definition has been deleted,
then this will output 
=GFT
(["context name"],"theory name (out of scope, deleted, or modified)")
=TEX
The head of the list returned is the current proof context, as also displayed 
by $get\-\_current\-\_pc$.
=ENDDOC
=FAILURE
51018	?0 (out of scope, deleted, or modified)
=TEX
=DOC
val Ûget_current_pcÝ : unit -> (string list * string);
=DESCRIBE
Returns the key(s) of the entries from which the
current proof context was copied, and the theory in which the single
proof context was created.
If the theory has since been placed out of scope, deleted or if the definition level becomes deleted, e.g.
because an axiom or definition has been deleted,
then this will output 
=GFT
(["context name"],"theory name (out of scope, deleted, or modified)")
=TEX
Note that the key may no longer access a proof context in the database identical to the current proof context.

Merged proof contexts upon the stack  (from $push\_merge\_pcs$ and  $set\_merge\_pcs$) will have the list of names of the constituent proof contexts, singleton contexts will have singleton lists.
=SEEALSO
$get\_stack\_pcs$
=ENDDOC
=DOC
val Ûpush_pcÝ : string -> unit;
val Ûset_pcÝ : string -> unit;
=DESCRIBE
$push\_pc$ stacks the previous ``current'' proof context, and
and sets the current proof context of the system to the proof 
context with the given key.
$set\_pc$ discards the previous ``current'' proof context, and
and sets the current proof context of the system to the proof 
context with the given key.

The current proof context is accessed by the functions prefixed $current\_ad\_$, and by $get\-\_current\-\_pc$.
=SEEALSO
$pending\_push\_pc$, $pop\_pc$, $push\_merge\_pcs$, $set\_merge\_pcs$
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
=ENDDOC
=DOC
val Ûpending_push_pcÝ : string -> unit -> unit;
=DESCRIBE
$pending\_push\_pc$ takes a snapshot of the named
proof context, and returns a function that, when applied
to $()$
stacks the previous ``current'' proof context, and
and sets the current proof context of the system to this snapshot.

The proof context must be in scope both at the time of the snapshot,
and at the time of pushing on the stack.

This provides a method of being independent of changes to
uncommitted proof contexts, or proof context deletions.
=SEEALSO
$push\_pc$
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
=ENDDOC
=DOC
val Ûpush_merge_pcsÝ : string list -> unit;
val Ûset_merge_pcsÝ : string list -> unit;
=DESCRIBE
$push\_merge\_pcs$ stacks the previous ``current'' proof context, and
and sets the current proof context of the system to the merge of the proof 
contexts with the given keys.
$set\_merge\_pcs$ discards the previous ``current'' proof context, and
and sets the current proof context of the system to the merge of the proof 
contexts with the given keys.
Merged proof contexts upon the stack will have $current\-\_ad\-\_names$ giving the list of names of the constituent proof contexts, singleton contexts will have singleton lists.
The proof contexts used need not have been committed.
Note that the $pr\_conv$ and $pr\_tac$ fields will take the value of the
last of the list of proof contexts, rather than being a merge.

The current proof context is accessed by the functions prefixed $current\_ad\_$, and by $get\-\_current\-\_pc$.
=SEEALSO
$pop\_pc$, $push\_pc$, $set\_pc$, $pending\_push\_merge\_pcs$
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51020	Must be at least one key in list
=ENDDOC
=DOC
val Ûpending_push_merge_pcsÝ : string list -> unit -> unit;
=DESCRIBE
$pending\_push\_merge\_pcs$ takes a snapshot of the result of merging the
named proof contexts, and returns a function that, when
applied to $()$
stacks the previous proof context, and
and sets the current proof context of the system to this snapshot.

Merged proof contexts upon the stack will have $current\-\_ad\-\_names$ giving the list of names of the constituent proof contexts, singleton contexts will have singleton lists.
The proof contexts used need not have been committed.
Note that the $pr\_conv$ and $pr\_tac$ fields will take the value of the
last of the list of proof contexts, rather than being a merge.

The proof context must be in scope both at the time of the snapshot,
and at the time of pushing on the stack.

This provides a method of being independent of changes to
uncommitted proof contexts, or proof context deletions.
=SEEALSO
$push\_merge\_pc$
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
51020	Must be at least one key in list
=ENDDOC
=DOC
val Ûpop_pcÝ : unit -> unit;
=DESCRIBE
This function unstacks the top of the proof context stack,
and sets the current proof context of the system to it.
There will always be a current proof context, though it may be the trivial ``initial'' proof context.

This function may make an out of scope proof context 
the current proof context.
=SEEALSO
$push\_pc$, $set\_pc$, $push\_merge\_pcs$, $set\_merge\_pcs$
=FAILURE
51001	The proof context stack is empty
=ENDDOC
=DOC
val Ûpending_reset_pc_databaseÝ : unit -> unit -> unit;
=DESCRIBE
This function, applied to $()$ takes a snapshot of the 
proof context database, and returns a function that,
if applied to $()$ will restore the proof context database
to the snapshot.

This function is particularly useful in initialising 
child databases.

Note that a named proof context on the proof context stack is never
taken as more than an echo of the item with that name
(if any) of proof context database,
and this function in particular, though not alone, is responsible
for the possible differences.
=ENDDOC
=DOC
(* proof context key "ÛinitialÝ" *)
=DESCRIBE
This is the ``empty'' proof context, formed with empty lists.
It thus has no default rewriting or stripping theorems,
no default rewriting canonicalisation, and its automated existence
prover fails on any input.
=ENDDOC
\section{USING THE PROOF CONTEXTS}
=DOC
val ÛPC_TÝ : string -> TACTIC -> TACTIC;
=DESCRIBE
=INLINEFT
PC_T context tac
=TEX
will apply tactic $tac$ to a goal, and evaluate its proof, in the proof context with key $context$,
using the context current at the point of applying the tactic to a goal in both places.
This is done via pushing and popping on the proof context stack.

Note that when using this functions that the standard rewriting functions (obvious candidates for this function) access the current
proof context at the point of being given their theorem list
argument: see $PC\_T1$ for a method of avoiding this.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
=FAILUREC
and as the errors of the tactic.
The previous proof context is restored, even if the tactic application or proof fails.
=ENDDOC
=DOC
val ÛPC_CÝ : string -> CONV -> CONV;
=DESCRIBE
=INLINEFT
PC_C context conv
=TEX
will apply conversion $conv$ to a term in the proof context with key $context$,
taking the context at the point of applying the conversion to a term.
This is done via pushing and popping on the proof context stack.

Note that when using this functions that the standard rewriting functions (obvious candidates for this function) access the current
proof context at the point of being given their theorem list
argument: see $PC\_C1$ for a method of avoiding this.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
=FAILUREC
and as the errors of the conversion.
The previous proof context is restored, even if the conversion fails.
=ENDDOC
=DOC
val Ûpc_ruleÝ : string -> ('a -> THM) -> ('a -> THM);
=DESCRIBE
=INLINEFT
pc_rule context rule
=TEX
will apply rule $rule$ to its argument in the proof context with key $context$,
taking the context at the point of applying the rule to the argument.
This is done via pushing and popping on the proof context stack.

Note that when using this functions that the standard rewriting functions (obvious candidates for this function) access the current
proof context at the point of being given their theorem list
argument: see $pc\_rule1$ for a method of avoiding this.
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
=FAILUREC
and as the errors of the rule.
The previous proof context is restored, even if the rule fails.
=ENDDOC
=DOC
val ÛPC_T1Ý : string -> ('a -> TACTIC) -> 'a -> TACTIC;
=DESCRIBE
=INLINEFT
PC_T1 context tac arg
=TEX
will apply tactic $tac$ $arg$ to a goal, and evaluate the proof, in the proof context with key $context$,
taking the context at the point of applying the tactic to a goal in both places.
This is done via pushing and popping on the proof context stack.
=SEEALSO
$PC\_T$
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
=FAILUREC
and as the errors of the tactic.
The previous proof context is restored, even if the tactic application or proof fails.
=ENDDOC
=DOC
val ÛPC_C1Ý : string -> ('a -> CONV) -> 'a -> CONV;
=DESCRIBE
=INLINEFT
PC_C context conv arg
=TEX
will apply conversion $conv$ $arg$ in the proof context with key $context$,
taking the context at the point of applying the conversion to a term.
This is done via pushing and popping on the proof context stack.
=SEEALSO
$PC\_C$
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
=FAILUREC
and as the errors of the conversion.
The previous proof context is restored, even if the conversion fails.
=ENDDOC
=DOC
val Ûpc_rule1Ý : string -> ('a -> 'b -> THM) -> 'a -> 'b -> THM;
=DESCRIBE
=INLINEFT
pc_rule context rule arg1 arg2
=TEX
will apply rule $rule$ $arg1$ to $arg2$ in the proof context with key $context$,
taking the context at the point of applying the rule to argument $arg2$.
This is done via pushing and popping on the proof context stack.
=SEEALSO
$pc\_rule$
=FAILURE
51010	There is no proof context with key ?0
51014	Proof context ?0 was created in theory ?1 at a 
	point now either not in scope, deleted or modified
=FAILUREC
and as the errors of the rule.
The previous proof context is restored, even if the rule fails.
=ENDDOC
=DOC
val Ûasm_prove_tacÝ : THM list -> TACTIC;
=DESCRIBE
This tactic is an automatic proof procedure appropriate to the
current proof context.

At the point of applying this tactic to its theorems it will
access the current setting of proof context field $pr\_tac$,
apply it to the theorem list immediately, and then to the goal when available
(i.e. the result is partially evaluated with only the list of theorems).
=FRULE 2 Tactic
asm_prove_tac
thms
÷
{ ‡ } t
÷
current_ad_pr_tac () thms ({ ‡ }, t)
=TEX
=SEEALSO
$PC\_T1$ to defer accessing the proof context until application to the goal;
$prove\_tac$ for the form that does not react to the presence of assumptions.
=FAILURE
51021	The current proof context was created in theory ?0 at a 
	point now either not in scope, deleted or modified
=FAILUREC
and as the proof context setting.
=ENDDOC
=DOC
val Ûprove_convÝ : THM list -> CONV;
=DESCRIBE
This conversion is an automatic proof procedure appropriate to the
current proof context.

At the point of applying this conversion to its theorems it will
access the current setting of proof context field $pr\_conv$,
applying the result to the theorem list immediately, and then to the term when available
(i.e. the result is partially evaluated with only the list of theorems).
=FRULE 1 Conversion
prove_conv
thms ¬t®
÷
÷
current_ad_pr_conv () thms ¬t®
=TEX
=SEEALSO
$PC\_C1$ to defer accessing the proof context until application to the term.
=FAILURE
51021	The current proof context was created in theory ?0 at a 
	point now either not in scope, deleted or modified
=FAILUREC
and as the proof context setting.
=ENDDOC
=DOC
val Ûprove_ruleÝ : THM list -> TERM -> THM;
=DESCRIBE
This rule is an automatic proof procedure appropriate to the
current proof context.

At the point of applying this rule to its theorem list it will
access the current setting of proof context field $pr\_conv$,
apply it to the theorem list immediately, and then to the term when available
(i.e. the result is partially evaluated with only the list of theorems),
and then, if the resulting theorem is $`ô term'\ ¤\ T`$
(with no assumptions) where $term$ is $Á$-convertible to $term'$, then
apply $¤\_t\_elim$, and otherwise fail.
=FRULE 1 Rule
prove_rule
thms ¬tm®
÷
÷
ô tm
=TEX
=SEEALSO
$pc\_rule1$ to defer accessing the proof context until application to the term.
=FAILURE
51021	The current proof context was created in theory ?0 at a 
	point now either not in scope, deleted or modified
51022	Result of applying conversion to ?0, which was ?1, 
	not of form: `ô input ¤ T`
=FAILUREC
and as the proof context setting.
=ENDDOC
=DOC
val Ûasm_prove_¶_tacÝ : TACTIC;
=DESCRIBE
This tactic is an automatic proof procedure for existential proofs,
appropriate to the current proof context.

At the point of applying this tactic to a goal it will
access the current setting of proof context field $prove\_¶$,
apply it to the goal using $conv\_tac$.
=FRULE 2 Tactic
asm_prove_¶_tac
thms
÷
{ ‡ } t
÷
conv_tac (current_ad_cs_¶_conv ())
	 ({ ‡ }, t)
=TEX
=SEEALSO
$prove\_¶\_tac$ that does not react to any assumptions that
are present.
=FAILURE
51021	The current proof context was created in theory ?0 at a 
	point now either not in scope, deleted or modified
=FAILUREC
and as the proof context setting.
=ENDDOC
=DOC
val Ûprove_¶_convÝ : CONV;
=DESCRIBE
This conversion is an automatic proof procedure for existential proofs,
appropriate to the current proof context.

At the point of applying this conversion to a term it will
access the current setting of proof context field $cs\_¶\_conv$,
apply it to the theorem list, and then to the term.

The resulting theorem is not checked as having its L.H.S.
being the input term.
=FRULE 1 Conversion
prove_¶_conv
¬t®
÷
÷
current_ad_cs_¶_conv () ¬t®
=TEX
=FAILURE
51021	The current proof context was created in theory ?0 at a 
	point now either not in scope, deleted or modified
=FAILUREC
and as the proof context setting.
=ENDDOC
=DOC
val Ûprove_¶_ruleÝ : TERM -> THM;
=DESCRIBE
This rule is an automatic proof procedure for existential proofs,
appropriate to the current proof context.

At the point of applying this rule to a term $term$ it will
access the current setting of proof context field $cs\_¶\_conv$,
apply it to the term,
and then, if the resulting theorem is $`ô term'\ ¤\ T`$
(with no assumptions) where $term$ is $Á$-convertible to $term'$, then
apply $¤\_t\_elim$, and otherwise fail.
=FRULE 1 Rule
prove_¶_rule
¬tm®
÷
÷
ô tm
=TEX
=FAILURE
51021	The current proof context was created in theory ?0 at a 
	point now either not in scope, deleted or modified
51022	Result of applying conversion to ?0, which was ?1, 
	not of form: `ô input ¤ T`
=FAILUREC
and as the proof context setting.
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of ProofContext *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


