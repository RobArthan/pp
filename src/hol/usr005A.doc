% usr005A.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
In this chapter, the concrete representation of the \HOL\ logic is described.
This involves describing the \ML\ functions that comprise the interface to the
logic %(up to and including Section~\ref{avra_terms})
; the quotation, printing
and parsing of logical terms %(Section~\ref{quotation})
; the representation of
theorems %(Section~\ref{avra_theorems})
; the representation of theories %(Section~\ref{theoryfns})
; the basic \HOL\ theories that are built into the \HOL\ system %(Sections~\ref{HOL-theory} and \ref{rules})
; the methods for extending theories %(throughout Section~\ref{HOL-ancestry} and in Section~\ref{types-package})
; and the \ML\ system functions concerning the logic %(Section~\ref{HOLflags})
.
It is assumed that the reader is familiar with \ML.

The \HOL\ system provides \ML\ types \ml{TYPE} and \ml{TERM} to represent
types and terms of the \HOL\ logic%, as defined in Sections~\ref{types} and \ref{terms}, respectively
.\footnote{Care must be taken to avoid confusion between ML types and types of the HOL logic: the ML type {\tt TYPE} represents types of the HOL logic in ML.}
It also provides primitive \ML\ functions for creating and manipulating values of these types.
The implementation of HOL in \Product follow the ``LCF paradigm'', due to Robin Milner\index{Milner, R.}.
This means that theorems are represented as an abstract \ML\ type whose only pre-defined values are axioms, and whose only operations are rules of inference.
Consequently the only way to construct theorems in \HOL\ is to apply rules of inference to axioms or existing theorems; hence the consistency of the logic is preserved.

The purpose of the meta-language \ML\ is to provide a programming environment
in which to build theorem proving tools to assist in the construction of
proofs.  When the \HOL\ system is built, a range of useful theorems are
pre-proved and a set of tools pre-defined. The basic system thus offers a rich
initial environment; users can further enrich it by implementing their own
application specific tools and building their own application specific
theories.

\section{Lexical Analysis}
\label{Lexical Analysis}
\input{def001C}

\section{Concrete Syntax}
\label{Concrete Syntax}
\input{def001A}
\input{def001B}

\section{Aliases and Overloading}
\label{Aliases and Overloading}
\input{def001D}

\section{Type Abbreviations}
\label{Type Abbreviations}
\input{def001E}









