% mdt025.doc   %Z% $Date$ $Revision$ $RCSfile$

=TEX
% mdt025.doc   %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol,11pt,TQ]{article}

\TPPtitle{Module Tests for Pretty Printer}
\TPPref{DS/FMU/IED/MDT025}
\def\SCCSissue{$Revision$%
}
\TPPissue{\SCCSissue}
\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{FST PROJECT}

=IGN

Commands to process this document in various ways.

doc4errors mdt025
usefile "mdt025.sml";

make -f rel001.mkf mdt025.dvi
doc4tex mdt025
tex4dvi mdt025
bibtex mdt025
doc4tex mdt025 ; tex4dvi mdt025
doc4tex mdt025 ; tex4dvi mdt025 ; bibtex mdt025
dvipage mdt025 &

doc4errors mdt025
usefile "mdt025.sml";

=TEX
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the module tests for the ICL~HOL
	Pretty Printer.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

%********************************************************************

\subsection{Contents List}
\tableofcontents
% \listoftables

%********************************************************************

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

%********************************************************************

\subsection{Changes History}

\begin{description}

\item[\FormatDate{91/07/10}, issue 1.1~] First issue.

\item[\FormatDate{91/07/16}, issue 1.2~]
	Extra test cases.

\item[\FormatDate{91/08/08}, issue 1.4~]
	Changed names of syntax functions.
	Function $format_term$ no longer includes the term brackets.
	All tests work with version~1.27 of ICL~HOL.

\item[\FormatDate{91/08/15}, issue 1.5~]
	Renamings of functions containing the name atom $simple$, and renaming of $aconv$.

%\item[\FormatDate{$Date$%
%}, issue \SCCSissue~]

\end{description}

%********************************************************************

\subsection{Changes Forecast} \label{ChangesForecast}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the module tests for the pretty printing
routines for Release~1 of the ICL HOL system which are discussed
in~\cite{DS/FMU/IED/IMP025}.  The tests use the module testing system
of~\cite{DS/FMU/IED/DTD013} and~\cite{DS/FMU/IED/IMP013}.

%********************************************************************

\subsection{Introduction}

Each test, or part of a test, is identified by a string of the form
``$\cal N_M$'' or ``$\cal N_MA$'' where: ``$\cal N$'' indicates the
area of the test; ``$\cal M$'' is the test number; and, ``$\cal A$'' is
ancillary labelling for the test.

The first major group of tests are concerned with getting the correct
layout of the brackets and components of the terms, most of these
tests use a very wide line length to ensure that all the output is
on a single line.

Most of the tests are run twice.  Firstly to see if the expected output
is produced.  Secondly (using function $uft$) to ensure that the text
that is produced can be parsed back in as the same term.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TEST HARNESS INITIALISATION}

=IGN
Get the test harness files
sccs -d ~ied get dtd013.doc imp013.doc
doc4errors dtd013
doc4errors imp013

doc4errors mdt025
usefile "mdt025.sml";

=TEX

Load and initialise the module test system.

=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results ();
=TEX

Use very long lines for the first tests.

=SML
set_line_length 500;
=TEX

Functions $ft$ and $uft$ are used to invoke the tests.  The first just
formats the term into a single string, the second formats the term into
a single string, parses it back as a term and formats the result of
that.

=SML
fun ft (x:TERM) : string list = PrettyPrinter.format_term x;

val uft_aux : TERM ref = ref »1¼;

fun uft (x:TERM) : TERM =
let
	val t1 = implode(ft x);
	val side_effect = usestring("(uft_aux := »" ^ t1 ^ "¼; !uft_aux)");
in
	!uft_aux
end;
=TEX

%********************************************************************

\subsection{Temporary}

Some initialisations required in the absence of the proper
declarations for the operators types and constants about:
	pairing
and
	sets.

=SML
(	declare_infix (100, "‰")		handle Fail _ => (),	"infix ‰");
(Value	(new_type("‰", 2))			handle Fail _ => Nil,	"new_type ‰");
(	declare_infix (100, ",")			handle Fail _ => (),	"infix ,");
(Value	(new_const(",", type_of»x:'a‹'b‹('a‰'b)¼))
						handle Fail _ => Nil,	"new_const ,");

(Value	(new_type("SET", 1))			handle Fail _ => Nil,	"new_type SET");
(Value	(new_const("Empty", »:'1 SET¼))	handle Fail _ => Nil,	"new_const Empty");
(Value	(new_const("Insert", »:'1 ‹ '1 SET ‹ '1 SET¼))
						handle Fail _ => Nil,	"new_const Insert");

(Value	(new_const("Uncurry", »:('a ‹ 'b ‹ 'c) ‹ ('a ‰ 'b) ‹ 'c¼))
						handle Fail _ => Nil,	"new_const Uncurry");
(Value	(new_const("SetComp", »:(('a ‰ 'b) ‹ BOOL) ‹ ('a ‰ 'b) SET¼))
						handle Fail _ => Nil,	"new_const SetComp");
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{THE TESTS}

\subsection{Simple constants and function applications}

=SML
let
val t1_010 =	»1¼;
val a1_010 =	["1"];
val t1_020 =	»x 1¼;
val a1_020 =	["x 1"];
val t1_030 =	»x y 1¼;
val a1_030 =	["x y 1"];
val t1_040 =	»x y z 1¼;
val a1_040 =	["x y z 1"];
val t1_050 =	»ax bx cx dx ex fx gx hx ix jx kx lx mx nx ox px qx rx sx tx ux vx wx xx yx zx¼;
val a1_050 =	["ax bx cx dx ex fx gx hx ix jx kx lx mx nx ox px qx rx sx tx ux vx wx xx yx zx"];
val t1_060 =	»x€y¼;
val a1_060 =	["x € y"];

in

store_mt_results_show mt_run[
("1_010", ft, t1_010, a1_010),
("1_020", ft, t1_020, a1_020),
("1_030", ft, t1_030, a1_030),
("1_040", ft, t1_040, a1_040),
("1_050", ft, t1_050, a1_050),
("1_060", ft, t1_060, a1_060)
];

store_mt_results_show mt_run[
("1_010f", uft, t1_010, t1_010),
("1_020f", uft, t1_020, t1_020),
("1_030f", uft, t1_030, t1_030),
("1_040f", uft, t1_040, t1_040),
("1_050f", uft, t1_050, t1_050),
("1_060f", uft, t1_060, t1_060)
]

end;
=TEX

\subsection{Infix Operators}

=SML
let
val t2_010 =	»x€y€z¼;
val a2_010 =	["x € y € z"];
val t2_020 =	»(x€y)€z¼;
val a2_020 =	["(x € y) € z"];
val t2_030 =	»x€(y€z)¼;
val a2_030 =	["x € y € z"];
val t2_040 =	»w€x€y€z¼;
val a2_040 =	["w € x € y € z"];

in

store_mt_results_show mt_run[
("2_010", ft, t2_010, a2_010),
("2_020", ft, t2_020, a2_020),
("2_030", ft, t2_030, a2_030),
("2_040", ft, t2_040, a2_040)
];

store_mt_results_show mt_run[
("2_010f", uft, t2_010, t2_010),
("2_020f", uft, t2_020, t2_020),
("2_030f", uft, t2_030, t2_030),
("2_040f", uft, t2_040, t2_040)
]
end;
=TEX

=SML
let
val t2_050 =	»(w€x)€y€z¼;
val a2_050 =	["(w € x) € y € z"];
val t2_060 =	»w€x€(y€z)¼;
val a2_060 =	["w € x € y € z"];
val t2_070 =	»(w€x)€(y€z)¼;
val a2_070 =	["(w € x) € y € z"];
val t2_080 =	»w€(x€y)€z¼;
val a2_080 =	["w € (x € y) € z"];

in

store_mt_results_show mt_run[
("2_050", ft, t2_050, a2_050),
("2_060", ft, t2_060, a2_060),
("2_070", ft, t2_070, a2_070),
("2_080", ft, t2_080, a2_080)
];

store_mt_results_show mt_run[
("2_050f", uft, t2_050, t2_050),
("2_060f", uft, t2_060, t2_060),
("2_070f", uft, t2_070, t2_070),
("2_080f", uft, t2_080, t2_080)
]
end;
=TEX

=SML
let
val t2_090 =	»wx€yz¼;
val a2_090 =	["w  x € y  z"];
val t2_100 =	»(wx)€yz¼;
val a2_100 =	["(w  x) € y  z"];
val t2_110 =	»w(x€y)z¼;
val a2_110 =	["w  x € y  z"];
val t2_120 =	»w€(xy)€z¼;
val a2_120 =	["w € (x  y) € z"];
val t2_130 =	»wx€(yz)¼;
val a2_130 =	["w  x € (y  z)"];
val t2_140 =	»(wx)€(yz)¼;
val a2_140 =	["(w  x) € (y  z)"];

in

store_mt_results_show mt_run[
("2_090", ft, t2_090, a2_090),
("2_100", ft, t2_100, a2_100),
("2_110", ft, t2_110, a2_110),
("2_120", ft, t2_120, a2_120),
("2_130", ft, t2_130, a2_130),
("2_140", ft, t2_140, a2_140)
];

store_mt_results_show mt_run[
("2_090f", uft, t2_090, t2_090),
("2_100f", uft, t2_100, t2_100),
("2_110f", uft, t2_110, t2_110),
("2_120f", uft, t2_120, t2_120),
("2_130f", uft, t2_130, t2_130),
("2_140f", uft, t2_140, t2_140)
]
end;
=TEX

=SML
let
val t2_150 =	»f wg x€h yj z¼;
val a2_150 =	["f w  g x € h y  j z"];
val t2_160 =	»(f wg x)€h yj z¼;
val a2_160 =	["(f w  g x) € h y  j z"];
val t2_170 =	»f w(g x€h y)j z¼;
val a2_170 =	["f w  g x € h y  j z"];
val t2_180 =	»f wg x€(h yj z)¼;
val a2_180 =	["f w  g x € (h y  j z)"];
val t2_190 =	»(f wg x)€(h yj z)¼;
val a2_190 =	["(f w  g x) € (h y  j z)"];

=IGN
val t2_150 =	»f wg x€h yj z¼;
val a2_150 =	["(f w)  (g x) € (h y)  (j z)"];
val t2_160 =	»(f wg x)€h yj z¼;
val a2_160 =	["((f w)  (g x)) € (h y)  (j z)"];
val t2_170 =	»f w(g x€h y)j z¼;
val a2_170 =	["(f w)  (g x) € (h y)  (j z)"];
val t2_180 =	»f wg x€(h yj z)¼;
val a2_180 =	["(f w)  (g x) € ((h y)  (j z))"];
val t2_190 =	»(f wg x)€(h yj z)¼;
val a2_190 =	["((f w)  (g x)) € ((h y)  (j z))"];
=SML

in

store_mt_results_show mt_run[
("2_150", ft, t2_150, a2_150),
("2_160", ft, t2_160, a2_160),
("2_170", ft, t2_170, a2_170),
("2_180", ft, t2_180, a2_180),
("2_190", ft, t2_190, a2_190)
];

store_mt_results_show mt_run[
("2_150f", uft, t2_150, t2_150),
("2_160f", uft, t2_160, t2_160),
("2_170f", uft, t2_170, t2_170),
("2_180f", uft, t2_180, t2_180),
("2_190f", uft, t2_190, t2_190)
]
end;
=TEX

=SML
let
val t2_200 =	»f (wg) (x€h) (yj) z¼;
val a2_200 =	["f (w  g) (x € h) (y  j) z"];
val t2_210 =	»(f (wg) x)€h (yj) z¼;
val a2_210 =	["f (w  g) x € h (y  j) z"];

in

store_mt_results_show mt_run[
("2_200", ft, t2_200, a2_200),
("2_210", ft, t2_210, a2_210)
];

store_mt_results_show mt_run[
("2_200f", uft, t2_200, t2_200),
("2_210f", uft, t2_210, t2_210)
]
end;
=TEX

\subsection{Conditionals}

=SML
let
val t3_010 =	»if x = y then 1 else z¼;
val a3_010 =	["if x = y then 1 else z"];
val t3_020 =	»if x = y then if x = yy then 2 else 3 else z¼;
val a3_020 =	["if x = y then if x = yy then 2 else 3 else z"];
val t3_030 =	»if x = y then 1 else if x = yy then 2 else 3¼;
val a3_030 =	["if x = y then 1 else if x = yy then 2 else 3"];

in

store_mt_results_show mt_run[
("3_010", ft, t3_010, a3_010),
("3_020", ft, t3_020, a3_020),
("3_030", ft, t3_030, a3_030)
];

store_mt_results_show mt_run[
("3_010f", uft, t3_010, t3_010),
("3_020f", uft, t3_020, t3_020),
("3_030f", uft, t3_030, t3_030)
]
end;
=TEX

=SML
let
val t3_040 =	»if x = y then z else w € z¼;
val a3_040 =	["if x = y then z else w € z"];
val t3_050 =	»if x = y then if x = yy then w € z1 else w € z2 else w € z3¼;
val a3_050 =	["if x = y then if x = yy then w € z1 else w € z2 else w € z3"];
val t3_060 =	»(if x = y then w € z1 else if x = yy then w € z2 else w) € z3¼;
val a3_060 =	["(if x = y then w € z1 else if x = yy then w € z2 else w) € z3"];
val t3_070 =	»(a € if x = y then w € z1 else if x = yy then w € z2 else w) € z3¼;
val a3_070 =	["(a € (if x = y then w € z1 else if x = yy then w € z2 else w)) € z3"];
val t3_080 =	»a € (if x = y then w € z1 else if x = yy then w € z2 else w) € z3¼;
val a3_080 =	["a € (if x = y then w € z1 else if x = yy then w € z2 else w) € z3"];
val t3_090 =	»(a € (if x = y then w € z1 else if x = yy then w € z2 else w)) € z3¼;
val a3_090 =	["(a € (if x = y then w € z1 else if x = yy then w € z2 else w)) € z3"];
val t3_100 =	»a € ((if x = y then w € z1 else if x = yy then w € z2 else w) € z3)¼;
val a3_100 =	["a € (if x = y then w € z1 else if x = yy then w € z2 else w) € z3"];

in

store_mt_results_show mt_run[
("3_040", ft, t3_040, a3_040),
("3_050", ft, t3_050, a3_050),
("3_060", ft, t3_060, a3_060),
("3_070", ft, t3_070, a3_070),
("3_080", ft, t3_080, a3_080),
("3_090", ft, t3_090, a3_090),
("3_100", ft, t3_100, a3_100)
];

store_mt_results_show mt_run[
("3_040f", uft, t3_040, t3_040),
("3_050f", uft, t3_050, t3_050),
("3_060f", uft, t3_060, t3_060),
("3_070f", uft, t3_070, t3_070),
("3_080f", uft, t3_080, t3_080),
("3_090f", uft, t3_090, t3_090),
("3_100f", uft, t3_100, t3_100)
]
end;
=TEX

=SML
let
val t3_110 =	»(if a then b else c d e f)¼;
val a3_110 =	["if a then b else c d e f"];
val t3_120 =	»(if a then b else c) d e f¼;
val a3_120 =	["(if a then b else c) d e f"];
val t3_130 =	»p q r (if a then b else c d e f)¼;
val a3_130 =	["p q r (if a then b else c d e f)"];
val t3_140 =	»p q r (if a then b else c) d e f¼;
val a3_140 =	["p q r (if a then b else c) d e f"];
val t3_150 =	»p q r (if a then b else c) d e f¼;
val a3_150 =	["p q r (if a then b else c) d e f"];
val t3_160 =	»p q r ((if a then b else c) d e f)¼;
val a3_160 =	["p q r ((if a then b else c) d e f)"];

in

store_mt_results_show mt_run[
("3_110", ft, t3_110, a3_110),
("3_120", ft, t3_120, a3_120),
("3_130", ft, t3_130, a3_130),
("3_140", ft, t3_140, a3_140),
("3_150", ft, t3_150, a3_150),
("3_160", ft, t3_160, a3_160)
];

store_mt_results_show mt_run[
("3_110f", uft, t3_110, t3_110),
("3_120f", uft, t3_120, t3_120),
("3_130f", uft, t3_130, t3_130),
("3_140f", uft, t3_140, t3_140),
("3_150f", uft, t3_150, t3_150),
("3_160f", uft, t3_160, t3_160)
]
end;
=TEX

\subsection{Binder Terms}

=SML
let
val t4_010 =	» x Ž x¼;
val a4_010 =	[" xŽ x"];
val t4_020 =	» x Ž y¼;
val a4_020 =	[" xŽ y"];
val t4_030 =	» x Ž x y¼;
val a4_030 =	[" xŽ x y"];
val t4_040 =	»( x Ž x) y¼;
val a4_040 =	["( xŽ x) y"];
val t4_050 =	» x Ž (x y)¼;
val a4_050 =	[" xŽ x y"];
val t4_060 =	»w  x Ž x y¼;
val a4_060 =	["w ( xŽ x y)"];
val t4_070 =	»w ( x Ž x) y¼;
val a4_070 =	["w ( xŽ x) y"];
val t4_080 =	»w ( x Ž (x y))¼;
val a4_080 =	["w ( xŽ x y)"];
val t4_090 =	»(w ( x Ž x)) y¼;
val a4_090 =	["w ( xŽ x) y"];

in

store_mt_results_show mt_run[
("4_010", ft, t4_010, a4_010),
("4_020", ft, t4_020, a4_020),
("4_030", ft, t4_030, a4_030),
("4_040", ft, t4_040, a4_040),
("4_050", ft, t4_050, a4_050),
("4_060", ft, t4_060, a4_060),
("4_070", ft, t4_070, a4_070),
("4_080", ft, t4_080, a4_080),
("4_090", ft, t4_090, a4_090)
];

store_mt_results_show mt_run[
("4_010f", uft, t4_010, t4_010),
("4_020f", uft, t4_020, t4_020),
("4_030f", uft, t4_030, t4_030),
("4_040f", uft, t4_040, t4_040),
("4_050f", uft, t4_050, t4_050),
("4_060f", uft, t4_060, t4_060),
("4_070f", uft, t4_070, t4_070),
("4_080f", uft, t4_080, t4_080),
("4_090f", uft, t4_090, t4_090)
]
end;
=TEX

=SML
let
val t4_100 =	»ƒ x Ž x¼;
val a4_100 =	["ƒ xŽ x"];
val t4_110 =	»ƒ x Ž (x y)¼;
val a4_110 =	["ƒ xŽ x y"];
val t4_120 =	»w ƒ x Ž x¼;
val a4_120 =	["w (ƒ xŽ x)"];
val t4_130 =	»w (ƒ x Ž x)¼;
val a4_130 =	["w (ƒ xŽ x)"];

in

store_mt_results_show mt_run[
("4_100f", uft, t4_100, t4_100),
("4_110f", uft, t4_110, t4_110),
("4_120f", uft, t4_120, t4_120),
("4_130f", uft, t4_130, t4_130)
];

store_mt_results_show mt_run[
("4_100", ft, t4_100, a4_100),
("4_110", ft, t4_110, a4_110),
("4_120", ft, t4_120, a4_120),
("4_130", ft, t4_130, a4_130)
]
end;
=TEX

=SML
let
val t4_140 =	»(ƒ w Ž w)€(ƒ x Ž x)€(ƒ y Ž y)€(ƒ z Ž z)¼;
val a4_140 =	["(ƒ wŽ w) € (ƒ xŽ x) € (ƒ yŽ y) € (ƒ zŽ z)"];
val t4_150 =	»((ƒ w Ž w)€(ƒ x Ž x))€(ƒ y Ž y)€(ƒ z Ž z)¼;
val a4_150 =	["((ƒ wŽ w) € (ƒ xŽ x)) € (ƒ yŽ y) € (ƒ zŽ z)"];
val t4_160 =	»(ƒ w Ž w)€(ƒ x Ž x)€((ƒ y Ž y)€(ƒ z Ž z))¼;
val a4_160 =	["(ƒ wŽ w) € (ƒ xŽ x) € (ƒ yŽ y) € (ƒ zŽ z)"];
val t4_170 =	»((ƒ w Ž w)€(ƒ x Ž x))€((ƒ y Ž y)€(ƒ z Ž z))¼;
val a4_170 =	["((ƒ wŽ w) € (ƒ xŽ x)) € (ƒ yŽ y) € (ƒ zŽ z)"];
val t4_180 =	»(ƒ w Ž w)€((ƒ x Ž x)€(ƒ y Ž y))€(ƒ z Ž z)¼;
val a4_180 =	["(ƒ wŽ w) € ((ƒ xŽ x) € (ƒ yŽ y)) € (ƒ zŽ z)"];

in

store_mt_results_show mt_run[
("4_140", ft, t4_140, a4_140),
("4_150", ft, t4_150, a4_150),
("4_160", ft, t4_160, a4_160),
("4_170", ft, t4_170, a4_170),
("4_180", ft, t4_180, a4_180)
];

store_mt_results_show mt_run[
("4_140f", uft, t4_140, t4_140),
("4_150f", uft, t4_150, t4_150),
("4_160f", uft, t4_160, t4_160),
("4_170f", uft, t4_170, t4_170),
("4_180f", uft, t4_180, t4_180)
]
end;
=TEX

=SML
let
val t4_190 =	» x Ž x€y¼;
val a4_190 =	[" xŽ x € y"];
val t4_200 =	» x Ž if x then y else z¼;
val a4_200 =	[" xŽ if x then y else z"];

in

store_mt_results_show mt_run[
("4_190", ft, t4_190, a4_190),
("4_200", ft, t4_200, a4_200)
];

store_mt_results_show mt_run[
("4_190f", uft, t4_190, t4_190),
("4_200f", uft, t4_200, t4_200)
]
end;
=TEX

=SML
let
val t4_210 =	»ƒ x Ž y = if x then 1 else 2¼;
val a4_210 =	["ƒ xŽ y = (if x then 1 else 2)"];
val t4_220 =	»(ƒ x Ž y) = (if x then p else q)¼;
val a4_220 =	["(ƒ xŽ y) ‚ (if x then p else q)"];

in

store_mt_results_show mt_run[
("4_210", ft, t4_210, a4_210),
("4_220", ft, t4_220, a4_220)
];

store_mt_results_show mt_run[
("4_210f", uft, t4_210, t4_210),
("4_220f", uft, t4_220, t4_220)
]
end;
=TEX

=SML
let
val t4_230 =	»ƒxŽƒyŽƒzŽx€y€z¼;
val a4_230 =	["ƒ x y zŽ x € y € z"];
val t4_240 =	»„xŽƒyŽ„zŽx€y€z¼;
val a4_240 =	["„ xŽ ƒ yŽ „ zŽ x € y € z"];

in

store_mt_results_show mt_run[
("4_230", ft, t4_230, a4_230),
("4_240", ft, t4_240, a4_240)
];

store_mt_results_show mt_run[
("4_230f", uft, t4_230, t4_230),
("4_240f", uft, t4_240, t4_240)
]
end;
=TEX

=SML
let
val t4_250 =	»f =  x Ž  y Ž x€y¼;
val a4_250 =	["f = ( x yŽ x € y)"];
val t4_260 =	»f =  (x,y) Ž x€y¼;
val a4_260 =	["f = ( (x, y)Ž x € y)"];


in

store_mt_results_show mt_run[
("4_250", ft, t4_250, a4_250),
("4_260", ft, t4_260, a4_260)
];

store_mt_results_show mt_run[
("4_250f", uft, t4_250, t4_250),
("4_260f", uft, t4_260, t4_260)
]
end;
=TEX

Binders with varstructs.

=SML
let
val t4_260 =	»ƒ a Ž x¼;
val a4_260 =	["ƒ aŽ x"];
val t4_270 =	» a Ž x¼;
val a4_270 =	[" aŽ x"];

in

store_mt_results_show mt_run[
("4_260", ft, t4_260, a4_260),
("4_270", ft, t4_270, a4_270)
];

store_mt_results_show mt_run[
("4_260f", uft, t4_260, t4_260),
("4_270f", uft, t4_270, t4_270)
]
end;
=TEX

=SML
let

val t4_280 =	»ƒ (a,b) Ž x¼;
val a4_280 =	["ƒ (a, b)Ž x"];
val t4_290 =	»ƒ (a,b,c) Ž x¼;
val a4_290 =	["ƒ (a, b, c)Ž x"];
val t4_300 =	»ƒ (a,b,c,d) Ž x¼;
val a4_300 =	["ƒ (a, b, c, d)Ž x"];
val t4_310 =	» (a,b) Ž x¼;
val a4_310 =	[" (a, b)Ž x"];
val t4_320 =	» (a,b,c) Ž x¼;
val a4_320 =	[" (a, b, c)Ž x"];
val t4_330 =	» (a,b,c,d) Ž x¼;
val a4_330 =	[" (a, b, c, d)Ž x"];

in

store_mt_results_show mt_run[
("4_280", ft, t4_280, a4_280),
("4_290", ft, t4_290, a4_290),
("4_300", ft, t4_300, a4_300),
("4_310", ft, t4_310, a4_310),
("4_320", ft, t4_320, a4_320),
("4_330", ft, t4_330, a4_330)
];

store_mt_results_show mt_run[
("4_280f", uft, t4_280, t4_280),
("4_290f", uft, t4_290, t4_290),
("4_300f", uft, t4_300, t4_300),
("4_310f", uft, t4_310, t4_310),
("4_320f", uft, t4_320, t4_320),
("4_330f", uft, t4_330, t4_330)
]
end;
=TEX

=SML
let

val t4_340 =	»ƒ a b c Ž d¼;
val a4_340 =	["ƒ a b cŽ d"];
val t4_350 =	»ƒ a Ž ƒ b Ž ƒ c Ž d¼;
val a4_350 =	["ƒ a b cŽ d"];
val t4_360 =	» a b c Ž d¼;
val a4_360 =	[" a b cŽ d"];
val t4_370 =	» a Ž  b Ž  c Ž d¼;
val a4_370 =	[" a b cŽ d"];

in

store_mt_results_show mt_run[
("4_340", ft, t4_340, a4_340),
("4_350", ft, t4_350, a4_350),
("4_360", ft, t4_360, a4_360),
("4_370", ft, t4_370, a4_370)
];

store_mt_results_show mt_run[
("4_340f", uft, t4_340, t4_340),
("4_350f", uft, t4_350, t4_350),
("4_360f", uft, t4_360, t4_360),
("4_370f", uft, t4_370, t4_370)
]
end;
=TEX

=SML
let

val t4_380 =	»ƒ (((a,b),c),d) Ž x¼;
val a4_380 =	["ƒ (((a, b), c), d)Ž x"];
val t4_390 =	»ƒ ((a,b),(c,d)) Ž x¼;
val a4_390 =	["ƒ ((a, b), c, d)Ž x"];
val t4_400 =	» (((a,b),c),d) Ž x¼;
val a4_400 =	[" (((a, b), c), d)Ž x"];
val t4_410 =	» ((a,b),(c,d)) Ž x¼;
val a4_410 =	[" ((a, b), c, d)Ž x"];

in

store_mt_results_show mt_run[
("4_380", ft, t4_380, a4_380),
("4_390", ft, t4_390, a4_390),
("4_400", ft, t4_400, a4_400),
("4_410", ft, t4_410, a4_410)
];

store_mt_results_show mt_run[
("4_380f", uft, t4_380, t4_380),
("4_390f", uft, t4_390, t4_390),
("4_400f", uft, t4_400, t4_400),
("4_410f", uft, t4_410, t4_410)
]
end;
=TEX

=SML
let

val t4_420 =	»ƒ ((a,((b,(c,(d,((e,f),(g,h)),i,(j,k,l),m),n)),o)),p) Ž x¼;
val a4_420 =	["ƒ ((a, (b, c, (d, ((e, f), g, h), i, (j, k, l), m), n), o), p)Ž x"];
val t4_430 =	» (a,b,(c,(d,e,f),g),((h,i),j),(k,(l,(m,n))),o,p) Ž x¼;
val a4_430 =	[" (a, b, (c, (d, e, f), g), ((h, i), j), (k, l, m, n), o, p)Ž x"];

in

store_mt_results_show mt_run[
("4_420", ft, t4_420, a4_420),
("4_430", ft, t4_430, a4_430)
];

store_mt_results_show mt_run[
("4_420f", uft, t4_420, t4_420),
("4_430f", uft, t4_430, t4_430)
]
end;
=TEX

Some binders where types are to be shown.

=SML
let

val t4_440 =	»ƒ a b c d Ž a = b € a = c € a = d¼;
val a4_440 =	["ƒ a b c dŽ a = b € a = c € a = d"];
val l4_440 =	["ƒ a b c d: 'aŽ a = b € a = c € a = d"];

val t4_450 =	»ƒ a b c d Ž a = b € c = d¼;
val a4_450 =	["ƒ a b c dŽ a = b € c = d"];
val l4_450 =	["ƒ a b: 'a; c d: 'bŽ a = b € c = d"];

val t4_460 =	» a b c d Ž a = b € a = c € a = d¼;
val a4_460 =	[" a b c dŽ a = b € a = c € a = d"];
val l4_460 =	[" a b c d: 'aŽ a = b € a = c € a = d"];

val t4_470 =	» a b c d Ž a = b € c = d¼;
val a4_470 =	[" a b c dŽ a = b € c = d"];
val l4_470 =	[" a b: 'a; c d: 'bŽ a = b € c = d"];

val t4_480 =	»ƒ (a1, a2) (b1, b2) ((c1, c2), c3) ((d1, d2), d3)
		Ž (a1, a2) = (b1, b2)
		€ ((c1, c2), c3) = ((d1, d2), d3)¼;
val a4_480 =	["ƒ (a1, a2) (b1, b2) ((c1, c2), c3) ((d1, d2), d3)"
		^"Ž (a1, a2) = (b1, b2)"
		^" € ((c1, c2), c3) = ((d1, d2), d3)"];
val l4_480 =	["ƒ (a1, a2) (b1, b2): 'a ‰ 'b;"
		^" ((c1, c2), c3) ((d1, d2), d3): ('c ‰ 'd) ‰ 'e"
		^"Ž (a1, a2) = (b1, b2)"
		^" € ((c1, c2), c3) = ((d1, d2), d3)"];

val t4_490 =	»ƒ (a1, (a2, a3)) (b1, (b2, b3)) ((c1, c2), c3) ((d1, d2), d3) Ž x¼;
val a4_490 =	["ƒ (a1, a2, a3) (b1, b2, b3) ((c1, c2), c3) ((d1, d2), d3)Ž x"];
val l4_490 =	["ƒ (a1, a2, a3): 'a ‰ 'b ‰ 'c;"
		^" (b1, b2, b3): 'd ‰ 'e ‰ 'f;"
		^" ((c1, c2), c3):"
		^" ('g ‰ 'h) ‰ 'i;"
		^" ((d1, d2), d3): ('j ‰ 'k) ‰ 'lŽ x"];

val t4_500 =	»ƒ (a1, (a2, a3)) (b1, (b2, b3)) ((c1, c2), c3) ((d1, d2), d3)
		Ž (a1, (a2, a3)) = (b1, (b2, b3))
		€ ((c1, c2), c3) = ((d1, d2), d3)¼;
val a4_500 =	["ƒ (a1, a2, a3) (b1, b2, b3) ((c1, c2), c3) ((d1, d2), d3)"
		^"Ž (a1, a2, a3) = (b1, b2, b3)"
		^" € ((c1, c2), c3) = ((d1, d2), d3)"];
val l4_500 =	["ƒ (a1, a2, a3) (b1, b2, b3): 'a ‰ 'b ‰ 'c;"
		^" ((c1, c2), c3) ((d1, d2), d3):"
		^" ('d ‰ 'e) ‰ 'f"
		^"Ž (a1, a2, a3) = (b1, b2, b3)"
		^" € ((c1, c2), c3) = ((d1, d2), d3)"];

val t4_510 =	»ƒ (a1, (a2, a3)) (b1, (b2, b3)) ((c1, c2), c3) ((d1, d2), d3)
		Ž a1 = b1 € a2 = b2 € a3 = b3
		€ a1 = c1 € a2 = c2 € a3 = c3
		€ a1 = d1 € a2 = d2 € a3 = d3¼;
val a4_510 =	["ƒ (a1, a2, a3) (b1, b2, b3) ((c1, c2), c3) ((d1, d2), d3)"
		^"Ž a1 = b1 € a2 = b2 € a3 = b3"
		^" € a1 = c1 € a2 = c2 € a3 = c3"
		^" € a1 = d1 € a2 = d2 € a3 = d3"];
val l4_510 =	["ƒ (a1, a2, a3) (b1, b2, b3): 'a ‰ 'b ‰ 'c;"
		^" ((c1, c2), c3) ((d1, d2), d3): ('a ‰ 'b) ‰ 'c"
		^"Ž a1 = b1 € a2 = b2 € a3 = b3"
		^" € a1 = c1 € a2 = c2 € a3 = c3"
		^" € a1 = d1 € a2 = d2 € a3 = d3"];

val t4_520 =	»ƒ (a1, (a2, a3)) (b1, (b2, b3)) (c1, (c2, c3)) (d1, (d2, d3))
		Ž a1 = b1 € a2 = b2 € a3 = b3
		€ a1 = c1 € a2 = c2 € a3 = c3
		€ a1 = d1 € a2 = d2 € a3 = d3¼;
val a4_520 =	["ƒ (a1, a2, a3) (b1, b2, b3) (c1, c2, c3) (d1, d2, d3)"
		^"Ž a1 = b1 € a2 = b2 € a3 = b3"
		^" € a1 = c1 € a2 = c2 € a3 = c3"
		^" € a1 = d1 € a2 = d2 € a3 = d3"];
val l4_520 =	["ƒ (a1, a2, a3) (b1, b2, b3)"
		^" (c1, c2, c3) (d1, d2, d3): 'a ‰ 'b ‰ 'c"
		^"Ž a1 = b1 € a2 = b2 € a3 = b3"
		^" € a1 = c1 € a2 = c2 € a3 = c3"
		^" € a1 = d1 € a2 = d2 € a3 = d3"];

in

store_mt_results_show mt_run[
("4_440", ft, t4_440, a4_440),
("4_450", ft, t4_450, a4_450),
("4_460", ft, t4_460, a4_460),
("4_470", ft, t4_470, a4_470),
("4_480", ft, t4_480, a4_480),
("4_490", ft, t4_490, a4_490),
("4_500", ft, t4_500, a4_500),
("4_510", ft, t4_510, a4_510),
("4_520", ft, t4_520, a4_520)
];

store_mt_results_show mt_run[
("4_440f", uft, t4_440, t4_440),
("4_450f", uft, t4_450, t4_450),
("4_460f", uft, t4_460, t4_460),
("4_470f", uft, t4_470, t4_470),
("4_480f", uft, t4_480, t4_480),
("4_490f", uft, t4_490, t4_490),
("4_500f", uft, t4_500, t4_500),
("4_510f", uft, t4_510, t4_510),
("4_520f", uft, t4_520, t4_520)
];

set_flag("pp_types_on_binders", true);

store_mt_results_show mt_run[
("4_440b", ft, t4_440, l4_440),
("4_450b", ft, t4_450, l4_450),
("4_460b", ft, t4_460, l4_460),
("4_470b", ft, t4_470, l4_470),
("4_480b", ft, t4_480, l4_480),
("4_490b", ft, t4_490, l4_490),
("4_500b", ft, t4_500, l4_500),
("4_510b", ft, t4_510, l4_510),
("4_520b", ft, t4_520, l4_520)
];

store_mt_results_show mt_run[
("4_440fb", uft, t4_440, t4_440),
("4_450fb", uft, t4_450, t4_450),
("4_460fb", uft, t4_460, t4_460),
("4_470fb", uft, t4_470, t4_470),
("4_480fb", uft, t4_480, t4_480),
("4_490fb", uft, t4_490, t4_490),
("4_500fb", uft, t4_500, t4_500),
("4_510fb", uft, t4_510, t4_510),
("4_520fb", uft, t4_520, t4_520)
];

set_flag("pp_types_on_binders", false)

end;
=TEX

\subsection{Local Definitions}

There are two forms of output for local definitions, so all of the
tests here occur twice.  Tests with suffix `$l$' denote the showing of
let definitions in their lambda form, without the suffix  denotes the
(default) functional form.  Most of the tests of let terms do not have
any local definitions so the results are the same.

=SML
let
val t5_010 =	»let a = 1 in a = 2¼;
val a5_010 =	["let a = 1 in a = 2"];
val t5_020 =	»let a = 1 and b = 2 in a = b¼;
val a5_020 =	["let a = 1 and b = 2 in a = b"];
val t5_030 =	»let a = 1 and b = 2 and c = 3 and d = 4 in a = b € c = d¼;
val a5_030 =	["let a = 1 and b = 2 and c = 3 and d = 4 in a = b € c = d"];

in

store_mt_results_show mt_run[
("5_010", ft, t5_010, a5_010),
("5_020", ft, t5_020, a5_020),
("5_030", ft, t5_030, a5_030)
];

store_mt_results_show mt_run[
("5_010f", uft, t5_010, t5_010),
("5_020f", uft, t5_020, t5_020),
("5_030f", uft, t5_030, t5_030)
];

set_flag("pp_let_as_lambda", true);

store_mt_results_show mt_run[
("5_010l", ft, t5_010, a5_010),
("5_020l", ft, t5_020, a5_020),
("5_030l", ft, t5_030, a5_030)
];

store_mt_results_show mt_run[
("5_010fl", uft, t5_010, t5_010),
("5_020fl", uft, t5_020, t5_020),
("5_030fl", uft, t5_030, t5_030)
];

set_flag("pp_let_as_lambda", false)

end;
=TEX

=SML
let
val t5_040 =	»c = let a = 1 in let b = 2 in a = b¼;
val a5_040 =	["c ‚ (let a = 1 in let b = 2 in a = b)"];
val t5_050 =	»let a = 1 in let b = 2 in a = b ‚ c¼;
val a5_050 =	["let a = 1 in let b = 2 in a = b ‚ c"];
val t5_060 =	»(let a = 1 in let b = 2 in a = b) = c¼;
val a5_060 =	["(let a = 1 in let b = 2 in a = b) ‚ c"];
val t5_070 =	»(let a = 1 in let b =  x Ž x in a = b d) = c¼;
val a5_070 =	["(let a = 1 in let b x = x in a = b d) ‚ c"];
val l5_070 =	["(let a = 1 in let b = ( xŽ x) in a = b d) ‚ c"];
val t5_080 =	»(let a = 1 in let b = 2 in a = b) ‚ if x then p else q¼;
val a5_080 =	["(let a = 1 in let b = 2 in a = b) ‚ (if x then p else q)"];
val t5_090 =	»(let a = if x then 1 else 2 in let b = 2 in a = b) = c¼;
val a5_090 =	["(let a = (if x then 1 else 2) in let b = 2 in a = b) ‚ c"];

in

store_mt_results_show mt_run[
("5_040", ft, t5_040, a5_040),
("5_050", ft, t5_050, a5_050),
("5_060", ft, t5_060, a5_060),
("5_070", ft, t5_070, a5_070),
("5_080", ft, t5_080, a5_080),
("5_090", ft, t5_090, a5_090)
];

store_mt_results_show mt_run[
("5_040f", uft, t5_040, t5_040),
("5_050f", uft, t5_050, t5_050),
("5_060f", uft, t5_060, t5_060),
("5_070f", uft, t5_070, t5_070),
("5_080f", uft, t5_080, t5_080),
("5_090f", uft, t5_090, t5_090)
];

set_flag("pp_let_as_lambda", true);

store_mt_results_show mt_run[
("5_040l", ft, t5_040, a5_040),
("5_050l", ft, t5_050, a5_050),
("5_060l", ft, t5_060, a5_060),
("5_070l", ft, t5_070, l5_070),
("5_080l", ft, t5_080, a5_080),
("5_090l", ft, t5_090, a5_090)
];

store_mt_results_show mt_run[
("5_040fl", uft, t5_040, t5_040),
("5_050fl", uft, t5_050, t5_050),
("5_060fl", uft, t5_060, t5_060),
("5_070fl", uft, t5_070, t5_070),
("5_080fl", uft, t5_080, t5_080),
("5_090fl", uft, t5_090, t5_090)
];

set_flag("pp_let_as_lambda", false)

end;
=TEX

Let with pairs.

=SML
let
val t5_100 =	»let (a,b) = x in a = b¼;
val a5_100 =	["let (a, b) = x in a = b"];
val t5_110 =	»let (a,b,c,d,e) = x in a = b¼;
val a5_110 =	["let (a, b, c, d, e) = x in a = b"];
val t5_120 =	»let ((a,((b,c),d)),e) = x in a = b¼;
val a5_120 =	["let ((a, (b, c), d), e) = x in a = b"];

in

store_mt_results_show mt_run[
("5_100", ft, t5_100, a5_100),
("5_110", ft, t5_110, a5_110),
("5_120", ft, t5_120, a5_120)
];

store_mt_results_show mt_run[
("5_100f", uft, t5_100, t5_100),
("5_110f", uft, t5_110, t5_110),
("5_120f", uft, t5_120, t5_120)
];

set_flag("pp_let_as_lambda", true);

store_mt_results_show mt_run[
("5_100l", ft, t5_100, a5_100),
("5_110l", ft, t5_110, a5_110),
("5_120l", ft, t5_120, a5_120)
];

store_mt_results_show mt_run[
("5_100fl", uft, t5_100, t5_100),
("5_110fl", uft, t5_110, t5_110),
("5_120fl", uft, t5_120, t5_120)
];

set_flag("pp_let_as_lambda", false)

end;
=TEX

Local functions.

=SML
let
val t5_130 =	»let f a = x in y¼;
val a5_130 =	["let f a = x in y"];
val l5_130 =	["let f = ( aŽ x) in y"];

val t5_140 =	»let f (a,b) = x in y¼;
val a5_140 =	["let f (a, b) = x in y"];
val l5_140 =	["let f = ( (a, b)Ž x) in y"];

val t5_150 =	»let f (a,b,c,d,e) = x in y¼;
val a5_150 =	["let f (a, b, c, d, e) = x in y"];
val l5_150 =	["let f = ( (a, b, c, d, e)Ž x) in y"];

val t5_160 =	»let f ((a,((b,c),d)),e) = x in y¼;
val a5_160 =	["let f ((a, (b, c), d), e) = x in y"];
val l5_160 =	["let f = ( ((a, (b, c), d), e)Ž x) in y"];

in

store_mt_results_show mt_run[
("5_130", ft, t5_130, a5_130),
("5_140", ft, t5_140, a5_140),
("5_150", ft, t5_150, a5_150),
("5_160", ft, t5_160, a5_160)
];

store_mt_results_show mt_run[
("5_130f", uft, t5_130, t5_130),
("5_140f", uft, t5_140, t5_140),
("5_150f", uft, t5_150, t5_150),
("5_160f", uft, t5_160, t5_160)
];

set_flag("pp_let_as_lambda", true);

store_mt_results_show mt_run[
("5_130l", ft, t5_130, l5_130),
("5_140l", ft, t5_140, l5_140),
("5_150l", ft, t5_150, l5_150),
("5_160l", ft, t5_160, l5_160)
];

store_mt_results_show mt_run[
("5_130fl", uft, t5_130, t5_130),
("5_140fl", uft, t5_140, t5_140),
("5_150fl", uft, t5_150, t5_150),
("5_160fl", uft, t5_160, t5_160)
];

set_flag("pp_let_as_lambda", false)

end;
=TEX

=SML
let
val t5_170 =	»let f a b c d e = x in y¼;
val a5_170 =	["let f a b c d e = x in y"];
val l5_170 =	["let f = ( a b c d eŽ x) in y"];

val t5_180 =	»let f (a1, a2) (b1, b2) (c1, c2) (d1, d2) (e1, e2) = x in y¼;
val a5_180 =	["let f (a1, a2) (b1, b2) (c1, c2) (d1, d2) (e1, e2) = x in y"];
val l5_180 =	["let f = ( (a1, a2) (b1, b2) (c1, c2) (d1, d2) (e1, e2)Ž x) in y"];

in
store_mt_results_show mt_run[
("5_170", ft, t5_170, a5_170),
("5_180", ft, t5_180, a5_180)
];

store_mt_results_show mt_run[
("5_170f", uft, t5_170, t5_170),
("5_180f", uft, t5_180, t5_180)
];

set_flag("pp_let_as_lambda", true);

store_mt_results_show mt_run[
("5_170l", ft, t5_170, l5_170),
("5_180l", ft, t5_180, l5_180)
];

store_mt_results_show mt_run[
("5_170fl", uft, t5_170, t5_170),
("5_180fl", uft, t5_180, t5_180)
];

set_flag("pp_let_as_lambda", false)

end;
=TEX

Local operators and binders.

=SML
let
val t5_190 =	»let f_pre a = b in f_pre e¼;
val a5_190 =	["let f_pre a = b in f_pre e"];
val t5_200 =	»let f_post a = b in f_post e¼;
val a5_200 =	["let a f_post = b in e f_post"];
val t5_210 =	»let f_inf a b = c in f_inf d e¼;
val a5_210 =	["let a f_inf b = c in d f_inf e"];

in

declare_prefix(300, "f_pre");
declare_postfix(300, "f_post");
declare_infix(300, "f_inf");

store_mt_results_show mt_run[
("5_190", ft, t5_190, a5_190),
("5_200", ft, t5_200, a5_200),
("5_210", ft, t5_210, a5_210)
];

store_mt_results_show mt_run[
("5_190f", uft, t5_190, t5_190),
("5_200f", uft, t5_200, t5_200),
("5_210f", uft, t5_210, t5_210)
];

declare_nonfix "f_pre";
declare_nonfix "f_post";
declare_nonfix "f_inf"

end;
=TEX

The local binder cannot be fully tested until the parser
accepts aliases for equality in the definitional part of
a let term. 

=SML
let
val t5_220 =	»let (f_bind:('a ‹ 'b) ‹ BOOL) a = b in f_bind ( c Ž d)¼;
val a5_220 =	["let $f_bind a ‚ b in f_bind cŽ d"];

in

declare_binder "f_bind";

store_mt_results_show mt_run[
("5_220", ft, t5_220, a5_220)
];

(*
store_mt_results_show mt_run[
("5_220f", uft, t5_220, t5_220)
];
*)

declare_nonfix "f_bind"

end;
=TEX

\subsection{More `if' `let' and binder terms}

These cases gave problems at one stage in the development.

=SML
let
val t6_010 =	»a€(ƒbŽb)€c¼;
val a6_010 =	["a € (ƒ bŽ b) € c"];
val t6_020 =	»(a€(ƒbŽb))€c¼;
val a6_020 =	["(a € (ƒ bŽ b)) € c"];
val t6_030 =	»a€((ƒbŽb)€c)¼;
val a6_030 =	["a € (ƒ bŽ b) € c"];
val t6_040 =	»a€b€c€d€e€f€g€h€i¼;
val a6_040 =	["a € b € c € d € e € f € g € h € i"];
val t6_050 =	»(((((((a€b)€c)€d)€e)€f)€g)€h)€i¼;
val a6_050 =	["(((((((a € b) € c) € d) € e) € f) € g) € h) € i"];
val t6_060 =	»a€(b€(c€(d€(e€(f€(g€(h€i)))))))¼;
val a6_060 =	["a € b € c € d € e € f € g € h € i"];
val t6_070 =	»(((((((a€b)€c)€(ƒ x Ž x))€e)€f)€g)€h)€i¼;
val a6_070 =	["(((((((a € b) € c) € (ƒ xŽ x)) € e) € f) € g) € h) € i"];
val t6_080 =	»a€(b€(c€((ƒ x Ž x)€(e€(f€(g€(h€i)))))))¼;
val a6_080 =	["a € b € c € (ƒ xŽ x) € e € f € g € h € i"];
val t6_090 =	»((((((((ƒaŽa)€(ƒbŽb))€(ƒcŽc))€(ƒdŽd))€(ƒeŽe))
			€(ƒfŽf))€(ƒgŽg))€(ƒhŽh))€(ƒiŽi)¼;
val a6_090 =	["((((((((ƒ aŽ a) € (ƒ bŽ b)) € (ƒ cŽ c)) € (ƒ dŽ d)) €"
		^ " (ƒ eŽ e)) € (ƒ fŽ f)) € (ƒ gŽ g)) € (ƒ hŽ h)) € (ƒ iŽ i)"];
val t6_100 =	»(ƒaŽa)€((ƒbŽb)€((ƒcŽc)€((ƒdŽd)€((ƒeŽe)€
		((ƒfŽf)€((ƒgŽg)€((ƒhŽh)€(ƒiŽi))))))))¼;
val a6_100 =	["(ƒ aŽ a) € (ƒ bŽ b) € (ƒ cŽ c) € (ƒ dŽ d) € (ƒ eŽ e) €"
		^ " (ƒ fŽ f) € (ƒ gŽ g) € (ƒ hŽ h) € (ƒ iŽ i)"];

in

store_mt_results_show mt_run[
("6_010", ft, t6_010, a6_010),
("6_020", ft, t6_020, a6_020),
("6_030", ft, t6_030, a6_030),
("6_040", ft, t6_040, a6_040),
("6_050", ft, t6_050, a6_050),
("6_060", ft, t6_060, a6_060),
("6_070", ft, t6_070, a6_070),
("6_080", ft, t6_080, a6_080),
("6_090", ft, t6_090, a6_090),
("6_100", ft, t6_100, a6_100)
];

store_mt_results_show mt_run[
("6_010f", uft, t6_010, t6_010),
("6_020f", uft, t6_020, t6_020),
("6_030f", uft, t6_030, t6_030),
("6_040f", uft, t6_040, t6_040),
("6_050f", uft, t6_050, t6_050),
("6_060f", uft, t6_060, t6_060),
("6_070f", uft, t6_070, t6_070),
("6_080f", uft, t6_080, t6_080),
("6_090f", uft, t6_090, t6_090),
("6_100f", uft, t6_100, t6_100)
]
end;
=TEX

=SML
let
val t6_110 =	»ff (if a then b else c)¼;
val a6_110 =	["ff (if a then b else c)"];
val t6_120 =	»ff (if a then b else c) (if d then e else f) (if g then h else i)¼;
val a6_120 =	["ff (if a then b else c) (if d then e else f) (if g then h else i)"];
val t6_130 =	»((ff (if a then b else c)) (if d then e else f)) (if g then h else i)¼;
val a6_130 =	["ff (if a then b else c) (if d then e else f) (if g then h else i)"];
val t6_140 =	»ff ((if a then b else c) ((if d then e else f) (if g then h else i)))¼;
val a6_140 =	["ff ((if a then b else c) ((if d then e else f) (if g then h else i)))"];

in

store_mt_results_show mt_run[
("6_110", ft, t6_110, a6_110),
("6_120", ft, t6_120, a6_120),
("6_130", ft, t6_130, a6_130),
("6_140", ft, t6_140, a6_140)
];

store_mt_results_show mt_run[
("6_110f", uft, t6_110, t6_110),
("6_120f", uft, t6_120, t6_120),
("6_130f", uft, t6_130, t6_130),
("6_140f", uft, t6_140, t6_140)
]
end;
=TEX

=SML
let
val t6_150 =	»ff ( a Ž b)¼;
val a6_150 =	["ff ( aŽ b)"];
val t6_160 =	»ff ( a Ž b) ( c Ž d) ( e Ž f)¼;
val a6_160 =	["ff ( aŽ b) ( cŽ d) ( eŽ f)"];
val t6_170 =	»((ff ( a Ž b)) ( c Ž d)) ( e Ž f)¼;
val a6_170 =	["ff ( aŽ b) ( cŽ d) ( eŽ f)"];
val t6_180 =	»ff (( a Ž b) (( c Ž d) ( e Ž f)))¼;
val a6_180 =	["ff (( aŽ b) (( cŽ d) ( eŽ f)))"];

in

store_mt_results_show mt_run[
("6_150", ft, t6_150, a6_150),
("6_160", ft, t6_160, a6_160),
("6_170", ft, t6_170, a6_170),
("6_180", ft, t6_180, a6_180)
];

store_mt_results_show mt_run[
("6_150f", uft, t6_150, t6_150),
("6_160f", uft, t6_160, t6_160),
("6_170f", uft, t6_170, t6_170),
("6_180f", uft, t6_180, t6_180)
]
end;
=TEX

=SML
let
val t6_190 =	»ff (let a = b in c)¼;
val a6_190 =	["ff (let a = b in c)"];
val t6_200 =	»ff (let a = b in c) (let d = e in f) (let g = h in i)¼;
val a6_200 =	["ff (let a = b in c) (let d = e in f) (let g = h in i)"];
val t6_210 =	»((ff (let a = b in c)) (let d = e in f)) (let g = h in i)¼;
val a6_210 =	["ff (let a = b in c) (let d = e in f) (let g = h in i)"];
val t6_220 =	»ff ((let a = b in c) ((let d = e in f) (let g = h in i)))¼;
val a6_220 =	["ff ((let a = b in c) ((let d = e in f) (let g = h in i)))"];

in

store_mt_results_show mt_run[
("6_190", ft, t6_190, a6_190),
("6_200", ft, t6_200, a6_200),
("6_210", ft, t6_210, a6_210),
("6_220", ft, t6_220, a6_220)
];

store_mt_results_show mt_run[
("6_190f", uft, t6_190, t6_190),
("6_200f", uft, t6_200, t6_200),
("6_210f", uft, t6_210, t6_210),
("6_220f", uft, t6_220, t6_220)
]
end;
=TEX

\subsection{Lists and Sets}

Set Comprehension.

=SML
let
val t7_010 =	»{a|b}¼;
val a7_010 =	["{a|b}"];
val t7_020 =	»{(a,b,c)|a€(ƒbŽb)€c}¼;
val a7_020 =	["{(a, b, c)|a € (ƒ bŽ b) € c}"];

in

store_mt_results_show mt_run[
("7_010", ft, t7_010, a7_010),
("7_020", ft, t7_020, a7_020)
];

store_mt_results_show mt_run[
("7_010f", uft, t7_010, t7_010),
("7_020f", uft, t7_020, t7_020)
]
end;
=TEX

=SML
let
val t7_030 =	»{}¼;
val a7_030 =	["{}"];
val t7_040 =	»{a; b; c; d; e}¼;
val a7_040 =	["{a; b; c; d; e}"];
val t7_041 =	»{a b}¼;
val a7_041 =	["{a b}"];

in

store_mt_results_show mt_run[
("7_030", ft, t7_030, a7_030),
("7_040", ft, t7_040, a7_040),
("7_041", ft, t7_041, a7_041)
];

store_mt_results_show mt_run[
("7_030f", uft, t7_030, t7_030),
("7_040f", uft, t7_040, t7_040),
("7_041f", uft, t7_041, t7_041)
]
end;
=TEX

=SML
let
val t7_050 =	»[]¼;
val a7_050 =	["[]"];
val t7_060 =	»[a; b; c; d; e]¼;
val a7_060 =	["[a; b; c; d; e]"];

in

store_mt_results_show mt_run[
("7_050", ft, t7_050, a7_050),
("7_060", ft, t7_060, a7_060)
];

store_mt_results_show mt_run[
("7_050f", uft, t7_050, t7_050),
("7_060f", uft, t7_060, t7_060)
]
end;
=TEX

\subsection{Strings and Characters}

We cannot fully test strings with the standard pattern of tests used in
this document.  In particular, newline characters cannot tested via
$uft$ because the text that is generated holds a string containing a
newline, this is then passed to $usestring$ which passes it on to the
compiler.  Thus the compiler reads a string containing a newline
character which is not valid Standard~ML.  Test $8_010$ gives a good
test of various strings, test $8_030$ tests the handling of
back-slashes in strings, including newlines.  Test $8_030$ cannot use
function $uft$.

=SML
let
val t8_010 =	»f "" T "a" T "a b c d e f g h i j k l m n o p q r s t u v w x y z" T¼;
val a8_010 =	["f \"\" T \"a\" T \"a b c d e f g h i j k l m n o p q r s t u v w x y z\" T"];
val t8_020 =	»`a`¼;
val a8_020 =	["`a`"];
val t8_030 =	»f "\t\n\234" a¼;
val a8_030 =	["f \"\t\n\234\" a"];

in

store_mt_results_show mt_run[
("8_010", ft, t8_010, a8_010),
("8_020", ft, t8_020, a8_020),
("8_030", ft, t8_030, a8_030)
];

store_mt_results_show mt_run[
("8_010f", uft, t8_010, t8_010),
("8_020f", uft, t8_020, t8_020)
(* No test of 8_030 with $uft$ *)
]
end;
=TEX

\subsection{INCOMPLETE USES OF HOL CONSTANTS}

Examples of HOL constants used for concrete syntax items but which are
insufficiently parameterised and so must be printed in their function
application form.

=SML
let
val t9_010 =	»Uncurry f¼;
val a9_010 =	["Uncurry f"];
val t9_020 =	»Uncurry f a¼;
val a9_020 =	["Uncurry f a"];
val t9_030 =	»Uncurry f a b¼;
val a9_030 =	["Uncurry f a b"];
val t9_040 =	»Uncurry f a b c¼;
val a9_040 =	["Uncurry f a b c"];
in
store_mt_results_show mt_run[
("9_010", ft, t9_010, a9_010),
("9_020", ft, t9_020, a9_020),
("9_030", ft, t9_030, a9_030),
("9_040", ft, t9_040, a9_040)
];

store_mt_results_show mt_run[
("9_010f", uft, t9_010, t9_010),
("9_020f", uft, t9_020, t9_020),
("9_030f", uft, t9_030, t9_030),
("9_040f", uft, t9_040, t9_040)
]
end;
=TEX

=SML
let
val App(t9_050, _) = dest_simple_term »if a then b else c¼;
val a9_050 =	["Cond a b"];
val App(t9_060, _) = dest_simple_term t9_050;
val a9_060 =	["Cond a"];
val App(t9_070, _) = dest_simple_term t9_060;
val a9_070 =	["Cond"];
in
store_mt_results_show mt_run[
("9_050", ft, t9_050, a9_050),
("9_060", ft, t9_060, a9_060),
("9_070", ft, t9_070, a9_070)
];

store_mt_results_show mt_run[
("9_050f", uft, t9_050, t9_050),
("9_060f", uft, t9_060, t9_060),
("9_070f", uft, t9_070, t9_070)
]
end;
=TEX

=SML
let
val App(t9_080, _) =	dest_simple_term »let a (b, c) = d in e¼;
val a9_080 =	["Let ( aŽ e)"];
val App(t9_090, _) =	dest_simple_term »let a (b, c) = d and (e, f) = g in h¼;
val a9_090 =	["Let (let a (b, c) = d in  (e, f)Ž h)"];
in
store_mt_results_show mt_run[
("9_080", ft, t9_080, a9_080),
("9_090", ft, t9_090, a9_090)
];

set_flag("pp_show_HOL_types", true);

store_mt_results_show mt_run[
("9_080f", uft, t9_080, t9_080),
("9_090f", uft, t9_090, t9_090)
];

set_flag("pp_show_HOL_types", false)

end;
=TEX

Set comprehensions.
In the short term expect test $9_100f$ to fail, this is because
in $t9_100$ we use $mk_const$ but at the call of $uft$ the name
$SetComp$ is not declared and so is set up as a variable.

=SML
let
val tv1 = mk_vartype "'tv1";
val tv2 = mk_vartype "'tv2";
val v1 = mk_var("v1", tv1);
val v2 = mk_var("v2", tv2);
val t9_100 = mk_app(mk_const("SetComp",mk_‹_type(mk_‹_type(
			mk_‰_type(tv1,tv2),BOOL),
			mk_ctype("SET",[mk_‰_type(tv1,tv2)]))),
		mk_var("v",mk_‹_type(mk_‰_type(tv1,tv2),BOOL)));
val a9_100 = ["SetComp v"];
in
store_mt_results_show mt_run[
("9_100", ft, t9_100, a9_100)
];

set_flag("pp_show_HOL_types", true);

store_mt_results_show mt_run[
("9_100f", uft, t9_100, t9_100)
];

set_flag("pp_show_HOL_types", false)

end;
=TEX

val
(PrettyPrinter.format_term(mk_app(p,q))) handle E => ["Exception", PolyML.makestring E];


=IGN
\subsection{Oddments}

An attempt to get all of the productions in the grammar
of~\cite{DS/FMU/IED/DEF001} into one HOL term.

=IGN
Value	(new_type("TRIPLE", 3))				handle Fail _ => Nil;
	declare_postfix (100, "+++")			handle Fail _ => ();
=TEX

=IGN
val tt = 
»
„ ka : ( '8 ‹ '9 ‹ '10 ) Ž kb
let ha = ( hb : '4 ) in hc
ƒ (ga, gb) (gc, gd, ge) ; gf gg : '2 ‹ '3 Ž gh
let ia ((ib, ic), (id, ie)) = ig : ('5, '6, '7) TRIPLE
	and ja jb jc jd = [fa = fb; Œ fc ; fd +++ ]
in { (la, lb) | lc (la []) lb if ma then {} else ( { mb ; mc ; md } : '1 SET ) }
¼;
=TEX

\section{SUMMARY OF RESULTS}

=SML
diag_string(summarize_mt_results());
=TEX

\end{document}
