% mdt025.doc   %Z% $Date$ $Revision$ $RCSfile$

=TEX
% mdt025.doc   %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol,11pt,TQ]{article}

\TPPtitle{Module Tests for Pretty Printer}
\TPPref{DS/FMU/IED/MDT025}
\def\SCCSissue{$Revision$%
}
\TPPissue{\SCCSissue}
\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{FST PROJECT}

=IGN

Commands to process this document in various ways.

doc4errors mdt025
usefile "mdt025.sml";

make -f rel001.mkf mdt025.dvi
doc4tex mdt025
tex4dvi mdt025
bibtex mdt025
doc4tex mdt025 ; tex4dvi mdt025
doc4tex mdt025 ; tex4dvi mdt025 ; bibtex mdt025
dvipage mdt025 &

doc4errors mdt025
usefile "mdt025.sml";

=TEX
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the module tests for the ICL~HOL
	Pretty Printer.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

%********************************************************************

\subsection{Contents List}
\tableofcontents
% \listoftables

%********************************************************************

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

%********************************************************************

\subsection{Changes History}

\begin{description}

\item[\FormatDate{91/07/10}, issue 1.1~] First issue.

\item[\FormatDate{91/07/16}, issue 1.2~]
	Extra test cases.

\item[\FormatDate{91/08/08}, issue 1.4~]
	Changed names of syntax functions.
	Function $format_term$ no longer includes the term brackets.
	All tests work with version~1.27 of ICL~HOL.

\item[\FormatDate{91/08/15}, issue 1.5~]
	Renamings of functions containing the name atom $simple$, and renaming of $aconv$.

\item[\FormatDate{91/08/20}, issue 1.6~]
	More test cases.

\item[\FormatDate{91/09/11}, issue 1.7~] Changes for ID0055, which
	includes the ``{\tt cdg}'' tests.  Add tests ``{\tt 7_080}''
	and ``{\tt 7_090}'' relating to a fault in the pretty printer.

%\item[\FormatDate{$Date$%
%}, issue \SCCSissue~]

\end{description}

%********************************************************************

%\subsection{Changes Forecast} \label{ChangesForecast}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the module tests for the pretty printing
routines for Release~1 of the ICL HOL system which are discussed
in~\cite{DS/FMU/IED/IMP025}.  The tests use the module testing system
of~\cite{DS/FMU/IED/DTD013} and~\cite{DS/FMU/IED/IMP013}.

%********************************************************************

\subsection{Introduction}

Each test, or part of a test, is identified by a string of the form
``$\cal N_M$'' or ``$\cal N_MA$'' where: ``$\cal N$'' indicates the
area of the test; ``$\cal M$'' is the test number; and, ``$\cal A$'' is
ancillary labelling for the test.

The first major group of tests are concerned with getting the correct
layout of the brackets and components of the terms, most of these
tests use a very wide line length to ensure that all the output is
on a single line.

Most of the tests are run twice.  Firstly to see if the expected output
is produced.  Secondly (using function $uft$) to ensure that the text
that is produced can be parsed back in as the same term.

\subsection{Deficiencies}

Function $pp_init$ is not directly tested by this file.  The function
is called in the implementation document~\cite{DS/FMU/IED/IMP025} when
it installs the printing functions.  The success of this function can
only be determined by the integration tests where if terms, types and
theorems are not printed as top level values then the printing
functions have not been installed.

The theorem printing functions are not tested because there are no
readily available values of suitable type and creating such values with
a non-empty set of assumptions is difficult.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TEST HARNESS INITIALISATION}

=IGN
Get the test harness files
sccs -d ~ied get dtd013.doc imp013.doc
doc4errors dtd013
doc4errors imp013

doc4errors mdt025
usefile "mdt025.sml";

=TEX

Load and initialise the module test system.

=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results ();
=TEX

Use very long lines for the first tests.

=SML
set_line_length 500;
=TEX

Functions $ft$ and $uft$ are used to invoke the tests.  The first just
formats the term into a single string, the second formats the term into
a single string, parses it back as a term and formats the result of
that.

=SML
fun ft (x:TERM) : string list = PrettyPrinter.format_term false x;

val uft_aux : TERM ref = ref ª1º;

fun uft (x:TERM) : TERM =
let
	val t1 = implode(ft x);
	val side_effect = usestring("(uft_aux := ª" ^ t1 ^ "º; !uft_aux)");
in
	!uft_aux
end;
=TEX

%********************************************************************

\subsection{HOL Operators, Types and Constants}

Some initialisations required in the absence of the proper
declarations for the operators, types and constants about:
	pairing
and
	sets.

=SML
(	declare_infix (100, "â")		handle Fail _ => (),	"infix â");
(Value	(new_type("â", 2))			handle Fail _ => Nil,	"new_type â");
(	declare_infix (100, ",")			handle Fail _ => (),	"infix ,");
(Value	(new_const(",", type_ofªx:'aã'bã('aâ'b)º))
						handle Fail _ => Nil,	"new_const ,");

(Value	(new_type("SET", 1))			handle Fail _ => Nil,	"new_type SET");
(Value	(new_const("Empty", ª:'1 SETº))	handle Fail _ => Nil,	"new_const Empty");
(Value	(new_const("Insert", ª:'1 ã '1 SET ã '1 SETº))
						handle Fail _ => Nil,	"new_const Insert");

(Value	(new_const("Uncurry", ª:('a ã 'b ã 'c) ã ('a â 'b) ã 'cº))
						handle Fail _ => Nil,	"new_const Uncurry");
(Value	(new_const("SetComp", ª:(('a â 'b) ã BOOL) ã ('a â 'b) SETº))
						handle Fail _ => Nil,	"new_const SetComp");
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{THE TESTS}

\subsection{Simple constants and function applications}

=SML
let
val t1_010 =	ª1º;
val a1_010 =	["1"];
val t1_020 =	ªx 1º;
val a1_020 =	["x 1"];
val t1_030 =	ªx y 1º;
val a1_030 =	["x y 1"];
val t1_040 =	ªx y z 1º;
val a1_040 =	["x y z 1"];
val t1_050 =	ªax bx cx dx ex fx gx hx ix jx kx lx mx nx ox px qx rx sx tx ux vx wx xx yx zxº;
val a1_050 =	["ax bx cx dx ex fx gx hx ix jx kx lx mx nx ox px qx rx sx tx ux vx wx xx yx zx"];
val t1_060 =	ªxÄyº;
val a1_060 =	["x Ä y"];

in

store_mt_results_show mt_run[
("1_010", ft, t1_010, a1_010),
("1_020", ft, t1_020, a1_020),
("1_030", ft, t1_030, a1_030),
("1_040", ft, t1_040, a1_040),
("1_050", ft, t1_050, a1_050),
("1_060", ft, t1_060, a1_060)
];

store_mt_results_show mt_run[
("1_010f", uft, t1_010, t1_010),
("1_020f", uft, t1_020, t1_020),
("1_030f", uft, t1_030, t1_030),
("1_040f", uft, t1_040, t1_040),
("1_050f", uft, t1_050, t1_050),
("1_060f", uft, t1_060, t1_060)
]

end;
=TEX

\subsection{Infix Operators}

=SML
let
val t2_010 =	ªxÄyÄzº;
val a2_010 =	["x Ä y Ä z"];
val t2_020 =	ª(xÄy)Äzº;
val a2_020 =	["(x Ä y) Ä z"];
val t2_030 =	ªxÄ(yÄz)º;
val a2_030 =	["x Ä y Ä z"];
val t2_040 =	ªwÄxÄyÄzº;
val a2_040 =	["w Ä x Ä y Ä z"];

in

store_mt_results_show mt_run[
("2_010", ft, t2_010, a2_010),
("2_020", ft, t2_020, a2_020),
("2_030", ft, t2_030, a2_030),
("2_040", ft, t2_040, a2_040)
];

store_mt_results_show mt_run[
("2_010f", uft, t2_010, t2_010),
("2_020f", uft, t2_020, t2_020),
("2_030f", uft, t2_030, t2_030),
("2_040f", uft, t2_040, t2_040)
]
end;
=TEX

=SML
let
val t2_050 =	ª(wÄx)ÄyÄzº;
val a2_050 =	["(w Ä x) Ä y Ä z"];
val t2_060 =	ªwÄxÄ(yÄz)º;
val a2_060 =	["w Ä x Ä y Ä z"];
val t2_070 =	ª(wÄx)Ä(yÄz)º;
val a2_070 =	["(w Ä x) Ä y Ä z"];
val t2_080 =	ªwÄ(xÄy)Äzº;
val a2_080 =	["w Ä (x Ä y) Ä z"];

in

store_mt_results_show mt_run[
("2_050", ft, t2_050, a2_050),
("2_060", ft, t2_060, a2_060),
("2_070", ft, t2_070, a2_070),
("2_080", ft, t2_080, a2_080)
];

store_mt_results_show mt_run[
("2_050f", uft, t2_050, t2_050),
("2_060f", uft, t2_060, t2_060),
("2_070f", uft, t2_070, t2_070),
("2_080f", uft, t2_080, t2_080)
]
end;
=TEX

=SML
let
val t2_090 =	ªwÅxÄyÅzº;
val a2_090 =	["w Å x Ä y Å z"];
val t2_100 =	ª(wÅx)ÄyÅzº;
val a2_100 =	["(w Å x) Ä y Å z"];
val t2_110 =	ªwÅ(xÄy)Åzº;
val a2_110 =	["w Å x Ä y Å z"];
val t2_120 =	ªwÄ(xÅy)Äzº;
val a2_120 =	["w Ä (x Å y) Ä z"];
val t2_130 =	ªwÅxÄ(yÅz)º;
val a2_130 =	["w Å x Ä (y Å z)"];
val t2_140 =	ª(wÅx)Ä(yÅz)º;
val a2_140 =	["(w Å x) Ä (y Å z)"];

in

store_mt_results_show mt_run[
("2_090", ft, t2_090, a2_090),
("2_100", ft, t2_100, a2_100),
("2_110", ft, t2_110, a2_110),
("2_120", ft, t2_120, a2_120),
("2_130", ft, t2_130, a2_130),
("2_140", ft, t2_140, a2_140)
];

store_mt_results_show mt_run[
("2_090f", uft, t2_090, t2_090),
("2_100f", uft, t2_100, t2_100),
("2_110f", uft, t2_110, t2_110),
("2_120f", uft, t2_120, t2_120),
("2_130f", uft, t2_130, t2_130),
("2_140f", uft, t2_140, t2_140)
]
end;
=TEX

=SML
let
val t2_150 =	ªf wÅg xÄh yÅj zº;
val a2_150 =	["f w Å g x Ä h y Å j z"];
val t2_160 =	ª(f wÅg x)Äh yÅj zº;
val a2_160 =	["(f w Å g x) Ä h y Å j z"];
val t2_170 =	ªf wÅ(g xÄh y)Åj zº;
val a2_170 =	["f w Å g x Ä h y Å j z"];
val t2_180 =	ªf wÅg xÄ(h yÅj z)º;
val a2_180 =	["f w Å g x Ä (h y Å j z)"];
val t2_190 =	ª(f wÅg x)Ä(h yÅj z)º;
val a2_190 =	["(f w Å g x) Ä (h y Å j z)"];

=IGN
val t2_150 =	ªf wÅg xÄh yÅj zº;
val a2_150 =	["(f w) Å (g x) Ä (h y) Å (j z)"];
val t2_160 =	ª(f wÅg x)Äh yÅj zº;
val a2_160 =	["((f w) Å (g x)) Ä (h y) Å (j z)"];
val t2_170 =	ªf wÅ(g xÄh y)Åj zº;
val a2_170 =	["(f w) Å (g x) Ä (h y) Å (j z)"];
val t2_180 =	ªf wÅg xÄ(h yÅj z)º;
val a2_180 =	["(f w) Å (g x) Ä ((h y) Å (j z))"];
val t2_190 =	ª(f wÅg x)Ä(h yÅj z)º;
val a2_190 =	["((f w) Å (g x)) Ä ((h y) Å (j z))"];
=SML

in

store_mt_results_show mt_run[
("2_150", ft, t2_150, a2_150),
("2_160", ft, t2_160, a2_160),
("2_170", ft, t2_170, a2_170),
("2_180", ft, t2_180, a2_180),
("2_190", ft, t2_190, a2_190)
];

store_mt_results_show mt_run[
("2_150f", uft, t2_150, t2_150),
("2_160f", uft, t2_160, t2_160),
("2_170f", uft, t2_170, t2_170),
("2_180f", uft, t2_180, t2_180),
("2_190f", uft, t2_190, t2_190)
]
end;
=TEX

=SML
let
val t2_200 =	ªf (wÅg) (xÄh) (yÅj) zº;
val a2_200 =	["f (w Å g) (x Ä h) (y Å j) z"];
val t2_210 =	ª(f (wÅg) x)Äh (yÅj) zº;
val a2_210 =	["f (w Å g) x Ä h (y Å j) z"];

in

store_mt_results_show mt_run[
("2_200", ft, t2_200, a2_200),
("2_210", ft, t2_210, a2_210)
];

store_mt_results_show mt_run[
("2_200f", uft, t2_200, t2_200),
("2_210f", uft, t2_210, t2_210)
]
end;
=TEX

\subsection{Conditionals}

=SML
let
val t3_010 =	ªif x = y then 1 else zº;
val a3_010 =	["if x = y then 1 else z"];
val t3_020 =	ªif x = y then if x = yy then 2 else 3 else zº;
val a3_020 =	["if x = y then if x = yy then 2 else 3 else z"];
val t3_030 =	ªif x = y then 1 else if x = yy then 2 else 3º;
val a3_030 =	["if x = y then 1 else if x = yy then 2 else 3"];

in

store_mt_results_show mt_run[
("3_010", ft, t3_010, a3_010),
("3_020", ft, t3_020, a3_020),
("3_030", ft, t3_030, a3_030)
];

store_mt_results_show mt_run[
("3_010f", uft, t3_010, t3_010),
("3_020f", uft, t3_020, t3_020),
("3_030f", uft, t3_030, t3_030)
]
end;
=TEX

=SML
let
val t3_040 =	ªif x = y then z else w Ä zº;
val a3_040 =	["if x = y then z else w Ä z"];
val t3_050 =	ªif x = y then if x = yy then w Ä z1 else w Ä z2 else w Ä z3º;
val a3_050 =	["if x = y then if x = yy then w Ä z1 else w Ä z2 else w Ä z3"];
val t3_060 =	ª(if x = y then w Ä z1 else if x = yy then w Ä z2 else w) Ä z3º;
val a3_060 =	["(if x = y then w Ä z1 else if x = yy then w Ä z2 else w) Ä z3"];
val t3_070 =	ª(a Ä if x = y then w Ä z1 else if x = yy then w Ä z2 else w) Ä z3º;
val a3_070 =	["(a Ä (if x = y then w Ä z1 else if x = yy then w Ä z2 else w)) Ä z3"];
val t3_080 =	ªa Ä (if x = y then w Ä z1 else if x = yy then w Ä z2 else w) Ä z3º;
val a3_080 =	["a Ä (if x = y then w Ä z1 else if x = yy then w Ä z2 else w) Ä z3"];
val t3_090 =	ª(a Ä (if x = y then w Ä z1 else if x = yy then w Ä z2 else w)) Ä z3º;
val a3_090 =	["(a Ä (if x = y then w Ä z1 else if x = yy then w Ä z2 else w)) Ä z3"];
val t3_100 =	ªa Ä ((if x = y then w Ä z1 else if x = yy then w Ä z2 else w) Ä z3)º;
val a3_100 =	["a Ä (if x = y then w Ä z1 else if x = yy then w Ä z2 else w) Ä z3"];

in

store_mt_results_show mt_run[
("3_040", ft, t3_040, a3_040),
("3_050", ft, t3_050, a3_050),
("3_060", ft, t3_060, a3_060),
("3_070", ft, t3_070, a3_070),
("3_080", ft, t3_080, a3_080),
("3_090", ft, t3_090, a3_090),
("3_100", ft, t3_100, a3_100)
];

store_mt_results_show mt_run[
("3_040f", uft, t3_040, t3_040),
("3_050f", uft, t3_050, t3_050),
("3_060f", uft, t3_060, t3_060),
("3_070f", uft, t3_070, t3_070),
("3_080f", uft, t3_080, t3_080),
("3_090f", uft, t3_090, t3_090),
("3_100f", uft, t3_100, t3_100)
]
end;
=TEX

=SML
let
val t3_110 =	ª(if a then b else c d e f)º;
val a3_110 =	["if a then b else c d e f"];
val t3_120 =	ª(if a then b else c) d e fº;
val a3_120 =	["(if a then b else c) d e f"];
val t3_130 =	ªp q r (if a then b else c d e f)º;
val a3_130 =	["p q r (if a then b else c d e f)"];
val t3_140 =	ªp q r (if a then b else c) d e fº;
val a3_140 =	["p q r (if a then b else c) d e f"];
val t3_150 =	ªp q r (if a then b else c) d e fº;
val a3_150 =	["p q r (if a then b else c) d e f"];
val t3_160 =	ªp q r ((if a then b else c) d e f)º;
val a3_160 =	["p q r ((if a then b else c) d e f)"];

in

store_mt_results_show mt_run[
("3_110", ft, t3_110, a3_110),
("3_120", ft, t3_120, a3_120),
("3_130", ft, t3_130, a3_130),
("3_140", ft, t3_140, a3_140),
("3_150", ft, t3_150, a3_150),
("3_160", ft, t3_160, a3_160)
];

store_mt_results_show mt_run[
("3_110f", uft, t3_110, t3_110),
("3_120f", uft, t3_120, t3_120),
("3_130f", uft, t3_130, t3_130),
("3_140f", uft, t3_140, t3_140),
("3_150f", uft, t3_150, t3_150),
("3_160f", uft, t3_160, t3_160)
]
end;
=TEX

\subsection{Binder Terms}

=SML
let
val t4_010 =	ªç x é xº;
val a4_010 =	["ç xé x"];
val t4_020 =	ªç x é yº;
val a4_020 =	["ç xé y"];
val t4_030 =	ªç x é x yº;
val a4_030 =	["ç xé x y"];
val t4_040 =	ª(ç x é x) yº;
val a4_040 =	["(ç xé x) y"];
val t4_050 =	ªç x é (x y)º;
val a4_050 =	["ç xé x y"];
val t4_060 =	ªw ç x é x yº;
val a4_060 =	["w (ç xé x y)"];
val t4_070 =	ªw (ç x é x) yº;
val a4_070 =	["w (ç xé x) y"];
val t4_080 =	ªw (ç x é (x y))º;
val a4_080 =	["w (ç xé x y)"];
val t4_090 =	ª(w (ç x é x)) yº;
val a4_090 =	["w (ç xé x) y"];

in

store_mt_results_show mt_run[
("4_010", ft, t4_010, a4_010),
("4_020", ft, t4_020, a4_020),
("4_030", ft, t4_030, a4_030),
("4_040", ft, t4_040, a4_040),
("4_050", ft, t4_050, a4_050),
("4_060", ft, t4_060, a4_060),
("4_070", ft, t4_070, a4_070),
("4_080", ft, t4_080, a4_080),
("4_090", ft, t4_090, a4_090)
];

store_mt_results_show mt_run[
("4_010f", uft, t4_010, t4_010),
("4_020f", uft, t4_020, t4_020),
("4_030f", uft, t4_030, t4_030),
("4_040f", uft, t4_040, t4_040),
("4_050f", uft, t4_050, t4_050),
("4_060f", uft, t4_060, t4_060),
("4_070f", uft, t4_070, t4_070),
("4_080f", uft, t4_080, t4_080),
("4_090f", uft, t4_090, t4_090)
]
end;
=TEX

=SML
let
val t4_100 =	ªÉ x é xº;
val a4_100 =	["É xé x"];
val t4_110 =	ªÉ x é (x y)º;
val a4_110 =	["É xé x y"];
val t4_120 =	ªw É x é xº;
val a4_120 =	["w (É xé x)"];
val t4_130 =	ªw (É x é x)º;
val a4_130 =	["w (É xé x)"];

in

store_mt_results_show mt_run[
("4_100f", uft, t4_100, t4_100),
("4_110f", uft, t4_110, t4_110),
("4_120f", uft, t4_120, t4_120),
("4_130f", uft, t4_130, t4_130)
];

store_mt_results_show mt_run[
("4_100", ft, t4_100, a4_100),
("4_110", ft, t4_110, a4_110),
("4_120", ft, t4_120, a4_120),
("4_130", ft, t4_130, a4_130)
]
end;
=TEX

=SML
let
val t4_140 =	ª(É w é w)Ä(É x é x)Ä(É y é y)Ä(É z é z)º;
val a4_140 =	["(É wé w) Ä (É xé x) Ä (É yé y) Ä (É zé z)"];
val t4_150 =	ª((É w é w)Ä(É x é x))Ä(É y é y)Ä(É z é z)º;
val a4_150 =	["((É wé w) Ä (É xé x)) Ä (É yé y) Ä (É zé z)"];
val t4_160 =	ª(É w é w)Ä(É x é x)Ä((É y é y)Ä(É z é z))º;
val a4_160 =	["(É wé w) Ä (É xé x) Ä (É yé y) Ä (É zé z)"];
val t4_170 =	ª((É w é w)Ä(É x é x))Ä((É y é y)Ä(É z é z))º;
val a4_170 =	["((É wé w) Ä (É xé x)) Ä (É yé y) Ä (É zé z)"];
val t4_180 =	ª(É w é w)Ä((É x é x)Ä(É y é y))Ä(É z é z)º;
val a4_180 =	["(É wé w) Ä ((É xé x) Ä (É yé y)) Ä (É zé z)"];

in

store_mt_results_show mt_run[
("4_140", ft, t4_140, a4_140),
("4_150", ft, t4_150, a4_150),
("4_160", ft, t4_160, a4_160),
("4_170", ft, t4_170, a4_170),
("4_180", ft, t4_180, a4_180)
];

store_mt_results_show mt_run[
("4_140f", uft, t4_140, t4_140),
("4_150f", uft, t4_150, t4_150),
("4_160f", uft, t4_160, t4_160),
("4_170f", uft, t4_170, t4_170),
("4_180f", uft, t4_180, t4_180)
]
end;
=TEX

=SML
let
val t4_190 =	ªç x é xÄyº;
val a4_190 =	["ç xé x Ä y"];
val t4_200 =	ªç x é if x then y else zº;
val a4_200 =	["ç xé if x then y else z"];

in

store_mt_results_show mt_run[
("4_190", ft, t4_190, a4_190),
("4_200", ft, t4_200, a4_200)
];

store_mt_results_show mt_run[
("4_190f", uft, t4_190, t4_190),
("4_200f", uft, t4_200, t4_200)
]
end;
=TEX

=SML
let
val t4_210 =	ªÉ x é y = if x then 1 else 2º;
val a4_210 =	["É xé y = (if x then 1 else 2)"];
val t4_220 =	ª(É x é y) = (if x then p else q)º;
val a4_220 =	["(É xé y) Ç (if x then p else q)"];

in

store_mt_results_show mt_run[
("4_210", ft, t4_210, a4_210),
("4_220", ft, t4_220, a4_220)
];

store_mt_results_show mt_run[
("4_210f", uft, t4_210, t4_210),
("4_220f", uft, t4_220, t4_220)
]
end;
=TEX

=SML
let
val t4_230 =	ªÉxéÉyéÉzéxÄyÄzº;
val a4_230 =	["É x y zé x Ä y Ä z"];
val t4_240 =	ªÑxéÉyéÑzéxÄyÄzº;
val a4_240 =	["Ñ xé É yé Ñ zé x Ä y Ä z"];

in

store_mt_results_show mt_run[
("4_230", ft, t4_230, a4_230),
("4_240", ft, t4_240, a4_240)
];

store_mt_results_show mt_run[
("4_230f", uft, t4_230, t4_230),
("4_240f", uft, t4_240, t4_240)
]
end;
=TEX

=SML
let
val t4_250 =	ªf = ç x é ç y é xÄyº;
val a4_250 =	["f = (ç x yé x Ä y)"];
val t4_260 =	ªf = ç (x,y) é xÄyº;
val a4_260 =	["f = (ç (x, y)é x Ä y)"];


in

store_mt_results_show mt_run[
("4_250", ft, t4_250, a4_250),
("4_260", ft, t4_260, a4_260)
];

store_mt_results_show mt_run[
("4_250f", uft, t4_250, t4_250),
("4_260f", uft, t4_260, t4_260)
]
end;
=TEX

Binders with varstructs.

=SML
let
val t4_265 =	ªÉ a é xº;
val a4_265 =	["É aé x"];
val t4_270 =	ªç a é xº;
val a4_270 =	["ç aé x"];

in

store_mt_results_show mt_run[
("4_265", ft, t4_265, a4_265),
("4_270", ft, t4_270, a4_270)
];

store_mt_results_show mt_run[
("4_265f", uft, t4_265, t4_265),
("4_270f", uft, t4_270, t4_270)
]
end;
=TEX

=SML
let

val t4_280 =	ªÉ (a,b) é xº;
val a4_280 =	["É (a, b)é x"];
val t4_290 =	ªÉ (a,b,c) é xº;
val a4_290 =	["É (a, b, c)é x"];
val t4_300 =	ªÉ (a,b,c,d) é xº;
val a4_300 =	["É (a, b, c, d)é x"];
val t4_310 =	ªç (a,b) é xº;
val a4_310 =	["ç (a, b)é x"];
val t4_320 =	ªç (a,b,c) é xº;
val a4_320 =	["ç (a, b, c)é x"];
val t4_330 =	ªç (a,b,c,d) é xº;
val a4_330 =	["ç (a, b, c, d)é x"];

in

store_mt_results_show mt_run[
("4_280", ft, t4_280, a4_280),
("4_290", ft, t4_290, a4_290),
("4_300", ft, t4_300, a4_300),
("4_310", ft, t4_310, a4_310),
("4_320", ft, t4_320, a4_320),
("4_330", ft, t4_330, a4_330)
];

store_mt_results_show mt_run[
("4_280f", uft, t4_280, t4_280),
("4_290f", uft, t4_290, t4_290),
("4_300f", uft, t4_300, t4_300),
("4_310f", uft, t4_310, t4_310),
("4_320f", uft, t4_320, t4_320),
("4_330f", uft, t4_330, t4_330)
]
end;
=TEX

=SML
let

val t4_340 =	ªÉ a b c é dº;
val a4_340 =	["É a b cé d"];
val t4_350 =	ªÉ a é É b é É c é dº;
val a4_350 =	["É a b cé d"];
val t4_360 =	ªç a b c é dº;
val a4_360 =	["ç a b cé d"];
val t4_370 =	ªç a é ç b é ç c é dº;
val a4_370 =	["ç a b cé d"];

in

store_mt_results_show mt_run[
("4_340", ft, t4_340, a4_340),
("4_350", ft, t4_350, a4_350),
("4_360", ft, t4_360, a4_360),
("4_370", ft, t4_370, a4_370)
];

store_mt_results_show mt_run[
("4_340f", uft, t4_340, t4_340),
("4_350f", uft, t4_350, t4_350),
("4_360f", uft, t4_360, t4_360),
("4_370f", uft, t4_370, t4_370)
]
end;
=TEX

=SML
let

val t4_380 =	ªÉ (((a,b),c),d) é xº;
val a4_380 =	["É (((a, b), c), d)é x"];
val t4_390 =	ªÉ ((a,b),(c,d)) é xº;
val a4_390 =	["É ((a, b), c, d)é x"];
val t4_400 =	ªç (((a,b),c),d) é xº;
val a4_400 =	["ç (((a, b), c), d)é x"];
val t4_410 =	ªç ((a,b),(c,d)) é xº;
val a4_410 =	["ç ((a, b), c, d)é x"];

in

store_mt_results_show mt_run[
("4_380", ft, t4_380, a4_380),
("4_390", ft, t4_390, a4_390),
("4_400", ft, t4_400, a4_400),
("4_410", ft, t4_410, a4_410)
];

store_mt_results_show mt_run[
("4_380f", uft, t4_380, t4_380),
("4_390f", uft, t4_390, t4_390),
("4_400f", uft, t4_400, t4_400),
("4_410f", uft, t4_410, t4_410)
]
end;
=TEX

=SML
let

val t4_420 =	ªÉ ((a,((b,(c,(d,((e,f),(g,h)),i,(j,k,l),m),n)),o)),p) é xº;
val a4_420 =	["É ((a, (b, c, (d, ((e, f), g, h), i, (j, k, l), m), n), o), p)é x"];
val t4_430 =	ªç (a,b,(c,(d,e,f),g),((h,i),j),(k,(l,(m,n))),o,p) é xº;
val a4_430 =	["ç (a, b, (c, (d, e, f), g), ((h, i), j), (k, l, m, n), o, p)é x"];

in

store_mt_results_show mt_run[
("4_420", ft, t4_420, a4_420),
("4_430", ft, t4_430, a4_430)
];

store_mt_results_show mt_run[
("4_420f", uft, t4_420, t4_420),
("4_430f", uft, t4_430, t4_430)
]
end;
=TEX

Some binders where types are to be shown.

=SML
let

val t4_440 =	ªÉ a b c d é a = b Ä a = c Ä a = dº;
val a4_440 =	["É a b c dé a = b Ä a = c Ä a = d"];
val l4_440 =	["É a b c d: 'aé a = b Ä a = c Ä a = d"];

val t4_450 =	ªÉ a b c d é a = b Ä c = dº;
val a4_450 =	["É a b c dé a = b Ä c = d"];
val l4_450 =	["É a b: 'a; c d: 'bé a = b Ä c = d"];

val t4_460 =	ªç a b c d é a = b Ä a = c Ä a = dº;
val a4_460 =	["ç a b c dé a = b Ä a = c Ä a = d"];
val l4_460 =	["ç a b c d: 'aé a = b Ä a = c Ä a = d"];

val t4_470 =	ªç a b c d é a = b Ä c = dº;
val a4_470 =	["ç a b c dé a = b Ä c = d"];
val l4_470 =	["ç a b: 'a; c d: 'bé a = b Ä c = d"];

val t4_480 =	ªÉ (a1, a2) (b1, b2) ((c1, c2), c3) ((d1, d2), d3)
		é (a1, a2) = (b1, b2)
		Ä ((c1, c2), c3) = ((d1, d2), d3)º;
val a4_480 =	["É (a1, a2) (b1, b2) ((c1, c2), c3) ((d1, d2), d3)"
		^"é (a1, a2) = (b1, b2)"
		^" Ä ((c1, c2), c3) = ((d1, d2), d3)"];
val l4_480 =	["É (a1, a2) (b1, b2): 'a â 'b;"
		^" ((c1, c2), c3) ((d1, d2), d3): ('c â 'd) â 'e"
		^"é (a1, a2) = (b1, b2)"
		^" Ä ((c1, c2), c3) = ((d1, d2), d3)"];

val t4_490 =	ªÉ (a1, (a2, a3)) (b1, (b2, b3)) ((c1, c2), c3) ((d1, d2), d3) é xº;
val a4_490 =	["É (a1, a2, a3) (b1, b2, b3) ((c1, c2), c3) ((d1, d2), d3)é x"];
val l4_490 =	["É (a1, a2, a3): 'a â 'b â 'c;"
		^" (b1, b2, b3): 'd â 'e â 'f;"
		^" ((c1, c2), c3):"
		^" ('g â 'h) â 'i;"
		^" ((d1, d2), d3): ('j â 'k) â 'lé x"];

val t4_500 =	ªÉ (a1, (a2, a3)) (b1, (b2, b3)) ((c1, c2), c3) ((d1, d2), d3)
		é (a1, (a2, a3)) = (b1, (b2, b3))
		Ä ((c1, c2), c3) = ((d1, d2), d3)º;
val a4_500 =	["É (a1, a2, a3) (b1, b2, b3) ((c1, c2), c3) ((d1, d2), d3)"
		^"é (a1, a2, a3) = (b1, b2, b3)"
		^" Ä ((c1, c2), c3) = ((d1, d2), d3)"];
val l4_500 =	["É (a1, a2, a3) (b1, b2, b3): 'a â 'b â 'c;"
		^" ((c1, c2), c3) ((d1, d2), d3):"
		^" ('d â 'e) â 'f"
		^"é (a1, a2, a3) = (b1, b2, b3)"
		^" Ä ((c1, c2), c3) = ((d1, d2), d3)"];

val t4_510 =	ªÉ (a1, (a2, a3)) (b1, (b2, b3)) ((c1, c2), c3) ((d1, d2), d3)
		é a1 = b1 Ä a2 = b2 Ä a3 = b3
		Ä a1 = c1 Ä a2 = c2 Ä a3 = c3
		Ä a1 = d1 Ä a2 = d2 Ä a3 = d3º;
val a4_510 =	["É (a1, a2, a3) (b1, b2, b3) ((c1, c2), c3) ((d1, d2), d3)"
		^"é a1 = b1 Ä a2 = b2 Ä a3 = b3"
		^" Ä a1 = c1 Ä a2 = c2 Ä a3 = c3"
		^" Ä a1 = d1 Ä a2 = d2 Ä a3 = d3"];
val l4_510 =	["É (a1, a2, a3) (b1, b2, b3): 'a â 'b â 'c;"
		^" ((c1, c2), c3) ((d1, d2), d3): ('a â 'b) â 'c"
		^"é a1 = b1 Ä a2 = b2 Ä a3 = b3"
		^" Ä a1 = c1 Ä a2 = c2 Ä a3 = c3"
		^" Ä a1 = d1 Ä a2 = d2 Ä a3 = d3"];

val t4_520 =	ªÉ (a1, (a2, a3)) (b1, (b2, b3)) (c1, (c2, c3)) (d1, (d2, d3))
		é a1 = b1 Ä a2 = b2 Ä a3 = b3
		Ä a1 = c1 Ä a2 = c2 Ä a3 = c3
		Ä a1 = d1 Ä a2 = d2 Ä a3 = d3º;
val a4_520 =	["É (a1, a2, a3) (b1, b2, b3) (c1, c2, c3) (d1, d2, d3)"
		^"é a1 = b1 Ä a2 = b2 Ä a3 = b3"
		^" Ä a1 = c1 Ä a2 = c2 Ä a3 = c3"
		^" Ä a1 = d1 Ä a2 = d2 Ä a3 = d3"];
val l4_520 =	["É (a1, a2, a3) (b1, b2, b3)"
		^" (c1, c2, c3) (d1, d2, d3): 'a â 'b â 'c"
		^"é a1 = b1 Ä a2 = b2 Ä a3 = b3"
		^" Ä a1 = c1 Ä a2 = c2 Ä a3 = c3"
		^" Ä a1 = d1 Ä a2 = d2 Ä a3 = d3"];

in

store_mt_results_show mt_run[
("4_440", ft, t4_440, a4_440),
("4_450", ft, t4_450, a4_450),
("4_460", ft, t4_460, a4_460),
("4_470", ft, t4_470, a4_470),
("4_480", ft, t4_480, a4_480),
("4_490", ft, t4_490, a4_490),
("4_500", ft, t4_500, a4_500),
("4_510", ft, t4_510, a4_510),
("4_520", ft, t4_520, a4_520)
];

store_mt_results_show mt_run[
("4_440f", uft, t4_440, t4_440),
("4_450f", uft, t4_450, t4_450),
("4_460f", uft, t4_460, t4_460),
("4_470f", uft, t4_470, t4_470),
("4_480f", uft, t4_480, t4_480),
("4_490f", uft, t4_490, t4_490),
("4_500f", uft, t4_500, t4_500),
("4_510f", uft, t4_510, t4_510),
("4_520f", uft, t4_520, t4_520)
];

set_flag("pp_types_on_binders", true);

store_mt_results_show mt_run[
("4_440b", ft, t4_440, l4_440),
("4_450b", ft, t4_450, l4_450),
("4_460b", ft, t4_460, l4_460),
("4_470b", ft, t4_470, l4_470),
("4_480b", ft, t4_480, l4_480),
("4_490b", ft, t4_490, l4_490),
("4_500b", ft, t4_500, l4_500),
("4_510b", ft, t4_510, l4_510),
("4_520b", ft, t4_520, l4_520)
];

store_mt_results_show mt_run[
("4_440fb", uft, t4_440, t4_440),
("4_450fb", uft, t4_450, t4_450),
("4_460fb", uft, t4_460, t4_460),
("4_470fb", uft, t4_470, t4_470),
("4_480fb", uft, t4_480, t4_480),
("4_490fb", uft, t4_490, t4_490),
("4_500fb", uft, t4_500, t4_500),
("4_510fb", uft, t4_510, t4_510),
("4_520fb", uft, t4_520, t4_520)
];

set_flag("pp_types_on_binders", false)

end;
=TEX

\subsection{Local Definitions}

There are two forms of output for local definitions, so all of the
tests here occur twice.  Tests with suffix `$l$' denote the showing of
let definitions in their lambda form, without the suffix  denotes the
(default) functional form.  Most of the tests of let terms do not have
any local definitions so the results are the same.

=SML
let
val t5_010 =	ªlet a = 1 in a = 2º;
val a5_010 =	["let a = 1 in a = 2"];
val t5_020 =	ªlet a = 1 and b = 2 in a = bº;
val a5_020 =	["let a = 1 and b = 2 in a = b"];
val t5_030 =	ªlet a = 1 and b = 2 and c = 3 and d = 4 in a = b Ä c = dº;
val a5_030 =	["let a = 1 and b = 2 and c = 3 and d = 4 in a = b Ä c = d"];

in

store_mt_results_show mt_run[
("5_010", ft, t5_010, a5_010),
("5_020", ft, t5_020, a5_020),
("5_030", ft, t5_030, a5_030)
];

store_mt_results_show mt_run[
("5_010f", uft, t5_010, t5_010),
("5_020f", uft, t5_020, t5_020),
("5_030f", uft, t5_030, t5_030)
];

set_flag("pp_let_as_lambda", true);

store_mt_results_show mt_run[
("5_010l", ft, t5_010, a5_010),
("5_020l", ft, t5_020, a5_020),
("5_030l", ft, t5_030, a5_030)
];

store_mt_results_show mt_run[
("5_010fl", uft, t5_010, t5_010),
("5_020fl", uft, t5_020, t5_020),
("5_030fl", uft, t5_030, t5_030)
];

set_flag("pp_let_as_lambda", false)

end;
=TEX

=SML
let
val t5_040 =	ªc = let a = 1 in let b = 2 in a = bº;
val a5_040 =	["c Ç (let a = 1 in let b = 2 in a = b)"];
val t5_050 =	ªlet a = 1 in let b = 2 in a = b Ç cº;
val a5_050 =	["let a = 1 in let b = 2 in a = b Ç c"];
val t5_060 =	ª(let a = 1 in let b = 2 in a = b) = cº;
val a5_060 =	["(let a = 1 in let b = 2 in a = b) Ç c"];
val t5_070 =	ª(let a = 1 in let b = ç x é x in a = b d) = cº;
val a5_070 =	["(let a = 1 in let b x = x in a = b d) Ç c"];
val l5_070 =	["(let a = 1 in let b = (ç xé x) in a = b d) Ç c"];
val t5_080 =	ª(let a = 1 in let b = 2 in a = b) Ç if x then p else qº;
val a5_080 =	["(let a = 1 in let b = 2 in a = b) Ç (if x then p else q)"];
val t5_090 =	ª(let a = if x then 1 else 2 in let b = 2 in a = b) = cº;
val a5_090 =	["(let a = (if x then 1 else 2) in let b = 2 in a = b) Ç c"];

in

store_mt_results_show mt_run[
("5_040", ft, t5_040, a5_040),
("5_050", ft, t5_050, a5_050),
("5_060", ft, t5_060, a5_060),
("5_070", ft, t5_070, a5_070),
("5_080", ft, t5_080, a5_080),
("5_090", ft, t5_090, a5_090)
];

store_mt_results_show mt_run[
("5_040f", uft, t5_040, t5_040),
("5_050f", uft, t5_050, t5_050),
("5_060f", uft, t5_060, t5_060),
("5_070f", uft, t5_070, t5_070),
("5_080f", uft, t5_080, t5_080),
("5_090f", uft, t5_090, t5_090)
];

set_flag("pp_let_as_lambda", true);

store_mt_results_show mt_run[
("5_040l", ft, t5_040, a5_040),
("5_050l", ft, t5_050, a5_050),
("5_060l", ft, t5_060, a5_060),
("5_070l", ft, t5_070, l5_070),
("5_080l", ft, t5_080, a5_080),
("5_090l", ft, t5_090, a5_090)
];

store_mt_results_show mt_run[
("5_040fl", uft, t5_040, t5_040),
("5_050fl", uft, t5_050, t5_050),
("5_060fl", uft, t5_060, t5_060),
("5_070fl", uft, t5_070, t5_070),
("5_080fl", uft, t5_080, t5_080),
("5_090fl", uft, t5_090, t5_090)
];

set_flag("pp_let_as_lambda", false)

end;
=TEX

Let with pairs.

=SML
let
val t5_100 =	ªlet (a,b) = x in a = bº;
val a5_100 =	["let (a, b) = x in a = b"];
val t5_110 =	ªlet (a,b,c,d,e) = x in a = bº;
val a5_110 =	["let (a, b, c, d, e) = x in a = b"];
val t5_120 =	ªlet ((a,((b,c),d)),e) = x in a = bº;
val a5_120 =	["let ((a, (b, c), d), e) = x in a = b"];

in

store_mt_results_show mt_run[
("5_100", ft, t5_100, a5_100),
("5_110", ft, t5_110, a5_110),
("5_120", ft, t5_120, a5_120)
];

store_mt_results_show mt_run[
("5_100f", uft, t5_100, t5_100),
("5_110f", uft, t5_110, t5_110),
("5_120f", uft, t5_120, t5_120)
];

set_flag("pp_let_as_lambda", true);

store_mt_results_show mt_run[
("5_100l", ft, t5_100, a5_100),
("5_110l", ft, t5_110, a5_110),
("5_120l", ft, t5_120, a5_120)
];

store_mt_results_show mt_run[
("5_100fl", uft, t5_100, t5_100),
("5_110fl", uft, t5_110, t5_110),
("5_120fl", uft, t5_120, t5_120)
];

set_flag("pp_let_as_lambda", false)

end;
=TEX

Local functions.

=SML
let
val t5_130 =	ªlet f a = x in yº;
val a5_130 =	["let f a = x in y"];
val l5_130 =	["let f = (ç aé x) in y"];

val t5_140 =	ªlet f (a,b) = x in yº;
val a5_140 =	["let f (a, b) = x in y"];
val l5_140 =	["let f = (ç (a, b)é x) in y"];

val t5_150 =	ªlet f (a,b,c,d,e) = x in yº;
val a5_150 =	["let f (a, b, c, d, e) = x in y"];
val l5_150 =	["let f = (ç (a, b, c, d, e)é x) in y"];

val t5_160 =	ªlet f ((a,((b,c),d)),e) = x in yº;
val a5_160 =	["let f ((a, (b, c), d), e) = x in y"];
val l5_160 =	["let f = (ç ((a, (b, c), d), e)é x) in y"];

in

store_mt_results_show mt_run[
("5_130", ft, t5_130, a5_130),
("5_140", ft, t5_140, a5_140),
("5_150", ft, t5_150, a5_150),
("5_160", ft, t5_160, a5_160)
];

store_mt_results_show mt_run[
("5_130f", uft, t5_130, t5_130),
("5_140f", uft, t5_140, t5_140),
("5_150f", uft, t5_150, t5_150),
("5_160f", uft, t5_160, t5_160)
];

set_flag("pp_let_as_lambda", true);

store_mt_results_show mt_run[
("5_130l", ft, t5_130, l5_130),
("5_140l", ft, t5_140, l5_140),
("5_150l", ft, t5_150, l5_150),
("5_160l", ft, t5_160, l5_160)
];

store_mt_results_show mt_run[
("5_130fl", uft, t5_130, t5_130),
("5_140fl", uft, t5_140, t5_140),
("5_150fl", uft, t5_150, t5_150),
("5_160fl", uft, t5_160, t5_160)
];

set_flag("pp_let_as_lambda", false)

end;
=TEX

=SML
let
val t5_170 =	ªlet f a b c d e = x in yº;
val a5_170 =	["let f a b c d e = x in y"];
val l5_170 =	["let f = (ç a b c d eé x) in y"];

val t5_180 =	ªlet f (a1, a2) (b1, b2) (c1, c2) (d1, d2) (e1, e2) = x in yº;
val a5_180 =	["let f (a1, a2) (b1, b2) (c1, c2) (d1, d2) (e1, e2) = x in y"];
val l5_180 =	["let f = (ç (a1, a2) (b1, b2) (c1, c2) (d1, d2) (e1, e2)é x) in y"];

in
store_mt_results_show mt_run[
("5_170", ft, t5_170, a5_170),
("5_180", ft, t5_180, a5_180)
];

store_mt_results_show mt_run[
("5_170f", uft, t5_170, t5_170),
("5_180f", uft, t5_180, t5_180)
];

set_flag("pp_let_as_lambda", true);

store_mt_results_show mt_run[
("5_170l", ft, t5_170, l5_170),
("5_180l", ft, t5_180, l5_180)
];

store_mt_results_show mt_run[
("5_170fl", uft, t5_170, t5_170),
("5_180fl", uft, t5_180, t5_180)
];

set_flag("pp_let_as_lambda", false)

end;
=TEX

Local operators and binders.
Tests 5_190--5_210 are of well formed uses.
Tests 5_230--5_250 have extra arguments and need brackets.
Tests 5_260--5_290 have insufficient arguments and need dollar signs.

=SML
let
val t5_190 =	ªlet f_pre a = b in f_pre eº;
val a5_190 =	["let f_pre a = b in f_pre e"];
val t5_200 =	ªlet f_post a = b in f_post eº;
val a5_200 =	["let a f_post = b in e f_post"];
val t5_210 =	ªlet f_inf a b = c in f_inf d eº;
val a5_210 =	["let a f_inf b = c in d f_inf e"];

val t5_230 =	ªlet f_pre a c = b in f_pre e fº;
val a5_230 =	["let (f_pre a) c = b in (f_pre e) f"];
val t5_240 =	ªlet f_post a c = b in f_post f eº;
val a5_240 =	["let (a f_post) c = b in (f f_post) e"];
val t5_250 =	ªlet f_inf a b d = c in f_inf d e gº;
val a5_250 =	["let (a f_inf b) d = c in (d f_inf e) g"];

val t5_260 =	ªlet f_pre = b in f_pre eº;
val a5_260 =	["let $f_pre = b in f_pre e"];
val t5_270 =	ªlet f_post = b in f_post eº;
val a5_270 =	["let $f_post = b in e f_post"];
val t5_280 =	ªlet f_inf a = c in f_inf d eº;
val a5_280 =	["let $f_inf a = c in d f_inf e"];
val t5_290 =	ªlet f_inf = c in f_inf d eº;
val a5_290 =	["let $f_inf = c in d f_inf e"];

in

declare_prefix(300, "f_pre");
declare_postfix(300, "f_post");
declare_infix(300, "f_inf");

store_mt_results_show mt_run[
("5_190", ft, t5_190, a5_190),
("5_200", ft, t5_200, a5_200),
("5_210", ft, t5_210, a5_210),
("5_230", ft, t5_230, a5_230),
("5_240", ft, t5_240, a5_240),
("5_250", ft, t5_250, a5_250),
("5_260", ft, t5_260, a5_260),
("5_270", ft, t5_270, a5_270),
("5_280", ft, t5_280, a5_280),
("5_290", ft, t5_290, a5_290)
];

store_mt_results_show mt_run[
("5_190f", uft, t5_190, t5_190),
("5_200f", uft, t5_200, t5_200),
("5_210f", uft, t5_210, t5_210),
("5_230f", uft, t5_230, t5_230),
("5_240f", uft, t5_240, t5_240),
("5_250f", uft, t5_250, t5_250),
("5_260f", uft, t5_260, t5_260),
("5_270f", uft, t5_270, t5_270),
("5_280f", uft, t5_280, t5_280),
("5_290f", uft, t5_290, t5_290)
];

declare_nonfix "f_pre";
declare_nonfix "f_post";
declare_nonfix "f_inf"

end;
=TEX

The local binder cannot be fully tested until the parser
accepts aliases for equality in the definitional part of
a let term. 

=SML
let
val t5_220 =	ªlet (f_bind:('a ã 'b) ã BOOL) a = b in f_bind (ç c é d)º;
val a5_220 =	["let $f_bind a Ç b in f_bind cé d"];

in

declare_binder "f_bind";

store_mt_results_show mt_run[
("5_220", ft, t5_220, a5_220)
];

(*
store_mt_results_show mt_run[
("5_220f", uft, t5_220, t5_220)
];
*)

declare_nonfix "f_bind"

end;
=TEX

\subsection{More `if' `let' and binder terms}

These cases gave problems at one stage in the development.

=SML
let
val t6_010 =	ªaÄ(Ébéb)Äcº;
val a6_010 =	["a Ä (É bé b) Ä c"];
val t6_020 =	ª(aÄ(Ébéb))Äcº;
val a6_020 =	["(a Ä (É bé b)) Ä c"];
val t6_030 =	ªaÄ((Ébéb)Äc)º;
val a6_030 =	["a Ä (É bé b) Ä c"];
val t6_040 =	ªaÄbÄcÄdÄeÄfÄgÄhÄiº;
val a6_040 =	["a Ä b Ä c Ä d Ä e Ä f Ä g Ä h Ä i"];
val t6_050 =	ª(((((((aÄb)Äc)Äd)Äe)Äf)Äg)Äh)Äiº;
val a6_050 =	["(((((((a Ä b) Ä c) Ä d) Ä e) Ä f) Ä g) Ä h) Ä i"];
val t6_060 =	ªaÄ(bÄ(cÄ(dÄ(eÄ(fÄ(gÄ(hÄi)))))))º;
val a6_060 =	["a Ä b Ä c Ä d Ä e Ä f Ä g Ä h Ä i"];
val t6_070 =	ª(((((((aÄb)Äc)Ä(É x é x))Äe)Äf)Äg)Äh)Äiº;
val a6_070 =	["(((((((a Ä b) Ä c) Ä (É xé x)) Ä e) Ä f) Ä g) Ä h) Ä i"];
val t6_080 =	ªaÄ(bÄ(cÄ((É x é x)Ä(eÄ(fÄ(gÄ(hÄi)))))))º;
val a6_080 =	["a Ä b Ä c Ä (É xé x) Ä e Ä f Ä g Ä h Ä i"];
val t6_090 =	ª((((((((Éaéa)Ä(Ébéb))Ä(Écéc))Ä(Édéd))Ä(Éeée))
			Ä(Éféf))Ä(Égég))Ä(Éhéh))Ä(Éiéi)º;
val a6_090 =	["((((((((É aé a) Ä (É bé b)) Ä (É cé c)) Ä (É dé d)) Ä"
		^ " (É eé e)) Ä (É fé f)) Ä (É gé g)) Ä (É hé h)) Ä (É ié i)"];
val t6_100 =	ª(Éaéa)Ä((Ébéb)Ä((Écéc)Ä((Édéd)Ä((Éeée)Ä
		((Éféf)Ä((Égég)Ä((Éhéh)Ä(Éiéi))))))))º;
val a6_100 =	["(É aé a) Ä (É bé b) Ä (É cé c) Ä (É dé d) Ä (É eé e) Ä"
		^ " (É fé f) Ä (É gé g) Ä (É hé h) Ä (É ié i)"];

in

store_mt_results_show mt_run[
("6_010", ft, t6_010, a6_010),
("6_020", ft, t6_020, a6_020),
("6_030", ft, t6_030, a6_030),
("6_040", ft, t6_040, a6_040),
("6_050", ft, t6_050, a6_050),
("6_060", ft, t6_060, a6_060),
("6_070", ft, t6_070, a6_070),
("6_080", ft, t6_080, a6_080),
("6_090", ft, t6_090, a6_090),
("6_100", ft, t6_100, a6_100)
];

store_mt_results_show mt_run[
("6_010f", uft, t6_010, t6_010),
("6_020f", uft, t6_020, t6_020),
("6_030f", uft, t6_030, t6_030),
("6_040f", uft, t6_040, t6_040),
("6_050f", uft, t6_050, t6_050),
("6_060f", uft, t6_060, t6_060),
("6_070f", uft, t6_070, t6_070),
("6_080f", uft, t6_080, t6_080),
("6_090f", uft, t6_090, t6_090),
("6_100f", uft, t6_100, t6_100)
]
end;
=TEX

=SML
let
val t6_110 =	ªff (if a then b else c)º;
val a6_110 =	["ff (if a then b else c)"];
val t6_120 =	ªff (if a then b else c) (if d then e else f) (if g then h else i)º;
val a6_120 =	["ff (if a then b else c) (if d then e else f) (if g then h else i)"];
val t6_130 =	ª((ff (if a then b else c)) (if d then e else f)) (if g then h else i)º;
val a6_130 =	["ff (if a then b else c) (if d then e else f) (if g then h else i)"];
val t6_140 =	ªff ((if a then b else c) ((if d then e else f) (if g then h else i)))º;
val a6_140 =	["ff ((if a then b else c) ((if d then e else f) (if g then h else i)))"];

in

store_mt_results_show mt_run[
("6_110", ft, t6_110, a6_110),
("6_120", ft, t6_120, a6_120),
("6_130", ft, t6_130, a6_130),
("6_140", ft, t6_140, a6_140)
];

store_mt_results_show mt_run[
("6_110f", uft, t6_110, t6_110),
("6_120f", uft, t6_120, t6_120),
("6_130f", uft, t6_130, t6_130),
("6_140f", uft, t6_140, t6_140)
]
end;
=TEX

=SML
let
val t6_150 =	ªff (ç a é b)º;
val a6_150 =	["ff (ç aé b)"];
val t6_160 =	ªff (ç a é b) (ç c é d) (ç e é f)º;
val a6_160 =	["ff (ç aé b) (ç cé d) (ç eé f)"];
val t6_170 =	ª((ff (ç a é b)) (ç c é d)) (ç e é f)º;
val a6_170 =	["ff (ç aé b) (ç cé d) (ç eé f)"];
val t6_180 =	ªff ((ç a é b) ((ç c é d) (ç e é f)))º;
val a6_180 =	["ff ((ç aé b) ((ç cé d) (ç eé f)))"];

in

store_mt_results_show mt_run[
("6_150", ft, t6_150, a6_150),
("6_160", ft, t6_160, a6_160),
("6_170", ft, t6_170, a6_170),
("6_180", ft, t6_180, a6_180)
];

store_mt_results_show mt_run[
("6_150f", uft, t6_150, t6_150),
("6_160f", uft, t6_160, t6_160),
("6_170f", uft, t6_170, t6_170),
("6_180f", uft, t6_180, t6_180)
]
end;
=TEX

=SML
let
val t6_190 =	ªff (let a = b in c)º;
val a6_190 =	["ff (let a = b in c)"];
val t6_200 =	ªff (let a = b in c) (let d = e in f) (let g = h in i)º;
val a6_200 =	["ff (let a = b in c) (let d = e in f) (let g = h in i)"];
val t6_210 =	ª((ff (let a = b in c)) (let d = e in f)) (let g = h in i)º;
val a6_210 =	["ff (let a = b in c) (let d = e in f) (let g = h in i)"];
val t6_220 =	ªff ((let a = b in c) ((let d = e in f) (let g = h in i)))º;
val a6_220 =	["ff ((let a = b in c) ((let d = e in f) (let g = h in i)))"];

in

store_mt_results_show mt_run[
("6_190", ft, t6_190, a6_190),
("6_200", ft, t6_200, a6_200),
("6_210", ft, t6_210, a6_210),
("6_220", ft, t6_220, a6_220)
];

store_mt_results_show mt_run[
("6_190f", uft, t6_190, t6_190),
("6_200f", uft, t6_200, t6_200),
("6_210f", uft, t6_210, t6_210),
("6_220f", uft, t6_220, t6_220)
]
end;
=TEX

\subsection{Lists and Sets}

Set Comprehension.

=SML
let
val t7_010 =	ª{a|b}º;
val a7_010 =	["{a|b}"];
val t7_020 =	ª{(a,b,c)|aÄ(Ébéb)Äc}º;
val a7_020 =	["{(a, b, c)|a Ä (É bé b) Ä c}"];

in

store_mt_results_show mt_run[
("7_010", ft, t7_010, a7_010),
("7_020", ft, t7_020, a7_020)
];

store_mt_results_show mt_run[
("7_010f", uft, t7_010, t7_010),
("7_020f", uft, t7_020, t7_020)
]
end;
=TEX

=SML
let
val t7_030 =	ª{}º;
val a7_030 =	["{}"];
val t7_040 =	ª{a; b; c; d; e}º;
val a7_040 =	["{a; b; c; d; e}"];
val t7_041 =	ª{a b}º;
val a7_041 =	["{a b}"];
val t7_042 =	ª{a}º;
val a7_042 =	["{a}"];

in

store_mt_results_show mt_run[
("7_030", ft, t7_030, a7_030),
("7_040", ft, t7_040, a7_040),
("7_041", ft, t7_041, a7_041),
("7_042", ft, t7_042, a7_042)
];

store_mt_results_show mt_run[
("7_030f", uft, t7_030, t7_030),
("7_040f", uft, t7_040, t7_040),
("7_041f", uft, t7_041, t7_041),
("7_042f", uft, t7_042, t7_042)
]
end;
=TEX

=SML
let
val t7_050 =	ª[]º;
val a7_050 =	["[]"];
val t7_060 =	ª[a; b; c; d; e]º;
val a7_060 =	["[a; b; c; d; e]"];
val t7_070 =	ª[a]º;
val a7_070 =	["[a]"];
val t7_080 =	ªf []º;
val a7_080 =	["f []"];
val t7_090 =	ªg [a]º;
val a7_090 =	["g [a]"];

in

store_mt_results_show mt_run[
("7_050", ft, t7_050, a7_050),
("7_060", ft, t7_060, a7_060),
("7_070", ft, t7_070, a7_070),
("7_080", ft, t7_080, a7_080),
("7_090", ft, t7_090, a7_090)
];

store_mt_results_show mt_run[
("7_050f", uft, t7_050, t7_050),
("7_060f", uft, t7_060, t7_060),
("7_070f", uft, t7_070, t7_070),
("7_080f", uft, t7_080, t7_080),
("7_090f", uft, t7_090, t7_090)
]
end;
=TEX

\subsection{Strings and Characters}

We cannot fully test strings with the standard pattern of tests used in
this document.  In particular, newline characters cannot tested via
$uft$ because the text that is generated holds a string containing a
newline, this is then passed to $usestring$ which passes it on to the
compiler.  Thus the compiler reads a string containing a newline
character which is not valid Standard~ML.  Test $8_010$ gives a good
test of various strings, test $8_030$ tests the handling of
back-slashes in strings, including newlines.  Test $8_030$ cannot use
function $uft$.

=SML
let
val t8_010 =	ªf "" T "a" T "a b c d e f g h i j k l m n o p q r s t u v w x y z" Tº;
val a8_010 =	["f \"\" T \"a\" T \"a b c d e f g h i j k l m n o p q r s t u v w x y z\" T"];
val t8_020 =	ª`a`º;
val a8_020 =	["`a`"];
val t8_030 =	ªf "\t\n\234" aº;
val a8_030 =	["f \"\t\n\234\" a"];

in

store_mt_results_show mt_run[
("8_010", ft, t8_010, a8_010),
("8_020", ft, t8_020, a8_020),
("8_030", ft, t8_030, a8_030)
];

store_mt_results_show mt_run[
("8_010f", uft, t8_010, t8_010),
("8_020f", uft, t8_020, t8_020)
(* No test of 8_030 with $uft$ *)
]
end;
=TEX

\subsection{INCOMPLETE USES OF HOL CONSTANTS}

Examples of HOL constants used for concrete syntax items but which are
insufficiently parameterised and so must be printed in their function
application form.

=SML
let
val t9_010 =	ªUncurry fº;
val a9_010 =	["Uncurry f"];
val t9_020 =	ªUncurry f aº;
val a9_020 =	["Uncurry f a"];
val t9_030 =	ªUncurry f a bº;
val a9_030 =	["Uncurry f a b"];
val t9_040 =	ªUncurry f a b cº;
val a9_040 =	["Uncurry f a b c"];
in
store_mt_results_show mt_run[
("9_010", ft, t9_010, a9_010),
("9_020", ft, t9_020, a9_020),
("9_030", ft, t9_030, a9_030),
("9_040", ft, t9_040, a9_040)
];

store_mt_results_show mt_run[
("9_010f", uft, t9_010, t9_010),
("9_020f", uft, t9_020, t9_020),
("9_030f", uft, t9_030, t9_030),
("9_040f", uft, t9_040, t9_040)
]
end;
=TEX

=SML
let
val App(t9_050, _) = dest_simple_term ªif a then b else cº;
val a9_050 =	["Cond a b"];
val App(t9_060, _) = dest_simple_term t9_050;
val a9_060 =	["Cond a"];
val App(t9_070, _) = dest_simple_term t9_060;
val a9_070 =	["Cond"];
in
store_mt_results_show mt_run[
("9_050", ft, t9_050, a9_050),
("9_060", ft, t9_060, a9_060),
("9_070", ft, t9_070, a9_070)
];

store_mt_results_show mt_run[
("9_050f", uft, t9_050, t9_050),
("9_060f", uft, t9_060, t9_060),
("9_070f", uft, t9_070, t9_070)
]
end;
=TEX

=SML
let
val App(t9_080, _) =	dest_simple_term ªlet a (b, c) = d in eº;
val a9_080 =	["Let (ç aé e)"];
val App(t9_090, _) =	dest_simple_term ªlet a (b, c) = d and (e, f) = g in hº;
val a9_090 =	["Let (let a (b, c) = d in ç (e, f)é h)"];
in
store_mt_results_show mt_run[
("9_080", ft, t9_080, a9_080),
("9_090", ft, t9_090, a9_090)
];

set_flag("pp_show_HOL_types", true);

store_mt_results_show mt_run[
("9_080f", uft, t9_080, t9_080),
("9_090f", uft, t9_090, t9_090)
];

set_flag("pp_show_HOL_types", false)

end;
=TEX

Set comprehensions.
In the short term expect test $9_100f$ to fail, this is because
in $t9_100$ we use $mk_const$ but at the call of $uft$ the name
$SetComp$ is not declared and so is set up as a variable.

=SML
let
val tv1 = mk_vartype "'tv1";
val tv2 = mk_vartype "'tv2";
val v1 = mk_var("v1", tv1);
val v2 = mk_var("v2", tv2);
val t9_100 = mk_app(mk_const("SetComp",mk_ã_type(mk_ã_type(
			mk_â_type(tv1,tv2),BOOL),
			mk_ctype("SET",[mk_â_type(tv1,tv2)]))),
		mk_var("v",mk_ã_type(mk_â_type(tv1,tv2),BOOL)));
val a9_100 = ["SetComp v"];
in
store_mt_results_show mt_run[
("9_100", ft, t9_100, a9_100)
];

set_flag("pp_show_HOL_types", true);

store_mt_results_show mt_run[
("9_100f", uft, t9_100, t9_100)
];

set_flag("pp_show_HOL_types", false)

end;
=TEX

\subsection{Other Formatting Routines}

The preceding tests have exercised the internals of all of the
formatting routines.  This group of tests exercises the various
interfaces.

=SML
let
val t10_tm =	ªxÄyº;
val t10_ty =	ª: 'a ã 'bº;

in

store_mt_results_show mt_run[
("10_010t", PrettyPrinter.format_term true,			t10_tm, ["ªx Ä yº"]),
("10_010t", PrettyPrinter.format_term false,			t10_tm, ["x Ä y"]),
("10_020t", PrettyPrinter.format_term1 true		80,	t10_tm, ["ªx Ä yº"]),
("10_020f", PrettyPrinter.format_term1 false	80,	t10_tm, ["x Ä y"])];

store_mt_results_show mt_run[
("10_030t", PrettyPrinter.format_type1 true		80,	t10_ty, ["ª:'a ã 'bº"]),
("10_030f", PrettyPrinter.format_type1 false		80,	t10_ty, ["'a ã 'b"])
]

end;
=TEX

\subsection{Coup de Gr\^ace}

An attempt to get all of the productions in the grammar
of~\cite{DS/FMU/IED/DEF001} into one HOL term.

=SML
Value	(new_type("TRIPLE", 3))				handle Fail _ => Nil;
	declare_postfix (100, "+++")				handle Fail _ => ();
=TEX

=SML
val t_cdg = ª	Ñ ka : ( '8 ã '9 ã '10 ) é kb
		let ha = ( hb : '4 ) in hc
		É (ga, gb) (gc, gd, ge) ; gf gg : '2 ã '3 é gh
		let ia ((ib, ic), (id, ie)) = ig : ('5, '6, '7) TRIPLE
			and ja jb jc jd = [fa = fb; å fc ; fd +++ ]
		in { (la, lb) | lc (la []) lb if ma then {} else ( { mb ; mc ; md } : '1 SET ) }
	º;

val a_cdg = ["Ñ kaé kb " ^
		"(let ha = hb in hc " ^
		"(É (ga, gb) (gc, gd, ge) gf ggé gh " ^
		"(let ia ((ib, ic), id, ie) = ig " ^
		"and ja jb jc jd = [fa = fb; å fc; fd +++] " ^
		"in {(la, lb)|lc (la []) lb (if ma then {} else {mb; mc; md})})))"];

val a_cdg_br = ["Ñ kaé (kb " ^
	"(let ha = hb in " ^
	"(hc " ^
	"(É (ga, gb) (gc, (gd, ge)) gf ggé " ^
	"(gh " ^
	"(let (ia ((ib, ic), (id, ie))) = ig and (ja jb jc jd) = " ^
	"[fa = fb; å fc; fd +++] in " ^
	"{(la, lb)|lc (la []) lb (if ma then {} else {mb; mc; md})})))" ^
	")))"];

val a_cdg_br_ty = ["Ñ (ka : ('8 ã ('9 ã '10)))é ((kb : ('a ã BOOL)) " ^
	"(let (ha : '4) = (hb : '4) in " ^
	"((hc : (BOOL ã 'a)) " ^
	"(É ((ga : 'b), (gb : 'c)) ((gc : 'd), ((gd : 'e), (ge : 'f))) " ^
	"(gf : ('2 ã '3)) (gg : ('2 ã '3))é " ^
	"((gh : ((('g LIST ã 'h) â 'i) SET ã BOOL)) " ^
	"(let " ^
	"((ia : ((('j â 'k) â ('l â 'm)) ã ('5, '6, '7) TRIPLE)) " ^
	"(((ib : 'j), (ic : 'k)), ((id : 'l), (ie : 'm)))) = " ^
	"(ig : ('5, '6, '7) TRIPLE) and " ^
	"((ja : ('n ã ('o ã ('p ã BOOL LIST)))) " ^
	"(jb : 'n) " ^
	"(jc : 'o) " ^
	"(jd : 'p)) = " ^
	"[(fa : 'q) = (fb : 'q); å (fc : BOOL); (fd : 'r) +++] in " ^
	"{((la : ('g LIST ã 'h)), (lb : 'i))" ^
	"|(lc : ('h ã ('i ã ('1 SET ã BOOL)))) " ^
	"((la : ('g LIST ã 'h)) []) (lb : 'i) " ^
	"(if (ma : BOOL) " ^
	"then {} " ^
	"else {(mb : '1); (mc : '1); (md : '1)}" ^
	")}))))))"];

val a_cdg_ty = ["Ñ (ka : ('8 ã '9 ã '10))é (kb : ('a ã BOOL)) " ^
	"(let (ha : '4) = (hb : '4) in " ^
	"(hc : (BOOL ã 'a)) " ^
	"(É ((ga : 'b), (gb : 'c)) ((gc : 'd), (gd : 'e), (ge : 'f)) " ^
	"(gf : ('2 ã '3)) (gg : ('2 ã '3))é " ^
	"(gh : ((('g LIST ã 'h) â 'i) SET ã BOOL)) " ^
	"(let " ^
	"(ia : ((('j â 'k) â 'l â 'm) ã ('5, '6, '7) TRIPLE)) " ^
	"(((ib : 'j), (ic : 'k)), (id : 'l), (ie : 'm)) = " ^
	"(ig : ('5, '6, '7) TRIPLE) and " ^
	"(ja : ('n ã 'o ã 'p ã BOOL LIST)) (jb : 'n) (jc : 'o) (jd : 'p) = " ^
	"[(fa : 'q) = (fb : 'q); å (fc : BOOL); (fd : 'r) +++] in " ^
	"{((la : ('g LIST ã 'h)), (lb : 'i))" ^
	"|(lc : ('h ã 'i ã '1 SET ã BOOL)) " ^
	"((la : ('g LIST ã 'h)) []) (lb : 'i) " ^
	"(if (ma : BOOL) then {} else {(mb : '1); (mc : '1); (md : '1)})}))" ^
	")"];

set_line_length 5000;
set_flag("pp_add_brackets", false);
set_flag("pp_show_HOL_types", false);
store_mt_results_show mt_run[("cdg_010", ft, t_cdg, a_cdg)];

set_flag("pp_add_brackets", true);
store_mt_results_show mt_run[("cdg_020", ft, t_cdg, a_cdg_br)];

set_flag("pp_show_HOL_types", true);
store_mt_results_show mt_run[("cdg_030", ft, t_cdg, a_cdg_br_ty)];

set_flag("pp_add_brackets", false);
store_mt_results_show mt_run[("cdg_040", ft, t_cdg, a_cdg_ty)];

set_flag("pp_show_HOL_types", false);
=TEX

\section{SUMMARY OF RESULTS}

=SML
set_line_length 80;

diag_string(summarize_mt_results());
=TEX

\end{document}
