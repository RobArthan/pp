% usr005.doc  %Z% $Date$ $Revision$ $RCSfile$
=IGNORE
           % U s e f u l C o m m a n d s

make -f usr006.mkf usr005.dvi1
make -f usr006.mkf usr005.dvi

=TEX

\documentstyle[hol1,11pt,fleqn,USR]{book}

\def\SCCSversion{$Revision$%
}
\def\SCCSdate{\FormatDate{$Date$
}}

\USRmanual{DESCRIPTION}
\USRref{usr005}
%\USRdate{\SCCSdate}

\raggedbottom
\ftlinepenalty=9999
\makeindex

\title{\Product}
\author{ }

\underscoreoff
\begin{document}

\makeUSRfrontpage

\pagebreak

\chapter*{CONTENTS}

\tableofcontents
\listoftables

\setcounter{chapter}{-1}

\chapter{ABOUT THIS PUBLICATION} \label{intro}
\section{Purpose}

This document, one of several making up the user documentation for the \Product\ system, is the description manual for the system.
\section{Readership}

This document will eventually provide a narrative description of {\Product} to complement the catalogue of detail provided by the {\REFERENCE}.
It is at present incomplete, containing only those parts of its intended content which are least well covered by other {\Product} user documentation.
Specifically, this version of the manual described the concrete syntax of the specification languages supported by {\Product}.

\section{Related Publications}

A bibliography is given at the end of this document.

Publications relating specifically to \Product\ are:

\begin{enumerate}
\item {\em \ {\TUTORIAL}}, tutorial covering the basic \Product{} system.
\item {\em \ {\ZTUTORIAL}}, tutorial covering \Product{} Z support option.
\item {\em \ {\HTUTORIAL}};
\item {\em \ {\REFERENCE}};
\item {\em \ {\INSTALLATION}};
\item {\em \ {\TYPESETTING}}.
\end{enumerate}

Since the user documentation is as yet incomplete \cite{DS/FMU/IED/USR001} is made available with the \Product{} system to cover some of the areas not yet fully addressed by user documentation.

\section{Assumptions}

Though it is not strictly prerequisite, the user may find this volume easier to read after attending a course on {\Product}, or after consulting the \TUTORIAL.

\section{Acknowledgements}

ICL gratefully acknowledges its debt to the many researchers (both academic and industrial) who have provided intellectual capital on which ICL has drawn in the development of \Product.

We are particularly indebted to Mike Gordon of The University of Cambridge, for his leading role in some of the research on which the development of \Product\ has built, and for his positive attitude towards industrial exploitation of his work.

The \Product\ system is a proof tool for Higher Order Logic which builds upon ideas arising from research carried out at the Universities of Cambridge and Edinburgh, and elsewhere.

In particular the logic supported by the system is (at an abstract level) identical to that implemented in the Cambridge HOL system \cite{gordon93}, and the paradigm adopted for implementation of proof support for the language follows that adopted by Cambridge HOL, originating with the LCF system developed at Edinburgh \cite{gordon79}.
The functional language ``standard ML'' used both for the implementation and as a interactive metalanguage for proof development, originates in work at Edinburgh, and has been developed to its present state by an international group of academic and industrial researchers.
The implementation of Standard ML on which \Product\ is based was itself originally implemented by David Matthews at the University of Cambridge, and is now commercially marketed by Abstract Hardware Limited.

The \Product{} system also supports specification and proof in the Z language, developed at the University of Oxford.
We are therefore also indebted to the research at Oxford (and elsewhere) which has contributed to the development of the Z language.


=IGN
\chapter{USER INTERFACE}

The contents of this section will be as indicated below.

\begin{itemize}
\item Services provided at the interface to the host operating system.
\item \begin{enumerate}
\item Standard ML.  What is documented here is what the user needs to
	know to get into {\SML} in order subsequently to run the proof
	development system, as opposed to what the user needs to know
	to get into {\SML} in general.   This might be nothing.
\item customization of screen and keyboard  to handle extended character sets.  What is documented here is how to switch on the facility, and what is the extended character set  and keyboard layout.
\item preparation of literate scripts using standard text-editors, with
	or without extended character sets.  What is documented here is
	the use of the extended characters which are special delimiters
	to mark off fragments, boxes etc. and all the \LaTeX macros
	which are provided to represent pretty characters or for other
	purposes.
\item printing of literate scripts. What is documented here is how to get the fonts set up and how to use the preprocessors.
\end{enumerate}
\item Services provided at the interface to \SML.
\item \begin{enumerate}
\item The proof development system, as constituted by all the defined {\SML} objects  documented in the body of the
 Reference Manual.  What might be documented here is the naming-conventions of \Cyte{DEF003}.
\item input of HOL terms via the parser.  What is documented here is the use of  special quotes to invoke the parser and the BNF of the grammar of HOL terms, as in \Cyte{DEF001}.
\item Use of the Z-like specification features, e.g. for $new\_specification$, for input of certain {\SML} expressions  and the automatically-performed proofs.   See  \Cyte{HLD010}.
\item customization of the parser for user-defined lexis. See \Cyte{DEF001}
\item output of HOL terms (via the pretty-printer).  What is to be documented here is what are the options for outputting a term. (Pretty-printed or not, with or without explicit types, etc, and how the pretty-printing may be customized ).
\item input of  \SML text stripped out of a literate script. What is documented here is how to invoke the process, and what are the conditions on the literate script for it to be successful.
\end{enumerate}
\end{itemize}
\pagebreak
=TEX

\pagebreak

\part{The ProofPower System}\label{PP-SYS}

\chapter{THE METALANGUAGE}

{\Product} has been implemented using PolyML, an implementation of Standard ML \cite{harper88}.

PolyML provides some extensions to the standard which have been used in the implementation of {\Product}.

These include:

\begin{itemize}
\item
A persistent database.
\item
Means of supporting quotation and pretty printing of object languages.
\end{itemize}

These extensions have been used in the development of {\Product} to achieve the following effects:

\begin{itemize}
\item
The theory heirarchy is held securely in the persistent database.
\item
The character set accepted in the metalanguage (ML) has been extended by including appropriate logical and mathematical symbols.
These extensions to the character set are mainly treated as new alphabetic characters and may therefore appear in ML variable names.
\item
Facilities have been provided for quotation of object language expressions and for automatic pretty-printing of values which represent such expressions.
\end{itemize}

To ensure that the {\Product} theory heirarchy is properly maintained, some of the effects normally obtained by commands supplied with PolyML should be obtained using alternative commands supplied with {\Product}.
Users of ProofPower should only use the supplied {\Product} function instead of the corresponding PolyML function whenever they are operating on a {\Product} database.

{\Product} users should use the UNIX command $Ûhol\_make\_databaseÝ$ instead of $ÛPolyML.make\_databaseÝ$.

Superseded ML functions are:

\begin{centering}

\begin{tabular}{l | l}
Use ProofPower Command & Instead of	PolyML command\\\hline
$Ûsave\_and\_quitÝ$ & $ÛPolyML.commitÝ$ \\
$ÛquitÝ$ & $ÛPolyML.quitÝ$ \\
$Ûuse\_fileÝ$ & $ÛPolyML.useÝ$
\end{tabular}

\end{centering}

Full details of the {\Product} versions of these commands may be found in the {\REFERENCE}.

{\Product} users should not use the following Poly/ML functions on {\Product} databases:

\begin{itemize}
\item
$ÛPolyML.makeÝ$
\item
$ÛPolyML.install\_ppÝ$
\item
$ÛPolyML.compilerÝ$
\end{itemize}

\chapter{ProofPower CONTROLS}

Some aspects of the behaviour of {\Product} are determined by the settings of various {\it controls} which the user of {\Product} may change.

There are three types of control, according to the type of the Standard ML value which exercises the control.
The value may have type {\tt bool}, {\tt int} or {\tt string}.

Procedures are available for manipulating the controls as follows:

\begin{centering}

\begin{table}

\begin{tabular}{|| l | l | p{4.5in} ||} \hline
{\bf name} & {\bf purpose} \\ \hline \hline
get_controls & retrieve all control values \\
get_int_controls & retrieve all integer control values \\
get_int_control & retrieve an integer control values \\
get_string_control & retrieve a string control value \\
new_int_control & create a new integer control value \\
new_string_control & create a new string control value \\
reset_int_control & set an int control to its default value \\
reset_string_control & set a string control to its default value\\
set_int_control & set an int control value\\
set_string_control & set a string control value \\
get_string_controls & get the string control values \\
reset_controls & reset all control values to their defaults \\
reset_int_controls & reset all int control values to their default\\
reset_string_controls & reset all string control values to their default \\
set_controls & set all control values \\
set_int_controls & set all int control values \\
set_string_controls & set all string control values \\
\\ \hline
\end{tabular}
\caption{ML Procedures for Manipulating Control Values}
\label{ProceduresManipulatingControls}
\end{table}

\end{centering}



\begin{centering}

\begin{table}
\begin{tabular}{|| l | l | p{3.5in} ||} \hline
{\bf name} & {\bf default value} & {\bf purpose} \\ \hline \hline
Ûcheck_is_zÝ & false & Influences the checking of theorems by Z inference facilities.\\ \hline 
Ûignore_warningsÝ & false & Causes warnings to be ignored.\\ \hline 
Ûillformed_rewrite_warningÝ & false & Controls output of a diagnostic arising when rewriting is inhibited due to certain kinds of bound variable capture.\\ \hline
Ûpp_add_bracketsÝ & false & When set the pretty printer to use more brackets.\\ \hline
Ûpp_let_as_lambdaÝ & false & If set let expressions are printed without hiding their underlying structure.\\ \hline
Ûpp_print_assumptionsÝ & true & Controls the pretty printing of theorems.
If this flag is set to true then any assumptions are printed in full, when set to false a single dot is printed to indicate the presence of assumptions, but the assumptions themselves are not printed.
This does not affect the printing of subgoals. \\ \hline
Ûpp_show_HOL_typesÝ & false & Causes extensive inclusion of type information in the output if the pretty printer.\\ \hline
Ûpp_show_indexÝ & false & \\ \hline
Ûpp_types_on_bindersÝ & false & Causes the pretty printer to display type casts on binding occurrences of variables.\\ \hline 
Ûpp_use_aliasÝ & true & When set the pretty printer will print terms using applicable aliases for the constants occuring in the terms.\\ \hline 
ÛprofilingÝ & false & Causes a number of counts to be incremented, particularly of kernel inference steps. \\ \hline
Ûresolution_diagnosticsÝ & false & Controls the output of diagnostics from the resolution package.\\ \hline
Ûsorted_listingsÝ & false & Causes theory listings to be sorted according to keys\\ \hline 
Ûstandard_z_termsÝ & false & Influences the checking of terms by Z facilities. \\ \hline
Ûstandard_z_parasÝ & true & Influences the checking of paragraphs by Z facilities. \\ \hline 
Ûsubgoal_package_quietÝ & false & This flag may be used to inhibit output from the subgoal package when re-running proofs which are known to work.\\ \hline 
Ûsubgoal_package_ti_contextÝ & true & Determines whether the type inference context is set by the subgoal package, causing parsing of terms to be influenced by the types of free variables in the current subgoal.\\ \hline
Ûti_verboseÝ & true & \\ \hline
Ûz_type_check_onlyÝ & true & When this control is set to `true', certain aspects of the processing of Z are inhibited, giving a faster response for type-checking only.\\ \hline
Ûz_use_axiomsÝ & true & Determines whether Z `axiomatic descriptions' are treated as `conservative' extensions.\\ \hline
Ûuse_file_non_stop_modeÝ & false & \\ \hline
Ûuse_extended_charsÝ & true &
When true extended characters are output while pretty printing, when false ascii keywords are output.
Does not affect input or {\LaTeX} output. \\ \hline 
\end{tabular}
\caption{Boolean Controls}
\label{BooleanControls}
\end{table}

\end{centering}

\begin{centering}

\begin{table}
\begin{tabular}{|| l | l | p{3.5in} ||} \hline
{\bf name} & {\bf default value} & {\bf purpose} \\ \hline \hline
Ûcompactification_maskÝ & 0 & Controls the compactification algorithms. \\ \hline
Ûline_lengthÝ & 78 & Should be set to the width of the window running ProofPower.\\ \hline
Ûlisting_indentÝ & 2 & Used to control the formatting of theory listings.\\ \hline
Ûpp_format_depthÝ & ~1 & Influences the formatting produced by the pretty printer.\\ \hline
Ûpp_top_level_depthÝ & ~1 & Influences the formatting produced by the pretty printer.\\ \hline
ÛRW_diagnosticsÝ & 0 & \\ \hline
Ûthl_char_widthÝ & 8 & Used to control the formatting of theory listings.\\ \hline 
Ûthl_chars_per_tabÝ & 5 & Used to control the formatting of theory listings.\\ \hline
Ûthl_line_widthÝ & 13 & Used to control the formatting of theory listings.\\ \hline
Ûthl_tab_widthÝ & 50 & Used to control the formatting of theory listings.\\ \hline
Ûtactic_subgoal_warningÝ & 20 & When the number of subgoals arising from a tactic application exceeds this value the subgoal package gives a warning before displaying the subgoals.
\\ \hline 
Ûundo_buffer_lengthÝ & 12 & Determines how many steps of a proof can be undone by the subgoal package (using `undo').\\ \hline
\end{tabular}
\caption{Integer Controls}
\label{IntegerControls}
\end{table}

\end{centering}

\begin{centering}

\begin{table}
\begin{tabular}{|| l | l | p{3.5in} ||} \hline
{\bf name} & {\bf default value} & {\bf purpose} \\ \hline \hline
Ûprompt1Ý & \verb!":> "! &
This is the prompt used by ProofPower when it is expecting a new command. \\ \hline
Ûprompt2Ý & \verb!":# "! & This is the prompt used by ProofPower when it is expecting more input to complete a command which has already started.\\ \hline 
Ûvariant_suffixÝ & \verb!"'"! &
This is the character used to decorate a variable name when alpha conversion takes place. \\ \hline 
\end{tabular}
\caption{String Controls}
\label{StringControls}
\end{table}

\end{centering}

\chapter{FORMAT OF ProofPower DIAGNOSTICS}

The \Product\ specification and proof tools (i.e., the program
\verb"pp", and its language specific variants \verb"hol" and
\\verb"zed") report errors via the ML exception mechanism.
The error messages have the following general format:

=GFT
<<Optional Explanatory Text>>
Exception- <<Error Type>> * <<Text>> [<<Function>>.<<Number>>] * raised
=TEX

Some recoverable error conditions are treated as warnings. Depending
on the value of the system control flag $ignore\_warnings$ and on whether
you are running interactively, functions detecting such
conditions give you the option to ask them to recover from
the error. The format of a warning message has the general form.

=GFT
<<Optional Explanatory Text>>
*** WARNING <<Number>> raised by <<Function>>: <<Text>>
Do you wish to continue (y/n)?
=TEX

For example, the following input, which contains a syntax error:

=GFT ProofPower Input
:> ¬(if a then b else )c®;
=TEX
\ produces the error message:

=GFT ProofPower Output 
Syntax error in: ¬ ( if a then b else <?> ) 
) is not expected after ¬ ( if ... then ... else
Exception- Fail * Syntax error [HOL-Parser.19000] * raised
=TEX
Most of the functions for manipulating syntax, and carrying out proofs,
do not produce any optional explanatory text. For example, the following
input, in which an inference rule is applied to a term with the wrong type:

=GFT ProofPower Input
:> asm_rule¬1 + 2®;
=TEX
\ produces the following error report:

=GFT ProofPower Output 
Exception- Fail * ¬1 + 2® is not of type ”BOOL® [asm_rule.3031] * raised
=TEX

As a final example, the most commonly seen warning condition is when you
ask to delete an object from the current theory; for example, in a theory
in which a number of constants and types have been defined, the input:

=GFT ProofPower Input
:> delete_type"REAL";
=TEX
\ might produce the warning message:

=GFT ProofPower Output
*** WARNING 12012 raised by delete_type: Deletion of REAL would require the
 deletion of Constants:Ð, e; Type:REAL
Do you wish to continue (y/n)?
=TEX

\ if you answer \verb"y", then $delete\_type$ will continue and delete
the objects listed in the error message. If you answer \verb"n", it will
raise an exception:

=GFT ProofPower Output
...
Do you wish to continue (y/n)? n
Exception- Fail * execution of delete_type abandoned [warn.10003] * raised
=TEX


In more detail, the various components of an error message are as follows:

\begin{description}
\item[Optional Explanatory Text]
If present, this gives an extended description of the problem
encountered. It is typically used by subsystems such as the parser or type
inferrer, which use a custom layout for their error messages.
If it is present then the $Text$ part of the message is normally a very
brief summary.
\item[Error Type]
This may either be:
$Fail$ indicating an error which the detecting function cannot recover
form but which may, in some circumstances, sensibly be handled by the
calling function.
$Error$ indicating an unrecoverable error condition which should not be
handled. Either the input is so seriously flawed that the condition should
be reported to the user immediately, or an unexpected failure has occurred
(and should be reported to ICL).
\item[Text]
In the absence of the optional explanatory text,
this is the main description of the error condition.
The text of the message is generated from an entry in an error message database,
together with any details specific to the
current failure - for instance, the input causing the failure.
The reference manual entry for the function raising the error
may contain further details of the cause of the error.
\item[Function]
This is the name of the function or subsystem raising the error.
\item[Number]
This is the error number, which is an index into the error
message database (c.f. $get\-\_error\-\_message$).
The reference manual entry of the function raising the exception
will usually contain the original text of the message, and
sometimes a description of the causes of that particular error.
\end{description}

It is intended that errors raised following the above format 
will either give the user a pointer to the solution of the
problem, or, if necessary, assist support staff understanding
the problem.
Thus, if you wish to contact ICL concerning a problem with \Product{}
it will be helpful if you had available the text of any
relevant error messages. At the very least the function name and the
error number should be noted.

If an exception is raised with a format other than the above
then it usually indicates a Standard ML programming error.
For instance requesting Standard ML to evaluate $1\ div\ 0$
will raised the Standard ML exception $Div$:

=GFT ProofPower Output
Exception- Div raised
=TEX

If problems arise with files, such as warnings of missing files or unexpectedly being denied read permission, you
should first contact your system administrator to
see whether the problem is due to the local installation.

\chapter{CONCRETE SYNTAX NOTATION}\label{def001A}
\include{def001A}

\part{ProofPower-HOL}\label{PP-HOL}

%\chapter{ProofPower-HOL IN THE METALANGUAGE}\label{usr005B}
%\include{usr005B}

\pagebreak
\chapter{ProofPower-HOL CONCRETE SYNTAX}\label{usr005A}
\include{usr005A}

%\pagebreak
%\chapter{THE ProofPower-HOL LOGIC}\label{usr005C}
%\include{usr005C}

%\part{Theorem Proving with ProofPower}
%\chapter{THEOREM PROVING IN ProofPower-HOL}\label{usr005D}
%\include{usr005D}

%\include{usr005.drules}
%\include{usr005.conv}
%\include{usr005.tactics}
%\include{usr005.see} 
    
\part{ProofPower-Z}
\chapter{ProofPower-Z CONCRETE SYNTAX}\label{def007A}
\include{def007A}

\pagebreak
\chapter*{REFERENCES}
\addcontentsline{toc}{chapter}{REFERENCES}

\bibliographystyle{fmu}
\bibliography{fmu}

\pagebreak
\twocolumn[\chapter*{INDEX}]
\addcontentsline{toc}{chapter}{INDEX}
\small

\printindex

\end{document}

