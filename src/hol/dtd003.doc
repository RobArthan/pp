=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Release 1 ICL HOL: Detailed Design for Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Release 1 ICL HOL \cr Detailed Design for Types and Terms}
\TPPref{DS/FMU/IED/DTD003}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the types of HOL terms and types, namely $TERM$ and $TYPE$. It then gives some utility functions upon these.
These will be sufficient functions upon $TERM$ to define the type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
Based on the first part of DS/FMU/IED/SML002.
\item [Issue 1.2]
Many changes while deciding upon a format.
\item [Issues 1.3, 1.4]
Changes made during writing implementation.
\end{description}
\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design of the types and terms of ICL HOL, and utilities to handle them, called for by the first point of section 4.2 of the Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The high-level specification for the code may be considered
to be given in \cite{DS/FMU/IED/SPC001}.
The design is
implemented in \cite{DS/FMU/IED/IMP003}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design of the types and terms of ICL HOL, and utilities to handle them.
These will be sufficient functions upon $TERM$ to define the type $THM$.
\subsubsection{Dependencies}

\subsubsection{Deficiencies}
The proposed pretty character facilities would allow such renamings as $mk\_forall$ to $mk\_É$, which would be preferable.
\subsubsection{Possible Enhancements}

=TEX
\section{INFIX DIRECTIVES}
=SML
infix 4 TERM_eq;
=TEX
\section{TYPES AND TERMS}
=DOC
signature ‚icl'TypesAndTerms· = sig
=DESCRIBE
This provides the type of ICL HOL types: $TYPE$, of ICL HOL terms: $TERM$, and some
utility functions upon them.
A user should access all the elements of this signature through signature $DerivedTerms$ in \cite{DS/FMU/IED/DTD004}.
=ENDDOC
\subsection{The Type: $TYPE$}
It may well be worth considering making the function type constructor
a constructor of the datatype $TYPE$. The advantage would be that
function types could then be recognised by a simpler pattern match (not
involving a string equality test).
We have not done this since it complicates some issues.

By using the names $mk\_vartype$ and $mk\_type$ below we follow the convention for naming construction and destruction functions,
rather than data constructors.
=DOC
datatype ‚TYPE· =
		‚mk_vartype· of string |
		‚mk_type·    of string * TYPE list;
=DESCRIBE
All ICL HOL terms will be ``typed'', by associating them with
an object of type $TYPE$.
A type may either be a variable (or generic) type, indicated in the
concrete syntax by $:'<name>$;
or a type constructor, with a list of type arguments, indicated by
$typename$, $arg\ typename$ or $(arg_1, \ldots, arg_n)\ typename$,
for types with none, one or many arguments.
=ENDDOC
\subsection{Functions Upon the Type $TYPE$}
=DOC
val ‚dest_type· : TYPE -> string * TYPE list;
=DESCRIBE
Extract the arguments to $mk\_type$ by function rather than pattern-matching.
=FAILURE
3001	Argument is not of form: mk_type(<string>,<type list>)
	but mk_vartype ?0
=ENDDOC
=DOC
val ‚mk_fun· : (TYPE * TYPE) -> TYPE;
=DESCRIBE
$mk\_fun$ $(ty_1,\ ty_2)$ is $":ty_1 ã ty_2"$.
=ENDDOC
=DOC
val ‚icl'inst_type· : ((TYPE * string) list) -> TYPE -> TYPE;
=DESCRIBE
$inst\_type$ $alist$ $type$ recursively descends through $type$, replacing any type variables by whatever the association list $alist$ associates with them.
If the association list does not contain a type variable found in $type$, then that type variable will not be changed.
Replaced types are {\bf not} recursively processed by this function.
=ENDDOC
=DOC
val ‚type_tycons· : TYPE -> (string * int) list;
=DESCRIBE
This returns a list of names of type constructors, and the arity of their use, within a type.
=ENDDOC
=DOC
val ‚type_tyvars· : TYPE -> string list;
=DESCRIBE
Returns the list of type variable names present in a type.
=ENDDOC
=DOC
val ‚BOOL· : TYPE;
=DESCRIBE
The type of boolean-valued ICL HOL terms.
=SEEALSO
(The theory that declared a new type of this name)
=ENDDOC
=TEX
\subsection{The Types $TERM$ and $DEST\_TERM$}
=DOC
type ‚TERM·;
=DESCRIBE
This is the type of well-formed ICL HOL terms.
Objects of this type are manipulated by term constructor and destructor functions, such as $mk\_comb$, $dest\_abs$ and $is\_var$.
=ENDDOC
=DOC
datatype ‚DEST_TERM· = ‚Var· of string * TYPE |
	‚Const· of string * TYPE |
	‚Comb· of TERM * TERM |
	‚Abs· of TERM * TERM;
=DESCRIBE
This is the type of destroyed terms, related to the type $TERM$ by
$dest\_TERM$ and $mk\_TERM$.
The four data constructors represented destroyed variables, constants, combinations and abstractions respectively.
=USES
In writing pattern-matching functions upon ICL HOL terms.
=ENDDOC
\subsection{Primitive Functions Upon Terms}
=DOC
val ‚dest_TERM· : TERM -> DEST_TERM;
=DESCRIBE
An injective function, that destroys a term, returning its 
top-level structure, and the associated constituent parts.
=FAILURE
3063	DESIGN ERROR : Ill-formed representation of TERM
=SEEALSO
$mk\_TERM$, $DEST\_TERM$
=ENDDOC
=DOC
val ‚mk_TERM· : DEST_TERM -> TERM;
=DESCRIBE
Create a well-formed TERM from a statement of a top-level structure, and the associated constituent parts.

This may produce terms that are not well-formed within the context of some theories.
=SEEALSO
$dest\_TERM$, $DEST\_TERM$
=FAILURE
3002	Given `Comb(f, x)', where `f' cannot be applied to `x'
3003	Ill-formed argument to mk_TERM
=ENDDOC
=DOC
val ‚type_of· : TERM -> TYPE;
=DESCRIBE
This gives the type of a term.
=ENDDOC
=DOC
val ‚icl'mk_var· : (string * TYPE) -> TERM;
=DESCRIBE
This produces a term with a variable's structure.

This may produce terms that are not well-formed within the context of some theories.
=USES
For producing variable names that are arbitrary strings, in particular for generated variable names.
=SEEALSO
$mk\_var$
=ENDDOC
=DOC
val ‚dest_var·: TERM -> (string * TYPE);
=DESCRIBE
Destroys a term with a variable's structure.
=FAILURE
3008	Term is not a variable
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val ‚is_var· : TERM -> bool;
=DESCRIBE
This function returns true iff. the term has a variable's structure.
=ENDDOC
=DOC
val ‚mk_const· : (string * TYPE) -> TERM;
=DESCRIBE
This produces a term with a constant's structure.

This may produce terms that are not well-formed within the context of some theories.
=FAILURE
3004		The constant name `?0' must be non-empty and must not contain 
		spaces or control characters
=ENDDOC
=DOC
val ‚dest_const·: TERM -> (string * TYPE);
=DESCRIBE
Destroys a term with a constant's structure.
=FAILURE
3009	Term is not a constant
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val ‚is_const· : TERM -> bool;
=DESCRIBE
This function returns true iff. the term has a constant's structure.
=ENDDOC
=DOC
val ‚mk_comb· : (TERM * TERM) -> TERM;
=DESCRIBE
This produces a term with a functional application structure.
=FAILURE
3005	Argument type must be compatible with function type
3006	Operator type must be a function type
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val ‚dest_comb·: TERM -> (TERM * TERM);
=DESCRIBE
Destroys a term with a function application structure.
=FAILURE
3010	Term is not a function application
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val ‚is_comb· : TERM -> bool;
=DESCRIBE
This function returns true iff. the term has a function application structure.
=ENDDOC
=DOC
val ‚list_mk_comb· : (TERM * TERM list) -> TERM;
=DESCRIBE
ÛDefinition
list_mk_comb ("body", ["a","b","c",...]) = "body a b c ..."
Ê
=FAILUREC
\paragraph{Failure}
May give rise to the error message from $mk\_comb$.
=ENDDOC
=DOC
val ‚strip_comb· : TERM -> TERM * TERM list;
=DESCRIBE
Splits a term into a head term, that is not an application, and the list of argument terms applied to that head term to form the original term.
=EXAMPLE
strip_comb "f (1+2) 3 4 5" = ("f", ["1+2", "3", "4", "5"])
=ENDDOC
=DOC
val ‚mk_simple_abs· : (TERM * TERM) -> TERM;
=DESCRIBE
This produces a term with an abstraction's structure.
It may only abstract variables.
=FAILURE
3007	An abstraction must have a variable as its first argument.
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised
=SEEALSO
$mk\_abs$
=ENDDOC
=DOC
val ‚dest_simple_abs·: TERM -> (TERM * TERM);
=DESCRIBE
Destroys a term with an abstraction's structure.
It cannot destroy paired abstractions, being a inverse of $mk\_simple\_abs$.
=FAILURE
3011	Term is not an abstraction
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=SEEALSO
$dest\_abs$
=ENDDOC
=DOC
val ‚is_simple_abs· : TERM -> bool;
=DESCRIBE
This function returns true iff. the term has a variable abstraction's structure.
=SEEALSO
$is\_abs$
=ENDDOC
=DOC
val ‚list_mk_simple_abs· : (TERM list * TERM) -> TERM;
=DESCRIBE
ÛDefinition
list_mk_simple_abs (["a","b","c",...], "body") = ç a b c ... é body
Ê
This function will be implemented using $mk\_simple\_abs$, not $mk\_abs$.
=FAILUREC
\paragraph{Failure}
May give rise to the error message from $mk\_simple\_abs$.
=SEEALSO
$list\_mk\_abs$
=ENDDOC
=DOC
val ‚TERM_eq· : (TERM * TERM) -> bool;
=DESCRIBE
The standard equality function upon terms.
=ENDDOC
=DOC
val ‚icl'frees· : TERM -> (string * TYPE) list;
=DESCRIBE
Extract the free term variables within the term argument,
presenting them as destroyed variables.
=USES
For when we know the free variables are to be destroyed to use them.
This function is faster than $frees$.
=FAILURE
3064	DESIGN ERROR : applied to ill-formed term
=SEEALSO
$frees$
=ENDDOC
=DOC
val ‚frees· : TERM -> TERM list;
=DESCRIBE
Extract the free term variables within the term argument.
=SEEALSO
$dest\_frees$
=ENDDOC
=DOC
val ‚is_free_var_in· : (string * TYPE) -> TERM -> bool;
=DESCRIBE
Given a destroyed term variable, checks to see if it is free within the term supplied as a second argument.
=ENDDOC
\subsection{Derived Term Structure Functions}
\subsubsection{Generic Derived Term Structure Functions}
A performance issue arises with the destructor functions for
derived term constructors: need they test the types of constants?
We do not make this test. It is not necessary if the
definition of two constants with the same name is
disallowed.
=DOC
val ‚mk_bin_op· : string -> int -> (TYPE -> TYPE -> TERM) ->
	(TERM * TERM) -> TERM;
=DESCRIBE
$mk\_bin\_op$ $area$ $msg$ $rator$ $(tm_1, tm_2)$ attempts to form the term $tm_1\ rator'\ tm_2$.
$rator'$ is gained by applying $rator$ to the types of $tm_1$ and $tm_2$.
=FAILUREC
\paragraph{Failure}
The failure message for failing to apply $rator$ to its arguments will be from area $area$, and will have the text indexed by $msg$.
=ENDDOC
=DOC
val ‚dest_bin_op· : string -> int -> string -> TERM -> (TERM * TERM);
=DESCRIBE
$dest\_bin\_op$ $area$ $msg$ $rator$ $term$ assumes that $term$ is of the form $tm_1\ rator\ tm_2$, and attempts to return $tm_1$ and
$tm_2$.
=FAILUREC
\paragraph{Failure}
The failure message for failing to apply $rator$ to its arguments will be from area $area$, and will have the text indexed by $msg$.
=ENDDOC
=DOC
val ‚is_bin_op· : (TERM -> 'a) -> TERM -> bool;
=DESCRIBE
$is\_bin\_op$ $dest$ $term$ is true iff. $dest$ can be applied to $term$ without a catchable exception being raised.
=ENDDOC
=DOC
val ‚list_mk_bin_op· : string -> int -> 
	(TYPE -> TYPE -> TERM) -> TERM list -> TERM;
=DESCRIBE
This function combines a list of terms using the given operator.
Notice the bracketing in the example.
=EXAMPLE
list_mk_bin_op "Ä" [a, (b Ä c), d] = (a Ä ((b Ä c) Ä d))
=FAILURE
3017	An empty list argument is not allowed
=FAILUREC
\paragraph{Failure}
The failure message for failing to combine its arguments will be from area $area$, and will have the text indexed by $msg$.
If given an empty list the error will be from area $area$, but with message 3017.
=ENDDOC
=DOC
val ‚strip_bin_op· : string -> TERM -> TERM list
=DESCRIBE
This function strips a binary operator, attempting to destroy its term argument, and recursively stripping to the right.
A test not formed from the operator is returned unchanged,
as a singleton list.
=EXAMPLE
strip_bin_op "Ä" (a Ä (b Ä c) Ä d) = [a, (b Ä c), d]
=ENDDOC
=DOC
val ‚mk_mon_op· : string -> int -> (TYPE -> TERM) ->
	TERM -> TERM;
=DESCRIBE
$mk\_mon\_op$ $area$ $msg$ $rator$ $rand$ attempts to form the term $rator'\ rand$.
$rator'$ is gained by applying $rator$ to the type of $rand$.
=FAILUREC
\paragraph{Failure}
The failure message for failing to apply $rator$ to its arguments will be from area $area$, and will have the text indexed by $msg$.
=ENDDOC
=DOC
val ‚dest_mon_op· : string -> int -> string -> TERM -> TERM;
=DESCRIBE
$dest\_mon\_op$ $area$ $msg$ $rator$ $term$ assumes that $term$ is of the form $rator\ term$, and attempts to return $term$.
=FAILUREC
\paragraph{Failure}
The failure message for failing to apply $rator$ to its argument will be from area $area$, and will have the text indexed by $msg$.
=ENDDOC
=DOC
val ‚is_mon_op· : (TERM -> 'a) -> TERM -> bool;
=DESCRIBE
$is\_mon\_op$ $dest$ $term$ is true iff. $dest$ can be applied to $term$ without a catchable exception being raised.
=ENDDOC
=DOC
val ‚mk_simple_binder· : string -> int -> (TYPE -> TYPE -> TERM) ->
	(TERM * TERM) -> TERM;
=DESCRIBE
$mk\_binder$ $area$ $msg$ $binder$ $(var,\ body)$ generates the term:
$binder(ç var\ é\ body)$.
The $var$ must be a term variable.
=FAILUREC
\paragraph{Failure}
If the term cannot be made, then the error will be from $area$, with a message indexed by $msg$.
=ENDDOC
=DOC
val ‚dest_simple_binder· : string -> int -> string -> TERM -> TERM * TERM;
=DESCRIBE
$dest\_binder$ $area$ $msg$ $binder$ $"binder(ç var é body)"$
will give $(var,\ body)$.
=FAILUREC
\paragraph{Failure}
If the term cannot be destroyed, then the error will be from $area$, with a message indexed by $msg$.
=ENDDOC
=DOC
val ‚is_simple_binder· : (TERM -> 'a) -> TERM -> bool;
=DESCRIBE
$is\_simple_binder$ $dest$ $term$ returns true iff. $dest$ can be applied to $term$ without raising a catchable exception.
=ENDDOC
=DOC
val ‚bin_bool_op· : string -> TYPE -> TYPE -> TERM;
=DESCRIBE
Returns a constant with the given name, and type $:BOOL\ ã\ BOOL\ ã\ BOOL$.
The type arguments are dummies.
=ENDDOC
\subsubsection{Specific Derived Term Structure Functions}
=DOC
val ‚equality· : TYPE -> TYPE -> TERM;
=DESCRIBE
Returns the constant "=" upon terms with the first type argument.
The second type is a dummy argument.
=ENDDOC
=DOC
val ‚mk_eq· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating equalities.
=FAILURE
3013	Equality is only between terms of same type
=ENDDOC
=DOC
val ‚dest_eq· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for equalities.
=FAILURE
3014	Term is not an equation.
=ENDDOC
=DOC
val ‚is_eq· : TERM -> bool;
=DESCRIBE
A derived term test for equalities.
=ENDDOC
=DOC
val ‚mk_imp· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating implications.
=FAILURE
3015	Implications are only between boolean terms
=ENDDOC
=DOC
val ‚dest_imp· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for implications.
=FAILURE
3016	Term is not an implication
=ENDDOC
=DOC
val ‚is_imp· : TERM -> bool;
=DESCRIBE
A derived term test for implications.
=ENDDOC
The following could alternatively have the signature $:(TERM\ list) * TERM -> TERM$.
=DOC
val ‚list_mk_imp· : TERM list -> TERM;
=DESCRIBE
ÛDefinition
list_mk_imp ["a","b","c",...] = "a ä b ä c ..."
Ê
Note that giving a singleton list containing a non-boolean term will return that term, rather than fail.
=FAILURE
3017	An empty list argument is not allowed
3018	Argument list must be of boolean terms
=ENDDOC
The following could alternatively have the signature $:TERM\ ->\ (TERM\ list) * TERM$
=DOC
val ‚strip_imp· : TERM -> TERM list;
=DESCRIBE
ÛDefinition
strip_imp  "a ä b ä c ..." = ["a","b","c",...]
Ê
Note that stripping a non-boolean term will result in that term, not a fail.
=ENDDOC
=DOC
val ‚quantifier· : string -> TYPE -> TYPE -> TERM;
=DESCRIBE
$quantifier$ $name$ $type$ $dummy$ returns a constant, with the given name, and type $: (type ã BOOL) ã BOOL$.
=ENDDOC
=DOC
val ‚mk_simple_forall· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating foralls.
ÛDefinition
mk_simple_forall (var, body) = É var é body
Ê
$var$ must be a term variable.
=FAILURE
3031	Argument must have the form: (variable, boolean)
=SEEALSO
$mk\_forall$
=ENDDOC
=DOC
val ‚dest_simple_forall· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for foralls.
It cannot destroy paired abstraction foralls, being the inverse of $mk\_simple\_forall$.
=FAILURE
3032	Term is not a simple forall
=ENDDOC
=DOC
val ‚is_simple_forall· : TERM -> bool;
=DESCRIBE
A derived term test for forall, not formed with paired abstractions.
=ENDDOC
=DOC
val ‚list_mk_simple_forall· : TERM list * TERM -> TERM;
=DESCRIBE
ÛDefinition
list_mk_simple_forall ["a","b","c",...] body = "É a b c ... é body"
Ê
This uses $mk\_simple\_forall$ to generate its result.
Note that giving an empty list paired with a non-boolean term will return that term, rather than fail.
=FAILUREC
\paragraph{Failure}
This may give $mk\_simple\_forall$ error messages.
=ENDDOC
=DOC
val ‚mk_simple_exist· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating exists.
ÛDefinition
mk_exist (var, body) = Ñ var é body
Ê
$var$ must be a term variable.
=FAILURE
3031	Argument must have the form: (variable, boolean)
=SEEALSO
$mk\_exist$
=ENDDOC
=DOC
val ‚dest_simple_exist· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for exists.
It cannot destroy paired abstraction exists, being the inverse of $mk\_simple\_exist$.
=FAILURE
3034	Term is not a simple exist
=SEEALSO
$dest\_exist$
=ENDDOC
=DOC
val ‚is_simple_exist· : TERM -> bool;
=DESCRIBE
A derived term test for exist, not formed with paired abstractions.
=ENDDOC
=DOC
val ‚list_mk_simple_exist· : TERM list * TERM -> TERM;
=DESCRIBE
ÛDefinition
list_mk_simple_exist ["a","b","c",...] body = "Ñ a b c ... é body"
Ê
This uses $mk\_simple\_exist$ to generate its result.
Note that giving an empty list paired with a non-boolean term will return that term, rather than fail.
=FAILUREC
\paragraph{Failure}
This may give $mk\_simple\_exist$ error messages.
=ENDDOC
\subsection{Other Term Functions}
=DOC
val ‚aconv· : TERM -> TERM -> bool;
=DESCRIBE
Tests whether two terms are alpha-convertable, that is it only differs by the names of bound variables.
=ENDDOC
=DOC
val ‚icl'variant· : ((string * TYPE) list) -> (string * TYPE) -> string;
=DESCRIBE
$icl'variant$ $vlist$ $(name,\ type)$ returns a string that is a variant of any name in $vlist$ with the associated type $type$.
Variants are formed by repeatedly priming $name$.
Note that $dest\_variant$ $[]$ $(name,\ type)$ gives $name$.
=USES
Somewhat faster than $variant$ if term variables are already destroyed.
=SEEALSO
$variant$
=ENDDOC
=DOC
val ‚icl'subst· : (TERM * (string * TYPE)) list -> TERM -> TERM;
=DESCRIBE
$icl'subst$ $alist$ $term$ returns a term based on $term$, but with with any term variable that may be found in the association list (second of a pair,
in a destroyed form) 
being replaced with the associated term(first of the pair).

Note that the destroyed term variables must have the same types as the term that is to replace them.
=SEEALSO
$var\_subst$, $subst$
=FAILURE
3052	Invalid types in term substitution
=ENDDOC
=DOC
val ‚rename· : (string * TYPE) -> string -> TERM -> TERM;
=DESCRIBE
$rename$ $(oname,\ type)$ $cname$ $term$ returns a term based on $term$, but with any free variables with name $oname$, and type $type$ renamed to $cname$.
=ENDDOC
=DOC
val ‚icl'inst· : (string * TYPE) list -> (TYPE * string) list -> TERM -> TERM;
=DESCRIBE
$icl'inst$ $alist$ $slist$ $term$ instantiates the type variables of $term$ with the associated types found in $slist$ (which is indexed by the type variable's name, not the type variables themselves).
It will rename bound variables as necessary to prevent name capture problems.
It will also rename variables to avoid them becoming the same as those in the avoidance list, $alist$.
=USES
Somewhat faster than $inst$ if type variables are already destroyed.
=SEEALSO
$inst$
=ENDDOC
=DOC
val ‚term_types· : TERM -> TYPE list;
=DESCRIBE
Gives a list of all the types of constants, variables or abstraction variables within the term argument.
=ENDDOC
=DOC
val ‚term_tyvars· : TERM -> string list;
=DESCRIBE
Returns the list of type variable names present in types present within a term.
=ENDDOC
=DOC
val ‚term_constants· : TERM -> (string * TYPE) list;
=DESCRIBE
This function extracts the subterms of a term which
are constants, giving destroyed constants in each case.
=ENDDOC
=DOC
val ‚type_match· : TYPE -> TYPE -> (TYPE * TYPE)list;
=DESCRIBE
$type\_match$ $ty_1$ $ty_2$ attempts to find if $ty_1$ is an instance of $ty_2$.
If so, then it returns a list giving the correspondence between
types in $ty_1$ with type variables in $ty_2$.
Trivial (i.e. (x,x)) correspondences are not noted.
=FAILURE
3053	The first type is not an instance of the second
=ENDDOC
=DOC
val ‚term_match· : TERM -> TERM -> (TYPE * TYPE) list * (TERM * TERM)list;
=DESCRIBE
$term\_match$ $tm_1$ $tm_2$ attempts to find if $tm_1$ is an instance of $tm_2$.
If so, then it returns two list.
The first gives the correspondence between types in $tm_1$ with type variables in $tm_2$.
The second gives the correspondence between (type instantiated) terms in $tm_1$ with free variables in $tm_2$.
Trivial (i.e. (x,x)) correspondences are not noted.
=FAILURE
3054	The first term is not an instance of the second
=ENDDOC
=DOC
val ‚is_type_instance· : TYPE -> TYPE -> bool;
=DESCRIBE
$is\_type\_instance$ $ty_1$ $ty_2$ returns true iff $ty_1$ is an instance of $ty_2$.
=ENDDOC
=DOC
val ‚genvar· : TYPE -> TERM;
=DESCRIBE
Each application of $gen\_var$ returns a variable whose
is different from that returned by any other application.
The variable name starts with a space so that the variable
name will also be different from that of any variable
constructed with $mk\_var$. 
=ENDDOC
=DOC
val ‚mk_var· : (string * TYPE) -> TERM;
=DESCRIBE
If the string is non-empty, and doesn't contain spaces, then a HOL term variable is formed in the obvious way from the argument.
=FAILURE
3055	Variable name `?0' must be non-empty and must not contain 
	spaces or control characters
=ENDDOC
=DOC
val ‚variant· : TERM list -> TERM -> TERM;
=DESCRIBE
$variant$ $stoplist$ $v$ returns a variant of variable $v$ that is not present in the $stoplist$.
The variants are generated by sufficient priming.
=FAILURE
3056	Can only give a variant of a variable
3057	First argument is not a list of term variables
=SEEALSO
$icl'variant$
=ENDDOC
=DOC
val ‚list_variant· : TERM list -> TERM list -> TERM list;
=DESCRIBE
$list\_variant$ $stoplist$ $vlist$ returns a list of variants that are not present in the $stoplist$, nor contain any duplicates, one for each member of $vlist$.
The variants are generated by sufficient priming.
=FAILUREC
\paragraph{Failure}
The function may give rise to errors from $variant$.
=ENDDOC
=DOC
val ‚is_free_in· : TERM -> TERM -> bool;
=DESCRIBE
$is\_free\_in$ $v$ $term$ is true iff. $v$ is a free variable in
$term$.
=ENDDOC
=DOC
val ‚frees· : TERM -> TERM list;
=DESCRIBE
Lists the free variables of a term.
=ENDDOC
=DOC
val ‚var_subst· : (TERM * TERM) list -> TERM -> TERM;
=DESCRIBE
$var\_subst$ $alist$ $term$ returns the term formed by, for each pair in $alist$, substituting in $term$ all instances of the term variable which is the second of the pair with the first of the pair.

Note that the term variables must have the same types as the term that is to replace them.
=FAILURE
3060	The second of each pair in the substitution list must be a term variable
=SEEALSO
$icl'subst$, $subst$
=ENDDOC
=DOC
val ‚subst· : (TERM * TERM) list -> TERM -> TERM;
=DESCRIBE
$subst$ $alist$ $term$ returns the term formed by, for each pair in $alist$, substituting in $term$ all instances of the term which is the first of the pair with the second of the pair.
=SEEALSO
$icl'subst$, $var\_subst$
=ENDDOC
=DOC
val ‚TERM_map· : ((TERM list) -> TERM -> TERM) -> TERM -> TERM;
=DESCRIBE
$TERM\_map$ $tmfun$ $tm$ traverses
$tm$ (breadth first) looking for subterms for which
the application $tmfun\,tm$ does not fail and replaces
such subterms with $tmfun\,tm$. $tmfun$ has as its first argument a list giving
the bound variables which are in scope at the point of use.
It does not attempt to apply $tmfun$ to a bound variable of an abstraction.
=ENDDOC
=DOC
val ‚inst· : TERM list -> (TYPE * TYPE) list -> TERM -> TERM;
=DESCRIBE
$inst$ $alist$ $slist$ $term$ instantiates the type variables of $term$ with the associated types found in $slist$.
An element of $slist$ will be ($return$, $tv$),
where $tv$ is a type variable that is to be instantiated to $return$.
It will rename bound variables as necessary to prevent name capture problems.
It will also not allow variables to become the same as those in the avoidance list, $alist$.
=FAILURE
3061	First argument must be a list of term variables
3062	Second argument must be a list of (TYPE * type variables)
=ENDDOC
=SML
end(* signature of icl'TypesAndTerms *);
=TEX
\section{TESTING}

=IGN
Minimum printing:
=IGN
fun flat_strings ss = implode(flat (map explode ss));

fun print_TYPE t = 
let
	fun aux (mk_vartype s) = " " ^ s
	| aux (mk_type ("->",[t1,t2])) = (
		"(" ^ aux t1 ^ "ã" ^ aux t2 ^")"
	) | aux (mk_type (c,tl)) = "((" ^ flat_strings (map ((fn x => x ^", ") o aux) tl)^ ")" ^ c ^ ")"
in
	":" ^ aux t
end;

fun print_TERM (tm: TERM) =
let fun print_DEST_TERM (Comb(t1,t2)) = (
	"Comb (" ^ print_DEST_TERM(dest_TERM t1) ^", " ^
		print_DEST_TERM(dest_TERM t2) ^ ")"
) | print_DEST_TERM (Const(s,ty)) = s ^ print_TYPE ty
| print_DEST_TERM (Var(s,ty)) = s ^ print_TYPE ty
| print_DEST_TERM (Abs(v,b)) = (
	let val (vs,vt) = dest_var v
	in
	"ç " ^ vs ^ print_TYPE vt ^ " é " ^ print_DEST_TERM (dest_TERM b)
	end);
in
	print_DEST_TERM (dest_TERM tm)
end;
=IGN
infix 6 cross;
fun t1 cross t2 = mk_type("â",[t1,t2]);
val BB = BOOL cross BOOL;
print_TYPE BB;
val BtoB = mk_fun(BOOL, BOOL);
print_TYPE BtoB;
dest_type BB;
mk_type(dest_type BB) = BB;
val tv1 = mk_vartype "'tv1";
val tv2 = mk_vartype "'tv2";
val tv3 = mk_vartype "'tv3";
print_TYPE tv1;
dest_type tv1;
infix 6 comma;
fun t1 comma t2 = mk_const(",", (mk_fun(t1,mk_fun(t2,(t1 cross t2)))));
val Comma = tv1 comma tv2;
mk_TERM (Comb(mk_var("v",BB),vtv1));
mk_TERM (Comb(mk_var("v",BtoB),vtv1));
print_TERM Comma;
print_TYPE(type_of Comma);
val ist = icl'inst_type [(BOOL, "'tv1"),(BB,"'tv3")];
print_TYPE(ist tv1);
print_TYPE(ist tv2);
print_TYPE(ist tv3);
print_TYPE(ist (tv1 cross tv2));
print_TYPE(ist (tv3 cross tv2));
type_tycons(type_of Comma);
type_tycons (ist (tv1 cross tv2));
type_tyvars(type_of Comma);
type_tyvars (ist (tv1 cross tv2));
dest_TERM Comma;
val c1 = mk_const("c1",BOOL);
val c2 = mk_const("c2",mk_type("triple",[tv1,tv2,tv3]));
val c3 = mk_const("c3",mk_type("triple",[tv3,BOOL,tv1]));
val c4 = mk_const("c4",mk_fun(BOOL,mk_fun(tv2,tv3)));
val c5 = mk_const("c5",mk_fun(tv1,mk_fun(tv2,BOOL)));
val c6 = mk_const("c6",mk_fun(tv1,mk_fun(tv2,mk_fun(tv3,
	mk_type("triple",[tv1,tv2,tv3])))));
mk_const(" wrong",BOOL);
map print_TERM [c1, c2, c3, c4, c5, c6];
val v1 = mk_var("v1",BOOL);
val v2 = mk_var("v2",mk_type("triple",[tv1,tv2,tv3]));
val v3 = mk_var("v2",mk_type("triple",[tv3,BOOL,tv1]));
val iv1 = icl'mk_var(" a b c = F",tv1);
val iv2 = icl'mk_var(" a b c = T",BOOL);
map print_TERM [iv1, iv2];
mk_var(" a b c = F",tv1);
mk_var(" a b c = T",BOOL);

val vtv1 = mk_var("vtv1",tv1);
val vtv2 = mk_var("vtv2",tv2);
val vtv3 = mk_var("vtv3",tv3);
val cm1 = mk_comb(c6,vtv1);
val cm2 = mk_comb(cm1,vtv2);
val cm3 = mk_comb(cm2,vtv3);
mk_comb(mk_var("v",BB),vtv1);
mk_comb(mk_var("v",BtoB),vtv1);
map print_TERM [cm1, cm2, cm3];
val a1 = mk_simple_abs(v1, cm3);
val a2 = mk_simple_abs(v2,v2);
val a3 = mk_simple_abs(genvar tv1, c2);
val a4 = mk_simple_abs(iv1, c2);
map print_TERM [a1, a2, a3, a4];
mk_simple_abs(c1, c1);
type_of cm3;
dest_const(c3);
dest_TERM c3;
dest_const vtv1;
dest_comb cm3;
dest_TERM cm3;
fun DEST_TERM_id x = ((mk_TERM (dest_TERM x)) TERM_eq x);
map DEST_TERM_id [c1, c2, c3, c4, c5, c6, v1, v2, v3,
	cm1, cm2, cm3, a1, a2, a3, iv1, iv2, a4];
dest_var iv1; dest_var v1; dest_var c1; 
is_var iv1; is_var v1; is_var c1; is_var cm1; is_var a1;
dest_const c1; dest_const v1;
is_const c1; is_const v1;
dest_comb v1;
list_mk_comb (c6, [vtv1, vtv2, vtv3]) TERM_eq cm3;
list_mk_comb (c6,[]) TERM_eq c6;
strip_comb cm3;
dest_simple_abs a1; dest_simple_abs a4; dest_simple_abs v1;
is_simple_abs a1; is_simple_abs v1;
print_TERM (list_mk_simple_abs ([vtv1, vtv2, vtv3], c6));
list_mk_simple_abs ([],c6) TERM_eq c6;
icl'frees cm3;
icl'frees (mk_simple_abs(vtv2, cm3));
map (op TERM_eq) (combine (frees cm3) (map mk_var (icl'frees cm3)));
is_free_var_in (dest_var vtv1) cm3; 
is_free_var_in (dest_var vtv1)
	(list_mk_simple_abs ([vtv1, vtv2, vtv3], c6));
val eq1 = mk_eq(c1,c1); 
mk_eq(c1, c2);
dest_eq c1;
(dest_const ** dest_const)(dest_eq eq1);
is_eq eq1; is_eq c1;
val T = mk_const("T",BOOL); val F = mk_const("F",BOOL);
val imp1 = (mk_imp(F,T));
mk_imp(c2,c3);
dest_imp c1;
is_imp imp1;
(dest_const ** dest_const)(dest_imp imp1);
list_mk_imp[];
list_mk_imp[vtv1, vtv2];
strip_imp(list_mk_imp[T,F,T,F]);
print_TERM (mk_simple_forall(vtv1, c1));
(print_TERM ** print_TERM) (dest_simple_forall(mk_simple_forall(vtv1, c1)));
mk_simple_forall(c1,c1);
dest_simple_forall c1;
is_simple_forall(mk_simple_forall(vtv1, c1));
is_simple_forall c1;
print_TERM(list_mk_simple_forall([vtv1, vtv2], c1));
(print_TERM ** print_TERM) (dest_simple_exist(mk_simple_exist(vtv1,c1)));
print_TERM(list_mk_simple_exist([vtv1, vtv2], c1));
dest_simple_exist c1;
aconv vtv1 c1;
aconv vtv1 vtv1;
aconv (mk_simple_abs(mk_var ("A",BOOL),c1)) 
	(mk_simple_abs(mk_var ("B",BOOL),c1)); 
aconv (mk_simple_abs(vtv1, vtv1) )
	(mk_simple_abs(mk_var ("'ntv1",tv1),vtv1)); 
icl'variant [] (dest_var vtv1);
icl'variant [(dest_var vtv1)] (dest_var vtv1);
icl'variant [(dest_var vtv1),(("vtv1'",tv1))] (dest_var vtv1);
icl'variant [("vtv1",tv2)] (dest_var vtv1);
(icl'subst [(T,("vtv1",tv2))] c1);
print_TERM (icl'subst [(T,("v1",BOOL))] c1);
print_TERM (icl'subst [(T,("v1",BOOL)),(F,("v2",BOOL))] (v1));
print_TERM (icl'subst [(T,("v1",BOOL)),(F,("v2",BOOL))] (mk_var("v2",BOOL)));
print_TERM (icl'subst [(T,("v1",BOOL)),(F,("v2",BOOL))] (mk_simple_exist(mk_var("v2",BOOL), mk_var("v2",BOOL))));
print_TERM (icl'subst [(T,("v1",BOOL)),(F,("v2",BOOL))] (mk_simple_forall(mk_var("v2",BOOL), v1)));
print_TERM(rename ("v1",BOOL) "renamed_v1"
	(mk_simple_exist(v1, mk_var("v2",BOOL))));
print_TERM(rename ("v1",BOOL) "renamed_v1"
	(mk_simple_exist(mk_var("v2",BOOL), v1)));
print_TERM(rename ("v1",tv1) "renamed_v1"
	(mk_simple_exist(mk_var("v2",BOOL), v1)));
print_TERM (icl'inst [("av1",tv1),("av2",tv2)]
	[(BOOL,"'tv1"),(tv1,"'tv2")]
	cm3);
print_TERM (icl'inst [("av1",tv1),("av2",tv2)]
	[(BOOL,"'tv1"),(tv1,"'tv2")]
	(rename ("vtv2",tv2) "av1" cm3));
map print_TYPE (term_types cm3);
(term_tyvars cm3);
term_constants cm3;
type_match BOOL tv1;
type_match BOOL BB;
type_match (mk_fun(tv1,mk_fun(tv2,tv1))) (mk_fun(tv2,mk_fun(tv1,tv2)));
type_match (mk_fun(tv2,mk_fun(tv2,tv2))) (mk_fun(tv1,mk_fun(tv2,tv1))) ;
type_match (mk_fun(BOOL,mk_fun(tv2,BB))) (mk_fun(tv1,mk_fun(tv2,tv1))) ;
(map (print_TYPE ** print_TYPE) ** map (print_TERM ** print_TERM)) (term_match v1 v1);
(map (print_TYPE ** print_TYPE) ** map (print_TERM ** print_TERM)) (term_match v2 vtv1);
(map (print_TYPE ** print_TYPE) ** map (print_TERM ** print_TERM)) (term_match 
	(list_mk_comb ((mk_const("trio",mk_fun(BOOL,mk_fun(tv2,mk_fun(tv3, (BOOL cross tv2)))))) ,
	[v1, vtv2,vtv3]))
	(list_mk_comb ((mk_const("trio",mk_fun(tv1,mk_fun(tv2,mk_fun(tv3, (tv1 cross tv2)))))),
	[vtv1, vtv2,vtv3])));
(map (print_TYPE ** print_TYPE) ** map (print_TERM ** print_TERM)) (term_match 
	(list_mk_comb ((mk_const("trio",mk_fun(BOOL,mk_fun(tv2,mk_fun(tv3, (BB cross tv2)))))) ,
	[v1, vtv2,vtv3]))
	(list_mk_comb ((mk_const("trio",mk_fun(tv1,mk_fun(tv2,mk_fun(tv3, (tv1 cross tv2)))))),
	[vtv1, vtv2,vtv3])));
print_TERM (genvar BOOL);print_TERM (genvar BOOL);print_TERM (genvar BOOL);
mk_var(dest_var (genvar BOOL));
(variant[c1]vtv1);
print_TERM(variant [] vtv1);
print_TERM(variant [] c1);
print_TERM(variant [vtv1] vtv1);
print_TERM(variant [vtv1,(mk_var("vtv1'",tv1))] vtv1);
print_TERM(variant [mk_var("vtv1",tv2)] vtv1);
print_TERM(variant [mk_var("vtv1",tv2)] vtv1);
map print_TERM(list_variant[vtv1,(mk_var("vtv1'",tv1))]
	[(mk_var("vtv1'",tv1)), vtv1]);
is_free_in vtv1 vtv1;
is_free_in vtv1 (mk_simple_abs(vtv1, vtv1));
map print_TERM (frees cm3);
map print_TERM (frees (mk_simple_abs(vtv2, cm3)));
(var_subst [(T,c1)] c1);
print_TERM (var_subst [(T,v1)] c1);
print_TERM (var_subst [(T,v1),(F,mk_var("v2",BOOL))] (v1));
print_TERM (var_subst [(T,v1),(F,mk_var("v2",BOOL))] (mk_var("v2",BOOL)));
print_TERM (var_subst [(T,v1),(F,mk_var("v2",BOOL))] (mk_simple_exist(mk_var("v2",BOOL), mk_var("v2",BOOL))));
print_TERM (var_subst [(T,v1),(F,mk_var("v2",BOOL))] (mk_simple_forall(mk_var("v2",BOOL), v1)));
print_TERM (subst [(v1,mk_imp(T,F))] (list_mk_imp[T,F,T,F]));
print_TERM (inst [mk_var("av1",tv1),mk_var("av2",tv2)]
	[(BOOL,tv1),(tv1,tv2)]
	cm3);
print_TERM (inst [mk_var("av1",tv1),mk_var("av2",tv2)]
	[(BOOL,tv1),(tv1,tv2)]
	(rename ("vtv2",tv2) "av1" cm3));
print_TERM (inst [c1,mk_var("av2",tv2)]
	[(BOOL,tv1),(tv1,tv2)]
	(rename ("vtv2",tv2) "av1" cm3));
print_TERM (inst [mk_var("av1",tv1),mk_var("av2",tv2)]
	[(BOOL,BB),(tv1,tv2)]
	(rename ("vtv2",tv2) "av1" cm3));
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
