%  dtd003.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design for Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for Types and Terms}
\TPPref{DS/FMU/IED/DTD003}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the types of HOL terms and types, namely $TERM$ and $TYPE$. It then gives some functions upon these.
There will be sufficient functions upon $TERM$ to define the type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
Based on the first part of DS/FMU/IED/SML002.
\item [Issue 1.2]
Many changes while deciding upon a format.
\item [Issues 1.3, 1.4]
Changes made during writing implementation.
\item [Issue 1.5]
Names made pretty were appropriate, using material of \cite{DS/FMU/IED/DTD005}.
\item [Issue 1.6]
Added $term\_any$, $type\_any$, $term\_type\_constructors$, $dest\_vartype$, $is\_vartype$.
Acted upon section 7 of issue 1.3 of \cite{DS/FMU/IED/WRK015}.
\item [Issue 1.7]
Modified error messages to match current version of doc4errors.
Added some minor descriptions, to get format correct.
\item [Issue 1.8]
Changed $TYPE$ to have hidden data constructors,
removed need for $TERM\_eq$.
Improved error messages.
\item [Issue 1.9]
Made the use of $simple\_$ more helpful, also applying it
 to changing $DEST\_TERM$ to $SIMPLE\_DEST\_TERM$.
Some minor tidying of names and descriptions.
\item [Issue 1.10]
Addition of functions :$?\_Ü$, $?\_char$ and $?\_string$;
and the types $Ü$, $CHAR$ and $STRING$.
\item [Issue 1.11]
Added error messages to $is\_free\_in$, $var\_subst$ and $subst$.
\item [Issue 1.12]
Added $set\_variant\_string$; 
modified $string_variant$ by this, and ignoring types.
Added $term\_fail$ and $type\_fail$.
\item [Issue 1.13]
Added functions on lists of terms, seen as sets under $\alpha$-convertible.
\item [Issue 1.14]
Stated ordering on the assorted $subst$ functions.
\item [Issue 1.15]
Stated ordering on the results of $icl'frees$ and $frees$.
Added $inst\_type$.
The prefix $simple$ is moved to being the first prefix, bar $icl'$.
\item [Issue 1.16]
Add specification of numeric, string and character literal formats.
\item [Issue 1.17]
Fixed some typos.
\item [Issue 1.18,1.19,1.20]
Changes in response to inspection IR0016.
\end{description}
\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design of the types and terms of ICL HOL, and functions to handle them, called for by the first point of section 4.2 of the Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004},
and the high level design \cite{DS/FMU/IED/HLD007}.
The high-level specification for the code may be considered
to be given in \cite{DS/FMU/IED/SPC001}.
The design is
implemented in \cite{DS/FMU/IED/IMP003}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design of the types and terms of ICL HOL, and functions to handle them.
There will be sufficient functions provided to define the type $THM$.
\subsubsection{Dependencies}
The code in this document depends upon the material in
\cite{DS/FMU/IED/IMP001}.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}

\subsubsection{Terminology}
In may be necessary when using the following terminology to remove ambiguity by prefixing some of the following with the word ``term'' or ``HOL'', to constrast with 
Standard ML terminology, or, for instance, theorems
whose conclusions are describable in the same terms.

\begin{tabular}{p{1.3in} p{4.9in}}
type variable & A HOL type formed by $mk\_vartype$. \\
compound type & A HOL type formed by $mk\_ctype$: a type constructor applied to sufficent types. \\
function type & A HOL type formed by $mk\_ã\_type$: the
type of HOL functions. \\
constant & A term formed by $mk\_const$. \\
variable & A term formed by $mk\_var$. \\
application & A term of the form $ªf\ tº$, as constructed by $mk\_app$
: the application of a function to an argument. \\
binder & A term constant which has, in the current context, the
 status of ``binder'' (see, e.g., $declare\_binder$). The class includes $ª\$Éº$ and $ª\$Ñº$.\\
$ç$-abstraction & A term of the form $ªç\ x\ é\ f[x]º$,
as constructed by $simple\_mk\_ç$ or $mk\_ç$,
or of the form $ªç\ (x,y)\ é\ f[x,y]º$, as constructed by $mk\_ç$. \\
simple abstraction & A term of the form $ªB\ x\ é\ f[x]º$
where $B$ is a binder or $ç$, and $x$ a simple variable. \\
paired abstraction & Either a simple abstraction, or
a term of the form $ªB\ (x,y)\ é\ f[x,y]º$
where $B$ is a binder or $ç$, and $(x,y)$ any variable structure allowed by the concrete syntax. \\
abstraction & A paired abstraction, used where the word ``paired'' may be dropped without ambiguity. \\
equation & A term of the form $ªx\ =\ yº$ or $ªx\ Ç\ yº$,
as constructed by $mk\_eq$. The class includes bi-implications. \\
implication & A term of the form $ªx\ ä\ yº$, as constructed by $mk\_ä$. \\
$É$-term & A universally quantified term of the form $ªÉ\ x\ é\ P[x]º$, as constructed by $simple\_mk\_É$ or $mk\_É$,
or a term of the form $ªÉ\ (x,y)\ é\ P[x,y]º$, as constructed by $mk\_É$. \\
$Ñ$-term & An existentially quantified term of the form $ªÑ\ x\ é\ P[x]º$, as constructed by $simple\_mk\_Ñ$ or $mk\_Ñ$,
or a term of the form $ªÑ\ (x,y)\ é\ P[x,y]º$, as constructed by $mk\_Ñ$. \\
numeric literal & A constant of the form $ª0º$, $ª1º$,..., as constructed by $mk\_Ü$. \\
character literal & A constant of the form  $ª`a`º$, $ª`b`º$,..., as constructed by $mk\_char$. \\
string literal & A constant of the form $ª""º$, $ª"a"º$, $ª"ab"º$,..., as constructed by $mk\_string$. \\
\end{tabular}

=TEX
\section{INFIX DIRECTIVES}
=SML
infix 4 term_mem;
infix 4 term_less;
infix 4 term_grab;
infix 4 term_union;
=TEX
\section{TYPES AND TERMS}
=DOC
signature ‚icl'TypesAndTerms· = sig
=DESCRIBE
This provides the type of ICL HOL types: $TYPE$, of ICL HOL terms: $TERM$, and some functions upon them.
A user should access all the elements of this signature through signature $DerivedTerms$ (q.v).
=FAILURE
3064	DESIGN ERROR : applied to ill-formed term
=FAILUREC
This error message indicates that a term has been encountered that the abstract data type for $TERM$ thought incapable of formation.
A number of functions make use of this message to indicate this ``impossible'' condition.
=ENDDOC
\subsection{The Type: $TYPE$}
=DOC
eqtype ‚TYPE·;
=DESCRIBE
All ICL HOL terms will be ``typed'', by associating them with
an object of type $TYPE$.
A type may either be a type variable or a compound type.

This is an equality type (i.e. $=$ may be used to test for equality).
=ENDDOC
\subsection{Constructors and Destructors of the Type $TYPE$}
\subsubsection{Simple Destroyed Types}
=DOC
datatype ‚SIMPLE_DEST_TYPE· = ‚Vartype· of string |
	‚Ctype· of (string * TYPE list);
=DESCRIBE
This is the type of simple destroyed types, related to the type $TYPE$ by
$simple\_dest\_type$(q.v) and $simple\_mk\_type$(q.v.). 
=ENDDOC
=DOC
val ‚simple_dest_type· : TYPE -> SIMPLE_DEST_TYPE;
=DESCRIBE
This function destroys a HOL type into something of type $SIMPLE\_DEST\_TYPE$ (q.v).
=ENDDOC
=DOC
val ‚simple_mk_type· : SIMPLE_DEST_TYPE -> TYPE;
=DESCRIBE
This function constructs a HOL type from something of type $SIMPLE\_DEST\_TYPE$ (q.v).
=ENDDOC

=SEEALSO
\subsubsection{Compound Types}
=DOC
val ‚mk_ctype· : string * TYPE list -> TYPE;
=DESCRIBE
Create a compound type from a type constructor and sufficient
arguments.
The function makes no checks against the declaration or
arity of the type constructor or the type arguments: see $get\_type\_info$ (q.v.).
ÛDefinition
mk_ctype ("tc", [ty1,ty2,...]) = ª:(ty1,ty2,...)tcº
mk_ctype ("tc", [ty]) = ª:ty tcº
mk_ctype ("tc", []) = ª:tcº
Ê
=ENDDOC
=DOC
val ‚dest_ctype· : TYPE -> string * TYPE list;
=DESCRIBE
Extract the components of a compound type.
ÛDefinition
dest_ctype ª:(ty1,ty2,...)tcº = ("tc", [ty1,ty2,...])
dest_ctype ª:ty tcº = ("tc", [ty])
dest_ctype ª:tcº = ("tc", [])
Ê
=FAILURE
3001	?0 is not a compound type
=ENDDOC
=DOC
val ‚is_ctype· : TYPE -> bool;
=DESCRIBE
Is the type a compound type? If it isn't then it must be a type variable.
=ENDDOC
\subsubsection{Type Variables}
=DOC
val ‚mk_vartype· : string -> TYPE;
=DESCRIBE
Create a HOL type variable from a string:
ÛDefinition
mk_vartype "tv" = ª: tvº
Ê
=ENDDOC
=DOC
val ‚dest_vartype· : TYPE -> string;
=DESCRIBE
Extract the name of a type variable:
ÛDefinition
dest_vartype ª: 'tvº = "'tv"
Ê
=FAILURE
3019	?0 is not a type variable
=ENDDOC
=DOC
val ‚is_vartype· : TYPE -> bool;
=DESCRIBE
Is the type a type variable? If it isn't then it must be a compound type.
=ENDDOC
\subsubsection{Function Types}
The following functions should be used in preference to
the ``ctype'' fucntions when handling function types.
=DOC
val ‚mk_ã_type· : (TYPE * TYPE) -> TYPE;
=DESCRIBE
Create a function type from two types.
A function type is just a kind of compound type.
ÛDefinition
mk_ã_type (ty1, ty2) = mk_ctype("ã",[ty1,ty2]) = ª:ty1 ã ty2º
Ê
=ENDDOC
=DOC
val ‚dest_ã_type· : TYPE -> (TYPE * TYPE);
=DESCRIBE
Given the function type $ª:ty_1\ ã\ ty_2º$, returns $($ty_1$, $ty_2$)$.
ÛDefinition
dest_ã_type ª:ty1 ã ty2º = (ty1, ty2)
Ê
=FAILURE
3022	?0 is not of form: ª:ty1 ã ty2º
=ENDDOC
=DOC
val ‚is_ã_type· : TYPE -> bool;
=DESCRIBE
Is the type a function type, i.e. of form  $ª:ty1\ ã\ ty2º$?
=ENDDOC
\subsection{Functions Upon the Type $TYPE$}
=DOC
val ‚inst_type· : ((TYPE * TYPE) list) -> TYPE -> TYPE;
=DESCRIBE
$inst\_type$ $alist$ $type$ recursively descends through $type$, replacing any type variables by whatever the association list $alist$ associates with them.
If the association list does not contain a type variable found in $type$, then that type variable will not be changed.
Replaced types are {\bf not} recursively processed by this function.
=FAILURE
3019	?0 is not a type variable
=ENDDOC
=DOC
val ‚type_tycons· : TYPE -> (string * int) list;
=DESCRIBE
This returns a list of names of type constructors, and the arity of their use, within a type.
=ENDDOC
=DOC
val ‚type_tyvars· : TYPE -> string list;
=DESCRIBE
Returns the list of type variable names present in a type.
=ENDDOC
=DOC
val ‚type_any· : (TYPE -> bool) -> TYPE -> bool;
=DESCRIBE
Given a predicate on types, tests to see if any sub-type of some type (or the type itself) satisfies the predicate.
The search ceases on the first satisfaction, rather than all the
tests being done and the results combined.
=ENDDOC
=DOC
val ‚type_map· : (TYPE -> TYPE) -> TYPE -> TYPE;
=DESCRIBE
$type\_map$ $tyfun$ $ty$ traverses
$ty$ (breadth first) looking for subtypes, $st$, for which
the application $tyfun\,st$ does not fail and replaces
such subterms with $tyfun\,st$.
It does not traverse the resulting subtypes.
=ENDDOC
=DOC
val ‚BOOL· : TYPE;
=DESCRIBE
The HOL type of truth values:
ÛDefinition
val BOOL = ª:BOOLº;
Ê
=SEEALSO
Theory ``min''.
=ENDDOC
=TEX
\subsection{The Types $TERM$ and $SIMPLE\_DEST\_TERM$}
=DOC
eqtype ‚TERM·;
=DESCRIBE
This is the type of well-formed ICL HOL terms.
Objects of this type are manipulated by term constructor and destructor functions, such as $mk\_app$, $dest\_ç$ and $is\_var$.

This is an equality type (i.e. $=$ may be used to test for equality).
=ENDDOC
=DOC
datatype ‚SIMPLE_DEST_TERM· = ‚Var· of string * TYPE |
	‚Const· of string * TYPE |
	‚App· of TERM * TERM |
	‚Simpleç· of TERM * TERM;
=DESCRIBE
This is the simple type of destroyed terms, related to the type $TERM$ by
$simple\_dest\_term$(q.v) and $simple\_mk\_term$(q.v.).
The four value constructors represented destroyed variables, constants, applications and simple $ç$-abstractions respectively.
=USES
In writing pattern-matching functions upon ICL HOL terms.
=SEEALSO
$DEST\_TERM$.
=ENDDOC
\subsection{Primitive Functions Upon Terms}
=DOC
val ‚simple_dest_term· : TERM -> SIMPLE_DEST_TERM;
=DESCRIBE
An injective function, that destroys a term, returning its 
top-level structure, and the associated constituent parts.
=SEEALSO
$SIMPLE\_DEST\_TERM$
=ENDDOC
=DOC
val ‚simple_mk_term· : SIMPLE_DEST_TERM -> TERM;
=DESCRIBE
Create a well-formed TERM from a statement of a top-level structure, and the associated constituent parts.

This may produce terms that are not well-formed within the context of some theories.
=SEEALSO
$SIMPLE\_DEST\_TERM$
=FAILURE
3005	Cannot apply ?0 to ?1 as types are incompatible
3006	Type of ?0 not of form ª:ty1 ã ty2º 
3007	?0 is not a term variable
=ENDDOC
=DOC
val ‚type_of· : TERM -> TYPE;
=DESCRIBE
This gives the HOL type of a term.
=ENDDOC
\subsection{Primitive Constructors and Destructors of the type $TERM$}
\subsubsection{Term Variables}
=DOC
val ‚mk_var· : (string * TYPE) -> TERM;
=DESCRIBE
This produces a term variable.

The function makes no checks against the declaration of the subtypes of the type supplied.
=ENDDOC
=DOC
val ‚dest_var·: TERM -> (string * TYPE);
=DESCRIBE
This destroys a term variable into its name and type.
=FAILURE
3007	?0 is not a term variable
=ENDDOC
=DOC
val ‚is_var· : TERM -> bool;
=DESCRIBE
Is the term a variable?
=ENDDOC
\subsubsection{Constants}
=DOC
val ‚mk_const· : (string * TYPE) -> TERM;
=DESCRIBE
This produces a term constant.

The function makes no checks against the declaration of the constant, the declaration of the type constructors of the type supplied, or
most general type of the constant name: see $get\_const\_info$ (q.v.).
However it will not form constants whose types clash with those constants required by the implementation of the abstract data type $THM$ (q.v.).
These are $=$, $ä$, $É$, and $Ñ$.
=FAILURE
3002	Type of constant with name "=" must be of form:ªty1 ã ty1 ã BOOLº
3003	Type of constant with name "ä" must be of form:ªBOOL ã BOOL ã BOOLº
3004	Type of constant with name ?0 must be of form:ª(ty1 ã BOOL) ã BOOLº
=ENDDOC
=DOC
val ‚dest_const·: TERM -> (string * TYPE);
=DESCRIBE
This destroys a term constant into its name and type.
=FAILURE
3009	?0 is not a constant
=ENDDOC
=DOC
val ‚is_const· : TERM -> bool;
=DESCRIBE
Is the term a constant?
=ENDDOC
\subsubsection{Applications}
=DOC
val ‚mk_app· : (TERM * TERM) -> TERM;
=DESCRIBE
This produces a function application.
=FAILURE
3005	Cannot apply ?0 to ?1 as types are incompatible
3006	Type of ?0 not of form ª:ty1 ã ty2º 
=ENDDOC
The uses of this function in the parser, etc, should catch 
this functions error messages, and give more meaningful ones.
=DOC
val ‚dest_app·: TERM -> (TERM * TERM);
=DESCRIBE
Destroys a function application into the function and argument.
=FAILURE
3010	?0 is not of form: ªt1 t2º 
=ENDDOC
=DOC
val ‚is_app· : TERM -> bool;
=DESCRIBE
Is the term a function application?
=ENDDOC
=DOC
val ‚list_mk_app· : (TERM * TERM list) -> TERM;
=DESCRIBE
Applies a function to multiple arguments.
ÛDefinition
list_mk_app (ªtº, [ªt1º,ªt2º,ªt3º,...]) = ªt t1 t2 t3 ...º 
Ê
=FAILUREC
\paragraph{Failure}
May give rise to the error message from $mk\_app$.
=ENDDOC
=DOC
val ‚strip_app· : TERM -> TERM * TERM list;
=DESCRIBE
Splits a term into a head term, that is not an application, and the list of argument terms, if any, to which that head term was applied.
=EXAMPLE
strip_app ªt t1 t2 t3 ...º = (ªtº, [ªt1º,ªt2º,ªt3º,...])
strip_app ªTº = (ªTº,[])
=ENDDOC
\subsubsection{Simple ç-abstractions}
As noted in the terminology, ``simple'' is used to denote the
abstraction of a variable from a term.
=DOC
val ‚simple_mk_ç· : (TERM * TERM) -> TERM;
=DESCRIBE
This produces a simple $ç$-abstraction.
It may only abstract variables.
=SEEALSO
$mk\_ç$
=FAILURE
3007	?0 is not a term variable
=ENDDOC
=DOC
val ‚simple_dest_ç·: TERM -> (TERM * TERM);
=DESCRIBE
Destroys a simple $ç$-abstraction.
It cannot destroy paired $ç$-abstractions, being a inverse of $simple\_mk\_ç$.
=SEEALSO
$dest\_ç$
=FAILURE
3011	?0 is not of form: ªç var é tº 
=ENDDOC
=DOC
val ‚simple_is_ç· : TERM -> bool;
=DESCRIBE
Is the term a simple $ç$-abstraction.
=SEEALSO
$is\_ç$
=ENDDOC
=DOC
val ‚simple_list_mk_ç· : (TERM list * TERM) -> TERM;
=DESCRIBE
$ç$-abstract a list of variables from a term.
ÛDefinition
simple_list_mk_ç ([ªx1º,ªx2º,...],ªtº) = ªç x1 x2 ... é tº 
Ê
This function will be implemented using $simple\_mk\_ç$(q.v), not $mk\_ç$.
=SEEALSO
$list\_mk\_ç$
=FAILUREC
\paragraph{Failure}
May give rise to the error message from $simple\_mk\_ç$.
=ENDDOC
\subsection{Functions Upon Terms}
=DOC
val ‚frees· : TERM -> TERM list;
=DESCRIBE
Extract the free term variables within the term argument.
The resulting variables will be in reverse order of first occurrence
(for a term viewed without fixity properties, such as infix variables).
=SEEALSO
$dest\_frees$
=ENDDOC
=DOC
val ‚is_free_var_in· : (string * TYPE) -> TERM -> bool;
=DESCRIBE
Given a destroyed term variable, checks to see if it is free within the term supplied as a second argument.
=ENDDOC
\subsection{Generic Derived Term Structure Functions}
The following functions are provided to give a standard, generic, approach
to implementing various derived term manipulation functions.
For instance, the functions of section \ref{SpecificFunctions} will usually
be implemented by just a call to one of these functions.

A performance issue arises with the destructor functions for
derived term constructors: need they test the types of constants?
We do not make this test, and thus might give the ``wrong''
results with ill-formed terms.
It is not necessary to worry about this if we are only concerned about
saved theorems, etc, as these are checked for well-formedness of their constituents.
In addition, the constants required to implement the abstract data type $THM$ cannot occur with incorrect types, by
the mechanism of $mk\_const$.
Apart from this, some misleading results on handling terms could occur,
but no inconsistency arises.

\subsection{Generic Binary Operators}
=DOC
val ‚mk_bin_op· : string -> int -> int -> (TYPE -> TYPE -> TERM) ->
	(TERM * TERM) -> TERM;
=DESCRIBE
$mk\_bin\_op$ $area$ $msg1 $msg2$ $rator\_fn$ $(t_1, t_2)$ attempts to form the term $ªt_1\ rator\ t_2º$.
$rator'$ is gained by applying $rator\_fn$ to the types of $t_1$ and $t_2$.
=FAILUREC
\paragraph{Failure}
The failure message for failing to apply $rator$ to 
the first term will be from area $area$, and will have the text indexed by $msg1$, with the two terms as strings for arguments.
If the failure is from applying the rators plus first term to the second term will be from area $area$, and will have the text indexed by $msg2$, with the two terms as strings for arguments.
=ENDDOC
=DOC
val ‚dest_bin_op· : string -> int -> string -> TERM -> (TERM * TERM);
=DESCRIBE
$dest\_bin\_op$ $area$ $msg$ $rator\_nm$ $term$ assumes that $term$ is of the form $ªrator\ t1\ t2º$, where $rator$ is
a constant with name $rator\_nm$, and attempts to return the pair $(t1, t2)$.
=FAILUREC
If the function fails it will fail with message $msg$, area $area$ and with the string form of $term$.
=ENDDOC
=DOC
val ‚is_bin_op· : string -> TERM -> bool;
=DESCRIBE
$is\_bin\_op$ $rator\_nm$ $term$ is true iff. $term$ is of the form ªrator\ t1\ t2º, and $rator$ is
a constant with name $rator\_nm$.
=ENDDOC
=DOC
val ‚list_mk_bin_op· : string -> int -> int ->
	(TYPE -> TYPE -> TERM) -> TERM list -> TERM;
=DESCRIBE
This function combines a list of terms using the given operator, as if by $mk\_bin\_op$ (q.v).
Notice the bracketing in the example.
=EXAMPLE
list_mk_bin_op area msg Ä_fun [ªaº, ªb Ä cº, ªdº] = 
		ªa Ä ((b Ä c) Ä d)º 
=TEX
where $Ä\_fun$ takes two (dummy) arguments and returns ª\$Äº.
=FAILURE
3017	An empty list argument is not allowed
=FAILUREC
\paragraph{Failure}
The failure message for failing to combine its arguments will be as $mk\_bin\_op$ for the offending two arguments.
If given an empty list the error will be from area $area$, but with message 3017.
=ENDDOC
=DOC
val ‚strip_bin_op· : string -> TERM -> TERM list
=DESCRIBE
This function strips a binary operator, attempting to destroy its term argument, and recursively stripping to the right,
as if by $dest\_bin\_op$.
A term not formed from the operator is returned unchanged,
as a singleton list.
=EXAMPLE
strip_bin_op "Ä" ªa Ä (b Ä c) Ä dº = [ªaº, ªb Ä cº, ªdº]
=ENDDOC
=DOC
val ‚bin_bool_op· : string -> TYPE -> TYPE -> TERM;
=DESCRIBE
Returns a constant with the given name, and type 
\[ª:BOOL\ ã\ BOOL\ ã\ BOOLº\]
The type arguments are dummies, present only to make the function
have an acceptable signature for certain other functions.
=ENDDOC
\subsubsection{Generic Unary Operator Functions}
=DOC
val ‚mk_mon_op· : string -> int -> (TYPE -> TERM) ->
	TERM -> TERM;
=DESCRIBE
$mk\_mon\_op$ $area$ $msg$ $rator\_fn$ $rand$ attempts to form the term $ªrator\ randº$.
The $rator$ is gained by applying $rator\_fn$ to the type of $rand$.
=FAILUREC
\paragraph{Failure}
The failure message for failing to apply $rator$ to its arguments will be from area $area$, and will have the text indexed by $msg$.
=ENDDOC
=DOC
val ‚dest_mon_op· : string -> int -> string -> TERM -> TERM;
=DESCRIBE
$dest\_mon\_op$ $area$ $msg$ $rator\_nm$ $term$ assumes that $term$ is of the form $ªrator\ tº$, where 
$rator$ is a constant with name $rator\_nm$, and the function attempts to return $t$.
=FAILUREC
\paragraph{Failure}
The failure message for failing to apply $rator$ to its argument will be from area $area$, and will have the text indexed by $msg$, and will have as argument the string form of $term$.
=ENDDOC
=DOC
val ‚is_mon_op· : string -> TERM -> bool;
=DESCRIBE
$is\_mon\_op$ $dest$ $term$ is true iff. $term$ is of the form $rator\ t$, where 
$rator$ is a constant with name $rator\_nm$.
=ENDDOC
\subsubsection{Generic Simple Abstraction Functions}
=DOC
val ‚simple_mk_binder· : string -> int -> (TYPE -> TYPE -> TERM) ->
	(TERM * TERM) -> TERM;
=DESCRIBE
$simple\_mk\_binder$ $area$ $msg$ $binder\_fn$ $(var,\ body)$ generates the term:
\[ªbinder(ç var\ é\ body)º\] where $binder$ is $binder\_fn$ applied to the types of $var$ and $body$.
$var$ must be a term variable.
=SEEALSO
$mk\_binder$
=FAILURE
3007	?0 is not a term variable
=FAILUREC
\paragraph{Failure}
If the term cannot be made, then the error will be from $area$, with a message indexed by $msg$, and the two terms as string arguments.
If the first of the pair of terms is not a variable then
error 3007 will be given from area $area$.
=ENDDOC
=DOC
val ‚simple_dest_binder· : string -> int -> string -> TERM -> TERM * TERM;
=DESCRIBE
Executing $simple\_dest\_binder$ $area$ $msg$ $binder\_nm$ $ªbinder(ç\ var\ é\ body)º$, where $binder$ is a constant with the name $binder\_nm$,
will give $(ªvarº,\ ªbodyº)$.
=SEEALSO
$dest\_binder$
=FAILUREC
\paragraph{Failure}
If the term cannot be destroyed, then the error will be from $area$, with a message indexed by $msg$,
and argument the string form of $term$.
=ENDDOC
=DOC
val ‚simple_is_binder· : string -> TERM -> bool;
=DESCRIBE
$simple\_is\_binder$ $binder\_nm$ $term$ returns true iff. $term$ is of the form $ªbinder(ç\ var\ é\ body)º$, where $binder$ is a constant with the name $binder\_nm$.
=SEEALSO
$is\_binder$
=ENDDOC
See \cite{DS/FMU/IED/DTD004} for a list binder constructor,
$list\_mk\_binder$ suitable for both simple and paired abstractions, and $simple\_strip\_binder$.
=DOC
val ‚quantifier· : string -> TYPE -> TYPE -> TERM;
=DESCRIBE
$quantifier$ $name$ $type$ $dummy$ returns a constant, with the given name, and type $ª: (type ã BOOL) ã BOOLº$,
This is an appropriate type for binders.
The dummy is present only to make the function
have an acceptable signature for certain other functions.
=ENDDOC
\subsection{Specific Derived Term Structure Functions}
\label{SpecificFunctions}
\subsubsection{Equations}
=DOC
val ‚equality· : TYPE -> TYPE -> TERM;
=DESCRIBE
Returns the constant $ª=º$
 upon terms with the first type argument.
The second type is a dummy argument, present only to make the function
have an acceptable signature for certain other functions.
=ENDDOC
=DOC
val ‚mk_eq· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating equations.
=FAILURE
3012	?0 and ?1 do not have the same types
=ENDDOC
=DOC
val ‚dest_eq· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for equations.
=FAILURE
3014	?0 is not of form: ªt = uº or ªt Ç uº 
=ENDDOC
=DOC
val ‚is_eq· : TERM -> bool;
=DESCRIBE
Is the term an equation?
=ENDDOC
\subsubsection{Implications}
=DOC
val ‚mk_ä· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating implications.
=FAILURE
3015	?1 is not of type ª:BOOLº
3031	?0 is not of type ª:BOOLº
=ENDDOC
=DOC
val ‚dest_ä· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for implications.
=FAILURE
3016	?0 is not of form: ªt ä uº 
=ENDDOC
=DOC
val ‚is_ä· : TERM -> bool;
=DESCRIBE
Is the term an implication?
=ENDDOC
The following could alternatively, and with equal merit, have the signature $:(TERM\ list) * TERM -> TERM$.
=DOC
val ‚list_mk_ä· : TERM list -> TERM;
=DESCRIBE
Makes a multiple implication term, using $mk\_ä$ (q.v.).
ÛDefinition
list_mk_ä [ªt1º,ªt2º,...] = ªt1 ä t2 ä ...º 
Ê
Note that giving a singleton list containing a non-boolean will return that term, rather than fail.
=FAILURE
3017	An empty list argument is not allowed
3015	?1 is not of type ª:BOOLº
3031	?0 is not of type ª:BOOLº
=ENDDOC
The following could alternatively have the signature $:TERM\ ->\ (TERM\ list) * TERM$, if it matched a change in $list\_mk\_ä$.
=DOC
val ‚strip_ä· : TERM -> TERM list;
=DESCRIBE
Strip a multiple implication.
ÛDefinition
strip_ä  ªt1 ä t2 ä ...º = [ªt1º,ªt2º,...]
Ê
Note that stripping a non-boolean will result in a singleton list containing that term, not a fail.
=ENDDOC
\subsubsection{Simple É-terms}
=DOC
val ‚simple_mk_É· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating $É$-terms.
ÛDefinition
simple_mk_É (ªvarº, ªbodyº) = ªÉ var é bodyº 
Ê
$var$ must be a term variable.
=SEEALSO
$mk\_É$
=FAILURE
3007	?0 is not a term variable
3015	?1 is not of type ª:BOOLº
=ENDDOC
=DOC
val ‚simple_dest_É· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for $É$-terms.
It cannot destroy paired abstraction $É$-terms, being the inverse of $simple\_mk\_É$.
=SEEALSO
$dest\_É$
=FAILURE
3032	?0 is not of form: ªÉ var é bodyº 
=ENDDOC
=DOC
val ‚simple_is_É· : TERM -> bool;
=DESCRIBE
A derived term test for simple $É$-terms, not formed with paired abstractions.
=SEEALSO
$is\_É$
=ENDDOC
=DOC
val ‚simple_list_mk_É· : TERM list * TERM -> TERM;
=DESCRIBE
Universally quantify a term with a list of variables.
ÛDefinition
simple_list_mk_É ([ªx1º,ªx2º,...], ªbodyº) = ªÉ x1 x2 ... é bodyº 
Ê
This uses $simple\_mk\_É$ (q.v) to generate its result.
Note that giving an empty list paired with a non-boolean will return that term, rather than fail.
=SEEALSO
$list\_mk\_É$
=FAILUREC
\paragraph{Failure}
This may give $simple\_mk\_É$ error messages.
=ENDDOC
\subsubsection{Simple Ñ-terms}
=DOC
val ‚simple_mk_Ñ· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating $Ñ$-terms.
ÛDefinition
mk_Ñ (ªvarº, ªbodyº) = ªÑ var é bodyº
Ê
$var$ must be a term variable.
=SEEALSO
$mk\_Ñ$
=FAILURE
3007	?0 is not a term variable
3015	?1 is not of type ª:BOOLº
=ENDDOC
=DOC
val ‚simple_dest_Ñ· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for $Ñ$-terms.
It cannot destroy paired abstraction $Ñ$-terms, being the inverse of $simple\_mk\_Ñ$.
=SEEALSO
$dest\_Ñ$
=FAILURE
3034	?0 is not of form: ªÑ var é bodyº
=ENDDOC
=DOC
val ‚simple_is_Ñ· : TERM -> bool;
=DESCRIBE
A derived term test for  $Ñ$-terms, not formed with paired abstractions.
=SEEALSO
$is\_Ñ$
=ENDDOC
=DOC
val ‚simple_list_mk_Ñ· : TERM list * TERM -> TERM;
=DESCRIBE
Existentially quantify a term with a list of variables.
ÛDefinition
simple_list_mk_Ñ ([ªx1º,ªx2º,...], ªbodyº) = ªÑ x1 x2 ... é bodyº
Ê
This uses $simple\_mk\_Ñ$ (q.v) to generate its result.
Note that giving an empty list paired with a non-boolean will return that term, rather than fail.
=SEEALSO
$list\_mk\_Ñ$
=FAILUREC
\paragraph{Failure}
This may give $simple\_mk\_Ñ$ error messages.
=ENDDOC
\subsection{Literals}
There are three types of literal: numbers, strings and characters.
\subsubsection{Numeric Literals}

The representation of numeric literals is by HOL constants whose type
is~``Ü'' and where the string component of the constant is entirely
decimal digits, the digits being the decimal representation of the
literal.

=DOC
val ‚Ü· : TYPE;
=DESCRIBE
This is the HOL type of the natural numbers, $0, 1, \ldots$.
ÛDefinition
val Ü = ª:Üº;
Ê
=SEEALSO
Theory ``$Ü$''.
=ENDDOC
=DOC
val ‚mk_Ü· : int -> TERM;
=DESCRIBE
Construct a numeric literal.
=FAILURE
3021	?0 may not be negative
=ENDDOC
=DOC
val ‚dest_Ü· : TERM -> int;
=DESCRIBE
Destroy a numeric literal.
=FAILURE
3026	?0 is not a numeric literal
=ENDDOC
=DOC
val ‚is_Ü· : TERM -> bool;
=DESCRIBE
Is the term a numeric literal?
=ENDDOC
\subsubsection{Character Literals}

Character literals are represented by HOL constants of type ``$CHAR$''
where the string component of the constant is exactly two characters
long, the first being the back-quotation~(~`~) and the second the
character itself.  The back-quotation~(~`~) is chosen as it is used in
the concrete syntax representation of character literals.

The construction and destruction functions have as argument and result
(respectively) a string holding a single character.  The back-quotation
is intended for use only in the internal representation of character
literals.  However, the internal representation will be returned by, e.g., a
call of $(simple\_)dest\_term$.

=DOC
val ‚CHAR· : TYPE;
=DESCRIBE
This is the type of single characters.
ÛDefinition
val CHAR = ª:CHARº;
Ê
=SEEALSO
Theory ``char''.
=ENDDOC
=DOC
val ‚mk_char· : string -> TERM;
=DESCRIBE
Construct a character literal.
=FAILURE
3023	String ?0 is not a single character
=ENDDOC
=DOC
val ‚dest_char· : TERM -> string;
=DESCRIBE
Destroy a character literal.
=FAILURE
3024	?0 is not a character literal
=ENDDOC
=DOC
val ‚is_char· : TERM  -> bool;
=DESCRIBE
Is the term a character literal?
=ENDDOC

\subsubsection{String Literals}

String literals are represented by HOL constants of type ``$STRING$''
where the first character of string component of the constant is the
double-quote~(~{\tt"}~) and the remainder is the body of the string.
The double-quote~(~{\tt"}~) is chosen as it is used in the concrete
syntax representation of strings.

The construction and destruction functions have as argument and result
(respectively) the body of the string.  The double-quote is intended
for use only in the internal representation of strings.  However, the
internal representation will be returned by a call of,
e.g.
$(simple\_)dest\_term$.

=DOC
val ‚STRING· : TYPE;
=DESCRIBE
This is the HOL type of strings, a type abbreviation for lists
of objects of type $CHAR$.
ÛDefinition
val STRING = ª:CHAR LISTº;
Ê
=SEEALSO
Theory ``char''.
=ENDDOC
=DOC
val ‚mk_string· : string -> TERM;
=DESCRIBE
Construct a string literal.
=ENDDOC
=DOC
val ‚dest_string· : TERM -> string;
=DESCRIBE
Destroy a string literal.
=FAILURE
3025	?0 is not a string literal
=ENDDOC
=DOC
val ‚is_string· : TERM -> bool;
=DESCRIBE
Is the term a string literal?
=ENDDOC

\subsection{Other Term Functions}
=DOC
val ‚aconv· : TERM -> TERM -> bool;
=DESCRIBE
Are two terms $\alpha$-convertible? That is, do they only differ by the names of bound variables.
=ENDDOC
=DOC
val ‚set_variant_suffix· : string -> string;
=DESCRIBE
Sets the string control $variant\_suffix$ used to create variant names in $string_variant$ (q.v.) and its relatives.
The string is initially a single prime character.
The function returns the previous setting of the control.
=FAILURE
3028	string may not be empty
=ENDDOC
=DOC
val ‚get_variant_suffix· : unit -> string;
=DESCRIBE
Returns the string control $variant\_suffix$ used to create variant names in $string_variant$ (q.v.) and its relatives.
The string is set by $set\_variant\_suffix$ (q.v.).
=ENDDOC
=DOC
val ‚string_variant· : string list -> string -> string;
=DESCRIBE
$string_variant$ $vlist$ $name$ returns a string that is a different from any name in $vlist$.
Variants are formed by repeatedly appending the variant string(see $set\_variant\_string$) to the $name$.
Note that $string_variant$ $[]$ $name$ gives $name$.
=USES
Somewhat faster than $variant$ if term variables are already destroyed, and their names and types are directly accessible.
=SEEALSO
$variant$
=ENDDOC
=DOC
val ‚rename· : (string * TYPE) -> string -> TERM -> TERM;
=DESCRIBE
$rename$ $(oname,\ type)$ $cname$ $term$ returns a term based on $term$, but with any free variables with name $oname$, and type $type$ renamed to $cname$.
=ENDDOC
=DOC
val ‚term_types· : TERM -> TYPE list;
=DESCRIBE
Gives a list of all the types of constants, variables or $ç$-abstraction variables within the term argument.
=ENDDOC
=DOC
val ‚term_any· : (TERM -> bool) -> TERM -> bool;
=DESCRIBE
Given a predicate on terms, tests to see if any sub-term of some term (or the term itself) satisfies the predicate.
The search ceases on the first satisfaction, rather than all the
tests being done and the results combined.
=ENDDOC
=DOC
val ‚term_tyvars· : TERM -> string list;
=DESCRIBE
Returns the list of type variable names present in types present within a term.
=ENDDOC
=DOC
val ‚term_tycons· : TERM -> (string * int) list;
=DESCRIBE
Returns the set of type constructors and their arity present in types present within a term
(represented as a list).
=ENDDOC
=DOC
val ‚term_consts· : TERM -> (string * TYPE) list;
=DESCRIBE
This function extracts the subterms of a term which
are constants, giving destroyed constants in each case.
=ENDDOC
=DOC
val ‚term_vars· : TERM -> (string * TYPE) list;
=DESCRIBE
This function extracts the subterms of a term which
are variables (including abstraction variables), giving destroyed variables in each case.
=ENDDOC
=DOC
val ‚type_match· : TYPE -> TYPE -> (TYPE * TYPE)list;
=DESCRIBE
$type\_match$ $ty_1$ $ty_2$ attempts to find if $ty_1$ is an instance of $ty_2$.
If so, then it returns a list giving the correspondence between
types in $ty_1$ with type variables in $ty_2$.
Trivial (i.e. (x,x)) correspondences are not noted.
=FAILURE
3053	?0 is not a type instance of ?1
=ENDDOC
=DOC
val ‚term_match· : TERM -> TERM -> (TYPE * TYPE) list * (TERM * TERM)list;
=DESCRIBE
$term\_match$ $tm_1$ $tm_2$ attempts to find if $tm_1$ is an instance of $tm_2$.
If so, then it returns two list.
The first gives the correspondence between types in $tm_1$ with type variables in $tm_2$.
The second gives the correspondence between (type instantiated) terms in $tm_1$ with free variables in $tm_2$.
Trivial (i.e. $(x,x)$) correspondences are not noted.
=FAILURE
3054	?0 is not an term instance of ?1
=ENDDOC
=DOC
val ‚is_type_instance· : TYPE -> TYPE -> bool;
=DESCRIBE
$is\_type\_instance$ $ty_1$ $ty_2$ returns true iff $ty_1$ is an instance of $ty_2$.
=ENDDOC
=DOC
val ‚gen_vars· : TYPE list -> TERM list -> TERM list;
=DESCRIBE
$gen\_vars$ $tyl$ $tml$ generates a list of differently named machine-generated term
variables, with the types in $tyl$, whose names are not present within any of the terms in $tml$ as variable names.

It will be much faster to make one call to this function with a list of types, than to make the equivalent number of individual type calls.
=ENDDOC
=DOC
val ‚variant· : TERM list -> TERM -> TERM;
=DESCRIBE
$variant$ $stoplist$ $v$ returns a variant of variable $v$ 
whose name is not used for any variable in $stoplist$
(which must be only variables).
The variants are generated by sufficient appending of the variant string (see $set\_variant\_string$).
=FAILURE
3007	?0 is not a term variable
=SEEALSO
$string_variant$, $list\_variant$
=ENDDOC
=DOC
val ‚list_variant· : TERM list -> TERM list -> TERM list;
=DESCRIBE
$list\_variant$ $stoplist$ $vlist$ returns a list of variantsof the list of variables $vlist$, whose names are not present in the $stoplist$, which is also a list of term variables.
No names are duplicated, the function returning one new variable for each member of $vlist$.
The variants are generated by sufficient appending of the variant string (see $set\_variant\_string$).
=FAILURE
3007	?0 is not a term variable
=ENDDOC
=DOC
val ‚is_free_in· : TERM -> TERM -> bool;
=DESCRIBE
$is\_free\_in$ $v$ $term$ is true iff. $v$ is a free variable in
$term$.
=FAILURE
3007	?0 is not a term variable
=ENDDOC
=DOC
val ‚var_subst· : (TERM * TERM) list -> TERM -> TERM;
=DESCRIBE
$var\_subst$ $alist$ $term$ returns the term formed by, for each pair in $alist$, substituting in $term$ all free instances of the term variable which is the second of the pair with the first of the pair.
The pair of the first matching term variable in the list will be used,
duplicates later in the list will be ignored. 
Renaming may occur to prevent bound variable capture.

Note that the term variables must have the same types as the terms that are to replace them.
Û
var_subst [(ªt1º,ªx1º),(ªt2º,ªx2º),...] ªtº =
	ªt[t1\x1, t2\x2,...]º
Ê
=FAILURE
3007	?0 is not a term variable
3012	?0 and ?1 do not have the same types
=SEEALSO
$subst$
=ENDDOC
=DOC
val ‚subst· : (TERM * TERM) list -> TERM -> TERM;
=DESCRIBE
$subst$ $alist$ $term$ returns the term formed by, for each pair in $alist$, substituting in $term$ all ``free'' instances of the term which is the first of the pair with the second of the pair.
A term is a ``free'' instance as a subterm if none of the
free variables of the term are bound in the position of the subterm.
The pair of the first matching term in the list will be used,
duplicates later in the list will be ignored. 
Renaming may occur to prevent bound variable capture.
Note that the terms must have the same types as the terms that are to replace them.
Û
var_subst [(ªt1aº,ªt1bº),(ªt2aº,ªt2bº),...] ªtº =
	ªt[t1a\t1b, t2a\t2b,...]º
Ê
=SEEALSO
$var\_subst$
=FAILURE
3012	?0 and ?1 do not have the same types
=ENDDOC
=DOC
val ‚term_map· : ((TERM list) -> TERM -> TERM) -> TERM -> TERM;
=DESCRIBE
$term\_map$ $tmfun$ $tm$ traverses
$tm$ (breadth first) looking for subterms for which
the application $tmfun\,tm$ does not fail and replaces
such subterms with $tmfun\,tm$. 
It does not traverse the resulting subterms.
$tmfun$ has as its first argument a list giving
the bound variables which are in scope at the point of use.
It does not attempt to apply $tmfun$ to a bound variable of an abstraction.
=ENDDOC
=DOC
val ‚inst· : TERM list -> (TYPE * TYPE) list -> TERM -> TERM;
=DESCRIBE
$inst$ $avlist$ $slist$ $term$ instantiates the type variables of $term$ with the associated types found in $slist$.
An element of $slist$ will be ($return$, $tv$),
where $tv$ is a type variable that is to be instantiated to $return$.
It will rename bound variables as necessary to prevent name capture problems.
It will also not allow free variables to become the same as those in the avoidance list, $avlist$.

It partially evaluates with two arguments.
=FAILURE
3007	?0 is not a term variable
3019	?0 is not a type variable
=ENDDOC
\subsection{Sets of Terms, Modulo $\alpha$-convertibilty}.
=DOC
val ‚term_mem· : (TERM * TERM list) -> bool;
=DESCRIBE
Is the given term $\alpha$-convertible to any term in the list?
=ENDDOC
=DOC
val ‚term_less· : (TERM list * TERM) -> TERM list;
=DESCRIBE
Remove any terms in the list that are $\alpha$-convertible to the given term.
=ENDDOC
=DOC
val ‚term_grab· : (TERM list * TERM) -> TERM list;
=DESCRIBE
If the given term is not $\alpha$-convertible to any member of the list, then add it to the list.
=ENDDOC
=DOC
val ‚term_union· : (TERM list * TERM list) -> TERM list;
=DESCRIBE
Take the union of two term lists viewed as sets, removing any $\alpha$-convertible duplicates.
=SEEALSO
$union$ for precise ordering of result.
=ENDDOC
=DOC
val ‚list_term_union· : (TERM list list) -> TERM list;
=DESCRIBE
Take the union of a number of lists of terms viewed as sets, removing any $\alpha$-convertible duplicates.
=SEEALSO
$list\_union$ for precise ordering of result.
=ENDDOC

\subsection{Failing With Terms and Types}
=DOC
val ‚term_fail· : string -> int -> TERM list -> 'a;
=DESCRIBE
$term\_fail$ $area$ $msg$ $tml$ first creates a list of functions from $()$ to string, providing displays of the list of terms.
It then calls $fail$ with the $area$, $msg$ and this list of functions.
This allows terms to be presented in error messages.
=ENDDOC
=DOC
val ‚type_fail· : string -> int -> TYPE list -> 'a;
=DESCRIBE
$type\_fail$ $area$ $msg$ $tyl$ first creates a list of functions from $()$ to string, providing displays of the list of types.
It then calls $fail$ with the $area$, $msg$ and this list of functions.
This allows types to be presented in error messages.
=ENDDOC

=SML
end(* signature of icl'TypesAndTerms *);
=TEX
\section{TEST POLICY}
In \cite{DS/FMU/IED/PLN008} there is a statement of the general principle of testing to be adopted.
This section gives some individual comments on special testing requirements for individual functions.

A key problem in the functions provided is to ensure that
free variable capture does not occur.
That is, due to some change, a variable that was free, becomes unintentionally bound.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
