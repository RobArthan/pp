=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Release 1 ICL HOL: Detailed Design for Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Release 1 ICL HOL \cr Detailed Design for Types and Terms}
\TPPref{DS/FMU/IED/DTD003}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the types of HOL terms and types, namely $TERM$ and $TYPE$. It then gives some utility functions upon these.
These will be sufficient functions upon $TERM$ to define the type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
Based on the first part of DS/FMU/IED/SML002.
\item [Issue 1.2]
Many changes while deciding upon a format.
\item [Issues 1.3, 1.4]
Changes made during writing implementation.
\item [Issue 1.5]
Names made pretty were appropriate, using material of \cite{DS/FMU/IED/DTD005}.
\item [Issue 1.5]
Added $term\_any$, $type\_any$, $term\_type\_constructors$, $dest\_vartype$, $is\_vartype$.
Acted upon section 7 of issue 1.3 of \cite{DS/FMU/IED/WRK015}.
\end{description}
\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design of the types and terms of ICL HOL, and utilities to handle them, called for by the first point of section 4.2 of the Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The high-level specification for the code may be considered
to be given in \cite{DS/FMU/IED/SPC001}.
The design is
implemented in \cite{DS/FMU/IED/IMP003}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design of the types and terms of ICL HOL, and utilities to handle them.
These will be sufficient functions upon $TERM$ to define the type $THM$.
\subsubsection{Dependencies}

\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}

=TEX
\section{INFIX DIRECTIVES}
=SML
infix 4 TERM_eq;
=TEX
\section{TYPES AND TERMS}
=DOC
signature ‚icl'TypesAndTerms· = sig
=DESCRIBE
This provides the type of ICL HOL types: $TYPE$, of ICL HOL terms: $TERM$, and some
utility functions upon them.
A user should access all the elements of this signature through signature $DerivedTerms$ in \cite{DS/FMU/IED/DTD004}.
=ENDDOC
\subsection{The Type: $TYPE$}
It may well be worth considering making the function type constructor
a constructor of the datatype $TYPE$. The advantage would be that
function types could then be recognised by a simpler pattern match (not
involving a string equality test).
We have not done this since it complicates some issues.

By using the names $mk\_vartype$ and $mk\_type$ below we follow the convention for naming construction and destruction functions,
rather than data constructors.
=DOC
datatype ‚TYPE· =
		‚mk_vartype· of string |
		‚mk_type·    of string * TYPE list;
=DESCRIBE
All ICL HOL terms will be ``typed'', by associating them with
an object of type $TYPE$.
A type may either be a variable (or generic) type, indicated in the
concrete syntax by $:'<name>$;
or a type constructor, with a list of type arguments, indicated by
$typename$, $arg\ typename$ or $(arg_1, \ldots, arg_n)\ typename$,
for types with none, one or many arguments.
=ENDDOC
\subsection{Functions Upon the Type $TYPE$}
=DOC
val ‚dest_type· : TYPE -> string * TYPE list;
=DESCRIBE
Extract the arguments to $mk\_type$ by function rather than pattern-matching.
=FAILURE
3001	?0 is not of form: `mk_type(<string>,<type list>)'
=ENDDOC
=DOC
val ‚dest_vartype· : TYPE -> string;
=DESCRIBE
Extract the name of a type variable.
=FAILURE
3019	Argument is not of form: `mk_vartype <string>'
=ENDDOC
=DOC
val ‚is_vartype· : TYPE -> bool;
=DESCRIBE
Is the type a type variable. If it isn't then it must be a type construction.
=ENDDOC
=DOC
val ‚mk_fun· : (TYPE * TYPE) -> TYPE;
=DESCRIBE
$mk\_fun$ $(ty1,\ ty2)$ is $":ty1 ã ty2"$.
=ENDDOC
=DOC
val ‚icl'inst_type· : ((TYPE * string) list) -> TYPE -> TYPE;
=DESCRIBE
$inst\_type$ $alist$ $type$ recursively descends through $type$, replacing any type variables by whatever the association list $alist$ associates with them.
If the association list does not contain a type variable found in $type$, then that type variable will not be changed.
Replaced types are {\bf not} recursively processed by this function.
=ENDDOC
=DOC
val ‚type_tycons· : TYPE -> (string * int) list;
=DESCRIBE
This returns a list of names of type constructors, and the arity of their use, within a type.
=ENDDOC
=DOC
val ‚type_tyvars· : TYPE -> string list;
=DESCRIBE
Returns the list of type variable names present in a type.
=ENDDOC
=DOC
val ‚type_any· : (TYPE -> bool) -> TYPE -> bool;
=DESCRIBE
Given a predicate on types, tests to see if any sub-type of some type (or the type itself) satisfies the predicate.
The search ceases on the first satisfaction, rather than all the
tests being done and the results combined.
=ENDDOC
=DOC
val ‚BOOL· : TYPE;
=DESCRIBE
The type of boolean-valued ICL HOL terms.
=SEEALSO
(The theory that declared a new type of this name)
=ENDDOC
=TEX
\subsection{The Types $TERM$ and $DEST\_TERM$}
=DOC
type ‚TERM·;
=DESCRIBE
This is the type of well-formed ICL HOL terms.
Objects of this type are manipulated by term constructor and destructor functions, such as $mk\_comb$, $dest\_abs$ and $is\_var$.
=ENDDOC
=DOC
datatype ‚DEST_TERM· = ‚Var· of string * TYPE |
	‚Const· of string * TYPE |
	‚Comb· of TERM * TERM |
	‚Abs· of TERM * TERM;
=DESCRIBE
This is the type of destroyed terms, related to the type $TERM$ by
$dest\_TERM$ and $mk\_TERM$.
The four data constructors represented destroyed variables, constants, combinations and abstractions respectively.
=USES
In writing pattern-matching functions upon ICL HOL terms.
=ENDDOC
\subsection{Primitive Functions Upon Terms}
=DOC
val ‚dest_TERM· : TERM -> DEST_TERM;
=DESCRIBE
An injective function, that destroys a term, returning its 
top-level structure, and the associated constituent parts.
=FAILURE
3063	DESIGN ERROR : Ill-formed representation of TERM
=SEEALSO
$mk\_TERM$, $DEST\_TERM$
=ENDDOC
=DOC
val ‚mk_TERM· : DEST_TERM -> TERM;
=DESCRIBE
Create a well-formed TERM from a statement of a top-level structure, and the associated constituent parts.

This may produce terms that are not well-formed within the context of some theories.
=SEEALSO
$dest\_TERM$, $DEST\_TERM$
=FAILURE
3002	Argument is `Comb(ªfº, ªaº)' where ªfº has the wrong type to be applied to ªaº 
3003	Argument is `Comb(ªfº, ªaº)' where type of ªfº not of form ª:ty1 ã ty2º
3020	Argument is `Abs(ªxº, ªtº)' where ªxº is not a variable
=ENDDOC
=DOC
val ‚type_of· : TERM -> TYPE;
=DESCRIBE
This gives the type of a term.
=ENDDOC
=DOC
val ‚mk_var· : (string * TYPE) -> TERM;
=DESCRIBE
This produces a term with a variable's structure.

This may produce terms that are not well-formed within the context of some theories.
=ENDDOC
=DOC
val ‚dest_var·: TERM -> (string * TYPE);
=DESCRIBE
Destroys a term with a variable's structure.
=FAILURE
3008	Term is not a variable
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val ‚is_var· : TERM -> bool;
=DESCRIBE
This function returns true iff. the term has a variable's structure.
=ENDDOC
=DOC
val ‚mk_const· : (string * TYPE) -> TERM;
=DESCRIBE
This produces a term with a constant's structure.

This may produce terms that are not well-formed within the context of some theories.
=ENDDOC
=DOC
val ‚dest_const·: TERM -> (string * TYPE);
=DESCRIBE
Destroys a term with a constant's structure.
=FAILURE
3009	Term is not a constant
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val ‚is_const· : TERM -> bool;
=DESCRIBE
This function returns true iff. the term has a constant's structure.
=ENDDOC
=DOC
val ‚mk_comb· : (TERM * TERM) -> TERM;
=DESCRIBE
This produces a term with a functional application structure.
=FAILURE
3005	Argument must have compatible types: `(ª... : ty1 ã ty2º, ª...:ty1º)'
3006	Argument is `(ªfº, ªaº) where type of ªfº not of form ª:ty1 ã ty2º 
=ENDDOC
The uses of this function in the parser, etc, should catch 
this functions error messages, and give more meaningful ones.
=DOC
val ‚dest_comb·: TERM -> (TERM * TERM);
=DESCRIBE
Destroys a term with a function application structure.
=FAILURE
3010	Term is not of form ªt1 t2º 
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val ‚is_comb· : TERM -> bool;
=DESCRIBE
This function returns true iff. the term has a function application structure.
=ENDDOC
=DOC
val ‚list_mk_comb· : (TERM * TERM list) -> TERM;
=DESCRIBE
ÛDefinition
list_mk_comb (ªtº, [ªt1º,ªt2º,ªt3º,...]) = ªt t1 t2 t3 ...º 
Ê
=FAILUREC
\paragraph{Failure}
May give rise to the error message from $mk\_comb$.
=ENDDOC
=DOC
val ‚strip_comb· : TERM -> TERM * TERM list;
=DESCRIBE
Splits a term into a head term, that is not an application, and the list of argument terms applied to that head term to form the original term.
=EXAMPLE
strip_comb ªt t1 t2 t3 ...º = (ªtº, [ªt1º,ªt2º,ªt3º,...])
=ENDDOC
=DOC
val ‚mk_simple_abs· : (TERM * TERM) -> TERM;
=DESCRIBE
This produces a term with an abstraction's structure.
It may only abstract variables.
=FAILURE
3007	Argument is not of form: `(ªvarº, ªtº)'
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised
=SEEALSO
$mk\_abs$
=ENDDOC
=DOC
val ‚dest_simple_abs·: TERM -> (TERM * TERM);
=DESCRIBE
Destroys a term with an abstraction's structure.
It cannot destroy paired abstractions, being a inverse of $mk\_simple\_abs$.
=FAILURE
3011	Argument is not of form: ªç var é tº 
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=SEEALSO
$dest\_abs$
=ENDDOC
=DOC
val ‚is_simple_abs· : TERM -> bool;
=DESCRIBE
This function returns true iff. the term has a variable abstraction's structure.
=SEEALSO
$is\_abs$
=ENDDOC
=DOC
val ‚list_mk_simple_abs· : (TERM list * TERM) -> TERM;
=DESCRIBE
ÛDefinition
list_mk_simple_abs ([ªx1º,ªx2º,...],ªtº) = ªç x1 x2 ... é tº 
Ê
This function will be implemented using $mk\_simple\_abs$, not $mk\_abs$.
=FAILUREC
\paragraph{Failure}
May give rise to the error message from $mk\_simple\_abs$.
=SEEALSO
$list\_mk\_abs$
=ENDDOC
=DOC
val ‚TERM_eq· : (TERM * TERM) -> bool;
=DESCRIBE
The standard equality function upon terms.
=ENDDOC
=DOC
val ‚icl'frees· : TERM -> (string * TYPE) list;
=DESCRIBE
Extract the free term variables within the term argument,
presenting them as destroyed variables.
=USES
For when we know the free variables are to be destroyed to use them.
This function is faster than $frees$.
=FAILURE
3064	DESIGN ERROR : applied to ill-formed term
=SEEALSO
$frees$
=ENDDOC
=DOC
val ‚frees· : TERM -> TERM list;
=DESCRIBE
Extract the free term variables within the term argument.
=SEEALSO
$dest\_frees$
=ENDDOC
=DOC
val ‚is_free_var_in· : (string * TYPE) -> TERM -> bool;
=DESCRIBE
Given a destroyed term variable, checks to see if it is free within the term supplied as a second argument.
=ENDDOC
\subsection{Derived Term Structure Functions}
\subsubsection{Generic Derived Term Structure Functions}
A performance issue arises with the destructor functions for
derived term constructors: need they test the types of constants?
We do not make this test. It is not necessary if the
definition of two constants with the same name is
disallowed.
=DOC
val ‚mk_bin_op· : string -> int -> (TYPE -> TYPE -> TERM) ->
	(TERM * TERM) -> TERM;
=DESCRIBE
$mk\_bin\_op$ $area$ $msg$ $rator$ $(t, t2)$ attempts to form the term $t1\ rator'\ t2$.
$rator'$ is gained by applying $rator$ to the types of $t1$ and $t2$.
=FAILUREC
\paragraph{Failure}
The failure message for failing to apply $rator$ to its arguments will be from area $area$, and will have the text indexed by $msg$.
=ENDDOC
=DOC
val ‚dest_bin_op· : string -> int -> string -> TERM -> (TERM * TERM);
=DESCRIBE
$dest\_bin\_op$ $area$ $msg$ $rator$ $term$ assumes that $term$ is of the form $t1\ rator\ t2$, and attempts to return the pair $t1, t2$.
=FAILUREC
\paragraph{Failure}
The failure message for failing to apply $rator$ to its arguments will be from area $area$, and will have the text indexed by $msg$.
=ENDDOC
=DOC
val ‚is_bin_op· : (TERM -> 'a) -> TERM -> bool;
=DESCRIBE
$is\_bin\_op$ $dest$ $term$ is true iff. $dest$ can be applied to $term$ without a catchable exception being raised.
=ENDDOC
=DOC
val ‚list_mk_bin_op· : string -> int -> 
	(TYPE -> TYPE -> TERM) -> TERM list -> TERM;
=DESCRIBE
This function combines a list of terms using the given operator.
Notice the bracketing in the example.
=EXAMPLE
list_mk_bin_op area msg Ä_fun [ªaº, ªb Ä cº, ªdº] = 
		ªa Ä ((b Ä c) Ä d)º 
=TEX
where $Ä\_fun$ takes two (dummy) arguments and returns ªÄº.
=FAILURE
3017	An empty list argument is not allowed
=FAILUREC
\paragraph{Failure}
The failure message for failing to combine its arguments will be from area $area$, and will have the text indexed by $msg$.
If given an empty list the error will be from area $area$, but with message 3017.
=ENDDOC
=DOC
val ‚strip_bin_op· : string -> TERM -> TERM list
=DESCRIBE
This function strips a binary operator, attempting to destroy its term argument, and recursively stripping to the right.
A test not formed from the operator is returned unchanged,
as a singleton list.
=EXAMPLE
strip_bin_op "Ä" ªa Ä (b Ä c) Ä dº = [ªaº, ªb Ä cº, ªdº]
=ENDDOC
=DOC
val ‚mk_mon_op· : string -> int -> (TYPE -> TERM) ->
	TERM -> TERM;
=DESCRIBE
$mk\_mon\_op$ $area$ $msg$ $rator$ $rand$ attempts to form the term $rator'\ rand$.
$rator'$ is gained by applying $rator$ to the type of $rand$.
=FAILUREC
\paragraph{Failure}
The failure message for failing to apply $rator$ to its arguments will be from area $area$, and will have the text indexed by $msg$.
=ENDDOC
=DOC
val ‚dest_mon_op· : string -> int -> string -> TERM -> TERM;
=DESCRIBE
$dest\_mon\_op$ $area$ $msg$ $rator$ $term$ assumes that $term$ is of the form $rator\ t$, and attempts to return $t$.
=FAILUREC
\paragraph{Failure}
The failure message for failing to apply $rator$ to its argument will be from area $area$, and will have the text indexed by $msg$.
=ENDDOC
=DOC
val ‚is_mon_op· : (TERM -> 'a) -> TERM -> bool;
=DESCRIBE
$is\_mon\_op$ $dest$ $term$ is true iff. $dest$ can be applied to $term$ without a catchable exception being raised.
=ENDDOC
=DOC
val ‚mk_simple_binder· : string -> int -> (TYPE -> TYPE -> TERM) ->
	(TERM * TERM) -> TERM;
=DESCRIBE
$mk\_binder$ $area$ $msg$ $binder$ $(var,\ body)$ generates the term:
$ªbinder(ç var\ é\ body)º$.
The $var$ must be a term variable.
=FAILUREC
\paragraph{Failure}
If the term cannot be made, then the error will be from $area$, with a message indexed by $msg$.
=ENDDOC
=DOC
val ‚dest_simple_binder· : string -> int -> string -> TERM -> TERM * TERM;
=DESCRIBE
$dest\_binder$ $area$ $msg$ $binder$ $ªbinder(ç var é body)º$
will give $(ªvarº,\ ªbodyº)$.
=FAILUREC
\paragraph{Failure}
If the term cannot be destroyed, then the error will be from $area$, with a message indexed by $msg$.
=ENDDOC
=DOC
val ‚is_simple_binder· : (TERM -> 'a) -> TERM -> bool;
=DESCRIBE
$is\_simple\_binder$ $dest$ $term$ returns true iff. $dest$ can be applied to $term$ without raising a catchable exception.
=ENDDOC
=DOC
val ‚bin_bool_op· : string -> TYPE -> TYPE -> TERM;
=DESCRIBE
Returns a constant with the given name, and type $ª:BOOL\ ã\ BOOL\ ã\ BOOLº$.
The type arguments are dummies.
=ENDDOC
\subsubsection{Specific Derived Term Structure Functions}
=DOC
val ‚equality· : TYPE -> TYPE -> TERM;
=DESCRIBE
Returns the constant $ª=º$
 upon terms with the first type argument.
The second type is a dummy argument.
=ENDDOC
=DOC
val ‚mk_eq· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating equalities.
=FAILURE
3013	Equality is only between terms of same type
=ENDDOC
=DOC
val ‚dest_eq· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for equalities.
=FAILURE
3014	Term is not of form: ªt = uº or ªt Ç uº 
=ENDDOC
=DOC
val ‚is_eq· : TERM -> bool;
=DESCRIBE
A derived term test for equalities.
=ENDDOC
=DOC
val ‚mk_ä· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating implications.
=FAILURE
3015	Implication is only between booleans
=ENDDOC
=DOC
val ‚dest_ä· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for implications.
=FAILURE
3016	Term is not of form: ªt ä uº 
=ENDDOC
=DOC
val ‚is_ä· : TERM -> bool;
=DESCRIBE
A derived term test for implications.
=ENDDOC
The following could alternatively have the signature $:(TERM\ list) * TERM -> TERM$.
=DOC
val ‚list_mk_ä· : TERM list -> TERM;
=DESCRIBE
ÛDefinition
list_mk_ä [ªt1º,ªt2º,...] = ªt1 ä t2 ä ...º 
Ê
Note that giving a singleton list containing a non-boolean will return that term, rather than fail.
=FAILURE
3017	An empty list argument is not allowed
3018	Argument list is not of booleans
=ENDDOC
The following could alternatively have the signature $:TERM\ ->\ (TERM\ list) * TERM$
=DOC
val ‚strip_ä· : TERM -> TERM list;
=DESCRIBE
ÛDefinition
strip_ä  ªt1 ä t2 ä ...º = [ªt1º,ªt2º,...]
Ê
Note that stripping a non-boolean will result in that term, not a fail.
=ENDDOC
=DOC
val ‚quantifier· : string -> TYPE -> TYPE -> TERM;
=DESCRIBE
$quantifier$ $name$ $type$ $dummy$ returns a constant, with the given name, and type $ª: (ty ã BOOL) ã BOOLº$.
=ENDDOC
=DOC
val ‚mk_simple_É· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating foralls.
ÛDefinition
mk_simple_É (ªvarº, ªbodyº) = ªÉ var é bodyº 
Ê
$var$ must be a term variable.
=FAILURE
3031	Argument is not of form: `(ªvarº, ªbody : BOOLº)'
=SEEALSO
$mk\_É$
=ENDDOC
=DOC
val ‚dest_simple_É· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for foralls.
It cannot destroy paired abstraction foralls, being the inverse of $mk\_simple\_É$.
=FAILURE
3032	Term is not of form: ªÉ var é bodyº 
=ENDDOC
=DOC
val ‚is_simple_É· : TERM -> bool;
=DESCRIBE
A derived term test for forall, not formed with paired abstractions.
=ENDDOC
=DOC
val ‚list_mk_simple_É· : TERM list * TERM -> TERM;
=DESCRIBE
ÛDefinition
list_mk_simple_É [ªx1º,ªx2º,...] ªbodyº = ªÉ x1 x2 ... é bodyº 
Ê
This uses $mk\_simple\_É$ to generate its result.
Note that giving an empty list paired with a non-boolean will return that term, rather than fail.
=FAILUREC
\paragraph{Failure}
This may give $mk\_simple\_É$ error messages.
=ENDDOC
=DOC
val ‚mk_simple_Ñ· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating exists.
ÛDefinition
mk_Ñ (ªvarº, ªbodyº) = ªÑ var é bodyº
Ê
$var$ must be a term variable.
=FAILURE
3031	Argument is not of form: `(ªvarº, ªbody : BOOLº)'
=SEEALSO
$mk\_Ñ$
=ENDDOC
=DOC
val ‚dest_simple_Ñ· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for exists.
It cannot destroy paired abstraction exists, being the inverse of $mk\_simple\_Ñ$.
=FAILURE
3034	Term is not of form: ªÑ var é bodyº
=SEEALSO
$dest\_Ñ$
=ENDDOC
=DOC
val ‚is_simple_Ñ· : TERM -> bool;
=DESCRIBE
A derived term test for exist, not formed with paired abstractions.
=ENDDOC
=DOC
val ‚list_mk_simple_Ñ· : TERM list * TERM -> TERM;
=DESCRIBE
ÛDefinition
list_mk_simple_Ñ [ªx1º,ªx2º,...] ªbodyº = ªÑ x1 x2 ... é bodyº
Ê
This uses $mk\_simple\_Ñ$ to generate its result.
Note that giving an empty list paired with a non-boolean will return that term, rather than fail.
=FAILUREC
\paragraph{Failure}
This may give $mk\_simple\_Ñ$ error messages.
=ENDDOC
\subsection{Other Term Functions}
=DOC
val ‚aconv· : TERM -> TERM -> bool;
=DESCRIBE
Tests whether two terms are alpha-convertable, that is it only differs by the names of bound variables.
=ENDDOC
=DOC
val ‚icl'variant· : ((string * TYPE) list) -> (string * TYPE) -> string;
=DESCRIBE
$icl'variant$ $vlist$ $(name,\ type)$ returns a string that is a variant of any name in $vlist$ with the associated type $type$.
Variants are formed by repeatedly priming $name$.
Note that $dest\_variant$ $[]$ $(name,\ type)$ gives $name$.
=USES
Somewhat faster than $variant$ if term variables are already destroyed.
=SEEALSO
$variant$
=ENDDOC
=DOC
val ‚icl'subst· : (TERM * (string * TYPE)) list -> TERM -> TERM;
=DESCRIBE
$icl'subst$ $alist$ $term$ returns a term based on $term$, but with with any term variable that may be found in the association list (second of a pair,
in a destroyed form) 
being replaced with the associated term(first of the pair).

Note that the destroyed term variables must have the same types as the term that is to replace them.
=SEEALSO
$var\_subst$, $subst$
=FAILURE
3052	Given `[...,(ªtº, string, ª:tyº),...]' where ªtº not of type ª:tyº
=ENDDOC
=DOC
val ‚rename· : (string * TYPE) -> string -> TERM -> TERM;
=DESCRIBE
$rename$ $(oname,\ type)$ $cname$ $term$ returns a term based on $term$, but with any free variables with name $oname$, and type $type$ renamed to $cname$.
=ENDDOC
=DOC
val ‚icl'inst· : (string * TYPE) list -> (TYPE * string) list -> TERM -> TERM;
=DESCRIBE
$icl'inst$ $alist$ $slist$ $term$ instantiates the type variables of $term$ with the associated types found in $slist$ (which is indexed by the type variable's name, not the type variables themselves).
It will rename bound variables as necessary to prevent name capture problems.
It will also rename variables to avoid them becoming the same as those in the avoidance list, $alist$.
=USES
Somewhat faster than $inst$ if type variables are already destroyed.
=SEEALSO
$inst$
=ENDDOC
=DOC
val ‚term_types· : TERM -> TYPE list;
=DESCRIBE
Gives a list of all the types of constants, variables or abstraction variables within the term argument.
=ENDDOC
=DOC
val ‚term_any· : (TERM -> bool) -> TERM -> bool;
=DESCRIBE
Given a predicate on terms, tests to see if any sub-term of some term (or the term itself) satisfies the predicate.
The search ceases on the first satisfaction, rather than all the
tests being done and the results combined.
=ENDDOC
=DOC
val ‚term_tyvars· : TERM -> string list;
=DESCRIBE
Returns the list of type variable names present in types present within a term.
=ENDDOC
=DOC
val ‚term_type_constructors· : TERM -> (string * int) list;
=DESCRIBE
Returns the set of type constructors and their arity
(represented as a list).
=ENDDOC
=DOC
val ‚term_constants· : TERM -> (string * TYPE) list;
=DESCRIBE
This function extracts the subterms of a term which
are constants, giving destroyed constants in each case.
=ENDDOC
=DOC
val ‚type_match· : TYPE -> TYPE -> (TYPE * TYPE)list;
=DESCRIBE
$type\_match$ $ty1$ $ty2$ attempts to find if $ty1$ is an instance of $ty2$.
If so, then it returns a list giving the correspondence between
types in $ty1$ with type variables in $ty2$.
Trivial (i.e. (x,x)) correspondences are not noted.
=FAILURE
3053	First type is not an instance of the second
=ENDDOC
=DOC
val ‚term_match· : TERM -> TERM -> (TYPE * TYPE) list * (TERM * TERM)list;
=DESCRIBE
$term\_match$ $tm_1$ $tm_2$ attempts to find if $tm_1$ is an instance of $tm_2$.
If so, then it returns two list.
The first gives the correspondence between types in $tm_1$ with type variables in $tm_2$.
The second gives the correspondence between (type instantiated) terms in $tm_1$ with free variables in $tm_2$.
Trivial (i.e. (x,x)) correspondences are not noted.
=FAILURE
3054	First term is not an instance of the second
=ENDDOC
=DOC
val ‚is_type_instance· : TYPE -> TYPE -> bool;
=DESCRIBE
$is\_type\_instance$ $ty1$ $ty2$ returns true iff $ty1$ is an instance of $ty2$.
=ENDDOC
=DOC
val ‚mg_variables· : TYPE list -> TERM list -> TERM list;
=DESCRIBE
$mg\_variables$ $tyl$ $tml$ generates a list of differently named machine-generated 
variables, with the types in $tyl$, whose names are not present within any of the terms in $tml$ as variable names.
=USES
It will be much faster to make one call to this function with a list of types, than to make the equivalent number of individual type calls.
=ENDDOC
=DOC
val ‚variant· : TERM list -> TERM -> TERM;
=DESCRIBE
$variant$ $stoplist$ $v$ returns a variant of variable $v$ that is not present in the $stoplist$.
The variants are generated by sufficient priming.
=FAILURE
3056	Second argument is not a variable
3057	First argument is not a list of term variables
=SEEALSO
$icl'variant$
=ENDDOC
=DOC
val ‚list_variant· : TERM list -> TERM list -> TERM list;
=DESCRIBE
$list\_variant$ $stoplist$ $vlist$ returns a list of variants that are not present in the $stoplist$, nor contain any duplicates, one for each member of $vlist$.
The variants are generated by sufficient priming.
=FAILUREC
\paragraph{Failure}
The function may give rise to errors from $variant$.
=ENDDOC
=DOC
val ‚is_free_in· : TERM -> TERM -> bool;
=DESCRIBE
$is\_free\_in$ $v$ $term$ is true iff. $v$ is a free variable in
$term$.
=ENDDOC
=DOC
val ‚var_subst· : (TERM * TERM) list -> TERM -> TERM;
=DESCRIBE
$var\_subst$ $alist$ $term$ returns the term formed by, for each pair in $alist$, substituting in $term$ all instances of the term variable which is the second of the pair with the first of the pair.

Note that the term variables must have the same types as the term that is to replace them.
=FAILURE
3060	First argument is not of form: `[(...,ªvarº),...,(...,ªvarº)]'
=SEEALSO
$icl'subst$, $subst$
=ENDDOC
=DOC
val ‚subst· : (TERM * TERM) list -> TERM -> TERM;
=DESCRIBE
$subst$ $alist$ $term$ returns the term formed by, for each pair in $alist$, substituting in $term$ all instances of the term which is the first of the pair with the second of the pair.
=SEEALSO
$icl'subst$, $var\_subst$
=ENDDOC
=DOC
val ‚TERM_map· : ((TERM list) -> TERM -> TERM) -> TERM -> TERM;
=DESCRIBE
$TERM\_map$ $tmfun$ $tm$ traverses
$tm$ (breadth first) looking for subterms for which
the application $tmfun\,tm$ does not fail and replaces
such subterms with $tmfun\,tm$. $tmfun$ has as its first argument a list giving
the bound variables which are in scope at the point of use.
It does not attempt to apply $tmfun$ to a bound variable of an abstraction.
=ENDDOC
=DOC
val ‚inst· : TERM list -> (TYPE * TYPE) list -> TERM -> TERM;
=DESCRIBE
$inst$ $alist$ $slist$ $term$ instantiates the type variables of $term$ with the associated types found in $slist$.
An element of $slist$ will be ($return$, $tv$),
where $tv$ is a type variable that is to be instantiated to $return$.
It will rename bound variables as necessary to prevent name capture problems.
It will also not allow variables to become the same as those in the avoidance list, $alist$.
=FAILURE
3061	First argument is not a list of term variables
3062	Second argument is not of form: `[...,(ª:tyº, ª:type variableº),...]'
=ENDDOC
=SML
end(* signature of icl'TypesAndTerms *);
=TEX
\section{TEST POLICY}
In \cite{DS/FMU/IED/PLN008} there is a statement of the general principle of testing to be adopted.
This section gives some individual comments on special testing requirements for individual functions.

A key problem in the functions provided is to ensure that
free variable capture does not occur.
That is, due to some change, a variable that was free, becomes unintentionally bound.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
