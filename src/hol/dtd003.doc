=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Release 1 ICL HOL: Detailed Design for Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Release 1 ICL HOL \cr Detailed Design for Types and Terms}
\TPPref{DS/FMU/IED/DTD003}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
Based on the first part of DS/FMU/IED/SML002.
\end{description}
\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design of the types and terms of ICL HOL, and utilities to handle them, called for by the first point of section 4.2 of the Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The high-level specification for the code may be considered
to be given in \cite{DS/FMU/IED/SPC001}.
The design is
implemented in \cite{DS/FMU/IED/IMP003}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design of the types and terms of ICL HOL, and utilities to handle them.
\subsubsection{Dependencies}

\subsubsection{Deficiencies}
The proposed pretty character facilities would allow such renamings as $mk\_forall$ to $mk\_É$, which would be preferable.
\subsubsection{Possible Enhancements}

=TEX
\section{THIS DOCUMENT'S INFIX DECLARATIONS}
=SML
infix 4 TERM_eq;
=TEX
\section{TYPES AND TERMS}
=DOC
signature ‚TypesAndTerms· = sig
=DESCRIBE
This provides the type of ICL HOL types: $TYPE$, of ICL HOL terms: $TERM$, and some
utility functions upon them.
=ENDDOC
\subsection{The Type: $TYPE$}
It may well be worth considering making the function type constructor
a constructor of the datatype $TYPE$. The advantage would be that
function types could then be recognised by a simpler pattern match (not
involving a string equality test).
We have not done this since it complicates some issues.

By using the names $mk\_vartype$ and $mk\_type$ below we follow the convention for naming construction and destruction functions,
rather than data constructors.
=DOC
datatype ‚TYPE· =
		‚mk_vartype· of string |
		‚mk_type·    of string * TYPE list;
=DESCRIBE
All ICL HOL terms will be ``typed'', by associating them with
an object of type $TYPE$.
A type may either be a variable (or generic) type, indicated in the
concrete syntax by $:'<name>$;
or a type constructor, with a list of type arguments, indicated by
$typename$, $arg\ typename$ or $(arg_1, \ldots, arg_n)\ typename$,
for types with none, one or many arguments.
=ENDDOC
\subsection{Functions Upon the Type $TYPE$}
=DOC
val ‚dest_type· : TYPE -> string * TYPE list;
=DESCRIBE
Extract the arguments to $mk\_type$ by function rather than pattern-matching.
=FAILURE
3001	Argument is not of form: mk_type(<string>,<type list>)
=ENDDOC
=DOC
val ‚mk_fun· : (TYPE * TYPE) -> TYPE;
=DESCRIBE
$mk\_fun$ $(ty_1,\ ty_2)$ is $":ty_1 ã ty_2"$.
=ENDDOC
=DOC
val ‚inst_type· : ((TYPE * string) list) -> TYPE -> TYPE;
=DESCRIBE
$inst\_type$ $alist$ $type$ recursively descends through $type$, replacing any type variables by whatever the association list $alist$ associates with them.
If the association list does not contain a type variable found in $type$, then that type variable will not be changed.
Replaced types are {\bf not} recursively processed by this function.
=ENDDOC
=DOC
val ‚type_tycons· : TYPE -> (string * int) list;
=DESCRIBE
This returns a list of names of type constructors, and the arity of their use, within a type.
=ENDDOC
=DOC
val ‚type_tyvars· : TYPE -> string list;
=DESCRIBE
Returns the list of type variable names present in the type.
=ENDDOC
=DOC
val ‚BOOL· : TYPE;
=DESCRIBE
The type of boolean-valued ICL HOL terms.
=SEEALSO
(The theory that declared a new type of this name)
=ENDDOC
=TEX
\subsection{The Types $TERM$ and $DEST\_TERM$}
=DOC
type ‚TERM·;
=DESCRIBE
This is the type of well-formed ICL HOL terms, manipulated by term construction and destruction functions.
=ENDDOC
=DOC
datatype ‚DEST_TERM· = ‚Var· of string * TYPE |
	‚Const· of string * TYPE |
	‚Comb· of TERM * TERM |
	‚Abs· of TERM * TERM;
=DESCRIBE
This is the type of destroyed terms, related to the type $TERM$ by
$dest\_TERM$ and $mk\_TERM$.
The four data constructors represented destroyed variables, constants, combinations and abstractions respectively.
=USES
In writing pattern-matching functions upon ICL HOL terms.
=ENDDOC
\subsection{Primitive Functions Upon Terms}
=DOC
val ‚dest_TERM· : TERM -> DEST_TERM;
=DESCRIBE
An injective function, that destroys a term, returning its 
top-level structure, and the associated constituent parts.
=SEEALSO
$mk\_TERM$, $DEST\_TERM$
=ENDDOC
=DOC
val ‚mk_TERM· : DEST_TERM -> TERM;
=DESCRIBE
Create a well-formed TERM from a statement of a top-level structure, and the associated constituent parts.

This may produce terms that are not well-formed within the context of some theories.
=SEEALSO
$dest\_TERM$, $DEST\_TERM$
=FAILURE
3002	Given `Comb(f, x)', where `f' cannot be applied to `x'
3003	Given `Abs(x, b)', where `x' is not a variable
=FAILUREC
Further details of the error will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val ‚type_of· : TERM -> TYPE;
=DESCRIBE
This gives the type of a term.
=ENDDOC
=DOC
val ‚icl'mk_var· : (string * TYPE) -> TERM;
=DESCRIBE
This produces a term with a variable's structure.

This may produce terms that are not well-formed within the context of some theories.
=USES
For producing variable names that are arbitrary strings, in particular for generated variable names.
=SEEALSO
$mk\_var$
=ENDDOC
=DOC
val ‚mk_const· : (string * TYPE) -> TERM;
=DESCRIBE
This produces a term with a constant's structure.

This may produce terms that are not well-formed within the context of some theories.
=FAILURE
3004	The constant name "?0" must be non-empty and must not contain 
	spaces or control characters
=ENDDOC
=DOC
val ‚mk_comb· : (TERM * TERM) -> TERM;
=DESCRIBE
This produces a term with a functional application structure.
=FAILURE
3005	Argument type must be compatible with 
	function type
3006	Operator type must be a function type
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val ‚mk_abs· : (TERM * TERM) -> TERM;
=DESCRIBE
This produces a term with a abstraction's structure.
=FAILURE
3007	An abstraction must have a variable as its first argument.
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val ‚dest_var·: TERM -> (string * TYPE);
=DESCRIBE
Destroys a term with a variable's structure.
=FAILURE
3008	Term is not a variable
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val ‚dest_const·: TERM -> (string * TYPE);
=DESCRIBE
Destroys a term with a constant's structure.
=FAILURE
3009	Term is not a constant
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val ‚dest_comb·: TERM -> (TERM * TERM);
=DESCRIBE
Destroys a term with a function application structure.
=FAILURE
3010	Term is not a function application
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val ‚dest_abs·: TERM -> (TERM * TERM);
=DESCRIBE
Destroys a term with an abstraction's structure.
=FAILURE
3011	Term is not an abstraction
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val ‚is_var· : TERM -> bool;
=DESCRIBE
This function returns true iff. the term has a variable's structure.
=ENDDOC
=DOC
val ‚is_const· : TERM -> bool;
=DESCRIBE
This function returns true iff. the term has a constant's structure.
=ENDDOC
=DOC
val ‚is_comb· : TERM -> bool;
=DESCRIBE
This function returns true iff. the term has a function application structure.
=ENDDOC
=DOC
val ‚is_abs· : TERM -> bool;
=DESCRIBE
This function returns true iff. the term has a variable abstraction's structure.
=ENDDOC
=DOC
val ‚TERM_eq· : (TERM * TERM) -> bool;
=DESCRIBE
The standard equality function upon terms.
=ENDDOC
=DOC
val ‚icl'frees· : TERM -> (string * TYPE) list;
=DESCRIBE
Extract the free term variables within the term argument,
presenting them as destroyed variables.
=USES
For when we know the free variables are to be destroyed to use them.
This function is faster than $frees$.
=SEEALSO
$frees$
=ENDDOC
=DOC
val ‚frees· : TERM -> TERM list;
=DESCRIBE
Extract the free term variables within the term argument.
=SEEALSO
$dest\_frees$
=ENDDOC
=DOC
val ‚is_free_var_in· : (string * TYPE) -> TERM -> bool;
=DESCRIBE
Given a destroyed variable, checks to see if it is free within the term.
=ENDDOC
\subsection{Derived Term Structure Functions}
\subsubsection{Generic Derived Term Structure Functions}
A performance issue arises with the destructor functions for
derived term constructors: need they test the types of constants?
We do not make this test. It is not necessary if the
definition of two constants with the same name is
disallowed.
=DOC
val ‚mk_bin_op· : string -> int -> (TYPE -> TYPE -> TERM) ->
	(TERM * TERM) -> TERM;
=DESCRIBE
$mk\_bin\_op$ $area$ $msg$ $rator$ $(tm_1, tm_2)$ attempts to form the term $tm_1\ rator'\ tm_2$.
$rator'$ is gained by applying $rator$ to the types of $tm_1$ and $tm_2$.
=FAILUREC
\paragraph{Failure}
The failure message for failing to apply $rator$ to its arguments will be from area $area$, and will have the text indexed by $msg$.
=ENDDOC
=DOC
val ‚dest_bin_op· : string -> int -> string -> TERM -> (TERM * TERM);
=DESCRIBE
$dest\_bin\_op$ $area$ $msg$ $rator$ $term$ assumes that $term$ is of the form $tm_1\ rator\ tm_2$, and attempts to return $tm_1$ and
$tm_2$.
=FAILUREC
\paragraph{Failure}
The failure message for failing to apply $rator$ to its arguments will be from area $area$, and will have the text indexed by $msg$.
=ENDDOC
=DOC
val ‚is_bin_op· : (TERM -> 'a) -> TERM -> bool;
=DESCRIBE
$is\_bin\_op$ $dest$ $term$ is true iff. $dest$ can be applied to $term$ without a catchable exception being raised.
=ENDDOC
=DOC
val ‚mk_mon_op· : string -> int -> (TYPE -> TERM) ->
	TERM -> TERM;
=DESCRIBE
$mk\_mon\_op$ $area$ $msg$ $rator$ $rand$ attempts to form the term $rator'\ rand$.
$rator'$ is gained by applying $rator$ to the type of $rand$.
=FAILUREC
\paragraph{Failure}
The failure message for failing to apply $rator$ to its arguments will be from area $area$, and will have the text indexed by $msg$.
=ENDDOC
=DOC
val ‚dest_mon_op· : string -> int -> string -> TERM -> TERM;
=DESCRIBE
$dest\_mon\_op$ $area$ $msg$ $rator$ $term$ assumes that $term$ is of the form $rator\ term$, and attempts to return $term$.
=FAILUREC
\paragraph{Failure}
The failure message for failing to apply $rator$ to its argument will be from area $area$, and will have the text indexed by $msg$.
=ENDDOC
=DOC
val ‚is_mon_op· : (TERM -> 'a) -> TERM -> bool;
=DESCRIBE
$is\_mon\_op$ $dest$ $term$ is true iff. $dest$ can be applied to $term$ without a catchable exception being raised.
=ENDDOC
=DOC
val ‚mk_binder· : string -> int -> (TYPE -> TYPE -> TERM) ->
	(TERM * TERM) -> TERM;
=DESCRIBE
$mk\_binder$ $area$ $msg$ $binder$ $(var,\ body)$ generates the term:
$binder(ç var\ é\ body)$.
=FAILUREC
\paragraph{Failure}
If the term cannot be made, then the error will be from $area$, with a message indexed by $msg$.
=ENDDOC
=DOC
val ‚dest_binder· : string -> int -> string -> TERM -> TERM * TERM;
=DESCRIBE
$dest\_binder$ $area$ $msg$ $binder$ $"binder(ç var é body)"$
will give $(var,\ body)$.
=FAILUREC
\paragraph{Failure}
If the term cannot be destroyed, then the error will be from $area$, with a message indexed by $msg$.
=ENDDOC
=DOC
val ‚is_binder· : (TERM -> 'a) -> TERM -> bool;
=DESCRIBE
$is\_binder$ $dest$ $term$ returns true iff. $dest$ can be applied to $term$ without raising a catchable exception.
=ENDDOC
=DOC
val ‚strip_binder· : (TERM -> bool) -> (TERM -> (TERM * TERM)) ->
	TERM -> TERM list * TERM;
=DESCRIBE
$strip\_binder$ $sel$ $dest$ applied to 
\[bind_1(ç v_1 é bind_2(ç v_2 é \ldots é body)\ldots)\]
where $sel\ bind_1$, $sel\ bind_2$, $\ldots$ are all true,
will return
\[[bind_1, bind_2, \ldots], body\]
=ENDDOC
\subsubsection{Specific Derived Term Structure Functions}
=DOC
val equality : TYPE -> TYPE -> TERM;
=DESCRIBE
Returns the constant "=" upon terms with the first type argument.
The second type is a dummy argument.
=ENDDOC
=DOC
val mk_eq : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating equalities.
=FAILURE
3013	Equality is only between terms of same type
=ENDDOC
=DOC
val ‚dest_eq· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for equalities.
=FAILURE
3014	Term is not an equation.
=ENDDOC
=DOC
val ‚is_eq· : TERM -> bool;
=DESCRIBE
A derived term test for equalities.
=ENDDOC
=DOC
val ‚mk_imp· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating implications.
=FAILURE
3015	Implications are only between boolean terms
=ENDDOC
=DOC
val ‚dest_imp· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for implications.
=FAILURE
3016	Term is not an implication
=ENDDOC
=DOC
val ‚is_imp· : TERM -> bool;
=DESCRIBE
A derived term test for implications.
=ENDDOC
=DOC
val ‚list_mk_imp· : TERM list -> TERM;
=DESCRIBE

ÛDefinition
list_mk_imp ["a","b","c",...] = "a ä b ä c ..."
Ê
=FAILURE
3017	An empty list argument is not allowed
3018	Argument list must be of boolean terms
=ENDDOC
=DOC
val ‚strip_imp· : TERM -> TERM list;
=DESCRIBE

ÛDefinition
strip_imp  "a ä b ä c ..." = ["a","b","c",...]
Ê
=ENDDOC
=DOC
val ‚list_mk_comb· : (TERM * TERM list) -> TERM;
=DESCRIBE

ÛDefinition
list_mk_comb ("body", ["a","b","c",...]) = "body a b c ..."
Ê
=FAILUREC
\paragraph{Failure}
May give rise to the error message from $mk\_abs$.
=ENDDOC
=DOC
val ‚strip_comb· : TERM -> TERM * TERM list;
=DESCRIBE
Splits a term into a head term, that is not an application, and the list of argument terms applied to that head term to form the original term.
=EXAMPLE
strip_comb "f (1+2) 3 4 5" = ("f", ["1+2", "3", "4", "5"])
=ENDDOC
=DOC
val ‚mk_neg· : TERM -> TERM;
=DESCRIBE
A derived term construction function for generating negations.
=FAILURE
3019	Negations are only on boolean terms
=ENDDOC
=DOC
val ‚dest_neg· : TERM -> TERM;
=DESCRIBE
A derived term destructor function for negations.
=FAILURE
3020	Term is not a negation
=ENDDOC
=DOC
val ‚is_neg· : TERM -> bool;
=DESCRIBE
A derived term test for negations.
=ENDDOC
=DOC
val ‚comma· : TYPE -> TYPE -> TERM;
=DESCRIBE
$comma$ $ty_1$ $ty_2$ generates a constant  ",", of type
$ty_1 ã ty_2 ã (ty_1 â ty_2)$.
=ENDDOC
=DOC
val ‚mk_pair· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating pairs.
=ENDDOC
=DOC
val ‚dest_pair· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for pairs.
=FAILURE
3021	Term is not a pair
=ENDDOC
=DOC
val ‚is_pair· : TERM -> bool;
=DESCRIBE
A derived term test for pairs.
=ENDDOC
=DOC
val ‚mk_conj· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating conjunctions.
=FAILURE
3022	A conjunction must be between booleans
=ENDDOC
=DOC
val ‚dest_conj· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for conjunctions.
=FAILURE
3023	Term is not a conjunction.
=ENDDOC
=DOC
val ‚is_conj· : TERM -> bool;
=DESCRIBE
A derived term test for conjunctions.
=ENDDOC
=DOC
val ‚list_mk_conj· : TERM list -> TERM;
=DESCRIBE

ÛDefinition
list_mk_conj ["a","b","c",...] = "a Ä b Ä c ..."
Ê
=FAILURE
3017	An empty list argument is not allowed
3025	Argument list must be of boolean terms.
=ENDDOC
=DOC
val ‚mk_disj· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating disjunctions.
=FAILURE
3026	A disjunction must be between booleans
=ENDDOC
=DOC
val ‚dest_disj· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for disjunctions.
=FAILURE
3012	Term is not a disjunction.
=ENDDOC
=DOC
val ‚is_disj· : TERM -> bool;
=DESCRIBE
A derived term test for disjunctions.
=ENDDOC
=DOC
val ‚list_mk_disj· : TERM list -> TERM;
=DESCRIBE

ÛDefinition
list_mk_disj ["a","b","c",...] = "a Å b Å c ..."
Ê
=FAILURE
3017	An empty list argument is not allowed
3025	Argument list must be of boolean terms.
=ENDDOC
=DOC
val ‚mk_iff· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating iff. terms.
=FAILURE
3029	iff must be between booleans
=ENDDOC
=DOC
val ‚dest_iff· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for iff.
=FAILURE
3030	Term is not a iff
=ENDDOC
=DOC
val ‚is_iff· : TERM -> bool;
=DESCRIBE
A derived term test for iff.
=ENDDOC
=DOC
val ‚quantifier· : string -> TYPE -> TYPE -> TERM;
=DESCRIBE
$quantifier$ $name$ $type$ $dummy$ returns a constant, with the given name, and type $: (type ã BOOL) ã BOOL$.
=ENDDOC
=DOC
val ‚mk_let· : (TERM * TERM * TERM) -> TERM
=DESCRIBE
A derived term construction function for generating local definitions.
=EXAMPLE
mk_let(x, 1, (x+1)) = (let x = 1 in x + 1)
=FAILURE
3031	First argument must be a term variable
3032	First and second arguments must have same type 
=ENDDOC
=DOC
val ‚dest_let· : TERM -> (TERM * TERM * TERM);
=DESCRIBE
A derived term destructor function for local definitions.
=FAILURE
3033	Term is not a local definition
=ENDDOC
=DOC
val ‚is_let· : TERM -> bool;
=DESCRIBE
A derived term test for local definitions.
=ENDDOC
=DOC
val ‚mk_enum_set· : TERM list -> TERM
=DESCRIBE
A derived term construction function for generating enumerated set definitions.
The argument is a list of the members of the set.
=FAILURE
3034	Elements of list must all be of one type
=ENDDOC
=DOC
val ‚dest_enum_set· : TERM -> (TERM list);
=DESCRIBE
A derived term destructor function for enumerated sets.
=FAILURE
3035	Term is not an enumerated set
=ENDDOC
=DOC
val ‚is_enum_set· : TERM -> bool;
=DESCRIBE
A derived term test for enumerated sets.
=ENDDOC
=DOC
val ‚mk_set· : (TERM * TERM) -> TERM
=DESCRIBE
A derived term construction function for generating set comprehensions.
=EXAMPLE
mk_set (x, x > 5) = (ç x é x > 5)
=FAILURE
3036	Second argument must be boolean
=ENDDOC
=DOC
val ‚dest_set· : TERM -> (TERM list);
=DESCRIBE
A derived term destructor function for set comprehensions.
=FAILURE
3037	Term is not a set comprehension.
=ENDDOC
=DOC
val ‚is_set· : TERM -> bool;
=DESCRIBE
A derived term test for set comprehensions.
=ENDDOC
=DOC
val ‚mk_list· : TERM list -> TERM
=DESCRIBE
A derived term construction function for generating lists.
The argument is a list of the members of the list.
=FAILURE
3034	Elements of list must all be of one type
=ENDDOC
=DOC
val ‚dest_list· : TERM -> (TERM list);
=DESCRIBE
A derived term destructor function for lists.
=FAILURE
3039	Term is not a list
=ENDDOC
=DOC
val ‚is_list· : TERM -> bool;
=DESCRIBE
A derived term test for lists.
=ENDDOC
=DOC
val ‚strip_forall· : TERM -> (TERM list * TERM);
=DESCRIBE

ÛDefinition
strip_forall "É a b c ... é body = ["a","b","c",...], body
Ê
=ENDDOC
=DOC
val ‚mk_forall· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating foralls.
=FAILURE
3040	Argument must have the form: (variable, boolean term)
=ENDDOC
=DOC
val ‚dest_forall· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for foralls.
=FAILURE
3041	Term is not a forall
=ENDDOC
=DOC
val ‚is_forall· : TERM -> bool;
=DESCRIBE
A derived term test for forall.
=ENDDOC
=DOC
val ‚list_mk_forall· : TERM list * TERM -> TERM;
=DESCRIBE

ÛDefinition
list_mk_forall ["a","b","c",...] body = "É a b c ... é body"
Ê
=FAILURE
3042	Argument list must be of term variables
=ENDDOC
=DOC
val ‚strip_forall· : TERM -> (TERM list * TERM);
=DESCRIBE

ÛDefinition
strip_forall "É a b c ... é body = ["a","b","c",...], body
Ê
=ENDDOC
=DOC
val ‚mk_exist· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating exists.
=FAILURE
3040	Argument must have the form: (variable, boolean term)
=ENDDOC
=DOC
val ‚dest_exist· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for exists.
=FAILURE
3044	Term is not an exist
=ENDDOC
=DOC
val ‚is_exist· : TERM -> bool;
=DESCRIBE
A derived term test for exist.
=ENDDOC
=DOC
val ‚list_mk_exist· : TERM list * TERM -> TERM;
=DESCRIBE

ÛDefinition
list_mk_exist ["a","b","c",...] body = "Ñ a b c ... é body"
Ê
=FAILURE
3042	Argument list must be of term variables
=ENDDOC
=DOC
val ‚strip_exist· : TERM -> (TERM list * TERM);
=DESCRIBE

ÛDefinition
strip_exist "Ñ a b c ... é body = ["a","b","c",...], body
Ê
=ENDDOC
=DOC
val ‚mk_select· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating selects.
=FAILURE
3040	Argument must have the form: (variable, boolean term)
=ENDDOC
=DOC
val ‚dest_select· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for selects.
=FAILURE
3047	Term is not a select
=ENDDOC
=DOC
val ‚is_select· : TERM -> bool;
=DESCRIBE
A derived term test for select.
=ENDDOC
=DOC
val ‚list_mk_select· : TERM list * TERM -> TERM;
=DESCRIBE

ÛDefinition
list_mk_select ["a","b","c",...], "body" = "á a b c ... é body"
Ê
=FAILURE
3042	Argument list must be of term variables
=ENDDOC
=DOC
val ‚strip_select· : TERM -> (TERM list * TERM);
=DESCRIBE

ÛDefinition
strip_select "á a b c ... é body" = ["a","b","c",...], "body"
Ê
=ENDDOC
=DOC
val ‚list_mk_abs· : (TERM list * TERM) -> TERM;
=DESCRIBE

ÛDefinition
list_mk_abs (["a","b","c",...], "body") = ç a b c ... é body
Ê
=FAILUREC
\paragraph{Failure}
May give rise to the error message from $mk\_abs$.
=ENDDOC
=DOC
val ‚strip_abs· : TERM -> (TERM list * TERM);
=DESCRIBE

ÛDefinition
strip_abs "ç a b c ... é body" = ["a","b","c",...], "body"
Ê
=ENDDOC
=DOC
val ‚mk_If· : (TERM * TERM * TERM) -> TERM;
=DESCRIBE
$mk\_If$ $(c,\ y,\ n)$ gives the term $if\ c\ then\ y\ else\ c$.
=FAILURE
3049	First argument must be a boolean term
3050	Second and third arguments must have the same type
=ENDDOC
=DOC
val ‚dest_If· : TERM -> (TERM * TERM * TERM);
=DESCRIBE
Destroys a term of the form $if\ c\ then\ y\ else\ c$.
=FAILURE
3051	Term is not a conditional
=ENDDOC
=DOC
val ‚is_If· : TERM -> bool;
=DESCRIBE
A test for conditionals.
=ENDDOC
\subsection{Other Term Functions}
=DOC
val ‚aconv· : TERM -> TERM -> bool;
=DESCRIBE
Tests whether two terms are alpha-convertable, that is it only differs by the names of bound variables.
=ENDDOC
=DOC
val ‚icl'variant· : ((string * TYPE) list) -> (string * TYPE) -> string;
=DESCRIBE
$dest\_variant$ $vlist$ $(name,\ type)$ returns a string that is a variant of any name in $vlist$ with the associated type $type$.
Variants are formed by repeatedly priming $name$.
Note that $dest\_variant$ $[]$ $(name,\ type)$ gives $name$.
=USES
Somewhat faster than $variant$ if term variables are already destroyed.
=SEEALSO
$variant$
=ENDDOC
=DOC
val ‚icl'subst· : (TERM * (string * TYPE)) list -> TERM -> TERM;
=DESCRIBE
$icl'subst$ $alist$ $term$ returns a term based on $term$, but with with any term variable that may be found in the association list
(in a destroyed form) being replaced with the associated term.
=FAILURE
3052	Invalid types in term substitution
=ENDDOC
=DOC
val ‚rename· : (string * TYPE) -> string -> TERM -> TERM;
=DESCRIBE
$rename$ $(cname,\ type)$ $oname$ $term$ returns a term based on $term$, but with any variables with name $oname$ renamed to $cname$.
=ENDDOC
=DOC
val ‚icl'inst· : (string * TYPE) list -> (TYPE * string) list -> TERM -> TERM;
=DESCRIBE
$icl'inst$ $alist$ $slist$ $term$ instantiates the type variables of $term$ with the associated types found in $slist$ (which is indexed by the type variables name, not the type variables themselves).
It will rename bound variables as necessary to prevent name capture problems.
It will also not allow variables to become the same as those in the avoidance list, $alist$.
=USES
Somewhat faster than $inst$ if type variables are already destroyed.
=SEEALSO
$inst$
=ENDDOC
=DOC
val ‚term_types· : TERM -> TYPE list;
=DESCRIBE
Gives a list of all the types of constants, variables or abstraction variables within the term argument.
=ENDDOC
=DOC
val ‚term_tyvars· : TERM -> string list;
=DESCRIBE
Returns the list of type variable names present in types present within a term.
=ENDDOC
=DOC
val ‚term_constants· : TERM -> (string * TYPE) list;
=DESCRIBE
This function extracts the subterms of a term which
are constants, giving destroyed constants in each case.
=ENDDOC
=DOC
val ‚type_match· : TYPE -> TYPE -> (TYPE * TYPE)list;
=DESCRIBE
$type\_match$ $ty_1$ $ty_2$ attempts to find if $ty_1$ is an instance of $ty_2$.
If so, then it returns a list giving the correspondence between
types in $ty_1$ with type variables in $ty_2$.
Trivial (i.e. (x,x)) correspondences are not noted.
=FAILURE
3053	The first type is not an instance of the second
=ENDDOC
=DOC
val ‚term_match· : TERM -> TERM -> (TYPE * TYPE) list * (TERM * TERM)list;
=DESCRIBE
$term\_match$ $tm_1$ $tm_2$ attempts to find if $tm_1$ is an instance of $tm_2$.
If so, then it returns two list.
The first gives the correspondence between types in $tm_1$ with type variables in $tm_2$.
The second gives the correspondence between terms in $tm_1$ with free variables in $tm_2$.
Trivial (i.e. (x,x)) correspondences are not noted.
=FAILURE
3054	The first term is not an instance of the second
=ENDDOC
=DOC
val ‚is_type_instance· : TYPE -> TYPE -> bool;
=DESCRIBE
$is\_type\_instance$ $ty_1$ $ty_2$ returns true iff $ty_1$ is an instance of $ty_2$.
=ENDDOC
=DOC
val ‚genvar· : TYPE -> TERM;
=DESCRIBE
Each application of $gen\_var$ returns a variable whose
is different from that returned by any other application.
The variable name starts with a space so that the variable
name will also be different from that of any variable
constructed with $mk\_var$. 
=ENDDOC
=DOC
val ‚mk_var· : (string * TYPE) -> TERM;
=DESCRIBE
If the string is non-empty, and doesn't contain spaces, then a HOL term variable is formed in the obvious way from the argument.
=FAILURE
3055	Variable name ?0 must be non-empty and must not contain spaces or control characters
=ENDDOC
=DOC
val ‚variant· : TERM list -> TERM -> TERM;
=DESCRIBE
$variant$ $stoplist$ $v$ returns a variant of $v$ that is not present in the $stoplist$.
The variants are generated by sufficient priming.
=FAILURE
3056	Second argument is not a variable
3057	First argument is not a list of term variables
=ENDDOC
=DOC
val ‚list_variant· : TERM list -> TERM list -> TERM;
=DESCRIBE
$list\_variant$ $stoplist$ $vlist$ returns a list of variants that are not present in the $stoplist$, one for each member of $vlist$.
The variants are generated by sufficient priming.
=FAILURE
3058	Second argument is not a list of term variables
3059	First argument is not a list of term variables
=ENDDOC
=DOC
val ‚is_free_in· : TERM -> TERM -> bool;
=DESCRIBE
$is\_free\_in$ $v$ $term$ is true iff. $v$ is a free variable in
$term$.
=ENDDOC
=DOC
val ‚frees· : TERM -> TERM list;
=DESCRIBE
Lists the free variables of a term.
=ENDDOC
=DOC
val ‚var_subst· : (TERM * TERM) list -> TERM -> TERM;
=DESCRIBE
$var\_subst$ $alist$ $term$ returns the term formed by, for each pair in $alist$, substituting in $term$ all instances of the term variable which is the first of the pair with the second of the pair.
=FAILURE
3060	The first of each pair in the substituition list must be a term variable
=SEEALSO
$subst$
=ENDDOC
=DOC
val ‚subst· : (TERM * TERM) list -> TERM -> TERM;
=DESCRIBE
$subst$ $alist$ $term$ returns the term formed by, for each pair in $alist$, substituting in $term$ all instances of the term which is the first of the pair with the second of the pair.
=SEEALSO
$var\_subst$
=ENDDOC
=DOC
val ‚TERM_map· : ((TERM list) -> TERM -> TERM) -> TERM -> TERM;
=DESCRIBE
$TERM\_map$ $tmfun$ $tm$ traverses
$tm$ (breadth first) looking for subterms for which
the application $tmfun\,tm$ does not fail and replaces
such subterms with $tmfun\,tm$. $tmfun$ has as its first argument a list giving
the bound variables which are in scope at the point of use.
=ENDDOC
=DOC
val ‚inst· : TERM list -> (TYPE * TYPE) list -> TERM -> TERM;
=DESCRIBE
$inst$ $alist$ $slist$ $term$ instantiates the type variables of $term$ with the associated types found in $slist$.
It will rename bound variables as neccesary to prevent name capture problems.
It will also not allow variables to become the same as those in the avoidance list, $alist$.
=FAILURE
3061	First argument must be a list of term variables
=ENDDOC
=SML
end(* signature of TypesAndTerms *);
=TEX
\section{TESTING}
???
\end{document}
