=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Module Tests for Tactics I}
\TPPref{DS/FMU/IED/MDT009}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{91/03/11 %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the module tests for the 
first group of tactics and tacticals in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
\end{description}
\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the module tests for the material
whose detailed design is given in in \cite{DS/FMU/IED/DTD009}.
\subsection{Introduction}
\subsubsection{Purpose and Background}

\subsubsection{Dependencies}

\subsubsection{Deficiencies}
\section{TEST CASES}
\begin{description}
\item[Group 1]
This checks the trivial tactics.
\end{description}
\section{PREAMBLE}
=SML
open_theory"misc";
new_theory"tst009";
open Tactics1;
init_mt_results();
=TEX
=SML
fun forge_seq ((asms, conc) : GOAL) : THM = (
	let	val tm = list_mk_ä (asms @ [conc]);
		val key = format_list Combinators.I (PrettyPrinter.format_term tm)"";
		val thm = (get_axiom "-" key) handle Fail _ => new_axiom(key, tm);
		fun aux [] thm = thm
		|   aux (_ :: more) thm = aux more (undisch_rule thm);
	in	aux asms thm
	end
);
=SML
fun forge_tac (tac : TACTIC) (gl : GOAL) : GOAL list * SEQ = (
	let	val (sgs, pf) = tac gl;
	in	(sgs, dest_thm(pf (map forge_seq sgs)))
	end		
);
=TEX
=SML
fun chk_res ((sgs1:GOAL list, (asms1, conc1):SEQ), (sgs2:GOAL list, (asms2, conc2):SEQ)) : bool = (
	sgs1 = sgs2 andalso aconv conc1 conc2 andalso
	length asms1 = length asms2 andalso all (combine asms1 asms2)(uncurry aconv)
);
=TEX
\section{TEST CODE AND DATA}
\section{Group 1}
=SML
val gl1_1 = ([ªb:BOOLº, ªa:BOOLº], ªa Ä bº);
val gl1_2 = ([ªb:BOOLº, ªa:BOOLº], ª(çxéx)a Ä bº);
val gl1_3 = dest_thm bool_cases_axiom;
val tm1_2 = ª(çyéy)a Ä bº;
val sg1_2 = ([ªb:BOOLº, ªa:BOOLº], tm1_2);
store_mt_results_show (mt_runf chk_res)
[
 ("Tactics1.1.1", forge_tac always_tac, gl1_1, ([gl1_1], gl1_1)),
 ("Tactics1.1.2", forge_tac (accept_tac(asm_rule tm1_2)), gl1_2, ([sg1_2], gl1_2)),
 ("Tactics1.1.2", forge_tac (accept_tac bool_cases_axiom), gl1_3, ([], gl1_3))
];
=TEX
\section{Group 2}
=SML
val tm2_1 = ª(çzéz)a Ä bº;
val sg2_1 = ([ªb:BOOLº, ªa:BOOLº], tm2_1);
val sg2_2 = ([], ªX:BOOLº);
val tm2_2 = ªA1:BOOLº;
val tm2_3 = ªA2:BOOLº;
val tm2_4 = ªA3:BOOLº;
val tac2_1 = accept_tac o asm_rule;

store_mt_results_show (mt_runf chk_res)
[
 ("Tactics1.2.1", forge_tac(always_tac THEN always_tac), gl1_1, ([gl1_1], gl1_1)),
 ("Tactics1.2.2", forge_tac (accept_tac(asm_rule tm1_2) THEN accept_tac(asm_rule tm2_1)), gl2, ([sg3], gl2)),
 ("Tactics1.2.3", forge_tac (accept_tac bool_cases_axiom THEN fail_tac), gl1_3, ([], gl1_3)),
 ("Tactics1.2.4", forge_tac (accept_tac bool_cases_axiom ORELSE fail_tac), gl1_3, ([], gl1_3)),
 ("Tactics1.2.5", forge_tac (fail_tac ORELSE accept_tac bool_cases_axiom), gl1_3, ([], gl1_3)),
 ("Tactics1.2.6", forge_tac (EVERY[accept_tac bool_cases_axiom, fail_tac]), gl1_3, ([], gl1_3)),
 ("Tactics1.2.7", forge_tac (EVERY[accept_tac(asm_rule tm1_2), accept_tac(asm_rule tm2_1)]), gl1_3, ([], gl1_3))
];
=TEX
\printindex
\end{document}


=IGN
val gl1 = ([ª(çxéx = x)yº, ªa:BOOLº], ªTº);
val gl2 = ([ª(çxéx = x)º, ªa:BOOLº], ªTº);


simple_tac_proof(gl1, accept_tac (asm_intro ª(çyéy=y)yºt_thm));
simple_tac_proof(gl2, accept_tac (t_thm));

tac_proof(gl1, accept_tac (asm_intro ª(çyéy=y)yºt_thm));
tac_proof(gl1, accept_tac (asm_intro ª(çyéy=y)yº(asm_introªa:BOOLºt_thm)));
tac_proof(gl2, accept_tac (asm_intro ª(çyéy=y)yºt_thm));
