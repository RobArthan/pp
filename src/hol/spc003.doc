=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{HOL Formalised: Deductive System}  %% Mandatory field
\TPPref{DS/FMU/IED/SPC003}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This is part of a suite of documents giving a formal
specification of the HOL logic. It defines the primitive
inference rules, including conservative extension mechanisms.
Related notions such as derivability are also defined.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion \FormatDate{$Date$%
}] First draft issue.
\end{description}
\subsection{Changes forecast}
When a little extra proof support is available for
reasoning with strings, the consistency proof for the definition
of the type $THM$ may be included here.

It may be desirable to improve the readability of the
definitions of the object language constructs in
section \ref{DEFINITIONS} by a trick using antiquotation
and the HOL parser to enter the necessary terms.

\newpage
\section{GENERAL}
\subsection{Scope}
This document specifies the HOL deductive system.
Some high level aspects of the implementation
of the proof development system are also discussed.
It is part of a suite of documents specifying the HOL
logic, an overview of which may be found in \cite{DS/FMU/IED/SPC001}.

\subsection{Introduction}

In  \cite{DS/FMU/IED/SPC001} a brief theoretical
discussion of the definition of deductive systems is
given. In this document we fill in the details for HOL.

The first task is to define the rules of inference.
HOL has five rules
of inference: $ABS$, $DISCH$, $INST\_TYPE$, $MP$, $SUBST$
(defined in section \ref{RULESOFINFERENCE} below)
and three axiom schemata: $ASSUME$, $BETA\_CONV$ and $REFL$
(defined in section \ref{AXIOMSCHEMATA}).
We follow \cite{SRI89a} in treating the axiom schemata
just like unary rules of inference.
Such rules are a convenient home
for infinite families of axioms that we wish to have in every theory.

With the rules of inference
in hand, we define derivability in section
\ref{DERIVABILITY}.
We then define the type of theorems of HOL as those pairs
$(s, T)$ where $T$ is a theory and $s$ is a sequent in the
language of $T$ derivable from the axioms of $T$.

Section \ref{CONSISTENCY},
defines the type of all theorems and
specifies the notions of consistency and conservative
extension.

Mechanisms for extending theories by
making definitions are of great practical
importance, particularly those which preserve consistency.
Section \ref{DEFINITIONS} discusses
the means by which theories may be extended in the HOL
system. Of particular importance are certain mechanisms
for introducing new constants and types.

In section \ref{INIT} we define the individual axioms
of the HOL logic.
The resulting theory is of special
interest, as are what we call its definitional extensions,
which we define in section \ref{DEFINITIONALEXTENSIONS}:
they are all consistent and have
a common standard set-theoretic model;
their theorems comprise what are normally taken to
be the theorems of HOL by those who shun axiomatic
extensions.




\section{PREAMBLE}

\Hide{
extend_theory"spc003";
}
We introduce the new theory. Its parent is
the theory $spc001$ which contains definitions concerned
with the HOL language.
Â
close_theory();
load_theory"spc001";
new_theory"‚spc003·";
Ê

\section{THE RULES OF INFERENCE} \label{RULESOFINFERENCE}

In this section we treat the syntax manipulating
functions required to define the various rules of
inference. We consider each inference rule in turn.
In the HOL system the inference rules are functions
which take theorems (and other things) as arguments
and return theorems. Since we cannot define
the type of theorems until we have defined the inference
rules we define the rules as functions taking
sequents (and other things) as arguments and returning
sequents.

\subsection{Free Variables}

{\it freevars\_list} returns the free variables of a term
listed in order of first appearance (from left to
right in the usual concrete syntax).

»
	‚freevars_list·: TERM ã ((string â TYPE)list)
…
	É(tm : TERM)(s : string) (ty : TYPE) (f : TERM)
	(a : TERM) (vty : TERM) (b : TERM) é
	freevars_list (mk_var(s, ty)) = [(s, ty)]
	Ä
	freevars_list (mk_const(s, ty)) = []
	Ä
	(has_mk_comb(f, a) tm ä freevars_list tm = freevars_list f µ freevars_list a)
	Ä
	((has_mk_abs(vty, b) tm Ä mk_var(s, ty) = vty) ä
		freevars_list tm = freevars_list b ¡ (çxéx à (s, ty)))
À
{\it freevars\_set} returns the set of free variables
of a term.
We use it in cases where the order of appearance
of the free variables in the term is immaterial.

»
	‚freevars_set·: TERM ã (string â TYPE) ã bool
…
	É(tm : TERM)éfreevars_set tm = elems(freevars_list tm)
À


\subsection{Object Language Constructs}

To define the rules of inference we need to form
certain object language types and terms.
We have already defined the function space type
constructor.
The other definitions needed are given in this
section.


We need to form instances of the polymorphic constant
``='':

»
	‚Equality· : TYPE ã TERM
…
	É ty é Equality ty = mk_const(`=`, Fun ty (Fun ty Bool))
À

The following is our analogue of the derived
constructor function for equations in the HOL system.

»
	‚has_mk_eq· : (TERM â TERM) ã TERM ã bool
…
	É lhs rhs tm é has_mk_eq(lhs, rhs) tm =
	(Ñ tm2 é
		has_mk_comb(Equality(type_of_term lhs), lhs) tm2
	Ä	has_mk_comb(tm2, rhs) tm)
À

We also need to form implications. The following functions
are analogous to those treating equality above.
»
	‚Implication· : TERM
…
	Implication = mk_const(`ä`, Fun Bool (Fun Bool Bool))
À

»
	‚has_mk_imp· : (TERM â TERM) ã TERM ã bool
…
	É lhs rhs tm é has_mk_imp(lhs, rhs) tm =
	(Ñ tm2 é
		has_mk_comb(Implication, lhs) tm2
	Ä	has_mk_comb(tm2, rhs) tm)
À


\subsection{Substitution of Equals}

In this section we define the inference rule {\it SUBST}.

In essence, {\it SUBST} says that given a
theorem whose conclusion is an equation, ${\cal A} = {\cal B}$, where
$\cal A$ and $\cal B$ are arbitrary terms of the same
type, and given any other theorem with conclusion
$\cal C$, we may obtain a new theorem by substituting
$\cal B$ for 
any subterm of $\cal C$ which is identical with $\cal A$. This is subject to the proviso that no variable
capture problems arise, i.e. no
free variables of $\cal B$ should become bound in the
conclusion of the new theorem. (The assumption set of the
consequent theorem is the union of the assumption sets of
the antecedent theorems.)

The inference rule is, in fact, slightly more
general. It allows one to use a whole set of theorems
whose conclusions are equations to perform (simultaneous)
substitutions for many subterms of $\cal C$. Moreover,
it is implemented as a functional relation, effectively by
renaming any bound variables of $\cal C$ which would
give rise to the capture problem.

The inference rule is parametrised by a template term
and a set of some of its free variables, one for each equation.
The actual statement of the rule is, essentially, that, 
if the result of substituting the left hand sides
of the equations for the corresponding variables
in the template term
is equal to $\cal C$ ({\it modulo} renaming bound
variables), then we may infer the result of substituting
the right hand sides of the equations for the
corresponding template variables in the template term
(providing we rename bound variables to avoid the capture
problem).


The notions we must formalise are therefore:
(i) substituting terms for
free variables in a term according to a given mapping
of variables to terms renaming bound variables
as necessary to avoid variable capture;
(ii) testing equivalence of
terms {\it modulo} renaming of bound variables (aka.
$\alpha$-conversion).

\subsubsection{Substitution}

We will need to choose new names for variables.
More precisely,
given a variable and a set of same we will
wish to rename the variable, when necessary,
to ensure that the result
does not lie in the set.
In practice in an implementation we would insist that the new name
be derived from the old one in a specified way.

»
	‚variant· : ((string â TYPE) ã bool) ã (string â TYPE) ã string
…
	É vs v ty é ((v, ty) ì vs) => (variant vs (v, ty) = v) | (variant vs (v, ty), ty) ì vs
À


Now we can define $subst$. Given a function $R$
associating free variables with terms,
$subst\,R\,t1$ is the
term resulting from replacing every free variable
$mk\_var(s, t)$
in {\it t1} by $\it R(mk\_var(s, t))$ with bound
variables renamed as necessary to avoid capture.
Variables which are not to be changed correspond
to pairs $(s, t)$ with $R (s, t) =  mk\_var (s, t)$.

Note $R$ here is intended to respect types, in the
sense that
$És tyétype\_of\_term(R(s,ty)) = ty$, but this is not
checked here (since it is convenient for $subst$ to be
a total function). This property should be checked whenever
$subst$ is used.

The only difficult case in $subst$ is when the
second argument is an abstraction. In this case we
calculate the variables which must not get captured (this
is the value $new\_frees$ below) and use $variant$ to
give an alternative name for the bound variable if necessary.
We then perform the substitution on the body using
a function, $RR$, which is $R$ modified to send the
old bound variable to the new one.

»
	‚subst· : ((string â TYPE) ã TERM) ã TERM ã TERM
…
	É (R :(string â TYPE) ã TERM) (tm : TERM)
	(s : string) (ty : TYPE) (vty : TERM)
	(f : TERM) (a : TERM) (b : TERM)
	é
	subst R (mk_var(s, ty)) = R(s,ty)
	Ä
	subst R (mk_const(s, ty)) = mk_const(s, ty)
	Ä
	(has_mk_comb(f, a) tm ä
	(subst R tm = átéhas_mk_comb(subst R f, subst R a)t))
	Ä
	((has_mk_abs(vty, b) tm Ä mk_var(s, ty) = vty) ä
	(subst R tm =
		let new_frees = £(image (freevars_set o R) (freevars_set b ƒ singleton_set (s, ty)))
		in  let s' = variant new_frees (s, ty)
		in let RR = çxé (x = (s, ty)) => mk_var (s', ty) | R x
		in
			áté
			has_mk_abs
			(mk_var(s', ty), subst RR b)t
	))
À

The special case of substitution
where we simply wish to rename a variable
is needed in the definition of our $\alpha$-conversion
test and elsewhere.
The following function $rename$ is used for this purpose.
$rename (v, ty) w\, e$ is the result of changing
the name in every free occurrence of the
variable with name $v$, and type $ty$, in the
term $e$, to $w$, renaming any bound variables
as necessary.

»
	‚rename· : (string â TYPE) ã string ã TERM ã TERM
…
	É
	(v : string) (ty : TYPE) (w: string)
	é
	rename (v, ty) w =
	subst
	(çxéx = (v, ty) => mk_var(w, ty) | mk_var x)
À


\subsubsection{$\alpha$-conversion}
Our $\alpha$-conversion test is as follows:
»
	‚aconv· : TERM ã TERM ã bool
…
	É(t1 : TERM) (t2 : TERM)é
	aconv t1 t2 Ç
		(t1 = t2)
	Å	(Ñt1f t1a t2f t2aé
			has_mk_comb(t1f, t1a)t1
		Ä	has_mk_comb(t2f, t2a)t2
		Ä	aconv t1f t2f Ä aconv t1a t2a)
	Å	(Ñv1 v2 ty v1ty v2ty b1 b2é
			has_mk_abs(v1ty, b1)t1	Ä	has_mk_abs(v2ty, b2)t2
		Ä	mk_var(v1, ty) = v1ty	Ä	mk_var(v2, ty) = v2ty
		Ä	aconv b1 (rename (v2, ty) v1 b2)
		Ä	((v1 = v2) Å ((v1, ty) ì freevars_set b2)))
À

\subsubsection{The Inference Rule $SUBST$}
We can now define the inference rule.
Its first argument gives the correspondence between the
template variables and equation theorems.
We could take this argument to 
behave as {\it REFL\_axiom o mk\_var} on variables which
are not template variables . 
Note that, to allow implementation as a partial function,
we test up to $\alpha$-convertibility on the first
sequent argument only.
Note also that the way that the first argument to $subst$
is constructed by dismantling equations ensures that
it respects types.
»
	‚SUBST_rule· : ((string â TYPE) ã SEQ) ã
			TERM ã SEQ ã SEQ ã bool
…
	É eqs tm old_asms old_conc new_asms  new_concé
	SUBST_rule eqs tm (old_asms, old_conc) (new_asms, new_conc) = 
	(Év ty é 
		Ñlhs rhsé
		has_mk_eq(lhs, rhs)(concl(eqs(v, ty))) Ä
		(type_of_term lhs = ty))
	Ä
	(aconv old_conc (subst(ç(v,ty)éálhséÑrhséhas_mk_eq(lhs, rhs)(concl(eqs(v,ty))))tm))
	Ä
	(new_conc = subst (ç(v,ty)éárhséÑlhséhas_mk_eq(lhs, rhs)(concl(eqs(v,ty))))tm)
	Ä
	(new_asms = old_asms ° £ (çasmséÑvtyéasms = (hyp (eqs vty))))
À

\subsection{Abstraction: ABS}

Again {\it ABS} is a partial function which we
specify as a relation:

»
	‚ABS_rule· : (string â TYPE) ã SEQ ã SEQ ã bool
…
	É vty old_asms old_conc new_asms new_conc é
	ABS_rule vty (old_asms, old_conc) (new_asms, new_conc) =
	(Ñ old_lhs old_rhs new_lhs new_rhs vé
		has_mk_eq(old_lhs, old_rhs)old_conc Ä
		has_mk_eq(new_lhs, new_rhs)new_conc Ä
		mk_var vty = v Ä
		has_mk_abs(v, old_lhs) new_lhs Ä
		has_mk_abs(v, old_rhs) new_rhs)
	Ä
	(vty ì £(image freevars_set old_asms))
	Ä
	(new_asms = old_asms)
À



\subsection{Type Instantiation}

The ability to prove and use general (polymorphic)
theorems  is one of the great strengths of the HOL
system. The feature in the inference system which
gives this strength is the inference rule {\it INST\_TYPE}
which allows us to instantiate the type variables
in the conclusion of a polymorphic theorem.

In essence, the inference rule says that, given a theorem
with conclusion, $\cal A$, say, we may infer the theorem
which has the same assumption set and whose conclusion
results from instantiating every type in $\cal A$
according to a given mapping of type variables to types.
This is subject to two provisos: (i) no type variable may
be changed which appears in the assumption set for the
theorem; (ii) no two variables in the assumptions or
conclusion of the antecedent theorem, which are
different, by virtue of their type,  should become
identified in the consequent theorem as a result of
the transformation.

The first proviso is, we believe, only enforced to preserve
a convention of natural deduction systems,
whereby inference rules
involve only simple set operations on the assumption
sets. It would seem to be quite in order for the first
proviso to be dropped provided we insisted that the
type instantiation be applied to every term in the sequent
(we have, of course, not done this).

The second proviso cannot be avoided. Consider for
example: $ç(x:**)éç(x:*)é(x:**)$. If the types in this were
instantiated according to $\{:** ó :*, :* ó :*\}$,
then from:
$$Ö É(y:**)(z:*)é(ç(x:**)éç(x:*)é(x:**))y z = y$$
we could infer that:
$$Ö É(y:*)(z:*)é(ç(x:*)éç(x:*)é(x:*))y z = y$$
whence, by $\beta$-conversions:
$$Ö É(y:*)(z:*)éz = y.$$
This leads to a contradiction whenever $:*$ is instantiated
to a type with more than one inhabitant.

To permit an implementation which is convenient to use,
the inference rule is actually formulated without the
second proviso. Instead, variables (both free and bound,
in general) in the conclusion of the consequent theorem,
which would violate the rule are renamed to
avoid the problem. It is valid to rename free variables
in these circumstances, given the first proviso, since
the variables in question cannot occur free in the
assumption set. Note that it would be invalid to
rename free variables in $\cal A$
which are not changed by the type instantiation
(since these may appear free in the assumption set).

Formalising these notions is a little tricky. We present
here a highly unconstructive specification, reminiscent
of $\alpha$-conversion.
The notion to be formalised is the predicate on
pairs of terms which says whether one is a type instance
of another according to a given mapping of type
variables to types and with respect to a set of
variables with which clashes must not occur (this
will be the set of free variables of the assumptions
in practice).

It is entertaining and instructive to consider
algorithms meeting these specifications.

\subsubsection{Instantiation of Terms}

Instantiation of terms is a little tricky.
The following two functions should be viewed as
local to the function {\it inst}.
{\it inst\_loc1} is very similar to an
$\alpha$-convertibility test. Indeed {\it aconv} could
have been defined as $\it inst\_loc1\,I$.
The first {\it TERM} argument of {\it inst\_loc1}
and {\it inst\_loc2}
gives the terms whose types are being instantiated (i.e.
it is the ``more polymorphic'' term).

$inst\_loc1$ checks that one term, $tm2$, is a type
instance of $tm1$, according to a mapping from
type variable names to types given by $tysubs$,
under the assumption that the free variable names
agree, i.e. that the first occurrence of each variable which
may need renaming will be its binding occurrence in
a $ç-abstraction$.
»
	‚inst_loc1· : (string ã TYPE) ã TERM ã TERM ã bool
…
	É
	(tysubs : string ã TYPE)
	(tm1 : TERM) (tm2 : TERM)é
	inst_loc1 tysubs tm1 tm2 =
		(Ñs ty1 ty2 mk_Xé
			((mk_X = mk_var) Å (mk_X = mk_const))
		Ä	mk_X(s, ty1) = tm1 Ä mk_X(s, ty2) = tm2
		Ä	(ty2 = inst_type tysubs ty1))
	Å	(Ñtm1f tm1a tm2f tm2aé
			has_mk_comb(tm1f, tm1a)tm1 Ä has_mk_comb(tm2f, tm2a)tm2
		Ä	inst_loc1 tysubs tm1f tm2f Ä inst_loc1 tysubs tm1a tm2a)
	Å	(Ñv1 v2 ty1 ty2 b1 b2 v1ty1 v2ty2 é
			mk_var(v1, ty1) = v1ty1 Ä has_mk_abs(v1ty1, b1)tm1
		Ä	mk_var(v2, ty2) = v2ty2 Ä has_mk_abs(v2ty2, b2)tm2
		Ä	inst_loc1 tysubs (rename (v1, ty1) v2 b1) b2
		Ä	(ty2 = inst_type tysubs ty1)
		Ä	å(Ñ ty3 v2ty3 é
				mk_var(v2, ty3) = v2ty3
			Ä	((v2, ty3) ù freevars_set b1)
			Ä	(ty2 = inst_type tysubs ty3)
			Ä	(v2ty3 à v1ty1) ))
À

$inst\_loc2$ uses $inst\_loc1$ to check that a term $tm2$
is a type instance of the result of renaming free
variables of a term $tm2$ according to a mapping
given by a list of pairs. It also checks that
the type of the second variable in each pair in the list
is a type instance of the type of the first variable
in the pair,
and that the second variable in each pair
is not in the set, $avoid$, unless both names and types
agree for that pair.
In the application of $inst\_loc2$ in $inst$ the list
of pairs is obtained by combining the free variable lists
of the two terms side by side.
The set $avoid$ is a set of variables (coming from
the assumptions of a sequent) whose free occurrences
must not change as a result of the type instantiation.
»
	‚inst_loc2· : ((string â TYPE) ã bool) ã 
		(string ã TYPE) ã
		(((string â TYPE) â (string â TYPE)) list) ã
		TERM ã TERM ã bool
…
	É(avoid : (string â TYPE) ã bool)
	(tysubs :string ã TYPE)
	(v1 : string) (ty1 : TYPE)
	(v2 : string) (ty2 : TYPE)
	(rest : ((string â TYPE) â (string â TYPE)) list)
	(tm1 : TERM) (tm2 : TERM)é
	(inst_loc2 avoid tysubs [] tm1 tm2 =
		inst_loc1 tysubs tm1 tm2)
	Ä
	(inst_loc2 avoid tysubs (CONS ((v1, ty1),(v2, ty2)) rest) tm1 tm2 =
		(((v2, ty2) ù avoid) ä ((v1, ty1) = (v2, ty2)))
	Ä	(ty2 = inst_type tysubs ty1)
	Ä	inst_loc2 avoid tysubs rest
		(rename (v1, ty1) v2 tm1) tm2)
À


With the above preliminaries we can now define {\it inst}.
Note that the condition that the free variable lists of
the two terms have the same length is required to ensure
that $inst\_loc2$ examines each free variable of each
term.

»
	‚inst· : ((string â TYPE) ã bool) ã
		(string ã TYPE) ã TERM ã TERM
…
	É(avoid : (string â TYPE) ã bool)
	(tysubs :string ã TYPE) (tm1 : TERM)é
	let tm2 = inst avoid tysubs tm1
	in let fl1 = freevars_list tm1
	in let fl2 = freevars_list tm2
	in
		((length fl1 = length fl2)
	Ä	inst_loc2 avoid tysubs (combine fl1 fl2) tm1 tm2)
À

\subsubsection{The Inference Rule $INST\_TYPE$}

Given $inst$, we need a few simple auxiliaries before
we can define the inference rule $INST\_TYPE$.

We need to detect the type variables in a term.
We use some auxiliary functions to
do this: $type\_tyvars$ detects the type variables in
a type.

»
	‚type_tyvars· :  TYPE ã (string ã bool)
…
		(És:stringé  type_tyvars (mk_vartype s) = singleton_set s)
	Ä	(És tlé type_tyvars (mk_type(s, tl)) =
			£ (çxé x ≈ (map type_tyvars tl)))
À
$term\_types$ detects the types in a term.
»
	‚term_types· :  TERM ã (TYPE ã bool)
…
	É (tm : TERM) (s: string) (ty : TYPE)
	(f : TERM) (a : TERM) (v: TERM) (b: TERM)é
	term_types (mk_var(s, ty)) = singleton_set ty
	Ä
	term_types (mk_const(s, ty)) = singleton_set ty
	Ä
	(has_mk_comb(f, a) tm ä (term_types tm = term_types f ° term_types a))
	Ä
	(has_mk_abs(v, b) tm ä (term_types tm = term_types v ° term_types b))
À
$term\_tyvars$ detects all the type variables
in a term using the previous two functions.
»
	‚term_tyvars· :  TERM ã (string ã bool)
…
	Étm é term_tyvars tm = £(image type_tyvars (term_types tm))
À
$INST\_TYPE\_rule$ is now readily defined:
»
	‚INST_TYPE_rule· : (string ã TYPE) ã SEQ ã SEQ ã bool
…
	É tysubs old_asms old_conc new_seqé
	INST_TYPE_rule tysubs (old_asms, old_conc) new_seq Ç
	(É (tyv : string) é
		(tyv ù £ (image term_tyvars old_asms)) ä
		(tysubs tyv = mk_vartype tyv))
	Ä
	(let asms_frees = £ (image freevars_set old_asms)
	in
		(new_seq = (old_asms, inst asms_frees tysubs old_conc)))
À


\subsection{Discharging an Assumption: DISCH}

{\it DISCH} is, in essence,
the usual rule of natural deduction
which allows one to infer from a proof of $\cal B$
on the assumption $\cal A$, that
${\cal A} ä \cal B$ on no assumption.
The actual rule is suitably generalised to cover
sequents and their assumption sets. It is not
required that $\cal A$ be in the assumption set,
and the logic would probably not be complete
otherwise.

»
	‚DISCH_rule· : TERM ã SEQ ã SEQ ã bool
…
	É tm old_asms old_conc new_seq é
	DISCH_rule tm (old_asms, old_conc) new_seq Ç
	(type_of_term tm = Bool) Ä
	(new_seq = ((old_asms ƒ singleton_set tm), átéhas_mk_imp(tm, old_conc)t))
À

\subsection{Modus Ponens: MP}

This is the usual rule: from ${\cal A} ä {\cal B}$
and ${\cal A}$, infer ${\cal B}$.
This generalises to sequents by taking the union
of the assumption sets.
 
»
	‚MP_rule· : SEQ ã SEQ ã SEQ ã bool
…
	É imp_asms imp_conc ant_asms ant_conc new_asms new_conc é
	MP_rule (imp_asms, imp_conc) (ant_asms, ant_conc) (new_asms, new_conc) Ç
	(has_mk_imp(ant_conc, new_conc)imp_conc) Ä
	(new_asms = imp_asms ° ant_asms)
À


\section{THE AXIOM SCHEMATA} \label{AXIOMSCHEMATA}


\subsection{The Axiom Schema ASSUME}

{\it ASSUME} allows us to infer
for any boolean term $\cal A$, that $\cal A$
holds on the assumptions $\{{\cal A}\}$.
This is straightforward to formalise. We must check
that the term being assumed is of the right type.
»
	‚ASSUME_axiom· : TERM ã SEQ ã bool
…
	É tm seq é ASSUME_axiom tm seq Ç
	(type_of_term tm = Bool) Ä 
	(seq = (singleton_set tm, tm))
À

\subsection{The Axiom Schema REFL}
{\it REFL} says that for any term $\cal A$,
we may infer that ${\cal A} = {\cal A}$ without
assumptions.

»
	‚REFL_axiom· : TERM ã SEQ
…
	É tm é REFL_axiom tm = (§, átéhas_mk_eq(tm, tm)t)
À

\subsection{The Axiom Schema BETA\_CONV}

{\it BETA\_CONV} says that, without any assumptions,
any $\beta$-redex is
equal to its $\beta$-reduction.
This is straightforward
to define, given the apparatus we used to define
{\it SUBST}.
Note that the way we construct the first argument to
$subst$ by dismantling a combination ensures that it
respects types.
»
	‚BETA_CONV_axiom· : TERM ã SEQ ã bool
…
	É tm new_seqé
	BETA_CONV_axiom tm new_seq Ç
	Ñ v ty vty b abs a é
	mk_var(v, ty) = vty Ä
	has_mk_abs(vty, b)abs Ä
	has_mk_comb(abs, a)tm Ä
	(new_seq = 
	let subs: ((string â TYPE) ã TERM) =
		(ç(vx, tyx)é((vx = v) Ä (tyx = ty)) => a | mk_var(vx, tyx))
	in
		(§, (átéhas_mk_eq(tm, subst subs b)t)))
À


\section{DERIVABILITY} \label{DERIVABILITY}


In this section we will define derivability.
This is a relation between sets of sequents
and sequents. As usual, we first define direct
derivability.
We include instances of the axiom schemata as valid
direct derivations from no premisses. This is merely
for convenience, we could equally well include all
instances of the axiom schemata as axioms in every theory
when theories are defined.

»
	‚directly_derivable_from· : SEQ ã (SEQ ã bool) ã bool
…
	É seq seqs é
	directly_derivable_from seq seqs Ç 
	(Ñ eqs tm old_seq é
	(image eqs (çxéT) • seqs) Ä (old_seq ù seqs) Ä SUBST_rule eqs tm old_seq seq)
	Å
	(Ñ vty old_seq é (old_seq ù seqs) Ä ABS_rule vty old_seq seq)
	Å
	(Ñ tysubs old_seq é (old_seq ù seqs) Ä INST_TYPE_rule tysubs old_seq seq)
	Å
	(Ñ tm old_seq é (old_seq ù seqs) Ä DISCH_rule tm old_seq seq)
	Å
	(Ñ imp_seq ant_seq é (imp_seq ù seqs) Ä (ant_seq ù seqs) Ä MP_rule imp_seq ant_seq seq)
	Å
	(Ñ tm é ASSUME_axiom tm seq)
	Å
	(Ñ tm é seq = REFL_axiom tm)
	Å
	(Ñ tm é BETA_CONV_axiom tm seq)
À

Proofs will just be lists of sequents. Any non-empty
list is a valid proof (of the sequent at its
head) on the premisses given by those elements
of the list which are not directly derivable
from elements later in the list.
There is little point in making the relevant type
definition for a syntactic class of proofs in this sense,
since they contain so little information.
We simply define the function which extracts the set
of premisses.

»
	‚premisses· :  (SEQ list) ã (SEQ ã bool)
…
	É seq rest é
	(premisses [] = §)
	Ä
	(premisses (CONS seq rest) =
		(directly_derivable_from seq (elems rest) => § | singleton_set seq) ° premisses rest)
À


»
	‚derivable_from· : SEQ ã (SEQ ã bool) ã bool
…
	É seq seqs é
	derivable_from seq seqs =
	Ñ seql é premisses (CONS seq seql) • seqs
À

\section{NORMAL THEORIES} \label{THEORIES}
In \cite{DS/FMU/IED/SPC001} a type $THEORY$ is defined
to represents the idea of a theory comprising signatures
governing the formation of types and terms and a set
of axioms. However the type $THEORY$ is too general
for our present purposes, since 
we have formulated rules of inference on the assumption
that there the nullary type ``${:}bool$'' and the
constants ``$=$'' and ``$ä$'' are available.
In this section we define a predicate $normal\_theory$
which selects the theories in which the inference
rules are intended to be valid.
(The normal theories correspond to those whose type
structures and signatures are standard in the terminology
of \cite{SRI89a}. Unfortunately the term {\it standard
theory} is used for a stronger notion in \cite{SRI89a}.)

\subsection{Object Language Constructs}
To define the type of all well-formed HOL theories
we need two further object language constructs: the
choice function ``$á$'' and the type of individuals``$:ind$''.
These are required since we
will follow \cite{SRI89a} in insisting
on the presence of the equality, implication and
choice functions in each theory.
It is noteworthy however that neither the rules of inference
nor the standard
conservative extension mechanisms require
choice or the individuals; they are only used in the
axioms given in section \ref{INIT}.

»
	‚Star· : TYPE
…
	Star = mk_vartype `*`
À

»
	‚Choice· : TERM
…
	Choice = mk_const((`á`, Fun (Fun Star Bool) Star))
À

»
	‚Ind· : TYPE
…
	Ind = mk_type(`Ind`, [])
À

\subsection{Normal Thoeries}
We now wish to define the predicate $normal\_theory$. It is natural
to say that the normal theories are those which extend the minimal
normal theory which contains only ``${:}bool$'', ``$=$'' etc.
Thus we must define this minimal normal theory and also the notion
of extension of theories.

$MIN$ is the minimal normal theory. It is represented
by the triple $MIN\_REP$:
»
	‚MIN_REP· : TY_ENV â CON_ENV â SEQS
…
	MIN_REP = (
	(	çty n é
		(	(ty = `bool`) Ä
			(n  = 0)
		) Å (	(ty = `ã`) Ä
			(n  = 2)
		) Å (	(ty = `ind`) Ä
			(n  = 0)
		)
	) , (	çs tyé
			(mk_const(s, ty) = Equality Star) Å
			(mk_const(s, ty) = Implication) Å
			(mk_const(s, ty) = Choice)
	) , ( § ) )
À
»
	‚MIN· : THEORY
…
	MIN = ABS_THEORY MIN_REP
À

Extension for objects of type {\it THEORY} is
the following binary relation:

Á
	$‚extends· : THEORY ã THEORY ã bool
…
	É thy1 thy2é
	$extends thy1 thy2 Ç
	(UNCURRY(types thy2) • UNCURRY(types thy1)) Ä
	(UNCURRY(constants thy2) • UNCURRY(constants thy1)) Ä
	(axioms thy2 • axioms thy1) 
À

The normal theories are those which extend the
minimal theory {\it MIN}. Note that we do not
exclude inconsistent theories here. (This corresponds
to the possibility of introducing inconsistent axioms
in the HOL system).

»
	‚is_normal_theory· : THEORY ã bool
…
	Éthyéthy ù is_normal_theory = thy extends MIN
À




\section{THEOREMS}
\label{THEOREMS}

We can, at last, define the type of all HOL theorems.
A theorem will consist of a sequent and a theory.
The type is the subtype of the type of all such  pairs
in which the sequent is well-formed with respect to the
type and constant environments of the theory and in which
the sequent may be derived from the axioms of the theory.

»
	‚is_thm·	: SEQ â THEORY ã bool
…ÕÕÕÕÕÕÕÕÕÕÕÕ
	Éseq thyé
	is_thm (seq, thy) Ç
	thy ù is_normal_theory
	Ä
	seq ù sequents thy
	Ä
	derivable_from seq (axioms thy)
À

Note that if $(seq, thy)$ is a theorem in this sense,
the derivation of $seq$ from the axioms of $thy$ may
involve sequents which are not well-formed with respect
to $thy$ (i.e. which contain type operators or constants
which are not in $thy$). This is allowed since it simplifies
the definition of derivability and makes no difference
to the set of theorems in a given theory (this is essentially
the fact that the extension mechanisms $new\_type$ and
$new\_constant$ are conservative). 

Proving that $Ñthméthm ù is\_thm$ involves rather more
work than has been involved in previous type definitions.
(A witness is easy to supply, e.g. $(REFL\_axiom\,(mk\_var(`x`, Star)), MIN)$ would do. However, to show that it is a witness
we need to compute $sequents\,MIN$ and to do this we
must show that $MIN\_REP$ is indeed the representative
of a theory and checking the conditions on the two
environments is rather long-winded).
For the time being we therefore defer this proof task
and use $subtype\_def$ to define the type, $THM$,
of theorems.

Â
subtype_def "‚THM·" ªis_thmº;
Ê
The components of a theorem are extracted using
the following functions:
»
	‚thm_seq· : THM ã SEQ
…
	É thm é
	thm_seq thm = FST(REP_THM thm)
À
»
	‚thm_thy· : THM ã THEORY
…
	É thm é
	thm_thy thm = SND(REP_THM thm)
À
\section{CONSISTENCY AND CONSERVATIVE EXTENSION}
\label{CONSISTENCY}
A theory is consistent if not every sequent which
is well-formed in it can be derived from the axioms:

»
	‚consistent_theory· : THEORY ã bool
…
	É thy é
	consistent_theory thy =
	Ñ seq é
	(seq ù sequents thy)
	Ä
	å(derivable_from seq (axioms thy))
À

An extension of a theory is conservative if no sequent
of the smaller theory is provable in the larger but not
in the smaller.
Á
	‚conservatively_extends· : THEORY ã THEORY ã bool
…
	É thy1 thy2é
	conservatively_extends thy1 thy2 =
	(thy1 extends thy2) Ä
	(É seq é
	(seq ù sequents thy2) ä
	(derivable_from seq (axioms thy1)) ä
	(derivable_from seq (axioms thy2)))
	
À


\section{DEFINITIONAL EXTENSIONS} \label{DEFINITIONS}

\subsection{Object Language Constructs}

A theory {\it LOG}
in which more of the standard logical apparatus is
available will be needed to define some of the definitional
extension mechanisms.
For example, {\it new\_type\_definition}
works with a theorem whose conclusion must be an
existentially quantified term of a particular form.
To define {\it LOG} we need some more object language
types and terms and these are defined in this section.
(It is convenient to leave the definition of {\it LOG}
itself until we have defined {\it new\_definition}.)

The formulation of the various logical connectives
follows the HOL manual, \cite{SRI89a}.

It is helpful now to
have the following term constructor functions.
Note that we are now using total functions to
approximate partial ones; we must, therefore, be
careful only to apply them to appropriate arguments.

»
	‚mk_comb· : (TERM â TERM) ã TERM
…
	mk_comb = $á o has_mk_comb 
À
»
	‚mk_abs· : (TERM â TERM) ã TERM
…
	mk_abs = $á o has_mk_abs 
À
»
	‚mk_eq· : (TERM â TERM) ã TERM
…
	mk_eq = $á o has_mk_eq 
À
»
	‚mk_imp· : (TERM â TERM) ã TERM
…
	mk_imp = $á o has_mk_imp 
À

We can now define the object language constructs needed.
(These could be defined via our explicit representations
of types and terms using strings. This has not been done
since the explicit concrete
syntax used is very  hard to read.)
\subsubsection{Truth}
The constant $T : bool$ is defined by the following equation:
$$T = ((ç(x:bool) é x) = (ç(x:bool) é x))$$

»
	‚Truth· : TERM
…
	Truth = mk_const(`T`, Bool)
À
»
	‚Truth_def· : TERM
…
	Truth_def = 
	let x = mk_var(`x`, Bool)
	in
	mk_eq(mk_abs(x, x), mk_abs(x, x))
À
\subsubsection{Universal Quantification}
The constant $É : (* ã bool) ã bool$ is defined by
the following equation:
$$\$É = (ç(P : * ã bool) é P = (ç(x:*) é T)$$

»
	‚Forall· : TYPE ã TERM
…
	É tyéForall ty = mk_const(`É`, Fun (Fun ty Bool) Bool)
À
»
	‚Forall_def· : TERM
…
	Forall_def =
	let P = mk_var(`P`, Fun Star Bool)
	in let x = mk_var(`x`, Star)
	in
	mk_abs(P, mk_eq(P, mk_abs(x,  Truth)))
À
»
	‚mk_forall· : (TERM â TERM) ã TERM
…
	É tm1 tm2émk_forall(tm1, tm2) =
			mk_comb(Forall (type_of_term tm1), mk_abs(tm1, tm2))
À
\subsubsection{Existential Quantification}
The constant $Ñ : (* ã bool) ã bool$ is defined
by the following equation, which defines $Ñ$ in terms
of the choice function $á: (* ã bool) ã*$:
$$\$Ñ = ç(P : * ã bool) é P(áP)$$
(This may be a little perplexing at first sight.
In the intended interpretations, given a predicate
$P : * ã bool$, if there is some $x : *$ for which $P$
is true (i.e. for which $P x = T$), then $á P$ is such
an $x$. I.e. taking as known the intuitive notion of
``whether or not something with a given property exists'',
$á$ chooses
something with a given property if such a thing exists.
The above definition can be viewed as taking as known
the informal notion of ``choosing something with a given
property'' and defining $Ñ$ to determine
whether or not something with a given property exists
by attempting to choose something with the given property and checking whether the attempt succeeded.)
»
	‚Exists· : TYPE ã TERM
…
	É ty é Exists ty = mk_const(`Ñ`, Fun (Fun ty Bool) Bool)
À

»
	‚Exists_def· : TERM
…
	Exists_def = 
	let P = mk_var(`P`, Fun Star Bool)
	in let PchoiceP = mk_comb(P,mk_comb(Choice, P))
	in
	mk_abs(P, PchoiceP)
À
»
	‚has_mk_exists· : (TERM â TERM) ã TERM ã bool
…
	É tm1 tm2 tm3 é
	has_mk_exists(tm1, tm2) tm3 =
	has_mk_comb(Exists (type_of_term tm1), mk_abs(tm1, tm2))tm3
À
»
	‚mk_exists· : (TERM â TERM) ã TERM
…
	É tm1 tm2émk_exists(tm1, tm2) =
			mk_comb(Exists (type_of_term tm1), mk_abs(tm1, tm2))
À
\subsubsection{Falsity}
The constant $F:bool$ is defined by the following equation:
$$F = É(x:bool) é x$$
(Again this may seem perplexing. The type $bool$
is intended to contain the truth values. The above definition
says that false is the truth value of the proposition that
every truth value is true!)
»
	‚Falsity· : TERM
…
	Falsity = mk_const(`F`, Bool)
À
»
	‚Falsity_def· : TERM
…
	Falsity_def =
	let x = mk_var(`x`, Bool)
	in
	mk_forall(x, x)
À
\subsubsection{Negation}
The constant $å:bool ã bool$ is defined by the following
equation:
$$\$å = ç(b:bool)éb ä F$$
»
	‚Negation· : TERM
…
	Negation = mk_const(`å`, Fun Bool Bool)
À
»
	‚Negation_def· : TERM
…
	Negation_def =
	let b = mk_var(`b`, Bool)
	in
	mk_abs(b, mk_imp(b, Falsity))
À
\subsubsection{Conjunction}
The constant $Ä: bool ã bool ã bool$
is defined by the following equation:
$$\$Ä = çb1éçb2éÉbé(b1 ä (b2 ä b)) ä b$$
(I assume, but do not know, that the above formulation
has some practical advantage in the present
context over the more obvious definition
in terms of $å$ and $ä$.)

The name of the constant is a slash, $/$, followed by a
backslash, $\backslash$. The backslash character
must be escaped by another backslash character within
an HOL string (and for idiosyncratic reasons the prototype ICL
HOL requires an extra layer of escapes as well).
»
	‚Conjunction· : TERM
…
	Conjunction = mk_const(`/\\\\`, Fun Bool (Fun Bool Bool))
À
»
	‚Conjunction_def· : TERM
…
	Conjunction_def =
	let b = mk_var(`b`, Bool)
	in let b1 = mk_var(`b1`, Bool)
	in let b2 = mk_var(`b2`, Bool)
	in
	mk_abs(b1, mk_abs(b2, mk_forall(b, mk_imp(mk_imp(b1, mk_imp(b2, b)), b))))
À
A derived constructor function for conjunctions is
useful.
»
	‚mk_conj· : (TERM â TERM) ã TERM
…
	É tm1 tm2é
	mk_conj(tm1, tm2) = mk_comb(mk_comb(Conjunction, tm1),tm2)
À

\subsubsection{Disjunction}
The constant $Å: bool ã bool ã bool$
is defined by the following equation:
$$\$Å = çb1éçb2éÉbé((b1 ä b) ä (b2 ä b)) ä b$$
(As for conjunction I assume this has some advantage
over a definition from the propositional calculus.)

The name of the constant is a
backslash, $\backslash$, followed by a slash, $/$.
The backslash character
must be escaped by another backslash character within
an HOL string.

»
	‚Disjunction· : TERM
…
	Disjunction = mk_const(`\\\\/`, Fun Bool (Fun Bool Bool))
À
»
	‚Disjunction_def· : TERM
…
	Disjunction_def =
	let b = mk_var(`b`, Bool)
	in let b1 = mk_var(`b1`, Bool)
	in let b2 = mk_var(`b2`, Bool)
	in
	mk_abs(b1, mk_abs(b2, mk_forall(b, mk_imp(mk_imp(b1, b),
				mk_imp(mk_imp(b2, b), b)))))
À
A derived constructor function for disjunctions is
useful later.
»
	‚mk_disj· : (TERM â TERM) ã TERM
…
	É tm1 tm2é
	mk_disj(tm1, tm2) = mk_comb(mk_comb(Disjunction, tm1),tm2)
À

\subsubsection{ONE\_ONE}
The definition of $Type\_Definition$ below requires the notion of
a one-to-one function. The constant $ONE\_ONE$
is defined by the following equation:
$$ONE\_ONE = ç(f:* ã **)éÉ(x1:*)éÉ(x2:*)é(f\,x1 = f\,x2) ä (x1 = x2)$$
»
	‚StarStar· : TYPE
…
	StarStar = mk_vartype `**`
À
»
	‚One_One· : TERM
…
	One_One = mk_const(`ONE_ONE`, Fun(Fun Star StarStar)Bool)
À
»
	‚One_One_def· : TERM
…
	One_One_def = 
	let f = mk_var(`f`,Fun Star StarStar)
	in let x1 = mk_var(`x1`,Star)
	in let x2 = mk_var(`x2`,Star) in
	mk_abs(f, mk_forall(x1, mk_forall(x2,
		mk_imp(mk_eq(mk_comb(f, x1), mk_comb(f, x2)),
			mk_eq(x1, x2)))))
À
\subsubsection{ONTO}
The axiom of infinity requires the notion of
an onto function. The constant $ONTO$
is defined by the following equation:
$$ONTO = ç(f:* ã **)éÉ(y:**)éÑ(x:*)éy = f\,x$$
»
	‚Onto· : TERM
…
	Onto = mk_const(`ONTO`, Fun(Fun Star StarStar)Bool)
À
»
	‚Onto_def· : TERM
…
	Onto_def =
	let f = mk_var(`f`,Fun Star StarStar)
	in let x = mk_var(`x`,Star)
	in let y = mk_var(`y`,StarStar) in
	mk_abs(f, mk_forall(y, mk_exists(x, mk_eq(y, mk_comb(f, x)))))
À
\subsubsection{Type\_Definition}

{\it Type\_Definition} may be new to some readers.
It is a term asserting that a function  represents
one type as a subtype of another. It is used
in defining {\it new\_type\_definition}.
It has type $(**ãbool)ã(*ã**)ãbool$ and
is defined by the following equation:
Û
Type_Definition = ç(P:**ãbool)é(rep:*ã**)éONE_ONE rep
	Ä É(x:**)éP x = Ñ(y:*)éx = rep y
Ê
It is useful later to have a version of {\it Type\_Definition}
parameterised over the types involved.
»
	‚Type_Definition· : TYPE ã TYPE ã TERM
…
	É ty1 ty2 é
	Type_Definition ty1 ty2 =
		mk_const(`Type_Definition`, (Fun (Fun ty2 Bool) (Fun(Fun ty1 ty2)Bool)))
À
»
	‚Type_Definition_def· : TERM
…
	Type_Definition_def = 
	let P = mk_var(`P`,Fun StarStar Bool)
	in let rep = mk_var(`rep`,Fun Star StarStar)
	in let x = mk_var(`x`,StarStar)
	in let y = mk_var(`y`,Star) in
	mk_abs(P, mk_abs(rep,
		mk_conj(mk_comb(One_One, rep),
			mk_forall(x, mk_eq(mk_comb(P, x), mk_exists(y,  
				mk_eq(x, mk_comb(rep, y))))))))
À

\subsection{{\it new\_type} and {\it new\_constant}}

The first two definitional extension mechanisms,
{\it new\_type} and {\it new\_constant} are
conservative, but not very powerful.

{\it new\_type}  is used to declare a name to be used
as a type constructor. No axioms about the type are
introduced so that only instances of polymorphic
functions may be applied to it.
The only constraint is that the name should not
be a type constructor in the theory to be extended.

To see, syntactically, that $new\_type$ is conservative
observe that, given a proof in which the new type does
not appear in the conclusion, distinct applications of
the new type operator could be replaced by distinct
type variables not used elsewhere in the proof. The result
would be a proof in the unextended theory with the same
conclusion as the original proof.
  
»
	‚new_type· : Ü ã string ã THEORY ã THEORY ã bool
…
	É arity name thy1 thy2 é
	new_type arity name thy1 thy2 =
	(É n é å (types thy1 name n)) Ä
	(É s n é types thy2 s n = ((s = name) Ä (n = arity)) Å (types thy1 s n)) Ä
	(constants thy2 = constants thy1) Ä
	(axioms thy2 = axioms thy1)
À
{\it new\_constant}  is used to declare a name to be used
as a constant of a given type.
No axioms about the constant are
introduced so that it behaves as a value
which we cannot determine.
The only constraint is that the name should not
be a constant in the theory to be extended.

»
	‚new_constant· : string ã TYPE ã THEORY ã THEORY ã bool
…
	É name type thy1 thy2 é
	new_constant name type thy1 thy2 =
	(É ty é å (constants thy1 name ty)) Ä
	(É s ty é constants thy2 s ty = ((s = name) Ä (ty = type)) Å (constants thy1 s ty)) Ä
	(types thy2 = types thy1) Ä
	(axioms thy2 = axioms thy1)
À

Again it is easy to see syntactically that this is conservative.
Simply replace distinct instances of the new constant
in a proof by distinct variables not used elsewhere
in the proof to obtain a proof in the unextended theory.

\subsection{{\it new\_axiom}}

{\it new\_axiom} is both powerful and dangerous!
It allows a sequent with no hypotheses and a
given conclusion to be taken as an axiom.
The only constraint is that the sequent be well-formed
with respect to the environments of the theory being
extended.

It is convenient, for technical reasons, in \cite{DS/FMU/IED/SPC004} to
have the more general operation of adding a set of
new axioms. We therefore define $new\_axiom$ in terms
of the more general $new\_axioms$.

»
	‚new_axioms· : (TERM ã bool) ã THEORY ã THEORY ã bool
…
	É tms thy1 thy2 é
	new_axioms tms thy1 thy2 =
	let seqs = image (çtmé(§, tm)) tms
	in
	((seqs • sequents thy1) Ä
	(types thy2 = types thy1) Ä
	(constants thy2 = constants thy1) Ä
	(axioms thy2 = axioms thy1 ° seqs))
À

»
	‚new_axiom· : TERM ã THEORY ã THEORY ã bool
…
	É tm thy1 thy2 é
	new_axiom tm thy1 thy2 = new_axioms (singleton_set tm) thy1 thy2
À
\subsection{{\it new\_definition}}
{\it new\_definition} is useful and conservative.
It allows the simultaneous introduction of a new constant
and an axiom asserting that the new constant is equal
to a given term.
The constraints imposed are {\it (a)} the name must satisfy the
check made in {\it new\_constant}, {\it (b)} the term
must be closed and {\it (c)} the term must contain
no bound variables whose types contain type variables
which do not appear in the type of the new constant.
Condition {\it (c)} ensures that different type instances
of the term result in different instances of the
constant; this avoids a possible inconsistency (see \cite{DS/FMU/IED/SPC004} for an example which arises in the course
of this specification).
»
	‚new_definition· : string ã TERM ã THEORY ã THEORY ã bool
…
	É name tm thy1 thy2 é
	new_definition name tm thy1 thy2 =
	let ty = type_of_term tm
	in 
	Ñ thy1a é
	(new_constant name ty thy1 thy1a) Ä
	(freevars_set tm = §) Ä
	(term_tyvars tm • type_tyvars ty) Ä
	(new_axiom (mk_eq(mk_const(name, ty), tm)) thy1a thy2)
À


\subsection{{\it new\_specification}}

{\it new\_specification} allows the simultaneous
introduction of a set of new constants satisfying a
given predicate provided that a theorem asserting
the existence of some set of values satisfying the
constants is given. An axiom asserting the predicate
for the new constants is introduced.
Like {\it new\_definition}, {\it new\_specification}
is useful and conservative.

The constraints imposed are analogous to those imposed
in {\it new\_definition}: {\it (a)} the constant
names must be pairwise distinct and different from
any constant name in the theory being extended,
{\it (b)} the predicate must have
no free variables apart from those corresponding
to the new constants, {\it (c)} any type variable
contained in a bound variable of the predicate must
appear as a type variable of each of the new constants.
Also, of course, the theorem must have the right form.

Since we now need to work with existential quantifiers
it is necessary to introduce the theory {\it LOG}.
We impose the restriction that {\it new\_specification}
may only be used  to extend theories which extend {\it LOG}.
»
	‚LOG· : THEORY
…
	Ñ thy1 thy2 thy3 thy4 thy5 thy6 thy7 thy8 thy9é
	let Name = çconéáséÑtyémk_const(s, ty) = con
	in
	(new_definition (Name Truth) Truth_def MIN thy1
Ä	new_definition (Name (Forall Star)) Forall_def thy1 thy2
Ä	new_definition (Name (Exists Star)) Exists_def thy2 thy3
Ä	new_definition (Name Falsity) Falsity_def thy3 thy4
Ä	new_definition (Name Negation) Negation_def thy4 thy5
Ä	new_definition (Name Conjunction) Conjunction_def thy5 thy6
Ä	new_definition (Name Disjunction) Disjunction_def thy6 thy7
Ä	new_definition (Name One_One) One_One_def thy7 thy8
Ä	new_definition (Name Onto) Onto_def thy8 thy9
Ä	new_definition (Name (Type_Definition Star StarStar)) Type_Definition_def thy9 LOG)
À

To define {\it new\_specification} we need  the relation
{\it has\_list\_mk\_exists}, and the relation {\it new\_constants}
which is like {\it new\_constant} but handles a
set of new constants.

»
	‚has_list_mk_exists· : (TERM list) ã TERM ã TERM ã bool
…
	(Étm1 tm2é has_list_mk_exists [] tm1 tm2 = (tm1 = tm2))
	Ä
	(É v rest tm1 tm2 é 
	has_list_mk_exists (CONS v rest) tm1 tm2 =
	Ñ rem é has_mk_exists(v, rem) tm2 Ä
		has_list_mk_exists rest rem tm1)
	
À

»
	‚new_constants· : ((string â TYPE) ã bool) ã THEORY ã THEORY ã bool
…
	É cons thy1 thy2 é
	new_constants cons thy1 thy2 =
	(É s ty1 ty2 é ((s, ty1) ù cons) ä å(constants thy1 s ty2)) Ä
	(É s ty é constants thy2 s ty = ((s, ty) ù cons) Å constants thy1 s ty) Ä
	(types thy2 = types thy1) Ä
	(axioms thy2 = axioms thy1)
À

We can now define {\it new\_specification}.
We use the cardinality function $card$ here to help
in asserting that certain lists contain no repeats.
»
	‚new_specification· : ((string â (string â TYPE)) list) ã
	TERM ã THM ã THEORY ã THEORY ã bool
…
	É pairs tm thm thy1 thy2 é
	new_specification pairs tm thm thy1 thy2 =
	let conl = FST(split pairs)
	in let varl = map mk_var (SND(split pairs))
	in let tyl = map SND (SND(split pairs))
	in let subs = ç(s, ty) é
		(Ñ c é (c, (s, ty)) ≈ pairs)
		 =>	mk_const((ácé(c, (s, ty)) ≈ pairs), ty)
		| 	mk_var(s, ty)
	in let axiom = subst subs tm
	in (Ñ concé
	(has_list_mk_exists varl tm conc)
	Ä (thy1 extends LOG)
	Ä
	(freevars_set conc = §)
	Ä
	(card (elems conl) = length varl) Ä (card(elems varl) = length varl)
	Ä
	(thm_seq thm = (§, conc)) Ä (thy1 extends thm_thy thm)
	Ä
	(É tyé (ty ≈ tyl) ä (term_tyvars conc • type_tyvars ty))
	Ä
	(Ñ thy1a é
	new_constants (elems (combine conl tyl)) thy1 thy1a Ä
	new_axiom axiom thy1a thy2) )
À

\subsection{{\it new\_type\_definition}}
{\it new\_type\_definition} allows the introduction
of a new type in one-to-one correspondence with
the subset of an existing type satisfying a given
predicate, given a theorem asserting that the subset
is not empty. A new axiom asserting the existence
of a representation function for the new type is introduced.
Like {\it new\_definition}, {\it new\_type\_definition}
is useful and conservative.

For simplicity, we have made the list of type variable
names to be used as the parameters of the type being
defined, a parameter to {\it new\_type}.
The constraints imposed are {\it (a)} that the list
of type parameter names contain
no repeats, {\it (b)} the theorem must have the right form
and {\it (c)} all type variables contained in the
predicate must be contained in the list of type parameters
names.
Condition {\it (c)} ensures that different type instances
of the new axiom involve different type instances of
the new type.

»
	‚new_type_definition· : string ã (string list) ã THM ã THEORY ã THEORY ã bool
…
	É name typars thm thy1 thy2 é
	new_type_definition name typars thm thy1 thy2=
	Ñ p xty x ty px thy1a axiom é
	let newty = mk_type(name, map mk_vartype typars)
	in let f = mk_var(`f`, Fun newty ty)
	in (
	(thy1 extends LOG)
	Ä
	(hyp (thm_seq thm) = §) Ä
	has_mk_exists (xty, px) (concl (thm_seq thm)) Ä
	mk_var (x, ty) = xty Ä
	has_mk_comb (p, xty) px
	Ä
	(freevars_set p = §) Ä
	(term_tyvars p • elems typars)
	Ä
	(length typars = card(elems typars))
	Ä
	has_mk_exists(f, mk_comb(mk_comb(Type_Definition newty ty, p), f)) axiom
	Ä
	(new_type (length typars) name thy1 thy1a) Ä
	(new_axiom axiom thy1a thy2) )
À
\section{THE THEORY INIT}
\label{INIT}
By extending the theory $LOG$ with five axioms
we will arrive at the theory $INIT$. In a typical
HOL proof development system all theories will be
extensions of this theory. 


\subsection{The Axioms}
\subsubsection{BOOL\_CASES\_AX}
This is the law of the excluded middle:
Û
BOOL_CASES\_AX Ö É(b:bool)é(b = T) Å (b = F)
Ê
»
	‚BOOL_CASES_AX· : TERM
…
	BOOL_CASES_AX =
	let b = mk_var(`b`, Bool)
	in mk_forall(b, mk_disj(mk_eq(b, Truth), mk_eq(b, Falsity)))
À

\subsubsection{IMP\_ANTISYM\_AX}

This says that implication is an antisymmetric
relation:
Û
IMP_ANTISYM_AX Ö É(b1:bool)éÉ(b2:bool)é(b1 ä b2) ä (b2 ä b1) ä (b1=b2)
Ê
»
	‚IMP_ANTISYM_AX· : TERM
…
	IMP_ANTISYM_AX =
	let b1 = mk_var(`b1`, Bool)
	in let b2 = mk_var(`b2`, Bool)
	in mk_forall(b1, mk_forall(b2,
		mk_imp(mk_imp(mk_imp(b1, b2), mk_imp(b2, b1)), mk_eq(b1, b2))))
À

\subsubsection{ETA\_AX}
This says that an $\eta$-redex is equal to
its $\eta$-reduction.
Û
ETA_AX Ö É(f:* ã **)é(ç(x:*)éf x) = f
Ê
»
	‚ETA_AX· : TERM
…
	ETA_AX =
	let f = mk_var(`f1`, Fun Star StarStar)
	in let x = mk_var(`x`, Star)
	in mk_forall(f, mk_eq(mk_abs(x, mk_comb(f, x)), f))
À
\subsubsection{SELECT\_AX}
This is the defining property of the choice function $á$.
Û
SELECT_AX Ö É(P:*ãbool)éÉ(x:*)éP x  ä  P(á P)
Ê
»
	‚SELECT_AX· : TERM
…
	SELECT_AX =
	let P = mk_var(`P`, Fun Star Bool)
	in let x = mk_var(`x`, Star)
	in mk_forall(P,mk_forall(x, mk_imp(mk_comb(P, x), mk_comb(P, mk_comb(Choice, P)))))
À
\subsubsection{INFINITY\_AX}
This is the axiom of infinity. It asserts that the
type $ind$ is in one-to-one correspondence with
a proper subset of itself:
Û
INFINITY_AX Ö Ñ(f:indãind)éONE_ONE f  Ä  åONTO f
Ê
»
	‚INFINITY_AX· : TERM
…
	INFINITY_AX =
	let f = mk_var(`f`, Fun Ind Ind)
	in mk_conj(mk_comb(One_One, f), mk_comb(Negation, mk_comb(Onto, f)))
À

\subsection{The Theory}
»
	‚INIT· : THEORY
…
	Ñ thy1 thy2 thy3 thy4 thy5 thy6 é
	new_axiom BOOL_CASES_AX LOG thy1
Ä	new_axiom IMP_ANTISYM_AX thy1 thy2
Ä	new_axiom ETA_AX thy2 thy3
Ä	new_axiom SELECT_AX thy4 thy5
Ä	new_type 0 (FST(dest_type Ind)) thy5 thy6
Ä	new_axiom INFINITY_AX thy6 INIT
À



\subsection{DEFINITIONAL EXTENSIONS}\label{DEFINITIONALEXTENSIONS}

We will say that a theory $thy1$ is a $definitional$ extension
of a theory $thy2$ if one may go from $thy2$ to $thy1$ by
some sequence of
extensions by the functions 
$new\_type$, $new\_constant$, $new\_definition$,
$new\_specification$ and $new\_type\_definition$.
It is stressed that definitional extensions in this sense
comprise significantly more than just extension by adjoining a defining
equation for a new constant.

»
	‚definitional_extension· : THEORY ã THEORY ã bool
…
	Éthyédefinitional_extension thy = ¢(çthyseté
		thy ù thyset
	Ä (	Éthy1 thy2 arity nameé
		(thy1 ù thyset Ä
		new_type arity name thy1 thy2) ä thy2 ù thyset
	) Ä (
	Éthy1 thy2 name typeé
		(thy1 ù thyset Ä
		new_constant name type thy1 thy2) ä thy2 ù thyset
	) Ä (
	Éthy1 thy2 name tmé
		(thy1 ù thyset Ä
		new_definition name tm thy1 thy2) ä thy2 ù thyset
	) Ä (
	Éthy1 thy2 pairs tm thmé
		(thy1 ù thyset Ä
		new_specification pairs tm thm thy1 thy2) ä thy2 ù thyset
	) Ä (
	Éthy1 thy2 name typars thmé
		(thy1 ù thyset Ä
		new_type_definition name typars thm thy1 thy2) ä thy2 ù thyset
	))
À

Of particular importance are theories which
may be obtained from $INIT$ by definitional
extension.
These theories are of interest since, we
assert, they form a sound formalism
in which much of the practical machine-checked
proof work one might wish to do can be carried out.

\pagebreak
\section{THEORY LISTING}
{\catcode`\_=\active
\gdef\underscoreoff{% make _ a normal char
        \catcode`\_=\active \let_=\_}}
{\underscoreoff
\def\Xref#1#2{\hbox to \hsize{$#1$\leaders\hbox to1em{\hss.\hss}\hfill $#2$}}

\input{\jobname.thp}}
\twocolumn
{\twocolumn[\section{INDEX OF DEFINED TERMS}]
{\makeatletter
\printindex}}
\end{document}
=IGN
val thm1 = save_thm "thm1" (TAC_PROOF(([], ªÉseqs tmédirectly_derivable_from (REFL_axiom tm) seqsº),
	REWRITE_TAC[
		specification"-""directly_derivable_from",
		TAC_PROOF(([], ªÑtm'éREFL_axiom tm = REFL_axiom tm'º),
 		EXISTS_TACªtm:TERMº THEN REWRITE_TAC[])]));


val thm2 = save_thm "thm2" (TAC_PROOF(([], ªÉthy tméderivable_from (REFL_axiom tm) (axioms thy)º),
	EVERY[
		REPEAT GEN_TAC THEN REWRITE_TAC[specification"-""derivable_from"],
		EXISTS_TACª[]:SEQ listº,
		REWRITE_TAC[specification"-""premisses", thm1, SET_CLAUSES]]));



val thm3 = save_thm "thm3" (TAC_PROOF(([], ªÉthyéthy extends thyº),
	REWRITE_TAC[specification"-""extends", SET_CLAUSES]));


val thm4 = save_thm "thm4" (TAC_PROOF(
set_goal([], ªis_theory MIN_REPº);
e(REWRITE_TAC[specification"-""MIN_REP", specification"spc001""is_theory"] THEN REPEAT STRIP_TAC);
e(REWRITE_TAC[specification"spc001""wf_ty_env"] THEN BETA_TAC THEN REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[]);


e(REWRITE_TAC[specification"spc001""wf_seqs", specification"sml027""§"]);



val thm? = save_thm "thm?" (TAC_PROOF(
set_goal([], ªÉs téREFL_axiom (mk_var(s, mk_vartype t)) ù sequents MINº);
e(REWRITE_TAC[specification"spc001""sequents", specification"-""MIN"]);


