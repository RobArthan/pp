=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Unification}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP014}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Approved}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This contains the Standard ML implementation of the unification function}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}

\item[Issue 2.1]
This is an approved version of issue 1.6.

\item[Issue 2.2]
Fixed bug in unify which caused an error message not to
have the unknown parameters filled in.

\item[Issue 2.3 20 November 1991]
Changed the representation of the substitution function
from a binary tree to sparse array. This increases
the speed significantly.

\end{description}
\subsection{Changes forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document contains the Standard ML code for implementing
Unification. It corresponds to the
detailed design of Unification as specified in \cite{DS/FMU/IED/DTD014}.

\subsection{Introduction}

\subsubsection{Background and Purpose}

The function $Unification$ is required by the type
inferrer to identify all the types in a partially typed
term. This document contains the Standard ML code
for implementing this function and its supporting functions
and is produced in response to the specification
of $Unification$ provided in \cite{DS/FMU/IED/DTD014}.

\subsubsection{Dependencies}

The Standard ML code in this document depends on the literate script
contained in \cite{DS/FMU/IED/DTD014} for the signature of Unification.

\subsubsection{Possible Enhancements}

None.

\subsubsection{Deficiencies}

None known.

\section{THE STRUCTURE $Unification$}

The $Unification$ structure binds together the function
unify and various subsidiary functions which are used
to define unify. The structure has the signature $Unification$
defined in \cite{DS/FMU/IED/DTD014}.

We now start the structure $Unification$ which contains
the unification algorithm and some associated data types
and utilities.
=SML
structure âUnificationá : Unification = struct
=TEX
The substitution supporting functions and the substitution
type use the structure $SparseArray$.
=SML
open SparseArray;
=TEX

\subsection{The type $EXTYPE$}

The type of extended types (i.e. types containing type unknowns) is
the following type $EXTYPE$.
=SML
datatype âEXVARá = âKnowná of string | âUnknowná of int;

datatype âEXTYPEá = âExVartypeá of EXVAR | âExTypeá of string * (EXTYPE list);
=TEX

The substitution is represented by a sparse array of
extended types. The substitution which takes a type unknown
onto an extended type is implemented as an array of
extended types, the array index
corresponding to the type unknown (a natural number).
A substitution which does not take a type unknown onto anything
is represented by an empty cell. The sparse array function
$sub\_opt$ returns $Nil$ when an empty cell is encountered.

=SML
type âSUBSá = EXTYPE SPARSE_ARRAY;
=TEX
The following function is needed to detect an error
case during unification. It detects whether or not the
type unknown occurs in any of the extended types which
repeated application of the substitution  gives, returning
true or false.
=SML
fun âtyvars_setá (phi:SUBS) (ExVartype(Known _)) (tvn : int) = false
|   tyvars_set phi (ExVartype(Unknown tvn')) (tvn : int) = (
	case sub_opt (phi, tvn) of
		Nil => (tvn = tvn')
	|	Value ty => tyvars_set phi ty tvn
) | tyvars_set phi (ExType(_, tyl)) (tvn : int) = any tyl (fn ty => tyvars_set phi ty tvn);
=TEX
\subsection{Substitutions}

The unification algorithm works using so-called
substitutions. These are functions from
type unknowns to (extended) types.
They have the property that they differ from
the identity function (on the set of all type unknowns)
in only finitely many places.

When the type inference process is complete (and also
for formatting error messages), we need to be able
to convert extended types back into types using the
most general typing which has been computed as a
substitution.

=SML
fun âextype_to_typeá (phi : SUBS) (namemap : (int * string) list)
	 (ExVartype(Known x)) = (
	mk_vartype x
) | extype_to_type phi namemap (ExVartype(Unknown x)) = (
	case sub_opt (phi, x) of
		Nil => (mk_vartype (lassoc3 namemap x)
			handle Fail msg =>
				fail "extype_to_type" 14003 [fn () => string_of_int x])
		| Value y => extype_to_type phi namemap y
) | extype_to_type phi namemap (ExType(s, l)) = (
	mk_ctype(s, map (extype_to_type phi namemap) l)
);
=TEX
The inverse of this function is $type\_to\_extype$.
=SML
fun âtype_to_extypeá (ty : TYPE) : EXTYPE = (
	let	fun aux ty = (
		if is_vartype ty
		then
			let	val x = dest_vartype ty
			in
				ExVartype(Known x)
			end
		else
			let	val (s,tyl) = dest_ctype ty
			in
				 ExType(s, map aux tyl)
			end
		)
	in
		aux ty
	end
);
=TEX
$sub\_type$ applies a substitution to a type repeatedly until
the substitution ceases to change the type.

=SML
fun âsub_typeá (phi : SUBS) (ExVartype(Known ty)) = ExVartype(Known ty)
|   sub_type (phi : SUBS) (ty as (ExVartype(Unknown tvn))) = (
	case sub_opt (phi, tvn) of
		Nil => ty
		| Value ty => sub_type phi ty)
|   sub_type (phi : SUBS) (ExType(s, tyl)) = ExType(s, map (sub_type phi) tyl);

=TEX
$new\_subs$ creates a new substitution array. The size
$sz$ is passed to the sparse array package and determines
the array size. The array is an indexed array of
lists. The larger the array, the shorter the lists in the
array, and hence the faster the lookup time. If the
array is too large, then space is wasted. A value of
100 for $sz$ gives reasonable performance for the ICL HOL
type inferrer. $init\_subs$ returns a substitution to the
identity function.

=SML
fun ânew_subsá (sz:int) : SUBS = array sz;
val âinit_subsá  : SUBS -> unit = scratch;
=TEX

The substitution array implements a form of structure sharing.
For example, a substitution:\\
\ \\
$\{?1 \mapsto ?3, ?2 \mapsto ?3\}$\\
\ \\
extended by $?3 \mapsto (?4‹?5‹?6)$, yields\\
\ \\
$\{?1 \mapsto ?3, ?2 \mapsto ?3, ?3 \mapsto (?4‹?5‹?6)\}$,\\
\ \\
whereas
without structure sharing (which was the case in the previous
version of this algorithm and the HOL prototype), the
substitution was represented as:\\
\ \\
$\{?1 \mapsto (?4‹?5‹?6), ?2 \mapsto (?4‹?5‹?6)\}$.
\ \\
Each occurrence of the unknown is substituted during unification.
With structure sharing, the substitution is deferred.
To find what $?1$ maps to, two look-ups to
the substitution array are required, the first look-up yields
$?3$, the second, $(?4‹?5‹?6)$. Further look-ups using
$?4$, $?5$, and $?6$ will fail (yielding Nil). This gives
$(?4‹?5‹?6)$ as the type which $?1$ maps to.

$extend\,\phi\,tvn\,ty$ is $\phi$ modified to send
$tvn$ to $ty$.
An exception is raised when solving equations
of the form $?1‹?1=?1$ which arise from
terms like ``$f f$'' (for $f$ a variable).

This is the so-called ``occurs check''. Note that it guarantees
that the substitution array contains no loops. i.e., that if
$R : † \leftrightarrow †$ denotes the relation between
type unknown names such that $x\  R\  y\  \leftrightarrow\  y$ occurs somewhere
in $sub\_opt (\phi,\  x)$, then the transitive closure $R^+$ of $R$
is irreflexive, i.e., $Œ x\  R^+\  x$ for all x.
To see this note that $extend\  \phi\  tvn$ is never called when
tvn already has an entry in $\phi$. (See the use of
$extend$ in $unify$). 

=SML
fun âextendá (phi : SUBS) (tvn : int) (ty : EXTYPE) : unit = (
	case ty of
	ExVartype(Unknown tvn') => (
		if tvn = tvn'
		then
			()
		else	if tyvars_set phi ty tvn
			then fail "unify" 14002 []
			else update (phi, tvn, ty))
	| Other =>
		if tyvars_set phi ty tvn
		then fail "unify" 14002 []
		else update (phi, tvn, ty)
);
=TEX
\subsection{The Unification Algorithm}
=TEX
The work of unification is done by the function
$unify$ below.
Given a substitution, $\phi$, which is an idempotent
substitution giving the most general solution
of some system, $S$, of type equations,
and a pair of types, $ty$ and $ty'$, $unify$ computes
an idempotent substitution
which is the most general solution of
$S\,¡\,\{ty = ty'\}$, provided such a solution exists.

The algorithm is fairly straightforward.
If either type argument is a type unknown then if that unknown is not
changed by $\phi$ we simply extend $\phi$ to send
that type unknown to the other type argument.
If one of the arguments is a type unknown and it is
changed by $\phi$ we must recursively unify its
image under $\phi$ with the other argument.
If neither argument is a type unknown then they must
both have the same top-level structure and we
recursively examine the corresponding
subtypes of the two arguments (if any) to find
the solution.

If the types cannot be unified, fail is called which
raises an exception with the contructor ``Fail''.
=SML
fun âunifyá (phi : SUBS) (ty, ty') : unit = (
	case ty of
		ExVartype(Unknown tvn) => (
			case sub_opt (phi, tvn) of
				Nil => (
					extend phi tvn ty'
				) |Value phitvn => (
					unify phi (phitvn, ty'))
	) |	ExVartype(Known kty) => (
			case ty' of
				ExVartype(Known kty') => (
					if kty = kty'
					then ()
					else fail "unify" 14001 [fn () => kty,
								 fn () => kty']
			) |	ExVartype(Unknown _ ) => unify phi (ty', ty)
			|	ExType(s, _) => fail "unify" 14001 [fn () => kty,
								    fn () => s]
	) |	ExType(s, tyl) => (
			case ty' of
				ExVartype _ => unify phi (ty', ty)
			|	ExType(s', tyl') => (
					if s = s' andalso length tyl = length tyl'
					then ((map (unify phi) (combine tyl tyl'));())
					else fail "unify" 14001 [fn () => s,
								 fn () => s']
			)
	)
);
=TEX

The function $list\_unify$ applied to a list $[t1,t2,...,tn]$
finds the unification $t1$ and $t2$, the unification of
$t2$ with $t3$, and so on, folding in the substitution.
At the end of the process, the substitution function
yielded is the unification of all the types in the list.
The substitution $phi$ is yielded as a side-effect of
unify, and the function returns $unit$.

=SML
fun âlist_unifyá (phi : SUBS) (tyl : EXTYPE list) : unit = (
let	fun aux (x1::x2::xs) = (
		let	val sd = unify phi (x1, x2);
		in
			aux (x2::xs)
		end)
	  | aux _ = ();
in
	aux tyl
end);
=TEX
\subsection{Further Utilities}

The following two utilities support a supply of unique names.

=SML
local
	val name_supply : int ref = ref 0;
in
	fun âstart_againá() = name_supply := 0;
	fun ânext_nameá () = (
		let	val x = !name_supply
		in	(name_supply := x+1; x)
		end
	);
end;
=TEX

=SML
fun ânew_nameá (names : 'a list) : ('a * int) list = (
	map (fn x => (x, next_name())) names
);
=TEX

The function $replaced$ below has the same functionality
as the function $replaced$ in the HOL prototype
\cite{DS/FMU/IED/SML007}, but has been recoded. The
value constructors in the prototype version are
now pure functions and cannot be used for pattern
matching. Hence we require the test $is\_vartype$ here.
This makes the implementation of the function look quite
different from the prototype, although it does the same
thing.
 
=SML
fun âreplacedá (ty : TYPE) : EXTYPE = (
	let	val rename = lassoc3(new_name (type_tyvars ty));
		fun aux ty = (
			if is_vartype ty
			then
				let	val x = dest_vartype ty;
				in
					ExVartype(Unknown(rename x))
				end
			else
				let	val	(s,tyl) = dest_ctype ty;
				in
					ExType(s, map aux tyl)
				end)
	in
		aux ty
	end
);
=TEX
=SML
end; (* of structure Unification *)
=TEX

\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}
