% imp032.doc   %Z% $Date$ $Revision$ $RCSfile$

=TEX
% imp032.doc   %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol,11pt,TQ]{article}

\TPPtitle{Implementation of the HOL Pretty Printer}
\TPPref{DS/FMU/IED/IMP032}
\def\SCCSissue{$Revision$%
}
\TPPissue{\SCCSissue}
\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{FST PROJECT}

=IGN

Commands to process this document in various ways.

make -f rel001.mkf imp032.dvi
doc4tex imp032
tex4dvi imp032
bibtex imp032
doc4tex imp032 ; tex4dvi imp032
doc4tex imp032 ; tex4dvi imp032 ; bibtex imp032
dvipage imp032 &

doc4errors imp032
usefile "imp032.sml";

lasp -s imp032.doc > zz1
lasp -s -u imp032.OKwords imp032.doc > zz1

=TEX
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Standard}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the HOL pretty printing functions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

%\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

%********************************************************************

\subsection{Contents List}
\tableofcontents
% \listoftables

%********************************************************************

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

%********************************************************************

\subsection{Changes History}

\begin{description}

\item[\FormatDate{91/07/10}, issue 1.1 ] First issue.
\item[\FormatDate{91/07/25}, issue 1.3 ] First issue.
	Corrected fault in $Uncurry$. {}
	Change `let' terms to have a syntax of the form ``{\tt let
		$term$ in $term$}''. {}
	Allow variables to have fixity.

\item[\FormatDate{91/07/30}, issue 1.5 ] First issue.
	Changed names of syntax functions.
	Fault in handling of set comprehension.

\item[\FormatDate{$Date$%
}, issue \SCCSissue ]
        $new\_flag$ parameter change.
\end{description}

%********************************************************************

\subsection{Changes Forecast} \label{ChangesForecast}

Showing the types of variables and constants in terms.  There are
several usages of variables and constants where it would be useful to
add type information.

\begin{itemize}

\item Defining instances of variables in binder terms.
\item Defining instances of variables in let terms.
\item Uses of constants as functions.
\item Uses of constants as operands of other constructs.
\item Uses of constants as prefix, infix or postfix operators.
\item Uses of free variables.

\end{itemize}

Some of these are relatively easy to achieve, however a constraint of
`give the minimal typing necessary to read back the term' is difficult
to achieve.  One way of approaching minimal typing would be to have a
prepass which marked uses of constants and free variables which require
typing together with the pretty printer always typing defining
instances of variables.

Add the correct body to function $print_identifier$ in
section~\ref{PrintingIdentifiers}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the HOL pretty printing routines
for Release~1 of the ICL HOL system.

%********************************************************************

\subsection{Introduction}

Part of the pretty printer comprises the routines that format terms and
types according to the HOL concrete syntax
of~\cite{DS/FMU/IED/DEF001}.  These routines are registered with the
pretty printing support system of~\cite{DS/FMU/IED/DTD031} and
~\cite{DS/FMU/IED/IMP031}.

%********************************************************************

\subsection{Purpose and Background}

Pretty printing requires understanding uses of HOL constants which
correspond to the various syntactic productions of HOL.  The pretty
printer support~\cite{DS/FMU/IED/DTD031} decodes applications of
constants and variables, it then invokes one of the main
routines (namely $HOL_fun_const$ or $HOL_fun_var$)
in this document.  Other, more primitive, types of HOL term are printed
by other routines in this document.

%********************************************************************

\subsection{Dependencies}

Basic output mechanisms are provided by the Oppen style printing
routines in~\cite{DS/FMU/IED/IMP024} and by the PolyML function
$PolyML.install_pp$, although they are provided via the pretty printer
in~\cite{DS/FMU/IED/IMP025}.

%********************************************************************

\subsection{Interface}

There is only one visible interfaces to this structure, namely that for
formatting HOL types.

Most of this structure is concerned with installing functions into the
pretty printer of~\cite{DS/FMU/IED/IMP031}.  These functions are
thereafter are only called by that pretty printer.

%********************************************************************

%\subsection{Algorithms}
%\subsection{Possible Enhancements}
%\subsection{Deficiencies}
%\subsection{Terminology}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{PRELUDE}

The HOL printing functions are contained in a structure.  All of the
definitions of the main pretty printer are made available.

=SML
structure HOLPrettyPrinter : HOLPrettyPrinter = struct

open PrettyPrinterSupport;
infix ge_prec;
=END

%********************************************************************

\subsection{Precedences}

A number of precedence values are defined.  They are used rather than
the numeric values based $pc_normal$ and $pc_very_low$ to make the
allocation of HOL precedences easier to understand.

=SML
val âpc_h_post_typeá			= pc_normal(60, 0, false);
val âpc_h_apply_firstá			= pc_normal(50, 0, false);
val âpc_h_apply_laterá			= pc_normal(50, 0, true);
fun âpc_h_operá(op_prec, assoc)	= pc_normal(40, op_prec, assoc);
val âpc_h_if_let_bindá			= pc_normal(30, 0, false);
val âpc_h_if_let_bind_lastá		= pc_normal(20, 0, false);
val âpc_h_typingá			= pc_normal(10, 0, false);
=TEX

%********************************************************************

\subsection{Controls}

When printing HOL terms types are selected by the following
control flag.

=SML
val pp_show_HOL_types : bool ref = ref false;
val _ =
new_flag {name = "âpp_show_HOL_typesá",  control=pp_show_HOL_types,
		check=fun_true, default=fun_false};
=TEX

=IGN
set_flag("pp_show_HOL_types", true);
set_flag("pp_show_HOL_types", false);
=TEX

Additional controls are anticipated so that finer control may be placed
upon where types are printed.  Such controls may require additions
to type $PP_ENV$.

%********************************************************************

\subsection{Printing Identifiers}
\label{PrintingIdentifiers}

HOL variables and constants may contain arbitrary text as their
identifiers.  Simple identifiers are printed as themselves, more
complex cases are printed with a leading dollar plus string quote and a
trailing string quote.  The symbol table~\cite{DS/FMU/IED/DTD020}
prevents the complex form of identifiers from being used as binder or
operator names.

=SML
fun âprint_identifierá (addstring:string -> unit) (identifier:string) : unit = (
	addstring identifier
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{PRINTING TYPES}

{\ftlinepenalty=9999
=SML
fun âmain_type_ppá (cur_env:PP_ENV) (ty:TYPE) : unit = (
let
	val pp_env{pe_prec = prec, pe_addstring = addstring, pe_beginb = beginb,
		pe_endb = endb, pe_space = space, ...} = cur_env;

	fun ty_p prec t = main_type_pp (set_prec prec cur_env) t;
	fun name_p n = print_identifier addstring n;

	fun print_list name t rest = (
		beginb(0, false);
		addstring "("; (*=)=*)
		beginb(2, false);
		ty_p pc_lowest t;
		map	(fn tx => (	addstring ",";
					space(1,0);
					ty_p pc_lowest tx))
			rest;
		endb();
		(*=(=*) addstring ")";
		space(1,0);
		name_p name;
		endb()
	);
in
	if is_vartype ty
	then
		name_p(dest_vartype ty)
	else
		case dest_ctype ty
		of (name, nil) => 		name_p name
		| (name, t1 :: nil) => (		ty_p pc_h_post_type t1;
						space(1,0);
						name_p name)
		| (name, t1 :: t2 :: nil) => (
			case get_fixity name
			of Lex.Infix op_prec =>
				let
					val br = prec ge_prec (pc_h_oper(op_prec, true))
				in(
					if br then (beginb(0, false); addstring "("; (*=)=*)
						beginb(2, false)) else ();
					ty_p (pc_h_oper(op_prec, true)) t1;
					space(1,0);
					name_p name;
					space(1,0);
					ty_p (pc_h_oper(op_prec, false)) t2;
					if br then (endb(); (*=(=*) addstring ")"; space(0, 0);
						endb()) else ()
				)end
			| _ => print_list name t1 [t2]
			)
		| (name, t1 :: rest) => print_list name t1 rest
end
);
=TEX
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{SIMPLE HOL CONSTRUCTORS}

%********************************************************************

\subsection{Variables and Constants}

=SML
fun âdo_var_constá (cur_env:PP_ENV) name ty = (
let
	val pp_env{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	val br = !pp_show_HOL_types andalso prec ge_prec pc_h_typing;
in
	if br then (addstring "("; (*=)=*) beginb(2, true)) else ();
	if get_fixity name <> Lex.Nonfix then addstring "$" else ();
	print_identifier addstring name;
	if !pp_show_HOL_types
	then (
		addstring " :";
		space(1, 2);
		main_type_pp cur_env ty;
		if br then (endb(); (*=(=*) addstring ")") else ()
	) else ()
end
);
=TEX

=SML
fun âHOL_do_vará cur_env name ty = do_var_const cur_env name ty;
=TEX

HOL constants representing strings and character literals include
the leading quote character.

=SML
fun âHOL_do_constá cur_env name ty = (
let
	val pp_env{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	val orig = mk_const(name, ty)
in
	if is_char orig
	then	(addstring name; addstring "`")
	else if is_string orig
	then	(addstring name; addstring "\"")
	else	do_var_const cur_env name ty
end
);
=TEX

%********************************************************************
\newpage
\subsection{Combinations}

These combinations are applications of the function $head_fn$ to a list
of arguments in $args$ which may be empty.  Function application is
left associative, thus the brackets may be omitted in the HOL fragment
``$((f\;\;a)\;\;b)\;\;c$''.  {} Value $pc_h_apply_first$ is already set
with this associativity, $pc_h_apply_later$ is set for the arguments to
indicate that they will need brackets if they are combinations.

Bracket elimination works as follows.  On entry to this routine we have
the function and each of its arguments, we know that function
application is left associative and therefore we know we do not need
any brackets with the whole combination.  Brackets may be required
around the whole combination:  when it is used as the argument of
another combination the associativity rule indicates that brackets are
wanted.

If this combination were required to be produced with all the brackets
added (i.e., perhaps when flag $pp_add_brackets$
of~\cite{DS/FMU/IED/IMP031} is set) then one opening bracket would need
to be output for each argument before outputting any of the arguments
and one closing bracket after each argument.

=SML
fun âHOL_do_appá (cur_env:PP_ENV) head_fn args = (
let
	val pp_env{pe_prec=prec, pe_lang=cur_lang, pe_addstring=addstring,
		pe_space=space, pe_beginb=beginb, pe_endb=endb, pe_const=do_const,
		pe_var=do_var, ...} = cur_env;

	val br = prec ge_prec pc_h_apply_later;

	fun print_it p tm = (
	let
		val new_env = set_prec p cur_env;
	in
		case  simple_dest_term tm
		of	Var(str, ty) =>	do_var new_env str ty
		|	Const(str, ty) =>	do_const new_env str ty
		|	_  =>			main_term_pp new_env tm
	end
	);
in
	case args
	of nil =>	print_it pc_h_apply_first head_fn
	| _ => (		beginb(0, false);
			if br then (addstring "("; (*=)=*) beginb(2, true)) else ();
			print_it pc_h_apply_first head_fn;
			map (fn t => (space(1, 0); print_it pc_h_apply_later t)) args;
			if br then (endb(); (*=(=*) addstring ")") else ();
			endb()
		)
end
);
=TEX

%********************************************************************
\newpage
\subsection{Abstractions and Binders}

Abstractions or lambda terms have the same syntax as binders.  They
have different term structures and thus need different decoding
routines.  Abstractions are decoded by function $HOL_do_$, whereas
function $do_binder$ decodes binders.  Both function produce three
components: the abstraction or binder name; the list of declared items,
these may be complex paired items; and, the term that is the scope of
the item.  In the following discussion we consider abstractions to be a
form of binder term.

When these terms do not require types to be shown, the syntax allows a
simple space separated list of declarations, prefixed with the binder
name and followed by a `fat dot'.  When types are required the number
shown should be minimised by use of production $Block$
in~\cite{DS/FMU/IED/DEF001}.  To do this the declarations are grouped
into sets having the same type.

Control flag $pp_types_on_binders$ is provided to request that
types be shown on binder terms.

=SML
val pp_types_on_binders : bool ref = ref false;
val _ =
new_flag {name = "âpp_types_on_bindersá",  control=pp_types_on_binders,
		check=fun_true, default=fun_false};
=TEX

=IGN
set_flag("pp_types_on_binders", true);
set_flag("pp_types_on_binders", false);
=TEX

Function $group_declarations$ takes a list of declarations and finds
the groups of declarations that have the same type.

=SML
fun group_declarations (nil:TERM list) : (TERM list * TYPE) list = nil
| group_declarations (head::rest) = (
let
	val head_ty = type_of head;

	fun split (prev, nil) = (prev, nil)
	| split (prev, h::t) =	if head_ty = type_of h
				then	split(h::prev, t)
				else	(prev, h::t);

	val (decs, to_do) = split([head], rest);

	val gp = (rev decs, head_ty);
in
	gp :: (group_declarations to_do)
end
);
=TEX

=SML
fun âdisplay_binderá (cur_env:PP_ENV) (name:string) (decls:TERM list) (body:TERM) : unit = (
let
	val pp_env{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p p t : unit = main_term_pp (set_prec p cur_env) t;

	fun vs_printer vs : unit = (space(1, 0); tm_p pc_lowest vs);

	fun pr_decls (decs, ty) : unit = (
		beginb(0, false);
		map vs_printer decs;
		addstring ":";
		space(1, 0);
		main_type_pp cur_env ty;
		space(0, 0);
		endb()
	);

	val br = prec ge_prec pc_h_if_let_bind;
in
	if br then (beginb(0, false); addstring "(" (*=)=*) ) else ();
	beginb(2, false);
	print_identifier addstring name;
	if !pp_types_on_binders
	then	(	beginb(2, false);
			case group_declarations decls
			of nil => ()
			| h::nil => pr_decls h
			| h::t => (pr_decls h; map (fn gp => (addstring ";"; pr_decls gp)) t; ())
			;
			space(0, 0);
			endb()
		)
	else	(map vs_printer decls; ())
	;
	addstring "";
	endb();
	space(1, 0);
	tm_p pc_h_if_let_bind_last body;
	if br then ( (*=(=*) addstring ")"; space(0, 0); endb()) else ()
end
);
=TEX

=SML
fun âHOL_do_á (cur_env:PP_ENV) tm1 tm2 = (
let
	val (l_decls, l_body) = strip_(mk_(tm1, tm2));
in
	display_binder cur_env "" l_decls l_body
end
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{PRINTERS FOR HOL CONSTANTS}

%********************************************************************

\subsection{Conditionals}

=SML
fun âHOL_conditionalá (cur_env:PP_ENV) (name:string) (ty:TYPE)
		(args:TERM list) : PFUN_ANS = (
	case args
	of cond :: then_part :: else_part :: nil =>
		let
			val pp_env{pe_prec = prec, pe_addstring = addstring, pe_beginb = beginb,
				pe_endb = endb, pe_space = space, ...} = cur_env;

			val br = prec ge_prec pc_h_if_let_bind;

			fun aux str inner_prec tm = (
				beginb(2, false);
				addstring str;
				space(1, 2);
				main_term_pp (set_prec inner_prec cur_env) tm;
				endb()
			);
		in
			if br then addstring "(" (*=)=*) else ();
			beginb(2, true);
			aux "if"	pc_lowest		cond;		space(1, 0);
			aux "then"	pc_lowest		then_part;	space(1, 0);
			aux "else"	pc_h_if_let_bind_last	else_part;	space(0, 0);
			endb();
			if br then (*=(=*) addstring ")" else ();
			pf_ok
		end
	| _ => (	if length args < 3
		then	pf_not_possible
		else	pf_fewer 3
	)
);
=TEX

%********************************************************************
\newpage
\subsection{Lists and Sets}

Enumerated sets have the same syntax as lists, apart from the shape of
their brackets.

Empty lists and sets are achieved by outputting a fixed string.

=SML
fun âHOL_empty_list_setá (token:string) (cur_env:PP_ENV) (name:string) (ty:TYPE)
		(args:TERM list) : PFUN_ANS = (
	case args
	of nil =>	let
				val pp_env{pe_addstring = addstring, ...} = cur_env;
			in
				addstring token;
				pf_ok
			end
	| _ => pf_not_possible
);
=TEX

Non-empty lists (respectively sets) are formed by the repeated
application of $Cons$ (respectively $Insert$) to a head value and the
tail of the list.  The last application is of the final element and the
constant $Nil$ (respectively $Empty$).

Lists are self bracketing, they never need enclosing in round brackets,
so there is no test of precedences.

=SML
fun âprint_list_or_setá (cur_env:PP_ENV) (opener:string) (body:TERM list) (closer:string) = (
let
	val pp_env{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p t = main_term_pp (set_prec pc_lowest cur_env) t;
in(
	beginb(0, false);
	addstring opener;
	beginb(2, false);
	case body
	of one_tm::nil =>	tm_p one_tm
	| hd_tm::rest => (	tm_p hd_tm;
				map (fn tm => (addstring ";"; space(1, 0); tm_p tm)) rest; ())
	| nil => ();
	endb();
	addstring closer;
	endb();
	pf_ok
)end
);
=TEX

{\hfuzz 3pt
=SML
fun âHOL_listá (cur_env:PP_ENV) (name:string) (ty:TYPE) ([a1, a2]:TERM list) : PFUN_ANS = (
let
	val tail = dest_list a2;
	val body = a1::tail;
in
	print_list_or_set cur_env "[" body "]"
end
handle Fail _ => pf_not_possible
)
| HOL_list _ _ _ args = if length args > 2 then pf_fewer 2 else pf_not_possible;
=TEX
}

{\hfuzz 3pt
=SML
fun âHOL_setá (cur_env:PP_ENV) (name:string) (ty:TYPE) ([a1, a2]:TERM list) : PFUN_ANS = (
let
	val tail = dest_enum_set a2;
	val body = a1::tail;
in
	print_list_or_set cur_env "{" body "}"
end
handle Fail _ => pf_not_possible
)
| HOL_set _ _ _ args = if length args > 2 then pf_fewer 2 else pf_not_possible;
=TEX
}

Set comprehensions are formed by the application of a constant to an
abstraction.

=SML
fun âHOL_set_compá (cur_env:PP_ENV) (name:string) (ty:TYPE)
		([a1]:TERM list) : PFUN_ANS = (
let
	val pp_env{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p t = main_term_pp (set_prec pc_lowest cur_env) t;

	val orig = mk_app(mk_const(name, ty), a1);

	val (decs, pred) = dest_set_comp orig;
in(
	beginb(0, false);
	addstring "{";
	beginb(2, false);
	tm_p decs;
	space(0,0);
	addstring"|";
	tm_p pred;
	endb();
	addstring "}";
	endb();
	pf_ok
)end
handle Fail _ => pf_not_possible
)
| HOL_set_comp _ _ _ args = if length args > 1 then pf_fewer 1 else pf_not_possible;
=TEX

%********************************************************************
\newpage
\subsection{Local Definitions}

HOL `let' terms are printed as if their syntax is of the form ``{\tt
let $term$ in $term$}'' or ``{\tt let $term$ and $term$ in $term$}'',
which is almost what the concrete syntax allows.  This general form
allows easy handling of the fixity of the locally declared items.

Printing out a HOL let term is done in several stages, function
$HOL_let$ conducts the process.  First (in function $get_let_pieces$)
the let term is broken open into the component pieces for printing.
This includes rebuilding the components into a form
compatible with the syntax shown above.
Function $print_list_of_lets$ prints the individual let terms.
Function $print_definer$ prints the defining terms.

Breaking open local definitions to get their constituents works as
follows.

Function $strip_let$ yields a pair: the ``let'' declarations and a
term.  The declarations comprise a list with one entry per ``let''
term.  Each ``let'' term entry is a list with one entry per definition
within the ``let'' term.  Each definition is a pair with the variable
and its defining term.

óSML Examples
strip_let »let a = b in c¼
		= ([[(»a¼, »b¼)]], »c¼)
strip_let »let a = b in let c = d in let e = f in g¼
		= ([[(»a¼, »b¼)], [(»c¼, »d¼)], [(»e¼, »f¼)]], »g¼)
strip_let »let (a1,a2) = b in let (c1,c2) = d in e¼
		= ([[(»(a1, a2)¼, »b¼)], [(»(c1, c2)¼, »d¼)]], »e¼)
strip_let »let af (a1,a2) = b in let cf (c1,c2) = d in e¼
		= ([[(»af¼, » (a1, a2) b¼)], [(»cf¼, » (c1, c2) d¼)]], »e¼)
strip_let »let af (a1,(a2,a3)) ((b1,b2),b3) (c1,c2,c3) = d in e¼
		= ([[(»af¼, » (a1, a2, a3) ((b1, b2), b3) (c1, c2, c3) d¼)]], »e¼)
strip_let »let ff a b c d = e in f¼
		= ([[(»ff¼, » a b c d e¼)]], »f¼)
strip_let »let a = b and c = d and e = f in g¼
æ

The last three examples above show local function definitions.  They
are represented as defining a single variable as a lambda term.  To
show these functions in their original form we do a $strip_$ on the
defining term which yields the original arguments.

óSML Examples
strip_ » (a1, a2) b¼
		= ([»(a1, a2)¼], »b¼)
strip_ » (a1, a2, a3) ((b1, b2), b3) (c1, c2, c3) d¼
		= ([»(a1, a2, a3)¼, »((b1, b2), b3)¼, »(c1, c2, c3)¼], »d¼)
strip_ » a b c d e¼
		= ([»a¼, »b¼, »c¼, »d¼], »e¼)
æ

During input of a HOL term some information is lost, e.g., the terms
`$let\;f\;a=b\;in\;c$' and `$let\;f=\lambda\;a\bullet
b\;in\;c$' are indistinguishable.  A control flag is provided to
allow users a choice over which style is used for output.

=SML
val pp_let_as_lambda : bool ref = ref false;
val _ =
new_flag {name = "âpp_let_as_lambdaá",  control=pp_let_as_lambda,
		check=fun_true, default=fun_false};
=TEX

=IGN
set_flag("pp_let_as_lambda", true);
set_flag("pp_let_as_lambda", false);
=TEX

In $get_let_pieces$ a complex value is returned, as follows.  The value
is a pair comprising (in $fst$ element) a list of the declarative parts
of the nested let terms and (in $snd$ element) the innermost term over
which the ``lets'' are defined.  Each declarative part is itself a
list, with one element per definition, i.e., one element per `$=$'
symbol, which is one more than the number of {\tt and} symbols.  Each
definition is a term formed as an equality between the left and right
sides of the `$=$' symbol.

=SML
fun âget_let_piecesá (orig_tm:TERM) : TERM list list * TERM = (
let
	fun aux_as_fn(t1:TERM, t2:TERM) =
		let
			val (decs, value) = strip_ t2
		in
			mk_eq(list_mk_app(t1, decs), value)
		end;

	fun aux_as_lambda(t1:TERM, t2:TERM) = mk_eq(t1, t2);

	val aux =	if ! pp_let_as_lambda
			then	aux_as_lambda
			else	aux_as_fn;

	val (decls, tm) = strip_let orig_tm;

	val fulldecls = map (map aux) decls;
in
	(fulldecls, tm)
end
);
=TEX

=SML
fun âprint_definerá (cur_env:PP_ENV) let_clause = (
let
	val pp_env{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p p t = main_term_pp (set_prec p cur_env) t;

	fun aux(definer, prefix) = (
		addstring prefix;
		space(1, 0);
		tm_p pc_lowest definer;
		space(1,0);
		"and"
	);
in
	revfold aux let_clause "let";
	addstring "in";
	space(1,2)
end
);
=TEX

=SML
fun âprint_list_of_letsá (cur_env:PP_ENV) (let_clauses, tm) = (
	case let_clauses
	of nil => main_term_pp (set_prec pc_h_if_let_bind_last cur_env) tm
	| first::rest => (
			print_definer cur_env first;
			print_list_of_lets cur_env (rest, tm)
		)
);
=TEX

To process the let term first the whole let term is rebuilt.  It is too
complex a task to partially expand the calls of $dest_let$ or
$strip_let$ to accommodate the four components passed that comprise the
whole term.  The components of the term are found.

=SML
fun âHOL_letá (cur_env:PP_ENV) (name:string) (ty:TYPE)
		([a1, a2]:TERM list) : PFUN_ANS = (
let
	val pp_env{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_endb=endb, ...} = cur_env;

	fun tm_p p t = main_term_pp (set_prec p cur_env) t;

	val br = prec ge_prec (pc_lowest);

	val orig_tm = mk_app(mk_app(mk_const(name, ty), a1), a2);

	val let_term = get_let_pieces orig_tm;
in(
	if br then (beginb(2, false); addstring "(" (*=)=*)) else ();
	print_list_of_lets cur_env let_term;
	if br then ((*=(=*) addstring ")"; endb()) else ();
	pf_ok
)end
)
| HOL_let _ _ _ args = if length args > 2 then pf_fewer 2 else pf_not_possible;
=TEX

%********************************************************************
\newpage
\subsection{Pairs}

=SML
fun âHOL_commaá (cur_env:PP_ENV) (name:string) (ty:TYPE)
		([a1, a2]:TERM list) : PFUN_ANS = (
let
	val pp_env{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p p t = main_term_pp (set_prec p cur_env) t;

	val br = prec ge_prec (pc_very_low(10, 0, true));
in(
	if br then (beginb(2, false); addstring "(" (*=)=*)) else ();
	tm_p (pc_very_low(10, 0, true)) a1;
	addstring ",";
	space(1,0);
	tm_p (pc_very_low(10, 0, false)) a2;
	if br then ((*=(=*) addstring ")"; endb()) else ();
	pf_ok
)end
)
| HOL_comma _ _ _ args = if length args > 2 then pf_fewer 2 else pf_not_possible;
=TEX

=SML
fun âHOL_uncurryá (cur_env:PP_ENV) (name:string) (ty:TYPE)
		([arg]:TERM list) : PFUN_ANS = (
let
	val orig_tm = mk_app(mk_const(name, ty), arg);
in
	case strip_ orig_tm
	of (nil, _) => pf_not_possible
	| (u_decls, u_body) => (	display_binder cur_env "" u_decls u_body;
					pf_ok
				)
end
)
| HOL_uncurry _ _ _ nil = pf_not_possible
| HOL_uncurry _ _ _ _ = pf_fewer 1;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{OPERATORS: PREFIX, INFIX AND POSTFIX}

=SML
fun âdo_prefixá (cur_env:PP_ENV) (name:string) (op_prec:int)
		((a1::nil):TERM list) : PFUN_ANS = (
let
	val pp_env{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p p t = main_term_pp (set_prec p cur_env) t;

	val br = prec ge_prec (pc_h_oper(op_prec, true));
in(
	if br then (beginb(2, false); addstring "(" (*=)=*)) else ();
	print_identifier addstring name;
	space(1,0);
	tm_p (pc_h_oper(op_prec, false)) a1;
	if br then ((*=(=*) addstring ")"; endb()) else ();
	pf_ok
)end
)
| do_prefix _ _ _ nil = pf_not_possible
| do_prefix _ _ _ _ = pf_fewer 1
;
=TEX

=SML
fun âdo_postfixá (cur_env:PP_ENV) (name:string) (op_prec:int)
		((a1::nil):TERM list) : PFUN_ANS = (
let
	val pp_env{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p p t = main_term_pp (set_prec p cur_env) t;

	val br = prec ge_prec (pc_h_oper(op_prec, true));
in(
	if br then (beginb(2, false); addstring "(" (*=)=*)) else ();
	tm_p (pc_h_oper(op_prec, true)) a1;
	space(1,0);
	print_identifier addstring name;
	if br then ((*=(=*) addstring ")"; endb()) else ();
	pf_ok
)end
)
| do_postfix _ _ _ nil = pf_not_possible
| do_postfix _ _ _ _ = pf_fewer 1
;
=TEX

=SML
fun âdo_infixá (cur_env:PP_ENV) (name:string) (op_prec:int)
		((a1::a2::nil):TERM list) : PFUN_ANS = (
let
	val pp_env{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p p t = main_term_pp (set_prec p cur_env) t;

	val br = prec ge_prec (pc_h_oper(op_prec, true));
in(
	if br then (beginb(2, false); addstring "(" (*=)=*)) else ();
	tm_p (pc_h_oper(op_prec, true)) a1;
	space(1,0);
	print_identifier addstring name;
	space(1,0);
	tm_p (pc_h_oper(op_prec, false)) a2;
	if br then ((*=(=*) addstring ")"; endb()) else ();
	pf_ok
)end
)
| do_infix _ _ _ args =
	if length args < 2 then pf_not_possible else pf_fewer 2
;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Binders}

=SML
fun âdo_binderá (cur_env:PP_ENV) (name:string) (ty:TYPE)
		((arg::nil):TERM list) : PFUN_ANS = (
 let
	fun dest_my_name (btm:TERM) : (TERM * TERM) OPT = (
		let
			val (binder, abs) = dest_app btm;		(* might fail *)
			val (var, body) = dest_ abs;			(* might fail *)
			val (const_name, _) = dest_const binder;	(* might fail *)
		in
			if const_name = name
			then	Value(var, body)
			else	Nil
		end
		handle (Fail _) => Nil
	);

	fun strip_binder(tm : TERM) : TERM list * TERM = (
	let
		fun aux prev_decls tm1 = (
			case dest_my_name tm1
			of Value(decl, tm2) => aux (decl::prev_decls) tm2
			| _ => (rev prev_decls, tm1)
		);
	in
		aux nil tm
	end
	);

	val outermost = ((Value(dest_ arg)) handle (Fail _) => Nil);
in
	case outermost
	of Nil => pf_not_possible
	| Value(first_decl, first_body) =>
		let
			val (more_decls, body) = strip_binder first_body;
		in
			display_binder cur_env name (first_decl :: more_decls) body;
			pf_ok
		end
end
)
| do_binder _ _ _ _ = pf_fewer 1
;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{FUNCTION APPLICATION OF CONSTANTS AND VARIABLES}

=SML
local
open Lex;

fun âdo_fixityá (cur_env:PP_ENV) constr (name:string) (ty:TYPE)
		(args:TERM list) : PFUN_ANS = (
	case get_fixity name
	of Nonfix => (
			HOL_do_app cur_env (constr(name, ty)) args;
			pf_ok
		)
	| Prefix op_prec	=> do_prefix	cur_env name op_prec args
	| Infix op_prec		=> do_infix	cur_env name op_prec args
	| Postfix op_prec	=> do_postfix	cur_env name op_prec args
	| Binder		=> do_binder	cur_env name ty args
);

in

fun âHOL_fun_constá (cur_env:PP_ENV) (name:string) (ty:TYPE)
		(args:TERM list) : PFUN_ANS = (
	case
		case name
		of "Cond"	=> Value HOL_conditional
		| "Cons"	=> Value HOL_list
		| "Empty"	=> Value (HOL_empty_list_set "{}")
		| "Insert"	=> Value HOL_set
		| "Let"		=> Value HOL_let
		| "Nil"		=> Value (HOL_empty_list_set "[]")
		| "SetComp"	=> Value HOL_set_comp
		| "Uncurry"	=> Value HOL_uncurry
		| ","		=> Value HOL_comma
		| _		=> Nil
	of Value printer => printer cur_env name ty args
	| Nil => do_fixity cur_env mk_const name ty args
);
=TEX

=SML
fun âHOL_fun_vará (cur_env:PP_ENV) (name:string) (ty:TYPE)
		(args:TERM list) : PFUN_ANS = (
	do_fixity cur_env mk_var name ty args
)

end;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{FINALE}

%********************************************************************

\subsection{Install the HOL Printing Functions}

=SML
val side_effect =
set_printers("HOL",
	(HOL_do_, HOL_do_app, HOL_do_const, HOL_fun_const,
		HOL_fun_var, HOL_do_var));
=TEX

%********************************************************************

\subsection{End of HOL Pretty Printer Structure}

=SML
end (* of structure HOLPrettyPrinter *);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\newpage

\makeatletter
\def\refstepcounter#1{\stepcounter{#1}\global\edef\@currentlabel{\csname
	p@#1\endcsname\csname the#1\endcsname}}
\makeatother

\twocolumn[\section{INDEX}] \label{Index}

\footnotesize
\printindex

\onecolumn

\end{document}
