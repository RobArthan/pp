% imp032.doc   %Z% $Date$ $Revision$ $RCSfile$

=TEX
% imp032.doc   %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol1,11pt,TQ]{article}

\TPPtitle{Implementation of the HOL Pretty Printer}
\TPPref{DS/FMU/IED/IMP032}
\def\SCCSissue{$Revision$%
}
\TPPissue{\SCCSissue}
\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{FST PROJECT}

=IGN

Commands to process this document in various ways.

make -f rel001.mkf imp032.dvi
doc4tex imp032
tex4dvi imp032
bibtex imp032
doc4tex imp032 ; tex4dvi imp032
doc4tex imp032 ; tex4dvi imp032 ; bibtex imp032
dvipage imp032 &

doc4errors imp032
usefile "imp032.sml";

lasp -s imp032.doc > zz1
lasp -s -u imp032.OKwords imp032.doc > zz1

=TEX
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{SML Literate Script}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the HOL pretty printing functions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

%\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

%********************************************************************

\subsection{Contents List}
\tableofcontents
% \listoftables

%********************************************************************

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

%********************************************************************

\subsection{Changes History}

\begin{description}

\item[Issues 1.1 to 1.10 ] Initial drafts.

\item[\FormatDate{91/09/12}, issue 2.1 ] First approved version.

\item[Issue \SCCSissue, \FormatDate{92/01/20} ] Updated to use new fonts.

%\item[\FormatDate{$Date$%
%}, issue \SCCSissue~]

\end{description}

%********************************************************************

\subsection{Changes Forecast} \label{ChangesForecast}

Showing the types of variables and constants in terms.  There are
several usages of variables and constants where it would be useful to
add type information.

\begin{itemize}

\item Defining instances of variables in binder terms.
\item Defining instances of variables in let terms.
\item Uses of constants as functions.
\item Uses of constants as operands of other constructs.
\item Uses of constants as prefix, infix or postfix operators.
\item Uses of free variables.

\end{itemize}

Some of these are relatively easy to achieve, however a constraint of
`give the minimal typing necessary to read back the term' is difficult
to achieve.  One way of approaching minimal typing would be to have a
prepass which marked uses of constants and free variables which require
typing together with the pretty printer always typing defining
instances of variables.

Add the correct body to function $print_identifier$ in
section~\ref{PrintingIdentifiers}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the HOL pretty printing routines
for Release~1 of the ICL HOL system.
These routines are specified in the detailed design~\cite{DS/FMU/IED/DTD032}.

%********************************************************************

\subsection{Introduction}

Part of the pretty printer comprises the routines that format terms and
types according to the HOL concrete syntax
of~\cite{DS/FMU/IED/DEF001}.  These routines are registered with the
pretty printing support system of~\cite{DS/FMU/IED/DTD031} and
~\cite{DS/FMU/IED/IMP031}.

%********************************************************************

\subsection{Purpose and Background}

Pretty printing requires understanding uses of HOL constants which
correspond to the various syntactic productions of HOL.  The pretty
printer support~\cite{DS/FMU/IED/DTD031} decodes applications of
constants and variables, it then invokes one of the main
routines (namely $HOL_fun_const$ or $HOL_fun_var$)
in this document.  Other, more primitive, types of HOL term are printed
by other routines in this document.

%********************************************************************

\subsection{Dependencies}

Basic output mechanisms are provided by the Oppen style printing
routines in~\cite{DS/FMU/IED/IMP024} and by the PolyML function
$PolyML.install_pp$, although they are provided via the pretty printer
in~\cite{DS/FMU/IED/IMP025}.

%********************************************************************

\subsection{Interface}

There is only one visible interfaces to this structure, namely that for
formatting HOL types.

Most of this structure is concerned with installing functions into the
pretty printer of~\cite{DS/FMU/IED/IMP031}.  These functions are
thereafter are only called by that pretty printer.

%********************************************************************

%\subsection{Algorithms}
%\subsection{Possible Enhancements}
%\subsection{Deficiencies}
%\subsection{Terminology}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{PRELUDE}

The HOL printing functions are contained in a structure.  All of the
definitions of the main pretty printer are made available.

=SML
structure €HOLPrettyPrinter› : HOLPrettyPrinter = struct

open PrettyPrinterSupport;
infix gt_prec;
=TEX

%********************************************************************

\subsection{Precedences}

A number of precedence values are defined.  They are used rather than
the numeric values based $PcNormal$ and $PcVeryLow$ to make the
allocation of HOL precedences easier to understand.

=SML
val €pc_h_post_type›			: PREC_CONTEXT = PcNormal(60, 0, false);
val €pc_h_apply_first›			: PREC_CONTEXT = PcNormal(50, 0, false);
val €pc_h_apply_later›		: PREC_CONTEXT = PcNormal(50, 0, true);
fun €pc_h_oper›(op_prec, assoc)	: PREC_CONTEXT = PcNormal(40, op_prec, assoc);
val €pc_h_if_let_bind›			: PREC_CONTEXT = PcNormal(30, 0, false);
val €pc_h_if_let_bind_last›		: PREC_CONTEXT = PcNormal(20, 0, false);
val €pc_h_typing›			: PREC_CONTEXT = PcNormal(10, 0, false);
=TEX

%********************************************************************

\subsection{Controls}

When printing HOL terms types are selected by the following
control flag.

=SML
val pp_show_HOL_types : bool ref = ref false;
val _ =
new_flag {name = "€pp_show_HOL_types›",  control=pp_show_HOL_types,
		check=fun_true, default=fun_false};
=TEX

=IGN
set_flag("pp_show_HOL_types", true);
set_flag("pp_show_HOL_types", false);
=TEX

Additional controls are anticipated so that finer control may be placed
upon where types are printed.  Such controls may require additions
to type $PP_ENV$.

%********************************************************************

\subsection{Printing Identifiers}
\label{PrintingIdentifiers}

HOL variables and constants may contain arbitrary text as their
identifiers.  Simple identifiers are printed as themselves, more
complex cases are printed with a leading dollar plus string quote and a
trailing string quote.  The symbol table~\cite{DS/FMU/IED/DTD020}
prevents the complex form of identifiers from being used as binder or
operator names.

=SML
fun €print_identifier› (addstring:string -> unit) (identifier:string) : unit = (
	addstring identifier
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{PRINTING TYPES}

{\ftlinepenalty=9999
=SML
fun €main_type_pp› (cur_env:PP_ENV) (ty:TYPE) : unit = (
let
	val PpEnv{pe_prec = prec, pe_addstring = addstring, pe_beginb = beginb,
		pe_endb = endb, pe_space = space, ...} = cur_env;

	fun ty_p prec t = main_type_pp (set_prec prec cur_env) t;
	fun name_p n = print_identifier addstring n;

	fun print_list name t rest = (
		beginb(0, false);
		addstring "("; (*=)=*)
		beginb(2, false);
		ty_p PcLowest t;
		map	(fn tx => (	addstring ",";
					space(1,0);
					ty_p PcLowest tx))
			rest;
		endb();
		(*=(=*) addstring ")";
		space(1,0);
		name_p name;
		endb()
	);
in
	if is_vartype ty
	then
		name_p(dest_vartype ty)
	else
		case dest_ctype ty
		of (name, nil) => 		name_p name
		| (name, t1 :: nil) => (		ty_p pc_h_post_type t1;
						space(1,0);
						name_p name)
		| (name, t1 :: t2 :: nil) => (
			case get_fixity name
			of Lex.Infix op_prec =>
				let
					val br = prec gt_prec (pc_h_oper(op_prec, true))
				in(
					if br then (beginb(0, false); addstring "("; (*=)=*)
						beginb(2, false)) else ();
					ty_p (pc_h_oper(op_prec, true)) t1;
					space(1,0);
					name_p name;
					space(1,0);
					ty_p (pc_h_oper(op_prec, false)) t2;
					if br then (endb(); (*=(=*) addstring ")"; space(0, 0);
						endb()) else ()
				)end
			| _ => print_list name t1 [t2]
			)
		| (name, t1 :: rest) => print_list name t1 rest
end
);
=TEX
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{SIMPLE HOL CONSTRUCTORS}

%********************************************************************

\subsection{Variables and Constants}

=SML
fun €do_var_const› (cur_env:PP_ENV) (name:string) (ty:TYPE) : unit = (
let
	val PpEnv{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	val br = !pp_show_HOL_types andalso prec gt_prec pc_h_typing;
in
	if br then (addstring "("; (*=)=*) beginb(2, true)) else ();
	if get_fixity name <> Lex.Nonfix then addstring "$" else ();
	print_identifier addstring name;
	if !pp_show_HOL_types
	then (
		addstring " :";
		space(1, 2);
		main_type_pp cur_env ty;
		if br then (endb(); (*=(=*) addstring ")") else ()
	) else ()
end
);
=TEX

=SML
fun €HOL_do_var› (cur_env:PP_ENV) (orig:TERM) (name:string) (ty:TYPE) : unit =
	do_var_const cur_env name ty;
=TEX

HOL constants representing strings and character literals include
the leading quote character.

=SML
fun €HOL_do_const› (cur_env:PP_ENV) (orig:TERM) (name:string) (ty:TYPE) : unit = (
let
	val PpEnv{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;
in
	if is_char orig 
	then
		if name = "`" ^ (dest_char orig)
		then	(addstring name; addstring "`")
		else	do_var_const cur_env name ty
	else if is_string orig
	then
		if name = "\"" ^ (dest_string orig)
		then	(addstring name; addstring "\"")
		else	do_var_const cur_env name ty
	else
		do_var_const cur_env name ty
end
);
=TEX

%********************************************************************
\newpage
\subsection{Applications}

These are applications of the function $head_fn$ to a list
of arguments in $args$ which may be empty.  Function application is
left associative, thus the brackets may be omitted in the HOL fragment
``$((f\;\;a)\;\;b)\;\;c$''.  {} Value $pc_h_apply_first$ is already set
with this associativity, $pc_h_apply_later$ is set for the arguments to
indicate that they will need brackets if they are applications.

Bracket elimination works as follows.  On entry to this routine we have
the function and each of its arguments, we know that function
application is left associative and therefore we know we do not need
any brackets with the whole application.  Brackets may be required
around the whole application:  when it is used as the argument of
another application the associativity rule indicates that brackets are
wanted.

If this application were required to be produced with all the brackets
added (i.e., perhaps when flag $pp_add_brackets$
of~\cite{DS/FMU/IED/IMP031} is set) then one opening bracket would need
to be output for each argument before outputting any of the arguments
and one closing bracket after each argument.

=SML
fun €HOL_do_app› (cur_env:PP_ENV) (head_fn:TERM) (args:TERM list) : unit = (
let
	val PpEnv{pe_prec=prec, pe_lang=cur_lang, pe_addstring=addstring,
		pe_space=space, pe_beginb=beginb, pe_endb=endb, pe_const=do_const,
		pe_var=do_var, ...} = cur_env;

	val br = prec gt_prec pc_h_apply_later;

	val head_env = set_prec pc_h_apply_first cur_env;

	fun print_head tm = (
		case  dest_simple_term tm
		of	Var(str, ty) =>	do_var head_env tm str ty
		|	Const(str, ty) =>	do_const head_env tm str ty
		|	_  =>			main_term_pp head_env tm
	);
in
	case args
	of nil =>	print_head head_fn
	| _ => 		let
				val arg_env = set_prec pc_h_apply_later cur_env;

				fun print_arg tm = main_term_pp arg_env tm;
			in
				beginb(0, false);
				if br then (addstring "("; (*=)=*) beginb(2, true)) else ();
				print_head head_fn;
				map (fn t => (space(1, 0); print_arg t)) args;
				if br then (endb(); (*=(=*) addstring ")") else ();
				endb()
			end
end
);
=TEX

%********************************************************************
\newpage
\subsection{Abstractions and Binders}

Abstractions or lambda terms have the same syntax as binders.  They
have different term structures and thus need different decoding
routines.  Abstractions are decoded by function $HOL_do_Ã$, whereas
function $do_binder$ decodes binders.  Both function produce three
components: the abstraction or binder name; the list of declared items,
these may be complex paired items; and, the term that is the scope of
the item.  In the following discussion we consider abstractions to be a
form of binder term.

When these terms do not require types to be shown, the syntax allows a
simple space separated list of declarations, prefixed with the binder
name and followed by a `fat dot'.  When types are required the number
shown should be minimised by use of production $Block$
in~\cite{DS/FMU/IED/DEF001}.  To do this the declarations are grouped
into sets having the same type.

Control flag $pp_types_on_binders$ is provided to request that
types be shown on binder terms.

=SML
val pp_types_on_binders : bool ref = ref false;
val _ =
new_flag {name = "€pp_types_on_binders›",  control=pp_types_on_binders,
		check=fun_true, default=fun_false};
=TEX

=IGN
set_flag("pp_types_on_binders", true);
set_flag("pp_types_on_binders", false);
=TEX

Function $group_declarations$ takes a list of declarations and finds
the groups of declarations that have the same type.

=SML
fun €group_declarations› (nil:TERM list) : (TERM list * TYPE) list = nil
| group_declarations (head::rest) = (
let
	val head_ty = type_of head;

	fun split (prev, nil) = (prev, nil)
	| split (prev, h::t) =	if head_ty = type_of h
				then	split(h::prev, t)
				else	(prev, h::t);

	val (decs, to_do) = split([head], rest);

	val gp = (rev decs, head_ty);
in
	gp :: (group_declarations to_do)
end
);
=TEX

=SML
fun €display_binder› (cur_env:PP_ENV) (name:string) (decls:TERM list) (body:TERM) : unit = (
let
	val PpEnv{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p p t : unit = main_term_pp (set_prec p cur_env) t;

	fun vs_printer vs : unit = (space(1, 0); tm_p PcLowest vs);

	fun pr_decls (decs, ty) : unit = (
		beginb(0, false);
		map vs_printer decs;
		addstring ":";
		space(1, 0);
		main_type_pp cur_env ty;
		space(0, 0);
		endb()
	);

	val br = prec gt_prec pc_h_if_let_bind;
in
	if br then (beginb(0, false); addstring "(" (*=)=*) ) else ();
	beginb(2, false);
	print_identifier addstring name;
	if !pp_types_on_binders
	then	(	beginb(2, false);
			case group_declarations decls
			of nil => ()
			| h::nil => pr_decls h
			| h::t => (pr_decls h; map (fn gp => (addstring ";"; pr_decls gp)) t; ())
			;
			space(0, 0);
			endb()
		)
	else	(map vs_printer decls; ())
	;
	addstring "∑";
	endb();
	space(1, 0);
	tm_p pc_h_if_let_bind_last body;
	if br then ( (*=(=*) addstring ")"; space(0, 0); endb()) else ()
end
);
=TEX

=SML
fun €HOL_do_Ã› (cur_env:PP_ENV) (tm1:TERM) (tm2:TERM) : unit = (
let
	val (l_decls, l_body) = strip_Ã(mk_Ã(tm1, tm2));
in
	display_binder cur_env "Ã" l_decls l_body
end
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{PRINTERS FOR HOL CONSTANTS}

%********************************************************************

\subsection{Conditionals}

=SML
fun €HOL_conditional› (cur_env:PP_ENV) (orig:TERM) (name:string) (ty:TYPE)
		(args:TERM list) : PFUN_ANS = (
	case args
	of cond :: then_part :: else_part :: nil =>
		let
			val PpEnv{pe_prec = prec, pe_addstring = addstring, pe_beginb = beginb,
				pe_endb = endb, pe_space = space, ...} = cur_env;

			val br = prec gt_prec pc_h_if_let_bind;

			fun aux str inner_prec tm = (
				beginb(2, false);
				addstring str;
				space(1, 2);
				main_term_pp (set_prec inner_prec cur_env) tm;
				endb()
			);
		in
			if br then addstring "(" (*=)=*) else ();
			beginb(2, true);
			aux "if"	PcLowest		cond;		space(1, 0);
			aux "then"	PcLowest		then_part;	space(1, 0);
			aux "else"	pc_h_if_let_bind_last	else_part;	space(0, 0);
			endb();
			if br then (*=(=*) addstring ")" else ();
			PfOk
		end
	| _ => (	if length args < 3
		then	PfNotPossible
		else	PfFewer 3
	)
);
=TEX

%********************************************************************
\newpage
\subsection{Lists and Sets}

Enumerated sets have the same syntax as lists, apart from the shape of
their brackets.

Empty lists and sets are achieved by outputting a fixed string.

=SML
fun €HOL_empty_list_set› (token:string) (cur_env:PP_ENV) (orig:TERM)
		(name:string) (ty:TYPE) (args:TERM list) : PFUN_ANS = (
	case args
	of nil =>	let
				val PpEnv{pe_addstring = addstring, ...} = cur_env;
			in
				addstring token;
				PfOk
			end
	| _ => PfNotPossible
);
=TEX

Non-empty lists (respectively sets) are formed by the repeated
application of $Cons$ (respectively $Insert$) to a head value and the
tail of the list.  The last application is of the final element and the
constant $Nil$ (respectively $Empty$).

Lists are self bracketing, they never need enclosing in round brackets,
so there is no test of precedences.

=SML
fun €print_list_or_set› (cur_env:PP_ENV) (opener:string) (body:TERM list)
			(closer:string) : PFUN_ANS = (
let
	val PpEnv{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p t = main_term_pp (set_prec PcLowest cur_env) t;
in(
	beginb(0, false);
	addstring opener;
	beginb(2, false);
	case body
	of one_tm::nil =>	tm_p one_tm
	| hd_tm::rest => (	tm_p hd_tm;
				map (fn tm => (addstring ";"; space(1, 0); tm_p tm)) rest; ())
	| nil => ();
	endb();
	addstring closer;
	endb();
	PfOk
)end
);
=TEX

{\hfuzz 3pt
=SML
fun €HOL_list› (cur_env:PP_ENV) (orig:TERM) (name:string) (ty:TYPE)
		([a1, a2]:TERM list) : PFUN_ANS = (
let
	val tail = dest_list a2;
	val body = a1::tail;
in
	print_list_or_set cur_env "[" body "]"
end
handle Fail _ => PfNotPossible
)
| HOL_list _ _ _ _ args = if length args > 2 then PfFewer 2 else PfNotPossible;
=TEX
}

{\hfuzz 3pt
=SML
fun €HOL_set› (cur_env:PP_ENV) (orig:TERM) (name:string) (ty:TYPE)
		([a1, a2]:TERM list) : PFUN_ANS = (
let
	val tail = dest_enum_set a2;
	val body = a1::tail;
in
	print_list_or_set cur_env "{" body "}"
end
handle Fail _ => PfNotPossible
)
| HOL_set _ _ _ _ args = if length args > 2 then PfFewer 2 else PfNotPossible;
=TEX
}

Set comprehensions are formed by the application of a constant to an
abstraction.

=SML
fun €HOL_set_comp› (cur_env:PP_ENV) (orig:TERM) (name:string) (ty:TYPE)
		([a1]:TERM list) : PFUN_ANS = (
let
	val PpEnv{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p t = main_term_pp (set_prec PcLowest cur_env) t;

	val (decs, pred) = dest_set_comp(mk_app(orig, a1));
in(
	beginb(0, false);
	addstring "{";
	beginb(2, false);
	tm_p decs;
	space(0,0);
	addstring"|";
	tm_p pred;
	endb();
	addstring "}";
	endb();
	PfOk
)end
handle Fail _ => PfNotPossible
)
| HOL_set_comp _ _ _ _ args = if length args > 1 then PfFewer 1 else PfNotPossible;
=TEX

%********************************************************************
\newpage
\subsection{Local Definitions}

HOL `let' terms are printed as if their syntax is of the form ``{\tt
let $term$ in $term$}'' or ``{\tt let $term$ and $term$ in $term$}'',
which is almost what the concrete syntax allows.  This general form
allows easy handling of the fixity of the locally declared items.

Printing out a HOL let term is done in several stages, function
$HOL_let$ conducts the process.  First (in function $get_let_pieces$)
the let term is broken open into the component pieces for printing.
This includes rebuilding the components into a form
compatible with the syntax shown above.
Function $print_list_of_lets$ prints the individual let terms.
Function $print_definer$ prints the defining terms.

Breaking open local definitions to get their constituents works as
follows.

Function $strip_let$ yields a pair: the ``let'' declarations and a
term.  The declarations comprise a list with one entry per ``let''
term.  Each ``let'' term entry is a list with one entry per definition
within the ``let'' term.  Each definition is a pair with the variable
and its defining term.

=GFT SML Examples
strip_let ¨let a = b in cÆ
		= ([[(¨aÆ, ¨bÆ)]], ¨cÆ)
strip_let ¨let a = b in let c = d in let e = f in gÆ
		= ([[(¨aÆ, ¨bÆ)], [(¨cÆ, ¨dÆ)], [(¨eÆ, ¨fÆ)]], ¨gÆ)
strip_let ¨let (a1,a2) = b in let (c1,c2) = d in eÆ
		= ([[(¨(a1, a2)Æ, ¨bÆ)], [(¨(c1, c2)Æ, ¨dÆ)]], ¨eÆ)
strip_let ¨let af (a1,a2) = b in let cf (c1,c2) = d in eÆ
		= ([[(¨afÆ, ¨Ã (a1, a2)∑ bÆ)], [(¨cfÆ, ¨Ã (c1, c2)∑ dÆ)]], ¨eÆ)
strip_let ¨let af (a1,(a2,a3)) ((b1,b2),b3) (c1,c2,c3) = d in eÆ
		= ([[(¨afÆ, ¨Ã (a1, a2, a3) ((b1, b2), b3) (c1, c2, c3)∑ dÆ)]], ¨eÆ)
strip_let ¨let ff a b c d = e in fÆ
		= ([[(¨ffÆ, ¨Ã a b c d∑ eÆ)]], ¨fÆ)
strip_let ¨let a = b and c = d and e = f in gÆ
=TEX

The last three examples above show local function definitions.  They
are represented as defining a single variable as a lambda term.  To
show these functions in their original form we do a $strip_Ã$ on the
defining term which yields the original arguments.

=GFT SML Examples
strip_Ã ¨Ã (a1, a2)∑ bÆ
		= ([¨(a1, a2)Æ], ¨bÆ)
strip_Ã ¨Ã (a1, a2, a3) ((b1, b2), b3) (c1, c2, c3)∑ dÆ
		= ([¨(a1, a2, a3)Æ, ¨((b1, b2), b3)Æ, ¨(c1, c2, c3)Æ], ¨dÆ)
strip_Ã ¨Ã a b c d∑ eÆ
		= ([¨aÆ, ¨bÆ, ¨cÆ, ¨dÆ], ¨eÆ)
=TEX

During input of a HOL term some information is lost, e.g., the terms
`$let\;f\;a=b\;in\;c$' and `$let\;f=\lambda\;a\bullet
b\;in\;c$' are indistinguishable.  A control flag is provided to
allow users a choice over which style is used for output.

=SML
val pp_let_as_lambda : bool ref = ref false;
val _ =
new_flag {name = "€pp_let_as_lambda›",  control=pp_let_as_lambda,
		check=fun_true, default=fun_false};
=TEX

=IGN
set_flag("pp_let_as_lambda", true);
set_flag("pp_let_as_lambda", false);
=TEX

In $get_let_pieces$ a complex value is returned, as follows.  The value
is a pair comprising (in $fst$ element) a list of the declarative parts
of the nested let terms and (in $snd$ element) the innermost term over
which the ``lets'' are defined.  Each declarative part is itself a
list, with one element per definition, i.e., one element per `$=$'
symbol, which is one more than the number of {\tt and} symbols.  Each
definition is a term formed as an equality between the left and right
sides of the `$=$' symbol.

=SML
fun €get_let_pieces› (orig_tm:TERM) : TERM list list * TERM = (
let
	fun aux_as_fn(t1:TERM, t2:TERM) =
		let
			val (decs, value) = strip_Ã t2
		in
			mk_eq(list_mk_app(t1, decs), value)
		end;

	fun aux_as_lambda(t1:TERM, t2:TERM) = mk_eq(t1, t2);

	val aux =	if ! pp_let_as_lambda
			then	aux_as_lambda
			else	aux_as_fn;

	val (decls, tm) = strip_let orig_tm;

	val fulldecls = map (map aux) decls;
in
	(fulldecls, tm)
end
);
=TEX

=SML
fun €print_definer› (cur_env:PP_ENV) (let_clause : TERM list) : unit = (
let
	val PpEnv{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p p t = main_term_pp (set_prec p cur_env) t;

	fun aux(definer, prefix) = (
		addstring prefix;
		space(1, 0);
		tm_p PcLowest definer;
		space(1,0);
		"and"
	);
in
	revfold aux let_clause "let";
	addstring "in";
	space(1,2)
end
);
=TEX

=SML
fun €print_list_of_lets› (cur_env:PP_ENV) (let_clauses : TERM list list, tm : TERM) : unit = (
	case let_clauses
	of nil => main_term_pp (set_prec pc_h_if_let_bind_last cur_env) tm
	| first::rest => (
			print_definer cur_env first;
			print_list_of_lets cur_env (rest, tm)
		)
);
=TEX

To process the let term first the whole let term is rebuilt.  It is too
complex a task to partially expand the calls of $dest_let$ or
$strip_let$ to accommodate the four components passed that comprise the
whole term.  The components of the term are found.

=SML
fun €HOL_let› (cur_env:PP_ENV) (orig:TERM) (name:string) (ty:TYPE)
		([a1, a2]:TERM list) : PFUN_ANS = (
let
	val PpEnv{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_endb=endb, ...} = cur_env;

	fun tm_p p t = main_term_pp (set_prec p cur_env) t;

	val br = prec gt_prec (PcLowest);

	val orig_tm = mk_app(mk_app(orig, a1), a2);

	val let_term = get_let_pieces orig_tm;
in(
	if br then (beginb(2, false); addstring "(" (*=)=*)) else ();
	print_list_of_lets cur_env let_term;
	if br then ((*=(=*) addstring ")"; endb()) else ();
	PfOk
)end
)
| HOL_let _ _ _ _ args = if length args > 2 then PfFewer 2 else PfNotPossible;
=TEX

%********************************************************************
\newpage
\subsection{Pairs}

=SML
fun €HOL_comma› (cur_env:PP_ENV) (orig:TERM) (name:string) (ty:TYPE)
		([a1, a2]:TERM list) : PFUN_ANS = (
let
	val PpEnv{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p p t = main_term_pp (set_prec p cur_env) t;

	val br = prec gt_prec (PcVeryLow(10, 0, true));
in(
	if br then (beginb(2, false); addstring "(" (*=)=*)) else ();
	tm_p (PcVeryLow(10, 0, true)) a1;
	addstring ",";
	space(1,0);
	tm_p (PcVeryLow(10, 0, false)) a2;
	if br then ((*=(=*) addstring ")"; endb()) else ();
	PfOk
)end
)
| HOL_comma _ _ _ _ args = if length args > 2 then PfFewer 2 else PfNotPossible;
=TEX

=SML
fun €HOL_uncurry› (cur_env:PP_ENV) (orig:TERM) (name:string) (ty:TYPE)
		([arg]:TERM list) : PFUN_ANS = (
	case strip_Ã (mk_app(orig, arg))
	of (nil, _) => PfNotPossible
	| (u_decls, u_body) => (	display_binder cur_env "Ã" u_decls u_body;
					PfOk
				)
)
| HOL_uncurry _ _ _ _ nil = PfNotPossible
| HOL_uncurry _ _ _ _ _ = PfFewer 1;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{OPERATORS: PREFIX, INFIX AND POSTFIX}

=SML
fun €do_prefix› (cur_env:PP_ENV) (name:string) (op_prec:int)
		((a1::nil):TERM list) : PFUN_ANS = (
let
	val PpEnv{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p p t = main_term_pp (set_prec p cur_env) t;

	val br = prec gt_prec (pc_h_oper(op_prec, true));
in(
	if br then (beginb(2, false); addstring "(" (*=)=*)) else ();
	print_identifier addstring name;
	space(1,0);
	tm_p (pc_h_oper(op_prec, false)) a1;
	if br then ((*=(=*) addstring ")"; endb()) else ();
	PfOk
)end
)
| do_prefix _ _ _ nil = PfNotPossible
| do_prefix _ _ _ _ = PfFewer 1
;
=TEX

=SML
fun €do_postfix› (cur_env:PP_ENV) (name:string) (op_prec:int)
		((a1::nil):TERM list) : PFUN_ANS = (
let
	val PpEnv{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p p t = main_term_pp (set_prec p cur_env) t;

	val br = prec gt_prec (pc_h_oper(op_prec, true));
in(
	if br then (beginb(2, false); addstring "(" (*=)=*)) else ();
	tm_p (pc_h_oper(op_prec, true)) a1;
	space(1,0);
	print_identifier addstring name;
	if br then ((*=(=*) addstring ")"; endb()) else ();
	PfOk
)end
)
| do_postfix _ _ _ nil = PfNotPossible
| do_postfix _ _ _ _ = PfFewer 1
;
=TEX

=SML
fun €do_infix› (cur_env:PP_ENV) (name:string) (op_prec:int)
		((a1::a2::nil):TERM list) : PFUN_ANS = (
let
	val PpEnv{pe_prec=prec, pe_addstring=addstring, pe_beginb=beginb,
		pe_space=space, pe_endb=endb, ...} = cur_env;

	fun tm_p p t = main_term_pp (set_prec p cur_env) t;

	val br = prec gt_prec (pc_h_oper(op_prec, true));
in(
	if br then (beginb(2, false); addstring "(" (*=)=*)) else ();
	tm_p (pc_h_oper(op_prec, true)) a1;
	space(1,0);
	print_identifier addstring name;
	space(1,0);
	tm_p (pc_h_oper(op_prec, false)) a2;
	if br then ((*=(=*) addstring ")"; endb()) else ();
	PfOk
)end
)
| do_infix _ _ _ args =
	if length args < 2 then PfNotPossible else PfFewer 2
;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Binders}

=SML
fun €do_binder› (cur_env:PP_ENV) (name:string) (ty:TYPE)
		((arg::nil):TERM list) : PFUN_ANS = (
 let
	fun dest_my_name (btm:TERM) : (TERM * TERM) OPT = (
		let
			val (binder, abs) = dest_app btm;		(* might fail *)
			val (var, body) = dest_Ã abs;			(* might fail *)
			val (const_name, _) = dest_const binder;	(* might fail *)
		in
			if const_name = name
			then	Value(var, body)
			else	Nil
		end
		handle (Fail _) => Nil
	);

	fun strip_binder(tm : TERM) : TERM list * TERM = (
	let
		fun aux prev_decls tm1 = (
			case dest_my_name tm1
			of Value(decl, tm2) => aux (decl::prev_decls) tm2
			| _ => (rev prev_decls, tm1)
		);
	in
		aux nil tm
	end
	);

	val outermost = ((Value(dest_Ã arg)) handle (Fail _) => Nil);
in
	case outermost
	of Nil => PfNotPossible
	| Value(first_decl, first_body) =>
		let
			val (more_decls, body) = strip_binder first_body;
		in
			display_binder cur_env name (first_decl :: more_decls) body;
			PfOk
		end
end
)
| do_binder _ _ _ _ = PfFewer 1
;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{FUNCTION APPLICATION OF CONSTANTS AND VARIABLES}

=SML
local
open Lex;

fun €do_fixity› (cur_env:PP_ENV) (orig:TERM) (name:string) (ty:TYPE)
		(args:TERM list) : PFUN_ANS = (
	case get_fixity name
	of Nonfix => (
			HOL_do_app cur_env orig args;
			PfOk
		)
	| Prefix op_prec	=> do_prefix	cur_env name op_prec args
	| Infix op_prec		=> do_infix	cur_env name op_prec args
	| Postfix op_prec	=> do_postfix	cur_env name op_prec args
	| Binder		=> do_binder	cur_env name ty args
);

in

fun €HOL_fun_const› (cur_env:PP_ENV) (orig:TERM) (name:string) (ty:TYPE)
		(args:TERM list) : PFUN_ANS = (
	case
		case name
		of "Cond"	=> Value HOL_conditional
		| "Cons"	=> Value HOL_list
		| "Empty"	=> Value (HOL_empty_list_set "{}")
		| "Insert"	=> Value HOL_set
		| "Let"		=> Value HOL_let
		| "Nil"		=> Value (HOL_empty_list_set "[]")
		| "SetComp"	=> Value HOL_set_comp
		| "Uncurry"	=> Value HOL_uncurry
		| ","		=> Value HOL_comma
		| _		=> Nil
	of Value printer => printer cur_env orig name ty args
	| Nil => do_fixity cur_env orig name ty args
);
=TEX

=SML
fun €HOL_fun_var› (cur_env:PP_ENV) (orig:TERM) (name:string) (ty:TYPE)
		(args:TERM list) : PFUN_ANS = (
	do_fixity cur_env orig name ty args
)

end;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{FINALE}

%********************************************************************

\subsection{Install the HOL Printing Functions}

=SML
val side_effect =
set_printers("HOL",
	(HOL_do_Ã, HOL_do_app, HOL_do_const, HOL_fun_const,
		HOL_fun_var, HOL_do_var));
=TEX

%********************************************************************

\subsection{End of HOL Pretty Printer Structure}

=SML
end (* of structure HOLPrettyPrinter *);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\newpage

\makeatletter
\def\refstepcounter#1{\stepcounter{#1}\global\edef\@currentlabel{\csname
	p@#1\endcsname\csname the#1\endcsname}}
\makeatother

\twocolumn[\section{INDEX}] \label{Index}

\footnotesize
\printindex

\onecolumn

\end{document}


