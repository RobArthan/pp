=IGN
********************************************************************************
imp057.doc: this file is part of the ProofPower system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************

=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Computational Conversions}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP057}  %% Mandatory field
\def\SCCSversion{$Revision: 1.15 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 1999/03/06 15:18:12 $%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & HAT Team Leader}
\TPPabstract{This document contains the implementation of conversions
which perform arithmetic computations on literals.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issue 1.4\ (\FormatDate{91/10/16%
})]
First drafts.
\item [Issue 1.5,1.6 (26th March 1992)]
Changed to use proof context material of issue 1.13 of \cite{DS/FMU/IED/DTD051}.
Now work in theory ``$basic\_hol$'', not ``$î$'' and ``$char$''.
\item [Issue 1.7 (14th April 1992)]
Changes due to CR0017.
\item [Issue 1.8,1.9 (12th May 1992)]
Changed theory.
\item [Issue 1.10 (14th May 1992)]
Tidying up proof contexts.
\item [Issue 1.11 (18th May 1992)]
Changed proof context material.
\item [Issue 1.12 (20th May 1992)]
Removed proof context "comp".
\item [Issue 1.13 (2nd June 1992)]
Changed ``native'' theory.
\item[Issue 1.14 (24th June 1992)]
Renamings from issue 1.6 of \cite{DS/FMU/IED/WRK038},
mostly proof context name changes.
\item[Issue 1.15] Update for new INTEGER type.
\item[Issue 1.16] Copyright and banner updates for open source release.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document implements the material whose detailed design is given
in \cite{DS/FMU/IED/DTD057}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD057}.
\subsubsection{Dependencies}
This document depends on the theory and proof procedures defined
in \cite{DS/FMU/IED/DTD038,DS/FMU/IED/IMP038} and on the proof context defined
in \cite{DS/FMU/IED/DTD029,DS/FMU/IED/IMP029}.
\subsubsection{Algorithms}
The implementation begins with some miscellaneous functions which
are used throughout the sequel. Thereafter,
for ease of development and maintenance, the conversions are implemented
following a standard pattern: for each
conversion we first prove one or
more theorems which capture the essence of the arithmetic computation
to be supported; then we define an auxiliary function which is parameterised
by the operands of the operation to be computed; and, finally we define
an interface function which calls the auxiliary, handles errors and
does any additional error-case detection which is not covered by the
auxiliary. The only exceptions are $gt\_conv$ and
$ge\_conv$ which are able to use the auxiliary functions supporting
$lt\_conv$ and $le\_conv$ fairly directly after rewriting the argument
term with the appropriate definition.

This style of implementation has the additional benefit that by formulating
the supporting theorems so as to minimise the amount of inference required
to use them, the resulting implementations can be made quite efficient.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Deficiencies}
None known.
\section{PROLOGUE}
=SML
structure ÛCompConvÝ  : CompConv = struct
val Ûold_theoryÝ = get_current_theory_name();
=TEX
\section{ARITHMETIC}
=SML
val Ûside_effectÝ = open_theory"basic_hol";
val _ = push_merge_pcs ["'propositions",
	"'simple_abstractions"];
=TEX
\subsection{DERIVED SYNTAX FUNCTIONS}
=SML
val Ûdest_¼Ý : TERM -> TERM*TERM = dest_bin_op "dest_¼" 57501 "¼";
val Ûdest_¾Ý : TERM -> TERM*TERM = dest_bin_op "dest_¾" 57502 "¾";
val Ûdest_divÝ : TERM -> TERM*TERM = dest_bin_op "dest_div" 57503 "Div";
val Ûdest_greaterÝ : TERM -> TERM*TERM = dest_bin_op "dest_greater" 57504 ">";
val Ûdest_lessÝ : TERM -> TERM*TERM = dest_bin_op "dest_less" 57505 "<";
val Ûdest_minusÝ : TERM -> TERM*TERM = dest_bin_op "dest_minus" 57506 "-";
val Ûdest_modÝ : TERM -> TERM*TERM = dest_bin_op "dest_mod" 57507 "Mod";
val Ûdest_plusÝ : TERM -> TERM*TERM = dest_bin_op "dest_plus" 57508 "+";
val Ûdest_timesÝ : TERM -> TERM*TERM = dest_bin_op "dest_times" 57509 "*";
=TEX
=SML
val Ûis_¼Ý : TERM -> bool = is_bin_op "¼";
val Ûis_¾Ý : TERM -> bool = is_bin_op "¾";
val Ûis_divÝ : TERM -> bool = is_bin_op "Div";
val Ûis_greaterÝ : TERM -> bool = is_bin_op ">";
val Ûis_lessÝ : TERM -> bool = is_bin_op "<";
val Ûis_minusÝ : TERM -> bool = is_bin_op "-";
val Ûis_modÝ : TERM -> bool = is_bin_op "Mod";
val Ûis_plusÝ : TERM -> bool = is_bin_op "+";
val Ûis_timesÝ : TERM -> bool = is_bin_op "*";
=TEX
N.b. Care has been taken in the following to ensure that all the
parser calls are made at compile-time.
=SML
fun Ûrator_tyÝ ty = (mk_­_type(”î®, mk_­_type(”î®, ty)));
fun Ûrator_fnÝ (nm : string) (ty : TYPE) : TYPE -> TYPE -> TERM = (
	let val act_ty = rator_ty ty;
	in	(fn _ => fn _ => mk_const (nm, act_ty))
	end
);
=TEX
=SML
val Ûmk_¼Ý : TERM*TERM -> TERM =
	mk_bin_op "mk_¼" 57510 57511 (rator_fn"¼"”BOOL®);
val Ûmk_¾Ý : TERM*TERM -> TERM =
	mk_bin_op "mk_¾" 57510 57511 (rator_fn"¾"”BOOL®);
val Ûmk_divÝ : TERM*TERM -> TERM =
	mk_bin_op "mk_div" 57510 57511 (rator_fn"Div"”î®);
val Ûmk_greaterÝ : TERM*TERM -> TERM =
	mk_bin_op "mk_greater" 57510 57511 (rator_fn">"”BOOL®);
val Ûmk_lessÝ : TERM*TERM -> TERM =
	mk_bin_op "mk_less" 57510 57511 (rator_fn"<"”BOOL®);
val Ûmk_minusÝ : TERM*TERM -> TERM =
	mk_bin_op "mk_minus" 57510 57511 (rator_fn"-"”î®);
val Ûmk_modÝ : TERM*TERM -> TERM =
	mk_bin_op "mk_mod" 57510 57511 (rator_fn"Mod"”î®);
val Ûmk_plusÝ : TERM*TERM -> TERM =
	mk_bin_op "mk_plus" 57510 57511 (rator_fn"+"”î®);
val Ûmk_timesÝ : TERM*TERM -> TERM =
	mk_bin_op "mk_times" 57510 57511 (rator_fn"*"”î®);
=TEX
\subsection{MISCELLANEOUS FUNCTIONS}
=SML
fun term_divert (ex : exn)
		(fromarea : string)
		(toarea : string)
		(msg : int)
		(tms : TERM list) : 'a = (
	divert ex fromarea toarea msg (map (fn t => (fn () => string_of_term t)) tms)
);
=SML
val ÛLEFT_CÝ =  RATOR_C o RAND_C;
val ÛRIGHT_CÝ = RAND_C;
val ÛRANDS_CÝ = APP_C o (RAND_C ** Combinators.I);
=TEX
These functions do not do any error handling, it is the caller's
responsibility to ensure that arguments are in range.
=SML
val Ûhol_oneÝ = ¬1®;
=TEX
$aux\_conv1$ proves any theorem of the form $x = q + q$, where
$x$ and $q$ are numeric literals. It is caller's responsibility
to supply an even $x$.
=SML
val two = @@"2";
val Ûaux_conv1Ý : CONV = (fn tm =>
	let	val x = dest_î tm;
		val xdiv2 = mk_î(x idiv two);
	in	eq_sym_rule
		(plus_conv (mk_plus(xdiv2, xdiv2)))
	end
);
=TEX
=SML
val Ûlist_´_mp_ruleÝ = revfold (uncurry(switch ´_mp_rule));
=TEX
=IGN
list_´_mp_rule [asm_rule¬A:BOOL®, asm_rule¬B:BOOL®, asm_rule¬C:BOOL®]
	(asm_rule¬A ´ B ´ C ´ D®);
=TEX
\subsection{RELATIONS}
\subsubsection{¼}
We use the following lemmas to assist in $le\_conv$:
=SML
val Û¼_t_lemmaÝ = tac_proof(
	([], ¬µx y a·x + a = y ´ (x ¼ y ¤ T)®),
	REPEAT strip_tac THEN rewrite_tac[¼_def]
	THEN ¶_tac¬a:î® THEN asm_rewrite_tac[]);
=TEX
=SML
val Û¼_f_lemmaÝ = tac_proof(
	([], ¬µx y a·y + a + 1 = x ´ (x ¼ y ¤ F)®),
	rewrite_tac[³_¼_thm, less_def, ¼_def] THEN REPEAT strip_tac
	THEN ¶_tac¬a:î® THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule)
	THEN rewrite_tac[plus_clauses, plus_assoc_thm]);
=TEX
=SML
fun Û¼_conv_auxÝ (tmx : TERM) (tmy : TERM) = (
	let	val x = dest_î tmx;
		val y = dest_î tmy;
	in	if x @<= y
		then	let	val a = y @- x;
				val tma = mk_î a;
				val thm1 = plus_conv(mk_plus(tmx, tma));
				val thm2 = list_µ_elim[tmx, tmy, tma]
						¼_t_lemma;
			in	´_mp_rule thm2 thm1
		end else let	val a = x @- (y @+ one);
				val tma = mk_î a;
				val thm1 = (RAND_C plus_conv THEN_C plus_conv)
					(mk_plus(tmy, mk_plus(tma, hol_one)));
				val thm2 = list_µ_elim[tmx, tmy, tma]
						¼_f_lemma;
			in	´_mp_rule thm2 thm1
		end
	end
);
=TEX
=IGN
val ÛtmxÝ = ¬10®;
val ÛtmyÝ = ¬20®;
=SML
val Û¼_convÝ : CONV = (fn aopb =>
	let	val (a, b) = dest_bin_op "¼_conv" 57001  "¼" aopb;
	in	¼_conv_aux  a b
	end	handle ex => term_divert ex "dest_î" "¼_conv" 57001 [aopb]
);
=TEX
\subsubsection{$<$}
We use the following lemmas to assist in $le\_conv$:
=SML
val Ûless_t_lemmaÝ = tac_proof(
	([], ¬µx y a·x + a + 1 = y ´ (x < y ¤ T)®),
	rewrite_tac[less_def, ¼_def] THEN REPEAT strip_tac
	THEN ¶_tac¬a:î® THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule)
	THEN rewrite_tac[plus_clauses, plus_assoc_thm]);
=TEX
=SML
val Ûless_f_lemmaÝ = tac_proof(
	([], ¬µx y a·y + a = x ´ (x < y ¤ F)®),
	rewrite_tac[³_less_thm, ¼_def] THEN REPEAT strip_tac
	THEN ¶_tac¬a:î® THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule)
	THEN rewrite_tac[plus_clauses, plus_assoc_thm]);
=TEX
=SML
fun Ûless_conv_auxÝ (tmx : TERM) (tmy : TERM) = (
	let	val x = dest_î tmx;
		val y = dest_î tmy;
	in	if x @< y
		then	let	val a = y @- (x @+ one);
				val tma = mk_î a;
				val thm1 = (RAND_C plus_conv THEN_C plus_conv)
					(mk_plus(tmx, mk_plus(tma, hol_one)));
				val thm2 = list_µ_elim[tmx, tmy, tma]
						less_t_lemma;
			in	´_mp_rule thm2 thm1
		end else let	val a = x @- y;
				val tma = mk_î a;
				val thm1 = plus_conv(mk_plus(tmy, tma));
				val thm2 = list_µ_elim[tmx, tmy, tma]
						less_f_lemma;
			in	´_mp_rule thm2 thm1
		end
	end
);
=TEX
=SML
val Ûless_convÝ : CONV = (fn aopb =>
	let	val (a, b) = dest_bin_op "less_conv" 57005  "<" aopb;
	in	less_conv_aux  a b
	end	handle ex => term_divert ex "dest_î" "less_conv" 57005 [aopb]
);
=TEX
\subsubsection{¾}
=SML
val Û¾_convÝ : CONV = (fn aopb =>
	let	val check = dest_bin_op "¾_conv" 57002  "¾" aopb;
	in	(eq_match_conv ¾_def THEN_C ¼_conv) aopb
	end	handle ex => term_divert ex "¼_conv" "¾_conv" 57002 [aopb]
);
=TEX
\subsubsection{$>$}
=SML
val Ûgreater_convÝ : CONV = (fn aopb =>
	let	val check = dest_bin_op "greater_conv" 57004  ">" aopb;
	in	(eq_match_conv greater_def THEN_C less_conv) aopb
	end	handle ex => term_divert ex "less_conv" "greater_conv" 57004 [aopb]
);
=TEX
\subsubsection{Numerical Equality}
=SML
=TEX
=SML
val Ûî_eq_lemma1Ý = tac_proof(
	([], ¬µx y·x < y ´ (x = y ¤ F)®),
	REPEAT strip_tac
	THEN asm_ante_tac ¬x < y®
	THEN asm_rewrite_tac[]
	THEN strip_asm_tac (list_µ_elim[¬y:î®, ¬y:î®] less_irrefl_thm)
);
=TEX
=SML
val Ûî_eq_lemma2Ý = tac_proof(
	([], ¬µx y·y < x ´ (x = y ¤ F)®),
	REPEAT strip_tac
	THEN strip_asm_tac (list_µ_elim[¬y:î®, ¬x:î®] î_eq_lemma1)
	THEN asm_ante_tac¬³ (y:î) = x® 
	THEN asm_rewrite_tac[]
);
=TEX
=SML
fun Ûî_eq_conv_auxÝ (tmx : TERM) (tmy : TERM) = (
	let	val x = dest_î tmx;
		val y = dest_î tmy;
	in	if x = y
		then	¤_t_intro(refl_conv tmx)
		else if x @< y
		then let	val thm1 = ¤_t_elim(less_conv_aux tmx tmy);
				val thm2 = list_µ_elim[tmx, tmy]
						î_eq_lemma1;
			in	´_mp_rule thm2 thm1
		end else let	val thm1 = ¤_t_elim(less_conv_aux tmy tmx);
				val thm2 = list_µ_elim[tmx, tmy]
						î_eq_lemma2;
			in	´_mp_rule thm2 thm1
		end
	end
);
=TEX
=SML
val Ûî_eq_convÝ : CONV = (fn aopb =>
	let	val (a, b) = dest_bin_op "î_eq_conv" 57100  "=" aopb;
	in	î_eq_conv_aux  a b
	end	handle ex => term_divert ex "dest_î" "î_eq_conv" 57100 [aopb]
);
=TEX
\subsection{ADDITION}
This is quite easy!
=SML
val Ûplus_convÝ = DerivedRules1.plus_conv;
=TEX
\subsection{SUBTRACTION}
\subsubsection{Lemma}
=SML
val Ûminus_lemmaÝ = tac_proof(
	([], ¬µx y a·a + y = x ´ (x - y = a)®),
	REPEAT strip_tac THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule)
	THEN rewrite_tac[minus_def]);
=TEX
=SML
fun Ûminus_conv_auxÝ (aopb :TERM) (tmx : TERM) (tmy : TERM) = (
	let	val x = dest_î tmx;
		val y = dest_î tmy;
	in	if x @>= y
		then	let	val a = x @- y;
				val tma = mk_î a;
				val thm1 = plus_conv(mk_plus(tma, tmy));
				val thm2 = list_µ_elim[tmx, tmy, tma]
						minus_lemma;
			in	´_mp_rule thm2 thm1
		 end else 	term_fail "minus_conv" 57010 [aopb]
	end
);
=TEX
=SML
val Ûminus_convÝ : CONV = (fn aopb =>
	let	val (a, b) = dest_bin_op "minus_conv" 57006  "-" aopb;
	in	minus_conv_aux aopb a b
	end	handle ex => term_divert ex "dest_î" "minus_conv" 57006 [aopb]
);
=TEX
\subsection{MULTIPLICATION}
\subsubsection{Lemmas}
=SML
val Ûtimes_0_xÝ = tac_proof(([], ¬µx·0 * x = 0®), rewrite_tac[times_clauses]);
val Ûtimes_1_xÝ = tac_proof(([], ¬µx·1 * x = x®), rewrite_tac[times_clauses]);
=TEX
\subsubsection{The Multiplier}
We compute $x * y$ where $x > 1$ is even as follows:
=GFT Example
1.	ô x = a + a			aux_conv1
2.	ô x*y = (a + a)*y		1
3.	ô (a + a)*y = a*y + a*y	2, distributivity
4.	ô a*y = z			recursive call
5.	ô a*y + a*y = z + z		4
6.	ô u = z + z			aux_conv1
7.	ô x*y = u			2, 3, 5, 6
=TEX
If $x$ is odd we work as follows:
=GFT Example
1.	ô x = b + 1			plus1_conv
2.	ô b*y = z			recursive call
3.	ô x*y = (b + 1)*y		1
4.	ô (b + 1)*y = b*y + 1*y		3, distributivity
5.	ô b*y + 1*y = z + y		2, times_1_x
6.	ô z + y = u			plus_conv
7.	ô x*y = u			3, 4, 5, 6 
=TEX
=TEX
We capture the above arguments in two theorems:
=SML
val Ûevenx_times_y_thmÝ = (
push_goal([],¬µx y a z u·
		x = a + a
	´	a * y = z
	´	u = z + z
	´	x * y = u®);
a(REPEAT strip_tac);
a(asm_rewrite_tac[times_plus_distrib_thm]);
pop_thm()
);
=TEX
=SML
val Ûoddx_times_y_thmÝ = (
push_goal([],¬µx y b z u·
		x = b + 1
	´	b * y = z
	´	z + y = u
	´	x * y = u®);
a(REPEAT strip_tac);
a(asm_rewrite_tac[times_plus_distrib_thm, times_clauses]);
pop_thm()
);
=TEX
=SML
fun Ûtimes_conv_auxÝ (x : INTEGER) (y : INTEGER) = (
	case string_of_integer x of
		"0" => µ_elim (mk_î y) times_0_x
	|	"1" => µ_elim (mk_î y) times_1_x
	|	_ =>
		if x imod two = zero
		then	let	val a = x idiv two;
				val z = a @* y;
				val u = z @+ z;
				val tmx = mk_î x;
				val tmy = mk_î y;
				val tma = mk_î a;
				val tmz = mk_î z;
				val tmu = mk_î u;
				val thm1 = aux_conv1 tmx;
				val thm2 = times_conv_aux a y;
				val thm3 = aux_conv1 tmu
			in	list_´_mp_rule [thm1, thm2, thm3]
				(list_µ_elim[tmx, tmy, tma, tmz, tmu]
				evenx_times_y_thm)
		end else let	val b = x @- one;
				val z = b @* y;
				val u = z @+ y;
				val tmx = mk_î x;
				val tmy = mk_î y;
				val tmb = mk_î b;
				val tmz = mk_î z;
				val tmu = mk_î u;
				val thm1 = plus1_conv tmx;
				val thm2 = times_conv_aux b y;
				val thm3 = plus_conv (mk_plus(tmz, tmy))
			in	list_´_mp_rule [thm1, thm2, thm3]
				(list_µ_elim[tmx, tmy, tmb, tmz, tmu]
				oddx_times_y_thm)
			end 
);
=TEX
=SML
val Ûtimes_convÝ : CONV = (fn aopb =>
	let	val (a, b) = dest_bin_op "times_conv" 57009  "*" aopb;
	in	times_conv_aux  (dest_î a) (dest_î b)
	end	handle ex => term_divert ex "dest_î" "times_conv" 57009 [aopb]
);
=IGN
fun test_times (m : int) (n : int) = (
	let	val range = interval m n;
		fun aux1 i j = list_mk_app(¬$*®, [mk_î i, mk_î j]);
		fun aux2 i = map (aux1 i) range;
		val tab = map aux2 range;
	in	map (map times_conv) tab
	end
);
\subsection{DIVISION AND MODULUS}
\subsubsection{Lemmas}
=SML
val Ûdiv_lemmaÝ = (
push_goal([], ¬µx y d r· r < y ´ d * y + r = x ´ x Div y = d®);
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¬x®, ¬y®, ¬d®, ¬r®]div_mod_unique_thm));
pop_thm()
);
=TEX
=SML
val Ûmod_lemmaÝ = (
push_goal([], ¬µx y d r· r < y ´ d * y + r = x ´ x Mod y = r®);
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¬x®, ¬y®, ¬d®, ¬r®]div_mod_unique_thm));
pop_thm()
);
=TEX
\subsection{The Divider}
=SML
fun Ûdiv_mod_conv_auxÝ (thm : THM) (tmx : TERM) (tmy : TERM) : THM OPT = (
	let	val x = dest_î tmx;
		val y = dest_î tmy;
	in	if y <> zero
		then	let	val d = x idiv y;
				val r = x imod y;
				val tmd = mk_î d;
				val tmr = mk_î r;
				val thm1 = ¤_t_elim(less_conv(mk_less(tmr, tmy)));
				val thm2 =
	(RATOR_C(RAND_C times_conv) THEN_C plus_conv)
					(mk_plus(mk_times(tmd, tmy), tmr));
				val thm3 = list_µ_elim[tmx, tmy, tmd, tmr]
						thm;
			in	Value(list_´_mp_rule [thm1, thm2] thm3)
		 end else 	Nil
	end
);
=TEX
=SML
val Ûdiv_convÝ : CONV = (fn aopb =>
	let	val (a, b) = dest_bin_op "div_conv" 57003  "Div" aopb;
	in	case div_mod_conv_aux div_lemma a b of
			Value thm => thm
		|	Nil => term_fail "div_conv" 57011 [aopb]
	end	handle ex => term_divert ex "dest_î" "div_conv" 57003 [aopb]
);
=TEX
=SML
val Ûmod_convÝ : CONV = (fn aopb =>
	let	val (a, b) = dest_bin_op "mod_conv" 57007  "Mod" aopb;
	in	case div_mod_conv_aux mod_lemma a b of
			Value thm => thm
		|	Nil => term_fail "mod_conv" 57012 [aopb]
	end	handle ex => term_divert ex "dest_î" "mod_conv" 57007 [aopb]
);
=TEX
\section{CHARACTERS}
\subsection{Lemma}
=SML
val Ûchar_lemmaÝ = (
	push_goal([], ¬µc d : CHAR; x y : î·
		c = AbsChar x ´ d = AbsChar y ´ x < 256 ´ y < 256 ´
			(c = d ¤ x = y)®);
a(REPEAT strip_tac THEN TRY_T(asm_rewrite_tac[]));
a(LEMMA_T ¬x = RepChar c ± y = RepChar d® rewrite_thm_tac);
a(strip_asm_tac(µ_elim¬x®(rewrite_rule[is_char_rep_def]
	(±_right_elim abs_char_rep_char_def))));
a(strip_asm_tac(µ_elim¬y®(rewrite_rule[is_char_rep_def]
	(±_right_elim abs_char_rep_char_def))));
a(LIST_DROP_NTH_ASM_T [1, 2, 6, 7] rewrite_tac);
a(POP_ASM_T rewrite_thm_tac);
pop_thm()
);
=TEX
\subsection{The Conversion}
=SML
val lit256 = ¬256®;

fun Ûchar_eq_conv_auxÝ (tmc : TERM) (tmd : TERM) = (
	let	val thm1 = char_conv tmc;
		val thm2 = char_conv tmd;
		val tmx = snd(dest_app(snd(dest_eq(concl thm1))));
		val tmy = snd(dest_app(snd(dest_eq(concl thm2))));
		val thm3 = ¤_t_elim(less_conv (mk_less(tmx, lit256)));
		val thm4 = ¤_t_elim(less_conv (mk_less(tmy, lit256)));
	in	list_´_mp_rule [thm1, thm2, thm3, thm4]
		(list_µ_elim[tmc, tmd, tmx, tmy] char_lemma)
	end
);
=TEX
=SML
val Ûchar_eq_aux_convÝ : CONV = (fn aopb =>
	let	val (a, b) = dest_bin_op "char_eq_conv" 57200  "=" aopb;
	in	char_eq_conv_aux a b
	end	handle ex => term_divert ex "char_conv" "char_eq_conv" 57200 [aopb]
);
=TEX
=SML
val Ûchar_eq_convÝ : CONV = char_eq_aux_conv THEN_C î_eq_conv;
=TEX
\section{STRINGS}
=SML
val ÛblipaÝ = ”'a®;
=TEX
=SML
val Ûstring_lemma1Ý = tac_proof( ([], ¬"" = "" ¤ T®), rewrite_tac[]);
=TEX
=SML
val Ûstring_lemma2Ý = (
	push_goal([], ¬µx; t·"" = Cons x t ¤ F®);
a(rewrite_tac[list_clauses, string_conv ¬""®]);
pop_thm()
);
=TEX
=SML
val Ûstring_lemma3Ý = (
	push_goal([], ¬µx; t·Cons x t = "" ¤ F®);
a(rewrite_tac[list_clauses, string_conv ¬""®]);
pop_thm()
);
=TEX
=SML
val Ûstring_lemma4Ý = (
	push_goal([], ¬µx y: CHAR; t u·Cons x t = Cons y u ¤ x = y ± t = u®);
a(rewrite_tac[list_clauses]);
pop_thm()
);
=TEX
=SML
val Ûstring_lemma5Ý = tac_proof( ([], ¬µq·F ± q ¤ F®), rewrite_tac[]);
=TEX
=SML
val Ûstring_lemma6Ý = tac_proof( ([], ¬µq·T ± q ¤ q®), rewrite_tac[]);
val rec Ûstring_eq_convÝ : CONV = (fn tm =>
	let	val (tmx, tmy) = dest_bin_op "string_eq_conv" 57300  "=" tm;
	in	case (dest_string tmx, dest_string tmy) of
			("", "") => (string_lemma1
		) |	("", _) => (
			(RIGHT_C string_conv THEN_C eq_match_conv string_lemma2) tm
		) |	(_, "") => (
			(LEFT_C string_conv THEN_C eq_match_conv string_lemma3)tm
		) |	(_, _) => (
			(	RANDS_C(string_conv, string_conv)
			THEN_C	eq_match_conv string_lemma4
			THEN_C LEFT_C char_eq_conv
			THEN_C (	eq_match_conv string_lemma5
				ORELSE_C	(eq_match_conv string_lemma6
					THEN_C string_eq_conv))) tm
		)
	end
	handle ex => term_divert ex "dest_string" "string_eq_conv" 57300 [tm]
);
=TEX

\section{EPILOGUE}
=SML
val Ûside_effectÝ = open_theory old_theory;
val _ = pop_pc();
end; (* of structure CompConv *)
open CompConv;
=TEX
\twocolumn[\section{INDEX}]\label{Index}
\printindex
\end{document}
=IGN
fun test_div (m : int) (n : int) = (
	let	val range = interval m n;
		fun aux1 i j = list_mk_app(¬$Div®, [mk_î i, mk_î j]);
		fun aux2 i = map (aux1 i) range;
		val tab = map aux2 range;
	in	map (map div_conv) tab
	end
);
=TEX
=IGN
fun test_mod (m : int) (n : int) = (
	let	val range = interval m n;
		fun aux1 i j = list_mk_app(¬$Mod®, [mk_î i, mk_î j]);
		fun aux2 i = map (aux1 i) range;
		val tab = map aux2 range;
	in	map (map mod_conv) tab
	end
);
=TEX
=IGN
new_theory"temp";
declare_postfix(400, "!");
=TEX
=IGN
push_goal([], ¬¶$!·µm·
		0! = 1
	±	(m + 1)! = (m + 1) * m!		®);
a(strip_asm_tac (conv_rule all_%beta%_conv
	(list_µ_elim
	[¬1®, ¬Ìn·Ìm·(m + 1) * n®]
	(inst_type_rule[(”î®, ”'a®)]prim_rec_thm))));
a(¶_tac ¬f®);
a(asm_rewrite_tac[]);
=TEX
=IGN
val fact_exists_thm = pop_thm();
=TEX
=IGN
val Ûfact_defÝ = new_spec(["fact_def", "!"], 1, fact_exists_thm);
=TEX
=IGN
push_goal([], ¬µm·m! = if 0 < m then m * (m-1)! else 1®);
a(strip_tac);
a(induction_tac¬m:î®);
(* *** Goal "1" *** *)
a(rewrite_tac[fact_def]);
(* *** Goal "2" *** *)
a(rewrite_tac[fact_def, less_clauses, minus_def]);
=TEX
=IGN
val fact_thm = pop_thm();
=TEX
=IGN
val fact_conv = COND_C (is_î o snd o dest_app)
	(eq_match_conv fact_thm) fail_conv;
=TEX
=IGN
fact_conv ¬6!®;
fact_conv ¬x!®;
=TEX
