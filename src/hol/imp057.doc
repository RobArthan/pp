=IGN
********************************************************************************
imp057.doc: this file is part of the ProofPower system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************

=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Computational Conversions}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP057}  %% Mandatory field
\def\SCCSversion{$Revision: 1.15 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 1999/03/06 15:18:12 $%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & HAT Team Leader}
\TPPabstract{This document contains the implementation of conversions
which perform arithmetic computations on literals.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issue 1.4\ (\FormatDate{91/10/16%
})]
First drafts.
\item [Issue 1.5,1.6 (26th March 1992)]
Changed to use proof context material of issue 1.13 of \cite{DS/FMU/IED/DTD051}.
Now work in theory ``$basic\_hol$'', not ``$Ó$'' and ``$char$''.
\item [Issue 1.7 (14th April 1992)]
Changes due to CR0017.
\item [Issue 1.8,1.9 (12th May 1992)]
Changed theory.
\item [Issue 1.10 (14th May 1992)]
Tidying up proof contexts.
\item [Issue 1.11 (18th May 1992)]
Changed proof context material.
\item [Issue 1.12 (20th May 1992)]
Removed proof context "comp".
\item [Issue 1.13 (2nd June 1992)]
Changed ``native'' theory.
\item[Issue 1.14 (24th June 1992)]
Renamings from issue 1.6 of \cite{DS/FMU/IED/WRK038},
mostly proof context name changes.
\item[Issue 1.15] Update for new INTEGER type.
\item[Issue 1.16] Copyright and banner updates for open source release.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document implements the material whose detailed design is given
in \cite{DS/FMU/IED/DTD057}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD057}.
\subsubsection{Dependencies}
This document depends on the theory and proof procedures defined
in \cite{DS/FMU/IED/DTD038,DS/FMU/IED/IMP038} and on the proof context defined
in \cite{DS/FMU/IED/DTD029,DS/FMU/IED/IMP029}.
\subsubsection{Algorithms}
The implementation begins with some miscellaneous functions which
are used throughout the sequel. Thereafter,
for ease of development and maintenance, the conversions are implemented
following a standard pattern: for each
conversion we first prove one or
more theorems which capture the essence of the arithmetic computation
to be supported; then we define an auxiliary function which is parameterised
by the operands of the operation to be computed; and, finally we define
an interface function which calls the auxiliary, handles errors and
does any additional error-case detection which is not covered by the
auxiliary. The only exceptions are $gt\_conv$ and
$ge\_conv$ which are able to use the auxiliary functions supporting
$lt\_conv$ and $le\_conv$ fairly directly after rewriting the argument
term with the appropriate definition.

This style of implementation has the additional benefit that by formulating
the supporting theorems so as to minimise the amount of inference required
to use them, the resulting implementations can be made quite efficient.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Deficiencies}
None known.
\section{PROLOGUE}
=SML
structure €CompConv›  : CompConv = struct
val €old_theory› = get_current_theory_name();
=TEX
\section{ARITHMETIC}
=SML
val €side_effect› = open_theory"basic_hol";
val _ = push_merge_pcs ["'propositions",
	"'simple_abstractions"];
=TEX
\subsection{DERIVED SYNTAX FUNCTIONS}
=SML
val €dest_º› : TERM -> TERM*TERM = dest_bin_op "dest_º" 57501 "º";
val €dest_æ› : TERM -> TERM*TERM = dest_bin_op "dest_æ" 57502 "æ";
val €dest_div› : TERM -> TERM*TERM = dest_bin_op "dest_div" 57503 "Div";
val €dest_greater› : TERM -> TERM*TERM = dest_bin_op "dest_greater" 57504 ">";
val €dest_less› : TERM -> TERM*TERM = dest_bin_op "dest_less" 57505 "<";
val €dest_minus› : TERM -> TERM*TERM = dest_bin_op "dest_minus" 57506 "-";
val €dest_mod› : TERM -> TERM*TERM = dest_bin_op "dest_mod" 57507 "Mod";
val €dest_plus› : TERM -> TERM*TERM = dest_bin_op "dest_plus" 57508 "+";
val €dest_times› : TERM -> TERM*TERM = dest_bin_op "dest_times" 57509 "*";
=TEX
=SML
val €is_º› : TERM -> bool = is_bin_op "º";
val €is_æ› : TERM -> bool = is_bin_op "æ";
val €is_div› : TERM -> bool = is_bin_op "Div";
val €is_greater› : TERM -> bool = is_bin_op ">";
val €is_less› : TERM -> bool = is_bin_op "<";
val €is_minus› : TERM -> bool = is_bin_op "-";
val €is_mod› : TERM -> bool = is_bin_op "Mod";
val €is_plus› : TERM -> bool = is_bin_op "+";
val €is_times› : TERM -> bool = is_bin_op "*";
=TEX
N.b. Care has been taken in the following to ensure that all the
parser calls are made at compile-time.
=SML
fun €rator_ty› ty = (mk_≠_type(îÓÆ, mk_≠_type(îÓÆ, ty)));
fun €rator_fn› (nm : string) (ty : TYPE) : TYPE -> TYPE -> TERM = (
	let val act_ty = rator_ty ty;
	in	(fn _ => fn _ => mk_const (nm, act_ty))
	end
);
=TEX
=SML
val €mk_º› : TERM*TERM -> TERM =
	mk_bin_op "mk_º" 57510 57511 (rator_fn"º"îBOOLÆ);
val €mk_æ› : TERM*TERM -> TERM =
	mk_bin_op "mk_æ" 57510 57511 (rator_fn"æ"îBOOLÆ);
val €mk_div› : TERM*TERM -> TERM =
	mk_bin_op "mk_div" 57510 57511 (rator_fn"Div"îÓÆ);
val €mk_greater› : TERM*TERM -> TERM =
	mk_bin_op "mk_greater" 57510 57511 (rator_fn">"îBOOLÆ);
val €mk_less› : TERM*TERM -> TERM =
	mk_bin_op "mk_less" 57510 57511 (rator_fn"<"îBOOLÆ);
val €mk_minus› : TERM*TERM -> TERM =
	mk_bin_op "mk_minus" 57510 57511 (rator_fn"-"îÓÆ);
val €mk_mod› : TERM*TERM -> TERM =
	mk_bin_op "mk_mod" 57510 57511 (rator_fn"Mod"îÓÆ);
val €mk_plus› : TERM*TERM -> TERM =
	mk_bin_op "mk_plus" 57510 57511 (rator_fn"+"îÓÆ);
val €mk_times› : TERM*TERM -> TERM =
	mk_bin_op "mk_times" 57510 57511 (rator_fn"*"îÓÆ);
=TEX
\subsection{MISCELLANEOUS FUNCTIONS}
=SML
fun term_divert (ex : exn)
		(fromarea : string)
		(toarea : string)
		(msg : int)
		(tms : TERM list) : 'a = (
	divert ex fromarea toarea msg (map (fn t => (fn () => string_of_term t)) tms)
);
=SML
val €LEFT_C› =  RATOR_C o RAND_C;
val €RIGHT_C› = RAND_C;
val €RANDS_C› = APP_C o (RAND_C ** Combinators.I);
=TEX
These functions do not do any error handling, it is the caller's
responsibility to ensure that arguments are in range.
=SML
val €hol_one› = ¨1Æ;
=TEX
$aux\_conv1$ proves any theorem of the form $x = q + q$, where
$x$ and $q$ are numeric literals. It is caller's responsibility
to supply an even $x$.
=SML
val two = @@"2";
val €aux_conv1› : CONV = (fn tm =>
	let	val x = dest_Ó tm;
		val xdiv2 = mk_Ó(x idiv two);
	in	eq_sym_rule
		(plus_conv (mk_plus(xdiv2, xdiv2)))
	end
);
=TEX
=SML
val €list_¥_mp_rule› = revfold (uncurry(switch ¥_mp_rule));
=TEX
=IGN
list_¥_mp_rule [asm_rule¨A:BOOLÆ, asm_rule¨B:BOOLÆ, asm_rule¨C:BOOLÆ]
	(asm_rule¨A ¥ B ¥ C ¥ DÆ);
=TEX
\subsection{RELATIONS}
\subsubsection{º}
We use the following lemmas to assist in $le\_conv$:
=SML
val €º_t_lemma› = tac_proof(
	([], ¨µx y a∑x + a = y ¥ (x º y § T)Æ),
	REPEAT strip_tac THEN rewrite_tac[º_def]
	THEN ∂_tac¨a:ÓÆ THEN asm_rewrite_tac[]);
=TEX
=SML
val €º_f_lemma› = tac_proof(
	([], ¨µx y a∑y + a + 1 = x ¥ (x º y § F)Æ),
	rewrite_tac[≥_º_thm, less_def, º_def] THEN REPEAT strip_tac
	THEN ∂_tac¨a:ÓÆ THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule)
	THEN rewrite_tac[plus_clauses, plus_assoc_thm]);
=TEX
=SML
fun €º_conv_aux› (tmx : TERM) (tmy : TERM) = (
	let	val x = dest_Ó tmx;
		val y = dest_Ó tmy;
	in	if x @<= y
		then	let	val a = y @- x;
				val tma = mk_Ó a;
				val thm1 = plus_conv(mk_plus(tmx, tma));
				val thm2 = list_µ_elim[tmx, tmy, tma]
						º_t_lemma;
			in	¥_mp_rule thm2 thm1
		end else let	val a = x @- (y @+ one);
				val tma = mk_Ó a;
				val thm1 = (RAND_C plus_conv THEN_C plus_conv)
					(mk_plus(tmy, mk_plus(tma, hol_one)));
				val thm2 = list_µ_elim[tmx, tmy, tma]
						º_f_lemma;
			in	¥_mp_rule thm2 thm1
		end
	end
);
=TEX
=IGN
val €tmx› = ¨10Æ;
val €tmy› = ¨20Æ;
=SML
val €º_conv› : CONV = (fn aopb =>
	let	val (a, b) = dest_bin_op "º_conv" 57001  "º" aopb;
	in	º_conv_aux  a b
	end	handle ex => term_divert ex "dest_Ó" "º_conv" 57001 [aopb]
);
=TEX
\subsubsection{$<$}
We use the following lemmas to assist in $le\_conv$:
=SML
val €less_t_lemma› = tac_proof(
	([], ¨µx y a∑x + a + 1 = y ¥ (x < y § T)Æ),
	rewrite_tac[less_def, º_def] THEN REPEAT strip_tac
	THEN ∂_tac¨a:ÓÆ THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule)
	THEN rewrite_tac[plus_clauses, plus_assoc_thm]);
=TEX
=SML
val €less_f_lemma› = tac_proof(
	([], ¨µx y a∑y + a = x ¥ (x < y § F)Æ),
	rewrite_tac[≥_less_thm, º_def] THEN REPEAT strip_tac
	THEN ∂_tac¨a:ÓÆ THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule)
	THEN rewrite_tac[plus_clauses, plus_assoc_thm]);
=TEX
=SML
fun €less_conv_aux› (tmx : TERM) (tmy : TERM) = (
	let	val x = dest_Ó tmx;
		val y = dest_Ó tmy;
	in	if x @< y
		then	let	val a = y @- (x @+ one);
				val tma = mk_Ó a;
				val thm1 = (RAND_C plus_conv THEN_C plus_conv)
					(mk_plus(tmx, mk_plus(tma, hol_one)));
				val thm2 = list_µ_elim[tmx, tmy, tma]
						less_t_lemma;
			in	¥_mp_rule thm2 thm1
		end else let	val a = x @- y;
				val tma = mk_Ó a;
				val thm1 = plus_conv(mk_plus(tmy, tma));
				val thm2 = list_µ_elim[tmx, tmy, tma]
						less_f_lemma;
			in	¥_mp_rule thm2 thm1
		end
	end
);
=TEX
=SML
val €less_conv› : CONV = (fn aopb =>
	let	val (a, b) = dest_bin_op "less_conv" 57005  "<" aopb;
	in	less_conv_aux  a b
	end	handle ex => term_divert ex "dest_Ó" "less_conv" 57005 [aopb]
);
=TEX
\subsubsection{æ}
=SML
val €æ_conv› : CONV = (fn aopb =>
	let	val check = dest_bin_op "æ_conv" 57002  "æ" aopb;
	in	(eq_match_conv æ_def THEN_C º_conv) aopb
	end	handle ex => term_divert ex "º_conv" "æ_conv" 57002 [aopb]
);
=TEX
\subsubsection{$>$}
=SML
val €greater_conv› : CONV = (fn aopb =>
	let	val check = dest_bin_op "greater_conv" 57004  ">" aopb;
	in	(eq_match_conv greater_def THEN_C less_conv) aopb
	end	handle ex => term_divert ex "less_conv" "greater_conv" 57004 [aopb]
);
=TEX
\subsubsection{Numerical Equality}
=SML
=TEX
=SML
val €Ó_eq_lemma1› = tac_proof(
	([], ¨µx y∑x < y ¥ (x = y § F)Æ),
	REPEAT strip_tac
	THEN asm_ante_tac ¨x < yÆ
	THEN asm_rewrite_tac[]
	THEN strip_asm_tac (list_µ_elim[¨y:ÓÆ, ¨y:ÓÆ] less_irrefl_thm)
);
=TEX
=SML
val €Ó_eq_lemma2› = tac_proof(
	([], ¨µx y∑y < x ¥ (x = y § F)Æ),
	REPEAT strip_tac
	THEN strip_asm_tac (list_µ_elim[¨y:ÓÆ, ¨x:ÓÆ] Ó_eq_lemma1)
	THEN asm_ante_tac¨≥ (y:Ó) = xÆ 
	THEN asm_rewrite_tac[]
);
=TEX
=SML
fun €Ó_eq_conv_aux› (tmx : TERM) (tmy : TERM) = (
	let	val x = dest_Ó tmx;
		val y = dest_Ó tmy;
	in	if x = y
		then	§_t_intro(refl_conv tmx)
		else if x @< y
		then let	val thm1 = §_t_elim(less_conv_aux tmx tmy);
				val thm2 = list_µ_elim[tmx, tmy]
						Ó_eq_lemma1;
			in	¥_mp_rule thm2 thm1
		end else let	val thm1 = §_t_elim(less_conv_aux tmy tmx);
				val thm2 = list_µ_elim[tmx, tmy]
						Ó_eq_lemma2;
			in	¥_mp_rule thm2 thm1
		end
	end
);
=TEX
=SML
val €Ó_eq_conv› : CONV = (fn aopb =>
	let	val (a, b) = dest_bin_op "Ó_eq_conv" 57100  "=" aopb;
	in	Ó_eq_conv_aux  a b
	end	handle ex => term_divert ex "dest_Ó" "Ó_eq_conv" 57100 [aopb]
);
=TEX
\subsection{ADDITION}
This is quite easy!
=SML
val €plus_conv› = DerivedRules1.plus_conv;
=TEX
\subsection{SUBTRACTION}
\subsubsection{Lemma}
=SML
val €minus_lemma› = tac_proof(
	([], ¨µx y a∑a + y = x ¥ (x - y = a)Æ),
	REPEAT strip_tac THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule)
	THEN rewrite_tac[minus_def]);
=TEX
=SML
fun €minus_conv_aux› (aopb :TERM) (tmx : TERM) (tmy : TERM) = (
	let	val x = dest_Ó tmx;
		val y = dest_Ó tmy;
	in	if x @>= y
		then	let	val a = x @- y;
				val tma = mk_Ó a;
				val thm1 = plus_conv(mk_plus(tma, tmy));
				val thm2 = list_µ_elim[tmx, tmy, tma]
						minus_lemma;
			in	¥_mp_rule thm2 thm1
		 end else 	term_fail "minus_conv" 57010 [aopb]
	end
);
=TEX
=SML
val €minus_conv› : CONV = (fn aopb =>
	let	val (a, b) = dest_bin_op "minus_conv" 57006  "-" aopb;
	in	minus_conv_aux aopb a b
	end	handle ex => term_divert ex "dest_Ó" "minus_conv" 57006 [aopb]
);
=TEX
\subsection{MULTIPLICATION}
\subsubsection{Lemmas}
=SML
val €times_0_x› = tac_proof(([], ¨µx∑0 * x = 0Æ), rewrite_tac[times_clauses]);
val €times_1_x› = tac_proof(([], ¨µx∑1 * x = xÆ), rewrite_tac[times_clauses]);
=TEX
\subsubsection{The Multiplier}
We compute $x * y$ where $x > 1$ is even as follows:
=GFT Example
1.	Ù x = a + a			aux_conv1
2.	Ù x*y = (a + a)*y		1
3.	Ù (a + a)*y = a*y + a*y	2, distributivity
4.	Ù a*y = z			recursive call
5.	Ù a*y + a*y = z + z		4
6.	Ù u = z + z			aux_conv1
7.	Ù x*y = u			2, 3, 5, 6
=TEX
If $x$ is odd we work as follows:
=GFT Example
1.	Ù x = b + 1			plus1_conv
2.	Ù b*y = z			recursive call
3.	Ù x*y = (b + 1)*y		1
4.	Ù (b + 1)*y = b*y + 1*y		3, distributivity
5.	Ù b*y + 1*y = z + y		2, times_1_x
6.	Ù z + y = u			plus_conv
7.	Ù x*y = u			3, 4, 5, 6 
=TEX
=TEX
We capture the above arguments in two theorems:
=SML
val €evenx_times_y_thm› = (
push_goal([],¨µx y a z u∑
		x = a + a
	¥	a * y = z
	¥	u = z + z
	¥	x * y = uÆ);
a(REPEAT strip_tac);
a(asm_rewrite_tac[times_plus_distrib_thm]);
pop_thm()
);
=TEX
=SML
val €oddx_times_y_thm› = (
push_goal([],¨µx y b z u∑
		x = b + 1
	¥	b * y = z
	¥	z + y = u
	¥	x * y = uÆ);
a(REPEAT strip_tac);
a(asm_rewrite_tac[times_plus_distrib_thm, times_clauses]);
pop_thm()
);
=TEX
=SML
fun €times_conv_aux› (x : INTEGER) (y : INTEGER) = (
	case string_of_integer x of
		"0" => µ_elim (mk_Ó y) times_0_x
	|	"1" => µ_elim (mk_Ó y) times_1_x
	|	_ =>
		if x imod two = zero
		then	let	val a = x idiv two;
				val z = a @* y;
				val u = z @+ z;
				val tmx = mk_Ó x;
				val tmy = mk_Ó y;
				val tma = mk_Ó a;
				val tmz = mk_Ó z;
				val tmu = mk_Ó u;
				val thm1 = aux_conv1 tmx;
				val thm2 = times_conv_aux a y;
				val thm3 = aux_conv1 tmu
			in	list_¥_mp_rule [thm1, thm2, thm3]
				(list_µ_elim[tmx, tmy, tma, tmz, tmu]
				evenx_times_y_thm)
		end else let	val b = x @- one;
				val z = b @* y;
				val u = z @+ y;
				val tmx = mk_Ó x;
				val tmy = mk_Ó y;
				val tmb = mk_Ó b;
				val tmz = mk_Ó z;
				val tmu = mk_Ó u;
				val thm1 = plus1_conv tmx;
				val thm2 = times_conv_aux b y;
				val thm3 = plus_conv (mk_plus(tmz, tmy))
			in	list_¥_mp_rule [thm1, thm2, thm3]
				(list_µ_elim[tmx, tmy, tmb, tmz, tmu]
				oddx_times_y_thm)
			end 
);
=TEX
=SML
val €times_conv› : CONV = (fn aopb =>
	let	val (a, b) = dest_bin_op "times_conv" 57009  "*" aopb;
	in	times_conv_aux  (dest_Ó a) (dest_Ó b)
	end	handle ex => term_divert ex "dest_Ó" "times_conv" 57009 [aopb]
);
=IGN
fun test_times (m : int) (n : int) = (
	let	val range = interval m n;
		fun aux1 i j = list_mk_app(¨$*Æ, [mk_Ó i, mk_Ó j]);
		fun aux2 i = map (aux1 i) range;
		val tab = map aux2 range;
	in	map (map times_conv) tab
	end
);
\subsection{DIVISION AND MODULUS}
\subsubsection{Lemmas}
=SML
val €div_lemma› = (
push_goal([], ¨µx y d r∑ r < y ¥ d * y + r = x ¥ x Div y = dÆ);
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨xÆ, ¨yÆ, ¨dÆ, ¨rÆ]div_mod_unique_thm));
pop_thm()
);
=TEX
=SML
val €mod_lemma› = (
push_goal([], ¨µx y d r∑ r < y ¥ d * y + r = x ¥ x Mod y = rÆ);
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨xÆ, ¨yÆ, ¨dÆ, ¨rÆ]div_mod_unique_thm));
pop_thm()
);
=TEX
\subsection{The Divider}
=SML
fun €div_mod_conv_aux› (thm : THM) (tmx : TERM) (tmy : TERM) : THM OPT = (
	let	val x = dest_Ó tmx;
		val y = dest_Ó tmy;
	in	if y <> zero
		then	let	val d = x idiv y;
				val r = x imod y;
				val tmd = mk_Ó d;
				val tmr = mk_Ó r;
				val thm1 = §_t_elim(less_conv(mk_less(tmr, tmy)));
				val thm2 =
	(RATOR_C(RAND_C times_conv) THEN_C plus_conv)
					(mk_plus(mk_times(tmd, tmy), tmr));
				val thm3 = list_µ_elim[tmx, tmy, tmd, tmr]
						thm;
			in	Value(list_¥_mp_rule [thm1, thm2] thm3)
		 end else 	Nil
	end
);
=TEX
=SML
val €div_conv› : CONV = (fn aopb =>
	let	val (a, b) = dest_bin_op "div_conv" 57003  "Div" aopb;
	in	case div_mod_conv_aux div_lemma a b of
			Value thm => thm
		|	Nil => term_fail "div_conv" 57011 [aopb]
	end	handle ex => term_divert ex "dest_Ó" "div_conv" 57003 [aopb]
);
=TEX
=SML
val €mod_conv› : CONV = (fn aopb =>
	let	val (a, b) = dest_bin_op "mod_conv" 57007  "Mod" aopb;
	in	case div_mod_conv_aux mod_lemma a b of
			Value thm => thm
		|	Nil => term_fail "mod_conv" 57012 [aopb]
	end	handle ex => term_divert ex "dest_Ó" "mod_conv" 57007 [aopb]
);
=TEX
\section{CHARACTERS}
\subsection{Lemma}
=SML
val €char_lemma› = (
	push_goal([], ¨µc d : CHAR; x y : Ó∑
		c = AbsChar x ¥ d = AbsChar y ¥ x < 256 ¥ y < 256 ¥
			(c = d § x = y)Æ);
a(REPEAT strip_tac THEN TRY_T(asm_rewrite_tac[]));
a(LEMMA_T ¨x = RepChar c ± y = RepChar dÆ rewrite_thm_tac);
a(strip_asm_tac(µ_elim¨xÆ(rewrite_rule[is_char_rep_def]
	(±_right_elim abs_char_rep_char_def))));
a(strip_asm_tac(µ_elim¨yÆ(rewrite_rule[is_char_rep_def]
	(±_right_elim abs_char_rep_char_def))));
a(LIST_DROP_NTH_ASM_T [1, 2, 6, 7] rewrite_tac);
a(POP_ASM_T rewrite_thm_tac);
pop_thm()
);
=TEX
\subsection{The Conversion}
=SML
val lit256 = ¨256Æ;

fun €char_eq_conv_aux› (tmc : TERM) (tmd : TERM) = (
	let	val thm1 = char_conv tmc;
		val thm2 = char_conv tmd;
		val tmx = snd(dest_app(snd(dest_eq(concl thm1))));
		val tmy = snd(dest_app(snd(dest_eq(concl thm2))));
		val thm3 = §_t_elim(less_conv (mk_less(tmx, lit256)));
		val thm4 = §_t_elim(less_conv (mk_less(tmy, lit256)));
	in	list_¥_mp_rule [thm1, thm2, thm3, thm4]
		(list_µ_elim[tmc, tmd, tmx, tmy] char_lemma)
	end
);
=TEX
=SML
val €char_eq_aux_conv› : CONV = (fn aopb =>
	let	val (a, b) = dest_bin_op "char_eq_conv" 57200  "=" aopb;
	in	char_eq_conv_aux a b
	end	handle ex => term_divert ex "char_conv" "char_eq_conv" 57200 [aopb]
);
=TEX
=SML
val €char_eq_conv› : CONV = char_eq_aux_conv THEN_C Ó_eq_conv;
=TEX
\section{STRINGS}
=SML
val €blipa› = î'aÆ;
=TEX
=SML
val €string_lemma1› = tac_proof( ([], ¨"" = "" § TÆ), rewrite_tac[]);
=TEX
=SML
val €string_lemma2› = (
	push_goal([], ¨µx; t∑"" = Cons x t § FÆ);
a(rewrite_tac[list_clauses, string_conv ¨""Æ]);
pop_thm()
);
=TEX
=SML
val €string_lemma3› = (
	push_goal([], ¨µx; t∑Cons x t = "" § FÆ);
a(rewrite_tac[list_clauses, string_conv ¨""Æ]);
pop_thm()
);
=TEX
=SML
val €string_lemma4› = (
	push_goal([], ¨µx y: CHAR; t u∑Cons x t = Cons y u § x = y ± t = uÆ);
a(rewrite_tac[list_clauses]);
pop_thm()
);
=TEX
=SML
val €string_lemma5› = tac_proof( ([], ¨µq∑F ± q § FÆ), rewrite_tac[]);
=TEX
=SML
val €string_lemma6› = tac_proof( ([], ¨µq∑T ± q § qÆ), rewrite_tac[]);
val rec €string_eq_conv› : CONV = (fn tm =>
	let	val (tmx, tmy) = dest_bin_op "string_eq_conv" 57300  "=" tm;
	in	case (dest_string tmx, dest_string tmy) of
			("", "") => (string_lemma1
		) |	("", _) => (
			(RIGHT_C string_conv THEN_C eq_match_conv string_lemma2) tm
		) |	(_, "") => (
			(LEFT_C string_conv THEN_C eq_match_conv string_lemma3)tm
		) |	(_, _) => (
			(	RANDS_C(string_conv, string_conv)
			THEN_C	eq_match_conv string_lemma4
			THEN_C LEFT_C char_eq_conv
			THEN_C (	eq_match_conv string_lemma5
				ORELSE_C	(eq_match_conv string_lemma6
					THEN_C string_eq_conv))) tm
		)
	end
	handle ex => term_divert ex "dest_string" "string_eq_conv" 57300 [tm]
);
=TEX

\section{EPILOGUE}
=SML
val €side_effect› = open_theory old_theory;
val _ = pop_pc();
end; (* of structure CompConv *)
open CompConv;
=TEX
\twocolumn[\section{INDEX}]\label{Index}
\printindex
\end{document}
=IGN
fun test_div (m : int) (n : int) = (
	let	val range = interval m n;
		fun aux1 i j = list_mk_app(¨$DivÆ, [mk_Ó i, mk_Ó j]);
		fun aux2 i = map (aux1 i) range;
		val tab = map aux2 range;
	in	map (map div_conv) tab
	end
);
=TEX
=IGN
fun test_mod (m : int) (n : int) = (
	let	val range = interval m n;
		fun aux1 i j = list_mk_app(¨$ModÆ, [mk_Ó i, mk_Ó j]);
		fun aux2 i = map (aux1 i) range;
		val tab = map aux2 range;
	in	map (map mod_conv) tab
	end
);
=TEX
=IGN
new_theory"temp";
declare_postfix(400, "!");
=TEX
=IGN
push_goal([], ¨∂$!∑µm∑
		0! = 1
	±	(m + 1)! = (m + 1) * m!		Æ);
a(strip_asm_tac (conv_rule all_%beta%_conv
	(list_µ_elim
	[¨1Æ, ¨Ãn∑Ãm∑(m + 1) * nÆ]
	(inst_type_rule[(îÓÆ, î'aÆ)]prim_rec_thm))));
a(∂_tac ¨fÆ);
a(asm_rewrite_tac[]);
=TEX
=IGN
val fact_exists_thm = pop_thm();
=TEX
=IGN
val €fact_def› = new_spec(["fact_def", "!"], 1, fact_exists_thm);
=TEX
=IGN
push_goal([], ¨µm∑m! = if 0 < m then m * (m-1)! else 1Æ);
a(strip_tac);
a(induction_tac¨m:ÓÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[fact_def]);
(* *** Goal "2" *** *)
a(rewrite_tac[fact_def, less_clauses, minus_def]);
=TEX
=IGN
val fact_thm = pop_thm();
=TEX
=IGN
val fact_conv = COND_C (is_Ó o snd o dest_app)
	(eq_match_conv fact_thm) fail_conv;
=TEX
=IGN
fact_conv ¨6!Æ;
fact_conv ¨x!Æ;
=TEX
