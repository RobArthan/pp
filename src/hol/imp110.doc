% imp005.doc %Z% $Date$ $Revision$ $RCSfile$

=TEX
% imp005.doc %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol,11pt,TQ]{article}

\TPPtitle{File and Terminal Reader Writer}
\TPPref{DS/FMU/IED/IMP005}
\TPPissue{$Revision$%
}

\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{IED 1563}

=IGN

Commands to process this document in various ways.

make -f rel001.mkf imp005.dvi
doc4tex imp005
tex4dvi imp005
bibtex imp005
doc4tex imp005 ; tex4dvi imp005
dvipage imp005 &

dviselect 31:   imp005.dvi | pstex -
dviselect 16:30 imp005.dvi | pstex -
dviselect  1:15 imp005.dvi | pstex -


doc4errors imp005
PolyML.use "imp005.sml";

abandon_reader_writer();

poly -r sun4hol.db
poly -r /hat/projects/ied/rel001/sun4hol.db


lasp -s imp005.doc > zz1
lasp -s -u imp005.OKwords imp005.doc > zz1

=TEX
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Standard}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the reading and writing functions
	that form the outermost level of user interface for Release~1
	of ICL~HOL.  These functions are concerned with the
	differentiation of the various languages (initially Standard~ML
	and HOL), and the extensions to support pretty characters in
	Standard~ML identifiers and in strings.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

%\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\makeatletter
\def\StartTerm{\@Mm{\mathchar"2\@fx70\relax}}
\def\EndTerm{\@Mm{\mathchar"2\@fx71\relax}}

\def\UPchar{\@Mm{\mathchar"0\@fx66\relax}}
\def\DNchar{\@Mm{\mathchar"0\@fx67\relax}}

\def\calllatex{\@Mm{\mathchar"0\@fx7B}}
\def\negate{\@Mm{\mathchar"0\@fy6B}}

\def¸{\calllatex}
\defª{\negate}
\defã{\DNchar}
\defÂ{\UPchar}

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}
\makeatother


\def\Compiler{C{\tiny OMPILER}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

%********************************************************************

\subsection{Contents List}
\tableofcontents
% \listoftables

%********************************************************************

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

%********************************************************************

\subsection{Changes History}

\begin{description}

\item[1 February 1991, issue 1.1 ] This issue is an authors draft.

\item[4 February 1991, issue 1.2 ] $useterminal$ is invoked by loading
	this file, and $usefile$ is set to be used in subsequent
	Install's used in building {\tt hol.db}.

\item[21 February 1991, issue 1.3 ] Change the control-D handling in
	$useterminal$.  Add a proper writer function that converts
	ASCII strings into pretty characters.

\item[6 March 1991, issue 1.4 ] Restructure to give support for other
	language readers via structure $ReaderWriterSupport$ and use
	that to form the HOL reader.  Minor improvements throughout,
	particularly in $useterminal$.

\item[28 March 1991, issue 1.5 ] Simplifications to type $NAME_CLASS$
	and to support for embedded strings.  Percent characters now
	enclose keywords rather than just starting them.  Complete
	the HOL reader.  Improvements throughout.

\item[22 April 1991, issue 1.6 ] Changed from $initial\_E\_DICT$ to
	$initial\_e\_dict$.

\item[14 May 1991, issue 1.7 ] Extensive changes.  New form of quotation of
	other languages.  Better split between the three structures.

\item[17 May 1991, issue 1.8 ] Restructure function $useterminal$ and add
	function $ask_at_terminal$.

\item[14 June 1991, issue 1.9 ] Treat ``Q''s in HOL text the same as in
	Standard~ML.

\end{description}

%********************************************************************

\subsection{Changes Forecast} \label{ChangesForecast}

\begin{enumerate}

\item Properly install $useterminal$ as the outermost reader writer of
	the system.  This will include producing proper handling of the
	routines $PolyML.quit$ and $PolyML.commit$ together with the
	implicit calling of $PolyML.commit$ at end of input.

\item Provide the complete and proper set of pretty characters and
	keywords in sections~\ref{PrettyCharacterDictionary}
	and~\ref{PrettyCharactersForHOL}.

\item Consider removing the bracket handling routines in the basic
	reader writer, they were needed for the HOL~88 style of anti
	quotation but seem unnecessary with the style now provided
	here.  However, how does the error recovery cope when there is
	less knowledge of the language structure?

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the reading and writing routines for Release~1 of
the ICL HOL system.

%********************************************************************

\subsection{Introduction}

%--------------------------------------------------------------------

%\subsubsection{Purpose and Background}

%A brief description of the
%purpose of the objects defined in the document together
%with any references to related material, design notes or
%the like. Any separate specification document for the
%code should be referenced here.

%--------------------------------------------------------------------

%\subsubsection{Dependencies}

%An indication of which literate
%scripts this document is dependent on.

%--------------------------------------------------------------------

%\subsubsection{Interface}

%A brief explanation of the external
%interface presented by the document.
%If the document is part of a prototyping exercise
%and contains one or more Standard ML structures
%then the signatures for these structures should go
%in this section if they are not given in a separate design document.

%--------------------------------------------------------------------

%\subsubsection{Algorithms}

%Introductory observations on any special
%algorithms or techniques used in the document.
%(This section is intended to augment, rather than
%substitute for, detailed discussion of particular
%functions in the rest of the document).
%This should contain references to books or
%external papers, if any, which a maintainer would need
%to read to understand the code.

%--------------------------------------------------------------------

%\subsubsection{Possible Enhancements}

%A discussion of ways the facilities
%offered by the document might be improved, e.g. an indication
%of possible performance bottle-necks.

%--------------------------------------------------------------------

%\subsubsection{Deficiencies}

%An indication of any shortcomings in the
%facilities offered by the document.

%--------------------------------------------------------------------

\subsubsection{Terminology}

The word `\Compiler' is used to denote the part of a Standard~ML system
that lexically analyses, parses, evaluates and formats for output
Standard~ML text.  The routine $PolyML.compiler$ is an example of a
`\Compiler'.

The `basic reader writer' supports reading and writing Standard~ML,
plus the interfaces to allow additional languages to be embedded.  It
is contained within structure $ReaderWriter$.

The `reader writer' includes the `basic reader writer' plus the reading
and writing functions for other languages which have been added via the
embedding interface in structure $ReaderWriterSupport$.

%--------------------------------------------------------------------

% \subsection{Deviations From Definition Document \protect{\cite{DS/FMU/IED/DEF002}}}

% Some changes are necessary to the ideas proposed
% in~\cite[issue~1.1]{DS/FMU/IED/DEF002}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{PRELUDE}

%********************************************************************

\subsection{Start of Basic Reader Writer}

The reader writer structure, $ReaderWriter$, contains only those values
that are required at top level, it is opened at the end of this file.
All of the reader writer routines are actually declared in the support
structure, $ReaderWriterSupport$, some of them are bound to names in
the reader writer structure.

=SML
structure âReaderWriterSupportá : ReaderWriterSupport = struct
=TEX

%********************************************************************

\subsection{Integers and Strings}

The string representation of integers is needed in various places.
This is mainly to do with Standard~ML strings where some characters are
denoted by their decimal code in three digits, preceded by a
backslash.  Function $string_of_int3$ gives a three character with
leading zeros representation of small positive numbers.

=SML
fun âstring_of_int3á n = (
	let
		val str = if n < 0 then "-****" else string_of_int n
	in
		case size str
		of 0 => "000"
		| 1 => "00" ^ str
		| 2 => "0" ^ str
		| 3 => str
		| x => fail "string_of_int3" 5040
			[fn () => PolyML.makestring n]
	end
);
=TEX

Some strings are built up and passed on to $PolyML.compiler$, these
must be valid Standard~ML strings.  Function $to_ML_string$ converts
any string into a valid string.

=SML
fun âto_ML_stringá str = (
let
	fun	aux (ch as " ") = ch
	|	aux (ch as "\n") = ch
	|	aux (ch as "\t") = ch
	|	aux ch = (
			if (ord ch >= 32 andalso ord ch <= 126)
			then ch
			else "\\" ^ (string_of_int3(ord ch)))
in
	implode(map aux (explode str))
end);
=TEX


%********************************************************************

\subsection{Warning Messages} \label{WarningMessages}

Based on the ideas in~\cite{DS/FMU/IED/DTD002}
and~\cite{DS/FMU/IED/IMP002}, these functions have the same set of
arguments as functions $error$ and $fail$, their purpose is to output the
warning message and then allow the calling function to continue.  It is
definitely not the $warn$ function discussed
in~\cite{DS/FMU/IED/DTD002} which prompts the user about continuing or
stopping.  This function provides a commentary on events as they
happen, it is intended to provide messages (1)~during the build and
extension of the tables of symbols, and (2)~messages about faults in
the users input which are detected by the reader writer.

=SML
fun âlocal_warná (area : string) (id : int) (inserters : (unit -> string) list) : unit = (
	diag_string(
			"*** WARNING "
		^	(string_of_int id)
		^	" from "
		^	area
		^	": "
		^	(get_error_message id (map (fn f => f())inserters))
	)
);
=TEX

=SML
fun âlocal_errorá (area : string) (id : int) (inserters : (unit -> string) list) : unit = (
	diag_string(
			"*** ERROR "
		^	(string_of_int id)
		^	" from "
		^	area
		^	": "
		^	(get_error_message id (map (fn f => f())inserters))
	)
);
=TEX

Details of warnings and errors are added to the generated text.

=SML
fun âadd_error_codeá (err_no:int, prev:string list) : string list = (
	" ERROR__" ^ (string_of_int err_no) ^ " " :: prev
);
=TEX

=SML
fun	âadd_error_codesá (nil:int list, prev:string list) : string list =
		prev
|	add_error_codes (err_nos, prev) = (
		fold add_error_code err_nos prev
);
=TEX

%********************************************************************

\subsection{Reader Environment} \label{DeclareReaderEnv}

A record structure is used to contain the environment used when
reading, this is primarily the character reading functions to
accommodate the various sources of Standard~ML text discussed in
section~\ref{IclHolInterface}.  The record is properly described in
section~\ref{ReaderEnvironment}, but its definition is presented here
to enable its use within the table of pretty characters, in particular
its use within the datatype $NAME_CLASS$ of
section~\ref{DeclareNameClass}.

=SML
type âREADER_ENVá = {
	âadvanceá			: unit -> string,
	âlook_at_nextá			: unit -> string,
	âpush_backá			: string -> unit,
	âskip_and_look_at_nextá	: unit -> string
};
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{PRETTY CHARACTERS}

The system supports pretty characters in the source documents and on
the printed output.  There are more characters available for output
than can be contained in the eight bit character set that is
available.  The additional pretty characters may be input by using a
keyword approach where the keywords are enclosed by percent
`{\tt\%}' characters.  Details of all of the keywords and the actual
pretty characters are included in a structure for use by other parts of
the reader writer.

To allow for the inclusion of other languages the structure is
extensible.  It is initialised with the characters and keywords to
support Standard~ML extended to allow pretty characters in identifiers
and strings.

=SML
structure âPrettyNamesá = struct
=TEX

%********************************************************************

\subsection{Data Held for Pretty Characters}
\label{DataHeldForPrettyCharacters}

The class of each symbol is recorded.  Type $Simple$ is for those that
may be part of identifiers.  Type $Invalid$ are those that are always
invalid when found by the reader, these include the symbols understood
by the document processing programs\footnote{Provide a reference.} for
surrounding formal text which does not require processing by this
reader writer.  Type $Ignore$ is for symbols which are to be completely
ignored.

More complex types are needed for embedding other languages.  Symbols of
type $Starting$ and $Ending$ are used (as their name suggests) to start
and complete sections of embedded text, the strings are included as the
first and last characters in the generated text.  Type $Middle$ is used within
a section of embedded text.  Type $Starting$ gives the reader function
for the embedded language, it will perform a recursive decent analysis
(as described in section~\ref{ReaderWriter}) of the
next characters input.

\label{DeclareNameClass}

=SML
datatype âNAME_CLASSá
	=	âSimpleá
	|	âIgnoreá
	|	âInvalidá
	|	âStartingá	of (READER_ENV -> (string * bool) -> string -> bool ->
					string list -> string list) * string
	|	âMiddleá	of string
	|	âEndingá	of string
	;
=TEX

For each distinct symbol a tuple is held.  It contains: a list of the
alternative names for the symbol, with the preferred name at head; the
pretty character, if any; and, the class of the name i.e., where and
how it is used.

=SML
type âPRETTY_NAMEá = ( string list * string OPT * NAME_CLASS );
=TEX

%********************************************************************

\subsection{Pretty Character Dictionary}
\label{PrettyCharacterDictionary}

The purpose of this data structure is to capture all of the names of
the symbols together with their pretty characters and attributes.  The
intention is that this table is fairly easy to understand and modify,
that the information about each symbol is given only once --- although
the generated data structure may replicate information.

A simple linear search through the table would be slow so the names and
characters are configured as an efficient dictionaries, their contents
are provided later.

The dictionaries themselves are accessed only via insertion and
inspection functions.

=SML
local (* for add_new_symbols, find_name and find_char *)

open EfficientDictionary;

val âname_dictá	: PRETTY_NAME E_DICT ref = ref initial_e_dict;
val âchar_dictá		: PRETTY_NAME E_DICT ref = ref initial_e_dict;
=TEX

To insert values into these dictionaries the following routines are
provided.

Some of the entries for pretty characters are temporary, we do
not yet have the proper set of pretty characters.  To direct attention
to the characters which are not correctly handled details will be
obtained by examining the above list whilst the list produced remains
non-empty some characters need attention.

=SML
in (* local for add_new_symbols, find_name and find_char *)

fun âadd_new_symbolsá (pnl:PRETTY_NAME list) : unit = (
let
	fun add_name(pcd as (names, _, _) : PRETTY_NAME, dict : PRETTY_NAME E_DICT
			) : PRETTY_NAME E_DICT = (
	let
		fun moan_kw name = local_warn "add_new_symbols" 5100 [fn () => name];

		fun ok_kw("Q"::"Q"::_) = false
		| ok_kw(_::t) = ok_kw t
		| ok_kw nil = true;

		fun aux("Q", dict) = (moan_kw "Q"; dict)
		| aux(name, dict) = (
			if ok_kw(explode name)
			then	e_enter name pcd dict
			else	(moan_kw name; dict)
		)
	in
		case names
		of nil => (local_warn "add_new_symbols" 5101 nil; dict)
		| _ => fold aux names dict
	end);

	fun add_char((_, Nil, _) : PRETTY_NAME, dict : PRETTY_NAME E_DICT
			) : PRETTY_NAME E_DICT = dict
	|   add_char(pcd as (names, Value ch, _), dict) = (
		if size ch = 1 andalso ord ch >= 128
		then	e_enter ch pcd dict
		else (	local_warn "add_new_symbols" 5102  [fn () => PolyML.makestring names];
			dict)
	)
in
	output(std_out, "Adding " ^ (PolyML.makestring(length pnl)) ^ " new symbols\n");
	name_dict := fold add_name pnl (!name_dict);
	char_dict := fold add_char pnl (!char_dict)
end);
=TEX

=SML
fun âfind_nameá (name:string) : PRETTY_NAME OPT = (
	e_lookup name (!name_dict)
);

fun âfind_chará (char:string) : PRETTY_NAME OPT = (
	e_lookup char (!char_dict)
)

end  (*  of local for add_new_symbols, find_name and find_char *);
=TEX

%********************************************************************

\subsection{Initial Set of Symbols}

The basic set of symbols are those available for all languages,
including Standard~ML, they are the Greek letters, the mathematical
symbols, and a few specials used in forming identifiers.

=SML
local (* for raw_symbol_names *)

val âraw_symbol_namesá : PRETTY_NAME list = [
=TEX

=IGN
(* Some symbols to test add_new_symbols and provoke some error messages *)
	([	"abcQQdef"],	Nil,				Simple),
	([	"QQdef"],	Nil,				Simple),
	([	"abcQQ"],	Nil,				Simple),
	([	"QQ"],		Nil,				Simple),
	([	"Q"],		Nil,				Simple),
	([	],		Nil,				Simple),
=TEX

The first group of symbols are for the Greek letters.  Note, there are
problems\footnote{To be resolved  --- they stem from the different
purposes that the characters are used for, and the different sorts of
processing that is done.  Ideally the $string\;OPT$ column should
contain something that prints like the graphics screen image of the
character and which has the correct single character in the Standard~ML
that is produced.  Correct ML has been achieved by careful use of the
{\tt screenfile} and its associated programs.  The changes needed to
those programs to make the characters print properly here are
non-trivial --- the problem characters are those that are converted, by
the program {\tt doc2tex,} into complex commands, what is required here
is the conversion into something that prints like the graphics screen
image of the character.} displaying some of the pretty characters
here.


{\ftlinepenalty=9999
=SMLLITERAL
	([	"Delta"],	Value "ñ",			Simple),
	([	"Gamma"],	Nil,				Simple),
	([	"Lambda"],	Nil,				Simple),
	([	"Omega"],	Nil,				Simple),
	([	"Phi"],		Nil,				Simple),
	([	"Pi"],		Nil,				Simple),
	([	"Psi"],		Nil,				Simple),
	([	"Sigma"],	Nil,				Simple),
	([	"Theta"],	Nil,				Simple),
	([	"Upsilon"],	Nil,				Simple),
	([	"Xi"],		Value "ò",			Simple),
	([	"alpha"],	Nil,				Simple),
	([	"beta"],	Nil,				Simple),
	([	"chi"],		Nil,				Simple),
	([	"delta"],	Nil,				Simple),
	([	"epsilon"],	Nil,				Simple),
	([	"eta"],		Nil,				Simple),
	([	"gamma"],	Nil,				Simple),
	([	"iota"],		Nil,				Simple),
	([	"kappa"],	Nil,				Simple),
	([	"fn",
		"lambda"],	Value "",			Simple),
	([	"mu"],		Value "",			Simple),
	([	"nu"],		Nil,				Simple),
	([	"omega"],	Nil,				Simple),
	([	"phi"],		Nil,				Simple),
	([	"pi"],		Nil,				Simple),
	([	"psi"],		Nil,				Simple),
	([	"rho"],		Nil,				Simple),
	([	"sigma"],	Nil,				Simple),
	([	"tau"],		Nil,				Simple),
	([	"theta"],	Value "­",			Simple),
	([	"upsilon"],	Nil,				Simple),
	([	"xi"],		Nil,				Simple),
	([	"zeta"],	Nil,				Simple),
=TEX
}

Calligraphic alphabet.

{\ftlinepenalty=9999
=SMLLITERAL
	([	"calA"],	Nil,				Simple),
	([	"calB"],	Nil,				Simple),
	([	"calC"],	Nil,				Simple),
	([	"calD"],	Nil,				Simple),
	([	"calE"],	Nil,				Simple),
	([	"calF"],	Nil,				Simple),
	([	"calG"],	Nil,				Simple),
	([	"calH"],	Nil,				Simple),
	([	"calI"],		Nil,				Simple),
	([	"calJ"],	Nil,				Simple),
	([	"calK"],	Nil,				Simple),
	([	"calL"],	Nil,				Simple),
	([	"calM"],	Nil,				Simple),
	([	"calN"],	Nil,				Simple),
	([	"calO"],	Nil,				Simple),
	([	"calP"],	Nil,				Simple),
	([	"calQ"],	Nil,				Simple),
	([	"calR"],	Nil,				Simple),
	([	"calS"],	Nil,				Simple),
	([	"calT"],	Nil,				Simple),
	([	"calU"],	Nil,				Simple),
	([	"calV"],	Nil,				Simple),
	([	"calW"],	Nil,				Simple),
	([	"calX"],	Nil,				Simple),
	([	"calY"],	Nil,				Simple),
	([	"calZ"],	Nil,				Simple),
=TEX
}

Maths symbols.

{\ftlinepenalty=9999
=SMLLITERAL
	([	"spot",
		"=>"],		Value "",			Simple),
	([	"and"],		Value "",			Simple),
	([	"bagunion"],	Value "Þ",			Simple),
	([	"bigcolon"],	Value "º",			Simple),
	([	"bij"],		Value "ì",			Simple),
	([	"bottom"],	Value "´",			Simple),
	([	"cat"],		Value "µ",			Simple),
	([	"dcat"],	Value "Ã",			Simple),
	([	"def"],		Value "",			Simple),
	([	"dintersect"],	Value "¢",			Simple),
	([	"dres"],	Value "",			Simple),
	([	"dsub"],	Value "",			Simple),
	([	"dunion"],	Value "£",			Simple),
	([	"emptyset"],	Value "¤",			Simple),
	([	"equiv"],	Value "",			Simple),
	([	"exists"],	Value "",			Simple),
	([	"fcompose"],	Value "¯",			Simple),
	([	"ffun"],	Value "",			Simple),
	([	"filter"],	Value "Á",			Simple),
	([	"finj"],		Value "ð",			Simple),
	([	"forall"],	Value "",			Simple),
	([	"fset"],		Value "",			Simple),
	([	"fun"],		Value "",			Simple),
	([	"geq"],		Value "",			Simple),
	([	"implies"],	Value "",			Simple),
	([	"inj"],		Value "",			Simple),
	([	"int"],		Value "í",			Simple),
	([	"intersect"],	Value " ",			Simple),
	([	"lbag"],		Value "[[",			Simple),
	([	"leq"],		Value "",			Simple),
	([	"lfree"],	Value "¾¾",		Simple),
	([	"lrelimg"],	Value "Ñ",			Simple),
	([	"lseq"],		Value "¾",			Simple),
	([	"map"],	Value "",			Simple),
	([	"mem"],	Value "",			Simple),
	([	"nat"],		Value "",			Simple),
	([	"neq"],		Value "",			Simple),
	([	"not"],		Value "",			Simple),
	([	"notmem"],	Value "",			Simple),
	([	"or"],		Value "",			Simple),
	([	"overwrite"],	Value "",			Simple),
	([	"pfun"],	Value "",			Simple),
	([	"pinj"],	Value "«",			Simple),
	([	"pset"],	Value "",			Simple),
	([	"psubset"],	Value "¦",			Simple),
	([	"psurj"],	Value "Î",			Simple),
	([	"rbag"],	Value "]]",			Simple),
	([	"rel"],		Value "",			Simple),
	([	"rfree"],	Value "¿¿",		Simple),
	([	"rrelimg"],	Value "Ò",			Simple),
	([	"rres"],		Value "",			Simple),
	([	"rseq"],	Value "¿",			Simple),
	([	"rsub"],	Value "",			Simple),
	([	"select"],	Value "\\varepsilon",		Simple),
	([	"subset"],	Value "¥",			Simple),
	([	"subtract"],	Value "Ä",			Simple),
	([	"surj"],	Value "Ú",			Simple),
	([	"thm"],		Value "",			Simple),
	([	"union"],	Value "¡",			Simple),
	([	"x"],		Value "",			Simple),
=TEX
}
Several symbols are provided for use with identifiers.

Four new characters are created which have significant processing with
respect to the way identifiers are formed.  Temporarily they will be
used as follows.

\begin{center}
\begin{tabular}[t]{|l|l|l|l|}
\hline
Purpose&Graphics&Printed&Keyword\\
&screen&form&\\
&image&&\\\hline\hline
Superscripts&$\sp+$&Â&{\tt\%up}\\
Subscripts&$\sb 0$&ã&{\tt\%down}\\
\LaTeX\ inclusion&$\sb c$&¸&{\tt\%latex}\\
Negation&${\rlap{$\times$}\hbox{$\,\times$}}$&ª&{\tt\%negate}\\
\hline
\end{tabular}
\end{center}

=SMLLITERAL
	([	"latex"],	Value "¸",			Simple),
	([	"negate"],	Value "ª",			Simple),
	([	"down"],	Value "ã",			Simple),
	([	"up"],		Value "Â",			Simple),

	([	"cal"],		Nil,				Simple),
	([	"SX"],		Value "â",			Ignore),
	([	"EX"],		Value "á",			Ignore),
=TEX

Several symbols are reserved, some for the use of the Z notation.  These are
included here for completeness, they will eventually be transferred to a
section of this or another document where Z is properly treated.

=SMLLITERAL
	([	"SFT"],	Value "ó",			Invalid),
	([	"SML"],	Value "å",			Invalid),
	([	"SR1"],	Value "\\StartRuleOne",	Invalid),
	([	"SR2"],	Value "\\StartRuleTwo",	Invalid),
	([	"SZ"],		Value "è",			Invalid),
	([	"SZA"],	Value "ê",			Invalid),
	([	"SZC"],	Value "ë",			Invalid),
	([	"SZS"],	Value "é",			Invalid),
	([	"EML",
		"EFT",
		"EZ"],		Value "æ",			Invalid),
	([	"ER"],		Value "\\EndRule",		Invalid)
]
=TEX

Add the symbols into the dictionary.

=SML
in (* local for raw_symbol_names *)

val _ = add_new_symbols raw_symbol_names;

end (* of local for raw_symbol_names *);
end (* of structure PrettyNames *);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{READER WRITER}
\label{ReaderWriter}

The task of the reader and writer is to read text presented to the
system, determining which parts are Standard~ML and which are in
an embedded language such as HOL.
Both may include pretty characters and keywords denoting pretty
characters or other symbols.  The Standard~ML text is modified
according to the nature of the pretty characters.

The basis of the reader writer is a recursive decent parser that
understands part of the structure of Standard~ML, similarly the readers for
embedded languages need to understand part of the structure of their language.
At first sight this seems overkill, but it is required so that (for
example) string literals and comments can be properly
delimited.  Both Standard~ML and HOL may include any character within
string literals and comments, thus the reader must recognise the
context of use of all characters, it must therefore understand a
considerable part of both languages.

The rules for the code of the recursive decent parser are as follows.
The main recursive function take as an argument the characters parsed
and processed already, i.e., the characters to the left of the item to
be matched by the called routine, this is called the ``left hand
context''.  The most recently read character is
the first character of the item handled by the called routine.  This
character is passed as an argument to some routines.  A routine is only
called when it is appropriate.  When called the routine must read all
the characters that are part of the input item it handles.  If the
parse is successful it returns with the new left hand
context.  If unsuccessful it calls $fail$ to report the
error.  On both types of exit the first unread character is the
character that does not belong to the text already parsed.

For efficiency reasons the characters parsed and processed already are
held as a list of strings with the most recently parsed item at the
head of the list.  (A first attempt at the type of this argument might
be a single string with text added to the right, however, string
concatenation is thought to be inefficient.)  To create the string
passed to the \Compiler{} the function ``$fn\;A=> implode(rev\;A)$''
is applied to the list.

%********************************************************************

\subsection{Recursive Descent Parser}

%--------------------------------------------------------------------

\subsubsection{Reader Environment}
\label{ReaderEnvironment}

Routines are required for reading characters, for giving a one
character lookahead, and for ``unreading'' characters (i.e., returning
characters to the input stream so they will be read again).  These
routines are considered to be the ``readers environment''.

At all stages during parsing the work can be seen as follows.  Of the
input text there is the ``portion already read'', the ``current
character'' and the ``unread portion''.  The ``portion already read''
will have been recorded (after some modifications) in $prev$, the
left hand context, which is
one of the arguments of many of the parsing routines.  The
``current-character'' will be under processing by one of the recursive
descent functions.  The first character of the ``unread-portion'' is
called the next character.  At may stages there will be no current
character, it will have been fully processed and added into the
left hand context.

Function $advance$ is used when the caller has properly dealt with the
current character, it reads a character and returns its value.
Function $look_at_next$ does a one character lookahead and returns the
value of that next character.  Function $skip_and_look_at_next$
combines the above, it reads one character and discards its value, it
then does a one character lookahead and returns the value of that next
character.

After end of file all the reading routines return the character control-D, decimal
code~4, whenever called.  For resilience of the code during testing the
routines signal a fault if they return an excessive number of control-D
characters, this is shown in section~\ref{ExcessiveControlDs}.

Function $push_back$ adds its argument to the ``unread portion'' of the
input text.

The routines are placed in a record which is passed through the various
routines of the lexical analyser.  The record, with the Standard~ML
type name $READER_ENV$, is declared in section~\ref{DeclareReaderEnv}.

Associated with the reader functions is the exception $EndOfInput$
which is raised when the parser has read the end of the file and
has passed the end of file character at least once to the \Compiler.
Raising this exception signifies that nothing more can usefully be
done with the current input stream.

=SML
exception âEndOfInputá;
=TEX

%--------------------------------------------------------------------

\subsubsection{Comments}

Comments are skipped over.  Comments are sequences of characters within
which the comment braces `{\tt (*}' and `{\tt *)}' are properly
balanced.  This routine is entered when the opening round bracket of
the comment has been read, the opening asterisk is the first unread
character.
The entire comment is skipped leaving the first character after the
comment as the first unread character.

Standard~ML comments separate items, see~\cite[section~2.5]{Milner90},
thus the caller of $skip_comment$ must arrange to replace the comment
with an suitable separation.

=SML
fun âskip_commentá (R:READER_ENV) : unit = (
let
	fun aux (skip:bool) (depth:int) : unit = (
		if skip then (#advance R (); ()) else ();
		case #look_at_next R ()
		of "(" =>	if #skip_and_look_at_next R () = "*"
				then	aux true (depth+1)
				else	aux false depth
		|  "*" =>	if #skip_and_look_at_next R () = ")"
				then
					(#advance R ();
					if depth = 1
					then	()
					else	aux false (depth-1))
				else	aux false depth
		|  "\^D" =>	fail "skip_comment" 5001 nil
		|  _   =>	aux true depth
	)
in
	aux true 1
end);
=TEX

%--------------------------------------------------------------------

\subsubsection{Percent Keywords}

Gather the characters of a percent keyword.  On entry the opening
`{\tt\%}' is the next character.  The returned tuple contains the
following values.

\begin{itemize}

\item The characters of the keyword, without the enclosing percents.

\item The additional information found from looking up the keyword, or
	$Nil$ for an unknown or empty keyword.

\item A flag set true for a keyword with a closing percent sign, which
	will have been read.

\end{itemize}

Note that for an input of two adjacent percent signs this routine
returns the value ``$("", false, true)$''.

This routine is a little different to the others in that it needs to do
a multi-character look-ahead to gather the whole name to know how to
treat the name and the enclosing `{\tt\%}' characters, whereas the rest
of the system only needs one-character look-ahead.

=SML
fun âget_percent_nameá (R:READER_ENV)
		: (string * PrettyNames.PRETTY_NAME OPT * bool) = (
	let
		fun is_alphanumeric ch = (
				(ch >= "a" andalso ch <= "z")
			orelse	(ch >= "A" andalso ch <= "Z")
			orelse	(ch >= "0" andalso ch <= "9")
		);

		fun collect_alphanumeric next = (
			if is_alphanumeric next
			then	next ^ (collect_alphanumeric(#skip_and_look_at_next R ()))
			else	""
		);

		fun is_special ch = (
			contains ["!", "&", "$", "#", "+", "-", "/", ":", "<", "=", ">",
				"?", "@", "\\", "~", "'", "^", "|", "*"] ch
		);

		fun collect_specials next = (
			if is_special next
			then	next ^ (collect_specials(#skip_and_look_at_next R ()))
			else	""
		);

		val next = #skip_and_look_at_next R ();

		val name =
			case collect_alphanumeric next
			of ""	=> collect_specials next
			| n	=> n;

		val is_closed =
			if #look_at_next R () = "%"
			then	(#advance R (); true)
			else	false
	in
		(name, PrettyNames.find_name name, is_closed)
	end
);
=TEX

%--------------------------------------------------------------------

\subsubsection{Reading Logical Characters}

In some parts of the reader writer we are interested in reading the
next ``logical'' character rather than the next real character of the
input.  By ``logical'' we mean that percent keywords have been read and
their status found, similarly the status of extended characters is
found.  Function $read_symbol$ achieves this task.  It returns a value
of type $SYMBOL$.

Note that function $read_symbol$ actually reads the symbol, it is thus
not appropriate for those cases where lookahead is needed --- although
a combination of $read_symbol$ and $push_back$ (see
section~\ref{DeclareReaderEnv}) may be used.  For example, function
$get_ML_any$ uses closing brackets to indicate the completion of the
text it should gather, it leaves the closing bracket unread so that its
caller may read the bracket.

=SML
datatype âSYMBOLá
	=	âSymCharacterá	of	string
	|	âSymWhiteá		of	string
	|	âSymKnowná		of	string
						* bool (* true => keyword *)
						* PrettyNames.PRETTY_NAME
	|	âSymUnknownKwá	of	string
						* bool (* true => has closing percent *)
	|	âSymUnknownChará	of	string
	|	âSymDoublePercentá
	;
=TEX

The meanings of the constructors of this type are as follows.

\begin{description}
\def\ITEM#1{\item[$#1$ ]}

\ITEM{SymWhite} One or more formatting characters.

\ITEM{SymKnown} An extended character or a keyword has been recognised
	in the pretty character tables.  The string holds the character
	or the keyword without its enclosing percent signs.  The bool
	is true for a keyword, false for an extended character.  The
	final value is the entry in the pretty character tables.

\ITEM{SymUnknownKw} A keyword that is not known, or has no closing
	percent sign, has been read.  The bool is true if a closing
	percent sign was found.

\ITEM{SymUnknownChar} An extended character that is not known in the
	pretty character tables was found.

\ITEM{SymDoublePercent} Two adjacent percent signs were found.

\ITEM{SymCharacter} A single character that is not covered by the above
	was found.  The character value is less than decimal~128.

\end{description}

=SML
fun âread_symbolá (R:READER_ENV) : SYMBOL = (
let
	fun formatters next =
	let
		fun aux prev next =
			if		next = " "
				orelse	next = "\n"
				orelse	next = "\t"
				orelse	next = "\^L"
			then	aux (next::prev) (#skip_and_look_at_next R ())
			else	prev;
	in
		SymWhite(implode(rev(aux nil next)))
	end;

	val next = #look_at_next R ()
in
	case next
	of "\t"	=>	formatters next
	|  "\n"	=>	formatters next
	|  " "	=>	formatters next
	|  "\^L" =>	formatters next
	|  "%"	=>	(	case get_percent_name R
				of (kw, Value info, true) => SymKnown(kw, true, info)
				| (kw, Value info, false) => SymUnknownKw(kw, false)
				| ("", Nil, true) => SymDoublePercent
				| (kw, Nil, is_closed) => SymUnknownKw(kw, is_closed)
			)
	|  _	=>	let
				val ch = #advance R ();
				val ord_ch = ord ch
			in
				if ord_ch > 127
				then	case PrettyNames.find_char ch
					of Value info => SymKnown(ch, false, info)
					|  Nil	=> SymUnknownChar ch
				else
					SymCharacter ch
			end
end);
=TEX

The textual form of a symbol is wanted for some purposes.

=SML
fun	âexpand_symbolá((SymCharacter ch):SYMBOL) : string	= ch
|	expand_symbol(SymWhite wh)				= wh
|	expand_symbol(SymKnown(sym, true, info))			= "%" ^ sym ^ "%"
|	expand_symbol(SymKnown(sym, false, info))			= sym
|	expand_symbol(SymUnknownKw(sym, true))			= "%" ^ sym ^ "%"
|	expand_symbol(SymUnknownKw(sym, false))		= "%" ^ sym
|	expand_symbol(SymUnknownChar ch)			= ch
|	expand_symbol(SymDoublePercent)				= "%%"
;
=TEX

%--------------------------------------------------------------------

\subsubsection{Strings}

Strings start and finish with a `~{\tt"}~' and contain a
mixture of characters and escape sequences.  Some escape sequences are
used in formatting the source text, others denote particular
characters.  Most of the understanding and validating of strings, and
in particular the escape sequences, can be left to the \Compiler, here
the concern is finding the end of the string, and converting pretty
characters into a form acceptable to the \Compiler.  In finding the end
of the string the escape sequence that allows strings to be laid out
neatly must be recognised.  The strings \verb*|"ab\"c\   \de\\f"| and
\verb*|"ab\"cde\\f"| are the same, as are the strings \verb*|"ab\  \"|
and \verb*|"ab"|, they only differ by the use of the formatting
characters.  Note the \verb*|\"| in the second example which must not
be interpreted as an escaped double quote.

Within a string an escape followed by one of more formatting characters
and another escape may be ignored.  Non formatting characters are not
allowed.  The full set of allowed characters is implementation
dependent, but includes, quoting from~\cite[section~2.1]{Milner90},
``$\ldots$ at least space, tab, newline and formfeed.''  These four
characters will be skipped by the lexical analyser here, any other
characters will be passed on to the \Compiler, as if they were escaped
formatting characters.

Local function $skip_format_chars$ is first entered with a formatting
character as the first unread character, it reads characters until a
closing escape character which it reads leaving the next character as
the first character after the whole escape sequence.  Any other
characters found between the escape characters are retained for
processing by the \Compiler which may consider some characters above the
minimum set of four as formatting characters.

On entry to $handle_escape$ the opening escape character has been read,
but not the character being escaped.

A variation on strings allows single left-hand primes~(~{\tt`}~) to
enclose the body of the string.  The escape conventions are altered,
swapping the interpretations of the single~(~{\tt`}~) and
double~(~{\tt"}~) prime characters.  Function $get_primed_string$ deals
with these strings.

=SML
local (* for get_ML_string and get_primed_string *)

fun âhandle_escapeá (ML_string:bool) (R:READER_ENV) : string = (
let
	fun skip_format_chars (prev:string) : string = (
		case #skip_and_look_at_next R ()
		of " "		=> skip_format_chars prev
		|  "\t"		=> skip_format_chars prev
		|  "\n"		=> skip_format_chars prev
		|  "\^L"		=> skip_format_chars prev
		|  "\\"		=> (#advance R (); prev)
		|  "\^D"	=> prev
		|  s		=> skip_format_chars (prev ^ s)
	);

	val next = #look_at_next R ()
in
	if next = " " orelse next = "\t" orelse next = "\n" orelse next = "\^L"
	then
		case skip_format_chars ""
		of	""	=> ""
		|	x	=> ("\\ " ^ x ^ " \\")
	else if next = "`"  andalso not ML_string
	then
		#advance R ()
	else
		("\\" ^ (#advance R ()))
end);
=TEX

Most of the work of gathering strings is just reading and concatenating
the characters, they are of five classes: end of string, end of file,
pretty, escaped
and others.  Function $string_body$ is first called with
the first character of the string being the first unread character.

There are several places in the Standard~ML code where double quotes or
brackets are used within strings, in some of them the quotes or
brackets do not balance.  Whilst this is the intended Standard~ML code
it confuses some other processes, particularly the quote and bracket
matching code in editors, and the mechanisms used to display double
quotes on paper.  To avoid these problems Standard~ML comments
containing the `missing' characters are added, these comments are in a
standard form, ``{\tt(*=}x{\tt=*)}'' where ``x'' is the missing
characters.  The first example of one of these comments is a
missing double quote in function $string_body$.

An end of file found in the string indicates that there is no more
input available, and so an immediate exit (via function $fail$) is
taken.  All other errors detected in strings are reported as found (via
function $local_error$) and have their numbers passed back to the
caller.

=SML
fun âstring_bodyá (ML_string:bool) (R:READER_ENV) (prev:string list, preverrs:int list)
			: (string list * int list) = (
	case read_symbol R
	of SymCharacter ch => (
		case ch
		of "\"" =>	(*="=*)
				if ML_string
				then	("\"" (*="=*) :: prev, preverrs)
				else	string_body ML_string R ("\\\"" (*="=*) :: prev, preverrs)
		| "`" =>	if ML_string
				then	string_body ML_string R ("`"::prev, preverrs)
				else	("\"" (*="=*) :: prev, preverrs)
		|  "\^D" =>	fail "string_body" 5002 nil
		|  "\\"	=>	string_body ML_string R
					((handle_escape ML_string R) :: prev, preverrs)
		|  _ =>		string_body ML_string R (ch::prev, preverrs)
		)
	| SymDoublePercent => string_body ML_string R ("%" :: prev, preverrs)
	| SymWhite wh => string_body ML_string R (wh::prev, preverrs)
	| SymKnown(_, _, info) =>
				string_body ML_string R ((
					case info
					of (_, Value ch, _) => "\\" ^ string_of_int3(ord ch)
					| (names,_,Simple) => hd names
				) :: prev, preverrs)
	| SymUnknownKw(sym, _) => (
				local_error "string_body" 5003 [fn () => sym, fn () =>
					implode(rev(" ... " :: (prev to 10)))];
				string_body ML_string R  (" 5003 " :: prev, 5003 :: preverrs))
	| SymUnknownChar ch =>
				string_body ML_string R
					(("\\" ^ string_of_int3(ord ch))::prev, preverrs)
);
=TEX

The result from $string_body$ is a sequence of mainly one-character
strings, it seems appropriate to convert it to one long string at this
stage rather than retaining the space overhead until the whole input
text is formed.  Functions $get_\ldots_string$ are called with the opening
string quote having been read.

=SML
fun âget_any_stringá (ML_string:bool) (R:READER_ENV) prev = (
let
	val (str, errs) = string_body ML_string R (["\"" (*="=*)], nil)
in
	([implode(rev str)] @ prev, errs)
end);

in (* local for get_ML_string and get_primed_string *)

fun âget_ML_stringá (R:READER_ENV) prev = get_any_string true R prev;

fun âget_primed_stringá (R:READER_ENV) prev = get_any_string false R prev;

end (* of local for get_ML_string and get_primed_string *);
=TEX

%--------------------------------------------------------------------

\subsubsection{Bracketed Text}

Gathering bracketed text is required in many languages.  The basic idea
of these routines is to gather some bracketed text.  The value returned
comprises both brackets plus all the text they enclose, or if the
opening bracket was a start-of-comment then return nothing (i.e., an
empty list).

Text enclosed by round brackets may be comment or nested Standard~ML text.
The opening round bracket has been read, so the next character indicates
how to process the bracket.

Gathering nested text enclosed by braces (i.e., by the characters
`\verb|( ) { } [ ]|') uses a general routine for bracketed text.

=SML
fun âget_round_bracesá (get : READER_ENV -> string list -> string list)
		(R:READER_ENV) (prev:string list) : string list = (
	if #look_at_next R () = "*"
	then
		(skip_comment R; " " :: prev)
	else
		get_braces get R prev "(" ")"
)

and âget_box_bracesá (get : READER_ENV -> string list -> string list)
		(R:READER_ENV) (prev:string list) : string list = (
	get_braces get R prev "[" "]"
)

and âget_curly_bracesá (get : READER_ENV -> string list -> string list)
		(R:READER_ENV) (prev:string list) : string list = (
	get_braces get R prev "{" "}"
)
=TEX

In the general routine for gathering bracketed text the next character
is the first character within the bracketed expression.  The opening
bracket for the expression is $first$, the closing bracket should be
$term$.  This routine differs from the general rules for the recursive
decent in that it does not pass $prev$ to the routines it calls, this
is needed to allow the detection of terminating braces, when the call
of $get$ will return an empty list.

An unexpected type of closing brace is reported\footnote{The error
message might be deleted in the future.} with a error message, and
then added to the returned string, leaving the real error reporting to
the \Compiler.

=SML
and âget_bracesá (get : READER_ENV -> string list -> string list)
		(R:READER_ENV) (prev1:string list) (first:string) (term:string) : string list = (
let
	fun more prev2 = (
		case get R nil
		of nil =>	let
					val next = #look_at_next R ()
				in
					if next = term
					then	(#advance R ()) :: prev2
					else if next = "\^D"
					then	"\^D" :: prev2
					else (	local_error "get_braces" 5008 [
							fn () => next, fn () => first];
						(if contains ["]", "}", ")"] next
						then [#advance R ()]
						else nil) @ (add_error_code(5008, prev2)))
				end
		| ["\^D"] =>	(#advance R ()) :: prev2
		| new =>	more(new @ prev2)
	)
in
	(more [first]) @ prev1
end);
=TEX

%--------------------------------------------------------------------

\subsubsection{Main Parser Function}

Function $get_ML_any$ is the main parser function.  It reads upto the
first semi colon `{\tt;}', closing bracket or ending keyword and then
returns the text read.  A semi colon will be read and added to the
returned text, a closing bracket or ending keyword is left unread for
the calling routine.  The syntax
error where too many closing bracket are presented must be resolved by
the outermost routine that calls this function.  The
routines that handle text which may include semi colons, essentially
those dealing with brackets, should repeatedly call $get_ML_any$ until
the appropriate end of text is found.

Some characters are used to indicate that $get_ML_any$ should return to
its caller leaving that character unread, so that the caller may
examine it further.  Most characters are actually read by this routine,
or by those it calls.  This distinction leads to the nesting of the
case expressions below.

{\ftlinepenalty=9999
=SML
fun âget_ML_anyá (R:READER_ENV) (prev:string list) : string list= (
let
	open PrettyNames;

	fun	do_keyword _ (names,_,Simple) p = get_ML_any R ("QQ"^(hd names)^"QQ"::p)
	|	do_keyword k (_,_,(Starting(proc, str))) p = proc R k str true p
	|	do_keyword _ (_,_,Middle str) p = get_ML_any R (str :: p)
	|	do_keyword (k, is_keyword) (_,_,Ending _) p =
			(#push_back R (if is_keyword then "%" ^ k ^ "%" else k); p)
	|	do_keyword _ (_,_,Ignore) p = get_ML_any R p
	|	do_keyword (k, is_keyword) (names,_,Invalid) p = (
			local_error "get_ML_any" 5007
				[fn () => if is_keyword then "%" ^ k ^ "%" else k];
			get_ML_any R (add_error_code(5007, p)));

	val next = #look_at_next R ()
in
	case next
	of (*=(=*)	")"	=>	prev
	|  (*=[=*)	"]"	=>	prev
	|  (*={=*)	"}"	=>	prev
	|  		"\^D"	=>	prev
	| 		_ => (
		case read_symbol R
		of	SymCharacter ch => (
				case ch
				of "("	=>	(*=)=*) get_ML_any R
						(get_round_braces get_ML_any R prev)
				|  "["	=>	(*=]=*) get_ML_any R
						(get_box_braces get_ML_any R prev)
				|  "{"	=>	(*=}=*) get_ML_any R
						(get_curly_braces get_ML_any R prev)
				|  ";"	=>	ch :: prev
				|  "\""	=>	let (*="=*)
							val (prevB, errnos) = get_ML_string R prev;
							val prevC = add_error_codes(errnos, prevB)
						in
							get_ML_any R prevC
						end
				|  "Q"	=>	get_ML_any R ("QQQQ" :: prev)
				| _ =>		get_ML_any R (ch :: prev)
			)
		|	SymWhite _ => get_ML_any R (" " :: prev)
		|	SymDoublePercent => get_ML_any R ("%%" :: prev)
		|	SymKnown(sym, is_keyword, info) =>
				do_keyword (sym, is_keyword) info prev
		|	SymUnknownKw(sym, _) => (
				local_error "get_ML_any" 5003 [fn () => sym, fn () =>
					implode(rev(" ... " :: (prev to 10)))];
				get_ML_any R (add_error_code(5003, prev))
			)
		|	SymUnknownChar ch => (
				local_error "get_ML_any" 5005 [fn () => next,
					fn () => string_of_int(ord ch),
					fn () => implode(rev(" ... " :: (prev to 10)))];
				get_ML_any R (add_error_code(5005, prev))
			)
	)
end);
=TEX
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{LANGUAGE NESTING}

The reader writer is extensible in that support other languages may be
added, the first such extension being for the HOL language.  Other
languages are allowed by embedding them within Standard~ML text
surrounded by certain percent-keywords or extended characters.

A ``HOL quotation'' is a HOL term written in the language defined by
the ICL HOL grammar~\cite{DS/FMU/IED/DEF001} and which is enclosed in
the HOL term delimiting symbols (which are ``{\tt\%<\%}'' and
``{\tt\%<\%}'' or their extended character equivalents).  Similarly one
may have ``Z quotations'', ``Standard~ML quotations'' and so on.  (ML
quotations are known as ``anti quotations'' in HOL~88.)

The word ``language'' is used in a general sense in this document.
Each set of enclosing symbols is considered to surround a different
language although in practice the same language recogniser may be used
for several set of enclosing symbols.  For example, the language of HOL
terms may be used in term quotations and in three forms of HOL
definition, namely axiomatic, infix axiomatic and schema definitions.

Quotations may be included as parts of other quotations to any level of
nesting.  The syntax for nesting is common across all supported
languages, this syntax should be seen as a requirement upon any future
embedded languages.

All quotations yield values which are either HOL types or HOL terms,
any particular quotation yields one of them.  Thus they may be used
only in contexts where such values are allowed.  From the macro
processing model of how quotations are processed each quotation is
converted into a Standard~ML expression (of a Standard~ML-type that is
either a HOL-type or a HOL-term).  Nesting of quotations means,
therefore, nesting of Standard~ML expressions which will be processed
by a Standard~ML compiler.  Text of languages other than Standard~ML is
passed as string arguments to a recogniser for that language, it
returns a value which is a HOL-type or a HOL-term.  Some recognisers
are intended to be used at the Standard~ML top level (i.e., to be
called as a Standard~ML $topdec$), their task is achieved by side
effects, perhaps to declare a HOL constant.  These recognisers

%********************************************************************

\subsection{General Quotations}

In all languages the two keywords `{\tt\%<\%}' and `{\tt\%>\%}' (and
the corresponding extended characters) are used to denote embedding of
text from another language.  The BNF syntax,
see~\cite{ds/fmu/ied/pln009}, is as follows.

óBNF
quotation	=	'%<%', [ language_code ], quoted_text, '%>%';

language_code	=	'%down%', name, white_space
		|	':' ;
æ

Where:

\begin{description}

\item[$name$ ] is a identifier in the extended Standard~ML.

\item[$white_space$ ] is a space or a tab character.

\item[$quoted_text$ ] is text in the named language.

\end{description}

The $name$ identifies the quoted language.  The default quotation is of
a HOL term, which may also be indicated by a name of ``{\tt HOL}''.
The colon form is equivalent to using the name ``{\tt HOL:}''.

Convention.  Languages which yield HOL types should have a colon
as the last character of their name.

Note that including any space or tab characters before the
$language_code$ will cause the default interpretation, as a HOL term.

%********************************************************************

\subsection{Other Quotations}

Another form of quotation is used when the language text is enclosed by
single symbols.  For example a HOL axiomatic definition is enclosed by
the keywords ``{\tt\%SHA\%}'' and ``{\tt\%EHA\%}''.

%********************************************************************

\subsection{Supporting Other Languages}

A goal when producing reader writers for embedded languages (indeed, a
goal for the whole reader writer) is to make the reading as simple as
possible, deferring as much as possible to the lexical analyser and
parser for the particular language.  There are several simplifications
that can be made, and which are made in the HOL reader writer that
follows.

\begin{itemize}

\item Defer error detection and reporting as much as possible, leave it
	to the lexical analyser or parser for the embedded language.
	In this context there are many errors that the basic reader
	writer is in a position to detect, but it passes them through to
	the \Compiler{} knowing that the \Compiler{} will detect and
	report them.

\item Treat brackets in the same way as other symbols.  This means
	allowing badly balanced brackets in the embedded text since the
	parser will detect them.

\item Use the functions provided in the basic reader writer, for
	example to read and get information about percent keywords, and
	to discard comment text.

\item Treat character literals as strings, letting the lexical analyser
	or parser complain if they are not exactly one character long.

\end{itemize}

Extensions are added in several pieces.

\begin{enumerate}

\item \label{ExtParser} A recursive descent parser for the new language, which {\em
	must\/} conform to the conventions given in the preceding
	sections, and particularly section~\ref{ReaderWriter}.  This
	means it must also use the same reading functions which are
	given in sections~\ref{DeclareReaderEnv}
	and~\ref{ReaderEnvironment}.   It may use any of the existing
	parsing functions, for example those dealing with comments and
	strings.

\item Additions to the name and character dictionaries, $name_dict$
	and $char_dict$, to show how the languages special symbols are
	treated.  These extensions include the symbols that start and
	end sections of text of the new language.

\item Additions to the dictionaries relating language names or
	starting symbols to reading functions.

\item \label{RWRoutine} A routine, but not part of this document, that
	performs the proper lexical analysis, parsing and any other
	processing required for the new language.

\end{enumerate}

%********************************************************************

\subsection{Datatype for Parser Interface}
\label{DatatypeForParserInterface}

Considered as an imperative program, the output of the reader portion
of the reader writer is a string of characters that are presented to a
Standard~ML \Compiler.  In this context the text of any embedded
language must be converted into Standard~ML, a convenient form would be
a Standard~ML string preceded by a call of the routine produced for
item~\ref{RWRoutine} listed above.  To allow embedded text to contain
quotations the input to
the parsing routine is actually a list of values of the following
datatype.  Note that the actual declaration is made by the lexical
analyser~\cite{ds/fmu/ied/dtd015}.  This declaration might be viewed
as the task of the $ReaderWriterSupport$ structure.  It is not needed
by anything in the reader writer, but arguably it should be defined
here since it represents part of the general interface between the
reader writer and the lexical analysers.  However, the datatype cannot be
declared until the Standard~ML types $TYPE$ and $TERM$ are declared, these require
a large portion of the ICL HOL system to be available and they are not
declared until after the reader writer is declared.

The exact form and usage of this declaration is determined by three
parts of the ICL HOL system: the HOL lexical
analyser~\cite{ds/fmu/ied/dtd015}; the symbol definitions passed to
$add_new_symbols$ in section~\ref{PrettyCharactersForHOL} below; and,
the code in the functions that generate text containing uses of the
declaration.

óSML Example
structure âLexá = struct
	...
	datatype âINPUTá
		=	âTextá		of string
		|	âStringá		of string
		|	âChará		of string
		|	âTypeá		of TYPE
		|	âTermá		of TERM
		|	âErrorá		of int
			;
	...
end;
æ

%\newpage

The various constructors are used as follows.

{\def\ITEM#1{\item[$#1$ ] }
\begin{description}

\ITEM{Lex.Text} Text of the new language, text that needs to be
	lexically analysed, parsed, etc.  This text excludes strings
	and character literals.

\ITEM{Lex.String} Character strings of the embedded language,
	these are strings as defined in~\cite[section~2.1]{Milner90}.
	These need to be recognised
	by the reader writer to prevent the wrong interpretation of
	characters within them.  Since the reader writer has identified
	them it seems appropriate to reduce the work of later stages of
	the languages analysis by keeping them
	as distinguished parts of the input text.

\ITEM{Lex.Char} As $Lex.String$ but these strings are introduced by the
	single left-hand prime~(~{\tt`}~) characters.  The name
	`$Lex.Char$' derives from the HOL use of this, namely for
	character literals --- the HOL recogniser has the task of
	validating the number of characters passed.

\ITEM{Lex.Term} A Standard~ML expression that yields a HOL
	term.  This value is produced by a term anti quotation within
	HOL text.  Note that the value given here is any Standard~ML
	expression --- it must yield the correct Standard~ML type or an
	error will be reported by the \Compiler{} --- which may contain
	embedded text of another language which will be another list of
	this datatype, which may contain another anti quotation, and so
	on.

\ITEM{Lex.Type} As $Lex.Term$, but for HOL types.

\ITEM{Lex.Error} Used to indicate the approximate site of detection of
	an error (whose code is also passed) in the object language
	text.

\end{description}}

The reader writer assumes a simple balancing of the starting and ending
symbols (from the constructors $PrettyNames.Starting$ and
$PrettyNames.Ending$), it does not attempt to check that the correct
symbols are used to start and end an embedded text.  The routines for
the called language are expected to check for the correct matching.  To
assist with this check the interface to the embedded language is a
tuple comprising the actual opening symbol, the list described above
and the actual closing symbol; its Standard~ML type is:
`$(string\;*\;string\;*\;(Lex.INPUT\;list)\;*\;string)$' \ The
order of these elements of the tuple reflects the order they are
read and processed by the imperative aspects of the reader writer.

The parsing routines return strings containing these constructors as
follows.  Note that these rules are built into the code of the
basic reader writer.

\begin{itemize}

\item All routines assume that they are entered when the string
	``\verb|Lex.Text "|'' has recently been output, other
	characters may also have been output, but the closing double
	quote has not.

\item Any routine that wants a constructor other than
	``\verb|Lex.Text|'' must close the current string, produce
	its own value, and start a new ``\verb|Lex.Text|', together
	with the necessary list element separators.

\end{itemize}

%********************************************************************

\subsection{Generated Standard~ML}

A call from an ML context will yield the equivalent of

óSML fragment
( recogniser ( "starting symbol", "language name", quoted_text, "closing symbol" ))
æ

Where:

\begin{description}

\item[$recogniser$ ] is derived from the language name, it has a
	result type of either HOL-term or HOL-type.

\item[$start_symbol$ ] is the symbol that introduced the quoted text,
	a string.

\item[$quoted_text$ ] is derived from the quoted text, it is a list
	comprising strings and quotations.

\item[$closing_symbol$ ] is the symbol that completed the quoted text,
	a string.

\end{description}

A call from a non-ML context will have the above passed as an argument
to either $Lex.Type$ or $Lex.Term$ depending on the way the language
name was introduced to the reader writer.

A language name that is not recognised will be processed in the same
way, but the name used for $recogniser$ above will be that of a
function that reports an error.  The reason for processing the text is
to allow the whole of the erroneous input text to be skipped over, thus
providing some measure of error recovery.

%********************************************************************

\subsection{Readers For Particular Languages}

All readers that may be called by the basic reader writer have a type
given by $READER_FUNCTION$, their string list argument is the left hand
context of their call, this value must be returned.  Any new text
assembled by the reader is added to the head of this list so that when
it is reversed and then imploded (via the Standard~ML function ``$fn
A=> implode(rev A)$'') the result is in the correct order.  This
function is always called with a left hand context requiring a
Standard~ML value, in other word, the text that the reader function
produces should be an Standard~ML expression.  The type of that
expression is either a HOL type or a HOL term if the text may be
written as a quotation embedded in another language, this is the case
when the reader is installed by $add_general_reader$. {} For readers
installed by $add_specific_reader$ the expression may be of any type,
but is usually of type unit, as it will normally be used as a
Standard~ML topdec.

=SML
type âREADER_FUNCTIONá
	= READER_ENV
	-> (string * bool)		(* Starting symbol *)
	-> string		(* Language name *)
	-> string		(* Opening text *)
	-> string list		(* Left hand context *)
	-> string list;
=TEX

A simple reader function is required for skipping over text when an
unknown language has been requested.

=SML
fun âskipping_readerá (R:READER_ENV) (start:string, is_keyword:bool)
		(lang_name:string) (opening:string)
		(prevA:string list) : string list = (
let
	open PrettyNames;

	fun read (depth:int) (prev_errs:int list) : int list = (
		case read_symbol R
		of	SymCharacter ch => (
				case ch
				of "\^D" => fail "skipping_reader" 5030 []
				| ch => read depth prev_errs
			)
		|	SymWhite _ => read depth prev_errs
		|	SymKnown(_, _, (_, _, info)) => (
				case info
				of Starting _ => read (depth+1) prev_errs
				| Ending _ =>
					if depth = 1
					then prev_errs
					else read (depth-1) prev_errs
				| _ => read depth prev_errs
			)
		|	SymUnknownKw(sym, _) => (
				local_error "skipping_reader" 5004 [fn () => sym];
				read depth (5004::prev_errs))
		|	SymUnknownChar ch => (
				local_error "skipping_reader" 5006 [fn () => ch,
					fn () => string_of_int(ord ch)];
				read depth (5006::prev_errs))
		|	SymDoublePercent => read depth prev_errs
	);

	val errs = read 1 nil
in
	(local_error "skipping_reader" 5010
		[fn () => if is_keyword then "%" ^ start ^ "%" else start,
		fn () => lang_name];
	add_error_codes(5010::errs, prevA))
end
);
=TEX

%********************************************************************

\subsection{Reader Function Database}

Two sets of reader functions are held.  A general reader handles
embedded language text introduced by a ``{\tt\%<\%}'' or the
corresponding extended character, which may be followed by the name of
the particular language, it defaults to the HOL term language.  A
specific reader handles language text introduced by a single
keyword or extended character and where the closing character denotes
the end of the extended Standard~ML topdec.

=SML
local (* for holding reader names *)

open EfficientDictionary;

val âgeneral_readerá : (READER_FUNCTION * string) E_DICT ref = ref initial_e_dict;

val âspecific_readerá : (READER_FUNCTION * string) E_DICT ref = ref initial_e_dict;

in

fun âadd_general_readerá (name:string, constructor:string,
		reader:READER_FUNCTION) : unit = (
	general_reader := e_enter name (reader, constructor) (!general_reader)
);

fun âlook_up_general_readerá (name:string) : (READER_FUNCTION * string) OPT = (
	e_lookup name (!general_reader)
);

fun âadd_specific_readerá (name:string, constructor:string,
		reader:READER_FUNCTION) : unit = (
	specific_reader := e_enter name (reader, constructor) (!specific_reader)
);

fun âlook_up_specific_readerá (name:string) : (READER_FUNCTION * string) OPT = (
	e_lookup name (!specific_reader)
);

end (* of local for holding reader names *);
=TEX

%********************************************************************

\subsection{General Quotation}

{\ftlinepenalty=9999
=SML
local (* for function general_quotation *)

fun âget_language_nameá (R:READER_ENV) : string = (
let
	open PrettyNames;

	fun get_name (prev:string list) : string list = (
		case read_symbol R
		of	SymWhite _ => prev
		|	SymCharacter ch => (
				case ch
				of "\^D" => fail  "get_language_name" 5031 []
				| _ => get_name (ch :: prev)
			)
		|	SymKnown(_, _, (_, _, Starting _)) => prev
		|	SymKnown(_, _, (_, _, Ending _)) => prev
		|	SymKnown(_, _, (_, _, Middle _)) => prev
		|	SymKnown(_, _, (_, Value ch, _)) => get_name (ch :: prev)
		|	SymKnown(_, _, (names, _, _)) => get_name ((hd names) :: prev)
		|	SymUnknownKw(sym, _) => (
				local_error ;
				["_ERROR_"]
			)
		|	SymUnknownChar ch => (
				local_error ;
				["_ERROR_"]
			)
		|	SymDoublePercent => get_name ("%" :: prev)
	);

	val next = #look_at_next R ()
in
	if next = "%" orelse ord next > 127
	then
		case read_symbol R
		of	SymKnown(sym, _, ("down"::_, _, _)) => implode(rev(get_name nil))
		|	sym => (#push_back R (expand_symbol sym); "HOL")
	else if next = ":"
	then
		(#advance R (); "HOL:")
	else
		"HOL"
end
);
=TEX
}

On entry the opening quotation symbol (keyword or character, passed in
$start$) has been read, the first character after the symbol is the
first unread character.  The calling context is indicated by $in_ML$
where $true$ denotes the quotation occurs in extended Standard~ML,
$false$ denotes the quotation is from an object language.  The
information about the opening quotation symbol is given as info.

=SML
in (* local for function general_quotation *)

fun âgeneral_quotationá (R:READER_ENV) (start:string * bool) (opening:string) (in_ML:bool)
		(prevA:string list)
		: string list = (
let
	val lang_name = get_language_name R;

	val (reader, constructor) =
			case look_up_general_reader lang_name
			of Nil => (
				local_error  "general_quotation" 5011 nil;
				(skipping_reader, ""))
			| Value x => x;

	val (completion, prevB) =
		if in_ML
		then ("", prevA)
		else (", Lex.Text\"", constructor :: "\", " :: prevA);
in
	completion :: (reader R start lang_name opening prevB)
end
);

end (* of local for function general_quotation *);
=TEX

=SML
fun âspecific_quotationá (R:READER_ENV) (start:string, is_keyword:bool)
		(opening:string) (in_ML:bool) (prevA:string list)
		: string list = (
let
	val (reader, constructor) = 
			case look_up_specific_reader start
			of Nil => (
				local_error  "specific_quotation" 5011 nil;
				(skipping_reader, ""))
			| Value x => x;

	val (completion, prevB) =
		if in_ML
		then (";", prevA)
		else (", Lex.Text\"", constructor :: "\", " :: prevA);
in
	completion :: (reader R (start, is_keyword) "" opening prevB)
end
);
=TEX

%********************************************************************

\subsection{Reader for Standard~ML}

Standard~ML may be quoted in other languages, the reading functions
have been given earlier in this document, but they need an entry point
of the correct type to be introduced to function $general_quotation$,
and they need the correct wrapping when included in other languages.

In common with other quoted languages a string of the following form is
generated.

óSML Example
( recogniser ( "starting symbol", "language name", quoted_text, "closing symbol" ))
æ

In this case function $ReaderWriterSupport.SML_recogniser$ is the
$recogniser$, it just checks the validity of the three strings and
returns the value of the $quoted_text$.

=SML
fun âSML_recogniserá (start:string, lang:string, value:'a, finish:string) : 'a = (
let
	fun kw_matches(str, kw) = (
		kw = str orelse
		case PrettyNames.find_name kw
		of Value(names, ch_opt, _) =>
			contains (	case ch_opt
					of Value ch => ch :: names
					| _ => names
				) str
		| Nil => false
	);
in
	if		kw_matches(start, "<")
	andalso	kw_matches(finish, ">")
	andalso	(lang = "SML" orelse lang = "SML:")
	then
		value
	else
		fail "SML_recogniser" 5050 [fn () => start, fn () => lang, fn () => finish]
end
);
=TEX

Function $SML_reader$ gathers the actual text.  Function $get_ML_any$
is called in a loop because its task is to read text up to but not
including certain delimiters.  In this case we must read text up to and
including the next $Ending$ symbol.  All other characters must be read
and added to the output list.

=SML
fun âSML_readerá (R:READER_ENV) (start:string, is_keyword:bool)
		(lang:string) (opening:string) (prevA:string list) : string list = (
let
	open PrettyNames;

	val prevB =
		opening ::
		"\", " :: (*="=*)
		lang ::
		"\", \"" ::
		start ::
		"(\"" (*=")=*) ::
		"ReaderWriterSupport.SML_recogniser" ::
		"(" ::
		prevA;

	fun read prevC = (
		case get_ML_any R nil
		of nil => (	case read_symbol R
				of	SymCharacter "\^D" =>
						fail "SML_reader" 5032 nil
				|	SymKnown(sym, _, (_, _, Ending str)) =>
						(*=[((=*)	"\"))" :: sym :: ", \"" :: str :: prevC
				|	SymWhite _ => read (" " :: prevC)
				|	sym => read ((expand_symbol sym) :: prevC)
			)
		| "\^D"::nil =>	fail "SML_reader" 5032 nil
		| x =>		read (x @ prevC)
	);
in
	read prevB
end
);
=TEX
 
=SML
val _ = add_general_reader("SML", "Lex.Term", SML_reader);
val _ = add_general_reader("SML:", "Lex.Type", SML_reader);
=TEX

%********************************************************************

\subsection{Completion of Basic Reader Writer}

That ends the support structure.

=SML
end (* of structure ReaderWriterSupport *);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{READER WRITER}

=SML
structure âReaderWriterá : ReaderWriter = struct

open ReaderWriterSupport;
=TEX

During development the capability to abandon this reader writer system
and return to the PolyML default reader and writer is needed.  This is
achieved by providing a local exception that is handled appropriately,
together with a function to raise it.  This facility may be withdrawn
for the proper release.  Calling this function from within $usefile$ or
$usestring$ is allowed, the exception will be propagated out as far as
possible.

=SML
exception AbandonReaderWriter;
val abandoning = ref false;

fun abandon_reader_writer () : unit = (
	abandoning := true;
	raise AbandonReaderWriter
);
=TEX

%********************************************************************

\subsection{Diagnostics}

Several control flags are provided in this structure for debugging
purposes.  These flags are used throughout the rest of the structure.
This section defines all of the debugging flags used by the reader
writer.

=SML
val RWchars_read = ref false;
val _ =
new_flag {name = "âRWchars_readá",  control=RWchars_read, default=fn () => false};

val RWchars_written = ref false;
val _ =
new_flag {name = "âRWchars_writtená",  control=RWchars_written, default=fn () => false};

val RWphrases_read = ref false;
val _ =
new_flag {name = "âRWphrases_readá",  control=RWphrases_read, default=fn () => false};

val RWtext_read = ref false;
val _ =
new_flag {name = "âRWtext_readá",  control=RWtext_read, default=fn () => false};

val RNC = ref false;
val _ =
new_flag {name = "âRNCá",  control=RNC, default=fn () => false};
=TEX

=IGN

%--------------------------------------------------------------------

It is useful to have the commands to set and clear these flags easily available.

set_flag("RWchars_read", true);
set_flag("RWchars_written", true);
set_flag("RWphrases_read", true);
set_flag("RWtext_read", true);
set_flag("RNC", true);

set_flag("RWchars_read", false);
set_flag("RWchars_written", false);
set_flag("RWphrases_read", false);
set_flag("RWtext_read", false);
set_flag("RNC", false);

%--------------------------------------------------------------------

=SML
fun âlogitá flag proc str = (
	if !flag
	then
		(output(std_out, proc ^ "   " ^ (string_of_int(size str)) ^ "  <" ^
			(	case str of "\n" => "\\n"
				| "\^D" => "\\^D"
				| x => x) ^ ">\n");
		str)
	else
		str
);

fun âlogit_listá flag proc (str:string list) = (
	if !flag
	then
		(output(std_out, proc ^ "  " ^
			(PolyML.makestring (map (fn x => (size x, x)) str)) ^ "\n");
		str)
	else
		str
);
=TEX

%********************************************************************

\subsection{Outermost Levels of Reader Writer}

This routine is called by $PolyML.compiler$ to read the next part of
the input text.  It adopts a simple approach to text that $get_ML_any$
cannot parse properly, it passes the first symbol that did not parse
on to its caller.  Consider an unmatched closing bracket which
$get_ML_any$ cannot parse and so returns an empty string, the bracket
is read here and returned for the caller to deal with, probably by
issuing an error message.

The case analysis on the result of $read_symbol$ below is complete, but
we expect that most branches will never be taken as function
$get_ML_any$ will have fully handled the characters.  For example, the
$SymUnknown\ldots$ clauses should have already been reported as faults
and thus have been read past.

Text that parsed successfully here must be converted in the correct
order into a single string.

=SML
local (* for get_ML_outermost *)

val âsent_eofá = ref false;

fun âget_MLá (R:READER_ENV) = (
	case get_ML_any R nil
	of nil =>	(
		case read_symbol R
		of	SymCharacter "\^D" =>
				if !sent_eof
				then nil
				else (sent_eof := true; ["\^D"])
		|	sym => (sent_eof := false; [expand_symbol sym])
		)
	| "\^D"::nil =>	if !sent_eof
				then	nil
				else	(sent_eof := true; [#advance R ()])
	| x =>			(sent_eof := false; rev x)
);
=TEX

=SML
in (* local for get_ML_outermost *)

fun âget_ML_outermostá (R:READER_ENV) () : string = (
	let
		val ord_nl = ord "\n" and ord_tab = ord "\t"
		and ord_ff = ord "\^L" and ord_eof = ord "\^D";

		val text_read_list = get_ML R;
		val text_read = implode text_read_list
	in
		logit_list	RWphrases_read	"get_ML_outermost" text_read_list;
		logit		RWtext_read		"get_ML_outermost" text_read;
		if text_read = ""
		then	raise EndOfInput
		else	text_read
	end
)

end (* of local for get_ML_outermost *);
=TEX

When reading from a terminal the string returned by $get_ML_outermost$
will start with a space character.  It comes from the newline character
which (along with any sequence of white space characters) is turned
into a single space.  This character could be removed from the string
passed back to $PolyML.compiler$ but doing so is not easy, and in any
case $PolyML.compiler$ skips over it without any problem.  There are
other places in the string that could be optimised (e.g., spaces before
and after brackets) but again, $PolyML.compiler$ skips over them more
efficiently than this routine could remove them.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{COMPILER INTERFACE}

%********************************************************************

\subsection{PolyML Interface} \label{PolyML.compiler.example}

The routine $PolyML.compiler$ is the interface to the
read-evaluate-print loop of the PolyML system, it is a \Compiler{}
and has the signature:

óSML example
PolyML.compiler : (unit -> string) * (string -> unit) -> unit -> unit
æ

Calling this routine invokes the read-evaluate-print loop to process
one outermost level item (e.g., a declaration or an expression) which
is called a {\em topdec\/} in \cite{Milner90}.  When a {\em topdec\/}
is fully processed (i.e., a response is printed) the routine exits.
The first argument is called whenever the \Compiler{} requires more
input, the routine should return a string containing the text read.
The second argument is an output function, invoked by the \Compiler{}
for output messages.  The third argument is provided to delay execution
of the read-evaluate-print loop.

Routine $PolyML.compiler$ is recursive in the sense that a file
included by the above example routine may include other files by
calling $usefile$.  Whilst reading the innermost included file a stack
trace would show the following items:

\begin{itemize}

	\item Normal read-evaluate-print loop.
	\item Call of $PolyML.compiler$
	\item Call of $use_file_loop$
	\item Call of $usefile$.
	\item Normal read-evaluate-print loop.
	\item Call of $PolyML.compiler$
	\item Call of $use_file_loop$
	\item Call of $usefile$.
	\item Normal read-evaluate-print loop.
	\item Outermost levels of PolyML system.

\end{itemize}

End of file is indicated to the $PolyML.compiler$ with the control-D
character, this is not actually read from the file, it must be
generated by the reader function.  Observation of $PolyML.compiler$
suggests that the control-D character forces the \Compiler{} to parse
the preceding text as a complete {\em topdec,} but otherwise ignore the
character.  After fully processing a {\em topdec\/} the
$PolyML.compiler$ returns or raises an exception, just as it does for
any other {\em topdec.} As $PolyML.compiler$ is called in a loop to
allow for many {\em topdec\/}s the end of file processing must break
out of the loop, but first it should cause the parsing of any text just
read, this allows the \Compiler{} to produce error messages for files
which have incomplete {\em topdec\/}s, e.g., a file that ends with
`{\tt let val x}' or a string without a closing double quote.

As an example, a simple file inclusion facility could be written
as follows.

óSML example
fun usefile (file:string) : unit = (
let
	val cur_in = open_in file;
	val eof_char_sent = ref false;
	exception E_eof;

	fun reader () : string = (
	let
		val ch = input(cur_in, 1)
	in
		if ch = ""
		then	if	!eof_char_sent
			then	raise E_eof
			else	(eof_char_sent := true; "\^D")
		else	ch
	end);

	fun writer (s : string) : unit = output(std_out, s);

	fun use_file_loop () = (
		if (PolyML.compiler (reader, writer) (); true)
					handle E_eof => false
		then	use_file_loop ()
		else	()
	)
in
	use_file_loop ()
		handle E => (
			output(std_out,
				"Exception, abandoning file "
				^ file ^ "\n");
			close_in cur_in;
			raise E)
	;
	(* Only reach here after reading end-of-file *)
	close_in cur_in
end);
æ

The interface to ICL HOL provided by this document uses the
$PolyML.compiler$ interface in a style based on the example above, the
capabilities for handling pretty characters and producing prompts for
interactive input are provided by using more complex $reader$ and
$writer$ functions.

%********************************************************************

\subsection{ICL HOL Interface}
\label{IclHolInterface}

Four input sources are required for ICL HOL.

\begin{enumerate}

\item The console for normal interactive use.

\item Piped input for non-interactive use.

\item Included files.

\item Strings built by Standard~ML functions.

\end{enumerate}

The first two are alternatives, either the system is being run
interactively or input is being piped (in the UNIX sense) into the
system.  Both of these modes may request input of further Standard~ML
and HOL from another file.  The final input type allows Standard~ML
functions to create a string to be interpreted as Standard~ML or HOL
text.

\bigskip

To present these interfaces three main routines are identified.

\begin{description}

\item[$useterminal : unit -> unit$ ] which is the outermost routine of
	the lexical part of ICL HOL.  This routine is invoked at system
	startup and should remain in control at all times.  This
	routine is the primary interface to the ICL HOL system, it
	should replace the default outermost routine of PolyML.  Some
	investigation and experimentation\footnote{To be done.} is
	required to find a way of doing this.  Having this as the
	outermost routine means that it is started automatically when
	PolyML is started, also that breaking in with a control-C and
	entering ``{\tt f}'' (i.e., raising an exception to exit from
	the active Standard~ML and return to the top level) reverts to
	this routine.

\item[$use_file : string -> unit$ ] causes the named file to be read in
	a manner analogous to the routine $PolyML.use : string ->
	unit$ of PolyML.  The text read will be interpreted as
	Standard~ML and HOL the same as it had been entered at the
	outermost level.

\item[$use_string : string -> unit$ ] causes the contents of the string
	to be interpreted as Standard~ML and HOL the same as it had
	been entered at the outermost level or read from a file.

\end{description}

%********************************************************************

\subsection{Introduction To Reader Functions}

From experimentation with PolyML it seems that text in an included file
must be complete, i.e., capable of interpretation as a top level item.
Unclosed bracketing forms cause error messages.  For example,
unclosed comments, brackets, strings, {\tt let}-clauses and {\tt
local}-clauses all provoke an error message.  This behaviour should be
followed by the routines presented in this document.

The three routines named above ($useterminal$, $usefile$ and $usestring$)
will be written much as in the example in
section~\ref{PolyML.compiler.example}, but with different reader and
writer functions.  Each function will set up its input stream, and then
invoke $PolyML.compiler$ naming the appropriate reader and writer.  All
of the reader functions will call $get_ML_outermost$ to read some text,
this text will be returned to the \Compiler.  The reader functions must
set up the input streams so that the various routines in structure $R$
above are provided.

There are three areas that add complexity to the reading functions.
First, keeping track of line and character numbers within the source
text, to provide information for error messages.  Second, providing a
mechanism to track faults in the parser where it loops looking at a
character without actually reading it --- for example (an actual fault
found in early testing) a pretty character was found by $get_ML_any$
but the character was not actually read (i.e., $\#advance\;R\;();$ was
not called) and so on the next call of $get_ML_any$ the same character
was found, and again, and again.  Third, providing diagnostic output
about the characters read.

\label{ExcessiveControlDs}
To stop the reader looping without reading new characters a counter is
maintained of the number of times each character is passed to the
parsing functions, a failure is reported when this exceeds a threshold
value.  This threshold must be at least 3 since a character may be
examined by one of the bracketed text functions
then looked at by $get_ML_any$ and then
advanced over.  Longer sequences may be possible but have not (yet!)
been identified.

=SML
val max_copies_of_char_sent = 30;
=TEX

%********************************************************************

\subsection{Writer Function}

A common writer function is used by all three reader writers, its most
complex tasks are to recognise ASCII keywords and convert them to their
equivalent pretty characters and to recognise the numeric values of
pretty characters in strings and print the correct character.  The
conversions are as follows.  A keyword is a sequence of alphanumerics enclosed in ``{\tt QQ}'' 
characters, e.g., ``$\pi$'' is encoded as ``{\tt QQpiQQ}''.
If a decoding is available then replace the
whole keyword with the corresponding pretty character.  If no pretty
character is available then replace the enclosing ``{\tt QQ}'' characters with
single ``{\tt\%}'' characters.  To preserve ``{\tt Q}''s in the original
text the string ``{\tt QQQQ}'' is considered to be the keyword whose
representation is a single ``{\tt Q}''.
In no cases are an isolated ``{\tt Q}'' or ``{\tt QQQ}'' valid as part
of a keyword, they indicate either an internal error or that user code
has produced a string containing these letters.  An opening ``{\tt
QQ}'' with a non-alphanumeric before the closing ``{\tt QQ}'' is
produced in the same manner.  Both cases provoke an error message.

On occasions no conversions should be performed by the writer so a
control flag is provided.

=SML
val writer_convert = ref true;
val _ =
new_flag {name = "âwriter_convertá",  control=writer_convert, default=fn () => true};
=TEX

From observation of $PolyML.compiler$ it seems that no identifier or
string is split over two or more calls of the writer function,
therefore no memory is required\footnote{This may need to be
reconsidered after further experience of the use of $PolyML.compiler$
is obtained.} between invocations of the writer to deal with partial
identifiers or partial strings.  Additional work will be
needed\footnote{To be done.} to support HOL text output via the
writer.

{\ftlinepenalty=9999
=SML
fun âwriterá (s : string) : unit = (
let
	val ord_0 = ord "0";

	fun get_kw (prev, nil) = (prev, true, nil)
	|   get_kw (prev, "Q"::"Q"::t) = (prev, true, t)
	|   get_kw (prev, h::t) = (	if	(h >= "A" andalso h <= "Z")
					orelse	(h >= "a" andalso h <= "z")
					orelse	(h >= "0" andalso h <= "9")
					then	get_kw(prev ^ h, t)
					else	(prev, false, h::t));

	val e5009 = " (* ERROR 5009 *) ";

	fun aux nil = []
	|   aux ("Q"::"Q"::"Q"::"Q"::t) = "Q"::(aux t)
	|   aux (f as "Q"::"Q"::"Q"::t) = (
		local_error "writer" 5009 [fn () => implode f];
		e5009 :: (aux t))
	|   aux (f as "Q"::"Q"::rest) = (
		case	get_kw ("", rest)
		of (_, false, t) => (local_error "writer" 5009 [fn () => implode f]; e5009 :: (aux t))
		|  (kw, true, t) => (	case	PrettyNames.find_name kw
					of Value(_, Value ch, _)	=> ch
					| _				=> "%" ^ kw ^ "%"
				) :: (aux t))
	|   aux (f as "Q"::t) = (local_error "writer" 5009 [fn () => implode f]; e5009 :: (aux t))
	|   aux ((h as "\"")::t) = h::(aux_str t)  (*="=*)
	|   aux (h::t) = h::(aux t)

	and aux_str nil = []
	|   aux_str ("\""::t) = "\""::(aux t)
	|   aux_str ("\\"::d1::d2::d3::t) = (
		if		(d1 >= "0" andalso d1 <= "9")
		andalso	(d2 >= "0" andalso d2 <= "9")
		andalso	(d3 >= "0" andalso d3 <= "9")
		then
			let
				val dd1 = ord d1 - ord_0;
				val dd2 = ord d2 - ord_0;
				val dd3 = ord d3 - ord_0;
				val ch = (dd1 * 10 + dd2) * 10 + dd3
			in
				if ch > 127
				then	(chr ch) :: (aux_str t)
				else	"\\"::d1::d2::d3::(aux_str t)
			end
		else
			"\\"::d1::(aux_str(d2::d3::t)))
	|   aux_str(h::t) = h::(aux_str t);

	val chars = logit RWchars_written "writer" s
in
	output(std_out,	if	!writer_convert
				then	implode(aux(explode chars))
				else	chars)
end);
=TEX
}

%********************************************************************

\subsection{Input Pushback}

The pushed back input stream is a list of single characters, it should
not contain any empty strings or control-Ds.  Either of these may be
wrongly interpreted as end of input.

=SML
fun âscreen_for_push_backá (chars:string) (prev:string list) : string list = (
let
	fun aux ("\^D"::t) prevA = aux t prevA
	| aux (""::t) prevA = aux t prevA
	| aux (h::t) prevA = aux t (h::prevA)
	| aux nil prevA = prevA
in
	aux (explode chars) prev
end);
=TEX

%********************************************************************

\subsection{Reading From a File -- {\tt usefile}}

Reading from a file is normally stopped at the first failure noted
within the file, this can be altered to cause the whole file to be
processed.

=SML
val usefile_non_stop_mode = ref false;
val _ =
new_flag {name = "âusefile_non_stop_modeá",  control=usefile_non_stop_mode,
	default=fn () => false};
=TEX

{\ftlinepenalty=9999
=SML
fun âusefileá (file:string) : unit = (
let
	val cur_in =	open_in file
			handle IO => open_in(file ^ ".ML")
			handle IO => open_in(file ^ ".sml");
	val line_number = ref 1;
	val copies_of_char_sent = ref 0;
	exception Read_too_often of string;

	val read_ahead : string list ref = ref nil;

	fun read_char () : string = (
		case !read_ahead
		of nil =>	input(cur_in, 1)
		| h :: t =>	(read_ahead := t; h)
	);

	fun look_ahead_char () : string = (
		case !read_ahead
		of nil =>	let	val ch = input(cur_in, 1)
				in	(read_ahead := [ch]; ch) end
		| h :: _ =>	h
	);

	fun âf_advanceá () : string = (
		case read_char()
		of "" =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often "\\^D"
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "f_advance              " "\^D")
		|  "\n" => (	copies_of_char_sent := 0;
				line_number := !line_number + 1 ;
				logit RWchars_read "f_advance              " "\n")
		|  ch => (	copies_of_char_sent := 0;
				logit RWchars_read "f_advance              " ch)
	);

	fun âf_look_at_nextá () = (
		case look_ahead_char()
		of "" =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often "\\^D"
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "f_look_at_next         " "\^D")
		|  ch =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often ch
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "f_look_at_next         " ch)
	);

	fun âf_push_backá ("":string) : unit = ()
	| f_push_back (chars:string) : unit = (
		logit RWchars_read "f_push_back            " chars;
		read_ahead := screen_for_push_back chars (!read_ahead)
	);

	fun âf_skip_and_look_at_nextá () = (
		case read_char()
		of "" =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often "\\^D"
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					"\^D")
		|  "\n" => (	copies_of_char_sent := 0;
				line_number := !line_number + 1 ;
				"\n")
		|  ch => (	copies_of_char_sent := 0;
				ch);

		logit RWchars_read "f_skip_and_look_at_next"
			(case look_ahead_char()
			of "" =>	"\^D"
			|  ch =>	ch)
	);

	val reader = {	advance = f_advance,
			look_at_next = f_look_at_next,
			push_back = f_push_back,
			skip_and_look_at_next = f_skip_and_look_at_next} : READER_ENV;

	fun âuse_file_loopá () = (
		if (PolyML.compiler (get_ML_outermost reader, writer) (); true)
					handle EndOfInput => false
		then	use_file_loop ()
		else	()
	)
in
	while (
	 (use_file_loop (); false)
		handle Read_too_often ch => (
			output(std_out,
				"Character \"" ^ ch ^ "\" read too often, abandoning file "
				^ file ^ " at line "
				^ (string_of_int (!line_number)) ^ "\n");
			close_in cur_in;
			raise Read_too_often ch)
		| E =>
			if !usefile_non_stop_mode
			then (
				diag_string(
					"Exception+ " ^ (PolyML.makestring E)
					^ " handled by usefile at line "
					^ (string_of_int (!line_number)) ^ "\n");
				true)
			else (
				diag_string(
					"Exception+, abandoning file "
					^ file ^ " at line "
					^ (string_of_int (!line_number)) ^ "\n");
				close_in cur_in;
				raise E)
	) do ( (* nothing *) )
	;
	(* Only reach here after reading end-of-file *)
	close_in cur_in
end);
=TEX
}

%********************************************************************

\subsection{Reading From a String -- {\tt usestring}}

{\ftlinepenalty=9999
=SML
fun âusestringá (str:string) : unit = (
let
	val cur_str = ref(explode str);
	val char_number = ref 1;
	val copies_of_char_sent = ref 0;
	exception Read_too_often of string;

	fun âs_advanceá () : string = (
		case !cur_str
		of nil =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often "\\^D"
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "s_advance              " "\^D")
		|  ch::t =>	(copies_of_char_sent := 0;
				char_number := !char_number + 1;
				cur_str := t;
				logit RWchars_read "s_advance              " ch)
	);

	fun âs_look_at_nextá () = (
		case !cur_str
		of nil =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often "\\^D"
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "s_look_at_next         " "\^D")
		|  ch::_ =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often ch
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "s_look_at_next         " ch)
	);

	fun âs_push_backá ("":string) : unit = ()
	| s_push_back (chars:string) : unit = (
		logit RWchars_read "s_push_back            " chars;
		cur_str := screen_for_push_back chars (!cur_str)
	);

	fun âs_skip_and_look_at_nextá () = (
		case !cur_str
		of nil =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often "\\^D"
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					"\^D")
		|  ch::t =>	(copies_of_char_sent := 0;
				char_number := !char_number + 1;
				cur_str := t;
				ch);

		logit RWchars_read "s_skip_and_look_at_next"
			(case !cur_str
			of nil =>	"\^D"
			|  ch::_ =>	ch)
	);

	val reader = {	advance = s_advance,
			look_at_next = s_look_at_next,
			push_back = s_push_back,
			skip_and_look_at_next = s_skip_and_look_at_next} : READER_ENV;

	fun âuse_string_loopá () = (
		if (PolyML.compiler (get_ML_outermost reader, writer) (); true)
					handle EndOfInput => false
		then	use_string_loop ()
		else	()
	)
in
	use_string_loop ()
		handle Read_too_often ch => (
			diag_string(
				"Character \"" ^ ch
				^ "\" read too often, abandoning string at character "
				^ (string_of_int (!char_number)) ^ "\n");
			raise Read_too_often ch)
		| E => (
			diag_string(
				"Exception+, abandoning string at character "
				^ (string_of_int (!char_number)) ^ "\n");
			raise E)
	(* Only reach here after reading end-of-string *)
end);
=TEX
}

%********************************************************************

\subsection{Reading from a Terminal -- {\tt useterminal}}

It only makes sense to have one invocation of $useterminal$, by
contrast calls to function $usefile$ may be nested, one file may
include another.  This means that the basic reading functions (i.e.,
the `$f_\ldots$' functions) need to be declared within $usefile$ so
that they and any file related data items, such as the stream and the
lookahead buffer, are local to that invocation.  Calls of function
$usestring$ may be nested with calls of $usefile$. {} With
$useterminal$ only one invocation is allowed because of the handling of
the read ahead and the type ahead buffers.
Most of the local data and functions for $useterminal$ are declared
outside the function making the text of $useterminal$ itself smaller
than either $usefile$ of $usestring$, although the function and its support
is larger.

Prompts are required when the system wants the user to enter some
	characters.  Input is line based, the operating system provides
	line editing and only passes the characters when an end-of-line
	character is typed.  Second and later lines of a {\em topdec\/}
	should have a different prompt to the first.  To distinguish
	this reader from the PolyML default reader the prompts have a
	colon `:' added.  A prompt is required when the previously read
	character is a new line or a control-X.

=SML
local (* for useterminal and ask_at_terminal *)
	val prompt1 = ":> ";
	val prompt2 = ":# ";

	val cur_prompt = ref prompt1;

	val console_last : string ref = ref "\n";

	fun issue_prompt() : unit = (
		if !console_last = "\n" orelse !console_last = "\^X"
		then	output(std_out, !cur_prompt)
		else	()
	);
=TEX

The control-X character is taken to mean break as soon as
	possible to the main prompt of this reader, ignoring any text
	typed and processed already.

=SML
	exception QuitTopDec;
=TEX

All exceptions should be fielded by the reader, they should be
	reported to standard output, then the next {\em topdec\/}
	solicited.

Counting of times a character is used should take place just as
	in the other readers, to reduce the chances of run-away
	recursion of the parsing routines.

=SML
	val copies_of_char_sent = ref 0;
	exception Read_too_often of string;
=TEX

The lookahead buffer holds characters which have actually been read,
they are held until required by the parser.  The head of the list holds
the next character to be read, pushed back characters are added to the
head.

=SML
	val read_ahead : string list ref = ref nil;
=TEX

Reading of characters is mainly handled by one routine which deals
with prompting as required.  The second-line of a {\em topdec\/} is
considered to have started only after a character other than a new line
has been read.
Characters are also read by function $ask_at_terminal$ which empties
the terminal type ahead buffer into the look ahead buffer.

=SML
local
	fun read_next_character () = (
		issue_prompt();

		let
			val last = 	case input(std_in, 1)
					of "" => "\^D"
					|  ch => ch
		in
			console_last := last;
			if last = "\^X"
			then	raise	QuitTopDec
			else if last <> "\n"
			then	(cur_prompt := prompt2; last)
			else	last
		end
	);
in
	fun read_char () : string = (
		case !read_ahead
		of nil =>	read_next_character()
		| h :: t =>	(read_ahead := t; h)
	);

	fun look_ahead_char () : string = (
		case !read_ahead
		of nil =>	let	val ch = read_next_character()
				in	(read_ahead := [ch]; ch) end
		| h :: _ =>	h
	);
end;
=TEX

=SML
	fun ât_push_backá ("":string) : unit = ()
	| t_push_back (chars:string) : unit = (
		logit RWchars_read "t_push_back            " chars;
		read_ahead := screen_for_push_back chars (!read_ahead)
	);
=TEX

The functions passed in a $READER_ENV$ record are very similar\footnote{We
could take advantage of the routine $read_next_character$ to centralise
the character counting in a future release of this document.} to those
of the other readers apart from the end-of-file handling not being
needed.

=SML
	fun ât_advanceá () : string = (
		copies_of_char_sent := 0;
		logit RWchars_read "t_advance              " (read_char ())
	);
=TEX

Note the call on $t_advance$ before raising $Read_too_often$ in 
$t_look_at_next$, this is
to force a way past the offending character.

=SML
	fun ât_look_at_nextá () = (
	let
		val ch = look_ahead_char()
	in
		if !copies_of_char_sent > max_copies_of_char_sent
		then	(t_advance(); raise Read_too_often ch)
		else	(copies_of_char_sent := (!copies_of_char_sent + 1);
			logit RWchars_read "t_look_at_next         " ch)
	end);

	fun ât_skip_and_look_at_nextá () = (
		read_char();
		logit RWchars_read "t_skip_and_look_at_next"
			(case look_ahead_char()
			of "" =>	if !copies_of_char_sent > max_copies_of_char_sent
					then	raise Read_too_often "\\^D"
					else	(copies_of_char_sent := (!copies_of_char_sent + 1);
						"\^D")
			|  ch => (	copies_of_char_sent := 0;
					ch)
			)
	);

	val reader = {	advance = t_advance,
			look_at_next = t_look_at_next,
			push_back = t_push_back,
			skip_and_look_at_next = t_skip_and_look_at_next} : READER_ENV;
=TEX

Most exceptions should be handled by the \Compiler{} loop which reports
them and then continues.  Exception $EndOfInput$ is
raised in response to end-of-file (control-D) characters being passed
to the parsing functions, the response is\footnote{Should probably also
	do a $PolyML.commit$ here to follow the practice of PolyML
	itself.  Unfortunately if we did then the first action on
	starting with such a database is to resume this function after
	the commit, which means that the quit is performed.  This leads
	to a PolyML database which quits immediately after it is
	started.  Some more investigation is required in this area.}
to call $PolyML.quit$.  Function $read_next_character$ deals with
control-X characters
locally by raising $QuitTopDec$ to indicate the users request to return
to the outer level of useterminal.  Exception $Read_too_often$ denotes
a coding fault in the processing of the users input.  Exception
$AbandonReaderWriter$ indicates the users desire to abandon this reader
writer package.  All other exceptions are just reported.  Note that in
many cases $PolyML.compiler$ will catch the exception, report it, and
raise an exception whose name is not available (presumably it is
declared local to the PolyML system).  This means that there needs to be
a check for abandoning in the ``others'' clause of the match for
exceptions below.

=SML
val âuseterminal_is_activeá : bool ref = ref false;

in (* local for useterminal and ask_at_terminal *)

fun âuseterminalá () : unit = (
let
	fun âuse_term_loopá () = (
		if (PolyML.compiler (get_ML_outermost reader, writer) (); true)
			handle EndOfInput => (diag_string 
					"End of input to useterminal.  Quit.";
				PolyML.quit(); false)
			| Fail x => (diag_string(
					"Exception+ Fail " ^ (PolyML.makestring x) ^ " raised");
				true)
			| Error x => (diag_string(
					"Exception+ Error " ^ (PolyML.makestring x) ^ " raised");
				true)
			| AbandonReaderWriter => (diag_string "Abandoning reader writer";
				false)
			| QuitTopDec => (diag_string
					"Control-X read, return to outer level of useterminal";
				true)
			| Read_too_often ch => (
				diag_string( "Character \"" ^ ch
					^ "\" read too often, abandoning current input");
				true)
			| E =>	if !abandoning
				then (	diag_string "Abandoning reader writer";
					false)
				else (	diag_string(
						"Exception+ " ^ (PolyML.makestring E)
						^ " handled by useterminal");
					true)
		then	(cur_prompt := prompt1; use_term_loop ())
		else	()
	)
in
	if !useterminal_is_active
	then
		()
	else
		(
			useterminal_is_active := true;
			cur_prompt := prompt1;
			abandoning := false;
			console_last := "\n";

			use_term_loop ();

			useterminal_is_active := false
		)
end);
=IGN
Alternatively:
			output(std_out, "End of input to useterminal.  Commit and quit.\n");
			PolyML.commit();
=TEX

The PolyML input output system has a `type ahead' buffer which is normally
invisible, however when questions are to be asked of the user at the terminal
the type ahead buffer must be emptied before reading the users answer.
Failing to empty the buffer may mean the wrong text being taken as the
answer, and that text

Recording the contents of the type ahead buffer is only performed
on terminals, do nothing for other type of input.

=SML
fun âask_at_terminalá (prompt:string) : string = (
let
	fun read_terminal_type_ahead_buffer  () : unit = (
	let
		fun aux prev_ch = (
			if ExtendedIO.can_input(std_in, 1)
			then
				aux((input(std_in, 1)) :: prev_ch)
			else
				prev_ch
		);

		val typed_ahead = aux nil;
	in
		case typed_ahead
		of last ::_ => console_last := last
		| _ => ();

		read_ahead := (!read_ahead) @ (rev typed_ahead)
	end
	);
in
	if  !useterminal_is_active
	then
		if ExtendedIO.is_term_in std_in
		then
			(	read_terminal_type_ahead_buffer();
				output(std_out, prompt);
				ExtendedIO.flush_out std_out;
				ExtendedIO.input_line std_in
			)
		else
			fail "ask_at_terminal" 5013 []
	else
		fail "ask_at_terminal" 5012 []

end) (* of ask_at_terminal *);

end (* of local for useterminal and ask_at_terminal *);
=TEX

%********************************************************************

\subsection{Completion of Basic Reader Writer}

=SML
end (* of structure ReaderWriter *);

open ReaderWriter;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{HOL READER WRITER}

=SML
structure âHOLReaderWriterá : HOLReaderWriter = struct

open ReaderWriterSupport;
=TEX

%********************************************************************

\subsection{Warning Messages}

Faults detected in the embedded text are reported via $local_error$ as
they occur, they are also noted in the generated output using these
two functions.

=SML
fun âlex_error_codeá (id : int, prev:string list) : string list = (
	", Lex.Text\"" :: (*="=*)
	"Lex.error " ^ (string_of_int id) ::
	"\", " :: (*="=*)
	prev
);

fun	âlex_error_codesá (nil : int list, prev:string list) : string list =
		prev
|	lex_error_codes (errnos, prev) =
		fold lex_error_code errnos prev
;
=TEX

%********************************************************************

\subsection{Recursive HOL Parser}

Brackets within HOL text need only be examined to see if they relate to
comments, all the other forms of bracket can simple be passed on for
the HOL lexical analyser and parser to deal with.

{\ftlinepenalty=9999
=SML
fun âget_HOL_anyá (R:READER_ENV) (prevA:string list) : string list= (
let
	open PrettyNames;

	fun	do_keyword _ (_,Value ch,Simple) p =
			get_HOL_any R ((to_ML_string ch) :: p)
	|	do_keyword _ (names,Nil,Simple) p =
			get_HOL_any R ("%" ^ (hd names) :: p)
	|	do_keyword k (info as (_,_, (Starting(proc, str)))) p =
			get_HOL_any R (proc R k str false p)
	|	do_keyword _ (_,_,Middle str) p =
			get_HOL_any R (str :: p)
	|	do_keyword (k, _) (_,ch_opt,Ending str) p =
			((*=[(("=*)	"\"))" :: k :: "\"], \"" :: str :: p)
	|	do_keyword _ (_,_,Ignore) p =
			get_HOL_any R p
	|	do_keyword (k, is_keyword) (names,_,Invalid) p = (
			local_error "get_HOL_any" 5007
				[fn () => if is_keyword then "%" ^ k ^ "%" else k];
			get_HOL_any R (lex_error_code(5007, p)));

	fun do_string ML_string = (
		let	val (read_string, ol_name) =
				if ML_string
				then	(get_ML_string, "Lex.String")
				else	(get_primed_string, "Lex.Char");
			val (str, errnos) = read_string R (ol_name :: "\", " :: prevA); (*="=*)
			val text_so_far = ", Lex.Text\"" (*="=*) :: str;
		in
			get_HOL_any R (lex_error_codes(errnos, text_so_far))
		end
	);

	val next = #look_at_next R ()
in
	case read_symbol R
	of	SymCharacter ch => (
			case ch
			of "("	=>	(	if #look_at_next R () = "*"
						then
							(skip_comment R;
							get_HOL_any R (" " :: prevA))
						else
							get_HOL_any R ( "(" ::  prevA))
			|  "\""	=>	do_string true (*="=*)
			|  "`"	=>	do_string false
			|  "\^D" =>	prevA
			|  "Q"	=>	get_HOL_any R ("QQQQ" :: prevA)
			|  _ => 	get_HOL_any R (ch :: prevA)
		)
	|	SymWhite wh => get_HOL_any R (" " :: prevA)
	|	SymKnown(sym, is_keyword, info) => do_keyword (sym, is_keyword) info prevA
	|	SymDoublePercent => get_HOL_any R ("%%" :: prevA)
	|	SymUnknownKw(sym, is_closed) => (
			local_error "get_HOL_any" 5003 [fn () => sym, fn () =>
							implode(rev(" ... " :: (prevA to 10)))];
			get_HOL_any R (lex_error_code(5003, prevA))
		)
	|	SymUnknownChar ch => (
			local_error "get_HOL_any" 5005
						[fn () => ch,
						fn () => string_of_int(ord ch),
						fn () => implode(rev(" ... " :: (prevA to 10)))];
				get_ML_any R (lex_error_code(5005, prevA))
		)
end);
=TEX
}

%********************************************************************

\subsection{Outer Level of the HOL Reader}

HOL text is to be read, the opening symbol and language name are
given.  Produce Standard~ML text as follows to add onto the left
hand context.

óSML Example
( recogniser ( "starting symbol", "language name", quoted_text, "closing symbol" ))
æ

Where the $quoted_text$ is a list of values of type $Lex.INPUT$, see
section\ref{DatatypeForParserInterface}.  Function $HOL_reader$ is
responsible for building the opening part of the Standard~ML text,
function $get_HOL_any$ reads and assembles the quoted text (i.e., the
body of the quotation) and the closing text.

=SML
fun âHOL_readerá (recogniser:string) (R:READER_ENV) (start:string, is_keyword:bool)
		(lang:string) (opening:string) (prevA:string list) : string list = (
let
	val prevB =
		opening ::
		"\", [Lex.Text\"" ::
		lang ::
		"\", \"" ::
		start ::
		"(\"" (*=")=*) ::
		recogniser ::
		"(" ::
		prevA;
in
	get_HOL_any R prevB
end
);
=TEX

%********************************************************************

\subsection{Installing the HOL Reader}

=SML
val âHOL_term_readerá = HOL_reader "HOL_term_recogniser";
val âHOL_type_readerá = HOL_reader "HOL_type_recogniser";

val _ = add_general_reader("HOL", "Lex.Term", HOL_term_reader);
val _ = add_general_reader("HOL:", "Lex.Type", HOL_type_reader);
=TEX


%********************************************************************

\subsection{Pretty Characters for HOL} \label{PrettyCharactersForHOL}

Box drawing, first the symbols that start a box.  Note that many
of these symbols have no interpretation in HOL or Standard~ML.
The Standard~ML comments below that contain only a string quote
`~{\tt"}~' are present to make the number of such quotes even
on each line.

The bracketing conventions used within HOL text need explaining.
Simple HOL text used as term or type expressions is not bracketed.  The
definitional HOL texts include brackets, these are generally used in a
style where the user enters the five components: {\em start,
definitions, where, predicate} and {\em finish.}  The {\em start,
where} and {\em finish\/} are the symbols defined below.  The users
input is translated to give a HOL term comprising the pair ``({\em
definitions\/}),~({\em predicate\/})'' which is used as the argument of
a Standard~ML function to achieve the definition.

=SML
local
open PrettyNames;

in
val _ = add_new_symbols [
=TEX

Box drawing, symbols that start a box.

=SMLLITERAL
	([	"<"],		Value "»",		Starting(general_quotation, "")),
	([	"SHA"],	Value "È",		Starting(specific_quotation, "(")), (*=)=*)
	([	"SHIA"],	Value "ç",		Starting(specific_quotation, "(")), (*=)=*)
	([	"SHS"],	Value "Ç",		Starting(specific_quotation, "(")), (*=)=*)
=TEX

Box drawing, symbols that complete a box.  Some of the pretty
characters can denote the end of several different types of box, note
the names used for end-of-Z boxes below.

=SMLLITERAL
	([	">"],		Value "¼",			Ending ""),

	([	"EHS",
		"EZC",
		"EZS"],	Value "Ê",			Ending (*=(=*) ")"),
	([	"EHA",
		"EZA"],	Value "Ë",			Ending (*=(=*) ")"),
=TEX

Box drawing, symbols used within boxes.

=SMLLITERAL
	([	"BBR"],	Value "à",			Ignore),
	([	"BH"],		Value "Í",			Ignore),
	([	"BHH"],	Value "ü",			Ignore),
	([	"BT"],		Value "É",			Middle "),("),
	([	"BTR"],	Value "ß",			Ignore),
	([	"BV"],		Value "Ý",			Ignore)
]
end (* of local *);
=TEX

Now the specific reading functions for the languages are introduced.

=SMLLITERAL
val _ =	map (fn (name, recogniser) =>
		add_specific_reader(name, "NONE", HOL_reader recogniser))
	[
	("SHA",		"HOL_axiomatic_recogniser"),
	("È",		"HOL_axiomatic_recogniser"),
	("SHIA",	"HOL_infix_recogniser"),
	("ç",		"HOL_infix_recogniser"),
	("SHS",		"HOL_schema_recogniser"),
	("Ç",		"HOL_schema_recogniser")
	];
=TEX

%********************************************************************

\subsection{HOL Reader Writer --- Completion}

=SML
end (* of structure HOLReaderWriter *);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{FINALE}

We wish to use $usefile$ as the file loading facility when building
subsequent files into the {\tt hol.db}.  $Install_file_loader$ is the
function that is used by the build script for {\tt hol.db} to load a
file to compile.  As a side effect, a large portion of this structure
is tested during the creation of the rest of the system.

=SML
Install_file_loader := (fn x => (diag_string ("usefile "^ x); usefile x));
=TEX

Now make some checks that things have been built properly.

=SMLLITERAL
let
	fun check_name (n, l) = (
		case ReaderWriterSupport.PrettyNames.find_name n
		of Nil => n :: l
		| _ => l
	);

	fun check_char (c, l) = (
		case ReaderWriterSupport.PrettyNames.find_char c
		of Nil => c :: l
		| _ => l
	);

	fun wrap nil title = ()
	| wrap l title = list_diag_string("Failed to load the" :: title :: l);

	val bad_names = fold check_name ["<", "SHS", "lambda", "fn"] nil;
	val bad_chars = fold check_char ["»", "Ç", ""] nil
in
	wrap bad_names "keywords:";
	wrap bad_chars "pretty characters:"
end;
=TEX

We will wish to use $useterminal$ from now onwards, unless explicitly
aborted by the user.

=SML
useterminal();
=TEX

Any Standard~ML text from here to the end of the file will be ignored
because the call of $useterminal$ has replaced the PolyML reading
function with the code within $useterminal$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\newpage

\makeatletter
\def\refstepcounter#1{\stepcounter{#1}\global\edef\@currentlabel{\csname
	p@#1\endcsname\csname the#1\endcsname}}
\makeatother

\twocolumn[\section{INDEX}] \label{Index}

\footnotesize
\printindex

\onecolumn

\end{document}
