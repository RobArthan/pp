% imp005.doc %Z% $Date$ $Revision$ $RCSfile$

=TEX
% imp005.doc %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol,11pt,TQ]{article}

\TPPtitle{File and Terminal Reader Writer}
\TPPref{DS/FMU/IED/IMP005}
\TPPissue{$Revision$%
}

\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{IED 1563}

=IGN

Commands to process this document in various ways.

make -f rel001.mkf imp005.dvi
doc4tex imp005
tex4dvi imp005
bibtex imp005
doc4tex imp005 ; tex4dvi imp005
dvipage imp005 &

dviselect 31:   imp005.dvi | pstex -
dviselect 16:30 imp005.dvi | pstex -
dviselect  1:15 imp005.dvi | pstex -


doc4errors imp005
PolyML.use "imp005.sml";

abandon_reader_writer();

poly -r sun4hol.db
poly -r /hat/projects/ied/rel001/sun4hol.db


lasp -s imp005.doc > zz1
lasp -s -u imp005.OKwords imp005.doc > zz1

=TEX
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Standard}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the reading and writing functions
	that form the outermost level of user interface for Release~1
	of ICL~HOL.  These functions are concerned with the
	differentiation of the various languages (initially Standard~ML
	and HOL), and the extensions to support pretty characters in
	Standard~ML identifiers and in strings.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

%\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\makeatletter
\def\StartTerm{\@Mm{\mathchar"2\@fx70\relax}}
\def\EndTerm{\@Mm{\mathchar"2\@fx71\relax}}

\def\UPchar{\@Mm{\mathchar"0\@fx66\relax}}
\def\DNchar{\@Mm{\mathchar"0\@fx67\relax}}

\def\calllatex{\@Mm{\mathchar"0\@fx7B}}
\def\negate{\@Mm{\mathchar"0\@fy6B}}

\def∏{\calllatex}
\def™{\negate}
\def„{\DNchar}
\def¬{\UPchar}

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}
\makeatother


\def\Compiler{C{\tiny OMPILER}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

%********************************************************************

\subsection{Contents List}
\tableofcontents
% \listoftables

%********************************************************************

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

%********************************************************************

\subsection{Changes History}

\begin{description}

\item[1 February 1991, issue 1.1 ] This issue is an authors draft.

\item[4 February 1991, issue 1.2 ] $useterminal$ is invoked by loading
	this file, and $usefile$ is set to be used in subsequent
	Install's used in building {\tt hol.db}.

\item[21 February 1991, issue 1.3 ] Change the control-D handling in
	$useterminal$.  Add a proper writer function that converts
	ASCII strings into pretty characters.

\item[6 March 1991, issue 1.4 ] Restructure to give support for other
	language readers via structure $ReaderWriterSupport$ and use
	that to form the HOL reader.  Minor improvements throughout,
	particularly in $useterminal$.

\end{description}

%********************************************************************

\subsection{Changes Forecast} \label{ChangesForecast}

\begin{enumerate}

\item Does the recursive descent need to understand as much of the
	language as is currently handled?  Could it be reduced to
	understanding the following:

	\begin{description}

	\item[ML ] HOL term start and finish, round braces, strings,
		comments

	\item[HOL ] anti-quotation start and finish, strings, character
		literals, comments

	\item[Strings ] start and finish, limited range of escape
		sequences.

	\end{description}

\item Properly install $useterminal$ as the outermost reader writer of
	the system.  This will include producing proper handling of the
	routines $PolyML.quit$ and $PolyML.commit$ together with the
	implicit calling of $PolyML.commit$ at end of input.

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the reading and writing routines for Release~1 of
the ICL HOL system.

%********************************************************************

\subsection{Introduction}

%********************************************************************
%\subsubsection{Purpose and Background}
%********************************************************************
%\subsubsection{Dependencies}
%********************************************************************
%\subsubsection{Interface}
%********************************************************************
%\subsubsection{Algorithms}
%********************************************************************
%\subsubsection{Possible Enhancements}
%********************************************************************
%\subsubsection{Deficiencies}
%********************************************************************

\subsubsection{Terminology}

The word `\Compiler' is used to denote the part of a Standard~ML system
that lexically analyses, parses, evaluates and formats for output
Standard~ML text.  The routine $PolyML.compiler$ is an example of a
`\Compiler'.

%********************************************************************

\subsection{Deviations From Definition Document \protect{\cite{DS/FMU/IED/DEF002}}}

Some changes are necessary to the ideas proposed
in~\cite[issue~1.1]{DS/FMU/IED/DEF002}.

%********************************************************************

%\subsubsection{Pretty Characters in ML Identifiers}

%\subsubsection{In ML Text} \label{PrettyChInML}

Modified version of section~5.1.2 ``In ML Text''
of~\cite[issue~1.1]{DS/FMU/IED/DEF002}

\bigskip

Pretty characters will be converted to an alphanumeric form to allow
their inclusion in Standard~ML {\em alphanumeric\/} identifiers.
This means that the characters \ \ $ı abc$ \ \ form one identifier,
whereas the characters \ \ $=\!abc$ \ \ form the two juxtaposed
identifiers \ \ $=$ \ \ and \ \ $abc$.

The conversion should be seen as `macro processing' of the source text
to create Standard~ML text.  The Standard~ML code section `{\tt val
$\pi$ = 1;}' is first converted to `{\tt val \%pi = 1;}'. \ The percent
sign is not allowed as part of an alphabetic name, so a second stage of
processing converts it to `{\tt val QQpi = 1;}'.  \ The conversion must
respect the letters `{\tt\%}' and `{\tt Q}' in the original source.  A
`{\tt\%}' in Standard~ML is (part of) a symbolic identifier, all
percent signs that are not immediately followed by an alphanumeric name
or by one of the known non-alphanumeric names\footnote{This may appear
to conflict with the ideas in section~\ref{UnknownAsciiNames}, but
they apply to unknown names used in HOL text whereas this section deals
with names used in Standard~ML.} (which are both listed in the index
in appendix~\ref{Index}) will be left unaltered.  The string `{\tt
Q}' will be converted into `{\tt QQ}'.  To allow the reverse
conversion no keyword may contain the letters `{\tt QQ}'.  To show
all these conversions, consider the following example whose first line
is the users original text; the second and third show the results of
macro processing; the third being what is presented to the
Standard~ML compiler.

{\tt\catcode`\%=12
\begin{tabbing}
\hspace*{3em}\=\+\kill
	val ı = 3 Q QQ QQQ QQQQ % %% %%% %cap % cap;\\
	val %pi = 3 QQQ QQQQQQ QQQQQQQQQ QQQQQQQQQQQQ % %% %%% %cap % cap;\\
	val QQpi = 3 QQQ QQQQQQ QQQQQQQQQ QQQQQQQQQQQQ % %% %%% QQcap % cap;\\

\end{tabbing}}

If the third line were displayed to the user on a graphics workstation,
it would be as follows, where the first line is the form displayed on a
graphics workstation, the second is the simple ASCII form.

{\tt\catcode`\%=12
\begin{tabbing}
\hspace*{3em}\=\+\kill
	val ı = 3 Q QQ QQQ QQQQ % %% %%% † % cap;\\
	val %pi = 3 Q QQ QQQ QQQQ % %% %%% %cap % cap;
\end{tabbing}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{PRELUDE}

%********************************************************************

\subsection{Start of Basic Reader Writer}

Everything goes in a structure.

=SML
structure ‚ReaderWriter· : ReaderWriter = struct
=TEX

During development the capability to abandon this reader writer system
and return to the PolyML default reader and writer is needed.  This is
achieved by providing a local exception that is handled appropriately,
together with a function to raise it.  This facility may be withdrawn
for the proper release.  Calling this function from within $usefile$ or
$usestring$ is allowed, the exception will be propagated out as far as
possible.

=SML
exception AbandonReaderWriter;
val abandoning = ref false;

fun abandon_reader_writer () : unit = (
	abandoning := true;
	raise AbandonReaderWriter
);
=TEX

%********************************************************************

\subsection{Integers and Strings}

Ordinal values of some characters are useful.

=SML
val ‚ord_0· = ord "0";
val ‚ord_9· = ord "9";
=TEX

The string representation of integers is needed in various places.
This is mainly to do with Standard~ML strings where some characters are
denoted by their decimal code in three digits, preceded by a
backslash.  Function $convert$ gives the string representation of a
positive number; $convert3$ gives a three character with leading zeros
representation of small positive numbers.

=SML
fun ‚convert· (0:int) : string = "0"
| convert m = (
	let	fun aux 0 = ""
		| aux n = (
			if n < 0
			then	fail "convert" 5009 [fn () => PolyML.makestring n]
			else	aux(n div 10) ^ chr(ord_0 + (n mod 10)))
	in
		aux m
	end
);

fun ‚convert3· n = (
	let
		val str = convert n
	in
		case size str
		of 0 => "000"
		| 1 => "00" ^ str
		| 2 => "0" ^ str
		| 3 => str
		| x => fail "convert3" 5010
			[fn () => PolyML.makestring n, fn () => PolyML.makestring x]
	end
);
=TEX

%********************************************************************

\subsection{Diagnostics}

Several control flags are provided in this structure for debugging
purposes.  These flags are used throughout the rest of the structure.
This section defines all of the debugging flags used by the reader
writer.

=SML
val RWchars_read = ref false;
val _ =
new_flag {name = "‚RWchars_read·",  control=RWchars_read, default=fn () => false};

val RWchars_written = ref false;
val _ =
new_flag {name = "‚RWchars_written·",  control=RWchars_written, default=fn () => false};

val RWphrases_read = ref false;
val _ =
new_flag {name = "‚RWphrases_read·",  control=RWphrases_read, default=fn () => false};

val RWtext_read = ref false;
val _ =
new_flag {name = "‚RWtext_read·",  control=RWtext_read, default=fn () => false};

val RNC = ref false;
val _ =
new_flag {name = "‚RNC·",  control=RNC, default=fn () => false};
=TEX

=IGN

%--------------------------------------------------------------------

It is useful to have the commands to set and clear these flags easily available.

set_flag("RWchars_read", true);
set_flag("RWchars_written", true);
set_flag("RWphrases_read", true);
set_flag("RWtext_read", true);
set_flag("RNC", true);

set_flag("RWchars_read", false);
set_flag("RWchars_written", false);
set_flag("RWphrases_read", false);
set_flag("RWtext_read", false);
set_flag("RNC", false);

%--------------------------------------------------------------------

=SML
fun ‚logit· flag proc str = (
	if !flag
	then
		(output(std_out, proc ^ "   " ^ (PolyML.makestring(size str)) ^ "  <" ^
			(	case str of "\n" => "\\n"
				| "\^D" => "\\004"
				| x => x) ^ ">\n");
		str)
	else
		str
);

fun ‚logit_list· flag proc (str:string list) = (
	if !flag
	then
		(output(std_out, proc ^ "  " ^
			(PolyML.makestring (map (fn x => (size x, x)) str)) ^ "\n");
		str)
	else
		str
);
=TEX

%********************************************************************

\subsection{Start of Embedding Interface}

Most of the reader writer is placed in a structure within the main
$ReaderWriter$ structure.  The items made visible from the outer
structure are for the normal users of the system, those from the inner
structure are provided to allow the embedding of other languages.

=SML
structure ‚ReaderWriterSupport· = struct
=TEX

%********************************************************************

\subsection{Reader Environment} \label{DeclareReaderEnv}

A record structure is used to contain the environment used when
reading, this is primarily the character reading functions to
accommodate the various sources of Standard~ML text discussed in
section~\ref{IclHolInterface}.  The record is properly described in
section~\ref{ReaderEnvironment}, but its definition is presented here
to enable its use within the table of pretty characters, in particular
its use within the datatype $NAME_CLASS$ of
section~\ref{DeclareNameClass}.

=SML
type ‚READER_ENV· = {
	‚advance·			: unit -> string,
	‚look_at_next·			: unit -> string,
	‚skip_and_look_at_next·	: unit -> string
};
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{PRETTY CHARACTERS}

The system supports pretty characters in the source documents and on
the printed output.  There are more characters available for output
than can be contained in the eight bit character set that is
available.  The additional pretty characters may be input by using a
keyword approach where the keywords are introduced by a percent
`{\tt\%}' character.  Details of all of the keywords and the actual
pretty characters are included in a structure for use by other parts of
the lexical analyser.

To allow for the inclusion of other languages the structure is
extensible.  It is initialised with the characters and keywords to
support Standard~ML extended to allow pretty characters in identifiers
and strings.  Later stages of this document\footnote{Or another
document.} will extend the structure to support HOL and Z.

=SML
structure ‚PrettyNames· = struct
=TEX

%********************************************************************

\subsection{Data Held for Pretty Characters}

Symbols that may be used in identifiers are either $Affable$ which
means they can freely be used with other $Affable$ symbols, or
$Singular$ which are less often used with other symbols.

=SML
datatype ‚AFFINITY· = ‚Affable· | ‚Singular· ;
=TEX

The class of each symbol is recorded.  The symbols for embedding other
languages have a string and a function.  The strings is written at the
start of the embedded language sequence, it will (typically) contain
the name of the Standard~ML function to lexically analyse, parse and
type check the language plus an opening bracket.  The function will
perform a recursive decent (as described in section~\ref{ReaderWriter})
of the next characters input.  Note that ending symbol are included in
the structure to allow their easy detection, but the function invoked
at the start of and embedded language sequence must verify that the
correct ending symbol is used.

\label{DeclareNameClass}

=SML
datatype ‚NAME_CLASS·
	=	‚Simple·	of AFFINITY
	|	‚Starting·	of string * (READER_ENV -> string list -> string list)
	|	‚Middle·	of string
	|	‚Ending·	of string
	|	‚Ignore·
	|	‚Invalid·
	|	‚Separator·
	;
=TEX

For each distinct symbol a tuple is held.  It contains: a list of the
alternative names for the symbol, with the preferred name at head; the
pretty character, if any; and, the class of the name, that is where and
how it is used.

=SML
type ‚PRETTY_NAME· = ( string list * string OPT * NAME_CLASS );
=TEX

%********************************************************************

\subsection{Pretty Character Dictionary}

The purpose of this data structure is to capture all of the names of
the symbols together with their pretty characters and attributes.  The
intention is that this table is fairly easy to understand and modify,
that the information about each symbol is given only once --- although
the generated data structure may replicate information.

A simple linear search through the table would be slow so the names and
characters are configured as an efficient dictionaries, their contents
are provided later.

The dictionaries themselves are accessed only via insertion and
inspection functions.

=SML
local (* for add_new_symbols, find_name and find_char *)

open EfficientDictionary;

val ‚name_dict·	: PRETTY_NAME E_DICT ref = ref initial_E_DICT;
val ‚char_dict·		: PRETTY_NAME E_DICT ref = ref initial_E_DICT;
=TEX

To insert values into these dictionaries the following routines are
provided.

Some of the entries for pretty characters above are temporary, we do
not yet have the proper set of pretty characters.  To direct attention
to the characters which are not correctly handled details will be
obtained by examining the above list whilst the list produced remains
non-empty some characters need attention.  Alter\footnote{To be done.
Also, should we have additional checks on the validity of keywords and
pretty characters?} $add_char$ to give warning 5016 if $size <> 1$ or
character is not pretty (rather than just calling $diag_line$ to print
a warning).  Give warning 5015 from $add_name$ and $add_char$ if there
are no names.

=SML
in (* local for add_new_symbols, find_name and find_char *)

fun ‚add_new_symbols· (pnl:PRETTY_NAME list) : unit = (
let
	fun add_name(pcd as (names, _, _) : PRETTY_NAME, dict : PRETTY_NAME E_DICT
			) : PRETTY_NAME E_DICT = (
	let	fun aux(name, dict) = e_enter name pcd dict
	in	fold aux names dict
	end);
	
	fun add_char((_, Nil, _) : PRETTY_NAME, dict : PRETTY_NAME E_DICT
			) : PRETTY_NAME E_DICT = dict
	|   add_char(pcd as (names, Value ch, _), dict) = (
		if size ch = 1 andalso ord ch >= 128
		then	e_enter ch pcd dict
		else (	diag_line("*** WARNING 5016 *** Invalid pretty character with keyword: "
				^ (PolyML.makestring names));
			dict)
	)
in
	output(std_out, "Adding " ^ (PolyML.makestring(length pnl)) ^ " new symbols\n");
	name_dict := fold add_name pnl (!name_dict);
	char_dict := fold add_char pnl (!char_dict)
end);
=TEX

=SML
fun ‚find_name· (name:string) : PRETTY_NAME OPT = (
	e_lookup name (!name_dict)
);

fun ‚find_char· (char:string) : PRETTY_NAME OPT = (
	e_lookup char (!char_dict)
)

end  (*  of local for add_new_symbols, find_name and find_char *);
=TEX

%********************************************************************

\subsection{Initial Set of Symbols}

The basic set of symbols are those available for all languages,
including Standard~ML, they are the Greek letters, the mathematical
symbols, and a few specials used in forming identifiers.

=SML
local (* for raw_symbol_names *)

val ‚raw_symbol_names· : PRETTY_NAME list = [
=TEX

The first group of symbols are for the Greek letters.  Note, there are
problems\footnote{To be resolved  --- they stem from the different
purposes that the characters are used for, and the different sorts of
processing that is done.  Ideally the $string\;OPT$ column should
contain something that prints like the graphics screen image of the
character and which has the correct single character in the Standard~ML
that is produced.  Correct ML has been achieved by careful use of the
{\tt screenfile} and its associated programs.  The changes needed to
those programs to make the characters print properly here are
non-trivial --- the problem characters are those that are converted, by
the program {\tt doc2tex,} into complex commands, what is required here
is the conversion into something that prints like the graphics screen
image of the character.} displaying some of the pretty characters
here.


{\ftlinepenalty=9999
=SMLLITERAL
	([	"Delta"],	Value "Ò",			Simple Singular),
	([	"Gamma"],	Nil,				Simple Affable),
	([	"Lambda"],	Nil,				Simple Affable),
	([	"Omega"],	Nil,				Simple Affable),
	([	"Phi"],		Nil,				Simple Affable),
	([	"Pi"],		Nil,				Simple Affable),
	([	"Psi"],		Nil,				Simple Affable),
	([	"Sigma"],	Nil,				Simple Affable),
	([	"Theta"],	Nil,				Simple Affable),
	([	"Upsilon"],	Nil,				Simple Affable),
	([	"Xi"],		Value "Ú",			Simple Singular),
	([	"alpha"],	Nil,				Simple Affable),
	([	"beta"],	Nil,				Simple Affable),
	([	"chi"],		Nil,				Simple Affable),
	([	"delta"],	Nil,				Simple Affable),
	([	"epsilon"],	Nil,				Simple Affable),
	([	"eta"],		Nil,				Simple Affable),
	([	"gamma"],	Nil,				Simple Affable),
	([	"iota"],		Nil,				Simple Affable),
	([	"kappa"],	Nil,				Simple Affable),
	([	"fn",
		"lambda"],	Value "ç",			Simple Singular),
	([	"mu"],		Value "á",			Simple Singular),
	([	"nu"],		Nil,				Simple Affable),
	([	"omega"],	Nil,				Simple Affable),
	([	"phi"],		Nil,				Simple Affable),
	([	"pi"],		Nil,				Simple Affable),
	([	"psi"],		Nil,				Simple Affable),
	([	"rho"],		Nil,				Simple Affable),
	([	"sigma"],	Nil,				Simple Affable),
	([	"tau"],		Nil,				Simple Affable),
	([	"theta"],	Value "≠",			Simple Singular),
	([	"upsilon"],	Nil,				Simple Affable),
	([	"xi"],		Nil,				Simple Affable),
	([	"zeta"],	Nil,				Simple Affable),
=TEX
}

Maths symbols.  Note these first few which have non alphanumeric
entries.  They are specially treated in the percent name gathering
routines.

{\ftlinepenalty=9999
=SMLLITERAL
	([	"=>",
		"spot"],	Value "é",			Separator),
	([	"and"],		Value "Ä",			Simple Singular),
	([	"bagunion"],	Value "ﬁ",			Simple Singular),
	([	"bigcolon"],	Value "∫",			Simple Singular),
	([	"bij"],		Value "Ï",			Simple Singular),
	([	"bottom"],	Value "¥",			Simple Singular),
	([	"cat"],		Value "µ",			Simple Singular),
	([	"dcat"],	Value "√",			Simple Singular),
	([	"def"],		Value "î",			Simple Singular),
	([	"dintersect"],	Value "¢",			Simple Singular),
	([	"dres"],	Value "ö",			Simple Singular),
	([	"dsub"],	Value "õ",			Simple Singular),
	([	"dunion"],	Value "£",			Simple Singular),
	([	"emptyset"],	Value "§",			Simple Singular),
	([	"equiv"],	Value "Ç",			Simple Singular),
	([	"exists"],	Value "Ñ",			Simple Singular),
	([	"fcompose"],	Value "Ø",			Simple Singular),
	([	"ffun"],	Value "ú",			Simple Singular),
	([	"filter"],	Value "¡",			Simple Singular),
	([	"finj"],		Value "",			Simple Singular),
	([	"forall"],	Value "É",			Simple Singular),
	([	"fset"],		Value "í",			Simple Singular),
	([	"fun"],		Value "ã",			Simple Singular),
	([	"geq"],		Value "ü",			Simple Singular),
	([	"implies"],	Value "ä",			Simple Singular),
	([	"inj"],		Value "è",			Simple Singular),
	([	"int"],		Value "Ì",			Simple Singular),
	([	"intersect"],	Value "†",			Simple Singular),
	([	"lbag"],		Value "[[",			Simple Singular),
	([	"leq"],		Value "û",			Simple Singular),
	([	"lfree"],	Value "ææ",		Simple Singular),
	([	"lrelimg"],	Value "—",			Simple Singular),
	([	"lseq"],		Value "æ",			Simple Singular),
	([	"map"],	Value "ó",			Simple Singular),
	([	"mem"],	Value "ù",			Simple Singular),
	([	"nat"],		Value "Ü",			Simple Singular),
	([	"neq"],		Value "à",			Simple Singular),
	([	"not"],		Value "å",			Simple Singular),
	([	"notmem"],	Value "ì",			Simple Singular),
	([	"or"],		Value "Å",			Simple Singular),
	([	"overwrite"],	Value "ï",			Simple Singular),
	([	"pfun"],	Value "ñ",			Simple Singular),
	([	"pinj"],	Value "´",			Simple Singular),
	([	"pset"],	Value "ë",			Simple Singular),
	([	"psubset"],	Value "¶",			Simple Singular),
	([	"psurj"],	Value "Œ",			Simple Singular),
	([	"rbag"],	Value "]]",			Simple Singular),
	([	"rel"],		Value "ê",			Simple Singular),
	([	"rfree"],	Value "øø",		Simple Singular),
	([	"rrelimg"],	Value "“",			Simple Singular),
	([	"rres"],		Value "ô",			Simple Singular),
	([	"rseq"],	Value "ø",			Simple Singular),
	([	"rsub"],	Value "ò",			Simple Singular),
	([	"subset"],	Value "•",			Simple Singular),
	([	"subtract"],	Value "ƒ",			Simple Singular),
	([	"surj"],	Value "⁄",			Simple Singular),
	([	"thm"],		Value "Ö",			Simple Singular),
	([	"union"],	Value "°",			Simple Singular),
	([	"x"],		Value "â",			Simple Singular),
=TEX
}
Several symbols are provided for use with identifiers.

Four new characters are created which have significant processing with
respect to the way identifiers are formed.  Temporarily they will be
used as follows, following the style used in~\cite{DS/FMU/IED/DEF002}
to show the graphic, printed and ASCII forms of characters.

\begin{center}
\begin{tabular}[t]{llll}
Purpose&Graphic&Printed&ASCII\\[1ex]
Superscripts&$\sp+$&¬&{\tt\%up}\\
Subscripts&$\sb 0$&„&{\tt\%down}\\
\LaTeX\ inclusion&$\sb c$&∏&{\tt\%latex}\\
Negation&${\rlap{$\times$}\hbox{$\,\times$}}$&™&{\tt\%negate}
\end{tabular}
\end{center}

=SMLLITERAL
	([	"latex"],	Value "∏",			Simple Affable),
	([	"negate"],	Value "™",			Simple Affable),
	([	"down"],	Value "„",			Simple Affable),
	([	"up"],		Value "¬",			Simple Affable),

	([	"cal"],		Nil,				Simple Affable),
	([	"SX"],		Value "‚",			Ignore),
	([	"EX"],		Value "·",			Ignore),
=TEX

Several symbols are reserved, some for the use of the Z notation.  These are
included here for completeness, they will eventually be transferred to a
section of this or another document where Z is properly treated.

=SMLLITERAL
	([	"SFT"],	Value "Û",			Invalid),
	([	"SML"],	Value "Â",			Invalid),
	([	"SR1"],	Value "\\StartRuleOne",	Invalid),
	([	"SR2"],	Value "\\StartRuleTwo",	Invalid),
	([	"SZ"],		Value "Ë",			Invalid),
	([	"SZA"],	Value "Í",			Invalid),
	([	"SZC"],	Value "Î",			Invalid),
	([	"SZS"],	Value "È",			Invalid),
	([	"EML",
		"EFT",
		"EZ"],		Value "Ê",			Invalid),
	([	"ER"],		Value "\\EndRule",		Invalid)
]
=TEX

Add the symbols into the dictionary.

=SML
in (* local for raw_symbol_names *)

val _ = add_new_symbols raw_symbol_names;

end (* of local for raw_symbol_names *);
end (* of structure PrettyNames *);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{READER WRITER}
\label{ReaderWriter}

The task of the reader and writer is to read text presented to the
system, determining which parts are Standard~ML and which are in
an embedded language such as HOL.
Both may include pretty characters and keywords denoting pretty
characters or other symbols.  The Standard~ML text is modified
according to the nature of the pretty characters.

The basis of the reader and writer is a recursive decent parser that
understands the structure of both Standard~ML and HOL.  At first sight
this seems overkill, but it is required so that anti quotations of
Standard~ML within HOL can be properly delimited, which means that
Standard~ML round braces be properly understood.  Both Standard~ML and
HOL may include any character within string literals and comments, thus
the reader must understand a considerable part of both languages.

The rules for the code of the recursive decent parser are as follows.
The main recursive function take as an argument the characters parsed
and processed already, i.e., the characters to the left of the item to
be matched by the called routine.  The most recently read character is
the first character of the item handled by the called routine.  This
character is passed as an argument to some routines.  A routine is only
called when it is appropriate.  When called the routine must read all
the characters that are part of the input item it handles.  If the
parse is successful it returns with the LHS string plus the newly
matched characters.  If unsuccessful it calls $fail$ to report the
error.  On both types of exit the first unread character is the
character that does not belong to the text already parsed.

For efficiency reasons the characters parsed and processed already are
held as a list of strings with the most recently parsed item at the
head of the list.  A first attempt at the type of this argument would
be a single string with text added to the right, however, string
concatenation is thought to be inefficient.

%********************************************************************

\subsection{Recursive Descent Parser}

%--------------------------------------------------------------------

\subsubsection{Reader Environment}
\label{ReaderEnvironment}

Routines are required for reading characters and giving a one character
lookahead.  These routines considered to be the ``readers
environment''.

At all stages during parsing the work can be seen as follows.  Of the
input text there is the ``portion already read'', the ``current
character'' and the ``unread portion''.  The ``portion already read''
will have been recorded (after some modifications) in $prev$ which is
one of the arguments of many of the parsing routines.  The
``current-character'' will be under processing by one of the recursive
descent functions.  The first character of the ``unread-portion'' is
called the next character.  At may stages there will be no current
character, it will have been fully processed and added into the
``portion already read''.

Function $advance$ assumes that the caller has properly dealt with the
current character, it reads a character and returns its value.
Function $skip_and_look_at_next$ is similar, but does not return the
value of the new current character.  Function $look_at_next$ does a one
character lookahead and returns the value of that next character.

After end of file all routines return the character control-D, decimal
code~4, whenever called.  For resilience of the code during testing the
routines signal a fault if they return an excessive number of control-D
characters, this is shown in section~\ref{ExcessiveControlDs}.

The routines are placed in a record which is passed through the various
routines of the lexical analyser.  The record, with the Standard~ML
type name $READER_ENV$, is declared in section~\ref{DeclareReaderEnv}.

Associated with the reader functions is the exception $EndOfInput$
which is raised when the parser has read the end of the file and
has passed the end of file character at least once to the \Compiler.
Raising this exception signifies that nothing more can usefully be
done with the current input stream.

=SML
exception ‚EndOfInput·;
=TEX

%--------------------------------------------------------------------

\subsubsection{Comments}

Comments are skipped over.  Comments are sequences of characters within
which the comment braces `{\tt (*}' and `{\tt *)}' are properly
balanced.  This routine is entered when the opening round bracket of
the comment has been read, the opening asterisk is the first unread
character.

=SML
fun ‚skip_comment· (R:READER_ENV) : unit = (
let
	val skip_and_read = #skip_and_look_at_next R;
	val skip = #advance R;
	fun aux (depth:int) : unit = (
		case skip_and_read ()
		of "(" =>	if skip_and_read () = "*"
				then	aux (depth+1)
				else	aux depth
		|  "*" =>	if skip_and_read () = ")"
				then
					if depth = 1
					then	(skip (); ())
					else	aux (depth-1)
				else	aux depth
		|  "\^D" =>	fail "skip_comment" 5001 nil
		|  _   =>	aux depth
	)
in
	aux 1
end);
=TEX

%--------------------------------------------------------------------

\subsubsection{Formatting Characters}

Formatting characters are skipped over.  The string argument $next$
here is the first unread character of the input text.

=SML
fun ‚skip_format· (get : READER_ENV -> string list -> string list)
		(R:READER_ENV) (prev:string list) (next:string) : string list = (
	if		next = " "
		orelse	next = "\n"
		orelse	next = "\t"
		orelse	next = "\^L"
	then	skip_format get R prev (#skip_and_look_at_next R ())
	else	get R (" " :: prev)
);
=TEX

%--------------------------------------------------------------------

\subsubsection{Strings}

Strings start and finish with a `~{\tt"}~' and contain a
mixture of characters and escape sequences.  Some escape sequences are
used in formatting the source text, others denote particular
characters.  Most of the understanding and validating of strings, and
in particular the escape sequences, can be left to the \Compiler, here
the concern is finding the end of the string, and converting pretty
characters into a form acceptable to the \Compiler.  In finding the end
of the string the escape sequence that allows strings to be laid out
neatly must be recognised.  The strings \verb*|"ab\"c\   \de\\f"| and
\verb*|"ab\"cde\\f"| are the same, as are the strings \verb*|"ab\  \"|
and \verb*|"ab"|, they only differ by the use of the formatting
characters.  Note the \verb*|\"| in the second example which must not
be interpreted as an escaped double quote.

Within a string an escape followed by one of more formatting characters
and another escape may be ignored.  Non formatting characters are not
allowed.  The full set of allowed characters is implementation
dependent, but includes, quoting from \cite[section~2.1]{Milner90},
``$\ldots$ at least space, tab, newline and formfeed.''  These four
characters will be skipped by the lexical analyser here, any other
characters will be passed on to the \Compiler, as if they were escaped
formatting characters.

Local function $skip_format_chars$ is first entered with a formatting
character as the first unread character, it reads characters until a
closing escape character which it reads leaving the next character as
the first character after the whole escape sequence.  Any other
characters found between the escape characters are retained for
processing by the \Compiler which may consider some characters above the
minimum set of four as formatting characters.

On entry to $handle_escape$ the opening escape character has been read,
but not the character being escaped.

=SML
local (* for get_string *)

fun ‚handle_escape· (R:READER_ENV) : string = (
let
	fun skip_format_chars (prev:string) : string = (
		case #skip_and_look_at_next R ()
		of " "		=> skip_format_chars prev
		|  "\t"		=> skip_format_chars prev
		|  "\n"		=> skip_format_chars prev
		|  "\^L"	=> skip_format_chars prev
		|  "\\"		=> (#advance R (); prev)
		|  "\^D"	=> prev
		|  s		=> skip_format_chars (prev ^ s)
	);

	val next = #look_at_next R ()
in
	if next = " " orelse next = "\t" orelse next = "\n" orelse next = "\^L"
	then
		case skip_format_chars ""
		of ""	=> ""
		| x	=> ("\\ " ^ x ^ " \\")
	else
		("\\" ^ (#advance R ()))
end);
=TEX

Most of the work of gathering strings is just reading and concatenating
the characters, they are of five classes: end of string, end of file,
pretty, escaped
and others.  Function $string_body$ is first called with
the first character of the string being the first unread character.

=SML
fun ‚string_body· (R:READER_ENV) prev = (
	case #look_at_next R ()
	of "\"" (*"*)	=> ((#advance R ()) :: prev)
	|  "\^D"	=> fail "string_body" 5007 nil
	|  _		=>
		let	val next = #advance R ();
			val str =
				if ord next > 127
				then
					"\\" ^ (convert3(ord next))
				else if next = "\\"
				then
					handle_escape R
				else
					next
		in
			string_body R (str::prev)
		end
)

in (* local for get_string *)
=TEX

The result from $string_body$ is a sequence of mainly one-character
strings, it seems appropriate to convert it to one long string at this
stage rather than retaining the space overhead until the whole input
text is formed.  Function $get_string$ is called with the opening
string quote having been read.

=SML
fun ‚get_string· (R:READER_ENV) prev = (
	[implode(rev(string_body R ["\""]))] @ prev (*"*)
);

end (* of local for get_string *);
=TEX

%--------------------------------------------------------------------

\subsubsection{Percent Keywords}

The characters of a keyword that starts with a percent `{\tt\%}'
character are assembled here, and the keyword is looked up against the
list of known keywords.

This routine is a little different to the others in that it needs to do
a multi-character look-ahead to gather the whole name to know how to
treat the name and the preceding `{\tt\%}' character, whereas the rest
of the system only needs one-character look-ahead.  The problem is that
the names are several characters long; in the ML we require that all or
none of the alphanumerics after a `{\tt\%}' are part of the name.  To
overcome this the function will return a pair of values.  The first
element will give the characters read, but without any `{\tt\%}'
characters.  The second entry will be the additional information found
from looking up the keyword, or $Nil$ for an unknown keyword.

On entry a `{\tt\%}' is the next character.  Read the the name which is
of two possible types:  most are a non-empty string of alphanumerics, a
few are non-alphanumeric.

=SML
fun ‚get_percent_name· (R:READER_ENV)
		: (string * PrettyNames.PRETTY_NAME OPT * bool) = (
	let
		fun is_alphanumeric ch = (
				(ch >= "a" andalso ch <= "z")
			orelse	(ch >= "A" andalso ch <= "Z")
			orelse	(ch >= "0" andalso ch <= "9")
		);

		fun collect_alphanumeric next = (
			if is_alphanumeric next
			then	next ^ (collect_alphanumeric(#skip_and_look_at_next R ()))
			else	""
		);

		val next = #skip_and_look_at_next R ();
	in
		case		(* (is a % keyword, keyword read, is alphanumeric) *)
			case next
			of "<"	=>	(#advance R (); (true, "<", false))	(* HOL start *)
			|  ">"	=>	(#advance R (); (true, ">", false))	(* HOL end *)
			|  "="	=>	(	case #skip_and_look_at_next R ()
						of ">"	=> (#advance R (); (true, "=>", false))
						| _	=> (false, "=", false))
			|  _	=>	(	case collect_alphanumeric next
						of ""	=> (false, "", false)
						| n	=> (true, n, true))
		of	(false, n, _)		=> (n, Nil, false)
		|	(true, n, is_alpha)	=> (n, PrettyNames.find_name n, is_alpha)
	end
);
=TEX

%--------------------------------------------------------------------

\subsubsection{Bracketed Text}

Gathering bracketed text is required in many languages.  The basic idea
of these routines is to gather some bracketed text.  The value returned
comprises both brackets plus all the text they enclose, or if the
opening bracket was a start-of-comment then return nothing (i.e., an
empty list).

Text enclosed by round brackets may be comment or nested Standard~ML text.
The opening round bracket has been read, so the next character indicates
how to process the bracket.

Gathering nested text enclosed by braces (i.e., by the characters
`\verb|( ) { } [ ]|') uses a general routine for bracketed text.

=SML
fun ‚get_round_braces· (get : READER_ENV -> string list -> string list)
		(R:READER_ENV) (prev:string list) : string list = (
	if #look_at_next R () = "*"
	then
		(skip_comment R; prev)
	else
		get_braces get R prev "(" ")"
)

and ‚get_box_braces· (get : READER_ENV -> string list -> string list)
		(R:READER_ENV) (prev:string list) : string list = (
	get_braces get R prev "[" "]"
)

and ‚get_curly_braces· (get : READER_ENV -> string list -> string list)
		(R:READER_ENV) (prev:string list) : string list = (
	get_braces get R prev "{" "}"
)
=TEX

In the general routine for gathering bracketed text the next character
is the first character within the bracketed expression.  The opening
bracket for the expression is $first$, the closing bracket should be
$term$.  This routine differs from the general rules for the recursive
decent in that it does not pass $prev$ to the routines it calls, this
is needed to allow the detection of terminating braces, when the call
of $get$ will return an empty list.

Note that the fail 5005 might be replaced with simply returning the
unmatched character as if it were the required terminator, and leaving
the error reporting to the \Compiler.

=SML
and ‚get_braces· (get : READER_ENV -> string list -> string list)
		(R:READER_ENV) (prev1:string list) (first:string) (term:string) : string list = (
let
	fun more prev2 = (
		case get R nil
		of nil =>	let
					val next = #look_at_next R ()
				in
					if next = term
					then	(#advance R ()) :: prev2
					else if next = "\^D"
					then	"\^D" :: prev2
					else	fail "get_braces" 5005 [
							fn () => next, fn () => first]
				end
		| ["\^D"] =>	(#advance R ()) :: prev2
		| new =>	more(new @ prev2)
	)
in
	(more [first]) @ prev1
end);
=TEX

%--------------------------------------------------------------------

\subsubsection{Main Parser Function}

Function $get_ML_any$ is the main parser function.  It reads upto the
first semi colon `{\tt;}' or closing bracket and then returns the text
read.  A semi colon will be read and added to the returned text, a
closing bracket is left unread for the calling routine.  The syntax
error where too many closing bracket are presented must be resolved by
the outermost routine that calls this function.  The
routines that handle text which may include semi colons, essentially
those dealing with brackets, should repeatedly call $get_ML_any$ until
the appropriate end of text is found.

{\ftlinepenalty=9999
=SML
fun ‚get_ML_any· (R:READER_ENV) (prev:string list) : string list= (
let
	open PrettyNames;

	fun	do_keyword(names,_,Simple _)	= get_ML_any R ("QQ" ^ (hd names) :: prev)
	|	do_keyword(_,_,Starting(str, proc))	= proc R (str :: prev)
	|	do_keyword(_,_,Middle str)		= get_ML_any R (str :: prev)
	|	do_keyword(_,_,Ending str)		= str :: prev
	|	do_keyword(_,_,Ignore)		= get_ML_any R prev
	|	do_keyword(names,_,Separator)	= get_ML_any R (" " ^ (hd names) ^ " ":: prev)
	|	do_keyword(names,_,Invalid)		= fail "get_ML_any" 5002
								[fn () => hd names];

	val next = #look_at_next R ()
in
	case next
	of "("	=>	(#advance R (); get_ML_any R (get_round_braces get_ML_any R prev))
	|  ")"	=>	prev
	|  "["	=>	(#advance R (); get_ML_any R (get_box_braces get_ML_any R prev))
	|  "]"	=>	prev
	|  "{"	=>	(#advance R (); get_ML_any R (get_curly_braces get_ML_any R prev))
	|  "}"	=>	prev
	|  ";"	=>	(#advance R ()) :: prev
	|  "\""	=>	(#advance R (); get_string R prev) (*"*)
	|  "\t"	=>	skip_format get_ML_any R prev next
	|  "\n"	=>	skip_format get_ML_any R prev next
	|  " "	=>	skip_format get_ML_any R prev next
	|  "\^L" =>	skip_format get_ML_any R prev next
	|  "\^D" =>	prev
	|  "%"	=>	(	case get_percent_name R
				of (name, Value info, _)
					=> do_keyword info
				|  (n, Nil, false)
					=> get_ML_any R (("%" ^ n) :: prev)
				|  (n, Nil, true)
					=> fail "get_ML_any" 5003 [fn () => n]
			)
	|  "Q"	=>	(#advance R (); get_ML_any R ("QQQ" :: prev))
	|  _	=>	let
				val ch = #advance R ();
				val ord_ch = ord ch
			in
				if ord_ch > 127
				then	case find_char ch
					of Value info
						=> do_keyword info
					|  Nil	=> fail "get_ML_any" 5004
						[fn () => next,
						fn () => PolyML.makestring(ord_ch)]
				else	get_ML_any R (ch :: prev)
			end
end)
=TEX
}

%********************************************************************

\subsection{Outermost Levels of Reader Writer}

This routine is called by $PolyML.compiler$ to read the next part of
the input text.  It adopts a simple approach to text that $get_ML_any$
cannot parse properly, it passes the first character that did not parse
on to its caller.  Consider an unmatched closing bracket which
$get_ML_any$ cannot parse and so returns an empty string, the bracket
is read here and returned for the caller to deal with, probably by
issuing an error message.

Text that parsed successfully here must be converted in the correct
order into a single string.

=SML
local (* for get_ML_outermost *)

val ‚sent_eof· = ref false;

fun ‚get_ML· (R:READER_ENV) = (
	case get_ML_any R nil
	of nil =>	(	case #advance R ()
				of "\^D" =>	if !sent_eof
						then nil
						else (sent_eof := true; ["\^D"])
				| ch =>		(sent_eof := false; [ch]))
	| "\^D"::nil =>	if !sent_eof
				then	nil
				else	(sent_eof := true; [#advance R ()])
	| x =>			(sent_eof := false; rev x)
)

in (* local for get_ML_outermost *)

fun ‚get_ML_outermost· (R:READER_ENV) () : string = (
	let
		val text_read_list = get_ML R;
		val text_read = implode text_read_list
	in
		logit_list	RWphrases_read	"get_ML_outermost" text_read_list;
		logit		RWtext_read		"get_ML_outermost" text_read;
		if text_read = ""
		then	raise EndOfInput
		else	text_read
	end
)

end (* of local for get_ML_outermost *);
=TEX

%********************************************************************

\subsection{Completion of Embedding Interface}

Some of the declarations above are intended for use when embedding
other languages.  The remaining declarations within structure
$ReaderWriter$ are concerned with the main user interface of the reader
writer.  The support structure is opened here so that its contents are
readily available for the remainder of the basic reader writer, note
that the signature constraint on the structure $ReaderWriter$ will keep
the supporting declarations within their own structure.

=SML
end (* of structure ReaderWriterSupport *);

open ReaderWriterSupport;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{COMPILER INTERFACE}

%********************************************************************

\subsection{PolyML Interface} \label{PolyML.compiler.example}

The routine $PolyML.compiler$ is the interface to the
read-evaluate-print loop of the PolyML system, it is a \Compiler{}
and has the signature:

ÛSML example
PolyML.compiler : (unit -> string) * (string -> unit) -> unit -> unit
Ê

Calling this routine invokes the read-evaluate-print loop to process
one outermost level item (e.g., a declaration or an expression) which
is called a {\em topdec\/} in \cite{Milner90}.  When a {\em topdec\/}
is fully processed (i.e., a response is printed) the routine exits.
The first argument is called whenever the \Compiler{} requires more
input, the routine should return a string containing the text read.
The second argument is an output function, invoked by the \Compiler{}
for output messages.  The third argument is provided to delay execution
of the read-evaluate-print loop.

Routine $PolyML.compiler$ is recursive in the sense that a file
included by the above example routine may include other files by
calling $usefile$.  Whilst reading the innermost included file a stack
trace would show the following items:

\begin{itemize}

	\item Normal read-evaluate-print loop.
	\item Call of $PolyML.compiler$
	\item Call of $use_file_loop$
	\item Call of $usefile$.
	\item Normal read-evaluate-print loop.
	\item Call of $PolyML.compiler$
	\item Call of $use_file_loop$
	\item Call of $usefile$.
	\item Normal read-evaluate-print loop.
	\item Outermost levels of PolyML system.

\end{itemize}

End of file is indicated to the $PolyML.compiler$ with the control-D
character, this is not actually read from the file, it must be
generated by the reader function.  Observation of $PolyML.compiler$
suggests that the control-D character forces the \Compiler{} to parse
the preceding text as a complete {\em topdec,} but otherwise ignore the
character.  After fully processing a {\em topdec\/} the
$PolyML.compiler$ returns or raises an exception, just as it does for
any other {\em topdec.} As $PolyML.compiler$ is called in a loop to
allow for many {\em topdec\/}s the end of file processing must break
out of the loop, but first it should cause the parsing of any text just
read, this allows the \Compiler{} to produce error messages for files
which have incomplete {\em topdec\/}s, e.g., a file that ends with
`{\tt let val x}' or a string without a closing double quote.

As an example, a simple file inclusion facility could be written
as follows.

ÛSML example
fun usefile (file:string) : unit = (
let
	val cur_in = open_in file;
	val eof_char_sent = ref false;
	exception E_eof;

	fun reader () : string = (
	let
		val ch = input(cur_in, 1)
	in
		if ch = ""
		then	if	!eof_char_sent
			then	raise E_eof
			else	(eof_char_sent := true; "\^D")
		else	ch
	end);

	fun writer (s : string) : unit = output(std_out, s);

	fun use_file_loop () = (
		if (PolyML.compiler (reader, writer) (); true)
					handle E_eof => false
		then	use_file_loop ()
		else	()
	)
in
	use_file_loop ()
		handle E => (
			output(std_out,
				"Exception, abandoning file "
				^ file ^ "\n");
			close_in cur_in;
			raise E)
	;
	(* Only reach here after reading end-of-file *)
	close_in cur_in
end);
Ê

The interface to ICL HOL provided by this document uses the
$PolyML.compiler$ interface in a style based on the example above, the
capabilities for handling pretty characters and producing prompts for
interactive input are provided by using more complex $reader$ and
$writer$ functions.

%********************************************************************

\subsection{ICL HOL Interface}
\label{IclHolInterface}

Four input sources are required for ICL HOL.

\begin{enumerate}

\item The console for normal interactive use.

\item Piped input for non-interactive use.

\item Included files.

\item Strings built by Standard~ML functions.

\end{enumerate}

The first two are alternatives, either the system is being run
interactively or input is being piped (in the UNIX sense) into the
system.  Both of these modes may request input of further Standard~ML
and HOL from another file.  The final input type allows Standard~ML
functions to create a string to be interpreted as Standard~ML or HOL
text.

\bigskip

To present these interfaces three main routines are identified.

\begin{description}

\item[$useterminal : unit -> unit$ ] which is the outermost routine of
	the lexical part of ICL HOL.  This routine is invoked at system
	startup and should remain in control at all times.  This
	routine is the primary interface to the ICL HOL system, it
	should replace the default outermost routine of PolyML.  Some
	investigation and experimentation\footnote{To be done.} is
	required to find a way of doing this.  Having this as the
	outermost routine means that it is started automatically when
	PolyML is started, also that breaking in with a control-C and
	entering ``{\tt f}'' (i.e., raising an exception to exit from
	the active Standard~ML and return to the top level) reverts to
	this routine.

\item[$use_file : string -> unit$ ] causes the named file to be read in
	a manner analogous to the routine $PolyML.use : string ->
	unit$ of PolyML.  The text read will be interpreted as
	Standard~ML and HOL the same as it had been entered at the
	outermost level.

\item[$use_string : string -> unit$ ] causes the contents of the string
	to be interpreted as Standard~ML and HOL the same as it had
	been entered at the outermost level or read from a file.

\end{description}

%********************************************************************

\subsection{Introduction To Reader Functions}

From experimentation with PolyML it seems that text in an included file
must be complete, i.e., capable of interpretation as a top level item.
Unclosed bracketing forms cause error messages.  For example,
unclosed comments, brackets, strings, {\tt let}-clauses and {\tt
local}-clauses all provoke an error message.  This behaviour should be
followed by the routines presented in this document.

The three routines named above ($useterminal$, $usefile$ and $usestring$)
will be written much as in the example in
section~\ref{PolyML.compiler.example}, but with different reader and
writer functions.  Each function will set up its input stream, and then
invoke $PolyML.compiler$ naming the appropriate reader and writer.  All
of the reader functions will call $get_ML_outermost$ to read some text,
this text will be returned to the \Compiler.  The reader functions must
set up the input streams so that the various routines in structure $R$
above are provided.

There are three areas that add complexity to the reading functions.
First, keeping track of line and character numbers within the source
text, to provide information for error messages.  Second, providing a
mechanism to track faults in the parser where it loops looking at a
character without actually reading it --- for example (an actual fault
found in early testing) a pretty character was found by $get_ML_any$
but the character was not actually read (i.e., $\#advance\;R\;();$ was
not called) and so on the next call of $get_ML_any$ the same character
was found, and again, and again.  Third, providing diagnostic output
about the characters read.

\label{ExcessiveControlDs}
To stop the reader looping without reading new characters a counter is
maintained of the number of times each character is passed to the
parsing functions, a failure is reported when this exceeds a threshold
value.  This threshold must be at least 3 since a character may be
examined by $skip_format$ then looked at by $get_ML_any$ and then
advanced over.  Longer sequences may be possible but have not (yet!)
been identified.

=SML
val max_copies_of_char_sent = 30;
=TEX

%********************************************************************

\subsection{Writer Function}

A common writer function is used by all three reader writers, its most
complex tasks are to recognise ASCII keywords and convert them to their
equivalent pretty characters and to recognise the numeric values of
pretty characters in strings and print the correct character.  The
conversions are as follows.  A double ``{\tt Q}'' is followed by the
characters of a keyword.  If a decoding is available then replace the
whole keyword with the corresponding pretty character.  If no pretty
character is available then replace the leading ``{\tt QQ}'' with a
single ``{\tt\%}'' character.  To preserve ``{\tt Q}''s in the original
text the string ``{\tt QQQ}'' is considered to be the keyword whose
representation is a single ``{\tt Q}''.

On occasions no conversions should be performed by the writer so a
control flag is provided.

=SML
val writer_convert = ref true;
val _ =
new_flag {name = "‚writer_convert·",  control=writer_convert, default=fn () => true};
=TEX

From observation of $PolyML.compiler$ it seems that no identifier or
string is split over two or more calls of the writer function,
therefore no memory is required\footnote{This may need to be
reconsidered after further experience of the use of $PolyML.compiler$
is obtained.} between invocations of the writer to deal with partial
identifiers or partial strings.  Additional work will be
needed\footnote{To be done.} to support HOL text output via the
writer.

{\ftlinepenalty=9999
=SML
fun ‚writer· (s : string) : unit = (
let
	fun get_kw (prev, nil) = (prev, nil)
	|   get_kw (prev, t as "Q"::"Q"::_) = (prev, t)
	|   get_kw (prev, h::t) = (
		if	(h >= "A" andalso h <= "Z")
		orelse	(h >= "a" andalso h <= "z")
		orelse	(h >= "0" andalso h <= "9")
		then	get_kw(prev ^ h, t)
		else	(prev, h::t));

	fun aux nil = []
	|   aux ("Q"::"Q"::"Q"::t) = "Q"::(aux t)
	|   aux ("Q"::"Q"::rest) = (
		case	get_kw ("", rest)
		of ("", t) =>	fail "writer" 5008 [fn () => implode("Q"::"Q"::rest)]
		|  (kw, t) =>	(	case	PrettyNames.find_name kw
					of Value(_, Value ch, _)	=> ch
					| _				=> "%" ^ kw
				) :: (aux t))
	|   aux ((h as "\"")::t) = h::(aux_str t)  (*"*)
	|   aux (h::t) = h::(aux t)

	and aux_str nil = []
	|   aux_str ("\""::t) = "\""::(aux t)
	|   aux_str ("\\"::d1::d2::d3::t) = (
		if	(d1 >= "0" andalso d1 <= "9")
		andalso	(d2 >= "0" andalso d2 <= "9")
		andalso	(d3 >= "0" andalso d3 <= "9")
		then
			let
				val dd1 = ord d1 - ord_0;
				val dd2 = ord d2 - ord_0;
				val dd3 = ord d3 - ord_0;
				val ch = (dd1 * 10 + dd2) * 10 + dd3
			in
				if ch > 127
				then	(chr ch) :: (aux_str t)
				else	"\\"::d1::(aux_str(d2::d3::t))
			end
		else
			"\\"::d1::(aux_str(d2::d3::t)))
	|   aux_str(h::t) = h::(aux_str t);

	val chars = logit RWchars_written "writer" s
in
	output(std_out,	if	!writer_convert
				then	implode(aux(explode chars))
				else	chars)
end);
=TEX
}

%********************************************************************

\subsection{Reading From a File -- {\tt usefile}}

{\ftlinepenalty=9999
=SML
fun ‚usefile· (file:string) : unit = (
let
	val cur_in = open_in file;
	val line_number = ref 1;
	val copies_of_char_sent = ref 0;
	exception Read_too_often of string;

	fun ‚f_advance· () : string = (
		case input(cur_in, 1)
		of "" =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often "\\004"
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "f_advance              " "\^D")
		|  "\n" => (	copies_of_char_sent := 0;
				line_number := !line_number + 1 ;
				logit RWchars_read "f_advance              " "\n")
		|  ch => (	copies_of_char_sent := 0;
				logit RWchars_read "f_advance              " ch)
	);

	fun ‚f_look_at_next· () = (
		case lookahead cur_in
		of "" =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often "\\004"
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "f_look_at_next         " "\^D")
		|  ch =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often ch
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "f_look_at_next         " ch)
	);

	fun ‚f_skip_and_look_at_next· () = (
		f_advance();
		logit RWchars_read "f_skip_and_look_at_next"
			(case lookahead cur_in
			of "" =>	"\^D"
			|  ch =>	ch)
	);

	val reader = {	advance = f_advance,
			look_at_next = f_look_at_next,
			skip_and_look_at_next = f_skip_and_look_at_next} : READER_ENV;

	fun ‚use_file_loop· () = (
		if (PolyML.compiler (get_ML_outermost reader, writer) (); true)
					handle EndOfInput => false
		then	use_file_loop ()
		else	()
	)
in
	use_file_loop ()
		handle Read_too_often ch => (
			output(std_out,
				"Character \"" ^ ch ^ "\" read too often, abandoning file "
				^ file ^ " at line "
				^ (PolyML.makestring (!line_number)) ^ "\n");
			close_in cur_in;
			raise Read_too_often ch)
		| E => (
			output(std_out,
				"Exception++, abandoning file "
				^ file ^ " at line "
				^ (PolyML.makestring (!line_number)) ^ "\n");
			close_in cur_in;
			raise E)
	;
	(* Only reach here after reading end-of-file *)
	close_in cur_in
end);
=TEX
}

%********************************************************************


\subsection{Reading From a String -- {\tt usestring}}

{\ftlinepenalty=9999
=SML
fun ‚usestring· (str:string) : unit = (
let
	val cur_str = ref(explode str);
	val char_number = ref 1;
	val copies_of_char_sent = ref 0;
	exception Read_too_often of string;

	fun ‚s_advance· () : string = (
		case !cur_str
		of nil =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often "\\004"
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "s_advance              " "\^D")
		|  ch::t =>	(copies_of_char_sent := 0;
				char_number := !char_number + 1;
				cur_str := t;
				logit RWchars_read "s_advance              " ch)
	);

	fun ‚s_look_at_next· () = (
		case !cur_str
		of nil =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often "\\004"
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "s_look_at_next         " "\^D")
		|  ch::_ =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often ch
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "s_look_at_next         " ch)
	);

	fun ‚s_skip_and_look_at_next· () = (
		s_advance();
		logit RWchars_read "s_skip_and_look_at_next"
			(case !cur_str
			of nil =>	"\^D"
			|  ch::_ =>	ch)
	);

	val reader = {	advance = s_advance,
			look_at_next = s_look_at_next,
			skip_and_look_at_next = s_skip_and_look_at_next} : READER_ENV;

	fun ‚use_string_loop· () = (
		if (PolyML.compiler (get_ML_outermost reader, writer) (); true)
					handle EndOfInput => false
		then	use_string_loop ()
		else	()
	)
in
	use_string_loop ()
		handle Read_too_often ch => (
			output(std_out,
				"Character \"" ^ ch
				^ "\" read too often, abandoning string at character "
				^ (PolyML.makestring (!char_number)) ^ "\n");
			raise Read_too_often ch)
		| E => (
			output(std_out,
				"Exception++, abandoning string at character "
				^ (PolyML.makestring (!char_number)) ^ "\n");
			raise E)
	(* Only reach here after reading end-of-string *)
end);
=TEX
}

%********************************************************************

\subsection{Reading from a Terminal -- {\tt useterminal}}

=SML
fun ‚useterminal· () : unit = (
let
=TEX

Whilst reading from a terminal several points must be dealt with in
addition to those needed for the other two readers.

\begin{itemize}

\item Prompts are required when the system wants the user to enter some
	characters.  Input is line based, the operating system provides
	line editing and only passes the characters when an end-of-line
	character is typed.  Second and later lines of a {\em topdec\/}
	should have a different prompt to the first.  To distinguish
	this reader from the PolyML default reader the prompts have a
	colon `:' added.  A prompt is required when the previously read
	character is a new line or a control-X.

=SML
	val prompt1 = ":> ";
	val prompt2 = ":# ";

	val cur_prompt = ref prompt1;

	val console_last : string ref = ref "\n";

	fun issue_prompt() : unit = (
		if !console_last = "\n" orelse !console_last = "\^X"
		then	output(std_out, !cur_prompt)
		else	()
	);
=TEX

\item The control-X character is taken to mean break as soon as
	possible to the main prompt of this reader, ignoring any text
	typed and processed already.

=SML
	exception QuitTopDec;
=TEX

\item All exceptions should be fielded by the reader, they should be
	reported to standard output, then the next {\em topdec\/}
	solicited.

\item Counting of times a character is used should take place just as
	in the other readers, to reduce the chances of run-away
	recursion of the parsing routines.

=SML
	val copies_of_char_sent = ref 0;
	exception Read_too_often of string;
=TEX

\end{itemize}

All the reading of characters is handled by one routine which deals
with prompting as required.  The second-line of a {\em topdec\/} is
considered to have started only after a character other than a new line
has been read.

=SML
local (* for read_char and lookahead_char *)

	fun read_next_character () = (
		issue_prompt();

		let
			val last = 	case input(std_in, 1)
					of "" => "\^D"
					|  ch => ch
		in
			console_last := last;
			if last = "\^X"
			then	raise	QuitTopDec
			else if last <> "\n"
			then	(cur_prompt := prompt2; last)
			else	last
		end
	);
=TEX

Character lookahead is simulated here by actually reading a character,
and remembering it until it is read by the parser.  Routines to read and
lookahead must then examine this remembered value.  The lookahead just
returns the value whereas a read empties it.

=SML
	val ahead_char : string OPT ref = ref Nil;

in (* local for read_char and lookahead_char *)

	fun read_char () : string = (
		case !ahead_char
		of Nil =>	read_next_character()
		| Value ch =>	(ahead_char := Nil; ch)
	);

	fun lookahead_char () : string = (
		case !ahead_char
		of Nil =>	let	val ch = read_next_character()
				in	(ahead_char := Value ch; ch) end
		| Value ch =>	ch
	)
end (* of local for read_char and lookahead_char *)
=TEX

The functions passed in a $READER_ENV$ record are very similar\footnote{We
could take advantage of the routine $read_next_character$ to centralise
the character counting in a future release of this document.} to those
of the other readers apart from the end-of-file handling not being
needed.

=SML
	fun ‚t_advance· () : string = (
		case read_char ()
		of "\n" => (	copies_of_char_sent := 0;
				logit RWchars_read "t_advance              " "\n")
		|  ch => (	copies_of_char_sent := 0;
				logit RWchars_read "t_advance              " ch)
	);

	fun ‚t_look_at_next· () = (
	let
		val ch = lookahead_char()
	in
				if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often ch
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "t_look_at_next         " ch)
	end);

	fun ‚t_skip_and_look_at_next· () = (
		t_advance();
		logit RWchars_read "t_skip_and_look_at_next"
			(case lookahead_char()
			of "" =>	"\^D"
			|  ch =>	ch)
	);

	val reader = {	advance = t_advance,
			look_at_next = t_look_at_next,
			skip_and_look_at_next = t_skip_and_look_at_next} : READER_ENV;
=TEX

Most exceptions should be handled by the \Compiler{} loop which reports
them and then continues.  Exception $EndOfInput$ is
raised in response to end-of-file (control-D) characters being passed
to the parsing functions, the response is\footnote{Should probably also
	do a $PolyML.commit$ here to follow the practice of PolyML
	itself.  Unfortunately if we did then the first action on
	starting with such a database is to resume this function after
	the commit, which means that the quit is performed.  This leads
	to a PolyML database which quits immediately after it is
	started.  Some more investigation is required in this area.}
to call $PolyML.quit$.  Function $read_next_character$ deals with
control-X characters
locally by raising $QuitTopDec$ to indicate the users request to return
to the outer level of useterminal.  Exception $Read_too_often$ denotes
a coding fault in the processing of the users input.  Exception
$AbandonReaderWriter$ indicates the users desire to abandon this reader
writer package.  All other exceptions are just reported.  Note that in
many cases $PolyML.compiler$ will catch the exception, report it, and
raise an exception whose name is not available (presumably it is
declared local to the PolyML system).  This means that there needs to be
a check for abandoning in the ``others'' clause of the match for
exceptions below.

=SML
	fun ‚use_term_loop· () = (
		if (PolyML.compiler (get_ML_outermost reader, writer) (); true)
			handle EndOfInput => (diag_string 
					"End of input to useterminal.  Quit.";
				PolyML.quit(); false)
			| Fail x => (diag_string(
					"Exception++ Fail " ^ (PolyML.makestring x) ^ " raised");
				true)
			| Error x => (diag_string(
					"Exception++ Error " ^ (PolyML.makestring x) ^ " raised");
				true)
			| AbandonReaderWriter => (diag_string "Abandoning reader writer";
				false)
			| QuitTopDec => (diag_string
					"Control-X read, return to outer level of useterminal";
				true)
			| Read_too_often ch => (
				diag_string( "Character \"" ^ ch
					^ "\" read too often, abandoning current input");
				true)
			| E =>	if !abandoning
				then (	diag_string "Abandoning reader writer";
					false)
				else (	diag_string(
						"Exception++ " ^ (PolyML.makestring E)
						^ " handled by useterminal");
					true)
		then	(cur_prompt := prompt1; use_term_loop ())
		else	()
	)
in
	cur_prompt := prompt1;
	abandoning := false;

	use_term_loop ()
end);
=IGN

			output(std_out, "End of input to useterminal.  Commit and quit.\n");
			PolyML.commit();
=TEX

%********************************************************************

\subsection{Completion of Basic Reader Writer}

That ends the structure.  Open it for the benefit of later structures.

=SML
end (* of structure ReaderWriter *);

open ReaderWriter;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{SUPPORTING OTHER LANGUAGES}

The reader writer is extensible in that support other languages may be
added, the first such extension being for the HOL language.  Other
languages are allowed by embedding them within Standard~ML text
surrounded by language specific percent-keywords or pretty characters.
Extensions are added in several pieces.

\begin{enumerate}

\item A recursive descent parser for the new language, which {\em
	must\/} conform to the conventions given in the preceding
	sections, and particularly section~\ref{ReaderWriter}.  This
	means it must also use the same reading functions which are
	given in sections~\ref{DeclareReaderEnv}
	and~\ref{ReaderEnvironment}.   It may use any of the existing
	parsing functions, for example those dealing with comments and
	strings.

\item Extensions to the name and character dictionaries, $name_dict$
	and $char_dict$, to show how the languages special symbols are
	treated.  These extensions include the symbols that start and
	end sections of text of the new language.

\item \label{RWRoutine} A routine, but not part of this document, that
	performs the proper lexical analysis, parsing and any other
	processing required for the new language.

\end{enumerate}

Considered as an imperative program, the output of the reader portion
of the reader writer is a string of characters that are presented to a
Standard~ML \Compiler.  In this context the text of any embedded
language must be converted into Standard~ML, a convenient form would be
a Standard~ML string preceded by a call of the routine produced for
item~\ref{RWRoutine} listed above.  To allow HOL text to contain anti
quotations that embed Standard~ML text within HOL terms the input to
the parsing routine is actually a list of values of the following
datatype.  Note that the actual declaration is
elsewhere.\footnote{Provide a reference. and make sure that this text,
the contents of the starting and ending strings, and the lexical
analysers agree on the names used in the datatype.}

ÛSML Example
datatype ‚icl'ol_input·	=	‚icl'ol_text·		of string
			|	‚icl'ol_string·		of string
			|	‚icl'ol_char·		of int
			|	‚icl'ol_HOL_TYPE·	of TYPE
			|	‚icl'ol_HOL_TERM·	of TERM
			;
Ê

\begin{description}
\item[Aside: ] \ \ \ \em This declaration could be made part of
	structure $ReaderWriterSupport$, it is not needed by anything
	in the reader writer, but arguable it should be defined there
	since it represents part of the general interface between the
	reader writer and the lexical analysers.  Perhaps the
	declaration should be moved into the prelude with two-way
	references to this section to preserve the order of the
	narrative whilst putting the declarations in the correct
	places.

	The exact form and usage of this declaration is determined by
	two parts of the ICL HOL system, strictly speaking, it is not
	necessary to define it here. The parts are: the HOL lexical
	analyser, see\footnote{Reference to be
	supplied.}~\cite{HOLLexicalAnalyser}; and, the symbol
	definitions passed to $add_new_symbols$ in
	section~\ref{PrettyCharactersForHOL} below.

	Note also that the datatype cannot be declared until the types
	$TYPE$ and $TERM$ are declared, these require a large portion
	of the ICL HOL system to be available.
\end{description}

\newpage

The various constructors are used as follows.

{\def\ITEM#1{\item[$#1$ ] }
\begin{description}

\ITEM{icl'ol_text} Text of the new language, text that needs to be
	lexically analysed, parsed, etc.  This text excludes strings
	and character literals.

\ITEM{icl'ol_string} Character strings of the embedded language.
	These, together with character literals, need to be recognised
	by the reader writer to prevent the wrong interpretation of
	characters within them.  Since the reader writer has identified
	them it seems appropriate to reduce the work of later stages of
	the languages analysis by keeping strings and character
	literals as distinguished parts of the input text.

\ITEM{icl'ol_char} Character literals of the embedded language.  See
	the above discussion of $icl'ol_string$.  To simplify the
	treatment of these literals they are represented by their
	numeric value.

\ITEM{icl'ol_HOL_TERM} A Standard~ML expression that yields a HOL
	term.  This value is produced by a term anti quotation within
	HOL text.  Note that the value given here is any Standard~ML
	expression --- it must yield the correct Standard~ML type or an
	error will be reported by the \Compiler\ --- which may contain
	embedded text of another language which will be another list of
	this datatype, which may contain another anti quotation, and so
	on.

\ITEM{icl'ol_HOL_TYPE} As $icl'ol_HOL_TERM$, but for HOL types.

\end{description}}

The string output for the embedded language start symbol, i.e., the
string argument of the constructor $PrettyNames.Starting$ should
contain the name of the routine in item~\ref{RWRoutine} listed above
plus any necessary brackets and the opening ``\verb|icl'ol_text|''.
\ Correspondingly, the string argument of constructor
$PrettyNames.Ending$ should contain the closing brackets and the
closing double quote for the ``\verb|icl'ol_text|''.

The parsing routines return strings containing these constructors as
follows.

\begin{itemize}

\item All routines assume that they are entered when the string
	``\verb|icl'ol_text "|'' has recently been output, other
	characters may also have been output, but the closing double
	quote has not.

\item Any routine that wants a different constructor to
	``\verb|icl'ol_text|'' must close the current string, produce
	its own value, and start a new ``\verb|icl'ol_text|' together
	with the necessary list element separators.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{HOL READER WRITER}

=SML
structure ‚HOLReaderWriter· : HOLReaderWriter = struct

open ReaderWriterSupport;
=TEX

Some other declarations are needed, note that these are
duplicates\footnote{Suppress the duplication.} of some made at the head
of this document, but I have not found a tidy way of resuing the
original declarations.

=SML
val ‚ord_0· = ord "0";
val ‚ord_9· = ord "9";

fun ‚convert· (0:int) : string = "0"
| convert m = (
	let	fun aux 0 = ""
		| aux n = (
			if n < 0
			then	fail "convert" 5009 [fn () => PolyML.makestring n]
			else	aux(n div 10) ^ chr(ord_0 + (n mod 10)))
	in
		aux m
	end
);
=TEX

%********************************************************************

\subsection{HOL Characters Literals}

Characters literals are indicated by the three component sequence:
prime, the character, and a closing prime.  The character itself may
require more than one character to represent it.  This routine is
entered when the opening prime has been read, leaving the character and
closing prime to be read.

Characters allowed in a character literal are much as those allowed in
character strings, the main exception being that the formatting
character option is not allowed.  An escaped double quote is not
allowed, since it can be directly entered, instead an escaped single
quote is offered.

{\ftlinepenalty=9999
=SML
fun ‚get_HOL_character· (R:READER_ENV) (prev:string list) : string list= (
let
	fun aux str = (
		if size str = 1
		then
			case #look_at_next R ()
			of "'" => (#advance R ();
					"\",icl'ol_char " ^ (convert(ord str))
					^ ",icl'ol_text\"" :: prev)
			| _ => fail "get_HOL_character" 5011 nil
		else
			fail "get_HOL_character" 5012 nil
	);

	fun digit depth chval = (
		if depth <= 0 then aux(chr chval)
		else	let
				val ord_ch = ord(#look_at_next R ())
			in
				if ord_ch >= ord_0 andalso ord_ch <= ord_9
				then digit (depth-1) (#advance R (); chval * 10 + ord_ch - ord_0)
				else aux(chr chval)
			end
	);

	fun caret () = (
		let
			val ord_ch = ord(#look_at_next R ())
		in
			if ord_ch >= 65 andalso ord_ch <= 95
			then aux(chr(ord_ch-64))
			else fail "get_HOL_character" 5013 [fn () => convert ord_ch]
		end
	)
in
	case #look_at_next R ()
	of "'" => aux ""
	|  "\\" => (
		case #skip_and_look_at_next R ()
		of "t"	=> aux "\t"
		| "n"	=> aux "\n"
		| "'"	=> aux "'"
		| "\\"	=> aux "\\"
		| "^"	=> caret ()
		| _	=> digit 3 0)
	| ch =>	aux ch
end);
=TEX
}

%********************************************************************

\subsection{Recursive HOL Parser}

Deal with anti quotations and proper matching of end keywords.\footnote{To be done.}

{\ftlinepenalty=9999
=SML
fun ‚get_HOL_any· (R:READER_ENV) (prev:string list) : string list= (
let
	open PrettyNames;

	fun	do_keyword(_,Value ch,Simple _)	= get_HOL_any R (ch :: prev)
	|	do_keyword(names,Nil,Simple _)	= get_HOL_any R ("%" ^ (hd names) :: prev)
	|	do_keyword(_,_,Starting(str, proc))	= proc R (str :: prev)
	|	do_keyword(_,_,Middle str)		= get_HOL_any R (str :: prev)
	|	do_keyword(_,_,Ending str)		= str :: prev
	|	do_keyword(_,_,Ignore)		= get_HOL_any R prev
	|	do_keyword(names,Nil,Separator)	= get_HOL_any R (" " ^(hd names)^ " " :: prev)
	|	do_keyword(_,Value ch,Separator)	= get_HOL_any R (" " ^ ch ^ " " :: prev)
	|	do_keyword(names,_,Invalid)		= fail "get_HOL_any" 5002
								[fn () => hd names];

	val next = #look_at_next R ()
in
	case next
	of "("	=>	(#advance R (); get_HOL_any R (get_round_braces get_HOL_any R prev))
	|  ")"	=>	prev
	|  "["	=>	(#advance R (); get_HOL_any R (get_box_braces get_HOL_any R prev))
	|  "]"	=>	prev
	|  "{"	=>	(#advance R (); get_HOL_any R (get_curly_braces get_HOL_any R prev))
	|  "}"	=>	prev
	|  "\""	=>	(#advance R (); get_HOL_any R
				(", icl'ol_text\"" ::
				(get_string R ("\", icl'ol_string" :: prev)))) (* " *)
	|  "'"	=>	(#advance R ();get_HOL_any R (get_HOL_character R prev))
	|  "\t"	=>	skip_format get_HOL_any R prev next
	|  "\n"	=>	skip_format get_HOL_any R prev next
	|  " "	=>	skip_format get_HOL_any R prev next
	|  "\^L" =>	skip_format get_HOL_any R prev next
	|  "\^D" =>	prev
	|  "%"	=>	(	case get_percent_name R
				of (name, Value info, _)
					=> do_keyword info
				|  (n, Nil, _)
					=> fail "get_HOL_any" 5003 [fn () => "%" ^ n]
			)
	|  _	=>	let
				val ch = #advance R ();
				val ord_ch = ord ch
			in
				if ord_ch > 127
				then	case find_char ch
					of Value info
						=> do_keyword info
					|  Nil	=> fail "get_HOL_any" 5004
						[fn () => next,
						fn () => PolyML.makestring(ord_ch)]
				else	get_HOL_any R (ch :: prev)
			end
end);
=TEX
}

%********************************************************************

\subsection{Pretty Characters for HOL} \label{PrettyCharactersForHOL}

=SML
local
open ReaderWriterSupport.PrettyNames;
in
val _ = add_new_symbols [
=TEX

Box drawing, first the symbols that start a box.  Note that many
of these symbols have no interpretation in HOL or Standard~ML.
The Standard~ML comments below that contain only a string quote
`~{\tt"}~' are present to make the number of such quotes even
on each line.

The bracketing conventions used within HOL text need explaining.
Simple HOL text used as term or type expressions is not bracketed.  The
definitional HOL texts include brackets, these are generally used in a
style where the user enters the five components: {\em start,
definitions, where, predicate} and {\em finish.}  The {\em start,
where} and {\em finish\/} are the symbols defined below.  The users
input is translated to give a HOL term comprising the pair ``({\em
definitions\/}),~({\em predicate\/})'' which is used as the argument of
a Standard~ML function to achieve the definition.

=SMLLITERAL
	([	"<"],		Value "ª",
			Starting(" HOL_text[icl'ol_text\" ", get_HOL_any)), (*"*)
	([	"SHA"],	Value "»",
			Starting(" def_HOL_axiomatic[icl'ol_text\"(", get_HOL_any)), (*"*)
	([	"SHIA"],	Value "Á",
			Starting(" def_HOL_infix[icl'ol_text\"(", get_HOL_any)), (*"*)
	([	"SHS"],	Value "«",
			Starting(" def_HOL_schema[icl'ol_text\"(", get_HOL_any)), (*"*)
=TEX

Box drawing, symbols that complete a box.  Some of the pretty
characters can denote the end of several different types of box, note
the names used for end-of-Z boxes below.

=SMLLITERAL
	([	">"],		Value "º",			Ending " \"(* > *)]"), (*"*)
	([	"EHS",
		"EZC",
		"EZS"],	Value " ",			Ending ")\"(* EHS *)];"), (*"*)
	([	"EHA",
		"EZA"],	Value "À",			Ending ")\"(* EHA *)];"), (*"*)
=TEX

Box drawing, symbols used within boxes.

=SMLLITERAL
	([	"BBR"],	Value "‡",			Ignore),
	([	"BH"],		Value "Õ",			Ignore),
	([	"BHH"],	Value "¸",			Ignore),
	([	"BT"],		Value "…",			Middle "),(* BT *)("),
	([	"BTR"],	Value "ﬂ",			Ignore),
	([	"BV"],		Value "›",			Ignore)
]
end (* of local *);
=TEX

%********************************************************************

\subsection{HOL Reader Writer --- Completion}

=SML
end (* of structure HOLReaderWriter *);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{FINALE}

We wish to use $usefile$ as the file loading facility when building
subsequent files into the {\tt hol.db}.  $Install_file_loader$ is the
function that is used by the build script for {\tt hol.db} to load a
file to compile.  As a side effect, a large portion of this structure
is tested during the creation of the rest of the system.

=SML
Install_file_loader := (fn x => (diag_string ("usefile "^ x); usefile x));
=TEX

Now make some checks that things have been built properly.

=SMLLITERAL
let
fun check_name (n, l) = (
	case ReaderWriterSupport.PrettyNames.find_name n
	of Nil => n :: l
	| _ => l
);
fun check_char (c, l) = (
	case ReaderWriterSupport.PrettyNames.find_char c
	of Nil => c :: l
	| _ => l
);
fun wrap nil title = (title, "OK", nil)
| wrap l title = (title, "Failed", l);
val bad_names = fold check_name ["<", "SHS", "lambda", "fn"] nil;
val bad_chars = fold check_char ["ª", "«", "ç"] nil
in
(wrap bad_names "Names", wrap bad_chars "Chars")
end;
=TEX

We will wish to use $useterminal$ from now onwards, unless explicitly
aborted by the user.

=SML
useterminal();
=TEX

Any Standard~ML text from here to the end of the file will be ignored
because the call of $useterminal$ has replaced the PolyML reading
function with the code within $useterminal$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\newpage

\makeatletter
\def\refstepcounter#1{\stepcounter{#1}\global\edef\@currentlabel{\csname
	p@#1\endcsname\csname the#1\endcsname}}
\makeatother

\twocolumn[\section{INDEX}] \label{Index}

\footnotesize
\printindex

\onecolumn

\end{document}
