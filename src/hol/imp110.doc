% imp005.doc %Z% $Date$ $Revision$ $RCSfile$

=TEX
% imp005.doc %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol,11pt,TQ]{article}

\TPPtitle{File and Terminal Reader Writer}
\TPPref{DS/FMU/IED/IMP005}
\TPPissue{$Revision$%
}

\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{IED 1563}

=IGN

Commands to process this document in various ways.

make -f rel001.mkf imp005.dvi
doc4tex imp005
tex4dvi imp005
bibtex imp005
doc4tex imp005 ; tex4dvi imp005
dvipage imp005 &

dviselect 31:   imp005.dvi | pstex -
dviselect 16:30 imp005.dvi | pstex -
dviselect  1:15 imp005.dvi | pstex -


doc4errors imp005
PolyML.use "imp005.sml";

abandon_reader_writer();

poly -r sun4hol.db
poly -r /hat/projects/ied/rel001/sun4hol.db


lasp -s imp005.doc > zz1
lasp -s -u imp005.OKwords imp005.doc > zz1

=TEX
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Standard}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the reading and writing functions
	that form the outermost level of user interface for Release~1
	of ICL~HOL.  These functions are concerned with the
	differentiation of the various languages (initially Standard~ML
	and HOL), and the extensions to support pretty characters in
	Standard~ML identifiers and in strings.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

%\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\makeatletter
\def\StartTerm{\@Mm{\mathchar"2\@fx70\relax}}
\def\EndTerm{\@Mm{\mathchar"2\@fx71\relax}}

\def\UPchar{\@Mm{\mathchar"0\@fx66\relax}}
\def\DNchar{\@Mm{\mathchar"0\@fx67\relax}}

\def\calllatex{\@Mm{\mathchar"0\@fx7B}}
\def\negate{\@Mm{\mathchar"0\@fy6B}}

\def¸{\calllatex}
\defª{\negate}
\defã{\DNchar}
\defÂ{\UPchar}

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}
\makeatother


\def\Compiler{C{\tiny OMPILER}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

%********************************************************************

\subsection{Contents List}
\tableofcontents
% \listoftables

%********************************************************************

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

%********************************************************************

\subsection{Changes History}

\begin{description}

\item[1 February 1991, issue 1.1 ] This issue is an authors draft.

\item[4 February 1991, issue 1.2 ] $useterminal$ is invoked by loading
	this file, and $usefile$ is set to be used in subsequent
	Install's used in building {\tt hol.db}.

\item[21 February 1991, issue 1.3 ] Change the control-D handling in
	$useterminal$.  Add a proper writer function that converts
	ASCII strings into pretty characters.

\item[6 March 1991, issue 1.4 ] Restructure to give support for other
	language readers via structure $ReaderWriterSupport$ and use
	that to form the HOL reader.  Minor improvements throughout,
	particularly in $useterminal$.

\item[28 March 1991, issue 1.5 ] Simplifications to type $NAME_CLASS$
	and to support for embedded strings.  Percent characters now
	enclose keywords rather than just starting them.  Complete
	the HOL reader.  Improvements throughout.

\end{description}

%********************************************************************

\subsection{Changes Forecast} \label{ChangesForecast}

\begin{enumerate}

\item Properly install $useterminal$ as the outermost reader writer of
	the system.  This will include producing proper handling of the
	routines $PolyML.quit$ and $PolyML.commit$ together with the
	implicit calling of $PolyML.commit$ at end of input.

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the reading and writing routines for Release~1 of
the ICL HOL system.

%********************************************************************

\subsection{Introduction}

%--------------------------------------------------------------------

%\subsubsection{Purpose and Background}

%A brief description of the
%purpose of the objects defined in the document together
%with any references to related material, design notes or
%the like. Any separate specification document for the
%code should be referenced here.

%--------------------------------------------------------------------

%\subsubsection{Dependencies}

%An indication of which literate
%scripts this document is dependent on.

%--------------------------------------------------------------------

%\subsubsection{Interface}

%A brief explanation of the external
%interface presented by the document.
%If the document is part of a prototyping exercise
%and contains one or more Standard ML structures
%then the signatures for these structures should go
%in this section if they are not given in a separate design document.

%--------------------------------------------------------------------

%\subsubsection{Algorithms}

%Introductory observations on any special
%algorithms or techniques used in the document.
%(This section is intended to augment, rather than
%substitute for, detailed discussion of particular
%functions in the rest of the document).
%This should contain references to books or
%external papers, if any, which a maintainer would need
%to read to understand the code.

%--------------------------------------------------------------------

%\subsubsection{Possible Enhancements}

%A discussion of ways the facilities
%offered by the document might be improved, e.g. an indication
%of possible performance bottle-necks.

%--------------------------------------------------------------------

%\subsubsection{Deficiencies}

%An indication of any shortcomings in the
%facilities offered by the document.

%--------------------------------------------------------------------

\subsubsection{Terminology}

The word `\Compiler' is used to denote the part of a Standard~ML system
that lexically analyses, parses, evaluates and formats for output
Standard~ML text.  The routine $PolyML.compiler$ is an example of a
`\Compiler'.

The `basic reader writer' supports reading and writing Standard~ML,
plus the interfaces to allow additional languages to be embedded.  It
is contained within structure $ReaderWriter$.

The `reader writer' includes the `basic reader writer' plus the reading
and writing functions for other languages which have been added via the
embedding interface in structure $ReaderWriterSupport$.

%--------------------------------------------------------------------

% \subsection{Deviations From Definition Document \protect{\cite{DS/FMU/IED/DEF002}}}

% Some changes are necessary to the ideas proposed
% in~\cite[issue~1.1]{DS/FMU/IED/DEF002}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{PRELUDE}

%********************************************************************

\subsection{Start of Basic Reader Writer}

Everything goes in a structure.

=SML
structure âReaderWriterá : ReaderWriter = struct
=TEX

During development the capability to abandon this reader writer system
and return to the PolyML default reader and writer is needed.  This is
achieved by providing a local exception that is handled appropriately,
together with a function to raise it.  This facility may be withdrawn
for the proper release.  Calling this function from within $usefile$ or
$usestring$ is allowed, the exception will be propagated out as far as
possible.

=SML
exception AbandonReaderWriter;
val abandoning = ref false;

fun abandon_reader_writer () : unit = (
	abandoning := true;
	raise AbandonReaderWriter
);
=TEX

%********************************************************************

\subsection{Start of Embedding Interface}

Most of the reader writer is placed in a structure within the main
$ReaderWriter$ structure.  The items made visible from the outer
structure are for the normal users of the system, those from the inner
structure are provided to allow the embedding of other languages.

=SML
structure âReaderWriterSupportá = struct
=TEX

%********************************************************************

\subsection{Integers and Strings}

Ordinal values of some characters are useful.

=SML
val âord_0á = ord "0";
val âord_9á = ord "9";
=TEX

The string representation of integers is needed in various places.
This is mainly to do with Standard~ML strings where some characters are
denoted by their decimal code in three digits, preceded by a
backslash.  Function $string_of_int3$ gives a three character with
leading zeros representation of small positive numbers.

=SML
fun âstring_of_int3á n = (
	let
		val str = if n < 0 then "-****" else string_of_int n
	in
		case size str
		of 0 => "000"
		| 1 => "00" ^ str
		| 2 => "0" ^ str
		| 3 => str
		| x => fail "string_of_int3" 5010
			[fn () => PolyML.makestring n]
	end
);
=TEX

Some strings are built up and passed on to $PolyML.compiler$, these
must be valid Standard~ML strings.  Function $to_ML_string$ converts
any string into a valid string.

=SML
fun âto_ML_stringá str = (
let
	fun	aux (ch as " ") = ch
	|	aux (ch as "\n") = ch
	|	aux (ch as "\t") = ch
	|	aux ch = (
			if (ord ch >= 32 andalso ord ch <= 126)
			then ch
			else "\\" ^ (string_of_int3(ord ch)))
in
	implode(map aux (explode str))
end);
=TEX


%********************************************************************

\subsection{Warning Messages} \label{WarningMessages}

Based on the ideas in~\cite{DS/FMU/IED/DTD002}
and~\cite{DS/FMU/IED/IMP002}, these functions have the same set of
arguments as functions $error$ and $fail$, their purpose is to output the
warning message and then allow the calling function to continue.  It is
definitely not the $warn$ function discussed
in~\cite{DS/FMU/IED/DTD002} which prompts the user about continuing or
stopping.  This function provides a commentary on events as they
happen, it is intended to provide messages (1)~during the build and
extension of the tables of symbols, and (2)~messages about faults in
the users input which are detected by the reader writer.

=SML
fun âlocal_warná (area : string) (id : int) (inserters : (unit -> string) list) : unit = (
	diag_string(
			"*** WARNING "
		^	(string_of_int id)
		^	" from "
		^	area
		^	": "
		^	(get_error_message id (map (fn f => f())inserters))
	)
);
=TEX

=SML
fun âlocal_errorá (area : string) (id : int) (inserters : (unit -> string) list) : unit = (
	diag_string(
			"*** ERROR "
		^	(string_of_int id)
		^	" from "
		^	area
		^	": "
		^	(get_error_message id (map (fn f => f())inserters))
	)
);
=TEX

%********************************************************************

\subsection{Diagnostics}

Several control flags are provided in this structure for debugging
purposes.  These flags are used throughout the rest of the structure.
This section defines all of the debugging flags used by the reader
writer.

=SML
val RWchars_read = ref false;
val _ =
new_flag {name = "âRWchars_readá",  control=RWchars_read, default=fn () => false};

val RWchars_written = ref false;
val _ =
new_flag {name = "âRWchars_writtená",  control=RWchars_written, default=fn () => false};

val RWphrases_read = ref false;
val _ =
new_flag {name = "âRWphrases_readá",  control=RWphrases_read, default=fn () => false};

val RWtext_read = ref false;
val _ =
new_flag {name = "âRWtext_readá",  control=RWtext_read, default=fn () => false};

val RNC = ref false;
val _ =
new_flag {name = "âRNCá",  control=RNC, default=fn () => false};
=TEX

=IGN

%--------------------------------------------------------------------

It is useful to have the commands to set and clear these flags easily available.

set_flag("RWchars_read", true);
set_flag("RWchars_written", true);
set_flag("RWphrases_read", true);
set_flag("RWtext_read", true);
set_flag("RNC", true);

set_flag("RWchars_read", false);
set_flag("RWchars_written", false);
set_flag("RWphrases_read", false);
set_flag("RWtext_read", false);
set_flag("RNC", false);

%--------------------------------------------------------------------

=SML
fun âlogitá flag proc str = (
	if !flag
	then
		(output(std_out, proc ^ "   " ^ (string_of_int(size str)) ^ "  <" ^
			(	case str of "\n" => "\\n"
				| "\^D" => "\\^D"
				| x => x) ^ ">\n");
		str)
	else
		str
);

fun âlogit_listá flag proc (str:string list) = (
	if !flag
	then
		(output(std_out, proc ^ "  " ^
			(PolyML.makestring (map (fn x => (size x, x)) str)) ^ "\n");
		str)
	else
		str
);
=TEX

%********************************************************************

\subsection{Reader Environment} \label{DeclareReaderEnv}

A record structure is used to contain the environment used when
reading, this is primarily the character reading functions to
accommodate the various sources of Standard~ML text discussed in
section~\ref{IclHolInterface}.  The record is properly described in
section~\ref{ReaderEnvironment}, but its definition is presented here
to enable its use within the table of pretty characters, in particular
its use within the datatype $NAME_CLASS$ of
section~\ref{DeclareNameClass}.

=SML
type âREADER_ENVá = {
	âadvanceá			: unit -> string,
	âlook_at_nextá			: unit -> string,
	âskip_and_look_at_nextá	: unit -> string
};
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{PRETTY CHARACTERS}

The system supports pretty characters in the source documents and on
the printed output.  There are more characters available for output
than can be contained in the eight bit character set that is
available.  The additional pretty characters may be input by using a
keyword approach where the keywords are introduced by a percent
`{\tt\%}' character.  Details of all of the keywords and the actual
pretty characters are included in a structure for use by other parts of
the lexical analyser.

To allow for the inclusion of other languages the structure is
extensible.  It is initialised with the characters and keywords to
support Standard~ML extended to allow pretty characters in identifiers
and strings.  Later stages of this document\footnote{Or another
document.} will extend the structure to support HOL and Z.

=SML
structure âPrettyNamesá = struct
=TEX

%********************************************************************

\subsection{Data Held for Pretty Characters}
\label{DataHeldForPrettyCharacters}

The class of each symbol is recorded.  Type $Simple$ is for those that
may be part of identifiers.  Type $Invalid$ are those that are always
invalid when found by the reader, these include the symbols understood
by the document processing programs\footnote{Provide a reference.} for
surrounding formal text which does not require processing by this
reader writer.  Type $Ignore$ is for symbols which are to be completely
ignored.

More complex types are needed for embedding other languages.  Symbol of
type $Starting$ and $Ending$ are used (as their name suggests) to start
and complete a section of embedded text.  Type $Middle$ is used within
a section of embedded text.  The strings with the three constructors
are added to the text presented to the \Compiler, they are described in
section~\ref{FixedStringsForEmbeddingSymbols} where the details of how
languages are embedded are given.  With type $Starting$ the function is
the parsing function for the embedded language, it will perform a
recursive decent (as described in section~\ref{ReaderWriter}) of the
next characters input.

\label{DeclareNameClass}

=SML
datatype âNAME_CLASSá
	=	âSimpleá
	|	âIgnoreá
	|	âInvalidá
	|	âStartingá	of (READER_ENV -> string list -> string list) * string * string
	|	âMiddleá	of string
	|	âEndingá	of string * string
	;
=TEX

For each distinct symbol a tuple is held.  It contains: a list of the
alternative names for the symbol, with the preferred name at head; the
pretty character, if any; and, the class of the name, that is where and
how it is used.

=SML
type âPRETTY_NAMEá = ( string list * string OPT * NAME_CLASS );
=TEX

%********************************************************************

\subsection{Pretty Character Dictionary}

The purpose of this data structure is to capture all of the names of
the symbols together with their pretty characters and attributes.  The
intention is that this table is fairly easy to understand and modify,
that the information about each symbol is given only once --- although
the generated data structure may replicate information.

A simple linear search through the table would be slow so the names and
characters are configured as an efficient dictionaries, their contents
are provided later.

The dictionaries themselves are accessed only via insertion and
inspection functions.

=SML
local (* for add_new_symbols, find_name and find_char *)

open EfficientDictionary;

val âname_dictá	: PRETTY_NAME E_DICT ref = ref initial_E_DICT;
val âchar_dictá		: PRETTY_NAME E_DICT ref = ref initial_E_DICT;
=TEX

To insert values into these dictionaries the following routines are
provided.

Some of the entries for pretty characters above are temporary, we do
not yet have the proper set of pretty characters.  To direct attention
to the characters which are not correctly handled details will be
obtained by examining the above list whilst the list produced remains
non-empty some characters need attention.

=SML
in (* local for add_new_symbols, find_name and find_char *)

fun âadd_new_symbolsá (pnl:PRETTY_NAME list) : unit = (
let
	fun add_name(pcd as (names, _, _) : PRETTY_NAME, dict : PRETTY_NAME E_DICT
			) : PRETTY_NAME E_DICT = (
	let
		fun moan_kw name = local_warn "add_new_symbols" 5006 [fn () => name];

		fun ok_kw("Q"::"Q"::_) = false
		| ok_kw(_::t) = ok_kw t
		| ok_kw nil = true;

		fun aux("Q", dict) = (moan_kw "Q"; dict)
		| aux(name, dict) = (
			if ok_kw(explode name)
			then	e_enter name pcd dict
			else	(moan_kw name; dict)
		)
	in
		case names
		of nil => (local_warn "add_new_symbols" 5015 nil; dict)
		| _ => fold aux names dict
	end);

	fun add_char((_, Nil, _) : PRETTY_NAME, dict : PRETTY_NAME E_DICT
			) : PRETTY_NAME E_DICT = dict
	|   add_char(pcd as (names, Value ch, _), dict) = (
		if size ch = 1 andalso ord ch >= 128
		then	e_enter ch pcd dict
		else (	local_warn "add_new_symbols" 5016  [fn () => PolyML.makestring names];
			dict)
	)
in
	output(std_out, "Adding " ^ (PolyML.makestring(length pnl)) ^ " new symbols\n");
	name_dict := fold add_name pnl (!name_dict);
	char_dict := fold add_char pnl (!char_dict)
end);
=TEX

=SML
fun âfind_nameá (name:string) : PRETTY_NAME OPT = (
	e_lookup name (!name_dict)
);

fun âfind_chará (char:string) : PRETTY_NAME OPT = (
	e_lookup char (!char_dict)
)

end  (*  of local for add_new_symbols, find_name and find_char *);
=TEX

%********************************************************************

\subsection{Initial Set of Symbols}

The basic set of symbols are those available for all languages,
including Standard~ML, they are the Greek letters, the mathematical
symbols, and a few specials used in forming identifiers.

=SML
local (* for raw_symbol_names *)

val âraw_symbol_namesá : PRETTY_NAME list = [
=TEX

=IGN
(* Some symbols to test add_new_symbols and provoke some error messages *)
	([	"abcQQdef"],	Nil,				Simple),
	([	"QQdef"],	Nil,				Simple),
	([	"abcQQ"],	Nil,				Simple),
	([	"QQ"],		Nil,				Simple),
	([	"Q"],		Nil,				Simple),
	([	],		Nil,				Simple),
=TEX

The first group of symbols are for the Greek letters.  Note, there are
problems\footnote{To be resolved  --- they stem from the different
purposes that the characters are used for, and the different sorts of
processing that is done.  Ideally the $string\;OPT$ column should
contain something that prints like the graphics screen image of the
character and which has the correct single character in the Standard~ML
that is produced.  Correct ML has been achieved by careful use of the
{\tt screenfile} and its associated programs.  The changes needed to
those programs to make the characters print properly here are
non-trivial --- the problem characters are those that are converted, by
the program {\tt doc2tex,} into complex commands, what is required here
is the conversion into something that prints like the graphics screen
image of the character.} displaying some of the pretty characters
here.


{\ftlinepenalty=9999
=SMLLITERAL
	([	"Delta"],	Value "ñ",			Simple),
	([	"Gamma"],	Nil,				Simple),
	([	"Lambda"],	Nil,				Simple),
	([	"Omega"],	Nil,				Simple),
	([	"Phi"],		Nil,				Simple),
	([	"Pi"],		Nil,				Simple),
	([	"Psi"],		Nil,				Simple),
	([	"Sigma"],	Nil,				Simple),
	([	"Theta"],	Nil,				Simple),
	([	"Upsilon"],	Nil,				Simple),
	([	"Xi"],		Value "ò",			Simple),
	([	"alpha"],	Nil,				Simple),
	([	"beta"],	Nil,				Simple),
	([	"chi"],		Nil,				Simple),
	([	"delta"],	Nil,				Simple),
	([	"epsilon"],	Nil,				Simple),
	([	"eta"],		Nil,				Simple),
	([	"gamma"],	Nil,				Simple),
	([	"iota"],		Nil,				Simple),
	([	"kappa"],	Nil,				Simple),
	([	"fn",
		"lambda"],	Value "",			Simple),
	([	"mu"],		Value "‡",			Simple),
	([	"nu"],		Nil,				Simple),
	([	"omega"],	Nil,				Simple),
	([	"phi"],		Nil,				Simple),
	([	"pi"],		Nil,				Simple),
	([	"psi"],		Nil,				Simple),
	([	"rho"],		Nil,				Simple),
	([	"sigma"],	Nil,				Simple),
	([	"tau"],		Nil,				Simple),
	([	"theta"],	Value "­",			Simple),
	([	"upsilon"],	Nil,				Simple),
	([	"xi"],		Nil,				Simple),
	([	"zeta"],	Nil,				Simple),
=TEX
}

Calligraphic alphabet.

{\ftlinepenalty=9999
=SMLLITERAL
	([	"calA"],	Nil,				Simple),
	([	"calB"],	Nil,				Simple),
	([	"calC"],	Nil,				Simple),
	([	"calD"],	Nil,				Simple),
	([	"calE"],	Nil,				Simple),
	([	"calF"],	Nil,				Simple),
	([	"calG"],	Nil,				Simple),
	([	"calH"],	Nil,				Simple),
	([	"calI"],		Nil,				Simple),
	([	"calJ"],	Nil,				Simple),
	([	"calK"],	Nil,				Simple),
	([	"calL"],	Nil,				Simple),
	([	"calM"],	Nil,				Simple),
	([	"calN"],	Nil,				Simple),
	([	"calO"],	Nil,				Simple),
	([	"calP"],	Nil,				Simple),
	([	"calQ"],	Nil,				Simple),
	([	"calR"],	Nil,				Simple),
	([	"calS"],	Nil,				Simple),
	([	"calT"],	Nil,				Simple),
	([	"calU"],	Nil,				Simple),
	([	"calV"],	Nil,				Simple),
	([	"calW"],	Nil,				Simple),
	([	"calX"],	Nil,				Simple),
	([	"calY"],	Nil,				Simple),
	([	"calZ"],	Nil,				Simple),
=TEX
}

Maths symbols.

{\ftlinepenalty=9999
=SMLLITERAL
	([	"spot",
		"=>"],		Value "Ž",			Simple),
	([	"and"],		Value "€",			Simple),
	([	"bagunion"],	Value "Þ",			Simple),
	([	"bigcolon"],	Value "º",			Simple),
	([	"bij"],		Value "ì",			Simple),
	([	"bottom"],	Value "´",			Simple),
	([	"cat"],		Value "µ",			Simple),
	([	"dcat"],	Value "Ã",			Simple),
	([	"def"],		Value "”",			Simple),
	([	"dintersect"],	Value "¢",			Simple),
	([	"dres"],	Value "š",			Simple),
	([	"dsub"],	Value "›",			Simple),
	([	"dunion"],	Value "£",			Simple),
	([	"emptyset"],	Value "¤",			Simple),
	([	"equiv"],	Value "‚",			Simple),
	([	"exists"],	Value "„",			Simple),
	([	"fcompose"],	Value "¯",			Simple),
	([	"ffun"],	Value "œ",			Simple),
	([	"filter"],	Value "Á",			Simple),
	([	"finj"],		Value "ð",			Simple),
	([	"forall"],	Value "ƒ",			Simple),
	([	"fset"],		Value "’",			Simple),
	([	"fun"],		Value "‹",			Simple),
	([	"geq"],		Value "Ÿ",			Simple),
	([	"implies"],	Value "Š",			Simple),
	([	"inj"],		Value "",			Simple),
	([	"int"],		Value "í",			Simple),
	([	"intersect"],	Value " ",			Simple),
	([	"lbag"],		Value "[[",			Simple),
	([	"leq"],		Value "ž",			Simple),
	([	"lfree"],	Value "¾¾",		Simple),
	([	"lrelimg"],	Value "Ñ",			Simple),
	([	"lseq"],		Value "¾",			Simple),
	([	"map"],	Value "—",			Simple),
	([	"mem"],	Value "",			Simple),
	([	"nat"],		Value "†",			Simple),
	([	"neq"],		Value "ˆ",			Simple),
	([	"not"],		Value "Œ",			Simple),
	([	"notmem"],	Value "“",			Simple),
	([	"or"],		Value "",			Simple),
	([	"overwrite"],	Value "•",			Simple),
	([	"pfun"],	Value "–",			Simple),
	([	"pinj"],	Value "«",			Simple),
	([	"pset"],	Value "‘",			Simple),
	([	"psubset"],	Value "¦",			Simple),
	([	"psurj"],	Value "Î",			Simple),
	([	"rbag"],	Value "]]",			Simple),
	([	"rel"],		Value "",			Simple),
	([	"rfree"],	Value "¿¿",		Simple),
	([	"rrelimg"],	Value "Ò",			Simple),
	([	"rres"],		Value "™",			Simple),
	([	"rseq"],	Value "¿",			Simple),
	([	"rsub"],	Value "˜",			Simple),
	([	"select"],	Value "\\varepsilon",		Simple),
	([	"subset"],	Value "¥",			Simple),
	([	"subtract"],	Value "Ä",			Simple),
	([	"surj"],	Value "Ú",			Simple),
	([	"thm"],		Value "…",			Simple),
	([	"union"],	Value "¡",			Simple),
	([	"x"],		Value "‰",			Simple),
=TEX
}
Several symbols are provided for use with identifiers.

Four new characters are created which have significant processing with
respect to the way identifiers are formed.  Temporarily they will be
used as follows, following the style used in~\cite{DS/FMU/IED/DEF002}
to show the graphic, printed and ASCII forms of characters.

\begin{center}
\begin{tabular}[t]{llll}
Purpose&Graphic&Printed&ASCII\\[1ex]
Superscripts&$\sp+$&Â&{\tt\%up}\\
Subscripts&$\sb 0$&ã&{\tt\%down}\\
\LaTeX\ inclusion&$\sb c$&¸&{\tt\%latex}\\
Negation&${\rlap{$\times$}\hbox{$\,\times$}}$&ª&{\tt\%negate}
\end{tabular}
\end{center}

=SMLLITERAL
	([	"latex"],	Value "¸",			Simple),
	([	"negate"],	Value "ª",			Simple),
	([	"down"],	Value "ã",			Simple),
	([	"up"],		Value "Â",			Simple),

	([	"cal"],		Nil,				Simple),
	([	"SX"],		Value "â",			Ignore),
	([	"EX"],		Value "á",			Ignore),
=TEX

Several symbols are reserved, some for the use of the Z notation.  These are
included here for completeness, they will eventually be transferred to a
section of this or another document where Z is properly treated.

=SMLLITERAL
	([	"SFT"],	Value "ó",			Invalid),
	([	"SML"],	Value "å",			Invalid),
	([	"SR1"],	Value "\\StartRuleOne",	Invalid),
	([	"SR2"],	Value "\\StartRuleTwo",	Invalid),
	([	"SZ"],		Value "è",			Invalid),
	([	"SZA"],	Value "ê",			Invalid),
	([	"SZC"],	Value "ë",			Invalid),
	([	"SZS"],	Value "é",			Invalid),
	([	"EML",
		"EFT",
		"EZ"],		Value "æ",			Invalid),
	([	"ER"],		Value "\\EndRule",		Invalid)
]
=TEX

Add the symbols into the dictionary.

=SML
in (* local for raw_symbol_names *)

val _ = add_new_symbols raw_symbol_names;

end (* of local for raw_symbol_names *);
end (* of structure PrettyNames *);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{READER WRITER}
\label{ReaderWriter}

The task of the reader and writer is to read text presented to the
system, determining which parts are Standard~ML and which are in
an embedded language such as HOL.
Both may include pretty characters and keywords denoting pretty
characters or other symbols.  The Standard~ML text is modified
according to the nature of the pretty characters.

The basis of the reader and writer is a recursive decent parser that
understands the structure of both Standard~ML and HOL.  At first sight
this seems overkill, but it is required so that anti quotations of
Standard~ML within HOL can be properly delimited, which means that
Standard~ML round braces be properly understood.  Both Standard~ML and
HOL may include any character within string literals and comments, thus
the reader must understand a considerable part of both languages.

The rules for the code of the recursive decent parser are as follows.
The main recursive function take as an argument the characters parsed
and processed already, i.e., the characters to the left of the item to
be matched by the called routine.  The most recently read character is
the first character of the item handled by the called routine.  This
character is passed as an argument to some routines.  A routine is only
called when it is appropriate.  When called the routine must read all
the characters that are part of the input item it handles.  If the
parse is successful it returns with the LHS string plus the newly
matched characters.  If unsuccessful it calls $fail$ to report the
error.  On both types of exit the first unread character is the
character that does not belong to the text already parsed.

For efficiency reasons the characters parsed and processed already are
held as a list of strings with the most recently parsed item at the
head of the list.  A first attempt at the type of this argument would
be a single string with text added to the right, however, string
concatenation is thought to be inefficient.

%********************************************************************

\subsection{Recursive Descent Parser}

%--------------------------------------------------------------------

\subsubsection{Reader Environment}
\label{ReaderEnvironment}

Routines are required for reading characters and giving a one character
lookahead.  These routines considered to be the ``readers
environment''.

At all stages during parsing the work can be seen as follows.  Of the
input text there is the ``portion already read'', the ``current
character'' and the ``unread portion''.  The ``portion already read''
will have been recorded (after some modifications) in $prev$ which is
one of the arguments of many of the parsing routines.  The
``current-character'' will be under processing by one of the recursive
descent functions.  The first character of the ``unread-portion'' is
called the next character.  At may stages there will be no current
character, it will have been fully processed and added into the
``portion already read''.

Function $advance$ assumes that the caller has properly dealt with the
current character, it reads a character and returns its value.
Function $skip_and_look_at_next$ is similar, but does not return the
value of the new current character.  Function $look_at_next$ does a one
character lookahead and returns the value of that next character.

After end of file all routines return the character control-D, decimal
code~4, whenever called.  For resilience of the code during testing the
routines signal a fault if they return an excessive number of control-D
characters, this is shown in section~\ref{ExcessiveControlDs}.

The routines are placed in a record which is passed through the various
routines of the lexical analyser.  The record, with the Standard~ML
type name $READER_ENV$, is declared in section~\ref{DeclareReaderEnv}.

Associated with the reader functions is the exception $EndOfInput$
which is raised when the parser has read the end of the file and
has passed the end of file character at least once to the \Compiler.
Raising this exception signifies that nothing more can usefully be
done with the current input stream.

=SML
exception âEndOfInputá;
=TEX

%--------------------------------------------------------------------

\subsubsection{Comments}

Comments are skipped over.  Comments are sequences of characters within
which the comment braces `{\tt (*}' and `{\tt *)}' are properly
balanced.  This routine is entered when the opening round bracket of
the comment has been read, the opening asterisk is the first unread
character.

=SML
fun âskip_commentá (R:READER_ENV) : unit = (
let
	val skip_and_read = #skip_and_look_at_next R;
	val skip = #advance R;
	fun aux (depth:int) : unit = (
		case skip_and_read ()
		of "(" =>	if skip_and_read () = "*"
				then	aux (depth+1)
				else	aux depth
		|  "*" =>	if skip_and_read () = ")"
				then
					if depth = 1
					then	(skip (); ())
					else	aux (depth-1)
				else	aux depth
		|  "\^D" =>	fail "skip_comment" 5001 nil
		|  _   =>	aux depth
	)
in
	aux 1
end);
=TEX

%--------------------------------------------------------------------

\subsubsection{Formatting Characters}

Formatting characters are skipped over.  The string argument $next$
here is the first unread character of the input text.

=SML
fun âskip_formatá (get : READER_ENV -> string list -> string list)
		(R:READER_ENV) (prev:string list) (next:string) : string list = (
	if		next = " "
		orelse	next = "\n"
		orelse	next = "\t"
		orelse	next = "\^L"
	then	skip_format get R prev (#skip_and_look_at_next R ())
	else	get R (" " :: prev)
);
=TEX

%--------------------------------------------------------------------

\subsubsection{Strings}

Strings start and finish with a `~{\tt"}~' and contain a
mixture of characters and escape sequences.  Some escape sequences are
used in formatting the source text, others denote particular
characters.  Most of the understanding and validating of strings, and
in particular the escape sequences, can be left to the \Compiler, here
the concern is finding the end of the string, and converting pretty
characters into a form acceptable to the \Compiler.  In finding the end
of the string the escape sequence that allows strings to be laid out
neatly must be recognised.  The strings \verb*|"ab\"c\   \de\\f"| and
\verb*|"ab\"cde\\f"| are the same, as are the strings \verb*|"ab\  \"|
and \verb*|"ab"|, they only differ by the use of the formatting
characters.  Note the \verb*|\"| in the second example which must not
be interpreted as an escaped double quote.

Within a string an escape followed by one of more formatting characters
and another escape may be ignored.  Non formatting characters are not
allowed.  The full set of allowed characters is implementation
dependent, but includes, quoting from~\cite[section~2.1]{Milner90},
``$\ldots$ at least space, tab, newline and formfeed.''  These four
characters will be skipped by the lexical analyser here, any other
characters will be passed on to the \Compiler, as if they were escaped
formatting characters.

Local function $skip_format_chars$ is first entered with a formatting
character as the first unread character, it reads characters until a
closing escape character which it reads leaving the next character as
the first character after the whole escape sequence.  Any other
characters found between the escape characters are retained for
processing by the \Compiler which may consider some characters above the
minimum set of four as formatting characters.

On entry to $handle_escape$ the opening escape character has been read,
but not the character being escaped.

A variation on strings allows single left-hand primes~(~{\tt`}~) to
enclose the body of the string.  The escape conventions are altered,
swapping the interpretations of the single~(~{\tt`}~) and
double~(~{\tt"}~) prime characters.  Function $get_primed_string$ deals
with these strings.

=SML
local (* for get_ML_string and get_primed_string *)

fun âhandle_escapeá (ML_string:bool) (R:READER_ENV) : string = (
let
	fun skip_format_chars (prev:string) : string = (
		case #skip_and_look_at_next R ()
		of " "		=> skip_format_chars prev
		|  "\t"		=> skip_format_chars prev
		|  "\n"		=> skip_format_chars prev
		|  "\^L"		=> skip_format_chars prev
		|  "\\"		=> (#advance R (); prev)
		|  "\^D"	=> prev
		|  s		=> skip_format_chars (prev ^ s)
	);

	val next = #look_at_next R ()
in
	if next = " " orelse next = "\t" orelse next = "\n" orelse next = "\^L"
	then
		case skip_format_chars ""
		of	""	=> ""
		|	x	=> ("\\ " ^ x ^ " \\")
	else if next = "`"  andalso not ML_string
	then
		#advance R ()
	else
		("\\" ^ (#advance R ()))
end);
=TEX

Most of the work of gathering strings is just reading and concatenating
the characters, they are of five classes: end of string, end of file,
pretty, escaped
and others.  Function $string_body$ is first called with
the first character of the string being the first unread character.

There are several places in the Standard~ML code where double quotes or
brackets are used within strings, in some of them the quotes or
brackets do not balance.  Whilst this is the intended Standard~ML code
it confuses some other processes, particularly the quote and bracket
matching code in editors, and the mechanisms used to display double
quotes on paper.  To avoid these problems Standard~ML comments
containing the `missing' characters are added, these comments are in a
standard form, ``{\tt(*=}x{\tt=*)}'' where ``x'' is the missing
characters.  The first example of one of these comments is a
missing double quote in function $string_body$.

=SML
fun âstring_bodyá (ML_string:bool) (R:READER_ENV) prev = (
	case #look_at_next R ()
	of "\""		=> (	#advance R (); (*="=*)
				if ML_string
				then	"\"" (*="=*) :: prev
				else	string_body ML_string R ("\\\""::prev) (*="=*))
	| "`"		=> (	#advance R ();
				if ML_string
				then	string_body ML_string R ("`"::prev)
				else	"\"" :: prev (*="=*))
	|  "\^D"	=> fail "string_body" 5007 nil
	|  _		=>
		let	val next = #advance R ();
			val ord_next = ord next
			val str =
				if ord_next > 255
				then
					fail "string_body" 5010
						[fn () => string_of_int ord_next]
				else if ord_next > 127
				then
					"\\" ^ (string_of_int ord_next)
				else if next = "\\"
				then
					handle_escape ML_string R
				else
					next
		in
			string_body ML_string R (str::prev)
		end
);
=TEX

The result from $string_body$ is a sequence of mainly one-character
strings, it seems appropriate to convert it to one long string at this
stage rather than retaining the space overhead until the whole input
text is formed.  Functions $get_\ldots_string$ are called with the opening
string quote having been read.

=SML
fun âget_any_stringá (ML_string:bool) (R:READER_ENV) prev = (
	[implode(rev(string_body ML_string R ["\""]))] @ prev (*="=*)
);

in (* local for get_ML_string and get_primed_string *)

fun âget_ML_stringá (R:READER_ENV) prev = get_any_string true R prev;

fun âget_primed_stringá (R:READER_ENV) prev = get_any_string false R prev;

end (* of local for get_ML_string and get_primed_string *);
=TEX

%--------------------------------------------------------------------

\subsubsection{Percent Keywords}

The characters of a keyword that is enclosed with percent `{\tt\%}'
characters are assembled here, and the keyword is looked up against the
list of known keywords.

This routine is a little different to the others in that it needs to do
a multi-character look-ahead to gather the whole name to know how to
treat the name and the enclosing `{\tt\%}' characters, whereas the rest
of the system only needs one-character look-ahead.  The problem is that
the names are several characters long; in the ML we require that all or
none of the letters after a `{\tt\%}' are part of the name.  To
overcome this the function will return a tuple of values.  The first
element will give the characters read, but without any `{\tt\%}'
characters.  The second entry will be the additional information found
from looking up the keyword, or $Nil$ for an unknown keyword.
The third entry is $true$ if the keyword was alphanumeric, $false$
otherwise.  A forth entry is set to the error message text if an error
has been raised because of a keyword without its closing `{\tt\%}',
when no warning has been issued it is the empty string

On entry a `{\tt\%}' is the next character.  Read the the name which is
of two possible types:  most are a non-empty string of alphanumerics, a
few are non-alphanumeric.

=SML
fun âget_percent_nameá (R:READER_ENV)
		: (string * PrettyNames.PRETTY_NAME OPT * bool * string) = (
	let
		fun is_alphanumeric ch = (
				(ch >= "a" andalso ch <= "z")
			orelse	(ch >= "A" andalso ch <= "Z")
			orelse	(ch >= "0" andalso ch <= "9")
		);

		fun collect_alphanumeric next = (
			if is_alphanumeric next
			then	next ^ (collect_alphanumeric(#skip_and_look_at_next R ()))
			else	""
		);

		fun is_special ch = (
			contains ["!", "&", "$", "#", "+", "-", "/", ":", "<", "=", ">",
				"?", "@", "\\", "~", "'", "^", "|", "*"] ch
		);

		fun collect_specials next = (
			if is_special next
			then	next ^ (collect_specials(#skip_and_look_at_next R ()))
			else	""
		);

		val next = #skip_and_look_at_next R ();
	in
		case	(* tuple: (name, is_alpha) *)
			case collect_alphanumeric next
			of ""	=> (
				(* No alphanumerics, look for specials *)
				case collect_specials next
				of ""	=> ("", false)
				| n	=> (n, false)
				)
			| n	=> (n, true)
		of ("", _) => ("", Nil, false, "")
		| (n, is_alpha) =>
			if #look_at_next R () = "%"
			then (	#advance R ();
				(n, PrettyNames.find_name n, is_alpha, ""))
			else (	local_error "get_percent_name" 5014 [fn () => "%" ^ n];
				(n, PrettyNames.find_name n, true, " *** ERROR 5014 *** "))
	end
);
=TEX

%--------------------------------------------------------------------

\subsubsection{Bracketed Text}

Gathering bracketed text is required in many languages.  The basic idea
of these routines is to gather some bracketed text.  The value returned
comprises both brackets plus all the text they enclose, or if the
opening bracket was a start-of-comment then return nothing (i.e., an
empty list).

Text enclosed by round brackets may be comment or nested Standard~ML text.
The opening round bracket has been read, so the next character indicates
how to process the bracket.

Gathering nested text enclosed by braces (i.e., by the characters
`\verb|( ) { } [ ]|') uses a general routine for bracketed text.

=SML
fun âget_round_bracesá (get : READER_ENV -> string list -> string list)
		(R:READER_ENV) (prev:string list) : string list = (
	if #look_at_next R () = "*"
	then
		(skip_comment R; prev)
	else
		get_braces get R prev "(" ")"
)

and âget_box_bracesá (get : READER_ENV -> string list -> string list)
		(R:READER_ENV) (prev:string list) : string list = (
	get_braces get R prev "[" "]"
)

and âget_curly_bracesá (get : READER_ENV -> string list -> string list)
		(R:READER_ENV) (prev:string list) : string list = (
	get_braces get R prev "{" "}"
)
=TEX

In the general routine for gathering bracketed text the next character
is the first character within the bracketed expression.  The opening
bracket for the expression is $first$, the closing bracket should be
$term$.  This routine differs from the general rules for the recursive
decent in that it does not pass $prev$ to the routines it calls, this
is needed to allow the detection of terminating braces, when the call
of $get$ will return an empty list.

An unexpected type of closing brace is reported\footnote{The error
message might be deleted in the future.} with a error message, and
then added to the returned string, leaving the real error reporting to
the \Compiler.

=SML
and âget_bracesá (get : READER_ENV -> string list -> string list)
		(R:READER_ENV) (prev1:string list) (first:string) (term:string) : string list = (
let
	fun more prev2 = (
		case get R nil
		of nil =>	let
					val next = #look_at_next R ()
				in
					if next = term
					then	(#advance R ()) :: prev2
					else if next = "\^D"
					then	"\^D" :: prev2
					else (	local_error "get_braces" 5005 [
							fn () => next, fn () => first];
						(if contains ["]", "}", ")"] next
						then [#advance R ()]
						else nil) @ (" *** ERROR 5005 *** " :: prev2))
				end
		| ["\^D"] =>	(#advance R ()) :: prev2
		| new =>	more(new @ prev2)
	)
in
	(more [first]) @ prev1
end);
=TEX

%--------------------------------------------------------------------

\subsubsection{Main Parser Function}

Function $get_ML_any$ is the main parser function.  It reads upto the
first semi colon `{\tt;}' or closing bracket and then returns the text
read.  A semi colon will be read and added to the returned text, a
closing bracket is left unread for the calling routine.  The syntax
error where too many closing bracket are presented must be resolved by
the outermost routine that calls this function.  The
routines that handle text which may include semi colons, essentially
those dealing with brackets, should repeatedly call $get_ML_any$ until
the appropriate end of text is found.

{\ftlinepenalty=9999
=SML
fun âget_ML_anyá (R:READER_ENV) (prev:string list) : string list= (
let
	open PrettyNames;

	fun	echo(names, Nil) = " " ^ (hd names)
	|	echo(names, Value ch) = " " ^ ch;

	fun	do_keyword _ (names,_,Simple) p = get_ML_any R ("QQ"^(hd names)^"QQ"::p)
	|	do_keyword k (_,_,Starting(proc, s1, s2)) p =
			proc R ((s1 ^ "(\"" ^ (to_ML_string k) ^ "\", [icl'ol_text\"" ^ s2) :: p) (*="=*)
	|	do_keyword _ (_,_,Middle str) p = get_ML_any R (str :: p)
	|	do_keyword k (_,_,Ending(s1, s2)) p =
			(s1 ^ "\"], \"" ^ (to_ML_string k) ^ "\")" ^ s2) :: p (*="=*)
	|	do_keyword _ (_,_,Ignore) p = get_ML_any R p
	|	do_keyword k (names,_,Invalid) p = (
			local_error "get_ML_any" 5002 [fn () => k];
			get_ML_any R (" *** ERROR 5002 *** ":: p));

	val next = #look_at_next R ()
in
	case next
	of "("	=>	(#advance R (); get_ML_any R (get_round_braces get_ML_any R prev))
	|  ")"	=>	prev
	|  "["	=>	(#advance R (); get_ML_any R (get_box_braces get_ML_any R prev))
	|  "]"	=>	prev
	|  "{"	=>	(#advance R (); get_ML_any R (get_curly_braces get_ML_any R prev))
	|  "}"	=>	prev
	|  ";"	=>	(#advance R ()) :: prev
	|  "\""	=>	(#advance R (); get_ML_string R prev) (*="=*)
	|  "\t"	=>	skip_format get_ML_any R prev next
	|  "\n"	=>	skip_format get_ML_any R prev next
	|  " "	=>	skip_format get_ML_any R prev next
	|  "\^L" =>	skip_format get_ML_any R prev next
	|  "\^T" =>	prev
	|  "\^D" =>	prev
	|  "%"	=>	(	case get_percent_name R
				of (name, Value info, _, ws)
					=> do_keyword ("%" ^ name ^ "%") info (ws :: prev)
				|  (n, Nil, false, ws)
					=> get_ML_any R (	(case ws
								of "" => "%" ^ n ^ "%"
								| wss => wss)
							:: prev)
				|  (n, Nil, true, ws)
					=> (	local_error "get_ML_any" 5003 [fn () => n, fn () =>
							implode(rev(" ... " :: (prev to 10)))];
						get_ML_any R (" *** ERROR 5003 *** "::ws::prev))
			)
	|  "Q"	=>	(#advance R (); get_ML_any R ("QQQQ" :: prev))
	|  _	=>	let
				val ch = #advance R ();
				val ord_ch = ord ch
			in
				if ord_ch > 127
				then	case find_char ch
					of Value info
						=> do_keyword ch info prev
					|  Nil	=> (local_error "get_ML_any" 5004 [fn () => next,
								fn () => string_of_int(ord_ch)];
						get_ML_any R (" *** ERROR 5004 *** " :: prev))
				else	get_ML_any R (ch :: prev)
			end
end)
=TEX
}

%********************************************************************

\subsection{Outermost Levels of Reader Writer}

This routine is called by $PolyML.compiler$ to read the next part of
the input text.  It adopts a simple approach to text that $get_ML_any$
cannot parse properly, it passes the first character that did not parse
on to its caller.  Consider an unmatched closing bracket which
$get_ML_any$ cannot parse and so returns an empty string, the bracket
is read here and returned for the caller to deal with, probably by
issuing an error message.

Text that parsed successfully here must be converted in the correct
order into a single string.

=SML
local (* for get_ML_outermost *)

val âsent_eofá = ref false;

fun âget_MLá (R:READER_ENV) = (
	case get_ML_any R nil
	of nil =>	(	case #advance R ()
				of "\^D" =>	if !sent_eof
						then nil
						else (sent_eof := true; ["\^D"])
				| ch =>		(sent_eof := false; [ch]))
	| "\^D"::nil =>	if !sent_eof
				then	nil
				else	(sent_eof := true; [#advance R ()])
	| x =>			(sent_eof := false; rev x)
)

in (* local for get_ML_outermost *)

fun âget_ML_outermostá (R:READER_ENV) () : string = (
	let
		val ord_nl = ord "\n" and ord_tab = ord "\t"
		and ord_ff = ord "\^L" and ord_eof = ord "\^D";

		fun ok_chars(s : string) : bool = (
			all (explode s) ((fn x => ((x >= 32 andalso x <= 127)
					orelse x = ord_nl
					orelse x = ord_tab
					orelse x = ord_ff
					orelse x = ord_eof)) o ord)
		);

		val text_read_list = get_ML R;
		val text_read = implode text_read_list
	in
		logit_list	RWphrases_read	"get_ML_outermost" text_read_list;
		logit		RWtext_read		"get_ML_outermost" text_read;
		if ok_chars text_read
		then	()
		else	local_warn "get_ML_outermost" 5018 [fn () => text_read];
		if text_read = ""
		then	raise EndOfInput
		else	text_read
	end
)

end (* of local for get_ML_outermost *);
=TEX

When reading from a terminal the string returned by $get_ML_outermost$
will start with a space character.  It comes from the newline character
which (along with any sequence of white space characters) is turned
into a single space.  This character could be removed from the string
passed back to $PolyML.compiler$ but doing so is not easy, and in any
case $PolyML.compiler$ skips over it without any problem.  There are
other places in the string that could be optimised (e.g., spaces before
and after brackets) but again, $PolyML.compiler$ skips over them more
efficiently than this routine could remove them.

%********************************************************************

\subsection{Completion of Embedding Interface}

Some of the declarations above are intended for use when embedding
other languages.  The remaining declarations within structure
$ReaderWriter$ are concerned with the main user interface of the reader
writer.  The support structure is opened here so that its contents are
readily available for the remainder of the basic reader writer, note
that the signature constraint on the structure $ReaderWriter$ will keep
the supporting declarations within their own structure.

=SML
end (* of structure ReaderWriterSupport *);

open ReaderWriterSupport;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{COMPILER INTERFACE}

%********************************************************************

\subsection{PolyML Interface} \label{PolyML.compiler.example}

The routine $PolyML.compiler$ is the interface to the
read-evaluate-print loop of the PolyML system, it is a \Compiler{}
and has the signature:

óSML example
PolyML.compiler : (unit -> string) * (string -> unit) -> unit -> unit
æ

Calling this routine invokes the read-evaluate-print loop to process
one outermost level item (e.g., a declaration or an expression) which
is called a {\em topdec\/} in \cite{Milner90}.  When a {\em topdec\/}
is fully processed (i.e., a response is printed) the routine exits.
The first argument is called whenever the \Compiler{} requires more
input, the routine should return a string containing the text read.
The second argument is an output function, invoked by the \Compiler{}
for output messages.  The third argument is provided to delay execution
of the read-evaluate-print loop.

Routine $PolyML.compiler$ is recursive in the sense that a file
included by the above example routine may include other files by
calling $usefile$.  Whilst reading the innermost included file a stack
trace would show the following items:

\begin{itemize}

	\item Normal read-evaluate-print loop.
	\item Call of $PolyML.compiler$
	\item Call of $use_file_loop$
	\item Call of $usefile$.
	\item Normal read-evaluate-print loop.
	\item Call of $PolyML.compiler$
	\item Call of $use_file_loop$
	\item Call of $usefile$.
	\item Normal read-evaluate-print loop.
	\item Outermost levels of PolyML system.

\end{itemize}

End of file is indicated to the $PolyML.compiler$ with the control-D
character, this is not actually read from the file, it must be
generated by the reader function.  Observation of $PolyML.compiler$
suggests that the control-D character forces the \Compiler{} to parse
the preceding text as a complete {\em topdec,} but otherwise ignore the
character.  After fully processing a {\em topdec\/} the
$PolyML.compiler$ returns or raises an exception, just as it does for
any other {\em topdec.} As $PolyML.compiler$ is called in a loop to
allow for many {\em topdec\/}s the end of file processing must break
out of the loop, but first it should cause the parsing of any text just
read, this allows the \Compiler{} to produce error messages for files
which have incomplete {\em topdec\/}s, e.g., a file that ends with
`{\tt let val x}' or a string without a closing double quote.

As an example, a simple file inclusion facility could be written
as follows.

óSML example
fun usefile (file:string) : unit = (
let
	val cur_in = open_in file;
	val eof_char_sent = ref false;
	exception E_eof;

	fun reader () : string = (
	let
		val ch = input(cur_in, 1)
	in
		if ch = ""
		then	if	!eof_char_sent
			then	raise E_eof
			else	(eof_char_sent := true; "\^D")
		else	ch
	end);

	fun writer (s : string) : unit = output(std_out, s);

	fun use_file_loop () = (
		if (PolyML.compiler (reader, writer) (); true)
					handle E_eof => false
		then	use_file_loop ()
		else	()
	)
in
	use_file_loop ()
		handle E => (
			output(std_out,
				"Exception, abandoning file "
				^ file ^ "\n");
			close_in cur_in;
			raise E)
	;
	(* Only reach here after reading end-of-file *)
	close_in cur_in
end);
æ

The interface to ICL HOL provided by this document uses the
$PolyML.compiler$ interface in a style based on the example above, the
capabilities for handling pretty characters and producing prompts for
interactive input are provided by using more complex $reader$ and
$writer$ functions.

%********************************************************************

\subsection{ICL HOL Interface}
\label{IclHolInterface}

Four input sources are required for ICL HOL.

\begin{enumerate}

\item The console for normal interactive use.

\item Piped input for non-interactive use.

\item Included files.

\item Strings built by Standard~ML functions.

\end{enumerate}

The first two are alternatives, either the system is being run
interactively or input is being piped (in the UNIX sense) into the
system.  Both of these modes may request input of further Standard~ML
and HOL from another file.  The final input type allows Standard~ML
functions to create a string to be interpreted as Standard~ML or HOL
text.

\bigskip

To present these interfaces three main routines are identified.

\begin{description}

\item[$useterminal : unit -> unit$ ] which is the outermost routine of
	the lexical part of ICL HOL.  This routine is invoked at system
	startup and should remain in control at all times.  This
	routine is the primary interface to the ICL HOL system, it
	should replace the default outermost routine of PolyML.  Some
	investigation and experimentation\footnote{To be done.} is
	required to find a way of doing this.  Having this as the
	outermost routine means that it is started automatically when
	PolyML is started, also that breaking in with a control-C and
	entering ``{\tt f}'' (i.e., raising an exception to exit from
	the active Standard~ML and return to the top level) reverts to
	this routine.

\item[$use_file : string -> unit$ ] causes the named file to be read in
	a manner analogous to the routine $PolyML.use : string ->
	unit$ of PolyML.  The text read will be interpreted as
	Standard~ML and HOL the same as it had been entered at the
	outermost level.

\item[$use_string : string -> unit$ ] causes the contents of the string
	to be interpreted as Standard~ML and HOL the same as it had
	been entered at the outermost level or read from a file.

\end{description}

%********************************************************************

\subsection{Introduction To Reader Functions}

From experimentation with PolyML it seems that text in an included file
must be complete, i.e., capable of interpretation as a top level item.
Unclosed bracketing forms cause error messages.  For example,
unclosed comments, brackets, strings, {\tt let}-clauses and {\tt
local}-clauses all provoke an error message.  This behaviour should be
followed by the routines presented in this document.

The three routines named above ($useterminal$, $usefile$ and $usestring$)
will be written much as in the example in
section~\ref{PolyML.compiler.example}, but with different reader and
writer functions.  Each function will set up its input stream, and then
invoke $PolyML.compiler$ naming the appropriate reader and writer.  All
of the reader functions will call $get_ML_outermost$ to read some text,
this text will be returned to the \Compiler.  The reader functions must
set up the input streams so that the various routines in structure $R$
above are provided.

There are three areas that add complexity to the reading functions.
First, keeping track of line and character numbers within the source
text, to provide information for error messages.  Second, providing a
mechanism to track faults in the parser where it loops looking at a
character without actually reading it --- for example (an actual fault
found in early testing) a pretty character was found by $get_ML_any$
but the character was not actually read (i.e., $\#advance\;R\;();$ was
not called) and so on the next call of $get_ML_any$ the same character
was found, and again, and again.  Third, providing diagnostic output
about the characters read.

\label{ExcessiveControlDs}
To stop the reader looping without reading new characters a counter is
maintained of the number of times each character is passed to the
parsing functions, a failure is reported when this exceeds a threshold
value.  This threshold must be at least 3 since a character may be
examined by $skip_format$ then looked at by $get_ML_any$ and then
advanced over.  Longer sequences may be possible but have not (yet!)
been identified.

=SML
val max_copies_of_char_sent = 30;
=TEX

%********************************************************************

\subsection{Writer Function}

A common writer function is used by all three reader writers, its most
complex tasks are to recognise ASCII keywords and convert them to their
equivalent pretty characters and to recognise the numeric values of
pretty characters in strings and print the correct character.  The
conversions are as follows.  A keyword is a sequence of alphanumerics enclosed in ``{\tt QQ}'' 
characters, e.g., ``$pi$'' is encoded as ``{\tt QQpiQQ}''.
If a decoding is available then replace the
whole keyword with the corresponding pretty character.  If no pretty
character is available then replace the enclosing ``{\tt QQ}'' characters with
single ``{\tt\%}'' characters.  To preserve ``{\tt Q}''s in the original
text the string ``{\tt QQQQ}'' is considered to be the keyword whose
representation is a single ``{\tt Q}''.
In no cases are an isolated ``{\tt Q}'' or ``{\tt QQQ}'' valid as part
of a keyword, they indicate either an internal error or that user code
has produced a string containing these letters.  An opening ``{\tt
QQ}'' with a non-alphanumeric before the closing ``{\tt QQ}'' is
produced in the same manner.  Both cases provoke an error message.

On occasions no conversions should be performed by the writer so a
control flag is provided.

=SML
val writer_convert = ref true;
val _ =
new_flag {name = "âwriter_convertá",  control=writer_convert, default=fn () => true};
=TEX

From observation of $PolyML.compiler$ it seems that no identifier or
string is split over two or more calls of the writer function,
therefore no memory is required\footnote{This may need to be
reconsidered after further experience of the use of $PolyML.compiler$
is obtained.} between invocations of the writer to deal with partial
identifiers or partial strings.  Additional work will be
needed\footnote{To be done.} to support HOL text output via the
writer.

{\ftlinepenalty=9999
=SML
fun âwriterá (s : string) : unit = (
let
	fun get_kw (prev, nil) = (prev, true, nil)
	|   get_kw (prev, "Q"::"Q"::t) = (prev, true, t)
	|   get_kw (prev, h::t) = (	if	(h >= "A" andalso h <= "Z")
					orelse	(h >= "a" andalso h <= "z")
					orelse	(h >= "0" andalso h <= "9")
					then	get_kw(prev ^ h, t)
					else	(prev, false, h::t));

	val e5017 = " *** ERROR 5017 *** ";

	fun aux nil = []
	|   aux ("Q"::"Q"::"Q"::"Q"::t) = "Q"::(aux t)
	|   aux (f as "Q"::"Q"::"Q"::t) = (
		local_error "writer" 5017 [fn () => implode f];
		e5017 :: (aux t))
	|   aux (f as "Q"::"Q"::rest) = (
		case	get_kw ("", rest)
		of (_, false, t) => (local_error "writer" 5017 [fn () => implode f]; e5017 :: (aux t))
		|  (kw, true, t) => (	case	PrettyNames.find_name kw
					of Value(_, Value ch, _)	=> ch
					| _				=> "%" ^ kw ^ "%"
				) :: (aux t))
	|   aux (f as "Q"::t) = (local_error "writer" 5017 [fn () => implode f]; e5017 :: (aux t))
	|   aux ((h as "\"")::t) = h::(aux_str t)  (*="=*)
	|   aux (h::t) = h::(aux t)

	and aux_str nil = []
	|   aux_str ("\""::t) = "\""::(aux t)
	|   aux_str ("\\"::d1::d2::d3::t) = (
		if		(d1 >= "0" andalso d1 <= "9")
		andalso	(d2 >= "0" andalso d2 <= "9")
		andalso	(d3 >= "0" andalso d3 <= "9")
		then
			let
				val dd1 = ord d1 - ord_0;
				val dd2 = ord d2 - ord_0;
				val dd3 = ord d3 - ord_0;
				val ch = (dd1 * 10 + dd2) * 10 + dd3
			in
				if ch > 127
				then	(chr ch) :: (aux_str t)
				else	"\\"::d1::(aux_str(d2::d3::t))
			end
		else
			"\\"::d1::(aux_str(d2::d3::t)))
	|   aux_str(h::t) = h::(aux_str t);

	val chars = logit RWchars_written "writer" s
in
	output(std_out,	if	!writer_convert
				then	implode(aux(explode chars))
				else	chars)
end);
=TEX
}

%********************************************************************

\subsection{Reading From a File -- {\tt usefile}}

Reading from a file is normally stopped at the first failure noted
within the file, this can be altered to cause the whole file to be
processed.

=SML
val usefile_non_stop_mode = ref false;
val _ =
new_flag {name = "âusefile_non_stop_modeá",  control=usefile_non_stop_mode,
	default=fn () => false};
=TEX

{\ftlinepenalty=9999
=SML
fun âusefileá (file:string) : unit = (
let
	val cur_in = open_in file;
	val line_number = ref 1;
	val copies_of_char_sent = ref 0;
	exception Read_too_often of string;

	fun âf_advanceá () : string = (
		case input(cur_in, 1)
		of "" =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often "\\^D"
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "f_advance              " "\^D")
		|  "\n" => (	copies_of_char_sent := 0;
				line_number := !line_number + 1 ;
				logit RWchars_read "f_advance              " "\n")
		|  ch => (	copies_of_char_sent := 0;
				logit RWchars_read "f_advance              " ch)
	);

	fun âf_look_at_nextá () = (
		case lookahead cur_in
		of "" =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often "\\^D"
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "f_look_at_next         " "\^D")
		|  ch =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often ch
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "f_look_at_next         " ch)
	);

	fun âf_skip_and_look_at_nextá () = (
		f_advance();
		logit RWchars_read "f_skip_and_look_at_next"
			(case lookahead cur_in
			of "" =>	"\^D"
			|  ch =>	ch)
	);

	val reader = {	advance = f_advance,
			look_at_next = f_look_at_next,
			skip_and_look_at_next = f_skip_and_look_at_next} : READER_ENV;

	fun âuse_file_loopá () = (
		if (PolyML.compiler (get_ML_outermost reader, writer) (); true)
					handle EndOfInput => false
		then	use_file_loop ()
		else	()
	)
in
	while (
	 (use_file_loop (); false)
		handle Read_too_often ch => (
			output(std_out,
				"Character \"" ^ ch ^ "\" read too often, abandoning file "
				^ file ^ " at line "
				^ (string_of_int (!line_number)) ^ "\n");
			close_in cur_in;
			raise Read_too_often ch)
		| E =>
			if !usefile_non_stop_mode
			then (
				diag_string(
					"Exception++ " ^ (PolyML.makestring E)
					^ " handled by usefile at line "
					^ (string_of_int (!line_number)) ^ "\n");
				true)
			else (
				diag_string(
					"Exception++, abandoning file "
					^ file ^ " at line "
					^ (string_of_int (!line_number)) ^ "\n");
				close_in cur_in;
				raise E)
	) do ( (* nothing *) )
	;
	(* Only reach here after reading end-of-file *)
	close_in cur_in
end);
=TEX
}

%********************************************************************

\subsection{Reading From a String -- {\tt usestring}}

{\ftlinepenalty=9999
=SML
fun âusestringá (str:string) : unit = (
let
	val cur_str = ref(explode str);
	val char_number = ref 1;
	val copies_of_char_sent = ref 0;
	exception Read_too_often of string;

	fun âs_advanceá () : string = (
		case !cur_str
		of nil =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often "\\^D"
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "s_advance              " "\^D")
		|  ch::t =>	(copies_of_char_sent := 0;
				char_number := !char_number + 1;
				cur_str := t;
				logit RWchars_read "s_advance              " ch)
	);

	fun âs_look_at_nextá () = (
		case !cur_str
		of nil =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often "\\^D"
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "s_look_at_next         " "\^D")
		|  ch::_ =>	if !copies_of_char_sent > max_copies_of_char_sent
				then	raise Read_too_often ch
				else	(copies_of_char_sent := (!copies_of_char_sent + 1);
					logit RWchars_read "s_look_at_next         " ch)
	);

	fun âs_skip_and_look_at_nextá () = (
		s_advance();
		logit RWchars_read "s_skip_and_look_at_next"
			(case !cur_str
			of nil =>	"\^D"
			|  ch::_ =>	ch)
	);

	val reader = {	advance = s_advance,
			look_at_next = s_look_at_next,
			skip_and_look_at_next = s_skip_and_look_at_next} : READER_ENV;

	fun âuse_string_loopá () = (
		if (PolyML.compiler (get_ML_outermost reader, writer) (); true)
					handle EndOfInput => false
		then	use_string_loop ()
		else	()
	)
in
	use_string_loop ()
		handle Read_too_often ch => (
			diag_string(
				"Character \"" ^ ch
				^ "\" read too often, abandoning string at character "
				^ (string_of_int (!char_number)) ^ "\n");
			raise Read_too_often ch)
		| E => (
			diag_string(
				"Exception++, abandoning string at character "
				^ (string_of_int (!char_number)) ^ "\n");
			raise E)
	(* Only reach here after reading end-of-string *)
end);
=TEX
}

%********************************************************************

\subsection{Reading from a Terminal -- {\tt useterminal}}

=SML
fun âuseterminalá () : unit = (
let
=TEX

Whilst reading from a terminal several points must be dealt with in
addition to those needed for the other two readers.

\begin{itemize}

\item Prompts are required when the system wants the user to enter some
	characters.  Input is line based, the operating system provides
	line editing and only passes the characters when an end-of-line
	character is typed.  Second and later lines of a {\em topdec\/}
	should have a different prompt to the first.  To distinguish
	this reader from the PolyML default reader the prompts have a
	colon `:' added.  A prompt is required when the previously read
	character is a new line or a control-X.

=SML
	val prompt1 = ":> ";
	val prompt2 = ":# ";

	val cur_prompt = ref prompt1;

	val console_last : string ref = ref "\n";

	fun issue_prompt() : unit = (
		if !console_last = "\n" orelse !console_last = "\^X"
		then	output(std_out, !cur_prompt)
		else	()
	);
=TEX

\item The control-X character is taken to mean break as soon as
	possible to the main prompt of this reader, ignoring any text
	typed and processed already.

=SML
	exception QuitTopDec;
=TEX

\item All exceptions should be fielded by the reader, they should be
	reported to standard output, then the next {\em topdec\/}
	solicited.

\item Counting of times a character is used should take place just as
	in the other readers, to reduce the chances of run-away
	recursion of the parsing routines.

=SML
	val copies_of_char_sent = ref 0;
	exception Read_too_often of string;
=TEX

\end{itemize}

All the reading of characters is handled by one routine which deals
with prompting as required.  The second-line of a {\em topdec\/} is
considered to have started only after a character other than a new line
has been read.

=SML
local (* for read_char and lookahead_char *)

	fun read_next_character () = (
		issue_prompt();

		let
			val last = 	case input(std_in, 1)
					of "" => "\^D"
					|  ch => ch
		in
			console_last := last;
			if last = "\^X"
			then	raise	QuitTopDec
			else if last <> "\n"
			then	(cur_prompt := prompt2; last)
			else	last
		end
	);
=TEX

Character lookahead is simulated here by actually reading a character,
and remembering it until it is read by the parser.  Routines to read and
lookahead must then examine this remembered value.  The lookahead just
returns the value whereas a read empties it.

=SML
	val ahead_char : string OPT ref = ref Nil;

in (* local for read_char and lookahead_char *)

	fun read_char () : string = (
		case !ahead_char
		of Nil =>	read_next_character()
		| Value ch =>	(ahead_char := Nil; ch)
	);

	fun lookahead_char () : string = (
		case !ahead_char
		of Nil =>	let	val ch = read_next_character()
				in	(ahead_char := Value ch; ch) end
		| Value ch =>	ch
	)
end (* of local for read_char and lookahead_char *)
=TEX

The functions passed in a $READER_ENV$ record are very similar\footnote{We
could take advantage of the routine $read_next_character$ to centralise
the character counting in a future release of this document.} to those
of the other readers apart from the end-of-file handling not being
needed.

=SML
	fun ât_advanceá () : string = (
		case read_char ()
		of "\n" => (	copies_of_char_sent := 0;
				logit RWchars_read "t_advance              " "\n")
		|  ch => (	copies_of_char_sent := 0;
				logit RWchars_read "t_advance              " ch)
	);
=TEX

Note the call on $t_advance$ before raising $Read_too_often$, this is
to force a way past the offending character.

=SML
	fun ât_look_at_nextá () = (
	let
		val ch = lookahead_char()
	in
		if !copies_of_char_sent > max_copies_of_char_sent
		then	(t_advance(); raise Read_too_often ch)
		else	(copies_of_char_sent := (!copies_of_char_sent + 1);
			logit RWchars_read "t_look_at_next         " ch)
	end);

	fun ât_skip_and_look_at_nextá () = (
		t_advance();
		logit RWchars_read "t_skip_and_look_at_next"
			(case lookahead_char()
			of "" =>	"\^D"
			|  ch =>	ch)
	);

	val reader = {	advance = t_advance,
			look_at_next = t_look_at_next,
			skip_and_look_at_next = t_skip_and_look_at_next} : READER_ENV;
=TEX

Most exceptions should be handled by the \Compiler{} loop which reports
them and then continues.  Exception $EndOfInput$ is
raised in response to end-of-file (control-D) characters being passed
to the parsing functions, the response is\footnote{Should probably also
	do a $PolyML.commit$ here to follow the practice of PolyML
	itself.  Unfortunately if we did then the first action on
	starting with such a database is to resume this function after
	the commit, which means that the quit is performed.  This leads
	to a PolyML database which quits immediately after it is
	started.  Some more investigation is required in this area.}
to call $PolyML.quit$.  Function $read_next_character$ deals with
control-X characters
locally by raising $QuitTopDec$ to indicate the users request to return
to the outer level of useterminal.  Exception $Read_too_often$ denotes
a coding fault in the processing of the users input.  Exception
$AbandonReaderWriter$ indicates the users desire to abandon this reader
writer package.  All other exceptions are just reported.  Note that in
many cases $PolyML.compiler$ will catch the exception, report it, and
raise an exception whose name is not available (presumably it is
declared local to the PolyML system).  This means that there needs to be
a check for abandoning in the ``others'' clause of the match for
exceptions below.

=SML
	fun âuse_term_loopá () = (
		if (PolyML.compiler (get_ML_outermost reader, writer) (); true)
			handle EndOfInput => (diag_string 
					"End of input to useterminal.  Quit.";
				PolyML.quit(); false)
			| Fail x => (diag_string(
					"Exception++ Fail " ^ (PolyML.makestring x) ^ " raised");
				true)
			| Error x => (diag_string(
					"Exception++ Error " ^ (PolyML.makestring x) ^ " raised");
				true)
			| AbandonReaderWriter => (diag_string "Abandoning reader writer";
				false)
			| QuitTopDec => (diag_string
					"Control-X read, return to outer level of useterminal";
				true)
			| Read_too_often ch => (
				diag_string( "Character \"" ^ ch
					^ "\" read too often, abandoning current input");
				true)
			| E =>	if !abandoning
				then (	diag_string "Abandoning reader writer";
					false)
				else (	diag_string(
						"Exception++ " ^ (PolyML.makestring E)
						^ " handled by useterminal");
					true)
		then	(cur_prompt := prompt1; use_term_loop ())
		else	()
	)
in
	cur_prompt := prompt1;
	abandoning := false;

	use_term_loop ()
end);
=IGN

			output(std_out, "End of input to useterminal.  Commit and quit.\n");
			PolyML.commit();
=TEX

%********************************************************************

\subsection{Completion of Basic Reader Writer}

That ends the structure.  Open it for the benefit of later structures.

=SML
end (* of structure ReaderWriter *);

open ReaderWriter;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{SUPPORTING OTHER LANGUAGES}

The reader writer is extensible in that support other languages may be
added, the first such extension being for the HOL language.  Other
languages are allowed by embedding them within Standard~ML text
surrounded by language specific percent-keywords or pretty characters.

A goal when producing reader writers for embedded languages (indeed, a
goal for the whole reader writer) is to make the reading as simple as
possible, deferring as much as possible to the lexical analyser and
parser for the particular language.  There are several simplifications
that can be made, and which are made in the HOL reader writer that
follows.

\begin{itemize}

\item Defer error detection and reporting as much as possible, leave it
	to the lexical analyser or parser for the embedded language.
	In this context there are many errors that the basic reader
	writer is in a position to detect, but it passes them through to
	the \Compiler{} knowing that the \Compiler{} will detect and
	report them.  To aid understanding of the error and where it
	occurred (or at least where it was detected) the characters
	``{\tt *** ERROR {\em number\/} *** }'' are passed to the
	\Compiler.

\item Treat brackets in the same way as other symbols.  This means
	allowing badly balanced brackets in the embedded text since the
	parser will detect them.

\item Use the functions provided in the basic reader writer, for
	example to read and get information about percent keywords, and
	to discard comment text.

\item Treat character literals as strings, letting the lexical analyser
	or parser complain if they are not exactly one character long.

\end{itemize}

Extensions are added in several pieces.

\begin{enumerate}

\item \label{ExtParser} A recursive descent parser for the new language, which {\em
	must\/} conform to the conventions given in the preceding
	sections, and particularly section~\ref{ReaderWriter}.  This
	means it must also use the same reading functions which are
	given in sections~\ref{DeclareReaderEnv}
	and~\ref{ReaderEnvironment}.   It may use any of the existing
	parsing functions, for example those dealing with comments and
	strings.

\item Extensions to the name and character dictionaries, $name_dict$
	and $char_dict$, to show how the languages special symbols are
	treated.  These extensions include the symbols that start and
	end sections of text of the new language.

\item \label{RWRoutine} A routine, but not part of this document, that
	performs the proper lexical analysis, parsing and any other
	processing required for the new language.

\end{enumerate}

%********************************************************************

\subsection{Datatype for Parser Interface}

Considered as an imperative program, the output of the reader portion
of the reader writer is a string of characters that are presented to a
Standard~ML \Compiler.  In this context the text of any embedded
language must be converted into Standard~ML, a convenient form would be
a Standard~ML string preceded by a call of the routine produced for
item~\ref{RWRoutine} listed above.  To allow embedded text to contain
anti quotations (i.e., embedding Standard~ML text within embedded text)
the input to
the parsing routine is actually a list of values of the following
datatype.  Note that the actual declaration is
elsewhere.\footnote{Provide a reference. and make sure that this text,
the contents of the starting and ending strings, and the lexical
analysers agree on the names used in the datatype.}

óSML Example
datatype âicl'ol_inputá	=	âicl'ol_textá			of string
			|	âicl'ol_ML_stringá		of string
			|	âicl'ol_primed_stringá		of string
			|	âicl'ol_HOL_TYPEá		of TYPE
			|	âicl'ol_HOL_TERMá		of TERM
			;
æ

\begin{description}
\item[Aside: ] \ \ \ \em This declaration could be made part of
	structure $ReaderWriterSupport$, it is not needed by anything
	in the reader writer, but arguably it should be defined there
	since it represents part of the general interface between the
	reader writer and the lexical analysers.  Perhaps the
	declaration should be moved into the prelude with two-way
	references to this section to preserve the order of the
	narrative whilst putting the declarations in the correct
	places.

	The exact form and usage of this declaration is determined by
	two parts of the ICL HOL system, strictly speaking, it is not
	necessary to define it here. The parts are: the HOL lexical
	analyser, see\footnote{Reference to be
	supplied.}~\cite{HOLLexicalAnalyser}; and, the symbol
	definitions passed to $add_new_symbols$ in
	section~\ref{PrettyCharactersForHOL} below.

	Note also that the datatype cannot be declared until the types
	$TYPE$ and $TERM$ are declared, these require a large portion
	of the ICL HOL system to be available.
\end{description}

%\newpage

The various constructors are used as follows.

{\def\ITEM#1{\item[$#1$ ] }
\begin{description}

\ITEM{icl'ol_text} Text of the new language, text that needs to be
	lexically analysed, parsed, etc.  This text excludes strings
	and character literals.

\ITEM{icl'ol_ML_string} Character strings of the embedded language,
	these are strings as defined in~\cite[section~2.1]{Milner90}.
	These need to be recognised
	by the reader writer to prevent the wrong interpretation of
	characters within them.  Since the reader writer has identified
	them it seems appropriate to reduce the work of later stages of
	the languages analysis by keeping them
	as distinguished parts of the input text.

\ITEM{icl'ol_primed_string} As $icl'ol_ML_string$ but these strings
	are introduced by the single left-hand prime~(~{\tt`}~)
	characters.

\ITEM{icl'ol_HOL_TERM} A Standard~ML expression that yields a HOL
	term.  This value is produced by a term anti quotation within
	HOL text.  Note that the value given here is any Standard~ML
	expression --- it must yield the correct Standard~ML type or an
	error will be reported by the \Compiler{} --- which may contain
	embedded text of another language which will be another list of
	this datatype, which may contain another anti quotation, and so
	on.

\ITEM{icl'ol_HOL_TYPE} As $icl'ol_HOL_TERM$, but for HOL types.

\end{description}}

The string output for the embedded language start symbol, i.e., the
string argument of the constructor $PrettyNames.Starting$ should
contain the name of the routine in item~\ref{RWRoutine} listed above
plus any necessary brackets and the opening ``\verb|icl'ol_text|''.
\ Correspondingly, the string argument of constructor
$PrettyNames.Ending$ should contain the closing brackets and the
closing double quote for the ``\verb|icl'ol_text|''.

The reader writer assumes a simple balancing of the starting and ending
symbols (from the constructors $PrettyNames.Starting$ and
$PrettyNames.Ending$), it does not attempt to check that the correct
symbols are used to start and end an embedded text.  The routines for
the called language are expected to check for the correct matching.  To
assist with this check the interface to the embedded language is a
triple comprising the actual opening symbol, the list described above
and the actual closing symbol; its Standard~ML type is:
$(string\;*\;(icl'ol_input\;list)\;*\;string)$

The parsing routines return strings containing these constructors as
follows.  Note that these rules are built into the code of the
basic reader writer.

\begin{itemize}

\item All routines assume that they are entered when the string
	``\verb|icl'ol_text "|'' has recently been output, other
	characters may also have been output, but the closing double
	quote has not.

\item Any routine that wants a constructor other than
	``\verb|icl'ol_text|'' must close the current string, produce
	its own value, and start a new ``\verb|icl'ol_text|', together
	with the necessary list element separators.

\end{itemize}

%********************************************************************

\subsection{Fixed Strings for Embedding Symbols}
\label{FixedStringsForEmbeddingSymbols}

Section~\ref{DataHeldForPrettyCharacters} defined datatype $NAME_CLASS$
but deferred the description of the strings it is constructed from.

With $Starting$ the first string contains Standard~ML text for the call
of the parsing routine, extension~\ref{ExtParser} above; normally it
should start with an open round bracket so that the whole sequence of
text generated for the embedded text can be used as an expression.  The
second string with $Starting$ contains characters to be added at the
start of the embedded text, it will contain the first characters read
by the routine called in the first string.

Type $Middle$ contains text to be read by the embedded language
parser.

The first string with type $Ending$ contains text to be added to the
end of the embedded text read by the embedded language parser.  The
second string contains Standard~ML text to complete the call of the
embedded language parser.

\bigskip

To explain the three embedding constructs in more detail, part of the HOL
symbols are copied here as an example.

óSML Example
"SHA"		Starting(get_HOL_outer, "(def_HOL_axiomatic",	"(")

"BT"],		Middle "),(* BT *)("

"EHA"		Ending(")", ");")
æ

A HOL axiomatic definition will be presented to the \Compiler{} as
follows.  Consider the definition: ``{\tt\catcode`\%=12 %SHA% \ def
\ %BT% \ pred \ %EHA%}''. \ This will be converted to the
Standard~ML text in the centre column of the following table for
presentation to the \Compiler.

{\catcode`\%=12
\begin{center}
\begin{tabular}{|l|l|p{4in}|}\hline
HOL text&			Standard~ML text&
	Discussion\\\hline\hline
{\tt%SHA%}&			{\tt(def_HOL_axiomatic}&
	String 1 of $Starting$, this must give a function that expects
	a triple of type $(string * icl'ol_input list * string)$ as its
	argument.  The opening bracket here must be matched by string~2
	of $Ending$.\\\hline
&				{\tt("%SHA%",}&	
	The starting symbol is copied as the first element of the
	argument triple\\\hline
&				{\tt[icl'ol_text"}&
	Opening the list of object language segments\\\hline
&				{\tt(}&	
	String 2 of $Starting$\\\hline

{\tt def}&			{\tt def}&
	HOL text is copied\\\hline
{\tt%BT%}&			{\tt),(* BT *)(}&
	Big turn-style is expanded\\\hline
{\tt pred}&			{\tt pred}&
	HOL text is copied\\\hline
{\tt%EHA%}&			{\tt)}&
	String 1 of $Ending$\\\hline
&				{\tt"],}&
	Completion of the list of segments and of the second element of
	the argument triple\\\hline
&				{\tt"%EHA%")}&
	The ending symbol is copied as the last element of the argument
	triple\\\hline
&				{\tt);}&
	String 2 of $Ending$\\\hline
\end{tabular}
\end{center}
}

Axiomatic definitions are here given as a HOL pair, each part is
enclosed in round brackets to avoid any problems when either part is
itself a tuple, hence the extra brackets in string~2 of $Starting$,
string~1 of $Ending$ and in the single string of $Middle$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{HOL READER WRITER}

=SML
structure âHOLReaderWriterá : HOLReaderWriter = struct

open ReaderWriterSupport;
=TEX

%********************************************************************

\subsection{Warning Messages}

Copy of the function in section~\ref{WarningMessages}.

=SML
fun âlocal_errorá (area : string) (id : int) (inserters : (unit -> string) list) : unit = (
	diag_string(
			"*** ERROR "
		^	(string_of_int id)
		^	" from "
		^	area
		^	": "
		^	(get_error_message id (map (fn f => f())inserters))
	)
);
=TEX

%********************************************************************

\subsection{HOL Anti Quotation}

Anti quotation allows text of other languages to be embedded in HOL, it
may be of several forms.  All are introduced by a caret~`\verb|^|'
character, this may be followed by a colon~`\verb|:|' denoting that a
HOL type is being anti quoted, absence of the colon denotes a HOL
term.  The caret and optional colon may be followed by white space and
symbols of type $PrettyNames.Ignore$; the caret and colon may be
separated by white space but not by $PrettyNames.Ignore$ symbols, a
colon in this context is treated as the first character of a
Standard~ML symbolic identifier.  There are then four further
distinctions.

\begin{enumerate}

\item A opening round bracket denotes that a Standard~ML expression
	follows, followed by a matching closing round bracket.

\item \label{AqIdentifier} A Standard~ML identifier may be used, this
	may contain pretty characters or their equivalent keywords.
	Symbols from constructor $PrettyNames.Ignore$ are skipped over,
	those from constructor $PrettyNames.Simple$ may be included
	only in alphanumeric identifiers, all other types are not part
	of the identifier, they have their normal meaning.

\item A starting symbol (i.e., of class $PrettyNames.Starting$) denotes
	an embedding of another language.  This text will be closed by
	an ending symbol.

\item Anything not in the previous three denotes a user error.  In
	general the symbol or character found will be treated as if it
	were the first symbol after an anti quotation, which in many
	cases leads to an empty anti quotation.  This gives the
	following interpretations of various sequences of text.

	\begin{description}

	\item[{\tt(*} ]  Gives an empty anti quotation.  The characters
		are taken as the start of a HOL comment, after the
		comment more HOL text is expected.

	\item[Symbols ] of type $PrettyNames.Middle$, $\ldots Ending$
		and $\ldots Invalid$ are taken as the first symbols
		after the anti quotation.

	\item[Other letters ] are treated as if they start an
		identifier, see item~\ref{AqIdentifier} above.  In
		particular, the sequence ``\verb|^%BH%:|'' is
		considered to be an anti quotation of a HOL term which
		is given by a Standard~ML identifier whose first letter
		is the colon.

	\end{description}

\end{enumerate}

Within these anti quotation categories an initial pretty character or
percent keyword is treated differently from the later ones.  The
initial one may be part of an identifier, or it may embed another
language.  Later ones are only valid as parts of identifiers.
In either case a symbol of type $PrettyNames.Ending$ completes the
anti quotation.

The value returned by this routine is a tuple containing the
conventional list of strings, its second component is of type
$AQ_TERMINATOR$, which will only be non-$AqNull$ if a pretty character
or a keyword that is not part of the anti quotation is found.

=SML
datatype AQ_TERMINATOR	= AqNull
			| AqChar of string
			| AqKeyword of string;

type GET_AQ_RES = string list * AQ_TERMINATOR;
=TEX

=SML
fun âget_HOL_anti_quotationá (R:READER_ENV) (prevA:string list) :  GET_AQ_RES = (
let
	open PrettyNames;

	fun skip_leading_format () : string = (
		let
			val ch = #look_at_next R ()
		in
			if ch = " " orelse ch = "\t" orelse ch = "\n" orelse ch = "\^L"	
			then	(#advance R (); skip_leading_format ())
			else	ch
		end
	);

	fun	aq_term_as_string(AqNull)		= ""
	|	aq_term_as_string(AqChar ch)	= ch
	|	aq_term_as_string(AqKeyword kw)	= "%" ^ kw ^ "%"
	;

	type GET_ID = string list -> GET_AQ_RES;
	type DO_KW = GET_ID -> AQ_TERMINATOR -> PrettyNames.PRETTY_NAME
			-> GET_ID;
=TEX

Second and later keywords are treated here, those of types
$PrettyNames.Simple$ and $\ldots.Ignore$ are are allowed, all others
are treated as the end of the anti quotation.

=SML
	fun	do_later_kw (get_id:GET_ID) _ (names,_,Simple) p =
								get_id ("QQ"^(hd names)^"QQ"::p)
	|	do_later_kw get_id _ (_,_,Ignore) p =		get_id p
	|	do_later_kw _ k (_,_,_) p =			(p, k);
=TEX

Known percent keywords are processed by the keyword function
passed, unknown keywords are reported here.

=SML
	fun do_percent (do_kw:DO_KW) (get_id:GET_ID) prevB = (
		case get_percent_name R
		of (name, Value info, _, ws)
			=> do_kw get_id (AqKeyword name) info (ws :: prevB)
		|  (n, Nil, _, ws)
			=> (
				local_error "get_HOL_anti_quotation" 5008 [fn () => "%" ^ n ^ "%"];
				(" *** ERROR 5008 *** " :: ws :: prevB, AqKeyword n)
			)
	)
=TEX

Anti quoted identifiers may be alphanumeric or symbolic, see
\cite[section~2.4, page~4]{Milner90}, these next two functions gather
the two identifier forms.

=SML
	and	get_alpha_id (prevC:string list) : GET_AQ_RES = (
		case #look_at_next R ()
		of "%"	=>	do_percent do_later_kw get_alpha_id prevC
		|  next	=>
			if ord next > 127
			then (
				#advance R ();
				case find_char next
				of Value info
					=> do_later_kw get_alpha_id (AqChar next) info prevC
				|  Nil	=> (prevC, AqChar next))
			else if		(next >= "A" andalso next <= "Z")
				orelse	(next >= "a" andalso next <= "z")
				orelse	(next >= "0" andalso next <= "9")
				orelse	next = "'"
				orelse	next = "_"
			then
				get_alpha_id ((#advance R ()) :: prevC)
			else
				(prevC, AqNull)
	)
=TEX

=SML
	and	get_sym_id (prevD:string list) : GET_AQ_RES = (
		case #look_at_next R ()
		of "%"	=>	do_percent do_later_kw get_sym_id prevD
		|  next	=>
			if ord next > 127
			then (
				#advance R ();
				case find_char next
				of Value info
					=> do_later_kw get_sym_id (AqChar next) info prevD
				|  Nil	=> (prevD, AqChar next))
			else if contains ["!", "&", "$", "#", "+", "-", "/", ":", "<",
					"=", ">", "?", "@", "\\", "~", "`", "^", "|", "*"] next
			then
				get_sym_id ((#advance R ()) :: prevD)
			else
				(prevD, AqNull)
	);
=TEX

The first keyword of an anti quotation may be part of an identifier
(always alphanumeric); it may start a fragment of an embedded language;
it may be an ignored symbol in which case the first character of the
anti quotation proper must must be found again; all other keywords
complete the anti quotation, which means that an empty anti quotation
has been formed.

=SML
	fun	do_1st_kw _ _ (names,_,Simple) p =
			get_alpha_id ("QQ"^(hd names)^"QQ"::p)
	|	do_1st_kw _ k (_,_,Starting(proc, s1, s2)) p =
			(proc R ((s1 ^ "(\""(*=")=*) ^ (to_ML_string(aq_term_as_string k))
				^ "\", [icl'ol_text\"" ^ s2) :: p), AqNull)
	|	do_1st_kw _ _ (_,_,Ignore) p =
			do_1st_letter p
	|	do_1st_kw _ k (_,_,_) p = (
			local_error "get_HOL_anti_quotation" 5009 [fn () => aq_term_as_string k];
			(" *** ERROR 5009 *** " :: p, k)
		)
=TEX

The first letter of an anti quotation sets the nature of the anti
quotation between the cases described at the top of this section.
Opening round brackets, percent signs, and pretty characters are dealt
with by the routines above.  Other characters denote Standard~ML
identifiers or error cases.  The routines $get_alpha_id$ and
$get_sym_id$ (when given an empty list) will return the identifier
read, or an empty list if no such identifier can be read.  If neither
yields an identifier then the character is reported as an error, it is
left unread for the next routine to deal with, i.e., to include as part
of the HOL text after the anti quotation.

=SML
	and do_1st_letter prevE = (
		case skip_leading_format ()
		of "("	=> (*=)=*)
				(	(#advance R ();
					case get_round_braces get_ML_any R nil
					of nil => (
						local_error "get_HOL_anti_quotation" 5011 [];
						[" *** ERROR 5011 *** "])
					| aq => aq
				) @ prevE, AqNull)
		|  "%"	=>	do_percent do_1st_kw get_alpha_id prevE
		|  next	=>	if ord next > 127
				then
					case find_char next
					of Value info
						=> (#advance R ();
							do_1st_kw get_alpha_id
							(AqChar next)
							info prevE)
					|  Nil	=> (prevE, AqNull)
				else
					case	case get_alpha_id nil
							of (nil, _) => get_sym_id nil
							| id_t => id_t
					of (nil, _) =>	(
						local_error "get_HOL_anti_quotation" 5009
								[fn () => next];
						(" *** ERROR 5009 *** " :: prevE, AqNull))
					| (id, t) =>	(id @ prevE, t)
	);
=TEX

=SML
	val aq_str = (	#advance R (); (* over the "^" *)
			if skip_leading_format () = ":"
			then	(#advance R (); " \", icl'ol_HOL_TYPE(" (*=)"=*))
			else	" \", icl'ol_HOL_TERM(" (*=)"=*));

	val (prevF, terminator) = do_1st_letter (aq_str :: prevA)
in
	((*=(=*) "), icl'ol_text\"" (*="=*) :: prevF, terminator)
end);
=TEX

%********************************************************************

\subsection{Recursive HOL Parser}

Brackets within HOL text need only be examined to see if they relate to
comments, all the other forms of bracket can simple be passed on for
the HOL lexical analyser and parser to deal with.

{\ftlinepenalty=9999
=SML prev
fun âget_HOL_anyá (depth:int) (R:READER_ENV) (prevA:string list) : string list= (
let
	open PrettyNames;

	val get_more = get_HOL_any depth;

	fun	do_keyword _ (_,Value ch,Simple) p		= get_more R ((to_ML_string ch) :: p)
	|	do_keyword _ (names,Nil,Simple) p		= get_more R ("%" ^ (hd names) :: p)
	|	do_keyword k (_,ch_opt,Starting _) p		= (
			get_HOL_any (depth+1) R
				(" " ^ (to_ML_string(case ch_opt of Nil => k | Value ch => ch))
				^ " " :: p))
	|	do_keyword _ (_,_,Middle str) p		= get_more R (str :: p)
	|	do_keyword k (_,ch_opt,Ending(s1, s2)) p	= (
			if depth = 1
			then
				(*=([=*) (s1 ^ "\"], \"" ^ k ^ "\")" ^ s2) :: p (*="=*)
			else
				get_HOL_any (depth-1) R
				(" " ^ (to_ML_string (case ch_opt of Nil => k | Value ch => ch))
				^ " " :: p))
	|	do_keyword _ (_,_,Ignore) p			= get_more R p
	|	do_keyword k (names,_,Invalid) p		= (
			local_error "get_more" 5002[fn () => k];
			get_more R (" *** ERROR 5002 *** ":: p));

	fun do_string ML_string = (
		#advance R ();
		let	val (read_string, ol_name) =
				if ML_string
				then	(get_ML_string, "icl'ol_ML_string")
				else	(get_primed_string, "icl'ol_primed_string")
		in
			get_more R (	", icl'ol_text\"" (*="=*)
				:: (read_string R
					(ol_name :: "\", " :: prevA))) (*="=*)
		end
	);

	fun	handle_keyword (name, Value info, _, ws) prevB = (
			do_keyword ("%" ^ name ^ "%") info (ws :: prevB))
	|	handle_keyword (n, Nil, _, ws) prevB = (
			local_error "get_HOL_any" 5003 [fn () => n, fn () =>
							implode(rev(" ... " :: (prevB to 10)))];
			get_more R (" *** ERROR 5003 *** " :: ws :: prevB)
	);

	fun handle_p_char ch prevC = (
		case find_char ch
		of Value info	=> do_keyword (to_ML_string ch) info prevC
		|  Nil		=> (local_error "get_HOL_any" 5004
						[fn () => ch,
						fn () => string_of_int(ord ch)];
				get_ML_any R (" *** ERROR 5004 *** " :: prevC))
	);

	val next = #look_at_next R ()
in
	case next
	of "("	=>	(	#advance R ();
				if #look_at_next R () = "*"
				then
					(skip_comment R; get_more R prevA)
				else
					get_more R ( "(" ::  prevA))
	|  "\""	=>	do_string true (*="=*)
	|  "`"	=>	do_string false
	|  "\t"	=>	skip_format get_more R prevA next
	|  "\n"	=>	skip_format get_more R prevA next
	|  " "	=>	skip_format get_more R prevA next
	|  "\^L" =>	skip_format get_more R prevA next
	|  "\^D" =>	prevA
	|  "%"	=>	handle_keyword (get_percent_name R) prevA
	|  "^"	=> (	case get_HOL_anti_quotation R prevA
			of (pp, AqNull) => get_more R pp
			| (pp, AqChar ch) => handle_p_char ch pp
			| (pp, AqKeyword kw) => handle_keyword(kw,
					PrettyNames.find_name kw,
					true(*actually, Don't care*), "") pp)
	|  _	=>	let
				val ch = #advance R ();
				val ord_ch = ord ch
			in
				if ord_ch > 127
				then	handle_p_char ch prevA
				else	get_more R (ch :: prevA)
			end
end);
=TEX
}

=SML
fun âget_HOL_outerá (R:READER_ENV) (prev:string list) : string list= (
	get_HOL_any 1 R prev
);
=TEX

%********************************************************************

\subsection{Pretty Characters for HOL} \label{PrettyCharactersForHOL}

Box drawing, first the symbols that start a box.  Note that many
of these symbols have no interpretation in HOL or Standard~ML.
The Standard~ML comments below that contain only a string quote
`~{\tt"}~' are present to make the number of such quotes even
on each line.

The bracketing conventions used within HOL text need explaining.
Simple HOL text used as term or type expressions is not bracketed.  The
definitional HOL texts include brackets, these are generally used in a
style where the user enters the five components: {\em start,
definitions, where, predicate} and {\em finish.}  The {\em start,
where} and {\em finish\/} are the symbols defined below.  The users
input is translated to give a HOL term comprising the pair ``({\em
definitions\/}),~({\em predicate\/})'' which is used as the argument of
a Standard~ML function to achieve the definition.

=SML
local
open ReaderWriterSupport.PrettyNames;

in
val _ = add_new_symbols [
=TEX

Box drawing, symbols that start a box.

=SMLLITERAL
	([	"<"],		Value "»",
			Starting(get_HOL_outer, "(HOL_text",		"")),
	([	"SHA"],	Value "È",
			Starting(get_HOL_outer, "(def_HOL_axiomatic",	"(")),
	([	"SHIA"],	Value "ç",
			Starting(get_HOL_outer, "(def_HOL_infix",		"(")),
	([	"SHS"],	Value "Ç",
			Starting(get_HOL_outer, "(def_HOL_schema",	"(")),
=TEX

Box drawing, symbols that complete a box.  Some of the pretty
characters can denote the end of several different types of box, note
the names used for end-of-Z boxes below.

=SMLLITERAL
	([	">"],		Value "¼",			Ending("", ")")),

	([	"EHS",
		"EZC",
		"EZS"],	Value "Ê",			Ending(")", ");")),
	([	"EHA",
		"EZA"],	Value "Ë",			Ending(")", ");")),
=TEX

Box drawing, symbols used within boxes.

=SMLLITERAL
	([	"BBR"],	Value "à",			Ignore),
	([	"BH"],		Value "Í",			Ignore),
	([	"BHH"],	Value "ü",			Ignore),
	([	"BT"],		Value "É",			Middle "),(* BT *)("),
	([	"BTR"],	Value "ß",			Ignore),
	([	"BV"],		Value "Ý",			Ignore)
]
end (* of local *);
=TEX

%********************************************************************

\subsection{HOL Reader Writer --- Completion}

=SML
end (* of structure HOLReaderWriter *);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{FINALE}

We wish to use $usefile$ as the file loading facility when building
subsequent files into the {\tt hol.db}.  $Install_file_loader$ is the
function that is used by the build script for {\tt hol.db} to load a
file to compile.  As a side effect, a large portion of this structure
is tested during the creation of the rest of the system.

=SML
Install_file_loader := (fn x => (diag_string ("usefile "^ x); usefile x));
=TEX

Now make some checks that things have been built properly.

=SMLLITERAL
let
	fun check_name (n, l) = (
		case ReaderWriterSupport.PrettyNames.find_name n
		of Nil => n :: l
		| _ => l
	);

	fun check_char (c, l) = (
		case ReaderWriterSupport.PrettyNames.find_char c
		of Nil => c :: l
		| _ => l
	);

	fun wrap nil title = ()
	| wrap l title = list_diag_string("Failed to load the" :: title :: l);

	val bad_names = fold check_name ["<", "SHS", "lambda", "fn"] nil;
	val bad_chars = fold check_char ["»", "Ç", ""] nil
in
	wrap bad_names "keywords:";
	wrap bad_chars "pretty characters:"
end;
=TEX

We will wish to use $useterminal$ from now onwards, unless explicitly
aborted by the user.

=SML
useterminal();
=TEX

Any Standard~ML text from here to the end of the file will be ignored
because the call of $useterminal$ has replaced the PolyML reading
function with the code within $useterminal$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\newpage

\makeatletter
\def\refstepcounter#1{\stepcounter{#1}\global\edef\@currentlabel{\csname
	p@#1\endcsname\csname the#1\endcsname}}
\makeatother

\twocolumn[\section{INDEX}] \label{Index}

\footnotesize
\printindex

\onecolumn

\end{document}
