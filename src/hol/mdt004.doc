=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Release 1 ICL HOL: Module Tests for Derived Terms}  %% Mandatory field
\def\TPPheadtitle{Release 1 ICL HOL \cr Module Tests for Derived Terms}
\TPPref{DS/FMU/IED/MDT004}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the derived term functions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue 1.1]
First draft version.
\end{description}
%\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the derived term functions, required by Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The design is in \cite{DS/FMU/IED/DTD004}
and it is
implemented in \cite{DS/FMU/IED/IMP004}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD004},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD004},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP004}.
\subsubsection{Deficiencies}
The coverage of the tests, as called for by the test specification, may currently be incomplete.

\section{UTILITIES USED FOR TESTING}
Flatten a list of strings into a single string.
=SML
fun flat_strings (ss: string list) : string = implode(flat (map explode ss));
=TEX
A simple pair of printing routines for $TERM$ and $TYPE$.
=SML
local
fun lprint_TYPE t = 
let
	fun aux (mk_vartype s) = " " ^ s
	| aux (mk_type ("ã",[t1,t2])) = (
		"(" ^ aux t1 ^ " ã" ^ aux t2 ^")"
	) | aux (mk_type ("â",[t1,t2])) = (
		"(" ^ aux t1 ^ " â" ^ aux t2 ^")"
	) | aux (mk_type (ty,[])) = (
		" " ^ ty
	) | aux (mk_type (c,tl)) = "((" ^ flat_strings (map ((fn x => x ^", ") 
		o aux) tl)^ ")" ^ c ^ ")"
in
	(":" ^ aux t)
end;
in
val print_TYPE: TYPE -> unit = diag_string o lprint_TYPE;

fun print_TERM (tm: TERM): unit =
let fun print_DEST_TERM (Comb(t1,t2)) = (
	"Comb (" ^ print_DEST_TERM(dest_TERM t1) ^", " ^
		print_DEST_TERM(dest_TERM t2) ^ ")"
) | print_DEST_TERM (Const(s,ty)) = s ^ lprint_TYPE ty
| print_DEST_TERM (Var(s,ty)) = s ^ lprint_TYPE ty
| print_DEST_TERM (Abs(v,b)) = (
	let val (vs,vt) = dest_var v
	in
	"ç " ^ vs ^ lprint_TYPE vt ^ " é " ^ print_DEST_TERM (dest_TERM b)
	end);
in
	diag_string(print_DEST_TERM (dest_TERM tm))
end;
end; (* local lprint_TYPE *)
=TEX
Then a term printing function that doesn't give the type information.
=SML
fun print_TERM1 (tm: TERM): unit =
let fun print_DEST_TERM (Comb(t1,t2)) = (
	"(" ^ print_DEST_TERM(dest_TERM t1) ^ " " ^
		print_DEST_TERM(dest_TERM t2) ^ ")"
) | print_DEST_TERM (Const(s,ty)) = s
| print_DEST_TERM (Var(s,ty)) = s
| print_DEST_TERM (Abs(v,b)) = (
	let val (vs,vt) = dest_var v
	in
	"(ç " ^ vs ^ " é " ^ print_DEST_TERM (dest_TERM b) ^")"
	end);
in
	diag_string(print_DEST_TERM (dest_TERM tm))
end;
=TEX
Print something of type $DERIV\_TERM$.
=SML
fun print_DERIV_TERM ((DVar (v,ty)) : DERIV_TERM) : unit = (
	diag_string "DVar"; diag_string v; print_TYPE ty
) | print_DERIV_TERM (DConst (c,ty)) = (
	diag_string "DConst" ; diag_string c; print_TYPE ty
) | print_DERIV_TERM (DComb(f, a)) = (
	diag_string "DComb"; print_TERM1 f; print_TERM1 a
) | print_DERIV_TERM (DAbs(v,b)) = (
	diag_string "DAbs"; print_TERM1 v; print_TERM1 b
) | print_DERIV_TERM (DEq(e1,e2)) = (
	diag_string "DEq"; print_TERM1 e1; print_TERM1 e2
) | print_DERIV_TERM (Dä(e1,e2)) = (
	diag_string "Dä"; print_TERM1 e1; print_TERM1 e2
) | print_DERIV_TERM (Då v) = (
	diag_string "Då"; print_TERM1 v
) | print_DERIV_TERM (DPair(p1,p2)) = (
	diag_string "DPair"; print_TERM1 p1; print_TERM1 p2
) | print_DERIV_TERM (DÄ(p1,p2)) = (
	diag_string "DÄ"; print_TERM1 p1; print_TERM1 p2
) | print_DERIV_TERM (DÅ(p1,p2)) = (
	diag_string "DÅ"; print_TERM1 p1; print_TERM1 p2
) | print_DERIV_TERM (DÇ(p1,p2)) = (
	diag_string "DÇ"; print_TERM1 p1; print_TERM1 p2
) | print_DERIV_TERM (DLet (ttl, b)) =(
	diag_string "DLet";map (print_TERM1 ** print_TERM1) ttl; print_TERM1 b
) | print_DERIV_TERM (DSet (a, b)) = (
	diag_string "DSet";print_TERM1 a; print_TERM1 b
) | print_DERIV_TERM (DEnumSet (ttl, ty)) =(
	diag_string "DEnumSet";map (print_TERM1) ttl; print_TYPE ty
) | print_DERIV_TERM (DList (ttl, ty)) =(
	diag_string "DList";map (print_TERM1) ttl; print_TYPE ty
) | print_DERIV_TERM (DÉ (a, b)) =(
	diag_string "DÉ";print_TERM1 a; print_TERM1 b
) | print_DERIV_TERM (DÑ (a, b)) =(
	diag_string "DÑ";print_TERM1 a; print_TERM1 b
) | print_DERIV_TERM (DSelect (a, b)) =(
	diag_string "DSelect";print_TERM1 a; print_TERM1 b
) | print_DERIV_TERM (DIf(c,b1,b2)) =(
	diag_string "DIf"; print_TERM1 c; print_TERM1 b1; print_TERM1 b2);
=TEX
\section{THE TESTS}
=SML
val NUM = mk_type("NUM",[]);
print_TYPE (mk_pair_type (BOOL, NUM));
val tv1 = mk_vartype "'tv1";
val tv2 = mk_vartype "'tv2";
val tv3 = mk_vartype "'tv3";
dest_fun_type tv3;
dest_fun_type (mk_fun(BOOL,NUM));
val v1 = mk_var("v1", tv1);
val v2 = mk_var("v2", tv2);
val v3 = mk_var("v3", tv3);
val c1 = mk_const("c1",BOOL);
val c2 = mk_const("c2",mk_type("triple",[tv1,tv2,tv3]));
val c3 = mk_const("c3",mk_type("triple",[tv3,BOOL,tv1]));
val T = mk_const("T",BOOL);
val F = mk_const("F",BOOL);

print_TERM (mk_pair(c1, c2));
dest_pair(mk_pair(c1,c2));
dest_pair c1; (* fails *)
is_pair c1; 
is_pair(mk_pair(c1,c2));

print_TERM (mk_abs(v1, c1));
print_TERM1 (mk_abs(mk_pair(v1,v2), c1));
print_TERM1 (mk_abs(mk_pair(mk_pair(v1,v2),mk_pair(v2,v3)), c1));
(print_TERM1 ** print_TERM1) (dest_abs(mk_abs(v1, c1)));
(print_TERM1 ** print_TERM1) (dest_abs(mk_abs(mk_pair(v1,v2), c1)));
(print_TERM1 ** print_TERM1) (dest_abs(mk_abs(mk_pair(mk_pair(v1,v2),
	mk_pair(v2,v3)), c1)));
dest_abs c1; (* fails *)
mk_abs(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)), T); 

print_TERM1 (mk_Ä(T,F));
print_TERM1 (mk_Ä(c2,F)); (* fails *)
(print_TERM1 ** print_TERM1)(dest_Ä(mk_Ä(T,F)));
is_Ä c1; 
is_Ä(mk_Ä(T,F));
dest_Ä c1; (* fails *)
print_TERM1 (list_mk_Ä[]); (* fails *)
print_TERM1 (list_mk_Ä[T, F, c1]);
print_TERM1 (list_mk_Ä[T, F, c2]); (* fails *)
map print_TERM1 (strip_Ä c2); 
map print_TERM1 (strip_Ä (list_mk_Ä[T, F, c1])); 

print_TERM1 (mk_Å(T,F));
print_TERM1 (mk_Å(c2,F)); (* fails *)
(print_TERM1 ** print_TERM1)(dest_Å(mk_Å(T,F)));
(dest_Å(mk_Ä(T,F))); (* fails *)
is_Å c1; 
is_Å(mk_Å(T,F)); 
is_Å(mk_Ä(T,F));
print_TERM1 (list_mk_Å[]); (* fails *)
print_TERM1 (list_mk_Å[T, F, c1]);
print_TERM1 (list_mk_Å[T, F, c2]); (* fails *)
map print_TERM1 (strip_Å c2); 
map print_TERM1 (strip_Å (list_mk_Å[T, F, c1])); 

print_TERM1(mk_Ç(T,F));
print_TERM1(mk_Ç(c2,c2)); (* fails *)
(print_TERM1 ** print_TERM1)(dest_Ç (mk_Ç(T,F)));
(print_TERM1 ** print_TERM1)(dest_Ç (mk_eq(T,F)));
(print_TERM1 ** print_TERM1)(dest_Ç (mk_eq(c2,c2))); (* fails *)

print_TERM1 (mk_If(c1, T, F));
print_TERM1 (mk_If(c2, T, F)); (* fails *)
print_TERM1 (mk_If(T, T, c2)); (* fails *)
(fn (x,y,z) => (print_TERM1 x, print_TERM1 y, print_TERM1 z)) 
	(dest_If(mk_If(c1, T, F)));
dest_If c1; (* fails *)
is_If (mk_If(c1, T, F));
is_If(mk_Ä(T,F));
=TEX
The following function will almost always have the first and third outputs the same.
It won't when locally defining a function with arguments.
The second output gives the structure of the destroyed term.
=SML
fun test_let base = 
(let val s = base
in
	(print_TERM1 (mk_let s),
	 dest_let(mk_let s), 
	 print_TERM1 (mk_let(dest_let(mk_let s))))
end);

(mk_let ([],T)) TERM_eq T;
test_let ([(v1, mk_const("cv1",tv1))], T);
test_let ([(v1, mk_const("cv1",tv1)),
		(v2, mk_const("cv2",tv2))], T);
test_let ([(mk_pair(v1, mk_var("v11",BOOL)), mk_const("cv1",mk_pair_type(tv1, BOOL))),
		(v2, mk_const("cv2",tv2))], T);
test_let ([(mk_comb (mk_comb(mk_var("lv1",mk_fun(
	mk_pair_type(tv1,tv2), mk_fun(tv3, BOOL))),
		mk_pair(v1,v2)), v3), c1),
		(v2, mk_const("cv2",tv2))],F);
dest_let c1; (* fails *)
mk_let([(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), 
	mk_const("v2",BOOL)), T)], T); (* fails *)
mk_let([(mk_comb(mk_var("v1",mk_fun(BOOL,NUM)), 
	mk_var("v2",BOOL)), T)], T); (* fails *)
mk_let([(v2, T)], T); (* fails *)

dest_let (mk_comb(mk_comb(
			 mk_const("Let",
			 mk_fun(BOOL,mk_fun(BOOL,BOOL))),
			 c1), c1)); (* fails *)
is_let c1; 
is_let(mk_let([(v1, mk_const("cv1",tv1))], T));
print_TERM1 (list_mk_let([[(v1, mk_const("cv1",tv1))],
	[(v2, mk_const("cv2",tv2))]], T));
print_TERM1 (list_mk_let(strip_let(list_mk_let([[(v1, mk_const("cv1",tv1))],
	[(v2, mk_const("cv2",tv2))]], T))));

print_TERM (mk_enum_set []);
print_TERM1 (mk_enum_set [T]);
print_TERM1 (mk_enum_set [T, F, c1]);
(mk_enum_set [T, F, c2]); (* fails *)
map print_TERM1 (dest_enum_set(mk_enum_set [T, F, c1]));
dest_enum_set c1; (* fails *)
is_enum_set (mk_enum_set [T, F, c1]);
is_enum_set T;
print_TERM1(mk_set(v1, T));
print_TERM1(mk_set(mk_pair(v1,v2), T));
mk_set(v1,v1); (* fails *)
(print_TERM1 ** print_TERM1)(dest_set(mk_set(mk_pair(v1,v2), T)));
dest_set c1; (* fails *)
is_set T; 
is_set (mk_set(v1, T));

print_TERM1 (mk_å T);
(mk_å c2); (* fails *)
dest_å c1; (* fails *)
print_TERM1(dest_å(mk_å T));

print_TERM1(mk_É(v1, T));
print_TERM1(mk_É(mk_pair(v1,v2), T));
mk_É(v1,v1); (* fails *)
mk_É(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)), T);
(print_TERM1 ** print_TERM1)(dest_É(mk_É(mk_pair(v1,v2), T)));
dest_É c1; (* fails *)
is_É T; 
is_É (mk_É(v1, T));
mk_É(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)), T); (* fails *)

print_TERM1(mk_Ñ(v1, T));
print_TERM1(mk_Ñ(mk_pair(v1,v2), T));
mk_Ñ(v1,v1); (* fails *)
mk_Ñ(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)), T);
(print_TERM1 ** print_TERM1)(dest_Ñ(mk_Ñ(mk_pair(v1,v2), T)));
dest_Ñ c1; (* fails *)
is_Ñ T; 
is_Ñ (mk_Ñ(v1, T));
mk_Ñ(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)), T); (* fails *)

print_TERM1(mk_select(v1, T));
print_TERM1(mk_select(mk_pair(v1,v2), T));
mk_select(v1,v1); (* fails *)
mk_select(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)), T); 
	(* fails *)
(print_TERM1 ** print_TERM1)(dest_select(mk_select(mk_pair(v1,v2), T)));
dest_select c1; (* fails *)
is_select T; 
is_set (mk_select(v1, T));

print_TERM(mk_list[]);
print_TERM1(mk_list[T,F,c1]);
print_TERM1(mk_list[T,F,c2]); (* fails *)
dest_list c1; (* fails *)
dest_list(mk_list[T,F,c1]);
is_list(mk_list[]); 
is_list(mk_list[T,F]);
is_list T;
=TEX
The following function decomposes and recomposes a term using
$?\_DERIV\_TERM$.
The first and third outputs should be identical.
The fourth output should always be $true$.
=SML
fun test_DT (tm:TERM) : bool = let
	val v1 = print_TERM1 tm;
	val v2 = diag_string "Becomes>";
	val v3 = print_DERIV_TERM (mk_DERIV_TERM tm);
	val v4 = diag_string "Decomposed>";
	val symd = dest_DERIV_TERM(mk_DERIV_TERM tm);
	val v5 = print_TERM1 symd
in
	tm TERM_eq symd
end;
test_DT(mk_var ("v2",BOOL));
test_DT(mk_const ("c2",BOOL));
test_DT(mk_comb (mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)));
test_DT(mk_abs (v1, c1));
test_DT(mk_pair(c1, c2));
test_DT(mk_Ä(T,F));
test_DT(mk_Å(T,F));
test_DT(mk_Ç(T,F));
test_DT(mk_eq(T,F));
test_DT(mk_eq(c2,c2));
test_DT(mk_If(c1, T, F));
test_DT(mk_let([(v1, mk_const("cv1",tv1)),
		(v2, mk_const("cv2",tv2))], T));
test_DT(mk_enum_set [T, F, c1]);
test_DT(mk_set(mk_pair(v1,v2), T));
test_DT(mk_å T);
test_DT(mk_É(mk_pair(v1,v2), T));
test_DT(mk_Ñ(v1, T));
test_DT(mk_select(mk_pair(v1,v2), T));
test_DT(mk_list[T,F,c1]);
test_DT (list_mk_comb(
	mk_const("F",mk_fun(BOOL,mk_fun(BOOL, mk_fun(BOOL, BOOL)))),
	[T, F , c1]));;
test_DT (list_mk_comb(
	mk_const("f",mk_fun(BOOL,mk_fun(BOOL,mk_fun(BOOL, mk_fun(BOOL, BOOL))))),
	[T, F , c1, T]));;
test_DT (list_mk_comb(mk_const("Insert",
	mk_fun(BOOL,mk_fun(mk_type("SET",[BOOL]),mk_type("SET",[BOOL])))),
	[T, mk_var("S",mk_type("SET",[BOOL]))]));
test_DT (mk_const("Nil",mk_type("LIST",[BOOL])));
test_DT (mk_const("Empty",mk_type("SET",[BOOL])));
test_DT (mk_const("Empty",BOOL));
=TEX
\subsection{End of Tests}
=SML
PolyML.quit();
=TEX
\end{document}
