=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Derived Terms}  %% Mandatory field
\def\TPPheadtitle{Module Tests for Derived Terms}
\TPPref{DS/FMU/IED/MDT004}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the derived term functions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue 1.1]
First draft version.
\item [Issue 1.2]
Changed to reflect changes in  issue 1.5 of \cite{DS/FMU/IED/DTD004}.
\item [Issue 1.3]
Changed to reflect changes in  issue 1.6 of \cite{DS/FMU/IED/DTD004}.
\item [Issue 1.4]
Changed to reflect changes in  issue 1.7 of \cite{DS/FMU/IED/IMP004}.
\item [Issue 1.5]
Changed to reflect changes in  issue 1.8 of \cite{DS/FMU/IED/IMP004}.

\end{description}
%\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the derived term functions, required by Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The design is in \cite{DS/FMU/IED/DTD004}
and it is
implemented in \cite{DS/FMU/IED/IMP004}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD004},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD004},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP004}.
\subsubsection{Deficiencies}
The coverage of the tests, as called for by the test specification, may currently be incomplete.

\section{UTILITIES USED FOR TESTING}
A simple pair of printing routines for $TERM$ and $TYPE$.
=SML
local
fun lprint_type t = (
let
	fun aux ty = (
	if is_vartype ty then 
		(" " ^ dest_vartype ty)
	else if is_funtype ty then
		(let val(t1,t2) = dest_funtype ty
		in
		( "(" ^ aux t1 ^ " ã" ^ aux t2 ^")" )
		end)
	else (let 
		fun aux1 ("â",[t1,t2]) = (
		"(" ^ aux t1 ^ " â" ^ aux t2 ^")"
		) | aux1 ((s,[])) = (
		" " ^ s
		) | aux1 ((s,tyl)) = (
		"((" ^ implode (map ((fn x => x ^", ") o aux) tyl)^ ")" ^ s ^ ")")
		in
			aux1 (dest_type ty)
		end)
	)
in
	(":" ^ aux t)
end);
in
val ‚print_type· = diag_string o lprint_type;

fun ‚print_term· (tm: TERM) =
let fun print_simple_dest_term (Comb(t1,t2)) = (
	"Comb (" ^ print_simple_dest_term(simple_dest_term t1) ^", " ^
		print_simple_dest_term(simple_dest_term t2) ^ ")"
) | print_simple_dest_term (Const(s,ty)) = s ^ lprint_type ty
| print_simple_dest_term (Var(s,ty)) = s ^ lprint_type ty
| print_simple_dest_term (Abs(v,b)) = (
	let val (vs,vt) = dest_var v
	in
	"ç " ^ vs ^ lprint_type vt ^ " é " ^ print_simple_dest_term (simple_dest_term b)
	end);
in
	diag_string(print_simple_dest_term (simple_dest_term tm))
end;
end;
=TEX
Then a term printing function that doesn't give the type information.
=SML
fun ‚print_term1· (tm: TERM): unit =
let fun print_simple_dest_term (Comb(t1,t2)) = (
	"(" ^ print_simple_dest_term(simple_dest_term t1) ^ " " ^
		print_simple_dest_term(simple_dest_term t2) ^ ")"
) | print_simple_dest_term (Const(s,ty)) = s
| print_simple_dest_term (Var(s,ty)) = s
| print_simple_dest_term (Abs(v,b)) = (
	let val (vs,vt) = dest_var v
	in
	"(ç " ^ vs ^ " é " ^ print_simple_dest_term (simple_dest_term b) ^")"
	end);
in
	diag_string(print_simple_dest_term (simple_dest_term tm))
end;
=TEX
Print something of type $DERIV\_TERM$.
=SML
fun ‚print_dest_term· ((DVar (v,ty)) : DEST_TERM) : unit = (
	diag_string "DVar"; diag_string v; print_type ty
) | print_dest_term (DConst (c,ty)) = (
	diag_string "DConst" ; diag_string c; print_type ty
) | print_dest_term (DComb(f, a)) = (
	diag_string "DComb"; print_term1 f; print_term1 a
) | print_dest_term (DAbs(v,b)) = (
	diag_string "DAbs"; print_term1 v; print_term1 b
) | print_dest_term (DEq(e1,e2)) = (
	diag_string "DEq"; print_term1 e1; print_term1 e2
) | print_dest_term (Dä(e1,e2)) = (
	diag_string "Dä"; print_term1 e1; print_term1 e2
) | print_dest_term (Då v) = (
	diag_string "Då"; print_term1 v
) | print_dest_term (DPair(p1,p2)) = (
	diag_string "DPair"; print_term1 p1; print_term1 p2
) | print_dest_term (DÄ(p1,p2)) = (
	diag_string "DÄ"; print_term1 p1; print_term1 p2
) | print_dest_term (DÅ(p1,p2)) = (
	diag_string "DÅ"; print_term1 p1; print_term1 p2
) | print_dest_term (DÇ(p1,p2)) = (
	diag_string "DÇ"; print_term1 p1; print_term1 p2
) | print_dest_term (DLet (ttl, b)) =(
	diag_string "DLet";map (print_term1 ** print_term1) ttl; print_term1 b
) | print_dest_term (DSet (a, b)) = (
	diag_string "DSet";print_term1 a; print_term1 b
) | print_dest_term (DEnumSet (ttl, ty)) =(
	diag_string "DEnumSet";map (print_term1) ttl; print_type ty
) | print_dest_term (DList (ttl, ty)) =(
	diag_string "DList";map (print_term1) ttl; print_type ty
) | print_dest_term (DÉ (a, b)) =(
	diag_string "DÉ";print_term1 a; print_term1 b
) | print_dest_term (DÑ (a, b)) =(
	diag_string "DÑ";print_term1 a; print_term1 b
) | print_dest_term (Dá (a, b)) =(
	diag_string "Dá";print_term1 a; print_term1 b
) | print_dest_term (DIf(c,b1,b2)) =(
	diag_string "DIf"; print_term1 c; print_term1 b1; print_term1 b2);
=TEX
\section{THE TESTS}
When determining whether the output from these tests is
the same as for some previous implementation,
the differences in information relating to the value of declared variables
may be ignored, as this reflects the internal implementation
of the values.
Differences in values printed by $print\_TERM$ and $print\_TYPE$,
however, should not change without justification.

=SML
val NUM = mk_type("NUM",[]);
print_type (mk_pair_type (BOOL, NUM));
val tv1 = mk_vartype "'tv1";
val tv2 = mk_vartype "'tv2";
val tv3 = mk_vartype "'tv3";
val v1 = mk_var("v1", tv1);
val v2 = mk_var("v2", tv2);
val v3 = mk_var("v3", tv3);
val c1 = mk_const("c1",BOOL);
val c2 = mk_const("c2",mk_type("triple",[tv1,tv2,tv3]));
val c3 = mk_const("c3",mk_type("triple",[tv3,BOOL,tv1]));
val T = mk_const("T",BOOL);
val F = mk_const("F",BOOL);

T = mk_T; (* true *)
F = mk_F; (* true *)
is_T T; (* true *)
is_T F; (* false *)
is_F F; (* true *)
is_F v1; (* false *)

print_term (mk_pair(c1, c2));
(print_term ** print_term) (dest_pair(mk_pair(c1,c2)));
dest_pair c1; (* fails *)
is_pair c1; (* false *)
is_pair(mk_pair(c1,c2));

print_term (mk_abs(v1, c1));
print_term1 (mk_abs(mk_pair(v1,v2), c1));
print_term1 (mk_abs(mk_pair(mk_pair(v1,v2),mk_pair(v2,v3)), c1));
(print_term1 ** print_term1) (dest_abs(mk_abs(v1, c1)));
(print_term1 ** print_term1) (dest_abs(mk_abs(mk_pair(v1,v2), c1)));
(print_term1 ** print_term1) (dest_abs(mk_abs(mk_pair(mk_pair(v1,v2),
	mk_pair(v2,v3)), c1)));
dest_abs c1; (* fails *)
mk_abs(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)), T);  (* fails *)
print_term1 (list_mk_abs([v1,v2],c1));
strip_abs(list_mk_abs([v1,v2],c1)) = ([v1,v2],c1);

print_term1 (mk_Ä(T,F));
print_term1 (mk_Ä(c2,F)); (* fails *)
(print_term1 ** print_term1)(dest_Ä(mk_Ä(T,F)));
is_Ä c1; (* false *)
is_Ä(mk_Ä(T,F));
dest_Ä c1; (* fails *)
print_term1 (list_mk_Ä[]); (* fails *)
print_term1 (list_mk_Ä[T, F, c1]);
print_term1 (list_mk_Ä[T, F, c2]); (* fails *)
map print_term1 (strip_Ä c2); 
map print_term1 (strip_Ä (list_mk_Ä[T, F, c1])); 

print_term1 (mk_Å(T,F));
print_term1 (mk_Å(c2,F)); (* fails *)
(print_term1 ** print_term1)(dest_Å(mk_Å(T,F)));
(dest_Å(mk_Ä(T,F))); (* fails *)
is_Å c1; 
is_Å(mk_Å(T,F)); 
is_Å(mk_Ä(T,F));
print_term1 (list_mk_Å[]); (* fails *)
print_term1 (list_mk_Å[T, F, c1]);
print_term1 (list_mk_Å[T, F, c2]); (* fails *)
map print_term1 (strip_Å c2); 
map print_term1 (strip_Å (list_mk_Å[T, F, c1])); 

print_term1(mk_Ç(T,F));
print_term1(mk_Ç(c2,c2)); (* fails *)
(print_term1 ** print_term1)(dest_Ç (mk_Ç(T,F)));
(print_term1 ** print_term1)(dest_Ç (mk_eq(T,F)));
(print_term1 ** print_term1)(dest_Ç (mk_eq(c2,c2))); (* fails *)
is_Ç(mk_Ç(T,F));
is_Ç(mk_eq(T,F)); (* true *)
is_Ç(mk_eq(c2,c2)); (* false *)


print_term1 (mk_if(c1, T, F));
print_term1 (mk_if(c2, T, F)); (* fails *)
print_term1 (mk_if(T, T, c2)); (* fails *)
(fn (x,y,z) => (print_term1 x, print_term1 y, print_term1 z)) 
	(dest_if(mk_if(c1, T, F)));
dest_if c1; (* fails *)
is_if (mk_if(c1, T, F));
is_if(mk_Ä(T,F));
=TEX
The following function will almost always have the first and last outputs the same.
The middle outputs give contents, and the ``val it $=$'' the structure of the destroyed term.
=SML
fun test_let base = 
(let val s = base
in
	(print_term1 (mk_let s),
	 (map (print_term ** print_term) ** print_term) (dest_let(mk_let s)), 
	 print_term1 (mk_let(dest_let(mk_let s))))
end);

(mk_let ([],T)) = T;
test_let ([(v1, mk_const("cv1",tv1))], T);
test_let ([(v1, mk_const("cv1",tv1)),
		(v2, mk_const("cv2",tv2))], T);
test_let ([(mk_pair(v1, mk_var("v11",BOOL)), mk_const("cv1",mk_pair_type(tv1, BOOL))),
		(v2, mk_const("cv2",tv2))], T);
test_let ([(mk_comb (mk_comb(mk_var("lv1",mk_fun(
	mk_pair_type(tv1,tv2), mk_fun(tv3, BOOL))),
		mk_pair(v1,v2)), v3), c1),
		(v2, mk_const("cv2",tv2))],F);
dest_let c1; (* fails *)
mk_let([(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), 
	mk_const("v2",BOOL)), T)], T); (* fails *)
mk_let([(mk_comb(mk_var("v1",mk_fun(BOOL,NUM)), 
	mk_var("v2",BOOL)), T)], T); (* fails *)
mk_let([(v2, T)], T); (* fails *)

dest_let (mk_comb(mk_comb(
			 mk_const("Let",
			 mk_fun(BOOL,mk_fun(BOOL,BOOL))),
			 c1), c1)); (* fails *)
is_let c1; (* false *)
is_let(mk_let([(v1, mk_const("cv1",tv1))], T));
print_term1 (list_mk_let([[(v1, mk_const("cv1",tv1))],
	[(v2, mk_const("cv2",tv2))]], T));
print_term1 (list_mk_let(strip_let(list_mk_let([[(v1, mk_const("cv1",tv1))],
	[(v2, mk_const("cv2",tv2))]], T))));

mk_enum_set []; (* fails *)
print_term1 (mk_enum_set [T]);
print_term1 (mk_enum_set [T, F, c1]);
(mk_enum_set [T, F, c2]); (* fails *)
print_term(mk_empty_enum_set BOOL);
map print_term1 (dest_enum_set(mk_enum_set [T, F, c1]));
dest_enum_set c1; (* fails *)
is_enum_set (mk_enum_set [T, F, c1]);
is_enum_set T;
print_term1(mk_set(v1, T));
print_term1(mk_set(mk_pair(v1,v2), T));
mk_set(v1,v1); (* fails *)
(print_term1 ** print_term1)(dest_set(mk_set(mk_pair(v1,v2), T)));
dest_set c1; (* fails *)
is_set T; (* false *)
is_set (mk_set(v1, T));

print_term1 (mk_å T);
(mk_å c2); (* fails *)
dest_å c1; (* fails *)
print_term1(dest_å(mk_å T));
is_å T; (* false *)
is_å (mk_å T);

print_term1(mk_É(v1, T));
print_term1(mk_É(mk_pair(v1,v2), T));
mk_É(v1,v1); (* fails *)
mk_É(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)), T); (* fails *)
(print_term1 ** print_term1)(dest_É(mk_É(mk_pair(v1,v2), T)));
dest_É c1; (* fails *)
is_É T; 
is_É (mk_É(v1, T));
mk_É(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)), T); (* fails *)
print_term1 (list_mk_É([v1,v2],T));
strip_É(list_mk_É([v1,v2],T)) = ([v1,v2],T);

print_term1(mk_Ñ(v1, T));
print_term1(mk_Ñ(mk_pair(v1,v2), T));
mk_Ñ(v1,v1); (* fails *)
mk_Ñ(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)), T);
(print_term1 ** print_term1)(dest_Ñ(mk_Ñ(mk_pair(v1,v2), T)));
dest_Ñ c1; (* fails *)
is_Ñ T; 
is_Ñ (mk_Ñ(v1, T));
mk_Ñ(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)), T); (* fails *)
print_term1 (list_mk_Ñ([v1,v2],T));
strip_Ñ(list_mk_Ñ([v1,v2],T)) = ([v1,v2],T);

print_term1(simple_mk_Ñ%down%1(v1, T));
print_term1(simple_mk_Ñ%down%1(mk_pair(v1,v2), T)); (* fails *)
simple_mk_Ñ%down%1(v1,v1); (* fails *)
simple_mk_Ñ%down%1(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)), T); (* fails *)
(print_term1 ** print_term1)(simple_dest_Ñ%down%1(mk_Ñ%down%1(v1, T)));
simple_dest_Ñ%down%1 c1; (* fails *)
simple_is_Ñ%down%1 T; (* false *)
simple_is_Ñ%down%1 (simple_mk_Ñ%down%1(v1, T));
simple_mk_Ñ%down%1(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)), T); (* fails *)

print_term1(mk_Ñ%down%1(v1, T));
print_term1(mk_Ñ%down%1(mk_pair(v1,v2), T));
mk_Ñ%down%1(v1,v1); (* fails *)
mk_Ñ%down%1(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)), T);
(print_term1 ** print_term1)(dest_Ñ%down%1(mk_Ñ%down%1(mk_pair(v1,v2), T)));
dest_Ñ%down%1 c1; (* fails *)
is_Ñ%down%1 T; 
is_Ñ%down%1 (mk_Ñ%down%1(v1, T));
mk_Ñ%down%1(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)), T); (* fails *)

print_term1(mk_á(v1, T));
print_term1(mk_á(mk_pair(v1,v2), T));
mk_á(v1,v1); (* fails *)
mk_á(mk_comb(mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)), T); 
	(* fails *)
(print_term1 ** print_term1)(dest_á(mk_á(mk_pair(v1,v2), T)));
dest_á c1; (* fails *)
is_á T; 
is_set (mk_á(v1, T));
print_term1 (list_mk_á([v1,v2],T));
strip_á(list_mk_á([v1,v2],T)) = ([v1,v2],T);

mk_list[]; (* fails *)
print_term1(mk_list[T,F,c1]);
print_term1(mk_list[T,F,c2]); (* fails *)
print_term (mk_empty_list BOOL);
dest_list c1; (* fails *)
dest_list(mk_list[T,F,c1]);
is_list(mk_list[]); 
is_list(mk_list[T,F]);
is_list T;
=TEX
The following function decomposes and recomposes a term using
$?\_DERIV\_TERM$.
The first and third outputs should be identical.
The fourth output should always be $true$.
=SML
fun test_DT (tm:TERM) : bool = let
	val v1 = print_term1 tm;
	val v2 = diag_string "Becomes>";
	val v3 = print_dest_term (dest_term tm);
	val v4 = diag_string "Decomposed>";
	val symd = mk_term(dest_term tm);
	val v5 = print_term1 symd
in
	tm = symd
end;
test_DT(mk_var ("v2",BOOL));
test_DT(mk_const ("c2",BOOL));
test_DT(mk_comb (mk_var("v1",mk_fun(BOOL,BOOL)), mk_var("v2",BOOL)));
test_DT(mk_abs (v1, c1));
test_DT(mk_pair(c1, c2));
test_DT(mk_Ä(T,F));
test_DT(mk_Å(T,F));
test_DT(mk_Ç(T,F));
test_DT(mk_eq(T,F));
test_DT(mk_eq(c2,c2));
test_DT(mk_if(c1, T, F));
test_DT(mk_let([(v1, mk_const("cv1",tv1)),
		(v2, mk_const("cv2",tv2))], T));
test_DT(mk_enum_set [T, F, c1]);
test_DT(mk_set(mk_pair(v1,v2), T));
test_DT(mk_å T);
test_DT(mk_É(mk_pair(v1,v2), T));
test_DT(mk_Ñ(v1, T));
test_DT(mk_á(mk_pair(v1,v2), T));
test_DT(mk_list[T,F,c1]);
test_DT (list_mk_comb(
	mk_const("F",mk_fun(BOOL,mk_fun(BOOL, mk_fun(BOOL, BOOL)))),
	[T, F , c1]));;
test_DT (list_mk_comb(
	mk_const("f",mk_fun(BOOL,mk_fun(BOOL,mk_fun(BOOL, mk_fun(BOOL, BOOL))))),
	[T, F , c1, T]));
test_DT (list_mk_comb(mk_const("Insert",
	mk_fun(BOOL,mk_fun(mk_type("SET",[BOOL]),mk_type("SET",[BOOL])))),
	[T, mk_var("S",mk_type("SET",[BOOL]))]));
test_DT (mk_const("Nil",mk_type("LIST",[BOOL])));
test_DT (mk_const("Nil",BOOL));
test_DT (mk_const("Empty",mk_type("SET",[BOOL])));
test_DT (mk_const("Empty",BOOL));
=TEX
\subsection{End of Tests}
=SML
PolyML.quit();
=TEX
\end{document}
