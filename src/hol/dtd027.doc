=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design of Derived Rules of Inference II}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Derived Rules of Inference II}
\TPPref{DS/FMU/IED/DTD027}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for further 
derived rules of inference in ICL HOL,
in particular those concerned with paired abstractions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Fixed an error message.
\item [ Issue 1.3]
Gained inference rules about sets.
\end{description}
\subsection{Changes forecast}
Most of the text outside the documentation boxes is a discussion
of the design process, rather than being part of the final design.
It will thus be removed or rephrased in later issues.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
derived rules of inference.
This is called for in section ??? of ???.
The design is
implemented in \cite{DS/FMU/IED/IMP027}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
paired abstraction
derived rules of inference in Release 001 of ICL HOL.

The document provides groups of rules of inference, related by their core operator.

All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP027}.

We use the notation ``varstruct'' for ``an allowed variable structure, under ICL HOL syntax''.
\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.

This document places requirements upon the constants handled by the
inference rules discussed.
In summary, the requirements are that the definitions of the constants must be such that the designs of the rules are satisfiable.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the ``top level''.
Thus we give the commands here for those functions declared in the following signatures.
=SML
=TEX
\section{THE DERIVED RULES OF REASONING}
=DOC
signature ‚DerivedInferenceRulesII· = sig
=DESCRIBE
This provides the further derived rules of inference for ICL HOL.
They are primarily concerned with handling paired abstractions.
=ENDDOC
\subsection{Concerning ä}
=DOC
val ‚ä_match_mp_rule· : THM -> THM -> THM ;
=DESCRIBE
A matching Modus Ponens rule for implication.
=RULE
ä_match_mp_rule
…
ˆ1 Ö É x1 ... é t1 ä t2; ˆ2 Ö t1'
…
ˆ1 ° ˆ2 Ö t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's hypothesis to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.
=FAILURE
27001	First theorem is not of the form: `É x1 ... é t1 ä t2`
	where the ªxiº are varstructs
7044	Cannot match the theorems
=ENDDOC
\subsection{Concerning Ç}
=DOC
val ‚Ç_match_mp_rule· : THM -> THM -> THM;
=DESCRIBE
A matching Modus Ponens for $Ç$.
=RULE
Ç_match_mp_rule
…
ˆ1 Ö É x1 ... é t1 Ç t2; ˆ2 Ö t1'
…
ˆ1 ° ˆ2 Ö t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's LHS to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.
=SEEALSO
$ä\_elim$ (Modus Ponens on $ä$)
=FAILURE
27002	First theorem is not of the form: `É x1 ... é t1 Ç t2`
	where the ªxiº are varstructs
7044	Cannot match the theorems
=ENDDOC

\subsection{Concerning =}
=DOC
val ‚eq_match_conv· : THM -> CONV ;
=DESCRIBE
This matches the LHS of an equation to a term,
instantiating the RHS accordingly.
The equation may be partially or fully universally quantified
(simple or by varstruct),
without affecting the result of the conversion.
=CONVERSION
eq_match_conv
(ˆ Ö É ... é u = v)
ªtº
…
…
ˆ Ö t = v'
=TEX
and
=CONVERSION
eq_match_conv
(ˆ Ö É ... é u Ç v)
ªtº
…
…
ˆ Ö t Ç v'
=TEX
where $v'$ is the result of applying to $v$ the instantiation rules required to match $u$ to $t$
(including both term and type instantiation).
If there are free variables on the RHS of the supplied equation (when stripped of all universal quantification)
they will be renamed as necessary to avoid identification with
any variables in $t$.

This conversion may be partially evaluated with only its theorem argument.
=FAILURE
27003	Theorem is not of the form `ˆ Ö É x1 ... xn é u = v`
	where ªxiº are varstructs
7076	Could not match term to LHS of theorem
=ENDDOC
($REWRITE\_CONV$ in Cambridge HOL)
The process of renaming to avoid identification is a minimum requirement on free variables on the RHS.
More powerful requirements (e.g. something like Cambridge HOL's $genvar$) could be appropriate.
=DOC
val ‚eq_match_conv1· : THM -> CONV ;
=DESCRIBE
This matches the LHS of an universally quantified (simple or by varstruct) equation to a term,
instantiating the RHS accordingly.
The conversion will only instantiate its universal quantifications,
and type variables, not its free term variables.
=CONVERSION
eq_match_conv1
(ˆ Ö É x1 ... xn é u[x1,...,xn] = 
   v[x1,...,xn])
ªtº
…
…
ˆ Ö t = v[t1,...,tn]
=TEX
and
=RULE
eq_match_conv1
(ˆ Ö É x1 ... xn é u[x1,...,xn] Ç 
   v[x1,...,xn])
ªtº
…
…
ˆ Ö t = v[t1,...,tn]
=TEX
where ªu[t1,...,tn]º is $\alpha$-convertible to ªtº.
If there are free variables on the RHS of the supplied equation (when stripped of all universal quantification)
they will be renamed as necessary to avoid identification with
any variables in $t$.

This conversion may be partially evaluated with only its theorem argument.
=USES
In producing a limited rewriting facility, that only instantiates
explicitly identified variables.
=FAILURE
27003	Theorem is not of the form `ˆ Ö É x1 ... xn é u = v`
	where ªxiº are varstructs
7076	Could not match term to LHS of theorem
=ENDDOC
An alternative method of indicating what may be instantiated 
is to give a ``forbidden list'' of variables that may not be instantiated,
whether they be universally quantified or free in the original theorem.
This could of course be a ``only modify'' list instead.

As this is calculated once per application of $eq\_match\_conv1$ to a theorem, and not once per application to a term, it is not 
a major potential time-saver either way.
What this function must be fast at is its application to a term.

We may want a specialised $term\_match$ function that understands
a ``forbidden list'' of variables that it may not modify.

We might also want some way of matching, such that free variables in the assumption list are also instantiated. This would work best with a ``forbidden list'' style, rather than a style that only
allows the universally quantified variables to be instantiated.
This question is particularly important if we want the possibility
of clever assumption introduction mechanisms during rewriting,
especially those involved in rewriting with implications.
\subsection{Concerning ç}
=DOC
val ‚abs_conv· : TERM -> CONV;
=DESCRIBE
The RHS of $abs\_conv$ $var$ $eqn$ is the equation formed by abstracting 
$var$ (which must be a varstruct) from both sides of the equation $eqn$.
=RULE
abs_conv
ªxº
ªt1 = t2º
…
…
Ö (t1 = t2) Ç ((ç x é t1) = (ç x é t2))
=TEX
And:
=RULE
abs_conv
ªxº
ªt1 Ç t2º
…
…
Ö (t1 Ç t2) Ç ((ç x é t1) = (ç x é t2))
=TEX
=SEEALSO
$abs\_rule$
=FAILURE
27005	First argument is not a varstruct
27006	?0 occurs free in assumption list
7090	Term is not of the form: ªt1 = t2º or ªt1 Ç t2º
=ENDDOC
=DOC
val ‚%beta%_rule· : THM -> THM;
=DESCRIBE
An elimination rule for $ç$, which can handle paired abstractions.
=RULE
%beta%_rule
…
ˆ Ö (ç x é t[x]) y
…
ˆ Ö t[y]
=TEX
=SEEALSO
$beta\_conv$
=FAILURE
27007	Theorem is not of the form: `ˆ Ö (ç x é t[x]) y`
	where ªxº is a varstruct
=ENDDOC
=DOC
val ‚%beta%_conv· : CONV;
=DESCRIBE
A full $\beta$ conversion.
=RULE
%beta%_conv
ª(ç x é t[x])yº
…
…
Ö ((ç x é t[x])y) = t'[y]
=TEX
where $x$ may be any varstruct allowed by the ICL HOL syntax, 
$y$ is an instance of this structure,
and $t'$ is $\alpha$-convertible to $t$, changed to avoid variable capture.
=SEEALSO
$simple\_\beta\_conv$
=FAILURE
27008	Term is not of the form: ª(ç x é t[x])yº
	where ªxº is a varstruct
27009	Term is not of the form: ª(ç x é t[x])yº, where ªxº may be
	instantiated to the same structure as ªyº
=ENDDOC
=DOC
val ‚all_%beta%_conv· : CONV;
=DESCRIBE
A conversion to eliminate all instances of $\beta$ redexes,
including paired abstraction redexes, in a term, regardless of nesting, or even that the $\beta$ redex was created as the result of
an earlier reduction in the conversion's evaluation.
=RULE
all_%beta%_conv
ªtº
…
…
Ö t = t'
=TEX
$t'$ is $t$ with all $\beta$ redexes reduced.
=USES
This uses an optimised term traversal algorithm, superior in speed
to the general term traversal algorithms used with conversions,
and should be used in preference to them and $\beta\_conv$.
=ENDDOC
=DOC
val ‚all_%beta%_rule· : THM -> THM;
=DESCRIBE
Eliminate all instances of $\beta$ redexes,
including paired abstraction redexes, in a theorem, regardless of nesting, or even that the $\beta$ redex was created as the result of
an earlier reduction in the rule's evaluation.
=RULE
all_%beta%_rule
…
ˆ Ö t
…
ˆ Ö t'
=TEX
$t'$ is $t$ with all $\beta$-redexes reduced.
=ENDDOC
($BETA\_RULE$ in Cambridge HOL)
=DOC
val ‚%eta%_conv· : CONV ;
=DESCRIBE
The rule for $\eta$ conversion.
=RULE
%eta%_conv
ªç x é t xº
…
…
Ö (ç x é t x) = t
=TEX
where $t$ contains no instances of $x$.
=FAILURE
27018	Term is not of the form: ªç x é t[x]º
	where ªxº is a varstruct
27023	Term is not of the form: ªç x é t xº where ªtº should not contain ªxº
=ENDDOC
($ETA\_CONV$ in Cambridge HOL)

\subsection{Concerning É}
=DOC
val ‚É_intro· : TERM -> THM -> THM;
=DESCRIBE
Introduce a universal quantification.
=RULE
É_intro
ªxº
…
ˆ Ö t
…
ˆ Ö É x é t
=TEX
=SEEALSO
$simple\_É\_intro$
=FAILURE
27010	Term is not a varstruct
7070	?0 occurs free in assumption list
=ENDDOC
=DOC
val ‚É_elim· : TERM -> THM -> THM;
=DESCRIBE
Instantiate a universally quantified variable to a given value.
=RULE
É_elim
ªt1º
…
ˆ Ö É x é t2[x]
…
ˆ Ö t2'[t1]
=TEX
where $t2'$ is renamed from $t2$ to prevent bound variable capture,
and $x$ is a varstruct, instantiable to the structure of $t1$.
=FAILURE
27011	Theorem is not of the form: `ˆ Ö É x é t` where ªxº is a varstruct
27012	Theorem is not of the form: `ˆ Ö É x é t` where the type of ªxº 
	is the type of the term argument
27013	Theorem is not of the form: `ˆ Ö É x é t` where the structure of ªxº 
	is instantiable to the structure of the term argument
=ENDDOC
($SPEC$ in Cambridge HOL)
=DOC
val ‚list_É_intro· : TERM list -> THM -> THM;
=DESCRIBE
Generalised $É$ introduction.
=RULE
list_É_intro
[ªx1º, ..., ªxnº]
…
ˆ Ö t[x1, ..., xn]
…
ˆ Ö É x1 ... xn é t[x1, ..., xn]
=TEX
=SEEALSO
$É\_intro$
=FAILUREC
\paragraph{Errors}
Same messages as $É\_intro$.
=ENDDOC
($GENL$ in Cambridge HOL)
=DOC
val ‚list_É_elim· : TERM list -> THM -> THM;
=DESCRIBE
Generalised $É$ elimination.
=RULE
list_É_elim
[ªt1º, ..., ªtnº]
…
ˆ Ö É x1 ... xn é t[x1, ..., xn]
…
t[t1, ..., tn]
=TEX
=SEEALSO
$É\_elim$
=FAILUREC
\paragraph{Errors}
Same messages as $É\_elim$.
=ENDDOC
($SPECL$ in Cambridge HOL)
=DOC
val ‚all_É_elim· : THM -> THM;
=DESCRIBE
Specialises all the outer universal quantifications in a theorem:
=RULE
all_É_elim
…
ˆ Ö É x1 ... xn é t[x1, ..., xn]
…
ˆ Ö t[x1', ..., xn']
=TEX
where $x1', \ldots, xn'$ are renamed from $x1, \ldots, xn$ as necessary to avoid clashes with
free variables in the assumption list.
=ENDDOC
($GEN\_ALL$ in Cambridge HOL)
=DOC
val ‚å_É_conv· : CONV;
=DESCRIBE
Move $å$ into a $É$ construct.
=RULE
å_É_conv
ªå (É x é t[x])º
…
…
Ö (å (É x é t[x])) Ç Ñ x é å t[x]
=TEX
This will work with any paired universal quantifier.
=FAILURE
27019	Term not of the form: ªå (É x é t[x])º
	where ªxº is a varstruct
=ENDDOC
($NOT\_FORALL\_CONV$ in Cambridge HOL)
=DOC
val ‚É_Ç_rule· : TERM -> THM -> THM;
=DESCRIBE
Universally quantify a variable on both sides of an equivalence.
=RULE
É_Ç_rule
ªxº
…
ˆ Ö p[x] Ç q[x]
…
ˆ Ö (É x é p[x]) Ç (É x é q[x])
=TEX
where $x$ is a varstruct.
=FAILURE
7062	Theorem is not of the form: `ˆ Ö t1 Ç t2`
27010	Term is not a varstruct
7070	?0 occurs free in assumption list
=ENDDOC
($FORALL\_EQ$ in Cambridge HOL)
=DOC
val ‚É_arb_elim· : THM -> THM;
=DESCRIBE
Specialise a universally quantified theorem with a machine generated variable.
=RULE
É_arb_elim
…
ˆ Ö É x é p[x]
…
ˆ Ö p[x']
=TEX
where $x'$ is not a variable (free or bound) in $p$.
=ENDDOC
($GSPEC$ in Cambridge HOL)
The precise rules for the name formation of $x$ will not be given here.
=DOC
val ‚É_asm_rule· : TERM -> TERM -> THM -> THM;
=DESCRIBE
Generalise an assumption (Left $É$ introduction).
=RULE
É_asm_rule
ªxº
ªp[x]º
…
ˆ, p'[x] Ö q[x]
…
ˆ, É x é p'[x] Ö q[x]
=TEX
where $p$ and $p'$ are $\alpha$-convertible.
$x$ {\bf may} be free in $ˆ$.
=FAILURE
27014	First term is not a varstruct
7055	Second term is not in assumption list
=ENDDOC
This is from \cite{Manna74}.
=DOC
val ‚É_reorder_conv· : TERM -> CONV;
=DESCRIBE
Reorder universal quantifications.
=RULE
É_reorder_conv
ªÉ x1 .. xn é t1º
ªÉ y1 .. ym é t2º
…
…
(É y1 .. ym é t2) Ç (É x1 .. xn é t1)
=TEX
where the $x_i$ and $y_i$ are varstructs,
and the reordering and renaming requested is valid.
=FAILURE
27015	Cannot prove equation
27016	First term is not boolean
27017	Second term is not boolean
=ENDDOC


We do not give a rule for $ÉÉ$ introduction from \cite{Manna74}.
\subsection{Concerning Ñ}
=DOC
val ‚Ñ_intro· : TERM -> THM -> THM ;
=DESCRIBE
Introduce an existential quantifier by reference to a witness.
=RULE
Ñ_intro
ªÑ x é t1[x]º
…
ˆ Ö t1[t2]
…
ˆ Ö Ñ x é t1[x]
=TEX
where ªxº is varstruct.
=FAILURE
27004	Term is not of the form: ªÑ x é t1[x]º where ªxº is a varstruct
7047	Term cannot be matched to conclusion of theorem
=ENDDOC
($EXISTS$ in Cambridge HOL)
In Cambridge HOL you give $t2$ (i.e. the witness that satisfies the predicate) as another argument, though this
seems only to speed the correctness check, as it may be
derived via $term\_match$.
=DOC
val ‚Ñ_elim· : TERM -> THM -> THM -> THM ;
=DESCRIBE
Eliminate an existential quantifier by reference to an arbitrary varstruct satisfying the predicate.
=RULE
Ñ_elim
ªt1[y]º
…
ˆ1 Ö Ñ x é t1[x]; ˆ2, t1[y] Ö t2
…
ˆ1 ° ˆ2 Ö t2
=TEX
where $y$ must be a free varstruct, none of whose component variables are present elsewhere in theorems.
=FAILURE
7002	Term is not boolean
7013	Term is not in assumption list of second theorem
27025	Cannot match term to conclusion of first theorem and gain a varstruct
=ENDDOC
($CHOOSE$ in Cambridge HOL)
=DOC
val ‚å_Ñ_conv· : CONV;
=DESCRIBE
Move $å$ into an $Ñ$ construct.
=RULE
å_Ñ_conv
ªå (Ñ x é t[x])º
…
…
Ö (å (Ñ x é t[x])) Ç É x é å t[x]
=TEX
This will work with any paired existential quantifier.
=FAILURE
27020	Term is not of the form: ªå (Ñ x é t[x])º
	where ªxº is a varstruct
=ENDDOC
($NOT\_EXISTS\_CONV$ in Cambridge HOL)
=DOC
val ‚Ñ_asm_rule· : TERM -> TERM -> THM -> THM;
=DESCRIBE
Existentially quantify an assumption (Left $Ñ$ introduction).
=RULE
Ñ_asm_rule
ªxº
ªp[x]º
…
ˆ, p'[x] Ö q
…
ˆ, Ñ x é p'[x] Ö q
=TEX
where $p$ and $p'$ are $\alpha$-convertible.
where $x$ is not free in $ˆ$ or $q$.
=FAILURE
27014	First term is not a varstruct
7055	Second term is not in assumption list
7078	?0 is free in conclusion of theorem
7079	?0 is free in of assumptions of theorem
=ENDDOC
This is from \cite{Manna74}.

=DOC
val ‚Ñ_reorder_conv· : TERM -> CONV;
=DESCRIBE
Reorder existential quantifications.
=RULE
Ñ_reorder_conv
ªÑ x1 .. xn é t1º
ªÑ y1 .. ym é t2º
…
…
(Ñ y1 .. ym é t2) Ç (Ñ x1 .. xn é t1)
=TEX
where the $x_i$ and $y_i$ are varstructs,
and the reordering and renaming requested is valid.
=FAILURE
27015	Cannot prove equation
27016	First term is not boolean
27017	Second term is not boolean
=ENDDOC

We do not give a rule for $ÑÑ$ introduction from \cite{Manna74}.
\subsection{Concerning Ñ$_1$}
=DOC
val ‚Ñ%down%1_intro· : TERM -> THM -> THM -> THM;
=DESCRIBE
Introduce $Ñ_1$ by reference to a witness, and a uniqueness theorem.
=RULE
Ñ%down%1_intro
…
ˆ1 Ö P'[t']
ˆ2 Ö É x é P[x] ä x = t
…
ˆ1 ° ˆ2 Ö Ñ%down%1 x é P[x]
=TEX
Where $P'$ is $\alpha$-convertible to $P$, and
$t'$ is $\alpha$-convertible to $t$.
Notice that for the resulting theorem we take the varstruct, $x$, and the form of the predicate, $P$, from the second theorem.
=FAILURE
27021	Theorems are not of the form: `ˆ1 Ö Pa[ta]` and `ˆ2 Ö É x é P[x] ä x = t`
	where ªPaº and ªPº, ªtaº and ªtº are %alpha%-convertible
	and ªxº is a varstruct
=ENDDOC
=DOC
val ‚Ñ%down%1_elim· : THM -> THM;
=DESCRIBE
Express a $Ñ_1$ in terms of $Ñ$ and a uniqueness property.
=RULE
Ñ%down%1_elim
…
ˆ Ö Ñ%down%1 x é P[x]
…
ˆ Ö Ñ x é P[x] Ä É y é P[y] ä y = x
=TEX
=FAILURE
27022	Theorem is not of the form: `ˆ Ö Ñ%down%1 x é P[x]`
	where ªxº is a varstruct
=ENDDOC
This could be rewritten to produce two theorems,
`$Ñ\ x\ é\ P[x]$` and `$É\ x\ y\ é\ P[x]\ Ä\ P[y]\ ä\ x\ =\ y$`
\subsection{Concerning á}
=DOC
val ‚Ñ_á_rule· : THM -> THM;
=DESCRIBE
Give that $á$ of a predicate satisfies the predicate by reference to an $Ñ$ construct.
It can properly handle paired existence.
=RULE
Ñ_á_rule
…
ˆ Ö Ñ x é p[x]
…
ˆ Ö p(á x é p x)
=TEX
=SEEALSO
$Ñ\_á\_conv$
=FAILURE
27024	Theorem is not of the form: `ˆ Ö Ñ x é p[x]`
	where ªxº is a varstruct
=ENDDOC
($SELECT\_RULE$ in Cambridge HOL)
=DOC
val ‚Ñ_á_conv· : CONV;
=DESCRIBE
Give that $á$ of a predicate satisfies the predicate by reference to an $Ñ$ construct.
It can properly handle paired existence.
=RULE
Ñ_á_conv
ªÑ x é p[x]º
…
…
ˆ Ö (Ñ x é p[x]) = p(á x é p x)
=TEX
=SEEALSO
$Ñ\_á\_rule$
=FAILURE
27024	Theorem is not of the form: `ˆ Ö Ñ x é p[x]`
	where ªxº is a varstruct
=ENDDOC
\subsection{Concerning Local Definitions}
=DOC
val ‚let_intro_rule· : (string * TERM) -> THM -> THM;
=DESCRIBE
Introduce a local definition.
=RULE
let_intro_rule
[...,("xi", ªtiº),...]
…
ˆ Ö t[t1,...tn]
…
ˆ Ö let x1' = t1 and ... xn' = tn 
	in t2[x1',...,xn']
=TEX
where $x_i'$ in the result are variables with the names $x_i$, and with the type of $t_i$, perhaps made into variants to avoid variable capture.
=ENDDOC
Perhaps we should provide a template of what $t[...]$ should look like, so that not all instances of $t_i$ are changed to $x_i$.
Perhaps we should fail, rather than rename, if variable capture occurs.
=DOC
val ‚let_elim_rule· : THM -> THM;
=DESCRIBE
Eliminate an outermost $let\ldots and\ldots in\ldots$ construct.
=RULE
let_elim_rule
…
ˆ Ö let x1 = t1 and ... xn = tn 
	in t[x1,...,xn]
…
ˆ Ö t[t1,...,tn]
=TEX
=ENDDOC
=DOC
val ‚let_conv· : CONV;
=DESCRIBE
Eliminate an outermost $let\ldots and\ldots in\ldots$ construct.
=CONVERSION
let_elim_rule
ªlet v1 = t1 and ... vn = tn 
 in t[v1,...,vn]º
…
…
Ö (let v1 = t1 and ... vn = tn in 
	t[v1,...,vn]) 
	= t[t1,...,tn]
=TEX
=ENDDOC

\subsection{Concerning $Uncurry$}
I don't believe we need a rule for eliminating $Uncurry$,
and its introduction is mostly behind the scenes.
\subsection{Concerning Sets}
A much wider set of rules than the below could be given .
=DOC
val ‚enum_set_rule· : TERM -> TERM list -> THM;
=DESCRIBE
Give that something within an enumerated set is a member of that set.
=RULE
enum_set_rule
ªtiº
[ªt1º,...ªtnº]
…
…
Ö ti ù {t1,...,tn}
=TEX
where $ti$ is $\alpha$-convertible to one of $t1,\ldots,tn$.
=FAILURE
27026	Term list may not be empty
27027	Differing types in term list
27028	Term has different type to elements in term list
=ENDDOC
A speculative form of rule, but the functionality will be useful
when handling sets.
=DOC
val ‚set_rule· : TERM -> string -> THM -> THM;
=DESCRIBE
Given that $x$ satisfies a predicate $P$, show that $x$ is a member of the
set constructed from $P$.
=RULE
set_rule
ªxº
(v : string)
…
ˆ Ö P [x]
…
ˆ Ö x ù {v' | P[v']}
=TEX
where $v'$ is a variable with name $v$ (or a variant as necessary,
to avoid variable capture) and the type of $x$.
=ENDDOC
A speculative form of rule, but the functionality will be useful when handling sets.
Perhaps we should provide a template for $P$, to allow only 
some instances of $x$ to be ``captured''.

\section{SUPPORTING THEORY}
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of DerivedInferenceRulesII *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
