=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design of Derived Rules of Inference II}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Derived Rules of Inference II}
\TPPref{DS/FMU/IED/DTD027}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for further 
derived rules of inference in ICL HOL,
in particular those concerned with paired abstractions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
\end{description}
\subsection{Changes forecast}
Most of the text outside the documentation boxes is a discussion
of the design process, rather than being part of the final design.
It will thus be removed or rephrased in later issues.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
derived rules of inference.
This is called for in section ??? of ???.
The design is
implemented in \cite{DS/FMU/IED/IMP027}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
paired abstraction
derived rules of inference in Release 001 of ICL HOL.

The document provides groups of rules of inference, related by their core operator.

All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP027}.

We use the notation ``varstruct'' for ``an allowed variable structure, under ICL HOL syntax''.
\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.

This document places requirements upon the constants handled by the
inference rules discussed.
In summary, the requirements are that the definitions of the constants must be such that the designs of the rules are satisfiable.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the ``top level''.
Thus we give the commands here for those functions declared in the following signatures.
=SML
=TEX
\section{THE DERIVED RULES OF REASONING}
=DOC
signature âDerivedInferenceRulesIIá = sig
=DESCRIBE
This provides the further derived rules of inference for ICL HOL.
They are primarily concerned with handling paired abstractions.
=ENDDOC
\subsection{Concerning Š}
=DOC
val âŠ_match_mp_ruleá : THM -> THM -> THM ;
=DESCRIBE
A matching Modus Ponens rule for implication.
=RULE
Š_match_mp_rule
É
ö1 … ƒ x1 ... Ž t1 Š t2; ö2 … t1'
É
ö1 ¡ ö2 … t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's hypothesis to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.
=FAILURE
27001	First theorem is not of the form: `ƒ x1 ... Ž t1 Š t2`
	where the »xi¼ are varstructs
7044	Cannot match the theorems
=ENDDOC
\subsection{Concerning ‚}
=DOC
val â‚_match_mp_ruleá : THM -> THM -> THM;
=DESCRIBE
A matching Modus Ponens for $‚$.
=RULE
‚_match_mp_rule
É
ö1 … ƒ x1 ... Ž t1 ‚ t2; ö2 … t1'
É
ö1 ¡ ö2 … t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's LHS to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.
=SEEALSO
$Š\_elim$ (Modus Ponens on $Š$)
=FAILURE
27002	First theorem is not of the form: `ƒ x1 ... Ž t1 ‚ t2`
	where the »xi¼ are varstructs
7044	Cannot match the theorems
=ENDDOC

\subsection{Concerning =}
=DOC
val âeq_match_convá : THM -> CONV ;
=DESCRIBE
This matches the LHS of an equation to a term,
instantiating the RHS accordingly.
The equation may be partially or fully universally quantified
(simple or by varstruct),
without affecting the result of the conversion.
=CONVERSION
eq_match_conv
(ö … ƒ ... Ž u = v)
»t¼
É
É
ö … t = v'
=TEX
and
=CONVERSION
eq_match_conv
(ö … ƒ ... Ž u ‚ v)
»t¼
É
É
ö … t ‚ v'
=TEX
where $v'$ is the result of applying to $v$ the instantiation rules required to match $u$ to $t$
(including both term and type instantiation).
If there are free variables on the RHS of the supplied equation (when stripped of all universal quantification)
they will be renamed as necessary to avoid identification with
any variables in $t$.

This conversion may be partially evaluated with only its theorem argument.
=FAILURE
27003	Theorem is not of the form `ö … ƒ x1 ... xn Ž u = v`
	where »xi¼ are varstructs
7076	Could not match term to LHS of theorem
=ENDDOC
($REWRITE\_CONV$ in Cambridge HOL)
The process of renaming to avoid identification is a minimum requirement on free variables on the RHS.
More powerful requirements (e.g. something like Cambridge HOL's $genvar$) could be appropriate.
=DOC
val âeq_match_conv1á : THM -> CONV ;
=DESCRIBE
This matches the LHS of an universally quantified (simple or by varstruct) equation to a term,
instantiating the RHS accordingly.
The conversion will only instantiate its universal quantifications,
and type variables, not its free term variables.
=CONVERSION
eq_match_conv1
(ö … ƒ x1 ... xn Ž u[x1,...,xn] = 
   v[x1,...,xn])
»t¼
É
É
ö … t = v[t1,...,tn]
=TEX
and
=RULE
eq_match_conv1
(ö … ƒ x1 ... xn Ž u[x1,...,xn] ‚ 
   v[x1,...,xn])
»t¼
É
É
ö … t = v[t1,...,tn]
=TEX
where »u[t1,...,tn]¼ is $\alpha$-convertible to »t¼.
If there are free variables on the RHS of the supplied equation (when stripped of all universal quantification)
they will be renamed as necessary to avoid identification with
any variables in $t$.

This conversion may be partially evaluated with only its theorem argument.
=USES
In producing a limited rewriting facility, that only instantiates
explicitly identified variables.
=FAILURE
27003	Theorem is not of the form `ö … ƒ x1 ... xn Ž u = v`
	where »xi¼ are varstructs
7076	Could not match term to LHS of theorem
=ENDDOC
An alternative method of indicating what may be instantiated 
is to give a ``forbidden list'' of variables that may not be instantiated,
whether they be universally quantified or free in the original theorem.
This could of course be a ``only modify'' list instead.

As this is calculated once per application of $eq\_match\_conv1$ to a theorem, and not once per application to a term, it is not 
a major potential time-saver either way.
What this function must be fast at is its application to a term.

We may want a specialised $term\_match$ function that understands
a ``forbidden list'' of variables that it may not modify.

We might also want some way of matching, such that free variables in the assumption list are also instantiated. This would work best with a ``forbidden list'' style, rather than a style that only
allows the universally quantified variables to be instantiated.
This question is particularly important if we want the possibility
of clever assumption introduction mechanisms during rewriting,
especially those involved in rewriting with implications.
\subsection{Concerning }
=DOC
val âabs_convá : TERM -> CONV;
=DESCRIBE
The RHS of $abs\_conv$ $var$ $eqn$ is the equation formed by abstracting 
$var$ (which must be a varstruct) from both sides of the equation $eqn$.
=RULE
abs_conv
»x¼
»t1 = t2¼
É
É
… (t1 = t2) ‚ (( x Ž t1) = ( x Ž t2))
=TEX
And:
=RULE
abs_conv
»x¼
»t1 ‚ t2¼
É
É
… (t1 ‚ t2) ‚ (( x Ž t1) = ( x Ž t2))
=TEX
=SEEALSO
$abs\_rule$
=FAILURE
27005	First argument is not a varstruct
27006	?0 occurs free in assumption list
7090	Term is not of the form: »t1 = t2¼ or »t1 ‚ t2¼
=ENDDOC
=DOC
val â%beta%_ruleá : THM -> THM;
=DESCRIBE
An elimination rule for $$, which can handle paired abstractions.
=RULE
%beta%_rule
É
ö … ( x Ž t[x]) y
É
ö … t[y]
=TEX
=SEEALSO
$beta\_conv$
=FAILURE
27007	Theorem is not of the form: `ö … ( x Ž t[x]) y`
	where »x¼ is a varstruct
=ENDDOC
=DOC
val â%beta%_convá : CONV;
=DESCRIBE
A full $\beta$ conversion.
=RULE
%beta%_conv
»( x Ž t[x])y¼
É
É
… (( x Ž t[x])y) = t'[y]
=TEX
where $x$ may be any varstruct allowed by the ICL HOL syntax, 
$y$ is an instance of this structure,
and $t'$ is $\alpha$-convertible to $t$, changed to avoid variable capture.
=SEEALSO
$simple\_\beta\_conv$
=FAILURE
27008	Term is not of the form: »( x Ž t[x])y¼
	where »x¼ is a varstruct
27009	Term is not of the form: »( x Ž t[x])y¼, where »x¼ may be
	instantiated to the same structure as »y¼
=ENDDOC
=DOC
val âall_%beta%_convá : CONV;
=DESCRIBE
A conversion to eliminate all instances of $\beta$ redexes,
including paired abstraction redexes, in a term, regardless of nesting, or even that the $\beta$ redex was created as the result of
an earlier reduction in the conversion's evaluation.
=RULE
all_%beta%_conv
»t¼
É
É
… t = t'
=TEX
$t'$ is $t$ with all $\beta$ redexes reduced.
=USES
This uses an optimised term traversal algorithm, superior in speed
to the general term traversal algorithms used with conversions,
and should be used in preference to them and $\beta\_conv$.
=ENDDOC
=DOC
val âall_%beta%_ruleá : THM -> THM;
=DESCRIBE
Eliminate all instances of $\beta$ redexes,
including paired abstraction redexes, in a theorem, regardless of nesting, or even that the $\beta$ redex was created as the result of
an earlier reduction in the rule's evaluation.
=RULE
all_%beta%_rule
É
ö … t
É
ö … t'
=TEX
$t'$ is $t$ with all $\beta$-redexes reduced.
=ENDDOC
($BETA\_RULE$ in Cambridge HOL)
=DOC
val â%eta%_convá : CONV ;
=DESCRIBE
The rule for $\eta$ conversion.
=RULE
%eta%_conv
» x Ž t x¼
É
É
… ( x Ž t x) = t
=TEX
where $t$ contains no instances of $x$.
=FAILURE
27018	Term is not of the form: » x Ž t[x]¼
	where »x¼ is a varstruct
27023	Term is not of the form: » x Ž t x¼ where »t¼ should not contain »x¼
=ENDDOC
($ETA\_CONV$ in Cambridge HOL)

\subsection{Concerning ƒ}
=DOC
val âƒ_introá : TERM -> THM -> THM;
=DESCRIBE
Introduce a universal quantification.
=RULE
ƒ_intro
»x¼
É
ö … t
É
ö … ƒ x Ž t
=TEX
=SEEALSO
$simple\_ƒ\_intro$
=FAILURE
27010	Term is not a varstruct
7070	?0 occurs free in assumption list
=ENDDOC
=DOC
val âƒ_elimá : TERM -> THM -> THM;
=DESCRIBE
Instantiate a universally quantified variable to a given value.
=RULE
ƒ_elim
»t1¼
É
ö … ƒ x Ž t2[x]
É
ö … t2'[t1]
=TEX
where $t2'$ is renamed from $t2$ to prevent bound variable capture,
and $x$ is a varstruct, instantiable to the structure of $t1$.
=FAILURE
27011	Theorem is not of the form: `ö … ƒ x Ž t` where »x¼ is a varstruct
27012	Theorem is not of the form: `ö … ƒ x Ž t` where the type of »x¼ 
	is the type of the term argument
27013	Theorem is not of the form: `ö … ƒ x Ž t` where the structure of »x¼ 
	is instantiable to the structure of the term argument
=ENDDOC
($SPEC$ in Cambridge HOL)
=DOC
val âlist_ƒ_introá : TERM list -> THM -> THM;
=DESCRIBE
Generalised $ƒ$ introduction.
=RULE
list_ƒ_intro
[»x1¼, ..., »xn¼]
É
ö … t[x1, ..., xn]
É
ö … ƒ x1 ... xn Ž t[x1, ..., xn]
=TEX
=SEEALSO
$ƒ\_intro$
=FAILUREC
\paragraph{Errors}
Same messages as $ƒ\_intro$.
=ENDDOC
($GENL$ in Cambridge HOL)
=DOC
val âlist_ƒ_elimá : TERM list -> THM -> THM;
=DESCRIBE
Generalised $ƒ$ elimination.
=RULE
list_ƒ_elim
[»t1¼, ..., »tn¼]
É
ö … ƒ x1 ... xn Ž t[x1, ..., xn]
É
t[t1, ..., tn]
=TEX
=SEEALSO
$ƒ\_elim$
=FAILUREC
\paragraph{Errors}
Same messages as $ƒ\_elim$.
=ENDDOC
($SPECL$ in Cambridge HOL)
=DOC
val âall_ƒ_elimá : THM -> THM;
=DESCRIBE
Specialises all the outer universal quantifications in a theorem:
=RULE
all_ƒ_elim
É
ö … ƒ x1 ... xn Ž t[x1, ..., xn]
É
ö … t[x1', ..., xn']
=TEX
where $x1', \ldots, xn'$ are renamed from $x1, \ldots, xn$ as necessary to avoid clashes with
free variables in the assumption list.
=ENDDOC
($GEN\_ALL$ in Cambridge HOL)
=DOC
val âŒ_ƒ_convá : CONV;
=DESCRIBE
Move $Œ$ into a $ƒ$ construct.
=RULE
Œ_ƒ_conv
»Œ (ƒ x Ž t[x])¼
É
É
… (Œ (ƒ x Ž t[x])) ‚ „ x Ž Œ t[x]
=TEX
This will work with any paired universal quantifier.
=FAILURE
27019	Term not of the form: »Œ (ƒ x Ž t[x])¼
	where »x¼ is a varstruct
=ENDDOC
($NOT\_FORALL\_CONV$ in Cambridge HOL)
=DOC
val âƒ_‚_ruleá : TERM -> THM -> THM;
=DESCRIBE
Universally quantify a variable on both sides of an equivalence.
=RULE
ƒ_‚_rule
»x¼
É
ö … p[x] ‚ q[x]
É
ö … (ƒ x Ž p[x]) ‚ (ƒ x Ž q[x])
=TEX
where $x$ is a varstruct.
=FAILURE
7062	Theorem is not of the form: `ö … t1 ‚ t2`
27010	Term is not a varstruct
7070	?0 occurs free in assumption list
=ENDDOC
($FORALL\_EQ$ in Cambridge HOL)
=DOC
val âƒ_arb_elimá : THM -> THM;
=DESCRIBE
Specialise a universally quantified theorem with a machine generated variable.
=RULE
ƒ_arb_elim
É
ö … ƒ x Ž p[x]
É
ö … p[x']
=TEX
where $x'$ is not a variable (free or bound) in $p$.
=ENDDOC
($GSPEC$ in Cambridge HOL)
The precise rules for the name formation of $x$ will not be given here.
=DOC
val âƒ_asm_ruleá : TERM -> TERM -> THM -> THM;
=DESCRIBE
Generalise an assumption (Left $ƒ$ introduction).
=RULE
ƒ_asm_rule
»x¼
»p[x]¼
É
ö, p'[x] … q[x]
É
ö, ƒ x Ž p'[x] … q[x]
=TEX
where $p$ and $p'$ are $\alpha$-convertible.
$x$ {\bf may} be free in $ö$.
=FAILURE
27014	First term is not a varstruct
7055	Second term is not in assumption list
=ENDDOC
This is from \cite{Manna74}.
=DOC
val âƒ_reorder_convá : TERM -> CONV;
=DESCRIBE
Reorder universal quantifications.
=RULE
ƒ_reorder_conv
»ƒ x1 .. xn Ž t1¼
»ƒ y1 .. ym Ž t2¼
É
É
(ƒ y1 .. ym Ž t2) ‚ (ƒ x1 .. xn Ž t1)
=TEX
where the $x_i$ and $y_i$ are varstructs,
and the reordering and renaming requested is valid.
=FAILURE
27015	Cannot prove equation
27016	First term is not boolean
27017	Second term is not boolean
=ENDDOC


We do not give a rule for $ƒƒ$ introduction from \cite{Manna74}.
\subsection{Concerning „}
=DOC
val â„_introá : TERM -> THM -> THM ;
=DESCRIBE
Introduce an existential quantifier by reference to a witness.
=RULE
„_intro
»„ x Ž t1[x]¼
É
ö … t1[t2]
É
ö … „ x Ž t1[x]
=TEX
where »x¼ is varstruct.
=FAILURE
27004	Term is not of the form: »„ x Ž t1[x]¼ where »x¼ is a varstruct
7047	Term cannot be matched to conclusion of theorem
=ENDDOC
($EXISTS$ in Cambridge HOL)
In Cambridge HOL you give $t2$ (i.e. the witness that satisfies the predicate) as another argument, though this
seems only to speed the correctness check, as it may be
derived via $term\_match$.
=DOC
val â„_elimá : TERM -> THM -> THM -> THM ;
=DESCRIBE
Eliminate an existential quantifier by reference to an arbitrary varstruct satisfying the predicate.
=RULE
„_elim
»t1[y]¼
É
ö1 … „ x Ž t1[x]; ö2, t1[y] … t2
É
ö1 ¡ ö2 … t2
=TEX
where $y$ must be a free varstruct, none of whose component variables are present elsewhere in theorems.
=FAILURE
7002	Term is not boolean
7013	Term is not in assumption list of second theorem
7014	Cannot match term to conclusion of first theorem and gain a varstruct
=ENDDOC
($CHOOSE$ in Cambridge HOL)
=DOC
val âŒ_„_convá : CONV;
=DESCRIBE
Move $Œ$ into an $„$ construct.
=RULE
Œ_„_conv
»Œ („ x Ž t[x])¼
É
É
… (Œ („ x Ž t[x])) ‚ ƒ x Ž Œ t[x]
=TEX
This will work with any paired existential quantifier.
=FAILURE
27020	Term is not of the form: »Œ („ x Ž t[x])¼
	where »x¼ is a varstruct
=ENDDOC
($NOT\_EXISTS\_CONV$ in Cambridge HOL)
=DOC
val â„_asm_ruleá : TERM -> TERM -> THM -> THM;
=DESCRIBE
Existentially quantify an assumption (Left $„$ introduction).
=RULE
„_asm_rule
»x¼
»p[x]¼
É
ö, p'[x] … q
É
ö, „ x Ž p'[x] … q
=TEX
where $p$ and $p'$ are $\alpha$-convertible.
where $x$ is not free in $ö$ or $q$.
=FAILURE
27014	First term is not a varstruct
7055	Second term is not in assumption list
7078	?0 is free in conclusion of theorem
7079	?0 is free in of assumptions of theorem
=ENDDOC
This is from \cite{Manna74}.

=DOC
val â„_reorder_convá : TERM -> CONV;
=DESCRIBE
Reorder existential quantifications.
=RULE
„_reorder_conv
»„ x1 .. xn Ž t1¼
»„ y1 .. ym Ž t2¼
É
É
(„ y1 .. ym Ž t2) ‚ („ x1 .. xn Ž t1)
=TEX
where the $x_i$ and $y_i$ are varstructs,
and the reordering and renaming requested is valid.
=FAILURE
27015	Cannot prove equation
27016	First term is not boolean
27017	Second term is not boolean
=ENDDOC

We do not give a rule for $„„$ introduction from \cite{Manna74}.
\subsection{Concerning „$_1$}
=DOC
val â„%down%1_introá : TERM -> THM -> THM -> THM;
=DESCRIBE
Introduce $„_1$ by reference to a witness, and a uniqueness theorem.
=RULE
„%down%1_intro
É
ö1 … P'[t']
ö2 … ƒ x Ž P[x] Š x = t
É
ö1 ¡ ö2 … „%down%1 x Ž P[x]
=TEX
Where $P'$ is $\alpha$-convertible to $P$, and
$t'$ is $\alpha$-convertible to $t$.
Notice that for the resulting theorem we take the varstruct, $x$, and the form of the predicate, $P$, from the second theorem.
=FAILURE
27021	Theorems are not of the form: `ö1 … Pa[ta]` and `ö2 … ƒ x Ž P[x] Š x = t`
	where »Pa¼ and »P¼, »ta¼ and »t¼ are %alpha%-convertible
	and »x¼ is a varstruct
=ENDDOC
=DOC
val â„%down%1_elimá : THM -> THM;
=DESCRIBE
Express a $„_1$ in terms of $„$ and a uniqueness property.
=RULE
„%down%1_elim
É
ö … „%down%1 x Ž P[x]
É
ö … „ x Ž P[x] € ƒ y Ž P[y] Š y = x
=TEX
=FAILURE
27022	Theorem is not of the form: `ö … „%down%1 x Ž P[x]`
	where »x¼ is a varstruct
=ENDDOC
This could be rewritten to produce two theorems,
`$„\ x\ Ž\ P[x]$` and `$ƒ\ x\ y\ Ž\ P[x]\ €\ P[y]\ Š\ x\ =\ y$`
\subsection{Concerning ‡}
=DOC
val â„_‡_ruleá : THM -> THM;
=DESCRIBE
Give that $‡$ of a predicate satisfies the predicate by reference to an $„$ construct.
It can properly handle paired existence.
=RULE
„_‡_rule
É
ö … „ x Ž p[x]
É
ö … p(‡ x Ž p x)
=TEX
=SEEALSO
$„\_‡\_conv$
=FAILURE
27024	Theorem is not of the form: `ö … „ x Ž p[x]`
	where »x¼ is a varstruct
=ENDDOC
($SELECT\_RULE$ in Cambridge HOL)
=DOC
val â„_‡_convá : CONV;
=DESCRIBE
Give that $‡$ of a predicate satisfies the predicate by reference to an $„$ construct.
It can properly handle paired existence.
=RULE
„_‡_conv
»„ x Ž p[x]¼
É
É
ö … („ x Ž p[x]) = p(‡ x Ž p x)
=TEX
=SEEALSO
$„\_‡\_rule$
=FAILURE
27024	Theorem is not of the form: `ö … „ x Ž p[x]`
	where »x¼ is a varstruct
=ENDDOC
\subsection{Concerning Local Definitions}
=DOC
val âlet_intro_ruleá : (string * TERM) -> THM -> THM;
=DESCRIBE
Introduce a local definition.
=RULE
let_intro_rule
[...,("xi", »ti¼),...]
É
ö … t[t1,...tn]
É
ö … let x1' = t1 and ... xn' = tn 
	in t2[x1',...,xn']
=TEX
where $x_i'$ in the result are variables with the names $x_i$, and with the type of $t_i$, perhaps made into variants to avoid variable capture.
=ENDDOC
Perhaps we should provide a template of what $t[...]$ should look like, so that not all instances of $t_i$ are changed to $x_i$.
Perhaps we should fail, rather than rename, if variable capture occurs.
=DOC
val âlet_elim_ruleá : THM -> THM;
=DESCRIBE
Eliminate an outermost $let\ldots and\ldots in\ldots$ construct.
=RULE
let_elim_rule
É
ö … let x1 = t1 and ... xn = tn 
	in t[x1,...,xn]
É
ö … t[t1,...,tn]
=TEX
=ENDDOC
=DOC
val âlet_convá : CONV;
=DESCRIBE
Eliminate an outermost $let\ldots and\ldots in\ldots$ construct.
=CONVERSION
let_elim_rule
»let v1 = t1 and ... vn = tn 
 in t[v1,...,vn]¼
É
É
… (let v1 = t1 and ... vn = tn in 
	t[v1,...,vn]) 
	= t[t1,...,tn]
=TEX
=ENDDOC

\subsection{Concerning $Uncurry$}
I don't believe we need a rule for eliminating $Uncurry$,
and its introduction is mostly behind the scenes.

\section{SUPPORTING THEORY}
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of DerivedInferenceRulesII *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
