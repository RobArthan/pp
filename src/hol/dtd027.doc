=IGN
********************************************************************************
dtd027.doc: this file is part of the PPHol system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% dtd027.doc   %Z% $Date: 2002/10/17 16:20:01 $ $Revision: 1.27 $ $RCSfile: dtd027.doc,v $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design of Derived Rules of Inference II}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Derived Rules of Inference II}
\TPPref{DS/FMU/IED/DTD027}  %% Mandatory field
\def\SCCSversion{$Revision: 1.27 $ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2002/10/17 16:20:01 $ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for further 
derived rules of inference in ICL HOL,
in particular those concerned with paired abstractions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Fixed an error message.
\item [Issue 1.3]
Gained inference rules about sets.
\item [Issue 1.4]
Gained tautology material.
\item [Issue 1.5]
Changes with a view to implementation,
and to reflect changes in \cite{DS/FMU/IED/DTD007} issue 2.1.
\item [Issue 1.6]
Changes made during implementation.
\item [Issue 1.7]
Changed name of signature.
\item [Issue 1.8]
Changed $¶_1\_elim$.
Added $¶_1\_conv$, $varstruct\-\_variant$,
tidied up.
\item [Issue 1.9]
Clarified $µ\_reorder\_conv$ and $¶\_reorder\_conv$

\item[Issue 1.10, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.11,(13th February 1992)]
Moving material from 058 to 027.
\item [Issue 1.12 (11th March 1992)]
Fixing typos.
\item [Issue 1.13 (11th March 1992)]
Various minor additions and extensions.
\item [Issue 1.14]
Removed percent keywords.
\item [Issue 1.15]
Removed sets material.
\item [Issue 1.16 (13th April 1992)]
Changes due to CR0017.
\item [Issue 1.17 (11th May 1992)]
Made $µ\_elim$ matching.
\item[Issue 1.18 (14 May 1992)] Use correct quotation symbols.
\item [Issue 1.19 (2nd July 1992)]
Tidying text.
\item [Issue 1.20 (30 July 1992)]
Added forward chaining rules and minor mods to matching modus
ponens (to accomodate changes to the simple versions).
\item [Issue 1.21] Changed $fc\_rule$ in light of comments on first version.
\item [Issue 1.22 (20th August 1992)]
Corrected typo.
\item [Issue 1.23 (11th November 1992)]
Added fancy variants on $fc\_canon$.
\item [Issue 1.24 (16th February 1993)]
Modified forward chaining.
\item [Issue 1.25)]
New forward chaining canon.
\item[Issue 1.26] Copyright and banner updates for open source release.
\item[Issue 1.27] PPHol-specific updates for open source release
\item[Issue 1.28] Fixed typo in description of
=INLINEFT
fc_¤_canon
=TEX
.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
derived rules of inference concerning paired abstractions.
This is called for in \cite{DS/FMU/IED/HLD012}.
The design is
implemented in \cite{DS/FMU/IED/IMP027}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
paired abstraction
derived rules of inference in Release 001 of ICL HOL,
as well as some further inference rules.

The document provides groups of rules of inference, related by their core operator.

All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP027}.

\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.

This document places requirements upon the constants handled by the
inference rules discussed.
In summary, the requirements are that the definitions of the constants must be such that the designs of the rules are satisfiable.
\subsubsection{Deficiencies}
The coverage of some of the material provided is uneven.
This is the result of those functions being a toolbox to achieve
a particular goal.
.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Terminology}
We use ``varstruct'' or ``(allowed) variable structure (in ICL HOL syntax)'' to indicate terms that 
satisfy the concrete syntax rule for $V$  (see \cite{DS/FMU/IED/DEF001}),
i.e. the kind of terms that may be
bound in an abstraction.
They are formed from variables by pairing: a simple variable is one example of a ``varstruct''.
\section{THE DERIVED RULES OF REASONING}
=DOC
signature ÛDerivedRules2Ý = sig
=DESCRIBE
This provides the further derived rules of inference for ICL HOL.
They are primarily concerned with handling paired abstractions.
=ENDDOC
\subsection{Tools For Variable Structures}
=DOC
val Ûvarstruct_variantÝ : TERM list -> TERM -> TERM;
=DESCRIBE
$varstruct\_variant$ $avoid$ $vs$ will recreate the variable structure $vs$ using only names that are not found in the
$avoid$ list of variables, and also renaming to avoid
duplicate variable names in the structure.
Variant names are found using $string\_variant$ (q.v.).
If there are duplicates to be renamed, then the original
name will be the rightmost in the variable structure.
=FAILURE
3007	?0 is not a term variable
4016	?0 is not an allowed variable structure
=FAILUREC
Message 3007 applies to the avoid list, 27060 to the variable
structure.
=ENDDOC
\subsection{Concerning ± and ²}
=DOC
val ÛALL_±_CÝ : CONV -> CONV;
val ÛALL_²_CÝ : CONV -> CONV;
=DESCRIBE
These respectively apply their conversion argument to:
\begin{itemize}
\item
All the conjuncts of a structure of conjuncts (including a term that is not a conjunct at all)
failing only if the conversion fails for all the conjuncts.
\item
All the disjuncts of a structure of disjuncts (including a term that is not a disjunct at all)
failing only if the conversion fails for all the disjuncts.
\end{itemize}
The result is simplified at any conjunct 
or disjunct where at least one branch had a successful
application of the conversion and matches the appropriate theorems of:
=GFT
ô µ t· (T ± t ¤ t) ± (t ± T ¤ t) ± ³ (F ± t) ± ³ (t ± F) ± (t ± t ¤ t)

ô µ t· (T ² t) ± (t ² T) ± (F ² t ¤ t) ± (t ² F ¤ t) ± (t ² t ¤ t)
=TEX
=FAILUREC
\paragraph{Errors}
As the failure of the conversion argument.
=ENDDOC

\subsection{Concerning ´}
=DOC
val Û´_match_mp_ruleÝ : THM -> THM -> THM ;
=DESCRIBE
A matching Modus Ponens rule for an implicative theorem.
=FRULE 1 Rule
´_match_mp_rule
÷
‡1 ô µ x1 ...· t1 ´ t2; ‡2 ô t1'
÷
‡1' À ‡2 ô t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's antecedent to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.

This may be partially evaluated with only the first argument.
=SEEALSO
$´\_match\_mp\_rule1$, $´\_elim$
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC
=DOC
val Û´_match_mp_rule1Ý : THM -> THM -> THM ;
=DESCRIBE
A matching Modus Ponens rule for an implicative theorem.
=FRULE 1 Rule
´_match_mp_rule
÷
‡1 ô µ x1 ...· t1 ´ t2; ‡2 ô t1'
÷
‡1 À ‡2 ô t2'
=TEX
where $t1'$ is an instance of $t1$ under type instantiation
and substitution for the $x‰i$ and the free variables of the
first theorem, and where $t2'$
is the corresponding instance of $t2$.
No type instantiation or substitution will occur in the assumptions of either
theorem.

This may be partially evaluated with only the first argument.
=FAILURE
7044	Cannot match ?0 and ?1
7045	?0 is not of the form `‡ ô µ x1 ... xn · u ´ v`
=ENDDOC
=DOC
val Ûforward_chain_ruleÝ : THM list -> THM list -> THM list;
val Ûfc_ruleÝ : THM list -> THM list -> THM list;
=DESCRIBE
This is a rule which uses a list of possibly universally
quantified implications and a list of
other theorems to infer new theorems, using
=INLINEFT
´_match_mp_rule1
. (
=INLINEFT
fc_rule
=TEX
\ is an alias for
=INLINEFT
forward_chain_rule
=TEX
.)
=INLINEFT
fc_rule imps ants
=TEX
\ returns the list of all theorems which may be derived by
applying
=INLINEFT
´_match_mp_rule1
=TEX
\ to a theorem from $imps$ and one from $ants$.
As a special case, if any theorem to be returned is determined
to have $¬F®$ as its conclusion, the first duch found wil be returned as a singleton list.
In order to work well in conjunction with
=INLINEFT
fc_canon
=TEX
\ and
=INLINEFT
fc_tac
=TEX
\ the theorems returned by
=INLINEFT
´_match_mp_rule1
=TEX
\ are transformed as follows:

\begin{enumerate}
\item
Theorems of the form:
=INLINEFT
ô µ x‰1 ...· t‰1 ´ t‰2 ´ ... ´ ³t‰k ´ F
=TEX
\ have their final implication changed to
=INLINEFT
t‰k
=TEX
.
\item
Theorems of the form:
=INLINEFT
ô µ x‰1 ...· t‰1 ´ t‰2 ´ ... ´ t‰k ´ F
=TEX
\ have their final implication changed to
=INLINEFT
´\³t‰k
=TEX
.
\item
All theorems are universally quantified over all the variables which
appear free in their conclusions but not in their assumptions
(using
=INLINEFT
all_µ_intro
=TEX
).
\end{enumerate}
Note that the
use of
=INLINEFT
´_match_mp_rule1
=TEX
\ gives some control over the number of results generated, since
variables which appear free in $imps$ are not considered as candidates
for instantiation.

The rule does not check that the theorems in its first argument
are (possible universally) quantified implications. Theorems which are
not of this form will be ignored.
=SEEALSO
$forward\_chain\_tac$, $forward\_chain\_canon$.
=ENDDOC

=DOC
val ÛFORWARD_CHAIN_CANÝ : CANON list -> CANON;
val ÛFC_CANÝ : CANON list -> CANON;
=DESCRIBE
=INLINEFT
FORWARD_CHAIN_CAN
=TEX
, which has the alias
=INLINEFT
FC_CAN
=TEX
, is a parameterised variant of
=INLINEFT
fc_canon
=TEX
. Given a list of canonicalisation functions $cans$,
=INLINEFT
FC_CAN cans
=TEX
\ behaves as
=INLINEFT
fc_canon
=TEX
\ would do if the line
=GFT
ô A		­	FIRST_CAN cans A
=TEX
were inserted at the beginning of the table of transformations given
in the description of
=INLINEFT
fc_canon
=TEX
.

For example,
=INLINEFT
fc_canon1
=TEX
, q.v., is the same as:

=GFT
	FC_CAN ((fn (x, y) => [x,y]) o ¤_elim);
=TEX
=USES
In tactic programming, or, occasionally interactively, typically in
circumstances where neither
=INLINEFT
fc_canon
=TEX
\ nor
=INLINEFT
fc_canon1
=TEX
\ is able to generate enough implications.
=ENDDOC

=DOC
val Ûforward_chain_canonÝ : THM -> THM list;
val Ûfc_canonÝ : THM -> THM list;
val Ûforward_chain_canon1Ý : THM -> THM list;
val Ûfc_canon1Ý : THM -> THM list;
=DESCRIBE
=INLINEFT
forward_chain_canon
=TEX
\ is a canonicalisation function which uses a theorem
to generate a list of
implications. (%
=INLINEFT
fc_canon
=TEX
\ is an alias for
=INLINEFT
forward_chain_canon
=TEX
.)
It may be used for constructing rules and tactics in conjunction
with
=INLINEFT
forward_chain_rule
=TEX
.
An example of such a tactic is
=INLINEFT
forward_chain_tac
=TEX
.
=INLINEFT
forward_chain_canon1
=TEX
, which has alias
=INLINEFT
fc_canon1
=TEX
, is just like
=INLINEFT
fc_canon
=TEX
\ except for its treatment of bi-implications.
The effects of
=INLINEFT
fc_canon
=TEX
\ and
=INLINEFT
fc_canon1
=TEX
\ are shown schematically in the following table (which only
shows assumptions relevant to the process):

=GFT
ô A ± B		­	ô A ; ô B
ô µx·A		­	ô A[x'/x]
ô A ± B ´ C	­	map (´_intro (st¬A®)) (xf( st¬A® ô B ´ C ))
ô A ² B ´ C	­	xf( ô (A ´ C) ± (B ´ C) )
ô (¶x·A) ´ C	­	map (µ_intro ¬x'®) (xf( ô A[x'/x] ´ B ))
A ô A ´ B		­	A ô B
ô T ´ B		­	ô B
A ô ³A ´ B		­	(* discarded *)
ô F ´ B		­	(* discarded *)
ô A ´ B		­	map (´_intro (st¬A®)) (xf( st¬A® ô B ))
ô A ¤ B		­	ô A ´ B			(* fc_canon *)
ô A ¤ B		­	ô A ´ B; ô B ´ A		(* fc_canon1 *)
ô T			­	(* discarded *)
ô A			­	ô sc¬A®
ô A			­	ô ³A ´ F
=TEX

The intention here is that
is that the first applicable transformation is applied repeatedly
until no further change is possible. The resulting theorems are
then universally quantified over
all of the free variables in their conclusions which were not free
in the original theorem.
In the table, $st$ and $sc$ stand for attempts to apply the
theorem and conclusion stripping conversions in the current proof context
(as returned by
=INLINEFT
current_ad_st_conv
=TEX
\ and
=INLINEFT
current_ad_sc_conv
=TEX
). If the stripping conversions fail then $st$ and $sc$ have no effect.
$x'$ denotes a variable name derived from $x$ and
chosen to avoid variable capture problems.
$xf$ stands for a nested recursive application of the transformation process.

In the transformations involving
=INLINEFT
´_intro
=TEX
\ the implication is only introduced if the antecedent is in the assumptions.
So, for example,
=INLINEFT
A ´ B ´ A ´ C
=TEX
\ is transformed into
=INLINEFT
B ´ A ´ C
=TEX
.
The transformation for
=INLINEFT
A ´ B
=TEX
\ is only applied if it changes the theorem, and the last of the
transformations is only applied if $A$ is neither an implication nor $F$.

The asymmetry in the rules is deliberate.
E.g., they derive
=INLINEFT
A ´ B ´ C
=TEX
\ from
=INLINEFT
A ± B ´ C
=TEX
, but not
=INLINEFT
B ´ A ´ C
=TEX
. This is intended to give slightly finer control and to result
in less duplication of results in the intended application
in
=INLINEFT
forward_chain_tac
=TEX
 (q.v.). 

=SEEALSO
$forward\_chain\_rule$, $forward\_chain\_tac$, $FC\_CAN$
=ENDDOC

=DOC
val ÛFORWARD_CHAIN_¤_CANÝ : CANON list -> CANON;
val ÛFC_¤_CANÝ : CANON list -> CANON;
=DESCRIBE
These are just like
=INLINEFT
FORWARD_CHAIN_CAN
=TEX
, q.v., except that they do {\em not} break up bi-implications.
Thus, given a list of canonicalisation functions $cans$,
=INLINEFT
FC_¤_CAN cans
=TEX
\ behaves as
=INLINEFT
fc_canon
=TEX
\ would do if the line
=GFT
ô A		­	FIRST_CAN cans A
=TEX
were inserted at the beginning of the table of transformations given
in the description of
=INLINEFT
fc_canon
=TEX
 and all transformations (including those coming from the proof context) that eliminate bi-implications were suppressed.

=USES
In tactic programming, or, occasionally interactively, typically in
circumstances where
=INLINEFT
fc_¤_canon
=TEX
\ is not able to generate enough implications.
=ENDDOC
=DOC
val Ûforward_chain_¤_canonÝ : THM -> THM list;
val Ûfc_¤_canonÝ : THM -> THM list;
=DESCRIBE
=INLINEFT
forward_chain_¤_canon
=TEX
\ is a canonicalisation function very similar to
=INLINEFT
forward_chain_canon
=TEX
, q.v.
The difference is that 
=INLINEFT
forward_chain_¤_canon
=TEX
\ suppresses all transformations which break up bi-implications.
It is intended for use in situations where a bi-implication is to be used as a conditional rewrite rule.

For example, the tactic
=INLINEFT
ALL_ASM_FC_T1 fc_¤_canon rewrite_tac []
=TEX
\ can instantiate an assumption of the form
=INLINEFT
µx1 x2 ...· A ´ B ´ (C ¤ D)
=TEX
\ and use the result to rewrite instances of $C$. 
=SEEALSO
$FC\_T1$, $ALL\_FC\_T1$ etc.
=ENDDOC

\subsection{Concerning ¤}
=DOC
val Û¤_match_mp_ruleÝ : THM -> THM -> THM;
=DESCRIBE
A matching Modus Ponens for $¤$.
=FRULE 1 Rule
¤_match_mp_rule
÷
‡1 ô µ x1 ...· t1 ¤ t2; ‡2 ô t1'
÷
‡1' À ‡2 ô t2'
=TEX
where we type instantiate, generalise and specialise
both conclusion and assumptions
to get the first theorem's LHS to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.

This may be partially evaluated with only first argument.
=SEEALSO
$´\_elim$ (Modus Ponens on $´$),
$simple\_¤\_match\-\_mp\_rule$
$¤\-\_mp\-\_rule$
$¤\-\_match\-\_mp\-\_rule1$
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC
=DOC
val Û¤_match_mp_rule1Ý : THM -> THM -> THM;
=DESCRIBE
A matching Modus Ponens for $¤$ that doesn't affect assumption lists.
=FRULE 1 Rule
¤_match_mp_rule1
÷
‡1 ô µ x1 ...· t1 ¤ t2; ‡2 ô t1'
÷
‡1 À ‡2 ô t2'
=TEX
where $t1'$ is an instance of $t1$ under type instantiation
and substitution for the $x‰i$ and the free variables of the
first theorem, and where $t2'$
is the corresponding instance of $t2$.
No type instantiation or substitution will occur in the assumptions of either
theorem.

This may be partially evaluated with only first argument.
=SEEALSO
$´\_elim$ (Modus Ponens on $´$),
$simple\_¤\_match\_mp\_rule1$
=FAILURE
7044	Cannot match ?0 and ?1
7046	?0 is not of the form `‡ ô µ x1 ... xn · u ¤ v`
=ENDDOC

\subsection{Concerning =}
=DOC
val Ûeq_match_convÝ : THM -> CONV ;
=DESCRIBE
This matches the LHS of an equational theorem to a term,
instantiating the RHS accordingly.
The equational theorem may be partially or fully universally quantified
(simple or by varstruct),
without affecting the result of the conversion.
=FRULE 1 Conversion
eq_match_conv
(‡ ô µ ...· u = v)
¬t®
÷
÷
‡ ô t = v'
=TEX
where $v'$ is the result of applying to $v$ the instantiation rules required to match $u$ to $t$
(including both term and type instantiation).
If there are free variables on the RHS of the supplied equational theorem (when stripped of all universal quantification)
they will be renamed as necessary to avoid identification with
any variables in $t$.

This conversion may be partially evaluated with only its theorem argument.
=SEEALSO
$eq\_match\_conv1$
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC

=DOC
val Ûeq_match_conv1Ý : THM -> CONV ;
=DESCRIBE
This matches the LHS of an universally quantified (simple or by varstruct) equational theorem to a term,
instantiating the RHS accordingly.
The conversion will only instantiate its universal quantifications,
and type variables not found within the assumptions, not its free term variables.
=FRULE 1 Conversion
eq_match_conv1
(‡ ô µ x1 ... xn· u[x1,...,xn] = 
   v[x1,...,xn])
¬t®
÷
÷
‡ ô t = v[t1,...,tn]
=TEX
where ¬u[t1,...,tn]® is $Á$-convertible to ¬t®.
If there are free variables on the RHS of the supplied equational theorem (when stripped of all universal quantification)
they will be renamed as necessary to avoid identification with
any variables in $t$.

This conversion may be partially evaluated with only its theorem argument.
=USES
In producing a limited rewriting facility, that only instantiates
explicitly identified variables.
=FAILURE
27003	?0 is not of the form `‡ ô µ x1 ... xn· u = v`
	where ¬xi® are varstructs
7076	Could not match term ?0 to LHS of theorem ?1
=ENDDOC
\subsection{Concerning Ì}
=DOC
val ÛÂ_ruleÝ : THM -> THM;
=DESCRIBE
An elimination rule for $Ì$, which can handle paired abstractions.
=FRULE 1 Rule
Â_rule
÷
‡ ô (Ì x· t[x]) y
÷
‡ ô t[y]
=TEX
=SEEALSO
$Â\_conv$
=FAILURE
27007	?0 is not of the form: `‡ ô (Ì x· t[x]) y`
	where ¬x® is a varstruct
=ENDDOC
=DOC
val ÛÂ_convÝ : CONV;
=DESCRIBE
Apply a $Â$-reduction to an abstraction.
=FRULE 1 Rule
Â_conv
¬(Ì x· t1[x])t2®
÷
÷
ô ((Ì x· t[x])y) = t'[y]
=TEX
where $x$ may be any varstruct allowed by the ICL HOL syntax, 
$y$ is an instance of this structure,
and $t'$ is $Á$-convertible to $t$, changed to avoid variable capture.

When the bound variable structure has a pair,
where the value applied to does not, then $Fst$ and $Snd$ are
introduced as necessary, e.g.:
=GFT Example
Â_conv ¬(Ì (x,y)· f x y) p® =
	ô (Ì (x,y)· f x y) p = f (Fst p) (Snd p)
=TEX
=SEEALSO
$simple\_Â\_conv$, $Â\_rule$
=FAILURE
27008	?0 is not of the form: ¬(Ì x· t1[x])t2®
	where ¬x® is a varstruct
=ENDDOC
=DOC
val Ûall_Â_convÝ : CONV;
=DESCRIBE
A conversion to eliminate all instances of $Â$ redexes,
including paired abstraction redexes, in a term, regardless of nesting, or even that the $Â$ redex was created as the result of
an earlier reduction in the conversion's evaluation.
=FRULE 1 Rule
all_Â_conv
¬t®
÷
÷
ô t = t'
=TEX
$t'$ is $t$ with all $Â$ redexes reduced.
=USES
This uses an optimised term traversal algorithm, superior in speed
to the general term traversal algorithms used with conversions,
and should be used in preference to them and $Â\_conv$.
=SEEALSO
$all\_simple\_Â\_conv$ which only handles simple
$Â$-redexes, but does a faster traversal if that is all that is required.
$all\_Â\_rule$.
=FAILURE
27049	?0 contains no Â-redexes
=ENDDOC
=DOC
val Ûall_Â_ruleÝ : THM -> THM;
=DESCRIBE
Eliminate all instances of $Â$ redexes,
including paired abstraction redexes, in the conclusion of a theorem, regardless of nesting, or even that the $Â$ redex was created as the result of
an earlier reduction in the rule's evaluation.
=FRULE 1 Rule
all_Â_rule
÷
‡ ô t
÷
‡ ô t'
=TEX
$t'$ is $t$ with all $Â$-redexes reduced.
=SEEALSO
$all\_Â\_conv$ for the conversion.
$all\_simple\_Â\_rule$ which only handles simple
$Â$-redexes, but does a faster traversal if that is all that is required.
=FAILURE
27049	?0 contains no Â-redexes
=ENDDOC
=DOC
val ÛÌ_eq_ruleÝ : TERM -> THM -> THM;
=DESCRIBE
Given an equational theorem, return the equation formed by abstracting the term argument (which must be an allowed variable structure) from both sides.
=FRULE 1 Rule
Ì_eq_rule
¬x®
÷
‡ ô t1[x] = t2[x]
÷
‡ ô (Ì x· t1[x]) = (Ì x· t2[x])
=TEX
=FAILURE
4016	?0 is not an allowed variable structure
6005	?0 occurs free in assumption list
6020	?0 is not of the form: `‡ ô t1 = t2`
=ENDDOC
=DOC
val ÛÈ_convÝ : CONV;
=DESCRIBE
The rule for $\eta$ conversion.
=FRULE 1 Conversion
È_conv
¬Ì vs· t vs®
÷
÷
ô (Ì vs· t vs) = t
=TEX
where $t$ contains no free instances of the variables of varstruct $vs$.
=FAILURE
27018	?0 is not of the form: ¬Ì vs· t vs'®
	where ¬vs® is a varstruct
27023	?0 is not of the form: ¬Ì vs· t vs® where ¬t® should not contain ¬vs®
=ENDDOC
=DOC
val ÛÌ_varstruct_convÝ : TERM -> CONV;
=DESCRIBE
This conversion allows one to change between any lambda abstracted varstruct
that has the same type.
=FRULE 1 Rule
Ì_varstruct_conv
¬Ì vs1[x1,y1,...]· t[x1,y1,...]®
¬Ì vs2[x2,y2,...]· t'[x2,y2,...]®
÷
÷
ô (Ì vs2[x2,y2,...]· t[x2,y2,...]) =
	(Ì vs1[x1,y1,...]· t'[x1,y1,...])
=TEX
Where the types of $vs1[x1,y1,...]$ and $vs2[x2,y2,...]$
are the same, and $t'$ and $t$ differ only in applications of $Fst$ and $Snd$ to the bound variables.

Note that before more sophisticated attempts, the conversion
will try $Á\_conv$ on the two term arguments.
=SEEALSO
$Á\_conv$ for a more limited form of renaming.
=FAILURE
27050	Cannot prove equality of ?0 and ?1
=ENDDOC
This is implemented using two $Â$-reductions, one for each term applied to the same machine-generated variable.
Worse, if a simple approach fails, it will attempt to pull $Fst$ and $Snd$ together by pure rewriting.
It is thus potentially not very fast.

\subsection{Concerning µ}
=DOC
val Ûµ_uncurry_convÝ : CONV;
=DESCRIBE
Convert a paired universally quantified term into
simple universal quantifications of the same term.
=FRULE 1 Conversion
µ_uncurry_conv
¬µ vs[x,y,...]· f[x,y,...]®
÷
÷
‡ ô µ vs[x,y,...]· f[x,y,...] = 
	µ x y ...· f[x,y,...]
=TEX
where $vs[x,y,...]$ is an allowed variable structure with
variables $x,y,...$.
It may not be a simple variable.
=SEEALSO
$Ì\_varstruct\_conv$, $all\_µ\_uncurry\_conv$.
=FAILURE
27038	?0 is not of the form: ¬µ (x,y)· f®
=ENDDOC
=DOC
val Ûall_µ_uncurry_convÝ : CONV;
=DESCRIBE
Apply $µ\_uncurry\_conv$ (q.v) to the outer universal
quantifications of a term,
flattening those binders.
=FRULE 1 Conversion
all_µ_uncurry_conv
¬µ vs1[x1,y1,...] vs2[x2,y2,...] ...· 
	f[x1,y1,...,x2,y2,...]®
÷
÷
‡ ô (µ vs1[x,y,...] vs2[x,y,...] ...· 
	f[x1,y1,...,x2,y2,...])
 = (µ x1 y1 ... x2 y2 ...· 
	f[x1,y1,...,x2,y2,...])
=TEX
where the $vs_i[x_i,y_i,...]$ are variable structures
at least one of which must not be a simple variable,
built from variables $x_i,y_i,...$,
=FAILURE
27041	?0 is not of the form: ¬µ ... (x,y) ...· f®
=ENDDOC
=DOC
val Ûµ_introÝ : TERM -> THM -> THM;
=DESCRIBE
Introduce a universally quantified theorem.
=FRULE 1 Rule
µ_intro
¬x®
÷
‡ ô t
÷
‡ ô µ x'· t
=TEX
Where $¬x'®$ is an allowed variable structure based on $¬x®$, but with
duplicate variables renamed, the original name being rightmost in the resulting variable structure.
=SEEALSO
$list\_µ\_intro$, $all\_µ\_intro$.
=FAILURE
4016	?0 is not an allowed variable structure
6005	?0 occurs free in assumption list
=ENDDOC
=DOC
val Ûµ_elimÝ : TERM -> THM -> THM;
=DESCRIBE
Specialise a universally quantified theorem with a given value, instantiating the type of the theorem as necessary.
=FRULE 1 Rule
µ_elim
¬t1®
÷
‡ ô µ x· t2[x]
÷
‡ ô t2'[t1]
=TEX
where $t2'$ is renamed from $t2$ to prevent bound variable capture and possibly type instantiated,
and $x$ is a varstruct, instantiable to the structure of $t1$.
The value $t1$ will be expanded using $Fst$ and $Snd$ as necessary to match
the structure of $¬x®$.
=SEEALSO
$list\_µ\_elim$, $all\_µ\_elim$.
=FAILURE
27011	?0 is not of the form: `‡ ô µ x· t` where ¬x® is a varstruct
27012	?0 is not of the form: `‡ ô µ x· t` where the type of ¬x® 
	is instantiable to the type of ?1
27013	?0 is not of the form: `‡ ô µ x· t` where the type of ¬x® 
	is instantiable to the type of ?1 without instantiating
	type variables in the assumptions
=ENDDOC
=DOC
val Ûlist_µ_introÝ : TERM list -> THM -> THM;
=DESCRIBE
Generalised $µ$ introduction.
=FRULE 1 Rule
list_µ_intro
[¬x1®, ..., ¬xn®]
÷
‡ ô t[x1, ..., xn]
÷
‡ ô µ x1 ... xn· t[x1, ..., xn]
=TEX
=SEEALSO
$µ\_intro$, $all\_µ\_intro$.
=FAILUREC
\paragraph{Errors}
Same messages as $µ\_intro$.
=ENDDOC
=DOC
val Ûlist_µ_elimÝ : TERM list -> THM -> THM;
=DESCRIBE
Generalised $µ$ elimination.
Specialise a universally quantified theorem with given values, instantiating the types of the theorem as necessary.
=FRULE 1 Rule
list_µ_elim
[¬t1®, ..., ¬tn®]
÷
‡ ô µ x1 ... xn· t[x1, ..., xn]
÷
t'[t1, ..., tn]
=TEX
where $t'$ is renamed from $t$ to prevent bound variable capture and type instantiated as necessary,
the $x_i$ are varstructs, instantiable to the structures of $t_i$.
The values will be expanded using $Fst$ and $Snd$ as necessary to match
the structure of $¬x®$.

Note that due to the type instantiation this function is somewhat
more that a $fold$ of $µ\_elim$.
=SEEALSO
$µ\_elim$, $all\_µ\_elim$.
=FAILURE
27014	?0 is not of the form: `‡ ô µ vs1 ... vsi · t` where
	i ¾ ?1
27015	?0 is not of the form: `‡ ô µ vs1 ... vsi · t` where the types of the vsi
	are instantiable to the types of ?1
27016	?0 is not of the form: `‡ ô µ vs1 ... vsi · t` where the types of the vsi
	are instantiable to the types of ?1 without instantiating
	type variables in the assumptions
=ENDDOC
The following is a design error caused by a check being passed by
that should have stopped processing:
=FAILURE
27017	DESIGN ERROR: counting arguments
=TEX
=DOC
val Ûall_µ_elimÝ : THM -> THM;
=DESCRIBE
Specialises all the outer universal quantifications in a theorem:
=FRULE 1 Rule
all_µ_elim
÷
‡ ô µ x1 ... xn· t[x1, ..., xn]
÷
‡ ô t[x1', ..., xn']
=TEX
where $x1', \ldots, xn'$ are renamed from $x1, \ldots, xn$ as necessary to avoid name clashes with
free variables in the assumption list.
=SEEALSO
$all\_µ\_arb\_elim$ which is faster, though the results are
slightly opaque.
$list\_µ\_elim$.
=ENDDOC
=DOC
val Û³_µ_convÝ : CONV;
=DESCRIBE
Move $³$ into a $µ$ construct.
=FRULE 1 Rule
³_µ_conv
¬³ (µ x· t[x])®
÷
÷
ô (³ (µ x· t[x])) ¤ ¶ x· ³ t[x]
=TEX
=SEEALSO
$³\_simple\_µ\_conv$ which only works with simple $µ$-abstractions, $³\_¶\_conv$
=FAILURE
27019	?0 not of the form: ¬³ (µ x· t[x])®
	where ¬x® is a varstruct
=ENDDOC
=DOC
val Ûµ_¤_ruleÝ : TERM -> THM -> THM;
=DESCRIBE
Universally quantify a variable on both sides of an equivalence.
=FRULE 1 Rule
µ_¤_rule
¬x®
÷
‡ ô p[x] ¤ q[x]
÷
‡ ô (µ x· p[x]) ¤ (µ x· q[x])
=TEX
where $x$ is a varstruct.
=FAILURE
6005	?0 occurs free in assumption list
6020	?0 is not of the form: `‡ ô t1 = t2`
7062	?0 is not of the form: `‡ ô t1 ¤ t2`
4016	?0 is not an allowed variable structure
=ENDDOC
=DOC
val Ûµ_arb_elimÝ : THM -> THM;
=DESCRIBE
Specialise a universally quantified theorem with a machine generated variable or variable structure.
=FRULE 1 Rule
µ_arb_elim
÷
‡ ô µ vs[x,y,...]· p[x,y,...]
÷
‡ ô p[x',y',...]
=TEX
where $x'$, $y'$, etc, are not variables (free or bound) in $p$ or $‡$,
created by $gen\_vars$(q.v).
=SEEALSO
$µ\_elim$
=FAILURE
27011	?0 is not of the form: `‡ ô µ x· t` where ¬x® is a varstruct
=ENDDOC
=DOC
val Ûall_µ_arb_elimÝ : THM -> THM;
=DESCRIBE
Specialise all the quantifiers of a possibly universally quantified theorem with a machine generated variables or variable structures.
=FRULE 1 Rule
µ_arb_elim
÷
‡ ô µ vs1[x1,y1,...] vs2[x2,y2,...] ...· 
	p[x1,y1,....x2,y2,...]
÷
‡ ô p[x1',y1',...,x2',y2',...]
=TEX
where $x_i'$, $y_i'$, etc, are not variables (free or bound) in $p$ or $‡$,
created by $gen\_vars$(q.v).
=SEEALSO
$all\_µ\_elim$
=ENDDOC
The precise rules for the name formation of $x$ will not be given here.
=DOC
val Ûµ_asm_ruleÝ : TERM -> TERM -> THM -> THM;
=DESCRIBE
Generalise an assumption (Left $µ$ introduction).
=FRULE 1 Rule
µ_asm_rule
¬x®
¬p[x]®
÷
‡, p'[x] ô q[x]
÷
‡, µ x· p'[x] ô q[x]
=TEX
where $p$ and $p'$ are $Á$-convertible.
$x$ {\bf may} be free in $‡$.
The function will work even if $p'[x]$ is not present
in the assumption list.
=FAILURE
4016	?0 is not an allowed variable structure
=ENDDOC
This is from \cite{Manna74}.
=DOC
val Ûµ_reorder_convÝ : TERM -> CONV;
=DESCRIBE
Reorder universal quantifications.
=FRULE 1 Rule
µ_reorder_conv
¬µ x1 .. xn· t1®
¬µ y1 .. ym· t2®
÷
÷
(µ y1 .. ym· t2) ¤ (µ x1 .. xn· t1)
=TEX
where the $x_i$ and $y_i$ are varstructs,
and the reordering, restructuring (by pairing) and renaming requested is provable by this function.
The presence of redundant quantifiers, including duplicates, is also handled.
=EXAMPLE
:> µ_reorder_conv ¬µ (x,q) z· x ± z® ¬µ (z,z,y) x· x ± z®;
val it = ô (µ (z, z, y) x· x ± z) ¤ (µ (x, q) z· x ± z) : THM
Note that before more sophisticated attempts, the conversion
will try $Á\_conv$ on the two term arguments.
=SEEALSO
$¶\_reorder\_conv$
=FAILURE
27050	Cannot prove equality of ?0 and ?1
=ENDDOC

We do not give a rule for $µµ$ introduction from \cite{Manna74}.
=DOC
val ÛALL_SIMPLE_µ_CÝ : CONV -> CONV;
=DESCRIBE
This conversional applies its conversion argument to the body of a repeated simple universal quantification.
=FAILUREC
\paragraph{Errors}
As the failure of the conversion argument.
=ENDDOC
=DOC
val Ûsimple_µ_¶_convÝ: CONV;
=DESCRIBE
Swap the order of a simple $µ$ and $¶$:
=FRULE 1 Conversion
simple_µ_¶_conv
¬µ x· ¶ y· P[x,y]®
÷
÷
ô (µ x· ¶ y· P[x,y]) ¤ 
	(¶ y'· µ x· P[x, y' x])
=TEX
where $y'$ is renamed to distinguish it from $y$ (for the types differ) and every other term variable in the argument.
=FAILURE
27031	?0 is not of the form: ¬µ x· ¶ y· P[x,y]®
=ENDDOC
=DOC
val Ûsimple_¶_µ_convÝ: CONV;
=DESCRIBE
Swap the order of a simple $¶$ and $µ$:
=FRULE 1 Conversion
simple_¶_µ_conv
¬¶ x· µ y· P[x,y]®
÷
÷
ô (¶ x· µ y· P[x,y]) ¤ 
	(µ y'· ¶ x· P[x, y' x])
=TEX
where $y'$ is renamed to distinguish it from $y$ (for the types differ) and every other term variable in the argument.
=FAILURE
27032	?0 is not of the form: ¬¶ x· µ y· P[x,y]®
=ENDDOC
=DOC
val Ûsimple_¶_µ_conv1Ý: CONV;
=DESCRIBE
Swap the order of a simple $¶$ and $µ$, where the first variable is always applied to the second:
=FRULE 1 Conversion
simple_¶_µ_conv1
¬¶ f· µ x· P[f x, x]®
÷
÷
(¶ f· µ x· P[f x, x]) ¤ 
 (µ x· ¶ f'· P[f', x])
=TEX
where $f'$ is renamed to distinguish it from $f$ (for the types differ) and every other term variable in the argument.
=FAILURE
27033	?0 is not of the form: ¬¶ f· µ x· P[f x,x]®
=ENDDOC
There is a potential design error in these two functions,
that is checked for ``just in case''.
=FAILURE
27034	DESIGN ERROR: resulting theorem for ?0 could not 
	be coerced to correct LHS
=TEX

\subsection{Concerning ¶}
=DOC
val Ûv_¶_introÝ : TERM -> THM -> THM ;
=DESCRIBE
Introduce an existential quantified variable structure into a theorem.
=FRULE 1 Rule
v_¶_intro
¬vs[x,y,...]®
÷
‡ ô t[x,y,...]
÷
‡ ô ¶ vs[x,y,...]· t[x,y,...]
=TEX
where ¬vs[x,y,...]® is a varstruct built from variables $¬x®$, $¬y®$, etc, which may contain duplicates.
=USES
If the functionality is sufficient, this is superior
in efficiency to both $¶\_intro$ and $simple\_¶\_intro$ (q.v.).
=FAILURE
4016	?0 is not an allowed variable structure
=ENDDOC
=DOC
val Û¶_introÝ : TERM -> THM -> THM ;
=DESCRIBE
Introduce an existential quantifier by reference to a witness.
=FRULE 1 Rule
¶_intro
¬¶ vs[x,y,...]· t[x,y,...]®
÷
‡ ô t[t1,t2,...]
÷
‡ ô ¶ vs[x',y',...]· t[x,y,...]
=TEX
where ¬vs[x,y,...]® is varstruct built from variables $¬x®$, $¬y®$, etc,
and the $¬x'®$ are renamed if duplicated inside the varstruct, all but the rightmost being so renamed.
=FAILURE
4020	?0 is not of form: ¬¶ vs· t®
7047	?0 cannot be matched to conclusion of theorem ?1
=ENDDOC
=DOC
val Û¶_elimÝ : TERM -> THM -> THM -> THM;
=DESCRIBE
Eliminate an existential quantifier by reference to an arbitrary varstruct satisfying the predicate.
=FRULE 1 Rule
¶_elim
¬vs[y1,y2,...]®
÷
‡1 ô ¶ vs[x1,x2,...]· t1[x1,x2,...]; 
‡2, t1[y1,y2,...] ô t2
÷
‡1 À ‡2 ô t2
=TEX
$t1[y1,y2,...]$ need not actually be present in the assumptions of the second theorem.
The $y_i$ must be free variables, none of whom are present elsewhere in the second theorem, or in the conclusion
of the first.
The $y_i$ may contain duplicates as long as the end pattern
matches the $x_i$ in required duplicates.
The term argument may be a less complex variable structure
than the bound variable structure of the theorem,
as $Fst$ and $Snd$ are used to make them match.
For example, the following rule holds true:
=FRULE 1 Rule
¶_elim
¬x®
÷
‡1 ô ¶ (p,q)· t1[p,q]; 
‡2, t1[Fst x, Snd x] ô t2
÷
‡1 À ‡2 ô t2
=TEX

=FAILURE
27042	?0 does not match the bound varstruct of ?1
27046	?0 is not of the form `‡ ô ¶ vs· t`
27051	?0 has members appearing free in conclusion of ?1
27052	?0 has members appearing free in ?1 other than in assumption ?2
=ENDDOC
=DOC
val Û¶_uncurry_convÝ : CONV;
=DESCRIBE
Convert a paired existentially quantified term into
simple universal quantifications of the same term.
=FRULE 1 Conversion
¶_uncurry_conv
¬¶ vs[x,y,...]· f[x, y,...]®
÷
÷
ô ¶ vs[x,y,...]· f[x,y,...] = 
	¶ x y ...· f[x,y,...]
=TEX
where $vs[x,y,...]$ is an allowed variable structure with
variables $x,y,...$.
It may not be a simple variable.
=SEEALSO
$Ì\_varstruct\_conv$, $all\_¶\_uncurry\_conv$, $µ\_uncurry\_conv$.
=FAILURE
27047	?0 is not of the form: ¬¶ (x,y)· f®
=ENDDOC
=DOC
val Ûall_¶_uncurry_convÝ : CONV;
=DESCRIBE
Apply $¶\_uncurry\_conv$ (q.v) to the outer existential
quantifications of a term,
flattening those binders.
=FRULE 1 Conversion
all_¶_uncurry_conv
¬¶ vs1[x1,y1,...] vs2[x2,y2,...] ...· 
 f[x1,y1,...,x2,y2,...]®
÷
÷
‡ ô (¶ vs1[x,y,...] vs2[x,y,...]· 
	f[x1,y1,...,x2,y2,...])
 = (¶ x1 y1 ... x2 y2 ...· 
	f[x1,y1,...,x2,y2,...])
=TEX
where the $vs[x,y,...]$ are variable structures
with variables $x,y,...$, at least one of which must not be a simple variable.
=SEEALSO
$all\_µ\_uncurry\_conv$
=FAILURE
27048	?0 is not of the form: ¬¶ ... (x,y) ...· f®
=ENDDOC
=DOC
val Û³_¶_convÝ : CONV;
=DESCRIBE
Move $³$ into an $¶$ construct.
=FRULE 1 Rule
³_¶_conv
¬³ (¶ x· t[x])®
÷
÷
ô (³ (¶ x· t[x])) ¤ µ x· ³ t[x]
=TEX
=SEEALSO
$³\_simple\_¶\_conv$ which only works with simple $¶$-abstractions, $³\_µ\_conv$
=FAILURE
27020	?0 is not of the form: ¬³ (¶ x· t[x])®
	where ¬x® is a varstruct
=ENDDOC
=DOC
val Û¶_asm_ruleÝ : TERM -> TERM -> THM -> THM;
=DESCRIBE
Existentially quantify an assumption (Left $¶$ introduction).
=FRULE 1 Rule
¶_asm_rule
¬x®
¬p[x]®
÷
‡, p'[x] ô q
÷
‡, ¶ x· p'[x] ô q
=TEX
where $p$ and $p'$ are $Á$-convertible.
where the variables of the varstruct $x$ are not free in $‡$ or $q$.
The assumption need not be present for the rule to apply.
=FAILURE
3015	?1 is not of type ”BOOL®
4016	?0 is not an allowed variable structure
6005	?0 occurs free in assumption list
27052	?0 has members appearing free in ?1 other than in assumption ?2
=FAILUREC
Message 3015 is just passed on from low level functions,
which is why it has "?1" not "?0".
=ENDDOC
This is from \cite{Manna74}.

=DOC
val Û¶_reorder_convÝ : TERM -> CONV;
=DESCRIBE
Reorder existential quantifications.
=FRULE 1 Rule
¶_reorder_conv
¬¶ x1 .. xn· t1®
¬¶ y1 .. ym· t2®
÷
÷
(¶ y1 .. ym· t2) ¤ (¶ x1 .. xn· t1)
=TEX
where the $x_i$ and $y_i$ are varstructs,
and the reordering, restructuring (by pairing) and renaming requested is provable by this function.
The presence of redundant quantifiers, including duplicates, is also handled.
=EXAMPLE
:> ¶_reorder_conv ¬¶ (x,q) z· x ± z® ¬¶ (z,z,y) x· x ± z®;
val it = ô (¶ (z, z, y) x· x ± z) ¤ (¶ (x, q) z· x ± z) : THM
Note that before more sophisticated attempts, the conversion
will try $Á\_conv$ on the two term arguments.
=SEEALSO
$µ\_reorder\_conv$
=FAILURE
27050	Cannot prove equality of ?0 and ?1
=ENDDOC

We do not give a rule for $¶¶$ introduction from \cite{Manna74}.
=DOC
val ÛALL_SIMPLE_¶_CÝ : CONV -> CONV;
=DESCRIBE
This conversional applies its conversion argument to
the body of a repeated simple existential quantification.
=FAILUREC
\paragraph{Errors}
As the failure of the conversion argument.
=ENDDOC

\subsection{Concerning ¶$_1$}
=DOC
val Û¶‰1_introÝ : THM -> THM -> THM;
=DESCRIBE
Introduce $¶_1$ by reference to a witness, and a uniqueness theorem.
=FRULE 1 Rule
¶‰1_intro
÷
‡1 ô P'[t']
‡2 ô µ x· P[x] ´ x = t
÷
‡1 À ‡2 ô ¶‰1 x· P[x]
=TEX
Where $P'$ is $Á$-convertible to $P$, and
$t'$ is $Á$-convertible to $t$.
Notice that for the resulting theorem we take the varstruct, $x$,
and the form of the predicate, $P$, from the second theorem.
=FAILURE
27021	?0 and ?1 are not of the form: `‡1 ô Pa[ta]` and 
	`‡2 ô µ vs[x,y,..]· P[x,y...] ´ vs[x,y,..] = t`
	where ¬Pa® and ¬P®, ¬ta® and ¬t® are Á-convertible
	and ¬x® is a varstruct
27054	?0 not of the form: `‡ ô µ vs[x,y,..]· P[x,y...] ´ vs[x,y,..] = t`
=ENDDOC
=DOC
val Û¶‰1_elimÝ : THM -> THM;
=DESCRIBE
Express a $¶_1$ in terms of $¶$ and a uniqueness property.
=FRULE 1 Rule
¶‰1_elim
÷
‡ ô ¶‰1 vs[a,b,...]· P[a,b,...]
÷
‡ ô ¶ vs[a,b,...]· P[a,b,...] ± 
	µ vs[a',b',...]· P[x1,x2,...]
 ´ 
	vs[a',b',...] = vs[a,b,...]
=TEX
where the $a'$, etc, are variants of the $a$.
=FAILURE
27022	?0 is not of the form: `‡ ô ¶‰1 x· P[x]`
	where ¬x® is a varstruct
=ENDDOC
This could be rewritten to produce two theorems,
$`¶\ x·\ P[x]`$ and $`µ\ x\ y·\ P[x]\ ±\ P[y]\ ´\ x\ =\ y`$
=DOC
val Û¶‰1_convÝ : CONV;
=DESCRIBE
This is a conversion which turns a unique existential quantifier into
an equivalent existential quantifier
=FRULE 1 Conversion
¶‰1_conv
¬¶‰1vs[x1,...]·t[x1,...]®
÷
÷
ô (¶‰1vs[x1,...]·t[x1,...]) ¤ 
	(¶vs[x1,...]·t[x1,...] ± 
	µvs[x1',...]·t[x1',...] ´ 
	vs[x1',...] = vs[x1,...])
=TEX
=USES
Tactic and conversion programming.
=SEEALSO
$strip\_tac$, $simple\_¶_1\_conv$
=FAILURE
27053	?0 is not of the form: ¬¶‰1vs·t®
=ENDDOC
\subsection{Concerning Å}
=DOC
val ÛÅ_elim_ruleÝ : TERM -> THM -> THM -> THM;
=DESCRIBE
Given that $Å$ of a predicate satisfies that predicate, then
in a different theorem we may eliminate an assumption that
claims an otherwise unused variable structure satisfies the predicate.
=FRULE 1 Rule
Å_elim_rule
¬vs®
÷
‡1 ô t' (Å t'');
‡2, t vs ô s
÷
‡1 À ‡2 ô s
=TEX
where $t$, $t'$ and $t''$ are $Á$-convertible, and 
$vs$ is a varstruct, with no duplicates, and with its free variables
occurring nowhere else in the second theorem, or in the conclusion
of the first.
Actually $(Å\ t'')$ can be any value, rather than a choice construct.
=FAILURE
4016	?0 is not an allowed variable structure
7019	?0 is not of the form: `‡ ô t1(Å t1)`
7054	?0 is not of same type as choice sub-term of first theorem
27043	?0 is repeated in the varstruct ?1
27045	Arguments ?0; ?1 and ?2 not of the form ¬vs®; `‡1 ô t (Å t)` and
	`‡2, (t vs) ô s`
27051	?0 has members appearing free in conclusion of ?1
27052	?0 has members appearing free in ?1 other than in assumption ?2
=ENDDOC
The above cannot handle duplicates within $vs$, because for instance a predicate on $(a,a)$ 
where $a$ is free is not the same as that predicate on $x$ where $x$ is free.
Renaming is not a sensible solution.
=DOC
val Û¶_Å_ruleÝ : THM -> THM;
=DESCRIBE
Give that $Å$ of a predicate satisfies the predicate by reference to an $¶$ construct.
It can properly handle paired existence.
=FRULE 1 Rule
¶_Å_rule
÷
‡ ô ¶ x· p[x]
÷
‡ ô p[Å x· p x]
=TEX
If $x$ is formed by paired then the $Fst$ and $Snd$ are used to extract the appropriate bits of the Å-term 
for distribution in $p[Å\ x·\ p\ x]$.
=SEEALSO
$¶\_Å\_conv$
=FAILURE
27024	?0 is not of the form: `‡ ô ¶ x· p[x]`
	where ¬x® is a varstruct
=ENDDOC
=DOC
val Û¶_Å_convÝ : CONV;
=DESCRIBE
Give that $Å$ of a predicate satisfies the predicate by reference to an $¶$ construct.
It can properly handle paired existence.
=FRULE 1 Rule
¶_Å_conv
¬¶ x· p[x]®
÷
÷
‡ ô (¶ x· p[x]) = p(Å x· p x)
=TEX
If $x$ is formed by paired then the $Fst$ and $Snd$ are used to extract the appropriate bits of the Å-term 
for distribution in $p[Å\ x·\ p\ x]$.
=SEEALSO
$¶\_Å\_rule$
=FAILURE
27024	?0 is not of the form: `‡ ô ¶ x· p[x]`
	where ¬x® is a varstruct
=ENDDOC
\subsection{Concerning Local Definitions}
=DOC
val Ûlet_convÝ : CONV;
=DESCRIBE
Eliminate an outermost $let\ldots and\ldots in\ldots$ construct.
=FRULE 1 Conversion
let_conv
¬let vs1[x1,y1,..] = 
 t1 and ... vsn[xn,yn,..] = tn 
 in t[x1,...,xn,...]®
÷
÷
ô (let vs1[x1,y1,..] = t1 
 and ... and vsn[xn,yn,..] = tn 
 in t[x1,...,xn,...] 
	= t[t1x,...,t1y,...,tnx,tny,...]
=TEX
Where the $t_ix$ is the component of $t_i$ matching $x_i$
when $t_i$ matches $vs_i[x_i,y_i,..]$.
=FAILURE
4009	?0 is not of form: ¬let ... in ...®
=ENDDOC

\subsection{Concerning $Uncurry$}
I don't believe we need a rule for eliminating $Uncurry$,
and its introduction is mostly behind the scenes.
\subsection{Concerning Sets}
See \cite{DS/FMU/IED/DTD044}.
\subsection{Conversionals}
=DOC
val ÛÌ_CÝ : CONV -> CONV;
=DESCRIBE
Apply a conversion to the body of an abstraction:
=FRULE 1 Rule
Ì_C
(c : CONV)
¬Ì x· p®
÷
÷
ô (Ì x· p[x]) = (Ì x· pa[x])
=TEX
where $c\ p[x]$ gives $`ô p[x] = pa[x]`$.
=FAILURE
4002	?0 is not of form: ¬Ì vs· t®
7104	Result of conversion, ?0, ill-formed
=FAILUREC
Also as the failure of the conversion.
=ENDDOC
=DOC
val ÛBINDER_CÝ : CONV -> CONV;
=DESCRIBE
Apply a conversion to the body of a binder term:
=FRULE 1 Rule
BINDER_C
(c : CONV)
¬B x· p®
÷
÷
ô (B x· p[x]) = (B x· pa[x])
=TEX
where $c\ p[x]$ gives $`ô p[x] = pa[x]`$,
and $B$ is a binder.
=FAILURE
27035	?0 is not of the form: ¬B x· p[x]® where ¬B® is a binder
	and ¬x® a varstruct
7104	Result of conversion, ?0, ill-formed
=FAILUREC
Also as the failure of the conversion.
=ENDDOC
This will later be renamed to $SIMPLE\-\_BINDER\-\_C$, and the current $SIMPLE\-\_BINDER\-\_C$ renamed to $SIMPLE\-\_BINDER\_C$.
\section{END OF THE SIGNATURE}
=SML
end; (* signature of DerivedRules2 *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

=IGN
open Sort;
fun sf {id = id1,text = text1} {id = id2,text = text2} = (
	if text1 <> text2
	then string_order text1 text2
	else (id1 - id2)
);
sort sf (get_error_messages());

sort (fn x => fn y => x - y) (map (fn {id=id,...} => id)( get_error_messages()));


