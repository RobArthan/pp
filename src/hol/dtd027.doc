=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design of Derived Rules of Inference II}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Derived Rules of Inference II}
\TPPref{DS/FMU/IED/DTD027}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for further 
derived rules of inference in ICL HOL,
in particular those concerned with paired abstractions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Fixed an error message.
\item [Issue 1.3]
Gained inference rules about sets.
\item [Issue 1.4]
Gained tautology material.
\item [Issue 1.5]
Changes with a view to implementation,
and to reflect changes in \cite{DS/FMU/IED/DTD007} issue 2.1.
\end{description}
\subsection{Changes forecast}
Rename $CBINDER\_C$ to $BINDER\_C$.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
derived rules of inference concerning paired abstractions.
This is called for in \cite{DS/FMU/IED/HLD012}.
The design is
implemented in \cite{DS/FMU/IED/IMP027}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
paired abstraction
derived rules of inference in Release 001 of ICL HOL.

The document provides groups of rules of inference, related by their core operator.

All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP027}.

We use the notation ``varstruct'' for ``an allowed variable structure, under ICL HOL syntax''.
\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.

This document places requirements upon the constants handled by the
inference rules discussed.
In summary, the requirements are that the definitions of the constants must be such that the designs of the rules are satisfiable.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the ``top level''.
Thus we give the commands here for those functions declared in the following signatures.
=SML
=TEX
\section{THE DERIVED RULES OF REASONING}
=DOC
signature âDerivedRulesIIá = sig
=DESCRIBE
This provides the further derived rules of inference for ICL HOL.
They are primarily concerned with handling paired abstractions.
=ENDDOC
\subsection{Concerning Š}
=DOC
val âŠ_match_mp_ruleá : THM -> THM -> THM ;
=DESCRIBE
A matching Modus Ponens rule for an implicative theorem.
=RULE
Š_match_mp_rule
É
ö1 … ƒ x1 ... Ž t1 Š t2; ö2 … t1'
É
ö1' ¡ ö2 … t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's antecedent to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.

This may be partially evaluated with only first argument.
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC
=DOC
val âŠ_match_mp_rule1á : THM -> THM -> THM ;
=DESCRIBE
A matching Modus Ponens rule for an implicative theorem.
=RULE
Š_match_mp_rule
É
ö1 … ƒ x1 ... Ž t1 Š t2; ö2 … t1'
É
ö1 ¡ ö2 … t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's antecedent to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.

This may be partially evaluated with only first argument.
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC
\subsection{Concerning ‚}
=DOC
val â‚_match_mp_ruleá : THM -> THM -> THM;
=DESCRIBE
A matching Modus Ponens for $‚$.
=RULE
‚_match_mp_rule
É
ö1 … ƒ x1 ... Ž t1 ‚ t2; ö2 … t1'
É
ö1' ¡ ö2 … t2'
=TEX
where we type instantiate, generalise and specialise
both conclusion and assumptions
to get the first theorem's LHS to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.

This may be partially evaluated with only first argument.
=SEEALSO
$Š\_elim$ (Modus Ponens on $Š$),
$simple\_‚\_match\_mp\_rule$
$‚\_match\_mp\_rule1$
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC
=DOC
val â‚_match_mp_rule1á : THM -> THM -> THM;
=DESCRIBE
A matching Modus Ponens for $‚$ tyhat doesn't affect assumption lists.
=RULE
‚_match_mp_rule1
É
ö1 … ƒ x1 ... Ž t1 ‚ t2; ö2 … t1'
É
ö1 ¡ ö2 … t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's LHS to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.

This may be partially evaluated with only first argument.
=SEEALSO
$Š\_elim$ (Modus Ponens on $Š$),
$simple\_‚\_match\_mp\_rule1$
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC

\subsection{Concerning =}
=DOC
val âeq_match_convá : THM -> CONV ;
=DESCRIBE
This matches the LHS of an equational theorem to a term,
instantiating the RHS accordingly.
The equational theorem may be partially or fully universally quantified
(simple or by varstruct),
without affecting the result of the conversion.
=CONVERSION
eq_match_conv
(ö … ƒ ... Ž u = v)
»t¼
É
É
ö … t = v'
=TEX
where $v'$ is the result of applying to $v$ the instantiation rules required to match $u$ to $t$
(including both term and type instantiation).
If there are free variables on the RHS of the supplied equational theorem (when stripped of all universal quantification)
they will be renamed as necessary to avoid identification with
any variables in $t$.

This conversion may be partially evaluated with only its theorem argument.
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC

=DOC
val âeq_match_conv1á : THM -> CONV ;
=DESCRIBE
This matches the LHS of an universally quantified (simple or by varstruct) equational theorem to a term,
instantiating the RHS accordingly.
The conversion will only instantiate its universal quantifications,
and type variables, not its free term variables.
=CONVERSION
eq_match_conv1
(ö … ƒ x1 ... xn Ž u[x1,...,xn] = 
   v[x1,...,xn])
»t¼
É
É
ö … t = v[t1,...,tn]
=TEX
where »u[t1,...,tn]¼ is $\alpha$-convertible to »t¼.
If there are free variables on the RHS of the supplied equational theorem (when stripped of all universal quantification)
they will be renamed as necessary to avoid identification with
any variables in $t$.

This conversion may be partially evaluated with only its theorem argument.
=USES
In producing a limited rewriting facility, that only instantiates
explicitly identified variables.
=FAILURE
27003	?0 is not of the form `ö … ƒ x1 ... xn Ž u = v`
	where »xi¼ are varstructs
7076	Could not match term ?0 to LHS of theorem ?1
=ENDDOC
\subsection{Concerning }
=DOC
val â%beta%_ruleá : THM -> THM;
=DESCRIBE
An elimination rule for $$, which can handle paired abstractions.
=RULE
%beta%_rule
É
ö … ( x Ž t[x]) y
É
ö … t[y]
=TEX
=SEEALSO
$beta\_conv$
=FAILURE
27007	?0 is not of the form: `ö … ( x Ž t[x]) y`
	where »x¼ is a varstruct
=ENDDOC
=DOC
val â%beta%_convá : CONV;
=DESCRIBE
Apply a $\beta$-reduction to an abstraction.
=RULE
%beta%_conv
»( x Ž t1[x])t2¼
É
É
… (( x Ž t[x])y) = t'[y]
=TEX
where $x$ may be any varstruct allowed by the ICL HOL syntax, 
$y$ is an instance of this structure,
and $t'$ is $\alpha$-convertible to $t$, changed to avoid variable capture.

When the bound variable structure has a pair,
where the value applied to does not, then $Fst$ and $Snd$ are
introduced as necessary, e.g.:
óExample
%beta%_conv »( (x,y) Ž f x y) p¼ =
	… ( (x,y) Ž f x y) p = f (Fst p) (Snd p)
æ 
=SEEALSO
$simple\_\beta\_conv$
=FAILURE
27008	?0 is not of the form: »( x Ž t1[x])t2¼
	where »x¼ is a varstruct
=ENDDOC
=DOC
val âall_%beta%_convá : CONV;
=DESCRIBE
A conversion to eliminate all instances of $\beta$ redexes,
including paired abstraction redexes, in a term, regardless of nesting, or even that the $\beta$ redex was created as the result of
an earlier reduction in the conversion's evaluation.
=RULE
all_%beta%_conv
»t¼
É
É
… t = t'
=TEX
$t'$ is $t$ with all $\beta$ redexes reduced.
=USES
This uses an optimised term traversal algorithm, superior in speed
to the general term traversal algorithms used with conversions,
and should be used in preference to them and $\beta\_conv$.
=FAILURE
27049	?0 contains no %beta%-redexes
=ENDDOC
=DOC
val âall_%beta%_ruleá : THM -> THM;
=DESCRIBE
Eliminate all instances of $\beta$ redexes,
including paired abstraction redexes, in a theorem, regardless of nesting, or even that the $\beta$ redex was created as the result of
an earlier reduction in the rule's evaluation.
=RULE
all_%beta%_rule
É
ö … t
É
ö … t'
=TEX
$t'$ is $t$ with all $\beta$-redexes reduced.
=ENDDOC
=DOC
val â_eq_ruleá : TERM -> THM -> THM;
=DESCRIBE
Given an equational theorem, return the equation formed by abstracting the term argument (which must be a variable structure) from both sides.
=RULE
_eq_rule
»x¼
É
ö … t1[x] = t2[x]
É
ö … ( x Ž t1[x]) = ( x Ž t2[x])
=TEX
=SEEALSO
$simple\_\_eq\_rule$
=FAILURE
27010	?0 is not a varstruct
6005	?0 occurs free in assumption list
6020	?0 is not of the form: `ö … t1 = t2`
=ENDDOC
=DOC
val â%eta%_convá : CONV;
=DESCRIBE
The rule for $\eta$ conversion.
=RULE
%eta%_conv
» vs Ž t vs¼
É
É
… ( vs Ž t vs) = t
=TEX
where $t$ contains no free instances of the variables of varstruct $vs$.
=FAILURE
27018	?0 is not of the form: » vs Ž t vs'¼
	where »vs¼ is a varstruct
27023	?0 is not of the form: » vs Ž t vs¼ where »t¼ should not contain »vs¼
=ENDDOC

\subsection{Concerning ƒ}
=DOC
val âƒ_uncurry_convá : CONV;
=DESCRIBE
Convert a paired universally quantified term into
simple universal quantifications of the same term.
=CONVERSION
ƒ_uncurry_conv
»ƒ vs[x,y,...] Ž f[x,y,...]¼
É
É
ö … ƒ vs[x,y,...] Ž f[x,y,...] = ƒ x y ... Ž f[x,y,...]
=TEX
where $vs[x,y,...]$ is a variable structure with
variables $x,y,...$.
It may not be a simple variable.
=FAILURE
27038	?0 is not of the form: »ƒ (x,y) Ž f¼
=ENDDOC
=DOC
val âall_ƒ_uncurry_convá : CONV;
=DESCRIBE
Apply $ƒ\_uncurry\_conv$ (q.v) to the outer universal
quantifications of a term,
flattening those binders.
=CONVERSION
ƒ_uncurry_conv
»ƒ vs1[x1,y1,...] vs2[x2,y2,...] ... Ž f[x1,y1,...,x2,y2,...]¼
É
É
ö … ƒ vs1[x,y,...] vs2[x,y,...] Ž f[x1,y1,...,x2,y2,...] 
	= ƒ x1 y1 ... x2 y2 ... Ž f[x1,y1,...,x2,y2,...]
=TEX
where the $vs[x,y,...]$ are variable structures
with variables $x,y,...$.
=FAILURE
27041	?0 is not of the form: »ƒ ... (x,y) ... Ž f¼
=ENDDOC
=DOC
val âƒ_introá : TERM -> THM -> THM;
=DESCRIBE
Introduce a universally quantified theorem.
=RULE
ƒ_intro
»x¼
É
ö … t
É
ö … ƒ x' Ž t
=TEX
Where $»x'¼$ is a variable structure based on $»x¼$, but with
duplicate variables renamed, the original name being rightmost in the resulting variable structure.
=SEEALSO
$simple\_ƒ\_intro$
=FAILURE
27010	?0 is not a varstruct
6005	?0 occurs free in assumption list
=ENDDOC
=DOC
val âƒ_elimá : TERM -> THM -> THM;
=DESCRIBE
Instantiate a universally quantified variable to a given value.
=RULE
ƒ_elim
»t1¼
É
ö … ƒ x Ž t2[x]
É
ö … t2'[t1]
=TEX
where $t2'$ is renamed from $t2$ to prevent bound variable capture,
and $x$ is a varstruct, instantiable to the structure of $t1$.
The term will be expanded using $Fst$ and $Snd$ as necessary to match
the structure of $»x¼$.
=FAILURE
27011	?0 is not of the form: `ö … ƒ x Ž t` where »x¼ is a varstruct
27012	?0 is not of the form: `ö … ƒ x Ž t` where the type of »x¼ 
	is the type of ?1
=ENDDOC
=DOC
val âlist_ƒ_introá : TERM list -> THM -> THM;
=DESCRIBE
Generalised $ƒ$ introduction.
=RULE
list_ƒ_intro
[»x1¼, ..., »xn¼]
É
ö … t[x1, ..., xn]
É
ö … ƒ x1 ... xn Ž t[x1, ..., xn]
=TEX
=SEEALSO
$ƒ\_intro$
=FAILUREC
\paragraph{Errors}
Same messages as $ƒ\_intro$.
=ENDDOC
=DOC
val âlist_ƒ_elimá : TERM list -> THM -> THM;
=DESCRIBE
Generalised $ƒ$ elimination.
=RULE
list_ƒ_elim
[»t1¼, ..., »tn¼]
É
ö … ƒ x1 ... xn Ž t[x1, ..., xn]
É
t[t1, ..., tn]
=TEX
=SEEALSO
$ƒ\_elim$
=FAILUREC
\paragraph{Errors}
Same messages as $ƒ\_elim$.
=ENDDOC
=DOC
val âall_ƒ_elimá : THM -> THM;
=DESCRIBE
Specialises all the outer universal quantifications in a theorem:
=RULE
all_ƒ_elim
É
ö … ƒ x1 ... xn Ž t[x1, ..., xn]
É
ö … t[x1', ..., xn']
=TEX
where $x1', \ldots, xn'$ are renamed from $x1, \ldots, xn$ as necessary to avoid name clashes with
free variables in the assumption list.
=ENDDOC
=DOC
val âŒ_ƒ_convá : CONV;
=DESCRIBE
Move $Œ$ into a $ƒ$ construct.
=RULE
Œ_ƒ_conv
»Œ (ƒ x Ž t[x])¼
É
É
… (Œ (ƒ x Ž t[x])) ‚ „ x Ž Œ t[x]
=TEX
This will work with any paired universal quantifier.
=FAILURE
27019	?0 not of the form: »Œ (ƒ x Ž t[x])¼
	where »x¼ is a varstruct
=ENDDOC
=DOC
val âƒ_‚_ruleá : TERM -> THM -> THM;
=DESCRIBE
Universally quantify a variable on both sides of an equivalence.
=RULE
ƒ_‚_rule
»x¼
É
ö … p[x] ‚ q[x]
É
ö … (ƒ x Ž p[x]) ‚ (ƒ x Ž q[x])
=TEX
where $x$ is a varstruct.
=FAILURE
7062	?0 is not of the form: `ö … t1 ‚ t2`
27010	?0 is not a varstruct
6005	?0 occurs free in assumption list
=ENDDOC
=DOC
val âƒ_arb_elimá : THM -> THM;
=DESCRIBE
Specialise a universally quantified theorem with a machine generated variable.
=RULE
ƒ_arb_elim
É
ö … ƒ x Ž p[x]
É
ö … p[x']
=TEX
where $x'$ is not a variable (free or bound) in $p$.
=ENDDOC
The precise rules for the name formation of $x$ will not be given here.
=DOC
val âƒ_asm_ruleá : TERM -> TERM -> THM -> THM;
=DESCRIBE
Generalise an assumption (Left $ƒ$ introduction).
=RULE
ƒ_asm_rule
»x¼
»p[x]¼
É
ö, p'[x] … q[x]
É
ö, ƒ x Ž p'[x] … q[x]
=TEX
where $p$ and $p'$ are $\alpha$-convertible.
$x$ {\bf may} be free in $ö$.
=FAILURE
27010	?0 is not a varstruct
27032	?0 is not in assumption list
=ENDDOC
This is from \cite{Manna74}.
=DOC
val âƒ_reorder_convá : TERM -> CONV;
=DESCRIBE
Reorder universal quantifications.
=RULE
ƒ_reorder_conv
»ƒ x1 .. xn Ž t1¼
»ƒ y1 .. ym Ž t2¼
É
É
(ƒ y1 .. ym Ž t2) ‚ (ƒ x1 .. xn Ž t1)
=TEX
where the $x_i$ and $y_i$ are varstructs,
and the reordering and renaming requested is valid.
=FAILURE
27015	Cannot prove theorem with conclusion ?0
27030	?0 is not of type »:BOOL¼
=ENDDOC


We do not give a rule for $ƒƒ$ introduction from \cite{Manna74}.
\subsection{Concerning „}
=DOC
val âv_„_introá : TERM -> THM -> THM ;
=DESCRIBE
Introduce an existential quantified variable structure into a theorem.
=RULE
v_„_intro
»vs[x,y,...]¼
É
ö … t[x,y,...]
É
ö … „ vs[x,y,...] Ž t[x,y,...]
=TEX
where »vs[x,y,...]¼ is varstruct built from variables $»x¼$, $»y¼$, etc, which may contain duplicates.
=USES
If the functionality is sufficient, this is superior
in efficiency to both $„\_intro$ and $simple\_„\_intro$.
=FAILURE
4016	?0 is not an allowed variable structure
=ENDDOC
=DOC
val â„_introá : TERM -> THM -> THM ;
=DESCRIBE
Introduce an existential quantifier by reference to a witness.
=RULE
„_intro
»„ vs[x,y,...] Ž t[x,y,...]¼
É
ö … t[t1,t2,...]
É
ö … „ vs[x',y',...] Ž t[x,y,...]
=TEX
where »vs[x,y,...]¼ is varstruct built from variables $»x¼$, $»y¼$, etc,
and the $»x'¼$ are renamed if duplicated inside the varstruct, all but the rightmost being so renamed.
=FAILURE
4020	?0 is not of form: »„ vs Ž t¼
7047	?0 cannot be matched to conclusion of theorem ?1
=ENDDOC
=DOC
val â„_elimá : TERM -> THM -> THM -> THM ;
=DESCRIBE
Eliminate an existential quantifier by reference to an arbitrary varstruct satisfying the predicate.
=RULE
„_elim
»vs[y1,y2,...]¼
É
ö1 … „ vs[x1,x2,...] Ž t1[x1,x2,...]; 
ö2, t1[y1,y2,...] … t2
É
ö1 ¡ ö2 … t2
=TEX
$t1[y1,y2,...]$ need not actually be present in the assumptions of the second theorem.
The $y_i$ must be free variables, none of whom are present elsewhere in theorems.
The $y_i$ may contain duplicates as long as the end pattern
matches the $x_i$ in required duplicates.
The term argument may be a less complex variable structure
than the bound variable structure of the theorem,
as $Fst$ and $Snd$ are used to make them match.
For example, the following rule holds true:
=RULE
„_elim
»x¼
É
ö1 … „ (p,q) Ž t1[p,q]; 
ö2, t1[Fst x, Snd x] … t2
É
ö1 ¡ ö2 … t2
=TEX

=FAILURE
27046	?0 is not of the form `ö … „ vs Ž t`
27010	?0 is not a varstruct
27042	?0 does not match the bound varstruct of ?1
=ENDDOC
=DOC
val â„_uncurry_convá : CONV;
=DESCRIBE
Convert a paired existentially quantified term into
simple universal quantifications of the same term.
=CONVERSION
„_uncurry_conv
»„ vs[x,y,...] Ž f[x, y,...]¼
É
É
… „ vs[x,y,...] Ž f[x,y,...] = „ x y ... Ž f[x,y,...]
=TEX
where $vs[x,y,...]$ is a variable structure with
variables $x,y,...$.
It may not be a simple variable.
=FAILURE
27047	?0 is not of the form: »„ (x,y) Ž f¼
=ENDDOC
=DOC
val âall_„_uncurry_convá : CONV;
=DESCRIBE
Apply $„\_uncurry\_conv$ (q.v) to the outer existential
quantifications of a term,
flattening those binders.
=CONVERSION
all_„_uncurry_conv
»„ vs1[x1,y1,...] vs2[x2,y2,...] ... Ž f[x1,y1,...,x2,y2,...]¼
É
É
ö … „ vs1[x,y,...] vs2[x,y,...] Ž f[x1,y1,...,x2,y2,...] 
	= „ x1 y1 ... x2 y2 ... Ž f[x1,y1,...,x2,y2,...]
=TEX
where the $vs[x,y,...]$ are variable structures
with variables $x,y,...$.
=FAILURE
27048	?0 is not of the form: »„ ... (x,y) ... Ž f¼
=ENDDOC
=DOC
val âŒ_„_convá : CONV;
=DESCRIBE
Move $Œ$ into an $„$ construct.
=RULE
Œ_„_conv
»Œ („ x Ž t[x])¼
É
É
… (Œ („ x Ž t[x])) ‚ ƒ x Ž Œ t[x]
=TEX
This will work with any paired existential quantifier.
=FAILURE
27020	?0 is not of the form: »Œ („ x Ž t[x])¼
	where »x¼ is a varstruct
=ENDDOC
=DOC
val â„_asm_ruleá : TERM -> TERM -> THM -> THM;
=DESCRIBE
Existentially quantify an assumption (Left $„$ introduction).
=RULE
„_asm_rule
»x¼
»p[x]¼
É
ö, p'[x] … q
É
ö, „ x Ž p'[x] … q
=TEX
where $p$ and $p'$ are $\alpha$-convertible.
where the variables of the varstruct $x$ are not free in $ö$ or $q$.
=FAILURE
27010	?0 is not a varstruct
27032	?0 is not in assumption list
27033	?0 is free in conclusion of theorem
27034	?0 is free in of assumptions of theorem
=ENDDOC
This is from \cite{Manna74}.

=DOC
val â„_reorder_convá : TERM -> CONV;
=DESCRIBE
Reorder existential quantifications.
=RULE
„_reorder_conv
»„ x1 .. xn Ž t1¼
»„ y1 .. ym Ž t2¼
É
É
(„ y1 .. ym Ž t2) ‚ („ x1 .. xn Ž t1)
=TEX
where the $x_i$ and $y_i$ are varstructs,
and the reordering and renaming requested is valid.
=FAILURE
27015	Cannot prove theorem with conclusion ?0
27030	?0 is not of type »:BOOL¼
=ENDDOC

We do not give a rule for $„„$ introduction from \cite{Manna74}.
\subsection{Concerning „$_1$}
=DOC
val â„%down%1_introá : TERM -> THM -> THM -> THM;
=DESCRIBE
Introduce $„_1$ by reference to a witness, and a uniqueness theorem.
=RULE
„%down%1_intro
É
ö1 … P'[t']
ö2 … ƒ x Ž P[x] Š x = t
É
ö1 ¡ ö2 … „%down%1 x Ž P[x]
=TEX
Where $P'$ is $\alpha$-convertible to $P$, and
$t'$ is $\alpha$-convertible to $t$.
Notice that for the resulting theorem we take the varstruct, $x$, and the form of the predicate, $P$, from the second theorem.
=FAILURE
27021	?0 and ?1 are not of the form: `ö1 … Pa[ta]` and `ö2 … ƒ x Ž P[x] Š x = t`
	where »Pa¼ and »P¼, »ta¼ and »t¼ are %alpha%-convertible
	and »x¼ is a varstruct
=ENDDOC
=DOC
val â„%down%1_elimá : THM -> THM;
=DESCRIBE
Express a $„_1$ in terms of $„$ and a uniqueness property.
=RULE
„%down%1_elim
É
ö … „%down%1 x Ž P[x]
É
ö … „ x Ž P[x] € ƒ y Ž P[y] Š y = x
=TEX
=FAILURE
27022	?0 is not of the form: `ö … „%down%1 x Ž P[x]`
	where »x¼ is a varstruct
=ENDDOC
This could be rewritten to produce two theorems,
`$„\ x\ Ž\ P[x]$` and `$ƒ\ x\ y\ Ž\ P[x]\ €\ P[y]\ Š\ x\ =\ y$`
\subsection{Concerning ‡}
=DOC
val âc‡_elim_ruleá : TERM -> THM -> THM -> THM;
=DESCRIBE
Given that $‡$ of a predicate satisfies that predicate, then
in a different theorem we may eliminate an assumption that
claims an otherwise unused variable structure satisfies the predicate.
=RULE
c‡_elim_rule
»vs¼
É
ö1 … t' (‡ t'');
ö2, t vs … s
É
ö1 ¡ ö2 … s
=TEX
where $t$, $t'$ and $t''$ are $\alpha$-convertible, and 
$vs$ is a varstruct, with no duplicates, and with its free variables occurring nowhere else in the theorems
other than shown.
Actually $(‡\ t'')$ can be any value, rather than a choice construct.
=FAILURE
27010	?0 is not a varstruct
6005	?0 occurs free in assumption list
7019	?0 is not of the form: `ö … t1(‡ t1)`
7054	?0 is not of same type as choice sub-term of first theorem
27043	?0 is repeated in the varstruct ?1
27044	?0 appears free in ?1
27045	Arguments ?0, ?1, ?2 not of the form »vs¼, `ö1 … t (‡ t)` and
	`ö2, (t vs) … s`
=ENDDOC
The above cannot handle duplicates within $vs$, because for instance a predicate on $(a,a)$ where $a$ is free is not the same as that predicate on $x$ where $x$ is free.
Renaming is not a sensible solution.
=DOC
val â„_‡_ruleá : THM -> THM;
=DESCRIBE
Give that $‡$ of a predicate satisfies the predicate by reference to an $„$ construct.
It can properly handle paired existence.
=RULE
„_‡_rule
É
ö … „ x Ž p[x]
É
ö … p(‡ x Ž p x)
=TEX
=SEEALSO
$„\_‡\_conv$
=FAILURE
27024	?0 is not of the form: `ö … „ x Ž p[x]`
	where »x¼ is a varstruct
=ENDDOC
=DOC
val â„_‡_convá : CONV;
=DESCRIBE
Give that $‡$ of a predicate satisfies the predicate by reference to an $„$ construct.
It can properly handle paired existence.
=RULE
„_‡_conv
»„ x Ž p[x]¼
É
É
ö … („ x Ž p[x]) = p(‡ x Ž p x)
=TEX
=SEEALSO
$„\_‡\_rule$
=FAILURE
27024	?0 is not of the form: `ö … „ x Ž p[x]`
	where »x¼ is a varstruct
=ENDDOC
\subsection{Concerning Local Definitions}
=DOC
val âlet_intro_ruleá : (string * TERM) -> THM -> THM;
=DESCRIBE
Introduce a local definition.
=RULE
let_intro_rule
[...,("xi", »ti¼),...]
É
ö … t[t1,...tn]
É
ö … let x1' = t1 and ... xn' = tn 
	in t2[x1',...,xn']
=TEX
where $x_i'$ in the result are variables with the names $x_i$, and with the type of $t_i$, perhaps made into variants to avoid variable capture.
=ENDDOC
Perhaps we should provide a template of what $t[...]$ should look like, so that not all instances of $t_i$ are changed to $x_i$.
Perhaps we should fail, rather than rename, if variable capture occurs.
=DOC
val âlet_elim_ruleá : THM -> THM;
=DESCRIBE
Eliminate an outermost $let\ldots and\ldots in\ldots$ construct.
=RULE
let_elim_rule
É
ö … let x1 = t1 and ... xn = tn 
	in t[x1,...,xn]
É
ö … t[t1,...,tn]
=TEX
=ENDDOC
=DOC
val âlet_convá : CONV;
=DESCRIBE
Eliminate an outermost $let\ldots and\ldots in\ldots$ construct.
=CONVERSION
let_elim_rule
»let v1 = t1 and ... vn = tn 
 in t[v1,...,vn]¼
É
É
… (let v1 = t1 and ... vn = tn in 
	t[v1,...,vn]) 
	= t[t1,...,tn]
=TEX
=ENDDOC

\subsection{Concerning $Uncurry$}
I don't believe we need a rule for eliminating $Uncurry$,
and its introduction is mostly behind the scenes.
\subsection{Concerning Sets}
A much wider set of rules than the below could be given .
=DOC
val âenum_set_ruleá : TERM -> TERM list -> THM;
=DESCRIBE
Give that something within an enumerated set is a member of that set.
=RULE
enum_set_rule
»ti¼
[»t1¼,...»tn¼]
É
É
… ti  {t1,...,tn}
=TEX
where $ti$ is $\alpha$-convertible to one of $t1,\ldots,tn$.
=FAILURE
27026	?0 list may not be empty
27027	?0 and ?1 have differing types in term list
27028	?0 has different type to elements in term list
=ENDDOC
A speculative form of rule, but the functionality will be useful
when handling sets.
=DOC
val âset_ruleá : TERM -> string -> THM -> THM;
=DESCRIBE
Given that $x$ satisfies a predicate $P$, show that $x$ is a member of the
set constructed from $P$.
=RULE
set_rule
»x¼
(v : string)
É
ö … P [x]
É
ö … x  {v' | P[v']}
=TEX
where $v'$ is a variable with name $v$ (or a variant as necessary,
to avoid variable capture) and the type of $x$.
=ENDDOC
A speculative form of rule, but the functionality will be useful when handling sets.
Perhaps we should provide a template for $P$, to allow only 
some instances of $x$ to be ``captured''.
=ENDDOC
=DOC
val âtaut_ruleá : TERM -> THM;
=DESCRIBE
A tautology prover.
If its argument is a tautologically true term, 
or a universally quantified version of such a term, then the
function will return that term as a theorem.
=RULE
taut_rule
»t¼
É
É
… t
=TEX
=FAILURE
27030	?0 is not of type »:BOOL¼
27037	?0 is not tautologically true
=ENDDOC
This is not a conversion, but there are two conversions leading
from it:
=DOC
val âtaut_convá : CONV;
=DESCRIBE
A tautology prover.
If its argument is a tautologically true term, 
or a universally quantified version of such a term, then the
function will return a theorem that the term is equivalent to $T$.
=CONVERSION
taut_conv
»t¼
É
É
… t ‚ T
=TEX
=FAILURE
27030	?0 is not of type »:BOOL¼
27037	?0 is not tautologically true
=ENDDOC
=DOC
val âtaut_eq_convá : TERM -> CONV;
=DESCRIBE
A tautology prover.
If its two boolean arguments are tautologically equal terms, then the
function will return a theorem that the terms are equal.
=CONVERSION
taut_eq_conv
»t1¼
»t2¼
É
É
… t2 ‚ t1
=TEX
=FAILURE
27015	Cannot prove theorem with conclusion ?0
27030	?0 is not of type »:BOOL¼
=ENDDOC
\subsubsection{Conversionals}
=DOC
val â_Cá : CONV -> CONV;
=DESCRIBE
Apply a conversion to the body of an abstraction:
=RULE
_C
(c : CONV)
» x Ž p¼
É
É
… ( x Ž p[x]) = ( x Ž pa[x])
=TEX
where $c\ p[x]$ gives $`… p[x] = pa[x]`$.
=SEEALSO
$BINDER\_C$
=FAILURE
4002	?0 is not of form: » vs Ž t¼
7104	Result of conversion, ?0, ill-formed
=FAILUREC
Also as the failure of the conversion.
=ENDDOC
=DOC
val âCBINDER_Cá : CONV -> CONV;
=DESCRIBE
Apply a conversion to the body of a binder term:
=RULE
CBINDER_C
(c : CONV)
»B x Ž p¼
É
É
… (B x Ž p[x]) = (B x Ž pa[x])
=TEX
where $c\ p[x]$ gives $`… p[x] = pa[x]`$,
and $B$ is a binder.
=FAILURE
27035	?0 is not of the form: »B x Ž p[x]¼ where »B¼ is a binder
	and »x¼ a varstruct
7104	Result of conversion, ?0, ill-formed
=FAILUREC
Also as the failure of the conversion.
=ENDDOC

\section{SUPPORTING THEORY}
\section{END OF THE SIGNATURE}
=SML
end; (* signature of DerivedRulesII *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

=IGN
open Sort;
fun sf {id = id1,text = text1} {id = id2,text = text2} = (
	if text1 <> text2
	then stringorder text1 text2
	else (id1 - id2)
);

sort sf (get_error_messages());
