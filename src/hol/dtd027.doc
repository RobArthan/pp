% dtd027.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design of Derived Rules of Inference II}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Derived Rules of Inference II}
\TPPref{DS/FMU/IED/DTD027}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for further 
derived rules of inference in ICL HOL,
in particular those concerned with paired abstractions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Fixed an error message.
\item [Issue 1.3]
Gained inference rules about sets.
\item [Issue 1.4]
Gained tautology material.
\item [Issue 1.5]
Changes with a view to implementation,
and to reflect changes in \cite{DS/FMU/IED/DTD007} issue 2.1.
\item [Issue 1.6]
Changes made during implementation.
\item [Issue 1.7]
Changed name of signature.
\item [Issue 1.8]
Changed $¶_1\_elim$.
Added $¶_1\_conv$, $varstruct\-\_variant$,
tidied up.
\item [Issue 1.9]
Clarified $µ\_reorder\_conv$ and $¶\_reorder\_conv$

\item[Issue 1.10, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.11,(13th February 1992)]
Moving material from 058 to 027.
\item [Issue 1.12 (11th March 1992)]
Fixing typos.
\item [Issue 1.13 (11th March 1992)]
Various minor additions and extensions.\end{description}
\subsection{Changes Forecast}
Rename $CBINDER\_C$ to $BINDER\_C$, and similar.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
derived rules of inference concerning paired abstractions.
This is called for in \cite{DS/FMU/IED/HLD012}.
The design is
implemented in \cite{DS/FMU/IED/IMP027}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
paired abstraction
derived rules of inference in Release 001 of ICL HOL,
as well as some further inference rules.

The document provides groups of rules of inference, related by their core operator.

All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP027}.

\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.

This document places requirements upon the constants handled by the
inference rules discussed.
In summary, the requirements are that the definitions of the constants must be such that the designs of the rules are satisfiable.
\subsubsection{Deficiencies}
The coverage of some of the material provided is uneven.
This is the result of those functions being a toolbox to achieve
a particular goal.
.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Terminology}
We use ``varstruct'' or ``(allowed) variable structure (in ICL HOL syntax)'' to indicate terms that 
satisfy the concrete syntax rule for $V$  (see \cite{DS/FMU/IED/DEF001}),
i.e. the kind of terms that may be
bound in an abstraction.
They are formed from variables by pairing: a simple variable is one example of a ``varstruct''.
\section{THE DERIVED RULES OF REASONING}
=DOC
signature ÛDerivedRules2Ý = sig
=DESCRIBE
This provides the further derived rules of inference for ICL HOL.
They are primarily concerned with handling paired abstractions.
=ENDDOC
\subsection{Tools For Variable Structures}
=DOC
val Ûvarstruct_variantÝ : TERM list -> TERM -> TERM;
=DESCRIBE
$varstruct\_variant$ $avoid$ $vs$ will recreate the variable structure $vs$ using only names that are not found in the
$avoid$ list of variables, and also renaming to avoid
duplicate variable names in the structure.
Variant names are found using $string\_variant$ (q.v.).
If there are duplicates to be renamed, then the original
name will be the rightmost in the variable structure.
=FAILURE
3007	?0 is not a term variable
4016	?0 is not an allowed variable structure
=FAILUREC
Message 3007 applies to the avoid list, 27060 to the variable
structure.
=ENDDOC
\subsection{Concerning ± and ²}
=DOC
val ÛALL_±_CÝ : CONV -> CONV;
val ÛALL_²_CÝ : CONV -> CONV;
=DESCRIBE
These respectively apply their conversion argument to:
\begin{itemize}
\item
All the conjuncts of a structure of conjuncts (including a term that is not a conjunct at all)
failing only if the conversion fails for all the conjuncts.
\item
All the disjuncts of a structure of disjuncts (including a term that is not a disjunct at all)
failing only if the conversion fails for all the disjuncts.
\end{itemize}
The result is simplified at any conjunct 
or disjunct where at least one branch had a successful
application of the conversion and matches the appropriate theorems of:
=GFT
ô µ t· (T ± t ¤ t) ± (t ± T ¤ t) ± ³ (F ± t) ± ³ (t ± F) ± (t ± t ¤ t)

ô µ t· (T ² t) ± (t ² T) ± (F ² t ¤ t) ± (t ² F ¤ t) ± (t ² t ¤ t)
=TEX
=FAILUREC
\paragraph{Errors}
As the failure of the conversion argument.
=ENDDOC

\subsection{Concerning ´}
=DOC
val Û´_match_mp_ruleÝ : THM -> THM -> THM ;
=DESCRIBE
A matching Modus Ponens rule for an implicative theorem.
=FRULE 1 Rule
´_match_mp_rule
÷
‡1 ô µ x1 ...· t1 ´ t2; ‡2 ô t1'
÷
‡1' À ‡2 ô t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's antecedent to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.

This may be partially evaluated with only first argument.
=SEEALSO
$´\_match\_mp\_rule1$, $´\_elim$
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC
=DOC
val Û´_match_mp_rule1Ý : THM -> THM -> THM ;
=DESCRIBE
A matching Modus Ponens rule for an implicative theorem.
=FRULE 1 Rule
´_match_mp_rule
÷
‡1 ô µ x1 ...· t1 ´ t2; ‡2 ô t1'
÷
‡1 À ‡2 ô t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's antecedent to match the conclusion of the
second theorem, while not modifying the assumptions.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching,
but no change will be made that affects the assumptions.

This may be partially evaluated with only first argument.
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC
\subsection{Concerning ¤}
=DOC
val Û¤_match_mp_ruleÝ : THM -> THM -> THM;
=DESCRIBE
A matching Modus Ponens for $¤$.
=FRULE 1 Rule
¤_match_mp_rule
÷
‡1 ô µ x1 ...· t1 ¤ t2; ‡2 ô t1'
÷
‡1' À ‡2 ô t2'
=TEX
where we type instantiate, generalise and specialise
both conclusion and assumptions
to get the first theorem's LHS to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.

This may be partially evaluated with only first argument.
=SEEALSO
$´\_elim$ (Modus Ponens on $´$),
$simple\_¤\_match\-\_mp\_rule$
$¤\-\_mp\-\_rule$
$¤\-\_match\-\_mp\-\_rule1$
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC
=DOC
val Û¤_match_mp_rule1Ý : THM -> THM -> THM;
=DESCRIBE
A matching Modus Ponens for $¤$ that doesn't affect assumption lists.
=FRULE 1 Rule
¤_match_mp_rule1
÷
‡1 ô µ x1 ...· t1 ¤ t2; ‡2 ô t1'
÷
‡1 À ‡2 ô t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's LHS to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching,
but no change will be made that affects the assumptions.

This may be partially evaluated with only first argument.
=SEEALSO
$´\_elim$ (Modus Ponens on $´$),
$simple\_¤\_match\_mp\_rule1$
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC

\subsection{Concerning =}
=DOC
val Ûeq_match_convÝ : THM -> CONV ;
=DESCRIBE
This matches the LHS of an equational theorem to a term,
instantiating the RHS accordingly.
The equational theorem may be partially or fully universally quantified
(simple or by varstruct),
without affecting the result of the conversion.
=FRULE 1 Conversion
eq_match_conv
(‡ ô µ ...· u = v)
¬t®
÷
÷
‡ ô t = v'
=TEX
where $v'$ is the result of applying to $v$ the instantiation rules required to match $u$ to $t$
(including both term and type instantiation).
If there are free variables on the RHS of the supplied equational theorem (when stripped of all universal quantification)
they will be renamed as necessary to avoid identification with
any variables in $t$.

This conversion may be partially evaluated with only its theorem argument.
=SEEALSO
$eq\_match\_conv1$
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC

=DOC
val Ûeq_match_conv1Ý : THM -> CONV ;
=DESCRIBE
This matches the LHS of an universally quantified (simple or by varstruct) equational theorem to a term,
instantiating the RHS accordingly.
The conversion will only instantiate its universal quantifications,
and type variables not found within the assumptions, not its free term variables.
=FRULE 1 Conversion
eq_match_conv1
(‡ ô µ x1 ... xn· u[x1,...,xn] = 
   v[x1,...,xn])
¬t®
÷
÷
‡ ô t = v[t1,...,tn]
=TEX
where ¬u[t1,...,tn]® is $\alpha$-convertible to ¬t®.
If there are free variables on the RHS of the supplied equational theorem (when stripped of all universal quantification)
they will be renamed as necessary to avoid identification with
any variables in $t$.

This conversion may be partially evaluated with only its theorem argument.
=USES
In producing a limited rewriting facility, that only instantiates
explicitly identified variables.
=FAILURE
27003	?0 is not of the form `‡ ô µ x1 ... xn· u = v`
	where ¬xi® are varstructs
7076	Could not match term ?0 to LHS of theorem ?1
=ENDDOC
\subsection{Concerning Ì}
=DOC
val ÛÂ_ruleÝ : THM -> THM;
=DESCRIBE
An elimination rule for $Ì$, which can handle paired abstractions.
=FRULE 1 Rule
Â_rule
÷
‡ ô (Ì x· t[x]) y
÷
‡ ô t[y]
=TEX
=SEEALSO
$beta\_conv$
=FAILURE
27007	?0 is not of the form: `‡ ô (Ì x· t[x]) y`
	where ¬x® is a varstruct
=ENDDOC
=DOC
val ÛÂ_convÝ : CONV;
=DESCRIBE
Apply a $\beta$-reduction to an abstraction.
=FRULE 1 Rule
Â_conv
¬(Ì x· t1[x])t2®
÷
÷
ô ((Ì x· t[x])y) = t'[y]
=TEX
where $x$ may be any varstruct allowed by the ICL HOL syntax, 
$y$ is an instance of this structure,
and $t'$ is $\alpha$-convertible to $t$, changed to avoid variable capture.

When the bound variable structure has a pair,
where the value applied to does not, then $Fst$ and $Snd$ are
introduced as necessary, e.g.:
=GFT Example
Â_conv ¬(Ì (x,y)· f x y) p® =
	ô (Ì (x,y)· f x y) p = f (Fst p) (Snd p)
=TEX
=SEEALSO
$simple\_\beta\_conv$, $\beta\_rule$
=FAILURE
27008	?0 is not of the form: ¬(Ì x· t1[x])t2®
	where ¬x® is a varstruct
=ENDDOC
=DOC
val Ûall_Â_convÝ : CONV;
=DESCRIBE
A conversion to eliminate all instances of $\beta$ redexes,
including paired abstraction redexes, in a term, regardless of nesting, or even that the $\beta$ redex was created as the result of
an earlier reduction in the conversion's evaluation.
=FRULE 1 Rule
all_Â_conv
¬t®
÷
÷
ô t = t'
=TEX
$t'$ is $t$ with all $\beta$ redexes reduced.
=USES
This uses an optimised term traversal algorithm, superior in speed
to the general term traversal algorithms used with conversions,
and should be used in preference to them and $\beta\_conv$.
=SEEALSO
$all\_simple\_\beta\_conv$ which only handles simple
$\beta$-redexes, but does a faster traversal if that is all that is required.
$all\_\beta\_rule$.
=FAILURE
27049	?0 contains no Â-redexes
=ENDDOC
=DOC
val Ûall_Â_ruleÝ : THM -> THM;
=DESCRIBE
Eliminate all instances of $\beta$ redexes,
including paired abstraction redexes, in the conclusion of a theorem, regardless of nesting, or even that the $\beta$ redex was created as the result of
an earlier reduction in the rule's evaluation.
=FRULE 1 Rule
all_Â_rule
÷
‡ ô t
÷
‡ ô t'
=TEX
$t'$ is $t$ with all $\beta$-redexes reduced.
=SEEALSO
$all\_\beta\_conv$ for the conversion.
$all\_simple\_\beta\_rule$ which only handles simple
$\beta$-redexes, but does a faster traversal if that is all that is required.
=FAILURE
27049	?0 contains no Â-redexes
=ENDDOC
=DOC
val ÛÌ_eq_ruleÝ : TERM -> THM -> THM;
=DESCRIBE
Given an equational theorem, return the equation formed by abstracting the term argument (which must be an allowed variable structure) from both sides.
=FRULE 1 Rule
Ì_eq_rule
¬x®
÷
‡ ô t1[x] = t2[x]
÷
‡ ô (Ì x· t1[x]) = (Ì x· t2[x])
=TEX
=FAILURE
4016	?0 is not an allowed variable structure
6005	?0 occurs free in assumption list
6020	?0 is not of the form: `‡ ô t1 = t2`
=ENDDOC
=DOC
val Û%eta%_convÝ : CONV;
=DESCRIBE
The rule for $\eta$ conversion.
=FRULE 1 Conversion
%eta%_conv
¬Ì vs· t vs®
÷
÷
ô (Ì vs· t vs) = t
=TEX
where $t$ contains no free instances of the variables of varstruct $vs$.
=FAILURE
27018	?0 is not of the form: ¬Ì vs· t vs'®
	where ¬vs® is a varstruct
27023	?0 is not of the form: ¬Ì vs· t vs® where ¬t® should not contain ¬vs®
=ENDDOC
=DOC
val ÛÌ_varstruct_convÝ : TERM -> CONV;
=DESCRIBE
This conversion allows one to change between any lambda abstracted varstruct
that has the same type.
=FRULE 1 Rule
Ì_varstruct_conv
¬Ì vs1[x1,y1,...]· t[x1,y1,...]®
¬Ì vs2[x2,y2,...]· t'[x2,y2,...]®
÷
÷
ô (Ì vs2[x2,y2,...]· t[x2,y2,...]) =
	(Ì vs1[x1,y1,...]· t'[x1,y1,...])
=TEX
Where the types of $vs1[x1,y1,...]$ and $vs2[x2,y2,...]$
are the same, and $t'$ and $t$ differ only in applications of $Fst$ and $Snd$ to the bound variables.
=SEEALSO
$\alpha\_conv$ for a more limited form of renaming.
=FAILURE
27050	Cannot prove equality of ?0 and ?1
=ENDDOC
This is implemented using two $\beta$-reductions, one for each term applied to the same machine-generated variable.
Worse, if a simple approach fails, it will attempt to pull $Fst$ and $Snd$ together by pure rewriting.
It is thus potentially not very fast.

\subsection{Concerning µ}
=DOC
val Ûµ_uncurry_convÝ : CONV;
=DESCRIBE
Convert a paired universally quantified term into
simple universal quantifications of the same term.
=FRULE 1 Conversion
µ_uncurry_conv
¬µ vs[x,y,...]· f[x,y,...]®
÷
÷
‡ ô µ vs[x,y,...]· f[x,y,...] = 
	µ x y ...· f[x,y,...]
=TEX
where $vs[x,y,...]$ is an allowed variable structure with
variables $x,y,...$.
It may not be a simple variable.
=SEEALSO
$Ì\_varstruct\_conv$, $all\_µ\_uncurry\_conv$.
=FAILURE
27038	?0 is not of the form: ¬µ (x,y)· f®
=ENDDOC
=DOC
val Ûall_µ_uncurry_convÝ : CONV;
=DESCRIBE
Apply $µ\_uncurry\_conv$ (q.v) to the outer universal
quantifications of a term,
flattening those binders.
=FRULE 1 Conversion
all_µ_uncurry_conv
¬µ vs1[x1,y1,...] vs2[x2,y2,...] ...· 
	f[x1,y1,...,x2,y2,...]®
÷
÷
‡ ô (µ vs1[x,y,...] vs2[x,y,...] ...· 
	f[x1,y1,...,x2,y2,...])
 = (µ x1 y1 ... x2 y2 ...· 
	f[x1,y1,...,x2,y2,...])
=TEX
where the $vs_i[x_i,y_i,...]$ are variable structures
at least one of which must not be a simple variable,
built from variables $x_i,y_i,...$,
=FAILURE
27041	?0 is not of the form: ¬µ ... (x,y) ...· f®
=ENDDOC
=DOC
val Ûµ_introÝ : TERM -> THM -> THM;
=DESCRIBE
Introduce a universally quantified theorem.
=FRULE 1 Rule
µ_intro
¬x®
÷
‡ ô t
÷
‡ ô µ x'· t
=TEX
Where $¬x'®$ is an allowed variable structure based on $¬x®$, but with
duplicate variables renamed, the original name being rightmost in the resulting variable structure.
=SEEALSO
$list\_µ\_intro$, $all\_µ\_intro$.
=FAILURE
4016	?0 is not an allowed variable structure
6005	?0 occurs free in assumption list
=ENDDOC
=DOC
val Ûµ_elimÝ : TERM -> THM -> THM;
=DESCRIBE
Instantiate a universally quantified variable to a given value.
=FRULE 1 Rule
µ_elim
¬t1®
÷
‡ ô µ x· t2[x]
÷
‡ ô t2'[t1]
=TEX
where $t2'$ is renamed from $t2$ to prevent bound variable capture,
and $x$ is a varstruct, instantiable to the structure of $t1$.
The term will be expanded using $Fst$ and $Snd$ as necessary to match
the structure of $¬x®$.
=SEEALSO
$list\_µ\_elim$, $all\_µ\_elim$.
=FAILURE
27011	?0 is not of the form: `‡ ô µ x· t` where ¬x® is a varstruct
27012	?0 is not of the form: `‡ ô µ x· t` where the type of ¬x® 
	is the type of ?1
=ENDDOC
=DOC
val Ûlist_µ_introÝ : TERM list -> THM -> THM;
=DESCRIBE
Generalised $µ$ introduction.
=FRULE 1 Rule
list_µ_intro
[¬x1®, ..., ¬xn®]
÷
‡ ô t[x1, ..., xn]
÷
‡ ô µ x1 ... xn· t[x1, ..., xn]
=TEX
=SEEALSO
$µ\_intro$, $all\_µ\_intro$.
=FAILUREC
\paragraph{Errors}
Same messages as $µ\_intro$.
=ENDDOC
=DOC
val Ûlist_µ_elimÝ : TERM list -> THM -> THM;
=DESCRIBE
Generalised $µ$ elimination.
=FRULE 1 Rule
list_µ_elim
[¬t1®, ..., ¬tn®]
÷
‡ ô µ x1 ... xn· t[x1, ..., xn]
÷
t[t1, ..., tn]
=TEX
=SEEALSO
$µ\_elim$, $all\_µ\_elim$.
=FAILUREC
\paragraph{Errors}
Same messages as $µ\_elim$.
=ENDDOC
=DOC
val Ûall_µ_elimÝ : THM -> THM;
=DESCRIBE
Specialises all the outer universal quantifications in a theorem:
=FRULE 1 Rule
all_µ_elim
÷
‡ ô µ x1 ... xn· t[x1, ..., xn]
÷
‡ ô t[x1', ..., xn']
=TEX
where $x1', \ldots, xn'$ are renamed from $x1, \ldots, xn$ as necessary to avoid name clashes with
free variables in the assumption list.
=SEEALSO
$all\_µ\_arb\_elim$ which is faster, though the results are
slightly opaque.
$list\_µ\_elim$.
=ENDDOC
=DOC
val Û³_µ_convÝ : CONV;
=DESCRIBE
Move $³$ into a $µ$ construct.
=FRULE 1 Rule
³_µ_conv
¬³ (µ x· t[x])®
÷
÷
ô (³ (µ x· t[x])) ¤ ¶ x· ³ t[x]
=TEX
=SEEALSO
$simple\_³\_µ\_conv$ which only works with simple $µ$-abstractions, $³\_¶\_conv$
=FAILURE
27019	?0 not of the form: ¬³ (µ x· t[x])®
	where ¬x® is a varstruct
=ENDDOC
=DOC
val Ûµ_¤_ruleÝ : TERM -> THM -> THM;
=DESCRIBE
Universally quantify a variable on both sides of an equivalence.
=FRULE 1 Rule
µ_¤_rule
¬x®
÷
‡ ô p[x] ¤ q[x]
÷
‡ ô (µ x· p[x]) ¤ (µ x· q[x])
=TEX
where $x$ is a varstruct.
=FAILURE
6005	?0 occurs free in assumption list
6020	?0 is not of the form: `‡ ô t1 = t2`
7062	?0 is not of the form: `‡ ô t1 ¤ t2`
4016	?0 is not an allowed variable structure
=ENDDOC
=DOC
val Ûµ_arb_elimÝ : THM -> THM;
=DESCRIBE
Specialise a universally quantified theorem with a machine generated variable or variable structure.
=FRULE 1 Rule
µ_arb_elim
÷
‡ ô µ vs[x,y,...]· p[x,y,...]
÷
‡ ô p[x',y',...]
=TEX
where $x'$, $y'$, etc, are not variables (free or bound) in $p$ or $‡$,
created by $gen\_vars$(q.v).
=SEEALSO
$µ\_elim$
=FAILURE
27011	?0 is not of the form: `‡ ô µ x· t` where ¬x® is a varstruct
=ENDDOC
=DOC
val Ûall_µ_arb_elimÝ : THM -> THM;
=DESCRIBE
Specialise all the quantifiers of a possibly universally quantified theorem with a machine generated variables or variable structures.
=FRULE 1 Rule
µ_arb_elim
÷
‡ ô µ vs1[x1,y1,...] vs2[x2,y2,...] ...· 
	p[x1,y1,....x2,y2,...]
÷
‡ ô p[x1',y1',...,x2',y2',...]
=TEX
where $x_i'$, $y_i'$, etc, are not variables (free or bound) in $p$ or $‡$,
created by $gen\_vars$(q.v).
=SEEALSO
$all\_µ\_elim$
=ENDDOC
The precise rules for the name formation of $x$ will not be given here.
=DOC
val Ûµ_asm_ruleÝ : TERM -> TERM -> THM -> THM;
=DESCRIBE
Generalise an assumption (Left $µ$ introduction).
=FRULE 1 Rule
µ_asm_rule
¬x®
¬p[x]®
÷
‡, p'[x] ô q[x]
÷
‡, µ x· p'[x] ô q[x]
=TEX
where $p$ and $p'$ are $\alpha$-convertible.
$x$ {\bf may} be free in $‡$.
The function will work even if $p'[x]$ is not present
in the assumption list.
=FAILURE
4016	?0 is not an allowed variable structure
=ENDDOC
This is from \cite{Manna74}.
=DOC
val Ûµ_reorder_convÝ : TERM -> CONV;
=DESCRIBE
Reorder universal quantifications.
=FRULE 1 Rule
µ_reorder_conv
¬µ x1 .. xn· t1®
¬µ y1 .. ym· t2®
÷
÷
(µ y1 .. ym· t2) ¤ (µ x1 .. xn· t1)
=TEX
where the $x_i$ and $y_i$ are varstructs,
and the reordering, restructuring (by pairing) and renaming requested is provable by this function.
The presence of redundant quantifiers, including duplicates, is also handled.
=EXAMPLE
:> µ_reorder_conv ¬µ (x,q) z· x ± z® ¬µ (z,z,y) x· x ± z®;
val it = ô (µ (z, z, y) x· x ± z) ¤ (µ (x, q) z· x ± z) : THM
=SEEALSO
$¶\_reorder\_conv$
=FAILURE
27050	Cannot prove equality of ?0 and ?1
=ENDDOC

We do not give a rule for $µµ$ introduction from \cite{Manna74}.
=DOC
val ÛALL_SIMPLE_µ_CÝ : CONV -> CONV;
=DESCRIBE
This conversional applies its conversion argument to the body of a repeated simple universal quantification.
=FAILUREC
\paragraph{Errors}
As the failure of the conversion argument.
=ENDDOC
=DOC
val Ûsimple_µ_¶_convÝ: CONV;
=DESCRIBE
Swap the order of a simple $µ$ and $¶$:
=FRULE 1 Conversion
simple_µ_¶_conv
¬µ x· ¶ y· P[x,y]®
÷
÷
ô (µ x· ¶ y· P[x,y]) ¤ 
	(¶ y'· µ x· P[x, y' x])
=TEX
where $y'$ is renamed to distinguish it from $y$ (for the types differ) and every other term variable in the argument.
=FAILURE
27031	?0 is not of the form: ¬µ x· ¶ y· P[x,y]®
=ENDDOC
=DOC
val Ûsimple_¶_µ_convÝ: CONV;
=DESCRIBE
Swap the order of a simple $¶$ and $µ$:
=FRULE 1 Conversion
simple_¶_µ_conv
¬¶ x· µ y· P[x,y]®
÷
÷
ô (¶ x· µ y· P[x,y]) ¤ 
	(µ y'· ¶ x· P[x, y' x])
=TEX
where $y'$ is renamed to distinguish it from $y$ (for the types differ) and every other term variable in the argument.
=FAILURE
27032	?0 is not of the form: ¬¶ x· µ y· P[x,y]®
=ENDDOC
=DOC
val Ûsimple_¶_µ_conv1Ý: CONV;
=DESCRIBE
Swap the order of a simple $¶$ and $µ$, where the first variable is always applied to the second:
=FRULE 1 Conversion
simple_¶_µ_conv1
¬¶ f· µ x· P[f x, x]®
÷
÷
(¶ f· µ x· P[f x, x]) ¤ 
 (µ x· ¶ f'· P[f', x])
=TEX
where $f'$ is renamed to distinguish it from $f$ (for the types differ) and every other term variable in the argument.
=FAILURE
27033	?0 is not of the form: ¬¶ f· µ x· P[f x,x]®
=ENDDOC
There is a potential design error in these two functions,
that is checked for ``just in case''.
=FAILURE
27034	DESIGN ERROR: resulting theorem for ?0 could not 
	be coerced to correct LHS
=TEX

\subsection{Concerning ¶}
=DOC
val Ûv_¶_introÝ : TERM -> THM -> THM ;
=DESCRIBE
Introduce an existential quantified variable structure into a theorem.
=FRULE 1 Rule
v_¶_intro
¬vs[x,y,...]®
÷
‡ ô t[x,y,...]
÷
‡ ô ¶ vs[x,y,...]· t[x,y,...]
=TEX
where ¬vs[x,y,...]® is a varstruct built from variables $¬x®$, $¬y®$, etc, which may contain duplicates.
=USES
If the functionality is sufficient, this is superior
in efficiency to both $¶\_intro$ and $simple\_¶\_intro$ (q.v.).
=FAILURE
4016	?0 is not an allowed variable structure
=ENDDOC
=DOC
val Û¶_introÝ : TERM -> THM -> THM ;
=DESCRIBE
Introduce an existential quantifier by reference to a witness.
=FRULE 1 Rule
¶_intro
¬¶ vs[x,y,...]· t[x,y,...]®
÷
‡ ô t[t1,t2,...]
÷
‡ ô ¶ vs[x',y',...]· t[x,y,...]
=TEX
where ¬vs[x,y,...]® is varstruct built from variables $¬x®$, $¬y®$, etc,
and the $¬x'®$ are renamed if duplicated inside the varstruct, all but the rightmost being so renamed.
=FAILURE
4020	?0 is not of form: ¬¶ vs· t®
7047	?0 cannot be matched to conclusion of theorem ?1
=ENDDOC
=DOC
val Û¶_elimÝ : TERM -> THM -> THM -> THM;
=DESCRIBE
Eliminate an existential quantifier by reference to an arbitrary varstruct satisfying the predicate.
=FRULE 1 Rule
¶_elim
¬vs[y1,y2,...]®
÷
‡1 ô ¶ vs[x1,x2,...]· t1[x1,x2,...]; 
‡2, t1[y1,y2,...] ô t2
÷
‡1 À ‡2 ô t2
=TEX
$t1[y1,y2,...]$ need not actually be present in the assumptions of the second theorem.
The $y_i$ must be free variables, none of whom are present elsewhere in the second theorem, or in the conclusion
of the first.
The $y_i$ may contain duplicates as long as the end pattern
matches the $x_i$ in required duplicates.
The term argument may be a less complex variable structure
than the bound variable structure of the theorem,
as $Fst$ and $Snd$ are used to make them match.
For example, the following rule holds true:
=FRULE 1 Rule
¶_elim
¬x®
÷
‡1 ô ¶ (p,q)· t1[p,q]; 
‡2, t1[Fst x, Snd x] ô t2
÷
‡1 À ‡2 ô t2
=TEX

=FAILURE
27042	?0 does not match the bound varstruct of ?1
27046	?0 is not of the form `‡ ô ¶ vs· t`
27051	?0 has members appearing free in conclusion of ?1
27052	?0 has members appearing free in ?1 other than in assumption ?2
=ENDDOC
=DOC
val Û¶_uncurry_convÝ : CONV;
=DESCRIBE
Convert a paired existentially quantified term into
simple universal quantifications of the same term.
=FRULE 1 Conversion
¶_uncurry_conv
¬¶ vs[x,y,...]· f[x, y,...]®
÷
÷
ô ¶ vs[x,y,...]· f[x,y,...] = 
	¶ x y ...· f[x,y,...]
=TEX
where $vs[x,y,...]$ is an allowed variable structure with
variables $x,y,...$.
It may not be a simple variable.
=SEEALSO
$Ì\_varstruct\_conv$, $all\_¶\_uncurry\_conv$, $µ\_uncurry\_conv$.
=FAILURE
27047	?0 is not of the form: ¬¶ (x,y)· f®
=ENDDOC
=DOC
val Ûall_¶_uncurry_convÝ : CONV;
=DESCRIBE
Apply $¶\_uncurry\_conv$ (q.v) to the outer existential
quantifications of a term,
flattening those binders.
=FRULE 1 Conversion
all_¶_uncurry_conv
¬¶ vs1[x1,y1,...] vs2[x2,y2,...] ...· 
 f[x1,y1,...,x2,y2,...]®
÷
÷
‡ ô (¶ vs1[x,y,...] vs2[x,y,...]· 
	f[x1,y1,...,x2,y2,...])
 = (¶ x1 y1 ... x2 y2 ...· 
	f[x1,y1,...,x2,y2,...])
=TEX
where the $vs[x,y,...]$ are variable structures
with variables $x,y,...$, at least one of which must not be a simple variable.
=SEEALSO
$all\_µ\_uncurry\_conv$
=FAILURE
27048	?0 is not of the form: ¬¶ ... (x,y) ...· f®
=ENDDOC
=DOC
val Û³_¶_convÝ : CONV;
=DESCRIBE
Move $³$ into an $¶$ construct.
=FRULE 1 Rule
³_¶_conv
¬³ (¶ x· t[x])®
÷
÷
ô (³ (¶ x· t[x])) ¤ µ x· ³ t[x]
=TEX
=SEEALSO
$simple\_³\_¶\_conv$ which only works with simple $¶$-abstractions, $³\_µ\_conv$
=FAILURE
27020	?0 is not of the form: ¬³ (¶ x· t[x])®
	where ¬x® is a varstruct
=ENDDOC
=DOC
val Û¶_asm_ruleÝ : TERM -> TERM -> THM -> THM;
=DESCRIBE
Existentially quantify an assumption (Left $¶$ introduction).
=FRULE 1 Rule
¶_asm_rule
¬x®
¬p[x]®
÷
‡, p'[x] ô q
÷
‡, ¶ x· p'[x] ô q
=TEX
where $p$ and $p'$ are $\alpha$-convertible.
where the variables of the varstruct $x$ are not free in $‡$ or $q$.
The assumption need not be present for the rule to apply.
=FAILURE
3015	?1 is not of type ¬:BOOL®
4016	?0 is not an allowed variable structure
6005	?0 occurs free in assumption list
27052	?0 has members appearing free in ?1 other than in assumption ?2
=FAILUREC
Message 3015 is just passed on from low level functions,
which is why it has "?1" not "?0".
=ENDDOC
This is from \cite{Manna74}.

=DOC
val Û¶_reorder_convÝ : TERM -> CONV;
=DESCRIBE
Reorder existential quantifications.
=FRULE 1 Rule
¶_reorder_conv
¬¶ x1 .. xn· t1®
¬¶ y1 .. ym· t2®
÷
÷
(¶ y1 .. ym· t2) ¤ (¶ x1 .. xn· t1)
=TEX
where the $x_i$ and $y_i$ are varstructs,
and the reordering, restructuring (by pairing) and renaming requested is provable by this function.
The presence of redundant quantifiers, including duplicates, is also handled.
=EXAMPLE
:> ¶_reorder_conv ¬¶ (x,q) z· x ± z® ¬¶ (z,z,y) x· x ± z®;
val it = ô (¶ (z, z, y) x· x ± z) ¤ (¶ (x, q) z· x ± z) : THM
=SEEALSO
$µ\_reorder\_conv$
=FAILURE
27050	Cannot prove equality of ?0 and ?1
=ENDDOC

We do not give a rule for $¶¶$ introduction from \cite{Manna74}.
=DOC
val ÛALL_SIMPLE_¶_CÝ : CONV -> CONV;
=DESCRIBE
This conversional applies its conversion argument to
the body of a repeated simple existential quantification.
=FAILUREC
\paragraph{Errors}
As the failure of the conversion argument.
=ENDDOC

\subsection{Concerning ¶$_1$}
=DOC
val Û¶‰1_introÝ : THM -> THM -> THM;
=DESCRIBE
Introduce $¶_1$ by reference to a witness, and a uniqueness theorem.
=FRULE 1 Rule
¶‰1_intro
÷
‡1 ô P'[t']
‡2 ô µ x· P[x] ´ x = t
÷
‡1 À ‡2 ô ¶‰1 x· P[x]
=TEX
Where $P'$ is $\alpha$-convertible to $P$, and
$t'$ is $\alpha$-convertible to $t$.
Notice that for the resulting theorem we take the varstruct, $x$,
and the form of the predicate, $P$, from the second theorem.
=FAILURE
27021	?0 and ?1 are not of the form: `‡1 ô Pa[ta]` and 
	`‡2 ô µ vs[x,y,..]· P[x,y...] ´ vs[x,y,..] = t`
	where ¬Pa® and ¬P®, ¬ta® and ¬t® are Á-convertible
	and ¬x® is a varstruct
27054	?0 not of the form: `‡ ô µ vs[x,y,..]· P[x,y...] ´ vs[x,y,..] = t`
=ENDDOC
=DOC
val Û¶‰1_elimÝ : THM -> THM;
=DESCRIBE
Express a $¶_1$ in terms of $¶$ and a uniqueness property.
=FRULE 1 Rule
¶‰1_elim
÷
‡ ô ¶‰1 vs[a,b,...]· P[a,b,...]
÷
‡ ô ¶ vs[a,b,...]· P[a,b,...] ± 
	µ vs[a',b',...]· P[x1,x2,...]
 ´ 
	vs[a',b',...] = vs[a,b,...]
=TEX
where the $a'$, etc, are variants of the $a$.
=FAILURE
27022	?0 is not of the form: `‡ ô ¶‰1 x· P[x]`
	where ¬x® is a varstruct
=ENDDOC
This could be rewritten to produce two theorems,
$`¶\ x·\ P[x]`$ and $`µ\ x\ y·\ P[x]\ ±\ P[y]\ ´\ x\ =\ y`$
=DOC
val Û¶‰1_convÝ : CONV;
=DESCRIBE
This is a conversion which turns a unique existential quantifier into
an equivalent existential quantifier
=FRULE 1 Conversion
¶‰1_conv
¬¶‰1vs[x1,...]·t[x1,...]®
÷
÷
ô (¶‰1vs[x1,...]·t[x1,...]) ¤ 
	(¶vs[x1,...]·t[x1,...] ± 
	µvs[x1',...]·t[x1',...] ´ 
	vs[x1',...] = vs[x1,...])
=TEX
=USES
Tactic and conversion programming.
=SEEALSO
$strip\_tac$, $simple\_¶_1\_conv$
=FAILURE
27053	?0 is not of the form: ¬¶‰1vs·t®
=ENDDOC
\subsection{Concerning Í}
=DOC
val ÛcÍ_elim_ruleÝ : TERM -> THM -> THM -> THM;
=DESCRIBE
Given that $Í$ of a predicate satisfies that predicate, then
in a different theorem we may eliminate an assumption that
claims an otherwise unused variable structure satisfies the predicate.
=FRULE 1 Rule
cÍ_elim_rule
¬vs®
÷
‡1 ô t' (Í t'');
‡2, t vs ô s
÷
‡1 À ‡2 ô s
=TEX
where $t$, $t'$ and $t''$ are $\alpha$-convertible, and 
$vs$ is a varstruct, with no duplicates, and with its free variables
occurring nowhere else in the second theorem, or in the conclusion
of the first.
Actually $(Í\ t'')$ can be any value, rather than a choice construct.
=FAILURE
4016	?0 is not an allowed variable structure
7019	?0 is not of the form: `‡ ô t1(Í t1)`
7054	?0 is not of same type as choice sub-term of first theorem
27043	?0 is repeated in the varstruct ?1
27045	Arguments ?0; ?1 and ?2 not of the form ¬vs®; `‡1 ô t (Í t)` and
	`‡2, (t vs) ô s`
27051	?0 has members appearing free in conclusion of ?1
27052	?0 has members appearing free in ?1 other than in assumption ?2
=ENDDOC
The above cannot handle duplicates within $vs$, because for instance a predicate on $(a,a)$ 
where $a$ is free is not the same as that predicate on $x$ where $x$ is free.
Renaming is not a sensible solution.
=DOC
val Û¶_Í_ruleÝ : THM -> THM;
=DESCRIBE
Give that $Í$ of a predicate satisfies the predicate by reference to an $¶$ construct.
It can properly handle paired existence.
=FRULE 1 Rule
¶_Í_rule
÷
‡ ô ¶ x· p[x]
÷
‡ ô p[Í x· p x]
=TEX
If $x$ is formed by paired then the $Fst$ and $Snd$ are used to extract the appropriate bits of the Í-term 
for distribution in $p[Í\ x·\ p\ x]$.
=SEEALSO
$¶\_Í\_conv$
=FAILURE
27024	?0 is not of the form: `‡ ô ¶ x· p[x]`
	where ¬x® is a varstruct
=ENDDOC
=DOC
val Û¶_Í_convÝ : CONV;
=DESCRIBE
Give that $Í$ of a predicate satisfies the predicate by reference to an $¶$ construct.
It can properly handle paired existence.
=FRULE 1 Rule
¶_Í_conv
¬¶ x· p[x]®
÷
÷
‡ ô (¶ x· p[x]) = p(Í x· p x)
=TEX
If $x$ is formed by paired then the $Fst$ and $Snd$ are used to extract the appropriate bits of the Í-term 
for distribution in $p[Í\ x·\ p\ x]$.
=SEEALSO
$¶\_Í\_rule$
=FAILURE
27024	?0 is not of the form: `‡ ô ¶ x· p[x]`
	where ¬x® is a varstruct
=ENDDOC
\subsection{Concerning Local Definitions}
=DOC
val Ûlet_convÝ : CONV;
=DESCRIBE
Eliminate an outermost $let\ldots and\ldots in\ldots$ construct.
=FRULE 1 Conversion
let_conv
¬let vs1[x1,y1,..] = 
 t1 and ... vsn[xn,yn,..] = tn 
 in t[x1,...,xn,...]®
÷
÷
ô (let vs1[x1,y1,..] = t1 
 and ... and vsn[xn,yn,..] = tn 
 in t[x1,...,xn,...] 
	= t[t1x,...,t1y,...,tnx,tny,...]
=TEX
Where the $t_ix$ is the component of $t_i$ matching $x_i$
when $t_i$ matches $vs_i[x_i,y_i,..]$.
=FAILURE
4009	?0 is not of form: ¬let ... in ...®
=ENDDOC

\subsection{Concerning $Uncurry$}
I don't believe we need a rule for eliminating $Uncurry$,
and its introduction is mostly behind the scenes.

\subsection{Concerning Sets}
A much wider set of rules than the below could be given.
=DOC
val Û_convÝ : CONV;
=DESCRIBE
A conversion for set membership.
It can handle variable structures bound by the set comprehension.
=FRULE 1 Conversion
_conv
¬t  {v[x,y,...] | p[x,y,...]}®
÷
÷
ô t  {vs[x,y,...] | p[x,y,...]} 
¤ p[x1,y1,...]
=TEX
where $x1$, $y1$, etc, are the appropriate components of
$t$, extracted via $Fst$ and $Snd$.
=SEEALSO
$simple\_\_conv$
=FAILURE
27002	?0 is not of form:¬x  {v | p[v]}®
=ENDDOC
=DOC
val Ûenum_set_ruleÝ : TERM -> TERM list -> THM;
=DESCRIBE
Give that something within an enumerated set is a member of that set.
=FRULE 1 Rule
enum_set_rule
¬ti®
[¬t1®,...¬tn®]
÷
÷
ô ti  {t1,...,tn}
=TEX
where $ti$ is $\alpha$-convertible to one of $t1,\ldots,tn$.
=FAILURE
3012	?0 and ?1 do not have the same types
27001	?0 not a member of list of terms
=FAILUREC
Message 3012 occurs when the term list cannot be made into
an enumerated set because of differing types.
=ENDDOC
=DOC
val Ûenum_set_convÝ : CONV;
=DESCRIBE
Give that something within an enumerated set is a member of that set.
=FRULE 1 Conversion
enum_set_conv
¬ti  {t1,...,tn}®
÷
÷
ô ti  {t1,...,tn} ¤ T
=TEX
where $ti$ is $\alpha$-convertible to one of $t1,\ldots,tn$.
=FAILURE
27005	?0 not a member of the enumerated set ?1
27006	?0 is not of the form: ¬x  {t1, ..., tn}®
=FAILUREC
Message 3012 occurs when the term list cannot be made into
an enumerated set because of differing types.
=ENDDOC
\subsection{Conversionals}
=DOC
val ÛÌ_CÝ : CONV -> CONV;
=DESCRIBE
Apply a conversion to the body of an abstraction:
=FRULE 1 Rule
Ì_C
(c : CONV)
¬Ì x· p®
÷
÷
ô (Ì x· p[x]) = (Ì x· pa[x])
=TEX
where $c\ p[x]$ gives $`ô p[x] = pa[x]`$.
=FAILURE
4002	?0 is not of form: ¬Ì vs· t®
7104	Result of conversion, ?0, ill-formed
=FAILUREC
Also as the failure of the conversion.
=ENDDOC
=DOC
val ÛCBINDER_CÝ : CONV -> CONV;
=DESCRIBE
Apply a conversion to the body of a binder term:
=FRULE 1 Rule
CBINDER_C
(c : CONV)
¬B x· p®
÷
÷
ô (B x· p[x]) = (B x· pa[x])
=TEX
where $c\ p[x]$ gives $`ô p[x] = pa[x]`$,
and $B$ is a binder.
=FAILURE
27035	?0 is not of the form: ¬B x· p[x]® where ¬B® is a binder
	and ¬x® a varstruct
7104	Result of conversion, ?0, ill-formed
=FAILUREC
Also as the failure of the conversion.
=ENDDOC
This will later be renamed to $BINDER\-\_C$, and the current $BINDER\-\_C$ renamed to $SIMPLE\-\_BINDER\_C$.
\section{END OF THE SIGNATURE}
=SML
end; (* signature of DerivedRules2 *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

=IGN
open Sort;
fun sf {id = id1,text = text1} {id = id2,text = text2} = (
	if text1 <> text2
	then stringorder text1 text2
	else (id1 - id2)
);
sort sf (get_error_messages());

sort (fn x => fn y => x - y) (map (fn {id=id,...} => id)( get_error_messages()));


