=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design of Derived Rules of Inference II}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Derived Rules of Inference II}
\TPPref{DS/FMU/IED/DTD027}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for further 
derived rules of inference in ICL HOL,
in particular those concerned with paired abstractions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Fixed an error message.
\item [Issue 1.3]
Gained inference rules about sets.
\item [Issue 1.4]
Gained tautology material.
\item [Issue 1.5]
Changes with a view to implementation,
and to reflect changes in \cite{DS/FMU/IED/DTD007} issue 2.1.
\end{description}
\subsection{Changes forecast}
Rename $CBINDER\_C$ to $BINDER\_C$.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
derived rules of inference concerning paired abstractions.
This is called for in \cite{DS/FMU/IED/HLD012}.
The design is
implemented in \cite{DS/FMU/IED/IMP027}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
paired abstraction
derived rules of inference in Release 001 of ICL HOL.

The document provides groups of rules of inference, related by their core operator.

All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP027}.

We use the notation ``varstruct'' for ``an allowed variable structure, under ICL HOL syntax''.
\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.

This document places requirements upon the constants handled by the
inference rules discussed.
In summary, the requirements are that the definitions of the constants must be such that the designs of the rules are satisfiable.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the ``top level''.
Thus we give the commands here for those functions declared in the following signatures.
=SML
=TEX
\section{THE DERIVED RULES OF REASONING}
=DOC
signature ‚DerivedRulesII· = sig
=DESCRIBE
This provides the further derived rules of inference for ICL HOL.
They are primarily concerned with handling paired abstractions.
=ENDDOC
\subsection{Concerning ä}
=DOC
val ‚ä_match_mp_rule· : THM -> THM -> THM ;
=DESCRIBE
A matching Modus Ponens rule for an implicative theorem.
=RULE
ä_match_mp_rule
…
ˆ1 Ö É x1 ... é t1 ä t2; ˆ2 Ö t1'
…
ˆ1' ° ˆ2 Ö t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's antecedent to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.

This may be partially evaluated with only first argument.
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC
=DOC
val ‚ä_match_mp_rule1· : THM -> THM -> THM ;
=DESCRIBE
A matching Modus Ponens rule for an implicative theorem.
=RULE
ä_match_mp_rule
…
ˆ1 Ö É x1 ... é t1 ä t2; ˆ2 Ö t1'
…
ˆ1 ° ˆ2 Ö t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's antecedent to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.

This may be partially evaluated with only first argument.
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC
\subsection{Concerning Ç}
=DOC
val ‚Ç_match_mp_rule· : THM -> THM -> THM;
=DESCRIBE
A matching Modus Ponens for $Ç$.
=RULE
Ç_match_mp_rule
…
ˆ1 Ö É x1 ... é t1 Ç t2; ˆ2 Ö t1'
…
ˆ1' ° ˆ2 Ö t2'
=TEX
where we type instantiate, generalise and specialise
both conclusion and assumptions
to get the first theorem's LHS to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.

This may be partially evaluated with only first argument.
=SEEALSO
$ä\_elim$ (Modus Ponens on $ä$),
$simple\_Ç\_match\_mp\_rule$
$Ç\_match\_mp\_rule1$
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC
=DOC
val ‚Ç_match_mp_rule1· : THM -> THM -> THM;
=DESCRIBE
A matching Modus Ponens for $Ç$ tyhat doesn't affect assumption lists.
=RULE
Ç_match_mp_rule1
…
ˆ1 Ö É x1 ... é t1 Ç t2; ˆ2 Ö t1'
…
ˆ1 ° ˆ2 Ö t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's LHS to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.

This may be partially evaluated with only first argument.
=SEEALSO
$ä\_elim$ (Modus Ponens on $ä$),
$simple\_Ç\_match\_mp\_rule1$
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC

\subsection{Concerning =}
=DOC
val ‚eq_match_conv· : THM -> CONV ;
=DESCRIBE
This matches the LHS of an equational theorem to a term,
instantiating the RHS accordingly.
The equational theorem may be partially or fully universally quantified
(simple or by varstruct),
without affecting the result of the conversion.
=CONVERSION
eq_match_conv
(ˆ Ö É ... é u = v)
ªtº
…
…
ˆ Ö t = v'
=TEX
where $v'$ is the result of applying to $v$ the instantiation rules required to match $u$ to $t$
(including both term and type instantiation).
If there are free variables on the RHS of the supplied equational theorem (when stripped of all universal quantification)
they will be renamed as necessary to avoid identification with
any variables in $t$.

This conversion may be partially evaluated with only its theorem argument.
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC

=DOC
val ‚eq_match_conv1· : THM -> CONV ;
=DESCRIBE
This matches the LHS of an universally quantified (simple or by varstruct) equational theorem to a term,
instantiating the RHS accordingly.
The conversion will only instantiate its universal quantifications,
and type variables, not its free term variables.
=CONVERSION
eq_match_conv1
(ˆ Ö É x1 ... xn é u[x1,...,xn] = 
   v[x1,...,xn])
ªtº
…
…
ˆ Ö t = v[t1,...,tn]
=TEX
where ªu[t1,...,tn]º is $\alpha$-convertible to ªtº.
If there are free variables on the RHS of the supplied equational theorem (when stripped of all universal quantification)
they will be renamed as necessary to avoid identification with
any variables in $t$.

This conversion may be partially evaluated with only its theorem argument.
=USES
In producing a limited rewriting facility, that only instantiates
explicitly identified variables.
=FAILURE
27003	?0 is not of the form `ˆ Ö É x1 ... xn é u = v`
	where ªxiº are varstructs
7076	Could not match term ?0 to LHS of theorem ?1
=ENDDOC
\subsection{Concerning ç}
=DOC
val ‚%beta%_rule· : THM -> THM;
=DESCRIBE
An elimination rule for $ç$, which can handle paired abstractions.
=RULE
%beta%_rule
…
ˆ Ö (ç x é t[x]) y
…
ˆ Ö t[y]
=TEX
=SEEALSO
$beta\_conv$
=FAILURE
27007	?0 is not of the form: `ˆ Ö (ç x é t[x]) y`
	where ªxº is a varstruct
=ENDDOC
=DOC
val ‚%beta%_conv· : CONV;
=DESCRIBE
Apply a $\beta$-reduction to an abstraction.
=RULE
%beta%_conv
ª(ç x é t1[x])t2º
…
…
Ö ((ç x é t[x])y) = t'[y]
=TEX
where $x$ may be any varstruct allowed by the ICL HOL syntax, 
$y$ is an instance of this structure,
and $t'$ is $\alpha$-convertible to $t$, changed to avoid variable capture.

When the bound variable structure has a pair,
where the value applied to does not, then $Fst$ and $Snd$ are
introduced as necessary, e.g.:
ÛExample
%beta%_conv ª(ç (x,y) é f x y) pº =
	Ö (ç (x,y) é f x y) p = f (Fst p) (Snd p)
Ê 
=SEEALSO
$simple\_\beta\_conv$
=FAILURE
27008	?0 is not of the form: ª(ç x é t1[x])t2º
	where ªxº is a varstruct
=ENDDOC
=DOC
val ‚all_%beta%_conv· : CONV;
=DESCRIBE
A conversion to eliminate all instances of $\beta$ redexes,
including paired abstraction redexes, in a term, regardless of nesting, or even that the $\beta$ redex was created as the result of
an earlier reduction in the conversion's evaluation.
=RULE
all_%beta%_conv
ªtº
…
…
Ö t = t'
=TEX
$t'$ is $t$ with all $\beta$ redexes reduced.
=USES
This uses an optimised term traversal algorithm, superior in speed
to the general term traversal algorithms used with conversions,
and should be used in preference to them and $\beta\_conv$.
=FAILURE
27049	?0 contains no %beta%-redexes
=ENDDOC
=DOC
val ‚all_%beta%_rule· : THM -> THM;
=DESCRIBE
Eliminate all instances of $\beta$ redexes,
including paired abstraction redexes, in a theorem, regardless of nesting, or even that the $\beta$ redex was created as the result of
an earlier reduction in the rule's evaluation.
=RULE
all_%beta%_rule
…
ˆ Ö t
…
ˆ Ö t'
=TEX
$t'$ is $t$ with all $\beta$-redexes reduced.
=ENDDOC
=DOC
val ‚ç_eq_rule· : TERM -> THM -> THM;
=DESCRIBE
Given an equational theorem, return the equation formed by abstracting the term argument (which must be a variable structure) from both sides.
=RULE
ç_eq_rule
ªxº
…
ˆ Ö t1[x] = t2[x]
…
ˆ Ö (ç x é t1[x]) = (ç x é t2[x])
=TEX
=SEEALSO
$simple\_ç\_eq\_rule$
=FAILURE
27010	?0 is not a varstruct
6005	?0 occurs free in assumption list
6020	?0 is not of the form: `ˆ Ö t1 = t2`
=ENDDOC
=DOC
val ‚%eta%_conv· : CONV;
=DESCRIBE
The rule for $\eta$ conversion.
=RULE
%eta%_conv
ªç vs é t vsº
…
…
Ö (ç vs é t vs) = t
=TEX
where $t$ contains no free instances of the variables of varstruct $vs$.
=FAILURE
27018	?0 is not of the form: ªç vs é t vs'º
	where ªvsº is a varstruct
27023	?0 is not of the form: ªç vs é t vsº where ªtº should not contain ªvsº
=ENDDOC

\subsection{Concerning É}
=DOC
val ‚É_uncurry_conv· : CONV;
=DESCRIBE
Convert a paired universally quantified term into
simple universal quantifications of the same term.
=CONVERSION
É_uncurry_conv
ªÉ vs[x,y,...] é f[x,y,...]º
…
…
ˆ Ö É vs[x,y,...] é f[x,y,...] = É x y ... é f[x,y,...]
=TEX
where $vs[x,y,...]$ is a variable structure with
variables $x,y,...$.
It may not be a simple variable.
=FAILURE
27038	?0 is not of the form: ªÉ (x,y) é fº
=ENDDOC
=DOC
val ‚all_É_uncurry_conv· : CONV;
=DESCRIBE
Apply $É\_uncurry\_conv$ (q.v) to the outer universal
quantifications of a term,
flattening those binders.
=CONVERSION
É_uncurry_conv
ªÉ vs1[x1,y1,...] vs2[x2,y2,...] ... é f[x1,y1,...,x2,y2,...]º
…
…
ˆ Ö É vs1[x,y,...] vs2[x,y,...] é f[x1,y1,...,x2,y2,...] 
	= É x1 y1 ... x2 y2 ... é f[x1,y1,...,x2,y2,...]
=TEX
where the $vs[x,y,...]$ are variable structures
with variables $x,y,...$.
=FAILURE
27041	?0 is not of the form: ªÉ ... (x,y) ... é fº
=ENDDOC
=DOC
val ‚É_intro· : TERM -> THM -> THM;
=DESCRIBE
Introduce a universally quantified theorem.
=RULE
É_intro
ªxº
…
ˆ Ö t
…
ˆ Ö É x' é t
=TEX
Where $ªx'º$ is a variable structure based on $ªxº$, but with
duplicate variables renamed, the original name being rightmost in the resulting variable structure.
=SEEALSO
$simple\_É\_intro$
=FAILURE
27010	?0 is not a varstruct
6005	?0 occurs free in assumption list
=ENDDOC
=DOC
val ‚É_elim· : TERM -> THM -> THM;
=DESCRIBE
Instantiate a universally quantified variable to a given value.
=RULE
É_elim
ªt1º
…
ˆ Ö É x é t2[x]
…
ˆ Ö t2'[t1]
=TEX
where $t2'$ is renamed from $t2$ to prevent bound variable capture,
and $x$ is a varstruct, instantiable to the structure of $t1$.
The term will be expanded using $Fst$ and $Snd$ as necessary to match
the structure of $ªxº$.
=FAILURE
27011	?0 is not of the form: `ˆ Ö É x é t` where ªxº is a varstruct
27012	?0 is not of the form: `ˆ Ö É x é t` where the type of ªxº 
	is the type of ?1
=ENDDOC
=DOC
val ‚list_É_intro· : TERM list -> THM -> THM;
=DESCRIBE
Generalised $É$ introduction.
=RULE
list_É_intro
[ªx1º, ..., ªxnº]
…
ˆ Ö t[x1, ..., xn]
…
ˆ Ö É x1 ... xn é t[x1, ..., xn]
=TEX
=SEEALSO
$É\_intro$
=FAILUREC
\paragraph{Errors}
Same messages as $É\_intro$.
=ENDDOC
=DOC
val ‚list_É_elim· : TERM list -> THM -> THM;
=DESCRIBE
Generalised $É$ elimination.
=RULE
list_É_elim
[ªt1º, ..., ªtnº]
…
ˆ Ö É x1 ... xn é t[x1, ..., xn]
…
t[t1, ..., tn]
=TEX
=SEEALSO
$É\_elim$
=FAILUREC
\paragraph{Errors}
Same messages as $É\_elim$.
=ENDDOC
=DOC
val ‚all_É_elim· : THM -> THM;
=DESCRIBE
Specialises all the outer universal quantifications in a theorem:
=RULE
all_É_elim
…
ˆ Ö É x1 ... xn é t[x1, ..., xn]
…
ˆ Ö t[x1', ..., xn']
=TEX
where $x1', \ldots, xn'$ are renamed from $x1, \ldots, xn$ as necessary to avoid name clashes with
free variables in the assumption list.
=ENDDOC
=DOC
val ‚å_É_conv· : CONV;
=DESCRIBE
Move $å$ into a $É$ construct.
=RULE
å_É_conv
ªå (É x é t[x])º
…
…
Ö (å (É x é t[x])) Ç Ñ x é å t[x]
=TEX
This will work with any paired universal quantifier.
=FAILURE
27019	?0 not of the form: ªå (É x é t[x])º
	where ªxº is a varstruct
=ENDDOC
=DOC
val ‚É_Ç_rule· : TERM -> THM -> THM;
=DESCRIBE
Universally quantify a variable on both sides of an equivalence.
=RULE
É_Ç_rule
ªxº
…
ˆ Ö p[x] Ç q[x]
…
ˆ Ö (É x é p[x]) Ç (É x é q[x])
=TEX
where $x$ is a varstruct.
=FAILURE
7062	?0 is not of the form: `ˆ Ö t1 Ç t2`
27010	?0 is not a varstruct
6005	?0 occurs free in assumption list
=ENDDOC
=DOC
val ‚É_arb_elim· : THM -> THM;
=DESCRIBE
Specialise a universally quantified theorem with a machine generated variable.
=RULE
É_arb_elim
…
ˆ Ö É x é p[x]
…
ˆ Ö p[x']
=TEX
where $x'$ is not a variable (free or bound) in $p$.
=ENDDOC
The precise rules for the name formation of $x$ will not be given here.
=DOC
val ‚É_asm_rule· : TERM -> TERM -> THM -> THM;
=DESCRIBE
Generalise an assumption (Left $É$ introduction).
=RULE
É_asm_rule
ªxº
ªp[x]º
…
ˆ, p'[x] Ö q[x]
…
ˆ, É x é p'[x] Ö q[x]
=TEX
where $p$ and $p'$ are $\alpha$-convertible.
$x$ {\bf may} be free in $ˆ$.
=FAILURE
27010	?0 is not a varstruct
27032	?0 is not in assumption list
=ENDDOC
This is from \cite{Manna74}.
=DOC
val ‚É_reorder_conv· : TERM -> CONV;
=DESCRIBE
Reorder universal quantifications.
=RULE
É_reorder_conv
ªÉ x1 .. xn é t1º
ªÉ y1 .. ym é t2º
…
…
(É y1 .. ym é t2) Ç (É x1 .. xn é t1)
=TEX
where the $x_i$ and $y_i$ are varstructs,
and the reordering and renaming requested is valid.
=FAILURE
27015	Cannot prove theorem with conclusion ?0
27030	?0 is not of type ª:BOOLº
=ENDDOC


We do not give a rule for $ÉÉ$ introduction from \cite{Manna74}.
\subsection{Concerning Ñ}
=DOC
val ‚v_Ñ_intro· : TERM -> THM -> THM ;
=DESCRIBE
Introduce an existential quantified variable structure into a theorem.
=RULE
v_Ñ_intro
ªvs[x,y,...]º
…
ˆ Ö t[x,y,...]
…
ˆ Ö Ñ vs[x,y,...] é t[x,y,...]
=TEX
where ªvs[x,y,...]º is varstruct built from variables $ªxº$, $ªyº$, etc, which may contain duplicates.
=USES
If the functionality is sufficient, this is superior
in efficiency to both $Ñ\_intro$ and $simple\_Ñ\_intro$.
=FAILURE
4016	?0 is not an allowed variable structure
=ENDDOC
=DOC
val ‚Ñ_intro· : TERM -> THM -> THM ;
=DESCRIBE
Introduce an existential quantifier by reference to a witness.
=RULE
Ñ_intro
ªÑ vs[x,y,...] é t[x,y,...]º
…
ˆ Ö t[t1,t2,...]
…
ˆ Ö Ñ vs[x',y',...] é t[x,y,...]
=TEX
where ªvs[x,y,...]º is varstruct built from variables $ªxº$, $ªyº$, etc,
and the $ªx'º$ are renamed if duplicated inside the varstruct, all but the rightmost being so renamed.
=FAILURE
4020	?0 is not of form: ªÑ vs é tº
7047	?0 cannot be matched to conclusion of theorem ?1
=ENDDOC
=DOC
val ‚Ñ_elim· : TERM -> THM -> THM -> THM ;
=DESCRIBE
Eliminate an existential quantifier by reference to an arbitrary varstruct satisfying the predicate.
=RULE
Ñ_elim
ªvs[y1,y2,...]º
…
ˆ1 Ö Ñ vs[x1,x2,...] é t1[x1,x2,...]; 
ˆ2, t1[y1,y2,...] Ö t2
…
ˆ1 ° ˆ2 Ö t2
=TEX
$t1[y1,y2,...]$ need not actually be present in the assumptions of the second theorem.
The $y_i$ must be free variables, none of whom are present elsewhere in theorems.
The $y_i$ may contain duplicates as long as the end pattern
matches the $x_i$ in required duplicates.
The term argument may be a less complex variable structure
than the bound variable structure of the theorem,
as $Fst$ and $Snd$ are used to make them match.
For example, the following rule holds true:
=RULE
Ñ_elim
ªxº
…
ˆ1 Ö Ñ (p,q) é t1[p,q]; 
ˆ2, t1[Fst x, Snd x] Ö t2
…
ˆ1 ° ˆ2 Ö t2
=TEX

=FAILURE
27046	?0 is not of the form `ˆ Ö Ñ vs é t`
27010	?0 is not a varstruct
27042	?0 does not match the bound varstruct of ?1
=ENDDOC
=DOC
val ‚Ñ_uncurry_conv· : CONV;
=DESCRIBE
Convert a paired existentially quantified term into
simple universal quantifications of the same term.
=CONVERSION
Ñ_uncurry_conv
ªÑ vs[x,y,...] é f[x, y,...]º
…
…
Ö Ñ vs[x,y,...] é f[x,y,...] = Ñ x y ... é f[x,y,...]
=TEX
where $vs[x,y,...]$ is a variable structure with
variables $x,y,...$.
It may not be a simple variable.
=FAILURE
27047	?0 is not of the form: ªÑ (x,y) é fº
=ENDDOC
=DOC
val ‚all_Ñ_uncurry_conv· : CONV;
=DESCRIBE
Apply $Ñ\_uncurry\_conv$ (q.v) to the outer existential
quantifications of a term,
flattening those binders.
=CONVERSION
all_Ñ_uncurry_conv
ªÑ vs1[x1,y1,...] vs2[x2,y2,...] ... é f[x1,y1,...,x2,y2,...]º
…
…
ˆ Ö Ñ vs1[x,y,...] vs2[x,y,...] é f[x1,y1,...,x2,y2,...] 
	= Ñ x1 y1 ... x2 y2 ... é f[x1,y1,...,x2,y2,...]
=TEX
where the $vs[x,y,...]$ are variable structures
with variables $x,y,...$.
=FAILURE
27048	?0 is not of the form: ªÑ ... (x,y) ... é fº
=ENDDOC
=DOC
val ‚å_Ñ_conv· : CONV;
=DESCRIBE
Move $å$ into an $Ñ$ construct.
=RULE
å_Ñ_conv
ªå (Ñ x é t[x])º
…
…
Ö (å (Ñ x é t[x])) Ç É x é å t[x]
=TEX
This will work with any paired existential quantifier.
=FAILURE
27020	?0 is not of the form: ªå (Ñ x é t[x])º
	where ªxº is a varstruct
=ENDDOC
=DOC
val ‚Ñ_asm_rule· : TERM -> TERM -> THM -> THM;
=DESCRIBE
Existentially quantify an assumption (Left $Ñ$ introduction).
=RULE
Ñ_asm_rule
ªxº
ªp[x]º
…
ˆ, p'[x] Ö q
…
ˆ, Ñ x é p'[x] Ö q
=TEX
where $p$ and $p'$ are $\alpha$-convertible.
where the variables of the varstruct $x$ are not free in $ˆ$ or $q$.
=FAILURE
27010	?0 is not a varstruct
27032	?0 is not in assumption list
27033	?0 is free in conclusion of theorem
27034	?0 is free in of assumptions of theorem
=ENDDOC
This is from \cite{Manna74}.

=DOC
val ‚Ñ_reorder_conv· : TERM -> CONV;
=DESCRIBE
Reorder existential quantifications.
=RULE
Ñ_reorder_conv
ªÑ x1 .. xn é t1º
ªÑ y1 .. ym é t2º
…
…
(Ñ y1 .. ym é t2) Ç (Ñ x1 .. xn é t1)
=TEX
where the $x_i$ and $y_i$ are varstructs,
and the reordering and renaming requested is valid.
=FAILURE
27015	Cannot prove theorem with conclusion ?0
27030	?0 is not of type ª:BOOLº
=ENDDOC

We do not give a rule for $ÑÑ$ introduction from \cite{Manna74}.
\subsection{Concerning Ñ$_1$}
=DOC
val ‚Ñ%down%1_intro· : TERM -> THM -> THM -> THM;
=DESCRIBE
Introduce $Ñ_1$ by reference to a witness, and a uniqueness theorem.
=RULE
Ñ%down%1_intro
…
ˆ1 Ö P'[t']
ˆ2 Ö É x é P[x] ä x = t
…
ˆ1 ° ˆ2 Ö Ñ%down%1 x é P[x]
=TEX
Where $P'$ is $\alpha$-convertible to $P$, and
$t'$ is $\alpha$-convertible to $t$.
Notice that for the resulting theorem we take the varstruct, $x$, and the form of the predicate, $P$, from the second theorem.
=FAILURE
27021	?0 and ?1 are not of the form: `ˆ1 Ö Pa[ta]` and `ˆ2 Ö É x é P[x] ä x = t`
	where ªPaº and ªPº, ªtaº and ªtº are %alpha%-convertible
	and ªxº is a varstruct
=ENDDOC
=DOC
val ‚Ñ%down%1_elim· : THM -> THM;
=DESCRIBE
Express a $Ñ_1$ in terms of $Ñ$ and a uniqueness property.
=RULE
Ñ%down%1_elim
…
ˆ Ö Ñ%down%1 x é P[x]
…
ˆ Ö Ñ x é P[x] Ä É y é P[y] ä y = x
=TEX
=FAILURE
27022	?0 is not of the form: `ˆ Ö Ñ%down%1 x é P[x]`
	where ªxº is a varstruct
=ENDDOC
This could be rewritten to produce two theorems,
`$Ñ\ x\ é\ P[x]$` and `$É\ x\ y\ é\ P[x]\ Ä\ P[y]\ ä\ x\ =\ y$`
\subsection{Concerning á}
=DOC
val ‚cá_elim_rule· : TERM -> THM -> THM -> THM;
=DESCRIBE
Given that $á$ of a predicate satisfies that predicate, then
in a different theorem we may eliminate an assumption that
claims an otherwise unused variable structure satisfies the predicate.
=RULE
cá_elim_rule
ªvsº
…
ˆ1 Ö t' (á t'');
ˆ2, t vs Ö s
…
ˆ1 ° ˆ2 Ö s
=TEX
where $t$, $t'$ and $t''$ are $\alpha$-convertible, and 
$vs$ is a varstruct, with no duplicates, and with its free variables occurring nowhere else in the theorems
other than shown.
Actually $(á\ t'')$ can be any value, rather than a choice construct.
=FAILURE
27010	?0 is not a varstruct
6005	?0 occurs free in assumption list
7019	?0 is not of the form: `ˆ Ö t1(á t1)`
7054	?0 is not of same type as choice sub-term of first theorem
27043	?0 is repeated in the varstruct ?1
27044	?0 appears free in ?1
27045	Arguments ?0, ?1, ?2 not of the form ªvsº, `ˆ1 Ö t (á t)` and
	`ˆ2, (t vs) Ö s`
=ENDDOC
The above cannot handle duplicates within $vs$, because for instance a predicate on $(a,a)$ where $a$ is free is not the same as that predicate on $x$ where $x$ is free.
Renaming is not a sensible solution.
=DOC
val ‚Ñ_á_rule· : THM -> THM;
=DESCRIBE
Give that $á$ of a predicate satisfies the predicate by reference to an $Ñ$ construct.
It can properly handle paired existence.
=RULE
Ñ_á_rule
…
ˆ Ö Ñ x é p[x]
…
ˆ Ö p(á x é p x)
=TEX
=SEEALSO
$Ñ\_á\_conv$
=FAILURE
27024	?0 is not of the form: `ˆ Ö Ñ x é p[x]`
	where ªxº is a varstruct
=ENDDOC
=DOC
val ‚Ñ_á_conv· : CONV;
=DESCRIBE
Give that $á$ of a predicate satisfies the predicate by reference to an $Ñ$ construct.
It can properly handle paired existence.
=RULE
Ñ_á_conv
ªÑ x é p[x]º
…
…
ˆ Ö (Ñ x é p[x]) = p(á x é p x)
=TEX
=SEEALSO
$Ñ\_á\_rule$
=FAILURE
27024	?0 is not of the form: `ˆ Ö Ñ x é p[x]`
	where ªxº is a varstruct
=ENDDOC
\subsection{Concerning Local Definitions}
=DOC
val ‚let_intro_rule· : (string * TERM) -> THM -> THM;
=DESCRIBE
Introduce a local definition.
=RULE
let_intro_rule
[...,("xi", ªtiº),...]
…
ˆ Ö t[t1,...tn]
…
ˆ Ö let x1' = t1 and ... xn' = tn 
	in t2[x1',...,xn']
=TEX
where $x_i'$ in the result are variables with the names $x_i$, and with the type of $t_i$, perhaps made into variants to avoid variable capture.
=ENDDOC
Perhaps we should provide a template of what $t[...]$ should look like, so that not all instances of $t_i$ are changed to $x_i$.
Perhaps we should fail, rather than rename, if variable capture occurs.
=DOC
val ‚let_elim_rule· : THM -> THM;
=DESCRIBE
Eliminate an outermost $let\ldots and\ldots in\ldots$ construct.
=RULE
let_elim_rule
…
ˆ Ö let x1 = t1 and ... xn = tn 
	in t[x1,...,xn]
…
ˆ Ö t[t1,...,tn]
=TEX
=ENDDOC
=DOC
val ‚let_conv· : CONV;
=DESCRIBE
Eliminate an outermost $let\ldots and\ldots in\ldots$ construct.
=CONVERSION
let_elim_rule
ªlet v1 = t1 and ... vn = tn 
 in t[v1,...,vn]º
…
…
Ö (let v1 = t1 and ... vn = tn in 
	t[v1,...,vn]) 
	= t[t1,...,tn]
=TEX
=ENDDOC

\subsection{Concerning $Uncurry$}
I don't believe we need a rule for eliminating $Uncurry$,
and its introduction is mostly behind the scenes.
\subsection{Concerning Sets}
A much wider set of rules than the below could be given .
=DOC
val ‚enum_set_rule· : TERM -> TERM list -> THM;
=DESCRIBE
Give that something within an enumerated set is a member of that set.
=RULE
enum_set_rule
ªtiº
[ªt1º,...ªtnº]
…
…
Ö ti ù {t1,...,tn}
=TEX
where $ti$ is $\alpha$-convertible to one of $t1,\ldots,tn$.
=FAILURE
27026	?0 list may not be empty
27027	?0 and ?1 have differing types in term list
27028	?0 has different type to elements in term list
=ENDDOC
A speculative form of rule, but the functionality will be useful
when handling sets.
=DOC
val ‚set_rule· : TERM -> string -> THM -> THM;
=DESCRIBE
Given that $x$ satisfies a predicate $P$, show that $x$ is a member of the
set constructed from $P$.
=RULE
set_rule
ªxº
(v : string)
…
ˆ Ö P [x]
…
ˆ Ö x ù {v' | P[v']}
=TEX
where $v'$ is a variable with name $v$ (or a variant as necessary,
to avoid variable capture) and the type of $x$.
=ENDDOC
A speculative form of rule, but the functionality will be useful when handling sets.
Perhaps we should provide a template for $P$, to allow only 
some instances of $x$ to be ``captured''.
=ENDDOC
=DOC
val ‚taut_rule· : TERM -> THM;
=DESCRIBE
A tautology prover.
If its argument is a tautologically true term, 
or a universally quantified version of such a term, then the
function will return that term as a theorem.
=RULE
taut_rule
ªtº
…
…
Ö t
=TEX
=FAILURE
27030	?0 is not of type ª:BOOLº
27037	?0 is not tautologically true
=ENDDOC
This is not a conversion, but there are two conversions leading
from it:
=DOC
val ‚taut_conv· : CONV;
=DESCRIBE
A tautology prover.
If its argument is a tautologically true term, 
or a universally quantified version of such a term, then the
function will return a theorem that the term is equivalent to $T$.
=CONVERSION
taut_conv
ªtº
…
…
Ö t Ç T
=TEX
=FAILURE
27030	?0 is not of type ª:BOOLº
27037	?0 is not tautologically true
=ENDDOC
=DOC
val ‚taut_eq_conv· : TERM -> CONV;
=DESCRIBE
A tautology prover.
If its two boolean arguments are tautologically equal terms, then the
function will return a theorem that the terms are equal.
=CONVERSION
taut_eq_conv
ªt1º
ªt2º
…
…
Ö t2 Ç t1
=TEX
=FAILURE
27015	Cannot prove theorem with conclusion ?0
27030	?0 is not of type ª:BOOLº
=ENDDOC
\subsubsection{Conversionals}
=DOC
val ‚ç_C· : CONV -> CONV;
=DESCRIBE
Apply a conversion to the body of an abstraction:
=RULE
ç_C
(c : CONV)
ªç x é pº
…
…
Ö (ç x é p[x]) = (ç x é pa[x])
=TEX
where $c\ p[x]$ gives $`Ö p[x] = pa[x]`$.
=SEEALSO
$BINDER\_C$
=FAILURE
4002	?0 is not of form: ªç vs é tº
7104	Result of conversion, ?0, ill-formed
=FAILUREC
Also as the failure of the conversion.
=ENDDOC
=DOC
val ‚CBINDER_C· : CONV -> CONV;
=DESCRIBE
Apply a conversion to the body of a binder term:
=RULE
CBINDER_C
(c : CONV)
ªB x é pº
…
…
Ö (B x é p[x]) = (B x é pa[x])
=TEX
where $c\ p[x]$ gives $`Ö p[x] = pa[x]`$,
and $B$ is a binder.
=FAILURE
27035	?0 is not of the form: ªB x é p[x]º where ªBº is a binder
	and ªxº a varstruct
7104	Result of conversion, ?0, ill-formed
=FAILUREC
Also as the failure of the conversion.
=ENDDOC

\section{SUPPORTING THEORY}
\section{END OF THE SIGNATURE}
=SML
end; (* signature of DerivedRulesII *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

=IGN
open Sort;
fun sf {id = id1,text = text1} {id = id2,text = text2} = (
	if text1 <> text2
	then stringorder text1 text2
	else (id1 - id2)
);

sort sf (get_error_messages());
