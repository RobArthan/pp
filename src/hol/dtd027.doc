% dtd027.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design of Derived Rules of Inference II}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Derived Rules of Inference II}
\TPPref{DS/FMU/IED/DTD027}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for further 
derived rules of inference in ICL HOL,
in particular those concerned with paired abstractions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Fixed an error message.
\item [Issue 1.3]
Gained inference rules about sets.
\item [Issue 1.4]
Gained tautology material.
\item [Issue 1.5]
Changes with a view to implementation,
and to reflect changes in \cite{DS/FMU/IED/DTD007} issue 2.1.
\item [Issue 1.6]
Changes made during implementation.
\item [Issue 1.7]
Changed name of signature.
\item [Issue 1.8]
Changed $„_1\_elim$.
Added $„_1\_conv$, $varstruct\-\_variant$,
tidied up.
\item [Issue 1.9]
Clarified $ƒ\_reorder\_conv$ and $„\_reorder\_conv$
\end{description}
\subsection{Changes Forecast}
Rename $CBINDER\_C$ to $BINDER\_C$, and similar.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
derived rules of inference concerning paired abstractions.
This is called for in \cite{DS/FMU/IED/HLD012}.
The design is
implemented in \cite{DS/FMU/IED/IMP027}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
paired abstraction
derived rules of inference in Release 001 of ICL HOL.

The document provides groups of rules of inference, related by their core operator.

All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP027}.

\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.

This document places requirements upon the constants handled by the
inference rules discussed.
In summary, the requirements are that the definitions of the constants must be such that the designs of the rules are satisfiable.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Terminology}
We use ``varstruct'' or ``(allowed) variable structure (in ICL HOL syntax)'' to indicate terms that 
satisfy the concrete syntax rule for $V$  (see \cite{DS/FMU/IED/DEF001}),
i.e. the kind of terms that may be
bound in an abstraction.
They are formed from variables by pairing: a simple variable is one example of a ``varstruct''.
\section{THE DERIVED RULES OF REASONING}
=DOC
signature âDerivedRules2á = sig
=DESCRIBE
This provides the further derived rules of inference for ICL HOL.
They are primarily concerned with handling paired abstractions.
=ENDDOC
\subsection{Tools For Variable Structures}
=DOC
val âvarstruct_variantá : TERM list -> TERM -> TERM;
=DESCRIBE
$varstruct\_variant$ $avoid$ $vs$ will recreate the variable structure $vs$ using only names that are not found in the
$avoid$ list of variables, and also renaming to avoid
duplicate variable names in the structure.
Variant names are found using $string\_variant$ (q.v.).
If there are duplicates to be renamed, then the original
name will be the rightmost in the variable structure.
=FAILURE
3007	?0 is not a term variable
4016	?0 is not an allowed variable structure
=FAILUREC
Message 3007 applies to the avoid list, 27060 to the variable
structure.
=ENDDOC
\subsection{Concerning Š}
=DOC
val âŠ_match_mp_ruleá : THM -> THM -> THM ;
=DESCRIBE
A matching Modus Ponens rule for an implicative theorem.
=RULE
Š_match_mp_rule
É
ö1 … ƒ x1 ... Ž t1 Š t2; ö2 … t1'
É
ö1' ¡ ö2 … t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's antecedent to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.

This may be partially evaluated with only first argument.
=SEEALSO
$Š\_match\_mp\_rule1$, $Š\_elim$
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC
=DOC
val âŠ_match_mp_rule1á : THM -> THM -> THM ;
=DESCRIBE
A matching Modus Ponens rule for an implicative theorem.
=RULE
Š_match_mp_rule
É
ö1 … ƒ x1 ... Ž t1 Š t2; ö2 … t1'
É
ö1 ¡ ö2 … t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's antecedent to match the conclusion of the
second theorem, while not modifying the assumptions.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching,
but no change will be made that affects the assumptions.

This may be partially evaluated with only first argument.
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC
\subsection{Concerning ‚}
=DOC
val â‚_match_mp_ruleá : THM -> THM -> THM;
=DESCRIBE
A matching Modus Ponens for $‚$.
=RULE
‚_match_mp_rule
É
ö1 … ƒ x1 ... Ž t1 ‚ t2; ö2 … t1'
É
ö1' ¡ ö2 … t2'
=TEX
where we type instantiate, generalise and specialise
both conclusion and assumptions
to get the first theorem's LHS to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching.

This may be partially evaluated with only first argument.
=SEEALSO
$Š\_elim$ (Modus Ponens on $Š$),
$simple\_‚\_match\-\_mp\_rule$
$‚\-\_mp\-\_rule$
$‚\-\_match\-\_mp\-\_rule1$
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC
=DOC
val â‚_match_mp_rule1á : THM -> THM -> THM;
=DESCRIBE
A matching Modus Ponens for $‚$ that doesn't affect assumption lists.
=RULE
‚_match_mp_rule1
É
ö1 … ƒ x1 ... Ž t1 ‚ t2; ö2 … t1'
É
ö1 ¡ ö2 … t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's LHS to match the conclusion of the
second theorem.
Universal quantification, or the lack of it, in the first theorem makes no difference to the matching,
but no change will be made that affects the assumptions.

This may be partially evaluated with only first argument.
=SEEALSO
$Š\_elim$ (Modus Ponens on $Š$),
$simple\_‚\_match\_mp\_rule1$
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC

\subsection{Concerning =}
=DOC
val âeq_match_convá : THM -> CONV ;
=DESCRIBE
This matches the LHS of an equational theorem to a term,
instantiating the RHS accordingly.
The equational theorem may be partially or fully universally quantified
(simple or by varstruct),
without affecting the result of the conversion.
=CONVERSION
eq_match_conv
(ö … ƒ ... Ž u = v)
»t¼
É
É
ö … t = v'
=TEX
where $v'$ is the result of applying to $v$ the instantiation rules required to match $u$ to $t$
(including both term and type instantiation).
If there are free variables on the RHS of the supplied equational theorem (when stripped of all universal quantification)
they will be renamed as necessary to avoid identification with
any variables in $t$.

This conversion may be partially evaluated with only its theorem argument.
=SEEALSO
$eq\_match\_conv1$
=FAILURE
7044	Cannot match ?0 and ?1
=ENDDOC

=DOC
val âeq_match_conv1á : THM -> CONV ;
=DESCRIBE
This matches the LHS of an universally quantified (simple or by varstruct) equational theorem to a term,
instantiating the RHS accordingly.
The conversion will only instantiate its universal quantifications,
and type variables not found within the assumptions, not its free term variables.
=CONVERSION
eq_match_conv1
(ö … ƒ x1 ... xn Ž u[x1,...,xn] = 
   v[x1,...,xn])
»t¼
É
É
ö … t = v[t1,...,tn]
=TEX
where »u[t1,...,tn]¼ is $\alpha$-convertible to »t¼.
If there are free variables on the RHS of the supplied equational theorem (when stripped of all universal quantification)
they will be renamed as necessary to avoid identification with
any variables in $t$.

This conversion may be partially evaluated with only its theorem argument.
=USES
In producing a limited rewriting facility, that only instantiates
explicitly identified variables.
=FAILURE
27003	?0 is not of the form `ö … ƒ x1 ... xn Ž u = v`
	where »xi¼ are varstructs
7076	Could not match term ?0 to LHS of theorem ?1
=ENDDOC
\subsection{Concerning }
=DOC
val â%beta%_ruleá : THM -> THM;
=DESCRIBE
An elimination rule for $$, which can handle paired abstractions.
=RULE
%beta%_rule
É
ö … ( x Ž t[x]) y
É
ö … t[y]
=TEX
=SEEALSO
$beta\_conv$
=FAILURE
27007	?0 is not of the form: `ö … ( x Ž t[x]) y`
	where »x¼ is a varstruct
=ENDDOC
=DOC
val â%beta%_convá : CONV;
=DESCRIBE
Apply a $\beta$-reduction to an abstraction.
=RULE
%beta%_conv
»( x Ž t1[x])t2¼
É
É
… (( x Ž t[x])y) = t'[y]
=TEX
where $x$ may be any varstruct allowed by the ICL HOL syntax, 
$y$ is an instance of this structure,
and $t'$ is $\alpha$-convertible to $t$, changed to avoid variable capture.

When the bound variable structure has a pair,
where the value applied to does not, then $Fst$ and $Snd$ are
introduced as necessary, e.g.:
óExample
%beta%_conv »( (x,y) Ž f x y) p¼ =
	… ( (x,y) Ž f x y) p = f (Fst p) (Snd p)
æ 
=SEEALSO
$simple\_\beta\_conv$, $\beta\_rule$
=FAILURE
27008	?0 is not of the form: »( x Ž t1[x])t2¼
	where »x¼ is a varstruct
=ENDDOC
=DOC
val âall_%beta%_convá : CONV;
=DESCRIBE
A conversion to eliminate all instances of $\beta$ redexes,
including paired abstraction redexes, in a term, regardless of nesting, or even that the $\beta$ redex was created as the result of
an earlier reduction in the conversion's evaluation.
=RULE
all_%beta%_conv
»t¼
É
É
… t = t'
=TEX
$t'$ is $t$ with all $\beta$ redexes reduced.
=USES
This uses an optimised term traversal algorithm, superior in speed
to the general term traversal algorithms used with conversions,
and should be used in preference to them and $\beta\_conv$.
=SEEALSO
$all\_simple\_\beta\_conv$ which only handles simple
$\beta$-redexes, but does a faster traversal if that is all that is required.
$all\_\beta\_rule$.
=FAILURE
27049	?0 contains no %beta%-redexes
=ENDDOC
=DOC
val âall_%beta%_ruleá : THM -> THM;
=DESCRIBE
Eliminate all instances of $\beta$ redexes,
including paired abstraction redexes, in the conclusion of a theorem, regardless of nesting, or even that the $\beta$ redex was created as the result of
an earlier reduction in the rule's evaluation.
=RULE
all_%beta%_rule
É
ö … t
É
ö … t'
=TEX
$t'$ is $t$ with all $\beta$-redexes reduced.
=SEEALSO
$all\_\beta\_conv$ for the conversion.
$all\_simple\_\beta\_rule$ which only handles simple
$\beta$-redexes, but does a faster traversal if that is all that is required.
=FAILURE
27049	?0 contains no %beta%-redexes
=ENDDOC
=DOC
val â_eq_ruleá : TERM -> THM -> THM;
=DESCRIBE
Given an equational theorem, return the equation formed by abstracting the term argument (which must be an allowed variable structure) from both sides.
=RULE
_eq_rule
»x¼
É
ö … t1[x] = t2[x]
É
ö … ( x Ž t1[x]) = ( x Ž t2[x])
=TEX
=FAILURE
4016	?0 is not an allowed variable structure
6005	?0 occurs free in assumption list
6020	?0 is not of the form: `ö … t1 = t2`
=ENDDOC
=DOC
val â%eta%_convá : CONV;
=DESCRIBE
The rule for $\eta$ conversion.
=CONVERSION
%eta%_conv
» vs Ž t vs¼
É
É
… ( vs Ž t vs) = t
=TEX
where $t$ contains no free instances of the variables of varstruct $vs$.
=FAILURE
27018	?0 is not of the form: » vs Ž t vs'¼
	where »vs¼ is a varstruct
27023	?0 is not of the form: » vs Ž t vs¼ where »t¼ should not contain »vs¼
=ENDDOC
=DOC
val â_varstruct_convá : TERM -> CONV;
=DESCRIBE
This conversion allows one to change between any lambda abstracted varstruct
that has the same type.
=RULE
_varstruct_conv
» vs1[x1,y1,...] Ž t[x1,y1,...]¼
» vs2[x2,y2,...] Ž t'[x2,y2,...]¼
É
É
… ( vs2[x2,y2,...] Ž t[x2,y2,...]) =
	( vs1[x1,y1,...] Ž t'[x1,y1,...])
=TEX
Where the types of $vs1[x1,y1,...]$ and $vs2[x2,y2,...]$
are the same, and $t'$ and $t$ differ only in applications of $Fst$ and $Snd$ to the bound variables.
=SEEALSO
$\alpha\_conv$ for a more limited form of renaming.
=FAILURE
27050	Cannot prove equality of ?0 and ?1
=ENDDOC
This is implemented using two $\beta$-reductions, one for each term applied to the same machine-generated variable.
Worse, if a simple approach fails, it will attempt to pull $Fst$ and $Snd$ together by pure rewriting.
It is thus potentially not very fast.

\subsection{Concerning ƒ}
=DOC
val âƒ_uncurry_convá : CONV;
=DESCRIBE
Convert a paired universally quantified term into
simple universal quantifications of the same term.
=CONVERSION
ƒ_uncurry_conv
»ƒ vs[x,y,...] Ž f[x,y,...]¼
É
É
ö … ƒ vs[x,y,...] Ž f[x,y,...] = 
	ƒ x y ... Ž f[x,y,...]
=TEX
where $vs[x,y,...]$ is an allowed variable structure with
variables $x,y,...$.
It may not be a simple variable.
=SEEALSO
$\_varstruct\_conv$, $all\_ƒ\_uncurry\_conv$.
=FAILURE
27038	?0 is not of the form: »ƒ (x,y) Ž f¼
=ENDDOC
=DOC
val âall_ƒ_uncurry_convá : CONV;
=DESCRIBE
Apply $ƒ\_uncurry\_conv$ (q.v) to the outer universal
quantifications of a term,
flattening those binders.
=CONVERSION
all_ƒ_uncurry_conv
»ƒ vs1[x1,y1,...] vs2[x2,y2,...] ...Ž 
	f[x1,y1,...,x2,y2,...]¼
É
É
ö … (ƒ vs1[x,y,...] vs2[x,y,...] ...Ž 
	f[x1,y1,...,x2,y2,...])
 = (ƒ x1 y1 ... x2 y2 ... Ž 
	f[x1,y1,...,x2,y2,...])
=TEX
where the $vs_i[x_i,y_i,...]$ are variable structures
at least one of which must not be a simple variable,
built from variables $x_i,y_i,...$,
=FAILURE
27041	?0 is not of the form: »ƒ ... (x,y) ... Ž f¼
=ENDDOC
=DOC
val âƒ_introá : TERM -> THM -> THM;
=DESCRIBE
Introduce a universally quantified theorem.
=RULE
ƒ_intro
»x¼
É
ö … t
É
ö … ƒ x' Ž t
=TEX
Where $»x'¼$ is an allowed variable structure based on $»x¼$, but with
duplicate variables renamed, the original name being rightmost in the resulting variable structure.
=SEEALSO
$list\_ƒ\_intro$, $all\_ƒ\_intro$.
=FAILURE
4016	?0 is not an allowed variable structure
6005	?0 occurs free in assumption list
=ENDDOC
=DOC
val âƒ_elimá : TERM -> THM -> THM;
=DESCRIBE
Instantiate a universally quantified variable to a given value.
=RULE
ƒ_elim
»t1¼
É
ö … ƒ x Ž t2[x]
É
ö … t2'[t1]
=TEX
where $t2'$ is renamed from $t2$ to prevent bound variable capture,
and $x$ is a varstruct, instantiable to the structure of $t1$.
The term will be expanded using $Fst$ and $Snd$ as necessary to match
the structure of $»x¼$.
=SEEALSO
$list\_ƒ\_elim$, $all\_ƒ\_elim$.
=FAILURE
27011	?0 is not of the form: `ö … ƒ x Ž t` where »x¼ is a varstruct
27012	?0 is not of the form: `ö … ƒ x Ž t` where the type of »x¼ 
	is the type of ?1
=ENDDOC
=DOC
val âlist_ƒ_introá : TERM list -> THM -> THM;
=DESCRIBE
Generalised $ƒ$ introduction.
=RULE
list_ƒ_intro
[»x1¼, ..., »xn¼]
É
ö … t[x1, ..., xn]
É
ö … ƒ x1 ... xn Ž t[x1, ..., xn]
=TEX
=SEEALSO
$ƒ\_intro$, $all\_ƒ\_intro$.
=FAILUREC
\paragraph{Errors}
Same messages as $ƒ\_intro$.
=ENDDOC
=DOC
val âlist_ƒ_elimá : TERM list -> THM -> THM;
=DESCRIBE
Generalised $ƒ$ elimination.
=RULE
list_ƒ_elim
[»t1¼, ..., »tn¼]
É
ö … ƒ x1 ... xn Ž t[x1, ..., xn]
É
t[t1, ..., tn]
=TEX
=SEEALSO
$ƒ\_elim$, $all\_ƒ\_elim$.
=FAILUREC
\paragraph{Errors}
Same messages as $ƒ\_elim$.
=ENDDOC
=DOC
val âall_ƒ_elimá : THM -> THM;
=DESCRIBE
Specialises all the outer universal quantifications in a theorem:
=RULE
all_ƒ_elim
É
ö … ƒ x1 ... xn Ž t[x1, ..., xn]
É
ö … t[x1', ..., xn']
=TEX
where $x1', \ldots, xn'$ are renamed from $x1, \ldots, xn$ as necessary to avoid name clashes with
free variables in the assumption list.
=SEEALSO
$all\_ƒ\_arb\_elim$ which is faster, though the results are
slightly opaque.
$list\_ƒ\_elim$.
=ENDDOC
=DOC
val âŒ_ƒ_convá : CONV;
=DESCRIBE
Move $Œ$ into a $ƒ$ construct.
=RULE
Œ_ƒ_conv
»Œ (ƒ x Ž t[x])¼
É
É
… (Œ (ƒ x Ž t[x])) ‚ „ x Ž Œ t[x]
=TEX
=SEEALSO
$simple\_Œ\_ƒ\_conv$ which only works with simple $ƒ$-abstractions, $Œ\_„\_conv$
=FAILURE
27019	?0 not of the form: »Œ (ƒ x Ž t[x])¼
	where »x¼ is a varstruct
=ENDDOC
=DOC
val âƒ_‚_ruleá : TERM -> THM -> THM;
=DESCRIBE
Universally quantify a variable on both sides of an equivalence.
=RULE
ƒ_‚_rule
»x¼
É
ö … p[x] ‚ q[x]
É
ö … (ƒ x Ž p[x]) ‚ (ƒ x Ž q[x])
=TEX
where $x$ is a varstruct.
=FAILURE
6005	?0 occurs free in assumption list
6020	?0 is not of the form: `ö … t1 = t2`
7062	?0 is not of the form: `ö … t1 ‚ t2`
4016	?0 is not an allowed variable structure
=ENDDOC
=DOC
val âƒ_arb_elimá : THM -> THM;
=DESCRIBE
Specialise a universally quantified theorem with a machine generated variable or variable structure.
=RULE
ƒ_arb_elim
É
ö … ƒ vs[x,y,...] Ž p[x,y,...]
É
ö … p[x',y',...]
=TEX
where $x'$, $y'$, etc, are not variables (free or bound) in $p$ or $ö$,
created by $gen\_vars$(q.v).
=SEEALSO
$ƒ\_elim$
=FAILURE
27011	?0 is not of the form: `ö … ƒ x Ž t` where »x¼ is a varstruct
=ENDDOC
=DOC
val âall_ƒ_arb_elimá : THM -> THM;
=DESCRIBE
Specialise all the quantifiers of a possibly universally quantified theorem with a machine generated variables or variable structures.
=RULE
ƒ_arb_elim
É
ö … ƒ vs1[x1,y1,...] vs2[x2,y2,...] ... Ž 
	p[x1,y1,....x2,y2,...]
É
ö … p[x1',y1',...,x2',y2',...]
=TEX
where $x_i'$, $y_i'$, etc, are not variables (free or bound) in $p$ or $ö$,
created by $gen\_vars$(q.v).
=SEEALSO
$all\_ƒ\_elim$
=ENDDOC
The precise rules for the name formation of $x$ will not be given here.
=DOC
val âƒ_asm_ruleá : TERM -> TERM -> THM -> THM;
=DESCRIBE
Generalise an assumption (Left $ƒ$ introduction).
=RULE
ƒ_asm_rule
»x¼
»p[x]¼
É
ö, p'[x] … q[x]
É
ö, ƒ x Ž p'[x] … q[x]
=TEX
where $p$ and $p'$ are $\alpha$-convertible.
$x$ {\bf may} be free in $ö$.
The function will work even if $p'[x]$ is not present
in the assumption list.
=FAILURE
4016	?0 is not an allowed variable structure
=ENDDOC
This is from \cite{Manna74}.
=DOC
val âƒ_reorder_convá : TERM -> CONV;
=DESCRIBE
Reorder universal quantifications.
=RULE
ƒ_reorder_conv
»ƒ x1 .. xn Ž t1¼
»ƒ y1 .. ym Ž t2¼
É
É
(ƒ y1 .. ym Ž t2) ‚ (ƒ x1 .. xn Ž t1)
=TEX
where the $x_i$ and $y_i$ are varstructs,
and the reordering, restructuring (by pairing) and renaming requested is provable by this function.
The presence of redundant quantifiers, including duplicates, is also handled.
=EXAMPLE
:> ƒ_reorder_conv »ƒ (x,q) z Ž x € z¼ »ƒ (z,z,y) x Ž x € z¼;
val it = … (ƒ (z, z, y) xŽ x € z) ‚ (ƒ (x, q) zŽ x € z) : THM
=SEEALSO
$„\_reorder\_conv$
=FAILURE
27050	Cannot prove equality of ?0 and ?1
=ENDDOC

We do not give a rule for $ƒƒ$ introduction from \cite{Manna74}.
\subsection{Concerning „}
=DOC
val âv_„_introá : TERM -> THM -> THM ;
=DESCRIBE
Introduce an existential quantified variable structure into a theorem.
=RULE
v_„_intro
»vs[x,y,...]¼
É
ö … t[x,y,...]
É
ö … „ vs[x,y,...] Ž t[x,y,...]
=TEX
where »vs[x,y,...]¼ is a varstruct built from variables $»x¼$, $»y¼$, etc, which may contain duplicates.
=USES
If the functionality is sufficient, this is superior
in efficiency to both $„\_intro$ and $simple\_„\_intro$ (q.v.).
=FAILURE
4016	?0 is not an allowed variable structure
=ENDDOC
=DOC
val â„_introá : TERM -> THM -> THM ;
=DESCRIBE
Introduce an existential quantifier by reference to a witness.
=RULE
„_intro
»„ vs[x,y,...] Ž t[x,y,...]¼
É
ö … t[t1,t2,...]
É
ö … „ vs[x',y',...] Ž t[x,y,...]
=TEX
where »vs[x,y,...]¼ is varstruct built from variables $»x¼$, $»y¼$, etc,
and the $»x'¼$ are renamed if duplicated inside the varstruct, all but the rightmost being so renamed.
=FAILURE
4020	?0 is not of form: »„ vs Ž t¼
7047	?0 cannot be matched to conclusion of theorem ?1
=ENDDOC
=DOC
val â„_elimá : TERM -> THM -> THM -> THM;
=DESCRIBE
Eliminate an existential quantifier by reference to an arbitrary varstruct satisfying the predicate.
=RULE
„_elim
»vs[y1,y2,...]¼
É
ö1 … „ vs[x1,x2,...] Ž t1[x1,x2,...]; 
ö2, t1[y1,y2,...] … t2
É
ö1 ¡ ö2 … t2
=TEX
$t1[y1,y2,...]$ need not actually be present in the assumptions of the second theorem.
The $y_i$ must be free variables, none of whom are present elsewhere in the second theorem, or in the conclusion
of the first.
The $y_i$ may contain duplicates as long as the end pattern
matches the $x_i$ in required duplicates.
The term argument may be a less complex variable structure
than the bound variable structure of the theorem,
as $Fst$ and $Snd$ are used to make them match.
For example, the following rule holds true:
=RULE
„_elim
»x¼
É
ö1 … „ (p,q) Ž t1[p,q]; 
ö2, t1[Fst x, Snd x] … t2
É
ö1 ¡ ö2 … t2
=TEX

=FAILURE
27042	?0 does not match the bound varstruct of ?1
27046	?0 is not of the form `ö … „ vs Ž t`
27051	?0 has members appearing free in conclusion of ?1
27052	?0 has members appearing free in ?1 other than in assumption ?2
=ENDDOC
=DOC
val â„_uncurry_convá : CONV;
=DESCRIBE
Convert a paired existentially quantified term into
simple universal quantifications of the same term.
=CONVERSION
„_uncurry_conv
»„ vs[x,y,...] Ž f[x, y,...]¼
É
É
… „ vs[x,y,...] Ž f[x,y,...] = 
	„ x y ... Ž f[x,y,...]
=TEX
where $vs[x,y,...]$ is an allowed variable structure with
variables $x,y,...$.
It may not be a simple variable.
=SEEALSO
$\_varstruct\_conv$, $all\_„\_uncurry\_conv$, $ƒ\_uncurry\_conv$.
=FAILURE
27047	?0 is not of the form: »„ (x,y) Ž f¼
=ENDDOC
=DOC
val âall_„_uncurry_convá : CONV;
=DESCRIBE
Apply $„\_uncurry\_conv$ (q.v) to the outer existential
quantifications of a term,
flattening those binders.
=CONVERSION
all_„_uncurry_conv
»„ vs1[x1,y1,...] vs2[x2,y2,...] ...Ž 
 f[x1,y1,...,x2,y2,...]¼
É
É
ö … („ vs1[x,y,...] vs2[x,y,...]Ž 
	f[x1,y1,...,x2,y2,...])
 = („ x1 y1 ... x2 y2 ...Ž 
	f[x1,y1,...,x2,y2,...])
=TEX
where the $vs[x,y,...]$ are variable structures
with variables $x,y,...$, at least one of which must not be a simple variable.
=SEEALSO
$all\_ƒ\_uncurry\_conv$
=FAILURE
27048	?0 is not of the form: »„ ... (x,y) ... Ž f¼
=ENDDOC
=DOC
val âŒ_„_convá : CONV;
=DESCRIBE
Move $Œ$ into an $„$ construct.
=RULE
Œ_„_conv
»Œ („ x Ž t[x])¼
É
É
… (Œ („ x Ž t[x])) ‚ ƒ x Ž Œ t[x]
=TEX
=SEEALSO
$simple\_Œ\_„\_conv$ which only works with simple $„$-abstractions, $Œ\_ƒ\_conv$
=FAILURE
27020	?0 is not of the form: »Œ („ x Ž t[x])¼
	where »x¼ is a varstruct
=ENDDOC
=DOC
val â„_asm_ruleá : TERM -> TERM -> THM -> THM;
=DESCRIBE
Existentially quantify an assumption (Left $„$ introduction).
=RULE
„_asm_rule
»x¼
»p[x]¼
É
ö, p'[x] … q
É
ö, „ x Ž p'[x] … q
=TEX
where $p$ and $p'$ are $\alpha$-convertible.
where the variables of the varstruct $x$ are not free in $ö$ or $q$.
The assumption need not be present for the rule to apply.
=FAILURE
3015	?1 is not of type »:BOOL¼
4016	?0 is not an allowed variable structure
6005	?0 occurs free in assumption list
27052	?0 has members appearing free in ?1 other than in assumption ?2
=FAILUREC
Message 3015 is just passed on from low level functions,
which is why it has "?1" not "?0".
=ENDDOC
This is from \cite{Manna74}.

=DOC
val â„_reorder_convá : TERM -> CONV;
=DESCRIBE
Reorder existential quantifications.
=RULE
„_reorder_conv
»„ x1 .. xn Ž t1¼
»„ y1 .. ym Ž t2¼
É
É
(„ y1 .. ym Ž t2) ‚ („ x1 .. xn Ž t1)
=TEX
where the $x_i$ and $y_i$ are varstructs,
and the reordering, restructuring (by pairing) and renaming requested is provable by this function.
The presence of redundant quantifiers, including duplicates, is also handled.
=EXAMPLE
:> „_reorder_conv »„ (x,q) z Ž x € z¼ »„ (z,z,y) x Ž x € z¼;
val it = … („ (z, z, y) xŽ x € z) ‚ („ (x, q) zŽ x € z) : THM
=SEEALSO
$ƒ\_reorder\_conv$
=FAILURE
27050	Cannot prove equality of ?0 and ?1
=ENDDOC

We do not give a rule for $„„$ introduction from \cite{Manna74}.
\subsection{Concerning „$_1$}
=DOC
val â„%down%1_introá : THM -> THM -> THM;
=DESCRIBE
Introduce $„_1$ by reference to a witness, and a uniqueness theorem.
=RULE
„%down%1_intro
É
ö1 … P'[t']
ö2 … ƒ x Ž P[x] Š x = t
É
ö1 ¡ ö2 … „%down%1 x Ž P[x]
=TEX
Where $P'$ is $\alpha$-convertible to $P$, and
$t'$ is $\alpha$-convertible to $t$.
Notice that for the resulting theorem we take the varstruct, $x$,
and the form of the predicate, $P$, from the second theorem.
=FAILURE
27021	?0 and ?1 are not of the form: `ö1 … Pa[ta]` and 
	`ö2 … ƒ vs[x,y,..] Ž P[x,y...] Š vs[x,y,..] = t`
	where »Pa¼ and »P¼, »ta¼ and »t¼ are %alpha%-convertible
	and »x¼ is a varstruct
27054	?0 not of the form: `ö … ƒ vs[x,y,..] Ž P[x,y...] Š vs[x,y,..] = t`
=ENDDOC
=DOC
val â„%down%1_elimá : THM -> THM;
=DESCRIBE
Express a $„_1$ in terms of $„$ and a uniqueness property.
=RULE
„%down%1_elim
É
ö … „%down%1 vs[a,b,...] Ž P[a,b,...]
É
ö … „ vs[a,b,...] Ž P[a,b,...] € 
	ƒ vs[a',b',...] Ž P[x1,x2,...]
 Š 
	vs[a',b',...] = vs[a,b,...]
=TEX
where the $a'$, etc, are variants of the $a$.
=FAILURE
27022	?0 is not of the form: `ö … „%down%1 x Ž P[x]`
	where »x¼ is a varstruct
=ENDDOC
This could be rewritten to produce two theorems,
$`„\ x\ Ž\ P[x]`$ and $`ƒ\ x\ y\ Ž\ P[x]\ €\ P[y]\ Š\ x\ =\ y`$
=DOC
val â„%down%1_convá : CONV;
=DESCRIBE
This is a conversion which turns a unique existential quantifier into
an equivalent existential quantifier
=CONVERSION
„%down%1_conv
»„%down%1vs[x1,...]Žt[x1,...]¼
É
É
… („%down%1vs[x1,...]Žt[x1,...]) ‚ 
	(„vs[x1,...]Žt[x1,...] € 
	ƒvs[x1',...]Žt[x1',...] Š 
	vs[x1',...] = vs[x1,...])
=TEX
=USES
Tactic and conversion programming.
=SEEALSO
$strip\_tac$, $simple\_„_1\_conv$
=FAILURE
27053	?0 is not of the form: »„%down%1vsŽt¼
=ENDDOC
\subsection{Concerning ‡}
=DOC
val âc‡_elim_ruleá : TERM -> THM -> THM -> THM;
=DESCRIBE
Given that $‡$ of a predicate satisfies that predicate, then
in a different theorem we may eliminate an assumption that
claims an otherwise unused variable structure satisfies the predicate.
=RULE
c‡_elim_rule
»vs¼
É
ö1 … t' (‡ t'');
ö2, t vs … s
É
ö1 ¡ ö2 … s
=TEX
where $t$, $t'$ and $t''$ are $\alpha$-convertible, and 
$vs$ is a varstruct, with no duplicates, and with its free variables
occurring nowhere else in the second theorem, or in the conclusion
of the first.
Actually $(‡\ t'')$ can be any value, rather than a choice construct.
=FAILURE
4016	?0 is not an allowed variable structure
7019	?0 is not of the form: `ö … t1(‡ t1)`
7054	?0 is not of same type as choice sub-term of first theorem
27043	?0 is repeated in the varstruct ?1
27045	Arguments ?0; ?1 and ?2 not of the form »vs¼; `ö1 … t (‡ t)` and
	`ö2, (t vs) … s`
27051	?0 has members appearing free in conclusion of ?1
27052	?0 has members appearing free in ?1 other than in assumption ?2
=ENDDOC
The above cannot handle duplicates within $vs$, because for instance a predicate on $(a,a)$ 
where $a$ is free is not the same as that predicate on $x$ where $x$ is free.
Renaming is not a sensible solution.
=DOC
val â„_‡_ruleá : THM -> THM;
=DESCRIBE
Give that $‡$ of a predicate satisfies the predicate by reference to an $„$ construct.
It can properly handle paired existence.
=RULE
„_‡_rule
É
ö … „ x Ž p[x]
É
ö … p[‡ x Ž p x]
=TEX
If $x$ is formed by paired then the $Fst$ and $Snd$ are used to extract the appropriate bits of the ‡-term 
for distribution in $p[‡\ x\ Ž\ p\ x]$.
=SEEALSO
$„\_‡\_conv$
=FAILURE
27024	?0 is not of the form: `ö … „ x Ž p[x]`
	where »x¼ is a varstruct
=ENDDOC
=DOC
val â„_‡_convá : CONV;
=DESCRIBE
Give that $‡$ of a predicate satisfies the predicate by reference to an $„$ construct.
It can properly handle paired existence.
=RULE
„_‡_conv
»„ x Ž p[x]¼
É
É
ö … („ x Ž p[x]) = p(‡ x Ž p x)
=TEX
If $x$ is formed by paired then the $Fst$ and $Snd$ are used to extract the appropriate bits of the ‡-term 
for distribution in $p[‡\ x\ Ž\ p\ x]$.
=SEEALSO
$„\_‡\_rule$
=FAILURE
27024	?0 is not of the form: `ö … „ x Ž p[x]`
	where »x¼ is a varstruct
=ENDDOC
\subsection{Concerning Local Definitions}
=DOC
val âlet_convá : CONV;
=DESCRIBE
Eliminate an outermost $let\ldots and\ldots in\ldots$ construct.
=CONVERSION
let_conv
»let vs1[x1,y1,..] = 
 t1 and ... vsn[xn,yn,..] = tn 
 in t[x1,...,xn,...]¼
É
É
… (let vs1[x1,y1,..] = t1 
 and ... and vsn[xn,yn,..] = tn 
 in t[x1,...,xn,...] 
	= t[t1x,...,t1y,...,tnx,tny,...]
=TEX
Where the $t_ix$ is the component of $t_i$ matching $x_i$
when $t_i$ matches $vs_i[x_i,y_i,..]$.
=FAILURE
4009	?0 is not of form: »let ... in ...¼
=ENDDOC

\subsection{Concerning $Uncurry$}
I don't believe we need a rule for eliminating $Uncurry$,
and its introduction is mostly behind the scenes.

\subsection{Concerning Sets}
A much wider set of rules than the below could be given.
=DOC
val â_convá : CONV;
=DESCRIBE
A conversion for set membership.
It can handle variable structures bound by the set comprehension.
=CONVERSION
_conv
»t  {v[x,y,...] | p[x,y,...]}¼
É
É
… t  {vs[x,y,...] | p[x,y,...]} ‚ p[x1,y1,...]
=TEX
where $x1$, $y1$, etc, are the appropriate components of
$t$, extracted via $Fst$ and $Snd$.
=SEEALSO
$simple\_\_conv$
=FAILURE
27002	?0 is not of form:»x  {v | p[v]}¼
=ENDDOC
=DOC
val âenum_set_ruleá : TERM -> TERM list -> THM;
=DESCRIBE
Give that something within an enumerated set is a member of that set.
=RULE
enum_set_rule
»ti¼
[»t1¼,...»tn¼]
É
É
… ti  {t1,...,tn}
=TEX
where $ti$ is $\alpha$-convertible to one of $t1,\ldots,tn$.
=FAILURE
3012	?0 and ?1 do not have the same types
27001	?0 not a member of list of terms
=FAILUREC
Message 3012 occurs when the term list cannot be made into
an enumerated set because of differing types.
=ENDDOC
\subsection{Conversionals}
=DOC
val â_Cá : CONV -> CONV;
=DESCRIBE
Apply a conversion to the body of an abstraction:
=RULE
_C
(c : CONV)
» x Ž p¼
É
É
… ( x Ž p[x]) = ( x Ž pa[x])
=TEX
where $c\ p[x]$ gives $`… p[x] = pa[x]`$.
=FAILURE
4002	?0 is not of form: » vs Ž t¼
7104	Result of conversion, ?0, ill-formed
=FAILUREC
Also as the failure of the conversion.
=ENDDOC
=DOC
val âCBINDER_Cá : CONV -> CONV;
=DESCRIBE
Apply a conversion to the body of a binder term:
=RULE
CBINDER_C
(c : CONV)
»B x Ž p¼
É
É
… (B x Ž p[x]) = (B x Ž pa[x])
=TEX
where $c\ p[x]$ gives $`… p[x] = pa[x]`$,
and $B$ is a binder.
=FAILURE
27035	?0 is not of the form: »B x Ž p[x]¼ where »B¼ is a binder
	and »x¼ a varstruct
7104	Result of conversion, ?0, ill-formed
=FAILUREC
Also as the failure of the conversion.
=ENDDOC
This will later be renamed to $BINDER\-\_C$, and the current $BINDER\-\_C$ renamed to $SIMPLE\-\_BINDER\_C$.
\section{END OF THE SIGNATURE}
=SML
end; (* signature of DerivedRules2 *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

=IGN
open Sort;
fun sf {id = id1,text = text1} {id = id2,text = text2} = (
	if text1 <> text2
	then stringorder text1 text2
	else (id1 - id2)
);
sort sf (get_error_messages());

sort (fn x => fn y => x - y) (map (fn {id=id,...} => id)( get_error_messages()));
