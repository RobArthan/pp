=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
\TPPtitle{Detailed Design for the Theory of Lists}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the \cr
Theory of Lists}
\TPPref{DS/FMU/IED/DTD039}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{D.J. King & WIN01}  %% Mandatory field
%\TPPauthors{R.D. Arthan & WIN01\\K. Blackburn & WIN01}
\TPPauthorisation{R.D. Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
theory ``list''.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1 - 1.3]
Initial drafts.
\item[Issie 1.4 22 November 1991]
Draft for review.

\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design
for the theory ``list'',
called for in \cite{DS/FMU/IED/HLD011}.
The design is implemented in \cite{DS/FMU/IED/IMP039}.

\subsection{Introduction}

This document introduces design for the aggregation of
information into a sequence. The type $LIST$ is
introduced. The concrete representation of a list
is a pair, the first element denoting a function which
given a number will return the nth item in the list; the
second element is a number denoting the length of the
list. The defining properties of a list are that there
is a list which has length zero, namely $Nil$, and that
there is a function $Cons$ which is the list constructor with
the defining properties that:
\begin{itemize}
\item
a constructed list will never be empty and
\item
the constructor function is one to one and
\item
recursion can be applied to all lists.
\end{itemize}
The concrete representation of lists is used for introducing
the new type. No further use is made of it in this document
or is likely to be used in subsequent documents.
\subsubsection{Purpose and Background}
This document contains the detailed design for the theory ``list''.
This defines the type $LIST$, and the operators upon it.
\subsubsection{Dependencies}
This document depends on \cite{DS/FMU/IED/IMP038},
and the theory design tools of \cite{DS/FMU/IED/DTD035}.
\subsubsection{Deficiencies}
None.
\subsubsection{Possible Enhancements}
None known.
\section{THE THEORY CONTENTS}
\subsection{Theory Name}

The theory name is that specified in \cite{DS/FMU/IED/HLD011}
for the theory of lists.
=THDOC
req_name "list" (Value "†");
=DESCRIBE
The theory ``âlistá'' defines a type of lists,
operations on lists,
and some associated theories and tactics.
=ENDDOC
\subsection{Basic Definitions}
=THDOC
req_const("IsListRep",»:((†‹'a)‰†)‹BOOL¼);
req_defn("IsListRep", ([], »
	„ nil:(†‹'a)‰†Ž„ cons:'a‹((†‹'a)‰†)‹((†‹'a)‰†) Ž
	(IsListRep nil) €
	(ƒxŽIsListRep x
		Š (ƒh:'aŽŒcons h x = nil)) €
	(ƒx yŽIsListRep x € IsListRep y
		Š (ƒa bŽ cons a x = cons b y
			‚ (a=b € x=y))) €
	(ƒxŽIsListRep x
		Š (ƒh:'aŽIsListRep (cons h x))) €

	(ƒp:((†‹'a)‰†)‹BOOL Ž p nil €
		(ƒmŽ p m Š (ƒhŽ p (cons h m)))
			Š (ƒnŽ IsListRep n Š p n))
¼));
=DESCRIBE
The representation type of lists, as given by
$âIsListRepá$ is a function from the concrete type for
lists onto BOOL.
The representation type for lists is a pair: the first
element is a function which given a number, $n$ yields
the ``nth'' element of the list; the second is the length of
the list. The defining properties of lists are encapsulated
in the predicate of the definition. This concrete
representation is only useful for introducing the type
of lists, and no use of it is envisaged elsewhere.
=ENDDOC

=THDOC
req_type("LIST",1);
req_defn("LIST",([],»„ f:'a LIST‹((†‹'a)‰†)Ž TypeDefn IsListRep f¼));
=DESCRIBE
The type of lists, $â'a LISTá$ is given by the representation
function $IsListRep$, and is useful for representing
sequences of objects with some arbitrary type.
=ENDDOC

=THDOC
req_const("Nil",»:'a LIST¼);
req_const("Cons",»:'a ‹ 'a LIST ‹ 'a LIST¼);
list_req_defn(["Nil","Cons"], ([],
»	(ƒ x : 'a; list:'a LIST Ž ŒCons x list = Nil) €
	(ƒ x1 x2 : 'a; list1 list2 : 'a LIST Ž
		Cons x1 list1 = Cons x2 list2
			‚ (x1=x2 € list1=list2)) €
	(ƒp:'a LIST‹BOOL Ž p Nil €
		(ƒlist:'a LISTŽ p list Š (ƒxŽ p (Cons x list)))
			Š (ƒlistŽ p list))
¼));
=DESCRIBE
The HOL constant $âNilá$ is the empty list.
The HOL constant $âConsá$ is the list contructor, taking
an element and attaching it to the front of a list.
=ENDDOC

\subsection{Definitions of Operations on Lists}
=THDOC
req_const("Length",»:'a LIST‹†¼);
req_defn("Length", ([], »
	Length (Nil:'a LIST) = 0 €
	ƒ h:'a; list:'a LISTŽ
		Length (Cons h list) = Length list + 1¼));
=DESCRIBE
$Length$ returns the length of a list.
=ENDDOC

=THDOC
req_const("Hd",»:'a LIST‹'a¼);
req_defn("Hd", ([], »
	ƒh:'a; list:'a LISTŽ Hd (Cons h list) = h¼));
=DESCRIBE
The loosely defined function
$Hd$ returns the first element of a list. 
=ENDDOC

=THDOC
req_const("Tl",»:'a LIST‹'a LIST¼);
req_defn("Tl", ([], »
	ƒh:'a; list:'a LISTŽ Tl (Cons h list) = list¼));
=DESCRIBE
$Tl$ returns the list after the first element has
been removed.
=ENDDOC

=THDOC
req_const("Append",»:'a LIST‹'a LIST‹'a LIST¼);
req_defn("Append", ([], »
	(ƒlist:'a LISTŽ Append Nil list = list) €
	(ƒh:'a; list:'a LIST; list':'a LISTŽ
	  Append (Cons h list) list' = Cons h (Append list list'))¼));
req_alias ("@", »Append¼);
req_infix (300, "@");
=DESCRIBE
$Append$ joins one list to another. The infix form is
the ``@'' symbol, similar to the Standard ML list
conjunction.
=ENDDOC

=THDOC
req_const("Rev",»:'a LIST‹'a LIST¼);
req_defn("Rev", ([], »
	Rev (Nil:'a LIST) = Nil €
	ƒ h:'a; list:'a LISTŽ
		Rev (Cons h list) = Append (Rev list) [h]¼));
=DESCRIBE
$Rev$ reverses the order of elements in a list.
=ENDDOC

=THDOC
req_const("Map",»:('a‹'b)‹'a LIST‹'b LIST¼);
req_defn("Map", ([], »
	(ƒg:'a‹'bŽ Map g Nil = Nil) €
	(ƒh:'a; g:'a‹'b; list:'a LISTŽ
	  Map g (Cons h list) = Cons (g h) (Map g list))¼));
=DESCRIBE
$Map(f,\  list)$ applies $f$ to each of the elements
of $list$ producing a list of results.
=ENDDOC

=THDOC
req_const("Fold",»:('a‹'b‹'b)‹'a LIST‹'b‹'b¼);
req_defn("Fold", ([], »
	(ƒg:'a‹'b‹'b; x:'bŽ Fold g Nil x = x) €
	(ƒh:'a; g:'a‹'b‹'b; x:'b; list:'a LISTŽ
		Fold g (Cons h list) x = g h (Fold g list x))¼));
=DESCRIBE
$Fold(f,\  list, x)$ applies the function f to each of the
elements of $list$ folding in the result.
=ENDDOC

=THDOC
req_const("Split",»:('a‰'b)LIST‹('a LIST‰'b LIST)¼);
req_defn("Split", ([], »
	Split (Nil:('a‰'b)LIST) = (Nil,Nil) €
	(ƒ list:('a‰'b) LIST; h1:'a; h2:'bŽ
	 Split (Cons (h1,h2) list) =
		(Cons h1 (Fst(Split list)),
			Cons h2 (Snd(Split list))))¼));
=DESCRIBE
$Split$ splits a list of pairs into a pair of lists
(of equal length).
=ENDDOC

=THDOC
req_const("Combine",»:'a LIST‹'b LIST‹('a‰'b)LIST¼);
req_defn("Combine", ([], »
	Combine (Nil:'a LIST) (Nil:'b LIST) = Nil €
	(ƒ h1:'a; h2:'b; list1:'a LIST; list2:'b LISTŽ
		Combine (Cons h1 list1) (Cons h2 list2) =
		Cons (h1,h2) (Combine list1 list2))¼));
=DESCRIBE
The loosely defined function $Combine$ takes a pair
of equal length lists and yields a list of pairs -- the
opposite of $Split$.
=ENDDOC

\subsection{Theorems}
=THDOC
req_thm("list_induction_thm", ([], »
	ƒp:'a LIST‹BOOL Ž p Nil €
		(ƒlist:'a LISTŽ p list Š (ƒxŽ p (Cons x list)))
			Š (ƒlistŽ p list)¼));
=DESCRIBE
This defines induction for lists. If $p$ is true for
an empty list, and if $p$ being true for $list$ implies
that it is true for $list$ prefixed with some element, then
$p$ is true for any list.
=ENDDOC
=THDOC
req_thm("list_prim_rec_thm", ([], »
	ƒn:'bŽƒc:'a‹'b‹'a LIST‹'bŽ „%down%1f:'a LIST‹'bŽ
		f Nil = n
	€	ƒlist:'a LISTŽƒa:'aŽ
			f(Cons a list) = c a (f list) list¼));
=DESCRIBE
This is the principle of primitive recursion for lists.
=ENDDOC
=THDOC
req_thm("list_clauses", ([], »
	ƒ x1 x2 list1 list2Ž
	Œ Cons x1 list1 = [] €
	Œ [] = Cons x1 list1 €
	(Cons x1 list1 = Cons x2 list2
		‚ x1 = x2 € list1 = list2) €
	Hd (Cons x1 list1) = x1 €
	Tl (Cons x1 list1) = list1
¼));
=DESCRIBE
This theorem gives rules for simplifying lists, expressed
as rewrite rules. 
=ENDDOC
=THDOC
req_thm("list_cases_thm", ([], »
	ƒ list1Ž list1 = [] 
	„ x list2Ž list1 = Cons x list2¼));
=DESCRIBE
Any list is either empty, or can be expressed as
a construction of an element to some list.
=ENDDOC


\section{THE SIGNATURE}
=DOC
signature âListá = sig
=DESCRIBE
This is the signature in which the theory ``list'' is declared.
=ENDDOC

\subsection{Definitions}
=DOC
	val ânil_cons_defá : THM
	val âlength_defá : THM
	val âhd_defá : THM
	val âtl_defá  : THM
	val âappend_defá : THM
	val âmap_defá : THM
	val âfold_defá : THM
	val âsplit_defá : THM
	val âcombine_defá : THM
	val ârev_defá : THM
=DESCRIBE
These Standard ML variables are bound to the definitions
in the theory ``list''.
=ENDDOC

\subsection{Theorems}
=DOC
	val âlist_clausesá : THM
	val âlist_cases_thmá : THM
	val âlist_induction_thmá : THM
	val âlist_prim_rec_thmá : THM
=DESCRIBE
These Standard ML variables are bound to the theorems
in the theory ``list''.
=ENDDOC

\subsection{Tactics}
=DOC
	val âlist_induction_tacá : TERM -> TACTIC
=DESCRIBE
This tactic implements induction over lists :
to prove $t[x]$ it suffices to prove $t[Nil]$ and to prove $t[Cons\  h\  x]$ on the
assumption that $t[x]$. The term argument must
appear free in the conclusion of the
goal but not in its assumptions.
=TACTIC
list_induction_tac »x¼
É
{ ö } t[x] 
É
{ ö } t[Nil] ; strip{t[x], ö} t[Cons h x]
=TEX
=SEEALSO
$LIST\_INDUCTION\_T$
=FAILURE
39001	?0 is not a term variable
39002	?0 does not appear free in the conclusion of the goal
39003	?0 appears free in the assumptions of the goal
=ENDDOC
=DOC
val âLIST_INDUCTION_Tá : TERM -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
This implements induction over lists as
a tactical. The term argument must appear free in the conclusion of the
goal but not in its assumptions.
The inductive hypothesis is passed to the tactic generating function
given by the second argument.
=TACTIC
LIST_INDUCTION_T »x¼ ttac
É
{ ö } t[x] 
É
{ ö } t[Nil] ; ttac(t[x] … t[x])({ ö } t[Cons h x])
=TEX
=USES
Most commonly used with $asm\_tac$ to avoid the stripping up of
the inductive hypothesis which occurs with $list\_induction\_tac$.
=SEEALSO
$list\_induction\_tac$
=FAILURE
39001	?0 is not a term variable
39002	?0 does not appear free in the conclusion of the goal
39003	?0 appears free in the assumptions of the goal
=ENDDOC

=SML
end (* of signature List *);
=TEX

\section{TEST POLICY}
The functions in this document should be tested according to the
general criteria list out in \cite{DS/FMU/IED/PLN008}, using the
tests in \cite{DS/FMU/IED/MDT039}.
The theories produced should be checked by the theory design tools
of \cite{DS/FMU/IED/DTD035}, against the theory design provided.
=TEX

\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
