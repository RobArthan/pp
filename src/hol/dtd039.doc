=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
\TPPtitle{Detailed Design for the Theory of Lists}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the \cr
Theory of Lists}
\TPPref{DS/FMU/IED/DTD039}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{D.J. King & WIN01}  %% Mandatory field
%\TPPauthors{R.D. Arthan & WIN01\\K. Blackburn & WIN01}
\TPPauthorisation{R.D. Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
theory ``list''.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First issue.
\end{description}
\subsection{Changes Forecast}
Populating theory with more theorems.

\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design
for the theory ``list'',
called for in \cite{DS/FMU/IED/HLD011}.
The design is implemented in \cite{DS/FMU/IED/IMP039}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the detailed design for the theory ``list''.
This defines the type $LIST$, and the operators upon it.

\subsubsection{Dependencies}
This document depends on \cite{DS/FMU/IED/IMP038},
and the theory design tools of \cite{DS/FMU/IED/DTD035}.
\subsubsection{Deficiencies}
None.
\subsubsection{Possible Enhancements}
The theory is missing some already obvious theorem
members, and it may be appropriate to add others 
as development and application work progresses.
There should also be some tactics and inference rules.

\section{THE THEORY ``list''}

\subsection{Design of the Theory ``list''}

=THDOC
req_name "list" (Value "Ü");
=DESCRIBE
The theory ``‚list·'' defines a type of lists, operators upon the type,
and some associated theories.
=ENDDOC

=THDOC
req_const("IsListRep",ª:((Üã'a)âÜ)ãBOOLº);
req_defn("IsListRep", ([], ª
	Ñ nil:(Üã'a)âÜéÑ cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ) é
	(IsListRep nil) Ä
	(ÉxéIsListRep x
		ä (Éh:'aéåcons h x = nil)) Ä
	(Éx yéIsListRep x Ä IsListRep y
		ä (Éa bé cons a x = cons b y
			Ç (a=b Ä x=y))) Ä
	(ÉxéIsListRep x
		ä (Éh:'aéIsListRep (cons h x))) Ä

	(Ép:((Üã'a)âÜ)ãBOOL é p nil Ä
		(Émé p m ä (Éhé p (cons h m)))
			ä (Éné IsListRep n ä p n))
º));
=DESCRIBE
The representation type of lists, as given by
$‚IsListRep·$ is a function from
the representation type for lists comprising
a function, number pair onto BOOL.
=ENDDOC
The first of the pair is a function
which given a number $n$ returns the $n$th item in the
list. The second of the pair is a number representing the
length of the list.
Its definition is saved under the key ``‚IsListRep·''.

=THDOC
req_type("LIST",1);
req_defn("LIST",([],ªÑ f:'a LISTã((Üã'a)âÜ)é TypeDefn IsListRep fº));
=DESCRIBE
The type of lists, $‚LIST·$ is given by the representation
function $IsListRep$.
=ENDDOC

=THDOC
req_const("Nil",ª:'a LISTº);
req_const("Cons",ª:'a ã 'a LIST ã 'a LISTº);
list_req_defn(["Nil","Cons"], ([],
ª	(É x : 'a; list:'a LIST é åCons x list = Nil) Ä
	(É x1 x2 : 'a; list1 list2 : 'a LIST é
		Cons x1 list1 = Cons x2 list2
			Ç (x1=x2 Ä list1=list2)) Ä
	(Ép:'a LISTãBOOL é p Nil Ä
		(Élist:'a LISTé p list ä (Éxé p (Cons x list)))
			ä (Élisté p list))
º));
=DESCRIBE
The HOL constant $‚Nil·$ is the empty list.
The HOL constant $‚Cons·$ is the list contruction function. It
takes an element and attaches it to the front of a list.
=ENDDOC

=THDOC
req_thm("list_induction_thm", ([], ª
	Ép:'a LISTãBOOL é p Nil Ä
		(Élist:'a LISTé p list ä (Éxé p (Cons x list)))
			ä (Élisté p list)º));
=DESCRIBE
=ENDDOC

=THDOC
req_thm("list_prim_rec_thm", ([], ª
	Én:'béÉc:'aã'bã'a LISTã'bé Ñ%down%1f:'a LISTã'bé
		f Nil = n
	Ä	Élist:'a LISTéÉa:'aé
			f(Cons a list) = c a (f list) listº));
=DESCRIBE
=ENDDOC
\subsection{Functions for Use with Lists}

=THDOC
req_const("Length",ª:'a LISTãÜº);
req_defn("Length", ([], ª
	Length (Nil:'a LIST) = 0 Ä
	É h:'a; list:'a LISTé
		Length (Cons h list) = Length list + 1º));
=DESCRIBE
=ENDDOC

=THDOC
req_const("Hd",ª:'a LISTã'aº);
req_defn("Hd", ([], ª
	Éh:'a; list:'a LISTé Hd (Cons h list) = hº));
=DESCRIBE
=ENDDOC

=THDOC
req_const("Tl",ª:'a LISTã'a LISTº);
req_defn("Tl", ([], ª
	Éh:'a; list:'a LISTé Tl (Cons h list) = listº));
=DESCRIBE
=ENDDOC

=THDOC
req_const("Append",ª:'a LISTã'a LISTã'a LISTº);
req_defn("Append", ([], ª
	(Élist:'a LISTé Append Nil list = list) Ä
	(Éh:'a; list:'a LIST; list':'a LISTé
	  Append (Cons h list) list' = Cons h (Append list list'))º));
req_alias ("@", ªAppendº);
req_infix (300, "@");
=DESCRIBE
=ENDDOC

=THDOC
req_const("Map",ª:('aã'b)ã'a LISTã'b LISTº);
req_defn("Map", ([], ª
	(Ég:'aã'bé Map g Nil = Nil) Ä
	(Éh:'a; g:'aã'b; list:'a LISTé
	  Map g (Cons h list) = Cons (g h) (Map g list))º));
=DESCRIBE
=ENDDOC

=THDOC
req_const("Fold",ª:('aã'bã'b)ã'a LISTã'bã'bº);
req_defn("Fold", ([], ª
	(Ég:'aã'bã'b; x:'bé Fold g Nil x = x) Ä
	(Éh:'a; g:'aã'bã'b; x:'b; list:'a LISTé
		Fold g (Cons h list) x = g h (Fold g list x))º));
=DESCRIBE
=ENDDOC

=THDOC
req_const("Split",ª:('aâ'b)LISTã('a LISTâ'b LIST)º);
req_defn("Split", ([], ª
	Split (Nil:('aâ'b)LIST) = (Nil,Nil) Ä
	(É list:('aâ'b) LIST; h1:'a; h2:'bé
	 Split (Cons (h1,h2) list) =
		(Cons h1 (Fst(Split list)),
			Cons h2 (Snd(Split list))))º));
=DESCRIBE
=ENDDOC

=THDOC
req_const("Combine",ª:'a LISTã'b LISTã('aâ'b)LISTº);
req_defn("Combine", ([], ª
	Combine (Nil:'a LIST) (Nil:'b LIST) = Nil Ä
	(É h1:'a; h2:'b; list1:'a LIST; list2:'b LISTé
		Combine (Cons h1 list1) (Cons h2 list2) =
		Cons (h1,h2) (Combine list1 list2))º));
=DESCRIBE
=ENDDOC

=THDOC
req_const("Rev",ª:'a LISTã'a LISTº);
req_defn("Rev", ([], ª
	Rev (Nil:'a LIST) = Nil Ä
	É h:'a; list:'a LISTé
		Rev (Cons h list) = Append (Rev list) [h]º));
=DESCRIBE
=ENDDOC

=THDOC
req_thm("list_clauses", ([], ª
	É x1 x2 list1 list2é
	å Cons x1 list1 = [] Ä
	å [] = Cons x1 list1 Ä
	(Cons x1 list1 = Cons x2 list2
		Ç x1 = x2 Ä list1 = list2) Ä
	Hd (Cons x1 list1) = x1 Ä
	Tl (Cons x1 list1) = list1
º));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("list_cases_thm", ([], ª
	É list1é list1 = [] Å
	Ñ x list2é list1 = Cons x list2º));
=DESCRIBE
=ENDDOC


\subsection{Signature of the theory ``list''}
=DOC
signature ‚ListTheory· = sig
=DESCRIBE
This is the signature in which we declare theory ``list''.
=ENDDOC

=DOC
	val ‚nil_cons_def· : THM
=DESCRIBE
=IGN
Ö (É x listé å Cons x list = []) Ä
  (É x1 x2 list1 list2é Cons x1 list1 = Cons x2 list2 Ç x1 = x2 Ä list1 =
  list2) Ä
  (É pé p [] Ä (É listé p list ä (É xé p (Cons x list))) ä (É listé p list))
=ENDDOC

=DOC
	val ‚list_clauses· : THM
=DESCRIBE
=ENDDOC

=DOC
	val ‚list_cases_thm· : THM
=DESCRIBE
=ENDDOC

=DOC
	val ‚list_induction_thm· : THM
=DESCRIBE
=IGN
Ö É pé p [] Ä (É listé p list ä (É xé p (Cons x list)))
			ä (É listé p list)
=ENDDOC

=DOC
	val ‚list_induction_tac· : TERM -> TACTIC
=DESCRIBE
=ENDDOC

=DOC
	val ‚list_prim_rec_thm· : THM
=DESCRIBE
=IGN
Ö É n cé Ñ„1 fé f [] = n Ä
  (É list aé f (Cons a list) = c a (f list) list)
=ENDDOC

=DOC
	val ‚length_def· : THM
	val ‚hd_def· : THM
	val ‚tl_def·  : THM
	val ‚append_def· : THM
	val ‚map_def· : THM
	val ‚fold_def· : THM
	val ‚split_def· : THM
	val ‚combine_def· : THM
	val ‚rev_def· : THM
end;
=ENDDOC
=TEX
\section{TEST POLICY}
The functions in this document should be tested according to the
general criteria list out in \cite{DS/FMU/IED/PLN008}, using the
tests in \cite{DS/FMU/IED/MDT039}.
The theories produced should be checked by the theory design tools
of \cite{DS/FMU/IED/DTD035}, against the theory design provided.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
