=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for the Abstract Data Type $THM$}  %% Mandatory field
\def\TPPheadtitle{Module Tests for the Interface \cr to the Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/MDT012}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}
%\TPPstatus{Approved}
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the 
the abstract data type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1 to 1.18]
First draft, leading up to desk check report ID0082, and responses.
\item [Issue 2.1 (27 September 1991)]
Approved version of issue 1.18.
\item [Issue 2.2]
Changed so that it works properly in batch mode, but
$delete\_...$ errors will go wrong interactively.

\item[Issue 2.3, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 2.4 (23rd January 1992)]
$new\_axiom$, $simple\_new\_type\_defn$, $new\_type\_defn$
all changed to take lists of keys, rather than single ones.
\item [Issue 2.5 (8th April 1992)]
Changes required by CR0016.
\item [Issue  (14th April 1992)]
Changes required by CR0017.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the the Abstract Data Type $THM$, required by Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The design is in \cite{DS/FMU/IED/DTD012}
and it is
implemented in \cite{DS/FMU/IED/IMP012}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD012},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.
It uses the test harness material of \cite{DS/FMU/IED/DTD013}
where appropriate.

In addition to the error messages explicitly mentioned in 
\cite{DS/FMU/IED/DTD012} we also test for some of the errors
that may arise from their underlying functions.
These include messages 6013, 6014, 6015, 6036 and 6038.
\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD012},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP012}.
It requires a HOL prettyprinter to be installed before
it will successfully match the output of some error tests
with the required output.
\subsubsection{Deficiencies}
None known, except as detailed in section \ref{untested}.
\section{UTILITIES}
We do not wish to fail on warning messages (for the
most part):
=SML
set_flag("ignore_warnings",true);
=TEX
Initialise the test package:
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results();
=TEX
We want to test in the context of empty theories,
and at least the icl'Kernel so:
=SML
open_theory "min";
map (fn x => delete_theory x 
	handle (Fail _) => ()) (theory_names());
map (fn x => delete_theory x 
	handle (Fail _) => ()) (theory_names());
delete_type "≠" handle (Fail _) => (); 
=TEX
N.B. theories used in this document become read-only ancestors,
and so cannot be deleted by the above.

We provide a list of diagnostic printing functions. 
Those called $string\_of\_\ldots$ turn objects of various significant types ($TERM$, $THM$, etc)
into strings,
those called $print\_\ldots$ apply $diag\_string$ to the output
of the associated $string\_of\_\ldots$.
=SML
local
	fun simple_print_dest_term (App(t1,t2)) = (
	"App (" ^ simple_print_dest_term(dest_simple_term t1) ^", " ^
		simple_print_dest_term(dest_simple_term t2) ^ ")"
) | simple_print_dest_term (Const(s,ty)) = s ^ string_of_type ty
| simple_print_dest_term (Var(s,ty)) = s ^ string_of_type ty
| simple_print_dest_term (SimpleÃ(v,b)) = (
	let val (vs,vt) = dest_var v
	in
	"Ã " ^ vs ^ string_of_type vt ^ " ∑ " ^ simple_print_dest_term (dest_simple_term b)
	end);
in

fun €string_of_term1› (tm : TERM) = simple_print_dest_term (dest_simple_term tm);
end;
=TEX
The following tests, by side effect, $get\-\_parents$, $get\-\_children$, $get\-\_theory\-\_status$, $get\-\_types$, $get\-\_consts$, $get\-\_thms$, $get\-\_defns$, and $get\-\_axioms$.
=SML
local
	val I = Combinators.I;
in
fun €string_of_thy› (nm : string) : string = (
	"\nName: " ^ (if nm = "-"
		then get_current_theory_name ()
		else nm) ^ ", " ^ 
	(case (get_theory_status nm) of
	TSNormal => "Status: Normal, "
	| TSDeleted => "Status: Deleted, "
	| TSLocked => "Status: Locked, "
	| TSAncestor => "Status: Ancestor, ") ^ "\n" ^
	"Parents: " ^ format_list I (get_parents nm) ", "  ^
	"; Children: " ^ format_list I (get_children nm) ", " ^ 
	"\n" ^
	format_list I (
	["***Types***"] @
	map string_of_type (get_types nm) @
	["***Constants***"] @
	map string_of_term1 (get_consts nm) @
	["***Theorems***"] @
	(map (fn (nl,thm) => format_list I nl ", " ^ ":" ^ string_of_thm thm)
		(get_thms nm)) @
	["***Definitions***"] @
	(map (fn (nl,thm) => format_list I nl ", " ^ ":" ^ string_of_thm thm)
		(get_defns nm)) @
	["***Axioms***"] @
	(map (fn (nl,thm) => format_list I nl ", " ^ ":" ^ string_of_thm thm)
		(get_axioms nm))) "\n");
end;

fun €print_thy› (nm : string) : unit = diag_line(string_of_thy nm);

fun €print_all_thy› (():unit) : unit = (
	map print_thy (theory_names());
	()
);
=TEX
=SML
fun list_eq (eq:'a * 'a -> bool) ((a :: x), (b :: y)) : bool = (
	eq(a,b) andalso list_eq eq (x, y)
) | list_eq eq ([], []) = true
| list_eq _ _ = false;
=TEX
=SML
infix 3 =**$;
infix 3 =**:;
infix 3 =*$;
infix 3 =*#;
infix 3 =*:;
=TEX
=SML
fun (a,b) =**$ (c,d) = (a =$ c) andalso (b =$ d);
fun  (a,b) =**: (c,d) = (a =: c) andalso (b =: d);
fun (a,b) =*$ (c,d) = (a = c) andalso (b =$ d);
fun (a,b) =*: (c,d) = (a = c) andalso (b =: d);
fun (a,b) =*# (c,d) = (a = c) andalso (b =# d);
=TEX
\section{VALUE BINDINGS}
=SML
val v1 = mk_var("v1", BOOL);
val v2 = mk_var("v2", BOOL);
val tv1 = mk_vartype "'tv1";
val tva = mk_vartype "'a";
val tv'1 = mk_vartype "'1";
val tv'2 = mk_vartype "'2";
val vtv1 = mk_var("vtv1",tv1);
val v1 = mk_var("v1", BOOL);
val v2 = mk_var("v2", BOOL);
val N0 = mk_Ó 0;
val N1 = mk_Ó 1;
val N2 = mk_Ó 2;
val N3 = mk_Ó 3;
val N7 = mk_Ó 7;
val pB = mk_var("p",BOOL);
val qB = mk_var("q",BOOL);
val xB = mk_var("x",BOOL);
val p1 = mk_var("p",tv'1);
val q1 = mk_var("q",tv'1);
val pa = mk_var("p",tva);
val qa = mk_var("q",tva);
val qa' = mk_var("q'",tva);
val p11 = mk_var("p1",tv'1);
val q1B = mk_var("q1",BOOL);
val pa = mk_var("p",tva);
val thm1 = icl'Kernel.icl'list_simple_µ_elim [v1]
	(icl'Kernel.icl'asm_rule(mk_simple_µ(v2,v2)));
val h_thm1 = [mk_simple_µ(v2,v2)];
val c_thm1 = v1;
val thm2 = icl'Kernel.icl'asm_rule v1;
val h_thm2 = [v1];
val c_thm2 = v1;
val thm3 = icl'Kernel.icl'asm_rule v2;
val h_thm3 = [v2];
val c_thm3 = v2;
val pB_thm = icl'Kernel.icl'asm_rule pB;
=TEX
$≈$ is not declared as a new constant.
=SML
val ill_formed_thm = icl'Kernel.icl'asm_rule (mk_≈(v1,v1));
=TEX
\section{THE TESTS}
\subsection{Kernel State Change Notifiers}
The following material tests $on\_kernel\_state\_change$ and $before\-\_kernel\-\_state\-\_change$,
by defining a notifier function, $tell\_ksc$,
and then requesting that it be called before and on every state change.

Put in a kernel state change notifier that prints a message:
=SML
local val I = Combinators.I;
in
fun €tell_ksc› (caller : string) ((OpenTheory (ot,(intos,outofs))) 
	: KERNEL_STATE_CHANGE) : unit = (
	diag_string(caller ^ "OpenTheory:" ^ ot ^"((" ^
		format_list I intos ", " ^"),("^
		format_list I outofs ", " ^"))")
) | tell_ksc caller (DeleteTheory thy) = (
	diag_string(caller ^ "DeleteTheory:"^thy)
) | tell_ksc caller (NewTheory thy) = (
	diag_string(caller ^ "NewTheory:"^thy)
) | tell_ksc caller (NewParent (thy, intos)) = (
	diag_string(caller ^ "NewParent:" ^ thy ^"(" ^
		format_list I intos ", " ^")")
) |tell_ksc caller (LockTheory thy) = (
	diag_string(caller ^ "LockTheory:"^thy)
) | tell_ksc caller (UnlockTheory thy) = (
	diag_string(caller ^ "UnlockTheory:"^thy)
) | tell_ksc caller (DuplicateTheory (thy1,thy2)) = (
	diag_string(caller ^ "DuplicateTheory:"^thy1^" , "^thy2)
) | tell_ksc caller (SaveThm (key,thm)) = (
	diag_string(caller ^ "SaveThm:"^key^":"^string_of_thm thm)
) | tell_ksc caller (ListSaveThm (keys,thm)) = (
	diag_string(caller ^ "ListSaveThm:"^
		format_list I keys ", " ^":"^string_of_thm thm)
) | tell_ksc caller (DeleteConst tm) = (
	diag_string(caller ^ "DeleteConst:"^string_of_term1 tm)
) | tell_ksc caller (DeleteType ty) = (
	diag_string(caller ^ "DeleteType:"^ty)
) | tell_ksc caller (DeleteAxiom ty) = (
	diag_string(caller ^ "DeleteAxiom:"^ty)
) | tell_ksc caller (DeleteThm nm) = (
	diag_string(caller ^ "DeleteThm:"^nm)
) | tell_ksc caller (NewConst (nm,ty)) = (
	diag_string(caller ^ "NewConst:"^nm^":"^string_of_type ty)
) | tell_ksc caller (NewType (nm,ar)) = (
	diag_string(caller ^ "NewType:"^nm^":"^string_of_int ar)
) | tell_ksc caller (SimpleNewDefn((keys, cnm,tm),thm)) = (
	diag_string(caller ^ "SimpleNewDefn:"^
		(format_list (Combinators.I) keys ", ")^":"^cnm^":"^string_of_term tm^
		":" ^ string_of_thm thm)
) | tell_ksc caller (NewTypeDefn((keys, tnm,typars,dthm),thm)) = (
	diag_string(caller ^ "NewTypeDefn:"^
		(format_list (Combinators.I) keys ", ")^":"^tnm^":"^
		format_list I typars ", " ^
		":" ^ string_of_thm thm)
) | tell_ksc caller (NewSpecification((keys, n, dthm),thm)) = (
	diag_string(caller ^ "NewSpecification:"^
		format_list I keys ", " ^
		":" ^ string_of_int n^ ":" ^string_of_thm dthm ^
		":" ^ string_of_thm thm)
) | tell_ksc caller (NewAxiom((keys, tm),thm)) = (
	diag_string(caller ^ "NewAxiom:"^
		(format_list (Combinators.I) keys ", ")^":"^string_of_term tm^
		":" ^ string_of_thm thm)
) | tell_ksc caller (SetUserDatum (nm,ud)) = (
	diag_string(caller ^ "SetUserDatum:"^nm)
);
end;

on_kernel_state_change (tell_ksc "OnKSC:" );
before_kernel_state_change (tell_ksc "BeforeKSC:");
=TEX
We rely on visual inspection of the results to check the 
correct functioning of these notifiers.
\subsection{Initialisation of Theories}
We consider that the successful operation of $open\_theory$ and $new\_theory$ are tested implicitly through out the tests.
Our initial hierarchy of (empty) theories:
=SML
print_all_thy ();
store_mt_results mt_run [("get_current_theory_name 1",
	get_current_theory_name,
	(),
	"min")];
new_theory "next";
store_mt_results mt_run [("get_current_theory_name 2",
	get_current_theory_name,
	(),
	"next")];
print_thy "-";
open_theory "min";
new_theory "another";
open_theory "next";
new_theory "yet_again";
store_mt_results mt_run_fail [("new_theory 6040",
	new_theory,
	"yet_again",
	gen_fail_msg "new_theory" 6040 ["yet_again"])];
open_theory "next";

print_all_thy ();
store_mt_results mt_run [("theory_names",
	theory_names,
	(),
	["yet_again","another","next","min"])];
=TEX
The tests proper:
=SML
store_mt_results mt_run_fail [
	("open_theory 6035",
	open_theory,
	"rubbish",
	gen_fail_msg "open_theory" 6035 ["rubbish"])
	];
store_mt_results (mt_runf (list_eq(op =$))) [("asms 1",
	asms,
	thm1,
	h_thm1),
	("asms 2",
	asms,
	icl'Kernel.icl'refl_conv mk_t,
	[])];
store_mt_results (mt_runf (op =$)) [("concl 1",
	concl,
	thm1,
	v1),
	("concl 2",
	concl,
	icl'Kernel.icl'refl_conv mk_t,
	mk_§(mk_t,mk_t))];
store_mt_results (mt_runf (op =:)) [("new_type 1",
	new_type,
	("BOOL",0),
	BOOL),
	("new_type 2",
	new_type,
	("Ó",0),
	Ó),
	("new_type 3",
	new_type,
	("≠",2),
	mk_≠_type(tv'1, tv'2))];
declare_infix (100, "≠");
print_thy("next");
store_mt_results mt_run_fail [
	("new_type 6045 a",
	new_type,
	("Ó",0),
	gen_fail_msg "new_type" 6045 ["Ó"]),
	("new_type 6088",
	new_type,
	("RUBBISH",~1),
	gen_fail_msg "new_type" 6088 [])
	];
store_mt_results (mt_runf (op =$)) [
	("new_const 6",
	new_const,
	("µ",mk_≠_type(mk_≠_type(tv'1,BOOL),BOOL)),
	mk_const(("µ",mk_≠_type(mk_≠_type(tv'1,BOOL),BOOL)))),
	("new_const 7",
	new_const,
	("∂",mk_≠_type(mk_≠_type(tv'1,BOOL),BOOL)),
	mk_const(("∂",mk_≠_type(mk_≠_type(tv'1,BOOL),BOOL))))
	];
declare_binder "µ";
declare_terminator "µ" handle _ => ();
declare_binder "∂";
declare_terminator "∂" handle _ => ();

val µ_spec = new_axiom(["µ_spec"],mk_∂(mk_var("µ",BOOL),mk_µ(v1,v1)));
store_mt_results mt_run_fail [
	("new_const 6049 e",
	new_const,
	("µ",mk_≠_type(mk_≠_type(tv'1,BOOL),BOOL)),
	gen_fail_msg "new_const" 6049 ["µ"]),
	("new_const 6013",
	new_const,
	("Rubbish",mk_ctype("RUBBISH",[])),
	gen_fail_msg "new_const" 6013 ["¨:RUBBISHÆ","RUBBISH"]),
	("new_const 6014",
	new_const,
	("Rubbish",mk_ctype("BOOL",[BOOL])),
	gen_fail_msg "new_const" 6014 ["¨:BOOL BOOLÆ","BOOL"])	];
store_mt_results mt_run_fail [
	("simple_new_defn 6049 a",
	simple_new_defn,
	(["µ_def"],"µ",mk_t),
	gen_fail_msg "simple_new_defn" 6049 ["µ"])
	];
store_mt_results mt_run_fail [
	("new_spec 6049 a",
	new_spec,
	(["µ"],1,µ_spec),
	gen_fail_msg "new_spec" 6049 ["µ"])
	];

store_mt_results (mt_runf (op =#)) [
	("list_save_thm 1",
	dest_thm o list_save_thm,
	(["thm1"], thm1),
	(h_thm1,c_thm1)),
	("list_save_thm 2",
	dest_thm o list_save_thm,
	(["thm1a","thm1b"], thm1),
	(h_thm1,c_thm1))
	];
store_mt_results (mt_runf (list_eq(op =*#))) [
	("get_thms 1",
	map (Combinators.I ** dest_thm) o get_thms,
	"-",
	[(["thm1a","thm1b","thm1"],(h_thm1,c_thm1))])
	];
store_mt_results mt_run_fail [
	("list_save_thm 6031",
	list_save_thm,
	([], thm2),
	gen_fail_msg "list_save_thm" 6031 []),
	("list_save_thm 6013",
	list_save_thm,
	(["n2"], icl'Kernel.icl'refl_conv (mk_var("rv",mk_ctype("rubbish",[])))),
	gen_fail_msg "list_save_thm" 6013 ["Ù rv = rv","rubbish"]),
	("list_save_thm 6014",
	list_save_thm,
	(["n2"], icl'Kernel.icl'refl_conv (mk_var("rv",mk_ctype("BOOL",[BOOL])))),
	gen_fail_msg "list_save_thm" 6014 ["Ù rv = rv","BOOL"]),
	("list_save_thm 6015",
	list_save_thm,
	(["n2"], icl'Kernel.icl'asm_rule (mk_const("rv",BOOL))),
	gen_fail_msg "list_save_thm" 6015 ["rv Ù rv","rv"]),
	("list_save_thm 6038",
	list_save_thm,
	(["n2"], icl'Kernel.icl'asm_rule (mk_const("1",BOOL))),
	gen_fail_msg "list_save_thm" 6038 ["1 Ù 1","1"]),
	("list_save_thm 6039 a",
	list_save_thm,
	(["thm1"], thm2),
	gen_fail_msg "list_save_thm" 6039 ["thm1","next"]),
	("list_save_thm 6039 b",
	list_save_thm,
	(["thm2","thm1","thm2a"], thm2),
	gen_fail_msg "list_save_thm" 6039 ["thm1","next"])
	];
store_mt_results mt_run_fail [
	("save_thm 6039",
	save_thm,
	("thm1", thm2),
	gen_fail_msg "save_thm" 6039 ["thm1","next"])];
store_mt_results (mt_runf (op =#)) [
	("list_save_thm 3",
	dest_thm o list_save_thm,
	(["thm2a","thm2b"], thm2),
	(h_thm2,c_thm2))
	];
store_mt_results (mt_runf (list_eq(op =*#))) [
	("get_thms 2",
	map (Combinators.I ** dest_thm) o get_thms,
	"-",
	[(["thm2a","thm2b"],(h_thm2,c_thm2)),
	(["thm1a","thm1b","thm1"],(h_thm1,c_thm1))])
	];
store_mt_results (mt_runf (op =#)) [
	("save_thm",
	dest_thm o save_thm,
	("thm3", thm3),
	(h_thm3,c_thm3))
	];
=TEX
Test out a theory in which BOOL is not defined.
=SML
open_theory "another";
store_mt_results mt_run_fail [
	("list_save_thm 6013 b",
	list_save_thm,
	(["thm2"], thm2),
	gen_fail_msg "list_save_thm" 6013 ["v1 Ù v1","BOOL"])
	];
store_mt_results mt_run_fail [
	("save_thm 6013 c",
	save_thm,
	("thm2", thm2),
	gen_fail_msg "save_thm" 6013 ["v1 Ù v1","BOOL"])
	];
=TEX
Test for reaction to things already defined in the descendants.
=SML
open_theory "min";
store_mt_results mt_run_fail [
	("new_type 6034",
	new_type,
	("≠",2),
	gen_fail_msg "new_type" 6034 ["≠"])
	];
store_mt_results mt_run_fail [
	("new_const 6063",
	new_const,
	("µ",tv'1),
	gen_fail_msg "new_const" 6063 ["µ"])
	];
store_mt_results mt_run_fail [
	("new_type_defn 6034",
	new_type_defn,
	(["≠_def"],"≠",[],thm1),
	gen_fail_msg "new_type_defn" 6034 ["≠"])
	];
store_mt_results mt_run_fail [
	("simple_new_defn 6063",
	simple_new_defn,
	(["µ_def"],"µ",mk_t),
	gen_fail_msg "simple_new_defn" 6063 ["µ"])
	];
=TEX
Unfortunately for our testing $new\_spec$ requires a valid theorem, so:
=SML
open_theory "yet_again";
new_const ("test_spec",BOOL);
open_theory "next";
val test_spec_ax = new_axiom(["test_spec_ax"],mk_∂(mk_var("test_spec",BOOL),mk_µ(v1,v1)));
store_mt_results mt_run_fail [
	("new_spec 6063",
	new_spec,
	(["test_spec_def"],1,test_spec_ax),
	gen_fail_msg "new_spec" 6063 ["test_spec"])
	];
=TEX
Now test reaction to presence in ancestors:
=SML
open_theory "yet_again";
store_mt_results mt_run_fail [
	("new_type 6045 c",
	new_type,
	("≠",2),
	gen_fail_msg "new_type" 6045 ["≠"])
	];
store_mt_results mt_run_fail [
	("new_const 6049 c",
	new_const,
	("µ",tv'1),
	gen_fail_msg "new_const" 6049 ["µ"])
	];
store_mt_results mt_run_fail [
	("new_type_defn 6045 c",
	new_type_defn,
	(["≠_def"],"≠",[],thm1),
	gen_fail_msg "new_type_defn" 6045 ["≠"])
	];
store_mt_results mt_run_fail [
	("simple_new_defn 6049 b",
	simple_new_defn,
	(["µ_def"],"µ",mk_t),
	gen_fail_msg "simple_new_defn" 6049 ["µ"])
	];
store_mt_results mt_run_fail [
	("new_spec 6049 b",
	new_spec,
	(["µ_def"],1,µ_spec),
	gen_fail_msg "new_spec" 6049 ["µ"])
	];
=TEX
Test out deletions($delete\_const$, $delete\_type$ and $delete\_axiom$, $delete\_thm$) by side effect:
=SML
open_theory "another";
store_mt_results (mt_runf (op =:)) [("new_type 4",
	new_type,
	("BOOL",0),
	BOOL)
	];
save_thm("example_delete_thm",pB_thm);
store_mt_results (mt_runf (op =|-)) [("delete_thm",
	delete_thm,
	"example_delete_thm",
	pB_thm)];
store_mt_results (mt_runf (op =$)) [
	("new_const 3",
	new_const,
	("T",BOOL),
	mk_const("T",BOOL)),
	("new_const 4",
	new_const,
	("F",BOOL),
	mk_const("F",BOOL))
	];
print_thy("another");
delete_const mk_f;
=TEX
Test for deletion of constant with same type up to renaming of type variables.
=SML
new_const ("test_delete_const",mk_vartype "'a");
delete_const (mk_const("test_delete_const",mk_vartype "'b"));
print_thy("-");
store_mt_results (mt_runf (op =$)) [
	("new_const 5",
	new_const,
	("F",BOOL),
	mk_const("F",BOOL))
	];
val s1 = list_save_thm(["s1"], icl'Kernel.icl'asm_rule v1);
print_thy("another");
store_mt_results mt_run_fail [
	("delete_const 12001",
	delete_const,
	(mk_const("F",tv1)),
	gen_fail_msg "delete_const" 12001 ["another","F"]),
	("delete_const 3009",
	delete_const,
	(mk_var("F",tv1)),
	gen_fail_msg "delete_const" 3009 ["¨FÆ"])
	];
=TEX
The following test only works in batch mode: $warn$ differs
in the exception returned for interactive use.
(Answer "n" in interactive mode).
=SML
set_flag("ignore_warnings",false);
store_mt_results mt_run_fail [
	("delete_const 12012 a",
	delete_const,
	mk_f,
	gen_fail_msg "delete_const" 12012 ["F","Constant:F; Theorem:s1"])
	];
set_flag("ignore_warnings",true);
delete_const mk_f; 
print_thy("-");
delete_const mk_t;
print_thy("-");
val TorF = new_const("TorF",BOOL);
print_thy("-");
store_mt_results mt_run_fail [
	("delete_type 12002",
	delete_type,
	"rubbish",
	gen_fail_msg "delete_type" 12002 ["another","rubbish"])];
store_mt_results mt_run_fail [
	("delete_axiom 12003",
	delete_axiom,
	"rubbish",
	gen_fail_msg "delete_axiom" 12003 ["another","rubbish"])];
store_mt_results mt_run_fail [
	("delete_thm 6046",
	delete_thm,
	"rubbish",
	gen_fail_msg "delete_thm" 6046 ["rubbish","another"])];

delete_type "BOOL";
print_thy("-");

open_theory "yet_again";
store_mt_results (mt_runf (op =#)) [
	("new_axiom",
	dest_thm o new_axiom,
	(["µ_axiom"],mk_µ(v1,v1)),
	([],mk_µ(v1,v1)))
	];
print_thy("yet_again");
=TEX
N.B. the constant $¨test_spec:BOOLÆ$ just happens to be
in scope, for testing empty key lists.
=SML
store_mt_results mt_run_fail [
	("new_axiom 6047",
	new_axiom,
	(["µ_axiom"],mk_µ(v1,v1)),
	gen_fail_msg "new_axiom" 6047 ["µ_axiom","yet_again"]),
	("new_axiom 6015",
	new_axiom,
	(["t_axiom"],mk_t),
	gen_fail_msg "new_axiom" 6015 ["¨TÆ","T"]),
	("new_axiom 3031",
	new_axiom,
	(["t_axiom"],N0),
	gen_fail_msg "new_axiom" 3031 ["¨0Æ"]),
	("new_axiom 6031",
	new_axiom,
	([],mk_const("test_spec",BOOL)),
	gen_fail_msg "new_axiom" 6031 [])
	];

print_thy("yet_again");

=TEX
Test $lock\_theory$ and $unlock\_theory$ by side effect:
=SML
new_type ("SOMETHING",3);
new_const ("Something",BOOL);
lock_theory "yet_again";
store_mt_results mt_run_fail [("delete_theory 6037",
	delete_theory,
	"yet_again",
	gen_fail_msg "delete_theory" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("new_axiom 6037",
	new_axiom,
	(["Truth_Axiom"],mk_t),
	gen_fail_msg "new_axiom" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("new_const 6037",
	new_const,
	("ForT",BOOL),
	gen_fail_msg "new_const" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("new_type_defn 6037",
	new_type_defn,
	(["≠_def"],"≠",[],thm1),
	gen_fail_msg "new_type_defn" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("simple_new_defn 6037",
	simple_new_defn,
	(["µ_def"],"µ",mk_t),
	gen_fail_msg "simple_new_defn" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("new_spec 6037",
	new_spec,
	(["µ_def"],1,µ_spec),
	gen_fail_msg "new_spec" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("new_type 6037",
	new_type,
	("SOMETHING",3),
	gen_fail_msg "new_type" 6037 ["yet_again"])
	];
store_mt_results mt_run_fail [("list_save_thm 6037",
	list_save_thm,
	(["Example"],thm1),
	gen_fail_msg "list_save_thm" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("save_thm 6037",
	save_thm,
	("Example1",thm1),
	gen_fail_msg "save_thm" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("delete_axiom 6037",
	delete_axiom,
	"µ_axiom",
	gen_fail_msg "delete_axiom" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("delete_thm 6037",
	delete_thm,
	"Example",
	gen_fail_msg "delete_thm" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("delete_type 6037",
	delete_type,
	"SOMETHING",
	gen_fail_msg "delete_type" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("delete_const 6037",
	delete_const,
	mk_const("Something",BOOL),
	gen_fail_msg "delete_const" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("set_user_datum 6037",
	set_user_datum,
	("testing",UD_String ("a test",[])),
	gen_fail_msg "set_user_datum" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("lock_theory 6037",
	lock_theory,
	"yet_again",
	gen_fail_msg "lock_theory" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("new_parent 6037",
	new_parent,
	"another",
	gen_fail_msg "new_parent" 6037 ["yet_again"])];
store_mt_results mt_run [
	("get_theory_status 1",
	get_theory_status,
	"yet_again",
	TSLocked)
	];
store_mt_results mt_run [
	("get_current_theory_status 1",
	get_current_theory_status,
	(),
	TSLocked)
	];

unlock_theory "yet_again";
store_mt_results mt_run [
	("get_theory_status 2",
	get_theory_status,
	"yet_again",
	TSNormal)
	];
=TEX
Test user data features of $set\_user\_data$ by side effect:
=SML
set_user_datum ("testing",UD_String ("a test",[]));
let
fun aux (UD_String (nm1,[]),UD_String (nm2,[])) = nm1 = nm2
| aux _ = false;
in
store_mt_results (mt_runf aux) [
	("get_user_datum 1",
	get_user_datum "-",
	"testing",
	UD_String ("a test",[])),
	("get_user_datum 2",
	get_user_datum "yet_again",
	"testing",
	UD_String ("a test",[]))
	]
end;

store_mt_results mt_run_fail [
	("get_user_datum 6035",
	get_user_datum "rubbish",
	"testing",
	gen_fail_msg "get_user_datum" 6035 ["rubbish"]),
	("get_user_datum 12009",
	get_user_datum "-",
	"rubbish",
	gen_fail_msg "get_user_datum" 12009 ["rubbish","-"])
	];
store_mt_results mt_run_fail [
	("lock_theory 6035",
	lock_theory,
	"rubbish",
	gen_fail_msg "lock_theory" 6035 ["rubbish"]),
	("unlock_theory 6035 a",
	unlock_theory,
	"rubbish",
	gen_fail_msg "unlock_theory" 6035 ["rubbish"])
	];
=TEX
Test the multiple deletion effects of the delete extension
functions.
=SML
val ForT = new_const("ForT",BOOL);
val just_passing = new_const("just_passing",BOOL);
=TEX
The following three tests only work in batch mode: $warn$ differs
in the exception returned for interactive use.
(Answer "n" in interactive mode).
=SML
set_flag("ignore_warnings",false);
store_mt_results mt_run_fail [
	("delete_const 12012 b",
	delete_const,
	just_passing,
	gen_fail_msg "delete_const" 12012 ["just_passing","Constant:just_passing"])
	];
set_flag("ignore_warnings",true);
delete_const ForT;
new_type("just_passing2",1);
=TEX
The following test in part relies on the visual inspection of the warning message given.
(Answer "n" in interactive mode).
=SML
set_flag("ignore_warnings",false);
store_mt_results mt_run_fail [
	("delete_type 12012",
	delete_type,
	"just_passing2",
	gen_fail_msg "delete_type" 12012 ["just_passing2","Type:just_passing2"])
	];
set_flag("ignore_warnings",true);
delete_type "just_passing2";
new_axiom(["just_passing3"],v1);
=TEX
The following test in part relies on the visual inspection of the warning message given.
(Answer "n" in interactive mode).
=SML
set_flag("ignore_warnings",false);
store_mt_results mt_run_fail [
	("delete_axiom 12012",
	delete_axiom,
	"just_passing3",
	gen_fail_msg "delete_axiom" 12012 ["just_passing3","Axiom:just_passing3"])
	];
set_flag("ignore_warnings",true);
delete_axiom "just_passing3";
=TEX
Can't delete if theory has children:
=SML
open_theory "next";
store_mt_results mt_run_fail [("delete_const 6076",
	delete_const,
	(mk_const("µ",mk_≠_type(mk_≠_type(tv'1,BOOL),BOOL))),
	gen_fail_msg "delete_const" 6076 ["next"])];
store_mt_results mt_run_fail [("delete_type 6076",
	delete_type,
	"BOOL",
	gen_fail_msg "delete_type" 6076 ["next"])];
store_mt_results mt_run_fail [("delete_axiom 6076",
	delete_axiom,
	"µ_spec",
	gen_fail_msg "delete_axiom" 6076 ["next"])];
open_theory "next";
store_mt_results mt_run [
	("thm_theory 1",
	thm_theory,
	thm1,
	"min"),
	("thm_theory 2",
	thm_theory,
	icl'Kernel.icl'asm_rule v1,
	"next")
	];
=TEX
Test $delete\_theory$ by side effect, rather than explicit test.
=SML
new_theory "to_be_deleted";
val del_thy_name = string_of_int(icl'Kernel.icl'get_current_theory_name());
print_thy("to_be_deleted"); 
val thy_deleted_thm = save_thm("thy_deleted_thm",icl'Kernel.icl'asm_rule v1);
open_theory "next";
delete_theory "to_be_deleted";

store_mt_results mt_run_fail [
	("thm_theory 12007",
	thm_theory,
	thy_deleted_thm,
	gen_fail_msg "thm_theory" 12007 ["v1 Ù v1",del_thy_name])
	];
store_mt_results mt_run_fail [
	("get_theory_status 6035 a",
	get_theory_status,
	"to_be_deleted",
	gen_fail_msg "get_theory_status" 6035 ["to_be_deleted"]),
	("get_theory_status 6035 b",
	get_theory_status,
	"rubbish",
	gen_fail_msg "get_theory_status" 6035 ["rubbish"])
	];

print_all_thy();
store_mt_results mt_run_fail [
	("open_theory 6035 b",
	open_theory,
	"to_be_deleted",
	gen_fail_msg "open_theory" 6035 ["to_be_deleted"])
	];
store_mt_results mt_run_fail [
	("delete_theory 6035 b",
	delete_theory,
	"to_be_deleted",
	gen_fail_msg "delete_theory" 6035 ["to_be_deleted"])
	];
store_mt_results mt_run_fail [
	("lock_theory 6035 b",
	lock_theory,
	"to_be_deleted",
	gen_fail_msg "lock_theory" 6035 ["to_be_deleted"]),
	("unlock_theory 6035 b",
	unlock_theory,
	"to_be_deleted",
	gen_fail_msg "unlock_theory" 6035 ["to_be_deleted"]),
	("unlock_theory 6068",
	unlock_theory,
	"yet_again",
	gen_fail_msg "unlock_theory" 6068 ["yet_again"])
	];

new_theory "to_be_deleted"; (* succeeds! *)
print_thy("to_be_deleted");
open_theory "yet_again";
delete_theory "to_be_deleted"; 
store_mt_results mt_run_fail [
	("delete_theory 6076",
	delete_theory,
	"min",
	gen_fail_msg "delete_theory" 6076 ["min"]),
	("delete_theory 6069",
	delete_theory,
	"yet_again",
	gen_fail_msg "delete_theory" 6069 ["yet_again"])
	];
=TEX
The correct operation of $duplicate\_theory$ should be checked
by visually inspecting the following output.
=SML
print_thy("next");
duplicate_theory ("next", "copy_of_next");
print_thy("copy_of_next");

store_mt_results mt_run_fail [
	("duplicate_theory 6026",
	duplicate_theory,
	("min", "copy_of_min"),
	gen_fail_msg "duplicate_theory" 6026 ["min"]),
	("duplicate_theory 6035 a",
	duplicate_theory,
	("rubbish", "copy_of_rubbish"),
	gen_fail_msg "duplicate_theory" 6035 ["rubbish"]),
	("duplicate_theory 6035 b",
	duplicate_theory,
	("to_be_deleted", "copy_of_rubbish"),
	gen_fail_msg "duplicate_theory" 6035 ["to_be_deleted"]),
	("duplicate_theory 6040",
	duplicate_theory,
	("next", "copy_of_next"),
	gen_fail_msg "duplicate_theory" 6040 ["copy_of_next"])
	];
store_mt_results mt_run_error [
	("list_save_thm 6036",
	list_save_thm,
	(["s2"], thy_deleted_thm),
	gen_fail_msg "icl'list_save_thm" 6036 ["v1 Ù v1","to_be_deleted",del_thy_name])
	];
=TEX
Definitional mechanisms:
=SML
open_theory "next";
declare_binder "Ã";
declare_terminator "Ã" handle _ => ();
new_const("T",BOOL);
new_const("F",BOOL);
new_const("=",mk_≠_type(tv1, mk_≠_type(tv1, BOOL)));
declare_infix (200, "=");
declare_terminator "=" handle _ => ();
declare_alias ("§", ¨$=:BOOL≠BOOL≠BOOLÆ) handle _ => ();
declare_infix (200, "§") handle _ => ();
new_const("¥",mk_≠_type(BOOL,mk_≠_type(BOOL,BOOL)));
declare_infix (20, "¥");
declare_terminator "¥" handle _ => ();
new_const("±",mk_≠_type(BOOL,mk_≠_type(BOOL,BOOL)));
declare_infix (40, "±");
declare_terminator "±" handle _ => ();
new_const("≤",mk_≠_type(BOOL,mk_≠_type(BOOL,BOOL)));
declare_infix (30, "≤");
declare_terminator "≤" handle _ => ();
new_const("≥",mk_≠_type(BOOL,BOOL));
declare_prefix (50, "≥");
new_const("TypeDefn",mk_≠_type(mk_≠_type(tv1,BOOL),
	mk_≠_type(mk_≠_type(tv'2,tv1),BOOL)));
val Tv1Pred = new_const("Tv1Pred",mk_≠_type(tv1,BOOL));
open_theory "yet_again";
store_mt_results (mt_runf (op =#)) [ 
	("simple_new_defn 1",
	dest_thm o simple_new_defn,
	(["True"],"True",mk_t),
	([],mk_§(mk_const("True",BOOL),mk_t))),
	("simple_new_defn 2",
	dest_thm o simple_new_defn,
	(["False"],"False",mk_f),
	([],mk_§(mk_const("False",BOOL),mk_f)))
	];
store_mt_results mt_run_fail [
	("simple_new_defn 6013",
	simple_new_defn,
	(["x"],"Rubbish",mk_var("v",mk_ctype("RUBBISH",[]))),
	gen_fail_msg "simple_new_defn" 6013 ["¨vÆ","RUBBISH"]),
	("simple_new_defn 6049 c",
	simple_new_defn,
	(["True"],"True",mk_t),
	gen_fail_msg "simple_new_defn" 6049 ["True"]),
	("simple_new_defn 6049 d",
	simple_new_defn,
	(["0"],"0",N0),
	gen_fail_msg "simple_new_defn" 6049 ["0"]),
	("simple_new_defn 6051",
	simple_new_defn,
	(["True"],"True1",mk_t),
	gen_fail_msg "simple_new_defn" 6051 ["True","yet_again"]),
	("simple_new_defn 6058",
	simple_new_defn,
	(["Maybe1"],"Maybe1",mk_µ(vtv1,mk_eq(vtv1,vtv1))),
	gen_fail_msg "simple_new_defn" 6058 ["¨µ vtv1∑ vtv1 = vtv1Æ","'tv1"]),
	("simple_new_defn 6059",
	simple_new_defn,
	(["Maybe"],"Maybe",v1),
	gen_fail_msg "simple_new_defn" 6059 ["¨v1Æ","v1"]),
	("simple_new_defn 6031",
	simple_new_defn,
	([],"Maybe",mk_t),
	gen_fail_msg "simple_new_defn" 6031 [])
	];
val etype_ax = new_axiom(["etype_ax"],
	mk_simple_∂(vtv1,mk_app(Tv1Pred,vtv1)));

local val x= mk_var("x",tv'2)
in
val etype2_exax = new_axiom(["etype2_exax"],
	mk_simple_∂(x,mk_app(inst [] [(tv'2,tv1)]Tv1Pred,x)))
end;
val etype_def = new_type_defn(["ETYPE"], "ETYPE", ["'tv1"], etype_ax);
val etype2_def = new_type_defn(["ETYPE2"], "ETYPE2", ["'2"], etype2_exax);
let
	fun f t1 t2 = mk_var("f",mk_≠_type(t1,t2));
in
store_mt_results (mt_runf (op =#)) [ 
	("new_type_defn 1",
	dest_thm,
	etype_def,
	([], mk_∂(f (mk_ctype("ETYPE",[tv1])) tv1,
		list_mk_app(
		mk_const("TypeDefn",mk_≠_type(mk_≠_type(tv1,BOOL),
			mk_≠_type(mk_≠_type(mk_ctype("ETYPE",[tv1]),tv1),BOOL))),
		[inst [] [] Tv1Pred,f (mk_ctype("ETYPE",[tv1])) tv1])))),
	("new_type_defn 2",
	dest_thm,
	etype2_def,
	([], mk_∂(f (mk_ctype("ETYPE2",[tv'2])) (tv'2),
		list_mk_app(
		mk_const("TypeDefn",mk_≠_type(mk_≠_type(tv'2,BOOL),
			mk_≠_type(mk_≠_type(mk_ctype("ETYPE2",[tv'2]),tv'2),BOOL))),
		[inst [] [(tv'2,tv1)] Tv1Pred,
		f (mk_ctype("ETYPE2",[tv'2])) (tv'2)]))))
	]
end;
val etype_ax_6054 = new_axiom(["etype_ax_6054"], mk_t);
val etype_ax_6055 = new_axiom(["etype_ax_6055"], 
	mk_∂(mk_var("x",tv1),mk_t));
val etype_ax_6056 = new_axiom(["etype_ax_6056"], 
	mk_∂(mk_var("x",tv1),mk_app(mk_var("p",mk_≠_type(tv1,BOOL)), 
		mk_var("x",tv1))));
val etype_ax_6080 = new_axiom(["etype_ax_6080"], 
	mk_∂(mk_var("x",tv1),mk_app(mk_const("≥",mk_≠_type(BOOL,BOOL)), 
		mk_t)));
store_mt_results mt_run_fail [
	("new_type_defn 6045",
	new_type_defn,
	(["ETYPE1"], "ETYPE", ["'tv1"], etype_ax),
	gen_fail_msg "new_type_defn" 6045 ["ETYPE"]),
	("new_type_defn 6052",
	new_type_defn,
	(["ETYPE"], "ETYPE1", ["'tv1"], etype_ax),
	gen_fail_msg "new_type_defn" 6052 ["ETYPE","yet_again"]),
	("new_type_defn 6053",
	new_type_defn,
	(["ETYPE1"], "ETYPE1", ["'tv1"], icl'Kernel.icl'asm_rule mk_t),
	gen_fail_msg "new_type_defn" 6053 ["T Ù T"]),
	("new_type_defn 6054",
	new_type_defn,
	(["ETYPE1"], "ETYPE1", ["'tv1"], etype_ax_6054),
	gen_fail_msg "new_type_defn" 6054 ["Ù T"]),
	("new_type_defn 6055",
	new_type_defn,
	(["ETYPE1"], "ETYPE1", ["'tv1"], etype_ax_6055),
	gen_fail_msg "new_type_defn" 6055 ["Ù ∂ x∑ T"]),
	("new_type_defn 6056",
	new_type_defn,
	(["ETYPE1"], "ETYPE1", ["'tv1"], etype_ax_6056),
	gen_fail_msg "new_type_defn" 6056 ["Ù ∂ x∑ p x","p"]),
	("new_type_defn 6057",
	new_type_defn,
	(["ETYPE1"], "ETYPE1", ["'not_there"], etype_ax),
	gen_fail_msg "new_type_defn" 6057 ["Ù ∂ vtv1∑ Tv1Pred vtv1","'tv1"]),
	("new_type_defn 6079",
	new_type_defn,
	(["ETYPE1"], "ETYPE1", ["'tv1","'tv1"], etype_ax),
	gen_fail_msg "new_type_defn" 6079 ["'tv1"]),
	("new_type_defn 6080",
	new_type_defn,
	(["ETYPE1"], "ETYPE1", ["'tv1"], etype_ax_6080),
	gen_fail_msg "new_type_defn" 6080 ["Ù ∂ x∑ ≥ T"]),
	("new_type_defn 6031",
	new_type_defn,
	([], "ETYPE1", ["'tv1"], etype_ax),
	gen_fail_msg "new_type_defn" 6031 [])
	];
store_mt_results mt_run_error [
	("new_type_defn 6036",
	new_type_defn,
	( ["rubbish"], "rubbish", [], thy_deleted_thm),
	gen_fail_msg "icl'new_type_defn" 6036 ["v1 Ù v1","to_be_deleted",del_thy_name])
	];
=TEX
\subsection{new\_spec}
=SML
val So = mk_const("So",BOOL);
val IsSo = mk_const("IsSo",BOOL);
val vSo = mk_var("So",BOOL);
val vIsSo = mk_var("IsSo",BOOL);
val so_isso_axiom = new_axiom(["so_isso_axiom"],
	list_mk_simple_∂([vSo,vIsSo],mk_¥(vSo,vIsSo)));
val so_isso_def = new_spec (["So","IsSo"],2,so_isso_axiom);
store_mt_results (mt_runf (op =#)) [ 
	("new_spec",
	dest_thm,
	so_isso_def,
	([],mk_¥(So,IsSo)))
	];
val spec_ax_6016 = new_axiom(["spec_ax_6016"],
	list_mk_∂([mk_var("x",BOOL),mk_var("x",BOOL)],
		mk_±(mk_var("x",BOOL),mk_var("x",BOOL))));
val spec_ax_6051 = new_axiom(["spec_ax_6051"],
	mk_∂(mk_var("x",BOOL),mk_var("x",BOOL)));
val spec_ax_6056 = new_axiom(["spec_ax_6056"],
	mk_∂(mk_var("x",BOOL),mk_eq(mk_var("x",BOOL),v1)));
val spec_ax_6061 = new_axiom(["spec_ax_6061"],
	mk_∂(mk_var("x",BOOL),mk_eq(mk_var("x",BOOL),
		mk_µ(mk_var("y",tv1), mk_t))));
val spec_ax_6081 = new_axiom(["spec_ax_6081"],
	list_mk_∂([mk_var("y",tv'2),mk_var("x",BOOL)],
		mk_±(mk_var("x",BOOL),mk_var("x",BOOL))));
store_mt_results mt_run_fail [
	("new_spec 6016",
	new_spec,
	(["x1","x2"],2,spec_ax_6016),
	gen_fail_msg "new_spec" 6016 ["x","Ù ∂ x x∑ x ± x"]),
	("new_spec 6031",
	new_spec,
	([],2,so_isso_axiom),
	gen_fail_msg "new_spec" 6031 []),
	("new_spec 6044",
	new_spec,
	(["nowhere"],0,so_isso_axiom),
	gen_fail_msg "new_spec" 6044 []),
	("new_spec 6049",
	new_spec,
	(["Soa","IsSoa"],2,so_isso_axiom),
	gen_fail_msg "new_spec" 6049 ["So"]),
	("new_spec 6051",
	new_spec,
	(["So","IsSo"],1,spec_ax_6051),
	gen_fail_msg "new_spec" 6051 ["IsSo","yet_again"]),
	("new_spec 6053",
	new_spec,
	(["So","IsSo"],2,icl'Kernel.icl'asm_rule mk_t),
	gen_fail_msg "new_spec" 6053 ["T Ù T"]),
	("new_spec 6056",
	new_spec,
	(["x"],1,spec_ax_6056),
	gen_fail_msg "new_spec" 6056 ["Ù ∂ x∑ x § v1","v1"]),
	("new_spec 6060",
	new_spec,
	(["Some"],3,so_isso_axiom),
	gen_fail_msg "new_spec" 6060 ["Ù ∂ So IsSo∑ So ¥ IsSo", "3"]),
	("new_spec 6061",
	new_spec,
	(["x"],1,spec_ax_6061),
	gen_fail_msg "new_spec" 6061 ["Ù ∂ x∑ x § (µ y∑ T)", "'tv1"]),
	("new_spec 6081",
	new_spec,
	(["x"],2,spec_ax_6081),
	gen_fail_msg "new_spec" 6081 ["¨yÆ","¨xÆ"])
	];
store_mt_results mt_run_error [
	("new_spec 6036",
	new_spec,
	([],2,thy_deleted_thm),
	gen_fail_msg "icl'new_spec" 6036 ["v1 Ù v1","to_be_deleted",del_thy_name])
	];
=TEX
\subsection{Theory Functions}
We test $new\_parent$'s successful operation by side effect (observing the print of the current theory).
=SML
new_parent "another";
print_thy "-";
open_theory "min";
val UNIT = new_type ("UNIT",0);
new_theory "tester";
val F' = new_const("F",UNIT);
open_theory "yet_again";
store_mt_results mt_run_fail [
	("new_parent 6067 a",
	new_parent,
	"tester",
	gen_fail_msg "new_parent" 6067 ["tester"]),
	("new_parent 6035 a",
	new_parent,
	"rubbish",
	gen_fail_msg "new_parent" 6035 ["rubbish"]),
	("new_parent 6035 b",
	new_parent,
	"to_be_deleted",
	gen_fail_msg "new_parent" 6035 ["to_be_deleted"]),
	("new_parent 6082",
	new_parent,
	"next",
	gen_fail_msg "new_parent" 6082 ["next"])
	];
open_theory "min";
store_mt_results mt_run_fail [
	("new_parent 6084",
	new_parent,
	"yet_again",
	gen_fail_msg "new_parent" 6084 ["yet_again"])];
store_mt_results mt_run [
	("get_current_theory_status 2",
	get_current_theory_status,
	(),
	TSNormal)
	];
=TEX
\section{FUTHER THEORY FUNCTIONS}
Test hooks into environments.
=SML
open_theory "yet_again";
let
fun aux (Value a,Value b) = a =:b
| aux (Nil, Nil) = true
| aux _ = false;
in
store_mt_results (mt_runf aux)  [ 
	("get_const_type 1",
	get_const_type,
	"5",
	Value Ó),
	("get_const_type 2",
	get_const_type,
	"",
	Nil),
	("get_const_type 3",
	get_const_type,
	"T",
	Value BOOL),
	("get_const_type 4",
	get_const_type,
	"TorF",
	Nil),
	("get_const_type 5",
	get_const_type,
	"rubbish",
	Nil)
	]
end;
store_mt_results mt_run [ 
	("get_type_arity 1",
	get_type_arity,
	"BOOL",
	Value 0),
	("get_type_arity 2",
	get_type_arity,
	"Ó",
	Value 0),
	("get_type_arity 3",
	get_type_arity,
	"",
	Nil),
	("get_type_arity 4",
	get_type_arity,
	"≠",
	Value 2),
	("get_type_arity 5",
	get_type_arity,
	"RUBBISH",
	Nil)
	];
=TEX
Test the built in scopes:
=SML
open_theory  "yet_again";
store_mt_results (mt_runf (op =$)) [ 
	("new_const 1",
	new_const,
	("12a",BOOL),
	mk_const("12a",BOOL)),
	("new_const 2",
	new_const,
	("`12",BOOL),
	mk_const("`12",BOOL))
	];
store_mt_results mt_run_fail [
	("new_const 6049 a",
	new_const,
	("1",BOOL),
	gen_fail_msg "new_const" 6049 ["1"]),
	("new_const 6049 b",
	new_const,
	("123",BOOL),
	gen_fail_msg "new_const" 6049 ["123"]),
	("new_const 6049 f",
	new_const,
	("`a",BOOL),
	gen_fail_msg "new_const" 6049 ["`a"]),
	("new_const 6049 d",
	new_const,
	("\"abc",BOOL),
	gen_fail_msg "new_const" 6049 ["\"abc"])
	];
=TEX
We can presume successful uses of $get\-\_thms$, $get\-\_axioms$, $get\-\_defns$, $get\_types$, $get\_consts$, $get\-\_parents$, $get\-\_children$,
$theory\_names$
are all well tested by $print\_(all\_)theory$.
The remainder of their kin are tested as follows:
=SML
open_theory "yet_again";
val out_of_scope_thm = save_thm("not_in_scope",icl'Kernel.icl'asm_rule v1);
open_theory "yet_again";
=TEX
\subsection{Valid Theorems}
=SML
store_mt_results mt_run [
	("valid_thm 1",
	valid_thm,
	thm1,
	true),
	("valid_thm 2",
	valid_thm,
	thy_deleted_thm,
	false)
	];
=TEX
\subsection{Output of Theorems}
=SML
store_mt_results mt_run [
	("string_of_thm",
	string_of_thm,
	pB_thm,
	"p Ù p")];
store_mt_results mt_run_fail [
	("thm_fail",
	thm_fail "test" 6053,
	[pB_thm],
	gen_fail_msg "test" 6053 ["p Ù p"])];
store_mt_results (mt_runf (op =#)) [ 
	("dest_thm",
	dest_thm,
	pB_thm,
	([pB],pB))
	];
=TEX
\subsection{Some More Theory Access Functions}
=SML
store_mt_results (mt_runf (op =#)) [
	("get_thm",
	dest_thm o get_thm "next",
	"thm1",
	(h_thm1,c_thm1)),
	("get_defn",
	dest_thm o get_defn "yet_again",
	"So",
	([],mk_¥(So,IsSo))),
	("get_axiom",
	dest_thm o get_axiom "yet_again",
	"etype_ax",
	(dest_thm etype_ax))
	];
open_theory "next";
store_mt_results mt_run_fail [
	("get_thm 6035",
	get_thm "rubbish",
	"thm1",
	gen_fail_msg "get_thm" 6035 ["rubbish"]),
	("get_thm 12006",
	get_thm "next",
	"rubbish",
	gen_fail_msg "get_thm" 12006 ["next","rubbish"]),
	("get_thm 12010",
	get_thm "yet_again",
	"not_in_scope",
	gen_fail_msg "get_thm" 12010 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("get_defn 6035",
	get_defn "rubbish",
	"def1",
	gen_fail_msg "get_defn" 6035 ["rubbish"]),
	("get_defn 12004",
	get_defn "next",
	"rubbish",
	gen_fail_msg "get_defn" 12004 ["next","rubbish"]),
	("get_defn 12010",
	get_defn "yet_again",
	"not_in_scope",
	gen_fail_msg "get_defn" 12010 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("get_axiom 6035",
	get_axiom "rubbish",
	"def1",
	gen_fail_msg "get_axiom" 6035 ["rubbish"]),
	("get_axiom 12005",
	get_axiom "next",
	"rubbish",
	gen_fail_msg "get_axiom" 12005 ["next","rubbish"]),
	("get_axiom 12010",
	get_axiom "yet_again",
	"not_in_scope",
	gen_fail_msg "get_axiom" 12010 ["yet_again"])
	];
=TEX
=SML
open_theory "yet_again";
store_mt_results mt_run [
	("get_ancestors 1",
	get_ancestors,
	"yet_again",
	["another", "min", "next", "yet_again"]),
	("get_ancestors 2",
	get_ancestors,
	"min",
	["min"])
	];
store_mt_results mt_run_fail [
	("get_ancestors 6035",
	get_ancestors,
	"rubbish",
	gen_fail_msg "get_ancestors" 6035 ["rubbish"])
	];
store_mt_results mt_run [
	("is_theory_ancestor 1",
	is_theory_ancestor "min",
	"-",
	true),
	("is_theory_ancestor 2",
	is_theory_ancestor "min",
	"yet_again",
	true),
	("is_theory_ancestor 3",
	is_theory_ancestor "yet_again",
	"min",
	false),
	("is_theory_ancestor 4",
	is_theory_ancestor "-",
	"min",
	false),
	("is_theory_ancestor 5",
	is_theory_ancestor "yet_again",
	"yet_again",
	true)
	];
store_mt_results mt_run_fail [
	("is_theory_ancestor 6035 a",
	is_theory_ancestor "rubbish",
	"min",
	gen_fail_msg "is_theory_ancestor" 6035 ["rubbish"]),
	("is_theory_ancestor 6035 b",
	is_theory_ancestor "-",
	"rubbish",
	gen_fail_msg "is_theory_ancestor" 6035 ["rubbish"]),
	("is_theory_ancestor 6035 c",
	is_theory_ancestor "rubbish",
	"rubbish",
	gen_fail_msg "is_theory_ancestor" 6035 ["rubbish"])
	];
store_mt_results mt_run [
	("get_descendants",
	get_descendants,
	"next",
	["yet_again", "next"])
	];
store_mt_results mt_run_fail [
	("get_descendants 6035",
	get_descendants,
	 "rubbish",
	gen_fail_msg "get_descendants" 6035 ["rubbish"])];
store_mt_results mt_run_fail [
	("get_parents 6035",
	get_parents,
	 "rubbish",
	gen_fail_msg "get_parents" 6035 ["rubbish"])];
store_mt_results mt_run_fail [
	("get_children 6035",
	get_children,
	 "rubbish",
	gen_fail_msg "get_children" 6035 ["rubbish"])];
store_mt_results mt_run_fail [
	("get_thms 6035",
	get_thms,
	 "rubbish",
	gen_fail_msg "get_thms" 6035 ["rubbish"])];
store_mt_results mt_run_fail [
	("get_axioms 6035",
	get_axioms,
	 "rubbish",
	gen_fail_msg "get_axioms" 6035 ["rubbish"])];
store_mt_results mt_run_fail [
	("get_defns 6035",
	get_defns,
	 "rubbish",
	gen_fail_msg "get_defns" 6035 ["rubbish"])];
store_mt_results mt_run_fail [
	("get_consts 6035",
	get_consts,
	"rubbish",
	gen_fail_msg "get_consts" 6035 ["rubbish"])];
store_mt_results mt_run_fail [
	("get_types 6035",
	get_types,
	 "rubbish",
	gen_fail_msg "get_types" 6035 ["rubbish"])];
=TEX
Tests on hierarchies : do after all others, as things are made read only.
=SML
icl'Kernel.icl'freeze_hierarchy();
open_theory "yet_again";
store_mt_results mt_run [
	("get_current_theory_status 3",
	get_current_theory_status,
	(),
	TSAncestor)
	];
store_mt_results mt_run [
	("get_theory_status",
	get_theory_status,
	"next",
	TSAncestor)
	];
store_mt_results mt_run_fail [
	("set_user_datum 6071",
	set_user_datum,
	("testing1",UD_String ("a test",[])),
	gen_fail_msg "set_user_datum" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("new_axiom 6071",
	new_axiom,
	(["Truth_axiom1"],mk_t),
	gen_fail_msg "new_axiom" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("new_const 6071",
	new_const,
	("ForT1",BOOL),
	gen_fail_msg "new_const" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("new_type 6071",
	new_type,
	("SOMETHING1",3),
	gen_fail_msg "new_type" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("simple_new_defn 6071",
	simple_new_defn,
	(["True1"],"True1",mk_t),
	gen_fail_msg "simple_new_defn" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("delete_const 6071",
	delete_const,
	mk_const("test_spec",BOOL),
	gen_fail_msg "delete_const" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("delete_axiom 6071",
	delete_axiom,
	"so_isso_axiom",
	gen_fail_msg "delete_axiom" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("delete_type 6071",
	delete_type,
	"ETYPE",
	gen_fail_msg "delete_type" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("list_save_thm 6071",
	list_save_thm,
	(["Example1"],thm1),
	gen_fail_msg "list_save_thm" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("save_thm 6071",
	save_thm,
	("Example1",thm1),
	gen_fail_msg "save_thm" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("delete_thm 6071",
	delete_thm,
	"Example",
	gen_fail_msg "delete_thm" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("delete_theory 6071",
	delete_theory,
	"another",
	gen_fail_msg "delete_theory" 6071 ["another"])
	];
store_mt_results mt_run_fail [
	("lock_theory 6071",
	lock_theory,
	"yet_again",
	gen_fail_msg "lock_theory" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("new_parent 6071",
	new_parent,
	"another",
	gen_fail_msg "new_parent" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("new_type_defn 6071",
	new_type_defn,
	(  ["ETYPE7"], "ETYPE7", ["'1"], etype_ax),
	gen_fail_msg "new_type_defn" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("new_spec 6071",
	new_spec,
	(["So1","IsSo1"],2,so_isso_axiom),
	gen_fail_msg "new_spec" 6071 ["yet_again"])
	];
=TEX
Test for clashes in children theories for $new\_parent$:
=SML
open_theory "next";
new_theory "np_test1";
new_theory "np_test3";
open_theory "next";
new_theory "np_test2";
new_const("np_test",BOOL);
open_theory "next";
new_theory "np_test4";
new_type("np_test_t",0);
open_theory "np_test3";
new_const("np_test",BOOL);
new_type("np_test_t",0);
open_theory "np_test1";
store_mt_results mt_run_fail [
	("new_parent 6067 b",
	new_parent,
	"np_test2",
	gen_fail_msg "new_parent" 6067 ["np_test2"]),
	("new_parent 6067 c",
	new_parent,
	"np_test4",
	gen_fail_msg "new_parent" 6067 ["np_test4"])
	];
=TEX
\subsection{End of Tests}
=SML
diag_string(summarize_mt_results());
=TEX
\section{UNTESTED ERROR MESSAGES}
\label{untested}
Error 6017 of $open\_theory$, concerning sealed theories,
as a full testing of sealing theories was carried out in \cite{DS/FMU/IED/MDT006}, and no sealing material occurs in 
\cite{DS/FMU/IED/DTD012} bar this error message.

Errors 6013, 6014, 6015 and 6038 of various functions, concerning ill-formed theorems are not tested for all their occurrences: they are raised by the underlying functions,
and are fully tested in \cite{DS/FMU/IED/MDT006}.

Error 6042 of $duplicate\_theory$ is not tested as we
do not wish to use $icl'seal\_hierarchy$ in these tests.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN
Coverage:
open Sort;

sort string_order (map fst (get_mt_results()));

all_different (map fst (get_mt_results()));


