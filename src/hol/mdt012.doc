=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for the Abstract Data Type $THM$}  %% Mandatory field
\def\TPPheadtitle{Module Tests for the Interface to the Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/MDT012}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the 
the abstract data type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue 1.1]
First draft version.
\item [Issue 1.2]
Updated to issue 1.5 of \cite{DS/FMU/IED/DTD012}.
\item [Issue 1.3]
Updated to issue 1.6 of \cite{DS/FMU/IED/DTD012}.
\end{description}
\subsection{Changes forecast}
Many.
Use of DJK test harness work.
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the the Abstract Data Type $THM$, required by Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The design is in \cite{DS/FMU/IED/DTD012}
and it is
implemented in \cite{DS/FMU/IED/IMP012}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD012},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD012},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP012}.
\subsubsection{Deficiencies}
The coverage of the tests, as called for by the test specification, may currently be incomplete.
\section{UTILITIES}
=SML
PolyML.print_depth 10;
=TEX
Get the structures (we open icl'Kernel for the inference rules alone).
We want to test in the context of empty theories so:
=SML
local
	val side_effect =  usefile "imp006";
	val side_effect =  usefile "imp012";
in
	open icl'Kernel;
	open KernelInterface;
end;
=TEX
We provide a list of diagnostic printing functions. 
Those called $string\_of\_\ldots$ turn objects of various significant types ($TERM$, $THM$, etc)
into strings,
those called $print\_\ldots$ apply $diag\_string$ to the output
of the associated $string\_of\_\ldots$.
=SML
fun âstring_of_typeá (t: TYPE) : string = (
let
	fun aux ty = (
	if is_vartype ty then 
		(" " ^ dest_vartype ty)
	else if is_funtype ty then
		(let val(t1,t2) = dest_funtype ty
		in
		("(" ^ aux t1 ^ " ‹" ^ aux t2 ^")" )
		end)
	else (let 
		fun aux1 ("‰",[t1,t2]) = (
		"(" ^ aux t1 ^ " ‰" ^ aux t2 ^")"
		) | aux1 ((s,[])) = (
		" " ^ s
		) | aux1 ((s,tyl)) = (
		"((" ^ implode (map ((fn x => x ^", ") o aux) tyl)^ ")" ^ s ^ ")")
		in
			aux1 (dest_type ty)
		end)
	)
in
	(":" ^ aux t)
end);
val âprint_typeá = diag_line o string_of_type;

local
	fun simple_print_dest_term (Comb(t1,t2)) = (
	"Comb (" ^ simple_print_dest_term(simple_dest_term t1) ^", " ^
		simple_print_dest_term(simple_dest_term t2) ^ ")"
) | simple_print_dest_term (Const(s,ty)) = s ^ string_of_type ty
| simple_print_dest_term (Var(s,ty)) = s ^ string_of_type ty
| simple_print_dest_term (Abs(v,b)) = (
	let val (vs,vt) = dest_var v
	in
	" " ^ vs ^ string_of_type vt ^ " Ž " ^ simple_print_dest_term (simple_dest_term b)
	end);
in

fun âstring_of_termá (tm : TERM) = simple_print_dest_term (simple_dest_term tm);

fun âprint_termá (tm: TERM) = diag_line(string_of_term tm);
end;
=TEX
We also provide a pair of functions on $TERM$ that don't give the type information.
=SML
local fun simple_print_dest_term (Comb(t1,t2)) = (
	"(" ^ simple_print_dest_term(simple_dest_term t1) ^ " " ^
		simple_print_dest_term(simple_dest_term t2) ^ ")"
) | simple_print_dest_term (Const(s,ty)) = s
| simple_print_dest_term (Var(s,ty)) = s
| simple_print_dest_term (Abs(v,b)) = (
	let val (vs,vt) = dest_var v
	in
	"( " ^ vs ^ " Ž " ^ simple_print_dest_term (simple_dest_term b) ^")"
	end);
in
	fun âstring_of_term1á (tm: TERM): string = (
		simple_print_dest_term (simple_dest_term tm)
	);

	fun âprint_term1á (tm: TERM): unit = diag_line(string_of_term1 tm);

	fun âstring_of_seqá ((tml , tm): SEQ) : string = (
		format_list string_of_term1 tml ", " ^
		"… " ^ string_of_term1 tm
	);

	fun âprint_seqá (seq: SEQ) : unit = diag_line(string_of_seq seq);
end;

fun âstring_of_thmá (thm : THM) : string = (
	"In theory "^ thm_theory thm ^ ":" ^
	string_of_seq (dest_thm thm)
);

fun âprint_thmá (thm : THM) : unit = diag_line(string_of_thm thm);

local
	val I = Combinators.I;
in
fun âstring_of_thyá (nm : string) : string = (
	"\nName: " ^ (if nm = "-"
		then get_current_theory_name ()
		else nm) ^ ", " ^ 
	(case (get_theory_status nm) of
	TSNormal => "Status: Normal, "
	| TSDeleted => "Status: Deleted, "
	| TSLocked => "Status: Locked, "
	| TSAncestor => "Status: Ancestor, ") ^ "\n" ^
	"Parents: " ^ format_list I (get_parents nm) ", "  ^
	"; Children: " ^ format_list I (get_children nm) ", " ^ 
	"\n" ^
	format_list I (
	["***Types***"] @
	map string_of_type (get_types nm) @
	["***Constants***"] @
	map string_of_term (get_consts nm) @
	["***Theorems***"] @
	(map (fn (nl,thm) => format_list I nl ", " ^ ":" ^ string_of_thm thm)
		(get_thms nm)) @
	["***Definitions***"] @
	(map (fn (nl,thm) => format_list I nl ", " ^ ":" ^ string_of_thm thm)
		(get_defns nm)) @
	["***Axioms***"] @
	(map (fn (nl,thm) => format_list I nl ", " ^ ":" ^ string_of_thm thm)
		(get_axioms nm))) "\n");
end;

fun âprint_thyá (nm : string) : unit = diag_line(string_of_thy nm);

fun âprint_all_thyá (():unit) : unit = (
	map print_thy (theory_names());
	()
);

=TEX
\section{THE TESTS}
We give rise to various errors, which we don't want 
$usefile$ to halt loading on, so:
=SML
set_flag("usefile_non_stop_mode",true);
=TEX
Neither do we wish to fail on warning messages (for the
most part):
=SML
set_flag("ignore_warnings",true);
=TEX
Put in a kernel state change notifier that prints a message:
=SML
local val I = Combinators.I;
in
fun âtell_kscá ((OpenTheory (ot,(intos,outofs))) : KERNEL_STATE_CHANGE) : unit = (
	diag_string("KSC:OpenTheory:" ^ ot ^"((" ^
		format_list I intos ", " ^"),("^
		format_list I outofs ", " ^"))")
) | tell_ksc (DeleteTheory thy) = (
	diag_string("KSC:DeleteTheory:"^thy)
) | tell_ksc (NewTheory thy) = (
	diag_string("KSC:NewTheory:"^thy)
) | tell_ksc (NewParent (thy, intos)) = (
	diag_string("KSC:NewParent:" ^ thy ^"(" ^
		format_list I intos ", " ^")")
) |tell_ksc (LockTheory thy) = (
	diag_string("KSC:LockTheory:"^thy)
) | tell_ksc (UnlockTheory thy) = (
	diag_string("KSC:UnlockTheory:"^thy)
) | tell_ksc (DuplicateTheory (thy1,thy2)) = (
	diag_string("KSC:DuplicateTheory:"^thy1^" , "^thy2)
) | tell_ksc (SaveThm (key,thm)) = (
	diag_string("KSC:SaveThm:"^key^":"^string_of_thm thm)
) | tell_ksc (ListSaveThm (keys,thm)) = (
	diag_string("KSC:ListSaveThm:"^
		format_list I keys ", " ^":"^string_of_thm thm)
) | tell_ksc (DeleteConstant tm) = (
	diag_string("KSC:DeleteConstant:"^string_of_term tm)
) | tell_ksc (DeleteType ty) = (
	diag_string("KSC:DeleteType:"^ty)
) | tell_ksc (DeleteAxiom ty) = (
	diag_string("KSC:DeleteAxiom:"^ty)
) | tell_ksc (DeleteThm nm) = (
	diag_string("KSC:DeleteThm:"^nm)
) | tell_ksc (NewConst (nm,ty)) = (
	diag_string("KSC:NewConst:"^nm^":"^string_of_type ty)
) | tell_ksc (NewType (nm,ar)) = (
	diag_string("KSC:NewType:"^nm^":"^string_of_int ar)
) | tell_ksc (SimpleNewDefinition((key, cnm,tm),thm)) = (
	diag_string("KSC:SimpleNewDefinition:"^key^":"^cnm^":"^string_of_term1 tm^
		":" ^ string_of_thm thm)
) | tell_ksc (NewTypeDefn((key, tnm,typars,dthm),thm)) = (
	diag_string("KSC:SimpleNewDefinition:"^key^":"^tnm^":"^
		format_list I typars ", " ^
		":" ^ string_of_thm thm)
) | tell_ksc (NewSpecification((keys, n, dthm),thm)) = (
	diag_string("KSC:NewSpecification:"^
		format_list I keys ", " ^
		":" ^ string_of_int n^ ":" ^string_of_thm dthm ^
		":" ^ string_of_thm thm)
) | tell_ksc (NewAxiom((key, tm),thm)) = (
	diag_string("KSC:NewAxiom:"^key^":"^string_of_term1 tm^
		":" ^ string_of_thm thm)
) | tell_ksc (SetUserDatum (nm,ud)) = (
	diag_string("KSC:SetUserDatum:"^nm)
);
end;

on_kernel_state_change tell_ksc;
=TEX
Our initial hierarchy of (empty) theories:
=SML
print_all_thy ();
new_theory "next";
print_thy "-";
open_theory "min";
new_theory "another";
open_theory "next";
new_theory "yet_again";
new_theory "yet_again"; (* fails *)
open_theory "next";

print_all_thy ();
=TEX
The tests proper:
=SML
val v1 = mk_var("v1", BOOL);
val v2 = mk_var("v2", BOOL);
local
	val thm1 = icl'Kernel.icl'simple_list_ƒ_elim [v1]
		(icl'Kernel.icl'asm_rule(simple_mk_ƒ(v2,v2)))
in
	val res1 = ([simple_mk_ƒ(v2,v2)] = hyps thm1);
	val res2 = (v1 = concl thm1);
end;
val tv1 = mk_vartype "'1";
val tv2 = mk_vartype "'2";
new_type("BOOL",0);
print_thy("next");
new_type ("†",0);
new_type ("†",0); (* fails *)
print_thy("next");
val n1 = list_save_thm(["n1"], icl'asm_rule v1);
val n1 = list_save_thm(["n1"], icl'asm_rule v1); (* fails *)
val n1 = list_save_thm([], icl'asm_rule v1); (* fails *)
print_thy("-");
val n23 = list_save_thm(["n2","n3"], icl'asm_rule v1);
print_thy("-"); (* n23  accumulates with n1 *)
val n45 = list_save_thm(["n4","n5"], icl'asm_rule v2);
print_thy("-");
open_theory "another";
list_save_thm(["n2"], icl'asm_rule v1); (* fails *)
save_thm("n2", icl'asm_rule v1); (* fails *)
open_theory "next";
new_type("‰",2);
new_type("‹",2);
new_type("rubbish",~1);
val N0 = mk_† 0;
val N1 = mk_† 1;
val N2 = mk_† 2;
val T = new_const("T",BOOL);
val F = new_const("F",BOOL);
print_thy("next");
val n6 = save_thm("n6", n1);
val n1 = save_thm("n1", n1); (* fails *)
print_thy("-");
open_theory "min";
new_type("‰",2); (* fails *)
val UNIT = new_type ("UNIT",0);
val Unit = new_const("Unit",UNIT);
print_thy("min");
open_theory "next";
val AlsoUnit = new_const("AlsoUnit",UNIT);
open_theory "min";
new_const("AlsoUnit",UNIT); (* fails *)
simple_new_defn("AlsoUnit","AlsoUnit", Unit); (* fails *)
val AlsoUnit = new_const("AlsoUnit",UNIT);
open_theory "yet_again";
val n3 = save_thm("n3", n1);
print_thy("-");
open_theory "another";
new_type("BOOL",0);
val T = new_const("T",BOOL);
val F = new_const("F",BOOL);

print_thy("another");
delete_const F;
print_thy("-");
new_const("F",BOOL);
val s1 = list_save_thm(["s1"], icl'asm_rule v1);
print_thy("another");
delete_const (mk_const("F",tv1)); (* fails *)
delete_const (mk_var("F",tv1)); (* fails *)
set_flag("ignore_warnings",false);
delete_const F; (* fails *)
set_flag("ignore_warnings",true);
delete_const F; 
print_thy("-");
delete_const T;
print_thy("-");
val TorF = new_const("TorF",BOOL);
new_const("TorF",BOOL); (* fails *)
new_const("TypeWrong",mk_type("TYPEWRONG",[])); (* fails *)
print_thy("-");
delete_type "rubbish"; (* fails *)
delete_axiom "rubbish"; (* fails *)
set_flag("ignore_warnings",false);
delete_type "BOOL"; (* fails *)
set_flag("ignore_warnings",true);
delete_type "BOOL";
print_thy("-");

open_theory "yet_again";
val truth_axiom = new_axiom("truth_axiom",T);
print_thy("yet_again");
new_axiom("truth_axiom",T); (* fails *)
new_axiom("not so", F);
new_axiom("testing",mk_const("rubbish",BOOL)); (* fails *)
new_axiom("testing",mk_comb(mk_var("f",mk_fun(BOOL,BOOL)), T)); 
print_thy("yet_again");
open_theory "another";
new_axiom("testing2",mk_comb(mk_var("f",mk_fun(BOOL,BOOL)), T)); (* fails *)
open_theory "yet_again";
new_axiom("testing2",mk_comb(mk_const("f",mk_fun(BOOL,BOOL)), T)); (* fails *)
new_axiom("Rubbish",N0); (* fails *)
let val t = mk_type("rubbish",[])
in
new_axiom("testing2",mk_comb(mk_var("f",mk_fun(t,BOOL)), mk_var("x",t)))
end; (* fails *)
=TEX
Test locking:
=SML
lock_theory "yet_again";
new_axiom("Truth_Axiom",T); (* fails *)
new_const("ForT",BOOL); (* fails *)
new_type("SOMETHING",3); (* fails *)
list_save_thm(["Example"],icl'asm_rule v1); (* fails *)
save_thm("Example1",icl'asm_rule v1); (* fails *)
unlock_theory "yet_again";
new_axiom("Truth_Axiom",T);
val ForT = new_const("ForT",BOOL); (* fails *)
new_type("SOMETHING",3); (* fails *)
list_save_thm(["Example"],icl'asm_rule v1);
save_thm("Example1",icl'asm_rule v1);
lock_theory "yet_again";
delete_axiom "Truth_Axiom"; (* fail *)
delete_thm "Example"; (* fail *)
delete_type "SOMETHING"; (* fail *)
delete_const ForT; (* fail *)
set_user_datum ("testing",UD_String ("a test",[])); (* fail *)
unlock_theory "yet_again";
delete_type "SOMETHING"; (* fail *)
delete_const ForT; (* fail *)
delete_axiom "Truth_Axiom"; (* fail *)

set_user_datum ("testing",UD_String ("a test",[]));
get_user_datum "-" "testing";
get_user_datum "yet_again" "testing";
get_user_datum "rubbish" "testing";
get_user_datum "-" "rubbish";
delete_thm "Example";
=TEX
Test the multiple deletion effects of the delete extension
functions.
=SML
new_const("just_passing",BOOL);
delete_const ForT;
new_type("just_passing2",1);
delete_type "just_passing2";
new_axiom("just_passing3",T);
set_flag("ignore_warnings",false);
delete_axiom "just_passing3"; (* fails *)
set_flag("ignore_warnings",true);
delete_axiom "just_passing3";

print_thy("-");
open_theory "min";
delete_const (mk_const("Unit",UNIT)); (* fails *)
delete_type "UNIT"; (* fails *)
open_theory "next";
delete_type "BOOL"; (* fails *)
open_theory "another";
open_theory "rubbish";
open_theory "next";
new_theory "to_be_deleted";
print_thy("to_be_deleted"); 
val thy_deleted_thm = save_thm("thy_deleted_thm",icl'asm_rule v1);
open_theory "next";
delete_theory "to_be_deleted";
thm_theory thy_deleted_thm;
get_theory_status("to_be_deleted"); (* fails *)
print_all_thy();
open_theory "to_be_deleted"; (* fails *)

delete_theory "to_be_deleted"; (* fails *)
new_theory "to_be_deleted"; (* succeeds! *)
print_thy("to_be_deleted");
open_theory "min";
delete_theory "to_be_deleted"; 

delete_theory "min"; (* fails *)
lock_theory "yet_again";
print_thy("yet_again");
delete_theory "yet_again"; (* fails *)
lock_theory "yet_again"; (* fails *)
unlock_theory "yet_again";
open_theory "yet_again";
delete_theory "yet_again"; (* fails *)
lock_theory "to_be_deleted"; (* fails *)
lock_theory "rubbish"; (* fails *)
unlock_theory "to_be_deleted"; (* fails *)
unlock_theory "rubbish"; (* fails *)
unlock_theory "yet_again"; (* fails *)
print_thy("next");
duplicate_theory ("next", "copy_of_next");
print_thy("copy_of_next");
duplicate_theory ("rubbish", "copy_of_next"); (* fails *)
duplicate_theory ("rubbish", "copy_of_rubbish"); (* fails *)
duplicate_theory ("to_be_deleted", "copy_of_rubbish"); (* fails *)
delete_thm "rubbish"; (* fails *)
list_save_thm(["s2"], thy_deleted_thm); (* fails *)
simple_new_defn ("True","True",T);
simple_new_defn ("True","True1",T); (* fails *)
simple_new_defn ("False","False",F);
print_thy("-");
simple_new_defn ("0","0",mk_const("0",†)); (* fails *)
val zero_def = simple_new_defn ("Zero","Zero",mk_† 0);
val Zero = mk_const("Zero",†);
print_thy("-");
delete_const Zero;
print_thy("-");
simple_new_defn ("False","False",mk_const("F",BOOL)); (* fails *)
simple_new_defn ("Somewhere","Somewhere",mk_const("Somehow",BOOL)); (* fails *)
lock_theory "-";
simple_new_defn ("Somewhere","Somewhere",mk_const("False",BOOL));
unlock_theory "-";
simple_new_defn ("Somewhere","Somewhere",mk_var("Somehow",BOOL)); (* fails *)
new_const("Everywhere",tv1);

simple_new_defn ("Somewhere","Somewhere",
	mk_comb(
	simple_mk_abs(mk_var("Somehow",tv1),T),
	mk_const("Everywhere",tv1)
		)); (* fails *)
open_theory "next";
new_const("=",mk_fun(tv1, mk_fun(tv1, BOOL)));
new_const("„",mk_fun(mk_fun(tv1,BOOL),BOOL));
new_const("ƒ",mk_fun(mk_fun(tv1,BOOL),BOOL));
new_const("TypeDefn",mk_fun(mk_fun(tv1,BOOL),
	mk_fun(mk_fun(tv2,tv1),BOOL)));
val Tv1Pred = new_const("Tv1Pred",mk_fun(tv1,BOOL));
open_theory "yet_again";

local val x= mk_var("x",tv1)
in
val etype_exax = new_axiom("etype_exax",
	simple_mk_„(x,mk_comb(Tv1Pred,x)))
end;
val etype_def = new_type_defn(  "ETYPE", "ETYPE", ["'1"], etype_exax);
val etype_def = new_type_defn(  "ETYPE", "ETYPE1", ["'1"], etype_exax);
print_thm etype_def;
print_thy("-");
local val x= mk_var("x",tv2)
in
val etype2_exax = new_axiom("etype2_exax",
	simple_mk_„(x,mk_comb(icl'inst [] [(tv2,"'1")]Tv1Pred,x)))
end;
val etype2_def = new_type_defn(  "ETYPE2", "ETYPE2", ["'2"], etype2_exax);
lock_theory "-";
new_type_defn(  "ETYPE2a", "ETYPE2a", ["'2"], etype2_exax); (* fails *)
unlock_theory "-";
new_type_defn(  "ETYPE2a", "ETYPE2a", ["'2"], etype2_exax);
new_type_defn(  "ETYPE2c", "ETYPE2c", ["'1"], etype2_exax); (* fails *)
new_type_defn(  "ETYPE2a", "ETYPE2b", ["'2"], etype2_exax); (* fails *)
new_type_defn(  "ETYPE2b", "ETYPE2b", ["'2"], 
	icl'asm_rule(snd(dest_thm etype2_exax))); (* fails *)
local val x= mk_var("x",tv2);
	val y= mk_var("y",tv2)
in
val etype6_exax = new_axiom("etype6_exax",
	simple_mk_„(x,mk_comb(icl'inst [] [(tv2,"'1")]Tv1Pred,y)))
end;
new_type_defn(  "ETYPE6", "ETYPE6", ["'2"], etype6_exax); (* fails *)

print_thy("-");
new_type_defn(  "rubbish", "BOOL", [], etype2_exax); (* fails *)
open_theory "min";
new_type_defn(  "rubbish", "BOOL", [], etype2_exax); (* fails *)
open_theory "yet_again";
new_type_defn(  "rubbish", "rubbish", [], thy_deleted_thm); (* fails *)

local val x= mk_var("x",tv2)
in
val etype3_exax = new_axiom("etype3_exax",
	simple_mk_ƒ(x,mk_comb(icl'inst [] [(tv2,"'1")]Tv1Pred,x)))
end;
val etype3_def = new_type_defn(  "ETYPE3", "ETYPE3", ["'2"], etype3_exax); (* fails *)
local val x= mk_var("x",tv1);
	val y= mk_const("Everywhere",tv1);	
in
val etype4_exax = new_axiom("etype4_exax",
	simple_mk_„(x,mk_comb(Tv1Pred,y)))
end;
val etype4_def = new_type_defn(  "ETYPE4", "ETYPE4", ["'1"], etype4_exax); (* fails *)
local val x= mk_var("x",tv1);
	val y= mk_const("Everywhere",tv1);	
in
val etype5_exax = new_axiom("etype5_exax",
	simple_mk_„(x,T))
end;
val etype5_def = new_type_defn(  "ETYPE5", "ETYPE5", ["'1"], etype5_exax); (* fails *)
new_type_defn(  "ETYPE6", "ETYPE6", ["'2","'2"], etype2_exax); (* fails *)
new_type_defn(  "ETYPE8", "ETYPE8", [], 
	icl'asm_rule(mk_const("rubbish",BOOL))); (* fails *)

open_theory "next";
new_const("Š",mk_fun(BOOL,mk_fun(BOOL,BOOL)));
local
	val So = mk_var("So",BOOL);
	val IsSo = mk_var("IsSo",BOOL)
in
	val so_isso_axiom = new_axiom("so_isso_axiom",
		list_mk_„([So,IsSo],mk_Š(So,IsSo)));
end;
open_theory "yet_again";
lock_theory "-";
val so_isso_def = new_specification (["So","IsSo"],2,so_isso_axiom); (* fails *)
unlock_theory "-";
val so_isso_def = new_specification (["So","IsSo"],2,so_isso_axiom);
new_specification (["Soa","IsSoa"],2,so_isso_axiom); (* fails *)
new_specification (["Soa","IsSoa"],2,icl'asm_rule(mk_const("rubbish",BOOL))); (* fails *)
open_theory "next";
new_specification (["Soa","IsSoa"],2,so_isso_axiom); (* fails *)
open_theory "yet_again";
val xx_ax = new_axiom("xx_ax",simple_mk_„(v1,simple_mk_„(v1,T)));
new_specification (["X"],2,xx_ax);
local val x = mk_var("x",tv1);
	val y = mk_var("y",tv2);
in
val xy_ax = new_axiom("xy_ax",simple_mk_„(x,simple_mk_„(y,T)))
end;
new_specification (["X","Y"],2,xy_ax); (* fails *)
local val x = mk_var("x",tv1);
in
val v1_ax = new_axiom("v1_ax",simple_mk_„(v1,
	simple_mk_ƒ(x,mk_eq(x,x))))
end;
new_specification (["V1"],1,v1_ax);


print_thy("-");
val x_def = new_specification (["x"],1,etype5_exax);
print_thy("-");
new_specification ([],1,etype5_exax); (* fails *)
new_specification (["x1"],0,etype5_exax); (* fails *)
new_specification (["x1"],1,etype5_exax); (* fails *)
local val y = mk_var("y",BOOL)
in
val y_ax = new_axiom("y_ax",mk_„(y,T))
end;
new_specification (["x"],1,y_ax); (* fails *)
new_specification (["x2"],1,icl'asm_rule(mk_„(v1,T))); (* fails *)
new_specification (["x1"],1,etype3_exax); (* fails *)
local val p= mk_var("p",tv1);
	val q= mk_var("q",BOOL);	
in
val pq_ax = new_axiom("pq_ax",simple_mk_„(p,q))
end;
new_specification (["x1"],1,pq_ax); (* fails *)
new_specification (["x3"],1,thy_deleted_thm);
open_theory "another";
val NEWTYPE = new_type("NEWTYPE",1);
val NewThing = new_const("NewThing",NEWTYPE);
open_theory "yet_again";
list_save_thm(["x3"],icl'asm_rule(mk_eq(NewThing, NewThing))); (* fails *)
lock_theory "-";
new_parent "another"; (* fails *)
unlock_theory "-";
new_parent "another";
print_thy "-";
new_parent "rubbish";
list_save_thm(["x3"],icl'asm_rule(mk_eq(NewThing, NewThing))); (* succeeds *)

print_all_thy();
open_theory "min";
new_theory "test";
val F' = new_const("F",UNIT);
open_theory "yet_again";
new_parent "test"; (* fails *)
new_parent "min"; (* fails *)
open_theory "min";
new_parent "yet_again"; (* fails *)
print_thy "min";
get_current_theory_status();
get_theory_status "min";
lock_theory "-";
get_current_theory_status();
get_theory_status "min";
unlock_theory "-";
=TEX
Test hooks into environments.
=SML
open_theory "yet_again";
get_const_type "5"; (* built in *)
get_const_type "T";
get_const_type "TorF"; (* Nil *)
get_const_type "rubbish"; (* Nil *)
get_type_arity "BOOL";
get_type_arity "†";
get_type_arity "‹";
get_type_arity "rubbish"; (* Nil *)
=TEX
We can presume successful uses of $get\_thms$, $get\_axioms$, $get\_defns$, $get\_types$, $get\_consts$, $get\_parents$, $get\_children$
are all well tested by $print\_theory$.
The remainder of their kin are tested as follows:
=SML
get_thm "yet_again" "Example1";
get_thm "yet_again" "rubbish";
get_thm "rubbish" "Example1";
get_defn "yet_again" "So";
get_defn "yet_again" "rubbish";
get_defn "rubbish" "So";
get_axiom "yet_again" "pq_ax";
get_axiom "yet_again" "rubbish";
get_axiom "rubbish" "pq_ax";
=TEX
Check for out of scope:
=SML
open_theory "min";
get_thm "yet_again" "Example1";
get_defn "yet_again" "So";
get_axiom "yet_again" "pq_ax";
open_theory "yet_again";
get_ancestors "rubbish"; (* fail *)
get_ancestors "yet_again";
get_ancestors "min";
is_ancestor "min" "-";
is_ancestor "min" "yet_again";
is_ancestor "yet_again" "min";
is_ancestor "-" "min";
is_ancestor "rubbish" "min"; (* fails *)
is_ancestor "-" "rubbish"; (* fails *)
get_descendants "next";
get_descendants "rubbish";
get_parents "rubbish";
get_children "rubbish";
get_thms "rubbish";
get_axioms "rubbish";
get_defns "rubbish";
get_consts "rubbish";
get_types "rubbish";
get_current_theory_status ();
=TEX
Test the built in scopes:
=SML
new_const("1",BOOL); (* fails *)
new_const("123",BOOL); (* fails *)
new_const("12a",BOOL); (* succeeds! *)
new_const("'a",BOOL); (* fails *)
new_const("'abc",BOOL); (* succeeds! *)
new_const("\"a",BOOL); (* fails *)
new_const("\"abc",BOOL); (* fails *)
=TEX
Tests on hierarchies : do after all others, as things are made read only.
=SML
val newhier = icl'new_hierarchy();
get_current_theory_status ();
map get_theory_status (theory_names ());
new_axiom("Truth_axiom1",T); (* fails *)
new_const("ForT1",BOOL); (* fails *)
new_type("SOMETHING1",3); (* fails *)
simple_new_defn ("True1","True1",T); (* fails *)
delete_const (mk_const("False",BOOL)); (* fails *)
delete_type "ETYPE"; (* fails *)
delete_axiom "pq_ax"; (* fails *)
list_save_thm(["Example1"],icl'asm_rule v1); (* fails *)
save_thm("Example1",icl'asm_rule v1); (* fails *)
delete_thm "Example";
delete_theory "yet_again"; (* fails *)
lock_theory "yet_again"; (* fails *)
new_parent "another"; (* fails *)
set_user_datum ("testing",UD_String ("a test",[]));
new_type_defn(  "ETYPE7", "ETYPE7", ["'1"], etype_exax); (* fails *)
new_specification (["So1","IsSo1"],2,so_isso_axiom); (* fails *)
=TEX
\subsection{End of Tests}
=SML
set_flag("usefile_non_stop_mode",false);
(* PolyML.quit(); *)
=TEX
\section{UNTESTED ERROR MESSAGES}
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
=TEX
\end{document}
