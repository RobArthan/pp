=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for the Abstract Data Type $THM$}  %% Mandatory field
\def\TPPheadtitle{Module Tests for the Interface to the Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/MDT012}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the 
the abstract data type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue 1.1]
First draft version.
\item [Issue 1.2]
Updated to issue 1.5 of \cite{DS/FMU/IED/DTD012}.
\item [Issue 1.3]
Updated to issue 1.6 of \cite{DS/FMU/IED/DTD012}.
\item [Issue 1.4]
Clears out theory hierarchy, rather than reloading imp006.
\item [Issue 1.5]
Updated to issue 1.9 of \cite{DS/FMU/IED/DTD012}.
Used material from \cite{DS/FMU/IED/DTD013}.
\item [Issue 1.6]
Removed the use of $t\_thm$.
\item [Issue 1.7]
Changed as result of changes caused by IR0016.
\item [Issue 1.8]
Reacting to issue 1.18 of \cite{DS/FMU/IED/DTD006}.
\item [Issue 1.9]
Putting in necessary syntactic details, responses to ID0012.
\item [Issue 1.10]
Returned SCCS keywords.
\item [Issue 1.11]
Correcting typos, and what were 6038 messages.
\item [Issue 1.12]
Renamings of functions containing the name atom $simple$,
and renaming of $aconv$.
\item [Issue 1.13]
Added test for clashes in children theories for $new\_parent$.
Protected use of $declare\_alias$ against errors.
Corrected a test of error 6038 in $list\-\_save\-\_thm$.
\item [Issue 1.14]
Tidying up in preparation for a desk check.
\end{description}
\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the the Abstract Data Type $THM$, required by Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The design is in \cite{DS/FMU/IED/DTD012}
and it is
implemented in \cite{DS/FMU/IED/IMP012}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD012},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.
It uses the test harness material of \cite{DS/FMU/IED/DTD013}
where appropriate.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD012},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP012}.
It requires a HOL prettyprinter to be installed before
it will successfully match the output of some error tests
with the required output.
\subsubsection{Deficiencies}
The coverage of the tests, as called for by the test specification, may currently be incomplete.
\section{UTILITIES}
Neither do we wish to fail on warning messages (for the
most part):
=SML
set_flag("ignore_warnings",true);
=TEX
Initialise the test package:
=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results();
=TEX
We want to test in the context of empty theories,
and at least the icl'Kernel so:
=SML
open_theory "min";
map (fn x => delete_theory x 
	handle (Fail _) => ()) (theory_names());
map (fn x => delete_theory x 
	handle (Fail _) => ()) (theory_names());
delete_type "ã" handle (Fail _) => (); 
=TEX
N.B. theories used in this document become read-only ancestors,
and so cannot be deleted by the above.

We provide a list of diagnostic printing functions. 
Those called $string\_of\_\ldots$ turn objects of various significant types ($TERM$, $THM$, etc)
into strings,
those called $print\_\ldots$ apply $diag\_string$ to the output
of the associated $string\_of\_\ldots$.
=SML
local
	fun simple_print_dest_term (App(t1,t2)) = (
	"App (" ^ simple_print_dest_term(dest_simple_term t1) ^", " ^
		simple_print_dest_term(dest_simple_term t2) ^ ")"
) | simple_print_dest_term (Const(s,ty)) = s ^ string_of_type ty
| simple_print_dest_term (Var(s,ty)) = s ^ string_of_type ty
| simple_print_dest_term (Simpleç(v,b)) = (
	let val (vs,vt) = dest_var v
	in
	"ç " ^ vs ^ string_of_type vt ^ " é " ^ simple_print_dest_term (dest_simple_term b)
	end);
in

fun ‚string_of_term1· (tm : TERM) = simple_print_dest_term (dest_simple_term tm);
end;
=TEX
The following tests, by side effect, $get\-\_parents$, $get\-\_children$, $get\-\_theory\-\_status$, $get\-\_types$, $get\-\_consts$, $get\-\_thms$, $get\-\_defns$, and $get\-\_axioms$.
=SML
local
	val I = Combinators.I;
in
fun ‚string_of_thy· (nm : string) : string = (
	"\nName: " ^ (if nm = "-"
		then get_current_theory_name ()
		else nm) ^ ", " ^ 
	(case (get_theory_status nm) of
	TSNormal => "Status: Normal, "
	| TSDeleted => "Status: Deleted, "
	| TSLocked => "Status: Locked, "
	| TSAncestor => "Status: Ancestor, ") ^ "\n" ^
	"Parents: " ^ format_list I (get_parents nm) ", "  ^
	"; Children: " ^ format_list I (get_children nm) ", " ^ 
	"\n" ^
	format_list I (
	["***Types***"] @
	map string_of_type (get_types nm) @
	["***Constants***"] @
	map string_of_term1 (get_consts nm) @
	["***Theorems***"] @
	(map (fn (nl,thm) => format_list I nl ", " ^ ":" ^ string_of_thm thm)
		(get_thms nm)) @
	["***Definitions***"] @
	(map (fn (nl,thm) => format_list I nl ", " ^ ":" ^ string_of_thm thm)
		(get_defns nm)) @
	["***Axioms***"] @
	(map (fn (nl,thm) => format_list I nl ", " ^ ":" ^ string_of_thm thm)
		(get_axioms nm))) "\n");
end;

fun ‚print_thy· (nm : string) : unit = diag_line(string_of_thy nm);

fun ‚print_all_thy· (():unit) : unit = (
	map print_thy (theory_names());
	()
);
=TEX
\section{VALUE BINDINGS}
=SML
val v1 = mk_var("v1", BOOL);
val v2 = mk_var("v2", BOOL);
val tv1 = mk_vartype "'tv1";
val tva = mk_vartype "'a";
val tv'1 = mk_vartype "'1";
val tv'2 = mk_vartype "'2";
val vtv1 = mk_var("vtv1",tv1);
val v1 = mk_var("v1", BOOL);
val v2 = mk_var("v2", BOOL);
val N0 = mk_Ü 0;
val N1 = mk_Ü 1;
val N2 = mk_Ü 2;
val N3 = mk_Ü 3;
val N7 = mk_Ü 7;
val pB = mk_var("p",BOOL);
val qB = mk_var("q",BOOL);
val xB = mk_var("x",BOOL);
val p1 = mk_var("p",tv'1);
val q1 = mk_var("q",tv'1);
val pa = mk_var("p",tva);
val qa = mk_var("q",tva);
val qa' = mk_var("q'",tva);
val p11 = mk_var("p1",tv'1);
val q1B = mk_var("q1",BOOL);
val pa = mk_var("p",tva);
val thm1 = icl'Kernel.icl'list_simple_É_elim [v1]
	(icl'Kernel.icl'asm_rule(mk_simple_É(v2,v2)));
val h_thm1 = [mk_simple_É(v2,v2)];
val c_thm1 = v1;
val thm2 = icl'Kernel.icl'asm_rule v1;
val h_thm2 = [v1];
val c_thm2 = v1;
val thm3 = icl'Kernel.icl'asm_rule v2;
val h_thm3 = [v2];
val c_thm3 = v2;
val pB_thm = icl'Kernel.icl'asm_rule pB;
=TEX
$á$ is not declared as a new constant.
=SML
val ill_formed_thm = icl'Kernel.icl'asm_rule (mk_á(v1,v1));
=TEX
\section{THE TESTS}
\subsection{Kernel State Change Notifiers}
Put in a kernel state change notifier that prints a message:
=SML
local val I = Combinators.I;
in
fun ‚tell_ksc· (caller : string) ((OpenTheory (ot,(intos,outofs))) 
	: KERNEL_STATE_CHANGE) : unit = (
	diag_string(caller ^ "OpenTheory:" ^ ot ^"((" ^
		format_list I intos ", " ^"),("^
		format_list I outofs ", " ^"))")
) | tell_ksc caller (DeleteTheory thy) = (
	diag_string(caller ^ "DeleteTheory:"^thy)
) | tell_ksc caller (NewTheory thy) = (
	diag_string(caller ^ "NewTheory:"^thy)
) | tell_ksc caller (NewParent (thy, intos)) = (
	diag_string(caller ^ "NewParent:" ^ thy ^"(" ^
		format_list I intos ", " ^")")
) |tell_ksc caller (LockTheory thy) = (
	diag_string(caller ^ "LockTheory:"^thy)
) | tell_ksc caller (UnlockTheory thy) = (
	diag_string(caller ^ "UnlockTheory:"^thy)
) | tell_ksc caller (DuplicateTheory (thy1,thy2)) = (
	diag_string(caller ^ "DuplicateTheory:"^thy1^" , "^thy2)
) | tell_ksc caller (SaveThm (key,thm)) = (
	diag_string(caller ^ "SaveThm:"^key^":"^string_of_thm thm)
) | tell_ksc caller (ListSaveThm (keys,thm)) = (
	diag_string(caller ^ "ListSaveThm:"^
		format_list I keys ", " ^":"^string_of_thm thm)
) | tell_ksc caller (DeleteConst tm) = (
	diag_string(caller ^ "DeleteConstant:"^string_of_term1 tm)
) | tell_ksc caller (DeleteType ty) = (
	diag_string(caller ^ "DeleteType:"^ty)
) | tell_ksc caller (DeleteAxiom ty) = (
	diag_string(caller ^ "DeleteAxiom:"^ty)
) | tell_ksc caller (DeleteThm nm) = (
	diag_string(caller ^ "DeleteThm:"^nm)
) | tell_ksc caller (NewConst (nm,ty)) = (
	diag_string(caller ^ "NewConst:"^nm^":"^string_of_type ty)
) | tell_ksc caller (NewType (nm,ar)) = (
	diag_string(caller ^ "NewType:"^nm^":"^string_of_int ar)
) | tell_ksc caller (SimpleNewDefn((key, cnm,tm),thm)) = (
	diag_string(caller ^ "SimpleNewDefn:"^key^":"^cnm^":"^string_of_term tm^
		":" ^ string_of_thm thm)
) | tell_ksc caller (NewTypeDefn((key, tnm,typars,dthm),thm)) = (
	diag_string(caller ^ "SimpleNewDefn:"^key^":"^tnm^":"^
		format_list I typars ", " ^
		":" ^ string_of_thm thm)
) | tell_ksc caller (NewSpecification((keys, n, dthm),thm)) = (
	diag_string(caller ^ "NewSpecification:"^
		format_list I keys ", " ^
		":" ^ string_of_int n^ ":" ^string_of_thm dthm ^
		":" ^ string_of_thm thm)
) | tell_ksc caller (NewAxiom((key, tm),thm)) = (
	diag_string(caller ^ "NewAxiom:"^key^":"^string_of_term tm^
		":" ^ string_of_thm thm)
) | tell_ksc caller (SetUserDatum (nm,ud)) = (
	diag_string(caller ^ "SetUserDatum:"^nm)
);
end;

on_kernel_state_change (tell_ksc "OnKSC:" );
before_kernel_state_change (tell_ksc "BeforeKSC");
=TEX
We rely on visual inspection of the results to check the 
correct functioning of these notifiers.
\subsection{Initialisation of Theories}
We consider that the successful operation of $open\_theory$ and $new\_theory$ are tested implicitly through out the tests.
Our initial hierarchy of (empty) theories:
=SML
print_all_thy ();
store_mt_results mt_run [("get_current_theory_name 1",
	get_current_theory_name,
	(),
	"min")];
new_theory "next";
store_mt_results mt_run [("get_current_theory_name 2",
	get_current_theory_name,
	(),
	"next")];
print_thy "-";
open_theory "min";
new_theory "another";
open_theory "next";
new_theory "yet_again";
store_mt_results mt_run_fail [("new_theory 6040",
	new_theory,
	"yet_again",
	gen_fail_msg "new_theory" 6040 ["yet_again"])];
open_theory "next";

print_all_thy ();
store_mt_results mt_run [("theory_names",
	theory_names,
	(),
	["yet_again","another","next","min"])];
=TEX
The tests proper:
=SML
store_mt_results mt_run_fail [
	("open_theory 6035",
	open_theory,
	"rubbish",
	gen_fail_msg "open_theory" 6035 ["rubbish"])
	];
store_mt_results mt_run [("hyps 1",
	hyps,
	thm1,
	h_thm1),
	("hyps 2",
	hyps,
	icl'Kernel.icl'refl_conv mk_t,
	[])];
store_mt_results mt_run [("concl 1",
	concl,
	thm1,
	v1),
	("concl 2",
	concl,
	icl'Kernel.icl'refl_conv mk_t,
	mk_Ç(mk_t,mk_t))];
store_mt_results mt_run [("new_type 1",
	new_type,
	("BOOL",0),
	BOOL),
	("new_type 2",
	new_type,
	("Ü",0),
	Ü),
	("new_type 3",
	new_type,
	("ã",2),
	mk_ã_type(tv'1, tv'2))];
declare_infix (100, "ã");
print_thy("next");
store_mt_results mt_run_fail [
	("new_type 6045 a",
	new_type,
	("Ü",0),
	gen_fail_msg "new_type" 6045 ["Ü"]),
	("new_type 6088",
	new_type,
	("RUBBISH",~1),
	gen_fail_msg "new_type" 6088 [])
	];
store_mt_results mt_run [
	("new_const 6",
	new_const,
	("É",mk_ã_type(mk_ã_type(tv'1,BOOL),BOOL)),
	mk_const(("É",mk_ã_type(mk_ã_type(tv'1,BOOL),BOOL)))),
	("new_const 7",
	new_const,
	("Ñ",mk_ã_type(mk_ã_type(tv'1,BOOL),BOOL)),
	mk_const(("Ñ",mk_ã_type(mk_ã_type(tv'1,BOOL),BOOL))))
	];
declare_binder "É";
declare_terminator "É" handle _ => ();
declare_binder "Ñ";
declare_terminator "Ñ" handle _ => ();

val É_spec = new_axiom("É_spec",mk_Ñ(mk_var("É",BOOL),mk_É(v1,v1)));
store_mt_results mt_run_fail [
	("new_const 6049 e",
	new_const,
	("É",mk_ã_type(mk_ã_type(tv'1,BOOL),BOOL)),
	gen_fail_msg "new_const" 6049 ["É"]),
	("new_const 6013",
	new_const,
	("Rubbish",mk_ctype("RUBBISH",[])),
	gen_fail_msg "new_const" 6013 ["ª:RUBBISHº","RUBBISH"]),
	("new_const 6014",
	new_const,
	("Rubbish",mk_ctype("BOOL",[BOOL])),
	gen_fail_msg "new_const" 6014 ["ª:BOOL BOOLº","BOOL"])	];
store_mt_results mt_run_fail [
	("simple_new_defn 6049 a",
	simple_new_defn,
	("É_def","É",mk_t),
	gen_fail_msg "simple_new_defn" 6049 ["É"])
	];
store_mt_results mt_run_fail [
	("new_specification 6049 a",
	new_specification,
	(["É"],1,É_spec),
	gen_fail_msg "new_specification" 6049 ["É"])
	];

store_mt_results mt_run [
	("list_save_thm 1",
	dest_thm o list_save_thm,
	(["thm1"], thm1),
	(h_thm1,c_thm1)),
	("list_save_thm 2",
	dest_thm o list_save_thm,
	(["thm1a","thm1b"], thm1),
	(h_thm1,c_thm1))
	];
store_mt_results mt_run [
	("get_thms 1",
	map (Combinators.I ** dest_thm) o get_thms,
	"-",
	[(["thm1a","thm1b","thm1"],(h_thm1,c_thm1))])
	];
store_mt_results mt_run_fail [
	("list_save_thm 6031",
	list_save_thm,
	([], thm2),
	gen_fail_msg "list_save_thm" 6031 []),
	("list_save_thm 6013",
	list_save_thm,
	(["n2"], icl'Kernel.icl'refl_conv (mk_var("rv",mk_ctype("rubbish",[])))),
	gen_fail_msg "list_save_thm" 6013 ["Ö rv = rv","rubbish"]),
	("list_save_thm 6014",
	list_save_thm,
	(["n2"], icl'Kernel.icl'refl_conv (mk_var("rv",mk_ctype("BOOL",[BOOL])))),
	gen_fail_msg "list_save_thm" 6014 ["Ö rv = rv","BOOL"]),
	("list_save_thm 6015",
	list_save_thm,
	(["n2"], icl'Kernel.icl'asm_rule (mk_const("rv",BOOL))),
	gen_fail_msg "list_save_thm" 6015 ["rv Ö rv","rv"]),
	("list_save_thm 6038",
	list_save_thm,
	(["n2"], icl'Kernel.icl'asm_rule (mk_const("1",BOOL))),
	gen_fail_msg "list_save_thm" 6038 ["1 Ö 1","1"]),
	("list_save_thm 6039 a",
	list_save_thm,
	(["thm1"], thm2),
	gen_fail_msg "list_save_thm" 6039 ["thm1","next"]),
	("list_save_thm 6039 b",
	list_save_thm,
	(["thm2","thm1","thm2a"], thm2),
	gen_fail_msg "list_save_thm" 6039 ["thm1","next"])
	];
store_mt_results mt_run_fail [
	("save_thm 6039",
	save_thm,
	("thm1", thm2),
	gen_fail_msg "save_thm" 6039 ["thm1","next"])];
store_mt_results mt_run [
	("list_save_thm 3",
	dest_thm o list_save_thm,
	(["thm2a","thm2b"], thm2),
	(h_thm2,c_thm2))
	];
store_mt_results mt_run [
	("get_thms 2",
	map (Combinators.I ** dest_thm) o get_thms,
	"-",
	[(["thm2a","thm2b"],(h_thm2,c_thm2)),
	(["thm1a","thm1b","thm1"],(h_thm1,c_thm1))])
	];
store_mt_results mt_run [
	("save_thm",
	dest_thm o save_thm,
	("thm3", thm3),
	(h_thm3,c_thm3))
	];
=TEX
Test out a theory in which BOOL is not defined.
=SML
open_theory "another";
store_mt_results mt_run_fail [
	("list_save_thm 6013 b",
	list_save_thm,
	(["thm2"], thm2),
	gen_fail_msg "list_save_thm" 6013 ["v1 Ö v1","BOOL"])
	];
store_mt_results mt_run_fail [
	("save_thm 6013 c",
	save_thm,
	("thm2", thm2),
	gen_fail_msg "save_thm" 6013 ["v1 Ö v1","BOOL"])
	];
=TEX
Test for reaction to things already defined in the descendants.
=SML
open_theory "min";
store_mt_results mt_run_fail [
	("new_type 6034",
	new_type,
	("ã",2),
	gen_fail_msg "new_type" 6034 ["ã"])
	];
store_mt_results mt_run_fail [
	("new_const 6063",
	new_const,
	("É",tv'1),
	gen_fail_msg "new_const" 6063 ["É"])
	];
store_mt_results mt_run_fail [
	("new_type_defn 6034",
	new_type_defn,
	("ã_def","ã",[],thm1),
	gen_fail_msg "new_type_defn" 6034 ["ã"])
	];
store_mt_results mt_run_fail [
	("simple_new_defn 6063",
	simple_new_defn,
	("É_def","É",mk_t),
	gen_fail_msg "simple_new_defn" 6063 ["É"])
	];
=TEX
Unfortunately for our testing $new\_specification$ requires a valid theorem, so:
=SML
open_theory "yet_again";
new_const ("test_spec",BOOL);
open_theory "next";
val test_spec_ax = new_axiom("test_spec_ax",mk_Ñ(mk_var("test_spec",BOOL),mk_É(v1,v1)));
store_mt_results mt_run_fail [
	("new_specification 6063",
	new_specification,
	(["test_spec_def"],1,test_spec_ax),
	gen_fail_msg "new_specification" 6063 ["test_spec"])
	];
=TEX
Now test reaction to presence in ancestors:
=SML
open_theory "yet_again";
store_mt_results mt_run_fail [
	("new_type 6045 c",
	new_type,
	("ã",2),
	gen_fail_msg "new_type" 6045 ["ã"])
	];
store_mt_results mt_run_fail [
	("new_const 6049 c",
	new_const,
	("É",tv'1),
	gen_fail_msg "new_const" 6049 ["É"])
	];
store_mt_results mt_run_fail [
	("new_type_defn 6045 c",
	new_type_defn,
	("ã_def","ã",[],thm1),
	gen_fail_msg "new_type_defn" 6045 ["ã"])
	];
store_mt_results mt_run_fail [
	("simple_new_defn 6049 b",
	simple_new_defn,
	("É_def","É",mk_t),
	gen_fail_msg "simple_new_defn" 6049 ["É"])
	];
store_mt_results mt_run_fail [
	("new_specification 6049 b",
	new_specification,
	(["É_def"],1,É_spec),
	gen_fail_msg "new_specification" 6049 ["É"])
	];
=TEX
Test out deletions($delete\_const$, $delete\_type$ and $delete\_axiom$, $delete\_thm$) by side effect:
=SML
open_theory "another";
store_mt_results mt_run [("new_type 4",
	new_type,
	("BOOL",0),
	BOOL)
	];
save_thm("example_delete_thm",pB_thm);
store_mt_results mt_run [("delete_thm",
	dest_thm o delete_thm,
	"example_delete_thm",
	dest_thm pB_thm)];
store_mt_results mt_run [
	("new_const 3",
	new_const,
	("T",BOOL),
	mk_const("T",BOOL)),
	("new_const 4",
	new_const,
	("F",BOOL),
	mk_const("F",BOOL))
	];
print_thy("another");
delete_const mk_f;
=TEX
Test for deletion of constant with same type up to renaming of type variables.
=SML
new_const ("test_delete_const",mk_vartype "'a");
delete_const (mk_const("test_delete_const",mk_vartype "'b"));
print_thy("-");
store_mt_results mt_run [
	("new_const 5",
	new_const,
	("F",BOOL),
	mk_const("F",BOOL))
	];
val s1 = list_save_thm(["s1"], icl'Kernel.icl'asm_rule v1);
print_thy("another");
store_mt_results mt_run_fail [
	("delete_const 12001",
	delete_const,
	(mk_const("F",tv1)),
	gen_fail_msg "delete_const" 12001 ["another","F"]),
	("delete_const 3009",
	delete_const,
	(mk_var("F",tv1)),
	gen_fail_msg "delete_const" 3009 ["ªFº"])
	];
=TEX
The following test in part relies on the visual inspection of the warning message given.
=SML
set_flag("ignore_warnings",false);
store_mt_results mt_run_fail [
	("delete_const 12012",
	delete_const,
	mk_f,
	gen_fail_msg "warn" 10003 ["delete_const"])
	];
set_flag("ignore_warnings",true);
delete_const mk_f; 
print_thy("-");
delete_const mk_t;
print_thy("-");
val TorF = new_const("TorF",BOOL);
print_thy("-");
store_mt_results mt_run_fail [
	("delete_type 12002",
	delete_type,
	"rubbish",
	gen_fail_msg "delete_type" 12002 ["another","rubbish"])];
store_mt_results mt_run_fail [
	("delete_axiom 12003",
	delete_axiom,
	"rubbish",
	gen_fail_msg "delete_axiom" 12003 ["another","rubbish"])];
store_mt_results mt_run_fail [
	("delete_thm 6046",
	delete_thm,
	"rubbish",
	gen_fail_msg "delete_thm" 6046 ["rubbish","another"])];

delete_type "BOOL";
print_thy("-");

open_theory "yet_again";
store_mt_results mt_run [
	("new_axiom",
	dest_thm o new_axiom,
	("É_axiom",mk_É(v1,v1)),
	([],mk_É(v1,v1)))
	];
print_thy("yet_again");
store_mt_results mt_run_fail [
	("new_axiom 6047",
	new_axiom,
	("É_axiom",mk_É(v1,v1)),
	gen_fail_msg "new_axiom" 6047 ["É_axiom","yet_again"]),
	("new_axiom 6015",
	new_axiom,
	("t_axiom",mk_t),
	gen_fail_msg "new_axiom" 6015 ["ªTº","T"]),
	("new_axiom 3031",
	new_axiom,
	("t_axiom",N0),
	gen_fail_msg "new_axiom" 3031 ["ª0º"])
	];

print_thy("yet_again");

=TEX
Test $lock\_theory$ and $unlock\_theory$ by side effect:
=SML
new_type ("SOMETHING",3);
new_const ("Something",BOOL);
lock_theory "yet_again";
store_mt_results mt_run_fail [("delete_theory 6037",
	delete_theory,
	"yet_again",
	gen_fail_msg "delete_theory" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("new_axiom 6037",
	new_axiom,
	("Truth_Axiom",mk_t),
	gen_fail_msg "new_axiom" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("new_const 6037",
	new_const,
	("ForT",BOOL),
	gen_fail_msg "new_const" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("new_type_defn 6037",
	new_type_defn,
	("ã_def","ã",[],thm1),
	gen_fail_msg "new_type_defn" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("simple_new_defn 6037",
	simple_new_defn,
	("É_def","É",mk_t),
	gen_fail_msg "simple_new_defn" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("new_specification 6037",
	new_specification,
	(["É_def"],1,É_spec),
	gen_fail_msg "new_specification" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("new_type 6037",
	new_type,
	("SOMETHING",3),
	gen_fail_msg "new_type" 6037 ["yet_again"])
	];
store_mt_results mt_run_fail [("list_save_thm 6037",
	list_save_thm,
	(["Example"],thm1),
	gen_fail_msg "list_save_thm" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("save_thm 6037",
	save_thm,
	("Example1",thm1),
	gen_fail_msg "save_thm" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("delete_axiom 6037",
	delete_axiom,
	"É_axiom",
	gen_fail_msg "delete_axiom" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("delete_thm 6037",
	delete_thm,
	"Example",
	gen_fail_msg "delete_thm" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("delete_type 6037",
	delete_type,
	"SOMETHING",
	gen_fail_msg "delete_type" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("delete_const 6037",
	delete_const,
	mk_const("Something",BOOL),
	gen_fail_msg "delete_const" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("set_user_datum 6037",
	set_user_datum,
	("testing",UD_String ("a test",[])),
	gen_fail_msg "set_user_datum" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("lock_theory 6037",
	lock_theory,
	"yet_again",
	gen_fail_msg "lock_theory" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("new_parent 6037",
	new_parent,
	"another",
	gen_fail_msg "new_parent" 6037 ["yet_again"])];
store_mt_results mt_run [
	("get_theory_status 1",
	get_theory_status,
	"yet_again",
	TSLocked)
	];
store_mt_results mt_run [
	("get_current_theory_status 1",
	get_current_theory_status,
	(),
	TSLocked)
	];

unlock_theory "yet_again";
store_mt_results mt_run [
	("get_theory_status 2",
	get_theory_status,
	"yet_again",
	TSNormal)
	];
=TEX
Test user data features of $set\_user\_data$ by side effect:
=SML
set_user_datum ("testing",UD_String ("a test",[]));
store_mt_results mt_run [
	("get_user_datum 1",
	get_user_datum "-",
	"testing",
	UD_String ("a test",[])),
	("get_user_datum 2",
	get_user_datum "yet_again",
	"testing",
	UD_String ("a test",[]))
	];

store_mt_results mt_run_fail [
	("get_user_datum 6035",
	get_user_datum "rubbish",
	"testing",
	gen_fail_msg "get_user_datum" 6035 ["rubbish"]),
	("get_user_datum 12009",
	get_user_datum "-",
	"rubbish",
	gen_fail_msg "get_user_datum" 12009 ["rubbish","-"])
	];
store_mt_results mt_run_fail [
	("lock_theory 6035",
	lock_theory,
	"rubbish",
	gen_fail_msg "lock_theory" 6035 ["rubbish"]),
	("unlock_theory 6035 a",
	unlock_theory,
	"rubbish",
	gen_fail_msg "unlock_theory" 6035 ["rubbish"])
	];
=TEX
Test the multiple deletion effects of the delete extension
functions.
=SML
val ForT = new_const("ForT",BOOL);
val just_passing = new_const("just_passing",BOOL);
=TEX
The following test in part relies on the visual inspection of the warning message given.
=SML
set_flag("ignore_warnings",false);
store_mt_results mt_run_fail [
	("delete_const 12012",
	delete_const,
	just_passing,
	gen_fail_msg "warn" 10003 ["delete_const"])
	];
set_flag("ignore_warnings",true);
delete_const ForT;
new_type("just_passing2",1);
=TEX
The following test in part relies on the visual inspection of the warning message given.
=SML
set_flag("ignore_warnings",false);
store_mt_results mt_run_fail [
	("delete_type 12012",
	delete_type,
	"just_passing2",
	gen_fail_msg "warn" 10003 ["delete_type"])
	];
set_flag("ignore_warnings",true);
delete_type "just_passing2";
new_axiom("just_passing3",v1);
=TEX
The following test in part relies on the visual inspection of the warning message given.
=SML
set_flag("ignore_warnings",false);
store_mt_results mt_run_fail [
	("delete_axiom 12012",
	delete_axiom,
	"just_passing3",
	gen_fail_msg "warn" 10003 ["delete_axiom"])
	];
set_flag("ignore_warnings",true);
delete_axiom "just_passing3";
=TEX
Can't delete if theory has children:
=SML
open_theory "next";
store_mt_results mt_run_fail [("delete_const 6076",
	delete_const,
	(mk_const("É",mk_ã_type(mk_ã_type(tv'1,BOOL),BOOL))),
	gen_fail_msg "delete_const" 6076 ["next"])];
store_mt_results mt_run_fail [("delete_type 6076",
	delete_type,
	"BOOL",
	gen_fail_msg "delete_type" 6076 ["next"])];
store_mt_results mt_run_fail [("delete_axiom 6076",
	delete_axiom,
	"É_spec",
	gen_fail_msg "delete_axiom" 6076 ["next"])];
open_theory "next";
store_mt_results mt_run [
	("thm_theory 1",
	thm_theory,
	thm1,
	"min"),
	("thm_theory 2",
	thm_theory,
	icl'Kernel.icl'asm_rule v1,
	"next")
	];
=TEX
Test $delete\_theory$ by side effect, rather than explicit test.
=SML
new_theory "to_be_deleted";
val del_thy_name = string_of_int(icl'Kernel.icl'get_current_theory_name());
print_thy("to_be_deleted"); 
val thy_deleted_thm = save_thm("thy_deleted_thm",icl'Kernel.icl'asm_rule v1);
open_theory "next";
delete_theory "to_be_deleted";

store_mt_results mt_run_fail [
	("thm_theory 12007",
	thm_theory,
	thy_deleted_thm,
	gen_fail_msg "thm_theory" 12007 ["v1 Ö v1",del_thy_name])
	];
store_mt_results mt_run_fail [
	("get_theory_status 6035 a",
	get_theory_status,
	"to_be_deleted",
	gen_fail_msg "get_theory_status" 6035 ["to_be_deleted"]),
	("get_theory_status 6035 b",
	get_theory_status,
	"rubbish",
	gen_fail_msg "get_theory_status" 6035 ["rubbish"])
	];

print_all_thy();
store_mt_results mt_run_fail [
	("open_theory 6035 b",
	open_theory,
	"to_be_deleted",
	gen_fail_msg "open_theory" 6035 ["to_be_deleted"])
	];
store_mt_results mt_run_fail [
	("delete_theory 6035 b",
	delete_theory,
	"to_be_deleted",
	gen_fail_msg "delete_theory" 6035 ["to_be_deleted"])
	];
store_mt_results mt_run_fail [
	("lock_theory 6035 b",
	lock_theory,
	"to_be_deleted",
	gen_fail_msg "lock_theory" 6035 ["to_be_deleted"]),
	("unlock_theory 6035 b",
	unlock_theory,
	"to_be_deleted",
	gen_fail_msg "unlock_theory" 6035 ["to_be_deleted"]),
	("unlock_theory 6068",
	unlock_theory,
	"yet_again",
	gen_fail_msg "unlock_theory" 6068 ["yet_again"])
	];

new_theory "to_be_deleted"; (* succeeds! *)
print_thy("to_be_deleted");
open_theory "yet_again";
delete_theory "to_be_deleted"; 
store_mt_results mt_run_fail [
	("delete_theory 6076",
	delete_theory,
	"min",
	gen_fail_msg "delete_theory" 6076 ["min"]),
	("delete_theory 6069",
	delete_theory,
	"yet_again",
	gen_fail_msg "delete_theory" 6069 ["yet_again"])
	];
=TEX
The correct operation of $duplicate\_theory$ should be checked
by visually inspecting the following output.
=SML
print_thy("next");
duplicate_theory ("next", "copy_of_next");
print_thy("copy_of_next");

store_mt_results mt_run_fail [
	("duplicate_theory 6035 a",
	duplicate_theory,
	("rubbish", "copy_of_rubbish"),
	gen_fail_msg "duplicate_theory" 6035 ["rubbish"]),
	("duplicate_theory 6035 b",
	duplicate_theory,
	("to_be_deleted", "copy_of_rubbish"),
	gen_fail_msg "duplicate_theory" 6035 ["to_be_deleted"]),
	("duplicate_theory 6040",
	duplicate_theory,
	("next", "copy_of_next"),
	gen_fail_msg "duplicate_theory" 6040 ["copy_of_next"])
	];
store_mt_results mt_run_error [
	("list_save_thm 6036",
	list_save_thm,
	(["s2"], thy_deleted_thm),
	gen_fail_msg "icl'list_save_thm" 6036 ["v1 Ö v1","to_be_deleted",del_thy_name])
	];
=TEX
Definitional mechanisms:
=SML
open_theory "next";
declare_binder "ç";
declare_terminator "ç" handle _ => ();
new_const("T",BOOL);
new_const("F",BOOL);
new_const("=",mk_ã_type(tv1, mk_ã_type(tv1, BOOL)));
declare_infix (200, "=");
declare_terminator "=" handle _ => ();
declare_alias ("Ç", ª$=:BOOLãBOOLãBOOLº) handle _ => ();
declare_infix (200, "Ç") handle _ => ();
new_const("ä",mk_ã_type(BOOL,mk_ã_type(BOOL,BOOL)));
declare_infix (20, "ä");
declare_terminator "ä" handle _ => ();
new_const("Ä",mk_ã_type(BOOL,mk_ã_type(BOOL,BOOL)));
declare_infix (40, "Ä");
declare_terminator "Ä" handle _ => ();
new_const("Å",mk_ã_type(BOOL,mk_ã_type(BOOL,BOOL)));
declare_infix (30, "Å");
declare_terminator "Å" handle _ => ();
new_const("å",mk_ã_type(BOOL,BOOL));
declare_prefix (50, "å");
new_const("TypeDefn",mk_ã_type(mk_ã_type(tv1,BOOL),
	mk_ã_type(mk_ã_type(tv'2,tv1),BOOL)));
val Tv1Pred = new_const("Tv1Pred",mk_ã_type(tv1,BOOL));
open_theory "yet_again";
store_mt_results mt_run [ 
	("simple_new_defn 1",
	dest_thm o simple_new_defn,
	("True","True",mk_t),
	([],mk_Ç(mk_const("True",BOOL),mk_t))),
	("simple_new_defn 2",
	dest_thm o simple_new_defn,
	("False","False",mk_f),
	([],mk_Ç(mk_const("False",BOOL),mk_f)))
	];
store_mt_results mt_run_fail [
	("simple_new_defn 6013",
	simple_new_defn,
	("x","Rubbish",mk_var("v",mk_ctype("RUBBISH",[]))),
	gen_fail_msg "simple_new_defn" 6013 ["ªvº","RUBBISH"]),
	("simple_new_defn 6049 c",
	simple_new_defn,
	("True","True",mk_t),
	gen_fail_msg "simple_new_defn" 6049 ["True"]),
	("simple_new_defn 6049 d",
	simple_new_defn,
	("0","0",N0),
	gen_fail_msg "simple_new_defn" 6049 ["0"]),
	("simple_new_defn 6051",
	simple_new_defn,
	("True","True1",mk_t),
	gen_fail_msg "simple_new_defn" 6051 ["True","yet_again"]),
	("simple_new_defn 6058",
	simple_new_defn,
	("Maybe1","Maybe1",mk_É(vtv1,mk_eq(vtv1,vtv1))),
	gen_fail_msg "simple_new_defn" 6058 ["ªÉ vtv1é vtv1 = vtv1º","'tv1"]),
	("simple_new_defn 6059",
	simple_new_defn,
	("Maybe","Maybe",v1),
	gen_fail_msg "simple_new_defn" 6059 ["ªv1º","v1"])
	];
val etype_ax = new_axiom("etype_ax",
	mk_simple_Ñ(vtv1,mk_app(Tv1Pred,vtv1)));

local val x= mk_var("x",tv'2)
in
val etype2_exax = new_axiom("etype2_exax",
	mk_simple_Ñ(x,mk_app(inst [] [(tv'2,tv1)]Tv1Pred,x)))
end;
val etype_def = new_type_defn("ETYPE", "ETYPE", ["'tv1"], etype_ax);
val etype2_def = new_type_defn(  "ETYPE2", "ETYPE2", ["'2"], etype2_exax);
let
	fun f t1 t2 = mk_var("f",mk_ã_type(t1,t2));
in
store_mt_results mt_run [ 
	("new_type_defn 1",
	dest_thm,
	etype_def,
	([], mk_Ñ(f (mk_ctype("ETYPE",[tv1])) tv1,
		list_mk_app(
		mk_const("TypeDefn",mk_ã_type(mk_ã_type(tv1,BOOL),
			mk_ã_type(mk_ã_type(mk_ctype("ETYPE",[tv1]),tv1),BOOL))),
		[inst [] [] Tv1Pred,f (mk_ctype("ETYPE",[tv1])) tv1])))),
	("new_type_defn 2",
	dest_thm,
	etype2_def,
	([], mk_Ñ(f (mk_ctype("ETYPE2",[tv'2])) (tv'2),
		list_mk_app(
		mk_const("TypeDefn",mk_ã_type(mk_ã_type(tv'2,BOOL),
			mk_ã_type(mk_ã_type(mk_ctype("ETYPE2",[tv'2]),tv'2),BOOL))),
		[inst [] [(tv'2,tv1)] Tv1Pred,
		f (mk_ctype("ETYPE2",[tv'2])) (tv'2)]))))
	]
end;
val etype_ax_6054 = new_axiom("etype_ax_6054", mk_t);
val etype_ax_6055 = new_axiom("etype_ax_6055", 
	mk_Ñ(mk_var("x",tv1),mk_t));
val etype_ax_6056 = new_axiom("etype_ax_6056", 
	mk_Ñ(mk_var("x",tv1),mk_app(mk_var("p",mk_ã_type(tv1,BOOL)), 
		mk_var("x",tv1))));
val etype_ax_6080 = new_axiom("etype_ax_6080", 
	mk_Ñ(mk_var("x",tv1),mk_app(mk_const("å",mk_ã_type(BOOL,BOOL)), 
		mk_t)));
store_mt_results mt_run_fail [
	("new_type_defn 6045",
	new_type_defn,
	("ETYPE1", "ETYPE", ["'tv1"], etype_ax),
	gen_fail_msg "new_type_defn" 6045 ["ETYPE"]),
	("new_type_defn 6052",
	new_type_defn,
	("ETYPE", "ETYPE1", ["'tv1"], etype_ax),
	gen_fail_msg "new_type_defn" 6052 ["ETYPE","yet_again"]),
	("new_type_defn 6053",
	new_type_defn,
	("ETYPE1", "ETYPE1", ["'tv1"], icl'Kernel.icl'asm_rule mk_t),
	gen_fail_msg "new_type_defn" 6053 ["T Ö T"]),
	("new_type_defn 6054",
	new_type_defn,
	("ETYPE1", "ETYPE1", ["'tv1"], etype_ax_6054),
	gen_fail_msg "new_type_defn" 6054 ["Ö T"]),
	("new_type_defn 6055",
	new_type_defn,
	("ETYPE1", "ETYPE1", ["'tv1"], etype_ax_6055),
	gen_fail_msg "new_type_defn" 6055 ["Ö Ñ xé T"]),
	("new_type_defn 6056",
	new_type_defn,
	("ETYPE1", "ETYPE1", ["'tv1"], etype_ax_6056),
	gen_fail_msg "new_type_defn" 6056 ["Ö Ñ xé p x","p"]),
	("new_type_defn 6057",
	new_type_defn,
	("ETYPE1", "ETYPE1", ["'not_there"], etype_ax),
	gen_fail_msg "new_type_defn" 6057 ["Ö Ñ vtv1é Tv1Pred vtv1","'tv1"]),
	("new_type_defn 6079",
	new_type_defn,
	("ETYPE1", "ETYPE1", ["'tv1","'tv1"], etype_ax),
	gen_fail_msg "new_type_defn" 6079 ["'tv1"]),	("new_type_defn 6080",
	new_type_defn,
	("ETYPE1", "ETYPE1", ["'tv1"], etype_ax_6080),
	gen_fail_msg "new_type_defn" 6080 ["Ö Ñ xé å T"])
	];
store_mt_results mt_run_error [
	("new_type_defn 6036",
	new_type_defn,
	( "rubbish", "rubbish", [], thy_deleted_thm),
	gen_fail_msg "icl'new_type_defn" 6036 ["v1 Ö v1","to_be_deleted",del_thy_name])
	];
=TEX
\subsection{new\_specification}
=SML
val So = mk_const("So",BOOL);
val IsSo = mk_const("IsSo",BOOL);
val vSo = mk_var("So",BOOL);
val vIsSo = mk_var("IsSo",BOOL);
val so_isso_axiom = new_axiom("so_isso_axiom",
	list_mk_simple_Ñ([vSo,vIsSo],mk_ä(vSo,vIsSo)));
val so_isso_def = new_specification (["So","IsSo"],2,so_isso_axiom);
store_mt_results mt_run [ 
	("new_specification",
	dest_thm,
	so_isso_def,
	([],mk_ä(So,IsSo)))
	];
val spec_ax_6016 = new_axiom("spec_ax_6016",
	list_mk_Ñ([mk_var("x",BOOL),mk_var("x",BOOL)],
		mk_Ä(mk_var("x",BOOL),mk_var("x",BOOL))));
val spec_ax_6051 = new_axiom("spec_ax_6051",
	mk_Ñ(mk_var("x",BOOL),mk_var("x",BOOL)));
val spec_ax_6056 = new_axiom("spec_ax_6056",
	mk_Ñ(mk_var("x",BOOL),mk_eq(mk_var("x",BOOL),v1)));
val spec_ax_6061 = new_axiom("spec_ax_6061",
	mk_Ñ(mk_var("x",BOOL),mk_eq(mk_var("x",BOOL),
		mk_É(mk_var("y",tv1), mk_t))));
val spec_ax_6081 = new_axiom("spec_ax_6081",
	list_mk_Ñ([mk_var("y",tv'2),mk_var("x",BOOL)],
		mk_Ä(mk_var("x",BOOL),mk_var("x",BOOL))));
store_mt_results mt_run_fail [
	("new_specification 6016",
	new_specification,
	(["x1","x2"],2,spec_ax_6016),
	gen_fail_msg "new_specification" 6016 ["x","Ö Ñ x xé x Ä x"]),
	("new_specification 6031",
	new_specification,
	([],2,so_isso_axiom),
	gen_fail_msg "new_specification" 6031 []),
	("new_specification 6044",
	new_specification,
	(["nowhere"],0,so_isso_axiom),
	gen_fail_msg "new_specification" 6044 []),
	("new_specification 6049",
	new_specification,
	(["Soa","IsSoa"],2,so_isso_axiom),
	gen_fail_msg "new_specification" 6049 ["So"]),
	("new_specification 6051",
	new_specification,
	(["So","IsSo"],1,spec_ax_6051),
	gen_fail_msg "new_specification" 6051 ["IsSo","yet_again"]),
	("new_specification 6053",
	new_specification,
	(["So","IsSo"],2,icl'Kernel.icl'asm_rule mk_t),
	gen_fail_msg "new_specification" 6053 ["T Ö T"]),
	("new_specification 6056",
	new_specification,
	(["x"],1,spec_ax_6056),
	gen_fail_msg "new_specification" 6056 ["Ö Ñ xé x Ç v1","v1"]),
	("new_specification 6060",
	new_specification,
	(["Some"],3,so_isso_axiom),
	gen_fail_msg "new_specification" 6060 ["Ö Ñ So IsSoé So ä IsSo", "3"]),
	("new_specification 6061",
	new_specification,
	(["x"],1,spec_ax_6061),
	gen_fail_msg "new_specification" 6061 ["Ö Ñ xé x Ç (É yé T)", "'tv1"]),
	("new_specification 6081",
	new_specification,
	(["x"],2,spec_ax_6081),
	gen_fail_msg "new_specification" 6081 ["ªyº","ªxº"])
	];
store_mt_results mt_run_error [
	("new_specification 6036",
	new_specification,
	([],2,thy_deleted_thm),
	gen_fail_msg "icl'new_specification" 6036 ["v1 Ö v1","to_be_deleted",del_thy_name])
	];
=TEX
\subsection{Theory Functions}
We test $new\_parent$'s successful operation by side effect (observing the print of the current theory).
=SML
new_parent "another";
print_thy "-";
open_theory "min";
val UNIT = new_type ("UNIT",0);
new_theory "tester";
val F' = new_const("F",UNIT);
open_theory "yet_again";
store_mt_results mt_run_fail [
	("new_parent 6067 a",
	new_parent,
	"tester",
	gen_fail_msg "new_parent" 6067 ["tester"]),
	("new_parent 6035 a",
	new_parent,
	"rubbish",
	gen_fail_msg "new_parent" 6035 ["rubbish"]),
	("new_parent 6035 b",
	new_parent,
	"to_be_deleted",
	gen_fail_msg "new_parent" 6035 ["to_be_deleted"]),
	("new_parent 6082",
	new_parent,
	"next",
	gen_fail_msg "new_parent" 6082 ["next"])
	];
open_theory "min";
store_mt_results mt_run_fail [
	("new_parent 6084",
	new_parent,
	"yet_again",
	gen_fail_msg "new_parent" 6084 ["yet_again"])];
store_mt_results mt_run [
	("get_current_theory_status 2",
	get_current_theory_status,
	(),
	TSNormal)
	];
=TEX
\section{FUTHER THEORY FUNCTIONS}
Test hooks into environments.
=SML
open_theory "yet_again";
store_mt_results mt_run [ 
	("get_const_type 1",
	get_const_type,
	"5",
	Value Ü),
	("get_const_type 2",
	get_const_type,
	"",
	Nil),
	("get_const_type 3",
	get_const_type,
	"T",
	Value BOOL),
	("get_const_type 4",
	get_const_type,
	"TorF",
	Nil),
	("get_const_type 5",
	get_const_type,
	"rubbish",
	Nil)
	];
store_mt_results mt_run [ 
	("get_type_arity 1",
	get_type_arity,
	"BOOL",
	Value 0),
	("get_type_arity 2",
	get_type_arity,
	"Ü",
	Value 0),
	("get_type_arity 3",
	get_type_arity,
	"",
	Nil),
	("get_type_arity 4",
	get_type_arity,
	"ã",
	Value 2),
	("get_type_arity 5",
	get_type_arity,
	"RUBBISH",
	Nil)
	];
=TEX
Test the built in scopes:
=SML
open_theory  "yet_again";
store_mt_results mt_run [ 
	("new_const 1",
	new_const,
	("12a",BOOL),
	mk_const("12a",BOOL)),
	("new_const 2",
	new_const,
	("`12",BOOL),
	mk_const("`12",BOOL))
	];
store_mt_results mt_run_fail [
	("new_const 6049 a",
	new_const,
	("1",BOOL),
	gen_fail_msg "new_const" 6049 ["1"]),
	("new_const 6049 b",
	new_const,
	("123",BOOL),
	gen_fail_msg "new_const" 6049 ["123"]),
	("new_const 6049 f",
	new_const,
	("`a",BOOL),
	gen_fail_msg "new_const" 6049 ["`a"]),
	("new_const 6049 d",
	new_const,
	("\"abc",BOOL),
	gen_fail_msg "new_const" 6049 ["\"abc"])
	];
=TEX
We can presume successful uses of $get\_thms$, $get\_axioms$, $get\_defns$, $get\_types$, $get\_consts$, $get\_parents$, $get\_children$,
$theory\_names$
are all well tested by $print\_(all\_)theory$.
The remainder of their kin are tested as follows:
=SML
open_theory "yet_again";
val out_of_scope_thm = save_thm("not_in_scope",icl'Kernel.icl'asm_rule v1);
open_theory "yet_again";
=TEX
\subsection{Valid Theorems}
=SML
store_mt_results mt_run[
	("valid_thm 1",
	valid_thm,
	thm1,
	true),
	("valid_thm 2",
	valid_thm,
	thy_deleted_thm,
	false)
	];
=TEX
\subsection{Output of Theorems}
=SML
store_mt_results mt_run [
	("string_of_thm",
	string_of_thm,
	pB_thm,
	"p Ö p")];
store_mt_results mt_run_fail [
	("thm_fail",
	thm_fail "test" 6053,
	[pB_thm],
	gen_fail_msg "test" 6053 ["p Ö p"])];
store_mt_results mt_run [ 
	("dest_thm",
	dest_thm,
	pB_thm,
	([pB],pB))
	];
=TEX
\subsection{Some More Theory Access Functions}
=SML
store_mt_results mt_run [
	("get_thm",
	dest_thm o get_thm "next",
	"thm1",
	(h_thm1,c_thm1)),
	("get_defn",
	dest_thm o get_defn "yet_again",
	"So",
	([],mk_ä(So,IsSo))),
	("get_axiom",
	dest_thm o get_axiom "yet_again",
	"etype_ax",
	(dest_thm etype_ax))
	];
open_theory "next";
store_mt_results mt_run_fail [
	("get_thm 6035",
	get_thm "rubbish",
	"thm1",
	gen_fail_msg "get_thm" 6035 ["rubbish"]),
	("get_thm 12006",
	get_thm "next",
	"rubbish",
	gen_fail_msg "get_thm" 12006 ["next","rubbish"]),
	("get_thm 12010",
	get_thm "yet_again",
	"not_in_scope",
	gen_fail_msg "get_thm" 12010 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("get_defn 6035",
	get_defn "rubbish",
	"def1",
	gen_fail_msg "get_defn" 6035 ["rubbish"]),
	("get_defn 12004",
	get_defn "next",
	"rubbish",
	gen_fail_msg "get_defn" 12004 ["next","rubbish"]),
	("get_defn 12010",
	get_defn "yet_again",
	"not_in_scope",
	gen_fail_msg "get_defn" 12010 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("get_axiom 6035",
	get_axiom "rubbish",
	"def1",
	gen_fail_msg "get_axiom" 6035 ["rubbish"]),
	("get_axiom 12005",
	get_axiom "next",
	"rubbish",
	gen_fail_msg "get_axiom" 12005 ["next","rubbish"]),
	("get_axiom 12010",
	get_axiom "yet_again",
	"not_in_scope",
	gen_fail_msg "get_axiom" 12010 ["yet_again"])
	];
=TEX
=SML
open_theory "yet_again";
store_mt_results mt_run [
	("get_ancestors 1",
	get_ancestors,
	"yet_again",
	["another", "min", "next", "yet_again"]),
	("get_ancestors 2",
	get_ancestors,
	"min",
	["min"])
	];
store_mt_results mt_run_fail [
	("get_ancestors 6035",
	get_ancestors,
	"rubbish",
	gen_fail_msg "get_ancestors" 6035 ["rubbish"])
	];
store_mt_results mt_run [
	("is_theory_ancestor 1",
	is_theory_ancestor "min",
	"-",
	true),
	("is_theory_ancestor 2",
	is_theory_ancestor "min",
	"yet_again",
	true),
	("is_theory_ancestor 3",
	is_theory_ancestor "yet_again",
	"min",
	false),
	("is_theory_ancestor 4",
	is_theory_ancestor "-",
	"min",
	false),
	("is_theory_ancestor 5",
	is_theory_ancestor "yet_again",
	"yet_again",
	true)
	];
store_mt_results mt_run_fail [
	("is_theory_ancestor 6035 a",
	is_theory_ancestor "rubbish",
	"min",
	gen_fail_msg "is_theory_ancestor" 6035 ["rubbish"]),
	("is_theory_ancestor 6035 b",
	is_theory_ancestor "-",
	"rubbish",
	gen_fail_msg "is_theory_ancestor" 6035 ["rubbish"]),
	("is_theory_ancestor 6035 c",
	is_theory_ancestor "rubbish",
	"rubbish",
	gen_fail_msg "is_theory_ancestor" 6035 ["rubbish"])
	];
store_mt_results mt_run [
	("get_descendants",
	get_descendants,
	"next",
	["yet_again", "next"])
	];
store_mt_results mt_run_fail [
	("get_descendants 6035",
	get_descendants,
	 "rubbish",
	gen_fail_msg "get_descendants" 6035 ["rubbish"])];
store_mt_results mt_run_fail [
	("get_parents 6035",
	get_parents,
	 "rubbish",
	gen_fail_msg "get_parents" 6035 ["rubbish"])];
store_mt_results mt_run_fail [
	("get_children 6035",
	get_children,
	 "rubbish",
	gen_fail_msg "get_children" 6035 ["rubbish"])];
store_mt_results mt_run_fail [
	("get_thms 6035",
	get_thms,
	 "rubbish",
	gen_fail_msg "get_thms" 6035 ["rubbish"])];
store_mt_results mt_run_fail [
	("get_axioms 6035",
	get_axioms,
	 "rubbish",
	gen_fail_msg "get_axioms" 6035 ["rubbish"])];
store_mt_results mt_run_fail [
	("get_defns 6035",
	get_defns,
	 "rubbish",
	gen_fail_msg "get_defns" 6035 ["rubbish"])];
store_mt_results mt_run_fail [
	("get_consts 6035",
	get_consts,
	"rubbish",
	gen_fail_msg "get_consts" 6035 ["rubbish"])];
store_mt_results mt_run_fail [
	("get_types 6035",
	get_types,
	 "rubbish",
	gen_fail_msg "get_types" 6035 ["rubbish"])];
=TEX
Tests on hierarchies : do after all others, as things are made read only.
=SML
icl'Kernel.icl'freeze_hierarchy();
open_theory "yet_again";
store_mt_results mt_run [
	("get_current_theory_status 3",
	get_current_theory_status,
	(),
	TSAncestor)
	];
store_mt_results mt_run [
	("get_theory_status",
	get_theory_status,
	"next",
	TSAncestor)
	];
store_mt_results mt_run_fail [
	("set_user_datum 6071",
	set_user_datum,
	("testing1",UD_String ("a test",[])),
	gen_fail_msg "set_user_datum" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("new_axiom 6071",
	new_axiom,
	("Truth_axiom1",mk_t),
	gen_fail_msg "new_axiom" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("new_const 6071",
	new_const,
	("ForT1",BOOL),
	gen_fail_msg "new_const" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("new_type 6071",
	new_type,
	("SOMETHING1",3),
	gen_fail_msg "new_type" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("simple_new_defn 6071",
	simple_new_defn,
	("True1","True1",mk_t),
	gen_fail_msg "simple_new_defn" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("delete_const 6071",
	delete_const,
	mk_const("test_spec",BOOL),
	gen_fail_msg "delete_const" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("delete_axiom 6071",
	delete_axiom,
	"so_isso_axiom",
	gen_fail_msg "delete_axiom" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("delete_type 6071",
	delete_type,
	"ETYPE",
	gen_fail_msg "delete_type" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("list_save_thm 6071",
	list_save_thm,
	(["Example1"],thm1),
	gen_fail_msg "list_save_thm" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("save_thm 6071",
	save_thm,
	("Example1",thm1),
	gen_fail_msg "save_thm" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("delete_thm 6071",
	delete_thm,
	"Example",
	gen_fail_msg "delete_thm" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("delete_theory 6071",
	delete_theory,
	"another",
	gen_fail_msg "delete_theory" 6071 ["another"])
	];
store_mt_results mt_run_fail [
	("lock_theory 6071",
	lock_theory,
	"yet_again",
	gen_fail_msg "lock_theory" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("new_parent 6071",
	new_parent,
	"another",
	gen_fail_msg "new_parent" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("new_type_defn 6071",
	new_type_defn,
	(  "ETYPE7", "ETYPE7", ["'1"], etype_ax),
	gen_fail_msg "new_type_defn" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("new_specification 6071",
	new_specification,
	(["So1","IsSo1"],2,so_isso_axiom),
	gen_fail_msg "new_specification" 6071 ["yet_again"])
	];
=TEX
Test for clashes in children theories for $new\_parent$:
=SML
open_theory "next";
new_theory "np_test1";
new_theory "np_test3";
open_theory "next";
new_theory "np_test2";
new_const("np_test",BOOL);
open_theory "next";
new_theory "np_test4";
new_type("np_test_t",0);
open_theory "np_test3";
new_const("np_test",BOOL);
new_type("np_test_t",0);
open_theory "np_test1";
store_mt_results mt_run_fail [
	("new_parent 6067 b",
	new_parent,
	"np_test2",
	gen_fail_msg "new_parent" 6067 ["np_test2"]),
	("new_parent 6067 c",
	new_parent,
	"np_test4",
	gen_fail_msg "new_parent" 6067 ["np_test4"])
	];
=TEX
\subsection{End of Tests}
=SML
diag_string(summarize_mt_results());
=TEX
\section{UNTESTED ERROR MESSAGES}
Error 6017 of $open\_theory$, concerning sealed theories,
as a ful testing of sealing theories was carried out in \cite{DS/FMU/IED/MDT006}, and no sealing material occurs in 
\cite{DTD012} bar this error message.

Error 6013, 6014, 6015 and 6038 of various functions, concerning ill-formed theorems.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
=TEX
\end{document}
=IGN
Coverage:
open Sort;

sort stringorder (map fst (get_mt_results()));

all_different (map fst (get_mt_results()));
