% mdt059.doc $Id$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Product Types}  %% Mandatory field
\def\TPPheadtitle{Module Tests for Product Types}
\TPPref{DS/FMU/IED/MDT059}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the 
the tools for introducing product types.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1]
First draft.

\item[Issue \SCCSversion, \FormatDate{92/01/20} ] Updated to use new fonts.

\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the product type tools.
The design is in \cite{DS/FMU/IED/DTD059}
and it is
implemented in \cite{DS/FMU/IED/IMP059}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD059},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD059},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP059}.
\subsubsection{Deficiencies}
None known.
\section{TEST CASES}
$set\_cache\_theories$ and $get\_cache\_theories$ are tested 
during the course of the other tests.
Otherwise we test each function of the signature of \cite{DS/FMU/IED/DTD059}
testing both successful, and all stated error, cases.
Where errors are ``inherited'' from earlier functions we test a small selection of inherited error cases.
The order of the tests is dictated by their interdependency, rather
than the order in the signature.

\section{PROLOGUE}
Initialise the test package:
=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results();
=TEX
=SML
new_theory "cache_theory059";
set_cache_theories ["cache_theory059"];
new_theory "test059";
val first_cache_theory = hd(get_cache_theories ());
new_parent "î" handle _ => ();
=TEX
\section{SETTING THE PROOF CONTEXT}
To make the tests independent of some outside changes, we give a local
proof context:
=SML
pop_proof_context();
push_proof_context prove_¶_epc;
=TEX
\section{THE TESTS}
\subsection{$cached\_labelled\_product\_rule$}
=SML
let
	val thm = cached_labelled_product_rule 2;
	val tm = ¬(¶ abs rep· (µ a:'a· abs (rep a) = a) ± (µ r:'1 ¸ '2· rep (abs r) = r)) ´
  (¶ 2Tuple Lab2_1 Lab2_2· µ (t:'a) (x1:'1) (x2:'2)·
  (Lab2_1 (2Tuple x1 x2) = x1 ± Lab2_2 (2Tuple x1 x2) = x2) ±
  2Tuple (Lab2_1 t) (Lab2_2 t) = t)®;
in
(store_mt_results mt_run [
	("cached_labelled_product_rule 2",
	dest_thm,
	thm,
	([],tm))];
store_mt_results mt_run [
	("cached_labelled_product_rule 2a",
	dest_thm,
	get_thm first_cache_theory "2CachedLabelledProduct",
	([],tm))])
end;
=TEX
The following checks that if the old form is present then it will be used (or at least, from the evidence, that the behaviour is as such).
=SML
let
	val thm = cached_labelled_product_rule 2;
	val tm = ¬(¶ abs rep· (µ a:'a· abs (rep a) = a) ± (µ r:'1 ¸ '2· rep (abs r) = r)) ´
  (¶ 2Tuple Lab2_1 Lab2_2· µ (t:'a) (x1:'1) (x2:'2)·
  (Lab2_1 (2Tuple x1 x2) = x1 ± Lab2_2 (2Tuple x1 x2) = x2) ±
  2Tuple (Lab2_1 t) (Lab2_2 t) = t)®;
in
store_mt_results mt_run [
	("cached_labelled_product_rule 2b",
	dest_thm,
	thm,
	([],tm))]
end;
=TEX
=SML
store_mt_results mt_run_fail [
	("cached_labelled_product_rule 59001",
	cached_labelled_product_rule,
	0,
	gen_fail_msg "cached_labelled_product_rule" 59001 ["0"])];

open_theory "misc";
store_mt_results mt_run_fail [
	("cached_labelled_product_rule 59002",
	cached_labelled_product_rule,
	3,
	gen_fail_msg "cached_labelled_product_rule" 59002 [first_cache_theory])];
store_mt_results mt_run_fail [
	("cached_labelled_product_rule 59017",
	cached_labelled_product_rule,
	1,
	gen_fail_msg "cached_labelled_product_rule" 59017 [])];
open_theory first_cache_theory;
save_thm("3CachedLabelledProduct",t_thm);
open_theory "test059";
store_mt_results mt_run_fail [
	("cached_labelled_product_rule 59003",
	cached_labelled_product_rule,
	4,
	gen_fail_msg "cached_labelled_product_rule" 59003 ["4"])];
set_cache_theories [];
store_mt_results mt_run_fail [
	("cached_labelled_product_rule 59006",
	cached_labelled_product_rule,
	2,
	gen_fail_msg "cached_labelled_product_rule" 59006 [])];
set_cache_theories [first_cache_theory];
=TEX
\subsection{$cached\_unlabelled\_product\_rule$}
=SML
let
	val thm = cached_unlabelled_product_rule 2;
	val tm = ¬(¶ abs rep· (µ a:'a· abs (rep a) = a) ± (µ r:'1 ¸ '2· rep (abs r) = r)) ´
  (¶ 2Tuple· (µ x1 x2 y1 y2· 2Tuple x1 x2 = 2Tuple y1 y2 ¤ x1 = y1 ± x2 = y2)
  ± (µ t:'a· ¶ (x1:'1) (x2:'2)· t = 2Tuple x1 x2))®;
in
(store_mt_results mt_run [
	("cached_unlabelled_product_rule 2",
	dest_thm,
	thm,
	([],tm))];
store_mt_results mt_run [
	("cached_unlabelled_product_rule 2a",
	dest_thm,
	get_thm first_cache_theory "2CachedUnlabelledProduct",
	([],tm))])
end;
=TEX
The following checks that if the old form is present then it will be used (or at least, from the evidence, that the behaviour is as such).
=SML
let
	val thm = cached_unlabelled_product_rule 2;
	val tm = ¬(¶ abs rep· (µ a:'a· abs (rep a) = a) ± (µ r:'1 ¸ '2· rep (abs r) = r)) ´
  (¶ 2Tuple· (µ x1 x2 y1 y2· 2Tuple x1 x2 = 2Tuple y1 y2 ¤ x1 = y1 ± x2 = y2)
  ± (µ t:'a· ¶ (x1:'1) (x2:'2)· t = 2Tuple x1 x2))®;
in
store_mt_results mt_run [
	("cached_unlabelled_product_rule 2b",
	dest_thm,
	thm,
	([],tm))]
end;
=TEX
=SML
store_mt_results mt_run_fail [
	("cached_unlabelled_product_rule 59001",
	cached_unlabelled_product_rule,
	0,
	gen_fail_msg "cached_unlabelled_product_rule" 59001 ["0"])];

open_theory "misc";
store_mt_results mt_run_fail [
	("cached_unlabelled_product_rule 59002",
	cached_unlabelled_product_rule,
	3,
	gen_fail_msg "cached_unlabelled_product_rule" 59002 [first_cache_theory])];
store_mt_results mt_run_fail [
	("cached_unlabelled_product_rule 59017",
	cached_unlabelled_product_rule,
	1,
	gen_fail_msg "cached_unlabelled_product_rule" 59017 [])];
open_theory first_cache_theory;
save_thm("3CachedUnlabelledProduct",t_thm);
open_theory "test059";
store_mt_results mt_run_fail [
	("cached_unlabelled_product_rule 59004",
	cached_unlabelled_product_rule,
	4,
	gen_fail_msg "cached_unlabelled_product_rule" 59004 ["4"])];
set_cache_theories [];
store_mt_results mt_run_fail [
	("cached_unlabelled_product_rule 59006",
	cached_unlabelled_product_rule,
	2,
	gen_fail_msg "cached_unlabelled_product_rule" 59006 [])];
set_cache_theories [first_cache_theory];
=TEX
\subsection{$labelled\_product\_spec$}
=SML
let
	val inp2 = {tyname = "HOLD2",tykey = "HOLD2",conname = "Hold2",
	constkeys= ["Hold2","First2","Second2"],
	labels = [("First2",î),("Second2",¬:'1®)],
	tyvars = Value[¬:'1®,¬:'2®]};
	val thm = labelled_product_spec inp2;
	val tm = ¬µ (t:('1,'2)HOLD2) x1 x2· (First2 (Hold2 x1 x2:('1,'2)HOLD2) = x1 ± 
		Second2 (Hold2 x1 x2:('1,'2)HOLD2) = x2)
  ± Hold2 (First2 t) (Second2 t) = t®;
in
(store_mt_results mt_run [
	("labelled_product_spec 2",
	dest_thm,
	thm,
	([],tm))];
store_mt_results mt_run [
	("labelled_product_spec 2a",
	dest_thm,
	get_defn "test059" "Hold2",
	([],tm))])
end;
=TEX
We have already given a corrupted third cached theorem, so this fails:
=SML
let
	val inp3 = {tyname = "WHOLD3",tykey = "WHOLD3",conname = "WHold3",
	constkeys= ["WHold3","WFirst3","WSecond3","WThird3"],
	labels = [("First3",î),("Second3",¬:'1®),("Third3",¬:'2®)],
	tyvars = Value[¬:'1®,¬:'2®]};
in
store_mt_results mt_run_fail [
	("labelled_product_spec 59014",
	labelled_product_spec,
	inp3,
	gen_fail_msg "labelled_product_spec" 59014 ["WHOLD3"])]
end;
=TEX
=SML
let
	val inp2 = {tyname = "WHOLD2",tykey = "WHOLD2",conname = "WHold2",
	constkeys= [],
	labels = [("WFirst2",î),("WSecond2",¬:'1®)],
	tyvars = Value[¬:'1®,¬:'2®]};
in
store_mt_results mt_run_fail [
	("labelled_product_spec 59010",
	labelled_product_spec,
	inp2,
	gen_fail_msg "labelled_product_spec" 59010 [])]
end;
=TEX
=SML
let
	val inp2 = {tyname = "WHOLD2",tykey = "WHOLD2",conname = "WHold2",
	constkeys= ["WHold2","WFirst2","WSecond2"],
	labels = [],
	tyvars = Value[¬:'1®,¬:'2®]};
in
store_mt_results mt_run_fail [
	("labelled_product_spec 59010",
	labelled_product_spec,
	inp2,
	gen_fail_msg "labelled_product_spec" 59010 [])]
end;
=TEX
=SML
let
	val inp2 = {tyname = "WHOLD2",tykey = "WHOLD2",conname = "WHold2",
	constkeys= ["WHold2","WFirst2","WSecond2"],
	labels = [("WFirst2",î),("WSecond2",¬:'1®)],
	tyvars = Value[¬:'2®]};
in
store_mt_results mt_run_fail [
	("labelled_product_spec 59015",
	labelled_product_spec,
	inp2,
	gen_fail_msg "labelled_product_spec" 59015 ["'1"])]
end;
=TEX
\subsection{$unlabelled\_product\_spec$}
=SML
let
	val ulp2 = {tyname="ULP2", tykey="ULP2", conname="Ulp2", 
	conkeys=["Ulp2"], tyi=[¬:'a ¸ 'b®,¬:'a ¸ 'b®], 
	tyvars = Value [¬:'a®,¬:'b®]};
	val thm = unlabelled_product_spec ulp2;
	val tm = ¬(µ (x1:'a ¸ 'b) (x2:'a ¸ 'b) y1 y2· 
	 Ulp2 x1 x2 = Ulp2 y1 y2 ¤ x1 = y1 ± x2 = y2) ±
	 (µ t:('a,'b)ULP2· ¶ x1 x2· t = Ulp2 x1 x2)®;
in
(store_mt_results mt_run [
	("unlabelled_product_spec 2",
	dest_thm,
	thm,
	([],tm))];
store_mt_results mt_run [
	("unlabelled_product_spec 2a",
	dest_thm,
	get_defn "test059" "Ulp2",
	([],tm))])
end;
=TEX
We have already given a corrupted third cached theorem, so this fails:
=SML
let
	val ulp3 = {tyname = "WULP3",tykey = "WULP3",conname = "WUlp3",
	conkeys=["WUlp3"],
	tyi = [î, ¬:'1®, ¬:'2®],
	tyvars = Value[¬:'1®,¬:'2®]};
in
store_mt_results mt_run_fail [
	("unlabelled_product_spec 59014",
	unlabelled_product_spec,
	ulp3,
	gen_fail_msg "unlabelled_product_spec" 59014 ["WULP3"])]
end;
=TEX
=SML
let
	val ulp2 = {tyname="ULP2", tykey="ULP2", conname="Ulp2", 
	conkeys=[], tyi=[î], 
	tyvars = Value [¬:'a®,¬:'b®]};
in
store_mt_results mt_run_fail [
	("unlabelled_product_spec 59011",
	unlabelled_product_spec,
	ulp2,
	gen_fail_msg "unlabelled_product_spec" 59010 [])]
end;
=TEX
=SML
let
	val ulp2 = {tyname="ULP2", tykey="ULP2", conname="Ulp2", 
	conkeys=["Ulp2"], tyi=[], 
	tyvars = Value [¬:'a®,¬:'b®]};
in
store_mt_results mt_run_fail [
	("unlabelled_product_spec 59011",
	unlabelled_product_spec,
	ulp2,
	gen_fail_msg "unlabelled_product_spec" 59011 [])]
end;
=TEX
=SML
let
	val ulp3 = {tyname="ULP3", tykey="ULP3", conname="Ulp3", 
	conkeys=["Ulp3"], tyi=[¬:'a ¸ 'b®,¬:'a ¸ 'b®,¬:î®], 
	tyvars = Value [¬:'a®]};
in
store_mt_results mt_run_fail [
	("unlabelled_product_spec 59016",
	unlabelled_product_spec,
	ulp3,
	gen_fail_msg "unlabelled_product_spec" 59016 ["'b"])]
end;
=TEX
\subsection{End of Tests}
First test that we are still in the right theory:
=SML
store_mt_results mt_run [
	("product_spec theory",
	get_current_theory_name,
	(),
	"test059")];
=TEX
Then output the test results.
=SML
diag_string(summarize_mt_results());
=TEX
\end{document}


