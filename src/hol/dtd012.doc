=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
\TPPtitle{Detailed Design for the Interface to the Abstract Data Type $THM$}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the \cr
Interface to the Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/DTD012}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{R.D. Arthan & WIN01}  %% Mandatory field
\TPPauthors{R.D. Arthan & WIN01\\K. Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
interface to the
abstract data type $THM$.
This includes all those functions that the kernel of ICL HOL
will need to interface to the abstract data type, but do not 
need to be present within the abstract data type.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library \\ RDA \\ KB \\RBJ
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.2]
First full version: RDA.
\item [Issue 1.3]
Major changes after comments: KB.
\item [Issue 1.4]
Changes during testing.
Extended $NewAxiom$.
\item [Issue 1.5]
Added $hyps$, $concl$.
Renamed $get\_const\_type$ to $get\_const\_type$.
\item [Issue 1.6]
Added $is\_theory\_ancestor$, described order of $get\_ancestor$ results.
The name atom ``theorem(s)'' has been consistently changed
to ``thm(s)'', 
``definition(s)'' to ``defn(s)''.
and ``constant(s)'' to ``const(s)''.
\item [Issue 1.7]
Changed ``Definition'' to ``Defn''.
\item [Issue 1.8]
Changed ``Constant'' to ``Const''.
\item [Issue 1.9]
Added $valid\_thm$.
Added ``before kernel state change'' material.
\item [Issue 1.10]
Stopped using $t\_thm$ as a default.
\item [Issue 1.11]
Reacting to issue 1.18 of \cite{DS/FMU/IED/DTD006}.
\item [Issue 1.12]
Changes in reaction to ID0021.
\item [Issue 1.13]
Corrected message 6061.
\item [Issue 1.14]
Minor changes, in preparation for inspection.
\end{description}
% \subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the interface to the
abstract data type $THM$.
The interface functions complete the set of functions called 
for in section 4 of \cite{DS/FMU/IED/HLD007}.
The design is implemented in \cite{DS/FMU/IED/IMP012}.

The interfaces given here do not include the inference rules.
The interfaces for the rules are considered in \cite{DS/FMU/IED/DTD007}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the detailed design for the theory management interface
functions to the abstract data type $THM$.
These functions give a user- or programmer- oriented interface rather
than the raw minimum supplied by the abstract data type itself.

\subsubsection{Dependencies}
This document depends on \cite{DS/FMU/IED/IMP006}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.

\subsubsection{Terminology}
The following supplements the terminology used in those documents
upon which this one depends.
\begin{tabular}{p{1.3in} p{4.9in}}
sealed theory & ICL and system extenders may seal a theory, ensuring that all opened theories must either be it, or have it as a parent. Only one theory may be sealed at any time, and this is the ``sealed theory''. \\
\end{tabular}

\section{DISCUSSION}
A few minor policy decisions are worth noting:

\begin{enumerate}
\item the interface provided uses strings for theory names throughout
(rather than the numeric theory identifiers used in the abstract data
type);
\item as in the abstract data type, modifications to a theory may
only happen when it is current;
\item operations which change the state are formulated as uncurried
functions so that an interactive user is less likely to omit an
argument unwittingly.
\item
All functions that take a theory name as a string recognise
``-'' as meaning the current theory.
This will not be indicated in the individual documentation boxes.
\end{enumerate}


\section{PREAMBLE}
=DOC
signature âKernelInterfaceá = sig
=DESCRIBE
This provides theory management interface functions to the abstract
data type $THM$.
=FAILURE
6013	?0 is ill-formed in current theory: type name ?1 is not declared
6014	?0 is ill-formed in current theory: type name ?1 does not have arity used
6015	?0 is ill-formed in current theory: constant name ?1 not declared
6038	?0 is ill-formed in current theory: constant name ?1 cannot have type used
=FAILUREC
The above are various kinds of well-formedness check failures.
A well-formedness check occurs on any types, terms and theorems saved in a theory, and thus for various functions in this signature.
=ENDDOC
There are errors common to many kernel (i.e. from the abstract data type) functions, that
are raised by $error$.
This means that they raise exceptions whose ``area'' is a
kernel function that is used to implement a corresponding
interface function of this document.
\section{TYPES}
Most of the types with which the interface works are given in the
signature $KernelTypes$ defined in \cite{DS/FMU/IED/DTD006}.
Here we merely need to include that signature:
=SML
include KernelTypes;
=TEX

\section{THEORY MANAGEMENT OPERATIONS}
\subsection{Operations of Hierarchies}
No operations on hierarchies are supplied in this interface. The only
user interface to hierarchies is via the UNIX commands as described
in \cite{DS/FMU/IED/HLD005} and these use the interfaces of
\cite{DS/FMU/IED/DTD006} directly.

\subsection{Operations on Theory Attributes}
=DOC
val âopen_theoryá : string -> unit;
=DESCRIBE
All specification and proof work is carried out in the context
of some theory, referred to as the current theory.
$open\_theory\,thy$ makes the theory $thy$ the current theory.
One theory in the theory database is ``sealed'', and a theory may not be opened if it is neither that theory nor does not have that theory as a parent..
Theories are only sealed by ICL or system extenders.
=FAILURE
6017	Theory ?0 is neither the sealed theory ?1, nor has it as a parent
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC

=DOC
val âdelete_theoryá : string -> unit;
=DESCRIBE
$delete\_theory\,thy$ removes the theory $thy$ from the theory database.
This means, for instance, that all theorems that were proven with the deleted 
theory as the current theory, and all constants and types declared within the theory, will become out of scope.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6037	Theory ?0 is locked
6069	Theory ?0 is in scope
6071	Theory ?0 is a read-only ancestor
6076	Theory ?0 has child theories
=ENDDOC

=DOC
val ânew_theoryá : string -> unit;
=DESCRIBE
$new\_theory\,thy$ adds a new, empty, theory called
$thy$ to the theory database.
The empty theory has no declarations within it,
but does have the current theory as its sole parent.
The new theory then becomes the current theory.
=FAILURE
6040	Theory ?0 is already present in current theory hierarchy
=ENDDOC
=DOC
val ânew_parentá : string -> unit;
=DESCRIBE
Adds the given parent theory to the list of parents of the current
theory, considered as a set.
It will fail if the parent theory does not exist, is already a parent of the current theory,
or if making it a parent causes clashes in the current theory
or its children.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6037	Theory ?0 is locked
6067	Making ?0 a parent would cause a clash
6071	Theory ?0 is a read-only ancestor
6082	Theory ?0 is already a parent
6084	Suggested parent ?0 is a child of the current theory
=ENDDOC

=DOC
val âlock_theoryá : string -> unit;
=DESCRIBE
$lock\_theory\,thy$ causes $thy$ to be {\em locked}. The contents of
a locked theory are protected from further changes.
A locked theory may be unlocked using $unlock\_theory$(q.v.).
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6037	Theory ?0 is locked
6071	Theory ?0 is a read-only ancestor
=ENDDOC

=DOC
val âunlock_theoryá : string -> unit;
=DESCRIBE
$unlock\_theory\,thy$ causes the locked theory $thy$ to be unlocked,
so that the contents of $thy$ may be changed.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6068	Theory ?0 has not been locked
=ENDDOC

=DOC
val âduplicate_theoryá : (string * string) -> unit;
=DESCRIBE
$duplicate\_theory\,oldthy\,newthy$ creates a new theory,
called $newthy$
with the same contents and parents as $oldthy$,
but without any children.
The current theory remains unchanged.
To ensure that the duplicate theory can be opened by $open\_theory$ (q.v.) the system will prevent the duplication of the sealed theory or its ancestors.
=USES
To allow the user to modify and experiment with a theory that
has child theories that are not involved in the experiment,
and would perhaps clash with the experiment.
=FAILURE
6026	Cannot duplicate the sealed theory ?0
6042	Cannot duplicate ?0 as it is an ancestor of the sealed theory ?1
6035	Theory ?0 is not present in the current hierarchy
6040	Theory ?0 is already present in current theory hierarchy
=ENDDOC

\subsection{Operations on Theory Contents}
=DOC
val âdest_thmá : THM -> SEQ;
=DESCRIBE
This returns the representation of a theorem as a sequent, i.e. as a list of assumptions and a conclusion.
=ENDDOC
=DOC
val âvalid_thmá : THM -> bool;
=DESCRIBE
This function uses the check for the validity of theorems
that can give rise to errors 6036, 6065, 6066 and 6072,
returning false if such errors would be caused by processing
the theorem, and true otherwise : it cannot raise exceptions.
=USES
To preempt errors caused by the primitive inference rules, et al,
and return more helpful error messages.
=ENDDOC
=DOC
val âthm_failá : string -> int -> THM list -> 'a;
=DESCRIBE
$thm\_fail$ $area$ $msg$ $thml$ first creates a list of functions from $unit$ to $string$, providing displays of the list of theorems.
It then calls $fail$ with the $area$, $msg$ and this list of functions.
This allows theorems to be presented in error messages.
=ENDDOC
=DOC
val âstring_of_thmá : THM -> string;
=DESCRIBE
This returns a display of a theorem in the form of a string,
with no inserted new lines, suitable for use with $diag\_string$ and $fail$.
=SEEALSO
$format\_thm$, a formatted string display of a theorem.
=ENDDOC
=DOC
val âhypsá : THM -> TERM list;
=DESCRIBE
This returns the assumptions(hypotheses) of a theorem.
=ENDDOC
=DOC
val âconclá : THM -> TERM;
=DESCRIBE
This returns the conclusion of a theorem.
=ENDDOC
=DOC
val âthm_theoryá : THM -> string;
=DESCRIBE
$thm\_theory\,thm$ returns the name of the theory which was current when
$thm$ was proven.
This will succeed even if the theory is out of scope,
but not if the theory has been deleted.
=FAILURE
12007	?0 proven in theory with internal name ?1, 
	which is not present in current hierarchy
=ENDDOC
=DOC
val âsave_thmá : (string * THM) -> THM
=DESCRIBE
$save\_thm(key, thm)$ causes $thm$ to be save under the key $key$ in the current
theory.
=FAILURE
6037	Theory ?0 is locked
6039	Key ?0 has already been used for a theorem in theory ?1
6071	Theory ?0 is a read-only ancestor
=ENDDOC

=DOC
val âlist_save_thmá : (string list * THM) -> THM
=DESCRIBE
$list\_save\_thm(keys, thm)$ causes $thm$ to be save under the keys $keys$ in the current
theory.
=FAILURE
6031	Key list may not be empty
6037	Theory ?0 is locked
6039	Key ?0 has already been used for a theorem in theory ?1
6071	Theory ?0 is a read-only ancestor
=ENDDOC

=DOC
val âdelete_constá : TERM -> unit
=DESCRIBE
$delete\_const\,c$ deletes the constant $c$ and any other object which
depends on $c$ from the current theory. If any saved objects other than $c$ and
its defining theorem do depend on $c$, the interactive user will be notified
and asked whether to proceed with the deletion.

After the deletion
any theorems which have been proven since the definition of $c$ will no
longer be usable for further proof.

Note that the deletion will attempt to delete all necessary
theorems before deleting constants, types, and axioms in single steps,
and thus may fail with a partially modified theory.
This is because checks in the interface may not be as definitive as those of the kernel.
The kernel state change functions will be notified as if
a sequence of $delete\_thm$'s had been done, and then
the necessary ``single step'' deletions of constants, types and axioms to achieve the goal.
=FAILURE
3009	?0 is not a constant
6037	Theory ?0 is locked
6071	Theory ?0 is a read-only ancestor
6076	Theory ?0 has child theories
12001	Theory ?0 does not contain the constant ?1 with the supplied type
12012	Deletion of ?0 would require the deletion of ?1
=ENDDOC

=DOC
val âdelete_typeá : string -> unit
=DESCRIBE
$delete\_type\,t$ deletes the type constructor $t$ and any other object which
depends on $t$ from the current theory. If any objects other than $t$ and
its defining theorem do depend on $t$, the interactive user will be notified
and asked whether to proceed with the deletion.

After the deletion
ny theorems which have been proven since the definition of $ty$ will no
longer be usable for further proof.

Note that the deletion will attempt to delete all necessary
theorems before deleting constants, types, and axioms in single steps,
and thus may fail with a partially modified theory.
This is because checks in the interface may not be as definitive as those of the kernel.
The kernel state change functions will be notified as if
a sequence of $delete\_thm$'s had been done, and then
the necessary ``single step'' deletions of constants, types and axioms to achieve the goal.
=FAILURE
6037	Theory ?0 is locked
6071	Theory ?0 is a read-only ancestor
6076	Theory ?0 has child theories
12002	Theory ?0 does not contain the type constructor ?1
12012	Deletion of ?0 would require the deletion of ?1
=ENDDOC

=DOC
val âdelete_axiomá : string -> unit
=DESCRIBE
$delete\_axiom\,key$ deletes the
axiom stored under key $key$ and any other object which
depends on it from the current theory. If any objects
do depend on the axiom, the interactive user will be notified
and asked whether to proceed with the deletion.

After the deletion any theorems which have been proven since the introduction
of the axiom will no longer be usable for further proof.

Note that the deletion will attempt to delete all necessary
theorems before deleting constants, types, and axioms in single steps,
and thus may fail with a partially modified theory.
This is because checks in the interface may not be as definitive as those of the kernel.
The kernel state change functions will be notified as if
a sequence of $delete\_thm$'s had been done, and then
the necessary ``single step'' deletions of constants, types and axioms to achieve the goal.
=FAILURE
6037	Theory ?0 is locked
6071	Theory ?0 is a read-only ancestor
6076	Theory ?0 has child theories
12003	Theory ?0 does not contain an axiom under key ?1
12012	Deletion of ?0 would require the deletion of ?1
=ENDDOC

=DOC
val âdelete_thmá : string -> THM;
=DESCRIBE
$delete\_thm\,key$ deletes the
theorem stored under key $key$ from the current theory.
It returns the deleted theorem.
=FAILURE
6037	Theory ?0 is locked
6046	Key ?0 is not used for a theorem in theory ?1
6071	Theory ?0 is a read-only ancestor
=ENDDOC

=DOC
val ânew_axiomá : (string * TERM) -> THM
=DESCRIBE
$new\_axiom(key, tm)$ stores the boolean term $tm$ an axiom in the
current theory as an axiom under key $key$.
=FAILURE
3031	?0 is not of type »:BOOL¼
6037	Theory ?0 is locked
6047	Key ?0 has already been used for an axiom in theory ?1
6071	Theory ?0 is a read-only ancestor
=ENDDOC

=DOC
val ânew_constá : (string * TYPE) -> TERM;
=DESCRIBE
$new\_const$ $(name, type)$ introduces a new constant
(with no defining theorem) called $name$, with most general type
$type$, into the current theory.
=FAILURE
6037	Theory ?0 is locked
6049	There is a constant called ?0 already in scope
6063	There is a constant called ?0 in the descendants of the
	current theory
6071	Theory ?0 is a read-only ancestor
=ENDDOC
=DOC
val ânew_typeá : (string * int) -> TYPE;
=DESCRIBE
$new\_type$ $(name, arity)$ introduces a new type constructor 
(with no defining theorem) called $name$ with arity $arity$ into the
current theory.
The function returns the new type with sufficient arguments $'1, '2, \ldots$
to provide a well-formed type.
=FAILURE
6034	There is a type called ?0 in the descendants of the current theory
6037	Theory ?0 is locked
6045	There is a type called ?0 already in scope
6071	Theory ?0 is a read-only ancestor
6088	The arity of a type must be  0
=ENDDOC

=DOC
val âset_user_datumá : (string * USER_DATUM) -> unit;
=DESCRIBE
$set\_user\_datum(key, ud)$ assigns the new value $ud$ to the user data
slot allocated to $key$ in the current theory.
If an old value was present it will be overwritten.
=ERRORS
6037	Theory ?0 is locked
6071	Theory ?0 is a read-only ancestor
=ENDDOC

=DOC
val âget_user_datumá :  string -> string -> USER_DATUM;
=DESCRIBE
$get\_user\_datum\,thy\,key$ returns the value stored in the user data
slot allocated to $key$ in the theory $thy$, if any.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
12009	No user data stored under key ?0 in theory ?1
=ENDDOC

\subsection{Definitional Mechanisms}
\subsubsection{$new\_defn$}
The user's $new\_defn$ is actually an interface to
$new\_specification$. It is discussed in \cite{DS/FMU/IED/HLD010}.
For uniformity, the ICL code which needs to make definitions prior
to the definition of $new\_defn$ can use the following interface
to $icl'new\_defn$:
=DOC
val âsimple_new_defná : (string * string * TERM) -> THM;
=DESCRIBE
$simple\_new\_defn$ $(key, name, value)$ declares a new
constant with name $name$, and with most general type being
the type of $value$ in the current theory.
It creates an equational theorem (i.e. of the form `$ name = value$',
or `$ name  value$' if $value$ is boolean), and saves it as a definition
under key $key$ in the current theory,
provided the theorem is well-formed.
If either the constant or theorem introduction fails then
the function does not change the current theory.
The body of $value$ may not contain type variables that are not in the type of $value$ itself.
=FAILURE
6037	Theory ?0 is locked
6049	There is a constant called ?0 already in scope
6051	Key ?0 has already been used for a definition in theory ?1
6058	the body of ?0 contains type variables not found in type of term itself, the variables being: ?1
6059	?0 contains the following free variables: ?1
6063	There is a constant called ?0 in the descendants of the
	current theory
6071	Theory ?0 is a read-only ancestor
=ENDDOC
Conventionally the key used will be the name of the constant defined, though reasons for different keys may arise.
\subsubsection{$new\_type\_defn$}
=DOC
val ânew_type_defná : 
	(string * string * string list * THM) -> THM;
=DESCRIBE
$new\_type\_defn$ $(key, name, typars, defthm)$
declares a new type with name $name$, and arity the length of
$typars$.
It creates a defining theorem for the type, saves it in the current theory under the key $key$. It returns the defining theorem.
$defthm$ must be a valid well-formed theorem of the form:
ó
  x : type  p x
æ
with no assumptions.
The defining theorem will then be of the form:
ó
  f : typars name  type  
	TypeDefn (p: type  BOOL) f
æ
where $TypeDefn$ asserts that its predicate argument 
$p$ is non-empty, and its function argument $f$ is a bijection
between the new type and the subset of $type$ delineated by $p$.
=FAILURE
6034	There is a type called ?0 in the descendants of the current theory
6037	Theory ?0 is locked
6045	There is a type called ?0 already in scope
6052	Key ?0 has already been used for an type definition theorem in theory ?1
6053	?0 must not have assumptions
6054	?0 is not of the form: `  x  px`
6055	?0 is not of the form: `  x  p y` where »x¼  is a variable
6056	?0 contains the free variables: ?1
6057	?0 contains type variables not found in type variable parameter list,
	type variables being: ?1
6071	Theory ?0 is a read-only ancestor
6079	?0 repeated in type parameter list
6080	?0 is not of the form: `  x  p y` where »x¼ equals »y¼
=ENDDOC
\subsubsection{$new\_specification$}
=DOC
val ânew_specificationá : (string list * int * THM) -> THM;
=DESCRIBE
$new\_specification$ $(keylist$, $ndef$, $`  x_1,\ldots,x_n\ \ p[x_1,\ldots,x_n]')$
will introduce $ndef$ new constants named and typed from the $x_i$.
It will also save a defining theorem under each of the keys in
$keylist$ in the current theory of the
form `$ p[c_1,\ldots,c_n]$' where $c_i$ is the constant with the
name and type of $x_i$.
If either the constant or theorem introduction fails then
the function will not change the current theory.
=FAILURE
6016	Existentially bound variable ?0 is repeated in theorem ?1
6031	Key list may not be empty
6037	Theory ?0 is locked
6044	Must define at least one constant
6049	There is a constant called ?0 already in scope
6051	Key ?0 has already been used for a definition in theory ?1
6053	?0 must not have assumptions
6056	?0 contains the free variables: ?1
6060	?0 is not of the form: `  x1 ... xn  p[x1,...,xn]`
	where the »xi¼ are variables, and n( = ?1) is the number of
	constants to be defined
6061	the body of ?0 contains type variables not found in type
	of constants to be defined, the variables being: ?1
6063	There is a constant called ?0 in the descendants of the
	current theory
6071	Theory ?0 is a read-only ancestor
6081	Sets of type variables in ?0 and ?1 differ
=ENDDOC
Conventionally the keys used in $new\_specification$ will be the names of the constants defined, but there may arise reasons to allow different keys.
Certainly, the convention is not forced upon the user.

\subsection{Theory Access Functions}

\subsubsection{Accessing Individual Theorems}
=DOC
val âget_defná : string -> string -> THM;
=DESCRIBE
$get\_defn$ $theory$ $key$ returns the definition with key $key$,
found in theory $theory$.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
12004	Theory ?0 does not have a definition with key ?1
12010	Theory ?0 is not in scope
=ENDDOC
=DOC
val âget_axiomá : string -> string -> THM;
=DESCRIBE
$get\_axiom$ $theory$ $key$ returns the axiom with key $key$,
found in theory $theory$.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
12005	Theory ?0 does not have an axiom with key ?1
12010	Theory ?0 is not in scope
=ENDDOC
=DOC
val âget_thmá : string -> string -> THM;
=DESCRIBE
$get\_thm$ $theory$ $key$ returns the theorem with key $key$,
found in theory $theory$.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
12006	Theory ?0 does not have a theorem with key ?1
12010	Theory ?0 is not in scope
=ENDDOC
=DOC
val âget_const_typeá : string -> TYPE OPT;
=DESCRIBE
If a constant with the given name is in scope, then its type is returned, otherwise $Nil$.
=USES
This is likely to be often used just as a rapid test for a constant being in scope.
=ENDDOC
=DOC
val âget_type_arityá : string -> int OPT;
=DESCRIBE
If a type with the given name is in scope, then its arity is returned, otherwise $Nil$.
=USES
This is likely to be often used just as a rapid test for a type being in scope.
=ENDDOC
\subsubsection{Theory Names and Ancestry}
=DOC
val âget_current_theory_nameá : unit -> string;
=DESCRIBE
Returns the name of the current theory.
=ENDDOC
=DOC
val âtheory_namesá : unit -> string list;
=DESCRIBE
This returns the list of undeleted theories in the current hierarchy,
whether in scope or not.
=ENDDOC
=DOC
val âget_ancestorsá : string -> string list;
=DESCRIBE
This returns all the ancestors of the named theory, including
the theory itself.
The named theory is the last name in the list returned.
The name of the parent first added to the named theory is next to last,
preceded by its ancestors.
All these are preceded by the second parent theory and its ancestors,
apart from those already added.
These are preceded by any unnoted ancestors of the third, fourth, etc parents of the named theory.
The order in the list of the ancestors of the parent theories is determined recursively by this ordering.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
=DOC
val âis_theory_ancestorá : string -> string -> bool;
=DESCRIBE
$is\_theory\_ancestor$ $thy1$ $thy2$ returns true if 
$thy1$ is an ancestor of $thy2$ within the current hierarchy.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=FAILUREC
This failure arises if either theory name is not present in the current hierarchy.
=ENDDOC
=DOC
val âget_parentsá : string -> string list;
=DESCRIBE
This returns the immediate parents of the named theory, (not including
the theory itself).
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
=DOC
val âget_childrená : string -> string list;
=DESCRIBE
This returns the immediate children of the named theory, (not including
the theory itself).
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
=DOC
val âget_descendantsá : string -> string list;
=DESCRIBE
This returns all the descendants of the named theory, including
itself.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
\subsection{Accessing Theory Contents}
=DOC
val âget_defnsá : string -> (string list * THM) list;
=DESCRIBE
This returns all the defining theorems stored in the indicated
theory together with the keys under which they are stored.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
=DOC
val âget_axiomsá : string -> (string list * THM) list;
=DESCRIBE
This returns all the axioms stored in the indicated
theory together with the keys under which they are stored.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
=DOC
val âget_thmsá : string -> (string list * THM) list;
=DESCRIBE
This returns all the theorems stored in the indicated
theory together with the keys under which they are stored.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
=DOC
val âget_constsá : string -> TERM list;
=DESCRIBE
This returns (most general instances of) all the constants stored on a theory.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
=DOC
val âget_typesá : string -> TYPE list;
=DESCRIBE
This returns (canonical applications of) all the type constructors stored on a theory.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
\subsubsection{Accessing Status Information}
=DOC
val âget_current_theory_statusá : unit -> THEORY_STATUS;
=DESCRIBE
This returns the current theory's status.
=ENDDOC
=DOC
val âget_theory_statusá : string -> THEORY_STATUS;
=DESCRIBE
This returns the status of the indicated theory.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
\section{NOTIFICATION OF STATE CHANGES}

Subsystems such as the user interface need to be notified
when state changes occur (e.g. when the current theory changes).
We supply an interface which allows a function to be nominated to
be called whenever a state change occurs. In general, there will be
a list of such functions. The functions have a single argument which
encodes the type of operation, its arguments and where appropriate
its result type. 

=DOC
datatype âKERNEL_STATE_CHANGEá
		=	âOpenTheoryá of string * ((string list) * (string list))
		|	âDeleteTheoryá of string
		|	âNewTheoryá of string
		|	âNewParentá of string * (string list)
		|	âLockTheoryá of string
		|	âUnlockTheoryá of string
		|	âDuplicateTheoryá of string * string
		|	âSaveThmá of string * THM
		|	âListSaveThmá of string list * THM
		|	âDeleteConstá of TERM
		|	âDeleteTypeá of string
		|	âDeleteAxiomá of string
		|	âDeleteThmá of string
		|	âNewAxiomá of (string * TERM)*THM
		|	âNewConstá of string * TYPE
		|	âNewTypeá of string * int
		|	âSimpleNewDefná of (string * string * TERM) * THM
		|	âNewTypeDefná of (string * string * (string list) * THM) * THM
		|	âNewSpecificationá of (string list * int * THM) * THM
		|	âSetUserDatumá of string * USER_DATUM;
=DESCRIBE
This is an encoding of the arguments of
the functions which change the state of the theory database in the lowest
level of interface.
When used to notify the system of a change that has been made
certain additional information is also included. 
If used to notify the system before a change is made the slots will be given ``null'' default values ($``''$, $[]$, $asm\_rule$ $mk\_t$).

{\hfuzz 3pt
\begin{tabular}{|l|l|p{2.73in}|}\hline
Operation & Value & Description \\\hline
$open\_theory$ &  
$(thy, (outthys, inthys))$ &
$thy$ names the theory which has been opened.
$outthys$ names the theories which have gone out of scope.
$inthys$ names the theories which have come into scope.
\\\hline
$new\_parent$ &
$(thy, inthys)$ &
$thy$ names the new parent theory.
$inthys$ names the theories which have come into scope.
\\\hline
\begin{tabular}[t]{l}
$SimpleNewDefn$\\$NewTypeDefn$\\$NewSpecification$\\$NewAxiom$\\
\end{tabular} &
$(arg, thm)$ &
$arg$ gives the argument to the operation. $thm$ is the new defining
theorem.
\\\hline
\end{tabular}}

SEE ALSO
$on\_kernel\_state\_change$,
$before\_kernel\_state\_change$
=ENDDOC

=DOC
val âon_kernel_state_changeá : (KERNEL_STATE_CHANGE -> unit) -> unit
=DESCRIBE
$on\_kernel\_state\_change\ f$
nominates $f$ to be called whenever the theory database
is modified by a low level interface. The argument to $f$ encodes the
operation which caused the modification together with its arguments and
certain other additional information.
A list of such functions is maintained, and the new function is put at the
end of the list, which means it may, if desired undo or overwrite the effects of a
function nominated by an earlier call of $on\-\_kernel\-\_state\-\_change$.

Functions handled by $on\_kernel\_state\_change$ should not be
coded to raise errors that are not handled by themselves,
and the handler will not catch such errors either.
If the function is to prevent a change from happening $before\-\_kernel\-\_state\-\_change$ should be used instead.
=SEEALSO
$KERNEL\_STATE\_CHANGE$,
$before\_kernel\_state\_change$
=ENDDOC
=DOC
val âbefore_kernel_state_changeá : (KERNEL_STATE_CHANGE -> unit) -> unit
=DESCRIBE
$before\_kernel\_state\_change\ f$
nominates $f$ to be called before the theory database
is to be modified by a low level interface. The argument to $f$ encodes the
operation which caused the modification together with its arguments and
certain other additional information
(usually sets to null defaults for this function).
A list of such functions is maintained, and the new function is put at the
end of the list, which means it may, if desired undo or overwrite the effects of a
function nominated by an earlier call of $before\-\_kernel\-\_state\-\_change$.

Functions handled by $before\_kernel\_state\_change$ might be
used to raise errors to prevent the state change occurring.
This will prevent further checks or actions being made.
Thus a careful choice between $before\_$ or $on\_$ is called for.
=SEEALSO
$KERNEL\_STATE\_CHANGE$,
$on\_kernel\_state\_change$
=ENDDOC
=SML
end(* signature of KernelInterface *);
=TEX
\section{TEST POLICY}
The functions in this document should be tested according to the
general criteria set out in \cite{DS/FMU/IED/PLN008}, using the
tests in \cite{DS/FMU/IED/MDT012}.

=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
