=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
\TPPtitle{Detailed Design for the Interface to the Abstract Data Type $THM$}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the \cr
Interface to the Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/DTD012}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D. Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
interface to the
abstract data type $THM$.
This includes all those functions that the kernel of ICL HOL
will need to interface to the abstract data type, but do not 
need to be present within the abstract data type.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library \\ KB \\RBJ
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue \SCCSversion (\FormatDate{$Date$%
})] First draft.
First version.
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the interface to the
abstract data type $THM$.
The interface functions complete the set of functions called 
for in section 4 of \cite{DS/FMU/IED/HLD007}.
The design is implemented in \cite{DS/FMU/IED/IMP012}.

The interfaces given here do not include the inference rules.
The interfaces for the rules are considered in \cite{DS/FMU/IED/DTD007}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the detailed design for the interface
functions to the abstract data type $THM$.
These functions give a user- or programmar- oriented interface rather
than the raw minimum supplied by the abstract data type itself.

\subsubsection{Dependencies}
This document depends on \cite{DS/FMU/IED/DTD006}.
The implementation will depend on \cite{DS/FMU/IED/IMP006}.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}
\section{DISCUSSION}
A few minor policy decisions are worth noting:

\begin{enumerate}
\item the interface provided uses strings for theory names throughout
(rather than the numeric theory identifies used in the abstract data
type);
\item as in the abstract data type, modifications to a theory may
only happen when it is current;
\item operations which change the state are formulated as uncurried
functions so that an interactive user is less likely to omit an
argument unwittingly.
\end{enumerate}


\section{PREAMBLE}
=DOC
signature âKernelInterfaceá = sig
=DESCRIBE
This provides interface functions to the abstract
data type $THM$.
=ENDDOC
\section{TYPES}
Most of the types with which the interface works are given in the
signature $KernelTypes$ defined in \cite{DS/FMU/IED/DTD006}.
Here we merely need to include that signature:
=SML
include KernelTypes;
=TEX
The following data type is used as the argument

\section{THEORY MANAGEMENT OPERATIONS}
\subsection{Operations on Hierarchies}
No operations on hierarchies are supplied in this interface. The only
user interface to hierarchies is via the UNIX commands as described
in \cite{DS/FMU/IED/HLD005} and these use the interfaces of
\cite{DS/FMU/IED/DTD006} directly.

\subsection{Operations on Theory Attributes}
=DOC
val âopen_theoryá : string -> unit;
=DESCRIBE
All specification and proof work is carried out in the context
of some theory, referred to as the current theory.
$open\_theory\,thy$ makes the theory $thy$ the current theory.
=FAILURE
6035    Theory ?0 is not present in the current hierarchy
6036    Theory ?0 has been deleted from the current hierarchy
=ENDDOC

=DOC
val âdelete_theoryá : string -> unit;
=DESCRIBE
$delete\_theory\,thy$ removes the theory $thy$ from the theory database.
This means that all theorems that were proven with the deleted 
theory as the current theory will become unusable.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6036	Theory ?0 has been deleted from the current hierarchy
6037	Theory ?0 is locked
6038	Theory ?0 has child theories
6069	Theory ?0 is in scope
=ENDDOC

=DOC
val ânew_theoryá : string -> unit;
=DESCRIBE
$new\_theory\,thy$ adds a new, empty, theory called
$thy$ to the theory database,
The empty theory has no declarations within it,
but does have the current theory as its sole parent.
The new theory becomes the current theory.
=FAILURE
6040	Theory ?0 is already present in current theory hierarchy
=ENDDOC

=DOC
val âlock_theoryá : string -> unit;
=DESCRIBE
$lock\_theory\,thy$ causes $thy$ to be {\em locked}. The contents of
a locked theory are protected from further changes.
A locked theory may be unlocked using $'unlock\_theory$(q.v.).
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6036	Theory ?0 has been deleted from the current hierarchy
6037	Theory ?0 is locked
=ENDDOC

=DOC
val âunlock_theoryá : string -> unit;
=DESCRIBE
$unlock\_theory\,thy$ causes the locked theory $thy$ to be unlocked,
so that the contents of $thy$ may be changed.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6036	Theory ?0 has been deleted from the current hierarchy
6068	Theory ?0 has not been locked
=ENDDOC

=DOC
val âduplicate_theoryá : (string * string) -> unit;
=DESCRIBE
$duplicate\_theory\,oldthy\,newthy$ creates a new theory,
called $newthy$
with the same contents and parents as $oldthy$,
but without any children.
=USES
To allow the user to modify and experiment with a theory that
has child theories that are not involved in the experiment,
and would perhaps clash with the experiment.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6036	Theory ?0 has been deleted from the current hierarchy
=ENDDOC

\subsection{Operations on Theory Contents}
=DOC
val âdest_thmá : THM -> SEQ;
=DESCRIBE
This returns the representation of a theorem as a sequent, i.e. as a list of assumptions and a conclusion.
=ENDDOC

=DOC
val âthm_theoryá : THM -> string;
=DESCRIBE
$thm\_theory\,thm$ returns the name of the theory which was current when
$thm$ was proved.
=ENDDOC

=DOC
val âsave_thmá : (string * THM) -> THM
=DESCRIBE
$save\_thm(key, thm)$ causes $thm$ to be save under the key $key$ in the current
theory
=FAILURE
6037	Theory ?0 is locked
6039	Key ?0 has already been used for a theorem in theory ?1
=ENDDOC

=DOC
val âlist_save_thmá : (string list * THM) -> THM
=DESCRIBE
$list\_save\_thm(keys, thm)$ causes $thm$ to be save under the keys $keys$ in the current
theory
=FAILURE
6037	Theory ?0 is locked
6031	Key list may not be empty
6039	Key ?0 has already been used for a theorem in theory ?1
=ENDDOC

=DOC
val âdelete_constantá : TERM -> unit
=DESCRIBE
$delete\_constant\,c$ deletes the constant $c$ and any other object which
depends on $c$ from the current theory. If any objects other than $c$ and
its defining theorem do depend on $c$, the interactive user will be notified
and asked whether to proceed with the deletion.

After the deletion
ny theorems which have been proved since the definition of $c$ will no
longer be usable for further proof.
=FAILURE
6037	Theory ?0 is locked
12001	Theory ?0 does not contain the constant ?1
12002	?0 is not a constant
=ENDDOC

=DOC
val âdelete_typeá : string -> unit
=DESCRIBE
$delete\_type\,t$ deletes the type constructor $t$ and any other object which
depends on $t$ from the current theory. If any objects other than $t$ and
its defining theorem do depend on $t$, the interactive user will be notified
and asked whether to proceed with the deletion.

After the deletion
ny theorems which have been proved since the definition of $ty$ will no
longer be usable for further proof.
=FAILURE
6037	Theory ?0 is locked
12002	Theory ?0 does not contain the type constructor ?1
=ENDDOC

=DOC
val âdelete_axiomá : string -> unit
=DESCRIBE
$delete\_axiom\,key$ deletes the
axiom stored under key $key$ and any other object which
depends on it from the current theory. If any objects
do depend on the axiom, the interactive user will be notified
and asked whether to proceed with the deletion.

After the deletion ny theorems which have been proved since the introduction
of the axiom will no longer be usable for further proof.
=FAILURE
6037	Theory ?0 is locked
12003	Theory ?0 does not contain an axiom under key ?1
=ENDDOC

=DOC
val âdelete_thmá : string -> unit
=DESCRIBE
$delete\_thm\,key$ deletes the
theorem stored under key $key$ from the current theory.
=FAILURE
6037	Theory ?0 is locked
12003	Theory ?0 does not contain a theorem under key ?1
=ENDDOC

=DOC
val ânew_axiomá : (string * TERM) -> THM
=DESCRIBE
$new\_axiom(key, tm)$ stores the boolean term $tm$ an axiom in the
current theory as an axiom under key $key$.
=FAILURE
6037	Theory ?0 is locked
6047	Key ?0 has already been used for an axiom in theory ?1
6048	Term argument is ill-formed in theory ?0
6017	Term is not boolean
=ENDDOC

=DOC
val ânew_constá : (string * TYPE) -> TERM;
=DESCRIBE
$new\_const$ $(name, type)$ introduces a new constant
(with no defining theorem) called $name$, with most general type
$TYPE$, into the current theory.
=FAILURE
6049	There is a constant called ?0 already in scope
6063	There is a constant called ?0 in the descendants of the
	current theory
=ENDDOC
=DOC
val ânew_typeá : (string * int) -> TYPE;
=DESCRIBE
$new\_type$ $(name, arity)$ introduces a new type constructor 
(with no defining theorem) called $name$ with arity $arity$ into the
current theory.
The function returns the new type with sufficient arguments $'1, '2, \ldots$
to provide a well formed type.
=FAILURE
6045	There is a type called ?0 already in scope
6034	There is a type called ?0 in the descendants of the current theory
=ENDDOC

=DOC
val âset_user_datumá : (string * USER_DATUM) -> unit;
=DESCRIBE
$set\_user\_datum(key, ud)$ assigns the new value $ud$ to the user data
slot allocated to $key$ in the current theory.
=FAILURE
6045	There is a type called ?0 already in scope
6034	There is a type called ?0 in the descendants of the current theory
=ENDDOC

=DOC
val âset_user_datumá :  string -> string -> USER_DATUM OPT;
=DESCRIBE
$get\_user\_datum\,thy\,key$ returns the value stored in the user data
slot allocated to $key$ in the current theory, if any.
=FAILURE
=ENDDOC


\subsection{Definitional Mechanisms}
\subsubsection{$new\_definition$}
The user's $new\_definition$ is actually an interface to
$new\_specification$. It is discussed in \cite{DS/FMU/IED/HLD010}.
For uniformity, the ICL code which needs to make definitions prior
to the definition of $new\_definition$ can use the following interface
to $icl'new\_definition$:
=DOC
val âsimple_new_definitioná : (string * string * TERM) -> THM;
=DESCRIBE
$simple\_new\_definition$ $(key, name, value)$ declares a new
constant with name $name$, and with most general type being
the type of $value$ in the current theory.
It creates a theorem of the form `$… name = value$'
(or `$… name ‚ value$' if $value$ is boolean), and saves it as a definition
under keys in $key$ in the current theory,
provided the theorem is well-formed.
If either the constant or theorem introduction fails then
the function does not change the current theory.
=FAILURE
6031	Key list may not be empty
6037	Theory ?0 is locked
6048	Term argument is ill-formed in theory ?0
6049	There is a constant called ?0 already in scope
6063	There is a constant called ?0 in the descendants of the
	current theory
6051	Key ?0 has already been used for an definition in theory ?1
6058	Term contains type variables not found in type of term itself
6059	Term contains free variables
=ENDDOC
\subsubsection{$new\_type\_definition$}
=DOC
val ânew_type_definitioná : 
	(string * string * string list * THM) -> THM;
=DESCRIBE
$new\_type\_definition$ $(key, name, typars, defthm)$
declares a new type with name $name$, and arity the length of
$typars$.
It creates a defining theorem for the type, saves it in the current theory under the key $key$. It returns the defining theorem.
$defthm$ must be of the form:
ó
… „ x : type Ž p x
æ
with no assumptions.
The defining theorem will then be of the form:
ó
… „ f : typars name ‹ type Ž 
	TypeDefinition (p: type ‹ BOOL) f
æ
where $TypeDefinition$ is defined so as to state that its predicate argument 
$p$ is non-empty, and its function argument $f$ is a bijection
between the new type and the subset of $type$ delineated by $p$.
=FAILURE
6037	Theory ?0 is locked
6045	There is a type called ?0 already in scope
6034	There is a type called ?0 in the descendants of the current theory
6052	Key ?0 has already been used for an type definition theorem in theory ?1
6053	Theorem must not have assumptions
6054	Theorem is not of the form: `… „ x Ž p x`
6055	Theorem is not of the form: `… „ x Ž p x` where »x¼  is a variable
6056	Theorem contains free variables
6057	Theorem contains type variables not found in type variable parameter list
6031	Key list may not be empty
=ENDDOC
\subsubsection{$new\_specification$}
=DOC
val ânew_specificationá : (string list * int * THM) -> THM;
=DESCRIBE
$new\_specification$ $(keylist$, $ndef$, $`… „ x_1,\ldots,x_n\ Ž\ p[x_1,\ldots,x_n]')$
will introduce $ndef$ new constants named and typed from the $x_i$.
It will also save a defining theorem under each of the keys in
$keylist$ in the current theory of the
form `$… p[c_1,\ldots,c_n]$' where $c_i$ is the constant with the
name and type of $x_i$.
If either the constant or theorem introduction fails then
the function will not change the current theory.
=FAILURE
6031	Key list may not be empty
6037	Theory ?0 is locked
6049	There is a constant called ?0 already in scope
6063	There is a constant called ?0 in the descendants of the
	current theory
6060	Theorem is not of the form `… „ x1,...,xn Ž p[x1,...,xn]`
6051	Key ?0 has already been used for an definition in theory ?1
6053	Theorem must not have assumptions
6056	Theorem contains free variables
6044	Must define at least one constant
6064	Theorem must be existentially quantified at least ?0 times
6061	Theorem contains type variables ?0 not found in the type of
	all the constants to be defined
6016	Theorem is not of the form `… „ x1,...,xn Ž p[x1,...,xn]`
	where the »xi¼ are all distinct
=ENDDOC
\subsection{$new\_parent$}
=DOC
val ânew_parentá : string -> unit;
=DESCRIBE
Adds the given parent theory to the list of parents of the current
theory, considered as a set.
It will fail if the parent theory does not exist,
or if making it a parent causes clashes in the current theory
or its children.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6036	Theory ?0 has been deleted from the current hierarchy
6037	Theory ?0 is locked
6067	Making ?0 a parent would cause a clash
=ENDDOC

\subsection{Theory Access Functions}

\subsubsection{Accessing Individual Theorems}
=DOC
val âget_definitioná : string -> string -> THM;
=DESCRIBE
$get\_definition$ $theory$ $key$ returns the definition with key $key$,
found in theory $theory$.
=FAILURE
12001	Theory ?0 is not present in the current hierarchy
12002	Theory ?0 has been deleted from the current hierarchy
12003	Theory ?0 is not in scope
12004	Theory ?0 does not have a definition with key ?1
=ENDDOC
=DOC
val âget_axiomá : string -> string -> THM;
=DESCRIBE
$get\_axiom$ $theory$ $key$ returns the axiom with key $key$,
found in theory $theory$.
=FAILURE
12001	Theory ?0 is not present in the current hierarchy
12002	Theory ?0 has been deleted from the current hierarchy
12003	Theory ?0 is not in scope
12005	Theory ?0 does not have an axiom with key ?1
=ENDDOC
=DOC
val âget_theoremá : string -> string -> THM;
=DESCRIBE
$get\_theorem$ $theory$ $key$ returns the theorem with key $key$,
found in theory $theory$.
=FAILURE
12001	Theory ?0 is not present in the current hierarchy
12002	Theory ?0 has been deleted from the current hierarchy
12003	Theory ?0 is not in scope
12006	Theory ?0 does not have a theorem with key ?1
=ENDDOC
\subsubsection{Theory Names and Ancestry}
=DOC
val âtheory_namesá : unit -> string list;
=DESCRIBE
This returns the list of undeleted theories in the current hierarchy,
whether in scope or not.
=ENDDOC
=DOC
val âget_ancestorsá : string -> string list;
=DESCRIBE
This returns all the ancestors of the named theory, including
the theory itself.
=ENDDOC
=DOC
val âget_parentsá : string -> string list;
=DESCRIBE
This returns the immediate parents of the named theory, (not including
the theory itself).
=FAILURE
12001	Theory ?0 is not present in the current hierarchy
12002	Theory ?0 has been deleted from the current hierarchy
=ENDDOC
=DOC
val âget_childrená : string -> string list;
=DESCRIBE
This returns the immediate children of the named theory, (not including
the theory itself).
=FAILURE
12001	Theory ?0 is not present in the current hierarchy
12002	Theory ?0 has been deleted from the current hierarchy
=ENDDOC
This will be needed to implement other features in the abstract data type,
and could be useful to the user, though it has the feels of a 
derived function.
=DOC
val âget_descendantsá : string -> string list;
=DESCRIBE
This returns all the descendants of the named theory, including
itself.
=FAILURE
12001	Theory ?0 is not present in the current hierarchy
12002	Theory ?0 has been deleted from the current hierarchy
=ENDDOC
\subsection{Accessing Theory Contents}
=DOC
val âget_definitionsá : string -> (string list * THM) list;
=DESCRIBE
This returns all the defining theorems stored in the indicated
theory together with the keys under which they are stored.
=FAILURE
12001	Theory ?0 is not present in the current hierarchy
12002	Theory ?0 has been deleted from the current hierarchy
=ENDDOC
=DOC
val âget_axiomsá : string -> (string list * THM) list;
=DESCRIBE
This returns all the axioms stored in the indicated
theory together with the keys under which they are stored.
=FAILURE
12001	Theory ?0 is not present in the current hierarchy
12002	Theory ?0 has been deleted from the current hierarchy
=ENDDOC
=DOC
val âget_theoremsá : string -> (string list * THM) list;
=DESCRIBE
This returns all the theorems stored in the indicated
theory together with the keys under which they are stored.
=FAILURE
12001	Theory ?0 is not present in the current hierarchy
12002	Theory ?0 has been deleted from the current hierarchy
=ENDDOC
=DOC
val âget_constantsá : string -> TERM list;
=DESCRIBE
This returns (most general instances of) all the constants stored on a theory.
=FAILURE
12001	Theory ?0 is not present in the current hierarchy
12002	Theory ?0 has been deleted from the current hierarchy
=ENDDOC
=DOC
val âget_typesá : string -> TYPE list;
=DESCRIBE
This returns (canonical applications of) all the type constructors stored on a theory.
=FAILURE
12001	Theory ?0 is not present in the current hierarchy
12002	Theory ?0 has been deleted from the current hierarchy
=ENDDOC
\subsubsection{Accessing Status Information}
=DOC
val âget_statusá : string -> THEORY_STATUS;
=DESCRIBE
This returns the status of the indicated theory.
=FAILURE
12001	Theory ?0 is not present in the current hierarchy
=ENDDOC
\section{NOTIFICATION OF STATE CHANGES}

Subsystems such as the user interface need to be notified
when state changes occur (e.g. when the current theory changes).
We supply an interface which allows a function to be nominated to
be called whenever a state change occurs. In general, there will be
a list of such functions. The functions have a single argument which
encodes the type of operation, its arguments and where appropriate
its result type. 

=DOC
datatype âKERNEL_STATE_CHANGEá
		=	âOpenTheoryá of string * ((string list) * (string list))
		|	âDeleteTheoryá of string
		|	âNewTheoryá of string
		|	âLockTheoryá of string
		|	âUnlockTheoryá of string
		|	âDuplicateTheoryá of string
		|	âSaveThmá of string * THM
		|	âListSaveThmá of string list * THM
		|	âDeleteConstantá of TERM
		|	âDeleteTypeá of string
		|	âDeleteAxiomá of string
		|	âDeleteThmá of string
		|	âNewAxiomá of string * TERM
		|	âNewConstá of string * TYPE
		|	âNewTypeá of string * int
		|	âSimpleNewDefinitioná of (string * string * TERM) * THM
		|	âNewTypeDefinitioná of (string * string * (string list) * THM) * THM
		|	âNewSpecificationá of (string list * int * THM) * THM
		|	âNewParentá of string * (string list);
=DESCRIBE
This is an encoding of the arguments of
the functions which change the state of the theory database in the lowest
level of interface.
Certain additional information is also included, in some cases,
as follows:


{\hfuzz 3pt
\begin{tabular}{|l|l|p{2.73in}|}\hline
Operation & Value & Description \\\hline
$open\_theory$ &  
$(thy, (outthys, inthys))$ &
$thy$ names the theory which has been opened.
$outthys$ names the theories which have gone out of scope.
$inthys$ names the theories which have come into scope.
\\\hline
$new\_parent$ &
$(thy, inthys)$ &
$thy$ names the new parent theory.
$inthys$ names the theories which have come into scope.
\\\hline
\begin{tabular}[t]{l}
$SimpleNewDefinition$\\$NewTypeDefinition$\\$NewSpecification$\\
\end{tabular} &
$(arg, thm)$ &
$arg$ gives the argument to the operation. $thm$ is the new defining
theorem.
\\\hline
\end{tabular}}

SEE ALSO
$on\_kernel\_state\_change$
=ENDDOC

=DOC
val âon_kernel_state_changeá : (KERNEL_STATE_CHANGE -> unit) -> unit
=DESCRIBE
$on\_kernel\_state\_change\,$
nominates $f$ to be called whenever the theory database
is modified by a low level interface. The argument to $f$ encodes the
operation which caused the modification together with its arguments and
certain other additional information.
A list of such functions is maintained, and the new function is put at the
end of the list, which means it may, if desired undo or overwrite the effects of a
function nominated by an earlier call of $on\_kernel\_state\_change$.
SEE ALSO
$KERNEL\_STATE\_CHANGE$
=ENDDOC

=SML
end(* signature of Theorems *);
=TEX
\section{TEST POLICY}
The functions in this document should be tested according to the
general criteria set out in \cite{DS/FMU/IED/PLN008}, using the
tests in \cite{DS/FMU/IED/MDT012}.

=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
