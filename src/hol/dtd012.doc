=IGN
********************************************************************************
dtd012.doc: this file is part of the PPHol system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
%  dtd012.doc  $Id: dtd012.doc,v 2.25 2002/12/14 17:02:02 rda Exp rda $ %Z%
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
\TPPtitle{Detailed Design for the Interface to the Abstract Data Type $THM$}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the \cr
Interface to the Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/DTD012}  %% Mandatory field
\def\SCCSversion{$Revision: 2.25 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2002/12/14 17:02:02 $ %
}}  %% Mandatory field
\TPPstatus{Draft}
%\TPPstatus{Approved}
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{R.D. Arthan & WIN01}  %% Mandatory field
\TPPauthors{R.D. Arthan & WIN01\\K. Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
interface to the
abstract data type $THM$.
This includes all those functions that the kernel of ICL HOL
will need to interface to the abstract data type, but do not 
need to be present within the abstract data type.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library \\ RDA \\ KB \\RBJ
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1 - 1.17]
First drafts leading up to deskcheck ID0042,
and the resulting rework.
\item [Issue 2.1 (18th September 1991)]
Approved version of issue 1.17.
\item [Issue 2.2 (25th September 1991)]
Approved version of issue 2.1, differing only in a ``=ERRORS'' being replaced by the correct marker, ``=FAILURE''.

\item[Issue 2.3~(\FormatDate{92/01/20})] Updated to use new fonts.
\item[Issue 2.4 (23rd January 1992)]
$new\_axiom$, $simple\_new\_type\_defn$ and $new\-\_type\-\_defn$
all changed to take lists of keys, rather than single ones.
\item [Issue 2.6 (13th April 1992)]
Changes due to CR0017.
\item[Issue 2.8 (14 May 1992)] 
Use correct quotation symbols.
\item [Issue 2.9(26th May 1992)]
Renamings from version 1.5 of DS/FMU/IED/WRK038.
\item [Issue 2.10 (31st July 1992)]
Added $do\_in\_theory$.
\item [Issue 2.11 (14th December 1992)]
Added $pending\_reset\_ksc\_functions$.
\item [Issue 2.13 (7th January 1993)]
Clarifying text.
\item [Issue 2.14 (18th February 1993)]
$delete\_const$ will now delete constant at head of application.
\item [Issue 2.15-2.17 (16th-18th August 1993)]
Added type, term and theorem compactification.
\item [Issue 2.18 (8th December 1993)]
Added $get\_theory\_names$.
\item [Issue 2.19 (9th August 2001)]
Added description of new caching mechanism.
\item [Issue 2.20]
Added functions to access the efficient representations of the axioms, definitions
and theorems in a theory.
\item[Issue 2.21] Copyright and banner updates for open source release.
\item[Issue 2.22] PPHol-specific updates for open source release
\item[Issue 2.23] Removed unnecessary level of indirection from the {\it USER\_DATA} data type.
\item[Issues 2.24 -- 2.27] Introduced theory checkpointing functionality.
\end{description}
% \subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the interface to the
abstract data type $THM$.
The interface functions complete the set of functions called 
for in section 4 of \cite{DS/FMU/IED/HLD007}.
The design is implemented in \cite{DS/FMU/IED/IMP012}.

The interfaces given here do not include the inference rules.
The interfaces for the rules are considered in \cite{DS/FMU/IED/DTD007}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the detailed design for the theory management interface
functions to the abstract data type $THM$.
These functions give a user- or programmer- oriented interface rather
than the raw minimum supplied by the abstract data type itself.

\subsubsection{Dependencies}
This document depends on \cite{DS/FMU/IED/IMP006}.
\subsubsection{Deficiencies}
Error 6067 of $new\_parent$ would be best replaced by 
an error that indicates the cause of the clash.
\subsubsection{Possible Enhancements}
There is some possibility for further experimentation and improvement
of the compactification techniques. One possibility is the use of
a string store to hold constant and variable names.

\section{DISCUSSION}
A few minor policy decisions are worth noting:

\begin{enumerate}
\item the interface provided uses strings for theory names throughout
(rather than the numeric theory identifiers used in the abstract data
type);
\item as in the abstract data type, modifications to a theory may
only happen when it is current;
\item operations which change the state are formulated as uncurried
functions so that an interactive user is less likely to omit an
argument unwittingly.
\item
all functions that take a theory name as a string recognise
``-'' as meaning the current theory.
This will not be indicated in the individual documentation boxes.
\end{enumerate}


\section{PREAMBLE}
=DOC
signature ÛKernelInterfaceÝ = sig
=DESCRIBE
This provides theory management interface functions to the abstract
data type $THM$.
=FAILURE
6013	?0 is ill-formed in current theory: type name ?1 is not declared
6014	?0 is ill-formed in current theory: type name ?1 does not have arity used
6015	?0 is ill-formed in current theory: constant name ?1 not declared
6038	?0 is ill-formed in current theory: constant name ?1 cannot have type used
=FAILUREC
The above are error messages various kinds of well-formedness check failures.
A well-formedness check occurs on any types, terms and theorems saved in a theory, and thus these errors may occur for any function in this signature which saves types, terms or theorems in a theory.
=ENDDOC
There are errors common to many kernel (i.e. from the abstract data type) functions, that
are raised by $error$.
This means that they raise exceptions whose ``area'' is a
kernel function that is used to implement a corresponding
interface function of this document.
\section{TYPES}
Most of the types with which the interface works are given in the
signature $KernelTypes$ defined in \cite{DS/FMU/IED/DTD006}.
Here we merely need to include that signature:
=SML
include KernelTypes;
=TEX

\section{THEORY MANAGEMENT OPERATIONS}
\subsection{Operations on Hierarchies}
No operations on hierarchies are supplied in this interface. The only
user interface to hierarchies is via the UNIX commands as described
in \cite{DS/FMU/IED/HLD005} and these use the interfaces of
\cite{DS/FMU/IED/DTD006} directly.

\subsection{Operations on Theory Attributes}
=DOC
val Ûopen_theoryÝ : string -> unit;
=DESCRIBE
All specification and proof work is carried out in the context
of some theory, referred to as the current theory.
$open\_theory\,thy$ makes an existing theory $thy$ the current theory.
=FAILURE
6017	Theory ?0 may not be opened (it is not a descendant of ?1 which must be in scope)
6035	Theory ?0 is not present in the current hierarchy
=FAILUREC
Certain theories created when the system is constructed may
not be subsequently opened, and attempts to open them give rise to error 6017.
=ENDDOC

=DOC
val Ûdelete_theoryÝ : string -> unit;
=DESCRIBE
$delete\_theory\,thy$ removes the theory $thy$ from the theory database.
This means, for instance, that all theorems that were proven with the deleted 
theory as the current theory, and all constants and types declared within the theory, will become out of scope.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6037	Theory ?0 is locked
6069	Theory ?0 is in scope
6071	Theory ?0 is a read-only ancestor
6076	Theory ?0 has child theories
=ENDDOC

=DOC
val Ûnew_theoryÝ : string -> unit;
=DESCRIBE
$new\_theory\,thy$ adds a new, empty, theory called
$thy$ to the theory database.
The empty theory has no declarations within it,
but does have the current theory as its sole parent.
The new theory then becomes the current theory.
=FAILURE
6040	Theory ?0 is already present in current theory hierarchy
=ENDDOC
Note that the notifier functions are only notified of $NewTheory$, not $OpenTheory$ as well.
=DOC
val Ûnew_parentÝ : string -> unit;
=DESCRIBE
Adds the given parent theory to the list of parents of the current
theory, considered as a set.
It will fail if the parent theory does not exist; is already a parent of the current theory;
or if making it a parent would cause a clash by bringing a new theory into scope (perhaps the new parent itself)
that declares a new type or constant that is already in scope,
or is declared in the descendants of the current theory.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6037	Theory ?0 is locked
6067	Making ?0 a parent would cause a clash
6071	Theory ?0 is a read-only ancestor
6082	Theory ?0 is already a parent
6084	Suggested parent ?0 is a child of the current theory
=ENDDOC

=DOC
val Ûlock_theoryÝ : string -> unit;
=DESCRIBE
$lock\_theory\,thy$ causes $thy$ to be {\em locked}. The contents of
a locked theory are protected from further changes.
A locked theory may be unlocked using $unlock\_theory$(q.v.).
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6037	Theory ?0 is locked
6071	Theory ?0 is a read-only ancestor
=ENDDOC

=DOC
val Ûunlock_theoryÝ : string -> unit;
=DESCRIBE
$unlock\_theory\,thy$ causes the locked theory $thy$ to be unlocked,
so that the contents of $thy$ may be changed.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
6068	Theory ?0 has not been locked
=ENDDOC

=DOC
val Ûduplicate_theoryÝ : (string * string) -> unit;
=DESCRIBE
$duplicate\_theory\,oldthy\,newthy$ creates a new theory,
called $newthy$
with the same contents and parents as $oldthy$,
but without any children.
The current theory remains unchanged.
=USES
To allow the user to modify and experiment with a theory that
has child theories that are not involved in the experiment,
and would perhaps clash with the experiment.
=FAILURE
6026	Theory ?0 may not be duplicated
	(it must always be in the scope of any opened theory)
6042	Theory ?0 may not be duplicated (the duplicate would not be a descendant of ?1)
6035	Theory ?0 is not present in the current hierarchy
6040	Theory ?0 is already present in current theory hierarchy
=FAILUREC
To ensure that the duplicate theory can be opened by $open\_theory$ (q.v.) the system will prevent the duplication of 
theories which would give rise to error 6017 of $open\_theory$ if opened, and attempts to create such duplicates will give rise to
error 6026 or 6042.
=ENDDOC

\subsection{Operations on Theorems}
=DOC
val Û=|-Ý : THM * THM -> bool;
val Û~=|-Ý : THM * THM -> bool;
val Û=#Ý : SEQ * SEQ -> bool;
val Û~=#Ý : SEQ * SEQ -> bool;
=DESCRIBE
=INLINEFT
 =|-
=TEX
{} provides a strict equality test on the conclusion and assumptions of theorems,
=INLINEFT
~=|-
=TEX
{} provides an equality test on the conclusion and assumptions of theorems up to $Á$-convertibility and order of assumptions.
=INLINEFT
 =#
=TEX
{} provides a strict equality test on sequents,
=INLINEFT
~=#
=TEX
{} provides an equality test on the sequents up to $Á$-convertibility and order of assumptions.
=ENDDOC
=DOC
val Ûdest_thmÝ : THM -> SEQ;
=DESCRIBE
This returns the representation of a theorem as a sequent, i.e. as a list of assumptions and a conclusion.
=SEEALSO
$asms$, $concl$
=ENDDOC
=DOC
val Ûvalid_thmÝ : THM -> bool;
=DESCRIBE
This function uses the check for the validity of theorems:
returning true if valid and false otherwise: it cannot raise exceptions.
=USES
To preempt errors caused by the primitive inference rules,
which raise uncatchable errors when given invalid theorems,
and so return more helpful error messages.
=ENDDOC
=DOC
val Ûthm_failÝ : string -> int -> THM list -> 'a;
=DESCRIBE
$thm\_fail$ $area$ $msg$ $thml$ first creates a list of functions from $unit$ to $string$, providing displays of the list of theorems.
It then calls $fail$ with the $area$, $msg$ and this list of functions.
This allows theorems to be presented in error messages.
=ENDDOC
=DOC
val Ûstring_of_thmÝ : THM -> string;
=DESCRIBE
This returns a display of a theorem in the form of a string,
with no inserted new lines, suitable for use with $diag\_string$ and $fail$.
=SEEALSO
$format\_thm$, a formatted string display of a theorem.
=ENDDOC
=DOC
val ÛasmsÝ : THM -> TERM list;
=DESCRIBE
This returns the assumptions(hypotheses) of a theorem.
=SEEALSO
$dest\_thm$
=ENDDOC
=DOC
val ÛconclÝ : THM -> TERM;
=DESCRIBE
This returns the conclusion of a theorem.
=SEEALSO
$dest\_thm$
=ENDDOC
=DOC
val Ûthm_theoryÝ : THM -> string;
=DESCRIBE
$thm\_theory\,thm$ returns the name of the theory which was current when
$thm$ was proven.
This will succeed even if the theory is out of scope,
but not if the theory has been deleted.
=FAILURE
12007	?0 proven in theory with internal name ?1, 
	which is not present in current hierarchy
=ENDDOC
\subsection{Operations on Theory Contents}
=DOC
val Ûsave_thmÝ : (string * THM) -> THM
=DESCRIBE
$save\_thm(key, thm)$ causes $thm$ to be save under the key $key$ in the current
theory.
The saved theorem is returned as the function's result.
=FAILURE
6037	Theory ?0 is locked
6039	Key ?0 has already been used for a theorem in theory ?1
6071	Theory ?0 is a read-only ancestor
=ENDDOC

=DOC
val Ûlist_save_thmÝ : (string list * THM) -> THM
=DESCRIBE
$list\_save\_thm(keys, thm)$ causes $thm$ to be save under the keys $keys$ in the current
theory.
The saved theorem is returned as the function's result.
=FAILURE
6031	Key list may not be empty
6037	Theory ?0 is locked
6039	Key ?0 has already been used for a theorem in theory ?1
6071	Theory ?0 is a read-only ancestor
=ENDDOC

=DOC
val Ûdelete_constÝ : TERM -> unit
=DESCRIBE
$delete\_const\,c$ deletes the constant $c$
(or the constant with the same type, up to renaming of type variables) and any other object which
depends on $c$ from the current theory. 
If $c$ is the application of a constant to some arguments
then that constant is the one deleted.
If any saved objects other than $c$ and
its defining theorem do depend on $c$, the interactive user will be notified
and asked whether to proceed with the deletion.

After the deletion
any theorems which have been proven since the definition of $c$ will no
longer be usable for further proof.

Note that the deletion will attempt to delete all necessary
theorems before deleting constants, types, and axioms in single steps,
and thus may fail with a partially modified theory.
This is because checks in the interface may not be as definitive as those of the kernel.
The ``on kernel state change'' functions will be notified as if
all necessary single step deletions, of theorems, constants, types and axioms to achieve the goal had been done, but after
all the actual changes have been made.
The ``before kernel state change'' functions will be notified of all the changes, as if single steps, before any are made.
=FAILURE
6037	Theory ?0 is locked
6071	Theory ?0 is a read-only ancestor
6076	Theory ?0 has child theories
12001	Theory ?0 does not contain the constant ?1 with the supplied type
12012	Deletion of ?0 would require the deletion of ?1
12014	?0 is not a constant or a constant applied to some arguments
=ENDDOC
The following strings are used in formatting the arguments of
message 12012:
=FAILURE
12100	Constant?0:
12101	Type?0:
12102	Theorem?0:
12103	Axiom?0:
12104	Definition?0:
=TEX

=DOC
val Ûdelete_typeÝ : string -> unit
=DESCRIBE
$delete\_type\,t$ deletes the type constructor $t$ and any other object which
depends on $t$ from the current theory. If any objects other than $t$ and
its defining theorem do depend on $t$, the interactive user will be notified
and asked whether to proceed with the deletion.

After the deletion
ny theorems which have been proven since the definition of $ty$ will no
longer be usable for further proof.

Note that the deletion will attempt to delete all necessary
theorems before deleting constants, types, and axioms in single steps,
and thus may fail with a partially modified theory.
This is because checks in the interface may not be as definitive as those of the kernel.
The ``on kernel state change'' functions will be notified as if
all necessary single step deletions, of theorems, constants, types and axioms to achieve the goal had been done, but after
all the actual changes have been made.
The ``before kernel state change'' functions will be notified of all the changes, as if single steps, before any are made.
=FAILURE
6037	Theory ?0 is locked
6071	Theory ?0 is a read-only ancestor
6076	Theory ?0 has child theories
12002	Theory ?0 does not contain the type constructor ?1
12012	Deletion of ?0 would require the deletion of ?1
=ENDDOC

=DOC
val Ûdelete_axiomÝ : string -> unit
=DESCRIBE
$delete\_axiom\,key$ deletes the
axiom stored under key $key$ and any other object which
depends on it from the current theory. If any objects
do depend on the axiom, the interactive user will be notified
and asked whether to proceed with the deletion.

After the deletion any theorems which have been proven since the introduction
of the axiom will no longer be usable for further proof.

Note that the deletion will attempt to delete all necessary
theorems before deleting constants, types, and axioms in single steps,
and thus may fail with a partially modified theory.
This is because checks in the interface may not be as definitive as those of the kernel.
The ``on kernel state change'' functions will be notified as if
all necessary single step deletions, of theorems, constants, types and axioms to achieve the goal had been done, but after
all the actual changes have been made.
The ``before kernel state change'' functions will be notified of all the changes, as if single steps, before any are made.
=FAILURE
6037	Theory ?0 is locked
6071	Theory ?0 is a read-only ancestor
6076	Theory ?0 has child theories
12003	Theory ?0 does not contain an axiom under key ?1
12012	Deletion of ?0 would require the deletion of ?1
=ENDDOC

=DOC
val Ûdelete_thmÝ : string -> THM;
=DESCRIBE
$delete\_thm\,key$ deletes the
theorem stored under key $key$ from the current theory.
It returns the deleted theorem.
=FAILURE
6037	Theory ?0 is locked
6046	Key ?0 is not used for a theorem in theory ?1
6071	Theory ?0 is a read-only ancestor
=ENDDOC

=DOC
val Ûnew_axiomÝ : (string list * TERM) -> THM
=DESCRIBE
$new\_axiom(keys, tm)$ stores the boolean term $tm$ an axiom in the
current theory as an axiom under keys $keys$.
=FAILURE
3031	?0 is not of type BOOL®
6031	Key list may not be empty
6037	Theory ?0 is locked
6047	Key ?0 has already been used for an axiom in theory ?1
6071	Theory ?0 is a read-only ancestor
=ENDDOC

=DOC
val Ûnew_constÝ : (string * TYPE) -> TERM;
=DESCRIBE
$new\_const$ $(name, type)$ introduces a new constant
(with no defining theorem) called $name$, with most general type
$type$, into the current theory.
=FAILURE
6037	Theory ?0 is locked
6049	There is a constant called ?0 already in scope
6063	There is a constant called ?0 in the descendants of the
	current theory
6071	Theory ?0 is a read-only ancestor
=ENDDOC
=DOC
val Ûnew_typeÝ : (string * int) -> TYPE;
=DESCRIBE
$new\_type$ $(name, arity)$ introduces a new type constructor 
(with no defining theorem) called $name$ with arity $arity$ into the
current theory.
The function returns the new type with sufficient arguments $'1, '2, \ldots$
to provide a well-formed type.
=FAILURE
6034	There is a type called ?0 in the descendants of the current theory
6037	Theory ?0 is locked
6045	There is a type called ?0 already in scope
6071	Theory ?0 is a read-only ancestor
6088	The arity of a type must be ¾ 0
=ENDDOC

=DOC
val Ûset_user_datumÝ : (string * USER_DATUM) -> unit;
=DESCRIBE
$set\_user\_datum(key, ud)$ assigns the new value $ud$ to the user data
slot allocated to $key$ in the current theory.
If an old value was present it will be overwritten.
=FAILURE
6037	Theory ?0 is locked
6071	Theory ?0 is a read-only ancestor
=ENDDOC

=DOC
val Ûget_user_datumÝ :  string -> string -> USER_DATUM;
=DESCRIBE
$get\_user\_datum\,thy\,key$ returns the value stored in the user data
slot allocated to $key$ in the theory $thy$, if any.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
12009	No user data stored under key ?0 in theory ?1
=ENDDOC

\subsection{Definitional Mechanisms}
\subsubsection{$new\_defn$}
The user's $new\_defn$ is actually an interface to
$new\_spec$. It is discussed in \cite{DS/FMU/IED/HLD010}.
For uniformity, the ICL code which needs to make definitions prior
to the definition of $new\_defn$ can use the following interface
to $icl'new\_defn$:
=DOC
val Ûsimple_new_defnÝ : (string list * string * TERM) -> THM;
=DESCRIBE
$simple\_new\_defn$ $(keys, name, value)$ declares a new
constant with name $name$, and with most general type being
the type of $value$ in the current theory.
It creates an equational theorem (i.e. of the form `$ô name = value$'), and saves it as a definition
under keys $keys$ in the current theory,
provided the theorem is well-formed.
If either the constant or theorem introduction fails then
the function does not change the current theory.
The body of $value$ may not contain type variables that are not in the type of $value$ itself.
=FAILURE
6031	Key list may not be empty
6037	Theory ?0 is locked
6049	There is a constant called ?0 already in scope
6051	Key ?0 has already been used for a definition in theory ?1
6058	the body of ?0 contains type variables not found in type of term itself,
	the variables being: ?1
6059	?0 contains the following free variables: ?1
6063	There is a constant called ?0 in the descendants of the
	current theory
6071	Theory ?0 is a read-only ancestor
=ENDDOC
Conventionally the key used will be the name of the constant defined, though reasons for different keys may arise.
\subsubsection{$new\_type\_defn$}
=DOC
val Ûnew_type_defnÝ : 
	(string list * string * string list * THM) -> THM;
=DESCRIBE
$new\_type\_defn$ $(keys, name, typars, defthm)$
declares a new type with name $name$, and arity the length of
$typars$.
It creates a defining theorem for the type, saves it in the current theory under the keys $keys$. It returns the defining theorem.
$defthm$ must be a valid well-formed theorem of the form:
=GFT
ô ¶ x : type · p x
=TEX
with no assumptions.
The defining theorem will then be of the form:
=GFT
ô ¶ f : typars name ­ type · 
	TypeDefn (p: type ­ BOOL) f
=TEX
where $TypeDefn$ asserts that its predicate argument 
$p$ is non-empty, and its function argument $f$ is a bijection
between the new type and the subset of $type$ delineated by $p$.
=FAILURE
6031	Key list may not be empty
6034	There is a type called ?0 in the descendants of the current theory
6037	Theory ?0 is locked
6045	There is a type called ?0 already in scope
6052	Key ?0 has already been used for an type definition theorem in theory ?1
6053	?0 must not have assumptions
6054	?0 is not of the form: `ô ¶ x · px`
6055	?0 is not of the form: `ô ¶ x · p y` where ¬x®  is a variable
6056	?0 is a free variable in ?1
6062	?0 are free variables in ?1
6057	?0 contains type variables not found in type variable parameter list,
	type variables being: ?1
6071	Theory ?0 is a read-only ancestor
6079	?0 repeated in type parameter list
6080	?0 is not of the form: `ô ¶ x · p y` where ¬x® equals ¬y®
=ENDDOC
\subsubsection{$new\_spec$}
=DOC
val Ûnew_specÝ : (string list * int * THM) -> THM;
=DESCRIBE
$new\_spec$ $(keylist$, $ndef$, $`ô ¶ x_1,\ldots,x_n\ ·\ p[x_1,\ldots,x_n]')$
will introduce $ndef$ new constants named and typed from the $x_i$.
It will also save a defining theorem under each of the keys in
$keylist$ in the current theory of the
form `$ô p[c_1,\ldots,c_n]$' where $c_i$ is the constant with the
name and type of $x_i$.
If either the constant or theorem introduction fails then
the function will not change the current theory.
=FAILURE
6016	Existentially bound variable ?0 is repeated in theorem ?1
6031	Key list may not be empty
6037	Theory ?0 is locked
6044	Must define at least one constant
6049	There is a constant called ?0 already in scope
6051	Key ?0 has already been used for a definition in theory ?1
6053	?0 must not have assumptions
6056	?0 is a free variable in ?1
6062	?0 are free variables in ?1
6060	?0 is not of the form: `ô ¶ x1 ... xn · p[x1,...,xn]`
	where the ¬xi® are variables, and n( = ?1) is the number of
	constants to be defined
6061	the body of ?0 contains type variables not found in type
	of constants to be defined, the variables being: ?1
6063	There is a constant called ?0 in the descendants of the
	current theory
6071	Theory ?0 is a read-only ancestor
6081	Sets of type variables in ?0 and ?1 differ
=ENDDOC
Conventionally the keys used in $new\_spec$ will be the names of the constants defined, but there may arise reasons to allow different keys.
Certainly, the convention is not forced upon the user.

\subsection{Theory Access Functions}

\subsubsection{Accessing Individual Theorems}
=DOC
val Ûget_defnÝ : string -> string -> THM;
=DESCRIBE
$get\_defn$ $theory$ $key$ returns the definition with key $key$,
found in theory $theory$.

To improve performance, this function uses a cache containing the values of
previous calls. This cache is rebuilt when {\it open\_theory} is called, by
removing entries that have gone out of scope. Opening a theory such as {\it basic\_hol}
that is low down in the theory hierarchy will reclaim the memory occupied by the
cache.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
12004	Theory ?0 does not have a definition with key ?1
12010	Theory ?0 is not in scope
=ENDDOC
=DOC
val Ûget_axiomÝ : string -> string -> THM;
=DESCRIBE
$get\_axiom$ $theory$ $key$ returns the axiom with key $key$,
found in theory $theory$.

To improve performance, this function uses a cache containing the values of
previous calls. This cache is rebuilt when {\it open\_theory} is called, by
removing entries that have gone out of scope. Opening a theory such as {\it basic\_hol}
that is low down in the theory hierarchy will reclaim the memory occupied by the
cache.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
12005	Theory ?0 does not have an axiom with key ?1
12010	Theory ?0 is not in scope
=ENDDOC
=DOC
val Ûget_thmÝ : string -> string -> THM;
=DESCRIBE
$get\_thm$ $theory$ $key$ returns the theorem with key $key$,
found in theory $theory$.

To improve performance, this function uses a cache containing the values of
previous calls. This cache is rebuilt when {\it open\_theory} is called, by
removing entries that have gone out of scope. Opening a theory such as {\it basic\_hol}
that is low down in the theory hierarchy will reclaim the memory occupied by the
cache.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
12006	Theory ?0 does not have a theorem with key ?1
12010	Theory ?0 is not in scope
=ENDDOC
=DOC
val Ûget_const_typeÝ : string -> TYPE OPT;
=DESCRIBE
If a constant with the given name is in scope, then its type is returned, otherwise $Nil$.
=USES
This is likely to be often used just as a rapid test for a constant being in scope.
=SEEALSO
$get\_const\_info$
=ENDDOC
=DOC
val Ûget_type_arityÝ : string -> int OPT;
=DESCRIBE
If a type with the given name is in scope, then its arity is returned, otherwise $Nil$.
=USES
This is likely to be often used just as a rapid test for a type being in scope.
=SEEALSO
$get\_type\_info$
=ENDDOC
\subsubsection{Theory Names and Ancestry}
=DOC
val Ûget_current_theory_nameÝ : unit -> string;
=DESCRIBE
Returns the name of the current theory.
=ENDDOC
=DOC
val Ûget_theory_namesÝ : unit -> string list;
val Ûtheory_namesÝ : unit -> string list;
=DESCRIBE
These return the list of undeleted theories in the current hierarchy, whether
in scope or not.  $theory\_names$ is an alias for $get\_theory\_names$.
=ENDDOC
=DOC
val Ûget_ancestorsÝ : string -> string list;
=DESCRIBE
This returns all the ancestors of the named theory, including
the theory itself.
The named theory is the last name in the list returned.
The name of the parent first added to the named theory is next to last,
preceded by its ancestors.
All these are preceded by the second parent theory and its ancestors,
apart from those already added.
These are preceded by any unnoted ancestors of the third, fourth, etc parents of the named theory.
The order in the list of the ancestors of the parent theories is determined recursively by this ordering.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
=DOC
val Ûis_theory_ancestorÝ : string -> string -> bool;
=DESCRIBE
$is\_theory\_ancestor$ $thy1$ $thy2$ returns true if 
$thy1$ is an ancestor of $thy2$ within the current hierarchy.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=FAILUREC
This failure arises if either theory name is not present in the current hierarchy.
=ENDDOC
=DOC
val Ûget_parentsÝ : string -> string list;
=DESCRIBE
This returns the immediate parents of the named theory, (not including
the theory itself).
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
=DOC
val Ûget_childrenÝ : string -> string list;
=DESCRIBE
This returns the immediate children of the named theory, (not including
the theory itself).
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
=DOC
val Ûget_descendantsÝ : string -> string list;
=DESCRIBE
This returns all the descendants of the named theory, including
itself.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
\subsection{Accessing Theory Contents}
=DOC
val Ûget_defnsÝ : string -> (string list * THM) list;
val Ûget_defn_dictÝ : string -> THM OE_DICT;
=DESCRIBE
{\it get\_defns} returns all the defining theorems stored in the indicated
theory together with the keys under which they are stored.

{\it get\_defn\_dict} returns the mapping of keys to defining theorems represented as an
order-preserving efficient dictionary.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
=DOC
val Ûget_axiomsÝ : string -> (string list * THM) list;
val Ûget_axiom_dictÝ : string -> THM OE_DICT;
=DESCRIBE
{\it get\_axioms} returns all the axioms stored in the indicated
theory together with the keys under which they are stored.

{\it get\_axiom\_dict} returns the mapping of keys to axioms represented as an
order-preserving efficient dictionary.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
=DOC
val Ûget_thmsÝ : string -> (string list * THM) list;
val Ûget_thm_dictÝ : string -> THM OE_DICT;
=DESCRIBE
{\it get\_thms} returns all the theorems stored in the indicated
theory together with the keys under which they are stored.

{\it get\_thm\_dict} returns the mapping of keys to theorems represented as an
order-preserving efficient dictionary.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
=DOC
val Ûget_constsÝ : string -> TERM list;
=DESCRIBE
This returns (most general instances of) all the constants stored on a theory.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
=DOC
val Ûget_typesÝ : string -> TYPE list;
=DESCRIBE
This returns (canonical applications of) all the type constructors stored on a theory.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
\subsubsection{Accessing Status Information}
=DOC
val Ûget_current_theory_statusÝ : unit -> THEORY_STATUS;
=DESCRIBE
This returns the current theory's status.
=ENDDOC
=DOC
val Ûget_theory_statusÝ : string -> THEORY_STATUS;
=DESCRIBE
This returns the status of the indicated theory.
=FAILURE
6035	Theory ?0 is not present in the current hierarchy
=ENDDOC
\section{NOTIFICATION OF STATE CHANGES}

Subsystems such as the user interface need to be notified
when state changes occur (e.g. when the current theory changes).
Others may wish to prevent certain state changes,
and need to be notified before such changes are attempted.
We supply an interface which allows a function to be nominated to
be called whenever a state change occurs,
and another for functions to be called before any state change occurs. 
In general, there will be
lists of such functions. The functions have a single argument which
encodes the type of operation, its arguments and where appropriate
its result type. 

=DOC
datatype ÛKERNEL_STATE_CHANGEÝ
		=	ÛOpenTheoryÝ of string * ((string list) * (string list))
		|	ÛDeleteTheoryÝ of string
		|	ÛNewTheoryÝ of string
		|	ÛNewParentÝ of string * (string list)
		|	ÛLockTheoryÝ of string
		|	ÛUnlockTheoryÝ of string
		|	ÛDuplicateTheoryÝ of string * string
		|	ÛSaveThmÝ of string * THM
		|	ÛListSaveThmÝ of string list * THM
		|	ÛDeleteConstÝ of TERM
		|	ÛDeleteTypeÝ of string
		|	ÛDeleteAxiomÝ of string
		|	ÛDeleteThmÝ of string
		|	ÛNewAxiomÝ of (string list * TERM)*THM
		|	ÛNewConstÝ of string * TYPE
		|	ÛNewTypeÝ of string * int
		|	ÛSimpleNewDefnÝ of (string list * string * TERM) * THM
		|	ÛNewTypeDefnÝ of (string list * string * (string list) * THM) * THM
		|	ÛNewSpecÝ of (string list * int * THM) * THM
		|	ÛSetUserDatumÝ of string * USER_DATUM;
=DESCRIBE
This is an encoding of the arguments of
the functions of signature $KernelInterface$ which change the state of the theory database.
When used to notify the system of a change that has been made
certain additional information is also included. 
If used to notify the system before a change is made the slots will be given ``null'' default values (``'', $[]$, $asm\_rule$ $mk\_t$).

{\hfuzz 3pt
\begin{tabular}{|l|l|p{2.73in}|}\hline
Operation & Value & Description \\\hline
$open\_theory$ &  
$(thy, (outthys, inthys))$ &
$thy$ names the theory which has been opened.
$outthys$ names the theories which have gone out of scope.
$inthys$ names the theories which have come into scope.
\\\hline
$new\_parent$ &
$(thy, inthys)$ &
$thy$ names the new parent theory.
$inthys$ names the theories which have come into scope.
\\\hline
\begin{tabular}[t]{l}
$SimpleNewDefn$\\$NewTypeDefn$\\$NewSpec$\\$NewAxiom$\\
\end{tabular} &
$(arg, thm)$ &
$arg$ gives the argument to the operation. $thm$ is the new defining
theorem.
\\\hline
\end{tabular}}

SEE ALSO
$on\_kernel\_state\_change$,
$before\_kernel\_state\_change$
=ENDDOC

=DOC
val Ûon_kernel_state_changeÝ : (KERNEL_STATE_CHANGE -> unit) -> unit
=DESCRIBE
$on\_kernel\_state\_change\ f$
nominates $f$ to be called whenever the theory database
is modified by a function from the signature $KernelInterface$. The argument to $f$ encodes the
operation which caused the modification together with its arguments and
certain other additional information.
A list of such functions is maintained, and the new function is put at the
end of the list, which means it may, if desired undo or overwrite the effects of a
function nominated by an earlier call of $on\-\_kernel\-\_state\-\_change$.

Functions handled by $on\_kernel\_state\_change$ should not be
coded to raise errors that are not handled by themselves,
as the handler will not catch such errors either.
If the function is to prevent a change from happening $before\-\_kernel\-\_state\-\_change$ should be used instead.
=SEEALSO
$KERNEL\_STATE\_CHANGE$,
$before\_kernel\_state\_change$
=ENDDOC
=DOC
val Ûbefore_kernel_state_changeÝ : (KERNEL_STATE_CHANGE -> unit) -> unit
=DESCRIBE
$before\_kernel\_state\_change\ f$
nominates $f$ to be called before the theory database
is to be modified by functions from the signature $KernelInterface$. The argument to $f$ encodes the
operation which caused the modification together with its arguments and
certain other additional information
(usually sets to null defaults for this function).
A list of such functions is maintained, and the new function is put at the
end of the list, which means it may, if desired undo or overwrite the effects of a
function nominated by an earlier call of $before\-\_kernel\-\_state\-\_change$.

Functions handled by $before\_kernel\_state\_change$ might be
used to raise errors to prevent the state change occurring.
This will prevent further checks or actions being made.
Thus a careful choice between $before\_$ or $on\_$ is called for.
=SEEALSO
$KERNEL\_STATE\_CHANGE$,
$on\_kernel\_state\_change$
=ENDDOC
=DOC
val Ûpending_reset_ksc_functionsÝ : unit -> unit -> unit;
=DESCRIBE
This function, applied to $()$ takes a ``snapshot'' of the
current ``On Kernel State Change'' and ``Before Kernel State Change'' functions.
The resulting snapshot,  when applied to $()$ will restore
these functions to their state at the time of making the snap shot.
=USES
To assist in saving the overall system state.
=ENDDOC
\subsection{Temporary Working in Other Theories}
=DOC
val Ûdo_in_theoryÝ : string -> ('a -> 'b) -> 'a -> 'b;
=DESCRIBE
=INLINEFT
do_in_theory thy f a
=TEX
{} will change to the named theory $thy$, apply $f$ to $a$, and return
to the theory in which it was called.
It will not notify the kernel state change functions
(e.g. $on\-\_kernel\-\_state\-\_change$) when it changes
to the named theory, nor
will it notify them on its return.
Thus for instance the symbol table mechanism, and so term parsing, will behave
as if no theory change had taken place before the
application of $f$ to $a$.
This refusal to notify causes this function to be faster
than the appropriate two uses of $open\_theory$.

The function prevents the application of $f$ from once more changing the current theory to another, or functions
that may delete the original theory.
The block will provoke error 12011.
These functions are:
=GFT
open_theory	new_theory	delete_theory
=TEX
It will also discard any changes made by $before\-\_kernel\-\_state\-\_change$ during the application of $f$ at its end.

The function will intercept any exceptions (including keyboard interrupts), and will attempt to remove the block
on changing the current theory, and then return to the original theory.
However, in certain circumstances (such as multiple
keyboard interrupts, or use of $icl'$ functions)
the exception handler itself may be interrupted or
be otherwise unable to complete its work.
In these cases $open\-\_theory$ must be used by hand
to notify the proof system of the correct theory and its context.
If this raises the error $12011$ then repeat the use of $open\-\_theory$,
as each raising of the error involves the removal
of one block put in place by $do\-\_in\-\_theory$ before the
message is generated.
=FAILURE
12011	Blocked from changing the current theory.
	This particular block has now been removed.
	Exceptionally, further blocks, giving the same 
	error message, may still be in place. These blocks 
	should be cleared now by repeatedly trying open_theory 
	until this error message is not provoked
12013	An internal error has corrupted the current theory
	data. Immediately make a call of open_theory
	to clear this internal error
=ENDDOC
\section{COMPACTIFICATION}
=DOC
	val Ûcompact_typeÝ : TYPE -> TYPE;
	val Ûcompact_termÝ : TERM -> TERM;
	val Ûcompact_thmÝ : THM -> THM;
=DESCRIBE
These functions compactify type, term and theorem values,
currently by commoning up type information so that only one ML instance
of any type is used in the compactified value. Depending on the value
of the integer control variable $compactification\_mask$, q.v., these
interfaces are invoked automatically as values are stored in the theory
database.

The $compactify\_{\cal XXX}$ interfaces act as identify functions: $compactify\_{\cal XXX}\,x$ returns a value
which is equal to $x$ (in the sense of $=:$, $=\$$ or $=\vert-$ as
appropriate), but which usually occupies significantly less space than
$x$.
=ENDDOC
Note: the algorithm used to do the compactification is not important
from the functional point of view, but is crucial to the performance.
The implementation documents the details of the techniques used.
=DOC
	(* Ûcompactification_maskÝ : integer control: default 0 *)
	val Ûget_compactification_cacheÝ : unit -> TYPE list;
	val Ûset_compactification_cacheÝ : TYPE list -> unit;
	val Ûclear_compactification_cacheÝ : unit -> unit;
=DESCRIBE
These functions and associated control value support compactification
of objects stored in the theory database.

$set\_compactification\_cache$ and $get\_compactification\_cache$ may
be used at the beginning and end of a \Product\ session to preserve the
contents of the cache of type information which is used to implement
compactification. Internally, the cache is held as a rather more
complex, and much larger, data structure than a simple list of types
and so $clear\_compactification\_cache$ is used automatically to empty
the cache at the end of a session, thereby avoiding saving the data
structure in the database file.  Restoring the cache from the list
returned by  $get\_compactification\_cache$ using
$set\_compactification\_cache$ is time-consuming and is not done
automatically; however, doing this using, e.g., the following lines of ML,
may improve the space-saving in applications which are built up in
several sessions:

=GFT SML Example - End of Every Session
val saved_compactification_cache = get_compactification_cache();
=TEX

=GFT SML Example - Beginning of Second and Later Sessions
set_compactification_cache saved_compactification_cache;
=TEX

ML functions which compute terms can often be coded so as to produce
terms in which common subterms are shared. The compactification algorithm
may actually increase the space occupied by such terms. Producers of such
functions may therefore wish to suppress the compactification when the computed
terms are stored in the theory database.

$compactification\_mask$ is an integer control which is treated as a
bit-mask and may used to suppress selected aspects of the
compactification algorithm. The default value of $0$ should be correct
for most normal specification and proof work. The significance of the
bits in the mask is as follows:

\begin{center}
\begin{tabular}{|l|p{4.0in}|}\hline
1 & Suppress compactification in $new\_axiom$ \\\hline
2 & Suppress compactification in $new\_const$  \\\hline
4 & Suppress compactification in $new\_type\_defn$ \\\hline
8 & Suppress compactification in $new\_spec$ \\\hline
16 & Suppress compactification in $save\_thm$ \\\hline
32 & Suppress compactification in $simple\_new\_defn$ \\\hline
\end{tabular}
\end{center}
So, for example, if the mask is set to $47$ ($=1+2+4+8+32$), then compactification
will only be performed when $save\_thm$ is called.
=ENDDOC

\subsection{Checkpointing}
=DOC
type ÛCHECKPOINTÝ;
val ÛcheckpointÝ : string -> CHECKPOINT;
val ÛrollbackÝ : CHECKPOINT -> unit;
=DESCRIBE
This opaque type and its associated functions implement a system for checkpointing and restoring
the state of the theory hierarchy. It is intended primarily for programmatic use
in applications that may need to undo multiple extensions to the logical
contents of the theory and changes to user data. The check-pointing scheme is unable
to keep track of theories, theorems, definitions etc. that have been deleted. Applications that
may delete such objects must make their own arrangements for restoring the deleted objects.

The parameter to {\it checkpoint} is a theory name. The checkpoint returned
contains the information required by {\it rollback}
to roll the indicated theory and all its descendants back to the state it had when the checkpoint was taken.
The theory becomes the current theory after the rollback.

Rolling back is done using {\it delete\_const} etc. and so rolling back the state of
definitions and axioms is restricted to changes made in theories which did not have children
when the checkpoint was taken. For uniformity, {\it rollback} does not attempt to restore
the state of the theorems and the user data in theories which had children when the checkpoint
was taken.

Messages 12015 to 12017 are reported by  {\it rollback} as comments.
In general,  {\it rollback} will just report on the problem and continue trying
to restore other theories.
For example, if {\it rollback} is unable to delete a theory, it continues to
attempt to restore the state of the definitions, etc. in the theories that are to be retained.
This is an unlikely situation, since {\it rollback} unlocks a theory if necessary before trying to delete it,
so it will only happen if the application using {\it rollback} has created a new theory
hierarchy and a theory to be deleted has obtained ancestor status.
Message 12020 is  reported by {\it rollback} as a failure.

Messages 12018 and 12019 are reported by {\it checkpoint} as failures.
A locked theory cannot be checkpointed. A read-only ancestor theory may
only be checkpointed if it has children.
=FAILURE
12015	it was not possible to delete theory ?0
12016	the theory ?0 has been deleted since the checkpoint was taken; this change cannot
	be rolled back
12017	a failure was reported while trying to restore theory ?0 (?1)
12018	the theory ?0 is locked and so cannot be checkpointed
12019	the theory ?0 is a read-only ancestor with no children and so cannot be checkpointed
12020	the theory ?0 has been deleted since this checkpoint was taken and a new
	theory of the same name has been created. Rolling back to this checkpoint
	is not possible.
=ENDDOC


=SML
end(* of signature KernelInterface *);
=TEX
\section{TEST POLICY}
The functions in this document should be tested according to the
general criteria set out in \cite{DS/FMU/IED/PLN008}, using the
tests in \cite{DS/FMU/IED/MDT012}.

Running the module tests for this module is slightly awkward, since
the tests need to take actions, such as deleting all of the theory
hierarchy, which are not allowed in normal
operation of the system. Consequently the tests are run part-way
through the construction of the system, at a point where
the code which disallows these actions has not been activated.
If the code or tests change, the most convenient way of checking
the tests without doing a full system build is to edit the
system build makefile so that it stops just after carrying out
the tests.



\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


