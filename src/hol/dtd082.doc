=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of Algebraic Normalisation Conversions}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD082}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D.~Arthan & WIN01}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the detailed design of proof
procedures for linear arithmetic.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item[1.1 (\FormatDate{92/09/07%
})] First draft (adapted from prototype implementation of \cite{DS/FMU/IED/SML023}) for comment.
\item[1.2(\FormatDate{92/09/11%
})] Amended in the light of comments. Added $ANF\_C$ and description of
error handling.
\item[\SCCSversion~(\FormatDate{$Date$%
})] Revised description of conversion arguments for $sort\_conv$ and $poly\_conv$.
\end{description}
\subsection{Changes forecast}
Error messages and numbers TBA.
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design of part of the \ProductHOL\ system.
The document responds to \cite{DS/FMU/IED/HLD012}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
There are algorithms which will decide the satisfiability
of a system of linear constraints over the rationals. Here
by a system of {\em linear constraints}, we mean a finite set of
formulae of the form:

=GFT
	a‰1*x‰1 + a‰2*x‰2 + ... a‰k * x‰k R c
=TEX
in which the constants $a_1$ and $c$ (which we will call {\em coefficients})
are rationals,
the variables $x_i$ range over the rationals
and R is one of $=$, $<$, $¼$, $>$, $¾$.

Since a system which is unsatisfiable over the rationals is {\it a fortiori}
unsatisfiable over the natural numbers or the integers, such a decision procedure
acts as a semi-decision procedure for the unsatisfiability of such a system
over the natural numbers or the integers (or indeed any subset of the
rationals).

It turns out that some of the algorithms which solve the rational
decision problem, such as the one given by L. Hodes in \cite{Hodes71} and
used in the Boyer-Moore theorem prover, see \cite{Boyer88b}, may readily
be adapted not only to decide the unsatisfiability but also to produce
as output a linear combination of the input constraints which reduces,
by collecting like terms and cancellation, to an unsatisfiable ground constraint
(i.e. one in which there are no variables). Such a procedure may
be used in \ProductHOL\ to prove facts of arithmetic which can be expressed
in terms of the unsatisfiability systems of linear constraints.
For example, the assertion
=INLINEFT
µx y:î· x ¾ 1 ± y > x ´ y > 2
=TEX
\ is, by contradiction, true iff. the following system of
constraints is unsatisfiable:
=GFT
(a)		x	¾	2
(b)		y - x	¾	1
(c)		y	¼	2
=TEX
The procedure of Hodes, suitability adapted, will tell us that
the linear combination
=INLINEFT
(c)-(a)-(b)
=TEX
\ of these constraints reduces to the ground constraint
=INLINEFT
0 ¼ -1
=TEX
. This information may be used to derive a contradiction from the three
constraints in HOL.

The purpose of this document is to provide proof procedures
and proof contexts
based on these techniques for the natural numbers and also
to provide an implementation of the basic tools which support these
proof procedures by testing
unsatisfiability of a system over the rationals for use
in constructing similar procedures for other number systems.

\subsubsection{Dependencies}
This document depends on the theory $basic\_hol$ defined in
\cite{DS/FMU/IED/DTD045}, on the conversions in
\cite{DS/FMU/IED/DTD081}, and on the tactics and rules of
\cite{DS/FMU/IED/DTD027,DS/FMU/IED/DTD029}.
\subsubsection{Algorithms}
See \cite{Hodes71} or the implementation document \cite{DS/FMU/IED/IMP081}
for full details. Note that the algorithm in \cite{Hodes71} is
used there as part of a decision procedure for full first-order rational
linear arithemetic whereas here it is just used for quantifier free formulae.

\subsubsection{Known Deficiencies}
None.
\subsubsection{Possible Enhancements}
When the proof procedure fails to derive a contradiction and the exception
signalling that failure is propagated to the top level, the diagnostic
print-out just shows the assignment of variables to atoms in the problem
and the system of constraints as expressed in terms of those variables.
It is possible, but not entirely straightforward, actually to exhibit
a solution to the constraints as well, but this has not been done in the
current implementation.
\section{SIGNATURE}
=DOC 
(*
signature ÛLinearArithmeticÝ = sig
=DESCRIBE
This is the signature of a structure containing proof procedures for linear
arithmetic and related functions.
=ENDDOC
\section{TOOLS}
=FAILURE
82100	Cannot prove this conjecture by linear arithmetic:
82101	Assigning variables to terms as follows:
82102	Gives the satisfiable system:
82110	System is satisfiable
82111	A system with no constraints is satisfiable
82200	Could not prove theorem with conclusion ?1 (?0)
=DOC
structure LinearArithmeticTools : sig
	type ÛPOLYÝ 	(*= (int * int) list *);
	datatype ÛCONSTRAINT_TYPEÝ = Eq | LessEq | Less;
	type ÛCONSTRAINTÝ (* = POLY * CONSTRAINT_TYPE * int * POLY *);
	val Ûnormalise_polyÝ : POLY -> POLY;
	val Ûnormalise_constraintÝ : POLY -> POLY;
	val Ûformat_polyÝ : POLY -> string;
	val Ûformat_constraintÝ : CONSTRAINT -> string;
	val Ûmult_and_add_polyÝ : int -> POLY -> int -> POLY -> POLY;
	val Ûmult_and_add_constraintÝ
		: int -> CONSTRAINT -> int -> CONSTRAINT -> CONSTRAINT;
	val Ûlin_arith_contrÝ : (int * TERM) list -> CONSTRAINT list -> POLY;
end;
=DESCRIBE
This is  a structure contained in the
structure
=INLINEFT
LinearArithmetic
=TEX
\ containing types and functions used to represent and manipulate 
polynomials of degree 1 in many variables and systems
of linear constraints with integer coefficients over the rational numbers.
Most importantly, 
=INLINEFT
lin_arith_contr
=TEX
\ provides a decision procedure for the unsatisfiability of such systems.
In more detail:

Degree one polynomials in many variables $x_1$, $x_2$, ... 
(henceforth, just {\em polynomials}) are represented, using the
type $POLY$, as
lists of pairs of integers, a pair $(a, i)$ indicating that the $i$-th variable
has coefficient $a$. The function
=INLINEFT
normalise_poly
=TEX
\ puts any polynomial in a normal form,
in which the variables in such a polynomial occur in strictly
increasing order and pairs with zero coefficients are omitted.
Provided two polynomials, $p$ and $q$, are in normal form,
=INLINEFT
mult_and_add_poly i p j q
=TEX
\ computes the normalised representation of 
=INLINEFT
i*p + j*q
=TEX
. N.B. for efficiency reasons, these functions do not check that their
arguments are normalised and may produce results which are not only
not normalised but also incorrect in such cases.


Constraints are labelled with an indicator of their
origin. This is a polynomial and typically
one would label the $j$-th constraint with $x_j$.
The provenance of a generated constraint is then represented using a polynomial,
where e.g. $2x_1 + 3x_2$ means add twice the polynomial labelled with
$x_1$ to thrice that labelled $x_2$.
A constraint
=INLINEFT
a‰1*x‰1 + a‰2*x‰2 + ... a‰k * x‰k R c
=TEX
\  with provenance $p$ is then represented as a 4-tuple
=INLINEFT
([(a‰1, x‰1), (a‰2, x‰2), ...], R, c, p)
=TEX
. The polynomials in a constraint may be put into the normal form
described above using
=INLINEFT
normalise_constraint
=TEX
\ and constraints may be multiplied by constants and added using
=INLINEFT
mult_and_add_constraint
=TEX
.


Given a table, $m$ mapping variable numbers to terms,
a list, $cs$, of constraints (not necessarily normalised),
=INLINEFT
lin_arith_contr m cs
=TEX
\ determines whether $cs$ is unsatisfiable (i.e. contradictory):
if so, it returns a normalised polynomial indicating, in terms of
of the origin labels in the inputs, a linear combination of the inputs
which reduces, by cancellation, to an unsatisfiable constraint
with no variables; if not, it raises an exception, which, if not
caught, will cause a diagnostic print of the satisfiable system
to be produced. The table $m$ is only used to format this diagnostic output.
=FAILURE
82001	The system of constraints is satisfiable
=ENDDOC
\section{RULES}
=DOC
	val scale_rule : TERM -> THM -> THM
=DESCRIBE
In the simplest cases, given a term, $t$, of type ”î®
and a theorem with conclusion
which the form $(t1:î) = t2$ or $t1 ¼ t2$,
=INLINEFT
scale_rule
=TEX
\ returns a theorem which expresses the result of multiplying
both sides of the conclusion of the theorem by $t$.
More generally,
=TEX
scale_rule t
=TEX
\ processes theorems whose conclusions are atomic arithmetic propositions
or negations of same as follows:

=GFT
t1 = t2		­	t * t1 = t * t2
t1 ¼ t2		­	t * t1 ¼ t * t2
t1 < t2		­	t * t1 + t ¼ t * t2
t1 ¾ t2		­	t * t2 ¼ t * t1
t1 > t2		­	t * t2 + t ¼ t * t1

³t1 = t2	­	t * t1 + t ¼ t * t2 ² t * t2 + t ¼ t * t1
³t1 ¼ t2	­	t * t2 + t ¼ t * t1
³t1 < t2	­	t * t2 ¼ t * t1
³t1 ¾ t2	­	t * t1 + t ¼ t * t2
³t1 > t2	­	t * t1 ¼ t * t2
=TEX

=FAILURE
82010	?0 does not have type ”î®
82011	?0 is not of the form ô (t1:î) R t2 or ô ³(t1:î) R t2 where R is one
	of =, ¼, <, ¾ or >
=ENDDOC

=DOC
	val scaled_sum_rule : (int * THM) list -> THM
=DESCRIBE
=TEX

=FAILURE
82010	?0 does not have type ”î®
82011	?0 is not of the form ô (t1:î) R t2 or ô ³(t1:î) R t2 where R is one
	of =, ¼, <, ¾ or >
=ENDDOC

\section{PROOF CONTEXTS}
\section{EPILOGUE}
=SML
end (* of signature LinearArithmetic *);
*)
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

