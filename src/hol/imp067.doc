=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Resolution Facilities}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP067}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation
of the resolution facilities in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1,1.2] 
First versions.

\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Tools giving some sort of resolution facility
are called for in \cite{DS/FMU/IED/HLD012}.
This document provides an implementation for these tools.
A design for such tools is given in \cite{DS/FMU/IED/DTD067}.
This document provides an implementations for them.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation for the
resolution tools.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD067}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.

\section{PREAMBLE}
=IGN
structure €Resolution› : Resolution = struct
=TEX
=SML
val lthy = get_current_theory_name();
val _ = open_theory "basic_hol";
val _ = push_proof_context prove_∂_epc;
open Unification;
=TEX
\section{THE CODE}
Using $rewrite\_rule$ as a simplifier is crude!
=SML
local
	val simp_rewrites_thm = 
	tac_proof(([],
	¨(µ x:'a∑ T) ± (∂ x :'a∑ T) ± 
	≥(µ x:'a∑ F) ± ≥(∂ x :'a∑ F) ±
	((∂â1 x:'a∑T) § (∂ x ∑µ y:'a ∑ y = x)) ±
	(≥(∂â1 x:'a∑F)) ±
	(µ t1 t2∑ (if T then t1 else t2) = t1 ± (if F then t1 else t2) = t2)
	±
	(µ t∑ (T ¥ t § t) ± (F ¥ t § T) ± (t ¥ T § T) ± 
                  (t ¥ F § ≥ t))
	±
	(µ t∑ (T ≤ t) ± (t ≤ T) ± (F ≤ t § t) ± (t ≤ F § t) ±
         (t ≤ t § t) ± (t ≤ ≥ t § T) ± (≥ t ≤ t § T))
	±
	(µ t∑ (T ± t § t) ± (t ± T § t) ± ≥ (F ± t) ± ≥ (t ± F) ±
        (t ± t § t))
	±
	(µ t∑ (≥ T § F) ± (≥ F § T))
	±
	(µ t∑ ((T § t) § t) ± ((t § T) § t) ± ((F § t) § ≥ t) ±
        ((t § F) § ≥ t))Æ),
	rewrite_tac[∂â1_thm] THEN REPEAT strip_tac);
	val rw = pure_rewrite_rule[simp_rewrites_thm];
in
fun €basic_resolve_rule› (subterm:TERM) (pthm:THM) (nthm:THM) : THM = (
let	val cases_thm = (simple_µ_elim subterm bool_cases_axiom)
		handle complaint =>
		divert complaint "simple_µ_elim" "basic_resolve_rule" 
		3031 [fn () => string_of_term subterm];
	val (§_T,§_F) = dest_≤(concl cases_thm);
	val pF = subst[(mk_f,subterm)] (concl pthm);
	val nT = subst[(mk_t,subterm)] (concl nthm);
	val pthm' = pure_once_rewrite_rule[asm_rule §_F]
		(≤_right_intro nT pthm)
		handle complaint =>
		divert complaint "pure_once_rewrite_rule" "basic_resolve_rule" 
		67009 [fn () => string_of_term subterm,
			fn () => string_of_term (concl pthm)];
	val nthm' = pure_once_rewrite_rule[asm_rule §_T]
		(≤_left_intro pF nthm)
		handle complaint =>
		divert complaint "pure_once_rewrite_rule" "basic_resolve_rule" 
		67009 [fn () => string_of_term subterm,
			fn () => string_of_term (concl nthm)];
	val base_thm = ≤_elim cases_thm nthm' pthm';
in
	all_µ_intro(rw base_thm)
	handle complaint =>
	if area_of complaint = "rewrite_rule"
	then base_thm
	else reraise complaint (area_of complaint)
end);
end; (* of local simp_rewrites_thm *)
=TEX
=IGN
fun €basic_resolve_tac› (subterm : TERM) 
	(asm1 : TERM, subs1 : TERM list) 

	(asm2: TERM, subs2 : TERM list) : TACTIC = (fn (asms,gl) =>
	LIST_GET_ASM_T [asm1,asm2] 
		(fn lst =>
		let	val thm1 = list_simple_µ_elim subs1 (hd lst);
			val thm2 = list_simple_µ_elim subs2 (hd(tl lst));
			val thm3 = basic_resolve_rule subterm thm1 thm2;
			val cthm3 = concl thm3;
		in
			if (cthm3 = mk_f) orelse (cthm3 = mk_t)
				orelse (cthm3 term_mem asms) 
			then strip_asm_tac thm3
			else asm_tac thm3
		end)
		(asms,gl)
);
=TEX
\subsection{Term Unification}

An algorithm for term unification:
\begin{enumerate}
\item
Substitute term variables not found at all in either term
for the specialisable term variables in either term.
\item
Substitute type variables not found at all in either term
for the specialisable type variables in either term.
(This prevents having to do this for the individual type unifications).
\item
Initialise the bound variable matching, to empty,
specialisation to mapping the variables to $Nil$,
and initialise the type unification scatchpad.
\item
Consider what the first term is:
\begin{description}
\item[Variable]
Determine its actual type, and consider that:
\begin{description}
\item[If a bound variable]
Then the second term must be the corresponding bound variable of the other term,
and the other type, when expanded out, must already be equal.
\item[Else if already specialised]
(i.e. mapped to $Value$ of something in the specialisation map)
Then unify what it is specialised to, and the second term.
\item[Else if it may be specialised]
(i.e. mapped to $Nil$ in the specialisation map)
Then unify its type to the type of the second term,
then expand out the second term, looking for
occurs checks, bound variables, etc,
then record the first term as specialised to the $Value$ of the second term.
\item[Else]
(i.e. not mapped in the specialisation map)
The second term must, after expansion, be either
\begin{itemize}
\item
the same named variable, with a type unifiable to the first.
\item
or a unbound, specialisable variable, with a type unifiable to
the first,
in which case record the second term as specialised to the first term.
\end{itemize}
\end{description}

\item[Constant]
Consider what the second term is:
\begin{description}
\item[Variable]
Determine its actual type, and consider that:
\begin{description}
\item[If a bound variable]
Fail.
\item[Else if already specialised]
Then unify what it is specialised to, and the first term.
\item[Else if it may be specialised]
Then unify its type to the type of the constant,
then record the second term as specialised to the first term.
\item[Else]
Fail.
\end{description}

\item[Constant]
The second term must be the same name, with 
a type unifiable to the first.
\item[Application]
Fail
\item[Abstraction]
Fail
\end{description}

\item[Application]
Consider what the second term is:
\begin{description}
\item[Variable]
Determine its actual type, and consider that:
\begin{description}
\item[If a bound variable]
Fail.
\item[Else if already specialised]
Then unify what it is specialised to, and the first term.
\item[Else if it may be specialised]
Then unify its type to the type of the application,
then record the second term as specialised to the first term.
\item[Else]
Fail.
\end{description}
\item[Application]
Unify the two arguments, and then the two functions
(the order is based on the grounds the types and subterms of the arguments are likely
to be smaller).
\item[Abstraction]
Fail
\end{description}

\item[Abstraction]
Consider what the second term is:
\begin{description}
\item[Variable]
Determine its actual type, and consider that:
\begin{description}
\item[If a bound variable]
Fail.
\item[Else if already specialised]
Then unify what it is specialised to, and the first term.
\item[Else if it may be specialised]
Then unify its type to the type of the abstraction,
then record the second term as specialised to the first term.
\item[Else]
Fail.
\end{description}
\item[Application]
Fail.
\item[Abstraction]
Unify the types of the abstractions.
Then record the fact that the two bound variables are indeed
such while traversing the body.
Then unify the two bodies.
The undo the recording of the bound variables.
\end{description}

\end{description}
\end{enumerate}
=SML
fun €list_string_variant› (av:string list) ([]:string list) : string list = []
| list_string_variant av (h:: t) = (
let	val h' = string_variant av h;
in
	h' :: list_string_variant (h'::av) t
end);
=IGN
list_string_variant ["p","q''","r'","r"] ["q", "q'", "q'''", "r''", "s"];
=SML
fun €term_tytm_vars› (tm : TERM) : TERM list * string list = (
let	fun aux _ (App (f, a)) = (
	let	val (tv1,ty1) = aux f (dest_simple_term f);
		val (tv2,ty2) = aux a (dest_simple_term a);
	in
		((tv1 cup tv2), (ty1 cup ty2))
	end
	) | aux _ (Const (_, ty)) = ([],type_tyvars ty)
	  | aux tm (Var (_,ty)) = ([tm],type_tyvars ty)
	  | aux _ (SimpleÃ (v, b)) = (
	let val (tv1,ty1) = aux b (dest_simple_term b);
	in
		(tv1 grab v, ty1 cup type_tyvars (type_of v))
	end)
in
	aux tm (dest_simple_term tm)
end);

=TEX
=TEX
To make the specialisable term and instantiable type variables unique in two terms:
=SML
fun €uniquify› (avty : TYPE list) (avtm : TERM list) (((tm1:TERM) ,(ms1: TERM list), (mi1:TYPE list)),
	((tm2:TERM), (ms2:TERM list), (mi2:TYPE list))) :
	((TERM * TERM list) * (TERM * TERM list) * (int * string) list) = (
let	val (tv_tm1, ty_tm1) = term_tytm_vars tm1;
	val (tv_tm2, ty_tm2) = term_tytm_vars tm2;
	val tv1_fixed = tv_tm1 diff ms1;
	val tv2_fixed = tv_tm2 diff ms2;
	val tv1_avoid = tv1_fixed @ tv2_fixed @ avtm;
	val tv1' = list_variant tv1_avoid ms1;
	val tv2_avoid = tv1_avoid @ tv1';
	val tv2' = list_variant tv2_avoid ms2;
	val tm1' = subst(combine tv1' ms1) tm1;
	val tm2' = subst(combine tv2' ms2) tm2;
	val nm_mi1 = map dest_vartype mi1;
	val nm_mi2 = map dest_vartype mi2;
	val ty1_fixed = ty_tm1 diff nm_mi1;
	val ty2_fixed = ty_tm2 diff nm_mi2;
	val ty1_avoid = ty1_fixed @ ty2_fixed @ map dest_vartype avty;
	val mi1s' = list_string_variant ty1_avoid nm_mi1;
	val mi1' = map mk_vartype mi1s';
	val ty1_insts = (combine mi1' mi1);
	val ty2_avoid = ty1_avoid @ mi1s';
	val mi2s' = list_string_variant ty2_avoid nm_mi2;
	val mi2' = map mk_vartype mi2s'
	val mi1mi2s = mi1s' @ mi2s';
	val esubs = combine (interval 1 (length mi1mi2s)) mi1mi2s;
	val ty2_insts = (combine mi2' mi2);
	val tm1'' = inst [] ty1_insts tm1';
	val tm2'' = inst [] ty2_insts tm2';
	val ms1' = map (inst [] ty1_insts) tv1';
	val ms2' = map (inst [] ty2_insts) tv2';
in
	((tm1'',ms1'),(tm2'',ms2'), esubs)
end
handle complaint =>
case (area_of complaint) of
"dest_vartype" => reraise complaint "term_unify"
| "dest_var" => reraise complaint "term_unify"
| other => reraise complaint other
);
=IGN
uniquify [] [] ¨a ± (µ b:'a∑ f b ≤ c) ≤ g (b:'a) ± h (d:'d)Æ [¨a:BOOLÆ,¨b:'aÆ,¨c:BOOLÆ] [¨:'aÆ,¨:'dÆ]
¨a ± (µ b:'a∑ f b ≤ c) ≤ g (b:'a) ± h (d:'d)Æ [¨a:BOOLÆ,¨d:'dÆ] [¨:'aÆ,¨:'dÆ];
=TEX
Local form of converting a type to an extended type:
=SML
fun €ltype_to_extype› (esubs: (int * string)list) (ty:TYPE):EXTYPE = (
let	fun aux (Ctype (nm,tys)) = ExType(nm,map (aux o dest_simple_type) tys)
	| aux (Vartype nm) = (
		case rassoc5 esubs nm of
		Value n => ExVartype (Unknown n)
		| _ => ExVartype (Known nm)
	);
in
	aux (dest_simple_type ty)
end);
=TEX
=SML
fun €expand_type› (subs:SUBS)
	(esubs:(int * string)list)
	(ty: TYPE): TYPE = (
let	fun aux (Ctype (nm,tys)) = mk_ctype(nm,map (aux o dest_simple_type) tys)
	| aux (Vartype nm) = (
		case rassoc5 esubs nm of
		Value n => extype_to_type subs esubs (ExVartype (Unknown n))
		| _ => mk_vartype nm
	);
in
	aux (dest_simple_type ty)
end);
=TEX
We do a very cheap and cheerful bound variable hider in the 
following.
=SML
fun €expand_term› (subs:SUBS)
	(esubs:(int * string)list)
	(ifvmatch: (TERM * TERM OPT)list)
	(tm:TERM):TERM = (
let	fun aux fvmatch _ (App(f,a)) = mk_app(
		aux fvmatch f (dest_simple_term f), 
		aux fvmatch a (dest_simple_term a))
	| aux fvmatch _ (Const(nm,ty)) = mk_const(nm, expand_type subs esubs ty)
	| aux fvmatch v (Var (nm,ty)) = (case lassoc5 fvmatch v of
		Nil => mk_var(nm, expand_type subs esubs ty)
		| Value Nil => mk_var(nm, expand_type subs esubs ty)
		| Value(Value tm') => 
			if v = tm'
			then error "expand_term" 67013 [
				(fn () => string_of_term v)]
			else aux fvmatch tm' (dest_simple_term tm')
	) | aux fvmatch _ (SimpleÃ(v,bdy)) = mk_simple_Ã (
		let val (nm,ty) = dest_var v
		in
		mk_var(nm, expand_type subs esubs ty)
		end,
		aux (fvmatch drop (fn(x,_)=> x=v)) bdy (dest_simple_term bdy))
in
	aux ifvmatch tm (dest_simple_term tm)
end);
=TEX
Expand out a term, checking for the presence of an instantiable (but not yet instantiated) term
variable as you go (an ``occurs'' check).
It is OK for the result to equal $mv$, but not to contain it.
=SML
fun €expand_check_term› (subs:SUBS) 
	(esubs:(int * string)list) 
	(ifvmatch: (TERM * TERM OPT)list)
	(mv:TERM) 
	(tm:TERM):TERM = (
let	fun aux _ _ fvmatch (App(f,a)) = mk_app(
		aux true f fvmatch (dest_simple_term f), 
		aux true a fvmatch (dest_simple_term a))
	| aux _ _  fvmatch (Const(nm,ty)) = mk_const(nm, expand_type subs esubs ty)
	| aux inside v fvmatch (Var (nm,ty)) = (case lassoc5 fvmatch v of
		Nil => mk_var(nm, expand_type subs esubs ty)
		| Value Nil => (let val nv = mk_var(nm, expand_type subs esubs ty);
			in
			if inside andalso mv = v
			then term_fail "term_unify" 67012 [mv, tm]
			else nv
			end
		) | Value(Value tm') => 
			if v = tm'
			then error "expand_check_term" 67013 
				[fn () => string_of_term v]
			else aux inside tm' fvmatch (dest_simple_term tm')
	) | aux _  _ fvmatch (SimpleÃ(v,bdy)) = (mk_simple_Ã (
		let val (nm,ty) = dest_var v
		in
		mk_var(nm, expand_type subs esubs ty)
		end,
		aux true bdy (fvmatch drop (fn (x,_)=> x=v)) (dest_simple_term bdy)))
in
	aux false tm ifvmatch (dest_simple_term tm)
end);
=TEX
Unify two types using material from \cite{DS/FMU/IED/DTD014}.
=SML
fun €type_unify› (subs:SUBS) (esubs: (int * string)list) (ty1:TYPE) (ty2: TYPE): unit = (
let	val ty1' = ltype_to_extype esubs ty1;
	val ty2' = ltype_to_extype esubs ty2;
in
	unify subs (ty1',ty2')
end
handle complaint =>
pass_on complaint "unify" "type_unify"
);
=TEX
=IGN
term_unify ((¨a ± (µ b:'a∑ f b ≤ c) ≤ g (b:'a) ± h (d:'d)Æ,
	[¨a:BOOLÆ,¨b:'aÆ,¨c:BOOLÆ], [¨:'aÆ,¨:'dÆ]),
	(¨a ± (µ b:'a∑ f b ≤ c) ≤ g (b:'a) ± h (d:'d)Æ, [¨a:BOOLÆ,¨d:'dÆ], [¨:'aÆ,¨:'dÆ]));
=TEX
Unify two terms:
note that because of bound variable matching we cannot swap the two terms about to exploit symmetry.
=SML
fun  €term_unify› (subs:SUBS) 
	(avty : TYPE list) (avtm: TERM list) 
	((itm1: TERM, ims1: TERM list, imi1: TYPE list),
	(itm2: TERM, ims2: TERM list, imi2: TYPE list))
	: 
	((TYPE * TYPE) list * (TERM * TERM) list) *
	((TYPE * TYPE) list * (TERM * TERM) list) = (
let	
=TEX
Initialisation:
=SML
	val ((tm1,ms1),(tm2,ms2),esubs) = (
		uniquify avty avtm ((itm1, ims1, imi1), (itm2, ims2, imi2))
	);
	val dummy = init_subs subs;
	val ifvmatch = map (fn tm => (tm,Nil)) (ms1 @ ms2);
	val trans_ms1 = combine ims1 ms1;
	val trans_ms2 = combine ims2 ms2;
=TEX
=SML
	fun tmaux2 fvmatch bvmatch (App(f1, a1)) (App(f2, a2)) = (
		tmaux2 (tmaux2 fvmatch bvmatch 
				(dest_simple_term a1) (dest_simple_term a2))
			bvmatch 
			(dest_simple_term f1) 
			(dest_simple_term f2)
	) | tmaux2 fvmatch bvmatch (Const(s1,ty1))(Const(s2,ty2)) = (
		if (s1 = s2)
		then (type_unify subs esubs ty1 ty2; fvmatch)
		else term_fail "term_unify" 67005 [itm1,itm2]
	) | tmaux2 fvmatch bvmatch (SimpleÃ(v1,b1))(SimpleÃ(v2,b2)) = (
		
		let	val bvmatch' = (v1, v2) :: bvmatch;
			val dummy = type_unify subs esubs (type_of v1) (type_of v2);
		in	tmaux2 fvmatch bvmatch' 
			(dest_simple_term b1) (dest_simple_term b2)
		end
	) | tmaux2 fvmatch bvmatch stm1 stm2 = (
let
=TEX
Auxiliary functions handling variables:
=SML
	fun tmaux0 (fvmatch:(TERM * TERM OPT)list)
			bvmatch (tm1:TERM) (v2: TERM) = (
		case rassoc5 bvmatch v2 of
		Nil => (
			if any (frees tm1) (fn x => any bvmatch (fn (x1, _) => (x = x1)))
			then term_fail "term_unify" 67005 [itm1,itm2]

			else case lassoc5 fvmatch v2 of
			Value(Value tm1') => (
				tmaux2 fvmatch bvmatch 
					(dest_simple_term tm1) 
					(dest_simple_term tm1')
			) | Value Nil => (
				let	val dummy =
					type_unify subs esubs (type_of tm1) (type_of v2);
					val tm1' = expand_check_term 
					 subs esubs fvmatch v2 tm1;
				in	if v2 = tm1'
					then fvmatch
					else fvmatch overwrite 
					(v2, Value tm1')
				end
			) | Nil => (
			if is_var tm1
			then (case lassoc5 fvmatch tm1 of
			Value(Value tm1') => (
				tmaux2 fvmatch bvmatch
				(dest_simple_term tm1) 
				(dest_simple_term tm1')
			) | Value Nil => (
				let	val dummy =
					type_unify subs esubs (type_of tm1) (type_of v2);
				in	fvmatch overwrite (tm1, Value v2)
				end
			) | Nil => (
			let	val (nm1,vty1) = dest_var tm1;
				val (nm2,vty2) = dest_var v2;
			in
				(if nm1 = nm2
				then (type_unify subs esubs vty1 vty2; fvmatch)
				else term_fail "term_unify" 67005 [itm1,itm2])
			end
			))
			else term_fail "term_unify" 67005 [itm1,itm2])			
		) |	Value _ => term_fail "term_unify" 67005 [itm1,itm2]
	);
=TEX
=SML
	fun tmaux1 fvmatch (bvmatch : (TERM * TERM) list) 
			tm1 v2 = (
		if is_var tm1
		then	(case lassoc5 bvmatch tm1 of
				Value v2' => (
					if v2' = v2 andalso rassoc5 bvmatch v2' = Value tm1
					then fvmatch
					else term_fail "term_unify" 67005 [itm1,itm2]
			) |	Nil => tmaux0 fvmatch bvmatch tm1 v2
			)
		else 	tmaux0 fvmatch bvmatch tm1 v2
	);

=TEX
Now the analogues to the above two, except the variable is the first term (done to keep bound variables straight)
=SML
	fun tmaux0' (fvmatch:(TERM * TERM OPT)list)
			bvmatch (tm2:TERM) (v1: TERM) = (
		case lassoc5 bvmatch v1 of
		Nil => (
			if any (frees tm2) (fn x => any bvmatch (fn (_, x1) => (x = x1)))
			then term_fail "term_unify" 67005 [itm2,itm2]

			else case lassoc5 fvmatch v1 of
			Value(Value tm1') => (
				tmaux2 fvmatch bvmatch 
				(dest_simple_term tm1')
				(dest_simple_term tm2) 
			) | Value Nil => (
				let	val dummy =
					type_unify subs esubs (type_of v1) (type_of tm2);
					val tm2' = expand_check_term 
						 subs esubs fvmatch v1 tm2;
					in	 
						if v1 = tm2' 
						then fvmatch 
						else fvmatch overwrite 
						(v1, Value tm2')
					end
			) | Nil => (
			if is_var tm2
			then (case lassoc5 fvmatch tm2 of
			Value(Value tm2') => (
				tmaux2 fvmatch bvmatch
				(dest_simple_term v1) 
				(dest_simple_term tm2')
			) | Value Nil => (
				let	val dummy =
					type_unify subs esubs (type_of v1) (type_of tm2);
				in	fvmatch overwrite (tm2, Value v1)
				end
			) | Nil => (
			let	val (nm1,vty1) = dest_var tm2;
				val (nm2,vty2) = dest_var v1;
			in
				(if nm1 = nm2
				then (type_unify subs esubs vty1 vty2; fvmatch)
				else term_fail "term_unify" 67005 [itm1,itm2])
			end
			))
			else term_fail "term_unify" 67005 [itm1,itm2])			
		) |	Value _ => term_fail "term_unify" 67005 [itm1,itm2]
	);
=TEX
=SML
	fun tmaux1' fvmatch (bvmatch : (TERM * TERM) list) 
			tm2 v1 = (
		if is_var tm2
		then	(case rassoc5 bvmatch tm2 of
				Value v1' => (
					if v1' = v1 andalso lassoc5 bvmatch v1' = Value tm2
					then fvmatch
					else term_fail "term_unify" 67005 [itm1,itm2]
			) |	Nil => tmaux0' fvmatch bvmatch tm2 v1
			)
		else 	tmaux0' fvmatch bvmatch tm2 v1
	);

=TEX
Back to the body of tmaux2
=SML
in
		case stm1 of
		(Var v1) =>
		tmaux1' fvmatch bvmatch (mk_simple_term stm2) (mk_var v1) 
		| _ => case stm2 of
		(Var v2) =>
		tmaux1 fvmatch bvmatch (mk_simple_term stm1) (mk_var v2)
		| _ => term_fail "term_unify" 67005 [itm1,itm2]
end);
=TEX
=SML
	val ofvmatch = tmaux2 ifvmatch [] 
		(dest_simple_term tm1)
		(dest_simple_term tm2);
	fun get_ty_inst ty = (
	let	val sendto = expand_type subs esubs ty;
	in
		if sendto = ty
		then fail "get_ty_inst" 0 []
		else (sendto, ty)
	end); 
	val omi1 = mapfilter (get_ty_inst) imi1;
	val omi2 = mapfilter (get_ty_inst) imi2;
	fun get_tm_subst trans_ms tm = (
	let	val used_tm = lassoc3 trans_ms tm;
		val sendto = expand_term subs esubs ofvmatch used_tm;
	in
		(sendto, tm)
	end); 
	val oms1 = mapfilter (get_tm_subst trans_ms1) ims1;
	val oms2 = mapfilter (get_tm_subst trans_ms2) ims2;
in
	((omi1,oms1),(omi2,oms2))
end
handle complaint =>
pass_on complaint "type_unify" "term_unify");
=IGN
term_unify [] [] ((¨aÆ,[],[]),(¨aÆ,[],[]));
term_unify [] [] ((¨aÆ,[],[]),(¨bÆ,[],[])); (* fails *)
term_unify [] [] ((¨aÆ,[¨aÆ],[]),(¨bÆ,[¨bÆ],[]));
term_unify [] [] ((¨aÆ,[¨aÆ],[]),(¨bÆ,[],[]));
term_unify [] [] ((¨aÆ,[],[]),(¨bÆ,[¨bÆ],[]));
term_unify [] [] ((¨a:'aÆ,[¨a:'aÆ],[¨:'aÆ]),(¨b:'bÆ,[¨b:'bÆ],[¨:'bÆ]));
term_unify [] [] ((¨a:'aÆ,[¨a:'aÆ],[¨:'aÆ]),(¨b:'bÆ,[¨b:'bÆ],[]));
term_unify [] [] ((¨a:'aÆ,[¨a:'aÆ],[]),(¨b:'bÆ,[¨b:'bÆ],[¨:'bÆ]));
term_unify [] [] ((¨f (x (f:'a ≠ 'b):'a)Æ,[¨f:'a ≠ 'bÆ,¨x:('a ≠ 'b) ≠ 'aÆ],[¨:'aÆ,¨:'bÆ]),
	(¨y (g:'a ≠ 'b) g:'bÆ,[¨y:('a ≠ 'b) ≠ ('a ≠ 'b) ≠ 'bÆ,¨g:'a ≠ 'bÆ],[¨:'aÆ,¨:'bÆ]));
term_unify [] [] ((¨R (x:'a) (y:'a):BOOLÆ,[¨x:'aÆ, ¨y:'aÆ, ¨z:'aÆ],[]),(¨R (x:'a) (z:'a):BOOLÆ,[¨x:'aÆ, ¨y:'aÆ, ¨z:'aÆ],[]));
term_unify [] [] ((¨Æ,[],[]),(¨Æ,[],[]));
term_unify [] [] ((¨Æ,[],[]),(¨Æ,[],[]));
term_unify [] [] ((¨Æ,[],[]),(¨Æ,[],[]));

fun free_unify tm1 tm2 = (term_unify [] []
	((tm1,frees tm1,map mk_vartype(term_tyvars tm1)),
	(tm2,frees tm2,map mk_vartype(term_tyvars tm2)))
);
fun setup_unify tm1 tm2 = 
	((tm1,frees tm1,map mk_vartype(term_tyvars tm1)),
	(tm2,frees tm2,map mk_vartype(term_tyvars tm2)));
free_unify ¨f:'a ≠ 'bÆ ¨g:'a ≠ 'bÆ;
free_unify ¨f xÆ ¨g yÆ;
free_unify ¨Ã x ∑ fÆ ¨Ã y ∑ gÆ;
free_unify ¨Ã x ∑ f xÆ ¨Ã y ∑ g yÆ;
free_unify ¨Ã x ∑ f pÆ ¨Ã y ∑ g qÆ;

free_unify ¨f xÆ ¨g (y:'c)Æ;

=TEX
\subsection{Resolution Tools Prooper}
The arguments are:
\begin{enumerate}
\item
The term is a subterm of the theorem argument(5), 
reached through outer universal quantifications and
all propositional connectives.
\item
The bool is false if and only if the subterm occurs ``negatively'' in the conclusion of the theorem.
\item
The term list is the specialisable variables of the subterm.
\item
The type list is the instantiable type variables of the subterm.
\item
The theorem is the source of the fragment.
\item
The next term list is the term variables that may not be used
in unifying the fragment
\item
The next type list is the type variables that may not be used
in unifying the fragment
\end{enumerate}
=SML
type BASIC_RES_TYPE = TERM * bool * TERM list * TYPE list * THM * TERM list * TYPE list;
type RES_DB_TYPE = BASIC_RES_TYPE list * BASIC_RES_TYPE list *
	BASIC_RES_TYPE list * THM list;
=TEX
Why isn't this in DTD004???
=SML
fun €strip_pair› (tm:TERM) : TERM list = (
let	val (a,b) = dest_pair tm
in
	strip_pair a @ strip_pair b
end)
handle (Fail _) => [tm];
=TEX
=SML
local
	fun rev_pos (a,t,bd) = (a, not t,bd);
	fun list_is_free_in (inlst:TERM list) (tm:TERM) = (
	let	val fs = frees tm;
	in
		any fs (fn x => x mem inlst)
	end);

	fun aux (pos:bool) (bd:TERM list) (tm:TERM) (dtm : DEST_TERM) : (TERM * bool * TERM list) list = (
	case dtm of
	D¥(a,b) => (
		aux (not pos) bd a (dest_term a) @ aux pos bd b (dest_term b)) 
	| (D≥ a) => aux (not pos) bd a (dest_term a)
	| (D±(a,b)) => (
		aux pos bd a (dest_term a) @ aux pos bd b (dest_term b)
	) | (D≤(a,b)) => (
		aux pos bd a (dest_term a) @ aux pos bd b (dest_term b)
	) | (D§(a,b)) => (
		let 	val a' = aux pos bd a (dest_term a);
			val b' = aux pos bd b (dest_term b);
		in
			a' @ b' @ map rev_pos a' @ map rev_pos b'
		end
	) | DT => if pos then [] else [(mk_t,false,bd)]
	| DF => if pos then [(mk_f,true,bd)] else []
	| (Dµ (x,t)) => (
		if list_is_free_in bd tm
		then aux pos (strip_pair x @ bd) t (dest_term t)
		else (tm, pos, bd) :: aux pos (strip_pair x @ bd) t (dest_term t)
	) | (D∂ (x,t)) => (
		if list_is_free_in bd tm
		then aux pos (strip_pair x @ bd) t (dest_term t)
		else (tm, pos, bd) :: aux pos (strip_pair x @ bd) t (dest_term t)
	) | (D∂â1 (x,t)) => (
		if list_is_free_in bd tm
		then aux pos (strip_pair x @ bd) t (dest_term t)
		else (tm, pos, bd) :: aux pos (strip_pair x @ bd) t (dest_term t)
	) | (DIf(cnd,th,el)) => (
	let	val cnd' = aux pos bd cnd (dest_term cnd);
	in
		cnd' @ map rev_pos cnd' @
		aux pos bd th (dest_term th) @
		aux pos bd el (dest_term el)
	end
	) | _ => (
		if list_is_free_in bd tm
		then []
		else [(tm, pos, bd)]
	));
in
fun €fragment_term› (tm : TERM) : (TERM * bool * TERM list) list * TERM list = (
let	val (vs,tm') =strip_µ tm;
	val vs' = flat (map strip_pair vs);
in
	(aux true [] tm' (dest_term tm'), vs')
end);
end;
=IGN
fragment_term ¨µ a ∑ a ± ≥ b ¥ (µ e ∑ e ± c) ± f dÆ;
=TEX
Specialise the noted quantified variables in a theorem,
leave the rest specialised to the bound variable
(presumably what the caller intended).
=SML
fun €local_specialise_rule› (subs:(TERM * TERM)list) (thm:THM) : THM = (
let	val thm' = conv_rule (TRY_C all_µ_uncurry_conv) thm;
	val (vs,_) = strip_simple_µ(concl thm');
	val vs' = map (rassoc1 subs) vs;
in
	list_simple_µ_elim vs' thm'
end);
=TEX
This returns $1$ if the conclusion of the first theorem equals
the second's, or is
a less general form than the second
(i.e. could be produced only by specialising the second theorem).
It returns $2$ if the second theorem's conclusion 
is a less general form than the first,
and otherwise returns $0$.

In checking, one must either gain a successful term match 
of the two conclusions, which can be used to generate
the other theorem.
The requirement is that the type instantiation
affects no type variables in the assumptions,
any specialised variable in the second theorem was bound,
and that any variable bound in the first theorem
is not free in the second.

(using inference in a check is crude). 
=SML
fun €basic_res_subsumption› (thm1 : THM) (thm2 :THM) : int = (
let	val (vs1,c1) = strip_µ(concl thm1);
	val (vs2,c2) = strip_µ(concl thm2);
	val vs1' = flat(map strip_pair vs1);
	val vs2' = flat(map strip_pair vs2);
in
(let	val (tym,tvm) = term_match c1 c2;
	val cthm2' = concl(inst_type_rule tym thm2);
	val fthm2' = frees cthm2';
in
	if (map snd tvm) subset (flat(map strip_pair (fst(strip_µ cthm2'))))
		andalso not(any vs1' (fn x => x mem fthm2'))
	then 1
	else fail "" 0 []
end
handle (Fail _) =>
(let	val (tym,tvm) = term_match c2 c1;
	val cthm1' = concl(inst_type_rule tym thm1);
	val fthm1' = frees cthm1';
in
	if (map snd tvm)  subset (flat(map strip_pair (fst(strip_µ cthm1'))))
		andalso not(any vs2' (fn x => x mem fthm1'))
	then 2
	else 0
end
handle (Fail _) => 0))
end);
=IGN
basic_res_subsumption t_thm f_thm;
basic_res_subsumption t_thm t_thm;
basic_res_subsumption ±_thm (all_simple_µ_elim ±_thm);
basic_res_subsumption (all_simple_µ_elim ±_thm) ±_thm ;
let 	val thma = tac_proof(([],¨µ x : 'a ∑ x = xÆ), rewrite_tac[]);
	val thmb = tac_proof(([],¨µ x : BOOL ∑ x = xÆ), rewrite_tac[]);
in
(basic_res_subsumption thma thmb,
basic_res_subsumption thmb thma)
end;
let 	val thma = tac_proof(([],¨µ x : 'a ∑ x = xÆ), rewrite_tac[]);
	val thmb = asm_rule ¨µ x : 'b ∑ x = xÆ;
in
(basic_res_subsumption thma thmb,
basic_res_subsumption thmb thma)
end;
basic_res_subsumption (asm_rule ¨µ x y z∑ R x y ± R y z ¥ R x zÆ)
	(asm_rule ¨µ x y z∑ R x y ± R y z ¥ R x zÆ);

basic_res_subsumption (asm_rule ¨µ x y z∑ R x y ± R y z ¥ R x zÆ)
	(asm_rule ¨µ p q r∑ R p q ± R q r ¥ R p rÆ);


=TEX
=SML
fun €aux_basic_res_pre› ([] : THM list) : BASIC_RES_TYPE list = []
| aux_basic_res_pre (a :: x) = (
let	val (asms,cl) = dest_thm a;
	val ctyvars = term_tyvars cl;
	val atyvars = list_cup (map term_tyvars asms);
	val fvs = list_cup (frees cl :: map frees asms);
	val ityvars = map mk_vartype (ctyvars diff atyvars);
	val (frags,vs) = fragment_term cl;
in
	map (fn (frag,pos,bd) => (frag,pos,vs,ityvars,a,
		bd @ fvs,
		map mk_vartype atyvars)) frags @
	aux_basic_res_pre x
end);

fun €basic_res_pre› (sos:THM list) (rest:THM list) : RES_DB_TYPE = (
let	val prest = aux_basic_res_pre rest;
	val psos = aux_basic_res_pre sos;
in
	if is_nil psos
	then (prest, [], psos, rest @ sos)
	else (prest @ [hd psos], [], psos, rest @ sos)
end);

=TEX
Try an instantiation or substituition, but don't fail.
=SML
fun €try_subst› (ts : (TERM * TERM) list) (tm : TERM): TERM = (
	subst ts tm
	handle complaint =>
	if area_of complaint = "subst"
	then tm
	else reraise complaint (area_of complaint)
);
fun €try_inst› (av:TERM list) (ts : (TYPE * TYPE) list) (tm : TERM): TERM = (
	inst av ts tm
	handle complaint =>
	if area_of complaint = "inst"
	then tm
	else reraise complaint (area_of complaint)
);
=TEX
=SML
fun €thm_frees› (thm :THM) : TERM list = (
let	val (asms,cl) = dest_thm thm;
in
	list_cup (frees cl :: map frees asms)
end);
=TEX
=SML
fun €basic_res_resolver› (subs:SUBS) 
	((frag1,pos1,vs1,tyvars1,thm1,nsvs1,nivs1):BASIC_RES_TYPE)
	((frag2,pos2,vs2,tyvars2,thm2,nsvs2,nivs2):BASIC_RES_TYPE) : THM list = (
	if pos1 = pos2
	then []
	else ((
	let	val ((ti1,ts1),(ti2,ts2)) = term_unify subs
		(nivs1 @ nivs2) (nsvs1 @ nsvs2)
		((frag1,vs1,tyvars1),(frag2,vs2,tyvars2));
		val thm1' = local_specialise_rule ts1
			(inst_type_rule ti1 thm1);
		val thm2' = local_specialise_rule ts2
			(inst_type_rule ti2 thm2);
		val subterm = try_subst ts1(try_inst [] ti1 frag1); 
	in
		if pos1
		then [basic_resolve_rule subterm thm1' thm2']
		else [basic_resolve_rule subterm thm2' thm1']
	end)
	handle complaint =>
	if area_of complaint = "term_unify"
	then []
	else reraise complaint (area_of complaint))
);

=TEX
=SML
fun €int_max› (a:int,b) = if a < b then b else a;
=TEX
=SML
fun €thm_less› thms thm = (
let	val dthm = dest_thm thm
in
	thms drop (fn x => dest_thm x = dthm)
end);
=TEX
=SML
fun €thm_diff› thms thms' = (
let	val dthms' = map dest_thm thms';
in
	thms drop (fn x => dest_thm x mem dthms')
end);
=SML
local
=SML
fun keep_lose_thms new_thms old_thms = (
let	fun aux [] added added' lost old old' = (
		aux_basic_res_pre added,added @ old, lost
	) | aux (a :: x) added [] lost old [] = (
		aux x (a :: added) (a :: added) lost old old
	) | aux (a :: x) added (a' :: x') lost old [] = (
		case (basic_res_subsumption a a') of
		1 => aux x added added lost old old
		| 2 => aux (a :: x) (thm_less added a) x' lost old []
		| _ => aux (a :: x) added x' lost old []
	) | aux (a :: x) added added' lost old (a' :: x') = (
		case (basic_res_subsumption a a') of
		1 => aux x added added' lost old old
		| 2 => aux (a :: x) added added' (a' :: lost) (thm_less old a) x'
		| _ => aux (a :: x) added added' lost old x'
	);
in
	aux new_thms [] [] [] old_thms old_thms
end);
=TEX
Drop any fragments whose theorems are in a given list.
=SML
fun frag_drop thml = (
let	val cthml = map dest_thm thml;
in
	(fn fragl =>
	fragl drop (fn (_,_,_,_,thm,_,_):BASIC_RES_TYPE => (dest_thm thm mem cthml))
	)
end);

in
fun €basic_res_post› (subsum:THM -> THM -> int) 
	((res, (against,tried, toprocess, using_thms)):THM list * RES_DB_TYPE)
	: (RES_DB_TYPE * bool) = (
let	val res' = flat(map strip_±_rule res) drop (fn thm =>
		concl thm = mk_t);
in
	if any res' (fn thm => concl thm = mk_f)
	then ((against, tried, toprocess, res' @ using_thms),true)
	else (let	val (new_frags, keep_thms, lose_thms) = keep_lose_thms res' using_thms;
		val fd = frag_drop lose_thms;
		val against' = fd (tl against);
		val tried' = fd (hd against :: tried);
		val hdtoprocess' =  fd [hd toprocess];
		val tltoprocess' = (fd (tl toprocess)) @ new_frags;
	in
		if is_nil hdtoprocess'
		then (([], rev against' @ tried, tltoprocess', keep_thms), false)
		else ((against', tried', hdtoprocess' @ tltoprocess', keep_thms), false)
	end)
end);
end;
=TEX
=SML
fun €basic_res_extract› ((_,_,_,thml):RES_DB_TYPE) : THM list = thml;

=TEX
=SML
fun €prim_resolution_rule› (prep : THM list -> THM list -> ('a list * 'a list * 'a list * 'b))
	(reso:'a -> 'a -> THM list)
	(postp:(THM list * ('a list * 'a list * 'a list * 'b)) -> 
		(('a list * 'a list * 'a list * 'b) * bool))
	(extract:('a list * 'a list * 'a list * 'b) -> THM list)
	(limit : int)
	(sos : THM list)
	(rest : THM list) : THM list = (
	if any (sos @ rest) (fn thm => concl thm = mk_f)
	then [find (sos @ rest) (fn thm => concl thm = mk_f)]
	else
let	val init_db = prep sos rest;
	fun aux (db as (against, tried, toprocess, dbdata)) count = (
		if is_nil toprocess
		then extract db
		else if is_nil against
		then (let val toprocess' = tl toprocess;
		in
			if is_nil toprocess'
			then extract db
			else aux(rev(hd toprocess' :: tried),[],toprocess',dbdata) count
		end)
		else (let
			val res_thms = reso (hd toprocess) (hd against);
			val (db',halt) = postp (res_thms,db);
			val count' = count + length res_thms;
		in
			if halt orelse (count' >= limit)
			then extract db' 
			else aux db' count'
		end)
	);
in
	aux init_db 0
end);
=TEX
=SML
fun €basic_resolution_rule› (limit:int) (sos:THM list) (rest:THM list) : THM list = 
	prim_resolution_rule 
		basic_res_pre
		(basic_res_resolver (new_subs 100))
		(basic_res_post basic_res_subsumption)
		basic_res_extract
		limit
		sos
		rest;
=IGN
val prep = basic_res_pre;
val reso = basic_res_resolver;
val postp = (basic_res_post basic_res_subsumption);
val extract = basic_res_extract;

val limit = 1;
val sos = [(asm_rule ¨(µ x y z ∑ R x y ± R y z ¥ R x z)Æ)];
val rest = [];

=IGN
basic_resolution_rule 10 [] [];

basic_resolution_rule 10 
	[asm_rule ¨a ¥ bÆ, asm_rule ¨a:BOOLÆ] [];

basic_resolution_rule 1
	[
	(asm_rule ¨(µ x y :'a∑ R x y ¥ R y x)Æ)]
	[]; (* no addition *)
basic_resolution_rule 1
	[
	(asm_rule ¨(µ x y z:'a ∑ R x y ± R y z ¥ R x z)Æ)]
	[];
basic_resolution_rule 10
	[
	(asm_rule ¨(µ x y z:'a ∑ R x y ± R y z ¥ R x z)Æ)]
	[];
basic_resolution_rule 3
	[
	(asm_rule ¨(µ x y z :'a∑ R x y ± R y z ¥ R x z)Æ),
	(asm_rule ¨(µ x y :'a∑ R x y ¥ R y x)Æ)]
	[];
basic_resolution_rule 10 
	[
	(asm_rule ¨(µ x y z :'a∑ R x y ± R y z ¥ R x z)Æ),
	(asm_rule ¨(µ x y:'a ∑ R x y ¥ R y x)Æ),
	(asm_rule ¨µ x :'a∑ R x (f x:'a)Æ),
	(asm_rule ¨(≥ R (x:'a) x)Æ)]
	[];
basic_resolution_rule 100
	[
	(asm_rule ¨(µ x y z:'a ∑ R x y ± R y z ¥ R x z)Æ),
	(asm_rule ¨(µ x y:'a ∑ R x y ¥ R y x)Æ),
	(asm_rule ¨µ x :'a∑ R x (f x:'a)Æ),
	(asm_rule ¨(≥ R (x:'a) x)Æ)]
	[];
basic_resolution_rule 10
	[(asm_rule ¨(µ x y :'a ∑ R x y ¥ R y x)Æ),
	(asm_rule ¨µ x :'a∑ R x (f x:'a)Æ)] [] ;

basic_resolution_rule 100
	[(asm_rule ¨(≥ R (x:'a) x)Æ)]
	[(asm_rule ¨(µ x y z:'a ∑ R x y ± R y z ¥ R x z)Æ),
	(asm_rule ¨(µ x y:'a ∑ R x y ¥ R y x)Æ),
	(asm_rule ¨µ x :'a∑ R x (f x:'a)Æ)];

basic_resolution_rule 10
	[(asm_rule ¨µ x ∑ p (f x) ± ≥ p xÆ)]
	[];
(* Moore's three blocks problem *)
basic_resolution_rule 200 (* 100 is not enough *)
	[
	(asm_rule ¨on(A:'box,B:'box):BOOLÆ),
	(asm_rule ¨on(B:'box,C:'box):BOOLÆ),
	(asm_rule ¨green(A:'box):BOOLÆ),
	(asm_rule ¨≥ green(C:'box)Æ),
	(asm_rule ¨µ x y:'box∑ (green x ± on(x,y)) ¥ green yÆ)
	]
	[];
basic_resolution_rule 200 (* 100 is not enough *)
	[
	(asm_rule ¨on(A:'box,B:'box):BOOLÆ),
	(asm_rule ¨on(B:'box,C:'box):BOOLÆ),
	(asm_rule ¨green(A:'box):BOOLÆ),
	(asm_rule ¨≥ green(C:'box)Æ)
	]
	[(asm_rule ¨µ x y:'box∑ (green x ± on(x,y)) ¥ green yÆ)];
basic_resolution_rule 10
	[
	(asm_rule ¨Æ),
	]
	[];

=TEX
\section{DERIVED RESOLUTION TOOLS}
=SML
local
	val thm = tac_proof(([],¨µ a ∑ a § (≥ a ¥ a)Æ),
		REPEAT strip_tac);
in
val rec €all_≥_∂_conv› = (fn tm =>
	(≥_∂_conv FURTHER_C 
	BINDER_C all_≥_∂_conv) tm
);

val €c_contr_tac1› : TACTIC = (
	conv_tac(fn a => simple_µ_elim a thm)
	THEN
	¥_T (strip_asm_tac o conv_rule (TRY_C all_≥_∂_conv))
);

fun €C_CONTR_T1› (thmtac: THM -> TACTIC): TACTIC = (
	conv_tac(fn a => simple_µ_elim a thm)
	THEN
	¥_T thmtac
);
end;
=SML
fun €BASIC_RESOLUTION_T› (limit:int) (thml:THM list) (thmtac1: THM -> TACTIC) 
	(thmtac2: THM -> TACTIC) : TACTIC = (fn (asms,gl) => 
let	val (sgs,prf) = C_CONTR_T1 thmtac1 (asms,gl);
	val lasms = length asms;
	fun	aux (asms',gl') = (
	let	val lasms' = length asms';
		val new_asms = asms' to (lasms' - (1 + lasms));
		val old_asms = asms' from (lasms' - (lasms));
		val new_asm_thms = map asm_rule new_asms;
		val old_asm_thms = map asm_rule old_asms;
		val res_thms = basic_resolution_rule limit
			new_asm_thms
			(thml @ old_asm_thms);
		val res_thms' = thm_diff res_thms (thml @ new_asm_thms @ old_asm_thms);
	in
		if any res_thms (fn thm => concl thm = mk_f)
		then f_thm_tac (find res_thms (fn thm => concl thm = mk_f)) (asms',gl')
		else 
		(MAP_EVERY thmtac2 res_thms') (asms',gl')
	end);
	val sgs2pfs2 = map aux sgs;
in
	(flat (map fst sgs2pfs2),
	prf o mapshape (map (fn (sgs, pf) => (pf, length sgs))sgs2pfs2))
end);

=TEX
=SML
fun €basic_resolution_tac› (limit:int) (thml:THM list) : TACTIC = (
	BASIC_RESOLUTION_T limit thml (strip_asm_tac o conv_rule (TRY_C all_≥_∂_conv))
 	strip_asm_tac
);
=TEX
=SML
fun €basic_resolution_tac2› (limit:int) (thml:THM list) : TACTIC = (
	BASIC_RESOLUTION_T limit thml (strip_asm_tac o conv_rule (TRY_C all_≥_∂_conv))
	(fn _ => fail_with_tac "basic_resolution_tac2" 67014 [])
);
=TEX
=SML
fun €BASIC_RESOLUTION_T1› (limit:int) (thml:THM list) 
	(thmtac: THM -> TACTIC) : TACTIC = (
	GET_ASMS_T (fn thms => 
	let val res_thms = basic_resolution_rule limit thms thml;
		val res_thms' = thm_diff res_thms (thml @ thms);

	in
		if any res_thms (fn thm => concl thm = mk_f)
		then f_thm_tac (find res_thms (fn thm => concl thm = mk_f))
		else MAP_EVERY thmtac res_thms'
	end)
);

=TEX
=SML
fun €basic_resolution_tac1› (limit:int) (thml:THM list) : TACTIC = (
	BASIC_RESOLUTION_T1 limit thml strip_asm_tac
);
=TEX
=SML
fun €basic_resolution_tac3› (limit:int) (thml:THM list) : TACTIC = (
	BASIC_RESOLUTION_T1 limit thml 
	(fn _ => fail_with_tac "basic_resolution_tac3" 67014[])
);
=TEX
\section{EPILOGUE}
=IGN
val _ = open_theory lthy;
val _ = pop_proof_context();
end; (* of structure Resolution *)
open Resolution;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

=IGN


push_goal([],¨(µ x y z ∑ R x y ± R y z ¥ R x z) ±
 (µ x y ∑ R x y ¥ R y x) ±
 (µ x ∑ ∂ y ∑ R x y) ¥
 (µ x ∑ R x x)Æ);
 a(c_contr_tac);
a(list_spec_nth_asm_tac 3 [¨xÆ,¨xÆ]); (* useless *)

(* comparing 2 vs 3 suggests need preprocessing, or embedded
   skolemisation *)

push_goal([],¨(µ x y z ∑ R x y ± R y z ¥ R x z) ±
 (µ x y ∑ R x y ¥ R y x) ±
 (∂ f ∑ µ x :'a∑ R x (f x:'a)) ¥
 (µ x ∑ R x x)Æ);
 a(c_contr_tac);
a(list_spec_nth_asm_tac 3 [¨xÆ,¨xÆ]); (* useless *)
a(list_spec_asm_tac ¨µ x y∑ R x y ¥ R y xÆ [¨x'Æ,¨f x'Æ]);
(* *** Goal "1" *** *)
a(spec_asm_tac ¨µ x∑ R x (f x)Æ ¨x'Æ);


(* *** Goal "2" *** *)
a(spec_asm_tac ¨µ x∑ R x (f x)Æ ¨x'Æ);
a(list_spec_asm_tac ¨µ x y∑ R x y ¥ R y xÆ [¨x''Æ,¨x''Æ]);
(* *** Goal "2.1" *** *)
a(list_spec_asm_tac ¨µ x y z∑ R x y ± R y z ¥ R x zÆ [¨xÆ,¨y''Æ,¨xÆ]);

(* *** Goal "2.1.1" *** *)
a(list_spec_asm_tac ¨µ x y z∑ R x y ± R y z ¥ R x zÆ [¨x'''Æ,¨y'''Æ,¨f x'''Æ]);
(* *** Goal "2.1.1.1" *** *)
a(spec_asm_tac  ¨µ x∑ R x (f x)Æ ¨x'''Æ);
a(list_spec_asm_tac ¨µ x y z∑ R x y ± R y z ¥ R x zÆ [¨x''''Æ,¨x'''''Æ,¨f x'''''Æ]);
(* *** Goal "2.1.1.1.1" *** *)
a(spec_asm_tac  ¨µ x∑ R x (f x)Æ ¨x'''''Æ);


a(basic_resolve_tac ¨Æ 
	(¨Æ,[])
	(¨Æ,[]));

push_goal([],¨(µ x y z ∑ R x y ± R y z ¥ R x z) ±
 (µ x y ∑ R x y ¥ R y x) ±
 (∂ f ∑ µ x :'a∑ R x (f x:'a)) ¥
 (µ x ∑ R x x)Æ);
a(c_contr_tac);
a(basic_resolve_tac ¨R x xÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨xÆ,¨xÆ])
	(¨≥ R x xÆ,[])); 
a(basic_resolve_tac ¨R x' (f x')Æ 
	(¨µ x∑ R x (f x)Æ,[¨x'Æ])
	(¨µ x y∑ R x y ¥ R y xÆ,[¨x'Æ,¨f x'Æ]));
a(basic_resolve_tac ¨R x' x'Æ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨x'Æ,¨x'Æ])
	(¨µ x y∑ R x y ¥ R y xÆ,[¨x'Æ,¨x'Æ]));
a(basic_resolve_tac ¨R x xÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨xÆ,¨yÆ,¨xÆ])
	(¨≥ R x xÆ,[]));
a(basic_resolve_tac ¨R x' (f x')Æ 
	(¨µ x∑ R x (f x)Æ,[¨x'Æ])
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨x'Æ,¨f x'Æ,¨zÆ]));
a(basic_resolve_tac ¨R x' (f x')Æ 
	(¨µ x∑ R x (f x)Æ,[¨x'Æ])
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨zÆ,¨x'Æ,¨f x'Æ]));
a(basic_resolve_tac ¨R y x'Æ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨x'Æ,¨yÆ])
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨yÆ,¨x'Æ,¨zÆ]));
	(* best to do all specialisation *)
a(basic_resolve_tac ¨R y x'Æ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨x'Æ,¨yÆ])
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨zÆ,¨yÆ,¨x'Æ]));
a(basic_resolve_tac ¨R x' zÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨x'Æ,¨yÆ,¨zÆ])
	(¨µ x y∑ R x y ¥ R y xÆ,[¨zÆ,¨x'Æ]));
a(basic_resolve_tac ¨R x' yÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨x'Æ,¨yÆ,¨zÆ])
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨x'Æ,¨zÆ,¨yÆ]));
a(basic_resolve_tac ¨R y zÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨x'Æ,¨yÆ,¨zÆ])
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨yÆ,¨x'Æ,¨zÆ]));
a(basic_resolve_tac ¨R (f x') x'Æ 
	(¨µ x'∑ R (f x') x'Æ,[¨x'Æ])
	(¨µ x y∑ R x y ¥ R y xÆ,[¨f x'Æ, ¨x'Æ]));
a(basic_resolve_tac ¨R (f x') x'Æ 
	(¨µ x'∑ R (f x') x'Æ,[¨x'Æ])
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨f x'Æ,¨x'Æ,¨zÆ]));
a(basic_resolve_tac ¨R (f x') x'Æ 
	(¨µ x'∑ R (f x') x'Æ,[¨x'Æ])
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨zÆ,¨f x'Æ,¨x'Æ]));
a(basic_resolve_tac ¨R x (f x)Æ 
	(¨µ x∑ R x (f x)Æ,[¨xÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨f xÆ]));
a(basic_resolve_tac ¨R x yÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨yÆ,¨xÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨yÆ]));
a(basic_resolve_tac ¨R x yÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨xÆ,¨zÆ,¨yÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨yÆ]));
a(basic_resolve_tac ¨R y xÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨yÆ,¨zÆ,¨xÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨yÆ]));

a(basic_resolve_tac ¨R (f x) xÆ 
	(¨µ x'∑ R (f x') x'Æ,[¨xÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨f xÆ]));
a(basic_resolve_tac ¨R x xÆ 
	(¨µ x' z∑ R (f x') z ¥ R x' zÆ,[¨xÆ,¨xÆ])
	(¨≥ R x xÆ,[]));
a(basic_resolve_tac ¨R(f x') (f(f x'))Æ 
	(¨µ x∑ R x (f x)Æ,[¨f x'Æ])
	(¨µ x' z∑ R (f x') z ¥ R x' zÆ,[¨x'Æ,¨f(f x')Æ]));
a(basic_resolve_tac ¨R(f x') zÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨zÆ,¨f x'Æ])
	(¨µ x' z∑ R (f x') z ¥ R x' zÆ,[¨x'Æ,¨zÆ]));
a(basic_resolve_tac ¨R x' zÆ 
	(¨µ x' z∑ R (f x') z ¥ R x' zÆ,[¨x'Æ,¨zÆ])
	(¨µ x y∑ R x y ¥ R y xÆ,[¨x'Æ,¨zÆ]));
a(basic_resolve_tac ¨R(f x') zÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨f x'Æ,¨yÆ,¨zÆ])
	(¨µ x' z∑ R (f x') z ¥ R x' zÆ,[¨x'Æ,¨zÆ]));
a(basic_resolve_tac ¨R (f x') x'Æ 
	(¨µ x'∑ R (f x') x'Æ,[¨x'Æ])
	(¨µ x' z∑ R (f x') z ¥ R x' zÆ,[¨x'Æ,¨x'Æ]));
a(basic_resolve_tac ¨R x yÆ 
	(¨µ x' z∑ R (f x') z ¥ R x' zÆ,[¨xÆ,¨yÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨yÆ]));
a(basic_resolve_tac ¨R y xÆ 
	(¨µ x' z∑ R (f x') z ¥ R x' zÆ,[¨yÆ,¨xÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨yÆ]));
a(basic_resolve_tac ¨R x' (f x')Æ 
	(¨µ x∑ R x (f x)Æ,[¨x'Æ])
	(¨µ z x'∑ R z x' ¥ R z (f x')Æ,[¨x'Æ,¨f x'Æ]));
a(basic_resolve_tac ¨R y x'Æ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨x'Æ,¨yÆ])
	(¨µ z x'∑ R z x' ¥ R z (f x')Æ,[¨yÆ,¨x'Æ]));
a(basic_resolve_tac ¨R z (f x')Æ 
	(¨µ z x'∑ R z x' ¥ R z (f x')Æ,[¨zÆ,¨x'Æ])
	(¨µ x y∑ R x y ¥ R y xÆ,[¨zÆ,¨(f x')Æ]));

etc until

a(basic_resolve_tac ¨R (f x) xÆ 
	(¨µ x'∑ R (f x') x'Æ,[¨xÆ])
	(¨≥ R (f x) xÆ,[]));
pop_thm();

(* set of support just being  ¨≥ R x xÆ *)
push_goal([],¨(µ x y z ∑ R x y ± R y z ¥ R x z) ±
 (µ x y ∑ R x y ¥ R y x) ±
 (∂ f ∑ µ x :'a∑ R x (f x:'a)) ¥
 (µ x ∑ R x x)Æ);
a(c_contr_tac);
a(basic_resolve_tac ¨R x xÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨xÆ,¨xÆ])
	(¨≥ R x xÆ,[])); 
a(basic_resolve_tac ¨R x xÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨xÆ,¨yÆ,¨xÆ])
	(¨≥ R x xÆ,[]));
a(basic_resolve_tac ¨R x (f x)Æ 
	(¨µ x∑ R x (f x)Æ,[¨xÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨f xÆ]));

a(basic_resolve_tac ¨R x yÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨yÆ,¨xÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨yÆ]));
a(basic_resolve_tac ¨R x yÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨xÆ,¨zÆ,¨yÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨yÆ]));
a(basic_resolve_tac ¨R y xÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨yÆ,¨zÆ,¨xÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨yÆ]));
a(basic_resolve_tac ¨R (f x) xÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨xÆ,¨f xÆ])
	(¨≥ R (f x) xÆ,[]));
a(basic_resolve_tac ¨R (f x) xÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨f xÆ,¨yÆ,¨xÆ])
	(¨≥ R (f x) xÆ,[]));
a(basic_resolve_tac ¨R y xÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨xÆ,¨yÆ])
	(¨µ y∑ ≥ R y xÆ,[¨yÆ]));
a(basic_resolve_tac ¨R y xÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨yÆ,¨zÆ,¨xÆ])
	(¨µ y∑ ≥ R y xÆ,[¨yÆ]));
a(basic_resolve_tac ¨R x (f x)Æ 
	(¨µ x∑ R x (f x)Æ,[¨xÆ])
	(¨µ z y∑ ≥ (R x z ± R z y) ≤ ≥ R y xÆ,[¨f xÆ,¨yÆ]));
a(basic_resolve_tac ¨R z (f z)Æ 
	(¨µ x∑ R x (f x)Æ,[¨zÆ])
	(¨µ z y∑ ≥ (R x z ± R z y) ≤ ≥ R y xÆ,[¨zÆ,¨f zÆ]));
a(basic_resolve_tac ¨R x zÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨zÆ,¨xÆ])
	(¨µ z y∑ ≥ (R x z ± R z y) ≤ ≥ R y xÆ,[¨zÆ,¨yÆ]));
a(basic_resolve_tac ¨R z yÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨zÆ,¨yÆ])
	(¨µ z y∑ ≥ (R x z ± R z y) ≤ ≥ R y xÆ,[¨zÆ,¨yÆ]));
a(basic_resolve_tac ¨R y xÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨yÆ,¨xÆ])
	(¨µ z y∑ ≥ (R x z ± R z y) ≤ ≥ R y xÆ,[¨zÆ,¨yÆ]));



a(basic_resolve_tac ¨Æ 
	(¨Æ,[])
	(¨Æ,[]));
a(basic_resolve_tac ¨Æ 
	(¨Æ,[])
	(¨Æ,[]));





