=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Resolution Facilities}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP067}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation
of the resolution facilities in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1,1.2] 
First versions.

\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Tools giving some sort of resolution facility
are called for in \cite{DS/FMU/IED/HLD012}.
This document provides an implementation for these tools.
A design for such tools is given in \cite{DS/FMU/IED/DTD067}.
This document provides an implementations for them.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation for the
resolution tools.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD067}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.

\section{PREAMBLE}
=IGN
structure €Resolution› : Resolution = struct
=TEX
=IGN
val lthy = open_theory "basic_hol";
val _ = push_proof_context ();
=TEX
\section{THE CODE}
Using $rewrite\_rule$ as a simplifier is crude!
=SML
local
	val simp_rewrites_thm = 
	tac_proof(([],
	¨(µ x:'a∑ T) ± (∂ x :'a∑ T) ± 
	≥(µ x:'a∑ F) ± ≥(∂ x :'a∑ F) ±
	((∂â1 x:'a∑T) § (∂ x ∑µ y:'a ∑ y = x)) ±
	(≥(∂â1 x:'a∑F)) ±
	(µ t1 t2∑ (if T then t1 else t2) = t1 ± (if F then t1 else t2) = t2)
	±
	(µ t∑ (T ¥ t § t) ± (F ¥ t § T) ± (t ¥ T § T) ± 
                  (t ¥ F § ≥ t))
	±
	(µ t∑ (T ≤ t) ± (t ≤ T) ± (F ≤ t § t) ± (t ≤ F § t) ±
         (t ≤ t § t) ± (t ≤ ≥ t § T) ± (≥ t ≤ t § T))
	±
	(µ t∑ (T ± t § t) ± (t ± T § t) ± ≥ (F ± t) ± ≥ (t ± F) ±
        (t ± t § t))
	±
	(µ t∑ (≥ T § F) ± (≥ F § T))
	±
	(µ t∑ ((T § t) § t) ± ((t § T) § t) ± ((F § t) § ≥ t) ±
        ((t § F) § ≥ t))Æ),
	rewrite_tac[∂â1_thm] THEN REPEAT strip_tac);
	val rw = pure_rewrite_rule[simp_rewrites_thm];
in
fun €basic_resolve_rule› (subterm:TERM) (pthm:THM) (nthm:THM) : THM = (
let	val cases_thm = (simple_µ_elim subterm bool_cases_axiom)
		handle complaint =>
		divert complaint "simple_µ_elim" "basic_resolve_rule" 
		3031 [fn () => string_of_term subterm];
	val (§_T,§_F) = dest_≤(concl cases_thm);
	val pF = subst[(mk_f,subterm)] (concl pthm);
	val nT = subst[(mk_t,subterm)] (concl nthm);
	val pthm' = pure_once_rewrite_rule[asm_rule §_F]
		(≤_right_intro nT pthm)
		handle complaint =>
		divert complaint "pure_once_rewrite_rule" "basic_resolve_rule" 
		67009 [fn () => string_of_term subterm,
			fn () => string_of_term (concl pthm)];
	val nthm' = pure_once_rewrite_rule[asm_rule §_T]
		(≤_left_intro pF nthm)
		handle complaint =>
		divert complaint "pure_once_rewrite_rule" "basic_resolve_rule" 
		67009 [fn () => string_of_term subterm,
			fn () => string_of_term (concl nthm)];
	val base_thm = ≤_elim cases_thm nthm' pthm';
in
	all_µ_intro(rw base_thm)
	handle complaint =>
	if area_of complaint = "rewrite_rule"
	then base_thm
	else reraise complaint (area_of complaint)
end);
end; (* of local simp_rewrites_thm *)
=TEX
=SML
fun €basic_resolve_tac› (subterm : TERM) 
	(asm1 : TERM, subs1 : TERM list) 

	(asm2: TERM, subs2 : TERM list) : TACTIC = (fn (asms,gl) =>
	LIST_GET_ASM_T [asm1,asm2] 
		(fn lst =>
		let	val thm1 = list_simple_µ_elim subs1 (hd lst);
			val thm2 = list_simple_µ_elim subs2 (hd(tl lst));
			val thm3 = basic_resolve_rule subterm thm1 thm2;
			val cthm3 = concl thm3;
		in
			if (cthm3 = mk_f) orelse (cthm3 = mk_t)
				orelse (cthm3 term_mem asms) 
			then strip_asm_tac thm3
			else asm_tac thm3
		end)
		(asms,gl)
);
=TEX
\subsection{Term Unification}
An algorithm for type unification:
\begin{enumerate}
\item
Substitute type variables not found at all in either term
for the specialisable type variables in either term.
(Not necessary if known to be done already).
\item
Initialise the type substitution maps to send the instantiable type variables to $Nil$.
We can then merge the test for instantiable to what it is
instantiated to.
\item
Consider what the first type is is:
\begin{description}
\item[Type Variable]
\begin{description}
\item{If already instantiated}
Then unify the second type with the instantiation.
\item{Else if instantiable}
(i.e. recorded as instantiated to $Nil$)
Then check for its occurrence in the second type,
if equal, then no change in unifcation map,
if contained in then fail, 
and if not then record the first type instantiated to the $Value$ of the second.
\item{Else}
(i.e. not in instantiation list)
The second type must either be
\begin{itemize}
\item
an instantiable type variable, 
either uninstantiated,
in which case it should be recorded as instantiated to $Value$ of the
first type,
or instantiated in which case its instantiation should
be unified with the first type,
\item
or an uninstantiable type variable, equal in name to the first.
\end{itemize}
\end{description}
\item[Compound Type]
Consider what the second type is is:
\begin{description}
\item[Type Variable]
This must be an instantiable type variable, 
either uninstantiated,
in which case it should be recorded as instantiated to the
first type,
or instantiated in which case its instantiation should
be unified with the first type.
\item[Compound Type]
In whichcase thetype constructor names must be equal, and the type 
arguments unifiable.
\end{description}
\end{description}
\end{enumerate}

An algorithm for term unification:
\begin{enumerate}
\item
Substitute term variables not found at all in either term
for the specialisable term variables in either term.
\item
Substitute type variables not found at all in either term
for the specialisable type variables in either term.
(This prevents having to do this for the individual type unifications).
\item
Initialise the bound variable matching, to empty,
specialisation and instantiation to mapping the variables to $Nil$.
\item
Consider what the first term is:
\begin{description}
\item[Variable]
Determine its actual type, and consider that:
\begin{description}
\item[If a bound variable]
Then the second term must be the corresponding bound variable of the other term,
and the other type, when expanded out, must already be equal.
\item[Else if already specialised]
(i.e. mapped to $Value$ of something in the specialisation map)
Then unify what it is specialised to, and the second term.
\item[Else if it may be specialised]
(i.e. mapped to $Nil$ in the specialisation map)
Then unify its type to the type of the second term,
then expand out the second term, looking for
occurs checks, bound variables, etc,
then record the first term as specialised to the $Value$ of the second term.
\item[Else]
(i.e. not mapped in the specialisation map)
The second term must, after expansion, be either
\begin{itemize}
\item
the same named variable, with a type unifiable to the first.
\item
or a unbound, specialisable variable, with a type unifiable to
the first,
in which case record the second term as specialised to the first term.
\end{itemize}
\end{description}

\item[Constant]
Consider what the second term is:
\begin{description}
\item[Variable]
Determine its actual type, and consider that:
\begin{description}
\item[If a bound variable]
Fail.
\item[Else if already specialised]
Then unify what it is specialised to, and the first term.
\item[Else if it may be specialised]
Then unify its type to the type of the constant,
then record the second term as specialised to the first term.
\item[Else]
Fail.
\end{description}

\item[Constant]
The second term must be the same name, with 
a type unifiable to the first.
\item[Application]
Fail
\item[Abstraction]
Fail
\end{description}

\item[Application]
Consider what the second term is:
\begin{description}
\item[Variable]
Determine its actual type, and consider that:
\begin{description}
\item[If a bound variable]
Fail.
\item[Else if already specialised]
Then unify what it is specialised to, and the first term.
\item[Else if it may be specialised]
Then unify its type to the type of the application,
then record the second term as specialised to the first term.
\item[Else]
Fail.
\end{description}
\item[Application]
Unify the two arguments, and then the two functions
(the order is based on the grounds the types and subterms of the arguments are likely
to be smaller).
\item[Abstraction]
Fail
\end{description}

\item[Abstraction]
Consider what the second term is:
\begin{description}
\item[Variable]
Determine its actual type, and consider that:
\begin{description}
\item[If a bound variable]
Fail.
\item[Else if already specialised]
Then unify what it is specialised to, and the first term.
\item[Else if it may be specialised]
Then unify its type to the type of the abstraction,
then record the second term as specialised to the first term.
\item[Else]
Fail.
\end{description}
\item[Application]
Fail.
\item[Abstraction]
Unify the types of the abstractions.
Then record the fact that the two bound variables are indeed
such while traversing the body.
Then unify the two bodies.
The undo the recording of the bound variables.
\end{description}

\end{description}
\end{enumerate}
=SML
fun €list_string_variant› (av:string list) ([]:string list) : string list = []
| list_string_variant av (h:: t) = (
let	val h' = string_variant av h;
in
	h' :: list_string_variant (h'::av) t
end);
=IGN
list_string_variant ["p","q''","r'","r"] ["q", "q'", "q'''", "r''", "s"];
=SML
fun €term_tytm_vars› (tm : TERM) : TERM list * string list = (
let	fun aux _ (App (f, a)) = (
	let	val (tv1,ty1) = aux f (dest_simple_term f);
		val (tv2,ty2) = aux a (dest_simple_term a);
	in
		((tv1 cup tv2), (ty1 cup ty2))
	end
	) | aux _ (Const (_, ty)) = ([],type_tyvars ty)
	  | aux tm (Var (nm,ty)) = ([tm],type_tyvars ty)
	  | aux _ (SimpleÃ (v, b)) = (
	let val (tv1,ty1) = aux b (dest_simple_term b);
	in
		(tv1 grab v, ty1 cup type_tyvars (type_of v))
	end)
in
	aux tm (dest_simple_term tm)
end);

=TEX
=TEX
To make the specialisable term and instantiable type variables unique in two terms:
=SML
fun €uniquify› (avty : TYPE list) (avtm : TERM list) (((tm1:TERM) ,(ms1: TERM list), (mi1:TYPE list)),
	((tm2:TERM), (ms2:TERM list), (mi2:TYPE list))) :
	((TERM * TERM list * TYPE list) * (TERM * TERM list * TYPE list)) = (
let	val (tv_tm1, ty_tm1) = term_tytm_vars tm1;
	val (tv_tm2, ty_tm2) = term_tytm_vars tm2;
	val tv1_fixed = tv_tm1 diff ms1;
	val tv2_fixed = tv_tm2 diff ms2;
	val tv1_avoid = tv1_fixed @ tv2_fixed @ avtm;
	val tv1' = list_variant tv1_avoid ms1;
	val tv2_avoid = tv1_avoid @ tv1';
	val tv2' = list_variant tv2_avoid ms2;
	val tm1' = subst(combine tv1' ms1) tm1;
	val tm2' = subst(combine tv2' ms2) tm2;
	val nm_mi1 = map dest_vartype mi1;
	val nm_mi2 = map dest_vartype mi2;
	val ty1_fixed = ty_tm1 diff nm_mi1;
	val ty2_fixed = ty_tm2 diff nm_mi2;
	val ty1_avoid = ty1_fixed @ ty2_fixed @ map dest_vartype avty;
	val mi1s' = list_string_variant ty1_avoid nm_mi1;
	val mi1' = map mk_vartype mi1s';
	val ty1_insts = (combine mi1' mi1);
	val ty2_avoid = ty1_avoid @ mi1s';
	val mi2' = map mk_vartype (list_string_variant ty2_avoid nm_mi2);
	val ty2_insts = (combine mi2' mi2);
	val tm1'' = inst [] ty1_insts tm1';
	val tm2'' = inst [] ty2_insts tm2';
	val ms1' = map (inst [] ty1_insts) tv1';
	val ms2' = map (inst [] ty2_insts) tv2';
in
	((tm1'',ms1',mi1'),(tm2'',ms2',mi2'))
end);
=IGN
uniquify [] [] ¨a ± (µ b:'a∑ f b ≤ c) ≤ g (b:'a) ± h (d:'d)Æ [¨a:BOOLÆ,¨b:'aÆ,¨c:BOOLÆ] [¨:'aÆ,¨:'dÆ]
¨a ± (µ b:'a∑ f b ≤ c) ≤ g (b:'a) ± h (d:'d)Æ [¨a:BOOLÆ,¨d:'dÆ] [¨:'aÆ,¨:'dÆ];


=TEX
Expand out a type, checking for the presence of an instantiable (but not yet instantiated) type
variable as you go (an ``occurs'' check).
It is OK for the result to equal $ty1$, but not to contain it.
=SML
fun €expand_check_type› (match:(TYPE * TYPE OPT)list) (ty1:TYPE)
	(ty2: TYPE): TYPE = (
let	fun aux inside ty =
	if is_vartype ty
	then (case lassoc5 match ty of
	Nil => ty (* not instantiable, so not ty1 *)
	| Value Nil => if inside andalso ty1 = ty
		then type_fail "term_unify" 67012 [ty1,ty2]
		else ty
	| Value (Value ty') => 
		if ty' = ty
		then error "expand_check_type" 67013 [
			(fn () => string_of_type ty)]
		else aux inside ty'
	)
	else (let val (nm,tys) = dest_ctype ty
	in
		mk_ctype(nm,map (aux true) tys)
	end)
in
	aux false ty2
end);
=TEX
=SML
fun €expand_type› (match:(TYPE * TYPE OPT)list) (ty2: TYPE): TYPE = (
let	fun aux ty =
	if is_vartype ty
	then (case lassoc5 match ty of
	Nil => ty 
	| Value Nil => ty
	| Value (Value ty') => 
		if ty = ty'
		then error "expand_type" 67013 [
			(fn () => string_of_type ty)]
		else aux ty')
	else (let val (nm,tys) = dest_ctype ty
	in
		mk_ctype(nm,map aux tys)
	end)
in
	aux ty2
end);
=TEX
We do a very cheap and cheerful bound variable hider in the 
following.
=SML
fun €expand_term› (tymatch:(TYPE * TYPE OPT)list) 
	(fvmatch: (TERM * TERM OPT)list)
	(tm:TERM):TERM = (
let	fun aux _ (App(f,a)) = mk_app(
		aux f (dest_simple_term f), 
		aux a (dest_simple_term a))
	| aux _ (Const(nm,ty)) = mk_const(nm, expand_type tymatch ty)
	| aux v (Var (nm,ty)) = (case lassoc5 fvmatch v of
		Nil => mk_var(nm, expand_type tymatch ty)
		| Value Nil => mk_var(nm, expand_type tymatch ty)
		| Value(Value tm') => 
			if v = tm'
			then error "expand_type" 67013 [
				(fn () => string_of_term v)]
			else aux tm' (dest_simple_term tm')
	) | aux _ (SimpleÃ(v,bdy)) = mk_simple_Ã (
		let val (nm,ty) = dest_var v
		in
		mk_var(nm, expand_type tymatch ty)
		end,
		expand_term tymatch (fvmatch drop (fn(x,_)=> x=v)) bdy)
in
	aux tm (dest_simple_term tm)
end);
=TEX
Expand out a term, checking for the presence of an instantiable (but not yet instantiated) term
variable as you go (an ``occurs'' check).
It is OK for the result to equal $mv$, but not to contain it.
=SML
fun €expand_check_term› (tymatch:(TYPE * TYPE OPT)list) 
	(ifvmatch: (TERM * TERM OPT)list)
	(mv:TERM) 
	(tm:TERM):TERM = (
let	fun aux _ _ fvmatch (App(f,a)) = mk_app(
		aux true f fvmatch (dest_simple_term f), 
		aux true a fvmatch (dest_simple_term a))
	| aux _ _  fvmatch (Const(nm,ty)) = mk_const(nm, expand_type tymatch ty)
	| aux inside v fvmatch (Var (nm,ty)) = (case lassoc5 fvmatch v of
		Nil => mk_var(nm, expand_type tymatch ty)
		| Value Nil => (let val nv = mk_var(nm, expand_type tymatch ty);
			in
			if inside andalso mv = v
			then term_fail "term_unify" 67012 [mv, tm]
			else nv
			end
		) | Value(Value tm') => 
			if v = tm'
			then error "expand_check_term" 67013 
				[fn () => string_of_term v]
			else aux inside tm' fvmatch (dest_simple_term tm')
	) | aux _  _ fvmatch (SimpleÃ(v,bdy)) = (mk_simple_Ã (
		let val (nm,ty) = dest_var v
		in
		mk_var(nm, expand_type tymatch ty)
		end,
		aux true bdy (fvmatch drop (fn (x,_)=> x=v)) (dest_simple_term bdy)))
in
	aux false tm ifvmatch (dest_simple_term tm)
end);
=TEX
Unify two types: $aux$ cummulatively unifies two lists of types.
=SML
fun €type_unify› (match:(TYPE * TYPE OPT)list) (ty1:TYPE)
	(ty2: TYPE): (TYPE * TYPE OPT)list = (
let	fun aux mth [] [] = mth
	| aux mth (t1 :: rest1) (t2 :: rest2) = (
		aux (type_unify mth t1 t2) rest1 rest2
	) | aux _ _ _ = type_fail "term_unify" 67005 [ty1,ty2];
in
	if is_vartype ty1
	then (case lassoc5 match ty1 of
	Nil => ((* fixed type variable *)
		if is_vartype ty2
		then (case lassoc5 match ty2 of
		Nil => ( if ty1 = ty2
			then match
			else type_fail "term_unify" 67007 [ty1,ty2,ty1]
		) | Value Nil => (
			match overwrite (ty2,Value ty1)
		) | Value(Value ty2') => (
			type_unify match ty1 ty2'
		)) else
		(type_fail "term_unify" 67005 [ty1,ty2]
		)
	) | Value Nil => ((* as yet uninstantiated *)
	let	val ty2' = expand_check_type match ty1 ty2;
	in
		if ty1 = ty2'
		then match
		else match overwrite (ty1,Value ty2')
	end
	) | Value(Value ty1') => (* instantiated *)
		type_unify match ty1' ty2
	)
	else ((* a compound type *)
		if is_vartype ty2
		then (case (lassoc5 match ty2) of
		Nil => type_fail "term_unify" 67005 [ty1,ty2]
		| Value Nil => (
			match overwrite (ty2,Value ty1)
		) | Value(Value ty2') => (
			type_unify match ty1 ty2'
		))
		else (
		let	val (nm1,tys1) = dest_ctype ty1;
			val (nm2,tys2) = dest_ctype ty2;
		in
			if (nm1 = nm2)
			then aux match tys1 tys2
			else type_fail "term_unify" 67005 [ty1,ty2]
		end)
	)
end);
=IGN
type_unify [(¨:'aÆ,Nil),(¨:'cÆ,Nil),(¨:'dÆ,Nil)]
	¨:'a ≠ 'b ≠ BOOL ≠ ('c ∏ 'd)Æ
	¨:'c ≠ 'c ≠ 'd ≠ ('a ∏ BOOL)Æ;
type_unify [(¨:'aÆ,Nil),(¨:'cÆ,Nil),(¨:'dÆ,Nil)]
	¨:'a ≠ 'b ≠ BOOL ≠ ('c ∏ 'd)Æ
	¨:'c ≠ 'c ≠ 'd ≠ (BOOL ∏ BOOL)Æ; (* fails *)
type_unify [(¨:'aÆ,Nil),(¨:'cÆ,Nil),(¨:'dÆ,Nil)]
	¨:'a Æ
	¨: ('a ∏ 'd)Æ;
=TEX
=IGN
term_unify ((¨a ± (µ b:'a∑ f b ≤ c) ≤ g (b:'a) ± h (d:'d)Æ,
	[¨a:BOOLÆ,¨b:'aÆ,¨c:BOOLÆ], [¨:'aÆ,¨:'dÆ]),
	(¨a ± (µ b:'a∑ f b ≤ c) ≤ g (b:'a) ± h (d:'d)Æ, [¨a:BOOLÆ,¨d:'dÆ], [¨:'aÆ,¨:'dÆ]));
=TEX
Unify two terms:
note that because of bound variable matching we cannot swap the two terms about to exploit symmetry.
=SML
fun  €term_unify› (avty : TYPE list) (avtm: TERM list) 
	((itm1: TERM, ims1: TERM list, imi1: TYPE list),
	(itm2: TERM, ims2: TERM list, imi2: TYPE list))
	: 
	((TYPE * TYPE) list * (TERM * TERM) list) *
	((TYPE * TYPE) list * (TERM * TERM) list) = (
let	
=TEX
Initialisation:
=SML
	val ((tm1,ms1,mi1),(tm2,ms2,mi2)) = (
		uniquify avty avtm ((itm1, ims1, imi1), (itm2, ims2, imi2))
	);
	val itymatch = map (fn ty => (ty,Nil)) (mi1 @ mi2);
	val ifvmatch = map (fn tm => (tm,Nil)) (ms1 @ ms2);
	val trans_mi1 = combine(imi1)(mi1);
	val trans_ms1 = combine(ims1)(ms1);
	val trans_mi2 = combine(imi2)(mi2);
	val trans_ms2 = combine(ims2)(ms2);

=TEX
=SML
	fun tmaux2 (tymatch, fvmatch) bvmatch (App(f1, a1)) (App(f2, a2)) = (
		tmaux2 (tmaux2 (tymatch, fvmatch) bvmatch 
				(dest_simple_term a1) (dest_simple_term a2))
			bvmatch 
			(dest_simple_term f1) 
			(dest_simple_term f2)
	) | tmaux2 (tymatch, fvmatch) bvmatch (Const(s1,ty1))(Const(s2,ty2)) = (
		if (s1 = s2)
		then (type_unify tymatch ty1 ty2, fvmatch)
		else term_fail "term_unify" 67005 [itm1,itm2]
	) | tmaux2 (tymatch, fvmatch) bvmatch (SimpleÃ(v1,b1))(SimpleÃ(v2,b2)) = (
		
		let	val bvmatch' = (v1, v2) :: bvmatch;
			val tymatch' = type_unify tymatch (type_of v1) (type_of v2);
		in	tmaux2 (tymatch', fvmatch) bvmatch' 
			(dest_simple_term b1) (dest_simple_term b2)
		end
	) | tmaux2 (tymatch, fvmatch) bvmatch stm1 stm2 = (
let
=TEX
Auxiliary functions handling variables:
=SML
	fun tmaux0 (tymatch:(TYPE * TYPE OPT)list, 
			(fvmatch:(TERM * TERM OPT)list))
			bvmatch (tm1:TERM) (v2: TERM) = (
		case rassoc5 bvmatch v2 of
		Nil => (
			if any (frees tm1) (fn x => any bvmatch (fn (x1, _) => (x = x1)))
			then term_fail "term_unify" 67005 [itm1,itm2]

			else case lassoc5 fvmatch v2 of
			Value(Value tm1') => (
				tmaux2 (tymatch, fvmatch) bvmatch 
					(dest_simple_term tm1) 
					(dest_simple_term tm1')
			) | Value Nil => (
				let	val tymatch' =
					type_unify tymatch (type_of tm1) (type_of v2);
					val tm1' = expand_check_term 
					 tymatch fvmatch v2 tm1;
				in	(tymatch', 
					if v2 = tm1'
					then fvmatch
					else fvmatch overwrite 
					(v2, Value tm1'))
				end
			) | Nil => (
			if is_var tm1
			then (case lassoc5 fvmatch tm1 of
			Value(Value tm1') => (
				tmaux2 (tymatch, fvmatch) bvmatch
				(dest_simple_term tm1) 
				(dest_simple_term tm1')
			) | Value Nil => (
				let	val tymatch' =
					type_unify tymatch (type_of tm1) (type_of v2);
				in	(tymatch', fvmatch overwrite (tm1, Value v2))
				end
			) | Nil => (
			let	val (nm1,vty1) = dest_var tm1;
				val (nm2,vty2) = dest_var v2;
			in
				(if nm1 = nm2
				then (type_unify tymatch vty1 vty2, fvmatch)
				else term_fail "term_unify" 67005 [itm1,itm2])
			end
			))
			else term_fail "term_unify" 67005 [itm1,itm2])			
		) |	Value _ => term_fail "term_unify" 67005 [itm1,itm2]
	);
=TEX
=SML
	fun tmaux1 (tymatch, fvmatch) (bvmatch : (TERM * TERM) list) 
			tm1 v2 = (
		if is_var tm1
		then	(case lassoc5 bvmatch tm1 of
				Value v2' => (
					if v2' = v2 andalso rassoc5 bvmatch v2' = Value tm1
					then (tymatch, fvmatch)
					else term_fail "term_unify" 67005 [itm1,itm2]
			) |	Nil => tmaux0 (tymatch, fvmatch) bvmatch tm1 v2
			)
		else 	tmaux0 (tymatch, fvmatch) bvmatch tm1 v2
	);

=TEX
Now the analogues to the above two, except the variable is the first term (done to keep bound variables straight)
=SML
	fun tmaux0' (tymatch:(TYPE * TYPE OPT)list, 
			(fvmatch:(TERM * TERM OPT)list))
			bvmatch (tm2:TERM) (v1: TERM) = (
		case lassoc5 bvmatch v1 of
		Nil => (
			if any (frees tm2) (fn x => any bvmatch (fn (_, x1) => (x = x1)))
			then term_fail "term_unify" 67005 [itm2,itm2]

			else case lassoc5 fvmatch v1 of
			Value(Value tm1') => (
				tmaux2 (tymatch, fvmatch) bvmatch 
				(dest_simple_term tm1')
				(dest_simple_term tm2) 
			) | Value Nil => (
				let	val tymatch' =
					type_unify tymatch (type_of v1) (type_of tm2);
					val tm2' = expand_check_term 
						 tymatch fvmatch v1 tm2;
					in	(tymatch', 
						if v1 = tm2' 
						then fvmatch 
						else fvmatch overwrite 
						(v1, Value tm2'))
					end
			) | Nil => (
			if is_var tm2
			then (case lassoc5 fvmatch tm2 of
			Value(Value tm2') => (
				tmaux2 (tymatch, fvmatch) bvmatch
				(dest_simple_term v1) 
				(dest_simple_term tm2')
			) | Value Nil => (
				let	val tymatch' =
					type_unify tymatch (type_of v1) (type_of tm2);
				in	(tymatch', fvmatch overwrite (tm2, Value v1))
				end
			) | Nil => (
			let	val (nm1,vty1) = dest_var tm2;
				val (nm2,vty2) = dest_var v1;
			in
				(if nm1 = nm2
				then (type_unify tymatch vty1 vty2, fvmatch)
				else term_fail "term_unify" 67005 [itm1,itm2])
			end
			))
			else term_fail "term_unify" 67005 [itm1,itm2])			
		) |	Value _ => term_fail "term_unify" 67005 [itm1,itm2]
	);
=TEX
=SML
	fun tmaux1' (tymatch, fvmatch) (bvmatch : (TERM * TERM) list) 
			tm2 v1 = (
		if is_var tm2
		then	(case rassoc5 bvmatch tm2 of
				Value v1' => (
					if v1' = v1 andalso lassoc5 bvmatch v1' = Value tm2
					then (tymatch, fvmatch)
					else term_fail "term_unify" 67005 [itm1,itm2]
			) |	Nil => tmaux0' (tymatch, fvmatch) bvmatch tm2 v1
			)
		else 	tmaux0' (tymatch, fvmatch) bvmatch tm2 v1
	);

=TEX
Back to the body of tmaux2
=SML
in
		case stm1 of
		(Var v1) =>
		tmaux1' (tymatch, fvmatch) bvmatch (mk_simple_term stm2) (mk_var v1) 
		| _ => case stm2 of
		(Var v2) =>
		tmaux1 (tymatch, fvmatch) bvmatch (mk_simple_term stm1) (mk_var v2)
		| _ => term_fail "term_unify" 67005 [itm1,itm2]
end);
=TEX
=SML
	val (otymatch,ofvmatch) = tmaux2 (itymatch, ifvmatch) [] 
		(dest_simple_term tm1)
		(dest_simple_term tm2);
	fun get_ty_inst trans_mi ty = (
	let	val used_ty = lassoc3 trans_mi ty;
		val sendto = expand_type otymatch used_ty;
	in
		if sendto = ty
		then fail "get_ty_inst" 0 []
		else (sendto, ty)
	end); 
	val omi1 = mapfilter (get_ty_inst trans_mi1) imi1;
	val omi2 = mapfilter (get_ty_inst trans_mi2) imi2;
	fun get_tm_subst trans_ms tm = (
	let	val used_tm = lassoc3 trans_ms tm;
		val sendto = expand_term otymatch ofvmatch used_tm;
	in
		(sendto, tm)
	end); 
	val oms1 = mapfilter (get_tm_subst trans_ms1) ims1;
	val oms2 = mapfilter (get_tm_subst trans_ms2) ims2;
in
	((omi1,oms1),(omi2,oms2))
end);
=IGN
term_unify [] [] ((¨aÆ,[],[]),(¨aÆ,[],[]));
term_unify [] [] ((¨aÆ,[],[]),(¨bÆ,[],[])); (* fails *)
term_unify [] [] ((¨aÆ,[¨aÆ],[]),(¨bÆ,[¨bÆ],[]));
term_unify [] [] ((¨aÆ,[¨aÆ],[]),(¨bÆ,[],[]));
term_unify [] [] ((¨aÆ,[],[]),(¨bÆ,[¨bÆ],[]));
term_unify [] [] ((¨a:'aÆ,[¨a:'aÆ],[¨:'aÆ]),(¨b:'bÆ,[¨b:'bÆ],[¨:'bÆ]));
term_unify [] [] ((¨a:'aÆ,[¨a:'aÆ],[¨:'aÆ]),(¨b:'bÆ,[¨b:'bÆ],[]));
term_unify [] [] ((¨a:'aÆ,[¨a:'aÆ],[]),(¨b:'bÆ,[¨b:'bÆ],[¨:'bÆ]));
term_unify [] [] ((¨f (x (f:'a ≠ 'b):'a)Æ,[¨f:'a ≠ 'bÆ,¨x:('a ≠ 'b) ≠ 'aÆ],[¨:'aÆ,¨:'bÆ]),
	(¨y (g:'a ≠ 'b) g:'bÆ,[¨y:('a ≠ 'b) ≠ ('a ≠ 'b) ≠ 'bÆ,¨g:'a ≠ 'bÆ],[¨:'aÆ,¨:'bÆ]));
term_unify [] [] ((¨R (x:'a) (y:'a):BOOLÆ,[¨x:'aÆ, ¨y:'aÆ, ¨z:'aÆ],[]),(¨R (x:'a) (z:'a):BOOLÆ,[¨x:'aÆ, ¨y:'aÆ, ¨z:'aÆ],[]));
term_unify [] [] ((¨Æ,[],[]),(¨Æ,[],[]));
term_unify [] [] ((¨Æ,[],[]),(¨Æ,[],[]));
term_unify [] [] ((¨Æ,[],[]),(¨Æ,[],[]));

fun free_unify tm1 tm2 = (term_unify [] []
	((tm1,frees tm1,map mk_vartype(term_tyvars tm1)),
	(tm2,frees tm2,map mk_vartype(term_tyvars tm2)))
);
fun setup_unify tm1 tm2 = 
	((tm1,frees tm1,map mk_vartype(term_tyvars tm1)),
	(tm2,frees tm2,map mk_vartype(term_tyvars tm2)));
free_unify ¨f:'a ≠ 'bÆ ¨g:'a ≠ 'bÆ;
free_unify ¨f xÆ ¨g yÆ;
free_unify ¨Ã x ∑ fÆ ¨Ã y ∑ gÆ;
free_unify ¨Ã x ∑ f xÆ ¨Ã y ∑ g yÆ;
free_unify ¨Ã x ∑ f pÆ ¨Ã y ∑ g qÆ;

free_unify ¨f xÆ ¨g (y:'c)Æ;

=TEX
\subsection{Resolution Tools Prooper}
The arguments are:
\begin{enumerate}
\item
The term is a subterm of the theorem argument(5), 
reached through outer universal quantifications and
all propositional connectives.
\item
The bool is false if and only if the subterm occurs ``negatively'' in the conclusion of the theorem.
\item
The term list is the specialisable variables of the subterm.
\item
The type list is the instantiable type variables of the subterm.
\item
The theorem is the source of the fragment.
\item
The next term list is the term variables that may not be used
in unifying the fragment
\item
The next type list is the type variables that may not be used
in unifying the fragment
\end{enumerate}
=SML
type BASIC_RES_TYPE = TERM * bool * TERM list * TYPE list * THM * TERM list * TYPE list;
=TEX
Why isn't this in DTD004???
=SML
fun €strip_pair› (tm:TERM) : TERM list = (
let	val (a,b) = dest_pair tm
in
	strip_pair a @ strip_pair b
end)
handle (Fail _) => [tm];
=TEX
=SML
local
	fun rev_pos (a,t,bd) = (a, not t,bd);
	fun list_is_free_in (inlst:TERM list) (tm:TERM) = (
	let	val fs = frees tm;
	in
		any fs (fn x => x mem inlst)
	end);

	fun aux (pos:bool) (bd:TERM list) (tm:TERM) (D¥(a,b) : DEST_TERM) : (TERM * bool * TERM list) list = (
		aux (not pos) bd a (dest_term a) @ aux pos bd b (dest_term b)
	) | aux pos bd tm DT = if pos then [] else [(mk_t,false,bd)]
	| aux pos bd tm DF = if pos then [(mk_f,true,bd)] else []
	| aux pos bd tm (D≥ a) = aux (not pos) bd a (dest_term a)
	| aux pos bd tm (D±(a,b)) = (
		aux pos bd a (dest_term a) @ aux pos bd b (dest_term b)
	) | aux pos bd tm (D≤(a,b)) = (
		aux pos bd a (dest_term a) @ aux pos bd b (dest_term b)
	) | aux pos bd tm (D§(a,b)) = (
		let 	val a' = aux pos bd a (dest_term a);
			val b' = aux pos bd b (dest_term b);
		in
			a' @ b' @ map rev_pos a' @ map rev_pos b'
		end
	) | aux pos bd tm (Dµ (x,t)) = (
		if list_is_free_in bd tm
		then aux pos (strip_pair x @ bd) t (dest_term t)
		else (tm, pos, bd) :: aux pos (strip_pair x @ bd) t (dest_term t)
	) | aux pos bd tm (D∂ (x,t)) = (
		if list_is_free_in bd tm
		then aux pos (strip_pair x @ bd) t (dest_term t)
		else (tm, pos, bd) :: aux pos (strip_pair x @ bd) t (dest_term t)
	) | aux pos bd tm (D∂â1 (x,t)) = (
		if list_is_free_in bd tm
		then aux pos (strip_pair x @ bd) t (dest_term t)
		else (tm, pos, bd) :: aux pos (strip_pair x @ bd) t (dest_term t)
	) | aux pos bd tm (DIf(cnd,th,el)) = (
	let	val cnd' = aux pos bd cnd (dest_term cnd);
	in
		cnd' @ map rev_pos cnd' @
		aux pos bd th (dest_term th) @
		aux pos bd el (dest_term el)
	end
	) | aux pos bd tm _ = (
		if list_is_free_in bd tm
		then []
		else [(tm, pos, bd)]
	);
in
fun €fragment_term› (tm : TERM) : (TERM * bool * TERM list) list * TERM list = (
let	val (vs,tm') =strip_µ tm;
	val vs' = flat (map strip_pair vs);
in
	(aux true [] tm' (dest_term tm'), vs')
end);
end;
=IGN
fragment_term ¨µ a ∑ a ± ≥ b ¥ (µ e ∑ e ± c) ± f dÆ;
=TEX
Specialise the noted quantified variables in a theorem,
leave the rest specialised to the bound variable
(presumably what the caller intended).
=SML
fun €local_specialise_rule› (subs:(TERM * TERM)list) (thm:THM) : THM = (
let	val thm' = conv_rule (TRY_C all_µ_uncurry_conv) thm;
	val (vs,_) = strip_simple_µ(concl thm');
	val vs' = map (rassoc1 subs) vs;
in
	list_simple_µ_elim vs' thm'
end);
=TEX
This returns $1$ if the conclusion of the first theorem equals
the second's, or is
a less general form than the second
(i.e. could be produced only by specialising the second theorem).
It returns $2$ if the second theorem's conclusion 
is a less general form than the first,
and otherwise returns $0$.

In checking, one must either gain a successful term match 
of the two conclusions, which can be used to generate
the other theorem.
The requirement is that the type instantiation
affects no type variables in the assumptions,
any specialised variable in the second theorem was bound,
and that any variable bound in the first theorem
is not free in the second.

(using inference in a check is crude). 
=SML
fun €basic_res_subsumption› (thm1 : THM) (thm2 :THM) : int = (
let	val (vs1,c1) = strip_µ(concl thm1);
	val (vs2,c2) = strip_µ(concl thm2);
	val vs1' = flat(map strip_pair vs1);
	val vs2' = flat(map strip_pair vs2);
in
(let	val (tym,tvm) = term_match c1 c2;
	val cthm2' = concl(inst_type_rule tym thm2);
	val fthm2' = frees cthm2';
in
	if (map snd tvm) subset (flat(map strip_pair (fst(strip_µ cthm2'))))
		andalso not(any vs1' (fn x => x mem fthm2'))
	then 1
	else fail "" 0 []
end
handle (Fail _) =>
(let	val (tym,tvm) = term_match c2 c1;
	val cthm1' = concl(inst_type_rule tym thm1);
	val fthm1' = frees cthm1';
in
	if (map snd tvm)  subset (flat(map strip_pair (fst(strip_µ cthm1'))))
		andalso not(any vs2' (fn x => x mem fthm1'))
	then 2
	else 0
end
handle (Fail _) => 0))
end);
=IGN
basic_res_subsumption t_thm f_thm;
basic_res_subsumption t_thm t_thm;
basic_res_subsumption ±_thm (all_simple_µ_elim ±_thm);
basic_res_subsumption (all_simple_µ_elim ±_thm) ±_thm ;
let 	val thma = tac_proof(([],¨µ x : 'a ∑ x = xÆ), rewrite_tac[]);
	val thmb = tac_proof(([],¨µ x : BOOL ∑ x = xÆ), rewrite_tac[]);
in
(basic_res_subsumption thma thmb,
basic_res_subsumption thmb thma)
end;
let 	val thma = tac_proof(([],¨µ x : 'a ∑ x = xÆ), rewrite_tac[]);
	val thmb = asm_rule ¨µ x : 'b ∑ x = xÆ;
in
(basic_res_subsumption thma thmb,
basic_res_subsumption thmb thma)
end;
basic_res_subsumption (asm_rule ¨µ x y z∑ R x y ± R y z ¥ R x zÆ)
	(asm_rule ¨µ x y z∑ R x y ± R y z ¥ R x zÆ);

basic_res_subsumption (asm_rule ¨µ x y z∑ R x y ± R y z ¥ R x zÆ)
	(asm_rule ¨µ p q r∑ R p q ± R q r ¥ R p rÆ);


=TEX
=SML
fun €aux_basic_res_pre› ([] : THM list) : BASIC_RES_TYPE list = []
| aux_basic_res_pre (a :: x) = (
let	val (asms,cl) = dest_thm a;
	val ctyvars = term_tyvars cl;
	val atyvars = list_cup (map term_tyvars asms);
	val fvs = list_cup (frees cl :: map frees asms);
	val ityvars = map mk_vartype (ctyvars diff atyvars);
	val (frags,vs) = fragment_term cl;
in
	map (fn (frag,pos,bd) => (frag,pos,vs,ityvars,a,
		bd @ fvs,
		map mk_vartype atyvars)) frags @
	aux_basic_res_pre x
end);

fun €basic_res_pre› (sos:THM list) (rest:THM list) : int * (BASIC_RES_TYPE list * THM list) = (
let	val prest = aux_basic_res_pre rest;
	val psos = aux_basic_res_pre sos;
in
	(length prest + 1,(prest @ psos, rest @ sos))
end);

=TEX
Try an instantiation or substituition, but don't fail.
=SML
fun €try_subst› (ts : (TERM * TERM) list) (tm : TERM): TERM = (
	subst ts tm
	handle complaint =>
	if area_of complaint = "subst"
	then tm
	else reraise complaint (area_of complaint)
);
fun €try_inst› (av:TERM list) (ts : (TYPE * TYPE) list) (tm : TERM): TERM = (
	inst av ts tm
	handle complaint =>
	if area_of complaint = "inst"
	then tm
	else reraise complaint (area_of complaint)
);
=TEX
=SML
fun €thm_frees› (thm :THM) : TERM list = (
let	val (asms,cl) = dest_thm thm;
in
	list_cup (frees cl :: map frees asms)
end);
=TEX
=SML
fun €basic_res_resolver› ((frag1,pos1,vs1,tyvars1,thm1,nsvs1,nivs1):BASIC_RES_TYPE)
	((frag2,pos2,vs2,tyvars2,thm2,nsvs2,nivs2):BASIC_RES_TYPE) : THM list = (
	if pos1 = pos2
	then []
	else ((
	let	val ((ti1,ts1),(ti2,ts2)) = term_unify
		(nivs1 @ nivs2) (nsvs1 @ nsvs2)
		((frag1,vs1,tyvars1),(frag2,vs2,tyvars2));
		val thm1' = local_specialise_rule ts1
			(inst_type_rule ti1 thm1);
		val thm2' = local_specialise_rule ts2
			(inst_type_rule ti2 thm2);
		val subterm = try_subst ts1(try_inst [] ti1 frag1); 
	in
		if pos1
		then [basic_resolve_rule subterm thm1' thm2']
		else [basic_resolve_rule subterm thm2' thm1']
	end)
	handle complaint =>
	if area_of complaint = "term_unify"
	then []
	else reraise complaint (area_of complaint))
);

=TEX
=SML
fun int_max (a:int,b) = if a < b then b else a;
=TEX
=SML
local
fun remove_frags cthm ([]:BASIC_RES_TYPE list) (pfr:BASIC_RES_TYPE list) atind hwm ind = (rev pfr, hwm, ind)
| remove_frags cthm ((frag as (_,_,_,_,thm',_,_)) :: rest) pfr atind hwm ind = (
	if cthm = concl thm'
	then (remove_frags cthm rest pfr (atind+1) 
		(if atind < hwm then (hwm-1) else hwm)
		(if atind <= ind then int_max(ind-1,1) else if atind = hwm then 1 else ind))
	else remove_frags cthm rest (frag :: pfr) (atind+1) hwm ind
);

fun aux thm (frags:BASIC_RES_TYPE list) ([]:THM list) (rest:THM list) (hwm:int) (ind:int) 
	:(BASIC_RES_TYPE list * THM list) * int * int * bool = (
	((frags @ aux_basic_res_pre [thm], (thm :: rest)),hwm,ind,false)
) | aux thm frags (a::x) rest hwm ind = (
	case (basic_res_subsumption thm a) of
	1 => ((frags,rest),hwm,ind,false)
	| 2 => (
	let	val cthm = concl thm;
		val (frags',hwm',ind') = remove_frags cthm frags [] 1 hwm ind
	in
		aux thm frags' x (rest drop (fn athm => concl athm = cthm)) hwm' ind'
	end)
	| _  => aux thm frags x rest hwm ind
);

fun list_aux [] (frags:BASIC_RES_TYPE list) (rest:THM list) (hwm:int) (ind:int) = (
	((frags,rest),hwm,ind,false)
) | list_aux (a::x) frags rest hwm ind = (
let	val ((frags',rest'),hwm',ind',_) = aux a frags rest rest hwm ind
in
	list_aux x frags' rest' hwm' ind'
end);

in
fun €basic_res_post› (subsum:THM -> THM -> int) 
	((res, (frags, before), hwm, ind):THM list * (BASIC_RES_TYPE list * THM list) * int * int)
	: ((BASIC_RES_TYPE list * THM list) * int * int * bool) = (
let	val res' = flat(map strip_±_rule res) drop (fn thm =>
		concl thm = mk_t);
in
	if any res' (fn thm => concl thm = mk_f)
	then ((frags, res' @ before),hwm,ind,true)
	else list_aux res' frags before hwm ind
end);
end;
=TEX
=SML
fun €basic_res_extract› ((_,thml):BASIC_RES_TYPE list * THM list) : THM list = thml;

=TEX
=SML
fun €prim_resolution_rule› (prep : THM list -> THM list -> (int * ('a list * 'b)))
	(reso:'a -> 'a -> THM list)
	(postp:(THM list * ('a list * 'b) * int * int) -> 
		(('a list * 'b) * int * int * bool))
	(extract:'a list * 'b -> THM list)
	(limit : int)
	(sos : THM list)
	(rest : THM list) : THM list = (
let	val (hwm,db) = prep sos rest;
	fun aux hwm ind (db as (dblist, dbdata)) count = (
	let	val ldblist = length dblist;
	in
		if hwm > ldblist
		then extract db
		else if ind > hwm
		then aux (hwm + 1) 1 db count
		else (let
			val hwm_item = nth (hwm-1) dblist;
			val ind_item = nth (ind-1) dblist;
			val res_thms = reso hwm_item ind_item;
			val (db',ind',hwm',halt) = 
				postp (res_thms,db,ind,hwm);
			val count' = count + length res_thms;
		in
			if halt orelse (count' >= limit)
			then extract db' 
			else aux hwm' (ind'+1) db' count'
		end)
	end);
in
	aux hwm 1 db 0
end);
=TEX
=SML
fun €basic_resolution_rule› (limit:int) (sos:THM list) (rest:THM list) : THM list = 
	prim_resolution_rule 
		basic_res_pre
		basic_res_resolver
		(basic_res_post basic_res_subsumption)
		basic_res_extract
		limit
		sos
		rest;
=IGN
val prep = basic_res_pre;
val reso = basic_res_resolver;
val postp = (basic_res_post basic_res_subsumption);
val extract = basic_res_extract;

val limit = 1;
val sos = [(asm_rule ¨(µ x y z ∑ R x y ± R y z ¥ R x z)Æ)];
val rest = [];

=IGN
basic_resolution_rule 10 [] [];

basic_resolution_rule 10 
	[asm_rule ¨a ¥ bÆ, asm_rule ¨a:BOOLÆ] [];

basic_resolution_rule 1
	[
	(asm_rule ¨(µ x y :'a∑ R x y ¥ R y x)Æ)]
	[]; (* no addition *)
basic_resolution_rule 1
	[
	(asm_rule ¨(µ x y z:'a ∑ R x y ± R y z ¥ R x z)Æ)]
	[];
basic_resolution_rule 1
	[
	(asm_rule ¨(µ x y z :'a∑ R x y ± R y z ¥ R x z)Æ),
	(asm_rule ¨(µ x y :'a∑ R x y ¥ R y x)Æ)]
	[];
basic_resolution_rule 10 
	[
	(asm_rule ¨(µ x y z :'a∑ R x y ± R y z ¥ R x z)Æ),
	(asm_rule ¨(µ x y:'a ∑ R x y ¥ R y x)Æ),
	(asm_rule ¨µ x :'a∑ R x (f x:'a)Æ),
	(asm_rule ¨(≥ R (x:'a) x)Æ)]
	[];
basic_resolution_rule 100
	[
	(asm_rule ¨(µ x y z:'a ∑ R x y ± R y z ¥ R x z)Æ),
	(asm_rule ¨(µ x y:'a ∑ R x y ¥ R y x)Æ),
	(asm_rule ¨µ x :'a∑ R x (f x:'a)Æ),
	(asm_rule ¨(≥ R (x:'a) x)Æ)]
	[];
basic_resolution_rule 10
	[(asm_rule ¨(≥ R (x:'a) x)Æ)]
	[(asm_rule ¨(µ x y z:'a ∑ R x y ± R y z ¥ R x z)Æ),
	(asm_rule ¨(µ x y :'a∑ R x y ¥ R y x)Æ),
	(asm_rule ¨µ x :'a∑ R x (f x:'a)Æ)];
basic_resolution_rule 10
	[(asm_rule ¨(µ x y :'a ∑ R x y ¥ R y x)Æ),
	(asm_rule ¨µ x :'a∑ R x (f x:'a)Æ)] [] ;

basic_resolution_rule 100
	[(asm_rule ¨(≥ R (x:'a) x)Æ)]
	[(asm_rule ¨(µ x y z:'a ∑ R x y ± R y z ¥ R x z)Æ),
	(asm_rule ¨(µ x y:'a ∑ R x y ¥ R y x)Æ),
	(asm_rule ¨µ x :'a∑ R x (f x:'a)Æ)];
basic_resolution_rule 5
	[(asm_rule ¨µ a b ∑ r a ¥ r a ≤ r b ≤ r aÆ)]
	[];

basic_resolution_rule 10
	[(asm_rule ¨µ x ∑ p (f x) ± ≥ p xÆ)]
	[];
(* Moore's three blocks problem *)
basic_resolution_rule 200 (* 100 is not enough *)
	[
	(asm_rule ¨on(A:'box,B:'box):BOOLÆ),
	(asm_rule ¨on(B:'box,C:'box):BOOLÆ),
	(asm_rule ¨green(A:'box):BOOLÆ),
	(asm_rule ¨≥ green(C:'box)Æ),
	(asm_rule ¨µ x y:'box∑ (green x ± on(x,y)) ¥ green yÆ)
	]
	[];
basic_resolution_rule 10
	[
	(asm_rule ¨Æ),
	]
	[];

=TEX
=IGN
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",true);
=TEX
\section{EPILOGUE}
=IGN
val _ = open_theory lthy;
val _ = pop_proof_context();
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",
	lsubgoal_package_quiet);
end; (* of structure Resolution *)
open ExistenceProofs;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

=IGN


push_goal([],¨(µ x y z ∑ R x y ± R y z ¥ R x z) ±
 (µ x y ∑ R x y ¥ R y x) ±
 (µ x ∑ ∂ y ∑ R x y) ¥
 (µ x ∑ R x x)Æ);
 a(c_contr_tac);
a(list_spec_nth_asm_tac 3 [¨xÆ,¨xÆ]); (* useless *)

(* comparing 2 vs 3 suggests need preprocessing, or embedded
   skolemisation *)

push_goal([],¨(µ x y z ∑ R x y ± R y z ¥ R x z) ±
 (µ x y ∑ R x y ¥ R y x) ±
 (∂ f ∑ µ x :'a∑ R x (f x:'a)) ¥
 (µ x ∑ R x x)Æ);
 a(c_contr_tac);
a(list_spec_nth_asm_tac 3 [¨xÆ,¨xÆ]); (* useless *)
a(list_spec_asm_tac ¨µ x y∑ R x y ¥ R y xÆ [¨x'Æ,¨f x'Æ]);
(* *** Goal "1" *** *)
a(spec_asm_tac ¨µ x∑ R x (f x)Æ ¨x'Æ);


(* *** Goal "2" *** *)
a(spec_asm_tac ¨µ x∑ R x (f x)Æ ¨x'Æ);
a(list_spec_asm_tac ¨µ x y∑ R x y ¥ R y xÆ [¨x''Æ,¨x''Æ]);
(* *** Goal "2.1" *** *)
a(list_spec_asm_tac ¨µ x y z∑ R x y ± R y z ¥ R x zÆ [¨xÆ,¨y''Æ,¨xÆ]);

(* *** Goal "2.1.1" *** *)
a(list_spec_asm_tac ¨µ x y z∑ R x y ± R y z ¥ R x zÆ [¨x'''Æ,¨y'''Æ,¨f x'''Æ]);
(* *** Goal "2.1.1.1" *** *)
a(spec_asm_tac  ¨µ x∑ R x (f x)Æ ¨x'''Æ);
a(list_spec_asm_tac ¨µ x y z∑ R x y ± R y z ¥ R x zÆ [¨x''''Æ,¨x'''''Æ,¨f x'''''Æ]);
(* *** Goal "2.1.1.1.1" *** *)
a(spec_asm_tac  ¨µ x∑ R x (f x)Æ ¨x'''''Æ);


a(basic_resolve_tac ¨Æ 
	(¨Æ,[])
	(¨Æ,[]));

push_goal([],¨(µ x y z ∑ R x y ± R y z ¥ R x z) ±
 (µ x y ∑ R x y ¥ R y x) ±
 (∂ f ∑ µ x :'a∑ R x (f x:'a)) ¥
 (µ x ∑ R x x)Æ);
a(c_contr_tac);
a(basic_resolve_tac ¨R x xÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨xÆ,¨xÆ])
	(¨≥ R x xÆ,[])); 
a(basic_resolve_tac ¨R x' (f x')Æ 
	(¨µ x∑ R x (f x)Æ,[¨x'Æ])
	(¨µ x y∑ R x y ¥ R y xÆ,[¨x'Æ,¨f x'Æ]));
a(basic_resolve_tac ¨R x' x'Æ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨x'Æ,¨x'Æ])
	(¨µ x y∑ R x y ¥ R y xÆ,[¨x'Æ,¨x'Æ]));
a(basic_resolve_tac ¨R x xÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨xÆ,¨yÆ,¨xÆ])
	(¨≥ R x xÆ,[]));
a(basic_resolve_tac ¨R x' (f x')Æ 
	(¨µ x∑ R x (f x)Æ,[¨x'Æ])
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨x'Æ,¨f x'Æ,¨zÆ]));
a(basic_resolve_tac ¨R x' (f x')Æ 
	(¨µ x∑ R x (f x)Æ,[¨x'Æ])
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨zÆ,¨x'Æ,¨f x'Æ]));
a(basic_resolve_tac ¨R y x'Æ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨x'Æ,¨yÆ])
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨yÆ,¨x'Æ,¨zÆ]));
	(* best to do all specialisation *)
a(basic_resolve_tac ¨R y x'Æ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨x'Æ,¨yÆ])
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨zÆ,¨yÆ,¨x'Æ]));
a(basic_resolve_tac ¨R x' zÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨x'Æ,¨yÆ,¨zÆ])
	(¨µ x y∑ R x y ¥ R y xÆ,[¨zÆ,¨x'Æ]));
a(basic_resolve_tac ¨R x' yÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨x'Æ,¨yÆ,¨zÆ])
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨x'Æ,¨zÆ,¨yÆ]));
a(basic_resolve_tac ¨R y zÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨x'Æ,¨yÆ,¨zÆ])
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨yÆ,¨x'Æ,¨zÆ]));
a(basic_resolve_tac ¨R (f x') x'Æ 
	(¨µ x'∑ R (f x') x'Æ,[¨x'Æ])
	(¨µ x y∑ R x y ¥ R y xÆ,[¨f x'Æ, ¨x'Æ]));
a(basic_resolve_tac ¨R (f x') x'Æ 
	(¨µ x'∑ R (f x') x'Æ,[¨x'Æ])
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨f x'Æ,¨x'Æ,¨zÆ]));
a(basic_resolve_tac ¨R (f x') x'Æ 
	(¨µ x'∑ R (f x') x'Æ,[¨x'Æ])
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨zÆ,¨f x'Æ,¨x'Æ]));
a(basic_resolve_tac ¨R x (f x)Æ 
	(¨µ x∑ R x (f x)Æ,[¨xÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨f xÆ]));
a(basic_resolve_tac ¨R x yÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨yÆ,¨xÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨yÆ]));
a(basic_resolve_tac ¨R x yÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨xÆ,¨zÆ,¨yÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨yÆ]));
a(basic_resolve_tac ¨R y xÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨yÆ,¨zÆ,¨xÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨yÆ]));

a(basic_resolve_tac ¨R (f x) xÆ 
	(¨µ x'∑ R (f x') x'Æ,[¨xÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨f xÆ]));
a(basic_resolve_tac ¨R x xÆ 
	(¨µ x' z∑ R (f x') z ¥ R x' zÆ,[¨xÆ,¨xÆ])
	(¨≥ R x xÆ,[]));
a(basic_resolve_tac ¨R(f x') (f(f x'))Æ 
	(¨µ x∑ R x (f x)Æ,[¨f x'Æ])
	(¨µ x' z∑ R (f x') z ¥ R x' zÆ,[¨x'Æ,¨f(f x')Æ]));
a(basic_resolve_tac ¨R(f x') zÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨zÆ,¨f x'Æ])
	(¨µ x' z∑ R (f x') z ¥ R x' zÆ,[¨x'Æ,¨zÆ]));
a(basic_resolve_tac ¨R x' zÆ 
	(¨µ x' z∑ R (f x') z ¥ R x' zÆ,[¨x'Æ,¨zÆ])
	(¨µ x y∑ R x y ¥ R y xÆ,[¨x'Æ,¨zÆ]));
a(basic_resolve_tac ¨R(f x') zÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨f x'Æ,¨yÆ,¨zÆ])
	(¨µ x' z∑ R (f x') z ¥ R x' zÆ,[¨x'Æ,¨zÆ]));
a(basic_resolve_tac ¨R (f x') x'Æ 
	(¨µ x'∑ R (f x') x'Æ,[¨x'Æ])
	(¨µ x' z∑ R (f x') z ¥ R x' zÆ,[¨x'Æ,¨x'Æ]));
a(basic_resolve_tac ¨R x yÆ 
	(¨µ x' z∑ R (f x') z ¥ R x' zÆ,[¨xÆ,¨yÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨yÆ]));
a(basic_resolve_tac ¨R y xÆ 
	(¨µ x' z∑ R (f x') z ¥ R x' zÆ,[¨yÆ,¨xÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨yÆ]));
a(basic_resolve_tac ¨R x' (f x')Æ 
	(¨µ x∑ R x (f x)Æ,[¨x'Æ])
	(¨µ z x'∑ R z x' ¥ R z (f x')Æ,[¨x'Æ,¨f x'Æ]));
a(basic_resolve_tac ¨R y x'Æ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨x'Æ,¨yÆ])
	(¨µ z x'∑ R z x' ¥ R z (f x')Æ,[¨yÆ,¨x'Æ]));
a(basic_resolve_tac ¨R z (f x')Æ 
	(¨µ z x'∑ R z x' ¥ R z (f x')Æ,[¨zÆ,¨x'Æ])
	(¨µ x y∑ R x y ¥ R y xÆ,[¨zÆ,¨(f x')Æ]));

etc until

a(basic_resolve_tac ¨R (f x) xÆ 
	(¨µ x'∑ R (f x') x'Æ,[¨xÆ])
	(¨≥ R (f x) xÆ,[]));
pop_thm();

(* set of support just being  ¨≥ R x xÆ *)
push_goal([],¨(µ x y z ∑ R x y ± R y z ¥ R x z) ±
 (µ x y ∑ R x y ¥ R y x) ±
 (∂ f ∑ µ x :'a∑ R x (f x:'a)) ¥
 (µ x ∑ R x x)Æ);
a(c_contr_tac);
a(basic_resolve_tac ¨R x xÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨xÆ,¨xÆ])
	(¨≥ R x xÆ,[])); 
a(basic_resolve_tac ¨R x xÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨xÆ,¨yÆ,¨xÆ])
	(¨≥ R x xÆ,[]));
a(basic_resolve_tac ¨R x (f x)Æ 
	(¨µ x∑ R x (f x)Æ,[¨xÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨f xÆ]));

a(basic_resolve_tac ¨R x yÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨yÆ,¨xÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨yÆ]));
a(basic_resolve_tac ¨R x yÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨xÆ,¨zÆ,¨yÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨yÆ]));
a(basic_resolve_tac ¨R y xÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨yÆ,¨zÆ,¨xÆ])
	(¨µ y∑ ≥ (R x y ± R y x)Æ,[¨yÆ]));
a(basic_resolve_tac ¨R (f x) xÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨xÆ,¨f xÆ])
	(¨≥ R (f x) xÆ,[]));
a(basic_resolve_tac ¨R (f x) xÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨f xÆ,¨yÆ,¨xÆ])
	(¨≥ R (f x) xÆ,[]));
a(basic_resolve_tac ¨R y xÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨xÆ,¨yÆ])
	(¨µ y∑ ≥ R y xÆ,[¨yÆ]));
a(basic_resolve_tac ¨R y xÆ 
	(¨µ x y z∑ R x y ± R y z ¥ R x zÆ,[¨yÆ,¨zÆ,¨xÆ])
	(¨µ y∑ ≥ R y xÆ,[¨yÆ]));
a(basic_resolve_tac ¨R x (f x)Æ 
	(¨µ x∑ R x (f x)Æ,[¨xÆ])
	(¨µ z y∑ ≥ (R x z ± R z y) ≤ ≥ R y xÆ,[¨f xÆ,¨yÆ]));
a(basic_resolve_tac ¨R z (f z)Æ 
	(¨µ x∑ R x (f x)Æ,[¨zÆ])
	(¨µ z y∑ ≥ (R x z ± R z y) ≤ ≥ R y xÆ,[¨zÆ,¨f zÆ]));
a(basic_resolve_tac ¨R x zÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨zÆ,¨xÆ])
	(¨µ z y∑ ≥ (R x z ± R z y) ≤ ≥ R y xÆ,[¨zÆ,¨yÆ]));
a(basic_resolve_tac ¨R z yÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨zÆ,¨yÆ])
	(¨µ z y∑ ≥ (R x z ± R z y) ≤ ≥ R y xÆ,[¨zÆ,¨yÆ]));
a(basic_resolve_tac ¨R y xÆ 
	(¨µ x y∑ R x y ¥ R y xÆ,[¨yÆ,¨xÆ])
	(¨µ z y∑ ≥ (R x z ± R z y) ≤ ≥ R y xÆ,[¨zÆ,¨yÆ]));



a(basic_resolve_tac ¨Æ 
	(¨Æ,[])
	(¨Æ,[]));
a(basic_resolve_tac ¨Æ 
	(¨Æ,[])
	(¨Æ,[]));





