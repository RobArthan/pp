=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Module Tests for Tactics III}
\TPPref{DS/FMU/IED/MDT029}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{R.D.~Arthan & WIN01 \\ K.~Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the module tests for the 
third group of tactics and tacticals in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Modified $spec\_asm\_tac$ tests, et al.
\item [Issue 1.3]
Changes to match issue 1.5 of \cite{DS/FMU/IED/DTD029}.

\item[Issue 1.4, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.5]
Removed duplicate labels.
\item [Issue 1.6]
Test $sets\_epc$.
\item [Issue 1.7]
Changed working theory
\item [Issue 1.8,1.9 (11th March 1992)]
Various minor additions and extensions.
\item [Issue 1.10]
Removed percent keywords.
\item [Issue 1.11 (26th March 1992)]
Changed to use proof context material of issue 1.13 of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.12 (31st March 1992)]
Added understanding of double negation
to $³\-\_rewrite\-\_canon$.
\item [Issue 1.13 (9th April 1992)]
Changes required by CR0016.
\item [Issue 1.14 (14th April 1992)]
Changes required by CR0017.
\item [Issue 1.15 (14th May 1992)]
Tidying up proof contexts.
\item [Issue 1.16 (20th May 1992)]
Rearranging build proof contexts.
\end{description}
\subsection{Changes Forecast}
Completion of coverage.
\section{GENERAL}
\subsection{Scope}
This document contains the module tests for the material
whose detailed design is given in in \cite{DS/FMU/IED/DTD029}.
\subsection{Introduction}
We are pretty cursory in the following, doing little more than just demonstrating
the tactics presence and error message origin.
\subsubsection{Dependencies}
The tests depend upon \cite{DS/FMU/IED/IMP013}, the test harness.
In addition, testing by the subgoal package
depends on \cite{DS/FMU/IED/IMP030}.

\subsubsection{Deficiencies}
The testing could be more rigorous.
\section{TEST CASES}
We test each function of the signature of \cite{DS/FMU/IED/DTD029}
in turn, where possible in the same order as in the design document.
\section{PREAMBLE}
=SML
open_theory"basic_hol";
use_file "dtd013";
use_file "imp013";
init_mt_results();
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",true);
repeat drop_main_goal;
push_merge_pcs ["propositions","paired_abstractions"];
=TEX
=SML
fun list_eq (eq:'a * 'a -> bool) ((a :: x), (b :: y)) : bool = (
	eq(a,b) andalso list_eq eq (x, y)
) | list_eq eq ([], []) = true
| list_eq _ _ = false;
=TEX
\section{TESTS}
\subsection{Testing Using Subgoal Package}
The following functions apply a tactic to a selected goal
and returns the resulting top goal. 
This of course doesn't fully test tactics that return multiple
goals.
The functions differ in that $tac\_res1$ inputs and outputs
both assumptions and conclusion, while $tac\_res$
just assumes an empty assumption list.
=SML
fun Ûtac_resÝ tac goal = (push_goal([],goal);
		a tac;
		let val (seqasms,gl) = top_goal()
		in
			(drop_main_goal();
			gl)
		end);
fun Ûtac_res1Ý tac (seqasms, goal) = (
		push_goal(seqasms,goal);
		a tac;
		let val (seqasms,gl) = top_goal()
		in
			(drop_main_goal();
			(seqasms,gl))
		end);
=TEX
This function tests that a tactic proves a goal:
=SML
fun Ûtac_solveÝ tac (seqasms, goal) = (
	dest_thm (tac_proof ((seqasms,goal),tac))
	=#
	(seqasms, goal)
);
=TEX
This function tests that a tactic fails on a goal:
=SML
fun Ûtac_failÝ tac (seqasms, goal) = (
	push_goal(seqasms,goal);
	a tac
	handle complaint =>
	(drop_main_goal();
	reraise complaint (area_of complaint))
);
=TEX
=SML

=TEX
\section{THE TESTS}
\subsection{Concerning Tautologies}
=SML
store_mt_results mt_run [
	("taut_tac 1",
	tac_solve taut_tac,
	([],¬T®),
	true),
	("taut_tac 2",
	tac_solve taut_tac,
	([],¬(a ± b) ¤ (b ± a)®),
	true),
	("taut_tac 3",
	tac_solve taut_tac,
	([],¬a ² ³ a®),
	true),
	("taut_tac 4",
	tac_solve taut_tac,
	([],¬(if a then p else ³ p) ´ (³ p ´ ³ a)®),
	true),
	("taut_tac 5",
	tac_solve taut_tac,
	([],¬³³³ F®),
	true)
];
store_mt_results mt_run [
	("taut_tac 6",
	tac_solve taut_tac,
	([],¬µ x y · T®),
	true),
	("taut_tac 7",
	tac_solve taut_tac,
	([],¬µ (a,b) · (a ± b) ¤ (b ± a)®),
	true),
	("taut_tac 8",
	tac_solve taut_tac,
	([],¬µ c · a ² ³ a®),
	true),
	("taut_tac 9",
	tac_solve taut_tac,
	([],¬µ p · (if a then p else ³ p) ´ (³ p ´ ³ a)®),
	true),
	("taut_tac 10",
	tac_solve taut_tac,
	([],¬µ z · ³³³ F®),
	true)
];
store_mt_results mt_run_fail [("taut_tac 29020 1",
	tac_fail taut_tac,
	([],¬F®),
	gen_fail_msg "taut_tac" 29020 []),
	("taut_tac 29020 2",
	tac_fail taut_tac,
	([],¬1 = 1®),
	gen_fail_msg "taut_tac" 29020 [])
	];

store_mt_results mt_run_fail [("taut_tac 29020 3",
	taut_tac,
	([],¬a:'a®),
	gen_fail_msg "taut_tac" 29020 [])];
=TEX
=SML
store_mt_results (mt_runf (op =#)) [("taut_rule",
	dest_thm o taut_rule,
	¬µ a e · (a ± b ± c ± d ´ e) ¤ (a ´ b ´ c ´ d ´ e)®,
	([],¬µ a e · (a ± b ± c ± d ´ e) ¤ (a ´ b ´ c ´ d ´ e)®))];
store_mt_results mt_run_fail [("taut_rule 27037",
	taut_rule,
	¬F®,
	gen_fail_msg "taut_rule" 27037 ["¬F®"]),
	("taut_rule 27030",
	taut_rule,
	¬1®,
	gen_fail_msg "taut_rule" 27037 ["¬1®"])];
=TEX
=SML
store_mt_results (mt_runf (op =#)) [("taut_conv",
	dest_thm o taut_conv,
	¬µ a e · (a ± b ± c ± d ´ e) ¤ (a ´ b ´ c ´ d ´ e)®,
	([],¬(µ a e · (a ± b ± c ± d ´ e) ¤ (a ´ b ´ c ´ d ´ e)) ¤ T®))];
store_mt_results mt_run_fail [("taut_conv 27037 a",
	taut_conv,
	¬F®,
	gen_fail_msg "taut_conv" 27037 ["¬F®"]),
	("taut_conv 27037 b",
	taut_conv,
	¬1®,
	gen_fail_msg "taut_conv" 27037 ["¬1®"])];
=TEX
\subsection{Concerning ³}
=SML
store_mt_results (mt_runf (op =$)) [
	("³_in_tac 1",
	tac_res ³_in_tac,
	¬³(³ F)®,
	¬F®),
	("³_in_tac 2",
	tac_res ³_in_tac,
	¬³(a ± b)®,
	¬³ a ² ³ b®),
	("³_in_tac 3",
	tac_res ³_in_tac,
	¬³(a ² b)®,
	¬³ a ± ³ b®),
	("³_in_tac 4",
	tac_res ³_in_tac,
	¬³(a ´ b)®,
	¬a ± ³ b®),
	("³_in_tac 5",
	tac_res ³_in_tac,
	¬³(a ¤ b)®,
	¬(a ± ³b) ² (b ± ³a)®),
	("³_in_tac 6",
	tac_res ³_in_tac,
	¬³(µ x ·f x)®,
	¬¶ x ·³ f x®),
	("³_in_tac 7",
	tac_res ³_in_tac,
	¬³(µ (x,y) · f x y)®,
	¬¶ (x,y) · ³ f x y®),
	("³_in_tac 8",
	tac_res ³_in_tac,
	¬³(¶ x ·f x)®,
	¬µ x ·³ f x®),
	("³_in_tac 9",
	tac_res ³_in_tac,
	¬³(¶ (x,y) · f x y)®,
	¬µ (x,y) · ³ f x y®),
	("³_in_tac 10",
	tac_res ³_in_tac,
	¬³(¶‰1 x ·f x)®,
	¬µ x ·³ (f x ± µ x' ·f x' ´ x' = x)®),
	("³_in_tac 11",
	tac_res ³_in_tac,
	¬³(¶‰1 (x,y) · f x y)®,
	¬µ (x,y) · ³ (f x y ± µ (x',y') ·f x' y' ´ (x',y') = (x,y))®),
	("³_in_tac 12",
	tac_res ³_in_tac,
	¬³ T®,
	¬F®)];
store_mt_results mt_run [
	("³_in_tac 13",
	tac_solve ³_in_tac,
	([],¬³F®),
	true)];
store_mt_results mt_run_fail [("³_in_tac 28025",
	tac_fail ³_in_tac,
	([],¬T®),
	gen_fail_msg "³_in_tac" 28025 [])];
=TEX
As $³\_IN\_THEN$ is based on the same conversion as the above,
we just test one case.
=SML
store_mt_results (mt_runf (op =$)) [("³_IN_THEN",
	tac_res (³_IN_THEN ante_tac f_thm),
	¬T®,
	¬T ´ T®)];
store_mt_results mt_run_fail [("³_IN_THEN 29010",
	³_IN_THEN asm_tac,
	t_thm,
	gen_fail_msg "³_IN_THEN" 29010 ["ô T"])];
=TEX
\subsection{Concerning µ}
=SML
store_mt_results (mt_runf (op =$)) [("µ_tac 1",
	tac_res µ_tac,
	¬µ x · f x®,
	¬f x : BOOL®),
	("µ_tac 2",
	tac_res µ_tac,
	¬µ (x,y,z) · f x y z®,
	¬f x y z: BOOL®)];
store_mt_results mt_run_fail [("µ_tac 29001",
	tac_fail µ_tac,
	([],¬T®),
	gen_fail_msg "µ_tac" 29001 [])];
=TEX
\subsection{Concerning ¶}
=SML
store_mt_results (mt_runf (op =$)) [("¶_tac 1",
	tac_res (¶_tac ¬1®),
	¬¶ x · x = 1®,
	¬1 = 1®),
	("¶_tac 2",
	tac_res (¶_tac ¬(1,2)®),
	¬¶ (x,y):î ¸ î · ³(x = y)®,
	¬³(1 = 2)®),
	("¶_tac 3",
	tac_res (¶_tac ¬x:'a®),
	¬¶  y : î · y = y®,
	¬(x:î) = x®),
	("¶_tac 4",
	tac_res (¶_tac ¬x:'a®),
	¬¶ (x,y): 'a ¸ 'a · x = y®,
	¬Fst (x: 'a ¸ 'a) = Snd x®)];
store_mt_results mt_run_fail [("¶_tac 29002",
	tac_fail (¶_tac mk_t),
	([],¬a ² b®),
	gen_fail_msg "¶_tac" 29002 []),
	("¶_tac 29008",
	tac_fail (¶_tac ¬(1,2)®),
	([],¬¶ a · a ² b®),
	gen_fail_msg "¶_tac" 29008 ["¬(1, 2)®","¬a®"])];
=TEX
=SML
store_mt_results (mt_runf (op =#))[("¶_THEN",
	tac_res1 (¶_THEN ante_tac (asm_rule ¬¶ (x,y) · x = y®)),
	([],¬x:BOOL®),
	([],¬(x' = y) ´ x®))];
store_mt_results mt_run_fail [("¶_THEN 29003",
	¶_THEN ante_tac,
	t_thm,
	gen_fail_msg "¶_THEN" 29003 ["ô T"])];
=TEX
\subsection{Concerning ¶$_1$}
=SML
store_mt_results (mt_runf (op =$))[("¶‰1_tac 1",
	tac_res (¶‰1_tac ¬2®),
	¬¶‰1 x · x = 1®,
	¬2 = 1 ± µ x' · x' = 1 ´ x' = 2®),
	("¶‰1_tac 2",
	tac_res (¶‰1_tac ¬(1,2)®),
	¬¶‰1 (x:î,y) · ³(x = y)®,
	¬³(1 = 2) ± µ (x',y') · ³(x' = y') ´ (x',y') = (1,2)®),
	("¶‰1_tac 3",
	tac_res (¶‰1_tac ¬x:'a®),
	¬¶‰1 y : î · y = y®,
	¬((x:î) = x) ± µ y' · (y' = y') ´ y' = x®),
	("¶‰1_tac 4",
	tac_res (¶‰1_tac ¬x:'a®),
	¬¶‰1 (x,y): 'a ¸ 'a · x = y®,
	¬Fst (x: 'a ¸ 'a) = Snd x ± µ (x',y') · (x' = y') ´ (x',y') = (Fst x, Snd x)®)];
store_mt_results mt_run_fail [("¶‰1_tac 29004",
	tac_fail (¶‰1_tac mk_t),
	([],¬a ² b®),
	gen_fail_msg "¶‰1_tac" 29004 []),
	("¶‰1_tac 29008",
	tac_fail (¶‰1_tac ¬(1,2)®),
	([],¬¶‰1 a · a ² b®),
	gen_fail_msg "¶‰1_tac" 29008 ["¬(1, 2)®","¬a®"])];
=TEX
=SML
store_mt_results (mt_runf (op =#))[("¶‰1_THEN",
	tac_res1 (¶‰1_THEN ante_tac (asm_rule ¬¶‰1 (x,y) · x = y®)),
	([],¬x:BOOL®),
	([],¬((x' = y) ± 
		(µ (x'',y') · (x'' = y') ´ (x'',y') = (x',y)))´ x®))];
store_mt_results mt_run_fail [("¶‰1_THEN 29005",
	¶‰1_THEN ante_tac,
	t_thm,
	gen_fail_msg "¶‰1_THEN" 29005 ["ô T"])];
=TEX
\subsection{Concerning Assumptions}
=SML
store_mt_results (mt_runf (op =#))[("spec_asm_tac",
	tac_res1 (spec_asm_tac ¬µ x · x = 1® ¬0®),
	([¬µ x · x = 1®],¬F®),
	([¬0 = 1®,¬µ x · x = 1®],¬F®))];
store_mt_results (mt_runf (op =#))[("list_spec_asm_tac",
	tac_res1 (list_spec_asm_tac ¬µ x y:î · x = y® [¬0®,¬1®]),
	([¬µ x y:î · x = y®],¬F®),
	([¬0 = 1®,¬µ x y:î · x = y®],¬F®))];
store_mt_results (mt_runf (op =#))[("spec_nth_asm_tac",
	tac_res1 (spec_nth_asm_tac 1 ¬0®),
	([¬µ x · x = 1®],¬F®),
	([¬0 = 1®,¬µ x · x = 1®],¬F®))];
store_mt_results (mt_runf (op =#))[("list_spec_nth_asm_tac",
	tac_res1 (list_spec_nth_asm_tac 1 [¬0®,¬1®]),
	([¬µ x y :î· x = y®],¬F®),
	([¬0 = 1®,¬µ x y :î· x = y®],¬F®))];
=TEX
We only give one example kind of passed-on error for each function.
=SML
store_mt_results mt_run_fail [("spec_asm_tac 9301",
	tac_fail (spec_asm_tac ¬µ x · x = 1® ¬0®),
	([],¬F®),
	gen_fail_msg "GET_ASM_T" 9301 ["¬µ x· x = 1®"])];
store_mt_results mt_run_fail [("list_spec_asm_tac 9301",
	tac_fail (list_spec_asm_tac ¬µ x y · x = y® [¬0®,¬1®]),
	([],¬F®),
	gen_fail_msg "GET_ASM_T" 9301 ["¬µ x y· x = y®"])];
store_mt_results mt_run_fail [("spec_nth_asm_tac 9303",
	tac_fail (spec_nth_asm_tac 2 ¬0®),
	([¬µ x · x = 1®],¬F®),
	gen_fail_msg "GET_NTH_ASM_T" 9303 ["2"])];
store_mt_results mt_run_fail [("list_spec_nth_asm_tac 9303",
	tac_fail (list_spec_nth_asm_tac 2 [¬0®,¬1®]),
	([¬µ x y · x = y®],¬F®),
	gen_fail_msg "GET_NTH_ASM_T" 9303 ["2"])];
=TEX
=SML
fun Ûlspec_asm_tacÝ (asm : TERM) (instance : TERM)  :TACTIC = (
	SPEC_ASM_T asm instance strip_asm_tac
);
fun Ûllist_spec_asm_tacÝ (asm : TERM) (instances : TERM list)  :TACTIC = (
	LIST_SPEC_ASM_T asm instances strip_asm_tac
);
fun Ûlspec_nth_asm_tacÝ (n : int) (instance : TERM)  :TACTIC = (
	SPEC_NTH_ASM_T n instance strip_asm_tac
);
fun Ûllist_spec_nth_asm_tacÝ (n : int) (instances : TERM list)  :TACTIC = (
	LIST_SPEC_NTH_ASM_T n instances strip_asm_tac
);

=TEX
=SML
store_mt_results (mt_runf (op =#))[("lspec_asm_tac",
	tac_res1 (lspec_asm_tac ¬µ x · x = 1® ¬0®),
	([¬µ x · x = 1®],¬F®),
	([¬0 = 1®,¬µ x · x = 1®],¬F®))];
store_mt_results (mt_runf (op =#))[("llist_spec_asm_tac",
	tac_res1 (llist_spec_asm_tac ¬µ x y:î · x = y® [¬0®,¬1®]),
	([¬µ x y:î · x = y®],¬F®),
	([¬0 = 1®,¬µ x y:î · x = y®],¬F®))];
store_mt_results (mt_runf (op =#))[("lspec_nth_asm_tac",
	tac_res1 (lspec_nth_asm_tac 1 ¬0®),
	([¬µ x · x = 1®],¬F®),
	([¬0 = 1®,¬µ x · x = 1®],¬F®))];
store_mt_results (mt_runf (op =#))[("llist_spec_nth_asm_tac",
	tac_res1 (llist_spec_nth_asm_tac 1 [¬0®,¬1®]),
	([¬µ x y :î· x = y®],¬F®),
	([¬0 = 1®,¬µ x y :î· x = y®],¬F®))];
=TEX
We only give one example kind of passed-on error for each function.
=SML
store_mt_results mt_run_fail [("lspec_asm_tac 9301",
	tac_fail (spec_asm_tac ¬µ x · x = 1® ¬0®),
	([],¬F®),
	gen_fail_msg "GET_ASM_T" 9301 ["¬µ x· x = 1®"])];
store_mt_results mt_run_fail [("llist_spec_asm_tac 9301",
	tac_fail (list_spec_asm_tac ¬µ x y · x = y® [¬0®,¬1®]),
	([],¬F®),
	gen_fail_msg "GET_ASM_T" 9301 ["¬µ x y· x = y®"])];
store_mt_results mt_run_fail [("lspec_nth_asm_tac 9303",
	tac_fail (lspec_nth_asm_tac 2 ¬0®),
	([¬µ x · x = 1®],¬F®),
	gen_fail_msg "GET_NTH_ASM_T" 9303 ["2"])];
store_mt_results mt_run_fail [("llist_spec_nth_asm_tac 9303",
	tac_fail (llist_spec_nth_asm_tac 2 [¬0®,¬1®]),
	([¬µ x y · x = y®],¬F®),
	gen_fail_msg "GET_NTH_ASM_T" 9303 ["2"])];
=TEX

\section{CONVERSIONS}
=SML
store_mt_results (mt_runf (op =$))[
	("³_in_conv 1",
	snd o dest_eq o concl o ³_in_conv,
	¬³³ T®,
	¬T®),
	("³_in_conv 2",
	snd o dest_eq o concl o ³_in_conv,
	¬³(b ± a)®,
	¬³ b ² ³ a®),
	("³_in_conv 3",
	snd o dest_eq o concl o ³_in_conv,
	¬³(b ² a)®,
	¬³ b ± ³ a®),
	("³_in_conv 4",
	snd o dest_eq o concl o ³_in_conv,
	¬³(a ´ b)®,
	¬a ± ³ b®),
	("³_in_conv 5",
	snd o dest_eq o concl o ³_in_conv,
	¬³(c ¤ b)®,
	¬(c ± ³b) ² (b ± ³c)®),
	("³_in_conv 6",
	snd o dest_eq o concl o ³_in_conv,
	¬³(if a then b else d)®,
	¬if a then ³b else ³d®),
	("³_in_conv 7",
	snd o dest_eq o concl o ³_in_conv,
	¬³(µ(x,y) · x ± y)®,
	¬¶(x,y) · ³(x ± y)®),
	("³_in_conv 8",
	snd o dest_eq o concl o ³_in_conv,
	¬³(¶(x,y) · x ± y)®,
	¬µ(x,y) · ³(x ± y)®),
	("³_in_conv 9",
	snd o dest_eq o concl o ³_in_conv,
	¬³(¶‰1(x,y) · x ± y)®,
	¬µ(x,y) · ³((x ± y) ± µ (x',y')· x' ± y' ´ (x',y') = (x,y))®),
	("³_in_conv 10",
	snd o dest_eq o concl o ³_in_conv,
	¬³ T®,
	¬F®),
	("³_in_conv 11",
	snd o dest_eq o concl o ³_in_conv,
	¬³ F®,
	¬T®)];
=TEX
=SML
store_mt_results mt_run_fail [("³_in_conv 28131",
	³_in_conv,
	mk_t,
	gen_fail_msg "³_in_conv" 28131 ["¬T®"])];
=TEX
\section{CANONICALISATION}
=SML
store_mt_results (mt_runf (op =#))[("³_rewrite_canon 1",
	dest_thm o hd o ³_rewrite_canon,
	asm_rule ¬³(a ² b)®,
	( [¬³(a ² b)®],¬³ a ± ³ b®)),
	("³_rewrite_canon 2",
	dest_thm o hd o ³_rewrite_canon,
	asm_rule ¬³(¶ (x,y) ·x = y)®,
	( [¬³(¶ (x,y) ·x = y)®],¬µ(x,y)·³(x = y)®)),
	("³_rewrite_canon 3",
	dest_thm o hd o ³_rewrite_canon,
	asm_rule ¬³a®,
	( [¬³a®],¬a ¤ F®)),
	("³_rewrite_canon 4",
	dest_thm o hd o ³_rewrite_canon,
	asm_rule ¬³³a®,
	( [¬³³a®],¬a:BOOL®))];
store_mt_results mt_run_fail [("³_rewrite_canon 26201",
	³_rewrite_canon,
	t_thm,
	gen_fail_msg "fail_canon" 26201 [])];
=TEX
=SML
store_mt_results (mt_runf (op =#))[("µ_rewrite_canon 1",
	dest_thm o hd o µ_rewrite_canon,
	asm_rule ¬µ (x,y) · x = y®,
	( [¬µ (x,y) · x = y®],¬x = y®))];
store_mt_results mt_run_fail [("µ_rewrite_canon 26201",
	µ_rewrite_canon,
	t_thm,
	gen_fail_msg "fail_canon" 26201 [])];
=TEX
The following does test all four canonicalisations that
make up the compilation, and the composition functions and $REWRITE\_CAN$.
=SML
store_mt_results (mt_runf (op =#))[("pair_rw_canon 1",
	dest_thm o hd o pair_rw_canon,
	asm_rule ¬³(a ² b)®,
	( [¬³(a ² b)®],¬a ¤ F®)),
	("pair_rw_canon 2",
	dest_thm o hd o pair_rw_canon,
	asm_rule ¬³(¶ (x,y) ·x = y)®,
	( [¬³(¶ (x, y)· x = y)®],¬µ y x · (x = y) ¤ F®)),
	("pair_rw_canon 3",
	dest_thm o hd o pair_rw_canon,
	asm_rule ¬³a®,
	( [¬³a®],¬a ¤ F®)),
	("pair_rw_canon 4",
	dest_thm o hd o pair_rw_canon,
	asm_rule ¬µ (x,y) · x = y®,
	( [¬µ (x,y) · x = y®],¬µ y x · x = y®)),
	("pair_rw_canon 5",
	dest_thm o hd o pair_rw_canon,
	asm_rule ¬µ (x,y) · x®,
	( [¬µ (x,y) · x®],¬µ x · x ¤ T®))];
=TEX
\section{PROOF CONTEXTS}
\subsection{Stripping Tactics and Tacticals}
We test those areas enhanced by the proof context $pair$
over $initial\_strip$,
after retesting that initial form.
We don't test much of the moving in of negations, as
the tests for $³\_in\_conv$ may be considered adequate.
=SML
store_mt_results (mt_runf (op =$))[
	("strip_tac 1",
	tac_res strip_tac,
	¬µ x · x ± y®,
	¬x ± y®),
	("strip_tac 2",
	tac_res strip_tac,
	¬a ± b®,
	¬a : BOOL®),
	("strip_tac 3",
	tac_res strip_tac,
	¬a ² ³ b®,
	¬b ´ a®),
	("strip_tac 4",
	tac_res strip_tac,
	¬³ a ² b®,
	¬a ´ b®),
	("strip_tac 5",
	tac_res strip_tac,
	¬a ² b®,
	¬³ a ´ b®),
	("strip_tac 6",
	tac_res strip_tac,
	¬a ¤ b®,
	¬(a ´ b) ± (b ´ a)®),
	("strip_tac 7",
	tac_res strip_tac,
	¬if a then (b:BOOL) else c®,
	¬(a ´ b) ± (³ a ´ c)®),
	("strip_tac 8",
	tac_res strip_tac,
	¬³ (a ² b)®,
	¬³ a ± ³ b®)];
store_mt_results (mt_runf (op =$))[
	("strip_tac p1",
	tac_res strip_tac,
	¬µ (x,y) z · x ± y ± z®,
	¬µ x y z · x ± y ± z®),
	("strip_tac p2",
	tac_res strip_tac,
	¬µ (x,y,z) · x ± y ± z®,
	¬µ x y z · x ± y ± z®)];
store_mt_results (mt_runf (op =#))[
	("strip_tac a1",
	tac_res1 strip_tac,
	([],¬a ´ b®),
	([¬a:BOOL®],¬b:BOOL®)),
	("strip_tac a2",
	tac_res1 strip_tac,
	([¬a:BOOL®],¬a ´ b®),
	([¬a:BOOL®],¬b:BOOL®)),
	("strip_tac a3",
	tac_res1 strip_tac,
	([],¬(a ± b) ´ c®),
	([¬b:BOOL®,¬a:BOOL®],¬c:BOOL®)),
	("strip_tac a4",
	tac_res1 strip_tac,
	([],¬(a ² b) ´ c®),
	([¬a:BOOL®],¬c:BOOL®)),
	("strip_tac a5",
	tac_res1 strip_tac,
	([],¬(¶ x · f x) ´ a®),
	([¬f x :BOOL®],¬a:BOOL®)),
	("strip_tac a6",
	tac_res1 strip_tac,
	([],¬(a ´ b) ´ c®),
	([¬³ a®],¬c:BOOL®)),
	("strip_tac a7",
	tac_res1 strip_tac,
	([],¬(a ¤ b) ´ c®),
	([¬³ b®,¬³ a®],¬c : BOOL®)),
	("strip_tac a8",
	tac_res1 strip_tac,
	([],¬(if a then b else c) ´ d®),
	([¬c:BOOL®,¬³ a®],¬d:BOOL®)),
	("strip_tac a9",
	tac_res1 strip_tac,
	([],¬(³( a ² b)) ´ c®),
	([¬³ b®,¬³ a®],¬c : BOOL®)),
	("strip_tac a10",
	tac_res1 strip_tac,
	([],¬(¶‰1 x · f x) ´ a®),
	([¬µ x':'a · f x' ´ x' = x®,¬f x:BOOL®],¬a:BOOL®))
];
store_mt_results (mt_runf (op =#))[
	("strip_tac pa1",
	tac_res1 strip_tac,
	([],¬(¶ (x,y) · f x y) ´ a®),
	([¬f x y:BOOL®],¬a:BOOL®)),
	("strip_tac pa2",
	tac_res1 strip_tac,
	([],¬(¶ (x,y,z) · f x y z) ´ a®),
	([¬f x y z:BOOL®],¬a:BOOL®)),
	("strip_tac pa3",
	tac_res1 strip_tac,
	([],¬(µ (x,y) · f x y) ´ a®),
	([¬µ x y · f x y®],¬a:BOOL®)),
	("strip_tac pa4",
	tac_res1 strip_tac,
	([],¬(¶‰1 (x,y) · f x y) ´ a®),
	([¬µ (x':'a) (y':'b) · f x' y' ´ (x',y') = (x,y)®,¬f x y:BOOL®],¬a:BOOL®))
];
store_mt_results mt_run [
	("strip_tac tp1",
	tac_solve strip_tac,
	([],¬T®),
	true),
	("strip_tac tp2",
	tac_solve strip_tac,
	([¬a:BOOL®,¬b:BOOL®],¬a:BOOL®),
	true),
	("strip_tac tp3",
	tac_solve strip_tac,
	([],¬(a ± b) ´ a®),
	true),
	("strip_tac tp4",
	tac_solve strip_tac,
	([¬³ a®],¬(a ± b) ´ c®),
	true),
	("strip_tac tp5",
	tac_solve strip_tac,
	([¬a:BOOL®],¬³ (a ² b) ´ c®),
	true)
];
store_mt_results mt_run_fail [("strip_tac",
	tac_fail strip_tac,
	([],¬f x : BOOL®),
	gen_fail_msg "strip_tac" 28003 ["¬f x®"])];
=TEX
The change to $strip\_asm\_tac$ has been tested in testing $strip\_tac$,
but for the record:
=SML
store_mt_results (mt_runf (op =#))[("strip_asm_tac 1",
	tac_res1 (strip_asm_tac (asm_rule ¬a ± b®)),
	([¬a ± b®],¬c:BOOL®),
	([¬b:BOOL®,¬a:BOOL®,¬a ± b®],¬c:BOOL®)),
	("strip_asm_tac 2",
	tac_res1 (strip_asm_tac t_thm),
	([],¬c:BOOL®),
	([],¬c:BOOL®))];
=TEX
The change to $check\_asm\_tac$ has been tested in testing $strip\_tac$,
but for the record:
=SML
store_mt_results (mt_runf (op =#))[("check_asm_tac 1",
	tac_res1 (check_asm_tac (±_left_elim(asm_rule ¬a ± b®))),
	([¬a ± b®],¬c:BOOL®),
	([¬a:BOOL®,¬a ± b®],¬c:BOOL®)),
	("check_asm_tac 2",
	tac_res1 (check_asm_tac t_thm),
	([],¬c:BOOL®),
	([],¬c:BOOL®))];
=TEX
The change to $STRIP\_THM\_THEN$ has been tested in testing $strip\_tac$,
but for the record:
=SML
store_mt_results (mt_runf (op =#))[("STRIP_THM_THEN",
	tac_res1 ((STRIP_THM_THEN strip_asm_tac) (asm_rule ¬a ± b®)),
	([¬a ± b®],¬c:BOOL®),
	([¬b:BOOL®,¬a:BOOL®,¬a ± b®],¬c:BOOL®))];
store_mt_results mt_run_fail [("STRIP_THM_THEN 28003",
	STRIP_THM_THEN strip_asm_tac,
	t_thm,
	gen_fail_msg "STRIP_THM_THEN" 28003 ["ô T"])];
=TEX
The change to $STRIP\-\_CONCL\_T$ has been tested in testing $strip\_tac$,
but for the record:
=SML
store_mt_results (mt_runf (op =#))[("STRIP_CONCL_T",
	tac_res1 (STRIP_CONCL_T asm_tac),
	([],¬(a ± b) ´ c®),
	([¬a ± b®],¬c : BOOL®))];
store_mt_results mt_run_fail [("STRIP_CONCL_T 28003",
	tac_fail (STRIP_CONCL_T asm_tac),
	([],¬f x: BOOL®),
	gen_fail_msg "STRIP_CONCL_T" 28003 ["¬f x®"])];
=TEX
\subsection{Canonicalisations in $pair$}
A simple test that the rewriting canonicalisations are in place in $pair$.
=SML
store_mt_results
(mt_runf (op =#))[
	("f_rewrite_canon",
	dest_thm o rewrite_rule[asm_rule mk_f],
	asm_rule ¬p ± q®,
	([mk_f,¬p ± q®],mk_t)),
	("±_rewrite_canon",
	dest_thm o pure_rewrite_rule[asm_rule ¬p ± q®],
	asm_rule ¬p ± q®,
	([¬p ± q®],¬T ± T®)),
	("³_rewrite_canon 5",
	dest_thm o pure_rewrite_rule[asm_rule ¬³(p ² q)®],
	asm_rule ¬p ± q®,
	([¬³(p ² q)®,¬p ± q®],¬F ± F®)),
	("³_rewrite_canon 6",
	dest_thm o pure_rewrite_rule[asm_rule ¬³ ¶ (x,y) · (x ± y)®],
	asm_rule ¬(x ± y)®,
	([¬¬³ ¶ (x,y) · (x ± y)®®,¬x ± y®],¬F®)),
	("³_rewrite_canon 7",
	dest_thm o pure_rewrite_rule[asm_rule ¬³ ³(x ¤ y)®],
	asm_rule ¬(x ± y)®,
	([¬¬³ ³(x ¤ y)®®,¬x ± y®],¬y ± y®)),
	("µ_rewrite_canon",
	dest_thm o pure_rewrite_rule[asm_rule ¬µ (x,y) · (x = 3) ± (y = "55")®],
	asm_rule ¬f 1 ± g "11"®,
	([¬µ (x,y) · (x = 3) ± (y = "55")®,¬f 1 ± g "11"®],¬f 3 ± g "55"®)),
	("¤_t_rewrite_canon",
	dest_thm o pure_rewrite_rule[asm_rule ¬x:BOOL®],
	asm_rule ¬x ± y®,
	([¬x:BOOL®,¬x ± y®],¬T ± y®))
];

=TEX

\section{END OF TESTS}
=SML
set_flag("subgoal_package_quiet",lsubgoal_package_quiet);
diag_string(summarize_mt_results ());
=TEX
\end{document}
=IGN
***********COPY**************
store_mt_results (mt_runf (op =$))[("",
	tac_res ,
	¬®,
	¬®)];
store_mt_results (mt_runf (op =#))[("",
	tac_res1 ,
	([¬®],¬®),
	([¬®],¬®))];
store_mt_results mt_run [
	("",
	tac_solve ,
	([],¬®),
	true),
];
store_mt_results mt_run_fail [("",
	tac_fail ,
	([],¬®),
	gen_fail_msg ""  [])];

store_mt_results mt_run [("",
	,
	,
	)];
store_mt_results mt_run_fail [("",
	,
	,
	gen_fail_msg ""  [])];


