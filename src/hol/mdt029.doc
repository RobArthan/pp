=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Module Tests for Tactics III}
\TPPref{DS/FMU/IED/MDT029}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{R.D.~Arthan & WIN01 \\ K.~Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the module tests for the 
third group of tactics and tacticals in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Modified $spec\_asm\_tac$ tests, et al.
\item [Issue 1.3]
Changes to match issue 1.5 of \cite{DS/FMU/IED/DTD029}.

\item[Issue 1.4, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.5]
Removed duplicate labels.
\item [Issue 1.6]
Test $sets\_epc$.
\item [Issue 1.7]
Changed working theory
\item [Issue 1.8(11th March 1992)]
Various minor additions and extensions.
\end{description}
\subsection{Changes Forecast}
Completion of coverage.
\section{GENERAL}
\subsection{Scope}
This document contains the module tests for the material
whose detailed design is given in in \cite{DS/FMU/IED/DTD029}.
\subsection{Introduction}
We are pretty cursory in the following, doing little more than just demonstrating
the tactics presence and error message origin.
\subsubsection{Dependencies}
The tests depend upon \cite{DS/FMU/IED/IMP013}, the test harness.
In addition, testing by the subgoal package
depends on \cite{DS/FMU/IED/IMP030}.

\subsubsection{Deficiencies}
The testing could be more rigorous.
\section{TEST CASES}
We test each function of the signature of \cite{DS/FMU/IED/DTD029}
in turn, where possible in the same order as in the design document.
\section{PREAMBLE}
=SML
open_theory"basic_hol";
usefile "dtd013";
usefile "imp013";
init_mt_results();
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",true);
repeat drop_main_goal;
val _ = push_proof_context pair_epc;
=TEX
\section{TESTS}
\subsection{Testing Using Subgoal Package}
The following functions apply a tactic to a selected goal
and returns the resulting top goal. 
This of course doesn't fully test tactics that return multiple
goals.
The functions differ in that $tac\_res1$ inputs and outputs
both assumptions and conclusion, while $tac\_res$
just assumes an empty assumption list.
=SML
fun €tac_res› tac goal = (push_goal([],goal);
		a tac;
		let val (asms,gl) = top_goal()
		in
			(drop_main_goal();
			gl)
		end);
fun €tac_res1› tac (asms, goal) = (
		push_goal(asms,goal);
		a tac;
		let val (asms,gl) = top_goal()
		in
			(drop_main_goal();
			(asms,gl))
		end);
=TEX
This function tests that a tactic proves a goal:
=SML
fun €tac_solve› tac (asms, goal) = (
	dest_thm (tac_proof ((asms,goal),tac))
	=
	(asms, goal)
);
=TEX
This function tests that a tactic fails on a goal:
=SML
fun €tac_fail› tac (asms, goal) = (
	push_goal(asms,goal);
	a tac
	handle complaint =>
	(drop_main_goal();
	reraise complaint (area_of complaint))
);
=TEX
=SML

=TEX
\section{THE TESTS}
\subsection{Concerning Tautologies}
=SML
store_mt_results mt_run [
	("taut_tac 1",
	tac_solve taut_tac,
	([],¨TÆ),
	true),
	("taut_tac 2",
	tac_solve taut_tac,
	([],¨(a ± b) § (b ± a)Æ),
	true),
	("taut_tac 3",
	tac_solve taut_tac,
	([],¨a ≤ ≥ aÆ),
	true),
	("taut_tac 4",
	tac_solve taut_tac,
	([],¨(if a then p else ≥ p) ¥ (≥ p ¥ ≥ a)Æ),
	true),
	("taut_tac 5",
	tac_solve taut_tac,
	([],¨≥≥≥ FÆ),
	true)
];
store_mt_results mt_run [
	("taut_tac 1",
	tac_solve taut_tac,
	([],¨µ x y ∑ TÆ),
	true),
	("taut_tac 2",
	tac_solve taut_tac,
	([],¨µ (a,b) ∑ (a ± b) § (b ± a)Æ),
	true),
	("taut_tac 3",
	tac_solve taut_tac,
	([],¨µ c ∑ a ≤ ≥ aÆ),
	true),
	("taut_tac 4",
	tac_solve taut_tac,
	([],¨µ p ∑ (if a then p else ≥ p) ¥ (≥ p ¥ ≥ a)Æ),
	true),
	("taut_tac 5",
	tac_solve taut_tac,
	([],¨µ z ∑ ≥≥≥ FÆ),
	true)
];
store_mt_results mt_run_fail [("taut_tac 28121 1",
	tac_fail taut_tac,
	([],¨FÆ),
	gen_fail_msg "taut_tac" 28121 []),
	("taut_tac 28121 2",
	tac_fail taut_tac,
	([],¨1 = 1Æ),
	gen_fail_msg "taut_tac" 28121 [])
	];

store_mt_results mt_run_fail [("taut_tac 28121 4",
	taut_tac,
	([],¨a:'aÆ),
	gen_fail_msg "taut_tac" 28121 [])];
=TEX
=SML
store_mt_results mt_run [("taut_rule",
	dest_thm o taut_rule,
	¨µ a e ∑ (a ± b ± c ± d ¥ e) § (a ¥ b ¥ c ¥ d ¥ e)Æ,
	([],¨µ a e ∑ (a ± b ± c ± d ¥ e) § (a ¥ b ¥ c ¥ d ¥ e)Æ))];
store_mt_results mt_run_fail [("taut_rule 27037",
	taut_rule,
	¨FÆ,
	gen_fail_msg "taut_rule" 27037 ["¨FÆ"]),
	("taut_rule 27030",
	taut_rule,
	¨1Æ,
	gen_fail_msg "taut_rule" 27037 ["¨1Æ"])];
=TEX
=SML
store_mt_results mt_run [("taut_conv",
	dest_thm o taut_conv,
	¨µ a e ∑ (a ± b ± c ± d ¥ e) § (a ¥ b ¥ c ¥ d ¥ e)Æ,
	([],¨(µ a e ∑ (a ± b ± c ± d ¥ e) § (a ¥ b ¥ c ¥ d ¥ e)) § TÆ))];
store_mt_results mt_run_fail [("taut_conv 27037 a",
	taut_conv,
	¨FÆ,
	gen_fail_msg "taut_conv" 27037 ["¨FÆ"]),
	("taut_conv 27037 b",
	taut_conv,
	¨1Æ,
	gen_fail_msg "taut_conv" 27037 ["¨1Æ"])];
=TEX
\subsection{Concerning ≥}
=SML
store_mt_results mt_run [
	("≥_in_tac 1",
	tac_res ≥_in_tac,
	¨≥(≥ F)Æ,
	¨FÆ),
	("≥_in_tac 2",
	tac_res ≥_in_tac,
	¨≥(a ± b)Æ,
	¨≥ a ≤ ≥ bÆ),
	("≥_in_tac 3",
	tac_res ≥_in_tac,
	¨≥(a ≤ b)Æ,
	¨≥ a ± ≥ bÆ),
	("≥_in_tac 4",
	tac_res ≥_in_tac,
	¨≥(a ¥ b)Æ,
	¨a ± ≥ bÆ),
	("≥_in_tac 5",
	tac_res ≥_in_tac,
	¨≥(a § b)Æ,
	¨(a ± ≥b) ≤ (b ± ≥a)Æ),
	("≥_in_tac 6",
	tac_res ≥_in_tac,
	¨≥(µ x ∑f x)Æ,
	¨∂ x ∑≥ f xÆ),
	("≥_in_tac 7",
	tac_res ≥_in_tac,
	¨≥(µ (x,y) ∑ f x y)Æ,
	¨∂ (x,y) ∑ ≥ f x yÆ),
	("≥_in_tac 8",
	tac_res ≥_in_tac,
	¨≥(∂ x ∑f x)Æ,
	¨µ x ∑≥ f xÆ),
	("≥_in_tac 9",
	tac_res ≥_in_tac,
	¨≥(∂ (x,y) ∑ f x y)Æ,
	¨µ (x,y) ∑ ≥ f x yÆ),
	("≥_in_tac 10",
	tac_res ≥_in_tac,
	¨≥(∂%down%1 x ∑f x)Æ,
	¨µ x ∑≥ (f x ± µ x' ∑f x' ¥ x' = x)Æ),
	("≥_in_tac 11",
	tac_res ≥_in_tac,
	¨≥(∂%down%1 (x,y) ∑ f x y)Æ,
	¨µ (x,y) ∑ ≥ (f x y ± µ (x',y') ∑f x' y' ¥ (x',y') = (x,y))Æ),
	("≥_in_tac 12",
	tac_res ≥_in_tac,
	¨≥ TÆ,
	¨FÆ)];
store_mt_results mt_run[
	("≥_in_tac 13",
	tac_solve ≥_in_tac,
	([],¨≥FÆ),
	true)];
store_mt_results mt_run_fail [("≥_in_tac 28025",
	tac_fail ≥_in_tac,
	([],¨TÆ),
	gen_fail_msg "≥_in_tac" 28025 [])];
=TEX
As $≥\_IN\_THEN$ is based on the same conversion as the above,
we just test one case.
=SML
store_mt_results mt_run [("≥_IN_THEN",
	tac_res (≥_IN_THEN ante_tac f_thm),
	¨TÆ,
	¨T ¥ TÆ)];
store_mt_results mt_run_fail [("≥_IN_THEN 29010",
	≥_IN_THEN asm_tac,
	t_thm,
	gen_fail_msg "≥_IN_THEN" 29010 ["Ù T"])];
=TEX
\subsection{Concerning µ}
=SML
store_mt_results mt_run [("µ_tac 1",
	tac_res µ_tac,
	¨µ x ∑ f xÆ,
	¨f x : BOOLÆ),
	("µ_tac 2",
	tac_res µ_tac,
	¨µ (x,y,z) ∑ f x y zÆ,
	¨f x y z: BOOLÆ)];
store_mt_results mt_run_fail [("µ_tac 29001",
	tac_fail µ_tac,
	([],¨TÆ),
	gen_fail_msg "µ_tac" 29001 [])];
=TEX
\subsection{Concerning ∂}
=SML
store_mt_results mt_run [("∂_tac 1",
	tac_res (∂_tac ¨1Æ),
	¨∂ x ∑ x = 1Æ,
	¨1 = 1Æ),
	("∂_tac 2",
	tac_res (∂_tac ¨(1,2)Æ),
	¨∂ (x,y):Ó ∏ Ó ∑ ≥(x = y)Æ,
	¨≥(1 = 2)Æ),
	("∂_tac 3",
	tac_res (∂_tac ¨x:'aÆ),
	¨∂  y : Ó ∑ y = yÆ,
	¨(x:Ó) = xÆ),
	("∂_tac 4",
	tac_res (∂_tac ¨x:'aÆ),
	¨∂ (x,y): 'a ∏ 'a ∑ x = yÆ,
	¨Fst (x: 'a ∏ 'a) = Snd xÆ)];
store_mt_results mt_run_fail [("∂_tac 29002",
	tac_fail (∂_tac mk_t),
	([],¨a ≤ bÆ),
	gen_fail_msg "∂_tac" 29002 []),
	("∂_tac 29008",
	tac_fail (∂_tac ¨(1,2)Æ),
	([],¨∂ a ∑ a ≤ bÆ),
	gen_fail_msg "∂_tac" 29008 ["¨(1, 2)Æ","¨aÆ"])];
=TEX
=SML
store_mt_results mt_run [("∂_THEN",
	tac_res1 (∂_THEN ante_tac (asm_rule ¨∂ (x,y) ∑ x = yÆ)),
	([],¨x:BOOLÆ),
	([],¨(x' = y) ¥ xÆ))];
store_mt_results mt_run_fail [("∂_THEN 29003",
	∂_THEN ante_tac,
	t_thm,
	gen_fail_msg "∂_THEN" 29003 ["Ù T"])];
=TEX
\subsection{Concerning ∂$_1$}
=SML
store_mt_results mt_run [("∂%down%1_tac 1",
	tac_res (∂%down%1_tac ¨2Æ),
	¨∂%down%1 x ∑ x = 1Æ,
	¨2 = 1 ± µ x' ∑ x' = 1 ¥ x' = 2Æ),
	("∂%down%1_tac 2",
	tac_res (∂%down%1_tac ¨(1,2)Æ),
	¨∂%down%1 (x:Ó,y) ∑ ≥(x = y)Æ,
	¨≥(1 = 2) ± µ (x',y') ∑ ≥(x' = y') ¥ (x',y') = (1,2)Æ),
	("∂%down%1_tac 3",
	tac_res (∂%down%1_tac ¨x:'aÆ),
	¨∂%down%1 y : Ó ∑ y = yÆ,
	¨((x:Ó) = x) ± µ y' ∑ (y' = y') ¥ y' = xÆ),
	("∂%down%1_tac 4",
	tac_res (∂%down%1_tac ¨x:'aÆ),
	¨∂%down%1 (x,y): 'a ∏ 'a ∑ x = yÆ,
	¨Fst (x: 'a ∏ 'a) = Snd x ± µ (x',y') ∑ (x' = y') ¥ (x',y') = (Fst x, Snd x)Æ)];
store_mt_results mt_run_fail [("∂%down%1_tac 29004",
	tac_fail (∂%down%1_tac mk_t),
	([],¨a ≤ bÆ),
	gen_fail_msg "∂%down%1_tac" 29004 []),
	("∂%down%1_tac 29008",
	tac_fail (∂%down%1_tac ¨(1,2)Æ),
	([],¨∂%down%1 a ∑ a ≤ bÆ),
	gen_fail_msg "∂%down%1_tac" 29008 ["¨(1, 2)Æ","¨aÆ"])];
=TEX
=SML
store_mt_results mt_run [("∂%down%1_THEN",
	tac_res1 (∂%down%1_THEN ante_tac (asm_rule ¨∂%down%1 (x,y) ∑ x = yÆ)),
	([],¨x:BOOLÆ),
	([],¨((x' = y) ± 
		(µ (x'',y') ∑ (x'' = y') ¥ (x'',y') = (x',y)))¥ xÆ))];
store_mt_results mt_run_fail [("∂%down%1_THEN 29005",
	∂%down%1_THEN ante_tac,
	t_thm,
	gen_fail_msg "∂%down%1_THEN" 29005 ["Ù T"])];
=TEX
\subsection{Concerning Assumptions}
=SML
store_mt_results mt_run [("spec_asm_tac",
	tac_res1 (spec_asm_tac ¨µ x ∑ x = 1Æ ¨0Æ),
	([¨µ x ∑ x = 1Æ],¨FÆ),
	([¨0 = 1Æ,¨µ x ∑ x = 1Æ],¨FÆ))];
store_mt_results mt_run [("list_spec_asm_tac",
	tac_res1 (list_spec_asm_tac ¨µ x y:Ó ∑ x = yÆ [¨0Æ,¨1Æ]),
	([¨µ x y:Ó ∑ x = yÆ],¨FÆ),
	([¨0 = 1Æ,¨µ x y:Ó ∑ x = yÆ],¨FÆ))];
store_mt_results mt_run [("spec_nth_asm_tac",
	tac_res1 (spec_nth_asm_tac 1 ¨0Æ),
	([¨µ x ∑ x = 1Æ],¨FÆ),
	([¨0 = 1Æ,¨µ x ∑ x = 1Æ],¨FÆ))];
store_mt_results mt_run [("list_spec_nth_asm_tac",
	tac_res1 (list_spec_nth_asm_tac 1 [¨0Æ,¨1Æ]),
	([¨µ x y :Ó∑ x = yÆ],¨FÆ),
	([¨0 = 1Æ,¨µ x y :Ó∑ x = yÆ],¨FÆ))];
=TEX
We only give one example kind of passed-on error for each function.
=SML
store_mt_results mt_run_fail [("spec_asm_tac 9301",
	tac_fail (spec_asm_tac ¨µ x ∑ x = 1Æ ¨0Æ),
	([],¨FÆ),
	gen_fail_msg "GET_ASM_T" 9301 ["¨µ x∑ x = 1Æ"])];
store_mt_results mt_run_fail [("list_spec_asm_tac 9301",
	tac_fail (list_spec_asm_tac ¨µ x y ∑ x = yÆ [¨0Æ,¨1Æ]),
	([],¨FÆ),
	gen_fail_msg "GET_ASM_T" 9301 ["¨µ x y∑ x = yÆ"])];
store_mt_results mt_run_fail [("spec_nth_asm_tac 9303",
	tac_fail (spec_nth_asm_tac 2 ¨0Æ),
	([¨µ x ∑ x = 1Æ],¨FÆ),
	gen_fail_msg "GET_NTH_ASM_T" 9303 ["2"])];
store_mt_results mt_run_fail [("list_spec_nth_asm_tac 9303",
	tac_fail (list_spec_nth_asm_tac 2 [¨0Æ,¨1Æ]),
	([¨µ x y ∑ x = yÆ],¨FÆ),
	gen_fail_msg "GET_NTH_ASM_T" 9303 ["2"])];
=TEX
=SML
fun €lspec_asm_tac› (asm : TERM) (instance : TERM)  :TACTIC = (
	SPEC_ASM_T asm instance strip_asm_tac
);
fun €llist_spec_asm_tac› (asm : TERM) (instances : TERM list)  :TACTIC = (
	LIST_SPEC_ASM_T asm instances strip_asm_tac
);
fun €lspec_nth_asm_tac› (n : int) (instance : TERM)  :TACTIC = (
	SPEC_NTH_ASM_T n instance strip_asm_tac
);
fun €llist_spec_nth_asm_tac› (n : int) (instances : TERM list)  :TACTIC = (
	LIST_SPEC_NTH_ASM_T n instances strip_asm_tac
);

=TEX
=SML
store_mt_results mt_run [("lspec_asm_tac",
	tac_res1 (lspec_asm_tac ¨µ x ∑ x = 1Æ ¨0Æ),
	([¨µ x ∑ x = 1Æ],¨FÆ),
	([¨0 = 1Æ,¨µ x ∑ x = 1Æ],¨FÆ))];
store_mt_results mt_run [("llist_spec_asm_tac",
	tac_res1 (llist_spec_asm_tac ¨µ x y:Ó ∑ x = yÆ [¨0Æ,¨1Æ]),
	([¨µ x y:Ó ∑ x = yÆ],¨FÆ),
	([¨0 = 1Æ,¨µ x y:Ó ∑ x = yÆ],¨FÆ))];
store_mt_results mt_run [("lspec_nth_asm_tac",
	tac_res1 (lspec_nth_asm_tac 1 ¨0Æ),
	([¨µ x ∑ x = 1Æ],¨FÆ),
	([¨0 = 1Æ,¨µ x ∑ x = 1Æ],¨FÆ))];
store_mt_results mt_run [("llist_spec_nth_asm_tac",
	tac_res1 (llist_spec_nth_asm_tac 1 [¨0Æ,¨1Æ]),
	([¨µ x y :Ó∑ x = yÆ],¨FÆ),
	([¨0 = 1Æ,¨µ x y :Ó∑ x = yÆ],¨FÆ))];
=TEX
We only give one example kind of passed-on error for each function.
=SML
store_mt_results mt_run_fail [("lspec_asm_tac 9301",
	tac_fail (spec_asm_tac ¨µ x ∑ x = 1Æ ¨0Æ),
	([],¨FÆ),
	gen_fail_msg "GET_ASM_T" 9301 ["¨µ x∑ x = 1Æ"])];
store_mt_results mt_run_fail [("llist_spec_asm_tac 9301",
	tac_fail (list_spec_asm_tac ¨µ x y ∑ x = yÆ [¨0Æ,¨1Æ]),
	([],¨FÆ),
	gen_fail_msg "GET_ASM_T" 9301 ["¨µ x y∑ x = yÆ"])];
store_mt_results mt_run_fail [("lspec_nth_asm_tac 9303",
	tac_fail (lspec_nth_asm_tac 2 ¨0Æ),
	([¨µ x ∑ x = 1Æ],¨FÆ),
	gen_fail_msg "GET_NTH_ASM_T" 9303 ["2"])];
store_mt_results mt_run_fail [("llist_spec_nth_asm_tac 9303",
	tac_fail (llist_spec_nth_asm_tac 2 [¨0Æ,¨1Æ]),
	([¨µ x y ∑ x = yÆ],¨FÆ),
	gen_fail_msg "GET_NTH_ASM_T" 9303 ["2"])];
=TEX

\section{CONVERSIONS}
=SML
store_mt_results mt_run [
	("≥_in_conv 1",
	snd o dest_eq o concl o ≥_in_conv,
	¨≥≥ TÆ,
	¨TÆ),
	("≥_in_conv 2",
	snd o dest_eq o concl o ≥_in_conv,
	¨≥(b ± a)Æ,
	¨≥ b ≤ ≥ aÆ),
	("≥_in_conv 3",
	snd o dest_eq o concl o ≥_in_conv,
	¨≥(b ≤ a)Æ,
	¨≥ b ± ≥ aÆ),
	("≥_in_conv 4",
	snd o dest_eq o concl o ≥_in_conv,
	¨≥(a ¥ b)Æ,
	¨a ± ≥ bÆ),
	("≥_in_conv 5",
	snd o dest_eq o concl o ≥_in_conv,
	¨≥(c § b)Æ,
	¨(c ± ≥b) ≤ (b ± ≥c)Æ),
	("≥_in_conv 6",
	snd o dest_eq o concl o ≥_in_conv,
	¨≥(if a then b else d)Æ,
	¨if a then ≥b else ≥dÆ),
	("≥_in_conv 7",
	snd o dest_eq o concl o ≥_in_conv,
	¨≥(µ(x,y) ∑ x ± y)Æ,
	¨∂(x,y) ∑ ≥(x ± y)Æ),
	("≥_in_conv 8",
	snd o dest_eq o concl o ≥_in_conv,
	¨≥(∂(x,y) ∑ x ± y)Æ,
	¨µ(x,y) ∑ ≥(x ± y)Æ),
	("≥_in_conv 9",
	snd o dest_eq o concl o ≥_in_conv,
	¨≥(∂%down%1(x,y) ∑ x ± y)Æ,
	¨µ(x,y) ∑ ≥((x ± y) ± µ (x',y')∑ x' ± y' ¥ (x',y') = (x,y))Æ),
	("≥_in_conv 10",
	snd o dest_eq o concl o ≥_in_conv,
	¨≥ TÆ,
	¨FÆ),
	("≥_in_conv 11",
	snd o dest_eq o concl o ≥_in_conv,
	¨≥ FÆ,
	¨TÆ)];
=TEX
=SML
store_mt_results mt_run_fail [("≥_in_conv 28131",
	≥_in_conv,
	mk_t,
	gen_fail_msg "≥_in_conv" 28131 ["¨TÆ"])];
=TEX
\section{CANONICALISATION}
=SML
store_mt_results mt_run [("≥_rewrite_canon 1",
	dest_thm o hd o ≥_rewrite_canon,
	asm_rule ¨≥(a ≤ b)Æ,
	( [¨≥(a ≤ b)Æ],¨≥ a ± ≥ bÆ)),
	("≥_rewrite_canon 2",
	dest_thm o hd o ≥_rewrite_canon,
	asm_rule ¨≥(∂ (x,y) ∑x = y)Æ,
	( [¨≥(∂ (x,y) ∑x = y)Æ],¨µ(x,y)∑≥(x = y)Æ)),
	("≥_rewrite_canon 3",
	dest_thm o hd o ≥_rewrite_canon,
	asm_rule ¨≥aÆ,
	( [¨≥aÆ],¨a § FÆ))];
store_mt_results mt_run_fail [("≥_rewrite_canon 26201",
	≥_rewrite_canon,
	t_thm,
	gen_fail_msg "fail_canon" 26201 [])];
=TEX
=SML
store_mt_results mt_run [("µ_rewrite_canon 1",
	dest_thm o hd o µ_rewrite_canon,
	asm_rule ¨µ (x,y) ∑ x = yÆ,
	( [¨µ (x,y) ∑ x = yÆ],¨x = yÆ))];
store_mt_results mt_run_fail [("µ_rewrite_canon 26201",
	µ_rewrite_canon,
	t_thm,
	gen_fail_msg "fail_canon" 26201 [])];
=TEX
The following does test all four canonicalisations that
make up the compilation, and the composition functions and $REWRITE\_CAN$.
=SML
store_mt_results mt_run [("pair_rw_canon 1",
	dest_thm o hd o pair_rw_canon,
	asm_rule ¨≥(a ≤ b)Æ,
	( [¨≥(a ≤ b)Æ],¨a § FÆ)),
	("pair_rw_canon 2",
	dest_thm o hd o pair_rw_canon,
	asm_rule ¨≥(∂ (x,y) ∑x = y)Æ,
	( [¨≥(∂ (x, y)∑ x = y)Æ],¨µ y x ∑ (x = y) § FÆ)),
	("pair_rw_canon 3",
	dest_thm o hd o pair_rw_canon,
	asm_rule ¨≥aÆ,
	( [¨≥aÆ],¨a § FÆ)),
	("pair_rw_canon 4",
	dest_thm o hd o pair_rw_canon,
	asm_rule ¨µ (x,y) ∑ x = yÆ,
	( [¨µ (x,y) ∑ x = yÆ],¨µ y x ∑ x = yÆ)),
	("pair_rw_canon 5",
	dest_thm o hd o pair_rw_canon,
	asm_rule ¨µ (x,y) ∑ xÆ,
	( [¨µ (x,y) ∑ xÆ],¨µ x ∑ x § TÆ))];
=TEX
\section{PROOF CONTEXTS}
\subsection{Stripping Tactics and Tacticals}
We test those areas enhanced by the $epair\_proof\_context$
over $einitial\_strip\_proof\_context$,
after retesting that initial form.
We don't test much of the moving in of negations, as
the tests for $≥\_in\_conv$ may be considered adequate.
=SML
store_mt_results mt_run [
	("strip_tac 1",
	tac_res strip_tac,
	¨µ x ∑ x ± yÆ,
	¨x ± yÆ),
	("strip_tac 2",
	tac_res strip_tac,
	¨a ± bÆ,
	¨a : BOOLÆ),
	("strip_tac 3",
	tac_res strip_tac,
	¨a ≤ ≥ bÆ,
	¨b ¥ aÆ),
	("strip_tac 4",
	tac_res strip_tac,
	¨≥ a ≤ bÆ,
	¨a ¥ bÆ),
	("strip_tac 5",
	tac_res strip_tac,
	¨a ≤ bÆ,
	¨≥ a ¥ bÆ),
	("strip_tac 6",
	tac_res strip_tac,
	¨a § bÆ,
	¨(a ¥ b) ± (b ¥ a)Æ),
	("strip_tac 7",
	tac_res strip_tac,
	¨if a then (b:BOOL) else cÆ,
	¨(a ¥ b) ± (≥ a ¥ c)Æ),
	("strip_tac 8",
	tac_res strip_tac,
	¨≥ (a ≤ b)Æ,
	¨≥ a ± ≥ bÆ)];
store_mt_results mt_run [
	("strip_tac p1",
	tac_res strip_tac,
	¨µ (x,y) z ∑ x ± y ± zÆ,
	¨µ x y z ∑ x ± y ± zÆ),
	("strip_tac p2",
	tac_res strip_tac,
	¨µ (x,y,z) ∑ x ± y ± zÆ,
	¨µ x y z ∑ x ± y ± zÆ)];
store_mt_results mt_run [
	("strip_tac a1",
	tac_res1 strip_tac,
	([],¨a ¥ bÆ),
	([¨a:BOOLÆ],¨b:BOOLÆ)),
	("strip_tac a2",
	tac_res1 strip_tac,
	([¨a:BOOLÆ],¨a ¥ bÆ),
	([¨a:BOOLÆ],¨b:BOOLÆ)),
	("strip_tac a3",
	tac_res1 strip_tac,
	([],¨(a ± b) ¥ cÆ),
	([¨b:BOOLÆ,¨a:BOOLÆ],¨c:BOOLÆ)),
	("strip_tac a4",
	tac_res1 strip_tac,
	([],¨(a ≤ b) ¥ cÆ),
	([¨a:BOOLÆ],¨c:BOOLÆ)),
	("strip_tac a5",
	tac_res1 strip_tac,
	([],¨(∂ x ∑ f x) ¥ aÆ),
	([¨f x :BOOLÆ],¨a:BOOLÆ)),
	("strip_tac a6",
	tac_res1 strip_tac,
	([],¨(a ¥ b) ¥ cÆ),
	([¨≥ aÆ],¨c:BOOLÆ)),
	("strip_tac a7",
	tac_res1 strip_tac,
	([],¨(a § b) ¥ cÆ),
	([¨≥ bÆ,¨≥ aÆ],¨c : BOOLÆ)),
	("strip_tac a8",
	tac_res1 strip_tac,
	([],¨(if a then b else c) ¥ dÆ),
	([¨c:BOOLÆ,¨≥ aÆ],¨d:BOOLÆ)),
	("strip_tac a9",
	tac_res1 strip_tac,
	([],¨(≥( a ≤ b)) ¥ cÆ),
	([¨≥ bÆ,¨≥ aÆ],¨c : BOOLÆ)),
	("strip_tac a10",
	tac_res1 strip_tac,
	([],¨(∂%down%1 x ∑ f x) ¥ aÆ),
	([¨µ x':'a ∑ f x' ¥ x' = xÆ,¨f x:BOOLÆ],¨a:BOOLÆ))
];
store_mt_results mt_run [
	("strip_tac pa1",
	tac_res1 strip_tac,
	([],¨(∂ (x,y) ∑ f x y) ¥ aÆ),
	([¨f x y:BOOLÆ],¨a:BOOLÆ)),
	("strip_tac pa2",
	tac_res1 strip_tac,
	([],¨(∂ (x,y,z) ∑ f x y z) ¥ aÆ),
	([¨f x y z:BOOLÆ],¨a:BOOLÆ)),
	("strip_tac pa3",
	tac_res1 strip_tac,
	([],¨(µ (x,y) ∑ f x y) ¥ aÆ),
	([¨µ x y ∑ f x yÆ],¨a:BOOLÆ)),
	("strip_tac pa4",
	tac_res1 strip_tac,
	([],¨(∂%down%1 (x,y) ∑ f x y) ¥ aÆ),
	([¨µ (x':'a) (y':'b) ∑ f x' y' ¥ (x',y') = (x,y)Æ,¨f x y:BOOLÆ],¨a:BOOLÆ))
];
store_mt_results mt_run [
	("strip_tac tp1",
	tac_solve strip_tac,
	([],¨TÆ),
	true),
	("strip_tac tp2",
	tac_solve strip_tac,
	([¨a:BOOLÆ,¨b:BOOLÆ],¨a:BOOLÆ),
	true),
	("strip_tac tp3",
	tac_solve strip_tac,
	([],¨(a ± b) ¥ aÆ),
	true),
	("strip_tac tp4",
	tac_solve strip_tac,
	([¨≥ aÆ],¨(a ± b) ¥ cÆ),
	true),
	("strip_tac tp5",
	tac_solve strip_tac,
	([¨a:BOOLÆ],¨≥ (a ≤ b) ¥ cÆ),
	true)
];
store_mt_results mt_run_fail [("strip_tac",
	tac_fail strip_tac,
	([],¨f x : BOOLÆ),
	gen_fail_msg "strip_tac" 28003 ["¨f xÆ"])];
=TEX
The change to $strip\_asm\_tac$ has been tested in testing $strip\_tac$,
but for the record:
=SML
store_mt_results mt_run [("strip_asm_tac 1",
	tac_res1 (strip_asm_tac (asm_rule ¨a ± bÆ)),
	([¨a ± bÆ],¨c:BOOLÆ),
	([¨b:BOOLÆ,¨a:BOOLÆ,¨a ± bÆ],¨c:BOOLÆ)),
	("strip_asm_tac 2",
	tac_res1 (strip_asm_tac t_thm),
	([],¨c:BOOLÆ),
	([],¨c:BOOLÆ))];
=TEX
The change to $check\_asm\_tac$ has been tested in testing $strip\_tac$,
but for the record:
=SML
store_mt_results mt_run [("check_asm_tac 1",
	tac_res1 (check_asm_tac (±_left_elim(asm_rule ¨a ± bÆ))),
	([¨a ± bÆ],¨c:BOOLÆ),
	([¨a:BOOLÆ,¨a ± bÆ],¨c:BOOLÆ)),
	("check_asm_tac 2",
	tac_res1 (check_asm_tac t_thm),
	([],¨c:BOOLÆ),
	([],¨c:BOOLÆ))];
=TEX
The change to $STRIP\_THM\_THEN$ has been tested in testing $strip\_tac$,
but for the record:
=SML
store_mt_results mt_run [("STRIP_THM_THEN",
	tac_res1 ((STRIP_THM_THEN strip_asm_tac) (asm_rule ¨a ± bÆ)),
	([¨a ± bÆ],¨c:BOOLÆ),
	([¨b:BOOLÆ,¨a:BOOLÆ,¨a ± bÆ],¨c:BOOLÆ))];
store_mt_results mt_run_fail [("STRIP_THM_THEN 28003",
	STRIP_THM_THEN strip_asm_tac,
	t_thm,
	gen_fail_msg "STRIP_THM_THEN" 28003 ["Ù T"])];
=TEX
The change to $STRIP\_GOAL\_T$ has been tested in testing $strip\_tac$,
but for the record:
=SML
store_mt_results mt_run [("STRIP_GOAL_T",
	tac_res1 (STRIP_GOAL_T asm_tac),
	([],¨(a ± b) ¥ cÆ),
	([¨a ± bÆ],¨c : BOOLÆ))];
store_mt_results mt_run_fail [("STRIP_GOAL_T 28003",
	tac_fail (STRIP_GOAL_T asm_tac),
	([],¨f x: BOOLÆ),
	gen_fail_msg "STRIP_GOAL_T" 28003 ["¨f xÆ"])];
=TEX
\subsection{Canonicalisations in $pair\_epc$}
A simple test that the rewriting canonicalisations are in place in $pair\_epc$.
=SML
store_mt_results
mt_run [
	("f_rewrite_canon",
	dest_thm o rewrite_rule[asm_rule mk_f],
	asm_rule ¨p ± qÆ,
	([mk_f,¨p ± qÆ],mk_t)),
	("±_rewrite_canon",
	dest_thm o pure_rewrite_rule[asm_rule ¨p ± qÆ],
	asm_rule ¨p ± qÆ,
	([¨p ± qÆ],¨T ± TÆ)),
	("≥_rewrite_canon 1",
	dest_thm o pure_rewrite_rule[asm_rule ¨≥(p ≤ q)Æ],
	asm_rule ¨p ± qÆ,
	([¨≥(p ≤ q)Æ,¨p ± qÆ],¨F ± FÆ)),
	("≥_rewrite_canon 2",
	dest_thm o pure_rewrite_rule[asm_rule ¨≥ ∂ (x,y) ∑ (x ± y)Æ],
	asm_rule ¨(x ± y)Æ,
	([¨¨≥ ∂ (x,y) ∑ (x ± y)ÆÆ,¨x ± yÆ],¨FÆ)),
	("µ_rewrite_canon",
	dest_thm o pure_rewrite_rule[asm_rule ¨µ (x,y) ∑ (x = 3) ± (≥ y)Æ],
	asm_rule ¨f 1 ± yÆ,
	([¨µ (x,y) ∑ (x = 3) ± (≥ y)Æ,¨f 1 ± yÆ],¨f 3 ± FÆ)),
	("§_t_rewrite_canon",
	dest_thm o pure_rewrite_rule[asm_rule ¨x:BOOLÆ],
	asm_rule ¨x ± yÆ,
	([¨x:BOOLÆ,¨x ± yÆ],¨T ± yÆ))
];

=TEX

\subsection{Testing the Sets Context}
We do this testing by a few proofs which require the proof context to be present ($sets\_pc$ is not tested on the assumption that
$sets\_epc$ is its evaluated form).
=SML
push_proof_context sets_epc;
open_theory "sets";
store_mt_results mt_run [
	("sets_epc 1",
	tac_solve (rewrite_tac[] THEN REPEAT strip_tac),
	([],¨(p ° q) = (q ° p)Æ),
	true)
	];
store_mt_results mt_run [
	("sets_epc 2",
	tac_solve (REPEAT strip_tac THEN all_undisch_tac THEN rewrite_tac[]),
	([],¨p ç {x | x ç {p}}Æ),
	true)
];
=TEX
\section{END OF TESTS}
=SML
set_flag("subgoal_package_quiet",lsubgoal_package_quiet);
diag_string(summarize_mt_results ());
=TEX
\end{document}
=IGN
***********COPY**************
store_mt_results mt_run [("",
	tac_res ,
	¨Æ,
	¨Æ)];
store_mt_results mt_run [("",
	tac_res1 ,
	([¨Æ],¨Æ),
	([¨Æ],¨Æ))];
store_mt_results mt_run [
	("",
	tac_solve ,
	([],¨Æ),
	true),
];
store_mt_results mt_run_fail [("",
	tac_fail ,
	([],¨Æ),
	gen_fail_msg ""  [])];

store_mt_results mt_run [("",
	,
	,
	)];
store_mt_results mt_run_fail [("",
	,
	,
	gen_fail_msg ""  [])];


