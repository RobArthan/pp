=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\underscoreoff
\TPPproject{FST Project}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Demonstration Script for the ICL HOL System}  %% Mandatory field
\def\TPPheadtitle{Demonstration Script for the ICL HOL System}
\TPPref{DS/FMU/IED/INT002}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{}
% \TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
\TPPauthors{R.D. Arthan&WIN 01\\R.B.Jones & WIN 01\\K. Blackburn & WIN 01}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{This document provides a demonstration script for the ICL HOL system,
and incidentally provides an integration test.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item[Issue 1.1]
First draft, based on wrk022.doc, wrk039.doc and 
unreferenced RDA work.
\item [Issue 1.2]
Removed an undesired $PolyML.timing$.
Changes to modal logic symbols.
\item [Issue 1.3]
Corrected $reset_compile$.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}\label{Scope}
This document provides a demonstration script for the ICL HOL system.
This demonstration is intended to be appropriate for
people with little or no knowledge of Cambridge or ICL HOL,
but with at least some slight aquaintance with the 
predicate calculus.

The script also serves as something of an integration test,
though the primary integration testing is accessed
through \cite{DS/FMU/IED/INT001}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document provides a demonstration script for the ICL HOL system.
The script also serves as something of an integration test.
\subsubsection{Dependencies}
The script provided requires a complete version the ICL HOL
system to be run.
\subsubsection{Deficiencies}
None known.
\subsubsection{Changes Forecast}
As the ICL HOL system changes, and in particular new areas worthy of
demonstration are introduced.

\subsection{The HOL Proof Tool}
HOL (Higher Order Logic) is a polymorphic version of Church's type theory
due to M.J.C. Gordon  \cite{gordon87}. A system produced
by Cambridge University supporting
machine-checked reasoning in HOL has been available in the public domain for
several years \cite{SRI89a}. The Cambridge HOL system has been widely
used for a range of verification tasks in academia and has
been successfully exploited by a number of industrial users including
the High Assurance Team at ICL.

ICL are currently engaged in a research programme into formal proof
technology which includes a re-engineering of the HOL proof tool to
meet more fully the requirements of industrial use and to give a basis
for exploiting more recent research on the HOL technology. The ICL HOL
proof tool has been specifically designed with a view to its use to
provide support for specification and proof in formalisms other
than the HOL logic itself.
After a significant prototyping exercise early in the project,
a first version of this system is close to $¬$-testing release.


Space does not permit us to give a full exposition of the operation
of the HOL proof tool here. However, we hope that some aspects of
this will be clear from the examples we give. It may be worth mentioning
some basic concepts:

The system is implemented in the interactive
functional programming language Standard ML (or, strictly speaking, an
extension of Standard ML giving a special syntax for entering
HOL terms and types and supporting the use of an extended character
set for mathematical notations). ML, often referred to
as the {\em metalanguage}, also acts as the command language through which
the user interacts with the system.

The types and terms of the HOL language are implemented as abstract
data types, $TYPE$ and $TERM$.
The constructors of the
data type of terms guarantee that all values of type $TERM$ obey
the typing rules of the HOL language. Proof is conducted, at the most
primitive level, by computing theorems, i.e. values of an abstract
data type, $THM$. The constructors of this abstract data type implement
the primitive inference rules of the
logic. Thus, the only way to compute a theorem is via a sequence of
primitive inferences, and so any value of type $THM$ is indeed a theorem
of the HOL logic. On top of this logical kernel are implemented a wide
range of proof procedures which assist the user in performing proofs.
The great merit of this approach to implementing a proof tool is that the logical
kernel guarantees that the soundness of the system cannot be compromised
by infelicities in the coding of these derived proof procedures.

\section{THE ORGANISATION OF THE SCRIPT}

The present document is a
{\em literate script} containing a mixture of narrative
text and input for the ICL HOL system.
The appendix contains a listing of the HOL theories set up by the script
and section \ref{INDEX} contains an index of the objects defined in the script.
Defining occurrences of names are shown in {\bf bold}.

The input for HOL consists of a sequence of commands in an extension
of the interactive programming language Standard ML.
HOL terms appear enclosed by the symbols `¨' and `Æ' 
and HOL types by `î' and `Æ', the text between the symbols being parsed as HOL and
resulting in an ML value of type $TERM$ or $TYPE$.

HOL constants are introduced using constant definition
boxes which have the form:
=SML
(*
πHOLCONST 

	c : ty
˜
	P
∞
=SML
*)
=TEX
The intention of this is to introduce a new constant, $c$, 
of type $ty$, satisfying the property $P$.

The definitions introduced by these boxes are {\em conservative}.
The HOL system maintains a distinction between conservative extensions
and the introduction of arbitrary axioms.

\section{THE SCRIPT : ARITHMETIC RESULTS}
\subsection{Prologue}
=SML
open_theory"hol";
new_theory €"arith_demo"›;
repeat drop_main_goal;
=TEX
The first command in the example makes current a proof
context in which rewriting will automatically cause
arithmetic expressions with literal operands
to be evaluated:
=SML
push_pc "hol1";
=TEX

\subsection{Functions for Compiling into a Proof Context}
The following extends the ICL HOL proof context mechanisms
by allowing specifications and other theorems
to be apparently compiled into the current proof context.
Though this is not an approach that is likely
to be appropriate for the development of a proof
it does allow the power of the proof context mechanism
to be demonstrated.

$recur_conv$ is used for positive arguments to
functions defined by recursion. It replaces a
positive literal, $ëmk_Ó\ iÆ$ say, by $ë(mk_Ó (i-1)Æ +1$
so allowing rewriting with a recursive clause of
the form $f(n+1) = r$:
=SML
val 	€recur_conv› : CONV = (fn m =>
	let	val tm = mk_plus(mk_Ó(dest_Ó m - 1), mk_Ó 1);
	in	eq_sym_rule (plus_conv tm)
	end
);
=TEX
=SML
recur_conv¨7Æ;
=TEX
In $lhs_conv$, $lhs$ is expected to be the left-hand
side of a clause in a function definition. The conversion
which is returned will attempt to apply $recur_conv$
to any actual arguments for which the formal argument
had the form $n+1$:
=SML
fun €lhs_conv› (lhs : TERM) : CONV = (
	if is_plus lhs
	then recur_conv
	else if is_app lhs
	then	let val (f, arg) = dest_app lhs
		in	APP_C(lhs_conv f, lhs_conv arg)
	end else id_conv
);
=TEX
=SML
lhs_conv ¨f (n+1, m+1) aÆ ¨f (1, 2) 4Æ;
=TEX
$lhs_pat$ computes the pattern to be associated with
the left-hand side of a definition. This is obtained
by replacing subterms of the form $a+b$ with a variable
so allowing these to be matched with anything.
=SML
fun €lhs_pat› (lhs : TERM) : TERM = (
	if is_plus lhs
	then mk_var("X", Ó)
	else if is_app lhs
	then (mk_app o (lhs_pat ** lhs_pat) o dest_app) lhs
	else if is_Ã lhs
	then (mk_Ã o (lhs_pat ** lhs_pat) o dest_Ã) lhs
	else lhs
);
=TEX
=SML
lhs_pat ¨f (n+1, m+1) aÆ;
=TEX
$compile_eqn$ produces a pattern-conversion pair
(for use in a rewriting context) from a single
theorem (which is expected to be an equation).
=SML
fun €compile_eqn› (thm : THM) : (TERM * CONV)= (
	let	val (lhs, rhs) = dest_eq (concl thm);
		val (f, args) = strip_app lhs;
		val vars = gen_vars (map type_of args) [];
	in	(lhs_pat lhs,
		lhs_conv lhs THEN_C eq_match_conv thm)
	end
);
=TEX
=SML
compile_eqn
(all_µ_elim(asm_rule¨µn m a∑f(n+1, m+1) a = f(n, m) a + aÆ));
snd it ¨f (1, 2) 4:ÓÆ;
=TEX
$compile_thm$ applies $compile_eqn$ to each equational
conjunct of a theorem (typically a partial recursive
definition)
=SML
fun €compile_thm› (thm : THM) : (TERM * CONV) list = (
	(map compile_eqn o strip_±_rule o all_µ_elim) thm
);
=TEX
We now set up a variable to contain the rewriting
context computed by the function $compile$.
This is initialised to the context we started with, ``hol1'', and
an additional conversion which tries hard to evaluate the condition in
an
=INLINEFT
if ... then ... else ...
=TEX
.
=SML
new_pc €"accumulate"›;


val code : (TERM * CONV) list ref = ref [
	(¨if a then b else cÆ, RATOR_C(RATOR_C(RAND_C(rewrite_conv[]))))];
set_rw_eqn_cxt (!code) "accumulate";


merge_pcs ["hol1"] "accumulate";
=TEX
Our ``compiler'' takes as its parameter either
a HOL constant, or
a string which is
the name of a a theorem (which it looks for
in the ancestry of the current theory) and extends the proof context
$accumulate$ with the result of compiling the 
constants specification, or by the saved theorem.
=SML
datatype €FUNC_OR_THM› = Function of TERM | Theorem of string;

fun €compile› (func_or_thm : FUNC_OR_THM) = (
	let	fun my_get_thm key (thy :: thys) = (
			(get_thm thy key)
			handle Fail _ => my_get_thm key thys
		) | my_get_thm key [] = get_thm "min" key;
		val def = case func_or_thm of
			Function tm => get_spec tm
			| Theorem key => my_get_thm key (get_ancestors"-");
		val this = compile_thm def;
		fun same ((t1, _), (t2, _)) = t1 ~=$ t2;
		val new = union same (!code) this;
		val sideeffect = set_rw_eqn_cxt new "accumulate";
	in	code := new;
		set_pc "accumulate"
	end
);
=TEX
Finally a function to reset the proof context ``accumulate''
back to its initial value.
=SML
fun €reset_compile› () = (
	code := [
	(¨if a then b else cÆ, RATOR_C(RATOR_C(RAND_C(rewrite_conv[]))))];
	set_rw_eqn_cxt (!code) "accumulate";
	set_pc "accumulate"
);
=TEX
\subsection{Cumulative Effects of Proof Contexts}
=SML
new_pc €"cumulative"›;
push_pc"cumulative";
=GFT HOL Input
rewrite_conv[]¨(Ãi j k∑ i*j + j*k +  i*k) 7 11 13Æ;
	(* fails - no rewriting occurs *)
=SML
set_rw_eqn_cxt[(¨(Ãx∑ y)zÆ, ¬_conv)]"cumulative";
set_pc"cumulative";
rewrite_conv[]¨(Ãi j k∑ i*j + j*k +  i*k) 7 11 13Æ;
set_rw_eqn_cxt[(¨(Ãx∑ y)zÆ, ¬_conv), (¨x * yÆ, times_conv)]"cumulative";
set_pc"cumulative";
rewrite_conv[]¨(Ãi j k∑ i*j + j*k +  i*k) 7 11 13Æ;
pop_pc();

delete_pc"cumulative";

push_pc"hol1";
rewrite_conv[]¨(Ãi j k∑ i*j + j*k +  i*k) 7 11 13Æ;
pop_pc();

=TEX
\subsection{Arithmetic and Compiling into Proof Contexts}
First we demonstrate what the supplied proof context can do:
=SML
rewrite_conv[]¨7 * 11 * 13Æ;
rewrite_conv[]¨7 * 11 * 13 < (42 - 37) * (10 + 1) * 99Æ;
rewrite_conv[]¨z + 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1Æ;
rewrite_conv[]¨
	if 2 * 3 º 6
	then (99 Div 12, 99 Mod 12)
	else (1, 1)Æ;
=TEX
Let us now extend the system by introducing a factorial function:
=SML
declare_postfix(400, "!");
=TEX
πHOLCONST
	$!: Ó ≠ Ó
˜
µm∑
		0! = 1
	±	(m + 1)! = (m + 1) * m!
∞
=SML
print_theory"-";
=TEX
Let us check our theorem compiler from the previous section:
=SML
compile_thm (get_spec ¨$!Æ);
val [(_, c1), (_, c2)] = it;
c1 ¨0!Æ;
c2 ¨3!Æ;
=TEX
Now onto our accumulating proof context. 
=SML
push_pc "accumulate";
=TEX
First we introduce factorial reasoning:
=GFT HOL Input
rewrite_conv[]¨0!Æ;	(* Fails: need to compile in specification for ¨!Æ *)
=SML
compile (Function ¨$!Æ);
rewrite_conv[]¨0!Æ;
rewrite_conv[]¨1!Æ;
rewrite_conv[]¨6!Æ;
rewrite_conv[]¨10!Æ;
rewrite_conv[]¨20!Æ;
=TEX
$Enter$ is the inner loop of a bubble sort. It is
parameterised by an ordering relation.
=SML
πHOLCONST
	€Enter›:('a ≠ 'a ≠ BOOL) ≠ 'a ≠ 'a LIST ≠ 'a LIST
˜
µrel x y ys∑
	Enter rel x [] = [x]
±	Enter rel x (Cons y ys) =
		if 	rel x y
		then	Cons x (Cons y ys)
		else	Cons y (Enter rel x ys)
∞
=SML
compile (Function ¨EnterÆ);
rewrite_conv[]¨Enter ($<) 1 []Æ;
rewrite_conv[]¨Enter ($<) (3!) [2;3;4;10;20]Æ;

=TEX
$Sort$ is a bubble sort. Like $Enter$ it is
parameterised by an ordering relation.
=SML
πHOLCONST
	€Sort›:('a ≠ 'a ≠ BOOL) ≠ 'a LIST ≠ 'a LIST
˜
µrel x xs∑
	Sort rel [] = []
±	Sort rel (Cons x xs) = Enter rel x (Sort rel xs)
∞
=SML
compile (Function ¨SortÆ);
rewrite_conv[]¨Sort ($<) []Æ;
rewrite_conv[]¨Sort ($<) [3!;2;3;4;10;20]Æ;
=TEX
=SML
declare_infix (320, "**");
πHOLCONST
	$€**›:Ó ≠ Ó ≠ Ó
˜
µm n∑
	m ** 0 = 1
±	m ** (n+1) = m * m ** n
∞
=SML
compile (Function ¨$**Æ);
rewrite_conv[]¨2**4Æ;
rewrite_conv[] ¨[2**1; 2**2; 2**3; 2**4]Æ;
rewrite_conv[] ¨[2**1; 2**2; 2**3; 2**4]Æ;
rewrite_conv[]
	¨Sort ($<)[1!; 2!; 3!; 4!; 2**1; 2**2; 2**3; 2**4]Æ;
=TEX
As a final example, we define the binomial function,
which we write as an infix $C$:
=SML
declare_infix (330, "C");
πHOLCONST
	$€C›:Ó ≠ Ó ≠ Ó
˜
µn j∑
	0 C 0 = 1
±	(n+1) C 0 = 1
±	0 C (j+1) = 0
±	(n+1) C (j+1) = n C j + n C (j+1)
∞
The following gives the first few rows of
Pascal's triangle.
=SML
compile (Function ¨$CÆ);
rewrite_conv[] ¨ [
[0 C 0; 0 C 1; 0 C 2];
[1 C 0; 1 C 1; 1 C 2];
[2 C 0; 2 C 1; 2 C 2]]Æ;
=TEX
To do eight rows takes a minute or two, since
the ``algorithm'' implicit in just writing out all
64 applications of $C$ involves a great deal of
recomputation.
=GFT HOL Input
rewrite_conv[] ¨ [
[0 C 0; 0 C 1; 0 C 2; 0 C 3; 0 C 4; 0 C 5; 0 C 6; 0 C 7];
[1 C 0; 1 C 1; 1 C 2; 1 C 3; 1 C 4; 1 C 5; 1 C 6; 1 C 7];
[2 C 0; 2 C 1; 2 C 2; 2 C 3; 2 C 4; 2 C 5; 2 C 6; 2 C 7];
[3 C 0; 3 C 1; 3 C 2; 3 C 3; 3 C 4; 3 C 5; 3 C 6; 3 C 7];
[4 C 0; 4 C 1; 4 C 2; 4 C 3; 4 C 4; 4 C 5; 4 C 6; 4 C 7];
[5 C 0; 5 C 1; 5 C 2; 5 C 3; 5 C 4; 5 C 5; 5 C 6; 5 C 7];
[6 C 0; 6 C 1; 6 C 2; 6 C 3; 6 C 4; 6 C 5; 6 C 6; 6 C 7];
[7 C 0; 7 C 1; 7 C 2; 7 C 3; 7 C 4; 7 C 5; 7 C 6; 7 C 7]]Æ;
=TEX
\subsection{Prime Numbers}
=SML
open_theory "arith_demo";
new_theory €"prime"›;
=TEX
First we define the notion of a factor of a number.
It is convenient only to consider the proper factors (i.e.
those greater than 1):
=SML
declare_infix(200, "Factor");
πHOLCONST
	$Factor : Ó ≠ Ó ≠ BOOL
˜
	µm n∑m Factor n § 1 < m ± n Mod m = 0
∞
=SML
compile (Function ¨$FactorÆ);
rewrite_conv[]¨2 Factor 6Æ;
rewrite_conv[]¨5 Factor 6Æ;
=TEX
A number may now be defined to be prime if it is greater than
1 and if its only proper factor is itself:
=SML
πHOLCONST
	$Prime : Ó ≠ BOOL
˜
	µm∑Prime m § 1 < m ± µi∑i Factor m ¥ i = m
∞
We are going to implement a primality tester using a bounded search
operator, which we now define.
$Search\ m\ n\ p$ searches between the numbers $m$ and
$n$ inclusive for the first number to satisfy $p$ (and
returns $n+1$ if no such number exists).
=SML
πHOLCONST
	Search : Ó ≠ Ó ≠ (Ó ≠ BOOL) ≠ Ó
˜
	µm n p∑Search m n p =
		if	n < m
		then	n+1
		else if	p m
		then	m
		else	Search (m+1) n p
∞
Verifying the consistency of the above definition is a fairly straightforward
application of the principle of primitive recursion.
=SML
push_consistency_goal ¨SearchÆ;
a(lemma_tac ¨
	∂a∑
	µ i n p∑
		a 0 n p	= n + 1
	±	a (i+1) n p	= if p (n - i)
				  then (n - i)
				  else a i n pÆ);
(* *** Goal "1" *** *)
a(asm_prove_∂_tac);
(* *** Goal "2" *** *)
a(∂_tac¨Ãm n p∑ a (if n < m then 0 else (n - m) + 1) n pÆ);
a(REPEAT strip_tac);
a(cases_tac¨n < mÆ THEN asm_rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[≥_less_thm, º_def]));
a(POP_ASM_T (fn th => rewrite_tac[eq_sym_rule th]));
a(LEMMA_T ¨(if i < 1 then 0 else ((m + i) - m + 1) + 1) = iÆ
	rewrite_thm_tac);
a(strip_asm_tac(µ_elim¨iÆÓ_cases_thm) THEN asm_rewrite_tac[]);
a(LEMMA_T¨m + i' + 1 = m + 1 + i'Ærewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[plus_assoc_thm1]);
save_consistency_thm ¨SearchÆ(pop_thm());
=TEX
We don't want $Search$'s specification in the standard rewrites just yet.
=SML
push_pc "accumulate";
get_spec¨SearchÆ;
compile (Function ¨SearchÆ);
rewrite_conv[]¨Search 1 10 (Ãi∑i > 5)Æ;
rewrite_conv[]¨Search 2 11 (Ãi∑i Factor 11)Æ;
pop_pc();
=TEX
The search function is a little tricky to reason about. We want to
prove that, if a propositional function $p$ is satisfied by a
number between $m$ and $n$, then $Search\,m\,n\,p$ is such
a number. However, inductive reasoning about $Search$ has to be
done by induction on the difference between $n$ and $m$ and care is
needed to handle the various edge cases. We therefore sneak up on
the problem by proving some lemmas first.

The first lemma says that the result returned by $Search$ is bounded
below by the lower bound of the $Search$ interval (provided the interval
is non-empty):
=SML
push_goal([], ¨
	µp n j∑	j º n ¥
		(n-j) º (Search (n-j) n p)
Æ);
a(REPEAT µ_tac);
a(induction_tac¨jÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[]);
a(once_rewrite_tac[get_spec¨SearchÆ]);
a(rewrite_tac[]);
a(cases_tac¨p nÆ);
(* *** Goal "1.1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(asm_rewrite_tac[]);
a(once_rewrite_tac[get_spec¨SearchÆ]);
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[plus1_º_thm]));
(* *** Goal "3" *** *)
a(once_rewrite_tac[get_spec¨SearchÆ]);
a(REPEAT strip_tac);
a(LEMMA_T ¨≥ n < n - j + 1Æ rewrite_thm_tac);
(* *** Goal "3.1" *** *)
a(asm_ante_tac¨j + 1 º nÆ THEN rewrite_tac[º_def]);
a(REPEAT strip_tac);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
(* *** Goal "3.2" *** *)
a(LEMMA_T¨(n - (j + 1)) + 1 = n - jÆ asm_tac);
(* *** Goal "3.2.1" *** *)
a(asm_ante_tac¨j + 1 º nÆ THEN rewrite_tac[º_def]);
a(REPEAT strip_tac);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[plus_assoc_thm]);
(* *** Goal "3.2.2" *** *)
a(CASES_T¨p (n - j + 1)Æ rewrite_thm_tac);
a(asm_rewrite_tac[]);
a(strip_asm_tac(list_µ_elim[¨n-(j+1)Æ, ¨n-jÆ, ¨Search (n - j) n pÆ]º_trans_thm));
a(swap_asm_concl_tac ¨≥ n - j + 1 º n - jÆ);
a(GET_ASM_T ¨(n - j + 1) + 1 = n - jÆ (rewrite_thm_tac o eq_sym_rule));
val €search_lemma1› = pop_thm();
=TEX
The second lemma about $Search$ says that if the result of a search
in a non-empty interval is not greater than the upper bound of the interval then
the search was successful:
=SML
push_goal([], ¨
	µp n j∑	j º n ¥
		((Search (n-j) n p) º n ¥ p(Search (n-j) n p))
Æ);
a(REPEAT µ_tac);
a(induction_tac¨jÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[]);
a(once_rewrite_tac[get_spec¨SearchÆ]);
a(rewrite_tac[]);
a(cases_tac¨p nÆ THEN asm_rewrite_tac[]);
a(once_rewrite_tac[get_spec¨SearchÆ]);
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(strip_tac);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[plus1_º_thm]));
(* *** Goal "3" *** *)
a(REPEAT strip_tac);
a(once_rewrite_tac[get_spec¨SearchÆ]);
a(GET_ASM_T ¨j + 1 º nÆ (strip_asm_tac o rewrite_rule[º_def]));
a(POP_ASM_T (fn th => all_asm_ante_tac THEN
	rewrite_tac[eq_sym_rule th] THEN REPEAT strip_tac));
a(cases_tac¨p iÆ THEN asm_rewrite_tac[]);
a(swap_nth_asm_concl_tac 3);
a(rewrite_tac[plus_assoc_thm]);
a(swap_nth_asm_concl_tac 3);
a(once_rewrite_tac[get_spec¨SearchÆ]);
a(asm_rewrite_tac[plus_assoc_thm]);
a(rewrite_tac[µ_elim¨1Æ plus_order_thm]);
a(asm_rewrite_tac[µ_elim¨jÆ plus_order_thm]);
(* *** Goal "4" *** *)
a(REPEAT strip_tac);
a(once_rewrite_tac[get_spec¨SearchÆ]);
a(GET_ASM_T ¨j + 1 º nÆ (strip_asm_tac o rewrite_rule[º_def]));
a(POP_ASM_T (fn th => all_asm_ante_tac THEN
	rewrite_tac[eq_sym_rule th] THEN REPEAT strip_tac));
a(cases_tac¨p iÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 3 ante_tac);
a(rewrite_tac[plus_assoc_thm]);
a(rewrite_tac[µ_elim¨iÆ plus_order_thm]);
val €search_lemma2› = pop_thm();
=TEX
The third lemma about $Search$ says that the search interval contains
a number with the desired property iff. the search returns an element
in the interval with the desired property.
=SML
push_goal([], ¨
	µp n j∑	j º n ¥
	((∂i∑(n-j) º i ± i º n ± p i)
		§	(Search (n-j) n p) º n ± p(Search (n-j) n p))
Æ);
a(REPEAT µ_tac THEN ¥_tac THEN §_tac);
(* *** Goal "1" *** *)
a(asm_ante_tac¨j º nÆ THEN rewrite_tac[
	rewrite_rule[
	taut_rule¨µa b c∑(a ¥ b ¥ c) § (a ¥ (b ± c)) § (a ¥ b)Æ
	]search_lemma2]);
a(asm_ante_tac ¨n - j º iÆ THEN induction_tac¨jÆ);
(* *** Goal "1.1" *** *)
a(rewrite_tac[]);
a(strip_tac THEN LEMMA_T¨n = iÆ rewrite_thm_tac);
(* *** Goal "1.1.1" *** *)
a(strip_asm_tac (list_µ_elim[¨iÆ, ¨nÆ] º_antisym_thm));
a(asm_rewrite_tac[]);
(* *** Goal "1.1.2" *** *)
a(once_rewrite_tac[get_spec¨SearchÆ]);
a(asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(REPEAT strip_tac);
a(DROP_ASM_T¨≥ n - j º iÆ (strip_asm_tac o rewrite_rule[≥_º_thm]));
a(lemma_tac¨i º n - (j+1)Æ);
(* *** Goal "1.2.1" *** *)
a(GET_ASM_T ¨j + 1 º nÆ (strip_asm_tac o rewrite_rule[º_def]));
a(asm_ante_tac ¨i < n - jÆ);
a(POP_ASM_T(fn th => rewrite_tac[eq_sym_rule th]));
a(rewrite_tac[plus_assoc_thm]);
a(rewrite_tac[less_def]);
(* *** Goal "1.2.2" *** *)
a(strip_asm_tac(list_µ_elim[¨n-j+1Æ, ¨iÆ]º_antisym_thm));
a(TOP_ASM_T rewrite_thm_tac);
a(once_rewrite_tac[get_spec¨SearchÆ]);
a(LEMMA_T ¨≥n < iÆ asm_rewrite_thm_tac);
a(asm_rewrite_tac[≥_less_thm]);
(* *** Goal "1.3" *** *)
a(REPEAT strip_tac);
a(lemma_tac¨j º nÆ);
a(strip_asm_tac(list_µ_elim[¨jÆ, ¨j+1Æ, ¨nÆ]º_trans_thm));
a(POP_ASM_T ante_tac THEN rewrite_tac[]);
(* *** Goal "1.4" *** *)
a(REPEAT strip_tac);
a(once_rewrite_tac[get_spec¨SearchÆ]);
a(LEMMA_T¨≥ n < n - j + 1Ærewrite_thm_tac);
(* *** Goal "1.4.1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[º_def]));
a(POP_ASM_T (fn th => rewrite_tac[eq_sym_rule th] 
	THEN REPEAT strip_tac));
(* *** Goal "1.4.2" *** *)
a(CASES_T ¨p (n - j + 1)Æ rewrite_thm_tac);
(* *** Goal "1.4.2.1" *** *)
a(strip_asm_tac(list_µ_elim[¨n-j+1Æ, ¨iÆ, ¨nÆ]º_trans_thm));
(* *** Goal "1.4.2.2" *** *)
a(asm_ante_tac¨Search (n - j) n p º nÆ);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[º_def]));
a(POP_ASM_T (fn th => rewrite_tac[eq_sym_rule th]));
a(rewrite_tac[plus_assoc_thm]);
a(rewrite_tac[µ_elim¨1Æ plus_order_thm]);
(* *** Goal "2" *** *)
a(∂_tac¨(Search (n - j) n p)Æ THEN asm_rewrite_tac[]);
a(strip_asm_tac(all_µ_elim search_lemma1));
val €search_lemma3› = pop_thm();
=TEX
Our first main theorem about $Search$ captures the content of the above
three lemmas and also caters for the exceptional case where the
search interval is empty:
=SML
push_goal([], ¨
	µp m n∑	(∂i∑m º i ± i º n ± p i)
		§	(Search m n p) º n ± p(Search m n p)
Æ);
a(REPEAT µ_tac);
a(cases_tac¨n < mÆ);
(* *** Goal "1" *** *)
a(once_rewrite_tac[get_spec¨SearchÆ]);
a(asm_rewrite_tac[]);
a(contr_tac);
a(strip_asm_tac(all_µ_elim ≥_º_thm));
a(strip_asm_tac(all_µ_elim º_trans_thm));
(* *** Goal "2" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[≥_less_thm, º_def]));
a(lemma_tac¨m = n - i ± i º nÆ);
(* *** Goal "2.1" *** *)
a(POP_ASM_T (fn th => rewrite_tac[eq_sym_rule th]));
(* *** Goal "2.2" *** *)
a(POP_ASM_T ante_tac);
a(rename_tac[] THEN asm_rewrite_tac[search_lemma3]);
val €search_thm1› = save_thm ("search_thm1", pop_thm());
=TEX
For computational purposes, $search_thm1$
is not ideal since it requires computation of $Search$ twice (although
that is easy to remedy) and also, worse, it requires an unnecessary
evaluation of $p$. The following formulation is preferable for computational
purposes:
=TEX
=SML
push_goal([], ¨
	µp m n∑	(∂i∑m º i ± i º n ± p i)
		§	m º n ± (Search m n p) º n
Æ);
a(REPEAT µ_tac);
a(cases_tac¨m º nÆ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[search_thm1, taut_rule¨µa b∑(a ± b § a) § (a ¥ b)Æ]);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[º_def]));
a(lemma_tac¨m = n - i ± i º nÆ);
(* *** Goal "1.1" *** *)
a(POP_ASM_T (fn th => rewrite_tac[eq_sym_rule th]));
(* *** Goal "1.2" *** *)
a(asm_ante_tac¨i º nÆ THEN asm_rewrite_tac[search_lemma2]);
(* *** Goal "2" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[≥_º_thm]));
a(once_rewrite_tac[get_spec¨SearchÆ]);
a(asm_rewrite_tac[]);
a(contr_tac);
a(strip_asm_tac(all_µ_elim ≥_º_thm));
a(strip_asm_tac(all_µ_elim º_trans_thm));
val €search_thm2› = save_thm ("search_thm2", pop_thm());
=TEX
We now wish to apply $Search$ to give a program to test for
primality. To do this we must supply bounds 
for the search for a proper factor. This requires some lemmas:
=SML
push_goal([], ¨
	µm n∑	0 < n ¥
		(m Mod n = 0 § ∂i∑i * n = m)
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac(list_µ_elim[¨mÆ, ¨nÆ]div_mod_thm));
a(∂_tac¨m Div nÆ THEN POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(¥_T (accept_tac o eq_sym_rule));
(* *** Goal "2" *** *)
a(strip_asm_tac(list_µ_elim[¨mÆ, ¨nÆ]div_mod_thm));
a(lemma_tac¨m = i * n + 0Æ);
(* *** Goal "2.1" *** *)
a(GET_ASM_T ¨i * n = mÆ rewrite_thm_tac);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(list_µ_elim[¨mÆ, ¨nÆ, ¨iÆ, ¨0Æ]div_mod_unique_thm));
a(POP_ASM_T rewrite_thm_tac);
val €mod_eq_0_lemma› = pop_thm();
=TEX
=SML
push_goal([], ¨
	µm n i∑ 0 < n ¥ i * n = m ¥ i º m
Æ);
a(conv_tac(µ_reorder_conv¨µi m n∑ 0 < n ¥ i * n = m ¥ i º mÆ));
a(strip_tac THEN induction_tac¨i:ÓÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[times_def]);
a(REPEAT strip_tac);
a(list_spec_nth_asm_tac 3[¨i*nÆ, ¨nÆ]);
a(lemma_tac¨i*n + 1 º m' ± i + 1 º i*n + 1Æ);
(* *** Goal "2.1" *** *)
a(asm_rewrite_tac[]);
a(DROP_ASM_T¨0 < nÆ(strip_asm_tac o rewrite_rule[less_def, º_def]));
a(rewrite_tac[º_def] THEN ∂_tac¨i'Æ THEN asm_rewrite_tac[plus_assoc_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(rewrite_rule[]
	(list_µ_elim[¨i+1Æ, ¨i*n+1Æ, ¨m'Æ]º_trans_thm)));
val €times_º_lemma› = pop_thm();
=TEX
We can now give a computable test for primality:
=SML
push_goal([], ¨
	µm∑	Prime m
		§
		≥(	m < 2
		 ≤	2 º (m-1) ± Search 2 (m-1) (Ãf∑f Factor m) º (m-1))
Æ);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv)search_thm2,
	get_spec ¨PrimeÆ, get_spec ¨$FactorÆ,
	mod_eq_0_lemma]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_ante_tac ¨1 < mÆ THEN rewrite_tac[≥_less_thm, less_def, º_def]);
(* *** Goal "2" *** *)
a(spec_nth_asm_tac 4 ¨iÆ);
a(GET_NTH_ASM_T 6 (strip_asm_tac o rewrite_rule[less_def, º_def]));
a(POP_ASM_T (strip_asm_tac o eq_sym_rule));
a(swap_asm_concl_tac¨i º m - 1Æ THEN asm_rewrite_tac[]);
a(LEMMA_T¨2 = 1 + 1Æ (fn th => pure_rewrite_tac[th, plus_assoc_thm]));
(* *** Goal "2.1" *** *)
a(rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[]);
(* *** Goal "3" *** *)
a(asm_ante_tac ¨≥ m < 2Æ THEN rewrite_tac[≥_less_thm, less_def, º_def]);
(* *** Goal "4" *** *)
a(lemma_tac¨2 º iÆ);
(* *** Goal "4.1" *** *)
a(asm_ante_tac¨1 < iÆ THEN rewrite_tac[less_def]);
(* *** Goal "4.2" *** *)
a(strip_asm_tac(rewrite_rule[](list_µ_elim[¨0Æ, ¨1Æ, ¨iÆ]less_trans_thm)));
a(strip_asm_tac(list_µ_elim[¨mÆ, ¨iÆ]mod_eq_0_lemma));
(* *** Goal "4.2.1" *** *)
a(spec_nth_asm_tac 1 ¨i'Æ);
(* *** Goal "4.2.2" *** *)
a(POP_ASM_T (strip_asm_tac o once_rewrite_rule[times_comm_thm]));
a(strip_asm_tac(list_µ_elim[¨mÆ, ¨i'Æ, ¨iÆ]times_º_lemma));
(* *** Goal "4.2.2.1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[≥_less_thm]));
a(asm_ante_tac¨i * i' = mÆ THEN asm_rewrite_tac[]);
a(¥_T(asm_tac o eq_sym_rule) THEN asm_ante_tac ¨≥ m < 2Æ THEN asm_rewrite_tac[]);
(* *** Goal "4.2.2.2" *** *)
a(spec_nth_asm_tac 7 ¨iÆ);
a(lemma_tac¨≥ i + 1 º mÆ);
(* *** Goal "4.2.2.2.1" *** *)
a(LEMMA_T¨m = (m-1)+1Æ once_rewrite_thm_tac);
(* *** Goal "4.2.2.2.1.1" *** *)
a(GET_ASM_T ¨≥ m < 2Æ (strip_asm_tac o rewrite_rule[≥_less_thm, º_def]));
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(LEMMA_T¨2 = 1 + 1Æ (fn th => pure_rewrite_tac
		[th, plus_assoc_thm] THEN rewrite_tac[]));
a(rewrite_tac[]);
(* *** Goal "4.2.2.2.1.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "4.2.2.2.2" *** *)
a(strip_asm_tac(list_µ_elim[¨iÆ, ¨mÆ]≥_plus1_º_thm));
a(strip_asm_tac(list_µ_elim[¨iÆ, ¨mÆ]º_antisym_thm));
val €prime_thm1› = save_thm ("prime_thm1", pop_thm());
=TEX
=SML
val €prime_thm2› = save_thm ("prime_thm2", (
push_goal([], ¨
	µm∑	Prime m
		§
		if	m < 2
		then	F
		else if 2 º (m-1)
		then ≥Search 2 (m-1) (Ãf∑f Factor m) º (m-1)
		else T
Æ);
a(rewrite_tac[taut_rule¨µa b c∑(if a then F else if b then ≥c else T) § ≥(a ≤ (b ± c))Æ,
	prime_thm1]);
pop_thm()
));
=TEX
=SML
compile (Theorem "prime_thm2");
(* compile (Function ¨SearchÆ);
compile (Function ¨$FactorÆ); *)
rewrite_conv[]¨Prime 0Æ;
rewrite_conv[]¨Prime 1Æ;
rewrite_conv[]¨Prime 2Æ;
rewrite_conv[]¨Prime 3Æ;
rewrite_conv[]¨Prime 4Æ;
rewrite_conv[]¨Prime 5Æ;
rewrite_conv[]¨Prime 6Æ;
rewrite_conv[]¨2**(2**1) + 1Æ;
rewrite_conv[]¨Prime 5Æ;
rewrite_conv[]¨2**(2**2) + 1Æ;
rewrite_conv[]¨Prime 17Æ;
(RAND_C (rewrite_conv[]) THEN_C rewrite_conv[])¨Prime (2**(2**2) + 1)Æ;
=GFT HOL Input
rewrite_conv[]¨Prime (2**(2**2) + 1)Æ; (* loops *)
rewrite_conv[]¨2**(2**3) + 1Æ;
rewrite_conv[]¨Prime 257Æ;
rewrite_conv[]¨2**(2**4) + 1Æ;
rewrite_conv[]¨Prime 65537Æ;
rewrite_conv[]¨2**(2**5) + 1Æ;
rewrite_conv[]¨Prime 4294967297Æ;
rewrite_conv[]¨Prime 101Æ;
=TEX
\subsection{Axiomatised Results}
Now to demonstration the behaviour of axiomatised results,
and cacheing possibilites:
=SML
open_theory "arith_demo";
new_theory €"false"›;
val €false_axiom› = new_axiom(["false","false_axiom"],¨FÆ);
open_theory"arith_demo";
new_theory €"arith_demo2"›;
new_parent "false";

fun €mk_thm› (t:TERM) : THM = contr_rule t false_axiom;

infix C;
fun	0 C 0 = 1
|	n C 0 = 1
|	0 C n = 0
|	n C j = ((n-1) C (j-1)) + ((n-1) C j);

local val opC = ¨$CÆ
in
fun C_conv t = 
	let	val (opr,b) = dest_app t;
	in	let val (opr, a) = dest_app opr;
		in	(if opr =$ opC
			then	mk_thm (mk_eq (t,mk_Ó((dest_Ó a) C (dest_Ó b)))) 
			else	fail_conv t)
		end
	end;
end;
=GFT HOL Input
ONCE_MAP_C C_conv ¨[
[0 C 0; 0 C 1; 0 C 2; 0 C 3; 0 C 4; 0 C 5; 0 C 6; 0 C 7];
[1 C 0; 1 C 1; 1 C 2; 1 C 3; 1 C 4; 1 C 5; 1 C 6; 1 C 7];
[2 C 0; 2 C 1; 2 C 2; 2 C 3; 2 C 4; 2 C 5; 2 C 6; 2 C 7];
[3 C 0; 3 C 1; 3 C 2; 3 C 3; 3 C 4; 3 C 5; 3 C 6; 3 C 7];
[4 C 0; 4 C 1; 4 C 2; 4 C 3; 4 C 4; 4 C 5; 4 C 6; 4 C 7];
[5 C 0; 5 C 1; 5 C 2; 5 C 3; 5 C 4; 5 C 5; 5 C 6; 5 C 7];
[6 C 0; 6 C 1; 6 C 2; 6 C 3; 6 C 4; 6 C 5; 6 C 6; 6 C 7];
[7 C 0; 7 C 1; 7 C 2; 7 C 3; 7 C 4; 7 C 5; 7 C 6; 7 C 7]]Æ;
=SML
fun fact 0 = 1
| fact n = n * fact(n-1);

local val opfact = ¨$!Æ
in
fun fact_conv t = 
	let	val (opr,a) = dest_app t;
	in	if opr =$ opfact
		then	mk_thm (mk_eq (t,mk_Ó(fact (dest_Ó a)))) 
		else	fail_conv t
	end;
end;
=SML
(* compile (Function ¨$!Æ); *)
rewrite_conv [] ¨10!Æ;
fact_conv ¨300!Æ;

fun €CACHE_C› (cnv:CONV):CONV = (
let	val cache = ref empty_net;
in
	(fn tm =>
	let	val poss = net_lookup (!cache)  tm
	in
	snd(find poss (fn (p,q) => p =$ tm))
	handle complaint =>
	(let val cnv_tm = cnv tm;
		val dummy = (cache:= net_enter (tm,(tm,cnv_tm)) (!cache));
	in
		cnv_tm
	end)
	end)
end);
val cache_fact_conv = CACHE_C fact_conv;
PolyML.timing true;
cache_fact_conv ¨300!Æ;
cache_fact_conv ¨300!Æ;
PolyML.timing false;


open_theory"arith_demo";
rewrite_conv []¨10!Æ;
=TEX
=GFT HOL Input
fact_conv ¨100!Æ; (* fails as Ù F out of scope *)
=TEX
=SML
get_ancestors"-";
get_ancestors"arith_demo2";
flat(map get_axioms (get_ancestors "arith_demo"));
flat(map get_axioms (get_ancestors "arith_demo2"));
=TEX

\section{THE SCRIPT : PREDICATE CALCULUS}
This section includes some examples of pure predicate calculus proofs,
proofs in set theory, and proofs of results involving
computation of arithmetic facts.
=SML
open_theory"hol";
repeat drop_main_goal;
push_pc "hol";
=TEX
The following definitions are included to enable a step by step demonstration of the effects of stripping.
=SML
val €strip_concl_tac› = STRIP_CONCL_T check_asm_tac;
fun €strip_asm_tac› t = DROP_ASM_T t (STRIP_THM_THEN check_asm_tac);
val €first_strip_asm_tac› =
	GET_ASMS_T (FIRST o (map (strip_asm_tac o concl)));
val €step_strip_tac› = strip_concl_tac ORELSE first_strip_asm_tac;
=TEX
The following are included to demonstrate the resolution package.
=SML
fun res_rule t = tac_proof (([],t), prove_tac[]);
=SML
taut_rule ¨a ± b ± c ± d ± e ± f ¥ g
	§ a ¥ b ¥ c ¥ d ¥ e ¥ f ¥ gÆ;
res_rule ¨a ± b ± c ± d ± e ± f ¥ g
	§ a ¥ b ¥ c ¥ d ¥ e ¥ f ¥ gÆ;
=TEX
A nice little result:
=SML
res_rule ¨(∂x∑µy∑ P x y) ¥ µx∑∂y∑ P y xÆ;
=TEX
The first full example is intended to demonstrate how simple predicate calculus proofs are.
=SML
push_goal([],¨
	(∂z∑ p z)±(∂z∑ q z)
	¥	(((µz∑ p z ¥ r z) ± (µz∑ q z ¥ s z))
		§ (µz w∑ p z ± q w ¥ r z ± s w))
		Æ);
a contr_tac;

a (list_spec_asm_tac
	¨µ z∑ p z ¥ r zÆ [¨z''Æ]);
a (list_spec_asm_tac
	¨µ z∑ q z ¥ s zÆ [¨wÆ]);
a (list_spec_asm_tac
	¨µ z w∑ p z ± q w ¥ r z ± s wÆ [¨z''Æ,¨z'Æ]);
a (list_spec_asm_tac
	¨µ z w∑ p z ± q w ¥ r z ± s wÆ [¨zÆ,¨z''Æ]);
val P11_71 = pop_thm();
=TEX
To show that stripping in slow motion:
=GFT
push_goal([],¨
	(∂z∑ p z)±(∂z∑ q z)
	¥	(((µz∑ p z ¥ r z) ± (µz∑ q z ¥ s z))
		§ (µz w∑ p z ± q w ¥ r z ± s w))
		Æ);
a step_strip_tac;
a step_strip_tac;
a step_strip_tac;
a step_strip_tac;
    ....
=TEX
Finally, do it by resolution:
=SML
push_goal([],¨
	(∂z∑ p z)±(∂z∑ q z)
	¥	(((µz∑ p z ¥ r z) ± (µz∑ q z ¥ s z))
		§ (µz w∑ p z ± q w ¥ r z ± s w))
		Æ);
a(prove_tac []);
val P11_71 = pop_thm();
=TEX
Elementary set theory results are demonstrated next.
First the ones that stripping is good enough for.
=SML
push_pc "hol1";

(* results provable by stripping *)

val terms1 =
	[
		¨a ¿ a = a ¿ {}Æ,
		¨a ¿ {} = a ° aÆ,
		¨a ° a = a \ {}Æ,
		¨a \ {} = aÆ,
		¨a ° {} = a \ aÆ,
		¨a \ a = {} \ aÆ,
		¨{} \ a = {}Æ,
		¨a ¿ b = b ¿ aÆ,
		¨a ° b = b ° aÆ,
		¨a ¿ (b ¿ c) = (a ¿ b) ¿ cÆ,
		¨a ° (b ° c) = (a ° b) ° cÆ,
		¨a ¿ (b ° c) = (a ¿ b) ° (a ¿ c)Æ,
		¨a ° (b ¿ c) = (a ° b) ¿ (a ° c)Æ,
		¨(a ° b) ¿ (a \ b) = aÆ,
		¨(a \ b) ° b = {}Æ,
		¨a \ (b \ c) = (a \ b) ¿ (a ° c)Æ,
		¨(a \ b) \ c = (a \ (b ¿ c))Æ,
		¨a ¿ (b \ c) = (a ¿ b) \ (c \ a)Æ,
		¨a ° (b \ c) = (a ° b) \ cÆ,
		¨(a ¿ b) \ c = (a \ c) ¿ (b \ c)Æ,
		¨a \ (b ° c) = (a \ b) ¿ (a \ c)Æ,
		¨≥ x ç {}Æ,
		¨a Ä aÆ,
		¨≥ a † aÆ,
		¨{} Ä aÆ,
		¨ﬁ {} = {}Æ,
		¨• {} = UniverseÆ
	];
	
=SML
(* results provable using resolution *)

val terms2 =
	[	¨a Ä b § a ç  bÆ,
		¨a Ä b ± b Ä a § a = bÆ,
		¨≥ (a † b ± b † a)Æ,
		¨a Ä b ± b Ä c ¥ a Ä cÆ,
		¨a † b ± b † c ¥ a † cÆ,
		¨{} † a § ≥ a = {}Æ,
		¨ﬁ (a ¿ b) = (ﬁ a) ¿ (ﬁ b)Æ,
		¨• (a ¿ b) = (• a) ° (• b)Æ,
		¨ a Ä b ¥ ﬁ a Ä ﬁ b Æ,
		¨ a Ä b ¥ • b Ä • a Æ
	];
=TEX
=GFT
(* use this to step through individual proofs *)

set_goal([],¨
Æ);
a step_strip_tac;
a (rewrite_tac[]);
a set_tac;
=TEX
=SML
(* use this to do them all at once *)

(* by stripping *)

let fun rule x = tac_proof (([],x),(REPEAT strip_tac))
in map rule terms1
end;

(* by resolution *)

let fun rule x = tac_proof (([],x), prove_tac [])
in map rule terms2
end;

=TEX
Next a more difficult one from Principia Mathematica.
=SML
push_goal([],¨
	epsilon Ä alpha ± eta Ä beta ± ( alpha ° beta = {})
	¥ ((epsilon ¿ eta)\ alpha=eta) ±
		((epsilon ¿ eta)\ beta=epsilon)
		Æ);
a(prove_tac []);
val P24_494 = pop_thm();
=TEX
Or, done the hard way:
=SML
push_goal([],¨
	epsilon Ä alpha ± eta Ä beta ± ( alpha ° beta = {})
	¥ ((epsilon ¿ eta)\ alpha=eta) ±
		((epsilon ¿ eta)\ beta=epsilon)
		Æ);
a (rewrite_tac []);
(* (map (get_defn "sets") ["Ä","\\","¿","°","ç","Empty"]); *)

a contr_tac;
a (list_spec_nth_asm_tac 6 [¨xÆ]);
a (list_spec_nth_asm_tac 4 [¨xÆ]);
a (list_spec_nth_asm_tac 4 [¨xÆ]);
a (list_spec_nth_asm_tac 5 [¨xÆ]);
a (list_spec_nth_asm_tac 5 [¨xÆ]);
a (list_spec_nth_asm_tac 4 [¨xÆ]);
val P24_494 = pop_thm();
=TEX
=IGN
From wrk022.doc.
**************************************************
=TEX

\section{THE SCRIPT: MODAL LOGIC DEMONSTRATION}
As the HOL logic is well-established and uncontroversial
mathematically, and as the HOL proof tool
is constructed so as to maximise assurance in the
correctness of the theorems it proves with respect
to that logic, use of HOL to support other formalisms
means that the soundness of such support tools does not
have to be established on an {\em ad hoc} basis.

This section reports on a brief investigation into embedding the
possible worlds semantics for modal logic in HOL.
The purpose of the investigation was to demonstrate some of the new
capabilities of the ICL HOL proof tool and to show
by means of examples
how a semantic embedding of this sort is used to provide
proof support for formalisms other than HOL.

The treatment of the possible worlds semantics we give is by no means new.
It is essentially just a translation into HOL
of the sort of set-theoretic treatment which may be found
in any text-book on modal logic, for example, \cite{Boolos79}.


\subsection{Modal Logics}
Modal propositional calculus is the ordinary propositional calculus
augmented by an additional connective, $\Box$. If $A$ is a proposition
then $\Box A$, the {\em necessitation} of $A$, was originally intended
to connote the idea that $A$ was, in some sense, a necessary rather
than a contingent fact. The semantics for this calculus, due to
Kripke, explicates this notion of necessity in terms of systems,
called {\em frames} in the literature.
A frame comprises a set of
{\em possible worlds} supplied with a relation of {\em accessibility}
between worlds. A proposition is viewed as necessary in a world
if its truth in each world, $x$, implies its truth in every world
accessible from $x$.

It turns out that by placing various constraints on the accessibility
relation, we arrive at semantics which interpret the
necessitation operator in interesting and useful ways, for example:

\begin{itemize}
\item
transitive accessibility relations for which all ascending chains
are finite correspond to
a view of $\Box$ which is closely related to the provability
predicate for Peano arithmetic. This leads to a useful conceptual framework
for understanding provability, consistency and self-reference
in the theory of arithmetic (see \cite{Boolos79}).
\item
Various forms of linear accessibility relation correspond to a view of $\Box$
as a temporal operator, with $\Box A$ meaning that $A$ will always hold
if it holds now (see, e.g., \cite{Benthem88}).
\item
Taking the worlds as the states of a computer and taking ``$x$ is accessible
from $y$'' to mean ``$x$ results when we execute program $p$ in state $y$'',
we get a modal logic which is closely connected with weakest-precondition
semantics for programming languages (see \cite{Benthem88}).
\item
Taking the worlds as the possible states of knowledge (or belief)
of some individual and taking
the accessibility relation to represent ways in which these states
grow through the acquisition of new knowledge (or belief), we get various forms
of {\em epistemic modal logic} (or {\em doxastic
modal logic}), in which $\Box A$ means that $A$ is known (or believed).
Such logics, usually extended to cover relationships between
the knowledge (or belief) of several individuals,
have many applications in artificial intelligence and in
the study of communication protocols in distributed computer systems
(see \cite{Ramsay88,burrows89}).
\end{itemize}

In the sequel we are going to formalise the possible worlds semantics
in HOL and prove the semantic justification of two rules
of inference for modal logic.

We will also prove some theorems, due to Kripke, about
some axioms used in various modal calculi.
To state the axioms we introduce the {\em possibility} operator, $\Diamond$.
$\Diamond A$ is defined as $≥(\Box(≥A))$. 
In each case, the theorem we prove says that an axiom is valid provided
the accessibility relation possesses a certain property. The axioms
and properties are shown in the following table:

\begin{center}
\begin{tabular}{|l|l|l|}\hline
Axiom 1 & $\Box A¥A$ & Reflexive \\\hline 
Axiom 2 & $\Box A¥\Box(\Box A)$ & Transitive \\\hline 
Axiom 3 & $A¥\Box (\Diamond A)$ & Symmetric \\\hline 
Axiom 4 & $\Diamond A¥\Box (\Diamond A)$ & Euclidean \\\hline 
\end{tabular}
\end{center}

(The notion of a euclidean relation is defined in section \ref{AUXILIARYDEFINITIONS}
below.)

Note that the appropriateness of the above axioms depends on the application.
For example, they are all arguably appropriate for the epistemic reading,
for which, say, 2 is the so-called principle of ``positive introspection'':
`if $A$ is known, then it is known that $A$ is known'.
However, axiom 1 is inappropriate for the doxastic reading: we cannot
assert that a proposition is true just because it is believed.

=SML
open_theory"hol";
new_theory €"modal_logic"›;

let	open ReaderWriterSupport.PrettyNames;
in	add_new_symbols [(["Diamond"], Nil, Simple), (["Box"], Nil, Simple)]
end;

repeat drop_main_goal;
push_pc "hol";
=TEX
\subsection{Auxiliary Definitions}\label{AUXILIARYDEFINITIONS}
We need definitions of the concepts of $reflexive$, $transitive$,
$symmetric$ and $euclidean$ relations in HOL.

As we have already mentioned, HOL is a polymorphic variant
of simple type theory. In such a system properties of values of type $‘$ are
represented as propositional functions, that is to say they are
objects of type 
=INLINEFT
‘ ≠ BOOL
=TEX
{}, where $BOOL$ is the two-point type
of truth values. A binary relation on a type $‘$
is a two-argument propositional function, i.e., it has type
=INLINEFT
‘ ≠ ‘ ≠ BOOL
=TEX
{}.

Polymorphism allows us to use variables
which range over types, such type variables are distinguished syntactically
by having names beginning with the character $'$.
The propositional functions $Reflexive$, $Transitive$, etc. which
we will shortly define are polymorphic constants, they may be applied
to any value whose type has the form 
=INLINEFT
‘ ≠ ‘ ≠ BOOL
=TEX
{}.

The definitions of the four properties of relations we need follow:

πHOLCONST
	€Reflexive›: ('a ≠ 'a ≠ BOOL) ≠ BOOL
˜
	µrel∑ Reflexive rel § µx∑ rel x x
∞ 

πHOLCONST
	€Transitive›: ('a ≠ 'a ≠ BOOL) ≠ BOOL
˜
	µrel∑ Transitive rel § µx y z∑ rel x y ± rel y z ¥ rel x z
∞ 

πHOLCONST
	€Symmetric›: ('a ≠ 'a ≠ BOOL) ≠ BOOL
˜
	µrel∑ Symmetric rel § µx y∑ rel x y ¥ rel y x
∞ 

πHOLCONST
	€Euclidean›: ('a ≠ 'a ≠ BOOL) ≠ BOOL
˜
	µrel∑ Euclidean rel § µx y z∑ rel x y ± rel x z ¥ rel y z
∞ 
=TEX

\subsection{Possible World Semantics in HOL}
\subsubsection{Frames}
In a set-theoretic treatment a {\em frame} consists of a non-empty set $W$, of
{\em possible worlds}, equipped with a binary relation, $R$, the
{\em accessibility} relation. We will use a type variable
$'W$ to represent the set of possible worlds, so that our general treatment
can be instantiated to a particular type of possible worlds.
We can thus capture the notion
of a frame using the following type abbreviation:
=SML
declare_type_abbrev (€"FRAME"›, ["'W"], ¨:'W ≠ 'W ≠ BOOLÆ);
=TEX
The above declaration introduces a new type abbreviation $FRAME$ with a single
formal parameter $'W$; The effect of the declaration is that, for example,
the type expression  $¨{:}(Ó)FRAMEÆ$ will represent the type
$¨:Ó ≠ Ó ≠ BOOLÆ$ of binary
relations on the type $Ó$ of natural numbers. Thus a value
of type $¨{:}(Ó)FRAMEÆ$ can be viewed as a frame in which the possible
worlds are numbers.

We will use the variable $R$ for accessibility relations,
and $x$, $y$ and $z$ for worlds. 
\subsubsection{Valuations}
A {\em valuation} will be a function assigning a truth-value to every possible
world. In a syntactic treatment we would work with an {\em evaluator}
assigning valuations in this sense to the propositional variables. In our
approach we can use HOL variables of the appropriate type to represent
the semantics directly. We use the following type abbreviation for
valuations:
=SML
declare_type_abbrev (€"VALUATION"›, ["'W"], ¨:'W ≠BOOLÆ);
=TEX
Thus, for example, a value of type $¨{:}(Ó)VALUATIONÆ$ is a propositional function on
the natural numbers.

We will use the variables $A$, $B$ and $C$ for valuations.
\subsubsection{Propositional Connectives}
It is straightforward to give the semantics of the ordinary
propositional connectives in their modal guise.
In each case the modal version of a connective
combines the valuations which are its operands to give a valuation
which asserts that for every world
the corresponding propositional connective holds
between the values taken by the operands in that world.
The definitions of these connectives are therefore independent of
any accessibility relation.

We will take implication and negation as our primitive connectives
and define others in terms of them:

πHOLCONST
	€¥_modal›: ('W)VALUATION ≠ ('W)VALUATION ≠ ('W)VALUATION
˜
	µA B x∑ ¥_modal A B x § A x ¥ B x
∞ 

 
πHOLCONST
	€≥_modal›: ('W)VALUATION ≠ ('W)VALUATION
˜
	µA x∑ ≥_modal A x § ≥A x
∞ 
=TEX
In making the above definitions, we had to distinguish the names for the modal
connectives from those already reserved for the propositional connectives
in HOL. The {\em alias} mechanism supported by ICL HOL allows us to use
the usual names instead as syntactic abbreviations. The following
declarations achieve this:
=SML
declare_alias(€"¥"›, ¨¥_modal: ('W)VALUATION ≠ ('W)VALUATION
	≠ ('W)VALUATIONÆ);
declare_alias(€"≥"›, ¨≥_modal: ('W)VALUATION ≠ ('W)VALUATIONÆ);
=TEX
To see how this works, we can now use a more natural syntax for
the definition of modal disjunction and conjunction:

πHOLCONST
	€≤_modal›: ('W)VALUATION ≠ ('W)VALUATION ≠ 
		('W)VALUATION
˜
	µA B∑ ≤_modal A B = (≥A ¥ B)
∞ 

πHOLCONST
	€±_modal›: ('W)VALUATION ≠ ('W)VALUATION ≠ 
		('W)VALUATION
˜
	µA B∑ ±_modal A B = ≥(A ¥ ≥B)
∞ 
=TEX
Note here that $≥$ and $¥$ refer to the modal connectives. The HOL
$≥$ and $¥$ may still be used --- the ICL HOL system
identifies the appropriate internal representation on the basis of the types
of the operands.

As with the other connectives we make alias declarations for the
modal disjunction and conjunction:
=SML
declare_alias(€"≤"›, ¨≤_modal: ('W)VALUATION ≠ ('W)VALUATION ≠ ('W)VALUATIONÆ);
declare_alias(€"±"›, ¨±_modal: ('W)VALUATION ≠ ('W)VALUATION ≠ ('W)VALUATIONÆ);
=TEX


\subsubsection{Necessitation}
The necessitation operator, $\Box$, is defined with respect to
a given frame $R$; The necessitation of a valuation, $A$, is the valuation
which is true at a world $x$ if and only if $A$ is true at every world
accessible from $x$. The HOL definition of this is as follows
πHOLCONST
	€%Box%›: ('W)FRAME ≠ ('W)VALUATION ≠ ('W)VALUATION
˜
	µR A x∑ %Box%R A x § µy∑ R x y ¥ A y
∞ 
=TEX
\subsubsection{Possibility}
The possibility operator, $\Diamond$, is defined in terms of
necessitation and negation as follows:
πHOLCONST
	€%Diamond%›: ('W)FRAME ≠ ('W)VALUATION ≠ ('W)VALUATION
˜
	µR A∑ %Diamond% R A = ≥(%Box%R(≥A))
∞ 
=TEX

\subsubsection{Validity}
A valuation is valid if it is true in every world. Thus:
πHOLCONST
	€Valid›: ('W)VALUATION ≠ BOOL
˜
	µA∑ Valid A § µx∑ A x
∞ 
=TEX
\subsubsection{A Rewrite System}

In the sequel, we will use the above definitions to prove some theorems
about the semantics. The proofs will have a common pattern, in which
the first step is to expand out the above definitions to reduce the goal
to be proved to a proposition in the predicate calculus. The following
ML command gives us an ML value containing the list of defining theorems
which we use to do this.
=SML
val €modal_rewrites› = map snd (get_defns"-");
=TEX
This pattern of proof is common in most applications of HOL: at the beginning
of building a theory, one often has to reduce problems to first principles.
Usually, once one has established a basic repertoire of theorems
characterising the problem domain, subsequent
proofs are performed at a higher-level using the characterising theorems.

\subsection{Inference Rules}\label{INFERENCERULES}
Using the definitions of the previous section we can now prove
some results about the modal operators.
In this section we prove two theorems which are the semantic justifications
for the two inference rules usually associated with modal logics.


\subsubsection{Modus Ponens}
The rule of modus ponens for modal logic is given by the following
HOL theorem.
As an inference rule, modus ponens says that from (the theoremhood of)
$A\,¥\,B$ and (the theoremhood of) $A$ we may infer
(the theoremhood of) $B$.
The semantic justification of this is the theorem we shall now 
prove which asserts that if
$A\,¥\,B$ and $A$ are valid, then so is $B$.

In the following statement of this theorem note that the conjunction
and the second implication are the HOL logical connectives. The first
implication is the modal one.
=SML
push_goal([], ¨µA B∑ Valid (A ¥ B) ± Valid A ¥ Valid BÆ);
=TEX
The above command initiates a session with the ICL HOL subgoal package,
the standard means of finding proofs by a goal oriented search.
Goals are reduced to subgoals by applying tactics. A discussion of
how proofs are conducted is outside the scope of this document.
The proofs given here follow a common pattern. First we rewrite with
the definitions to reduce the goal to a predicate calculus proposition.
We then break this down using the standard tactic for simplifying
such propositions, $strip_tac$.
This simplification gives us a simpler goal and some assumptions
with which to prove it. In most of the present proofs, one or more of the
assumptions turns out to be a universally quantified
formula, which we use to prove the goal by specialisation and rewriting.
=SML
a(rewrite_tac modal_rewrites);
a(REPEAT strip_tac);
a(POP_ASM_T (ante_tac o µ_elim¨xÆ) THEN asm_rewrite_tac[]);
=TEX
This completes the proof of our goal. We save the theorem in
the HOL theory as follows:
=SML
val €modal_mp_thm› = save_thm("modal_mp_thm", pop_thm());
=TEX
\subsubsection{Necessitation}
The rule of necessitation says that from $A$ we may infer $\Box A$.
Again this rule holds for any accessibility relation.
=SML
push_goal([], ¨µR A∑ Valid A ¥ Valid (%Box%R A)Æ);
=TEX
=SML
a(rewrite_tac modal_rewrites);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
=TEX
=SML
val €necessitation_thm› = save_thm("necessitation_thm", pop_thm());
=TEX
\subsection{The Distribution Axiom Schemata}
The distribution axiom schemata contains all sentences of the
form 
=INLINEFT
%Box% (A ¥ B) ¥ (%Box% A ¥ %Box% B)
=TEX 
{}.
The semantic justification for this is proved as follows:
=SML
push_goal([], ¨µR A B∑ Valid (%Box%R(A ¥ B)) ¥ Valid (%Box%R A ¥ %Box%R B)Æ);
=TEX
=SML
a(rewrite_tac modal_rewrites);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 (ante_tac o list_µ_elim[¨xÆ, ¨yÆ]));
a(DROP_NTH_ASM_T 2 (ante_tac o µ_elim  ¨yÆ) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
=TEX
=SML
val €distribution_thm› = save_thm("distribution_thm", pop_thm());
=TEX
\subsection{Four Axioms}
In this section we prove the promised four theorems about the interplay
between certain modal axioms and properties of the accessibility
relation. 
\subsubsection{Axiom 1}
This axiom holds for reflexive accessibility relations:
=SML
push_goal([], ¨µR∑ Reflexive R ¥ µA∑ Valid(%Box%R A ¥ A)Æ);
=TEX
=SML
a(rewrite_tac modal_rewrites);
a(REPEAT strip_tac);
a(POP_ASM_T (ante_tac o µ_elim¨xÆ) THEN asm_rewrite_tac[]);
=TEX
=SML
val €axiom1_thm› = save_thm("axiom1_thm", pop_thm());
=TEX
\subsubsection{Axiom 2}
This axiom holds for transitive accessibility relations:
=SML
push_goal([], ¨µR∑ Transitive R ¥ µA∑ Valid(%Box%R A ¥ %Box%R (%Box%R A))Æ);
=TEX
=SML
a(rewrite_tac modal_rewrites);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (ante_tac o list_µ_elim[¨xÆ, ¨yÆ, ¨y'Æ]) THEN asm_rewrite_tac[]);
=TEX
=SML
val €axiom2_thm› = save_thm("axiom2_thm", pop_thm());
=TEX
\subsubsection{Axiom 3}
This axiom holds for symmetric accessibility relations:
=SML
push_goal([], ¨µR∑ Symmetric R ¥ µA∑ Valid(A ¥ %Box%R (%Diamond% R A))Æ);
=TEX
=SML
a(rewrite_tac modal_rewrites);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 (ante_tac o list_µ_elim[¨xÆ, ¨yÆ]) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN simple_∂_tac¨xÆ THEN asm_rewrite_tac[]);
=TEX
=SML
val €axiom3_thm› = save_thm("axiom3_thm", pop_thm());
=TEX
\subsubsection{Axiom 4}
This axiom holds for euclidean accessibility relations:
=SML
push_goal([], ¨µR∑ Euclidean R ¥ µA∑ Valid(%Diamond% R A ¥ %Box%R (%Diamond% R A))Æ);
=TEX
=SML
a(rewrite_tac modal_rewrites);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (ante_tac o list_µ_elim[¨xÆ, ¨y'Æ, ¨yÆ]) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN ∂_tac¨yÆ THEN asm_rewrite_tac[]);
=TEX
=SML
val €axiom4_thm› = save_thm("axiom4_thm", pop_thm());
=TEX
\subsection{Proof Support for a Modal Logic}
In this section we implement inference rules for modal logic,
and also implement the axiom schemata for 
the modal logic traditionally called $T$.
$T$ has as its axioms all distribution axioms,
all instances of ordinary propositional tautologies
and all sentences of the form $\Box A ¥ A$.

Note that we use the term ``axioms'' here
for what are actually theorems derived from our definitions
of the semantics. 
The axiom schemata are implemented
as proof procedures, i.e.,
ML functions which prove rather than merely postulate the ``axioms''
in question.


Examples of the use of the rules and axiom schemata are given in section
\ref{ExampleProofs} below.

\subsubsection{Implementing the Inference Rules}
In this section we implement derived rules in HOL corresponding
to the theorems proved in section \ref{INFERENCERULES} above.

The first rule is modus ponens. Given as its arguments theorems of
the form $á Ù Valid(A ¥ B)$\footnote{%
The HOL logic is formulated as a {\em sequent calculus}:
the assertions one proves comprise a list of assumptions and a
conclusion. We write $á Ù t$ for a theorem with assumptions $á$ and
conclusion $t$.}%
and $Ñ Ù Valid\,A$ it will prove the theorem
$á ¿ Ñ Ù Valid\,B$.
This is done with HOL rules to instantiate our
theorem on modus ponens and to use the theorem arguments to
discharge the antecedents of the resulting implication.
=SML
fun €modal_mp_rule› (thm1 : THM) (thm2 : THM) : THM = (
	simple_¥_match_mp_rule modal_mp_thm (±_intro thm1 thm2)
);
=TEX
The second rule is necessitation. Given as arguments a term, $¨RÆ$,
and a theorem
of the form $á Ù Valid\,A$, it will prove $á Ù Valid(\Box R A)$.
This is done by instantiating our theorem on necessitation.
=SML
fun €nec_rule› (R : TERM) (thm : THM) : THM = (
	inst_term_rule [(R, ¨R:('a)FRAMEÆ)]
	(simple_¥_match_mp_rule necessitation_thm thm)
);
=TEX
\subsubsection{Implementing the Axiom Schemata}
It is usual in modal calculi to take all ordinary propositional
tautologies as axioms. The following ML code implements this rule
by proving all such axioms. This proof procedure works
by rewriting with the
definitions of validity and all the modal connectives except $\Box$, and then
using $strip_tac$ to prove the resulting proposition.
=SML
local
	val rw_thms = 
	(map(get_defn"-")
		["%Diamond%", "±_modal", "≤_modal", "≥_modal", 
		 "¥_modal", "Valid"]);
in
fun €modal_taut_rule› (tm : TERM) : THM = (
	tac_proof( ([], tm),
	rewrite_tac rw_thms
	THEN REPEAT strip_tac)
);
end;
=TEX
It is also usual to take all instances of the distribution
axiom as axioms. This is implemented by the following proof procedure
which takes the accessibility relation, $¨RÆ$, and terms
$¨AÆ$ and $¨BÆ$ as arguments and proves
$Ù \Box R(A ¥ B) ¥ (\Box R\,A ¥ \Box R\,B)$. The proof is done by
instantiating our theorem on the distribution axiom appropriately.
=SML
fun €dist_rule› (R : TERM) (A : TERM) (B : TERM) : THM = (
	inst_term_rule 
	(combine [R, A, B] (fst(strip_µ(concl distribution_thm))))
	(all_simple_µ_elim distribution_thm)
);
=TEX
With reference to our theorem about axiom 1, to complete
our rules and axioms for the system $T$
we need assume that some unspecified accessibility relation
$R$ is symmetric.
The following proof procedure proves instances of axiom 1 on the
assumption of a symmetric
accessibility relation, $R$.
=SML
fun €axiom1_rule› (tm : TERM) : THM = (
	§_t_elim(rewrite_conv[undisch_rule(all_simple_µ_elim axiom1_thm)] tm)
);
=TEX
\subsubsection{Example Proofs}\label{ExampleProofs}

As examples, we will prove the (semantic justifications of)
the following two theorems of the system $T$. The
two results are given as theorem 6 in chapter 1 of \cite{Boolos79} and
the proofs we give follow the ones give there.

=GFT Informal Example
	Ù A ¥ %Diamond% A
	Ù %Box% A ¥ %Diamond% A
=TEX
For expository purposes, we have written the proof out step by step.
In actual use, the main purpose of the sort of rules we have implemented
is to enable the construction of higher-level and more powerful
facilities for finding proofs. Proofs at the level of detail seen
here would not be seen by the user.

The following sequence of computations, then, is the HOL
proof of the two results. After each step
we show the output produced by the HOL system after executing
that step.
Note that, essentially, we are now working purely in modal logic:
we no longer see any HOL logical operators, just
terms of the form $¨Valid\,AÆ$ where $A$ involves only modal
connectives; all proof steps are done using the modal inference rules
and axiom schemata we have coded above.

=SML
val €lemma1› = axiom1_rule ¨Valid(%Box% R (≥A) ¥ ≥A)Æ;
=TEX
=GFT HOL Output
val lemma1 = Reflexive R Ù Valid (%Box% R (≥ A) ¥ ≥ A) : THM   
=TEX
=SML
val €lemma2› = modal_taut_rule¨Valid((%Box% R(≥A) ¥ ≥A) ¥ (A ¥ %Diamond% R A))Æ;
=TEX
=GFT HOL Output
val lemma2 = Ù Valid ((%Box% R (≥ A) ¥ ≥ A) ¥ A ¥ %Diamond% R A) : THM   
=TEX
=SML
val €result1› = save_thm("result1", modal_mp_rule lemma2 lemma1);
=TEX
=GFT HOL Output
val result1 = Reflexive R Ù Valid (A ¥ %Diamond% R A) : THM   
=TEX
=SML
val €lemma3› = modal_taut_rule¨Valid((%Box% R A ¥ A) ¥ (A ¥ %Diamond% R A) ¥ (%Box% R A ¥ %Diamond% R A))Æ;
=TEX
=GFT HOL Output
val lemma3 = Ù Valid ((%Box% R A ¥ A) ¥ (A ¥ %Diamond% R A) ¥ %Box% R A ¥ %Diamond% R A) : THM   
=TEX
=SML
val €lemma4› = axiom1_rule ¨Valid(%Box%R A ¥ A)Æ;
=TEX
=GFT HOL Output
val lemma4 = Reflexive R Ù Valid (%Box% R A ¥ A) : THM   
=TEX
=SML
val €lemma5› = modal_mp_rule lemma3 lemma4;
=TEX
=GFT HOL Output
val lemma5 = Reflexive R Ù Valid ((A ¥ %Diamond% R A) ¥ %Box% R A ¥ %Diamond% R A) : THM   
=TEX
=SML
val €result2› = save_thm("result2", modal_mp_rule lemma5 result1);
=TEX
=GFT HOL Output
val result2 = Reflexive R Ù Valid (%Box% R A ¥ %Diamond% R A) : THM   
=TEX
\pagebreak
\subsection{Practical Systems}
While based on a semantics similar to the semantics discussed here,
systems of modal logic intended for practical applications,
e.g. for program verification or protocol verification, will
involve application-specific syntactic features. It is important
for the ease of use of proof tools that the user should
interact with the tool using the natural formalism for the task at hand.
As we have seen, this can come with very little extra work in the case of
a sufficiently simple logical language.

Proof support offering this feature for more complex languages
may be supplied by combining
a semantic approach like the one given here  with use of the facilities
offered by the HOL proof tool for manipulating syntax.
This technique is usually referred to as {\em semantic embedding} (as
opposed to a {\em syntactic} treatment, in which one would use HOL to reason
about syntactic notions, e.g. inference rules, rather than
semantic ones, e.g. the accessibility relation in the present treatment of
modal propositional logic).

In the semantic embedding technique,
sentences of the language to be supported are represented by
semantically equivalent HOL terms.
A parser maps sentences in the desired
concrete syntax to their HOL representation and a pretty-printer automatically
inverts this mapping when terms are displayed.
In the simple example we have given here the parser and pretty-printer
could be very easily constructed modifications of the HOL parser
and pretty-printer which would suppress the appearance of 
the validity operator.
Tools assisting in the production of parsers and pretty-printers are
supplied as part of the ICL HOL system.

On the basis of theorems proved about the semantic objects,
proof procedures, analogous to the rules we have implemented in
the present document,
may be produced which preserve the required syntax as far as the user
is concerned.
Such procedures may often be produced quite
readily by customising or specialising existing proof procedures for HOL.
As in our example,
if valid inference rules for the language are already known, then they
can be used as the basis for the design of such proof procedures.  

An important advantage of the semantic embedding techniques is
that, compared with other approaches, such as coding a complete system
for manipulating syntax from scratch,
it drastically reduces the amount of code in which
errors can make the system inconsistent (i.e. allow the user to prove
an invalid result).

A system of this sort offering proof support for Z is currently being
prototyped in ICL and good results are emerging.
Z is in many respects much harder to accomodate than most of
the formalisms based on modal logics
which have been proposed for computer science applications, and so such
formalisms promise to be good applications for this semantic
embedding techniques.

{\small
\twocolumn[\section{INDEX}]\label{INDEX}
\printindex}

\onecolumn
\appendix
\input{int002.thl.tex}

\subsection{Creating this Index}
Pipe the output of ``hol_list'', with
``initialisation file'' ``int002.sml'' to ``int002.thl.doc'',
and process the result with ``doctex''.
=GFT csh
docsml int002
hol_list -i int002.sml arith_demo prime false arith_demo2 modal_logic >! int002.thl.doc
doctex int002.thl
=TEX
The directory will now contain the file necessary for the
appendix to be created.
\end{document}

=IGN
