=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of Product Types}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD059}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D. Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design
of the tools providing product types.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item[Issue 1.1] 
First version.
\item[Issue 1.2] 
Changes after RDA comments.
\end{description}
\subsection{Changes Forecast}
None known.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Tools for introducing HOL product types are 
called for in \cite{DS/FMU/IED/HLD???}.
This document provides a detailed design for these tools.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the
tools to introduce HOL product types.
Unlike constant specification (See $const\_spec$)
there is no requirement for an ``axiom'' mode, where instead
of proof required theorems are introduced by axiom.
This is because all the proof work can always be completed,
and if the relevant cached theorem is present, it can be
completed fast.
\subsubsection{Dependencies}
This document depends upon \cite{DS/FMU/IED/IMP???}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{PREAMBLE}
=DOC
signature âProductTypesá  = sig
=DESCRIBE
This is the signature of a structure supporting the introduction of HOL product types.
=ENDDOC
\section{THE DESIGN}
=DOC
val âlabelled_product_specá:{tyname:string, tykey:string, conname:string, 
	constkeys:string list, labels:(string*TYPE)list, tyvars:(TYPE list)OPT} -> THM;
=DESCRIBE
This function
introduces a labelled product type, and its constructor and projection functions.
Its argument's fields are:
\begin{description}
\item [tyname]
This will be the name of the new type.
\item [tykey]
This will be the key under which the defining axiom for the type will be saved.
\item [conname]
This will be the name of the single constructor of the new type.
It will be a curried function, from each of the label types, in turn, to the new type.
Its defining axiom will be saved under the keys $conkeys$.
\item [constkeys]
These will be the keys under which the defining axiom for the 
constructor and projection functions will be saved.
\item [labels]
This is the list of the names and types of the labelled fields in the new type. 
A projection function will be defined for each label,
a single defining axiom for all will be saved under the keys $conkeys$.
It is this defining axiom that is the result of the function call.
\item [tyvars]
If this filed is $Nil$ then the type variables in the new type will be ordered as their occurrence in $labels$, otherwise as stated by this parameter.
\end{description}
If the appropriate tuple type is not already in scope a call of $tuple\_spec$ $(length$ $labels)$ will also be made as a side effect.
This defines the representation type $n\_TUPLE$.
=EXAMPLE
	:> labelled_product_spec {tyname="PAIR", tykey="PAIR", conname="Comma",
		constkeys=["Comma","First","Second"], 
		labels=[("First",»:'f¼),("Second",»:'s¼)], tyvars=Value[»:'s¼,»:'f¼]};
will cause
	… „ f : ('s, 'f) PAIR ‹ ('s, 'f)2TUPLE Ž TypeDefn ( x Ž T) f
to be saved under the key "PAIR", and
	… ƒ t Ž ƒ (x1:'f) (x2:'s)Ž
		First(Comma x1 x2) = x1 €
		Second(Comma x1 x2) = x2 €
		(Comma(First t) (Second t) = t)
to be saved under keys "Comma", "First", and "Second", and returned as the result of the call
=FAILURE
59010	Must be at least one label in list
59012	set of tyvars list ?0 not equal to type variables in labels, ?1
=FAILUREC
As the appropriate errors of $tuple\_spec$, $new\_type\_defn$ and $new\_specification$.
=ENDDOC
Any form of failure will cause the overall function to have no effect.

Interestingly, the result of the above is in the right form for the theorem used as an argument for $set\_pc\_„\_vs\_thm$.
=DOC
val âunlabelled_product_specá : {tyname:string, tykey:string, conname:string, 
	conkeys:string list, tyi:TYPE list, tyvars:(TYPE list)OPT} -> THM;
=DESCRIBE
This introduces an unlabelled product type (given name $tyname$
and arity the number of distinct type variables with the $ty_i$)
and its constructor (a curried function given name $conname$,
and type $ty1\ ‹\ ty2\ ‹ ... (...)tyname$).
The type definition will be saved under the key $tykey$,
and the constructor definition will be saved under keys $conkeys$.
If the $tyvars$ field is $Nil$ then the type variables in the new type will be ordered as their occurrence in $tyi$, otherwise as stated by this parameter.

If the appropriate tuple type is not already in scope a call of $tuple\_spec$ $(length$ $types)$ will also be made as a side effect.
This is as part of the speeding up of introducing the new type,
as it defines the representation type $n\_TUPLE$.
=EXAMPLE
:> unlabelled_product_spec {tyname="PAIR", tykey="PAIR", conname="Comma",
	conkeys=["Comma"], tyi=[»:'f¼, »:'s¼], tyvars=Nil};

will cause

… „ f : ('f, 's) PAIR ‹ ('1, '2)2TUPLE Ž TypeDefn ( x Ž T) f

to be saved under the key "PAIR", and

… 	(ƒ (x1:'f) (x2:'s)Ž ƒ y1 y2Ž
	(Comma x1 x2 = Comma y1 y2) ‚ (x1 = y1) € (x2 = y2))
	€
	(ƒ t Ž „ x1 x2 Ž t = Comma x1 x2)

to be saved under the key "Comma", and returned as the result of the call.
=SEEALSO 
$labelled\_product\_type$
=FAILURE
59011	The must be at least one type in list
59032	set of tyvars list ?0 not equal to type variables in tyi, ?1
=FAILUREC
As the appropriate errors of $tuple\_spec$ and $new\_type\_defn$.
Any form of failure will cause the overall function to have no effect.
=ENDDOC
=DOC
val âtuple_specá : int -> THM;
=DESCRIBE
$tuple\_spec$ $n$ defines the type $n\_TUPLE$, an n-tuple type,
where $n$ is some positive integer,
and returns a theorem stating that a constructor, and projection functions exist for this type.
The theorem and definition will be stored in the current cache theory (see $get\-\_cache\-\_theories$).
However, if the type desired is already in a cache theory in scope, then no definition
will occur and the function
just returns the stored existence theorem.
=EXAMPLE
> tuple_spec 2;

creates the type 2TUPLE; and saves its definition as:

… „ f Ž ('1, '2)2TUPLE ‹ ('1 ‰ '2) Ž TypeDefn ( x Ž T) f

under the key "2TUPLE", and saves the following theorem under "2TUPLE":

… „ 2Tuple Ž
   („ Lab2_1 Lab2_2 Ž
  	ƒ t Ž ƒ (x1:'1) (x2:'2)Ž
	Lab2_1(2Tuple x1 x2) = x1 €
	Lab2_2(2Tuple x1 x2) = x2 €
	(2Tuple(Lab2_1 t) (Lab2_2 t) = t))
   €
   ((ƒ x1 x2Ž ƒ y1 y2Ž
	(2Tuple x1 x2 = 2Tuple y1 y2) ‚ (x1 = y1) € (x2 = y2)) €
	(ƒ tŽ „ x1 x2Ž t = 2Tuple x1 x2))
=TEX
The theorem has the form $„ n_TupleŽconj1\ €\ conj2$ where it can be proven $conj1\ ‚\ conj2$
because the two conjuncts correspond to the needs of
$labelled\-\_product\-\_spec$ and $unlabelled\-\_product\-\_spec$ (q.v.)
respectively.
=FAILURE
59001	Argument ?0 should have been positive
59002	Current cache theory, ?0, not set, not in scope or not writable
59003	Type ?0 in scope, but no theorem, saved with key ?0, in cache theories
59004	Found theorem, but no definition, saved with key ?0 in current cache theory
59005	Type ?0 is in scope or in descendants of current theory,
	but not properly saved in cache theories
59006	There are no cache theories
=FAILUREC
and as the appropriate failures of $new\_type\_defn$ and $save\_thm$.
=ENDDOC
Notice that ``default'' constructor
could be be defined along with the type by:
ó
new_specification(keys, 1, tuple_spec n);
æ
and default projection functions by only a bit more work.
=DOC
val âset_cache_theoriesá : string list -> unit;
val âget_cache_theoriesá : unit -> string list;
=DESCRIBE
THese two functions provide the obvious interface to
providing access to the list of cache theories.
The current cache theory is always the head of the list provided,
and this is the only cache theory that will be written to
as a cache.
The theory names given need not be associated with theories that are
in scope, or even ones that exist, though functions that use
$get\-\_cache\-\_theories$ will fail if they need to write to the current
cache theory, and it is not writable.

These functions support a method of working using cache theories, where
only a subset of the ancestors of the current theory are searched
for particular portions of contents,
and these things are only stored in the current cache theory.
This will speed the search for these items by such functions as 
$tuple\_spec$.
=ENDDOC
\section{EPILOGUE}
=SML
end; (* of signature ProductTypes *)
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
