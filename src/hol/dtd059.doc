=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of Product Types}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD059}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D. Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design
of the tools providing product types, both labelled and unlablled.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item[Issue 1.1] 
First version.
\item[Issue 1.2] 
Changes after RDA comments.
\item [Issue 1.3]
Changes during testing.

\item[Issue \SCCSversion, \FormatDate{92/01/20} ] Updated to use new fonts.

\end{description}
\subsection{Changes Forecast}
None known.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Tools for introducing HOL product types are 
called for to support introduction of Z schemas, etc, called for in \cite{DS/FMU/IED/HLD016}.
The tools are directly called for in \cite{DS/FMU/IED/HLD010}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the
tools to introduce HOL product types.
Unlike constant specification (See $const\_spec$)
there is no requirement for an ``axiom'' mode, where instead
of proof required theorems are introduced by axiom.
This is because all the proof work can always be completed,
and if the relevant cached theorem is present, it can be
completed fast.
\subsubsection{Dependencies}
This document depends upon \cite{DS/FMU/IED/IMP027}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{PREAMBLE}
=DOC
signature ÛProductTypesÝ  = sig
=DESCRIBE
This is the signature of a structure supporting the introduction of HOL product types.
=ENDDOC
\section{THE DESIGN}
=DOC
val Ûlabelled_product_specÝ:{tyname:string, tykey:string, conname:string, 
	constkeys:string list, labels:(string*TYPE)list, tyvars:(TYPE list)OPT} -> THM;
=DESCRIBE
This function
introduces a labelled product type, and its constructor and projection functions.
Its argument's fields are:
\begin{description}
\item [tyname]
The name of the new type.
\item [tykey]
The key under which the defining axiom for the type will be saved.
\item [conname]
The name of the single constructor of the new type.
It will be a curried function, from each of the label types, in turn, to the new type.
\item [constkeys]
The keys under which the defining axiom for the 
constructor $conname$ and projection functions will be saved.
\item [labels]
The list of the names and types of the labelled fields in the new type. 
A projection function will be defined for each label,
a single defining axiom for all will be saved under the keys $conkeys$.
It is this defining axiom that is the result of the function call.
\item [tyvars]
If this field is $Nil$ then the type variables in the new type will be ordered as their occurrence in $labels$, otherwise as stated by this parameter.
\end{description}
If the appropriate tuple theorem is not already in scope a call of $cached\-\_labelled\-\_product\-\_rule$ $(length$ $labels)$ will also be made as a side effect.
=EXAMPLE
:> labelled_product_spec {tyname="PAIR", tykey="PAIR", conname="Comma",
	constkeys=["Comma","First","Second"], 
		labels=[("First",¬:'f®),("Second",¬:'s®)], tyvars=Value[¬:'s®,¬:'f®]};
will cause	ô ¶ f : ('s, 'f) PAIR ­ ('s, 'f)2TUPLE · TypeDefn (Ì x · T) f
to be saved under the key "PAIR", and
		ô µ t · µ (x1:'f) (x2:'s)· (First(Comma x1 x2) = x1 ± 
		Second(Comma x1 x2) = x2) ± (Comma(First t) (Second t) = t)
to be saved under keys "Comma", "First", and "Second", and returned as the result of the call
=FAILURE
59010	Must be at least one label in list
59014	Failed to introduce type and operators for ?0
59015	Some labels are given types containing type variables not found in 
	supplied list of type variables, being: ?0
=FAILUREC
Also as the appropriate errors of $cached\-\_labelled\-\_product\-\_rule$, $new\-\_type\-\_defn$ and $new\-\_speci\-fication$.
Error 59014 suggests a corrupted cache theorem, but only for certain indicates an otherwise uncaught error.
=ENDDOC

Interestingly, the result of the above is in the right form for the theorem used as an argument for $set\_pc\_¶\_vs\_thm$.
=DOC
val Ûunlabelled_product_specÝ : {tyname:string, tykey:string, conname:string, 
	conkeys:string list, tyi:TYPE list, tyvars:(TYPE list)OPT} -> THM;
=DESCRIBE
This introduces an unlabelled product type (given name $tyname$
and arity the number of distinct type variables with the $ty_i$)
and its constructor (a curried function given name $conname$,
and type $ty1\ ­\ ty2\ ­ ... (...)tyname$).
The type definition will be saved under the key $tykey$,
and the constructor definition will be saved under keys $conkeys$.
If the $tyvars$ field is $Nil$ then the type variables in the new type will be ordered as their occurrence in $tyi$, otherwise as stated by this parameter.

If the appropriate tuple theorem is not already in scope a call of $cached\-\_unlabelled\-\_product\-\_rule$ $(length$ $types)$ will also be made as a side effect.
This is as part of the speeding up of introducing the new type.
=EXAMPLE
:> unlabelled_product_spec {tyname="PAIR", tykey="PAIR", conname="Comma",
	conkeys=["Comma"], tyi=[¬:'f®, ¬:'s®], tyvars=Nil};

will cause

ô ¶ f : ('f, 's) PAIR ­ ('1, '2)2TUPLE · TypeDefn (Ì x · T) f

to be saved under the key "PAIR", and

ô 	(µ (x1:'f) (x2:'s)· µ y1 y2·
	(Comma x1 x2 = Comma y1 y2) ¤ (x1 = y1) ± (x2 = y2))
	±
	(µ t · ¶ x1 x2 · t = Comma x1 x2)

to be saved under the key "Comma", and returned as the result of the call.
=SEEALSO
$labelled\_product\_type$
=FAILURE
59011	There must be at least one type in list
59014	Failed to introduce type and operators for ?0
59016	The supplied types contain type variables not in the
	supplied list of type variables, being: ?0
=FAILUREC
Also as the appropriate errors of $cached\-\_unlabelled\-\_product\-\_rule$ and $new\-\_type\-\_defn$.
Error 59014 suggests a corrupted cache theory, but only for certain indicates an otherwise uncaught error.
=ENDDOC
=DOC
val Ûcached_labelled_product_ruleÝ : int -> THM;
=DESCRIBE
$cached\-\_labelled\_product\-\_rule$ $n$ proves a theorem about an n-tuple,
where $n$ is some positive integer.
This states that if some type is isomorphic to an n-tuple
(an iterated binary product)
then a constructor, and projection functions exist for this type.
The theorem will be stored in the current cache theory (see $get\-\_cache\-\_theories$)
under the key ``nCachedLabelledProduct'',
unless $n\ =\ 1$, when it is ``built-it''.
However, if the theorem desired is already in a cache theory in scope, then it
just returns the stored existence theorem.

=EXAMPLE
> cached_labelled_product_rule 2;

ô  (¶ abs rep · (µ a · abs(rep a) = a) ± (µ r · rep(abs r) = r))
   ´
   ¶ 2Tuple ·
   ¶ Lab2_1 Lab2_2 ·
  	µ t · µ (x1:'1) (x2:'2)·
	Lab2_1(2Tuple x1 x2) = x1 ±
	Lab2_2(2Tuple x1 x2) = x2 ±
	(2Tuple(Lab2_1 t) (Lab2_2 t) = t)
=TEX
=SEEALSO
$cached\_unlabelled\_product\_rule$
=FAILURE
59001	Argument ?0 should have been positive
59002	Current cache theory, ?0, not set, not in scope or not writable
59003	Failed to prove ?0th labelled cached theorem
59006	There are no cache theories
59017	Current theory does not have theory pair as an ancestor
=FAILUREC
Also as the appropriate failures of $save\_thm$.
Failure 59003 suggests a corrupted cached theorem, but only for certain indicates an otherwise uncaught error.
=ENDDOC
There are one other piece of text involved: the information message indicating that a new cached theorem is being created.
=FAILURE
59012	Proving the ?0th cached labelled product theorem
=TEX
=DOC
val Ûcached_unlabelled_product_ruleÝ : int -> THM;
=DESCRIBE
$cached\-\_unlabelled\-\_product\-\_rule$ $n$ proves a theorem about an n-tuple,
where $n$ is some positive integer.
This states that if some type is isomorphic to an n-tuple
(an iterated binary product)
then a constructor with appropriate properties exists for this type.
The theorem will be stored in the current cache theory (see $get\-\_cache\-\_theories$)
under the key ``nCachedUnlabelledProduct'',
unless $n\ =\ 1$, when it is ``built-it''.
.
However, if the theorem desired is already in a cache theory in scope, then it
just returns the stored existence theorem.
=EXAMPLE
> cached_unlabelled_product_rule 2;

ô  (¶ abs rep · (µ a · abs(rep a) = a) ± (µ r · rep(abs r) = r))
   ´
   ¶ 2Tuple ·
   	(µ x1 x2· µ y1 y2·
	(2Tuple x1 x2 = 2Tuple y1 y2) ¤ (x1 = y1) ± (x2 = y2)) 
	±
	(µ t· ¶ x1 x2· t = 2Tuple x1 x2)
=TEX
=FAILURE
59001	Argument ?0 should have been positive
59002	Current cache theory, ?0, not set, not in scope or not writable
59004	Failed to prove ?0th unlabelled cached theorem
59006	There are no cache theories
59017	Current theory does not have theory pair as an ancestor
=SEEALSO
$cached\_labelled\_product\_rule$
=FAILUREC
Also as the appropriate failures of $save\_thm$.
Failure 59004 suggests a corrupted cached theorem, but only for certain indicates an otherwise uncaught error.
=ENDDOC
There are one other piece of text involved: the information message indicating that a new cached theorem is being created.
=FAILURE
59013	Proving the ?0th cached unlabelled product theorem
=TEX
=DOC
val Ûset_cache_theoriesÝ : string list -> unit;
val Ûget_cache_theoriesÝ : unit -> string list;
=DESCRIBE
THese two functions provide the obvious interface to
providing access to the list of cache theories.
The current cache theory is always the head of the list provided,
and this is the only cache theory that will be written to
as a cache.
The theory names given need not be associated with theories that are
in scope, or even ones that exist, though functions that use
$get\-\_cache\-\_theories$ will fail if they need to write to the current
cache theory, and it is not writable.

These functions support a method of working using cache theories, where
only a subset of the ancestors of the current theory are searched
for particular portions of contents,
and these things are only stored in the current cache theory.
This will speed the search for these items by such functions as
$cached\-\_labelled\-\_product\-\_rule$.

Initially the list of cache theories is empty.
=ENDDOC
\section{EPILOGUE}
=SML
end; (* of signature ProductTypes *)
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


