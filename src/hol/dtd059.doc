=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of Product Types}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD059}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D. Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design
of the tools providing product types.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item[Issue 1.1] 
First version.
\end{description}
\subsection{Changes Forecast}
None known.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Tools for introducing HOL product types are 
called for in \cite{DS/FMU/IED/HLD???}.
This document provides a detailed design for these tools.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the
tools to introduce HOL product types.
\subsubsection{Dependencies}
This document depends upon \cite{DS/FMU/IED/IMP???}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{PREAMBLE}
=DOC
signature âProductTypesá  = sig
=DESCRIBE
This is the signature of a structure supporting the introduction of HOL product types.
=ENDDOC
\section{THE DESIGN}
=DOC
val âlabelled_product_specá : string * string list * string * string list * 
	(string * TYPE)list ‹ THM;
=DESCRIBE
$labelled\_product\_spec$ $tyname$ $tykeys$ $conname$ $conkeys$ $labels$
introduces a labelled product type, and its constructor and projection functions.
Its arguments are:
\begin{description}
\item [tyname]
This will be the name of the new type.
\item [tykeys]
This will be the keys under which the defining axiom for the type will be saved.
\item [conname]
This will be the name of the single constructor of the new type.
It will be a curried function, from each of the label types, in turn, to the new type.
Its defining axiom will be saved under the keys $conkeys$.
\item [conkeys]
These will be the keys under which the defining axiom for the 
constructor and projection functions will be saved.
\item [labels]
This is the list of the names and types of the labelled fields in the new type. 
A projection function will be defined for each label,
a single defining axiom for all will be saved under the keys $conkeys$.
It is this defining axiom that is the result of the function call.
\end{description}
If the appropriate tuple type is not already in scope a call of $tuple\_spec$ $(length$ $labels)$ will also be made as a side effect.
This is as part of the speeding up of introducing the new type,
as it defines the representation type $TUPLE\_n$.
=EXAMPLE
	:> labelled_product_spec "PAIR" ["PAIR"] "Comma" ["Comma","First","Second"]
	[("First",»:'f¼),("Second",»:'s¼)];
will cause
	… „ f : ('f, 's) PAIR ‹ ('f, 's)TUPLE_2 Ž TypeDefn ( x Ž T) f
to be saved under the key "PAIR", and
	… ƒ t Ž ƒ x1 y1: 'fŽ ƒ x2 y2: '2Ž
		First(Comma x1 x2) = x1 €
		Second(Comma x1 x2) = x2 €
		(Comma(First t) (Second t) = t)
to be saved under keys "Comma", "First", and "Second", and returned as the result of the call
=SEEALSO 
$unlabelled\_product\_type$
=FAILURE
59010	Must be at least one label in list
=FAILUREC
As the appropriate errors of $tuple\_spec$, $new\_type\_defn$ and $new\_specification$.
Any form of failure will cause the overall function to have no effect.
=ENDDOC
Interestingly, the result of the above is in the right form for the theorem used as an argument for $set\_pc\_„\_vs\_thm$.
=DOC
val âunlabelled_product_specá : string * string list * string * string list * TYPE list ‹ THM;
=DESCRIBE
$unlabelled\_product\_spec$ $tyname$ $tykeys$ $conname$ $conkeys$ $[ty1,$ $ty2$, $...]$
introduces an unlabelled product type (given name $tyname$
and arity the number of distinct type variables with the $ty_i$)
and its constructor (a curried function given name $conname$,
and type $ty1\ ‹\ ty2\ ‹ ... (...)tyname$).
The type definition will be saved under the keys $tykeys$,
and the constructor definition will be saved under keys $conkeys$.

If the appropriate tuple type is not already in scope a call of $tuple\_spec$ $(length$ $types)$ will also be made as a side effect.
This is as part of the speeding up of introducing the new type,
as it defines the representation type $TUPLE\_n$.
=EXAMPLE
:> unlabelled_product_spec "PAIR" ["PAIR"] "Comma" ["Comma"] [»:'f¼, »:'s¼];

will cause

… „ f : ('f, 's) PAIR ‹ ('1, '2)TUPLE_2 Ž TypeDefn ( x Ž T) f

to be saved under the key "PAIR", and

… 	(ƒ x1 y1: '1Ž ƒ x2 y2: '2Ž
	(Comma x1 x2 = Comma y1 y2) ‚ (x1 = y1) € (x2 = y2))
	€
	(ƒ t Ž „ x1 x2 Ž t = Comma x1 x2)

to be saved under the key "Comma", and returned as the result of the call.
=SEEALSO 
$labelled\_product\_type$
=FAILURE
59011	The must be at least one type in list
=FAILUREC
As the appropriate errors of $tuple\_spec$ and $new\_type\_defn$.
Any form of failure will cause the overall function to have no effect.
=ENDDOC
=DOC
val âtuple_specá : int -> THM;
=DESCRIBE
$tuple\_spec$ $n$ defines the type $TUPLE\__n$, an n-tuple type,
where $n$ is some positive integer,
and returns a theorem stating that a constructor, and projection functions exist for this type.
The theorem and definition will be stored in the current cache theory (see $new\-\_cache\-\_theory$).
However, if the type desired is already in a cache theory in scope, then no definition
will occur and the function
just returns the stored existence theorem.
=EXAMPLE
> tuple_spec 2;

creates the type TUPLE_2; and saves its definition as:

… „ f Ž ('1, '2) ‹ ('1 ‰ '2) Ž TypeDefn ( x Ž T) f

under the key "TUPLE_2", and saves the following theorem under "TUPLE_2":

… „ Tuple2 Ž
   („ Lab2_1 Lab2_2 Ž
  	ƒ t Ž ƒ x1 y1: '1Ž ƒ x2 y2: '2Ž
	Lab2_1(Tuple2 x1 x2) = x1 €
	Lab2_2(Tuple2 x1 x2) = x2 €
	(Tuple2(Lab2_1 t) (Lab2_2 t) = t))
   €
   ((ƒ x1 y1: '1Ž ƒ x2 y2: '2Ž
	(Tuple2 x1 x2 = Tuple2 y1 y2) ‚ (x1 = y1) € (x2 = y2)) €
	(ƒ tŽ „ x1 x2Ž t = Tuple2 x1 x2))
=TEX
The theorem has the form $„ TupleNŽconj1\ €\ conj2$ where it can be proven $conj1\ ‚\ conj2$
because the two conjuncts correspond to the needs of
$labelled\-\_product\-\_spec$ and $unlabelled\-\_product\-\_spec$ (q.v.)
respectively.
=SEEALSO
$labelled\_product\_spec$
=FAILURE
59001	Argument ?0 should have been positive
59002	Current cache theory, ?0, not set, not in scope or not writable
59003	Found definition, but no theorem, saved with key TUPLE_?0
59004	Found theorem, but no definition, saved with key TUPLE_?0
59005	Type ?0 is in scope or in descendants of current theory,
	but not properly saved in cache theories
59006	There are no cache theories
=FAILUREC
and as the appropriate failures of $new\_type\_defn$ and $save\_thm$.
=ENDDOC
Notice that ``default'' constructor
could be be defined along with the type by:
ó
new_specification(keys, 1, tuple_spec n);
æ
and default projection functions by only a bit more work.
=DOC
val âpush_cache_theoryá : string -> unit;
val âpop_cache_theoryá : unit -> unit;
val âget_cache_theoriesá : unit -> string list;
=DESCRIBE
$push\_cache\_theory$ $thyname$, with a valid
theory name, will cause later invocations of $get\-\_cache\-\_theories$ to return its previous value, but with $thyname$ appended to the front of the list.
Before the first invocation of $push\-\_cache\-\_theory$ a call to
$get\-\_cache\-\_theories$ will return the empty list.
$pop\-\_cache\-\_theory$ removes the top cache theory from the
list, and is primarily provided for handling working in different branches
in the theory hierarchy.

These functions support a method of working using cache theories, where
only a subset of the ancestors of the current theory are searched
for particular portions of contents,
and these things are only stored in the current cache theory.
This will speed the search for these items by such functions as 
$tuple\_spec$.
A new cache theory would be added when the previous one must
become unwritable (e.g. because of creating a child database).
Note that $pop\-\_cache\-\_theory$ does not remove anything cached within the now popped theory, so if the theory doesn't also go out of 
scope there may be clashes if redefinition is tried.

A valid theory name is one for a theory that is in scope, is writable, and has the current cache theory amongst its ancestors.
=FAILURE
59006	There are no cache theories
59007	Theory ?0 is not writable
59008	Theory ?0 is not in scope
59009	Theory ?0 does not have current cache theory, ?1, as an ancestor
=ENDDOC
\section{EPILOGUE}
=SML
end; (* of signature ProductTypes *)
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
