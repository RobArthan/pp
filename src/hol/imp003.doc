%  imp003.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Implementation for Types and Terms}
\TPPref{DS/FMU/IED/IMP003}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issues 1.1 to 1.20]
First drafts.
\item [Issue 1.21]
Changes in reaction to deskcheck ID0090.
\item [Issue 2.1 (11th October 1991)]
Approved version of issue 1.21.
\item [Issue 2.2,2.3,2.4 (11th October 1991)]
Reimplemented some functions by ``failure''.

\item[Issue \SCCSversion, \FormatDate{92/01/20} ] Updated to use new fonts.

\end{description}
% \subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the types and terms of ICL HOL.
The design is given in \cite{DS/FMU/IED/DTD003}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the types and terms of ICL HOL, and functions to handle them.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD003}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{TYPES AND TERMS}
=SML
structure €icl'TypesAndTerms› : icl'TypesAndTerms = struct
=TEX
\newpage
\subsection{An Exception}
We want an arbitrary $Fail$ exception, to save on creating new
values at need.
Its use (by $raise$ $just\_fail$) breaks the conventions for error handling described in
\cite{DS/FMU/IED/IMP002}, which would have errors only raised by $fail$, $error$, etc.
The conventions are broken to assist in efficiently implementing, e.g., $icl'inst$
by propogating exceptions in the cases of ``no change'',
where we wish to raise an exception will be always be caught,
but are unbothered by the contents.
If we used $fail$ then time and store would be spent in creating an exception
that would never be examined.
We do however want the failure to match $(Fail$ $\_)$, as the
functions using this also see errors raised by, e.g. $lassoc3$.
=SML
val €just_fail› = fail "just_fail" 3064  [] handle complaint => complaint;
=TEX
\subsection{Types}
We implement types by using local definition to hide
its data constructors, rather than declaring it as an abstract data type,
to keep $TYPE$ an equality type.
=SML
local 
datatype €TYPE› = 
	€LVartype› of string |
	€LCtype› of string * TYPE list |
	€L≠Type› of (TYPE * TYPE)
in
type €TYPE› = TYPE;

datatype €DEST_SIMPLE_TYPE› = €Vartype› of string |
 	€Ctype› of (string * TYPE list);
=TEX
\subsection{Functions for Types}
=SML
fun €string_of_type› (ty : TYPE) : string = PolyML.makestring ty;
=TEX
We use the following function to give error messages including types.
=SML
fun €type_fail› (area : string) (msg : int) (tyl : TYPE list) : 'a = (
	fail area msg (map (fn ty => (fn () => string_of_type ty)) tyl)
);
=TEX
We force $mk\_ctype$ to produce function types when appropriate -
this ensures a single form for equal types.
=SML
fun €mk_ctype› (("≠",[t1,t2]): string * TYPE list) : TYPE = L≠Type(t1,t2)
| mk_ctype ctl = LCtype ctl;
=TEX
=SML
val €mk_vartype› : string -> TYPE = LVartype;
=TEX
=SML
val €mk_≠_type› : (TYPE * TYPE) -> TYPE = L≠Type;
=TEX
=SML
fun €dest_ctype› (LCtype stl : TYPE): string * TYPE list = stl
| dest_ctype (L≠Type (t1, t2)) = ("≠", [t1, t2])
| dest_ctype (LVartype s) = type_fail "dest_ctype" 3001 [(LVartype s)];
=TEX
=SML
fun €dest_vartype› ((LVartype s):TYPE) : string = s
 | dest_vartype ty = type_fail "dest_vartype" 3019 [ty];
=TEX
=SML
fun €dest_≠_type› (L≠Type t1t2 : TYPE) : TYPE * TYPE = t1t2
| dest_≠_type ty = type_fail "dest_≠_type" 3022 [ty];
=TEX
=SML
fun €is_vartype› ((LVartype _):TYPE) : bool = true
| is_vartype _ = false;
=TEX
=SML
fun €is_ctype› ((LVartype _):TYPE) : bool = false
| is_ctype _ = true;
=TEX
Types formed by $LCtype$ are only formed by $mk\_type$,
and therefore cannot be function types, as $mk\_type$
coerces these to being formed by $L≠Type$.
=SML
fun €is_≠_type› ((L≠Type _):TYPE) : bool = true 
| is_≠_type _ = false;
=TEX
\subsection{Destroyed Types}
=SML
fun €mk_simple_type› (Vartype nm : DEST_SIMPLE_TYPE) : TYPE = LVartype nm
| mk_simple_type (Ctype ("≠",[ty1,ty2])) = L≠Type(ty1,ty2)
| mk_simple_type (Ctype tctyl) = LCtype tctyl;

fun €dest_simple_type› (LVartype nm : TYPE) : DEST_SIMPLE_TYPE = Vartype nm
| dest_simple_type (LCtype tctyl) = Ctype tctyl
| dest_simple_type (L≠Type (ty1,ty2)) = Ctype("≠",[ty1,ty2]);
=TEX
\subsection{The Type of Truth Values}
=SML
val €BOOL› : TYPE = mk_ctype("BOOL", []);
=TEX
\subsection{Well-Formedness and the Type of Well-Formed Terms}
There is some choice for the
representation for well-formed terms.
At one extreme, we need only to know types in the leaves
of the expression trees --- this means we must recompute
the type of the term from scratch whenever we need it.
At the opposite extreme, we could keep type information
for every node in the tree --- but this might take
up a lot of space. We will try a compromise which allows
the type of a term and its immediate subterms to
be computed using only simple combinations of information
available at the corresponding node.

At nodes of a term tree other than the root,
type information is only given for combinations
(where we give the type of the result and the type
of the argument).
At the root of the tree we give the type unless the
term is a combination, when the type information is
available ``just underneath''.
The local type $TERM\_term$ is introduced to allow this approach.

We implement terms by using local definition to hide
its data constructors, rather than declaring it as an abstract data type,
to keep $TERM$ an equality type.
=SML
local
datatype €icl'TERM›	 =
	€icl'Var› of string |
	€icl'Const› of string |
	€icl'App› of icl'TERM * icl'TERM * TYPE |
	€icl'SimpleÃ› of string * icl'TERM;
datatype TERM = typed of icl'TERM * TYPE
in
type €TERM› = TERM;
=TEX
The type of destroyed terms, and functions upon it:
=SML
datatype €DEST_SIMPLE_TERM› = €Var› of string * TYPE |
	€Const› of string * TYPE |
	€App› of TERM * TERM |
	€SimpleÃ› of TERM * TERM;
=TEX
=SML
fun €string_of_term› (tm : TERM) : string = PolyML.makestring tm;
=TEX
We use the following function for giving error messages including terms.
=SML
fun €term_fail› (area : string) (msg : int) (tml : TERM list) : 'a = (
	fail area msg (map (fn tm => (fn () => string_of_term tm)) tml)
);
=TEX
Initially we do check that the types of abstractions and the operators of
applications have types formed by $L≠Type$,
and provide default clauses to catch cases where no match is made,
even when apparently unnecessary
because of the supposed well-formedness of the terms.
=SML
fun €dest_simple_term› (typed vl:TERM) : DEST_SIMPLE_TERM = (
	case vl of
	(icl'App(t1, t2, ty2), tyt1t2) => (
		App (typed(t1, L≠Type (ty2, tyt1t2)), typed(t2, ty2))
	) | (icl'Const s, ty) => Const (s, ty)
	| (icl'Var s, ty) => Var (s, ty)
	| (icl'SimpleÃ(str, tm), L≠Type(ty1, ty2)) => (
		SimpleÃ (typed(icl'Var str, ty1), typed(tm, ty2))
	) | _ => error "dest_simple_term" 3063 []
);
=TEX
=SML
fun €mk_simple_term› ((Var (s, ty)): DEST_SIMPLE_TERM) : TERM = typed(icl'Var s, ty)
| mk_simple_term (Const (s, ty)) = typed(icl'Const s, ty)
| mk_simple_term (App (ftm1 as typed(tm1, L≠Type (ty1,ty2)), ftm2 as typed(tm2,ty3))) = (
	if (ty1 = ty3)
	then typed(icl'App(tm1, tm2, ty3), ty2)
	else term_fail "mk_simple_term" 3005 [ftm1, ftm2]
) | mk_simple_term (SimpleÃ (typed(icl'Var s, ty1), typed(bdy, ty2))) = (
	typed(icl'SimpleÃ(s, bdy), L≠Type(ty1, ty2))
) | mk_simple_term (App (tm1,_)) = term_fail "mk_simple_term" 3006 [tm1]
| mk_simple_term (SimpleÃ (tm1,_)) = term_fail "mk_simple_term" 3007 [tm1];
=TEX
=SML
fun €type_of› ((typed (_, ty)):TERM):TYPE = ty;
=TEX
=SML
fun €mk_var› ((v, ty):string * TYPE): TERM = typed (icl'Var v, ty);

fun €dest_var› ((typed (icl'Var s, ty)):TERM) : string * TYPE = (s, ty)
| dest_var tm = term_fail "dest_var" 3007 [tm];

fun €is_var› ((typed (icl'Var _, _)): TERM) : bool = true
| is_var _ = false;
=TEX
=SML
fun €mk_const›((v, ty):string * TYPE): TERM = (
	case v of
	"=" => (case ty of
		L≠Type(ty1, L≠Type(ty2,ty3)) => (
			if (ty1 = ty2) andalso (ty3 = BOOL)
			then typed(icl'Const v, ty)
			else fail "mk_const" 3002 []
		) | _ => fail "mk_const" 3002 []
	) | "¥" => (case ty of
		L≠Type(ty1, L≠Type(ty2, ty3)) => (
			if (ty1 = BOOL) andalso (ty2 = BOOL) andalso (ty3 = BOOL)
			then typed(icl'Const v, ty)
			else fail "mk_const" 3003 []
		) | _ => fail "mk_const" 3003 []
	) | "µ" => (case ty of
		L≠Type(L≠Type(ty1, ty2),ty3) => (
			if (ty2 = BOOL) andalso (ty3 = BOOL)
			then typed(icl'Const v, ty)
			else fail "mk_const" 3004 [fn ()=>"µ"]
		) | _ => fail "mk_const" 3004 [fn ()=>"µ"]
	) | "∂" => (case ty of
		L≠Type(L≠Type(ty1, ty2),ty3) => (
			if (ty2 = BOOL) andalso (ty3 = BOOL)
			then typed(icl'Const v, ty)
			else fail "mk_const" 3004 [fn ()=>"∂"]
		) | _ => fail "mk_const" 3004 [fn ()=>"∂"]
	) | _ => typed (icl'Const v, ty)
);

fun €dest_const› (tm as (typed (icl'Const s, ty)): TERM):string * TYPE = (s, ty)
| dest_const tm = term_fail "dest_const" 3009 [tm];

fun €is_const› ((typed (icl'Const _, _)): TERM):bool = true
| is_const _ = false;
=TEX
=SML
fun €mk_app›((tm1 as typed(f, L≠Type(ty1, ty2)), tm2 as typed(atm, aty)): 
		TERM * TERM) : TERM = (
	if ty1 = aty
	then typed(icl'App(f, atm, aty), ty2)
	else term_fail "mk_app" 3005 [tm1, tm2]
) | mk_app (tm1,_) = term_fail "mk_app" 3006 [tm1];

fun €dest_app› ((typed(icl'App(ftm, atm, aty), faty)): TERM) : TERM * TERM = (
	typed(ftm, L≠Type(aty, faty)), typed(atm, aty)
) | dest_app tm = term_fail "dest_app" 3010 [tm];

fun €is_app› (typed(icl'App _, _)) = true
| is_app _ = false;
=TEX
=SML
fun €mk_simple_Ã› ((typed(icl'Var v, ty), typed(btm, bty)):TERM * TERM):TERM = (
	typed(icl'SimpleÃ(v, btm), L≠Type (ty, bty))
) | mk_simple_Ã (tm1,_) = term_fail "mk_simple_Ã" 3007 [tm1];

fun €dest_simple_Ã› ((typed(icl'SimpleÃ (s, b), L≠Type(ty1,ty2))): TERM): TERM * TERM = (
	(typed(icl'Var s, ty1), typed(b, ty2))
) | dest_simple_Ã tm = term_fail "dest_simple_Ã" 3011 [tm];

fun €is_simple_Ã› (typed(icl'SimpleÃ _, _)) = true
| is_simple_Ã _ = false;
=TEX
This is present in the abstract data type for speed reasons:
it is frequently used in critical functions.
=SML
local
	fun fvaux
		(bvs : (string * TYPE) list)
		(fvs : (string * TYPE) list)
		(icl'App(tm1, tm2, ty2) : icl'TERM) 
		(ty1 : TYPE) : (string * TYPE) list = (
		fvaux bvs (fvaux bvs fvs tm1 (L≠Type(ty2, ty1)))
			tm2 ty2
	) | fvaux bvs fvs (icl'Const _) _ = fvs
	| fvaux bvs fvs (icl'Var s) ty = (
		if (s, ty) mem bvs
		then fvs
		else fvs grab (s,ty)
	) | fvaux bvs fvs (icl'SimpleÃ (s, bdy)) (L≠Type(ty1, ty2)) = (
		fvaux ((s, ty1) :: bvs) fvs bdy ty2
	) | fvaux _ _ _ _ = error "icl'frees" 3064 [];
in
	fun €icl'frees› (( typed(tm, ty)):TERM) : (string * TYPE) list = (
		fvaux [] [] tm ty
	);
end;
=TEX
=SML
end; (* of local defining TERM *)
end; (* of local defining TYPE *)
=TEX
\subsection{Functions derived from Abstract Data Type $TYPE$ Part}
Some of these functions could be improved by being placed within
the abstract data type.

The following  will fail if it causes no type instantiation.
=SML
fun €icl'inst_type› ([] : (TYPE * string) list) (mty : TYPE) : TYPE = raise just_fail
| €icl'inst_type› (f : (TYPE * string) list) (mty : TYPE) : TYPE = (
let	fun aux ty = (
	if is_vartype ty
	then rassoc3 f (dest_vartype ty)
	else (
		let	val (s,tyl) = dest_ctype ty;
			fun aux1 [] = raise just_fail
			| aux1 (a :: x) = (let	val a' = aux a
			in
				a' :: map (fn t => aux t handle (Fail _) => t) x
			end
			handle (Fail _) =>
			a :: aux1 x);
		in
			mk_ctype(s, aux1 tyl)
		end)
	);

in
	aux mty
end);
=TEX
=SML
fun €inst_type› (f : (TYPE * TYPE) list) (ty : TYPE) : TYPE = (
	icl'inst_type 
		(map (fn (ty,tyv) => (ty,dest_vartype tyv)) f)
		ty
	handle complaint =>
	if area_of complaint = "dest_vartype"
	then pass_on complaint "dest_vartype" "inst_type"
	else ty
);
=TEX
This function extracts the type constructors contained
in a type.
=SML
fun €type_tycons› (ty : TYPE) : (string * int) list = (
	if is_vartype ty
	then []
	else	(
		let	val (s,tyl) = dest_ctype ty
		in
		list_cup (map type_tycons tyl) grab (s, length tyl)
		end)
);
=TEX
This function extracts the type variables contained
in a type.
=SML
fun €type_tyvars› (ty : TYPE) : string list = (
	if is_vartype ty
	then [dest_vartype ty]
	else (
		let	val (_,tyl) = dest_ctype ty
		in
		list_cup (map type_tyvars tyl)
		end)
);
=TEX
=SML
fun €type_any› (p : TYPE -> bool) (ty : TYPE) : bool = (
let	fun aux ty = (
	let
		fun list_type_any (lty :: ltyl) = (
		p lty orelse aux lty orelse list_type_any ltyl
		) | list_type_any [] = false
	in
	is_ctype ty andalso (
		let	val (_,tyl) = dest_ctype ty
		in
		list_type_any tyl
		end)
	end)
in
	p ty orelse aux ty
end);	
=TEX
=SML
fun €type_map› (tyfun :TYPE -> TYPE) (ty : TYPE) : TYPE = (
let
	fun aux (ty : TYPE) = (
		tyfun ty
		handle (Fail _) =>
		if is_vartype ty
		then raise just_fail
		else (
		let	val (s,tyl) = dest_ctype ty;
			fun aux1 [] = raise just_fail
			| aux1 (a :: x) = (let	val a' = aux a
			in
				a' :: map (fn t => aux t handle (Fail _) => t) x
			end
			handle (Fail _) =>
			a :: aux1 x);
		in
			mk_ctype(s, aux1 tyl)
		end));
in
		(aux ty handle (Fail _) => ty)
end);
=TEX
\subsection{Functions derived from Abstract Data Type $TERM$ Part}
Some of these functions could be improved by being placed within
the abstract data type.
=SML
fun €is_free_var_in› (vsvty as (vs, vty): string * TYPE) (tm : TERM) : bool = (
let
	fun ifvi (App (f, a)) = ifvi (dest_simple_term f) orelse ifvi (dest_simple_term a)
	| ifvi (Const _) = false
	| ifvi (Var sty) = (sty = vsvty)
	| ifvi (SimpleÃ (av, bdy)) = (dest_var av <> vsvty) andalso ifvi (dest_simple_term bdy)
in
	ifvi (dest_simple_term tm)
end);
=TEX
=SML
fun €list_mk_simple_Ã› ((tml, f):TERM list * TERM): TERM = (
	fold mk_simple_Ã tml f
);

fun €list_mk_app› ((f:TERM), ([]:TERM list)) : TERM = f
| list_mk_app (f, (a1 :: a2ton)) = list_mk_app(mk_app(f, a1), a2ton);

fun €strip_app› (tm : TERM) = (
	let	fun aux t args = (
			if is_app t
			then	let	val (f, a) = dest_app t;
				in	aux f (a::args)
				end
			else (t, args)
		);
	in	aux tm []
	end
);
=TEX
\subsection{Derived $TERM$ Functions}
A performance issue arises with the destructor functions for
derived term constructors: need they test the types of constants?
Here we do not make this test. It is not necessary if the
definition of two constants with the same name is
disallowed.
=SML
fun €mk_bin_op› (area_name : string) (msg1 : int) (msg2 : int)
	(rator : TYPE -> TYPE -> TERM)
	((lhs, rhs) : TERM * TERM) : TERM = (
	let	val app1 = (mk_app(rator(type_of lhs)(type_of rhs), lhs)
			handle (Fail _) =>
			term_fail area_name msg1 [lhs,rhs]);
	in
	(mk_app(app1, rhs))
	handle (Fail _) =>
		term_fail area_name msg2 [lhs,rhs]
	end
);

fun €dest_bin_op› (area_name : string) (msg : int) (op_name : string)
	(tm : TERM) : TERM * TERM = (
	let	val (Oplhs, rhs) = dest_app tm
		val (Op, lhs) = dest_app Oplhs
	in	if fst(dest_const Op) = op_name
		then (lhs, rhs)
		else term_fail area_name msg [tm]
	end
	handle (Fail _) => term_fail area_name msg [tm]
);

fun €is_bin_op› (op_name : string) (tm : TERM) : bool = (
	let	val (Oplhs, _) = dest_app tm
		val (Op, _) = dest_app Oplhs
	in	fst(dest_const Op) = op_name
	end
	handle (Fail _) => false
);

fun €list_mk_bin_op› (area_name : string) (msg1 : int) (msg2 : int)
	(rator : TYPE -> TYPE -> TERM)
	(tml : TERM list) = (
let
	val tol = type_of (hd tml);
	val rat = rator tol tol;
	fun aux [tm] = tm
	| aux (tm :: tmrest) = 	(
		let	val app1 = (mk_app(rat, tm)
			handle (Fail _) =>
			term_fail area_name msg1 [tm,aux tmrest]);
		in
			(mk_app(app1, aux tmrest))
			handle (Fail _) =>
			term_fail area_name msg2 [tm,aux tmrest]

		end
	) | aux [] = fail area_name 3017 [];
in
	aux tml
end
handle complaint =>
	divert complaint "hd" area_name 3017 []
);
	
fun €strip_bin_op› (op_name : string) (tm : TERM): TERM list = (
	let	val (Oplhs, rhs) = dest_app tm
		val (Op, lhs) = dest_app Oplhs
	in	if fst(dest_const Op) = op_name
		then (lhs :: strip_bin_op op_name rhs)
		else [tm]
	end
	handle (Fail _) => [tm]
);
=TEX
=SML
fun €mk_mon_op› (area_name : string) (msg : int)
	(rator : TYPE -> TERM)
	(rand : TERM) : TERM = (
	(mk_app(rator(type_of rand), rand))
	handle (Fail _) => 
	term_fail area_name msg [rand]
);

fun €dest_mon_op› (area_name : string) (msg : int) (op_name : string)
	(tm : TERM) : TERM = (
	let	val (rator, rand) = dest_app tm
	in	if fst(dest_const rator) = op_name
		then rand
		else term_fail area_name msg [tm]
	end
	handle (Fail _) => term_fail area_name msg [tm]
);

fun €is_mon_op› (op_name : string) (tm : TERM) : bool = (
	let	val (rator, _) = dest_app tm
	in	fst(dest_const rator) = op_name
	end
	handle (Fail _) => false
);
=TEX
=SML
fun €mk_simple_binder› (area_name : string) (msg : int)
	(binder : TYPE -> TYPE -> TERM)
	((var, body) : TERM * TERM) : TERM = (
	(mk_app(binder(type_of var)(type_of body), mk_simple_Ã(var, body)))
	handle complaint =>
		case (area_of complaint) of
		"mk_app" => term_fail area_name msg [var,body]
		| "mk_simple_Ã" => pass_on complaint "mk_simple_Ã" area_name
		| _ => reraise complaint area_name
);

fun €dest_simple_binder› (area_name : string) (msg : int) (op_name : string)
	(tm : TERM) : TERM * TERM = (
	let	val (binder, abs) = dest_app tm;
		val (var, body) = dest_simple_Ã abs;
	in	if fst (dest_const binder) = op_name
		then (var, body)
		else term_fail area_name msg [tm]
	end
	handle (Fail _) => term_fail area_name msg [tm]
);

fun €is_simple_binder› (op_name : string) (tm : TERM) : bool = (
	let	val (binder, bdy) = dest_app tm;
	in	is_simple_Ã bdy
		andalso
		(fst (dest_const binder) = op_name)
	end
	handle (Fail _) => false
);
=TEX
=SML
fun €bin_bool_op› (name : string) (_:TYPE) (_:TYPE): TERM = (
	mk_const(name, mk_≠_type (BOOL,(mk_≠_type (BOOL, BOOL))))
);
=TEX
=SML
fun €equality› (ty : TYPE) (_ : TYPE) : TERM = (
	mk_const("=", mk_≠_type (ty, (mk_≠_type (ty, BOOL))))
);

val €mk_eq› : (TERM * TERM) -> TERM= mk_bin_op "mk_eq" 3012 3012 equality;

val €dest_eq› : TERM -> (TERM * TERM)= dest_bin_op "dest_eq" 3014 "=";

val €is_eq› : TERM -> bool = is_bin_op "=";
=TEX
=SML
val €mk_¥› : (TERM * TERM) -> TERM = mk_bin_op "mk_¥" 3031 3015 (bin_bool_op "¥");

val €dest_¥› : TERM -> (TERM * TERM) = dest_bin_op "dest_¥" 3016 "¥";

val €is_¥› : TERM -> bool = is_bin_op "¥";

val €list_mk_¥› : TERM list -> TERM = (
	list_mk_bin_op "list_mk_¥" 3031 3015 (bin_bool_op "¥")
);

val €strip_¥› : TERM -> TERM list = strip_bin_op "¥";
=TEX
=SML
fun €quantifier› (name : string) (vty : TYPE) (_ : TYPE) : TERM = (
	mk_const(name, mk_≠_type ((mk_≠_type (vty, BOOL)), BOOL))
);

val €mk_simple_µ› : (TERM * TERM) -> TERM = (
	mk_simple_binder "mk_simple_µ" 3015 (quantifier "µ")
);

val €dest_simple_µ› : TERM -> (TERM * TERM) = (
	dest_simple_binder "dest_simple_µ" 3032 "µ"
);

val €is_simple_µ› : TERM -> bool = is_simple_binder "µ";

fun €list_mk_simple_µ› ((tml, f):TERM list * TERM): TERM = (
	fold mk_simple_µ tml f
);

val €mk_simple_∂› : TERM * TERM -> TERM = (
	mk_simple_binder "mk_simple_∂" 3015 (quantifier "∂")
);

val €dest_simple_∂›: TERM -> (TERM * TERM) = (
	dest_simple_binder "dest_simple_∂" 3034 "∂"
);

val €is_simple_∂› : TERM -> bool = is_simple_binder "∂";

fun €list_mk_simple_∂› ((tml, f):TERM list * TERM): TERM = (
	fold mk_simple_∂ tml f
);
=TEX
\subsection{Literals}
Types:
=SML
val €Ó› = mk_ctype("Ó",[]);
val €CHAR› = mk_ctype("CHAR",[]);
val €STRING› = mk_ctype("LIST",[CHAR]);
=TEX
Numerics:
=SML
fun €is_Ó› (tm : TERM) : bool = (
let	val (tmn,tmty) = dest_const tm
in
	(tmty = Ó) andalso (is_all_decimal tmn)
end
handle Fail _ => false
);

fun €mk_Ó› (n : int) : TERM = (
	if (n >= 0)
	then mk_const(string_of_int n,Ó)
	else fail "mk_Ó" 3021 [fn () => string_of_int n]
);

fun €dest_Ó› (tm : TERM) : int = (
let	val (tmn,tmty) = dest_const tm
in
	if (tmty = Ó)
	then nat_of_string tmn
	else term_fail "dest_Ó" 3026 [tm]
end
handle (Fail _) =>
	term_fail "dest_Ó" 3026 [tm]
);
=TEX
Characters:
=SML
local
	val ordquote = ord "`";
in

fun €is_char› (tm : TERM) : bool = (
let	val (tmn,tmty) = dest_const tm
in
	(tmty = CHAR) andalso
	(tmn <> "") andalso
	(ordquote = ord tmn) andalso
	(size tmn = 2)
end
handle Fail _ => false
);

fun €mk_char› (str : string) : TERM = (
	if size str = 1
	then mk_const("`" ^ str, CHAR)
	else fail "mk_char" 3023 [fn () => str]
);

fun €dest_char› (tm : TERM) : string = (
let	val (tmn,tmty) = (dest_const tm
		handle (Fail _) =>
		term_fail "dest_char" 3024 [tm]);
in
	case	if tmty = CHAR
		then	case explode tmn
			of "`"::c2::nil => Value c2
			| _ => Nil
		else Nil
	of Value c => c
	| Nil => term_fail "dest_char" 3024 [tm]
end);
end; (* local *)
=TEX
Strings:
=SML
local
	val orddquote = ord("\"");
in
fun €is_string› (tm : TERM) : bool = (
let	val (tmn,tmty) = dest_const tm
in
	(tmty = STRING) andalso 
	(tmn <> "") andalso
	(orddquote = ord tmn)
end
handle Fail _ => false
);

fun €mk_string› (str : string) : TERM = mk_const("\"" ^ str,STRING);

fun €dest_string› (tm : TERM) : string = (
let	val (tmn,tmty) = (dest_const tm
		handle (Fail _) =>
		term_fail "dest_string" 3025 [tm]);
in
	if (tmty = STRING) andalso (tmn <> "") 
		andalso (ord tmn = orddquote)
	then implode(tl(explode tmn))
	else term_fail "dest_string" 3025 [tm]
end);
end; (* local *)
=TEX
\subsection{Functions Upon Terms}
\subsubsection{$\alpha$-conversion}
This is probably the most compact presentation, but it might be faster to match only the first argument, and then test the second separately.
Otherwise we will always do four tests on mismatched structures.
This depends on the cleverness of compilation.
=SML
fun €%alpha%_eq› (tm1 : TERM) (tm2 : TERM) : bool = (
let	fun aux (App (tm11, tm12))(App(tm21, tm22)) map2to1 = (
		aux(dest_simple_term tm11)(dest_simple_term tm21) map2to1
		andalso
		aux(dest_simple_term tm12)(dest_simple_term tm22) map2to1
	) | aux (Const c1)(Const c2) map2to1 = (c1 = c2)
	  | aux (Var v1) (Var v2) map2to1 = (lassoc1 map2to1 v1 = v2
		andalso rassoc1 map2to1 v2 = v1
	) | aux (SimpleÃ(v1,b1)) (SimpleÃ(v2, b2)) map2to1 = (
		(type_of v1 = type_of v2)
		andalso
		aux (dest_simple_term b1) (dest_simple_term b2) 
			(((dest_var v1), (dest_var v2)) :: map2to1)
	) | aux _ _ _ = false
 	in
		(tm1 = tm2) orelse (aux (dest_simple_term tm1) (dest_simple_term tm2) [])
	end
);
=TEX
Now some functions viewing term lists as sets under $\alpha$-convertibility.
=SML
fun (tm : TERM) €term_mem› (tml : TERM list) : bool = (
let	fun test (h :: t) = (%alpha%_eq tm h) orelse test t
	| test [] = false
in
	test tml
end);
=TEX
=SML
fun ((x :: xs) : TERM list) €term_less› (tm : TERM) : TERM list = (
	if %alpha%_eq tm x
	then xs term_less tm
	else (x :: (xs term_less tm))
) | [] term_less _ = [];
=TEX
=SML
fun (tml : TERM list) €term_grab› (tm : TERM) : TERM list = (
	if tm term_mem tml
	then tml
	else (tm :: tml)
);
=TEX
=SML
fun (tml1 : TERM list) €term_union› (tml2 : TERM list) : TERM list = (
	let
		fun insert (what, lst) = (
			if what term_mem lst
			then lst
			else (what :: lst)
		);
	in
		fold insert tml1 tml2
	end
);
=TEX
=SML
fun €list_term_union› (lists : TERM list list) : TERM list = (
	fold (fn (l1, l2) => l1 term_union l2) lists []
);
=TEX
\subsubsection{Substitution}
A destroyed variable renaming function, used in substitution:
=SML
local
	val €variant_suffix› : string ref = ref "'";
	val side_effect = (
		new_string_control
		{name="variant_suffix", 
		control=variant_suffix, 
		default = (fn () => "'"), 
		check = (fn s => if s = ""
			then fail "variant_suffix" 3028 []
			else true)}
	);

in
fun €set_variant_suffix› (s : string) : string = (
	set_string_control("variant_suffix",s)
);

fun €get_variant_suffix› (():unit) : string = (
	get_string_control "variant_suffix"
);

fun €string_variant› (vars : string list) (s : string) : string = (
	if s mem vars
	then string_variant vars (s ^ (!variant_suffix))
	else s
);
end; (* of local *)
=TEX
=IGN
$new\_frees$ in the below, determines the free variables in the abstraction, changes those found in $R$ to their substitution, finds the frees in the results, and flattens these to gain a single list of resulting frees.
=SML
fun €icl'subst› ([] : (TERM * (string * TYPE)) list) (tm : TERM) : TERM = tm
| icl'subst (R : (TERM * (string * TYPE)) list) (tm : TERM) : TERM = (
let
	fun aux R (App(f, a)) = (
		let	val f' = aux R (dest_simple_term f);
		in
			mk_app(f',
				(aux R (dest_simple_term a)
				handle (Fail _) =>
				a))
		end
		handle (Fail _) =>
		mk_app(f, aux R (dest_simple_term a)))
	| aux R (Const c) = raise just_fail
	| aux R (Var v) = rassoc3 R v
	| aux R (SimpleÃ(vty, b)) = (
		let	val (s, ty) = dest_var vty;
			val new_frees =
				flat (map
				(icl'frees o rassoc2 R mk_var)
				(icl'frees b less (s, ty)));
			val s' = string_variant (map fst new_frees) s;
		in 
			if s' = s
			then (let val RR = ((vty, (s, ty)) :: R);
				val b' = aux RR (dest_simple_term b);
			in
				mk_simple_Ã(vty, b')
			end)
			else(let val vty' = mk_var (s', ty);
				val RR = ((vty', (s, ty)) :: R);
			in
			(let	val b' = aux RR (dest_simple_term b);
			in mk_simple_Ã(vty', b')
			end)
			handle (Fail _) =>
			mk_simple_Ã(vty', b) (* using this would be very odd *)
			end)
		end
	);
in
	(map (fn (t, (vnm, ty)) => 
		if type_of t = ty
		then ()
		else term_fail "icl'subst" 3012 [t,mk_var(vnm,ty)])
		R;
	(aux R (dest_simple_term tm)
	 handle (Fail_) => tm))
end);
=TEX
\subsubsection{Renaming}
=SML
fun €rename› ((v, ty) : string * TYPE) (w : string) (tm : TERM) : TERM = (
	icl'subst[(mk_var(w, ty), (v, ty))]tm
);
=TEX
\subsubsection{Instantiation of Types and Terms}
The use of $string\_variant$ in $rename\_dups$ is untidy.
=SML
local
	fun	inst_loc1 
		(tysubs : (TYPE * string) list)
		(App(f, a) : DEST_SIMPLE_TERM)
		(vars : string list)
		(varmap : ((string * TYPE) * (string * TYPE)) list)
		: TERM = (
		let	val fi = inst_loc1 tysubs (dest_simple_term f) vars varmap;
		in
			mk_app(fi,
				(inst_loc1 tysubs (dest_simple_term a) vars varmap
				handle (Fail _) => a))
		end
		handle (Fail _) =>
		let	val ai = inst_loc1 tysubs (dest_simple_term a) vars varmap;
		in
			mk_app(f,ai)
		end
	) | inst_loc1 tysubs (Const(s,ty)) vars varmap = (
		mk_const(s, icl'inst_type tysubs ty)
	) | inst_loc1 tysubs (Var(s,ty)) vars varmap = (
		mk_var(lassoc3 varmap (s,ty))
	) | inst_loc1 tysubs (SimpleÃ(v, b)) vars varmap = (
		let	val sty as (s, ty) = dest_var v;
			val s' = string_variant vars s;
		in
		((let	val ty' = icl'inst_type tysubs ty;
		in mk_simple_Ã(mk_var (s',ty'),
			(inst_loc1
			tysubs
			(dest_simple_term b)
			(s' :: vars)
			((sty, (s',ty')) :: varmap)
			handle (Fail _) => b))
		end) 
		handle (Fail _) =>
		if s = s'
		then mk_simple_Ã(v,
			inst_loc1
			tysubs
			(dest_simple_term b)
			(s :: vars)
			varmap)
		else mk_simple_Ã(mk_var (s',ty),
			(inst_loc1
			tysubs
			(dest_simple_term b)
			(s' :: vars)
			((sty, (s',ty)) :: varmap)
			handle (Fail _) => b)))
		end
	);
=TEX
=SML
	fun rename_dups _ _ [] = []
	| rename_dups tysubs av ((s, ty) :: rest) = (
		let	val ty' = icl'inst_type tysubs ty;
		in	if ty = ty'
			then (s, ty) :: rename_dups tysubs av rest
			else
				let val s' = (string_variant 
					(map fst(av less (s,ty))) s);
					val sty' = (s' , ty');
				in sty' :: rename_dups tysubs (sty' :: av) rest
				end
		end
		handle (Fail _) =>
		(s, ty) :: rename_dups tysubs av rest);
	fun	inst_loc2
		(avoid : (string * TYPE) list)
		(tysubs : (TYPE * string) list)
		(frees : (string * TYPE) list)
		:	((string * TYPE) * (string * TYPE)) list = (
			combine
			frees
			(rename_dups
			tysubs
			(frees @ avoid)
			frees)
	);
=TEX
=SML
in
	fun	€icl'inst›
		(avoid : (string * TYPE) list)
		(tysubs : (TYPE * string) list)
		(tm : TERM) : TERM = (
		inst_loc1
		tysubs
		(dest_simple_term tm)
		[]
		(inst_loc2 avoid tysubs (icl'frees tm))
	);
end; (* of local ... in ... end *)
=TEX
=SML
fun €term_types› (tm : TERM) : TYPE list = (
let	fun aux (App (f, a)) = (
		aux (dest_simple_term f) cup aux (dest_simple_term a)
	) | aux (Const (_, ty)) = [ty]
	  | aux (Var (_,ty)) = [ty]
	  | aux (SimpleÃ (v, b)) = aux (dest_simple_term b) grab (type_of v)
in
	aux(dest_simple_term tm)
end);
=TEX
=SML
fun €term_any› (p : TERM -> bool) (tm : TERM) : bool = (
let	fun aux (App (f, a)) = (
		p f orelse p a orelse
		aux (dest_simple_term f) orelse
		aux (dest_simple_term a)
	) | aux (Const _) = false
	  | aux (Var _) = false
	  | aux (SimpleÃ (v, b)) = (
		p v orelse p b orelse
		aux (dest_simple_term b)
	)
in
	p tm orelse aux (dest_simple_term tm)
end);
=TEX
=SML
val €term_tyvars› = list_cup o (map type_tyvars) o term_types;
=TEX
=SML
fun €term_tycons› (tm : TERM) : (string * int) list = (
let
	fun aux (App (f, a)) = (
		aux (dest_simple_term f) cup aux (dest_simple_term a)
	) | aux (Const (_, ty)) = type_tycons ty
	  | aux (Var (_,ty)) = type_tycons ty
	  | aux (SimpleÃ (v, b)) = aux (dest_simple_term b) cup (type_tycons(type_of v))
in
	aux(dest_simple_term tm)
end);
=TEX

This function extracts the subterms of a term which
are constants.
=SML
fun €term_consts› (tm : TERM) : (string * TYPE) list = (
let	fun aux (App(f, a)) = aux(dest_simple_term f) cup aux(dest_simple_term a)
	| aux (Var _) = []
	| aux (Const c) = [c]
	| aux (SimpleÃ (v, b)) = aux (dest_simple_term b)
in
	aux (dest_simple_term tm)
end);
=TEX
This function extracts the subterms of a term which
are variables.
=SML
fun €term_vars› (tm : TERM) : (string * TYPE) list = (
let	fun aux (App(f, a)) = aux(dest_simple_term f) cup aux(dest_simple_term a)
	| aux (Var v) = [v]
	| aux (Const c) = []
	| aux (SimpleÃ (v, b)) = [dest_var v] cup aux (dest_simple_term b)
in
	aux (dest_simple_term tm)
end);
=TEX
\subsubsection{$term\_match$ and $type\_match$}
We will need functions which attempt to determine
if one type (or term) is an instance of another.
$type\_match\;ty1\;ty2$ determines if the type $ty1$
is an instance of $ty2$.
If so it returns a list giving the correspondence between
types in $ty1$ with type variables in $ty2$.
If not it raises an exception.
Similarly $term\_match\;tm1\;tm2$ determines if the term
$tm1$ is an instance of $tm2$. If so it returns
a pair of lists, the first giving the correspondence
between types and the second the correspondence between
free variables of (the appropriate type instance of)
$tm2$ and corresponding subterms of $tm1$.
As with $type\_match$, an exception is raised if the
matching is unsuccessful.

The main work of the matching is done by
auxiliary functions ($tyaux1$ and $tmaux2$).
These
operate in a fairly straight forward way by a structural
recursion on their second type (or term) argument building
up the correspondence between leaves in the structure
and substructures of the first type (or term) argument.
$tmaux2$ uses $tyaux1$ to process types in the terms.

=SML
local
=TEX
$tyaux1$ is quite straightforward. It uses an auxiliary
$tyaux0$ to handle lists of types:
=SML
	fun tyaux1 match t1 t2 = (
	if is_vartype t2
	then (
		let	val s2 = dest_vartype t2
		in
		if (rassoc4 match t1 s2 = t1)
		then match grab (t1, s2)
		else fail "type_match" 3053 []
		end
	) else if is_ctype t1
	then (let val (s1, tl1) = dest_ctype t1;
		val (s2, tl2) = dest_ctype t2;
		fun tyaux0 match [] [] = (
				match
		) | tyaux0 match (h1 :: t1) (h2 :: t2) = (
			tyaux0 (tyaux1 match h1 h2) t1 t2
		) | tyaux0 _ _ _ = fail "type_match" 3053 []
		in
			if s1 = s2
			then tyaux0 match tl1 tl2
			else fail "type_match" 3053 []
		end)

	else fail "type_match" 3053 []);
=TEX
The treatment of terms is more complex than that of types
because of bound variables.
As a result $tmaux2$ is supported by two auxiliary functions, $tmaux1$ and $tmaux0$.
The three functions work with two association lists:
$fvmatch$, which records the correspondence between subterms
of $tm1$ and free variables of $tm2$ and $bvmatch$,
which records the correspondence between
those bound variables of the two terms which are in
scope in the subterm being examined.
It is convenient for $fvmatch$ to have type
$TERM * (string * TYPE)$ and for $bvmatch$
to have type $(string * TYPE) * (string * TYPE)$,
since these choices facilitate the use of $rassoc5$ etc.

$tmaux0$ handles the case when we have encountered a
variable, $v2$ say, in $tm2$ alongside a subterm, $t1$ say, of
$tm1$ which is known not to be
bound variable of $tm1$ (by inspection of $bvmatch$).
We first check that $v2$ is not bound and that
no free variable of $t1$ is bound, if these conditions
are not satisfied the terms do not match.
Assuming all is well,
if we have encountered $v2$ before there
will be an entry for it in $fvmatch$ and
$t1$ must agree (up to $\alpha$-conversion) with that entry.
If we have not encountered $v2$ before,
there will be no entry in $fvmatch$ for it and now
is the time to make one, using $tyaux1$ to handle the
type matching.
=SML
	fun tmaux0 (tymatch, fvmatch) bvmatch tm1 (v2ty2 : string * TYPE) = (
		case rassoc5 bvmatch v2ty2 of
			Nil => (
				if any (icl'frees tm1) (fn x => any bvmatch (fn (x1, _) => (x = x1)))
				then fail "term_match" 3054 []

				else case rassoc5 fvmatch v2ty2 of
					Value tm1' => (
						if %alpha%_eq tm1 tm1'
						then (tymatch, fvmatch)
						else fail "term_match" 3054 []
				) |	Nil => (
						let	val tymatch' =
						tyaux1 tymatch (type_of tm1) (snd v2ty2);
						in	(tymatch', (tm1, v2ty2) :: fvmatch)
						end
				)
			) |	Value _ => fail "term_match" 3054 []
	);
=TEX
$tmaux1$ handles the case when we have encountered a variable, $v2$ say,
in $tm2$.
If the corresponding subterm, $t1$ say, of $tm1$ is
a variable, then we must consult $bvmatch$ to see whether
it is a bound variable.
If it is, then all we must do is consult
$bvmatch$ again to ensure that $v2$ is the corresponding
bound variable of $tm2$, and fail if it is not.
If $t1$ is either a free variable of $tm1$ or some
other sort of term then we just pass the problem
on to $tmaux0$.
=SML
	fun tmaux1 (tymatch, fvmatch) (bvmatch : ((string * TYPE) * (string * TYPE)) list) 
			tm1 v2ty2 = (
		if is_var tm1
		then	(let	val v1ty1 = dest_var tm1;
			in case lassoc5 bvmatch v1ty1 of
				Value vty => (
					if vty = v2ty2 andalso rassoc5 bvmatch v2ty2 = Value v1ty1
					then (tymatch, fvmatch)
					else fail "term_match" 3054 []
			) |	Nil => tmaux0 (tymatch, fvmatch) bvmatch tm1 v2ty2
			end)
		else 	tmaux0 (tymatch, fvmatch) bvmatch tm1 v2ty2
	);
=TEX
$tmaux2$ handles the general case. If the subterm, $t2$ say,
of $tm2$ is a variable, then $tmaux1$ is applied.
If $t2$ is a constant then the corresponding subterm
of $tm2$ must also be a constant with the same
name and we just use 
$tyaux1$ to handle the type instantiation.
If $t2$ is a combination, then the corresponding subterm
of $tm1$ must be too. The subterms of the
combinations are examined in turn, with matching information
gleaned from the operator passed on for use in examining
of the operand.
If $t2$ is an abstraction, then so must be the corresponding
subterm of $tm1$. The bodies of the abstractions
are examined with the bound variable matching information
in $bvmatch$ suitably adjusted.
Mismatched structures will result in an exception.
=SML
	fun tmaux2 (tymatch, fvmatch) bvmatch (App(f1, a1)) (App(f2, a2)) = (
		tmaux2 (tmaux2 (tymatch, fvmatch) bvmatch 
				(dest_simple_term f1) (dest_simple_term f2))
			bvmatch 
			(dest_simple_term a1) 
			(dest_simple_term a2)
	) | tmaux2 (tymatch, fvmatch) bvmatch (Const(s1,ty1))(Const(s2,ty2)) = (
		if (s1 = s2)
		then (tyaux1 tymatch ty1 ty2, fvmatch)
		else fail "term_match" 3054 []
	) | tmaux2 (tymatch, fvmatch) bvmatch tm1 (Var v2) = (
		tmaux1 (tymatch, fvmatch) bvmatch (mk_simple_term tm1) v2
	) | tmaux2 (tymatch, fvmatch) bvmatch (SimpleÃ(v1,b1))(SimpleÃ(v2,b2)) = (
		
		let	val v1ty1 = dest_var v1;
			val v2ty2 = dest_var v2;
			val bvmatch' = (v1ty1, v2ty2) :: bvmatch;
			val tymatch' = tyaux1 tymatch (snd v1ty1) (snd v2ty2);
		in	tmaux2 (tymatch', fvmatch) bvmatch' 
			(dest_simple_term b1) (dest_simple_term b2)
		end
	) | tmaux2 _ _ _ _ = fail "term_match" 3054 [];
in
=TEX
It will often be the case that identical subtypes or
subterms correspond.
For compactness, the result lists of the matching functions
do not contain trivial correspondences.
$type\_match$ and $term\_match$ therefore both work
by calling the relevant auxiliary and then
removing trivial correspondences from the result.
=SML
	fun €type_match› (ty1 : TYPE) (ty2 : TYPE) : (TYPE * TYPE) list = (
		map(Combinators.I ** mk_vartype)
		((tyaux1 [] ty1 ty2) drop 
			(fn (x, y) => is_vartype x andalso (dest_vartype x = y)))
		handle complaint =>
		if area_of complaint = "type_match"
		then type_fail "type_match" 3053 [ty1,ty2]
		else reraise complaint (area_of complaint)
	);
	fun €term_match› (tm1 : TERM) (tm2 : TERM)
		: (TYPE * TYPE) list * (TERM * TERM) list = (
		(let	val (tym, tmm) = tmaux2 ([], []) [] 
				(dest_simple_term tm1) 
				(dest_simple_term tm2);
			val tym' = tym drop 
				(fn (x, y) => is_vartype x andalso 
				(dest_vartype x = y));
			val tmm' = tmm drop
		(fn (x, (s, ty)) => is_var x andalso 
			(dest_var x = (s, (icl'inst_type tym' ty handle (Fail _) => ty))));
			val tmm'' = map (fn(x, (s,_)) => (x, (s, type_of x))) tmm';
		in 	(map(Combinators.I ** mk_vartype)tym',
			 map(Combinators.I ** mk_var)tmm'')
		end) 
		handle (Fail _) => term_fail "term_match" 3054 [tm1,tm2]
	);
end;
=TEX
=SML
fun €is_type_instance› (ty1 : TYPE) (ty2 : TYPE) : bool = (
	(type_match ty1 ty2; true)
	handle (Fail _) => false
);
=TEX
\subsubsection{Functions Concerning Term Variables}
=SML
fun €variant› (vs : TERM list) (v : TERM) : TERM = (
let	val (s, ty) = dest_var v
		handle complaint =>
		pass_on complaint "dest_var" "variant";
	val vss = map (fst o dest_var) vs
		handle complaint => 
		pass_on complaint "dest_var" "variant";
	val s' = string_variant vss s;
in
	if s' = s
	then v
	else mk_var(s',ty)
end);

fun €list_variant› (av : TERM list) (tml: TERM list) : TERM list = (
let
	val av_vars = map (fst o dest_var) av
		handle complaint =>
		pass_on complaint "dest_var" "list_variant";

	fun aux avs (v :: rest) = (
	let	val (vnm,vty) = dest_var v
			handle complaint => 
			pass_on complaint "dest_var" "list_variant";
		val vnm' = string_variant avs vnm;
		val v' = if vnm = vnm'
			then v
			else mk_var(vnm',vty);
	in
		(v' :: aux (vnm' :: avs) rest)	
	end
	) | aux _ [] = [];
in
	aux av_vars tml
end);

=TEX
The following is a function to create a list of
machine generated variables known to be different
to any existing in a list of terms.
It is very heavily tweaked for efficiency, and its local declarations are as follows.
\begin{description}
\item[mgn\_prefix]
This is the starting prefix for all machine-generated variables,
and should the prefix change, then only this declaration need change.
\item[ord\_mgn\_prefix]
We hope that a fast if incomplete filter names is testing whether
the first character of any encountered name is the same as that
at the start of $mgn\_prefix$.
We do this by using $ord$ which gives the ascii value of the first
character in a string.
We precompute this value for $mgn\_prefix$.
\item[mg\_in\_term]
This gives the list of possible machine-generated names already
present in a single term, with no duplicates.
\item[mg\_in\_terms]
This gives the list of possible machine-generated names already
present in a list of terms, with no duplicates.
\item[mgs]
This is the list of possible machine-generated names present in
$gen\_vars$ term list.
\item[base\_mgns]
This is the list of names that will be used for our newly generated variables, if there are no conflicts already.
\item[create\_mgv]
This creates one variable per type, named $(mgn\_prefix)nnn$,
where $nnn$ is the first number (starting from 0) for which the name is not already
in the list.
The $nnn$ carries over to the name of each new variable, so that
previously rejected names, and previously generated names are not 
tried once more.
This means we don't have to test the new names against themselves.
\end{description}
It replaces the very fast, if slightly uncertain $genvar$, of the prototype ICL HOL.
It is less fast, but should always meet its specification.
=SML
local
	val mgn_prefix = "@_";
	val ord_mgn_prefix = ord mgn_prefix
in
fun €gen_vars› (tyl : TYPE list) (tml : TERM list) : TERM list = (
let	fun mg_in_term acc (App(f, a)) = (
	let	val acc' = mg_in_term acc (dest_simple_term f)
	in mg_in_term acc' (dest_simple_term a) end
	) | mg_in_term acc (Var (s,_)) = if (s <> "") andalso 
			(ord s = ord_mgn_prefix)
		then acc grab s
		else acc
	| mg_in_term acc (Const _) = acc
	| mg_in_term acc (SimpleÃ(v, b)) = 
		let	val vnm = fst(dest_var v) in
		(if (vnm <> "") andalso ord vnm = ord_mgn_prefix
		then mg_in_term (acc grab vnm) (dest_simple_term b)
		else mg_in_term acc (dest_simple_term b))
		end;

	fun mg_in_terms acc (ltm :: ltml) = (
	let	val acc' = mg_in_term acc (dest_simple_term ltm)
	in mg_in_terms acc' ltml end
	) | mg_in_terms acc [] = acc;

	val mgs = mg_in_terms [] tml;

	fun create_mgv n ((lty :: ltyl):TYPE list) : TERM list = (
		if (mgn_prefix ^ string_of_int n) mem mgs
		then create_mgv (n+1) (lty :: ltyl)
		else (mk_var(mgn_prefix ^ string_of_int n, lty) :: 
			create_mgv (n+1) ltyl)
	) | create_mgv n [] = [];
in
	create_mgv 1 tyl
end);
end;
=TEX
=SML
fun €is_free_in› (tm : TERM) (tm1 : TERM): bool = (
	is_free_var_in(dest_var tm) tm1
	handle complaint =>
	pass_on complaint "dest_var" "is_free_in"
);
=TEX
=SML
val €frees› = map mk_var o icl'frees;
=TEX
$var\_subst$ is the direct interface to $icl'subst$.
Thus, unlike $subst$ (see below), it is only capable of
substituting for subterms of a term which are variables.
=SML
fun €var_subst›
	(subs : (TERM * TERM) list)
	(tm : TERM) = (
	((icl'subst o map (Combinators.I ** dest_var)) subs tm)
	handle complaint =>
	pass_on complaint "dest_var" "var_subst"
	handle complaint =>
	pass_on complaint "icl'subst" "var_subst"
);
=TEX
\subsubsection{Mapping over Terms}
This function is a minor convenience. 
In essence,
given a function, $tmfun$, and a term, $tm$, it traverses
$tm$ (breadth first) looking for subterms for which
the application $tmfun\,tm$ does not fail and replaces
such subterms with $tmfun\,tm$. 
In fact, it is convenient
for $tmfun$ to have as an extra parameter a list giving
the bound variables which are in scope at the point of use.
=SML
fun €term_map› (tmfun :(TERM list) -> TERM -> TERM) (tm : TERM) : TERM = (
let
	fun aux
		(bvs : TERM list)
		(tm : TERM) 
		(App(f, a)) = (
			(tmfun bvs tm)
			handle (Fail _) =>
			(let	val f' = aux bvs f (dest_simple_term f);
			in
			mk_app(f',
			(aux bvs a (dest_simple_term a) handle (Fail _) => a))
			end
			handle (Fail _) =>
			mk_app(f,aux bvs a (dest_simple_term a)))
	) | aux bvs tm (Const _) = (tmfun bvs tm)
	| aux bvs tm (Var _) = (tmfun bvs tm)
	| aux bvs tm (SimpleÃ(v, b)) = (
		(tmfun bvs tm) handle (Fail _) =>
			mk_simple_Ã(v, aux (v :: bvs) b (dest_simple_term b))
	);
in
	aux [] tm (dest_simple_term tm)
	handle (Fail _) => tm
end);
=TEX
\subsection{$subst$}
This is the more general interface to $icl'subst$ or $var\_subst$ which
can substitute for arbitrary subterms of a term, not just
variables.
=SML
fun €subst›
	(subs : (TERM * TERM) list)
	(tm : TERM) = (
	if is_nil subs
	then tm
	else
	let	val (xs, ys) = split subs;
		val terms = tm :: (xs @ ys); 
		val Xs = gen_vars (map type_of ys) terms;
		val ysXs = combine ys Xs;
		fun aux bvs tm = (
			let	val (t, X) = find ysXs (fn (u, Y) => %alpha%_eq u tm);
			in	if all bvs (not o switch is_free_in tm)
				then X
				else tm
			end
		);
		val mediator = term_map aux tm;
	in
		var_subst (combine xs Xs) mediator
	end
	handle complaint =>
	(map (fn (x,y) => if type_of x = type_of y
			then ()
			else term_fail "subst" 3012 [x,y])
		subs;
	reraise complaint "subst")
);
=TEX
\subsection{$inst$}
=SML
fun	 €inst›
	(avoid : TERM list)
	(tysubs : (TYPE * TYPE) list)
	: TERM -> TERM = (
let	val vs = ((map dest_var avoid)
		handle complaint => 
		pass_on complaint "dest_var" "inst");
	val tys = ((map (Combinators.I ** dest_vartype) tysubs)
		handle complaint => 
		pass_on complaint "dest_vartype" "inst");
in
	(fn tm =>
	icl'inst
	vs
	tys
	tm
	handle (Fail _) => tm)
end);
=TEX
=SML
end; (* of structure icl'TypesAndTerms *)
=TEX
We now open the structure for system creation, though the user will only see
the items provided by the structure via the opening of structure
$TypesAndTerms$, in \cite{DS/FMU/IED/IMP004}.
=SML
open icl'TypesAndTerms;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


