=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Release 1  ICL HOL: Implementation for Types and Terms}  %% Mandatory field
\def\TPPheadtitle{Release 1  ICL HOL \cr Implementation for Types and Terms}
\TPPref{DS/FMU/IED/IMP003}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FMU Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
Based on the first part of DS/FMU/IED/SML002.
\item [Issue 1.2]
Minor corrections and prettifying of characters.
Hid $TERM\_term$ from user.
\item [Issue 1.3]
Changes to mirror changes to version 1.5 of \cite{DS/FMU/IED/DTD003}.
\end{description}
\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the types and terms of ICL HOL, and utilities to handle them, called for by section 4.2 of the Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The high-level specification for the code may be considered
to be given in \cite{DS/FMU/IED/SPC001}.
The design is in \cite{DS/FMU/IED/DTD003}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the types and terms of ICL HOL, and utilities to handle them.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD003},
and also requires those files indicated as preceding it in the 
rel001 makefile.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}

=TEX
\section{TYPES AND TERMS}
=SML
structure âicl'TypesAndTermsá : icl'TypesAndTerms = struct
=TEX
\subsection{Types}
=SML
datatype âTYPEá =
		âmk_vartypeá of string |
		âmk_typeá    of string * TYPE list;
=TEX
=SML
fun âdest_typeá ((mk_vartype s):TYPE) : string * TYPE list = (
	fail "dest_type" 3001 [(fn(u:unit)=> s)]
) | dest_type (mk_type(s, tl)) = (s, tl);
=TEX
=SML
fun âdest_vartypeá ((mk_vartype s):TYPE) : string = s
 | dest_vartype _ = fail "dest_vartype" 3019 [];
=TEX
=SML
fun âis_vartypeá ((mk_vartype _):TYPE) : bool = true
| is_vartype (mk_type _) = false;
=SML
fun âmk_funá ((ty1, ty2) : TYPE * TYPE) : TYPE = (
	mk_type("‹", [ty1, ty2])
);
=TEX
$icl'inst\_type$ $alist$ $type$ recursively descends through $type$, replacing any type variables by whatever the association list $alist$ associates with them.
If the association list does not contain a type variable found in $type$, then that type variable will not be changed.
Replaced types are {\bf not} recursively processed by this function.
=SML
fun âicl'inst_typeá (f : (TYPE * string) list) (mk_vartype s : TYPE) : TYPE = (
	rassoc2 f mk_vartype s
) | icl'inst_type (f : (TYPE * string) list) (mk_type (s, tl)) : TYPE = (
	mk_type(s, map (icl'inst_type f) tl)
);
=TEX
This function extracts the type constructors contained
in a type.
=SML
fun âtype_tyconsá ((mk_vartype _): TYPE) : (string * int) list = []
| type_tycons (mk_type(s, tl)) = list_cup (map type_tycons tl) grab (s, length tl);
=TEX
This function extracts the type variables contained
in a type.
=SML
fun âtype_tyvarsá ((mk_vartype s): TYPE) : string list = [s]
| type_tyvars (mk_type(_, tl)) = list_cup (map type_tyvars tl);
=TEX
=SML
fun âtype_anyá (p : TYPE -> bool) (ty : TYPE) : bool = (
let 	fun aux (mk_vartype _) = false
	| aux (mk_type(_,tyl)) = ( 
	let
		fun list_type_any (lty :: ltyl) = (
		p lty orelse aux lty orelse list_type_any ltyl
		) | list_type_any [] = false
	in
		list_type_any tyl
	end)
in
	p ty orelse aux ty
end);	
=TEX
=SML
val âBOOLá : TYPE = mk_type("BOOL", []);
=TEX
\subsection{Well-Formedness and the Type of Well-Formed Terms}
Since we give the type of well-formed terms as an
abstract datatype whose constructor functions raise
exceptions if their arguments are incompatible, we do
not need to define the well-formedness predicate.

There is some choice for the
representation for well-formed terms.
At one extreme, we need only to know types in the leaves
of the expression trees --- this means we must recompute
the type of the term from scratch whenever we need it.
At the opposite extreme, we could keep type information
for every node in the tree --- but this might take
up a lot of space. We will try a compromise which allows
the type of a term and its immediate subterms to
be computed using only simple combinations of information
available at the corresponding node.

At nodes of a term tree other than the root,
type information is only given for combinations
(where we give the type of the result and the type
of the argument).
At the root of the tree we give the type unless the
term is a combination, when the type information is
available ``just underneath''.

Instead of the $\it has\_mk\_\ldots$ functions,
we give a constructor function ($mk\_\ldots$),
a destructor function ($dest\_\ldots$) and
a test function ($is\_\ldots$) for each syntactic
class.

=SML
local
	datatype âTERM_termá =
	âicl'Vará of string |
	âicl'Constá of string |
	âicl'Combá of TERM_term * TERM_term * TYPE |
	âicl'Absá of string * TERM_term
in
abstype âTERMá =
	typed of TERM_term * TYPE
with
=TEX
The type of destroyed terms, and functions upon it:
=SML
datatype âDEST_TERMá = âVará of string * TYPE |
	âConstá of string * TYPE |
	âCombá of TERM * TERM |
	âAbsá of TERM * TERM;
=TEX
Initially we are pedantic about matching function types arrows.
After extensive testing we might assume the presence of matches in some functions, such as $dest\_TERM$,
as their absence would indicate a design error, not a usage error.
=SML
fun âdest_TERMá ((typed (icl'Var s, ty)):TERM) : DEST_TERM = Var (s, ty)
| dest_TERM (typed (icl'Const s, ty)) = Const (s,  ty)
| dest_TERM (typed (icl'Comb(t1, t2, ty2),ty1ty2)) = (
	Comb (typed(t1, mk_fun (ty2, ty1ty2)), typed(t2, ty2))
) | dest_TERM (typed (icl'Abs(str, tm), mk_type("‹",[ty1, ty2]))) = (
	Abs (typed(icl'Var str, ty1), typed(tm, ty2))
) | dest_TERM _ = error "dest_TERM" 3063 [];
=TEX
=SML
fun  âmk_TERMá ((Var (s, ty)): DEST_TERM) : TERM = typed(icl'Var s, ty)
| mk_TERM (Const (s, ty)) = typed(icl'Const s, ty)
| mk_TERM (Comb (typed(tm1,mk_type("‹", [ty1, ty2])), typed(tm2,ty3))) = (
	if (ty1 = ty3)
	then typed(icl'Comb(tm1, tm2, ty3), ty2)
	else fail "mk_TERM" 3002 []
) | mk_TERM (Abs (typed(icl'Var s, ty1), typed(bdy, ty2))) = (
	typed(icl'Abs(s, bdy), mk_fun(ty1, ty2))
) | mk_TERM (Comb _) = fail "mk_TERM" 3003 []
  | mk_TERM (Abs _) = fail "mk_TERM" 3020 [];
=TEX
=SML
fun âtype_ofá ((typed (_, ty)):TERM):TYPE = ty;
=TEX
=SML
fun âmk_vará ((v, ty):string * TYPE): TERM = typed (icl'Var v, ty);

fun âdest_vará ((typed (icl'Var s, ty)):TERM) : string * TYPE = (s, ty)
|   dest_var _ = fail "dest_var" 3008 [];

fun âis_vará ((typed (icl'Var _, _)): TERM) : bool = true
|   is_var _ = false;
=TEX
=SML
fun âmk_constá((v, ty):string * TYPE): TERM = typed (icl'Const v, ty);

fun âdest_constá ((typed (icl'Const s, ty)): TERM):string * TYPE = (s, ty)
|   dest_const _ = fail "dest_const" 3009 [];

fun âis_constá ((typed (icl'Const _, _)): TERM):bool = true
|   is_const _ = false;
=TEX
=SML
fun âmk_combá((typed(f, mk_type("‹", [ty1, ty2])), typed(atm, aty)): 
		TERM * TERM) : TERM = (
	if ty1 = aty
	then typed(icl'Comb(f, atm, aty), ty2)

	else fail "mk_comb" 3005 []
) | mk_comb  _ = (
	fail "mk_comb" 3006 []
);

fun âdest_combá ((typed(icl'Comb(ftm, atm, aty), faty)): TERM) : TERM * TERM =
	(typed(ftm, mk_fun (aty, faty)), typed(atm, aty))
|   dest_comb _ = fail "dest_comb" 3010 [];

fun âis_combá (typed(icl'Comb _, _)) = true
|   is_comb _ = false;
=TEX
=SML
fun âmk_simple_absá ((typed(icl'Var v, ty), typed(btm, bty)):TERM * TERM):TERM = (
	typed(icl'Abs(v, btm), mk_fun (ty, bty))
) | mk_simple_abs _ = fail "mk_simple_abs" 3007 [];

fun âdest_simple_absá ((typed(icl'Abs (s, b), mk_type(_, [ty1, ty2]))): TERM): TERM * TERM =
	(typed(icl'Var s, ty1), typed(b, ty2))
|   dest_simple_abs _ = fail "dest_simple_abs" 3011 [];

fun âis_simple_absá (typed(icl'Abs _, _)) = true
|   is_simple_abs _ = false;
=TEX
Equality upon terms is simple equality on their representations.
=SML
val op âTERM_eqá = op = : (TERM * TERM) -> bool;
=TEX
This is present in the abstract data type for speed reasons:
it is frequently used in critical functions.
=SML
local
	fun fvaux
		(bvs : (string * TYPE) list)
		(fvs : (string * TYPE) list)
		(icl'Comb(tm1, tm2, ty2) : TERM_term) 
		(ty1 : TYPE) : (string * TYPE) list = (
		fvaux bvs (fvaux bvs fvs tm1 (mk_fun(ty2, ty1)))
			tm2 ty2
	) | fvaux bvs fvs (icl'Const _) _ = fvs
	| fvaux bvs fvs (icl'Var s) ty = (
		if (s,ty) mem bvs
		then fvs
		else fvs grab (s,ty)
	) | fvaux bvs fvs (icl'Abs (s, bdy)) (mk_type("‹",[ty1, ty2])) = (
		fvaux ((s, ty1) :: bvs) fvs bdy ty2
	) | fvaux _ _ _ _ = error "icl'frees" 3064 [];
in
	fun âicl'freesá ((typed (tm, ty)):TERM) : (string * TYPE) list = (
		fvaux [] [] tm ty
	);
end;
=TEX
=SML
end; (* of abstype TERM *)
end; (* of local *)
=TEX
\subsection{Functions derived from Abstract Data Type $TERM$}
=SML
fun âis_free_var_iná ((vs, vty) : string * TYPE) (tm : TERM) : bool = (
let
	fun ifvi (Comb (f, a)) = ifvi (dest_TERM f) orelse ifvi (dest_TERM a)
	| ifvi (Const _) = false
	| ifvi (Var (s,ty)) = (s = vs) andalso (vty = ty)
	| ifvi  (Abs (av, bdy)) = (dest_var av <> (vs, vty)) andalso ifvi (dest_TERM bdy)
in
	ifvi (dest_TERM tm)
end);
=TEX
=SML
fun âlist_mk_simple_absá ((tml, f):TERM list * TERM): TERM = (
	fold mk_simple_abs tml f
);

fun âlist_mk_combá ((f:TERM), ([]:TERM list)) : TERM = f
|   list_mk_comb (f, (a1 :: a2ton)) = list_mk_comb(mk_comb(f, a1), a2ton);

fun âstrip_combá (tm : TERM) = (
	let	fun aux t args = (
			if is_comb t
			then	let	val (f, a) = dest_comb t;
				in	aux f (a::args)
				end
			else (t, args)
		);
	in	aux tm []
	end
);
=TEX
\subsection{Derived $TERM$ Functions}
A performance issue arises with the destructor functions for
derived term constructors: need they test the types of constants?
Here we do not make this test. It is not necessary if the
definition of two constants with the same name is
disallowed.
=SML
fun âmk_bin_opá (area_name : string) (msg : int)
	(rator : TYPE -> TYPE -> TERM)
	((lhs, rhs) : TERM * TERM) : TERM = (
	(mk_comb(mk_comb(rator(type_of lhs)(type_of rhs), lhs), rhs))
	handle complaint =>
		divert complaint "mk_comb" area_name msg []
);

fun âdest_bin_opá (area_name : string) (msg : int) (op_name : string)
	(tm : TERM) : TERM * TERM = (
	let val (Oplhs, rhs) = dest_comb tm
	    val (Op, lhs) = dest_comb Oplhs
	in	if fst(dest_const Op) = op_name
		then (lhs, rhs)
		else fail area_name msg []
	end
	handle (Fail _) => fail area_name msg []
);

fun âis_bin_opá (dest : TERM -> 'a) (tm : TERM) : bool = (
	(dest tm; true) handle (Fail _) => false
);

fun âlist_mk_bin_opá (area_name : string) (msg : int)
	(rator : TYPE -> TYPE -> TERM)
	(tml : TERM list) = (
let
	val tol = type_of (hd tml);
	val rat = rator tol tol;
	fun aux [tm] = tm
	| aux (tm :: tmrest) = (mk_comb(mk_comb(rat, tm), aux tmrest))
	| aux [] = fail "list_mk_bin_op" 3017 [];
in
	aux tml
end
handle complaint =>
	list_divert complaint area_name 
		[("hd",3017, []),
		 ("mk_comb", msg, [])]
);
	

fun âstrip_bin_opá (op_name : string) (tm : TERM): TERM list =
	let val (Oplhs, rhs) = dest_comb tm
	    val (Op, lhs) = dest_comb Oplhs
	in	if fst(dest_const Op) = op_name
		then (lhs :: strip_bin_op op_name rhs)
		else [tm]
	end
	handle (Fail _) => [tm];
=TEX
=SML
fun âmk_mon_opá (area_name : string) (msg : int)
	(rator : TYPE -> TERM)
	(rand : TERM) : TERM = (
	(mk_comb(rator(type_of rand), rand))
	handle complaint => divert complaint "mk_comb" area_name msg []
);

fun âdest_mon_opá (area_name : string) (msg : int) (op_name : string)
	(tm : TERM) : TERM = (
	let val (rator, rand) = dest_comb tm
	in	if fst(dest_const rator) = op_name
		then rand
		else fail area_name msg []
	end
	handle (Fail _) => fail area_name msg []
);

fun âis_mon_opá (dest : TERM -> 'a) (tm : TERM) : bool = (
	(dest tm; true) handle (Fail _) => false
);
=TEX
=SML
fun âmk_simple_binderá (area_name : string) (msg : int)
	(binder : TYPE -> TYPE -> TERM)
	((var, body) : TERM * TERM) : TERM = (
	(mk_comb(binder(type_of var)(type_of body), mk_simple_abs(var, body)))
	handle complaint =>
		list_divert complaint area_name 
		[("mk_comb", msg, []),
		 ("mk_simple_abs", msg, [])]
);

fun âdest_simple_binderá (area_name : string) (msg : int) (op_name : string)
	(tm : TERM) : TERM * TERM = (
	let	val (binder, abs) = dest_comb tm;
		val (var, body) = dest_simple_abs abs;
	in	if fst (dest_const binder) = op_name
		then (var, body)
		else fail area_name msg []
	end
	handle (Fail _) => fail area_name msg []
);

val âis_simple_binderá: (TERM -> 'a) -> TERM -> bool = is_bin_op;
=TEX
=SML
fun âbin_bool_opá (name : string) (_:TYPE) (_:TYPE): TERM = (
	mk_const(name, mk_fun (BOOL,(mk_fun (BOOL, BOOL))))
);
=TEX
=SML
fun âequalityá (ty : TYPE) (_ : TYPE) : TERM = mk_const("=", mk_fun (ty, (mk_fun (ty, BOOL))));

val âmk_eqá : (TERM * TERM) -> TERM= mk_bin_op "mk_eq" 3013 equality;

val âdest_eqá : TERM -> (TERM * TERM)= dest_bin_op "dest_eq" 3014 "=";

val âis_eqá : TERM -> bool = is_bin_op dest_eq;
=TEX
=SML
val âmk_Šá : (TERM * TERM) -> TERM = mk_bin_op "mk_Š" 3015 (bin_bool_op "Š");

val âdest_Šá : TERM -> (TERM * TERM) = dest_bin_op "dest_Š" 3016 "Š";

val âis_Šá : TERM -> bool = is_bin_op dest_Š;

val âlist_mk_Šá : TERM list -> TERM = (
	list_mk_bin_op  "list_mk_Š" 3018 (bin_bool_op "Š")
);

val âstrip_Šá : TERM -> TERM list = strip_bin_op "Š";
=TEX
=SML
fun âquantifierá (name : string) (vty : TYPE) (_ : TYPE)  : TERM = (
	mk_const(name, mk_fun ((mk_fun (vty, BOOL)), BOOL))
);

val âmk_simple_ƒá : (TERM * TERM) -> TERM = (
	mk_simple_binder "mk_simple_ƒ" 3031 (quantifier "ƒ")
);

val âdest_simple_ƒá : TERM -> (TERM * TERM) = (
	dest_simple_binder "dest_simple_ƒ" 3032 "ƒ"
);

val âis_simple_ƒá : TERM -> bool = is_simple_binder dest_simple_ƒ;

fun âlist_mk_simple_ƒá ((tml, f):TERM list * TERM): TERM = (
	fold mk_simple_ƒ tml f
);

val âmk_simple_„á : TERM * TERM -> TERM = (
	mk_simple_binder "mk_simple_„" 3031 (quantifier "„")
);

val âdest_simple_„á: TERM -> (TERM * TERM) = (
	dest_simple_binder "dest_simple_„" 3034 "„"
);

val âis_simple_„á : TERM -> bool = is_simple_binder dest_simple_„;

fun âlist_mk_simple_„á ((tml, f):TERM list * TERM): TERM = (
	fold mk_simple_„ tml f
);
=TEX
\subsection{Functions Upon Terms}
\subsubsection{$\alpha$-conversion}
This is probably the most compact presentation, but it might be faster to match only the first argument, and then test the second separately.
Otherwise we will always do four tests on mismatched structures.
This depends on the cleverness of compilation.
=SML
fun âaconvá (tm1 : TERM) (tm2 : TERM) : bool = (
	let fun aux (Comb (tm11, tm12))(Comb(tm21, tm22)) map2to1 = (
		aux(dest_TERM tm11)(dest_TERM tm21) map2to1 andalso
		aux(dest_TERM tm12)(dest_TERM tm22) map2to1
	) | aux (Const c1)(Const c2) map2to1 = (c1 = c2)
	  | aux (Var v1)  (Var v2) map2to1 = (lassoc1 map2to1 v2 = v1
		andalso rassoc1 map2to1 v1 = v2
	) | aux (Abs(v1,b1)) (Abs(v2, b2)) map2to1 = (
		aux (dest_TERM b1) (dest_TERM b2) (((dest_var v1), (dest_var v2)) :: map2to1)
	) | aux _ _ _ = false
 	in
		(tm1 TERM_eq tm2) orelse (aux (dest_TERM tm1) (dest_TERM tm2) [])
	end
);
=TEX
\subsubsection{Substitution}
A destroyed variable renaming function, used in substitution:
=SML
fun âicl'variantá (vars : (string * TYPE) list) ((s, ty) : string * TYPE) : string = (
	if not (any vars (fn (s1, _) => s = s1))
	then s
	else	let val vars2 = map fst (vars drop (fn (_, ty1) => ty <> ty1))
		    fun aux n = (
			if contains vars2 n
			then aux (n ^ "'")
			else n
		    )
		in aux s
		end
);
=TEX
=IGN
$new\_frees$ in the below, determines the free variables in the abstraction, changes those found in $R$ to their substitution, finds the frees in the results, and flattens these to gain a single list of resulting frees.
=SML
fun âicl'substá (R : (TERM * (string * TYPE)) list) (tm : TERM) : TERM = (
	let
	fun aux R (Comb(f, a)) = mk_comb(aux R (dest_TERM f), aux R (dest_TERM a))
	| aux R (Const c) = mk_const c
	| aux R (Var v) = rassoc2 R mk_var v
	| aux R (Abs(vty, b)) = (
		let	val (s, ty) = dest_var vty
			val new_frees =
				flat (map
				(icl'frees o rassoc2 R mk_var)
				(icl'frees b less (s, ty)));
			val s' = icl'variant new_frees (s, ty)
			val vty' = mk_var (s', ty)
			val RR = (vty', (s, ty)) :: R;
			val b' = aux RR (dest_TERM b);
		in mk_simple_abs(vty', b')
		end
	);
	in
		if all R (fn (t, (_, ty)) => type_of t = ty)
		then aux R (dest_TERM tm)
		else fail "icl'subst" 3052 []
	end
);
=TEX
\subsubsection{Renaming}
=SML
fun ârenameá ((v, ty) : string * TYPE) (w : string) (tm : TERM) : TERM = (
	icl'subst[(mk_var(w, ty), (v, ty))]tm
);
=TEX
\subsubsection{Instantiation of Types and Terms}
=SML
local
	fun	inst_loc1 
		(tysubs : (TYPE * string) list)
		(Comb(f, a) : DEST_TERM)
		(vars : (string * TYPE) list)
		(varmap : ((string * TYPE) * (string * TYPE)) list)
		: TERM = (
			mk_comb(inst_loc1 tysubs (dest_TERM f) vars varmap,
				inst_loc1 tysubs (dest_TERM a) vars varmap)
	) | inst_loc1 tysubs (Const(s,ty)) vars varmap = (
		mk_const(s, icl'inst_type tysubs ty)
	) | inst_loc1 tysubs (Var(s,ty)) vars varmap = (
		mk_var(lassoc3 varmap (s,ty))
	) | inst_loc1 tysubs (Abs(v, b)) vars varmap = (
		let	val sty as (s, ty) = dest_var v
			val ty' = icl'inst_type tysubs ty
			val sty' = (icl'variant vars (s, ty'), ty')
		in mk_simple_abs(mk_var sty',
			inst_loc1
			tysubs
			(dest_TERM b)
			(sty' :: vars)
			((sty, sty') :: varmap))
		end
	);
=TEX
=SML
	fun rename_dups _ _ [] = []
	|   rename_dups tysubs av ((s, ty) :: rest) = (
		let	val ty' = icl'inst_type tysubs ty;
		in	if ty = ty'
			then (s, ty) :: rename_dups tysubs av rest
			else
				let val sty' = (icl'variant av (s, ty'), ty')
				in sty' :: rename_dups tysubs (sty' :: av) rest
				end
		end);
	fun	inst_loc2
		(avoid : (string * TYPE) list)
		(tysubs : (TYPE * string) list)
		(frees : (string * TYPE) list)
		:	((string * TYPE) * (string * TYPE)) list = (
			combine
			frees
			(rename_dups
			tysubs
			(frees @ avoid)
			frees)
	);
=TEX
=SML
in
	fun	âicl'instá
		(avoid : (string * TYPE) list)
		(tysubs : (TYPE * string) list)
		(tm : TERM) : TERM = (
		inst_loc1
		tysubs
		(dest_TERM tm)
		nil
		(inst_loc2 avoid tysubs (icl'frees tm))
	);
end; (* of local ... in ... end *)
=TEX
=SML
fun âterm_typesá (tm : TERM) : TYPE list = (
let	fun aux (Comb (f, a)) = (
		aux (dest_TERM f) cup aux (dest_TERM a)
	) | aux (Const (_, ty)) = [ty]
	  | aux (Var (_,ty)) = [ty]
	  | aux (Abs (v, b)) = aux (dest_TERM b) grab (type_of v)
in
	aux(dest_TERM tm)
end);
=TEX
=SML
fun âterm_anyá (p : TERM -> bool) (tm : TERM) : bool = (
let	fun aux (Comb (f, a)) = (
		p f orelse p a orelse
		aux (dest_TERM f) orelse
		aux (dest_TERM a)
	) | aux (Const _) = false
	  | aux (Var _) = false
	  | aux (Abs (v, b)) = (
		p v orelse p b orelse
		aux (dest_TERM b)
	)
in
	p tm orelse aux (dest_TERM tm)
end);
=TEX
=SML
val âterm_tyvarsá = list_cup o (map type_tyvars) o term_types;
=TEX
=SML
fun âterm_type_constructorsá (tm : TERM) : (string * int) list = (
let
	fun aux (Comb (f, a)) = (
		aux (dest_TERM f) cup aux (dest_TERM a)
	) | aux (Const (_, ty)) = type_tycons ty
	  | aux (Var (_,ty)) = type_tycons ty
	  | aux (Abs (v, b)) = aux (dest_TERM b) cup (type_tycons(type_of v))
in
	aux(dest_TERM tm)
end);
=TEX

This function extracts the subterms of a term which
are constants.
=SML
fun âterm_constantsá (tm : TERM) : (string * TYPE) list = (
let fun aux (Comb(f, a)) = aux(dest_TERM f) cup aux(dest_TERM a)
	| aux (Var _) = []
	| aux (Const c) = [c]
	| aux (Abs (v, b)) = aux (dest_TERM b)
in
	aux (dest_TERM tm)
end);
=TEX
\subsubsection{$term\_match$ and $type\_match$}
We will need functions which attempt to determine
if one type (or term) is an instance of another.
$type\_match\;ty1\;ty2$ determines if the type $ty1$
is an instance of $ty2$.
If so it returns a list giving the correspondence between
types in $ty1$ with type variables in $ty2$.
If not it raises an exception.
Similarly $term\_match\;tm1\;tm2$ determines if the term
$tm1$ is an instance of $tm2$. If so it returns
a pair of lists, the first giving the correspondence
between types and the second the correspondence between
free variables of (the appropriate type instance of)
$tm2$ and corresponding subterms of $tm1$.
As with $type\_match$, an exception is raised if the
matching is unsuccessful.

The main work of the matching is done by
auxiliary functions ($tyaux1$ and $tmaux2$).
These
operate in a fairly straight forward way by a structural
recursion on their second type (or term) argument building
up the correspondence between leaves in the structure
and substructures of the first type (or term) argument.
$tmaux2$ uses $tyaux1$ to process types in the terms.

=SML
local
=TEX
$tyaux1$ is quite straightforward. It uses an auxiliary
$tyaux0$ to handle lists of types:
=SML
	fun tyaux1 match t1 (mk_vartype s2) = (
		if rassoc4 match t1 s2 = t1
		then match grab (t1, s2)
		else fail "type_match" 3053 []
	) | tyaux1 match (mk_type(s1, tl1)) (mk_type(s2, tl2)) = (
		let	fun tyaux0 match [] [] = (
				match
			) | tyaux0 match (h1 :: t1) (h2 :: t2) = (
				tyaux0 (tyaux1 match h1 h2) t1 t2
			) | tyaux0 _ _ _ = fail
			"type_match"  3053 [];
		in
			if s1 = s2
			then tyaux0 match tl1 tl2
			else fail "type_match"  3053 []
		end
	) | tyaux1 _ _ _ = fail "type_match"  3053 [];
=TEX
The treatment of terms is more complex than that of types
because of bound variables.
As a result $tmaux2$ is supported by two auxiliary functions, $tmaux1$ and $tmaux0$.
The three functions work with two association lists:
$fvmatch$, which records the correspondence between subterms
of $tm1$ and free variables of $tm2$ and $bvmatch$,
which records the correspondence between
those bound variables of the two terms which are in
scope in the subterm being examined.
It is convenient for $fvmatch$ to have type
$TERM * (string * TYPE)$ and for $bvmatch$
to have type $(string * TYPE) * (string * TYPE)$,
since these choices facilitate the use of $rassoc5$ etc.

$tmaux0$ handles the case when we have encountered a
variable, $v2$ say, in $tm2$ alongside a subterm, $t1$ say, of
$tm1$ which is known not to be
bound variable of $tm1$ (by inspection of $bvmatch$).
We first check that $v2$ is not bound and that
no free variable of $t1$ is bound, if these conditions
are not satisfied the terms do not match.
Assuming all is well,
if we have encountered $v2$ before there
will be an entry for it in $fvmatch$ and
$t1$ must agree (up to $\alpha$-conversion) with that entry.
If we have not encountered $v2$ before,
there will be no entry in $fvmatch$ for it and now
is the time to make one, using $tyaux1$ to handle the
type matching.
=SML
	fun tmaux0  (tymatch, fvmatch) bvmatch tm1 (v2ty2 : string * TYPE) = (
		case rassoc5 bvmatch v2ty2 of
			Nil => (
				if any (icl'frees tm1) (fn x => any bvmatch (fn (x1, _) => x = x1))
				then fail "term_match" 3054 []

				else case rassoc5 fvmatch v2ty2 of
					Value tm1' => (
						if aconv tm1 tm1'
						then (tymatch, fvmatch)
						else fail "term_match" 3054 []
				) |	Nil => (
						let	val tymatch' =
						tyaux1 tymatch (type_of tm1) (snd v2ty2);
						in	(tymatch', (tm1, v2ty2) :: fvmatch)
						end
				)
			) |	Value _ => fail "term_match" 3054 []
	);
=TEX
$tmaux1$ handles the case when we have encountered a variable, $v2$ say,
in $tm2$.
If the corresponding subterm, $t1$ say, of $tm1$ is
a variable, then we must consult $bvmatch$ to see whether
it is a bound variable.
If it is, then all we must do is consult
$bvmatch$ again to ensure that $v2$ is the corresponding
bound variable of $tm2$, and fail if it is not.
If $t1$ is either a free variable of $tm1$ or some
other sort of term then we just pass the problem
on to $tmaux0$.
=SML
	fun tmaux1 (tymatch, fvmatch) (bvmatch : ((string * TYPE) * (string * TYPE)) list) 
			tm1 v2ty2 = (
		if is_var tm1
		then	let val v1ty1 = dest_var tm1;
			in case lassoc5 bvmatch v1ty1 of
				Value vty => (
					if vty = v2ty2 andalso rassoc5 bvmatch v2ty2 = Value v1ty1
					then (tymatch, fvmatch)
					else fail "term_match" 3054 []
			) |	Nil => tmaux0 (tymatch, fvmatch) bvmatch tm1 v2ty2
			end
		else 	tmaux0 (tymatch, fvmatch) bvmatch tm1 v2ty2
	);
=TEX
$tmaux2$ handles the general case. If the subterm, $t2$ say,
of $tm2$ is a variable, then $tmaux1$ is applied.
If $t2$ is a constant then the corresponding subterm
of $tm2$ must also be a constant with the same
name and we just use 
$tyaux1$ to handle the type instantiation.
If $t2$ is a combination, then the corresponding subterm
of $tm1$ must be too. The subterms of the
combinations are examined in turn, with matching information
gleaned from the operator passed on for use in examining
of the operand.
If $t2$ is an abstraction, then so must be the corresponding
subterm of $tm1$. The bodies of the abstractions
are examined with the bound variable matching information
in $bvmatch$ suitably adjusted.
Mismatched structures will result in an exception.
=SML
	fun tmaux2 (tymatch, fvmatch) bvmatch (Comb(f1, a1)) (Comb(f2, a2)) = (
		tmaux2 (tmaux2 (tymatch, fvmatch) bvmatch (dest_TERM f1) (dest_TERM f2))
			bvmatch 
			(dest_TERM a1) 
			(dest_TERM a2)
	) | tmaux2 (tymatch, fvmatch) bvmatch (Const(s1,ty1))(Const(s2,ty2)) = (
		if s1 = s2
		then (tyaux1 tymatch ty1 ty2, fvmatch)
		else fail "term_match" 3054 []
	) | tmaux2 (tymatch, fvmatch) bvmatch tm1 (Var v2) = (
		tmaux1 (tymatch, fvmatch) bvmatch (mk_TERM tm1) v2
	) | tmaux2 (tymatch, fvmatch) bvmatch (Abs(v1,b1))(Abs(v2,b2)) = (
		
		let	val v1ty1 = dest_var v1;
			val v2ty2 = dest_var v2;
			val bvmatch' = (v1ty1, v2ty2) :: bvmatch;
			val tymatch' = tyaux1 tymatch (snd v1ty1) (snd v2ty2);
		in	tmaux2 (tymatch', fvmatch) bvmatch' (dest_TERM b1) (dest_TERM b2)
		end
	) | tmaux2 _ _ _ _ = fail "term_match" 3054 [];
in
=TEX
It will often be the case that identical subtypes or
subterms correspond.
For compactness, the result lists of the matching functions
do not contain trivial correspondences.
$type\_match$ and $term\_match$ therefore both work
by calling the relevant auxiliary and then
removing trivial correspondences from the result.
=SML
	fun âtype_matchá (ty1 : TYPE) (ty2 : TYPE) : (TYPE * TYPE) list = (
		map(Combinators.I ** mk_vartype)
		((tyaux1 [] ty1 ty2) drop (fn (x, y) => x = mk_vartype y))
	);
	fun âterm_matchá (tm1 : TERM) (tm2 : TERM)
		: (TYPE * TYPE) list * (TERM * TERM) list = (
		let	val (tym, tmm) = tmaux2 ([], []) [] (dest_TERM tm1) (dest_TERM tm2);
			val tym' = tym drop (fn (x, y) => x = mk_vartype y);
			val tmm' = tmm drop
		(fn (x, (s, ty)) => x TERM_eq mk_var(s, icl'inst_type tym' ty));
			val tmm'' = map (fn(x, (s,_)) => (x, (s, type_of x))) tmm';
		in 	(map(Combinators.I ** mk_vartype)tym',
			 map(Combinators.I ** mk_var)tmm'')
		end handle (Fail _) => fail "term_match" 3054 []
	);
end;
=TEX
=SML
fun âis_type_instanceá (ty1 : TYPE) (ty2 : TYPE) : bool = (
	(type_match ty1 ty2; true)
	handle (Fail _) => false
);
=TEX
\subsubsection{Functions Concerning Term Variables}
=SML
fun âvariantá (vs : TERM list) (v : TERM) : TERM = (
	(if is_var v
	then (let val (s, ty) = dest_var v;
	in
		if not (any vs (fn v1 => s = fst(dest_var v1)))
		then v
		else	let val vs2 = map fst ((map dest_var vs) drop (fn (_, ty1) => ty <> ty1))
			    fun aux n = (
				if contains vs2 n
				then aux (n ^ "'")
				else n
			    )
			in mk_var(aux s, ty)
			end
	end)
	else fail "variant" 3056 [])
handle complaint => divert complaint "dest_var" "variant" 3057 []);

fun âlist_variantá (av : TERM list) ([]: TERM list) : TERM list = []
|   list_variant (av : TERM list) ((tm :: tms) : TERM list) : TERM list = (
	let	val tm' = variant av tm
	in	tm' :: list_variant (tm' :: av) tms
	end
);
=TEX
The following is a function to create a list of
machine genrated variables known to be different
to any existing in a list of terms.
It is very heavily tweaked for efficiency, and its local declarations are as follows.
\begin{description}
\item[mgn\_prefix]
This is the starting prefix for all machine-generated variables,
and should the prefix change, then only this declaraction need change.
\item[ord\_mgn\_prefix]
We hope that a fast if incomplete filter names is testing whether
the first character of any encountered name is the same as that
at the start of $mgn\_prefix$.
We do this by using $ord$ which gives the ascii value of the first
character in a string.
We precompute this value for $mgn\_prefix$.
\item[mg\_in\_term]
This gives the list of possible machine-generated names already
present in a single term, with no duplicates.
\item[mg\_in\_terms]
This gives the list of possible machine-generated names already
present in a list of terms, with no duplicates.
\item[mgs]
This is the list of possible machine-generated names present in
$mg\_variables$ term list.
\item[base\_mgns]
This is the list of names that will be used for our newly generated varibles, if there are no conflicts already.
\item[create\_mgv]
This creates one variable per type, named $(mgn\_prefix)nnn$,
where $nnn$ is the first number (starting from 0) for which the name is not already
in the list.
The $nnn$ carries over to the name of each new variable, so that
previously rejected names, and previously generated names are not 
tried once more.
This means we don't have to test the new names against themselves.
\end{description}.
It replaces the very fast, if slightly uncertain $genvar$, of the prototype ICL HOL.
It is less fast, but should always meet its specification.
=SML
local
	val mgn_prefix = "@_";
	val ord_mgn_prefix = ord mgn_prefix
in
fun âmg_variablesá (tyl : TYPE list) (tml : TERM list) : TERM list =  (
let fun mg_in_term acc (Comb(f, a)) = (
	let val acc' = mg_in_term acc (dest_TERM f)
	in mg_in_term acc' (dest_TERM a) end
	) | mg_in_term acc (Var (s,_)) = if ord s = ord_mgn_prefix
		then acc grab s
		else acc
	| mg_in_term acc (Const _) = acc
	| mg_in_term acc (Abs(v, b)) = if ord(fst(dest_var v)) = ord_mgn_prefix
		then mg_in_term (acc grab (fst(dest_var v))) (dest_TERM b)
		else mg_in_term acc (dest_TERM b);

	fun mg_in_terms acc (ltm :: ltml) = (
	let val acc' = mg_in_term acc (dest_TERM ltm)
	in mg_in_terms acc' ltml end
	) | mg_in_terms acc [] = acc;

	val mgs = mg_in_terms [] tml;

	fun create_mgv n ((lty :: ltyl):TYPE list) : TERM list = (
		if (mgn_prefix ^ string_of_int n) mem mgs
		then create_mgv (n+1) (lty :: ltyl)
		else (mk_var(mgn_prefix ^ string_of_int n, lty) :: 
			create_mgv (n+1) ltyl)
	) | create_mgv n [] = [];
in
	create_mgv 1 tyl
end);
end;
=TEX
=SML
val âis_free_iná : TERM -> TERM -> bool = is_free_var_in o dest_var;
=TEX
=SML
val âfreesá = map mk_var o icl'frees;
=TEX
$var\_subst$ is the direct interface to $icl'subst$.
Thus, unlike $subst$ (see below), it is only capable of
substituting for subterms of a term which are variables.
=SML
fun âvar_substá
	(subs : (TERM * TERM) list)
	(tm : TERM) = (
	((icl'subst o map (Combinators.I ** dest_var)) subs tm)
	handle X =>
	divert X "dest_var" "var_subst" 3060 []
);
=TEX
\subsubsection{Mapping over Terms}
This function is a minor convenience. In essence,
given a function, $tmfun$, and a term, $tm$, it traverses
$tm$ (breadth first) looking for subterms for which
the application $tmfun\,tm$ does not fail and replaces
such subterms with $tmfun\,tm$. In fact, it is convenient
for $tmfun$ to have as an extra parameter a list giving
the bound variables which are in scope at the point of use.
=SML
fun âTERM_mapá (tmfun :(TERM list) -> TERM -> TERM) (tm : TERM) : TERM = (
let
	fun aux
		(bvs : TERM list)
		(tm : TERM) 
		(Comb(f, a)) = (
			(tmfun bvs tm)
			handle (Fail _) =>
			mk_comb(aux bvs f (dest_TERM f),
			aux bvs a (dest_TERM a))
	) | aux bvs tm (Const _) = ((tmfun bvs tm) handle (Fail _) => tm)
	| aux bvs tm (Var _) = ((tmfun bvs tm) handle (Fail _) => tm)
	| aux bvs tm (Abs(v, b)) = (
		(tmfun bvs tm) handle (Fail _) =>
			mk_simple_abs(v, aux (v :: bvs) b (dest_TERM b))
	);
in
		aux [] tm (dest_TERM tm)
end);
=TEX
\subsection{$subst$}
This is the more general interface to $icl'subst$ or $var\_subst$ which
can substitute for arbitrary subterms of a term, not just
variables.
=SML
fun âsubstá
	(subs : (TERM * TERM) list)
	(tm : TERM) = (
	let	val (xs, ys) = split subs;
		val terms = tm :: (xs @ ys); 
		val Xs = mg_variables (map type_of ys) terms;
		val ysXs = combine ys Xs;
		fun aux bvs tm = (
			let	val (t, X) = find ysXs (fn (u, Y) => aconv u tm);
			in	if all bvs (not o switch is_free_in tm)
				then X
				else tm
			end
		);
		val mediator = TERM_map aux tm;
	in
		var_subst (combine xs Xs) mediator
	end
);
=TEX
\subsection{$inst$}
=SML
fun	 âinstá
	(avoid : TERM list)
	(tysubs : (TYPE * TYPE) list)
	: TERM -> TERM = (
	let	fun dest (mk_vartype s) = s
		|   dest _ = fail "inst" 3062 [];
		
	in	icl'inst
		(map dest_var avoid)
		(map (Combinators.I ** dest) tysubs)
	end
	handle X => divert X "dest_var" "inst" 3061 []
);
=TEX
=SML
end (* of structure icl'TypesAndTerms *);
open icl'TypesAndTerms;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
)
