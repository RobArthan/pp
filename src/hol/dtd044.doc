=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
\TPPtitle{Detailed Design for the Theory of Sets}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the \cr
Theory of Sets}
\TPPref{DS/FMU/IED/DTD044}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K. Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{R.D. Arthan & WIN01\\K. Blackburn & WIN01}
\TPPauthorisation{R.D. Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
theory ``sets''.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1,1.2]
First drafts.
\item [Issue 1.3]
Correcting typos.
\item [Issue 1.4]
Changed to match \cite{DS/FMU/IED/HLD011}.
\item [Issue 1.5]
Changes following comments.
\item [Issue 1.6]
Simplified requirement on $IsSetRep$.

\item[Issue \SCCSversion, \FormatDate{92/01/20} ] Updated to use new fonts.

\end{description}
\subsection{Changes Forecast}
Populating theory with more theorems and functions.

\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design
for the theory ``sets'',
called for in \cite{DS/FMU/IED/HLD011}.
The design is implemented in \cite{DS/FMU/IED/IMP044}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the detailed design for the theory ``sets''.
This defines the type $SET$, and the operators upon it.

\subsubsection{Dependencies}
This document depends on \cite{DS/FMU/IED/IMP040},
and the theory design tools of \cite{DS/FMU/IED/DTD035}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
The theory is missing some already obvious theorem
members, and it may be appropriate to add others 
as development and application work progresses.
There should also be some tactics and inference rules.
However, when considering further theorems one should be aware of the power of just rewriting
with definitions, $set\_clauses$, and placing $(simple\_)ç\_conv$ in the
list of basic conversions (see $set\_rewrite\_convs$).
Many ``obvious'' theorems, such as $Ù\ µ\ S\ ∑S\ Ä\ S$,
can be proved, and therefore bypassed with such an approach.
The approach only fails if one wishes to keep the derived
set operators ``present'' in the goal.
\section{THE THEORY ``sets''}
\subsection{Design of the theory ``sets''}
=THDOC
req_name "sets" (Value "char");
=DESCRIBE
The theory ``€sets›'' defines a type of sets, operators upon the type,
and some associated theories.
=ENDDOC
=THDOC
req_const("IsSetRep",¨:('a ≠ BOOL) ≠ BOOLÆ);
req_defn("IsSetRep",([],¨IsSetRep = Ã x:'a ≠ BOOL∑ TÆ));
=DESCRIBE
The representation type of sets, as given by
$€IsSetRep›$ is just any function from
the type of objects of the set to ¨:BOOLÆ.
Its definition is saved under the key ``€IsSetRep›''.
=ENDDOC
=THDOC
req_type("SET",1);
req_defn("SET",([],¨∂ f:'a SET ≠ 'a ≠ BOOL∑ TypeDefn IsSetRep fÆ));
=DESCRIBE
The type of sets, $€SET›$ is given by the representation
function $IsSetRep$.
=ENDDOC
=THDOC
req_const("SetComp",¨:('a ≠ BOOL) ≠ 'a SETÆ);
req_binder "SetComp";
req_const("ç",¨:'a ≠ 'a SET ≠ BOOLÆ);
req_infix(230,"ç");
list_req_defn(["SetComp","ç"],
	([],¨µ (x : 'a) (p:'a ≠ BOOL) (S1: 'a SET) (S2 : 'a SET)∑
	(x ç {v | p v} § p x) ±
	((S1 = S2) § (µ x:'a∑ x ç S1 § x ç S2))
	Æ));
=DESCRIBE
The HOL constant $€SetComp›$ is a binder for forming set comprehensions.
The HOL constant $€ç›$ is set membership.
=ENDDOC
=THDOC
req_const("Empty",¨:'a SETÆ);
req_const("Insert",¨:'a ≠ 'a SET ≠ 'a SETÆ);
list_req_defn(["Empty","Insert"],
	([],¨µ (x : 'a) (y : 'a) (S: 'a SET) ∑
	≥(x ç {}) ±
	(x ç Insert y S § (x = y ≤ x ç S))Æ));
=DESCRIBE
The HOL constant $€Empty›$ is the empty set.
The HOL constant $€Insert›$ inserts an object into a set.
=ENDDOC
=THDOC
req_thm("set_clauses",([], ¨
	µ (x : 'a) (y : 'a) (p:'a ≠ BOOL) (q : BOOL) (S1: 'a SET) (S2 : 'a SET)∑
	≥(x ç {}) ±
	((x ç {v | q}) § q) ±
	(x ç {v | p v} § p x) ±
	(x ç {v | v = y} § (x = y)) ±
	(x ç {y} § (x = y)) ±
	((S1 = S2) § (µ x:'a∑ x ç S1 § x ç S2))Æ));
=DESCRIBE
``$€set\_clauses›$'' is a miscellaneous collection of theorems about sets, all appropriate
for rewriting, and some drawn from the definitions.
Note that we do not need a direct rule for $¨\{v | y = v\}Æ$,
as other clauses will give it indirectly:
we provide the clause in the first place as a way of rewriting one form of expressing a singleton set.
The definition of $Insert$ is excluded as there will sometimes
be good reasons why its form of rewriting won't be desired.
=ENDDOC
=THDOC
req_const("¿",¨:'a SET ≠ 'a SET ≠ 'a SETÆ);
req_infix(260, "¿");
req_defn("¿",([],¨µ (x:'a) (S1 : 'a SET) (S2 : 'a SET) ∑ 
	(x ç S1 ¿ S2) § (x ç S1 ≤ x ç S2)Æ));
=DESCRIBE
The HOL constant $€¿›$ represents set union.
=ENDDOC
=THDOC
req_const("°",¨:'a SET ≠ 'a SET ≠ 'a SETÆ);
req_infix(270, "°");
req_defn("°",([],¨µ (x:'a) (S1 : 'a SET) (S2 : 'a SET) ∑ 
	(x ç S1 ° S2) § (x ç S1 ± x ç S2)Æ));
=DESCRIBE
The HOL constant $€°›$ represents set union.
=ENDDOC
=THDOC
req_const("\\",¨:'a SET ≠ 'a SET ≠ 'a SETÆ);
req_infix(250, "\\");
req_defn("\\",([],¨µ (x:'a) (S1 : 'a SET) (S2 : 'a SET) ∑ 
	(x ç S1 \ S2) § (x ç S1 ± ≥ (x ç S2))Æ));
=DESCRIBE
The HOL constant €Backslash› represents set difference.
=ENDDOC
=THDOC
req_const("Ä",¨:'a SET ≠ 'a SET ≠ BOOLÆ);
req_const("†",¨:'a SET ≠ 'a SET ≠ BOOLÆ);
req_infix(230, "Ä");
req_infix(230, "†");
req_defn("Ä",([],¨µ S1 S2 : 'a SET ∑ 
	(S1 Ä S2) § µ x ∑ x ç S1 ¥ x ç S2Æ));
req_defn("†",([],¨µ S1 S2 : 'a SET ∑ 
	(S1 † S2) § ((S1 Ä S2) ± (∂ x ∑ ≥(x ç S1) ± (x ç S2)))Æ));
=DESCRIBE
The HOL constant $€Ä›$ represents set inclusion.
The HOL constant $€†›$ represents proper set inclusion.
=ENDDOC
=THDOC
req_const("ﬁ",¨:('a SET) SET ≠ 'a SETÆ);
req_const("•",¨:('a SET) SET ≠ 'a SETÆ);
req_defn("ﬁ",([],¨µ (x: 'a) (S: ('a SET) SET) ∑ 
	(x ç ﬁ S) § ∂ s ∑ x ç s ± s ç SÆ));
req_defn("•",([],¨µ (x: 'a) (S: ('a SET) SET) ∑ 
	(x ç • S) § µ s ∑ s ç S ¥ x ç sÆ));
=DESCRIBE
The HOL constant $€ﬁ›$ represents generalised union.
The HOL constant $€•›$ represents generalised intersection.
=ENDDOC
=THDOC
req_const("",¨:'a SET ≠ ('a SET) SETÆ);
req_defn("",([],¨µ (x : 'a SET) (S: 'a SET) ∑ 
	(x ç  S) § x Ä SÆ));
=DESCRIBE
The HOL constant $€›$ represents the power set constructor.
=ENDDOC
=THDOC
req_thm("ö_clauses",([], ¨µ (x : 'a) (S:'a SET) ∑
	{x | F} = {} ±
	≥ x ç {} ±
	{} ¿ S = S ±
	S ¿ {} = S ±
	{} ° S = {} ±
	S ° {} = {} ±
	S \ {} = S ±
	{} \ S = {} ±
	{} Ä S ±
	(S Ä {} § S = {}) ±
	({} † S § ≥ S = {}) ±
	≥ S † {} ±
	≥ x ç ﬁ {} ±
	x ç • {} ±
	{} ç  S ±
	( {} = {{}})Æ));
=DESCRIBE
The theorem ``$€ö\_clauses›$'' gives all the interactions of the empty set with the operators given in the theory ``sets''.
=ENDDOC
\subsection{Signature of the theory ``sets''}
=DOC
signature €SetsTheory› = sig
	val €set_clauses› : THM;
	val €ö_clauses› : THM;
	val €insert_def› : THM;
	val €¿_def› : THM;
	val €°_def› : THM;
	val €set_sub_def› : THM;
	val €Ä_def› : THM;
	val €†_def› : THM;
	val €ﬁ_def› : THM;
	val €•_def› : THM;
	val €_def› : THM;
=DESCRIBE
This is the signature in which we declare theory ``sets''.
$set\_clauses$ is bound the the theorem saved with the same name as
key,
$insert\_def$ is bound to the definition of $Insert$, saved with key $Insert$, and the other $\_def$ follow the same pattern.
=ENDDOC
=DOC
val €simple_ç_conv› : CONV;
=DESCRIBE
A conversion for set membership.
It cannot handle variable structures bound by the set comprehension.
=FRULE 1 Conversion
simple_ç_conv
¨x ç {v | p[v]}Æ
˜
˜
Ù x ç {v | p[v]} § p[x]
=TEX
=SEEALSO
$ç\_conv$
=FAILURE
44001	?0 is not of the form:¨x ç {v | p[v]}Æ
=ENDDOC
=SML
end;(* of signature SetsTheory *)
=TEX
\section{TEST POLICY}
Any functions given in this document should be tested according to the
general criteria set out in \cite{DS/FMU/IED/PLN008}, using the
tests in \cite{DS/FMU/IED/MDT044}.
In \cite{DS/FMU/IED/MDT044} the theory produced is checked by the theory design tools
of \cite{DS/FMU/IED/DTD035}, against the theory design provided.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


