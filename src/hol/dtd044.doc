=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
\TPPtitle{Detailed Design for the Theory of Sets}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the \cr
Theory of Sets}
\TPPref{DS/FMU/IED/DTD044}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\def\SCCSdate{\FormatDate{$Date$ %
}}
\TPPdate{\SCCSdate}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K. Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{R.D. Arthan & WIN01\\K. Blackburn & WIN01}
\TPPauthorisation{R.D. Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
theory ``sets''.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1,1.2]
First drafts.
\item [Issue 1.3]
Correcting typos.
\item [Issue 1.4]
Changed to match \cite{DS/FMU/IED/HLD011}.
\item [Issue 1.5]
Changes following comments.
\item [Issue 1.6]
Simplified requirement on $IsSetRep$.

\item[Issue 1.7, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.8 (23rd January 1992)]
$new\_axiom$, $simple\_new\_type\_defn$ and $new\_type\_defn$
all changed to take lists of keys, rather than single ones.
\item[Issue 1.9 (7th February 1992)]
Made $basic\_hol$ a parent.
\item[Issue \SCCSversion (\SCCSdate)]

The main purpose of the changes at this issue is to introduce new proof contexts.
The contexts introduced are $sets\_ext\_pc$ and $sets\_alg\_pc$.
$sets\_ext\_pc$ is a proof context suitable for automatic proof of results in this theory using extensionality of sets and elementary reasoning.
$sets\_alg\_pc$ is a proof context suitable for automatic simplification when conducting proofs which involve but are not primarily concerned with set theory.

In order to be able to introduce these proof contexts we have also included the definitions of the conversions which they use (after renaming these are $ç\_comp\_conv$ and $ç\_enum\_conv$), and various additional theorems which are used by the proof contexts.

\end{description}
\subsection{Changes Forecast}
The proof contexts should perhaps be built from $basic\_hol$ proof contexts rather that $pair$.
An existence prover should be included.

\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design
for the theory ``sets'',
called for in \cite{DS/FMU/IED/HLD011}.
The design is implemented in \cite{DS/FMU/IED/IMP044}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the detailed design for the theory ``sets''.
This defines the type $SET$, and the operators upon it.

\subsubsection{Dependencies}
This document depends on \cite{DS/FMU/IED/IMP040},
and the theory design tools of \cite{DS/FMU/IED/DTD035}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
The theory is missing some already obvious theorem
members, and it may be appropriate to add others 
as development and application work progresses.
There should also be some tactics and inference rules.
However, when considering further theorems one should be aware of the power of just rewriting with definitions, $set\_clauses$, and placing $(simple\_)ç\_conv$ in the list of basic conversions (see $set\_rewrite\_convs$).
Many ``obvious'' theorems, such as $Ù\ µ\ S\ ∑S\ Ä\ S$,
can be proved, and therefore bypassed with such an approach.
The approach only fails if one wishes to keep the derived
set operators ``present'' in the goal.
\section{THE THEORY ``sets''}
\subsection{Design of the theory ``sets''}
=THDOC
req_name "sets" (Value "basic_hol");
=DESCRIBE
The theory ``€sets›'' defines a type of sets, operators upon the type,
and some associated theories.
=ENDDOC
=THDOC
req_const("IsSetRep",¨:('a ≠ BOOL) ≠ BOOLÆ);
req_defn(["IsSetRep","is_set_rep_def"],([],¨IsSetRep = Ã x:'a ≠ BOOL∑ TÆ));
=DESCRIBE
The representation type of sets, as given by
$€IsSetRep›$ is just any function from
the type of objects of the set to ¨:BOOLÆ.
Its definition is saved under the key ``€IsSetRep›''.
=ENDDOC
=THDOC
req_type("SET",1);
req_defn(["SET","set_def"],([],¨∂ f:'a SET ≠ 'a ≠ BOOL∑ TypeDefn IsSetRep fÆ));
=DESCRIBE
The type of sets, $€SET›$ is given by the representation
function $IsSetRep$.
=ENDDOC
=THDOC
req_const("SetComp",¨:('a ≠ BOOL) ≠ 'a SETÆ);
req_binder "SetComp";
req_const("ç",¨:'a ≠ 'a SET ≠ BOOLÆ);
req_infix(230,"ç");
req_defn(["SetComp","ç","set_comp_def"],
	([],¨µ (x : 'a) (p:'a ≠ BOOL) (S1: 'a SET) (S2 : 'a SET)∑
	(x ç {v | p v} § p x) ±
	((S1 = S2) § (µ x:'a∑ x ç S1 § x ç S2))
	Æ));
=DESCRIBE
The HOL constant $€SetComp›$ is a binder for forming set comprehensions.
The HOL constant $€ç›$ is set membership.
=ENDDOC
=THDOC
req_const("Empty",¨:'a SETÆ);
req_const("Universe",¨:'a SETÆ);
req_const("Insert",¨:'a ≠ 'a SET ≠ 'a SETÆ);
req_defn(["Empty","Universe","Insert","insert_def"],
	([],¨µ (x : 'a) (y : 'a) (S: 'a SET) ∑
		≥(x ç {})
	±	(x ç Universe)
	±	(x ç Insert y S § (x = y ≤ x ç S))Æ));
=DESCRIBE
The HOL constant $€Empty›$ is the empty set.
The HOL constant $€Universe›$ is the set of all values of a type.
The HOL constant $€Insert›$ inserts an object into a set.
=ENDDOC
=THDOC
req_thm("set_clauses",([], ¨
	µ (x : 'a) (y : 'a) (p:'a ≠ BOOL) (q : BOOL) (S1: 'a SET) (S2 : 'a SET)∑
		(x ç {} § F)
	±	(x ç Universe § T)
	±	((x ç {v | q}) § q)
	±	(x ç {v | p v} § p x)
	±	(x ç {v | v = y} § (x = y))
	±	(x ç {y} § (x = y))Æ));
=DESCRIBE
``$€set\_clauses›$'' is a miscellaneous collection of theorems about sets, all appropriate for rewriting, and some drawn from the definitions.
Note that we do not need a direct rule for $¨\{v | y = v\}Æ$,
as other clauses will give it indirectly:
we provide the clause in the first place as a way of rewriting one form of expressing a singleton set.
The definition of $Insert$ is excluded as there will sometimes
be good reasons why its form of rewriting won't be desired.
=ENDDOC
=THDOC
req_const("€~›",¨:'a SET ≠ 'a SETÆ);
req_defn(["~","complement_def"],
	([],¨µ (x : 'a) (S: 'a SET) ∑
	(x ç ~ S § ≥ x ç S)Æ));
=DESCRIBE
The HOL constant $\verb+~+$ forms the complement of a set.
=ENDDOC
=THDOC
req_thm("complement_clauses",([], ¨
	(µ (x : 'a) (S: 'a SET) ∑(x ç ~ S § ≥ x ç S)) ±
		(~ Universe = {})
	±	(~ {} = Universe)Æ));
=DESCRIBE
``$€complement\_clauses›$'' provides simplifying clauses arising the fact that the ``$Empty$'' set and the ``$Universe$'' set are complementary.
=ENDDOC
=THDOC
req_const("¿",¨:'a SET ≠ 'a SET ≠ 'a SETÆ);
req_infix(260, "¿");
req_defn(["¿","¿_def"],([],¨µ (x:'a) (S1 : 'a SET) (S2 : 'a SET) ∑ 
	(x ç S1 ¿ S2) § (x ç S1 ≤ x ç S2)Æ));
=DESCRIBE
The HOL constant $€¿›$ represents set union.
=ENDDOC
=THDOC
req_thm("¿_clauses",([], ¨
	µ (S1: 'a SET)∑
		(S1 ¿ {} = S1)
	±	({} ¿ S1 = S1)
	±	(S1 ¿ Universe = Universe)
	±	(Universe ¿ S1 = Universe)
	±	(S1 ¿ S1 = S1)Æ));
=DESCRIBE
``$€¿\_clauses›$'' provides simplifying clauses associated with ``$\$¿$''.
=ENDDOC
=THDOC
req_const("°",¨:'a SET ≠ 'a SET ≠ 'a SETÆ);
req_infix(270, "°");
req_defn(["°","°_def"],([],¨µ (x:'a) (S1 : 'a SET) (S2 : 'a SET) ∑ 
	(x ç S1 ° S2) § (x ç S1 ± x ç S2)Æ));
=DESCRIBE
The HOL constant $€°›$ represents set union.
=ENDDOC
=THDOC
req_thm("°_clauses",([], ¨
	µ (S1: 'a SET)∑
		(S1 ° {} = {})
	±	({} ° S1 = {})
	±	(S1 ° Universe = S1)
	±	(Universe ° S1 = S1)
	±	(S1 ° S1 = S1)Æ));
=DESCRIBE
``$€°\_clauses›$'' provides simplifying clauses associated with ``$\$°$''.
=ENDDOC
=THDOC
req_const("\\",¨:'a SET ≠ 'a SET ≠ 'a SETÆ);
req_infix(250, "\\");
req_defn(["\\","set_sub_def"],([],¨µ (x:'a) (S1 : 'a SET) (S2 : 'a SET) ∑ 
	(x ç S1 \ S2) § (x ç S1 ± ≥ (x ç S2))Æ));
=DESCRIBE
The HOL constant €Backslash› represents set difference.
=ENDDOC
=THDOC
req_thm("set_sub_clauses",([], ¨
	µ (S: 'a SET)∑
		(S \ {} = S)
	±	({} \ S = {})
	±	(S \ Universe = {})
	±	(Universe \ S = ~ S)
	±	(S1 \ S = {})Æ));
=DESCRIBE
``$€set\_sub\_clauses›$'' provides simplifying clauses associated with ``$\$\verb+\+$''.
=ENDDOC
=THDOC
req_const("Ä",¨:'a SET ≠ 'a SET ≠ BOOLÆ);
req_const("†",¨:'a SET ≠ 'a SET ≠ BOOLÆ);
req_infix(230, "Ä");
req_infix(230, "†");
req_defn(["Ä","Ä_def"],([],¨µ S1 S2 : 'a SET ∑ 
	(S1 Ä S2) § µ x ∑ x ç S1 ¥ x ç S2Æ));
req_defn(["†","†_def"],([],¨µ S1 S2 : 'a SET ∑ 
	(S1 † S2) § ((S1 Ä S2) ± (∂ x ∑ ≥(x ç S1) ± (x ç S2)))Æ));
=DESCRIBE
The HOL constant $€Ä›$ represents set inclusion.
The HOL constant $€†›$ represents proper set inclusion.
=ENDDOC
=THDOC
req_thm("Ä_clauses",([], ¨
	µ (S1: 'a SET)∑
		(S1 Ä S1)
	±	({} Ä S1)
	±	(S1 Ä Universe)Æ));
=DESCRIBE
``$€Ä\_clauses›$'' provides simplifying clauses associated with ``$\$Ä$''.
=ENDDOC
=THDOC
req_const("ﬁ",¨:('a SET) SET ≠ 'a SETÆ);
req_const("•",¨:('a SET) SET ≠ 'a SETÆ);
req_defn(["ﬁ","ﬁ_def"],([],¨µ (x: 'a) (S: ('a SET) SET) ∑ 
	(x ç ﬁ S) § ∂ s ∑ x ç s ± s ç SÆ));
req_defn(["•","•_def"],([],¨µ (x: 'a) (S: ('a SET) SET) ∑ 
	(x ç • S) § µ s ∑ s ç S ¥ x ç sÆ));
=DESCRIBE
The HOL constant $€ﬁ›$ represents generalised union.
The HOL constant $€•›$ represents generalised intersection.
=ENDDOC
=THDOC
req_thm("ﬁ_clauses",([], ¨
		(ﬁ {} = {})
	±	(ﬁ Universe = Universe)Æ));
=DESCRIBE
``$€ﬁ\_clauses›$'' provides simplifying clauses associated with ``$\$ﬁ$''.
=ENDDOC
=THDOC
req_thm("•_clauses",([], ¨
		(• {} = Universe)
	±	(• Universe = {})Æ));
=DESCRIBE
``$€•\_clauses›$'' provides simplifying clauses associated with ``$\$•$''.
=ENDDOC
=THDOC
req_const("",¨:'a SET ≠ ('a SET) SETÆ);
req_defn(["","_def"],([],¨µ (x : 'a SET) (S: 'a SET) ∑ 
	(x ç  S) § x Ä SÆ));
=DESCRIBE
The HOL constant $€›$ represents the power set constructor.
=ENDDOC
=THDOC
req_thm("_clauses",([], ¨
	µ (S:'a SET)∑
		( {} = {{}})
	±	( Universe = Universe)
	±	S ç  S
	±	{} ç  SÆ));
=DESCRIBE
``$€\_clauses›$'' provides simplifying clauses associated with ``$\$$''.
=ENDDOC
=THDOC
req_thm("ö_clauses",([], ¨µ (x : 'a) (S:'a SET) ∑
	{x | F} = {} ±
	≥ x ç {} ±
	{} ¿ S = S ±
	S ¿ {} = S ±
	{} ° S = {} ±
	S ° {} = {} ±
	S \ {} = S ±
	{} \ S = {} ±
	{} Ä S ±
	(S Ä {} § S = {}) ±
	({} † S § ≥ S = {}) ±
	≥ S † {} ±
	≥ x ç ﬁ {} ±
	x ç • {} ±
	{} ç  S ±
	( {} = {{}})Æ));
=DESCRIBE
The theorem ``$€ö\_clauses›$'' gives all the interactions of the empty set with the operators given in the theory ``sets''.
This will probably be dropped because the results are mostly in the other `clauses'.
=ENDDOC
=THDOC
req_thm("ç_in_clauses",([], ¨
	(µ (x : 'a) (y : 'a) (S: 'a SET) ∑
		(x ç {} § F)
	±	(x ç Insert y S § (x = y ≤ x ç S)))
±	(µ (x:'a) (S1 : 'a SET) (S2 : 'a SET) ∑
		(x ç S1 ¿ S2 § x ç S1 ≤ x ç S2)
	±	(x ç S1 ° S2 § x ç S1 ± x ç S2)
	±	(x ç S1 \ S2 § x ç S1 ± ≥ x ç S2))
±	(µ (x:'a) (S : 'a SET SET) ∑
		(x ç ﬁ S § ∂ s ∑ x ç s ± s ç S)
	±	((x ç • S) § µ s ∑ s ç S ¥ x ç s)
±	(µ (x : 'a SET) (S1 : 'a SET) ∑(x ç  S1 § x Ä S1)))Æ));
=DESCRIBE
The theorem ``$€ç\_in\_clauses›$'' gives theorems which ``push in'' membership assertions.
=ENDDOC
=THDOC
req_thm("set_ext_clauses",([], ¨µ(S1 : 'a SET) (S2 : 'a SET) ∑
	((S1 † S2) § ((µ x ∑ x ç S1 ¥ x ç S2) ± (∂ x ∑ ≥(x ç S1) ± (x ç S2))))
±	((S1 Ä S2) § µ x ∑ x ç S1 ¥ x ç S2)
±	((S1 = S2) § (µ x:'a∑ x ç S1 § x ç S2))Æ));
=DESCRIBE
The theorem ``$€set\_ext\_clauses›$'' gives theorems which express extensionality of sets and closely related results.
They are for use when set theoretic results are to be obtained by reasoning about membership rather than by more algebraic means.
=ENDDOC
\subsection{Signature of the theory ``sets''}
=DOC
signature €SetsTheory› = sig
	val €set_clauses› : THM;
	val €ö_clauses› : THM;
	val €ç_in_clauses› : THM;
	val €set_ext_clauses› : THM;
	val €complement_clauses› : THM;
	val €¿_clauses› : THM;
	val €°_clauses› : THM;
	val €set_sub_clauses› : THM;
	val €Ä_clauses› : THM;
	val €†_clauses› : THM;
	val €ﬁ_clauses› : THM;
	val €•_clauses› : THM;
	val €_clauses› : THM;
	val €is_set_rep_def› : THM;
	val €set_comp_def› : THM;
	val €insert_def› : THM;
	val €complement_def› : THM;
	val €¿_def› : THM;
	val €°_def› : THM;
	val €set_sub_def› : THM;
	val €Ä_def› : THM;
	val €†_def› : THM;
	val €ﬁ_def› : THM;
	val €•_def› : THM;
	val €_def› : THM;
=DESCRIBE
This is the signature in which we declare theory ``sets''.
$set\_clauses$ is bound the the theorem saved with the same name as
key,
$insert\_def$ is bound to the definition of $Insert$, saved with key $Insert$, and the other $\_def$ follow the same pattern.
=ENDDOC
=DOC
val €simple_ç_comp_conv› : CONV;
=DESCRIBE
A conversion for set membership.
It cannot handle variable structures bound by the set comprehension.
=FRULE 1 Conversion
simple_ç_comp_conv
¨x ç {v | p[v]}Æ
˜
˜
Ù x ç {v | p[v]} § p[x]
=TEX
=SEEALSO
$ç\_conv$
=FAILURE
44001	?0 is not of the form:¨x ç {v | p[v]}Æ
=ENDDOC
=DOC
val €ç_comp_conv› : CONV;
=DESCRIBE
A conversion for set membership.
It can handle variable structures bound by the set comprehension.
=FRULE 1 Conversion
ç_conv
¨t ç {v[x,y,...] | p[x,y,...]}Æ
˜
˜
Ù t ç {vs[x,y,...] | p[x,y,...]} 
§ p[x1,y1,...]
=TEX
where $x1$, $y1$, etc, are the appropriate components of
$t$, extracted via $Fst$ and $Snd$.
=SEEALSO
$simple\_ç\_comp\_conv$
=FAILURE
27002	?0 is not of form:¨x ç {v | p[v]}Æ
=ENDDOC
=DOC
val €ç_enum_rule› : TERM -> TERM list -> THM;
=DESCRIBE
Give that something within an enumerated set is a member of that set.
=FRULE 1 Rule
ç_enum_rule
¨tiÆ
[¨t1Æ,...¨tnÆ]
˜
˜
Ù ti ç {t1,...,tn}
=TEX
where $ti$ is $\alpha$-convertible to one of $t1,\ldots,tn$.
=FAILURE
3012	?0 and ?1 do not have the same types
27001	?0 not a member of list of terms
=FAILUREC
Message 3012 occurs when the term list cannot be made into
an enumerated set because of differing types.
=ENDDOC
=DOC
val €ç_enum_conv› : CONV;
=DESCRIBE
Give that something within an enumerated set is a member of that set.
=FRULE 1 Conversion
ç_enum_conv
¨ti ç {t1,...,tn}Æ
˜
˜
Ù ti ç {t1,...,tn} § T
=TEX
where $ti$ is $\alpha$-convertible to one of $t1,\ldots,tn$.
=FAILURE
27005	?0 not a member of the enumerated set ?1
27006	?0 is not of the form: ¨x ç {t1, ..., tn}Æ
=FAILUREC
Message 3012 occurs when the term list cannot be made into
an enumerated set because of differing types.
=ENDDOC
\section{PROOF CONTEXTS}
=DOC
val €sets_ext_pc› : PROOF_CONTEXT;
val €sets_ext_epc› : EPROOF_CONTEXT;
=DESCRIBE
$sets\_ext\_pc$ extends $pair\_pc$ by:
\begin{description}
\item [Name]\ 

Becomes ``sets$\_$ext$\_$pc''.
\item [Stripping Goals and Theorems]\ 

Adding in $ç\_comp\_conv$, $ç\_enum\_conv$, $ç\_in\_clauses$ and $sets\_ext\_clauses$ applied at the top level or under a single negation.
\item [Rewriting Context]\ 

Adding in $ç\_comp\_conv$, $ç\_enum\_conv$, $ç\_in\_clauses$ and $sets\_ext\_clauses$.
\end{description}
$sets\_ext\_epc$ is the evaluated form of $sets\_ext\_pc$, with name
``sets$\_ext\_$pc''.
=ENDDOC
=DOC
val €sets_alg_pc› : PROOF_CONTEXT;
val €sets_alg_epc› : EPROOF_CONTEXT;
=DESCRIBE
$sets\_alg\_pc$ extends $pair\_pc$ by:
\begin{description}
\item [Name]\ 

Becomes ``sets$\_$alg$\_$pc''.
\item [Stripping Goals and Theorems]\ 

Adding in $ç\_comp\_conv$, $ç\_enum\_conv$, and $ç\_in\_clauses$ applied at the top level or under a single negation.
\item [Rewriting Context]\ 

Adding in $ç\_comp\_conv$, $ç\_enum\_conv$, $complement\_clauses$, $¿\_clauses$, $°\_clauses$, $set\_sub\_clauses$, $Ä\_clauses$, $†\_clauses$, $ﬁ\_clauses$, $•\_clauses$ and $\_clauses$.
\end{description}
$sets\_alg\_epc$ is the evaluated form of $sets\_ext\_pc$, with name
``sets$\_alg\_$pc''.
=ENDDOC
=SML
end;(* of signature SetsTheory *)
=TEX
\section{TEST POLICY}
Any functions given in this document should be tested according to the
general criteria set out in \cite{DS/FMU/IED/PLN008}, using the
tests in \cite{DS/FMU/IED/MDT044}.
In \cite{DS/FMU/IED/MDT044} the theory produced is checked by the theory design tools
of \cite{DS/FMU/IED/DTD035}, against the theory design provided.

The module tests should include automatic proof of all the ``rules'' in \cite{Spivey89} expressible in this part of set theory, but this can't be done until resolution facilities are available.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


