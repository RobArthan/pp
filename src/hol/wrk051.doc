% wrk051.doc  %Z% $Date$ $Revision$ $RCSfile$

=IGNORE
To use this makefile starting from scratch:

Work in a directory with:

(1)	usr004.doc usr022_slides.doc usr023_slides.doc
	usr011S.doc usr011X.doc
(2)	usr011A.sml usr011B.sml usr011C.sml usr011D.sml usr011E.sml 
	usr011T.sml
(3)	wrk051.doc (this file)

Use the following line to otain the makefile:

sieve sml < wrk051.doc

then make the required .dvi files.

U s e f u l  C o m m a n d s
doctex wrk051
texdvi wrk051
bibtex  wrk051
texdvi wrk051
dvipage wrk051
pstex   wrk051

Print This Document:
	make -f wrk051.mkf wrk051.prt

Make all example databases:
	make -f wrk051.mkf all
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\TPPtitle{Creating Example ProofPower Databases}
\TPPref{DS/FMU/IED/WRK051}
\def\SCCSissue{$Revision$%
}
\TPPissue{\SCCSissue}
\TPPdate{\FormatDate{$Date$
}}
\TPPproject{FST PROJECT}
\TPPstatus{Draft}
\TPPtype{Literate Script}
\TPPkeywords{HOL}
\TPPauthors{K.~Blackburn &WIN01}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the makefile, plus its associated files,
	that produces example databases for \Product.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

%\ftlinepenalty=9999
\makeindex
% \underscoreoff
\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

\subsection{Contents List}
\tableofcontents
% \listoftables

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}

\begin{description}
\item[Issues 1.1 (3rd March 1993)]
Initial version.
\end{description}

\subsection{Changes Forecast} \label{ChangesForecast}
None.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{GENERAL}
\subsection{Scope}

This document provides documentation, a makefile and auxiliary scripts
for the process of producing certain example databases.
It is based on \cite{DS/FMU/IED/WRK027}.

\subsection{Introduction}

This document contains the literate script of a makefile ($wrk051.mkf$) and a number
of auxiliary files which are scripts for other programs.  To produce
the makefile the program {\tt sieve} is run against this document,
with the {\tt sml} view, as shown below.  The  output is the makefile,
together with a number of small utility-files: mostly scripts for {\tt
sed} and {\tt awk}.

The commentary upon the makefile assumes some knowledge of
the UNIX {\tt make} command.
The key item of knowledge is the form and meaning of a standard
makefile entry.
=GFT Example makefile entry
target1 target2 : dependency1 dependency2 dependency3
	command1
	command2
	command3
	command4
=TEX
To use such an entry in a makefile the user might type:
=GFT csh 
make -f makefile target1
=TEX
If so, {\tt make} will first recursively use the rest of the makefile to
do what processing is necessary for each of the $dependency_i$
(this may be nothing).
It will then determine whether $target1$ exists and has a ``time of last change''
after the ``time of last change'' of each
$dependency_i$.
If so {\tt make} will halt.
If not, then it will execute each of the $command_i$ in sequence,
in different shells, and then halt.

See UNIX documentation for further details, such as a description of macros and pattern matching rules.

It is this {\tt make} algorithm, in combination with a single file (a database) containing all the effect of cumulative loads
in \Product{}, that leads to the system of ``flags'' in the entries below.
\subsection{Interface}
To produce the example databases, start in a directory with
the necessary files of:
=GFT
(1)	usr004.doc usr022_slides.doc usr023_slides.doc usr011S.doc usr011X.doc
(2)	usr011A.sml usr011B.sml usr011C.sml usr011D.sml usr011E.sml usr011T.sml
(3)	wrk051.doc (this file)
=TEX
These should all be present in the subdirectory $docs$ of
the \Product{} installation directory.
Then create the makefile {\tt wrk051.mkf} by:
=GFT csh
sieve sml < wrk051.doc
=TEX

The makefile is saved as file {\tt wrk051.mkf}.
Having produced the makefile ( {\tt wrk051.mkf}) and utilities,
as above, there are then several options for further commands.

To print this document:
=GFT csh
make -f wrk051.mkf wrk051.prt
=TEX

To run tutorial scripts for usr004:
=GFT csh
make -f wrk051.mkf usr004.tutorial
=TEX
Similarly for $usr011$, $usr022$ and $usr023$, rather than $usr004$.

To run exercise scripts for usr011 (which will also run the tutorial scripts for $usr011$, if not already done):
=GFT csh
make -f wrk051.mkf usr011.zexercises
=TEX

To run solutions scripts for usr011 (which will also run the exercises, if not already done):
=GFT csh
make -f wrk051.mkf usr011.solutions
=TEX

To tidy up afterwards, execute:

=GFT csh
make -f wrk051.mkf texclean clean_examples
=TEX

To remove all auxiliary files created by ``sieving'' this one:
=GFT csh
rm -f wrk051.mkf wrk051_*.*
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{START OF MAKEFILE}

=DUMP wrk051.mkf
# wrk051.mkf
#	A makefile that produces example databases.
#	Created from:  wrk051.doc %Z% $Revision$ $RCSfile$ $Date$

=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{PRELIMINARIES}

\subsection{Macros}
The following should be left unchanged (it is the current
machine architecture):
=DUMPMORE wrk051.mkf
ARCH:sh = arch
=TEX

The following may be altered on the command line that invokes {\tt make}.
The first two define the location of the appropriate parent databases.
They assume that $INSTALLDIR$ is set in the shell environment.
The next two define the ``root'' names of the example databases.
=DUMPMORE wrk051.mkf
PP_HOLDB = $(INSTALLDIR)/$(ARCH)pp_hol.db
PP_ZEDDB = $(INSTALLDIR)/$(ARCH)pp_zed.db

EHOLROOT = example_hol
EZEDROOT = example_zed
=TEX

The following should be left unchanged - they define the actual
file names of the example databases, and these must 
be precisely as given.
=DUMPMORE wrk051.mkf
EHOLDB = $(ARCH)$(EHOLROOT).db
EZEDDB = $(ARCH)$(EZEDROOT).db
=TEX
The following are the comments returned at the end of a successful or failed  make:
=DUMPMORE wrk051.mkf
SUCCESS_MESSAGE = "make command succeeded"
FAILURE_MESSAGE = "make command failed"
=TEX
\subsection{Default}
The default action of the makefile is to print a message.
The default is indicated by it being the first target in the
makefile.
=DUMPMORE wrk051.mkf
default :
	@echo Use:
	@echo "         make -f wrk051.mkf all"
	@echo to create example ProofPower databases for HOL and Z. 
	@echo See document DS/FMU/IED/WRK051 for further details.
=TEX
\subsection{Pattern Matching Rules} \label{PatternMatchingRules}
See {\tt make} documentation for how the following work.
They provide the ``standard'' processing rules for:
\begin{description}
\item[.doc]
Documents,
\item[.sml]
Standard ML files, usually derived from documents,
\item[.tex]
\LaTeX{} files derived from documents,
\item[.dvi]
files displayable by {\tt dvipage} or printable by {\tt pstex},
\item[.prt]
dummy files, used to provoke printing.
\end{description}
=DUMPMORE wrk051.mkf

.SUFFIXES: .doc .sml .tex .dvi .prt
%.tex: %.doc
	doctex $*

%.dvi: %.tex
	texdvi $*
	- bibtex $*
	texdvi $*
	texdvi $*

%.sml: %.doc
	docsml $*

%.prt: %.dvi
	pstex $*
=TEX
The following .sml files are supplied directly in a release of \Product, rather than their
source documents being given.
=DUMPMORE wrk051.mkf
Ûusr011A.smlÝ \
Ûusr011B.smlÝ \
Ûusr011C.smlÝ \
Ûusr011D.smlÝ \
Ûusr011E.smlÝ \
Ûusr011T.smlÝ:
	@echo Missing $@, which should have been present in release
	exit 1
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{PREPARING CLEAN DATABASES}
Unless the macro definitions previously given in this document have been altered, the following assumes that suitable parent databases can be
found in the directory pointed to by shell variable
$INSTALLDIR$.
The example databases are files whose names are held in
the macros
=INLINEFT
$(EHOLDB)
=TEX
{} and {}
=INLINEFT
$(EZEDDB)
=TEX
{}.
The two flags, $wrk051\_hol.flag$ and $wrk051\_zed.flag$
are two empty files, whose ``time of last change'' is the
time of creation of the example databases.
Various items later in this makefile have these flags
amongst their dependencies.
This means that, amongst other reasons for reloading,
such items are reloaded if their previous load
was made prior to the creation of the appropriate
example database.
If the dependencies of these items were the database
filenames themselves, then a reload would be needed
on any change to the databases, such as another, orthogonal, load.
However, the databases themselves will still be recreated
if the flags are used as dependencies when they are out of
step with their parents (or are not there at all!).
=DUMPMORE wrk051.mkf
Ûwrk051_hol.flagÝ \
$(EHOLDB) : $(PP_HOLDB)
	pp_make_database -p $(PP_HOLDB) $(EHOLROOT)
	touch wrk051_hol.flag

Ûwrk051_zed.flagÝ \
$(EZEDDB) : $(PP_ZEDDB)
	pp_make_database -p $(PP_ZEDDB) $(EZEDROOT)
	touch wrk051_zed.flag
=TEX

The following can be ``piped'' into a \Product{} session after all desired
``-i'' files have been entered - it will cause the effects of the previous
loads to be saved within the database.
=VDUMP wrk051_save_and_quit.sml
(* created from wrk051.doc %Z% $Revision$ $RCSfile$ $Date$ *)
save_and_quit();
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MAKING THE TUTORIAL MANUAL (usr004)}
The following pattern of file creation and makefile entry
is used in most of the following sections, though we only comment
upon it in this one.

The following command creates a file:
=INLINEFT
wrk051_delete_theories_usr004.sml
=TEX
{} that is used to delete, if present, the theories that would be created by loading $usr004.sml$.
If the theories were present the load of $usr004.sml$ would fail.
A similar file is created for each of the items that may be added
into the example databases.
=VDUMP wrk051_delete_theories_usr004.sml
(* created from wrk051.doc %Z% $Revision$ $RCSfile$ $Date$ *)
(force_delete_theory "Peanissimo" handle Fail _ => ());
(force_delete_theory "ordinals" handle Fail _ => ());
=TEX

The following creates, if necessary, an example HOL database (via
=INLINEFT
wrk051_hol.flag
=TEX
{}).
It then creates an $.sml$ file from $usr004.doc$,
loads the above theory-deleting file into the example database, and then loads this formal text of $usr004.doc$.
It then saves the database with the results of the above loads.
Finally, it touches a flag, $usr004.tutorial$, so that
the ``time of last change'' for the flag is the time
of last loading $usr004.sml$.
=DUMPMORE wrk051.mkf
Ûusr004.tutorialÝ: wrk051_hol.flag usr004.doc usr004.sml
	hol -d $(EHOLDB) -i wrk051_delete_theories_usr004 \
		-i usr004 < wrk051_save_and_quit.sml
	touch usr004.tutorial
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MAKING THE Z TUTORIAL MANUAL (usr011)}

\subsection{Z Tutorial Source Files}

\begin{center}
\begin{tabular}{|l|l|} \hline
usr011.* & top level document \\\hline
usr011A.* &  Ch. 2 - Z Language\\\hline
usr011B.* &  Ch. 3 - Z Predicate Calculus\\\hline
usr011C.* &  Ch. 4 - Z Expressions\\\hline
usr011D.* &  Ch. 5 - Z Paragraphs\\\hline
usr011E.* &  Ch. 6 - An Example Specification and Proof\\\hline
usr011T.* &  Ch. 7 - The Z ToolKit\\\hline
usr011X.* &  Exercises\\\hline
usr011S.* &  Solutions\\\hline
\end{tabular}
\end{center}

\subsection{Z Tutorial Make Entries}

=VDUMP wrk051_delete_theories_usr011.sml
(* created from wrk051.doc %Z% $Revision$ $RCSfile$ $Date$ *)
(force_delete_theory "usr011" handle Fail _ => ());
=TEX

=VDUMP wrk051_delete_theories_zexercises.sml
(* created from wrk051.doc %Z% $Revision$ $RCSfile$ $Date$ *)
(force_delete_theory "z_exercises_1" handle Fail _ => ());
(force_delete_theory "z_exercises_2" handle Fail _ => ());
(force_delete_theory "z_exercises_3" handle Fail _ => ());
(force_delete_theory "z_exercises_4" handle Fail _ => ());
=TEX

=DUMPMORE wrk051.mkf
Ûusr011.tutorialÝ: wrk051_zed.flag usr011A.sml usr011B.sml \
		usr011C.sml usr011D.sml usr011E.sml usr011T.sml
	zed -d $(EZEDDB) -i wrk051_delete_theories_usr011.sml -i usr011A.sml \
		-i usr011B.sml -i usr011C.sml -i usr011D.sml \
		-i usr011T.sml -i usr011E.sml \
		< wrk051_save_and_quit.sml
	discgarb $(EZEDDB)
	touch usr011.tutorial
	
Ûusr011.zexercisesÝ: usr011.tutorial usr011X.doc usr011S.doc \
		usr011X.sml usr011S.sml
	zed -d $(EZEDDB) -i wrk051_delete_theories_zexercises.sml \
		-i usr011X.sml < wrk051_save_and_quit.sml
	discgarb $(EZEDDB)
	touch usr011.zexercises
	
Ûusr011.solutionsÝ: usr011.zexercises usr011S.doc \
		 usr011X.sml usr011S.sml
	zed -d $(EZEDDB) -i usr011S.sml < wrk051_save_and_quit.sml
	discgarb $(EZEDDB)
	touch usr011.solutions
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MAKING TUTORIAL OVERHEADS (usr022)}

=VDUMP wrk051_delete_theories_usr022.sml
(* created from wrk051.doc %Z% $Revision$ $RCSfile$ $Date$ *)
(force_delete_theory "tutorial" handle Fail _ => ());
=TEX

=DUMPMORE wrk051.mkf
Ûusr022.tutorialÝ: wrk051_hol.flag usr022_slides.doc usr022_slides.sml
	hol -d $(EHOLDB)  -i wrk051_delete_theories_usr022.sml \
	        -i usr022_slides < wrk051_save_and_quit.sml
	discgarb $(EHOLDB)
	touch usr022.tutorial
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MAKING Z TUTORIAL OVERHEADS (usr023) AND CASE STUDY (wrk050)}

=VDUMP wrk051_delete_theories_usr023.sml
(* created from wrk051.doc %Z% $Revision$ $RCSfile$ $Date$ *)
(force_delete_theory "usr023" handle Fail _ => ());
=TEX

=DUMPMORE wrk051.mkf
Ûusr023.tutorialÝ: wrk051_zed.flag usr023_slides.doc usr023_slides.sml
	zed -d $(EZEDDB) -i wrk051_delete_theories_usr023.sml \
	        -i usr023_slides < wrk051_save_and_quit.sml
	discgarb $(EZEDDB)
	touch usr023.tutorial
=TEX

=VDUMP wrk051_delete_theories_wrk050.sml
(* created from wrk051.doc %Z% $Revision$ $RCSfile$ $Date$ *)
(force_delete_theory "wrk050" handle Fail _ => ());
=TEX

=DUMPMORE wrk051.mkf
Ûwrk050.thÝ: wrk051_zed.flag wrk050.doc wrk050.sml
	zed -d $(EZEDDB) -i wrk051_delete_theories_wrk050.sml \
	        -i wrk050.sml < wrk051_save_and_quit.sml
	discgarb $(EZEDDB)
	touch wrk050.th
=TEX
$wrk050.dvi$ is created by the standard rule for $.dvi$ files.
		
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{CREATE ALL DATABASES}
The following create and populates the example HOL and Z databases.
=DUMPMORE wrk051.mkf
Ûall_holÝ: usr004.tutorial usr022.tutorial 

Ûall_zedÝ: usr011.solutions usr022.tutorial usr023.tutorial wrk050.th

ÛallÝ : all_hol all_zed
=TEX
$all$ can be ``undone'' by $clean\_examples$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{TIDYING UP THE FILE STORE}
Clean out all example database material that might be created during an execution of this makefile:
=DUMPMORE wrk051.mkf
Ûclean_examplesÝ :
	rm -f $(EHOLDB) $(EZEDDB) 
	rm -f wrk051_hol.flag wrk051_zed.flag 
	rm -f usr004.tutorial usr022.tutorial usr023.tutorial
	rm -f usr011.tutorial usr011.zexercises usr011.solutions 
	rm -f wrk050.th
	rm -f usr022_slides.sml usr023_slides.sml usr004.sml 
	rm -f usr011X.sml usr011S.sml wrk050.sml
=TEX
To remove all auxiliary files created by ``sieving'' {\tt wrk051.doc} (we refrain from having a makefile entry delete its own makefile!):
=GFT csh
rm -f wrk051.mkf wrk051_*.*
=TEX
\section{make ENDINGS}
=DUMPMORE wrk051.mkf
Û.FAILEDÝ :
	@ echo "*** $(FAILURE_MESSAGE) ***" 1>&2
	exit 1

Û.DONEÝ :
	@ echo "*** $(SUCCESS_MESSAGE) ***" 1>&2
=TEX

\newpage

\twocolumn[\section{INDEX}] \label{Index}

\footnotesize
\printindex

\onecolumn

\end{document}
