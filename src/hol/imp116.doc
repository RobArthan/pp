=TEX
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex

\def\Title{ Implementation: Theory of Reals }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document gives the implementation of the theory of real numbers in \ProductHOL.}
\end{center}}

\def\Reference{LEMMA1/HOL/IMP116}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.8 $%
}
\def\Date{\FormatDate{$Date: 2001/07/02 13:51:19 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\newpage
\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1-1.5] First development drafts.
\item[Issues 1.6-1.8] Improvements to the computational and normalisation conversions.
\item[Issues 1.9] Fixed bug in {\it add\_simp\_conv}.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

Some of the material in this document might more usefully be shipped into a separate
document extending the facilities for natural numbers.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}

Lemma 1 build system.

\newpage

\section{Introduction}
\subsection{Scope}
The real numbers are constructed in HOL using the positive dyadic rational numbers
under multiplication to provide an ordered algebraic system whose completion
provides the reals.
This construction is carried out in \cite{LEMMA1/HOL/DTD116}.
This module provides the necessary algebraic and order-theoretic facts about
this system of numbers.


\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD011}.


\section{PROLOGUE}\label{PROLOGUE}
=TEX
The structure takes rather a long time to compile if done in one piece.
We break it up into smaller structures each one of which includes the previous one.
The signature constraint is applied to the final structure.
=SML
structure €Ø› (* : Ø *) = struct
val _ = open_theory"Ø";
val _ = push_merge_pcs["basic_hol", "'˙", "'sets_alg"];
open Dyadic;
=TEX
\section{CONSISTENCY OF THE ORDERING RELATION}
In this section we prove that the definition of
=INLINEFT
$<âR
=TEX
\ is consistent.
This is essentially just a straightforward transfer of facts about the representation
type for the reals (as the completion of the ordered set of positive dyadic
rational) up to the abstract type of reals.
=SML
val _ = declare_infix(210, "lt");
=TEX
=SML
val €left_inv_one_one_thm› = (
set_goal([], ¨µf g∑(µx∑g(f x) = x) ¥ OneOne fÆ);
a(rewrite_tac[one_one_def] THEN REPEAT strip_tac);
a(LEMMA_T ¨g(f x1) = g(f x2)Æ ante_tac THEN1 POP_ASM_T rewrite_thm_tac);
a(POP_ASM_T discard_tac THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val €Ø_order_exists_thm› = (
set_goal([], ¨∂$lt:Ø ≠ Ø ≠ BOOL; iota : DYADIC ≠ Ø∑
		LinearOrder(Universe, $lt)
	±	Complete(Universe, $lt)
	±	UnboundedAbove(Universe, $lt)
	±	UnboundedBelow(Universe, $lt)
	±	(µa b∑ iota a lt iota b § a dy_less b)
	±	{x | ∂a∑iota a = x} DenseIn (Universe, $lt)
Æ);
a (strip_asm_tac (rewrite_rule[get_spec¨Is_Ø_RepÆ]
	(simple_¥_match_mp_rule type_lemmas_thm (get_defn"-""Ø"))));
a(lemma_tac¨µx∑rep x ç Cuts (Universe, $dy_less)Æ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[left_inv_one_one_thm]);
a(∂_tac¨Ãx y∑rep x † rep yÆ);
a(∂_tac¨Ãa∑abs (DownSet(Universe, $dy_less, a))Æ);
a(strip_asm_tac(get_thm"-""dy_less_order_lemmas_thm"));
a(lemma_tac¨Trans(Universe, $dy_less)Æ
	THEN1 rewrite_tac[get_spec¨TransÆ, dy_less_trans_thm]);
a(rewrite_tac[] THEN REPEAT ±_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac induced_linear_order_thm);
a(∂_tac¨Cuts (Universe, $dy_less)Æ THEN asm_rewrite_tac[]);
a(all_fc_tac[cuts_linear_order_thm]);
(* *** Goal "2" *** *)
a(bc_thm_tac induced_order_complete_thm);
a(∂_tac¨Cuts (Universe, $dy_less)Æ THEN asm_rewrite_tac[cuts_complete_thm]);
a(REPEAT strip_tac);
a(∂_tac¨abs xÆ THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(bc_thm_tac induced_order_unbounded_above_thm);
a(∂_tac¨Cuts (Universe, $dy_less)Æ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(∂_tac¨abs xÆ THEN asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(bc_thm_tac cuts_unbounded_above_thm THEN asm_rewrite_tac[get_spec¨IrreflÆ, dy_less_irrefl_thm]);
(* *** Goal "4" *** *)
a(bc_thm_tac induced_order_unbounded_below_thm);
a(∂_tac¨Cuts (Universe, $dy_less)Æ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(∂_tac¨abs xÆ THEN asm_rewrite_tac[]);
(* *** Goal "4.2" *** *)
a(bc_thm_tac cuts_unbounded_below_thm THEN asm_rewrite_tac[get_spec¨IrreflÆ, dy_less_irrefl_thm]);
(* *** Goal "5" *** *)
a(REPEAT µ_tac);
a(LEMMA_T¨DownSet (Universe, $dy_less, a) ç Cuts (Universe, $dy_less)Æ ante_tac
	THEN1 (bc_thm_tac downset_cut_thm THEN REPEAT strip_tac));
a(LEMMA_T¨DownSet (Universe, $dy_less, b) ç Cuts (Universe, $dy_less)Æ ante_tac
	THEN1 (bc_thm_tac downset_cut_thm THEN REPEAT strip_tac));
a(asm_rewrite_tac[] THEN REPEAT (¥_T rewrite_thm_tac));
a(bc_thm_tac downsets_less_thm);
a(REPEAT strip_tac);
(* *** Goal "6" *** *)
a(bc_thm_tac induced_order_dense_thm);
a(∂_tac¨Cuts (Universe, $dy_less)Æ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN1 (∂_tac¨abs xÆ THEN asm_rewrite_tac[]));
a(LEMMA_T¨{x|∂a∑ (∂ a'∑ abs (DownSet (Universe, $dy_less, a')) = a) ± x = rep a} =
	DownSets (Universe, $dy_less, Universe)Æ rewrite_thm_tac);
(* *** Goal "6.1" *** *)
a(PC_T "sets_ext1" strip_tac);
a(rewrite_tac[get_spec¨DownSetsÆ] THEN REPEAT strip_tac);
(* *** Goal "6.1.1" *** *)
a(LEMMA_T¨DownSet (Universe, $dy_less, a') ç Cuts (Universe, $dy_less)Æ ante_tac
	THEN1 (bc_thm_tac downset_cut_thm THEN REPEAT strip_tac));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "6.1.2" *** *)
a(LEMMA_T¨DownSet (Universe, $dy_less, x') ç Cuts (Universe, $dy_less)Æ ante_tac
	THEN1 (bc_thm_tac downset_cut_thm THEN REPEAT strip_tac));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨abs (DownSet (Universe, $dy_less, x'))Æ THEN asm_rewrite_tac[]);
a(∂_tac¨x'Æ THEN REPEAT strip_tac);
(* *** Goal "6.2" *** *)
a(bc_thm_tac downsets_dense_thm1 THEN REPEAT strip_tac);
pop_thm()
);
=TEX
=SML
val _ = (
push_consistency_goal¨$<âRÆ;
a(strip_asm_tac Ø_order_exists_thm);
a(∂_tac¨$ltÆ THEN REPEAT strip_tac);
a(∂_tac¨$iotaÆ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
save_consistency_thm¨$<âRÆ(pop_thm())
);
=TEX
=SML
val _ = declare_nonfix("lt");
=TEX
\section{THEOREMS ABOUT THE ORDERING}
\ftlinepenalty=9999

In this section we prove basic facts about the less-than relation on the reals.

=SML
end (* of structure Ø part 1 *);
structure €Ø› (* : Ø *) = struct
open Ø;
=SML
val €Ø_unbounded_below_thm› = (
set_goal([], ¨µx: Ø∑ ∂y∑ y < xÆ);
a(LEMMA_T ¨UnboundedBelow(Universe, $<âR)Æ ante_tac THEN1 rewrite_tac[get_spec¨$<âRÆ]);
a(rewrite_tac[get_spec¨UnboundedBelowÆ] THEN REPEAT strip_tac);
save_pop_thm "Ø_unbounded_below_thm"
);
=TEX
=SML
val €Ø_unbounded_above_thm› = (
set_goal([], ¨µx: Ø∑ ∂y∑ x < yÆ);
a(LEMMA_T ¨UnboundedAbove(Universe, $<âR)Æ ante_tac THEN1 rewrite_tac[get_spec¨$<âRÆ]);
a(rewrite_tac[get_spec¨UnboundedAboveÆ] THEN REPEAT strip_tac);
save_pop_thm "Ø_unbounded_above_thm"
);
=TEX
=SML
val €Ø_less_irrefl_thm› = (
set_goal([], ¨µx: Ø∑ ≥x < xÆ);
a(LEMMA_T ¨LinearOrder(Universe, $<âR)Æ ante_tac THEN1 rewrite_tac[get_spec¨$<âRÆ]);
a(rewrite_tac(map get_spec[¨LinearOrderÆ, ¨PartialOrderÆ, ¨IrreflÆ]) THEN REPEAT strip_tac);
save_pop_thm "Ø_less_irrefl_thm"
);
=TEX
=SML
val €Ø_less_antisym_thm› = (
set_goal([], ¨µx y: Ø∑ ≥(x < y ± y < x)Æ);
a(LEMMA_T ¨LinearOrder(Universe, $<âR)Æ ante_tac THEN1 rewrite_tac[get_spec¨$<âRÆ]);
a(rewrite_tac(map get_spec[¨LinearOrderÆ, ¨PartialOrderÆ, ¨AntisymÆ]) THEN REPEAT strip_tac);
save_pop_thm "Ø_less_antisym_thm"
);
=TEX
=SML
val €Ø_less_trans_thm› = (
set_goal([], ¨µx y z: Ø∑ x < y ± y < z ¥ x < zÆ);
a(LEMMA_T ¨LinearOrder(Universe, $<âR)Æ ante_tac THEN1 rewrite_tac[get_spec¨$<âRÆ]);
a(rewrite_tac(map get_spec[¨LinearOrderÆ, ¨PartialOrderÆ, ¨TransÆ]) THEN REPEAT strip_tac);
save_pop_thm "Ø_less_trans_thm"
);
=TEX
=SML
val €Ø_less_cases_thm› = (
set_goal([], ¨µx y: Ø∑ x < y ≤ x = y ≤ y < xÆ);
a(LEMMA_T ¨LinearOrder(Universe, $<âR)Æ ante_tac THEN1 rewrite_tac[get_spec¨$<âRÆ]);
a(rewrite_tac(map get_spec[¨LinearOrderÆ, ¨TrichÆ]) THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
save_pop_thm "Ø_less_cases_thm"
);
=TEX
=SML
val €Ø_º_cases_thm› = (
set_goal([], ¨µx y: Ø∑ x º y ≤ y º xÆ);
a(rewrite_tac[get_spec¨$ºâRÆ]);
a(REPEAT strip_tac THEN all_fc_tac[Ø_less_cases_thm]);
save_pop_thm "Ø_º_cases_thm"
);
=TEX
=SML
val €Ø_º_less_cases_thm› = (
set_goal([], ¨µx y: Ø∑ x º y ≤ y < xÆ);
a(rewrite_tac[get_spec¨$ºâRÆ]);
a(REPEAT strip_tac THEN all_fc_tac[Ø_less_cases_thm]);
save_pop_thm "Ø_º_less_cases_thm"
);
=TEX
=SML
val €Ø_eq_º_thm› = (
set_goal([], ¨µx y: Ø∑ x = y § x º y ± y º xÆ);
a(rewrite_tac[get_spec¨$ºâRÆ] THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(all_fc_tac[Ø_less_antisym_thm]);
save_pop_thm "Ø_eq_º_thm"
);
=TEX
=SML
val €Ø_º_antisym_thm› = (
set_goal([], ¨µx y: Ø∑ x º y ± y º x  ¥ x = yÆ);
a(rewrite_tac[Ø_eq_º_thm]);
save_pop_thm "Ø_º_antisym_thm"
);
=TEX
=SML
val €Ø_less_º_trans_thm› = (
set_goal([], ¨µx y z: Ø∑ x < y ± y º z ¥ x < zÆ);
a(rewrite_tac[get_spec¨$ºâRÆ]);
a(REPEAT strip_tac THEN1 all_fc_tac[Ø_less_trans_thm]);
a(all_var_elim_asm_tac1);
save_pop_thm "Ø_less_º_trans_thm"
);
=TEX
=SML
val €Ø_º_less_trans_thm› = (
set_goal([], ¨µx y z: Ø∑ x º y ± y < z ¥ x < zÆ);
a(rewrite_tac[get_spec¨$ºâRÆ]);
a(REPEAT strip_tac THEN1 all_fc_tac[Ø_less_trans_thm]);
a(all_var_elim_asm_tac1);
save_pop_thm "Ø_º_less_trans_thm"
);
=TEX
=SML
val €Ø_º_refl_thm› = (
set_goal([], ¨µx: Ø∑ x º xÆ);
a(rewrite_tac[get_spec¨$ºâRÆ]);
save_pop_thm "Ø_º_refl_thm"
);
=TEX
=SML
val €Ø_º_trans_thm› = (
set_goal([], ¨µx y z: Ø∑ x º y ± y º z ¥ x º zÆ);
a(rewrite_tac[get_spec¨$ºâRÆ]);
a(REPEAT strip_tac THEN_TRY all_var_elim_asm_tac1 THEN REPEAT strip_tac);
a(all_fc_tac[Ø_less_trans_thm]);
save_pop_thm "Ø_º_trans_thm"
);
=TEX
=SML
val €Ø_º_≥_less_thm› = (
set_goal([], ¨µx y: Ø∑ x º y § ≥y < xÆ);
a(rewrite_tac[get_spec¨$ºâRÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(contr_tac THEN all_fc_tac[Ø_less_antisym_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[Ø_less_irrefl_thm]);
a(contr_tac THEN all_fc_tac[Ø_less_cases_thm]);
save_pop_thm "Ø_º_≥_less_thm"
);
=TEX
=SML
val €Ø_≥_º_less_thm› = (
set_goal([], ¨µx y: Ø∑ ≥x º y § y < xÆ);
a(rewrite_tac[Ø_º_≥_less_thm]);
save_pop_thm "Ø_≥_º_less_thm"
);
=TEX
=SML
val €Ø_less_≥_eq_thm› = (
set_goal([], ¨µx y: Ø∑ x < y ¥ ≥x = yÆ);
a(contr_tac THEN all_var_elim_asm_tac THEN all_fc_tac[Ø_less_irrefl_thm]);
save_pop_thm "Ø_less_≥_eq_thm"
);
=TEX
=SML
val €Ø_≥_less_º_thm› = conv_rule (ONCE_MAP_C eq_sym_conv) Ø_º_≥_less_thm;
=TEX
=SML
val €Ø_less_dense_thm› = (
set_goal([], ¨µx y: Ø∑ x < y ¥ ∂z∑ x < z ± z < yÆ);
a(strip_asm_tac (get_spec¨$<âRÆ));
a(POP_ASM_T (strip_asm_tac o rewrite_rule(map get_spec[¨$DenseInÆ])));
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(∂_tac¨aÆ THEN REPEAT strip_tac);
save_pop_thm "Ø_less_dense_thm"
);
=TEX
=SML
val €Ø_complete_thm› = (
set_goal([], ¨µA : Ø SET∑
	≥A = {} ± (∂b∑µ x∑ x ç A ¥ x º b) ¥
	∂s∑  (µ x∑ x ç A ¥ x º s)
±	(µ b∑ (µ x∑ x ç A ¥ x º b) ¥ s º b)
Æ);
push_pc"sets_ext1";
a(REPEAT strip_tac);
a(LEMMA_T ¨Complete(Universe, $<âR)Æ ante_tac THEN1 prove_tac[get_spec¨$<âRÆ]);
a(rewrite_tac(map get_spec[¨CompleteÆ, ¨UnboundedAboveÆ, ¨UpperBoundÆ, ¨$HasSupremumÆ]));
a(STRIP_T (strip_asm_tac o list_µ_elim[¨{s|∂r∑r ç A ± s < r}Æ, ¨bÆ]));
(* *** Goal "1" *** *)
a(strip_asm_tac(µ_elim¨xÆØ_unbounded_below_thm));
a(spec_nth_asm_tac 2 ¨yÆ THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_fc_tac[Ø_less_dense_thm]);
a(spec_nth_asm_tac 3 ¨zÆ THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
a(all_fc_tac[Ø_less_º_trans_thm]);
(* *** Goal "4" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[Ø_≥_less_º_thm]);
a(REPEAT strip_tac THEN ∂_tac¨yÆ THEN REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(contr_tac THEN all_fc_tac[Ø_º_less_cases_thm]);
a(spec_nth_asm_tac 5 ¨yÆ THEN all_asm_fc_tac[Ø_less_irrefl_thm]);
(* *** Goal "4.2" *** *)
a(GET_NTH_ASM_T 2 bc_thm_tac THEN REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_fc_tac[Ø_less_º_trans_thm]);
pop_pc();
save_pop_thm "Ø_complete_thm"
);
=TEX
=SML
val _ = (
push_consistency_goal¨SupÆ;
a(prove_∂_tac THEN REPEAT strip_tac);
a(cases_tac¨A' = {}Æ THEN1 asm_rewrite_tac[]);
a(CASES_T2¨≥(∂ b∑ µ x∑ x ç A' ¥ x º b)Æ rewrite_thm_tac strip_asm_tac);
a(all_fc_tac[Ø_complete_thm]);
a(∂_tac¨sÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
save_consistency_thm¨SupÆ (pop_thm())
);
=TEX
=SML
val €Ø_sup_thm› = (
set_goal([], ¨µA a∑ ≥A = {} ± (µx∑x ç A ¥ x º a) ¥
	(µ x∑ x ç A ¥ x º Sup A) ± (µ b∑ (µ x∑ x ç A ¥ x º b) ¥ Sup A º b)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac (µ_elim¨AÆ (get_spec¨SupÆ)));
(* *** Goal "1.1" *** *)
a(spec_nth_asm_tac 1 ¨aÆ THEN all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac (µ_elim¨AÆ (get_spec¨SupÆ)));
(* *** Goal "2.1" *** *)
a(spec_nth_asm_tac 1 ¨aÆ THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(all_asm_fc_tac[]);
save_pop_thm "Ø_sup_thm"
);
=TEX
=SML
val €Ø_less_sup_thm› = (
set_goal([], ¨µA∑ ≥A = {} ± (∂a∑µx∑x ç A ¥ x º a) ¥
	(µx∑ x < Sup A § (∂y∑y ç A ± x < y))Æ);
a(REPEAT µ_tac THEN strip_tac);
a(strip_asm_tac (list_µ_elim[¨AÆ, ¨aÆ] Ø_sup_thm) THEN1 all_asm_fc_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(swap_nth_asm_concl_tac 1 THEN rewrite_tac[Ø_≥_less_º_thm]);
a(GET_NTH_ASM_T 2 bc_thm_tac THEN rewrite_tac[Ø_º_≥_less_thm]);
a(REPEAT strip_tac);
a(spec_nth_asm_tac 2 ¨x'Æ);
(* *** Goal "2" *** *)
a(spec_nth_asm_tac 4 ¨yÆ THEN all_fc_tac[Ø_less_º_trans_thm]);
save_pop_thm "Ø_less_sup_thm"
);
=TEX
=SML
val €Ø_less_sup_bc_thm› = (
set_goal([], ¨µA∑ ≥A = {} ± (∂a∑µx∑x ç A ¥ x º a) ± (∂y∑y ç A ± x < y) ¥ x < Sup AÆ);
a(REPEAT strip_tac);
a(strip_asm_tac (list_µ_elim[¨AÆ] Ø_less_sup_thm));
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 1 ¨aÆ THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
a(contr_tac THEN all_asm_fc_tac[]);
save_pop_thm "Ø_less_sup_bc_thm"
);
=TEX
=SML
val €Ø_º_sup_thm› = (
set_goal([], ¨µA a∑ ≥A = {} ± (∂a∑µx∑x ç A ¥ x º a) ¥
	(µx∑ x º Sup A § (µy∑(µz∑z ç A ¥ z º y) ¥ x º y))Æ);
a(REPEAT µ_tac THEN strip_tac);
a(strip_asm_tac (list_µ_elim[¨AÆ, ¨aÆ] Ø_sup_thm) THEN1 all_asm_fc_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 3 ¨yÆ THEN1 all_asm_fc_tac[]);
a(all_fc_tac[Ø_º_trans_thm]);
(* *** Goal "2" *** *)
a(spec_nth_asm_tac 1 ¨Sup AÆ THEN1 all_asm_fc_tac[]);
save_pop_thm "Ø_º_sup_thm"
);
=TEX
=SML
val €Ø_º_sup_bc_thm› = (
set_goal([], ¨µA a x∑ ≥A = {} ± (∂a∑µx∑x ç A ¥ x º a) ± (µy∑(µz∑z ç A ¥ z º y) ¥ x º y) ¥
	x º Sup AÆ);
a(REPEAT strip_tac);
a(strip_asm_tac (list_µ_elim[¨AÆ, ¨aÆ] Ø_º_sup_thm));
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 1 ¨aÆ THEN1 all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
save_pop_thm "Ø_º_sup_bc_thm"
);
=TEX
=SML
val €Ø_ç_º_sup_bc_thm› = (
set_goal([], ¨µA x∑ x ç A ± (∂a∑µx∑x ç A ¥ x º a)  ¥ x º Sup AÆ);
a(REPEAT strip_tac);
a(lemma_tac¨≥A = {}Æ THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(strip_asm_tac (list_µ_elim[¨AÆ, ¨aÆ] Ø_º_sup_thm));
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 1 ¨aÆ THEN1 all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[] THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
save_pop_thm "Ø_ç_º_sup_bc_thm"
);
=TEX
=SML
val €Ø_Ä_sup_thm› = (
set_goal([], ¨µA B∑
	≥A = {} ± (∂a∑µx∑x ç A ¥ x º a) ±
	≥B = {} ± (∂b∑µy∑y ç B ¥ y º b) ±
	A Ä B ¥	Sup A º Sup BÆ);
a(REPEAT strip_tac);
a(strip_asm_tac (list_µ_elim[¨AÆ, ¨aÆ] Ø_sup_thm) THEN1 all_asm_fc_tac[]);
a(strip_asm_tac (list_µ_elim[¨BÆ, ¨bÆ] Ø_sup_thm) THEN1 all_asm_fc_tac[]);
a(DROP_NTH_ASM_T 5 (PC_T1 "sets_ext1" strip_asm_tac));
a(spec_nth_asm_tac 4 ¨Sup BÆ);
a(all_asm_fc_tac [] THEN all_asm_fc_tac[]);
save_pop_thm "Ø_Ä_sup_thm"
);
=TEX
=SML
val €Ø_sup_º_bc_thm› = (
set_goal([], ¨µA a x∑ ≥A = {} ± (∂a∑µx∑x ç A ¥ x º a) ± (µy∑y ç A ¥ y º x) ¥
	Sup A º xÆ);
a(REPEAT strip_tac);
a(strip_asm_tac (list_µ_elim[¨AÆ, ¨aÆ] Ø_sup_thm) THEN all_asm_fc_tac[]);
save_pop_thm "Ø_sup_º_bc_thm"
);
=TEX
=SML
val €Ø_sup_less_bc_thm› = (
set_goal([], ¨µA x z∑ ≥A = {} ± (∂a∑µx∑x ç A ¥ x º a) ± (µy∑y ç A ¥ y º x) ± x < z ¥
	Sup A < zÆ);
a(REPEAT strip_tac);
a(lemma_tac¨Sup A º xÆ);
(* *** Goal "1" *** *)
a(bc_thm_tac Ø_sup_º_bc_thm);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
a(∂_tac¨aÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[Ø_º_less_trans_thm]);
save_pop_thm "Ø_sup_less_bc_thm"
);
=TEX
=SML
val €Ø_sup_eq_bc_thm› = (
set_goal([], ¨µA a s∑ ≥A = {} ± (µx∑x ç A ¥ x º s) ± (µx∑(µy∑y ç A ¥ y º x) ¥ s º x) ¥
	Sup A = sÆ);
a(REPEAT strip_tac);
a(rewrite_tac[Ø_eq_º_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ø_sup_º_bc_thm THEN asm_rewrite_tac[]);
a(∂_tac¨sÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(bc_thm_tac Ø_º_sup_bc_thm THEN asm_rewrite_tac[]);
a(∂_tac¨sÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
save_pop_thm "Ø_sup_eq_bc_thm"
);
=TEX
=SML
val €Ø_eq_sup_bc_thm› = (
set_goal([], ¨µA a s∑ ≥A = {} ± (µx∑x ç A ¥ x º s) ± (µx∑(µy∑y ç A ¥ y º x) ¥ s º x) ¥
	s = Sup AÆ);
a(REPEAT strip_tac THEN conv_tac eq_sym_conv);
a(bc_thm_tac Ø_sup_eq_bc_thm THEN all_asm_ante_tac THEN taut_tac);
save_pop_thm "Ø_eq_sup_bc_thm"
);
=TEX
The following principle about suprema will be useful:
=SML
val €Ø_less_sup_ç_thm› = (
set_goal([], ¨µA a∑ ≥A = {} ± (µx∑x ç A ¥ x º a) ± ≥Sup A ç A ¥
	(µx∑ x < Sup A ¥ ∂y∑ x < y ± y < Sup A ± y ç A)Æ);
a(REPEAT µ_tac THEN strip_tac);
a(strip_asm_tac (list_µ_elim[¨AÆ, ¨aÆ] Ø_sup_thm) THEN1 all_asm_fc_tac[]);
a(contr_tac THEN lemma_tac¨Sup A º xÆ);
(* *** Goal "1" *** *)
a(GET_NTH_ASM_T 3 bc_thm_tac THEN REPEAT strip_tac);
a(contr_tac THEN POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(spec_nth_asm_tac 3 ¨x'Æ);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
a(spec_nth_asm_tac 7 ¨x'Æ);
a(lemma_tac¨x' = Sup AÆ THEN1 (rewrite_tac[Ø_eq_º_thm] THEN REPEAT strip_tac));
a(all_var_elim_asm_tac1);
(* *** Goal "2" *** *)
a(all_fc_tac[Ø_less_º_trans_thm] THEN all_fc_tac[Ø_less_irrefl_thm]);
save_pop_thm "Ø_less_sup_ç_thm"
);
=TEX
\section{CONSISTENCY OF ADDITION}
In this section we prove that the definition of
=INLINEFT
$+âR
=TEX
\ is consistent.
The proof is long. We begin with a series of lemmas (after the following
red tape).

=SML
end (* of structure Ø part 2 *);
structure €Ø› (* : Ø *) = struct
open Ø;
=TEX

\subsection{Miscellaneous Lemmas}
The first lemma is just a convenience.
=SML
val €plus_exists_lemma1› = (
set_goal([], ¨µx y∑ y dy_less x ¥ ∂z∑ x dy_times z dy_less y ± z dy_less dy_oneÆ);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim ¨yÆ dy_balance_thm1));
a(strip_asm_tac (µ_elim ¨x dy_times y'Æ dy_balance_thm2));
a(lemma_tac¨x dy_times y'' dy_less yÆ);
(* *** Goal "1" *** *)
a(ALL_FC_T (MAP_EVERY ante_tac) [dy_less_trans_thm]);
a(rewrite_tac[list_µ_elim[¨xÆ, ¨y'Æ]dy_times_comm_thm, list_µ_elim[¨yÆ, ¨y'Æ]dy_times_comm_thm]);
a(rewrite_tac[dy_times_assoc_thm, dy_times_mono_§_thm]);
(* *** Goal "2" *** *)
a(∂_tac ¨y''Æ THEN REPEAT strip_tac);
a(strip_asm_tac (list_µ_elim[¨y''Æ, ¨dy_oneÆ]dy_less_trich_thm));
(* *** Goal "2.1" *** *)
a(all_var_elim_asm_tac1);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[dy_times_unit_thm]));
a(all_fc_tac[dy_less_antisym_thm]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨x dy_less yÆ THEN_LIST
	[bc_thm_tac dy_less_trans_thm, all_fc_tac[dy_less_antisym_thm]]);
a(∂_tac¨x dy_times y''Æ THEN REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨xÆ, ¨dy_oneÆ, ¨y''Æ] dy_times_mono_thm1));
a(once_rewrite_tac[dy_times_comm_thm]);
a(POP_ASM_T ante_tac THEN rewrite_tac[once_rewrite_rule[dy_times_comm_thm] dy_times_unit_thm]);
pop_thm()
);
=TEX
The second lemma is a simple consequence of
=INLINEFT
minimum_≥_thm
=TEX
.
=SML
val €plus_exists_lemma2› = (
set_goal([], ¨µp m∑ p 0 ± ≥p m ¥ ∂n∑p n ± ≥p (n+1)Æ);
a(REPEAT strip_tac);
a(all_fc_tac[minimum_≥_thm]);
a(spec_nth_asm_tac 2 ¨m'Æ);
a(contr_tac THEN all_asm_fc_tac[]);
pop_thm()
);
=TEX
The next lemma is the analogue for the dyadic
rationals of the less/less-or-equal transitivity theorems.
=SML
val €plus_exists_lemma3› = (
set_goal([], ¨µa b c∑ a dy_less b ± ≥c dy_less b ¥ a dy_less cÆ);
a(REPEAT strip_tac);
a(cases_tac¨b = cÆ THEN1 (all_var_elim_asm_tac THEN all_fc_tac[dy_less_irrefl_thm]));
a(fc_tac[dy_less_trich_thm]);
a(all_fc_tac[dy_less_trans_thm]);
pop_thm()
);
=TEX
Similarly next lemma is the analogue for the dyadic
rationals of the less-or-equal/less transitivity theorems.
=SML
val €plus_exists_lemma4› = (
set_goal([], ¨µa b c∑ ≥b dy_less a ± b dy_less c ¥ a dy_less cÆ);
a(REPEAT strip_tac);
a(cases_tac¨a = bÆ THEN1 (all_var_elim_asm_tac THEN all_fc_tac[dy_less_irrefl_thm]));
a(fc_tac[dy_less_trich_thm]);
a(all_fc_tac[dy_less_trans_thm]);
pop_thm()
);
=TEX
The next lemma builds on the right balance theorem a little.
(Commented out - no plans to use at the moment.)
=SML
(*
val €plus_exists_lemmaX› = (
set_goal([], ¨µa∑ ∂b∑ dy_one dy_less a dy_times b ± dy_one dy_less bÆ);
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨aÆ dy_balance_thm1));
a(cases_tac¨dy_one dy_less yÆ);
(* *** Goal "1" *** *)
a(∂_tac¨yÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(strip_asm_tac (rewrite_rule[dy_times_unit_clauses](µ_elim¨dy_oneÆ dy_balance_thm1)));
a(∂_tac¨y'Æ THEN REPEAT strip_tac);
a(all_fc_tac[plus_exists_lemma4]);
a(bc_thm_tac dy_less_trans_thm THEN ∂_tac ¨a dy_times yÆ THEN REPEAT strip_tac);
a(bc_thm_tac dy_times_mono_thm THEN REPEAT strip_tac);
pop_thm()
);
*)
=TEX
More on balance:
=SML
val €plus_exists_lemma5› = (
set_goal([], ¨µa b∑ ∂c∑ b dy_less a dy_times cÆ);
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨aÆ dy_balance_thm1));
a(∂_tac¨y dy_times bÆ);
a(LEMMA_T¨dy_one dy_times b dy_less (a dy_times y) dy_times bÆ ante_tac
	THEN_LIST [bc_thm_tac dy_times_mono_thm1 THEN REPEAT strip_tac,
		rewrite_tac[dy_times_assoc_thm, dy_times_unit_clauses]]);
pop_thm()
);
=TEX
The next lemma helps with our use of the archimedean property.
=SML
val €plus_exists_lemma6› = (
set_goal([], ¨µa b d∑ a dy_less b ± dy_one dy_less d ¥
	∂m∑	 a dy_times d dy_exp m dy_less b ±
		≥a dy_times d dy_exp (m+1) dy_less bÆ);
a(REPEAT strip_tac);
a(bc_thm_tac (rewrite_rule[](µ_elim ¨
	Ãm∑a dy_times d dy_exp m dy_less bÆ plus_exists_lemma2)));
a(asm_rewrite_tac[dy_exp_clauses, dy_times_unit_thm]);
a(strip_asm_tac(list_µ_elim[¨aÆ, ¨bÆ] plus_exists_lemma5));
a(strip_asm_tac (list_µ_elim[¨dÆ, ¨cÆ]dy_arch_thm));
a(∂_tac¨tÆ THEN contr_tac);
a(LEMMA_T¨a dy_times d dy_exp t dy_less a dy_times d dy_exp tÆ
	(strip_asm_tac o rewrite_rule[dy_less_irrefl_thm]));
a(bc_thm_tac dy_less_trans_thm THEN ∂_tac¨bÆ THEN REPEAT strip_tac);
a(bc_thm_tac dy_less_trans_thm THEN ∂_tac¨a dy_times cÆ THEN REPEAT strip_tac);
a(bc_thm_tac dy_times_mono_thm THEN REPEAT strip_tac);
pop_thm()
);
=TEX
Yet more to do with the archimedean property:
=SML
val €plus_exists_lemma7› = (
set_goal([], ¨µa b d∑ a dy_less b ± dy_one dy_less d ¥
	∂m∑	 b dy_less a dy_times d dy_exp mÆ);
a(REPEAT strip_tac);
a(all_fc_tac[plus_exists_lemma6]);
a(∂_tac¨(m'+1) + 1Æ THEN once_rewrite_tac[dy_exp_clauses]);
a(bc_thm_tac plus_exists_lemma4 THEN ∂_tac¨a dy_times d dy_exp (m' + 1)Æ THEN REPEAT strip_tac);
a(rewrite_tac[dy_exp_clauses] );
a(LEMMA_T ¨ a dy_times (d dy_exp m') dy_times d dy_times dy_one
	   dy_less a dy_times ((d dy_exp m') dy_times d) dy_times dÆ ante_tac THEN_LIST
	[bc_thm_tac dy_times_mono_thm THEN REPEAT strip_tac,
	 rewrite_tac[dy_times_unit_clauses]]);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) dy_times_assoc_thm]);
a(bc_thm_tac dy_times_mono_thm THEN REPEAT strip_tac);
pop_thm()
);
=TEX
The following is used in the proof of the existence of additive inverses
to show that the set whose supremum is the inverse is non-empty.
Unsurprisingly, this is a point at which the second balance theorem makes
a crucial appearance:
=SML
val €plus_exists_lemma8› = (
set_goal([], ¨µc∑∂b∑µa∑ a dy_less c ¥ a dy_times b dy_less dy_oneÆ);
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨cÆdy_balance_thm2));
a(∂_tac¨yÆ THEN REPEAT strip_tac);
a(bc_thm_tac dy_less_trans_thm THEN ∂_tac ¨c dy_times yÆ THEN REPEAT strip_tac);
a(bc_thm_tac dy_times_mono_thm1 THEN REPEAT strip_tac);
pop_thm()
);
=TEX
=TEX
The following is used to show that the set whose limit is the additive
inverse of a real number is bounded above.
=SML
val €plus_exists_lemma8› = (
set_goal([], ¨µc∑∂b∑µa∑ a dy_less c ¥ a dy_times b dy_less dy_oneÆ);
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨cÆdy_balance_thm2));
a(∂_tac¨yÆ THEN REPEAT strip_tac);
a(bc_thm_tac dy_less_trans_thm THEN ∂_tac ¨c dy_times yÆ THEN REPEAT strip_tac);
a(bc_thm_tac dy_times_mono_thm1 THEN REPEAT strip_tac);
pop_thm()
);
=TEX
The following makes the right density theorem a bit easier to use (by throwing in the
fact that the addend it gives is positive):
=SML
val €plus_exists_lemma9› = (
set_goal([], ¨µa b∑ a dy_less b ¥ ∂c∑
	dy_one dy_less c ± a dy_less a dy_times c ± a dy_times c dy_less bÆ);
a(REPEAT strip_tac);
a(all_fc_tac[dy_right_dense_thm]);
a(∂_tac¨zÆ THEN REPEAT strip_tac);
a(LEMMA_T¨a dy_times dy_one dy_less a dy_times zÆ ante_tac THEN_LIST
	[asm_rewrite_tac[dy_times_unit_thm],
	 rewrite_tac[dy_times_mono_§_thm]]);
pop_thm()
);
=TEX
The following is another convenience (and could have been put to good use
in several earlier proofs).
=SML
val €plus_exists_lemma10› = (
set_goal([], ¨µa b∑ dy_one dy_less a ¥ b dy_less b dy_times aÆ);
a(REPEAT strip_tac);
a(LEMMA_T¨b dy_times dy_one dy_less b dy_times aÆ ante_tac THEN_LIST
	[asm_rewrite_tac[dy_times_mono_§_thm],
	 rewrite_tac[dy_times_unit_thm]]);
pop_thm()
);
=TEX
The following is used in proving the existence of additive inverses.
(The context being where $a$ and $b$ are within $c$ of two limits
and we want to argue that $a + b$ is within $2\times c$ of the sum of the limits).
=SML
val €plus_exists_lemma11› = (
set_goal([], ¨µa b∑ a dy_less b ¥ ∂c∑
	dy_one dy_less c ±
	a dy_less a dy_times c dy_times c ±
	a dy_times c dy_times c dy_less bÆ);
a(REPEAT strip_tac);
a(all_fc_tac[plus_exists_lemma9]);
a(all_fc_tac[µ_elim¨a dy_times cÆplus_exists_lemma9]);
a(cases_tac¨c dy_less c'Æ);
(* *** Goal "1" *** *)
a(∂_tac ¨cÆ THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(bc_thm_tac dy_less_trans_thm THEN ∂_tac ¨a dy_times cÆ THEN REPEAT strip_tac);
a(asm_rewrite_tac[µ_elim¨cÆdy_times_order_thm, dy_times_mono_§_thm]);
a(ALL_FC_T rewrite_tac [plus_exists_lemma10]);
(* *** Goal "1.2" *** *)
a(bc_thm_tac dy_less_trans_thm THEN ∂_tac ¨(a dy_times c) dy_times c'Æ THEN REPEAT strip_tac);
a(asm_rewrite_tac[dy_times_assoc_thm, dy_times_mono_§_thm]);
(* *** Goal "2" *** *)
a(∂_tac ¨c'Æ THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(bc_thm_tac dy_less_trans_thm THEN ∂_tac ¨a dy_times c'Æ THEN REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(ALL_FC_T rewrite_tac [plus_exists_lemma10]);
(* *** Goal "2.1.2" *** *)
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) dy_times_assoc_thm]);
a(ALL_FC_T rewrite_tac [plus_exists_lemma10]);
(* *** Goal "2.2" *** *)
a(bc_thm_tac plus_exists_lemma4 THEN ∂_tac ¨(a dy_times c) dy_times c'Æ THEN REPEAT strip_tac);
a(rewrite_tac[dy_times_assoc_thm, dy_times_mono_§_thm]);
a(once_rewrite_tac[dy_times_comm_thm]);
a(asm_rewrite_tac[dy_times_mono_§_thm]);
pop_thm()
);
=TEX
\subsection{Statement of the Theorem}

Now we embark on the main consistency proof.
=SML
val €Ø_plus_exists_thm› = (
declare_infix(300, "pl");
declare_infix(300, "pld");
set_goal([], ¨∂$pl:Ø ≠ Ø ≠ Ø; zero : Ø∑
	(µx y z∑ (x pl y) pl z = x pl (y pl z))
±	(µx y∑ x pl y = y pl x)
±	(µx∑ x pl zero = x)
±	(∂one∑zero < one)
±	(µx∑ ∂y∑ x pl y = zero)
±	(µx y z∑ y < z ¥ x pl y < x pl z)
Æ);
(*
=TEX
\subsection{Getting Started}
We warm up by introducing names for various items we will need.
The function $i$ sends a real number $x$ to the cut in the dyadic
rationals that has $x$ as its supremum.
The function $s$ is the right inverse of $i$.
The infix operator $pld$ is the operator on cuts that will induce the
addition on the reals. Finally the operator $pl$ is the addition
operator we seek.
=SML
*)
a(strip_asm_tac (get_spec¨$<âRÆ));
a(LIST_DROP_NTH_ASM_T [3, 4, 5, 6] discard_tac);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[get_spec¨$DenseInÆ]));
a(lemma_tac¨∂i∑ µx∑ i x = {a | … a < x}Æ THEN1 prove_∂_tac);
a(lemma_tac¨∂s∑ µA∑ s A = Sup{y | ∂a∑a ç A ± y < … a}Æ THEN1 prove_∂_tac);
a(lemma_tac¨∂$pld∑
	µA B∑ A pld B = {c | ∂a b∑ a ç A ± b ç B ± c dy_less a dy_times b}Æ
	THEN1 prove_∂_tac);
a(lemma_tac¨∂$pl∑ µx y∑ x pl y = s( i x pld i y )Æ THEN1 prove_∂_tac);
(*
=TEX
\subsection{A lemma about $s$ and $i$}

Subgoal 1: our first job is to show that $s$ is a left-inverse for $i$:
=SML
*)
a(lemma_tac¨µx∑s(i x) = xÆ);
(* *** Goal "1" *** *)
a(LIST_DROP_NTH_ASM_T [1, 2, 3, 4] rewrite_tac THEN REPEAT strip_tac);
a(bc_thm_tac Ø_sup_eq_bc_thm);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(strip_asm_tac(µ_elim¨xÆØ_unbounded_below_thm));
a(list_spec_nth_asm_tac 2 [¨yÆ, ¨xÆ] THEN all_var_elim_asm_tac1);
a(∂_tac¨yÆ THEN rewrite_tac[]);
a(∂_tac¨a'Æ THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(asm_rewrite_tac[get_spec¨$ºâRÆ] THEN all_fc_tac[Ø_less_trans_thm] THEN REPEAT strip_tac);
(* *** Goal "1.3" *** *)
a(rewrite_tac[Ø_º_≥_less_thm] THEN contr_tac);
a(list_spec_nth_asm_tac 3 [¨x'Æ, ¨xÆ] THEN all_var_elim_asm_tac1);
a(list_spec_nth_asm_tac 5 [¨x'Æ, ¨… a'Æ] THEN all_var_elim_asm_tac1);
a(spec_nth_asm_tac 6 ¨… a''Æ);
(* *** Goal "1.3.1" *** *)
a(spec_nth_asm_tac 1 ¨a'Æ);
(* *** Goal "1.3.2" *** *)
a(all_asm_fc_tac[Ø_º_less_trans_thm] THEN all_asm_fc_tac[Ø_less_irrefl_thm]);
(*
=TEX
\subsection{A lemma about $s$, $i$ and $pld$}

Subgoal 2: next we show that $i$ is a left inverse for $s$ when restricted $s$
to representatives of numbers of the form $x + y$.
This fact gives a rewrite rule that streamlines the proof of associativity.
=SML
*)
(* *** Goal "2" *** *)
a(lemma_tac¨µx y∑ i(s(i x pld i y)) = i x pld i yÆ THEN1 REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(LIST_DROP_NTH_ASM_T [1, 2, 3, 4, 5] rewrite_tac);
a(PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(lemma_tac¨≥{y'|∂ a ∑ (∂ a' b∑ … a' < x ± … b < y ± a dy_less a' dy_times b) ± y' < … a} = {}Æ);
(* *** Goal "2.1.1.1" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨xÆØ_unbounded_below_thm));
a(list_spec_nth_asm_tac 3 [¨y'Æ, ¨xÆ] THEN all_var_elim_asm_tac1);
a(strip_asm_tac(µ_elim¨yÆØ_unbounded_below_thm));
a(list_spec_nth_asm_tac 6 [¨y''Æ, ¨yÆ] THEN all_var_elim_asm_tac1);
a(list_spec_nth_asm_tac 8 [¨y'Æ, ¨… a'Æ] THEN all_var_elim_asm_tac1);
a(list_spec_nth_asm_tac 10 [¨y''Æ, ¨… a''Æ] THEN all_var_elim_asm_tac1);
a(strip_asm_tac(µ_elim¨… (a''' dy_times a'''')ÆØ_unbounded_below_thm));
a(∂_tac¨y'''Æ THEN rewrite_tac[]);
a(∂_tac¨a''' dy_times a''''Æ THEN REPEAT strip_tac);
(* *** Goal "2.1.1.1.1" *** *)
a(∂_tac¨a'Æ THEN ∂_tac¨a''Æ THEN REPEAT strip_tac);
a(bc_thm_tac dy_times_mono_thm2);
a(LIST_DROP_NTH_ASM_T [2, 4] (MAP_EVERY ante_tac) THEN asm_rewrite_tac[] THEN taut_tac);
(* *** Goal "2.1.1.2" *** *)
a(LEMMA_T¨∂d∑µw∑
	w ç {y'|∂ a ∑ (∂ a' b∑ … a' < x ± … b < y ± a dy_less a' dy_times b) ± y' < … a} 
	¥ w º dÆ asm_tac);
(* *** Goal "2.1.1.2.1" *** *)
a(strip_asm_tac(µ_elim¨xÆØ_unbounded_above_thm));
a(list_spec_nth_asm_tac 4 [¨xÆ, ¨y'Æ] THEN all_var_elim_asm_tac1);
a(strip_asm_tac(µ_elim¨yÆØ_unbounded_above_thm));
a(list_spec_nth_asm_tac 7 [¨yÆ, ¨y''Æ] THEN all_var_elim_asm_tac1);
a(∂_tac¨… (a' dy_times a'')Æ THEN REPEAT strip_tac);
a(lemma_tac ¨… a < … (a''' dy_times b)Æ THEN1 asm_rewrite_tac[]);
a(lemma_tac ¨w < … (a''' dy_times b)Æ THEN1 all_fc_tac[Ø_less_trans_thm]);
a(lemma_tac ¨… (a''' dy_times b) <  … (a' dy_times a'')Æ);
(* *** Goal "2.1.1.2.1.1" *** *)
a(asm_rewrite_tac[] THEN bc_thm_tac dy_times_mono_thm2);
a(lemma_tac ¨… a''' < … a' ± … b < … a''Æ THEN1
	(REPEAT strip_tac THEN all_fc_tac[Ø_less_trans_thm]));
a(LIST_DROP_NTH_ASM_T [1, 2] (MAP_EVERY ante_tac) THEN asm_rewrite_tac[] THEN taut_tac);
(* *** Goal "2.1.1.2.1.2" *** *)
a(rewrite_tac[get_spec¨$ºâRÆ] THEN all_fc_tac[Ø_less_trans_thm] THEN REPEAT strip_tac);
(* *** Goal "2.1.1.2.2" *** *)
a(ante_tac (µ_elim¨{y'|∂ a ∑ (∂ a' b∑ … a' < x ± … b < y ± a dy_less a' dy_times b) ± y' < … a}Æ
	 Ø_less_sup_thm));
a(LIST_DROP_NTH_ASM_T [1,2] rewrite_tac);
a(STRIP_T (fn th => all_fc_tac[th]));
a(∂_tac ¨a'Æ THEN ∂_tac¨bÆ THEN REPEAT strip_tac);
a(all_fc_tac[Ø_less_trans_thm]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN all_fc_tac[dy_less_trans_thm]);
(* *** Goal "2.1.2" *** *)
a(bc_thm_tac Ø_less_sup_bc_thm);
a(REPEAT strip_tac);
(* *** Goal "2.1.2.1" *** *)
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(∂_tac ¨… x'Æ THEN rewrite_tac[]);
a(all_fc_tac[dy_less_dense_thm]);
a(∂_tac ¨zÆ THEN REPEAT strip_tac);
(* *** Goal "2.1.2.1.1" *** *)
a(∂_tac ¨aÆ THEN ∂_tac ¨bÆ THEN REPEAT strip_tac);
(* *** Goal "2.1.2.1.2" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2.2" *** *)
a(strip_asm_tac(µ_elim¨xÆØ_unbounded_above_thm));
a(list_spec_nth_asm_tac 5 [¨xÆ, ¨y'Æ] THEN all_var_elim_asm_tac1);
a(strip_asm_tac(µ_elim¨yÆØ_unbounded_above_thm));
a(list_spec_nth_asm_tac 8 [¨yÆ, ¨y''Æ] THEN all_var_elim_asm_tac1);
a(∂_tac¨…(a'' dy_times a''')Æ THEN REPEAT strip_tac);
a(rewrite_tac[get_spec¨$ºâRÆ] THEN ≤_left_tac);
a(lemma_tac ¨… a' < … (a'''' dy_times b')Æ THEN1 asm_rewrite_tac[]);
a(lemma_tac ¨x'' < … (a'''' dy_times b')Æ THEN1 all_fc_tac[Ø_less_trans_thm]);
a(lemma_tac ¨… (a'''' dy_times b') <  … (a'' dy_times a''')Æ);
(* *** Goal "2.1.2.2.1" *** *)
a(asm_rewrite_tac[] THEN bc_thm_tac dy_times_mono_thm2);
a(LEMMA_T¨… a''''  < … a'' ± … b' < … a'''Æ ante_tac THEN1
	(REPEAT strip_tac THEN all_fc_tac[Ø_less_trans_thm]));
a(asm_rewrite_tac[] THEN taut_tac);
(* *** Goal "2.1.2.2.2" *** *)
a(all_fc_tac[Ø_less_trans_thm]);
(* *** Goal "2.1.2.3" *** *)
a(all_fc_tac[dy_less_dense_thm]);
a(∂_tac ¨… zÆ THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
a(all_fc_tac[µ_elim ¨zÆdy_less_dense_thm]);
a(∂_tac ¨z'Æ THEN REPEAT strip_tac);
a(∂_tac ¨aÆ THEN ∂_tac ¨bÆ THEN REPEAT strip_tac);
(*
=TEX
\subsection{The Witnesses}

Subgoal 2.2: we now introduce the witnesses and strip off the first four properties
to be proved.
The proofs of the existence of inverses and of the ordering property share a lemma
so we don't strip them apart at this stage.
(which is why we contrived in the statement of the theorem to put them together at
the end).

=SML
*)
(* *** Goal "2.2" *** *)
a(∂_tac¨$plÆ THEN ∂_tac ¨… dy_oneÆ THEN REPEAT_N 4 strip_tac);
(*
=TEX
\subsection{Associativity}

Subgoal 2.2.1: associativity: the operator $pld$ is associative. However, 
inferring the associativity of $pl$ from this fact requires us to reason
about suprema. The rewrite rule that we have just finished proving
lets us rewrite the goal in the form $s(a) = s(b)$ where $a$ and $b$ do not
involve $s$. We then prove $a = b$ and so avoid further reasoning about suprema.
=SML
*)
(* *** Goal "2.2.1" *** *)
a(LIST_GET_NTH_ASM_T[1, 3] rewrite_tac);
a(LEMMA_T ¨µ x y z∑ (i x pld i y) pld i z = i x pld (i y pld i z)Æ rewrite_thm_tac);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
a(rename_tac[] THEN PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.2.1.1" *** *)
a(∂_tac ¨a'Æ THEN ∂_tac ¨b' dy_times bÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.1.1.1" *** *)
a(list_spec_nth_asm_tac 12 [¨… b'Æ, ¨yÆ] THEN all_var_elim_asm_tac1);
a(∂_tac ¨a'''Æ THEN ∂_tac ¨bÆ THEN REPEAT strip_tac);
a(bc_thm_tac dy_times_mono_thm1);
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.1.1.2" *** *)
a(bc_thm_tac dy_less_trans_thm THEN ∂_tac¨a dy_times bÆ THEN REPEAT strip_tac);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) dy_times_assoc_thm]);
a(bc_thm_tac dy_times_mono_thm1 THEN REPEAT strip_tac);
(* *** Goal "2.2.1.2" *** *)
a(∂_tac ¨a dy_times a'Æ THEN ∂_tac ¨b'Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.1.2.1" *** *)
a(list_spec_nth_asm_tac 12 [¨… aÆ, ¨xÆ] THEN all_var_elim_asm_tac1);
a(∂_tac ¨a'''Æ THEN ∂_tac ¨a'Æ THEN REPEAT strip_tac);
a(bc_thm_tac dy_times_mono_thm1);
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.1.2.2" *** *)
a(bc_thm_tac dy_less_trans_thm THEN ∂_tac¨a dy_times bÆ THEN REPEAT strip_tac);
a(rewrite_tac[dy_times_assoc_thm]);
a(bc_thm_tac dy_times_mono_thm THEN REPEAT strip_tac);
(*
=TEX
\subsection{Commutativity}

Subgoal 2.2.2: commutativity: the operator $pld$ is commutative and this immediately
implies that $pl$ is commutative.
=SML
*)
(* *** Goal "2.2.2" *** *)
a(GET_NTH_ASM_T 3 rewrite_thm_tac);
a(LEMMA_T ¨µ A B∑ A pld B = B pld AÆ (rewrite_thm_tac o µ_elim ¨i xÆ));
a(asm_rewrite_tac[] THEN PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.2.2.1" (and (2.2.2.2")) *** *)
a(∂_tac¨bÆ THEN ∂_tac¨aÆ THEN once_rewrite_tac[dy_times_comm_thm] THEN REPEAT strip_tac);
(*
=TEX
\subsection{Unit Property}

Subgoal 2.2.3: unit property: the operator $pld$ will not in general have a unit.
However, the unit exists ``up to a supremum'' for the sets that represent real numbers.
=SML
*)
(* *** Goal "2.2.3" *** *)
a(LIST_GET_NTH_ASM_T[1, 3] rewrite_tac);
a(LEMMA_T ¨µ x∑ i x pld i(… dy_one) = i xÆ rewrite_thm_tac
	THEN_LIST[id_tac, GET_NTH_ASM_T 2 rewrite_thm_tac]);
a(asm_rewrite_tac[] THEN PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.2.3.1" *** *)
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨… aÆ THEN REPEAT strip_tac);
a(asm_rewrite_tac[] THEN bc_thm_tac dy_less_trans_thm THEN
	∂_tac¨a dy_times bÆ THEN REPEAT strip_tac);
a(LEMMA_T ¨a dy_times b dy_less a dy_times dy_oneÆ ante_tac
	THEN_LIST[id_tac, rewrite_tac[dy_times_unit_thm]]);
a(bc_thm_tac dy_times_mono_thm THEN REPEAT strip_tac);
(* *** Goal "2.2.3.2" *** *)
a(list_spec_nth_asm_tac 8 [¨… x'Æ, ¨xÆ] THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a(all_fc_tac[dy_left_dense_thm]);
a(∂_tac¨a'Æ THEN ∂_tac¨zÆ THEN REPEAT strip_tac);
a(LEMMA_T¨a' dy_times z dy_less a' dy_times dy_oneÆ ante_tac THEN1
	(asm_rewrite_tac[dy_times_unit_thm]));
a(rewrite_tac[dy_times_mono_§_thm]);
(*
=TEX
\subsection{Existence of $one$}

Subgoal 2.2.4: existence of $one$. 
=SML
*)
(* *** Goal "2.2.4" *** *)
a(strip_asm_tac(µ_elim¨dy_oneÆdy_balance_thm1));
a(∂_tac¨…(dy_one dy_times y)Æ THEN asm_rewrite_tac[]);
(*
=TEX
\subsection{Lemma for Inverses and Ordering}


Subgoal 2.2.5: inverses and ordering: these will share a lemma.
The lemma says that given any real $x$ and any positive dyadic rational $d$
we can trap $x$ between two dyadic rationals that differ by $d$.
This is where the archimedean property comes into action.
=SML
*)
(* *** Goal "2.2.5" *** *)
a(lemma_tac¨ µx:Ø; d : DYADIC∑
	dy_one dy_less d ¥ ∂a∑ … a < x ± x < …(a dy_times d)Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.5.1" *** *)
a(lemma_tac¨∂c∑… c < xÆ);
(* *** Goal "2.2.5.1.1" *** *)
a(strip_asm_tac(µ_elim¨xÆØ_unbounded_below_thm));
a(list_spec_nth_asm_tac 9 [¨yÆ, ¨xÆ] THEN all_var_elim_asm_tac1);
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2.5.1.2" *** *)
a(lemma_tac¨∂e∑x < … eÆ);
(* *** Goal "2.2.5.1.2.1" *** *)
a(strip_asm_tac(µ_elim¨xÆØ_unbounded_above_thm));
a(list_spec_nth_asm_tac 10 [¨xÆ, ¨yÆ] THEN all_var_elim_asm_tac1);
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2.5.1.2.2" *** *)
a(lemma_tac ¨∂m∑
	…(c dy_times d dy_exp m) < x ±
	≥ …(c dy_times d dy_exp (m+1)) < xÆ);
(* *** Goal "2.2.5.1.2.2.1" *** *)
a(bc_thm_tac (rewrite_rule[](µ_elim ¨
	Ãm∑…(c dy_times d dy_exp m) < xÆ plus_exists_lemma2)));
a(asm_rewrite_tac[dy_exp_clauses, dy_times_unit_thm]);
a(lemma_tac ¨∂m∑ … e < …(c dy_times d dy_exp m)Æ THEN1 asm_rewrite_tac[]);
(* *** Goal "2.2.5.1.2.2.1.1" *** *)
a(ALL_FC_T (MAP_EVERY ante_tac) [Ø_less_trans_thm]);
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(all_fc_tac[plus_exists_lemma7]);
a(∂_tac¨mÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.5.1.2.2.1.2" *** *)
a(∂_tac¨mÆ THEN contr_tac);
a(LEMMA_T ¨x < xÆ (strip_asm_tac o rewrite_rule[Ø_less_irrefl_thm]));
a(all_fc_tac[Ø_less_trans_thm] THEN all_fc_tac[Ø_less_trans_thm]);
(* *** Goal "2.2.5.1.2.2.2" *** *)
a(lemma_tac¨ ∂b∑ … b < x ± x º …(b dy_times d)Æ);
(* *** Goal "2.2.5.1.2.2.2.1" *** *)
a(∂_tac¨c dy_times d dy_exp mÆ THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac);
a(rewrite_tac[Ø_º_≥_less_thm, dy_exp_clauses, dy_times_assoc_thm]);
(* *** Goal "2.2.5.1.2.2.2.2" *** *)
a(list_spec_nth_asm_tac 14 [¨… bÆ, ¨xÆ] THEN all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a(∂_tac¨a'Æ THEN REPEAT strip_tac);
a(lemma_tac¨… (b dy_times d) < … (a' dy_times d)Æ THEN1
	(asm_rewrite_tac[µ_elim¨dÆdy_times_order_thm, dy_times_mono_§_thm]));
a(all_fc_tac[Ø_º_less_trans_thm]);
(*
=TEX
\subsection{Inverses}

Subgoal 2.2.5.2: inverses: we haven't much choice here but to construct
the inverse as a supremum of an appropriate set.
=SML
*)
(* *** Goal "2.2.5.2" *** *)
a(lemma_tac¨∂Y∑Y = {z | ∂b∑ (µa∑… a < x ¥ a dy_times b dy_less dy_one) ± z º … b}Æ
	THEN1 prove_∂_tac);
a(lemma_tac¨≥Y = {}Æ);
(* *** Goal "2.2.5.2.1" *** *)
a(POP_ASM_T rewrite_thm_tac THEN PC_T1 "sets_ext" REPEAT strip_tac);
a(lemma_tac¨∂c∑ x < … cÆ);
(* *** Goal "2.2.5.2.1.1" *** *)
a(strip_asm_tac(µ_elim¨xÆØ_unbounded_above_thm));
a(list_spec_nth_asm_tac 9 [¨xÆ, ¨yÆ] THEN all_var_elim_asm_tac1);
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2.5.2.1.2" *** *)
a(strip_asm_tac(µ_elim¨cÆplus_exists_lemma8));
a(∂_tac¨… bÆ THEN rewrite_tac[]);
a(∂_tac¨bÆ THEN rewrite_tac[get_spec¨$ºâRÆ]);
a(REPEAT strip_tac);
a(ALL_FC_T (MAP_EVERY ante_tac) [Ø_less_trans_thm]);
a(asm_rewrite_tac[]);
(* *** Goal "2.2.5.2.2" *** *)
a(LEMMA_T¨∂r∑µt∑ t ç Y ¥ t º rÆ asm_tac);
(* *** Goal "2.2.5.2.2.1" *** *)
a(lemma_tac¨∂c∑… c < xÆ);
(* *** Goal "2.2.5.2.2.1.1" *** *)
a(strip_asm_tac(µ_elim¨xÆØ_unbounded_below_thm));
a(list_spec_nth_asm_tac 11 [¨yÆ, ¨xÆ] THEN all_var_elim_asm_tac1);
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2.5.2.2.1.2" *** *)
a(lemma_tac¨∂d∑dy_one dy_less c dy_times dÆ THEN1
	(strip_asm_tac(µ_elim¨cÆ dy_balance_thm1) THEN contr_tac THEN all_asm_fc_tac[]));
a(asm_rewrite_tac[] THEN ∂_tac¨… dÆ THEN REPEAT strip_tac);
a(rewrite_tac[Ø_º_≥_less_thm] THEN contr_tac);
a(LIST_GET_NTH_ASM_T [3] all_fc_tac);
a(ALL_FC_T (MAP_EVERY ante_tac)[Ø_less_º_trans_thm]);
a(asm_rewrite_tac[]);
a(ALL_FC_T (MAP_EVERY ante_tac)[dy_less_trans_thm]);
a(rewrite_tac[dy_times_mono_§_thm]);
a(strip_tac THEN all_fc_tac[dy_less_antisym_thm]);
(* *** Goal "2.2.5.2.2.2" *** *)
a(∂_tac¨Sup YÆ THEN LEMMA_T¨µa∑… a = s {c | c dy_less a}Æ rewrite_thm_tac);
(* *** Goal "2.2.5.2.2.2.1" *** *)
a(strip_tac THEN lemma_tac ¨{c|c dy_less a} = i(… a)Æ THEN1 asm_rewrite_tac[]);
a(LIST_GET_NTH_ASM_T[1, 7] rewrite_tac);
(* *** Goal "2.2.5.2.2.2.2" *** *)
a(GET_NTH_ASM_T 7 rewrite_thm_tac);
a(LEMMA_T ¨i x pld i (Sup Y) = {c|c dy_less dy_one}Æ rewrite_thm_tac);
a(LIST_GET_NTH_ASM_T [10, 8] rewrite_tac THEN PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.2.5.2.2.2.2.1" *** *)
a(ante_tac (µ_elim¨YÆ Ø_less_sup_thm) THEN asm_rewrite_tac[]);
a(STRIP_T (fn th => fc_tac[th]));
a(DROP_NTH_ASM_T 2 ante_tac THEN GET_NTH_ASM_T 7 rewrite_thm_tac THEN REPEAT strip_tac);
a(spec_nth_asm_tac 2 ¨aÆ);
a(bc_thm_tac dy_less_trans_thm THEN ∂_tac ¨a dy_times bÆ THEN REPEAT strip_tac);
a(bc_thm_tac dy_less_trans_thm THEN ∂_tac ¨a dy_times b'Æ THEN REPEAT strip_tac);
a(ALL_FC_T (MAP_EVERY ante_tac) [Ø_less_º_trans_thm]);
a(asm_rewrite_tac[] THEN strip_tac THEN asm_rewrite_tac[dy_times_mono_§_thm]);
(* *** Goal "2.2.5.2.2.2.2.2" *** *)
a(strip_asm_tac (list_µ_elim [¨x'Æ, ¨dy_oneÆ] plus_exists_lemma11));
a(list_spec_nth_asm_tac 8 [¨xÆ, ¨cÆ]);
a(list_spec_nth_asm_tac 10 [¨Sup YÆ, ¨cÆ]);
a(cases_tac¨dy_one dy_less a dy_times a' dy_times c dy_times cÆ);
(* *** Goal "2.2.5.2.2.2.2.2.1" *** *)
a(∂_tac¨aÆ THEN ∂_tac ¨a'Æ THEN REPEAT strip_tac);
a(LEMMA_T¨x' dy_times c dy_times c dy_less a dy_times a' dy_times c dy_times cÆ ante_tac
	THEN1 all_fc_tac [dy_less_trans_thm]);
a(rewrite_tac[µ_elim¨cÆdy_times_order_thm, dy_times_mono_§_thm]);
(* *** Goal "2.2.5.2.2.2.2.2.2" *** *)
a(i_contr_tac THEN lemma_tac¨… (a' dy_times c) ç YÆ);
(* *** Goal "2.2.5.2.2.2.2.2.2.1" *** *)
a(asm_rewrite_tac[]);
a(∂_tac¨(a' dy_times c)Æ THEN rewrite_tac[get_spec¨$ºâRÆ]);
a(REPEAT strip_tac);
a(LEMMA_T¨… a'' < … (a dy_times c)Æ ante_tac THEN1 all_fc_tac[Ø_less_trans_thm]);
a(asm_rewrite_tac[] THEN strip_tac);
a(lemma_tac¨a'' dy_times a' dy_less a dy_times a' dy_times cÆ THEN1
	asm_rewrite_tac[µ_elim¨a'Ædy_times_order_thm, dy_times_mono_§_thm]);
a(swap_nth_asm_concl_tac 4);
a(bc_thm_tac plus_exists_lemma4 THEN ∂_tac¨a'' dy_times a' dy_times cÆ
	THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 ante_tac THEN rewrite_tac[µ_elim¨cÆdy_times_order_thm, dy_times_mono_§_thm]);
(* *** Goal "2.2.5.2.2.2.2.2.2.2" *** *)
a(DROP_NTH_ASM_T 11 strip_asm_tac);
a(strip_asm_tac (list_µ_elim[¨YÆ, ¨rÆ]Ø_sup_thm) THEN1 all_asm_fc_tac[]);
a(LIST_GET_NTH_ASM_T [2] (ALL_FC_T (MAP_EVERY ante_tac)));
a(asm_rewrite_tac[Ø_º_≥_less_thm]);
(*
=TEX
\subsection{Ordering Property}

Subgoal 2.2.5.3: ordering property: we first prove that the less-than relation on
the reals corresponds to the subset relation on the cuts:

=SML
*)
(* *** Goal "2.2.5.3" *** *)
a(LEMMA_T ¨µx y∑ x < y § i x † i yÆ rewrite_thm_tac);
(* *** Goal "2.2.5.3.1" *** *)
a(asm_rewrite_tac[] THEN PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.2.5.3.1.1" *** *)
a(all_fc_tac[Ø_less_trans_thm]);
(* *** Goal "2.2.5.3.1.2" *** *)
a(list_spec_nth_asm_tac 10 [¨xÆ, ¨y'Æ] THEN all_var_elim_asm_tac1);
a(∂_tac¨a'Æ THEN REPEAT strip_tac);
a(contr_tac THEN all_fc_tac[Ø_less_antisym_thm]);
(* *** Goal "2.2.5.3.1.3" *** *)
a(lemma_tac¨x º … x'Æ THEN1 asm_rewrite_tac[Ø_º_≥_less_thm]);
a(all_fc_tac[Ø_º_less_trans_thm]);
(* *** Goal "2.2.5.3.2" *** *)
a(LIST_GET_NTH_ASM_T [2, 3, 5] rewrite_tac);
a(PC_T1 "sets_ext" asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.2.5.3.2.1" *** *)
a(∂_tac¨aÆ THEN ∂_tac¨bÆ THEN REPEAT strip_tac THEN all_fc_tac[Ø_less_trans_thm]);
(* *** Goal "2.2.5.3.2.2" *** *)
a(lemma_tac¨∂c d∑dy_one dy_less d ± y < … c ± …(c dy_times d) < zÆ);
(* *** Goal "2.2.5.3.2.1.1" *** *)
a(list_spec_nth_asm_tac 9 [¨yÆ, ¨zÆ] THEN all_var_elim_asm_tac1);
a(list_spec_nth_asm_tac 11 [¨… a'Æ, ¨zÆ] THEN all_var_elim_asm_tac1);
a(GET_NTH_ASM_T 2 ante_tac THEN GET_NTH_ASM_T 14 rewrite_thm_tac THEN strip_tac);
a(all_fc_tac[plus_exists_lemma9]);
a(∂_tac¨a'Æ THEN ∂_tac¨cÆ THEN asm_rewrite_tac[]);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨… a''Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.5.3.2.2.2" *** *)
a(list_spec_nth_asm_tac 5 [¨xÆ, ¨dÆ]);
a(∂_tac¨a dy_times c dy_times dÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.5.3.2.2.2.1" *** *)
a(contr_tac THEN lemma_tac¨… a' < …(a dy_times d)Æ THEN1 all_fc_tac[Ø_less_trans_thm]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[] THEN contr_tac);
a(LEMMA_T  ¨a dy_times c dy_times d dy_less a dy_times c dy_times dÆ
	(strip_asm_tac o rewrite_rule[dy_less_irrefl_thm]));
a(bc_thm_tac dy_less_trans_thm THEN ∂_tac¨a' dy_times bÆ THEN REPEAT strip_tac);
a(LEMMA_T¨a' dy_times b dy_less (a dy_times d) dy_times bÆ
	(strip_asm_tac o rewrite_rule[dy_times_assoc_thm]) THEN1
	(once_rewrite_tac[dy_times_comm_thm] THEN asm_rewrite_tac[dy_times_mono_§_thm]));
a(bc_thm_tac dy_less_trans_thm THEN ∂_tac¨a dy_times d dy_times bÆ THEN REPEAT strip_tac);
a(rewrite_tac[dy_times_mono_§_thm]);
a(rewrite_tac[µ_elim¨dÆdy_times_order_thm, dy_times_mono_§_thm]);
a(LEMMA_T¨… b < … cÆ ante_tac THEN_LIST[all_fc_tac[Ø_less_trans_thm], asm_rewrite_tac[]]);
(* *** Goal "2.2.5.3.2.2.2.2" *** *)
a(list_spec_nth_asm_tac 14 [¨… (c dy_times d)Æ, ¨zÆ] THEN all_var_elim_asm_tac1);
a(∂_tac¨aÆ THEN ∂_tac¨a''Æ THEN REPEAT strip_tac);
a(rewrite_tac[dy_times_mono_§_thm]);
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[]);
declare_nonfix"pl";
declare_nonfix"pld";
pop_thm()
);
=TEX
=SML
val _ = (
push_consistency_goal¨$+âRÆ;
a(strip_asm_tac Ø_plus_exists_thm);
a(∂_tac¨(pl, zero, one)Æ THEN all_asm_ante_tac THEN taut_tac);
save_consistency_thm¨$+âRÆ (pop_thm())
);
=TEX
=SML
val €Ø_plus_def› = get_spec¨$+âRÆ;
=TEX
=SML
val €Ø_subtract_def› = get_spec¨$-âRÆ;
=TEX
=SML
val €ÓØ_def› = get_spec¨ÓØÆ;
=TEX
=SML
val €Ø_less_def› = get_spec¨$<âRÆ;
=TEX
=SML
val €Ø_º_def› = get_spec¨$ºâRÆ;
=TEX
=SML
val €Ø_less_def› = get_spec¨$<âRÆ;
=TEX
=SML
val €Ø_greater_def› = get_spec¨$>âRÆ;
=TEX
=SML
val €Ø_æ_def› = get_spec¨$æâRÆ;
=TEX
=SML
val _ = (
push_consistency_goal¨$~âRÆ;
a(strip_asm_tac Ø_plus_def);
a(prove_∂_tac);
save_consistency_thm¨$~âRÆ (pop_thm())
);
=TEX
=SML
val €Ø_minus_def› = get_spec¨~âRÆ;
=TEX
\section{SYNTAX FUNCTIONS}

=SML
end (* of structure Ø part 3 *);
structure €Ø› (* : Ø *) = struct
open Ø;
=TEX


=SML
val €minus› = (fst o dest_app) ¨~ (ÓØ 42)Æ;
val €minusn› = (fst o dest_const) minus;
val €Øabs› = (fst o dest_app) ¨Abs (ÓØ 42)Æ;
val €Øabsn› = (fst o dest_const) Øabs;
val €Ørecip› = (fst o dest_app) ¨(ÓØ 42)õ-õ1Æ;
val €Ørecipn› = (fst o dest_const) Ørecip;
val €ÓØ› = (fst o dest_app) ¨ÓØ 42Æ;
val €ÓØn› = (fst o dest_const) ÓØ;
=TEX
=TEX
=SML
val €dest_Ø_less› = dest_bin_op "dest_Ø_less" 116101 (fst(dest_const ¨$<âRÆ));
val €dest_Ø_º› = dest_bin_op "dest_Ø_º" 116102 (fst(dest_const ¨$ºâRÆ));
val €dest_Ø_greater› = dest_bin_op "dest_Ø_greater" 116103 (fst(dest_const ¨$>âRÆ));
val €dest_Ø_æ› = dest_bin_op "dest_Ø_æ" 116104 (fst(dest_const ¨$æâRÆ));
val €dest_Ø_plus› = dest_bin_op "dest_Ø_plus" 116105 (fst(dest_const ¨$+âRÆ));
val €dest_Ø_subtract› = dest_bin_op "dest_Ø_subtract" 116106 (fst(dest_const ¨$-âRÆ));
val €dest_Ø_times› = dest_bin_op "dest_Ø_times" 116107 (fst(dest_const ¨$*âRÆ));
val €dest_Ø_over› = dest_bin_op "dest_Ø_over" 116108 (fst(dest_const ¨$/âRÆ));
val €dest_Ø_frac› = dest_bin_op "dest_Ø_frac" 116109 (fst(dest_const ¨$/âNÆ));
val €dest_Ø_Ó_exp› = dest_bin_op "dest_Ø_Ó_exp" 116114 (fst(dest_const ¨$^âNÆ));
=TEX
=SML
fun €dest_Ø_minus› (tm : TERM) : TERM = (
	let	val (sgn, a) = dest_app tm;
		val (s, _) = dest_const sgn;
	in	if s = minusn then a
			else term_fail "dest_Ø_minus" 116110 [tm]
	end	handle Fail _ => term_fail "dest_Ø_minus" 116110 [tm]
);
=TEX
=SML
fun €dest_Ø_abs› (tm : TERM) : TERM = (
	let	val (sgn, a) = dest_app tm;
		val  (s,_) = dest_const sgn;
	in	if s = Øabsn then a
			else term_fail "dest_Ø_abs" 116111 [tm]
	end	handle Fail _ => term_fail "dest_Ø_abs" 116111 [tm]
);
=TEX
=SML
fun €dest_Ø_recip› (tm : TERM) : TERM = (
	let	val (sgn, a) = dest_app tm;
		val (s, _) = dest_const sgn;
	in	if s = Ørecipn then a
			else term_fail "dest_Ø_recip" 116113 [tm]
	end	handle Fail _ => term_fail "dest_Ø_recip" 116113 [tm]
);
=TEX
=SML
fun €dest_ÓØ› (tm : TERM) : TERM = (
	let	val (sgn, a) = dest_app tm;
		val (s, _) = dest_const sgn;
	in	if s = ÓØn then a
			else term_fail "dest_ÓØ" 116115 [tm]
	end	handle Fail _ => term_fail "dest_ÓØ" 116115 [tm]
);
=TEX
=SML
val €is_Ø_º› = is_bin_op (fst(dest_const ¨$ºâRÆ));
val €is_Ø_æ› = is_bin_op (fst(dest_const ¨$æâRÆ));
val €is_Ø_less› = is_bin_op (fst(dest_const ¨$<âRÆ));
val €is_Ø_greater› = is_bin_op (fst(dest_const ¨$>âRÆ));
val €is_Ø_plus› = is_bin_op (fst(dest_const ¨$+âRÆ));
val €is_Ø_subtract› = is_bin_op (fst(dest_const ¨$-âRÆ));
val €is_Ø_times› = is_bin_op (fst(dest_const ¨$*âRÆ));
val €is_Ø_over› = is_bin_op (fst(dest_const ¨$/âRÆ));
val €is_Ø_frac› = is_bin_op (fst(dest_const ¨$/âNÆ));
val €is_Ø_Ó_exp› = is_bin_op (fst(dest_const ¨$^âNÆ));
=TEX
=SML
fun €is_Ø_minus› (tm : TERM) : bool = (
	(dest_Ø_minus tm; true) handle Fail _ => false
);
=TEX
=SML
fun €is_Ø_abs› (tm : TERM) : bool = (
	(dest_Ø_abs tm; true) handle Fail _ => false
);
=TEX
=SML
fun €is_Ø_recip› (tm : TERM) : bool = (
	(dest_Ø_recip tm; true) handle Fail _ => false
);
=TEX
=SML
fun €is_ÓØ› (tm : TERM) : bool = (
	(dest_ÓØ tm; true) handle Fail _ => false
);
=TEX

=SML
fun €mk_Ø_simple_bin_op› (tm : TERM) : TERM * TERM -> TERM = (fn (a1, a2) =>
	mk_app(mk_app(tm, a1), a2)
);
=TEX
=SML
val Ø_ty = îØÆ;
fun €mk_Ø_bin_op› (area : string) (tm : TERM) : (TERM * TERM) -> TERM = (
	let val f = mk_Ø_simple_bin_op tm;
	in (fn tt as (t1, t2) => (
		if	type_of t1 =: Ø_ty
		then 	if	type_of t2 =: Ø_ty
			then	f tt
			else term_fail area 116201 [t2]
		else	term_fail area 116201 [t1]
	))
	end
);
=TEX
=SML
val €mk_Ø_º› = mk_Ø_bin_op "mk_Ø_º" ¨$ºâRÆ;
val €mk_Ø_æ› = mk_Ø_bin_op "mk_Ø_æ" ¨$æâRÆ;
val €mk_Ø_less› = mk_Ø_bin_op "mk_Ø_less" ¨$<âRÆ;
val €mk_Ø_greater› = mk_Ø_bin_op "mk_Ø_greater" ¨$>âRÆ;
val €mk_Ø_plus› = mk_Ø_bin_op "mk_Ø_plus" ¨$+âRÆ;
val €mk_Ø_subtract› = mk_Ø_bin_op "mk_Ø_subtract" ¨$-âRÆ;
val €mk_Ø_times› = mk_Ø_bin_op "mk_Ø_times" ¨$*âRÆ;
val €mk_Ø_over› = mk_Ø_bin_op "mk_Ø_over" ¨$/âRÆ;
val €mk_Ø_frac› = mk_Ø_bin_op "mk_Ø_frac" ¨$/âNÆ;

=TEX
=SML
val Ó_ty = îÓÆ;
fun €mk_Ó_bin_op› (area : string) (tm : TERM) : (TERM * TERM) -> TERM = (
	let val f = mk_Ø_simple_bin_op tm;
	in (fn tt as (t1, t2) => (
		if	type_of t1 =: Ó_ty
		then 	if	type_of t2 =: Ó_ty
			then	f tt
			else term_fail area 116202 [t2]
		else	term_fail area 116202 [t1]
	))
	end
);
val €mk_Ø_frac› = mk_Ó_bin_op "mk_Ø_frac" ¨$/âNÆ;
=TEX
=SML
fun €mk_Ø_Ó_bin_op› (area : string) (tm : TERM) : (TERM * TERM) -> TERM = (
	let val f = mk_Ø_simple_bin_op tm;
	in (fn tt as (t1, t2) => (
		if	type_of t1 =: Ø_ty
		then 	if	type_of t2 =: Ó_ty
			then	f tt
			else term_fail area 116202 [t2]
		else	term_fail area 116201 [t1]
	))
	end
);
=TEX
=SML
val €mk_Ø_Ó_exp› = mk_Ø_Ó_bin_op "mk_Ø_Ó_exp" ¨$^âNÆ;
=TEX
=SML
fun €mk_Ø_minus› (tm : TERM) : TERM = (
	if type_of tm =: îØÆ then mk_app (minus, tm)
			else term_fail "mk_Ø_minus" 116201 [tm]
);
=TEX
=SML
fun €mk_Ø_abs› (tm : TERM) : TERM = (
	if type_of tm =: îØÆ then mk_app (Øabs, tm)
			else term_fail "mk_Ø_abs" 116201 [tm]
);
=TEX
=SML
fun €mk_Ø_recip› (tm : TERM) : TERM = (
	if type_of tm =: îØÆ then mk_app (Ørecip, tm)
			else term_fail "mk_Ø_abs" 116201 [tm]
);
=TEX
=SML
fun €mk_ÓØ› (tm : TERM) : TERM = (
	if type_of tm =: îÓÆ then mk_app (ÓØ, tm)
			else term_fail "mk_ÓØ" 116202 [tm]
);
=TEX
\section{THEOREMS ABOUT ADDITION AND ORDER}
In this section we prove theorems of general utility about the addition and
ordering of the real numbers.
=SML
end (* of structure Ø part 4 *);
structure €Ø› (* : Ø *) = struct
open Ø;
=TEX
=TEX
=SML
val [	€Ø_plus_assoc_thm›,
	€Ø_plus_comm_thm›,
	€Ø_plus_unit_thm›,
	_, 
	€Ø_plus_mono_thm›,
	_ ] = strip_±_rule Ø_plus_def;
val €Ø_plus_assoc_thm1› = conv_rule (ONCE_MAP_C eq_sym_conv) Ø_plus_assoc_thm;
val €Ø_plus_mono_thm1› = once_rewrite_rule[Ø_plus_comm_thm] Ø_plus_mono_thm;
val _ = save_thm("Ø_plus_assoc_thm", Ø_plus_assoc_thm);
val _ = save_thm("Ø_plus_comm_thm", Ø_plus_comm_thm);
val _ = save_thm("Ø_plus_unit_thm", Ø_plus_unit_thm);
val _ = save_thm("Ø_plus_mono_thm", Ø_plus_mono_thm);
val _ = save_thm("Ø_plus_assoc_thm1", Ø_plus_assoc_thm1);
val _ = save_thm("Ø_plus_mono_thm1", Ø_plus_mono_thm1);

=TEX
=SML
val €Ø_plus_mono_thm2› = (
set_goal([], ¨µx y s t:Ø∑ x < y ± s < t ¥ x + s < y + tÆ);
a(REPEAT strip_tac THEN bc_thm_tac Ø_less_trans_thm);
a(∂_tac ¨x + tÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ø_plus_mono_thm THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(bc_thm_tac Ø_plus_mono_thm1 THEN REPEAT strip_tac);
save_pop_thm"Ø_plus_mono_thm2"
);
=TEX
=SML
val €Ø_plus_0_thm› = (
set_goal([], ¨µx:Ø∑ x + ÓØ 0 = x ± ÓØ 0 + x = xÆ);
a(rewrite_tac[get_spec¨ÓØÆ, Ø_plus_unit_thm, µ_elim¨0âRÆ Ø_plus_comm_thm]);
save_pop_thm"Ø_plus_0_thm"
);
=TEX
=SML
val €Ø_0_1_thm› = (
set_goal([], ¨0âR = ÓØ 0 ± 1âR = ÓØ 1Æ);
a(pure_once_rewrite_tac[prove_rule [] ¨1 = 0 + 1Æ]);
a(pure_rewrite_tac[get_spec¨ÓØÆ]);
a(rewrite_tac[µ_elim¨0âRÆ Ø_plus_comm_thm, Ø_plus_unit_thm]);
save_pop_thm"Ø_0_1_thm"
);
=TEX
=SML
val €Ø_plus_order_thm› = (
set_goal([], ¨µx y z:Ø∑
	y + x = x + y
±	(x + y) + z = x + y + z
±	y + x + z = x + y + z	Æ);
a(REPEAT µ_tac THEN rewrite_tac[Ø_plus_assoc_thm]);
a(rewrite_tac[µ_elim¨yÆ Ø_plus_comm_thm, Ø_plus_assoc_thm]);
save_pop_thm"Ø_plus_order_thm"
);
=TEX
=SML
val €Ø_plus_minus_thm› = (
set_goal([], ¨µ x : Ø ∑ x + ~ x = ÓØ 0 ± ~x + x = ÓØ 0Æ);
a(µ_tac);
a(rewrite_tac[µ_elim¨xÆ Ø_plus_order_thm]);
a(rewrite_tac[ÓØ_def, Ø_minus_def]);
save_pop_thm"Ø_plus_minus_thm"
);
=TEX
=SML
val €Ø_eq_thm› = (
set_goal([], ¨µ x y : Ø ∑ x = y § x + ~y = ÓØ 0Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[Ø_plus_minus_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨(x + ~ y) + y = ÓØ 0 + yÆ ante_tac THEN1 asm_rewrite_tac[]);
a(rewrite_tac[Ø_plus_assoc_thm, Ø_plus_minus_thm, Ø_plus_0_thm]);
save_pop_thm"Ø_eq_thm"
);
=TEX
=SML
val €ÓØ_plus_homomorphism_thm› = (
set_goal([], ¨µ m n : Ó ∑ ÓØ(m + n) = ÓØ m + ÓØ nÆ);
a(REPEAT strip_tac THEN induction_tac¨n:ÓÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[ÓØ_def, Ø_0_1_thm, Ø_plus_0_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[plus_assoc_thm1, ÓØ_def, Ø_plus_assoc_thm]);
save_pop_thm"ÓØ_plus_homomorphism_thm"
);
=TEX
=SML
val €Ø_minus_clauses› = (
set_goal([], ¨µx y : Ø∑
		~ (~ x) = x
	±	x + ~ x = ÓØ 0
	±	~ x + x = ÓØ 0
	±	~ (x + y) = ~ x + ~ y
	± 	~(ÓØ 0) = (ÓØ 0)Æ);
a(REPEAT µ_tac);
a(rewrite_tac[Ø_plus_minus_thm]);
a(lemma_tac¨µx:Ø∑~(~ x) = xÆ);
(* *** Goal "1" *** *)
a(strip_tac THEN once_rewrite_tac[Ø_eq_thm]);
a(once_rewrite_tac[Ø_plus_comm_thm]);
a(rewrite_tac[Ø_plus_minus_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[] THEN strip_tac);
(* *** Goal "2.1" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[Ø_eq_thm]);
a(asm_rewrite_tac[µ_elim¨~ yÆØ_plus_order_thm]);
a(rewrite_tac[µ_elim¨yÆØ_plus_order_thm, Ø_plus_minus_thm, Ø_plus_0_thm]);
(* *** Goal "2.2" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[Ø_eq_thm]);
a(asm_rewrite_tac[Ø_plus_0_thm]);
save_pop_thm"Ø_minus_clauses"
);
=TEX
=SML
val €Ø_minus_eq_thm› = (
set_goal([], ¨µx y : Ø∑~x = ~y § x = yÆ);
a(REPEAT µ_tac);
a(conv_tac(LEFT_C eq_sym_conv));
a(once_rewrite_tac[Ø_eq_thm]);
a(rewrite_tac[Ø_minus_clauses, µ_elim¨xÆØ_plus_order_thm]);
save_pop_thm"Ø_minus_eq_thm"
);
=TEX
=SML
val €ÓØ_0_less_thm› = (
set_goal([], ¨µm:Ó∑ ÓØ 0  <  ÓØ (m+1) Æ);
a(REPEAT strip_tac THEN lemma_tac¨ÓØ 0 < ÓØ 1Æ);
(* *** Goal "1" *** *)
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) Ø_0_1_thm, Ø_plus_def]);
(* *** Goal "2" *** *)
a(induction_tac¨m:ÓÆ THEN1 asm_rewrite_tac[]);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨ÓØ (m+1)Æ THEN REPEAT strip_tac);
a(rewrite_tac[ÓØ_plus_homomorphism_thm, Ø_plus_assoc_thm]);
a(bc_thm_tac Ø_plus_mono_thm);
a(LEMMA_T ¨ÓØ 1 + ÓØ 0 < ÓØ 1 + ÓØ 1Æ (accept_tac o rewrite_rule[Ø_plus_0_thm]));
a(bc_thm_tac Ø_plus_mono_thm THEN REPEAT strip_tac);
save_pop_thm"ÓØ_0_less_thm"
);
=TEX
=SML
val €ÓØ_one_one_thm› = (
set_goal([], ¨µm n:Ó∑ ÓØ m = ÓØ n § m = nÆ);
a(REPEAT strip_tac THEN_LIST [id_tac, asm_rewrite_tac[]]);
a(strip_asm_tac (rewrite_rule[less_def, º_def](list_µ_elim[¨mÆ, ¨nÆ]less_cases_thm))
	THEN all_var_elim_asm_tac1 THEN all_asm_ante_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[ÓØ_plus_homomorphism_thm, plus_assoc_thm, Ø_plus_assoc_thm, plus_clauses]);
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN once_rewrite_tac[Ø_eq_thm]);
a(rewrite_tac[µ_elim¨~(ÓØ m)Æ Ø_plus_order_thm]);
a(rewrite_tac[Ø_plus_assoc_thm1, Ø_minus_clauses]);
a(rewrite_tac[Ø_plus_0_thm]);
a(once_rewrite_tac[Ø_plus_comm_thm]);
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN contr_tac THEN ante_tac (µ_elim ¨iÆ ÓØ_0_less_thm));
a(asm_rewrite_tac[ÓØ_plus_homomorphism_thm, Ø_less_irrefl_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[ÓØ_plus_homomorphism_thm, plus_assoc_thm, Ø_plus_assoc_thm, plus_clauses]);
a(once_rewrite_tac[Ø_eq_thm]);
a(rewrite_tac[Ø_minus_clauses, µ_elim¨~(ÓØ n)Æ Ø_plus_order_thm]);
a(rewrite_tac[Ø_plus_assoc_thm1, Ø_minus_clauses]);
a(rewrite_tac[Ø_plus_0_thm]);
a(once_rewrite_tac[Ø_plus_comm_thm]);
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN contr_tac THEN ante_tac (µ_elim ¨iÆ ÓØ_0_less_thm));
a(asm_rewrite_tac[ÓØ_plus_homomorphism_thm, Ø_less_irrefl_thm]);
save_pop_thm"ÓØ_one_one_thm"
);
=TEX
=SML
val €Ø_plus_clauses› = (
set_goal([], ¨
	µ x y z∑
	(x + z = y + z § x = y)
±	(z + x = y + z § x = y)
±	(x + z = z + y § x = y)
±	(z + x = z + y § x = y)
±	(x + z = z § x = ÓØ 0)
±	(z + x = z § x = ÓØ 0)
±	(z = z + y § y = ÓØ 0)
±	(z = y + z § y = ÓØ 0)
±	x + ÓØ 0 = x
±	ÓØ 0 + x = x
±	≥ ÓØ 1 = ÓØ 0
±	≥ ÓØ 0 = ÓØ 1
Æ);
a(REPEAT µ_tac);
a(rewrite_tac[Ø_plus_0_thm, ÓØ_one_one_thm, plus_clauses,
	µ_elim¨zÆ Ø_plus_order_thm]);
a(once_rewrite_tac[µ_elim¨z + xÆ Ø_eq_thm]);
a(once_rewrite_tac[µ_elim¨zÆ Ø_eq_thm]);
a(rewrite_tac[Ø_minus_clauses, µ_elim¨~ zÆ Ø_plus_order_thm]);
a(rewrite_tac[Ø_plus_assoc_thm1, Ø_minus_clauses, Ø_plus_0_thm]);
a(once_rewrite_tac[µ_elim¨xÆ Ø_eq_thm]);
a(rewrite_tac[]);
a(conv_tac(LEFT_C eq_sym_conv));
a(once_rewrite_tac[µ_elim¨ÓØ 0Æ Ø_eq_thm]);
a(rewrite_tac[Ø_minus_clauses, Ø_plus_0_thm]);
save_pop_thm"Ø_plus_clauses"
);
=TEX
=SML
val €Ø_less_less_0_thm› = (
set_goal([], ¨µ x y : Ø ∑ x < y § x + ~y < ÓØ 0Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T ¨x + ~y < y + ~yÆ (accept_tac o rewrite_rule[Ø_minus_clauses]));
a(bc_thm_tac Ø_plus_mono_thm1 THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LEMMA_T ¨x + ~y + y < y + ~y + yÆ (accept_tac o rewrite_rule[Ø_minus_clauses, Ø_plus_0_thm]));
a(rewrite_tac[Ø_plus_assoc_thm1]);
a(bc_thm_tac Ø_plus_mono_thm1 THEN asm_rewrite_tac[Ø_minus_clauses]);
save_pop_thm"Ø_less_less_0_thm"
);
=TEX
=SML
val €Ø_less_clauses› = (
set_goal([], ¨
	µ x y z : Ø ∑
	(x + z < y + z § x < y)
±	(z + x < y + z § x < y)
±	(x + z < z + y § x < y)
±	(z + x < z + y § x < y)
±	(x + z < z § x < ÓØ 0)
±	(z + x < z § x < ÓØ 0)
±	(x < z + x § ÓØ 0 < z)
±	(x < x + z § ÓØ 0 < z)
±	≥ x < x
±	ÓØ 0 < ÓØ 1
±	≥ ÓØ 1 < ÓØ 0
Æ);
a(REPEAT µ_tac);
a(strip_asm_tac (rewrite_rule[](µ_elim¨0ÆÓØ_0_less_thm)));
a(all_fc_tac[Ø_less_antisym_thm]);
a(asm_rewrite_tac[Ø_less_irrefl_thm, µ_elim¨zÆ Ø_plus_order_thm]);
a(once_rewrite_tac[µ_elim¨z + xÆ Ø_less_less_0_thm]);
a(once_rewrite_tac[µ_elim¨xÆ Ø_less_less_0_thm]);
a(once_rewrite_tac[µ_elim¨ÓØ 0Æ Ø_less_less_0_thm]);
a(rewrite_tac[Ø_minus_clauses, µ_elim¨~ zÆ Ø_plus_order_thm]);
a(rewrite_tac[Ø_plus_assoc_thm1, Ø_minus_clauses, Ø_plus_0_thm]);
save_pop_thm "Ø_less_clauses"
);
=TEX
=SML
val €Ø_less_0_less_thm› = (
set_goal([], ¨µ x y : Ø ∑ x < y § ÓØ 0 < y + ~xÆ);
a(REPEAT µ_tac THEN once_rewrite_tac[Ø_less_less_0_thm]);
a(rewrite_tac[Ø_plus_clauses, Ø_minus_clauses, µ_elim¨~y:ØÆØ_plus_order_thm]);
save_pop_thm"Ø_less_0_less_thm"
);
=TEX
=SML
val €Ø_º_clauses› = (
set_goal([], ¨
	µ x y z : Ø ∑
	(x + z º y + z § x º y)
±	(z + x º y + z § x º y)
±	(x + z º z + y § x º y)
±	(z + x º z + y § x º y)
±	(x + z º z § x º ÓØ 0)
±	(z + x º z § x º ÓØ 0)
±	(x º z + x § ÓØ 0 º z)
±	(x º x + z § ÓØ 0 º z)
±	x º x
±	ÓØ 0 º ÓØ 1
±	≥ ÓØ 1 º ÓØ 0
Æ);
a(REPEAT µ_tac);
a(rewrite_tac[Ø_º_≥_less_thm, Ø_less_clauses]);
save_pop_thm "Ø_º_clauses"
);
=TEX
=SML
val €Ø_º_º_0_thm› = (
set_goal([], ¨µ x y : Ø ∑ x º y § x + ~y º ÓØ 0Æ);
a(REPEAT µ_tac);
a(rewrite_tac[Ø_º_≥_less_thm]);
a(once_rewrite_tac[Ø_less_less_0_thm]);
a(rewrite_tac[Ø_minus_clauses, Ø_plus_0_thm]);
a(rewrite_tac[µ_elim¨yÆØ_plus_order_thm]);
save_pop_thm"Ø_º_º_0_thm"
);
=TEX
=SML
val €Ø_º_0_º_thm› = (
set_goal([], ¨µ x y : Ø ∑ x º y § ÓØ 0 º y + ~xÆ);
a(REPEAT µ_tac THEN once_rewrite_tac[Ø_º_º_0_thm]);
a(rewrite_tac[Ø_plus_clauses, Ø_minus_clauses, µ_elim¨~y:ØÆØ_plus_order_thm]);
save_pop_thm"Ø_º_0_º_thm"
);
=TEX
=SML
val €ÓØ_less_thm› = (
set_goal([], ¨µ m n: Ó ∑ ÓØ m < ÓØ n § m < nÆ);
a(lemma_tac¨µ m n: Ó ∑ m < n ¥ ÓØ m < ÓØ nÆ);
a(REPEAT µ_tac THEN rewrite_tac[less_def, º_def] THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN rewrite_tac[ÓØ_plus_homomorphism_thm]);
a(rewrite_tac[Ø_plus_assoc_thm, Ø_less_clauses]);
a(ante_tac(µ_elim¨iÆ ÓØ_0_less_thm) THEN rewrite_tac[ÓØ_plus_homomorphism_thm]);
a(REPEAT strip_tac THEN once_rewrite_tac[Ø_plus_comm_thm] THEN strip_tac);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN_LIST [id_tac, all_asm_fc_tac[]]);
a(contr_tac THEN lemma_tac¨m = n ≤ n < mÆ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2.1" *** *)
a(all_var_elim_asm_tac1 THEN all_fc_tac[Ø_less_irrefl_thm]);
(* *** Goal "2.2" *** *)
a(all_asm_fc_tac[] THEN all_fc_tac[Ø_less_antisym_thm]);
save_pop_thm"ÓØ_less_thm"
);
=TEX
=SML
val €Ø_less_strong_dense_thm› = (
set_goal([], ¨µx y : Ø ∑ x < y ¥ ∂d∑ ÓØ 0 < d ± x + d < yÆ);
a(REPEAT strip_tac THEN all_fc_tac[Ø_less_dense_thm]);
a(∂_tac¨z + ~xÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(GET_NTH_ASM_T 2 (strip_asm_tac o once_rewrite_rule[Ø_less_0_less_thm]));
(* *** Goal "2" *** *)
a(asm_rewrite_tac[µ_elim¨zÆ Ø_plus_order_thm, Ø_minus_clauses, Ø_plus_0_thm]);
save_pop_thm"Ø_less_strong_dense_thm"
);
=TEX
=SML
val €ÓØ_º_thm› = (
set_goal([], ¨µ m n: Ó ∑ ÓØ m º ÓØ n § m º nÆ);
a(rewrite_tac[Ø_º_≥_less_thm,
	pc_rule1"lin_arith"prove_rule[]¨µa b:Ó∑ a º b § ≥b < aÆ, ÓØ_less_thm]);
save_pop_thm"ÓØ_º_thm"
);
=TEX
\section{THEOREMS ABOUT SUPREMA AND ADDITION}
=SML
end (* of structure Ø part 5 *);
structure €Ø› (* : Ø *) = struct
open Ø;
=TEX
=SML
val €Ø_sup_plus_thm› = (
set_goal([], ¨µA a x∑
	≥A = {} ± (µx∑x ç A ¥ x º a) ¥ Sup A + x = Sup {t | ∂a∑a ç A ± t < a + x}Æ);
a(REPEAT strip_tac THEN bc_thm_tac Ø_eq_sup_bc_thm THEN
	PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(GET_NTH_ASM_T 2 (PC_T1 "sets_ext" strip_asm_tac));
a(strip_asm_tac(µ_elim¨x' + xÆØ_unbounded_below_thm));
a(∂_tac¨yÆ THEN asm_prove_tac[]);
(* *** Goal "2" *** *)
a(LEMMA_T¨x' + ~x º (Sup A + x) + ~xÆ ante_tac THEN_LIST
	[rewrite_tac[Ø_plus_assoc_thm, Ø_plus_clauses, Ø_minus_clauses],
	 rewrite_tac[Ø_º_clauses]]);
a(bc_thm_tac Ø_º_sup_bc_thm);
a(LEMMA_T ¨∂ a∑ µ x∑ x ç A ¥ x º aÆ asm_rewrite_thm_tac
	THEN1 (∂_tac¨aÆ THEN asm_rewrite_tac[]));
a(REPEAT strip_tac);
a(LEMMA_T¨x' + ~x º (a' + x) + ~xÆ ante_tac THEN1
	(rewrite_tac[Ø_º_clauses] THEN asm_rewrite_tac[Ø_º_def]));
a(rewrite_tac[Ø_plus_assoc_thm, Ø_plus_clauses, Ø_minus_clauses]);
a(strip_tac THEN bc_thm_tac Ø_º_trans_thm THEN ∂_tac¨a'Æ THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(LEMMA_T¨(Sup A + x) + ~x º x' + ~xÆ ante_tac THEN_LIST
	[rewrite_tac[Ø_plus_assoc_thm, Ø_plus_clauses, Ø_minus_clauses],
	 rewrite_tac[Ø_º_clauses]]);
a(bc_thm_tac Ø_sup_º_bc_thm);
a(LEMMA_T ¨∂ a∑ µ x∑ x ç A ¥ x º aÆ asm_rewrite_thm_tac
	THEN1 (∂_tac¨aÆ THEN asm_rewrite_tac[]));
a(REPEAT strip_tac);
a(LEMMA_T¨(y + x) + ~x º x' + ~xÆ ante_tac THEN_LIST
	[rewrite_tac[Ø_º_clauses],
	 rewrite_tac[Ø_plus_assoc_thm, Ø_plus_clauses, Ø_minus_clauses]]);
a(contr_tac THEN POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(strip_asm_tac(list_µ_elim[¨x'Æ, ¨y + xÆ]Ø_less_dense_thm));
a(spec_nth_asm_tac 5 ¨zÆ THEN1 all_asm_fc_tac[]);
a(swap_nth_asm_concl_tac 3 THEN asm_rewrite_tac[Ø_≥_less_º_thm]);
save_pop_thm"Ø_sup_plus_thm"
);
=TEX
=SML
val €Ø_sup_plus_sup_thm› = (
set_goal([], ¨µA a B b∑
	≥A = {} ± (µx∑x ç A ¥ x º a) ±
	≥B = {} ± (µy∑y ç B ¥ y º b)
¥	Sup A + Sup B = Sup {t | ∂a b∑a ç A ± b ç B ± t < a + b}Æ);
a(REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[Ø_sup_plus_thm]);
a(LEMMA_T ¨	{v|∂ a∑ a ç A ± v < a + Sup B}
	=	{t|∂ a b∑ a ç A ± b ç B ± t < a + b}Æ rewrite_thm_tac);
a(PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T¨~a' + x < ~a' + (a' + Sup B)Æ ante_tac THEN_LIST
	[asm_rewrite_tac[Ø_less_clauses],
	rewrite_tac[Ø_plus_assoc_thm1, Ø_plus_clauses, Ø_minus_clauses]] THEN strip_tac);
a(all_fc_tac[Ø_less_sup_thm]);
a(∂_tac¨a'Æ THEN ∂_tac¨yÆ THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN once_rewrite_tac[Ø_less_0_less_thm]);
a(rewrite_tac[Ø_minus_clauses, µ_elim¨yÆ Ø_plus_order_thm]);
(* *** Goal "2" *** *)
a(∂_tac¨a'Æ THEN REPEAT strip_tac);
a(lemma_tac¨b' º Sup BÆ);
(* *** Goal "2.1" *** *)
a(bc_thm_tac Ø_º_sup_bc_thm);
a(LEMMA_T ¨∂ b∑ µ y∑ y ç B ¥ y º bÆ asm_rewrite_thm_tac
	THEN1 (∂_tac¨bÆ THEN asm_rewrite_tac[]));
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(bc_thm_tac Ø_less_º_trans_thm THEN ∂_tac¨a' + b'Æ THEN REPEAT strip_tac);
a(asm_rewrite_tac[Ø_º_clauses]);
save_pop_thm"Ø_sup_plus_sup_thm"
);
=TEX
\section{SOME INDUCTION-LIKE PRINCIPLES}
In preparation for developing the theory of multiplication, we now develop two
induction-like principles.
The first says that if
{\em(i)} a property, $p$, holds in an open interval $(x, \epsilon)$
and {\em(ii)} $0 < \delta < \epsilon$
and {\em(iii)} if $p$ holds at $s +\delta$ whenever it holds at $s$, for$x < s$,
then $p$ holds for every $y > x$.

=SML
end (* of structure Ø part 6 *);
structure €Ø› (* : Ø *) = struct
open Ø;
=TEX

=SML
val €Ø_delta_induction_thm› = (
set_goal([], ¨µx p∑
	(∂d∑ÓØ 0 < d
	±	(∂e∑d < e ± (µt∑x < t ± t < x + e ¥ p t))
	±	(µs∑x < s ± p s ¥ p (s + d)))
	¥ (µy∑x < y ¥ p y)
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂P∑ P = {y | x < y ± µt∑x < t ± t º y ¥ p t}Æ THEN1 prove_∂_tac);
a(lemma_tac¨∂c∑ d < c ± x + c ç PÆ THEN1 (POP_ASM_T rewrite_thm_tac THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a(lemma_tac¨∂c∑d < c ± c < eÆ THEN1
	(contr_tac THEN all_fc_tac[Ø_less_dense_thm] THEN all_asm_fc_tac[]));
a(∂_tac¨cÆ THEN asm_rewrite_tac[Ø_less_clauses] THEN ALL_FC_T rewrite_tac[Ø_less_trans_thm]);
a(REPEAT strip_tac);
a(lemma_tac¨t < x + eÆ THEN_LIST [id_tac, all_asm_fc_tac[]]);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac ¨x + cÆ THEN REPEAT strip_tac);
a(asm_rewrite_tac[Ø_less_clauses]);
(* *** Goal "2" *** *)
a(lemma_tac¨≥ P = {}Æ THEN1
	(PC_T1 "sets_ext" REPEAT strip_tac THEN ∂_tac ¨x + cÆ THEN REPEAT strip_tac));
a(cases_tac¨∂a∑µ x∑ x ç P ¥ x º aÆ);
(* *** Goal "2.1" *** *)
a(lemma_tac¨Sup P + ~d < Sup PÆ THEN1
	(rewrite_tac[Ø_less_clauses] THEN
	 once_rewrite_tac[Ø_less_0_less_thm] THEN asm_rewrite_tac[Ø_plus_0_thm, Ø_minus_clauses]));
a(lemma_tac ¨∂v∑ v ç P ± Sup P + ~d < vÆ THEN1
	(contr_tac THEN all_fc_tac[Ø_less_sup_thm] THEN all_asm_fc_tac[]));
a(lemma_tac¨v + d ç PÆ);
(* *** Goal "2.1.1" *** *)
a(GET_ASM_T ¨v ç PÆ ante_tac THEN GET_NTH_ASM_T 8 rewrite_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2.1.1.1" *** *)
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨vÆ THEN REPEAT strip_tac
	THEN asm_rewrite_tac[Ø_less_clauses]);
(* *** Goal "2.1.1.2" *** *)
a(cases_tac¨t < Sup PÆ);
(* *** Goal "2.1.1.2.1" *** *)
a(LEMMA_T¨∂u∑ t < u ± u ç PÆ ante_tac THEN1
	(contr_tac THEN all_fc_tac[Ø_less_sup_thm] THEN all_asm_fc_tac[]));
a(GET_NTH_ASM_T 13 rewrite_thm_tac THEN rewrite_tac[Ø_º_def] THEN
	REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.1.1.2.2" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
a(lemma_tac¨x < t + ~dÆ);
(* *** Goal "2.1.1.2.2.1" *** *)
a(all_fc_tac[Ø_ç_º_sup_bc_thm]);
a(LEMMA_T¨x + d < (t + ~d) + dÆ (fn th => ante_tac th THEN rewrite_tac[Ø_less_clauses]));
a(rewrite_tac[Ø_plus_assoc_thm, Ø_minus_clauses, Ø_plus_0_thm]);
a(bc_thm_tac Ø_less_º_trans_thm THEN ∂_tac ¨Sup PÆ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_less_º_trans_thm THEN ∂_tac ¨x + cÆ THEN REPEAT strip_tac);
a(asm_rewrite_tac[Ø_less_clauses]);
(* *** Goal "2.1.1.2.2.2" *** *)
a(lemma_tac¨p (t + ~ d)Æ);
(* *** Goal "2.1.1.2.2.2.1" *** *)
a(LEMMA_T¨t + ~d º (v + d) + ~dÆ ante_tac THEN1 asm_rewrite_tac[Ø_º_clauses]);
a(rewrite_tac[Ø_plus_assoc_thm, Ø_minus_clauses, Ø_plus_0_thm] THEN strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "2.1.1.2.2.2.2" *** *)
a(LEMMA_T¨p ((t + ~d) + d)Æ ante_tac THEN1 all_asm_fc_tac[]);
a(rewrite_tac[Ø_plus_assoc_thm, Ø_minus_clauses, Ø_plus_0_thm]);
(* *** Goal "2.1.2" *** *)
a(LEMMA_T ¨(Sup P + ~d) + d < v + dÆ ante_tac THEN1 asm_rewrite_tac[Ø_less_clauses]);
a(rewrite_tac[Ø_plus_assoc_thm, Ø_minus_clauses, Ø_plus_0_thm] THEN strip_tac);
a(lemma_tac ¨v + d º Sup PÆ THEN1 all_fc_tac[Ø_ç_º_sup_bc_thm]);
a(all_fc_tac[Ø_º_less_trans_thm] THEN all_fc_tac[Ø_less_irrefl_thm]);
(* *** Goal "2.2" *** *)
a(spec_nth_asm_tac 1 ¨yÆ);
a(POP_ASM_T ante_tac THEN rewrite_tac[Ø_≥_º_less_thm] THEN strip_tac);
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(lemma_tac ¨y º x'Æ THEN1 asm_rewrite_tac[Ø_º_def]);
a(all_asm_fc_tac[]);
save_pop_thm"Ø_delta_induction_thm"
);
=TEX
=SML
fun €Ø_delta_induction_tac› (tm : TERM) : TACTIC = (
	if not (is_var tm andalso type_of tm =: îØÆ)
	then term_fail "Ø_delta_induction_tac" 116001 [tm]
	else ( fn(asms, conc) =>
	let	val asm = find asms (fn t => is_Ø_less t andalso snd(dest_Ø_less t) =$ tm)
			handle Fail _ => fail "Ø_delta_induction_tac" 116002 [];
		val thm = µ_elim (fst(dest_Ø_less asm)) Ø_delta_induction_thm;
	in	if not (is_free_in tm conc)
			then term_fail "Ø_delta_induction_tac" 116003 [tm]
		else if any (asms drop (fn t => t =$ asm)) (is_free_in tm)
			then term_fail "Ø_delta_induction_tac" 116004 [tm]
		else	(asm_ante_tac asm THEN gen_induction_tac1 thm) (asms, conc)
	end
	)
);
(*
=TEX
Not used --- commented out for the present.

The second induction-like principle is ``proof by continuity'':
if a property, $p$, holds on a dense subset of the reals and if
for every $y$, whenever $x < y$, there is a $z$ between $x$ and $y$
for which $p$ holds then $p$ holds everywhere.
=SML
val €Ø_dense_induction_thm› = (
set_goal([], ¨µp : Ø ≠ BOOL∑
		(µx y∑x < y ¥ ∂z∑ x < z ± z < y ± p z)
	±	(µy∑(µx∑x < y ¥ ∂z∑ x < z ± z < y ± p z) ¥ p y)
	¥	(µx∑p x)
Æ);
a(REPEAT strip_tac);
a(POP_ASM_T bc_thm_tac THEN contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
save_pop_thm"Ø_dense_induction_thm"
);
=SML
val €Ø_dense_induction_tac› = gen_induction_tac Ø_dense_induction_thm;
*)
=TEX
\section{MULTIPLICATION}
Our approach to multiplication is based on order-preserving homomorphisms.
We need a number of lemmas of various degress of difficulty.

\subsection{Order Preserving Mappings}

We show that an order-preserving mapping is strictly order-preserving
in a suitable sense:
=SML
end (* of structure Ø part 7 *);
structure €Ø› (* : Ø *) = struct
open Ø;
=TEX

=SML
val €Ø_ord_pres_strict_thm› = (
set_goal([], ¨µf : Ø ≠ Ø∑
		(µx y∑x < y ¥ f x < f y)
	¥	(µx y∑f x < f y ¥ x < y)
Æ);
a(REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨xÆ, ¨yÆ]Ø_less_cases_thm));
(* *** Goal "1" *** *)
a(all_var_elim_asm_tac THEN all_fc_tac[Ø_less_irrefl_thm]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[] THEN all_fc_tac[Ø_less_antisym_thm]);
save_pop_thm"Ø_ord_pres_strict_thm"
);
=TEX
\subsection{Additive Homomorphisms}
Now we show some elementary properties of homomorphisms
of the additive structure:

A homomorphism maps the unit to itself:

=SML
val €Ø_add_hom_0_thm› = (
set_goal([], ¨µf : Ø ≠ Ø∑
		(µx y∑f (x + y) = f x + f y)
	¥	(µx∑ f (ÓØ 0) = ÓØ 0)
Æ);
a(REPEAT strip_tac);
a(LEMMA_T ¨f (x + ÓØ 0) = f xÆ ante_tac THEN1 rewrite_tac[Ø_plus_clauses]);
a(asm_rewrite_tac[] THEN rewrite_tac[Ø_plus_clauses]);
save_pop_thm"Ø_add_hom_0_thm"
);
=TEX
Homomorphisms commute with the inverse operator:

=SML
val €Ø_add_hom_minus_thm› = (
set_goal([], ¨µf : Ø ≠ Ø∑
		(µx y∑f (x + y) = f x + f y)
	¥	(µx∑ f (~x) = ~ (f x))
Æ);
a(REPEAT strip_tac);
a(LEMMA_T¨f(~x + x) = f (ÓØ 0)Æ ante_tac THEN1 rewrite_tac[Ø_minus_clauses]);
a(ALL_FC_T rewrite_tac[Ø_add_hom_0_thm]);
a(asm_rewrite_tac[] THEN strip_tac);
a(once_rewrite_tac[Ø_eq_thm]);
a(asm_rewrite_tac[Ø_minus_clauses]);
save_pop_thm"Ø_add_hom_minus_thm"
);
=TEX
The following theorem is a labour-saver in proving that a homomorphism defined
by extending a homomorphism of the monoid of non-negative elements is
itself a group homomorphism:
=SML
val €Ø_add_hom_extension_thm› = (
set_goal([], ¨µf : Ø ≠ Ø∑
		(µx y∑ÓØ 0 º x ± ÓØ 0 º y ¥ f (x + y) = f x + f y)
	±	(µx∑ ÓØ 0 º x ¥ f (~x) = ~(f x))
	¥	(µx y∑f (x + y) = f x + f y)
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µv∑f (~v) = ~(f v)Æ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨ÓØ 0Æ, ¨vÆ] Ø_º_cases_thm) THEN1 ALL_ASM_FC_T rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o
	rewrite_rule[Ø_plus_clauses] o once_rewrite_rule[Ø_º_0_º_thm]));
a(spec_nth_asm_tac 2 ¨~vÆ THEN POP_ASM_T ante_tac THEN once_rewrite_tac[Ø_eq_thm]);
a(rewrite_tac[Ø_minus_clauses, µ_elim¨f vÆ Ø_plus_order_thm]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 2 discard_tac);
a(lemma_tac¨µv w∑ÓØ 0 º w ¥ f (v + w) = f v + f wÆ);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨ÓØ 0Æ, ¨vÆ] Ø_º_cases_thm) THEN1 ALL_ASM_FC_T rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o
	rewrite_rule[Ø_plus_clauses] o once_rewrite_rule[Ø_º_0_º_thm]));
a(strip_asm_tac(list_µ_elim[¨ÓØ 0Æ, ¨v + wÆ] Ø_º_cases_thm));
(* *** Goal "2.1.1" *** *)
a(LEMMA_T¨f(~v) + f(v + w) = f(~v + (v + w))Æ ante_tac THEN1 ALL_ASM_FC_T rewrite_tac[]);
a(once_rewrite_tac[Ø_eq_thm]);
a(asm_rewrite_tac[µ_elim¨wÆ Ø_plus_order_thm, µ_elim¨f (v + w)Æ Ø_plus_order_thm,
	Ø_plus_clauses, Ø_minus_clauses, Ø_plus_assoc_thm]);
(* *** Goal "2.1.2" *** *)
a(POP_ASM_T (strip_asm_tac o
	rewrite_rule[Ø_plus_clauses] o once_rewrite_rule[Ø_º_0_º_thm]));
a(LEMMA_T¨f(w + ~(v + w)) = f w + f(~(v + w))Æ ante_tac THEN1 ALL_ASM_FC_T rewrite_tac[]);
a(once_rewrite_tac[Ø_eq_thm]);
a(asm_rewrite_tac[µ_elim¨~vÆ Ø_plus_order_thm, µ_elim¨f (v + w)Æ Ø_plus_order_thm,
	Ø_plus_clauses, Ø_minus_clauses, Ø_plus_assoc_thm]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(list_µ_elim[¨ÓØ 0Æ, ¨yÆ] Ø_º_cases_thm) THEN1 ALL_ASM_FC_T rewrite_tac[]);
a(strip_asm_tac(list_µ_elim[¨ÓØ 0Æ, ¨x + yÆ] Ø_º_cases_thm));
(* *** Goal "2.2.1" *** *)
a(LEMMA_T¨f (~y) + f(x + y) = f(~y + x + y)Æ ante_tac THEN1 ALL_ASM_FC_T rewrite_tac[]);
a(once_rewrite_tac[Ø_eq_thm]);
a(asm_rewrite_tac[µ_elim¨xÆ Ø_plus_order_thm, µ_elim¨f (x + y)Æ Ø_plus_order_thm,
	Ø_plus_clauses, Ø_minus_clauses, Ø_plus_assoc_thm]);
a(rewrite_tac[µ_elim¨~(f y)Æ Ø_plus_order_thm]);
(* *** Goal "2.2.2" *** *)
a(DROP_NTH_ASM_T 2 (strip_asm_tac o
	rewrite_rule[Ø_plus_clauses] o once_rewrite_rule[Ø_º_0_º_thm]));
a(DROP_NTH_ASM_T 2 (strip_asm_tac o
	rewrite_rule[Ø_plus_clauses] o once_rewrite_rule[Ø_º_0_º_thm]));
a(LEMMA_T ¨x + y = ~(~x + ~y)Æ asm_rewrite_thm_tac THEN1 rewrite_tac[Ø_minus_clauses]);
a(LEMMA_T¨f(~x + ~y) = f(~x) + f (~y)Æ asm_rewrite_thm_tac THEN1 ALL_ASM_FC_T rewrite_tac[]);
a(rewrite_tac[Ø_minus_clauses]);
save_pop_thm"Ø_add_hom_extension_thm"
);
=TEX
\subsection{Subgroups, Submonoids and Subsemigroups}

Now using the $\delta$-induction principle, we show that if a submonoid, $G$,
of the reals contains a positive element, then $G$ meets every interval of
positive numbers of width $\delta$.
=SML
val €Ø_monoid_delta_dense_thm› = (
set_goal([], ¨µG d∑
		(ÓØ 0 ç G)
	±	(µg h∑ g ç G ± h ç G ¥ g + h ç G)
	±	d ç G
	±	ÓØ 0 < d
	¥	(µx∑ ÓØ 0 < x ¥ ∂g∑g ç G ± g º x ± x < g + d)
Æ);
a(REPEAT strip_tac);
a(Ø_delta_induction_tac ¨xÆ);
a(∂_tac¨dÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[Ø_less_dense_thm]);
a(∂_tac¨d + zÆ THEN REPEAT strip_tac THEN1 asm_rewrite_tac[Ø_less_clauses]);
a(POP_ASM_T ante_tac THEN  asm_rewrite_tac[Ø_plus_clauses] THEN strip_tac);
a(cases_tac¨t < dÆ);
(* *** Goal "1.1" *** *)
a(∂_tac¨ÓØ 0Æ THEN asm_rewrite_tac[Ø_less_clauses, Ø_plus_clauses, Ø_º_def]);
(* *** Goal "1.2" *** *)
a(POP_ASM_T ante_tac THEN  asm_rewrite_tac[Ø_≥_less_º_thm] THEN strip_tac);
a(∂_tac¨dÆ THEN asm_rewrite_tac[]);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨d + zÆ THEN asm_rewrite_tac[Ø_less_clauses]);
(* *** Goal "2" *** *)
a(lemma_tac¨g + d ç GÆ THEN1 all_asm_fc_tac[]);
a(∂_tac¨g + dÆ THEN asm_rewrite_tac[Ø_less_clauses, Ø_º_clauses]);
save_pop_thm"Ø_monoid_delta_dense_thm"
);
=TEX
Now we show that a monoid which contains arbitrarily small positive elements
is dense in the set of positive elements: 
=SML
val €Ø_monoid_dense_thm› = (
set_goal([], ¨µG∑
		(ÓØ 0 ç G)
	±	(µg h∑ g ç G ± h ç G ¥ g + h ç G)
	±	(µx∑ÓØ 0 < x ¥ ∂g∑ g ç G ± ÓØ 0 < g ± g < x)
	¥	(µx y∑ÓØ 0 < x ± x < y ¥ ∂g∑g ç G ± x < g ± g < y)
Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨ÓØ 0 < y + ~xÆ THEN1
	(POP_ASM_T ante_tac THEN once_rewrite_tac[Ø_less_0_less_thm]
	THEN rewrite_tac[Ø_plus_clauses, Ø_minus_clauses]));
a(spec_nth_asm_tac 4 ¨y + ~xÆ);
a(strip_asm_tac(list_µ_elim[¨GÆ, ¨gÆ]Ø_monoid_delta_dense_thm)
	THEN1 all_asm_fc_tac[]);
a(POP_ASM_T (strip_asm_tac o µ_elim¨xÆ));
a(lemma_tac ¨g' + g ç GÆ THEN1 (GET_NTH_ASM_T 11 bc_thm_tac THEN REPEAT strip_tac));
a(∂_tac¨g' + gÆ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac¨x + gÆ THEN1 asm_rewrite_tac[Ø_º_clauses]);
a(LEMMA_T ¨x + g < x + (y + ~x)Æ ante_tac THEN1 asm_rewrite_tac[Ø_less_clauses]);
a(rewrite_tac[µ_elim¨yÆØ_plus_order_thm, Ø_minus_clauses, Ø_plus_0_thm]);
save_pop_thm"Ø_monoid_dense_thm"
);
=TEX
The analogous result for subgroups:
=SML
val €Ø_subgroup_dense_thm› = (
set_goal([], ¨µG∑
		(ÓØ 0 ç G)
	±	(µg h∑ g ç G ± h ç G ¥ g + h ç G)
	±	(µg∑ g ç G ¥ ~g ç G)
	±	(µx∑ÓØ 0 < x ¥ ∂g∑ g ç G ± ÓØ 0 < g ± g < x)
	¥	(µx y∑x < y ¥ ∂g∑g ç G ± x < g ± g < y)
Æ);
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨GÆ Ø_monoid_dense_thm) THEN1 all_asm_fc_tac[]);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac(list_µ_elim[¨ÓØ 0Æ, ¨xÆ] Ø_less_cases_thm));
(* *** Goal "2.1" *** *)
a(GET_NTH_ASM_T 2 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(all_var_elim_asm_tac1 THEN GET_NTH_ASM_T 3 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2.3" *** *)
a(strip_asm_tac(list_µ_elim[¨yÆ, ¨ÓØ 0Æ] Ø_less_cases_thm));
(* *** Goal "2.3.1" *** *)
a(LIST_DROP_NTH_ASM_T [1, 2, 4] (MAP_EVERY
	(strip_asm_tac o
	 conv_rule (TRY_C (rewrite_conv[Ø_plus_clauses])) o
	 once_rewrite_rule[Ø_less_0_less_thm])));
a(lemma_tac¨~y < ~xÆ);
(* *** Goal "2.3.1.1" *** *)
a(once_rewrite_tac[Ø_less_0_less_thm] THEN once_rewrite_tac[Ø_plus_comm_thm]);
a(asm_rewrite_tac[Ø_minus_clauses]);
(* *** Goal "2.3.1.2" *** *)
a(list_spec_nth_asm_tac 5 [¨~yÆ, ¨~xÆ]);
a(∂_tac ¨~gÆ THEN ALL_ASM_FC_T rewrite_tac[]);
a(LIST_GET_NTH_ASM_T [1, 2] (MAP_EVERY ante_tac));
a(once_rewrite_tac[Ø_less_0_less_thm]);
a(rewrite_tac[Ø_minus_clauses,  µ_elim¨gÆØ_plus_order_thm, µ_elim¨~gÆØ_plus_order_thm]
	THEN taut_tac);
(* *** Goal "2.3.2" *** *)
a(all_var_elim_asm_tac1);
a(DROP_NTH_ASM_T	2 (strip_asm_tac o rewrite_rule[Ø_plus_clauses] o
	 once_rewrite_rule[Ø_less_0_less_thm]));
a(spec_nth_asm_tac 3 ¨~xÆ);
a(∂_tac ¨~gÆ THEN ALL_ASM_FC_T rewrite_tac[]);
a(LIST_GET_NTH_ASM_T [1, 2] (MAP_EVERY ante_tac));
a(once_rewrite_tac[Ø_less_0_less_thm]);
a(rewrite_tac[Ø_minus_clauses,  µ_elim¨gÆØ_plus_order_thm, µ_elim¨~gÆØ_plus_order_thm]
	THEN taut_tac);
(* *** Goal "2.3.3" *** *)
a(∂_tac ¨ÓØ 0Æ THEN REPEAT strip_tac);
save_pop_thm"Ø_subgroup_dense_thm"
);
=TEX
\ldots and for subsemigroups:
=SML
val €Ø_semigroup_dense_thm› = (
set_goal([], ¨µG∑
		(µg h∑ g ç G ± h ç G ¥ g + h ç G)
	±	(µx∑ÓØ 0 < x ¥ ∂g∑ g ç G ± ÓØ 0 < g ± g < x)
	¥	(µx y∑ÓØ 0 < x ± x < y ¥ ∂g∑g ç G ± x < g ± g < y)
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂M∑ M = {t | t ç G ≤ t = ÓØ 0}Æ THEN1 prove_∂_tac);
a(lemma_tac¨	ÓØ 0 ç M
	±	(µg h∑ g ç M ± h ç M ¥ g + h ç M)
	±	(µx∑ÓØ 0 < x ¥ ∂g∑ g ç M ± ÓØ 0 < g ± g < x)ÆTHEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[Ø_plus_clauses]);
(* *** Goal "2.3" *** *)
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[Ø_plus_clauses]);
(* *** Goal "2.4" *** *)
a(asm_rewrite_tac[Ø_plus_clauses]);
(* *** Goal "3" *** *)
a(spec_nth_asm_tac 5 ¨x'Æ);
a(∂_tac¨gÆ THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(all_fc_tac[Ø_monoid_dense_thm]);
a(∂_tac¨gÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[]);
a(lemma_tac¨ÓØ 0 < gÆ THEN1 all_fc_tac[Ø_less_trans_thm]);
a(LEMMA_T¨≥g = ÓØ 0Æ rewrite_thm_tac THEN1
	(contr_tac THEN all_var_elim_asm_tac1 THEN all_fc_tac[Ø_less_irrefl_thm]));
save_pop_thm"Ø_semigroup_dense_thm"
);
=TEX
Now back to generalities: the image of a homomorphism is a group:
=SML
val €Ø_add_hom_image_group_thm› = (
set_goal([], ¨µf : Ø ≠ Ø∑
		(µx y∑f (x + y) = f x + f y)
	±	(I = {b | ∂ a∑ b = f a })
	¥	ÓØ 0 ç I
	±	(µg h∑ g ç I ± h ç I ¥ g + h ç I)
	±	(µg∑ g ç I ¥ ~g ç I)
Æ);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac THEN ∂_tac¨ÓØ 0Æ);
a(ALL_FC_T asm_rewrite_tac[Ø_add_hom_0_thm]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac THEN ∂_tac¨a + a'Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac THEN ∂_tac¨~aÆ);
a(ALL_FC_T asm_rewrite_tac[Ø_add_hom_minus_thm]);
save_pop_thm"Ø_add_hom_image_group_thm"
);
=TEX
\ldots and, for completeness (we don't seem to need it here) we show
that the kernel of a homomorphism is a group:
=SML
val €Ø_add_hom_kernel_group_thm› = (
set_goal([], ¨µf : Ø ≠ Ø∑
		(µx y∑f (x + y) = f x + f y)
	±	(K = {a | f a = ÓØ 0 })
	¥	ÓØ 0 ç K
	±	(µg h∑ g ç K ± h ç K ¥ g + h ç K)
	±	(µg∑ g ç K ¥ ~g ç K)
Æ);
a(REPEAT strip_tac THEN all_var_elim_asm_tac1);
(* *** Goal "1" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac THEN ALL_FC_T rewrite_tac[Ø_add_hom_0_thm]);
(* *** Goal "2" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac THEN asm_rewrite_tac[Ø_plus_clauses]);
(* *** Goal "3" *** *)
a(PC_T1 "sets_ext" REPEAT strip_tac THEN ALL_FC_T asm_rewrite_tac[Ø_add_hom_minus_thm]);
a(rewrite_tac[Ø_minus_clauses]);
save_pop_thm"Ø_add_hom_kernel_group_thm"
);
=TEX
\subsection{Order-preserving Additive Homomorphisms}

For brevity, we characterise order-preserving homomorphisms as those that
send positive numbers to positive numbers.
First we show that such homomorphisms do indeed preserve the ordering:
=SML
val €Ø_opah_thm› = (
set_goal([], ¨µf : Ø ≠ Ø∑
		(µx y∑f (x + y) = f x + f y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < f x)
	¥	(µx y∑x < y ¥ f x < f y)
Æ);
a(REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN once_rewrite_tac[Ø_less_0_less_thm] THEN REPEAT strip_tac);
a(ALL_ASM_FC_T (MAP_EVERY ante_tac)[]);
a(asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[Ø_add_hom_minus_thm]);
save_pop_thm"Ø_opah_thm"
);
=TEX
Next we show that the implication in the previous theorem can be reversed:
=SML
val €Ø_opah_strict_thm› = (
set_goal([], ¨µf : Ø ≠ Ø∑
		(µx y∑f (x + y) = f x + f y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < f x)
	¥	(µx y∑f x < f y ¥ x < y)
Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨µx y∑x < y ¥ f x < f yÆ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN all_fc_tac[Ø_opah_thm]);
(* *** Goal "2" *** *)
a(all_fc_tac[Ø_ord_pres_strict_thm]);
save_pop_thm"Ø_opah_strict_thm"
);
=TEX
Now we can show that order-preserving homomorphisms are injective functions:
=SML
val €Ø_opah_one_one_thm› = (
set_goal([], ¨µf : Ø ≠ Ø∑
		(µx y∑f (x + y) = f x + f y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < f x)
	¥	OneOne f
Æ);
a(rewrite_tac[one_one_def] THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN once_rewrite_tac[Ø_eq_thm] THEN strip_tac);
a(strip_asm_tac(list_µ_elim[¨x1 + ~x2Æ, ¨ÓØ 0Æ]Ø_less_cases_thm));
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN once_rewrite_tac[Ø_less_0_less_thm]);
a(rewrite_tac[Ø_minus_clauses, Ø_plus_0_thm]);
a(strip_tac THEN ALL_ASM_FC_T (MAP_EVERY ante_tac)[]);
a(asm_rewrite_tac[]);
a(once_rewrite_tac[Ø_less_less_0_thm]);
a(rewrite_tac[Ø_minus_clauses, Ø_plus_0_thm]);
a(ALL_FC_T rewrite_tac[Ø_add_hom_minus_thm]);
a(asm_rewrite_tac[Ø_minus_clauses, Ø_less_irrefl_thm]);
(* *** Goal "2" *** *)
a(ALL_ASM_FC_T (MAP_EVERY ante_tac)[]);
a(asm_rewrite_tac[] THEN ALL_FC_T rewrite_tac[Ø_add_hom_minus_thm]);
a(asm_rewrite_tac[Ø_less_irrefl_thm]);
save_pop_thm"Ø_opah_one_one_thm"
);
=TEX
Next we show that the image of an order-preserving homomorphism
contains positive numbers arbitrarily close to $0$:
=SML
val €Ø_opah_dense_image_thm› = (
set_goal([], ¨µf e∑
		(µx y∑f (x + y) = f x + f y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < f x)
	±	ÓØ 0 < e
	¥	∂d∑ ÓØ 0 < d ± f d < e
Æ);
a(contr_tac);
a(lemma_tac¨∂N∑ N = {r | ∂t∑ t < ÓØ 0 ± r = f t}Æ THEN1 prove_∂_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨f(~(ÓØ 1)) ç NÆ THEN1 POP_ASM_T rewrite_thm_tac);
a(∂_tac¨~(ÓØ 1)Æ	THEN rewrite_tac[]);
a(once_rewrite_tac[Ø_less_0_less_thm] THEN rewrite_tac[Ø_minus_clauses, Ø_less_clauses]);
(* *** Goal "2" *** *)
a(lemma_tac¨≥N = {}Æ THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(lemma_tac¨µx∑ x ç N ¥ x º ÓØ 0Æ);
(* *** Goal "2.1" *** *)
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(rewrite_tac[Ø_º_≥_less_thm] THEN contr_tac);
a(lemma_tac ¨f t < f(ÓØ 0)Æ THEN1 all_fc_tac[Ø_opah_thm]);
a(POP_ASM_T ante_tac THEN ALL_FC_T rewrite_tac[Ø_add_hom_0_thm] THEN contr_tac);
a(all_fc_tac[Ø_less_trans_thm] THEN all_fc_tac[Ø_less_irrefl_thm]);
(* *** Goal "2.2" *** *)
a(cases_tac¨≥Sup N ç NÆ);
(* *** Goal "2.2.1" *** *)
a(LEMMA_T¨(Sup N + ~e) < (Sup N + ~e) + eÆ ante_tac THEN1 asm_rewrite_tac[Ø_less_clauses]);
a(rewrite_tac[Ø_plus_assoc_thm, Ø_minus_clauses, Ø_plus_0_thm] THEN contr_tac);
a(lemma_tac¨∂a∑a ç N ± Sup N + ~e < a ± a < Sup NÆ);
(* *** Goal "2.2.1.1" *** *)
a(all_fc_tac[Ø_less_sup_ç_thm]);
a(∂_tac¨yÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.1.2" *** *)
a(lemma_tac¨∂b∑b ç N ± a < b ± b < Sup NÆ);
(* *** Goal "2.2.1.2.1" *** *)
a(DROP_NTH_ASM_T 4 discard_tac THEN all_fc_tac[Ø_less_sup_ç_thm]);
a(∂_tac¨yÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.1.2.2" *** *)
a(lemma_tac¨b + ~a < eÆ);
(* *** Goal "2.2.1.2.2.1" *** *)
a(LEMMA_T ¨(b + ~a) + a < e + aÆ ante_tac THEN_LIST
	[id_tac, rewrite_tac[Ø_less_clauses]]);
a(rewrite_tac[Ø_plus_assoc_thm, Ø_minus_clauses, Ø_plus_clauses]);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨Sup NÆ THEN REPEAT strip_tac);
a(LEMMA_T ¨~e + Sup N < ~e + (e + a)Æ ante_tac THEN_LIST
	[id_tac, rewrite_tac[Ø_less_clauses]]);
a(rewrite_tac[Ø_plus_assoc_thm1, Ø_minus_clauses, Ø_plus_clauses]);
a(once_rewrite_tac[Ø_plus_comm_thm] THEN REPEAT strip_tac);
a(GET_ASM_T ¨a ç NÆ ante_tac THEN GET_ASM_T ¨b ç NÆ ante_tac);
a(LIST_GET_NTH_ASM_T [13] rewrite_tac THEN REPEAT strip_tac);
a(var_elim_asm_tac ¨a = f t'Æ THEN var_elim_asm_tac ¨b = f tÆ);
a(lemma_tac¨t' < tÆ THEN1 all_fc_tac[Ø_opah_strict_thm]);
a(POP_ASM_T (strip_asm_tac o once_rewrite_rule[Ø_less_0_less_thm]));
a(lemma_tac¨f(t + ~t') < eÆ THEN1
	(asm_rewrite_tac[] THEN ALL_FC_T asm_rewrite_tac[Ø_add_hom_minus_thm]));
a(spec_nth_asm_tac 17 ¨t + ~t'Æ);
(* *** Goal "2.2.2" *** *)
a(lemma_tac¨∂s∑s = Sup NÆ THEN1 prove_∂_tac);
a(LEMMA_T ¨s ç NÆ ante_tac THEN1 var_elim_asm_tac¨s = Sup NÆ);
a(rewrite_tac[] THEN once_asm_rewrite_tac[]);
a(POP_ASM_T discard_tac THEN contr_tac);
a(all_fc_tac[µ_elim¨tÆØ_less_dense_thm]);
a(lemma_tac¨f t < f zÆ THEN1 all_fc_tac[Ø_opah_thm]);
a(lemma_tac¨f z ç NÆ THEN1 (asm_rewrite_tac[] THEN REPEAT strip_tac));
(* *** Goal "2.2.2.1" *** *)
a(∂_tac ¨zÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2" *** *)
a(lemma_tac¨f z º Sup NÆ THEN1 all_fc_tac[Ø_sup_thm]);
a(lemma_tac¨Sup N < f zÆ THEN1 LIST_GET_NTH_ASM_T [3, 6] rewrite_tac);
a(strip_asm_tac(list_µ_elim[¨f zÆ, ¨Sup NÆ]Ø_º_less_trans_thm));
a(all_asm_fc_tac[] THEN all_fc_tac[Ø_less_irrefl_thm]);
save_pop_thm"Ø_opah_dense_image_thm"
);
=TEX
As a consequence of the previous theorem
we can no show that order-preserving homomorphisms are surjective.
The reasoning is that the image of such a homomorphism is dense (by the above
results) and complete (because it is order-isomorphic to the reals).
By a general result on orderings, we infer that the image is the set of all reals.
=SML
val €Ø_opah_onto_thm› = (
set_goal([], ¨µf : Ø ≠ Ø∑
		(µx y∑f (x + y) = f x + f y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < f x)
	¥	Onto f
Æ);
a(rewrite_tac[onto_def] THEN REPEAT strip_tac);
a(lemma_tac ¨∂I∑ I = {b | ∂ a∑ b = f a}Æ THEN1 prove_∂_tac);
a(lemma_tac¨I DenseIn(Universe, $<) ± Complete(I, $<)Æ);
a(rewrite_tac[dense_in_def, complete_def, unbounded_above_def,
	has_supremum_def, upper_bound_def] THEN REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(strip_asm_tac (µ_elim¨fÆØ_add_hom_image_group_thm) THEN1 all_asm_fc_tac[]);
a(lemma_tac ¨µ x∑ ÓØ 0 < x ¥ ∂ g∑ g ç I ± ÓØ 0 < g ± g < xÆ);
(* *** Goal "1.1.1" *** *)
a(REPEAT strip_tac THEN all_fc_tac[Ø_opah_dense_image_thm]);
a(LEMMA_T ¨f(ÓØ 0) < f dÆ ante_tac THEN1 all_fc_tac[Ø_opah_thm]);
a(ALL_FC_T rewrite_tac[Ø_add_hom_0_thm] THEN strip_tac);
a(lemma_tac ¨f d ç IÆ THEN1 (asm_rewrite_tac[] THEN ∂_tac¨dÆ THEN REPEAT strip_tac));
a(∂_tac¨f dÆ THEN REPEAT strip_tac);
(* *** Goal "1.1.2" *** *)
a(all_fc_tac[Ø_subgroup_dense_thm] THEN contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a(lemma_tac¨∂D∑D = {a | f a ç A}Æ THEN1 prove_∂_tac);
a(lemma_tac¨≥D = {}Æ);
(* *** Goal "1.2.1" *** *)
a(GET_NTH_ASM_T 6 (PC_T1 "sets_ext" strip_asm_tac));
a(lemma_tac¨x' ç IÆ THEN1
	(LIST_GET_NTH_ASM_T [1, 6] (MAP_EVERY ante_tac) THEN PC_T1 "sets_ext" prove_tac[]));
a(POP_ASM_T ante_tac THEN LIST_GET_NTH_ASM_T [2, 8] rewrite_tac THEN REPEAT strip_tac);
a(var_elim_asm_tac ¨x' = f aÆ THEN PC_T1 "sets_ext" REPEAT strip_tac);
a(∂_tac¨aÆ THEN REPEAT strip_tac);
(* *** Goal "1.2.2" *** *)
a(lemma_tac¨∂b∑µx∑x ç D ¥ x º bÆ THEN1 swap_nth_asm_concl_tac 3 THEN REPEAT strip_tac);
(* *** Goal "1.2.2.1" *** *)
a(strip_asm_tac (µ_elim¨fÆØ_add_hom_image_group_thm) THEN1 all_asm_fc_tac[]);
a(cases_tac¨ÓØ 0 < xÆ);
(* *** Goal "1.2.2.1.1" *** *)
a(lemma_tac¨∂y∑y ç I ± x < yÆ THEN1 all_fc_tac[Ø_monoid_delta_dense_thm]);
(* *** Goal "1.2.2.1.1.1" *** *)
a(lemma_tac ¨g + x ç IÆ THEN1 (GET_NTH_ASM_T 6 bc_thm_tac THEN REPEAT strip_tac));
a(∂_tac¨g + xÆ THEN REPEAT strip_tac);
(* *** Goal "1.2.2.1.1.2" *** *)
a(GET_NTH_ASM_T 2 ante_tac THEN GET_NTH_ASM_T 14 rewrite_thm_tac THEN REPEAT strip_tac);
a(var_elim_asm_tac ¨y = f aÆ);
a(spec_nth_asm_tac 7 ¨aÆ);
a(GET_NTH_ASM_T 2 ante_tac THEN GET_NTH_ASM_T 11 rewrite_thm_tac THEN REPEAT strip_tac);
a(∂_tac¨f x'Æ THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(lemma_tac¨f a < f x'Æ THEN1 all_fc_tac[Ø_opah_thm]);
a(contr_tac THEN LEMMA_T ¨f x' < f x'Æ (strip_asm_tac o rewrite_rule[Ø_less_irrefl_thm]));
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac ¨xÆ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac ¨f aÆ THEN REPEAT strip_tac);
(* *** Goal "1.2.2.1.2" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
a(spec_nth_asm_tac 5 ¨ÓØ 0Æ);
a(GET_NTH_ASM_T 2 ante_tac THEN GET_NTH_ASM_T 9 rewrite_thm_tac THEN REPEAT strip_tac);
a(∂_tac¨f x'Æ THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 2 (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(LEMMA_T¨f (ÓØ 0) < f x'Æ ante_tac THEN1 all_fc_tac[Ø_opah_thm]);
a(ALL_FC_T rewrite_tac[Ø_add_hom_0_thm] THEN REPEAT strip_tac);
a(contr_tac THEN LEMMA_T ¨f x' < f x'Æ (strip_asm_tac o rewrite_rule[Ø_less_irrefl_thm]));
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac ¨xÆ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac ¨ÓØ 0Æ THEN REPEAT strip_tac);
(* *** Goal "1.2.2.2" *** *)
a(∂_tac¨f(Sup D)Æ THEN REPEAT strip_tac);
(* *** Goal "1.2.2.2.1" *** *)
a(GET_NTH_ASM_T 9 rewrite_thm_tac THEN ∂_tac ¨Sup DÆ THEN REPEAT strip_tac);
(* *** Goal "1.2.2.2.2" *** *)
a(lemma_tac ¨a ç IÆ THEN1
	(LIST_GET_NTH_ASM_T [1, 8] (MAP_EVERY ante_tac) THEN PC_T1 "sets_ext" prove_tac[]));
a(POP_ASM_T ante_tac THEN GET_NTH_ASM_T 10 rewrite_thm_tac THEN strip_tac);
a(var_elim_asm_tac ¨a = f a'Æ);
a(lemma_tac¨a' < Sup DÆ THEN_LIST [id_tac, all_fc_tac[Ø_opah_thm]]);
a(bc_thm_tac Ø_less_sup_bc_thm THEN REPEAT strip_tac);
(* *** Goal "1.2.2.2.2.1" *** *)
a(∂_tac¨bÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.2.2.2" *** *)
a(GET_NTH_ASM_T 6 ante_tac THEN GET_NTH_ASM_T 10 rewrite_thm_tac THEN strip_tac);
a(var_elim_asm_tac ¨x = f aÆ);
a(LIST_GET_NTH_ASM_T [7]all_fc_tac);
a(lemma_tac ¨c ç IÆ THEN1
	(LIST_GET_NTH_ASM_T [2, 10] (MAP_EVERY ante_tac) THEN PC_T1 "sets_ext" prove_tac[]));
a(POP_ASM_T ante_tac THEN GET_NTH_ASM_T 12 rewrite_thm_tac THEN strip_tac);
a(var_elim_asm_tac ¨c = f a''Æ);
a(∂_tac¨a''Æ THEN asm_rewrite_tac[]);
a(all_fc_tac[Ø_opah_strict_thm]);
(* *** Goal "1.2.2.2.3" *** *)
a(GET_NTH_ASM_T 2 ante_tac THEN GET_NTH_ASM_T 11 rewrite_thm_tac THEN strip_tac);
a(var_elim_asm_tac ¨y' = f aÆ);
a(lemma_tac¨≥a < Sup DÆ THEN_LIST
	[id_tac, contr_tac THEN all_fc_tac[Ø_opah_strict_thm]]);
a(rewrite_tac[Ø_≥_less_º_thm] THEN bc_thm_tac Ø_sup_º_bc_thm);
a(REPEAT strip_tac);
(* *** Goal "1.2.2.2.3.1" *** *)
a(∂_tac¨bÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2.2.3.2" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a(LIST_GET_NTH_ASM_T [2] all_fc_tac);
a(all_fc_tac[Ø_opah_strict_thm]);
a(asm_rewrite_tac[Ø_º_def]);
(* *** Goal "2" *** *)
a(strip_asm_tac Ø_less_def THEN LIST_DROP_NTH_ASM_T [1, 2] discard_tac);
a(LEMMA_T¨I Ä UniverseÆ asm_tac THEN1 PC_T1 "sets_ext" prove_tac[]);
a(all_fc_tac[dense_complete_subset_thm]);
a(POP_ASM_T ante_tac THEN  PC_T1 "sets_ext" asm_rewrite_tac[]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
save_pop_thm"Ø_opah_onto_thm"
);
=TEX
\subsection{Inverse of Order-preserving Additive Homomorphisms}
Now we know that order-preserving additive homomorphisms are one-to-one and
onto, we can exhibit their inverses.

We prove a general lemma on function inverses first:

=SML
val €inverse_lemma› = (
set_goal([], ¨µf ∑ OneOne f ± Onto f ¥ ∂g∑(µx∑g(f x) = x) ± (µx∑f(g x) = x)Æ);
a(rewrite_tac[one_one_def, onto_def] THEN REPEAT strip_tac);
a(lemma_tac¨∂g∑µx∑f(g x) = xÆ THEN1 prove_∂_tac);
(* *** Goal "1" *** *)
a(conv_tac(ONCE_MAP_C eq_sym_conv) THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨gÆ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(lemma_tac¨f(g (f x)) = f xÆ THEN1 asm_rewrite_tac[]);
a(all_asm_fc_tac[]);
pop_thm()
);
=TEX
Now, we show that if an order-preserving additive homomorphism has
an inverse then the inverse is order-preserving and an additive homomorphism.
=SML
val €Ø_opah_inverse_add_hom_thm› = (
set_goal([], ¨µf : Ø ≠ Ø; g∑
		(µx y∑f (x + y) = f x + f y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < f x)
	±	(µx∑g(f x) = x)
	±	(µx∑f(g x) = x)
	¥	(µx y∑g (x + y) = g x + g y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < g x)
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T¨x + y = f(g x + g y)Ærewrite_thm_tac THEN1 asm_rewrite_tac[]);
a(GET_NTH_ASM_T 2 rewrite_thm_tac);
(* *** Goal "2" *** *)
a(lemma_tac¨f(ÓØ 0) < f (g x)Æ THEN1 ALL_FC_T asm_rewrite_tac[Ø_add_hom_0_thm]);
a(all_fc_tac[Ø_opah_strict_thm]);
save_pop_thm"Ø_opah_inverse_add_hom_thm"
);
=TEX
=SML
val €Ø_opah_inverse_thm› = (
set_goal([], ¨µf : Ø ≠ Ø∑
		(µx y∑f (x + y) = f x + f y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < f x)
	¥	∂g : Ø ≠ Ø∑
		(µx∑g(f x) = x)
	±	(µx∑f(g x) = x)
	±	(µx y∑g (x + y) = g x + g y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < g x)
Æ);
a(REPEAT strip_tac);
a(all_fc_tac[Ø_opah_one_one_thm, Ø_opah_onto_thm]);
a(all_fc_tac[inverse_lemma]);
a(ante_tac (list_µ_elim[¨fÆ, ¨gÆ] Ø_opah_inverse_add_hom_thm));
a(asm_rewrite_tac[] THEN strip_tac);
a(∂_tac¨gÆ THEN REPEAT strip_tac THEN_TRY (SOLVED_T (asm_rewrite_tac[])));
a(all_asm_fc_tac[]);
save_pop_thm"Ø_opah_inverse_thm"
);
=TEX
\subsection{Existence of Central Order-preserving Additive Homomorphisms}
We now want to show that the real numbers come with a very
adequate supply of OPAHs that lie in the centre of the automorphism group, we call these COPAHs.

Firstly and most trivially, the identity function is a COPAH
=SML
val €Ø_copah_id_thm› = (
set_goal([], ¨∂… : Ø ≠ Ø∑
		(µx∑ … x = x)
	±	(µx y∑… (x + y) = … x + … y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < … x)
	±	(µf∑ (µx y∑f (x + y) = f x + f y) ¥ µx∑…(f x) = f(… x))
Æ);
a(∂_tac¨Ãx:Ø ∑ xÆ THEN rewrite_tac[]);
save_pop_thm"Ø_copah_id_thm"
);
=TEX
Next, there is a COPAH that increases any positive number:
=SML
val €Ø_copah_double_thm› = (
set_goal([], ¨∂¡ : Ø ≠ Ø∑
		(µx∑ ¡ x = x + x)
	±	(µx y∑¡ (x + y) = ¡ x + ¡ y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < ¡ x)
	±	(µx∑ ÓØ 0 < x ¥ x < ¡ x)
	±	(µf∑ (µx y∑f (x + y) = f x + f y) ¥ µx∑¡(f x) = f(¡ x))
Æ);
a(∂_tac¨Ãx:Ø ∑ x + xÆ THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[µ_elim¨xÆ Ø_plus_order_thm]);
(* *** Goal "2" *** *)
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac ¨xÆ THEN asm_rewrite_tac[Ø_less_clauses]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[Ø_less_clauses]);
(* *** Goal "4" *** *)
a(asm_rewrite_tac[]);
save_pop_thm"Ø_copah_double_thm"
);
=TEX
\ldots and there is a COPAH that decreases any positive number:
=SML
val €Ø_copah_halve_thm› = (
set_goal([], ¨∂¬ : Ø ≠ Ø∑
		(µx∑ ¬ x + ¬ x = x)
	±	(µx y∑¬ (x + y) = ¬ x + ¬ y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < ¬ x)
	±	(µx∑ ÓØ 0 < x ¥ ¬ x < x)
	±	(µf∑ (µx y∑f (x + y) = f x + f y) ¥ µx∑¬(f x) = f(¬ x))
Æ);
a(strip_asm_tac Ø_copah_double_thm);
a(all_fc_tac[Ø_opah_inverse_thm]);
a(lemma_tac¨µx∑ g x + g x = xÆ THEN1 strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T¨g x + g x = ¡ (g x)Æ ante_tac THEN1 GET_NTH_ASM_T 9 rewrite_thm_tac);
a(GET_NTH_ASM_T 3 rewrite_thm_tac);
(* *** Goal "2" *** *)
a(∂_tac¨gÆ THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2.3" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2.4" *** *)
a(lemma_tac¨x < ¡ xÆ THEN1 all_asm_fc_tac[]);
a(LEMMA_T¨g x < g (¡ x)Æ ante_tac THEN1 all_fc_tac[Ø_opah_thm]);
a(asm_rewrite_tac[]);
(* *** Goal "2.5" *** *)
a(LEMMA_T ¨g(g(f x) + g(f x)) = g(f(g x + g x))Æ ante_tac THEN1 GET_NTH_ASM_T 2 rewrite_thm_tac);
a(GET_NTH_ASM_T 1 rewrite_thm_tac);
a(GET_NTH_ASM_T 2 rewrite_thm_tac);
a(GET_NTH_ASM_T 4 rewrite_thm_tac);
a(LEMMA_T ¨g (f (g x)) + g (f (g x)) = ¡(g(f(g x)) )Æ rewrite_thm_tac THEN1
		GET_NTH_ASM_T 11 rewrite_thm_tac);
a(GET_NTH_ASM_T 5 rewrite_thm_tac);
save_pop_thm"Ø_copah_halve_thm"
);
=TEX
\ldots and the composite of two COPAHs is a COPAH:
=SML
val €Ø_copah_comp_thm› = (
set_goal([], ¨µ¡ ¬∑ 
		(µx y∑¡ (x + y) = ¡ x + ¡ y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < ¡ x)
	±	(µf∑ (µx y∑f (x + y) = f x + f y) ¥ µx∑¡(f x) = f(¡ x))
	±	(µx y∑¬ (x + y) = ¬ x + ¬ y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < ¬ x)
	±	(µf∑ (µx y∑f (x + y) = f x + f y) ¥ µx∑¬(f x) = f(¬ x))
	¥	∂«∑
		(µx∑ « x = ¡(¬ x))
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < « x)
	±	(µx y∑« (x + y) = « x + « y)
	±	(µf∑ (µx y∑f (x + y) = f x + f y) ¥ µx∑«(f x) = f(« x))
Æ);
a(REPEAT strip_tac);
a(∂_tac¨Ãx∑¡(¬ x)Æ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(GET_NTH_ASM_T 6 bc_thm_tac THEN GET_NTH_ASM_T 3 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LEMMA_T¨µx∑¬(f x) = f(¬ x)Æ rewrite_thm_tac THEN1
	(GET_NTH_ASM_T 2 bc_thm_tac THEN asm_rewrite_tac[]));
a(LEMMA_T¨µx∑¡(f x) = f(¡ x)Æ rewrite_thm_tac THEN1
	(GET_NTH_ASM_T 5 bc_thm_tac THEN asm_rewrite_tac[]));
save_pop_thm"Ø_copah_comp_thm"
);
=TEX
\ldots and the sum of two COPAHs is a COPAH:
=SML
val €Ø_copah_sum_thm› = (
set_goal([], ¨µ¡ ¬∑ 
		(µx y∑¡ (x + y) = ¡ x + ¡ y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < ¡ x)
	±	(µf∑ (µx y∑f (x + y) = f x + f y) ¥ µx∑¡(f x) = f(¡ x))
	±	(µx y∑¬ (x + y) = ¬ x + ¬ y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < ¬ x)
	±	(µf∑ (µx y∑f (x + y) = f x + f y) ¥ µx∑¬(f x) = f(¬ x))
	¥	∂«∑
		(µx∑ « x = ¡ x + ¬ x)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < « x)
	±	(µx y∑« (x + y) = « x + « y)
	±	(µf∑ (µx y∑f (x + y) = f x + f y) ¥ µx∑«(f x) = f(« x))
Æ);
a(REPEAT strip_tac);
a(∂_tac¨Ãx∑¡ x + ¬ xÆ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨¡ xÆ THEN REPEAT strip_tac THEN1 all_asm_fc_tac[]);
a(rewrite_tac[Ø_less_clauses] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[Ø_plus_assoc_thm]);
a(rewrite_tac[µ_elim¨¡ yÆØ_plus_order_thm]);
(* *** Goal "3" *** *)
a(LEMMA_T¨µx∑¬(f x) = f(¬ x)Æ rewrite_thm_tac THEN1
	(GET_NTH_ASM_T 2 bc_thm_tac THEN asm_rewrite_tac[]));
a(LEMMA_T¨µx∑¡(f x) = f(¡ x)Æ rewrite_thm_tac THEN1
	(GET_NTH_ASM_T 5 bc_thm_tac THEN asm_rewrite_tac[]));
a(asm_rewrite_tac[]);
save_pop_thm"Ø_copah_sum_thm"
);
=TEX
We now want to show that certain sets define in terms of COPAHs are dense.
The following lemma is vital: it says that if a set $A$ contains a positive
element, $\epsilon$ and is closed under division by $2$ then $A$ contains
elements arbitrarily close to $0$.
=SML
val €Ø_halve_closed_dense_thm› = (
set_goal([], ¨µA e∑
		ÓØ 0 < e
	±	e ç A
	±	(µy∑y ç A ¥ ∂z∑z ç A ± z + z = y)
	¥	(µd∑ ÓØ 0 < d ¥ ∂a∑a ç A ± ÓØ 0 < a ± a < d)
Æ);
a contr_tac;
a(lemma_tac¨∂B∑B = {c | ÓØ 0 < c ± µa∑a ç A ± ÓØ 0 < a ¥ ≥a < c}Æ THEN1 prove_∂_tac);
a(lemma_tac¨≥B = {}Æ THEN1
	(PC_T1 "sets_ext" REPEAT strip_tac THEN ∂_tac¨dÆ THEN asm_rewrite_tac[]));
(* *** Goal "1" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨∂b∑µ x∑ x ç B ¥ x º bÆ);
(* *** Goal "2.1" *** *)
a(∂_tac ¨eÆ THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(contr_tac THEN POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_º_≥_less_thm]));
a(all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨d º Sup BÆ THEN1 bc_thm_tac Ø_º_sup_bc_thm);
(* *** Goal "2.2.1" *** *)
a(REPEAT strip_tac THEN1 (∂_tac¨bÆ THEN contr_tac THEN all_asm_fc_tac[]));
a(lemma_tac¨d ç BÆ THEN1 (asm_rewrite_tac[] THEN contr_tac THEN all_asm_fc_tac[]));
a(all_asm_fc_tac[]);
(* *** Goal "2.2.2" *** *)
a(lemma_tac¨µv∑ÓØ 0 < v ± Sup B < v ¥ ∂c∑ c ç A ± ÓØ 0 < c ± c < vÆ THEN1 contr_tac);
(* *** Goal "2.2.2.1" *** *)
a(swap_nth_asm_concl_tac 2);
a(rewrite_tac[Ø_≥_less_º_thm] THEN bc_thm_tac Ø_º_sup_bc_thm);
a(REPEAT strip_tac THEN1 (∂_tac¨bÆ THEN contr_tac THEN all_asm_fc_tac[]));
a(TOP_ASM_T bc_thm_tac THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(lemma_tac¨ÓØ 0 < Sup BÆ THEN1 all_fc_tac[Ø_less_º_trans_thm]);
a(lemma_tac¨ÓØ 0 < Sup B + dÆ);
(* *** Goal "2.2.2.2.1" *** *)
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac ¨Sup BÆ THEN REPEAT strip_tac);
a(asm_rewrite_tac[Ø_less_clauses]);
(* *** Goal "2.2.2.2.2" *** *)
a(SPEC_NTH_ASM_T 3 ¨Sup B + dÆ ante_tac);
a(rewrite_tac[Ø_less_clauses] THEN REPEAT strip_tac);
a(contr_tac THEN spec_nth_asm_tac 13 ¨cÆ);
a(lemma_tac¨z < Sup BÆ THEN1 contr_tac);
(* *** Goal "2.2.2.2.2.1" *** *)
a(var_elim_asm_tac¨z + z = cÆ);
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
a(lemma_tac ¨Sup B + d º z + zÆ THEN1 bc_thm_tac Ø_º_trans_thm);
(* *** Goal "2.2.2.2.2.1.1" *** *)
a(∂_tac ¨Sup B + Sup BÆ THEN rewrite_tac[Ø_º_clauses] THEN REPEAT strip_tac);
a(bc_thm_tac Ø_º_trans_thm THEN ∂_tac ¨Sup B + zÆ THEN rewrite_tac[Ø_º_clauses] THEN strip_tac);
(* *** Goal "2.2.2.2.2.1.2" *** *)
a(LEMMA_T ¨z + z < z + zÆ (strip_asm_tac o rewrite_rule[Ø_less_irrefl_thm]));
a(bc_thm_tac Ø_less_º_trans_thm THEN ∂_tac ¨Sup B + dÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.2.2" *** *)
a(lemma_tac¨≥Sup B ç BÆ);
(* *** Goal "2.2.2.2.2.2.1" *** *)
a(lemma_tac¨∂s∑s = Sup BÆ THEN1 prove_∂_tac);
a(LEMMA_T¨≥s ç BÆ ante_tac THEN_LIST
	[GET_NTH_ASM_T 14 rewrite_thm_tac, TOP_ASM_T rewrite_thm_tac]);
a(var_elim_asm_tac ¨s = Sup BÆ THEN contr_tac);
a(lemma_tac¨ÓØ 0 < zÆ THEN1 contr_tac);
(* *** Goal "2.2.2.2.2.2.1.1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
a(lemma_tac¨z + z º ÓØ 0Æ THEN1
	(bc_thm_tac Ø_º_trans_thm THEN ∂_tac¨zÆ THEN
	rewrite_tac[Ø_º_clauses] THEN REPEAT strip_tac));
a(LEMMA_T ¨z + z < z + zÆ (strip_asm_tac o rewrite_rule[Ø_less_irrefl_thm]));
a(var_elim_asm_tac¨z + z = cÆ);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac ¨ÓØ 0Æ THEN REPEAT strip_tac);
(* *** Goal "2.2.2.2.2.2.1.2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2.2.2.2.2.2.2" *** *)
a(DROP_NTH_ASM_T 9 discard_tac THEN all_fc_tac[Ø_less_sup_ç_thm]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(lemma_tac¨ÓØ 0 < zÆ THEN1 contr_tac);
(* *** Goal "2.2.2.2.2.2.2.1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
a(lemma_tac¨z + z º ÓØ 0Æ THEN1
	(bc_thm_tac Ø_º_trans_thm THEN ∂_tac¨zÆ THEN
	rewrite_tac[Ø_º_clauses] THEN REPEAT strip_tac));
a(LEMMA_T ¨z + z < z + zÆ (strip_asm_tac o rewrite_rule[Ø_less_irrefl_thm]));
a(var_elim_asm_tac¨z + z = cÆ);
a(bc_thm_tac Ø_º_less_trans_thm THEN ∂_tac ¨ÓØ 0Æ THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < yÆ THEN1 
	(bc_thm_tac Ø_less_trans_thm THEN ∂_tac ¨zÆ THEN REPEAT strip_tac));
a(TOP_ASM_T rewrite_thm_tac THEN REPEAT strip_tac);
a(∂_tac¨zÆ THEN REPEAT strip_tac);
save_pop_thm"Ø_halve_closed_dense_thm"
);
=TEX
Now we can show, that for any $\delta > 0$, the images of $\epsilon$ under
the COPAHs are a dense in the positive reals:
=SML
val €Ø_copah_dense_thm› = (
set_goal([], ¨µd x y∑
		ÓØ 0 < d ± ÓØ 0 < x ± x < y
	¥	∂«∑
		(µx y∑« (x + y) = « x + « y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < « x)
	±	(µf∑ (µx y∑f (x + y) = f x + f y) ¥ µx∑«(f x) = f(« x))
	±	x < « d ± « d < y
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂A∑
	A = { t | ∂q∑ 
		(µx y∑q (x + y) = q x + q y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < q x)
	±	(µf∑ (µx y∑f (x + y) = f x + f y) ¥ µx∑q(f x) = f(q x))
	±	t = q d } Æ THEN1 prove_∂_tac);
a(lemma_tac¨d ç AÆ);
(* *** Goal "1" *** *)
a(strip_asm_tac Ø_copah_id_thm);
a(asm_rewrite_tac[]);
a(∂_tac ¨…Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac ¨µd∑ ÓØ 0 < d ¥ ∂a∑a ç A ± ÓØ 0 < a ± a < dÆ THEN1
	bc_thm_tac Ø_halve_closed_dense_thm);
(* *** Goal "2.1" *** *)
a(∂_tac¨dÆ THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(strip_asm_tac Ø_copah_halve_thm);
a(∂_tac¨¬ y'Æ THEN asm_rewrite_tac[]);
a(ante_tac(list_µ_elim[¨¬Æ, ¨qÆ]Ø_copah_comp_thm));
a(asm_rewrite_tac[] THEN strip_tac);
a(∂_tac¨«Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨µg h∑ g ç A ± h ç A ¥ g + h ç AÆ);
(* *** Goal "2.2.1" *** *)
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨qÆ, ¨q'Æ]Ø_copah_sum_thm));
a(asm_rewrite_tac[] THEN strip_tac);
a(∂_tac¨«Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a(all_fc_tac[Ø_semigroup_dense_thm]);
a(DROP_NTH_ASM_T 3 ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a(var_elim_asm_tac ¨g = q dÆ THEN ∂_tac¨qÆ THEN asm_rewrite_tac[]);
save_pop_thm"Ø_copah_dense_thm"
);
=TEX
\subsection{Extensions of Partial Homomorphisms}

In this section we show that to define an OPAH it is sufficient to define
its behaviour on the positive elements. I.e., if a function $f$ is
an order-preserving homomorphism of the additive semigroup of positive elements,
its positive side can be extended to an order-preserving homomorphism $\phi$ of the whole additive group.

To reduce the number of cases that have to be considered, we sneak up on this slowly.
We first show that the semigroup homomorphism can be extended to 
homomorphism of the non-negative monoid
(by defining $\phi(0) = 0$). The following portmanteau lemma
helps to eliminate the various cases in this.

=SML
val €eq_order_thm› = prove_rule[]¨µy x∑x = y § y = xÆ;
val €Ø_opah_extension_lemmas1› = (
push_goal([], ¨µv w∑
	(v < w ¥ ≥w < v ± ≥v = w ± ≥w = v)
± 	(ÓØ 0 < v ± ÓØ 0 < w ¥ ≥v + w = ÓØ 0 ± ≥ÓØ 0 = v + w)
Æ);
a(REPEAT µ_tac);
a(rewrite_tac[µ_elim¨ÓØ 0Æeq_order_thm, µ_elim¨vÆeq_order_thm] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(contr_tac THEN all_fc_tac[Ø_less_antisym_thm]);
(* *** Goal "2" *** *)
a(all_fc_tac[Ø_less_≥_eq_thm]);
(* *** Goal "3" *** *)
a(LEMMA_T ¨ÓØ 0 + ÓØ 0 < v + wÆ ante_tac THEN1
	(bc_thm_tac Ø_plus_mono_thm2 THEN REPEAT strip_tac));
a(rewrite_tac[Ø_plus_clauses] THEN REPEAT strip_tac THEN all_fc_tac[Ø_less_≥_eq_thm]);
pop_thm()
);
=TEX
Now here is the extension to the non-negative monoid.
=SML
val €Ø_opah_extension_thm1› = (
set_goal([], ¨µf∑
		(µx y∑ÓØ 0 < x ± ÓØ 0 < y ¥ f (x + y) = f x + f y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < f x)
	¥	∂∆∑
		(∆ (ÓØ 0) = ÓØ 0)
	±	(µx∑ ÓØ 0 < x ¥ ∆ x = f x)
	±	(µx y∑ÓØ 0 º x ± ÓØ 0 º y ¥ ∆ (x + y) = ∆ x + ∆ y)
Æ);
a(REPEAT strip_tac);
a(∂_tac¨Ãx∑if x = ÓØ 0 then ÓØ 0 else f xÆ
	THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_fc_tac[Ø_opah_extension_lemmas1] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN rewrite_tac[Ø_º_def]
	THEN REPEAT strip_tac THEN
	TRY all_var_elim_asm_tac1 THEN
	all_asm_fc_tac[] THEN
	all_fc_tac[Ø_opah_extension_lemmas1] THEN
	asm_rewrite_tac[Ø_plus_clauses]);
save_pop_thm"Ø_opah_extension_thm1"
);
=TEX
=SML
val €Ø_opah_extension_thm2› = (
set_goal([], ¨µf∑
		(f (ÓØ 0) = ÓØ 0)
	±	(µx y∑ÓØ 0 º x ± ÓØ 0 º y ¥ f (x + y) = f x + f y)
	¥	∂Ÿ∑
		(µx∑ ÓØ 0 º x ¥ Ÿ x = f x)
	±	(µx y∑Ÿ (x + y) = Ÿ x + Ÿ y)
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨∂∆∑µx∑ ∆ x = if ÓØ 0 º x then f x else ~(f (~x))Æ THEN1 prove_∂_tac);
a(∂_tac¨∆Æ THEN ±_tac);
(* *** Goal "1" *** *)
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(bc_thm_tac Ø_add_hom_extension_thm THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(lemma_tac¨ÓØ 0 º x + yÆ THEN1
	(bc_thm_tac Ø_º_trans_thm THEN ∂_tac¨xÆ THEN asm_rewrite_tac[Ø_º_clauses]));
a(asm_rewrite_tac[]);
a(ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[Ø_minus_clauses]);
a(cases_tac¨ÓØ 0 º ~ xÆ THEN asm_rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o
	rewrite_rule[Ø_plus_clauses, Ø_minus_clauses] o once_rewrite_rule[Ø_º_º_0_thm]));
a(lemma_tac ¨x = ÓØ 0Æ THEN1 asm_rewrite_tac[Ø_eq_º_thm] THEN asm_rewrite_tac[Ø_minus_clauses]);
save_pop_thm"Ø_opah_extension_thm2"
);
=TEX
Now here is the extension to the whole group, in which, for convenience in using
the theorem, we explicitly include the fact that the result is is order-presereving
as part of the conclusion.
=SML
val €Ø_opah_extension_thm› = (
set_goal([], ¨µf∑
		(µx y∑ÓØ 0 < x ± ÓØ 0 < y ¥ f (x + y) = f x + f y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < f x)
	¥	∂∆∑
		(µx∑ ÓØ 0 < x ¥ ∆ x = f x)
	±	(µx y∑∆ (x + y) = ∆ x + ∆ y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < ∆ x)
Æ);
a(REPEAT strip_tac);
a(once_rewrite_tac[taut_rule¨µp1 p2 p3∑ p1 ± p2 ± p3 § p1 ± p2 ± (p1 ¥ p3)Æ]);
a(all_fc_tac[Ø_opah_extension_thm1]);
a(all_fc_tac[Ø_opah_extension_thm2]);
a(∂_tac¨ŸÆ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨ÓØ 0 º xÆ THEN1 asm_rewrite_tac[Ø_º_def]);
a(ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "2" *** *)
a(ALL_ASM_FC_T rewrite_tac[]);
save_pop_thm"Ø_opah_extension_thm"
);
=TEX
\subsection{Ordering of the Order-preserving Additive Homomorphisms}
The abundance of central order-preserving homomorphisms now lets
us show that if $f$ and $g$ are OPAHs and $f(d) < g(d)$ for some positive $d$,
then $f(x) < g(x)$ for every positive $x$.

=SML
val €Ø_opah_order_thm› = (
set_goal([], ¨µf g d∑
		(µx y∑f (x + y) = f x + f y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < f x)
	±	(µx y∑g (x + y) = g x + g y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < g x)
	±	ÓØ 0 < d
	±	f d < g d
	¥	(µx∑ÓØ 0 < x ¥ f x < g x)
Æ);
a(REPEAT µ_tac THEN REPEAT_UNTIL is_µ strip_tac);
a(lemma_tac¨µx∑ÓØ 0 < x ¥ f x º g xÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(contr_tac THEN POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(lemma_tac¨ÓØ 0 < g x ± ÓØ 0 < g dÆ THEN1 ALL_ASM_FC_T rewrite_tac[]);
a(strip_asm_tac(list_µ_elim[¨g dÆ, ¨g xÆ, ¨f xÆ]Ø_copah_dense_thm));
a(lemma_tac¨µx∑ « (f x) = f (« x)Æ THEN1
	(GET_NTH_ASM_T 3 bc_thm_tac THEN asm_rewrite_tac[]));
a(lemma_tac¨µx∑ « (g x) = g (« x)Æ THEN1
	(GET_NTH_ASM_T 4 bc_thm_tac THEN asm_rewrite_tac[]));
a(GET_NTH_ASM_T 4 ante_tac THEN TOP_ASM_T rewrite_thm_tac THEN contr_tac);
a(all_fc_tac[Ø_opah_strict_thm]);
a(lemma_tac¨f x < «(f d)Æ THEN1 (ALL_FC_T asm_rewrite_tac[Ø_opah_thm]));
a(LEMMA_T¨f x < f xÆ (strip_asm_tac o rewrite_rule[Ø_less_irrefl_thm]));
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac ¨«(f d)Æ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac ¨«(g d)Æ THEN REPEAT strip_tac);
a(all_fc_tac[Ø_opah_thm]);
(* *** Goal "2" *** *)
a(contr_tac THEN POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
a(spec_nth_asm_tac 3 ¨xÆ);
a(lemma_tac¨f x = g xÆ THEN1 asm_rewrite_tac[Ø_eq_º_thm]);
a(strip_asm_tac (µ_elim¨f dÆ Ø_unbounded_above_thm));
a(lemma_tac¨ÓØ 0 < f x ± ÓØ 0 < f dÆ THEN1 ALL_ASM_FC_T rewrite_tac[]);
a(strip_asm_tac(list_µ_elim[¨f xÆ, ¨f dÆ, ¨yÆ]Ø_copah_dense_thm));
a(lemma_tac¨µx∑ « (f x) = f (« x)Æ THEN1
	(DROP_ASM_T ¨f x = g xÆ discard_tac THEN GET_NTH_ASM_T 3 bc_thm_tac
		THEN asm_rewrite_tac[]));
a(lemma_tac¨µx∑ « (g x) = g (« x)Æ THEN1
	(DROP_ASM_T ¨f x = g xÆ discard_tac THEN GET_NTH_ASM_T 4 bc_thm_tac
		THEN asm_rewrite_tac[]));
a(LEMMA_T¨« (f x) = «(g x)Æ ante_tac THEN1 GET_NTH_ASM_T 11 rewrite_thm_tac);
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
a(contr_tac THEN lemma_tac¨d < « xÆ THEN1 all_fc_tac[Ø_opah_strict_thm]);
a(POP_ASM_T (strip_asm_tac o once_rewrite_rule[Ø_less_0_less_thm]));
a(lemma_tac ¨g(« x + ~ d) < f(« x + ~d)Æ);
(* *** Goal "2.1" *** *)
a(asm_rewrite_tac[Ø_less_clauses]);
a(GET_ASM_T ¨f d < g dÆ ante_tac);
a(ALL_FC_T rewrite_tac[Ø_add_hom_minus_thm]);
a(once_rewrite_tac[Ø_less_0_less_thm]);
a(rewrite_tac[Ø_minus_clauses, µ_elim¨~(f d)Æ Ø_plus_order_thm]);
a(spec_nth_asm_tac 18 ¨« x + ~ dÆ);
a(all_fc_tac[Ø_less_º_trans_thm] THEN all_fc_tac[Ø_less_irrefl_thm]);
save_pop_thm"Ø_opah_order_thm"
);
=TEX
It is an easy consequence of the above that if two OPAHs agree at any positive value
then they agree everywhere and so are equal:

=SML
val €Ø_opah_eq_thm› = (
set_goal([], ¨µf g d∑
		(µx y∑f (x + y) = f x + f y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < f x)
	±	(µx y∑g (x + y) = g x + g y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < g x)
	±	ÓØ 0 < d
	±	f d = g d
	¥	f = g
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨(µy∑ÓØ 0 < y ¥ f y = g y) ¥ f = gÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[ext_thm] THEN REPEAT strip_tac);
a(strip_asm_tac (list_µ_elim[¨ÓØ 0Æ, ¨xÆ] Ø_less_cases_thm));
(* *** Goal "1.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "1.2" *** *)
a(all_var_elim_asm_tac1 THEN ALL_FC_T rewrite_tac[Ø_add_hom_0_thm]);
(* *** Goal "1.3" *** *)
a(POP_ASM_T (strip_asm_tac o
	rewrite_rule[Ø_plus_clauses] o once_rewrite_rule[Ø_less_0_less_thm]));
a(spec_nth_asm_tac 2 ¨~xÆ THEN POP_ASM_T ante_tac);
a(ALL_FC_T rewrite_tac[Ø_add_hom_minus_thm]);
a(conv_tac (LEFT_C eq_sym_conv));
a(once_rewrite_tac[Ø_eq_thm]);
a(rewrite_tac[Ø_minus_clauses, µ_elim¨f xÆ Ø_plus_order_thm]);
(* *** Goal "2" *** *)
a(strip_asm_tac (list_µ_elim[¨f yÆ, ¨g yÆ] Ø_less_cases_thm));
(* *** Goal "2.1" *** *)
a(all_fc_tac[Ø_opah_order_thm]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[Ø_less_irrefl_thm]);
(* *** Goal "2.2" *** *)
a(rename_tac[(¨gÆ, "gg"), (¨fÆ, "ff")] THEN all_fc_tac[Ø_opah_order_thm]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[Ø_less_irrefl_thm]);
save_pop_thm"Ø_opah_eq_thm"
);
=TEX
\subsection{Completeness of the Order-preserving Homomorphisms}
We have shown that the images of any given positive number under
a (central) order-preserving additive homomorphism are dense in
the set of real numbers. We now show that this image is complete.
The main lemma is that all the above is true if we restrict
our attention entirely to the semigroup of positive reals:
=SML
val €Ø_opah_complete_lemma› = (
set_goal([], ¨µd e∑
		ÓØ 0 < d
	±	ÓØ 0 < e
	¥	∂f∑
		(µx y∑ÓØ 0 < x ± ÓØ 0 < y ¥ f (x + y) = f x + f y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < f x)
	±	f d = e
Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨∂‘∑µv∑
	‘ v =	{t | ∂g∑	(µx y∑g (x + y) = g x + g y)
		±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < g x)
		±	g d < e
		±	t < g v}
Æ THEN1 prove_∂_tac);
a(lemma_tac¨µv∑≥‘ v = {}Æ);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[] THEN PC_T1 "sets_ext" REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨ÓØ 0Æ, ¨eÆ]Ø_less_dense_thm));
a(strip_asm_tac(list_µ_elim[¨dÆ, ¨zÆ, ¨eÆ]Ø_copah_dense_thm));
a(strip_asm_tac(µ_elim¨« vÆØ_unbounded_below_thm));
a(∂_tac¨yÆ THEN rewrite_tac[]);
a(∂_tac¨«Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨µv∑ÓØ 0 < v ¥ ∂b∑µs∑s ç ‘ v ¥ s º bÆ);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨eÆØ_unbounded_above_thm));
a(strip_asm_tac(list_µ_elim[¨dÆ, ¨eÆ, ¨yÆ]Ø_copah_dense_thm));
a(∂_tac¨« vÆ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(rewrite_tac[Ø_º_def] THEN ≤_left_tac);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac ¨g vÆ THEN REPEAT strip_tac);
a(lemma_tac ¨g d < « dÆ THEN1 all_fc_tac[Ø_less_trans_thm]);
a(ante_tac(list_µ_elim[¨gÆ, ¨«Æ, ¨dÆ]Ø_opah_order_thm));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¨vÆ);
(* *** Goal "2.2" *** *)
a(∂_tac¨Ãz∑ Sup (‘ z)Æ THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(lemma_tac¨∂ xb∑ µ s∑ s ç ‘ x ¥ s º xbÆ THEN1
	(spec_nth_asm_tac 3 ¨xÆ THEN ∂_tac¨b:ØÆ THEN asm_rewrite_tac[]));
a(lemma_tac¨∂ yb∑ µ s∑ s ç ‘ y ¥ s º ybÆ THEN1
	(spec_nth_asm_tac 4 ¨yÆ THEN ∂_tac¨b:ØÆ THEN asm_rewrite_tac[]));
a(ante_tac(list_µ_elim[¨‘ xÆ, ¨xbÆ, ¨‘ yÆ, ¨ybÆ]Ø_sup_plus_sup_thm));
a(LIST_GET_NTH_ASM_T [1, 2, 6] rewrite_tac);
a(STRIP_T rewrite_thm_tac);
a(LEMMA_T ¨‘ (x + y) = {t|∂ a b∑ a ç ‘ x ± b ç ‘ y ± t < a + b}Æ rewrite_thm_tac);
a(PC_T1 "sets_ext" asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.2.1.1" *** *)
a(∂_tac ¨g xÆ THEN ∂_tac ¨g yÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.1.1.1" *** *)
a(spec_nth_asm_tac 3 ¨dÆ);
a(strip_asm_tac(list_µ_elim[¨dÆ, ¨g dÆ, ¨eÆ]Ø_copah_dense_thm));
a(∂_tac¨«Æ THEN asm_rewrite_tac[]);
a(ante_tac(list_µ_elim[¨gÆ, ¨«Æ, ¨dÆ]Ø_opah_order_thm) THEN asm_rewrite_tac[]);
a(STRIP_T (fn th => all_fc_tac[th]));
(* *** Goal "2.2.1.1.2" *** *)
a(spec_nth_asm_tac 3 ¨dÆ);
a(strip_asm_tac(list_µ_elim[¨dÆ, ¨g dÆ, ¨eÆ]Ø_copah_dense_thm));
a(∂_tac¨«Æ THEN asm_rewrite_tac[]);
a(ante_tac(list_µ_elim[¨gÆ, ¨«Æ, ¨dÆ]Ø_opah_order_thm) THEN asm_rewrite_tac[]);
a(STRIP_T (fn th => all_fc_tac[th]));
(* *** Goal "2.2.1.1.3" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.1.2" *** *)
a(strip_asm_tac(list_µ_elim[¨g dÆ, ¨g' dÆ]Ø_less_cases_thm));
(* *** Goal "2.2.1.2.1" *** *)
a(∂_tac¨g'Æ THEN asm_rewrite_tac[]);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨a + bÆ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_plus_mono_thm2 THEN REPEAT strip_tac);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨g xÆ THEN REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨gÆ, ¨g'Æ, ¨dÆ]Ø_opah_order_thm));
a(asm_rewrite_tac[] THEN STRIP_T (fn th => all_fc_tac[th]));
(* *** Goal "2.2.1.2.2" *** *)
a(ante_tac(list_µ_elim[¨gÆ, ¨g'Æ, ¨dÆ]Ø_opah_eq_thm));
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
a(var_elim_asm_tac ¨g = g'Æ);
a(∂_tac¨g'Æ THEN asm_rewrite_tac[]);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨a + bÆ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_plus_mono_thm2 THEN REPEAT strip_tac);
(* *** Goal "2.2.1.2.3" *** *)
a(∂_tac¨gÆ THEN asm_rewrite_tac[]);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨a + bÆ THEN REPEAT strip_tac);
a(bc_thm_tac Ø_plus_mono_thm2 THEN REPEAT strip_tac);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨g' yÆ THEN REPEAT strip_tac);
a(ante_tac(list_µ_elim[¨g'Æ, ¨gÆ, ¨dÆ]Ø_opah_order_thm));
a(asm_rewrite_tac[] THEN STRIP_T (fn th => all_fc_tac[th]));
(* *** Goal "2.2.2" *** *)
a(bc_thm_tac Ø_less_sup_bc_thm THEN REPEAT strip_tac THEN1 asm_rewrite_tac[]);
(* *** Goal "2.2.2.1" *** *)
a(SPEC_NTH_ASM_T 2 ¨xÆ ante_tac THEN TOP_ASM_T rewrite_thm_tac);
(* *** Goal "2.2.2.2" *** *)
a(asm_rewrite_tac[] THEN PC_T1 "sets_ext" REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨ÓØ 0Æ, ¨eÆ]Ø_less_dense_thm));
a(strip_asm_tac(list_µ_elim[¨dÆ, ¨zÆ, ¨eÆ]Ø_copah_dense_thm));
a(spec_nth_asm_tac 4 ¨xÆ);
a(strip_asm_tac(list_µ_elim[¨ÓØ 0Æ, ¨« xÆ]Ø_less_dense_thm));
a(∂_tac ¨z'Æ THEN REPEAT strip_tac);
a(∂_tac ¨«Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.3" *** *)
a(bc_thm_tac Ø_sup_eq_bc_thm THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.2.3.1" *** *)
a(rewrite_tac[Ø_º_def] THEN ALL_FC_T rewrite_tac[Ø_less_trans_thm]);
(* *** Goal "2.2.3.2" *** *)
a(contr_tac THEN POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_º_less_thm]));
a(lemma_tac¨∂w∑ x < w ± ÓØ 0 < w ± w < eÆ);
(* *** Goal "2.2.3.2.1" *** *)
a(cases_tac¨ÓØ 0 < xÆ);
(* *** Goal "2.2.3.2.1.1" *** *)
a(strip_asm_tac(list_µ_elim[¨xÆ, ¨eÆ]Ø_less_dense_thm));
a(∂_tac ¨zÆ THEN REPEAT strip_tac THEN all_fc_tac[Ø_less_trans_thm]);
(* *** Goal "2.2.3.2.1.2" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_≥_less_º_thm]));
a(strip_asm_tac(list_µ_elim[¨ÓØ 0Æ, ¨eÆ]Ø_less_dense_thm));
a(∂_tac ¨zÆ THEN REPEAT strip_tac THEN all_fc_tac[Ø_º_less_trans_thm]);
(* *** Goal "2.2.3.2.2" *** *)
a(strip_asm_tac(list_µ_elim[¨dÆ, ¨wÆ, ¨eÆ]Ø_copah_dense_thm));
a(swap_nth_asm_concl_tac 10 THEN REPEAT strip_tac);
a(∂_tac¨wÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.3.2.2.1" *** *)
a(∂_tac¨«Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.3.2.2.2" *** *)
a(asm_rewrite_tac[Ø_≥_º_less_thm]);
pop_thm()
);
=TEX
The lemma and earlier results on extending homomorphisms gives us the desired
result:
=SML
val €Ø_opah_complete_thm› = (
set_goal([], ¨µd e∑
		ÓØ 0 < d
	±	ÓØ 0 < e
	¥	∂f∑
		(µx y∑f (x + y) = f x + f y)
	±	(µx∑ ÓØ 0 < x ¥ ÓØ 0 < f x)
	±	f d = e
Æ);
a(REPEAT strip_tac);
a(strip_asm_tac(list_µ_elim[¨dÆ, ¨eÆ]Ø_opah_complete_lemma));
a(all_fc_tac[Ø_opah_extension_thm]);
a(∂_tac¨∆Æ THEN asm_rewrite_tac[]);
a(spec_nth_asm_tac 3 ¨dÆ THEN asm_rewrite_tac[]);
save_pop_thm"Ø_opah_complete_thm"
);
=TEX
\subsection{Consistency of Multiplication}
We can now prove the consistency of multiplication.
As so often, we need to sneak up on this slowly.
What follows is essentially the argument of sections 3.5 and 4.2 of Behrend's paper
``A contribution to the theory of magnitudes and the foundations
of analysis''.
=SML
val €Ø_times_consistent_lemma1› = (
set_goal([], ¨∂ —∑
		(µ x v w∑ ÓØ 0 < x ¥ — x (v + w) = — x v + — x w)
	±	(µ x v∑ ÓØ 0 < x ± ÓØ 0 < v ¥ ÓØ 0 < — x v)
	±	(µ x∑ ÓØ 0 < x ¥ — x (ÓØ 1) = x)
Æ);
a(prove_∂_tac);
a(lemma_tac ¨ÓØ 0 < ÓØ 1Æ THEN1 rewrite_tac[Ø_less_clauses] THEN strip_tac);
a(cases_tac¨≥ÓØ 0 < x'Æ THEN1 asm_rewrite_tac[]);
a(strip_asm_tac(list_µ_elim[¨ÓØ 1Æ, ¨x'Æ]Ø_opah_complete_thm) THEN1 asm_rewrite_tac[]);
a(∂_tac¨fÆ THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val €Ø_times_consistent_lemma2› = (
set_goal([], ¨∂ Œ∑
		(µ x v w∑ ÓØ 0 < x ¥ Œ x (v + w) = Œ x v + Œ x w)
	±	(µ x y v∑ ÓØ 0 < x ± ÓØ 0 < y ¥ Œ (x + y) v = Œ x v + Œ y v)
	±	(µ x v∑ ÓØ 0 < x ± ÓØ 0 < v ¥ ÓØ 0 < Œ x v)
	±	(µ x∑ ÓØ 0 < x ¥ Œ x (ÓØ 1) = x)
	±	(µ v∑ Œ (ÓØ 1) v = v)
Æ);
a(strip_asm_tac Ø_times_consistent_lemma1);
a(∂_tac¨—Æ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨ÓØ 0 < x + yÆ THEN1
	(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨xÆ THEN asm_rewrite_tac[Ø_less_clauses]));
a(SPEC_NTH_ASM_T 6 ¨x+yÆ ante_tac THEN TOP_ASM_T rewrite_thm_tac THEN strip_tac);
a(SPEC_NTH_ASM_T 6 ¨x+yÆ ante_tac THEN GET_NTH_ASM_T 2 rewrite_thm_tac THEN strip_tac);
a(SPEC_NTH_ASM_T 8 ¨xÆ ante_tac THEN GET_NTH_ASM_T 5 rewrite_thm_tac THEN strip_tac);
a(SPEC_NTH_ASM_T 8 ¨xÆ ante_tac THEN GET_NTH_ASM_T 6 rewrite_thm_tac THEN strip_tac);
a(SPEC_NTH_ASM_T 10 ¨yÆ ante_tac THEN GET_NTH_ASM_T 6 rewrite_thm_tac THEN strip_tac);
a(SPEC_NTH_ASM_T 10 ¨yÆ ante_tac THEN GET_NTH_ASM_T 7 rewrite_thm_tac THEN strip_tac);
a(lemma_tac¨∂ÿ∑µa∑ÿ a = — x a + — y aÆ THEN1 prove_∂_tac);
a(lemma_tac¨µa b∑ÿ (a + b) = ÿ a + ÿ bÆ THEN1 asm_rewrite_tac[]);
(* *** Goal "1.1" *** *)
a(REPEAT strip_tac);
a(rewrite_tac[µ_elim¨— y aÆØ_plus_order_thm]);
a(rewrite_tac[Ø_plus_assoc_thm]);
(* *** Goal "1.2" *** *)
a(lemma_tac¨µa∑ÓØ 0 < a ¥ ÓØ 0 < ÿ aÆ THEN1 (REPEAT strip_tac THEN asm_rewrite_tac[]));
(* *** Goal "1.2.1" *** *)
a(spec_nth_asm_tac 6 ¨aÆ THEN spec_nth_asm_tac 5 ¨aÆ);
a(bc_thm_tac Ø_less_trans_thm THEN ∂_tac ¨— x aÆ THEN asm_rewrite_tac[Ø_less_clauses]);
(* *** Goal "1.2.2" *** *)
a(spec_nth_asm_tac 13 ¨x+yÆ THEN spec_nth_asm_tac 14 ¨xÆ THEN spec_nth_asm_tac 15 ¨yÆ);
a(lemma_tac¨ÿ (ÓØ 1) = — (x + y) (ÓØ 1)Æ THEN1 asm_rewrite_tac[]);
a(lemma_tac ¨ÓØ 0 < ÓØ 1Æ THEN1 rewrite_tac[Ø_less_clauses]);
a(all_fc_tac[Ø_opah_eq_thm]);
a(all_var_elim_asm_tac1 THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac ¨ÓØ 0 < ÓØ 1Æ THEN1 rewrite_tac[Ø_less_clauses]);
a(SPEC_NTH_ASM_T 4 ¨ÓØ 1Æ ante_tac THEN GET_NTH_ASM_T 1 rewrite_thm_tac THEN strip_tac);
a(SPEC_NTH_ASM_T 4 ¨ÓØ 1Æ ante_tac THEN GET_NTH_ASM_T 2 rewrite_thm_tac THEN strip_tac);
a(spec_nth_asm_tac 4 ¨ÓØ 1Æ);
a(strip_asm_tac Ø_copah_id_thm);
a(lemma_tac¨… (ÓØ 1) = — (ÓØ 1) (ÓØ 1)Æ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[Ø_opah_eq_thm]);
a(all_var_elim_asm_tac1 THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val €Ø_times_consistent_lemma3› = (
set_goal([], ¨∂ –∑
		(µ x v w∑ ÓØ 0 º x ¥ – x (v + w) = – x v + – x w)
	±	(µ x y v∑ ÓØ 0 º x ± ÓØ 0 º y ¥ – (x + y) v = – x v + – y v)
	±	(µ x v∑ ÓØ 0 < x ± ÓØ 0 < v ¥ ÓØ 0 < – x v)
	±	(µ x∑ ÓØ 0 º x ¥ – x (ÓØ 1) = x)
	±	(µ v∑ – (ÓØ 1) v = v)
	±	(µ v∑ – (ÓØ 0) v = ÓØ 0)
Æ);
a(strip_asm_tac Ø_times_consistent_lemma2);
a(∂_tac¨Ãx v∑if x = ÓØ 0 then ÓØ 0 else Œ x vÆ
	THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(cases_tac ¨x = ÓØ 0Æ THEN asm_rewrite_tac[Ø_plus_clauses]);
a(POP_ASM_T (strip_asm_tac o conv_rule (ONCE_MAP_C eq_sym_conv)));
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[Ø_º_def] THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(cases_tac ¨x = ÓØ 0Æ THEN asm_rewrite_tac[Ø_plus_clauses]);
a(cases_tac ¨y = ÓØ 0Æ THEN asm_rewrite_tac[Ø_plus_clauses]);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o conv_rule (ONCE_MAP_C eq_sym_conv)));
a(DROP_NTH_ASM_T 2 (strip_asm_tac o conv_rule (ONCE_MAP_C eq_sym_conv)));
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[Ø_º_def] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[Ø_º_def] THEN REPEAT strip_tac);
a(lemma_tac¨ÓØ 0 < x + yÆ THEN1
	(bc_thm_tac Ø_less_trans_thm THEN ∂_tac¨xÆ THEN asm_rewrite_tac[Ø_less_clauses]));
a(LEMMA_T¨≥x + y = ÓØ 0Æ rewrite_thm_tac THEN1
	(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[Ø_less_clauses]));
a(ALL_ASM_FC_T rewrite_tac[]);
(* *** Goal "3" *** *)
a(LEMMA_T¨≥x = ÓØ 0Æ rewrite_thm_tac THEN1
	(swap_nth_asm_concl_tac 2 THEN asm_rewrite_tac[Ø_less_clauses]));
a(all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(cases_tac ¨x = ÓØ 0Æ THEN asm_rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o conv_rule (ONCE_MAP_C eq_sym_conv)));
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[Ø_º_def]);
(* *** Goal "5" *** *)
a(asm_rewrite_tac[Ø_plus_clauses]);
pop_thm()
);
=TEX
=SML
val €Ø_times_consistent_lemma4› = (
set_goal([], ¨∂ ◊∑
		(µ x v w∑ ◊ x (v + w) = ◊ x v + ◊ x w)
	±	(µ x y v∑ ◊ (x + y) v = ◊ x v + ◊ y v)
	±	(µ x v∑ ÓØ 0 < x ± ÓØ 0 < v ¥ ÓØ 0 < ◊ x v)
	±	(µ x∑ ◊ x (ÓØ 1) = x)
	±	(µ v∑ ◊ (ÓØ 1) v = v)
Æ);
a(strip_asm_tac Ø_times_consistent_lemma3);
a(lemma_tac¨∂∆∑µx v∑∆ v x = if ÓØ 0 º x then – x v else ~(– (~x) v)Æ THEN1 prove_∂_tac);
a(∂_tac¨Ãx v∑∆ v xÆ THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(cases_tac¨ÓØ 0 º xÆ THEN ALL_ASM_FC_T asm_rewrite_tac[]);
a(all_fc_tac[Ø_º_cases_thm]);
a(POP_ASM_T (strip_asm_tac o
	rewrite_rule[Ø_plus_clauses] o once_rewrite_rule[Ø_º_0_º_thm]));
a(ALL_ASM_FC_T rewrite_tac[]);
a(rewrite_tac[Ø_minus_clauses]);
(* *** Goal "2" *** *)
a(lemma_tac¨(µx y∑ÓØ 0 º x ± ÓØ 0 º y ¥ ∆ v (x + y) = ∆ v x + ∆ v y)
	±	(µ x∑ ÓØ 0 º x ¥ ∆ v (~ x) = ~ (∆ v x))	Æ);
(* *** Goal "2.1" *** *)
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(lemma_tac¨ÓØ 0 º x + yÆ THEN1
	(bc_thm_tac Ø_º_trans_thm THEN ∂_tac¨xÆ THEN asm_rewrite_tac[Ø_º_clauses]));
a(ALL_ASM_FC_T asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a(cases_tac ¨ÓØ 0 º ~xÆ THEN
	ALL_ASM_FC_T asm_rewrite_tac[] THEN_TRY rewrite_tac[Ø_minus_clauses]);
a(POP_ASM_T (strip_asm_tac o
	rewrite_rule[Ø_plus_clauses, Ø_minus_clauses] o once_rewrite_rule[Ø_º_º_0_thm]));
a(lemma_tac¨x = ÓØ 0Æ THEN1 asm_rewrite_tac[Ø_eq_º_thm]);
a(all_var_elim_asm_tac1);
a(asm_rewrite_tac[Ø_minus_clauses]);
(* *** Goal "2.2" *** *)
a(ALL_FC_T rewrite_tac[Ø_add_hom_extension_thm]);
(* *** Goal "3" *** *)
a(DROP_NTH_ASM_T 3 rewrite_thm_tac);
a(LEMMA_T ¨ÓØ 0 º xÆ rewrite_thm_tac THEN1 asm_rewrite_tac[Ø_º_def]);
a(all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(cases_tac¨ÓØ 0 º xÆ THEN ALL_ASM_FC_T asm_rewrite_tac[]);
a(all_fc_tac[Ø_º_cases_thm]);
a(POP_ASM_T (strip_asm_tac o
	rewrite_rule[Ø_plus_clauses] o once_rewrite_rule[Ø_º_0_º_thm]));
a(ALL_ASM_FC_T rewrite_tac[]);
a(rewrite_tac[Ø_minus_clauses]);
(* *** Goal "5" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(asm_rewrite_tac[Ø_º_clauses]);
pop_thm()
);
=TEX
=SML
val €Ø_times_consistent_lemma5› = (
set_goal([], ¨∂ ◊∑
		(µ x v w∑ ◊ x (v + w) = ◊ x v + ◊ x w)
	±	(µ x y v∑ ◊ (x + y) v = ◊ x v + ◊ y v)
	±	(µ x v∑ ÓØ 0 < x ± ÓØ 0 < v ¥ ÓØ 0 < ◊ x v)
	±	(µ x∑ ◊ x (ÓØ 1) = x)
	±	(µ v∑ ◊ (ÓØ 1) v = v)
	±	(µ x∑ ◊ x (ÓØ 0) = ÓØ 0 ± ◊ (ÓØ 0) x = ÓØ 0)
	±	(µ x y∑ ◊ x (~y) = ~(◊ x y) ± ◊ (~x) y = ~(◊ x y))
Æ);
a(strip_asm_tac Ø_times_consistent_lemma4);
a(∂_tac¨◊Æ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 5 ¨xÆ THEN all_fc_tac[Ø_add_hom_0_thm]);
(* *** Goal "2" *** *)
a(lemma_tac¨∂∆∑µv∑∆ v = ◊ v xÆ THEN1 prove_∂_tac);
a(lemma_tac¨µ v w∑ ∆ (v + w) = ∆ v + ∆ wÆ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[Ø_add_hom_0_thm]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¨∂∆∑µv∑∆ v = ◊ x vÆ THEN1 prove_∂_tac);
a(lemma_tac¨µ v w∑ ∆ (v + w) = ∆ v + ∆ wÆ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[Ø_add_hom_minus_thm]);
a(rename_tac[] THEN POP_ASM_T ante_tac THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(lemma_tac¨∂∆∑µv∑∆ v = ◊ v yÆ THEN1 prove_∂_tac);
a(lemma_tac¨µ v w∑ ∆ (v + w) = ∆ v + ∆ wÆ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[Ø_add_hom_minus_thm]);
a(rename_tac[] THEN POP_ASM_T ante_tac THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val €Ø_times_consistent_lemma6› = (
set_goal([], ¨∂ ◊∑
		(µ x v w∑ ◊ x (v + w) = ◊ x v + ◊ x w)
	±	(µ x y v∑ ◊ (x + y) v = ◊ x v + ◊ y v)
	±	(µ x v∑ ÓØ 0 < x ± ÓØ 0 < v ¥ ÓØ 0 < ◊ x v)
	±	(µ x∑ ◊ x (ÓØ 1) = x)
	±	(µ v∑ ◊ (ÓØ 1) v = v)
	±	(µ x∑ ◊ x (ÓØ 0) = ÓØ 0 ± ◊ (ÓØ 0) x = ÓØ 0)
	±	(µ x y∑ ◊ x (~y) = ~(◊ x y) ± ◊ (~x) y = ~(◊ x y))
	±	(µ x y z∑ ◊ (◊ x y) z = ◊ x (◊ y z))
Æ);
a(strip_asm_tac Ø_times_consistent_lemma5);
a(∂_tac¨◊Æ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(cases_tac¨x = ÓØ 0 ≤ z = ÓØ 0Æ THEN_TRY asm_rewrite_tac[]);
a(lemma_tac¨µv w∑ ÓØ 0 < v ± ÓØ 0 < w ¥◊ (◊ v y) w = ◊ v (◊ y w) Æ THEN1 REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨∂ÿ∑µa∑ÿ a = ◊ (◊ v a) wÆ THEN1 prove_∂_tac);
a(lemma_tac¨µa b∑ÿ (a + b) = ÿ a + ÿ bÆ THEN1 asm_rewrite_tac[]);
a(lemma_tac¨µa∑ÓØ 0 < a ¥ ÓØ 0 < ÿ aÆ THEN1 (REPEAT strip_tac THEN asm_rewrite_tac[]));
(* *** Goal "1.1" *** *)
a(GET_NTH_ASM_T 12 bc_thm_tac THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 12 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(lemma_tac¨∂»∑µa∑» a = ◊ v (◊ a w)Æ THEN1 prove_∂_tac);
a(lemma_tac¨µa b∑» (a + b) = » a + » bÆ THEN1 asm_rewrite_tac[]);
a(lemma_tac¨µa∑ÓØ 0 < a ¥ ÓØ 0 < » aÆ THEN1 (REPEAT strip_tac THEN asm_rewrite_tac[]));
(* *** Goal "1.2.1" *** *)
a(GET_NTH_ASM_T 15 bc_thm_tac THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 15 bc_thm_tac THEN REPEAT strip_tac);
(* *** Goal "1.2.2" *** *)
a(lemma_tac ¨ÓØ 0 < ÓØ 1Æ THEN1 rewrite_tac[Ø_less_clauses]);
a(lemma_tac¨ÿ (ÓØ 1) = » (ÓØ 1)Æ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[Ø_opah_eq_thm]);
a(LEMMA_T¨ÿ y = » yÆ ante_tac THEN1 TOP_ASM_T rewrite_thm_tac);
a(LIST_GET_NTH_ASM_T [6, 9] rewrite_tac);
(* *** Goal "2" *** *)
a(strip_asm_tac (list_µ_elim[¨xÆ, ¨ÓØ 0Æ]Ø_less_cases_thm) THEN
	strip_asm_tac (list_µ_elim[¨zÆ, ¨ÓØ 0Æ]Ø_less_cases_thm) THEN
	POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN
	once_rewrite_tac[Ø_less_0_less_thm] THEN
	rewrite_tac[Ø_plus_clauses, Ø_minus_clauses] THEN
	REPEAT strip_tac THEN
	LIST_GET_NTH_ASM_T [3] (ALL_FC_T (MAP_EVERY ante_tac)) THEN_TRY
	asm_rewrite_tac[Ø_minus_clauses, Ø_minus_eq_thm] THEN
	taut_tac);
pop_thm()
);
=TEX
=SML
val €Ø_times_consistent_lemma7› = (
set_goal([], ¨∂ ◊∑
		(µ x v w∑ ◊ x (v + w) = ◊ x v + ◊ x w)
	±	(µ x y v∑ ◊ (x + y) v = ◊ x v + ◊ y v)
	±	(µ x v∑ ÓØ 0 < x ± ÓØ 0 < v ¥ ÓØ 0 < ◊ x v)
	±	(µ x∑ ◊ x (ÓØ 1) = x)
	±	(µ v∑ ◊ (ÓØ 1) v = v)
	±	(µ x∑ ◊ x (ÓØ 0) = ÓØ 0 ± ◊ (ÓØ 0) x = ÓØ 0)
	±	(µ x y∑ ◊ x (~y) = ~(◊ x y) ± ◊ (~x) y = ~(◊ x y))
	±	(µ x y z∑ ◊ (◊ x y) z = ◊ x (◊ y z))
	±	(µ x y∑ ◊ x y = ◊ y x)
Æ);
a(strip_asm_tac Ø_times_consistent_lemma6);
a(∂_tac¨◊Æ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(cases_tac¨y = ÓØ 0Æ THEN1 asm_rewrite_tac[]);
a(lemma_tac¨µv w∑ ÓØ 0 < w ¥ ◊ v w = ◊ w v Æ THEN1 REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨∂ÿ∑µa∑ÿ a = ◊ a wÆ THEN1 prove_∂_tac);
a(lemma_tac¨µa b∑ÿ (a + b) = ÿ a + ÿ bÆ THEN1 asm_rewrite_tac[]);
a(lemma_tac¨µa∑ÓØ 0 < a ¥ ÓØ 0 < ÿ aÆ THEN1
	(REPEAT strip_tac THEN asm_rewrite_tac[] THEN all_asm_fc_tac[]));
a(lemma_tac¨∂»∑µa∑» a = ◊ w aÆ THEN1 prove_∂_tac);
a(lemma_tac¨µa b∑» (a + b) = » a + » bÆ THEN1 asm_rewrite_tac[]);
a(lemma_tac¨µa∑ÓØ 0 < a ¥ ÓØ 0 < » aÆ THEN1
	(REPEAT strip_tac THEN asm_rewrite_tac[] THEN all_asm_fc_tac[]));
a(lemma_tac ¨ÓØ 0 < ÓØ 1Æ THEN1 rewrite_tac[Ø_less_clauses]);
a(lemma_tac¨ÿ (ÓØ 1) = » (ÓØ 1)Æ THEN1 asm_rewrite_tac[]);
a(all_fc_tac[Ø_opah_eq_thm]);
a(LEMMA_T¨ÿ v = » vÆ ante_tac THEN1 TOP_ASM_T rewrite_thm_tac);
a(LIST_GET_NTH_ASM_T [6, 9] rewrite_tac);
(* *** Goal "2" *** *)
a(strip_asm_tac (list_µ_elim[¨yÆ, ¨ÓØ 0Æ]Ø_less_cases_thm) THEN
	POP_ASM_T ante_tac THEN
	once_rewrite_tac[Ø_less_0_less_thm] THEN
	rewrite_tac[Ø_plus_clauses, Ø_minus_clauses] THEN
	REPEAT strip_tac THEN
	LIST_GET_NTH_ASM_T [2] (ALL_FC_T (MAP_EVERY ante_tac)) THEN_TRY
	asm_rewrite_tac[Ø_minus_clauses, Ø_minus_eq_thm] THEN
	STRIP_T rewrite_thm_tac);
pop_thm()
);
=TEX
We are now ready to prove the consistency of the definition of multiplication.
The only tiny difficulty is to avoid a looping rewrite from the commutative law.

=SML
val _ = (
push_consistency_goal¨$*âRÆ;
a(strip_asm_tac Ø_times_consistent_lemma7);
a(∂_tac¨◊Æ THEN POP_ASM_T
	(fn th => asm_rewrite_tac[] THEN strip_asm_tac th));
save_consistency_thm¨$*âRÆ(pop_thm())
);
=TEX
\section{INITIAL THEOREMS ABOUT MULTIPLICATION}
We now prove a handful of theorems about multiplication.
More will follow when we have division available.
=SML
end (* of structure Ø part 8 *);
structure €Ø› (* : Ø *) = struct
open Ø;
=TEX
=SML
val €Ø_times_def› = get_spec¨$*âRÆ;
val [	€Ø_times_assoc_thm›,
	€Ø_times_unit_thm›,
	€Ø_times_distrib_lemma›,
	€Ø_times_comm_thm›, 
	€Ø_0_less_0_less_times_thm› ] = strip_±_rule Ø_times_def;
val €Ø_times_assoc_thm1› = conv_rule (ONCE_MAP_C eq_sym_conv) Ø_times_assoc_thm;
val _ = save_thm("Ø_times_assoc_thm", Ø_times_assoc_thm);
val _ = save_thm("Ø_times_comm_thm", Ø_times_comm_thm);
val _ = save_thm("Ø_times_unit_thm", Ø_times_unit_thm);
val _ = save_thm("Ø_0_less_0_less_times_thm", Ø_0_less_0_less_times_thm);
val _ = save_thm("Ø_times_assoc_thm1", Ø_times_assoc_thm1);
=TEX
=SML
val €Ø_times_plus_distrib_thm› = (
set_goal([], ¨µ x y z:Ø∑ x * (y + z) = x * y + x * z ± (x + y) * z = x * z + y * z Æ);
a(rewrite_tac [Ø_times_distrib_lemma] THEN REPEAT strip_tac);
a(once_rewrite_tac[Ø_times_comm_thm] THEN rewrite_tac [Ø_times_distrib_lemma]);
save_pop_thm"Ø_times_plus_distrib_thm"
);
=TEX
=SML
val €Ø_times_order_thm› = (
set_goal([], ¨µ x : Ø ∑ µ y z ∑
		y * x = x * y
	±	(x * y) * z = x * y * z
	±	y * x * z = x * y * zÆ);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [list_µ_elim [¨yÆ,¨xÆ] Ø_times_comm_thm]);
(* *** Goal "2" *** *)
a (rewrite_tac [all_µ_elim Ø_times_assoc_thm]);
(* *** Goal "3" *** *)
a (rewrite_tac [list_µ_elim [¨yÆ,¨xÆ,¨zÆ] Ø_times_assoc_thm1]);
a (once_rewrite_tac [list_µ_elim [¨yÆ,¨xÆ] Ø_times_comm_thm]);
a (rewrite_tac [Ø_times_assoc_thm]);
save_pop_thm "Ø_times_order_thm"
);
=TEX
=SML
val €Ø_times_0_thm1› = (
set_goal([], ¨µx:Ø∑ x * ÓØ 0 = ÓØ 0Æ);
a(accept_tac(
	all_µ_intro
	(rewrite_rule[Ø_plus_clauses, Ø_plus_0_thm](prove_rule[Ø_times_plus_distrib_thm]
	¨x*(ÓØ 0 + ÓØ 0) = x * ÓØ 0 + x * ÓØ 0Æ))));
pop_thm()
);
=TEX
=SML
val €Ø_times_0_thm› = (
set_goal([], ¨µx:Ø∑ x * ÓØ 0 = ÓØ 0 ± ÓØ 0 * x = ÓØ 0Æ);
a(rewrite_tac[µ_elim¨x:ØÆØ_times_order_thm, Ø_times_0_thm1]);
save_pop_thm "Ø_times_0_thm"
);
=TEX
=SML
val €Ø_times_1_thm› = (
set_goal([], ¨µx:Ø∑ x * ÓØ 1 = x ± ÓØ 1 * x = xÆ);
a(rewrite_tac[µ_elim¨x:ØÆØ_times_order_thm, Ø_times_unit_thm]);
save_pop_thm "Ø_times_1_thm"
);
=TEX
=SML
val €ÓØ_times_homomorphism_thm› = (
set_goal([], ¨µ m n : Ó ∑ ÓØ(m * n) = ÓØ m * ÓØ nÆ);
a(REPEAT strip_tac);
a(induction_tac¨nÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[times_clauses, Ø_times_0_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[times_plus_distrib_thm, Ø_times_1_thm,
	Ø_times_plus_distrib_thm, ÓØ_plus_homomorphism_thm]);
save_pop_thm"ÓØ_times_homomorphism_thm"
);
=TEX
=SML
val €ÓØ_times_homomorphism_thm1› = conv_rule (ONCE_MAP_C eq_sym_conv) ÓØ_times_homomorphism_thm;
=TEX
=SML
val €Ø_times_minus_thm1› = (
set_goal([], ¨µx y:Ø∑ x * ~ y = ~(x * y)Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨x * ~ y+ x * y = ÓØ 0Æ);
(* *** Goal "1" *** *)
a(LEMMA_T ¨x * ~ y + x * y = x * (~y + y)Æ rewrite_thm_tac
	THEN1 rewrite_tac[Ø_times_plus_distrib_thm]);
a(rewrite_tac[Ø_minus_clauses, Ø_times_0_thm1]);
(* *** Goal "2" *** *)
a(once_rewrite_tac[Ø_eq_thm]);
a(asm_rewrite_tac[Ø_minus_clauses]);
pop_thm()
);
=TEX
=SML
val €Ø_times_minus_thm› = (
set_goal([], ¨µx y:Ø∑ ~x * y = ~(x * y) ± x * ~ y = ~(x * y) ± ~x * ~y = x * yÆ);
a(REPEAT µ_tac);
a(rewrite_tac[µ_elim¨yÆØ_times_order_thm]);
a(rewrite_tac[Ø_times_minus_thm1]);
a(rewrite_tac[µ_elim¨yÆØ_times_order_thm]);
a(rewrite_tac[Ø_times_minus_thm1, Ø_minus_clauses]);
save_pop_thm"Ø_times_minus_thm"
);
=TEX
\subsection{Consistency of Division}
We can now prove the consistency of the definition of division.
=SML
val €Ø_over_consistent_lemma1› = (
set_goal([], ¨µz∑ ≥z = ÓØ 0 ¥ ∂r∑z * r = ÓØ 1Æ);
a(REPEAT µ_tac);
a(lemma_tac¨µz∑ ÓØ 0 < z ¥ ∂r∑z * r = ÓØ 1Æ THEN REPEAT strip_tac);
a(lemma_tac¨∂ÿ∑µa∑ÿ a = z * aÆ THEN1 prove_∂_tac);
a(lemma_tac¨µa b∑ÿ (a + b) = ÿ a + ÿ bÆ THEN1 asm_rewrite_tac[Ø_times_plus_distrib_thm]);
a(lemma_tac¨µa∑ÓØ 0 < a ¥ ÓØ 0 < ÿ aÆ THEN1 (REPEAT strip_tac THEN asm_rewrite_tac[])
	THEN1 (once_rewrite_tac[Ø_times_comm_thm] THEN all_fc_tac[Ø_0_less_0_less_times_thm]));
a(all_fc_tac[Ø_opah_onto_thm]);
a(POP_ASM_T ante_tac THEN rewrite_tac[onto_def] THEN REPEAT strip_tac);
a(SPEC_NTH_ASM_T 1 ¨ÓØ 1Æ ante_tac THEN GET_NTH_ASM_T 4 rewrite_thm_tac THEN strip_tac);
a(∂_tac¨xÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(cases_tac ¨ÓØ 0 < zÆ);
(* *** Goal "2.1" *** *)
a(all_asm_fc_tac[]);
a(∂_tac¨rÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[Ø_º_def, Ø_≥_less_º_thm]));
a(POP_ASM_T (strip_asm_tac o
	rewrite_rule[Ø_plus_clauses] o once_rewrite_rule[Ø_less_0_less_thm]));
a(all_asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN rewrite_tac[Ø_times_minus_thm] THEN strip_tac);
a(∂_tac¨~rÆ THEN asm_rewrite_tac[Ø_times_minus_thm, Ø_minus_eq_thm]);
pop_thm()
);
=SML
val _ = (
push_consistency_goal¨$/âRÆ;
a(lemma_tac¨∂f∑ µ z∑ ≥ z = ÓØ 0 ¥ z * f z = ÓØ 1Æ);
(* *** Goal "1" *** *)
a(prove_∂_tac THEN REPEAT strip_tac);
a(strip_asm_tac Ø_over_consistent_lemma1);
a(cases_tac ¨z' = ÓØ 0Æ THEN asm_rewrite_tac[]);
a(all_asm_fc_tac[]);
a(∂_tac¨rÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨Ãv w∑v * f wÆ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[Ø_times_assoc_thm] THEN ALL_ASM_FC_T rewrite_tac[]);
a(rewrite_tac[Ø_times_1_thm]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[Ø_times_assoc_thm]);
save_consistency_thm¨$/âRÆ(pop_thm())
);
=SML
val €Ø_over_def› = get_spec¨$/âRÆ;
=TEX
\section{MORE THEOREMS ABOUT THE MULTIPLICATIVE STRUCTURE}
=SML
end (* of structure Ø part 9 *);
structure €Ø› (* : Ø *) = struct
open Ø;
=TEX
=TEX
=SML
val €Ø_over_times_recip_thm› = (
set_goal ([], ¨µz∑≥ z = ÓØ 0 ¥ µx∑x / z = x * z õ-õ1Æ);
a(rewrite_tac[get_spec¨$õ-õ1Æ]);
a(REPEAT strip_tac THEN fc_tac[Ø_over_def]);
(* *** Goal "1" *** *)
a(LEMMA_T¨x / z = (x * ÓØ 1)/zÆ rewrite_thm_tac THEN1 rewrite_tac[Ø_times_1_thm]);
a(asm_rewrite_tac[]);
save_pop_thm "Ø_over_times_recip_thm"
);
=TEX
=SML
val €Ø_times_recip_thm› = (
set_goal ([], ¨µz∑≥ z = ÓØ 0 ¥ z * z õ-õ1 = ÓØ 1Æ);
a(rewrite_tac[get_spec¨$õ-õ1Æ]);
a(REPEAT strip_tac THEN fc_tac[Ø_over_def]);
(* *** Goal "1" *** *)
a(LEMMA_T¨z * ÓØ 1 / z = (ÓØ 1 * z) / zÆ rewrite_thm_tac THEN1
	(rewrite_tac[µ_elim¨zÆØ_times_order_thm] THEN GET_NTH_ASM_T 2 rewrite_thm_tac));
a(TOP_ASM_T rewrite_thm_tac);
save_pop_thm "Ø_times_recip_thm"
);
=TEX
=SML
val €Ø_eq_recip_thm› = (
set_goal ([], ¨µz∑≥ z = ÓØ 0 ¥ (µy∑ y = z § y * z õ-õ1 = ÓØ 1)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(var_elim_asm_tac ¨y = zÆ);
a(all_fc_tac[Ø_times_recip_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨z * (y * z õ-õ1) = z * ÓØ 1Æ ante_tac THEN1 asm_rewrite_tac[]);
a(rewrite_tac[Ø_times_1_thm, µ_elim¨yÆØ_times_order_thm]);
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
a(rewrite_tac[Ø_times_1_thm]);
save_pop_thm "Ø_eq_recip_thm"
);
=TEX
=SML
val €Ø_times_cancel_thm› = (
set_goal ([], ¨µ x y z∑ ≥ z = ÓØ 0 ¥ (x*z = y*z § x = y)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T ¨(x*z) * z õ-õ1 = (y*z) * z õ-õ1Æ ante_tac THEN1 asm_rewrite_tac[]);
a(rewrite_tac[Ø_times_assoc_thm]);
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
a(rewrite_tac[Ø_times_1_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
save_pop_thm "Ø_times_cancel_thm"
);
=TEX
=SML
val €Ø_times_eq_0_thm› = (
set_goal ([], ¨µ x y : Ø ∑ x * y = ÓØ 0 § x = ÓØ 0 ≤ y = ÓØ 0Æ);
a(conv_tac (ONCE_MAP_C eq_sym_conv));
a(REPEAT strip_tac THEN_LIST
	[asm_rewrite_tac[Ø_times_0_thm], asm_rewrite_tac[Ø_times_0_thm], id_tac]);
a(contr_tac THEN LEMMA_T ¨ÓØ 1 = ÓØ 0Æ (strip_asm_tac o rewrite_rule[Ø_plus_clauses]));
a(LEMMA_T¨x * y * y õ-õ1 * x õ-õ1 = ÓØ 0Æ ante_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[Ø_times_assoc_thm1, Ø_times_0_thm]);
(* *** Goal "2" *** *)
a(rewrite_tac[µ_elim¨x õ-õ1Æ Ø_times_order_thm]);
a(rewrite_tac[µ_elim¨xÆ Ø_times_order_thm]);
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
a(rewrite_tac[Ø_times_1_thm]);
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
save_pop_thm "Ø_times_eq_0_thm"
);
=TEX
=SML
val €Ø_times_clauses› = (
set_goal ([], ¨µ x ∑ ÓØ 0 * x = ÓØ 0 ± x * ÓØ 0 = ÓØ 0 ± x * ÓØ 1 = x ± ÓØ 1 * x = xÆ);
a(rewrite_tac[Ø_times_0_thm, Ø_times_1_thm]);
save_pop_thm "Ø_times_clauses"
);
=TEX
=SML
val €Ø_times_mono_§_thm› = (
set_goal ([], ¨µ x∑ ÓØ 0 < x ¥ (µ y z∑ y < z § x * y < x * z)Æ);
a(REPEAT_N 2 strip_tac);
a(lemma_tac¨∂f∑µv∑f v = x*vÆ THEN1 prove_∂_tac);
a(lemma_tac¨µv w∑f (v + w) = f v + f wÆ THEN1 
	asm_rewrite_tac[Ø_times_plus_distrib_thm]);
a(lemma_tac¨µv∑ÓØ 0 < v ¥ ÓØ 0 < f vÆ THEN1 
	(asm_rewrite_tac[] THEN REPEAT strip_tac
	THEN all_fc_tac[Ø_0_less_0_less_times_thm]));
a(GET_NTH_ASM_T 3 (rewrite_thm_tac o conv_rule (ONCE_MAP_C eq_sym_conv)));
a(REPEAT strip_tac THEN all_fc_tac[Ø_opah_thm, Ø_opah_strict_thm]);
save_pop_thm "Ø_times_mono_§_thm"
);
=TEX
=SML
val €Ø_times_mono_thm› = (
set_goal ([], ¨µ x y z∑ ÓØ 0 < x ± y < z ¥ x * y < x * zÆ);
a(REPEAT strip_tac THEN all_fc_tac[Ø_times_mono_§_thm]);
save_pop_thm "Ø_times_mono_thm"
);
=TEX
=SML
val €Ø_0_º_0_º_times_thm› = (
set_goal ([], ¨µ x y ∑ ÓØ 0 º x ± ÓØ 0 º y ¥ ÓØ 0 º x*yÆ);
a(rewrite_tac[Ø_º_def] THEN REPEAT strip_tac THEN
	(SOLVED_T (all_fc_tac[Ø_0_less_0_less_times_thm]) ORELSE
	 all_var_elim_asm_tac1 THEN_TRY rewrite_tac[Ø_times_clauses]));
save_pop_thm "Ø_0_º_0_º_times_thm"
);
=TEX
=SML
val €Ø_≥_recip_0_thm› = (
set_goal ([], ¨µz∑≥ z = ÓØ 0 ¥ ≥z õ-õ1 = ÓØ 0Æ);
a(contr_tac);
a(all_fc_tac[Ø_times_recip_thm]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[Ø_times_clauses, Ø_plus_clauses]);
save_pop_thm "Ø_≥_recip_0_thm"
);
=TEX
Our general strategy for expressions involving
multiplication and division is analogous to that
used for addition and subtraction, where we replace
subtraction by addition of the inverse element and push
unary minus signs into sums. 
=TEX
=SML
val €Ø_recip_clauses1› = (
set_goal ([], ¨
	(ÓØ 1) õ-õ1  = ÓØ 1
±	(µ w ∑ ≥w = ÓØ 0 ¥ (
	w õ-õ1 õ-õ1  = w
±	w * w õ-õ1 = ÓØ 1
±	w õ-õ1 * w = ÓØ 1
))Æ);
a(strip_tac THEN1 REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac¨≥ÓØ 1 = ÓØ 0Æ THEN1 rewrite_tac[Ø_plus_clauses]);
a(rewrite_tac[get_spec¨$õ-õ1Æ]);
a(ALL_FC_T once_rewrite_tac[Ø_over_times_recip_thm]);
a(ALL_FC_T(MAP_EVERY ante_tac)[ Ø_times_recip_thm ]);
a(REPEAT strip_tac);
(* *** Goal "2" *** *)
a(µ_tac THEN ¥_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[µ_elim¨wÆØ_times_order_thm]);
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
a(FC_T1 fc_§_canon rewrite_tac[Ø_eq_recip_thm]);
a(all_fc_tac[Ø_≥_recip_0_thm]);
a(once_rewrite_tac[Ø_times_comm_thm]);
a(ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
pop_thm ()
);
=TEX
=SML
val €Ø_recip_clauses2› = (
set_goal ([], ¨
	(µw z ∑ ≥w = ÓØ 0 ± ≥z = ÓØ 0 ¥
	(w * z)õ-õ1 = w õ-õ1 * z õ-õ1
)Æ);
a(REPEAT strip_tac THEN conv_tac eq_sym_conv);
a(lemma_tac¨≥w * z = ÓØ 0Æ THEN1 asm_rewrite_tac[Ø_times_eq_0_thm]);
a(all_fc_tac[Ø_≥_recip_0_thm]);
a(ALL_FC_T1 fc_§_canon rewrite_tac[Ø_eq_recip_thm]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses1]);
a(rewrite_tac[µ_elim¨zÆØ_times_order_thm]);
a(rewrite_tac[µ_elim¨w õ-õ1ÆØ_times_order_thm]);
a(rewrite_tac[µ_elim¨wÆØ_times_order_thm]);
a(all_fc_tac[Ø_times_recip_thm] THEN asm_rewrite_tac[Ø_times_clauses]);
pop_thm()
);
=TEX
=SML
val €Ø_recip_clauses› = save_thm ("Ø_recip_clauses",
	(±_intro Ø_recip_clauses1 Ø_recip_clauses2));
=TEX
=SML
val €Ø_cross_mult_eq_thm› = (
set_goal ([], ¨
	(µw z ∑ ≥w = ÓØ 0 ± ≥z = ÓØ 0 ¥
	(µx y ∑ x / w = y / z § x * z = w * y)
)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T ¨(x / w) * w * z = (y / z) * w * zÆ ante_tac THEN1 asm_rewrite_tac[]);
a(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(rewrite_tac[µ_elim¨xÆØ_times_order_thm]);
a(rewrite_tac[µ_elim¨zÆØ_times_order_thm]);
a(all_fc_tac[Ø_recip_clauses]);
a(asm_rewrite_tac[Ø_times_clauses]);
a(rewrite_tac[µ_elim¨yÆØ_times_order_thm]);
a(rewrite_tac[µ_elim¨wÆØ_times_order_thm]);
a(asm_rewrite_tac[Ø_times_clauses]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨(x * z)/(w * z) = (w * y)/(w * z)Æ ante_tac THEN1 asm_rewrite_tac[]);
a(lemma_tac¨≥w * z = ÓØ 0Æ THEN1 asm_rewrite_tac[Ø_times_eq_0_thm]);
a(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm, Ø_recip_clauses ]);
a(all_fc_tac[Ø_recip_clauses]);
a(rewrite_tac[µ_elim¨w õ-õ1ÆØ_times_order_thm]);
a(asm_rewrite_tac[Ø_times_assoc_thm, Ø_times_clauses]);
a(asm_rewrite_tac[Ø_times_assoc_thm1, Ø_times_clauses]);
save_pop_thm "Ø_cross_mult_eq_thm"
);
=TEX
=SML
val €Ø_less_≥_eq_0_thm› = (
set_goal ([], ¨µz ∑ ÓØ 0 < z ¥ ≥z = ÓØ 0Æ);
a(contr_tac THEN all_var_elim_asm_tac1 THEN all_fc_tac[Ø_less_irrefl_thm]);
save_pop_thm "Ø_less_≥_eq_0_thm"
);
=TEX
=SML
val €Ø_0_less_0_less_recip_thm› = (
set_goal ([], ¨µz ∑ ÓØ 0 < z ¥ ÓØ 0 < z õ-õ1Æ);
a(REPEAT strip_tac THEN
	strip_asm_tac(list_µ_elim[¨z õ-õ1Æ, ¨ÓØ 0Æ] Ø_less_cases_thm));
(* *** Goal "1" *** *)
a(POP_ASM_T (asm_tac o 
	rewrite_rule[Ø_plus_clauses] o once_rewrite_rule[Ø_less_0_less_thm]));
a(LEMMA_T¨ÓØ 0 < z * ~ (z õ-õ1)Æ ante_tac THEN1
	all_fc_tac[Ø_0_less_0_less_times_thm]);
a(once_rewrite_tac[Ø_less_less_0_thm]);
a(rewrite_tac[Ø_plus_clauses, Ø_times_minus_thm, Ø_minus_clauses]);
a(all_fc_tac[Ø_less_≥_eq_0_thm]);
a(lemma_tac ¨z * z õ-õ1 = ÓØ 1Æ THEN1
	ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
a(asm_rewrite_tac[Ø_less_clauses]);
(* *** Goal "2" *** *)
a(all_fc_tac[Ø_less_≥_eq_0_thm]);
a(LEMMA_T ¨z * z õ-õ1 = ÓØ 1Æ ante_tac THEN1
	ALL_FC_T rewrite_tac[Ø_times_recip_thm]);
a(asm_rewrite_tac[Ø_times_clauses, Ø_plus_clauses]);
save_pop_thm "Ø_0_less_0_less_recip_thm"
);
=TEX
=SML
val €Ø_cross_mult_less_thm› = (
set_goal ([], ¨
	(µw z ∑ ÓØ 0 < w ± ÓØ 0 < z ¥
	(µx y ∑ x / w < y / z § x * z < w * y)
)Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LEMMA_T ¨w*z*(x / w) < w*z*(y / z)Æ ante_tac THEN1
	REPEAT (bc_thm_tac Ø_times_mono_thm THEN REPEAT strip_tac));
a(all_fc_tac[Ø_less_≥_eq_0_thm]);
a(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(rewrite_tac[µ_elim¨xÆØ_times_order_thm]);
a(rewrite_tac[µ_elim¨zÆØ_times_order_thm]);
a(all_fc_tac[Ø_recip_clauses]);
a(asm_rewrite_tac[Ø_times_clauses]);
a(rewrite_tac[µ_elim¨yÆØ_times_order_thm]);
a(rewrite_tac[µ_elim¨wÆØ_times_order_thm]);
a(asm_rewrite_tac[Ø_times_clauses]);
(* *** Goal "2" *** *)
a(all_fc_tac[Ø_less_≥_eq_0_thm]);
a(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(all_fc_tac[Ø_0_less_0_less_recip_thm]);
a(LEMMA_T ¨w õ-õ1 *z õ-õ1 * (x * z) < w õ-õ1 * z õ-õ1 * (w * y)Æ ante_tac THEN1
	REPEAT (bc_thm_tac Ø_times_mono_thm THEN REPEAT strip_tac));
a(all_fc_tac[Ø_recip_clauses]);
a(rewrite_tac[µ_elim¨w õ-õ1ÆØ_times_order_thm]);
a(rewrite_tac[µ_elim¨xÆØ_times_order_thm]);
a(asm_rewrite_tac[Ø_times_assoc_thm, Ø_times_clauses]);
a(rewrite_tac[µ_elim¨z õ-õ1ÆØ_times_order_thm]);
a(rewrite_tac[µ_elim¨yÆØ_times_order_thm]);
a(asm_rewrite_tac[Ø_times_assoc_thm, Ø_times_clauses]);
save_pop_thm "Ø_cross_mult_less_thm"
);
=TEX
=SML
val €Ø_over_cancel_thm› = (
set_goal ([], ¨
	(µw z ∑ ≥w = ÓØ 0 ± ≥z = ÓØ 0 ¥
	(µx ∑ (x * z) / (w * z) = x / w))
Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨≥ w * z = ÓØ 0Æ THEN1 asm_rewrite_tac[Ø_times_eq_0_thm]);
a(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm, Ø_recip_clauses]);
a(rewrite_tac[µ_elim¨w õ-õ1ÆØ_times_order_thm]);
a(rewrite_tac[µ_elim¨xÆØ_times_order_thm]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(rewrite_tac[Ø_times_clauses]);
save_pop_thm "Ø_over_cancel_eq_thm"
);
=TEX
\section{THEOREMS TO SUPPORT CALCULATIONS}
=SML
end (* of structure Ø part 10 *);
structure €Ø› : Ø = struct
open Ø;
=TEX
\subsection{Addition}
=SML
val €Ø_over_plus_over_thm› = (
set_goal ([], ¨µx y u v ∑
	≥u = ÓØ 0 ± ≥v = ÓØ 0 ¥
	x/u + y/v = (x * v + y * u) / (u*v)
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨≥u*v = ÓØ 0Æ THEN1 asm_rewrite_tac[Ø_times_eq_0_thm]);
a(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm, Ø_recip_clauses]);
a(rewrite_tac[Ø_times_plus_distrib_thm]);
a(rewrite_tac[µ_elim¨u õ-õ1ÆØ_times_order_thm]);
a(rewrite_tac[µ_elim¨xÆØ_times_order_thm]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(rewrite_tac[µ_elim¨v õ-õ1ÆØ_times_order_thm]);
a(rewrite_tac[µ_elim¨yÆØ_times_order_thm]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(rewrite_tac[Ø_times_clauses]);
save_pop_thm "Ø_over_plus_over_thm"
);
=TEX
=SML
val €Ø_0_over_thm› = (
set_goal ([], ¨
	µz ∑ ≥z = ÓØ 0 ¥ ÓØ 0 / z = ÓØ 0
Æ);
a(REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(rewrite_tac[Ø_times_clauses]);
save_pop_thm "Ø_0_over_thm"
);
=TEX
=SML
val €Ø_over_1_thm› = (
set_goal ([], ¨µx ∑ x / ÓØ 1 = xÆ);
a(lemma_tac¨≥ÓØ 1 = ÓØ 0Æ THEN1 rewrite_tac[ÓØ_one_one_thm]);
a(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm, Ø_recip_clauses]);
a(rewrite_tac[Ø_recip_clauses, Ø_times_clauses]);
save_pop_thm "Ø_over_1_thm"
);
=TEX
=SML
val €Ø_frac_def› = get_spec¨$/âNÆ;
=TEX
=SML
val €ÓØ_plus_homomorphism_thm1› = save_thm("ÓØ_plus_homomorphism_thm1",
	conv_rule (ONCE_MAP_C eq_sym_conv) ÓØ_plus_homomorphism_thm);
val €ÓØ_times_homomorphism_thm1› = save_thm("ÓØ_times_homomorphism_thm1",
	conv_rule (ONCE_MAP_C eq_sym_conv) ÓØ_times_homomorphism_thm);
=SML
val €Ø_frac_cross_mult_eq_thm› = (
set_goal ([], ¨
	µm n i j ∑ i / (m + 1) = j / (n + 1) § i*(n + 1) = j*(m + 1)
Æ);
a(REPEAT µ_tac);
a(rewrite_tac[Ø_frac_def]);
a(LEMMA_T ¨≥m + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ¨≥n + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(lemma_tac ¨≥ÓØ(m + 1) = ÓØ 0 ± ≥ÓØ(n + 1) = ÓØ 0 Æ
	THEN1 asm_rewrite_tac[ÓØ_one_one_thm]);
a(ALL_FC_T1 fc_§_canon rewrite_tac[Ø_cross_mult_eq_thm]);
a(rewrite_tac[µ_elim¨ÓØ jÆ Ø_times_order_thm]);
a(rewrite_tac[ÓØ_times_homomorphism_thm1, ÓØ_one_one_thm]);
save_pop_thm "Ø_frac_cross_mult_eq_thm"
);
=TEX
=SML
val €Ø_frac_cancel_thm› = (
set_goal ([], ¨
	µi m n ∑ (i * (n + 1)) / ((m + 1) * (n + 1)) = i / (m + 1)
Æ);
a(REPEAT strip_tac);
a(rewrite_tac[Ø_frac_def]);
a(LEMMA_T ¨≥m + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ¨≥n + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(lemma_tac ¨≥ÓØ(m + 1) = ÓØ 0 ± ≥ÓØ(n + 1) = ÓØ 0 Æ
	THEN1 asm_rewrite_tac[ÓØ_one_one_thm]);
a(rewrite_tac[ÓØ_times_homomorphism_thm]);
a(ALL_FC_T rewrite_tac[Ø_over_cancel_thm]);
save_pop_thm "Ø_frac_cancel_eq_thm"
);
=TEX
=SML
val €Ø_frac_0_thm› = (
set_goal ([], ¨µm ∑ 0 / (m + 1) = ÓØ 0Æ);
a(REPEAT strip_tac);
a(rewrite_tac[Ø_frac_def]);
a(LEMMA_T ¨≥m + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(lemma_tac ¨≥ÓØ(m + 1) = ÓØ 0 Æ
	THEN1 asm_rewrite_tac[ÓØ_one_one_thm]);
a(ALL_FC_T rewrite_tac[Ø_0_over_thm]);
save_pop_thm "Ø_frac_0_thm"
);
=TEX
=SML
val €Ø_frac_Ó_thm› = (
set_goal ([], ¨µi ∑ i / 1 = ÓØ iÆ);
a(rewrite_tac[Ø_frac_def, Ø_over_1_thm]);
save_pop_thm "Ø_frac_Ó_thm"
);
=TEX
=SML
val €Ø_frac_plus_frac_thm› = (
set_goal ([], ¨
	µi j k m n∑
	i/(m+1) + j/(n+1) = (i*(n+1) + j*(m+1))/ ((m+1) * (n+1))
Æ);
a(REPEAT strip_tac);
a(rewrite_tac[Ø_frac_def]);
a(LEMMA_T ¨≥m + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ¨≥n + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(lemma_tac ¨≥ÓØ(m + 1) = ÓØ 0 ± ≥ÓØ(n + 1) = ÓØ 0 Æ
	THEN1 asm_rewrite_tac[ÓØ_one_one_thm]);
a(ALL_FC_T rewrite_tac[Ø_over_plus_over_thm]);
a(rewrite_tac[ÓØ_times_homomorphism_thm1, ÓØ_plus_homomorphism_thm1]);
save_pop_thm "Ø_frac_plus_frac_thm"
);
=TEX
=SML
val €Ø_frac_minus_frac_lemma1› = (
set_goal ([], ¨
	µm n∑ m º n ¥ ÓØ (n - m) = ÓØ n - ÓØ m
Æ);
a(rewrite_tac[º_def] THEN REPEAT strip_tac THEN all_var_elim_asm_tac1);
a(once_rewrite_tac[plus_comm_thm] THEN rewrite_tac[minus_def,
	ÓØ_plus_homomorphism_thm, Ø_plus_assoc_thm,
	Ø_subtract_def, Ø_minus_clauses, Ø_plus_clauses]);
pop_thm()
);
=TEX
=SML
val €Ø_frac_minus_frac_thm› = (
set_goal ([], ¨
	µi j k m n∑
	j*(m+1) º i*(n+1) ¥
	i/(m+1) + ~(j/(n+1)) = (i*(n+1) - j*(m+1))/ ((m+1) * (n+1))
Æ);
a(REPEAT strip_tac);
a(rewrite_tac[Ø_frac_def]);
a(LEMMA_T ¨≥m + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ¨≥n + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(lemma_tac ¨≥ÓØ(m + 1) = ÓØ 0 ± ≥ÓØ(n + 1) = ÓØ 0 Æ
	THEN1 asm_rewrite_tac[ÓØ_one_one_thm]);
a(LEMMA_T ¨~ (ÓØ j / ÓØ (n + 1)) = ~(ÓØ j)/ ÓØ(n + 1)Æ rewrite_thm_tac THEN1
	(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm] THEN
	rewrite_tac[Ø_times_minus_thm]));
a(ALL_FC_T rewrite_tac[Ø_frac_minus_frac_lemma1]);
a(rewrite_tac[Ø_subtract_def]);
a(ALL_FC_T rewrite_tac[Ø_over_plus_over_thm]);
a(rewrite_tac[ÓØ_times_homomorphism_thm, ÓØ_plus_homomorphism_thm,
	Ø_times_minus_thm]);
save_pop_thm "Ø_frac_minus_frac_thm"
);
=TEX
=SML
val €Ø_frac_minus_frac_thm1› = (
set_goal ([], ¨
	µi j m n∑
	i*(n+1) º j*(m+1) ¥
	i/(m+1) + ~(j/(n+1)) = ~((j*(m+1) - i*(n+1))/ ((m+1) * (n+1)))
Æ);
a(REPEAT strip_tac);
a(LEMMA_T ¨µa b:Ø∑ a + ~b = ~(b + ~a)Æ once_rewrite_thm_tac
	THEN1 rewrite_tac[Ø_minus_clauses, Ø_plus_clauses]);
a(ALL_FC_T rewrite_tac[Ø_frac_minus_frac_thm]);
a(rewrite_tac[µ_elim¨m+1Ætimes_comm_thm]);
save_pop_thm "Ø_frac_minus_frac_thm1"
);
=TEX
\subsection{Multiplication}
=SML
val €Ø_over_times_over_thm› = (
set_goal ([], ¨µx y u v ∑
	≥u = ÓØ 0 ± ≥v = ÓØ 0 ¥
	(x/u) * (y/v) = (x * y)/(u * v)
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨≥u*v = ÓØ 0Æ THEN1 asm_rewrite_tac[Ø_times_eq_0_thm]);
a(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm, Ø_recip_clauses]);
a(rewrite_tac[µ_elim¨yÆØ_times_order_thm]);
a(rewrite_tac[Ø_times_assoc_thm]);
save_pop_thm "Ø_over_times_over_thm"
);
=TEX
=SML
val €Ø_frac_times_frac_thm› = (
set_goal ([], ¨µi j m n ∑
	(i/(m+1))*(j/(n+1)) = (i*j)/((m+1)*(n+1))
Æ);
a(REPEAT strip_tac THEN rewrite_tac[Ø_frac_def]);
a(LEMMA_T ¨≥m + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ¨≥n + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(lemma_tac ¨≥ÓØ(m + 1) = ÓØ 0 ± ≥ÓØ(n + 1) = ÓØ 0 Æ
	THEN1 asm_rewrite_tac[ÓØ_one_one_thm]);
a(ALL_FC_T rewrite_tac[Ø_over_times_over_thm]);
a(rewrite_tac[ÓØ_times_homomorphism_thm1]);
save_pop_thm "Ø_frac_times_frac_thm"
);
=TEX
\subsection{Reciprocals and Division}
=SML
val €Ø_over_recip_thm› = (
set_goal ([], ¨µu v∑
	≥u = ÓØ 0 ± ≥v = ÓØ 0 ¥ (u/v) õ-õ1 = v/u
Æ);
a(REPEAT strip_tac);
a(all_asm_fc_tac[Ø_≥_recip_0_thm]);
a(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm, Ø_recip_clauses]);
a(rewrite_tac[µ_elim¨vÆØ_times_order_thm]);
save_pop_thm "Ø_over_recip_thm"
);
=TEX
=SML
val €Ø_frac_recip_thm› = (
set_goal ([], ¨µm n∑
	((m+1)/(n+1)) õ-õ1 = (n+1)/(m+1)
Æ);
a(REPEAT strip_tac THEN rewrite_tac[Ø_frac_def]);
a(LEMMA_T ¨≥m + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ¨≥n + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(lemma_tac ¨≥ÓØ(m + 1) = ÓØ 0 ± ≥ÓØ(n + 1) = ÓØ 0 Æ
	THEN1 asm_rewrite_tac[ÓØ_one_one_thm]);
a(ALL_FC_T rewrite_tac[Ø_over_recip_thm]);
save_pop_thm "Ø_frac_recip_thm"
);
=TEX
=SML
val €Ø_minus_recip_thm› = (
set_goal ([], ¨µz∑
	≥z = ÓØ 0 ¥ (~z) õ-õ1 = ~(z õ-õ1)
Æ);
a(REPEAT strip_tac);
a(TOP_ASM_T (strip_asm_tac o
	rewrite_rule[Ø_plus_clauses, Ø_minus_clauses] o
	once_rewrite_rule[Ø_eq_thm] o
	conv_rule (RAND_C eq_sym_conv)));
a(conv_tac eq_sym_conv);
a(all_asm_fc_tac[Ø_≥_recip_0_thm]);
a(ALL_FC_T1 fc_§_canon rewrite_tac[Ø_eq_recip_thm]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
a(rewrite_tac[Ø_times_minus_thm]);
a(ALL_FC_T rewrite_tac[Ø_recip_clauses]);
save_pop_thm "Ø_minus_recip_thm"
);
=TEX
=SML
val €Ø_over_eq_0_thm› = (
set_goal ([], ¨µu v∑
	≥u = ÓØ 0 ± ≥v = ÓØ 0 ¥ ≥ u/v = ÓØ 0
Æ);
a(REPEAT strip_tac);
a(all_asm_fc_tac[Ø_≥_recip_0_thm]);
a(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
a(asm_rewrite_tac[Ø_times_eq_0_thm]);
save_pop_thm "Ø_over_eq_0_thm"
);
=TEX
=SML
val €Ø_over_over_over_thm› = (
set_goal ([], ¨µx y u v ∑
	≥u = ÓØ 0 ± ≥v = ÓØ 0 ± ≥y = ÓØ 0  ¥
	(x/u) / (y/v) = (x * v)/(u * y)
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨≥y/v = ÓØ 0Æ THEN1 all_fc_tac[Ø_over_eq_0_thm]);
a(ALL_FC_T once_rewrite_tac[Ø_over_times_recip_thm]);
a(ALL_FC_T once_rewrite_tac[Ø_over_recip_thm]);
a(bc_thm_tac Ø_over_times_over_thm THEN REPEAT strip_tac);
save_pop_thm "Ø_over_over_over_thm"
);
=TEX
\section{Less-than}
=TEX
=SML
val €Ø_frac_less_frac_thm› = (
set_goal ([], ¨
	µi j m n∑
	i/(m+1) < j/(n+1) § i*(n+1) < j*(m+1)
Æ);
a(REPEAT µ_tac THEN rewrite_tac[Ø_frac_def]);
a(LEMMA_T ¨0 < m + 1 Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ¨0 < n + 1Æ asm_tac THEN1 prove_tac[]);
a(lemma_tac ¨ÓØ 0 < ÓØ (m + 1) ± ÓØ 0 < ÓØ (n + 1)Æ
	THEN1 asm_rewrite_tac[ÓØ_less_thm]);
a(strip_asm_tac(list_µ_elim[¨ÓØ(m+1)Æ, ¨ÓØ(n+1)Æ]Ø_cross_mult_less_thm));
a(asm_rewrite_tac[ÓØ_times_homomorphism_thm, ÓØ_plus_homomorphism_thm]);
a(rewrite_tac[µ_elim¨ÓØ jÆ Ø_times_order_thm]);
a(asm_rewrite_tac[ÓØ_times_homomorphism_thm1, ÓØ_plus_homomorphism_thm1,
	ÓØ_less_thm]);
save_pop_thm "Ø_frac_less_frac_thm"
);
=TEX
=SML
val €Ø_minus_frac_less_frac_thm› = (
set_goal ([], ¨
	µi j m n∑
	~(i/(m+1)) < j/(n+1) § 0 < i + j
Æ);
a(REPEAT_UNTIL is_¥ strip_tac);
(* *** Goal "1" *** *)
a(once_rewrite_tac[Ø_less_0_less_thm]);
a(rewrite_tac[Ø_minus_clauses, Ø_frac_plus_frac_thm]);
a(contr_tac THEN lemma_tac¨i = 0 ± j = 0Æ THEN1
	PC_T1 "lin_arith" asm_prove_tac[]);
a(all_var_elim_asm_tac1);
a(POP_ASM_T ante_tac THEN rewrite_tac [times_plus_distrib_thm]);
a(rewrite_tac[plus_assoc_thm1, Ø_frac_0_thm, Ø_less_irrefl_thm]);
(* *** Goal "2" *** *)
a(once_rewrite_tac[Ø_less_0_less_thm]);
a(rewrite_tac[Ø_minus_clauses, Ø_frac_plus_frac_thm, times_plus_distrib_thm]);
a(rewrite_tac[plus_assoc_thm1]);
a(pure_rewrite_tac[eq_sym_rule(µ_elim¨0ÆØ_frac_0_thm),
	Ø_frac_less_frac_thm]);
a(PC_T1 "lin_arith" prove_tac[]);
save_pop_thm "Ø_minus_frac_less_frac_thm"
);
=TEX
=SML
val €Ø_frac_less_minus_frac_thm› = (
set_goal ([], ¨
	µi j m n∑
	≥i/(m+1) < ~(j/(n+1))
Æ);
a(REPEAT strip_tac);
a(pure_once_rewrite_tac[Ø_less_less_0_thm]);
a(rewrite_tac[Ø_minus_clauses, Ø_frac_plus_frac_thm, times_plus_distrib_thm]);
a(rewrite_tac[plus_assoc_thm1]);
a(pure_rewrite_tac[eq_sym_rule(µ_elim¨0ÆØ_frac_0_thm),
	Ø_frac_less_frac_thm]);
a(rewrite_tac[]);
save_pop_thm "Ø_frac_less_minus_frac_thm"
);
=TEX
\subsection{Absolute Value}
=SML
val €Ø_0_º_frac_thm› = (
set_goal ([], ¨µi m∑ ÓØ 0 º i/(m+1)Æ);
a(contr_tac THEN POP_ASM_T ante_tac);
a(pure_rewrite_tac[Ø_≥_º_less_thm, eq_sym_rule(µ_elim¨0ÆØ_frac_0_thm),
	Ø_frac_less_frac_thm]);
a(PC_T1 "lin_arith" prove_tac[]);
save_pop_thm"Ø_0_º_frac_thm"
);
=TEX
=SML
val €Ø_abs_frac_thm› = (
set_goal ([], ¨µi m∑ Abs(i/(m+1)) = i/(m+1)Æ);
a(REPEAT strip_tac THEN rewrite_tac[get_spec¨AbsâRÆ, Ø_0_º_frac_thm]);
save_pop_thm"Ø_abs_frac_thm"
);
=TEX
=SML
val €Ø_abs_minus_thm› = (
set_goal([], ¨µ x : Ø ∑ Abs (~x) = Abs xÆ);
a(REPEAT strip_tac THEN rewrite_tac[get_spec¨AbsâRÆ]);
a(strip_asm_tac (list_µ_elim [¨ÓØ 0Æ, ¨xÆ] Ø_less_cases_thm));
(* *** Goal "1" *** *)
a(LEMMA_T ¨ÓØ 0 º xÆ rewrite_thm_tac THEN1 asm_rewrite_tac[Ø_º_def]);
a(once_rewrite_tac[Ø_º_º_0_thm] THEN
	rewrite_tac[Ø_plus_clauses, Ø_minus_clauses]);
a(LEMMA_T ¨≥x º ÓØ 0Æ rewrite_thm_tac);
a(contr_tac THEN all_fc_tac[Ø_º_less_trans_thm]);
a(all_fc_tac[Ø_less_irrefl_thm]);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1 THEN rewrite_tac[Ø_minus_clauses, Ø_º_clauses]);
(* *** Goal "3" *** *)
a(once_rewrite_tac[Ø_º_º_0_thm] THEN
	rewrite_tac[Ø_plus_clauses, Ø_minus_clauses]);
a(LEMMA_T ¨x º ÓØ 0Æ rewrite_thm_tac THEN1 asm_rewrite_tac[Ø_º_def]);
a(LEMMA_T ¨≥ ~x º ÓØ 0Æ rewrite_thm_tac);
a(once_rewrite_tac[Ø_º_0_º_thm] THEN
	rewrite_tac[Ø_plus_clauses, Ø_minus_clauses]);
a(contr_tac THEN all_fc_tac[Ø_º_less_trans_thm]);
a(all_fc_tac[Ø_less_irrefl_thm]);
save_pop_thm "Ø_abs_minus_thm"
);
=TEX
\section{COMPUTATIONAL CONVERSIONS}\label{COMP}
It is only now that we start to need specialised lemmas that are not to be exported
to the user. Thus the structure starts here: (see comments in section~\ref{PROLOGUE}
=TEX
\subsection{Normalisation and Denormalisation}
We denormalise terms of the form
=INLINEFT
ÓØ i
=TEX
\ or
=INLINEFT
i/m
=TEX
, where $i$, and $m$ are natural number literals and $m$ is non-zero,
into the form
=INLINEFT
j/(n+1)
=TEX
, where $j$ and $n$ are natural number literals.
Denormalisation lets the theorems on fractions  ``bite''.

Normalisation is the reverse process and gives either
=INLINEFT
ÓØ i
=TEX
\ or
=INLINEFT
i/m
=TEX
, where $i$ and $m$ are natural number literals, $m > 1$.

We need a metalanguage function to compute greatest common divisors:

=SML
fun €gcd› (m : INTEGER) (n : INTEGER) = (
	if	m @<= zero
	then	n
	else if	m @< n
	then	gcd (n imod m) m
	else if	m = n
	then	m
	else	gcd (m imod n) n
);
=TEX
Now we can define the normalising conversion:
=SML
val €one_tm› = ¨1Æ;

val €Ø_frac_norm_conv› : CONV = (
	simple_eq_match_conv Ø_frac_0_thm
ORELSE_C
	simple_eq_match_conv Ø_frac_Ó_thm
ORELSE_C
	(fn tm =>
	let	val (a_tm, b_tm) = dest_Ø_frac tm
			handle Fail _ =>
			term_fail "Ø_frac_norm_conv" 116301 [tm];
		val (a, b) = (dest_Ó a_tm, dest_Ó b_tm)
			handle Fail _ =>
			term_fail "Ø_frac_norm_conv" 116301 [tm];
	in	if	b = zero
		then	term_fail "Ø_frac_norm_conv" 116302 [tm]
		else
		let	val np1 = gcd a b;
		in
		if	np1 = one
		then	term_fail "Ø_frac_norm_conv" 116303 [tm]
		else	
		let	val i_tm = mk_Ó(a idiv np1);
			val m_tm = mk_Ó((b idiv np1) @- one);
			val mp1_tm = mk_plus(m_tm, one_tm);
			val n_tm = mk_Ó (np1 @- one);
			val np1_tm = mk_plus(n_tm, one_tm);
			val inp1_tm = mk_times(i_tm, np1_tm);
			val mnp1_tm = mk_times(mp1_tm, np1_tm);
			val frac = mk_Ø_frac(inp1_tm, mnp1_tm);
			val conv1 = RIGHT_C plus_conv THEN_C times_conv;
			val conv2 = RANDS_C plus_conv THEN_C times_conv;
			val thm1 = eq_sym_rule
				((LEFT_C conv1 THEN_C RIGHT_C conv2)frac);
			val conv2 = simple_eq_match_conv Ø_frac_cancel_thm
				THEN_C
				RIGHT_C plus_conv
				THEN_C
				TRY_C (simple_eq_match_conv Ø_frac_Ó_thm);
			val thm2 = conv2 frac;
		in	eq_trans_rule thm1 thm2
		end
		end
	end)
);
=TEX
\ldots and the denormalising conversion:
=SML
val €Ø_frac_denorm_0_thm› = conv_rule(ONCE_MAP_C eq_sym_conv)
	(conv_rule (ONCE_MAP_C plus_conv) (µ_elim¨0ÆØ_frac_0_thm));
val €Ø_frac_denorm_Ó_thm› = conv_rule(ONCE_MAP_C eq_sym_conv) Ø_frac_Ó_thm;
val €Ø_frac_denorm_conv› : CONV = 
	TRY_C (simple_eq_match_conv Ø_frac_denorm_0_thm ORELSE_C
		simple_eq_match_conv Ø_frac_denorm_Ó_thm)
THEN_C	(fn tm =>
	let	val (a_tm, b_tm) = dest_Ø_frac tm
		handle Fail _ =>
		term_fail "Ø_frac_denorm_conv" 116301 [tm];
		val b = dest_Ó b_tm
			handle Fail _ =>
			term_fail "Ø_frac_norm_conv" 116301 [tm];
	in	if	b = zero
		then	term_fail "Ø_frac_norm_conv" 116302 [tm]
		else	let	val bl1_tm = mk_Ó (b @- one);
				val bl1p1_tm = mk_plus(bl1_tm, one_tm);
				val res_tm = mk_Ø_frac(a_tm, bl1p1_tm);
			in	eq_sym_rule (RIGHT_C plus_conv(res_tm))
			end
	end	
);
=TEX
\subsection{Addition}
=SML
val €Ø_frac_plus_frac_conv› : CONV = (fn tm =>
	(simple_eq_match_conv Ø_frac_plus_frac_thm THEN_C
	RIGHT_C (RANDS_C plus_conv THEN_C times_conv) THEN_C
	LEFT_C (RANDS_C (RIGHT_C plus_conv THEN_C times_conv)
		THEN_C plus_conv)
	THEN_TRY_C Ø_frac_norm_conv) tm
	handle Fail _ => term_fail "Ø_frac_plus_frac_conv" 116304 [tm]
);
=TEX
=SML
val €Ø_frac_minus_frac_lemma2› = (
set_goal ([], ¨
	µi j k m n∑
	(j*(m+1) º i*(n+1) § F) ¥
	i/(m+1) + ~(j/(n+1)) = ~((j*(m+1) - i*(n+1))/ ((m+1) * (n+1)))
Æ);
a(REPEAT strip_tac);
a(lemma_tac¨i*(n+1) º j*(m+1)Æ THEN1 PC_T1 "lin_arith" asm_prove_tac[]);
a(ALL_FC_T rewrite_tac[Ø_frac_minus_frac_thm1]);
pop_thm()
);

=SML
val €Ø_frac_minus_frac_conv› : CONV = (fn tm =>
	let	val (l_tm, r_tm) = dest_Ø_plus tm;
		val rop_tm = dest_Ø_minus r_tm;
		val (i_tm, mp1_tm) = dest_Ø_frac l_tm;
		val (j_tm, np1_tm) = dest_Ø_frac rop_tm;
		val inp1_tm = mk_times(i_tm, np1_tm);
		val jmp1_tm = mk_times(j_tm, mp1_tm);
		val test_tm = mk_º(jmp1_tm, inp1_tm);
		val conv1 = RIGHT_C plus_conv THEN_C times_conv;
		val conv2 = RANDS_C conv1 THEN_C º_conv;
		val thm1 = conv2 test_tm;
		val numer_conv = RANDS_C conv1 THEN_C minus_conv;
		val denom_conv = RANDS_C plus_conv THEN_C times_conv;
		val frac_conv = LEFT_C numer_conv THEN_C RIGHT_C denom_conv
			THEN_C TRY_C Ø_frac_norm_conv;
	in	((fn tm =>
		simple_¥_match_mp_rule Ø_frac_minus_frac_thm (§_t_elim thm1))
		THEN_C frac_conv) tm
		handle Fail _ =>
		((fn tm =>
		simple_¥_match_mp_rule Ø_frac_minus_frac_lemma2 thm1)
		THEN_C RAND_C frac_conv) tm
	end
);
=SML
=TEX
=SML
val €Ø_plus_conv_lemma1› = (
set_goal ([], ¨
	µx y:Ø∑ ~x + ~y = ~(x + y)
Æ);
a(rewrite_tac[Ø_minus_clauses]);
pop_thm()
);
val €Ø_plus_conv_lemma2› = (
set_goal ([], ¨
	µx y:Ø∑ ~x + y = y + ~x
Æ);
a(rewrite_tac[Ø_plus_clauses]);
pop_thm()
);
val €Ø_plus_conv_lemma3› = (
set_goal ([], ¨~(ÓØ 0) = ÓØ 0Æ);
a(rewrite_tac[Ø_minus_clauses]);
pop_thm()
);

=TEX
Now these pieces may be fitted together to give the conversion
for real plus:
=SML
val €Ø_plus_conv› : CONV = (fn tm =>
	(RANDS_C (Ø_frac_denorm_conv ORELSE_C RAND_C Ø_frac_denorm_conv)
	 THEN_C FIRST_C [
		Ø_frac_plus_frac_conv,
		simple_eq_match_conv Ø_plus_conv_lemma2 THEN_C
			Ø_frac_minus_frac_conv,
		Ø_frac_minus_frac_conv,
		simple_eq_match_conv Ø_plus_conv_lemma1 THEN_C
			 RAND_C Ø_frac_plus_frac_conv THEN_C
			TRY_C (simple_eq_match_conv Ø_plus_conv_lemma3)
 	]) tm
	handle ex => term_fail "Ø_plus_conv" 116305 [tm]
);
=TEX
\subsection{Multiplication}
=SML
val €Ø_frac_times_frac_conv› : CONV = (fn tm =>
	(simple_eq_match_conv Ø_frac_times_frac_thm THEN_C
	RIGHT_C (RANDS_C plus_conv THEN_C times_conv) THEN_C
	LEFT_C times_conv
	THEN_TRY_C Ø_frac_norm_conv) tm
	handle Fail _ => term_fail "Ø_frac_times_frac_conv" 116306 [tm]
);
=TEX
=TEX
=SML
val €Ø_times_conv_lemma1› = (
set_goal ([], ¨µx y:Ø∑ ~x * ~y = x * yÆ);
a(rewrite_tac[Ø_times_minus_thm]);
pop_thm()
);
val €Ø_times_conv_lemma2› = (
set_goal ([], ¨
	µx y:Ø∑ ~x * y = ~(x * y)
Æ);
a(rewrite_tac[Ø_times_minus_thm]);
pop_thm()
);
val €Ø_times_conv_lemma3› = (
set_goal ([], ¨
	µx y:Ø∑ x * ~y = ~(x * y)
Æ);
a(rewrite_tac[Ø_times_minus_thm]);
pop_thm()
);
=TEX
=SML
val €Ø_times_conv› : CONV = (fn tm =>
	(RANDS_C (Ø_frac_denorm_conv ORELSE_C RAND_C Ø_frac_denorm_conv)
	 THEN_C FIRST_C [
		Ø_frac_times_frac_conv,
		simple_eq_match_conv Ø_times_conv_lemma1 THEN_C
			Ø_frac_times_frac_conv,
		simple_eq_match_conv Ø_times_conv_lemma2 THEN_C
			RAND_C Ø_frac_times_frac_conv THEN_C
			TRY_C (simple_eq_match_conv Ø_plus_conv_lemma3),
		simple_eq_match_conv Ø_times_conv_lemma3 THEN_C
			RAND_C Ø_frac_times_frac_conv THEN_C
			TRY_C (simple_eq_match_conv Ø_plus_conv_lemma3)
	]) tm
	handle ex => term_fail "Ø_times_conv" 116306 [tm]
);
=TEX
=TEX
\subsection{Reciprocals}
=SML
val €Ø_frac_recip_conv› : CONV = (fn tm =>
	let	val (a_tm, b_tm) = dest_Ø_frac (dest_Ø_recip tm)
		handle Fail _ =>
		term_fail "Ø_frac_recip_conv" 116301 [tm];
		val a = dest_Ó a_tm
			handle Fail _ =>
			term_fail "Ø_frac_recip_conv" 116308 [tm];
	in	if	a = zero
		then	term_fail "Ø_frac_recip_conv" 116307 [tm]
		else	let	val al1_tm = mk_Ó (a @- one);
				val al1p1_tm = mk_plus(al1_tm, one_tm);
				val mid_tm = mk_Ø_recip(
						mk_Ø_frac(al1p1_tm, b_tm));
				val thm1 = eq_sym_rule(
					RAND_C(LEFT_C plus_conv) mid_tm);
				val thm2 = conv_rule
					(RIGHT_C(RANDS_C plus_conv))
						(simple_eq_match_conv
						 Ø_frac_recip_thm mid_tm);
			in	eq_trans_rule thm1 thm2
			end
	end	
);
=TEX
=SML
val €Ø_recip_conv_thm› = (
set_goal ([], ¨µm n∑
	~(((m+1)/(n+1))) õ-õ1 = ~(((m+1)/(n+1))õ-õ1)
Æ);
a(REPEAT strip_tac THEN rewrite_tac[get_spec¨$/âNÆ]);
a(LEMMA_T ¨≥m + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ¨≥n + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(lemma_tac ¨≥ÓØ(m + 1) = ÓØ 0 ± ≥ÓØ(n + 1) = ÓØ 0 Æ
	THEN1 asm_rewrite_tac[ÓØ_one_one_thm]);
a(all_fc_tac[Ø_over_eq_0_thm]);
a(ALL_FC_T rewrite_tac[Ø_minus_recip_thm]);
pop_thm ()
);
=TEX
The following writes $a/b$ as $(m+1)/(n+1)$ if possible:
=SML
val €Ø_non_0_denorm_conv› : CONV = (
	let	val numer_conv = (fn tm =>
			let	val im1_tm = mk_Ó(dest_Ó tm @- one);
			in	eq_sym_rule(plus_conv(mk_plus(im1_tm, one_tm)))
			end
		);
	in	Ø_frac_denorm_conv THEN_C LEFT_C numer_conv
	end
);
=TEX
=SML
val €Ø_recip_conv› : CONV = (fn tm =>
	((		RAND_C Ø_frac_denorm_conv
	 THEN_C		Ø_frac_recip_conv
	 THEN_TRY_C	Ø_frac_norm_conv)
ORELSE_C
	(RAND_C		(RAND_C Ø_non_0_denorm_conv)
	 THEN_C		simple_eq_match_conv Ø_recip_conv_thm
	 THEN_C		RAND_C (RAND_C (LEFT_C plus_conv)
				THEN_C Ø_frac_recip_conv)
	 THEN_TRY_C	RAND_C Ø_frac_norm_conv
	)) tm
	handle Fail _ => term_fail "Ø_recip_conv" 116308 [tm]
);
=TEX
\subsection{Ordering Relations}
=SML
=TEX
=SML
val €Ø_less_conv_lemma1› = (
set_goal ([], ¨
	µx y:Ø∑ ~x < ~y § y < x
Æ);
a(REPEAT µ_tac);
a(once_rewrite_tac[Ø_less_0_less_thm]);
a(rewrite_tac[Ø_plus_clauses, Ø_minus_clauses, µ_elim¨xÆØ_plus_order_thm]);
pop_thm()
);
=TEX
=SML
val €Ø_less_conv_lemma2› = (
set_goal ([], ¨
	µ i j m n∑ i / (m + 1) < ~ (j / (n + 1)) § F
Æ);
a(rewrite_tac[Ø_frac_less_minus_frac_thm]);
pop_thm()
);
=TEX
=SML
val €Ø_frac_less_frac_conv› : CONV = (fn tm =>
	(simple_eq_match_conv Ø_frac_less_frac_thm THEN_C
	 RANDS_C (RIGHT_C plus_conv THEN_C times_conv) THEN_C
	 less_conv
	) tm
	handle ex => term_fail "Ø_frac_less_conv" 116309 [tm]
);
=TEX
=SML
val €Ø_less_conv› : CONV = (fn tm =>
	(RANDS_C (Ø_frac_denorm_conv ORELSE_C RAND_C Ø_frac_denorm_conv)
	 THEN_C FIRST_C [
		Ø_frac_less_frac_conv,
		simple_eq_match_conv Ø_less_conv_lemma1 THEN_C
			Ø_frac_less_frac_conv,
		simple_eq_match_conv Ø_minus_frac_less_frac_thm THEN_C
		RIGHT_C plus_conv THEN_C less_conv,
		simple_eq_match_conv Ø_less_conv_lemma2 
	]) tm
	handle ex => term_fail "Ø_less_conv" 116309 [tm]
);
=TEX
=SML
val €Ø_º_conv_lemma› = (
set_goal([], ¨µx y:Ø∑x º y § ≥y < xÆ);
a(rewrite_tac[Ø_≥_less_º_thm]);
pop_thm()
);
=TEX
=SML
val €Ø_º_conv› : CONV = (fn tm =>
	(simple_eq_match_conv Ø_º_conv_lemma THEN_C
	 RAND_C Ø_less_conv THEN_C 
	 (simple_eq_match_conv ≥_t_thm ORELSE_C simple_eq_match_conv ≥_f_thm)
	) tm
	handle ex => term_fail "Ø_º_conv" 116310 [tm]
);
=TEX
=SML
val €Ø_eq_conv_lemma1› = Ø_minus_eq_thm;
=TEX
=SML
val €Ø_eq_conv_lemma2› = (
set_goal ([], ¨
	µ i j m n∑ i / (m + 1) = ~(j / (n + 1)) § 0 = i + j
Æ);
a(REPEAT µ_tac THEN rewrite_tac[Ø_eq_º_thm, Ø_º_conv_lemma]);
a(rewrite_tac[Ø_minus_frac_less_frac_thm, Ø_frac_less_minus_frac_thm]);
a(PC_T1 "lin_arith"  prove_tac[]);
pop_thm()
);
=TEX
=SML
val €Ø_frac_eq_frac_conv› : CONV = (fn tm =>
	(simple_eq_match_conv Ø_frac_cross_mult_eq_thm THEN_C
	 RANDS_C (RIGHT_C plus_conv THEN_C times_conv) THEN_C
	 Ó_eq_conv
	) tm
	handle ex => term_fail "Ø_frac_less_conv" 116309 [tm]
);
=TEX
=SML
val €Ø_eq_conv› : CONV = (fn tm =>
	(RANDS_C (Ø_frac_denorm_conv ORELSE_C RAND_C Ø_frac_denorm_conv)
	 THEN_C FIRST_C [
		Ø_frac_eq_frac_conv,
		simple_eq_match_conv Ø_eq_conv_lemma1 THEN_C
			Ø_frac_eq_frac_conv,
		simple_eq_match_conv Ø_eq_conv_lemma2 THEN_C
		RIGHT_C plus_conv THEN_C Ó_eq_conv,
		eq_sym_conv THEN_C
		simple_eq_match_conv Ø_eq_conv_lemma2 THEN_C
		RIGHT_C plus_conv THEN_C Ó_eq_conv
	]) tm
	handle ex => term_fail "Ø_eq_conv" 116311 [tm]
);
=TEX
\subsection{Subtraction}
=SML
val €Ø_subtract_conv› =  (fn tm =>
	simple_eq_match_conv Ø_subtract_def tm
	handle ex => term_fail "Ø_subtract_conv" 116315 [tm]
);
=TEX
\subsection{Division}
=SML
val €Ø_over_conv_lemma1› = (
set_goal([], ¨
	µx m n∑ x / ((m+1)/(n+1)) = x * ((n+1)/(m+1))
Æ);
a(REPEAT strip_tac THEN 
	conv_tac(RIGHT_C(once_rewrite_conv
		[conv_rule(ONCE_MAP_C eq_sym_conv)Ø_frac_recip_thm])));
a(rewrite_tac[get_spec¨$/âNÆ]);
a(LEMMA_T ¨≥m + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ¨≥n + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(lemma_tac ¨≥ÓØ(m + 1) = ÓØ 0 ± ≥ÓØ(n + 1) = ÓØ 0 Æ
	THEN1 asm_rewrite_tac[ÓØ_one_one_thm]);
a(lemma_tac¨≥ ÓØ (m + 1) / ÓØ (n + 1) = ÓØ 0Æ THEN1 
	all_fc_tac[Ø_over_eq_0_thm]);
a(ALL_FC_T rewrite_tac[Ø_over_times_recip_thm]);
pop_thm()
);
=TEX
=SML
val €Ø_over_conv_lemma2› = (
set_goal([], ¨
	µx m n∑ ~x / ((m+1)/(n+1)) = (x * ~((n+1)/(m+1)))
Æ);
a(rewrite_tac[Ø_over_conv_lemma1, Ø_times_minus_thm]);
pop_thm()
);
=TEX
=SML
val €Ø_over_conv_lemma3› = (
set_goal([], ¨
	µx m n∑ x / ~((m+1)/(n+1)) = (x * ~((n+1)/(m+1)))
Æ);
a(REPEAT strip_tac THEN rewrite_tac[Ø_times_minus_thm] THEN 
	conv_tac(RIGHT_C(once_rewrite_conv
		[conv_rule(ONCE_MAP_C eq_sym_conv)Ø_frac_recip_thm])));
a(rewrite_tac[get_spec¨$/âNÆ]);
a(LEMMA_T ¨≥m + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(LEMMA_T ¨≥n + 1 = 0 Æ asm_tac THEN1 prove_tac[]);
a(lemma_tac ¨≥ÓØ(m + 1) = ÓØ 0 ± ≥ÓØ(n + 1) = ÓØ 0 Æ
	THEN1 asm_rewrite_tac[ÓØ_one_one_thm]);
a(lemma_tac¨≥ ÓØ (m + 1) / ÓØ (n + 1) = ÓØ 0Æ THEN1 
	all_fc_tac[Ø_over_eq_0_thm]);
a(TOP_ASM_T (strip_asm_tac	o rewrite_rule[Ø_minus_clauses, Ø_plus_clauses] o
	once_rewrite_rule[Ø_eq_thm] o conv_rule (ONCE_MAP_C eq_sym_conv)));
a(ALL_FC_T (fn ths => conv_tac (LEFT_C (once_rewrite_conv ths)))
	[Ø_over_times_recip_thm]);
a(ALL_FC_T once_rewrite_tac[Ø_minus_recip_thm]);
a(rewrite_tac[Ø_times_minus_thm]);
pop_thm()
);
=TEX
=SML
val €Ø_over_conv_lemma4› = (
set_goal([], ¨
	µx m n∑ ~x / ~((m+1)/(n+1)) = (x * ((n+1)/(m+1)))
Æ);
a(rewrite_tac[Ø_over_conv_lemma3, Ø_times_minus_thm]);
pop_thm()
);
=TEX
=SML
val OPT_MINUS_C : CONV -> CONV = (fn c =>
 	c ORELSE_C (fn t => (dest_Ø_minus t; RAND_C c t))
);
=TEX
=SML
val €Ø_over_conv› : CONV = (fn tm =>
	let
		val conv1 = RIGHT_C (OPT_MINUS_C Ø_non_0_denorm_conv);
		val conv2 = (FIRST_C o map simple_eq_match_conv) [
			Ø_over_conv_lemma4,
			Ø_over_conv_lemma3,
			Ø_over_conv_lemma2,
			Ø_over_conv_lemma1];
		val conv3 =
		RIGHT_C (OPT_MINUS_C (RANDS_C plus_conv THEN_TRY_C Ø_frac_norm_conv))
		THEN_TRY_C Ø_times_conv;
	in	(conv1 THEN_C conv2 THEN_C conv3) tm
	end	handle Fail _ => term_fail "Ø_over_conv" 116312 [tm]
);
=TEX
\subsection{Greater-than and Greater-than-or-equal}
=SML
val €Ø_greater_conv› : CONV = (fn tm =>
	simple_eq_match_conv Ø_greater_def tm
	handle ex => term_fail "Ø_greater_conv" 116313 [tm]
);
=TEX
=SML
val €Ø_æ_conv› : CONV = (fn tm =>
	simple_eq_match_conv Ø_æ_def tm
	handle ex => term_fail "Ø_æ_conv" 116314 [tm]
);
=TEX
\subsection{Absolute Value}
=SML
val €Ø_abs_conv_lemma› = (
set_goal([], ¨µi m∑ Abs(~(i/(m+1))) = i/(m+1)Æ);
a(rewrite_tac[Ø_abs_minus_thm, Ø_abs_frac_thm]);
pop_thm()
);
=SML
val €Ø_abs_conv› =  (fn tm =>
	((RAND_C Ø_frac_denorm_conv THEN_C
	 simple_eq_match_conv Ø_abs_frac_thm THEN_C
	RIGHT_C plus_conv THEN_TRY_C Ø_frac_norm_conv)
ORELSE_C (RAND_C(RAND_C Ø_frac_denorm_conv) THEN_C
	 simple_eq_match_conv Ø_abs_conv_lemma THEN_C
	RIGHT_C plus_conv THEN_TRY_C Ø_frac_norm_conv)) tm
	handle ex => term_fail "Ø_abs_conv" 116316 [tm]
);
=TEX
\subsection{Negation}
=TEX
=SML
val €Ø_minus_minus_thm› =tac_proof(([],
	¨µx:Ø∑ ~(~ x) = x Æ),
	rewrite_tac[Ø_minus_clauses]);
=TEX
=SML
val €Ø_minus_0_thm› =tac_proof(([],
	¨µx:Ø∑ ~(ÓØ 0) = ÓØ 0 Æ),
	rewrite_tac[Ø_minus_clauses]);
=TEX
=SML
val €Ø_minus_conv› : CONV = (fn tm =>
	(dest_Ø_minus tm handle Fail _ => term_fail "Ø_abs_conv" 116319 [tm]);
	REPEAT_C1 (simple_eq_match_conv Ø_minus_minus_thm) AND_OR_C
	(Ø_frac_norm_conv ORELSE_C RAND_C Ø_frac_norm_conv) AND_OR_C
	simple_eq_match_conv Ø_minus_0_thm
);
=TEX
\subsection{Exponentiation}
=SML
val €Ø_Ó_exp_def› = get_spec¨$^âNÆ;
=TEX
=SML
val €Ø_Ó_exp_conv_lemma1› = (
set_goal([], ¨µx:Ø; m:Ó∑ x ^ (m + m) = x ^ m * x ^ mÆ);
a(REPEAT strip_tac THEN induction_tac ¨m:ÓÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[Ø_Ó_exp_def, Ø_times_clauses]);
(* *** Goal "2" *** *)
a(rewrite_tac[plus_assoc_thm1, Ø_Ó_exp_def]);
a(rewrite_tac[µ_elim¨mÆ plus_order_thm]);
a(asm_rewrite_tac[plus_assoc_thm1, Ø_Ó_exp_def]);
a(rewrite_tac[µ_elim¨xÆ Ø_times_order_thm]);
pop_thm()
);
=TEX
=SML
val €Ø_Ó_exp_conv_lemma2› = (
set_goal([], ¨µx:Ø; m:Ó∑ x ^ (m + m + 1) = (x ^ m * x ^ m) * xÆ);
a(REPEAT strip_tac);
a(rewrite_tac[plus_assoc_thm1, Ø_Ó_exp_def, Ø_Ó_exp_conv_lemma1]);
a(rewrite_tac[µ_elim¨xÆ Ø_times_order_thm]);
pop_thm()
);
=TEX
=SML
val €Ø_Ó_exp_conv_lemma3› = (
set_goal([], ¨µx:Ø∑ x ^ 0 = ÓØ 1Æ);
a(rewrite_tac[Ø_Ó_exp_def]);
pop_thm()
);
=TEX
Note that the following theorem might produce an unnormalised answer, so the
conversion must take care. 
=SML
val €Ø_Ó_exp_conv_lemma4› = (
set_goal([], ¨µx:Ø; m:Ó∑ x ^ 1 = xÆ);
a(REPEAT strip_tac);
a(LEMMA_T ¨x ^ 1 = x ^ (0 + 1)Æ pure_rewrite_thm_tac THEN1 rewrite_tac[]);
a(pure_rewrite_tac[Ø_Ó_exp_def]);
a(rewrite_tac[Ø_times_clauses]);
pop_thm()
);
=TEX
=SML
val €two› = @@"2";
val €three› = @@"3";
val rec €Ø_Ó_exp_conv› =  (fn tm =>
	simple_eq_match_conv Ø_Ó_exp_conv_lemma3 tm
	handle Fail _ =>
	(simple_eq_match_conv Ø_Ó_exp_conv_lemma4 THEN_TRY_C Ø_minus_conv) tm
	handle Fail _ =>
	let	val (x_tm, m_tm) = dest_Ø_Ó_exp tm;
		fun check t = (
			(dest_Ø_frac t; mk_t) handle Fail _ => dest_ÓØ t
		);
		val _ = check x_tm
			handle Fail _ => check(dest_Ø_minus x_tm);
		val m = dest_Ó m_tm;
		val mb2 = m idiv two;
		val mb2_tm = mk_Ó mb2;
		fun even_conv t = (
			eq_sym_rule (plus_conv (mk_plus(mb2_tm, mb2_tm)))
		);
		fun odd_conv t = (
			eq_sym_rule ((RIGHT_C plus_conv THEN_C plus_conv)
				(mk_plus(mb2_tm, mk_plus(mb2_tm, one_tm))))
		);
		val recur = Ø_Ó_exp_conv (mk_Ø_Ó_exp(x_tm, mb2_tm));
		fun either_conv t = recur;
	in	(if	m = mb2 @+ mb2
		then	RIGHT_C even_conv THEN_C
			simple_eq_match_conv Ø_Ó_exp_conv_lemma1 THEN_C
			RANDS_C either_conv THEN_C Ø_times_conv
		else	RIGHT_C odd_conv THEN_C
			simple_eq_match_conv Ø_Ó_exp_conv_lemma2
			THEN_C LEFT_C (RANDS_C either_conv THEN_C Ø_times_conv)
			THEN_C Ø_times_conv) tm
	end	handle Fail _ => term_fail "Ø_Ó_exp_conv" 116317 [tm]
);
=TEX
\subsection{General Arithmetic Evaluation}
=SML
val €eval_net› = switch list_net_enter empty_net
[
	(¨x +âR yÆ, Ø_plus_conv),
	(¨x -âR yÆ, Ø_subtract_conv THEN_C RIGHT_C (TRY_C Ø_minus_conv) THEN_C Ø_plus_conv),
	(¨x *âR yÆ, Ø_times_conv),
	(¨x /âR yÆ, Ø_over_conv THEN_C COND_C is_Ø_times fail_conv id_conv),
	(¨x õ-õ1Æ, Ø_recip_conv),
	(¨AbsâR xÆ, Ø_abs_conv),
	(¨~âR xÆ, TRY_C Ø_minus_conv)
];
=TEX
=SML
val rec €Ø_EVAL_C› : CONV -> CONV = (fn user_conv => fn tm =>
	let	fun chk tm = (
			let	val tm2 = dest_Ø_minus tm	handle Fail _=> tm;
			in	let	val (a, b) = dest_Ø_frac tm2;
					val (_, bi) = (dest_Ó a, dest_Ó b);
				in	bi <> zero
				end	handle Fail _ =>
				let	val m = dest_ÓØ tm2;
				in	is_Ó m
				end	handle Fail _ => false
			end
		);
	in	case net_lookup eval_net tm of
			[conv] => RANDS_C (TRY_C(Ø_EVAL_C user_conv)) THEN_C conv
		|	_ => (user_conv AND_OR_C (OPT_MINUS_C Ø_frac_norm_conv))
				THEN_C COND_C chk id_conv fail_conv
	end	tm
	handle	Fail _ => term_fail "Ø_EVAL_C" 116320 [tm]
);
=TEX
=SML
val €Ø_eval_conv› : CONV = (fn tm =>
	Ø_EVAL_C fail_conv tm handle ex as (Fail _) => reraise ex "Ø_eval_conv"
);
=TEX
\section{PROOF CONTEXT}
=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt (current_ad_rw_canon())) thms)
);
=TEX
=SML
val _ = delete_pc "'Ø" handle Fail _ => ();
val _ = new_pc "'Ø";
val _ = set_rw_eqn_cxt
		[	(¨x +âR yÆ, Ø_plus_conv),
			(¨x *âR yÆ, Ø_times_conv),
			(¨x -âR yÆ, Ø_subtract_conv),
			(¨AbsâR xÆ, Ø_abs_conv),
			(¨x /âR yÆ, Ø_over_conv),
			(¨x õ-õ1Æ, Ø_recip_conv),
			(¨x ^âN mÆ, Ø_Ó_exp_conv),
			(¨(x:Ø) = yÆ, Ø_eq_conv),
			(¨x ºâR yÆ, Ø_º_conv),
			(¨x <âR yÆ, Ø_less_conv),
			(¨x æâR yÆ, Ø_æ_conv),
			(¨x >âR yÆ, Ø_greater_conv)
		] "'Ø";
val _ = add_rw_thms [Ø_plus_clauses, Ø_minus_clauses, Ø_º_clauses,
			Ø_less_clauses, Ø_times_clauses]
	"'Ø";
val €pos› = (thms_to_eqn_cxt [Ø_minus_clauses, Ø_º_clauses, Ø_less_clauses]) @
		[	(¨(x:Ø) = yÆ, Ø_eq_conv),
			(¨x æâR yÆ, Ø_æ_conv),
			(¨x >âR yÆ, Ø_greater_conv)];
val €neg› = mapfilter (mk_≥ ** RAND_C) pos;
val €neutral› = [(¨x ºâR yÆ, Ø_º_conv), (¨x <âR yÆ, Ø_less_conv)];
val €strip_eqn_cxt› = neutral @ pos @ neg;
val _ = set_st_eqn_cxt strip_eqn_cxt "'Ø";
val _ = set_sc_eqn_cxt strip_eqn_cxt "'Ø";
val _ = set_pr_tac basic_prove_tac "'Ø";
val _ = set_pr_conv basic_prove_conv "'Ø";
val _ = commit_pc "'Ø";
=TEX
\section{TERM ORDERING FOR Ø}
The ordering must bring together signed literals and like monomials.
We arrange things so that a monomial with a sign comes immediately after the monomial, and with a literal multiplier immediately after that, e.g.:

=GFT
	a*b < ~a * b < 0 * a * b < ~1 * a * b < 1 * a * b < ....
=TEX
The function {\it pervert} below corresponds to the suggestions
in the documentation for {\it gen\_term\_order} taking the sets
$X_m$ to be the numbers of the form $i/m$ together with
$X_{-1}$ containing numbers of the form
=INLINEFT
ÓØ i
=TEX
.
=SML
fun €dest_lit› (tm : TERM) : TERM * TERM = (
	dest_Ø_frac tm handle Fail _ => (dest_ÓØ tm, one_tm)
);
fun €dest_signed_lit› (tm : TERM) : TERM * TERM = (
	let	val (tm3, tm4) = dest_lit tm;
	in	(mk_ÓØ tm3, mk_ÓØ tm4)
	end	handle Fail _ => 
	let	val tm2 = dest_Ø_minus tm;
		val (tm3, tm4) = dest_signed_lit tm2;
	in	(mk_Ø_minus tm3, tm4)
	end	handle Fail _ => 
	let	val tm2 = dest_Ø_recip tm;
		val (tm3, tm4) = dest_signed_lit tm2;
	in	(mk_Ø_recip tm3, mk_Ø_recip tm4) 
	end
);
local
val €bottom› : TERM = mk_const("", mk_vartype "");
fun €pervert› (tm : TERM) : TERM * INTEGER = (
	let	val (a, b) = dest_Ø_times tm;
	in	let	val (x, y) = dest_signed_lit a;
		in	(b, three)
		end	handle Fail _ => (mk_Ø_times(dest_Ø_minus a, b), two)
			handle Fail _ => (tm, one)
	end	handle Fail _ =>
	let	val (x, y) = dest_signed_lit tm;
	in	(bottom, ((dest_lit tm; zero) handle Fail _ => one))
	end	handle Fail _ => (dest_Ø_minus tm, one)
		handle Fail _ => (dest_Ø_recip tm, one)
		handle Fail _ => (tm, zero)
);
in
val €Ø_term_order› = gen_term_order pervert;
end;

=TEX
\section{ANF FOR Ø}
We need conversions and supporting theorems which do collection of
like terms.
First of all we need to provide conversions which, given a (sorted) sum,
=INLINEFT
mâ1 + mâ2
=TEX
\ of two normalised monomials will do all applicable simplifications which can reduce the sum to a single monomial.
We find the following cases, in which $c$d and $d$ denote literals, and where, on the right hand-side of the equations, literal arithmetic expressions are intended to have been evaluated:
=GFT
1.	c*m +d*m 	=	(c + d)*m
2.	m +d*m 		=	(1 + d)*m
3.	0 + m		=	m
4.	c + d		=	c + d
5.	m + m 		=	2*m
6.	m + ~m 		=	0
7.	m*n + ~m*n	=	0
8.	~m + d*m		=	(~1 + d)*m	
9.	~m*n + d*m*n	=	(~1 + d)*m*n
10.	m + 0		=	m
=TEX
Here case 4 is directly supported by $Ø\_plus\_conv$ (note that the order
here is important since case 4 overlaps case 5).
Note that case 5 may introduce a monadic minus in the wrong place.
The others will not do this unless their input has the same flaw.
Note also that that cases 1, 2, 8 and 9 may introduce multiplication
by $1$,
=INLINEFT
~1
=TEX
, or $0$ which must be simplified away.
Case 10 only arises when cancellation during in the polynomial normalisation has caused a sub-polynomial to become $0$.
=SML
val _ = push_merge_pcs ["'Ø", "'Ó", "predicates"];
val €case1_thm› = tac_proof(([], ¨µc d m:Ø∑c*m + d*m = (c + d)*mÆ),
	rewrite_tac[Ø_times_plus_distrib_thm]);
val €case2_thm› = tac_proof(([], ¨µd m:Ø∑m + d*m = (ÓØ 1 + d)*mÆ),
	rewrite_tac[Ø_times_plus_distrib_thm, Ø_plus_assoc_thm]);
val €case3a_thm› = tac_proof(([], ¨µm∑ÓØ 0 + m = mÆ),
	rewrite_tac[]);
val €case3b_thm› = tac_proof(([], ¨µm∑~(ÓØ 0) + m = mÆ),
	rewrite_tac[]);
val €case5_thm› = tac_proof(([], ¨µm:Ø∑m + m = ÓØ 2*mÆ),
	pure_rewrite_tac[prove_rule[]¨ÓØ 2 = ÓØ 1 + ÓØ 1Æ,
		 Ø_times_plus_distrib_thm]
	THEN rewrite_tac[]);
val €case5a_thm› = tac_proof(([], ¨µm n:Ø∑m * ~ n= ~m * nÆ),
	rewrite_tac[Ø_times_minus_thm]);
val €case5b_thm› = tac_proof(([], ¨µm n p:Ø∑m * ~ n * p = ~m * n *pÆ),
	rewrite_tac[Ø_times_minus_thm]);
val €case6_thm› = tac_proof(([], ¨µm:Ø∑m + ~m = ÓØ 0Æ),
	rewrite_tac[Ø_minus_clauses]);
val €case7_thm› = tac_proof(([], ¨µm n:Ø∑m*n + ~m*n = ÓØ 0Æ),
	rewrite_tac[Ø_minus_clauses, Ø_times_minus_thm]);
val €case8_thm› = tac_proof(([], ¨µm:Ø∑~m + d*m = (~(ÓØ 1) + d)*mÆ),
	rewrite_tac[Ø_times_minus_thm,
		Ø_times_clauses, Ø_times_plus_distrib_thm]);
val €case9_thm› = tac_proof(([], ¨µm n:Ø∑~m*n + d*m*n = (~(ÓØ 1) + d)*m*nÆ),
	rewrite_tac[Ø_times_minus_thm,
		Ø_times_clauses, Ø_times_plus_distrib_thm]);
val €case10a_thm› = tac_proof(([], ¨µm:Ø∑m + ÓØ 0 = mÆ),
	rewrite_tac[Ø_plus_0_thm]);
val €case10b_thm› = tac_proof(([], ¨µm:Ø∑m + ~(ÓØ 0) = mÆ),
	rewrite_tac[Ø_plus_0_thm]);
val €case1289a_thm› = tac_proof(([], ¨µm:Ø∑ÓØ 1 *m = mÆ),
	rewrite_tac[Ø_times_clauses]);
val €case1289b_thm› = tac_proof(([], ¨µm:Ø∑~(ÓØ 1) * m = ~mÆ),
	rewrite_tac[Ø_times_clauses, Ø_times_minus_thm]);
val €case1289c_thm› = tac_proof(([], ¨µm:Ø∑(ÓØ 0) * m = ÓØ 0Æ),
	rewrite_tac[Ø_times_clauses]);
=TEX
Now we provide the conversions to support the cases:
=SML
val €case1289_conv› : CONV = (
	(simple_eq_match_conv case1289a_thm ORELSE_C
		simple_eq_match_conv case1289b_thm ORELSE_C
		simple_eq_match_conv case1289c_thm)
);
val €case1_conv› : CONV = (fn tm => (
	(((dest_signed_lit o fst o dest_Ø_times) **
		(dest_signed_lit o fst o dest_Ø_times))
		o dest_Ø_plus) tm;
	(simple_eq_match_conv case1_thm THEN_C LEFT_C Ø_plus_conv
		THEN_TRY_C case1289_conv) tm
));
val €case2_conv› : CONV = (fn tm => (
	(dest_signed_lit o fst o dest_Ø_times o snd o dest_Ø_plus) tm;
	(simple_eq_match_conv case2_thm THEN_C LEFT_C Ø_plus_conv
		THEN_TRY_C case1289_conv) tm
));
val €case3_conv› : CONV = (fn tm =>
	if (dest_Ó o dest_ÓØ o fst o dest_signed_lit o fst o dest_Ø_plus) tm = zero
	then (TRY_C (LEFT_C Ø_frac_norm_conv) THEN_C
		simple_eq_match_conv case3a_thm) tm
		handle Fail _ =>
		(TRY_C (RAND_C (LEFT_C Ø_frac_norm_conv)) THEN_C
		simple_eq_match_conv case3b_thm) tm
	else fail_conv tm
);
val €case4_conv› = Ø_plus_conv;
val €case5_conv› = 
	simple_eq_match_conv case5_thm
	THEN_TRY_C (simple_eq_match_conv case5a_thm ORELSE_C
			simple_eq_match_conv case5b_thm);
val €case6_conv› = simple_eq_match_conv case6_thm;
val €case7_conv› = simple_eq_match_conv case7_thm;
val €case8_conv› : CONV = (fn tm => (
	(dest_signed_lit o fst o dest_Ø_times o snd o dest_Ø_plus) tm;
	(simple_eq_match_conv case8_thm THEN_C LEFT_C Ø_plus_conv
		THEN_TRY_C case1289_conv) tm
));
val €case9_conv› : CONV = (fn tm => (
	(dest_signed_lit o fst o dest_Ø_times o snd o dest_Ø_plus) tm;
	(simple_eq_match_conv case9_thm THEN_C LEFT_C Ø_plus_conv
		THEN_TRY_C case1289_conv) tm
));
val €case10_conv› = FIRST_C
	[simple_eq_match_conv case10a_thm,
	 RIGHT_C (TRY_C Ø_frac_norm_conv)
		THEN_C simple_eq_match_conv case10a_thm,
	 RIGHT_C (RAND_C (TRY_C Ø_frac_norm_conv))
		THEN_C  simple_eq_match_conv case10b_thm
];
=TEX
=SML
=TEX
The following conversional converts a conversion acting on $x + y$, say,
to one which will also act on $x + y + z$ (by rewriting it as $(x + y) + z$
and then applying the conversion to the subterm $x + y$).
=SML
val €Ø_plus› = ¨$+âRÆ;
fun €A_C› (c : CONV) : CONV = (fn tm =>
	let	val (ltm, rtm) = dest_Ø_plus tm;
		exception BaseCase;
	in let	val (rtm1, rtm2) = dest_Ø_plus rtm
		handle Fail _ => raise BaseCase;
		val thm = c (mk_Ø_plus(ltm, rtm1));
	in	eq_trans_rule
		(list_µ_elim[ltm, rtm1, rtm2] Ø_plus_assoc_thm1)
		(app_arg_rule rtm2 (app_fun_rule Ø_plus thm))
	end 	handle BaseCase => c tm
	end
);
=TEX
We want to simplify multiplication according to the following scheme, where $x$ and $y$ denotes atoms (and other variables are as in the list of simplifications for addition):
=GFT
1.	c*d		= c*d
2.	0*x		= 0
3.	1*x		= x
4.	~1*~x		= x
5.	~1*x		= ~x
6.	~x*~y		= x*y
7.	x*~y		= ~x*y
=TEX
=SML
val €times234567_thm› = tac_proof(([],
	¨µx y:Ø∑
		ÓØ 0 * x = ÓØ 0
	±	~(ÓØ 0) * x = ÓØ 0
	±	ÓØ 1 * x = x
	±	~(ÓØ 1) * ~x = x
	±	~(ÓØ 1) * x = ~x
	±	~x * ~y = x*y
	±	x * ~y = ~x*y Æ),
	rewrite_tac[Ø_times_clauses, Ø_minus_clauses, Ø_times_minus_thm]);
=TEX
=SML
val €times1234567_conv› : CONV = (
		FIRST_C (
			Ø_times_conv :: 
			map simple_eq_match_conv
			(current_ad_rw_canon() times234567_thm))
);
=TEX
$M\_C$ is analogous to $A\_C$ but for multiplication rather than addition.
There are additional cases to worry about.
=SML
val €times0_thm› = tac_proof(([],
	¨µx:Ø∑ÓØ 0 * x = ÓØ 0Æ),
		rewrite_tac[Ø_times_clauses]);

val €times_minus0_thm› = tac_proof(([],
	¨µx:Ø∑~(ÓØ 0) * x = ÓØ 0Æ),
		rewrite_tac[Ø_times_clauses, Ø_minus_clauses]);

val €Ø_times› = ¨$*âRÆ;
fun €M_C1› (c : CONV) : CONV = (fn tm =>
	let	val (ltm, rtm) = dest_Ø_times tm;
		exception BaseCase;
	in let	val (rtm1, rtm2) = dest_Ø_times rtm
		handle Fail _ => raise BaseCase;
		val thm = c (mk_Ø_times(ltm, rtm1));
	in	eq_trans_rule
		(list_µ_elim[ltm, rtm1, rtm2] Ø_times_assoc_thm1)
		(app_arg_rule rtm2 (app_fun_rule Ø_times thm))
	end 	handle BaseCase => c tm
	end
);
fun €M_C› (c : CONV) : CONV = 
	M_C1 c THEN_TRY_C
	FIRST_C (map simple_eq_match_conv
		[times0_thm, times_minus0_thm, Ø_times_assoc_thm]
);
=TEX
Finally, we need to sort out reciprocals, unary minus and unnormalised literal fractions:
=SML
val rec €Ø_signed_lit_conv› = (fn tm =>
	(dest_Ø_minus tm;
		RAND_C (Ø_frac_norm_conv ORELSE_C Ø_signed_lit_conv) THEN_TRY_C
		simple_eq_match_conv Ø_minus_minus_thm) tm
	handle Fail _ =>
	(dest_Ø_recip tm;
		RAND_C (TRY_C Ø_signed_lit_conv) THEN_C Ø_recip_conv) tm
	handle Fail _ => 
	(dest_Ø_frac tm;
		Ø_frac_norm_conv) tm
);
=TEX
Pulling these bits together we get the following:.
=SML
val €add_simp_conv› =
	FIRST_C(map A_C[
		case1_conv, case2_conv, case3_conv, case4_conv,
		case5_conv, case6_conv, case7_conv, case8_conv,
		case9_conv, case10_conv]) THEN_C TRY_C case3_conv;
val €times_simp_conv› = 
	REPEAT_C1
	(M_C (FIRST_C[
		CHANGED_C(RANDS_C (TRY_C Ø_signed_lit_conv)),
		times1234567_conv,
		Ø_signed_lit_conv]));

=TEX
Unlike the natural number case, we have some  non-trivial work to
do trying to make non-atoms from what $poly\_conv$ will see as
atoms if we don't push monadic and dyadic minus around.
The transformation is done according to the following schema:
=GFT
1. ~ (~ m)		= m			(repeatedly)
2. ~(m + n)		= ~m + ~n
3. ~(m * n)		= ~m * n
4. (m - n)		= m + ~n
5. ~(m - n)		= ~m + n
6. ~0			= 0
=TEX
Note that the first of these must be performed repeatedly, since $poly\_conv$
will only apply it once, and, if there are more than four monadic minuses
this may be insufficient to reveal a non-atom for $poly\_conv$ to attack.
=SML
val €minus23456_thm› = tac_proof(([],
	¨µm:Ø∑~(m + n) =~m + ~n
	±	~(m * n) = ~m * n
	±	m - n = m + ~n
	±	~(m - n) = ~m + n
	±	~(ÓØ 0) = ÓØ 0Æ),
	rewrite_tac[Ø_minus_clauses, Ø_times_minus_thm, get_spec¨$-âRÆ]);
=TEX
=SML
val €minus1_conv› : CONV = REPEAT_C1 (simple_eq_match_conv Ø_minus_minus_thm);
val €minus23456_convs› : CONV list 
	= map simple_eq_match_conv (current_ad_rw_canon()minus23456_thm);
val €minus_simp_conv› : CONV = minus1_conv AND_OR_C FIRST_C minus23456_convs;
=TEX
We also need to replace division by literals by multiplication by the reciprocal.
to handle cases such as $x / (m + n)$. We use the evaluation conversion rather
than full normalisation to do this for efficiency. The slight loss in functionality
can be worked around (the user can explicitly apply the normalisation to the
denominator if necessary). The conversion used is passed as the parameter to
the following conversional.
=SML
val rec €OVER_SIMP_C› : CONV -> CONV = (fn conv => fn tm => (
	(dest_Ø_over tm;
	(TRY_C (RIGHT_C conv) THEN_C Ø_over_conv) tm)
	handle Fail _ =>
	(dest_Ø_minus tm; RAND_C (OVER_SIMP_C conv) tm)
));
=TEX
We need the following theorem:
=SML
val €Ø_left_times_plus_distrib_thm› =
	all_µ_intro(±_left_elim(all_µ_elim Ø_times_plus_distrib_thm));
=TEX
Now we can define the external interfaces:
=SML
local
val  €Ø_ANF_C_AUX› : CONV -> CONV = ( 
	poly_conv
	Ø_term_order
	Ø_plus_comm_thm
	Ø_plus_assoc_thm
	Ø_times_comm_thm
	Ø_times_assoc_thm
	Ø_left_times_plus_distrib_thm
	(add_simp_conv)
	(times_simp_conv)
);
in
fun  €Ø_ANF_C› (conv : CONV) : CONV = (fn tm =>
	(Ø_ANF_C_AUX (
		conv AND_OR_C
		Ø_signed_lit_conv AND_OR_C
		minus_simp_conv AND_OR_C
		OVER_SIMP_C (Ø_EVAL_C conv)) tm)
	handle Fail _ => term_fail "Ø_ANF_C" 116318 [tm]
);
val €Ø_anf_conv› : CONV = (fn tm =>
	(Ø_ANF_C fail_conv tm)
		handle ex => (
			if area_of ex = "Ø_ANF_C"
			then reraise ex "Ø_anf_conv"
			else raise ex
	)
);
end;
=TEX


\section{LINEAR ARITHMETIC DECISION PROCEDURE}
The material in this section implements the linear
arithmetic decision procedure for the reals.
\section{Preliminaries}
=SML
open LinearArithmeticTools;
=TEX
\subsection{Theorems and Rules}
We need the ability to multiply an equation or inequality appearing as the
conclusion of a theorem by a (positive integer literal);
the following two theorems are used to justify this (note that there is no
arithmetic content in the theorem about equalities).
=SML
val €scale_eq_thm›  = tac_proof(
	([], ¨µk:Ø; i j:Ø∑i = j ¥ k * i = k * jÆ),
	REPEAT strip_tac THEN asm_rewrite_tac[]);
val €pos_scale_º_thm› = tac_proof(
	([], ¨µm:Ó; i j:Ø∑i º j ¥ ÓØ m * i º ÓØ m * jÆ),
	rewrite_tac[Ø_º_def] THEN REPEAT strip_tac THEN_TRY all_var_elim_asm_tac1 THEN
	REPEAT strip_tac THEN
	strip_asm_tac (µ_elim¨m:ÓÆÓ_cases_thm) THEN all_var_elim_asm_tac1
	THEN1 rewrite_tac[] THEN
	i_contr_tac THEN swap_nth_asm_concl_tac 1 THEN
	strip_asm_tac(µ_elim¨i':ÓÆÓØ_0_less_thm) THEN all_fc_tac[Ø_times_mono_thm]);
val €pos_scale_less_thm› = tac_proof(([], ¨µm:Ó; i j:Ø∑i < j ¥ ÓØ (m+1) * i < ÓØ (m+1) * jÆ),
	REPEAT strip_tac THEN bc_thm_tac Ø_times_mono_thm THEN REPEAT strip_tac
	THEN rewrite_tac[ÓØ_0_less_thm]);
=TEX
The next set of theorems justify adding equalities and inequalities:
=SML
val €add_eq_eq_thm› = tac_proof(([],
	¨µm n i j:Ø∑m = n ± i = j ¥ m + i = n + jÆ),
	REPEAT strip_tac THEN asm_rewrite_tac[]);
val €add_eq_º_thm› = tac_proof(([],
	¨µm n i j:Ø∑m = n ± i º j ¥ m + i º n + jÆ),
	REPEAT strip_tac THEN asm_rewrite_tac[]);
val €add_º_º_thm› = tac_proof(
	([], ¨µm n i j:Ø∑m º n ± i º j ¥ m + i º n + jÆ),
	rewrite_tac[Ø_º_def] THEN REPEAT strip_tac THEN_TRY
	(all_var_elim_asm_tac1 THEN asm_rewrite_tac[])
	THEN all_fc_tac[Ø_plus_mono_thm2]);
val €add_eq_less_thm› = tac_proof(([],
	¨µm n i j:Ø∑m = n ± i < j ¥ m + i < n + jÆ),
	REPEAT strip_tac THEN asm_rewrite_tac[]);
val €add_less_less_thm› = tac_proof(([],
	¨µm n i j:Ø∑m < n ± i < j ¥ m + i < n + jÆ),
	accept_tac Ø_plus_mono_thm2);
val €add_less_º_thm› = tac_proof(([],
	¨µm n i j:Ø∑m < n ± i º j ¥ m + i < n + jÆ),
	rewrite_tac[Ø_º_def] THEN REPEAT strip_tac THEN_LIST [
		all_asm_fc_tac[Ø_plus_mono_thm2],
		asm_rewrite_tac[]]);
=TEX
Note: notwithstanding the rather complex coding of the version of these functions
for the natural numbers, Hodes' algorithm as implemented in \cite{DS/FMU/IED/IMP082} produces a polynomial in which the only negative coefficients correspond to equations in the original input.
The following function does not therefore need a case for negating an inequality.

If performance dictates, a more customised conversion than
=INLINEFT
Ø_anf_conv
=TEX
\ could be used here to exploit the fact that the input theorem will already have its
conclusion in ANF in our application here.
=SML
fun €lit_scale_rule› (b : INTEGER) (th : THM) : THM = (
	let	val (scale_th, conv) =  (
			case (fst o dest_const o fst o strip_app o concl) th of
				"ºâR" => (
				(simple_µ_elim (mk_Ó b) pos_scale_º_thm, id_conv)
			) |	"<âR" => (
				(simple_µ_elim (mk_Ó (b @- one)) pos_scale_less_thm,
				 LEFT_C (RAND_C plus_conv))
			) |	_ => (
				(simple_µ_elim (
					if	b @>= zero
					then	mk_ÓØ (mk_Ó b)
					else	mk_Ø_minus(mk_ÓØ (mk_Ó (@~ b))))
					scale_eq_thm, id_conv)
			)
		);
	in	(conv_rule (RANDS_C (conv THEN_C TRY_C Ø_anf_conv))
			o ¥_match_mp_rule scale_th) th
	end
);
=IGN
val th1 = asm_rule¨a + b º ÓØ 0Æ;
val th2 = asm_rule¨~(3/2)*a º ~(1/2)Æ;
val th3 = asm_rule¨~b  + (4/52)*a º ~(ÓØ 1)Æ;
val th4 = asm_rule¨~b  + (4/5)*a = ~(ÓØ 1)Æ;
val th5 = asm_rule¨a = ~(ÓØ 1)Æ;
val th6 = asm_rule¨~b  + (4/5)*a < ~(ÓØ 1)Æ;
lit_scale_rule (@@"1") th1;
lit_scale_rule (@@"4") th1;
lit_scale_rule (@@"3") th2;
lit_scale_rule (@@"5") th3;
lit_scale_rule (@@"5") th4;
lit_scale_rule (@@"-6") th4;
lit_scale_rule (@@"-2") th5;
lit_scale_rule (@@"2") th6;
=TEX
=SML
fun €sum2_rule› (th1 : THM) (th2: THM) : THM = (
	let	val rator1 = (fst o dest_const o fst o strip_app o concl) th1;
		val rator2 = (fst o dest_const o fst o strip_app o concl) th2;
		val (add_th, conj_th) = (
			case (rator1, rator2) of
				("=", "=") => (add_eq_eq_thm, ±_intro th1 th2)
			|	("=", "ºâR") => (add_eq_º_thm, ±_intro th1 th2)
			|	("=", "<âR") => (add_eq_less_thm, ±_intro th1 th2)
			|	("ºâR", "=") => (add_eq_º_thm, ±_intro th2 th1)
			|	("ºâR", "ºâR") => (add_º_º_thm, ±_intro th1 th2)
			|	("ºâR", "<âR") => (add_less_º_thm, ±_intro th2 th1)
			|	("<âR", "=") => (add_eq_less_thm, ±_intro th2 th1)
			|	("<âR", "ºâR") => (add_less_º_thm, ±_intro th1 th2)
			|	("<âR", "<âR") => (add_less_less_thm, ±_intro th1 th2)
			|	_ => thm_fail "sum2_rule" 999 [th1, th2]
		);
	in	(conv_rule (RAND_C Ø_plus_conv) o ¥_match_mp_rule add_th)
		conj_th
	end
	handle Fail _ => thm_fail "sum2_rule" 999 [th1, th2]
(* ?0 and ?1 are not both of the form Ù a = b, Ù a < b, Ù a º b Ù a > b or Ùa æ b *)
);
=IGN
sum2_rule (asm_rule¨x = ÓØ 2Æ) (asm_rule¨y = ÓØ 3Æ);
sum2_rule (asm_rule¨x º ÓØ 2Æ) (asm_rule¨y = ÓØ 3Æ);
sum2_rule (asm_rule¨x < ÓØ 2Æ) (asm_rule¨y = ÓØ 3Æ);
sum2_rule (asm_rule¨x = ÓØ 2Æ) (asm_rule¨y º ÓØ 3Æ);
sum2_rule (asm_rule¨x º ÓØ 2Æ) (asm_rule¨y º ÓØ 3Æ);
sum2_rule (asm_rule¨x < ÓØ 2Æ) (asm_rule¨y º ÓØ 3Æ);
sum2_rule (asm_rule¨x = ÓØ 2Æ) (asm_rule¨y < ÓØ 3Æ);
sum2_rule (asm_rule¨x º ÓØ 2Æ) (asm_rule¨y < ÓØ 3Æ);
sum2_rule (asm_rule¨x < ÓØ 2Æ) (asm_rule¨y < ÓØ 3Æ);
=TEX
=SML
fun €scale_and_sum2_rule› (a1 : INTEGER) (th1 : THM) (th2: THM) : THM = (
	sum2_rule (lit_scale_rule a1 th1) th2
);
=TEX
=SML
fun €scaled_sum_rule› (aths : (INTEGER * THM) list) : THM = (
	let 	fun r aths = (
			case aths of
				[] => fail "sum2_rule" 9089 []
			|	[(a, th)] =>
					lit_scale_rule a th
			|	(a, th) :: more =>
					scale_and_sum2_rule a th (r more)
		);
	in	conv_rule (TRY_C (LEFT_C Ø_anf_conv)
			THEN_C TRY_C (Ø_º_conv ORELSE_C Ø_less_conv ORELSE_C Ø_eq_conv)) (r aths)
	end
);
=IGN
scaled_sum_rule (map (Combinators.I ** asm_rule) [
	(one,	¨a º ÓØ 0Æ),
	(one,	¨~a º ~(ÓØ 1)Æ)
]);
scaled_sum_rule (map (Combinators.I ** asm_rule) [
	(one,	¨a + b = ÓØ 0Æ),
	(one,	¨~a º ~(ÓØ 1)Æ),
	(one,	¨~b º ~(ÓØ 1)Æ)
]);
scaled_sum_rule (map (Combinators.I ** asm_rule) [
	(one,	¨a + b = ÓØ 0Æ),
	(minus_one,	¨a = ÓØ 1Æ),
	(minus_one,	¨b = ÓØ 1Æ)
]);
scaled_sum_rule (map (Combinators.I ** asm_rule) [
	(@@"2",		¨a + b = ÓØ 0Æ),
	(minus_one,	¨ÓØ 2*a = ÓØ 1Æ),
	(minus_one,	¨ÓØ 2*b = ÓØ 1Æ)
]);
scaled_sum_rule (map (Combinators.I ** asm_rule) [
	(@@"2",		¨~a + ~b = ÓØ 0Æ),
	(one,	¨ÓØ 2*a < ~(ÓØ 1)Æ),
	(one,	¨ÓØ 2*b < ÓØ 1Æ)
]);
=TEX
\subsection{Creating the input for the decision procedure}
We need to be able to compute least common multiples to produce a good
reduction of a normal form with rational coefficients into one with integer
coefficients:
=SML
fun €list_lcm› ([i] : INTEGER list) : INTEGER = i
|   list_lcm (i :: more) = (
	let	val recur = list_lcm more;
		val g = gcd i recur;
	in	(i idiv g) @* recur
	end
) | list_lcm [] = one;
=TEX
The following splits a rational literal into a (signed) numerator and a denominator. 
=SML
fun €dest_coefficient› (tm : TERM) : INTEGER * INTEGER = (
	let	val (tm1, neg) = (dest_Ø_minus tm, true)
			handle Fail _ => (tm, false);
		val (numer, denom) = (dest_Ó (dest_ÓØ tm1), one)
			handle Fail _ => (dest_Ó ** dest_Ó)(dest_Ø_frac tm1);
	in	if	not (denom = zero)
		then	(if neg then @~ numer else numer, denom)
		else	term_fail "dest_coefficient" 116307 [tm]
	end
);
=IGN
dest_coefficient¨ÓØ 0Æ;
dest_coefficient¨ÓØ 1Æ;
dest_coefficient¨ÓØ 10000Æ;
dest_coefficient¨~(ÓØ 0)Æ;
dest_coefficient¨~(ÓØ 1)Æ;
dest_coefficient¨~(ÓØ 10000)Æ;
dest_coefficient¨0/1Æ;
dest_coefficient¨1/1Æ;
dest_coefficient¨1/3Æ;
dest_coefficient¨1001/3Æ;
dest_coefficient¨~(0/1)Æ;
dest_coefficient¨~(1/1)Æ;
dest_coefficient¨~(1/3)Æ;
dest_coefficient¨~(1001/3)Æ;

Ø_anf_conv¨a * ~b * ÓØ 4 * (2/3)Æ;
Ø_anf_conv¨(a:Ø) * ~bÆ;

=TEX
The following gets the coefficient from a monomial:
=SML
val €minus_one› = @@"-1";
fun €get_coefficient› (tm : TERM) : (INTEGER * INTEGER) = (
	let	val (x, _) = (dest_Ø_times tm);
	in	(dest_coefficient x)
		handle Fail _ => (dest_Ø_minus x; (minus_one, one))
	end	handle Fail _ => (one, one)
);
=IGN
get_coefficient¨ÓØ 0 * a * bÆ;
get_coefficient¨ÓØ 1 * a * bÆ;
get_coefficient¨ÓØ 100 * a * bÆ;
get_coefficient¨(3/4) * a * bÆ;
get_coefficient¨~(ÓØ 0) * a * bÆ;
get_coefficient¨~(ÓØ 1) * a * bÆ;
get_coefficient¨~(ÓØ 100) * a * bÆ;
get_coefficient¨~(3/4) * a * bÆ;
get_coefficient¨~a * b:ØÆ;
get_coefficient¨a * b:ØÆ;
=TEX
The following function breaks up a sum of 1 or more terms:
=SML
fun €strip_Ø_plus› (tm : TERM) : TERM list = (
	((op :: o (Combinators.I ** strip_Ø_plus) o dest_Ø_plus) tm)
	handle Fail _ => [tm]
);
=IGN
strip_Ø_plus¨x:ØÆ;
strip_Ø_plus¨x:Ø + y + ÓØ 42 * v + qÆ;
strip_Ø_plus¨x:Ø + y + ÓØ 42 * v + q + 157/59 + ~(43/5)*zÆ;
=TEX
The following rule takes a theorem of
one of the forms: $t = c$, $t < c$ or $ t \le c$ where $t$ is in ANF and $c$ is a
rational literal,
and scales it so that all coefficients are integers.
=SML 
fun €to_˙_rule› (thm : THM) : THM = (
	let	val tm = concl thm;
		val (t, c) = dest_eq tm
			handle Fail _ => dest_Ø_º tm
			handle Fail _ => dest_Ø_less tm;
		val (_, c_denom) = dest_coefficient c;
		val t_denoms = map (snd o get_coefficient) (strip_Ø_plus t);
		val factor = list_lcm (c_denom::t_denoms);
	in	if	factor <> one
		then	lit_scale_rule factor thm
		else	thm
	end
);
=IGN
val th6 = asm_rule¨(1001/4)*b  + (1/13)*a º ~(6/7)Æ;
val th7 = asm_rule¨~(1001/4)*b  + (1/13)*a º ~(6/7)Æ;
val th8 = asm_rule¨~(1001/4)*b  + (1/13)*a = ~(6/7)Æ;
val th9 = asm_rule¨~(1001/4)*b  + (1/13)*a < ~(6/7)Æ;
to_˙_rule th1;
to_˙_rule th2;
to_˙_rule th3;
to_˙_rule th4;
to_˙_rule th5;
to_˙_rule th6;
to_˙_rule th7;
to_˙_rule th8;
to_˙_rule th9;
=TEX
We now need to build a mapping of variable numbers to monomials as
needed to construct polynomials as used in the linear arithmetic decision
procedure. Some utilities come first:
=TEX
=SML
type €VAR_MAP› = {next : int, table : (int * TERM) list};
=TEX
=SML
fun €term_rassoc›
	((i, t) :: more : ('a * TERM) list)
	(tm : TERM) : 'a = (
	if t ~=$ tm then i else term_rassoc more tm
) | €term_rassoc› [] _ = (
	fail "term_rassoc" 9090 []
);
=TEX
=SML
fun €establish› (tm : TERM) (vm as {next, table}: VAR_MAP) : (int * VAR_MAP) = (
	(term_rassoc table tm, vm)
	handle Fail _ =>
	(next, {next = next + 1, table = (next, tm) :: table})	
);
=TEX
=IGN
val vm0 : VAR_MAP = {next = 1, table = []};
val (i1, vm1) = establish ¨a*b:ØÆ vm0;
val (i2, vm2) = establish ¨a*c:ØÆ vm1;
val (i3, vm3) = establish ¨a*b:ØÆ vm2;
=TEX
The following breaks out an integer coefficient and a monomial from a summand on
the left-hand side of an equality or inequality:
=SML
fun €dest_monomial› (tm : TERM) : (INTEGER * TERM) = (
	let	val (x, y) = (dest_Ø_times tm);
	in	(dest_Ó(dest_ÓØ x), y)
		handle Fail _ =>
		let	val x' = dest_Ø_minus x;
		in	(@~(dest_Ó(dest_ÓØ x')), y)
			handle Fail _ => (minus_one, mk_Ø_times(x', y))
		end
	end	handle Fail _ => 
		let	val tm' = dest_Ø_minus tm;
		in	(minus_one, tm')
		end
	handle Fail _ => (one, tm)
);
=IGN
dest_monomial¨ÓØ 0 * a * bÆ;
dest_monomial¨ÓØ 1 * a * bÆ;
dest_monomial¨ÓØ 100 * a * bÆ;
dest_monomial¨~(ÓØ 0) * a * bÆ;
dest_monomial¨~(ÓØ 1) * a * bÆ;
dest_monomial¨~(ÓØ 100) * a * bÆ;
dest_monomial¨~a * b:ØÆ;
dest_monomial¨a * b:ØÆ;
dest_monomial¨~b:ØÆ;
dest_monomial¨b:ØÆ;
=TEX
Given a partial mapping of variable numbers to HOL terms and
a term comprising a sum of scaled monomials, the following
function computes the corresponding polynomial for $lin\_arith\_contr$
together with an updated mapping (for feeding into later sums).
=SML
fun €make_poly› (vm : VAR_MAP) (tm : TERM) : VAR_MAP * POLY = (
	let	val summands = map dest_monomial (strip_Ø_plus tm);
		fun aux res [] = res
		|   aux (vm, p) ((c, t)::more) = (
			let	val (i, vm') = establish t vm;
			in	aux (vm', (c, i)::p) more
			end
		);
	in	aux (vm, []) summands
	end
);
=IGN
val vm = vm0;
val tm10 = ¨x*y + ÓØ 1*a + ~(ÓØ 3)*bÆ;
val tm11 = ¨ÓØ 9 * x*y + ÓØ 6*a + ~(ÓØ 7)*bÆ;
val (vm1, p) = make_poly vm tm10;
val (vm2, p) = make_poly vm1 tm11;
=TEX
The following function makes a constraint for $lin\_arith\_contr$, 
from a term and an index value.
A dummy constraint is produced if the term is not
in the appropriate form.

=SML
fun €make_constraint› (vm : VAR_MAP) (ind : int) (tm : TERM) : VAR_MAP * CONSTRAINT = (
	let	val ((rel, lhs), rhs) =
			((dest_app ** Combinators.I) o dest_app)tm;
		val tipe = (
			case fst(dest_const rel) of
				"=" => Eq
			|	"ºâR" => LessEq
			|	"<âR" => Less
			|	_ => fail "make_constraint" 0 []
		);
		val (vm', p) = make_poly vm lhs;
		val (r, _) = dest_coefficient rhs;
	in	(vm', (p, tipe,  r, [(one, ind)]))
	end	handle Fail _ =>
		(vm, ([], Eq, zero, []))
);
=TEX
The following function makes the constraints for $lin\_arith\_contr$, 
from a list of terms. The labels on the polynomials are the indices
into the list starting from 0 (i.e., in the sense of {\tt nth}).
=SML
fun €make_constraints› (tms : TERM list) : CONSTRAINT list = (
	let	val acc0 : int * VAR_MAP * CONSTRAINT list = (0, {next = 1, table = []}, []);
		fun aux (_, _, res) [] = res
		|   aux (i, vm, cs) (tm::more) = (
			let	val (vm', c) = make_constraint vm i tm;
			in	aux (i+1, vm', c::cs) more
			end
		);
	in	aux acc0 tms
	end
);
=IGN
make_constraints [
	¨a + b º ÓØ 0Æ,
	¨~(ÓØ 4)*a º ÓØ 99Æ,
	¨~b  + (ÓØ 52)*a = ~(ÓØ 1)Æ
];
=TEX
\subsection{Putting the results together}
=SML
fun €make_actual_thm› (p : POLY) (thl : THM list) : THM = (
	let	fun aux acc [] = acc
		|   aux acc ((c, ind)::more) = aux ((c, nth ind thl)::acc) more;
		val aths = aux [] p;
	in	scaled_sum_rule aths
	end
);
=TEX
\subsection{The Linear Arithmetic Rule}
The following auxiliary function may raise various exceptions that
its caller must catch:
=SML
fun €Ø_lin_arith_rule_aux› (thl : THM list) : THM = (
	let	val tml = map concl thl;
		val constraints = make_constraints tml drop
			(fn ([], _, _, _) => true | _ => false);
		val p =	(lin_arith_contr constraints);
	in	make_actual_thm p thl
	end
);
=IGN
val tms1 = [
	¨a º ÓØ 0Æ,
	¨~a º ~(ÓØ 1)Æ,
	¨TÆ
];
Ø_lin_arith_rule_aux (map asm_rule tms1);
val tms2 = [
	¨a + b = ÓØ 0Æ,
	¨ÓØ 2*a = ÓØ 1Æ,
	¨ÓØ 2*b = ÓØ 1Æ
];
Ø_lin_arith_rule_aux (map asm_rule tms2);
=TEX
=SML
fun €Ø_lin_arith_rule› (tml : TERM list) : THM = (
	let	val thl = map asm_rule tml;
		fun aux acc [] = acc
		|   aux acc (th :: more) = (
			aux (to_˙_rule th::acc) more
			handle Fail _ => aux acc more
		);
	in	Ø_lin_arith_rule_aux (aux [] thl)
	end	handle Fail _ => fail "Ø_lin_arith_rule" 116341 []
);
=IGN
=IGN
val tms3 = [
	¨a º ÓØ 0Æ,
	¨~b º ~(ÓØ 1)Æ,
	¨TÆ,
	¨~a + b º ~(ÓØ 2)Æ,
	¨TÆ
];
val tms4 = [
	¨(1/2)*a º ÓØ 0Æ,
	¨~(4/5)*a º ~(5/6)Æ,
	¨TÆ
];
val tms5 = [
	¨(1/2)*a = ÓØ 1Æ,
	¨~(2/5)*b º ~(7/6)Æ,
	¨~a + b º (1/100)Æ,
	¨TÆ
];
val tms6 = [¨a º 1 / 2Æ,¨~ a º ~ (3 / 4)Æ,¨TÆ];
val tms7 = [
	¨a + ~b º ~(ÓØ 1)Æ,
	¨(1/2)*b + ~ (1/2)*c º ÓØ 0Æ,
	¨(7/6)*c + ~ (7/6)*d º ÓØ 0Æ,
	¨d + ~ a º ÓØ 0Æ,
	¨TÆ
];
val tms7 = [
	¨a + ~b < ~(ÓØ 1)Æ,
	¨(1/2)*b + ~ (1/2)*c º ÓØ 0Æ,
	¨(7/6)*c + ~ (7/6)*d º ÓØ 0Æ,
	¨d + ~ a º ÓØ 0Æ,
	¨TÆ
];
val tms8 = [
	¨a + ~b < ~(ÓØ 1)Æ,
	¨(1/2)*b + ~ (1/2)*c º ÓØ 0Æ,
	¨(7/6)*c + ~ (7/6)*d = ÓØ 0Æ,
	¨(ÓØ 99)*d + ~ (ÓØ 99)*e < ÓØ 0Æ,
	¨e + ~ a = ÓØ 0Æ,
	¨TÆ
];
val tms9 = [
	¨~ a * a º ÓØ 0Æ,
	¨~ b * b º ÓØ 0Æ,
	¨a * a + b * b < ÓØ 0Æ,
	¨TÆ
];
Ø_lin_arith_rule tms1;
Ø_lin_arith_rule tms2;
Ø_lin_arith_rule tms3;
Ø_lin_arith_rule tms4;
Ø_lin_arith_rule tms5;
Ø_lin_arith_rule tms6;
Ø_lin_arith_rule tms7;
Ø_lin_arith_rule tms8;
Ø_lin_arith_rule tms9;
=TEX
=SML
val €Ø_lin_arith_tac› : TACTIC = (fn gl =>
	(GET_ASMS_T (f_thm_tac o Ø_lin_arith_rule o map concl) gl)
	handle ex => reraise ex "Ø_lin_arith_tac"
);
=TEX
Now the tactic which is the automatic proof tactic.
(Note error message number 82200 is generic enough for us to use here).
=SML
val €Ø_lin_arith_prove_tac› : THM list -> TACTIC = (fn thl => fn gl =>
	((	DROP_ASMS_T (MAP_EVERY strip_asm_tac)
	THEN	MAP_EVERY  strip_asm_tac thl
	THEN	contr_tac
	THEN	Ø_lin_arith_tac) gl)
	handle	Fail msg => fail "Ø_lin_arith_prove_tac" 82200
			[(fn () =>get_message msg),
			 (fn () => string_of_term (snd gl))]
);
=TEX
and the associated conversion:
=SML
val €Ø_lin_arith_prove_conv› : THM list -> CONV = (fn thl => fn tm =>
	let	val th = tac_proof(([], tm), Ø_lin_arith_prove_tac thl);
	in	§_t_intro  th
	end	handle ex => reraise ex "Ø_lin_arith_prove_conv"
);
=IGN

=TEX
\section{OTHER RULES}
=TEX
=SML
val €Ø_eq_cancel_conv_lemma› = (
set_goal([], ¨µc x:Ø∑ c + x = ÓØ 0 § x = ~cÆ);
a(REPEAT µ_tac);
a(conv_tac (RIGHT_C (once_rewrite_conv[Ø_eq_thm])));
a(asm_rewrite_tac[Ø_minus_clauses, µ_elim¨xÆØ_plus_order_thm]);
pop_thm()
);
=TEX
=SML
fun €check_lhs› (dest : TERM -> TERM * TERM) (tm : TERM) = (
	let	val c = fst(dest_Ø_plus(fst(dest tm)));
	in	(dest_coefficient c; true) handle Fail _ =>  false
	end	handle Fail _ => false
);
val €Ø_eq_cancel_conv_aux› = (
	simple_eq_match_conv Ø_eq_thm THEN_TRY_C
	LEFT_C Ø_anf_conv THEN_C
	COND_C	(check_lhs dest_eq)
		(simple_eq_match_conv Ø_eq_cancel_conv_lemma THEN_TRY_C RIGHT_C Ø_anf_conv)
		id_conv	
);
val €Ø_eq_cancel_conv› = (fn tm =>
	CHANGED_C Ø_eq_cancel_conv_aux tm
	handle Fail _ => term_fail "Ø_eq_cancel_conv" 116520 [tm]
);
=IGN
Ø_eq_cancel_conv¨x + 1/2 = yÆ;
Ø_eq_cancel_conv¨1/2 = yÆ;
Ø_eq_cancel_conv¨1/2 = 1/2Æ;
Ø_eq_cancel_conv¨1/2 = ÓØ 0Æ;
Ø_eq_cancel_conv¨ÓØ 0 = ÓØ 0Æ;
=TEX
=SML
val €Ø_º_cancel_conv_lemma› = (
set_goal([], ¨µc x:Ø∑ c + x º ÓØ 0 § x º ~cÆ);
a(REPEAT µ_tac);
a(conv_tac (RIGHT_C (once_rewrite_conv[Ø_º_º_0_thm])));
a(asm_rewrite_tac[Ø_minus_clauses, µ_elim¨xÆØ_plus_order_thm]);
pop_thm()
);
=TEX
=SML
val €Ø_º_cancel_conv_aux› = (
	simple_eq_match_conv Ø_º_º_0_thm THEN_TRY_C
	LEFT_C Ø_anf_conv THEN_C
	COND_C	(check_lhs dest_Ø_º)
		(simple_eq_match_conv Ø_º_cancel_conv_lemma THEN_TRY_C RIGHT_C Ø_anf_conv)
		id_conv	
);
val €Ø_º_cancel_conv› = (fn tm =>
	CHANGED_C Ø_º_cancel_conv_aux tm
	handle Fail _ => term_fail "Ø_º_cancel_conv" 116521 [tm]
);
=IGN
Ø_º_cancel_conv¨x + 1/2 º yÆ;
Ø_º_cancel_conv¨1/2 º yÆ;
Ø_º_cancel_conv¨1/2 º 1/2Æ;
Ø_º_cancel_conv¨1/2 º ÓØ 0Æ;
Ø_º_cancel_conv¨ÓØ 0 º ÓØ 0Æ;
=TEX
=SML
val €Ø_less_cancel_conv_lemma› = (
set_goal([], ¨µc x:Ø∑ c + x < ÓØ 0 § x < ~cÆ);
a(REPEAT µ_tac);
a(conv_tac (RIGHT_C (once_rewrite_conv[Ø_less_less_0_thm])));
a(asm_rewrite_tac[Ø_minus_clauses, µ_elim¨xÆØ_plus_order_thm]);
pop_thm()
);
=TEX
=SML
val €Ø_less_cancel_conv_aux› = (
	simple_eq_match_conv Ø_less_less_0_thm THEN_TRY_C
	LEFT_C Ø_anf_conv THEN_C
	COND_C	(check_lhs dest_Ø_less)
		(simple_eq_match_conv Ø_less_cancel_conv_lemma THEN_TRY_C RIGHT_C Ø_anf_conv)
		id_conv	
);
val €Ø_less_cancel_conv› = (fn tm =>
	CHANGED_C Ø_less_cancel_conv_aux tm
	handle Fail _ => term_fail "Ø_less_cancel_conv" 116522 [tm]
);
=IGN
Ø_less_cancel_conv¨x + 1/2 < yÆ;
Ø_less_cancel_conv¨1/2 < yÆ;
Ø_less_cancel_conv¨1/2 < 1/2Æ;
Ø_less_cancel_conv¨1/2 < ÓØ 0Æ;
Ø_less_cancel_conv¨ÓØ 0 < ÓØ 0Æ;
=TEX
\ubsection{Linear Arithmetic Proof Context}
The equational contexts required are the same for stripping goals and stripping
theorems. We take numeric $=$, $<$ and $º$ as the atomic
predicates which we will deal with. The possibilities are:
{\em(i)} put the a ground atomic predicate into normal form with the appropriate canncellation conversion;
{\em(ii)} convert a negated atomic predicate into an atomic one;
{\em(iii)} convert a predicate formed with $<$, $æ$ or $>$ into an atomic one;
{\em(iv)} convert the negation of a predicate formed with $<$, $æ$ or $>$ into an atomic one;
and
{\em(v)} attempt to evaluate ground inequalities.
=SML
val €Ø_≥_eq_thm› = (
set_goal([], ¨µx y:Ø∑ ≥x = y § x < y ≤ y < xÆ);
a(REPEAT µ_tac);
a(rewrite_tac[Ø_eq_º_thm, taut_rule¨µp q∑≥(p ± q) § ≥p ≤ ≥ qÆ, Ø_≥_º_less_thm]);
a(REPEAT strip_tac);
pop_thm()
);
=TEX
The following is a little bit more leisurely than the natural numbers versions;
it does the conversion into atomic predicates in easy stages.
=SML
val strip_cxt = [

	(¨(x:Ø) = yÆ, Ø_eq_conv),
	(¨(x:Ø) º yÆ, Ø_º_conv),
	(¨(x:Ø) < yÆ, Ø_less_conv),

	(¨≥(x:Ø) = yÆ, simple_eq_match_conv Ø_≥_eq_thm),
	(¨≥(x:Ø) º yÆ, simple_eq_match_conv Ø_≥_º_less_thm),
	(¨≥(x:Ø) < yÆ, simple_eq_match_conv Ø_≥_less_º_thm),

	(¨(x:Ø) æ yÆ, Ø_æ_conv),
	(¨(x:Ø) > yÆ, Ø_greater_conv),
	(¨≥ (x:Ø) æ yÆ, RAND_C Ø_æ_conv),
	(¨≥ (x:Ø) > yÆ, RAND_C Ø_greater_conv),

	(¨(x:Ø) = yÆ, Ø_eq_cancel_conv),
	(¨(x:Ø) º yÆ, Ø_º_cancel_conv),
	(¨(x:Ø) < yÆ, Ø_less_cancel_conv)
];
=IGN
map (fn (t, c) => TRY_C c t) strip_cxt;
=TEX
=SML
val _ = delete_pc "'Ø_lin_arith" handle Fail _ => ();
val _ = new_pc €"'Ø_lin_arith"›;
val _ = set_rw_eqn_cxt strip_cxt "'Ø_lin_arith";
val _ = set_st_eqn_cxt strip_cxt "'Ø_lin_arith";
val _ = set_sc_eqn_cxt strip_cxt "'Ø_lin_arith";
val _ = set_pr_tac Ø_lin_arith_prove_tac "'Ø_lin_arith";
val _ = set_pr_conv Ø_lin_arith_prove_conv "'Ø_lin_arith";
val _ = commit_pc "'Ø_lin_arith";
=TEX
=SML
val _ = delete_pc "Ø_lin_arith" handle Fail _ => ();
val _ = new_pc €"Ø_lin_arith"›;
val _ = merge_pcs ["predicates","'Ø_lin_arith"] "Ø_lin_arith";
val _ = commit_pc "Ø_lin_arith";
=TEX
=IGN
map (PC_C1 "Ø_lin_arith" rewrite_conv[]) [
	¨ÓØ 1 = ÓØ 2Æ, ¨ÓØ 3 º ÓØ 2Æ, ¨ÓØ 2 = ÓØ 2Æ, ¨ÓØ 1 º ÓØ 2Æ
,	¨a + b = b + a + ÓØ 1Æ, ¨a + ÓØ 20 + b = (a+ ÓØ 10)+(b+ ÓØ 10)Æ
,	¨a + b º b + a - ÓØ 1Æ, ¨a + ÓØ 20 + b º (a+ ÓØ 14)+(b+ ÓØ 10)Æ
,	¨≥ÓØ 10 = ÓØ 20Æ, ¨≥(a:Ø) + b = b + aÆ
,	¨≥ÓØ 10 º ÓØ 20Æ, ¨≥(a:Ø) + b º b + aÆ
,	¨ÓØ 10 < ÓØ 20Æ, ¨(a:Ø) + b æ b + aÆ, ¨(a:Ø) + b > b + aÆ
,	¨≥ÓØ 10 < ÓØ 20Æ, ¨≥(a:Ø) + b æ b + aÆ, ¨≥(a:Ø) + b > b + aÆ
,	¨(a:Ø +b)*(a-b) = a*a - b*bÆ, ¨(a:Ø +b)*(a-b) = a*a - b*b Æ
,	¨≥10/1001 < 9/900Æ, ¨≥(3/4)*(a + b) æ b + aÆ, ¨≥(a:Ø) + b > 1/2 + aÆ
]; 
map (PC_C1 "Ø_lin_arith" prove_rule[]) [
	¨a*a æ ÓØ 0 ± b*b æ ÓØ 0 ¥ (a+b)*(a+b) æ ÓØ 2 * a * bÆ
];
map (PC_C1 "Ø_lin_arith" prove_rule[]) [
	¨a*a æ ÓØ 0 ± b*b æ ÓØ 0 ¥ (1/2)*(a+b)*(a+b) æ a * bÆ
];
=TEX
=TEX
\section{EPILOGUE}
=TEX
=SML
val _ = (pop_pc(); pop_pc());
end (* of structure Ø *);
open Ø;

=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}







