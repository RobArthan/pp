=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Implementation for the Rewriting Rules of Inference}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Rewriting Rules of Inference}
\TPPref{DS/FMU/IED/IMP026}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{K.~Blackburn & WIN01\\D.J.~King & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Good version.
\item [Issue 1.3]
Changed $?\_TRAVERSE\_C$ to $?\_MAP\_C$.
Failure 26001 added to appropriate functions.
\item [Issue 1.6]
Addition of tactics.
\item [Issue 1.7]
Addition and canons and basic rewrites.
\item [Issue 1.8]
Fixes to canons and basic rewrites.
\item [Issue 1.9]
Added initialisation of rewrite convs.
\item [Issue 1.10]
Added theorem tactic formulations of rewriting.
\item [Issue 1.11]
Various minor mods as a result of testing canons.
\item [Issue 1.12]
Renamings of functions containing the name atom $simple$,
and renaming of $aconv$.
\item [Issue 1.13]
All rewrite functions now fail when applying an equation produces no change.
\item [Issue 1.14]
Re-implementation to follow ideas of \cite{DS/FMU/IED/DTD051}.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the rewriting rules of inference.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the rewriting rules of inference.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD026},
and also requires those files indicated as preceding it in the 
rel001 makefile.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}
\section{START OF THE SIGNATURE}
=SML
structure Rewriting : Rewriting = struct
=TEX
\section{CANONICALISATION FUNCTIONS}
=TEX
=SML
type ‚CANON· = THM -> (THM list);
=TEX
=SML
val ‚id_canon· : CANON = (fn thm => [thm]);
=TEX
=SML
val ‚fail_canon· : CANON = (fn _ => fail "fail_canon" 26201 []);
=TEX
=SML
fun ‚fail_with_canon· 	(area : string) (msg : int)
	(inserters : (unit -> string) list) : CANON = (fn thm =>
	fail area msg inserters
);
=TEX
=SML
fun (lr1 : CANON) ‚THEN_CAN· (lr2 : CANON) : CANON = (
	flat o (map lr2 o lr1)
);
=TEX
=SML
fun (lr1 : CANON) ‚ORELSE_CAN· (lr2 : CANON) : CANON = (fn thm =>
	(lr1 thm) handle Fail _ => lr2 thm
);
=TEX
=SML
fun (lr1 : CANON) ‚THEN_LIST_CAN· (lrs : CANON list) : CANON = (fn thm =>
	let	fun aux (thm :: morethms) (lr :: morelrs) = (
			lr thm @ aux morethms morelrs
		) | aux [] [] = ([]
		) | aux _ _ = fail "THEN_LIST_CAN" 26204 [];
	in	aux (lr1 thm) lrs
	end	
);
=TEX
=SML
fun ‚EVERY_CAN· (lrs : CANON list) : CANON = fold (op THEN_CAN) lrs id_canon;
=TEX
=SML
fun ‚FIRST_CAN· (lrs : CANON list) = fold (op ORELSE_CAN) lrs (fail_with_canon "FIRST_CAN" 26202 []);
=TEX
=SML
fun ‚REPEAT_CAN· (lr : CANON) : CANON = (fn thm =>
	((lr THEN_CAN REPEAT_CAN lr) ORELSE_CAN id_canon) thm
);
=TEX
=SML
fun ‚Ä_rewrite_canon· (thm : THM) : THM list = (
	[Ä_left_elim thm, Ä_right_elim thm]
);
=TEX
=SML
fun ‚simple_å_rewrite_canon· (thm : THM) : THM list = (
	[conv_rule (FIRST_C[
		simple_eq_match_conv å_Å_thm,
		simple_å_Ñ_conv,
		simple_eq_match_conv å_1_thm])thm]
);
=TEX
=SML
fun ‚Ç_t_rewrite_canon· (thm : THM) : THM list = (
	if is_eq (concl thm)
	then fail "Ç_t_rewrite_canon" 26203 []
	else [Ç_t_intro thm]
);
=TEX
=SML
fun ‚simple_É_rewrite_canon· (thm : THM) : THM list = (
	if is_É (concl thm)
	then [all_simple_É_elim thm]
	else fail_canon thm
);
=TEX
=SML
fun ‚thm_%alpha%_eq· (thm1: THM) (thm2: THM) : bool = (
	let	val (asms1, conc1) = dest_thm thm1;
		val (asms2, conc2) = dest_thm thm2;
	in	%alpha%_eq conc1 conc2
		andalso all asms1 (switch(present (uncurry %alpha%_eq)) asms2)
		andalso all asms2 (switch(present (uncurry %alpha%_eq)) asms1)
	end
);
=TEX
=TEX
=SML
fun ‚thm_frees· (thm: THM) : TERM list = (
	let	val (asms, conc) = dest_thm thm;
	in	(frees conc) cup (list_cup (map frees asms))
	end
);
=TEX
=SML
fun ‚rewrite_gen_canon· (fvs : TERM list) (thm : THM) : THM list = (
let	val (asms, conc) = dest_thm thm;
	val avoid = list_cup(fvs :: map frees asms);
in
	[list_simple_É_intro ((frees conc) drop (fn v => (v mem avoid))) thm]
end);
=TEX
=SML
fun ‚REWRITE_CAN· (can : CANON) : CANON = (fn (thm : THM) =>
	(can 
	THEN_CAN rewrite_gen_canon (thm_frees thm)) thm
);
=TEX
=SML
val ‚initial_rw_canon· : CANON=
	REWRITE_CAN
	(REPEAT_CAN(FIRST_CAN [
	simple_É_rewrite_canon,
	Ä_rewrite_canon,
	simple_å_rewrite_canon,
	Ç_t_rewrite_canon]));
=TEX
\section{THE REWRITING RULES OF INFERENCE}
\subsection{Utilities}
=SML
val ‚thm_union· = union (fn (thm1,thm2) => (dest_thm thm1 = dest_thm thm2));

fun ‚filter· (fil : 'a -> bool) ((x :: rest) : 'a list) = (
	if fil x
	then x :: filter fil rest
	else filter fil rest
) | filter _ [] = [];
=TEX
For equational contexts:
=SML
fun ‚cthm_for_eqn_cxt· (canon: CANON) (thm:THM) : EQN_CXT = (
	mapfilter thm_for_eqn_cxt (canon thm)
);
=TEX
\subsection{prim\_rewrite\_conv}
The core function:
=SML
local
	fun FIRST_CHANGED_C (cv :: rest) tm =
		(CHANGED_C cv ORELSE_C FIRST_CHANGED_C rest) tm
	| FIRST_CHANGED_C [] tm = term_fail "eqn_cxt_conv" 28141 [tm];

	fun net_lookup_conv net : CONV = (fn (tm : TERM) =>
		FIRST_CHANGED_C(net_lookup net tm)tm
	);
in
fun ‚prim_rewrite_conv· (initial_net : CONV NET) :
	CANON -> 
	(CONV -> CONV) -> 
	EQN_CXT -> 
	THM list -> TERM -> THM = (
(fn (canon : CANON) =>
(fn (traverse : CONV -> CONV) =>
(fn (with_eqn_cxt : EQN_CXT) =>
let	val initial_with_eqn_cxt = list_net_enter 
		with_eqn_cxt initial_net
in
(fn (with_thms : THM list) =>
let	val with_entries = flat (map (cthm_for_eqn_cxt canon)
		with_thms);
	val initial_with_thms = list_net_enter 
		with_entries initial_with_eqn_cxt;
in
(fn (tm : TERM) =>
let
	val s1 = traverse (net_lookup_conv initial_with_thms) tm
in
	(prof "prim_rewrite_conv";
	s1)
end)
end)
end)
)
)
);
end; (* local fun FIRST_CHANGED_C ... *)
=TEX
=SML
fun ‚prim_rewrite_rule· (initial_net : CONV NET) :
	CANON -> 
	(CONV -> CONV) -> 
	EQN_CXT -> 
	THM list -> THM -> THM = (
let	val c1 = prim_rewrite_conv initial_net;
in
(fn (canon : CANON) =>
let	val c2 = c1 canon;
in
(fn (traverse : CONV -> CONV) =>
let	val c3 = c2 traverse;
in
(fn (with_eqn_cxt : EQN_CXT) =>
let	val c4 = c3 with_eqn_cxt;
in
(fn (with_thms : THM list) =>
let	val c5 = c4 with_thms;
in
(fn (thm : THM) =>
	(prof "prim_rewrite_rule";
	conv_rule c5 thm)
)
end)
end)
end)
end)
end);
=TEX
=SML
fun ‚prim_rewrite_tac· (initial_net : CONV NET) :
	CANON -> 
	(CONV -> CONV) -> 
	EQN_CXT -> 
	THM list -> TACTIC = (
let	val c1 = prim_rewrite_conv initial_net;
in
(fn (canon : CANON) =>
let	val c2 = c1 canon;
in
(fn (traverse : CONV -> CONV) =>
let	val c3 = c2 traverse;
in
(fn (with_eqn_cxt : EQN_CXT) =>
let	val c4 = c3 with_eqn_cxt;
in
(fn (with_thms : THM list) =>
let	val c5 = c4 with_thms;
in
(fn (gl : GOAL) =>
	(prof "prim_rewrite_tac";
	conv_tac c5 gl)
)
end)
end)
end)
end)
end);
=TEX
Now the actual inferences.
Rules first:
=SML
fun ‚rewrite_rule· (thms : THM list) : THM -> THM = (
let	val {rw_canon = rw_canon, rw_net = rw_net,...} =
		get_proof_context();
	val r1 = prim_rewrite_rule rw_net rw_canon TOP_MAP_C [] thms;
in
	(fn (thm : THM) => r1 thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "rewrite_rule" 26001 [])
end);

fun ‚pure_rewrite_rule· (thms : THM list) : THM -> THM = (
let	val {rw_canon = rw_canon,...} =
		get_proof_context();
	val r1 = prim_rewrite_rule empty_net rw_canon TOP_MAP_C [] thms;
in
	(fn (thm : THM) => r1 thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_rewrite_rule" 26001 [])
end);

fun ‚once_rewrite_rule· (thms : THM list) : THM -> THM = (
let	val {rw_canon = rw_canon, rw_net = rw_net,...} =
		get_proof_context();
	val r1 = prim_rewrite_rule rw_net rw_canon ONCE_MAP_C [] thms;
in
	(fn (thm : THM) => r1 thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_rewrite_rule" 26001 [])
end);

fun ‚pure_once_rewrite_rule· (thms : THM list) : THM -> THM = (
let	val {rw_canon = rw_canon,...} =
		get_proof_context();
	val r1 = prim_rewrite_rule empty_net rw_canon ONCE_MAP_C [] thms;
in
	(fn (thm : THM) => r1 thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_rewrite_rule" 26001 [])
end);
=TEX
Now with assumptions:
=SML
fun ‚asm_rewrite_rule· (thms : THM list) : THM -> THM = (
let	val {rw_canon = rw_canon, rw_net = rw_net,...} =
		get_proof_context();
	val r1 = prim_rewrite_rule rw_net rw_canon TOP_MAP_C
		(flat(map (cthm_for_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (hyps thm)) thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "asm_rewrite_rule" 26001 [])
end);

fun ‚pure_asm_rewrite_rule· (thms : THM list) : THM -> THM = (
let	val {rw_canon = rw_canon, ...} =
		get_proof_context();
	val r1 = prim_rewrite_rule empty_net rw_canon TOP_MAP_C
		(flat(map (cthm_for_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (hyps thm)) thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_asm_rewrite_rule" 26001 [])
end);

fun ‚once_asm_rewrite_rule· (thms : THM list) : THM -> THM = (
let	val {rw_canon = rw_canon, rw_net = rw_net,...} =
		get_proof_context();
	val r1 = prim_rewrite_rule rw_net rw_canon ONCE_MAP_C
		(flat(map (cthm_for_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (hyps thm)) thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_asm_rewrite_rule" 26001 [])
end);

fun ‚pure_once_asm_rewrite_rule· (thms : THM list) : THM -> THM = (
let	val {rw_canon = rw_canon, ...} =
		get_proof_context();
	val r1 = prim_rewrite_rule empty_net rw_canon ONCE_MAP_C
		(flat(map (cthm_for_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (hyps thm)) thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_asm_rewrite_rule" 26001 [])
end);
=TEX

Now we give rules with filtered assumption lists.
=SML
fun ‚fasm_rewrite_rule· (thms : THM list) (fil: TERM -> bool) : THM -> THM = (
let	val {rw_canon = rw_canon, rw_net = rw_net,...} =
		get_proof_context();
	val r1 = prim_rewrite_rule rw_net rw_canon TOP_MAP_C
		(flat(map (cthm_for_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (filter fil (hyps thm))) thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "fasm_rewrite_rule" 26001 [])
end);

fun ‚pure_fasm_rewrite_rule· (thms : THM list) (fil: TERM -> bool) : THM -> THM = (
let	val {rw_canon = rw_canon, ...} =
		get_proof_context();
	val r1 = prim_rewrite_rule empty_net rw_canon TOP_MAP_C
		(flat(map (cthm_for_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (filter fil (hyps thm))) thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_fasm_rewrite_rule" 26001 [])
end);

fun ‚once_fasm_rewrite_rule· (thms : THM list) (fil: TERM -> bool) : THM -> THM = (
let	val {rw_canon = rw_canon, rw_net = rw_net,...} =
		get_proof_context();
	val r1 = prim_rewrite_rule rw_net rw_canon ONCE_MAP_C
		(flat(map (cthm_for_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (filter fil (hyps thm))) thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_fasm_rewrite_rule" 26001 [])
end);

fun ‚pure_once_fasm_rewrite_rule· (thms : THM list) (fil: TERM -> bool) : THM -> THM = (
let	val {rw_canon = rw_canon, ...} =
		get_proof_context();
	val r1 = prim_rewrite_rule empty_net rw_canon ONCE_MAP_C
		(flat(map (cthm_for_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (filter fil (hyps thm))) thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_fasm_rewrite_rule" 26001 [])
end);
=TEX
Conversions:
=SML
fun ‚rewrite_conv· (thms : THM list) : CONV = (
let	val {rw_canon = rw_canon, rw_net = rw_net,...} =
		get_proof_context();
	val r1 = prim_rewrite_conv rw_net rw_canon TOP_MAP_C [] thms;
in
	(fn (tm : TERM) => r1 tm
	handle complaint =>
	divert complaint "TOP_MAP_C" "rewrite_conv" 26001 [])
end);

fun ‚pure_rewrite_conv· (thms : THM list) : CONV = (
let	val {rw_canon = rw_canon,...} =
		get_proof_context();
	val r1 = prim_rewrite_conv empty_net rw_canon TOP_MAP_C [] thms;
in
	(fn (tm : TERM) => r1 tm
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_rewrite_conv" 26001 [])
end);

fun ‚once_rewrite_conv· (thms : THM list) : CONV = (
let	val {rw_canon = rw_canon, rw_net = rw_net,...} =
		get_proof_context();
	val r1 = prim_rewrite_conv rw_net rw_canon ONCE_MAP_C [] thms;
in
	(fn (tm : TERM) => r1 tm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_rewrite_conv" 26001 [])
end);

fun ‚pure_once_rewrite_conv· (thms : THM list) : CONV = (
let	val {rw_canon = rw_canon,...} =
		get_proof_context();
	val r1 = prim_rewrite_conv empty_net rw_canon ONCE_MAP_C [] thms;
in
	(fn (tm : TERM) => r1 tm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_rewrite_conv" 26001 [])
end);
=TEX
Tactics:
=SML
fun ‚rewrite_tac· (thms : THM list) : TACTIC = (
let	val {rw_canon = rw_canon, rw_net = rw_net,...} =
		get_proof_context();
	val r1 = prim_rewrite_tac rw_net rw_canon TOP_MAP_C [] thms;
in
	(fn (gl : GOAL) => r1 gl
	handle complaint =>
	divert complaint "TOP_MAP_C" "rewrite_tac" 26001 [])
end);

fun ‚pure_rewrite_tac· (thms : THM list) : TACTIC = (
let	val {rw_canon = rw_canon,...} =
		get_proof_context();
	val r1 = prim_rewrite_tac empty_net rw_canon TOP_MAP_C [] thms;
in
	(fn (gl : GOAL) => r1 gl
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_rewrite_tac" 26001 [])
end);

fun ‚once_rewrite_tac· (thms : THM list) : TACTIC = (
let	val {rw_canon = rw_canon, rw_net = rw_net,...} =
		get_proof_context();
	val r1 = prim_rewrite_tac rw_net rw_canon ONCE_MAP_C [] thms;
in
	(fn (gl : GOAL) => r1 gl
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_rewrite_tac" 26001 [])
end);

fun ‚pure_once_rewrite_tac· (thms : THM list) : TACTIC = (
let	val {rw_canon = rw_canon,...} =
		get_proof_context();
	val r1 = prim_rewrite_tac empty_net rw_canon ONCE_MAP_C [] thms;
in
	(fn (gl : GOAL) => r1 gl
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_rewrite_tac" 26001 [])
end);
=TEX
Now with assumptions:
=SML
fun ‚asm_rewrite_tac· (thms : THM list) : TACTIC = (
let	val {rw_canon = rw_canon, rw_net = rw_net,...} =
		get_proof_context();
	val r1 = prim_rewrite_tac rw_net rw_canon TOP_MAP_C
		(flat(map (cthm_for_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule asms) (asms,conc)
	handle complaint =>
	divert complaint "TOP_MAP_C" "asm_rewrite_tac" 26001 [])
end);

fun ‚pure_asm_rewrite_tac· (thms : THM list) : TACTIC = (
let	val {rw_canon = rw_canon, ...} =
		get_proof_context();
	val r1 = prim_rewrite_tac empty_net rw_canon TOP_MAP_C
		(flat(map (cthm_for_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule asms) (asms,conc)
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_asm_rewrite_tac" 26001 [])
end);

fun ‚once_asm_rewrite_tac· (thms : THM list) : TACTIC = (
let	val {rw_canon = rw_canon, rw_net = rw_net,...} =
		get_proof_context();
	val r1 = prim_rewrite_tac rw_net rw_canon ONCE_MAP_C
		(flat(map (cthm_for_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule asms) (asms,conc)
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_asm_rewrite_tac" 26001 [])
end);

fun ‚pure_once_asm_rewrite_tac· (thms : THM list) : TACTIC = (
let	val {rw_canon = rw_canon, ...} =
		get_proof_context();
	val r1 = prim_rewrite_tac empty_net rw_canon ONCE_MAP_C
		(flat(map (cthm_for_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule asms) (asms,conc)
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_asm_rewrite_tac" 26001 [])
end);
=TEX

Now we give rules with filtered assumption lists.
=SML
fun ‚fasm_rewrite_tac· (thms : THM list) (fil: TERM -> bool) : TACTIC = (
let	val {rw_canon = rw_canon, rw_net = rw_net,...} =
		get_proof_context();
	val r1 = prim_rewrite_tac rw_net rw_canon TOP_MAP_C
		(flat(map (cthm_for_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule (filter fil asms))(asms,conc)
	handle complaint =>
	divert complaint "TOP_MAP_C" "fasm_rewrite_tac" 26001 [])
end);

fun ‚pure_fasm_rewrite_tac· (thms : THM list) (fil: TERM -> bool) : TACTIC = (
let	val {rw_canon = rw_canon, ...} =
		get_proof_context();
	val r1 = prim_rewrite_tac empty_net rw_canon TOP_MAP_C
		(flat(map (cthm_for_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule (filter fil asms))(asms,conc)
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_fasm_rewrite_tac" 26001 [])
end);

fun ‚once_fasm_rewrite_tac· (thms : THM list) (fil: TERM -> bool) : TACTIC = (
let	val {rw_canon = rw_canon, rw_net = rw_net,...} =
		get_proof_context();
	val r1 = prim_rewrite_tac rw_net rw_canon ONCE_MAP_C
		(flat(map (cthm_for_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule (filter fil asms))(asms,conc)
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_fasm_rewrite_tac" 26001 [])
end);

fun ‚pure_once_fasm_rewrite_tac· (thms : THM list) (fil: TERM -> bool) : TACTIC = (
let	val {rw_canon = rw_canon, ...} =
		get_proof_context();
	val r1 = prim_rewrite_tac empty_net rw_canon ONCE_MAP_C
		(flat(map (cthm_for_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule (filter fil asms))(asms,conc)
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_fasm_rewrite_tac" 26001 [])
end);
=TEX
=SML
fun ‚singleton· (x : 'a) : 'a list = [x];

val ‚rewrite_thm_tac· : THM -> TACTIC =
				rewrite_tac o singleton;
val ‚pure_rewrite_thm_tac· : THM -> TACTIC =
				pure_rewrite_tac o singleton;
val ‚once_rewrite_thm_tac· : THM -> TACTIC =
				once_rewrite_tac o singleton;
val ‚pure_once_rewrite_thm_tac· : THM -> TACTIC =
				pure_once_rewrite_tac  o singleton;
val ‚asm_rewrite_thm_tac· : THM -> TACTIC =
				asm_rewrite_tac o singleton;
val ‚pure_asm_rewrite_thm_tac· : THM -> TACTIC = 
				pure_asm_rewrite_tac o singleton;
val ‚once_asm_rewrite_thm_tac· : THM -> TACTIC =
				once_asm_rewrite_tac o singleton;
val ‚pure_once_asm_rewrite_thm_tac· : THM -> TACTIC = 
				pure_once_asm_rewrite_tac o singleton;
val ‚fasm_rewrite_thm_tac· : (TERM -> bool) -> THM -> TACTIC =
				switch (fasm_rewrite_tac o singleton);
val ‚pure_fasm_rewrite_thm_tac· : (TERM -> bool) -> THM -> TACTIC = 
				switch (pure_fasm_rewrite_tac o singleton);
val ‚once_fasm_rewrite_thm_tac· : (TERM -> bool) -> THM -> TACTIC = 
				switch (once_fasm_rewrite_tac o singleton);
val ‚pure_once_fasm_rewrite_thm_tac· : (TERM -> bool) -> THM -> TACTIC =
				switch (pure_once_fasm_rewrite_tac o singleton);
=TEX
\section{BASIC REWRITE THEOREMS}
=SML
val ‚eq_rewrite_thm· = save_thm("eq_rewrite_thm", tac_proof(([],
		ªÉ xé(x = x) Ç Tº),
	REPEAT strip_tac THEN accept_tac (refl_convªxº)));
val ‚Ç_rewrite_thm· = save_thm("Ç_rewrite_thm", tac_proof(([],
		ªÉ té((T Ç t) = t) Ä ((t Ç T) = t) Ä ((F Ç t) = (å t)) Ä (t Ç F) = (å t)º),
	REPEAT strip_tac));
val ‚å_rewrite_thm· = save_thm("å_rewrite_thm", tac_proof(([],
		ªÉ té(ååt) = t Ä ((å T) = F) Ä (å F) = Tº),
	REPEAT strip_tac));
val ‚Ä_rewrite_thm· = save_thm("Ä_rewrite_thm", tac_proof(([],
		ªÉ té((T Ä t) Ç t) Ä ((t Ä T) Ç t) Ä
		(å (F Ä t)) Ä (å (t Ä F)) Ä (t Ä t) = tº),
	REPEAT strip_tac));
val ‚Å_rewrite_thm· = save_thm("Å_rewrite_thm", tac_proof(([],
		ªÉ té(T Å t) Ä (t Å T) Ä ((F Å t) = t) Ä ((t Å F) = t) Ä (t Å t) = tº),
	REPEAT strip_tac));
val ‚ä_rewrite_thm· = save_thm("ä_rewrite_thm", tac_proof(([],
		ªÉ té((T ä t) = t) Ä ((F ä t) = T) Ä ((t ä T) = T) Ä ((t ä t) = T)
  Ä (t ä F) = (å t)º),
	REPEAT strip_tac));
val ‚if_rewrite_thm· = save_thm("if_rewrite_thm", tac_proof(([],
		ªÉ t1 t2é((if T then t1 else t2) = t1) Ä (if F then t1 else t2) = t2º),
	REPEAT strip_tac THEN conv_tac (eq_sym_conv THEN_C fun_if_conv)
	THEN REPEAT strip_tac THEN_LIST [accept_tac(refl_convªt1º), accept_tac(refl_convªt2º)]));

val ‚É_rewrite_thm· = save_thm("É_rewrite_thm", tac_proof(([],
		ªÉ té(É xét) = tº),
	REPEAT strip_tac THEN POP_ASM_T (accept_tac o all_simple_É_elim)));
val ‚Ñ_rewrite_thm· = save_thm("Ñ_rewrite_thm", tac_proof(([],
		ªÉ té(Ñ xét) = tº),
	REPEAT strip_tac THEN simple_Ñ_tac ªxº THEN goal_in_asms_tac));
val ‚%beta%_rewrite_thm· = save_thm("%beta%_rewrite_thm", tac_proof(([],
		ªÉ t1:'a; t2:'bé((ç xét1)t2) = t1º),
	REPEAT strip_tac THEN accept_tac(simple_%beta%_conv ª(ç x:'bét1:'a)t2º)));
=TEX
\subsection{Rewriting Proof Contexts}
=SML
val ‚initial_rw_eqn_cxt· : EQN_CXT = (flat
	(map (cthm_for_eqn_cxt initial_rw_canon) [
		eq_rewrite_thm,
		Ç_rewrite_thm,
		å_rewrite_thm,
		Ä_rewrite_thm,
		Å_rewrite_thm,
		ä_rewrite_thm,
		if_rewrite_thm,
		É_rewrite_thm,
		Ñ_rewrite_thm,
		%beta%_rewrite_thm])) @
	[ (ª(ç x é y) zº, simple_%beta%_conv) ];

val ‚initial_rewrite_proof_context· : PROOF_CONTEXT = (
let val {sa_eqn_cxt = sa_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,...} = 
	initial_strip_proof_context;
in
	{sa_eqn_cxt = sa_eqn_cxt, 
	sg_eqn_cxt = sg_eqn_cxt,
	rw_canon = initial_rw_canon,
	rw_eqn_cxt = initial_rw_eqn_cxt}
end);

val ‚einitial_rewrite_proof_context·: EPROOF_CONTEXT = (
let val {sa_conv = sa_conv, sg_conv = sg_conv,...} =
	einitial_strip_proof_context;
in
	{sa_conv = sa_conv, 
	sg_conv = sg_conv,
	rw_canon = initial_rw_canon,
	rw_net = make_net initial_rw_eqn_cxt}
end);

val _ = push_proof_context einitial_rewrite_proof_context;
=TEX
\section{EVALUATION OF PROOF CONTEXTS}
=SML
fun ‚evaluate_proof_context· (
		{sa_eqn_cxt = sa_eqn_cxt, 
		sg_eqn_cxt = sg_eqn_cxt,
		rw_canon = rw_canon,
		rw_eqn_cxt = rw_eqn_cxt} : PROOF_CONTEXT) 
	: EPROOF_CONTEXT = (
	{sa_conv = eqn_cxt_conv sa_eqn_cxt, 
	sg_conv = eqn_cxt_conv sg_eqn_cxt,
	rw_canon = rw_canon,
	rw_net = make_net rw_eqn_cxt}
);
=TEX
\section{END OF THE STRUCTURE}
=SML
end; (* of structure Rewriting *)
open Rewriting;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN
