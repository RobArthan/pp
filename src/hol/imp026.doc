=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the Rewriting Rules of Inference}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Rewriting Rules of Inference}
\TPPref{DS/FMU/IED/IMP026}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{K.~Blackburn & WIN01\\D.J.~King & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Good version.
\item [Issue 1.3]
Changed $?\_TRAVERSE\_C$ to $?\_MAP\_C$.
Failure 26001 added to appropriate functions.
\item [Issue 1.6]
Addition of tactics.
\item [Issue 1.7]
Addition and canons and basic rewrites.
\item [Issue 1.8]
Fixes to canons and basic rewrites.
\item [Issue 1.9]
Added initialisation of rewrite convs.
\item [Issue 1.10]
Added theorem tactic formulations of rewriting.
\item [Issue 1.11]
Various minor mods as a result of testing canons.
\item [Issue 1.12]
Renamings of functions containing the name atom $simple$,
and renaming of $aconv$.
\item [Issue 1.13]
All rewrite functions now fail when applying an equation produces no change.
\item [Issue 1.14]
Re-implementation to follow ideas of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.15]
Fixed a bug with $simple\_µ\_rewrite\_canon$.
\item [Issue 1.16]
Reacting to issue 1.5 of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.17,1.18]
Added $cs\_∂\_rule$ material.

\item[Issue \SCCSversion, \FormatDate{92/01/20} ] Updated to use new fonts.

\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the rewriting rules of inference.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the rewriting rules of inference.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD026}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{START OF THE SIGNATURE}
=SML
structure Rewriting : Rewriting = struct
=TEX
=SML
val €was_theory› = get_current_theory_name ();
val _ = open_theory "misc";
=TEX
\section{CANONICALISATION FUNCTIONS}
=SML
type €CANON› = THM -> (THM list);
=TEX
=SML
val €id_canon› : CANON = (fn thm => [thm]);
=TEX
=SML
val €fail_canon› : CANON = (fn _ => fail "fail_canon" 26201 []);
=TEX
=SML
fun €fail_with_canon› 	(area : string) (msg : int)
	(inserters : (unit -> string) list) : CANON = (fn thm =>
	fail area msg inserters
);
=TEX
=SML
fun (lr1 : CANON) €THEN_CAN› (lr2 : CANON) : CANON = (
	flat o (map lr2 o lr1)
);
=TEX
=SML
fun (lr1 : CANON) €ORELSE_CAN› (lr2 : CANON) : CANON = (fn thm =>
	(lr1 thm) handle Fail _ => lr2 thm
);
=TEX
=SML
fun (lr1 : CANON) €THEN_LIST_CAN› (lrs : CANON list) : CANON = (fn thm =>
	let	fun aux (thm :: morethms) (lr :: morelrs) = (
			lr thm @ aux morethms morelrs
		) | aux [] [] = ([]
		) | aux _ _ = fail "THEN_LIST_CAN" 26204 [];
	in	aux (lr1 thm) lrs
	end	
);
=TEX
=SML
fun €EVERY_CAN› (lrs : CANON list) : CANON = fold (op THEN_CAN) lrs id_canon;
=TEX
=SML
fun €FIRST_CAN› (lrs : CANON list) = (
	fold (op ORELSE_CAN) lrs (fail_with_canon "FIRST_CAN" 26202 [])
);
=TEX
=SML
fun €REPEAT_CAN› (lr : CANON) : CANON = (fn thm =>
	((lr THEN_CAN REPEAT_CAN lr) ORELSE_CAN id_canon) thm
);
=TEX
=SML
fun €±_rewrite_canon› (thm : THM) : THM list = (
	[±_left_elim thm, ±_right_elim thm]
);
=TEX
=SML
fun €simple_≥_rewrite_canon› (thm : THM) : THM list = (
	[conv_rule (FIRST_C[
		simple_eq_match_conv ≥_≤_thm,
		simple_≥_∂_conv,
		simple_eq_match_conv ≥_1_thm])thm]
);
=TEX
=SML
fun €§_t_rewrite_canon› (thm : THM) : THM list = (
	if is_eq (concl thm)
	then fail "§_t_rewrite_canon" 26203 []
	else [§_t_intro thm]
);
=TEX
=SML
fun €simple_µ_rewrite_canon› (thm : THM) : THM list = (
	if is_simple_µ (concl thm)
	then [all_simple_µ_elim thm]
	else fail_canon thm
);
=TEX
=SML
fun €thm_%alpha%_eq› (thm1: THM) (thm2: THM) : bool = (
	let	val (asms1, conc1) = dest_thm thm1;
		val (asms2, conc2) = dest_thm thm2;
	in	%alpha%_eq conc1 conc2
		andalso all asms1 (switch(present (uncurry %alpha%_eq)) asms2)
		andalso all asms2 (switch(present (uncurry %alpha%_eq)) asms1)
	end
);
=TEX
=SML
fun €thm_frees› (thm: THM) : TERM list = (
	let	val (asms, conc) = dest_thm thm;
	in	(frees conc) cup (list_cup (map frees asms))
	end
);
=TEX
=SML
fun €rewrite_gen_canon› (fvs : TERM list) (thm : THM) : THM list = (
let	val (asms, conc) = dest_thm thm;
	val avoid = list_cup(fvs :: map frees asms);
in
	[list_simple_µ_intro ((frees conc) drop (fn v => (v mem avoid))) thm]
end);
=TEX
=SML
fun €REWRITE_CAN› (can : CANON) : CANON = (fn (thm : THM) =>
	(can 
	THEN_CAN rewrite_gen_canon (thm_frees thm)) thm
);
=TEX
=SML
val €initial_rw_canon› : CANON=
	REWRITE_CAN
	(REPEAT_CAN(FIRST_CAN [
	simple_µ_rewrite_canon,
	±_rewrite_canon,
	simple_≥_rewrite_canon,
	§_t_rewrite_canon]));
=TEX
\section{THE REWRITING RULES OF INFERENCE}
\subsection{Utilities}
=SML
val €thm_union› = union (fn (thm1,thm2) => (dest_thm thm1 = dest_thm thm2));

fun €filter› (fil : 'a -> bool) ((x :: rest) : 'a list) = (
	if fil x
	then x :: filter fil rest
	else filter fil rest
) | filter _ [] = [];
=TEX
For equational contexts:
=SML
fun €cthm_eqn_cxt› (canon: CANON) (thm:THM) : EQN_CXT = (
	mapfilter thm_eqn_cxt (canon thm)
);
=TEX
\subsection{prim\_rewrite\_conv}
The core function:
=SML
local
	fun FIRST_CHANGED_C (cv :: rest) tm =
		(CHANGED_C cv ORELSE_C FIRST_CHANGED_C rest) tm
	| FIRST_CHANGED_C [] tm = term_fail "eqn_cxt_conv" 28141 [tm];

	fun net_lookup_conv net : CONV = (fn (tm : TERM) =>
		FIRST_CHANGED_C(net_lookup net tm)tm
	);
in
fun €prim_rewrite_conv› (initial_net : CONV NET) :
	CANON -> 
	(CONV -> CONV) -> 
	EQN_CXT -> 
	THM list -> TERM -> THM = (
(fn (canon : CANON) =>
(fn (traverse : CONV -> CONV) =>
(fn (with_eqn_cxt : EQN_CXT) =>
let	val initial_with_eqn_cxt = list_net_enter 
		with_eqn_cxt initial_net
in
(fn (with_thms : THM list) =>
let	val with_entries = flat (map (cthm_eqn_cxt canon)
		with_thms);
	val initial_with_thms = list_net_enter 
		with_entries initial_with_eqn_cxt;
in
(fn (tm : TERM) =>
let
	val s1 = traverse (net_lookup_conv initial_with_thms) tm
in
	(prof "prim_rewrite_conv";
	s1)
end)
end)
end)
)
)
);
end; (* local fun FIRST_CHANGED_C ... *)
=TEX
=SML
fun €prim_rewrite_rule› (initial_net : CONV NET) :
	CANON -> 
	(CONV -> CONV) -> 
	EQN_CXT -> 
	THM list -> THM -> THM = (
let	val c1 = prim_rewrite_conv initial_net;
in
(fn (canon : CANON) =>
let	val c2 = c1 canon;
in
(fn (traverse : CONV -> CONV) =>
let	val c3 = c2 traverse;
in
(fn (with_eqn_cxt : EQN_CXT) =>
let	val c4 = c3 with_eqn_cxt;
in
(fn (with_thms : THM list) =>
let	val c5 = c4 with_thms;
in
(fn (thm : THM) =>
	(prof "prim_rewrite_rule";
	conv_rule c5 thm)
)
end)
end)
end)
end)
end);
=TEX
=SML
fun €prim_rewrite_tac› (initial_net : CONV NET) :
	CANON -> 
	(CONV -> CONV) -> 
	EQN_CXT -> 
	THM list -> TACTIC = (
let	val c1 = prim_rewrite_conv initial_net;
in
(fn (canon : CANON) =>
let	val c2 = c1 canon;
in
(fn (traverse : CONV -> CONV) =>
let	val c3 = c2 traverse;
in
(fn (with_eqn_cxt : EQN_CXT) =>
let	val c4 = c3 with_eqn_cxt;
in
(fn (with_thms : THM list) =>
let	val c5 = c4 with_thms;
in
(fn (gl : GOAL) =>
	(prof "prim_rewrite_tac";
	conv_tac c5 gl)
)
end)
end)
end)
end)
end);
=TEX
Now the actual inferences.
Rules first:
=SML
fun €rewrite_rule› (thms : THM list) : THM -> THM = (
let	val gpc = get_proof_context();
	val r1 = prim_rewrite_rule (get_epc_rw_net gpc)
		(get_epc_rw_canon gpc) TOP_MAP_C [] thms;
in
	(fn (thm : THM) => r1 thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "rewrite_rule" 26001 [])
end);

fun €pure_rewrite_rule› (thms : THM list) : THM -> THM = (
let	val rw_canon = get_epc_rw_canon(get_proof_context());
	val r1 = prim_rewrite_rule empty_net rw_canon TOP_MAP_C [] thms;
in
	(fn (thm : THM) => r1 thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_rewrite_rule" 26001 [])
end);

fun €once_rewrite_rule› (thms : THM list) : THM -> THM = (
let	val gpc = get_proof_context();
	val r1 = prim_rewrite_rule (get_epc_rw_net gpc)
		(get_epc_rw_canon gpc) ONCE_MAP_C [] thms;
in
	(fn (thm : THM) => r1 thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_rewrite_rule" 26001 [])
end);

fun €pure_once_rewrite_rule› (thms : THM list) : THM -> THM = (
let	val rw_canon = get_epc_rw_canon(get_proof_context());
	val r1 = prim_rewrite_rule empty_net rw_canon ONCE_MAP_C [] thms;
in
	(fn (thm : THM) => r1 thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_rewrite_rule" 26001 [])
end);
=TEX
Now with assumptions:
=SML
fun €asm_rewrite_rule› (thms : THM list) : THM -> THM = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_rule rw_net rw_canon TOP_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (hyps thm)) thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "asm_rewrite_rule" 26001 [])
end);

fun €pure_asm_rewrite_rule› (thms : THM list) : THM -> THM = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_rule empty_net rw_canon TOP_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (hyps thm)) thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_asm_rewrite_rule" 26001 [])
end);

fun €once_asm_rewrite_rule› (thms : THM list) : THM -> THM = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_rule rw_net rw_canon ONCE_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (hyps thm)) thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_asm_rewrite_rule" 26001 [])
end);

fun €pure_once_asm_rewrite_rule› (thms : THM list) : THM -> THM = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_rule empty_net rw_canon ONCE_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (hyps thm)) thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_asm_rewrite_rule" 26001 [])
end);
=TEX

Now we give rules with filtered assumption lists.
=SML
fun €fasm_rewrite_rule› (thms : THM list) (fil: TERM -> bool) : THM -> THM = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_rule rw_net rw_canon TOP_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (filter fil (hyps thm))) thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "fasm_rewrite_rule" 26001 [])
end);

fun €pure_fasm_rewrite_rule› (thms : THM list) (fil: TERM -> bool) : THM -> THM = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_rule empty_net rw_canon TOP_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (filter fil (hyps thm))) thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_fasm_rewrite_rule" 26001 [])
end);

fun €once_fasm_rewrite_rule› (thms : THM list) (fil: TERM -> bool) : THM -> THM = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_rule rw_net rw_canon ONCE_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (filter fil (hyps thm))) thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_fasm_rewrite_rule" 26001 [])
end);

fun €pure_once_fasm_rewrite_rule› (thms : THM list) (fil: TERM -> bool) : THM -> THM = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_rule empty_net rw_canon ONCE_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (filter fil (hyps thm))) thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_fasm_rewrite_rule" 26001 [])
end);
=TEX
Conversions:
=SML
fun €rewrite_conv› (thms : THM list) : CONV = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_conv rw_net rw_canon TOP_MAP_C [] thms;
in
	(fn (tm : TERM) => r1 tm
	handle complaint =>
	divert complaint "TOP_MAP_C" "rewrite_conv" 26001 [])
end);

fun €pure_rewrite_conv› (thms : THM list) : CONV = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_conv empty_net rw_canon TOP_MAP_C [] thms;
in
	(fn (tm : TERM) => r1 tm
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_rewrite_conv" 26001 [])
end);

fun €once_rewrite_conv› (thms : THM list) : CONV = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_conv rw_net rw_canon ONCE_MAP_C [] thms;
in
	(fn (tm : TERM) => r1 tm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_rewrite_conv" 26001 [])
end);

fun €pure_once_rewrite_conv› (thms : THM list) : CONV = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_conv empty_net rw_canon ONCE_MAP_C [] thms;
in
	(fn (tm : TERM) => r1 tm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_rewrite_conv" 26001 [])
end);
=TEX
Tactics:
=SML
fun €rewrite_tac› (thms : THM list) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_tac rw_net rw_canon TOP_MAP_C [] thms;
in
	(fn (gl : GOAL) => r1 gl
	handle complaint =>
	divert complaint "TOP_MAP_C" "rewrite_tac" 26001 [])
end);

fun €pure_rewrite_tac› (thms : THM list) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_tac empty_net rw_canon TOP_MAP_C [] thms;
in
	(fn (gl : GOAL) => r1 gl
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_rewrite_tac" 26001 [])
end);

fun €once_rewrite_tac› (thms : THM list) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_tac rw_net rw_canon ONCE_MAP_C [] thms;
in
	(fn (gl : GOAL) => r1 gl
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_rewrite_tac" 26001 [])
end);

fun €pure_once_rewrite_tac› (thms : THM list) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_tac empty_net rw_canon ONCE_MAP_C [] thms;
in
	(fn (gl : GOAL) => r1 gl
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_rewrite_tac" 26001 [])
end);
=TEX
Now with assumptions:
=SML
fun €asm_rewrite_tac› (thms : THM list) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_tac rw_net rw_canon TOP_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule asms) (asms,conc)
	handle complaint =>
	divert complaint "TOP_MAP_C" "asm_rewrite_tac" 26001 [])
end);

fun €pure_asm_rewrite_tac› (thms : THM list) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_tac empty_net rw_canon TOP_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule asms) (asms,conc)
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_asm_rewrite_tac" 26001 [])
end);

fun €once_asm_rewrite_tac› (thms : THM list) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_tac rw_net rw_canon ONCE_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule asms) (asms,conc)
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_asm_rewrite_tac" 26001 [])
end);

fun €pure_once_asm_rewrite_tac› (thms : THM list) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_tac empty_net rw_canon ONCE_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule asms) (asms,conc)
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_asm_rewrite_tac" 26001 [])
end);
=TEX

Now we give rules with filtered assumption lists.
=SML
fun €fasm_rewrite_tac› (thms : THM list) (fil: TERM -> bool) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_tac rw_net rw_canon TOP_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule (filter fil asms))(asms,conc)
	handle complaint =>
	divert complaint "TOP_MAP_C" "fasm_rewrite_tac" 26001 [])
end);

fun €pure_fasm_rewrite_tac› (thms : THM list) (fil: TERM -> bool) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_tac empty_net rw_canon TOP_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule (filter fil asms))(asms,conc)
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_fasm_rewrite_tac" 26001 [])
end);

fun €once_fasm_rewrite_tac› (thms : THM list) (fil: TERM -> bool) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_tac rw_net rw_canon ONCE_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule (filter fil asms))(asms,conc)
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_fasm_rewrite_tac" 26001 [])
end);

fun €pure_once_fasm_rewrite_tac› (thms : THM list) (fil: TERM -> bool) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_tac empty_net rw_canon ONCE_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule (filter fil asms))(asms,conc)
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_fasm_rewrite_tac" 26001 [])
end);
=TEX
=SML
fun €singleton› (x : 'a) : 'a list = [x];

val €rewrite_thm_tac› : THM -> TACTIC =
				rewrite_tac o singleton;
val €pure_rewrite_thm_tac› : THM -> TACTIC =
				pure_rewrite_tac o singleton;
val €once_rewrite_thm_tac› : THM -> TACTIC =
				once_rewrite_tac o singleton;
val €pure_once_rewrite_thm_tac› : THM -> TACTIC =
				pure_once_rewrite_tac  o singleton;
val €asm_rewrite_thm_tac› : THM -> TACTIC =
				asm_rewrite_tac o singleton;
val €pure_asm_rewrite_thm_tac› : THM -> TACTIC = 
				pure_asm_rewrite_tac o singleton;
val €once_asm_rewrite_thm_tac› : THM -> TACTIC =
				once_asm_rewrite_tac o singleton;
val €pure_once_asm_rewrite_thm_tac› : THM -> TACTIC = 
				pure_once_asm_rewrite_tac o singleton;
val €fasm_rewrite_thm_tac› : (TERM -> bool) -> THM -> TACTIC =
				switch (fasm_rewrite_tac o singleton);
val €pure_fasm_rewrite_thm_tac› : (TERM -> bool) -> THM -> TACTIC = 
				switch (pure_fasm_rewrite_tac o singleton);
val €once_fasm_rewrite_thm_tac› : (TERM -> bool) -> THM -> TACTIC = 
				switch (once_fasm_rewrite_tac o singleton);
val €pure_once_fasm_rewrite_thm_tac› : (TERM -> bool) -> THM -> TACTIC =
				switch (pure_once_fasm_rewrite_tac o singleton);
=TEX
\section{BASIC REWRITE THEOREMS}
=SML
val €eq_rewrite_thm› = save_thm("eq_rewrite_thm", tac_proof(([],
		¨µ x∑(x = x) § TÆ),
	REPEAT strip_tac THEN accept_tac (refl_conv¨xÆ)));
val €§_rewrite_thm› = save_thm("§_rewrite_thm", tac_proof(([],
		¨µ t∑((T § t) = t) ± ((t § T) = t) ± ((F § t) = (≥ t)) ± (t § F) = (≥ t)Æ),
	REPEAT strip_tac));
val €≥_rewrite_thm› = save_thm("≥_rewrite_thm", tac_proof(([],
		¨µ t∑(≥≥t) = t ± ((≥ T) = F) ± (≥ F) = TÆ),
	REPEAT strip_tac));
val €±_rewrite_thm› = save_thm("±_rewrite_thm", tac_proof(([],
		¨µ t∑((T ± t) § t) ± ((t ± T) § t) ±
		(≥ (F ± t)) ± (≥ (t ± F)) ± (t ± t) = tÆ),
	REPEAT strip_tac));
val €≤_rewrite_thm› = save_thm("≤_rewrite_thm", tac_proof(([],
		¨µ t∑(T ≤ t) ± (t ≤ T) ± ((F ≤ t) = t) ± ((t ≤ F) = t) ± (t ≤ t) = tÆ),
	REPEAT strip_tac));
val €¥_rewrite_thm› = save_thm("¥_rewrite_thm", tac_proof(([],
		¨µ t∑((T ¥ t) = t) ± ((F ¥ t) = T) ± ((t ¥ T) = T) ± ((t ¥ t) = T)
  ± (t ¥ F) = (≥ t)Æ),
	REPEAT strip_tac));
val €if_rewrite_thm› = save_thm("if_rewrite_thm", tac_proof(([],
	¨µ t1 t2∑((if T then t1 else t2) = t1) ± (if F then t1 else t2) = t2Æ),
	REPEAT strip_tac THEN conv_tac (eq_sym_conv THEN_C fun_if_conv)
	THEN REPEAT strip_tac THEN_LIST [
		accept_tac(refl_conv¨t1Æ), 
		accept_tac(refl_conv¨t2Æ)]));

val €µ_rewrite_thm› = save_thm("µ_rewrite_thm", tac_proof(([],
		¨µ t∑(µ x∑t) = tÆ),
	REPEAT strip_tac THEN POP_ASM_T (accept_tac o all_simple_µ_elim)));
val €∂_rewrite_thm› = save_thm("∂_rewrite_thm", tac_proof(([],
		¨µ t∑(∂ x∑t) = tÆ),
	REPEAT strip_tac THEN simple_∂_tac ¨xÆ THEN goal_in_asms_tac));
val €%beta%_rewrite_thm› = save_thm("%beta%_rewrite_thm", tac_proof(([],
		¨µ t1:'a; t2:'b∑((Ã x∑t1)t2) = t1Æ),
	REPEAT strip_tac THEN accept_tac(simple_%beta%_conv ¨(Ã x:'b∑t1:'a)t2Æ)));
=TEX
\subsection{Rewriting Proof Contexts}
=SML
val €initial_rw_eqn_cxt› : EQN_CXT = (flat
	(map (cthm_eqn_cxt initial_rw_canon) [
		eq_rewrite_thm,
		§_rewrite_thm,
		≥_rewrite_thm,
		±_rewrite_thm,
		≤_rewrite_thm,
		¥_rewrite_thm,
		if_rewrite_thm,
		µ_rewrite_thm,
		∂_rewrite_thm,
		%beta%_rewrite_thm])) @
	[ (¨(Ã x ∑ y) zÆ, simple_%beta%_conv) ];

val €initial_rewrite_pc› : PROOF_CONTEXT = (
	set_pc_rw_canons [simple_µ_rewrite_canon,
		±_rewrite_canon,
		simple_≥_rewrite_canon]
	(set_pc_rw_eqn_cxt initial_rw_eqn_cxt
		initial_strip_pc)
);

val €initial_rewrite_epc›: EPROOF_CONTEXT = (
	set_epc_rw_canon initial_rw_canon
	(set_epc_rw_net (make_net initial_rw_eqn_cxt)
	initial_strip_epc)
);

val _ = push_proof_context initial_rewrite_epc;
=TEX
Restore the previous theory:
=SML
val _ = open_theory was_theory;
=TEX
\section{EVALUATION OF PROOF CONTEXTS}
=SML
fun €evaluate_proof_context› (nm : string)(pc: PROOF_CONTEXT) 
	: EPROOF_CONTEXT = (
	set_epc_name nm
	(set_epc_rw_net(make_net (get_pc_rw_eqn_cxt pc))
	(set_epc_rw_canon(REWRITE_CAN
		(REPEAT_CAN(FIRST_CAN (get_pc_rw_canons pc @
		[§_t_rewrite_canon]))))
	(set_epc_st_conv (eqn_cxt_conv(get_pc_st_eqn_cxt pc))
	(set_epc_sg_conv (eqn_cxt_conv(get_pc_sg_eqn_cxt pc))
	(set_epc_cs_∂_rule (get_pc_cs_∂_rule pc)
	initial_epc)))))
);
=TEX
\section{END OF THE STRUCTURE}
=SML
end; (* of structure Rewriting *)
open Rewriting;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN


