=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the Rewriting Rules of Inference}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Rewriting Rules of Inference}
\TPPref{DS/FMU/IED/IMP026}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{K.~Blackburn & WIN01\\D.J.~King & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Good version.
\item [Issue 1.3]
Changed $?\_TRAVERSE\_C$ to $?\_MAP\_C$.
Failure 26001 added to appropriate functions.
\item [Issue 1.6]
Addition of tactics.
\item [Issue 1.7]
Addition and canons and basic rewrites.
\item [Issue 1.8]
Fixes to canons and basic rewrites.
\item [Issue 1.9]
Added initialisation of rewrite convs.
\item [Issue 1.10]
Added theorem tactic formulations of rewriting.
\item [Issue 1.11]
Various minor mods as a result of testing canons.
\item [Issue 1.12]
Renamings of functions containing the name atom $simple$,
and renaming of $aconv$.
\item [Issue 1.13]
All rewrite functions now fail when applying an equation produces no change.
\item [Issue 1.14]
Re-implementation to follow ideas of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.15]
Fixed a bug with $simple\_µ\_rewrite\_canon$.
\item [Issue 1.16]
Reacting to issue 1.5 of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.17]
Added $cs\_¶\_rule$ material.

\item[Issue 1.18, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.19, 1.20]
Added and used $(ONCE\_)REWRITE\_MAP\_C$.
\item [Issue 1.21 (26th March 1992)]
Changed to use proof context material of issue 1.13 of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.21 (31st March 1992)]
Removed filtered rewrites, added understanding of double negation
to $simple\-\_³\-\_rewrite\-\_canon$.
\item [Issue  (2nd April 1992)]
Changes required by CR0016.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the rewriting rules of inference.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the rewriting rules of inference.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD026}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{START OF THE SIGNATURE}
=SML
structure Rewriting : Rewriting = struct
=TEX
=SML
val Ûwas_theoryÝ = get_current_theory_name ();
val _ = open_theory "misc";
=TEX
\section{CANONICALISATION FUNCTIONS}
=SML
type ÛCANONÝ = THM -> (THM list);
=TEX
=SML
val Ûid_canonÝ : CANON = (fn thm => [thm]);
=TEX
=SML
val Ûfail_canonÝ : CANON = (fn _ => fail "fail_canon" 26201 []);
=TEX
=SML
fun Ûfail_with_canonÝ 	(area : string) (msg : int)
	(inserters : (unit -> string) list) : CANON = (fn thm =>
	fail area msg inserters
);
=TEX
=SML
fun (lr1 : CANON) ÛTHEN_CANÝ (lr2 : CANON) : CANON = (
	flat o (map lr2 o lr1)
);
=TEX
=SML
fun (lr1 : CANON) ÛORELSE_CANÝ (lr2 : CANON) : CANON = (fn thm =>
	(lr1 thm) handle Fail _ => lr2 thm
);
=TEX
=SML
fun (lr1 : CANON) ÛTHEN_LIST_CANÝ (lrs : CANON list) : CANON = (fn thm =>
	let	fun aux (thm :: morethms) (lr :: morelrs) = (
			lr thm @ aux morethms morelrs
		) | aux [] [] = ([]
		) | aux _ _ = fail "THEN_LIST_CAN" 26204 [];
	in	aux (lr1 thm) lrs
	end	
);
=TEX
=SML
fun ÛEVERY_CANÝ (lrs : CANON list) : CANON = fold (op THEN_CAN) lrs id_canon;
=TEX
=SML
fun ÛFIRST_CANÝ (lrs : CANON list) = (
	fold (op ORELSE_CAN) lrs (fail_with_canon "FIRST_CAN" 26202 [])
);
=TEX
=SML
fun ÛREPEAT_CANÝ (lr : CANON) : CANON = (fn thm =>
	((lr THEN_CAN REPEAT_CAN lr) ORELSE_CAN id_canon) thm
);
=TEX
=SML
fun Û±_rewrite_canonÝ (thm : THM) : THM list = (
	[±_left_elim thm, ±_right_elim thm]
);
=TEX
=SML
local
	val µ_tm = mk_simple_µ(mk_var("x",BOOL),mk_var("x",BOOL));
in
fun Ûf_rewrite_canonÝ (thm : THM) : THM list = (
	[contr_rule µ_tm thm]
);
end;
=TEX
=SML
fun Ûsimple_³_rewrite_canonÝ (thm : THM) : THM list = (
	dest_³(concl thm)
	handle complaint =>
	pass_on complaint "dest_³" "simple_³_rewrite_canon";
	[conv_rule (FIRST_C[
		simple_eq_match_conv ³_²_thm,
		simple_³_¶_conv,
		³_³_conv,
		simple_eq_match_conv ³_1_thm])thm]
);
=TEX
=SML
fun Û¤_t_rewrite_canonÝ (thm : THM) : THM list = (
	if is_eq (concl thm)
	then fail "¤_t_rewrite_canon" 26203 []
	else [¤_t_intro thm]
);
=TEX
=SML
fun Ûsimple_µ_rewrite_canonÝ (thm : THM) : THM list = (
	if is_simple_µ (concl thm)
	then [all_simple_µ_elim thm]
	else fail_canon thm
);
=TEX
=SML
fun Ûthm_freesÝ (thm: THM) : TERM list = (
	let	val (asms, conc) = dest_thm thm;
	in	list_union (op =$)(frees conc :: (map frees asms))
	end
);
=TEX
=SML
fun Ûrewrite_gen_canonÝ (fvs : TERM list) (thm : THM) : THM list = (
let	val (asms, conc) = dest_thm thm;
	val avoid = list_union (op =$) (fvs :: map frees asms);
in
	[list_simple_µ_intro ((frees conc) drop (fn v => (present (op =$) v avoid))) thm]
end);
=TEX
=SML
fun ÛREWRITE_CANÝ (can : CANON) : CANON = (fn (thm : THM) =>
	(can 
	THEN_CAN rewrite_gen_canon (thm_frees thm)) thm
);
=TEX
=SML
val Ûinitial_rw_canonÝ : CANON=
	REWRITE_CAN
	(REPEAT_CAN(FIRST_CAN [
	simple_µ_rewrite_canon,
	±_rewrite_canon,
	simple_³_rewrite_canon,
	f_rewrite_canon,
	¤_t_rewrite_canon]));
=TEX
\section{THE REWRITING RULES OF INFERENCE}
\subsection{Utilities}
=SML
val Ûthm_unionÝ = union (op =|-);
=TEX
For equational contexts:
=SML
fun Ûcthm_eqn_cxtÝ (canon: CANON) (thm:THM) : EQN_CXT = (
	mapfilter thm_eqn_cxt (canon thm)
);
=TEX
\subsection{prim\_rewrite\_conv}
The core function:
=SML
local
	fun FIRST_CHANGED_C (cv :: rest) tm =
		(CHANGED_C cv ORELSE_C FIRST_CHANGED_C rest) tm
	| FIRST_CHANGED_C [] tm = term_fail "eqn_cxt_conv" 28141 [tm];

	fun net_lookup_conv net : CONV = (fn (tm : TERM) =>
		FIRST_CHANGED_C(net_lookup net tm)tm
	);
in
fun Ûprim_rewrite_convÝ (initial_net : CONV NET) :
	CANON -> 
	(CONV -> CONV) -> 
	EQN_CXT -> 
	THM list -> TERM -> THM = (
(fn (canon : CANON) =>
(fn (traverse : CONV -> CONV) =>
(fn (with_eqn_cxt : EQN_CXT) =>
let	val initial_with_eqn_cxt = list_net_enter 
		with_eqn_cxt initial_net
in
(fn (with_thms : THM list) =>
let	val with_entries = flat (map (cthm_eqn_cxt canon)
		with_thms);
	val initial_with_thms = list_net_enter 
		with_entries initial_with_eqn_cxt;
in
(fn (tm : TERM) =>
let
	val s1 = traverse (net_lookup_conv initial_with_thms) tm
in
	(prof "prim_rewrite_conv";
	s1)
end)
end)
end)
)
)
);
end; (* local fun FIRST_CHANGED_C ... *)
=TEX
=SML
fun Ûprim_rewrite_ruleÝ (initial_net : CONV NET) :
	CANON -> 
	(CONV -> CONV) -> 
	EQN_CXT -> 
	THM list -> THM -> THM = (
let	val c1 = prim_rewrite_conv initial_net;
in
(fn (canon : CANON) =>
let	val c2 = c1 canon;
in
(fn (traverse : CONV -> CONV) =>
let	val c3 = c2 traverse;
in
(fn (with_eqn_cxt : EQN_CXT) =>
let	val c4 = c3 with_eqn_cxt;
in
(fn (with_thms : THM list) =>
let	val c5 = c4 with_thms;
in
(fn (thm : THM) =>
	(prof "prim_rewrite_rule";
	conv_rule c5 thm)
)
end)
end)
end)
end)
end);
=TEX
=SML
fun Ûprim_rewrite_tacÝ (initial_net : CONV NET) :
	CANON -> 
	(CONV -> CONV) -> 
	EQN_CXT -> 
	THM list -> TACTIC = (
let	val c1 = prim_rewrite_conv initial_net;
in
(fn (canon : CANON) =>
let	val c2 = c1 canon;
in
(fn (traverse : CONV -> CONV) =>
let	val c3 = c2 traverse;
in
(fn (with_eqn_cxt : EQN_CXT) =>
let	val c4 = c3 with_eqn_cxt;
in
(fn (with_thms : THM list) =>
let	val c5 = c4 with_thms;
in
(fn (gl : GOAL) =>
	(prof "prim_rewrite_tac";
	conv_tac c5 gl)
)
end)
end)
end)
end)
end);
=TEX
\subsection{Traversal Functions}
=SML
local
=TEX
A flag:
=SML
val Ûillformed_rewrite_warningÝ : bool ref = ref false;
val _ = new_flag{name = "illformed_rewrite_warning",
	check = (fn _ => true),
	control = illformed_rewrite_warning,
	default = (fn _ => false)};

val an_error = (fail "RW_SUB_C" 26001 [])
	handle complaint => complaint;
=TEX
The supporting auxiliary function:
=SML
fun ÛRW_SUB_CÝ (illformed:bool ref)(cnv : CONV) : CONV = (fn (tm:TERM) => 
let	fun aux (Var _) = raise an_error
	| aux (Const _) = raise an_error
	| aux (App (f,x)) = (
		let val thm1 = cnv f
		in
		 (let val thm2 = (cnv x
			handle (Fail _) => refl_conv x)
		 in
			(mk_app_rule thm1 thm2
			handle (Fail _) =>
			(illformed := true;
			raise an_error))
		 end)
		end
		handle (Fail _) =>
		(let val thm2 = cnv x
		in
			(ap_fun_rule f thm2
			handle (Fail _) =>
			(illformed := true;
			raise an_error))
		end)
	) | aux (SimpleÌ (x,b)) = (
		let val thm1 = cnv b
		in
			(simple_Ì_eq_rule x thm1
			handle (Fail _) =>
			(illformed := true;
			raise an_error))
		end
	);
in
	aux(dest_simple_term tm)
end);

in
=TEX
=SML
fun ÛREWRITE_MAP_CÝ (caller : string) (cnv : CONV) : CONV = (	fn (tm: TERM) => 
let	val illformed = ref false;
	fun aux (tm : TERM) = ((REPEAT1_C cnv) EITHER_C 
	((CHANGED_C (RW_SUB_C illformed aux))
		FURTHER_C
		(cnv FURTHER_C aux))) tm;
	val res = aux tm handle (Fail _) =>
		(if (!illformed)
		then fail caller 26003 []
		else fail caller 26001 []);
in
	(if (!illformed) andalso (!illformed_rewrite_warning)
	then warn caller 26002 []
	else ();
	res)
end);
=TEX
=SML
fun ÛONCE_REWRITE_MAP_CÝ (caller : string) (cnv : CONV) : CONV = (
fn (tm: TERM) => 
let	val illformed = ref false;
	fun aux (tm : TERM) = (cnv ORELSE_C (RW_SUB_C illformed aux)) tm;
	val res = aux tm handle (Fail _) =>
		(if (!illformed)
		then fail caller 26003 []
		else fail caller 26001 []);
in
	(if (!illformed) andalso (!illformed_rewrite_warning)
	then warn caller 26002 []
	else ();
	res)
end);
=TEX
=SML
end; (* local RW_SUB_C *)
=TEX
\subsection{Derived Rewriting Rules}
Now the actual inferences.
Rules first:
=SML
fun Ûrewrite_ruleÝ (thms : THM list) : THM -> THM = (
let	val r1 = prim_rewrite_rule (current_ad_rw_net ())
		(current_ad_rw_canon ()) 
		(REWRITE_MAP_C "rewrite_rule") [] thms;
in
	(fn (thm : THM) => r1 thm)
end);

fun Ûpure_rewrite_ruleÝ (thms : THM list) : THM -> THM = (
let	val rw_canon = current_ad_rw_canon();
	val r1 = prim_rewrite_rule empty_net rw_canon 
		(REWRITE_MAP_C "pure_rewrite_rule") [] thms;
in
	(fn (thm : THM) => r1 thm)
end);

fun Ûonce_rewrite_ruleÝ (thms : THM list) : THM -> THM = (
let	val r1 = prim_rewrite_rule (current_ad_rw_net ())
		(current_ad_rw_canon ()) 
		(ONCE_REWRITE_MAP_C "once_rewrite_rule") [] thms;
in
	(fn (thm : THM) => r1 thm)
end);

fun Ûpure_once_rewrite_ruleÝ (thms : THM list) : THM -> THM = (
let	val rw_canon = current_ad_rw_canon();
	val r1 = prim_rewrite_rule empty_net rw_canon 
		(ONCE_REWRITE_MAP_C "pure_once_rewrite_rule") [] thms;
in
	(fn (thm : THM) => r1 thm)
end);
=TEX
Now with assumptions:
=SML
fun Ûasm_rewrite_ruleÝ (thms : THM list) : THM -> THM = (
let	val rw_canon = current_ad_rw_canon ();
	val rw_net = current_ad_rw_net();
	val r1 = prim_rewrite_rule rw_net rw_canon 
		(REWRITE_MAP_C "asm_rewrite_rule")
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (hyps thm)) thm)
end);

fun Ûpure_asm_rewrite_ruleÝ (thms : THM list) : THM -> THM = (
let	val rw_canon = current_ad_rw_canon ();
	val r1 = prim_rewrite_rule empty_net rw_canon 
		(REWRITE_MAP_C "pure_asm_rewrite_rule")
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (hyps thm)) thm)
end);

fun Ûonce_asm_rewrite_ruleÝ (thms : THM list) : THM -> THM = (
let	val rw_canon = current_ad_rw_canon ();
	val rw_net = current_ad_rw_net();
	val r1 = prim_rewrite_rule rw_net rw_canon 
		(ONCE_REWRITE_MAP_C "once_asm_rewrite_rule")
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (hyps thm)) thm)
end);

fun Ûpure_once_asm_rewrite_ruleÝ (thms : THM list) : THM -> THM = (
let	val rw_canon = current_ad_rw_canon ();
	val r1 = prim_rewrite_rule empty_net rw_canon 
		(ONCE_REWRITE_MAP_C "pure_once_asm_rewrite_rule")
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (hyps thm)) thm)
end);
=TEX

Conversions:
=SML
fun Ûrewrite_convÝ (thms : THM list) : CONV = (
let	val rw_canon = current_ad_rw_canon ();
	val rw_net = current_ad_rw_net();
	val r1 = prim_rewrite_conv rw_net rw_canon 
		(REWRITE_MAP_C "rewrite_conv")
		 [] thms;
in
	r1
end);

fun Ûpure_rewrite_convÝ (thms : THM list) : CONV = (
let	val rw_canon = current_ad_rw_canon ();
	val r1 = prim_rewrite_conv empty_net rw_canon 
		(REWRITE_MAP_C "pure_rewrite_conv") [] thms;
in
	r1
end);

fun Ûonce_rewrite_convÝ (thms : THM list) : CONV = (
let	val rw_canon = current_ad_rw_canon ();
	val rw_net = current_ad_rw_net();
	val r1 = prim_rewrite_conv rw_net rw_canon 
		(ONCE_REWRITE_MAP_C "once_rewrite_conv") [] thms;
in
	r1
end);

fun Ûpure_once_rewrite_convÝ (thms : THM list) : CONV = (
let	val rw_canon = current_ad_rw_canon ();
	val r1 = prim_rewrite_conv empty_net rw_canon 
		(ONCE_REWRITE_MAP_C "pure_once_rewrite_conv") [] thms;
in
	r1
end);
=TEX
Tactics:
=SML
fun Ûrewrite_tacÝ (thms : THM list) : TACTIC = (
let	val rw_canon = current_ad_rw_canon ();
	val rw_net = current_ad_rw_net();
	val r1 = prim_rewrite_tac rw_net rw_canon 
		(REWRITE_MAP_C "rewrite_tac") [] thms;
in
	r1
end);

fun Ûpure_rewrite_tacÝ (thms : THM list) : TACTIC = (
let	val rw_canon = current_ad_rw_canon ();
	val r1 = prim_rewrite_tac empty_net rw_canon 
		(REWRITE_MAP_C "pure_rewrite_tac") [] thms;
in
	r1
end);

fun Ûonce_rewrite_tacÝ (thms : THM list) : TACTIC = (
let	val rw_canon = current_ad_rw_canon ();
	val rw_net = current_ad_rw_net();
	val r1 = prim_rewrite_tac rw_net rw_canon 
		(ONCE_REWRITE_MAP_C "once_rewrite_tac") [] thms;
in
	r1
end);

fun Ûpure_once_rewrite_tacÝ (thms : THM list) : TACTIC = (
let	val rw_canon = current_ad_rw_canon ();
	val r1 = prim_rewrite_tac empty_net rw_canon 
		(ONCE_REWRITE_MAP_C "pure_once_rewrite_tac") [] thms;
in
	r1
end);
=TEX
Now with assumptions:
=SML
fun Ûasm_rewrite_tacÝ (thms : THM list) : TACTIC = (
let	val rw_canon = current_ad_rw_canon ();
	val rw_net = current_ad_rw_net();
	val r1 = prim_rewrite_tac rw_net rw_canon 
		(REWRITE_MAP_C "asm_rewrite_tac")
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule asms) (asms,conc))
end);

fun Ûpure_asm_rewrite_tacÝ (thms : THM list) : TACTIC = (
let	val rw_canon = current_ad_rw_canon ();
	val r1 = prim_rewrite_tac empty_net rw_canon 
		(REWRITE_MAP_C "pure_asm_rewrite_tac")
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule asms) (asms,conc))
end);

fun Ûonce_asm_rewrite_tacÝ (thms : THM list) : TACTIC = (
let	val rw_canon = current_ad_rw_canon ();
	val rw_net = current_ad_rw_net();
	val r1 = prim_rewrite_tac rw_net rw_canon 
		(ONCE_REWRITE_MAP_C "once_asm_rewrite_tac")
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule asms) (asms,conc))
end);

fun Ûpure_once_asm_rewrite_tacÝ (thms : THM list) : TACTIC = (
let	val rw_canon = current_ad_rw_canon ();
	val r1 = prim_rewrite_tac empty_net rw_canon 
		(ONCE_REWRITE_MAP_C "pure_once_asm_rewrite_tac")
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule asms) (asms,conc))
end);
=TEX

=SML
fun ÛsingletonÝ (x : 'a) : 'a list = [x];

val Ûrewrite_thm_tacÝ : THM -> TACTIC =
				rewrite_tac o singleton;
val Ûpure_rewrite_thm_tacÝ : THM -> TACTIC =
				pure_rewrite_tac o singleton;
val Ûonce_rewrite_thm_tacÝ : THM -> TACTIC =
				once_rewrite_tac o singleton;
val Ûpure_once_rewrite_thm_tacÝ : THM -> TACTIC =
				pure_once_rewrite_tac  o singleton;
val Ûasm_rewrite_thm_tacÝ : THM -> TACTIC =
				asm_rewrite_tac o singleton;
val Ûpure_asm_rewrite_thm_tacÝ : THM -> TACTIC = 
				pure_asm_rewrite_tac o singleton;
val Ûonce_asm_rewrite_thm_tacÝ : THM -> TACTIC =
				once_asm_rewrite_tac o singleton;
val Ûpure_once_asm_rewrite_thm_tacÝ : THM -> TACTIC = 
				pure_once_asm_rewrite_tac o singleton;
=TEX
\section{BASIC REWRITE THEOREMS}
=SML
val Ûeq_rewrite_thmÝ = save_thm("eq_rewrite_thm", tac_proof(([],
		¬µ x·(x = x) ¤ T®),
	REPEAT strip_tac THEN accept_tac (refl_conv¬x®)));
val Û¤_rewrite_thmÝ = save_thm("¤_rewrite_thm", tac_proof(([],
		¬µ t·((T ¤ t) = t) ± ((t ¤ T) = t) ± ((F ¤ t) = (³ t)) ± (t ¤ F) = (³ t)®),
	REPEAT strip_tac));
val Û³_rewrite_thmÝ = save_thm("³_rewrite_thm", tac_proof(([],
		¬µ t·(³³t) = t ± ((³ T) = F) ± (³ F) = T®),
	REPEAT strip_tac));
val Û±_rewrite_thmÝ = save_thm("±_rewrite_thm", tac_proof(([],
		¬µ t·((T ± t) ¤ t) ± ((t ± T) ¤ t) ±
		(³ (F ± t)) ± (³ (t ± F)) ± (t ± t) = t®),
	REPEAT strip_tac));
val Û²_rewrite_thmÝ = save_thm("²_rewrite_thm", tac_proof(([],
		¬µ t·(T ² t) ± (t ² T) ± ((F ² t) = t) ± ((t ² F) = t) ± (t ² t) = t®),
	REPEAT strip_tac));
val Û´_rewrite_thmÝ = save_thm("´_rewrite_thm", tac_proof(([],
		¬µ t·((T ´ t) = t) ± ((F ´ t) = T) ± ((t ´ T) = T) ± ((t ´ t) = T)
  ± (t ´ F) = (³ t)®),
	REPEAT strip_tac));
val Ûif_rewrite_thmÝ = save_thm("if_rewrite_thm", tac_proof(([],
	¬µ t1 t2·((if T then t1 else t2) = t1) ± (if F then t1 else t2) = t2®),
	REPEAT strip_tac THEN conv_tac (eq_sym_conv THEN_C fun_if_conv)
	THEN REPEAT strip_tac THEN_LIST [
		accept_tac(refl_conv¬t1®), 
		accept_tac(refl_conv¬t2®)]));

val Ûµ_rewrite_thmÝ = save_thm("µ_rewrite_thm", tac_proof(([],
		¬µ t·(µ x·t) = t®),
	REPEAT strip_tac THEN POP_ASM_T (accept_tac o all_simple_µ_elim)));
val Û¶_rewrite_thmÝ = save_thm("¶_rewrite_thm", tac_proof(([],
		¬µ t·(¶ x·t) = t®),
	REPEAT strip_tac THEN simple_¶_tac ¬x® THEN goal_in_asms_tac));
val ÛÂ_rewrite_thmÝ = save_thm("Â_rewrite_thm", tac_proof(([],
		¬µ t1:'a; t2:'b·((Ì x·t1)t2) = t1®),
	REPEAT strip_tac THEN accept_tac(simple_Â_conv ¬(Ì x:'b·t1:'a)t2®)));
=TEX
\subsection{Rewriting Proof Contexts}
Create a new proof context, and set the rewriting canonicalisation function.
=SML
val Ûinitial_rw_eqn_cxtÝ : EQN_CXT = (flat
	(map (cthm_eqn_cxt initial_rw_canon) [
		eq_rewrite_thm,
		¤_rewrite_thm,
		³_rewrite_thm,
		±_rewrite_thm,
		²_rewrite_thm,
		´_rewrite_thm,
		if_rewrite_thm,
		µ_rewrite_thm,
		¶_rewrite_thm,
		Â_rewrite_thm])) @
	[ (¬(Ì x · y) z®, simple_Â_conv) ];

val _ = new_pc "initial_rewrite";
val _ = merge_pcs ["initial_strip"] "initial_rewrite";
val _ = set_rw_canons [simple_µ_rewrite_canon,
		±_rewrite_canon,
		simple_³_rewrite_canon,
		f_rewrite_canon] "initial_rewrite";
val _ = set_rw_eqn_cxt initial_rw_eqn_cxt "initial_rewrite";

val _ = icl'set_eval_ad_rw_canon (fn canons =>
	REWRITE_CAN
	(REPEAT_CAN(FIRST_CAN (canons @
	[¤_t_rewrite_canon]))));
val _ = commit_pc "initial_rewrite";
val _ = push_pc "initial_rewrite";
=TEX
Restore the previous theory:
=SML
val _ = open_theory was_theory;
=TEX
\section{END OF THE STRUCTURE}
=SML
end; (* of structure Rewriting *)
open Rewriting;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN


