=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the Rewriting Rules of Inference}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Rewriting Rules of Inference}
\TPPref{DS/FMU/IED/IMP026}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{K.~Blackburn & WIN01\\D.J.~King & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Good version.
\item [Issue 1.3]
Changed $?\_TRAVERSE\_C$ to $?\_MAP\_C$.
Failure 26001 added to appropriate functions.
\item [Issue 1.6]
Addition of tactics.
\item [Issue 1.7]
Addition and canons and basic rewrites.
\item [Issue 1.8]
Fixes to canons and basic rewrites.
\item [Issue 1.9]
Added initialisation of rewrite convs.
\item [Issue 1.10]
Added theorem tactic formulations of rewriting.
\item [Issue 1.11]
Various minor mods as a result of testing canons.
\item [Issue 1.12]
Renamings of functions containing the name atom $simple$,
and renaming of $aconv$.
\item [Issue 1.13]
All rewrite functions now fail when applying an equation produces no change.
\item [Issue 1.14]
Re-implementation to follow ideas of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.15]
Fixed a bug with $simple\_µ\_rewrite\_canon$.
\item [Issue 1.16]
Reacting to issue 1.5 of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.17,1.18]
Added $cs\_¶\_rule$ material.

\item[Issue \SCCSversion, \FormatDate{92/01/20} ] Updated to use new fonts.

\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the rewriting rules of inference.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the rewriting rules of inference.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD026}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{START OF THE SIGNATURE}
=SML
structure Rewriting : Rewriting = struct
=TEX
=SML
val Ûwas_theoryÝ = get_current_theory_name ();
val _ = open_theory "misc";
=TEX
\section{CANONICALISATION FUNCTIONS}
=SML
type ÛCANONÝ = THM -> (THM list);
=TEX
=SML
val Ûid_canonÝ : CANON = (fn thm => [thm]);
=TEX
=SML
val Ûfail_canonÝ : CANON = (fn _ => fail "fail_canon" 26201 []);
=TEX
=SML
fun Ûfail_with_canonÝ 	(area : string) (msg : int)
	(inserters : (unit -> string) list) : CANON = (fn thm =>
	fail area msg inserters
);
=TEX
=SML
fun (lr1 : CANON) ÛTHEN_CANÝ (lr2 : CANON) : CANON = (
	flat o (map lr2 o lr1)
);
=TEX
=SML
fun (lr1 : CANON) ÛORELSE_CANÝ (lr2 : CANON) : CANON = (fn thm =>
	(lr1 thm) handle Fail _ => lr2 thm
);
=TEX
=SML
fun (lr1 : CANON) ÛTHEN_LIST_CANÝ (lrs : CANON list) : CANON = (fn thm =>
	let	fun aux (thm :: morethms) (lr :: morelrs) = (
			lr thm @ aux morethms morelrs
		) | aux [] [] = ([]
		) | aux _ _ = fail "THEN_LIST_CAN" 26204 [];
	in	aux (lr1 thm) lrs
	end	
);
=TEX
=SML
fun ÛEVERY_CANÝ (lrs : CANON list) : CANON = fold (op THEN_CAN) lrs id_canon;
=TEX
=SML
fun ÛFIRST_CANÝ (lrs : CANON list) = (
	fold (op ORELSE_CAN) lrs (fail_with_canon "FIRST_CAN" 26202 [])
);
=TEX
=SML
fun ÛREPEAT_CANÝ (lr : CANON) : CANON = (fn thm =>
	((lr THEN_CAN REPEAT_CAN lr) ORELSE_CAN id_canon) thm
);
=TEX
=SML
fun Û±_rewrite_canonÝ (thm : THM) : THM list = (
	[±_left_elim thm, ±_right_elim thm]
);
=TEX
=SML
fun Ûsimple_³_rewrite_canonÝ (thm : THM) : THM list = (
	[conv_rule (FIRST_C[
		simple_eq_match_conv ³_²_thm,
		simple_³_¶_conv,
		simple_eq_match_conv ³_1_thm])thm]
);
=TEX
=SML
fun Û¤_t_rewrite_canonÝ (thm : THM) : THM list = (
	if is_eq (concl thm)
	then fail "¤_t_rewrite_canon" 26203 []
	else [¤_t_intro thm]
);
=TEX
=SML
fun Ûsimple_µ_rewrite_canonÝ (thm : THM) : THM list = (
	if is_simple_µ (concl thm)
	then [all_simple_µ_elim thm]
	else fail_canon thm
);
=TEX
=SML
fun Ûthm_%alpha%_eqÝ (thm1: THM) (thm2: THM) : bool = (
	let	val (asms1, conc1) = dest_thm thm1;
		val (asms2, conc2) = dest_thm thm2;
	in	%alpha%_eq conc1 conc2
		andalso all asms1 (switch(present (uncurry %alpha%_eq)) asms2)
		andalso all asms2 (switch(present (uncurry %alpha%_eq)) asms1)
	end
);
=TEX
=SML
fun Ûthm_freesÝ (thm: THM) : TERM list = (
	let	val (asms, conc) = dest_thm thm;
	in	(frees conc) cup (list_cup (map frees asms))
	end
);
=TEX
=SML
fun Ûrewrite_gen_canonÝ (fvs : TERM list) (thm : THM) : THM list = (
let	val (asms, conc) = dest_thm thm;
	val avoid = list_cup(fvs :: map frees asms);
in
	[list_simple_µ_intro ((frees conc) drop (fn v => (v mem avoid))) thm]
end);
=TEX
=SML
fun ÛREWRITE_CANÝ (can : CANON) : CANON = (fn (thm : THM) =>
	(can 
	THEN_CAN rewrite_gen_canon (thm_frees thm)) thm
);
=TEX
=SML
val Ûinitial_rw_canonÝ : CANON=
	REWRITE_CAN
	(REPEAT_CAN(FIRST_CAN [
	simple_µ_rewrite_canon,
	±_rewrite_canon,
	simple_³_rewrite_canon,
	¤_t_rewrite_canon]));
=TEX
\section{THE REWRITING RULES OF INFERENCE}
\subsection{Utilities}
=SML
val Ûthm_unionÝ = union (fn (thm1,thm2) => (dest_thm thm1 = dest_thm thm2));

fun ÛfilterÝ (fil : 'a -> bool) ((x :: rest) : 'a list) = (
	if fil x
	then x :: filter fil rest
	else filter fil rest
) | filter _ [] = [];
=TEX
For equational contexts:
=SML
fun Ûcthm_eqn_cxtÝ (canon: CANON) (thm:THM) : EQN_CXT = (
	mapfilter thm_eqn_cxt (canon thm)
);
=TEX
\subsection{prim\_rewrite\_conv}
The core function:
=SML
local
	fun FIRST_CHANGED_C (cv :: rest) tm =
		(CHANGED_C cv ORELSE_C FIRST_CHANGED_C rest) tm
	| FIRST_CHANGED_C [] tm = term_fail "eqn_cxt_conv" 28141 [tm];

	fun net_lookup_conv net : CONV = (fn (tm : TERM) =>
		FIRST_CHANGED_C(net_lookup net tm)tm
	);
in
fun Ûprim_rewrite_convÝ (initial_net : CONV NET) :
	CANON -> 
	(CONV -> CONV) -> 
	EQN_CXT -> 
	THM list -> TERM -> THM = (
(fn (canon : CANON) =>
(fn (traverse : CONV -> CONV) =>
(fn (with_eqn_cxt : EQN_CXT) =>
let	val initial_with_eqn_cxt = list_net_enter 
		with_eqn_cxt initial_net
in
(fn (with_thms : THM list) =>
let	val with_entries = flat (map (cthm_eqn_cxt canon)
		with_thms);
	val initial_with_thms = list_net_enter 
		with_entries initial_with_eqn_cxt;
in
(fn (tm : TERM) =>
let
	val s1 = traverse (net_lookup_conv initial_with_thms) tm
in
	(prof "prim_rewrite_conv";
	s1)
end)
end)
end)
)
)
);
end; (* local fun FIRST_CHANGED_C ... *)
=TEX
=SML
fun Ûprim_rewrite_ruleÝ (initial_net : CONV NET) :
	CANON -> 
	(CONV -> CONV) -> 
	EQN_CXT -> 
	THM list -> THM -> THM = (
let	val c1 = prim_rewrite_conv initial_net;
in
(fn (canon : CANON) =>
let	val c2 = c1 canon;
in
(fn (traverse : CONV -> CONV) =>
let	val c3 = c2 traverse;
in
(fn (with_eqn_cxt : EQN_CXT) =>
let	val c4 = c3 with_eqn_cxt;
in
(fn (with_thms : THM list) =>
let	val c5 = c4 with_thms;
in
(fn (thm : THM) =>
	(prof "prim_rewrite_rule";
	conv_rule c5 thm)
)
end)
end)
end)
end)
end);
=TEX
=SML
fun Ûprim_rewrite_tacÝ (initial_net : CONV NET) :
	CANON -> 
	(CONV -> CONV) -> 
	EQN_CXT -> 
	THM list -> TACTIC = (
let	val c1 = prim_rewrite_conv initial_net;
in
(fn (canon : CANON) =>
let	val c2 = c1 canon;
in
(fn (traverse : CONV -> CONV) =>
let	val c3 = c2 traverse;
in
(fn (with_eqn_cxt : EQN_CXT) =>
let	val c4 = c3 with_eqn_cxt;
in
(fn (with_thms : THM list) =>
let	val c5 = c4 with_thms;
in
(fn (gl : GOAL) =>
	(prof "prim_rewrite_tac";
	conv_tac c5 gl)
)
end)
end)
end)
end)
end);
=TEX
Now the actual inferences.
Rules first:
=SML
fun Ûrewrite_ruleÝ (thms : THM list) : THM -> THM = (
let	val gpc = get_proof_context();
	val r1 = prim_rewrite_rule (get_epc_rw_net gpc)
		(get_epc_rw_canon gpc) TOP_MAP_C [] thms;
in
	(fn (thm : THM) => r1 thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "rewrite_rule" 26001 [])
end);

fun Ûpure_rewrite_ruleÝ (thms : THM list) : THM -> THM = (
let	val rw_canon = get_epc_rw_canon(get_proof_context());
	val r1 = prim_rewrite_rule empty_net rw_canon TOP_MAP_C [] thms;
in
	(fn (thm : THM) => r1 thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_rewrite_rule" 26001 [])
end);

fun Ûonce_rewrite_ruleÝ (thms : THM list) : THM -> THM = (
let	val gpc = get_proof_context();
	val r1 = prim_rewrite_rule (get_epc_rw_net gpc)
		(get_epc_rw_canon gpc) ONCE_MAP_C [] thms;
in
	(fn (thm : THM) => r1 thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_rewrite_rule" 26001 [])
end);

fun Ûpure_once_rewrite_ruleÝ (thms : THM list) : THM -> THM = (
let	val rw_canon = get_epc_rw_canon(get_proof_context());
	val r1 = prim_rewrite_rule empty_net rw_canon ONCE_MAP_C [] thms;
in
	(fn (thm : THM) => r1 thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_rewrite_rule" 26001 [])
end);
=TEX
Now with assumptions:
=SML
fun Ûasm_rewrite_ruleÝ (thms : THM list) : THM -> THM = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_rule rw_net rw_canon TOP_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (hyps thm)) thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "asm_rewrite_rule" 26001 [])
end);

fun Ûpure_asm_rewrite_ruleÝ (thms : THM list) : THM -> THM = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_rule empty_net rw_canon TOP_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (hyps thm)) thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_asm_rewrite_rule" 26001 [])
end);

fun Ûonce_asm_rewrite_ruleÝ (thms : THM list) : THM -> THM = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_rule rw_net rw_canon ONCE_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (hyps thm)) thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_asm_rewrite_rule" 26001 [])
end);

fun Ûpure_once_asm_rewrite_ruleÝ (thms : THM list) : THM -> THM = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_rule empty_net rw_canon ONCE_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (hyps thm)) thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_asm_rewrite_rule" 26001 [])
end);
=TEX

Now we give rules with filtered assumption lists.
=SML
fun Ûfasm_rewrite_ruleÝ (thms : THM list) (fil: TERM -> bool) : THM -> THM = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_rule rw_net rw_canon TOP_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (filter fil (hyps thm))) thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "fasm_rewrite_rule" 26001 [])
end);

fun Ûpure_fasm_rewrite_ruleÝ (thms : THM list) (fil: TERM -> bool) : THM -> THM = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_rule empty_net rw_canon TOP_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (filter fil (hyps thm))) thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_fasm_rewrite_rule" 26001 [])
end);

fun Ûonce_fasm_rewrite_ruleÝ (thms : THM list) (fil: TERM -> bool) : THM -> THM = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_rule rw_net rw_canon ONCE_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (filter fil (hyps thm))) thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_fasm_rewrite_rule" 26001 [])
end);

fun Ûpure_once_fasm_rewrite_ruleÝ (thms : THM list) (fil: TERM -> bool) : THM -> THM = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_rule empty_net rw_canon ONCE_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn (thm : THM) => r1 (map asm_rule (filter fil (hyps thm))) thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_fasm_rewrite_rule" 26001 [])
end);
=TEX
Conversions:
=SML
fun Ûrewrite_convÝ (thms : THM list) : CONV = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_conv rw_net rw_canon TOP_MAP_C [] thms;
in
	(fn (tm : TERM) => r1 tm
	handle complaint =>
	divert complaint "TOP_MAP_C" "rewrite_conv" 26001 [])
end);

fun Ûpure_rewrite_convÝ (thms : THM list) : CONV = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_conv empty_net rw_canon TOP_MAP_C [] thms;
in
	(fn (tm : TERM) => r1 tm
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_rewrite_conv" 26001 [])
end);

fun Ûonce_rewrite_convÝ (thms : THM list) : CONV = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_conv rw_net rw_canon ONCE_MAP_C [] thms;
in
	(fn (tm : TERM) => r1 tm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_rewrite_conv" 26001 [])
end);

fun Ûpure_once_rewrite_convÝ (thms : THM list) : CONV = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_conv empty_net rw_canon ONCE_MAP_C [] thms;
in
	(fn (tm : TERM) => r1 tm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_rewrite_conv" 26001 [])
end);
=TEX
Tactics:
=SML
fun Ûrewrite_tacÝ (thms : THM list) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_tac rw_net rw_canon TOP_MAP_C [] thms;
in
	(fn (gl : GOAL) => r1 gl
	handle complaint =>
	divert complaint "TOP_MAP_C" "rewrite_tac" 26001 [])
end);

fun Ûpure_rewrite_tacÝ (thms : THM list) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_tac empty_net rw_canon TOP_MAP_C [] thms;
in
	(fn (gl : GOAL) => r1 gl
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_rewrite_tac" 26001 [])
end);

fun Ûonce_rewrite_tacÝ (thms : THM list) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_tac rw_net rw_canon ONCE_MAP_C [] thms;
in
	(fn (gl : GOAL) => r1 gl
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_rewrite_tac" 26001 [])
end);

fun Ûpure_once_rewrite_tacÝ (thms : THM list) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_tac empty_net rw_canon ONCE_MAP_C [] thms;
in
	(fn (gl : GOAL) => r1 gl
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_rewrite_tac" 26001 [])
end);
=TEX
Now with assumptions:
=SML
fun Ûasm_rewrite_tacÝ (thms : THM list) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_tac rw_net rw_canon TOP_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule asms) (asms,conc)
	handle complaint =>
	divert complaint "TOP_MAP_C" "asm_rewrite_tac" 26001 [])
end);

fun Ûpure_asm_rewrite_tacÝ (thms : THM list) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_tac empty_net rw_canon TOP_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule asms) (asms,conc)
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_asm_rewrite_tac" 26001 [])
end);

fun Ûonce_asm_rewrite_tacÝ (thms : THM list) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_tac rw_net rw_canon ONCE_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule asms) (asms,conc)
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_asm_rewrite_tac" 26001 [])
end);

fun Ûpure_once_asm_rewrite_tacÝ (thms : THM list) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_tac empty_net rw_canon ONCE_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule asms) (asms,conc)
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_asm_rewrite_tac" 26001 [])
end);
=TEX

Now we give rules with filtered assumption lists.
=SML
fun Ûfasm_rewrite_tacÝ (thms : THM list) (fil: TERM -> bool) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_tac rw_net rw_canon TOP_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule (filter fil asms))(asms,conc)
	handle complaint =>
	divert complaint "TOP_MAP_C" "fasm_rewrite_tac" 26001 [])
end);

fun Ûpure_fasm_rewrite_tacÝ (thms : THM list) (fil: TERM -> bool) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_tac empty_net rw_canon TOP_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule (filter fil asms))(asms,conc)
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_fasm_rewrite_tac" 26001 [])
end);

fun Ûonce_fasm_rewrite_tacÝ (thms : THM list) (fil: TERM -> bool) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val rw_net = get_epc_rw_net gpc;
	val r1 = prim_rewrite_tac rw_net rw_canon ONCE_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule (filter fil asms))(asms,conc)
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_fasm_rewrite_tac" 26001 [])
end);

fun Ûpure_once_fasm_rewrite_tacÝ (thms : THM list) (fil: TERM -> bool) : TACTIC = (
let	val gpc = get_proof_context();
	val rw_canon = get_epc_rw_canon gpc;
	val r1 = prim_rewrite_tac empty_net rw_canon ONCE_MAP_C
		(flat(map (cthm_eqn_cxt rw_canon) thms));
in
	(fn ((asms,conc):GOAL) => r1 (map asm_rule (filter fil asms))(asms,conc)
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_fasm_rewrite_tac" 26001 [])
end);
=TEX
=SML
fun ÛsingletonÝ (x : 'a) : 'a list = [x];

val Ûrewrite_thm_tacÝ : THM -> TACTIC =
				rewrite_tac o singleton;
val Ûpure_rewrite_thm_tacÝ : THM -> TACTIC =
				pure_rewrite_tac o singleton;
val Ûonce_rewrite_thm_tacÝ : THM -> TACTIC =
				once_rewrite_tac o singleton;
val Ûpure_once_rewrite_thm_tacÝ : THM -> TACTIC =
				pure_once_rewrite_tac  o singleton;
val Ûasm_rewrite_thm_tacÝ : THM -> TACTIC =
				asm_rewrite_tac o singleton;
val Ûpure_asm_rewrite_thm_tacÝ : THM -> TACTIC = 
				pure_asm_rewrite_tac o singleton;
val Ûonce_asm_rewrite_thm_tacÝ : THM -> TACTIC =
				once_asm_rewrite_tac o singleton;
val Ûpure_once_asm_rewrite_thm_tacÝ : THM -> TACTIC = 
				pure_once_asm_rewrite_tac o singleton;
val Ûfasm_rewrite_thm_tacÝ : (TERM -> bool) -> THM -> TACTIC =
				switch (fasm_rewrite_tac o singleton);
val Ûpure_fasm_rewrite_thm_tacÝ : (TERM -> bool) -> THM -> TACTIC = 
				switch (pure_fasm_rewrite_tac o singleton);
val Ûonce_fasm_rewrite_thm_tacÝ : (TERM -> bool) -> THM -> TACTIC = 
				switch (once_fasm_rewrite_tac o singleton);
val Ûpure_once_fasm_rewrite_thm_tacÝ : (TERM -> bool) -> THM -> TACTIC =
				switch (pure_once_fasm_rewrite_tac o singleton);
=TEX
\section{BASIC REWRITE THEOREMS}
=SML
val Ûeq_rewrite_thmÝ = save_thm("eq_rewrite_thm", tac_proof(([],
		¬µ x·(x = x) ¤ T®),
	REPEAT strip_tac THEN accept_tac (refl_conv¬x®)));
val Û¤_rewrite_thmÝ = save_thm("¤_rewrite_thm", tac_proof(([],
		¬µ t·((T ¤ t) = t) ± ((t ¤ T) = t) ± ((F ¤ t) = (³ t)) ± (t ¤ F) = (³ t)®),
	REPEAT strip_tac));
val Û³_rewrite_thmÝ = save_thm("³_rewrite_thm", tac_proof(([],
		¬µ t·(³³t) = t ± ((³ T) = F) ± (³ F) = T®),
	REPEAT strip_tac));
val Û±_rewrite_thmÝ = save_thm("±_rewrite_thm", tac_proof(([],
		¬µ t·((T ± t) ¤ t) ± ((t ± T) ¤ t) ±
		(³ (F ± t)) ± (³ (t ± F)) ± (t ± t) = t®),
	REPEAT strip_tac));
val Û²_rewrite_thmÝ = save_thm("²_rewrite_thm", tac_proof(([],
		¬µ t·(T ² t) ± (t ² T) ± ((F ² t) = t) ± ((t ² F) = t) ± (t ² t) = t®),
	REPEAT strip_tac));
val Û´_rewrite_thmÝ = save_thm("´_rewrite_thm", tac_proof(([],
		¬µ t·((T ´ t) = t) ± ((F ´ t) = T) ± ((t ´ T) = T) ± ((t ´ t) = T)
  ± (t ´ F) = (³ t)®),
	REPEAT strip_tac));
val Ûif_rewrite_thmÝ = save_thm("if_rewrite_thm", tac_proof(([],
	¬µ t1 t2·((if T then t1 else t2) = t1) ± (if F then t1 else t2) = t2®),
	REPEAT strip_tac THEN conv_tac (eq_sym_conv THEN_C fun_if_conv)
	THEN REPEAT strip_tac THEN_LIST [
		accept_tac(refl_conv¬t1®), 
		accept_tac(refl_conv¬t2®)]));

val Ûµ_rewrite_thmÝ = save_thm("µ_rewrite_thm", tac_proof(([],
		¬µ t·(µ x·t) = t®),
	REPEAT strip_tac THEN POP_ASM_T (accept_tac o all_simple_µ_elim)));
val Û¶_rewrite_thmÝ = save_thm("¶_rewrite_thm", tac_proof(([],
		¬µ t·(¶ x·t) = t®),
	REPEAT strip_tac THEN simple_¶_tac ¬x® THEN goal_in_asms_tac));
val Û%beta%_rewrite_thmÝ = save_thm("%beta%_rewrite_thm", tac_proof(([],
		¬µ t1:'a; t2:'b·((Ì x·t1)t2) = t1®),
	REPEAT strip_tac THEN accept_tac(simple_%beta%_conv ¬(Ì x:'b·t1:'a)t2®)));
=TEX
\subsection{Rewriting Proof Contexts}
=SML
val Ûinitial_rw_eqn_cxtÝ : EQN_CXT = (flat
	(map (cthm_eqn_cxt initial_rw_canon) [
		eq_rewrite_thm,
		¤_rewrite_thm,
		³_rewrite_thm,
		±_rewrite_thm,
		²_rewrite_thm,
		´_rewrite_thm,
		if_rewrite_thm,
		µ_rewrite_thm,
		¶_rewrite_thm,
		%beta%_rewrite_thm])) @
	[ (¬(Ì x · y) z®, simple_%beta%_conv) ];

val Ûinitial_rewrite_pcÝ : PROOF_CONTEXT = (
	set_pc_rw_canons [simple_µ_rewrite_canon,
		±_rewrite_canon,
		simple_³_rewrite_canon]
	(set_pc_rw_eqn_cxt initial_rw_eqn_cxt
		initial_strip_pc)
);

val Ûinitial_rewrite_epcÝ: EPROOF_CONTEXT = (
	set_epc_rw_canon initial_rw_canon
	(set_epc_rw_net (make_net initial_rw_eqn_cxt)
	initial_strip_epc)
);

val _ = push_proof_context initial_rewrite_epc;
=TEX
Restore the previous theory:
=SML
val _ = open_theory was_theory;
=TEX
\section{EVALUATION OF PROOF CONTEXTS}
=SML
fun Ûevaluate_proof_contextÝ (nm : string)(pc: PROOF_CONTEXT) 
	: EPROOF_CONTEXT = (
	set_epc_name nm
	(set_epc_rw_net(make_net (get_pc_rw_eqn_cxt pc))
	(set_epc_rw_canon(REWRITE_CAN
		(REPEAT_CAN(FIRST_CAN (get_pc_rw_canons pc @
		[¤_t_rewrite_canon]))))
	(set_epc_st_conv (eqn_cxt_conv(get_pc_st_eqn_cxt pc))
	(set_epc_sg_conv (eqn_cxt_conv(get_pc_sg_eqn_cxt pc))
	(set_epc_cs_¶_rule (get_pc_cs_¶_rule pc)
	initial_epc)))))
);
=TEX
\section{END OF THE STRUCTURE}
=SML
end; (* of structure Rewriting *)
open Rewriting;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN


