=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Implementation for the Rewriting Rules of Inference}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Rewriting Rules of Inference}
\TPPref{DS/FMU/IED/IMP026}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{K.~Blackburn & WIN01\\D.J.~King & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Good version.
\item [Issue 1.3]
Changed $?\_TRAVERSE\_C$ to $?\_MAP\_C$.
Failure 26001 added to appropriate functions.
\item [Issue 1.6]
Addition of tactics.
\item [Issue 1.7]
Addition and canons and basic rewrites.
\item [Issue 1.8]
Fixes to canons and basic rewrites.
\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the rewriting rules of inference.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the rewriting rules of inference.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD026},
and also requires those files indicated as preceding it in the 
rel001 makefile.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}
\section{START OF THE SIGNATURE}
=SML
structure Rewriting : Rewriting = struct
=TEX
\section{CANONICALISATION FUNCTIONS}
=TEX
=SML
type ‚CANON· = THM -> (THM list);
=TEX
=SML
val ‚id_canon· : CANON = (fn thm => [thm]);
=TEX
=SML
val ‚fail_canon· : CANON = (fn _ => fail "fail_canon" 26201 []);
=TEX
=SML
fun ‚fail_with_canon· 	(area : string) (msg : int)
	(inserters : (unit -> string) list) : CANON = (
	fail area msg inserters
);
=TEX
=SML
fun (lr1 : CANON) ‚THEN_CAN· (lr2 : CANON) : CANON = (
	flat o (map lr2 o lr1)
);
=TEX
=SML
fun (lr1 : CANON) ‚ORELSE_CAN· (lr2 : CANON) : CANON = (fn thm =>
	(lr1 thm) handle Fail _ => lr2 thm
);
=TEX
=SML
fun (lr1 : CANON) ‚THEN_LIST_CAN· (lrs : CANON list) : CANON = (fn thm =>
	let	fun aux (thm :: morethms) (lr :: morelrs) = (
			lr thm @ aux morethms morelrs
		) | aux [] [] = ([]
		) | aux _ _ = fail "CANON" 26202 [];
	in	aux (lr1 thm) lrs
	end	
);
=TEX
=SML
fun ‚EVERY_CAN· (lrs : CANON list) : CANON = fold (op THEN_CAN) lrs id_canon;
=TEX
=SML
fun ‚FIRST_CAN· (lrs : CANON list) = fold (op ORELSE_CAN) lrs fail_canon;
=TEX
=SML
fun ‚REPEAT_CAN· (lr : CANON) : CANON = (fn thm =>
	((lr THEN_CAN REPEAT_CAN lr) ORELSE_CAN id_canon) thm
);
=TEX
=SML
fun ‚Ä_rewrite_canon· (thm : THM) : THM list = (
	[Ä_left_elim thm, Ä_right_elim thm]
);
=TEX
The following is not right yet:
=SML
fun ‚simple_å_rewrite_canon· (thm : THM) : THM list = (
	[conv_rule (FIRST_C[
		simple_eq_match_conv å_Å_thm,
		simple_å_Ñ_conv,
		simple_eq_match_conv å_1_thm])thm]
);
=TEX
=SML
fun ‚Ç_t_rewrite_canon· (thm : THM) : THM list = (
	if is_eq (concl thm)
	then fail_canon thm
	else [Ç_t_intro thm]
);
=TEX
=SML
fun ‚simple_É_rewrite_canon· (thm : THM) : THM list = (
	if is_É (concl thm)
	then [simple_all_É_elim thm]
	else fail_canon thm
);
=TEX
=SML
fun ‚thm_aconv· (thm1: THM) (thm2: THM) : bool = (
	let	val (asms1, conc1) = dest_thm thm1;
		val (asms2, conc2) = dest_thm thm2;
	in	aconv conc1 conc2
		andalso all asms1 (switch(present (uncurry aconv)) asms2)
		andalso all asms2 (switch(present (uncurry aconv)) asms1)
	end
);
=TEX
=TEX
=SML
fun ‚thm_frees· (thm: THM) : TERM list = (
	let	val (asms, conc) = dest_thm thm;
	in	(frees conc) cup (list_cup (map frees asms))
	end
);
=TEX
=SML
fun ‚rewrite_gen_canon· (fvs : TERM list) (thm : THM) : THM list = (
	[simple_list_É_intro ((thm_frees thm) drop (fn v => (v mem fvs))) thm]
);
=TEX
=SML
fun ‚gen_rewrite_canon· (lrs : CANON list) (thm : THM) (* : THM list *)= (
	(REPEAT_CAN (FIRST_CAN lrs) THEN_CAN rewrite_gen_canon (thm_frees thm)) thm
);
=TEX
\section{THE REWRITING RULES OF INFERENCE}
\subsection{Utilities}
=SML
val ‚thm_union· = union (fn (thm1,thm2) => (dest_thm thm1 = dest_thm thm2));

fun ‚filter· (fil : 'a -> bool) ((x :: rest) : 'a list) = (
	if fil x
	then x :: filter fil rest
	else filter fil rest
) | filter _ [] = [];
=TEX
\subsection{prim\_rewrite\_conv}
The core function:
=SML
local
	open NetTools;

	fun list_enter (tmal: (TERM * 'a)list) (base:'a NET) = (
		fold (uncurry enter) tmal base
	);

	fun mk_net_entry (thm : THM) = (
	let val lhs = fst(dest_eq(snd(simple_strip_É (concl thm))))
	in
		(lhs, simple_eq_match_1_conv thm)
	end);

	fun net_lookup_conv net : CONV = (fn (tm : TERM) =>
	let	val cnvs = lookup net tm;
	in
		FIRST_C cnvs tm
	end);

in
fun ‚prim_rewrite_conv· (other_conv : (TERM * CONV) list) :
	CANON -> 
	THM list -> (CONV -> CONV) -> 
	THM list -> TERM -> THM = (
let 	val net1 = list_enter other_conv empty
in
(fn (canon : CANON) =>
(fn (basis : THM list) =>
let 	val base_entries = mapfilter mk_net_entry (flat (map canon basis));
	val net2 = list_enter base_entries net1;
in
(fn (traverse : CONV -> CONV) => 
(fn (with_thms : THM list) =>
let	val with_entries = mapfilter mk_net_entry (flat (map canon with_thms));
	val net3 = list_enter with_entries net2;
in
(fn (tm : TERM) =>
let
	val s1 = traverse (net_lookup_conv net3) tm
in
	(prof "prim_rewrite_conv";
	s1)
end)
end)
)
end)
)
end);
end; (* local open NetTools ... *)
=TEX
Since we wish to profile rules, we have to mess around a little.
=SML
fun  ‚prim_rewrite_rule·  (other_conv : (TERM * CONV) list) :
	CANON -> 
	THM list -> (CONV -> CONV) -> 
	THM list -> THM -> THM = (
let 	val c1 = prim_rewrite_conv other_conv;
in
(fn (canon : CANON) =>
let 	val c2 = c1 canon;
in
(fn (basis : THM list) =>
let 	val c3 = c2 basis;
in
(fn (traverse : CONV -> CONV) => 
let 	val c4 = c3 traverse;
in
(fn (with_thms : THM list) =>
let	val c5 = c4 with_thms;
in
(fn (thm : THM) =>
let
	val s1 = conv_rule c5 thm
in
	(prof "prim_rewrite_rule";
	s1)
end)
end)
end)
end)
end)
end);
=TEX
=SML
fun  ‚prim_rewrite_tac·  (other_conv : (TERM * CONV) list) :
	CANON -> 
	THM list -> (CONV -> CONV) -> 
	THM list -> TACTIC = (
let 	val c1 = prim_rewrite_conv other_conv;
in
(fn (canon : CANON) =>
let 	val c2 = c1 canon;
in
(fn (basis : THM list) =>
let 	val c3 = c2 basis;
in
(fn (traverse : CONV -> CONV) => 
let 	val c4 = c3 traverse;
in
(fn (with_thms : THM list) =>
let	val c5 = c4 with_thms;
in
	conv_tac c5
end)
end)
end)
end)
end);
=TEX
We now do all the following in the context of
being able to dynamically change the $rewrite\_canon$ and
$basic\_rewrites$. 
=SML
local
val ‚rewrite_canon· : CANON ref = ref id_canon;

val ‚rewrite_canons· : (string * CANON) list ref = ref [];

=TEX
=SML
val ‚basic_rewrites· : (THM list) ref = ref [];

val ‚rewrite_convs· : ((TERM * CONV) list) ref = ref [];
=TEX
We then have a number of variables that cannot be directly
set by the user.
They correspond to the conversions gained from applying the
first three arguments to $prim\_rewrite\_conv$,
and the four kinds of rule/conversion: 
$rewrite$, $once\_rewrite$, $pure\_rewrite$, $pure\_once\_rewrite$.
=SML
val ‚prc1· : (CANON -> THM list -> 
	(CONV -> CONV) -> THM list -> TERM -> THM) ref =
	ref (prim_rewrite_conv (!rewrite_convs));

val ‚prc2· : (THM list -> 
	(CONV -> CONV) -> THM list -> TERM -> THM) ref =
	ref ((!prc1) (!rewrite_canon));

val ‚prc3· : ((CONV -> CONV) -> THM list -> TERM -> THM) ref =
	ref ((!prc2) (!basic_rewrites));

val ‚prc4· : (THM list -> TERM -> THM) ref =
	ref ((!prc3) TOP_MAP_C);

val ‚prc4once· : (THM list -> TERM -> THM) ref =
	ref ((!prc3) ONCE_MAP_C);

val ‚prc4pure· : (THM list -> TERM -> THM) ref =
	ref (prim_rewrite_conv [] (!rewrite_canon) [] TOP_MAP_C);

val ‚prc4pureonce· : (THM list -> TERM -> THM) ref =
	ref (prim_rewrite_conv [] (!rewrite_canon) [] ONCE_MAP_C);

in
=TEX
To set the rewriting parameters:
=SML
fun ‚set_rewrite_convs· (cnvs : (TERM * CONV) list) : unit = (
	rewrite_convs := cnvs;
	prc1 := prim_rewrite_conv (!rewrite_convs);
	prc2 := (!prc1) (!rewrite_canon);
	prc3 := (!prc2) (!basic_rewrites);
	prc4 := (!prc3) TOP_MAP_C;
	prc4once := (!prc3) ONCE_MAP_C;
	prc4pure := prim_rewrite_conv [] (!rewrite_canon) [] TOP_MAP_C;
	prc4pureonce := prim_rewrite_conv [] (!rewrite_canon) [] ONCE_MAP_C;
	()
);
fun ‚get_rewrite_convs· (() : unit) : (TERM * CONV) list = (
	!rewrite_convs
);
=TEX
=SML
fun ‚set_rewrite_canons· (canons : (string * CANON) list) : unit = (
	rewrite_canons := canons;
	rewrite_canon := gen_rewrite_canon (map snd canons);
	prc2 := (!prc1) (!rewrite_canon);
	prc3 := (!prc2) (!basic_rewrites);
	prc4 := (!prc3) TOP_MAP_C;
	prc4once := (!prc3) ONCE_MAP_C;
	prc4pure := prim_rewrite_conv [] (!rewrite_canon) [] TOP_MAP_C;
	prc4pureonce := prim_rewrite_conv [] (!rewrite_canon) [] ONCE_MAP_C;
	()
);
=TEX
=SML
fun ‚get_rewrite_canons· (() : unit) : (string * CANON) list = (
	!rewrite_canons
);
=TEX
=SML
fun ‚set_basic_rewrites· (thms : THM list) : THM list = (
let
	val old = (!basic_rewrites)
in
	(basic_rewrites := thms;
	prc3 := (!prc2) (!basic_rewrites);
	prc4 := (!prc3) TOP_MAP_C;
	prc4once := (!prc3) ONCE_MAP_C;
	prc4pure := prim_rewrite_conv [] (!rewrite_canon) [] TOP_MAP_C;
	prc4pureonce := prim_rewrite_conv [] (!rewrite_canon) [] ONCE_MAP_C;
	old)
end);
=TEX
=SML
fun ‚get_basic_rewrites· (() : unit) : THM list = (
	!basic_rewrites
);
=TEX
Now the actual inferences.
Rules first:
=SML
fun ‚rewrite_rule· (thms : THM list) : THM -> THM = (
let	val c1 = (!prc4) thms;
in
	(fn (thm : THM) => conv_rule c1 thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "rewrite_rule" 26001 [])
end);

fun ‚pure_rewrite_rule· (thms : THM list) : THM -> THM = (
let	val c1 = (!prc4pure) thms;
in
	(fn (thm : THM) => conv_rule c1 thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_rewrite_rule" 26001 [])
end);

fun ‚once_rewrite_rule· (thms : THM list) : THM -> THM = (
let	val c1 = (!prc4once) thms;
in
	(fn (thm : THM) => conv_rule c1 thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_rewrite_rule" 26001 [])
end);

fun ‚pure_once_rewrite_rule· (thms : THM list) : THM -> THM = (
let	val c1 = (!prc4pureonce) thms;
in
	(fn (thm : THM) => conv_rule c1 thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_rewrite_rule" 26001 [])
end);
=TEX
Now with assumptions:
=SML
fun ‚asm_rewrite_rule· (thms : THM list) (thm : THM) : THM = (
let	val c1 = (!prc4) (thm_union thms (map asm_rule (hyps thm)));
in
	conv_rule c1 thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "asm_rewrite_rule" 26001 []
end);

fun ‚pure_asm_rewrite_rule· (thms : THM list) (thm : THM) : THM = (
let	val c1 = (!prc4pure) (thm_union thms (map asm_rule (hyps thm)));
in
	conv_rule c1 thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_asm_rewrite_rule" 26001 []
end);

fun ‚once_asm_rewrite_rule· (thms : THM list) (thm : THM) : THM = (
let	val c1 = (!prc4once) (thm_union thms (map asm_rule (hyps thm)));
in
	conv_rule c1 thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_asm_rewrite_rule" 26001 []
end);

fun ‚pure_once_asm_rewrite_rule· (thms : THM list) (thm : THM) : THM = (
let	val c1 = (!prc4pureonce) (thm_union thms (map asm_rule (hyps thm)));
in
	conv_rule c1 thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_asm_rewrite_rule" 26001 []
end);
=TEX
Now we give rules with filtered assumption lists.
We fail to maximise partial evaluation because we need to
know all the theorems, including those generated from the theorem being rewritten, as the last argument to
$prim\_rewrite\_conv$.
We could partially evaluate given the theorem list alone
if we bypassed $prim\_rewrite\_conv$ in some manner.
=SML
fun ‚fasm_rewrite_rule· (thms : THM list) (fil : TERM -> bool)  (thm : THM) : THM = (
let	val c1 = (!prc4) (thm_union thms (map asm_rule 
		(filter fil (hyps thm))));
in
	conv_rule c1 thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "fasm_rewrite_rule" 26001 []
end);

fun ‚pure_fasm_rewrite_rule· (thms : THM list) (fil : TERM -> bool) (thm : THM) : THM = (
let	val c1 = (!prc4pure) (thm_union thms (map asm_rule 
		(filter fil (hyps thm))));
in
	conv_rule c1 thm
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_fasm_rewrite_rule" 26001 []
end);

fun ‚once_fasm_rewrite_rule· (thms : THM list) (fil : TERM -> bool) (thm : THM) : THM = (
let	val c1 = (!prc4once) (thm_union thms (map asm_rule 
		(filter fil (hyps thm))));
in
	conv_rule c1 thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_fasm_rewrite_rule" 26001 []
end);

fun ‚pure_once_fasm_rewrite_rule· (thms : THM list) 
	(fil : TERM -> bool) (thm : THM) : THM = (
let	val c1 = (!prc4pureonce) (thm_union thms (map asm_rule 
		(filter fil (hyps thm))));
in
	conv_rule c1 thm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_fasm_rewrite_rule" 26001 []
end);
=TEX
Conversions:
=SML
fun ‚rewrite_conv· (thms : THM list) : CONV = (
let	val c = (!prc4) thms
in
	(fn (tm : TERM) => c tm
	handle complaint =>
	divert complaint "TOP_MAP_C" "rewrite_conv" 26001 [])
end);

fun ‚pure_rewrite_conv· (thms : THM list) : CONV = (
let	val c = (!prc4pure) thms
in
	(fn (tm : TERM) => c tm
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_rewrite_conv" 26001 [])
end);

fun ‚once_rewrite_conv· (thms : THM list) : CONV = (
let	val c = (!prc4once) thms
in
	(fn (tm : TERM) => c tm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_rewrite_conv" 26001 [])
end);

fun ‚pure_once_rewrite_conv· (thms : THM list) : CONV = (
let	val c = (!prc4pureonce) thms
in
	(fn (tm : TERM) => c tm
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_rewrite_conv" 26001 [])
end);
=TEX
Tactics:
=SML
fun ‚rewrite_tac· (thms : THM list) : TACTIC = (
let	val c1 = (!prc4) thms;
in
	(fn (gl : GOAL) => conv_tac c1 gl
	handle complaint =>
	divert complaint "TOP_MAP_C" "rewrite_tac" 26001 [])
end);

fun ‚pure_rewrite_tac· (thms : THM list) : TACTIC = (
let	val c1 = (!prc4pure) thms;
in
	(fn (gl : GOAL) => conv_tac c1 gl
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_rewrite_tac" 26001 [])
end);

fun ‚once_rewrite_tac· (thms : THM list) : TACTIC = (
let	val c1 = (!prc4once) thms;
in
	(fn (gl : GOAL) => conv_tac c1 gl
	handle complaint =>
	divert complaint "ONCE_MAP_C" "once_rewrite_tac" 26001 [])
end);

fun ‚pure_once_rewrite_tac· (thms : THM list) : TACTIC = (
let	val c1 = (!prc4pureonce) thms;
in
	(fn (gl : GOAL) => conv_tac c1 gl
	handle complaint =>
	divert complaint "ONCE_MAP_C" "pure_once_rewrite_tac" 26001 [])
end);

fun ‚asm_rewrite_tac· (thms : THM list) : TACTIC = (fn gl as (asms, _):GOAL =>
let	val c1 = (!prc4) (thm_union thms (map asm_rule asms));
in
	conv_tac c1 gl
	handle complaint =>
	divert complaint "TOP_MAP_C" "asm_rewrite_tac" 26001 []
end);

fun ‚pure_asm_rewrite_tac· (thms : THM list) : TACTIC = (fn gl as (asms, _):GOAL =>
let	val c1 = (!prc4pure) (thm_union thms (map asm_rule asms));
in
	conv_tac c1 gl
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_asm_rewrite_tac" 26001 []
end);


fun ‚once_asm_rewrite_tac· (thms : THM list) : TACTIC = (fn gl as (asms, _):GOAL =>
let	val c1 = (!prc4once) (thm_union thms (map asm_rule asms));
in
	conv_tac c1 gl
	handle complaint =>
	divert complaint "TOP_MAP_C" "once_asm_rewrite_tac" 26001 []
end);


fun ‚pure_once_asm_rewrite_tac· (thms : THM list) : TACTIC = (fn gl as (asms, _):GOAL =>
let	val c1 = (!prc4pureonce) (thm_union thms (map asm_rule asms));
in
	conv_tac c1 gl
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_once_asm_rewrite_tac" 26001 []
end);


fun ‚fasm_rewrite_tac· (thms : THM list) (fil : TERM -> bool) : TACTIC = (fn gl as (asms, _):GOAL =>
let	val c1 = (!prc4) (thm_union thms (map asm_rule (filter fil asms)));
in
	conv_tac c1 gl
	handle complaint =>
	divert complaint "TOP_MAP_C" "fasm_rewrite_tac" 26001 []
end);

fun ‚pure_fasm_rewrite_tac· (thms : THM list) (fil : TERM -> bool) : TACTIC = (fn gl as (asms, _):GOAL =>
let	val c1 = (!prc4pure) (thm_union thms (map asm_rule (filter fil asms)));
in
	conv_tac c1 gl
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_fasm_rewrite_tac" 26001 []
end);

fun ‚once_fasm_rewrite_tac· (thms : THM list) (fil : TERM -> bool) : TACTIC = (fn gl as (asms, _):GOAL =>
let	val c1 = (!prc4once) (thm_union thms (map asm_rule (filter fil asms)));
in
	conv_tac c1 gl
	handle complaint =>
	divert complaint "TOP_MAP_C" "once_fasm_rewrite_tac" 26001 []
end);

fun ‚pure_once_fasm_rewrite_tac· (thms : THM list) (fil : TERM -> bool) : TACTIC = (fn gl as (asms, _):GOAL =>
let	val c1 = (!prc4pureonce) (thm_union thms (map asm_rule (filter fil asms)));
in
	conv_tac c1 gl
	handle complaint =>
	divert complaint "TOP_MAP_C" "pure_once_fasm_rewrite_tac" 26001 []
end);
=TEX
=SML
end; (* of local val basic_ ... in ... end *)
=TEX
\section{BASIC REWRITE THEOREMS}
=SML
val ‚eq_rewrite_thm· = save_thm("eq_rewrite_thm", tac_proof(([],
		ªÉ xé(x = x) Ç Tº),
	REPEAT strip_tac THEN accept_tac (refl_convªxº)));
val ‚Ç_rewrite_thm· = save_thm("Ç_rewrite_thm", tac_proof(([],
		ªÉ té((T Ç t) = t) Ä ((t Ç T) = t) Ä ((F Ç t) = (å t)) Ä (t Ç F) = (å t)º),
	REPEAT strip_tac));
val ‚å_rewrite_thm· = save_thm("å_rewrite_thm", tac_proof(([],
		ªÉ té(ååt) = t Ä ((å T) = F) Ä (å F) = Tº),
	REPEAT strip_tac));
val ‚Ä_rewrite_thm· = save_thm("Ä_rewrite_thm", tac_proof(([],
		ªÉ té((T Ä t) Ç t) Ä ((t Ä T) Ç t) Ä
		(å (F Ä t)) Ä (å (t Ä F)) Ä (t Ä t) = tº),
	REPEAT strip_tac));
val ‚Å_rewrite_thm· = save_thm("Å_rewrite_thm", tac_proof(([],
		ªÉ té(T Å t) Ä (t Å T) Ä ((F Å t) = t) Ä ((t Å F) = t) Ä (t Å t) = tº),
	REPEAT strip_tac));
val ‚ä_rewrite_thm· = save_thm("ä_rewrite_thm", tac_proof(([],
		ªÉ té((T ä t) = t) Ä ((F ä t) = T) Ä ((t ä T) = T) Ä ((t ä t) = T)
  Ä (t ä F) = (å t)º),
	REPEAT strip_tac));
val ‚if_rewrite_thm· = save_thm("if_rewrite_thm", tac_proof(([],
		ªÉ t1 t2é((if T then t1 else t2) = t1) Ä (if F then t1 else t2) = t2º),
	REPEAT strip_tac THEN conv_tac (eq_sym_conv THEN_C fun_if_conv)
	THEN REPEAT strip_tac THEN_LIST [accept_tac(refl_convªt1º), accept_tac(refl_convªt2º)]));

val ‚É_rewrite_thm· = save_thm("É_rewrite_thm", tac_proof(([],
		ªÉ té(É xét) = tº),
	REPEAT strip_tac THEN POP_ASM_T (accept_tac o simple_all_É_elim)));
val ‚Ñ_rewrite_thm· = save_thm("Ñ_rewrite_thm", tac_proof(([],
		ªÉ té(Ñ xét) = tº),
	REPEAT strip_tac THEN simple_Ñ_tac ªxº THEN goal_in_asms_tac));
val ‚%beta%_rewrite_thm· = save_thm("%beta%_rewrite_thm", tac_proof(([],
		ªÉ t1:'a; t2:'bé((ç xét1)t2) = t1º),
	REPEAT strip_tac THEN accept_tac(simple_%beta%_conv ª(ç x:'bét1:'a)t2º)));
=TEX
=SML
val ‚side_effect· = set_basic_rewrites [
		eq_rewrite_thm,
		Ç_rewrite_thm,
		å_rewrite_thm,
		Ä_rewrite_thm,
		Å_rewrite_thm,
		ä_rewrite_thm,
		if_rewrite_thm,
		É_rewrite_thm,
		Ñ_rewrite_thm,
		%beta%_rewrite_thm];
=TEX
=SML
val ‚side_effect· = set_rewrite_canons [
	("Ä_rewrite_canon",		Ä_rewrite_canon),
	("simple_å_rewrite_canon",	simple_å_rewrite_canon),
	("simple_É_rewrite_canon",	simple_É_rewrite_canon),
	("Ç_t_rewrite_canon",		Ç_t_rewrite_canon)
];
=TEX
=SML
val ‚side_effect· = set_rewrite_convs[(ª(çxéy)zº, simple_%beta%_conv)];
=TEX
\section{END OF THE STRUCTURE}
=SML
end; (* of structure Rewriting *)
open Rewriting;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN
Statistics:

open Sort;
fun comp_stats (s1,n1) (s2,n2) = (
	if n1 = n2
	then stringorder s1 s2
	else (n1 - n2)
);

sort comp_stats (get_stats ());
