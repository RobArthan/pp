=TEX
% wrk044.doc   %Z% $Date: 1993/01/19 15:16:58 $ $Revision: 2.2 $ $RCSfile: wrk044.doc,v $
% COPYRIGHT (c) International Computers Limited, 1992
=IGN
%
% The material in this document may be loaded into the ProofPower-HOL system
% using the following UNIX commands:
docsml wrk044			# strip the proof script out into wrk044.sml
hol				# run ProofPower-HOL
use_file"wrk044";		(* load file wrk044.sml into ProofPower-HOL *)
%
% Useful ProofPower-HOL commands:
%	
open_theory"fin_thms";		(* open the theory built by this file *)
print_theory"fin_thms";		(* list the theory on the screen *)
output_theory{theory="fin_thms", out_file="wrk044.thl.doc"};
				(* list the theory into a file in .doc format *)
%
% Useful UNIX commands:
doctex wrk044		# convert the document into LaTeX format (in wrk044.tex)
doctex wrk044.thl	# convert the theory listing into LaTeX \input format
texdvi wrk044		# run LaTeX on the document (giving wrk044.dvi)
docsml wrk044		# strip the proof script out into wrk044.sml
=TEX
=TEX
%
\documentclass[a4paper,11pt]{article}
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{latexsym}
\ftlinepenalty=9999
\makeindex
\def\Title{ Theorems on Finiteness \\ (Draft) }
\def\Reference{ PPDOC/WRK044 }
\def\RCSversion{ $Revision:$ }
\def\Version{\RCSversion}
\def\Date{29th September 1992; This revision \FormatDate{$Date:$}}
\def\Author{ Rob Arthan }
\def\EMail{ rda@lemma-one.com }
\def\Abstract{\centering{\bf Abstract}\par
This paper supplies proofs of some theorems about finite sets.
It is part of work in progress on \ProductHOL. }
\makeindex
\begin{document}
\FrontPage
% \parskip=0.5\parskip
\section*{CONTENTS}
\tableofcontents
\newpage
\section{INTRODUCTION}
This document contains some proofs which are mainly
concerned with finiteness as defined in
the theory $fin\_set$ supplied as part of the \ProductHOL\ system.
Some miscellaneous material about certain other concepts defined in
the ancestors of $fin\_set$ is also provided.

The material displays several aspects of the use of \ProductHOL.,
including:
\begin{enumerate}
\item
Proof of an induction theorem and its use to produce an induction tactic.
\item
Discharge of a consistency proof obligation.
\item
Proof of a theorem for use as a rewrite rule to ``compute'' values of
a function in certain useful special cases
(namely the minimum function $\mathit{Min}$ applied to set displays whose elements
are numeric constants).
\end{enumerate}

Note that the proofs are typically packaged in the following style:

=GFT Example
val €blah_blah_thm› = save_thm("fin_set_induction_thm", (
push_goal([], (* Statement of theorem *));
(* Rest of subgoal package command script goes here *)
pop_thm()
));
=TEX
To experiment with such a proof interactively simply omit the first line.
I.e. cut-and-paste the $push\_goal$ command into the \ProductHOL\ window
followed by the subgoal package commands (which are almost invariably
just tactic applications of the form $a(\ldots)$) modifying these
as you wish.
To finish the proof off either cut-and-paste the $pop\_thm$ line
followed by a semi-colon (if you have completed the proof) or
abandon the proof attempt with $drop\_main\_goal$.

=TEX
\section{PREAMBLE}
=SML
open_theory"fin_set";
new_theory"fin_thms";
set_pc"hol";
=TEX
\section{THE THEOREMS}
=TEX
\subsection{Induction over Finite Sets}
=SML
val €fin_set_induction_thm› = save_thm("fin_set_induction_thm", (
push_goal([], ¨
		µP∑	P {} ± (µa x∑a ç Finite ± P a ± ≥x ç a ¥ P({x} ¿ a))
		¥ 	µa∑a ç Finite ¥ P a
Æ);
a(REPEAT strip_tac);
a(asm_ante_tac¨a ç FiniteÆ);
a(rewrite_tac[get_spec¨FiniteÆ]);
a(REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¨{b | b ç Finite ± P b}Æ);
(* *** Goal "1" *** *)
a(swap_asm_concl_tac ¨≥ {} ç FiniteÆ);
a(rewrite_tac[get_spec¨FiniteÆ]);
a(PC_T "hol1" (REPEAT strip_tac));
(* *** Goal "2" *** *)
a(swap_asm_concl_tac ¨a' ç FiniteÆ);
a(asm_ante_tac ¨≥ {x} ¿ a' ç FiniteÆ);
a(rewrite_tac[get_spec¨FiniteÆ]);
a(PC_T "hol1" (contr_tac));
a(spec_nth_asm_tac 1 ¨sÆ);
(* *** Goal "2.1" *** *)
a(list_spec_nth_asm_tac 5 [¨a''Æ, ¨x'Æ]);
(* *** Goal "2.2" *** *)
a(list_spec_nth_asm_tac 4 [¨a'Æ, ¨xÆ]);
(* *** Goal "3" *** *)
a(swap_asm_concl_tac ¨≥ P ({x} ¿ a')Æ);
a(cases_tac¨x ç a'Æ);
(* *** Goal "3.1" *** *)
a(LEMMA_T¨{x} ¿ a' = a'Æ asm_rewrite_thm_tac);
a(PC_T "hol1" (REPEAT strip_tac));
a(asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(list_spec_nth_asm_tac 6 [¨a'Æ, ¨xÆ]);
pop_thm()
));
=TEX
=SML
val €fin_set_induction_tac› : TACTIC =
		gen_induction_tac1 fin_set_induction_thm;
=TEX
\subsection{Consistency of $\mathit{Min}$}
=TEX
=SML
val _ = save_consistency_thm¨MinÆ(
push_consistency_goal¨MinÆ;
a(conv_tac prove_∂_conv THEN strip_tac);
a(strip_asm_tac (rewrite_rule[](µ_elim¨(Ãj∑j ç a')Æº_well_order_thm))
	THEN ∂_tac ¨m:ÓÆ THEN asm_prove_tac []);
a(strip_asm_tac(list_µ_elim[¨mÆ, ¨m'Æ] º_antisym_thm) THEN asm_prove_tac[]);
pop_thm()
);
=TEX
=SML
val €min_thm› = save_thm("min_thm", (
push_goal([], ¨µm a∑m ç a ¥ Min a ç a ± Min a º mÆ);
a(REPEAT µ_tac THEN ¥_tac);
a(strip_asm_tac (rewrite_rule[](µ_elim¨(Ãj∑j ç a)Æº_well_order_thm))
	THEN asm_prove_tac[]);
(* *** Goal "1" *** *)
a(strip_asm_tac (list_µ_elim[¨m'Æ, ¨aÆ](get_spec¨MinÆ)));
(* *** Goal "1.1" *** *)
a(asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(strip_asm_tac (list_µ_elim[¨m'Æ, ¨aÆ](get_spec¨MinÆ)));
(* *** Goal "2.1" *** *)
a(asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[] THEN asm_prove_tac[]);
pop_thm()
));
=TEX
\subsection{Theorems about $\mathit{Min}$}
=SML
val €min_clause1› = (
push_goal([], ¨µm∑Min {m} = mÆ);
a(REPEAT strip_tac);
a(strip_asm_tac (list_µ_elim[¨mÆ, ¨{m}Æ](get_spec¨MinÆ)));
a(swap_asm_concl_tac¨≥m º iÆ THEN asm_rewrite_tac[º_clauses]);
pop_thm()
);
=TEX
=SML
val €min_clause2› = (
push_goal([], ¨µm n∑Min {m; n} = if m º n then m else nÆ);
a(REPEAT strip_tac);
a(strip_asm_tac (list_µ_elim[¨if m º n then m else nÆ, ¨{m; n}Æ](get_spec¨MinÆ)));
(* *** Goal "1" *** *)
a(all_asm_ante_tac THEN cases_tac¨m º nÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(swap_asm_concl_tac¨≥(if m º n then m else n) º iÆ THEN asm_rewrite_tac[]);
a(cases_tac¨m º nÆ THEN asm_rewrite_tac[º_clauses]);
a(strip_asm_tac(list_µ_elim[¨mÆ, ¨nÆ]º_cases_thm));
(* *** Goal "3" *** *)
a(swap_asm_concl_tac¨≥(if m º n then m else n) º iÆ THEN asm_rewrite_tac[]);
a(cases_tac¨m º nÆ THEN asm_rewrite_tac[º_clauses]);
pop_thm()
);
=TEX
=SML
val €min_clause3› = (
push_goal([], ¨µm a∑Min ({m} ¿ a) = if a = {} then m else Min{m; Min a}Æ);
a(REPEAT strip_tac);
a(cases_tac¨a = {}Æ THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(rewrite_tac[min_clause1]);
(* *** Goal "2" *** *)
a(all_asm_ante_tac THEN (PC_T"sets_ext" strip_tac));
a(all_asm_ante_tac THEN strip_tac);
a(strip_asm_tac (list_µ_elim[¨xÆ, ¨aÆ]min_thm));
a(lemma_tac¨µ i∑ i ç {m} ¿ a ¥ Min {m; Min a} º iÆ);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac THEN rewrite_tac[min_clause2]);
(* *** Goal "2.1.1" *** *)
a(cases_tac¨m º Min aÆ THEN asm_rewrite_tac[º_clauses]);
a(strip_asm_tac (list_µ_elim[¨mÆ, ¨Min aÆ]º_cases_thm));
(* *** Goal "2.1.2" *** *)
a(strip_asm_tac (list_µ_elim[¨iÆ, ¨aÆ]min_thm));
a(cases_tac ¨m º Min aÆ THEN asm_rewrite_tac[]);
a(fc_tac [º_trans_thm] THEN asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(LEMMA_T ¨Min {m; Min a} ç {m} ¿ aÆ asm_tac);
(* *** Goal "2.2.1" *** *)
a(cases_tac¨m º Min aÆ THEN asm_rewrite_tac[min_clause2] THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(ante_tac (list_µ_elim[¨Min {m; Min a}Æ, ¨({m} ¿ a)Æ](get_spec¨MinÆ))
	THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val €min_clauses› = save_thm("min_clauses",
	list_±_intro[min_clause1, min_clause2, min_clause3]);
=TEX
\subsection{Relationship between $Finite$ and $Elems$}
=SML
val €fin_set_thm1› = save_thm("fin_set_thm1", (
push_goal([], ¨µa∑ a ç Finite ¥ ∂list∑a = Elems list ± list ç DistinctÆ);
a(strip_tac);
a fin_set_induction_tac;
(* *** Goal "1" *** *)
a(∂_tac ¨[]Æ THEN rewrite_tac(map get_spec[¨ElemsÆ, ¨DistinctÆ]));
(* *** Goal "2" *** *)
a(∂_tac ¨Cons x listÆ THEN asm_rewrite_tac(map get_spec[¨ElemsÆ, ¨DistinctÆ]));
a(asm_ante_tac ¨≥ x ç aÆ THEN asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val €elems_thm1› = save_thm("elems_thm1", (
push_goal([], ¨µlist∑ Elems list = {} § list = []Æ);
a(strip_tac THEN strip_asm_tac(µ_elim¨list:'a LISTÆ list_cases_thm));
(* *** Goal "1" *** *)
a(asm_rewrite_tac[get_spec¨ElemsÆ]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[get_spec¨ElemsÆ]);
a(PC_T "sets_ext" (REPEAT strip_tac));
a(REPEAT strip_tac);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
pop_thm()
));
=TEX
=SML
val €elems_thm2› = save_thm("elems_thm2", (
push_goal([], ¨(µlist∑ Elems list = {} § list = [])
	± (µlist∑ {} = Elems list § list = [])Æ);
a(rewrite_tac[elems_thm1]);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) elems_thm1]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val €elems_thm3› = save_thm("elems_thm3", (
push_goal([], ¨µlist1 list2∑ Elems(list1 @ list2) = Elems list1 ¿ Elems list2Æ);
a(REPEAT strip_tac);
a(list_induction_tac¨list1Æ);
(* *** Goal "1" *** *)
a(rewrite_tac(map get_spec[¨AppendÆ, ¨ElemsÆ]));
(* *** Goal "2" *** *)
a(asm_rewrite_tac(map get_spec[¨AppendÆ, ¨ElemsÆ]));
a(PC_T"hol1" (REPEAT strip_tac));
pop_thm()
));
=TEX
=SML
val €length_thm› = save_thm("length_thm", (
push_goal([], ¨µlist1 list2∑ Length (list1 @ list2) = Length list1 + Length list2Æ);
a(REPEAT strip_tac);
a(list_induction_tac¨list1Æ THEN rewrite_tac(map get_spec[¨LengthÆ, ¨AppendÆ]));
a(asm_rewrite_tac[plus_assoc_thm]);
pop_thm()
));
=TEX
=SML
val €˘_thm1› = save_thm("˘_thm1", (
push_goal([], ¨µlist a∑Elems(list ˘ a) = Elems list ° aÆ);
a(REPEAT strip_tac);
a(list_induction_tac¨listÆ THEN rewrite_tac(map get_spec[¨ElemsÆ, ¨$˘Æ]));
a(strip_tac THEN cases_tac ¨x ç aÆ THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[get_spec¨ElemsÆ]);
a(PC_T "hol1" (REPEAT strip_tac));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(PC_T "hol1" (REPEAT strip_tac));
a(asm_ante_tac¨x' ç aÆ THEN asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val €˘_thm2› = save_thm("˘_thm2", (
push_goal([], ¨µlist; a:'a SET∑Length((list ˘ a) @ (list ˘ ~a)) = Length listÆ);
a(REPEAT strip_tac);
a(list_induction_tac¨listÆ THEN rewrite_tac(map get_spec[¨LengthÆ, ¨$˘Æ, ¨AppendÆ]));
a(strip_tac THEN cases_tac ¨x ç aÆ THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(asm_rewrite_tac(map get_spec[¨LengthÆ, ¨$˘Æ, ¨AppendÆ]));
(* *** Goal "2" *** *)
a(all_asm_ante_tac THEN rewrite_tac[length_thm] THEN REPEAT strip_tac);
a(asm_rewrite_tac[get_spec¨LengthÆ, µ_elim¨1Æplus_order_thm]);
pop_thm()
));
=TEX
=SML
val €˘_thm3› = save_thm("˘_thm3", (
push_goal([], ¨µlist a∑Elems list Ä a ¥ list ˘ a = list Æ);
a(strip_tac);
a(list_induction_tac¨listÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[get_spec¨$˘Æ]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac(map get_spec[¨$˘Æ, ¨ElemsÆ]));
a(REPEAT strip_tac);
a(lemma_tac ¨x ç aÆ);
(* *** Goal "2.1" *** *)
a(POP_ASM_T ante_tac);
a(PC_T"hol1"(REPEAT strip_tac));
a(spec_nth_asm_tac 1 ¨xÆ);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[]);
a(lemma_tac ¨Elems list Ä aÆ);
(* *** Goal "2.2.1" *** *)
a(asm_ante_tac¨{x} ¿ Elems list Ä aÆ THEN PC_T"hol1"(REPEAT strip_tac));
a(spec_nth_asm_tac 2 ¨x'Æ);
(* *** Goal "2.2.2" *** *)
a(spec_nth_asm_tac 4 ¨aÆ);
pop_thm()
));
=TEX
=SML
val €˘_thm4› = save_thm("˘_thm4", (
push_goal([], ¨µlist; x:'a∑x ç Elems list ¥ Length(list ˘ ~{x}) < Length list Æ);
a(strip_tac);
a(list_induction_tac¨listÆ THEN asm_rewrite_tac[get_spec¨ElemsÆ]);
(* *** Goal "" *** *)
a(asm_rewrite_tac(map get_spec[¨$˘Æ, ¨LengthÆ]) THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[get_spec¨LengthÆ] THEN cases_tac¨x ç Elems listÆ);
(* *** Goal "1.1" *** *)
a(spec_nth_asm_tac 3 ¨xÆ);
a(strip_asm_tac(list_µ_elim
	[¨Length (list ˘ ~ {x})Æ, ¨Length listÆ, ¨Length list + 1Æ]
	less_trans_thm));
a(lemma_tac¨Elems list Ä ~{x}Æ);
(* *** Goal "1.2.1" *** *)
a(PC_T"hol1"(REPEAT strip_tac THEN rewrite_tac[]));
a(swap_asm_concl_tac ¨x'' ç Elems listÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2" *** *)
a(strip_asm_tac(list_µ_elim[¨listÆ, ¨~{x}Æ]˘_thm3));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 2 (strip_asm_tac o µ_elim ¨x'Æ));
a(cases_tac¨x = x'Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a(strip_asm_tac(list_µ_elim
	[¨Length (list ˘ ~ {x'})Æ, ¨Length listÆ, ¨Length list + 1Æ]
	less_trans_thm));
(* *** Goal "2.2" *** *)
a(rewrite_tac[get_spec¨LengthÆ] THEN REPEAT strip_tac);
pop_thm()
));
=TEX
=SML
val €distinct_thm1› = save_thm("distinct_thm1",  (
push_goal([], ¨µlist1 list2∑
		list1 ç Distinct ± Elems list1 = Elems list2
	¥	Length list1 º Length list2Æ);
a(strip_tac);
a(list_induction_tac¨list1Æ);
(* *** Goal "1" *** *)
a(rewrite_tac(elems_thm2 :: map get_spec[¨ElemsÆ, ¨DistinctÆ, ¨LengthÆ]));
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(lemma_tac ¨Length ([x] @ (list2 ˘ ~{x})) º Length list2Æ);
(* *** Goal "2.1" *** *)
a(rewrite_tac[get_spec¨LengthÆ, length_thm]);
a(cases_tac¨x ç Elems list2Æ);
(* *** Goal "2.1.1" *** *)
a(strip_asm_tac(list_µ_elim[¨list2Æ, ¨xÆ]˘_thm4));
a(asm_ante_tac¨Length (list2 ˘ ~ {x}) < Length list2Æ THEN
	rewrite_tac[µ_elim¨1Æplus_order_thm, less_def]);
(* *** Goal "2.1.2" *** *)
a(lemma_tac¨Elems list2 Ä ~{x}Æ);
(* *** Goal "2.1.2.1" *** *)
a(PC_T"hol1"(REPEAT strip_tac THEN rewrite_tac[]));
a(swap_asm_concl_tac¨x' ç Elems list2Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2.2" *** *)
a(lemma_tac¨x ç Elems list2Æ);
a(asm_ante_tac ¨Elems (Cons x list1) = Elems list2Æ);
a(rewrite_tac[get_spec¨ElemsÆ]);
a(PC_T"hol1"(REPEAT strip_tac));
a(spec_nth_asm_tac 1¨xÆ);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 3 (strip_asm_tac o rewrite_rule[get_spec¨DistinctÆ]));
a(lemma_tac¨Elems list1 = Elems (list2 ˘ ~ {x})Æ);
(* *** Goal "2.2.2" *** *)
a(rewrite_tac[˘_thm1]);
a(DROP_NTH_ASM_T 4 (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[get_spec¨ElemsÆ]);
a(PC_T"hol1"(REPEAT strip_tac));
(* *** Goal "2.2.1.1" *** *)
a(PC_T"hol1"(rewrite_tac[]));
a(swap_asm_concl_tac¨x' ç Elems list1Æ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.1.2" *** *)
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[]));
(* *** Goal "2.2.2" *** *)
a(DROP_NTH_ASM_T 6 (strip_asm_tac o µ_elim¨list2 ˘ ~ {x}Æ));
a(rewrite_tac(map get_spec[¨LengthÆ]));
a(swap_nth_asm_concl_tac 5 THEN rewrite_tac(map get_spec[¨$AppendÆ, ¨LengthÆ]));
a(lemma_tac¨x ç Elems list2Æ);
(* *** Goal "2.2.2.1" *** *)
a(GET_NTH_ASM_T 6 (fn th => rewrite_tac[eq_sym_rule th, get_spec¨ElemsÆ]));
a(PC_T"hol1" (REPEAT strip_tac));
(* *** Goal "2.2.2.2" *** *)
a(strip_asm_tac(list_µ_elim[¨list2Æ, ¨xÆ]˘_thm4));
a(swap_nth_asm_concl_tac 1);
a(rewrite_tac[get_spec¨$<Æ]);
a(strip_asm_tac(list_µ_elim
	[¨Length list1 + 1Æ, ¨Length (list2 ˘ ~ {x}) + 1Æ, ¨Length list2Æ]
	º_trans_thm));
pop_thm()
));
=TEX
=SML
val €size_thm1› = save_thm("size_thm1", (
push_goal([], ¨Size {} = 0Æ);
a(rewrite_tac[get_spec¨SizeÆ, elems_thm1]);
a(conv_tac (ONCE_MAP_C prove_∂_conv));
a(rewrite_tac[get_spec¨LengthÆ]);
a(lemma_tac¨{i|0 = i} = {0}Æ );
(* *** Goal "1" *** *)
a(PC_T"hol1" (REPEAT strip_tac)
	THEN TRY_T (asm_ante_tac ¨≥x = 0Æ) THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[min_clauses]);
pop_thm()
));
=TEX
=SML
val €size_thm2› = save_thm("size_thm2", (
push_goal([], ¨µlist∑ list ç Distinct ¥ Size(Elems list) = Length listÆ);
a(rewrite_tac[get_spec¨SizeÆ] THEN REPEAT strip_tac);
a(strip_asm_tac (list_µ_elim
	[¨Length listÆ, ¨{i|∂ list'∑ Length list' = i ± Elems list' = Elems list}Æ]
	min_thm));
(* *** Goal "1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[] o µ_elim¨listÆ));
a(TOP_ASM_T ante_tac THEN GET_NTH_ASM_T 3 (rewrite_thm_tac o eq_sym_rule));
a(strip_tac THEN strip_asm_tac (list_µ_elim
	[¨Length listÆ, ¨Length list'Æ]
	º_antisym_thm));
(* *** Goal "2.1" *** *)
a(strip_asm_tac (list_µ_elim[¨listÆ, ¨list'Æ]distinct_thm1));
a(asm_ante_tac ¨≥ Elems list = Elems list'Æ);
a(GET_NTH_ASM_T 5 rewrite_thm_tac);
(* *** Goal "2.2" *** *)
a(GET_NTH_ASM_T 2 rewrite_thm_tac);
pop_thm()
));
=TEX
\subsection{Relationship between $Finite$ and Set Operations}
=SML
val €fin_set_thm2› = save_thm("fin_set_thm2", (
push_goal([], ¨{} ç FiniteÆ);
a(rewrite_tac[get_spec¨FiniteÆ]);
a(PC_T "hol1" (REPEAT strip_tac));
pop_thm()
));
=TEX
=SML
val €fin_set_thm3› = save_thm("fin_set_thm3", (
push_goal([], ¨µ a x∑ a ç Finite ¥ ({x} ¿ a) ç FiniteÆ);
a(rewrite_tac[get_spec¨FiniteÆ] THEN (PC_T "hol1" (REPEAT strip_tac)));
a(spec_nth_asm_tac 3 ¨sÆ);
(* *** Goal "1" *** *)
a(list_spec_nth_asm_tac 3 [¨a'Æ, ¨x'Æ]);
(* *** Goal "2" *** *)
a(list_spec_nth_asm_tac 2 [¨aÆ, ¨xÆ]);
pop_thm()
));
=TEX
=SML
val €fin_set_thm4› = save_thm("fin_set_thm4", (
push_goal([], ¨µ list∑ Elems list ç FiniteÆ);
a(strip_tac);
a(list_induction_tac¨listÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[get_spec ¨ElemsÆ, fin_set_thm2]);
(* *** Goal "2" *** *)
a(rewrite_tac[get_spec ¨ElemsÆ]);
a(strip_tac);
a(strip_asm_tac (list_µ_elim[¨Elems listÆ, ¨xÆ]fin_set_thm3));
pop_thm()
));
=TEX
=SML
val €size_thm3› = save_thm("size_thm3", (
push_goal([], ¨µa b∑ a ç Finite ± b ç Finite
	¥		(a ¿ b) ç FiniteÆ);
a(REPEAT strip_tac);
a(strip_asm_tac (µ_elim ¨aÆ fin_set_thm1));
a(strip_asm_tac (µ_elim ¨bÆ fin_set_thm1));
a(asm_rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) elems_thm3]);
a(prove_tac[fin_set_thm4]);
pop_thm()
));
=TEX
=SML
val €size_thm4› = save_thm("size_thm4", (
push_goal([], ¨µa b∑ a ç Finite ± b Ä a
	¥		b ç FiniteÆ);
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨aÆfin_set_thm1));
a(LEMMA_T ¨b = Elems (list ˘ b)Æ once_rewrite_thm_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 2 (fn th => rewrite_tac[eq_sym_rule th, ˘_thm1]));
a(PC_T"hol1"(asm_prove_tac[]));
(* *** Goal "2" *** *)
a(rewrite_tac[fin_set_thm4]);
pop_thm()
));
=TEX
=SML
val €size_thm5› = save_thm("size_thm5", (
push_goal([], ¨µa x∑ a ç Finite
	¥	 Size({x} ¿ a) = if x ç a then Size a else Size a + 1Æ);
a(REPEAT strip_tac);
a(cases_tac¨x ç aÆ);
(* *** Goal "1" *** *)
a(LEMMA_T ¨{x} ¿ a = aÆ asm_rewrite_thm_tac);
a(PC_T"hol1"(REPEAT strip_tac));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac(list_µ_elim[¨aÆ]fin_set_thm1));
a(lemma_tac¨{x} ¿ a = Elems (Cons x list) ± Cons x list ç DistinctÆ);
(* *** Goal "2.1" *** *)
a(asm_rewrite_tac[get_spec¨ElemsÆ, get_spec¨DistinctÆ]);
a(DROP_NTH_ASM_T 2 (asm_rewrite_thm_tac o eq_sym_rule));
(* *** Goal "2.2" *** *)
a(strip_asm_tac(list_µ_elim[¨listÆ]size_thm2));
a(strip_asm_tac(list_µ_elim[¨Cons x listÆ]size_thm2));
a(LIST_GET_NTH_ASM_T [7, 4, 1] rewrite_tac);
a(LIST_GET_NTH_ASM_T [6, 2] rewrite_tac);
a(rewrite_tac[get_spec¨LengthÆ]);
pop_thm()
));
=TEX
=SML
val €size_thm6› = save_thm("size_thm6", (
push_goal([], ¨µa b∑ a ç Finite ± b ç Finite ¥  (a ° b) ç FiniteÆ);
a(REPEAT strip_tac);
a(strip_asm_tac(pc_rule"hol1"(prove_rule[])¨a ° b Ä aÆ));
a(strip_asm_tac(list_µ_elim[¨aÆ, ¨a ° bÆ]size_thm4));
pop_thm()
));
=TEX
=SML
val €size_thm7› = save_thm("size_thm7", (
push_goal([], ¨µa b∑ a ç Finite ± b ç Finite
	¥		Size(a ¿ b) + Size (a ° b) = Size a + Size bÆ);
a(REPEAT strip_tac);
a(asm_ante_tac ¨a ç FiniteÆ THEN fin_set_induction_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[size_thm1]);
(* *** Goal "2" *** *)
a(strip_asm_tac(list_µ_elim[¨aÆ, ¨bÆ]size_thm3));
a(strip_asm_tac(list_µ_elim[¨aÆ, ¨bÆ]size_thm6));
a(cases_tac¨x ç bÆ);
(* *** Goal "2.1" *** *)
a(lemma_tac ¨({x} ¿ a) ¿ b = a ¿ b ±
	({x} ¿ a) ° b = {x} ¿ (a ° b)Æ); 
(* *** Goal "2.1.1" *** *)
a(PC_T"hol1"(REPEAT strip_tac THEN asm_rewrite_tac[]));
(* *** Goal "2.1.2" *** *)
a(strip_asm_tac(list_µ_elim[¨a ¿ bÆ, ¨xÆ]size_thm5));
a(strip_asm_tac(list_µ_elim[¨a ° bÆ, ¨xÆ]size_thm5));
a(strip_asm_tac(list_µ_elim[¨aÆ, ¨xÆ]size_thm5));
a(LEMMA_T ¨x ç a ¿ b ± ≥x ç a ° bÆ
	(fn th => asm_rewrite_tac[th, µ_elim¨1Æplus_order_thm]));
a(REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(lemma_tac ¨({x} ¿ a) ¿ b = {x} ¿ a ¿ b ±
	({x} ¿ a) ° b = (a ° b)Æ); 
(* *** Goal "2.2.1" *** *)
a(PC_T"hol1"(REPEAT strip_tac THEN asm_rewrite_tac[]));
a(asm_ante_tac ¨x' ç bÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a(strip_asm_tac(list_µ_elim[¨a ¿ bÆ, ¨xÆ]size_thm5));
a(strip_asm_tac(list_µ_elim[¨a ° bÆ, ¨xÆ]size_thm5));
a(strip_asm_tac(list_µ_elim[¨aÆ, ¨xÆ]size_thm5));
a(LEMMA_T ¨≥x ç a ¿ b ± ≥x ç a ° bÆ
	(fn th => asm_rewrite_tac[th, µ_elim¨1Æplus_order_thm]));
a(REPEAT strip_tac);
pop_thm()
));
=TEX
=SML
val €size_singleton_thm› = save_thm("size_singleton_thm", (
push_goal([], ¨µx∑ #{x} = 1Æ);
a strip_tac;
a(accept_tac(rewrite_rule[fin_set_thm2, size_thm1]
	(list_µ_elim[¨{}Æ, ¨xÆ]size_thm5)));
pop_thm()
));
=TEX
\subsection{Miscellany}
=SML
val €Ó_set_thm1› = save_thm("Ó_set_thm1", (
push_goal([], ¨µa: Ó SET∑ a ç Finite ± ≥a = {} ¥ ∂m∑m ç a ± µi∑i ç a ¥ i º mÆ);
a(strip_tac THEN bc_tac[taut_rule¨(A ¥ B ¥ C) ¥ (A ± B ¥ C)Æ]);
a(fin_set_induction_tac THEN_TRY asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨x:ÓÆ THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac(list_µ_elim[¨xÆ, ¨mÆ]º_cases_thm));
(* *** Goal "2.1" *** *)
a(∂_tac¨mÆ THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(asm_fc_tac[] THEN rename_tac[(¨iÆ, "ii")]);
a(bc_tac[º_trans_thm]);
a(∂_tac¨mÆ THEN REPEAT strip_tac);
pop_thm()
));
=TEX
=SML
val _ = save_consistency_thm¨MaxÆ(
push_consistency_goal¨MaxÆ;
a(prove_∂_tac THEN strip_tac);
a(cases_tac¨∂m∑ m ç a' ± (µ i∑ i ç a' ¥ i º m)Æ);
(* *** Goal "1" *** *)
a(∂_tac¨mÆ THEN REPEAT strip_tac);
a(bc_tac[º_antisym_thm] THEN asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val €finite_max_thm› = save_thm("finite_max_thm", (
push_goal([], ¨µa: Ó SET∑ a ç Finite ± ≥a = {} ¥ Max a ç a ± µi∑i ç a ¥ i º Max aÆ);
a(REPEAT_N 2 strip_tac);
a(fc_tac[Ó_set_thm1]);
a(LEMMA_T ¨Max a = mÆ (fn th => rewrite_tac[th] THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a(bc_tac[get_spec¨MaxÆ] THEN REPEAT strip_tac THEN asm_fc_tac[]);
(* *** Goal "2" *** *)
a(asm_fc_tac[]);
pop_thm()
));
=TEX
=SML
val €finite_size_thm› = save_thm("finite_size_thm", (
push_goal([], ¨µa m∑ 
	(∂list∑Elems list = a ± list ç Distinct ± Length list = m)
§	a ç Finite ± #a = m
Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(GET_NTH_ASM_T 3 (fn th => rewrite_tac[eq_sym_rule th, fin_set_thm4]));
(* *** Goal "2" *** *)
a(fc_tac[size_thm2]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(fc_tac[fin_set_thm1]);
a(∂_tac¨listÆ THEN asm_rewrite_tac[]);
a(fc_tac[size_thm2]);
a(LIST_DROP_NTH_ASM_T [1,3,4] (rewrite_tac o map eq_sym_rule));
pop_thm()
));
=TEX
=SML
val €length_map_thm› = save_thm("length_map_thm", (
push_goal([], ¨µf list∑
	Length(Map f list) = Length list
Æ);
a(REPEAT strip_tac);
a(list_induction_tac¨listÆ THEN asm_rewrite_tac[length_def, map_def]);
pop_thm()
));
=TEX
=SML
val €elems_map_thm› = save_thm("elems_map_thm", (
push_goal([], ¨µf list∑
	Elems(Map f list) = {y | ∂x∑ x ç Elems list ± f x = y}
Æ);
a(REPEAT strip_tac);
a(list_induction_tac¨listÆ THEN asm_rewrite_tac[elems_def, map_def]
	THEN PC_T"hol1"(REPEAT strip_tac));
(* *** Goal "1" *** *)
a(∂_tac¨xÆ THEN PC_T"hol1"(REPEAT strip_tac) THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨x''Æ THEN PC_T"hol1"(REPEAT strip_tac));
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(∂_tac¨x''Æ THEN PC_T"hol1"(REPEAT strip_tac));
pop_thm()
));
=TEX
=SML
val €map_distinct_thm› = save_thm("map_distinct_thm", (
push_goal([], ¨µf list∑
	(Map f list) ç Distinct 
§	list ç Distinct
	± (µx y∑ x ç Elems list ± y ç Elems list ± f x = f y ¥ x = y)
Æ);
a(REPEAT µ_tac);
a(list_induction_tac¨listÆ);
(* *** Goal "1" of 5 *** *)
a(asm_rewrite_tac[elems_def, map_def, distinct_def]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[elems_def, map_def, distinct_def]);
(* *** Goal "3" *** *)
a(rename_tac[]);
a(asm_rewrite_tac[elems_def, map_def, distinct_def]);
a(PC_T"hol1"(REPEAT strip_tac));
a(asm_fc_tac[] THEN asm_fc_tac[]);
(* *** Goal "4" *** *)
a(asm_fc_tac[] THEN asm_fc_tac[]);
(* *** Goal "5" *** *)
a(asm_rewrite_tac[elems_def, map_def, distinct_def]);
a(rewrite_tac[taut_rule¨µp q r∑(≥p § ≥q ± r) § (p § q ≤ ≥r)Æ, elems_map_thm]);
a(REPEAT_N 3 strip_tac);
(* *** Goal "5.1" *** *)
a(strip_tac THEN cases_tac ¨x ç Elems listÆ THEN1 REPEAT strip_tac);
a(PC_T"hol1"(REPEAT strip_tac));
a(list_spec_nth_asm_tac 1 [¨x'Æ, ¨xÆ]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule) THEN strip_tac);
(* *** Goal "5.2" *** *)
a(cases_tac ¨x ç Elems listÆ);
(* *** Goal "5.2.1" *** *)
a(¥_T (fn th => id_tac));
a(∂_tac¨xÆ THEN asm_rewrite_tac[]);
(* *** Goal "5.2.2" *** *)
a(asm_rewrite_tac[]);
a(once_rewrite_tac[taut_rule¨µp q∑(≥p ¥ q) § (≥q ¥ p)Æ]);
a(PC_T"hol1"(REPEAT strip_tac));
(* *** Goal "5.2.2.1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "5.2.2.2" *** *)
a(list_spec_nth_asm_tac 4 [¨yÆ]);
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(¥_T rewrite_thm_tac);
(* *** Goal "5.2.2.3" *** *)
a(list_spec_nth_asm_tac 4 [¨x'Æ]);
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(¥_T rewrite_thm_tac);
(* *** Goal "5.2.2.4" *** *)
a(asm_fc_tac[] THEN asm_fc_tac[]);
pop_thm()
));
=TEX
=SML
val €pair_eq_thm› = save_thm("pair_eq_thm", (
push_goal([], ¨µx y∑ Fst x = Fst y ± Snd x = Snd y ¥ x = yÆ);
a(REPEAT strip_tac);
a(LEMMA_T¨y = (Fst x, Snd x)Æ rewrite_thm_tac);
a(pure_asm_rewrite_tac[] THEN rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val €at_thm› = save_thm("at_thm", (
push_goal([], ¨µf: 'a ™ 'b; x : 'a∑
	f ç Functional ± x ç Dom f
	¥ µy∑f@x = y § (x, y) ç f
Æ);
a(rewrite_tac[functional_def, dom_def]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(fc_tac[get_spec¨$AtÆ]);
(* *** Goal "1.1" *** *)
a(asm_fc_tac[] THEN asm_fc_tac[]);
a(asm_ante_tac¨≥ z = yÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(DROP_ASM_T¨f @ x = y'Æ(asm_rewrite_thm_tac o eq_sym_rule));
(* *** Goal "2" *** *)
a(fc_tac[get_spec¨$AtÆ]);
(* *** Goal "2.1" *** *)
a(asm_fc_tac[] THEN asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[] THEN asm_fc_tac[] THEN asm_fc_tac[]);
pop_thm()
));
=TEX
=SML
val €finite_function_thm› = save_thm("finite_function_thm", (
push_goal([], ¨µf: 'a ™ 'b∑ 
		f ç Functional
	±	(f ç Finite ≤ Dom f ç Finite)
	¥ 	f ç Finite ± Dom f ç Finite ± #(Dom f) = #f
Æ);
a(REPEAT_N 2 strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
a(fc_tac[fin_set_thm1]);
a(bc_tac[finite_size_thm]);
a(∂_tac¨Map Fst listÆ);
a(fc_tac[size_thm2]);
a(asm_rewrite_tac[length_map_thm, elems_map_thm, map_distinct_thm, dom_def]);
a(PC_T"hol1"(REPEAT strip_tac));
(* *** Goal "1.1" *** *)
a(∂_tac¨Snd x'Æ THEN POP_ASM_T (asm_rewrite_thm_tac o eq_sym_rule));
(* *** Goal "1.2" *** *)
a(∂_tac¨(x, y)Æ THEN asm_rewrite_tac[]);
(* *** Goal "1.3" *** *)
a(DROP_ASM_T¨f = Elems listÆ (asm_tac o eq_sym_rule));
a(LIST_DROP_NTH_ASM_T [3,4] (MAP_EVERY ante_tac) THEN asm_rewrite_tac[]);
a(DROP_ASM_T¨f ç FunctionalÆ (strip_asm_tac o rewrite_rule[get_spec¨FunctionalÆ]));
a(REPEAT strip_tac);
a(lemma_tac ¨(Fst x, Snd y) ç fÆ THEN1 asm_rewrite_tac[]);
a(LIST_SPEC_NTH_ASM_T 4 [¨Fst xÆ, ¨Snd xÆ, ¨Snd yÆ] (strip_asm_tac o rewrite_rule[]));
a(bc_tac[pair_eq_thm] THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
a(fc_tac[fin_set_thm1]);
a(conv_tac(ONCE_MAP_C eq_sym_conv) THEN bc_tac[finite_size_thm]);
a(∂_tac¨Map (Ãx∑(x, f@x)) listÆ);
a(fc_tac[size_thm2]);
a(asm_rewrite_tac[length_map_thm, elems_map_thm, map_distinct_thm, dom_def]);
a(PC_T"hol1"(REPEAT strip_tac));
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 6 (asm_tac o eq_sym_rule));
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a(fc_tac[at_thm] THEN asm_fc_tac[]);
a(DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[] THEN strip_tac);
a(asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(lemma_tac¨Fst x ç Dom fÆ);
(* *** Goal "2.2.1" *** *)
a(rewrite_tac[dom_def] THEN ∂_tac¨Snd xÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a(lemma_tac¨x = (Fst x, f@(Fst x))Æ);
(* *** Goal "2.2.2.1" *** *)
a(fc_tac[conv_rule (ONCE_MAP_C eq_sym_conv) at_thm] THEN asm_fc_tac[]);
a(POP_ASM_T (ante_tac o µ_elim¨Snd xÆ) THEN rewrite_tac[]);
a(strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(DROP_NTH_ASM_T 6 (rewrite_thm_tac o eq_sym_rule));
a(POP_ASM_T once_rewrite_thm_tac THEN ∂_tac¨Fst xÆ THEN asm_rewrite_tac[]);
pop_thm()
));
=TEX
\newpage
\input{wrk044.thl.tex}
\newpage
\section{INDEX}
\printindex
\end{document}


