
=TEX
\documentstyle[11pt,hol1,TQa4]{article}
\begin{document}
=SML
open_theory"hol";
new_theory"finite";
set_pc"hol";
open Resolution;
=TEX
¹HOLCONST
	ÛElemsİ : 'a LIST ­ 'a SET
÷
	Elems [] = {}
± µh list·
	Elems (Cons h list) = {h} À Elems list
°
¹HOLCONST
	ÛDisjointİ : 'a LIST SET
÷
	[]  Disjoint
±	µh t· (Cons h t)  Disjoint ¤ ³h  Elems t ± t  Disjoint
°
¹HOLCONST
	Finite : 'a SET SET
÷
	Finite = ¥{u | {}  u ± µa x·a  u ´ ({x} À a)  u}
°
=SML
declare_infix(300, "ù");
¹HOLCONST
	$ù : 'a LIST ­ 'a SET ­ 'a LIST
÷
	µa h t·	[] ù a = []
		± (Cons h t) ù a = if h  a then Cons h (t ù a) else t ù a
°
¹HOLCONST
	Min : î SET ­ î
÷
	µm a·m  a ± (µi·i  a ´ m ¼ i) ´ Min a = m
°
=SML
¹HOLCONST
	Size : 'a SET ­ î
÷
	µa·Size a = Min {i | ¶list· Length list = i ± Elems list = a}
°
=TEX
=SML
val Ûfin_set_induction_thmİ = save_thm("fin_set_induction_thm", (
	push_goal([], ¬
		µP·	P {} ± (µa x·P a ± ³x  a ´ P({x} À a))
		´ 	µa·a  Finite ´ P a
®);
a(rewrite_tac[get_spec¬Finite®]);
a(REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¬{b | P b}®);
a(cases_tac¬x'  a'®);
(* *** Goal "1" *** *)
a(swap_asm_concl_tac ¬³ P ({x'} À a')®);
a(LEMMA_T¬{x'} À a' = a'® asm_rewrite_thm_tac);
a(PC_T "hol1" (REPEAT strip_tac));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(list_spec_nth_asm_tac 5 [¬a'®, ¬x'®]);
pop_thm()
));
=TEX
=SML
local
val Ûpatternİ = ¬(a:'a SET)  Finite ´ q®;
val tma = ¬a:'a SET®;
val tmq = ¬q:BOOL®;
in
val ÛFIN_SET_INDUCTION_Tİ : (THM -> TACTIC) -> TACTIC = ((fn thmtac =>
	let fun aux_tac (gl as (seqasms, conc)) = (
		let	val (ty_m, tm_m) = (term_match conc pattern)
				handle (Fail _) =>
				term_fail "FIN_SET_INDUCTION_T" 74000 [conc];
			val mya = subst tm_m (inst [] ty_m tma);
			val se = if not (is_var mya)
				then term_fail "FIN_SET_INDUCTION_T" 74001 [mya]
				else if any seqasms (is_free_in mya)
				then term_fail "FIN_SET_INDUCTION_T" 74002 [mya]
				else ();
			val myq = subst tm_m tmq;
			val abs = mk_simple_Ì(mya, myq);
			val thm0 = (conv_rule(ONCE_MAP_C (simple_Â_conv))
					(simple_µ_elim abs
					(inst_type_rule ty_m fin_set_induction_thm)));
			val thm1 = undisch_rule(conv_rule
				((LEFT_C o RIGHT_C o RAND_C)
				 (simple_Á_conv (fst(dest_var mya)))) thm0);
			val thm2 = simple_µ_elim mya thm1;
			val conc' = (hd (asms thm2));
		in	([(seqasms, conc')],
			 (fn [th] => prove_asm_rule th thm2
			  | _ => bad_proof "INDUCTION_T"))
		end);
	in	aux_tac THEN ±_tac THEN_LIST 
			[id_tac, simple_µ_tac THEN simple_µ_tac THEN ´_T thmtac]
	end)
);
end;
=TEX
=SML
val Ûfin_set_induction_tacİ : TACTIC = (
	let	val tac = (FIN_SET_INDUCTION_T strip_asm_tac);
	in	fn gl => (tac gl
			handle ex => pass_on ex "FIN_SET_INDUCTION_T" "fin_set_induction_tac")
	end handle ex => pass_on ex "FIN_SET_INDUCTION_T" "fin_set_induction_tac"
);
=TEX
=SML
val _ = save_consistency_thm¬Min®(
push_consistency_goal¬Min®;
a(conv_tac prove_¶_conv THEN strip_tac);
a(strip_asm_tac (rewrite_rule[](µ_elim¬(Ìj·j  a')®¼_well_order_thm))
	THEN ¶_tac ¬m:î® THEN asm_prove_tac []);
a(strip_asm_tac(list_µ_elim[¬m®, ¬m'®] ¼_antisym_thm) THEN asm_prove_tac[]);
pop_thm()
);
=TEX
=SML
val Ûmin_thmİ = save_thm("min_thm", (
push_goal([], ¬µm a·m  a ´ Min a  a ± Min a ¼ m®);
a(REPEAT µ_tac THEN ´_tac);
a(strip_asm_tac (rewrite_rule[](µ_elim¬(Ìj·j  a)®¼_well_order_thm))
	THEN asm_prove_tac[]);
(* *** Goal "1" *** *)
a(strip_asm_tac (list_µ_elim[¬m'®, ¬a®](get_spec¬Min®)));
(* *** Goal "1.1" *** *)
a(asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(strip_asm_tac (list_µ_elim[¬m'®, ¬a®](get_spec¬Min®)));
(* *** Goal "2.1" *** *)
a(asm_prove_tac[]);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[] THEN asm_prove_tac[]);
pop_thm()
));
=TEX
=SML
val Ûmin_clause1İ = (
push_goal([], ¬µm·Min {m} = m®);
a(REPEAT strip_tac);
a(strip_asm_tac (list_µ_elim[¬m®, ¬{m}®](get_spec¬Min®)));
a(swap_asm_concl_tac¬³m ¼ i® THEN asm_rewrite_tac[¼_clauses]);
pop_thm()
);
=TEX
=SML
val Ûmin_clause2İ = (
push_goal([], ¬µm n·Min {m; n} = if m ¼ n then m else n®);
a(REPEAT strip_tac);
a(strip_asm_tac (list_µ_elim[¬if m ¼ n then m else n®, ¬{m; n}®](get_spec¬Min®)));
(* *** Goal "1" *** *)
a(all_asm_ante_tac THEN cases_tac¬m ¼ n® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(swap_asm_concl_tac¬³(if m ¼ n then m else n) ¼ i® THEN asm_rewrite_tac[]);
a(cases_tac¬m ¼ n® THEN asm_rewrite_tac[¼_clauses]);
a(strip_asm_tac(list_µ_elim[¬m®, ¬n®]¼_cases_thm));
(* *** Goal "3" *** *)
a(swap_asm_concl_tac¬³(if m ¼ n then m else n) ¼ i® THEN asm_rewrite_tac[]);
a(cases_tac¬m ¼ n® THEN asm_rewrite_tac[¼_clauses]);
pop_thm()
);
=TEX
=SML
val Ûmin_clause3İ = (
push_goal([], ¬µm a·Min ({m} À a) = if a = {} then m else Min{m; Min a}®);
a(REPEAT strip_tac);
a(cases_tac¬a = {}® THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(rewrite_tac[min_clause1]);
(* *** Goal "2" *** *)
a(all_asm_ante_tac THEN (PC_T"sets_ext" strip_tac));
a(all_asm_ante_tac THEN strip_tac);
a(strip_asm_tac (list_µ_elim[¬x®, ¬a®]min_thm));
a(lemma_tac¬µ i· i  {m} À a ´ Min {m; Min a} ¼ i®);
(* *** Goal "2.1" *** *)
a(REPEAT strip_tac THEN rewrite_tac[min_clause2]);
(* *** Goal "2.1.1" *** *)
a(cases_tac¬m ¼ Min a® THEN asm_rewrite_tac[¼_clauses]);
a(strip_asm_tac (list_µ_elim[¬m®, ¬Min a®]¼_cases_thm));
(* *** Goal "2.1.2" *** *)
a(strip_asm_tac (list_µ_elim[¬i®, ¬a®]min_thm));
a(cases_tac ¬m ¼ Min a® THEN asm_rewrite_tac[]);
a(basic_res_tac 3 [¼_trans_thm]);
(* *** Goal "2.2" *** *)
a(LEMMA_T ¬Min {m; Min a}  {m} À a® asm_tac);
(* *** Goal "2.2.1" *** *)
a(cases_tac¬m ¼ Min a® THEN asm_rewrite_tac[min_clause2] THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(ante_tac (list_µ_elim[¬Min {m; Min a}®, ¬({m} À a)®](get_spec¬Min®))
	THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val Ûmin_clausesİ = save_thm("min_clauses",
	list_±_intro[min_clause1, min_clause2, min_clause3]);
=TEX
=SML
val Ûfin_set_thm1İ = save_thm("fin_set_thm1", (
push_goal([], ¬µa· a  Finite ´ ¶list·a = Elems list ± list  Disjoint®);
a(strip_tac);
a fin_set_induction_tac;
(* *** Goal "1" *** *)
a(¶_tac ¬[]® THEN rewrite_tac(map get_spec[¬Elems®, ¬Disjoint®]));
(* *** Goal "2" *** *)
a(¶_tac ¬Cons x list® THEN asm_rewrite_tac(map get_spec[¬Elems®, ¬Disjoint®]));
a(asm_ante_tac ¬³ x  a® THEN asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val Ûelems_thm1İ = save_thm("elems_thm1", (
push_goal([], ¬µlist· Elems list = {} ¤ list = []®);
a(strip_tac THEN strip_asm_tac(µ_elim¬list:'a LIST® list_cases_thm));
(* *** Goal "1" *** *)
a(asm_rewrite_tac[get_spec¬Elems®]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[get_spec¬Elems®]);
a(PC_T "sets_ext" (REPEAT strip_tac));
a(REPEAT strip_tac);
a(¶_tac¬x® THEN REPEAT strip_tac);
pop_thm()
));
=TEX
=SML
val Ûelems_thm2İ = save_thm("elems_thm2", (
push_goal([], ¬(µlist· Elems list = {} ¤ list = [])
	± (µlist· {} = Elems list ¤ list = [])®);
a(rewrite_tac[elems_thm1]);
a(rewrite_tac[conv_rule (ONCE_MAP_C eq_sym_conv) elems_thm1]);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val Ûlength_thmİ = save_thm("length_thm", (
push_goal([], ¬µlist1 list2· Length (list1 @ list2) = Length list1 + Length list2®);
a(REPEAT strip_tac);
a(list_induction_tac¬list1® THEN rewrite_tac(map get_spec[¬Length®, ¬Append®]));
a(asm_rewrite_tac[plus_assoc_thm]);
pop_thm()
));
=TEX
=SML
val Ûù_thm1İ = save_thm("ù_thm1", (
push_goal([], ¬µlist a·Elems(list ù a) = Elems list ¡ a®);
a(REPEAT strip_tac);
a(list_induction_tac¬list® THEN rewrite_tac(map get_spec[¬Elems®, ¬$ù®]));
a(strip_tac THEN cases_tac ¬x  a® THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[get_spec¬Elems®]);
a(PC_T "hol1" (REPEAT strip_tac));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(PC_T "hol1" (REPEAT strip_tac));
a(asm_ante_tac¬x'  a® THEN asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val Ûù_thm2İ = save_thm("ù_thm2", (
push_goal([], ¬µlist a·Length((list ù a) @ (list ù ~a)) = Length list®);
a(REPEAT strip_tac);
a(list_induction_tac¬list® THEN rewrite_tac(map get_spec[¬Length®, ¬$ù®, ¬Append®]));
a(strip_tac THEN cases_tac ¬x  a® THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a(asm_rewrite_tac(map get_spec[¬Length®, ¬$ù®, ¬Append®]));
(* *** Goal "2" *** *)
a(all_asm_ante_tac THEN rewrite_tac[length_thm] THEN REPEAT strip_tac);
a(asm_rewrite_tac[get_spec¬Length®, µ_elim¬1®plus_order_thm]);
pop_thm()
));
=TEX
=SML
val Ûù_thm3İ = save_thm("ù_thm3", (
push_goal([], ¬µlist a·Elems list € a ´ list ù a = list ®);
a(strip_tac);
a(list_induction_tac¬list®);
(* *** Goal "1" *** *)
a(rewrite_tac[get_spec¬$ù®]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac(map get_spec[¬$ù®, ¬Elems®]));
a(REPEAT strip_tac);
a(lemma_tac ¬x  a®);
(* *** Goal "2.1" *** *)
a(POP_ASM_T ante_tac);
a(PC_T"hol1"(REPEAT strip_tac));
a(spec_nth_asm_tac 1 ¬x®);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[]);
a(lemma_tac ¬Elems list € a®);
(* *** Goal "2.2.1" *** *)
a(asm_ante_tac¬{x} À Elems list € a® THEN PC_T"hol1"(REPEAT strip_tac));
a(spec_nth_asm_tac 2 ¬x'®);
(* *** Goal "2.2.2" *** *)
a(spec_nth_asm_tac 4 ¬a®);
pop_thm()
));
=TEX
=SML
val Ûù_thm4İ = save_thm("ù_thm4", (
push_goal([], ¬µlist x·x  Elems list ´ Length(list ù ~{x}) < Length list ®);
a(strip_tac);
a(list_induction_tac¬list® THEN asm_rewrite_tac[get_spec¬Elems®]);
(* *** Goal "" *** *)
a(asm_rewrite_tac(map get_spec[¬$ù®, ¬Length®]) THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[get_spec¬Length®] THEN cases_tac¬x  Elems list®);
(* *** Goal "1.1" *** *)
a(spec_nth_asm_tac 3 ¬x®);
a(strip_asm_tac(list_µ_elim
	[¬Length (list ù ~ {x})®, ¬Length list®, ¬Length list + 1®]
	less_trans_thm));
a(POP_ASM_T (strip_asm_tac o rewrite_rule[]));
a(lemma_tac¬Elems list € ~{x}®);
(* *** Goal "1.2.1" *** *)
a(PC_T"hol1"(REPEAT strip_tac));
a(rewrite_tac[get_spec¬~®]);
a(contr_tac THEN asm_ante_tac ¬x''  Elems list® THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2" *** *)
a(strip_asm_tac(list_µ_elim[¬list®, ¬~{x}®]ù_thm3));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 2 (strip_asm_tac o µ_elim ¬x'®));
a(cases_tac¬x = x'® THEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a(strip_asm_tac(list_µ_elim
	[¬Length (list ù ~ {x'})®, ¬Length list®, ¬Length list + 1®]
	less_trans_thm));
a(POP_ASM_T (strip_asm_tac o rewrite_rule[]));
(* *** Goal "2.2" *** *)
a(rewrite_tac[get_spec¬Length®] THEN REPEAT strip_tac);
pop_thm()
));
=TEX
=SML
val Ûdisjoint_thm1İ = save_thm("disjoint_thm1", 
push_goal([], ¬µlist1 list2·
		list1  Disjoint ± Elems list1 = Elems list2
	´	Length list1 ¼ Length list2®);
a(strip_tac);
a(list_induction_tac¬list1®);
(* *** Goal "1" *** *)
a(rewrite_tac(elems_thm2 :: map get_spec[¬Elems®, ¬Disjoint®, ¬Length®]));
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(lemma_tac ¬Length ([x] @ (list2 ù ~{x})) ¼ Length list2®);
(* *** Goal "2.1" *** *)
a(rewrite_tac[get_spec¬Length®, length_thm]);
a(cases_tac¬x  Elems list2®);
(* *** Goal "2.1.1" *** *)
a(strip_asm_tac(list_µ_elim[¬list2®, ¬x®]ù_thm4));
a(asm_ante_tac¬Length (list2 ù ~ {x}) < Length list2® THEN
	rewrite_tac[µ_elim¬1®plus_order_thm, less_def]);
(* *** Goal "2.1.2" *** *)
a(lemma_tac¬Elems list2 € ~{x}®);
(* *** Goal "2.1.2.1" *** *)
a(PC_T"hol1"(REPEAT strip_tac));
a(rewrite_tac[get_spec¬~®]);
a(swap_asm_concl_tac¬x'  Elems list2® THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2.2" *** *)
a(lemma_tac¬x  Elems list2®);
a(asm_ante_tac ¬Elems (Cons x list1) = Elems list2®);
a(rewrite_tac[get_spec¬Elems®]);
a(PC_T"hol1"(REPEAT strip_tac));
a(spec_nth_asm_tac 1¬x®);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 3 (strip_asm_tac o rewrite_rule[get_spec¬Disjoint®]));
a(lemma_tac¬Elems list1 = Elems (list2 ù ~ {x})®);
(* *** Goal "2.2.2" *** *)
a(rewrite_tac[ù_thm1]);
a(DROP_NTH_ASM_T 4 (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[get_spec¬Elems®]);
a(PC_T"hol1"(REPEAT strip_tac));
(* *** Goal "2.2.1.1" *** *)
a(rewrite_tac[get_spec¬~®]);
a(swap_asm_concl_tac¬x'  Elems list1® THEN asm_rewrite_tac[]);
(* *** Goal "2.2.1.2" *** *)
a(TOP_ASM_T (strip_asm_tac o rewrite_rule[get_spec¬~®]));
(* *** Goal "2.2.2" *** *)
a(DROP_NTH_ASM_T 6 (strip_asm_tac o µ_elim¬list2 ù ~ {x}®));
a(rewrite_tac(map get_spec[¬Length®]));
a(swap_nth_asm_concl_tac 5 THEN rewrite_tac(map get_spec[¬$@®, ¬Length®]));
a(swap_nth_asm_concl_tac 1);
a(strip_asm_tac(list_µ_elim
	[¬Length list1 + 1®, ¬Length (list2 ù ~ {x}) + 1®, ¬Length list2®]
	¼_trans_thm));
a(POP_ASM_T (strip_asm_tac o rewrite_rule[]));
pop_thm()
));
=TEX
!!! GOT HERE !!!
=SML
val Ûsize_thm1İ = (
push_goal([], ¬Size {} = 0®);
a(rewrite_tac[get_spec¬Size®, elems_thm1]);
a(conv_tac (ONCE_MAP_C prove_¶_conv));
a(rewrite_tac[get_spec¬Length®]);
a(lemma_tac¬{i|0 = i} = {0}® );
(* *** Goal "1" *** *)
a(PC_T"hol1" (REPEAT strip_tac)
	THEN TRY_T (asm_ante_tac ¬³x = 0®) THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[min_clauses]);
pop_thm()
);
=TEX
=SML
val Ûsize_thm2İ = (
push_goal([], ¬µlist· list  Disjoint ´ Size(Elems list) = Length list®);
a(rewrite_tac[get_spec¬Size®] THEN REPEAT strip_tac);
a(strip_asm_tac (list_µ_elim
	[¬Length list®, ¬{i|¶ list'· Length list' = i ± Elems list' = Elems list}®]
	min_thm));
(* *** Goal "1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[] o µ_elim¬list®));
a(TOP_ASM_T ante_tac THEN GET_NTH_ASM_T 3 (rewrite_thm_tac o eq_sym_rule));
a(strip_tac THEN strip_asm_tac (list_µ_elim
	[¬Length list®, ¬Length list'®]
	¼_antisym_thm));
(* *** Goal "2.1" *** *)
a(strip_asm_tac (list_µ_elim[¬list®, ¬list'®]disjoint_thm1));
a(asm_ante_tac ¬³ Elems list = Elems list'®);
a(GET_NTH_ASM_T 5 rewrite_thm_tac);
(* *** Goal "2.2" *** *)
a(GET_NTH_ASM_T 2 rewrite_thm_tac);
pop_thm()
);
 
=TEX
\end{document}
