=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
\TPPtitle{Detailed Design for the General Purpose Theories}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the \cr
General Purpose Theories}
\TPPref{DS/FMU/IED/DTD045}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K. Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{R.D. Arthan & WIN01\\K. Blackburn & WIN01}
\TPPauthorisation{R.D. Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
general purpose theories ``sum'', ``one'' and ``combin''.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First issue.
\item [Issue 1.2]
Changes after RDA comments.
\item [Issue 1.3]
Changes during implementation.
\item [Issue 1.4]
Fixing typos, corrected test policy.
\item [Issue 1.5]
Made ``set'' the parent.
\item [Issue 1.6]
Made ``sets'' the parent.
\item [Issue 1.7,1.8]
Changes after comments.
Renamed constants $S$, $K$ and $I$ to $CombS$, $CombK$ and $CombI$.
Added $Arbitrary$.
\end{description}
\subsection{Changes Forecast}
Populating theories with more theorems.

\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains detailed designs
for the theories ``sum'', ``one'' and ``combin'',
called for in \cite{DS/FMU/IED/HLD011}.
The design is implemented in \cite{DS/FMU/IED/IMP045}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the detailed design for the theories ``sum'', ``one'' and ``combin''.

These respectively:
\begin{description}
\item [sum]
Define the sum type (i.e. binary disjoint union).
\item [one]
Defines a one-point type.
\item [combin]
Defines the combinators $CombS$, $CombK$ and $CombI$
and the functional composition operator $o$.
\end{description}

\subsubsection{Dependencies}
This document depends on \cite{DS/FMU/IED/IMP044}, which is the theory of sets,
and the theory design tools of \cite{DS/FMU/IED/DTD035}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
The three theories are missing some already obvious theorem
members, and it may be appropriate to add others 
as development and application work progresses.

\section{THE THEORY ``one''}
\subsection{Design of the theory ``one''}
=THDOC
req_name "one" (Value "sets");
=DESCRIBE
The theory ``‚one·'' defines a one-point type, $ª:ONEº$.
It also introduces the constant $Arbitrary$.
=ENDDOC
=THDOC
req_const ("IsOneRep",ª:BOOL ã BOOLº);
req_defn ("IsOneRep",([],ªÑ one: BOOLé 
	É x: BOOLé IsOneRep x Ç (x Ç one)º));
=DESCRIBE
We represent the type $ONE$ by a single member of type $ª:BOOLº$, expressed
by the predicate HOL constant $ª‚IsOneRep·º$.
=ENDDOC
=THDOC
req_type ("ONE",0);
req_defn("ONE",([],ªÑ f: ONE ã BOOL é TypeDefn IsOneRep fº));
req_const("One",ª:ONEº);
req_defn("One",([],ªÉ x: ONEé x = Oneº));
=DESCRIBE
The type $‚ONE·$ has only one member,$ª‚One·º$, demonstrated by its definition ``$‚One·$''
(which is bound to the ML value $one\_def$).
The definition of the type is saved with key ``‚ONE·''.
=ENDDOC
=THDOC
req_thm("one_fns_thm",([],ªÉ f: 'a ã ONE é f = ç x é Oneº));
=DESCRIBE
The theorem ``$‚one\_fns\_thm·$'' states that there is only one
function of any given domain whose range is $ª:ONEº$.
=ENDDOC
=THDOC
req_const("Arbitrary",ª:'aº);
=DESCRIBE
By its type, and lack of constraints, the constant $‚Arbitrary·$ has a type instance that is a member of any type.
=USES
It is to be used when a fixed, but unknown value is required.
=ENDDOC
Red tape to end theory design:
=THSML
summarize_td_results ();
val one_success = theory_check_success ();
initialise_td_results ();
=TEX
\subsection{Signature of the theory ``one''}
=DOC
signature ‚OneTheory· = sig
	val ‚one_def· : THM;
	val ‚one_fns_thm· : THM;
end;
=DESCRIBE
This is the signature in which we declare theory ``one''.
$one\_def$ is the definition of $One$, saved with the key ``One''.
$one\_fns\_thm$ is the theorem saved with key ``$one\_fns\_thm$''.
=ENDDOC
\section{THE THEORY ``combin''}
\subsection{Design of the theory ``combin''}
=THDOC
req_name "combin" (Value "one");
=DESCRIBE
The theory ``‚combin·'' defines the combinators $CombS$, $CombK$ and $CombI$
and the functional composition operator $o$.
=ENDDOC
If a user intends to make significant use of the combinators
they may wish to alias $Comb$ to $S$, etc.
The combinators are not given their usual one letter names to preserve 
these for use as variable names.
=THDOC
req_const ("o",ª:('b ã 'c) ã ('a ã 'b) ã ('a  ã 'c)º);
req_infix (300, "o");
req_defn("o",([],ªÉ (f:'b ã 'c) (g:'a ã 'b) (x: 'a) é
	(f o g) x = f(g x)º));
=DESCRIBE
The HOL constant ``$‚o·$'' represents functional composition,
and is given a definition saved under key ``‚o·''.
=ENDDOC
Note that ``o'' is lower case, following literature conventions.
=THDOC
req_const ("CombS",ª:('a ã 'b ã 'c) ã ('a ã 'b) ã 'a ã 'cº);
req_const ("CombK",ª:'a ã 'b ã 'aº);
req_const ("CombI",ª:'a ã 'aº);
req_defn("CombS",([],ªÉ (f:'a ã 'b ã 'c) (g:'a ã 'b) (x:'a) é
	CombS f g x = f x (g x)º));
req_defn("CombK",([],ªÉ (x : 'a) (y : 'b) é CombK x y = xº));
req_defn("CombI",([],ªÉ (x : 'a) é CombI x = xº));
=DESCRIBE
The HOL constant $ª‚CombS·º$ is the duplication combinator,
$ª‚CombK·º$ is the deletion combinator,
and $ª‚CombI·º$ is the identity combinator.
Their definitions are saved under the keys ``‚CombS·'', ``‚CombK·'' and ``‚CombI·''.
=ENDDOC
=THDOC
req_thm("s_k_thm",([],ªÉ x é 
	(CombS:('a ã 'b ã 'a) ã ('a ã 'b) ã 'a ã 'a) CombK x = CombIº));
req_thm("o_assoc_thm",([],ªÉ (f:'a ã 'b) (g:'c ã 'a) (h :'d ã 'c)é 
	f o (g o h) = (f o g) o hº));
req_thm("o_i_thm",([],ªÉ f : 'a ã 'bé
	((CombI o f) = f) Ä ((f o CombI) = f)º));
=DESCRIBE
The theorem ``$‚s\_k\_thm·$'' expresses the relationship between $S$, $K$ and $I$.
The theorem ``$‚o\_assoc\_thm·$'' expresses the associativity of
functional composition.
The theorem ``$‚o\_i\_thm·$'' expresses the fact that $I$ is the left and right identity of $o$.
=ENDDOC
Red tape to end theory design:
=THSML
summarize_td_results ();
val combin_success = theory_check_success ();
initialise_td_results ();
=TEX
\subsection{Signature of the theory ``combin''}
=DOC
signature ‚CombinTheory· = sig
	val ‚comb_s_def· : THM;
	val ‚comb_k_def· : THM;
	val ‚comb_i_def· : THM;
	val ‚o_def· : THM;
	val ‚o_assoc_thm· : THM;
	val ‚o_i_thm· : THM;
end;
=DESCRIBE
In the signature of $CombinTheory$ in which we declare theory ``combin'' we bind the definitions of $CombS$, $CombK$, $CombI$ and $o$ to
$comb\_s\_def$, $comb\_k\_def$, $comb\_i\_def$ and $o\_def$ respectively.
The theorem  saved with key ``$o\_assoc\_thm$'' is bound to
the ML value of the same name, as is ``$o\_i\_thm$''.
=ENDDOC
We do not bind the other theorems of ``combin'' to ML values
because they won't be in common use.
\section{THE THEORY ``sum''}
\subsection{Design of the theory ``sum''}
=THDOC
req_name "sum" (Value "combin");
=DESCRIBE
The theory ``‚sum·'' defines the sum type (i.e. binary disjoint union).
=ENDDOC
=THDOC
req_const("IsSumRep",ª: ('a â 'b â BOOL) ã BOOLº);
req_defn("IsSumRep",([],ª
Ñ (inl:'a ã  'a â 'b â BOOL) (inr:'b ã  'a â 'b â BOOL)
  (outl:'a â 'b â BOOL ã 'a) (outr:'a â 'b â BOOL ã 'b)
  (isl:'a â 'b â BOOL ã BOOL) (isr:'a â 'b â BOOL ã BOOL) é
É (x1:'a) (x2:'a) (y1:'b) (y2:'b) (z: 'a â 'b â BOOL) é
	IsSumRep(inl x1) Ä
	IsSumRep(inr y1) Ä
	(IsSumRep z ä (inl(outl z) = z Å inr(outr z) = z)) Ä
	(inl x1 = inl x2 Ç x1 = x2) Ä
	(inr y1 = inr y2 Ç y1 = y2) Ä
	å(inl x1 = inr y1) Ä
	å(inr y1 = inl x1) Ä
	outl(inl x1) = x1 Ä
	outr(inr y1) = y1 Ä
	(IsSumRep z ä (isl z Ç inl(outl z) = z)) Ä
	(IsSumRep z ä (isr z Ç inr(outr z) = z))
	º));
=DESCRIBE
The representation of a value of type $ª:'a\ +\ 'bº$ is 
by a triple, where in the implementation the third member indicates whether
the first or second member is the ``real'' value of the type.
This is expressed by the constant $‚IsSumRep·$ whose definition
is saved with key ``‚IsSumRep·''.
=ENDDOC
=THDOC
req_type ("+",2);
req_infix (120,"+");
req_defn("+",([],ªÑ f: 'a + 'b ã ('a â 'b â BOOL) é TypeDefn IsSumRep fº));
=DESCRIBE
The HOL type constructor ``$‚+·$'' creates sum types (i.e. binary disjoint union).
Its definition is saved under the key ``$‚+·$''.
=ENDDOC
=THDOC
req_const("InL",ª:'a ã 'a + 'bº);
req_const("InR",ª:'b ã 'a + 'bº);
req_const("OutL",ª:'a + 'b ã 'aº);
req_const("OutR",ª:'a + 'b ã 'bº);
req_const("IsL",ª:'a + 'b ã BOOLº);
req_const("IsR",ª:'a + 'b ã BOOLº);
list_req_defn(["InL", "InR", "OutL", "OutR", "IsL", "IsR"],
	([],ªÉ (x1:'a) (x2:'a) (y1:'b) (y2:'b) (z: 'a + 'b) é
	(InL(OutL z) = z Å InR(OutR z) = z) Ä
	((InL x1 : 'a + 'b) = InL x2 Ç x1 = x2) Ä
	((InR y1 : 'a + 'b) = InR y2 Ç y1 = y2) Ä
	å(InL x1 = InR y1) Ä
	å(InR y1 = InL x1) Ä
	OutL(InL x1:'a + 'b) = x1 Ä
	OutR(InR y1:'a + 'b) = y1 Ä
	(IsL z Ç InL(OutL z) = z) Ä
	(IsR z Ç InR(OutR z) = z)
	º));
=DESCRIBE
The HOL constants $‚InL·$ and $‚InR·$ are the left and right injection
functions for sum types,
$‚OutL·$ and $‚OutR·$ are the left and right destructor
functions for sum types, and
$‚IsL·$ and $‚IsR·$ are the left and right discriminator
functions.
The resulting definition is also the
primary rewrite rule for these functions,
and is bound to the ML variable $sum\_clauses$(q.v).
=ENDDOC
=THDOC
req_thm("sum_cases_thm",([],
	ªÉ z:'a + 'b é InL (OutL z) = z Å InR (OutR z) = zº));
=DESCRIBE
The theorem ``$‚sum\_cases\_thm·$'' just extracts
the first clause of $sum\_clauses$.
It is used in conjunction with, e.g., $Å\_THEN$.
=ENDDOC
=THDOC
req_thm("sum_fns_thm",([],
	ªÉ (f: 'a ã 'c) (g: 'b ã 'c) é
	Ñ%down%1 h: 'a + 'b ã 'c é
	h o InL = f Ä h o InR = gº));
=DESCRIBE
The theorem ``$‚sum\_fns\_thm·$'' may be used for providing 
meta-results over $InL$ and $InR$,
and is bound to the ML value $sum\_fns\_thm$.
=ENDDOC
Red tape to end theory design:
=THSML
summarize_td_results ();
val sum_success = theory_check_success ();
=TEX
\subsection{Signature of the theory ``sum''}
=DOC
signature ‚SumTheory· = sig
	val ‚sum_clauses· : THM;
	val ‚sum_fns_thm· : THM;
end;
=DESCRIBE
$sum\_clauses$ is bound to the definition of $InL$.
$sum\_fns\_thm$ is bound to the theorem with the that name
as its key.
=ENDDOC
=TEX
\section{TEST POLICY}
The theories produced should be checked by the theory design tools
of \cite{DS/FMU/IED/DTD035}, against the theory design provided.
This is done in \cite{DS/FMU/IED/MDT045}.
There are no functions to be checked.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
