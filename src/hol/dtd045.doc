=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
\TPPtitle{Detailed Design for the General Purpose Theories}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the \cr
General Purpose Theories}
\TPPref{DS/FMU/IED/DTD045}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K. Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{R.D. Arthan & WIN01\\K. Blackburn & WIN01}
\TPPauthorisation{R.D. Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
general purpose theories ``sum'', ``one'' and ``combin''.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First issue.
\end{description}
\subsection{Changes Forecast}
Move to being a theory checker only(set argument to $initialise_td_results$ to false).
Populating theories with more theorems.

\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains detailed designs
for the theories ``sum'', ``one'' and ``combin'',
called for in \cite{DS/FMU/IED/HLD011}.
The design is implemented in \cite{DS/FMU/IED/IMP012}.


\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the detailed design for the theories ``sum'', ``one'' and ``combin''.

These respectively:
\begin{description}
\item [sum]
Define the sum type (i.e. binary disjoint union).
\item [one]
Defines a one-point type.
\item [combin]
Defines the combinators $S$, $K$ and $I$
and the functional composition operator $o$.
\end{description}

\subsubsection{Dependencies}
This document depends on \cite{DS/FMU/IED/IMP037},
and the theory design tools of \cite{DS/FMU/IED/DTD035}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
The three theories are missing some already obvious theorem
members, and it may be appropriate to add others 
as development and application work progresses.

\section{THE THEORY ``one''}
\subsection{Design of the theory ``one''}
=THDOC
req_name "one" (Value "pair");
=DESCRIBE
The theory ``‚one·'' defines a one-point type, $ª:ONEº$.
=ENDDOC
=THDOC
req_const ("IsOneRep",ª:BOOL ã BOOLº);
req_defn ("IsOneRep",([],ªÉ x:BOOLé IsOneRep x Ç xº));
=DESCRIBE
We represent the type $ONE$ by the set ${ªTº}$, expressed
by the predicate HOL constant $ª‚IsOneRep·º$.
=ENDDOC
=THDOC
req_type ("ONE",0);
req_defn("ONE",([],ªÑ f: ONE ã BOOL é TypeDefn IsOneRep fº));
req_const("One",ª:ONEº);
req_defn("One",([],ªÉ x : ONE é x = Oneº));
=DESCRIBE
The type $‚ONE·$ has only one member,$ª‚One·º$, demonstrated by
the its definition ``$‚One·$''
(which is bound to the ML value $one\_defn$).
The definition of the type is saved with key ``‚ONE·''.
=ENDDOC
=THDOC
req_thm("one_fns_thm",([],ªÉ f: 'a ã ONE é f = ç x é Oneº));
=DESCRIBE
The theorem ``$‚one\_fns\_thm·$'' states that there is only one
function of any given domain whose range is $ª:ONEº$.
=ENDDOC
=THDOC
summarize_td_results ();
val one_success = theory_check_success ();
initialise_td_results true;
=DESCRIBE
We need to do this because we are defining more than just ``one''
in one document.
=ENDDOC
\subsection{Signature of the theory ``one''}
=DOC
signature ‚OneTheory· = sig
	val ‚one_defn· : THM;
	val ‚one_fns_thm· : THM;
end;
=DESCRIBE
This is the signature in which we declare theory ``one''.
$one\_defn$ is the definition of $One$, saved with the key ``One''.
$one\_fns\_thm$ is the theorem saved with key ``$one\_fns\_thm$''.
=ENDDOC
\section{THE THEORY ``combin''}
\subsection{Design of the theory ``combin''}
=THDOC
req_name "combin" (Value "one");
=DESCRIBE
The theory ``‚combin·'' defines the combinators $S$, $K$ and $I$
and the functional composition operator $o$.
=ENDDOC
=THDOC
req_const ("o",ª:('b ã 'c) ã ('a ã 'b) ã ('a  ã 'c)º);
req_infix (300, "o");
req_defn("o",([],ªÉ (f:'b ã 'c) (g:'a ã 'b) (x: 'a) é
	(f o g) x = f(g x)º));
=DESCRIBE
The HOL constant ``$‚o·$'' represents functional composition,
and is given a definition saved under key ``‚o·''.
=ENDDOC
Note that ``o'' is lower case, following literature conventions.
=THDOC
req_const ("S",ª:('a ã 'b ã 'c) ã ('a ã 'b) ã 'a ã 'cº);
req_const ("K",ª:'a ã 'b ã 'aº);
req_const ("I",ª:'a ã 'aº);
req_defn("S",([],ªÉ (f:'a ã 'b ã 'c) (g:'a ã 'b) (x:'a) é
	S f g x = f x (g x)º));
req_defn("K",([],ªÉ (x : 'a) (y : 'b) é K x y = xº));
req_defn("I",([],ªÉ (x : 'a) é I x = xº));
=DESCRIBE
The HOL constant $ª‚S·º$ is the duplication combinator,
$ª‚K·º$ is the deletion combinator,
and $ª‚I·º$ is the identity combinator.
Their definitions are saved under the keys ``‚S·'', ``‚K·'' and ``‚I·''.
=ENDDOC
=THDOC
req_thm("s_k_thm",([],ªÉ x é S K x = Iº));
req_thm("o_assoc_thm",([],ªÉ  (f:'a ã 'b) (g:'c ã 'a) (h :'d ã 'c)é 
	f o (g o h) = (f o g) o hº));
req_thm("o_i_thm",([],ªÉ f : 'a ã 'bé
	((I o f) = f) Ä ((f o I) = f)º));
=DESCRIBE
The theorem ``$‚s\_k\_thm·$'' expresses the relationship between $S$, $K$ and $I$.
The theorem ``$‚o\_assoc\_thm·$'' expresses the associativity of
functional composition.
The theorem ``$‚o\_i\_thm·$'' expresses the fact that $I$ is the left and right identity of $o$.
=ENDDOC
=THDOC
summarize_td_results ();
val combin_success = theory_check_success ();
initialise_td_results true;
=DESCRIBE
We need to do this because we are defining more than just ``min''
in one document.
=ENDDOC
\subsection{Signature of the theory ``combin''}
=DOC
signature ‚CombinTheory· = sig
	val ‚s_defn· : THM;
	val ‚k_defn· : THM;
	val ‚i_defn· : THM;
	val ‚o_defn· : THM;
	val ‚o_assoc_thm· : THM;
end;
=DESCRIBE
In the signature of $CombinTheory$ in which we declare theory ``combin'' we bind the definitions of $S$, $K$, $I$ and $o$ to
$s\_defn$, $k\_defn$, $i\_defn$ and $o\_defn$ respectively.
The theorem  saved with key ``$o\_assoc\_thm$'' is bound to
the ML value of the same name.
=ENDDOC
We do not bind the other theorems of ``combin'' to ML values
because they won't be in common use.
\section{THE THEORY ``sum''}
\subsection{Design of the theory ``sum''}
=THDOC
req_name "sum" (Value "combin");
=DESCRIBE
The theory ``‚sum·'' defines the sum type (i.e. binary disjoint union).
=ENDDOC
=THDOC
req_const("IsSumRep",ª: ('a â 'b â BOOL) ã BOOLº);
req_defn("IsSumRep",([],ªÉ (a:'a) (b:'b) (c:BOOL) é
	IsSumRep (a, b, c) Ç 
	if c 
	then (b = á xéT)
	else (a = á yéT)º));
=DESCRIBE
The representation of a value of type $ª:'a\ +\ 'bº$ is 
by a triple, whose third member indicates whether
the first or second member is the ``real'' value of the type.
This is expressed by the constant $‚IsSumRep·$ whose definition
is saved with key ``‚IsSumRep·''.
=ENDDOC
=THDOC
req_type ("+",2);
req_infix (120,"+");
req_defn("+_TYPE",([],ªÑ f: 'a + 'b ã ('a â 'b â BOOL) é TypeDefn IsSumRep fº));
=DESCRIBE
The HOL type constructor ``$‚+·$'' creates sum types (i.e. binary disjoint union).
Its definition is saved under the key ``$‚+\_TYPE·$'' to
distinguish it from other definitions using $+$.
=ENDDOC
=THDOC
req_const("InL",ª:'a ã 'a + 'bº);
req_const("InR",ª:'b ã 'a + 'bº);
req_const("ProjL",ª:'a + 'b ã 'aº);
req_const("ProjR",ª:'a + 'b ã 'bº);

map (fn nm => 
	req_defn(nm,([],
	ªÉ (x : 'a) (x1 : 'a) (y:'b) (y1:'b) é
		(ProjL(InL x: 'a + 'b) = x) Ä 
		(ProjR(InR y: 'a + 'b) = y) Ä
		(((InL x : 'a + 'b)= InL x1) Ç (x = x1)) Ä
		(((InR y: 'a + 'b) = InR y1) Ç (y = y1)) Ä
		å(InL x : 'a + 'b = InR y) Ä
		å(InR y : 'a + 'b = InL x) Ä
		(É z : 'a + 'b é
		(Ñ x é z = InL x) Å (Ñ y é z = InR y))
	º)))
["InL","InR","ProjL","ProjR"];
=DESCRIBE
The HOL constants $‚InL·$ and $‚InR·$ are the left and right injection
functions for sum types,
and $‚ProjL·$ and $‚ProjR·$ are the left and right injection
functions for sum types.
Their properties are captured in the single definition,
saved under each of the four constants names.
=ENDDOC
=THDOC
req_const("IsL",ª:'a + 'b ã BOOLº);
req_const("IsR",ª:'a + 'b ã BOOLº);
req_defn("IsL",([],
	ªÉ (x:'a) (y:'b) é IsL(InL x:'a + 'b) Ä å IsL(InR y:'a + 'b)º));
req_defn("IsR",([],
	ªÉ (x:'a) (y:'b) é IsR(InR y:'a + 'b) Ä å IsR(InL x:'a + 'b)º));
req_thm("isl_thm",([],ªÉ ab : 'a + 'b é IsL ab ä (Ñ x : 'a é ab = InL x)º));
req_thm("isr_thm",([],ªÉ ab : 'a + 'b é IsR ab ä (Ñ y : 'b é ab = InR y)º));
=DESCRIBE
The HOL constants $‚IsL·$ and $‚IsR·$ are the two discriminators
on type $+$.
Their definitions are saved under the keys ``‚IsL·'' and ``‚IsR·''.
The theorems ``$‚isl\_thm·$'' and ``$‚isr\_thm·$'' 
give the obvious properties if either discriminator is known to be satisfied.
=ENDDOC
=THDOC
summarize_td_results ();
val sum_success = theory_check_success ();
initialise_td_results true;
=DESCRIBE
We need to do this because we are defining more than just ``sum''
in one document.
=ENDDOC
\subsection{Signature of the theory ``sum''}
=DOC
signature ‚SumTheory· = sig
	val ‚sum_clauses· : THM;
	val ‚isl_defn· : THM;
	val ‚isr_defn· : THM;
	val ‚isl_thm· : THM;
	val ‚isr_thm· : THM;	
end;
=DESCRIBE
$sum\_clauses$ is bound to the single definition of $InL$, $InR$,
$ProjL$, $ProjR$.
$isl_defn$ is bound to the definition of $IsL$,
$isr_defn$ is bound to the definition of $IsR$,
$isl_thm$ is bound to the theorem saved with that name as key,
and $isr_thm$ is bound to the theorem saved with that name as key.
=ENDDOC
=TEX
\section{TEST POLICY}
The functions in this document should be tested according to the
general criteria set out in \cite{DS/FMU/IED/PLN008}, using the
tests in \cite{DS/FMU/IED/MDT045}.
The theories produced should be checked by the theory design tools
of \cite{DS/FMU/IED/DTD035}.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
