=IGN
********************************************************************************
mdt116.doc: this file is part of the PPHol system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex

\def\Title{ Quantifier Elimination Toolkit: Module Tests }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document gives the module tests for the 	quantifier elimination toolkit.}
\end{center}}

\def\Reference{LEMMA1/HOL/MDT114}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{1.7%
}
\def\Date{\FormatDate{2002/10/17 16:20:01%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\newpage
\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issue 1.1] First draft (place-holder).
\item[Issue 1.2] First complete version.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}

Lemma 1 build system.

\newpage

\section{INTRODUCTION}
\subsection{Scope}
This document contains the module tests associated with toolkit of conversions etc.
required by \cite{DS/FMU/IED/DTD119} and
implemented in \cite{DS/FMU/IED/IMP119}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD040}.
\subsubsection{Dependencies}
The test material depends on \cite{DS/FMU/IED/DTD013} and \cite{DS/FMU/IED/IMP013}.

\subsubsection{Deficiencies}
None known.
\section{INITIALISATION}
Initialise the test package:
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results ();
=TEX
Utility to help check a conversion: applies the conversion and returns the right-hand side of the conclusion of the result, failing if the conventions for conversions have not been followed.
=SML
fun check_conv conv tm = (
	let	val thm = conv tm;
		val (lhs, rhs) = dest_eq (concl thm);
	in	if	tm = lhs
		andalso	asms thm = []
		then	rhs
		else	concl (fail_conv tm)
	end
);
=TEX
=SML
fun gen_term_fail_msg area num tms = (
	gen_fail_msg area num (map string_of_term tms)
);
=TEX
\section{TEST CASES}
The organisation of the test cases is that each function is tested in turn in the order of appearance in the signature.
For each function, correct operation is tested first and then error behaviour, if appropriate.

\section{THE TESTS}
=SML
store_mt_results
mt_run [
("119.dest_quant.1.1",
	dest_quant,
		¬¶x·x = x®,
			(¬$¶®, ¬x®, ¬x = x®)),
("119.dest_quant.1.2",
	dest_quant,
		¬µ(x, (y, z))·x = y ± y = z ± z = 1®,
			(¬$µ:(î ¸ î ¸ î ­ BOOL) ­ BOOL®, ¬(x:î, (y:î, z:î))®, ¬x = y ± y = z ± z = 1®)),
("119.dest_quant.1.3",
	dest_quant,
		¬¶‰1(x, y)·x = y ± y = 1®,
			(¬$¶‰1:(î ¸ î ­ BOOL) ­ BOOL®, ¬(x:î, y:î)®, ¬x = y ± y = 1®))
];
=TEX
=SML
store_mt_results
mt_run_fail [
("119.dest_quant.2.1",
	dest_quant,
		¬Ìx·x = x®,
			gen_term_fail_msg "dest_quant" 119001 [¬Ìx·x = x®]),
("119.dest_quant.2.2",
	dest_quant,
		¬CombI(Ìx·x = x)®,
			gen_term_fail_msg "dest_quant" 119001 [¬CombI(Ìx·x = x)®])
];
=TEX
=SML
store_mt_results
mt_run [
("119.is_quant.1.1",
	is_quant,
		¬¶x·x = x®,
			true),
("119.is_quant.1.2",
	is_quant,
		¬µ(x, (y, z))·x = y ± y = z ± z = 1®,
			true),
("119.is_quant.1.3",
	is_quant,
		¬¶‰1(x, y)·x = y ± y = 1®,
			true),
("119.is_quant.1.4",
	is_quant,
		mk_t,
			false)
,
("119.is_quant.1.5",
	is_quant,
		¬Ìx·x = 1®,
			false)
,
("119.is_quant.1.6",
	is_quant,
		¬CombI(Ìx·x = 1)®,
			false)
];
=TEX
=SML
store_mt_results
mt_run [
("119.mk_quant.1.1",
	mk_quant,
		(¬$¶®, ¬x®, ¬x = x®),
			¬¶x·x = x®),
("119.mk_quant.1.2",
	mk_quant,
		(¬$µ:(î ¸ î ­ BOOL) ­ BOOL®, ¬(x:î, y:î)®, ¬x = 1 ± y = 2®),
			¬µ(x, y)·x = 1 ± y = 2®)

];
=TEX
=SML
store_mt_results
mt_run_fail [
("119.mk_quant.2.1",
	mk_quant,
		(¬$µ:(î ¸ î ­ BOOL) ­ BOOL®, ¬1®, ¬1 = 1®),
			gen_term_fail_msg "mk_quant" 119003 [¬1®]),
("119.mk_quant.2.2",
	mk_quant,
		(¬$µ:(î ¸ î ­ BOOL) ­ BOOL®, ¬(x:î, y:î)®, ¬1®),
			gen_term_fail_msg "mk_quant" 119004 [¬1®])
];
=TEX
=SML
store_mt_results
mt_run_fail [
("119.FAIL_C.2.1",
	FAIL_C id_conv,
		mk_t,
			gen_term_fail_msg "fail_conv" 7061 [])
];
=TEX
=SML
store_mt_results
mt_run [
("119.find_in_±_conv.1.1",
	check_conv(find_in_±_conv is_eq),
		¬x < 1 ± a = b®,
			¬a = b ± x < 1®),
("119.find_in_±_conv.1.2",
	check_conv(find_in_±_conv is_eq),
		¬x < 1 ± a = b ± c = d®,
			¬a = b ± x < 1 ± c = d®),
("119.find_in_±_conv.1.3",
	check_conv(find_in_±_conv is_eq),
		¬x < 1 ± a < b ± a = 1®,
			¬a = 1 ± x < 1 ± a < b®),
("119.find_in_±_conv.1.4",
	check_conv(find_in_±_conv is_eq),
		¬x < 1 ± y < 1 ± y = b ± b > c ± c < d®,
			¬y = b ± x < 1 ± y < 1 ± b > c ± c < d®),
("119.find_in_±_conv.1.5",
	check_conv(find_in_±_conv is_less),
		¬x = 1 ± y < 1 ± y = b ± b > c ± c < d®,
			¬y < 1 ± x = 1 ± y = b ± b > c ± c < d®)
];
=TEX
=SML
store_mt_results
mt_run_fail [
("119.find_in_±_conv.2.1",
	find_in_±_conv is_eq,
		¬1 = 2 ± 2 = 3®,
			gen_term_fail_msg "find_in_±_conv" 119008 [¬1 = 2 ± 2 = 3®]),
("119.find_in_±_conv.2.2",
	find_in_±_conv is_eq,
		¬1®,
			gen_term_fail_msg "find_in_±_conv" 119008 [¬1®]),
("119.find_in_±_conv.2.3",
	find_in_±_conv is_less,
		¬x = 1 ± y = 2®,
			gen_term_fail_msg "find_in_±_conv" 119008 [¬x = 1 ± y = 2®])
];
=TEX
=SML
val ¤_t_thm = taut_rule¬µp·p ¤ (p ¤ T)®;
val ¤_t_conv : CONV = (fn tm =>
	if	is_¤ tm
	andalso	is_t(snd(dest_¤ tm))
	then	fail_conv tm
	else	simple_eq_match_conv ¤_t_thm tm
);
val ft_conv : CONV = FIRST_THEN_C [
	(¶‰1_conv, (fn c => QUANT_C(PROP_ATOM_C (QUANTS_C c)) THEN_C c)),
	(¶_uncurry_conv, QUANTS_C),
	(µ_uncurry_conv, QUANTS_C),
	(¶_uncurry_conv, QUANTS_C),
	(µ_uncurry_conv, QUANTS_C),
	(QUANT_C ¤_t_conv, ID_C)];
=TEX
=SML
store_mt_results
mt_run [
("119.FIRST_THEN_C.1.1",
	check_conv ft_conv,
		¬¶ (x, y)· x = y®,
			¬(¶ x· (¶ y· x = y ¤ T) ¤ T)®),
("119.FIRST_THEN_C.1.2",
	check_conv ft_conv,
		¬µ(a, b)· ¶ (x, y)· x = y ± x = a ² x = b®,
			¬µ a· (µ b· (¶ x· (¶ y· x = y ± x = a ² x = b ¤ T) ¤ T) ¤ T) ¤ T®),
("119.FIRST_THEN_C.1.3",
	check_conv ft_conv,
		¬¶‰1(x, y)·x = y®,
			¬(¶x· (¶y· x = y ± (µ x'· (µ y'· x' = y' ´ (x', y') = (x, y) ¤ T) ¤ T) ¤ T) ¤ T)®)
];
=TEX
=SML
store_mt_results
mt_run_fail [
("119.FIRST_THEN_C.2.1",
	FIRST_THEN_C [(fail_conv, ID_C)],
		¬1 = 2®,
			gen_term_fail_msg "FIRST_THEN_C" 119010 [¬1 = 2®])
];
=TEX
=SML
store_mt_results
mt_run [
("119.ID_C.1.1",
	check_conv (ID_C ¤_t_conv),
		¬x = y®,
			¬x = y ¤ T®)
];
=TEX
=SML
store_mt_results
mt_run [
("119.INNERMOST_QUANT_C.1.1",
	check_conv (INNERMOST_QUANT_C ¤_t_conv),
		¬¶x·¶y· x = y®,
			¬¶x·(¶y· x = y) ¤ T®),
("119.INNERMOST_QUANT_C.1.2",
	check_conv (INNERMOST_QUANT_C (QUANT_C ¤_t_conv)),
		¬¶x·¶y· x = y ± ¶z·z = x®,
			¬¶x·¶y· x = y ± ¶z·z = x ¤ T ®),
("119.INNERMOST_QUANT_C.1.3",
	check_conv (INNERMOST_QUANT_C (QUANT_C ¤_t_conv)),
		¬(¶x·¶y· x = y) ± ¶z·z = x®,
			¬(¶x·¶y· x = y ¤ T) ± ¶z·z = x ¤ T ®),
("119.INNERMOST_QUANT_C.1.4",
	check_conv (INNERMOST_QUANT_C (QUANT_C ¤_t_conv)),
		¬³((¶x·¶y· x = y) ± ¶z·z = x)®,
			¬³((¶x·¶y· x = y ¤ T) ± ¶z·z = x ¤ T )®),
("119.INNERMOST_QUANT_C.1.5",
	check_conv (INNERMOST_QUANT_C (QUANT_C ¤_t_conv)),
		¬³((¶x·¶y· x = y) ² ¶z·z = x)®,
			¬³((¶x·¶y· x = y ¤ T) ² ¶z·z = x ¤ T )®),
("119.INNERMOST_QUANT_C.1.6",
	check_conv (INNERMOST_QUANT_C (QUANT_C ¤_t_conv)),
		¬³((¶x·¶y· x = y) ² 1 = 2)®,
			¬³((¶x·¶y· x = y ¤ T) ² 1 = 2 )®)
];
=TEX
=SML
store_mt_results
mt_run_fail [
("119.INNERMOST_QUANT_C.2.1",
	INNERMOST_QUANT_C ¤_t_conv,
		¬1 = 2 ± a = b®,
			gen_fail_msg "INNERMOST_QUANT_C" 119011 [])
];
=TEX
=SML
store_mt_results
mt_run [
("119.nnf_conv.1.1",
	check_conv nnf_conv,
		¬³(x ± y ² z)®,
			¬(³x ² ³y) ± ³z®),
("119.nnf_conv.1.2",
	check_conv nnf_conv,
		¬³(x ´ y)®,
			¬x ± ³y®),
("119.nnf_conv.1.3",
	check_conv nnf_conv,
		¬³(x ¤ y)®,
			¬x ± ³y ² ³x ± y®),
("119.nnf_conv.1.4",
	check_conv nnf_conv,
		¬³(x ¤ x)®,
			¬F®),
("119.nnf_conv.1.5",
	check_conv nnf_conv,
		¬³³³³(x ¤ x)®,
			¬T®)
];
=TEX
=SML
store_mt_results
mt_run_fail [
("119.nnf_conv.2.1",
	nnf_conv ,
		¬1 = 2®,
			gen_term_fail_msg "nnf_conv" 119007 [¬1 = 2®]),
("119.nnf_conv.2.2",
	nnf_conv ,
		¬³1 = 2®,
			gen_term_fail_msg "nnf_conv" 119007 [¬³1 = 2®]),
("119.nnf_conv.2.3",
	nnf_conv ,
		¬³1 = 2 ± ³a  = b®,
			gen_term_fail_msg "nnf_conv" 119007 [¬³1 = 2 ± ³a = b®])
];
=TEX
=SML
store_mt_results
mt_run [
("119.PROP_ATOM_C.1.1",
	check_conv (PROP_ATOM_C ¤_t_conv),
		¬³p®,
			¬³(p ¤ T)®),
("119.PROP_ATOM_C.1.2",
	check_conv (PROP_ATOM_C ¤_t_conv),
		¬³p ± q®,
			¬³(p ¤ T) ± (q ¤ T)®),
("119.PROP_ATOM_C.1.3",
	check_conv (PROP_ATOM_C ¤_t_conv),
		¬³p ± q ¤ a ² b®,
			¬³(p ¤ T) ± (q ¤ T) ¤ (a ¤ T) ² (b ¤ T)®)
];
=TEX
=SML
store_mt_results
mt_run [
("119.PROP_LIT_C.1.1",
	check_conv (PROP_LIT_C ¤_t_conv),
		¬³p®,
			¬³p ¤ T®),
("119.PROP_LIT_C.1.2",
	check_conv (PROP_LIT_C ¤_t_conv),
		¬³p ± q®,
			¬(³p ¤ T) ± (q ¤ T)®),
("119.PROP_LIT_C.1.3",
	check_conv (PROP_LIT_C ¤_t_conv),
		¬³p ± q ¤ a ² ³b®,
			¬(³p ¤ T) ± (q ¤ T) ¤ (a ¤ T) ² (³b ¤ T)®)
];
=TEX
=SML
store_mt_results
mt_run [
("119.prop_simp_conv.1.1",
	check_conv prop_simp_conv,
		¬³³³³³³p ± ³p®,
			¬F®),
("119.prop_simp_conv.1.2",
	check_conv prop_simp_conv,
		¬³p ± ³p®,
			¬³p®),
("119.prop_simp_conv.1.3",
	check_conv prop_simp_conv,
¬( ³(³p) ¤ p ) ± ( ³F ¤ T ) ± ( ³T ¤ F ) ±
( F ² p ¤ p ) ± ( p ² F ¤ p ) ± ( T ² p ¤ T ) ± ( p ² T ¤ T ) ±
( p ± F ¤ F ) ± ( F ± p ¤ F ) ± ( T ± p ¤ p ) ± ( p ± T ¤ p ) ±
( p ´ T ¤ T ) ± ( T ´ p ¤ p ) ± ( F ´ p ¤ T ) ± ( p ´ F ¤ ³p ) ±
( (p ¤ T) ¤ p ) ± ( (T ¤ p) ¤ p ) ± ( (F ¤ p) ¤ ³p ) ± ( (p ¤ F) ¤ ³p ) ±
( (p ² p) ¤ p ) ± ( p ± p ¤ p ) ± ( (p ´ p) ¤ T ) ± ( (p ¤ p) ¤ T ) ±
( (p ² ³p) ¤ T ) ± ( p ± ³p ¤ F ) ± ( (p ´ ³p) ¤ ³p ) ± ( (p ¤ ³p) ¤ F ) ±
( (³p ² p) ¤ T ) ± ( ³p ± p ¤ F ) ± ( (³p ´ p) ¤ p ) ± ( (³p ¤ p) ¤ F )®,
			¬T®)
];
=TEX
=SML
store_mt_results
mt_run
[
("119.QUANT_C.1.1", check_conv (QUANT_C ¤_t_conv),
		 ¬¶(x, y)·x = y®,
		 ¬¶(x, y)·x = y ¤ T®),
("119.QUANT_C.1.2", check_conv (QUANT_C ¤_t_conv),
		 ¬µx·¶y·x = y®,
		 ¬µx·(¶y·x = y) ¤ T®),
("119.QUANT_C.1.3", check_conv (QUANT_C ¤_t_conv),
		 ¬¶‰1x·¶y·x = y®,
		 ¬¶‰1x·(¶y·x = y) ¤ T®)
];
=TEX
=SML
store_mt_results
mt_run_fail
[
("119.QUANT_C.2.1", QUANT_C ¤_t_conv,
		 ¬1 = 2®,
		 gen_fail_msg "QUANT_C" 119001 ["¬1 = 2®"])
];
=TEX
=SML
store_mt_results
mt_run
[
("119.QUANTS_C.1.1", check_conv (QUANTS_C ¤_t_conv),
		 ¬¶(x, y)·x = y®,
		 ¬(¶(x, y)·x = y) ¤ T®),
("119.QUANTS_C.1.2", check_conv (QUANTS_C ¤_t_conv),
		 ¬µx·¶y·x = y®,
		 ¬(µx·(¶y·x = y) ¤ T) ¤ T®),
("119.QUANTS_C.1.3", check_conv (QUANTS_C ¤_t_conv),
		 ¬¶‰1x·¶y·x = y®,
		 ¬(¶‰1x·(¶y·x = y) ¤ T) ¤ T®)
];
=TEX
=SML
store_mt_results
mt_run
[
("119.QUANT_MAP_C.1.1", check_conv (QUANT_MAP_C (QUANT_C ¤_t_conv)),
		 ¬(¶(x, y)·x = y) ± µx·¶y·x = y®,
		 ¬(¶(x, y)·x = y ¤ T) ± (µx·(¶y·x = y ¤ T) ¤ T)®)
];
=TEX
=SML
store_mt_results
mt_run
[
("119.simple_µ_³_¶_³_conv.1.1", check_conv simple_µ_³_¶_³_conv,
		 ¬µx·x = y®,
		 ¬³¶x·³x = y®)
];
=TEX
=SML
store_mt_results
mt_run_fail
[
("119.simple_µ_³_¶_³_conv.2.1", simple_µ_³_¶_³_conv,
		 ¬1 = 2®,
		 gen_term_fail_msg "simple_µ_³_¶_³_conv" 119005 [¬1 = 2®])
];
=TEX
=SML
store_mt_results
mt_run
[
("119.simple_¶_const_elim_conv.1.1", check_conv simple_¶_const_elim_conv,
		 ¬¶x·y:'a = y®,
		 ¬y = y®)
];
=TEX
=SML
store_mt_results
mt_run_fail
[
("119.simple_¶_const_elim_conv.2.1", simple_¶_const_elim_conv,
		 ¬1 = 2®,
		 gen_term_fail_msg "simple_¶_const_elim_conv" 119006 [¬1 = 2®]),
("119.simple_¶_const_elim_conv.2.2", simple_¶_const_elim_conv,
		 ¬¶y·y = y®,
		 gen_term_fail_msg "simple_¶_const_elim_conv" 119006 [¬¶y·y = y®])
];
=TEX
=SML
store_mt_results
mt_run
[
("119.simple_one_point_conv.1.1", check_conv simple_one_point_conv,
		 ¬¶x·x = y®,
		 ¬T®),
("119.simple_one_point_conv.1.2", check_conv simple_one_point_conv,
		 ¬¶x·x = y ± p x y®,
		 ¬p y y:BOOL®)
];
=TEX
=SML
store_mt_results
mt_run_fail
[
("119.simple_one_point_conv.2.1", simple_one_point_conv,
		 ¬1 = 2®,
		 gen_term_fail_msg "simple_one_point_conv" 119009 [¬1 = 2®])
];
=TEX
=SML
store_mt_results
mt_run
[
("119.split_±_conv.1.1", check_conv (split_±_conv is_eq),
		 ¬x < 1 ± a = b ± d > 3®,
		 ¬a = b ± x < 1 ± d > 3®),
("119.split_±_conv.1.2", check_conv (split_±_conv is_eq),
		 ¬x < 1 ± a < b ± d > 3 ± a = 1®,
		 ¬a = 1 ± x < 1 ± a < b ± d > 3®),
("119.split_±_conv.1.3", check_conv (split_±_conv is_eq),
		 ¬x < 1 ± a < 2 ± a < b ± d = 3 ± a = 1®,
		 ¬(a = 1 ± d = 3) ± x < 1 ± a < 2 ± a < b®)
];
=TEX
=SML
store_mt_results
mt_run_fail
[
("119.split_±_conv.2.1", check_conv (split_±_conv is_eq),
		 ¬1®,
		 gen_fail_msg "split_±_conv" 119002 ["¬1®"]),
("119.split_±_conv.2.2", check_conv (split_±_conv is_eq),
		 ¬T®,
		 gen_fail_msg "split_±_conv" 119002 ["¬T®"]),
("119.split_±_conv.2.3", check_conv (split_±_conv is_eq),
		 ¬x = 1 ± y = 2®,
		 gen_fail_msg "split_±_conv" 119002 ["¬x = 1 ± y = 2®"]),
("119.split_±_conv.2.4", check_conv (split_±_conv is_eq),
		 ¬x < 1 ± y > 2®,
		 gen_fail_msg "split_±_conv" 119002 ["¬x < 1 ± y > 2®"])
];
(*		
split_±_conv is_eq ¬x < y ± x < 1 ± a = b ± d > 3®;
split_±_conv is_eq ¬x < y ± x < 1®;
split_±_conv is_eq ¬x = y ± x = 1®;
split_±_conv is_eq ¬x = y ± x = 1 ± x = 1®;
split_±_conv is_eq ¬1®;
split_±_conv is_eq ¬mk_t®;
*)
=TEX
\section{END OF TESTS}
=SML
diag_string(summarize_mt_results());
=TEX
\end{document}







