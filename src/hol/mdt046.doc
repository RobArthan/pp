% mdt046.doc  %Z% $Date$ $Id$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for the Constant Specification Tools}  %% Mandatory field
\def\TPPheadtitle{Module Tests for the \cr Constant Specification Tools}
\TPPref{DS/FMU/IED/MDT046}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the 
the constant specification tools.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1]
First draft.
\item [Issue 1.2]
Fixed a bug in $a\_get\_epc\_cs\_¶\_rule$.

\item[Issue 1.3, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.4]
Reacted to change in $HOL\_const\_recogniser$.
\item [Issue 1.5]
Fixed duplicated test identities.
\item [Issue 1.6]
Modified declarations in constant specifications to
be separated by semicolons rather than commas - to
work with the new version hol constant recogniser.
\item[Issue 1.7]
Changed name of parent theory to $basic\_hol$.
\item [Issue 1.8 (26th March 1992)]
Changed to use proof context material of issue 1.13 of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.9 (9th April 1992)]
Changes required by CR0016.
\item [Issue 1.10 (14th April 1992)]
Changes required by CR0017.
\item [Issue 1.11,1.12 (13th May 1992)]
Changed signature of $get\_spec$ et al.
\item [Issue 1.13,1.14 (18th May 1992)]
Changed proof context material.
\item [Issue 1.15 (20th May 1992)]
Rearranging build proof contexts.
\item [Issue 1.17 (22nd May 1992)]
Getting 6062 right.
\item[Issue 1.18 (24th June 1992)]
Renamings from issue 1.6 of \cite{DS/FMU/IED/WRK038},
mostly proof context name changes.
\item[Issue 1.19 (24th July 1992)]
To match detailed design version 1.13.
\item[Issue 1.20 (24th July 1992)]
Changed messages 6056 and 6062.
\item[Issue 1.21,1.22 (3rd December 1992)]
Added $get\_spec$ language processing.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the contant specification tools.
The design is in \cite{DS/FMU/IED/DTD046}
and it is
implemented in \cite{DS/FMU/IED/IMP046}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD046},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD046},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP046}.
\subsubsection{Deficiencies}
None known.
\section{TEST CASES}
We test each function of the signature of \cite{DS/FMU/IED/DTD046}
in turn, where possible in the same order as in the design document, testing both successful, and all error, cases,
except for 6037 and 6071, concerning the writability of theories.
These are untested here because they were extensively tested for the primitive theory functions, elsewhere.
\section{PROLOGUE}
Initialise the test package:
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results();
repeat drop_main_goal;
open_theory "basic_hol";
push_merge_pcs ["'propositions","'paired_abstractions"];

delete_theory "mdttest_046b" handle _ => ();
delete_theory "mdttest_046" handle _ => ();
new_theory "mdttest_046";
new_theory "mdttest_046b";
=TEX
¹HOLCONST
OutOfContext : 'a
÷
T
°
=TEX
=SML
open_theory "mdttest_046";
=TEX
\section{SETTING THE PROOF CONTEXT}
To make the tests independent of some outside changes, we give a local 
proof context:
=SML
val Û¶_rewrite_thm1Ý = (
	push_goal([],¬µ t :'a· (¶ x · x = t) ± (¶ x · t = x)®);
	a(REPEAT strip_tac);
	a(¶_tac ¬t:'a® THEN rewrite_tac[]);
	a(¶_tac ¬t:'a® THEN rewrite_tac[]);
	pop_thm());

fun Ûa_cs_¶_convÝ (tm:TERM) : THM = 
	tac_proof(([],mk_¤(tm,mk_t)),rewrite_tac[¶_rewrite_thm1]);

new_pc "mdt046";
merge_pcs ["'propositions","'paired_abstractions"] "mdt046";
delete_pc_fields ["cs_¶_convs"] "mdt046";
set_cs_¶_convs [a_cs_¶_conv] "mdt046";
push_pc "mdt046";
=TEX
\section{THE TESTS}
\subsection{$HOL\_axiomatic\_recogniser$}
¹HOLCONST
c5 : BOOL ­ BOOL;
c6 : BOOL ­ BOOL
÷
(µ x · c5 x = ³ x)
±
(µ y · c6 y = y)
°
=TEX
¹HOLCONST
c7 : 'a ¸ 'b;
c8 : 'b ¸ 'a
÷
T
°
=TEX
¹HOLCONST
c9 : 'a ¸ 'b
÷
F
°
=TEX

=TEX
=SML
store_mt_results (mt_runf (op =#))[
	("HOL_const_recogniser 1",
	dest_thm o get_defn "-",
	"c5",
	([],¬ConstSpec (Ì(c5',c6')· (µ x · c5' x = ³ x)
		±
		(µ y · c6' y = y)) (c5,c6)®)),
	("HOL_const_recogniser 2",
	dest_thm o get_defn "-",
	"c6",
	([],¬ConstSpec (Ì(c5',c6')· (µ x · c5' x = ³ x)
		±
		(µ y · c6' y = y)) (c5,c6)®)),
	("HOL_const_recogniser 3",
	dest_thm o get_defn "-",
	"c7",
	([],¬T®)),
	("HOL_const_recogniser 4",
	dest_thm o get_defn "-",
	"c8",
	([],¬T®))
	];
=TEX
The following will perhaps change (and also cause some output to the screen):
=SML
store_mt_results mt_run_fail [
	("HOL_const_recogniser 46000",
	HOL_const_recogniser,
	("(",")",[],"[]"),
	gen_fail_msg "HOL_const_recogniser" 46000 [])
	];
=TEX
\subsection{$const\_spec$}
=SML
const_spec (["c1","c2","c3"],[¬c1:BOOL®,¬(c2:BOOL,c3:BOOL)®],
	¬c1 ± c2 ± c3®);
const_spec (["c4"],[¬c4:BOOL®],¬c4 ¤ T®);
=TEX
=SML
store_mt_results (mt_runf (op =#))[
	("const_spec 1",
	dest_thm o get_defn "-",
	"c1",
	([],¬ConstSpec (Ì(c1',c2',c3')·c1' ± c2' ± c3')(c1,c2,c3)®)),
	("const_spec 2",
	dest_thm o get_defn "-",
	"c2",
	([],¬ConstSpec (Ì(c1',c2',c3')·c1' ± c2' ± c3')(c1,c2,c3)®)),
	("const_spec 3",
	dest_thm o get_defn "-",
	"c2",
	([],¬ConstSpec (Ì(c1',c2',c3')·c1' ± c2' ± c3')(c1,c2,c3)®)),
	("const_spec 4",
	dest_thm o get_defn "-",
	"c4",
	([],¬c4 ¤ T®))
	];
=TEX
=SML
store_mt_results mt_run_fail [
	("const_spec 3031",
	const_spec,
	(["ec1"],[¬x®],¬y®),
	gen_fail_msg "const_spec" 3031 ["¬y®"]),
	("const_spec 6031",
	const_spec,
	([],[¬x®],¬T®),
	gen_fail_msg "const_spec" 6031 []),
	("const_spec 6044",
	const_spec,
	(["test"],[],¬T®),
	gen_fail_msg "const_spec" 6044 []),
	("const_spec 6049",
	const_spec,
	(["test"],[mk_var("T",BOOL)],¬T®),
	gen_fail_msg "const_spec" 6049 ["T"]),
	("const_spec 6051",
	const_spec,
	(["c1"],[¬v1®],¬T®),
	gen_fail_msg "const_spec" 6051 ["c1","mdttest_046"]),
	("const_spec 6056",
	const_spec,
	(["ec1"],[¬ec1®],¬var:BOOL®),
	gen_fail_msg "const_spec" 6056 
		["var","¬¶ ec1· var®"]),
	("const_spec 6062",
	const_spec,
	(["ec1"],[¬ec1®],¬var:BOOL = var1®),
	gen_fail_msg "const_spec" 6062 ["var1, var", 
		"¬¶ ec1· var ¤ var1®"]),
	("const_spec 6061",
	const_spec,
	(["ec1"],[¬ec1®],¬µ x : 'b · x = x®),
	gen_fail_msg "const_spec" 6061 ["ô ¶ ec1· µ x· x = x", "'b"]),
	("const_spec 6063",
	const_spec,
	(["OutOfContext"],[¬OutOfContext®],¬T®),
	gen_fail_msg "const_spec" 6063 ["OutOfContext"]),
	("const_spec 6081",
	const_spec,
	(["ec1","ec2"],[¬ec1,ec2®],¬T®),
	gen_fail_msg "const_spec" 6081 ["¬ec1®","¬ec2®"]),
	("const_spec 46003",
	const_spec,
	(["ec1","ec2"],[¬ec1, ec1®],¬T®),
	gen_fail_msg "const_spec" 46003 ["ec1"]),
	("const_spec 46004",
	const_spec,
	(["ec1","ec2"],[¬(ec1, T)®],¬T®),
	gen_fail_msg "const_spec" 46004 ["¬(ec1, T)®"])	
	];
=TEX
\subsection{$get\_spec$ Part I}
Preparation for axiomatic lookup for $get\_spec$:
=SML
new_const("AxiomDefined",BOOL);
new_axiom(["AxiomDefined"],¬AxiomDefined ¤ T®);
const_spec(["AxiomConsistent"],[¬AxiomConsistent:BOOL ­ BOOL®],¬AxiomConsistent T ± F®);
new_axiom(["AxiomConsistent_consistent"],¬Consistent AxiomConsistent®);
=TEX
=SML
store_mt_results (mt_runf (op =#))[
	("get_spec 1",
	dest_thm o get_spec,
	¬c1®,
	([¬Consistent (Ì(c1',c2',c3')·c1' ± c2' ± c3')®],
		¬c1 ± c2 ± c3®)),
	("get_spec 2",
	dest_thm o get_spec,
	¬c2®,
	([¬Consistent (Ì(c1',c2',c3')·c1' ± c2' ± c3')®],
		¬c1 ± c2 ± c3®)),
	("get_spec 3",
	dest_thm o get_spec,
	¬c3®,
	([¬Consistent (Ì(c1',c2',c3')·c1' ± c2' ± c3')®],
		¬c1 ± c2 ± c3®)),
	("get_spec 4",
	dest_thm o get_spec,
	¬c4®,
	([],¬c4 ¤ T®)),
	("get_spec 5",
	dest_thm o get_spec,
	¬AxiomDefined®,
	([],¬AxiomDefined ¤ T®)),
	("get_spec 6",
	dest_thm o get_spec,
	¬AxiomConsistent®,
	([¬Consistent (Ì AxiomConsistent'· AxiomConsistent' T ± F)®],¬AxiomConsistent T ± F®)),
	("get_spec 7",
	dest_thm o get_spec,
	¬AxiomConsistent F®,
	([¬Consistent (Ì AxiomConsistent'· AxiomConsistent' T ± F)®],¬AxiomConsistent T ± F®))
	];

=TEX
=SML
store_mt_results mt_run_fail [
	("get_spec 46009",
	get_spec,
	¬rubbish®,
	gen_fail_msg "get_spec" 46009 ["¬rubbish®"]),
	("get_spec 46005",
	get_spec,
	(mk_const ("rubbish",BOOL)),
	gen_fail_msg "get_spec" 46005 ["rubbish"]),
	("get_spec 46006",
	get_spec,
	¬$´®,
	gen_fail_msg "get_spec" 46006 ["´"])
	];
=TEX
\subsection{$push\_consistency\_goal$}
=SML
push_consistency_goal ¬c2®;
store_mt_results (mt_runf (op =#))[
	("push_consistency_goal",
	top_goal,
	(),
	([],¬¶ (c1', c2', c3') · c1' ± c2' ± c3'®))
	];

store_mt_results mt_run_fail [
	("push_consistency_goal 46009",
	push_consistency_goal,
	¬rubbish®,
	gen_fail_msg "push_consistency_goal" 46009 ["¬rubbish®"]),
	("push_consistency_goal 46005",
	push_consistency_goal,
	mk_const("rubbish",BOOL),
	gen_fail_msg "push_consistency_goal" 46005 ["rubbish"]),
	("push_consistency_goal 46006",
	push_consistency_goal,
	¬$´®,
	gen_fail_msg "push_consistency_goal" 46006 ["´"]),
	("push_consistency_goal 46007",
	push_consistency_goal,
	¬c4®,
	gen_fail_msg "push_consistency_goal" 46007 ["c4"])
	];
=TEX
\subsection{$save\_consistency\_thm$}
=SML
a(¶_tac ¬(T,T,T)®);
a(rewrite_tac[]);
val thm = pop_thm();
save_consistency_thm ¬c3® thm;
store_mt_results (mt_runf (op =#))[
	("save_consistency_thm",
	dest_thm o get_thm "-",
	"c2_consistent",
	([],¬Consistent (Ì(c1',c2',c3')·c1' ± c2' ± c3')®))
	];
=TEX
=SML
store_mt_results mt_run_fail [
	("save_consistency_thm 46009",
	save_consistency_thm ¬rubbish®,
	thm,
	gen_fail_msg "save_consistency_thm" 46009 ["¬rubbish®"]),
	("save_consistency_thm 46005",
	save_consistency_thm (mk_const("rubbish",BOOL)),
	thm,
	gen_fail_msg "save_consistency_thm" 46005 ["rubbish"]),
	("save_consistency_thm 46006",
	save_consistency_thm ¬$´®,
	thm,
	gen_fail_msg "save_consistency_thm" 46006 ["´"]),
	("save_consistency_thm 46008",
	save_consistency_thm ¬c2®,
	t_thm,
	gen_fail_msg "save_consistency_thm" 46008 ["¬T®"]),
	("save_consistency_thm 46011",
	save_consistency_thm ¬c5®,
	thm,
	gen_fail_msg "save_consistency_thm" 46011 
		["ô Consistent (Ì (c1', c2', c3')· c1' ± c2' ± c3')",
		"c5"]),
	("save_consistency_thm 46012",
	save_consistency_thm ¬c4®,
	thm,
	gen_fail_msg "save_consistency_thm" 46012 ["¬c4 ¤ T®"])
	];
=TEX
Now to try applications to arguments:
=SML
const_spec (["C1"],[¬C1 : BOOL ­ BOOL®],
	¬µ x:BOOL · C1 x ± F®);
push_consistency_goal ¬C1 T®;
store_mt_results (mt_runf (op =#))[
	("push_consistency_goal 1",
	top_goal,
	(),
	([],¬¶ C1' · µ x :BOOL · C1' x ± F®))
	];
a(accept_tac(new_axiom(["Total rubbish"],¬¶ C1' · µ x:BOOL · C1' x ± F®)));
save_consistency_thm ¬C1 T® (pop_thm());
store_mt_results (mt_runf (op =#))[
	("save_consistency_thm 1",
	dest_thm o get_thm "-",
	"C1_consistent",
	([],¬Consistent (Ì C1'· µ x:BOOL · C1' x ± F)®))
	];
=TEX

\subsection{$get\_spec$ Part II}
Now we have a consistency property saved we can use it:
=SML
store_mt_results (mt_runf (op =#))[
	("get_spec 1 a",
	dest_thm o get_spec,
	¬c1®,
	([], ¬c1 ± c2 ± c3®)),
	("get_spec 2 a",
	dest_thm o get_spec,
	¬c2®,
	([], ¬c1 ± c2 ± c3®))
	];
=TEX
Language Processing:
=SML
simple_new_defn (["const1"],"HOL'const1",mk_t);
store_mt_results (mt_runf (op =#))[
	("get_spec language 1",
	dest_thm o get_spec,
	¬HOL'const1®,
	([],¬HOL'const1 ¤ T®))];
simple_new_defn (["const2"],"HoL'const2",mk_t);
store_mt_results (mt_runf (op =#))[
	("get_spec language 2",
	dest_thm o get_spec,
	¬HoL'const2®,
	([],¬HoL'const2 ¤ T®))];
set_current_language "HOL'2";
simple_new_defn(["2'const1"],"HOL'2'const1",mk_f);
declare_const_language ("HOL'2'const1","HOL");
store_mt_results mt_run_fail [(
	"get_spec 46013",
	get_spec,
	¬HOL'2'const1®,
	gen_fail_msg "get_spec" 46013 
		["HOL'2'const1",
		format_list string_of_thm 
		[get_defn "-" "const1",
		get_defn "-" "2'const1"] ", "])];
=TEX
More such:
=SML
val lthy = get_current_theory_name();
delete_theory "Ztemp" handle (Fail _) => ();
new_theory "Ztemp";
set_current_language "Z";
const_spec (["AnExample"],[mk_var("z'AnExample",BOOL)],mk_f);
get_spec ¬z'AnExample®;
push_consistency_goal ¬z'AnExample®;
a(rewrite_tac[new_axiom(["temp"],mk_f)]);
store_mt_results (mt_runf (op =#))
	[("language-processing 1",
	dest_thm o save_consistency_thm ¬z'AnExample®,
	pop_thm(),
	([],¬Consistent (Ì z'AnExample':BOOL· F)®))
	];
store_mt_results (mt_runf (op =#)) 
	[("language-processing 2",
	dest_thm o get_spec,
	¬z'AnExample®,
	([],mk_f))
	];
store_mt_results mt_run_fail [
	("get_defn without z'",
	get_defn "-",
	"z'AnExample",
	gen_fail_msg "get_defn" 12004 ["-","z'AnExample"])
	];
open_theory lthy;
delete_theory "Ztemp";
=TEX
=IGN
\subsection{}
store_mt_results mt_run [
	("",
	,
	,
	)
	];
store_mt_results mt_run_fail [
	("",
	,
	,
	gen_fail_msg ""  [])
	];
=TEX
\subsection{End of Tests}
=SML
diag_string(summarize_mt_results());
delete_pc "mdt046";
=TEX
\end{document}


