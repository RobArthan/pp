=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation of Proof Contexts}
\TPPref{DS/FMU/IED/IMP051}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives an implementation providing proof contexts.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First draft version.
\item [Issue 1.2]
Made default conversions $fail\_conv$.
Reacted to $NetTools$ being open.
\item [Issue 1.3]
Moved to using abstract data types.
\item [Issue 1.4]
Added $cs\_∂\_conv$ material.
\item [Issue 1.5]
Added existence prover parameterisation.

\item[Issue 1.6, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.7]
Changes to reflect issue 1.12 of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.8 (1st April 1992)]
Changes required by CR0016.
\item [Issue 1.11 (13th April 1992)]
Changes due to CR0017.

\end{description}
\subsection{Changes Forecast}
As detailed design.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for material
whose detailed design is given in in \cite{DS/FMU/IED/DTD051}.
It is module tested in \cite{DS/FMU/IED/MDT051}
\subsection{Introduction}
\subsubsection{Purpose and Background}
A proof context is a setting of various configurable
parameters of proof tools to support a particular mode of proof.
For instance, both $rewrite\_tac$ and $strip\_tac$ 
are configurable proof tools.
In particular, proof contexts will be later made available,
through the tools supplied here,
that supply a good environment to reason about Z,
or within a particular theory (e.g. set theory),
and alter the default environment.

\subsubsection{Dependencies}
This document is dependent on \cite{DS/FMU/IED/DTD051}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
As detailed design.
\section{PREAMBLE}
=SML
val lthy = get_current_theory_name();
open_theory "min";
=SML
structure €ProofContext› : ProofContext = struct
=TEX
\section{UTILITIES}
=SML
val €thm_union› : THM list -> THM list -> THM list = 
	union (op =|-);
=TEX
As $roverwrite$ but prefix, and putting new entries at the head:
=SML
fun €roverwrite1› lst (a,b) = (
let fun aux [] = fail "" 0 []
| aux ((x,y) :: rest) = (
	if b = y
	then ((a,b) :: rest)
	else ((x,y) :: aux rest)
);
in
	aux lst
	handle complaint =>
	((a,b) :: lst)
end);
=TEX
=SML
fun €list_roverwrite1› (abs : ('a * ''b) list) (xys : ('a * ''b) list) : ('a * ''b) list = (
	fold (fn (l1, l2) => roverwrite1 l2 l1) abs xys
);
=IGN
list_roverwrite1 [(1,"1"),(3,"3"),(4,"3"),(5,"5")] [(2,"2"),(0,"5"),(4,"4")];
=TEX
\section{EQUATIONAL CONTEXTS}
An equational context is a list of conversions,
each paired with term index. It represents a statement of
how to
rewrite a term to result in an equational theorem,
guided by the outermost form of the term to be rewritten,
which is matched against the term index of each conversion.
=SML
type €EQN_CXT› = (TERM * CONV) list;
=TEX
In the following, if $simple\_eq\_match\_conv1$
is successfully applied, then the term destruction
but be successful.
=SML
fun €thm_eqn_cxt› (thm : THM) : (TERM * CONV) = (
let	val cnv =  simple_eq_match_conv1 thm
		handle complaint =>
		pass_on complaint "simple_eq_match_conv1" "thm_eqn_cxt";
	val lhs = fst(dest_eq(snd(strip_µ (concl thm))));
in
	(lhs, cnv)
end);
=TEX
=SML
local
	fun FIRST_CHANGED_C (cv :: rest) tm =
		(CHANGED_C cv ORELSE_C FIRST_CHANGED_C rest) tm
	| FIRST_CHANGED_C [] tm = term_fail "eqn_cxt_conv" 51005 [tm];
in
fun €eqn_cxt_conv› (ec : EQN_CXT) : CONV = (
let	val net = make_net ec;
in
	(fn tm => FIRST_CHANGED_C(net_lookup net tm)tm
	)
end);
end;
=TEX

\section{TYPES}
The following is the object stored in the stack and database of proof contexts.
=SML
type €PROOF_CONTEXT› = {
	rw_eqn_cxt: (EQN_CXT * string)list,
	rw_canons: ((THM -> THM list) list * string)list,
				(* CANON list * ... *)
	st_eqn_cxt: (EQN_CXT * string) list,
	sg_eqn_cxt: (EQN_CXT * string) list,
	cs_∂_convs: (CONV list * string) list,
	∂_cd_thms: THM list,
	∂_vs_thms: (string * (TERM list * THM)) list,
=TEX
Now the evaluated parts:
=SML
	rw_net: CONV NET,
	rw_canon: THM -> THM list,	(* CANON *)
	st_conv: CONV,
	sg_conv: CONV,
	cs_∂_conv: TERM -> THM,
	∂_ad_cd_thms:  (TERM list * int list * TYPE * (TERM list)list * THM) list,
	∂_ad_vs_thms:  (string * (TERM list * THM)) list,
=TEX
And finally the commital data
=SML
	names : string list,
	theoryname : string,
	a_valid_thm : THM,
	committed : bool
	};
=TEX
$a\_valid\_thm$ is intended to be set to a theorem generated 
at the creation of the proof context, and if that is not valid (by $valid\_thm$) then the proof context itself is considered ``stale''.
\section{DATA STRUCTURES AND ABSTRACT DATA TYPES}
\subsection{Proof Context ``initial''}
=SML
fun €empty_pc› (committed : bool)(names : string list): PROOF_CONTEXT = {
	rw_eqn_cxt = [],
	rw_canons = [],
	st_eqn_cxt = [],
	sg_eqn_cxt = [],
	cs_∂_convs = [],
	∂_cd_thms = [],
	∂_vs_thms = [],
=TEX
Now the evaluated parts:
=SML
	rw_net = empty_net,
	rw_canon = (fn thm => [thm]),	(* CANON *)
	st_conv = fail_conv,
	sg_conv = fail_conv,
	cs_∂_conv = (fn _ => fail "icl'set_eval_ad_cs_∂_convs" 51015 []),
	∂_ad_cd_thms = [],
	∂_ad_vs_thms = [],
=TEX
And finally the commital data
=SML
	names = names,
	theoryname = get_current_theory_name(),
	a_valid_thm = icl'Kernel.icl'refl_conv (mk_var("a",BOOL)),
	committed = committed
	};
=TEX
Now the initial proof context (local only):
=SML
val €initial_pc› = empty_pc true ["initial"];
=TEX
\subsection{Database of Proof Contexts}
Unsurprisingly, this is a simple dictionary, stored in an assignable variable.
=SML
local
	val pc_db : (PROOF_CONTEXT S_DICT) ref = ref (
		s_enter "initial" initial_pc initial_s_dict);
in
=TEX
Local declarations:
=SML
fun €get_pc› (caller: string) (key : string) : PROOF_CONTEXT = (
	case s_lookup key (!pc_db) of
	Value (pc as {a_valid_thm = a_valid_thm,theoryname=theoryname,...}) => (
		if valid_thm a_valid_thm
		then pc
		else fail caller 51014 [(fn () => key),(fn () => theoryname)]
	) | Nil => fail caller 51010 [fn () => key]
);

fun €extend_pc› (caller: string) (key : string) (pc : PROOF_CONTEXT) : unit = ((
	pc_db := s_extend key pc (!pc_db);
	())
	handle (Fail _) =>
	fail caller 51011 [fn () => key]
);

fun €change_pc› (caller: string) (key : string) 
	(pcf : PROOF_CONTEXT -> PROOF_CONTEXT) : unit = (
let	val opc as {committed = committed,...} = get_pc caller key;
	val sideeeffect = if committed 
		then fail caller 51016 [fn () => key]
		else ();
in
	(pc_db := s_enter key (pcf opc) (!pc_db);
	())
end);
=TEX
Seen in signature:
=SML
local
	fun detail (key,({theoryname = theoryname,
		a_valid_thm = a_valid_thm, ...}:PROOF_CONTEXT)) = (
		if valid_thm a_valid_thm
		then (key,theoryname)
		else (key,get_error_message 51018 [theoryname])
	);
in
fun €show_pcs› () : (string * string)list = (
	map detail (!pc_db)
);
end;
=TEX
Seen in signature:
=SML
fun €delete_pc› (key : string) :unit = (
	if key = "initial"
	then fail "delete_pc" 51012 []
	else (
	case s_lookup key (!pc_db) of
	Value _ => (
		pc_db := s_delete key (!pc_db);
		()
	) | Nil => fail "delete_pc" 51010 [fn () => key])
);
=TEX
=SML
fun €new_pc› (new: string) : unit = (
	extend_pc "new_pc" new (empty_pc false [new])
);
=TEX
End of database functions
=SML
end;
=TEX
\subsection{Proof Context Stack}
The current proof context is not actually on the proof context
stack, but separate.
=SML
local
	val pc_stack : (PROOF_CONTEXT list) ref = ref [];
in
fun push_pc_stack pc = (pc_stack := (pc :: (!pc_stack));());
fun pop_pc_stack caller = (
	case (!pc_stack) of
	[] => fail caller 51001 []
	| (a :: x) => (pc_stack := x; a)
);
local
	fun detail (({theoryname = theoryname,
		a_valid_thm = a_valid_thm, names = names, ...}:PROOF_CONTEXT)) = (
		if valid_thm a_valid_thm
		then (names,theoryname)
		else (names,get_error_message 51018 [theoryname])
	);
in
fun €show_stack_pcs› () : (string list * string)list = (
	map detail (!pc_stack)
);
end;
end; (* of local pc_stack *)
=TEX
\subsection{Current Proof Context}
=SML
local
	val current_pc : PROOF_CONTEXT ref = ref initial_pc;
	val ad_rw_net = ref (#rw_net initial_pc);
	val ad_rw_canon = ref (#rw_canon initial_pc);
	val ad_st_conv = ref (#st_conv initial_pc);
	val ad_sg_conv = ref (#sg_conv initial_pc);
	val ad_cs_∂_convs = ref (#cs_∂_conv initial_pc);
	val ad_∂_ad_cd_thms = ref (#∂_ad_cd_thms initial_pc);
	val ad_∂_ad_vs_thms = ref (#∂_ad_vs_thms initial_pc);
in
=TEX
Set the current proof context:
=SML
fun set_current_pc pc = (
	current_pc := pc;
	ad_rw_net := (#rw_net pc);
	ad_rw_canon := (#rw_canon pc);
	ad_st_conv := (#st_conv pc);
	ad_sg_conv := (#sg_conv pc);
	ad_cs_∂_convs := (#cs_∂_conv pc);
	ad_∂_ad_cd_thms := (#∂_ad_cd_thms pc);
	ad_∂_ad_vs_thms := (#∂_ad_vs_thms pc);
	()
);
=TEX
Access the current proof context:
=SML
fun €current_ad_rw_net› ():CONV NET = (!ad_rw_net);
fun €current_ad_rw_canon› ():THM -> THM list = (!ad_rw_canon);
fun €current_ad_st_conv› ():CONV = (!ad_st_conv);
fun €current_ad_sg_conv› ():CONV = (!ad_sg_conv);
fun €current_ad_cs_∂_conv› ():TERM -> THM = (!ad_cs_∂_convs);
fun €current_ad_∂_cd_thms› ()
	: (TERM list * int list * TYPE * (TERM list)list * THM) list
	= (!ad_∂_ad_cd_thms);
fun €current_ad_∂_vs_thms› ():(string * (TERM list * THM)) list 
	= (!ad_∂_ad_vs_thms);

fun €show_current_pc› () : (string list * string) = (
	if valid_thm (#a_valid_thm (!current_pc))
	then ((#names (!current_pc)),(#theoryname (!current_pc)))
	else ((#names (!current_pc)),get_error_message 51018 [(#theoryname (!current_pc))])
);

fun €get_current_pc› () = (!current_pc);
=TEX
End of current proof context stuff:
=SML
end;
=TEX
\subsection{Evaluation Functions}
We cannot express $eval\_ad\_rw\_canon$ properly yet.
=SML
local
val eval_ad_rw_net : (EQN_CXT -> CONV NET) ref = ref make_net;
val eval_ad_rw_canon : ((THM -> THM list) list -> (THM -> THM list)) ref = 
	ref (fn _ => fn thm => [thm]);
val eval_ad_st_conv : (EQN_CXT -> CONV) ref = ref eqn_cxt_conv;
val eval_ad_sg_conv : (EQN_CXT -> CONV) ref = ref eqn_cxt_conv;

local
	fun try_all [] = (fn tm => fail "current_ad_cs_∂_conv" 51015 [])
	| try_all (afun :: []) = afun
	| try_all (afun :: rest) = afun AND_OR_C (try_all rest);
in
val eval_ad_cs_∂_convs : (CONV list -> CONV) ref = ref try_all;
end;
	
val eval_ad_∂_ad_cd_thms : (THM list -> 
	(TERM list * int list * TYPE * (TERM list)list * THM) list) ref = 
	ref (fn _ => []);
val eval_ad_∂_ad_vs_thms : ((string * (TERM list * THM)) list ->
	(string * (TERM list * THM)) list) ref = ref Combinators.I;
in
fun €icl'set_eval_ad_rw_net› (f:(EQN_CXT -> CONV NET)) : unit =
	(eval_ad_rw_net := f; ());
fun €icl'set_eval_ad_rw_canon› (f:((THM -> THM list) list -> 
	(THM -> THM list))) : unit =
	(eval_ad_rw_canon := f; ());
fun €icl'set_eval_ad_st_conv› (f:(EQN_CXT -> CONV)) : unit = 
	(eval_ad_st_conv := f; ());
fun €icl'set_eval_ad_sg_conv› (f:(EQN_CXT -> CONV)) : unit =
	(eval_ad_sg_conv := f; ());
fun €icl'set_eval_ad_cs_∂_convs› (f:(CONV list -> CONV)) =
	(eval_ad_cs_∂_convs := f; ());
fun €icl'set_eval_ad_∂_cd_thms› (f:(THM list -> 
	(TERM list * int list * TYPE * (TERM list)list * THM) list)) =
	(eval_ad_∂_ad_cd_thms := f; ());
fun €icl'set_eval_ad_∂_vs_thms› (f:((string * (TERM list * THM)) list ->
	(string * (TERM list * THM)) list)) =
	(eval_ad_∂_ad_vs_thms := f; ());
=TEX
Now the method of evaluating a proof context:
=SML
fun €evaluate_proof_context› (
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
	: PROOF_CONTEXT) : PROOF_CONTEXT = 
	{
	rw_eqn_cxt = rw_eqn_cxt,
	rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt,
	sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs,
	∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms,
	rw_net = (!eval_ad_rw_net) (flat(map fst rw_eqn_cxt)),
	rw_canon = (!eval_ad_rw_canon) (flat(map fst rw_canons)),
	st_conv = (!eval_ad_st_conv) (flat(map fst st_eqn_cxt)),
	sg_conv = (!eval_ad_sg_conv) (flat(map fst sg_eqn_cxt)),
	cs_∂_conv = (!eval_ad_cs_∂_convs) (flat(map fst cs_∂_convs)),
	∂_ad_cd_thms = (!eval_ad_∂_ad_cd_thms) ∂_cd_thms,
	∂_ad_vs_thms  = (!eval_ad_∂_ad_vs_thms) ∂_vs_thms,
	names = names,
	theoryname = theoryname,
	a_valid_thm = a_valid_thm,
	committed = committed};
=TEX
End of evaluating things.
=SML
end;
=TEX
\section{OTHER FUNCTIONS}
\subsection{Setting and Getting User Data}
\subsubsection{Rewriting Equations Context}
=SML
fun €set_rw_eqn_cxt› (ec:EQN_CXT) (key:string) : unit =  (
change_pc "set_rw_eqn_cxt" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = roverwrite1 rw_eqn_cxt (ec,key), rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun €get_rw_eqn_cxt› (key:string) : (EQN_CXT * string) list = (
	#rw_eqn_cxt (get_pc "get_rw_eqn_cxt" key)
);
=TEX
In adding the theorems we canonicalise them by what the
proof context would evaluate as its current canonicalisation.
=SML
fun €add_rw_thms› (thms:THM list) (key:string) : unit =  (
change_pc "add_rw_thms" key 
((fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}:PROOF_CONTEXT
 =>
	let val cthms = map thm_eqn_cxt(flat (map rw_canon thms));
	in
	{
	rw_eqn_cxt = (case rassoc5 rw_eqn_cxt key of
		Value x => roverwrite1 rw_eqn_cxt ((cthms @ x),key)
		| Nil =>  ((cthms, key) :: rw_eqn_cxt)), 
	rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
	end)
o
evaluate_proof_context)
);
=TEX
\subsubsection{Rewriting Canonicalisation}
=SML
fun €set_rw_canons› (can: (THM -> THM list) list) (key:string) : unit =  (
change_pc "set_rw_canons" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = roverwrite1 rw_canons (can,key),
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun €get_rw_canons› (key:string) : ((THM -> THM list) list * string) list = (
	#rw_canons (get_pc "get_rw_canons" key)
);
=TEX
\subsubsection{Theorem Stripping Equational Context}
=SML
fun €set_st_eqn_cxt› (ec:EQN_CXT) (key:string) : unit =  (
change_pc "set_st_eqn_cxt" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = roverwrite1 st_eqn_cxt (ec,key), sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun €get_st_eqn_cxt› (key:string) : (EQN_CXT * string) list = (
	#st_eqn_cxt (get_pc "get_st_eqn_cxt" key)
);
=TEX
In adding the theorems we canonicalise them by what the
proof context would evaluate as its current canonicalisation.
=SML
fun €add_st_thms› (thms:THM list) (key:string) : unit =  (
change_pc "add_st_thms" key 
((fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}:PROOF_CONTEXT
 =>
	let val cthms = map thm_eqn_cxt(flat (map rw_canon thms));
	in
	{
	rw_eqn_cxt = rw_eqn_cxt, 
	rw_canons = rw_canons,
	st_eqn_cxt = (case rassoc5 st_eqn_cxt key of
		Value x => roverwrite1 st_eqn_cxt ((cthms @ x),key)
		| Nil =>  ((cthms, key) :: st_eqn_cxt)), 
	sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
	end)
o
evaluate_proof_context)
);
=TEX
\subsubsection{Goal Stripping Equational Context}
=SML
fun €set_sg_eqn_cxt› (ec:EQN_CXT) (key:string) : unit =  (
change_pc "set_sg_eqn_cxt" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = roverwrite1 sg_eqn_cxt (ec,key),
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun €get_sg_eqn_cxt› (key:string) : (EQN_CXT * string) list = (
	#sg_eqn_cxt (get_pc "get_sg_eqn_cxt" key)
);
=TEX
=SML
fun €add_sg_thms› (thms:THM list) (key:string) : unit =  (
change_pc "add_sg_thms" key 
((fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}:PROOF_CONTEXT
 =>
	let val cthms = map thm_eqn_cxt(flat (map rw_canon thms));
	in
	{
	rw_eqn_cxt = rw_eqn_cxt, 
	rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, 
	sg_eqn_cxt = (case rassoc5 sg_eqn_cxt key of
		Value x => roverwrite1 sg_eqn_cxt ((cthms @ x),key)
		| Nil =>  ((cthms, key) :: sg_eqn_cxt)),
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
	end)
o
evaluate_proof_context)
);
=TEX

\subsubsection{Automated Existence Provers}
=SML
fun €set_cs_∂_convs› (rls : CONV list) (key:string) : unit =  (
change_pc "set_cs_∂_convs" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = roverwrite1 cs_∂_convs (rls,key), ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun €get_cs_∂_convs› (key:string) : (CONV list * string) list = (
	#cs_∂_convs (get_pc "get_cs_∂_convs" key)
);
=TEX
\subsubsection{Clausal Definition Theorems}
=SML
fun €set_∂_cd_thms› (cd : THM list) (key:string) : unit =  (
change_pc "set_∂_cd_thms" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = cd,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun €get_∂_cd_thms› (key:string) : THM list = (
	#∂_cd_thms (get_pc "get_∂_cd_thms" key)
);
=TEX
=SML
fun €add_∂_cd_thms› (thms:THM list) (key:string) : unit =  (
change_pc "add_∂_cd_thms" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}:PROOF_CONTEXT
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, 
	rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, 
	sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, 
	∂_cd_thms = thm_union thms ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
	)
);
=TEX
\subsubsection{Variable Structure Theorems}
=SML
local
fun list_eq (a :: x) (b :: y) = a =$ b andalso list_eq x y
| list_eq [] [] = true
| list_eq _ _ = false;

val union_bits = union (fn ((str1,(tml1,thm1)) ,(str2,(tml2,thm2))) =>
	str1 = str2 andalso (list_eq tml1 tml2) andalso (thm1 =|- thm2))
in
fun €set_∂_vs_thms› (vs : (string * (TERM list * THM))list) (key:string) : unit =  (
change_pc "set_∂_vs_thms" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = union_bits ∂_vs_thms vs, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
end;
fun €get_∂_vs_thms› (key:string) : (string * (TERM list * THM))  list = (
	#∂_vs_thms (get_pc "get_∂_vs_thms" key)
);
=TEX

\subsection{Functions upon Proof Contexts}
=SML
fun €commit_pc› (key:string) : unit =  (
change_pc "commit_pc" key 
((fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = true})
o evaluate_proof_context)
);
=TEX
N.B. the second of the pair is ``the master'', to which the first is added in.
=SML
local
fun list_eq (a :: x) (b :: y) = a =$ b andalso list_eq x y
| list_eq [] [] = true
| list_eq _ _ = false;

val union_bits = union (fn ((str1,(tml1,thm1)) ,(str2,(tml2,thm2))) =>
	str1 = str2 andalso (list_eq tml1 tml2) andalso (thm1 =|- thm2))
in
fun €local_merge_pc› (caller:string) (test_committed:bool) (({
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}:PROOF_CONTEXT),
	({
	rw_eqn_cxt = rw_eqn_cxt1, rw_canons = rw_canons1,
	st_eqn_cxt = st_eqn_cxt1, sg_eqn_cxt = sg_eqn_cxt1,
	cs_∂_convs = cs_∂_convs1, ∂_cd_thms = ∂_cd_thms1,
	∂_vs_thms = ∂_vs_thms1, rw_net = rw_net1,
	rw_canon = rw_canon1, st_conv = st_conv1,
	sg_conv = sg_conv1, cs_∂_conv = cs_∂_conv1,
	∂_ad_cd_thms = ∂_ad_cd_thms1, ∂_ad_vs_thms  = ∂_ad_vs_thms1,
	names = names1, theoryname = theoryname1,
	a_valid_thm = a_valid_thm1, committed = committed1}:PROOF_CONTEXT
)) : PROOF_CONTEXT = (
	if test_committed andalso not committed
	then fail caller 51017 [fn () => hd names]
	else
	{
	rw_eqn_cxt = list_roverwrite1 rw_eqn_cxt rw_eqn_cxt1,
	rw_canons = list_roverwrite1 rw_canons rw_canons1,
	st_eqn_cxt = list_roverwrite1 st_eqn_cxt st_eqn_cxt1,
	sg_eqn_cxt = list_roverwrite1 sg_eqn_cxt sg_eqn_cxt1,
	cs_∂_convs = list_roverwrite1 cs_∂_convs cs_∂_convs1,
	∂_cd_thms = thm_union ∂_cd_thms ∂_cd_thms1,
	∂_vs_thms = union_bits ∂_vs_thms ∂_vs_thms1,
	rw_net = rw_net1,
	rw_canon = rw_canon1,
	st_conv = st_conv1,
	sg_conv = sg_conv1,
	cs_∂_conv = cs_∂_conv1,
	∂_ad_cd_thms = ∂_ad_cd_thms1,
	∂_ad_vs_thms  = ∂_ad_vs_thms1,
	names = names1,
	theoryname = theoryname1,
	a_valid_thm = a_valid_thm1,
	committed = false}
);
end;
=TEX
=SML
fun €merge_pcs› (keys:string list) (key : string) : unit = (
let	val pcs = map (get_pc "merge_pcs") keys;
in
	change_pc "merge_pcs" key 
	(fn pc => fold (local_merge_pc "merge_pcs" true) pcs pc)
end);
=TEX
=SML
local
val valid_fields = ["rw_eqn_cxt","rw_canons","st_eqn_cxt",
	"sg_eqn_cxt","cs_∂_convs","∂_cd_thms","∂_vs_thms"];
in
fun €prune_pc› (caller : string) (fields : string list) ({
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_∂_convs = cs_∂_convs, ∂_cd_thms = ∂_cd_thms,
	∂_vs_thms = ∂_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms, ∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}: PROOF_CONTEXT) 
	: PROOF_CONTEXT = (
	if not(fields subset valid_fields)
	then fail caller 51019 [fn () => hd(fields diff valid_fields)]
	else
	{
	rw_eqn_cxt = if "rw_eqn_cxt" mem fields then rw_eqn_cxt else [],
	rw_canons = if "rw_canons" mem fields then rw_canons else [],
	st_eqn_cxt = if "st_eqn_cxt" mem fields then st_eqn_cxt else [],
	sg_eqn_cxt = if "sg_eqn_cxt" mem fields then sg_eqn_cxt else [],
	cs_∂_convs = if "cs_∂_convs" mem fields then cs_∂_convs else [],
	∂_cd_thms = if "∂_cd_thms" mem fields then ∂_cd_thms else [],
	∂_vs_thms = if "∂_vs_thms" mem fields then ∂_vs_thms else [],
	rw_net = rw_net,
	rw_canon = rw_canon,
	st_conv = st_conv,
	sg_conv = sg_conv,
	cs_∂_conv = cs_∂_conv,
	∂_ad_cd_thms = ∂_ad_cd_thms,
	∂_ad_vs_thms  = ∂_ad_vs_thms,
	names = names,
	theoryname = theoryname,
	a_valid_thm = a_valid_thm,
	committed = committed}
);
end; 
=TEX
=SML
local
	fun get_stuff {context:string,fields:string list}:PROOF_CONTEXT = (
	let	val pc = get_pc "merge_pc_fields" context;
	in
		prune_pc "merge_pc_fields" fields pc
	end);
in
fun €merge_pc_fields› (lst : {context:string,fields:string list}list) 
	(key :string) : unit = (
let	val pcs = map get_stuff lst;
in
	change_pc "merge_pc_fields" key 
	(fn pc => fold (local_merge_pc "merge_pc_fields" true) pcs pc)
end);
end;
=TEX
=SML
fun €push_pc› (key : string): unit = (
let	val pc = get_pc "push_pc" key;
	val epc = if #committed pc
		then pc
		else evaluate_proof_context pc;
in
	(push_pc_stack (get_current_pc());
	set_current_pc epc)
end);
=TEX
=SML
fun €pop_pc› (): unit = (
let	val pc = pop_pc_stack "pop_pc";
in
	set_current_pc pc
end);
=TEX
=SML
fun €set_pc› (key : string): unit = (
let	val pc = get_pc "set_pc" key;
	val epc = if #committed pc
		then pc
		else evaluate_proof_context pc;
in
	set_current_pc epc
end);
=TEX
=SML
fun €push_merge_pcs› ([]: string list): unit = fail "push_merge_pcs" 51020 []
| push_merge_pcs (keys) = (
let	val pc = empty_pc false keys;
	val fullpc = fold (local_merge_pc "push_merge_pcs" false) 
		(map (get_pc "push_merge_pcs") keys) pc;
	val epc = evaluate_proof_context fullpc;
in
	(push_pc_stack (get_current_pc());
	set_current_pc epc)
end);
=TEX
=SML
fun €set_merge_pcs› ([]: string list): unit = fail "set_merge_pcs" 51020 []
| set_merge_pcs (keys) = (
let	val pc = empty_pc false keys;
	val fullpc = fold (local_merge_pc "set_merge_pcs" false) 
		(map (get_pc "set_merge_pcs") keys) pc;
	val epc = evaluate_proof_context fullpc;
in
	set_current_pc epc
end);
=TEX
\section{END OF SIGNATURE}
=SML
end; (* of structure ProofContext *)
open_theory lthy;
open ProofContext;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
