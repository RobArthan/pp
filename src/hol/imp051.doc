=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation of Proof Contexts}
\TPPref{DS/FMU/IED/IMP051}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives an implementation providing proof contexts.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First draft version.
\item [Issue 1.2]
Made default conversions $fail\_conv$.
Reacted to $NetTools$ being open.
\item [Issue 1.3]
Moved to using abstract data types.
\item [Issue 1.4]
Added $cs\_¶\_conv$ material.
\item [Issue 1.5]
Added existence prover parameterisation.

\item[Issue 1.6, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.7]
Changes to reflect issue 1.12 of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.8 (1st April 1992)]
Changes required by CR0016.
\item [Issue 1.11 (13th April 1992)]
Changes due to CR0017.
\item [Issue 1.17 (15th April 1992)]
Change to $show\_stack\_pcs$, added $delete\_pc\_fields$.
\item [Issue 1.18 (8th May 1992)]
Reorganised after RBJ comments.
\item [Issue 1.19,1.20 (12th May 1992)]
Changed some names.
\end{description}
\subsection{Changes Forecast}
As detailed design.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for material
whose detailed design is given in in \cite{DS/FMU/IED/DTD051}.
It is module tested in \cite{DS/FMU/IED/MDT051}
\subsection{Introduction}
\subsubsection{Purpose and Background}
A proof context is a setting of various configurable
parameters of proof tools to support a particular mode of proof.
For instance, both $rewrite\_tac$ and $strip\_tac$ 
are configurable proof tools.
In particular, proof contexts will be later made available,
through the tools supplied here,
that supply a good environment to reason about Z,
or within a particular theory (e.g. set theory),
and alter the default environment.

\subsubsection{Dependencies}
This document is dependent on \cite{DS/FMU/IED/DTD051}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
As detailed design.
\section{PREAMBLE}
=SML
structure ÛProofContextÝ : ProofContext = struct

val lthy = get_current_theory_name();
val dummy = open_theory "min";

=TEX
\section{UTILITIES}
=SML
val Ûthm_unionÝ : THM list -> THM list -> THM list = 
	union (op =|-);
=TEX
As $roverwrite$ but prefix, and putting new entries at the head:
=SML
fun Ûroverwrite1Ý lst (a,b) = (
let fun aux [] = fail "" 0 []
| aux ((x,y) :: rest) = (
	if b = y
	then ((a,b) :: rest)
	else ((x,y) :: aux rest)
);
in
	aux lst
	handle complaint =>
	((a,b) :: lst)
end);
=TEX
=SML
fun Ûlist_roverwrite1Ý (abs : ('a * ''b) list) (xys : ('a * ''b) list) : ('a * ''b) list = (
	fold (fn (l1, l2) => roverwrite1 l2 l1) abs xys
);
=IGN
list_roverwrite1 [(1,"1"),(3,"3"),(4,"3"),(5,"5")] [(2,"2"),(0,"5"),(4,"4")];
=TEX
\section{EQUATIONAL CONTEXTS}
An equational context is a list of conversions,
each paired with term index. It represents a statement of
how to
rewrite a term to result in an equational theorem,
guided by the outermost form of the term to be rewritten,
which is matched against the term index of each conversion.
=SML
type ÛEQN_CXTÝ = (TERM * CONV) list;
=TEX
In the following, if $simple\_eq\_match\_conv1$
is successfully applied, then the term destruction
but be successful.
=SML
fun Ûthm_eqn_cxtÝ (thm : THM) : (TERM * CONV) = (
let	val cnv =  simple_eq_match_conv1 thm
		handle complaint =>
		pass_on complaint "simple_eq_match_conv1" "thm_eqn_cxt";
	val lhs = fst(dest_eq(snd(strip_µ (concl thm))));
in
	(lhs, cnv)
end);
=TEX
=SML
local
	fun FIRST_CHANGED_C (cv :: rest) tm =
		(CHANGED_C cv ORELSE_C FIRST_CHANGED_C rest) tm
	| FIRST_CHANGED_C [] tm = term_fail "eqn_cxt_conv" 51005 [tm];
in
fun Ûeqn_cxt_convÝ (ec : EQN_CXT) : CONV = (
let	val net = make_net ec;
in
	(fn tm => FIRST_CHANGED_C(net_lookup net tm)tm
	)
end);
end;
=TEX

\section{TYPES}
The following is the object stored in the stack and database of proof contexts.
=SML
type ÛPROOF_CONTEXTÝ = {
	rw_eqn_cxt: (EQN_CXT * string)list,
	rw_canons: ((THM -> THM list) list * string)list,
				(* CANON list * ... *)
	st_eqn_cxt: (EQN_CXT * string) list,
	sg_eqn_cxt: (EQN_CXT * string) list,
	cs_¶_convs: (CONV list * string) list,
	¶_cd_thms: THM list,
	¶_vs_thms: (string * (TERM list * THM))list,
	pr_tac : THM list -> TACTIC,
	pr_conv : THM list -> CONV,
=TEX
Now the evaluated parts:
=SML
	rw_net: CONV NET,
	rw_canon: THM -> THM list,	(* CANON *)
	st_conv: CONV,
	sg_conv: CONV,
	cs_¶_conv: TERM -> THM,
	¶_ad_cd_thms:  (TERM list * int list * TYPE * (TERM list)list * THM) list,
	¶_ad_vs_thms:  (string * (TERM list * THM))list,
=TEX
And finally the commital data
=SML
	names : string list,
	theoryname : string,
	a_valid_thm : THM,
	committed : bool
	};
=TEX
$a\_valid\_thm$ is intended to be set to a theorem generated 
at the creation of the proof context, and if that is not valid (by $valid\_thm$) then the proof context itself is considered ``stale''.
\section{DATA STRUCTURES AND ABSTRACT DATA TYPES}
\subsection{Proof Context ``initial''}
=SML
fun Ûempty_pcÝ (committed : bool)(names : string list): PROOF_CONTEXT = {
	rw_eqn_cxt = [],
	rw_canons = [],
	st_eqn_cxt = [],
	sg_eqn_cxt = [],
	cs_¶_convs = [],
	¶_cd_thms = [],
	¶_vs_thms = [],
	pr_tac = (fn _ => fail_tac),
	pr_conv = (fn _ => fail_conv),
=TEX
Now the evaluated parts:
=SML
	rw_net = empty_net,
	rw_canon = (fn thm => [thm]),	(* CANON *)
	st_conv = fail_conv,
	sg_conv = fail_conv,
	cs_¶_conv = (fn _ => fail "icl'set_eval_ad_cs_¶_convs" 51015 []),
	¶_ad_cd_thms = [],
	¶_ad_vs_thms = [],
=TEX
And finally the commital data
=SML
	names = names,
	theoryname = get_current_theory_name(),
	a_valid_thm = icl'Kernel.icl'refl_conv (mk_var("a",BOOL)),
	committed = committed
	};
=TEX
Now the initial proof context (local only):
=SML
val Ûinitial_pcÝ = empty_pc true ["initial"];
=TEX
\subsection{Database of Proof Contexts}
Unsurprisingly, this is a simple dictionary, stored in an assignable variable.
=SML
local
	val pc_db : (PROOF_CONTEXT S_DICT) ref = ref (
		s_enter "initial" initial_pc initial_s_dict);
in
=TEX
Local declarations:
=SML
fun Ûget_pcÝ (caller: string) (key : string) : PROOF_CONTEXT = (
	case s_lookup key (!pc_db) of
	Value (pc as {a_valid_thm = a_valid_thm,theoryname=theoryname,...}) => (
		if valid_thm a_valid_thm
		then pc
		else fail caller 51014 [(fn () => key),(fn () => theoryname)]
	) | Nil => fail caller 51010 [fn () => key]
);

fun Ûextend_pcÝ (caller: string) (key : string) (pc : PROOF_CONTEXT) : unit = ((
	pc_db := s_extend key pc (!pc_db);
	())
	handle (Fail _) =>
	fail caller 51011 [fn () => key]
);

fun Ûchange_pcÝ (caller: string) (key : string) 
	(pcf : PROOF_CONTEXT -> PROOF_CONTEXT) : unit = (
let	val opc as {committed = committed,...} = get_pc caller key;
	val sideeeffect = if committed 
		then fail caller 51016 [fn () => key]
		else ();
in
	(pc_db := s_enter key (pcf opc) (!pc_db);
	())
end);
=TEX
Seen in signature:
=SML
local
	fun detail (key,({theoryname = theoryname,
		a_valid_thm = a_valid_thm, ...}:PROOF_CONTEXT)) = (
		if valid_thm a_valid_thm
		then (key,theoryname)
		else (key,get_error_message 51018 [theoryname])
	);
in
fun Ûshow_pcsÝ () : (string * string)list = (
	map detail (!pc_db)
);
end;
=TEX
Seen in signature:
=SML
fun Ûdelete_pcÝ (key : string) :unit = (
	if key = "initial"
	then fail "delete_pc" 51012 []
	else (
	case s_lookup key (!pc_db) of
	Value _ => (
		pc_db := s_delete key (!pc_db);
		()
	) | Nil => fail "delete_pc" 51010 [fn () => key])
);
=TEX
=SML
fun Ûnew_pcÝ (new: string) : unit = (
	extend_pc "new_pc" new (empty_pc false [new])
);
=TEX
=SML
fun Ûpending_reset_pc_databaseÝ () : unit -> unit = (
let	val temp_db = (!pc_db)
in
	(fn () => pc_db := temp_db)
end);
=TEX
End of database functions
=SML
end;
=TEX
\subsection{Proof Context Stack}
The current proof context is not actually on the proof context
stack, but separate.
=SML
local
	val pc_stack : (PROOF_CONTEXT list) ref = ref [];
in
fun push_pc_stack pc = (pc_stack := (pc :: (!pc_stack));());
fun pop_pc_stack caller = (
	case (!pc_stack) of
	[] => fail caller 51001 []
	| (a :: x) => (pc_stack := x; a)
);
=TEX
\subsection{Current Proof Context}
=SML
local
	val current_pc : PROOF_CONTEXT ref = ref initial_pc;
	val ad_rw_net = ref (#rw_net initial_pc);
	val ad_rw_canon = ref (#rw_canon initial_pc);
	val ad_st_conv = ref (#st_conv initial_pc);
	val ad_sg_conv = ref (#sg_conv initial_pc);
	val ad_cs_¶_convs = ref (#cs_¶_conv initial_pc);
	val ad_¶_ad_cd_thms = ref (#¶_ad_cd_thms initial_pc);
	val ad_¶_ad_vs_thms = ref (#¶_ad_vs_thms initial_pc);
	val ad_pr_tac = ref (#pr_tac initial_pc);
	val ad_pr_conv = ref (#pr_conv initial_pc);
	val ad_valid_thm = ref (#a_valid_thm initial_pc);
	val ad_theoryname = ref (#theoryname initial_pc);
in
=TEX
Set the current proof context:
=SML
fun set_current_pc pc = (
	current_pc := pc;
	ad_rw_net := (#rw_net pc);
	ad_rw_canon := (#rw_canon pc);
	ad_st_conv := (#st_conv pc);
	ad_sg_conv := (#sg_conv pc);
	ad_cs_¶_convs := (#cs_¶_conv pc);
	ad_¶_ad_cd_thms := (#¶_ad_cd_thms pc);
	ad_¶_ad_vs_thms := (#¶_ad_vs_thms pc);
	ad_pr_tac := (#pr_tac pc);
	ad_pr_conv := (#pr_conv pc);
	ad_valid_thm := (#a_valid_thm pc);
	ad_theoryname := (#theoryname pc);
	()
);
=TEX
Access the current proof context:
=SML
fun Ûcurrent_ad_rw_netÝ ():CONV NET = 
	if valid_thm (!ad_valid_thm) 
	then (!ad_rw_net)
	else fail "current_ad_rw_net" 51021 [fn () => (!ad_theoryname)];
fun Ûcurrent_ad_rw_canonÝ () (thm :THM) : THM list = 
	if valid_thm (!ad_valid_thm) 
	then (!ad_rw_canon) thm
	else fail "current_ad_rw_canon" 51021 [fn () => (!ad_theoryname)];
fun Ûcurrent_ad_st_convÝ ():CONV = 
	if valid_thm (!ad_valid_thm) 
	then (!ad_st_conv)
	else fail "current_ad_st_conv" 51021 [fn () => (!ad_theoryname)];
fun Ûcurrent_ad_sg_convÝ ():CONV = 
	if valid_thm (!ad_valid_thm) 
	then (!ad_sg_conv)
	else fail "current_ad_sg_conv" 51021 [fn () => (!ad_theoryname)];
fun Ûcurrent_ad_cs_¶_convÝ ():CONV = 
	if valid_thm (!ad_valid_thm) 
	then (!ad_cs_¶_convs)
	else fail "current_ad_cs_¶_conv" 51021 [fn () => (!ad_theoryname)];
fun Ûcurrent_ad_¶_cd_thmsÝ ()
	: (TERM list * int list * TYPE * (TERM list)list * THM) list
	= 
	if valid_thm (!ad_valid_thm) 
	then (!ad_¶_ad_cd_thms)
	else fail "current_ad_¶_cd_thms" 51021 [fn () => (!ad_theoryname)];
fun Ûcurrent_ad_¶_vs_thmsÝ ():(string * (TERM list * THM)) list 
	= 
	if valid_thm (!ad_valid_thm) 
	then (!ad_¶_ad_vs_thms)
	else fail "current_ad_¶_vs_thms" 51021 [fn () => (!ad_theoryname)];
fun Ûcurrent_ad_pr_tacÝ () (thms : THM list) : TACTIC
	= 
	if valid_thm (!ad_valid_thm) 
	then (!ad_pr_tac) thms
	else fail "current_ad_pr_tac" 51021 [fn () => (!ad_theoryname)];
fun Ûcurrent_ad_pr_convÝ () (thms : THM list): CONV 
	= 
	if valid_thm (!ad_valid_thm) 
	then (!ad_pr_conv) thms
	else fail "current_ad_pr_conv" 51021 [fn () => (!ad_theoryname)];

fun Ûshow_current_pcÝ () : (string list * string) = (
	if valid_thm (#a_valid_thm (!current_pc))
	then ((#names (!current_pc)),(#theoryname (!current_pc)))
	else ((#names (!current_pc)),get_error_message 51018 [(#theoryname (!current_pc))])
);

fun Ûget_current_pcÝ () = (!current_pc);
=TEX
End of current proof context stuff:
=SML
end; (* current prof context *)
=SML
local
	fun detail (({theoryname = theoryname,
		a_valid_thm = a_valid_thm, names = names, ...}:PROOF_CONTEXT)) = (
		if valid_thm a_valid_thm
		then (names,theoryname)
		else (names,get_error_message 51018 [theoryname])
	);
in
fun Ûshow_stack_pcsÝ () : (string list * string)list = (
	show_current_pc () ::
	map detail (!pc_stack)
);
end;
end; (* of local pc_stack *)
=TEX
\subsection{Evaluation Functions}
We cannot express $eval\_ad\_rw\_canon$ properly yet.
=SML
local
val eval_ad_rw_net : (EQN_CXT -> CONV NET) ref = ref make_net;
val eval_ad_rw_canon : ((THM -> THM list) list -> (THM -> THM list)) ref = 
	ref (fn _ => fn thm => [thm]);
val eval_ad_st_conv : (EQN_CXT -> CONV) ref = ref eqn_cxt_conv;
val eval_ad_sg_conv : (EQN_CXT -> CONV) ref = ref eqn_cxt_conv;

local
	fun try_all [] = (fn tm => fail "current_ad_cs_¶_conv" 51015 [])
	| try_all (afun :: []) = afun
	| try_all (afun :: rest) = afun AND_OR_C (try_all rest);
in
val eval_ad_cs_¶_convs : (CONV list -> CONV) ref = ref try_all;
end;
	
val eval_ad_¶_ad_cd_thms : (THM list -> 
	(TERM list * int list * TYPE * (TERM list)list * THM) list) ref = 
	ref (fn _ => []);
val eval_ad_¶_ad_vs_thms : ((string * (TERM list * THM)) list ->
	(string * (TERM list * THM)) list) ref = ref Combinators.I;
in
fun Ûicl'set_eval_ad_rw_netÝ (f:(EQN_CXT -> CONV NET)) : unit =
	(eval_ad_rw_net := f; ());
fun Ûicl'set_eval_ad_rw_canonÝ (f:((THM -> THM list) list -> 
	(THM -> THM list))) : unit =
	(eval_ad_rw_canon := f; ());
fun Ûicl'set_eval_ad_st_convÝ (f:(EQN_CXT -> CONV)) : unit = 
	(eval_ad_st_conv := f; ());
fun Ûicl'set_eval_ad_sg_convÝ (f:(EQN_CXT -> CONV)) : unit =
	(eval_ad_sg_conv := f; ());
fun Ûicl'set_eval_ad_cs_¶_convsÝ (f:(CONV list -> CONV)) =
	(eval_ad_cs_¶_convs := f; ());
fun Ûicl'set_eval_ad_¶_cd_thmsÝ (f:(THM list -> 
	(TERM list * int list * TYPE * (TERM list)list * THM) list)) =
	(eval_ad_¶_ad_cd_thms := f; ());
fun Ûicl'set_eval_ad_¶_vs_thmsÝ (f:((string * (TERM list * THM)) list ->
	(string * (TERM list * THM)) list)) =
	(eval_ad_¶_ad_vs_thms := f; ());
=TEX
Now the method of evaluating a proof context:
=SML
fun Ûevaluate_proof_contextÝ (
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, pr_tac = pr_tac, pr_conv = pr_conv,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
	: PROOF_CONTEXT) : PROOF_CONTEXT = 
	{
	rw_eqn_cxt = rw_eqn_cxt,
	rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt,
	sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs,
	¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms,
	pr_tac = pr_tac, 
	pr_conv = pr_conv,
	rw_net = (!eval_ad_rw_net) (flat(map fst rw_eqn_cxt)),
	rw_canon = (!eval_ad_rw_canon) (flat(map fst rw_canons)),
	st_conv = (!eval_ad_st_conv) (flat(map fst st_eqn_cxt)),
	sg_conv = (!eval_ad_sg_conv) (flat(map fst sg_eqn_cxt)),
	cs_¶_conv = (!eval_ad_cs_¶_convs) (flat(map fst cs_¶_convs)),
	¶_ad_cd_thms = (!eval_ad_¶_ad_cd_thms) ¶_cd_thms,
	¶_ad_vs_thms  = (!eval_ad_¶_ad_vs_thms) ¶_vs_thms,
	names = names,
	theoryname = theoryname,
	a_valid_thm = a_valid_thm,
	committed = committed};
=TEX
End of evaluating things.
=SML
end;
=TEX
\section{OTHER FUNCTIONS}
\subsection{Setting and Getting User Data}
\subsubsection{Rewriting Equations Context}
=SML
fun Ûset_rw_eqn_cxtÝ (ec:EQN_CXT) (key:string) : unit =  (
change_pc "set_rw_eqn_cxt" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = roverwrite1 rw_eqn_cxt (ec,key), rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun Ûget_rw_eqn_cxtÝ (key:string) : (EQN_CXT * string) list = (
	#rw_eqn_cxt (get_pc "get_rw_eqn_cxt" key)
);
=TEX
In adding the theorems we canonicalise them by what the
proof context would evaluate as its current canonicalisation.
=SML
fun Ûadd_rw_thmsÝ (thms:THM list) (key:string) : unit =  (
change_pc "add_rw_thms" key 
((fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}:PROOF_CONTEXT
 =>
	let val cthms = map thm_eqn_cxt(flat (map rw_canon thms));
	in
	{
	rw_eqn_cxt = (case rassoc5 rw_eqn_cxt key of
		Value x => roverwrite1 rw_eqn_cxt ((cthms @ x),key)
		| Nil =>  ((cthms, key) :: rw_eqn_cxt)), 
	rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
	end)
o
evaluate_proof_context)
);
=TEX
\subsubsection{Rewriting Canonicalisation}
=SML
fun Ûset_rw_canonsÝ (can: (THM -> THM list) list) (key:string) : unit =  (
change_pc "set_rw_canons" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = roverwrite1 rw_canons (can,key),
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun Ûget_rw_canonsÝ (key:string) : ((THM -> THM list) list * string) list = (
	#rw_canons (get_pc "get_rw_canons" key)
);
=TEX
\subsubsection{Theorem Stripping Equational Context}
=SML
fun Ûset_st_eqn_cxtÝ (ec:EQN_CXT) (key:string) : unit =  (
change_pc "set_st_eqn_cxt" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = roverwrite1 st_eqn_cxt (ec,key), sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun Ûget_st_eqn_cxtÝ (key:string) : (EQN_CXT * string) list = (
	#st_eqn_cxt (get_pc "get_st_eqn_cxt" key)
);
=TEX
In adding the theorems we canonicalise them by what the
proof context would evaluate as its current canonicalisation.
=SML
fun Ûadd_st_thmsÝ (thms:THM list) (key:string) : unit =  (
change_pc "add_st_thms" key 
((fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}:PROOF_CONTEXT
 =>
	let val cthms = map thm_eqn_cxt(flat (map rw_canon thms));
	in
	{
	rw_eqn_cxt = rw_eqn_cxt, 
	rw_canons = rw_canons,
	st_eqn_cxt = (case rassoc5 st_eqn_cxt key of
		Value x => roverwrite1 st_eqn_cxt ((cthms @ x),key)
		| Nil =>  ((cthms, key) :: st_eqn_cxt)), 
	sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
	end)
o
evaluate_proof_context)
);
=TEX
\subsubsection{Goal Stripping Equational Context}
=SML
fun Ûset_sg_eqn_cxtÝ (ec:EQN_CXT) (key:string) : unit =  (
change_pc "set_sg_eqn_cxt" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = roverwrite1 sg_eqn_cxt (ec,key),
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun Ûget_sg_eqn_cxtÝ (key:string) : (EQN_CXT * string) list = (
	#sg_eqn_cxt (get_pc "get_sg_eqn_cxt" key)
);
=TEX
=SML
fun Ûadd_sg_thmsÝ (thms:THM list) (key:string) : unit =  (
change_pc "add_sg_thms" key 
((fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}:PROOF_CONTEXT
 =>
	let val cthms = map thm_eqn_cxt(flat (map rw_canon thms));
	in
	{
	rw_eqn_cxt = rw_eqn_cxt, 
	rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, 
	sg_eqn_cxt = (case rassoc5 sg_eqn_cxt key of
		Value x => roverwrite1 sg_eqn_cxt ((cthms @ x),key)
		| Nil =>  ((cthms, key) :: sg_eqn_cxt)),
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
	end)
o
evaluate_proof_context)
);
=TEX

\subsubsection{Automated Existence Provers}
=SML
fun Ûset_cs_¶_convsÝ (rls : CONV list) (key:string) : unit =  (
change_pc "set_cs_¶_convs" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = roverwrite1 cs_¶_convs (rls,key), ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun Ûget_cs_¶_convsÝ (key:string) : (CONV list * string) list = (
	#cs_¶_convs (get_pc "get_cs_¶_convs" key)
);
=TEX
\subsubsection{Clausal Definition Theorems}
=SML
fun Ûset_¶_cd_thmsÝ (cd : THM list) (key:string) : unit =  (
change_pc "set_¶_cd_thms" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = cd,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun Ûget_¶_cd_thmsÝ (key:string) : THM list = (
	#¶_cd_thms (get_pc "get_¶_cd_thms" key)
);
=TEX
=SML
fun Ûadd_¶_cd_thmsÝ (thms:THM list) (key:string) : unit =  (
change_pc "add_¶_cd_thms" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}:PROOF_CONTEXT
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, 
	rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, 
	sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, 
	¶_cd_thms = thm_union thms ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
	)
);
=TEX
\subsubsection{Variable Structure Theorems}
=SML
local
fun list_eq (a :: x) (b :: y) = a =$ b andalso list_eq x y
| list_eq [] [] = true
| list_eq _ _ = false;

val union_bits = union (fn ((str1,(tml1,thm1)) ,(str2,(tml2,thm2))) =>
	str1 = str2 andalso (list_eq tml1 tml2) andalso (thm1 =|- thm2))
in
fun Ûset_¶_vs_thmsÝ (vs : (string * (TERM list * THM))list) (key:string) : unit =  (
change_pc "set_¶_vs_thms" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = union_bits ¶_vs_thms vs, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
end;
fun Ûget_¶_vs_thmsÝ (key:string) : (string * (TERM list * THM))  list = (
	#¶_vs_thms (get_pc "get_¶_vs_thms" key)
);
=TEX
\subsubsection{Automatic Proof: Tactics}
=SML
fun Ûset_pr_tacÝ (tac : THM list -> TACTIC) (key:string) : unit =  (
change_pc "set_pr_tac" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun Ûget_pr_tacÝ (key:string) : THM list -> TACTIC = (
	#pr_tac (get_pc "get_pr_tac" key)
);
=TEX
\subsubsection{Automatic Proof: Conversions}
=SML
fun Ûset_pr_convÝ (conv : THM list -> CONV) (key:string) : unit =  (
change_pc "set_pr_conv" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun Ûget_pr_convÝ (key:string) : THM list -> CONV = (
	#pr_conv (get_pc "get_pr_conv" key)
);
=TEX

\subsection{Functions upon Proof Contexts}
=SML
fun Ûcommit_pcÝ (key:string) : unit =  (
change_pc "commit_pc" key 
((fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = get_current_theory_name(),
	a_valid_thm = icl'Kernel.icl'refl_conv (mk_var("a",BOOL)), 
	committed = true})
o evaluate_proof_context)
);
=TEX
N.B. the second of the pair is ``the master'', to which the first is added in.
The added in form is the source for $pr\_tac$ and $pr\_conv$.
=SML
local
fun list_eq (a :: x) (b :: y) = a =$ b andalso list_eq x y
| list_eq [] [] = true
| list_eq _ _ = false;

val union_bits = union (fn ((str1,(tml1,thm1)) ,(str2,(tml2,thm2))) =>
	str1 = str2 andalso (list_eq tml1 tml2) andalso (thm1 =|- thm2));
in
fun Ûlocal_merge_pcÝ (caller:string) (test_committed:bool) (({
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}:PROOF_CONTEXT),
	({
	rw_eqn_cxt = rw_eqn_cxt1, rw_canons = rw_canons1,
	st_eqn_cxt = st_eqn_cxt1, sg_eqn_cxt = sg_eqn_cxt1,
	cs_¶_convs = cs_¶_convs1, ¶_cd_thms = ¶_cd_thms1,
	¶_vs_thms = ¶_vs_thms1, pr_conv = pr_conv1,
	pr_tac = pr_tac1, rw_net = rw_net1,
	rw_canon = rw_canon1, st_conv = st_conv1,
	sg_conv = sg_conv1, cs_¶_conv = cs_¶_conv1,
	¶_ad_cd_thms = ¶_ad_cd_thms1, ¶_ad_vs_thms  = ¶_ad_vs_thms1,
	names = names1, theoryname = theoryname1,
	a_valid_thm = a_valid_thm1, committed = committed1}:PROOF_CONTEXT
)) : PROOF_CONTEXT = (
	if test_committed andalso not committed
	then fail caller 51017 [fn () => hd names]
	else
	{
	rw_eqn_cxt = list_roverwrite1 rw_eqn_cxt rw_eqn_cxt1,
	rw_canons = list_roverwrite1 rw_canons rw_canons1,
	st_eqn_cxt = list_roverwrite1 st_eqn_cxt st_eqn_cxt1,
	sg_eqn_cxt = list_roverwrite1 sg_eqn_cxt sg_eqn_cxt1,
	cs_¶_convs = list_roverwrite1 cs_¶_convs cs_¶_convs1,
	¶_cd_thms = thm_union ¶_cd_thms ¶_cd_thms1,
	¶_vs_thms = union_bits ¶_vs_thms ¶_vs_thms1,
	pr_tac = pr_tac,
	pr_conv = pr_conv,
	rw_net = rw_net1,
	rw_canon = rw_canon1,
	st_conv = st_conv1,
	sg_conv = sg_conv1,
	cs_¶_conv = cs_¶_conv1,
	¶_ad_cd_thms = ¶_ad_cd_thms1,
	¶_ad_vs_thms  = ¶_ad_vs_thms1,
	names = names1,
	theoryname = theoryname1,
	a_valid_thm = a_valid_thm1,
	committed = false}
);
end;
=TEX
=SML
fun Ûmerge_pcsÝ (keys:string list) (key : string) : unit = (
let	val pcs = map (get_pc "merge_pcs") keys;
in
	change_pc "merge_pcs" key 
	(fn pc => fold (local_merge_pc "merge_pcs" true) pcs pc)
end);
=TEX
The following empties all but selected fields of proof contexts.
This is used directly in $delete\-\_pc\-\_fields$,
and indirectly in merging proof context fields.
=SML
val valid_fields = ["rw_eqn_cxt","rw_canons","st_eqn_cxt",
	"sg_eqn_cxt","cs_¶_convs","¶_cd_thms","¶_vs_thms","pr_tac","pr_conv"];
=TEX
=SML
fun Ûprune_pcÝ (caller : string) (fields : string list) ({
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, 
	pr_conv = pr_conv, pr_tac = pr_tac,
	rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}: PROOF_CONTEXT) 
	: PROOF_CONTEXT = (
	if not(fields subset valid_fields)
	then fail caller 51019 [fn () => hd(fields diff valid_fields)]
	else
	{
	rw_eqn_cxt = if "rw_eqn_cxt" mem fields then rw_eqn_cxt else [],
	rw_canons = if "rw_canons" mem fields then rw_canons else [],
	st_eqn_cxt = if "st_eqn_cxt" mem fields then st_eqn_cxt else [],
	sg_eqn_cxt = if "sg_eqn_cxt" mem fields then sg_eqn_cxt else [],
	cs_¶_convs = if "cs_¶_convs" mem fields then cs_¶_convs else [],
	¶_cd_thms = if "¶_cd_thms" mem fields then ¶_cd_thms else [],
	¶_vs_thms = if "¶_vs_thms" mem fields then ¶_vs_thms else [],
	
	pr_conv = if "pr_conv" mem fields then pr_conv else (fn _ => fail_conv), 
	pr_tac = if "pr_tac" mem fields then pr_tac else (fn _ => fail_tac), 
	rw_net = rw_net,
	rw_canon = rw_canon,
	st_conv = st_conv,
	sg_conv = sg_conv,
	cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms,
	¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names,
	theoryname = theoryname,
	a_valid_thm = a_valid_thm,
	committed = committed}
);
=TEX
=SML
local
	fun get_stuff {context:string,fields:string list}:PROOF_CONTEXT = (
	let	val pc = get_pc "merge_pc_fields" context;
	in
		prune_pc "merge_pc_fields" fields pc
	end);
in
fun Ûmerge_pc_fieldsÝ (lst : {context:string,fields:string list}list) 
	(key :string) : unit = (
let	val pcs = map get_stuff lst;
in
	change_pc "merge_pc_fields" key 
	(fn pc => fold (local_merge_pc "merge_pc_fields" true) pcs pc)
end);
end;
=TEX
=SML
fun Ûdelete_pc_fieldsÝ (fields: string list) (key: string) : unit = (
	if not(fields subset valid_fields)
	then fail "delete_pc_fields" 51019 [fn () => hd(fields diff valid_fields)]
	else (change_pc "delete_pc_fields" key
		(prune_pc "delete_pc_fields" (valid_fields diff fields)))
);
=TEX
=SML
fun Ûpush_pcÝ (key : string): unit = (
let	val pc = get_pc "push_pc" key;
	val epc = if #committed pc
		then pc
		else evaluate_proof_context pc;
in
	(push_pc_stack (get_current_pc());
	set_current_pc epc)
end);
=TEX
=SML
fun Ûpending_push_pcÝ (key : string): unit -> unit = (
let	val pc = get_pc "pending_push_pc" key;
	val epc = if #committed pc
		then pc
		else evaluate_proof_context pc;
in
	(fn () =>
	((if valid_thm (#a_valid_thm pc)
	then ()
	else fail "pending_push_pc" 51014 [
		(fn () => format_list (Combinators.I) (#names pc) ","),
		(fn () => (#theoryname pc))]);
	push_pc_stack (get_current_pc());
	set_current_pc epc))
end);
=TEX
=SML
fun Ûpop_pcÝ (): unit = (
let	val pc = pop_pc_stack "pop_pc";
in
	set_current_pc pc
end);
=TEX
=SML
fun Ûset_pcÝ (key : string): unit = (
let	val pc = get_pc "set_pc" key;
	val epc = if #committed pc
		then pc
		else evaluate_proof_context pc;
in
	set_current_pc epc
end);
=TEX
=SML
fun Ûpush_merge_pcsÝ ([]: string list): unit = fail "push_merge_pcs" 51020 []
| push_merge_pcs (keys) = (
let	val pc = empty_pc false keys;
	val fullpc = fold (local_merge_pc "push_merge_pcs" false) 
		(map (get_pc "push_merge_pcs") keys) pc;
	val epc = evaluate_proof_context fullpc;
in
	(push_pc_stack (get_current_pc());
	set_current_pc epc)
end);
=TEX
=SML
fun Ûpending_push_merge_pcsÝ ([]: string list): unit -> unit = fail "pending_push_merge_pcs" 51020 []
| pending_push_merge_pcs (keys) = (
let	val pc = empty_pc false keys;
	val fullpc = fold (local_merge_pc "pending_push_merge_pcs" false) 
		(map (get_pc "pending_push_merge_pcs") keys) pc;
	val epc = evaluate_proof_context fullpc;
in
	(fn () =>
	((if valid_thm (#a_valid_thm fullpc)
	then ()
	else fail "pending_push_merge_pcs" 51014 [
		(fn () => format_list (Combinators.I) (#names fullpc) ","),
		(fn () => (#theoryname fullpc))]);
	push_pc_stack (get_current_pc());
	set_current_pc epc))
end);
=TEX
=SML
fun Ûset_merge_pcsÝ ([]: string list): unit = fail "set_merge_pcs" 51020 []
| set_merge_pcs (keys) = (
let	val pc = empty_pc false keys;
	val fullpc = fold (local_merge_pc "set_merge_pcs" false) 
		(map (get_pc "set_merge_pcs") keys) pc;
	val epc = evaluate_proof_context fullpc;
in
	set_current_pc epc
end);
=TEX
\section{USING THE PROOF CONTEXTS}
=SML
fun ÛPC_TÝ (key : string) (tac: TACTIC): TACTIC = (fn gl => 
let	val ppc = pending_push_pc key 
		handle complaint => 
		pass_on complaint "pending_push_pc" "PC_T";
	val dummy = ppc()
		 handle complaint => 
		pass_on complaint "pending_push_pc" "PC_T";
	val (sgs,prf) = (tac gl
		handle complaint =>
		(pop_pc();
		reraise complaint (area_of complaint)));
	val dummy = pop_pc();
	val prf' = (fn x => 
		let val p1 = ppc()
			handle complaint => 
			pass_on complaint "pending_push_pc" "PC_T";
		val p2 = prf x
			handle complaint =>
			(pop_pc();
			reraise complaint (area_of complaint));
		in
			(pop_pc();
			p2)
		end);
in
	(sgs,prf')
end);
=TEX
=SML
fun ÛPC_T1Ý (key : string) (tac: 'a -> TACTIC) (arg : 'a):  TACTIC = (fn gl => 
let	val ppc = pending_push_pc key 
		handle complaint => 
		pass_on complaint "pending_push_pc" "PC_T1";
	val dummy = ppc()
		 handle complaint => 
		pass_on complaint "pending_push_pc" "PC_T1";
	val (sgs,prf) = (tac arg gl 
		handle complaint =>
		(pop_pc();
		reraise complaint (area_of complaint)));
	val dummy = pop_pc();
	val prf' = (fn x => 
		let val p1 = ppc()
			handle complaint => 
			pass_on complaint "pending_push_pc" "PC_T1";
		val p2 = prf x
			handle complaint =>
			(pop_pc();
			reraise complaint (area_of complaint));
		in
			(pop_pc();
			p2)
		end);
in
	(sgs,prf')
end);
=TEX
=SML
fun ÛPC_CÝ (key : string) (conv: CONV) :  CONV = (fn tm => 
let	val dummy = push_pc key handle complaint => pass_on complaint "push_pc" "PC_C";
	val res = (conv tm
		handle complaint =>
		(pop_pc();
		reraise complaint (area_of complaint)));
	val dummy = pop_pc();
in
	res
end);
=TEX
=SML
fun ÛPC_C1Ý (key : string) (conv: 'a -> CONV) (arg : 'a):  CONV = (fn tm => 
let	val dummy = push_pc key handle complaint => pass_on complaint "push_pc" "PC_C1";
	val res = (conv arg tm
		handle complaint =>
		(pop_pc();
		reraise complaint (area_of complaint)));
	val dummy = pop_pc();
in
	res
end);
=TEX
=SML
fun Ûpc_ruleÝ (key : string) (rule: 'a -> THM) (x : 'a) : THM = ( 
let	val dummy = push_pc key handle complaint => pass_on complaint "push_pc" "pc_rule";
	val res = (rule x
		handle complaint =>
		(pop_pc();
		reraise complaint (area_of complaint)));
	val dummy = pop_pc();
in
	res
end);
=TEX
=SML
fun Ûpc_rule1Ý (key : string) (rule: 'a -> 'b -> THM) 
	(arg1 : 'a) (arg2 : 'b) : THM = (
let	val dummy = push_pc key 
		handle complaint => 
		pass_on complaint "push_pc" "pc_rule1";
	val res = (rule arg1 arg2
		handle complaint =>
		(pop_pc();
		reraise complaint (area_of complaint)));
	val dummy = pop_pc();
in
	res
end);
=TEX
=SML
fun Ûasm_prove_tacÝ (thms: THM list) :  TACTIC = (
	current_ad_pr_tac () thms
	handle complaint => 
	pass_on complaint "current_ad_pr_tac" "asm_prove_tac"
);
=TEX
=SML
fun Ûprove_convÝ (thms: THM list) :  CONV = (
	current_ad_pr_conv () thms
	handle complaint => 
	pass_on complaint "current_ad_pr_conv" "prove_conv"
);
=TEX
=SML
fun Ûprove_ruleÝ (thms: THM list) : TERM -> THM = (
let	val res1 = current_ad_pr_conv () thms
		handle complaint => 
		pass_on complaint "current_ad_pr_conv" "prove_rule";
in
	(fn tm => 
let
	val res = res1 tm;
	val dummy = if is_nil (asms res)
		then ()
		else fail "prove_rule" 51022 [
			fn () => string_of_term tm,
			fn () => string_of_thm res];
	val (lhs,rhs) = dest_¤ (concl res)
		handle complaint =>
		divert complaint "dest_¤" "prove_rule" 51022 [
			fn () => string_of_term tm,
			fn () => string_of_thm res];
in
	if (rhs =$ mk_t) andalso (lhs ~=$ tm)
	then ¤_t_elim(eq_trans_rule (refl_conv tm) res)
	else fail "prove_rule" 51022 [
			fn () => string_of_term tm,
			fn () => string_of_thm res]
end)
end);
=TEX
=SML
val Ûasm_prove_¶_tacÝ : TACTIC = (fn gl =>
	conv_tac(current_ad_cs_¶_conv ()) gl
	handle complaint => 
	pass_on complaint "current_ad_cs_¶_conv" "asm_prove_¶_tac"
);
=TEX
=SML
val Ûprove_¶_convÝ :  CONV = (fn tm =>
	current_ad_cs_¶_conv () tm
	handle complaint => 
	pass_on complaint "current_ad_cs_¶_conv" "prove_¶_conv"
);
=TEX
=SML
fun Ûprove_¶_ruleÝ (tm : TERM) : THM = (
let	val res = current_ad_cs_¶_conv () tm
		handle complaint => 
		pass_on complaint "current_ad_cs_¶_conv" "prove_¶_rule";
	val dummy = if is_nil (asms res)
		then ()
		else fail "prove_¶_rule" 51022 [
			fn () => string_of_term tm,
			fn () => string_of_thm res];
	val (lhs,rhs) = dest_¤ (concl res)
		handle complaint =>
		divert complaint "dest_¤" "prove_¶_rule" 51022 [
			fn () => string_of_term tm,
			fn () => string_of_thm res];
in
	if (rhs =$ mk_t) andalso (lhs ~=$ tm)
	then ¤_t_elim(eq_trans_rule (refl_conv tm) res)
	else fail "prove_¶_rule" 51022 [
			fn () => string_of_term tm,
			fn () => string_of_thm res]
end);
=TEX


\section{END OF SIGNATURE}
=SML
val _ = open_theory lthy;
end; (* of structure ProofContext *)
open ProofContext;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
