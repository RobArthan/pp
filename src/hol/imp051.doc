=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation of Proof Contexts}
\TPPref{DS/FMU/IED/IMP051}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives an implementation providing proof contexts.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First draft version.
\item [Issue 1.2]
Made default conversions $fail\_conv$.
Reacted to $NetTools$ being open.
\item [Issue 1.3]
Moved to using abstract data types.
\item [Issue 1.4]
Added $cs\_¶\_conv$ material.
\item [Issue 1.5]
Added existence prover parameterisation.

\item[Issue 1.6, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.7]
Changes to reflect issue 1.12 of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.8 (1st April 1992)]
Changes required by CR0016.
\item [Issue 1.11 (13th April 1992)]
Changes due to CR0017.

\end{description}
\subsection{Changes Forecast}
As detailed design.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for material
whose detailed design is given in in \cite{DS/FMU/IED/DTD051}.
It is module tested in \cite{DS/FMU/IED/MDT051}
\subsection{Introduction}
\subsubsection{Purpose and Background}
A proof context is a setting of various configurable
parameters of proof tools to support a particular mode of proof.
For instance, both $rewrite\_tac$ and $strip\_tac$ 
are configurable proof tools.
In particular, proof contexts will be later made available,
through the tools supplied here,
that supply a good environment to reason about Z,
or within a particular theory (e.g. set theory),
and alter the default environment.

\subsubsection{Dependencies}
This document is dependent on \cite{DS/FMU/IED/DTD051}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
As detailed design.
\section{PREAMBLE}
=SML
val lthy = get_current_theory_name();
open_theory "min";
=SML
structure ÛProofContextÝ : ProofContext = struct
=TEX
\section{UTILITIES}
=SML
val Ûthm_unionÝ : THM list -> THM list -> THM list = 
	union (op =|-);
=TEX
As $roverwrite$ but prefix, and putting new entries at the head:
=SML
fun Ûroverwrite1Ý lst (a,b) = (
let fun aux [] = fail "" 0 []
| aux ((x,y) :: rest) = (
	if b = y
	then ((a,b) :: rest)
	else ((x,y) :: aux rest)
);
in
	aux lst
	handle complaint =>
	((a,b) :: lst)
end);
=TEX
=SML
fun Ûlist_roverwrite1Ý (abs : ('a * ''b) list) (xys : ('a * ''b) list) : ('a * ''b) list = (
	fold (fn (l1, l2) => roverwrite1 l2 l1) abs xys
);
=IGN
list_roverwrite1 [(1,"1"),(3,"3"),(4,"3"),(5,"5")] [(2,"2"),(0,"5"),(4,"4")];
=TEX
\section{EQUATIONAL CONTEXTS}
An equational context is a list of conversions,
each paired with term index. It represents a statement of
how to
rewrite a term to result in an equational theorem,
guided by the outermost form of the term to be rewritten,
which is matched against the term index of each conversion.
=SML
type ÛEQN_CXTÝ = (TERM * CONV) list;
=TEX
In the following, if $simple\_eq\_match\_conv1$
is successfully applied, then the term destruction
but be successful.
=SML
fun Ûthm_eqn_cxtÝ (thm : THM) : (TERM * CONV) = (
let	val cnv =  simple_eq_match_conv1 thm
		handle complaint =>
		pass_on complaint "simple_eq_match_conv1" "thm_eqn_cxt";
	val lhs = fst(dest_eq(snd(strip_µ (concl thm))));
in
	(lhs, cnv)
end);
=TEX
=SML
local
	fun FIRST_CHANGED_C (cv :: rest) tm =
		(CHANGED_C cv ORELSE_C FIRST_CHANGED_C rest) tm
	| FIRST_CHANGED_C [] tm = term_fail "eqn_cxt_conv" 51005 [tm];
in
fun Ûeqn_cxt_convÝ (ec : EQN_CXT) : CONV = (
let	val net = make_net ec;
in
	(fn tm => FIRST_CHANGED_C(net_lookup net tm)tm
	)
end);
end;
=TEX

\section{TYPES}
The following is the object stored in the stack and database of proof contexts.
=SML
type ÛPROOF_CONTEXTÝ = {
	rw_eqn_cxt: (EQN_CXT * string)list,
	rw_canons: ((THM -> THM list) list * string)list,
				(* CANON list * ... *)
	st_eqn_cxt: (EQN_CXT * string) list,
	sg_eqn_cxt: (EQN_CXT * string) list,
	cs_¶_convs: (CONV list * string) list,
	¶_cd_thms: THM list,
	¶_vs_thms: (string * (TERM list * THM)) list,
=TEX
Now the evaluated parts:
=SML
	rw_net: CONV NET,
	rw_canon: THM -> THM list,	(* CANON *)
	st_conv: CONV,
	sg_conv: CONV,
	cs_¶_conv: TERM -> THM,
	¶_ad_cd_thms:  (TERM list * int list * TYPE * (TERM list)list * THM) list,
	¶_ad_vs_thms:  (string * (TERM list * THM)) list,
=TEX
And finally the commital data
=SML
	names : string list,
	theoryname : string,
	a_valid_thm : THM,
	committed : bool
	};
=TEX
$a\_valid\_thm$ is intended to be set to a theorem generated 
at the creation of the proof context, and if that is not valid (by $valid\_thm$) then the proof context itself is considered ``stale''.
\section{DATA STRUCTURES AND ABSTRACT DATA TYPES}
\subsection{Proof Context ``initial''}
=SML
fun Ûempty_pcÝ (committed : bool)(names : string list): PROOF_CONTEXT = {
	rw_eqn_cxt = [],
	rw_canons = [],
	st_eqn_cxt = [],
	sg_eqn_cxt = [],
	cs_¶_convs = [],
	¶_cd_thms = [],
	¶_vs_thms = [],
=TEX
Now the evaluated parts:
=SML
	rw_net = empty_net,
	rw_canon = (fn thm => [thm]),	(* CANON *)
	st_conv = fail_conv,
	sg_conv = fail_conv,
	cs_¶_conv = (fn _ => fail "icl'set_eval_ad_cs_¶_convs" 51015 []),
	¶_ad_cd_thms = [],
	¶_ad_vs_thms = [],
=TEX
And finally the commital data
=SML
	names = names,
	theoryname = get_current_theory_name(),
	a_valid_thm = icl'Kernel.icl'refl_conv (mk_var("a",BOOL)),
	committed = committed
	};
=TEX
Now the initial proof context (local only):
=SML
val Ûinitial_pcÝ = empty_pc true ["initial"];
=TEX
\subsection{Database of Proof Contexts}
Unsurprisingly, this is a simple dictionary, stored in an assignable variable.
=SML
local
	val pc_db : (PROOF_CONTEXT S_DICT) ref = ref (
		s_enter "initial" initial_pc initial_s_dict);
in
=TEX
Local declarations:
=SML
fun Ûget_pcÝ (caller: string) (key : string) : PROOF_CONTEXT = (
	case s_lookup key (!pc_db) of
	Value (pc as {a_valid_thm = a_valid_thm,theoryname=theoryname,...}) => (
		if valid_thm a_valid_thm
		then pc
		else fail caller 51014 [(fn () => key),(fn () => theoryname)]
	) | Nil => fail caller 51010 [fn () => key]
);

fun Ûextend_pcÝ (caller: string) (key : string) (pc : PROOF_CONTEXT) : unit = ((
	pc_db := s_extend key pc (!pc_db);
	())
	handle (Fail _) =>
	fail caller 51011 [fn () => key]
);

fun Ûchange_pcÝ (caller: string) (key : string) 
	(pcf : PROOF_CONTEXT -> PROOF_CONTEXT) : unit = (
let	val opc as {committed = committed,...} = get_pc caller key;
	val sideeeffect = if committed 
		then fail caller 51016 [fn () => key]
		else ();
in
	(pc_db := s_enter key (pcf opc) (!pc_db);
	())
end);
=TEX
Seen in signature:
=SML
local
	fun detail (key,({theoryname = theoryname,
		a_valid_thm = a_valid_thm, ...}:PROOF_CONTEXT)) = (
		if valid_thm a_valid_thm
		then (key,theoryname)
		else (key,get_error_message 51018 [theoryname])
	);
in
fun Ûshow_pcsÝ () : (string * string)list = (
	map detail (!pc_db)
);
end;
=TEX
Seen in signature:
=SML
fun Ûdelete_pcÝ (key : string) :unit = (
	if key = "initial"
	then fail "delete_pc" 51012 []
	else (
	case s_lookup key (!pc_db) of
	Value _ => (
		pc_db := s_delete key (!pc_db);
		()
	) | Nil => fail "delete_pc" 51010 [fn () => key])
);
=TEX
=SML
fun Ûnew_pcÝ (new: string) : unit = (
	extend_pc "new_pc" new (empty_pc false [new])
);
=TEX
End of database functions
=SML
end;
=TEX
\subsection{Proof Context Stack}
The current proof context is not actually on the proof context
stack, but separate.
=SML
local
	val pc_stack : (PROOF_CONTEXT list) ref = ref [];
in
fun push_pc_stack pc = (pc_stack := (pc :: (!pc_stack));());
fun pop_pc_stack caller = (
	case (!pc_stack) of
	[] => fail caller 51001 []
	| (a :: x) => (pc_stack := x; a)
);
local
	fun detail (({theoryname = theoryname,
		a_valid_thm = a_valid_thm, names = names, ...}:PROOF_CONTEXT)) = (
		if valid_thm a_valid_thm
		then (names,theoryname)
		else (names,get_error_message 51018 [theoryname])
	);
in
fun Ûshow_stack_pcsÝ () : (string list * string)list = (
	map detail (!pc_stack)
);
end;
end; (* of local pc_stack *)
=TEX
\subsection{Current Proof Context}
=SML
local
	val current_pc : PROOF_CONTEXT ref = ref initial_pc;
	val ad_rw_net = ref (#rw_net initial_pc);
	val ad_rw_canon = ref (#rw_canon initial_pc);
	val ad_st_conv = ref (#st_conv initial_pc);
	val ad_sg_conv = ref (#sg_conv initial_pc);
	val ad_cs_¶_convs = ref (#cs_¶_conv initial_pc);
	val ad_¶_ad_cd_thms = ref (#¶_ad_cd_thms initial_pc);
	val ad_¶_ad_vs_thms = ref (#¶_ad_vs_thms initial_pc);
in
=TEX
Set the current proof context:
=SML
fun set_current_pc pc = (
	current_pc := pc;
	ad_rw_net := (#rw_net pc);
	ad_rw_canon := (#rw_canon pc);
	ad_st_conv := (#st_conv pc);
	ad_sg_conv := (#sg_conv pc);
	ad_cs_¶_convs := (#cs_¶_conv pc);
	ad_¶_ad_cd_thms := (#¶_ad_cd_thms pc);
	ad_¶_ad_vs_thms := (#¶_ad_vs_thms pc);
	()
);
=TEX
Access the current proof context:
=SML
fun Ûcurrent_ad_rw_netÝ ():CONV NET = (!ad_rw_net);
fun Ûcurrent_ad_rw_canonÝ ():THM -> THM list = (!ad_rw_canon);
fun Ûcurrent_ad_st_convÝ ():CONV = (!ad_st_conv);
fun Ûcurrent_ad_sg_convÝ ():CONV = (!ad_sg_conv);
fun Ûcurrent_ad_cs_¶_convÝ ():TERM -> THM = (!ad_cs_¶_convs);
fun Ûcurrent_ad_¶_cd_thmsÝ ()
	: (TERM list * int list * TYPE * (TERM list)list * THM) list
	= (!ad_¶_ad_cd_thms);
fun Ûcurrent_ad_¶_vs_thmsÝ ():(string * (TERM list * THM)) list 
	= (!ad_¶_ad_vs_thms);

fun Ûshow_current_pcÝ () : (string list * string) = (
	if valid_thm (#a_valid_thm (!current_pc))
	then ((#names (!current_pc)),(#theoryname (!current_pc)))
	else ((#names (!current_pc)),get_error_message 51018 [(#theoryname (!current_pc))])
);

fun Ûget_current_pcÝ () = (!current_pc);
=TEX
End of current proof context stuff:
=SML
end;
=TEX
\subsection{Evaluation Functions}
We cannot express $eval\_ad\_rw\_canon$ properly yet.
=SML
local
val eval_ad_rw_net : (EQN_CXT -> CONV NET) ref = ref make_net;
val eval_ad_rw_canon : ((THM -> THM list) list -> (THM -> THM list)) ref = 
	ref (fn _ => fn thm => [thm]);
val eval_ad_st_conv : (EQN_CXT -> CONV) ref = ref eqn_cxt_conv;
val eval_ad_sg_conv : (EQN_CXT -> CONV) ref = ref eqn_cxt_conv;

local
	fun try_all [] = (fn tm => fail "current_ad_cs_¶_conv" 51015 [])
	| try_all (afun :: []) = afun
	| try_all (afun :: rest) = afun AND_OR_C (try_all rest);
in
val eval_ad_cs_¶_convs : (CONV list -> CONV) ref = ref try_all;
end;
	
val eval_ad_¶_ad_cd_thms : (THM list -> 
	(TERM list * int list * TYPE * (TERM list)list * THM) list) ref = 
	ref (fn _ => []);
val eval_ad_¶_ad_vs_thms : ((string * (TERM list * THM)) list ->
	(string * (TERM list * THM)) list) ref = ref Combinators.I;
in
fun Ûicl'set_eval_ad_rw_netÝ (f:(EQN_CXT -> CONV NET)) : unit =
	(eval_ad_rw_net := f; ());
fun Ûicl'set_eval_ad_rw_canonÝ (f:((THM -> THM list) list -> 
	(THM -> THM list))) : unit =
	(eval_ad_rw_canon := f; ());
fun Ûicl'set_eval_ad_st_convÝ (f:(EQN_CXT -> CONV)) : unit = 
	(eval_ad_st_conv := f; ());
fun Ûicl'set_eval_ad_sg_convÝ (f:(EQN_CXT -> CONV)) : unit =
	(eval_ad_sg_conv := f; ());
fun Ûicl'set_eval_ad_cs_¶_convsÝ (f:(CONV list -> CONV)) =
	(eval_ad_cs_¶_convs := f; ());
fun Ûicl'set_eval_ad_¶_cd_thmsÝ (f:(THM list -> 
	(TERM list * int list * TYPE * (TERM list)list * THM) list)) =
	(eval_ad_¶_ad_cd_thms := f; ());
fun Ûicl'set_eval_ad_¶_vs_thmsÝ (f:((string * (TERM list * THM)) list ->
	(string * (TERM list * THM)) list)) =
	(eval_ad_¶_ad_vs_thms := f; ());
=TEX
Now the method of evaluating a proof context:
=SML
fun Ûevaluate_proof_contextÝ (
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
	: PROOF_CONTEXT) : PROOF_CONTEXT = 
	{
	rw_eqn_cxt = rw_eqn_cxt,
	rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt,
	sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs,
	¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms,
	rw_net = (!eval_ad_rw_net) (flat(map fst rw_eqn_cxt)),
	rw_canon = (!eval_ad_rw_canon) (flat(map fst rw_canons)),
	st_conv = (!eval_ad_st_conv) (flat(map fst st_eqn_cxt)),
	sg_conv = (!eval_ad_sg_conv) (flat(map fst sg_eqn_cxt)),
	cs_¶_conv = (!eval_ad_cs_¶_convs) (flat(map fst cs_¶_convs)),
	¶_ad_cd_thms = (!eval_ad_¶_ad_cd_thms) ¶_cd_thms,
	¶_ad_vs_thms  = (!eval_ad_¶_ad_vs_thms) ¶_vs_thms,
	names = names,
	theoryname = theoryname,
	a_valid_thm = a_valid_thm,
	committed = committed};
=TEX
End of evaluating things.
=SML
end;
=TEX
\section{OTHER FUNCTIONS}
\subsection{Setting and Getting User Data}
\subsubsection{Rewriting Equations Context}
=SML
fun Ûset_rw_eqn_cxtÝ (ec:EQN_CXT) (key:string) : unit =  (
change_pc "set_rw_eqn_cxt" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = roverwrite1 rw_eqn_cxt (ec,key), rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun Ûget_rw_eqn_cxtÝ (key:string) : (EQN_CXT * string) list = (
	#rw_eqn_cxt (get_pc "get_rw_eqn_cxt" key)
);
=TEX
In adding the theorems we canonicalise them by what the
proof context would evaluate as its current canonicalisation.
=SML
fun Ûadd_rw_thmsÝ (thms:THM list) (key:string) : unit =  (
change_pc "add_rw_thms" key 
((fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}:PROOF_CONTEXT
 =>
	let val cthms = map thm_eqn_cxt(flat (map rw_canon thms));
	in
	{
	rw_eqn_cxt = (case rassoc5 rw_eqn_cxt key of
		Value x => roverwrite1 rw_eqn_cxt ((cthms @ x),key)
		| Nil =>  ((cthms, key) :: rw_eqn_cxt)), 
	rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
	end)
o
evaluate_proof_context)
);
=TEX
\subsubsection{Rewriting Canonicalisation}
=SML
fun Ûset_rw_canonsÝ (can: (THM -> THM list) list) (key:string) : unit =  (
change_pc "set_rw_canons" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = roverwrite1 rw_canons (can,key),
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun Ûget_rw_canonsÝ (key:string) : ((THM -> THM list) list * string) list = (
	#rw_canons (get_pc "get_rw_canons" key)
);
=TEX
\subsubsection{Theorem Stripping Equational Context}
=SML
fun Ûset_st_eqn_cxtÝ (ec:EQN_CXT) (key:string) : unit =  (
change_pc "set_st_eqn_cxt" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = roverwrite1 st_eqn_cxt (ec,key), sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun Ûget_st_eqn_cxtÝ (key:string) : (EQN_CXT * string) list = (
	#st_eqn_cxt (get_pc "get_st_eqn_cxt" key)
);
=TEX
In adding the theorems we canonicalise them by what the
proof context would evaluate as its current canonicalisation.
=SML
fun Ûadd_st_thmsÝ (thms:THM list) (key:string) : unit =  (
change_pc "add_st_thms" key 
((fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}:PROOF_CONTEXT
 =>
	let val cthms = map thm_eqn_cxt(flat (map rw_canon thms));
	in
	{
	rw_eqn_cxt = rw_eqn_cxt, 
	rw_canons = rw_canons,
	st_eqn_cxt = (case rassoc5 st_eqn_cxt key of
		Value x => roverwrite1 st_eqn_cxt ((cthms @ x),key)
		| Nil =>  ((cthms, key) :: st_eqn_cxt)), 
	sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
	end)
o
evaluate_proof_context)
);
=TEX
\subsubsection{Goal Stripping Equational Context}
=SML
fun Ûset_sg_eqn_cxtÝ (ec:EQN_CXT) (key:string) : unit =  (
change_pc "set_sg_eqn_cxt" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = roverwrite1 sg_eqn_cxt (ec,key),
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun Ûget_sg_eqn_cxtÝ (key:string) : (EQN_CXT * string) list = (
	#sg_eqn_cxt (get_pc "get_sg_eqn_cxt" key)
);
=TEX
=SML
fun Ûadd_sg_thmsÝ (thms:THM list) (key:string) : unit =  (
change_pc "add_sg_thms" key 
((fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}:PROOF_CONTEXT
 =>
	let val cthms = map thm_eqn_cxt(flat (map rw_canon thms));
	in
	{
	rw_eqn_cxt = rw_eqn_cxt, 
	rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, 
	sg_eqn_cxt = (case rassoc5 sg_eqn_cxt key of
		Value x => roverwrite1 sg_eqn_cxt ((cthms @ x),key)
		| Nil =>  ((cthms, key) :: sg_eqn_cxt)),
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
	end)
o
evaluate_proof_context)
);
=TEX

\subsubsection{Automated Existence Provers}
=SML
fun Ûset_cs_¶_convsÝ (rls : CONV list) (key:string) : unit =  (
change_pc "set_cs_¶_convs" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = roverwrite1 cs_¶_convs (rls,key), ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun Ûget_cs_¶_convsÝ (key:string) : (CONV list * string) list = (
	#cs_¶_convs (get_pc "get_cs_¶_convs" key)
);
=TEX
\subsubsection{Clausal Definition Theorems}
=SML
fun Ûset_¶_cd_thmsÝ (cd : THM list) (key:string) : unit =  (
change_pc "set_¶_cd_thms" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = cd,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
fun Ûget_¶_cd_thmsÝ (key:string) : THM list = (
	#¶_cd_thms (get_pc "get_¶_cd_thms" key)
);
=TEX
=SML
fun Ûadd_¶_cd_thmsÝ (thms:THM list) (key:string) : unit =  (
change_pc "add_¶_cd_thms" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}:PROOF_CONTEXT
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, 
	rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, 
	sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, 
	¶_cd_thms = thm_union thms ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
	)
);
=TEX
\subsubsection{Variable Structure Theorems}
=SML
local
fun list_eq (a :: x) (b :: y) = a =$ b andalso list_eq x y
| list_eq [] [] = true
| list_eq _ _ = false;

val union_bits = union (fn ((str1,(tml1,thm1)) ,(str2,(tml2,thm2))) =>
	str1 = str2 andalso (list_eq tml1 tml2) andalso (thm1 =|- thm2))
in
fun Ûset_¶_vs_thmsÝ (vs : (string * (TERM list * THM))list) (key:string) : unit =  (
change_pc "set_¶_vs_thms" key 
(fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = union_bits ¶_vs_thms vs, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed})
);
end;
fun Ûget_¶_vs_thmsÝ (key:string) : (string * (TERM list * THM))  list = (
	#¶_vs_thms (get_pc "get_¶_vs_thms" key)
);
=TEX

\subsection{Functions upon Proof Contexts}
=SML
fun Ûcommit_pcÝ (key:string) : unit =  (
change_pc "commit_pc" key 
((fn 
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}
 =>
	{
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = true})
o evaluate_proof_context)
);
=TEX
N.B. the second of the pair is ``the master'', to which the first is added in.
=SML
local
fun list_eq (a :: x) (b :: y) = a =$ b andalso list_eq x y
| list_eq [] [] = true
| list_eq _ _ = false;

val union_bits = union (fn ((str1,(tml1,thm1)) ,(str2,(tml2,thm2))) =>
	str1 = str2 andalso (list_eq tml1 tml2) andalso (thm1 =|- thm2))
in
fun Ûlocal_merge_pcÝ (caller:string) (test_committed:bool) (({
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}:PROOF_CONTEXT),
	({
	rw_eqn_cxt = rw_eqn_cxt1, rw_canons = rw_canons1,
	st_eqn_cxt = st_eqn_cxt1, sg_eqn_cxt = sg_eqn_cxt1,
	cs_¶_convs = cs_¶_convs1, ¶_cd_thms = ¶_cd_thms1,
	¶_vs_thms = ¶_vs_thms1, rw_net = rw_net1,
	rw_canon = rw_canon1, st_conv = st_conv1,
	sg_conv = sg_conv1, cs_¶_conv = cs_¶_conv1,
	¶_ad_cd_thms = ¶_ad_cd_thms1, ¶_ad_vs_thms  = ¶_ad_vs_thms1,
	names = names1, theoryname = theoryname1,
	a_valid_thm = a_valid_thm1, committed = committed1}:PROOF_CONTEXT
)) : PROOF_CONTEXT = (
	if test_committed andalso not committed
	then fail caller 51017 [fn () => hd names]
	else
	{
	rw_eqn_cxt = list_roverwrite1 rw_eqn_cxt rw_eqn_cxt1,
	rw_canons = list_roverwrite1 rw_canons rw_canons1,
	st_eqn_cxt = list_roverwrite1 st_eqn_cxt st_eqn_cxt1,
	sg_eqn_cxt = list_roverwrite1 sg_eqn_cxt sg_eqn_cxt1,
	cs_¶_convs = list_roverwrite1 cs_¶_convs cs_¶_convs1,
	¶_cd_thms = thm_union ¶_cd_thms ¶_cd_thms1,
	¶_vs_thms = union_bits ¶_vs_thms ¶_vs_thms1,
	rw_net = rw_net1,
	rw_canon = rw_canon1,
	st_conv = st_conv1,
	sg_conv = sg_conv1,
	cs_¶_conv = cs_¶_conv1,
	¶_ad_cd_thms = ¶_ad_cd_thms1,
	¶_ad_vs_thms  = ¶_ad_vs_thms1,
	names = names1,
	theoryname = theoryname1,
	a_valid_thm = a_valid_thm1,
	committed = false}
);
end;
=TEX
=SML
fun Ûmerge_pcsÝ (keys:string list) (key : string) : unit = (
let	val pcs = map (get_pc "merge_pcs") keys;
in
	change_pc "merge_pcs" key 
	(fn pc => fold (local_merge_pc "merge_pcs" true) pcs pc)
end);
=TEX
=SML
local
val valid_fields = ["rw_eqn_cxt","rw_canons","st_eqn_cxt",
	"sg_eqn_cxt","cs_¶_convs","¶_cd_thms","¶_vs_thms"];
in
fun Ûprune_pcÝ (caller : string) (fields : string list) ({
	rw_eqn_cxt = rw_eqn_cxt, rw_canons = rw_canons,
	st_eqn_cxt = st_eqn_cxt, sg_eqn_cxt = sg_eqn_cxt,
	cs_¶_convs = cs_¶_convs, ¶_cd_thms = ¶_cd_thms,
	¶_vs_thms = ¶_vs_thms, rw_net = rw_net,
	rw_canon = rw_canon, st_conv = st_conv,
	sg_conv = sg_conv, cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms, ¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names, theoryname = theoryname,
	a_valid_thm = a_valid_thm, committed = committed}: PROOF_CONTEXT) 
	: PROOF_CONTEXT = (
	if not(fields subset valid_fields)
	then fail caller 51019 [fn () => hd(fields diff valid_fields)]
	else
	{
	rw_eqn_cxt = if "rw_eqn_cxt" mem fields then rw_eqn_cxt else [],
	rw_canons = if "rw_canons" mem fields then rw_canons else [],
	st_eqn_cxt = if "st_eqn_cxt" mem fields then st_eqn_cxt else [],
	sg_eqn_cxt = if "sg_eqn_cxt" mem fields then sg_eqn_cxt else [],
	cs_¶_convs = if "cs_¶_convs" mem fields then cs_¶_convs else [],
	¶_cd_thms = if "¶_cd_thms" mem fields then ¶_cd_thms else [],
	¶_vs_thms = if "¶_vs_thms" mem fields then ¶_vs_thms else [],
	rw_net = rw_net,
	rw_canon = rw_canon,
	st_conv = st_conv,
	sg_conv = sg_conv,
	cs_¶_conv = cs_¶_conv,
	¶_ad_cd_thms = ¶_ad_cd_thms,
	¶_ad_vs_thms  = ¶_ad_vs_thms,
	names = names,
	theoryname = theoryname,
	a_valid_thm = a_valid_thm,
	committed = committed}
);
end; 
=TEX
=SML
local
	fun get_stuff {context:string,fields:string list}:PROOF_CONTEXT = (
	let	val pc = get_pc "merge_pc_fields" context;
	in
		prune_pc "merge_pc_fields" fields pc
	end);
in
fun Ûmerge_pc_fieldsÝ (lst : {context:string,fields:string list}list) 
	(key :string) : unit = (
let	val pcs = map get_stuff lst;
in
	change_pc "merge_pc_fields" key 
	(fn pc => fold (local_merge_pc "merge_pc_fields" true) pcs pc)
end);
end;
=TEX
=SML
fun Ûpush_pcÝ (key : string): unit = (
let	val pc = get_pc "push_pc" key;
	val epc = if #committed pc
		then pc
		else evaluate_proof_context pc;
in
	(push_pc_stack (get_current_pc());
	set_current_pc epc)
end);
=TEX
=SML
fun Ûpop_pcÝ (): unit = (
let	val pc = pop_pc_stack "pop_pc";
in
	set_current_pc pc
end);
=TEX
=SML
fun Ûset_pcÝ (key : string): unit = (
let	val pc = get_pc "set_pc" key;
	val epc = if #committed pc
		then pc
		else evaluate_proof_context pc;
in
	set_current_pc epc
end);
=TEX
=SML
fun Ûpush_merge_pcsÝ ([]: string list): unit = fail "push_merge_pcs" 51020 []
| push_merge_pcs (keys) = (
let	val pc = empty_pc false keys;
	val fullpc = fold (local_merge_pc "push_merge_pcs" false) 
		(map (get_pc "push_merge_pcs") keys) pc;
	val epc = evaluate_proof_context fullpc;
in
	(push_pc_stack (get_current_pc());
	set_current_pc epc)
end);
=TEX
=SML
fun Ûset_merge_pcsÝ ([]: string list): unit = fail "set_merge_pcs" 51020 []
| set_merge_pcs (keys) = (
let	val pc = empty_pc false keys;
	val fullpc = fold (local_merge_pc "set_merge_pcs" false) 
		(map (get_pc "set_merge_pcs") keys) pc;
	val epc = evaluate_proof_context fullpc;
in
	set_current_pc epc
end);
=TEX
\section{END OF SIGNATURE}
=SML
end; (* of structure ProofContext *)
open_theory lthy;
open ProofContext;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
