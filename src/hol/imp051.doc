=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation of Proof Contexts}
\TPPref{DS/FMU/IED/IMP051}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.BLackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives an implementation providing proof contexts.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First draft version.
\item [Issue 1.2]
Made default conversions $fail\_conv$.
Reacted to $NetTools$ being open.
\item [Issue 1.3]
Moved to using abstract data types.
\end{description}
\subsection{Changes Forecast}
As detailed design.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for material
whose detailed design is given in in \cite{DS/FMU/IED/DTD051}.
It is module tested in \cite{DS/FMU/IED/MDT051}
\subsection{Introduction}
\subsubsection{Purpose and Background}
A proof context is a setting of various configurable
parameters of proof tools to support a particular mode of proof.
For instance, both $rewrite\_tac$ and $strip\_tac$ 
are configurable proof tools.
In particular, proof contexts will be later made available,
through the tools supplied here,
that supply a good environment to reason about Z,
or within a particular theory (e.g. set theory),
and alter the default environment.

\subsubsection{Dependencies}
This document is dependent on \cite{DS/FMU/IED/DTD051}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
As detailed design.
\section{PREAMBLE}
=SML
structure âProofContextá : ProofContext = struct
=TEX
\section{UTILITIES}
=TEX
\section{EQUATIONAL CONTEXTS}
An equational context is a list of conversions,
each paired with term index. It represents a statement of
how to
rewrite a term to result in an equational theorem,
guided by the outermost form of the term to be rewritten,
which is matched against the term index of each conversion.
=SML
type âEQN_CXTá = (TERM * CONV) list;
=TEX
In the following, if $simple\_eq\_match\_1\_conv$
is successfully applied, then the term destruction
but be successful.
=SML
fun âthm_eqn_cxtá (thm : THM) : (TERM * CONV) = (
let	val cnv =  simple_eq_match_1_conv thm
		handle complaint =>
		pass_on complaint "simple_eq_match_1_conv" "thm_eqn_cxt";
	val lhs = fst(dest_eq(snd(strip_ƒ (concl thm))));
in
	(lhs, cnv)
end);
=TEX
=SML
local
	fun FIRST_CHANGED_C (cv :: rest) tm =
		(CHANGED_C cv ORELSE_C FIRST_CHANGED_C rest) tm
	| FIRST_CHANGED_C [] tm = term_fail "eqn_cxt_conv" 51005 [tm];
in
fun âeqn_cxt_convá (ec : EQN_CXT) : CONV = (
let	val net = make_net ec;
in
	(fn tm => FIRST_CHANGED_C(net_lookup net tm)tm
	)
end);
end;
=TEX

\section{TYPES}
=SML
abstype âPROOF_CONTEXTá = pc of {
	name : string,
	rw_eqn_cxt: EQN_CXT,
	rw_canons: (THM -> THM list) list,	(* CANON list*)
	st_eqn_cxt: EQN_CXT,
	sg_eqn_cxt: EQN_CXT}
and
=TEX
=SML
âEPROOF_CONTEXTá = epc of {
	name : string,
	rw_net: CONV NET,
	rw_canon: THM -> THM list,	(* CANON *)
	st_conv: CONV,
	sg_conv: CONV}
with
=TEX
\section{CODE}
\subsection{Within the ADT}
=SML
fun âset_pc_nameá (nm : string) (pc{name = name,
		rw_eqn_cxt = rw_eqn_cxt,
		rw_canons = rw_canons,
		st_eqn_cxt = st_eqn_cxt,
		sg_eqn_cxt = sg_eqn_cxt} :
		PROOF_CONTEXT): PROOF_CONTEXT = (
	pc {name = nm,
		rw_eqn_cxt = rw_eqn_cxt,
		rw_canons = rw_canons,
		st_eqn_cxt = st_eqn_cxt,
		sg_eqn_cxt = sg_eqn_cxt}
);
fun âget_pc_nameá (pc lpc : PROOF_CONTEXT) : string = #name lpc;
=TEX
=SML
fun âset_epc_nameá (nm : string) (epc{name = name,
		rw_net = rw_net,
		rw_canon = rw_canon,
		st_conv = st_conv,
		sg_conv = sg_conv} :
		EPROOF_CONTEXT): EPROOF_CONTEXT = (
	epc {name = nm,
		rw_net = rw_net,
		rw_canon = rw_canon,
		st_conv = st_conv,
		sg_conv = sg_conv}
);
fun âget_epc_nameá (epc lepc : EPROOF_CONTEXT) : string = #name  lepc;
=TEX
=SML
fun âset_pc_rw_eqn_cxtá (ec : EQN_CXT) (pc{name = name,
		rw_eqn_cxt = rw_eqn_cxt,
		rw_canons = rw_canons,
		st_eqn_cxt = st_eqn_cxt,
		sg_eqn_cxt = sg_eqn_cxt} :
		PROOF_CONTEXT): PROOF_CONTEXT = (
	pc {name = name,
		rw_eqn_cxt = ec,
		rw_canons = rw_canons,
		st_eqn_cxt = st_eqn_cxt,
		sg_eqn_cxt = sg_eqn_cxt}
);
fun âget_pc_rw_eqn_cxtá (pc lpc : PROOF_CONTEXT) : EQN_CXT = #rw_eqn_cxt lpc;
=TEX
=SML
fun âset_epc_rw_netá (cn : CONV NET) (epc{name = name,
		rw_net = rw_net,
		rw_canon = rw_canon,
		st_conv = st_conv,
		sg_conv = sg_conv} :
		EPROOF_CONTEXT): EPROOF_CONTEXT = (
	epc {name = name,
		rw_net = cn,
		rw_canon = rw_canon,
		st_conv = st_conv,
		sg_conv = sg_conv}
);
fun âget_epc_rw_netá (epc lepc : EPROOF_CONTEXT) : CONV NET = #rw_net lepc;
=TEX
=SML
fun âset_pc_rw_canonsá (cs : (THM -> THM list)list) (pc{name = name,
		rw_eqn_cxt = rw_eqn_cxt,
		rw_canons = rw_canons,
		st_eqn_cxt = st_eqn_cxt,
		sg_eqn_cxt = sg_eqn_cxt} :
		PROOF_CONTEXT): PROOF_CONTEXT = (
	pc {name = name,
		rw_eqn_cxt = rw_eqn_cxt,
		rw_canons = cs,
		st_eqn_cxt = st_eqn_cxt,
		sg_eqn_cxt = sg_eqn_cxt}
);
fun âget_pc_rw_canonsá (pc lpc : PROOF_CONTEXT) : (THM -> THM list) list = (
	#rw_canons lpc
);
=TEX
=SML
fun âset_epc_rw_canoná (cn : THM -> THM list) (epc{name = name,
		rw_net = rw_net,
		rw_canon = rw_canon,
		st_conv = st_conv,
		sg_conv = sg_conv} :
		EPROOF_CONTEXT): EPROOF_CONTEXT = (
	epc {name = name,
		rw_net = rw_net,
		rw_canon = cn,
		st_conv = st_conv,
		sg_conv = sg_conv}
);
fun âget_epc_rw_canoná (epc lepc : EPROOF_CONTEXT) : THM -> THM list = #rw_canon lepc;
=TEX
=SML
fun âset_pc_st_eqn_cxtá (ec : EQN_CXT) (pc{name = name,
		rw_eqn_cxt = rw_eqn_cxt,
		rw_canons = rw_canons,
		st_eqn_cxt = st_eqn_cxt,
		sg_eqn_cxt = sg_eqn_cxt} :
		PROOF_CONTEXT): PROOF_CONTEXT = (
	pc {name = name,
		rw_eqn_cxt = rw_eqn_cxt,
		rw_canons = rw_canons,
		st_eqn_cxt = ec,
		sg_eqn_cxt = sg_eqn_cxt}
);
fun âget_pc_st_eqn_cxtá (pc lpc : PROOF_CONTEXT) : EQN_CXT = #st_eqn_cxt lpc;
=TEX
=SML
fun âset_epc_st_convá (cn : CONV) (epc{name = name,
		rw_net = rw_net,
		rw_canon = rw_canon,
		st_conv = st_conv,
		sg_conv = sg_conv} :
		EPROOF_CONTEXT): EPROOF_CONTEXT = (
	epc {name = name,
		rw_net = rw_net,
		rw_canon = rw_canon,
		st_conv = cn,
		sg_conv = sg_conv}
);
fun âget_epc_st_convá (epc lepc : EPROOF_CONTEXT) : CONV = #st_conv lepc;
=TEX
=SML
fun âset_pc_sg_eqn_cxtá (ec : EQN_CXT) (pc{name = name,
		rw_eqn_cxt = rw_eqn_cxt,
		rw_canons = rw_canons,
		st_eqn_cxt = st_eqn_cxt,
		sg_eqn_cxt = sg_eqn_cxt} :
		PROOF_CONTEXT): PROOF_CONTEXT = (
	pc {name = name,
		rw_eqn_cxt = rw_eqn_cxt,
		rw_canons = rw_canons,
		st_eqn_cxt = st_eqn_cxt,
		sg_eqn_cxt = ec}
);
fun âget_pc_sg_eqn_cxtá (pc lpc : PROOF_CONTEXT) : EQN_CXT = #sg_eqn_cxt lpc;
=TEX
=SML
fun âset_epc_sg_convá (cn : CONV) (epc{name = name,
		rw_net = rw_net,
		rw_canon = rw_canon,
		st_conv = st_conv,
		sg_conv = sg_conv} :
		EPROOF_CONTEXT): EPROOF_CONTEXT = (
	epc {name = name,
		rw_net = rw_net,
		rw_canon = rw_canon,
		st_conv = st_conv,
		sg_conv = cn}
);
fun âget_epc_sg_convá (epc lepc : EPROOF_CONTEXT) : CONV = #sg_conv lepc;
=TEX
=SML
val âinitial_pcá: PROOF_CONTEXT = pc {name = "initial_pc",
	rw_eqn_cxt = [],
	rw_canons = [],
	st_eqn_cxt = [],
	sg_eqn_cxt = []};
val âinitial_epcá : EPROOF_CONTEXT = epc  {name = "initial_epc",
	rw_net = empty_net,
	rw_canon = (fn thm => [thm]),
	st_conv = fail_conv,
	sg_conv = fail_conv};
=TEX
=SML
fun âmerge_proof_contextá (pc{name = name1,
		rw_eqn_cxt = rw_eqn_cxt1,
		rw_canons = rw_canons1,
		st_eqn_cxt = st_eqn_cxt1,
		sg_eqn_cxt = sg_eqn_cxt1} :
		PROOF_CONTEXT)
	(pc{name = name2,
		rw_eqn_cxt = rw_eqn_cxt2,
		rw_canons = rw_canons2,
		st_eqn_cxt = st_eqn_cxt2,
		sg_eqn_cxt = sg_eqn_cxt2} :
		PROOF_CONTEXT) = 
	(pc{name = name1 ^ " and " ^ name2,
		rw_eqn_cxt = rw_eqn_cxt1 @ rw_eqn_cxt2,
		rw_canons = rw_canons1 @ rw_canons2,
		st_eqn_cxt = st_eqn_cxt1 @ st_eqn_cxt2,
		sg_eqn_cxt = sg_eqn_cxt1 @ sg_eqn_cxt2} :
		PROOF_CONTEXT)
=SML
end; (* of ADT PROOF_CONTEXT *)
=TEX
The following is the (hidden) current proof context,
and proof context stack,
manipulated by the following visible functions.
=SML
val âcurrent_proof_contextá : EPROOF_CONTEXT ref = ref initial_epc;

val âproof_context_stacká : (EPROOF_CONTEXT list) ref = ref [];
=TEX
=SML
fun âget_proof_contextá () : EPROOF_CONTEXT = (!current_proof_context);

fun âpush_proof_contextá (pc : EPROOF_CONTEXT) : unit = (
	proof_context_stack := (!current_proof_context) :: (!proof_context_stack);
	current_proof_context := pc;
	()
);
fun âpop_proof_contextá () : EPROOF_CONTEXT = (
let	val cpc = (!current_proof_context);
	val (top, rest) = case (!proof_context_stack) of
		[] => fail "pop_proof_context" 51001 []
		| (head :: tail) => (head, tail);
in
	(current_proof_context := top;
	proof_context_stack := rest;
	cpc)
end);
=TEX		
\section{END OF SIGNATURE}
=SML
end; (* of structure ProofContext *)
open ProofContext;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=SML
