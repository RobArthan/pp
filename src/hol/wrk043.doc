=TEX
% 199.doc   %Z% $Date$ $Revision$ $RCSfile$
% COPYRIGHT (c) International Computers Limited, 1992
\documentstyle[hol1]{article}

\pagestyle{empty}
\thispagestyle{empty}

\makeatletter

\parskip=0.5\parskip
% Change the next line to read 245mm when page numbers to be included
%\textheight = 265mm
%\ftaboveboxskip=2mm minus 1mm
%\ftbelowboxskip=2mm minus 1mm
%\def\section{\@startsection {section}{1}{\z@}{-3.5ex plus -1ex minus 
% -2.5ex}{2.3ex plus .2ex}{\Large\bf}}
%\def\subsection{\@startsection{subsection}{2}{\z@}{-3.25ex plus -1ex minus 
% -2.5ex}{1.5ex plus .2ex}{\large\bf}}
%\def\subsubsection{\@startsection{subsubsection}{3}{\z@}{-3.25ex plus 
% -1ex minus -2.5ex}{1.5ex plus .2ex}{\normalsize\bf}}
%\def\paragraph{\@startsection
% {paragraph}{4}{\z@}{3.25ex plus 1ex minus 2.5ex}{-1em}{\normalsize\bf}}
%\def\subparagraph{\@startsection
% {subparagraph}{4}{\parindent}{3.25ex plus 1ex minus 
% .2ex}{-1em}{\normalsize\bf}}
 
% From latex.tex

\def\@dottedtocline#1#2#3#4#5{\ifnum #1>\c@tocdepth \else
  \vskip \z@ plus .2pt
  {\leftskip #2\relax \rightskip \@tocrmarg \parfillskip -\rightskip
    \parindent #2\relax\@afterindenttrue
   \interlinepenalty\@M
   \leavevmode 
   \@tempdima #3\relax \advance\leftskip \@tempdima \hbox{}\hskip -\leftskip
    #4\nobreak
    \hfill\ 
%\leaders\hbox{$\m@th \mkern \@dotsep mu.\mkern \@dotsep 
%       mu$}\hfill \nobreak \hbox to\@pnumwidth{\hfil\rm #5}
\par}\fi}

% From article.sty

\def\l@section#1#2{\addpenalty{\@secpenalty} \addvspace{1.0em plus 1pt}
\@tempdima 1.5em \begingroup
 \parindent \z@ \rightskip \@pnumwidth 
 \parfillskip -\@pnumwidth 
 \bf \leavevmode \advance\leftskip\@tempdima \hskip -\leftskip #1\nobreak%
 \hfill\ 
%\nobreak\hbox to\@pnumwidth{\hss #2}
\par
 \endgroup}

% From ???

% To make index entries have section numbers

\def\@wrindex#1{\let\thepage\relax
   \xdef\@gtempa{\write\@indexfile{\string
      \indexentry{#1}{\@currentlabel}}}\endgroup\@gtempa
   \if@nobreak \ifvmode\nobreak\fi\fi\@esphack}

\makeatother % Stops "@" characters being allowed in macro names.

\newcommand{\Dontprint}[1]{}

\makeindex
\thispagestyle{empty}
\begin{document}
\thispagestyle{empty}
\date{} 
\title{\vspace{-3pc}\bf Ramsey's Theorem in ProofPower}
\author{\large Roger Bishop Jones\\
    \normalsize International Computers Limited, \\
    \normalsize Eskdale Road,
    \normalsize Winnersh, 
    \normalsize Berks, England, RG11 5TT. \\
    \normalsize Phone: +44 734 693131, E-mail: R.B.Jones@win0109.uucp
}
\maketitle
\begin{abstract}
\noindent 
This paper contains a HOL proof of Ramsey's Theorem.
\end{abstract}


\section{Introduction}

=SML 
(*
open_theory"fin_set";
new_theoryÛ"finsetthms"Ý;
use_file"/hat/users/rbj/form/fin";
*)
open_theory"fin_thms";
new_theoryÛ"ramsey"Ý;
¹HOLCONST
Ü ÛsymgÝ : ('a ð ¸ ('a ª 'a))ð
÷üüüüüüüüüüüüüüüüüüüüüüüü
Ü	µ (V,E)· (V,E)  symg
Ü
Ü	¤ E  (VªV) ± µ x y· (x,y)  E ¤ (y,x)  E
Ü
°
=SML
declare_infix(300, "clique_of");

¹HOLCONST
Ü $Ûclique_ofÝ  :  'a ð ­ ('a ð ¸ ('a ª 'a)) ­ BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüü
Ü	µ C (V,E)· C clique_of (V,E)
Ü
Ü	¤ C € V ± (C ¸ C)\(Id C) € E
°
=SML
declare_infix(300, "indep_of");

¹HOLCONST
Ü $Ûindep_ofÝ  :  'a ð ­ ('a ð ¸ ('a ª 'a)) ­ BOOL
÷üüüüüüüüüüüüüüüüüüüüüüüü
Ü	µ C (V,E)· C indep_of (V,E)
Ü
Ü	¤ C € V ± (C ¸ C) ¡ E € Id C
°

Now we prepare for the proof by assigning ml names to the specifications and setting the proof context:
=SML
val symg_def = get_spec¬symg®;
val clique_of_def = get_spec¬$clique_of®;
val indep_of_def = get_spec¬$indep_of®;
set_pc"hol";
=TEX
=SML
set_goal([], ¬
	µ(V, E); U·
	(V, E)  symg ± U € V ´ (U, (U ¸ U) ¡ E)  symg
®);
a(rewrite_tac[symg_def, ¸_def, ª_def] THEN REPEAT(PC_T "hol1" strip_tac)
 THEN asm_fc_tac[]);
val lemma1 = save_pop_thm"lemma1";
=TEX
=SML
set_goal([],¬
	µ (V:'a ð,E) U C·
	U € V ± C clique_of (U, (U ¸ U) ¡ E)
´	C clique_of (V, E)
®);
a(rewrite_tac[clique_of_def, ¸_def, ª_def, id_def]
	THEN PC_T "hol1" (REPEAT strip_tac));
a(asm_fc_tac[] THEN asm_fc_tac[]);
a(spec_nth_asm_tac 4 ¬x®);
val lemma1a = save_pop_thm"lemma1a";
=TEX
=SML
set_goal([],¬
	µ (V:'a ð,E) U C·
	U € V ± C indep_of (U, (U ¸ U) ¡ E)
´	C indep_of (V, E)
®);
a(rewrite_tac[indep_of_def, ¸_def, ª_def, id_def]
	THEN PC_T "hol1" (REPEAT strip_tac));
a(asm_fc_tac[] THEN asm_fc_tac[]);
a(asm_fc_tac[] THEN asm_fc_tac[]);
val lemma1b = save_pop_thm"lemma1b";

=TEX
=SML
push_goal([],¬
	µ (V:'a ð,E) U C·
	C € U ± C indep_of (V, E)
´	C indep_of (U, E)
®);
a(rewrite_tac[indep_of_def, ¸_def, ª_def, id_def]
	THEN PC_T "hol1" (REPEAT strip_tac));
a(asm_fc_tac[] THEN asm_fc_tac[]);
a(spec_nth_asm_tac 4 ¬x®);
val lemma1c = save_pop_thm"lemma1c";
=TEX
=SML
push_goal([],¬
	µ (V:'a ð,E) U C·
	U € V ± C clique_of (U, E)
´	C clique_of (V, E)
®);
a(rewrite_tac[clique_of_def, ¸_def, ª_def, id_def]
	THEN PC_T "hol1" (REPEAT strip_tac));
a(asm_fc_tac[] THEN asm_fc_tac[]);
a(spec_nth_asm_tac 4 ¬x®);
val lemma1d = save_pop_thm"lemma1d";
=TEX
=SML
push_goal([],¬
	µ (V:'a ð,E) U C·
	U € V ± C indep_of (U, E)
´	C indep_of (V, E)
®);
a(rewrite_tac[indep_of_def, ¸_def, ª_def, id_def]
	THEN PC_T "hol1" (REPEAT strip_tac));
a(asm_fc_tac[] THEN asm_fc_tac[]);
a(spec_nth_asm_tac 4 ¬x®);
val lemma1e = save_pop_thm"lemma1e";
=TEX
=SML
set_goal([], ¬({}, {})  symg®);
a(rewrite_tac[symg_def, ¸_def, ª_def] THEN REPEAT(PC_T "hol1" strip_tac)
 THEN asm_fc_tac[]);
val lemma2 = save_pop_thm"lemma2";
=TEX
=SML
set_goal([], ¬µa·a  Finite ´ (#a = 0 ¤ a = {})®);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(REPEAT(POP_ASM_T ante_tac));
a(fin_set_induction_tac THEN1 rewrite_tac[]);
(* *** Goal "1.1" *** *)
a (strip_asm_tac (list_µ_elim [¬a®,¬x®] size_thm5));
a (asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (strip_asm_tac (list_µ_elim [¬a®,¬x®] size_thm5));
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[size_thm1]);
val lemma3 = save_pop_thm"lemma3";
=TEX
The following pair of lemmas justify the constructions used in the inductive step:
=SML
set_goal([],¬
	µ (V:'a ð,E); v; S; i j·
	let R = {x | x  V \ {v} ± (v, x)  E}
	in
		(V, E)  symg
	±	V  Finite
	±	v  V
	±	S € R
	±	(S clique_of (V, (R ¸ R) ¡ E) ± #S = i
		² S indep_of (V, (R ¸ R) ¡ E) ± #S = j)
	´	¶S'·
		S' clique_of (V, E) ± #S' = i+1
		² S' indep_of (V, E) ± #S' = j
®);
a(rewrite_tac[let_def] THEN REPEAT strip_tac);
(* Two subgoals. The one in which S is a clique comes first: *)
(* *** Goal "1" *** *)
a(¶_tac ¬{v} À S® THEN ²_left_tac THEN strip_tac);
(* Two subgoals. First that S' is a clique *)
(* *** Goal "1.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac
	THEN rewrite_tac[clique_of_def, ¸_def, ª_def]
	THEN PC_T"hol1" (REPEAT strip_tac));
(* 6 subgoals *)
(* *** Goal "1.1.1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "1.1.2" *** *)
a(asm_prove_tac[]);
(* *** Goal "1.1.3" *** *)
a(POP_ASM_T (PC_T1 "hol1" (strip_asm_tac o rewrite_rule[id_def])));
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.1.4" *** *)
a(DROP_NTH_ASM_T 7 ante_tac THEN PC_T"hol1" (REPEAT strip_tac));
a(asm_fc_tac[]);
a(swap_asm_concl_tac ¬(v, Snd x)  E® THEN
	GET_ASM_T¬Fst x = v®(rewrite_thm_tac o eq_sym_rule) THEN strip_tac);
(* *** Goal "1.1.5" *** *)
a(DROP_NTH_ASM_T 10 ante_tac THEN rewrite_tac[symg_def] THEN REPEAT strip_tac);
a(POP_ASM_T (fn th => LEMMA_T ¬(Snd x, Fst x)  E® asm_tac THEN fc_tac[th]));
(* *** Goal "1.1.5.1" *** *)
a(GET_ASM_T¬Snd x = v® rewrite_thm_tac);
a(DROP_NTH_ASM_T 8 ante_tac THEN PC_T"hol1" (REPEAT strip_tac));
a(spec_nth_asm_tac 1 ¬Fst x®);
(* *** Goal "1.1.5.2" *** *)
a(TOP_ASM_T ante_tac THEN rewrite_tac[]);
(* *** Goal "1.1.6" *** *)
a(lemma_tac¬x  {(v, w)|v  S ± w  S} \ Id S®);
(* *** Goal "1.1.6.1" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[id_def] THEN REPEAT strip_tac);
(* *** Goal "1.1.6.2" *** *)
a(spec_nth_asm_tac 5 ¬x®);
(* That completes the proof that S' is a clique. Now want #S' = i + 1 *)
(* *** Goal "1.2" *** *)
a(lemma_tac ¬S € V®);
(* *** Goal "1.2.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN PC_T"hol1" (REPEAT strip_tac));
a(PC_T "hol1"(spec_nth_asm_tac 2 ¬x®));
(* *** Goal "1.2.2" *** *)
a(fc_tac[size_thm4]);
a(asm_fc_tac[]);
a(fc_tac[size_thm5]);
a(POP_ASM_T (strip_asm_tac o µ_elim¬v®));
a(asm_rewrite_tac[]);
a(LEMMA_T¬³v  S® rewrite_thm_tac);
a(DROP_NTH_ASM_T 8 ante_tac THEN PC_T"hol1" (REPEAT strip_tac));
a(POP_ASM_T (strip_asm_tac o µ_elim¬v®));
(* That does the case where S was a clique. Now do the case when S is independent *)
(* *** Goal "2" *** *)
a(¶_tac ¬S® THEN ²_right_tac THEN strip_tac);
(* Two subgoals. First that S is independent: *)
(* *** Goal "2.1" *** *)
a(bc_tac[lemma1b]);
a(¶_tac ¬{x|x  V \ {v} ± (v, x)  E}®);
a strip_tac;
(* *** Goal "2.1.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN PC_T"hol1" (REPEAT strip_tac));
a(bc_tac[lemma1c] THEN strip_tac);
(* That does that S is independent. Now Size s = j *)
(* *** Goal "2.2" *** *)
a(strip_tac);
val lemma4 = save_pop_thm"lemma4";

=TEX
The second of the pair of lemmas to justify the constructions
used in the inductive step is the part which is described
as ``analogous'' in the informal proof in \cite{Basin90}
=SML
set_goal([],¬
	µ (V:'a ð,E); v; S; i j·
	let R = {x | x  V \ {v} ± ³(v, x)  E}
	in
		(V, E)  symg
	±	V  Finite
	±	v  V
	±	S € R
	±	(S clique_of (V, (R ¸ R) ¡ E) ± #S = i
		² S indep_of (V, (R ¸ R) ¡ E) ± #S = j)
	´	¶S'·
		S' clique_of (V, E) ± #S' = i
		² S' indep_of (V, E) ± #S' = j+1
®);
a(rewrite_tac[let_def] THEN REPEAT strip_tac);
(* Two subgoals. The one in which S is a clique comes first: *)
(* *** Goal "1" *** *)
a(¶_tac ¬S® THEN ²_left_tac THEN strip_tac);
(* Two subgoals. First that S' is a clique *)
(* *** Goal "1.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac
	THEN rewrite_tac[clique_of_def, ¸_def, ª_def]
	THEN PC_T"hol1" (REPEAT strip_tac));
(* *** Goal "1.1.1" *** *)
a(DROP_NTH_ASM_T 5 ante_tac THEN (PC_T "hol1" (REPEAT strip_tac)));
a(asm_fc_tac[]);
(* *** Goal "1.1.2" *** *)
a(spec_nth_asm_tac 4 ¬x®);
(* *** Goal "1.2" *** *)
a(strip_tac);
(* That does the case where S was a clique. Now do the case when S is independent *)
(* *** Goal "2" *** *)
a(¶_tac ¬{v} À S® THEN ²_right_tac THEN strip_tac);
(* Two subgoals. First that S' is independent: *)
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac
	THEN rewrite_tac[indep_of_def, ¸_def, ª_def]
	THEN PC_T"hol1" (REPEAT strip_tac));
(* 3 subgoals. *)
(* *** Goal "2.1.1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a(DROP_NTH_ASM_T 5 ante_tac THEN (PC_T "hol1" (REPEAT strip_tac)));
a(spec_nth_asm_tac 4 ¬x®);
(* *** Goal "2.1.3" *** *)
a(rewrite_tac[id_def] THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
(* *** Goal "2.1.4" *** *)
a(DROP_NTH_ASM_T 7 ante_tac THEN (PC_T "hol1" (REPEAT strip_tac)));
a(spec_nth_asm_tac 1 ¬Snd x®);
a(swap_asm_concl_tac ¬³ (v, Snd x)  E®);
a(GET_NTH_ASM_T 7 (rewrite_thm_tac o eq_sym_rule) THEN strip_tac);
(* *** Goal "2.1.5" *** *)
a(GET_NTH_ASM_T 10(strip_asm_tac o rewrite_rule[symg_def]));
a(POP_ASM_T (fn th => strip_asm_tac(rewrite_rule[pair_clauses](list_µ_elim[¬Fst x®, ¬Snd x®]th))));
a(swap_asm_concl_tac ¬(Snd x, Fst x)  E® THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 ante_tac THEN (PC_T "hol1" (REPEAT strip_tac)));
a(spec_nth_asm_tac 1 ¬Fst x®);
(* *** Goal "2.1.6" *** *)
a(DROP_NTH_ASM_T 4 ante_tac THEN
	rewrite_tac[id_def] THEN PC_T"hol1" (REPEAT strip_tac));
a(DROP_NTH_ASM_T 7 ante_tac THEN (PC_T "hol1" (REPEAT strip_tac)));
a(asm_fc_tac[]);
(* That shows that S' is independent. Now need #S' = j + 1 *)
(* *** Goal "2.2" *** *)
a(lemma_tac ¬S € V®);
(* *** Goal "2.2.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN PC_T"hol1" (REPEAT strip_tac));
a(PC_T "hol1"(spec_nth_asm_tac 2 ¬x®));
(* *** Goal "2.2.2" *** *)
a(fc_tac[size_thm4]);
a(asm_fc_tac[]);
a(fc_tac[size_thm5]);
a(POP_ASM_T (strip_asm_tac o µ_elim¬v®));
a(asm_rewrite_tac[]);
a(LEMMA_T¬³v  S® rewrite_thm_tac);
a(DROP_NTH_ASM_T 8 ante_tac THEN PC_T"hol1" (REPEAT strip_tac));
a(POP_ASM_T (strip_asm_tac o µ_elim¬v®));
val lemma5 = save_pop_thm"lemma5";
=TEX
=SML
set_goal([], ¬µa b c; x; m n·
	a  Finite
±	#a ¾ m + n
±	a = {x} À b À c
´	#b ¾ m ² #c ¾ n
®);
a(rewrite_tac[pc_rule"hol1"(prove_rule[])¬{x} À b À c = ({x} À b) À c®]);
a(REPEAT strip_tac);
a(lemma_tac¬b € a ± ({x} À b) € a ± c € a®);
(* *** Goal "1" *** *)
a(GET_ASM_T¬a = ({x} À b) À c® ante_tac THEN (PC_T"hol1" (REPEAT strip_tac THEN asm_prove_tac[])));
(* *** Goal "2" *** *)
a(lemma_tac¬#a + #(({x} À b) ¡ c) = #({x} À b) + #c®);
(* *** Goal "2.1" *** *)
a(fc_tac[size_thm4] THEN asm_fc_tac[]);
a(DROP_ASM_T ¬a = ({x} À b) À c® rewrite_thm_tac);
a(bc_tac[size_thm7] THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(swap_asm_concl_tac¬#a + #(({x} À b) ¡ c) = #({x} À b) + #c®);
a(DROP_ASM_T ¬m + n ¼ #a® (strip_asm_tac o rewrite_rule[¼_def]));
a(DROP_ASM_T ¬(m + n) + i = #a® (rewrite_thm_tac o eq_sym_rule));
a(LIST_GET_NTH_ASM_T[1,5] (MAP_EVERY (strip_asm_tac o rewrite_rule[³_¼_thm])));
a(lemma_tac¬#({x} À b) ¼ m®);
(* *** Goal "2.2.1" *** *)
a(fc_tac[size_thm4] THEN asm_fc_tac[] THEN asm_fc_tac[size_thm5]);
a(DROP_NTH_ASM_T 3 (rewrite_thm_tac o rewrite_rule[] o µ_elim¬x®));
a(DROP_NTH_ASM_T 8 ante_tac);
a(rewrite_tac[less_def, ¼_def] THEN REPEAT strip_tac);
a(CASES_T¬x  b® (fn th => rewrite_tac[th] THEN asm_tac th));
(* *** Goal "2.2.1.1" *** *)
a(¶_tac ¬1+i® THEN DROP_NTH_ASM_T 2 (rewrite_thm_tac o rewrite_rule[plus_assoc_thm]));
(* *** Goal "2.2.1.2" *** *)
a(¶_tac ¬i® THEN DROP_NTH_ASM_T 2 rewrite_thm_tac);
(* *** Goal "2.2.2" *** *)
a(LIST_GET_NTH_ASM_T[1,2,3](MAP_EVERY (strip_asm_tac o rewrite_rule[less_def, ¼_def])));
a(LIST_GET_NTH_ASM_T[1,3] (rewrite_tac o map eq_sym_rule));
a(rewrite_tac[µ_elim¬#({x} À b)®plus_order_thm]);
a(rewrite_tac[µ_elim¬#c®plus_order_thm]);
val lemma6 = save_pop_thm"lemma6";
=TEX
The inductive step may be derived from the following theorem:
=SML
set_goal([],¬
	µ a b m n·
	0 < m
±	0 < n
±	(µ (V:'a ð,E) ·
	(V,E)  symg ± V  Finite ± #V ¾ m ´
		(¶ C · C clique_of (V,E) ± #C = a
		² C indep_of (V,E) ± #C = b+1))
±	(µ (V:'a ð,E) ·
	(V,E)  symg ± V  Finite ± #V ¾ n ´
		(¶ C · C clique_of (V,E) ± #C = a+1
		² C indep_of (V,E) ± #C = b))
´	(µ (V:'a ð,E) ·
	(V,E)  symg ± V  Finite ± #V ¾ m + n ´
		(¶ C · C clique_of (V,E) ± #C = a+1
		² C indep_of (V,E) ± #C = b+1))
®);
a(REPEAT(strip_tac));
(* First want to prove ³ V = {} *)
a(FC_T1 id_canon
	(fn ths =>LEMMA_T ¬³ #V = 0® (strip_asm_tac o rewrite_rule ths))[lemma3]);
(* *** Goal "1" *** *)
a(MAP_EVERY (fn t => DROP_ASM_T t
		(strip_asm_tac o rewrite_rule[less_def, ¼_def]))
	[¬m + n ¼ # V®, ¬0 < n®]);
a(DROP_ASM_T ¬(m + n) + i = #V® (rewrite_thm_tac o eq_sym_rule));
a(DROP_ASM_T¬1 + i' = n®(rewrite_thm_tac o eq_sym_rule));
(* Completes proof of ³ V = {} *)
(* *** Goal "2" *** *)
(* Now use ³ V = {} to give an element of V *)
a(PC_T "hol1" (POP_ASM_T strip_asm_tac));
(* Gives us x  V; Easier to read with v  V: *)
a(rename_tac[(¬x®, "v")]);
a(lemma_tac
¬V = {v} À {x | x  V \ {v} ± (v, x)  E} À {x | x  V \ {v} ± ³(v, x)  E}®);
(* *** Goal "2.1" *** *)
a(PC_T "hol1" (REPEAT strip_tac) THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(lemma_tac
¬#{x | x  V \ {v} ± (v, x)  E} ¾ m ² #{x | x  V \ {v} ± ³(v, x)  E} ¾ n®);
(* *** Goal "2.2.1" *** *)
a(bc_tac[lemma6]);
a(¶_tac ¬v® THEN ¶_tac¬V® THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(lemma_tac¬{x|x  V \ {v} ± (v, x)  E}  Finite®);
(* *** Goal "2.2.2.1" *** *)
a(bc_tac[size_thm4] THEN ¶_tac¬V® THEN PC_T "hol1" (REPEAT strip_tac));
(* *** Goal "2.2.2.2" *** *)
a(lemma_tac¬
({x|x  V \ {v} ± (v, x)  E},
 ({x|x  V \ {v} ± (v, x)  E} ¸ {x|x  V \ {v} ± (v, x)  E}) ¡ E)  symg®);
(* *** Goal "2.2.2.2.1" *** *)
a(bc_tac[lemma1] THEN PC_T "hol1" (REPEAT strip_tac));
(* *** Goal "2.2.2.2.2" *** *)
a(list_spec_nth_asm_tac 10 [
	¬{x|x  V \ {v} ± (v, x)  E}®,
	¬({x|x  V \ {v} ± (v, x)  E} ¸ {x|x  V \ {v} ± (v, x)  E}) ¡ E®]);
(* *** Goal "2.2.2.2.2.1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[¾_def]));
(* *** Goal "2.2.2.2.2.2" *** *)
a(bc_tac[rewrite_rule[let_def] lemma4]);
a(¶_tac¬C® THEN ¶_tac ¬v® THEN PC_T "hol1" (REPEAT strip_tac));
(* *** Goal "2.2.2.2.2.2.1" *** *)
a(GET_NTH_ASM_T 3 (PC_T1"hol1"(strip_asm_tac o rewrite_rule[clique_of_def])));
a(spec_nth_asm_tac 2 ¬x®);
(* *** Goal "2.2.2.2.2.2.2" *** *)
a(GET_NTH_ASM_T 3 (PC_T1"hol1"(strip_asm_tac o rewrite_rule[clique_of_def])));
a(spec_nth_asm_tac 2 ¬x®);
(* *** Goal "2.2.2.2.2.2.3" *** *)
a(GET_NTH_ASM_T 3 (PC_T1"hol1"(strip_asm_tac o rewrite_rule[clique_of_def])));
a(spec_nth_asm_tac 2 ¬x®);
(* *** Goal "2.2.2.2.2.2.4" *** *)
a(swap_nth_asm_concl_tac 1 THEN bc_tac [lemma1d]);
a(¶_tac¬{x|x  V \ {v} ± (v, x)  E}® THEN REPEAT strip_tac);
a(PC_T"hol1" (REPEAT strip_tac));
(* *** Goal "2.2.2.2.2.2.4" *** *)
a(swap_nth_asm_concl_tac 1 THEN bc_tac [lemma1d]);
a(¶_tac¬{x|x  V \ {v} ± (v, x)  E}® THEN REPEAT strip_tac);
a(PC_T"hol1" (REPEAT strip_tac));
(* *** Goal "2.2.2.2.2.3" *** *)
(* This is the easy second quarter of the main construction *)
a(¶_tac¬C® THEN ²_right_tac THEN REPEAT strip_tac);
a(bc_tac[lemma1b]);
a(¶_tac¬{x|x  V \ {v} ± (v, x)  E}® THEN REPEAT strip_tac);
a(PC_T"hol1" (REPEAT strip_tac));
(* Completes the second quarter *)
a(lemma_tac¬{x|x  V \ {v} ± ³(v, x)  E}  Finite®);
(* *** Goal "2.2.3.1" *** *)
a(bc_tac[size_thm4] THEN ¶_tac¬V® THEN PC_T "hol1" (REPEAT strip_tac));
(* *** Goal "2.2.3.2" *** *)
a(lemma_tac¬
({x|x  V \ {v} ± ³(v, x)  E},
 ({x|x  V \ {v} ± ³(v, x)  E} ¸ {x|x  V \ {v} ± ³(v, x)  E}) ¡ E)  symg®);
(* *** Goal "2.2.3.2.1" *** *)
a(bc_tac[lemma1] THEN PC_T "hol1" (REPEAT strip_tac));
(* *** Goal "2.2.3.2.2" *** *)
a(list_spec_nth_asm_tac 9 [
	¬{x|x  V \ {v} ± ³(v, x)  E}®,
	¬({x|x  V \ {v} ± ³(v, x)  E} ¸ {x|x  V \ {v} ± ³(v, x)  E}) ¡ E®]);
(* *** Goal "2.2.3.2.2.1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[¾_def]));
(* *** Goal "2.2.3.2.2.2.2" *** *)
(* Now the easy third quarter: *)
a(¶_tac¬C® THEN ²_left_tac THEN REPEAT strip_tac);
a(bc_tac[lemma1a]);
a(¶_tac¬{x|x  V \ {v} ± ³(v, x)  E}® THEN REPEAT strip_tac);
a(PC_T"hol1" (REPEAT strip_tac));
(* Now the final hard quarter: *)
(* *** Goal "2.2.3.2.2.3" *** *)
a(bc_tac[rewrite_rule[let_def] lemma5]);
a(¶_tac¬C® THEN ¶_tac ¬v® THEN PC_T "hol1" (REPEAT strip_tac));
(* *** Goal "2.2.3.2.2.3.1" *** *)
a(GET_NTH_ASM_T 3 (PC_T1"hol1"(strip_asm_tac o rewrite_rule[indep_of_def])));
a(spec_nth_asm_tac 2 ¬x®);
(* *** Goal "2.2.3.2.2.3.2" *** *)
a(GET_NTH_ASM_T 3 (PC_T1"hol1"(strip_asm_tac o rewrite_rule[indep_of_def])));
a(spec_nth_asm_tac 2 ¬x®);
(* *** Goal "2.2.3.2.2.3.3" *** *)
a(GET_NTH_ASM_T 3 (PC_T1"hol1"(strip_asm_tac o rewrite_rule[indep_of_def])));
a(spec_nth_asm_tac 2 ¬x®);
(* *** Goal "2.2.3.2.2.3.4" *** *)
a(bc_tac [lemma1e]);
a(¶_tac¬{x|x  V \ {v} ± ³(v, x)  E}® THEN PC_T"hol1" (REPEAT strip_tac));
(* *** Goal "2.2.3.2.2.3.5" *** *)
a(bc_tac [lemma1e]);
a(¶_tac¬{x|x  V \ {v} ± ³(v, x)  E}® THEN PC_T"hol1" (REPEAT strip_tac));
val lemma7 = save_pop_thm"lemma7";
=TEX
The base case may be derived from the following theorems:
=SML
set_goal([],¬
	µ (V, E)·
		{} clique_of (V, E)
	±	{} indep_of (V, E)
®);
a(rewrite_tac[clique_of_def, indep_of_def, ¸_def, ª_def, id_def]
	THEN PC_T"hol1" (REPEAT strip_tac));
val lemma8  = save_pop_thm"lemma8";

=TEX
=SML
set_goal([],¬
	µ (V, E); x·
		x  V
	´	{x} clique_of (V, E)
	±	{x} indep_of (V, E)
®);
a(rewrite_tac[clique_of_def, indep_of_def, ¸_def, ª_def, id_def]
	THEN PC_T"hol1" (REPEAT strip_tac) THEN_TRY asm_rewrite_tac[]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
val lemma9  = save_pop_thm"lemma9";
=TEX
=SML
set_goal([],¬
	µ a b · ¶n ·
	µ (V:'a ð,E) ·
	(V,E)  symg ± V  Finite ± #V ¾ n ´
		(¶ C · C clique_of (V,E) ± #C = a
		² C indep_of (V,E) ± #C = b)
®);
a(REPEAT µ_tac);
(* Prefer for induction on an upper bound for a + b: *)
a(lemma_tac¬¶m·a + b ¼ m®
	THEN_LIST[¶_tac¬a + b® THEN rewrite_tac[], POP_ASM_T ante_tac]);
a(intro_µ_tac(¬b®, ¬b®) THEN intro_µ_tac(¬a®, ¬a®));
a(INDUCTION_T ¬m® strip_asm_tac);
(* Base case: *)
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(¶_tac¬0® THEN REPEAT strip_tac);
a(¶_tac¬{}® THEN REPEAT strip_tac THEN 
	fc_tac[lemma3] THEN asm_rewrite_tac[lemma8, size_thm1]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN fc_tac[¼_plus1_thm]);
(* 2 subgoals. One is trivial; the hard one comes first: *)
(* *** Goal "2.1.1" *** *)
(* Case analysis ( a > 0 / b > 0 ): *)
a(strip_asm_tac (µ_elim¬a® î_cases_thm) THEN
	strip_asm_tac (µ_elim¬b® î_cases_thm));
(* 4 cases *)
(* *** Goal "2.1.1" *** *)
a(¶_tac¬0® THEN REPEAT strip_tac);
a(¶_tac¬{}® THEN REPEAT strip_tac THEN 
	fc_tac[lemma3] THEN asm_rewrite_tac[lemma8, size_thm1]);
(* *** Goal "2.1.2" *** *)
a(¶_tac¬0® THEN REPEAT strip_tac);
a(¶_tac¬{}® THEN asm_rewrite_tac[lemma8, size_thm1]);
(* *** Goal "2.1.3" *** *)
a(¶_tac¬0® THEN REPEAT strip_tac);
a(¶_tac¬{}® THEN asm_rewrite_tac[lemma8, size_thm1]);
(* *** Goal "2.1.4" *** *)
a(lemma_tac¬(i+1) + i' ¼ m ± i + (i'+1) ¼ m®);
(* *** Goal "2.1.4.1" *** *)
a(strip_tac);
(* *** Goal "2.1.4.1.1" *** *)
a(GET_ASM_T¬a = i + 1®(rewrite_thm_tac o eq_sym_rule));
a(GET_ASM_T ¬a + b = m + 1® ante_tac THEN GET_ASM_T ¬b = i' + 1®rewrite_thm_tac);
a(rewrite_tac[µ_elim¬1®plus_order_thm]);
a(´_T rewrite_thm_tac);
(* *** Goal "2.1.4.1.2" *** *)
a(GET_ASM_T¬b = i' + 1®(rewrite_thm_tac o eq_sym_rule));
a(GET_ASM_T ¬a + b = m + 1® ante_tac THEN GET_ASM_T ¬a = i + 1®rewrite_thm_tac);
a(rewrite_tac[µ_elim¬1®plus_order_thm]);
a(´_T rewrite_thm_tac);
(* *** Goal "2.1.4.2" *** *)
a(list_spec_nth_asm_tac 7[¬i+1®, ¬i'®]);
a(DROP_NTH_ASM_T 8 (strip_asm_tac o list_µ_elim[¬i®, ¬i'+1®]));
(* Now introduce the witness: *)
a(¶_tac¬(if 0 < n' then n' else 1) + (if 0 < n then n else 1) ®);
a(LIST_GET_NTH_ASM_T [5,6] rewrite_tac THEN bc_tac [rewrite_rule[]lemma7]);
(* 4 subgoals: *)
(* *** Goal "2.1.4.2.1" *** *)
a(CASES_T¬0 < n'® rewrite_thm_tac);
(* *** Goal "2.1.4.2.2" *** *)
a(CASES_T¬0 < n® rewrite_thm_tac);
(* *** Goal "2.1.4.2.3" *** *)
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 bc_thm_tac);
a(rewrite_tac [] THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN cases_tac¬0 < n'® THEN1 asm_rewrite_tac[]);
a(TOP_ASM_T rewrite_thm_tac THEN TOP_ASM_T ante_tac);
a(rewrite_tac[³_less_thm]);
a(´_T rewrite_thm_tac);
(* *** Goal "2.1.4.2.4" *** *)
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 5 bc_thm_tac);
a(rewrite_tac [] THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN cases_tac¬0 < n® THEN1 asm_rewrite_tac[]);
a(TOP_ASM_T rewrite_thm_tac THEN TOP_ASM_T ante_tac);
a(rewrite_tac[³_less_thm]);
a(´_T rewrite_thm_tac);
(* That does the hard bit *)
(* *** Goal "2.2" *** *)
a(asm_fc_tac[]);
a(¶_tac ¬n® THEN REPEAT µ_tac THEN TOP_ASM_T rewrite_thm_tac);
val fin_exp_2_ramsey_thm = save_pop_thm"fin_exp_2_ramsey_thm";
=TEX
%\bibliographystyle{fmu}
%\bibliography{fmu}
\section*{Index of Formal Names}
%\newbox\COLC
%\newbox\COLB
%\newbox\COLA
%\setbox\COLC=\vbox{{\footnotesize\printindex}}
%\newdimen\H
%\H=\ht\COLC
%\divide\H by 3\advance\H by\ht\strutbox
%\splittopskip=\ht\strutbox\vbadness=10000
%\setbox\COLA=\vsplit\COLC to \H
%\setbox\COLB=\vsplit\COLC to \H
%\valign{#\vfil\cr\box\COLA\cr\noalign{\hfill}\box\COLB\cr
%  \noalign{\hfill}\box\COLC\cr}
\printindex
\end{document}




