=TEX
% 199.doc   %Z% $Date$ $Revision$ $RCSfile$
% COPYRIGHT (c) International Computers Limited, 1992
\documentstyle[hol1]{article}

\pagestyle{empty}
\thispagestyle{empty}

\makeatletter

\parskip=0.5\parskip
% Change the next line to read 245mm when page numbers to be included
%\textheight = 265mm
%\ftaboveboxskip=2mm minus 1mm
%\ftbelowboxskip=2mm minus 1mm
%\def\section{\@startsection {section}{1}{\z@}{-3.5ex plus -1ex minus 
% -2.5ex}{2.3ex plus .2ex}{\Large\bf}}
%\def\subsection{\@startsection{subsection}{2}{\z@}{-3.25ex plus -1ex minus 
% -2.5ex}{1.5ex plus .2ex}{\large\bf}}
%\def\subsubsection{\@startsection{subsubsection}{3}{\z@}{-3.25ex plus 
% -1ex minus -2.5ex}{1.5ex plus .2ex}{\normalsize\bf}}
%\def\paragraph{\@startsection
% {paragraph}{4}{\z@}{3.25ex plus 1ex minus 2.5ex}{-1em}{\normalsize\bf}}
%\def\subparagraph{\@startsection
% {subparagraph}{4}{\parindent}{3.25ex plus 1ex minus 
% .2ex}{-1em}{\normalsize\bf}}
 
% From latex.tex

\def\@dottedtocline#1#2#3#4#5{\ifnum #1>\c@tocdepth \else
  \vskip \z@ plus .2pt
  {\leftskip #2\relax \rightskip \@tocrmarg \parfillskip -\rightskip
    \parindent #2\relax\@afterindenttrue
   \interlinepenalty\@M
   \leavevmode 
   \@tempdima #3\relax \advance\leftskip \@tempdima \hbox{}\hskip -\leftskip
    #4\nobreak
    \hfill\ 
%\leaders\hbox{$\m@th \mkern \@dotsep mu.\mkern \@dotsep 
%       mu$}\hfill \nobreak \hbox to\@pnumwidth{\hfil\rm #5}
\par}\fi}

% From article.sty

\def\l@section#1#2{\addpenalty{\@secpenalty} \addvspace{1.0em plus 1pt}
\@tempdima 1.5em \begingroup
 \parindent \z@ \rightskip \@pnumwidth 
 \parfillskip -\@pnumwidth 
 \bf \leavevmode \advance\leftskip\@tempdima \hskip -\leftskip #1\nobreak%
 \hfill\ 
%\nobreak\hbox to\@pnumwidth{\hss #2}
\par
 \endgroup}

% From ???

% To make index entries have section numbers

\def\@wrindex#1{\let\thepage\relax
   \xdef\@gtempa{\write\@indexfile{\string
      \indexentry{#1}{\@currentlabel}}}\endgroup\@gtempa
   \if@nobreak \ifvmode\nobreak\fi\fi\@esphack}

\makeatother % Stops "@" characters being allowed in macro names.

\newcommand{\Dontprint}[1]{}

\makeindex
\thispagestyle{empty}
\begin{document}
\thispagestyle{empty}
\date{} 
\title{\vspace{-3pc}\bf Ramsey's Theorem in ProofPower}
\author{\large Roger Bishop Jones\\
    \normalsize International Computers Limited, \\
    \normalsize Eskdale Road,
    \normalsize Winnersh, 
    \normalsize Berks, England, RG11 5TT. \\
    \normalsize Phone: +44 734 693131, E-mail: R.B.Jones@win0109.uucp
}
\maketitle
\begin{abstract}
\noindent 
This paper contains a HOL proof of Ramsey's Theorem.
\end{abstract}


\section{Introduction}

=SML 
(*
open_theory"fin_set";
new_theory€"finsetthms"›;
use_file"/hat/users/rbj/form/fin";
*)
open_theory"fin_thms";
new_theory€"ramsey"›;
πHOLCONST
‹ €symg› : ('a  ∏ ('a ™ 'a))
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ (V,E)∑ (V,E) ç symg
‹
‹	§ E ç (V™V) ± µ x y∑ (x,y) ç E § (y,x) ç E
‹
∞
=SML
declare_infix(300, "clique_of");

πHOLCONST
‹ $€clique_of›  :  'a  ≠ ('a  ∏ ('a ™ 'a)) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ C (V,E)∑ C clique_of (V,E)
‹
‹	§ C Ä V ± (C ∏ C)\(Id C) Ä E
∞
=SML
declare_infix(300, "indep_of");

πHOLCONST
‹ $€indep_of›  :  'a  ≠ ('a  ∏ ('a ™ 'a)) ≠ BOOL
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ C (V,E)∑ C indep_of (V,E)
‹
‹	§ C Ä V ± (C ∏ C) ° E Ä Id C
∞

Now we prepare for the proof by assigning ml names to the specifications and setting the proof context:
=SML
val symg_def = get_spec¨symgÆ;
val clique_of_def = get_spec¨$clique_ofÆ;
val indep_of_def = get_spec¨$indep_ofÆ;
set_pc"hol";
=TEX
=SML
set_goal([], ¨
	µ(V, E); U∑
	(V, E) ç symg ± U Ä V ¥ (U, (U ∏ U) ° E) ç symg
Æ);
a(rewrite_tac[symg_def, ∏_def, ™_def] THEN REPEAT(PC_T "hol1" strip_tac)
 THEN asm_fc_tac[]);
val lemma1 = save_pop_thm"lemma1";
=TEX
=SML
set_goal([],¨
	µ (V:'a ,E) U C∑
	U Ä V ± C clique_of (U, (U ∏ U) ° E)
¥	C clique_of (V, E)
Æ);
a(rewrite_tac[clique_of_def, ∏_def, ™_def, id_def]
	THEN PC_T "hol1" (REPEAT strip_tac));
a(asm_fc_tac[] THEN asm_fc_tac[]);
a(spec_nth_asm_tac 4 ¨xÆ);
val lemma1a = save_pop_thm"lemma1a";
=TEX
=SML
set_goal([],¨
	µ (V:'a ,E) U C∑
	U Ä V ± C indep_of (U, (U ∏ U) ° E)
¥	C indep_of (V, E)
Æ);
a(rewrite_tac[indep_of_def, ∏_def, ™_def, id_def]
	THEN PC_T "hol1" (REPEAT strip_tac));
a(asm_fc_tac[] THEN asm_fc_tac[]);
a(asm_fc_tac[] THEN asm_fc_tac[]);
val lemma1b = save_pop_thm"lemma1b";

=TEX
=SML
push_goal([],¨
	µ (V:'a ,E) U C∑
	C Ä U ± C indep_of (V, E)
¥	C indep_of (U, E)
Æ);
a(rewrite_tac[indep_of_def, ∏_def, ™_def, id_def]
	THEN PC_T "hol1" (REPEAT strip_tac));
a(asm_fc_tac[] THEN asm_fc_tac[]);
a(spec_nth_asm_tac 4 ¨xÆ);
val lemma1c = save_pop_thm"lemma1c";
=TEX
=SML
push_goal([],¨
	µ (V:'a ,E) U C∑
	U Ä V ± C clique_of (U, E)
¥	C clique_of (V, E)
Æ);
a(rewrite_tac[clique_of_def, ∏_def, ™_def, id_def]
	THEN PC_T "hol1" (REPEAT strip_tac));
a(asm_fc_tac[] THEN asm_fc_tac[]);
a(spec_nth_asm_tac 4 ¨xÆ);
val lemma1d = save_pop_thm"lemma1d";
=TEX
=SML
push_goal([],¨
	µ (V:'a ,E) U C∑
	U Ä V ± C indep_of (U, E)
¥	C indep_of (V, E)
Æ);
a(rewrite_tac[indep_of_def, ∏_def, ™_def, id_def]
	THEN PC_T "hol1" (REPEAT strip_tac));
a(asm_fc_tac[] THEN asm_fc_tac[]);
a(spec_nth_asm_tac 4 ¨xÆ);
val lemma1e = save_pop_thm"lemma1e";
=TEX
=SML
set_goal([], ¨({}, {}) ç symgÆ);
a(rewrite_tac[symg_def, ∏_def, ™_def] THEN REPEAT(PC_T "hol1" strip_tac)
 THEN asm_fc_tac[]);
val lemma2 = save_pop_thm"lemma2";
=TEX
=SML
set_goal([], ¨µa∑a ç Finite ¥ (#a = 0 § a = {})Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(REPEAT(POP_ASM_T ante_tac));
a(fin_set_induction_tac THEN1 rewrite_tac[]);
(* *** Goal "1.1" *** *)
a (strip_asm_tac (list_µ_elim [¨aÆ,¨xÆ] size_thm5));
a (asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (strip_asm_tac (list_µ_elim [¨aÆ,¨xÆ] size_thm5));
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[size_thm1]);
val lemma3 = save_pop_thm"lemma3";
=TEX
The following pair of lemmas justify the constructions used in the inductive step:
=SML
set_goal([],¨
	µ (V:'a ,E); v; S; i j∑
	let R = {x | x ç V \ {v} ± (v, x) ç E}
	in
		(V, E) ç symg
	±	V ç Finite
	±	v ç V
	±	S Ä R
	±	(S clique_of (V, (R ∏ R) ° E) ± #S = i
		≤ S indep_of (V, (R ∏ R) ° E) ± #S = j)
	¥	∂S'∑
		S' clique_of (V, E) ± #S' = i+1
		≤ S' indep_of (V, E) ± #S' = j
Æ);
a(rewrite_tac[let_def] THEN REPEAT strip_tac);
(* Two subgoals. The one in which S is a clique comes first: *)
(* *** Goal "1" *** *)
a(∂_tac ¨{v} ¿ SÆ THEN ≤_left_tac THEN strip_tac);
(* Two subgoals. First that S' is a clique *)
(* *** Goal "1.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac
	THEN rewrite_tac[clique_of_def, ∏_def, ™_def]
	THEN PC_T"hol1" (REPEAT strip_tac));
(* 6 subgoals *)
(* *** Goal "1.1.1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "1.1.2" *** *)
a(asm_prove_tac[]);
(* *** Goal "1.1.3" *** *)
a(POP_ASM_T (PC_T1 "hol1" (strip_asm_tac o rewrite_rule[id_def])));
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.1.4" *** *)
a(DROP_NTH_ASM_T 7 ante_tac THEN PC_T"hol1" (REPEAT strip_tac));
a(asm_fc_tac[]);
a(swap_asm_concl_tac ¨(v, Snd x) ç EÆ THEN
	GET_ASM_T¨Fst x = vÆ(rewrite_thm_tac o eq_sym_rule) THEN strip_tac);
(* *** Goal "1.1.5" *** *)
a(DROP_NTH_ASM_T 10 ante_tac THEN rewrite_tac[symg_def] THEN REPEAT strip_tac);
a(POP_ASM_T (fn th => LEMMA_T ¨(Snd x, Fst x) ç EÆ asm_tac THEN fc_tac[th]));
(* *** Goal "1.1.5.1" *** *)
a(GET_ASM_T¨Snd x = vÆ rewrite_thm_tac);
a(DROP_NTH_ASM_T 8 ante_tac THEN PC_T"hol1" (REPEAT strip_tac));
a(spec_nth_asm_tac 1 ¨Fst xÆ);
(* *** Goal "1.1.5.2" *** *)
a(TOP_ASM_T ante_tac THEN rewrite_tac[]);
(* *** Goal "1.1.6" *** *)
a(lemma_tac¨x ç {(v, w)|v ç S ± w ç S} \ Id SÆ);
(* *** Goal "1.1.6.1" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[id_def] THEN REPEAT strip_tac);
(* *** Goal "1.1.6.2" *** *)
a(spec_nth_asm_tac 5 ¨xÆ);
(* That completes the proof that S' is a clique. Now want #S' = i + 1 *)
(* *** Goal "1.2" *** *)
a(lemma_tac ¨S Ä VÆ);
(* *** Goal "1.2.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN PC_T"hol1" (REPEAT strip_tac));
a(PC_T "hol1"(spec_nth_asm_tac 2 ¨xÆ));
(* *** Goal "1.2.2" *** *)
a(fc_tac[size_thm4]);
a(asm_fc_tac[]);
a(fc_tac[size_thm5]);
a(POP_ASM_T (strip_asm_tac o µ_elim¨vÆ));
a(asm_rewrite_tac[]);
a(LEMMA_T¨≥v ç SÆ rewrite_thm_tac);
a(DROP_NTH_ASM_T 8 ante_tac THEN PC_T"hol1" (REPEAT strip_tac));
a(POP_ASM_T (strip_asm_tac o µ_elim¨vÆ));
(* That does the case where S was a clique. Now do the case when S is independent *)
(* *** Goal "2" *** *)
a(∂_tac ¨SÆ THEN ≤_right_tac THEN strip_tac);
(* Two subgoals. First that S is independent: *)
(* *** Goal "2.1" *** *)
a(bc_tac[lemma1b]);
a(∂_tac ¨{x|x ç V \ {v} ± (v, x) ç E}Æ);
a strip_tac;
(* *** Goal "2.1.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN PC_T"hol1" (REPEAT strip_tac));
a(bc_tac[lemma1c] THEN strip_tac);
(* That does that S is independent. Now Size s = j *)
(* *** Goal "2.2" *** *)
a(strip_tac);
val lemma4 = save_pop_thm"lemma4";

=TEX
The second of the pair of lemmas to justify the constructions
used in the inductive step is the part which is described
as ``analogous'' in the informal proof in \cite{Basin90}
=SML
set_goal([],¨
	µ (V:'a ,E); v; S; i j∑
	let R = {x | x ç V \ {v} ± ≥(v, x) ç E}
	in
		(V, E) ç symg
	±	V ç Finite
	±	v ç V
	±	S Ä R
	±	(S clique_of (V, (R ∏ R) ° E) ± #S = i
		≤ S indep_of (V, (R ∏ R) ° E) ± #S = j)
	¥	∂S'∑
		S' clique_of (V, E) ± #S' = i
		≤ S' indep_of (V, E) ± #S' = j+1
Æ);
a(rewrite_tac[let_def] THEN REPEAT strip_tac);
(* Two subgoals. The one in which S is a clique comes first: *)
(* *** Goal "1" *** *)
a(∂_tac ¨SÆ THEN ≤_left_tac THEN strip_tac);
(* Two subgoals. First that S' is a clique *)
(* *** Goal "1.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac
	THEN rewrite_tac[clique_of_def, ∏_def, ™_def]
	THEN PC_T"hol1" (REPEAT strip_tac));
(* *** Goal "1.1.1" *** *)
a(DROP_NTH_ASM_T 5 ante_tac THEN (PC_T "hol1" (REPEAT strip_tac)));
a(asm_fc_tac[]);
(* *** Goal "1.1.2" *** *)
a(spec_nth_asm_tac 4 ¨xÆ);
(* *** Goal "1.2" *** *)
a(strip_tac);
(* That does the case where S was a clique. Now do the case when S is independent *)
(* *** Goal "2" *** *)
a(∂_tac ¨{v} ¿ SÆ THEN ≤_right_tac THEN strip_tac);
(* Two subgoals. First that S' is independent: *)
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac
	THEN rewrite_tac[indep_of_def, ∏_def, ™_def]
	THEN PC_T"hol1" (REPEAT strip_tac));
(* 3 subgoals. *)
(* *** Goal "2.1.1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a(DROP_NTH_ASM_T 5 ante_tac THEN (PC_T "hol1" (REPEAT strip_tac)));
a(spec_nth_asm_tac 4 ¨xÆ);
(* *** Goal "2.1.3" *** *)
a(rewrite_tac[id_def] THEN REPEAT strip_tac);
a(asm_rewrite_tac[]);
(* *** Goal "2.1.4" *** *)
a(DROP_NTH_ASM_T 7 ante_tac THEN (PC_T "hol1" (REPEAT strip_tac)));
a(spec_nth_asm_tac 1 ¨Snd xÆ);
a(swap_asm_concl_tac ¨≥ (v, Snd x) ç EÆ);
a(GET_NTH_ASM_T 7 (rewrite_thm_tac o eq_sym_rule) THEN strip_tac);
(* *** Goal "2.1.5" *** *)
a(GET_NTH_ASM_T 10(strip_asm_tac o rewrite_rule[symg_def]));
a(POP_ASM_T (fn th => strip_asm_tac(rewrite_rule[pair_clauses](list_µ_elim[¨Fst xÆ, ¨Snd xÆ]th))));
a(swap_asm_concl_tac ¨(Snd x, Fst x) ç EÆ THEN asm_rewrite_tac[]);
a(DROP_NTH_ASM_T 9 ante_tac THEN (PC_T "hol1" (REPEAT strip_tac)));
a(spec_nth_asm_tac 1 ¨Fst xÆ);
(* *** Goal "2.1.6" *** *)
a(DROP_NTH_ASM_T 4 ante_tac THEN
	rewrite_tac[id_def] THEN PC_T"hol1" (REPEAT strip_tac));
a(DROP_NTH_ASM_T 7 ante_tac THEN (PC_T "hol1" (REPEAT strip_tac)));
a(asm_fc_tac[]);
(* That shows that S' is independent. Now need #S' = j + 1 *)
(* *** Goal "2.2" *** *)
a(lemma_tac ¨S Ä VÆ);
(* *** Goal "2.2.1" *** *)
a(DROP_NTH_ASM_T 3 ante_tac THEN PC_T"hol1" (REPEAT strip_tac));
a(PC_T "hol1"(spec_nth_asm_tac 2 ¨xÆ));
(* *** Goal "2.2.2" *** *)
a(fc_tac[size_thm4]);
a(asm_fc_tac[]);
a(fc_tac[size_thm5]);
a(POP_ASM_T (strip_asm_tac o µ_elim¨vÆ));
a(asm_rewrite_tac[]);
a(LEMMA_T¨≥v ç SÆ rewrite_thm_tac);
a(DROP_NTH_ASM_T 8 ante_tac THEN PC_T"hol1" (REPEAT strip_tac));
a(POP_ASM_T (strip_asm_tac o µ_elim¨vÆ));
val lemma5 = save_pop_thm"lemma5";
=TEX
=SML
set_goal([], ¨µa b c; x; m n∑
	a ç Finite
±	#a æ m + n
±	a = {x} ¿ b ¿ c
¥	#b æ m ≤ #c æ n
Æ);
a(rewrite_tac[pc_rule"hol1"(prove_rule[])¨{x} ¿ b ¿ c = ({x} ¿ b) ¿ cÆ]);
a(REPEAT strip_tac);
a(lemma_tac¨b Ä a ± ({x} ¿ b) Ä a ± c Ä aÆ);
(* *** Goal "1" *** *)
a(GET_ASM_T¨a = ({x} ¿ b) ¿ cÆ ante_tac THEN (PC_T"hol1" (REPEAT strip_tac THEN asm_prove_tac[])));
(* *** Goal "2" *** *)
a(lemma_tac¨#a + #(({x} ¿ b) ° c) = #({x} ¿ b) + #cÆ);
(* *** Goal "2.1" *** *)
a(fc_tac[size_thm4] THEN asm_fc_tac[]);
a(DROP_ASM_T ¨a = ({x} ¿ b) ¿ cÆ rewrite_thm_tac);
a(bc_tac[size_thm7] THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(swap_asm_concl_tac¨#a + #(({x} ¿ b) ° c) = #({x} ¿ b) + #cÆ);
a(DROP_ASM_T ¨m + n º #aÆ (strip_asm_tac o rewrite_rule[º_def]));
a(DROP_ASM_T ¨(m + n) + i = #aÆ (rewrite_thm_tac o eq_sym_rule));
a(LIST_GET_NTH_ASM_T[1,5] (MAP_EVERY (strip_asm_tac o rewrite_rule[≥_º_thm])));
a(lemma_tac¨#({x} ¿ b) º mÆ);
(* *** Goal "2.2.1" *** *)
a(fc_tac[size_thm4] THEN asm_fc_tac[] THEN asm_fc_tac[size_thm5]);
a(DROP_NTH_ASM_T 3 (rewrite_thm_tac o rewrite_rule[] o µ_elim¨xÆ));
a(DROP_NTH_ASM_T 8 ante_tac);
a(rewrite_tac[less_def, º_def] THEN REPEAT strip_tac);
a(CASES_T¨x ç bÆ (fn th => rewrite_tac[th] THEN asm_tac th));
(* *** Goal "2.2.1.1" *** *)
a(∂_tac ¨1+iÆ THEN DROP_NTH_ASM_T 2 (rewrite_thm_tac o rewrite_rule[plus_assoc_thm]));
(* *** Goal "2.2.1.2" *** *)
a(∂_tac ¨iÆ THEN DROP_NTH_ASM_T 2 rewrite_thm_tac);
(* *** Goal "2.2.2" *** *)
a(LIST_GET_NTH_ASM_T[1,2,3](MAP_EVERY (strip_asm_tac o rewrite_rule[less_def, º_def])));
a(LIST_GET_NTH_ASM_T[1,3] (rewrite_tac o map eq_sym_rule));
a(rewrite_tac[µ_elim¨#({x} ¿ b)Æplus_order_thm]);
a(rewrite_tac[µ_elim¨#cÆplus_order_thm]);
val lemma6 = save_pop_thm"lemma6";
=TEX
The inductive step may be derived from the following theorem:
=SML
set_goal([],¨
	µ a b m n∑
	0 < m
±	0 < n
±	(µ (V:'a ,E) ∑
	(V,E) ç symg ± V ç Finite ± #V æ m ¥
		(∂ C ∑ C clique_of (V,E) ± #C = a
		≤ C indep_of (V,E) ± #C = b+1))
±	(µ (V:'a ,E) ∑
	(V,E) ç symg ± V ç Finite ± #V æ n ¥
		(∂ C ∑ C clique_of (V,E) ± #C = a+1
		≤ C indep_of (V,E) ± #C = b))
¥	(µ (V:'a ,E) ∑
	(V,E) ç symg ± V ç Finite ± #V æ m + n ¥
		(∂ C ∑ C clique_of (V,E) ± #C = a+1
		≤ C indep_of (V,E) ± #C = b+1))
Æ);
a(REPEAT(strip_tac));
(* First want to prove ≥ V = {} *)
a(FC_T1 id_canon
	(fn ths =>LEMMA_T ¨≥ #V = 0Æ (strip_asm_tac o rewrite_rule ths))[lemma3]);
(* *** Goal "1" *** *)
a(MAP_EVERY (fn t => DROP_ASM_T t
		(strip_asm_tac o rewrite_rule[less_def, º_def]))
	[¨m + n º # VÆ, ¨0 < nÆ]);
a(DROP_ASM_T ¨(m + n) + i = #VÆ (rewrite_thm_tac o eq_sym_rule));
a(DROP_ASM_T¨1 + i' = nÆ(rewrite_thm_tac o eq_sym_rule));
(* Completes proof of ≥ V = {} *)
(* *** Goal "2" *** *)
(* Now use ≥ V = {} to give an element of V *)
a(PC_T "hol1" (POP_ASM_T strip_asm_tac));
(* Gives us x ç V; Easier to read with v ç V: *)
a(rename_tac[(¨xÆ, "v")]);
a(lemma_tac
¨V = {v} ¿ {x | x ç V \ {v} ± (v, x) ç E} ¿ {x | x ç V \ {v} ± ≥(v, x) ç E}Æ);
(* *** Goal "2.1" *** *)
a(PC_T "hol1" (REPEAT strip_tac) THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(lemma_tac
¨#{x | x ç V \ {v} ± (v, x) ç E} æ m ≤ #{x | x ç V \ {v} ± ≥(v, x) ç E} æ nÆ);
(* *** Goal "2.2.1" *** *)
a(bc_tac[lemma6]);
a(∂_tac ¨vÆ THEN ∂_tac¨VÆ THEN REPEAT strip_tac);
(* *** Goal "2.2.2" *** *)
a(lemma_tac¨{x|x ç V \ {v} ± (v, x) ç E} ç FiniteÆ);
(* *** Goal "2.2.2.1" *** *)
a(bc_tac[size_thm4] THEN ∂_tac¨VÆ THEN PC_T "hol1" (REPEAT strip_tac));
(* *** Goal "2.2.2.2" *** *)
a(lemma_tac¨
({x|x ç V \ {v} ± (v, x) ç E},
 ({x|x ç V \ {v} ± (v, x) ç E} ∏ {x|x ç V \ {v} ± (v, x) ç E}) ° E) ç symgÆ);
(* *** Goal "2.2.2.2.1" *** *)
a(bc_tac[lemma1] THEN PC_T "hol1" (REPEAT strip_tac));
(* *** Goal "2.2.2.2.2" *** *)
a(list_spec_nth_asm_tac 10 [
	¨{x|x ç V \ {v} ± (v, x) ç E}Æ,
	¨({x|x ç V \ {v} ± (v, x) ç E} ∏ {x|x ç V \ {v} ± (v, x) ç E}) ° EÆ]);
(* *** Goal "2.2.2.2.2.1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[æ_def]));
(* *** Goal "2.2.2.2.2.2" *** *)
a(bc_tac[rewrite_rule[let_def] lemma4]);
a(∂_tac¨CÆ THEN ∂_tac ¨vÆ THEN PC_T "hol1" (REPEAT strip_tac));
(* *** Goal "2.2.2.2.2.2.1" *** *)
a(GET_NTH_ASM_T 3 (PC_T1"hol1"(strip_asm_tac o rewrite_rule[clique_of_def])));
a(spec_nth_asm_tac 2 ¨xÆ);
(* *** Goal "2.2.2.2.2.2.2" *** *)
a(GET_NTH_ASM_T 3 (PC_T1"hol1"(strip_asm_tac o rewrite_rule[clique_of_def])));
a(spec_nth_asm_tac 2 ¨xÆ);
(* *** Goal "2.2.2.2.2.2.3" *** *)
a(GET_NTH_ASM_T 3 (PC_T1"hol1"(strip_asm_tac o rewrite_rule[clique_of_def])));
a(spec_nth_asm_tac 2 ¨xÆ);
(* *** Goal "2.2.2.2.2.2.4" *** *)
a(swap_nth_asm_concl_tac 1 THEN bc_tac [lemma1d]);
a(∂_tac¨{x|x ç V \ {v} ± (v, x) ç E}Æ THEN REPEAT strip_tac);
a(PC_T"hol1" (REPEAT strip_tac));
(* *** Goal "2.2.2.2.2.2.4" *** *)
a(swap_nth_asm_concl_tac 1 THEN bc_tac [lemma1d]);
a(∂_tac¨{x|x ç V \ {v} ± (v, x) ç E}Æ THEN REPEAT strip_tac);
a(PC_T"hol1" (REPEAT strip_tac));
(* *** Goal "2.2.2.2.2.3" *** *)
(* This is the easy second quarter of the main construction *)
a(∂_tac¨CÆ THEN ≤_right_tac THEN REPEAT strip_tac);
a(bc_tac[lemma1b]);
a(∂_tac¨{x|x ç V \ {v} ± (v, x) ç E}Æ THEN REPEAT strip_tac);
a(PC_T"hol1" (REPEAT strip_tac));
(* Completes the second quarter *)
a(lemma_tac¨{x|x ç V \ {v} ± ≥(v, x) ç E} ç FiniteÆ);
(* *** Goal "2.2.3.1" *** *)
a(bc_tac[size_thm4] THEN ∂_tac¨VÆ THEN PC_T "hol1" (REPEAT strip_tac));
(* *** Goal "2.2.3.2" *** *)
a(lemma_tac¨
({x|x ç V \ {v} ± ≥(v, x) ç E},
 ({x|x ç V \ {v} ± ≥(v, x) ç E} ∏ {x|x ç V \ {v} ± ≥(v, x) ç E}) ° E) ç symgÆ);
(* *** Goal "2.2.3.2.1" *** *)
a(bc_tac[lemma1] THEN PC_T "hol1" (REPEAT strip_tac));
(* *** Goal "2.2.3.2.2" *** *)
a(list_spec_nth_asm_tac 9 [
	¨{x|x ç V \ {v} ± ≥(v, x) ç E}Æ,
	¨({x|x ç V \ {v} ± ≥(v, x) ç E} ∏ {x|x ç V \ {v} ± ≥(v, x) ç E}) ° EÆ]);
(* *** Goal "2.2.3.2.2.1" *** *)
a(POP_ASM_T (strip_asm_tac o rewrite_rule[æ_def]));
(* *** Goal "2.2.3.2.2.2.2" *** *)
(* Now the easy third quarter: *)
a(∂_tac¨CÆ THEN ≤_left_tac THEN REPEAT strip_tac);
a(bc_tac[lemma1a]);
a(∂_tac¨{x|x ç V \ {v} ± ≥(v, x) ç E}Æ THEN REPEAT strip_tac);
a(PC_T"hol1" (REPEAT strip_tac));
(* Now the final hard quarter: *)
(* *** Goal "2.2.3.2.2.3" *** *)
a(bc_tac[rewrite_rule[let_def] lemma5]);
a(∂_tac¨CÆ THEN ∂_tac ¨vÆ THEN PC_T "hol1" (REPEAT strip_tac));
(* *** Goal "2.2.3.2.2.3.1" *** *)
a(GET_NTH_ASM_T 3 (PC_T1"hol1"(strip_asm_tac o rewrite_rule[indep_of_def])));
a(spec_nth_asm_tac 2 ¨xÆ);
(* *** Goal "2.2.3.2.2.3.2" *** *)
a(GET_NTH_ASM_T 3 (PC_T1"hol1"(strip_asm_tac o rewrite_rule[indep_of_def])));
a(spec_nth_asm_tac 2 ¨xÆ);
(* *** Goal "2.2.3.2.2.3.3" *** *)
a(GET_NTH_ASM_T 3 (PC_T1"hol1"(strip_asm_tac o rewrite_rule[indep_of_def])));
a(spec_nth_asm_tac 2 ¨xÆ);
(* *** Goal "2.2.3.2.2.3.4" *** *)
a(bc_tac [lemma1e]);
a(∂_tac¨{x|x ç V \ {v} ± ≥(v, x) ç E}Æ THEN PC_T"hol1" (REPEAT strip_tac));
(* *** Goal "2.2.3.2.2.3.5" *** *)
a(bc_tac [lemma1e]);
a(∂_tac¨{x|x ç V \ {v} ± ≥(v, x) ç E}Æ THEN PC_T"hol1" (REPEAT strip_tac));
val lemma7 = save_pop_thm"lemma7";
=TEX
The base case may be derived from the following theorems:
=SML
set_goal([],¨
	µ (V, E)∑
		{} clique_of (V, E)
	±	{} indep_of (V, E)
Æ);
a(rewrite_tac[clique_of_def, indep_of_def, ∏_def, ™_def, id_def]
	THEN PC_T"hol1" (REPEAT strip_tac));
val lemma8  = save_pop_thm"lemma8";

=TEX
=SML
set_goal([],¨
	µ (V, E); x∑
		x ç V
	¥	{x} clique_of (V, E)
	±	{x} indep_of (V, E)
Æ);
a(rewrite_tac[clique_of_def, indep_of_def, ∏_def, ™_def, id_def]
	THEN PC_T"hol1" (REPEAT strip_tac) THEN_TRY asm_rewrite_tac[]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
val lemma9  = save_pop_thm"lemma9";
=TEX
=SML
set_goal([],¨
	µ a b ∑ ∂n ∑
	µ (V:'a ,E) ∑
	(V,E) ç symg ± V ç Finite ± #V æ n ¥
		(∂ C ∑ C clique_of (V,E) ± #C = a
		≤ C indep_of (V,E) ± #C = b)
Æ);
a(REPEAT µ_tac);
(* Prefer for induction on an upper bound for a + b: *)
a(lemma_tac¨∂m∑a + b º mÆ
	THEN_LIST[∂_tac¨a + bÆ THEN rewrite_tac[], POP_ASM_T ante_tac]);
a(intro_µ_tac(¨bÆ, ¨bÆ) THEN intro_µ_tac(¨aÆ, ¨aÆ));
a(INDUCTION_T ¨mÆ strip_asm_tac);
(* Base case: *)
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(∂_tac¨0Æ THEN REPEAT strip_tac);
a(∂_tac¨{}Æ THEN REPEAT strip_tac THEN 
	fc_tac[lemma3] THEN asm_rewrite_tac[lemma8, size_thm1]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN fc_tac[º_plus1_thm]);
(* 2 subgoals. One is trivial; the hard one comes first: *)
(* *** Goal "2.1.1" *** *)
(* Case analysis ( a > 0 / b > 0 ): *)
a(strip_asm_tac (µ_elim¨aÆ Ó_cases_thm) THEN
	strip_asm_tac (µ_elim¨bÆ Ó_cases_thm));
(* 4 cases *)
(* *** Goal "2.1.1" *** *)
a(∂_tac¨0Æ THEN REPEAT strip_tac);
a(∂_tac¨{}Æ THEN REPEAT strip_tac THEN 
	fc_tac[lemma3] THEN asm_rewrite_tac[lemma8, size_thm1]);
(* *** Goal "2.1.2" *** *)
a(∂_tac¨0Æ THEN REPEAT strip_tac);
a(∂_tac¨{}Æ THEN asm_rewrite_tac[lemma8, size_thm1]);
(* *** Goal "2.1.3" *** *)
a(∂_tac¨0Æ THEN REPEAT strip_tac);
a(∂_tac¨{}Æ THEN asm_rewrite_tac[lemma8, size_thm1]);
(* *** Goal "2.1.4" *** *)
a(lemma_tac¨(i+1) + i' º m ± i + (i'+1) º mÆ);
(* *** Goal "2.1.4.1" *** *)
a(strip_tac);
(* *** Goal "2.1.4.1.1" *** *)
a(GET_ASM_T¨a = i + 1Æ(rewrite_thm_tac o eq_sym_rule));
a(GET_ASM_T ¨a + b = m + 1Æ ante_tac THEN GET_ASM_T ¨b = i' + 1Ærewrite_thm_tac);
a(rewrite_tac[µ_elim¨1Æplus_order_thm]);
a(¥_T rewrite_thm_tac);
(* *** Goal "2.1.4.1.2" *** *)
a(GET_ASM_T¨b = i' + 1Æ(rewrite_thm_tac o eq_sym_rule));
a(GET_ASM_T ¨a + b = m + 1Æ ante_tac THEN GET_ASM_T ¨a = i + 1Ærewrite_thm_tac);
a(rewrite_tac[µ_elim¨1Æplus_order_thm]);
a(¥_T rewrite_thm_tac);
(* *** Goal "2.1.4.2" *** *)
a(list_spec_nth_asm_tac 7[¨i+1Æ, ¨i'Æ]);
a(DROP_NTH_ASM_T 8 (strip_asm_tac o list_µ_elim[¨iÆ, ¨i'+1Æ]));
(* Now introduce the witness: *)
a(∂_tac¨(if 0 < n' then n' else 1) + (if 0 < n then n else 1) Æ);
a(LIST_GET_NTH_ASM_T [5,6] rewrite_tac THEN bc_tac [rewrite_rule[]lemma7]);
(* 4 subgoals: *)
(* *** Goal "2.1.4.2.1" *** *)
a(CASES_T¨0 < n'Æ rewrite_thm_tac);
(* *** Goal "2.1.4.2.2" *** *)
a(CASES_T¨0 < nÆ rewrite_thm_tac);
(* *** Goal "2.1.4.2.3" *** *)
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 bc_thm_tac);
a(rewrite_tac [] THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN cases_tac¨0 < n'Æ THEN1 asm_rewrite_tac[]);
a(TOP_ASM_T rewrite_thm_tac THEN TOP_ASM_T ante_tac);
a(rewrite_tac[≥_less_thm]);
a(¥_T rewrite_thm_tac);
(* *** Goal "2.1.4.2.4" *** *)
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 5 bc_thm_tac);
a(rewrite_tac [] THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN cases_tac¨0 < nÆ THEN1 asm_rewrite_tac[]);
a(TOP_ASM_T rewrite_thm_tac THEN TOP_ASM_T ante_tac);
a(rewrite_tac[≥_less_thm]);
a(¥_T rewrite_thm_tac);
(* That does the hard bit *)
(* *** Goal "2.2" *** *)
a(asm_fc_tac[]);
a(∂_tac ¨nÆ THEN REPEAT µ_tac THEN TOP_ASM_T rewrite_thm_tac);
val fin_exp_2_ramsey_thm = save_pop_thm"fin_exp_2_ramsey_thm";
=TEX
%\bibliographystyle{fmu}
%\bibliography{fmu}
\section*{Index of Formal Names}
%\newbox\COLC
%\newbox\COLB
%\newbox\COLA
%\setbox\COLC=\vbox{{\footnotesize\printindex}}
%\newdimen\H
%\H=\ht\COLC
%\divide\H by 3\advance\H by\ht\strutbox
%\splittopskip=\ht\strutbox\vbadness=10000
%\setbox\COLA=\vsplit\COLC to \H
%\setbox\COLB=\vsplit\COLC to \H
%\valign{#\vfil\cr\box\COLA\cr\noalign{\hfill}\box\COLB\cr
%  \noalign{\hfill}\box\COLC\cr}
\printindex
\end{document}




