=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation for the Theory of Pairs}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP037}  %% Mandatory field
\def\SCCSversion{$Date$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{The theory of pairs for ICL HOL is implemented.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.2 (21st August 1991)] 
First draft.
\item [Issue 1.3 (21st September 1991)]
Added some theorems, and structure wrapping.
\item [Issue 1.4 (2nd October 1991)]
Tidying up.
\item [Issue 1.5 (17th October 1991)]
Gained $fun\_rel\_thm$ from \cite{DS/FMU/IED/IMP038}.

\item[Issue 1.6, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.7 (23rd January 1992)]
$new\_axiom$, $simple\_new\_type\_defn$, $new\_type\_defn$
all changed to take lists of keys, rather than single ones.
\item [Issue 1.8 (27th January 1992)]
Fixed a typo.
\item [Issue 1.9 (18th March 1992)]
Using $simple\_taut\_tac$ rather than $taut\_tac$.
\item [Issue 1.10 (13th April 1992)]
Changes due to CR0017.
\item [Issue 1.12 (26th May 1992)]
Renamings from version 1.5 of DS/FMU/IED/WRK038.
\item[Issue 1.13 (24th June 1992)]
Renamings from issue 1.6 of \cite{DS/FMU/IED/WRK038},
mostly proof context name changes.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the theory of pairs.
This is called for in \cite{DS/FMU/IED/HLD011}.
The design is in \cite{DS/FMU/IED/DTD037}.

\subsection{Deficiences}
None known.
\subsection{Introduction}
\section{ABSTRACTION AND REPRESENTATION FUNCTIONS}
When we use $new\_type\_definition$ a new definitional
axiom is introduced of the following form. 
=GFT
ô (¶ f.TYPE_DEFINITION Pred f)
=TEX
Here $Pred$ is the predicate which defines a subset of
existing type which is equinumerous with the new type.
The axiom asserts the existence of a 1-1 correspondence
between the new type and that subset.
To put the axiom to work it is usually convenient
to use explicit abstraction and representation functions
to enable facts about the predicate to be interpreted as
facts about the new type.

In this section we supply a theorem supporting a utility which, given a theorem
of the above form, automatically defines abstraction
and representation functions as constants with appropriate
properties. In the Cambridge HOL system these properties
comprised a list of half a dozen or more facts. We
prefer to work with rather less.


Our first objective is to prove the following theorem.
We can then instantiate this to match a given new type axiom
and so derive a theorem which can be used as an argument
to $new\_spec$ to define abstraction and
representation functions, say $abs$ and $rep$ with the
relevant properties, viz. that $abs$ is a left inverse
of $rep$, and that $rep$ is a left inverse of the
restriction of $abs$ to the subset determined by $Pred$.
Note that these properties imply that $abs$ is onto and
that $rep$ is one-to-one.
=GFT
ô µ Pred.(¶ f.TYPE_DEFINITION Pred f) ´
	(¶ abs rep·
		(µ a.abs (rep a) = a) ±
		 (µ r·Pred r = (rep (abs r) = r)))
=TEX
=TEX
To prove the above theorem it is convenient first to
prove the following triviality:
=GFT
ô µf:'a­'b; x y·(f x = f y ´ x = y) ¤ (f x = f y ¤ x = y)
=TEX
The following structure adds material to theory ``misc''
and creates a new theory ``pair''.
=SML
structure ÛPairTheoryÝ : PairTheory = struct
=TEX
Before we prove this we make sure we are in the right
theory.
=SML
val _ = open_theory "misc";
val _ = push_merge_pcs ["'propositions",
	"'simple_abstractions"];
=TEX
=SML
val Ûone_one_thmÝ = save_thm("one_one_thm",(
push_goal([], ¬µf:'a­'b·OneOne f ¤ µx y·(f x = f y ¤ x = y)®);
a(lemma_tac ¬µf:'a­'b; x y·(f x = f y ´ x = y) ¤ (f x = f y ¤ x = y)®);
a(REPEAT strip_tac THEN POP_ASM_T rewrite_thm_tac);
a(asm_rewrite_tac[one_one_def]);
pop_thm()));
=TEX
=SML
val Ûext_thmÝ = save_thm("ext_thm",(
push_goal([], ¬µf g:'a­'b·f = g ¤ (µx · f x = g x)®);
a(REPEAT strip_tac THEN TRY_T (asm_rewrite_tac[]));
a(once_rewrite_tac(map eq_sym_rule[simple_µ_elim ¬f:'a­'b® È_axiom,
				simple_µ_elim ¬g:'a­'b® È_axiom]));
a(asm_rewrite_tac[]);
pop_thm()));
=TEX
Our main theorem in this section may now be proved.
=SML
val Ûtype_lemmas_thmÝ = save_thm ("type_lemmas_thm", (
push_goal([], ¬
	µpred · (¶f:'a­'b·TypeDefn pred f) ´
	¶abs:'b­'a·¶rep:'a­'b·(µa·abs(rep a) = a) ±
		 µr·pred r ¤ rep(abs r) = r®);
(* Expand some definitions and split goal up: *)
	a (rewrite_tac[type_defn_def, one_one_thm, onto_def] THEN REPEAT strip_tac);
(* Give witnesses for abstraction and representation functions: *)
	a(simple_¶_tac(¬Ìy:'b·Åx:'a· y = f x®) THEN simple_¶_tac (¬f:'a­'b®));
(* Split it up some more *)
	a(rewrite_tac[] THEN REPEAT strip_tac);
(* We get three subgoals. 1: *)
	a(asm_rewrite_tac[]);
	a(LEMMA_T ¬¶x·a = x® (accept_tac o eq_sym_rule o simple_¶_Å_rule));
(* The lemma proves the goal, so only one subgoal *)
	a(simple_¶_tac¬a:'a® THEN rewrite_tac[]);
(* That completes 1. 2: *)
	a(GET_NTH_ASM_T 1 (asm_ante_tac o concl) THEN asm_rewrite_tac[]);
	a(´_T (accept_tac o eq_sym_rule o simple_¶_Å_rule));
(* That completes 2. 3: *)
	a(asm_rewrite_tac[] THEN REPEAT strip_tac);
(* Only one subgoal *)
	a(simple_¶_tac(¬Å x·r = (f:'a­'b) x®));
	a(asm_rewrite_tac[]);
pop_thm()));
=TEX
\subsection{On Functional Relations}
A set-theoretic proof relies on the identification of functions with
single valued relations in set theory. To adapt it to HOL we need
a theorem to justify this line of argument.
The following theorem does just that by allowing
us to rewrite problems about function
existence in terms of two-place relations and so facilitates the use
of standard set-theoretic means of constructing functions.
=SML
val Ûfun_rel_thmÝ = save_thm("fun_rel_thm",(
push_goal([], ¬µr:'a­'b­BOOL·
	(¶f·µx y·f x = y ¤ r x y) ¤ (µx·¶y·r x y ± µz·r x z ´ z = y)
®);
=TEX
=SML
a(REPEAT strip_tac);
(* 2 subgoals 1: *)
a(simple_¶_tac¬(f:'a­'b)x®);
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN
	LEMMA_T ¬r x ((f:'a­'b)x):BOOL® (fn th => asm_rewrite_tac[th]));
(* Above leaves only the lemma to do: *)
a(POP_ASM_T (rewrite_thm_tac o conv_rule (ONCE_MAP_C eq_sym_conv)));
(* Completes 1. 2: *)
a(simple_¶_tac ¬Ìx:'a·Åy:'b·r x y® THEN conv_tac all_simple_%beta%_conv);
a(REPEAT strip_tac);
(* 2 subgoals: 2.1: *)
a(LEMMA_T ¬¶y:'b·r (x:'a)y® (ante_tac o simple_¶_Å_rule)
	THEN GET_NTH_ASM_T 2 (strip_asm_tac o simple_µ_elim¬x:'a®));
(* 2 subgoals. 2.1.1: *)
a(simple_¶_tac¬y':'b® THEN asm_rewrite_tac[]);
(* Completes 2.1.1. 2.1.2: *)
a(asm_rewrite_tac[]);
(* Completes 2.1. 2.2: *)
a(LEMMA_T ¬¶y':'b·r (x:'a)y'® (asm_tac o simple_¶_Å_rule));
(* 2 subgoals. 2.2.1: *)
a(simple_¶_tac¬y:'b® THEN asm_rewrite_tac[]);
(* Completes 2.2.1. 2.2.2: *)
a(GET_NTH_ASM_T 3 (strip_asm_tac o simple_µ_elim¬x:'a®));
a(TOP_ASM_T (strip_asm_tac o simple_µ_elim¬Åy:'b· r (x:'a) y®));
a(GET_NTH_ASM_T 2 (strip_asm_tac o simple_µ_elim¬y:'b®));
a(asm_rewrite_tac[]);
=TEX
=SML
pop_thm()
));
=TEX
\section{THE THEORY $PAIR$}
We can now use the functions of the earlier sections
to help use define the theory of pairs.

The basic idea is to represent the product type $A ¸ B$
as the singleton subsets in the power set $(A ¸ B) ­ bool$,
which we can represent as $A ­ B ­ bool$.
=SML
val _ = new_theory "pair";
val _ = declare_infix(200, "comma");
=TEX
=SML
val Ûis_pair_rep_defÝ = new_spec(["ÛIsPairRepÝ","is_pair_rep_def"], 1, (
push_goal([], ¬
¶IsPairRep:('a ­ 'b ­ BOOL) ­ BOOL·
	¶ ($comma):'a ­ 'b ­ ('a ­ 'b ­ BOOL); fst; snd·
		(µx y·	IsPairRep (x comma y)
		 ±	fst(x comma y) = x
		 ±	snd(x comma y) = y)
	±	(µx y a b· (a comma b) = (x comma y) ¤ a = x ± b = y)
	±	(µp· IsPairRep p ´ (fst p comma snd p) = p)
®);
a (simple_¶_tac ¬Ìp:'a­'b­BOOL · ¶a b · µx y · p x y ¤ x = a ± y = b®);
a (simple_¶_tac ¬Ìa:'a; b:'b · Ìx y · x = a ± y = b®);
a (simple_¶_tac ¬Ìp:'a­'b­BOOL · Åx · ¶ y · p x y®);
a (simple_¶_tac ¬Ìp:'a­'b­BOOL · Åy · ¶ x · p x y®);
a (conv_tac (all_simple_%beta%_conv) THEN REPEAT strip_tac);
(* 7 subgoals: 1: *)
a (simple_¶_tac ¬x:'a® THEN simple_¶_tac ¬y:'b® THEN rewrite_tac[]);
(* 2: *)
a(LEMMA_T ¬¶x':'a; y':'b · x' = x ± y' = y® (strip_asm_tac o simple_¶_Å_rule));
a (simple_¶_tac ¬x:'a® THEN simple_¶_tac ¬y:'b® THEN rewrite_tac[]);
(* 3 is very similar to 2: *)
a(LEMMA_T ¬¶y':'b; x':'a · x' = x ± y' = y® (strip_asm_tac o simple_¶_Å_rule));
a (simple_¶_tac ¬y:'b® THEN simple_¶_tac ¬x:'a® THEN rewrite_tac[]);
(* 4: *)
a (conv_tac eq_sym_conv);
a (POP_ASM_T (strip_asm_tac o rewrite_rule[] o all_simple_%beta%_rule o
		app_arg_rule ¬y:'b® o app_arg_rule ¬x:'a®));
(* 5 is very similar to 4: *)
a(conv_tac eq_sym_conv);
a (POP_ASM_T (strip_asm_tac o rewrite_rule[] o all_simple_%beta%_rule o
		app_arg_rule ¬y:'b® o app_arg_rule ¬x:'a®));
(* 6: *)
a (DROP_ASMS_T (rewrite_tac o map eq_sym_rule));
(* 7: *)
a (asm_rewrite_tac[ext_thm]);
a(LEMMA_T ¬¶x':'a; y':'b · x' = a ± y' = b®
			(STRIP_THM_THEN rewrite_thm_tac o simple_¶_Å_rule));
(* Two subgoals. 7/1: *)
a (simple_¶_tac ¬a:'a® THEN simple_¶_tac ¬b:'b® THEN rewrite_tac[]);
(* 7/2: *)
a(LEMMA_T ¬¶y':'b;  x':'a· x' = a ± y' = b®
			(STRIP_THM_THEN rewrite_thm_tac o simple_¶_Å_rule));
(* The rewriting proves the goal, leaving only the lemma: *)
a (simple_¶_tac ¬b:'b® THEN simple_¶_tac ¬a:'a® THEN rewrite_tac[]);
pop_thm()));
=TEX
We can now declare the type of pairs:
=SML
val _ = declare_infix(150, "¸");
val _ = declare_terminator"¸";
=TEX
=SML
val Û¸_defÝ = new_type_defn(["¸", "¸_def"], "¸", ["'a", "'b"], (
push_goal([], ¬¶p:('a ­ 'b ­ BOOL)· IsPairRep p®);
a(strip_asm_tac is_pair_rep_def);
a(simple_¶_tac ¬(a:'a comma b:'b):'a ­ 'b ­ BOOL® THEN asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val _ = declare_infix(150, ",");
=TEX
$new\_spec$ may now be used to introduce the basic operations
on pairs:
=SML
val Ûpair_ops_defÝ = new_spec([",", "Fst", "Snd", "pair_ops_def"], 3, (
push_goal([], ¬
	¶ ($,):'a ­ 'b ­ ('a ¸ 'b); Fst; Snd ·
		(µx y · Fst(x, y) = x ± Snd(x, y) = y)
	±	(µx y a b · (a, b) = (x, y) ¤ a = x ± b = y)
	±	(µp · (Fst p, Snd p) = p)
®);
(* We use the type lemmas to bring abstraction and representation functions *)
(* for the new type into the assumptions: *)
a (strip_asm_tac (simple_´_match_mp_rule type_lemmas_thm ¸_def));
(* Now we use the definition of IsPairRep to bring representations *)
(* of the three operations into the assumptions: *)
a (strip_asm_tac is_pair_rep_def);
(* Now we can introduce the witnesses: *)
a (simple_¶_tac ¬(Ìx y· abs((x comma y):'a­'b­BOOL)) : 'a ­ 'b ­ 'a¸'b®);
a (simple_¶_tac ¬(Ìp· (fst:('a­'b­BOOL)­'a) (rep p)) : 'a ¸ 'b ­ 'a®);
a (simple_¶_tac ¬(Ìp· (snd:('a­'b­BOOL)­'b) (rep p)) : 'a ¸ 'b ­ 'b®);
(* It is convenient to rewrite one of the assumptions with another: *)
a (GET_NTH_ASM_T 4 (fn th => DROP_NTH_ASM_T 3 (asm_tac o rewrite_rule[th])));
(* Now simplify strip the problem up *)
a (asm_rewrite_tac[] THEN REPEAT strip_tac);
(* 4 subgoals. 1: *)
a (lemma_tac ¬
	(rep:'a¸'b­'a­'b­BOOL) ((abs:('a­'b­BOOL)­'a¸'b) ((a:'a) comma (b:'b))) 
	= rep(abs(x comma y))®);
(* 1.1: *)
a(POP_ASM_T rewrite_thm_tac);
(* 1.2: *)
a (TOP_ASM_T (asm_ante_tac o concl) THEN POP_ASM_T(fn _ => asm_rewrite_tac[] 
	THEN simple_taut_tac));
(* 2 is very similar to 1: *)
a (lemma_tac ¬
	(rep:'a¸'b­'a­'b­BOOL) ((abs:('a­'b­BOOL)­'a¸'b) ((a:'a) comma (b:'b)))
	= rep(abs(x comma y))®);
a(POP_ASM_T rewrite_thm_tac);
(* Does lemma *)
a (TOP_ASM_T (asm_ante_tac o concl) THEN
		POP_ASM_T(fn _ => asm_rewrite_tac[] THEN simple_taut_tac));
(* 3: *)
a (GET_NTH_ASM_T 5 (asm_ante_tac o concl) THEN asm_rewrite_tac[]);
(* 4: *)
a (lemma_tac ¬IsPairRep ((rep:'a¸'b­'a­'b­BOOL) p)®);
(* 4.1: *)
a(asm_rewrite_tac[]);
(* Does 4.1. 4.2: *)
a (lemma_tac ¬
	((fst (rep p):'a) comma (snd (rep p):'b))
	= (rep:'a¸'b­'a­'b­BOOL) p®);
(* 4.2.1: *)
a (GET_NTH_ASM_T 3 (strip_asm_tac o simple_µ_elim¬(rep:'a¸'b­'a­'b­BOOL) p®));
(* 4.2.2: *)
a (asm_rewrite_tac[]);
pop_thm()));
=TEX
\subsection{$Curry$ and $Uncurry$}
=SML
val Ûuncurry_defÝ = new_spec(["Uncurry","uncurry_def"], 1, (
push_goal([], ¬
	¶ Uncurry : ('a ­ 'b ­ 'c) ­ ('a ¸ 'b ­ 'c)· µ f x y·
	Uncurry f (x, y) = f x y
®);
a(simple_¶_tac ¬Ìf:'a ­ 'b ­ 'c; p·f (Fst p) (Snd p)®);
a(rewrite_tac[pair_ops_def]);
pop_thm()));
=TEX
=SML
val Ûcurry_defÝ = new_spec(["Curry","curry_def"], 1, (
push_goal([], ¬
	¶ Curry : ('a ¸ 'b ­ 'c) ­ ('a ­ 'b ­ 'c)· µ f x y·
	Curry f x y = f (x, y)
®);
a(simple_¶_tac ¬Ìf:'a ¸ 'b ­ 'c; x y·f (x, y)®);
a(rewrite_tac[pair_ops_def]);
pop_thm()));
=TEX
\subsection{A Portmanteau Theorem}
In implementing the following, due to historical reasons,
it happens to be convenient to nest invocations
of the subgoal package.
=SML
val Ûpair_clausesÝ = save_thm("pair_clauses",(
push_goal([],¬µ (x: 'a) (y: 'b) (a:'a) (b:'b)
	(p:'a ¸ 'b)
	(fu : 'a ­ 'b ­ 'c)
	(fc : ('a ¸ 'b) ­ 'c) ·
	Fst (x, y) = x ± 
	Snd (x, y) = y ±
	((a, b) = (x, y) ¤ a = x ± b = y) ±
	(Fst p, Snd p) = p ±
	Curry fc x y = fc (x, y) ±
	Uncurry fu (x, y) = fu x y ±
	Uncurry fu p = fu (Fst p) (Snd p) ±	
	((a,b) = p ¤ (a = Fst p ± b = Snd p)) ±
	(p = (a,b)  ¤ (Fst p = a ± Snd p = b))®);
a(rewrite_tac [
	pair_ops_def,
	curry_def,
	uncurry_def,
=TEX
An alternative form for the rewriting $uncurry$, that
will only be rewritten with if $uncurry\_def$ doesn't match:
=SML
(push_goal([],¬µ (f:'a ­ 'b ­ 'c) (x:'a ¸ 'b) · 
	Uncurry f x = f (Fst x) (Snd x)®);
a(REPEAT strip_tac);
a(once_rewrite_tac[eq_sym_rule(simple_µ_elim ¬x:'a ¸ 'b®
	(hd(rev(strip_±_rule (get_defn "pair" "Fst")))))]);
a(pure_rewrite_tac[uncurry_def]);
a(rewrite_tac[get_defn "pair" "Fst"]);
pop_thm()),
=TEX
An alternative form for the rewriting of equalities on pairs, that
will only be rewritten with if the relevant clause of $pair\_ops\_def$ doesn't match:
=SML
(push_goal([],¬µ (a:'a) (b:'b) z · 
	((a,b) = z ¤ (a = Fst z ± b = Snd z)) ±
	(z = (a,b)  ¤ (Fst z = a ± Snd z = b))®);
a(REPEAT simple_µ_tac THEN once_rewrite_tac
	[eq_sym_rule(simple_µ_elim ¬z:'a ¸ 'b®
	(hd(rev(strip_±_rule (get_defn "pair" "Fst")))))]);
a(rewrite_tac[get_defn "pair" "Fst"]);
pop_thm())
]);
=TEX
Round this lot off:
=SML
pop_thm())); (* end of proof of theorem pair_clauses *)
=TEX
\subsection{Tidying Up}
We don't want to see certain things on the theory listing
after the creation of the theory of pairs.
Thus the following:
=SML
val _ = declare_nonfix "comma";
=TEX
\subsection{End of Structure}
=SML
val _ = pop_pc();
end; (* of structure PairTheory *)
open PairTheory;
=TEX
\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
