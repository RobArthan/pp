=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FORMAL METHODS UNIT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Theory of Pairs}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP037}  %% Mandatory field
\def\SCCSversion{$Date$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{The theory of pairs for ICL HOL is implemented.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue \SCCSversion (\FormatDate{$Date$%
})] First draft.
\end{description}
\subsection{Changes forecast}
Under development.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains parts of the ICL HOL
proof development system called for in \cite{DS/FMU/IED/HLD011}.
\subsection{Introduction}
=TEX
\section{ABSTRACTION AND REPRESENTATION FUNCTIONS}
When we use $new\_type\_definition$ a new definitional
axiom is introduced of the following form. 
Û
Ö (Ñ f.TYPE_DEFINITION Pred f)
Ê
Here $Pred$ is the predicate which defines a subset of
existing type which is equinumerous with the new type.
The axiom asserts the existence of a 1-1 correspondence
between the new type and that subset.
To put the axiom to work it is usually convenient
to use explicit abstraction and representation functions
to enable facts about the predicate to be interpreted as
facts about the new type.

In this section we supply a thoerem supporting a utility which, given a theorem
of the above form, automatically defines abstraction
and representation functions as constants with appropriate
properties. In the Cambridge HOL system these properties
comprised a list of half a dozen or more facts. We
prefer to work with rather less.


Our first objective is to prove the following theorem.
We can then instantiate this to match a given new type axiom
and so derive a theorem which can be used as an argument
to $new\_specification$ to define abstraction and
representation functions, say $abs$ and $rep$ with the
relevant properties, viz. that $abs$ is a left inverse
of $rep$, and that $rep$ is a left inverse of the
restriction of $abs$ to the subset determined by $Pred$.
Note that these properties imply that $abs$ is onto and
that $rep$ is one-to-one.
Û
Ö É Pred.(Ñ f.TYPE_DEFINITION Pred f) ä
	(Ñ abs repé
		(É a.abs (rep a) = a) Ä
		 (É réPred r = (rep (abs r) = r)))
Ê
=TEX
To prove the above theorem it is convenient first to
prove the following triviality:
Û
Ö Éf:'aã'b; x yé(f x = f y ä x = y) Ç (f x = f y Ç x = y)
Ê
Before we prove this we make sure we are in the right
theory.
=SML
open_theory"misc";
=TEX
=SML
=SML
push_goal([], ªÉf:'aã'béOneOne f Ç Éx yé(f x = f y Ç x = y)º);
a(lemma_tac ªÉf:'aã'b; x yé(f x = f y ä x = y) Ç (f x = f y Ç x = y)º);
a(REPEAT strip_tac THEN POP_ASM_T rewrite_thm_tac);
a(asm_rewrite_tac[one_one_def]);
val ‚one_one_thm· = pop_thm();
=TEX
ÛOld Proof
	REPEAT(EQ_TAC THEN DISCH_TAC THEN ASM_REWRITE_TAC[]) THEN
	UNDISCHALL_TAC THEN TAUT_TAC
Ê
=SML
push_goal([], ªÉf g:'aã'béf = g Ç (Éx é f x = g x)º);
a(REPEAT strip_tac THEN TRY_T (asm_rewrite_tac[]));
a(once_rewrite_tac(map eq_sym_rule[simple_É_elim ªf:'aã'bº eta_axiom,
				simple_É_elim ªg:'aã'bº eta_axiom]));
a(asm_rewrite_tac[]);
val ‚ext_thm· = pop_thm();
=TEX
=TEX
Our main theorem in this section may now be proved.
=SML
push_goal([], ª
	Épred é (Ñf:'aã'béTypeDefn pred f) ä
	Ñabs:'bã'aéÑrep:'aã'bé(Éaéabs(rep a) = a) Ä
		 Érépred r Ç rep(abs r) = rº);
(* Expand some definitions and split goal up: *)
	a (rewrite_tac[type_defn_def, one_one_thm, onto_def] THEN REPEAT strip_tac);
(* Give witnesses for abstraction and representation functions: *)
	a(simple_Ñ_tac(ªçy:'béáx:'aé y = f xº) THEN simple_Ñ_tac (ªf:'aã'bº));
(* Split it up some more *)
	a(rewrite_tac[] THEN REPEAT strip_tac);
(* We get three subgoals. 1: *)
	a(asm_rewrite_tac[]);
	a(LEMMA_T ªÑxéa = xº (accept_tac o eq_sym_rule o simple_Ñ_á_rule));
(* The lemma proves the goal, so only one subgoal *)
	a(simple_Ñ_tacªa:'aº THEN rewrite_tac[]);
(* That completes 1. 2: *)
	a(GET_NTH_ASM_T 1 (undisch_tac o concl) THEN asm_rewrite_tac[]);
	a(ä_T (accept_tac o eq_sym_rule o simple_Ñ_á_rule));
(* That completes 2. 3: *)
	a(asm_rewrite_tac[] THEN REPEAT strip_tac);
(* Only one subgoal *)
	a(simple_Ñ_tac(ªá xér = (f:'aã'b) xº));
	a(asm_rewrite_tac[]);
val ‚type_lemmas_thm· = save_thm ("type_lemmas_thm", pop_thm());
=TEX
\section{THE THEORY $PAIR$}
We can now use the functions of the earlier sections
to help use define the theory of pairs.

The basic idea is to represent the product type $A â B$
as the singleton subsets in the power set $(A â B) ã bool$,
which we can represent as $A ã B ã bool$.

The function `$MK_PAIR$' is the representation of the
pairing operation. `$IS\_PAIR$' is the predicate
which represents the range of `$MK_PAIR$.
=SML
new_theory "pair";
declare_infix(200, "comma");
=TEX
=SML
push_goal([], ª
ÑIsPairRep:('a ã 'b ã BOOL) ã BOOLé
	Ñ ($comma):'a ã 'b ã ('a ã 'b ã BOOL); fst; sndé
		(Éx yé	IsPairRep (x comma y)
		 Ä	fst(x comma y) = x
		 Ä	snd(x comma y) = y)
	Ä	(Éx y a bé (a comma b) = (x comma y) Ç a = x Ä b = y)
	Ä	(Épé IsPairRep p ä (fst p comma snd p) = p)
º);
a (simple_Ñ_tac ªçp:'aã'bãBOOL é Ña b é Éx y é p x y Ç x = a Ä y = bº);
a (simple_Ñ_tac ªça:'a; b:'b é çx y é x = a Ä y = bº);
a (simple_Ñ_tac ªçp:'aã'bãBOOL é áx é Ñ y é p x yº);
a (simple_Ñ_tac ªçp:'aã'bãBOOL é áy é Ñ x é p x yº);
a (conv_tac (all_simple_%beta%_conv) THEN REPEAT strip_tac);
(* 7 subgoals: 1: *)
a (simple_Ñ_tac ªx:'aº THEN simple_Ñ_tac ªy:'bº THEN rewrite_tac[]);
(* 2: *)
a(LEMMA_T ªÑx':'a; y':'b é x' = x Ä y' = yº (strip_asm_tac o simple_Ñ_á_rule));
a (simple_Ñ_tac ªx:'aº THEN simple_Ñ_tac ªy:'bº THEN rewrite_tac[]);
(* 3 is very similar to 2: *)
a(LEMMA_T ªÑy':'b; x':'a é x' = x Ä y' = yº (strip_asm_tac o simple_Ñ_á_rule));
a (simple_Ñ_tac ªy:'bº THEN simple_Ñ_tac ªx:'aº THEN rewrite_tac[]);
(* 4: *)
a (conv_tac eq_sym_conv);
a (POP_ASM_T (strip_asm_tac o rewrite_rule[] o all_simple_%beta%_rule o
		ap_arg_rule ªy:'bº o ap_arg_rule ªx:'aº));
(* 5 is very similar to 4: *)
a(conv_tac eq_sym_conv);
a (POP_ASM_T (strip_asm_tac o rewrite_rule[] o all_simple_%beta%_rule o
		ap_arg_rule ªy:'bº o ap_arg_rule ªx:'aº));
(* 6: *)
a (DROP_ASMS_T (rewrite_tac o map eq_sym_rule));
(* 7: *)
a (asm_rewrite_tac[ext_thm]);
a(LEMMA_T ªÑx':'a; y':'b é x' = a Ä y' = bº
			(STRIP_THM_THEN rewrite_thm_tac o simple_Ñ_á_rule));
(* Two subgoals. 7/1: *)
a (simple_Ñ_tac ªa:'aº THEN simple_Ñ_tac ªb:'bº THEN rewrite_tac[]);
(* 7/2: *)
a(LEMMA_T ªÑy':'b;  x':'aé x' = a Ä y' = bº
			(STRIP_THM_THEN rewrite_thm_tac o simple_Ñ_á_rule));
(* The rewriting proves the goal, leaving only the lemma: *)
a (simple_Ñ_tac ªb:'bº THEN simple_Ñ_tac ªa:'aº THEN rewrite_tac[]);
val ‚pair_rep_thm· = pop_thm();
=TEX
=SML
val ‚is_pair_rep_def· = new_specification(["‚IsPairRep·"], 1, pair_rep_thm);
=TEX
=SML
push_goal([], ªÑp:('a ã 'b ã BOOL)é IsPairRep pº);
a(strip_asm_tac is_pair_rep_def);
a(simple_Ñ_tac ª(a:'a comma b:'b):'a ã 'b ã BOOLº THEN asm_rewrite_tac[]);
val ‚pairs_exist_thm· = pop_thm();
=TEX
=SML
declare_infix(150, "â");
declare_terminator"â";
=TEX
=SML
val â_def = new_type_defn("â", "â", ["'a", "'b"], pairs_exist_thm);
=TEX
=SML
declare_infix(150, ",");
=TEX
=SML
push_goal([], ª
	Ñ ($,):'a ã 'b ã ('a â 'b); Fst; Snd é
		(Éx y é Fst(x, y) = x Ä Snd(x, y) = y)
	Ä	(Éx y a b é (a, b) = (x, y) Ç a = x Ä b = y)
	Ä	(Ép é (Fst p, Snd p) = p)
º);
(* We use the type lemmas to bring abstraction and representation functions *)
(* for the new type into the assumptions: *)
a (strip_asm_tac (simple_ä_match_mp_rule type_lemmas_thm â_def));
(* Now we use the definition of IsPairRep to bring representations *)
(* of the three operations into the assumptions: *)
a (strip_asm_tac is_pair_rep_def);
(* Now we can introduce the witnesses: *)
a (simple_Ñ_tac ª(çx yé abs((x comma y):'aã'bãBOOL)) : 'a ã 'b ã 'aâ'bº);
a (simple_Ñ_tac ª(çpé (fst:('aã'bãBOOL)ã'a) (rep p)) : 'a â 'b ã 'aº);
a (simple_Ñ_tac ª(çpé (snd:('aã'bãBOOL)ã'b) (rep p)) : 'a â 'b ã 'bº);
(* It is convenient to rewrite one of the assumptions with another: *)
a (GET_NTH_ASM_T 4 (fn th => DROP_NTH_ASM_T 3 (asm_tac o rewrite_rule[th])));
(* Now simplify strip the problem up *)
a (asm_rewrite_tac[] THEN REPEAT strip_tac);
(* 4 subgoals. 1: *)
a (lemma_tac ª
	(rep:'aâ'bã'aã'bãBOOL) ((abs:('aã'bãBOOL)ã'aâ'b) ((a:'a) comma (b:'b))) 
	= rep(abs(x comma y))º);
(* 1.1: *)
a(POP_ASM_T rewrite_thm_tac);
(* 1.2: *)
a (TOP_ASM_T (undisch_tac o concl) THEN POP_ASM_T(fn _ => asm_rewrite_tac[] THEN taut_tac));
(* 2 is very similar to 1: *)
a (lemma_tac ª
	(rep:'aâ'bã'aã'bãBOOL) ((abs:('aã'bãBOOL)ã'aâ'b) ((a:'a) comma (b:'b)))
	= rep(abs(x comma y))º);
a(POP_ASM_T rewrite_thm_tac);
(* Does lemma *)
a (TOP_ASM_T (undisch_tac o concl) THEN
		POP_ASM_T(fn _ => asm_rewrite_tac[] THEN taut_tac));
(* 3: *)
a (GET_NTH_ASM_T 5 (undisch_tac o concl) THEN asm_rewrite_tac[]);
(* 4: *)
a (lemma_tac ªIsPairRep ((rep:'aâ'bã'aã'bãBOOL) p)º);
(* 4.1: *)
a(asm_rewrite_tac[]);
(* Does 4.1. 4.2: *)
a (lemma_tac ª
	((fst (rep p):'a) comma (snd (rep p):'b))
	= (rep:'aâ'bã'aã'bãBOOL) pº);
(* 4.2.1: *)
a (GET_NTH_ASM_T 3 (strip_asm_tac o simple_É_elimª(rep:'aâ'bã'aã'bãBOOL) pº));
(* 4.2.2: *)
a (asm_rewrite_tac[]);
val ‚pair_ops_thm· = pop_thm();
=TEX
$new\_specification$ may now be used to introduce the basic operations
on pairs:
=SML
val ‚pair_ops_def· = new_specification([",", "Fst", "Snd"], 3, pair_ops_thm);
=TEX
\section{$Curry$ AND $Uncurry$}
=SML
push_goal([], ª
	Ñ Uncurry : ('a ã 'b ã 'c) ã ('a â 'b ã 'c)é É f x yé
	Uncurry f (x, y) = f x y
º);
a(simple_Ñ_tac ªçf:'a ã 'b ã 'c; péf (Fst p) (Snd p)º);
a(rewrite_tac[pair_ops_def]);
val ‚uncurry_thm· = pop_thm();
=TEX
=SML
val ‚uncurry_def· = new_specification(["Uncurry"], 1, uncurry_thm);
=TEX
=SML
push_goal([], ª
	Ñ Curry : ('a â 'b ã 'c) ã ('a ã 'b ã 'c)é É f x yé
	Curry f x y = f (x, y)
º);
a(simple_Ñ_tac ªçf:'a â 'b ã 'c; x yéf (x, y)º);
a(rewrite_tac[pair_ops_def]);
val ‚curry_thm· = pop_thm();
=TEX
=SML
val ‚curry_def· = new_specification(["Curry"], 1, curry_thm);

=TEX
\end{document}
