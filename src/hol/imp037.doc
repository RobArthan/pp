=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation for the Theory of Pairs}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP037}  %% Mandatory field
\def\SCCSversion{$Date$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{The theory of pairs for ICL HOL is implemented.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.2 (21st August 1991)] 
First draft.
\item [Issue 1.3 (21st September 1991)]
Added some theorems, and structure wrapping.
\item [Issue 1.4 (2nd October 1991)]
Tidying up.
\item [Issue 1.5 (17th October 1991)]
Gained $fun\_rel\_thm$ from \cite{DS/FMU/IED/IMP038}.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the theory of pairs.
This is called for in \cite{DS/FMU/IED/HLD011}.
The design is in \cite{DS/FMU/IED/DTD037}.

\subsection{Deficiences}
None known.
\subsection{Introduction}
=TEX
\section{ABSTRACTION AND REPRESENTATION FUNCTIONS}
When we use $new\_type\_definition$ a new definitional
axiom is introduced of the following form. 
Û
Ö (Ñ f.TYPE_DEFINITION Pred f)
Ê
Here $Pred$ is the predicate which defines a subset of
existing type which is equinumerous with the new type.
The axiom asserts the existence of a 1-1 correspondence
between the new type and that subset.
To put the axiom to work it is usually convenient
to use explicit abstraction and representation functions
to enable facts about the predicate to be interpreted as
facts about the new type.

In this section we supply a theorem supporting a utility which, given a theorem
of the above form, automatically defines abstraction
and representation functions as constants with appropriate
properties. In the Cambridge HOL system these properties
comprised a list of half a dozen or more facts. We
prefer to work with rather less.


Our first objective is to prove the following theorem.
We can then instantiate this to match a given new type axiom
and so derive a theorem which can be used as an argument
to $new\_specification$ to define abstraction and
representation functions, say $abs$ and $rep$ with the
relevant properties, viz. that $abs$ is a left inverse
of $rep$, and that $rep$ is a left inverse of the
restriction of $abs$ to the subset determined by $Pred$.
Note that these properties imply that $abs$ is onto and
that $rep$ is one-to-one.
Û
Ö É Pred.(Ñ f.TYPE_DEFINITION Pred f) ä
	(Ñ abs repé
		(É a.abs (rep a) = a) Ä
		 (É réPred r = (rep (abs r) = r)))
Ê
=TEX
To prove the above theorem it is convenient first to
prove the following triviality:
Û
Ö Éf:'aã'b; x yé(f x = f y ä x = y) Ç (f x = f y Ç x = y)
Ê
The following structure adds material to theory ``misc''
and creates a new theory ``pair''.
=SML
structure ‚PairTheory· : PairTheory = struct
=TEX
Before we prove this we make sure we are in the right
theory.
=SML
val _ = open_theory "misc";
=TEX
=SML
=SML
val ‚one_one_thm· = save_thm("one_one_thm",(
push_goal([], ªÉf:'aã'béOneOne f Ç Éx yé(f x = f y Ç x = y)º);
a(lemma_tac ªÉf:'aã'b; x yé(f x = f y ä x = y) Ç (f x = f y Ç x = y)º);
a(REPEAT strip_tac THEN POP_ASM_T rewrite_thm_tac);
a(asm_rewrite_tac[one_one_def]);
pop_thm()));
=TEX
=SML
val ‚ext_thm· = save_thm("ext_thm",(
push_goal([], ªÉf g:'aã'béf = g Ç (Éx é f x = g x)º);
a(REPEAT strip_tac THEN TRY_T (asm_rewrite_tac[]));
a(once_rewrite_tac(map eq_sym_rule[simple_É_elim ªf:'aã'bº eta_axiom,
				simple_É_elim ªg:'aã'bº eta_axiom]));
a(asm_rewrite_tac[]);
pop_thm()));
=TEX
Our main theorem in this section may now be proved.
=SML
val ‚type_lemmas_thm· = save_thm ("type_lemmas_thm", (
push_goal([], ª
	Épred é (Ñf:'aã'béTypeDefn pred f) ä
	Ñabs:'bã'aéÑrep:'aã'bé(Éaéabs(rep a) = a) Ä
		 Érépred r Ç rep(abs r) = rº);
(* Expand some definitions and split goal up: *)
	a (rewrite_tac[type_defn_def, one_one_thm, onto_def] THEN REPEAT strip_tac);
(* Give witnesses for abstraction and representation functions: *)
	a(simple_Ñ_tac(ªçy:'béáx:'aé y = f xº) THEN simple_Ñ_tac (ªf:'aã'bº));
(* Split it up some more *)
	a(rewrite_tac[] THEN REPEAT strip_tac);
(* We get three subgoals. 1: *)
	a(asm_rewrite_tac[]);
	a(LEMMA_T ªÑxéa = xº (accept_tac o eq_sym_rule o simple_Ñ_á_rule));
(* The lemma proves the goal, so only one subgoal *)
	a(simple_Ñ_tacªa:'aº THEN rewrite_tac[]);
(* That completes 1. 2: *)
	a(GET_NTH_ASM_T 1 (undisch_tac o concl) THEN asm_rewrite_tac[]);
	a(ä_T (accept_tac o eq_sym_rule o simple_Ñ_á_rule));
(* That completes 2. 3: *)
	a(asm_rewrite_tac[] THEN REPEAT strip_tac);
(* Only one subgoal *)
	a(simple_Ñ_tac(ªá xér = (f:'aã'b) xº));
	a(asm_rewrite_tac[]);
pop_thm()));
=TEX
\subsection{On Functional Relations}
A set-theoretic proof relies on the identification of functions with
single valued relations in set theory. To adapt it to HOL we need
a theorem to justify this line of argument.
The following theorem does just that by allowing
us to rewrite problems about function
existence in terms of two-place relations and so facilitates the use
of standard set-theoretic means of constructing functions.
=SML
val ‚fun_rel_thm· = save_thm("fun_rel_thm",(
push_goal([], ªÉr:'aã'bãBOOLé
	(ÑféÉx yéf x = y Ç r x y) Ç (ÉxéÑyér x y Ä Ézér x z ä z = y)
º);
=TEX
=SML
a(REPEAT strip_tac);
(* 2 subgoals 1: *)
a(simple_Ñ_tacª(f:'aã'b)xº);
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN
	LEMMA_T ªr x ((f:'aã'b)x):BOOLº (fn th => asm_rewrite_tac[th]));
(* Above leaves only the lemma to do: *)
a(POP_ASM_T (rewrite_thm_tac o conv_rule (ONCE_MAP_C eq_sym_conv)));
(* Completes 1. 2: *)
a(simple_Ñ_tac ªçx:'aéáy:'bér x yº THEN conv_tac all_simple_%beta%_conv);
a(REPEAT strip_tac);
(* 2 subgoals: 2.1: *)
a(LEMMA_T ªÑy:'bér (x:'a)yº (ante_tac o simple_Ñ_á_rule)
	THEN GET_NTH_ASM_T 2 (strip_asm_tac o simple_É_elimªx:'aº));
(* 2 subgoals. 2.1.1: *)
a(simple_Ñ_tacªy':'bº THEN asm_rewrite_tac[]);
(* Completes 2.1.1. 2.1.2: *)
a(asm_rewrite_tac[]);
(* Completes 2.1. 2.2: *)
a(LEMMA_T ªÑy':'bér (x:'a)y'º (asm_tac o simple_Ñ_á_rule));
(* 2 subgoals. 2.2.1: *)
a(simple_Ñ_tacªy:'bº THEN asm_rewrite_tac[]);
(* Completes 2.2.1. 2.2.2: *)
a(GET_NTH_ASM_T 3 (strip_asm_tac o simple_É_elimªx:'aº));
a(TOP_ASM_T (strip_asm_tac o simple_É_elimªáy:'bé r (x:'a) yº));
a(GET_NTH_ASM_T 2 (strip_asm_tac o simple_É_elimªy:'bº));
a(asm_rewrite_tac[]);
=TEX
=SML
pop_thm()
));
=TEX
\section{THE THEORY $PAIR$}
We can now use the functions of the earlier sections
to help use define the theory of pairs.

The basic idea is to represent the product type $A â B$
as the singleton subsets in the power set $(A â B) ã bool$,
which we can represent as $A ã B ã bool$.
=SML
val _ = new_theory "pair";
val _ = declare_infix(200, "comma");
=TEX
=SML
val ‚is_pair_rep_def· = new_specification(["‚IsPairRep·"], 1, (
push_goal([], ª
ÑIsPairRep:('a ã 'b ã BOOL) ã BOOLé
	Ñ ($comma):'a ã 'b ã ('a ã 'b ã BOOL); fst; sndé
		(Éx yé	IsPairRep (x comma y)
		 Ä	fst(x comma y) = x
		 Ä	snd(x comma y) = y)
	Ä	(Éx y a bé (a comma b) = (x comma y) Ç a = x Ä b = y)
	Ä	(Épé IsPairRep p ä (fst p comma snd p) = p)
º);
a (simple_Ñ_tac ªçp:'aã'bãBOOL é Ña b é Éx y é p x y Ç x = a Ä y = bº);
a (simple_Ñ_tac ªça:'a; b:'b é çx y é x = a Ä y = bº);
a (simple_Ñ_tac ªçp:'aã'bãBOOL é áx é Ñ y é p x yº);
a (simple_Ñ_tac ªçp:'aã'bãBOOL é áy é Ñ x é p x yº);
a (conv_tac (all_simple_%beta%_conv) THEN REPEAT strip_tac);
(* 7 subgoals: 1: *)
a (simple_Ñ_tac ªx:'aº THEN simple_Ñ_tac ªy:'bº THEN rewrite_tac[]);
(* 2: *)
a(LEMMA_T ªÑx':'a; y':'b é x' = x Ä y' = yº (strip_asm_tac o simple_Ñ_á_rule));
a (simple_Ñ_tac ªx:'aº THEN simple_Ñ_tac ªy:'bº THEN rewrite_tac[]);
(* 3 is very similar to 2: *)
a(LEMMA_T ªÑy':'b; x':'a é x' = x Ä y' = yº (strip_asm_tac o simple_Ñ_á_rule));
a (simple_Ñ_tac ªy:'bº THEN simple_Ñ_tac ªx:'aº THEN rewrite_tac[]);
(* 4: *)
a (conv_tac eq_sym_conv);
a (POP_ASM_T (strip_asm_tac o rewrite_rule[] o all_simple_%beta%_rule o
		ap_arg_rule ªy:'bº o ap_arg_rule ªx:'aº));
(* 5 is very similar to 4: *)
a(conv_tac eq_sym_conv);
a (POP_ASM_T (strip_asm_tac o rewrite_rule[] o all_simple_%beta%_rule o
		ap_arg_rule ªy:'bº o ap_arg_rule ªx:'aº));
(* 6: *)
a (DROP_ASMS_T (rewrite_tac o map eq_sym_rule));
(* 7: *)
a (asm_rewrite_tac[ext_thm]);
a(LEMMA_T ªÑx':'a; y':'b é x' = a Ä y' = bº
			(STRIP_THM_THEN rewrite_thm_tac o simple_Ñ_á_rule));
(* Two subgoals. 7/1: *)
a (simple_Ñ_tac ªa:'aº THEN simple_Ñ_tac ªb:'bº THEN rewrite_tac[]);
(* 7/2: *)
a(LEMMA_T ªÑy':'b;  x':'aé x' = a Ä y' = bº
			(STRIP_THM_THEN rewrite_thm_tac o simple_Ñ_á_rule));
(* The rewriting proves the goal, leaving only the lemma: *)
a (simple_Ñ_tac ªb:'bº THEN simple_Ñ_tac ªa:'aº THEN rewrite_tac[]);
pop_thm()));
=TEX
We can now declare the type of pairs:
=SML
val _ = declare_infix(150, "â");
val _ = declare_terminator"â";
=TEX
=SML
val ‚â_def· = new_type_defn("â", "â", ["'a", "'b"], (
push_goal([], ªÑp:('a ã 'b ã BOOL)é IsPairRep pº);
a(strip_asm_tac is_pair_rep_def);
a(simple_Ñ_tac ª(a:'a comma b:'b):'a ã 'b ã BOOLº THEN asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val _ = declare_infix(150, ",");
=TEX
$new\_specification$ may now be used to introduce the basic operations
on pairs:
=SML
val ‚pair_ops_def· = new_specification([",", "Fst", "Snd"], 3, (
push_goal([], ª
	Ñ ($,):'a ã 'b ã ('a â 'b); Fst; Snd é
		(Éx y é Fst(x, y) = x Ä Snd(x, y) = y)
	Ä	(Éx y a b é (a, b) = (x, y) Ç a = x Ä b = y)
	Ä	(Ép é (Fst p, Snd p) = p)
º);
(* We use the type lemmas to bring abstraction and representation functions *)
(* for the new type into the assumptions: *)
a (strip_asm_tac (simple_ä_match_mp_rule type_lemmas_thm â_def));
(* Now we use the definition of IsPairRep to bring representations *)
(* of the three operations into the assumptions: *)
a (strip_asm_tac is_pair_rep_def);
(* Now we can introduce the witnesses: *)
a (simple_Ñ_tac ª(çx yé abs((x comma y):'aã'bãBOOL)) : 'a ã 'b ã 'aâ'bº);
a (simple_Ñ_tac ª(çpé (fst:('aã'bãBOOL)ã'a) (rep p)) : 'a â 'b ã 'aº);
a (simple_Ñ_tac ª(çpé (snd:('aã'bãBOOL)ã'b) (rep p)) : 'a â 'b ã 'bº);
(* It is convenient to rewrite one of the assumptions with another: *)
a (GET_NTH_ASM_T 4 (fn th => DROP_NTH_ASM_T 3 (asm_tac o rewrite_rule[th])));
(* Now simplify strip the problem up *)
a (asm_rewrite_tac[] THEN REPEAT strip_tac);
(* 4 subgoals. 1: *)
a (lemma_tac ª
	(rep:'aâ'bã'aã'bãBOOL) ((abs:('aã'bãBOOL)ã'aâ'b) ((a:'a) comma (b:'b))) 
	= rep(abs(x comma y))º);
(* 1.1: *)
a(POP_ASM_T rewrite_thm_tac);
(* 1.2: *)
a (TOP_ASM_T (undisch_tac o concl) THEN POP_ASM_T(fn _ => asm_rewrite_tac[] 
	THEN taut_tac));
(* 2 is very similar to 1: *)
a (lemma_tac ª
	(rep:'aâ'bã'aã'bãBOOL) ((abs:('aã'bãBOOL)ã'aâ'b) ((a:'a) comma (b:'b)))
	= rep(abs(x comma y))º);
a(POP_ASM_T rewrite_thm_tac);
(* Does lemma *)
a (TOP_ASM_T (undisch_tac o concl) THEN
		POP_ASM_T(fn _ => asm_rewrite_tac[] THEN taut_tac));
(* 3: *)
a (GET_NTH_ASM_T 5 (undisch_tac o concl) THEN asm_rewrite_tac[]);
(* 4: *)
a (lemma_tac ªIsPairRep ((rep:'aâ'bã'aã'bãBOOL) p)º);
(* 4.1: *)
a(asm_rewrite_tac[]);
(* Does 4.1. 4.2: *)
a (lemma_tac ª
	((fst (rep p):'a) comma (snd (rep p):'b))
	= (rep:'aâ'bã'aã'bãBOOL) pº);
(* 4.2.1: *)
a (GET_NTH_ASM_T 3 (strip_asm_tac o simple_É_elimª(rep:'aâ'bã'aã'bãBOOL) pº));
(* 4.2.2: *)
a (asm_rewrite_tac[]);
pop_thm()));
=TEX
\subsection{$Curry$ and $Uncurry$}
=SML
val ‚uncurry_def· = new_specification(["Uncurry"], 1, (
push_goal([], ª
	Ñ Uncurry : ('a ã 'b ã 'c) ã ('a â 'b ã 'c)é É f x yé
	Uncurry f (x, y) = f x y
º);
a(simple_Ñ_tac ªçf:'a ã 'b ã 'c; péf (Fst p) (Snd p)º);
a(rewrite_tac[pair_ops_def]);
pop_thm()));
=TEX
=SML
val ‚curry_def· = new_specification(["Curry"], 1, (
push_goal([], ª
	Ñ Curry : ('a â 'b ã 'c) ã ('a ã 'b ã 'c)é É f x yé
	Curry f x y = f (x, y)
º);
a(simple_Ñ_tac ªçf:'a â 'b ã 'c; x yéf (x, y)º);
a(rewrite_tac[pair_ops_def]);
pop_thm()));
=TEX
\subsection{A Portmanteau Theorem}
In implementing the following, due to historical reasons,
it happens to be convenient to nest invocations
of the subgoal package.
=SML
val ‚pair_clauses· = save_thm("pair_clauses",(
push_goal([],ªÉ (x: 'a) (y: 'b) (a:'a) (b:'b)
	(p:'a â 'b)
	(fu : 'a ã 'b ã 'c)
	(fc : ('a â 'b) ã 'c) é
	Fst (x, y) = x Ä 
	Snd (x, y) = y Ä
	((a, b) = (x, y) Ç a = x Ä b = y) Ä
	(Fst p, Snd p) = p Ä
	Curry fc x y = fc (x, y) Ä
	Uncurry fu (x, y) = fu x y Ä
	Uncurry fu p = fu (Fst p) (Snd p) Ä	
	((a,b) = p Ç (a = Fst p Ä b = Snd p)) Ä
	(p = (a,b)  Ç (Fst p = a Ä Snd p = b))º);
a(rewrite_tac [
	pair_ops_def,
	curry_def,
	uncurry_def,
=TEX
An alternative form for the rewriting $uncurry$, that
will only be rewritten with if $uncurry\_def$ doesn't match:
=SML
(push_goal([],ªÉ (f:'a ã 'b ã 'c) (x:'a â 'b) é 
	Uncurry f x = f (Fst x) (Snd x)º);
a(REPEAT strip_tac);
a(once_rewrite_tac[eq_sym_rule(simple_É_elim ªx:'a â 'bº
	(hd(rev(strip_Ä_rule (get_defn "pair" "Fst")))))]);
a(pure_rewrite_tac[uncurry_def]);
a(rewrite_tac[get_defn "pair" "Fst"]);
pop_thm()),
=TEX
An alternative form for the rewriting of equalities on pairs, that
will only be rewritten with if the relevant clause of $pair\_ops\_def$ doesn't match:
=SML
(push_goal([],ªÉ (a:'a) (b:'b) z é 
	((a,b) = z Ç (a = Fst z Ä b = Snd z)) Ä
	(z = (a,b)  Ç (Fst z = a Ä Snd z = b))º);
a(REPEAT simple_É_tac THEN once_rewrite_tac
	[eq_sym_rule(simple_É_elim ªz:'a â 'bº
	(hd(rev(strip_Ä_rule (get_defn "pair" "Fst")))))]);
a(rewrite_tac[get_defn "pair" "Fst"]);
pop_thm())
]);
=TEX
Round this lot off:
=SML
pop_thm())); (* end of proof of theorem pair_clauses *)
=TEX
\subsection{Tidying Up}
We don't want to see certain things on the theory listing
after the creation of the theory of pairs.
Thus the following:
=SML
val _ = declare_nonfix "comma";
=TEX
\subsection{End of Structure}
=SML
end; (* of structure PairTheory *)
open PairTheory;
=TEX
\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
=TEX
\end{document}
