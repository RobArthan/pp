=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{TECHNOLOGY PROJECTS}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{HOL Formalised: Proof Development System}  %% Mandatory field
\TPPref{DS/FMU/IED/SPC004}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This is part of a suite of documents giving a formal
specification of the HOL logic. An abstract
model of a proof development system for HOL is defined
and its critical properties are stated.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      R.D. Arthan \\ M.J.C. Gordon (Cambridge) \\ R.B.Jones \\ K. Blackburn \\ G.M. Prout
}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion \FormatDate{$Date$%
}] First draft issue. This is based on material
which was formely part of \cite{DS/FMU/IED/SPC001}.
\end{description}
\subsection{Changes forecast}
When a little extra proof support is available for
reasoning with strings, the consistency proof for the definition
of the type $THM$ may be included here.

It may be desirable to improve the readability of the
definitions of the object language constructs in
section \ref{DEFINITIONS} by a trick using antiquotation
and the HOL parser to enter the necessary terms.

\newpage
\section{GENERAL}
\subsection{Scope}
This document specifies some high level aspects of a
proof development system for HOL.
It is part of a suite of documents specifying HOL
an overview of which may be found in \cite{DS/FMU/IED/SPC001}.

\subsection{Introduction}

In \cite{DS/FMU/IED/SPC003} the rules of inference
and definitional mechanisms which make up the HOL
deductive system are defined. In this document
we turn to specifying some high level aspects of
the HOL proof development system.
Many of the types and functions used to specify
the logic may already be viewed as specifying
corresponding parts of the implementation.
We now wish to specify a generic type giving
an abstract model of a HOL proof development system and to
characterise the critical properties of such a system. 


The designer of a proof development system
is interested in ensuring
that the theorems which the users compute are indeed
derivable from the axioms of the theory involved.
The LCF approach to this problem is to use
a programming language supporting the
abstract data type concept. Theorems are represented
as elements of an abstract
data type whose constructor functions consist
precisely of the rules of inference (suitably parameterised
so that they are partial functions rather than arbitrary
relations).

In this way, the type system of the programming
language helps to ensure that only valid theorems may be
derived. In section \ref{RULESOFINFERENCEREVISITED} we
define the action of the rules of inference on
our type of theorems. These definitions can be viewed as a high level
specification of the constructor functions of the
abstract data type.
Such functions are used to
extend the set of theorems stored within a theory.


Finally, section \ref{THEORYHIERARCHIES} discusses
an abstraction of the database side of the proof development
system.
The concept of a named hierarchy of theories
is introduced and an abstraction of the state of
an HOL proof development system is presented.
Given this, we can define the generic type of an HOL
system and so define general predicates on such systems,
e.g., {\it safety:} the property of those HOL systems
which only allow consistent extensions.
In producing a very high assurance implementation
of HOL, this would give the starting point for some
meaningful proof work: one might attempt to prove 
the safety of a design which was founded on
the theorem proving mechanisms of section
\ref{RULESOFINFERENCEREVISITED} and the (conservative)
definitional mechanisms of \cite{DS/FMU/IED/SPC003}.

\section{PREAMBLE}
We introduce the new theory. Its parents are 
the theories $spc002$ and $spc003$ defined
in \cite{DS/FMU/IED/SPC002} and \cite{DS/FMU/IED/SPC003}.
Â
close_theory();
load_theory"spc002";
new_theory"‚spc004·";
new_parent"spc003";
Ê

\section{THE RULES OF INFERENCE REVISITED} \label{RULESOFINFERENCEREVISITED}

In \cite{DS/FMU/IED/SPC001} the inference rules are
defined as relations between sequents.
We now wish to define
inference rules as relations between theorems, since this
gives a better model of what is done in a proof development
system.
Thus, recalling that a theorem is represented by a
pair $(S, T)$ where $T$ is a theory and $S$ is a sequent
$T$, we must specify how
the inference rules interact with the theory components.
Essentially, we say that
if, by rule {\bf X}{\it\_rule}, we may infer the sequent $S$
from $S_1, S_2, \ldots$, then, by {\bf X}, we
may infer $(S, T)$ from
$(S_1, T_1), (S_2, T_2), \ldots$ provided
the theory $T$ is an extension of each $T_i$.

Proof theoretically this is no different from
a rule which insists that $T_i = T$ for all $i$.
The more general formulation is meant to accord a 
little better with the thinking of the user of the
proof development system and may allow more freedom
in an implementation. An implementation need
not exploit the full generality.
For example, in the Cambridge HOL system
all proofs are conducted in the context
of a particular theory called the {\it current} theory.
Thus the abstract data type representing theorems
does not need a theory component and the current theory
is, effectively, an implicit and unused parameter to
the constructor functions of the abstract data type.
The ICL HOL system follows a different approach to
storage of theories and does tag theorems with the theory to
which they belong.

The definitions of the inference rules for theorems
are derived directly and tediously from the corresponding
rules for sequences. In each case, we simply change
the sequent arguments to theorem arguments, and check
that the corresponding rule for sequents holds for
the sequent components of the theorems and that the
theory component of the theorem inferred extends that
of all the other theorem arguments.

»
	‚SUBST· : ((string â TYPE) ã THM) ã
			TERM ã THM ã THM ã bool
…
	É eqs tm old_thm new_thm é
	SUBST eqs tm old_thm new_thm =
	let old_seq = thm_seq old_thm in let old_thy = thm_thy old_thm
	in let new_seq = thm_seq new_thm in let new_thy = thm_thy new_thm
	in
	(SUBST_rule (thm_seq o eqs) tm old_seq new_seq
	Ä
	(new_thy extends old_thy) Ä
	(image (thm_thy o eqs)(çxéT) • $extends new_thy))
À
»
	‚ABS· : (string â TYPE) ã THM ã THM ã bool
…
	É vty old_thm new_thm é
	ABS vty old_thm new_thm =
	let old_seq = thm_seq old_thm in let old_thy = thm_thy old_thm
	in let new_seq = thm_seq new_thm in let new_thy = thm_thy new_thm
	in
	(ABS_rule vty old_seq new_seq Ä
	(new_thy extends old_thy)) 
À
»
	‚INST_TYPE· : (string ã TYPE) ã THM ã THM ã bool
…
	É tysubs old_thm new_thm é
	INST_TYPE tysubs old_thm new_thm =
	let old_seq = thm_seq old_thm in let old_thy = thm_thy old_thm
	in let new_seq = thm_seq new_thm in let new_thy = thm_thy new_thm
	in
	(INST_TYPE_rule tysubs old_seq new_seq Ä
	(new_thy extends old_thy)) 
À
»
	‚DISCH· : TERM ã THM ã THM ã bool
…
	É tm old_thm new_thm é
	DISCH tm old_thm new_thm =
	let old_seq = thm_seq old_thm in let old_thy = thm_thy old_thm
	in let new_seq = thm_seq new_thm in let new_thy = thm_thy new_thm
	in
	(DISCH_rule tm old_seq new_seq Ä
	(new_thy extends old_thy))
À
»
	‚MP· : THM ã THM ã THM ã bool
…
	É imp_thm ant_thm new_thm é
	MP imp_thm ant_thm new_thm =
	let imp_seq = thm_seq imp_thm in let imp_thy = thm_thy imp_thm
	in let ant_seq = thm_seq ant_thm in let ant_thy = thm_thy ant_thm
	in let new_seq = thm_seq new_thm in let new_thy = thm_thy new_thm
	in
	(MP_rule imp_seq ant_seq new_seq Ä
	(new_thy extends imp_thy) Ä (new_thy extends ant_thy))
À
The axiom schemata for theorems are even more straightforward
to define, since they hold in every standard theory. 
»
	‚ASSUME· : TERM ã THM ã bool
…
	É tm thm é ASSUME tm thm = ASSUME_axiom tm (thm_seq thm)
À
»
	‚REFL· : TERM ã THM ã bool
…
	É tm thm é REFL tm thm = ((thm_seq thm) = REFL_axiom tm)
À
»
	‚BETA_CONV· : TERM ã THM ã bool
…
	É tm thm é BETA_CONV tm thm = BETA_CONV_axiom tm (thm_seq thm)
À

\section{THEORY HIERARCHIES AND THE HOL SYSTEM} \label{THEORYHIERARCHIES}

HOL systems operate not with the totality
of the type {\it THEORY}, but with subsets of it.
The subsets are structured as hierarchies in which
each theory has a name and a parenthood relation is
given on the names.
Moreover the representation of a theory provides
for the storage of theorems which have been proved.
We will view a theory hierarchy
as a function from names to pairs comprising
a theory and a set of sequents (forgetting the parenthood
relation since we can recover its ancestral from the
extension relation on theories).

Our abstraction for an HOL system is a (total) function\footnote{%
Arguably, a partial function or some similar,
more realistic abstraction should be used.},
which we think of as the state transition function for
an automaton whose state includes a theory hierarchy
component. We formulate three important properties
of such functions: 

\begin{tabular}{|l|p{4in}|}\hline
{\it(a)}&
a semantic property of the theorems in the system ---
do the transitions preserve truth?
I.e. given an input in which every theorem
is true in every model of the corresponding theory,
does the output have the same property? \\\hline
{\it(b)}&
a syntactic property of the theorems in the system ---
do the transitions preserve derivability?
I.e. given an input in which every theorem is derivable
from the axioms of the corresponding theory, does the
output have the same property? \\\hline
{\it(c)}&
a standard extension property --- is every theory
in the output of a transition a standard extension
of some theory in the input? \\\hline
\end{tabular}

Neither {\it(a)} nor {\it(b)} prohibits arbitrary
axiomatic extensions, this is the purpose of {\it(c)}.
However {\it(c)} see says nothing about how the system
treats the theorems in a theory hierarchy.

The reason for stating the three properties separately
is to give a little latitude in the choice of a
critical property to verify for an implementation.
E.g. it would be appropriate to verify {\it(a)} and
{\it(c)} for a system which was asserted to
permit only standard extension mechanisms but
which contained built-in inference rules for which it
was felt that a semantic proof of correctness was
significantly easier than a syntactic one.

\subsection{Theory Hierarchies}

In our abstraction of a proof development system a theory
hierarchy is represented by the following type (we assume
that the finite function in an implementation is interpreted
as a total function by mapping unused names to some
well-known theory (e.g. $MIN$ or $INIT$):
Â
TypeInference.new_type_abbrev "‚THEORY_HIERARCHY_REP·" ª:string ã (THEORY â (SEQ ã bool))º;
Ê
The theory hierarchies in a proof development system
will be required to satisfy the following condition:
»
	‚wf_hierarchy· : THEORY_HIERARCHY_REP ã bool
…
	Éhieré
	hier ù wf_hierarchy Ç 
		Éthyn seqéseq ù SND(hier thyn) ä seq ù sequents (FST(hier thyn))
À

The critical part of a proof development system states
will thus be interpreted as having the following type:
Â
subtype_def "‚THEORY_HIERARCHY·" ªwf_hierarchyº;
Ê
which we access with the following functions:
»
	‚th_theory· : THEORY_HIERARCHY ã string ã THEORY
…
	É hier thyné
	th_theory hier thyn = FST((REP_THEORY_HIERARCHY hier) thyn)
À
»
	‚th_theories· : THEORY_HIERARCHY ã (THEORY ã bool)
…
	É hier thyé
	thy ù th_theories hier Ç Ñthynéth_theory hier thyn = thy
À
»
	‚th_theorems· : THEORY_HIERARCHY ã string ã (SEQ ã bool)
…
	É hier thyn seq é
	seq ù th_theorems hier thyn Ç seq ù SND((REP_THEORY_HIERARCHY hier) thyn)
À
\subsection{Proof Development Systems}
A HOL system may be interpreted as an
instance of the following polymorphic type:
Â
TypeInference.new_type_abbrev "‚HOL_SYSTEM·" ª:(*INPUT â THEORY_HIERARCHY) ã (THEORY_HIERARCHY â *OUTPUT)º;
Ê

The above definition does not capture any conditions
on the ``theorems'' stored in the theories in the
system other than their well-formedness as sequents.
We can now consider the properties of such systems which
we might wish to verify to give some confidence that
the ``theorems'' really are theorems of the logic.

\subsubsection{Property (a)}
This is the condition based on the semantics.
To describe it, let us say that
a hierarchy is $valid$ with respect to a type, ${*}U$,
if all of its ``theorems'' are satisfied in any model
of the theory with universe ${*}U$. We could then assert
that we are interested in systems which preserve
validity of hierarchies. Thus valid hierarchies for
the type ${*}U$ are given by:

»
	‚valid_hierarchy· : *U ã THEORY_HIERARCHY ã bool
…
	É (v:*U) hieré
	hier ù valid_hierarchy v Ç
	É(int:*U INTERPRETATION) thyné
		is_model (th_theory hier thyn) int
	ä	th_theorems hier thyn • $satisfies int
À

(Note that the apparently unused first parameter of
$valid\_hierarchy$ ensures that ${*}U$ appears in the
type of $valid\_hierarchy$, as required to satisfy the
restrictions on type variables imposed by
$new\_specification$.)

The validity preserving HOL systems for the type
${*}U$ are given by:
»
	‚validity_preserving· : *U ã (*INPUT, *OUTPUT)HOL_SYSTEM ã bool
…
	É (v:*U) sysé
	sys ù validity_preserving v Ç
	Éinput hieré
	valid_hierarchy v hier ä valid_hierarchy v (FST(sys(input, hier)))
À

Thus the proposition for a given
system $sys$ would be the conjecture:
Û
	?Ö É(v:*U)évalidity_preserving v sys
Ê
I.e. property {\it(a)} is:
Û
	çsys:(*INPUT, *OUTPUT)HOL_SYSTEMéÉ(v:*U)évalidity_preserving v sys
Ê


Note that it is inadequate just to prove an instance
of the above conjecture.
E.g. since there are no models of any
theory with universe a one-point type, the instance:
Û
	?Ö É(v:one)évalidity_preserving v sys
Ê
is trivially true for any $v$.
However, using a model of a (provably) consistent theory
such as $MIN$, it is possibly to construct systems
which are not validity preserving.

This is an example of the need for the restrictions
imposed on type variables in the definition of
$new\_specification$ in \cite{DS/FMU/IED/SPC002}.
The following conjecture
Û
	?Ö xx = çsys:(*INPUT, *OUTPUT)HOL_SYSTEMéÉ(v:*U)évalidity_preserving v sys
Ê
is equal to $çsyséT$ at some instances of ${*}U$ but not at
others, and so cannot be the defining theorem of a
new constant $xx$.

\subsection{Property (b)}
This is the condition based on derivability.
The relevant condition on theory hierarchies is:
»
	‚derivable_hierarchy· : THEORY_HIERARCHY ã bool
…
	É hieré
	hier ù derivable_hierarchy Ç
	Éthyn seqé seq ù th_theorems hier thyn ä derivable_from seq (axioms(th_theory hier thyn))
À

Property {\it(b)} is then the condition on systems that
they preserve derivable hierarchies:
»
	‚derivability_preserving· : (*INPUT, *OUTPUT)HOL_SYSTEM ã bool
…
	É sysé
	sys ù derivability_preserving Ç
	Éinput hieré
	derivable_hierarchy hier ä derivable_hierarchy (FST(sys(input, hier)))
À
\subsection{Property (c)}
Property {\it(c)} states that :
»
	‚standard· : (*INPUT, *OUTPUT)HOL_SYSTEM ã bool
…
	É sysé
	sys ù standard Ç
	Éinput hier thyn1éÑthyn2é
		standard_extension (th_theory(FST(sys(input, hier)))thyn1) (th_theory hier thyn2)
À

\pagebreak
\section{THEORY LISTING}
{\catcode`\_=\active
\gdef\underscoreoff{% make _ a normal char
        \catcode`\_=\active \let_=\_}}
{\underscoreoff
\def\Xref#1#2{\hbox to \hsize{$#1$\leaders\hbox to1em{\hss.\hss}\hfill $#2$}}
\input{\jobname.thp}}

\twocolumn
\section{INDEX OF DEFINED TERMS}
\printindex
\end{document}
=IGN

