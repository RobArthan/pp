% dtd029.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design of Tactics III}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Tactics III}
\TPPref{DS/FMU/IED/DTD029}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the third grouping of tactics,
in particular those concerned with paired abstractions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version: place holder for tautology stuff.
\item [Issue 1.2]
Added some more odds and ends.
\item [Issue 1.3]
Attempting a ``complete'' design.
\item [Issue 1.4]
Used $GET\_ASM\_T$, etc, in $spec\_asm\_tac$, etc.
\item [Issue 1.5]
Reacting to issue 1.5 of \cite{DS/FMU/IED/DTD051}.

\item[Issue 1.6, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.7]
Added $sets\_(e)pc$.
\item [Issue 1.8(11th March 1992)]
Various minor additions and extensions.
\item [Issue 1.9 (26th March 1992)]
Changed to use proof context material of issue 1.13 of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.10 (31st March 1992)]
Added understanding of double negation
to $≥\-\_rewrite\-\_canon$.
\item [Issue 1.11 (13th April 1992)]
Changes due to CR0017.
\item [Issue 1.12 (28th April 1992)]
Corrected documentation typo.
\item [Issue 1.13 (14th May 1992)]
Tidying up proof contexts.
\item [Issue 1.14 (27th May 1992)]
Added $all\_¬\_tac$.
\item [Issue 1.15 (5th July 1992)]
Added $step\_strip\_tac$ and $THEN1$.
\end{description}
% \subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
third grouping of tactics, in particular those concerning paired abstractions.
This is called for in \cite{DS/FMU/IED/HLD012}.
The design is
implemented in \cite{DS/FMU/IED/IMP029}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
third grouping of tactics, in particular those concerning paired abstractions.

The document provides groups of tactics, related by their core operator.

All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP029}.

We use the notation ``varstruct'' for ``an allowed variable structure, under ICL HOL syntax''.
\subsubsection{Dependencies}
Loading this document is dependent on \cite{DS/FMU/IED/IMP026}.
It is implemented in theory ``pair''.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{INFIX DIRECTIVES}
A Standard ML $infix$ directive must be given at the ``top level''.
Thus we give the directives here for those functions declared in the following signatures.
=SML
infix 4 THEN_T1;
infix 4 THEN1;
=TEX

\section{THE SIGNATURE}
=DOC
signature €Tactics3› = sig
=DESCRIBE
This provides a third group of tactics.
They are primarily concerned with adding handling for paired abstractions.
=ENDDOC
\section{TACTICS}
\subsection{Concerning Tautologies}
The following are all implemented using $simple\_taut\_tac$.
=DOC
val €taut_tac› : TACTIC;
=DESCRIBE
A tautology prover.
If the conclusion of the goal is a tautology then $taut\_tac$ will prove
the goal.
A tautology is taken to be any (perhaps universally quantified) substitution
instance of a term which is formed from boolean variables,
the constants $T$ and $F$ and the following
connectives:
=GFT
±, ≤, ¥, §, ≥, if ... then ... else
=TEX
and which is true for any assignment of truth values to the variables.
=FRULE 2 Tactic
taut_tac
˜
{ á } t
˜
=TEX
=SEEALSO
$strip\_tac$, $taut\_rule$, $taut\_conv$,
$simple\_taut\_tac$.
=FAILURE
29020	Conclusion of the goal is not a universally quantified tautology
=ENDDOC
=DOC
val €taut_rule› : TERM -> THM;
=DESCRIBE
A tautology prover.
A tautology is taken to be any universally quantified substitution
instance of a term which is formed from boolean variables,
the constants $T$ and $F$ and the following
connectives:
=GFT
±, ≤, ¥, §, ≥, if ... then ... else
=TEX
and which is true for any assignment of truth values to the variables.
If its argument is such a tautology then the
function will return that term as a theorem.
=FRULE 1 Rule
taut_rule
¨tÆ
˜
˜
Ù t
=TEX
=SEEALSO
$taut\_tac$, $taut\_conv$,
$simple\_taut\_tac$.
=FAILURE
27037	?0 is not tautologically true
=ENDDOC
This is not a conversion, but there are two conversions leading
from it:
=DOC
val €taut_conv› : CONV;
=DESCRIBE
A tautology prover.
A tautology is taken to be any universally quantified substitution
instance of a term which is formed from boolean variables,
the constants $T$ and $F$ and the following
connectives:
=GFT
±, ≤, ¥, §, ≥, if ... then ... else
=TEX
and which is true for any assignment of truth values to the variables.
If its argument is a tautologically true term, then the
function will return a theorem that the term is equivalent to $T$.
=FRULE 1 Conversion
taut_conv
¨tÆ
˜
˜
Ù t § T
=TEX
=SEEALSO
$taut\_tac$, $taut\_rule$,
$simple\_taut\_tac$.
=FAILURE
27037	?0 is not tautologically true
=ENDDOC
\subsection{Concerning ≥}
=DOC
val €≥_in_tac› : TACTIC;
=DESCRIBE
This is a tactic which moves negations inside other predicate calculus
connectives using the following rules:
=GFT
		≥≥t			≠	 t
		≥(t1 ± t2)		≠	 ≥t1 ≤ ≥t2
		≥(t1 ≤ t2)		≠	 ≥t1 ± ≥t2
		≥(t1 ¥ t2)		≠	 t1 ± ≥t2
		≥(t1 § t2)		≠	 (t1 ± ≥t2) ≤ (t2 ± ≥t1)
		≥µvs∑t			≠	 ∂vs∑≥t
		≥∂vs∑t			≠	 µvs∑≥t
		≥∂â1vs∑t	≠	 µvs∑≥(t ± µvs'∑t[vs'] ¥ vs' = vs)
		≥T			≠	 F
		≥F			≠	 T
=TEX
=USES
=SEEALSO
$simple\_≥\_in\_tac$, $≥\_in\_conv$
=FAILURE
28025	No applicable rule for this goal
=ENDDOC

=DOC
val €≥_IN_THEN› : THM_TACTICAL;
=DESCRIBE
This is a theorem tactical which applies a given 
theorem tactic to the result of transforming a theorem
by moving a top level negation inside other predicate calculus
connectives using the following rules:
=GFT
		≥≥t			≠	 t
		≥(t1 ± t2)		≠	 ≥t1 ≤ ≥t2
		≥(t1 ≤ t2)		≠	 ≥t1 ± ≥t2
		≥(t1 ¥ t2)		≠	 t1 ± ≥t2
		≥(t1 § t2)		≠	 (t1 ± ≥t2) ≤ (t2 ± ≥t1)
		≥µvs∑t			≠	 ∂vs∑≥t
		≥∂vs∑t			≠	 µvs∑≥t
		≥∂â1vs∑t	≠	 µvs∑≥(t ± µvs'∑t[vs'] ¥ vs' = vs)
		≥T			≠	 F
		≥F			≠	 T
=TEX
This function partially evaluates given only the theorem
and theorem-tactical.
=SEEALSO
$SIMPLE\_≥\_IN\_THEN$
=FAILURE
29010	No applicable rule for ?0
=ENDDOC
\subsection{Concerning ¥ and §}
=DOC
val €¥_thm_tac› : THM -> TACTIC;
=DESCRIBE
A tactic which uses a theorem whose conclusion is an
implication, $t1 ¥ t2$, to reduce a goal with conclusion $t2$
to $t1$.
=FRULE 2 Tactic
bc_thm_tac 
á1 Ù t1 ¥ t2
˜
{ á } t2
˜
{ á } t1
=TEX
=USES
Mainly for use in tactic programming where the extra generality
of
=INLINEFT
bc_thm_tac
=TEX
\ and
=INLINEFT
bc_tac
=TEX
\ is not required.
=SEEALSO
$bc\_thm\_tac$, $bc\_tac$.
=FAILURE
29013	Conclusion of the goal is not ?0
=ENDDOC
=DOC
val €back_chain_thm_tac› : THM -> TACTIC;
val €bc_thm_tac› : THM -> TACTIC;
=DESCRIBE
=INLINEFT
back_chain_thm_tac
=TEX
\ is a tactic which uses a theorem whose conclusion is a possibly
universally quantified implication or bi-implication to chain backwards
one step from the conclusion of a goal. (%
=INLINEFT
bc_thm_tac
=TEX
\ is an alias for
=INLINEFT
back_chain_thm_tac
=TEX
.)


=FRULE 2 Tactic
bc_thm_tac 
á1 Ù t1 ¥ t2
˜
{ á } t2'
˜
{ á } t1'
=TEX
=FRULE 2 Tactic
¥_tac 
á1 Ù t1 § t2
˜
{ á } t2'
˜
{ á } t1'
=TEX
where $t2'$ is an instance (under type instantiation and substitution)
of $t2$ and $t1'$ is the corresponding instance of $t1$.
If $t1'$ contains free variables which do not appear in
the assumptions of the instantiated theorem or in $t2'$, then the new subgoal
$t1'$ will be existentially quantified over these variables.

Note that, bi-implications are in effect treated as right-to-left rewrite
rules at the top level by this tactic. The standard rewriting
mechanisms may be used for left-to-right rewriting.

N.B. this tactic strengthens the goal, i.e. it may result in unprovable
subgoals even when the original goal was provable.
=SEEALSO
$back\_chain\_tac$ (which supplies a more general facility).
=FAILURE
29011	Conclusion of the goal is not an instance of: ?0
29012	Theorem ?0 is not of the form `á Ù µ x1 ... xn ∑ u § v`
	or `á Ù µ x1 ... xn ∑ u ¥ v`
=ENDDOC

=DOC
val €back_chain_tac› : THM list -> TACTIC;
val €bc_tac› : THM list -> TACTIC;
=DESCRIBE
=INLINEFT
back_chain_tac
=TEX
\ is a tactic which uses theorems whose conclusions are possibly
universally quantified implications or bi-implications, to reason
backwards from the conclusion of a goal.
(%
=INLINEFT
bc_tac
=TEX
\ is an alias for
=DESCRIBE
=INLINEFT
back_chain_tac
=TEX
.) The tactic
repeatedly performs the following steps:

\begin{enumerate}
\item
Scan the list of theorems looking for an implication,
=INLINEFT
t1 ¥ t2
=TEX
, or a bi-implication
=INLINEFT
t1 § t2
=TEX
\ for which the conclusion of the goal is a substitution instance, $t2'$
say, of $t2$. If no such theorem is found then stop.
\item
If in step 1, an applicable theorem, say $thm$, has been found reduce the goal to
the corresponding instance of $t1$ (or an existentially quantified version
thereof) using
=INLINEFT
bc\_thm\_tac
=TEX
\item
Repeatedly apply
=INLINEFT
µ_tac
=TEX
\ or
=INLINEFT
±_tac
=TEX
\ until neither of these is applicable.
\item
Delete $thm$ from the list of theorems and return to step 1.
\end{enumerate}

In step 4, only the first appearance of $thm$ is removed from the list,
so that one can arrange for a theorem to be used more than once by the
tactic by putting several copies of it in the list. 

For example:  
=FRULE 2 Example
¥_tac 
[á1 Ù t1 ± (µx∑t2) ¥ t3,
á2 Ù t4 § t1,
á3 Ù t5 ¥ t2,
˜
{ á } t3'
˜
{ á } t4'; { á } t5'
=TEX

(Here $t3'$ is some substitution instance of $t3$ and $t4'$ and $t5'$ are the
corresponding instances of $t4$ and $t5$.)

N.B. this tactic strengthens the goal, i.e. it may result in unprovable
subgoals even when the original goal was provable.
=SEEALSO
$bc\_thm\_tac$ (which is used to perform step 2).
=FAILURE
29012	Theorem ?0 is not of the form `á Ù µ x1 ... xn ∑ u § v`
	or `á Ù µ x1 ... xn ∑ u ¥ v`
=ENDDOC

=DOC
val €forward_chain_tac› : THM list -> TACTIC;
val €fc_tac› : THM list -> TACTIC;
val €asm_forward_chain_tac› : THM list -> TACTIC;
val €asm_fc_tac› : THM list -> TACTIC;
=DESCRIBE
These are tactics which use theorems whose conclusions are
implications, or from which implications can be derived using
the canonicalisation function
=INLINEFT
fc_rule
=TEX
\ (see below), to reason forwards from the assumptions of a goal. (The names
with
=INLINEFT
fc
=TEX
\ are aliases for the corresponding ones with
=INLINEFT
forward_chain
=TEX
.)

The basic step is to take a theorem of the form
=INLINEFT
á Ù t1 ¥ t2
=TEX
\ and an assumption of the form
=INLINEFT
t1'
=TEX
\ where $t1'$ is a substitution instance of $t1$ and to deduce the
corresponding instance of $t2'$. The new theorem,
=INLINEFT
Ñ Ù t2'
=TEX
\ say, is then stripped into the assumptions. (In fact, to make the
tactic more powerful
=INLINEFT
t2'
=TEX
\ is universally quantified over all its free variables which are not
also free in
=INLINEFT
Ñ
=TEX
.)


In the case of
=INLINEFT
fc_tac
=TEX
\ the implicative theorem is always derived from the list
of theorems given as an argument.
In the case of
=INLINEFT
asm_fc_tac
=TEX
\ the assumptions are also used.
In both cases the rule 
=INLINEFT
fc_rule
=TEX
(q.v.) is used to derive an implicative canonical form from the
candidate implicative theorems.
Each combination of an implicative theorem and an assumption
is then tried in turn and all resulting theorems are stripped into
the assumptions of the goal.


In order to give some control over the number of results generated,
variables which appear free in a theorem are not considered as candidates
for instantiation.

=SEEALSO
$back\_chain\_tac$.
=ENDDOC


=DOC
val €FORWARD_CHAIN_T› :
	(THM list -> TACTIC) -> THM list -> TACTIC;
val €FC_T› :
	(THM list -> TACTIC) -> THM list -> TACTIC;
val €ASM_FORWARD_CHAIN_T› :
	(THM list -> TACTIC) -> THM list -> TACTIC;
val €ASM_FC_T› :
	(THM list -> TACTIC) -> THM list -> TACTIC;

val €FORWARD_CHAIN_T1› :
	(THM -> THM list) -> (THM list -> TACTIC) -> THM list -> TACTIC;
val €FC_T1› :
	(THM -> THM list) -> (THM list -> TACTIC) -> THM list -> TACTIC;
val €ASM_FORWARD_CHAIN_T1› : 
	(THM -> THM list) -> (THM list -> TACTIC) -> THM list -> TACTIC;
val €ASM_FC_T1› : 
	(THM -> THM list) -> (THM list -> TACTIC) -> THM list -> TACTIC;
=DESCRIBE
These are tacticals which use theorems whose conclusions are
implications, or from which implications can be derived,
to reason forwards from the assumptions of a goal.
(The tacticals with
=INLINEFT
FC
=TEX
\ are aliases for the corresponding ones with
=INLINEFT
FORWARD_CHAIN
=TEX
.)

The description of 
=INLINEFT
fc_tac
=TEX
\ should be consulted for the basic forward chaining algorithm used.
The significance of the final argument and of the presence or absence of
=INLINEFT
ASM
=TEX
\ in the name is exactly as for
=INLINEFT
fc_tac
=TEX
\ and
=INLINEFT
asm_fc_tac
=TEX
.

The tacticals with names ending in
=INLINEFT
T1
=TEX
\ allow variation of the canonicalisation function
used to obtain implications from the argument theorems and of
the tactic generating function used to process the theorems derived
by the forward inference.
The canonicalisation function to use is the first argument
and the tactic generating function is the second.
The tacticals with names ending in
=INLINEFT
T
=TEX
\ use the same canonicalisation function as
=INLINEFT
fc_tac
=TEX
\ and just allow the tactic generating function to be given as the first
argument.

\paragraph{Examples}
=INLINEFT
fc_tac
=TEX
\ is the same as:
=INLINEFT
FC_T (MAP_EVERY strip_asm_tac)
=TEX
.

To rewrite the goal with the results of the forward inference one
could use
=INLINEFT
FC_T rewrite_tac
=TEX
.

If the theorem argument comprises only implications
which are to be used without canonicalisation, one might use:
=INLINEFT
FC_T1 (fn th => [th]) (MAP_EVERY strip_asm_tac)
=TEX

=SEEALSO
$fc\_tac$, $asm\_fc\_tac$, $bc\_tac$.
=ENDDOC
\subsection{Concerning µ}
=DOC
val €µ_tac› : TACTIC;
=DESCRIBE
Reduce a universally quantified goal.
=FRULE 2 Tactic
µ_tac
˜
{ á } µ vs[x1,...] ∑ t[x1,...]
˜
{ á } t[x1',...]
=TEX
where $x1'$ is a variant name of $x1$, etc, different from any 
variable in $á$ or $t$.
=SEEALSO
$simple\_µ\_tac$
=FAILURE
29001	Goal is not of the form: { á } µ vs ∑ t[vs]
=ENDDOC

\subsection{Concerning ∂}

=DOC
val €∂_tac› : TERM -> TACTIC ;
=DESCRIBE
Provide a witness for an existential subgoal.

N.B. this tactic strengthens the goal, i.e. it may result in unprovable
subgoals even when the original goal was provable.
=FRULE 2 Tactic
∂_tac
¨tÆ
˜
{ á } ∂ vs[x1,...] ∑ t2[x1,...]
˜
{ á } t2[t1',...]
=TEX
where $vs[t_1,...]$ is $t$, type instantiated to have the same type as $vs[x1,...]$, and broken up using
$Fst$ and $Snd$ as necessary.
=SEEALSO
$simple\_∂\_tac$
=FAILURE
29002	Goal is not of the form: { á } ∂ vs ∑ t2[vs]
29008	Cannot match witness ?0 to varstruct ?1
=ENDDOC
=DOC
val €∂_THEN› : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical which applies a given theorem tactic to the result
of eliminating the outermost quantifier from a theorem of the form
$á Ù ∂vs∑t$.
=GFT
∂_THEN thmtac (á Ù ∂vs[x1,...]∑t) = thmtac (á Ù t[x1'/x1,...])
=TEX
where ¨x1'Æ is a variant of ¨x1Æ , etc, which does not appear in $á$ or in
the assumption or conclusion of the goal.
=SEEALSO
$SIMPLE\_∂\_THEN$
=FAILURE
29003	?0 is not of the form: `á Ù ∂ vs ∑ t`
=ENDDOC

\subsection{Concerning ∂$_1$}

=DOC
val €∂â1_tac› : TERM -> TACTIC;
=DESCRIBE
Provide a witness for a goal with conclusion of the form
=INLINEFT
∂â1x∑t
=TEX
.

N.B. this tactic strengthens the goal, i.e. it may result in unprovable
subgoals even when the original goal was provable.
=FRULE 2 Tactic
∂â1_tac1
¨tÆ
˜
{ á } ∂â1 vs[x1,...] ∑ P[x1,...]
˜
{ á } P[t1',...];
{ á } µvs[x1',...]∑ 
	P[x1',...] ¥ vs[x1',...] = t'
=TEX
where $x_i'$ is a variant of $x_i$ which does not occur free in $t$,
$t'$ is equal to $t$ type instantiated to the type of $vs[x1,...]$,
and $vs[t1',...]$ equals $t'$ (perhaps using $Fst$ and $Snd$).
=FAILURE
29004	Goal is not of the form: { á } ∂â1 vs ∑ t
29008	Cannot match witness ?0 to varstruct ?1
=ENDDOC
=DOC
val €∂â1_THEN› : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical which applies a given theorem tactic to the result
of eliminating the outermost quantifier from a theorem of the form
$á Ù ∂_1vs∑t$.
=GFT
∂â1_THEN thmtac (á Ù ∂â1vs[x1,...]∑t) = 
	thmtac (á Ù t[x1'/x1,...] ± 
		µvs[x1'',...]∑P[x1'',...] ¥ vs[x1'',...] = vs[x1',...])
=TEX
where ¨x1'Æ and ¨x1''Æ are distinct variants of ¨x1Æ, etc, which do not appear free in $á$ or in
the assumptions or conclusion of the goal.
=FAILURE
29005	?0 is not of the form: `á Ù ∂â1 vs ∑ t`
=ENDDOC
\subsection{Concerning Ã}
=DOC
val €all_¬_tac› : TACTIC;
=DESCRIBE
This tactic will $¬$-reduce all $¬$-redexes in the goal's
conclusion,
including
those redexes introduced by preceding $¬$-reductions
in the same tactic application.
=USES
In most proof contexts $¬$-reduction will be a side effect
of rewriting: this tactic is intended for cases where
rewriting would do ``too much''.
=SEEALSO
$all\_¬\_rule$, $all\_¬\_conv$
=FAILURE
27049	?0 contains no ¬-redexes
=ENDDOC
\subsection{Concerning Assumptions}
=DOC
val €spec_asm_tac› : TERM -> TERM -> TACTIC;
val €list_spec_asm_tac› : TERM -> TERM list -> TACTIC;
val €spec_nth_asm_tac› : int -> TERM -> TACTIC;
val €list_spec_nth_asm_tac› : int -> TERM list -> TACTIC;
=DESCRIBE
These are four methods of specialising asssumptions,
differing by single or lists of values to specialise to,
and in the method of selection of the assumption.
All of them leave the old assumption in place, and place the
 instantiated asssumption onto the assumption list using $strip\_asm\_tac$.
If the desired behaviour differs from any of those supplied
then use $GET\_ASM\_T$ and its cousins to create the desired functionality.
=FRULE 2 Tactic
spec_asm_tac
¨µ vs[x1,...] ∑ f [x1,...]Æ
¨tmÆ
˜
{ á, ¨µ vs[x1',...] ∑ f [x1',...]Æ } t
˜
{strip ¨f [t1,...]Æ, á,
¨µ vs[x1,...] ∑ f [x1,...]Æ} t1
=TEX
The following all handle paired abstractions in a similar
manner.
=FRULE 2 Tactic
list_spec_asm_tac
¨µ x1 ... ∑ f [x1,...]Æ
[¨t1Æ,¨t2Æ,...]
˜
{ á, ¨µ x1 ... ∑ f [x1,...]Æ } t
˜
{strip ¨f [t1,...]Æ, á,
¨µ x1 x2 ... ∑ f [x1,...]Æ,
} t
=TEX
=FRULE 2 Tactic
spec_nth_asm_tac
n
¨t2Æ
˜
{ á1...n-1, ¨µ x' ∑ f [x']Æ, á} t1
˜
{strip ¨f [t2]Æ,  á1...n-1,
¨µ x' ∑ f [x']Æ,
á} t1
=TEX
=FRULE 2 Tactic
list_spec_nth_asm_tac
n
[¨t1Æ,...]
˜
{ á1...n-1, ¨µ x1 ...∑ f [x1,...]Æ, á} t
˜
{strip ¨f [t1,...]Æ, á1...n-1,
¨µ x1 ...∑ f [x1,...]Æ, 
á} t
=TEX
=FAILUREC
\paragraph{Errors}
As the constituents of the implementing functions
(e.g. $GET\_ASM\_T$ and $µ\_elim$).
=ENDDOC
=DOC
val €SPEC_ASM_T› : TERM -> TERM -> (THM -> TACTIC) -> TACTIC;
val €LIST_SPEC_ASM_T› : TERM -> TERM list -> (THM -> TACTIC) 
	-> TACTIC;
val €SPEC_NTH_ASM_T› : int -> TERM -> (THM -> TACTIC) -> TACTIC;
val €LIST_SPEC_NTH_ASM_T› : int -> TERM list -> (THM -> TACTIC) 
	-> TACTIC;
=DESCRIBE
These are four methods of specialising asssumptions,
differing by single or lists of values to specialise to,
and in the method of selection of the assumption.
All of them leave the old assumption in place, and place the
 instantiated asssumption onto the assumption list using 
their theorem tactic.
=FRULE 2 Tactic
SPEC_ASM_T
¨µ vs[x1,...] ∑ f [x1,...]Æ
¨tmÆ
thm_tac
˜
{ á, ¨µ vs[x1',...] ∑ f [x1',...]Æ } t
˜
thm_tac (asm_rule ¨f [t1,...]Æ)
{á,¨µ vs[x1,...] ∑ f [x1,...]Æ} t1
=TEX
The following all handle paired abstractions in a similar
manner.
=FRULE 2 Tactic
LIST_SPEC_ASM_T
¨µ x1 x2 ... ∑ f [x1,x2,...]Æ
[¨t1Æ,¨t2Æ,...]
thm_tac
˜
{ á, ¨µ x1 x2 ... ∑ f [x1,x2,...]Æ } t
˜
thm_tac (asm_rule ¨f [t1,t2,...]Æ)
{á,¨µ x1 x2 ... ∑ f [x1,x2,...]Æ} t
=TEX
=FRULE 2 Tactic
SPEC_NTH_ASM_T
n
¨t2Æ
thm_tac
˜
{ á1...n-1, ¨µ x' ∑ f [x']Æ, á} t1
˜
thm_tac (asm_rule ¨f [t2]Æ)
{á1...n-1,¨µ x' ∑ f [x']Æ,á} t1
=TEX
=FRULE 2 Tactic
LIST_SPEC_NTH_ASM_T
n
[¨t1Æ,...]
thm_tac
˜
{ á1...n-1, ¨µ x1 ...∑ f [x1,...]Æ, á} t
˜
thm_tac (asm_rule ¨f [t1,...]Æ)
{á1...n-1,¨µ x1 ...∑ f [x1,...]Æ, á} 
t
=TEX
=FAILUREC
\paragraph{Errors}
As the constituents of the implementing functions
(e.g. $GET\_ASM\_T$ and $µ\_elim$).
=ENDDOC
\subsection{Concerning Stripping}
=DOC
val €step_strip_tac› : TACTIC;
val €step_strip_asm_tac› : THM -> TACTIC;
=DESCRIBE
These functions provide methods of single-stepping through the application of $strip\-\_tac$ and $strip\-\_asm\-\_tac$ (q.v.).

When stripping the antecedent of an implication ,or a theorem, into the assumption list $strip\-\_tac$ and $strip\-\_asm\-\_tac$ respectively do all their stripping in one application of the tactic.
This is not appropriate behaviour when:
\begin{enumerate}
\item
Explaining the detailed behaviour of these functions by example
applications.
\item
Attempting to ``debug'' a failed or inappropriate stripping.
\item
When a partial strip into the assumption list is desired.
\end{enumerate}
The two functions provided give a single-step stripping of antecendents and theorems.
They represent sets of objects that are partially stripped into
the assumption list by making the conclusion of the resulting goal an implication with the antecendent being the conjunction of the
partially stripped objects and the consequent being the unstripped part of the goal.
Repeated use of the provided functions closely corresponds to the processing order and effect of $strip\-\_tac$ and $strip\-\_asm\-\_tac$.
Under certain unusual circumstances the match may not be exact.
=EXAMPLE
Ù? ((a ≤ b) ± c) ¥ ((a ± c) ≤ (b ± c)) 
Single steps to:
Ù? (a ± c) ¥ ((a ± c) ≤ (b ± c))
and Ù? (b ± c) ¥ ((a ± c) ≤ (b ± c))
Each single step to:
a Ù? c ¥ ((a ± c) ≤ (b ± c))
and b Ù? c ¥ ((a ± c) ≤ (b ± c))
Each single step to:
a, c Ù? ¥ ((a ± c) ≤ (b ± c))
and b, c Ù? ¥ ((a ± c) ≤ (b ± c))
=TEX
These five steps (two on each branch) map onto one call of
$strip\_tac$.
=FAILURE
28003	There is no stripping technique for ?0 in the current proof context
=ENDDOC
Some ``ununusual circumstances'' when the above do not correspond to  $strip\-\_tac$ and $strip\-\_asm\-\_tac$ are:
\begin{enumerate}
\item
If a conversion in the proof context for stripping theorems
is applicable to conjuncts then it might not be applied in the single stripping case.
\item
If a conversion in the proof context has side effects these might interfere with the main goal, etc, in different manners, though the
order of occurrence of the side effects should normally be the same.
\item
Some of the processing that a single call of $strip\_tac$ would do before
determing that a subgoal has been proved may not 
occur in the single-step case,
due to the single step functions being unable to distinguish
whether certain conclusions were formed from partially
stripped objects, or were part of the original goal.
This only affects the amount of processing, not the equivalence of the result.
\end{enumerate}
\subsection{Concerning Induction}
=DOC
val GEN_INDUCTION_T : THM -> (THM -> TACTIC) -> TERM -> TACTIC;
val gen_induction_tac : THM -> TERM -> TACTIC;
=DESCRIBE
These give general means for constructing an induction tactic from
an induction principle formulated as a theorem.
The term argument is the induction variable, which must be free in
the conclusion of the goal to which the tactic is applied but not
in the assumptions.

=INLINEFT
GEN_INDUCTION_T
=TEX
\ causes any inductive hypotheses (see below) to be passed to
a tactic generating function.

=INLINEFT
gen_induction_tac thm
=TEX
\ is the same as
=INLINEFT
GEN_INDUCTION_T thm strip_asm_tac
=TEX
.

The discussion below is for the tactic computed by the call
=INLINEFT
GEN_INDUCTION_T thm ttac y
=TEX
\ applied to a goal with conclusion
=INLINEFT
t
=TEX
.

The induction principle, $thm$ has the form:
=GFT
Ù µp∑a ¥ µx∑p x
=TEX
E.g.
=GFT
Ù µ p∑ p 0 ± (µ m∑ p m ¥ p (m + 1)) ¥ (µ n∑ p n)
=TEX

The induction tactic takes the following steps:

\begin{enumerate}
\item
Use µ-elimination on $thm$, (with the TERM
=INLINEFT
Ãy∑t
=TEX
) and ¬-reduction to give an implicative theorem,
=INLINEFT
Ù a' ¥ t
=TEX
\  and use it to reduce the goal to a subgoal with conclusion
=INLINEFT
a'
=TEX
.\item
Repeatedly apply
=INLINEFT
±_tac
=TEX
\ and then repeatedly apply
=INLINEFT
µ_tac
=TEX
.
\item
To any of the resulting subgoals whose principal connective comes from
an implication in $thm$ apply
=INLINEFT
¥_T ttac
=TEX
.
\end{enumerate}
The tactic also renames bound variables so that names which begin
with the name of the variable in the theorem now begin
with the name of the induction variable passed to the tactic.
=FAILURE
29021	?0 does not have the form `Ù µp∑a ¥ µx∑p x` (where assumptions
	are not allowed)
29023	The type of ?0 is not an instance of ?1
29024	?0 is not a variable
29025	?0 appears free in the assumptions of the goal
29026	?0 does not appear free in the conclusion of the goal
=ENDDOC

=DOC
val GEN_INDUCTION_T1 : THM -> (THM -> TACTIC) -> TACTIC;
val gen_induction_tac1 : THM -> TACTIC;
=DESCRIBE
These give a means for constructing an induction tactic from
an induction principle formulated as a theorem, in cases where the
induction variable can be inferred from the form of the theorem
and the goal. They are in other respects very like
=INLINEFT
GEN_INDUCTION_T
=TEX
\ and
=INLINEFT
gen_induction_tac thm
=TEX
, q.v.

The induction theorem must be a theorem of the form:
=GFT
Ù µp∑a ¥ µx∑t[p x/b]
=TEX
Where $t$ contains at least one occurrence of $x$.
For example,
=GFT
Ù µ p ∑ p {} ± (µ a x∑ a ç Finite ± p a ± ≥ x ç a ¥ p ({x} ¿ a))
      ¥ (µ a∑ a ç Finite ¥ p a)
=TEX
(for which $t$ is
=INLINEFT
a ç Finite ¥ b
=TEX
).

The induction tactic matches the conclusion, $c$, of the goal with $t$,
uses the result to derive a theorem
of the form
=INLINEFT
Ù a' ¥ c
=TEX
\ and then proceeds exactly like the corresponding induction tactic produced
by
=INLINEFT
GEN_INDUCTION_T
=TEX
\ and
=INLINEFT
gen_induction_tac thm
=TEX
\, q.v.

=FAILURE
29007	?0 does not have the form `Ùµp:‘≠BOOL∑a ¥ µx∑t[p x/b]`
	(where ¨xÆ must also appear in ¨tÆ other than as an argument of ¨pÆ)
29009	The conclusion of the goal cannot be rewritten in the form `?0 t`
29014	The term `?0` which matches the induction variable is not a variable
=ENDDOC
\section{TACTICALS}
=DOC
val €THEN_T1› : (TACTIC * TACTIC) -> TACTIC;
val €THEN1› : (TACTIC * TACTIC) -> TACTIC;
=DESCRIBE
$THEN\_T1$ is a tactical used as an infix operator.
$tac1$ $THEN\_T1$ $tac2$ is the tactic that applies $tac1$
and then applies $tac2$ to the first of the resulting subgoals
and $id\_tac$ to any other subgoals.
If $tac1$ returns no subgoals, then nor will $tac1$ $THEN\_T1$ $tac2$.
$THEN1$ is an alias for $THEN\_T1$.

It is intended for use in conjunction with induction tactics or
tactics like $lemma\_tac$ for which the first subgoal (i.e., the base
case of the induction or the lemma) often has a simple proof.
=SEEALSO
$THEN$
=FAILUREC
\paragraph{Errors}
As the errors of $tac1$ and $tac2$.
=ENDDOC

\section{CONVERSIONS}
=DOC
val €≥_in_conv› : CONV;
=DESCRIBE
This is a conversion which moves negations inside other predicate
calculus connectives using whichever of the following rules applies:
=GFT
		≥≥t			=	 t
		≥(t1 ± t2)		=	 ≥t1 ≤ ≥t2
		≥(t1 ≤ t2)		=	 ≥t1 ± ≥t2
		≥(t1 ¥ t2)		=	 t1 ± ≥t2
		≥(t1 § t2)		=	 (t1 ± ≥t2) ≤ (t2 ± ≥t1)
		≥(if a then t1 else t2)
					=	 (if a then ≥t1 else ≥t2)
		≥µvs∑t			=	 ∂vs∑≥t
		≥∂vs∑t			=	 µvs∑≥t
		≥∂â1vs∑t	=	 µvs∑≥(t ± µvs'∑t[vs'] ¥ vs' = vs)
		≥T			=	 F
		≥F			=	 T
=TEX
=USES
Tactic and conversion programming.
=SEEALSO
$simple\_≥\_in\_conv$, $≥\_in\_tac$
=FAILURE
28131	No applicable rules for the term ?0
=ENDDOC
\section{CANONICALISATION}
=DOC
val €≥_rewrite_canon› : THM -> THM list
val €µ_rewrite_canon› : THM -> THM list
=DESCRIBE
These are some of the standard canonicalisation functions used for breaking theorems up into
lists of equations for use in rewriting. They four perform the following
transformations:
=GFT
≥_rewrite_canon		(á Ù ≥(t1 ≤ t2))	= (á Ù ≥t1 ± ≥t2)	
≥_rewrite_canon		(á Ù ≥∂vs∑t)		= (á Ù µvs∑≥t)	
≥_rewrite_canon		(á Ù ≥≥t)		= (á Ù t)	
≥_rewrite_canon		(á Ù ≥t)		= (á Ù t § F)	
µ_rewrite_canon		(á Ù µvs∑t)		= á Ù t
=TEX

=SEEALSO
$simple\_≥\_rewrite\_canon$, $simple\_µ\_rewrite\_canon$.
=FAILURE
26201	Failed as requested
=FAILUREC
The area given by the failure will be $fail\_canon$.
=ENDDOC

=DOC
val €pair_rw_canon› : CANON;
=DESCRIBE
This is the rewrite canonicalisation function for the theory of pairs,
defined as
=GFT
val pair_rw_canon =
	REWRITE_CAN
	(REPEAT_CAN(FIRST_CAN [
	µ_rewrite_canon,
	±_rewrite_canon,
	≥_rewrite_canon,
	f_rewrite_canon,
	§_t_rewrite_canon]));
=TEX
This is the repeated application of the first applicable
operation in the following list:
\begin{enumerate}
\item
stripping universal quantifiers (paired or simple);
\item
dividing conjunctive theorems into their conjuncts;
\item
changing $Ù≥(t1 ≤ t2)$ to $≥t1 ± ≥t2$;
\item
changing $Ù≥∂vs∑t$ to $µvs∑≥t$;
\item
changing $Ù≥≥t$ to $t § F$;
\item
changing $Ù≥t$ to $t § F$;
\item
if none of the above apply, changing $Ùt$ to $Ùt § T$.
\end{enumerate}

Finally, after all this canonicalisation we then universally quantify
the resulting theorems in all free variables other than those
that were free in the original.
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of Tactics3 *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

=IGN
open Sort;
fun sf {id = id1,text = text1} {id = id2,text = text2} = (
	if text1 <> text2
	then string_order text1 text2
	else (id1 - id2)
);

sort sf (get_error_messages());


set_goal([], ¨
µp∑p{} ± (µx∑p{x}) ± (µa1 a2∑a1 ç Finite ± a2 ç Finite ± p a1 ± p a2 ¥ p (a1 ¿ a2))
	¥ (µa∑a ç Finite ¥ p a)
Æ);
a(REPEAT_N 3 strip_tac);
a(fin_set_induction_tac);
a(strip_tac);
a(asm_fc_tac[]);
a(once_rewrite_tac[pc_rule1"hol1"prove_rule[]¨µa b∑a ¿ b = b ¿ aÆ]);
a(strip_asm_tac(rewrite_rule[](fc_rule[fin_set_thm3][fin_set_thm2])));
a(strip_asm_tac(rewrite_rule[](hd(fc_rule[fin_set_thm3][fin_set_thm2]))));
a(asm_fc_tac[] THEN asm_fc_tac[]);
pop_thm();
