% dtd029.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design of Tactics III}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Tactics III}
\TPPref{DS/FMU/IED/DTD029}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the third grouping of tactics,
in particular those concerned with paired abstractions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version: place holder for tautology stuff.
\item [Issue 1.2]
Added some more odds and ends.
\item [Issue 1.3]
Attempting a ``complete'' design.
\end{description}
% \subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
third grouping of tactics, in particular those concerning paired abstractions.
This is called for in \cite{DS/FMU/IED/HLD012}.
The design is
implemented in \cite{DS/FMU/IED/IMP029}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
third grouping of tactics, in particular those concerning paired abstractions.

The document provides groups of tactics, related by their core operator.

All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP029}.

We use the notation ``varstruct'' for ``an allowed variable structure, under ICL HOL syntax''.
\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.

\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.

\section{THE SIGNATURE}
=DOC
signature ‚TacticsIII· = sig
=DESCRIBE
This provides the grouping of tactics for ICL HOL.
They are primarily concerned with adding handling for paired abstractions.
=ENDDOC
\subsection{Concerning Tautologies}
The following are all implemented using $taut\_tac$.
=DOC
val ‚taut_rule· : TERM -> THM;
=DESCRIBE
A tautology prover.
A tautology is taken to be any substitution
instance of a term which is formed from boolean variables,
the constants $T$ and $F$ and the following
connectives:
Û
Ä, Å, ä, Ç, å, if ... then ... else
Ê
and which is true for any assignment of truth values to the variables.
If its argument is a tautology then the
function will return that term as a theorem.
=RULE
taut_rule
ªtº
…
…
Ö t
=TEX
=SEEALSO
$taut\_tac$, $taut\_conv$, $taut\_eq\_conv$.
=FAILURE
27037	?0 is not tautologically true
=ENDDOC
This is not a conversion, but there are two conversions leading
from it:
=DOC
val ‚taut_conv· : CONV;
=DESCRIBE
A tautology prover.
A tautology is taken to be any substitution
instance of a term which is formed from boolean variables,
the constants $T$ and $F$ and the following
connectives:
Û
Ä, Å, ä, Ç, å, if ... then ... else
Ê
and which is true for any assignment of truth values to the variables.
If its argument is a tautologically true term, then the
function will return a theorem that the term is equivalent to $T$.
=CONVERSION
taut_conv
ªtº
…
…
Ö t Ç T
=TEX
=SEEALSO
$taut\_tac$, $taut\_rule$, $taut\_eq\_conv$.
=FAILURE
27037	?0 is not tautologically true
=ENDDOC
=DOC
val ‚taut_eq_conv· : TERM -> CONV;
=DESCRIBE
A tautology prover.
A tautology is taken to be any substitution
instance of a term which is formed from boolean variables,
the constants $T$ and $F$ and the following
connectives:
Û
Ä, Å, ä, Ç, å, if ... then ... else
Ê
and which is true for any assignment of truth values to the variables.
If its two boolean arguments are tautologically equal terms, then the
function will return a theorem that the terms are equal.
=CONVERSION
taut_eq_conv
ªt1º
ªt2º
…
…
Ö t2 Ç t1
=TEX
=SEEALSO
$taut\_tac$, $taut\_rule$, $taut\_conv$.
=FAILURE
27015	Cannot prove the tautological equivalence of ?0 and ?1
=ENDDOC
Should this be $taut\_Ç\_conv$?
\subsection{Concerning å}
=DOC
val ‚å_in_tac· : TACTIC;
=DESCRIBE
This is a tactic which moves negations inside other predicate calculus
connectives using the following rules:
Û
		ååt			ã	 t
		å(t1 Ä t2)		ã	 åt1 Å åt2
		å(t1 Å t2)		ã	 åt1 Ä åt2
		å(t1 ä t2)		ã	 t1 Ä åt2
		å(t1 Ç t2)		ã	 (t1 Ä åt2) Å (t2 Ä åt1)
		åÉvsét			ã	 Ñvséåt
		åÑvsét			ã	 Évséåt
		åÑ%down%1vsét	ã	 Évséå(t Ä Évs'ét[vs'] ä vs' = vs)
		åT			ã	 F
		åF			ã	 T
Ê
=USES
=SEEALSO
$simple\_å\_in\_tac$, $å\_in\_conv$
=FAILURE
28025	No applicable rule for this goal
=ENDDOC

=DOC
val ‚å_IN_THEN· : THM_TACTICAL;
=DESCRIBE
This is a theorem tactical which applies a given 
theorem tactic to the result of transforming a theorem
by moving a top level negation inside other predicate calculus
connectives using the following rules:
Û
		ååt			ã	 t
		å(t1 Ä t2)		ã	 åt1 Å åt2
		å(t1 Å t2)		ã	 åt1 Ä åt2
		å(t1 ä t2)		ã	 t1 Ä åt2
		å(t1 Ç t2)		ã	 (t1 Ä åt2) Å (t2 Ä åt1)
		åÉvsét			ã	 Ñvséåt
		åÑvsét			ã	 Évséåt
		åÑ%down%1vsét	ã	 Évséå(t Ä Évs'ét[vs'] ä vs' = vs)
		åT			ã	 F
		åF			ã	 T
Ê
This function partially evaluates given only the theorem
and theorem-tactical.
=SEEALSO
$SIMPLE\_å\_IN\_THEN$
=FAILURE
29010	No applicable rule for ?0
=ENDDOC
\subsection{Concerning É}
=DOC
val ‚É_tac· : TACTIC;
=DESCRIBE
Reduce a universally quantified goal.
=TACTIC
É_tac
…
{ ˆ } É vs[x1,...] é t[x1,...]
…
{ ˆ } t[x1',...]
=TEX
where $x1'$ is a variant name of $x1$, etc, different from any 
variable in $ˆ$ or $t$.
=SEEALSO
$simple\_É\_tac$
=FAILURE
29001	Goal is not of the form: { ˆ } É vs é t[vs]
=ENDDOC

\subsection{Concerning Ñ}

=DOC
val ‚Ñ_tac· : TERM -> TACTIC ;
=DESCRIBE
Provide a witness for an existential subgoal.

N.B. loses information.
=TACTIC
Ñ_tac
ªtº
…
{ ˆ } Ñ vs[x1,...] é t2[x1,...]
…
{ ˆ } t2[t1',...]
=TEX
where $vs[t_1,...]$ is $t$, type instantiated to have the same type as $vs[x1,...]$, and broken up using
$Fst$ and $Snd$ as necessary.
=SEEALSO
$simple\_Ñ\_tac$
=FAILURE
29002	Goal is not of the form: { ˆ } Ñ vs é t2[vs]
29008	Cannot match witness ?0 to varstruct ?1
=ENDDOC
=DOC
val ‚Ñ_THEN· : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical which applies a given theorem tactic to the result
of eliminating the outermost quantifier from a theorem of the form
$ˆ Ö Ñvsét$.
Û
Ñ_THEN thmtac (ˆ Ö Ñvs[x1,...]ét) = thmtac (ˆ Ö t[x1'/x1,...])
Ê
where ªx1'º is a variant of ªx1º , etc, which does not appear in $ˆ$ or in
the assumption or conclusion of the goal.
=SEEALSO
$SIMPLE\_Ñ\_THEN$
=FAILURE
29003	?0 is not of the form: `ˆ Ö Ñ vs é t`
=ENDDOC

\subsection{Concerning Ñ$_1$}

=DOC
val ‚Ñ%down%1_tac· : TERM -> TACTIC;
=DESCRIBE
Simplify a unique existentially quantified goal with a particular
witness.

N.B. loses information.
=TACTIC
Ñ%down%1_tac1
ªtº
…
{ ˆ } Ñ%down%1 vs[x1,...] é P[x1,...]
…
{ ˆ } P[t1',...];
{ ˆ } Évs[x1',...]é P[x1',...] ä vs[x1',...] = t'
=TEX
where $x_i'$ is a variant of $x_i$ which does not occur free in $t$,
$t'$ is equal to $t$ type instantiated to the type of $vs[x1,...]$,
and $vs[t1',...]$ equals $t'$ (perhaps using $Fst$ and $Snd$).
=FAILURE
29004	Goal is not of the form: { ˆ } Ñ%down%1 vs é t
29008	Cannot match witness ?0 to varstruct ?1
=ENDDOC
=DOC
val ‚Ñ%down%1_THEN· : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical which applies a given theorem tactic to the result
of eliminating the outermost quantifier from a theorem of the form
$ˆ Ö Ñ_1vsét$.
Û
Ñ%down%1_THEN thmtac (ˆ Ö Ñ%down%1vs[x1,...]ét) = 
	thmtac (ˆ Ö t[x1'/x1,...] Ä 
		Évs[x1'',...]éP[x1'',...] ä vs[x1'',...] = vs[x1',...])
Ê
where ªx1'º and ªx1''º are distinct variants of ªx1º, etc, which do not appear free in $ˆ$ or in
the assumptions or conclusion of the goal.
=FAILURE
29005	?0 is not of the form: `ˆ Ö Ñ%down%1 vs é t`
=ENDDOC

\subsection{Concerning Assumptions}
=DOC
val ‚spec_asm_tac· : TERM -> TERM -> TACTIC;
val ‚list_spec_asm_tac· : TERM -> TERM list -> TACTIC;
val ‚spec_nth_asm_tac· : int -> TERM -> TACTIC;
val ‚list_spec_nth_asm_tac· : int -> TERM list -> TACTIC;
=DESCRIBE
These are four methods of specialising asssumptions,
differing by single or lists of values to specialise to,
and in the method of selection of the assumption.
All of them discard the old assumption, and place the
result onto the assumption list using $strip\_asm\_tac$.
If the desired behaviour differs from any of those supplied
then use $GET\_ASM\_T$ and its cousins.
=TACTIC
spec_asm_tac
ªÉ vs[x1,...] é f [x1,...]º
ªtmº
…
{ ˆ, ªÉ vs[x1',...] é f [x1',...]º } t
…
{strip ªf [t1,...]º, ˆ} t1
=TEX
The following all handle paired abstractions in a similar
manner.
=TACTIC
list_spec_asm_tac
ªÉ x1 x2 ... é f [x1,x2,...]º
[ªt1º,ªt2º,...]
…
{ ˆ, ªÉ x1 x2 ... é f [x1,x2,...]º } t
…
{strip ªf [t1,t2,...]º, ˆ} t
=TEX
=TACTIC
spec_nth_asm_tac
n
ªt2º
…
{ ˆ1...n-1, ªÉ x' é f [x']º, ˆ} t1
…
{strip ªf [t2]º, ˆ} t1
=TEX
=TACTIC
list_spec_nth_asm_tac
n
[ªt1º,ªt2º,...]
…
{ ˆ1...n-1, ªÉ x1 x2 ...é f [x1,x2,...]º, ˆ} t
…
{strip ªf [t1,t2,...]º, ˆ1...n-1,ˆ} t
=TEX
=FAILUREC
\paragraph{Errors}
As the constituents of the implementing functions
(e.g. $DROP\_ASM\_T$ and $É\_elim$).
=ENDDOC
\section{CONVERSIONS}
=DOC
val ‚å_in_conv· : CONV;
=DESCRIBE
This is a conversion which moves negations inside other predicate
calculus connectives using whichever of the following rules applies:
Û
		ååt			=	 t
		å(t1 Ä t2)		=	 åt1 Å åt2
		å(t1 Å t2)		=	 åt1 Ä åt2
		å(t1 ä t2)		=	 t1 Ä åt2
		å(t1 Ç t2)		=	 (t1 Ä åt2) Å (t2 Ä åt1)
		å(if a then t1 else t2)
					=	 (if a then åt1 else åt2)
		åÉvsét			=	 Ñvséåt
		åÑvsét			=	 Évséåt
		åÑ%down%1vsét	=	 Évséå(t Ä Évs'ét[vs'] ä vs' = vs)
		åT			=	 F
		åF			=	 T
Ê
=USES
Tactic and conversion programming.
=SEEALSO
$simple\_å\_in\_conv$, $å\_in\_tac$
=FAILURE
28131	No applicable rules for the term ?0
=ENDDOC
\section{CANONICALISATION}
=DOC
val ‚å_rewrite_canon· : THM -> THM list
val ‚É_rewrite_canon· : THM -> THM list
=DESCRIBE
These are some of the standard canonicalisation functions used for breaking theorems up into
lists of equations for use in rewriting. They four perform the following
transformations:
Û
å_rewrite_canon		(ˆ Ö å(t1 Å t2))	= (ˆ Ö åt1 Ä åt2)	
å_rewrite_canon		(ˆ Ö åÑvsét)		= (ˆ Ö Évséåt)	
å_rewrite_canon		(ˆ Ö åt)		= (ˆ Ö t Ç F)	
É_rewrite_canon		(ˆ Ö Évsét)		= ˆ Ö t
Ê

=SEEALSO
$simple\_å\_rewrite\_canon$, $simple\_É\_rewrite\_canon$.
=FAILURE
26201	Failed as requested
=FAILUREC
The area given by the failure will be $fail\_canon$.
=ENDDOC

=DOC
val ‚pair_rw_canon· : CANON;
=DESCRIBE
This is the rewrite canonicalisation function for the theory of pairs,
defined as
Û
val pair_rw_canon =
	REWRITE_CAN
	(REPEAT_CAN(FIRST_CAN [
	É_rewrite_canon,
	Ä_rewrite_canon,
	å_rewrite_canon,
	Ç_t_rewrite_canon]));
Ê
This is the repeated application of the first applicable
operation in the following list:
\begin{enumerate}
\item
stripping universal quantifiers (paired or simple);
\item
dividing conjunctive theorems into their conjuncts;
\item
changing $Öå(t1 Å t2)$ to $åt1 Ä åt2$;
\item
changing $ÖåÑvsét$ to $Évséåt$;
\item
changing $Öåt$ to $t Ç F$;
\item
if none of the above apply, changing $Öt$ to $Öt Ç T$.
\end{enumerate}

Finally, after all this canonicalisation we then universally quantify
the resulting theorems in all free variables other than those
that were free in the original.
=ENDDOC

\section{PROOF CONTEXTS}
=DOC
val ‚pair_proof_context· : PROOF_CONTEXT;
val ‚epair_proof_context· : EPROOF_CONTEXT;
=DESCRIBE
$pair\_proof\_context$ takes:
for the $sa\_eqn\_cxt$ parameter (for $STRIP\-\_THM\-\_THEN$):
Û
[(thm_for_eqn_cxt ä_thm),
 (thm_for_eqn_cxt Ç_thm),
 (thm_for_eqn_cxt `Ö É a t1 t2é (if a then t1 else t2) Ç (a ä t1) Ä (å a ä t2)`),
 (ªå xº, å_in_conv),
 (ªÑ%down%1 x é pº, simple_Ñ%down%1_conv),
 (ª$Ñ%down%1(Uncurry f)º, Ñ%down%1_conv),
 (ª$É (Uncurry f)º, É_uncurry_conv),
 (ª$Ñ (Uncurry f)º, Ñ_uncurry_conv)
]
Ê
for the $sg\_eqn\_cxt$ parameter (for $STRIP\-\_GOAL\-\_T$):
Û
[(thm_for_eqn_cxt `Ö É t1 t2 é (t1 Å å t2) Ç (t2 ä t1)`),
 (thm_for_eqn_cxt `Ö É t1 t2 é (å t1 Å t2) Ç (t1 ä t2)`),
 (thm_for_eqn_cxt `Ö É t1 t2 é (t1 Å t2) Ç (å t1 ä t2)`),
 (thm_for_eqn_cxt Ç_thm),
 (thm_for_eqn_cxt `Ö É a t1 t2é (if a then t1 else t2) Ç (a ä t1) Ä (å a ä t2)`),
 (ªå xº, å_conv),
 (ª$É (Uncurry f)º, É_uncurry_conv)]
Ê
for the $rw\_canon$, $pair\_rw\_canon$;
and $rw\_eqn\_cxt$:
Û
(flat(map (cthm_for_eqn_cxt initial_rw_canon) [
	eq_rewrite_thm,
	Ç_rewrite_thm,
	å_rewrite_thm,
	Ä_rewrite_thm,
	Å_rewrite_thm,
	ä_rewrite_thm,
	if_rewrite_thm,
	É_rewrite_thm,
	Ñ_rewrite_thm,
	%beta%_rewrite_thm])) @
[ (ª(ç x é y) zº, simple_%beta%_conv),
  (ªUncurry x yº, %beta%_conv)
 ];
Ê
$epair\_proof\_context$ 
is created from the above using $evaluate\_proof\_context$(q.v.).
=ENDDOC
The above is somewhat arbitrary in its handling of 
paired quantifiers that we know will not be further
stripped.
It ``uncurries'' universals that will going into the assumption
list, but leaves curried existentials and unique existentials
in the goal unchanged.
This is a guess at desired behaviour based on making the
assumptions simple at all costs, though assuming that
paired existentials in the goal {\em may} be beneficial
if providing a witness whose type is paired, but is not formed
using the pair data constructor ``,''. 
\section{END OF THE SIGNATURE}
=SML
end; (* signature of TacticsIII *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

=IGN
open Sort;
fun sf {id = id1,text = text1} {id = id2,text = text2} = (
	if text1 <> text2
	then stringorder text1 text2
	else (id1 - id2)
);

sort sf (get_error_messages());
