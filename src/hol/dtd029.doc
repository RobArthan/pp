% dtd029.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design of Tactics III}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Tactics III}
\TPPref{DS/FMU/IED/DTD029}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the third grouping of tactics,
in particular those concerned with paired abstractions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version: place holder for tautology stuff.
\item [Issue 1.2]
Added some more odds and ends.
\item [Issue 1.3]
Attempting a ``complete'' design.
\item [Issue 1.4]
Used $GET\_ASM\_T$, etc, in $spec\_asm\_tac$, etc.
\item [Issue 1.5]
Reacting to issue 1.5 of \cite{DS/FMU/IED/DTD051}.

\item[Issue 1.6, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.7]
Added $sets\_(e)pc$.
\item [Issue 1.8(11th March 1992)]
Various minor additions and extensions.
\item [Issue 1.9 (26th March 1992)]
Changed to use proof context material of issue 1.13 of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.10 (31st March 1992)]
Added understanding of double negation
to $≥\-\_rewrite\-\_canon$.
\item [Issue 1.11 (13th April 1992)]
Changes due to CR0017.
\item [Issue 1.12 (28th April 1992)]
Corrected documentation typo.
\item [Issue 1.13 (14th May 1992)]
Tidying up proof contexts.
\item [Issue 1.14 (27th May 1992)]
Added $all\_¬\_tac$.
\end{description}
% \subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
third grouping of tactics, in particular those concerning paired abstractions.
This is called for in \cite{DS/FMU/IED/HLD012}.
The design is
implemented in \cite{DS/FMU/IED/IMP029}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
third grouping of tactics, in particular those concerning paired abstractions.

The document provides groups of tactics, related by their core operator.

All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP029}.

We use the notation ``varstruct'' for ``an allowed variable structure, under ICL HOL syntax''.
\subsubsection{Dependencies}
Loading this document is dependent on \cite{DS/FMU/IED/IMP026}.
It is implemented in theory ``pair''.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.

\section{THE SIGNATURE}
=DOC
signature €Tactics3› = sig
=DESCRIBE
This provides the grouping of tactics for ICL HOL.
They are primarily concerned with adding handling for paired abstractions.
=ENDDOC
\subsection{Concerning Tautologies}
The following are all implemented using $simple\_taut\_tac$.
=DOC
val €taut_tac› : TACTIC;
=DESCRIBE
A tautology prover.
If the conclusion of the goal is a tautology then $taut\_tac$ will prove
the goal.
A tautology is taken to be any (perhaps universally quantified) substitution
instance of a term which is formed from boolean variables,
the constants $T$ and $F$ and the following
connectives:
=GFT
±, ≤, ¥, §, ≥, if ... then ... else
=TEX
and which is true for any assignment of truth values to the variables.
=FRULE 2 Tactic
taut_tac
˜
{ á } t
˜
=TEX
=SEEALSO
$strip\_tac$, $taut\_rule$, $taut\_conv$,
$simple\_taut\_tac$.
=FAILURE
29020	Conclusion of the goal is not a universally quantified tautology
=ENDDOC
=DOC
val €taut_rule› : TERM -> THM;
=DESCRIBE
A tautology prover.
A tautology is taken to be any universally quantified substitution
instance of a term which is formed from boolean variables,
the constants $T$ and $F$ and the following
connectives:
=GFT
±, ≤, ¥, §, ≥, if ... then ... else
=TEX
and which is true for any assignment of truth values to the variables.
If its argument is such a tautology then the
function will return that term as a theorem.
=FRULE 1 Rule
taut_rule
¨tÆ
˜
˜
Ù t
=TEX
=SEEALSO
$taut\_tac$, $taut\_conv$,
$simple\_taut\_tac$.
=FAILURE
27037	?0 is not tautologically true
=ENDDOC
This is not a conversion, but there are two conversions leading
from it:
=DOC
val €taut_conv› : CONV;
=DESCRIBE
A tautology prover.
A tautology is taken to be any universally quantified substitution
instance of a term which is formed from boolean variables,
the constants $T$ and $F$ and the following
connectives:
=GFT
±, ≤, ¥, §, ≥, if ... then ... else
=TEX
and which is true for any assignment of truth values to the variables.
If its argument is a tautologically true term, then the
function will return a theorem that the term is equivalent to $T$.
=FRULE 1 Conversion
taut_conv
¨tÆ
˜
˜
Ù t § T
=TEX
=SEEALSO
$taut\_tac$, $taut\_rule$,
$simple\_taut\_tac$.
=FAILURE
27037	?0 is not tautologically true
=ENDDOC
Should this be $taut\_§\_conv$?
\subsection{Concerning ≥}
=DOC
val €≥_in_tac› : TACTIC;
=DESCRIBE
This is a tactic which moves negations inside other predicate calculus
connectives using the following rules:
=GFT
		≥≥t			≠	 t
		≥(t1 ± t2)		≠	 ≥t1 ≤ ≥t2
		≥(t1 ≤ t2)		≠	 ≥t1 ± ≥t2
		≥(t1 ¥ t2)		≠	 t1 ± ≥t2
		≥(t1 § t2)		≠	 (t1 ± ≥t2) ≤ (t2 ± ≥t1)
		≥µvs∑t			≠	 ∂vs∑≥t
		≥∂vs∑t			≠	 µvs∑≥t
		≥∂â1vs∑t	≠	 µvs∑≥(t ± µvs'∑t[vs'] ¥ vs' = vs)
		≥T			≠	 F
		≥F			≠	 T
=TEX
=USES
=SEEALSO
$simple\_≥\_in\_tac$, $≥\_in\_conv$
=FAILURE
28025	No applicable rule for this goal
=ENDDOC

=DOC
val €≥_IN_THEN› : THM_TACTICAL;
=DESCRIBE
This is a theorem tactical which applies a given 
theorem tactic to the result of transforming a theorem
by moving a top level negation inside other predicate calculus
connectives using the following rules:
=GFT
		≥≥t			≠	 t
		≥(t1 ± t2)		≠	 ≥t1 ≤ ≥t2
		≥(t1 ≤ t2)		≠	 ≥t1 ± ≥t2
		≥(t1 ¥ t2)		≠	 t1 ± ≥t2
		≥(t1 § t2)		≠	 (t1 ± ≥t2) ≤ (t2 ± ≥t1)
		≥µvs∑t			≠	 ∂vs∑≥t
		≥∂vs∑t			≠	 µvs∑≥t
		≥∂â1vs∑t	≠	 µvs∑≥(t ± µvs'∑t[vs'] ¥ vs' = vs)
		≥T			≠	 F
		≥F			≠	 T
=TEX
This function partially evaluates given only the theorem
and theorem-tactical.
=SEEALSO
$SIMPLE\_≥\_IN\_THEN$
=FAILURE
29010	No applicable rule for ?0
=ENDDOC
\subsection{Concerning µ}
=DOC
val €µ_tac› : TACTIC;
=DESCRIBE
Reduce a universally quantified goal.
=FRULE 2 Tactic
µ_tac
˜
{ á } µ vs[x1,...] ∑ t[x1,...]
˜
{ á } t[x1',...]
=TEX
where $x1'$ is a variant name of $x1$, etc, different from any 
variable in $á$ or $t$.
=SEEALSO
$simple\_µ\_tac$
=FAILURE
29001	Goal is not of the form: { á } µ vs ∑ t[vs]
=ENDDOC

\subsection{Concerning ∂}

=DOC
val €∂_tac› : TERM -> TACTIC ;
=DESCRIBE
Provide a witness for an existential subgoal.

N.B. loses information.
=FRULE 2 Tactic
∂_tac
¨tÆ
˜
{ á } ∂ vs[x1,...] ∑ t2[x1,...]
˜
{ á } t2[t1',...]
=TEX
where $vs[t_1,...]$ is $t$, type instantiated to have the same type as $vs[x1,...]$, and broken up using
$Fst$ and $Snd$ as necessary.
=SEEALSO
$simple\_∂\_tac$
=FAILURE
29002	Goal is not of the form: { á } ∂ vs ∑ t2[vs]
29008	Cannot match witness ?0 to varstruct ?1
=ENDDOC
=DOC
val €∂_THEN› : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical which applies a given theorem tactic to the result
of eliminating the outermost quantifier from a theorem of the form
$á Ù ∂vs∑t$.
=GFT
∂_THEN thmtac (á Ù ∂vs[x1,...]∑t) = thmtac (á Ù t[x1'/x1,...])
=TEX
where ¨x1'Æ is a variant of ¨x1Æ , etc, which does not appear in $á$ or in
the assumption or conclusion of the goal.
=SEEALSO
$SIMPLE\_∂\_THEN$
=FAILURE
29003	?0 is not of the form: `á Ù ∂ vs ∑ t`
=ENDDOC

\subsection{Concerning ∂$_1$}

=DOC
val €∂â1_tac› : TERM -> TACTIC;
=DESCRIBE
Simplify a unique existentially quantified goal with a particular
witness.

N.B. loses information.
=FRULE 2 Tactic
∂â1_tac1
¨tÆ
˜
{ á } ∂â1 vs[x1,...] ∑ P[x1,...]
˜
{ á } P[t1',...];
{ á } µvs[x1',...]∑ 
	P[x1',...] ¥ vs[x1',...] = t'
=TEX
where $x_i'$ is a variant of $x_i$ which does not occur free in $t$,
$t'$ is equal to $t$ type instantiated to the type of $vs[x1,...]$,
and $vs[t1',...]$ equals $t'$ (perhaps using $Fst$ and $Snd$).
=FAILURE
29004	Goal is not of the form: { á } ∂â1 vs ∑ t
29008	Cannot match witness ?0 to varstruct ?1
=ENDDOC
=DOC
val €∂â1_THEN› : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical which applies a given theorem tactic to the result
of eliminating the outermost quantifier from a theorem of the form
$á Ù ∂_1vs∑t$.
=GFT
∂â1_THEN thmtac (á Ù ∂â1vs[x1,...]∑t) = 
	thmtac (á Ù t[x1'/x1,...] ± 
		µvs[x1'',...]∑P[x1'',...] ¥ vs[x1'',...] = vs[x1',...])
=TEX
where ¨x1'Æ and ¨x1''Æ are distinct variants of ¨x1Æ, etc, which do not appear free in $á$ or in
the assumptions or conclusion of the goal.
=FAILURE
29005	?0 is not of the form: `á Ù ∂â1 vs ∑ t`
=ENDDOC
\subsection{Concerning Ã}
=DOC
val €all_¬_tac› : TACTIC;
=DESCRIBE
This tactic will $¬$-reduce all $¬$-redexes in the goal's
conclusion,
including
those redexes introduced by preceding $¬$-reductions
in the same tactic application.
=USES
In most proof contexts $¬$-reduction will be a side effect
of rewriting: this tactic is intended for cases where
rewriting would do ``too much''.
=SEEALSO
$all\_¬\_rule$, $all\_¬\_conv$
=FAILURE
27049	?0 contains no ¬-redexes
=ENDDOC
\subsection{Concerning Assumptions}
=DOC
val €spec_asm_tac› : TERM -> TERM -> TACTIC;
val €list_spec_asm_tac› : TERM -> TERM list -> TACTIC;
val €spec_nth_asm_tac› : int -> TERM -> TACTIC;
val €list_spec_nth_asm_tac› : int -> TERM list -> TACTIC;
=DESCRIBE
These are four methods of specialising asssumptions,
differing by single or lists of values to specialise to,
and in the method of selection of the assumption.
All of them leave the old assumption in place, and place the
 instantiated asssumption onto the assumption list using $strip\_asm\_tac$.
If the desired behaviour differs from any of those supplied
then use $GET\_ASM\_T$ and its cousins to create the desired functionality.
=FRULE 2 Tactic
spec_asm_tac
¨µ vs[x1,...] ∑ f [x1,...]Æ
¨tmÆ
˜
{ á, ¨µ vs[x1',...] ∑ f [x1',...]Æ } t
˜
{strip ¨f [t1,...]Æ, á,
¨µ vs[x1,...] ∑ f [x1,...]Æ} t1
=TEX
The following all handle paired abstractions in a similar
manner.
=FRULE 2 Tactic
list_spec_asm_tac
¨µ x1 ... ∑ f [x1,...]Æ
[¨t1Æ,¨t2Æ,...]
˜
{ á, ¨µ x1 ... ∑ f [x1,...]Æ } t
˜
{strip ¨f [t1,...]Æ, á,
¨µ x1 x2 ... ∑ f [x1,...]Æ,
} t
=TEX
=FRULE 2 Tactic
spec_nth_asm_tac
n
¨t2Æ
˜
{ á1...n-1, ¨µ x' ∑ f [x']Æ, á} t1
˜
{strip ¨f [t2]Æ,  á1...n-1,
¨µ x' ∑ f [x']Æ,
á} t1
=TEX
=FRULE 2 Tactic
list_spec_nth_asm_tac
n
[¨t1Æ,...]
˜
{ á1...n-1, ¨µ x1 ...∑ f [x1,...]Æ, á} t
˜
{strip ¨f [t1,...]Æ, á1...n-1,
¨µ x1 ...∑ f [x1,...]Æ, 
á} t
=TEX
=FAILUREC
\paragraph{Errors}
As the constituents of the implementing functions
(e.g. $GET\_ASM\_T$ and $µ\_elim$).
=ENDDOC
=DOC
val €SPEC_ASM_T› : TERM -> TERM -> (THM -> TACTIC) -> TACTIC;
val €LIST_SPEC_ASM_T› : TERM -> TERM list -> (THM -> TACTIC) 
	-> TACTIC;
val €SPEC_NTH_ASM_T› : int -> TERM -> (THM -> TACTIC) -> TACTIC;
val €LIST_SPEC_NTH_ASM_T› : int -> TERM list -> (THM -> TACTIC) 
	-> TACTIC;
=DESCRIBE
These are four methods of specialising asssumptions,
differing by single or lists of values to specialise to,
and in the method of selection of the assumption.
All of them leave the old assumption in place, and place the
 instantiated asssumption onto the assumption list using 
their theorem tactic.
=FRULE 2 Tactic
SPEC_ASM_T
¨µ vs[x1,...] ∑ f [x1,...]Æ
¨tmÆ
thm_tac
˜
{ á, ¨µ vs[x1',...] ∑ f [x1',...]Æ } t
˜
thm_tac (asm_rule ¨f [t1,...]Æ)
{á,¨µ vs[x1,...] ∑ f [x1,...]Æ} t1
=TEX
The following all handle paired abstractions in a similar
manner.
=FRULE 2 Tactic
LIST_SPEC_ASM_T
¨µ x1 x2 ... ∑ f [x1,x2,...]Æ
[¨t1Æ,¨t2Æ,...]
thm_tac
˜
{ á, ¨µ x1 x2 ... ∑ f [x1,x2,...]Æ } t
˜
thm_tac (asm_rule ¨f [t1,t2,...]Æ)
{á,¨µ x1 x2 ... ∑ f [x1,x2,...]Æ} t
=TEX
=FRULE 2 Tactic
SPEC_NTH_ASM_T
n
¨t2Æ
thm_tac
˜
{ á1...n-1, ¨µ x' ∑ f [x']Æ, á} t1
˜
thm_tac (asm_rule ¨f [t2]Æ)
{á1...n-1,¨µ x' ∑ f [x']Æ,á} t1
=TEX
=FRULE 2 Tactic
LIST_SPEC_NTH_ASM_T
n
[¨t1Æ,...]
thm_tac
˜
{ á1...n-1, ¨µ x1 ...∑ f [x1,...]Æ, á} t
˜
thm_tac (asm_rule ¨f [t1,...]Æ)
{á1...n-1,¨µ x1 ...∑ f [x1,...]Æ, á} 
t
=TEX
=FAILUREC
\paragraph{Errors}
As the constituents of the implementing functions
(e.g. $GET\_ASM\_T$ and $µ\_elim$).
=ENDDOC
\section{CONVERSIONS}
=DOC
val €≥_in_conv› : CONV;
=DESCRIBE
This is a conversion which moves negations inside other predicate
calculus connectives using whichever of the following rules applies:
=GFT
		≥≥t			=	 t
		≥(t1 ± t2)		=	 ≥t1 ≤ ≥t2
		≥(t1 ≤ t2)		=	 ≥t1 ± ≥t2
		≥(t1 ¥ t2)		=	 t1 ± ≥t2
		≥(t1 § t2)		=	 (t1 ± ≥t2) ≤ (t2 ± ≥t1)
		≥(if a then t1 else t2)
					=	 (if a then ≥t1 else ≥t2)
		≥µvs∑t			=	 ∂vs∑≥t
		≥∂vs∑t			=	 µvs∑≥t
		≥∂â1vs∑t	=	 µvs∑≥(t ± µvs'∑t[vs'] ¥ vs' = vs)
		≥T			=	 F
		≥F			=	 T
=TEX
=USES
Tactic and conversion programming.
=SEEALSO
$simple\_≥\_in\_conv$, $≥\_in\_tac$
=FAILURE
28131	No applicable rules for the term ?0
=ENDDOC
\section{CANONICALISATION}
=DOC
val €≥_rewrite_canon› : THM -> THM list
val €µ_rewrite_canon› : THM -> THM list
=DESCRIBE
These are some of the standard canonicalisation functions used for breaking theorems up into
lists of equations for use in rewriting. They four perform the following
transformations:
=GFT
≥_rewrite_canon		(á Ù ≥(t1 ≤ t2))	= (á Ù ≥t1 ± ≥t2)	
≥_rewrite_canon		(á Ù ≥∂vs∑t)		= (á Ù µvs∑≥t)	
≥_rewrite_canon		(á Ù ≥≥t)		= (á Ù t)	
≥_rewrite_canon		(á Ù ≥t)		= (á Ù t § F)	
µ_rewrite_canon		(á Ù µvs∑t)		= á Ù t
=TEX

=SEEALSO
$simple\_≥\_rewrite\_canon$, $simple\_µ\_rewrite\_canon$.
=FAILURE
26201	Failed as requested
=FAILUREC
The area given by the failure will be $fail\_canon$.
=ENDDOC

=DOC
val €pair_rw_canon› : CANON;
=DESCRIBE
This is the rewrite canonicalisation function for the theory of pairs,
defined as
=GFT
val pair_rw_canon =
	REWRITE_CAN
	(REPEAT_CAN(FIRST_CAN [
	µ_rewrite_canon,
	±_rewrite_canon,
	≥_rewrite_canon,
	f_rewrite_canon,
	§_t_rewrite_canon]));
=TEX
This is the repeated application of the first applicable
operation in the following list:
\begin{enumerate}
\item
stripping universal quantifiers (paired or simple);
\item
dividing conjunctive theorems into their conjuncts;
\item
changing $Ù≥(t1 ≤ t2)$ to $≥t1 ± ≥t2$;
\item
changing $Ù≥∂vs∑t$ to $µvs∑≥t$;
\item
changing $Ù≥≥t$ to $t § F$;
\item
changing $Ù≥t$ to $t § F$;
\item
if none of the above apply, changing $Ùt$ to $Ùt § T$.
\end{enumerate}

Finally, after all this canonicalisation we then universally quantify
the resulting theorems in all free variables other than those
that were free in the original.
=ENDDOC

\section{END OF THE SIGNATURE}
=SML
end; (* signature of Tactics3 *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

=IGN
open Sort;
fun sf {id = id1,text = text1} {id = id2,text = text2} = (
	if text1 <> text2
	then string_order text1 text2
	else (id1 - id2)
);

sort sf (get_error_messages());


