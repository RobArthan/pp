% dtd029.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design of Tactics III}  %% Mandatory field
\def\TPPheadtitle{Detailed Design of Tactics III}
\TPPref{DS/FMU/IED/DTD029}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the third grouping of tactics,
in particular those concerned with paired abstractions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version: place holder for tautology stuff.
\item [Issue 1.2]
Added some more odds and ends.
\item [Issue 1.3]
Attempting a ``complete'' design.
\item [Issue 1.4]
Used $GET\_ASM\_T$, etc, in $spec\_asm\_tac$, etc.
\item [Issue 1.5]
Reacting to issue 1.5 of \cite{DS/FMU/IED/DTD051}.

\item[Issue 1.6, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.7]
Added $sets\_(e)pc$.
\item [Issue 1.8(11th March 1992)]
Various minor additions and extensions.
\item [Issue 1.9 (26th March 1992)]
Changed to use proof context material of issue 1.13 of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.10 (31st March 1992)]
Added understanding of double negation
to $³\-\_rewrite\-\_canon$.
\item [Issue 1.11 (13th April 1992)]
Changes due to CR0017.
\end{description}
% \subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
third grouping of tactics, in particular those concerning paired abstractions.
This is called for in \cite{DS/FMU/IED/HLD012}.
The design is
implemented in \cite{DS/FMU/IED/IMP029}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
third grouping of tactics, in particular those concerning paired abstractions.

The document provides groups of tactics, related by their core operator.

All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP029}.

We use the notation ``varstruct'' for ``an allowed variable structure, under ICL HOL syntax''.
\subsubsection{Dependencies}
Loading this document is dependent on \cite{DS/FMU/IED/IMP026}.
It is implemented in theory ``pair''.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.

\section{THE SIGNATURE}
=DOC
signature ÛTactics3Ý = sig
=DESCRIBE
This provides the grouping of tactics for ICL HOL.
They are primarily concerned with adding handling for paired abstractions.
=ENDDOC
\subsection{Concerning Tautologies}
The following are all implemented using $simple\_taut\_tac$.
=DOC
val Ûtaut_tacÝ : TACTIC;
=DESCRIBE
A tautology prover.
If the conclusion of the goal is a tautology then $taut\_tac$ will prove
the goal.
A tautology is taken to be any (perhaps universally quantified) substitution
instance of a term which is formed from boolean variables,
the constants $T$ and $F$ and the following
connectives:
=GFT
±, ², ´, ¤, ³, if ... then ... else
=TEX
and which is true for any assignment of truth values to the variables.
=FRULE 2 Tactic
taut_tac
÷
{ ‡ } t
÷
=TEX
=SEEALSO
$strip\_tac$, $taut\_rule$, $taut\_conv$,
$simple\_taut\_tac$.
=FAILURE
29020	Conclusion of the goal is not a universally quantified tautology
=ENDDOC
=DOC
val Ûtaut_ruleÝ : TERM -> THM;
=DESCRIBE
A tautology prover.
A tautology is taken to be any universally quantified substitution
instance of a term which is formed from boolean variables,
the constants $T$ and $F$ and the following
connectives:
=GFT
±, ², ´, ¤, ³, if ... then ... else
=TEX
and which is true for any assignment of truth values to the variables.
If its argument is such a tautology then the
function will return that term as a theorem.
=FRULE 1 Rule
taut_rule
¬t®
÷
÷
ô t
=TEX
=SEEALSO
$taut\_tac$, $taut\_conv$,
$simple\_taut\_tac$.
=FAILURE
27037	?0 is not tautologically true
=ENDDOC
This is not a conversion, but there are two conversions leading
from it:
=DOC
val Ûtaut_convÝ : CONV;
=DESCRIBE
A tautology prover.
A tautology is taken to be any universally quantified substitution
instance of a term which is formed from boolean variables,
the constants $T$ and $F$ and the following
connectives:
=GFT
±, ², ´, ¤, ³, if ... then ... else
=TEX
and which is true for any assignment of truth values to the variables.
If its argument is a tautologically true term, then the
function will return a theorem that the term is equivalent to $T$.
=FRULE 1 Conversion
taut_conv
¬t®
÷
÷
ô t ¤ T
=TEX
=SEEALSO
$taut\_tac$, $taut\_rule$,
$simple\_taut\_tac$.
=FAILURE
27037	?0 is not tautologically true
=ENDDOC
Should this be $taut\_¤\_conv$?
\subsection{Concerning ³}
=DOC
val Û³_in_tacÝ : TACTIC;
=DESCRIBE
This is a tactic which moves negations inside other predicate calculus
connectives using the following rules:
=GFT
		³³t			­	 t
		³(t1 ± t2)		­	 ³t1 ² ³t2
		³(t1 ² t2)		­	 ³t1 ± ³t2
		³(t1 ´ t2)		­	 t1 ± ³t2
		³(t1 ¤ t2)		­	 (t1 ± ³t2) ² (t2 ± ³t1)
		³µvs·t			­	 ¶vs·³t
		³¶vs·t			­	 µvs·³t
		³¶‰1vs·t	­	 µvs·³(t ± µvs'·t[vs'] ´ vs' = vs)
		³T			­	 F
		³F			­	 T
=TEX
=USES
=SEEALSO
$simple\_³\_in\_tac$, $³\_in\_conv$
=FAILURE
28025	No applicable rule for this goal
=ENDDOC

=DOC
val Û³_IN_THENÝ : THM_TACTICAL;
=DESCRIBE
This is a theorem tactical which applies a given 
theorem tactic to the result of transforming a theorem
by moving a top level negation inside other predicate calculus
connectives using the following rules:
=GFT
		³³t			­	 t
		³(t1 ± t2)		­	 ³t1 ² ³t2
		³(t1 ² t2)		­	 ³t1 ± ³t2
		³(t1 ´ t2)		­	 t1 ± ³t2
		³(t1 ¤ t2)		­	 (t1 ± ³t2) ² (t2 ± ³t1)
		³µvs·t			­	 ¶vs·³t
		³¶vs·t			­	 µvs·³t
		³¶‰1vs·t	­	 µvs·³(t ± µvs'·t[vs'] ´ vs' = vs)
		³T			­	 F
		³F			­	 T
=TEX
This function partially evaluates given only the theorem
and theorem-tactical.
=SEEALSO
$SIMPLE\_³\_IN\_THEN$
=FAILURE
29010	No applicable rule for ?0
=ENDDOC
\subsection{Concerning µ}
=DOC
val Ûµ_tacÝ : TACTIC;
=DESCRIBE
Reduce a universally quantified goal.
=FRULE 2 Tactic
µ_tac
÷
{ ‡ } µ vs[x1,...] · t[x1,...]
÷
{ ‡ } t[x1',...]
=TEX
where $x1'$ is a variant name of $x1$, etc, different from any 
variable in $‡$ or $t$.
=SEEALSO
$simple\_µ\_tac$
=FAILURE
29001	Goal is not of the form: { ‡ } µ vs · t[vs]
=ENDDOC

\subsection{Concerning ¶}

=DOC
val Û¶_tacÝ : TERM -> TACTIC ;
=DESCRIBE
Provide a witness for an existential subgoal.

N.B. loses information.
=FRULE 2 Tactic
¶_tac
¬t®
÷
{ ‡ } ¶ vs[x1,...] · t2[x1,...]
÷
{ ‡ } t2[t1',...]
=TEX
where $vs[t_1,...]$ is $t$, type instantiated to have the same type as $vs[x1,...]$, and broken up using
$Fst$ and $Snd$ as necessary.
=SEEALSO
$simple\_¶\_tac$
=FAILURE
29002	Goal is not of the form: { ‡ } ¶ vs · t2[vs]
29008	Cannot match witness ?0 to varstruct ?1
=ENDDOC
=DOC
val Û¶_THENÝ : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical which applies a given theorem tactic to the result
of eliminating the outermost quantifier from a theorem of the form
$‡ ô ¶vs·t$.
=GFT
¶_THEN thmtac (‡ ô ¶vs[x1,...]·t) = thmtac (‡ ô t[x1'/x1,...])
=TEX
where ¬x1'® is a variant of ¬x1® , etc, which does not appear in $‡$ or in
the assumption or conclusion of the goal.
=SEEALSO
$SIMPLE\_¶\_THEN$
=FAILURE
29003	?0 is not of the form: `‡ ô ¶ vs · t`
=ENDDOC

\subsection{Concerning ¶$_1$}

=DOC
val Û¶‰1_tacÝ : TERM -> TACTIC;
=DESCRIBE
Simplify a unique existentially quantified goal with a particular
witness.

N.B. loses information.
=FRULE 2 Tactic
¶‰1_tac1
¬t®
÷
{ ‡ } ¶‰1 vs[x1,...] · P[x1,...]
÷
{ ‡ } P[t1',...];
{ ‡ } µvs[x1',...]· 
	P[x1',...] ´ vs[x1',...] = t'
=TEX
where $x_i'$ is a variant of $x_i$ which does not occur free in $t$,
$t'$ is equal to $t$ type instantiated to the type of $vs[x1,...]$,
and $vs[t1',...]$ equals $t'$ (perhaps using $Fst$ and $Snd$).
=FAILURE
29004	Goal is not of the form: { ‡ } ¶‰1 vs · t
29008	Cannot match witness ?0 to varstruct ?1
=ENDDOC
=DOC
val Û¶‰1_THENÝ : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical which applies a given theorem tactic to the result
of eliminating the outermost quantifier from a theorem of the form
$‡ ô ¶_1vs·t$.
=GFT
¶‰1_THEN thmtac (‡ ô ¶‰1vs[x1,...]·t) = 
	thmtac (‡ ô t[x1'/x1,...] ± 
		µvs[x1'',...]·P[x1'',...] ´ vs[x1'',...] = vs[x1',...])
=TEX
where ¬x1'® and ¬x1''® are distinct variants of ¬x1®, etc, which do not appear free in $‡$ or in
the assumptions or conclusion of the goal.
=FAILURE
29005	?0 is not of the form: `‡ ô ¶‰1 vs · t`
=ENDDOC

\subsection{Concerning Assumptions}
=DOC
val Ûspec_asm_tacÝ : TERM -> TERM -> TACTIC;
val Ûlist_spec_asm_tacÝ : TERM -> TERM list -> TACTIC;
val Ûspec_nth_asm_tacÝ : int -> TERM -> TACTIC;
val Ûlist_spec_nth_asm_tacÝ : int -> TERM list -> TACTIC;
=DESCRIBE
These are four methods of specialising asssumptions,
differing by single or lists of values to specialise to,
and in the method of selection of the assumption.
All of them leave the old assumption in place, and place the
 instantiated asssumption onto the assumption list using $strip\_asm\_tac$.
If the desired behaviour differs from any of those supplied
then use $GET\_ASM\_T$ and its cousins to create the desired functionality.
=FRULE 2 Tactic
spec_asm_tac
¬µ vs[x1,...] · f [x1,...]®
¬tm®
÷
{ ‡, ¬µ vs[x1',...] · f [x1',...]® } t
÷
{strip ¬f [t1,...]®, ‡,
¬µ vs[x1,...] · f [x1,...]®} t1
=TEX
The following all handle paired abstractions in a similar
manner.
=FRULE 2 Tactic
list_spec_asm_tac
¬µ x1 ... · f [x1,...]®
[¬t1®,¬t2®,...]
÷
{ ‡, ¬µ x1 ... · f [x1,...]® } t
÷
{strip ¬f [t1,...]®, ‡,
¬µ x1 x2 ... · f [x1,...]®,
} t
=TEX
=FRULE 2 Tactic
spec_nth_asm_tac
n
¬t2®
÷
{ ‡1...n-1, ¬µ x' · f [x']®, ‡} t1
÷
{strip ¬f [t2]®,  ‡1...n-1,
¬µ x' · f [x']®,
‡} t1
=TEX
=FRULE 2 Tactic
list_spec_nth_asm_tac
n
[¬t1®,...]
÷
{ ‡1...n-1, ¬µ x1 ...· f [x1,...]®, ‡} t
÷
{strip ¬f [t1,...]®, ‡1...n-1,
¬µ x1 ...· f [x1,...]®, 
‡} t
=TEX
=FAILUREC
\paragraph{Errors}
As the constituents of the implementing functions
(e.g. $GET\_ASM\_T$ and $µ\_elim$).
=ENDDOC
=DOC
val ÛSPEC_ASM_TÝ : TERM -> TERM -> (THM -> TACTIC) -> TACTIC;
val ÛLIST_SPEC_ASM_TÝ : TERM -> TERM list -> (THM -> TACTIC) 
	-> TACTIC;
val ÛSPEC_NTH_ASM_TÝ : int -> TERM -> (THM -> TACTIC) -> TACTIC;
val ÛLIST_SPEC_NTH_ASM_TÝ : int -> TERM list -> (THM -> TACTIC) 
	-> TACTIC;
=DESCRIBE
These are four methods of specialising asssumptions,
differing by single or lists of values to specialise to,
and in the method of selection of the assumption.
All of them leave the old assumption in place, and place the
 instantiated asssumption onto the assumption list using 
their theorem tactic.
=FRULE 2 Tactic
SPEC_ASM_T
¬µ vs[x1,...] · f [x1,...]®
¬tm®
thm_tac
÷
{ ‡, ¬µ vs[x1',...] · f [x1',...]® } t
÷
thm_tac (asm_rule ¬f [t1,...]®)
{‡,¬µ vs[x1,...] · f [x1,...]®} t1
=TEX
The following all handle paired abstractions in a similar
manner.
=FRULE 2 Tactic
LIST_SPEC_ASM_T
¬µ x1 x2 ... · f [x1,x2,...]®
[¬t1®,¬t2®,...]
thm_tac
÷
{ ‡, ¬µ x1 x2 ... · f [x1,x2,...]® } t
÷
thm_tac (asm_rule ¬f [t1,t2,...]®)
{‡,¬µ x1 x2 ... · f [x1,x2,...]®} t
=TEX
=FRULE 2 Tactic
SPEC_NTH_ASM_T
n
¬t2®
thm_tac
÷
{ ‡1...n-1, ¬µ x' · f [x']®, ‡} t1
÷
thm_tac (asm_rule ¬f [t2]®)
{‡1...n-1,¬µ x' · f [x']®,‡} t1
=TEX
=FRULE 2 Tactic
LIST_SPEC_NTH_ASM_T
n
[¬t1®,...]
thm_tac
÷
{ ‡1...n-1, ¬µ x1 ...· f [x1,...]®, ‡} t
÷
thm_tac (asm_rule ¬f [t1,...]®)
{‡1...n-1,¬µ x1 ...· f [x1,...]®, ‡} 
t
=TEX
=FAILUREC
\paragraph{Errors}
As the constituents of the implementing functions
(e.g. $GET\_ASM\_T$ and $µ\_elim$).
=ENDDOC
\section{CONVERSIONS}
=DOC
val Û³_in_convÝ : CONV;
=DESCRIBE
This is a conversion which moves negations inside other predicate
calculus connectives using whichever of the following rules applies:
=GFT
		³³t			=	 t
		³(t1 ± t2)		=	 ³t1 ² ³t2
		³(t1 ² t2)		=	 ³t1 ± ³t2
		³(t1 ´ t2)		=	 t1 ± ³t2
		³(t1 ¤ t2)		=	 (t1 ± ³t2) ² (t2 ± ³t1)
		³(if a then t1 else t2)
					=	 (if a then ³t1 else ³t2)
		³µvs·t			=	 ¶vs·³t
		³¶vs·t			=	 µvs·³t
		³¶‰1vs·t	=	 µvs·³(t ± µvs'·t[vs'] ´ vs' = vs)
		³T			=	 F
		³F			=	 T
=TEX
=USES
Tactic and conversion programming.
=SEEALSO
$simple\_³\_in\_conv$, $³\_in\_tac$
=FAILURE
28131	No applicable rules for the term ?0
=ENDDOC
\section{CANONICALISATION}
=DOC
val Û³_rewrite_canonÝ : THM -> THM list
val Ûµ_rewrite_canonÝ : THM -> THM list
=DESCRIBE
These are some of the standard canonicalisation functions used for breaking theorems up into
lists of equations for use in rewriting. They four perform the following
transformations:
=GFT
³_rewrite_canon		(‡ ô ³(t1 ² t2))	= (‡ ô ³t1 ± ³t2)	
³_rewrite_canon		(‡ ô ³¶vs·t)		= (‡ ô µvs·³t)	
³_rewrite_canon		(‡ ô ³³t)		= (‡ ô t)	
³_rewrite_canon		(‡ ô ³t)		= (‡ ô t ¤ F)	
µ_rewrite_canon		(‡ ô µvs·t)		= ‡ ô t
=TEX

=SEEALSO
$simple\_³\_rewrite\_canon$, $simple\_µ\_rewrite\_canon$.
=FAILURE
26201	Failed as requested
=FAILUREC
The area given by the failure will be $fail\_canon$.
=ENDDOC

=DOC
val Ûpair_rw_canonÝ : CANON;
=DESCRIBE
This is the rewrite canonicalisation function for the theory of pairs,
defined as
=GFT
val pair_rw_canon =
	REWRITE_CAN
	(REPEAT_CAN(FIRST_CAN [
	µ_rewrite_canon,
	±_rewrite_canon,
	³_rewrite_canon,
	f_rewrite_canon,
	¤_t_rewrite_canon]));
=TEX
This is the repeated application of the first applicable
operation in the following list:
\begin{enumerate}
\item
stripping universal quantifiers (paired or simple);
\item
dividing conjunctive theorems into their conjuncts;
\item
changing $ô³(t1 ² t2)$ to $³t1 ± ³t2$;
\item
changing $ô³¶vs·t$ to $µvs·³t$;
\item
changing $ô³³t$ to $t ¤ F$;
\item
changing $ô³t$ to $t ¤ F$;
\item
if none of the above apply, changing $ôt$ to $ôt ¤ T$.
\end{enumerate}

Finally, after all this canonicalisation we then universally quantify
the resulting theorems in all free variables other than those
that were free in the original.
=ENDDOC

\section{PROOF CONTEXTS}
=DOC
(* ÛpairÝ : proof context *)
=DESCRIBE
$pair$ takes proof context $initial$,
and applies $set\_st\_eqn\_cxt$
(for $STRIP\-\_THM\-\_THEN$) with:
=GFT
[(thm_eqn_cxt ´_thm),	(thm_eqn_cxt ¤_thm),
 (thm_eqn_cxt `ô µ a t1 t2· (if a then t1 else t2) ¤ (a ´ t1) ± (³ a ´ t2)`),
 (¬³ x®, ³_in_conv),
 (¬¶‰1 x · p®, simple_¶‰1_conv),
 (¬$¶‰1(Uncurry f)®, ¶‰1_conv),
 (¬$µ (Uncurry f)®, µ_uncurry_conv),
 (¬$¶ (Uncurry f)®, ¶_uncurry_conv)
]
=TEX
$set\_sg\_eqn\_cxt$  (for $STRIP\-\_CONCL\-\_T$) with:
=GFT
[(thm_eqn_cxt `ô µ t1 t2 · (t1 ² ³ t2) ¤ (t2 ´ t1)`),
 (thm_eqn_cxt `ô µ t1 t2 · (³ t1 ² t2) ¤ (t1 ´ t2)`),
 (thm_eqn_cxt `ô µ t1 t2 · (t1 ² t2) ¤ (³ t1 ´ t2)`),
 (thm_eqn_cxt ¤_thm),
 (thm_eqn_cxt `ô µ a t1 t2· (if a then t1 else t2) ¤ (a ´ t1) ± (³ a ´ t2)`),
 (¬³ x®, ³_conv),
 (¬$µ (Uncurry f)®, µ_uncurry_conv)]
=TEX
$set\_rw\_canons$ with
=GFT
[	µ_rewrite_canon,	±_rewrite_canon,	³_rewrite_canon]
=TEX
and $set\_rw\_eqn\_cxt$ with:
=GFT
(flat(map (cthm_eqn_cxt initial_rw_canon) [
	eq_rewrite_thm,	¤_rewrite_thm,
	³_rewrite_thm,	±_rewrite_thm,
	²_rewrite_thm,	´_rewrite_thm,
	if_rewrite_thm,	µ_rewrite_thm,
	¶_rewrite_thm,	Â_rewrite_thm])) @
[ (¬(Ì x · y) z®, simple_Â_conv),
  (¬Uncurry x y®, Â_conv)
 ]
=TEX
=ENDDOC
The above is somewhat arbitrary in its handling of 
paired quantifiers that we know will not be further
stripped.
It ``uncurries'' universals that will going into the assumption
list, but leaves curried existentials and unique existentials
in the goal unchanged.
This is a guess at desired behaviour based on making the
assumptions simple at all costs, though assuming that
paired existentials in the goal {\em may} be beneficial
if providing a witness whose type is paired, but is not formed
using the pair data constructor ``,''. 
\section{END OF THE SIGNATURE}
=SML
end; (* signature of Tactics3 *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

=IGN
open Sort;
fun sf {id = id1,text = text1} {id = id2,text = text2} = (
	if text1 <> text2
	then string_order text1 text2
	else (id1 - id2)
);

sort sf (get_error_messages());


