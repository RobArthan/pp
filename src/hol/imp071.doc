%  $Id$ %Z%
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the Theory of Relations}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Theory of Sets}
\TPPref{DS/FMU/IED/IMP071}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.B.Jones & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document creates the theory ``relation''.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion (\FormatDate{$Date$%
})]

This is the first draft of the document.

\end{description}
\subsection{Changes Forecast}

\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the theory of relations.
The design is in \cite{DS/FMU/IED/DTD071}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the theory of relations.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD071}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{THE THEORY ``relation''}
=SML
structure €BinRelTheory› : BinRelTheory = struct
val _ = open_theory "hol";
val _ = push_pc "basic_hol";
val _ = new_theory "bin_rel";
=TEX
=SML
val _ = declare_type_abbrev(€""›, ["'a"], ¨:('a)SETÆ);
val _ = declare_infix(300, "Ì");
val €Ì_def› =
πHOLCONST
‹
‹	$€Ì›:'a ≠ 'b ≠ 'a ∏ 'b
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	$Ì = $,
‹
∞
=SML
val _ = declare_infix(240, "™");
val _ = declare_type_abbrev(€"™"›, ["'a","'b"], ¨:('a ∏ 'b)Æ);
val €∏_def› =
πHOLCONST
‹
‹	$€∏›:'a  ≠ 'b  ≠ ('a ™ 'b)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ (x : 'a ) (y : 'b )
‹	∑ (x ∏ y) = {(v,w) | v ç x ± w ç y}
‹
∞
=SML
val €™_def› =
πHOLCONST
‹
‹	$€™›:'a  ≠ 'b  ≠ ('a ™ 'b) 
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ (x : 'a ) (y : 'b )
‹	∑ (x ™ y) = (x ∏ y)
‹
∞
=TEX
The HOL constant $∏$ is the cartesian product contructor.
The HOL constant $€™›$ is relation space contructor.
=SML
val €dom_def› =
πHOLCONST
‹
‹	€Dom›:('a ™ 'b) ≠ ('a)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ (r : ('a ™ 'b))
‹	∑ Dom r = {x | ∂y ∑ (x, y) ç r}
‹
∞
=SML
val €ran_def› =
πHOLCONST
‹
‹	€Ran›:('a ™ 'b) ≠ ('b)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ (r : ('a ™ 'b))
‹	∑ Ran r = {y | ∂x ∑ (x, y) ç r}
‹
∞
=SML
=TEX
The HOL constant $Dom$ is the function giving the domain of a relation.
The HOL constant $€Ran›$ is the function giving the range of a relation.
=SML
val €id_def› =
πHOLCONST
‹
‹	€Id›:('a) ≠ ('a ™ 'a)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ (s : ('a))
‹	∑  Id s = {(x,x) | x ç s}
‹
∞
=SML
val €graph_def› =
πHOLCONST
‹
‹	€Graph›:('a ≠ 'b)≠ ('a ™ 'b)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ f : 'a ≠ 'b
‹	∑  Graph f = {(x, y) | y = f x}
‹
∞
=SML
=SML
val _ = declare_infix(240, "ª");
val €ª_def› =
πHOLCONST
‹	$€ª›:('a ≠ 'b) ≠ ('b ≠ 'c) ≠ ('a ≠ 'c)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ (f:'a ≠ 'b) (g:'b ≠ 'c) ∑ f ª g = g o f
∞
=SML
val _ = declare_infix(240, "R_ª_R");
val €r_ª_r_def› =
πHOLCONST
‹
‹	$€R_ª_R›:('a ™ 'b) ≠ ('b ™ 'c) ≠ ('a ™ 'c)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ r s ∑ r R_ª_R s =
‹	{(x,z)|∂y∑ (x,y) ç r ± (y,z) ç s}
∞
=SML
val _ = declare_alias("ª",¨$R_ª_RÆ);
val _ = declare_infix(240, "R_o_R");
val €r_o_r_def› =
πHOLCONST
‹	$€R_o_R›:('b ™ 'c) ≠ ('a ™ 'b) ≠ ('a ™ 'c)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ r s ∑ r R_o_R s = s R_ª_R r
∞
=SML
val _ = declare_alias("o",¨$R_o_RÆ);
val _ = declare_infix(240,"Ú");
val €Ú_def› =
πHOLCONST
‹	$€Ú›:('a) ≠ ('a ™ 'b) ≠ ('a ™ 'b)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ a r ∑ a Ú r = {(x,y)| x ç a ± (x,y) ç r}
∞
=SML
val _ = declare_infix(240,"í");
val €í_def› =
πHOLCONST
‹	$€í›:('a ™ 'b) ≠ ('b) ≠ ('a ™ 'b)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ a r ∑ r í a = {(x,y)| y ç a ± (x,y) ç r}
∞
=SML
val _ = declare_infix(240,"·");
val €·_def› =
πHOLCONST
‹	$€·›:('a) ≠ ('a ™ 'b) ≠ ('a ™ 'b)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ a r ∑ a · r = {(x,y)| ≥ x ç a ± (x,y) ç r}
∞
=SML
val _ = declare_infix(240,"Å");
val €Å_def› =
πHOLCONST
‹	$€Å›:('a ™ 'b) ≠ ('b) ≠ ('a ™ 'b)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ a r ∑ r Å a = {(x,y)| ≥ y ç a ± (x,y) ç r}
∞
=SML
val €inv_rel_def› =
πHOLCONST
‹	$€InvRel›:('a ™ 'b) ≠ ('b ™ 'a)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ r ∑ InvRel r = {(x,y)| (y,x) ç r}
∞
=SML
val _ = declare_alias("Á~Í",¨InvRelÆ);
val _ = declare_infix(280,"Image");
val €image_def› =
πHOLCONST
‹	$€Image›:('a ™ 'b) ≠ ('a) ≠ ('b)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ r s ∑ r Image s = {y| ∂x∑ x ç s ± (x, y) ç r}
∞
=SML
val €reflexive_def› =
πHOLCONST
‹	$€Reflexive›:('a ™ 'a) 
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Reflexive = {r | µx∑ (x, x) ç r}
∞
=SML
val €symmetric_def› =
πHOLCONST
‹	$€Symmetric›:('a ™ 'a) 
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Symmetric = {r | µx y∑ (x, y) ç r ¥ (y, x) ç r}
∞
=SML
val €transitive_def› =
πHOLCONST
‹	$€Transitive›:('a ™ 'a) 
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Transitive = {r | µx y z∑ (x, y) ç r ± (y, z) ç r ¥ (x, z) ç r}
∞
=SML
val €injective_def› =
πHOLCONST
‹	$€Injective›:('a ™ 'b) 
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Injective = {r | µx y; z∑ (x, z) ç r ± (y, z) ç r ¥ x = y}
∞
=SML
val €surjective_def› =
πHOLCONST
‹	$€Surjective›:('a ™ 'b) 
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Surjective = {r | µz∑ ∂x∑ (x, z) ç r}
∞
=SML
val €total_def› =
πHOLCONST
‹	$€Total›:('a ™ 'b) 
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Total = {r | µx∑ ∂z∑ (x, z) ç r}
∞
=SML
val €functional_def› =
πHOLCONST
‹	$€Functional›:('a ™ 'b) 
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Functional = {r | µx; w z∑ (x, w) ç r ± (x, z) ç r ¥ w = z}
∞
=SML
val _ = declare_infix(240,"´");
val €´_def› =
πHOLCONST
‹	$€´›:('a ™ 'b) ≠ ('a ™ 'b) ≠ ('a ™ 'b)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ r s ∑ r ´ s = ((Dom s) · r) ¿ s
∞
=SML
val _ = declare_postfix(300,"Á+Í");
val €tc_def› =
πHOLCONST
‹	$€Á+Í›:('a ™ 'a) ≠ ('a ™ 'a)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ r ∑ r Á+Í = •{q | r Ä q ± q ç Transitive}
∞
=SML
val _ = declare_postfix(300,"Á*Í");
val €rtc_def› = 
πHOLCONST
‹	$€Á*Í›:('a ™ 'a) ≠ ('a ™ 'a)
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ r ∑
‹	r Á*Í = •{q | r Ä q ± q ç Reflexive ± q ç Transitive}
∞
=SML
val €rel_combine_def› = 
πHOLCONST
‹	$€RelCombine›:('a ™ 'b) ≠ ('a ™ 'c) ≠ ('a ™ ('b ∏ 'c))
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	µ f g ∑ RelCombine f g 
‹	= {(x, (y,z)) | (x,y) ç f ± (x,z) ç g}
∞
=TEX
\subsection{Derived Definitions}
\subsection{End of Theory ``relation''}
\section{CONVERSIONS}
\section{PROOF CONTEXTS}
The extensional context is good for proving results involving the operators introduced in this theory.
=GFT
val pos_bits = 
	[(¨x ç $SetComp yÆ, ç_comp_conv),
	(¨x ç $Insert y zÆ, ç_enum_set_conv)] @
	(cthm_eqn_cxt initial_rw_canon ç_in_clauses) @
	(cthm_eqn_cxt initial_rw_canon sets_ext_clauses);
val neg_bits = map (mk_≥ ** RAND_C) pos_bits;
val new_bits = pos_bits @ neg_bits;
val rw_eqn_cxt =
	(¨x ç $SetComp yÆ, ç_comp_conv) ::
	(¨x ç $Insert y zÆ, ç_enum_set_conv) ::
	(flat(map (cthm_eqn_cxt initial_rw_canon) [ç_in_clauses,sets_ext_clauses]));
val dummy = (delete_pc "sets_ext" handle ? => ());
val dummy = new_pc "sets_ext";
val dummy = merge_pcs ["pair"] "sets_ext";
val dummy = ((set_st_eqn_cxt new_bits "sets_ext");
		(set_sg_eqn_cxt new_bits "sets_ext");
		(set_rw_eqn_cxt rw_eqn_cxt "sets_ext"));
=TEX
The algebraic context is for more general use where obvious simplifications are required.
=GFT
val pos_bits = 
	[(¨x ç $SetComp yÆ, ç_comp_conv),
	(¨x ç $Insert y zÆ, ç_enum_set_conv)] @
	(cthm_eqn_cxt initial_rw_canon ç_in_clauses);
val neg_strips = map (mk_≥ ** RAND_C) pos_bits;
val new_strips = pos_bits @ neg_strips;
val new_rw =
	(¨x ç $SetComp yÆ, ç_comp_conv) ::
	(¨x ç $Insert y zÆ, ç_enum_set_conv) ::
	(flat(map (cthm_eqn_cxt initial_rw_canon)
	[complement_clauses, ¿_clauses, °_clauses, set_dif_clauses,
	Ä_clauses, †_clauses, ﬁ_clauses, •_clauses, _clauses]));
val dummy = (delete_pc "sets_alg" handle ? => ());
val dummy = new_pc "sets_alg";
val dummy = merge_pcs ["pair"] "sets_alg";
val dummy = ((set_st_eqn_cxt new_strips "sets_alg");
		(set_sg_eqn_cxt new_strips "sets_alg");
		(set_rw_eqn_cxt new_rw "sets_alg"));
=TEX
=GFT
(*
val _ = pop_pc();
val _ = open_theory "sum";
val _ = (new_theory"hol";
		new_parent"one";
		new_parent"sets") handle ? => ();
*)
=SML
end; (* of structure BinRelTheory *)
open BinRelTheory;
=TEX
\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


=IGN
val €graph_thm1› = save_thm("graph_thm1", (
push_goal([], ¨Ran (Graph Graph) = Total ° FunctionalÆ);
a(PC_T "hol1"
	(rewrite_tac(map get_spec[¨RanÆ, ¨TotalÆ, ¨FunctionalÆ, ¨GraphÆ])
	THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a(∂_tac ¨x' x''Æ);
a(PC_T "hol1" (spec_nth_asm_tac 1 ¨(x'', x' x'')Æ));
(* *** Goal "2" *** *)
a(PC_T "hol1" (spec_nth_asm_tac 3 ¨(x'', w)Æ));
a(PC_T "hol1" (spec_nth_asm_tac 4 ¨(x'', z)Æ));
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¨µ x'∑ ∂ y∑ (x', y) ç x ± (µ z∑ (x', z) ç x ¥ z = y)Æ);
(* *** Goal "3.1" *** *)
a(strip_tac);
a(spec_nth_asm_tac 2 ¨x'Æ);
a(∂_tac ¨zÆ THEN REPEAT strip_tac);
a(list_spec_nth_asm_tac 3 [¨x'Æ, ¨z'Æ, ¨zÆ]);
(* *** Goal "3.2" *** *)
a(ante_tac(rewrite_rule[](µ_elim¨Ãa b∑(a, b) ç xÆ fun_rel_thm)));
a(asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(∂_tac¨fÆ);
a(PC_T "hol1" (strip_tac));
a(conv_tac(RIGHT_C(ONCE_MAP_C eq_sym_conv)));
a(asm_rewrite_tac[]);
a(PC_T "hol1" (REPEAT strip_tac));
(* *** Goal "3.2.1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3.2.2" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[]);
pop_thm()
));
