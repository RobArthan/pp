%  $Id$ %Z%
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the Theory of Relations}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Theory of Sets}
\TPPref{DS/FMU/IED/IMP071}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.B.Jones & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document creates the theory ``relation''.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion (\FormatDate{$Date$%
})]

This is the first draft of the document.

\end{description}
\subsection{Changes Forecast}

\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the theory of relations.
The design is in \cite{DS/FMU/IED/DTD071}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the theory of relations.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD071}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{THE THEORY ``relation''}
=SML
structure €BinRelTheory› : BinRelTheory = struct
val _ = open_theory "bin_rel";
val _ = push_pc "basic_hol";
=TEX
=SML
val €Ì_def› = get_defn"-""Ì";
val €∏_def› = get_defn"-""∏";
val €™_def› = get_defn"-""™";
val €dom_def› = get_defn"-""Dom";
val €ran_def› = get_defn"-""Ran";
val €id_def› = get_defn"-""Id";
val €graph_def› = get_defn"-""Graph";
val €ª_def› = get_defn"-""ª";
val €r_ª_r_def› = get_defn"-""R_ª_R";
=SML
=SML
val €r_o_r_def› = get_defn"-""R_o_R";
val €Ú_def› = get_defn"-""Ú";
val €í_def› = get_defn"-""í";
val €·_def› = get_defn"-""·";
val €Å_def› = get_defn"-""Å";
val €inv_rel_def› = get_defn"-""InvRel";
val €image_def› = get_defn"-""Image";
val €reflexive_def› = get_defn"-""Reflexive";
val €symmetric_def› = get_defn"-""Symmetric";
val €transitive_def› = get_defn"-""Transitive";
val €injective_def› = get_defn"-""Injective";
val €surjective_def› = get_defn"-""Surjective";
val €total_def› = get_defn"-""Total";
val €functional_def› = get_defn"-""Functional";
val €´_def› = get_defn"-""´";
val €tc_def› = get_defn"-""Á+Í";
val €rtc_def› = get_defn"-""Á*Í";
val €rel_combine_def› = get_defn"-""RelCombine";
=TEX
\subsection{Derived Definitions}
\subsection{End of Theory ``relation''}
\section{CONVERSIONS}
\section{PROOF CONTEXTS}
The extensional context is good for proving results involving the operators introduced in this theory.
=GFT
val pos_bits = 
	[(¨x ç $SetComp yÆ, ç_comp_conv),
	(¨x ç $Insert y zÆ, ç_enum_set_conv)] @
	(cthm_eqn_cxt initial_rw_canon ç_in_clauses) @
	(cthm_eqn_cxt initial_rw_canon sets_ext_clauses);
val neg_bits = map (mk_≥ ** RAND_C) pos_bits;
val new_bits = pos_bits @ neg_bits;
val rw_eqn_cxt =
	(¨x ç $SetComp yÆ, ç_comp_conv) ::
	(¨x ç $Insert y zÆ, ç_enum_set_conv) ::
	(flat(map (cthm_eqn_cxt initial_rw_canon) [ç_in_clauses,sets_ext_clauses]));
val dummy = (delete_pc "sets_ext" handle ? => ());
val dummy = new_pc "sets_ext";
val dummy = merge_pcs ["pair"] "sets_ext";
val dummy = ((set_st_eqn_cxt new_bits "sets_ext");
		(set_sg_eqn_cxt new_bits "sets_ext");
		(set_rw_eqn_cxt rw_eqn_cxt "sets_ext"));
=TEX
The algebraic context is for more general use where obvious simplifications are required.
=GFT
val pos_bits = 
	[(¨x ç $SetComp yÆ, ç_comp_conv),
	(¨x ç $Insert y zÆ, ç_enum_set_conv)] @
	(cthm_eqn_cxt initial_rw_canon ç_in_clauses);
val neg_strips = map (mk_≥ ** RAND_C) pos_bits;
val new_strips = pos_bits @ neg_strips;
val new_rw =
	(¨x ç $SetComp yÆ, ç_comp_conv) ::
	(¨x ç $Insert y zÆ, ç_enum_set_conv) ::
	(flat(map (cthm_eqn_cxt initial_rw_canon)
	[complement_clauses, ¿_clauses, °_clauses, set_dif_clauses,
	Ä_clauses, †_clauses, ﬁ_clauses, •_clauses, _clauses]));
val dummy = (delete_pc "sets_alg" handle ? => ());
val dummy = new_pc "sets_alg";
val dummy = merge_pcs ["pair"] "sets_alg";
val dummy = ((set_st_eqn_cxt new_strips "sets_alg");
		(set_sg_eqn_cxt new_strips "sets_alg");
		(set_rw_eqn_cxt new_rw "sets_alg"));
=TEX
=GFT
(*
val _ = pop_pc();
val _ = open_theory "sum";
val _ = (new_theory"hol";
		new_parent"one";
		new_parent"sets") handle ? => ();
*)
=SML
end; (* of structure BinRelTheory *)
open BinRelTheory;
=TEX
\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


=IGN
val €graph_thm1› = save_thm("graph_thm1", (
push_goal([], ¨Ran (Graph Graph) = Total ° FunctionalÆ);
a(PC_T "hol1"
	(rewrite_tac(map get_spec[¨RanÆ, ¨TotalÆ, ¨FunctionalÆ, ¨GraphÆ])
	THEN REPEAT strip_tac));
(* *** Goal "1" *** *)
a(∂_tac ¨x' x''Æ);
a(PC_T "hol1" (spec_nth_asm_tac 1 ¨(x'', x' x'')Æ));
(* *** Goal "2" *** *)
a(PC_T "hol1" (spec_nth_asm_tac 3 ¨(x'', w)Æ));
a(PC_T "hol1" (spec_nth_asm_tac 4 ¨(x'', z)Æ));
a(asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¨µ x'∑ ∂ y∑ (x', y) ç x ± (µ z∑ (x', z) ç x ¥ z = y)Æ);
(* *** Goal "3.1" *** *)
a(strip_tac);
a(spec_nth_asm_tac 2 ¨x'Æ);
a(∂_tac ¨zÆ THEN REPEAT strip_tac);
a(list_spec_nth_asm_tac 3 [¨x'Æ, ¨z'Æ, ¨zÆ]);
(* *** Goal "3.2" *** *)
a(ante_tac(rewrite_rule[](µ_elim¨Ãa b∑(a, b) ç xÆ fun_rel_thm)));
a(asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(∂_tac¨fÆ);
a(PC_T "hol1" (strip_tac));
a(conv_tac(RIGHT_C(ONCE_MAP_C eq_sym_conv)));
a(asm_rewrite_tac[]);
a(PC_T "hol1" (REPEAT strip_tac));
(* *** Goal "3.2.1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "3.2.2" *** *)
a(POP_ASM_T ante_tac THEN rewrite_tac[]);
pop_thm()
));
