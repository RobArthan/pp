%  %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the Theory of Relations}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Theory of Sets}
\TPPref{DS/FMU/IED/IMP071}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.B.Jones & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document creates the theory ``relation''.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{center}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{center}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}

\item[Issues 1.1 to 1.9 ]
	First drafts of the document.

\item[\FormatDate{$Date$%
}, issue \SCCSversion~]
	Add proofs of theorems.
	Add proof contexts.

%\item[\FormatDate{$Date$%
%}, issue \SCCSversion~]

\end{description}
\subsection{Changes Forecast}

\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the theory of relations.
The design is in~\cite{DS/FMU/IED/DTD071}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the theory of relations.
\subsubsection{Dependencies}
This document takes its signature from~\cite{DS/FMU/IED/DTD071}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
=IGN
None known.
=TEX
Provide a proof context for algebraic proof work involving binary relations.
\section{THE THEORY ``bin\_rel''}

=SML
structure €BinRelTheory› : BinRelTheory = struct
=TEX

=SML
val _ = open_theory "bin_rel";
val bin_rel_defs = map snd(get_defns "-");
val _ = push_pc "sets_ext";
=TEX

=SML
val _ = push_goal([],
¨
µ	a : 'a SET; b : 'b SET;
	x x1 :'a; y : 'b; z : 'c;
	r  r1 r2 : 'a ™ 'b; s : 'b ™ 'c; t : 'a ™ 'c;	q : 'a ™ 'a;
	f:'a ≠ 'b
∑
		(x Ì y ç r § (x, y) ç r)
	±	((x, y) ç (a ∏ b) § x ç a ± y ç b)
	±	(r ç (a ™ b) § r Ä (a ∏ b))
	±	(x ç Dom r § ∂y∑ (x, y) ç r)
	±	(y ç Ran r § ∂x∑ (x, y) ç r)
	±	((x, x1) ç Id a § x ç a ± x = x1)
	±	((x, y) ç Graph f § y = f x)
	±	((x, z) ç r R_ª_R s § ∂y∑ (x, y) ç r ± (y, z) ç s)
	±	((x, z) ç (s R_o_R r) § (x, z) ç r R_ª_R s)
	±	((x, y) ç a Ú r § (x, y) ç r ± x ç a)
	±	((x, y) ç r í b § (x, y) ç r ± y ç b)
	±	((x, y) ç a · r § (x, y) ç r ± ≥x ç a)
	±	((x, y) ç r Å b § (x, y) ç r ± ≥y ç b)
	±	((y, x) ç InvRel r § (x, y) ç r)
	±	(y ç r Image a § ∂x∑ (x, y) ç r ± x ç a)
	±	(q ç Reflexive § µx∑(x, x) ç q)
	±	(q ç Symmetric § µx1 x2∑(x1, x2) ç q ¥ (x2, x1) ç q)
	±	(q ç Transitive §
			µx1 x2 x3∑(x1, x2) ç q ± (x2, x3) ç q ¥ (x1, x3) ç q)
	±	(r ç Injective § µx1 x2 y∑(x1, y) ç r ± (x2, y) ç r ¥ x1 = x2)
	±	(r ç Surjective § µy∑∂x∑(x, y) ç r)
	±	(r ç Total § µx∑∂y∑(x, y) ç r)
	±	(r ç Functional § µx y1 y2∑(x, y1) ç r ± (x, y2) ç r ¥ y1 = y2)
	±	((x, y) ç r1 ´ r2 § (x, y) ç (Dom r2 · r1) ¿ r2)
	±	((x, (y, z)) ç RelCombine r t § (x, y) ç r ± (x, z) ç t)
Æ
);
=TEX

=SML
val _ = a(rewrite_tac bin_rel_defs THEN prove_tac nil);

val €rel_ç_in_clauses› = save_thm("rel_ç_in_clauses", pop_thm());
=TEX

=SML
val _ = push_goal([],
¨
µ	r1 r2 : 'a ™ 'b
∑
		((r1 † r2) § ((µ x y ∑ (x, y) ç r1 ¥ (x, y) ç r2)
			± (∂ x y ∑ ≥((x, y) ç r1) ± ((x, y) ç r2))))
	±	((r1 Ä r2) § µ x y ∑ (x, y) ç r1 ¥ (x, y) ç r2)
	±	((r1 = r2) § (µ x y ∑ (x, y) ç r1 § (x, y) ç r2))
Æ
);

val _ = a(prove_tac bin_rel_defs);
(* *** Goal "1" *** *)
val _ = a(∂_tac ¨Fst xÆ
	THEN ∂_tac ¨Snd xÆ
	THEN prove_tac [pair_clauses]);
(* *** Goal "2" *** *)
val _ = a(list_spec_nth_asm_tac 4 [¨Fst x'Æ, ¨Snd x'Æ]
	THEN swap_nth_asm_concl_tac 1
	THEN prove_tac [pair_clauses]);
(* *** Goal "3" *** *)
val _ = a(list_spec_nth_asm_tac 2 [¨Fst xÆ, ¨Snd xÆ]
	THEN swap_nth_asm_concl_tac 1
	THEN prove_tac [pair_clauses]);
(* *** Goal "4" *** *)
val _ = a(list_spec_nth_asm_tac 2 [¨Fst xÆ, ¨Snd xÆ]
	THEN swap_nth_asm_concl_tac 2
	THEN prove_tac [pair_clauses]);
(* *** Goal "5" *** *)
val _ = a(list_spec_nth_asm_tac 2 [¨Fst xÆ, ¨Snd xÆ]
	THEN swap_nth_asm_concl_tac 1
	THEN prove_tac [pair_clauses]);

val €bin_rel_ext_clauses› = save_thm("bin_rel_ext_clauses", pop_thm());
=TEX

=SML
val €Ì_def› = get_defn"-""Ì";
val €∏_def› = get_defn"-""∏";
val €™_def› = get_defn"-""™";
val €dom_def› = get_defn"-""Dom";
val €ran_def› = get_defn"-""Ran";
val €id_def› = get_defn"-""Id";
val €graph_def› = get_defn"-""Graph";
val €ª_def› = get_defn"-""ª";
val €r_ª_r_def› = get_defn"-""R_ª_R";
val €r_o_r_def› = get_defn"-""R_o_R";
val €Ú_def› = get_defn"-""Ú";
val €í_def› = get_defn"-""í";
val €·_def› = get_defn"-""·";
val €Å_def› = get_defn"-""Å";
val €inv_rel_def› = get_defn"-""InvRel";
val €image_def› = get_defn"-""Image";
val €reflexive_def› = get_defn"-""Reflexive";
val €symmetric_def› = get_defn"-""Symmetric";
val €transitive_def› = get_defn"-""Transitive";
val €injective_def› = get_defn"-""Injective";
val €surjective_def› = get_defn"-""Surjective";
val €total_def› = get_defn"-""Total";
val €functional_def› = get_defn"-""Functional";
val €´_def› = get_defn"-""´";
val €tc_def› = get_defn"-""Á+Í";
val €rtc_def› = get_defn"-""Á*Í";
val €rel_combine_def› = get_defn"-""RelCombine";
=TEX
\subsection{Derived Definitions}
\subsection{End of Theory ``relation''}
\section{CONVERSIONS}

\section{From imp076.doc: Implementation of the Proof Contexts I}

=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt initial_rw_canon) thms)
);
=TEX

\section{PROOF CONTEXTS}

\subsection{Proof Context: $'bin\_rel\_ext$}

The extensional context is good for proving results involving the
operators introduced in this theory.

=SML
val _ = (delete_pc "'bin_rel_ext"; "Deleted original proof context: 'bin_rel_ext")
	handle _ => "Could not delete original proof context: 'bin_rel_ext";
=TEX

=SML
val _ =
let
	val pos_bits =
		thms_to_eqn_cxt[rel_ç_in_clauses, bin_rel_ext_clauses]
	;
	val neg_strips = map (mk_≥ ** RAND_C) pos_bits;
	val new_strips = pos_bits @ neg_strips;
in
	new_pc					€"'bin_rel_ext"›;
	set_st_eqn_cxt	new_strips		"'bin_rel_ext";
	set_sc_eqn_cxt	new_strips		"'bin_rel_ext";
	set_rw_eqn_cxt	pos_bits		"'bin_rel_ext";
	add_rw_thms	bin_rel_defs		"'bin_rel_ext";
	set_pr_tac	basic_prove_tac		"'bin_rel_ext";
	set_pr_conv	basic_prove_conv	"'bin_rel_ext";
	commit_pc				"'bin_rel_ext";

	()
end;
=TEX

\subsection{Proof Context: $'bin\_rel\_alg$}

The number of formula that are suitable for algebraic reasoning about
binary relations seems large, here we capture a number of them.

The first source is the rules from Spivey's Z~Reference Manual~\cite{Spivey92}.
The second source is found by compiling a matrix of all the
set theory values (from~\cite{DS/FMU/IED/DTD044}) on one dimension plus
all the binary relation values on the other dimension and considering their
interactions.

--- To be provided.

\section{FINALE}

=SML
end; (* of structure BinRelTheory *)
open BinRelTheory;
=TEX

\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
