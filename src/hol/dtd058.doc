=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of Automatic Existence Proofs}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD058}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D. Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design
of the tools providing automated existence proofs.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item[Issue 1.1] 
First version.
\end{description}
\subsection{Changes Forecast}
None known.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Tools providing automatic existence proofs
are a supporting tools for the specification of constants
and are called for in \cite{DS/FMU/IED/HLD010}.
This document provides a detailed design for these tools.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the
tools supporting automatic existence proofs.
These are required both to asist in constant specification (See $const\_spec$) and
as independent tools.
\subsubsection{Dependencies}
This document depends upon the paired-abstraction inference rules of
\cite{DS/FMU/IED/DTD027}.
\subsubsection{Deficiencies}
The coverage of the material provided is uneven (e.g.
there is only ever one of a simple and paired form of a function).
This is the result of the functions being a toolbox to achieve
a particular goal.

$evaluate\_proof\_context$ duplicates the entry in \cite{DS/FMU/IED/DTD026}, though the implementation is incomplete
in \cite{DS/FMU/IED/IMP026}.
\subsubsection{Possible Enhancements}
None known.
\section{METHODS AND ISSUES}

\section{PREAMBLE}
=DOC
signature ‚ExistenceProofs·  = sig
=DESCRIBE
This is the signature of a structure supporting automatic existence proofs.
=ENDDOC
\section{THE DESIGN}
\subsection{Components}
Some of the components that go to make up the main functions
are of interest in their own right.
They are presented here.
\subsubsection{Conversionals}
=DOC
val ‚ALL_SIMPLE_É_C· : CONV -> CONV;
val ‚ALL_SIMPLE_Ñ_C· : CONV -> CONV;
=DESCRIBE
These respectively apply their conversion argument to:
\begin{itemize}
\item
The body of a repeated simple universal quantification.
\item
The body of a repeated simple existential quantification.
\end{itemize}
=FAILUREC
\paragraph{Errors}
As the failure of the conversion argument.
=ENDDOC
=DOC
val ‚ALL_Ä_C· : CONV -> CONV;
val ‚ALL_Å_C· : CONV -> CONV;
=DESCRIBE
These respectively apply their conversion argument to:
\begin{itemize}
\item
All the conjuncts of a structure of conjuncts (including a term that is not a conjunct at all)
failing only if the conversion fails for all the conjuncts.
\item
All the disjuncts of a structure of disjuncts (including a term that is not a disjunct at all)
failing only if the conversion fails for all the disjuncts.
\end{itemize}
The result is simplified at any conjunct 
or disjunct where at least one branch had a successful
application of the conversion and matches the appropriate theorems of:
Û
Ö É té (T Ä t Ç t) Ä (t Ä T Ç t) Ä å (F Ä t) Ä å (t Ä F) Ä (t Ä t Ç t)

Ö É té (T Å t) Ä (t Å T) Ä (F Å t Ç t) Ä (t Å F Ç t) Ä (t Å t Ç t)
Ê
=FAILUREC
\paragraph{Errors}
As the failure of the conversion argument.
=ENDDOC
\subsubsection{Conversions}
=DOC
val ‚simple_Ñ_Å_conv·: CONV;
=DESCRIBE
This conversion will push simple existential quantifiers
into a term body that consists of nested disjunctions.
It will prove the input equal to a term formed by disjoining
the list of disjuncts, existentially quantified
by any of the original quantifiers that are free in that disjunct.
=CONVERSION
simple_Ñ_Å_conv
ªÑ x1 ... xn é P [y1 ... ym] Å Q [z1 ...zo]º
…
…
Ö (Ñ x1 ... xn é P [y1 ... ym] Å Q [z1 ...zo]) Ç
	(Ñ y1 ... ym é P [y1 ... ym]) Å
	(Ñ z1 ... zo é P [z1 ... zo])
=TEX
=TEX
where $\{y1...ym\}\ •\ \{x1 ... xn\}$, and
$\{z1...zo\}\ •\ \{x1 ... xn\}$.
The conversion will actually distribute over an arbitrary disjunctive
structure, though the result is ``flattened''.
=EXAMPLE
simple_Ñ_Å_conv ªÑ x y é f x Å g yº =
	Ö (Ñ x y é f x Å g y) Ç (Ñ x é f x) Å (Ñ y é g y)

simple_Ñ_Å_conv ªÑ x y é f x Å g y Å h x y Å iº =
	Ö (Ñ x y é f x Å g y Å h x y Å i) Ç 
		(Ñ x é f x) 
		Å (Ñ y é g y)
		Å (Ñ x y é h x y)
		Å i
=SEEALSO
$Ñ\_uncurry\_conv$ to uncurry any paired $Ñ$-abstractions.
$simple\_Ñ\_Ä\_conv$.
=FAILURE
58010	?0 is not of the form: ªÑ x1 ... é a Å bº
58015	Unexpected feature of ?0 caused failure
=ENDDOC
This function, and others, are designed to try, and fail in special cases,
rather than catch all problems.
Thus just in case we give error message 58015:
=FAILURE
58015	Unexpected feature of ?0 caused failure
=TEX
=DOC
val ‚simple_Ñ_Ä_conv·: CONV;
=DESCRIBE
This conversion will push simple existential quantifiers
into a term body that consists of nested conjunctions
when not all the conjuncts have all of the quantified
variables free in them.
It will prove the input equal to a term formed by conjoining
the list of existentially quantified groupings
of conjuncts, grouped by possession of a quantified
variable free in each of the group.
It may not necessarily form the ``most pushed in'' form
with each conjunct minimally bound,
but will do some pushing in if any is available.
=CONVERSION
simple_Ñ_Ä_conv
ªÑ x1 ... xn é 
.... Ä P[y1...ym] Ä ....º
…
…
(Ñ x1 ... xn é .... Ä P[y1...ym] Ä ....)
 Ç
<pushed in form>
=TEX
where the $y_i$ are a subset of the $x_j$.
=EXAMPLE
simple_Ñ_Ä_conv ªÑ x é P[x] Ä Qº =
	 Ö (Ñ x é P[x] Ä Q) Ç (Ñ x é P[x]) Ä Q

simple_Ñ_Ä_conv ªÑ x é P Ä Q[x]º =
	 Ö (Ñ x é P Ä Q[x]) Ç (Ñ x é Q[x]) Ä P

simple_Ñ_Ä_conv ªÑ x y é P[x] Ä Q[y]º =
	Ö (Ñ x y é P[x] Ä Q[y]) Ç (Ñ y é Q[y]) Ä (Ñ x éP[x])

simple_Ñ_Ä_conv ªÑ x y z é P[x, z] Ä Q[y, z]º =
	Ö (Ñ x y z é P[x, z] Ä Q[y, z]) Ç 
	Ñ z é (Ñ y é Q[y, z]) Ä (Ñ x éP[x, z])
=TEX
The original conjunctive structure and ordering is lost.
=SEEALSO
$Ñ\_uncurry\_conv$ to uncurry any paired $Ñ$-abstractions.
$simple\_Ñ\_Å\_conv$.
=FAILURE
58012	?0 is not of the form: ªÑ x1 ... é a Ä bº
58014	All conjuncts of ?0 have all existentially quantified variables
	free within them
=ENDDOC
=DOC
val ‚É_Ä_conv·: CONV;
=DESCRIBE
This conversion will push universal quantifiers
into a term body that consists of nested conjunctions.
It will prove the input equal to a term formed by conjoining
the list of conjuncts, universally quantified
by any of the original quantifiers that are free in that conjunct.
=CONVERSION
É_Ä_conv
ªÉ x1 ... xn é P [y1 ... ym]
Ä Q [z1 ...zo]º
…
…
Ö (É x1 ... xn é P [y1 ... ym] Ä Q [z1 ...zo]) 
	Ç
	(É y1 ... ym é P [y1 ... ym]) Ä
	(É z1 ... zo é P [z1 ... zo])
=TEX
where $\{y1...ym\}\ •\ \{x1 ... xn\}$, and
$\{z1...zo\}\ •\ \{x1 ... xn\}$.
The conversion will actually distribute over an arbitrary conjunctive
structure, though the result is ``flattened''.
The conversion will work with paired universal quantifiers,
and will still return a result even if
it only acts as $all\-\_É\-\_uncurry\-\_conv$ (q.v.), and does not
redistribute the quantifiers any further.
=EXAMPLE
É_Ä_conv ªÉ x y é f x Ä g yº =
	Ö (É x y é f x Ä g y) Ç (É x é f x) Ä (É y é g y)

É_Ä_conv ªÉ x y é f x Ä g y Ä h x y Ä iº =
	Ö (É x y é f x Ä g y Ä h x y Ä i) Ç 
		(É x é f x) 
		Ä (É y é g y)
		Ä (É x y é h x y)
		Ä i
=SEEALSO
$É\_uncurry\_conv$ to uncurry any paired $Ñ$-abstractions.
=FAILURE
58020	?0 is not of the form: ªÉ x1 ... é a Ä bº
=ENDDOC

=DOC
val ‚simple_É_Ñ_conv·: CONV;
=DESCRIBE
Swap the order of a simple $É$ and $Ñ$:
=CONVERSION
simple_É_Ñ_conv
ªÉ x é Ñ y é P[x,y]º
…
…
Ö (É x é Ñ y é P[x,y]) Ç 
	(Ñ y' é É x é P[x, y' x])
=TEX
where $y'$ is renamed to distinguish it from $y$ (for the types differ) and every other term variable in the argument.
=FAILURE
58016	?0 is not of the form: ªÉ x é Ñ y é P[x,y]º
=ENDDOC
=DOC
val ‚simple_Ñ_É_conv·: CONV;
=DESCRIBE
Swap the order of a simple $Ñ$ and $É$:
=CONVERSION
simple_Ñ_É_conv
ªÑ x é É y é P[x,y]º
…
…
Ö (Ñ x é É y é P[x,y]) Ç 
	(É y' é Ñ x é P[x, y' x])
=TEX
where $y'$ is renamed to distinguish it from $y$ (for the types differ) and every other term variable in the argument.
=FAILURE
58017	?0 is not of the form: ªÑ x é É y é P[x,y]º
=ENDDOC
=DOC
val ‚simple_Ñ_É_conv1·: CONV;
=DESCRIBE
Swap the order of a simple $Ñ$ and $É$, where the first variable is always applied to the second:
=CONVERSION
simple_Ñ_É_conv1
ªÑ f é É x é P[f x, x]º
…
…
(Ñ f é É x é P[f x, x]) Ç (É x é Ñ f' é P[f', x])
=TEX
where $f'$ is renamed to distinguish it from $f$ (for the types differ) and every other term variable in the argument.
=FAILURE
58019	?0 is not of the form: ªÑ f é É x é P[f x,x]º
=ENDDOC
There is a potential design error in these two functions,
that is checked for ``just in case''.
=FAILURE
58018	DESIGN ERROR: resulting theorem for ?0 could not 
	be coerced to correct LHS
=TEX

\subsection{Automatically Proving Existential Properties}
=DOC
val ‚simple_Ñ_equation_conv· : CONV;
=DESCRIBE
This conversion eliminates a simple existential quantifier that is equated to 
a term within the body of the quantification.
The term equated with must not contain the existential quantifier,
nor may it have free variables that are bound in the
body of the existential quantifier, other than in an outer
existential.
The equation must also be ``reached'' only through 
existential and universal quantifications, $Ä$ and $Å$.
Implicit equations (e.g. an implicit $Ç\ T$ or by $å$) are also handled.
=CONVERSION
simple_Ñ_equation_conv
ªÑ f é P (f = tm) f º
…
…
Ö (Ñ f é P [(f = tm), f]) Ç P [T, tm]
=TEX
Some simplification will also take place if any of the following apply where the $T$ replaced the equation:
Û
	[Ä_rewrite_thm, Ñ_rewrite_thm,
	É_rewrite_thm, eq_rewrite_thm, 
	ä_rewrite_thm, å_rewrite_thm]
Ê
=EXAMPLES
simple_Ñ_equation_conv ªÑ f é f = xº =
	Ö (Ñ f é f = x) Ç T

simple_Ñ_equation_conv ªÑ f é x = fº =
	Ö (Ñ f é x = f) Ç T

simple_Ñ_equation_conv ªÑ f é (f = x) Ä P fº =
	Ö (Ñ f é (f = x) Ä P f) Ç P x

simple_Ñ_equation_conv ªÑ f g é (f = g) Ä P fº =
	Ö (Ñ f g é (f = g) Ä P f) Ç Ñ g éP g

simple_Ñ_equation_conv ªÑ f é f Ä P fº =
	Ö (Ñ f é f Ä P f) Ç P T

simple_Ñ_equation_conv ªÑ f é å f Ä P fº =
	Ö (Ñ f é å f Ä P f) Ç P F
=SEEALSO
$prove\_Ñ\_conv$ for a more powerful existence prover.
=FAILURE
3034	?0 is not of form: ªÑ var é bodyº
58013	Cannot find an equation in ?0 to simplify
58022	Could not proved ?0 by selected witness ?1
=ENDDOC
\subsection {The Main Functions}
=DOC
val ‚prove_Ñ_conv· : CONV;
=DESCRIBE
This is an automatic existence prover.
It uses its internal mechanisms, and material stored in the current proof context to attempt to prove a ``simpler'' term
equal to the conversion argument, which must be of the
form $ªÑ ...º$.
It will simplify by:
\begin{itemize}
\item
Converting paired existential quantifiers into simple ones (see $all\-\_Ñ\-\_uncurry\-\_conv$).
\item
Removing existential and universal quantifiers not used in the body of their
quantification.
\item
Distributing existential quantifiers over $Ä$ and $Å$ as far
as it is able (see $simple\_Ñ\_Ä\_conv$ and $simple\_Ñ\_Å\_conv$).
\item
Eliminating an existential quantifier that is equated to 
a term within the body of the quantification.
The term must not contain the existential quantifier,
nor may it have free variables that are bound in the
body of the existential quantifier, other than in an outer
existential.
Implicit equations (e.g. an implicit $Ç\ T$ or by $å$) are also handled
(see $simple\_Ñ\-\_equation\-\_conv$).
\item
``Pulling out'' universal quantifiers through existential
quantifiers if the existential is a function applied in all its instances
to the universally quantified variables
(see $simple\_Ñ\_É\_conv1$), or variable structures
formed by data constructors accessed by $get\_epc\_Ñ\_vs\_thm$ in the current proof context.
Redistribution of universals and data constructions may be done to allow this simplification to apply.
\item
Uncurrying existential quantifiers that are curried functions.
\item
Simplifying existential quantifiers that match the pattern of
use of recursive functions held by $get\_epc\_Ñ\_single\_dc$ in the current proof context.
\item
Traversing subterms reached from the outside of the term through (perhaps paired)
existential and universal quantifiers, and $Ä$ or $Å$ operators.
\end{itemize}
It will repeat its simplification attempts until it can go no further.
=CONVERSION
prove_Ñ_conv
ªÑ decls é predº
…
…
Ö (Ñ decls é pred) Ç simpler
=TEX
=USES
To implement $prove\_Ñ\_rule/tac$ (q.v),
and to be used directly.
=FAILURE
58001	?0 is not of the form: ªÑ decls é predº
58002	Failed to simplify ?0
=ENDDOC
=DOC
val ‚prove_Ñ_rule· : TERM -> THM;
=DESCRIBE
This will attempt to simplify its argument to $T$, by using 
$prove\_Ñ\_conv$ (q.v.).
If it succeeds, it returns the theorem with $Ç\ T$ stripped off.
=RULE
prove_Ñ_rule
ªÑ decls é predº
…
…
Ö Ñ decls é pred
=TEX
=USES
As an appropriate argument for $set\_epc\_cs\_Ñ\_rule$,
and as a stand-alone tool.
=FAILURE
58001	?0 is not of the form: ªÑ decls é predº
58002	Failed to simplify ?0
58003	Failed to prove ?0
=FAILUREC
We distinguish between no simplification, and failing to prove a term,
to indicate whether $prove\_Ñ\_conv$ may be of initial use in a manual proof of the term.
=ENDDOC
=DOC
val ‚prove_Ñ_tac· : TACTIC;
=DESCRIBE
This will attempt to prove its goal, by using 
$prove\_Ñ\_conv$ (q.v.).
If $prove\_Ñ\_conv$ fails, or only partially succeeds,
then the tactic will fail.
=TACTIC
prove_Ñ_tac
…
{ ˆ } Ñ decls é pred
…
=TEX
=FAILURE
58004	Goal is not of the form: { ˆ } Ñ decls é pred
58005	Failed to simplify goal
58006	Failed to prove goal
=FAILUREC
We distinguish between no simplification, and failing to prove a term,
to indicate whether $prove\_Ñ\_conv$ may be of initial use in a manual proof of the term.
=ENDDOC
\subsection{Proof Contexts}
=DOC
val ‚evaluate_Ñ_cd_thm· : THM ->
	(TERM list * int list * TYPE * (TERM list)list * THM);
=DESCRIBE
This gives the sophisticated user direct access to the internal mechanism
in $evaluate\_proof\_context$ for evaluating 
the input to $set\_pc\_Ñ\_cd\_thm$.
Its input theorem is of the ``standard'' form of a primitive recursion theorem or pattern matching theorem:
Û
É fn1 fn2 ... é
Ñ%down%1 f é
(É a11 ... é f (dc1[a11,...]) = fn1 (patt11[f,a11...]) (patt12[f,a11,...]) ...) Ä
(É a21 ... é f (dc2[a21,...]) = fn1 (patt21[f,a21...]) (patt22[f,a21,...]) ...) Ä
...
Ê
Compare this with:
Û
prim_rec_thm =
Ö É z sé Ñ%down%1 fé (f 0 = z) Ä (É né f (n + 1) = s (f n) n)  
Ê
The $fn_i$ (in example - $z$ and $s$) are the new functions which express the behaviour
of each data constructor.
$f$ ($f$) is the function defined by clausal definitions.
The $a_{ij}$ ($n$ in the second conjunct) are the free variables of the data construction.
The $dc_i$ ($n+1$ and $0$) are data constructions, as in the example given these do not need to be the original data constructors of a type, just applications of constants and variables.
The $patt_{ij}$ ($f\ n$, $n$) are the arguments to the new functions. 
They may involve uses of the clausally defined function.

The result of this function is:
the list of data constructions,
a list of the number of free variables in each data construction,
the type of $f$,
a list of free variables in the data constructions,
and a theorem of the form:
Û
É pred1 ... é
(Ñ f é (É a11 ... é pred1 (dc1[...]) (patt1[...]) ..) Ä ...) Ç
((É x11 ... x1n é Ñ y1 é pred1 y11 x11 ...) Ä ...) Å
(CombI(Ñ f é (É a11 ... é pred1 (dc1[...]) (patt1[...]) ..) Ä ...))
Ê
This is in a convenient form for proving the existence of
clausally defined functions, in particular
recursive functions within $prove\_Ñ\_conv$.
The $pred_i$, $x_{ij}$ and $y_i$ are generated by $gen\_vars$.
=FAILURE
58007	?0 is not of the form: `Ö É ... é Ñ%down%1 f é ...`
58008	?0 has a conjunct not of the form: ªÉ ... é f dc = ...º
58009	?0 has a conjunct not of the form: ªÉ ... é f dc = ...º 
	where f is the function whose existence is to be proven
58021	Failed to prove new theorem based on ?0
58023	?0 has a conjunct not of the form: ªÉ ...P... é f dc = P ...º 
=ENDDOC
=DOC
val ‚prove_Ñ_pc· : PROOF_CONTEXT;
val ‚prove_Ñ_epc· : EPROOF_CONTEXT;
=DESCRIBE
These are respectively:
Û
set_pc_name "prove_Ñ_pc"
(set_pc_cs_Ñ_rule prove_Ñ_rule
(set_pc_Ñ_vs_thm [(",",([ªFstº,ªSndº],pair_rewrite_thm))]
(set_pc_Ñ_cd_thm [prim_rec_thm,
	list_prim_rec_thm,
	(rewrite_rule[ext_thm, o_def] sum_fns_thm)]
pair_pc)));
Ê
and the evaluated form (via $evaluate\_proof\_context$ ``$prove\_Ñ\_epc$'')
based on this.
=ENDDOC
The following function needs implementing after the
methods of initialising all configurable proof tools have been introduced.
Thus it will probably migrate from this document in the future.
The need for this function is discussed in \cite{DS/FMU/IED/DTD051}.
It is currently also declared in \cite{DS/FMU/IED/DTD026},
but this version overwrites that one
(by adding parameterisation of the existence prover $prove\_Ñ\_conv$).
=DOC
val ‚evaluate_proof_context· : string -> PROOF_CONTEXT -> EPROOF_CONTEXT;
=DESCRIBE
This function converts the user-presentation style of a 
proof context into one that may be set using $push\_proof\_context$ (q.v).
The string argument is the name of the resulting context.
=ENDDOC

\section{EPILOGUE}
=SML
end; (* of signature ExistenceProofs *)
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
