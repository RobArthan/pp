%  imp006.doc  %Z% $Date: 2001/07/30 14:29:12 $ $Revision: 1.48 $ $RCSfile: imp006.doc,v $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for Abstract Data Type $THM$}  %% Mandatory field
\def\TPPheadtitle{Implementation for Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/IMP006}  %% Mandatory field
\def\SCCSversion{$Revision: 1.48 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2001/07/30 14:29:12 $ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2,1.3,1.4]
Still being created.
\item [Issue 1.5]
First version working with a version of \cite{DS/FMU/IED/DTD006}.
\item [Issue 1.6]
Minor Corrections.
Functions more closely related to the specifications.
\item [Issue 1.7]
Added $get\_constant\_type$ and $get\_type\_arity$.
\item [Issue 1.8]
Prevented negative arity types.
$icl'get\_theory\_name$ no longer given deleted theory names.
Corrected some $fail$ calls.
\item [Issue 1.9]
Replaced local $set\_equal$ with function from utilities.
Removed open dictionaries statement.
\item [Issue 1.10]
Corrections after comments by RDA.
No external functionality change, merely tidying up.
\item [Issue 1.11]
Made the function $icl'list\_simple\_µ\_elim$ primitive, rather than $icl'simple\-\_µ\-\_elim$.
Renamed $get\_constant\_type$ as $get\_const\_type$.
Added $icl'seal\_hierarchy$.
\item [Issue 1.12]
Use $term\_mem$ etc.
\item [Issue 1.13]
Corrected error message, and execution, of $list\_simple\_µ\_elim$. 
\item [Issue 1.14]
Errors 6008, 6032, 6036, 6041, 6065, 6066, 6070, 6072, 6073, 6074, 6083 are now all raised by $error$ not $fail$
(only some were before).
The name atom ``theorem(s)'' has been consistently changed
to ``thm(s)'', 
and ``definition(s)'' to ``defn(s)''.
Corrected result of $get\_con\_env\ ""$.
\item [Issue 1.15]
Change the flag character used for character literals.
\item [Issue 1.16]
Corrected a flaw in $icl'open\_theory$ concerning scopes.
\item [Issue 1.17]
Corrected a flaw in $icl'new\_parent$ concerning scope checking.
Added $valid\_thm$.
\item [Issue 1.18]
Changed as result of changes caused by IR0016.
\item [Issue 1.19,1.20]
Changes to match issue 1.17 of \cite{DS/FMU/IED/DTD006}.
\item [Issue 1.21]
Eliminated message 6009.
Catch $mk\_const$ errors.
\item [Issue 1.22]
Fixed the use of message 6061.
\item [Issue 1.23]
Changes in response to ID0021.
\item [Issue 1.24]
Renamings of functions containing the name atom $simple$,
and renaming of $aconv$.
\item [Issue 1.25]
Corrected $icl'new\_parent$, to ensure it checks for clashes in children of current theory.
\item [Issue 1.26,1.27]
Tidying up prior to a desk check.
\item [Issue 1.28]
Correcting problems to do with saving and getting hierarchies.
\item [Issue 1.29,1.30]
Added $icl'plus\_conv$, removed $icl'div2\_conv$ and $icl'mod2\_conv$,
following change request CR007.
\item[Issue 31, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.32]
Changes to using sparse arrays from \cite{DS/FMU/IED/DTD001},
rather than local structure.
\item [Issue 1.33]
Fixed a bug in $new\_parent$.
\item [Issue 1.34 ]
Put $translate\_for\_output$ around uses of $makestring$.
\item [Issue 1.36 (13th April 1992)]
Changes due to CR0017.
\item [Issue 1.37 (6th May 1992)]
$icl'load\_hierarchy$ sets $inscope$ fields correctly.
\item [Issue 1.38 (20th May 1992)]
Added $icl'get\_pervasive\_theory\_name$.
\item [Issue 1.39 (21st May 1992)]
Improved 6056.
\item [Issue 1.40 (1 June 1992)]
Do not do a $translate\_for\_output$, undo change~1.34.
\item [Issue 1.41 (14th July 1992)]
Collapsed error 6052 into 6051.
\item [Issue 1.42 (12th August 1992)]
Improved error handling of $valid\_thm$.
\item [Issue 1.43 (13th August 1992)]
Corrected error handling for interrupts.
\item [Issue 1.44 (18th January 1993)]
Made inconsistency ``flag'' part of a hierarchy.
\item [Issue 1.45 (4th November 1994)]
Fixed bug 167.
\item [Issue 1.46 (11th February 1999)]
Update for SML'97.
\item[Issue 1.47] Use of new INTEGER type.
\item[Issue 1.48] Performance improvement in {\it icl'inst\_term\_rule}.
\item[Issues 1.49, 1.50] Performance improvement when checking additions to the the theory: removed
redundant linear search of current theory for constant names and type names and introduced
efficient dictionaries for axiom, definiition and theorem keys.
\end{description}
% \subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the abstract data type $THM$.
This includes its
primitive and built-in inference rules,
and its theory management material.
This is called for in section 4 of \cite{DS/FMU/IED/HLD007}.
The high-level specification for the code is
given in \cite{DS/FMU/IED/SPC003}, \cite{DS/FMU/IED/SPC004} and \cite{DS/FMU/IED/SPC005}.
The design is in \cite{DS/FMU/IED/DTD006}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the 
abstract data type $THM$.
This includes its
primitive and built-in inference rules,
and its theory management material.
A ``primitive'' inference rule is considered to be part of the logic,
whereas a built-in rule is one that, though it could be coded in terms 
of the primitive rules, will actually be part of the abstract data type $THM$, and thus taken as holding true without checking.

We have to assume that single assignments cannot be interrupted,
but that any sequence of commands may be.
We need to maintain consistency between certain parts of state,
and thus we have some protected functions,
see section \ref{Inconsistent}.

When handling hierarchies it should be borne in mind that
the only function that may change the address of the current
hierarchy is $icl'load\_hierarchy$.
This is so that the addresses in $icl'new\_hierarchy$
remain current until the next $icl'load\_hierarchy$. 
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD006},
and also requires those files indicated as preceding it in the 
rel001 makefile.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.

\newpage
\section{INTERRUPTS AND INCONSISTENCY}
\label{Inconsistent}
There are three activities we sometimes wish to do in uninterruptable combinations.
Interrupts might be, for instance, due to the user pressing Control-C, or the program running out of machine resources.
\begin{description}
\item[1]
``In place'' modification of $icl'THEORY\_INFO$s within the hierarchy, using the fact that the hierarchy is an (imperative-style) array and using array assignment.
\item[2]
Changes to the current state, other than ``in place''. 
In particular, modifications to the type and constructor environments $ty\-\_env$ and $con\-\_env$.
\item[3]
Assignments to the current theory address, to update the theory rather than change the theory that is current.
\end{description}
If combinations of these were interrupted they might lead to some of the following:
\begin{itemize}
\item
The type or constructor environments containing items that are not actually within any theory in scope.
This can cause theorems to be apparently valid, when in fact they are not.
\item
The type or constructor environments failing to contain items that are actually within some theory in scope.
This could allow the redefinition of such things while theorems concerning
the old definition are still in scope
(and are made valid once more by the redefinition placing the items in the type or constructor environment).
\item
A theory may have another as parent that does not record its child in its $children$ field
(we take the $parents$ field as definitive).
This would allow the parent to declare things that clashed with its child's contents, and would sometimes allow the parent to be deleted
leaving an orphan.
\item
A theory may indicate it has another as a child, while the so-called child does not record the other as parent.
This will cause the parent to be unable to redefine things present in the so-called child that strictly it should be able to do.
This is not inconsistent, but only inconvenient.
\item 
Having the $inscope$ fields inconsistent with the current theory and the parentage relation has the same problems as the $children$ field being inconsistent.
If the $inscope$ fields are inconsistent with the type and constant environments
then this will give rise to the same problems as if those are
inconsistent with the theory's contents.
\end{itemize}
These problems could occur in the following functions,
the numbers in brackets refer to the kind of changes made: 1, 2, or 3.

\begin{tabular}{| l | p{4.7in}|}\hline
Function & Combination \\ \hline
$icl'open\_theory$ & Multiple ``in place'' modifications to the hierarchy and environments, and a change of address for the current theory(1,2). \\
$icl'delete\_theory$ & Multiple ``in place'' modifications to the hierarchy: the deleted theory, and its parents. Can also leave
some garbage if interrupted(1). \\
$icl'new\_theory$ & Two ``in place'' modifications to the hierarchy
(the new theory and parent) (1). \\
$icl'duplicate\_theory$ & Multiple ``in place'' modifications to the hierarchy
(new theory and its parents)(1). \\
$icl'freeze\_hierarchy$ & Multiple ``in place'' modifications to the hierarchy
(all theories)(1). \\
$delete\_extension$ & Deletions from environments and an assignment to current theory address(2,3). \\
$icl'new\_const$ & Addition to constant environment and an assignment to current theory address(2,3). \\
$icl'new\_type$ & Addition to type environment and an assignment to current theory address(2,3). \\
$icl'new\_defn$ & Addition to constant environment and an assignment to current theory address(2,3). \\
$icl'new\_type\_defn$ & Addition to type environment and an assignment to current theory address(2,3). \\
$icl'new\_spec$ & Additions to constant environment and an assignment to current theory address(2,3). \\
$icl'new\_parent$ & Additions to constant and type environments, an assignment to current theory address, and ``in place'' modifications to the hierarchy (new parent and current theory)(2,3). \\ \hline
\end{tabular}

These problems occur because we maintain ``value added'' copies of 
definitive information, usually to increase speed.
One solution would be to eliminate the copies, and accept the time
cost: this seems an unreasonable deal, and might not solve the 
problem.
Another solution would be to maintain a backup of the entire system
to be reverted to in the case of an error. 
This would have a time penalty, would have to be careful in
avoiding introducing inconsistencies, and might be vulnerable to multiple interrupts.

We choose as a solution the introduction of a boolean flag in $HIERARCHY$ (q.v.),
that is set on entering a block of code that is dangerous if interrupted,
and reset on exiting normally.
An interrupt will leave the flag set.
All validity checkers, in particular $check\_thm$ (q.v)
and $check\_c\_writable$
(``check current theory writable'', q.v.),
will check the flag, and if it is set then the validity check will fail.
Thus an unfortunately timed interrupt could render the system ``you can look, but you can't touch''.
This is indicated by the error message:

=GFT Error Declaration
6083	STATE WAS FOUND TO BE INCONSISTENT: state is now read-only, and
	you are advised to quit ICL HOL. Do not commit the ML database.
=TEX

\section{THE ABSTRACT DATA TYPE $THM$}
=SML
structure €icl'Kernel› : icl'Kernel = struct
=TEX
\subsection{Utilities}
=SML
fun €max› (a:int) (b:int) : int = if a > b
	then a
	else b;
=TEX
The following is a function to give the maximum of a list of numbers.
The maximum of n empty list is $0$ (could be made a fail).
=SML
fun €list_max› ([]: int list): int = 0
| list_max (a :: x) = (
let	fun aux (sf:int) ((p :: q):int list) : int = (
	if sf < p
	then aux p q
	else aux sf q
	) | aux sf [] = sf;
in
	aux a x
end);
=TEX
Give a list of HOL type variables $'1, '2,\ldots$:
=SML
fun €ntyvars› (n : int) : TYPE list = (
	map (fn x=> mk_vartype("'"^string_of_int x))
		(interval 1 n)
);
=TEX
Find two elements that are the same (presuming $all\_different$ has failed):
=SML
fun €two_the_same› ((a :: x): ''a list) : ''a = (
	if a mem x
	then a
	else two_the_same x
) | two_the_same _ = error "two_the_same" 6032 [];
=TEX
=SML
fun €two_the_same1› (eq : 'a * 'a -> bool) ((a :: x): 'a list) : 'a = (
	if present eq a x
	then a
	else two_the_same1 eq x
) | two_the_same1 _ _ = error "two_the_same1" 6032 [];
=TEX
=SML
fun €st_equals› (((nm1,ty1):string * TYPE), ((nm2,ty2):string * TYPE))  : bool = (
	nm1 = nm2 andalso ty1 =: ty2
);
=TEX
\subsubsection{Ranges}
We are interested in supporting ranges of deleted levels,
but the code can be given in isolation from
the type of theories.

We are interested in a list of numbers,
\[ [ (a_{1},\ b_{1}),\ (a_{2},\ b_{2}),\ ...,\ (a_n,\ b_n)]\]
where $b_{i-1}$ is always less than $a_i$,
$0\ <\ a_1$, 
and $a_i$ is always less than or equal to $b_i$.

First, we wish to check whether a number fails inside any of the ranges $a_i$ to $b_i$.
=SML
fun €range_mem› (v : int, [] : (int * int)list) = false
| range_mem (v, ((a,b) :: x)) = (
	(v >= a) andalso 
	((v <= b) orelse range_mem(v, x))
);
=TEX
Second, we wish to extend the range by adding (a,b), which may enclose other ranges.
=SML
fun €extend_range› (a:int,b:int) ([]:(int * int)list): (int * int)list= (
	[(a,b)]
) | extend_range (a,b) (lst as ((a1,b1) :: x)) = (
let
	fun fixb lw (lst1 as ((a2,b2) :: x1)) = (
		if b + 1 < a2
		then ((lw,b) :: lst1)
		else if b <= b2
		then ((lw,b2) :: x1)
		else fixb lw x1
	) | fixb lw [] = [(lw,b)];
in
	if a < a1 
	then fixb a lst
	else if b1+1 < a
	then ((a1,b1) :: extend_range (a,b) x)	
	else fixb a1 lst
end);
=IGN
val p = [(1,2), (6,8), (10,10), (12,13)];
extend_range (0,3) p;
extend_range (4,4) p;
extend_range (5,5) p;
extend_range (11,15) p;
extend_range (11,11) p;

=TEX
We will use the sparse array material of \cite{DS/FMU/IED/DTD001}
=SML
open SparseArray;
=TEX
\subsection{Types of the ADT $THM$}
A fragment of some user data, and a collection of such
fragments:
=SML
datatype €USER_DATUM› =
	€UD_Term› of TERM * (USER_DATUM list) |
	€UD_Type› of TYPE * (USER_DATUM list) |
	€UD_String› of string * (USER_DATUM list) |
	€UD_Int› of int * (USER_DATUM list);

type €USER_DATA› = (USER_DATUM ref) S_DICT;
=TEX
The type of sequents:
=SML
type €SEQ› = TERM list * TERM;
=TEX
The type of the theory status:
=SML
datatype €THEORY_STATUS› =
	€TSNormal› | €TSLocked› | €TSAncestor› | €TSDeleted›;
=TEX
=SML
abstype €THM› = €Thm› of {
		level : int,
		theory : icl'THEORY ref, 
		sequent : SEQ}
and
	€icl'THEORY› = €Thy› of {
		name : int,
		ty_env : {arity:int, level:int} S_DICT,
		con_env : {ty:TYPE, level:int} S_DICT,
		parents : int list,
		del_levels : (int * int) list,
		axiom_dict : THM S_DICT,
		defn_dict : THM S_DICT,
		thm_dict : THM S_DICT,
		current_level : int,
		user_data : USER_DATA ref}
and
	€icl'THEORY_INFO› = €ThyInfo› of {
		status : THEORY_STATUS,
		inscope : bool,
		contents : icl'THEORY ref,
		children : int list,
		name : string}
and
=TEX
In a hierarchy there will be:
\begin{itemize}
\item
A boolean flag which is $false$ if the hierarchy is consistent, and true otherwise.
If a new hierarchy is loaded then the new consistency will be the new flag alone. 
I.e. the new hierachy is not necessarily recorded as inconsistent if the old one was.
\item
An array of theory information blocks.
This will contain theories with internal names $0$ to length of array, though some may have the status ``deleted''.
\end{itemize}
=SML
	€icl'HIERARCHY› = €hier› of bool ref * icl'THEORY_INFO SPARSE_ARRAY
=TEX
There now follows the body of the $abstype$:
=SML
with
=TEX
\subsection{The Interface Theory Type}
The interface presentation of $icl'THEORY$:
=SML
type €THEORY› = {
		name : int,
		ty_env : {arity:int, level:int} S_DICT,
		con_env : {ty:TYPE, level:int} S_DICT,
		parents : int list,
		del_levels : (int * int) list,
		axiom_dict : THM S_DICT,
		defn_dict : THM S_DICT,
		thm_dict : THM S_DICT,
		current_level : int,
		user_data : USER_DATA ref};
=TEX
\subsection{The State Type}
$sealed$ is the integer index of the sealed theory.
=SML
type €STATE› = {hierarchy : icl'HIERARCHY,
	theory : icl'THEORY ref,
	ty_env : {arity:int, level:int} E_DICT,
	con_env : {ty:TYPE, level:int} E_DICT,
	defn_dict : THM E_DICT,
	axiom_dict : THM E_DICT,
	thm_dict : THM E_DICT,
	sealed : int};
=TEX
\subsection{Interface Types}
=SML
type €THEORY_INFO› = {
		status : THEORY_STATUS,
		inscope : bool,
		contents : THEORY,
		children : int list,
		name : string};

type €HIERARCHY› = (string * THEORY_INFO) list;
=TEX
\subsection{The Type of Conversions}
=SML
type €CONV› = TERM -> THM;
=TEX
\subsection{Equalities}
The following doesn't require very much from the ADT,
and could be moved out.
=SML
fun €list_eq› eq (a :: x) (b :: y) = eq (a,b) andalso list_eq eq x y
| list_eq eq [] [] = true
| list_eq eq _ _ = false;
=TEX
=SML
fun sequal (eq:'a * 'a -> bool) ([]: 'a list) ([]:'a list) : bool = true 
| sequal _ [] _  = false
| sequal _ _ [] = false
| sequal eq (a1 :: x1) l2 = (
let fun aux acc (a2 :: x2) = (
	if eq (a1, a2)
	then (true, acc @ (x2 drop (fn v => eq(v, a1))))
	else aux (a2 :: acc) x2
	) | aux acc [] = (false, []);

	val (ok,res) = aux [] l2;
in
	ok andalso (sequal eq (x1 drop (fn v => eq(v, a1))) res)
end);

fun ((asms1,conc1):SEQ) €=#› ((asms2,conc2):SEQ) = (
	conc1 =$ conc2
	andalso list_eq (op =$) asms1 asms2
);

fun ((asms1,conc1):SEQ) €~=#› ((asms2,conc2):SEQ) = (
	conc1 ~=$ conc2
	andalso sequal (op ~=$) asms1 asms2
);

fun (Thm {sequent=seq1,...}:THM) €=|-›
	(Thm {sequent=seq2,...}:THM) = seq1 =# seq2;
fun (Thm {sequent=seq1,...}:THM) €~=|-›
	(Thm {sequent=seq2,...}:THM) = seq1 ~=# seq2;
=TEX
\subsection{Formatting Theorems and Theorem Failures}
=TEX
=SML
val €pp'string_of_thm_ref› : (THM -> string) ref =
	ref (fn _ : THM => "<THM>");
fun €pp'set_string_of_thm› (f : THM -> string) : THM -> string = (
	let	val res = !pp'string_of_thm_ref;
	in	pp'string_of_thm_ref := f;
		res
	end
);
fun €string_of_thm› (tm : THM) : string = (
	! pp'string_of_thm_ref tm
);
=SML
fun €thm_fail› (area : string) (msg : int) (thml : THM list) : 'a = (
	fail area msg (map (fn x => fn () => string_of_thm x) thml)
);
=TEX
We often wish to destroy a theorem equation into its assumptions, LHS and RHS,
giving an error if it fails:
=SML
fun €dest_thm_eq› (area : string) (msg : int) (thm as Thm{sequent=(asms,concl),...} : THM)
	: (TERM list * (TERM * TERM)) = (
	(asms,dest_eq concl) 
	handle complaint =>
	case (area_of complaint) of
	"dest_eq" => thm_fail area msg [thm]
	| _ => reraise complaint (area_of complaint)
);
=TEX
\subsection{The Initial State}
The following is a function to give an empty theory, for initialisation
or deletion purposes.
The $pnts$ (for ``parents'') are given as a list type to give a simple ``optional'' value method.
=SML
fun €empty_theory› (nm: int) (pnts : int list) : icl'THEORY = (
	Thy{name = nm,
	 ty_env = initial_s_dict,
	 con_env = initial_s_dict,
	 parents = pnts,
	 del_levels = [],
	 axiom_dict = initial_s_dict,
	 defn_dict = initial_s_dict,
	 thm_dict = initial_s_dict,
	 current_level = 0,
	 user_data = ref initial_s_dict}
);
=TEX
The following is initialises the ``current state'', which is a $ref$ variable called $current$.
Initially it contains the empty theory "min" (with index 0), alone, as the current theory, which is also the sealed theory, with empty environments
(except that the constant environment always contains the numeric, string and character literal constants).

=SML
local
	val min = ref (empty_theory 0 []);

	val min_ti = ThyInfo{status = TSNormal,
		inscope = true,
		contents = min,
		children = [],
		name = "€min›"};

	val init_hier_ia : icl'THEORY_INFO SPARSE_ARRAY = array 100;

	val dummy = update(init_hier_ia, 0, min_ti);

	val init_hier : icl'HIERARCHY = 
		hier (ref false, init_hier_ia);
in
	val €current› : STATE ref = ref {
		hierarchy = init_hier,
		theory = min,
		ty_env = initial_e_dict,
		con_env = initial_e_dict,
		defn_dict = initial_e_dict,
		axiom_dict = initial_e_dict,
		thm_dict = initial_e_dict,
		sealed = 0};
end;
=TEX
Pointers into the current state:
=SML
fun €current_hierarchy› (():unit) : icl'HIERARCHY = (
let	val {hierarchy=hierarchy,...} = !current
in
	hierarchy
end);

fun €current_theory› (():unit) : icl'THEORY = (
let	val {theory=theory,...} = !current
in
	!theory
end);
=TEX
\subsection{The Scope of Types and Constants}
We will need to be able to rapidly check where HOL terms, types
and their derivatives are well-formed.
Well-formedness is just that the HOL type constructors and constants are in scope, with the right usage.
To do this efficiently we need a fast lookup facility for
type constructors and constants in scope.

Remove a simple dictionaries worth of constructor
information from an $E\_DICT$:
=SML
fun €del_con_env› (lst:{ty:TYPE, level:int} S_DICT) 
	(edict:{ty:TYPE, level:int} E_DICT): {ty:TYPE, level:int} E_DICT = (
	fold (fn ((nm,_),dct) => e_delete nm dct)
		lst
		edict
);

fun €del_ty_env› (lst:{arity:int, level:int} S_DICT)
	(edict:{arity:int, level:int} E_DICT) : {arity:int, level:int} E_DICT = (
	fold (fn ((nm,_),dct) => e_delete nm dct)
		lst
		edict
);
=TEX
We give a function to add a simple dictionaries worth of constructor
information to a scope.
If error messages 6073 or 6074 are seen by the outside world they are design errors, but some functions correctly catch these errors if they are the initial cause of them.
=SML
fun €add_con_env› (lst:{ty:TYPE, level:int} S_DICT) 
	(edict:{ty:TYPE, level:int} E_DICT): {ty:TYPE, level:int} E_DICT= (
	list_e_merge edict lst
	handle complaint =>
		if area_of complaint = "e_extend"
		then fail "add_con_env" 6073 []
		else reraise complaint (area_of complaint)
);

fun €add_ty_env› (lst:{arity:int, level:int} S_DICT) 
	(edict:{arity:int, level:int} E_DICT) : {arity:int, level:int} E_DICT = (
	list_e_merge edict lst
	handle complaint =>
		if area_of complaint = "e_extend"
		then fail "add_ty_env" 6074 []
		else reraise complaint (area_of complaint)
);
=TEX
The following functions look up a named entry in the value constructor or type constructor scopes.
These two functions could be made available to the user or interface
document, to allow, if nothing else, a ``what caused the well-formedness check to fail'' function to be written.
The constant environment always contains the numeric, string and character literal constants.
=SML
local
	val ordquote = ord("`");
	val orddquote = ord("\""); (* " *)
	val ord0 = ord("0");
	val ord9 = ord("9");
in
fun €get_con_env› (nm : string): {ty:TYPE, level:int} OPT = (
let	val {con_env=con_env,...} = !current;
in
	if nm = "" 
	then e_lookup "" con_env
	else (let
	val ordnm = ord nm;
in
	(if (ordnm = ordquote) andalso (size nm = 2)
	then Value {ty=CHAR, level = 0}
	else if	(ordnm = orddquote)
	then Value {ty = STRING, level = 0}
	else if	(ord0 <= ordnm andalso ordnm <= ord9 andalso
		(is_all_decimal nm))
	then Value {ty = Ó, level = 0}
	else e_lookup nm con_env)
end)
end);
end;

fun €get_ty_env› (nm : string):{arity:int, level:int} OPT = (
let	val {ty_env=ty_env,...} = !current
in
	e_lookup nm ty_env
end);
=TEX
Add a theory's environment to a pair of environment dictionaries:
=SML
fun €add_thy_env› (Thy{ty_env=ty_env, con_env=con_env,...})
	((te : {arity:int, level:int} E_DICT),
	 (ce : {ty:TYPE, level:int} E_DICT)) : 
	(({arity:int, level:int} E_DICT) *
	 ({ty:TYPE, level:int} E_DICT)) = (
	add_ty_env ty_env te,
	add_con_env con_env ce
);
=TEX
Delete a theory's environment to a pair of environment dictionaries:
=SML
fun €del_thy_env› (Thy{ty_env=ty_env, con_env=con_env,...})
	((te : {arity:int, level:int} E_DICT),
	 (ce : {ty:TYPE, level:int} E_DICT)) : 
	(({arity:int, level:int} E_DICT) *
	 ({ty:TYPE, level:int} E_DICT)) = (
	del_ty_env ty_env te,
	del_con_env con_env ce
);
=TEX
\subsection{Utilities Depending on ADT State and Types}
\subsubsection{Well-formedness}
The following are functions to check whether a type, term or theorem is well-formed within the current scope:
they give rise to an appropriate error message if not.

We choose to make a set of all types and constants to be checked,
and then check each set member, rather than check all generated
items, as this is judged superior in speed.
=SML
local
	fun auxty (caller:string) fw [] = ()
	| auxty caller fw ((tnm,arit) :: x) = (
		let val res = get_ty_env tnm
		in
		case res of
		Value{arity=arity,...} => (
			if (arit=arity)
			then auxty caller fw x
			else fail caller 6014 [fw,fn () => tnm]
		) | Nil => fail caller 6013 [fw,fn () => tnm]
		end);

	fun auxcon (caller:string) fw [] = ()
	| auxcon caller fw ((cnm,typ) :: x) = (
		let val res = get_con_env cnm
		in
		case res of
		Value{ty=ty1,...} => (
			if (is_type_instance typ ty1)
			then auxcon caller fw x
			else fail caller 6038 [fw,fn () => cnm]
		) | Nil => fail caller 6015 [fw,fn () => cnm]
		end);
in
	fun €wf_type› (caller : string) (ty : TYPE) : unit = (
	let	val tyv = type_tycons ty;
		val fw = (fn () => string_of_type ty);
	in
		auxty caller fw tyv
	end);

	fun €wf_term› (caller : string) (tm : TERM) : unit = (
	let	val tyv = term_tycons tm;
		val con = term_consts tm;
		val fw = (fn () => string_of_term tm);
	in
		(auxty caller fw tyv; auxcon caller fw con)
	end);

	fun €wf_thm› (caller : string) (thm : THM as Thm{sequent = (tml,tm),...}) : unit = (
	let	val tyv = list_cup (term_tycons tm ::
			map term_tycons tml);
		val con = list_union st_equals (term_consts tm ::
			map term_consts tml);
		val fw = (fn () => string_of_thm thm);
	in
		(auxty caller fw tyv; auxcon caller fw con)
	end);
end; (* of local fun auxty... *)
=TEX
The following is a function to check that a theorem is valid, fail if not.
Note that we do not check the well-formedness of the sequent,
as this is not required by the specification.
=SML
fun €check_thm› (caller: string)
	(thm as Thm {level = level, theory=theory, ...} : THM) : unit = (
let	val {hierarchy = hier (inconsistent,lookup),...} = !current;

	val Thy{name = iname, del_levels = del_levels, ...} = !theory;
	
	val dummy = if !inconsistent
		then error caller 6083 []
		else if (0 <= iname) andalso (iname <= uindex lookup)
		then ()
		else error caller 6072 [fn () => string_of_thm thm,
			fn () => "Internal "^string_of_int iname];

	val ThyInfo{status = status,
		inscope = inscope,
		contents = contents,
		children = children,
		name = ename}
		= sub(lookup,iname);
in
	if status = TSDeleted
	then error caller 6036 [fn () => string_of_thm thm,
		(fn () => ename),
		(fn () => string_of_int iname)]
	else if theory <> contents
	then error caller 6072 [fn () => "Internal "^string_of_int iname]
	else if not inscope
	then error caller 6066 [fn () => string_of_thm thm,
		fn () => ename]
	else if range_mem(level, del_levels)
	then error caller 6065 [fn () => string_of_thm thm,
		fn () => ename]
	else ()
end);
=TEX
In the following we deliberately catch all errors, whether raised by $fail$ or $error$, to provide a test of whether $check\_thm$ will fail on a given theorem.
=SML
fun €valid_thm› (thm : THM) : bool = (
	(check_thm "valid_thm" thm; true)
	handle complaint => 
	case complaint of
	(Fail _) => false
	| Error _ => false
	| _ => raise complaint
);
=TEX
\subsubsection{Theory Names}
$icl'get\_current\_theory\_name$ is part of the ADT interface,
but it is useful in defining utilities, so we provide it ``out of sequence''.

Get the current theory's name as an integer:
=SML
fun €icl'get_current_theory_name› (():unit) : int = (
let	val Thy{name = name,...} = current_theory();
in
	name
end);
=TEX
Check that an internal name falls within the range 0 to length of array, failing if not, with area being the $caller$ parameter:
=SML
fun €check_internal_theory_name› (nm : int) (caller : string) : unit = (
let	val hier (inconsistent,lookup) = current_hierarchy();
in
	if (0 <= nm) andalso (nm <= uindex lookup)
	then ()
	else fail caller 6043 [fn () => string_of_int nm]
end);
=TEX
Given a theory name as an string, the following function returns its internal name as an integer.
The error raised is stated to be from the calling function, denoted by $caller$.
A deleted theory's name cannot be found by these means.
=SML
fun €internal_theory_name› (nm : string) (caller : string): int = (
let	val hier (inconsistent,lookup) = current_hierarchy();
	fun aux ~1 = fail caller 6035 [fn () => nm]
	| aux n = (let val (ThyInfo{name=sname,contents=contents,status=status,...}) 
			= sub(lookup, n);
		in
			if ((sname = nm) andalso (status <> TSDeleted))
			then (let val(Thy{name=iname,...}) = !contents
				in
					iname
				end)
			else aux (n-1)
		end)
in
	if nm = "-"
	then icl'get_current_theory_name ()
	else aux (uindex lookup)
end);
=TEX
The following is a test of whether the given theory name present at all.
A deleted theory will not be noted by this function.
There is always a current theory, ``-''.
=SML
fun €is_theory_name› (nm : string) : bool = (
let	val hier (inconsistent,lookup) = current_hierarchy();
	fun aux ~1 = false
	| aux n = (let val (ThyInfo{name=sname,status=status,...}) = sub(lookup, n);
		in
			((sname = nm) andalso (status <> TSDeleted))
			orelse aux (n-1)
		end)
in
	(nm = "-")
	orelse aux (uindex lookup)
end);
=TEX
Return the theory contents:
=SML
fun €get_theory_contents› (n : int) : icl'THEORY = (
let	val hier (inconsistent,lookup) = current_hierarchy();
	val (ThyInfo{contents=contents,...}) = sub(lookup, n);
in
	!contents
end);
=TEX
Return the current theory name as a string:
=SML
fun €get_current_theory_name› (():unit):string = (
let	val hier (inconsistent,lookup) = current_hierarchy();
	val Thy{name = iname,...} = current_theory();
	val (ThyInfo{name=ename,...}) = sub(lookup, iname);
in
	ename
end);
=TEX
\subsubsection{Checking Writability}
We give a check that the current theory status allows writing, with various fail messages if not.
Note that the current theory should never have status $TSDeleted$.
=SML
fun €check_c_writable› (caller : string) : unit = (
let	val {hierarchy = hier (inconsistent,lookup),
		theory = theory, ...} = !current;

	val Thy{name = iname,...} = !theory;

	val ThyInfo{status = status, name = ename,...} = sub(lookup,iname);

in
	if !inconsistent
	then error caller 6083 []
	else case status of
	TSDeleted => error caller 6008 [fn x=>ename]
	| TSAncestor => fail caller 6071 [fn x=>ename]
	| TSLocked => fail caller 6037 [fn x=>ename]
	| TSNormal => ()
end);
=TEX
\subsubsection{Ancestors and Descendants}
A function to return all of a theory's ancestors
(including itself):
=SML
fun €theory_ancestors› (nm : int) : int list = (
let	val hier (inconsistent,lookup) = current_hierarchy();

	fun lparents (n : int) = (
		let	val ThyInfo{contents=contents,...} = sub(lookup,n);
			val Thy{parents=parents,...} = !contents
		in
			parents
		end);

	fun allparents ([]:int list) (acc:int list) = acc
	| allparents (a :: x) acc = (
		if a mem acc
		then allparents x acc
		else allparents ((lparents a) cup x) (a :: acc));
in
	check_internal_theory_name nm "theory_ancestors";
	allparents [nm] []
end);
=TEX
A function to return all of a theory's descendants
(but not including itself):
=SML
fun €theory_descendants› (nm : int) : int list = (
let	val hier (inconsistent,lookup) = current_hierarchy();

	fun lchildren (n : int) = (
		let val ThyInfo{children=children,...} = sub(lookup,n);
		in
			children
		end);

	fun allchildren ([]:int list) (acc:int list) = acc
	| allchildren (a :: x) acc = (
		if a mem acc
		then allchildren x acc
		else allchildren ((lchildren a) cup x) (a :: acc));
in
	check_internal_theory_name nm "theory_descendants";
	allchildren (lchildren nm) []
end);
=TEX
We provide a datatype to encode the results of the following functions.
=SML
datatype €THEORY_SCOPE› = €NotPresent› | €InScope› | €InDescendant›
=TEX
Is a given constant name used in any ancestor or descendant of the
current theory?
=SML
fun €const_in_anc_or_des› (nm : string) : THEORY_SCOPE = (
let	val iname =icl'get_current_theory_name();
	
	val hier (inconsistent,lookup) = current_hierarchy();

	fun const_in_thy (nm : string) (thry : int) : bool = (
	let val ThyInfo{contents = contents,...} = sub(lookup, thry);
		val Thy{con_env=con_env,...} = !contents;
	in
		not(is_Nil(s_lookup nm con_env))
	end);
in	
	if is_Nil(get_con_env nm)
	then (if (any (theory_descendants iname less iname) 
		(fn thry => const_in_thy nm thry))
		then InDescendant
		else NotPresent)
	else InScope
end);
=TEX
Is a given type constructor name used in any ancestor or descendant of the
current theory?
=SML
fun €type_in_anc_or_des› (nm : string) : THEORY_SCOPE = (
let	val iname = icl'get_current_theory_name();
	
	val hier (inconsistent,lookup) = current_hierarchy();

	fun type_in_thy (nm : string) (thry : int) : bool = (
	let	val ThyInfo{contents = contents,...} = sub(lookup, thry);
		val Thy{ty_env=ty_env,...} = !contents;
	in
		not(is_Nil(s_lookup nm ty_env))
	end);
in	
	if is_Nil(get_ty_env nm)
	then (if (any (theory_descendants iname less iname) 
		(fn thry => type_in_thy nm thry))
		then InDescendant
		else NotPresent)
	else InScope
end);
=TEX
=SML
local
	fun €modify_child› (parents: int list) 
		(modify : int list -> int list) : unit = (
	let	val hier (inconsistent,lookup) = current_hierarchy();
		fun aux (a :: x) = (
		let val ThyInfo{status = status,
			inscope = inscope,
			contents = contents,
			children = children,
			name = name} = sub(lookup,a)
		in
		update(lookup,a,
			ThyInfo{status = status,
			inscope = inscope,
			contents = contents,
			children = modify children,
			name = name});
			aux x
		end
		) | aux [] = ();
	in
		aux parents
	end);
in
=TEX
The following function removes theory $child$ from the children field 
of each of its $parents$.
This will be used in $icl'delete\_theory$.
=SML
fun €remove_child› (child : int) (parents: int list) : unit = (
	modify_child parents (fn children => children less child)
);
=TEX
The following function adds theory $child$ to the children field 
of each of its $parents$.
This will be used in $icl'new\_theory$ and
$icl'duplicate\_theory$.
=SML
fun €add_child› (child : int) (parents : int list) : unit = (
	modify_child parents (fn children => (child :: children))
);
end; (* of local fun modify_child ... *)
=TEX
\subsubsection{Hierarchies}
The following function maps $f$ over each of the theory information cells in the hierarchy.
As it is working through references it is misleading to
return any value.
=SML
fun €map_hierarchy› (f: (int * icl'THEORY_INFO) -> icl'THEORY_INFO) 
	(hier (incons,lookup) : icl'HIERARCHY) : unit = (
let	val leng = uindex lookup;
	fun aux	n = (if n <= leng
		then (
		let val old_ti = sub(lookup, n)
		in
			update(lookup,n,f (n,old_ti));
			aux (n+1)
		end) 
		else ());
in
	aux 0
end);
=TEX
Now a function to copy a hierarchy into a new one:
Note that when creating new hierarchies by copying we must copy from theory information 0 first, and then copy up to the number of hierarchies.
=SML
fun €copy_hierarchy› (hier (inconsistent,old_lookup) : icl'HIERARCHY) : icl'HIERARCHY = (
let	val new_lookup = array 100; 
	val top_theory = uindex old_lookup;
	fun aux	n = (if n <= top_theory
		then (
		let	val old_ti = sub(old_lookup, n);
		in
			update(new_lookup,n,old_ti);
			aux (n+1)
		end) 
		else ());
in
	(aux 0;
	hier (ref (!inconsistent),new_lookup))
end);
=TEX
We need a test to see if $hir1$ hierarchy is an ``ancestor'' of $hir2$.
According to the specification, this is so if the child possesses all the ancestors theories (by address comparison),
with the same theory information for each,
except that the children theories field may be different.
As new theories are always added to the ``tail'' of the theory hierarchy array we need only test up to the top theory of the ``ancestor''
hierarchy.
=SML
fun €is_hierarchy_ancestor› (hier (incons1,lookup1) : icl'HIERARCHY)
	(hier (incons2,lookup2) : icl'HIERARCHY) : bool = (
let	fun aux ~1 = true
	| aux n = (
	let	val (ThyInfo{status = status1,
			inscope = inscope1,
			contents = contents1,
			children = children1,
			name = name1})
		= sub(lookup1,n);

		val (ThyInfo{status = status2,
			inscope = inscope2,
			contents = contents2,
			children = children2,
			name = name2})
		= sub(lookup2,n) 
	in
		(status1 = status2) andalso
		(contents1 = contents2) andalso
		(name1 = name2) andalso
		aux (n-1)
	end)
in
	(uindex lookup1 <= uindex lookup2) andalso
	aux (uindex lookup1)
end);
=TEX
\section{THEORY AND HIERARCHY FUNCTIONS OF ADT THM}
\subsection{Operations on Hierarchies}
These functions follow the specification of \cite{DS/FMU/IED/SPC005}.

The following sets all non-deleted theories to have 
status TSancestor.
=SML
fun €icl'freeze_hierarchy› () : unit = (
let	val {hierarchy=hierarchy as hier(inconsistent,lookup), theory=theory, ty_env=ty_env, 
		con_env=con_env, sealed=sealed, ...} = !current;
	val dummy = if !inconsistent
		then error "icl'freeze_hierarchy" 6083 []
		else ();
	fun make_anc (n , ThyInfo{status = status,
				inscope = inscope,
				contents = contents,
				children = children,
				name = name})
		=
		( ThyInfo{status = (if status = TSDeleted
					then TSDeleted
					else TSAncestor),
				inscope = inscope,
				contents = contents,
				children = children,
				name = name});
	val was_inconsistent = !inconsistent;
in
	inconsistent := true;

	map_hierarchy make_anc hierarchy; (* spec. step 1 *)

	inconsistent := was_inconsistent;
		(* spec. step 2 *)
	() 
end);
=TEX

The following function gives the process of creating a new hierarchy from the current one,
but fails if any ancestor has status other than 
$TSancestor$ or $TSdeleted$. 
We first take a copy, we then modify its contents by reference,
we then make the current state have this new hierarchy as its current
one, as well as returning this value.
=SML
fun €icl'new_hierarchy› () : icl'HIERARCHY = (
let	val {hierarchy=hierarchy as hier(inconsistent,lookup), theory=theory, ty_env=ty_env, 
		con_env=con_env, sealed=sealed, ... } = !current;
	val dummy = if !inconsistent
		then error "icl'new_hierarchy" 6083 []
		else ();
	fun test_anc (n , ti as ThyInfo{status = status,
				inscope = inscope,
				contents = contents,
				children = children,
				name = name})
		=
		if (status <> TSDeleted) andalso (status <> TSAncestor)
		then fail "icl'new_hierarchy" 6090 [fn () => string_of_int n]
		else ti;

	val hcopy = copy_hierarchy hierarchy;

	val dummy = map_hierarchy test_anc hcopy; (* spec. step ? *)

in
	hcopy (* spec. step ? *)
end);
=TEX
Now we give a ``load hierarchy'' function, as demanded by the specification.
As the current theory address doesn't change, and its contents and its ancestors are
equal, $ty\_env$ and $con\_env$ and the theorem, definition and axiom dictionaries do not change.
The specification step 1 is irrelevant to our style of
implementation.

First a function, used with $map\_hierarchy$ to match the new hierarchies $inscope$ flags to the existing ones, or set them false.
After applying this only the $children$ field of the overlap
might differ, and the differences can only be aditional children in the new hierarchy.

We do not load the new hierarchy if either the new or the old are inconsistent.
=SML
local
fun match_scope (hier (_,flookup)):(int * icl'THEORY_INFO) -> icl'THEORY_INFO = (
let	val uflookup = uindex flookup
in
	fn (thn, 
	thi as ThyInfo{status = status,
			inscope = inscope,
			contents = contents,
			children = children,
			name = name}) => (
	if thn <= uindex flookup
	then (let val ThyInfo{inscope=finscope,...} = sub(flookup, thn);
	in ThyInfo{status = status,
			inscope = finscope,
			contents = contents,
			children = children,
			name = name}
	end)
	else ThyInfo{status = status,
			inscope = false,
			contents = contents,
			children = children,
			name = name}
	)
end);
=TEX
=SML
in
fun €icl'load_hierarchy› (hir as (hier(inconsistent,lookup): icl'HIERARCHY)) : unit = (
let	val {hierarchy=hierarchy as hier(inconsistent1, old_lookup),
		theory=theory, ty_env=ty_env, 
		con_env=con_env, defn_dict = defn_dict, thm_dict = thm_dict,
		axiom_dict  = axiom_dict, sealed=sealed} = !current;
	val dummy = if !inconsistent
		then error "icl'load_hierarchy" 6092 []
		else ();
	val dummy = if !inconsistent1
		then error "icl'load_hierarchy" 6083 []
		else ();
in
	if is_hierarchy_ancestor hierarchy hir (* spec step 2 *)
	then 	(let
	val dummy = map_hierarchy (match_scope hierarchy) hir;
	in
	current := {hierarchy = hir, theory=theory, ty_env=ty_env, 
		con_env=con_env, defn_dict = defn_dict, thm_dict = thm_dict,
		axiom_dict  = axiom_dict, sealed=sealed}
		(* spec step 3 *)
	end)
	else fail "icl'load_hierarchy" 6033 []
end
);
end; (* local fun match_scope ... *)
=IGN
icl'Kernel.icl'open_theory "min";
icl'Kernel.icl'freeze_hierarchy();
val temp = icl'Kernel.icl'new_hierarchy();
icl'Kernel.icl'new_theory "temp";
icl'Kernel.icl'open_theory "temp";
icl'Kernel.icl'new_const ("temp",mk_vartype "'a");
icl'Kernel.icl'new_theory "temp2";
icl'Kernel.icl'open_theory "temp2";
icl'Kernel.icl'new_const ("temp2",mk_vartype "'a");
icl'Kernel.icl'open_theory "min";
icl'Kernel.icl'load_hierarchy temp;
icl'Kernel.icl'open_theory "temp";
=TEX
Give an interface presentation of the current hierarchy:
=SML
fun €icl'get_hierarchy› (():unit) : HIERARCHY = (
let	val hier (inconsistent,lookup) = current_hierarchy();
	fun aux ~1 = [] 
	| aux n = (let	val (ThyInfo{status = status,
				inscope = inscope,
				contents = contents,
				children = children,
				name = name}) = sub(lookup,n);
			val Thy athy = !contents;
		in
			(name, {status = status,
				inscope = inscope,
				contents = athy,
				children = children,
				name = name}) 
			:: aux (n-1)
		end)
in
	aux (uindex lookup)
end);
=TEX
The bulk of the following is taken up with ensuring
that there will be no unopennable theories.
=SML
fun €icl'seal_hierarchy› () : unit = (
let	val {hierarchy=hierarchy as hier (inconsistent,lookup), 
		theory=theory, ty_env=ty_env, 
		con_env=con_env, defn_dict = defn_dict, thm_dict = thm_dict,
		axiom_dict  = axiom_dict, sealed=sealed} = !current;
	val dummy = if !inconsistent
		then error "icl'seal_hierarchy" 6083 []
		else ();
	val top_theory = uindex lookup;

	val cthynm = icl'get_current_theory_name ();

	val c_anc_des = theory_ancestors cthynm cup 
		theory_descendants cthynm;

	fun aux	n = (if n > top_theory
		then ()
		else if n mem c_anc_des
		then aux (n+1)
		else (let val (ThyInfo{status = status,
			inscope = inscope,
			contents = contents,
			children = children,
			name = name}) = sub(lookup,n);
		in
			if status <> TSDeleted
			then fail "icl'seal_hierarchy" 6004 [fn () => name]
			else aux (n+1)
		end) 
			
		);
	val side_effect = aux 0;
in
	current := {hierarchy = hierarchy, theory=theory, ty_env=ty_env, 
		con_env=con_env, 
		defn_dict = defn_dict, thm_dict = thm_dict,
		axiom_dict  = axiom_dict,
		sealed=icl'get_current_theory_name ()}
end
);
=TEX
In the sequence suggested by \cite{DS/FMU/IED/DTD006}
we would only now give $icl'get\_current\_theory\_name$,
but the function was useful in defining utilities needed before this point.

Return an interface presentation of a theory, based on a string:
=SML
fun €icl'get_theory_info› (nm : string) : THEORY_INFO = (
let	val hier (inconsistent,lookup) = current_hierarchy();

	val iname = internal_theory_name nm "icl'get_theory_info";

	val (ThyInfo{status = status,
			inscope = inscope,
			contents = contents,
			children = children,
			name = name}) = sub(lookup,iname);

	val Thy athy = !contents;
in
	{status = status,
	inscope = inscope,
	contents = athy,
	children = children,
	name = name}
end);
=TEX
Given a theory name as an integer, return it as a string:
=SML
fun icl'get_theory_name (nm : int) : string = (
let	val hier (inconsistent,lookup) = current_hierarchy();
in
	check_internal_theory_name nm "icl'get_theory_name";
	(let val (ThyInfo{name=name,status=status,...}) = sub(lookup, nm)
		in
			if status <> TSDeleted
			then name
			else fail "icl'get_theory_name" 6089 [fn () => string_of_int nm]
		end)
end);
=TEX
=SML
fun €icl'get_pervasive_theory_name› () : string = (
let	val {sealed=sealed,...} = !current;
in
	icl'get_theory_name sealed
	handle (Fail _) =>
	error "icl'get_pervasive_theory_name" 6091 [fn () => string_of_int sealed]
end);
=TEX

\subsection{Operations on Theory Attributes}
These functions follow the specification of \cite{DS/FMU/IED/SPC005}.

We give a function to make some theory the current theory.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun €icl'open_theory› (nm : string) : (int list * int list) = (
let	val {hierarchy = hierarchy as hier (inconsistent,lookup),
		theory=theory, ty_env=ty_env, con_env=con_env,
		sealed=sealed, ...} = !current;
	val top_theory = uindex lookup;
	val thyn = internal_theory_name nm "icl'open_theory"; (* spec step 1 *)

	val allp = theory_ancestors thyn;

	val sideeffect = if sealed mem allp
		then ()
		else fail "icl'open_theory" 6017 [fn () => nm,
			fn () => icl'get_theory_name sealed];

	val ThyInfo{status = status,
		inscope = inscope,
		contents = contents as ref (Thy
			{defn_dict = def_sd, axiom_dict = ax_sd, thm_dict = thm_sd, ...}),
		children = children,
		name = name} = sub(lookup,thyn);

	val ax_ed = list_e_merge initial_e_dict ax_sd;

	val def_ed = list_e_merge initial_e_dict def_sd;

	val thm_ed = list_e_merge initial_e_dict thm_sd;
	
=TEX
The following auxiliary function takes everything necessary out of scope, sets all the inscope fields to
their correct value.
=SML
	fun aux_out ~1 out_of_scope tece = (out_of_scope, tece)
	| aux_out n out_of_scope tece = (
		let val ThyInfo{status = status1,
			inscope = inscope1,
			contents = contents1,
			children = children1,
			name = name1} = sub(lookup,n)
		in
		(if (n mem allp) orelse (not inscope1)
		then (aux_out (n - 1) out_of_scope tece)
		else (update(lookup,n,
			ThyInfo{status = status1,
				inscope = false,
				contents = contents1,
				children = children1,
				name = name1});
			aux_out (n-1) (n :: out_of_scope)
				(del_thy_env (!contents1) tece)))
		end);
=TEX
The following auxiliary function takes everything necessary in to scope, sets all the inscope fields to
their correct value.
=SML
	fun aux_in ~1 into_scope tece = (into_scope, tece)
	| aux_in n into_scope tece = (
		let val ThyInfo{status = status1,
			inscope = inscope1,
			contents = contents1,
			children = children1,
			name = name1} = sub(lookup,n)
		in
		(if (n mem allp) andalso (not inscope1)
		then (update(lookup,n,
			ThyInfo{status = status1,
				inscope = true,
				contents = contents1,
				children = children1,
				name = name1});
			aux_in (n-1) (n :: into_scope) 
				(add_thy_env (!contents1) tece))
		else (aux_in (n - 1) into_scope tece))
		end);
	val was_inconsistent = !inconsistent;
=TEX
We now need to protect the changes to the hierarchy:
=SML
in
	(inconsistent := true;
=TEX
Now use these auxiliary functions to gain the theories moved in and out of scope and the
new type and constructor environments, after the opening.
Notice we must take everything necessary out of scope before we put anything into scope.
=SML
	let
	val (outs, tece) = aux_out top_theory [] (ty_env, con_env);
	val (ins, (te,ce)) = aux_in top_theory [] tece;
=TEX
=SML
	in
	(current := {hierarchy=hierarchy, theory=contents, ty_env=te, 
		con_env=ce, defn_dict = def_ed, thm_dict = thm_ed,
		axiom_dict  = ax_ed, sealed=sealed};
	inconsistent := was_inconsistent;
		(* spec step 3, 4 *)
	(ins, outs))
	end)
end);
=TEX
The following is a function to delete theories.
We modify the current hierarchy ``in place'' rather than taking a copy.
If it is interrupted then the state may be left with the $inconsistent$ flag set.
=SML
fun €icl'delete_theory› (nm : string) : unit = (
let	val {hierarchy = hierarchy as hier (inconsistent,lookup),
		theory=theory, ty_env=ty_env, con_env=con_env, 
		sealed=sealed, ...} = !current;

	val thyn = internal_theory_name nm "icl'delete_theory"; (* spec. step 1 *)
	
	val ThyInfo{status = status,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name} = sub(lookup,thyn);

	val dummy = case status of
		TSDeleted => error "icl'delete_theory" 6041 [fn () => nm]
		| TSAncestor => fail "icl'delete_theory" 6071 [fn () => nm]
		| TSLocked => fail "icl'delete_theory" 6037 [fn () => nm]
		| TSNormal => 
		if !inconsistent
		then error "icl'delete_theory" 6083 []
		else if not(is_nil children)
		then fail "icl'delete_theory" 6076 [fn () => nm]
		else if inscope
		then fail "icl'delete_theory" 6069 [fn () => nm]
		else ();

	val Thy{parents = parents,...} = !contents;

	val ethy = empty_theory thyn [];
	val was_inconsistent = !inconsistent;
in
	inconsistent :=true;
	remove_child thyn parents;
	contents := ethy; (* spec step 3 *)
	update(lookup,thyn,ThyInfo{status = TSDeleted,
		inscope = false,
		contents = contents,
		children = [],
		name = name}); (* spec step 2, 4 *)
	inconsistent := was_inconsistent
end);
=TEX
The following creates a new theory, though it does not make it current.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun €icl'new_theory› (nm : string) : int = (
	if (is_theory_name nm)	(* spec. step 1 *)
	then fail "icl'new_theory" 6040 [fn () => nm]
	else let val {hierarchy = hierarchy as hier (inconsistent,lookup), 
		theory=theory, ty_env=ty_env, con_env=con_env, 
		sealed=sealed, ...} = !current;
	val dummy = if !inconsistent
		then error "icl'new_theory" 6083 []
		else ();

	val cthy = icl'get_current_theory_name();

	val ntop_theory = uindex lookup + 1;

	val nthy = ref (empty_theory ntop_theory [cthy]); (* spec. step 2 *)

	val nti = (ThyInfo{status = TSNormal, 
		inscope = false,
		contents = nthy,
		children = [],
		name = nm});
	val was_inconsistent = !inconsistent;

in
	inconsistent:=true;
	update(lookup,ntop_theory,nti); (* spec step 3 *)
	add_child ntop_theory [cthy];
	inconsistent := was_inconsistent; (* spec. step 4 *)
	ntop_theory
end
);
=TEX
The following adds a new parent to the current theory.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun €icl'new_parent› (nm : string) : int list = (
let	val dummy = (check_c_writable "icl'new_parent";
	if not(is_theory_name nm)
	then fail "icl'new_parent" 6035 [fn () => nm]
	else ());

	val pthy = internal_theory_name nm "icl'new_parent";

	val {hierarchy=hierarchy as hier (inconsistent,lookup), 
		theory=theory, ty_env=cty_env,
		con_env=ccon_env,
		defn_dict = def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed}
		 = !current;

	val ThyInfo{status = fstatus, 
		inscope = finscope,
		contents = fcontents,
		children = fchildren,
		name = fname}
		= sub(lookup, pthy);

	val cthy = icl'get_current_theory_name();

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;
=TEX
The ancestors of the current and parent theories:
=SML
	val pthy_anc = theory_ancestors pthy;
	val cthy_anc = theory_ancestors cthy;
=TEX
A theory is an ancestor of the current one if and only if it is in scope.
=SML
	val dummy = if pthy mem parents
		then fail "icl'new_parent" 6082 [fn () => fname]
		else if cthy mem pthy_anc
		then fail "icl'new_parent" 6084 [fn () => fname]
		else ();

	val nfti = (ThyInfo{status = fstatus, 
		inscope = finscope,
		contents = fcontents,
		children = (cthy :: fchildren),
		name = fname});

	val new_thys_in_scope = pthy_anc diff cthy_anc ;
=TEX
The following detects clashes with things in scope, as well as discovering the new scopes.
=SML
	val ntece as (new_ty_env,new_con_env) = ((fold 
		(fn (athy,tece) => add_thy_env (get_theory_contents athy) tece)
		new_thys_in_scope
		(cty_env, ccon_env))
		handle complaint =>
		list_divert complaint "icl'new_parent" [
			("add_ty_env",6067,[fn () => fname]),
			("add_con_env",6067,[fn () => fname])]);
=TEX
The following detects clashes with things in the children of the current theory.
=SML
	val dummy = ((map (fn athy => (add_thy_env (get_theory_contents athy) ntece;()))
		(theory_descendants cthy))
		handle complaint =>
		list_divert complaint "icl'new_parent" [
			("add_ty_env",6067,[fn () => fname]),
			("add_con_env",6067,[fn () => fname])]);

	val new_thy = Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = (pthy :: parents),
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data};
=TEX
Put the new ancestor theories in scope:
=SML
	fun put_in_scope [] = () 
	| put_in_scope (n :: x) = (
	let val ThyInfo{status = astatus, 
		inscope = ainscope,
		contents = acontents,
		children = achildren,
		name = aname} = sub(lookup,n)
	in
		(update(lookup,n,ThyInfo{status = astatus, 
			inscope = true,
			contents = acontents,
			children = achildren,
			name = aname});
		put_in_scope x)
	end);
	val was_inconsistent = !inconsistent;
in
	inconsistent:=true;
	put_in_scope new_thys_in_scope;
	add_child cthy [pthy];
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory, ty_env = new_ty_env, 
		con_env=new_con_env,
		defn_dict = def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed};
	inconsistent:= was_inconsistent;
	new_thys_in_scope
end);
=TEX
The following is a function to lock a theory, to make it read-only.
We work by modifying the current hierarchy ``in place''.
=SML
fun €icl'lock_theory› (nm : string): unit = (
let	val thyn = internal_theory_name nm "icl'lock_theory"; (* spec. step 1 *)

	val hier (inconsistent,lookup) = current_hierarchy();
	val dummy = if !inconsistent
		then error "icl'lock_theory" 6083 []
		else ();
	
	val ThyInfo{status = status,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name} = sub(lookup,thyn);

	val dummy = case status of
		TSDeleted => error "icl'lock_theory" 6041 []
		| TSAncestor => fail "icl'lock_theory" 6071 [fn () => nm]
		| TSLocked => fail "icl'lock_theory" 6037 [fn () => nm]
		| TSNormal => ();
in
	update(lookup,thyn,ThyInfo{status = TSLocked,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name}) (* spec step 2,3 *)
end);
=TEX
The following is a function to unlock a locked theory, allowing to to be written to once more.
We work by modifying the current hierarchy ``in place''.
=SML
fun €icl'unlock_theory› (nm : string): unit = (
let	val thyn = internal_theory_name nm "icl'unlock_theory"; (* spec. step 1 *)

	val hier (inconsistent,lookup) = current_hierarchy();
	val dummy = if !inconsistent
		then error "icl'unlock_theory" 6083 []
		else ();
	
	val ThyInfo{status = status,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name} = sub(lookup,thyn);

	val dummy = case status of
		TSDeleted => error "icl'unlock_theory" 6041 []
		| TSAncestor => fail "icl'unlock_theory" 6068 [fn () => nm]
		| TSNormal => fail "icl'unlock_theory" 6068 [fn () => nm]
		| TSLocked => ();
in
	update(lookup,thyn,ThyInfo{status = TSNormal,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name}) (* spec. step 2,3 *)
end);
=TEX
The following is a function to create a duplicate theory, except it has no children.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun €icl'duplicate_theory› (fromnm : string) (tonm : string) : int = (
let	val {hierarchy = hierarchy as hier (inconsistent,lookup),
		theory=theory, ty_env=cty_env, con_env=ccon_env, 
		defn_dict = def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed} = !current;
	val dummy = if !inconsistent
		then error "icl'duplicate_theory" 6083 []
		else if (is_theory_name tonm)
		then fail "icl'duplicate_theory" 6040 [fn () => tonm]
		else ();

	val fromn = internal_theory_name fromnm "icl'duplicate_theory";

	val dummy = if sealed = fromn
		then fail "icl'duplicate_theory" 6026 [fn () => fromnm]
		else if sealed mem (theory_ancestors fromn)
		then ()
		else fail "icl'duplicate_theory" 6042 [fn () => fromnm];

	val ntop_theory = uindex lookup + 1;

	val ThyInfo{status = status1,
		inscope = inscope1,
		contents = contents1,
		children = children1,
		name = name1}
		= sub(lookup,fromn);

	val Thy{name = frname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !contents1;

	val dummy = if frname <> fromn
		then error "icl'duplicate_theory" 6041 []
		else ();

	val tothy = ref (empty_theory 0 []);

	fun new_dict_entry (k, Thm {level, theory, sequent}) = (
		(k, Thm {level = level, theory = tothy, sequent = sequent})
	);

	val side = (
		tothy := 
		Thy{	name = ntop_theory,
			ty_env = ty_env,
			con_env = con_env,
			parents = parents,
			del_levels = del_levels,
			axiom_dict = map new_dict_entry axiom_dict,
			defn_dict = map new_dict_entry defn_dict,
			thm_dict = map new_dict_entry thm_dict,
			current_level = current_level,
			user_data = ref(!user_data)});

	val toti = (ThyInfo{status = TSNormal, 
		inscope = false,
		contents = tothy,
		children = [],
		name = tonm});

	val was_inconsistent = !inconsistent;
in
	inconsistent:=true;
	update(lookup,ntop_theory,toti);
	add_child ntop_theory parents;
	current := {hierarchy = hierarchy,
		theory=theory, ty_env=cty_env, con_env=ccon_env, 
		defn_dict = def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed};
	inconsistent:=was_inconsistent;
	ntop_theory
end);
=TEX

\subsection{Operations on Theory Contents}
The first two functions of this section have no specification.
The rest of the functions follow the specification of \cite{DS/FMU/IED/SPC005}.

Get a theory's contents, by string name:
=SML
fun €icl'get_theory› (nm : string) : THEORY = (
let	val iname = internal_theory_name nm "icl'get_theory"
	val Thy gthy = get_theory_contents iname
in
	gthy
end);
=TEX
Get the current theory's status:
=SML
fun €get_current_theory_status› () : THEORY_STATUS = (
let	val {hierarchy = hier (inconsistent,lookup), theory = theory, ...} = !current;

	val Thy{name = iname,...} = !theory;

	val (ThyInfo{status = status,...}) = sub(lookup, iname);
in
	status
end);
=TEX
Give the sequent of a theorem:
=SML
fun €dest_thm› (Thm{sequent=sequent,...} : THM) : SEQ = sequent;
=TEX
Give a user presentation of a theorem:
=SML
fun €icl'dest_thm› (Thm{level = level, theory=theory, sequent = sequent}:THM) :
	{level : int, theory : THEORY, sequent : SEQ} = (
let	val Thy thry = !theory
in
	{level=level, theory = thry, sequent = sequent}
end);
=TEX

Save a theorem under a list of keys:
=SML
fun €icl'list_save_thm› (keys : string list, 
	thm : THM as Thm {level = level, theory=theory, sequent = sequent}) : THM = (
let	val dummy = (check_thm "icl'list_save_thm" thm;
		wf_thm "icl'list_save_thm" thm;
		if keys = []
		then fail "icl'list_save_thm" 6031 []
		else check_c_writable "icl'list_save_thm"); (* part of spec. step 2 *)

	val {hierarchy=hierarchy as hier (inconsistent,lookup), 
		theory=ctheory, ty_env=cty_env,
		con_env=ccon_env,
		defn_dict = def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed}
		 = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !ctheory; (* spec. step 1 *)
=TEX
The definition level of the saved theorem is 0 if it is from
an ancestor theory, as described in the specification.
=SML
	val new_thm = Thm{level = if (theory = ctheory)
			then current_level
			else 0,
		theory = ctheory,
		sequent = sequent};
=TEX
We test that all the keys are new (part of spec. step 2) at the same time as 
adding new entries to the cached dictionary, by using $e\_extend$
(spec. step 3).
We can then just extend the dictionary in the theory by cons-ing with no further check.
=SML

	val new_thm_ed = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			e_extend key new_thm dct
			handle complaint =>
			divert complaint "e_extend" "icl'list_save_thm" 6039
		 [(fn () => key),
		  (fn () => get_current_theory_name())])
		keys)
		thm_ed);

	val new_thm_dict = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			(key, new_thm) :: dct)
		keys)
		thm_dict);

	val new_thy = Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = new_thm_dict,
		current_level = current_level,
		user_data = user_data}
	val was_inconsistent = !inconsistent;
in
	inconsistent:=true;
	ctheory := new_thy; (* spec. step 4 *)
	current :=  {hierarchy=hierarchy, theory=ctheory, ty_env = cty_env, 
		con_env = ccon_env,
		defn_dict = def_ed, axiom_dict = ax_ed, thm_dict = new_thm_ed,
		sealed=sealed};
	inconsistent:= was_inconsistent;
	new_thm
end);
=TEX
The following is a function to delete the last extension to the current theory.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun €icl'delete_extension› (():unit) : int = (
let	val {hierarchy = hierarchy as hier (inconsistent,lookup), 
		theory=theory, ty_env=cty_env, con_env=ccon_env, 
		sealed=sealed, thm_dict = thm_ed, ...} = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;

	val ThyInfo{children = children, name = ename,...} = sub(lookup,iname);

	val dummy = (check_c_writable "icl'delete_extension"; (* spec. step 1 *)
		if children <> []
		then fail "icl'delete_extension" 6076 [fn x=>ename]
		else ());
=TEX
We want the last level at which something was defined
(specification step 2).
All the following lists are always manipulated such that their head
will be the last declaration of their kind.
N.B. this does not hold true of $thm\_dict$,
as it may save theorems from other theories at level 0.

In the following $ll\_def$ should always be less than or equal $ll\_con$, but we check, just in case.
=SML
	val ll_type = case ty_env of
		[] => 0
		| ((_,{level=llt,...})::_) => llt;
	val ll_con = case con_env of
		[] => 0
		| ((_,{level=llc,...})::_) => llc;
	val ll_def = case defn_dict of
		[] => 0
		| ((_,Thm{level=lld,...})::_) => lld;
	val ll_axiom = case axiom_dict of
		[] => 0
		| ((_,Thm{level=lla,...})::_) => lla;

	val last_level = list_max[ll_type, ll_con, ll_def, ll_axiom];

	val dummy = (
		if last_level = 0
		then fail "icl'delete_extension" 6050 [fn () => ename]
		else if (any thm_dict (fn (_,Thm{level=ll,...}) => 
			ll >= last_level))
		then fail "icl'delete_extension" 6077 
			[(fn () => ename),
			(fn () => let val (key,_) = (find thm_dict 
				(fn (_,Thm{level=ll,...}) =>
				 ll >= last_level))
				in key end)]
		else ());

	val new_del_levels = extend_range (last_level, current_level) del_levels;
=TEX
The following deletion, specification step 3, depends upon the implementation of simple
dictionaries.
We delete anything made between $last\_level$ and $current\_level$
(there should only be things {\bf at} the current level,
but we are very cautious).
=SML
	val new_ty_env=ty_env drop (fn (_,{level=ll,...}) => ll >= last_level);

	val new_cty_env = del_ty_env (ty_env drop (fn (_,{level=ll,...}) => ll < last_level))
		cty_env;

	val new_con_env=con_env drop (fn (_,{level=ll,...}) => ll >= last_level);

	val new_ccon_env = del_con_env(con_env drop (fn (_,{level=ll,...}) => ll < last_level))
		ccon_env;

	val new_axiom_dict = axiom_dict drop 
		(fn (_,Thm{level=ll,...}) => ll >= last_level);

	val new_defn_dict = defn_dict drop 
		(fn (_,Thm{level=ll,...}) => ll >= last_level);

	val ax_ed = list_e_merge initial_e_dict new_axiom_dict;

	val def_ed = list_e_merge initial_e_dict new_defn_dict;

	val new_thy = Thy{name = iname,
		ty_env = new_ty_env,
		con_env = new_con_env,
		parents = parents,
		del_levels = new_del_levels,
		axiom_dict = new_axiom_dict,
		defn_dict = new_defn_dict,
		thm_dict = thm_dict,
		current_level = current_level+1,
		user_data = user_data};
	val was_inconsistent = !inconsistent;
in
=TEX
Note that the current theory address doesn't change, only the contents of the location pointed to.
=SML
	inconsistent:=true;
	theory := new_thy; (* spec. step 4 *)
	current := {hierarchy=hierarchy, theory=theory,
		ty_env=new_cty_env, con_env=new_ccon_env,
		defn_dict = def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed};
	inconsistent:=was_inconsistent;
	last_level
end);
=TEX
Delete a named theorem from the current theory:
=SML
fun €icl'delete_thm› (key : string) : THM = (
let	val {hierarchy=hierarchy as hier (inconsistent,lookup), 
		theory=theory, ty_env=cty_env,
		con_env=ccon_env,
		defn_dict = def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed}
		 = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;

	val dummy = check_c_writable "icl'delete_thm"; (* spec. step 1 *)

	val dthm = (force_value(s_lookup key thm_dict)
		handle complaint =>
		divert complaint "force_value" "icl'delete_thm" 6046 [
				fn x => key,
				fn x => get_current_theory_name()]);

	val new_thm_dict = s_delete key thm_dict; (* spec step 2 *)

	val new_thm_ed = e_delete key thm_ed;

	val new_thy = Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = new_thm_dict,
		current_level = current_level,
		user_data = user_data}

	val was_inconsistent = !inconsistent;
in
	inconsistent := true;
	current := {hierarchy=hierarchy, theory=theory,
		ty_env=cty_env, con_env=ccon_env,
		defn_dict = def_ed, axiom_dict = ax_ed, thm_dict = new_thm_ed,
		sealed=sealed};
	theory := new_thy;
	inconsistent:=was_inconsistent;
	dthm
end);
=TEX
Add an axiom to the current theorem:
=SML
fun €icl'new_axiom› (keys : string list, tm : TERM) : THM = (
let	val {hierarchy=hierarchy as hier (inconsistent,lookup), 
		theory=theory, ty_env=cty_env,
		con_env=ccon_env,
		defn_dict = def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed}
		 = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;
	
	val dummy = (check_c_writable "icl'new_axiom" ;
		wf_term "icl'new_axiom" tm;
		if keys = []
		then fail "icl'new_axiom" 6031 []
		else if type_of tm =: BOOL
		then ()
		else term_fail "icl'new_axiom" 3031 [tm]); 
			(* spec step 1 *)

	val new_axiom = Thm{level = current_level+1, 
		theory=theory, 
		sequent = ([], tm)}; (* spec step 2,3 *)
=TEX
We test that all the keys are new (part of spec. step 1) at the same time as 
adding new entries to the cached dictionary, by using $e\_extend$.
We can then just extend the dictionary in the theory by cons-ing with no further check.
=SML
	val new_ax_ed = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			e_extend key new_axiom dct
			handle complaint =>
			divert complaint "e_extend" "icl'new_axiom" 6047 
			[(fn () => key), 
			 (fn () => get_current_theory_name ())])
		keys)
		ax_ed);

	val new_axiom_dict = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			(key, new_axiom) :: dct)
		keys)
		axiom_dict);

	val new_thy = Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = new_axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level+1,
		user_data = user_data};

	val was_inconsistent = !inconsistent;
in
	inconsistent:=true;
	theory := new_thy; (* spec. step 4 *)
	current := {hierarchy=hierarchy, theory=theory,
		ty_env= cty_env, con_env=ccon_env,
		defn_dict = def_ed, axiom_dict = new_ax_ed, thm_dict = thm_ed,
		sealed=sealed};
	inconsistent:=was_inconsistent;
	new_axiom
end);
=TEX
\subsubsection{Definitional Mechanisms}
These functions follow the specification of \cite{DS/FMU/IED/SPC005}.
The following five functions follow the pattern of the
definitional mechanisms of the specification.

The following is a function to add a new constant to the theory.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun €icl'new_const› (nm : string, ty : TYPE) : TERM = (
let	val {hierarchy=hierarchy as hier(inconsistent,lookup), theory=theory, ty_env=cty_env, 
		con_env=ccon_env,
		defn_dict = def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed} = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;
	
	val dummy = (check_c_writable "icl'new_const";
		wf_type "icl'new_const" ty;
		(case const_in_anc_or_des nm of
		InScope => fail "icl'new_const" 6049 [fn () => nm]
		| InDescendant => fail "icl'new_const" 6063 [fn () => nm]
		| NotPresent => ())); 
		
	val new_const = mk_const(nm,ty)
		handle complaint =>
		pass_on complaint "mk_const" "icl'new_const";

	val con_decl = {ty=ty,level=current_level+1};

	val new_con_env = (nm, con_decl) :: con_env;

	val new_thy = Thy{name = iname,
		ty_env = ty_env,
		con_env = new_con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level+1,
		user_data = user_data};

	val new_ccon_env = add_con_env [ (nm,con_decl)] ccon_env;
	val was_inconsistent = !inconsistent;
in
	inconsistent:=true;
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=new_ccon_env,
		defn_dict = def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed};
	inconsistent:=was_inconsistent;
	new_const
end);
=TEX
The following is a function to add a new type to the theory.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun €icl'new_type› (nm : string, arity : int) : TYPE = (
let	val {hierarchy=hierarchy as hier(inconsistent,lookup), 
		theory=theory, ty_env=cty_env, 
		con_env=ccon_env,
		defn_dict = def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed} = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;
	
	val dummy = (check_c_writable "icl'new_type";
		(case type_in_anc_or_des nm of
		InScope => fail "icl'new_type" 6045 [fn () => nm]
		| InDescendant => fail "icl'new_type" 6034 [fn () => nm]
		| NotPresent => 
		if arity < 0 
		then fail "icl'new_type" 6088 []
		else ()));
		
	val new_type = mk_ctype(nm,ntyvars arity);

	val type_decl = {arity=arity,level=current_level+1};

	val new_ty_env = (nm, type_decl) :: ty_env;

	val new_thy = Thy{name = iname,
		ty_env = new_ty_env,
		con_env=con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level+1,
		user_data = user_data};

	val new_cty_env = add_ty_env [(nm,type_decl)] cty_env; 
	val was_inconsistent = !inconsistent;
in
	inconsistent:=true;
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory, ty_env = new_cty_env, 
		con_env=ccon_env,
		defn_dict = def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed};
	inconsistent:=was_inconsistent;
	new_type
end);
=TEX
The following is a function to declare a new, named, constant to be equal to some term.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
Note that the function assumes the presence of $=$ as a valid constant.
=SML
fun €icl'new_defn› (keys : string list, cnm : string, vl : TERM) : THM = (
let	val {hierarchy=hierarchy as hier(inconsistent,lookup), 
		 theory=theory, ty_env=cty_env,
		 con_env=ccon_env,
		defn_dict = def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed} = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;

	val ctype = type_of vl;
=TEX
Do the checks required (other than on keys):
=SML
	val dummy = (check_c_writable "icl'new_defn";
		(case const_in_anc_or_des cnm of
		InScope => fail "icl'new_defn" 6049 [fn () => cnm]
		| InDescendant => fail "icl'new_defn" 6063 [fn () => cnm]
		| NotPresent => ());
		wf_term "icl'new_defn" vl;
		if is_nil keys
		then fail "icl'new_defn" 6031 []
		else if not(is_nil (frees vl))
		then fail "icl'new_defn" 6059 [fn () => string_of_term vl,
			fn () => format_list (fst o dest_var) (frees vl) ", "]
		else if not(is_nil((term_tyvars vl) diff (type_tyvars ctype)))
		then fail "icl'new_defn" 6058 
			[fn () => string_of_term vl,
			 fn () => format_list (Combinators.I) 
			 ((term_tyvars vl) diff (type_tyvars ctype)) ", "]

		else ()
		);
=TEX
Now build up the new material:
=SML
	val new_const = mk_const(cnm,ctype)
		handle complaint =>
		pass_on complaint "mk_const" "icl'new_defn";

	val con_decl = {ty=ctype,level=current_level+1};

	val new_con_env = (cnm, con_decl) :: con_env;

	val new_ccon_env = add_con_env [ (cnm,con_decl)] ccon_env;

	val new_defn = Thm{level = current_level+1, 
		theory=theory, 
		sequent = ([], mk_eq(new_const, vl))};

	val new_def_ed = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			e_extend key new_defn dct
			handle complaint =>
			divert complaint "e_extend" "icl'new_defn" 6051 
			[(fn () => key), 
			 (fn () => get_current_theory_name())])
		keys)
		def_ed);

	val new_defn_dict = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			(key, new_defn) :: dct)
		keys)
		defn_dict);

	val new_thy = Thy{name = iname,
		ty_env = ty_env,
		con_env = new_con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = new_defn_dict,
		thm_dict = thm_dict,
		current_level = current_level+1,
		user_data = user_data};
	val was_inconsistent = !inconsistent;
in
	inconsistent:=true;
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=new_ccon_env,
		defn_dict = new_def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed};
	inconsistent:=was_inconsistent;
	new_defn
end);
=TEX
The following is a function to introduce a new type definition.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
Note that the function assumes the presence of $TypeDefn$ and $∂$ as valid constants.
=SML
fun €icl'new_type_defn› (keys : string list, tnm : string, 
		typars : string list,
		defthm : THM as Thm{sequent = (asms, concl),...}) : THM = (
let	val {hierarchy=hierarchy as hier(inconsistent,lookup),
		 theory=theory, ty_env=cty_env, 
		con_env=ccon_env,
		defn_dict = def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed} = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;
=TEX
Do the checks required (other than on keys):
=SML
	val dummy = (check_c_writable "icl'new_type_defn";
		(case type_in_anc_or_des tnm of
		InScope => fail "icl'new_type_defn" 6045 [fn () => tnm]
		| InDescendant => fail "icl'new_type_defn" 6034 [fn () => tnm]
		| NotPresent => ());
		check_thm "icl'new_type_defn" defthm;
		wf_thm "icl'new_type_defn" defthm;
		if is_nil keys
		then fail "icl'new_type_defn" 6031 []
		else if not(is_nil asms)
		then thm_fail "icl'new_type_defn" 6053 [defthm]
		else if not(is_nil (frees concl))
		then (let val fc = map (fst o dest_var)(frees concl) in
			if length fc = 1
			then 
			fail "icl'new_type_defn" 6056 
			[fn () => hd fc,
			 fn () => string_of_thm defthm]
			else
			fail "icl'new_type_defn" 6062 
			[fn () => format_list Combinators.I fc ", ",
			 fn () => string_of_thm defthm]
		end)
		else if not(is_nil((term_tyvars concl) diff typars))
		then fail "icl'new_type_defn" 6057
			[fn () => string_of_thm defthm,
			 fn () => format_list (Combinators.I) 
			  ((term_tyvars concl) diff typars) ", "] 
		else if not(all_different typars)
		then fail "icl'new_type_defn" 6079 
			[fn () => two_the_same typars]
		else ());
=TEX
Now build up the new material:
=SML
	val (x,(p, x1)) = ((Combinators.I ** dest_app)(dest_simple_∂ concl)
		handle complaint =>
		case (area_of complaint) of
		"dest_app" => thm_fail "icl'new_type_defn" 6055 [defthm]
		| "dest_simple_∂" => thm_fail "icl'new_type_defn" 6054 [defthm]
		| _ => reraise complaint (area_of complaint));

	val dummy = if not(x =$ x1)
		then thm_fail "icl'new_type_defn" 6080 [defthm]
		else ();

	val arity = length typars;

	val new_type = mk_ctype(tnm, map mk_vartype typars);

	val ftype = mk_≠_type(new_type, type_of x);

	val f = mk_var("f",ftype); (* cannot be present in p, from frees test *)

	val td = mk_const("TypeDefn",mk_≠_type(type_of p,
		mk_≠_type(ftype, BOOL)));

	val seq_concl = mk_simple_∂(f, list_mk_app (td, [p, f]));

	val new_type_defn = Thm{level = current_level+1, 
		theory=theory, 
		sequent = ([], seq_concl)};

	val ty_decl = {arity = arity,level=current_level+1};

	val new_ty_env = (tnm, ty_decl) :: ty_env;

	val new_cty_env = add_ty_env [ (tnm,ty_decl)] cty_env;

	val new_def_ed = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			e_extend key new_type_defn dct
			handle complaint =>
			divert complaint "e_extend" 
				"icl'new_type_defn" 6051
				 [(fn () => key),
				 (fn () => get_current_theory_name())])
		keys)
		def_ed);

	val new_defn_dict = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			(key, new_type_defn) :: dct)
		keys)
		defn_dict);

	val new_thy = Thy{name = iname,
		ty_env = new_ty_env,
		con_env=con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = new_defn_dict,
		thm_dict = thm_dict,
		current_level = current_level+1,
		user_data = user_data};
	val was_inconsistent = !inconsistent;
in
	inconsistent:=true;
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory, ty_env=new_cty_env, 
		con_env=ccon_env,
		defn_dict = new_def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed};
	inconsistent:=was_inconsistent;
	new_type_defn
end);
=TEX
The following is a function to introduce a new specification.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
Note that this function examines theorems involving $∂$,
through there is no guarantee of this constant being present yet.
=SML
fun €icl'new_spec› (keys : string list, ndef : int, 
	defthm : THM as Thm{sequent = (asms, concl),...}) : THM = (
let	val {hierarchy=hierarchy as hier(inconsistent,lookup),
		 theory=theory, ty_env=cty_env, 
		con_env=ccon_env,
		defn_dict = def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed} = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;
=TEX
Do the checks required (other than on keys, and theorem form):
=SML
	val dummy = (check_c_writable "icl'new_spec";
		check_thm "icl'new_spec" defthm;
		wf_thm "icl'new_spec" defthm;
		if is_nil keys
		then fail "icl'new_spec" 6031 []
		else if not(is_nil (frees concl))
		then (let val fc = map (fst o dest_var)(frees concl) in
			if length fc = 1
			then 
			fail "icl'new_spec" 6056 
			[fn () => hd fc,
			 fn () => string_of_thm defthm]
			else
			fail "icl'new_spec" 6062 
			[fn () => format_list Combinators.I fc ", ",
			 fn () => string_of_thm defthm]
		end)
		else if ndef < 1
		then fail "icl'new_spec" 6044 []
		else if is_nil asms
		then ()
		else thm_fail "icl'new_spec" 6053 [defthm]
		);
=TEX
Now build up the new material:
=SML
	fun nexists (n:int) (tm : TERM) (res : TERM list) : (TERM list * TERM) = (
		if n = 0 
		then (res, tm)
		else (let val (x,bdy) = dest_simple_∂ tm
			handle complaint =>
			divert complaint "dest_simple_∂" "icl'new_spec" 
			6060 [fn () => string_of_thm defthm,
				fn () => string_of_int ndef]
		in
			nexists (n-1) bdy (res @ [x])
		end)
	);

	val (xlist, bdt) = nexists ndef concl [];

	val xtyvars = term_tyvars(hd xlist);
=TEX
Check the results of picking apart the theorem:
=SML
	val dummy = (if any (tl xlist) (fn x => not((term_tyvars x) ~= xtyvars)) 
		then term_fail "icl'new_spec" 6081 [hd xlist, 
			find (tl xlist) (fn x => not((term_tyvars x) ~= xtyvars))]
		else if not(is_nil((term_tyvars bdt) diff xtyvars))
		then fail "icl'new_spec" 6061
			[fn () => string_of_thm defthm,
			 fn () => format_list (Combinators.I) 
			 ((term_tyvars concl) diff xtyvars) ", "]
		else if not(all_distinct (op =$) xlist)
		then fail "icl'new_spec" 6016 
			[fn () => fst(dest_var(two_the_same1 (op =$) xlist)),
			 fn () => string_of_thm defthm]
		else ();
		map (fn x =>
			let val (cnm,ty) = dest_var x
			in
			(case const_in_anc_or_des cnm of
			InScope => fail "icl'new_spec" 6049 [fn () => cnm]
			| InDescendant => fail "icl'new_spec" 6063 [fn () => cnm]
			| NotPresent => ())
			end)
		xlist;
		());

	val new_consts = map (fn x => mk_const(dest_var x)
		handle complaint =>
		pass_on complaint "mk_const" "icl'new_spec") xlist;

	val new_current_level = current_level+1;

	val con_decl = map (fn x => let val(cnm,ty) = dest_var x
			in
			(cnm,{ty=ty,level=new_current_level})
			end)
		xlist;

	val new_con_env = fold 
		(fn (cnm_entry, dict) => cnm_entry ::  dict)
		 con_decl con_env;

	val new_ccon_env = add_con_env con_decl ccon_env;

	val new_concl = subst(combine new_consts xlist) bdt;
=TEX
Now put everything in the correct place:
=SML
	val new_defn = Thm{level = current_level+1, 
		theory=theory, 
		sequent = ([], new_concl)};

	val new_def_ed = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			e_extend key new_defn dct
			handle complaint =>
			divert complaint "e_extend" "icl'new_spec" 6051 
				[(fn () => key),
				(fn () => get_current_theory_name())])

		keys)
		def_ed);

	val new_defn_dict = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			(key, new_defn) ::  dct)

		keys)
		defn_dict);

	val new_thy = Thy{name = iname,
		ty_env = ty_env,
		con_env = new_con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = new_defn_dict,
		thm_dict = thm_dict,
		current_level = current_level+1,
		user_data = user_data};
	val was_inconsistent = !inconsistent;
in
	inconsistent:=true;
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=new_ccon_env,
		defn_dict = new_def_ed, axiom_dict = ax_ed, thm_dict = thm_ed,
		sealed=sealed};
	inconsistent := was_inconsistent;
	new_defn
end);
=TEX
=SML
fun €get_const_type› (nm : string) : TYPE OPT = (
	case (get_con_env nm) of
	Value {ty = ty,...} => Value ty
	| _ => Nil
);
=TEX
=SML
fun €get_type_arity› (nm : string) : int OPT = (
	case (get_ty_env nm) of
	Value {arity=arity,...} => Value arity
	| _ => Nil
);
=TEX

\section{PRIMITIVE INFERENCE RULES OF ADT THM}
The functions in this section, other than the utilities, follow the specifications of
\cite{DS/FMU/IED/SPC003} and \cite{DS/FMU/IED/SPC004}.
\subsection{Utilities}
Do union up to $\alpha$-conversion:
Give the frees of a list of terms:
=SML
val €list_frees› = list_union (op =$) o map frees;
=TEX
Then provide a test for being free in a list of terms:
=SML
fun €list_is_free_in› (x:TERM) (tms:TERM list) : bool = (
	any tms (fn p => is_free_in x p)
);
=TEX
Create a theorem from a sequent of the current theory and current definition level:
=SML
fun €mk_current_thm›(seq : SEQ) : THM = (
let	val {theory = theory,...} = !current;

	val Thy{current_level = current_level,...} = !theory;
in
	Thm{theory = theory, level = current_level, sequent = seq}
end);
=TEX

\subsection{icl'subst\_rule}
This function partially evaluates with one or two arguments.
=FRULE 1 Rule
icl'subst_rule
˜
[á1 Ù t1=t1', ... , án Ù tn=tn']
á Ù t[t1,...tn]
˜
á1 ¿ ... án ¿ á Ù t[t1',...tn']
=TEX
The following local function takes the input list and hypotheses to $icl'subst\_rule$, and returns the 
substitution lists for $var\_subst$, as well as the 
new assumption list.
=SML
local 
	fun two_subst_lists (lhslst : (TERM * TERM) list)
		(rhslst : (TERM * TERM) list)
		(new_hyps : TERM list) 
		([] : (THM * TERM) list) :
		(((TERM * TERM) list) * ((TERM * TERM) list) * (TERM list)) = (
		lhslst, rhslst, new_hyps
	) | two_subst_lists lhslst rhslst new_hyps ((thmi,vari) :: lst) = (
	let val (nhyps,(lhsi,rhsi)) = dest_thm_eq "icl'subst_rule" 6002 thmi;
	in
		if not(is_var vari)
		then term_fail "icl'subst_rule" 3007 [vari]
		else if not(type_of lhsi =: type_of vari)
		then fail "icl'subst_rule" 6029 [fn () => string_of_thm thmi, 
			fn () => string_of_term vari]
		else (two_subst_lists ((lhsi, vari) :: lhslst)
			((rhsi, vari) :: rhslst)
			(nhyps term_union new_hyps)
			lst)
	end);
in
=TEX
Main function:
=SML
fun €icl'subst_rule› (thm_var_list : (THM * TERM) list):
	TERM -> THM -> THM = (
	if is_nil thm_var_list
	then (
=TEX
We optimize for the special case of an empty $thm\_var\_list$, which is just returning a theorem that is $\alpha$-convertible to the input:
=SML
		(fn (template : TERM) => 
		(fn (ithm as Thm{sequent = (asms,concl),...}) =>
		let val dummy = check_thm "icl'subst_rule" ithm;
		in
			if concl ~=$ template
			then mk_current_thm(asms, template)
			else term_fail "icl'subst_rule" 6001 [template, concl]
		end))
	)
=TEX
We now consider doing a full substitution.
Create (while checking) two lists, one of $lhs_i\ ∏\ var_i$,
one of $rhs_i\ ∏\ var_i$, as well as accumulating the hypotheses of the theorems used; 
create two terms, $lhs$ and $rhs$, from $template$,
one by the $lhs$ substitutions, the other by the $rhs$;
if the $lhs$ is $\alpha$-convertible to $concl$, then
return the theorem that the $rhs$ term is true.
=SML
	else (
	let val (lhssubs, rhssubs, new_hyps) = two_subst_lists [] [] [] thm_var_list;
	in
	(fn (template : TERM) => let
		val template_as_lhs = var_subst lhssubs template;
		val template_as_rhs = var_subst rhssubs template;
	in
	(fn (ithm as Thm{sequent = (asms,concl),...}) =>
		let val dummy = (check_thm "icl'subst_rule" ithm;
			map (check_thm "icl'subst_rule" o fst) thm_var_list);
		in
			if concl ~=$ template_as_lhs
			then mk_current_thm(asms term_union new_hyps, template_as_rhs)
			else term_fail "icl'subst_rule" 6001 [template_as_lhs, concl]
		end
	)
	end
	)
	end
	)
); (* end of if..then...else... *)
end; (* of local fun two_subst_lists ... *)
=TEX
\subsection{icl'simple\_Ã\_eq\_rule}
=FRULE 1 Rule
icl'simple_Ã_eq_rule
¨xÆ
˜
á Ù t1[x] = t2[x]
˜
á Ù (Ã x ∑ t1[x]) = (Ã x ∑ t2[x])
=TEX
And:
=FRULE 1 Rule
icl'simple_Ã_eq_rule
¨xÆ
˜
á Ù t1[x] § t2[x]
˜
á Ù (Ã x ∑ t1[x]) = (Ã x ∑ t2[x])
=TEX
=SML
fun €icl'simple_Ã_eq_rule› (absvar : TERM) (thrm : THM) 
	: THM = (
let	 val dummy = (check_thm "icl'simple_Ã_eq_rule" thrm;
		if not(is_var absvar)
		then term_fail "icl'simple_Ã_eq_rule" 3007 [absvar]
		else ());

	val (asms,(lhs,rhs)) = dest_thm_eq "icl'simple_Ã_eq_rule" 6020 thrm;

	val dummy = if list_is_free_in absvar asms
		then term_fail "icl'simple_Ã_eq_rule" 6005 [absvar]
		else ();
in
	mk_current_thm (asms, 
		mk_eq(mk_simple_Ã(absvar, lhs),mk_simple_Ã(absvar, rhs)))
end);
=TEX
\subsection{icl'inst\_type\_rule}
=FRULE 1 Rule
icl'inst_type_rule
[(”1, tyv1), ..., (”n,tyvn)]
˜
á Ù t[tyv1,...tyvn]
˜
á Ù t[”1,...”n]
=TEX
=SML
fun €icl'inst_type_rule› (talist: (TYPE * TYPE) list)
	(thrm : THM as Thm{sequent = (asms, concl),...}) : THM = (
let	val dummy = check_thm "icl'inst_type_rule" thrm;

	val usingtvs : string list = map (fn (t,tv) => (dest_vartype tv
		handle complaint =>
		pass_on complaint "dest_vartype" "icl'inst_type_rule"))
		talist;

	val dummy = if any asms (fn x => any (term_tyvars x)
			(fn y => y mem usingtvs))
		then fail "icl'inst_type_rule" 6006 
			[fn () => find (term_tyvars (find asms (fn x => any (term_tyvars x)
			(fn y => y mem usingtvs))))
			(fn y => y mem usingtvs)]
		else ();
in
	mk_current_thm(asms, inst (list_frees asms) talist concl)
end);
=TEX
\subsection{icl'¥\_intro}
=FRULE 1 Rule
icl'¥_intro
¨t1Æ
˜
á Ù t2
˜
á - {t1} Ù t1 ¥ t2
=TEX
=SML
fun €icl'¥_intro› (asm : TERM) (thrm : THM as Thm{sequent = (asms,concl),...}) : THM = (
let	val dummy = (check_thm "icl'¥_intro" thrm;
	if type_of asm =: BOOL
	then ()
	else term_fail "icl'¥_intro" 3031 [asm]);
in
	mk_current_thm(asms term_less asm, mk_¥(asm, concl))
end);
=TEX
\subsection{icl'¥\_elim}
=FRULE 1 Rule
icl'¥_elim
˜
á1 Ù t1 ¥ t2; á2 Ù t1'
˜
á1 ¿ á2 Ù t2
=TEX
=SML
fun €icl'¥_elim› (thrm1 : THM as Thm{sequent = (hyps1,concl1),...})
	(thrm2 : THM as Thm{sequent = (hyps2,concl2),...}) : THM = (
let	val dummy = (check_thm "icl'¥_elim" thrm1;
		check_thm "icl'¥_elim" thrm2);

	val (hconcl1,cconcl1) = (dest_¥ concl1 
		handle complaint =>
		case (area_of complaint) of
		"dest_¥" => thm_fail "icl'¥_elim" 6010 [thrm1]
		| _ => reraise complaint (area_of complaint));
in
	if hconcl1 ~=$ concl2
	then mk_current_thm(hyps1 term_union hyps2, cconcl1)
	else thm_fail "icl'¥_elim" 6011 [thrm1, thrm2]
end);
=TEX
\subsection{icl'asm\_rule}
=FRULE 1 Rule
icl'asm_rule
¨tÆ
˜
˜
t Ù t
=TEX
=SML
fun €icl'asm_rule› (tm : TERM) : THM = (
	if type_of tm =: BOOL
	then mk_current_thm([tm],tm)
	else term_fail "icl'asm_rule" 3031 [tm]
);
=TEX
\subsection{icl'refl\_conv}
=FRULE 1 Rule
icl'refl_conv
¨tÆ
˜
˜
Ù t = t
=TEX
Or, if $t$ is boolean:
=FRULE 1 Rule
icl'refl_conv
¨tÆ
˜
˜
Ù t § t
=TEX
=SML
val €icl'refl_conv› : CONV = (fn (tm : TERM) =>
	mk_current_thm([],mk_eq(tm,tm))
);
=TEX
\subsection{icl'simple\_$\beta$\_conv}
=FRULE 1 Conversion
icl'simple_¬_conv
¨(Ã x ∑ t1[x]) t2Æ
˜
˜
Ù (Ã x ∑ t1[x]) t2 = t1[t2]
=TEX
Or, if the term is of type $BOOL$:
=FRULE 1 Conversion
icl'simple_¬_conv
¨(Ã x ∑ t1[x]) t2Æ
˜
˜
Ù (Ã x ∑ t1[x]) t2 § t1[t2]
=TEX
=SML
val €icl'simple_¬_conv› : CONV = (fn (tm : TERM) =>
let	val ((vr, t1), t2) = ((dest_simple_Ã ** Combinators.I)(dest_app tm)
		handle complaint =>
		case (area_of complaint) of
		"dest_simple_Ã" => term_fail "icl'simple_¬_conv" 6012 [tm]
		| "dest_app" => term_fail "icl'simple_¬_conv" 6012 [tm]
		| _ => reraise complaint (area_of complaint));
	val rhs = var_subst [(t2,vr)] t1;
in
	mk_current_thm([],mk_eq(tm,rhs))
end);
=TEX
\subsection{icl'suc\_conv}
We have no specification for this.
=FRULE 1 Rule
icl'suc_conv
(mk_Ó (m+1))
˜
˜
Ù ^(mk_Ó(m+1)) = Suc ^(mk_Ó m)
=TEX
=FRULE 1 Rule
icl'suc_conv
(mk_Ó 0)
˜
˜
Ù 0 = Zero
=TEX
The following inference rule relies on the well-formedness of the following constants.
=SML
local
	val €Suc› = mk_const("Suc",mk_≠_type(Ó, Ó));
	val €Zero› = mk_const("Zero", Ó);
in
=TEX
=SML
val €icl'suc_conv› : CONV = (fn (tm : TERM) =>
let	val nint = (dest_Ó tm
		handle complaint =>
		pass_on complaint "dest_Ó" "icl'suc_conv");

	val rhs = if nint = zero
		then Zero
		else mk_app(Suc, mk_Ó (nint @- one));
in
	mk_current_thm([],mk_eq(tm,rhs))
end);
end;
=TEX
\subsection{icl'string\_conv}
We have no specification for this.
=FRULE 1 Rule
icl'string_conv
(mk_string ("c" :: t))
˜
˜
Ù ^(mk_string("c" :: t)) = 
Cons ^(mk_char("c")) ^(mk_string(t))
=TEX
Or:
=FRULE 1 Rule
icl'string_conv
(mk_string "")
˜
˜
Ù ^(mk_string("")) = Nil
=TEX
The following inference rule relies on the well-formedness of the following constants.
=SML
local
	val SCons = mk_const("Cons",mk_≠_type(CHAR, mk_≠_type(STRING, STRING)));
	val SNil = mk_const("Nil", STRING);
in
val €icl'string_conv› : CONV = (fn (tm : TERM) =>
let	val sex = explode(dest_string tm)
		handle complaint =>
		pass_on complaint "dest_string" "icl'string_conv";

	val rhs = if is_nil sex
		then SNil
		else list_mk_app(SCons,
			[mk_char(hd sex),
			mk_string(implode (tl sex))]);

in
	mk_current_thm([],mk_eq(tm,rhs))
end);
end;
=TEX
\subsection{icl'char\_conv}
We have no specification for this.
=FRULE 1 Rule
icl'char_conv
(mk_char("c"))
˜
˜
Ù ^(mk_char("c")) = AbsChar ^(ord "c")
=TEX
The following inference rule relies on the well-formedness of the following constant.
=SML
local 
	val AbsChar = mk_const("AbsChar",mk_≠_type(Ó,CHAR));
in
val €icl'char_conv› : CONV = (fn (tm : TERM) =>
let	val cnum = integer_of_int(ord(dest_char tm))
		handle complaint =>
		pass_on complaint "dest_char" "icl'char_conv";
	
	val rhs = mk_app(AbsChar, mk_Ó cnum);
in
	mk_current_thm([],mk_eq(tm,rhs))
end);
end;
=TEX
\section{BUILT-IN INFERENCE RULES OF ADT $THM$}
The inference rules in this section are justified by
the informal reasoning given in \cite{DS/FMU/IED/DTD006}.
They should mimic the end results of the reasoning stated there, for any acceptable input.
\subsection{icl'eq\_sym\_rule}
=FRULE 1 Rule
icl'eq_sym_rule
˜
á Ù t1 = t2
˜
á Ù t2 = t1
=TEX
And:
=FRULE 1 Rule
icl'eq_sym_rule
˜
á Ù t1 § t2
˜
á Ù t2 § t1
=TEX
=SML
fun €icl'eq_sym_rule› (thrm : THM) : THM = (
let	val dummy = check_thm "icl'eq_sym_rule" thrm;

	val (asms,(lhs_concl,rhs_concl)) = dest_thm_eq "icl'eq_sym_rule" 6020 thrm;

	val new_concl = mk_eq(rhs_concl, lhs_concl);
in
	mk_current_thm(asms, new_concl)
end);
=TEX
\subsection{icl'list\_simple\_µ\_elim}
=FRULE 1 Rule
icl'list_simple_µ_elim
[...,¨t1Æ,...]
˜
á Ù µ ...x... ∑ t2[...,xn,...]
˜
á Ù t2'[...,tn,...]
=TEX
In the following, when creating the local variable $subs$, of substitutions
to be carried out, we reverse the order of the list so that
if there are two nested quantifiers with the same variable,
the inner quantifier's instantiation has effect, and the
outer one is ignored.
=SML
local
	fun simple_n_µ 0 acc tm = (acc,tm)
	| simple_n_µ n acc tm = (
	let val (v,bdy) = dest_simple_µ tm
	in
		simple_n_µ (n-1) (acc @ [v]) bdy
	end);
in
fun €icl'list_simple_µ_elim› (tml : TERM list) 
	(thrm : THM as Thm{sequent = (asms,concl),...}) : THM = (
let	val dummy = check_thm "icl'list_simple_µ_elim" thrm;

	val ninsts = length tml;
	
	val (bvl, bdy) = (simple_n_µ ninsts [] concl
		handle complaint =>
		case (area_of complaint) of
		"dest_simple_µ" => fail "icl'list_simple_µ_elim" 6018 
			[fn () => string_of_thm thrm,
			fn () => string_of_int ninsts]
		| _ => reraise complaint (area_of complaint));

	val subs = rev(combine tml bvl);

	val new_concl = (var_subst subs bdy
		handle complaint =>
		pass_on complaint "var_subst" "icl'list_simple_µ_elim");
in
	mk_current_thm(asms, new_concl)
end);
end; (* local fun simple_n_µ = *)
=TEX
\subsection{icl'eq\_trans\_rule}
=FRULE 1 Rule
icl'eq_trans_rule
˜
á1 Ù t1 = t2; á2 Ù t2' = t3
˜
á1 ¿ á2 Ù t3
=TEX
And:
=FRULE 1 Rule
icl'eq_trans_rule
˜
á1 Ù t1 § t2; á2 Ù t2' § t3
˜
á1 ¿ á2 Ù t1 § t3
=TEX
=SML
fun €icl'eq_trans_rule› (thrm1 : THM) (thrm2 : THM) : THM = (
let	val dummy = (check_thm "icl'eq_trans_rule" thrm1;
		check_thm "icl'eq_trans_rule" thrm2);

	val (hyps1,(lhs_concl1,rhs_concl1)) = dest_thm_eq "icl'eq_trans_rule" 6020 thrm1;

	val (hyps2,(lhs_concl2,rhs_concl2)) = dest_thm_eq "icl'eq_trans_rule" 6020 thrm2;

	val dummy = if rhs_concl1 ~=$ lhs_concl2
		then ()
		else thm_fail "icl'eq_trans_rule" 6022 [thrm1, thrm2];

	val new_concl = mk_eq(lhs_concl1,rhs_concl2);
in
	mk_current_thm(hyps1 term_union hyps2, new_concl)
end);
=TEX
\subsection{icl'mk\_app\_rule}
=FRULE 1 Rule
icl'mk_app_rule
˜
á1 Ù u1 = u2; á2 Ù v1 = v2
˜
á1 ¿ á2 Ù u1 v1 = u2 v2
=TEX
=SML
fun €icl'mk_app_rule› (thrm1 : THM) (thrm2 : THM) : THM = (
let	val dummy = (check_thm "icl'mk_app_rule" thrm1;
		check_thm "icl'mk_app_rule" thrm2);

	val (hyps1,(lhs_concl1,rhs_concl1)) = dest_thm_eq "icl'mk_app_rule" 6020 thrm1;

	val (hyps2,(lhs_concl2,rhs_concl2)) = dest_thm_eq "icl'mk_app_rule" 6020 thrm2;

	val new_concl = mk_eq(mk_app(lhs_concl1, lhs_concl2),
		mk_app(rhs_concl1,rhs_concl2))
		handle complaint =>
		case (area_of complaint) of
		"mk_app" => thm_fail "icl'mk_app_rule" 6023 [thrm1, thrm2]
		| _ => reraise complaint (area_of complaint);
in
	mk_current_thm(hyps1 term_union hyps2, new_concl)
end);
=TEX
\subsection{icl'§\_mp\_rule}
=FRULE 1 Rule
icl'§_mp_rule
˜
á1 Ù t1 § t2; á2 Ù t1'
˜
á1 ¿ á2 Ù t2
=TEX
=SML
fun €icl'§_mp_rule› (thrm1 : THM)
	(thrm2 : THM as Thm{sequent = (hyps2,concl2),...}) : THM = (
let	val dummy = (check_thm "icl'§_mp_rule" thrm1;
		check_thm "icl'§_mp_rule" thrm2);

	val (hyps1,(lhs_concl1,rhs_concl1)) = dest_thm_eq "icl'§_mp_rule" 6030 thrm1;

	val side_effect = if type_of lhs_concl1 =: BOOL
		then ()
		else thm_fail "icl'§_mp_rule" 6030 [thrm1];

	val new_concl = if lhs_concl1 ~=$ concl2
		then rhs_concl1
		else thm_fail "icl'§_mp_rule" 6024 [thrm1, thrm2];
in
	mk_current_thm(hyps1 term_union hyps2, new_concl)
end);
=TEX
\subsection{icl'simple\_µ\_intro}
=FRULE 1 Rule
icl'simple_µ_intro
¨xÆ
˜
á Ù t
˜
á Ù µ x ∑ t
=TEX
=SML
fun €icl'simple_µ_intro› (tm : TERM) 
	(thrm : THM as Thm{sequent = (asms,concl),...}) : THM = (
let	val dummy = check_thm "icl'simple_µ_intro" thrm;
		
	val dummy = (if not(is_var tm)
		then term_fail "icl'simple_µ_intro" 3007 [tm]
		else if list_is_free_in tm asms
		then term_fail "icl'simple_µ_intro" 6005 [tm]
		else ());

	val new_concl = mk_simple_µ(tm,concl);
in
	mk_current_thm(asms, new_concl)
end);
=TEX
\subsection{icl'inst\_term\_rule}
=FRULE 1 Rule
icl'inst_term_rule
[..., (¨tiÆ, ¨xiÆ), ...]
˜
á Ù t[x1, ..., xn]
˜
á Ù t[t1, ..., tn]
=TEX
=SML
fun €icl'inst_term_rule› (tvl : (TERM * TERM)list) 
	(thrm : THM as Thm{sequent = (asms,concl),...}) : THM = (
let	val dummy = check_thm "icl'inst_term_rule" thrm;

	val svars = (map (fn (t,x) => (
		let val (_,xty) = (dest_var x
			handle complaint =>
			pass_on complaint "dest_var" "icl'inst_term_rule")
		in
			if type_of t =: xty
			then x
			else term_fail "icl'inst_term_rule" 6027 [t,x]
		end))		
		tvl);
		
	fun rogue x = list_is_free_in x asms;
 
	val dummy = if any svars rogue
		then term_fail "icl'inst_term_rule" 6028 
			[find svars rogue]
		else ();

	val new_concl = var_subst tvl concl;
in
	mk_current_thm(asms, new_concl)
end);
=TEX
\subsection{icl'plus\_conv}
=FRULE 1 Rule
icl'plus_conv
¨ëmk_Ó mÆ + 
 ëmk_Ó nÆÆ
˜
˜
Ù ¨ëmk_Ó mÆ +
	ëmk_Ó nÆÆ = 
	ëmk_Ó(m + n)Æ
=TEX
=SML
val €icl'plus_conv› : CONV = (fn (tm : TERM) =>
let	val (m,n) = dest_bin_op "icl'plus_conv" 6085 "+" tm;

	val mint = dest_Ó m;
	val nint = dest_Ó n;
	val rhs = mk_Ó (mint @+ nint);
in
	mk_current_thm([],mk_eq(tm,rhs))
end
handle complaint =>
divert complaint "dest_Ó" "icl'plus_conv" 6085
	[fn () => string_of_term tm]
);
=TEX

\section{END OF THE ADT}
=SML
end; (* of abstype THM *)
=TEX
=SML
fun €pp'string_of_thm› (t : THM) : string = (
	let	val {sequent = (asms, conc), ...} = icl'dest_thm t;
	in	format_list string_of_term asms "," ^ "Ù" ^ string_of_term conc
	end
);
=TEX
=SML
end; (* of structure icl'Kernel *)
val _ = icl'Kernel.pp'set_string_of_thm icl'Kernel.pp'string_of_thm;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
