=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Implementation for Abstract Data Type $THM$}  %% Mandatory field
\def\TPPheadtitle{Implementation for Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/IMP006}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2,1.3]
Still being created.
\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the abstract data type $THM$.
This includes its
primitive and built-in inference rules,
and its theory management material.
This is called for in section 4 of \cite{DS/FMU/IED/HLD007}.
The high-level specification for the code is
given in \cite{DS/FMU/IED/SPC003}, \cite{DS/FMU/IED/SPC004} and \cite{DS/FMU/IED/SPC005}.
The design is in \cite{DS/FMU/IED/DTD006}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the 
abstract data type $THM$.
This includes its
primitive and built-in inference rules,
and its theory management material.
A ``primitive'' inference rule is considered to be part of the logic,
whereas a built-in rule is one that, though it could be coded in terms 
of the primitive rules, will actually be part of the abstract data type $THM$, and thus taken as holding true without checking.

We have to assume that single assignments cannot be interrupted,
but that any sequence of commands may be.
We need to maintain consistency between certain parts of state,
and thus we have some $handle\ \_\ =>$ protected functions.
It is a implementation goal that consistency of state is maintained.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD006},
and also requires those files indicated as preceding it in the 
rel001 makefile.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}

=TEX
\newpage
\section{INTERRUPTS AND INCONSISTENCY}
There are three activities we sometimes wish to do in uninterruptable combinations.
Interrupts might be, for instance, due to the user pressing Control-C, or the program running out of machine resources.
\begin{enumerate}
\item
``In place'' modification of $icl'THEORY\_INFO$s within the hierarchy, using the fact that the hierarchy is an (imperative-style) array and using array assignment.
\item
Changes to the current state, other than ``in place''. 
In particular, modifications to the type and constructor enviroments $ty\_env$ and $con\_env$.
\item
Assignments to the current theory address, to update the theory rather than change the theory that is current.
\end{enumerate}
If combinations of these were interrupted they might lead to some of the following:
\begin{itemize}
\item
The type or constructor enviroments containing items that are not actually within any theory in scope.
This can cause theorems to be apparently valid, when in fact they are not.
\item
The type or constructor enviroments failing to contain items that are actually within some theory in scope.
This could allow the redefinition of such things while theorems concerning
the old definition are still in scope
(and are made valid once more by the redefinition placing the items in the type or constructor enviroment).
\item
A theory may have another as parent that does not record its child in its $children$ field
(we take the $parents$ field as definitive).
This would allow the parent to declare things that clashed with its child's contents, and would sometimes allow the parent to be deleted
leaving an orphan.
\item
A theory may indicate it has another as a child, while the so-called child does not record the other as parent.
This will cause the parent to be unable to redefine things present in the so-called child that strictly it should be able to do.
This is not inconsistent, but only inconvenient.
\item 
Having the $inscope$ fields inconsistent with the current theory and the parentage relation has the same problems as the $children$ field being inconsistent.
If the $inscope$ fields are inconsistent with the type and constant environments
then this will give rise to the same problems as if those are
inconsistent with the theories contents.
\end{itemize}
These problems could occur in the following functions:

\begin{tabular}{| l | p{5.0in}|}\hline
Function & Combination \\ \hline
$icl'open\_theory$ & Multiple ``in place'' modifications to the hierarchy and environments, and a change of address for the current theory: but all made safe by using a copy of the current hierarchy(1,2). \\
$icl'delete\_theory$ & Multiple ``in place'' modifications to the hierarchy: the deleted theory, and its parents. Can also leave
some garbage if interrupted(1,2). \\
$icl'new\_theory$ & Two ``in place'' modifications to the hierarchy
(new theory and parent), and a change to the state (the value of $top\_theory$)(1,2). \\
$icl'duplicate\_theory$ & Multiple ``in place'' modifications to the hierarchy
(new theory and its parents), and a change to the state (the value of $top\_theory$)(1,2). \\
$delete\_extension$ & Deletions from environments and an assignment to current theory address(2,3). \\
$icl'new\_const$ & Addition to constant environment and an assignment to current theory address(2,3). \\
$icl'new\_type$ & Addition to type environment and an assignment to current theory address(2,3). \\
$icl'new\_definition$ & Addition to constant environment and an assignment to current theory address(2,3). \\
$icl'new\_type\_definition$ & Addition to type environment and an assignment to current theory address(2,3). \\
$icl'new\_specification$ & Additions to constant environment and an assignment to current theory address(2,3). \\
$icl'new\_parent$ & Additions to constant and type environments, an assignment to current theory address, and ``in place'' modifications to the hierarchy (new parent and current theory)(2,3). \\ \hline
\end{tabular}

These problems occur because we maintain ``value added'' copies of 
definitive information, usually to increase speed.
One solution would be to eliminate the copies, and accept the time
cost: this seems an unreasonable deal, and might not solve the 
problem.
Another solution would be to maintain a backup of the entire system
to be reverted to in the case of an error. 
This would have a time penalty, would have to be careful in
avoiding introducing inconsistencies, and might be vulnerable to multiple interrupts.

We choose as a solution the introduction of a flag in the $STATE$ (q.v.),
that is set on entering a block of code that is dangerous if interrupted,
and reset on exiting normally.
An interrupt will leave the flag set.
All validity checkers, in particular $check\_thm$ (q.v)
and $check\_c\_writable$
(``check current theory writable'', q.v.),
will check the flag, and if it is set then the validity check will fail.
Thus an unfortunately timed interrupt could render the system ``you can look, but you can't don't touch''.
This is indicated by the error message:

\begin{verbatim}
6083	STATE RENDERED INCONSISTENT: state is now read-only, and
	you are advised to quit ICL HOL. Do not commit the ML database.
\end{verbatim}

\section{THE ABSTRACT DATA TYPE $THM$}
=SML
(* structure ‚icl'Theorems· : icl'Theorems = struct *)
=TEX
\subsection{Utilities}
Give the maximum of a list of numbers.
The maximum of n empty list is $0$ (could be made a fail).
=SML
fun ‚list_max· ([]: int list): int = 0
| list_max (a :: x) = (
let fun aux (sf:int) ((p :: q):int list) : int = (
	if sf <= p
	then aux p q
	else aux sf q
	) | aux sf [] = sf;
in
	aux a x
end);
=TEX
Give a list of HOL type variables $'1, '2,\ldots$:
=SML
fun ‚ntyvars· (n : int) = (
	map (fn x=> mk_vartype("'"^string_of_int x))
		(interval 1 n)
);
=TEX
Given two lists, considered as sets are they equal:
=SML
local
	exception SetEqual
in
fun ‚set_equal· ([]: ''a list) ([]:''a list) : bool = true 
| set_equal [] _ = false
| set_equal _ [] = false
| set_equal (a1 :: x1) l2 = (
	let fun aux (a2 :: x2) = (
		if (a1 = a2)
		then (x2 less a1)
		else (a2 :: aux x2)
	) | aux [] = raise SetEqual
	in
		set_equal (x1 less a1) (aux l2)
	end)
	handle SetEqual => false
end;

=TEX
\subsubsection{Ranges}
We are interested in supporting ranges of deleted levels,
but the code can be given in isolation from
the type of theories.

We are interested in a list of numbers,
\[ [ (a_{1},\ b_{1}),\ (a_{2},\ b_{2}),\ ...,\ (a_n,\ b_n)]\]
where $b_{i-1}$ is always less than $a_i$,
$0\ <\ a_1$, 
and $a_i$ is always less than or equal to $b_i$.

First, we wish to check whether a number fails inside any of the ranges $a_i$ to $b_i$.
=SML
fun ‚range_mem· (v : int, [] : (int * int)list) = false
| range_mem (v, ((a,b) :: x)) = (
	(v >= a) andalso 
	((v <= b) orelse range_mem(v, x))
);
=TEX
Second, we wish to extend the range by adding (a,b), which may enclose other ranges.
=SML
fun ‚extend_range· (a:int,b:int) ([]:(int * int)list): (int * int)list= (
	[(a,b)]
) | extend_range (a,b) (lst as ((a1,b1) :: x)) = (
let
	fun fixb lw (lst1 as ((a2,b2) :: x1)) = (
		if b + 1 < a2
		then ((lw,b) :: lst1)
		else if b <= b2
		then ((lw,b2) :: x1)
		else fixb lw x1
	) | fixb lw [] = [(lw,b)];
in
	if a < a1 
	then fixb a lst
	else if b1+1 < a
	then ((a1,b1) :: extend_range (a,b) x)	
	else fixb a1 lst
end);
=IGN
val p = [(1,2), (6,8), (10,10), (12,13)];
extend_range (0,3) p;
extend_range (4,4) p;
extend_range (5,5) p;
extend_range (11,15) p;
extend_range (11,11) p;
=TEX
\subsection{Infinite Arrays}
We implement Infinite arrays as finite arrays of lists of values.
We expect that the lists will be short (generally only length 0 to 2, even in ``large'' applications, and we optimize for that).
=SML
signature ‚InfiniteArray· = sig
	type 'a ‚INFINITE_ARRAY·;
	val ‚create_ia· : unit -> '_a INFINITE_ARRAY;
	val ‚update_ia· : ('_a INFINITE_ARRAY * int * '_a) -> unit;
	val ‚sub_ia· : ('_a INFINITE_ARRAY * int) -> '_a;
end;
=TEX
=SML
structure ‚InfiniteArray· : InfiniteArray = struct
=TEX
Introduce the array package:
=SML
open Array;
=TEX
Infinite arrays are made of $size$ lists - an index picks from the list by indexing the array by $index\ mod\ size$,
and then takes the $index\ div\ size$'th member of the list
(0 being the first element of the list).
=SML
type '_a ‚INFINITE_ARRAY· = ('_a list) array;
=TEX
Give a single, hidden, source of the size of the array that holds the lists.
=SML
val size = 100;
=TEX
Create a new array, using a dummy argument to force the type.
=SML
fun ‚create_ia· (():unit): '_a INFINITE_ARRAY = (
	array (size, ([] : '_a list))
);
=TEX
Place the value at index given in array.
The function can ignore some ``gaps'' in the array, but not
others. 
We don't expect our use of the package to produce any gaps,
but it is easier to allow gaps to exist than detect this fact.
The final $else$ of $aux$ could be modified to
pad with $vl$ to allow all gaps to be ignored
at the cost of some spurious values within the array.
This is in excess to our needs.
=SML
fun ‚update_ia· ((arr : '_a INFINITE_ARRAY), 
		(index: int), 
		(vl : '_a)) = (
let fun aux (n:int) ([]: '_a list) : '_a list = (
	if n = 0
	then [vl]
	else error "update_ia" 6070 []
) | aux n (a :: x) = (
	if n = 0
	then (vl :: x)
	else (a :: aux (n-1) x));
in
	if index < 0
	then error "update_ia" 6070 []
	else let val imsize = index mod size;
		val sublist = (sub(arr, imsize))
	in
		update(arr, imsize, (aux (index div size) sublist))
	end
end);
=TEX
Subscript the infinite array, giving a failure if the 
entry does not exist.
=SML
fun ‚sub_ia· ((arr : '_a INFINITE_ARRAY), index : int) = ((
	if index < 0
	then error "update_ia" 6070 []
	else (nth (index div size) (sub(arr, index mod size))))
	handle complaint =>
		divert complaint "nth" "sub_ia" 6070 []
);
=TEX
=SML
end; (* structure InfiniteArray *)

open InfiniteArray;
open SimpleDictionary;
open EfficientDictionary;
=TEX
A fragment of some user data, and a collection of such
fragments:
=SML
datatype ‚USER_DATUM· =
	‚UD_Term· of TERM * (USER_DATUM list) |
	‚UD_Type· of TYPE * (USER_DATUM list) |
	‚UD_String· of string * (USER_DATUM list) |
	‚UD_Int· of int * (USER_DATUM list);

type ‚USER_DATA· = (USER_DATUM ref) S_DICT;
=TEX
The type of sequents:
=SML
type ‚SEQ· = TERM list * TERM;
=TEX
The type of the theory status:
=SML
datatype ‚THEORY_STATUS· =
	‚TSNormal· | ‚TSLocked· | ‚TSAncestor· | ‚TSDeleted·;
=TEX
We will make the following an $abstype$ in the end.
=SML
datatype ‚THM· = ‚thm· of {
		level : int,
		theory : THEORY ref, 
		sequent : SEQ}
and
	‚THEORY· = ‚thy· of {
		name : int,
		ty_env : {arity:int, level:int} S_DICT,
		con_env : {ty:TYPE, level:int} S_DICT,
		parents : int list,
		del_levels : (int * int) list,
		axiom_dict : THM S_DICT,
		definition_dict : THM S_DICT,
		theorem_dict : THM S_DICT,
		current_level : int,
		user_data : USER_DATA ref}
and
	‚icl'THEORY_INFO· = ‚ti· of {
		status : THEORY_STATUS,
		inscope : bool,
		contents : THEORY ref,
		children : int list,
		name : string}
and
=TEX
In a hierarchy there will be theories with internal names $0$ to $top\_theory$, though some may have the status ``deleted''.
=SML
	‚icl'HIERARCHY· = ‚hier· of {
		lookup : icl'THEORY_INFO INFINITE_ARRAY,
		top_theory : int};
(* with *)
=TEX
\subsection{The State Type}
=SML
type ‚STATE· = {hierarchy : icl'HIERARCHY,
	theory : THEORY ref,
	ty_env : {arity:int, level:int} E_DICT,
	con_env : {ty:TYPE, level:int} E_DICT,
	inconsistent : bool};
=TEX
\subsection{Interface Types}
=SML
type ‚THEORY_INFO· = {
		status : THEORY_STATUS,
		inscope : bool,
		contents : THEORY,
		children : int list,
		name : string};

type ‚HIERARCHY· = (string * THEORY_INFO) list;
=TEX
\subsection{The Initial State}
Give an empty theory, for initialisation
or deletion purposes.
The $pnts$ (for ``parents'') are given  as a list type to give a simple ``optional'' value method.
=SML
fun ‚empty_theory· (nm: int) (pnts : int list) : THEORY = (
	thy {name = nm,
	 ty_env = initial_s_dict,
	 con_env = initial_s_dict,
	 parents = pnts,
	 del_levels = [],
	 axiom_dict = initial_s_dict,
	 definition_dict = initial_s_dict,
	 theorem_dict = initial_s_dict,
	 current_level = 0,
	 user_data = ref initial_s_dict}
);
=TEX
Initialisation of the ICL State:
=SML
local
	val min = ref (empty_theory 0 []);

	val min_ti = ti {status = TSNormal,
		inscope = true,
		contents = min,
		children = [],
		name = "‚min·"};

	val init_hier_ia : icl'THEORY_INFO INFINITE_ARRAY = create_ia ();

	val dummy = update_ia(init_hier_ia, 0, min_ti);

	val init_hier :  icl'HIERARCHY = 
		(hier {lookup = init_hier_ia, top_theory = 0});
in
	val ‚current· : STATE ref = ref {
		hierarchy = init_hier,
		theory = min,
		ty_env = initial_e_dict,
		con_env = initial_e_dict,
		inconsistent=false};
end;
=TEX
Pointers into the current state:
=SML
fun ‚current_hierarchy· (():unit) : icl'HIERARCHY = (
let val {hierarchy=hierarchy,...} = !current
in
	hierarchy
end);

fun ‚current_theory· (():unit) : THEORY = (
let val {theory=theory,...} = !current
in
	!theory
end);
=TEX
\subsection{The Scope of Types and Constants}
We will need  to be able to rapidly check where HOL terms, types
and their derivatives are well-formed.
Well-formedness is just that the HOL type constructors and constants are in scope, with the right usage.
To do this efficiently we need a fast lookup facility for
type constructors and constants in scope.

Remove a simple dictionaries worth of constructor
information from an $E\_DICT$.
=SML
fun ‚del_con_env· (lst:{ty:TYPE, level:int} S_DICT) 
	(edict:{ty:TYPE, level:int} E_DICT): {ty:TYPE, level:int} E_DICT = (
	fold (fn ((nm,_),dct) => e_delete nm dct)
		lst
		edict
);

fun ‚del_ty_env· (lst:{arity:int, level:int} S_DICT)
	(edict:{arity:int, level:int} E_DICT) : {arity:int, level:int} E_DICT = (
	fold (fn ((nm,_),dct) => e_delete nm dct)
		lst
		edict
);
=TEX
Add a simple dictionaries worth of constructor
information to a scope.
=SML
fun ‚add_con_env· (lst:{ty:TYPE, level:int} S_DICT) 
	(edict:{ty:TYPE, level:int} E_DICT): {ty:TYPE, level:int} E_DICT= (
	list_e_merge edict lst
	handle complaint =>
	divert complaint "e_extend" "add_con_env" 6073 []
);

fun ‚add_ty_env· (lst:{arity:int, level:int} S_DICT) 
	(edict:{arity:int, level:int} E_DICT) : {arity:int, level:int} E_DICT = (
	list_e_merge edict lst
	handle complaint =>
	divert complaint "e_extend" "add_ty_env" 6073 []
);
=TEX
Look up a named entry in the value constructor or type constructor scopes.
These two functions could be made available to the user or interface
document, to allow, if nothing else, a ``what caused the well-formedness check to fail'' function to be written.
=SML
fun ‚get_con_env· (nm : string): {ty:TYPE, level:int} OPT = (
let val {con_env=con_env,...} = !current
in
	e_lookup nm con_env
end);

fun ‚get_ty_env· (nm : string):{arity:int, level:int} OPT = (
let val {ty_env=ty_env,...} = !current
in
	e_lookup nm ty_env
end);
=TEX
Add a theories environment to a pair of environment dictionaries:
=SML
fun ‚add_thy_env· (thy{ty_env=ty_env, con_env=con_env,...})
	((te : {arity:int, level:int} E_DICT),
	 (ce : {ty:TYPE, level:int} E_DICT)) = (
	add_ty_env ty_env te,
	add_con_env con_env ce
);
=TEX
Delete a theories environment to a pair of environment dictionaries:
=SML
fun ‚del_thy_env· (thy{ty_env=ty_env, con_env=con_env,...})
	((te : {arity:int, level:int} E_DICT),
	 (ce : {ty:TYPE, level:int} E_DICT)) = (
	del_ty_env ty_env te,
	del_con_env con_env ce
);
=TEX
\subsection{Utilities Depending on ADT State and Types}
\subsubsection{Well-formedness}
Check whether a type, term or sequent is well-formed within the current scope.
The use of $type\_match$ in $auxcon$ is a bit clumsy,
and a $is\_type\_instance$, if provided, would be better.

We choose to make a set of all types and constants to be checked,
and then check each set member, rather than check all generated
items, as this is judged superior in speed.
=SML
local
	fun auxty [] = true
	| auxty ((tnm,arit) :: x) = (
		let val res = get_ty_env tnm
		in
		case res of
		Value{arity=arity,...} => (arit=arity)
			andalso auxty x
		| Nil => false
		end);

	fun auxcon [] = true
	| auxcon ((cnm,typ) :: x) = (
		let val res = get_con_env cnm
		in
		case res of
		Value{ty=ty1,...} => (
			(((type_match typ ty1);true)
			handle complaint => false)
			andalso auxcon x)
		| Nil => false
		end);
in
	fun ‚wf_type· (ty : TYPE) : bool =
	let val tyv = type_tycons ty;

	in
		auxty tyv
	end;

	fun ‚wf_term· (tm : TERM) : bool =
	let val tyv = term_type_constructors tm;
		val con = term_constants tm;

	in
		auxty tyv andalso auxcon con
	end;

	fun ‚wf_seq· ((tml , tm) : SEQ) : bool =
	let val tyv = list_cup (term_type_constructors tm ::
			map term_type_constructors tml);
		val con = list_cup (term_constants tm ::
			map term_constants tml);
	in
		auxty tyv andalso auxcon con
	end;
end (* end local *);
=TEX
Check that a theorem is valid, fail if not.
Note that we do not check the well-formedness of the sequent,
as this is not required by the specification.
=SML
fun ‚check_thm· (caller: string)
	(thm {level = level, theory=theory, ...} : THM) : unit = (
let val {hierarchy = hier{lookup=lookup, top_theory=top_theory},
		inconsistent=inconsistent,...} = !current;

	val thy {name = iname, del_levels = del_levels, ...} = !theory;
	
	val dummy = if inconsistent
		then error caller 6083 []
		else if (0 <= iname) andalso (iname <= top_theory)
		then ()
		else error caller 6072 [fn x => "Internal "^string_of_int iname];

	val ti{status = status,
		inscope = inscope,
		contents = contents,
		children = children,
		name = ename}
		= sub_ia(lookup,iname);
in
	if status = TSDeleted
	then fail caller 6036 [fn x => ename]
	else if theory <> contents
	then error caller 6072 [fn x => "Internal "^string_of_int iname]
	else if not inscope
	then fail caller 6066 [fn x => ename]
	else if range_mem(level, del_levels)
	then fail caller 6065 []
	else ()
end);
=TEX

\subsubsection{Theory Names}
$icl'get\_current\_theory\_name$ is part of the ADT interface,
but it is useful in defining utilities.

Get the current theories name as an integer:
=SML
fun ‚icl'get_current_theory_name· (():unit) : int = (
let val thy{name = name,...} = current_theory();
in
	name
end);
=TEX
Check that an internal name falls within the range 0 to $top\_theory$, failing if not, with area being the $caller$ parameter.
=SML
fun ‚check_internal_theory_name· (nm : int) (caller : string) : unit = (
let val hier{top_theory=top_theory,...} = current_hierarchy();
in
	if (0 <= nm) andalso (nm <= top_theory)
	then ()
	else fail caller 6043 [fn x => string_of_int nm]
end);
=TEX
Given a theory name as an string, return its internal name as an integer.
The error raised is stated to be from the calling function, denoted by $caller$.
A deleted theories name cannot be found by these means.
=SML
fun ‚internal_theory_name· (nm : string) (caller : string): int = (
let val hier{lookup=lookup, top_theory=top_theory} = 
		current_hierarchy();
	fun aux ~1 = fail caller 6035 [fn x => nm]
	| aux n = (let val (ti {name=sname,contents=contents,status=status,...}) = sub_ia(lookup, n);
		in
			if ((sname = nm) andalso (status <> TSDeleted))
			then (let val(thy{name=iname,...}) = !contents
				in
					iname
				end)
			else aux (n-1)
		end)
in
	if nm = "-"
	then icl'get_current_theory_name ()
	else aux top_theory
end);
=TEX
Is the given theory name present at all?
A deleted theory will not be noted by this function.
There is always a current theory, ``-''.
=SML
fun ‚is_theory_name· (nm : string) : bool = (
let val hier{lookup=lookup, top_theory=top_theory} = 
		current_hierarchy();
	fun aux ~1 = false
	| aux n = (let val (ti {name=sname,status=status,...}) = sub_ia(lookup, n);
		in
			((sname = nm) andalso (status <> TSDeleted))
			orelse aux (n-1)
		end)
in
	(nm = "-")
	orelse aux top_theory
end);
=TEX
Return the current theory name as a string:
=SML
fun ‚get_current_theory_name· (():unit):string = (
let val hier{lookup=lookup, top_theory=top_theory} = 
		current_hierarchy();
	val thy{name = iname,...} = current_theory();
	val (ti {name=ename,...}) = sub_ia(lookup, iname);
in
	ename
end);
=TEX
\subsubsection{Checking Writeability}
Check that the current theory status allows writing, with various fail messages if not.
Note that the current theory should never have status $TSDeleted$.
=SML
fun ‚check_c_writable· (caller : string) : unit = (
let val {hierarchy = hier{lookup=lookup, ...},
		theory = theory, inconsistent=inconsistent,...} = !current;

	val thy{name = iname,...} = !theory;

	val ti{status = status, name = ename,...}  = sub_ia(lookup,iname);

in
	if inconsistent
	then error caller 6083 []
	else case status of
	TSDeleted => error caller 6008 [fn x=>ename]
	| TSAncestor => fail caller 6071 [fn x=>ename]
	| TSLocked => fail caller 6037 [fn x=>ename]
	| TSNormal => ()
end);
=TEX
\subsubsection{Ancestors and Descendants}
A function to return all of a theories ancestors
(including itself):
=SML
fun ‚theory_ancestors· (nm : int) : int list = (
let val hier{lookup=lookup, ...} = current_hierarchy();

	fun lparents (n : int) = (
		let val ti {contents=contents,...} = sub_ia(lookup,n);
			val thy{parents=parents,...} = !contents
		in
			parents
		end);

	fun allparents ([]:int list) (acc:int list) = acc
	| allparents (a :: x) acc = (
		if a mem acc
		then allparents x acc
		else allparents ((lparents a) cup x) (a :: acc));
in
	check_internal_theory_name nm "theory_ancestors";
	allparents [nm] []
end);
=TEX
A function to return all of a theories descendants
(but not including itself):
=SML
fun ‚theory_descendants· (nm : int) : int list = (
let val hier{lookup=lookup, ...} = current_hierarchy();

	fun lchildren (n : int) = (
		let val ti {children=children,...} = sub_ia(lookup,n);
		in
			children
		end);

	fun allchildren ([]:int list) (acc:int list) = acc
	| allchildren (a :: x) acc = (
		if a mem acc
		then allchildren x acc
		else allchildren ((lchildren a) cup x) (a :: acc));
in
	check_internal_theory_name nm "theory_descendants";
	allchildren (lchildren nm) []
end);
=TEX
Is a given constant name used in any ancestor or descendant of the
current theory?
=SML
datatype ‚THEORY_SCOPE· = ‚NotPresent· |  ‚InScope· | ‚InDescendant·
=TEX
=SML
fun ‚const_in_anc_or_des· (nm : string) : THEORY_SCOPE = (
let val iname =icl'get_current_theory_name();
	
	val hier{lookup=lookup, ...} = current_hierarchy();

	fun const_in_thy (nm : string) (thry : int) : bool = (
	let val ti {contents = contents,...} = sub_ia(lookup, thry);
		val thy {con_env=con_env,...} = !contents;
	in
		not(is_Nil(s_lookup nm con_env))
	end);
in	
	if is_Nil(get_con_env nm)
	then (if (any (theory_descendants iname) 
		(fn thry => const_in_thy nm thry))
		then InDescendant
		else NotPresent)
	else InScope
end);
=TEX
Is a given type constructor name used in any ancestor or descendant of the
current theory?
=SML
fun ‚type_in_anc_or_des· (nm : string) : THEORY_SCOPE = (
let val iname = icl'get_current_theory_name();
	
	val hier{lookup=lookup, ...} = current_hierarchy();

	fun type_in_thy (nm : string) (thry : int) : bool = (
	let val ti {contents = contents,...} = sub_ia(lookup, thry);
		val thy {ty_env=ty_env,...} = !contents;
	in
		not(is_Nil(s_lookup nm ty_env))
	end);
in	
	if is_Nil(get_ty_env nm)
	then (if (any (theory_descendants iname) 
		(fn thry => type_in_thy nm thry))
		then InDescendant
		else NotPresent)
	else InScope
end);
=TEX
The following function removes theory $child$ from the children field 
of each of its $parents$.
This will be used in $icl'delete\_theory$.
=SML
fun ‚remove_child· (child : int) (parents: int list) : unit = (
let val hier{lookup=lookup, ...} = current_hierarchy();
	fun aux (a :: x) = (
	let val ti {status = status,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name} = sub_ia(lookup,a)
	in
		update_ia(lookup,a,
			ti {status = status,
			inscope = inscope,
			contents = contents,
			children = children less child,
			name = name});
		aux x
	end)
	| aux [] = ();
in
	aux parents
end);
=TEX
The following function adds theory $child$ to the children field 
of each of its $parents$.
This will be used in $icl'new\_theory$ and
$icl'duplicate\_theory$.
=SML
fun ‚add_child· (child : int) (parents : int list) : unit = (
let val hier{lookup=lookup, ...} = current_hierarchy();

	fun aux (a :: x) = (
	let val ti {status = status2,
		inscope = inscope2,
		contents = contents2,
		children = children2,
		name = name2} = sub_ia(lookup,a)
	in
		update_ia(lookup,a,
			ti {status = status2,
			inscope = inscope2,
			contents = contents2,
			children = (child :: children2),
			name = name2});
		aux x
	end)
	| aux [] = ();
in
	aux parents
end);
=TEX
\subsubsection{Hierarchies}
The following function maps $f$ over each of the theory information cells in the hierarchy.
As it is working through references it is misleading to
return any value.
=SML
fun ‚map_hierarchy· (f: icl'THEORY_INFO -> icl'THEORY_INFO) 
	(hir : icl'HIERARCHY) : unit = (
let val hier{lookup=lookup, top_theory=top_theory} = 
		hir;
	fun aux	n = (if n <= top_theory
		then (
		let val old_ti = sub_ia(lookup, n)
		in
			update_ia(lookup,n,f old_ti);
			aux (n+1)
		end) else ());
in
	aux 0
end);
=TEX
Now a function to copy a hierarchy into a new one.
Note that when creating new hierarchies we must move from 0 to number of hierarchies.
=SML
fun ‚copy_hierarchy· (old : icl'HIERARCHY) : icl'HIERARCHY = (
let val hier{lookup=old_lookup, top_theory=top_theory} = 
		old;
	val new_lookup = create_ia (); 
	fun aux	n = (if n <= top_theory
		then (
		let val old_ti = sub_ia(old_lookup, n);
		in
			update_ia(new_lookup,n,old_ti);
			aux (n+1)
		end) else ());
in
	(aux 0;
	hier{lookup=new_lookup, top_theory=top_theory})
end);
=TEX
We need a test to see if $hir1$ hierarchy is an ``ancestor'' of $hir2$.
According to the specification, this is so if the child possesses all the ancestors theories (by address comparison),
with the same theory information for each,
except that the children theories field may be different.
As new theories are always added to the ``tail'' of the theory hierarchy array we need only test up to the top theory of the ``ancestor''
hierarchy.
=SML
fun ‚is_hierarchy_ancestor· (hir1 : icl'HIERARCHY)
	(hir2 : icl'HIERARCHY) : bool = (
let val hier{lookup=lookup1, top_theory=top_theory1} = 
		hir1;

	val hier{lookup=lookup2, top_theory=top_theory2} = 
		hir2;

	fun aux ~1 = true
	| aux n = (
	let val (ti {status = status1,
			inscope = inscope1,
			contents = contents1,
			children = children1,
			name = name1})
		= sub_ia(lookup1,n);

		val (ti {status = status2,
			inscope = inscope2,
			contents = contents2,
			children = children2,
			name = name2})
		= sub_ia(lookup2,n) 
	in
		(status1 = status2) andalso
		(inscope1 = inscope2) andalso
		(contents1 = contents2) andalso
		(name1 = name2) andalso
		aux (n-1)
	end)
in
	(top_theory1 <= top_theory2) andalso
	aux top_theory1
end);
=TEX
\section{INTERFACE FUNCTIONS OF ADT THM}
\subsection{Operations on Hierarchies}
The process of creating a new hierarchy from the current one.
We first take a copy, we then modify its contents by reference,
we then make the current state have this new hierarchy as its current
one.
=SML
fun ‚icl'new_hierarchy· (x: unit) : icl'HIERARCHY = (
let val {hierarchy=hierarchy, theory=theory, ty_env=ty_env, 
		con_env=con_env, inconsistent=inconsistent} = !current;

	fun make_anc (ti {status = status,
				inscope = inscope,
				contents = contents,
				children = children,
				name = name})
		=
		( ti {status = (if status = TSDeleted
					then TSDeleted
					else TSAncestor),
				inscope = inscope,
				contents = contents,
				children = children,
				name = name});

	val hcopy = copy_hierarchy hierarchy;

	val dummy = map_hierarchy make_anc hcopy;

in
	current := {hierarchy = hcopy, theory=theory, ty_env=ty_env, 
		con_env=con_env, inconsistent=inconsistent};
	hcopy
end);
=TEX
Now we can give a ``load hierarchy'' function, as demanded by the specification.
As the current theory address doesn't change, and its contents and its ancestors are
equal, $ty\_env$ and $con\_env$ do not change.
=SML
fun ‚icl'load_hierarchy· (hir : icl'HIERARCHY) : unit = (
let val {hierarchy=hierarchy, theory=theory, ty_env=ty_env, 
		con_env=con_env, inconsistent=inconsistent} = !current;
in
	if is_hierarchy_ancestor hierarchy hir
	then current := {hierarchy = hir, theory=theory, ty_env=ty_env, 
		con_env=con_env, inconsistent=inconsistent}
	else fail "icl'load_hierarchy" 6033 []
end
);
=TEX
Give an interface presentation of the current hierarchy:
=SML
fun ‚icl'get_hierarchy· (():unit) : HIERARCHY = (
let val hier{lookup=lookup, top_theory=top_theory} = 
		current_hierarchy();
	fun aux ~1 = [] 
	| aux n = (let val (ti {status = status,
			inscope = inscope,
			contents = contents,
			children = children,
			name = name}) = sub_ia(lookup,n)
		in
			(name, {status = status,
				inscope = inscope,
				contents = !contents,
				children = children,
				name = name}) 
			:: aux (n-1)
		end)
in
	aux top_theory
end);
=TEX
In the sequence suggested by \cite{DS/FMU/IED/DTD006}
we would only now give $icl'get\_current\_theory\_name$,
but it is useful in defining utilities.

Return an interface presentation of a theory, based on a string.
=SML
fun ‚icl'get_theory_info· (nm : string) : THEORY_INFO = (
let val hier{lookup=lookup, ...} = 
		current_hierarchy();

	val iname = internal_theory_name nm "icl'get_theory_info";

	val (ti {status = status,
			inscope = inscope,
			contents = contents,
			children = children,
			name = name}) = sub_ia(lookup,iname);
in
	{status = status,
	inscope = inscope,
	contents = !contents,
	children = children,
	name = name}
end);
=TEX
Given a theory name as an integer, return it as a string.
=SML
fun icl'get_theory_name (nm : int) : string = (
let val hier{lookup=lookup, ...} = current_hierarchy();
in
	check_internal_theory_name nm "icl'get_theory_name";
	(let val (ti {name=name,...}) = sub_ia(lookup, nm)
		in
			name
		end)
end);
=TEX
\subsection{Operations of Theory Attributes}
Make some theory the current theory.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun ‚icl'open_theory· (nm : string) : (int list * int list) = (
let val {hierarchy = hierarchy as hier{lookup=lookup, top_theory=top_theory},
		theory=theory, ty_env=ty_env, con_env=con_env, 
		inconsistent=inconsistent} = !current;

	val thyn = internal_theory_name nm "icl'open_theory";

	val allp = theory_ancestors thyn;

	val ti {status = status,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name} = sub_ia(lookup,thyn);

	val dummy = if status = TSDeleted
		then fail "icl'open_theory" 6036 [fn x => nm]
		else ();
=TEX
We take a copy of the current hierarchy to modify, and this will
be put back in place.
This may create more garbage than modifiing the current hierarchy in place,
but does ensure consistency by using a single assignment.
=SML
	val chierarchy as hier{lookup=clookup, ...} = copy_hierarchy hierarchy;
=TEX
The following auxiliary function sets all the inscope fields to
their correct value,
and gets the new values for the current $ty\_env$ and $con\_env$.
=SML
	fun aux ~1 into_scope out_of_scope tece = (into_scope, out_of_scope, tece)
	| aux n into_scope out_of_scope tece = (
		let val ti {status = status1,
			inscope = inscope1,
			contents = contents1,
			children = children1,
			name = name1} = sub_ia(clookup,n)
		in
		if n mem allp
		then (if inscope1
			then aux (n - 1) into_scope out_of_scope tece
			else (update_ia(clookup,n,
				ti {status = status1,
				inscope = true,
				contents = contents1,
				children = children1,
				name = name1});
				aux (n-1) (n :: into_scope) out_of_scope 
					(add_thy_env (!contents1) tece)))
		else (if not inscope1
			then aux (n - 1) into_scope out_of_scope tece
			else (update_ia(clookup,n,
				ti {status = status1,
				inscope = false,
				contents = contents1,
				children = children1,
				name = name1});
				aux (n-1) into_scope (n :: out_of_scope)
					(del_thy_env (!contents1) tece)))
		end);
=TEX
Now use this auxiliary function to gain the theores moved in and out of scope and the
new type and constructor environments, after the opening.
=SML
	val (ins, outs, (te,ce)) = aux top_theory [] [] (ty_env, con_env);
=TEX
Then we can do a single assignment modification of the state:
=SML
in	
	current := {hierarchy=chierarchy, theory=contents, ty_env=te, 
		con_env=ce, inconsistent=inconsistent};
	(ins, outs)
end);
=TEX
A function to delete theories.
If it is interrupted then the user may be left with the $inconsistent$ flag set.
=SML
fun ‚icl'delete_theory· (nm : string) : unit = (
let val {hierarchy = hierarchy as hier{lookup=lookup, ...},
		theory=theory, ty_env=ty_env, con_env=con_env, 
		inconsistent=inconsistent} = !current;

	val thyn = internal_theory_name nm "icl'delete_theory";
	
	val ti {status = status,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name} = sub_ia(lookup,thyn);

	val dummy = case status of
		TSDeleted => fail "icl'delete_theory" 6036 [fn x => nm]
		| TSAncestor => fail "icl'delete_theory" 6071 [fn x => nm]
		| TSLocked => fail "icl'delete_theory" 6037 [fn x => nm]
		| TSNormal => 
		if inconsistent
		then error "icl'delete_theory" 6083 []
		else if not(is_nil children)
		then fail "icl'delete_theory" 6076 [fn x => nm]
		else if inscope
		then fail "icl'delete_theory" 6069 [fn x => nm]
		else ();

	val thy {parents = parents,...} = !contents;

	val ethy = empty_theory thyn [];
in
	current := {hierarchy=hierarchy, theory=theory, ty_env=ty_env,
		con_env=con_env, inconsistent=true};
	remove_child thyn parents;
	update_ia(lookup,thyn,ti {status = TSDeleted,
		inscope = false,
		contents = ref ethy,
		children = [],
		name = name});
	contents := ethy;
	current := {hierarchy=hierarchy, theory=theory, ty_env=ty_env,
		con_env=con_env, inconsistent=false}
end);
=TEX
Create a new theory, though not make it current.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun ‚icl'new_theory· (nm : string) :  int = (
	if (is_theory_name nm)	(* spec. step 1 *)
	then fail "icl'new_theory" 6040 [fn x => nm]
	else let val {hierarchy = hierarchy as hier{lookup=lookup, top_theory=top_theory}, 
		theory=theory, ty_env=ty_env, con_env=con_env, 
		inconsistent=inconsistent} = !current;

	val dummy = if inconsistent
		then error "icl'delete_theory" 6083 []
		else ();

	val cthy = icl'get_current_theory_name();

	val ntop_theory = top_theory+1;

	val nthy = ref (empty_theory ntop_theory [cthy]); (* spec. step 2 *)

	val nti = (ti {status = TSNormal, 
		inscope = false,
		contents = nthy,
		children = [],
		name = nm});

in
	current := {hierarchy=hierarchy, theory=theory, ty_env=ty_env,
		con_env=con_env, inconsistent=true};
	update_ia(lookup,ntop_theory,nti); (* spec step 3 *)
	add_child ntop_theory [cthy];
	current := {hierarchy = hier{lookup=lookup, top_theory=ntop_theory},
		theory=theory, ty_env=ty_env, con_env=con_env, 
		inconsistent=inconsistent}; (* spec. step 4 *)
	ntop_theory
end
);
=TEX
Lock a theory, to make it read-only.
=SML
fun ‚icl'lock_theory· (nm : string): unit = (
let val thyn = internal_theory_name nm "icl'lock_theory";

	val hier{lookup=lookup, ...} = current_hierarchy();
	
	val ti {status = status,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name} = sub_ia(lookup,thyn);

	val dummy = case status of
		TSDeleted => fail "icl'lock_theory" 6036 [fn x => nm]
		| TSAncestor => fail "icl'lock_theory" 6071 [fn x => nm]
		| TSLocked => fail "icl'lock_theory" 6037 [fn x => nm]
		| TSNormal => ();
in
	update_ia(lookup,thyn,ti {status = TSLocked,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name})
end);
=TEX
Unlock a locked theory, allowing to to be written to once more.
=SML
fun ‚icl'unlock_theory· (nm : string): unit = (
let val thyn = internal_theory_name nm "icl'unlock_theory";

	val hier{lookup=lookup, ...} = current_hierarchy();
	
	val ti {status = status,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name} = sub_ia(lookup,thyn);

	val dummy = case status of
		TSDeleted => fail "icl'unlock_theory" 6036 [fn x => nm]
		| TSAncestor => fail "icl'unlock_theory" 6068 [fn x => nm]
		| TSNormal => fail "icl'unlock_theory" 6068 [fn x => nm]
		| TSLocked => ();
in
	update_ia(lookup,thyn,ti {status = TSNormal,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name})
end);
=TEX
Create a duplicate theory, except it has no children.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun ‚icl'duplicate_theory· (fromnm : string) (tonm : string) :  int = (
let val {hierarchy = hierarchy as hier{lookup=lookup, top_theory=top_theory},
		theory=theory, ty_env=cty_env, con_env=ccon_env, 
		inconsistent=inconsistent} = !current;

	val dummy = if inconsistent
		then error "icl'duplicate_theory" 6083 []
		else if (is_theory_name tonm)
		then fail "icl'duplicate_theory" 6040 [fn x => tonm]
		else ();

	val fromn = internal_theory_name fromnm "icl'lock_theory";

	val ntop_theory = top_theory+1;

	val ti {status = status1,
		inscope = inscope1,
		contents = contents1,
		children = children1,
		name = name1}
		= sub_ia(lookup,fromn);

	val dummy = case status1 of
		TSDeleted => fail "icl'duplicate_theory" 6036 [fn x => fromnm]
		| _ => ();

	val thy {name = frname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level,
		user_data = user_data} = !contents1;

	val dummy = if frname <> fromn
		then error "icl'duplicate_theory" 6041 []
		else ();

	val tothy = ref (thy{name = ntop_theory,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level,
		user_data = ref(!user_data)});

	val toti = (ti {status = TSNormal, 
		inscope = false,
		contents = tothy,
		children = [],
		name = tonm});
in
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=true};
	update_ia(lookup,ntop_theory,toti);
	add_child ntop_theory parents;
	current := {hierarchy = hier{lookup=lookup, top_theory=ntop_theory},
		theory=theory, ty_env=cty_env, con_env=ccon_env, inconsistent=inconsistent};
	ntop_theory
end);
=TEX	
\subsection{Operations on Theory Contents}
Give the sequent of a theorem:
=SML
fun ‚dest_thm· (thm{sequent=sequent,...} : THM) : SEQ = sequent;
=TEX
Give a user presentation of a theorem:
=SML
fun ‚icl'dest_thm· (thm{level = level, theory=theory, sequent = sequent}) :
	{level : int, theory : THEORY, sequent : SEQ} = (
	{level=level, theory = !theory, sequent = sequent}
);
=TEX

Save a theorem under a list of keys:
=SML
fun ‚icl'list_save_thm· (keys : string list, 
	theorem : THM as thm {level = level, theory=theory, sequent = sequent}) : THM = (
let val dummy = (check_thm "icl'list_save_thm" theorem;
		if keys = []
		then fail "icl'list_save_thm" 6031 []
		else check_c_writable "icl'list_save_thm");

	val {theory = ctheory,...} = !current;

	val thy {name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level,
		user_data = user_data} = !ctheory;

	val new_theorem = thm{level = if (theory = ctheory)
			then current_level
			else 0,
		theory = ctheory,
		sequent = sequent};

	val new_theorem_dict = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			s_extend key new_theorem dct
			handle complaint =>
			divert complaint "s_extend" "icl'list_save_thm" 6039 [fn x=> key])
		keys)
		theorem_dict);

	val new_thy = thy {name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = new_theorem_dict,
		current_level = current_level,
		user_data = user_data}
in
	ctheory := new_thy;
	new_theorem
end);
=TEX
Delete the last extension to the current theory.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun ‚icl'delete_extension· (():unit) : int = (
let val {hierarchy = hierarchy as hier{lookup=lookup, ...}, 
		theory=theory, ty_env=cty_env, con_env=ccon_env, 
		inconsistent=inconsistent} = !current;

	val thy {name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level,
		user_data = user_data} = !theory;

	val ti{children = children, name = ename,...} = sub_ia(lookup,iname);

	val dummy = (check_c_writable "icl'delete_extension"; 
		if children <> []
		then fail "icl'delete_extension" 6076 [fn x=>ename]
		else ());
=TEX
We want the last level at which something was defined.
All the following lists are always manipulated such that their head
will be the last declaration of their kind.
N.B. this does not hold true of $theorem\_dict$,
as it may save theorems from other theories at level 0.
=SML
	val ll_type = case ty_env of
		[] => 0
		| ((_,{level=llt,...})::_) => llt;
	val ll_con = case con_env of
		[] => 0
		| ((_,{level=llc,...})::_) => llc;
	val ll_def = case definition_dict of
		[] => 0
		| ((_,thm {level=lld,...})::_) => lld;
	val ll_axiom = case axiom_dict of
		[] => 0
		| ((_,thm {level=lla,...})::_) => lla;

	val last_level = list_max[ll_type, ll_con, ll_def, ll_axiom];

	val dummy = (
		if last_level = 0
		then fail "icl'delete_extension" 6050 [fn x => ename]
		else if (any theorem_dict (fn (_,thm{level=ll,...}) => 
			ll >= last_level))
		then fail "icl'delete_extension" 6077 
			[(fn x => ename),
			(fn x => let val (key,_) = (find theorem_dict 
				(fn (_,thm{level=ll,...}) =>
				 ll >= last_level))
				in key end)]
		else ());

	val new_del_levels = extend_range (last_level, current_level) del_levels;
=TEX
The following deletion depends upon the implementation of simple
dictionaries.
We delete anything made between $last\_level$ and $current\_level$.
=SML
	val new_ty_env=ty_env drop (fn (_,{level=ll,...}) => ll >= last_level);

	val new_cty_env = del_ty_env (ty_env drop (fn (_,{level=ll,...}) => ll < last_level))
		cty_env;

	val new_con_env=con_env drop (fn (_,{level=ll,...}) => ll >= last_level);

	val new_ccon_env = del_con_env(con_env drop (fn (_,{level=ll,...}) => ll < last_level))
		ccon_env;

	val new_axiom_dict = axiom_dict drop 
		(fn (_,thm{level=ll,...}) => ll >= last_level);

	val new_definition_dict = definition_dict drop 
		(fn (_,thm{level=ll,...}) => ll >= last_level);

	val new_thy = thy {name = iname,
		ty_env = new_ty_env,
		con_env = new_con_env,
		parents = parents,
		del_levels = new_del_levels,
		axiom_dict = new_axiom_dict,
		definition_dict = new_definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level+1,
		user_data = user_data};
in
=TEX
Note that the current theory address doesn't change, only the contents of the location pointed to.
=SML
	current := {hierarchy=hierarchy, theory=theory,
		ty_env=cty_env, con_env=ccon_env,
		inconsistent=true};
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory,
		ty_env=new_cty_env, con_env=new_ccon_env,
		inconsistent=inconsistent};
	last_level
end);
=TEX
Delete a named theorem from the current theory.
=SML
fun ‚icl'delete_thm· (key : string) : THM = (
let val {theory=theory, inconsistent=inconsistent,...} = !current;

	val thy {name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level,
		user_data = user_data} = !theory;

	val dummy = check_c_writable "icl'delete_thm";

	val dthm = (force_value(s_lookup key theorem_dict)
		handle complaint =>
		divert complaint "force_value" "icl'delete_thm" 6046 [
				fn x => key,
				fn x => get_current_theory_name()]);

	val new_theorem_dict = s_delete key theorem_dict;

	val new_thy = thy {name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = new_theorem_dict,
		current_level = current_level,
		user_data = user_data}
in
	theory := new_thy;
	dthm
end);
=TEX 
Add an axiom to the current theorem:
=SML
fun ‚icl'new_axiom· (keys : string list, tm : TERM) : THM = (
let val {theory=theory,...} = !current;

	val thy {name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level,
		user_data = user_data} = !theory;
	
	val dummy = (check_c_writable "icl'new_axiom" ;
		if wf_term tm
		then ()
		else fail "icl'new_axiom" 6048 [fn x => get_current_theory_name ()]);

	val new_axiom = thm{level = current_level+1, 
		theory=theory, 
		sequent = ([], tm)};

	val new_axiom_dict = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			s_extend key new_axiom dct
			handle complaint =>
			divert complaint "s_extend" "icl'new_axiom" 6047 [fn x=> key])
		keys)
		axiom_dict);

	val new_thy = thy {name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = new_axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level+1,
		user_data = user_data}
in
	theory := new_thy;
	new_axiom
end);
=TEX
Add a new constant to the theory.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun ‚icl'new_const· (nm : string, ty : TYPE) : TERM = (
let val {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=inconsistent} = !current;

	val thy {name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level,
		user_data = user_data} = !theory;
	
	val dummy = (check_c_writable "icl'new_const";
		if not(wf_type ty)
		then fail "icl'new_const" 6048 [fn x => get_current_theory_name ()]
		else (case const_in_anc_or_des nm of
		InScope => fail "icl'new_const" 6049 [fn x => nm]
		| InDescendant => fail "icl'new_const" 6063 [fn x => nm]
		| NotPresent => ()));
		
	val new_const = mk_const(nm,ty);

	val con_decl = {ty=ty,level=current_level+1};

	val new_con_env = s_extend nm con_decl con_env;

	val new_thy = thy {name = iname,
		ty_env = ty_env,
		con_env = new_con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level+1,
		user_data = user_data};

	val new_ccon_env = add_con_env [ (nm,con_decl)] ccon_env;
in
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=true};
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=new_ccon_env, inconsistent=inconsistent};
	new_const
end);
=TEX
Add a new type to the theory.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun ‚icl'new_type· (nm : string, arity : int) : TYPE = (
let val {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=inconsistent} = !current;

	val thy {name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level,
		user_data = user_data} = !theory;
	
	val dummy = (check_c_writable "icl'new_type";
		(case type_in_anc_or_des nm of
		InScope => fail "icl'new_type" 6045 [fn x => nm]
		| InDescendant => fail "icl'new_type" 6034 [fn x => nm]
		| NotPresent => ()));
		
	val new_type = mk_type(nm,ntyvars arity);

	val type_decl = {arity=arity,level=current_level+1};

	val new_ty_env = s_extend nm type_decl ty_env;

	val new_thy = thy {name = iname,
		ty_env = new_ty_env,
		con_env=con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level+1,
		user_data = user_data};

	val new_cty_env = add_ty_env [(nm,type_decl)] cty_env; 
in
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=true};
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory, ty_env = new_cty_env, 
		con_env=ccon_env, inconsistent=inconsistent};
	new_type
end);
=TEX
Declare a new, named, constant to be equal to some term.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
Note that the function assumes the presence of $=$ as a valid constant.
=SML
fun ‚icl'new_definition· (keys : string list, cnm : string, vl : TERM) : THM = (
let val {hierarchy=hierarchy, theory=theory, ty_env=cty_env,
		 con_env=ccon_env, inconsistent=inconsistent} = !current;

	val thy {name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level,
		user_data = user_data} = !theory;

	val ctype = type_of vl;
=TEX
Do the checks required (other than on keys)
=SML
	val dummy = (check_c_writable "icl'new_definition";
		(case const_in_anc_or_des cnm of
		InScope => fail "icl'new_definition" 6049 [fn x => cnm]
		| InDescendant => fail "icl'new_definition" 6063 [fn x => cnm]
		| NotPresent => ());
		if keys = []
		then fail "icl'new_definition" 6031 []
		else if not (wf_term vl)
		then fail "icl'new_definition" 6048 [fn x => get_current_theory_name()]
		else if not(is_nil (frees vl))
		then fail "icl'new_definition" 6059 []
		else if not(is_nil((term_tyvars vl) diff (type_tyvars ctype)))
		then fail "icl'new_definition" 6058 []
		else ()
		);
=TEX
Now build up the new material
=SML
	val new_const = mk_const(cnm,ctype);

	val con_decl = {ty=ctype,level=current_level+1};

	val new_con_env = s_extend cnm con_decl con_env;

	val new_ccon_env = add_con_env [ (cnm,con_decl)] ccon_env;

	val new_defn = thm{level = current_level+1, 
		theory=theory, 
		sequent = ([], mk_eq(new_const, vl))};

	val new_definition_dict = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			s_extend key new_defn dct
			handle complaint =>
			divert complaint "s_extend" "icl'new_definition" 6051 [fn x=> key])
		keys)
		definition_dict);

	val new_thy = thy {name = iname,
		ty_env = ty_env,
		con_env = new_con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = new_definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level+1,
		user_data = user_data};
in
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=true};
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=new_ccon_env, inconsistent=inconsistent};
	new_defn
end);
=TEX
Introduce a new type definition.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
Note that the function assumes the presence of $TypeDefinition$ and $Ñ$ as valid constants.
=SML
fun ‚icl'new_type_definition· (keys : string list, tnm : string, 
		typars : string list,
		defthm : THM as thm{sequent = (hyps, concl),...}) : THM = (
let val {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=inconsistent} = !current;

	val thy {name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level,
		user_data = user_data} = !theory;
=TEX
Do the checks required (other than on keys)
=SML
	val dummy = (check_c_writable "icl'new_type_definition";
		(case type_in_anc_or_des tnm of
		InScope => fail "icl'new_type_definition" 6045 [fn x => tnm]
		| InDescendant => fail "icl'new_type_definition" 6034 [fn x => tnm]
		| NotPresent => ());
		check_thm "icl'new_type_definition" defthm;
		if keys = []
		then fail "icl'new_type_definition" 6031 []
		else if hyps <> []
		then fail "icl'new_type_definition" 6053 []
		else if not(is_nil (frees concl))
		then fail "icl'new_type_definition" 6056 []
		else if not(is_nil((term_tyvars concl) diff typars))
		then fail "icl'new_type_definition" 6057 []
		else if not(all_different typars)
		then fail "icl'new_type_definition" 6079 []
		else ());
=TEX
Now build up the new material
=SML
	val (x,(p, x1)) = (Combinators.I ** dest_comb)(simple_dest_Ñ concl)
		handle complaint =>
		list_divert complaint "icl'new_type_definition"
			[("dest_comb", 6055,[]),
			 ("simple_dest_Ñ", 6054, [])];

	val dummy = if not(x=x1)
		then fail "icl'new_type_definition" 6080 []
		else ();

	val arity = length typars;

	val new_type = mk_type(tnm, map mk_vartype typars);

	val ftype = mk_fun(new_type, type_of x);

	val f = mk_var("f",ftype); (* cannot be present in p, from frees test *)

	val td = mk_const("TypeDefinition",mk_fun(type_of p,
		mk_fun(ftype, BOOL)));

	val seq_concl = simple_mk_Ñ(f, list_mk_comb (td, [p, f]));

	val new_type_defn = thm{level = current_level+1, 
		theory=theory, 
		sequent = ([], seq_concl)};

	val ty_decl = {arity = arity,level=current_level+1};

	val new_ty_env = s_extend tnm ty_decl ty_env;

	val new_cty_env = add_ty_env [ (tnm,ty_decl)] cty_env;

	val new_definition_dict = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			s_extend key new_type_defn dct
			handle complaint =>
			divert complaint "s_extend" 
				"icl'new_type_definition" 6051 [fn x=> key])
		keys)
		definition_dict);

	val new_thy = thy {name = iname,
		ty_env = new_ty_env,
		con_env=con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = new_definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level+1,
		user_data = user_data};
in
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=true};
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory, ty_env=new_cty_env, 
		con_env=ccon_env, inconsistent=inconsistent};
	new_type_defn
end);
=TEX
Introduce a new specification.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
Note that this function examines theorems using $Ñ$,
for which there is no guarentee of it being present yet.
=SML
fun ‚icl'new_specification· (keys : string list, ndef : int, 
	defthm : THM as thm{sequent = (hyps, concl),...}) : THM = (
let val {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=inconsistent} = !current;

	val thy {name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level,
		user_data = user_data} = !theory;
=TEX
Do the checks required (other than on keys, and theorem form)
=SML
	val dummy = (check_c_writable "icl'new_specification";
		check_thm "icl'new_specification" defthm;
		if keys = []
		then fail "icl'new_specification" 6031 []
		else if not(is_nil (frees concl))
		then fail "icl'new_specification" 6056 []
		else if ndef < 1
		then fail "icl'new_specification" 6044 []
		else if hyps <> []
		then fail "icl'new_specification" 6053 []
		else ()
		);
=TEX
Now build up the new material
=SML
	fun nexists (n:int) (tm : TERM) (res : TERM list) : (TERM list * TERM) = (
		if n = 0 
		then (res, tm)
		else if simple_is_Ñ tm
		then (let val (x,bdy) = simple_dest_Ñ tm
			in
			nexists (n-1) bdy (res @ [x])
			end)
		else fail "icl'new_specification" 6060 [fn () => string_of_int ndef]
	);

	val (xlist, bdt) = nexists ndef concl [];

	val xtyvars = term_tyvars(hd xlist);
=TEX
Check the results of picking apart the theorem
=SML
	val dummy = (if ((term_tyvars concl) diff xtyvars) <> []
		then fail "icl'new_specification" 6058 []
		else if any (tl xlist) (fn x => not(set_equal (term_tyvars x) xtyvars)) 
		then fail "icl'new_specification" 6081 []
		else if not(all_different xlist)
		then fail "icl'new_specification" 6016 []
		else ();
		map (fn x =>
			let val (cnm,ty) = dest_var x
			in
			(case const_in_anc_or_des cnm of
			InScope => fail "icl'new_definition" 6049 [fn x => cnm]
			| InDescendant => fail "icl'new_definition" 6063 [fn x => cnm]
			| NotPresent => ())
			end)
		xlist;
		());

	val new_consts = map (fn x => mk_const(dest_var x)) xlist;

	val new_current_level = current_level+1;

	val con_decl = map (fn x => let val(cnm,ty) = dest_var x
			in
			(cnm,{ty=ty,level=new_current_level})
			end)
		xlist;

	val new_con_env = fold 
		(fn ((cnm,entry),edict) => s_extend cnm entry edict)
		 con_decl con_env;

	val new_ccon_env = add_con_env con_decl ccon_env;

	val new_concl = subst(combine new_consts xlist) bdt;
=TEX
Now put everything in the correct place
=SML
	val new_defn = thm{level = current_level+1, 
		theory=theory, 
		sequent = ([], new_concl)};

	val new_definition_dict = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			s_extend key new_defn dct
			handle complaint =>
			divert complaint "s_extend" "icl'new_specification" 6051 [fn x=> key])
		keys)
		definition_dict);

	val new_thy = thy {name = iname,
		ty_env = ty_env,
		con_env = new_con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = new_definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level+1,
		user_data = user_data};
in
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=true};
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=new_ccon_env, inconsistent=inconsistent};
	new_defn
end);
=TEX
Add a new parent to the current theory.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
die;
fun ‚icl'new_parent· (nm : string) : unit = (
let val dummy = (check_c_writable "icl'new_parent";
	if not(is_theory_name nm)
	then fail 6035 "icl'new_parent" [fn () => nm]
	else  ();

	val fromn = internal_theory_name fromnm "icl'lock_theory";

	val {hierarchy=hierarchy as hier{lookup=lookup, top_theory=top_theory}, 
		theory=theory, ty_env=ty_env,
		con_env=con_env, inconsistent=inconsistent}
		 = !current;

	val ti {status = fstatus, 
		inscope = finscope,
		contents = fcontents,
		children = fchildren,
		name = fname}
		= sub_ia(lookup, fromn);

	val cthy = icl'get_current_theory_name();

=TEX
The ancestors of the current and parent theories
=SML
	val fthy_anc = theory_ancestors fromn;
	val cthy_anc = theory_ancestors cthy;
=TEX
A theory is an ancestor of the current one if and only if it is in scope:
unless the scope has been corrupted.
This ``feels'' like a good place to check for that sort of corruption.
=SML
	val dummy = if fstatus = TSDeleted
		then fail "icl'new_parent" 6036 [fn () => fname]
		else if finscope
		then fail "icl'new_parent" 6082 [fn () => fname]
		else if fromn mem fthy_anc
		then error "icl'new_parent" 6041 []
		else ();

	val nfti = (ti {status = fstatus, 
		inscope = finscope,
		contents = fcontents,
		children = (cthy :: fchildren),
		name = fname});

in
	current := {hierarchy=hierarchy, theory=theory, ty_env=ty_env, 
			con_env=con_env, inconsistent=true};
	update_ia(lookup,ntop_theory,nti);
	add_child ntop_theory [cthy];
	current := {hierarchy=hierarchy, theory=theory, ty_env = new_ty_env, 
		con_env=new_con_env, inconsistent=inconsistent};
	ntop_theory
end
);
=TEX
=SML		
(* end; abstype *)
=TEX
=SML
(*  end; structure icl'Theorems *)
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN
PolyML.print_depth 10;
icl'new_theory "next";
icl'new_theory "another";
icl'open_theory "next";
icl'new_theory "yet_again";
fun naff n = ref(empty_theory n []);

fun ptr_thy (n: int) : THEORY ref = (
let val hier {lookup=lookup,...} = current_hierarchy();
	val ti{contents=contents,...} = sub_ia(lookup,n)
in
	contents
end);

fun mk_seq (c:string) : SEQ = ([mk_const("Asm"^c,BOOL)],mk_const("Conc"^c,BOOL));

fun mk_thm (c:string) (n:int) (lev: int) : THM = (
	thm{level = lev,
		sequent = mk_seq c,
		theory = ptr_thy n}
);

(* Diagnostic printing: *)

local
fun lprint_type t = (
let
	fun aux ty = (
	if is_vartype ty then 
		(" " ^ dest_vartype ty)
	else if is_funtype ty then
		(let val(t1,t2) = dest_funtype ty
		in
		( "(" ^ aux t1 ^ " ã" ^ aux t2 ^")" )
		end)
	else (let 
		fun aux1 ("â",[t1,t2]) = (
		"(" ^ aux t1 ^ " â" ^ aux t2 ^")"
		) | aux1 ((s,[])) = (
		" " ^ s
		) | aux1 ((s,tyl)) = (
		"((" ^ implode (map ((fn x => x ^", ") o aux) tyl)^ ")" ^ s ^ ")")
		in
			aux1 (dest_type ty)
		end)
	)
in
	(":" ^ aux t)
end);
in
val ‚print_type· = diag_string o lprint_type;
val ‚string_of_type· = lprint_type;

fun ‚print_term· (tm: TERM) =
let fun print_simple_dest_term (Comb(t1,t2)) = (
	"Comb (" ^ print_simple_dest_term(simple_dest_term t1) ^", " ^
		print_simple_dest_term(simple_dest_term t2) ^ ")"
) | print_simple_dest_term (Const(s,ty)) = s ^ lprint_type ty
| print_simple_dest_term (Var(s,ty)) = s ^ lprint_type ty
| print_simple_dest_term (Abs(v,b)) = (
	let val (vs,vt) = dest_var v
	in
	"ç " ^ vs ^ lprint_type vt ^ " é " ^ print_simple_dest_term (simple_dest_term b)
	end);
in
	diag_string(print_simple_dest_term (simple_dest_term tm))
end;
end;
(* 
Then a term and sequent printing function that doesn't give the type information.
*)
local fun print_simple_dest_term (Comb(t1,t2)) = (
	"(" ^ print_simple_dest_term(simple_dest_term t1) ^ " " ^
		print_simple_dest_term(simple_dest_term t2) ^ ")"
) | print_simple_dest_term (Const(s,ty)) = s
| print_simple_dest_term (Var(s,ty)) = s
| print_simple_dest_term (Abs(v,b)) = (
	let val (vs,vt) = dest_var v
	in
	"(ç " ^ vs ^ " é " ^ print_simple_dest_term (simple_dest_term b) ^")"
	end);
in
	fun ‚print_term1· (tm: TERM): unit = (
	diag_string(print_simple_dest_term (simple_dest_term tm))
	);
	fun ‚print_seq· ((tml , tm): SEQ) : unit = (
	diag_string( implode ((map (fn x =>
		print_simple_dest_term (simple_dest_term x) ^", ") tml)
		@
		["Ö ", print_simple_dest_term (simple_dest_term tm)]))
	);
end;

fun print_thm (key:string) (them : THM) : unit = (
let val {level=level,theory=thy{name=iname,...},sequent=sequent} =
		icl'dest_thm them
	in
		diag_string("In theory "^string_of_int iname^ ", at level "^string_of_int level^ ", with key "^key^":");
		print_seq sequent
end);

fun print_thy (thy {name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level,
		user_data = user_data} : THEORY) : unit = (
	diag_string("Internal name " ^ string_of_int iname ^
		", Current Level " ^ string_of_int current_level^
		", Parents " ^ implode
		((map (fn x => string_of_int x ^ " ") parents)));
	diag_string "***Types***";
	map (fn (nm,{arity=arity,level=level}) =>
		diag_string ("     " ^ nm ^ 
			": arity="^string_of_int arity ^
			", level="^string_of_int level))
		ty_env;
	diag_string "***Constants***";
	map (fn (nm,{ty=ty,level=level}) =>
		diag_string ("     " ^ nm ^ 
			": ty="^string_of_type ty ^
			", level="^string_of_int level))
		con_env;
	diag_string "***Theorems***";
	map (fn (key,them) => print_thm key them) theorem_dict;
	diag_string "***Definitions***";
	map (fn (key,them) => print_thm key them) definition_dict;
	diag_string "***Axioms***";
	map (fn (key,them) => print_thm key them)axiom_dict;
	()
);

fun print_ti ({status : THEORY_STATUS,
	inscope : bool,
	contents : THEORY,
	children : int list,
	name : string}:THEORY_INFO) : unit = (
	diag_string ("Theory "^name^":");
	diag_string((if inscope then "In Scope" else "Out of Scope") ^
		", Children:" ^ implode 
		(map (fn x => string_of_int x ^ ", ") children));
	(case status of
	TSNormal => diag_string "Status: Normal"
	| TSDeleted => diag_string "Status: Deleted"
	| TSLocked => diag_string "Status: Locked"
	| TSAncestor => diag_string "Status: Ancestor");
	print_thy contents
);

fun print_hierarchy (():unit) : unit = (
	map (fn (p,q) => (diag_string("------ti key: "^p^"------");
		print_ti q))
	(icl'get_hierarchy ());
	()
);

print_hierarchy ();
icl'new_type("BOOL",0);
print_ti(icl'get_theory_info "next");
val Ü = icl'new_type ("Ü",0);
print_ti(icl'get_theory_info "next");
val n1 = icl'list_save_thm(["n1"], mk_thm "block" 1 1);
val n2 = icl'list_save_thm(["n2"], mk_thm "block2" 1 1);
icl'new_type("â",2);
icl'new_type("ã",2);
val Zero = icl'new_const("0",Ü);
val One = icl'new_const("1",Ü);
val T = icl'new_const("T",BOOL);
val F = icl'new_const("F",BOOL);
print_ti(icl'get_theory_info "next");
val n3 = icl'list_save_thm(["n3"], mk_thm "block3" 0 1);
print_ti(icl'get_theory_info "next");
icl'open_theory "min";
icl'new_type("â",2); (* fails *)
val UNIT = icl'new_type ("UNIT",0);
val Unit = icl'new_const("Unit",UNIT);
print_ti(icl'get_theory_info "min");
icl'open_theory "next";
val AlsoUnit = icl'new_const("AlsoUnit",UNIT);
icl'open_theory "min";
val AlsoUnit2 = icl'new_const("AlsoUnit",UNIT); (* fails *)
icl'open_theory "another";
icl'new_type("BOOL",0);
val T = icl'new_const("T",BOOL);
val F = icl'new_const("F",BOOL);

print_ti(icl'get_theory_info "another");
wf_term F; (* true *)
wf_term T; (* true *)
icl'new_theory "yet_again"; (* fails *)
icl'delete_extension();
print_ti(icl'get_theory_info "another");
val s1 = icl'list_save_thm(["s1"], mk_thm "from_min" 0 3);
val s2 = icl'list_save_thm(["s2"], mk_thm "from_here" 2 5);
wf_term F; (* false *)
wf_term T; (* true *)
icl'new_const("F",BOOL);
print_ti(icl'get_theory_info "another");
wf_term F; (* true *)
wf_term T; (* true *)
icl'delete_extension();
icl'delete_extension(); (* fails *)
icl'delete_thm "s2";
icl'delete_extension();
print_ti(icl'get_theory_info "another");
val TorF = icl'new_const("TorF",BOOL);
print_ti(icl'get_theory_info "another");
wf_term TorF; (* true *)
wf_term T; (* false *)
wf_term F; (* false *)
icl'delete_extension();
print_ti(icl'get_theory_info "another");
icl'delete_extension();
print_ti(icl'get_theory_info "another");
icl'delete_extension(); (* fails *)

icl'open_theory "yet_again";
icl'open_theory "yet_again";
icl'new_axiom(["truth_axiom"],T);
print_ti(icl'get_theory_info "yet_again");
icl'new_axiom(["truth_axiom"],T); (* fails *)
icl'new_axiom(["not so", "No way!"],F);
icl'new_axiom(["testing"],mk_const("rubbish",BOOL)); (* fails *)
icl'new_axiom(["testing"],mk_comb(mk_var("f",mk_fun(BOOL,BOOL)), T)); 
print_ti(icl'get_theory_info "yet_again");
icl'open_theory "another";
icl'new_axiom(["testing2"],mk_comb(mk_var("f",mk_fun(BOOL,BOOL)), T)); (* fails *)
icl'open_theory "yet_again";
icl'new_axiom(["testing2"],mk_comb(mk_const("f",mk_fun(BOOL,BOOL)), T)); (* fails *)
let val t = mk_type("rubbish",[])
in
icl'new_axiom(["testing2"],mk_comb(mk_var("f",mk_fun(t,BOOL)), mk_var("x",t)))
end; (* fails *)
icl'lock_theory "yet_again";
icl'new_axiom(["Truth_axiom"],T); (* fails *)
icl'new_const("ForT",BOOL); (* fails *)
icl'new_type("SOMETHING",3); (* fails *)
icl'unlock_theory "yet_again";
icl'new_axiom(["Truth_axiom"],T); 
icl'new_const("ForT",BOOL); 
icl'new_type("SOMETHING",3); 
print_ti(icl'get_theory_info "yet_again");
val s2 = icl'list_save_thm(["s2"], mk_thm "from_here" 2 5); (* fails *)
icl'open_theory "another";
val s2 = icl'list_save_thm(["s2"], mk_thm "from_here" 2 5); (* fails *)
print_ti(icl'get_theory_info "rubbish"); (* fails *)
icl'get_theory_name 0;
icl'get_theory_name 5; (* fails *)
icl'open_theory "rubbish";
icl'new_theory "to_be_deleted";
print_ti(icl'get_theory_info "to_be_deleted"); 
icl'delete_theory "to_be_deleted";
print_ti(icl'get_theory_info "to_be_deleted"); (* fails *)
print_hierarchy();
icl'open_theory "to_be_deleted"; (* fails *)

icl'delete_theory "to_be_deleted"; (* fails *)
icl'new_theory "to_be_deleted"; (* succeeds! *)
print_ti(icl'get_theory_info "to_be_deleted");
icl'delete_theory "to_be_deleted"; 

icl'delete_theory "min"; (* fails *)
icl'lock_theory "yet_again";
print_ti(icl'get_theory_info "yet_again");
icl'delete_theory "yet_again"; (* fails *)
icl'lock_theory "yet_again"; (* fails *)
icl'unlock_theory "yet_again";
icl'open_theory "yet_again";
icl'delete_theory "yet_again"; (* fails *)
icl'lock_theory "to_be_deleted"; (* fails *)
icl'lock_theory "rubbish"; (* fails *)
icl'unlock_theory "to_be_deleted"; (* fails *)
icl'unlock_theory "rubbish"; (* fails *)
icl'unlock_theory "yet_again"; (* fails *)
print_ti(icl'get_theory_info "next");
icl'duplicate_theory "next" "copy_of_next";
print_ti(icl'get_theory_info "copy_of_next");
icl'duplicate_theory "rubbish" "copy_of_next"; (* fails *)
icl'duplicate_theory "rubbish" "copy_of_rubbish"; (* fails *)
icl'duplicate_theory "to_be_deleted" "copy_of_rubbish";
icl'delete_thm "rubbish";
val s2 = icl'list_save_thm(["s2"], mk_thm "from_here" 2 5); (* fails *)
icl'new_definition (["True"],"True",mk_const("T",BOOL));
icl'new_definition (["False"],"False",mk_const("F",BOOL));
print_ti(icl'get_theory_info "-");
icl'new_definition (["0"],"0",mk_const("0",Ü)); (* fails *)
val zero_def = icl'new_definition (["Zero"],"Zero",mk_const("0",Ü));
val Zero = mk_const("Zero",Ü);
check_thm "test" zero_def;
wf_term Zero;
print_ti(icl'get_theory_info "-");
icl'delete_extension ();
print_ti(icl'get_theory_info "-");
check_thm "test" zero_def;
wf_term Zero;
icl'new_definition ([],"rubbish",mk_const("F",BOOL));
icl'new_definition (["False"],"False",mk_const("F",BOOL));
icl'new_definition (["Somewhere"],"Somewhere",mk_const("Somehow",BOOL));
icl'lock_theory "-";
icl'new_definition (["Somewhere"],"Somewhere",mk_const("False",BOOL));
icl'unlock_theory "-";
icl'new_definition (["Somewhere"],"Somewhere",mk_var("Somehow",BOOL));
val tv1 = mk_vartype "'1";
val tv2 = mk_vartype "'2";
icl'new_const("Everywhere",tv1);

icl'new_definition (["Somewhere"],"Somewhere",
	mk_comb(
	simple_mk_abs(mk_var("Somehow",tv1),T),
	mk_const("Everywhere",tv1)
		)); (* fails *)

(* icl'new_type("BOOL",0); *)
icl'new_const("=",mk_fun(tv1, mk_fun(tv1, BOOL)));
icl'new_const("Ñ",mk_fun(mk_fun(tv1,BOOL),BOOL));
icl'new_const("É",mk_fun(mk_fun(tv1,BOOL),BOOL));
icl'new_const("TypeDefinition",mk_fun(mk_fun(tv1,BOOL),
	mk_fun(mk_fun(tv2,tv1),BOOL)));
val Tv1Pred = icl'new_const("Tv1Pred",mk_fun(tv1,BOOL));

local val x= mk_var("x",tv1)
in
val etype_exax = icl'new_axiom(["etype_exax"],
	simple_mk_Ñ(x,mk_comb(Tv1Pred,x)))
end;
val etype_def = icl'new_type_definition( [ "ETYPE"], "ETYPE", ["'1"], etype_exax);
print_ti(icl'get_theory_info "-");
local val x= mk_var("x",tv2)
in
val etype2_exax = icl'new_axiom(["etype2_exax"],
	simple_mk_Ñ(x,mk_comb(icl'inst [] [(tv2,"'1")]Tv1Pred,x)))
end;
val etype2_def = icl'new_type_definition( [ "ETYPE2"], "ETYPE2", ["'2"], etype2_exax);
print_ti(icl'get_theory_info "-");
icl'new_type_definition( [ "rubbish"], "BOOL", [], etype2_exax); (* fails *)
icl'open_theory "min";
icl'new_type_definition( [ "rubbish"], "BOOL", [], etype2_exax); (* fails *)
icl'open_theory "yet_again";
icl'new_type_definition( [ "rubbish"], "rubbish", [], mk_thm "hello" 0 0); (* fails *)

local val x= mk_var("x",tv2)
in
val etype3_exax = icl'new_axiom(["etype3_exax"],
	simple_mk_É(x,mk_comb(icl'inst [] [(tv2,"'1")]Tv1Pred,x)))
end;
val etype3_def = icl'new_type_definition( [ "ETYPE3"], "ETYPE3", ["'2"], etype3_exax); (* fails *)
local val x= mk_var("x",tv1);
	val y= mk_const("Everywhere",tv1);	
in
val etype4_exax = icl'new_axiom(["etype4_exax"],
	simple_mk_Ñ(x,mk_comb(Tv1Pred,y)))
end;
val etype4_def = icl'new_type_definition( [ "ETYPE4"], "ETYPE4", ["'1"], etype4_exax); (* fails *)
local val x= mk_var("x",tv1);
	val y= mk_const("Everywhere",tv1);	
in
val etype5_exax = icl'new_axiom(["etype5_exax"],
	simple_mk_Ñ(x,T))
end;
val etype5_def = icl'new_type_definition( [ "ETYPE5"], "ETYPE5", ["'1"], etype5_exax); (* fails *)
icl'new_type_definition( [ "ETYPE6"], "ETYPE6", ["'2","'2"], etype2_exax); (* fails *)
icl'new_const("ä",mk_fun(BOOL,mk_fun(BOOL,BOOL)));
local
	val So = mk_var("So",BOOL);
	val IsSo = mk_var("IsSo",BOOL)
in
	val so_isso_axiom = icl'new_axiom(["so_isso_axiom"],
		list_mk_Ñ([So,IsSo],mk_ä(So,IsSo)));
end;
val so_isso_def = icl'new_specification (["So","IsSo"],2,so_isso_axiom);
print_ti(icl'get_theory_info "-");
val x_def = icl'new_specification (["x"],1,etype5_exax);
print_ti(icl'get_theory_info "-");
icl'new_specification ([],1,etype5_exax); (* fails *)
icl'new_specification (["x1"],0,etype5_exax); (* fails *)
icl'new_specification (["x1"],1,etype5_exax); (* fails *)
local val y = mk_var("y",BOOL)
in
val y_ax = icl'new_axiom(["y_ax"],mk_Ñ(y,T))
end;
icl'new_specification (["x"],1,y_ax); (* fails *)
icl'new_specification (["x2"],1,mk_thm "hello" 0 0); (* fails *)
icl'new_specification (["x1"],1,etype3_exax); (* fails *)
local val p= mk_var("p",tv1);
	val q= mk_var("q",BOOL);	
in
val pq_ax = icl'new_axiom(["pq_ax"],simple_mk_Ñ(p,q))
end;
icl'new_specification (["x1"],1,pq_ax); (* fails *)



