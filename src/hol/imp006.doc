=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Implementation for Abstract Data Type $THM$}  %% Mandatory field
\def\TPPheadtitle{Implementation for Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/IMP006}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2,1.3,1.4]
Still being created.
\item [Issue 1.5]
First version working with a version of \cite{DS/FMU/IED/DTD006}.
\item [Issue 1.6]
Minor Corrections.
Functions more closely related to the specifications.
\item [Issue 1.7]
Added $get\_constant\_type$ and $get\_type\_arity$.
\item [Issue 1.8]
Prevented negative arity types.
$icl'get\_theory\_name$ no longer given deleted theory names.
Corrected some $fail$ calls.
\item [Issue 1.9]
Replaced local $set\_equal$ with function from utilities.
Removed open dictionaries statement.
\item [Issue 1.10]
Corrections after comments by RDA.
No external functionality change, merely tidying up.
\item [Issue 1.11]
Made $icl'simple\_list\_É\_elim$ primitive, rather than $icl'simple\_É\_elim$.
Renamed $get\_constant\_type$ as $get\_const\_type$.
Added $icl'seal\_hierarchy$.
\item [Issue 1.12]
Use $term\_mem$ etc.
\item [Issue 1.13]
Corrected error message, and execution, of $simple\_list\_É\_elim$. 
\item [Issue 1.14]
Errors 6008, 6032, 6036, 6041, 6065, 6066, 6070, 6072, 6073, 6074, 6083 are now all raised by $error$ not $fail$
(only some were before).
The name atom ``theorem(s)'' has been consistently changed
to ``thm(s)'', 
and ``definition(s)'' to ``defn(s)''.
Corrected result of $get\_con\_env\ ""$.
\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the abstract data type $THM$.
This includes its
primitive and built-in inference rules,
and its theory management material.
This is called for in section 4 of \cite{DS/FMU/IED/HLD007}.
The high-level specification for the code is
given in \cite{DS/FMU/IED/SPC003}, \cite{DS/FMU/IED/SPC004} and \cite{DS/FMU/IED/SPC005}.
The design is in \cite{DS/FMU/IED/DTD006}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the 
abstract data type $THM$.
This includes its
primitive and built-in inference rules,
and its theory management material.
A ``primitive'' inference rule is considered to be part of the logic,
whereas a built-in rule is one that, though it could be coded in terms 
of the primitive rules, will actually be part of the abstract data type $THM$, and thus taken as holding true without checking.

We have to assume that single assignments cannot be interrupted,
but that any sequence of commands may be.
We need to maintain consistency between certain parts of state,
and thus we have some protected functions,
see section \ref{Inconsistent}.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD006},
and also requires those files indicated as preceding it in the 
rel001 makefile.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}

=TEX
\newpage
\section{INTERRUPTS AND INCONSISTENCY}
\label{Inconsistent}
There are three activities we sometimes wish to do in uninterruptable combinations.
Interrupts might be, for instance, due to the user pressing Control-C, or the program running out of machine resources.
\begin{enumerate}
\item
``In place'' modification of $icl'THEORY\_INFO$s within the hierarchy, using the fact that the hierarchy is an (imperative-style) array and using array assignment.
\item
Changes to the current state, other than ``in place''. 
In particular, modifications to the type and constructor enviroments $ty\_env$ and $con\_env$.
\item
Assignments to the current theory address, to update the theory rather than change the theory that is current.
\end{enumerate}
If combinations of these were interrupted they might lead to some of the following:
\begin{itemize}
\item
The type or constructor enviroments containing items that are not actually within any theory in scope.
This can cause theorems to be apparently valid, when in fact they are not.
\item
The type or constructor enviroments failing to contain items that are actually within some theory in scope.
This could allow the redefinition of such things while theorems concerning
the old definition are still in scope
(and are made valid once more by the redefinition placing the items in the type or constructor enviroment).
\item
A theory may have another as parent that does not record its child in its $children$ field
(we take the $parents$ field as definitive).
This would allow the parent to declare things that clashed with its child's contents, and would sometimes allow the parent to be deleted
leaving an orphan.
\item
A theory may indicate it has another as a child, while the so-called child does not record the other as parent.
This will cause the parent to be unable to redefine things present in the so-called child that strictly it should be able to do.
This is not inconsistent, but only inconvenient.
\item 
Having the $inscope$ fields inconsistent with the current theory and the parentage relation has the same problems as the $children$ field being inconsistent.
If the $inscope$ fields are inconsistent with the type and constant environments
then this will give rise to the same problems as if those are
inconsistent with the theory's contents.
\end{itemize}
These problems could occur in the following functions:

\begin{tabular}{| l | p{4.7in}|}\hline
Function & Combination \\ \hline
$icl'open\_theory$ & Multiple ``in place'' modifications to the hierarchy and environments, and a change of address for the current theory: but all made safe by using a copy of the current hierarchy(1,2). \\
$icl'delete\_theory$ & Multiple ``in place'' modifications to the hierarchy: the deleted theory, and its parents. Can also leave
some garbage if interrupted(1,2). \\
$icl'new\_theory$ & Two ``in place'' modifications to the hierarchy
(new theory and parent), and a change to the state (the value of $top\_theory$)(1,2). \\
$icl'duplicate\_theory$ & Multiple ``in place'' modifications to the hierarchy
(new theory and its parents), and a change to the state (the value of $top\_theory$)(1,2). \\
$delete\_extension$ & Deletions from environments and an assignment to current theory address(2,3). \\
$icl'new\_const$ & Addition to constant environment and an assignment to current theory address(2,3). \\
$icl'new\_type$ & Addition to type environment and an assignment to current theory address(2,3). \\
$icl'new\_defn$ & Addition to constant environment and an assignment to current theory address(2,3). \\
$icl'new\_type\_defn$ & Addition to type environment and an assignment to current theory address(2,3). \\
$icl'new\_specification$ & Additions to constant environment and an assignment to current theory address(2,3). \\
$icl'new\_parent$ & Additions to constant and type environments, an assignment to current theory address, and ``in place'' modifications to the hierarchy (new parent and current theory)(2,3). \\ \hline
\end{tabular}

These problems occur because we maintain ``value added'' copies of 
definitive information, usually to increase speed.
One solution would be to eliminate the copies, and accept the time
cost: this seems an unreasonable deal, and might not solve the 
problem.
Another solution would be to maintain a backup of the entire system
to be reverted to in the case of an error. 
This would have a time penalty, would have to be careful in
avoiding introducing inconsistencies, and might be vulnerable to multiple interrupts.

We choose as a solution the introduction of a flag in the $STATE$ (q.v.),
that is set on entering a block of code that is dangerous if interrupted,
and reset on exiting normally.
An interrupt will leave the flag set.
All validity checkers, in particular $check\_thm$ (q.v)
and $check\_c\_writable$
(``check current theory writable'', q.v.),
will check the flag, and if it is set then the validity check will fail.
Thus an unfortunately timed interrupt could render the system ``you can look, but you can't touch''.
This is indicated by the error message:

ÛError Declaration
6083	STATE RENDERED INCONSISTENT: state is now read-only, and
	you are advised to quit ICL HOL. Do not commit the ML database.
Ê

\section{THE ABSTRACT DATA TYPE $THM$}
=SML
structure ‚icl'Kernel· : icl'Kernel = struct
=TEX
\subsection{Utilities}
The following is a function to give the maximum of a list of numbers.
The maximum of n empty list is $0$ (could be made a fail).
=SML
fun ‚list_max· ([]: int list): int = 0
| list_max (a :: x) = (
let fun aux (sf:int) ((p :: q):int list) : int = (
	if sf < p
	then aux p q
	else aux sf q
	) | aux sf [] = sf;
in
	aux a x
end);
=TEX
Give a list of HOL type variables $'1, '2,\ldots$:
=SML
fun ‚ntyvars· (n : int) : TYPE list = (
	map (fn x=> mk_vartype("'"^string_of_int x))
		(interval 1 n)
);
=TEX
Find two elements that are the same (presuming $all\_different$ has failed):
=SML
fun ‚two_the_same· ((a :: x): ''a list) : ''a = (
	if a mem x
	then a
	else two_the_same x
) | two_the_same _ = error "two_the_same" 6032 [];
=TEX
\subsubsection{Ranges}
We are interested in supporting ranges of deleted levels,
but the code can be given in isolation from
the type of theories.

We are interested in a list of numbers,
\[ [ (a_{1},\ b_{1}),\ (a_{2},\ b_{2}),\ ...,\ (a_n,\ b_n)]\]
where $b_{i-1}$ is always less than $a_i$,
$0\ <\ a_1$, 
and $a_i$ is always less than or equal to $b_i$.

First, we wish to check whether a number fails inside any of the ranges $a_i$ to $b_i$.
=SML
fun ‚range_mem· (v : int, [] : (int * int)list) = false
| range_mem (v, ((a,b) :: x)) = (
	(v >= a) andalso 
	((v <= b) orelse range_mem(v, x))
);
=TEX
Second, we wish to extend the range by adding (a,b), which may enclose other ranges.
=SML
fun ‚extend_range· (a:int,b:int) ([]:(int * int)list): (int * int)list= (
	[(a,b)]
) | extend_range (a,b) (lst as ((a1,b1) :: x)) = (
let
	fun fixb lw (lst1 as ((a2,b2) :: x1)) = (
		if b + 1 < a2
		then ((lw,b) :: lst1)
		else if b <= b2
		then ((lw,b2) :: x1)
		else fixb lw x1
	) | fixb lw [] = [(lw,b)];
in
	if a < a1 
	then fixb a lst
	else if b1+1 < a
	then ((a1,b1) :: extend_range (a,b) x)	
	else fixb a1 lst
end);
=IGN
val p = [(1,2), (6,8), (10,10), (12,13)];
extend_range (0,3) p;
extend_range (4,4) p;
extend_range (5,5) p;
extend_range (11,15) p;
extend_range (11,11) p;
=TEX
\subsubsection{Infinite Arrays}
We implement Infinite arrays as finite arrays of lists of values.
We expect that the lists will be short (generally only length 0 to 2, even in ``large'' applications, and we optimize for that).
We use the following signature, but as we are within a structure
we can only use the $sig \ldots end$ part.
Û
signature ‚InfiniteArray· = sig
	type 'a ‚INFINITE_ARRAY·;
	val ‚create_ia· : unit -> '_a INFINITE_ARRAY;
	val ‚update_ia· : ('_a INFINITE_ARRAY * int * '_a) -> unit;
	val ‚sub_ia· : ('_a INFINITE_ARRAY * int) -> '_a;
end;
Ê
=TEX
=SML
structure ‚InfiniteArray· : sig
	type 'a INFINITE_ARRAY;
	val create_ia : unit -> '_a INFINITE_ARRAY;
	val update_ia : ('_a INFINITE_ARRAY * int * '_a) -> unit;
	val sub_ia : ('_a INFINITE_ARRAY * int) -> '_a;
	end = struct
=TEX
Introduce the array package:
=SML
open Array;
=TEX
Infinite arrays are made of size $sz$ lists - an index picks from the list by indexing the array by $index\ mod\ sz$,
and then takes the $index\ div\ sz$'th member of the list
(0 being the first element of the list).
=SML
type '_a ‚INFINITE_ARRAY· = ('_a list) array;
=TEX
Give a single, hidden, source of the size of the array that holds the lists:
=SML
val sz = 100;
=TEX
Create a new array, using a dummy argument to force the type:
=SML
fun ‚create_ia· (():unit): '_a INFINITE_ARRAY = (
	array (sz, ([] : '_a list))
);
=TEX
The following is a function to place the value at index given in array.
The function can ignore some ``gaps'' in the array, but not
others. 
We don't expect our use of the package to produce any gaps,
but it is easier to allow gaps to exist than detect this fact.
The final $else$ of $aux$ could be modified to
pad with $vl$ to allow all gaps to be ignored
at the cost of some spurious values within the array.
This is in excess to our needs.
=SML
fun ‚update_ia· ((arr : '_a INFINITE_ARRAY), 
		(index: int), 
		(vl : '_a)) = (
let fun aux (n:int) ([]: '_a list) : '_a list = (
	if n = 0
	then [vl]
	else error "update_ia" 6070 []
) | aux n (a :: x) = (
	if n = 0
	then (vl :: x)
	else (a :: aux (n-1) x));
in
	if index < 0
	then error "update_ia" 6070 []
	else let val imsize = index mod sz;
		val sublist = (sub(arr, imsize))
	in
		update(arr, imsize, (aux (index div sz) sublist))
	end
end);
=TEX
Subscript the infinite array, giving a failure if the 
entry does not exist:
=SML
fun ‚sub_ia· ((arr : '_a INFINITE_ARRAY), index : int) = ((
	if index < 0
	then error "sub_ia" 6070 []
	else (nth (index div sz) (sub(arr, index mod sz))))
	handle complaint =>
		if area_of complaint = "nth"
		then error "sub_ia" 6070 []
		else reraise complaint (area_of complaint)
);
=TEX
=SML
end; (* of structure InfiniteArray *)

open InfiniteArray;
=TEX
\subsection{Types of the ADT $THM$}
A fragment of some user data, and a collection of such
fragments:
=SML
datatype ‚USER_DATUM· =
	‚UD_Term· of TERM * (USER_DATUM list) |
	‚UD_Type· of TYPE * (USER_DATUM list) |
	‚UD_String· of string * (USER_DATUM list) |
	‚UD_Int· of int * (USER_DATUM list);

type ‚USER_DATA· = (USER_DATUM ref) S_DICT;
=TEX
The type of sequents:
=SML
type ‚SEQ· = TERM list * TERM;
=TEX
The type of the theory status:
=SML
datatype ‚THEORY_STATUS· =
	‚TSNormal· | ‚TSLocked· | ‚TSAncestor· | ‚TSDeleted·;
=TEX
=SML
abstype ‚THM· = ‚Thm· of {
		level : int,
		theory : icl'THEORY ref, 
		sequent : SEQ}
and
	‚icl'THEORY· = ‚Thy· of {
		name : int,
		ty_env : {arity:int, level:int} S_DICT,
		con_env : {ty:TYPE, level:int} S_DICT,
		parents : int list,
		del_levels : (int * int) list,
		axiom_dict : THM S_DICT,
		defn_dict : THM S_DICT,
		thm_dict : THM S_DICT,
		current_level : int,
		user_data : USER_DATA ref}
and
	‚icl'THEORY_INFO· = ‚ThyInfo· of {
		status : THEORY_STATUS,
		inscope : bool,
		contents : icl'THEORY ref,
		children : int list,
		name : string}
and
=TEX
In a hierarchy there will be theories with internal names $0$ to $top\_theory$, though some may have the status ``deleted''.
=SML
	‚icl'HIERARCHY· = ‚hier· of {
		lookup : icl'THEORY_INFO INFINITE_ARRAY,
		top_theory : int}
=TEX
There now follows the body of the $abstype$:
=SML
with
=TEX
\subsection{The Interface Theory Type}
The interface presentation of $icl'THEORY$:
=SML
type ‚THEORY· = {
		name : int,
		ty_env : {arity:int, level:int} S_DICT,
		con_env : {ty:TYPE, level:int} S_DICT,
		parents : int list,
		del_levels : (int * int) list,
		axiom_dict : THM S_DICT,
		defn_dict : THM S_DICT,
		thm_dict : THM S_DICT,
		current_level : int,
		user_data : USER_DATA ref};
=TEX
\subsection{The State Type}
$sealed$ is the integer index of the sealed theory.
=SML
type ‚STATE· = {hierarchy : icl'HIERARCHY,
	theory : icl'THEORY ref,
	ty_env : {arity:int, level:int} E_DICT,
	con_env : {ty:TYPE, level:int} E_DICT,
	inconsistent : bool,
	sealed : int};
=TEX
\subsection{Interface Types}
=SML
type ‚THEORY_INFO· = {
		status : THEORY_STATUS,
		inscope : bool,
		contents : THEORY,
		children : int list,
		name : string};

type ‚HIERARCHY· = (string * THEORY_INFO) list;
=TEX
\subsection{The Type of Conversions}
=SML
type ‚CONV· = TERM -> THM;
=TEX
\subsection{The Initial State}
The following is a function to give an empty theory, for initialisation
or deletion purposes.
The $pnts$ (for ``parents'') are given  as a list type to give a simple ``optional'' value method.
=SML
fun ‚empty_theory· (nm: int) (pnts : int list) : icl'THEORY = (
	Thy{name = nm,
	 ty_env = initial_s_dict,
	 con_env = initial_s_dict,
	 parents = pnts,
	 del_levels = [],
	 axiom_dict = initial_s_dict,
	 defn_dict = initial_s_dict,
	 thm_dict = initial_s_dict,
	 current_level = 0,
	 user_data = ref initial_s_dict}
);
=TEX
The following is initialises the ``current state'', which is a $ref$ variable called $current$.
Initially it contains the empty theory "min", alone, as the current theory, which is also the sealed theory, with empty environments
(except that the constant environment always contains the numeric, string and character literal constants).

=SML
local
	val min = ref (empty_theory 0 []);

	val min_ti = ThyInfo{status = TSNormal,
		inscope = true,
		contents = min,
		children = [],
		name = "‚min·"};

	val init_hier_ia : icl'THEORY_INFO INFINITE_ARRAY = create_ia ();

	val dummy = update_ia(init_hier_ia, 0, min_ti);

	val init_hier :  icl'HIERARCHY = 
		(hier {lookup = init_hier_ia, top_theory = 0});
in
	val ‚current· : STATE ref = ref {
		hierarchy = init_hier,
		theory = min,
		ty_env = initial_e_dict,
		con_env = initial_e_dict,
		inconsistent=false,
		sealed = 0};
end;
=TEX
Pointers into the current state:
=SML
fun ‚current_hierarchy· (():unit) : icl'HIERARCHY = (
let 	val {hierarchy=hierarchy,...} = !current
in
	hierarchy
end);

fun ‚current_theory· (():unit) : icl'THEORY = (
let 	val {theory=theory,...} = !current
in
	!theory
end);
=TEX
\subsection{The Scope of Types and Constants}
We will need  to be able to rapidly check where HOL terms, types
and their derivatives are well-formed.
Well-formedness is just that the HOL type constructors and constants are in scope, with the right usage.
To do this efficiently we need a fast lookup facility for
type constructors and constants in scope.

Remove a simple dictionaries worth of constructor
information from an $E\_DICT$:
=SML
fun ‚del_con_env· (lst:{ty:TYPE, level:int} S_DICT) 
	(edict:{ty:TYPE, level:int} E_DICT): {ty:TYPE, level:int} E_DICT = (
	fold (fn ((nm,_),dct) => e_delete nm dct)
		lst
		edict
);

fun ‚del_ty_env· (lst:{arity:int, level:int} S_DICT)
	(edict:{arity:int, level:int} E_DICT) : {arity:int, level:int} E_DICT = (
	fold (fn ((nm,_),dct) => e_delete nm dct)
		lst
		edict
);
=TEX
We give a function to add a simple dictionaries worth of constructor
information to a scope.
=SML
fun ‚add_con_env· (lst:{ty:TYPE, level:int} S_DICT) 
	(edict:{ty:TYPE, level:int} E_DICT): {ty:TYPE, level:int} E_DICT= (
	list_e_merge edict lst
	handle complaint =>
		if area_of complaint = "e_extend"
		then error "add_con_env" 6073 []
		else reraise complaint (area_of complaint)
);

fun ‚add_ty_env· (lst:{arity:int, level:int} S_DICT) 
	(edict:{arity:int, level:int} E_DICT) : {arity:int, level:int} E_DICT = (
	list_e_merge edict lst
	handle complaint =>
		if area_of complaint = "e_extend"
		then error "add_ty_env" 6074 []
		else reraise complaint (area_of complaint)
);
=TEX
The following functions look up a named entry in the value constructor or type constructor scopes.
These two functions could be made available to the user or interface
document, to allow, if nothing else, a ``what caused the well-formedness check to fail'' function to be written.
The constant environment always contains the numeric, string and character literal constants.
=SML
local
	val ordquote = ord("'");
	val orddquote = ord("\""); (* " *)
	val ord0 = ord("0");
	val ord9 = ord("9");
in
fun ‚get_con_env· (nm : string): {ty:TYPE, level:int} OPT = (
let 	val {con_env=con_env,...} = !current;
in
	if nm = "" 
	then e_lookup "" con_env
	else (let
	val ordnm = ord nm;
in
	(if (ordnm = ordquote) andalso (size nm = 2)
	then Value {ty=CHAR, level = 0}
	else if	(ordnm = orddquote)
	then Value {ty = STRING, level = 0}
	else if	(ord0 <= ordnm andalso ordnm <= ord9 andalso
		(is_all_decimal nm))
	then Value {ty = Ü, level = 0}
	else e_lookup nm con_env)
end)
end);
end;

fun ‚get_ty_env· (nm : string):{arity:int, level:int} OPT = (
let 	val {ty_env=ty_env,...} = !current
in
	e_lookup nm ty_env
end);
=TEX
Add a theory's environment to a pair of environment dictionaries:
=SML
fun ‚add_thy_env· (Thy{ty_env=ty_env, con_env=con_env,...})
	((te : {arity:int, level:int} E_DICT),
	 (ce : {ty:TYPE, level:int} E_DICT)) : 
	(({arity:int, level:int} E_DICT) *
	 ({ty:TYPE, level:int} E_DICT)) = (
	add_ty_env ty_env te,
	add_con_env con_env ce
);
=TEX
Delete a theory's environment to a pair of environment dictionaries:
=SML
fun ‚del_thy_env· (Thy{ty_env=ty_env, con_env=con_env,...})
	((te : {arity:int, level:int} E_DICT),
	 (ce : {ty:TYPE, level:int} E_DICT)) : 
	(({arity:int, level:int} E_DICT) *
	 ({ty:TYPE, level:int} E_DICT)) = (
	del_ty_env ty_env te,
	del_con_env con_env ce
);
=TEX
\subsection{Utilities Depending on ADT State and Types}
\subsubsection{Well-formedness}
The following are functions to check whether a type, term or sequent is well-formed within the current scope.

We choose to make a set of all types and constants to be checked,
and then check each set member, rather than check all generated
items, as this is judged superior in speed.
=SML
local
	fun auxty [] = true
	| auxty ((tnm,arit) :: x) = (
		let val res = get_ty_env tnm
		in
		case res of
		Value{arity=arity,...} => (arit=arity)
			andalso auxty x
		| Nil => false
		end);

	fun auxcon [] = true
	| auxcon ((cnm,typ) :: x) = (
		let val res = get_con_env cnm
		in
		case res of
		Value{ty=ty1,...} => (
			(is_type_instance typ ty1)
			andalso auxcon x)
		| Nil => false
		end);
in
	fun ‚wf_type· (ty : TYPE) : bool =
	let val tyv = type_tycons ty;

	in
		auxty tyv
	end;

	fun ‚wf_term· (tm : TERM) : bool =
	let val tyv = term_type_constructors tm;
		val con = term_consts tm;

	in
		auxty tyv andalso auxcon con
	end;

	fun ‚wf_seq· ((tml , tm) : SEQ) : bool =
	let val tyv = list_cup (term_type_constructors tm ::
			map term_type_constructors tml);
		val con = list_cup (term_consts tm ::
			map term_consts tml);
	in
		auxty tyv andalso auxcon con
	end;
end; (* of local fun auxty... *)
=TEX
The following is a function to check that a theorem is valid, fail if not.
Note that we do not check the well-formedness of the sequent,
as this is not required by the specification.
=SML
fun ‚check_thm· (caller: string)
	(Thm {level = level, theory=theory, ...} : THM) : unit = (
let 	val {hierarchy = hier{lookup=lookup, top_theory=top_theory},
		inconsistent=inconsistent,...} = !current;

	val Thy{name = iname, del_levels = del_levels, ...} = !theory;
	
	val dummy = if inconsistent
		then error caller 6083 []
		else if (0 <= iname) andalso (iname <= top_theory)
		then ()
		else error caller 6072 [fn () => "Internal "^string_of_int iname];

	val ThyInfo{status = status,
		inscope = inscope,
		contents = contents,
		children = children,
		name = ename}
		= sub_ia(lookup,iname);
in
	if status = TSDeleted
	then error caller 6036 [(fn () => ename),(fn () => string_of_int iname)]
	else if theory <> contents
	then error caller 6072 [fn () => "Internal "^string_of_int iname]
	else if not inscope
	then error caller 6066 [fn () => ename]
	else if range_mem(level, del_levels)
	then error caller 6065 [fn () => ename]
	else ()
end);
=TEX

\subsubsection{Theory Names}
$icl'get\_current\_theory\_name$ is part of the ADT interface,
but it is useful in defining utilities, so we provide it ``out of sequence''.

Get the current theory's name as an integer:
=SML
fun ‚icl'get_current_theory_name· (():unit) : int = (
let 	val Thy{name = name,...} = current_theory();
in
	name
end);
=TEX
Check that an internal name falls within the range 0 to $top\_theory$, failing if not, with area being the $caller$ parameter:
=SML
fun ‚check_internal_theory_name· (nm : int) (caller : string) : unit = (
let 	val hier{top_theory=top_theory,...} = current_hierarchy();
in
	if (0 <= nm) andalso (nm <= top_theory)
	then ()
	else fail caller 6043 [fn () => string_of_int nm]
end);
=TEX
Given a theory name as an string, the following function returns its internal name as an integer.
The error raised is stated to be from the calling function, denoted by $caller$.
A deleted theory's name cannot be found by these means.
=SML
fun ‚internal_theory_name· (nm : string) (caller : string): int = (
let 	val hier{lookup=lookup, top_theory=top_theory} = 
		current_hierarchy();
	fun aux ~1 = fail caller 6035 [fn () => nm]
	| aux n = (let val (ThyInfo{name=sname,contents=contents,status=status,...}) 
			= sub_ia(lookup, n);
		in
			if ((sname = nm) andalso (status <> TSDeleted))
			then (let val(Thy{name=iname,...}) = !contents
				in
					iname
				end)
			else aux (n-1)
		end)
in
	if nm = "-"
	then icl'get_current_theory_name ()
	else aux top_theory
end);
=TEX
The following is a test of whether the given theory name present at all.
A deleted theory will not be noted by this function.
There is always a current theory, ``-''.
=SML
fun ‚is_theory_name· (nm : string) : bool = (
let 	val hier{lookup=lookup, top_theory=top_theory} = 
		current_hierarchy();
	fun aux ~1 = false
	| aux n = (let val (ThyInfo{name=sname,status=status,...}) = sub_ia(lookup, n);
		in
			((sname = nm) andalso (status <> TSDeleted))
			orelse aux (n-1)
		end)
in
	(nm = "-")
	orelse aux top_theory
end);
=TEX
Return the theory contents:
=SML
fun ‚get_theory_contents· (n : int) : icl'THEORY = (
let 	val hier{lookup=lookup, ...} = current_hierarchy();
	val (ThyInfo{contents=contents,...}) = sub_ia(lookup, n);
in
	!contents
end);
=TEX
Return the current theory name as a string:
=SML
fun ‚get_current_theory_name· (():unit):string = (
let 	val hier{lookup=lookup, ...} = current_hierarchy();
	val Thy{name = iname,...} = current_theory();
	val (ThyInfo{name=ename,...}) = sub_ia(lookup, iname);
in
	ename
end);
=TEX
\subsubsection{Checking Writability}
We give a check that the current theory status allows writing, with various fail messages if not.
Note that the current theory should never have status $TSDeleted$.
=SML
fun ‚check_c_writable· (caller : string) : unit = (
let 	val {hierarchy = hier{lookup=lookup, ...},
		theory = theory, inconsistent=inconsistent,...} = !current;

	val Thy{name = iname,...} = !theory;

	val ThyInfo{status = status, name = ename,...}  = sub_ia(lookup,iname);

in
	if inconsistent
	then error caller 6083 []
	else case status of
	TSDeleted => error caller 6008 [fn x=>ename]
	| TSAncestor => fail caller 6071 [fn x=>ename]
	| TSLocked => fail caller 6037 [fn x=>ename]
	| TSNormal => ()
end);
=TEX
\subsubsection{Ancestors and Descendants}
A function to return all of a theory's ancestors
(including itself):
=SML
fun ‚theory_ancestors· (nm : int) : int list = (
let 	val hier{lookup=lookup, ...} = current_hierarchy();

	fun lparents (n : int) = (
		let val ThyInfo{contents=contents,...} = sub_ia(lookup,n);
			val Thy{parents=parents,...} = !contents
		in
			parents
		end);

	fun allparents ([]:int list) (acc:int list) = acc
	| allparents (a :: x) acc = (
		if a mem acc
		then allparents x acc
		else allparents ((lparents a) cup x) (a :: acc));
in
	check_internal_theory_name nm "theory_ancestors";
	allparents [nm] []
end);
=TEX
A function to return all of a theory's descendants
(but not including itself):
=SML
fun ‚theory_descendants· (nm : int) : int list = (
let 	val hier{lookup=lookup, ...} = current_hierarchy();

	fun lchildren (n : int) = (
		let val ThyInfo{children=children,...} = sub_ia(lookup,n);
		in
			children
		end);

	fun allchildren ([]:int list) (acc:int list) = acc
	| allchildren (a :: x) acc = (
		if a mem acc
		then allchildren x acc
		else allchildren ((lchildren a) cup x) (a :: acc));
in
	check_internal_theory_name nm "theory_descendants";
	allchildren (lchildren nm) []
end);
=TEX
We provide a datatype to encode the results of the following functions.
=SML
datatype ‚THEORY_SCOPE· = ‚NotPresent· |  ‚InScope· | ‚InDescendant·
=TEX
Is a given constant name used in any ancestor or descendant of the
current theory?
=SML
fun ‚const_in_anc_or_des· (nm : string) : THEORY_SCOPE = (
let 	val iname =icl'get_current_theory_name();
	
	val hier{lookup=lookup, ...} = current_hierarchy();

	fun const_in_thy (nm : string) (thry : int) : bool = (
	let val ThyInfo{contents = contents,...} = sub_ia(lookup, thry);
		val Thy{con_env=con_env,...} = !contents;
	in
		not(is_Nil(s_lookup nm con_env))
	end);
in	
	if is_Nil(get_con_env nm)
	then (if (any (theory_descendants iname) 
		(fn thry => const_in_thy nm thry))
		then InDescendant
		else NotPresent)
	else InScope
end);
=TEX
Is a given type constructor name used in any ancestor or descendant of the
current theory?
=SML
fun ‚type_in_anc_or_des· (nm : string) : THEORY_SCOPE = (
let 	val iname = icl'get_current_theory_name();
	
	val hier{lookup=lookup, ...} = current_hierarchy();

	fun type_in_thy (nm : string) (thry : int) : bool = (
	let val ThyInfo{contents = contents,...} = sub_ia(lookup, thry);
		val Thy{ty_env=ty_env,...} = !contents;
	in
		not(is_Nil(s_lookup nm ty_env))
	end);
in	
	if is_Nil(get_ty_env nm)
	then (if (any (theory_descendants iname) 
		(fn thry => type_in_thy nm thry))
		then InDescendant
		else NotPresent)
	else InScope
end);
=TEX
=SML
local
	fun ‚modify_child· (parents: int list) 
		(modify : int list -> int list) : unit = (
	let 	val hier{lookup=lookup, ...} = current_hierarchy();
		fun aux (a :: x) = (
		let val ThyInfo{status = status,
			inscope = inscope,
			contents = contents,
			children = children,
			name = name} = sub_ia(lookup,a)
		in
		update_ia(lookup,a,
			ThyInfo{status = status,
			inscope = inscope,
			contents = contents,
			children = modify children,
			name = name});
			aux x
		end
		) | aux [] = ();
	in
		aux parents
	end);
in
=TEX
The following function removes theory $child$ from the children field 
of each of its $parents$.
This will be used in $icl'delete\_theory$.
=SML
fun ‚remove_child· (child : int) (parents: int list) : unit = (
	modify_child parents (fn children => children less child)
);
=TEX
The following function adds theory $child$ to the children field 
of each of its $parents$.
This will be used in $icl'new\_theory$ and
$icl'duplicate\_theory$.
=SML
fun ‚add_child· (child : int) (parents : int list) : unit = (
	modify_child parents (fn children => (child :: children))
);
end; (* of local fun modify_child ... *)
=TEX
\subsubsection{Hierarchies}
The following function maps $f$ over each of the theory information cells in the hierarchy.
As it is working through references it is misleading to
return any value.
=SML
fun ‚map_hierarchy· (f: (int * icl'THEORY_INFO) -> icl'THEORY_INFO) 
	(hir : icl'HIERARCHY) : unit = (
let 	val hier{lookup=lookup, top_theory=top_theory} = 
		hir;
	fun aux	n = (if n <= top_theory
		then (
		let val old_ti = sub_ia(lookup, n)
		in
			update_ia(lookup,n,f (n,old_ti));
			aux (n+1)
		end) 
		else ());
in
	aux 0
end);
=TEX
Now a function to copy a hierarchy into a new one:
Note that when creating new hierarchies by copying we must copy from theory information 0 first, and then copy up to the number of hierarchies.
=SML
fun ‚copy_hierarchy· (old : icl'HIERARCHY) : icl'HIERARCHY = (
let 	val hier{lookup=old_lookup, top_theory=top_theory} = 
		old;
	val new_lookup = create_ia (); 
	fun aux	n = (if n <= top_theory
		then (
		let val old_ti = sub_ia(old_lookup, n);
		in
			update_ia(new_lookup,n,old_ti);
			aux (n+1)
		end) 
		else ());
in
	(aux 0;
	hier{lookup=new_lookup, top_theory=top_theory})
end);
=TEX
We need a test to see if $hir1$ hierarchy is an ``ancestor'' of $hir2$.
According to the specification, this is so if the child possesses all the ancestors theories (by address comparison),
with the same theory information for each,
except that the children theories field may be different.
As new theories are always added to the ``tail'' of the theory hierarchy array we need only test up to the top theory of the ``ancestor''
hierarchy.
=SML
fun ‚is_hierarchy_ancestor· (hir1 : icl'HIERARCHY)
	(hir2 : icl'HIERARCHY) : bool = (
let 	val hier{lookup=lookup1, top_theory=top_theory1} = 
		hir1;

	val hier{lookup=lookup2, top_theory=top_theory2} = 
		hir2;

	fun aux ~1 = true
	| aux n = (
	let val (ThyInfo{status = status1,
			inscope = inscope1,
			contents = contents1,
			children = children1,
			name = name1})
		= sub_ia(lookup1,n);

		val (ThyInfo{status = status2,
			inscope = inscope2,
			contents = contents2,
			children = children2,
			name = name2})
		= sub_ia(lookup2,n) 
	in
		(status1 = status2) andalso
		(inscope1 = inscope2) andalso
		(contents1 = contents2) andalso
		(name1 = name2) andalso
		aux (n-1)
	end)
in
	(top_theory1 <= top_theory2) andalso
	aux top_theory1
end);
=TEX
\section{THEORY AND HIERARCHY FUNCTIONS OF ADT THM}
\subsection{Operations on Hierarchies}
These functions follow the specification of \cite{DS/FMU/IED/SPC005}.

The following function gives the process of creating a new hierarchy from the current one.
We first take a copy, we then modify its contents by reference,
we then make the current state have this new hierarchy as its current
one, as well as returning this value.
=SML
fun ‚icl'new_hierarchy· (x: unit) : icl'HIERARCHY = (
let 	val {hierarchy=hierarchy, theory=theory, ty_env=ty_env, 
		con_env=con_env, inconsistent=inconsistent,sealed=sealed} = !current;

	fun make_anc (n , ThyInfo{status = status,
				inscope = inscope,
				contents = contents,
				children = children,
				name = name})
		=
		( ThyInfo{status = (if status = TSDeleted
					then TSDeleted
					else TSAncestor),
				inscope = inscope,
				contents = contents,
				children = children,
				name = name});

	val hcopy = copy_hierarchy hierarchy;

	val dummy = map_hierarchy make_anc hcopy; (* spec. step 1 *)

in
	current := {hierarchy = hcopy, theory=theory, ty_env=ty_env, 
		con_env=con_env, inconsistent=inconsistent, sealed=sealed};
		(* spec. step 2 *)
	hcopy (* spec. step 3 *)
end);
=TEX
Now we give a ``load hierarchy'' function, as demanded by the specification.
As the current theory address doesn't change, and its contents and its ancestors are
equal, $ty\_env$ and $con\_env$ do not change.
The specification step 1 is irrelevant to our style of
implementation.
=SML
fun ‚icl'load_hierarchy· (hir : icl'HIERARCHY) : unit = (
let 	val {hierarchy=hierarchy, theory=theory, ty_env=ty_env, 
		con_env=con_env, inconsistent=inconsistent,sealed=sealed} = !current;
in
	if is_hierarchy_ancestor hierarchy hir (* spec step 2 *)
	then current := {hierarchy = hir, theory=theory, ty_env=ty_env, 
		con_env=con_env, inconsistent=inconsistent,sealed=sealed}
		(* spec step 3 *)
	else fail "icl'load_hierarchy" 6033 []
end
);
=TEX
Give an interface presentation of the current hierarchy:
=SML
fun ‚icl'get_hierarchy· (():unit) : HIERARCHY = (
let 	val hier{lookup=lookup, top_theory=top_theory} = 
		current_hierarchy();
	fun aux ~1 = [] 
	| aux n = (let val (ThyInfo{status = status,
			inscope = inscope,
			contents = contents,
			children = children,
			name = name}) = sub_ia(lookup,n);
			val Thy athy = !contents;
		in
			(name, {status = status,
				inscope = inscope,
				contents = athy,
				children = children,
				name = name}) 
			:: aux (n-1)
		end)
in
	aux top_theory
end);
=TEX
=SML
fun ‚icl'seal_hierarchy· (() : unit) : unit = (
let 	val {hierarchy=hierarchy, theory=theory, ty_env=ty_env, 
		con_env=con_env, inconsistent=inconsistent,sealed=sealed} = !current;
in
	current := {hierarchy = hierarchy, theory=theory, ty_env=ty_env, 
		con_env=con_env, inconsistent=inconsistent,
		sealed=icl'get_current_theory_name ()}
end
);
=TEX
In the sequence suggested by \cite{DS/FMU/IED/DTD006}
we would only now give $icl'get\_current\_theory\_name$,
but the function was useful in defining utilities needed before this point.

Return an interface presentation of a theory, based on a string:
=SML
fun ‚icl'get_theory_info· (nm : string) : THEORY_INFO = (
let 	val hier{lookup=lookup, ...} = current_hierarchy();

	val iname = internal_theory_name nm "icl'get_theory_info";

	val (ThyInfo{status = status,
			inscope = inscope,
			contents = contents,
			children = children,
			name = name}) = sub_ia(lookup,iname);

	val Thy athy = !contents;
in
	{status = status,
	inscope = inscope,
	contents = athy,
	children = children,
	name = name}
end);
=TEX
Given a theory name as an integer, return it as a string:
=SML
fun icl'get_theory_name (nm : int) : string = (
let 	val hier{lookup=lookup, ...} = current_hierarchy();
in
	check_internal_theory_name nm "icl'get_theory_name";
	(let val (ThyInfo{name=name,status=status,...}) = sub_ia(lookup, nm)
		in
			if status <> TSDeleted
			then name
			else fail "icl'get_theory_name" 6089 [fn () => string_of_int nm]
		end)
end);
=TEX
\subsection{Operations on Theory Attributes}
These functions follow the specification of \cite{DS/FMU/IED/SPC005}.

We give a function to make some theory the current theory.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun ‚icl'open_theory· (nm : string) : (int list * int list) = (
let 	val {hierarchy = hierarchy as hier{lookup=lookup, top_theory=top_theory},
		theory=theory, ty_env=ty_env, con_env=con_env, 
		inconsistent=inconsistent,sealed=sealed} = !current;

	val thyn = internal_theory_name nm "icl'open_theory"; (* spec step 1 *)

	val allp = theory_ancestors thyn;

	val sideeffect = if sealed mem allp
		then ()
		else fail "icl'open_theory" 6017 [fn () => nm,
			fn () => icl'get_theory_name sealed];

	val ThyInfo{status = status,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name} = sub_ia(lookup,thyn);
=TEX
For specification step 2 we take a copy of the current hierarchy to modify, and this will
be put back in place.
This may create more garbage than modifiing the current hierarchy in place,
but does help to ensure consistency by using a single assignment.
=SML
	val chierarchy as hier{lookup=clookup, ...} = copy_hierarchy hierarchy;
=TEX
The following auxiliary function sets all the inscope fields to
their correct value,
and gets the new values for the current $ty\_env$ and $con\_env$.
=SML
	fun aux ~1 into_scope out_of_scope tece = (into_scope, out_of_scope, tece)
	| aux n into_scope out_of_scope tece = (
		let val ThyInfo{status = status1,
			inscope = inscope1,
			contents = contents1,
			children = children1,
			name = name1} = sub_ia(clookup,n)
		in
		if n mem allp
		then (if inscope1
			then aux (n - 1) into_scope out_of_scope tece
			else (update_ia(clookup,n,
				ThyInfo{status = status1,
				inscope = true,
				contents = contents1,
				children = children1,
				name = name1});
				aux (n-1) (n :: into_scope) out_of_scope 
					(add_thy_env (!contents1) tece)))
		else (if not inscope1
			then aux (n - 1) into_scope out_of_scope tece
			else (update_ia(clookup,n,
				ThyInfo{status = status1,
				inscope = false,
				contents = contents1,
				children = children1,
				name = name1});
				aux (n-1) into_scope (n :: out_of_scope)
					(del_thy_env (!contents1) tece)))
		end);
=TEX
Now use this auxiliary function to gain the theories moved in and out of scope and the
new type and constructor environments, after the opening.
=SML
	val (ins, outs, (te,ce)) = aux top_theory [] [] (ty_env, con_env);
=TEX
Then we can do a single assignment modification of the state:
=SML
in	
	current := {hierarchy=chierarchy, theory=contents, ty_env=te, 
		con_env=ce, inconsistent=inconsistent,sealed=sealed};
		(* spec step 3, 4 *)
	(ins, outs)
end);
=TEX
The following is a function to delete theories.
We modify the current hierarchy ``in place'' rather than taking a copy.
If it is interrupted then the state may be left with the $inconsistent$ flag set.
=SML
fun ‚icl'delete_theory· (nm : string) : unit = (
let 	val {hierarchy = hierarchy as hier{lookup=lookup, ...},
		theory=theory, ty_env=ty_env, con_env=con_env, 
		inconsistent=inconsistent,sealed=sealed} = !current;

	val thyn = internal_theory_name nm "icl'delete_theory"; (* spec. step 1 *)
	
	val ThyInfo{status = status,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name} = sub_ia(lookup,thyn);

	val dummy = case status of
		TSDeleted => error "icl'delete_theory" 6041 [fn () => nm]
		| TSAncestor => fail "icl'delete_theory" 6071 [fn () => nm]
		| TSLocked => fail "icl'delete_theory" 6037 [fn () => nm]
		| TSNormal => 
		if inconsistent
		then error "icl'delete_theory" 6083 []
		else if not(is_nil children)
		then fail "icl'delete_theory" 6076 [fn () => nm]
		else if inscope
		then fail "icl'delete_theory" 6069 [fn () => nm]
		else ();

	val Thy{parents = parents,...} = !contents;

	val ethy = empty_theory thyn [];
in
	current := {hierarchy=hierarchy, theory=theory, ty_env=ty_env,
		con_env=con_env, inconsistent=true,sealed=sealed};
	remove_child thyn parents;
	contents := ethy; (* spec step 3 *)
	update_ia(lookup,thyn,ThyInfo{status = TSDeleted,
		inscope = false,
		contents = contents,
		children = [],
		name = name}); (* spec step 2, 4 *)
	current := {hierarchy=hierarchy, theory=theory, ty_env=ty_env,
		con_env=con_env, inconsistent=false,sealed=sealed}
end);
=TEX
The following creates a new theory, though it does not make it current.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun ‚icl'new_theory· (nm : string) :  int = (
	if (is_theory_name nm)	(* spec. step 1 *)
	then fail "icl'new_theory" 6040 [fn () => nm]
	else let val {hierarchy = hierarchy as hier{lookup=lookup, top_theory=top_theory}, 
		theory=theory, ty_env=ty_env, con_env=con_env, 
		inconsistent=inconsistent,sealed=sealed} = !current;

	val dummy = if inconsistent
		then error "icl'delete_theory" 6083 []
		else ();

	val cthy = icl'get_current_theory_name();

	val ntop_theory = top_theory+1;

	val nthy = ref (empty_theory ntop_theory [cthy]); (* spec. step 2 *)

	val nti = (ThyInfo{status = TSNormal, 
		inscope = false,
		contents = nthy,
		children = [],
		name = nm});

in
	current := {hierarchy=hierarchy, theory=theory, ty_env=ty_env,
		con_env=con_env, inconsistent=true,sealed=sealed};
	update_ia(lookup,ntop_theory,nti); (* spec step 3 *)
	add_child ntop_theory [cthy];
	current := {hierarchy = hier{lookup=lookup, top_theory=ntop_theory},
		theory=theory, ty_env=ty_env, con_env=con_env, 
		inconsistent=inconsistent,sealed=sealed}; (* spec. step 4 *)
	ntop_theory
end
);
=TEX
The following adds a new parent to the current theory.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun ‚icl'new_parent· (nm : string) : int list = (
let 	val dummy = (check_c_writable "icl'new_parent";
	if not(is_theory_name nm)
	then fail "icl'new_parent" 6035 [fn () => nm]
	else  ());

	val fthy = internal_theory_name nm "icl'new_parent";

	val {hierarchy=hierarchy as hier{lookup=lookup, ...}, 
		theory=theory, ty_env=cty_env,
		con_env=ccon_env, inconsistent=inconsistent,sealed=sealed}
		 = !current;

	val ThyInfo{status = fstatus, 
		inscope = finscope,
		contents = fcontents,
		children = fchildren,
		name = fname}
		= sub_ia(lookup, fthy);

	val cthy = icl'get_current_theory_name();

=TEX
The ancestors of the current and parent theories:
=SML
	val fthy_anc = theory_ancestors fthy;
	val cthy_anc = theory_ancestors cthy;
=TEX
A theory is an ancestor of the current one if and only if it is in scope.
=SML
	val dummy = if finscope
		then fail "icl'new_parent" 6082 [fn () => fname]
		else if cthy mem fthy_anc
		then fail "icl'new_parent" 6084 [fn () => fname]
		else ();

	val nfti = (ThyInfo{status = fstatus, 
		inscope = finscope,
		contents = fcontents,
		children = (cthy :: fchildren),
		name = fname});

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;

	val new_thys_in_scope = fthy_anc diff cthy_anc ;
=TEX
The following detects clashes, as well as discovering the new scopes.
=SML
	val (new_ty_env,new_con_env) = ((fold 
		(fn (athy,tece) => add_thy_env (get_theory_contents athy) tece)
		new_thys_in_scope
		(cty_env, ccon_env))
		handle complaint =>
		list_divert complaint "new_parent" [
			("add_ty_env",6067,[fn () => fname]),
			("add_con_env",6067,[fn () => fname])]);

	val new_thy = Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = (fthy :: parents),
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data};
=TEX
Put the new ancestor theories in scope:
=SML
	fun put_in_scope [] = () 
	| put_in_scope (n :: x) = (
	let val ThyInfo{status = astatus, 
		inscope = ainscope,
		contents = acontents,
		children = achildren,
		name = aname} = sub_ia(lookup,n)
	in
		update_ia(lookup,n,ThyInfo{status = astatus, 
			inscope = true,
			contents = acontents,
			children = achildren,
			name = aname})
	end);
in
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
			con_env=ccon_env, inconsistent=true,sealed=sealed};
	put_in_scope new_thys_in_scope;
	add_child cthy [fthy];
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory, ty_env = new_ty_env, 
		con_env=new_con_env, inconsistent=inconsistent,sealed=sealed};
	new_thys_in_scope
end);
=TEX
The following is a function to lock a theory, to make it read-only.
We work by modifying the current hierarchy ``in place''.
=SML
fun ‚icl'lock_theory· (nm : string): unit = (
let 	val thyn = internal_theory_name nm "icl'lock_theory"; (* spec. step 1 *)

	val hier{lookup=lookup, ...} = current_hierarchy();
	
	val ThyInfo{status = status,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name} = sub_ia(lookup,thyn);

	val dummy = case status of
		TSDeleted => error "icl'lock_theory" 6041 []
		| TSAncestor => fail "icl'lock_theory" 6071 [fn () => nm]
		| TSLocked => fail "icl'lock_theory" 6037 [fn () => nm]
		| TSNormal => ();
in
	update_ia(lookup,thyn,ThyInfo{status = TSLocked,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name}) (* spec step 2,3 *)
end);
=TEX
The following is a function to unlock a locked theory, allowing to to be written to once more.
We work by modifying the current hierarchy ``in place''.
=SML
fun ‚icl'unlock_theory· (nm : string): unit = (
let 	val thyn = internal_theory_name nm "icl'unlock_theory"; (* spec. step 1 *)

	val hier{lookup=lookup, ...} = current_hierarchy();
	
	val ThyInfo{status = status,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name} = sub_ia(lookup,thyn);

	val dummy = case status of
		TSDeleted => error "icl'unlock_theory" 6041 []
		| TSAncestor => fail "icl'unlock_theory" 6068 [fn () => nm]
		| TSNormal => fail "icl'unlock_theory" 6068 [fn () => nm]
		| TSLocked => ();
in
	update_ia(lookup,thyn,ThyInfo{status = TSNormal,
		inscope = inscope,
		contents = contents,
		children = children,
		name = name}) (* spec. step 2,3 *)
end);
=TEX
The following is a function to create a duplicate theory, except it has no children.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun ‚icl'duplicate_theory· (fromnm : string) (tonm : string) :  int = (
let 	val {hierarchy = hierarchy as hier{lookup=lookup, top_theory=top_theory},
		theory=theory, ty_env=cty_env, con_env=ccon_env, 
		inconsistent=inconsistent,sealed=sealed} = !current;

	val dummy = if inconsistent
		then error "icl'duplicate_theory" 6083 []
		else if (is_theory_name tonm)
		then fail "icl'duplicate_theory" 6040 [fn () => tonm]
		else ();

	val fromn = internal_theory_name fromnm "icl'duplicate_theory";

	val ntop_theory = top_theory+1;

	val ThyInfo{status = status1,
		inscope = inscope1,
		contents = contents1,
		children = children1,
		name = name1}
		= sub_ia(lookup,fromn);

	val Thy{name = frname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !contents1;

	val dummy = if frname <> fromn
		then error "icl'duplicate_theory" 6041 []
		else ();

	val tothy = ref (Thy{name = ntop_theory,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = ref(!user_data)});

	val toti = (ThyInfo{status = TSNormal, 
		inscope = false,
		contents = tothy,
		children = [],
		name = tonm});
in
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=true,sealed=sealed};
	update_ia(lookup,ntop_theory,toti);
	add_child ntop_theory parents;
	current := {hierarchy = hier{lookup=lookup, top_theory=ntop_theory},
		theory=theory, ty_env=cty_env, con_env=ccon_env, inconsistent=inconsistent,sealed=sealed};
	ntop_theory
end);
=TEX	

\subsection{Operations on Theory Contents}
The first two functions of this section have no specification.
The rest of the functions follow the specification of \cite{DS/FMU/IED/SPC005}.

Get a theory's contents, by string name:
=SML
fun ‚icl'get_theory· (nm : string) : THEORY = (
let 	val iname = internal_theory_name nm "icl'get_theory"
	val Thy gthy = get_theory_contents iname
in
	gthy
end);
=TEX
Get the current theory's status:
=SML
fun  ‚get_current_theory_status· (() : unit) = (
let 	val {hierarchy = hier{lookup=lookup,...}, theory = theory, ...} = !current;

	val Thy{name = iname,...} = !theory;

	val (ThyInfo{status = status,...}) = sub_ia(lookup, iname);
in
	status
end);
=TEX
Give the sequent of a theorem:
=SML
fun ‚dest_thm· (Thm{sequent=sequent,...} : THM) : SEQ = sequent;
=TEX
Give a user presentation of a theorem:
=SML
fun ‚icl'dest_thm· (Thm{level = level, theory=theory, sequent = sequent}:THM) :
	{level : int, theory : THEORY, sequent : SEQ} = (
let 	val Thy thry = !theory
in
	{level=level, theory = thry, sequent = sequent}
end);
=TEX

Save a theorem under a list of keys:
=SML
fun ‚icl'list_save_thm· (keys : string list, 
	theorem : THM as Thm {level = level, theory=theory, sequent = sequent}) : THM = (
let 	val dummy = (check_thm "icl'list_save_thm" theorem;
		if not (wf_seq sequent)
		then fail "icl'list_save_thm" 6038 []
		else if keys = []
		then fail "icl'list_save_thm" 6031 []
		else check_c_writable "icl'list_save_thm"); (* part of spec. step 2 *)

	val {theory = ctheory,...} = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !ctheory; (* spec. step 1 *)
=TEX
The definition level of the saved theorem is 0 if it is from
an ancestor theory, as described in the specification.
=SML
	val new_thm = Thm{level = if (theory = ctheory)
			then current_level
			else 0,
		theory = ctheory,
		sequent = sequent};
=TEX
We test that all the keys are new (part of spec. step 2) at the same time as 
adding new entries to the dictionary, by using $s\_extend$
(spec. step 3).
=SML
	val new_thm_dict = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			s_extend key new_thm dct
			handle complaint =>
			divert complaint "s_extend" "icl'list_save_thm" 6039
		 [(fn () => key),
		  (fn () => get_current_theory_name())])
		keys)
		thm_dict);

	val new_thy = Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = new_thm_dict,
		current_level = current_level,
		user_data = user_data}
in
	ctheory := new_thy; (* spec. step 4 *)
	new_thm
end);
=TEX
The following is a function to delete the last extension to the current theory.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun ‚icl'delete_extension· (():unit) : int = (
let 	val {hierarchy = hierarchy as hier{lookup=lookup, ...}, 
		theory=theory, ty_env=cty_env, con_env=ccon_env, 
		inconsistent=inconsistent,sealed=sealed} = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;

	val ThyInfo{children = children, name = ename,...} = sub_ia(lookup,iname);

	val dummy = (check_c_writable "icl'delete_extension"; (* spec. step 1 *)
		if children <> []
		then fail "icl'delete_extension" 6076 [fn x=>ename]
		else ());
=TEX
We want the last level at which something was defined
(specification step 2).
All the following lists are always manipulated such that their head
will be the last declaration of their kind.
N.B. this does not hold true of $thm\_dict$,
as it may save theorems from other theories at level 0.

In the following $ll\_def$ should always be less than or equal $ll\_con$, but we check, just in case.
=SML
	val ll_type = case ty_env of
		[] => 0
		| ((_,{level=llt,...})::_) => llt;
	val ll_con = case con_env of
		[] => 0
		| ((_,{level=llc,...})::_) => llc;
	val ll_def = case defn_dict of
		[] => 0
		| ((_,Thm{level=lld,...})::_) => lld;
	val ll_axiom = case axiom_dict of
		[] => 0
		| ((_,Thm{level=lla,...})::_) => lla;

	val last_level = list_max[ll_type, ll_con, ll_def, ll_axiom];

	val dummy = (
		if last_level = 0
		then fail "icl'delete_extension" 6050 [fn () => ename]
		else if (any thm_dict (fn (_,Thm{level=ll,...}) => 
			ll >= last_level))
		then fail "icl'delete_extension" 6077 
			[(fn () => ename),
			(fn () => let val (key,_) = (find thm_dict 
				(fn (_,Thm{level=ll,...}) =>
				 ll >= last_level))
				in key end)]
		else ());

	val new_del_levels = extend_range (last_level, current_level) del_levels;
=TEX
The following deletion, specification step 3, depends upon the implementation of simple
dictionaries.
We delete anything made between $last\_level$ and $current\_level$
(there should only be things {\bf at} the current level,
but we are very cautious).
=SML
	val new_ty_env=ty_env drop (fn (_,{level=ll,...}) => ll >= last_level);

	val new_cty_env = del_ty_env (ty_env drop (fn (_,{level=ll,...}) => ll < last_level))
		cty_env;

	val new_con_env=con_env drop (fn (_,{level=ll,...}) => ll >= last_level);

	val new_ccon_env = del_con_env(con_env drop (fn (_,{level=ll,...}) => ll < last_level))
		ccon_env;

	val new_axiom_dict = axiom_dict drop 
		(fn (_,Thm{level=ll,...}) => ll >= last_level);

	val new_defn_dict = defn_dict drop 
		(fn (_,Thm{level=ll,...}) => ll >= last_level);

	val new_thy = Thy{name = iname,
		ty_env = new_ty_env,
		con_env = new_con_env,
		parents = parents,
		del_levels = new_del_levels,
		axiom_dict = new_axiom_dict,
		defn_dict = new_defn_dict,
		thm_dict = thm_dict,
		current_level = current_level+1,
		user_data = user_data};
in
=TEX
Note that the current theory address doesn't change, only the contents of the location pointed to.
=SML
	current := {hierarchy=hierarchy, theory=theory,
		ty_env=cty_env, con_env=ccon_env,
		inconsistent=true,sealed=sealed};
	theory := new_thy; (* spec. step 4 *)
	current := {hierarchy=hierarchy, theory=theory,
		ty_env=new_cty_env, con_env=new_ccon_env,
		inconsistent=inconsistent,sealed=sealed};
	last_level
end);
=TEX
Delete a named theorem from the current theory:
=SML
fun ‚icl'delete_thm· (key : string) : THM = (
let 	val {theory=theory, inconsistent=inconsistent,...} = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;

	val dummy = check_c_writable "icl'delete_thm"; (* spec. step 1 *)

	val dthm = (force_value(s_lookup key thm_dict)
		handle complaint =>
		divert complaint "force_value" "icl'delete_thm" 6046 [
				fn x => key,
				fn x => get_current_theory_name()]);

	val new_thm_dict = s_delete key thm_dict; (* spec step 2 *)

	val new_thy = Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = new_thm_dict,
		current_level = current_level,
		user_data = user_data}
in
	theory := new_thy;
	dthm
end);
=TEX 
Add an axiom to the current theorem:
=SML
fun ‚icl'new_axiom· (keys : string list, tm : TERM) : THM = (
let 	val {theory=theory,...} = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;
	
	val dummy = (check_c_writable "icl'new_axiom" ;
		if keys = []
		then fail "icl'new_axiom" 6031 []
		else if type_of tm <> BOOL
		then fail "icl'new_axiom" 6009 []
		else if wf_term tm
		then ()
		else fail "icl'new_axiom" 6048 [fn () => get_current_theory_name ()]); 
			(* spec step 1 *)

	val new_axiom = Thm{level = current_level+1, 
		theory=theory, 
		sequent = ([], tm)}; (* spec step 2,3 *)
=TEX
We both check for an unused key (part of specification step 1 *), and insert a new entry in the dictionary by using $s\_extend$.
=SML
	val new_axiom_dict = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			s_extend key new_axiom dct
			handle complaint =>
			divert complaint "s_extend" "icl'new_axiom" 6047 
			[(fn () => key), 
			 (fn () => get_current_theory_name ())])
		keys)
		axiom_dict);

	val new_thy = Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = new_axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level+1,
		user_data = user_data}
in
	theory := new_thy; (* spec step 4 *)
	new_axiom
end);
=TEX
\subsubsection{Definitional Mechanisms}
These functions follow the specification of \cite{DS/FMU/IED/SPC005}.
The following five functions follow the pattern of the
definitional mechanisms of the specification.

The following is a function to add a new constant to the theory.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun ‚icl'new_const· (nm : string, ty : TYPE) : TERM = (
let 	val {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=inconsistent,sealed=sealed} = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;
	
	val dummy = (check_c_writable "icl'new_const";
		if not(wf_type ty)
		then fail "icl'new_const" 6075 [fn () => get_current_theory_name ()]
		else (case const_in_anc_or_des nm of
		InScope => fail "icl'new_const" 6049 [fn () => nm]
		| InDescendant => fail "icl'new_const" 6063 [fn () => nm]
		| NotPresent => ())); 
		
	val new_const = mk_const(nm,ty);

	val con_decl = {ty=ty,level=current_level+1};

	val new_con_env = s_extend nm con_decl con_env;

	val new_thy = Thy{name = iname,
		ty_env = ty_env,
		con_env = new_con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level+1,
		user_data = user_data};

	val new_ccon_env = add_con_env [ (nm,con_decl)] ccon_env;
in
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=true,sealed=sealed};
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=new_ccon_env, inconsistent=inconsistent,sealed=sealed};
	new_const
end);
=TEX
The following is a function to add a new type to the theory.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
=SML
fun ‚icl'new_type· (nm : string, arity : int) : TYPE = (
let 	val {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=inconsistent,sealed=sealed} = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;
	
	val dummy = (check_c_writable "icl'new_type";
		(case type_in_anc_or_des nm of
		InScope => fail "icl'new_type" 6045 [fn () => nm]
		| InDescendant => fail "icl'new_type" 6034 [fn () => nm]
		| NotPresent => 
		if arity < 0 
		then fail "icl'new_type" 6088 []
		else ()));
		
	val new_type = mk_type(nm,ntyvars arity);

	val type_decl = {arity=arity,level=current_level+1};

	val new_ty_env = s_extend nm type_decl ty_env;

	val new_thy = Thy{name = iname,
		ty_env = new_ty_env,
		con_env=con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level+1,
		user_data = user_data};

	val new_cty_env = add_ty_env [(nm,type_decl)] cty_env; 
in
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=true,sealed=sealed};
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory, ty_env = new_cty_env, 
		con_env=ccon_env, inconsistent=inconsistent,sealed=sealed};
	new_type
end);
=TEX
The following is a function to declare a new, named, constant to be equal to some term.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
Note that the function assumes the presence of $=$ as a valid constant.
=SML
fun ‚icl'new_defn· (keys : string list, cnm : string, vl : TERM) : THM = (
let 	val {hierarchy=hierarchy, theory=theory, ty_env=cty_env,
		 con_env=ccon_env, inconsistent=inconsistent,sealed=sealed} = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;

	val ctype = type_of vl;
=TEX
Do the checks required (other than on keys):
=SML
	val dummy = (check_c_writable "icl'new_defn";
		(case const_in_anc_or_des cnm of
		InScope => fail "icl'new_defn" 6049 [fn () => cnm]
		| InDescendant => fail "icl'new_defn" 6063 [fn () => cnm]
		| NotPresent => ());
		if keys = []
		then fail "icl'new_defn" 6031 []
		else if not (wf_term vl)
		then fail "icl'new_defn" 6048 [fn () => get_current_theory_name()]
		else if not(is_nil (frees vl))
		then fail "icl'new_defn" 6059 
			[fn () => format_list (fst o dest_var) (frees vl) ", "]
		else if not(is_nil((term_tyvars vl) diff (type_tyvars ctype)))
		then fail "icl'new_defn" 6058 
			[fn () => format_list (Combinators.I) 
			 ((term_tyvars vl) diff (type_tyvars ctype)) ", "]

		else ()
		);
=TEX
Now build up the new material:
=SML
	val new_const = mk_const(cnm,ctype);

	val con_decl = {ty=ctype,level=current_level+1};

	val new_con_env = s_extend cnm con_decl con_env;

	val new_ccon_env = add_con_env [ (cnm,con_decl)] ccon_env;

	val new_defn = Thm{level = current_level+1, 
		theory=theory, 
		sequent = ([], mk_eq(new_const, vl))};

	val new_defn_dict = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			s_extend key new_defn dct
			handle complaint =>
			divert complaint "s_extend" "icl'new_defn" 6051 
			[(fn () => key), 
			 (fn () => get_current_theory_name())])
		keys)
		defn_dict);

	val new_thy = Thy{name = iname,
		ty_env = ty_env,
		con_env = new_con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = new_defn_dict,
		thm_dict = thm_dict,
		current_level = current_level+1,
		user_data = user_data};
in
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=true,sealed=sealed};
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=new_ccon_env, inconsistent=inconsistent,sealed=sealed};
	new_defn
end);
=TEX
The following is a function to introduce a new type definition.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
Note that the function assumes the presence of $TypeDefn$ and $Ñ$ as valid constants.
=SML
fun ‚icl'new_type_defn· (keys : string list, tnm : string, 
		typars : string list,
		defthm : THM as Thm{sequent = (hyps, concl),...}) : THM = (
let 	val {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=inconsistent,sealed=sealed} = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;
=TEX
Do the checks required (other than on keys):
=SML
	val dummy = (check_c_writable "icl'new_type_defn";
		(case type_in_anc_or_des tnm of
		InScope => fail "icl'new_type_defn" 6045 [fn () => tnm]
		| InDescendant => fail "icl'new_type_defn" 6034 [fn () => tnm]
		| NotPresent => ());
		check_thm "icl'new_type_defn" defthm;
		if not(wf_seq (hyps, concl))
		then fail "icl'new_type_defn" 6087 [fn () => get_current_theory_name()]
		else if keys = []
		then fail "icl'new_type_defn" 6031 []
		else if hyps <> []
		then fail "icl'new_type_defn" 6053 []
		else if not(is_nil (frees concl))
		then fail "icl'new_type_defn" 6056 
			[fn () => format_list (fst o dest_var) (frees concl) ", "]
		else if not(is_nil((term_tyvars concl) diff typars))
		then fail "icl'new_type_defn" 6057
			[fn () => format_list (Combinators.I) ((term_tyvars concl) diff typars) ", "] 
		else if not(all_different typars)
		then fail "icl'new_type_defn" 6079 
			[fn () => two_the_same typars]
		else ());
=TEX
Now build up the new material:
=SML
	val (x,(p, x1)) = (Combinators.I ** dest_comb)(simple_dest_Ñ concl)
		handle complaint =>
		list_divert complaint "icl'new_type_defn"
			[("dest_comb", 6055,[]),
			 ("simple_dest_Ñ", 6054, [])];

	val dummy = if not(x=x1)
		then fail "icl'new_type_defn" 6080 []
		else ();

	val arity = length typars;

	val new_type = mk_type(tnm, map mk_vartype typars);

	val ftype = mk_fun(new_type, type_of x);

	val f = mk_var("f",ftype); (* cannot be present in p, from frees test *)

	val td = mk_const("TypeDefn",mk_fun(type_of p,
		mk_fun(ftype, BOOL)));

	val seq_concl = simple_mk_Ñ(f, list_mk_comb (td, [p, f]));

	val new_type_defn = Thm{level = current_level+1, 
		theory=theory, 
		sequent = ([], seq_concl)};

	val ty_decl = {arity = arity,level=current_level+1};

	val new_ty_env = s_extend tnm ty_decl ty_env;

	val new_cty_env = add_ty_env [ (tnm,ty_decl)] cty_env;

	val new_defn_dict = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			s_extend key new_type_defn dct
			handle complaint =>
			divert complaint "s_extend" 
				"icl'new_type_defn" 6052
				 [(fn () => key),
				 (fn () => get_current_theory_name())])
		keys)
		defn_dict);

	val new_thy = Thy{name = iname,
		ty_env = new_ty_env,
		con_env=con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = new_defn_dict,
		thm_dict = thm_dict,
		current_level = current_level+1,
		user_data = user_data};
in
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=true,sealed=sealed};
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory, ty_env=new_cty_env, 
		con_env=ccon_env, inconsistent=inconsistent,sealed=sealed};
	new_type_defn
end);
=TEX
The following is a function to introduce a new specification.
Interrupting the body of the main $let$ statement may leave the state with the $inconsistent$ flag set.
Note that this function examines theorems involving $Ñ$,
through there is no guarantee of this constant being present yet.
=SML
fun ‚icl'new_specification· (keys : string list, ndef : int, 
	defthm : THM as Thm{sequent = (hyps, concl),...}) : THM = (
let 	val {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=inconsistent,sealed=sealed} = !current;

	val Thy{name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} = !theory;
=TEX
Do the checks required (other than on keys, and theorem form):
=SML
	val dummy = (check_c_writable "icl'new_specification";
		check_thm "icl'new_specification" defthm;
		if not(wf_seq (hyps, concl))
		then fail "icl'new_specification" 6087 
			[fn () => get_current_theory_name()]
		else if keys = []
		then fail "icl'new_specification" 6031 []
		else if not(is_nil (frees concl))
		then fail "icl'new_specification" 6056	
			[fn () => format_list (fst o dest_var) (frees concl) ", "]

		else if ndef < 1
		then fail "icl'new_specification" 6044 []
		else if hyps <> []
		then fail "icl'new_specification" 6053 []
		else ()
		);
=TEX
Now build up the new material:
=SML
	fun nexists (n:int) (tm : TERM) (res : TERM list) : (TERM list * TERM) = (
		if n = 0 
		then (res, tm)
		else (let val (x,bdy) = simple_dest_Ñ tm
			handle complaint =>
			divert complaint "simple_dest_Ñ" "icl'new_specification" 
			6060 [fn () => string_of_int ndef]
		in
			nexists (n-1) bdy (res @ [x])
		end)
	);

	val (xlist, bdt) = nexists ndef concl [];

	val xtyvars = term_tyvars(hd xlist);
=TEX
Check the results of picking apart the theorem:
=SML
	val dummy = (if any (tl xlist) (fn x => not((term_tyvars x) set_eq xtyvars)) 
		then fail "icl'new_specification" 6081 []
		else if ((term_tyvars bdt) diff xtyvars) <> []
		then fail "icl'new_specification" 6061
			[fn () => format_list (Combinators.I) 
			 ((term_tyvars concl) diff xtyvars) ", "]
		else if not(all_different xlist)
		then fail "icl'new_specification" 6016 
			[fn () => fst(dest_var(two_the_same xlist))]
		else ();
		map (fn x =>
			let val (cnm,ty) = dest_var x
			in
			(case const_in_anc_or_des cnm of
			InScope => fail "icl'new_specification" 6049 [fn () => cnm]
			| InDescendant => fail "icl'new_specification" 6063 [fn () => cnm]
			| NotPresent => ())
			end)
		xlist;
		());

	val new_consts = map (fn x => mk_const(dest_var x)) xlist;

	val new_current_level = current_level+1;

	val con_decl = map (fn x => let val(cnm,ty) = dest_var x
			in
			(cnm,{ty=ty,level=new_current_level})
			end)
		xlist;

	val new_con_env = fold 
		(fn ((cnm,entry),edict) => s_extend cnm entry edict)
		 con_decl con_env;

	val new_ccon_env = add_con_env con_decl ccon_env;

	val new_concl = subst(combine new_consts xlist) bdt;
=TEX
Now put everything in the correct place:
=SML
	val new_defn = Thm{level = current_level+1, 
		theory=theory, 
		sequent = ([], new_concl)};

	val new_defn_dict = (fold (fn (x,y) => x y)
		(map (fn key => fn dct =>
			s_extend key new_defn dct
			handle complaint =>
			divert complaint "s_extend" "icl'new_specification" 6051 
				[(fn () => key),
				(fn () => get_current_theory_name())])

		keys)
		defn_dict);

	val new_thy = Thy{name = iname,
		ty_env = ty_env,
		con_env = new_con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = new_defn_dict,
		thm_dict = thm_dict,
		current_level = current_level+1,
		user_data = user_data};
in
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=ccon_env, inconsistent=true,sealed=sealed};
	theory := new_thy;
	current := {hierarchy=hierarchy, theory=theory, ty_env=cty_env, 
		con_env=new_ccon_env, inconsistent=inconsistent,sealed=sealed};
	new_defn
end);
=TEX
=SML 
fun ‚get_const_type· (nm : string) : TYPE OPT = (
	case (get_con_env nm) of
	Value {ty = ty,...} => Value ty
	| _ => Nil
);
=TEX
=SML
fun ‚get_type_arity· (nm : string) : int OPT = (
	case (get_ty_env nm) of
	Value {arity=arity,...} => Value arity
	| _ => Nil
);
=TEX

\section{PRIMITIVE INFERENCE RULES OF ADT THM}
The functions in this section, other than the utilities, follow the specifications of
\cite{DS/FMU/IED/SPC003} and \cite{DS/FMU/IED/SPC004}.
\subsection{Utilities}
Do union up to $\alpha$-conversion:
Give the frees of a list of terms:
=SML
val ‚list_frees· = list_cup o map frees;
=TEX
Then provide a test for being free in a list of terms:
=SML
fun ‚list_is_free_in· (x:TERM) (tms:TERM list) : bool = (
	any tms (fn p => is_free_in x p)
);
=TEX
Create a theorem from a sequent of the current theory and current definition level:
=SML
fun ‚mk_current_thm·(seq : SEQ) : THM = (
let	val {theory = theory,...} = !current;

	val Thy{current_level = current_level,...} = !theory;

in
	Thm{theory = theory, level = current_level, sequent = seq}
end);
=TEX

\subsection{icl'subst\_rule}
This function partially evaluates with one or two arguments.
=RULE
icl'subst_rule
…
[ˆ1 Ö t1=t1', ... , ˆn Ö tn=tn']
ˆ Ö t[t1,...tn]
…
ˆ1 ° ... ˆn ° ˆ Ö t[t1',...tn']
=TEX
The following local function takes the input list and hypotheses to $icl'subst\_rule$, and returns the 
substitution lists for $var\_subst$, as well as the 
new assumption list.
=SML
local 
	fun two_subst_lists (lhslst : (TERM * TERM) list)
		(rhslst : (TERM * TERM) list)
		(new_hyps : TERM list) 
		([] : (THM * TERM) list) :
		(((TERM * TERM) list) * ((TERM * TERM) list) * (TERM list)) = (
		lhslst, rhslst, new_hyps
	) | two_subst_lists lhslst rhslst new_hyps ((thmi,vari) :: lst) = (
	let val (nhyps,(lhsi,rhsi)) = (((Combinators.I ** dest_eq)(dest_thm thmi))
		handle complaint =>
		divert complaint "dest_eq" "icl'subst_rule" 6002 []);
	in
		if not(is_var vari)
		then fail "icl'subst_rule" 6003 []
		else if type_of lhsi <> type_of vari
		then fail "icl'subst_rule" 6029 
			[fn () => fst(dest_var vari)]
		else (two_subst_lists ((lhsi, vari) :: lhslst)
			((rhsi, vari) :: rhslst)
			(nhyps term_union new_hyps)
			lst)
	end);
in
=TEX
Main function:
=SML
fun ‚icl'subst_rule· (thm_var_list : (THM * TERM) list):
	TERM -> THM -> THM = (
	if is_nil thm_var_list
	then (
=TEX
We optimize for the special case of an empty $thm\_var\_list$, which is just returing a theorem that is $\alpha$-convertible to the input:
=SML
		(fn (template : TERM) => 
		(fn (ithm as Thm{sequent = (hyps,concl),...}) =>
		let val dummy = check_thm "icl'subst_rule" ithm;
		in
			if aconv concl template
			then mk_current_thm(hyps, template)
			else fail "icl'subst_rule" 6001 []
		end))
	)
=TEX
We now consider doing a full substitution.
Create (while checking) two lists, one of $lhs_i\ â\ var_i$,
one of $rhs_i\ â\ var_i$, as well as accumulating the hypotheses of the theorems used; 
create two terms, $lhs$ and $rhs$, from $template$,
one by the $lhs$ substitutions, the other by the $rhs$;
if the $lhs$ is $\alpha$-convertible to $concl$, then
return the theorem that the $rhs$ term is true.
=SML
	else (
	let val (lhssubs, rhssubs, new_hyps) = two_subst_lists [] [] [] thm_var_list;
	in
	(fn (template : TERM) => let
		val template_as_lhs = var_subst lhssubs template;
		val template_as_rhs = var_subst rhssubs template;
	in
	(fn (ithm as Thm{sequent = (hyps,concl),...}) =>
		let val dummy = (check_thm "icl'subst_rule" ithm;
			map (check_thm "icl'subst_rule" o fst) thm_var_list);
		in
			if aconv concl template_as_lhs
			then mk_current_thm(hyps term_union new_hyps, template_as_rhs)
			else fail "icl'subst_rule" 6001 []
		end
	)
	end
	)
	end
	)
); (* end of if..then...else... *)
end; (* of local fun two_subst_lists ... *)
=TEX
\subsection{icl'simple\_abs\_rule}
=RULE
icl'simple_abs_rule
ªxº
…
ˆ Ö t1[x] = t2[x]
…
ˆ Ö (ç x é t1[x]) = (ç x é t2[x])
=TEX
And:
=RULE
icl'simple_abs_rule
ªxº
…
ˆ Ö t1[x] Ç t2[x]
…
ˆ Ö (ç x é t1[x]) = (ç x é t2[x])
=TEX
=SML
fun ‚icl'simple_abs_rule· (absvar : TERM) 
	(thrm as Thm{sequent = (hyps, concl),...} : THM) 
	: THM = (
let 	val (absvarnm, absvarty) = (dest_var absvar
		handle complaint =>
		divert complaint "dest_var" "icl'simple_abs_rule" 6004 []);

	val dummy = (check_thm "icl'simple_abs_rule" thrm;
		if list_is_free_in absvar hyps
		then fail "icl'simple_abs_rule" 6005 [fn () => absvarnm]
		else ());

	val (lhs,rhs) = (dest_eq concl
		handle complaint =>
		divert complaint "dest_eq" "icl'simple_abs_rule" 6025 []);
in
	mk_current_thm (hyps, 
		mk_eq(simple_mk_abs(absvar, lhs),simple_mk_abs(absvar, rhs)))
end);
=TEX
\subsection{icl'inst\_type\_rule}
=RULE
icl'inst_type_rule
[(˛1, tyv1), ..., (˛n,tyvn)]
…
ˆ Ö t[tyv1,...tyvn]
…
ˆ Ö t[˛1,...˛n]
=TEX
=SML
fun  ‚icl'inst_type_rule· (talist: (TYPE * TYPE) list)
	(thrm : THM as Thm{sequent = (hyps, concl),...}) : THM = (
let 	val dummy = check_thm "icl'inst_type_rule" thrm;

	val usingtvs : string list = map (fn (t,tv) => (dest_vartype tv
		handle complaint =>
		divert complaint "dest_vartype" "icl'inst_type_rule" 6007 []))
		talist;

	val dummy = if any hyps (fn x => any (term_tyvars x)
			(fn y => y mem usingtvs))
		then fail "icl'inst_type_rule" 6006 
			[fn () => (find (term_tyvars (find hyps (fn x => any (term_tyvars x)
			(fn y => y mem usingtvs))))
			(fn y => y mem usingtvs))]
		else ();
in
	mk_current_thm(hyps, inst (list_frees hyps) talist concl)
end);
=TEX
\subsection{icl'ä\_intro}
=RULE
icl'ä_intro
ªt1º
…
ˆ Ö t2
…
ˆ - {t1} Ö t1 ä t2
=TEX
=SML
fun ‚icl'ä_intro· (asm : TERM) (thrm : THM as Thm{sequent = (hyps,concl),...}) : THM = (
let 	val dummy = (check_thm "icl'ä_intro" thrm;
	if type_of asm <> BOOL
	then fail "icl'ä_intro" 6009 []
	else ());
in
	mk_current_thm(hyps term_less asm, mk_ä(asm, concl))
end);
=TEX
\subsection{icl'ä\_elim}
=RULE
icl'ä_elim
…
ˆ1 Ö t1 ä t2; ˆ2 Ö t1'
…
ˆ1 ° ˆ2 Ö t2
=TEX
=SML
fun ‚icl'ä_elim· (thrm1 : THM as Thm{sequent = (hyps1,concl1),...})
	(thrm2 : THM as Thm{sequent = (hyps2,concl2),...}) : THM = (
let 	val dummy = (check_thm "icl'ä_elim" thrm1;
		check_thm "icl'ä_elim" thrm2);

	val (hconcl1,cconcl1) = (dest_ä concl1 
		handle complaint =>
		divert complaint "dest_ä" "icl'ä_elim" 6010 []);
in
	if aconv hconcl1 concl2
	then mk_current_thm(hyps1 term_union hyps2, cconcl1)
	else fail "icl'ä_elim" 6011 []
end);
=TEX
\subsection{icl'asm\_rule}
=RULE
icl'asm_rule
ªtº
…
…
t Ö t
=TEX
=SML
fun ‚icl'asm_rule· (tm : TERM) : THM = (
	if type_of tm = BOOL
	then mk_current_thm([tm],tm)
	else fail "icl'asm_rule" 6009 []
);
=TEX
\subsection{icl'refl\_conv}
=RULE
icl'refl_conv
ªtº
…
…
Ö t = t
=TEX
Or, if $t$ is boolean:
=RULE
icl'refl_conv
ªtº
…
…
Ö t Ç t
=TEX
=SML
val ‚icl'refl_conv· : CONV = (fn (tm : TERM) =>
	mk_current_thm([],mk_eq(tm,tm))
);
=TEX
\subsection{icl'simple\_$\beta$\_conv}
=CONVERSION
icl'simple_%beta%_conv
ª(ç x é t1[x]) t2º
…
…
Ö (ç x é t1[x]) t2 = t1[t2]
=TEX
Or, if the term is of type $BOOL$:
=CONVERSION
icl'simple_%beta%_conv
ª(ç x é t1[x]) t2º
…
…
Ö (ç x é t1[x]) t2 Ç t1[t2]
=TEX
=SML
val ‚icl'simple_%beta%_conv· : CONV = (fn (tm : TERM) =>
let 	val ((vr, t1), t2) = ((simple_dest_abs ** Combinators.I)(dest_comb tm)
		handle complaint =>
		list_divert complaint "icl'simple_%beta%_conv"
			[("simple_dest_abs",6012,[]),
			("dest_comb",6012,[])]);

	val rhs = var_subst [(t2,vr)] t1;
in
	mk_current_thm([],mk_eq(tm,rhs))
end);
=TEX
\subsection{icl'suc\_conv}
We have no specification for this.
=RULE
icl'suc_conv
(mk_Ü (m+1))
…
…
Ö ^(mk_Ü(m+1)) = Suc ^(mk_Ü m)
=TEX
=RULE
icl'suc_conv
(mk_Ü 0)
…
…
Ö 0 = Zero
=TEX
The following inference rule relies on the well-formedness of the following constants.
=SML
local
	val ‚Suc· = mk_const("Suc",mk_fun(Ü, Ü));
	val ‚Zero· = mk_const("Zero", Ü);
in
=TEX
=SML
val ‚icl'suc_conv· : CONV = (fn (tm : TERM) =>
let	val nint = (dest_Ü tm
		handle complaint =>
		divert complaint "dest_Ü" "icl'suc_conv" 6013 []);

	val rhs = if nint = 0
		then Zero
		else mk_comb(Suc, mk_Ü (nint - 1));
in
	mk_current_thm([],mk_eq(tm,rhs))
end);
end;
=TEX
\subsection{icl'string\_conv}
We have no specification for this.
=RULE
icl'string_conv
(mk_string ("c" :: t))
…
…
Ö ^(mk_string("c" :: t)) = 
Cons ^(mk_char("c")) ^(mk_string(t))
=TEX
Or:
=RULE
icl'string_conv
(mk_string "")
…
…
Ö ^(mk_string("")) = Nil
=TEX
The following inference rule relies on the well-formedness of the following constants.
=SML
local
	val SCons = mk_const("Cons",mk_fun(CHAR, mk_fun(STRING, STRING)));
	val SNil = mk_const("Nil", STRING);
in
val ‚icl'string_conv· : CONV = (fn (tm : TERM) =>
let 	val sex = explode(dest_string tm)
		handle complaint =>
		divert complaint "dest_string" "icl'string_conv" 6014 [];

	val rhs = if sex = []
		then SNil
		else list_mk_comb(SCons,
			[mk_char(hd sex),
			mk_string(implode (tl sex))]);

in
	mk_current_thm([],mk_eq(tm,rhs))
end);
end;
=TEX
\subsection{icl'char\_conv}
We have no specification for this.
=RULE
icl'char_conv
(mk_char("c"))
…
…
Ö ^(mk_char("c")) = AbsChar ^(ord "c")
=TEX
The following inference rule relies on the well-formedness of the following constant.
=SML
local 
	val AbsChar = mk_const("AbsChar",mk_fun(Ü,CHAR));
in
val ‚icl'char_conv· : CONV = (fn (tm : TERM) =>
let 	val cnum = ord(dest_char tm)
		handle complaint =>
		divert complaint "dest_char" "icl'char_conv" 6015 [];
	
	val rhs = mk_comb(AbsChar, mk_Ü cnum);
in
	mk_current_thm([],mk_eq(tm,rhs))
end);
end;
=TEX
\section{BUILT-IN INFERENCE RULES OF ADT $THM$}
The inference rules in this section are justified by
the informal reasoning given in \cite{DS/FMU/IED/DTD006}.
They should mimic the end results of the reasoning stated there, for any acceptable input.
\subsection{icl'eq\_sym\_rule}
=RULE
icl'eq_sym_rule
…
ˆ Ö t1 = t2
…
ˆ Ö t2 = t1
=TEX
And:
=RULE
icl'eq_sym_rule
…
ˆ Ö t1 Ç t2
…
ˆ Ö t2 Ç t1
=TEX
=SML
fun ‚icl'eq_sym_rule· (thrm : THM as Thm{sequent = (hyps,concl),...}) : THM = (
let 	val dummy = check_thm "icl'eq_sym_rule" thrm;

	val (lhs_concl,rhs_concl) = (dest_eq concl
		handle complaint =>
		divert complaint "dest_eq" "icl'eq_sym_rule" 6025 []);

	val new_concl = mk_eq(rhs_concl, lhs_concl);
in
	mk_current_thm(hyps, new_concl)
end);
=TEX
\subsection{icl'simple\_list\_É\_elim}
=RULE
icl'simple_list_É_elim
[...,ªt1º,...]
…
ˆ Ö É ...x... é t2[...,xn,...]
…
ˆ Ö t2'[...,tn,...]
=TEX
In the following, when creating the local variable $subs$, of substitutions
to be carried out, we reverse the order of the list so that
if there are two nested quantifiers with the same variable,
the inner quantifier's instantiation has effect, and the
outer one is ignored.
=SML
local
	fun simple_n_É 0 acc tm = (acc,tm)
	| simple_n_É n acc tm = (
	let val (v,bdy) = simple_dest_É tm
	in
		simple_n_É (n-1) (acc @ [v]) bdy
	end);

	fun type_fails [] = ""
	| type_fails ((tm,v):: rest) = (
		if type_of tm <> type_of v
		then (fst(dest_var v) ^" " ^ type_fails rest)
		else type_fails rest);
in
fun ‚icl'simple_list_É_elim· (tml : TERM list) 
	(thrm : THM as Thm{sequent = (hyps,concl),...}) : THM = (
let 	val dummy = check_thm "icl'simple_list_É_elim" thrm;

	val ninsts = length tml;
	
	val (bvl, bdy) = (simple_n_É ninsts [] concl
		handle complaint =>
		divert complaint "simple_dest_É" "icl'simple_list_É_elim" 6018 [fn () => string_of_int ninsts]);

	val subs = rev(combine tml bvl);

	val new_concl = (var_subst subs bdy
		handle complaint =>
		divert complaint "var_subst" "icl'simple_list_É_elim" 6019 [fn () => type_fails subs]);
in
	mk_current_thm(hyps, new_concl)
end);
end; (* local fun simple_n_É = *)
=TEX
\subsection{icl'eq\_trans\_rule}
=RULE
icl'eq_trans_rule
…
ˆ1 Ö t1 = t2; ˆ2 Ö t2' = t3
…
ˆ1 ° ˆ2 Ö t3
=TEX
And:
=RULE
icl'eq_trans_rule
…
ˆ1 Ö t1 Ç t2; ˆ2 Ö t2' Ç t3
…
ˆ1 ° ˆ2 Ö t1 Ç t3
=TEX
=SML
fun ‚icl'eq_trans_rule· (thrm1 : THM as Thm{sequent = (hyps1,concl1),...})
	(thrm2 : THM as Thm{sequent = (hyps2,concl2),...}) : THM = (
let 	val dummy = (check_thm "icl'eq_trans_rule" thrm1;
		check_thm "icl'eq_trans_rule" thrm2);

	val (lhs_concl1,rhs_concl1) = (dest_eq concl1 
		handle complaint =>
		divert complaint "dest_eq" "icl'eq_trans_rule" 6020 []);

	val (lhs_concl2,rhs_concl2) = (dest_eq concl2
		handle complaint =>
		divert complaint "dest_eq" "icl'eq_trans_rule" 6021 []);

	val dummy = if aconv rhs_concl1 lhs_concl2
		then ()
		else fail "icl'eq_trans_rule" 6022 [];

	val new_concl = mk_eq(lhs_concl1,rhs_concl2);
in
	mk_current_thm(hyps1 term_union hyps2, new_concl)
end);
=TEX
\subsection{icl'mk\_comb\_rule}
=RULE
icl'mk_comb_rule
…
ˆ1 Ö u1 = u2; ˆ2 Ö v1 = v2
…
ˆ1 ° ˆ2 Ö u1 v1 = u2 v2
=TEX
=SML
fun ‚icl'mk_comb_rule· (thrm1 : THM as Thm{sequent = (hyps1,concl1),...})
	(thrm2 : THM as Thm{sequent = (hyps2,concl2),...}) : THM = (
let 	val dummy = (check_thm "icl'mk_comb_rule" thrm1;
		check_thm "icl'mk_comb_rule" thrm2);

	val (lhs_concl1,rhs_concl1) = (dest_eq concl1 
		handle complaint =>
		divert complaint "dest_eq" "icl'mk_comb_rule" 6020 []);

	val (lhs_concl2,rhs_concl2) = (dest_eq concl2
		handle complaint =>
		divert complaint "dest_eq" "icl'mk_comb_rule" 6021 []);

	val new_concl = mk_eq(mk_comb(lhs_concl1, lhs_concl2),
		mk_comb(rhs_concl1,rhs_concl2))
		handle complaint =>
		divert complaint "mk_comb" "icl'mk_comb_rule" 6023 [];
in
	mk_current_thm(hyps1 term_union hyps2, new_concl)
end);
=TEX
\subsection{icl'Ç\_mp\_rule}
=RULE
icl'Ç_mp_rule
…
ˆ1 Ö t1 Ç t2; ˆ2 Ö t1'
…
ˆ1 ° ˆ2 Ö t2
=TEX
=SML
fun ‚icl'Ç_mp_rule· (thrm1 : THM as Thm{sequent = (hyps1,concl1),...})
	(thrm2 : THM as Thm{sequent = (hyps2,concl2),...}) : THM = (
let 	val dummy = (check_thm "icl'Ç_mp_rule" thrm1;
		check_thm "icl'Ç_mp_rule" thrm2);

	val (lhs_concl1,rhs_concl1) = (dest_eq concl1 
		handle complaint =>
		divert complaint "dest_eq" "icl'Ç_mp_rule" 6030 []);

	val new_concl = if aconv lhs_concl1 concl2
		then rhs_concl1
		else fail "icl'Ç_mp_rule" 6024 [];
in
	mk_current_thm(hyps1 term_union hyps2, new_concl)
end);
=TEX
\subsection{icl'simple\_É\_intro}
=RULE
icl'simple_É_intro
ªxº
…
ˆ Ö t
…
ˆ Ö É x é t
=TEX
=SML
fun ‚icl'simple_É_intro· (x : TERM) 
	(thrm : THM as Thm{sequent = (hyps,concl),...}) : THM = (
let 	val dummy = check_thm "icl'simple_É_intro" thrm;

	val (nmx, tyx) = (dest_var x
		handle complaint =>
		divert complaint "dest_var" "icl'simple_É_intro" 6004 []);
		
	val dummy = (if list_is_free_in x hyps
		then fail "icl'simple_É_intro" 6005 [fn () => nmx]
		else ());

	val new_concl = simple_mk_É(x,concl);
in
	mk_current_thm(hyps, new_concl)
end);
=TEX
\subsection{icl'inst\_term\_rule}
=RULE
icl'inst_term_rule
[..., (ªtiº, ªxiº), ...]
…
ˆ Ö t[x1, ..., xn]
…
ˆ Ö t[t1, ..., tn]
=TEX
=SML
fun ‚icl'inst_term_rule· (tvl : (TERM * TERM)list) 
	(thrm : THM as Thm{sequent = (hyps,concl),...}) : THM = (
let 	val dummy = check_thm "icl'inst_term_rule" thrm;

	val svars = (map (fn (t,x) => (
		let val (xnm,xty) = (dest_var x
			handle complaint =>
			divert complaint "dest_var" "icl'inst_term_rule" 6026 [])
		in
			if type_of t = xty
			then x
			else fail "icl'inst_term_rule" 6027 [fn () => xnm]
		end))		
		tvl);
		
	val hfrees = list_frees hyps;
 
	val dummy = if any svars (fn x => x mem hfrees)
		then fail "icl'inst_term_rule" 6028 
			[fn () => fst(dest_var(find svars (fn x => x mem hfrees)))]
		else ();

	val new_concl = var_subst tvl concl;
in
	mk_current_thm(hyps, new_concl)
end);
=TEX
\subsection{icl'div2\_conv}
=RULE
icl'div2_conv
(mk_Ü n)
…
…
Ö ^(mk_Ü n) Div 2 = ^(mk_Ü(n div 2))
=TEX
=SML
local 
	val N2 = mk_Ü 2
in
val ‚icl'div2_conv· : CONV = (fn (tm : TERM) =>
let 	val (n,n2) = dest_bin_op "icl'div2_conv" 6085 "Div" tm;

 	val nint = (dest_Ü n
		handle complaint =>
		divert complaint "dest_Ü" "icl'div2_conv" 6085 []);

	val dummy = if N2 <> n2
		then fail "icl'div2_conv" 6085 []
		else ();

	val rhs = mk_Ü (nint div 2);
in
	mk_current_thm([],mk_eq(tm,rhs))
end);
end;
=TEX
\subsection{icl'mod2\_conv}
=RULE
icl'mod2_conv
(mk_Ü n)
…
…
Ö ^(mk_Ü n) Mod 2 = ^(mk_Ü(n mod 2))
=TEX
=SML
local 
	val N2 = mk_Ü 2
in
val ‚icl'mod2_conv· : CONV = (fn (tm : TERM) =>
let 	val (n,n2) = dest_bin_op "icl'mod2_conv" 6086 "Mod" tm;

 	val nint = (dest_Ü n
		handle complaint =>
		divert complaint "dest_Ü" "icl'mod2_conv" 6086 []);

	val dummy = if N2 <> n2
		then fail "icl'mod2_conv" 6086 []
		else ();

	val rhs = mk_Ü (nint mod 2);

in
	mk_current_thm([],mk_eq(tm,rhs))
end);
end;
=TEX

\section{END OF THE ADT}
=SML
end; (* of abstype THM *)
=TEX
=SML
end; (* of structure icl'Kernel *)
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
