=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Integer Arithmetic Proof Procedure}  %% Mandatory field
\TPPref{DS/FMU/IED/MDT105}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthors{R.D.~Arthan & WIN01\\K.~Blackburn & WIN01}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains tests for the material defined
in DS/FMU/IED/DTD105\cite{DS/FMU/IED/DTD105}.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item[\SCCSversion~(\FormatDate{$Date$%}
)]]
First draft.
\end{description}
\subsection{Changes forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains module tests for the module defined 
in \cite{DS/FMU/IED/DTD105}.
\subsection{Introduction}
\subsubsection{Background and Purpose}
See \cite{DS/FMU/IED/DTD105}. The tests are intended to meet
the requirements for module tests identified in the quality plan
\cite{DS/FMU/IED/PLN008}.
\subsubsection{Dependencies}
These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Deficiencies}
None known.
\section{PREAMBLE}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
open_theory"ú";
push_merge_pcs["'ú", "'î", "predicates"];
new_theory"mdt105";
=TEX
\section{TEST CASES}
We identify the following test cases:

\begin{description}
\item[anf.1]
Miscellaneous black box tests (correct operation).
\item[anf.2]
White box test of simplification of sums (correct operation).
\item[anf.3]
White box test of simplification of products (correct operation).
\item[anf.4]
White box test of treatment of atoms (correct operation).
\item[anf.5]
Arithmetic normaliser (error cases).
\item[la.1]
$ú\_lin\_arith\_rule$ (successful operation)
\item[la.2]
$ú\_lin\_arith\_rule$ (error cases)
\item[la.3]
$ú\_lin\_arith\_tac$ (successful operation)
\item[la.4]
$ú\_lin\_arith\_tac$ (error cases)
\item[pc.1]
The proof contexts (successful operation)
\item[pc.2]
The proof contexts (error cases)
\end{description}

The conversional $ú\_ANF\_C$ is only tested in anf.4 and anf.5 (as is justifed by the structure of the implementation).



\section{THE TESTS}
\subsection{Tools}
For testing, it is convenient to have functions to check the salient features of the normal forms.
=SML
fun Ûstrip_dyopÝ (dest : TERM -> TERM * TERM) (tm : TERM) : TERM list = (
	let	val (x, y) = dest tm;
	in	x :: (strip_dyop dest y)
	end	handle Fail _ => [tm]
);
=TEX
=SML
fun Ûis_atomÝ (tm : TERM) : bool = (
	(dest_ú_times tm; false)
	handle Fail _ => (
		(dest_ú_subtract tm; false)
		handle Fail _ => (
			(dest_ú_plus tm; false)
			handle Fail _ => (
				(dest_ú_minus tm; false)
					handle Fail _ => true
			)
		)
	)
);
=TEX
=SML
fun Ûtest_dest_monomialÝ (tm : TERM) : (bool * (int * (TERM list))) = (
	let	val ts = strip_dyop dest_ú_times tm;
	in let	val i = dest_ú_signed_int (hd ts);
	in	if	(((i = 1) orelse (i = 0)) andalso not (is_nil (tl ts)))
		orelse	 not (all (tl ts) is_atom)
		then	(false, (i, tl ts))
		else	(true, (i, tl ts))
	end	handle Fail _ => (
			let	val t = dest_ú_minus (hd ts);
				val ts' = t :: tl ts;
			in	(all ts' is_atom, (~1, ts'))
			end	handle Fail _ =>
				(all ts is_atom, (1, ts))
		)
	end
);
=TEX
=SML
fun Ûtest_polyÝ (tm : TERM) : bool * string = (
	let	val (oks,( _, ms)) = 
		((Combinators.I ** split) o split o map test_dest_monomial o
			strip_dyop dest_ú_plus) tm;
		fun f a b = (
			if a =$ b
			then 1
			else term_order a b
		)
		val sms = map (Sort.sort f) ms;
		fun eq_ms (m1, m2) = (
			(all (combine m1 m2) (op =$))
			handle Fail _ => false
		);
	in	(all oks Combinators.I andalso all_distinct eq_ms sms,
		string_of_term tm)
	end
);
=TEX
=SML
fun Ûtest_anfÝ (thm : THM) : bool * string = (
	let	val concl = concl thm;
		val (t1, t2) = dest_eq concl;
	in	if	not(is_nil (asms thm))
		then	(false, string_of_thm thm)
		else	test_poly t2
	end	handle Fail _ =>
		(false, string_of_thm thm)
);
=TEX
=SML
fun Ûanf_resultsÝ (grp : string) (rs : (bool * string) list)
	: unit -> (string * bool) list = (
	let	fun label i = grp ^ "." ^ string_of_int i;
		val lrs = combine (map label (interval 1 (length rs))) rs;
		fun chk (flg, _) = flg;
		fun test (lab, r) = (lab, chk, r, true);
	in	fn () => mt_run (map test lrs)
	end
);
=TEX
=SML
fun ÛrippleÝ (xs : 'a list) : 'a list = (
	let	val mid = length xs div 2;
		fun r (x :: xs) (y :: ys) = x :: y :: r xs ys
		|   r [] ys = ys
		|   r xs [] = xs;
	in	r (xs from mid) (xs to (mid - 1))
	end
);
fun ÛshuffleÝ (i : int) (xs : 'a list) = (
	if	i <= 0
	then	xs
	else	shuffle (i-1) (ripple xs)
);

=TEX
=SML
fun list_mk_dyop (unit : TERM) (mk : TERM * TERM -> TERM)
		(tms : TERM list) : TERM = (
	case tms of
		tm :: (more as _ :: _) => mk(tm, list_mk_dyop unit mk more)
	|	[tm] => tm
	|	[] => unit
);
=TEX
\subsection{Case anf.1}
A miscellany:
=SML
val ts1_1 = [
	¬îú 1 + îú 2®,
	¬(x:ú) + x®,
	¬(x:ú) - x®,
	¬((x:ú) - îú 1)*(x + îú 1)®,
	¬((x:ú) - îú 1)*(x + y)®,
	¬((x:ú) + y + z)*(x + y + z)®,
	¬((x1:ú) + ~ x2 + x3 + ~ x4)*(x1 + x2 + x3 + x4)®,
	¬(x - îú 1)*(x*x + x + îú 1)®,
	¬(x - îú 1)*(x*x*x*x + x*x*x + x*x + x + îú 1)®,
	¬~ (îú 1)*x*x®,
	¬~ (y:ú)*  x * ~ x®,
	¬~ (y:ú)* ~ (~ (~ (~ x)))* ~ (~ (~ (~ (~ (~ (~ (~ (~ (~ x)))))))))®,
	¬~(îú 0)®,
	¬~(îú 0) * x®,
	¬(a:ú - b) * (a + b)®,
	¬~ a * a * c + îú 2 * a * a * c®,
	¬îú 2 * m + ~(îú 1) * m®,
	¬((a:ú - b) + c) * ((a + b) - c) * ((~a + b) + c)®];
val rs1_1 = map (test_anf o ú_anf_conv) ts1_1;
store_mt_results (anf_results "anf.1.1" rs1_1) ();
=TEX
\subsection{Case anf.2}
Simplification of sums:
=SML
val ts2_1 = [
	¬îú 35 *M*O*N*O + îú 47 *M*O*O*N®,			(* 1 *)
	¬îú 99 *M*O*N*O + ~(îú 99) *M*O*O*N®,
	¬M*O*N*O + ~(îú 35) *M*O*O*N®,			(* 2 *)
	¬îú 0 + M*O*O*N®,					(* 3 *)
	¬îú 0 + îú 99®,					(* 4 *)
	¬(M:ú)*O*N*O + M*O*O*N®,				(* 5 *)
	¬(M:ú) + ~M®,						(* 6 *)
	¬(M:ú)*O*N*O + ~M*O*O*N®,				(* 7 *)
	¬(M:ú)*O*N*O + ~(M*O*O*N)®,
	¬~M + îú 42 * M®,					(* 8 *)
	¬~M*O*N*O + îú 42 *M*O*O*N®				(* 9 *) ];
=TEX
=SML
val rs2_1 = map (test_anf o ú_anf_conv) ts2_1;
store_mt_results (anf_results "anf.2.1" rs2_1) ();
=TEX
=SML
val decorate = (fn (t1, t2) =>
	mk_ú_plus(¬SUN:ú *PLUTO®,
		mk_ú_plus(mk_ú_plus(¬îú 99®, t1),
				mk_ú_plus(¬îú 100*PLUTO*SUN®,
					mk_ú_plus(mk_ú_plus(¬EARTH:ú®, t2),
							¬îú 66®)))));
val ts2_2 = map (decorate o dest_ú_plus) ts2_1;
val rs2_2 = map (test_anf o ú_anf_conv) ts2_2;
store_mt_results (anf_results "anf.2.2" rs2_2) ();
=TEX
=SML
val ts2_3 = map (decorate o swap o dest_ú_plus) ts2_1;
val rs2_3 = map (test_anf o ú_anf_conv) ts2_3;
store_mt_results (anf_results "anf.2.3" rs2_3) ();
val ts2_4 = map (list_mk_dyop ¬îú 0® mk_ú_plus o shuffle 7 o
			strip_dyop dest_ú_plus) ts2_2;
val rs2_4 = map (test_anf o ú_anf_conv) ts2_4;
store_mt_results (anf_results "anf.2.4" rs2_4) ();
=TEX
\subsection{Case anf.3}
Simplification of products.
=SML
val ts3_1 = [
	¬îú 2 * ~(îú 5)®,			(* 1 *)
	¬îú 0 * îú 5®,
	¬îú 5 * îú 0®,
	¬îú 1 * îú 1®,
	¬îú 1 * ~(îú 1)®,
	¬~(îú 1) * îú 1®,
	¬~(îú 1) * ~(îú 1)®,
	¬îú 0 * factor®,			(* 2 *)
	¬îú 1 * factor®,			(* 3 *)
	¬~(îú 1) * ~factor®,			(* 4 *)
	¬~(îú 1) * factor®,			(* 5 *)
	¬~(fac:ú) * ~tor®,			(* 6 *)
	¬(fac:ú) * ~tor®			(* 7 *)
];
val rs3_1 = map (test_anf o ú_anf_conv) ts3_1;
store_mt_results (anf_results "anf.3.1" rs3_1) ();
val decorate1 = (fn (t1, t2) =>
	mk_ú_times(¬tinker:ú *tailor®,
		mk_ú_times(mk_ú_times(t1, ¬îú 99®),
				mk_ú_times(¬îú 100*tailor*tinker®,
					mk_ú_times(t2,
						mk_ú_times(¬soldier:ú®,
							(¬îú 66®)))))));
val ts3_2 = map (decorate1 o dest_ú_times) ts3_1;
val rs3_2 = map (test_anf o ú_anf_conv) ts3_2;
store_mt_results (anf_results "anf.3.2" rs3_2) ();
val ts3_3 = map (decorate1 o swap o dest_ú_times) ts3_1;
val rs3_3 = map (test_anf o ú_anf_conv) ts3_3;
store_mt_results (anf_results "anf.3.3" rs3_3) ();
val ts3_4 = map (list_mk_dyop ¬îú 1® mk_ú_times o shuffle 4 o
			strip_dyop dest_ú_times) ts3_2;
val rs3_4 = map (test_anf o ú_anf_conv) ts3_4;
store_mt_results (anf_results "anf.3.4" rs3_4) ();
=TEX
\subsection{Case anf.4}
Treatment of atoms:
=SML
val ts4_1 = [
	¬îú 1 + (Ìx·x) (îú 2 + îú 1)®,
	¬(Ìx·x)(((x:ú) + y + z)*(x + y + z))®,
	¬(Ìx·x)(((x:ú) + y + z))*(x + y + z)®
];
fun test_ANF_I (th : THM) : bool * string = (
	let	val (ok, s) = test_anf th;
		val ok2 = (
			MAP_C Â_conv (snd (dest_eq(concl th))); false
		) handle Fail _ => true
	in	(ok andalso ok2, s)
	end
);
val rs4_1 = map (test_ANF_I o ú_ANF_C Â_conv) ts4_1;
store_mt_results (anf_results "anf.4.1" rs4_1) ();
val ts4_2 = [
	¬~(~(m:ú))®,					(* 1 *)
	¬~(~(~(~(~(~(~(~(m:ú))))))))®,
	¬~(~(~(~(~(~(~(~(~(m:ú)))))))))®,
	¬~(m+n:ú)®,					(* 2 *)
	¬~(~(~(~(~(m+n:ú)))))®,
	¬~(m+n:ú)®,
	¬~(m*n:ú)®,					(* 3 *)
	¬(m-n:ú)®,					(* 4 *)
	¬~(~((m-n:ú)))®,	
	¬~(~((m- ~(îú 0):ú)))®			(* 5 *)	
];
val rs4_2 = map (test_anf o ú_anf_conv) ts4_2;
store_mt_results (anf_results "anf.4.2" rs4_2) ();

=TEX
\subsection{Case anf.5}
Arithmetic normaliser error cases.
=SML
store_mt_results_show mt_run_fail [
("anf.5.1", ú_ANF_C fail_conv, ¬(a:ú) + b®,
		gen_fail_msg"ú_ANF_C" 105032 [string_of_term¬(a:ú) + b®]),
("anf.5.2", ú_anf_conv, mk_f,
		gen_fail_msg"ú_anf_conv" 105032 [string_of_term mk_f]),
("anf.5.3", ú_ANF_C fail_conv, mk_t,
		gen_fail_msg"ú_ANF_C" 105032 [string_of_term mk_t]),
("anf.5.4", ú_anf_conv, ¬îú 42®,
		gen_fail_msg"ú_anf_conv" 105032 [string_of_term¬îú 42®])
];
=TEX
\subsection{Group la.1}
$ú\_lin\_arith\_rule$ (successful operation)
=SML
fun t (s, f, a) = (s, dest_thm o f, a, (a, mk_f));
store_mt_results_show (mt_runf (op ~=#) o map t) [
	("la.1.1", ú_lin_arith_rule,
		[¬~ x ¼ ~(îú 1)®,
		¬x + y + ~ z:ú = îú 0®,
		¬y + ~z:ú = îú 0®]),
	("la.1.2", ú_lin_arith_rule,
		[¬f(x, y) ¼ îú 0®,
		¬~(g(x, y)) ¼ îú 0®,
		¬~(f(x, y)) + g(x, y)  ¼ ~(îú 1)®])
];
store_mt_results_show (mt_runf (op ~=#) o map t) [
	("la.1.3", ú_lin_arith_rule,
		[¬a + b = îú 0®, ¬a = îú 1®, ¬b = îú 1®]),
	("la.1.4", ú_lin_arith_rule,
		[¬a*a + b = îú 0®, ¬~a*a ¼ ~(îú 1)®, ¬~b ¼ ~(îú 1)®])
];

=TEX
\subsection{Group la.2}
$ú\_lin\_arith\_rule$ (error cases).

N.b. these generate message on the standard output as well as just raising
exceptions.
=SML
store_mt_results_show mt_run_fail [
	("la.2.1", ú_lin_arith_rule,
		[¬X ¼ îú 0®],
		gen_fail_msg"ú_lin_arith_rule" 82110 []),
	("la.2.3", ú_lin_arith_rule,
		[],
		gen_fail_msg"ú_lin_arith_rule" 82111 []),
	("la.2.4", ú_lin_arith_rule,
		[¬f(a, b) + g(x, y):ú®],
		gen_fail_msg"ú_lin_arith_rule" 105112 [])
];
\subsection{Group la.3}
$lin\_arith\_tac$ (successful operation)
=SML
fun check_tac (tac, gl) = (
	set_goal gl;
	a tac;
	(dest_thm o pop_thm) () ~=# gl
);
=TEX
store_mt_results_show mt_run [
("la.3.1", check_tac, 
	(ú_lin_arith_tac, ([¬a*a + b = îú 0®,
		¬~a*a ¼ ~(îú 1)®, ¬~b ¼ ~(îú 1)®], mk_f)), true)
];
=TEX
\subsection{Group la.4}
$lin\_arith\_tac$ (error cases)
=SML
store_mt_results_show mt_run_fail [
("la.4.1", ú_lin_arith_tac, ([¬îú 1 + x  ¼ îú 0®], mk_f),
		gen_fail_msg"ú_lin_arith_tac" 82110 [])
];
=TEX
\subsection{Group pc.1}
The proof contexts (successful operation)
=SML
store_mt_results_show mt_run [
("pc.1.1.1", check_tac, 
	(PC_T1"ú_lin_arith"asm_prove_tac[], ([], ¬x + y ¼ y ´ x ¼ îú 0®)), true),
("pc.1.1.2", check_tac, 
	(PC_T1"ú_lin_arith"asm_prove_tac[], ([], ¬³¶x y:ú·x > îú 0 ± x + a + b + y < b + y + a®)), true)
];
=TEX
Now try the examples from the detailed design for the natural numbers version:
=SML
store_mt_results_show mt_run [
("pc.1.2.1", check_tac, (PC_T1"ú_lin_arith"prove_tac[],
		([], ¬µa b c:ú·a ¼ b ± (a + b < c + a) ´ a < c®)
			), true),
("pc.1.2.2", check_tac, (PC_T1"ú_lin_arith"prove_tac[],
	([], ¬µa b c:ú·a ¾ b ± ³ b < c ´ a ¾ c®)
			), true),
("pc.1.2.3", check_tac, (PC_T1"ú_lin_arith"prove_tac[],
	([], ¬µa b c:ú·a + îú 2*b < îú 2*a ´ b + b < a®)
			), true),
("pc.1.2.4", check_tac, (PC_T1"ú_lin_arith"prove_tac[],
	([], ¬µ x y:ú· ³ (îú 2*x + y = îú 4 ±îú  4*x + îú 2*y = îú 7)®)
			), true)
];
=TEX
Now try out the component proof context:
=SML
open_theory"sets";
store_mt_results_show mt_run [
("pc.1.3.1", check_tac, (MERGE_PCS_T1["sets_ext", "'ú_lin_arith"]prove_tac[],
	([], ¬µm:ú· {i | m ¼ i ± i < m+ îú 3} = {m; m+ îú 1; m+ îú 2}®)
			), true),
("pc.1.3.2", check_tac, (MERGE_PCS_T1["sets_ext", "'ú_lin_arith"]prove_tac[],
	([], ¬{(i, j) | îú 30*i = îú 105*j} = {(i, j) | îú 2*i = îú 7*j}®)
			), true),
("pc.1.3.3", check_tac, (MERGE_PCS_T1["sets_ext", "'ú_lin_arith"]prove_tac[],
	([], ¬{i | îú 5*i = îú 6*i} = {îú 0}®)
			), true)
];
=TEX
Now a case to show that the arguments to the automatic proof tactic are
not ignored.
=SML
¹HOLCONST
Ü	q : ú ­ ú ­ ú
÷
Ü	µi j:ú· q i j = i - j + îú 1
°
store_mt_results_show mt_run [
("pc.1.5.1", check_tac, (
	REPEAT strip_tac THEN PC_T1"ú_lin_arith"asm_prove_tac
	[list_µ_elim[¬x:ú®, ¬y:ú®] (get_spec¬q®)],
	([], ¬µx y· q x y ¾ îú 1 ´ x ¾ y®)
			), true)
];
=TEX
Check the rewriting, using the examples from the detailed design:
=SML
fun check_pc_1_6 t1 t2 = (
	let	val (l, r) = (dest_¤ o concl o PC_C1"ú_lin_arith"rewrite_conv[]) t1;
	in	l =$ t1 andalso r =$ t2
	end
);
=SML
store_mt_results_show mt_run [
("pc.1.6.1", check_pc_1_6 ¬³x + îú 2*y + x + îú 3 = y + îú 2 + îú 2*x + y®, ¬T®, true),
("pc.1.6.2", check_pc_1_6 ¬x + îú 2*y + x + îú 3 ¼ y + îú 2 + îú 2*x + y®, ¬F®, true)
];
=TEX
\subsection{Group pc.2}
The proof contexts (error cases)
=SML
store_mt_results_show mt_run_fail [
("pc.2.1", PC_T1"ú_lin_arith"asm_prove_tac[], ([¬x + y ¼ y:ú®, ¬îú 1 ¼ y®], mk_f),
		gen_fail_msg"ú_lin_arith_prove_tac" 82200
			[get_message(fail "ú_lin_arith_tac" 82110 [] handle Fail msg => msg),
			string_of_term ¬F®])
];
=TEX

=TEX
\section{SUMMARY OF RESULTS}
=SML
diag_string(summarize_mt_results());
=TEX

\end{document}

