=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Integer Arithmetic Proof Procedure}  %% Mandatory field
\TPPref{DS/FMU/IED/MDT105}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthors{R.D.~Arthan & WIN01\\K.~Blackburn & WIN01}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains tests for the material defined
in DS/FMU/IED/DTD105\cite{DS/FMU/IED/DTD105}.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item[\SCCSversion~(\FormatDate{$Date$%}
)]]
First draft.
\end{description}
\subsection{Changes forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains module tests for the module defined 
in \cite{DS/FMU/IED/DTD105}.
\subsection{Introduction}
\subsubsection{Background and Purpose}
See \cite{DS/FMU/IED/DTD105}. The tests are intended to meet
the requirements for module tests identified in the quality plan
\cite{DS/FMU/IED/PLN008}.
\subsubsection{Dependencies}
These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Deficiencies}
None known.
\section{PREAMBLE}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
open_theory"˙";
push_merge_pcs["'˙", "'Ó", "predicates"];
new_theory"mdt105";
=TEX
\section{TEST CASES}
We identify the following test cases:

\begin{description}
\item[anf.1]
Miscellaneous black box tests (correct operation).
\item[anf.2]
White box test of simplification of sums (correct operation).
\item[anf.3]
White box test of simplification of products (correct operation).
\item[anf.4]
White box test of treatment of atoms (correct operation).
\item[anf.5]
Arithmetic normaliser (error cases).
\item[la.1]
$˙\_lin\_arith\_rule$ (successful operation)
\item[la.2]
$˙\_lin\_arith\_rule$ (error cases)
\item[la.3]
$˙\_lin\_arith\_tac$ (successful operation)
\item[la.4]
$˙\_lin\_arith\_tac$ (error cases)
\item[pc.1]
The proof contexts (successful operation)
\item[pc.2]
The proof contexts (error cases)
\end{description}

The conversional $˙\_ANF\_C$ is only tested in anf.4 and anf.5 (as is justifed by the structure of the implementation).



\section{THE TESTS}
\subsection{Tools}
For testing, it is convenient to have functions to check the salient features of the normal forms.
=SML
fun €strip_dyop› (dest : TERM -> TERM * TERM) (tm : TERM) : TERM list = (
	let	val (x, y) = dest tm;
	in	x :: (strip_dyop dest y)
	end	handle Fail _ => [tm]
);
=TEX
=SML
fun €is_atom› (tm : TERM) : bool = (
	(dest_˙_times tm; false)
	handle Fail _ => (
		(dest_˙_subtract tm; false)
		handle Fail _ => (
			(dest_˙_plus tm; false)
			handle Fail _ => (
				(dest_˙_minus tm; false)
					handle Fail _ => true
			)
		)
	)
);
=TEX
=SML
fun €test_dest_monomial› (tm : TERM) : (bool * (int * (TERM list))) = (
	let	val ts = strip_dyop dest_˙_times tm;
	in let	val i = dest_˙_signed_int (hd ts);
	in	if	(((i = 1) orelse (i = 0)) andalso not (is_nil (tl ts)))
		orelse	 not (all (tl ts) is_atom)
		then	(false, (i, tl ts))
		else	(true, (i, tl ts))
	end	handle Fail _ => (
			let	val t = dest_˙_minus (hd ts);
				val ts' = t :: tl ts;
			in	(all ts' is_atom, (~1, ts'))
			end	handle Fail _ =>
				(all ts is_atom, (1, ts))
		)
	end
);
=TEX
=SML
fun €test_poly› (tm : TERM) : bool * string = (
	let	val (oks,( _, ms)) = 
		((Combinators.I ** split) o split o map test_dest_monomial o
			strip_dyop dest_˙_plus) tm;
		fun f a b = (
			if a =$ b
			then 1
			else term_order a b
		)
		val sms = map (Sort.sort f) ms;
		fun eq_ms (m1, m2) = (
			(all (combine m1 m2) (op =$))
			handle Fail _ => false
		);
	in	(all oks Combinators.I andalso all_distinct eq_ms sms,
		string_of_term tm)
	end
);
=TEX
=SML
fun €test_anf› (thm : THM) : bool * string = (
	let	val concl = concl thm;
		val (t1, t2) = dest_eq concl;
	in	if	not(is_nil (asms thm))
		then	(false, string_of_thm thm)
		else	test_poly t2
	end	handle Fail _ =>
		(false, string_of_thm thm)
);
=TEX
=SML
fun €anf_results› (grp : string) (rs : (bool * string) list)
	: unit -> (string * bool) list = (
	let	fun label i = grp ^ "." ^ string_of_int i;
		val lrs = combine (map label (interval 1 (length rs))) rs;
		fun chk (flg, _) = flg;
		fun test (lab, r) = (lab, chk, r, true);
	in	fn () => mt_run (map test lrs)
	end
);
=TEX
=SML
fun €ripple› (xs : 'a list) : 'a list = (
	let	val mid = length xs div 2;
		fun r (x :: xs) (y :: ys) = x :: y :: r xs ys
		|   r [] ys = ys
		|   r xs [] = xs;
	in	r (xs from mid) (xs to (mid - 1))
	end
);
fun €shuffle› (i : int) (xs : 'a list) = (
	if	i <= 0
	then	xs
	else	shuffle (i-1) (ripple xs)
);

=TEX
=SML
fun list_mk_dyop (unit : TERM) (mk : TERM * TERM -> TERM)
		(tms : TERM list) : TERM = (
	case tms of
		tm :: (more as _ :: _) => mk(tm, list_mk_dyop unit mk more)
	|	[tm] => tm
	|	[] => unit
);
=TEX
\subsection{Case anf.1}
A miscellany:
=SML
val ts1_1 = [
	¨Ó˙ 1 + Ó˙ 2Æ,
	¨(x:˙) + xÆ,
	¨(x:˙) - xÆ,
	¨((x:˙) - Ó˙ 1)*(x + Ó˙ 1)Æ,
	¨((x:˙) - Ó˙ 1)*(x + y)Æ,
	¨((x:˙) + y + z)*(x + y + z)Æ,
	¨((x1:˙) + ~ x2 + x3 + ~ x4)*(x1 + x2 + x3 + x4)Æ,
	¨(x - Ó˙ 1)*(x*x + x + Ó˙ 1)Æ,
	¨(x - Ó˙ 1)*(x*x*x*x + x*x*x + x*x + x + Ó˙ 1)Æ,
	¨~ (Ó˙ 1)*x*xÆ,
	¨~ (y:˙)*  x * ~ xÆ,
	¨~ (y:˙)* ~ (~ (~ (~ x)))* ~ (~ (~ (~ (~ (~ (~ (~ (~ (~ x)))))))))Æ,
	¨~(Ó˙ 0)Æ,
	¨~(Ó˙ 0) * xÆ,
	¨(a:˙ - b) * (a + b)Æ,
	¨~ a * a * c + Ó˙ 2 * a * a * cÆ,
	¨Ó˙ 2 * m + ~(Ó˙ 1) * mÆ,
	¨((a:˙ - b) + c) * ((a + b) - c) * ((~a + b) + c)Æ];
val rs1_1 = map (test_anf o ˙_anf_conv) ts1_1;
store_mt_results (anf_results "anf.1.1" rs1_1) ();
=TEX
\subsection{Case anf.2}
Simplification of sums:
=SML
val ts2_1 = [
	¨Ó˙ 35 *M*O*N*O + Ó˙ 47 *M*O*O*NÆ,			(* 1 *)
	¨Ó˙ 99 *M*O*N*O + ~(Ó˙ 99) *M*O*O*NÆ,
	¨M*O*N*O + ~(Ó˙ 35) *M*O*O*NÆ,			(* 2 *)
	¨Ó˙ 0 + M*O*O*NÆ,					(* 3 *)
	¨Ó˙ 0 + Ó˙ 99Æ,					(* 4 *)
	¨(M:˙)*O*N*O + M*O*O*NÆ,				(* 5 *)
	¨(M:˙) + ~MÆ,						(* 6 *)
	¨(M:˙)*O*N*O + ~M*O*O*NÆ,				(* 7 *)
	¨(M:˙)*O*N*O + ~(M*O*O*N)Æ,
	¨~M + Ó˙ 42 * MÆ,					(* 8 *)
	¨~M*O*N*O + Ó˙ 42 *M*O*O*NÆ				(* 9 *) ];
=TEX
=SML
val rs2_1 = map (test_anf o ˙_anf_conv) ts2_1;
store_mt_results (anf_results "anf.2.1" rs2_1) ();
=TEX
=SML
val decorate = (fn (t1, t2) =>
	mk_˙_plus(¨SUN:˙ *PLUTOÆ,
		mk_˙_plus(mk_˙_plus(¨Ó˙ 99Æ, t1),
				mk_˙_plus(¨Ó˙ 100*PLUTO*SUNÆ,
					mk_˙_plus(mk_˙_plus(¨EARTH:˙Æ, t2),
							¨Ó˙ 66Æ)))));
val ts2_2 = map (decorate o dest_˙_plus) ts2_1;
val rs2_2 = map (test_anf o ˙_anf_conv) ts2_2;
store_mt_results (anf_results "anf.2.2" rs2_2) ();
=TEX
=SML
val ts2_3 = map (decorate o swap o dest_˙_plus) ts2_1;
val rs2_3 = map (test_anf o ˙_anf_conv) ts2_3;
store_mt_results (anf_results "anf.2.3" rs2_3) ();
val ts2_4 = map (list_mk_dyop ¨Ó˙ 0Æ mk_˙_plus o shuffle 7 o
			strip_dyop dest_˙_plus) ts2_2;
val rs2_4 = map (test_anf o ˙_anf_conv) ts2_4;
store_mt_results (anf_results "anf.2.4" rs2_4) ();
=TEX
\subsection{Case anf.3}
Simplification of products.
=SML
val ts3_1 = [
	¨Ó˙ 2 * ~(Ó˙ 5)Æ,			(* 1 *)
	¨Ó˙ 0 * Ó˙ 5Æ,
	¨Ó˙ 5 * Ó˙ 0Æ,
	¨Ó˙ 1 * Ó˙ 1Æ,
	¨Ó˙ 1 * ~(Ó˙ 1)Æ,
	¨~(Ó˙ 1) * Ó˙ 1Æ,
	¨~(Ó˙ 1) * ~(Ó˙ 1)Æ,
	¨Ó˙ 0 * factorÆ,			(* 2 *)
	¨Ó˙ 1 * factorÆ,			(* 3 *)
	¨~(Ó˙ 1) * ~factorÆ,			(* 4 *)
	¨~(Ó˙ 1) * factorÆ,			(* 5 *)
	¨~(fac:˙) * ~torÆ,			(* 6 *)
	¨(fac:˙) * ~torÆ			(* 7 *)
];
val rs3_1 = map (test_anf o ˙_anf_conv) ts3_1;
store_mt_results (anf_results "anf.3.1" rs3_1) ();
val decorate1 = (fn (t1, t2) =>
	mk_˙_times(¨tinker:˙ *tailorÆ,
		mk_˙_times(mk_˙_times(t1, ¨Ó˙ 99Æ),
				mk_˙_times(¨Ó˙ 100*tailor*tinkerÆ,
					mk_˙_times(t2,
						mk_˙_times(¨soldier:˙Æ,
							(¨Ó˙ 66Æ)))))));
val ts3_2 = map (decorate1 o dest_˙_times) ts3_1;
val rs3_2 = map (test_anf o ˙_anf_conv) ts3_2;
store_mt_results (anf_results "anf.3.2" rs3_2) ();
val ts3_3 = map (decorate1 o swap o dest_˙_times) ts3_1;
val rs3_3 = map (test_anf o ˙_anf_conv) ts3_3;
store_mt_results (anf_results "anf.3.3" rs3_3) ();
val ts3_4 = map (list_mk_dyop ¨Ó˙ 1Æ mk_˙_times o shuffle 4 o
			strip_dyop dest_˙_times) ts3_2;
val rs3_4 = map (test_anf o ˙_anf_conv) ts3_4;
store_mt_results (anf_results "anf.3.4" rs3_4) ();
=TEX
\subsection{Case anf.4}
Treatment of atoms:
=SML
val ts4_1 = [
	¨Ó˙ 1 + (Ãx∑x) (Ó˙ 2 + Ó˙ 1)Æ,
	¨(Ãx∑x)(((x:˙) + y + z)*(x + y + z))Æ,
	¨(Ãx∑x)(((x:˙) + y + z))*(x + y + z)Æ
];
fun test_ANF_I (th : THM) : bool * string = (
	let	val (ok, s) = test_anf th;
		val ok2 = (
			MAP_C ¬_conv (snd (dest_eq(concl th))); false
		) handle Fail _ => true
	in	(ok andalso ok2, s)
	end
);
val rs4_1 = map (test_ANF_I o ˙_ANF_C ¬_conv) ts4_1;
store_mt_results (anf_results "anf.4.1" rs4_1) ();
val ts4_2 = [
	¨~(~(m:˙))Æ,					(* 1 *)
	¨~(~(~(~(~(~(~(~(m:˙))))))))Æ,
	¨~(~(~(~(~(~(~(~(~(m:˙)))))))))Æ,
	¨~(m+n:˙)Æ,					(* 2 *)
	¨~(~(~(~(~(m+n:˙)))))Æ,
	¨~(m+n:˙)Æ,
	¨~(m*n:˙)Æ,					(* 3 *)
	¨(m-n:˙)Æ,					(* 4 *)
	¨~(~((m-n:˙)))Æ,	
	¨~(~((m- ~(Ó˙ 0):˙)))Æ			(* 5 *)	
];
val rs4_2 = map (test_anf o ˙_anf_conv) ts4_2;
store_mt_results (anf_results "anf.4.2" rs4_2) ();

=TEX
\subsection{Case anf.5}
Arithmetic normaliser error cases.
=SML
store_mt_results_show mt_run_fail [
("anf.5.1", ˙_ANF_C fail_conv, ¨(a:˙) + bÆ,
		gen_fail_msg"˙_ANF_C" 105032 [string_of_term¨(a:˙) + bÆ]),
("anf.5.2", ˙_anf_conv, mk_f,
		gen_fail_msg"˙_anf_conv" 105032 [string_of_term mk_f]),
("anf.5.3", ˙_ANF_C fail_conv, mk_t,
		gen_fail_msg"˙_ANF_C" 105032 [string_of_term mk_t]),
("anf.5.4", ˙_anf_conv, ¨Ó˙ 42Æ,
		gen_fail_msg"˙_anf_conv" 105032 [string_of_term¨Ó˙ 42Æ])
];
=TEX
\subsection{Group la.1}
$˙\_lin\_arith\_rule$ (successful operation)
=SML
fun t (s, f, a) = (s, dest_thm o f, a, (a, mk_f));
store_mt_results_show (mt_runf (op ~=#) o map t) [
	("la.1.1", ˙_lin_arith_rule,
		[¨~ x º ~(Ó˙ 1)Æ,
		¨x + y + ~ z:˙ = Ó˙ 0Æ,
		¨y + ~z:˙ = Ó˙ 0Æ]),
	("la.1.2", ˙_lin_arith_rule,
		[¨f(x, y) º Ó˙ 0Æ,
		¨~(g(x, y)) º Ó˙ 0Æ,
		¨~(f(x, y)) + g(x, y)  º ~(Ó˙ 1)Æ])
];
store_mt_results_show (mt_runf (op ~=#) o map t) [
	("la.1.3", ˙_lin_arith_rule,
		[¨a + b = Ó˙ 0Æ, ¨a = Ó˙ 1Æ, ¨b = Ó˙ 1Æ]),
	("la.1.4", ˙_lin_arith_rule,
		[¨a*a + b = Ó˙ 0Æ, ¨~a*a º ~(Ó˙ 1)Æ, ¨~b º ~(Ó˙ 1)Æ])
];

=TEX
\subsection{Group la.2}
$˙\_lin\_arith\_rule$ (error cases).

N.b. these generate message on the standard output as well as just raising
exceptions.
=SML
store_mt_results_show mt_run_fail [
	("la.2.1", ˙_lin_arith_rule,
		[¨X º Ó˙ 0Æ],
		gen_fail_msg"˙_lin_arith_rule" 82110 []),
	("la.2.3", ˙_lin_arith_rule,
		[],
		gen_fail_msg"˙_lin_arith_rule" 82111 []),
	("la.2.4", ˙_lin_arith_rule,
		[¨f(a, b) + g(x, y):˙Æ],
		gen_fail_msg"˙_lin_arith_rule" 105112 [])
];
\subsection{Group la.3}
$lin\_arith\_tac$ (successful operation)
=SML
fun check_tac (tac, gl) = (
	set_goal gl;
	a tac;
	(dest_thm o pop_thm) () ~=# gl
);
=TEX
store_mt_results_show mt_run [
("la.3.1", check_tac, 
	(˙_lin_arith_tac, ([¨a*a + b = Ó˙ 0Æ,
		¨~a*a º ~(Ó˙ 1)Æ, ¨~b º ~(Ó˙ 1)Æ], mk_f)), true)
];
=TEX
\subsection{Group la.4}
$lin\_arith\_tac$ (error cases)
=SML
store_mt_results_show mt_run_fail [
("la.4.1", ˙_lin_arith_tac, ([¨Ó˙ 1 + x  º Ó˙ 0Æ], mk_f),
		gen_fail_msg"˙_lin_arith_tac" 82110 [])
];
=TEX
\subsection{Group pc.1}
The proof contexts (successful operation)
=SML
store_mt_results_show mt_run [
("pc.1.1.1", check_tac, 
	(PC_T1"˙_lin_arith"asm_prove_tac[], ([], ¨x + y º y ¥ x º Ó˙ 0Æ)), true),
("pc.1.1.2", check_tac, 
	(PC_T1"˙_lin_arith"asm_prove_tac[], ([], ¨≥∂x y:˙∑x > Ó˙ 0 ± x + a + b + y < b + y + aÆ)), true)
];
=TEX
Now try the examples from the detailed design for the natural numbers version:
=SML
store_mt_results_show mt_run [
("pc.1.2.1", check_tac, (PC_T1"˙_lin_arith"prove_tac[],
		([], ¨µa b c:˙∑a º b ± (a + b < c + a) ¥ a < cÆ)
			), true),
("pc.1.2.2", check_tac, (PC_T1"˙_lin_arith"prove_tac[],
	([], ¨µa b c:˙∑a æ b ± ≥ b < c ¥ a æ cÆ)
			), true),
("pc.1.2.3", check_tac, (PC_T1"˙_lin_arith"prove_tac[],
	([], ¨µa b c:˙∑a + Ó˙ 2*b < Ó˙ 2*a ¥ b + b < aÆ)
			), true),
("pc.1.2.4", check_tac, (PC_T1"˙_lin_arith"prove_tac[],
	([], ¨µ x y:˙∑ ≥ (Ó˙ 2*x + y = Ó˙ 4 ±Ó˙  4*x + Ó˙ 2*y = Ó˙ 7)Æ)
			), true)
];
=TEX
Now try out the component proof context:
=SML
open_theory"sets";
store_mt_results_show mt_run [
("pc.1.3.1", check_tac, (MERGE_PCS_T1["sets_ext", "'˙_lin_arith"]prove_tac[],
	([], ¨µm:˙∑ {i | m º i ± i < m+ Ó˙ 3} = {m; m+ Ó˙ 1; m+ Ó˙ 2}Æ)
			), true),
("pc.1.3.2", check_tac, (MERGE_PCS_T1["sets_ext", "'˙_lin_arith"]prove_tac[],
	([], ¨{(i, j) | Ó˙ 30*i = Ó˙ 105*j} = {(i, j) | Ó˙ 2*i = Ó˙ 7*j}Æ)
			), true),
("pc.1.3.3", check_tac, (MERGE_PCS_T1["sets_ext", "'˙_lin_arith"]prove_tac[],
	([], ¨{i | Ó˙ 5*i = Ó˙ 6*i} = {Ó˙ 0}Æ)
			), true)
];
=TEX
Now a case to show that the arguments to the automatic proof tactic are
not ignored.
=SML
πHOLCONST
‹	q : ˙ ≠ ˙ ≠ ˙
˜
‹	µi j:˙∑ q i j = i - j + Ó˙ 1
∞
store_mt_results_show mt_run [
("pc.1.5.1", check_tac, (
	REPEAT strip_tac THEN PC_T1"˙_lin_arith"asm_prove_tac
	[list_µ_elim[¨x:˙Æ, ¨y:˙Æ] (get_spec¨qÆ)],
	([], ¨µx y∑ q x y æ Ó˙ 1 ¥ x æ yÆ)
			), true)
];
=TEX
Check the rewriting, using the examples from the detailed design:
=SML
fun check_pc_1_6 t1 t2 = (
	let	val (l, r) = (dest_§ o concl o PC_C1"˙_lin_arith"rewrite_conv[]) t1;
	in	l =$ t1 andalso r =$ t2
	end
);
=SML
store_mt_results_show mt_run [
("pc.1.6.1", check_pc_1_6 ¨≥x + Ó˙ 2*y + x + Ó˙ 3 = y + Ó˙ 2 + Ó˙ 2*x + yÆ, ¨TÆ, true),
("pc.1.6.2", check_pc_1_6 ¨x + Ó˙ 2*y + x + Ó˙ 3 º y + Ó˙ 2 + Ó˙ 2*x + yÆ, ¨FÆ, true)
];
=TEX
\subsection{Group pc.2}
The proof contexts (error cases)
=SML
store_mt_results_show mt_run_fail [
("pc.2.1", PC_T1"˙_lin_arith"asm_prove_tac[], ([¨x + y º y:˙Æ, ¨Ó˙ 1 º yÆ], mk_f),
		gen_fail_msg"˙_lin_arith_prove_tac" 82200
			[get_message(fail "˙_lin_arith_tac" 82110 [] handle Fail msg => msg),
			string_of_term ¨FÆ])
];
=TEX

=TEX
\section{SUMMARY OF RESULTS}
=SML
diag_string(summarize_mt_results());
=TEX

\end{document}

