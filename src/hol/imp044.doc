%  $Id$ %Z%
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the Theory of Sets}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Theory of Sets}
\TPPref{DS/FMU/IED/IMP044}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document creates the theory ``sets''.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.2]
First version.
\item [Issue 1.3]
Changed to match \cite{DS/FMU/IED/HLD011}.
\item [Issue 1.4]
Simplified requirement on $IsSetRep$.

\item[Issue 1.5, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.6 (23rd January 1992)]
$new\_axiom$, $simple\_new\_type\_defn$ and $new\_type\_defn$
all changed to take lists of keys, rather than single ones.
\item[Issue 1.6 (27th January 1992)]
Corrected a typo.
\end{description}
\subsection{Changes Forecast}
Further theorems, and some function tools will be later provided.
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the theory of sets.
This is called for in \cite{DS/FMU/IED/HLD011}.
The design is in \cite{DS/FMU/IED/DTD044}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the 
theory of sets.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD044},
and also requires the theory ``char'' defined in
\cite{DS/FMU/IED/DTD040}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{THE THEORY ``sets''}
=SML
structure €SetsTheory› : SetsTheory = struct
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",true);
val _ = open_theory "char";
val _ = new_theory "sets";
=TEX
=SML
val €is_set_rep_def› = new_specification(["IsSetRep", "is_set_rep_def"],1, (
push_goal([],¨∂ IsSetRep:('a ≠ BOOL) ≠ BOOL ∑
	IsSetRep = Ã x: 'a ≠ BOOL∑ TÆ);
a(simple_∂_tac ¨Ã x:'a ≠ BOOL∑ TÆ THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €set_def› = new_type_defn(["SET","set_def"],"SET",["'a"],(
push_goal([],¨∂ x: 'a ≠ BOOL ∑ IsSetRep xÆ);
a(rewrite_tac[is_set_rep_def]);
pop_thm()));
=TEX
=SML
val _ = declare_binder "SetComp";
val _ = declare_infix (230,"ç");
val €set_comp_def› = new_specification(["SetComp","ç","set_comp_def"],2,(
push_goal([],¨∂ ($SetComp:('a ≠ BOOL) ≠ 'a SET)
	($ç : 'a ≠ 'a SET ≠ BOOL) ∑
	µ (x : 'a) (p:'a ≠ BOOL) (S1: 'a SET) (S2 : 'a SET)∑
	(x ç (SetComp v ∑p v) § p x) ±
	(S1 = S2 § (µ x:'a∑ x ç S1 § x ç S2))Æ);
a (strip_asm_tac (rewrite_rule [is_set_rep_def]
	(simple_¥_match_mp_rule type_lemmas_thm set_def)));
a(MAP_EVERY simple_∂_tac
	[¨Ã x ∑ abs xÆ,
	¨Ã x S ∑ (rep S) xÆ]);
a(asm_rewrite_tac[]);
a(rewrite_tac[all_µ_intro(eq_sym_rule(all_simple_µ_elim ext_thm))]);
a(REPEAT simple_µ_tac THEN §_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T (ante_tac o ap_fun_rule ¨absÆ));
a(asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €insert_def› = new_specification(["Empty","Insert","insert_def"],2,(
push_goal([],¨∂ (Empty : 'a SET) (Insert: 'a ≠ 'a SET ≠ 'a SET)∑
	µ (x : 'a) (y : 'a) (S: 'a SET) ∑
	≥ x ç Empty ±
	(x ç Insert y S § x = y ≤ x ç S)Æ);
a(MAP_EVERY simple_∂_tac
	[¨{v:'a | (Ã x ∑ F) v}Æ, 
	¨Ã y S ∑ {x | x = y ≤ x ç S}Æ]);
a(rewrite_tac[set_comp_def]);
a(REPEAT simple_µ_tac);
a(LEMMA_T ¨{x:'a | x = y ≤ x ç S} = {x:'a | (Ã x ∑ x = y ≤ x ç S) x}Æ
	(fn x => pure_rewrite_tac[x]));
(* *** Goal "1" *** *)
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[set_comp_def]);
pop_thm()));
=TEX
=SML
val €set_clauses› = save_thm("set_clauses",(
push_goal([],¨µ (x : 'a) (y : 'a) (p:'a ≠ BOOL) (q : BOOL) (S1: 'a SET) (S2 : 'a SET)∑
	≥ x ç {} ±
	(x ç {v | q} § q) ±
	(x ç {v | p v} § p x) ±
	(x ç {v | v = y} § (x = y)) ±
	(x ç {y} § (x = y)) ±
	(S1 = S2 § (µ x:'a∑ x ç S1 § x ç S2))Æ);
a(rewrite_tac[set_comp_def, insert_def]);
a(REPEAT simple_µ_tac);
a(LEMMA_T ¨{v|q} = {v|(Ãs ∑ q) v}Æ (fn x => pure_rewrite_tac[x]));
(* *** Goal "1" *** *)
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[set_comp_def]);
a(LEMMA_T ¨{v|v = y} = {v | (Ã x ∑ x = y) v}Æ (fn x => pure_rewrite_tac[x]));
(* *** Goal "2.1" *** *)
a(rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[set_comp_def]);
pop_thm()));
=TEX
=SML
local
	val aux_thm = tac_proof(([],¨
		µ x : 'a ∑
		µ p : 'a ≠ BOOL ∑
		x ç {v | p v} § p xÆ),
		rewrite_tac[set_clauses]);
	val tva = ¨:'aÆ;
in
val €simple_ç_conv› : CONV = (fn tm:TERM =>
let	val (x,S) = dest_bin_op "simple_ç_conv" 44001 "ç" tm;
	val (v,pv) = dest_set_comp S;
	val sideeffect = (if is_var v
		then ()
		else term_fail "simple_ç_conv" 44001 [tm]);
	val s1 = inst_type_rule [(type_of x, tva)] aux_thm;
	val s2 = list_simple_µ_elim[x, 
		mk_simple_Ã(v,pv)] s1;
	val s3 =  conv_rule (APP_C
		((RAND_C o RAND_C o BINDER_C) simple_%beta%_conv,
		simple_%beta%_conv))s2;
	val s4 = eq_trans_rule (%alpha%_conv 
		(fst(dest_§(concl s3))) tm)
		s3
in
	s4
end);
end;
=TEX
\subsection{Derived Definitions}
=SML
val _ = declare_infix (260,"¿");
val €¿_def› = new_specification(["¿","¿_def"],1,(
push_goal([],¨∂ $¿: 'a SET ≠ 'a SET ≠ 'a SET ∑
	µ (x:'a) (S1 : 'a SET) (S2 : 'a SET) ∑ 
	x ç S1 ¿ S2 § x ç S1 ≤ x ç S2Æ);
a(simple_∂_tac ¨Ã S1 S2 ∑ {x : 'a | x ç S1 ≤ x ç S2}Æ
	THEN rewrite_tac[]);
a(conv_tac(ONCE_MAP_C simple_ç_conv) THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val _ = declare_infix (270,"°");
val €°_def› = new_specification(["°","°_def"],1,(
push_goal([],¨∂ $°: 'a SET ≠ 'a SET ≠ 'a SET ∑
	µ (x:'a) (S1 : 'a SET) (S2 : 'a SET) ∑ 
	x ç S1 ° S2 § x ç S1 ± x ç S2Æ);
a(simple_∂_tac ¨Ã S1 S2 ∑ {x : 'a | x ç S1 ± x ç S2}Æ
	THEN rewrite_tac[]);
a(conv_tac(ONCE_MAP_C simple_ç_conv) THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val _ = declare_infix (250,"\\");
val €set_sub_def› = new_specification(["\\","set_sub_def"],1,(
push_goal([],¨∂ $\: 'a SET ≠ 'a SET ≠ 'a SET ∑
	µ (x:'a) (S1 : 'a SET) (S2 : 'a SET) ∑ 
	x ç S1 \ S2 § x ç S1 ± ≥ x ç S2Æ);
a(simple_∂_tac ¨Ã S1 S2 ∑ {x : 'a | x ç S1 ± ≥ x ç S2}Æ
	THEN rewrite_tac[]);
a(conv_tac(ONCE_MAP_C simple_ç_conv) THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val _ = declare_infix (230,"Ä");
val €Ä_def› = new_specification(["Ä","Ä_def"],1,(
push_goal([],¨∂ $Ä : 'a SET ≠ 'a SET ≠ BOOL ∑
	µ S1 S2 : 'a SET ∑ 
	S1 Ä S2 § µ x ∑ x ç S1 ¥ x ç S2Æ);
a(simple_∂_tac ¨Ã S1 S2 ∑ µ x ∑ x ç S1 ¥ x ç S2Æ
	THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val _ = declare_infix (230,"†");
val €†_def› = new_specification(["†","†_def"],1,(
push_goal([],¨∂ $† : 'a SET ≠ 'a SET ≠ BOOL ∑
	µ S1 S2 : 'a SET ∑ 
	S1 † S2 § (S1 Ä S2 ± (∂ x ∑ ≥ x ç S1 ± x ç S2))Æ);
a(simple_∂_tac ¨Ã S1 S2 ∑ (S1 Ä S2 ± (∂ x ∑ ≥ x ç S1 ± x ç S2))Æ
	THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €ﬁ_def› = new_specification(["ﬁ","ﬁ_def"],1,(
push_goal([],¨∂ ﬁ : ('a SET) SET ≠ 'a SET ∑ 
	µ (x: 'a) (S: ('a SET) SET) ∑ 
	x ç ﬁ S § ∂ s ∑ x ç s ± s ç SÆ);
a(simple_∂_tac ¨Ã S ∑ {x | ∂ s ∑ x ç s ± s ç S}Æ
	THEN rewrite_tac[]);
a(conv_tac(ONCE_MAP_C simple_ç_conv) THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €•_def› = new_specification(["•","•_def"],1,(
push_goal([],¨∂ • : ('a SET) SET ≠ 'a SET ∑ 
	µ (x: 'a) (S: ('a SET) SET) ∑ 
	(x ç • S) § µ s ∑ s ç S ¥ x ç sÆ);
a(simple_∂_tac ¨Ã S ∑ {x | µ s ∑ s ç S ¥ x ç s}Æ
	THEN rewrite_tac[]);
a(conv_tac(ONCE_MAP_C simple_ç_conv) THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €_def› = new_specification(["","_def"],1,(
push_goal([],¨∂ :'a SET ≠ ('a SET) SET ∑
	µ (x : 'a SET) (S: 'a SET) ∑ 
	x ç  S § x Ä SÆ);
a(simple_∂_tac ¨Ã S ∑ {x | x Ä S}Æ
	THEN rewrite_tac[]);
a(conv_tac(ONCE_MAP_C simple_ç_conv) THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €ö_clauses› = save_thm("ö_clauses",(
push_goal([], ¨µ (x : 'a) (S:'a SET) ∑
	{x | F} = {} ±
	≥ x ç {} ±
	{} ¿ S = S ±
	S ¿ {} = S ±
	{} ° S = {} ±
	S ° {} = {} ±
	S \ {} = S ±
	{} \ S = {} ±
	{} Ä S ±
	(S Ä {} § S = {}) ±
	({} † S § ≥ S = {}) ±
	≥ S † {} ±
	≥ x ç ﬁ {} ±
	x ç • {} ±
	{} ç  S ±
	( {} = {{}})Æ);
a(REPEAT simple_µ_tac THEN rewrite_tac[set_clauses,
	¿_def, °_def, set_sub_def, Ä_def, †_def, ﬁ_def, •_def, _def]);
a(conv_tac(MAP_C simple_≥_in_conv) THEN rewrite_tac[]);
pop_thm()));
=TEX
\subsection{End of Theory ``sets''}
=SML
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",
	lsubgoal_package_quiet);
end; (* of structure SetsTheory *)
open SetsTheory;
=TEX
\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


