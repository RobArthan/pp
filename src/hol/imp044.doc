%  $Id$ %Z%
=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Implementation for the Theory of Sets}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Theory of Sets}
\TPPref{DS/FMU/IED/IMP044}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document creates the theory ``set''.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\end{description}
\subsection{Changes Forecast}
Further theorems, and some function tools will be later provided.
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the theory of sets.
This is called for in \cite{DS/FMU/IED/HLD011}.
The design is in \cite{DS/FMU/IED/DTD044}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the 
theory of sets.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD044},
and also requires the theory ``pair'' defined in
\cite{DS/FMU/IED/DTD037}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{THE THEORY ``set''}
=SML
(* structure ‚SetTheory· : SetTheory = struct *)
val _ = new_theory "set";
=TEX
=SML
val is_set_rep_thm = new_specification(["IsSetRep"],1, (
push_goal([],ªÑ IsSetRep:('a ã BOOL) ã BOOL é
	 Ñ (mem:'a ã ('a ã BOOL) ã BOOL)
		(setcomp:('a ã BOOL) ã ('a ã BOOL)) é 
	É (x : 'a) (p:'a ã BOOL) (S1: 'a ã BOOL) (S2 : 'a ã BOOL)é
	IsSetRep (setcomp S1) Ä
	(mem x (setcomp(ç v ép v)) Ç p x) Ä
	(IsSetRep S1 Ä IsSetRep S2 ä
	 ((S1 = S2) Ç (É x:'aé mem x S1 Ç mem x S2)))º);
a(MAP_EVERY simple_Ñ_tac [ªç x:'a ã BOOLé Tº, 
	ªç x (S:'a ã BOOL) éS xº,
	ªç x :('a ã BOOL) é xº]
	THEN rewrite_tac[]);
a(rewrite_tac[ext_thm]);
pop_thm()));
=TEX
=SML
val set_def = new_type_defn("SET","SET",["'a"],(
push_goal([],ªÑ x: 'a ã BOOL é IsSetRep xº);
a(strip_asm_tac is_set_rep_thm);
a(simple_Ñ_tac ªsetcomp xº);
a(asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val _ = declare_binder "SetComp";
val _ = declare_infix (160,"ù");
val ‚set_comp_def· = new_specification(["SetComp","ù"],2,(
push_goal([],ªÑ ($SetComp:('a ã BOOL) ã 'a SET)
	($ù : 'a ã 'a SET ã BOOL) é
	É (x : 'a) (p:'a ã BOOL) (S1: 'a SET) (S2 : 'a SET)é
	(x ù (SetComp v ép v) Ç p x) Ä
	((S1 = S2) Ç (É x:'aé x ù S1 Ç x ù S2))º);
a (strip_asm_tac (simple_ä_match_mp_rule type_lemmas_thm set_def));
a(strip_asm_tac is_set_rep_thm);
a(MAP_EVERY simple_Ñ_tac
	[ªç x é abs (setcomp x)º,
	ªç x S é mem x (rep S)º]);
a(rewrite_tac[]);
a(GET_NTH_ASM_T 2 (fn th1 => DROP_NTH_ASM_T 1 (fn th2
	=> asm_tac (rewrite_rule [th1] th2))));
a(asm_rewrite_tac[]);
a(POP_ASM_T(MAP_EVERY (strip_asm_tac o all_É_intro) o strip_Ä_rule o all_simple_É_elim));
a(REPEAT simple_É_tac);
a(POP_ASM_T(ante_tac o list_simple_É_elim[ªrep S1º,ªrep S2º]));
a(asm_rewrite_tac[]);
a(ä_T(fn x => rewrite_tac[eq_sym_rule x]));
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T (ante_tac o ap_fun_rule ªabsº));
a(asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val ‚insert_def· = new_specification(["Empty","Insert"],2,(
push_goal([],ªÑ (Empty : 'a SET) (Insert: 'a ã 'a SET ã 'a SET)é
	É (x : 'a) (y : 'a) (S: 'a SET) é
	å(x ù Empty) Ä
	(x ù Insert y S Ç (x = y Å x ù S))º);
a(MAP_EVERY simple_Ñ_tac
	[ª{v:'a | (ç x é F) v}º, 
	ªç y S é {x | x = y Å x ù S}º]);
a(rewrite_tac[set_comp_def]);
a(REPEAT simple_É_tac);
a(LEMMA_T ª{x:'a | x = y Å x ù S} = {x:'a | (ç x é x = y Å x ù S) x}º
	(fn x => pure_rewrite_tac[x]));
(* *** Goal "1" *** *)
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[set_comp_def]);
pop_thm()));
=TEX
=SML
val ‚set_clauses· = save_thm("set_clauses",(
push_goal([],ªÉ (x : 'a) (y : 'a) (p:'a ã BOOL) (q : BOOL) (S1: 'a SET) (S2 : 'a SET)é
	å(x ù {}) Ä
	((x ù {v | q}) Ç q) Ä
	(x ù {v | p v} Ç p x) Ä
	(x ù {v | v = y} Ç (x = y)) Ä
	((S1 = S2) Ç (É x:'aé x ù S1 Ç x ù S2))º);
a(rewrite_tac[set_comp_def, insert_def]);
a(REPEAT simple_É_tac);
a(LEMMA_T ª{v|q} = {v|(çs é q) v}º (fn x => pure_rewrite_tac[x]));
(* *** Goal "1" *** *)
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[set_comp_def]);
a(LEMMA_T ª{v|v = y} = {v | (ç x é x = y) v}º (fn x => pure_rewrite_tac[x]));
(* *** Goal "2.1" *** *)
a(rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[set_comp_def]);
pop_thm()));
=TEX
=SML
local
	val aux_thm = tac_proof(([],ª
		É x : 'a é
		É p : 'a ã BOOL é
		x ù {v | p v} Ç p xº),
		rewrite_tac[set_clauses]);
	val tva = ª:'aº;
in
val ‚simple_ù_conv· : CONV = (fn tm:TERM =>
let	val (x,S) = dest_bin_op "ù_conv" 44001 "ù" tm;
	val (v,pv) = dest_set_comp S;
	val s1 = inst_type_rule [(type_of x, tva)] aux_thm;
	val s2 = list_simple_É_elim[x, 
		mk_app(simple_mk_ç(v,pv),v)] s1;
	val s3 =  conv_rule ((BINDER_C o RAND_C o RAND_C o RATOR_C) 
		simple_%beta%_conv) s2;
	val s4 = eq_trans_rule (%alpha%_conv 
		(fst(dest_Ç(concl s3))) tm)
		s3
in
	s4
end);
end;
=TEX
\subsection{Derived Definitions}
=SML
declare_infix (170,"°");
val °_def = new_specification("",1,(
push_goal([],ªÑ $°: 'a SET ã 'a SET ã 'a SET é
	É (x:'a) (S1 : 'a SET) (S2 : 'a SET) é 
	(x ù S1 ° S2) Ç (x ù S1 Å x ù S2)º);
a(simple_Ñ_tac ªç S1 S2 é {x : 'a | x ù S1 Å x ù S2}º
	THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
declare_infix (170,"†");
val †_def = new_specification("",1,(
push_goal([],ªÑ $†: 'a SET ã 'a SET ã 'a SET é
	É (x:'a) (S1 : 'a SET) (S2 : 'a SET) é 
	(x ù S1 † S2) Ç (x ù S1 Ä x ù S2)º);
a(simple_Ñ_tac ªº);
pop_thm()));
=TEX
=SML
declare_infix (170,"ƒ");
val ƒ_def = new_specification("ƒ",1,(
push_goal([],ªÑ $ƒ: 'a SET ã 'a SET ã 'a SET é
	É (x:'a) (S1 : 'a SET) (S2 : 'a SET) é 
	(x ù S1 ƒ S2) Ç (x ù S1 Ä å (x ù S2))º);
a(simple_Ñ_tac ªº);
pop_thm()));
=TEX
=SML
declare_infix (50,"•");
val •_def = new_specification("•",1,(
push_goal([],ªÑ $• : 'a SET ã 'a SET ã BOOL é
	É S1 S2 : 'a SET é 
	(S1 • S2) Ç É x é x ù S1 ä x ù S2º);
a(simple_Ñ_tac ªº);
pop_thm()));
=TEX
=SML
declare_infix (50,"¶");
val ¶_def = new_specification("¶",1,(
push_goal([],ªÑ $¶ : 'a SET ã 'a SET ã BOOL é
	É S1 S2 : 'a SET é 
	(S1 ¶ S2) Ç ((S1 • S2) Ä (Ñ x é å(x ù S1) Ä (x ù S2)))º);
a(simple_Ñ_tac ªº);
pop_thm()));
=TEX
=SML
val £_def = new_specification("£",1,(
push_goal([],ªÑ £ : ('a SET) SET ã 'a SET é 
	É (x: 'a) (S: ('a SET) SET) é 
	(x ù £ S) Ç Ñ s é x ù s Ä s ù Sº);
a(simple_Ñ_tac ªº);
pop_thm()));
=TEX
=SML
val ¢_def = new_specification("¢",1,(
push_goal([],ªÑ ¢ : ('a SET) SET ã 'a SET é 
	É (x: 'a) (S: ('a SET) SET) é 
	(x ù ¢ S) Ç É s é s ù S ä x ù sº);
a(simple_Ñ_tac ªº);
pop_thm()));
=TEX
=SML
val ë_def = new_specification("ë",1,(
push_goal([],ªÑ ë::'a SET ã ('a SET) SET é
	É (x : 'a SET) (S: 'a SET) é 
	(x ù ë S) Ç x • Sº);
a(simple_Ñ_tac ªº);
pop_thm()));
=TEX
\subsection{End of Theory ``set''}
=SML
end; (* of structure SetTheory *)
open SetTheory;
=TEX
=TEX
\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
