%  imp044.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the Theory of Sets}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Theory of Sets}
\TPPref{DS/FMU/IED/IMP044}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document creates the theory ``sets''.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.2]
First version.
\item [Issue 1.3]
Changed to match \cite{DS/FMU/IED/HLD011}.
\item [Issue 1.4]
Simplified requirement on $IsSetRep$.

\item[Issue 1.5, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.6 (23rd January 1992)]
$new\_axiom$, $simple\_new\_type\_defn$, $new\_type\_defn$
all changed to take lists of keys, rather than single ones.
\item[Issue 1.7 (27th January 1992)]
Corrected a typo.
\item [Issue 1.8 (7th February 1992)]
Made ``basic$\_$hol'' a parent.
\item [Issue 1.10 (13th April 1992)]
Changes due to CR0017.
\item[Issue 1.12 (15 May 1992)] Use correct quotation symbols.
\end{description}
\subsection{Changes Forecast}
Further theorems, and some function tools will be later provided.
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the theory of sets.
This is called for in \cite{DS/FMU/IED/HLD011}.
The design is in \cite{DS/FMU/IED/DTD044}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the 
theory of sets.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD044},
and also requires the theory ``char'' defined in
\cite{DS/FMU/IED/DTD040}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{THE THEORY ``sets''}
=SML
structure €SetsTheory› : SetsTheory = struct
val _ = push_pc "pair";
val _ = open_theory "basic_hol";
val _ = (delete_theory "hol" handle ? => ());
val _ = (delete_theory "sets" handle ? => ());
val _ = new_theory "sets";
=TEX
=SML
val €is_set_rep_def› = new_spec(["IsSetRep", "is_set_rep_def"],1, (
push_goal([],¨∂ IsSetRep:('a ≠ BOOL) ≠ BOOL ∑
	IsSetRep = Ã x: 'a ≠ BOOL∑ TÆ);
a(simple_∂_tac ¨Ã x:'a ≠ BOOL∑ TÆ THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €set_def› = new_type_defn(["SET","set_def"],"SET",["'a"],(
push_goal([],¨∂ x: 'a ≠ BOOL ∑ IsSetRep xÆ);
a(rewrite_tac[is_set_rep_def]);
pop_thm()));
=TEX
=SML
val _ = declare_binder "SetComp";
val _ = declare_infix (230,"ç");
val €set_comp_def› = new_spec(["SetComp","ç","set_comp_def"],2,(
push_goal([],¨∂ ($SetComp:('a ≠ BOOL) ≠ 'a SET)
	($ç : 'a ≠ 'a SET ≠ BOOL) ∑
	µ (x : 'a) (p:'a ≠ BOOL) (a: 'a SET) (b : 'a SET)∑
	(x ç (SetComp v ∑p v) § p x) ±
	(a = b § (µ x:'a∑ x ç a § x ç b))Æ);
a (strip_asm_tac (rewrite_rule [is_set_rep_def]
	(simple_¥_match_mp_rule type_lemmas_thm set_def)));
a(MAP_EVERY simple_∂_tac
	[¨Ã x ∑ abs xÆ,
	¨Ã x a ∑ (rep a) xÆ]);
a(asm_rewrite_tac[]);
a(rewrite_tac[all_µ_intro(eq_sym_rule(all_simple_µ_elim ext_thm))]);
a(REPEAT simple_µ_tac THEN §_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T (ante_tac o app_fun_rule ¨absÆ));
a(asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €insert_def› = new_spec(["Empty","Universe","Insert","insert_def"],3,(
push_goal([],¨
∂ (Empty : 'a SET) (Universe : 'a SET) (Insert: 'a ≠ 'a SET ≠ 'a SET)∑
	µ (x : 'a) (y : 'a) (a: 'a SET) ∑
		≥ x ç Empty
	±	(x ç Universe)
	±	(x ç Insert y a § (x = y ≤ x ç a))Æ);
a(MAP_EVERY simple_∂_tac
	[¨{v:'a | (Ã x ∑ F) v}Æ, 
	¨{v:'a | (Ã x ∑ T) v}Æ, 
	¨Ã y a ∑ {x | x = y ≤ x ç a}Æ]);
a(rewrite_tac[set_comp_def]);
a(REPEAT simple_µ_tac);
a(LEMMA_T ¨{x:'a | x = y ≤ x ç a} = {x:'a | (Ã x ∑ x = y ≤ x ç a) x}Æ
	(fn x => pure_rewrite_tac[x]));
(* *** Goal "1" *** *)
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[set_comp_def]);
pop_thm()));
=TEX
=SML

val €sets_ext_thm› = (
push_goal([],¨	µ (a : 'a SET) (b : 'a SET)∑
	a = b § µ (x : 'a)∑ x ç a § x ç bÆ);
a (rewrite_tac [set_comp_def]);
pop_thm());

val €sets_clauses› = save_thm("sets_clauses",(
push_goal([],¨
	µ (x : 'a) (y : 'a) (p:'a ≠ BOOL) (q : BOOL)∑
	(x ç {} § F) ±
	(x ç Universe § T) ±
	((x ç {v | q}) § q) ±
	(x ç {v | p v} § p x) ±
	(x ç {v | v = y} § (x = y)) ±
	(x ç {y} § (x = y))Æ);
a(rewrite_tac[set_comp_def, insert_def]);
a(REPEAT simple_µ_tac);
a(LEMMA_T ¨{v|q} = {v|(Ãs ∑ q) v}Æ (fn x => pure_rewrite_tac[x]));
(* *** Goal "1" *** *)
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[set_comp_def]);
a(LEMMA_T ¨{v|v = y} = {v | (Ã x ∑ x = y) v}Æ (fn x => pure_rewrite_tac[x]));
(* *** Goal "2.1" *** *)
a(rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(rewrite_tac[set_comp_def]);
pop_thm()));
=TEX
=SML
local
	val aux_thm = tac_proof(([],¨
		µ x : 'a ∑
		µ p : 'a ≠ BOOL ∑
		x ç {v | p v} § p xÆ),
		rewrite_tac[sets_clauses]);
	val tva = î'aÆ;
in
val €simple_ç_comp_conv› : CONV = (fn tm:TERM =>
let	val (x,S) = dest_bin_op "simple_ç_comp_conv" 44001 "ç" tm;
	val (v,pv) = dest_set_comp S;
	val sideeffect = (if is_var v
		then ()
		else term_fail "simple_ç_comp_conv" 44001 [tm]);
	val s1 = inst_type_rule [(type_of x, tva)] aux_thm;
	val s2 = list_simple_µ_elim[x, 
		mk_simple_Ã(v,pv)] s1;
	val s3 =  conv_rule (APP_C
		((RAND_C o RAND_C o SIMPLE_BINDER_C) simple_¬_conv,
		simple_¬_conv))s2;
	val s4 = eq_trans_rule (¡_conv 
		(fst(dest_§(concl s3))) tm)
		s3
in
	s4
end);
end;
=TEX
\subsection{Derived Definitions}
=SML
val €complement_def› = new_spec(["~","complement_def"],1,(
push_goal([],¨∂(~ : 'a SET ≠ 'a SET)∑
	µ (x : 'a) (a: 'a SET) ∑
	(x ç ~ a § ≥ x ç a)Æ);
a(simple_∂_tac ¨Ã a : 'a SET ∑ {x : 'a | ≥ x ç a}Æ
	THEN rewrite_tac[]);
a(conv_tac(ONCE_MAP_C simple_ç_comp_conv) THEN rewrite_tac[]);
pop_thm()));

val €complement_clauses› = save_thm("complement_clauses",(
push_goal([], ¨
	(µ (x : 'a) (a: 'a SET) ∑(x ç ~ a § ≥ x ç a)) ±
		(~ Universe = {})
	±	(~ {} = Universe)Æ);
a (rewrite_tac [sets_ext_thm, sets_clauses, complement_def, insert_def]);
pop_thm()));

val _ = declare_infix (260,"¿");
val €¿_def› = new_spec(["¿","¿_def"],1,(
push_goal([],¨∂ $¿: 'a SET ≠ 'a SET ≠ 'a SET ∑
	µ (x:'a) (a : 'a SET) (b : 'a SET) ∑ 
	x ç a ¿ b § x ç a ≤ x ç bÆ);
a(simple_∂_tac ¨Ã a b ∑ {x : 'a | x ç a ≤ x ç b}Æ
	THEN rewrite_tac[]);
a(conv_tac(ONCE_MAP_C simple_ç_comp_conv) THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €¿_clauses› = save_thm("¿_clauses",(
push_goal([], ¨
	µ (a: 'a SET)∑
		(a ¿ {} = a)
	±	({} ¿ a = a)
	±	(a ¿ Universe = Universe)
	±	(Universe ¿ a = Universe)
	±	(a ¿ a = a)Æ);
a (rewrite_tac [sets_ext_thm, set_comp_def, insert_def, ¿_def]);
pop_thm()));
=TEX
=SML
val _ = declare_infix (270,"°");
val €°_def› = new_spec(["°","°_def"],1,(
push_goal([],¨∂ $°: 'a SET ≠ 'a SET ≠ 'a SET ∑
	µ (x:'a) (a : 'a SET) (b : 'a SET) ∑ 
	x ç a ° b § x ç a ± x ç bÆ);
a(simple_∂_tac ¨Ã a b ∑ {x : 'a | x ç a ± x ç b}Æ
	THEN rewrite_tac[]);
a(conv_tac(ONCE_MAP_C simple_ç_comp_conv) THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €°_clauses› = save_thm("°_clauses",(
push_goal([], ¨
	µ (a: 'a SET)∑
		(a ° {} = {})
	±	({} ° a = {})
	±	(a ° Universe = a)
	±	(Universe ° a = a)
	±	(a ° a = a)Æ);
a (rewrite_tac [sets_ext_thm, set_comp_def, insert_def, °_def]);
pop_thm()));
=TEX
=SML
val _ = declare_infix (250,"\\");
val €set_dif_def› = new_spec(["\\","set_dif_def"],1,(
push_goal([],¨∂ $\: 'a SET ≠ 'a SET ≠ 'a SET ∑
	µ (x:'a) (a : 'a SET) (b : 'a SET) ∑ 
	x ç a \ b § x ç a ± ≥ x ç bÆ);
a(simple_∂_tac ¨Ã a b ∑ {x : 'a | x ç a ± ≥ x ç b}Æ
	THEN rewrite_tac[]);
a(conv_tac(ONCE_MAP_C simple_ç_comp_conv) THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €set_dif_clauses› = save_thm("set_dif_clauses",(
push_goal([], ¨
	µ (a: 'a SET)∑
		(a \ {} = a)
	±	({} \ a = {})
	±	(a \ Universe = {})
	±	(Universe \ a = ~ a)
	±	(a \ a = {})Æ);
a (rewrite_tac [set_comp_def, insert_def, set_dif_def, complement_def]);
a contr_tac;
pop_thm()));
=TEX
=SML
val _ = declare_infix (230,"Ä");
val €Ä_def› = new_spec(["Ä","Ä_def"],1,(
push_goal([],¨∂ $Ä : 'a SET ≠ 'a SET ≠ BOOL ∑
	µ a b : 'a SET ∑ 
	a Ä b § µ x ∑ x ç a ¥ x ç bÆ);
a(simple_∂_tac ¨Ã a b ∑ µ x ∑ x ç a ¥ x ç bÆ
	THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €Ä_clauses› = save_thm("Ä_clauses",(
push_goal([], ¨
	µ (a: 'a SET)∑
		(a Ä a)
	±	({} Ä a)
	±	(a Ä Universe)Æ);
a (rewrite_tac [Ä_def, insert_def]);
pop_thm()));
=TEX
=SML
val _ = declare_infix (230,"†");
val €†_def› = new_spec(["†","†_def"],1,(
push_goal([],¨∂ $† : 'a SET ≠ 'a SET ≠ BOOL ∑
	µ a b : 'a SET ∑ 
	a † b § (a Ä b ± (∂ x ∑ ≥ x ç a ± x ç b))Æ);
a(simple_∂_tac ¨Ã a b ∑ (a Ä b ± (∂ x ∑ ≥ x ç a ± x ç b))Æ
	THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €†_clauses› = save_thm("†_clauses",(
push_goal([], ¨
	µ (a: 'a SET)∑
		≥ (a † a)
	±	≥ (a † {})
	±	({} † Universe)Æ);
a (rewrite_tac [†_def, Ä_def, insert_def]);
a contr_tac;
pop_thm()));
=TEX
=SML
val €ﬁ_def› = new_spec(["ﬁ","ﬁ_def"],1,(
push_goal([],¨∂ ﬁ : ('a SET) SET ≠ 'a SET ∑ 
	µ (x: 'a) (a: ('a SET) SET) ∑ 
	x ç ﬁ a § ∂ s ∑ x ç s ± s ç aÆ);
a(simple_∂_tac ¨Ã a ∑ {x | ∂ s ∑ x ç s ± s ç a}Æ
	THEN rewrite_tac[]);
a(conv_tac(ONCE_MAP_C simple_ç_comp_conv) THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €ﬁ_clauses› = save_thm("ﬁ_clauses",(
push_goal([], ¨
		(ﬁ ({}:'a SET SET) = {})
	±	(ﬁ (Universe: 'a SET SET) = Universe)Æ);
a (rewrite_tac [sets_ext_thm, ﬁ_def, insert_def]);
a µ_tac;
a (simple_∂_tac ¨{x}Æ);
a (rewrite_tac [insert_def]);
pop_thm()));
=TEX
=SML
val €•_def› = new_spec(["•","•_def"],1,(
push_goal([],¨∂ • : ('a SET) SET ≠ 'a SET ∑ 
	µ (x: 'a) (a: ('a SET) SET) ∑ 
	(x ç • a) § µ s ∑ s ç a ¥ x ç sÆ);
a(simple_∂_tac ¨Ã a ∑ {x | µ s ∑ s ç a ¥ x ç s}Æ
	THEN rewrite_tac[]);
a(conv_tac(ONCE_MAP_C simple_ç_comp_conv) THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €•_clauses› = save_thm("•_clauses",(
push_goal([], ¨
	(• ({}: 'a SET SET) = Universe)
	±	(• Universe = ({}:'a SET SET))Æ);
a (rewrite_tac [sets_ext_thm, •_def, insert_def]);
a (REPEAT strip_tac);
a (simple_∂_tac ¨{}:'a SET SETÆ);
a (rewrite_tac [insert_def]);
pop_thm()));
=TEX
=SML
val €_def› = new_spec(["","_def"],1,(
push_goal([],¨∂ :'a SET ≠ ('a SET) SET ∑
	µ (x : 'a SET) (a: 'a SET) ∑ 
	x ç  a § x Ä aÆ);
a(simple_∂_tac ¨Ã a ∑ {x | x Ä a}Æ
	THEN rewrite_tac[]);
a(conv_tac(ONCE_MAP_C simple_ç_comp_conv) THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €_clauses› = save_thm("_clauses",(
push_goal([], ¨
	µ (a:'a SET)∑
		( {} = {{}})
	±	( Universe = Universe)
	±	a ç  a
	±	{} ç  aÆ);
a (rewrite_tac [sets_ext_thm, insert_def, _def, Ä_def]);
pop_thm()));
=TEX
=SML
val €ö_clauses› = save_thm("ö_clauses",(
push_goal([], ¨µ (x : 'a) (a:'a SET) ∑
	{x | F} = {} ±
	≥ x ç {} ±
	{} ¿ a = a ±
	a ¿ {} = a ±
	{} ° a = {} ±
	a ° {} = {} ±
	a \ {} = a ±
	{} \ a = {} ±
	{} Ä a ±
	(a Ä {} § a = {}) ±
	({} † a § ≥ a = {}) ±
	≥ a † {} ±
	≥ x ç ﬁ {} ±
	x ç • {} ±
	{} ç  a ±
	( {} = {{}})Æ);
a(REPEAT simple_µ_tac THEN rewrite_tac[sets_clauses, sets_ext_thm,
	¿_def, °_def, set_dif_def, Ä_def, †_def, ﬁ_def, •_def, _def]);
a(conv_tac(MAP_C simple_≥_in_conv) THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €ç_in_clauses› = save_thm("ç_in_clauses",(
push_goal([], ¨
	(µ (x : 'a) (y : 'a) (a: 'a SET) ∑
		(x ç {} § F)
	±	(x ç Insert y a § (x = y ≤ x ç a)))
±	(µ (x:'a) (a : 'a SET) (b : 'a SET) ∑
		(x ç a ¿ b § x ç a ≤ x ç b)
	±	(x ç a ° b § x ç a ± x ç b)
	±	(x ç a \ b § x ç a ± ≥ x ç b))
±	(µ (x:'a) (a : 'a SET SET) ∑
		(x ç ﬁ a § ∂ s ∑ x ç s ± s ç a)
	±	((x ç • a) § µ s ∑ s ç a ¥ x ç s)
±	(µ (x : 'a SET) (a : 'a SET) ∑(x ç  a § x Ä a)))Æ);
a(rewrite_tac[sets_clauses, sets_ext_thm, insert_def, ¿_def, °_def, set_dif_def, Ä_def,
	†_def, ﬁ_def, •_def, _def]
	THEN REPEAT strip_tac);
pop_thm()));
=TEX
=SML
val €sets_ext_clauses› = save_thm("sets_ext_clauses",(
push_goal([], ¨µ(a : 'a SET) (b : 'a SET) ∑
	((a † b) § ((µ x ∑ x ç a ¥ x ç b) ± (∂ x ∑ ≥(x ç a) ± (x ç b))))
±	((a Ä b) § µ x ∑ x ç a ¥ x ç b)
±	((a = b) § (µ x:'a∑ x ç a § x ç b))Æ);
a(rewrite_tac[sets_clauses, sets_ext_thm, insert_def, ¿_def, °_def, set_dif_def, Ä_def,
	†_def, ﬁ_def, •_def, _def]
	THEN REPEAT strip_tac);
pop_thm()));
=TEX
\subsection{End of Theory ``sets''}
We wish to make the pre-existing theory ``hol''
have this theory as a parent:
=SML
(*val _ = open_theory "hol";
val _ = new_parent "sets";*)
=TEX
\section{CONVERSIONS}
=SML
local
	val €tva› = î'aÆ;
	val aux_thm = tac_proof(([],¨
		µ x : 'a ∑
		µ p : 'a ≠ BOOL ∑
		x ç {v | p v} § p xÆ),
		rewrite_tac[sets_clauses]);
in
val €ç_comp_conv› : CONV = (fn tm:TERM =>
let	val (x,S) = dest_bin_op "ç_comp_conv" 27002 "ç" tm;
	val (v,pv) = dest_set_comp S;
	val s1 = inst_type_rule [(type_of x, tva)] aux_thm;
	val s2 = list_µ_elim[x, mk_Ã(v,pv)] s1;
in
if is_var v
then (let val s3 =  conv_rule (APP_C
		((RAND_C o RAND_C o SIMPLE_BINDER_C) simple_¬_conv,
		simple_¬_conv))s2;
	val s4 = eq_trans_rule (¡_conv 
		(fst(dest_§(concl s3))) tm)
		s3;
in
	s4
end)
else (let val s3 = conv_rule (RATOR_C(RAND_C(RAND_C (RAND_C
	(Ã_varstruct_conv (mk_Ã(v,mk_app(mk_Ã(v,pv),v)))))))) s2;
	val s4 = conv_rule (APP_C
		((RAND_C o RAND_C o BINDER_C) ¬_conv,
		¬_conv))s3;
	val s5 = eq_trans_rule (refl_conv tm) s4;
in
	s5
end)
end
handle (Fail _) =>
term_fail "ç_comp_conv" 27002 [tm])
end;
=TEX
=SML
local
	val prc = pure_rewrite_conv[insert_def, ≤_rewrite_thm, 
		eq_rewrite_thm];
in
fun €ç_enum_set_rule› (tm : TERM) (tml : TERM list): THM = (
	if not(tm term_mem tml)
	then term_fail "ç_enum_set_rule" 27001 [tm]
	else 
(let	val es = mk_enum_set tml
		handle complaint =>
		pass_on complaint "mk_enum_set" "ç_enum_set_rule" ;
	val ttm = type_of tm;
	val tes = type_of es;
	val conc = list_mk_app(mk_const("ç",mk_≠_type(ttm,
		mk_≠_type(tes,BOOL))),
		[tm,es]);
	val s1 = prc conc;
	val s2 = eq_sym_rule s1;
	val s3 = §_mp_rule s2 t_thm;
in
	s3
end));
end;
val €ç_enum_set_conv› : CONV = (fn tm =>
let	val (x,s) = dest_bin_op "ç_enum_set_conv" 27006 "ç" tm;
	val ss = dest_enum_set s;
in
	§_t_intro (ç_enum_set_rule x ss)
	handle complaint =>
	if area_of complaint = "ç_enum_set_rule"
	then term_fail "ç_enum_set_conv" 27005 [x,s]
	else reraise complaint(area_of complaint)
end);
=TEX
\section{PROOF CONTEXTS}
The extensional context is good for proving results involving the operators introduced in this theory.
=SML
val pos_bits = 
	[(¨x ç $SetComp yÆ, ç_comp_conv),
	(¨x ç $Insert y zÆ, ç_enum_set_conv)] @
	(cthm_eqn_cxt initial_rw_canon ç_in_clauses) @
	(cthm_eqn_cxt initial_rw_canon sets_ext_clauses);
val neg_bits = map (mk_≥ ** RAND_C) pos_bits;
val new_bits = pos_bits @ neg_bits;
val rw_eqn_cxt =
	(¨x ç $SetComp yÆ, ç_comp_conv) ::
	(¨x ç $Insert y zÆ, ç_enum_set_conv) ::
	(flat(map (cthm_eqn_cxt initial_rw_canon) [ç_in_clauses,sets_ext_clauses]));
val dummy = (delete_pc "sets_ext" handle ? => ());
val dummy = new_pc "sets_ext";
val dummy = merge_pcs ["pair"] "sets_ext";
val dummy = ((set_st_eqn_cxt new_bits "sets_ext");
		(set_sg_eqn_cxt new_bits "sets_ext");
		(set_rw_eqn_cxt rw_eqn_cxt "sets_ext"));
=TEX
The algebraic context is for more general use where obvious simplifications are required.
=SML
val pos_bits = 
	[(¨x ç $SetComp yÆ, ç_comp_conv),
	(¨x ç $Insert y zÆ, ç_enum_set_conv)] @
	(cthm_eqn_cxt initial_rw_canon ç_in_clauses);
val neg_strips = map (mk_≥ ** RAND_C) pos_bits;
val new_strips = pos_bits @ neg_strips;
val new_rw =
	(¨x ç $SetComp yÆ, ç_comp_conv) ::
	(¨x ç $Insert y zÆ, ç_enum_set_conv) ::
	(flat(map (cthm_eqn_cxt initial_rw_canon)
	[complement_clauses, ¿_clauses, °_clauses, set_dif_clauses,
	Ä_clauses, †_clauses, ﬁ_clauses, •_clauses, _clauses]));
val dummy = (delete_pc "sets_alg" handle ? => ());
val dummy = new_pc "sets_alg";
val dummy = merge_pcs ["pair"] "sets_alg";
val dummy = ((set_st_eqn_cxt new_strips "sets_alg");
		(set_sg_eqn_cxt new_strips "sets_alg");
		(set_rw_eqn_cxt new_rw "sets_alg"));
=TEX
=SML
val dummy = pop_pc();
val dummy = open_theory "sum";
val dummy = (new_theory"hol";
		new_parent"one";
		new_parent"sets") handle ? => ();
end; (* of structure SetsTheory *)
open SetsTheory;
=TEX
\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


