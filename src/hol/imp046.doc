=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Constant Specification Tools}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP046}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation
of the tools supporting specification of constants in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1 to 1.3] 
First experimental versions.
\item [Issue 1.4]
First ``real'' implementation.
\item [Issue 1.5]
Changed to revert to previous theory afterwards.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Tools supporting specification of constants will be required in ICL HOL.
A design for such tools is given in \cite{DS/FMU/IED/DTD046}.
This document provides an implementations for them.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation for the
tools supporting specification of constants.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD046}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.

\section{Preamble}
=SML
structure âConstantSpecificationá : ConstantSpecification = struct
=TEX
=SML
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",true);
=TEX
\section{THE THEORY}
=SML
val was_theory = get_current_theory_name();
val _ = open_theory "misc";
val _ = push_proof_context initial_rewrite_epc;
=TEX
=SML
val âconsistent_defá = 
new_specification(["Consistent"],1,(
	push_goal([],»„ Consistent Ž ƒ p:'a ‹ BOOL Ž Consistent p ‚ „ x Ž p x¼);
	a(simple_„_tac » p:'a ‹ BOOL Ž „ x Ž p x¼);
	a (rewrite_tac[]);
	pop_thm()));
=TEX
=SML
val âconst_spec_defá = 
new_specification(["ConstSpec"],1,(
	push_goal([],»„ ConstSpec Ž ƒ (p:'a ‹ BOOL) (c:'a) Ž 
		ConstSpec p c ‚ (Consistent p Š p c)¼);
	a(simple_„_tac » (p:'a ‹ BOOL) (c:'a) Ž (Consistent p Š p c)¼);
	a (rewrite_tac[]);
	pop_thm()));
=TEX
=SML
val âconst_spec_thmá = save_thm("const_spec_thm",(
	push_goal([],»ƒ (p:'a ‹ BOOL) Ž „ x : 'a Ž ConstSpec p x¼);
	a(simple_ƒ_tac);
	a(rewrite_tac[consistent_def, const_spec_def]);
	a(simple_„_tac »(‡ xŽp x)¼);
	a(Š_T (strip_asm_tac o „_‡_rule));
	pop_thm()));
=TEX
We now wish to reason about pairs, so:
=SML
val _ = open_theory "pair";
=TEX
\section{UTILITIES}
We wish to process a list of varstructs into a list of variables, failing if given other than varstructs,
or duplicated names.
=SML
fun âprocess_vssá (caller: string) (tml : TERM list) : TERM list = (
let	fun aux1 acc tm = (
		if is_var tm
		then (let val (nm ,ty) = dest_var tm
			in
			if nm mem acc
			then fail caller 46003 [fn () => nm]
			else (nm :: acc, [tm])
			end
		) else let val (tm1,tm2) = dest_pair tm;
			val (acc',tms1) = aux1 acc tm1;
			val (acc'',tms2) = aux1 acc' tm2;
		in
			(acc'', tms1 @ tms2)
		end
	);

	fun aux acc [] = []
	| aux acc (tm :: tml) = (
		let	val (acc',tms) = aux1 acc tm
			handle complaint =>
			divert complaint "dest_pair" 
			caller 46004 [fn () => string_of_term tm]
		in	
			tms @ aux acc' tml
		end
	);
in
	aux [] tml
end);

=TEX
=SML
fun âmk_fstá tm = (
let	val ttm = type_of tm;
	val (ta,tb) = dest_‰_type ttm;
in
	mk_app(mk_const("Fst", mk_‹_type(ttm,ta)), tm)
end);
fun âmk_sndá tm = (
let	val ttm = type_of tm;
	val (ta,tb) = dest_‰_type ttm;
in
	mk_app(mk_const("Snd", mk_‹_type(ttm,tb)), tm)
end);

fun âlist_mk_pairá ([tm]: TERM list) : TERM = tm
| list_mk_pair (a :: x) = mk_pair(a,list_mk_pair x)
| list_mk_pair [] = fail "list_mk_pair" 0 [];

fun âstrip_pairá (tm:TERM):TERM list = (
	if is_pair tm
	then (let val (tm1,tm2) = dest_pair tm
	in
		strip_pair tm1 @ strip_pair tm2
	end)
	else [tm]
);
=TEX
=SML
val âsfst_snd_thmá = tac_proof(([],»ƒ x Ž (Fst x,Snd x) = x¼),
	rewrite_tac[pair_clauses]);
=TEX
Something tailored to our precise needs:
=RULE
„_uncurry_x_rule
»„ c1 ... cn Ž ConstSpec p (c1,...,cn)¼
É
„ x Ž ConstSpec p x
É
„ c1 ... cn Ž ConstSpec p (c1,...,cn)
=TEX
Where the type of $(c1,...,cn)$ equals the type of $x$.
=SML
fun â„_uncurry_x_ruleá (tm : TERM) (thm : THM) : THM = (
let	val cs = fst(strip_simple_„ tm);
	fun aux x [c] = [x]
	| aux x (c :: cs1) = mk_fst x :: aux (mk_snd x) cs1
	| aux x [] = fail "„_uncurry_x_rule" 0 [];
in
	tac_proof((hyps thm,tm),(
		strip_asm_tac thm 
		THEN
		(fn (asms,gl) =>
		let val (_,x') = dest_app(hd asms)
		in
		MAP_EVERY simple_„_tac (aux x' cs) (asms,gl)
		end)
		THEN
		conv_tac(RAND_C(TRY_C(pure_rewrite_conv[sfst_snd_thm])))
		THEN goal_in_asms_tac))
end);
=TEX
\section{MAIN FUNCTIONS}
\subsection{$const\_spec$}
=SML
fun âconst_specá (keys:string list, vss : TERM list, pred : TERM) : THM = (
let	val vs = process_vss "const_spec" vss;
	val sideeffect = if is_nil vs
		then fail "const_spec" 6044 []
		else if type_of pred <> BOOL
		then term_fail "const_spec" 3031 [pred]
		else ();
	val proof_tm = list_mk_simple_„ (vs, pred)
		handle complaint =>
		pass_on complaint "list_mk_simple_„" "const_spec";
	val proven = (Value (get_epc_cs_„_rule (get_proof_context ()) proof_tm))
		handle (Fail _) => Nil;
in
case proven of
Value res => (new_specification(keys,length vs, res)
		handle complaint =>
		pass_on complaint "new_specification" "const_spec"
) | Nil	=> (
let	val nvs = list_variant (vs @ (map mk_var (term_vars pred))) vs;
	val insts = combine nvs vs;
	val pred' = subst insts pred;
	val deferred_bundle = list_mk_pair vs;
	val deferred_bundle' = list_mk_pair nvs;
	val deferred_pred = mk_(deferred_bundle',pred');
	val deferred_cs = mk_const("ConstSpec",
		mk_‹_type(type_of deferred_pred,
			mk_‹_type(type_of deferred_bundle,
				BOOL)));
	val deferred_tm = list_mk_simple_„ (vs,
		list_mk_app(deferred_cs, 
			[deferred_pred, deferred_bundle]));
	val s1 = inst_type_rule [(type_of deferred_bundle,
		mk_vartype "'a")] const_spec_thm;
	val s2 = simple_ƒ_elim deferred_pred s1;
	val s3 = „_uncurry_x_rule deferred_tm s2;
in
	new_specification(keys,length vs, s3)
		handle complaint =>
		pass_on complaint "new_specification" "const_spec"	
end)
end);
=IGN
const_spec (["c1","c2","c3"],[»c1:BOOL¼,»(c2:BOOL,c3:BOOL)¼],
	»c1 € c2 € c3¼);
const_spec (["c4"],[»c4:BOOL¼],»c4 = T¼);
=TEX
=SML
fun âHOL_axiomatic_recogniserá
	(x:string, y:string,
		toks:Lex.INPUT list, z:string:string) : THM = (
	let	val tm = HOL_term_recogniser(x, y, toks, z);
	in	if is_pair tm
		then let	val (var, def) = dest_pair tm;
				val nms = map (fst o dest_var)(frees var);
		in	
			const_spec (nms,[var],def)
		end
		else fail "HOL_axiomatic_recogniser" 46000 []
	end
	handle complaint =>
	divert complaint "HOL parser" "HOL_axiomatic_recogniser" 46000 []
);
=IGN
 È
c5 : BOOL ‹ BOOL,
c6 : BOOL ‹ BOOL
É
(ƒ x Ž c5 x = Œ x)
€
(ƒ y Ž c6 y = y)
Ë
 È
c7 : 'a ‰ 'b,
c8 : 'b ‰ 'a
É
T
Ë
=TEX
\subsection{Extracting the Best Specification}
=SML
fun âget_specificationá (nm : string) : THM = (
let	val thy = get_const_theory nm;
	val defn = get_defn thy nm;
in
	(if is_bin_op "ConstSpec" (concl defn)
	then ((
	let	val poss_thys = thy :: ((get_descendants thy) diff 
			(thy :: get_ancestors "-"));
		val x_cons = nm ^ "_consistent";
		val find_cons = hd(mapfilter 
			(fn lthy => get_thm lthy x_cons) poss_thys);
	in
		%beta%_rule (Š_elim (
			conv_rule (simple_eq_match_1_conv const_spec_def) defn)
			find_cons)
	end)
	handle (Fail _) =>
	%beta%_rule (undisch_rule(conv_rule (simple_eq_match_1_conv const_spec_def) defn)))
	else defn)
end
handle complaint =>
list_divert complaint "get_specification" [
	("get_const_theory",46005,[fn () => nm]),
	("get_defn",46006,[fn () => nm])]
);
=TEX
\subsection{Supporting the Conventions}
=SML
local
	val consistent_thm = pure_rewrite_rule [eta_axiom] consistent_def;
in
fun âpush_consistency_goalá (nm : string) : unit = (
let	val spec = get_specification nm
		handle complaint =>
		pass_on complaint "get_specification" "push_consistency_goal";
	val gl = (hd(hyps spec)
		handle complaint =>
		fail "push_consistency_goal" 46007 [fn () => nm])
in
	if is_mon_op "Consistent" gl
	then (push_goal([],gl);
		a(pure_once_rewrite_tac[consistent_thm]))
	else fail "push_consistency_goal" 46007 [fn () => nm]
end);
end;
=TEX
=SML
fun âsave_consistency_thmá (nm : string) (thm : THM) = (
let	val thy = get_const_theory nm;
	val defn = get_defn thy nm;
	val (pred,cs) = dest_bin_op "save_consistency_thm" 46012 "ConstSpec" (concl defn);
	val pred' = dest_mon_op "save_consistency_thm" 46008 "Consistent" (concl thm);
	val csnms = map (fst o dest_const)(strip_pair cs);
	val save_nms = map (fn s => s ^ "_consistent") csnms;
	val sideeffect = if %alpha%_eq pred pred'
		then ()
		else fail "save_consistency_thm" 46011 
			[fn () => string_of_thm thm,
			fn () => nm];
in
	(list_save_thm (save_nms, thm)
	handle complaint =>
	pass_on complaint "list_save_thm" "save_consistency_thm")
end
handle complaint =>
list_divert complaint "save_consistency_thm" [
	("get_const_theory",46005,[fn () => nm]),
	("get_defn",46006,[fn () => nm])]
);
=IGN
get_specification "c1";
push_consistency_goal "c2";
a(„_tac »(T,T,T)¼);
a(rewrite_tac[]);
save_consistency_thm "c3" (pop_thm());
get_specification "c1";
get_specification "c2";
=TEX
\section{EPILOGUE}
=SML
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",
	lsubgoal_package_quiet);
val _ = open_theory was_theory;
end; (* of structure ConstantSpecification *)
open ConstantSpecification;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
