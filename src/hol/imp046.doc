=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Constant Specification Tools}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP046}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation
of the tools supporting specification of constants in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1 to 1.3] 
First experimental versions.
\item [Issue 1.4]
First ``real'' implementation.
\item [Issue 1.5]
Changed to revert to previous theory afterwards.

\item[Issue 1.6, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.7]
Added missing definition keys.
Corrected $HOL\_constant\_recogniser$.
\item [Issue 1.8 (6 February 1992)]
Re-worked $HOL\_constant\_recogniser$ to construct
an existence assertion rather than a variable list -- predicate
pair.
\item [Issue 1.9 (7 February 1992)]
$HOL\_constant\_recogniser$ modified to correctly
handle predicates which begin with any binder.
\item [Issue 1.10,1.11 (26th March 1992)]
Changed to use proof context material of issue 1.13 of \cite{DS/FMU/IED/DTD051}.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Tools supporting specification of constants will be required in ICL HOL.
A design for such tools is given in \cite{DS/FMU/IED/DTD046}.
This document provides an implementations for them.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation for the
tools supporting specification of constants.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD046}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.

\section{Preamble}
=SML
structure €ConstantSpecification› : ConstantSpecification = struct
=TEX
=SML
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",true);
=TEX
\section{THE THEORY}
=SML
val was_theory = get_current_theory_name();
val _ = open_theory "misc";
val _ = push_pc "initial_rewrite";
=TEX
=SML
val €consistent_def› = 
new_specification(["Consistent","consistent_def"],1,(
	push_goal([],¨∂ Consistent ∑ µ p:'a ≠ BOOL ∑ Consistent p § ∂ x ∑ p xÆ);
	a(simple_∂_tac ¨Ã p:'a ≠ BOOL ∑ ∂ x ∑ p xÆ);
	a (rewrite_tac[]);
	pop_thm()));
=TEX
=SML
val €const_spec_def› = 
new_specification(["ConstSpec","const_spec_def"],1,(
	push_goal([],¨∂ ConstSpec ∑ µ (p:'a ≠ BOOL) (c:'a) ∑ 
		ConstSpec p c § (Consistent p ¥ p c)Æ);
	a(simple_∂_tac ¨Ã (p:'a ≠ BOOL) (c:'a) ∑ (Consistent p ¥ p c)Æ);
	a (rewrite_tac[]);
	pop_thm()));
=TEX
=SML
val €const_spec_thm› = save_thm("const_spec_thm",(
	push_goal([],¨µ (p:'a ≠ BOOL) ∑ ∂ x : 'a ∑ ConstSpec p xÆ);
	a(simple_µ_tac);
	a(rewrite_tac[consistent_def, const_spec_def]);
	a(simple_∂_tac ¨(Õ x∑p x)Æ);
	a(¥_T (strip_asm_tac o ∂_Õ_rule));
	pop_thm()));
=TEX
We now wish to reason about pairs, so:
=SML
val _ = open_theory "pair";
=TEX
\section{UTILITIES}
We wish to process a list of varstructs into a list of variables, failing if given other than varstructs,
or duplicated names.
=SML
fun €process_vss› (caller: string) (tml : TERM list) : TERM list = (
let	fun aux1 acc tm = (
		if is_var tm
		then (let val (nm ,ty) = dest_var tm
			in
			if nm mem acc
			then fail caller 46003 [fn () => nm]
			else (nm :: acc, [tm])
			end
		) else let val (tm1,tm2) = dest_pair tm;
			val (acc',tms1) = aux1 acc tm1;
			val (acc'',tms2) = aux1 acc' tm2;
		in
			(acc'', tms1 @ tms2)
		end
	);

	fun aux acc [] = []
	| aux acc (tm :: tml) = (
		let	val (acc',tms) = aux1 acc tm
			handle complaint =>
			divert complaint "dest_pair" 
			caller 46004 [fn () => string_of_term tm]
		in	
			tms @ aux acc' tml
		end
	);
in
	aux [] tml
end);

=TEX
=SML
fun €mk_fst› tm = (
let	val ttm = type_of tm;
	val (ta,tb) = dest_∏_type ttm;
in
	mk_app(mk_const("Fst", mk_≠_type(ttm,ta)), tm)
end);
fun €mk_snd› tm = (
let	val ttm = type_of tm;
	val (ta,tb) = dest_∏_type ttm;
in
	mk_app(mk_const("Snd", mk_≠_type(ttm,tb)), tm)
end);

fun €list_mk_pair› ([tm]: TERM list) : TERM = tm
| list_mk_pair (a :: x) = mk_pair(a,list_mk_pair x)
| list_mk_pair [] = fail "list_mk_pair" 0 [];

fun €strip_pair› (tm:TERM):TERM list = (
	if is_pair tm
	then (let val (tm1,tm2) = dest_pair tm
	in
		strip_pair tm1 @ strip_pair tm2
	end)
	else [tm]
);
=TEX
=SML
val €sfst_snd_thm› = tac_proof(([],¨µ x ∑ (Fst x,Snd x) = xÆ),
	rewrite_tac[pair_clauses]);
=TEX
Something tailored to our precise needs:
=FRULE 1 Rule
∂_uncurry_x_rule
¨∂ c1 ... cn ∑ ConstSpec p (c1,...,cn)Æ
˜
∂ x ∑ ConstSpec p x
˜
∂ c1 ... cn ∑ ConstSpec p (c1,...,cn)
=TEX
Where the type of $(c1,...,cn)$ equals the type of $x$.
=SML
fun €∂_uncurry_x_rule› (tm : TERM) (thm : THM) : THM = (
let	val cs = fst(strip_simple_∂ tm);
	fun aux x [c] = [x]
	| aux x (c :: cs1) = mk_fst x :: aux (mk_snd x) cs1
	| aux x [] = fail "∂_uncurry_x_rule" 0 [];
in
	tac_proof((hyps thm,tm),(
		strip_asm_tac thm 
		THEN
		(fn (asms,gl) =>
		let val (_,x') = dest_app(hd asms)
		in
		MAP_EVERY simple_∂_tac (aux x' cs) (asms,gl)
		end)
		THEN
		conv_tac(RAND_C(TRY_C(pure_rewrite_conv[sfst_snd_thm])))
		THEN goal_in_asms_tac))
end);
=TEX
\section{MAIN FUNCTIONS}
\subsection{$const\_spec$}
=SML
fun €const_spec› (keys:string list, vss : TERM list, pred : TERM) : THM = (
let	val vs = process_vss "const_spec" vss;
	val sideeffect = if is_nil vs
		then fail "const_spec" 6044 []
		else if type_of pred <> BOOL
		then term_fail "const_spec" 3031 [pred]
		else ();
	val proof_tm = list_mk_simple_∂ (vs, pred)
		handle complaint =>
		pass_on complaint "list_mk_simple_∂" "const_spec";
	val proven = (Value (§_t_elim((current_ad_cs_∂_conv ()) proof_tm)))
		handle (Fail _) => Nil;
in
case proven of
Value res => (new_specification(keys,length vs, res)
		handle complaint =>
		pass_on complaint "new_specification" "const_spec"
) | Nil	=> (
let	val nvs = list_variant (vs @ (map mk_var (term_vars pred))) vs;
	val insts = combine nvs vs;
	val pred' = subst insts pred;
	val deferred_bundle = list_mk_pair vs;
	val deferred_bundle' = list_mk_pair nvs;
	val deferred_pred = mk_Ã(deferred_bundle',pred');
	val deferred_cs = mk_const("ConstSpec",
		mk_≠_type(type_of deferred_pred,
			mk_≠_type(type_of deferred_bundle,
				BOOL)));
	val deferred_tm = list_mk_simple_∂ (vs,
		list_mk_app(deferred_cs, 
			[deferred_pred, deferred_bundle]));
	val s1 = inst_type_rule [(type_of deferred_bundle,
		mk_vartype "'a")] const_spec_thm;
	val s2 = simple_µ_elim deferred_pred s1;
	val s3 = ∂_uncurry_x_rule deferred_tm s2;
in
	new_specification(keys,length vs, s3)
		handle complaint =>
		pass_on complaint "new_specification" "const_spec"	
end)
end);
=IGN
const_spec (["c1","c2","c3"],[¨c1:BOOLÆ,¨(c2:BOOL,c3:BOOL)Æ],
	¨c1 ± c2 ± c3Æ);
const_spec (["c4"],[¨c4:BOOLÆ],¨c4 = TÆ);
=TEX
=SML
local
	open Lex Parser ReaderWriterSupport SymbolTable TypeInference;
	open PrettyNames;
	fun €strip_varbinder› (op_name : string) (tm : TERM) : TERM list * TERM = (
	let	fun aux (tm1:TERM) : (TERM list * TERM) = (
		let	val (binder, abs) = dest_app tm1;
			val (var, body) = dest_Ã abs;
		in	if fst (dest_var binder) = op_name
			then (let val (vs,bd) = aux body;
				in
					((var :: vs) , bd)
				end)
		else ([],tm1)
		end
		handle (Fail _) => ([],tm1)
		);
	in
		aux tm
	end);

	fun unique_bname s = (
		case get_fixity s of
		Lex.Binder => unique_bname (s^" ")
		|_ => s);
in
=TEX
=SML
fun €HOL_constant_recogniser›
	(x:string, y:string,
		toks:Lex.INPUT list, z:string:string) : THM = (
=TEX
=SMLLITERAL
	let	val sideeffect = if is_same_symbol(x, "π")
			andalso	is_same_symbol(z, "∞")
			andalso	(y = "HOLCONST")
			then ()
			else fail "HOL_constant_recogniser" 46000 [];
		fun aux res (Separator"˜":: more) = (
			 res@[Separator "∑"]@more
		) | aux res (Text t::more) = (
			if contains (explode t) "∑"
			then fail "HOL_constant_recogniser" 46000 []
			else aux (res@[Text t]) more
		) | aux res (x::more) = (aux (res@[x]) more
		) | aux res [] = fail "HOL_constant_recogniser" 46000 [];
		val toks' =  aux [] toks;
		val tm = (lex (get_current_terminators()) get_fixity) toks';
		val binder_name = unique_bname "πHOLCONST";
		val tm1 = HTBinder binder_name::tm;
		val tm2 = (make_term o HOL_parser) tm1;
		val (vars, def) = strip_varbinder binder_name tm2;
		val fv = list_cup(map frees vars);
		val nms = map (fst o dest_var)fv;
	in	
		const_spec (nms,vars,def)
	end
	handle complaint =>
	divert complaint "HOL parser" "HOL_constant_recogniser" 46000 []
);
end (* local ... in *);

=TEX
=IGN

 πHOLCONST
x4 : BOOL ≠ BOOL;-
x5 : BOOL ≠ BOOL
˜
 ∂x6 ∑ x6 = x5
  ∞;

  πHOLCONST
c1 : BOOL ≠ BOOL
˜
 T
  ∞;

 πHOLCONST
c2 : BOOL ≠ BOOL;
c3 : BOOL ≠ BOOL
˜
 T
  ∞;
=TEX
\subsection{Extracting the Best Specification}
=SML
fun €get_specification› (nm : string) : THM = (
let	val thy = get_const_theory nm;
	val defn = get_defn thy nm;
in
	(if is_bin_op "ConstSpec" (concl defn)
	then ((
	let	val poss_thys = thy :: ((get_descendants thy) diff 
			(thy :: get_ancestors "-"));
		val x_cons = nm ^ "_consistent";
		val find_cons = hd(mapfilter 
			(fn lthy => get_thm lthy x_cons) poss_thys);
	in
		%beta%_rule (¥_elim (
			conv_rule (simple_eq_match_1_conv const_spec_def) defn)
			find_cons)
	end)
	handle (Fail _) =>
	%beta%_rule (undisch_rule(conv_rule (simple_eq_match_1_conv const_spec_def) defn)))
	else defn)
end
handle complaint =>
list_divert complaint "get_specification" [
	("get_const_theory",46005,[fn () => nm]),
	("get_defn",46006,[fn () => nm])]
);
=TEX
\subsection{Supporting the Conventions}
=SML
local
	val consistent_thm = pure_rewrite_rule [eta_axiom] consistent_def;
in
fun €push_consistency_goal› (nm : string) : unit = (
let	val spec = get_specification nm
		handle complaint =>
		pass_on complaint "get_specification" "push_consistency_goal";
	val gl = (hd(hyps spec)
		handle complaint =>
		fail "push_consistency_goal" 46007 [fn () => nm])
in
	if is_mon_op "Consistent" gl
	then (push_goal([],gl);
		a(pure_once_rewrite_tac[consistent_thm]))
	else fail "push_consistency_goal" 46007 [fn () => nm]
end);
end;
=TEX
=SML
fun €save_consistency_thm› (nm : string) (thm : THM) = (
let	val thy = get_const_theory nm;
	val defn = get_defn thy nm;
	val (pred,cs) = dest_bin_op "save_consistency_thm" 46012 "ConstSpec" (concl defn);
	val pred' = dest_mon_op "save_consistency_thm" 46008 "Consistent" (concl thm);
	val csnms = map (fst o dest_const)(strip_pair cs);
	val save_nms = map (fn s => s ^ "_consistent") csnms;
	val sideeffect = if %alpha%_eq pred pred'
		then ()
		else fail "save_consistency_thm" 46011 
			[fn () => string_of_thm thm,
			fn () => nm];
in
	(list_save_thm (save_nms, thm)
	handle complaint =>
	pass_on complaint "list_save_thm" "save_consistency_thm")
end
handle complaint =>
list_divert complaint "save_consistency_thm" [
	("get_const_theory",46005,[fn () => nm]),
	("get_defn",46006,[fn () => nm])]
);
=IGN
get_specification "c1";
push_consistency_goal "c2";
a(∂_tac ¨(T,T,T)Æ);
a(rewrite_tac[]);
save_consistency_thm "c3" (pop_thm());
get_specification "c1";
get_specification "c2";
=TEX
\section{EPILOGUE}
=SML
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",
	lsubgoal_package_quiet);
val _ = open_theory was_theory;
end; (* of structure ConstantSpecification *)
open ConstantSpecification;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


