=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FORMAL METHODS UNIT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Modal Logic in HOL}  %% Mandatory field
\TPPref{DS/FMU/IED/SML013}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
\TPPauthors{K.~Blackburn &WIN01\\R.D. Arthan &WIN01\\&}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    R.D.~Arthan \\ K.~Blackburn
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
First version.

\subsection{Changes forecast}

Under development, highly incomplete, totally volatile.
\pagebreak
\section{GENERAL}
\subsection{Scope}
proof development system.
\subsection{Introduction}
\section{UTILITIES}
=TEX
=SML
val ‚list_frees· : TERM list -> TERM list = list_term_union o map frees;
=TEX
\section{A SIMPLE FORM OF $new\_definition$}
The following function is used for both the
simple and the general version of $new\_definition$.

The first argument, $argfun$,
is intended to be a function which,
given a dummy argument list and the right hand side of
a definition, returns a pair consisting of a term and
a conversion. The term must be a term which when
applied to the dummy argument list returns the right-hand-side.
The conversion must be the conversion which expresses this
fact. E.g. given  $[`a', `b', `c']$ and `$a ä b ä c$'
$argfun$ should return `ça b c.a ä b ä c', and a conversion
which proves ``Ö(ça b c.a ä b ä c) a b c = a ä b ä c'',
given $(ça b c.a ä b ä c) a b c$.
$argfun$ is also expected to make any necesary checks
on the argument list (e.g. for duplicated variables).

The argument $defname$ gives the name under which the definition
will be stored on the theory.

The argument, $tm$, is the equation which is to define
the new constant.
It may be universally quantified if desired.
The actual definitional axiom will be a closed term.
The closure is taken by adding universal quantifiers
after (i.e. within the scope of) any which are already
present. Thus specialisation of the definitional axiom
will work, more or less, as expected.
=SML
new_error_message{id=99900, text="defining term contains free variables"};
=SML
fun ‚arb_new_defn·
	(argfun : TERM list-> TERM -> (TERM * CONV))
	(defnames : string list, tm : TERM) : THM = (
	let	val (vs, pred) = strip_É tm;
		val (lhs, rhs) = dest_eq pred;
		val (f, args) = strip_app lhs;
		val check = case frees tm term_less f of
				[] => ()
			|	vs => (
				warn "new_defn" 99900 []
(* defining term contains the following free variables ?0 *)
		);
		val (v, ty) = dest_var f;
		val newvs = vs term_union (frees tm term_less f);
		val tm' = list_mk_É (newvs, mk_eq(lhs, rhs));
		val tm'' = list_mk_É (newvs, pred);
		val (witness, conv) = argfun args rhs;
		val evidence = list_simple_É_intro newvs (conv (list_mk_app(witness ,args)));
		val thm = simple_Ñ_intro (mk_Ñ(f, tm')) evidence;
	in
		new_specification (defnames, 1, thm)
	end
	handle ex => (
		if area_of ex = "new_specification"
		then reraise ex "new_defn" 
		else list_divert ex "new_defn"
			[("dest_eq",
(* "defining term must be a (possibly universally quantified) equation" *)
				99901, []),
			("dest_var",
(* "the left hand side of the defining equation must have the form `f' or `f a1 ... ak', where `f' is a variable" *)
				99902, [])]
	)
);
=TEX
The following simple $argfun$ suffices for the definitions
we need to make in this document. It handles a dummy
argument list comprising variables only.
Note that we check for duplicated dummy arguments,
even though $new\_specification$ would accept that
case.

The algorithm is straightforward. We are trying to solve
an equation $f\,a_1\,\ldots\,a_k = b$ for $f$. We work
from right to left along the $a_i$, using the solution
$F = çA.B$ of $F\,A = B$ for the one argument case.
We also need to supply a conversion which will prove
that our solution is a solution. This conversion
will be the trivial conversion if there are no
dummy arguments. If there is just one argument then
a beta conversion will suffice. For $n > 1$ the
conversion for $n+1$ arguments is obtained by applying
the conversion for $n$ arguments to the operator of
a combination followed by a beta conversion.
Conceptually, we are working from left to right along
the arguments here (hence the use of $rev$ below, which
is not actually needed in the simple case treated here).
=SML
fun ‚simple_arg_fun· (args : TERM list) (body : TERM) : TERM * CONV = (
	let
		fun make_term [] (body : TERM) = body
		|   make_term (arg :: args : TERM list) (body : TERM) = (
			if is_var arg andalso not(arg term_mem list_frees args)
			then mk_ç(arg, make_term args body)
			else fail "new_defn" 99903 []
(* "argument ?0 on left hand side of definition is not valid" *)
		);
		fun make_conv (_::(args as (_ :: _))) = (
			RATOR_C (make_conv args) THEN_C simple_%beta%_conv
		) | make_conv [_] = simple_%beta%_conv
		|   make_conv [] = id_conv;
	in	if	(let	val argfrees = list_frees args
			in	all (frees body) (fn v => v term_mem argfrees)
			end)
		then	(make_term args body, make_conv (rev args))
		else fail "new_defn" 99904 []
(* "rhs of definition must not contain free variables not on the lhs" *)
	end
);
=TEX
=SML
val ‚new_defn· : string list * TERM -> THM = arb_new_defn simple_arg_fun;
=IGN
new_theory"fred";
new_defn(["thing1"], ªthing1 = Tº);
new_defn([""], ªthing2 (x:IND) = Tº);
new_defn(["abcdef", "ghij", "klmnop"], ªÉx; y; zéthing3 (x:IND) (y:BOOL) (z:IND)= (x,y,z)º);
open_theory"pair";
delete_theory"fred";
=TEX
=IGN
new_theory"fred";
=SML
fun ‚HOL_axiomatic_recogniser·(x, y, toks, z) = (
	let	val tm = HOL_term_recogniser(x, y, toks, z);
	in	if is_pair tm
		then let val (var, def) = dest_pair tm;
		in	if is_var var
			then new_defn([fst(dest_var var)], def)
			else fail "const_def" 99905 []
		end else fail "const_def" 99906 []
	end
);
=TEX
 »	thing:BOOL
…
	thing = T
À
 »	thing2:IND ã BOOL
…
	thing2 x = T
À
 »	thing3:IND ã BOOL
…
	Éxé thing3 x = T
À
=TEX
\end{document}
