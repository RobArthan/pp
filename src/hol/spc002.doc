=IGN
********************************************************************************
spc002.doc: this file is part of the PPHol system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
%
%	hol_list -d play spc002 >spc002.thy.doc
%	doctex spc002.thy.doc
% TQtemplate.tex
\documentstyle[hol1,11pt,TQa4]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\title{{\bf HOL Formalised: \\ Semantics}}  %% Mandatory field
\author{R.D. Arthan \\ Lemma 1 Ltd. \\ rda@lemma-one.com}
\date{25th October 1993 \\ Revised \FormatDate{\VCDate}}

\begin{document}
\thispagestyle{empty}
\begin{titlepage}
\maketitle
\begin{abstract}
This is part of a suite of documents giving a formal
specification of the HOL logic. It gives the semantics of the
HOL language by defining the notion of a model of an HOL theory.

The semantics is given by first formalising the notion of what we call a ''universe'', i.e., a model of set theory within HOL.
Such a universe is a type provided with a binary relation which obeys the axioms expected of the set-theoretic membership operation.
Polymorphism is used to present the notion of a model conservatively, rather than axiomatically.
The definition of a model of an HOL theory within some universe is then given in the usual denotational style.
The document concludes with a brief and informal discussion of the consistency and independence of the postulates for set theory as defined here.

An index to the formal material is provided at the end of the document.
\end{abstract}
\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd \number\year \\
Reference: DS/FMU/IED/SPC002; issue $Revision: 2.17 $%


\end{centering}
\thispagestyle{empty}
\end{titlepage}
\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

% \subsection{Changes forecast}
\newpage
\section{GENERAL}
\subsection{Scope}
This document specifies the semantics of the HOL language.
It is part of a suite of documents constituting
a formal specification of the HOL logic, an  overview of
which may be found in \cite{DS/FMU/IED/SPC001}.
\subsection{Introduction}
A set-theoretic semantics devised by A. Pitts for HOL is
given in \cite{SRI89a}. The treatment given is
not fully formal; however, it is ``possible in
principle to give a completely formal version within
{\tt ZFC} set theory''.
We wish to formalise the semantics in HOL.


A number of approaches have been considered to
specifying the semantics of HOL within HOL itself.
At one extreme, analogues of the axioms of {\tt ZFC} can
be introduced to give a theory in which we could hope to
construct a model of HOL and use it to prove
the consistency of all HOL theories which do not use
axiomatic extensions. At the other extreme we might try
a category-theoretic approach (see \cite{Lambek86}
or \cite{Hatcher82}), say by using definitional extensions
to define the notion of an interpretation of a
typed Ã-calculus in a cartesian closed category and
to specify how this notion applies to HOL.
The main decisions to be made are:

\begin{itemize}
\item How general a class of structures do we wish to
consider as models for HOL?
\item Should we use axiomatic extensions?
\end{itemize}

Our present approach tries to be no more general than
it needs to be. Since we have no immediate interest in completeness
results or comparisons with other type theories, extra generality would probably only
be an obstacle to assessing the correctness of our
treatment and might well make it more difficult to
prove the soundness of the inference rules. Thus we have
opted for a set-theoretic treatment.

We do not wish to use axiomatic extensions.
To avoid them we formulate the semantics as a specification
of what a model should be, rather than as construction
of a particular model. This makes little difference
to the utility of the semantics since all it amounts to
is that we make explicit our assumption of the existence of an appropriate universe
of sets in which terms take their values.

\subsection{Initialisation}
=SML
open_theory"spc001";
new_theory€"spc002"›;
=TEX
\pagebreak
\section{MODELS FOR SET THEORY IN HOL}

\subsection{Postulates for Elementary Set Theory}

We wish to define a notion of a model for set theory
within HOL. We will formulate this as a property
of a membership relation, $mem:'U ≠ 'U ≠ bool$.
The type $'U$ over which $mem$ is defined corresponds
to the universe in the treatment in \cite{SRI89a}.

In the following sections we define predicates which
assist in defining our postulates for a set theory.

\subsubsection{Extensionality}
The predicate for extensionality is straightforward:
πHOLCONST
	€extensional› : ('U ≠ 'U ≠ BOOL) ≠ BOOL
˜
	µmem∑extensional mem §
		µx y:'U∑x = y § µa:'U∑mem a x § mem a y
∞
=TEX
Note that we use the ordinary metalanguage equality as the
equality relation in $'U$. Since the extensionality
property implies that equality for sets is an equivalence
relation, this imposes no loss of generality (since we
could always work with the equivalence classes).
\subsubsection{Separation}
For us the postulate of separation will assert the existence
of a subset operator assigning to each set $x$ and
each property $P$ the subset of $x$ in which $P$ holds.
Note that, since $P$ is not constrained to be a property
which can be expressed in first-order set theory, this
postulate is, in general, stronger than that usual in
first-order treatments of set theory.

πHOLCONST
	€is_separation› : ('U ≠ 'U ≠ BOOL) ≠ ('U ≠ ('U ≠ BOOL) ≠ 'U) ≠ BOOL
˜
	µmem sub∑is_separation mem sub §
		µx P∑µa∑mem a (sub x P) § mem a x ± P a
∞
=TEX

Note that our universe is necessarily non-empty (since
metalanguage types are non-empty), so
extensionality and the
existence of a subset operator
with the above property will imply the existence of
a unique set with no elements (namely $sub\,x\,(Ãa.F)$
where $x$ is any term of type $'U$).

\subsubsection{Power Sets}
This postulate will assert the existence of an operator
assigning to each set the set of all its subsets.
πHOLCONST
	€is_power› : ('U ≠ 'U ≠ BOOL) ≠ ('U ≠ 'U) ≠ BOOL
˜
	µmem power∑is_power mem power §
		µx∑µa∑mem a (power x) § µb∑mem b a ¥ mem b x
∞
=TEX

If $x$ is an element of $'U$ let us write $extent\,mem\,x$
for the metalanguage predicate $Ãa∑mem\,a\,x$ and
assume $mem$ satisfies the postulates of separation and
power sets, then, viewing metalanguage predicates
as sets, $extent\,mem\,(power\,x)$ will be in
1-1 correspondence with $ÃP∑P\,Ä\,extent\,mem\,x$.
This will mean later that our semantics uses
only the so-called standard models, in which both object
language and metalanguage agree about the cardinality
of object language function spaces.

\subsubsection{Union Sets}
This postulate asserts the existence of an operator
assigning to each set the union of all its elements.
πHOLCONST
	€is_union› : ('U ≠ 'U ≠ BOOL) ≠ ('U ≠ 'U) ≠ BOOL
˜
	µmem union∑is_union mem union §
		µx∑µa∑mem a (union x) § ∂b∑mem a b ± mem b x
∞
=TEX
\subsubsection{Unordered Pairs}
This postulate asserts the existence of an operator
assigning to any two sets a set whose elements are precisely
those sets.
πHOLCONST
	€is_pair› : ('U ≠ 'U ≠ BOOL) ≠ ('U ≠ 'U ≠ 'U) ≠ BOOL
˜
	µmem pair∑is_pair mem pair §
		µx y∑µa∑mem a (pair x y) § a = x ≤ a = y
∞
=TEX
\subsection{Set Theories} \label{SetTheories}
We will say that a relation, $mem$, is a set theory if
it admits
a subset operator, a power set operator
etc. satisfying the properties defined in the previous section.
πHOLCONST
	€is_set_theory› : ('U ≠ 'U ≠ BOOL) ≠ BOOL
˜
	µmem∑	is_set_theory mem §
		extensional mem
	±	(∂sub∑is_separation mem sub)
	±	(∂power∑is_power mem power)
	±	(∂union∑is_union mem union)
	±	(∂pair∑is_pair mem pair)
∞
=TEX

This notion of a set theory is quite a weak one. An example
could be constructed without using axiomatic extensions
by using a countably infinite type to model the set of
hereditarily
finite sets in a classical set theory (see appendix \ref{Consistency}
below).

I would conjecture that
one would only need to assert axiomatically the existence
of a set theory (in the above sense)
together with an axiom of infinity to give
an extension of the HOL system
strong enough to prove the consistency of the theory $INIT$ and
its definitional extensions.

\subsection{Operations on Set Theories}

It is pleasant in the sequel to use notations similar to
the usual set-theoretic ones, at the very least by making
membership an infix operator.
Towards this end, we define polymorphic constants which will act
as membership relation and subset, power set, union and
pair operators in
any type which permits a set theory.
The names of these constants are given a subscript to
distinguish them from constants used in the metalanguage.

\subsubsection{Primitive Operations}
First we fix a choice of membership relation, then we
define the other operators with respect to that choice.

=SML
declare_infix(1000, "çâs");

πHOLCONST
	$€çâs›:'U ≠ 'U ≠ BOOL
˜
	(∂mem:'U ≠ 'U ≠ BOOL∑is_set_theory mem) ¥
		is_set_theory ($çâs:'U ≠ 'U ≠ BOOL)
∞
=TEX

πHOLCONST
	€Subâs›	: 'U ≠ ('U ≠ BOOL) ≠ 'U
˜
	(∂mem:'U ≠ 'U ≠ BOOL∑is_set_theory mem) ¥
		is_separation ($çâs) (Subâs:'U ≠ ('U ≠ BOOL) ≠ 'U)
∞
=TEX

πHOLCONST
	€âs›	: 'U ≠ 'U
˜
	(∂mem:'U ≠ 'U ≠ BOOL∑is_set_theory mem) ¥
		is_power ($çâs) (âs:'U ≠ 'U)
∞
=TEX

πHOLCONST
	€ﬁâs›	: 'U ≠ 'U
˜
	(∂mem:'U ≠ 'U ≠ BOOL∑is_set_theory mem) ¥
		is_union ($çâs) (ﬁâs:'U ≠ 'U)
∞
=TEX

We will use the symbol $´âs$ for the infix operator which
makes an unordered pair out of its operands:
=SML
declare_infix(1000, "´âs");

πHOLCONST
	$€´âs›	: 'U ≠ 'U ≠ 'U
˜
	(∂mem:'U ≠ 'U ≠ BOOL∑is_set_theory mem) ¥
		is_pair ($çâs) ($´âs:'U ≠ 'U ≠ 'U)
∞
=TEX

\subsubsection{Derived Operations}
As already mentioned, since the type $'U$ cannot be empty
we may construct an empty
set using the subset operator. This set will be denoted
$öâs$:
πHOLCONST
	€öâs›	: 'U
˜
	öâs = Subâs (≈x∑T) (Ãa∑F)
∞
=TEX
$Unitâs\,x$ will denote the singleton set $\{x\}$:
πHOLCONST
	€Unitâs›	: 'U ≠ 'U
˜
	µx:'U∑ Unitâs x = x ´âs x
∞
=TEX
$1âs$ denotes the set $\{öâs\}$:
πHOLCONST
	€1âs›	: 'U
˜
	1âs = Unitâs öâs
∞
=TEX
$2âs$ denotes the set $\{öâs, 1âs\}$:
πHOLCONST
	€2âs›	: 'U
˜
	2âs = öâs ´âs 1âs
∞
=TEX

$x\,Ìâs\,y$ will denote the ordered pair with first component $x$
and second component $y$, that is to say $\{\{x\},\{x,y\}\}$:
=SML
declare_infix(1000, "Ìâs");
πHOLCONST
	$€Ìâs›	: 'U ≠ 'U ≠ 'U
˜
	µx y:'U∑ x Ìâs y = Unitâs x ´âs (x ´âs y)
∞
=TEX
$¿âs$ will be the infix binary union operator:
=SML
declare_infix(1000, "¿âs");
πHOLCONST
	$€¿âs›	: 'U ≠ 'U ≠ 'U
˜
	µx y:'U∑ x ¿âs y = ﬁâs(x ´âs y)
∞
=TEX
$∏âs$ will be the infix binary product operator.
Since $\{\{x\},\{x,y\}\}\;Ä\;((x\,¿\,y))$, this may be defined
using the subset operator as follows.
=SML
declare_infix(1000, "∏âs");
πHOLCONST
	$€∏âs›	: 'U ≠ 'U ≠ 'U
˜
	µx y:'U∑ x ∏âs y = Subâs (âs(âs(x ¿âs y))) (Ãa∑∂b c∑b çâs x ± c çâs y ± a = b Ìâs c)
∞
=TEX
For the infix relation-space operator we use the name $™âs$):
=SML
declare_infix(1000, "™âs");
πHOLCONST
	$€™âs›	: 'U ≠ 'U ≠ 'U
˜
	µx y:'U∑ x ™âs y = âs (x ∏âs y)
∞
=TEX
$≠âs$ will be the infix total function-space operator:
=SML
declare_infix(1000, "≠âs");
πHOLCONST
	$€≠âs›	: 'U ≠ 'U ≠ 'U
˜
	µx y:'U∑ x ≠âs y = Subâs (x ™âs y) (Ãf∑µa∑(a çâs x) ¥ ∂â1b∑(a Ìâs b) çâs f)
∞
=TEX
The infix operator $@âs$ is used to denote application of a function
to an argument. (Note that $x$ here may not be a function and,
even if it is, $y$ may not be in its domain. These properties
will have to be proved as necessary.)
=SML
declare_infix(1000, "@âs");
πHOLCONST
	$€@âs›	: 'U ≠ 'U ≠ 'U
˜
	µx y:'U∑ x @âs y = ≈a∑ (y Ìâs a) çâs x
∞
=TEX
The following function is used to define the semantics of the
boolean type constructor.
$Boolâs$ is a function taking the empty list to $2âs$ and
any other list to the empty set.
πHOLCONST
	€Boolâs›	: 'U LIST ≠ 'U
˜
		(Boolâs [] = 2âs)
	±	(µx t∑ Boolâs (Cons x t) = öâs)
∞
=TEX
The following function is used to define the semantics of the
function space type constructor. $Funâs$ is a function which takes
a two element list, $[dom, rng]$, of non-empty elements of $'U$
to the set of functions from $Dom$ to $rng$ and
which takes any other list to the empty set.
πHOLCONST
	€Funâs›	: 'U LIST ≠ 'U
˜
	µargs∑Funâs args =
		let dom = Hd args
		in let rng = Hd (Tl args)
		in	if args = [dom; rng] ± ≥dom = öâs ± ≥rng = öâs
			then dom ≠âs rng
			else öâs
∞
=TEX
The following function is used to define the semantics
of $Ã$-abstraction. Note that there
is no guarantee that the result is a total function and
this will have to be proved where necessary.
πHOLCONST
	€Absâs›	: ('U ≠ 'U) ≠ 'U ≠ 'U ≠ 'U
˜
	µf dom rng∑Absâs f dom rng = Subâs (dom ∏âs rng) (Ãx∑∂a∑x = a Ìâs f a)
∞
=TEX
The following function will represent the polymorphic
equality of HOL:
πHOLCONST
	€EqRelâs›	: 'U ≠ 'U
˜
	µx:'U∑EqRelâs x = Subâs (x ∏âs x ∏âs 2âs)
			(Ãa∑∂b c∑a = (b Ìâs c Ìâs if b = c then 1âs else öâs))
∞
=TEX
The following set will represent
the graph of the implication function:
πHOLCONST
	€ImpRelâs›	: 'U
˜
	ImpRelâs =
		Unitâs(1âs Ìâs 1âs Ìâs 1âs)
	¿âs	Unitâs(1âs Ìâs öâs Ìâs öâs)
	¿âs	Unitâs(öâs Ìâs 1âs Ìâs 1âs)
	¿âs	Unitâs(öâs Ìâs öâs Ìâs 1âs)
∞
=TEX
\pagebreak
\section{SEMANTICS FOR HOL}
In this section we give the semantics of HOL with respect
to some universe $'U$ by specifying the notion of
a model of a theory. The main work in doing this is
defining the value of a term with respect to a function
assigning values to the variables and constants in it (and
similarly for types).

Because of our use of HOL rather than set theory as a metalanguage,
the approach and hence the terminology used here is rather
different from that used in the HOL manual, \cite{SRI89a}. An approximate
translation is given in the following table:

\begin{tabular}{|p{3in}|p{3in}|}\hline
This Document & HOL Manual\\ \hline
(Well-formed) type constant assignment & (Standard) model of a type structure \\ \hline
Type variable assignment & Element of ${\cal U}^n$ \\ \hline
Polymorphic value & Function from ${\cal U}\sp{n}$ to ${\cal U}$ \\ \hline
(Well-formed) constant assignment & Second component of a (standard) model of a signature \\ \hline
(Well-formed) interpretation & (Standard) model of a signature \\ \hline
Variable  assignment & Element of ${\cal U}^n$ \\ \hline
\end{tabular}

\subsection{Semantics of Types}
\subsubsection{Type Constant Assignment}
The value we assign to a type constant is in effect a function from
$n$-tuples of non-empty elements of the universe $'U$ to
non-empty elements of $'U$, where
$n$ is the arity of the type constant. Since we do not have
dependent types we represent such a thing as a function
of type $('U\,list ≠ {*}U)$ which sends a list of length other
than $n$ to the empty set.
We make the following type abbreviation\footnote{%
{\ProductHOL} does not provide special syntax for type abbreviations.
To introduce a type abbreviation one uses the ML function $declare\_type\_abbrev$ with parameters indicating the name, formal parameters and definition of the type abbreviation.%
} to facilitate this:
=SML
declare_type_abbrev("TY_CON_ASSIGNMENT", ["'U"], ¨:STRING ≠ ('U LIST ≠ 'U)Æ);
=TEX

We say that a type constant assignment is well-formed with respect to a
type environment if the arities of the values assigned to
the type constant names agree with those in the type environment
and if the boolean and function space types are assigned appropriately.
πHOLCONST
	€is_wf_ty_con_assignment›: TY_ENV ≠ 'U TY_CON_ASSIGNMENT ≠ BOOL
˜
	µtyenv tyconass∑ is_wf_ty_con_assignment tyenv tyconass §
		(µtycon args∑
			(≥tyconass tycon args = öâs)
		§	(tycon Ì Length args ç tyenv ± µa∑a ç Elems args ¥ ≥a = öâs))
	±	tyconass "bool" = Boolâs
	±	tyconass "≠" = Funâs
∞
=TEX

\subsubsection{Type Variable Assignments}
A type variable assignment is just a total function from type
variables to the universe, $'U$. We make the following
type abbreviation for this notion.
=SML
declare_type_abbrev("TY_VAR_ASSIGNMENT", ["'U"], ¨:STRING ≠ 'UÆ);
=TEX
A type variable assignment will be well-formed if
all the values in its range are non-empty
πHOLCONST
	is_wf_ty_var_assignment : 'U TY_VAR_ASSIGNMENT ≠ BOOL
˜
	µtyvarass∑is_wf_ty_var_assignment tyvarass § µtyv∑≥tyvarass tyv = öâs
∞
=TEX
\subsubsection{Polymorphic Values}
Types and terms have polymorphic values. We
represent these as functions from type variable assignments
to $'U$. This corresponds to the use of certain
dependent products in the treatment in \cite{SRI89a}.
=SML
declare_type_abbrev("POLY_VALUE", ["'U"], ¨:'U TY_VAR_ASSIGNMENT ≠ 'UÆ);
=TEX

A set $X$ of type variables supports a polymorphic value $v$ if $v$ is independent
of the values assigned to type variables not in $X$.
=SML
declare_infix(1000, "supports");
πHOLCONST
	$€supports›: STRING SET ≠ 'U POLY_VALUE ≠ BOOL
˜
µX v∑	X supports v § (µa1 a2∑ (µx∑ x ç X ¥ a1 x = a2 x) ¥ v a1 = v a2)
∞

\subsubsection{Semantics of Types}
The value of a type with respect to a type constant assignment is a function
mapping type variable assignments onto polymorphic values:
πHOLCONST
	€type_value›	:      'U TY_CON_ASSIGNMENT ≠ TYPE ≠ 'U POLY_VALUE
˜
	µtyconass s tyl∑
		type_value tyconass (mk_var_type s)  = (Ãtyvarass∑tyvarass s)
	±	type_value tyconass (mk_type(s, tyl)) =
		(Ãtyvarass∑tyconass s (Map(Ãty∑type_value tyconass ty tyvarass) tyl))
∞
=TEX
\subsection{Semantics of Terms}
\subsubsection{Constant Assignments}
A constant assignment
is a function
assigning to each constant name a polymorphic value.

=SML
declare_type_abbrev("CON_ASSIGNMENT", ["'U"], ¨:(STRING ≠ 'U POLY_VALUE)Æ);
=TEX


We call a constant assignment well-formed with respect to a constant environment if
it sends implication and equality to appropriate
polymorphic values and if the set of type variables in the type associated with
each constant in the environment supports the polymorphic value associated
with the constant.
πHOLCONST
	€is_wf_con_assignment›: CON_ENV ≠ 'U CON_ASSIGNMENT ≠ BOOL
˜
	µconenv conass∑ is_wf_con_assignment conenv conass §
		(µtyvarass∑
			conass "=" tyvarass = EqRelâs (tyvarass "*")
		±	conass "¥" tyvarass = ImpRelâs)
	±	(µcon ty∑ con Ì ty ç conenv ¥ type_ty_vars ty supports (conass con))
∞
=TEX

Here we rely on the fact that in the theory $MIN$ equality
is defined to have type $*≠*≠bool$.
\subsubsection{Interpretations}

An interpretation is a pair consisting of a
type constant assignment and a constant assignment:
=SML
declare_type_abbrev("INTERPRETATION", ["'U"],
		¨:'U TY_CON_ASSIGNMENT ∏ 'U CON_ASSIGNMENTÆ);
=TEX

An interpretation is
considered to be well-formed with respect to a theory if the
type constant assignment is well-formed with respect to the type environment
of the theory and if the constant assignment is well-formed
and respects the type constant assignment
in an appropriate sense:
πHOLCONST
	€is_wf_interpretation›	: THEORY ≠ 'U INTERPRETATION ≠ BOOL
˜
	µthy tyconass conass∑
		is_wf_interpretation thy (tyconass, conass)
	§ (	is_wf_ty_con_assignment (types thy) tyconass
	  ±	is_wf_con_assignment (constants thy) conass
	  ±	µs ty∑ s Ì ty ç constants thy ¥
			µtyvarass∑is_wf_ty_var_assignment tyvarass ¥
				conass s tyvarass çâs type_value tyconass ty tyvarass)
∞
=TEX
(Here $constants\,thy\,s\,ty$ is the assertion that a constant
named $s$ with type $ty$ has been defined in the theory $thy$.)
\subsubsection{Variable Assignments}
A variable assignment is a function sending name-type pairs
to polymorphic values.
=SML
declare_type_abbrev("VAR_ASSIGNMENT", ["'U"],
		¨:(STRING ∏ TYPE) ≠ 'U POLY_VALUEÆ);
=TEX

A variable assignment is considered to be well-formed
with respect to a type constant assignment if the following
condition holds:
πHOLCONST
	€is_wf_var_assignment› : 'U TY_CON_ASSIGNMENT ≠
					'U VAR_ASSIGNMENT ≠ BOOL
˜
	µtyconass varass∑
		is_wf_var_assignment tyconass varass
	§ 	µs ty tyvarass∑is_wf_ty_var_assignment tyvarass ¥
			varass (s, ty) tyvarass çâs type_value tyconass ty tyvarass
∞
\subsubsection{Instantiation of Polymorphic Values}
Given a theory, the name of a constant and the type of an instance of a constant,
the declared type may be matched with the instance type and the result used
to instantiate the polymorphic value assigned to the constant appropriately.
The function $instance$ that does this is only used in contexts where the constant has an assigned value and the instance type is an instance of the declared type.
πHOLCONST
	€instance› : THEORY ≠ 'U INTERPRETATION ≠
				STRING ∏ TYPE ≠'U POLY_VALUE
˜
	µthy tyconass conass s instty f declty∑
		is_wf_con_assignment (constants thy) conass ¥
		s Ì declty ç constants thy ± inst_type f declty = instty ¥
			instance thy (tyconass, conass) (s, instty)
		=	(Ãtyvarass∑ conass s (Ãtyvar∑ type_value tyconass (f tyvar) tyvarass))
∞

I am indebted to Ramana Kumar for pointing out that instantiation of polymorphic values was not addressed in earlier versions of this document and for commenting on the solution to that shortcoming.
=TEX
\subsubsection{Semantics of Terms}
The value of a term with respect to a type assignment
and a constant assignment is a function
mapping variable assignments to polymorphic values.
If the term is a variable then its value is given by the variable assignment.
If the term is a constant then the value is given by instantiating the value give
by the constant assignment as determined by its declared type and the type of this instance.
If it is a combination, $f\,a$, then the application operator
$@âs$ is used to apply the value of $f$ to that of $a$.
If the term is an abstraction, $Ãv∑b$, then
we form
a metalanguage $Ã$-abstraction which sends an element, $x$,
of the universe to the value taken by $b$ when $v$ takes
the polymorphic value which is identically $x$. We then
use $Absâs$ to construct a set in $'U$ from this metalanguage
$Ã$-abstraction.
πHOLCONST
	€term_value›	: THEORY ≠ 'U INTERPRETATION  ≠
			TERM ≠ 'U VAR_ASSIGNMENT ≠ 'U POLY_VALUE
˜
	µthy tyconass conass tm varass sty f a v b∑
		(term_value thy (tyconass, conass) (mk_var sty) varass
		=	(Ãtyvarass∑varass sty tyvarass))
	±	(term_value thy (tyconass, conass)(mk_const sty) varass
		=	instance thy (tyconass, conass) sty)
	±	(has_mk_comb(f, a)tm ¥
			term_value thy (tyconass, conass) tm varass
		=	let vf = term_value thy (tyconass, conass) f
			in let va = term_value thy (tyconass, conass) a
			in (Ãtyvarass∑vf varass tyvarass @âs va varass tyvarass))
	±	(has_mk_abs(v, b)tm ± mk_var sty = v ¥
			term_value thy (tyconass, conass) tm varass
		=	Ãtyvarass∑
			let dom = type_value tyconass (type_of_term v) tyvarass
			in let rng = type_value tyconass (type_of_term b) tyvarass
			in let fnc = (Ãx:'U∑
				term_value thy
				(tyconass, conass) b
				(Ãsty'∑if sty' = sty then Ãtyvarass'∑x else varass sty')
				tyvarass)
			in Absâs fnc dom rng)
∞
=TEX
\subsection{Models of Theories}
\subsubsection{Satisfaction}
Using $term\_value$ and interpreting boolean
terms which evaluate to $Ãx∑1âs$ as true,
we can define the notion of
a sequence being satisfied by
an interpretation.
We define this notion as an infix relation between
interpretations and sequents.
=SML
declare_infix(1000, "satisfies");
πHOLCONST
	$€satisfies›	: THEORY ∏ 'U INTERPRETATION ≠ SEQ ≠ BOOL
˜
	µthy int seq∑ (thy, int) satisfies seq §
		µvarass tyvarass∑
		let val_of = Ãtm∑term_value thy int tm varass tyvarass
		and (tyconass, _) = int
		in	is_wf_ty_var_assignment tyvarass
		±	is_wf_var_assignment tyconass varass
		±	(µasm∑asm ç hyp seq ¥ val_of asm = 1âs)
		¥	val_of (concl seq) = 1âs
∞
=TEX
\subsubsection{Models}
A model for a theory is an interpretation which is
well-formed with respect to the theory and which satisfies
all of its axioms:
πHOLCONST
	€is_model›	: THEORY ≠ 'U INTERPRETATION SET
˜
	µthy int∑
		int ç is_model thy §
		(is_wf_interpretation thy int ±
		µseq∑seq ç axioms thy ¥ (thy, int) satisfies seq)
∞
\subsubsection{Validity}
A sequent is valid with respect to a theory
if it is satisfied by any model of that theory. Because of
the restriction that any type variable in the defining property
of a constant must also appear in the type of the constant, we
have to give $valid$ an additional apparently unused parameter.
(The reasons for this are further discussed in the description
of $new\_specification$ in \cite{DS/FMU/IED/SPC003}.)
πHOLCONST
	€valid›	: 'U ≠ THEORY ≠ SEQ SET
˜
	µv thy seq∑
		seq ç valid v thy §
		µint:'U INTERPRETATION∑int ç is_model thy ¥ (thy, int) satisfies seq
∞

=TEX
\pagebreak
=IGN
\input{\jobname.thy.tex}
\pagebreak
=TEX
\appendix
\section{CONSISTENCY AND INDEPENDENCE} \label{Consistency}
In this appendix we briefly discuss the consistency and mutual independence of the
postulates for a set theory given in section~\ref{SetTheories} above.
We make use of informal set-theoretic notions.

My original arguments for the independence of union and pairing were incorrect.
I am much indebted to Prof. Robert M. Solovay for pointing this out and supplying
the arguments given below.

\subsection{Consistency}
Since we have not included an axiom of infinity, a model
for the postulates may be constructed using a model of the
hereditarily finite sets\footnote{%
A set, A, is hereditarily finite if its transitive closure
is finite. Here the transitive closure
$tr\_cl\,A$, of $A$ is defined by
$tr\_cl\,A = A\,¿\,(ﬁA)\,¿\,(ﬁ(ﬁA))\,¿\,(ﬁ(ﬁ(ﬁA)))\,¿\,\ldots$.
Less formally, a set is hereditarily finite if it is finite, all
its elements are finite, all their elements are finite and so on.}
in classical set theory.

It is easy to see that the hereditarily finite sets would supply
a model for our postulates if we could represent them as an HOL
type and define the membership relation for them in terms of
that representation. This is straightforward: e.g. take the type, Ó,
of natural numbers under the relation, $mem$, informally described by:
=GFT Informal Discussion
	mem i j § the i-th coefficient in the binary expansion of j is 1
=TEX

Thus our definition of set theory is consistent in the sense
that some instance of the predicate $is\_set\_theory$ is
satisfiable.

Note that if one wishes to introduce an axiom of infinity
and attempt to construct a model for HOL on that basis,
then one can presumably construct a model just
using the separation and power set axioms.
This should follow from the fact that
the cumulative hierarchy in {\tt ZF} is constructed using
only the power set and union operators, since a model
for HOL only requires sets formed before stage $\omega + \omega$ and
the axiom of infinity gets one beyond stage $\omega$ immediately.


\subsection{Independence}
The 5 postulates section~\ref{SetTheories} are independent.
For example, we can construct a model that satisfies all the postulates except extensionality,
so that extensionality is not a logical consequence of the other postulates.
The following paragraphs sketch such a construction for each postulate in turn:

\paragraph{Extensionality}
To see that extensionality is independent of the other postulates,
we adjoin a new empty individual, $X$ say,
to a model of all the postulates.
Of course, this actually introduces an infinite family of sets
constructed using $X$ and the various set forming operations.
The resulting system of sets satisfies all of the postulates
except extensionality.

\paragraph{Separation}
The identity relation on a one-element set supplies a model
of all of the postulates apart from separation.

\paragraph{Power Sets}
The hereditarily countable sets supply a model of all of the
postulates apart from the existence of power sets (see \cite{Kunen80} for more information).

\paragraph{Union Sets}
In ZFC, if $\kappa = |X|$ is the cardinal of a set $X$, we write, as usual, $2^{\kappa}$ for the cardinal of the powerset of $X$.
Define $\beta_x$ for $x \in \omega \cup \{\omega\}$,
by
\begin{eqnarray*}
	\beta_0		&=& |\omega| \\
	\beta_{n+1}	&=& 2^{\beta_{n}}, n \in \omega\\
	\beta_{\omega} 	&=& \mbox{\sf sup}_{n \in \omega}|\beta_n|\\
\end{eqnarray*}

One may verify that the set $M$ of all sets which are hereditarily of cardinality less than $\beta_{\omega}$ satisfies all the postulates except the existence of unions.
If one takes $U = \{\beta_n | n \in \omega\}$, then certainly $U \in M$, but $|\bigcup U| = \beta_{\omega} \not\in M$, so $M$ is not closed under unions.

\paragraph{Pairs}
To see the independence of the pairing postulate, consider a model of the system
of axioms derived from ZFC by replacing the axiom of foundation by an axiom asserting
the existence of two sets $A$ and $B$ satisfying $\{a\} = a$ and $\{b\}=b$ and such
that any descending chain with respect to the membership relation stabilises at either $a$ or $b$.
I.e., if $x_1, x_2, \ldots$ is such that $x_{i+1} \in x_i$ for all $i$, then there is a $j$ such that either $\forall i > j \bullet x_i = a$ or $\forall i > j \bullet x_i = b$

Now define  take $M$ to comprise all sets $X$ such that at least one of $a$ and $b$ does not belong to the transitive closure of $X$.
One may check that $M$ satisfies all the postulates except pairing.
However, both $a$ and $b$ are in $M$, but the pair $\{a, b\}$ is not, so $M$ is not closed under formation of pairs.

=IGN
\subsection{Some Theorems}
let
	fun thm_tac thm = (
		REWRITE_TAC[thm] THEN EVERY[
		ASM_CASES_TAC¨∂ mem:'U≠'U≠bool∑is_set_theory memÆ THEN ASM_REWRITE_TAC[],
		IMP_RES_TAC(specification"-""çâs") THEN
		DEF_RES_TAC(specification"-""is_set_theory")]
	);
in
	set_goal([], ¨∂ x1:'U≠'U≠bool∑SPEC_çâs x1Æ);
	e(thm_tac(definition"-""çâs_DEF"));
	show(save_top_thm"EXISTS_çâs_THM");

	set_goal([], ¨∂ x1:'U≠('U≠bool)≠'U∑SPEC_Subâs x1Æ);
	e(thm_tac(definition"-""Subâs_DEF"));
	show(save_top_thm"EXISTS_Subâs_THM");

	set_goal([], ¨∂ x1:'U≠'U∑SPEC_âs x1Æ);
	e(thm_tac(definition"-""âs_DEF"));
	show(save_top_thm"EXISTS_âs_THM");

	set_goal([], ¨∂ x1:'U≠'U∑SPEC_ﬁâs x1Æ);
	e(thm_tac(definition"-""ﬁâs_DEF"));
	show(save_top_thm"EXISTS_ﬁâs_THM");

	set_goal([], ¨∂ x1:'U≠'U≠'U∑SPEC_´âs x1Æ);
	e(thm_tac(definition"-""´âs_DEF"));
	show(save_top_thm"EXISTS_´âs_THM"); ()
end;

set_goal([¨∂mem:'U≠'U≠bool∑is_set_theory memÆ],¨µx:'U∑≥(x çâs öâs)Æ);
e(REWRITE_TAC[specification"-""öâs"]);
e(IMP_RES_THEN (REWRITE1_TAC o show o REWRITE_RULE[specification"-""is_separation"])(specification"-""Subâs") );
val thm1 = show(top_thm());

set_goal([¨∂mem:'U≠'U≠bool∑is_set_theory memÆ], ¨µx y:'U∑x çâs x ´âs y ± y çâs x ´âs yÆ);
e(IMP_RES_THEN (REWRITE1_TAC o REWRITE_RULE[specification"-""is_pair"])(specification"-""´âs") );
val thm2 = show(top_thm());


set_goal([¨∂mem:'U≠'U≠bool∑is_set_theory memÆ], ¨öâs:'U Ω 1âsÆ);
e(ASM_CASES_TAC¨öâs:'U = 1âsÆ THEN ASM_REWRITE_TAC[specification"SPC001_SUPPORT""Ω"]);
e(SUBGOAL_THEN¨∂x:'U∑x çâs öâsÆ (ACCEPT_TAC o REWRITE_RULE[thm1]));
e(ONCE_ASM_REWRITE_TAC[] THEN REWRITE_TAC[specification"-""1âs", specification"-""Unitâs"]);
e(EXISTS_TAC¨öâs:'UÆ THEN REWRITE_TAC[thm2]);
val thm3 = show(top_thm());

=TEX
{\twocolumn[\section{INDEX OF DEFINED TERMS}]
{\makeatletter
\printindex}}
\end{document}



