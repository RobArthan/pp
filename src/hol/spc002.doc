=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{TECHNOLOGY PROJECTS}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{A Semantics for HOL}  %% Mandatory field
\TPPref{DS/FMU/IED/SPC002}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{A formal specification, in HOL, of the semantics of HOL.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue 1.3  (27/07/90)]
Incomplete first draft for comment.
\item[Issue 1.4  (30/08/90)]
First ``complete'' draft. 
\end{description}
\subsection{Changes forecast}
\newpage
\section{GENERAL}
\subsection{Scope}
This document is an attempt to specify the
semantic aspects of the HOL logic using the HOL system.
\subsection{Introduction}
A set-theoretic semantics devised by A. Pitts for HOL is
given in \cite{SRI89a}. The treatment given is
not fully formal however it is ``possible in
principal to give a completely formal version within
{\tt ZFC} set theory''.
We wish to formalise the semantics in HOL.


A number of approaches have been considered to
specifying the semantics of HOL within HOL itself.
At one extreme, analogues of the axioms of {\tt ZFC} can
be introduced to give a theory in which we could hope to
construct a model of HOL and use it to prove
the consistency of all HOL theories which do not use
axiomatic extensions. At the other extreme we might try
a category-theoretic approach (see \cite{Lambek86}
or \cite{Hatcher82}), say by using definitional extensions
to define the notion of an interpretation of a
typed ç-calculus in a cartesian closed category and
to specify how this notion applies to HOL.
The main decisions to be made are:

\begin{itemize}
\item How general a class of structures do we wish to
consider as models for HOL?
\item Should we use axiomatic extensions?
\end{itemize}

Our present approach tries to be no more general than
it needs to be. Since we have no immediate interest in completeness
results or comparisons with other type theories, extra generality would probably only
be an obstacle to assessing the correctness of our
treatment and might well make it more difficult to
prove the soundness of the inference rules. Thus we have
opted for a set-theoretic treatment.

We do not wish to use axiomatic extensions\footnote{%
Axiomatic extensions are currently used to define some
aspects of the HOL syntax in \cite{DS/FMU/IED/SPC001}.
This is a temporary measure taken to defer some proof
work. It is more essential uses of axiomatic extensions
which we wish to eschew here.}.
To avoid them we formulate the semantics as a specification
of what a model should be, rather than as construction
of a particular model. This makes little difference
to the utility of the semantics since all it amounts to
is that we make explicit our assumption of the existence of an appropriate universe
of sets in which terms take their values.

\subsection{Initialisation}
Â
close_theory();
load_theory"SPC001";
new_theory"SPC002";
Ê
\pagebreak
\section{MODELS FOR SET THEORY IN HOL}

\subsection{Postulates for Elementary Set Theory}

We wish to define a notion of a model for set theory
within HOL. We will formulate this as a property
of a membership relation, $mem:*U ã *U ã bool$.
The type $*U$ over which $mem$ is defined corresponds
to the universe in the treatment in \cite{SRI89a}.

In the following sections we define predicates which
assist in defining our postulates for a set theory.

\subsubsection{Extensionality}
The predicate for extensionality is straightforward:
»
	‚extensional· : (*U ã *U ã bool) ã bool
…
	Émeméextensional mem Ç
		Éx y:*Uéx = y Ç (Éa:*Uémem a x Ç mem a y)
À
Note that we use the ordinary metalanguage equality as the
equality relation in $*U$. Since the extensionality
property implies that equality for sets is an equivalence
relation, this imposes no loss of generality (since we
could always work with the equivalence classes).
\subsubsection{Separation}
For us the postulate of separation will assert the existence
of a subset operator assigning to each set $x$ and
each property $P$ the subset of $x$ in which $P$ holds.
Note that, since $P$ is not constrained to be a property
which can be expressed in first-order set theory, this
postulate is, in general, stronger than that usual in
first-order treatments of set theory.

»
	‚is_separation· : (*U ã *U ã bool) ã (*U ã (*U ã bool) ã *U) ã bool
…
	Émem subéis_separation mem sub Ç
		Éx PéÉaémem a (sub x P) Ç mem a x Ä P a
À

Note that our universe is necessarily non-empty (since
metalanguage types are non-empty), so
extensionality and the
existence of a subset operator
with the above property will imply the existence of
a unique set with no elements (namely $sub\,x\,(ça.F)$
where $x$ is any term of type $*U$).

\subsubsection{Power Sets}
This postulate will assert the existence of an operator
assigning to each set the set of all its subsets.
»
	‚is_power· : (*U ã *U ã bool) ã (*U ã *U) ã bool
…
	Émem poweréis_power mem power Ç
		ÉxéÉaémem a (power x) Ç Ébémem b a ä mem b x
À

If $x$ is an element of $*U$ let us write $extent\,mem\,x$
for the metalanguage predicate $çxémem\,a\,x$ and
assume $mem$ satisfies the postulates of separation and
power sets, then, viewing metalanguage predicates
as sets, $extent\,mem\,(power\,x)$ will be in
1-1 correspondence with $çPéP\,•\,extent\,mem\,x$.
This will mean later our that our semantics uses
only the so-called standard models in which both object
language and metalanguage agree about the cardinality
of object language function spaces.
 
\subsubsection{Union Sets}
This postulate asserts the existence of an operator
assigning to each set the union of all its elements.
»
	‚is_union· : (*U ã *U ã bool) ã (*U ã *U) ã bool
…
	Émem unionéis_union mem union Ç
		ÉxéÉaémem a (union x) Ç Ñbémem a b Ä mem b x
À
\subsubsection{Unordered Pairs}
This postulate asserts the existence of an operator
assigning to any two sets a set whose elements are precisely
those sets.
»
	‚is_pair· : (*U ã *U ã bool) ã (*U ã *U ã *U) ã bool
…
	Émem pairéis_pair mem pair Ç
		Éx yéÉaémem a (pair x y) Ç a = x Å a = y
À
\subsection{Set Theories}
We will say that a relation, $mem$, is a set theory if
it admits
a subset operator, a power set operator
etc. satisfying the properties defined in the previous section.
»
	‚is_set_theory· : (*U ã *U ã bool) ã bool
…
	Émemé	is_set_theory mem Ç
		extensional mem
	Ä	(Ñsubéis_separation mem sub)
	Ä	(Ñpoweréis_power mem power)
	Ä	(Ñunionéis_union mem union)
	Ä	(Ñpairéis_pair mem pair)
À

This notion of a set theory is quite a weak one. An example
could be constructed without using axiomatic extensions
by using a countably infinite type to model the set of
hereditarily
finite sets in a classical set theory (see appendix \ref{Consistency}
below). I would conjecture that
one would only need to assert axiomatically the existence
of a set theory satisfying an axiom of infinity to give
a system strong enough to prove the consistency of HOL.

\subsection{Operations on Set Theories}

It is pleasant in the sequel to use notations similar to
the usual set-theoretic ones, at the very least by making
membership an infix operator.
Towards this end, we define polymorphic constants which will act
as membership relation and subset, power set, union and
pair operators in
any type which permits a set theory. 
The names of these constants are given a subscript to
distinguish them from constants used in parent theories.

\subsubsection{Primitive Operations}
First we fix a choice of membership relation, then we
define the other operators with respect to that choice.

Á
	$‚ù’·:*U ã *U ã bool
…
	(Ñmem:*U ã *U ã booléis_set_theory mem) ä
		is_set_theory ($ù’:*U ã *U ã bool)
À

»
	‚Sub’·	: *U ã (*U ã bool) ã *U
…
	(Ñmem:*U ã *U ã booléis_set_theory mem) ä
		is_separation ($ù’) (Sub’:*U ã (*U ã bool) ã *U)
À

»
	‚ë’·	: *U ã *U
…
	(Ñmem:*U ã *U ã booléis_set_theory mem) ä
		is_power ($ù’) (ë’:*U ã *U)
À

»
	‚£’·	: *U ã *U
…
	(Ñmem:*U ã *U ã booléis_set_theory mem) ä
		is_union ($ù’) (£’:*U ã *U)
À

We will use the symbol $ï’$ for the infix operator which
makes an unordered pair out of its operands:
Á
	$‚ï’·	: *U ã *U ã *U
…
	(Ñmem:*U ã *U ã booléis_set_theory mem) ä
		is_pair ($ù’) ($ï’:*U ã *U ã *U)
À

\subsubsection{Derived Operations}
As already mentioned, since the type $*U$ cannot be empty
we may construct an empty
set using the subset operator. This set will be denoted
$§’$:
»
	‚§’·	: *U
…
	§’ = Sub’ (áxéT) (çaéF)
À
$Unit’\,x$ will denote the singleton set $\{x\}$:
»
	‚Unit’·	: *U ã *U
…
	Éx:*Ué Unit’ x = x ï’ x
À
$1’$ denotes the set $\{§’\}$:
»
	‚1’·	: *U
…
	1’ = Unit’ §’
À
$2’$ denotes the set $\{§’, 1’\}$:
»
	‚2’·	: *U
…
	2’ = §’ ï’ 1’
À

$x\,ó’\,y$ will denote the ordered pair with first component $x$
and second component $y$, that is to say $\{\{x\},\{x,y\}\}$:
Á
	$‚ó’·	: *U ã *U ã *U
…
	Éx y:*Ué ($ó’) x y = Unit’ x ï’ (x ï’ y)
À
$°’$ will be the infix binary union operator:
Á
	$‚°’·	: *U ã *U ã *U
…
	Éx y:*Ué ($°’) x y = £’(x ï’ y)
À
$â\_’$ will be the infix binary product operator.
Since $\{\{x\},\{x,y\}\}\;•\;ë(ë(x\,°\,y))$, this may be defined
using the subset operator as follows. (Here, because of
lexical restrictions,
we need to tie the subscript to the operator name with an underscore):
Á
	$‚â_’·	: *U ã *U ã *U
…
	Éx y:*Ué ($â_’) x y = Sub’ (ë’(ë’(x °’ y))) (çaéÑb céb ù’ x Ä c ù’ y Ä a = b ó’ c)
À
For the infix relation space operator we use the Z-like
name $ê’$):
Á
	$‚ê’·	: *U ã *U ã *U
…
	Éx y:*Ué ($ê’) x y = ë’ (x â_’ y)
À
$ã\_’$ will be the infix total function space operator (again we need an underscore in the name):
Á
	$‚ã_’·	: *U ã *U ã *U
…
	Éx y:*Ué ($ã_’) x y = Sub’ (x ê’ y) (çféÉaé(a ù’ x) ä ¿bé(a ó’ b) ù’ f)
À
The infix operator $”’$ is used to denote application of a function
to an argument. (Note that $x$ here may not be a function and,
even if it is, $y$ may not be in its domain. These properties
will have to be proved as necessary.)
Á
	$‚”’·	: *U ã *U ã *U
…
	Éx y:*Ué ($”’) x y = áaé (y ó’ a) ù’ x
À
The following function is used to define the semantics of the
boolean type constructor.
$Bool’$ is a function taking the empty list to $2’$ and
any other list to the empty set.
»
	‚Bool’·	: *U list ã *U
…
		(Bool’ NIL = 2’)
	Ä	(Éx té Bool’ (CONS x t) = §’)
À
The following function is used to define the semantics of the
function space type constructor. $Fun’$ is a function which takes
a two element list, $[Dom, Rng]$, of non-empty elements of $*U$
to the set of functions from $Dom$ to $Rng$ and
which takes any other list to the empty set.
»
	‚Fun’·	: *U list ã *U
…
	ÉargséFun’ args =
		let Dom = HD args
		in let Rng = HD (TL args)
		in (args = [Dom; Rng] Ä Dom à §’ Ä Rng à §’ => Dom ã_’ Rng | §’)
À

The following function is used to define the semantics
of $ç$-abstraction. Note that there
is no guarantee that the result is a total function and
this will have to be proved where necessary.
»
	‚Abs’·	: (*U ã *U) ã *U ã *U ã *U
…
	Éf Dom RngéAbs’ f Dom Rng = Sub’ (Dom â_’ Rng) (çxéÑaéx = a ó’ f a)
À
The following function will represent the polymorphic
equality of HOL:
»
	‚EqRel’·	: *U ã *U
…
	Éx:*UéEqRel’ x = Sub’ (x â_’ x â_’ 2’)
			(çaéÑb céa = (b ó’ c ó’ (b = c => 1’ | §’)))
À
The following set will represent
the graph of the implication function:
»
	‚ImpRel’·	: *U
…
	ImpRel’ =
		Unit’(1’ ó’ 1’ ó’ 1’)
	°’	Unit’(1’ ó’ §’ ó’ §’)
	°’	Unit’(§’ ó’ 1’ ó’ 1’)
	°’	Unit’(§’ ó’ §’ ó’ 1’)
À
\pagebreak
\section{SEMANTICS FOR HOL}
\subsection{Semantics of Types}
\subsubsection{Type Constant Assignment}
The value we assign to a type constant is in effect a function from
$n$-tuples of non-empty elements of the universe $*U$ to 
non-empty elements of $*U$, where
$n$ is the arity of the type constant. Since we do not have
dependent types we represent such a thing as a function
of type $(*U\,list ã {*}U)$ which sends a list a length other
than $n$ to the empty set.
We make the following type abbreviation to facilitate this:
Â
TypeInference.new_type_abbrev "TY_CON_ASSIGNMENT" ª:string ã (*U list ã *U)º;
Ê

We say that a type constant assignment is well-formed with respect to a
type environment if the arities of the values assigned to
the type constant names agree with those in the type environment
and if the boolean and function space types are assigned appropriately.
»
	‚is_wf_ty_con_assignment·: TY_ENV ã *U TY_CON_ASSIGNMENT ã bool
…
	Étyenv tyconassé is_wf_ty_con_assignment tyenv tyconass Ç
		(Étycon argsé
			(tyconass tycon args à §’)
		Ç	((tyenv tycon (length args)) Ä Éaéa ≈ args ä a à §’))
	Ä	tyconass `bool` = Bool’
	Ä	tyconass `ã` = Fun’
À
\subsubsection{Type Variable Assignments}
A type variable assignment is just a total function from type
variables to the universe, $*U$. We make the following
type abbreviation for this notion.
Â
TypeInference.new_type_abbrev "TY_VAR_ASSIGNMENT" ª:string ã *Uº;
Ê
A type variable assignment will be well-formed if
all the values in its range are non-empty
»
	is_wf_ty_var_assignment : *U TY_VAR_ASSIGNMENT ã bool
…
	Étyvarasséis_wf_ty_var_assignment tyvarass Ç Étyvétyvarass tyv à §’
À
\subsubsection{Polymorphic Values}
Types and terms have polymorphic values. We
represent these as functions from type variable assignments
to $*U$. This corresponds to the use of certain
dependent products in the treatment in \cite{SRI89a}.
Â
TypeInference.new_type_abbrev "POLY_VALUE" ª:*U TY_VAR_ASSIGNMENT ã *Uº;
Ê

\subsubsection{Semantics of Types}
The value of a type with respect to a type constant assignment is a function
mapping type variable assignments onto polymorphic values:
»
	‚type_value·	:      *U TY_CON_ASSIGNMENT ã TYPE ã *U POLY_VALUE
…
	Étyconass s tylé
		type_value tyconass (mk_vartype s)  = (çtyvarassétyvarass s)
	Ä	type_value tyconass (mk_type(s, tyl)) =
		(çtyvarassétyconass s (map(çtyétype_value tyconass ty tyvarass) tyl))
À
\subsection{Semantics of Terms}
\subsubsection{Constant Assignments}
A constant assignment
is a function
assigning to each constant name a polymorphic value.

Â
TypeInference.new_type_abbrev "CON_ASSIGNMENT" ª:(string ã *U POLY_VALUE)º;
Ê

We call a constant assignment well-formed if
it sends implication and equality to appropriate
polymorphic values:
»
	‚is_wf_con_assignment·: *U CON_ASSIGNMENT ã bool
…
	Éconassé is_wf_con_assignment conass Ç
		Étyvarassé
			conass `=` tyvarass = EqRel’ (tyvarass `*`)
		Ä	conass `ä` tyvarass = ImpRel’
À

Here we rely on the fact that in the theory $MIN$ equality
is defined to have type $*ã*ãbool$.
\subsubsection{Interpretations}

An interpretation is a pair consisting of a
type constant assignment and a constant assignment:
Â
TypeInference.new_type_abbrev "INTERPRETATION"
		ª:*U TY_CON_ASSIGNMENT â *U CON_ASSIGNMENTº;
Ê

An interpretation is
considered to be well-formed with respect to a theory if the
type constant assignment is well-formed with respect to the type environment
of the theory and if the constant assignment is well-formed
and respects the type constant assignment
in an appropriate sense:
»
	‚is_wf_interpretation·	: THEORY ã *U INTERPRETATION ã bool
…
	Éthy tyconass conassé
		is_wf_interpretation thy (tyconass, conass)
	Ç (	is_wf_ty_con_assignment (types thy) tyconass
	  Ä	is_wf_con_assignment conass
	  Ä	És tyéconstants thy s ty ä
			Étyvarasséis_wf_ty_var_assignment tyvarass ä
				conass s tyvarass ù’ type_value tyconass ty tyvarass)
À
(Here $constants\,thy\,s\,ty$ is the assertion that a constant
named $s$ with type $ty$ has been defined in the theory $thy$.)
\subsubsection{Variable Assignments}
A variable assignment is a function sending name-type pairs
to polymorphic values. 
Â
TypeInference.new_type_abbrev "VAR_ASSIGNMENT" ª:(string â TYPE) ã *U POLY_VALUEº;
Ê

A variable assignment is considered to be well-formed
with respect to a type constant assignment if the following
condition holds:
»
	‚is_wf_var_ass·	: *U TY_CON_ASSIGNMENT ã *U VAR_ASSIGNMENT ã bool
…
	Étyconass varassé
		is_wf_var_ass tyconass varass
	Ç 	És ty tyvarasséis_wf_ty_var_assignment tyvarass ä
			varass (s, ty) tyvarass ù’ type_value tyconass ty tyvarass
À
\subsubsection{Semantics of Terms}
The value of a term with respect to a type assignment
and a constant assignment is a function
mapping variable assignments to polymorphic values.
If the term is a variable or a constant then the value
of the term is given by the variable assignment or
the constant assignment respectively.
If it is a combination, $f\,a$, then the application operator
$”’$ is used to apply the value of $f$ to that of $a$.
If the term is an abstraction, $çvéb$, then
we form
a metalanguage $ç$-abstraction which sends an element, $x$,
of the universe to the value taken by $b$ when $v$ takes
the polymorphic value which is identically $x$. We then
use $Abs’$ to construct a set in $*U$ from this metalanguage
$ç$-abstraction.  
»
	‚term_value·	: *U INTERPRETATION  ã
			TERM ã *U VAR_ASSIGNMENT ã *U POLY_VALUE
…
	Étyconass conass tm varass sty s ty f a v bé
		(has_mk_var sty tm ä
			term_value (tyconass, conass) tm varass
		=	(çtyvarassévarass  sty tyvarass))
	Ä	(has_mk_const(s, ty)tm ä
			term_value (tyconass, conass) tm varass
		=	(çtyvarasséconass s tyvarass))
	Ä	(has_mk_comb(f, a)tm ä
			term_value (tyconass, conass) tm varass
		=	let vf = term_value (tyconass, conass) f
			in let va = term_value (tyconass, conass) a
			in (çtyvarassévf varass tyvarass ”’ va varass tyvarass))
	Ä	(has_mk_abs(v, b)tm Ä has_mk_var sty v ä
			term_value (tyconass, conass) tm varass
		=	çtyvarassé
			let Dom = type_value tyconass (type_of_term v) tyvarass
			in let Rng = type_value tyconass (type_of_term b) tyvarass
			in let Fnc = (çx:*Ué
				term_value
				(tyconass, conass) b
				(çsty'ésty' = sty => (çtyvarass'éx) | varass sty')
				tyvarass)
			in Abs’ Fnc Dom Rng)
À
\subsection{Models of Theories}
\subsubsection{Satisfaction}
Using $term\_value$ and interpreting boolean
terms which evaluate to $çxé1’$ as true,
we can define the notion of
a sequence being satisfied by
an interpretation.
We define this notion as an infix relation between
interpretations and sequents. 
Á
	‚satisfies·	: *U INTERPRETATION ã SEQ ã bool
…
	Éint seqé($satisfies) int seq Ç
		Évarass tyvarassé
		let val_of = çtméterm_value int tm varass tyvarass
		in (Éasméasm ù hyp seq ä val_of asm = 1’) ä val_of (concl seq) = 1’
À
\subsubsection{Models}
A model for a theory is an interpretation which is
well-formed with respect to the theory and which satisfies
all of its axioms:
»
	‚is_model·	: THEORY ã *U INTERPRETATION ã bool
…
	Éthy inté
		is_model thy int Ç
		(is_wf_interpretation thy int Ä
		Éseqéseq ù axioms thy ä int satisfies seq)
À
\pagebreak
\appendix
\section{CONSISTENCY AND INDEPENDENCE} \label{Consistency}
In this appendix we briefly discuss the consistenc and mutual independencey of the
postulates for a set theory given in \ref{SetTheories} above.
We make use of informal set-theoretic notions.
\subsection{Consistency}
Since we have not included an axiom of infinity, a model
for the postulates may be constructed using a model of the
hereditarily finite sets\footnote{%
A set, A, is hereditarily finite if its transitive closure
is finite. Here the transitive closure
$tr\_cl\,A$, of $A$ is defined by
$tr_cl\,A = A\,°\,(£A)\,°\,(£(£A))\,°\,(£(£(£A)))\,°\,\ldots$.
Less formally, a set is hereditarily finite if it is finite, all
its elements are finite, all their elements are finite and so on.}
in classical set theory.

It is easy to see that the hereditarily finite sets would supply
a model for our postulates if we could represent them as an HOL
type and define the membership relation for them in terms of
that representation. This is straightforward: e.g. take the type, Ü,
of natural numbers under the relation, $mem$, informally described by:
ÛInformal Discussion
	mem i j Ç the i-th coefficient in the binary expansion of j is 1
Ê

Thus our definition of set theory is consistent in the sense
that some instance of the predicate $is\_set\_theory$ is
satisfiable.

Note that if one wishes to introduce an axiom of infinity
and attempt to construct a model for HOL on that basis,
then one can presumably construct a model just
using the separation and power set axioms.
This should follow from the fact that
the cumulative hierarchy in {\tt ZF} is constructed using
only the power set and union operators, since a model
for HOL only requires sets formed before stage $\omega + \omega$ and
the axiom of infinity gets one beyond stage $\omega$ immediately.

However as discussed in the next section, there are some
rather odd models if one drops the other postulates.


\subsection{Independence}
I believe that the chosen postulates are independent, however I
suspect that it is necessary to use non-well-founded relations
to show that  the existence of pairs is independent
of the other axioms. I now consider each postulate in turn:

\paragraph{Extensionality}
To see that extensionality is independent of the other postulates,
we adjoin a new empty individual, $X$ say,
to a model of all the postulates.
Of course, this actually introduces an infinite family of sets
constructed using $X$ and the various set forming operations.
The resulting system of sets satisfies all of the postulates
except extensionality.

\paragraph{Separation}
The identity relation on a one-element set supplies a model
of all of the postulates apart from separation.

\paragraph{Power Sets}
The hereditarily countable sets supply a model of all of the
postulates apart from the existence of power sets (see \cite{Kunen80} for more information).

\paragraph{Union Sets}
If we assume a model of all our postulate which also satisfies
an axiom of infinity, then it is easy to see that the set of
finite sets in the model satisfies all of the postulates except
for the existence of unions.

\paragraph{Pairs}
I believe that a model satisfying all the postulates except the
existence of pairs may be satisfied by adding two new individuals,
$X$ and $Y$ say, to a model, $M$ of all the postulates, together
with all the sets formed from $X$, $Y$ and the sets in $M$ using
the various set forming operations.  We then decree that
$X ù X$ and $Y ù Y$. The resulting model again satisfies all of
our postulates, I believe. The system obtained by restricting
the new model to sets whose transitive closure does not contain
$\{X, Y\}$ should then satisfy all of the postulates except the
existence of pairs.
=IGN
\subsection{Some Theorems}
let
	fun thm_tac thm = (
		REWRITE_TAC[thm] THEN EVERY[
		ASM_CASES_TACªÑ mem:*Uã*Uãbooléis_set_theory memº THEN ASM_REWRITE_TAC[],
		IMP_RES_TAC(specification"-""ù’") THEN
		DEF_RES_TAC(specification"-""is_set_theory")]
	);
in
	set_goal([], ªÑ x1:*Uã*UãbooléSPEC_ù’ x1º);
	e(thm_tac(definition"-""ù’_DEF"));
	show(save_top_thm"EXISTS_ù’_THM");

	set_goal([], ªÑ x1:*Uã(*Uãbool)ã*UéSPEC_Sub’ x1º);
	e(thm_tac(definition"-""Sub’_DEF"));
	show(save_top_thm"EXISTS_Sub’_THM");

	set_goal([], ªÑ x1:*Uã*UéSPEC_ë’ x1º);
	e(thm_tac(definition"-""ë’_DEF"));
	show(save_top_thm"EXISTS_ë’_THM");

	set_goal([], ªÑ x1:*Uã*UéSPEC_£’ x1º);
	e(thm_tac(definition"-""£’_DEF"));
	show(save_top_thm"EXISTS_£’_THM");

	set_goal([], ªÑ x1:*Uã*Uã*UéSPEC_ï’ x1º);
	e(thm_tac(definition"-""ï’_DEF"));
	show(save_top_thm"EXISTS_ï’_THM"); ()
end;

set_goal([ªÑmem:*Uã*Uãbooléis_set_theory memº],ªÉx:*Uéå(x ù’ §’)º);
e(REWRITE_TAC[specification"-""§’"]);
e(IMP_RES_THEN (REWRITE1_TAC o show o REWRITE_RULE[specification"-""is_separation"])(specification"-""Sub’") );
val thm1 = show(top_thm());

set_goal([ªÑmem:*Uã*Uãbooléis_set_theory memº], ªÉx y:*Uéx ù’ x ï’ y Ä y ù’ x ï’ yº);
e(IMP_RES_THEN (REWRITE1_TAC o REWRITE_RULE[specification"-""is_pair"])(specification"-""ï’") );
val thm2 = show(top_thm());


set_goal([ªÑmem:*Uã*Uãbooléis_set_theory memº], ª§’:*U à 1’º);
e(ASM_CASES_TACª§’:*U = 1’º THEN ASM_REWRITE_TAC[specification"SPC001_SUPPORT""à"]);
e(SUBGOAL_THENªÑx:*Uéx ù’ §’º (ACCEPT_TAC o REWRITE_RULE[thm1]));
e(ONCE_ASM_REWRITE_TAC[] THEN REWRITE_TAC[specification"-""1’", specification"-""Unit’"]);
e(EXISTS_TACª§’:*Uº THEN REWRITE_TAC[thm2]);
val thm3 = show(top_thm());

=TEX
{\twocolumn[\section{INDEX OF DEFINED TERMS}]
{\makeatletter
\printindex}}
\end{document}

