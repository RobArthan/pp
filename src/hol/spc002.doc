=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{TECHNOLOGY PROJECTS}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{A Semantics for HOL}  %% Mandatory field
\TPPref{DS/FMU/IED/SPC002}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{A formal specification, in HOL, of the semantics of HOL.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion (\today)]
Incomplete first draft for comment.
\end{description}
\subsection{Changes forecast}
\newpage
\section{GENERAL}
\subsection{Scope}
This document is an attempt to specify the
semantic aspects of the HOL logic using the HOL system.
\subsection{Introduction}
\subsection{Method}
A set-theoretic semantics devised by A. Pitts for HOL is
given in \cite{SRI89a}. The treatment given is
not fully formal however it is ``possible in
principal to give a completely formal version within
{\tt ZFC} set theory''.
We wish to formalise the semantics in HOL.


A number of approaches have been considered to
specifying the semantics of HOL within HOL itself.
At one extreme, analogues of the axioms of {\tt ZFC} can
be introduced to give a theory in which we could hope to
construct a model of HOL and use it to prove
the consistency of all HOL theories which do not use
axiomatic extensions. At the other extreme we might try
a category-theoretic approach (see \cite{Lambek86}
or \cite{Hatcher82}), say by using definitional extensions
to define the notion of an interpretation of a
typed ç-calculus in a cartesian closed category and
to specify how this notion applies to HOL.
The main decisions to be made are:

\begin{itemize}
\item How general a class of structures do we wish to
consider as models for HOL?
\item Should we use axiomatic extensions?
\end{itemize}

Our present approach tries to be no more general than
it needs to be. Since we have no immediate interest in completeness
results or comparisons with other type theories, extra generality would probably only
be an obstacle to assessing the correctness of our
treatment and might well make it more difficult to
prove the soundness of the inference rules. Thus we have
opted for a set-theoretic treatment.

We do not wish to use axiomatic extensions\footnote{%
Axiomatic extensions are currently used to define some
aspects of the HOL syntax in \cite{DS/FMU/IED/SPC001}.
This is a temporary measure taken to defer some proof
work. It is more essential uses of axiomatic extensions
which we wish to eschew here.}.
To avoid them we formulate the semantics as a specification
of what a model should be, rather than as construction
of a particular model. This makes little difference
to the utility of the semantics since all it amounts to
is that we make explicit our assumption of the existence of an appropriate universe
of sets in which terms take their values.

\subsection{Preamble}
Â
close_theory();
load_theory"SPC001";
new_theory"SPC002";
Ê
\pagebreak
\section{MODELS FOR SET THEORY IN HOL}

\subsection{Postulates for Elementary Set Theory}

We wish to define a notion of a model for set theory
within HOL. We will formulate this as a property
of a membership relation, $mem:*U ã *U ã bool$.
The type $*U$ over which $mem$ is defined corresponds
to the universe in the treatment in \cite{SRI89a}.

In the following sections we define predicates which
assist in defining our postulates for a set theory.

\subsubsection{Extensionality}
The predicate for extensionality is straightforward:
»
	‚extensional· : (*U ã *U ã bool) ã bool
…
	Émeméextensional mem Ç
		Éx y:*Uéx = y Ç (Éa:*Uémem a x Ç mem a y)
À

\subsubsection{Separation}
For us the postulate of separation will assert the existence
of a subset operator assigning to each set $x$ and
each property $P$ the subset of $x$ in which $P$ holds.
Note that, since $P$ is not constrained to be a property
which can be expressed in first-order set theory, this
postulate is, in general, stronger than that usual in
first-order treatments of set theory.

»
	‚is_separation· : (*U ã *U ã bool) ã (*U ã (*U ã bool) ã *U) ã bool
…
	Émem subéis_separation mem sub Ç
		Éx PéÉaémem a (sub x P) Ç mem a x Ä P a
À


\subsubsection{Power Sets}
This postulate will assert the existence of an operator
assigning to each set the set of all its subsets.
»
	‚is_power· : (*U ã *U ã bool) ã (*U ã *U) ã bool
…
	Émem poweréis_power mem power Ç
		ÉxéÉaémem a (power x) Ç Ébémem b a ä mem b x
À

If $x$ is an element of $*U$ let us write $extent\,mem\,x$
for the metalanguage predicate $çxémem\,a\,x$ and
assume $mem$ satisfies the postulates of separation and
power sets, then, viewing metalanguage predicates
as sets, $extent\,mem\,(power\,x)$ will be in
1-1 correspondence with $çPéP\,•\,extent\,mem\,x$.
This will mean later our that our semantics uses
only the so-called standard models in which both object
language and metalanguage agree about the cardinality
of object language function spaces.
 
\subsubsection{Union Sets}
This postulate asserts the existence of an operator
assigning to each sets the union of all its elements.
»
	‚is_union· : (*U ã *U ã bool) ã (*U ã *U) ã bool
…
	Émem unionéis_union mem union Ç
		ÉxéÉaémem a (union x) Ç Ñbémem a b Ä mem b x
À
\subsubsection{Unordered Pairs}
This postulate asserts the existence of an operator
assigning to any two sets a set whose elements are precisely
those sets.
»
	‚is_pair· : (*U ã *U ã bool) ã (*U ã *U ã *U) ã bool
…
	Émem pairéis_pair mem pair Ç
		Éx yéÉaémem a (pair x y) Ç a = x Å a = y
À
\subsection{Set Theories}\label{SetTheories}
\subsubsection{Definition of a Set Theory}
We will say that a relation, $mem$, is a set theory if
it satisfies the predicates of the previous section
for an appropriate choice of subset operator, power set operator
etc.
»
	‚is_set_theory· : (*U ã *U ã bool) ã bool
…
	Émemé	is_set_theory mem Ç
		extensional mem
	Ä	(Ñsubéis_separation mem sub)
	Ä	(Ñpoweréis_power mem power)
	Ä	(Ñunionéis_union mem union)
	Ä	(Ñpairéis_pair mem pair)
À

This notion of a set theory is quite a weak one. An example
could be constructed without using axiomatic extensions
by using a countably infinite type to model the set of
hereditarily
finite sets in a classical set theory (see appendix \ref{Consistency}
below). I would conjecture that
one would only need to assert axiomatically the existence
of a set theory satisfying an axiom of infinity to give
a system strong enough to prove the consistency of HOL.

\section{OPERATIONS ON SET THEORIES}

It is pleasant in the sequel to use notations similar to
the usual set-theoretic ones, at the very least by making
membership an infix operator.
Towards this end, we define polymorphic constants which will act
as membership relation, subset operator, power set operator etc. in
any type which permits a set theory. 
The names of these constants are given a subscript to
distinguish them from constants used in parent theories.

\subsection{Primitive Operations}
First we fix a choice of membership relation, then we
define the other operators with respect to that choice.

Á
	$‚ù’·:*U ã *U ã bool
…
	(Ñmem:*U ã *U ã booléis_set_theory mem) ä
		is_set_theory ($ù’:*U ã *U ã bool)
À

»
	‚Sub’·	: *U ã (*U ã bool) ã *U
…
	(Ñmem:*U ã *U ã booléis_set_theory mem) ä
		is_separation ($ù’) (Sub’:*U ã (*U ã bool) ã *U)
À

»
	‚ë’·	: *U ã *U
…
	(Ñmem:*U ã *U ã booléis_set_theory mem) ä
		is_power ($ù’) (ë’:*U ã *U)
À

»
	‚£’·	: *U ã *U
…
	(Ñmem:*U ã *U ã booléis_set_theory mem) ä
		is_union ($ù’) (£’:*U ã *U)
À

We will use the symbol $ï’$ for the infix operator which
makes an unordered pair out of its operands:
Á
	$‚ï’·	: *U ã *U ã *U
…
	(Ñmem:*U ã *U ã booléis_set_theory mem) ä
		is_pair ($ù’) ($ï’:*U ã *U ã *U)
À

\subsection{Derived Operations}
Since the type $*U$ cannot be empty we may construct an empty
set using the subset operator. This set will be denoted
$§’$:
»
	‚§’·	: *U
…
	(§’:*U) = Sub’ (áxéT) (çaéF)
À
$Unit’\,x$ will denote the singleton set $\{x\}$:
»
	‚Unit’·	: *U ã *U
…
	Éx:*Ué Unit’ x = x ï’ x
À
$1’$ denotes the set $\{§’\}$:
»
	‚1’·	: *U
…
	1’ = Unit’ §’
À
$2’$ denotes the set $\{§’, 1’\}$:
»
	‚2’·	: *U
…
	2’ = §’ ï’ 1’
À

$x\,–’\,y$ will denote the ordered pair with first component $x$
and second component $y$, that is to say $\{\{x\},\{x,y\}\}$:
Á
	$‚–’·	: *U ã *U ã *U
…
	Éx y:*Ué ($–’) x y = Unit’ x ï’ (x ï’ y)
À
$°’$ will be the infix binary union operator:
Á
	$‚°’·	: *U ã *U ã *U
…
	Éx y:*Ué ($°’) x y = £’(x ï’ y)
À
$â_’$ will be the infix binary product operator.
Since $\{\{x\},\{x,y\}\}\;•\;ë(ë(x\,°\,y))$, this may be defined
using the subset operator as follows. (Here, because of
lexical restrictions,
we need to tie the subscript to the operator name with an underscore):
Á
	$‚â_’·	: *U ã *U ã *U
…
	Éx y:*Ué ($â_’) x y = Sub’ (ë’(ë’(x °’ y))) (çaéÑb céa = b –’ c)
À
For the infix relation space operator we use the Z-like
name $ê’$):
Á
	$‚ê’·	: *U ã *U ã *U
…
	Éx y:*Ué ($ê’) x y = ë’ (x â_’ y)
À
$ã_’$ will be the infix total function space operator (again we need an underscore in the name):
Á
	$‚ã_’·	: *U ã *U ã *U
…
	Éx y:*Ué ($ã_’) x y = Sub’ (x ê’ y) (çféÉaé(a ù’ x) ä ¿bé(a –’ b) ù’ f)
À
The infix operator $”’$ is used to denote application of a function
to an argument:
Á
	$‚”’·	: *U ã *U ã *U
…
	Éx y:*Ué ($”’) x y = áaé (y –’ a) ù’ x
À
The following function is used to define the semantics of the
function space type constructor. $Fun’$ is a function taking
a two element list, $[Dom, Rng]$, of non-empty elements of $*U$
to the set of functions from $Dom$ to $Rng$ and
which take any other list to the empty set.
»
	‚Fun’·	: *U list ã *U
…
	ÉargséFun’ args =
		let Dom = HD args
		in let Rng = HD (TL args)
		in (args = [Dom; Rng] Ä Dom à §’ Ä Rng à §’ => Dom ã_’ Rng | §’)
À

The following function is used to define the semantics
of $ç$-abstraction. Note that there
is no guarantee that the result is a total function and
this will have to be proved where necessary.
»
	‚Abs’·	: (*U ã *U) ã *U ã *U ã *U
…
	Éf Dom RngéAbs’ f Dom Rng = Sub’ (Dom â_’ Rng) (çxéÑaéx = a –’ f a)
À

\pagebreak
\section{SEMANTICS OF TYPES}
\subsection{Type Constant Assignment}
The value we assign to a type constant is in effect a function from
$n$-tuples of non-empty elements of the universe $*U$ to 
non-empty elements of $*U$, where
$n$ is the arity of the type constant. Since we do not have
dependent types we represent such a thing as a function
of type $(*U\,list ã {*}U)$.
We make the following type abbreviation to facilitate this:
Â
TypeInference.new_type_abbrev "TY_CON_ASSIGNMENT" ª:string ã (*U list ã *U)º;
Ê

We say that a type constant assignment is well-formed with respect to a
type environment if the arities of the meanings assigned to
the type constant names agree with those in the type environment
and if the boolean and function space types are assigned to
appropriate elements of *U.
»
	‚is_wf_ty_con_assignment·: TY_ENV ã *U TY_CON_ASSIGNMENT ã bool
…
	Étyenv tyconassé is_wf_ty_con_assignment tyenv tyconass Ç
		(Étycon argsé
			(tyconass tycon args à §’)
		Ç	((tyenv tycon (length args)) Ä Éaéa ≈ args ä a à §’))
	Ä	tyconass(FST(dest_type Bool)) = 2’
	Ä	tyconass(FST(dest_type(Fun Bool Bool))) = Fun’
À
(The $FST(dest\_type\ldots)$ constructs here merely select the
names of the boolean and function space type constants).
\subsection{Type Variable Assignments}
A type variable assignment is just a total function from type
variables to the universe, $*U$. We make the following
type abbreviation for this notion.
Â
TypeInference.new_type_abbrev "TY_VAR_ASSIGNMENT" ª:string ã *Uº;
Ê
A type variable assignment will be well-formed if
all the values in its range are non-empty
»
	is_wf_ty_var_assignment : *U TY_VAR_ASSIGNMENT ã bool
…
	Étyvarasséis_wf_ty_var_assignment tyvarass Ç
		Étyvétyvarass tyv à §’
À
\subsection{Polymorphic Values}
Types and terms have polymorphic values which we
represent as functions from type variable assignments
to $*U$. This corresponds to to the use of certain
dependent products in the treatment in \cite{SRI89a}.
Â
TypeInference.new_type_abbrev "POLY_VALUE" ª:*U TY_VAR_ASSIGNMENT ã *Uº;
Ê

\subsection{Semantics of Types}
The value of a type with respect to a type constant assignment is a function
mapping type variable assignments onto polymorphic values:
»
	‚type_value·	:      *U TY_CON_ASSIGNMENT ã TYPE ã *U POLY_VALUE
…
	Étyconass s tylé
		type_value tyconass (mk_vartype s)  = (çtyvarassétyvarass s)
	Ä	type_value tyconass (mk_type(s, tyl)) =
		(çtyvarassétyconass s (map(çtyétype_value tyconass ty tyvarass) tyl))
À
\pagebreak
\section{SEMANTICS OF TERMS}
\subsection{Constant Assignments}
A constant assignment
is a function
assigning to each constant name a polymorphic value.

Â
TypeInference.new_type_abbrev "CON_ASSIGNMENT" ª:(string ã *U POLY_VALUE)º;
Ê


A type constant assignment and a constant assignment are
considered to be well-formed with respect to a theory if the
type constant assignment is well-formed with respect to the type environment
of the theory and if the constant assignment respects the type constant assignment
in a sense which is easier to express formally than in words:
»
	‚are_wf_assignments·	: THEORY ã *U TY_CON_ASSIGNMENT ã *U CON_ASSIGNMENT ã bool
…
	Éthy tyconass conassé
		are_wf_assignments thy tyconass conass
	Ç (	is_wf_ty_con_assignment (types thy) tyconass
	  Ä	És tyéconstants thy s ty ä
			Étyvarasséis_wf_ty_var_assignment tyvarass ä
				conass s tyvarass ù’ type_value tyconass ty tyvarass)
À
(Here $constants\,thy\,s\,ty$ is the assertion that a constant
named $s$ with type $ty$ has been defined in the theory.)
\subsection{Variable Assignments}
A variable assignment is a function sending name-type pairs
to polymorphic values. 
Â
TypeInference.new_type_abbrev "VAR_ASSIGNMENT" ª:(string â TYPE) ã *U POLY_VALUEº;
Ê

A variable assignment is considered to be well-formed
with respect to a type constant assignment if the following
condition holds:
»
	‚is_wf_var_ass·	: *U TY_CON_ASSIGNMENT ã *U VAR_ASSIGNMENT ã bool
…
	Étyconass varassé
		is_wf_var_ass tyconass varass
	Ç 	És ty tyvarasséis_wf_ty_var_assignment tyvarass ä
			varass (s, ty) tyvarass ù’ type_value tyconass ty tyvarass

À
\subsection{Semantics of Terms}
The value of a term with respect to a type assignment
and a constant assignment is a function
mapping variable assignments to polymorphic values.
If the term is a variable or a constant then the value
of the term is found in the variable assignment or
the constant assignment respectively.
If it is a combination, $f\,a$, then the application operator
$”’$ is used to apply the value of $f$ to that of $a$.
If the term is an abstraction, $çvéb$, then
essentially we form
the metalanguage $ç$-abstraction which sends an element, $x$,
of the universe to the value taken by $b$ when $v$ takes
the polymorphic value which is identically $x$. We then
use $Abs’$ to construct a set in $*U$ from this metalanguage
$ç$-abstraction.  
»
	‚term_value·	: *U TY_CON_ASSIGNMENT ã *U CON_ASSIGNMENT  ã
			TERM ã *U VAR_ASSIGNMENT ã *U POLY_VALUE
…
	Étyconass conass tm varass sty s ty f a v bé
		(has_mk_var sty tm ä
			term_value tyconass conass tm varass
		=	(çtyvarassévarass  sty tyvarass))
	Ä	(has_mk_const(s, ty)tm ä
			term_value tyconass conass tm varass
		=	(çtyvarasséconass s tyvarass))
	Ä	(has_mk_comb(f, a)tm ä
			term_value tyconass conass tm varass
		=	let vf = term_value tyconass conass f
			in let va = term_value tyconass conass a
			in (çtyvarassévf varass tyvarass ”’ va varass tyvarass))
	Ä	(has_mk_abs(v, b)tm Ä has_mk_var sty v ä
			term_value tyconass conass tm varass
		=	çtyvarassé
			let Dom = type_value tyconass (type_of_term v) tyvarass
			in let Rng = type_value tyconass (type_of_term b) tyvarass
			in let Fnc = (çx:*Ué
				term_value
				tyconass conass b
				(çsty'ésty' = sty => (çtyvarass'éx) | varass sty')
				tyvarass)
			in Abs’ Fnc Dom Rng)
À
\section{MODELS}
{\footnotesize
Using $term\_value$ we will define the truth of a sequent with respect
to a type constant and type variable assignment:
namely the sequent will be true if whenever its
assumptions all evaluate to $1’$ then so does its conclusions.

A model will be a pair consisting of a type constant
assignment and a type variable assignment such that
these things are well-formed with respect to the
theory (using $are\_wf\_assignments$).

A model will be said to be standard, if it
sends implication and equality to implication
and equality (defined as suitable polymorphic values)
and sends choice to a polymorphic value which
behaves as a choice function.

One could then prove a few simple things, e.g. that the
existence of a model implied consistency.
}
\pagebreak
\appendix
\section{CONSISTENCY AND INDEPENDENCE} \label{Consistency}
In this appendix we briefly discuss the consistenc and mutual independencey of the
postulates for a set theory given in \ref{SetTheories} above.
We make use of informal set-theoretic notions.
\subsection{Consistency}
Since we have not included an axiom of infinity, a model
for the postulates may be constructed using a model of the
hereditarily finite sets\footnote{%
A set, A, is hereditarily finite if its transitive closure
is finite. Here the transitive closure
$tr\_cl\,A$, of $A$ is defined by:
ÛInformal Discussion
	tr_cl A = A ° (£A) ° (£(£A)) ° (£(£(£A))) ° ...
Ê
Less formally, a set is hereditarily finite if it is finite, all
its elements are finite, all their elements are finite and so on.}
in classical set theory.

It is easy to see that the hereditarily finite sets would supply
a model for our postulates if we could represent them as an HOL
type and define the membership relation for them in terms of
that representation. This is straightforward: e.g. take the type, Ü,
of natural numbers under the relation, mem, informally described by:
ÛInformal Discussion
	mem i j Ç the i-th coefficient in the binary expansion of j is 1
Ê

Thus our definition of set theory is consistent in the sense
that some instance of the predicate $is\_set\_theory$ is
satisfiable.

Note that if one wishes to introduce an axiom of infinity
and attempt to construct a model for HOL on that basis,
then one can probably actually construct a model just
using the separation and power set axioms.
This should follow from the fact that
the cumulative hierarchy in {\tt ZF} is constructed
only the power set and union operators are used, since a model
for HOL only requires sets formed before stage $\omega + \omega$ and
the axiom of infinity gets one beyond stage $\omega$ immediately.

However as discussed in the next section, there are some
rather odd models if one drops the other postulates.


\subsection{Independence}
I believe that the chosen postulates are independent, however I
suspect that it is necessary to use non-well-founded relations
to show that  the existence of pairs is independent
of the other axioms. I now consider each postulate in turn:

\paragraph{Extensionality}
To see that extensionality is independent of the other postulates,
we adjoin a new empty individual, $X$ say,
or so-called urelement to a model of all the postulates.
Of course, this actually introduces an infinite family of sets
constructed using $X$ and the various set forming operations.
The resulting system of sets satisfies all of the postulates
except extensionality.

\paragraph{Separation}
The identity relation on a one-element set supplies a model
of all of the postulates apart from separation.

\paragraph{Power Sets}
The hereditarily countable sets supply a model of all of the
postulates apart from the existence of power sets (see \cite{Kunen80} for more information).

\paragraph{Union Sets}
If we assume a model of all our postulate which also satisfies
an axiom of infinity, then it is easy to see that the set of
finite sets in the model satisfies all of the postulates except
for the existence of unions.

\paragraph{Pairs}
I believe that a model satisfying all the postulates except the
existence of pairs may be satisfied by adding two new individuals,
$X$ and $Y$ say, to a model, $M$ of all the postulates, together
with all the sets formed from $X$, $Y$ and the sets in $M$ using
the various set forming operations.  We then decree that
$X ù X$ and $Y ù Y$. The resulting model again satisfies all of
our postulates, I believe. The system obtained by restricting
the new model to sets whose transitive closure does not contain
$\{X, Y\}$ should then satisfy all of the postulates except the
existence of pairs.

{\twocolumn[\section{INDEX OF DEFINED TERMS}]
{\makeatletter
\printindex}}
\end{document}

