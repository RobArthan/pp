=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for Derived Terms}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP004}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}
%\TPPstatus{Approved}
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives an implementation for functions concerning derived terms that are not used in defining the type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1 to 1.13]
Initial Drafts
\item [Issue 1.14,1.15]
Changes in response to deskcheck ID0091.
\item [Issue 2.1 (20th November 1991)]
Approved version of issue 1.15.

\item[Issue 2.2, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 2.3, 2.4 (11th February 1992)]
Added functions $list\_mk\_≠\_type$, $strip\_≠\_type$,
$is\-\_empty\-\_list$, $dest\-\_empty\-\_list$,
$dest\-\_t$, $dest\-\_f$,
$is\-\_ö$, and $dest\-\_ö$.
\item [Issue 2.5 (16th March 1992)]
Added stripping combinators.
\item [Issue 2.6 (1st April 1992)]
Changes required by CR0016.
\item [Issue 2.7 (13th April 1992)]
Changes due to CR0017.

\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of some functions for derived terms of ICL HOL, and functions to handle them, called for by section 4.2 of the Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
They are not required for the implementation of type $THM$, such derived functions may be found in \cite{DS/FMU/IED/DTD003}.
The high-level specification for the code may be considered
to be given in \cite{DS/FMU/IED/SPC001}.
The design is in \cite{DS/FMU/IED/DTD004}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of functions for derived terms of ICL HOL, and functions to handle them.
\subsubsection{Dependencies}
This document's signature is given in \cite{DS/FMU/IED/DTD004}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{DERIVED TERMS}
=SML
structure €TypesAndTerms› : TypesAndTerms = struct
=TEX
First gain the items implemented in $icl'TypesAndTerms$.
Opening that structure here allows an invisible (at the user interface level) movement of items between the two structures.
=SML
open icl'TypesAndTerms;
=TEX
\subsection{Generic Stripping Functions}
=SML
fun €strip_leaves› (dest:'a -> 'a * 'a) : 'a -> 'a list = (
let	fun aux x = (
	let	val (x1,x2) = dest x
	in
		aux x1 @ aux x2
	end
	handle (Fail _) => [x]);
in
	aux
end);
=TEX
=SML
fun €strip_spine_left› (dest:'a -> 'a * 'a) : 'a -> 'a list = (
let	fun aux x = (
	let	val (x1,x2) = dest x
	in
		aux x1 @ [x2]
	end
	handle (Fail _) => [x]);
in
	aux
end);
=TEX
=SML
fun €strip_spine_right› (dest:'a -> 'a * 'a) : 'a -> 'a list = (
let	fun aux x = (
	let	val (x1,x2) = dest x
	in
		x1 :: aux x2
	end
	handle (Fail _) => [x]);
in
	aux
end);
=TEX

\subsection{Derived Type Functions}
=SML
fun €list_mk_≠_type› ([ty]:TYPE list) : TYPE = ty
| list_mk_≠_type (ty :: tys) = mk_≠_type(ty, list_mk_≠_type tys)

| list_mk_≠_type ([]:TYPE list) = fail "list_mk_≠_type" 3017 [];

val €strip_≠_type› : TYPE -> TYPE list = strip_spine_right dest_≠_type;

=TEX
\subsection{Truth Values}
=SML
val €mk_t› : TERM = mk_const("T",BOOL);
fun €is_t› (tm : TERM) : bool = (tm =$ mk_t);
fun €dest_t› (tm:TERM) : unit = (
	if tm =$ mk_t
	then ()
	else term_fail "dest_t" 4036 [tm]
);
=TEX
=SML
val €mk_f› : TERM = mk_const("F",BOOL);
fun €is_f› (tm : TERM) : bool = (tm =$ mk_f);
fun €dest_f› (tm:TERM) : unit = (
	if tm =$ mk_f
	then ()
	else term_fail "dest_f" 4037 [tm]
);
=TEX
\subsection{Pairs}
=SML
fun €mk_∏_type› ((t1, t2) : TYPE * TYPE): TYPE = mk_ctype("∏", [t1, t2]);

fun €dest_∏_type› (ty : TYPE): TYPE * TYPE = (
	case dest_simple_type ty of
	Ctype ("∏",[t1,t2]) => (t1,t2)
	| _ => type_fail "dest_∏_type" 4018 [ty]
);
fun €is_∏_type› (ty : TYPE): bool = (
	case dest_simple_type ty of
	Ctype ("∏",[t1,t2]) => true
	| _ => false
);

local
	fun comma (ty1: TYPE) (ty2: TYPE): TERM = (
	mk_const(",", mk_≠_type (ty1, mk_≠_type (ty2, mk_∏_type (ty1,ty2))))
);
in
fun €mk_pair› (xy: TERM * TERM) : TERM = (
	(mk_bin_op "mk_pair" 4033 4033 comma xy)
	handle (Fail _) =>
	error "mk_pair" 4033 [fn () => PolyML.makestring (fst xy),	
		fn () => PolyML.makestring (snd xy)]);
end;

val €dest_pair› : TERM -> (TERM * TERM) = dest_bin_op "dest_pair" 4003 ",";

val €is_pair› : TERM -> bool = is_bin_op ",";
=TEX
\subsection{(Paired) Ã-abstractions}
=SML
local
fun Uncurry (t1:TYPE) (t2:TYPE) (t3:TYPE):TERM = (
	mk_const("Uncurry",
	mk_≠_type(mk_≠_type(t1,mk_≠_type(t2, t3)), mk_≠_type(mk_∏_type(t1, t2), t3)))
);
in
=TEX
The following function can handle an arbitrarily nested paired abstraction.
=SML
fun €mk_Ã› ((x, y): TERM * TERM) : TERM = (
	(if is_pair x
	then (let val (a,b) = dest_pair x;
		val ta = type_of a and
			tb = type_of b
	in
		mk_app(Uncurry ta tb (type_of y),
			mk_Ã(a, mk_Ã(b, y)))
	end)
	else mk_simple_Ã(x, y))
	handle complaint => 
	case area_of complaint of
	"mk_simple_Ã" => term_fail "mk_Ã" 4016 [x]
	| anm => reraise complaint anm
);
end;
=TEX
=SML
fun €dest_Ã› (ab : TERM) : TERM * TERM = (
	(if is_simple_Ã ab
	then dest_simple_Ã ab
	else let val (a,b) = dest_app ab
	in
		if is_const a andalso (fst(dest_const a) = "Uncurry")
		then (let val (b1, b2) = dest_Ã b;
			val (b21, b22) = dest_Ã b2
		in
			(mk_pair(b1,b21), b22)
		end)
		else fail "dest_Ã" 4002 []
	end)
	handle (Fail _) => 
	term_fail "dest_Ã" 4002 [ab]
);
=TEX
=SML
fun €is_Ã› (tm : TERM) : bool = (dest_Ã tm; true) handle (Fail _) => false;
=TEX
\subsection{Generic Binders}
=SML
fun €mk_binder› (area : string) (msg : int) (binder:TYPE -> TYPE -> TERM) 
	((v, b) : TERM * TERM) : TERM = (
	
	(mk_app (binder (type_of v) (type_of b), 
		mk_Ã(v, b)))
	handle complaint => 
	case area_of complaint of
	"mk_Ã" => pass_on complaint "mk_Ã" area
	| _ => term_fail area msg [v,b]
);

fun €dest_binder› (area_name : string) (msg : int) (op_name : string)
	(tm : TERM) : TERM * TERM = (
	let	val (binder, abs) = dest_app tm;
		val (var, body) = dest_Ã abs;
	in	if fst (dest_const binder) = op_name
		then (var, body)
		else fail area_name msg []
	end
	handle (Fail _) => term_fail area_name msg [tm]
);

fun €is_binder› (op_name : string) (tm : TERM) : bool = (
	let	val (binder, bdy) = dest_app tm;
	in	is_Ã bdy
		andalso
		(fst (dest_const binder) = op_name)
	end
	handle (Fail _) => false
);
=TEX
=SML
fun €list_mk_binder› (maker : TERM * TERM -> TERM) 
	((tml, tm) : TERM list * TERM) : TERM = (
let	fun aux [] = tm
	| aux (htm :: ttm) = maker(htm, (aux ttm))
in
	aux tml
end);
=TEX
=SML
fun €strip_binder› (op_name : string) (tm : TERM) : TERM list * TERM = (
let	fun aux (tm1:TERM) : (TERM list * TERM) = (
	let	val (binder, abs) = dest_app tm1;
		val (var, body) = dest_Ã abs;
	in	if fst (dest_const binder) = op_name
		then (let val (vs,bd) = aux body;
		in
			((var :: vs) , bd)
		end)
		else ([],tm1)
	end
	handle (Fail _) => ([],tm1)
	);
in
	aux tm
end);
fun €strip_simple_binder› (op_name : string) (tm : TERM) : TERM list * TERM = (
let	fun aux (tm1:TERM) : (TERM list * TERM) = (
	let	val (binder, abs) = dest_app tm1;
		val (var, body) = dest_simple_Ã abs;
	in	if fst (dest_const binder) = op_name
		then (let val (vs,bd) = aux body;
		in
			((var :: vs) , bd)
		end)
		else ([],tm1)
	end
	handle (Fail _) => ([],tm1)
	);
in
	aux tm
end);
=TEX
\subsection{(Paired) Ã-abstractions II}
=SML
val €list_mk_Ã› : (TERM list * TERM) -> TERM = list_mk_binder mk_Ã;

fun €strip_Ã› (tm : TERM ) : (TERM list * TERM) = (
let	val (var, body) = dest_Ã tm;
in	(let	val (vs,bd) = strip_Ã body;
	in
		((var :: vs) , bd)
	end)
end
handle (Fail _) => ([],tm)
);
=TEX
\subsection{Conjunctions}
=SML
val €mk_±› : (TERM * TERM) -> TERM = (
	mk_bin_op "mk_±" 3031 3015 (bin_bool_op "±")
);

val €dest_±› : TERM -> (TERM * TERM) = (
	dest_bin_op "dest_±" 4032 "±"
);

val €is_±› : TERM -> bool = is_bin_op "±";

val €list_mk_±› : TERM list -> TERM = (
	list_mk_bin_op "list_mk_±" 3031 3015 (bin_bool_op "±")
);

val €strip_±› : TERM -> TERM list = strip_bin_op "±";
=TEX
\subsection{Disjunctions}
=SML
val €mk_≤› : (TERM * TERM) -> TERM = (
	mk_bin_op "mk_≤" 3031 3015 (bin_bool_op "≤")
);

val €dest_≤› : TERM -> (TERM * TERM) = (
	dest_bin_op "dest_≤" 4027 "≤"
);

val €is_≤› : TERM -> bool = is_bin_op "≤";

val €list_mk_≤› : TERM list -> TERM = (
	list_mk_bin_op "list_mk_≤" 3031 3015 (bin_bool_op "≤")
);

val €strip_≤› : TERM -> TERM list = strip_bin_op "≤";
=TEX
\subsection{Bi-implications}
=SML
val €mk_§› : (TERM * TERM) -> TERM =(
	 mk_bin_op "mk_§" 3031 3015 (bin_bool_op "=")
);

fun €dest_§› (tm : TERM) : (TERM * TERM) = (
let	val (tm1, tm2) = dest_bin_op "dest_§" 4031 "=" tm
in
	if (type_of tm1 =: BOOL)
	then (tm1, tm2)
	else term_fail "dest_§" 4031 [tm]
end);

fun €is_§› (tm : TERM) : bool = (
let	val (tm1, tm2) = dest_eq tm
in
	(type_of tm1 =: BOOL)
end
handle (Fail _) => false);
=TEX
\subsection{Conditionals}
=SML
fun €mk_if› (c : TERM, y : TERM, n : TERM) : TERM = (
let	val cty = type_of c;
	val yty = type_of y
in
	if not(cty =: BOOL)
	then term_fail "mk_if" 3031 [c]
	else if not(yty =: type_of n)
	then term_fail "mk_if" 3012 [y,n]
	else	let	val If = mk_const("Cond", 
			mk_≠_type (BOOL,(mk_≠_type (yty,(mk_≠_type(yty, yty))))));
		in	mk_app(mk_app(mk_app(If, c), y), n)
		end
end);
=TEX
=SML
fun €is_if› (tm : TERM) : bool = (
	let	val rand = (fst o dest_app);
		val name = fst(dest_const(rand(rand(rand tm))));
	in	name = "Cond"
	end handle (Fail _) => false
);
=TEX
=SML
fun €dest_if› (tm : TERM) : (TERM * TERM * TERM) = (
	(case ((fst o dest_const) ** Combinators.I)(strip_app tm) of
		("Cond", [c, y, n]) => (c, y, n)
	|	_ => fail "dest_if" 4006 [])
	handle (Fail _) => 
	term_fail "dest_if" 4006 [tm]
);
=TEX
\subsection{Let-terms}
We implement $mk\_let$ to carry out three steps:
\begin{enumerate}
\item
Given a list of local bindings, $bindings$, process them with $process\_bindings$, to replace bindings of local functions, e.g. $f\ x\ =\ y$, with bindings of variable structures (actually the replacement will always be with variables) to abstractions, e.g. $f\ =\ Ã\ x\ ∑\ y$.
This gives us $bindings'$.
Bindings to variable structures will be left unchanged in this step.
\item
Abstract, as a list, the variable structures of $bindings'$ from the body of the local definition, $bdy$, using $list\_mk\_Ã$.
\item
Apply the abstracted body to the values of $bindings'$,
using the marker function $Let$ to indicate the presence of a local definition construct.
This is done in $aux$ by repeatedly calling $l\_mk\_let$.
\end{enumerate}
=SML
fun €mk_let› ((bindings, bdy): (TERM * TERM)list * TERM) : TERM = (
let
	fun l_mk_let (t2, t3) = (
		let	val tt2 = type_of t2 and
		 		tt3 = type_of t3;
			val (tt31,tt32) = dest_≠_type tt3
		in
			mk_app(mk_app(
			 mk_const("Let",
			 mk_≠_type(tt3,mk_≠_type(tt2,tt32))),
			 t3), t2)
		end);

	fun aux [] bd = bd
	| aux ((t1, t2) :: blist) bd = aux blist (l_mk_let(t2, bd));

	fun process_bindings ((t1, t2) :: blist) = (
	if not(type_of t1 =: type_of t2)
	then term_fail "mk_let" 3012 [t1,t2]
	else (let fun aux1 (Var v) = ((t1, t2) :: process_bindings blist)
		| aux1 (App cc) = (
		 if is_pair t1
		 then ((t1, t2) :: process_bindings blist)
		 else (let val (f,alist) = strip_app t1 in
			(f, list_mk_Ã (alist, t2)) :: process_bindings blist
		 end
		 handle complaint =>
		 (case area_of complaint of
		 "mk_Ã" => term_fail "mk_let" 4007 [t1]
		 | anm => reraise complaint anm))
		) | aux1 _ = term_fail "mk_let" 4007 [t1]
		;
	in
		aux1 (dest_simple_term t1)
	end
	)) | process_bindings [] = [];
	
	val bindings' = process_bindings bindings;
in
	aux bindings' (list_mk_Ã(map fst bindings', bdy))
end);
=TEX
To destroy a $let\ldots in$, we first strip off as many $Let$'s as
possible, saving the arguments as they are the values bound to.
We then strip off an equal number of abstractions, using $dest\_Ã$, and the varstruct's are the things that the values are bound to.
The remaining term is the body of the local definition.

The function will fail entirely if it attempts to destroy, e.g.
\[let\ x\ =\ 1\ in\ (Let\ p\ q)\]
where $p$ is not an abstraction, and $Let$ is the marker function for
local definitions.
In this case, for instance, it would not return
$([(x,\ 1)],\ (Let\ p\ q))$.
=SML
fun €dest_let› (tm : TERM) : (TERM * TERM)list * TERM = (
	(if is_bin_op "Let" tm
	then (let
	val ldest_let = dest_bin_op "" 0 "Let";

	fun get_values trm value_list = (
		let	val (bd, vl) = ldest_let trm
		in
			get_values bd (vl :: value_list)
		end
		handle (Fail _) => (value_list, trm));

	fun get_vstructs trm value_list = (
		let	val (rev_vslist,bdy) = (
		 fold (fn (_,(vslist, bd)) => ( 
			let	val (vs, bd') = dest_Ã bd
			in
				((vs :: vslist), bd')
			end))
			value_list
			([], trm))
		in
			(rev rev_vslist, bdy)
		end
	);

	val (values, LetForm) = get_values tm [];

	val (vstructs, body) = get_vstructs LetForm values;
	in
		(combine vstructs values, body)
	end)
	else fail "dest_let" 4009 [])
handle (Fail _) => 
term_fail "dest_let" 4009 [tm]
);
=TEX
=SML
fun €is_let› (tm : TERM) : bool = (
	(dest_let tm; true) handle (Fail _) => false
);

fun €list_mk_let› ((bindings, bdy):((TERM * TERM)list)list * TERM) : TERM = (
	fold mk_let bindings bdy
);

fun €strip_let› (trm:TERM): ((TERM * TERM)list)list * TERM = (
let
	fun aux (tm:TERM) (bindings:((TERM * TERM) list)list) = (
		let	val (binding, bdy) = dest_let tm;
		in
			aux bdy (binding :: bindings)
		end
		handle (Fail _) => (rev bindings, tm)
	);
in
	aux trm []
end);		 
=TEX
\subsection{List-terms}
=SML
local
	fun mk_LIST ty = mk_ctype("LIST",[ty])
in
fun €mk_list› (tml : TERM list): TERM = ((
	if is_nil tml
	then fail "mk_list" 3017 []
	else let
		val tt = type_of(hd tml);
		val cons = mk_const("Cons",mk_≠_type(tt, 
			mk_≠_type(mk_LIST tt, mk_LIST tt)));
		fun aux (el :: els) = (
			if tt =: type_of el
			then list_mk_app (cons, [el, aux els])
			else term_fail "mk_list" 3012 [hd tml, el]
		) | aux [] = mk_const("Nil", mk_LIST tt);
	in
		aux tml
	end
)
handle complaint => divert complaint "mk_app" "mk_list" 4010 []);
=TEX
=SML
fun €mk_empty_list› (ty : TYPE) : TERM = mk_const("Nil", mk_LIST ty);
fun €dest_empty_list› (tm : TERM) : TYPE = (
let	val (nm,ty) = dest_const tm
		handle (Fail _) =>
		term_fail "dest_empty_list" 4034 [tm]
in
	if nm = "Nil"
	then hd(snd(dest_ctype ty))
	else term_fail "dest_empty_list" 4034 [tm]
end);
fun €is_empty_list› (tm : TERM) : bool = (
	is_const tm andalso
	fst(dest_const tm) = "Nil"
);
=TEX
=SML
fun €dest_list› (tm : TERM) : TERM list = ((
let
	fun aux (Const ("Nil", _)) = []
	| aux (App (f, a)) = (
		let	val (f1, f2) = dest_app f;
			val (cns, _) = dest_const f1
		in
			if cns = "Cons"
			then (f2 :: aux (dest_simple_term a))
			else fail "dest_list" 4015 []
		end
	) | aux _ = fail "dest_list" 4015 [];
in
	aux (dest_simple_term tm)
end)
handle (Fail _) => 
term_fail "dest_list" 4015 [tm]
);
=TEX
=SML
fun €is_list› (tm : TERM) : bool = (
	(dest_list tm;true) handle (Fail _) => false
);
end (* local mk_LIST *);
=TEX
\subsection{Enumerated Sets} 
=SML
local
	fun mk_SET ty = mk_ctype("SET",[ty])
in
fun €mk_enum_set› (tml : TERM list): TERM = ((
	if is_nil tml
	then fail "mk_enum_set" 3017 []
	else let
		val tt = type_of(hd tml);
		val insert = mk_const("Insert",mk_≠_type(tt, 
			mk_≠_type(mk_SET tt, mk_SET tt)));
		val empty = mk_const("Empty", mk_SET tt);
		fun aux (el :: els) = (if type_of el =: tt
			then list_mk_app (insert, [el, aux els])
			else term_fail "mk_enum_set" 3012 [hd tml, el]
		) | aux [] = empty;
	in
		aux tml
	end
)
handle complaint => divert complaint "mk_app" "mk_enum_set" 4010 []);
=TEX
=SML
fun €mk_ö› (ty : TYPE) : TERM = mk_const("Empty", mk_SET ty);
fun €dest_ö› (tm : TERM) : TYPE = (
let	val (nm,ty) = dest_const tm
		handle (Fail _) =>
		term_fail "dest_ö" 4035 [tm]
in
	if nm = "Empty"
	then hd(snd(dest_ctype ty))
	else term_fail "dest_ö" 4035 [tm]
end);
fun €is_ö› (tm : TERM) : bool = (
	is_const tm andalso
	fst(dest_const tm) = "Empty"
);

=TEX
=SML
fun €dest_enum_set› (tm : TERM) : TERM list = ((
let
	fun aux (Const ("Empty", _)) = []
	| aux (App (f, a)) = (
		let	val (f1, f2) = dest_app f;
			val (ins, _) = dest_const f1
		in
			if ins = "Insert"
			then (f2 :: aux (dest_simple_term a))
			else fail "dest_enum_set" 4011 []
		end
	) | aux _ = fail "dest_enum_set" 4011 [];
in
	aux (dest_simple_term tm)
end)
handle (Fail _) => 
term_fail "dest_enum_set" 4011 [tm]
);
=TEX
=SML
fun €is_enum_set› (tm : TERM) : bool = (
	(dest_enum_set tm;true) handle (Fail _) => false
);
=TEX
=SML
local 
	fun lmk_set_comp t1 _ = mk_const("SetComp", mk_≠_type(mk_≠_type(
		t1, BOOL), mk_SET t1))
in
	val €mk_set_comp› : TERM * TERM -> TERM = (
		mk_binder "mk_set_comp" 3015 lmk_set_comp
	);

	val €dest_set_comp› : TERM -> TERM * TERM = (
		dest_binder "dest_set_comp" 4013 "SetComp"
	);

	val €is_set_comp› : TERM -> bool = is_binder "SetComp";

end (* local lmk_set_comp *);
=TEX
\subsection{Negations}
=SML
end (* local mk_SET *);
=TEX

=SML
local 
	fun Negate _ = mk_const("≥", mk_≠_type (BOOL, BOOL));
in
	val €mk_≥›: TERM -> TERM = mk_mon_op "mk_≥" 3031 Negate;
end;

fun €mk_multi_≥› (n : int, tm : TERM) : TERM = (
let	fun aux (0,tm) = tm
	| aux (n,tm) = aux (n-1, mk_≥ tm)
		handle complaint =>
		pass_on complaint "mk_≥" "mk_multi_≥";
in
	if n < 0
	then fail "mk_multi_≥" 4030 [fn()=>string_of_int n]
	else aux(n,tm)
end);

val €dest_≥› : TERM -> TERM = dest_mon_op "dest_≥" 4029 "≥";

val €is_≥› : TERM -> bool = is_mon_op "≥";

fun €dest_multi_≥› (tm : TERM) : (int * TERM) = (
let	fun aux n tm = if is_≥ tm
		then aux (n+1) (dest_≥ tm)
		else (n, tm);
in
	aux 0 tm
end);
=TEX
\subsection{(Paired) µ-terms}
=SML
local 
	fun Forall t1 _ = quantifier "µ" t1 BOOL;
in
val €mk_µ› : TERM * TERM -> TERM = mk_binder "mk_µ" 3015 Forall;

val €dest_µ› : TERM -> TERM * TERM = dest_binder "dest_µ" 4017 "µ";

val €is_µ› : TERM -> bool = is_binder "µ";

val €list_mk_µ› : (TERM list * TERM) -> TERM = list_mk_binder mk_µ;
 
val €strip_µ› : TERM -> (TERM list * TERM) = strip_binder "µ";

end (* local Forall *);

val €strip_simple_µ› : TERM -> (TERM list * TERM) = strip_simple_binder "µ";
=TEX
\subsection{(Paired) ∂-terms}
=SML
local
	fun Exists t1 _ = quantifier "∂" t1 BOOL;
in
val €mk_∂› : TERM * TERM -> TERM = mk_binder "mk_∂" 3015 Exists;

val €dest_∂› : TERM -> TERM * TERM = dest_binder "dest_∂" 4020 "∂";

val €is_∂› : TERM -> bool = is_binder "∂";

val €list_mk_∂› : (TERM list * TERM) -> TERM = list_mk_binder mk_∂;
 
val €strip_∂› : TERM -> (TERM list * TERM) = strip_binder "∂";

end (* local Exists *);

val €strip_simple_∂› : TERM -> (TERM list * TERM) = strip_simple_binder "∂";
=TEX
\subsection{Simple and Paired ∂$_1$-terms}
=SML
local
	fun Exists1 t1 _ = quantifier "∂â1" t1 BOOL;
in
val €mk_simple_∂â1› : TERM * TERM -> TERM = (
	mk_simple_binder "mk_simple_∂â1" 3015 Exists1
);

val €dest_simple_∂â1› : TERM -> TERM * TERM = (
	dest_simple_binder "dest_simple_∂â1" 4019 "∂â1")
;

val €is_simple_∂â1› : TERM -> bool = is_simple_binder "∂â1";

val €mk_∂â1› : TERM * TERM -> TERM = (
		mk_binder "mk_∂â1" 3015 Exists1
);

val €dest_∂â1› : TERM -> TERM * TERM = (
	dest_binder "dest_∂â1" 4021 "∂â1"
);

val €is_∂â1› : TERM -> bool = is_binder "∂â1";
end (* local Exists1 *);
=TEX
\subsection{≈-terms}
=SML
local 
	fun Select t1 _ = mk_const("≈", mk_≠_type(mk_≠_type(
		t1, BOOL), t1))
in
val €mk_≈› : TERM * TERM -> TERM = mk_binder "mk_≈" 3015 Select;

val €dest_≈› : TERM -> TERM * TERM = dest_binder "dest_≈" 4023 "≈";

val €is_≈› : TERM -> bool = is_binder "≈";

val €list_mk_≈› : (TERM list * TERM) -> TERM = list_mk_binder mk_≈;
 
val €strip_≈› : TERM -> (TERM list * TERM) = strip_binder "≈";

end (* local Select *);
=TEX
\subsection{The Type of Destroyed Derived Terms}
=SML
datatype €DEST_TERM› = €DVar› of string * TYPE |
	€DConst› of string * TYPE |
	€DApp› of TERM * TERM |
	€DÃ› of TERM * TERM |
	€DEq› of TERM * TERM |
	€D¥› of TERM * TERM |
 	€DT› |
 	€DF› |
	€D≥› of TERM |
	€DPair› of TERM * TERM |
	€D±› of TERM * TERM |
	€D≤› of TERM * TERM |
	€D§› of TERM * TERM |
	€DLet› of ((TERM * TERM)list * TERM) |
	€DEnumSet› of TERM list |
 	€Dö› of TYPE |
	€DSetComp› of TERM * TERM |
	€DList› of TERM list |
 	€DEmptyList› of TYPE |
	€Dµ› of TERM * TERM |
	€D∂› of TERM * TERM |
 	€D∂â1› of TERM * TERM |
	€D≈› of TERM * TERM |
	€DIf› of (TERM * TERM * TERM);
=TEX
=SML
local
	val BtoBtoB = mk_≠_type(BOOL,mk_≠_type(BOOL,BOOL));
in
fun €dest_term› (tm : TERM ) : DEST_TERM = (
let
	fun aux3 "Nil" ty = (
		if is_ctype ty
		then (let val (s,tyl) = dest_ctype ty
			in
			if (s = "LIST" andalso length tyl = 1)
			then DEmptyList(hd tyl)
			else DConst("Nil",ty)
			end)
		else DConst("Nil",ty)
	) | aux3 "Empty" ty = (
		if is_ctype ty
		then (let val (s,tyl) = dest_ctype ty
			in
			if (s = "SET" andalso length tyl = 1)
			then Dö(hd tyl)
			else DConst("Empty",ty)
			end)
		else DConst("Empty",ty)
	) | aux3 "T" ty = (
		if ty =: BOOL
		then DT
		else DConst("T",ty)
	) | aux3 "F" ty = (
		if ty =: BOOL
		then DF
		else DConst("F",ty)
	) | aux3 nm ty = DConst (nm,ty);

	fun aux2 (App(f11, f12)) f1 f2 f a = (
		if is_const f11 andalso (fst(dest_const f11) = "Cond")
		then DIf(f12, f2, a)
		else DApp(f, a)
	) | aux2(Var _) f1 f2 f a = DApp(f, a)
	| aux2(SimpleÃ _) f1 f2 f a = DApp(f, a)
	| aux2(Const(co,ty)) f1 f2 f a = (
		case co
		of "¥" => D¥ (f2, a)
		| "=" => (
			if ty =: BtoBtoB
			then D§ (f2, a)
			else DEq (f2, a)
		) | "±" => D± (f2, a)
		| "≤" => D≤ (f2, a)
		| "," => DPair (f2, a)
		| "Let" => (
			DLet(dest_let tm)
			handle (Fail _) =>
			DApp(f, a)
		) | "Insert" => (
			DEnumSet(dest_enum_set tm)
			handle (Fail _) =>
			DApp(f, a)
		) | "Cons" => (
			DList(dest_list tm)
			handle (Fail _) =>
			DApp(f, a)
		) | _ => DApp(f, a));

	fun aux1 (App(f1, f2)) f a = (
		aux2(dest_simple_term f1) f1 f2 f a
	) | aux1(Var v) f a = DApp(f, a)
	| aux1 (SimpleÃ c) f a = DApp (f, a)
	| aux1 (Const(co,ty)) f a = (
		case co
		of "Uncurry" => (
			DÃ(dest_Ã tm)
			handle (Fail _) =>
			DApp(f, a)
		) | "µ" => (
			Dµ(dest_µ tm)
			handle (Fail _) =>
			DApp(f, a)
		) | "∂" => (
			D∂(dest_∂ tm)
			handle (Fail _) =>
			DApp(f, a)
		) | "∂â1" => (
			D∂â1(dest_∂â1 tm)
			handle (Fail _) =>
			DApp(f, a)
		) | "≈" => (
			D≈(dest_≈ tm)
			handle (Fail _) =>
			DApp(f, a)
		) | "SetComp" => (
			DSetComp(dest_set_comp tm)
			handle (Fail _) =>
			DApp(f, a)
		) | "≥" => D≥ a
		| _ => DApp(f, a));
		
	fun aux (App (f, a)) = (aux1 (dest_simple_term f) f a)
	| aux (Var v) = DVar v
	| aux (SimpleÃ a) = DÃ a
	| aux (Const (nm,ty)) = aux3 nm ty;
in
	aux (dest_simple_term tm)
end (* let *));
end (* local *);
=TEX
=SML
fun €mk_term› ((DVar v) : DEST_TERM) : TERM = mk_var v
| mk_term (DConst c) = mk_const c
| mk_term (DApp fa) = mk_app fa
| mk_term (DÃ ab) = mk_Ã ab
| mk_term (DT) = mk_t
| mk_term (DF) = mk_f
| mk_term (DEq ee) = mk_eq ee
| mk_term (D¥ imp) = mk_¥ imp
| mk_term (D≥ n) = mk_≥ n
| mk_term (DPair p) = mk_pair p
| mk_term (D± cc) = mk_± cc
| mk_term (D≤ dd) = mk_≤ dd
| mk_term (D§ ee) = mk_§ ee
| mk_term (DLet ll) = mk_let ll
| mk_term (DEnumSet ttl) = mk_enum_set ttl
| mk_term (Dö ty) = mk_ö ty
| mk_term (DSetComp s) = mk_set_comp s
| mk_term (DList ttl) = mk_list ttl
| mk_term (DEmptyList ty) = mk_empty_list ty
| mk_term (Dµ f) = mk_µ f
| mk_term (D∂ e) = mk_∂ e
| mk_term (D∂â1 e) = mk_∂â1 e
| mk_term (D≈ s) = mk_≈ s
| mk_term (DIf ii) = mk_if ii;
=TEX
 
=SML
end; (* of TypesAndTerms signature *)
=TEX
=SML
open TypesAndTerms;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document})


