=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for Derived Terms}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP004}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FMU Manager}
\TPPabstract{This document gives an implementation for functions concerning derived terms that are not used in defining the type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.2]
First full version.
Based on the first part of DS/FMU/IED/SML002.
\item [Issue 1.3]
Modified for changes in issue 1.8 of \cite{DS/FMU/IED/DTD003},
and issue 1.5 of \cite{DS/FMU/IED/DTD004}
\item [Issue 1.4]
Modified for changes in issue 1.6 of \cite{DS/FMU/IED/DTD004}
\item [Issue 1.5]
Added $mk\_empty\_$ for $enum\_set$ and $list$.
\item [Issue 1.6]
Corrected $strip\_binder$.
\item [Issue 1.7]
Added constructors, etc, for $Ñ_1$, $T$ and $F$.
\item [Issue 1.8]
Reimplemented $strip\_binder$ and $strip\_abs$,
added $strip\_simple\_binder$,
changed $?\_T$ and $?\_F$ to $?\_t$ and $\_f$.
\item [Issue 1.9,1.10,1.11]
Changes in response to inspection IR0017.
\item [Issue 1.12]
Renamings of functions containing the name atom $simple$,
and renaming of $aconv$.
\item [Issue 1.13]
Tidying up prior to desk check.
\end{description}
\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of some functions for derived terms of ICL HOL, and functions to handle them, called for by section 4.2 of the Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
They are not required for the implementation of type $THM$, such derived functions may be found in \cite{DS/FMU/IED/DTD003}.
The high-level specification for the code may be considered
to be given in \cite{DS/FMU/IED/SPC001}.
The design is in \cite{DS/FMU/IED/DTD004}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of functions for derived terms of ICL HOL, and functions to handle them.
\subsubsection{Dependencies}
This document's signature is given in \cite{DS/FMU/IED/DTD004}.
It relies on those files indicated by the ICL HOL release 001 makefile.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
=TEX
\section{DERIVED TERMS}
=SML
structure ‚TypesAndTerms· : TypesAndTerms = struct
=TEX
First gain the items implemented in $icl'TypesAndTerms$.
Opening that structure here allows a seamless (at the user interface level) movement of items between them.
=SML
open icl'TypesAndTerms;
=TEX
=SML
val ‚mk_t· : TERM = mk_const("T",BOOL);
fun ‚is_t· (tm : TERM) : bool = (tm = mk_t);
=TEX
=SML
val ‚mk_f· : TERM = mk_const("F",BOOL);
fun ‚is_f· (tm : TERM) : bool = (tm = mk_f);
=TEX

As the $selector$ in the below is likely to just an error-trapped attempt to to apply the $destroyer$ this is less efficient than it might be in some instances.
=SML
fun ‚list_mk_binder· (maker : TERM * TERM -> TERM) 
	((tml, tm) : TERM list * TERM) : TERM = (
let	fun aux [] = tm
	| aux (htm :: ttm) = maker(htm, (aux ttm))
in
	aux tml
end);

=TEX
Pairing:
=SML
fun ‚mk_â_type· ((t1, t2) : TYPE * TYPE): TYPE = mk_ctype("â", [t1, t2]);

fun ‚dest_â_type· (ty : TYPE): TYPE * TYPE = (
	case dest_simple_type ty of
	Ctype ("â",[t1,t2]) => (t1,t2)
	| _ => type_fail "dest_â_type" 4018 [ty]
);
fun ‚is_â_type· (ty : TYPE): bool = (
	case dest_simple_type ty of
	Ctype ("â",[t1,t2]) => true
	| _ => false
);

local
	fun comma (ty1: TYPE) (ty2: TYPE): TERM = (
	mk_const(",", mk_ã_type (ty1, mk_ã_type (ty2, mk_â_type (ty1,ty2))))
);
in
fun ‚mk_pair· (xy: TERM * TERM) : TERM = (
	(mk_bin_op "mk_pair" 4033 4033 comma xy)
	handle (Fail _) =>
	error "mk_pair" 4033 [fn () => PolyML.makestring (fst xy),	
		fn () => PolyML.makestring (snd xy)]);
end;

val ‚dest_pair· : TERM -> (TERM * TERM) = dest_bin_op "dest_pair" 4003 ",";

val ‚is_pair· : TERM -> bool = is_bin_op ",";
=TEX
=SML
fun ‚uncurry· (t1:TYPE) (t2:TYPE) (t3:TYPE):TERM = (
	mk_const("Uncurry",
	mk_ã_type(mk_ã_type(t1,mk_ã_type(t2, t3)), mk_ã_type(mk_â_type(t1, t2), t3)))
);
=TEX
The following function can handle an arbitrarily nested paired abstraction.
=SML
local
	fun uncurry (t1:TYPE) (t2:TYPE) (t3:TYPE):TERM = (
	mk_const("Uncurry",
	mk_ã_type(mk_ã_type(t1,mk_ã_type(t2, t3)), mk_ã_type(mk_â_type(t1, t2), t3)))
);
in
fun ‚mk_ç· ((x, y): TERM * TERM) : TERM = (
	(if is_pair x
	then (let val (a,b) = dest_pair x;
		val ta = type_of a and
			tb = type_of b
	in
		mk_app(uncurry ta tb (type_of y),
			mk_ç(a, mk_ç(b, y)))
	end)
	else mk_simple_ç(x, y))
	handle complaint => 
	case area_of complaint of
	"mk_simple_ç" => term_fail "mk_ç" 4016 [x]
	| anm => reraise complaint anm
);
end;
=TEX
=SML
fun ‚dest_ç· (ab : TERM) : TERM * TERM = (
	(if is_simple_ç ab
	then dest_simple_ç ab
	else let val (a,b) = dest_app ab
	in
		if is_const a andalso (fst(dest_const a) = "Uncurry")
		then (let val (b1, b2) = dest_ç b;
			val (b21, b22) = dest_ç b2
		in
			(mk_pair(b1,b21), b22)
		end)
		else fail "dest_ç" 4002 []
	end)
	handle (Fail _) => 
	term_fail "dest_ç" 4002 [ab]
);
=TEX
=SML
fun ‚is_ç· (tm : TERM) : bool = (dest_ç tm; true) handle (Fail _) => false;

val ‚list_mk_ç· : (TERM list * TERM) -> TERM = list_mk_binder mk_ç;

fun ‚strip_ç· (tm : TERM ) : (TERM list * TERM) = (
let	val (var, body) = dest_ç tm;
in	(let	val (vs,bd) = strip_ç body;
	in
		((var :: vs) , bd)
	end)
end
handle (Fail _) => ([],tm)
);
=TEX
=SML
fun ‚mk_binder· (area : string) (msg : int) (binder:TYPE -> TYPE -> TERM) 
	((v, b) : TERM * TERM) : TERM = (
	
	(mk_app (binder (type_of v) (type_of b), 
		mk_ç(v, b)))
	handle complaint => 
	case area_of complaint of
	"mk_ç" => pass_on complaint "mk_ç" area
	| _ => term_fail area msg [v,b]
);

fun ‚dest_binder· (area_name : string) (msg : int) (op_name : string)
	(tm : TERM) : TERM * TERM = (
	let	val (binder, abs) = dest_app tm;
		val (var, body) = dest_ç abs;
	in	if fst (dest_const binder) = op_name
		then (var, body)
		else fail area_name msg []
	end
	handle (Fail _) => term_fail area_name msg [tm]
);

fun ‚is_binder· (op_name : string) (tm : TERM) : bool = (
	let	val (binder, bdy) = dest_app tm;
	in	is_ç bdy
		andalso
		(fst (dest_const binder) = op_name)
	end
	handle (Fail _) => false
);

fun ‚strip_binder· (op_name : string) (tm : TERM) : TERM list * TERM = (
let	fun aux (tm1:TERM) : (TERM list * TERM) = (
	let	val (binder, abs) = dest_app tm1;
		val (var, body) = dest_ç abs;
	in	if fst (dest_const binder) = op_name
		then (let val (vs,bd) = aux body;
		in
			((var :: vs) , bd)
		end)
		else ([],tm1)
	end
	handle (Fail _) => ([],tm1)
	);
in
	aux tm
end);
fun ‚strip_simple_binder· (op_name : string) (tm : TERM) : TERM list * TERM = (
let	fun aux (tm1:TERM) : (TERM list * TERM) = (
	let	val (binder, abs) = dest_app tm1;
		val (var, body) = dest_simple_ç abs;
	in	if fst (dest_const binder) = op_name
		then (let val (vs,bd) = aux body;
		in
			((var :: vs) , bd)
		end)
		else ([],tm1)
	end
	handle (Fail _) => ([],tm1)
	);
in
	aux tm
end);
=TEX
=SML
val ‚mk_Ä· : (TERM * TERM) -> TERM = mk_bin_op "mk_Ä" 3031 3015 (bin_bool_op "Ä");

val ‚dest_Ä· : TERM -> (TERM * TERM) = dest_bin_op "dest_Ä" 4032 "Ä";

val ‚is_Ä· : TERM -> bool = is_bin_op "Ä";

val ‚list_mk_Ä· : TERM list -> TERM = list_mk_bin_op "list_mk_Ä" 3031 3015 (bin_bool_op "Ä");

val ‚strip_Ä· : TERM -> TERM list = strip_bin_op "Ä";
=TEX
=SML
val ‚mk_Å· : (TERM * TERM) -> TERM = mk_bin_op "mk_Å" 3031 3015 (bin_bool_op "Å");

val ‚dest_Å· : TERM -> (TERM * TERM) = dest_bin_op "dest_Å" 4027 "Å";

val ‚is_Å· : TERM -> bool = is_bin_op "Å";

val ‚list_mk_Å· : TERM list -> TERM = list_mk_bin_op "list_mk_Å" 3031 3015 (bin_bool_op "Å");

val ‚strip_Å· : TERM -> TERM list = strip_bin_op "Å";
=TEX
=SML
val ‚mk_Ç· : (TERM * TERM) -> TERM = mk_bin_op "mk_Ç" 3031 3015 (bin_bool_op "=");

fun ‚dest_Ç· (tm : TERM) : (TERM * TERM) = (
let	val (tm1, tm2) = dest_bin_op "dest_Ç" 4031 "=" tm
in
	if (type_of tm1 = BOOL)
	then (tm1, tm2)
	else term_fail "dest_Ç" 4031 [tm]
end);

fun ‚is_Ç· (tm : TERM) : bool = (
let	val (tm1, tm2) = dest_eq tm
in
	(type_of tm1 = BOOL)
end
handle (Fail _) => false);
=TEX
=SML
fun ‚mk_if· (c : TERM, y : TERM, n : TERM) : TERM = (
let	val cty = type_of c;
	val yty = type_of y
in
	if cty <> BOOL
	then term_fail "mk_if" 3031 [c]
	else if yty <> type_of n
	then term_fail "mk_if" 3012 [y,n]
	else	let	val If = mk_const("Cond", 
			mk_ã_type (BOOL,(mk_ã_type (yty,(mk_ã_type(yty, yty))))));
		in	mk_app(mk_app(mk_app(If, c), y), n)
		end
end);
=TEX
=SML
fun ‚is_if· (tm : TERM) : bool = (
	let	val rand = (fst o dest_app);
		val name = fst(dest_const(rand(rand(rand tm))));
	in	name = "Cond"
	end handle (Fail _) => false
);
=TEX
=SML
fun ‚dest_if· (tm : TERM) : (TERM * TERM * TERM) = (
	(case ((fst o dest_const) ** Combinators.I)(strip_app tm) of
		("Cond", [c, y, n]) => (c, y, n)
	|	_ => fail "dest_if" 4006 [])
	handle (Fail _) => 
	term_fail "dest_if" 4006 [tm]
);
=TEX
We implement $mk\_let$ to carry out three steps:
\begin{enumerate}
\item
Given a list of local bindings, $bindings$, process them with $process\_bindings$, to replace bindings of local functions, e.g. $f\ x\ =\ y$, with bindings of variable structures (actually the replacement will always be with variables) to abstractions, e.g. $f\ =\ ç\ x\ é\ y$.
This gives us $bindings'$.
Bindings to variable structures will be left unchanged in this step.
\item
Abstract, as a list, the variable structures of $bindings'$ from the body of the local definition, $bdy$, using $list\_mk\_ç$.
\item
Apply the abstracted body to the values of $bindings'$,
using the marker function $Let$ to indicate the presence of a local definition construct.
This is done in $aux$ by repeatedly calling $l\_mk\_let$.
\end{enumerate}
=SML
fun ‚mk_let· ((bindings, bdy): (TERM * TERM)list * TERM) : TERM = (
let
	fun l_mk_let (t2, t3) = (
		let	val tt2 = type_of t2 and
		 		tt3 = type_of t3;
			val (tt31,tt32) = dest_ã_type tt3
		in
			mk_app(mk_app(
			 mk_const("Let",
			 mk_ã_type(tt3,mk_ã_type(tt2,tt32))),
			 t3), t2)
		end);

	fun aux [] bd = bd
	| aux ((t1, t2) :: blist) bd = aux blist (l_mk_let(t2, bd));

	fun process_bindings ((t1, t2) :: blist) = (
	if type_of t1 <> type_of t2
	then term_fail "mk_let" 3012 [t1,t2]
	else (let fun aux1 (Var v) = ((t1, t2) :: process_bindings blist)
		| aux1 (App cc) = (
		 if is_pair t1
		 then ((t1, t2) :: process_bindings blist)
		 else (let val (f,alist) = strip_app t1 in
			(f, list_mk_ç (alist, t2)) :: process_bindings blist
		 end
		 handle complaint =>
		 (case area_of complaint of
		 "mk_ç" => term_fail "mk_let" 4007 [t1]
		 | anm => reraise complaint anm))
		) | aux1 _ = term_fail "mk_let" 4007 [t1]
		;
	in
		aux1 (dest_simple_term t1)
	end
	)) | process_bindings [] = [];
	
	val bindings' = process_bindings bindings;
in
	aux bindings' (list_mk_ç(map fst bindings', bdy))
end);
=TEX
To destroy a $let\ldots in$, we first strip off as many $Let$'s as
possible, saving the arguments as they are the values bound to.
We then strip off an equal number of abstractions, using $dest\_ç$, and the varstruct's are the things that the values are bound to.
The remaining term is the body of the local definition.

The function will fail entirely if it attempts to destroy, e.g.
\[let\ x\ =\ 1\ in\ (Let\ p\ q)\]
where $p$ is not an abstraction, and $Let$ is the marker function for
local definitions.
In this case, for instance, it would not return
$([(x,\ 1)],\ (Let\ p\ q))$.
=SML
fun ‚dest_let· (tm : TERM) : (TERM * TERM)list * TERM = (
	(if is_bin_op "Let" tm
	then (let
	val ldest_let = dest_bin_op "" 0 "Let";

	fun get_values trm value_list = (
		let	val (bd, vl) = ldest_let trm
		in
			get_values bd (vl :: value_list)
		end
		handle (Fail _) => (value_list, trm));

	fun get_vstructs trm value_list = (
		let	val (rev_vslist,bdy) = (
		 fold (fn (_,(vslist, bd)) => ( 
			let	val (vs, bd') = dest_ç bd
			in
				((vs :: vslist), bd')
			end))
			value_list
			([], trm))
		in
			(rev rev_vslist, bdy)
		end
	);

	val (values, LetForm) = get_values tm [];

	val (vstructs, body) = get_vstructs LetForm values;
	in
		(combine vstructs values, body)
	end)
	else fail "dest_let" 4009 [])
handle (Fail _) => 
term_fail "dest_let" 4009 [tm]
);
=TEX
=SML
fun ‚is_let· (tm : TERM) : bool = (
	(dest_let tm; true) handle (Fail _) => false
);

fun ‚list_mk_let· ((bindings, bdy):((TERM * TERM)list)list * TERM) : TERM = (
	fold mk_let bindings bdy
);

fun ‚strip_let· (trm:TERM): ((TERM * TERM)list)list * TERM = (
let
	fun aux (tm:TERM) (bindings:((TERM * TERM) list)list) = (
		let	val (binding, bdy) = dest_let tm;
		in
			aux bdy (binding :: bindings)
		end
		handle (Fail _) => (rev bindings, tm)
	);
in
	aux trm []
end);		 
=TEX
=SML
local
	fun mk_LIST ty = mk_ctype("LIST",[ty])
in
fun ‚mk_list· (tml : TERM list): TERM = ((
	if is_nil tml
	then fail "mk_list" 3017 []
	else let
		val tt = type_of(hd tml);
		val cons = mk_const("Cons",mk_ã_type(tt, 
			mk_ã_type(mk_LIST tt, mk_LIST tt)));
		fun aux (el :: els) = (
			if tt = type_of el
			then list_mk_app (cons, [el, aux els])
			else term_fail "mk_list" 3012 [hd tml, el]
		) | aux [] = mk_const("Nil", mk_LIST tt);
	in
		aux tml
	end
)
handle complaint => divert complaint "mk_app" "mk_list" 4010 []);
=TEX
=SML
fun ‚mk_empty_list· (ty : TYPE) : TERM = mk_const("Nil", mk_LIST ty);
=TEX
=SML
fun ‚dest_list· (tm : TERM) : TERM list = ((
let
	fun aux (Const ("Nil", _)) = []
	| aux (App (f, a)) = (
		let	val (f1, f2) = dest_app f;
			val (cns, _) = dest_const f1
		in
			if cns = "Cons"
			then (f2 :: aux (dest_simple_term a))
			else fail "dest_list" 4015 []
		end
	) | aux _ = fail "dest_list" 4015 [];
in
	aux (dest_simple_term tm)
end)
handle (Fail _) => 
term_fail "dest_list" 4015 [tm]
);
=TEX
=SML
fun ‚is_list· (tm : TERM) : bool = (
	(dest_list tm;true) handle (Fail _) => false
);
end (* local mk_LIST *);
=TEX
=SML
local
	fun mk_SET ty = mk_ctype("SET",[ty])
in
fun ‚mk_enum_set· (tml : TERM list): TERM = ((
	if is_nil tml
	then fail "mk_enum_set" 3017 []
	else let
		val tt = type_of(hd tml);
		val insert = mk_const("Insert",mk_ã_type(tt, 
			mk_ã_type(mk_SET tt, mk_SET tt)));
		val empty = mk_const("Empty", mk_SET tt);
		fun aux (el :: els) = (if type_of el = tt
			then list_mk_app (insert, [el, aux els])
			else term_fail "mk_enum_set" 3012 [hd tml, el]
		) | aux [] = empty;
	in
		aux tml
	end
)
handle complaint => divert complaint "mk_app" "mk_enum_set" 4010 []);
=TEX
=SML
fun ‚mk_§· (ty : TYPE) : TERM = mk_const("Empty", mk_SET ty);
=TEX
=SML
fun ‚dest_enum_set· (tm : TERM) : TERM list = ((
let
	fun aux (Const ("Empty", _)) = []
	| aux (App (f, a)) = (
		let	val (f1, f2) = dest_app f;
			val (ins, _) = dest_const f1
		in
			if ins = "Insert"
			then (f2 :: aux (dest_simple_term a))
			else fail "dest_enum_set" 4011 []
		end
	) | aux _ = fail "dest_enum_set" 4011 [];
in
	aux (dest_simple_term tm)
end)
handle (Fail _) => 
term_fail "dest_enum_set" 4011 [tm]
);
=TEX
=SML
fun ‚is_enum_set· (tm : TERM) : bool = (
	(dest_enum_set tm;true) handle (Fail _) => false
);
=TEX
=SML
local 
	fun lmk_set_comp t1 _ = mk_const("SetComp", mk_ã_type(mk_ã_type(
		t1, BOOL), mk_SET t1))
in
	val ‚mk_set_comp· : TERM * TERM -> TERM = (
		mk_binder "mk_set_comp" 3015 lmk_set_comp
	);

	val ‚dest_set_comp· : TERM -> TERM * TERM = (
		dest_binder "dest_set_comp" 4013 "SetComp"
	);

	val ‚is_set_comp· : TERM -> bool = is_binder "SetComp";

end (* local lmk_set_comp *);

end (* local mk_SET *);
=TEX
=SML
local 
	fun Negate _ = mk_const("å", mk_ã_type (BOOL, BOOL));
in
	val ‚mk_å·: TERM -> TERM = mk_mon_op "mk_å" 3031 Negate;
end;

fun ‚mk_multi_å· (n : int, tm : TERM) : TERM = (
let	fun aux (0,tm) = tm
	| aux (n,tm) = aux (n-1, mk_å tm)
		handle complaint =>
		pass_on complaint "mk_å" "mk_multi_å";
in
	if n < 0
	then fail "mk_multi_å" 4030 [fn()=>string_of_int n]
	else aux(n,tm)
end);

val ‚dest_å· : TERM -> TERM = dest_mon_op "dest_å" 4029 "å";

val ‚is_å· : TERM -> bool = is_mon_op "å";

fun ‚dest_multi_å· (tm : TERM) : (int * TERM) = (
let	fun aux n tm = if is_å tm
		then aux (n+1) (dest_å tm)
		else (n, tm);
in
	aux 0 tm
end);
=TEX
=SML
local 
	fun Forall t1 _ = quantifier "É" t1 BOOL;
in
val ‚mk_É· : TERM * TERM -> TERM = mk_binder "mk_É" 3015 Forall;

val ‚dest_É· : TERM -> TERM * TERM = dest_binder "dest_É" 4017 "É";

val ‚is_É· : TERM -> bool = is_binder "É";

val ‚list_mk_É· : (TERM list * TERM) -> TERM = list_mk_binder mk_É;
 
val ‚strip_É· : TERM -> (TERM list * TERM) = strip_binder "É";

end (* local Forall *);
=TEX
=SML
local
	fun Exists t1 _ = quantifier "Ñ" t1 BOOL;
in
val ‚mk_Ñ· : TERM * TERM -> TERM = mk_binder "mk_Ñ" 3015 Exists;

val ‚dest_Ñ· : TERM -> TERM * TERM = dest_binder "dest_Ñ" 4020 "Ñ";

val ‚is_Ñ· : TERM -> bool = is_binder "Ñ";

val ‚list_mk_Ñ· : (TERM list * TERM) -> TERM = list_mk_binder mk_Ñ;
 
val ‚strip_Ñ· : TERM -> (TERM list * TERM) = strip_binder "Ñ";

end (* local Exists *);
=TEX
=SML
local
	fun Exists1 t1 _ = quantifier "Ñ%down%1" t1 BOOL;
in
val ‚mk_simple_Ñ%down%1· : TERM * TERM -> TERM = (
	mk_simple_binder "mk_simple_Ñ%down%1" 3015 Exists1
);

val ‚dest_simple_Ñ%down%1· : TERM -> TERM * TERM = (
	dest_simple_binder "dest_simple_Ñ%down%1" 4019 "Ñ%down%1")
;

val ‚is_simple_Ñ%down%1· : TERM -> bool = is_simple_binder "Ñ%down%1";

val ‚mk_Ñ%down%1· : TERM * TERM -> TERM = (
		mk_binder "mk_Ñ%down%1" 3015 Exists1
);

val ‚dest_Ñ%down%1· : TERM -> TERM * TERM = (
	dest_binder "dest_Ñ%down%1" 4021 "Ñ%down%1"
);

val ‚is_Ñ%down%1· : TERM -> bool = is_binder "Ñ%down%1";
end (* local Exists1 *);
=TEX
=SML
local 
	fun Select t1 _ = mk_const("á", mk_ã_type(mk_ã_type(
		t1, BOOL), t1))
in
val ‚mk_á· : TERM * TERM -> TERM = mk_binder "mk_á" 3015 Select;

val ‚dest_á· : TERM -> TERM * TERM = dest_binder "dest_á" 4023 "á";

val ‚is_á· : TERM -> bool = is_binder "á";

val ‚list_mk_á· : (TERM list * TERM) -> TERM = list_mk_binder mk_á;
 
val ‚strip_á· : TERM -> (TERM list * TERM) = strip_binder "á";

end (* local Select *);
=TEX
=SML
val ‚strip_simple_É· : TERM -> (TERM list * TERM) = strip_simple_binder "É";

val ‚strip_simple_Ñ· : TERM -> (TERM list * TERM) = strip_simple_binder "Ñ";
=TEX
\subsection{The Type of Destroyed Derived Terms}
=SML
datatype ‚DEST_TERM· = ‚DVar· of string * TYPE |
	‚DConst· of string * TYPE |
	‚DApp· of TERM * TERM |
	‚Dç· of TERM * TERM |
	‚DEq· of TERM * TERM |
	‚Dä· of TERM * TERM |
 	‚DT· |
 	‚DF· |
	‚Då· of TERM |
	‚DPair· of TERM * TERM |
	‚DÄ· of TERM * TERM |
	‚DÅ· of TERM * TERM |
	‚DÇ· of TERM * TERM |
	‚DLet· of ((TERM * TERM)list * TERM) |
	‚DEnumSet· of TERM list |
 	‚D§· of TYPE |
	‚DSetComp· of TERM * TERM |
	‚DList· of TERM list |
 	‚DEmptyList· of TYPE |
	‚DÉ· of TERM * TERM |
	‚DÑ· of TERM * TERM |
 	‚DÑ%down%1· of TERM * TERM |
	‚Dá· of TERM * TERM |
	‚DIf· of (TERM * TERM * TERM);
=TEX
=SML
local
	val BtoBtoB = mk_ã_type(BOOL,mk_ã_type(BOOL,BOOL));
in
fun ‚dest_term· (tm : TERM ) : DEST_TERM = (
let
	fun aux3 "Nil" ty = (
		if is_ctype ty
		then (let val (s,tyl) = dest_ctype ty
			in
			if (s = "LIST" andalso length tyl = 1)
			then DEmptyList(hd tyl)
			else DConst("Nil",ty)
			end)
		else DConst("Nil",ty)
	) | aux3 "Empty" ty = (
		if is_ctype ty
		then (let val (s,tyl) = dest_ctype ty
			in
			if (s = "SET" andalso length tyl = 1)
			then D§(hd tyl)
			else DConst("Empty",ty)
			end)
		else DConst("Empty",ty)
	) | aux3 "T" ty = (
		if ty = BOOL
		then DT
		else DConst("T",ty)
	) | aux3 "F" ty = (
		if ty = BOOL
		then DF
		else DConst("F",ty)
	) | aux3 nm ty = DConst (nm,ty);

	fun aux2 (App(f11, f12)) f1 f2 f a = (
		if is_const f11 andalso (fst(dest_const f11) = "Cond")
		then DIf(f12, f2, a)
		else DApp(f, a)
	) | aux2(Var _) f1 f2 f a = DApp(f, a)
	| aux2(Simpleç _) f1 f2 f a = DApp(f, a)
	| aux2(Const(co,ty)) f1 f2 f a = (
		case co
		of "ä" => Dä (f2, a)
		| "=" => (
			if ty = BtoBtoB
			then DÇ (f2, a)
			else DEq (f2, a)
		) | "Ä" => DÄ (f2, a)
		| "Å" => DÅ (f2, a)
		| "," => DPair (f2, a)
		| "Let" => (
			DLet(dest_let tm)
			handle (Fail _) =>
			DApp(f, a)
		) | "Insert" => (
			DEnumSet(dest_enum_set tm)
			handle (Fail _) =>
			DApp(f, a)
		) | "Cons" => (
			DList(dest_list tm)
			handle (Fail _) =>
			DApp(f, a)
		) | _ => DApp(f, a));

	fun aux1 (App(f1, f2)) f a = (
		aux2(dest_simple_term f1) f1 f2 f a
	) | aux1(Var v) f a = DApp(f, a)
	| aux1 (Simpleç c) f a = DApp (f, a)
	| aux1 (Const(co,ty)) f a = (
		case co
		of "Uncurry" => (
			Dç(dest_ç tm)
			handle (Fail _) =>
			DApp(f, a)
		) | "É" => (
			DÉ(dest_É tm)
			handle (Fail _) =>
			DApp(f, a)
		) | "Ñ" => (
			DÑ(dest_Ñ tm)
			handle (Fail _) =>
			DApp(f, a)
		) | "Ñ%down%1" => (
			DÑ%down%1(dest_Ñ%down%1 tm)
			handle (Fail _) =>
			DApp(f, a)
		) | "á" => (
			Dá(dest_á tm)
			handle (Fail _) =>
			DApp(f, a)
		) | "SetComp" => (
			DSetComp(dest_set_comp tm)
			handle (Fail _) =>
			DApp(f, a)
		) | "å" => Då a
		| _ => DApp(f, a));
		
	fun aux (App (f, a)) = (aux1 (dest_simple_term f) f a)
	| aux (Var v) = DVar v
	| aux (Simpleç a) = Dç a
	| aux (Const (nm,ty)) = aux3 nm ty;
in
	aux (dest_simple_term tm)
end (* let *));
end (* local *);
=TEX
=SML
fun ‚mk_term· ((DVar v) : DEST_TERM) : TERM = mk_var v
| mk_term (DConst c) = mk_const c
| mk_term (DApp fa) = mk_app fa
| mk_term (Dç ab) = mk_ç ab
| mk_term (DT) = mk_t
| mk_term (DF) = mk_f
| mk_term (DEq ee) = mk_eq ee
| mk_term (Dä imp) = mk_ä imp
| mk_term (Då n) = mk_å n
| mk_term (DPair p) = mk_pair p
| mk_term (DÄ cc) = mk_Ä cc
| mk_term (DÅ dd) = mk_Å dd
| mk_term (DÇ ee) = mk_Ç ee
| mk_term (DLet ll) = mk_let ll
| mk_term (DEnumSet ttl) = mk_enum_set ttl
| mk_term (D§ ty) = mk_§ ty
| mk_term (DSetComp s) = mk_set_comp s
| mk_term (DList ttl) = mk_list ttl
| mk_term (DEmptyList ty) = mk_empty_list ty
| mk_term (DÉ f) = mk_É f
| mk_term (DÑ e) = mk_Ñ e
| mk_term (DÑ%down%1 e) = mk_Ñ%down%1 e
| mk_term (Dá s) = mk_á s
| mk_term (DIf ii) = mk_if ii;
=TEX
 
=SML
end; (* of TypesAndTerms signature *)
=TEX
=SML
open TypesAndTerms;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document})
