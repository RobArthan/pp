=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Release 1 ICL HOL: Detailed Design for the Derived Rules of Reasoning}  %% Mandatory field
\def\TPPheadtitle{Release 1 ICL HOL \cr Detailed Design for the Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/DTD007}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
derived rules of reasoning in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
\end{description}
\subsection{Changes forecast}
Must of the text outside the documentation boxes is a discussion
of the design process, rather than being part of the final design.
It will thus be removed or rephrased in later issues.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
derived rules of reasoning.
This is called for in section ??? of ???.
The high-level specification for the code is
given in ???.
The design is
implemented in \cite{DS/FMU/IED/IMP007}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the 
derived rules of reasoning in Release 001 of ICL HOL.
Though other rules of reasoning may be introduced, this 
document should provide a core set, at least covering the rules
of natural deduction, and providing at least easy access to the functionality
of the rules of reasoning for the prototype ICL HOL.
Studies of this coverage may be found in \cite{DS/FMU/IED/WRK013} and
\cite{DS/FMU/IED/WRK014}.

The document provides groups of rules of reasoning, related by their core operator.
The text surrounding the documentation will note when one of the group will be found in the abstract data type $THM$ (\cite{DS/FMU/IED/DTD006}),
or when we choose not to implement a rule called for by our claimed minimum coverage.
\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the `top level'.
Thus we give the commands here for those functions declared in the following signatures.
=SML
infix 4 THEN_C;
infix 4 ORELSE_C;
=TEX
(The priorities given are probably not appropriate)
\section{THE DERIVED RULES OF REASONING}
=DOC
signature âDerivedRulesOfReasoningá = sig
=DESCRIBE
This provides the derived rules of reasoning in Release 001 of ICL HOL.
Though other rules of reasoning may be introduced, this 
document should provide a core set, at least covering the rules
of natural deduction.
=ENDDOC
The declaration of $THM$ will be elsewhere, but for the 
purposes of this document.
=SML
type THM;
=TEX
=DOC
type CONV;
=DESCRIBE
This is the type of conversions, that is, rules of reasoning
whose last argument is a term, and whose result is an equation
whose LHS is precisely that term (no $\alpha$-conversion).
All conversion names will have $\_conv$ as their conventional suffix.
The type is to be used as a subset of $TERM\ ->\ THM$.
=ENDDOC
This should be moved to \cite{DS/FMU/IED/DTD007}.
\subsection{Concerning $T$}
$t\_thm$ will be declared in the initial theory of ICL HOL,
as an axiom:
ó
t_thm = … T
æ
=DOC
val â‚_T_introá :  THM -> THM;
=DESCRIBE
The conclusion of a theorem is equal to $T$.
=RULE
‚_T_intro
É
ö … t
É
ö … t ‚ T
=TEX
($EQT\_INTRO$ in Cambridge HOL).
=ENDDOC
In informal justification may be found in \cite{DS/FMU/IED/DTD006}.
=DOC
val â‚_T_elimá :  THM -> THM;
=DESCRIBE
We can always eliminate $\ldots ‚ T$.
=RULE
‚_T_elim
É
ö … t ‚ T
É
ö … t
=TEX
($EQT\_ELIM$ in Cambridge HOL).
=ENDDOC
In informal justification may be found in \cite{DS/FMU/IED/DTD006}.
=DOC
val â‚_mp_ruleá : THM -> THM -> THM;
=DESCRIBE
Modus Ponens for $‚$.
=RULE
‚_mp_rule
É
ö1 … t1; ö2 … t1 ‚ t2
É
ö1 ¡ ö2 … t2
=TEX
($EQ\_MP$ in Cambridge HOL).
=ENDDOC
\subsection{Concerning $F$}
$f\_thm$ will be declared in a theory of ICL HOL:
ó
f_thm = … Œ F
æ
=DOC
val âcontr_ruleá : TERM -> THM -> THM;
=DESCRIBE
Intuitionistic contradiction rule:
=RULE
contr_rule
(t : TERM)
É
ö … F
É
ö … t
=TEX
($CONTR$ in Cambridge HOL).
=FAILURE
7001	Conclusion of theorem not F
7002	Term is not boolean
=ENDDOC
=DOC
val âc_contr_ruleá : TERM -> THM -> THM;
=DESCRIBE
Classical contradiction rule:
=RULE
c_contr_rule
(t : TERM)
É
ö, Œt … F
É
ö … t
=TEX
Note that the argument is the unnegated form of what must be present 
in the assumption list for success.
Works up to $\alpha$-conversion.
($CCONTR$ in Cambridge HOL).
=FAILURE
7002	Term is not boolean
7003	Negation of term not in assumption list
=ENDDOC
\subsection{Concerning Negation}
=DOC
val âŒ_introá : TERM -> THM -> THM -> THM;
=DESCRIBE
Given two contradictory theorems with the same assumption lists
(up to $\alpha$-convertibility, their assumptions must be inconsistent, and thus any member of the lists may be proven false on the assumption of the remainder
(reductio ad absurdum).
=RULE
Œ_intro (a: TERM)
É
ö, a … b ; ö, a … Œ b
É
ö … Œ a
=TEX
Works up to $\alpha$-conversion, and input theorems may be
in either order.
=FAILURE
7002	Term is not boolean
7004	Theorems do not fit rules pattern
7005	Term is not present in assumption list
=ENDDOC
=DOC
val âŒ_elimá : TERM -> THM -> THM -> THM;
=DESCRIBE
Given two contradictory theorems with the same assumptions,
conclude any other fact from the assumptions.
=RULE
Œ_elim (b: TERM)
É
ö … a ; ö … Œ a
É
ö … b
=TEX
=FAILURE
7002	Term is not boolean
7004	Theorems do not fit rules pattern
=ENDDOC
=DOC
val âŒ_Œ_introá : THM -> THM;
=DESCRIBE
We may always introduce a double negation.
=RULE
Œ_Œ_intro
É
ö … a
É
ö … Œ (Œ a)
=TEX
=ENDDOC
=DOC
val âŒ_Œ_elimá : THM -> THM;
=DESCRIBE
We may always eliminate a double negation.
=RULE
Œ_Œ_elim
É
ö … Œ (Œ a)
É
ö … a
=TEX
=FAILURE
7006	Theorem is not a double negation
=ENDDOC
\subsection{Concerning €}
=DOC
val â€_introá : THM -> THM -> THM;
=DESCRIBE
Conjoin two theorems.
=RULE
€_intro
É
ö1 … a; ö2 … b
É
ö1 ¡ ö2 … a € b
=TEX
($CONJ$ in Cambridge HOL).
=ENDDOC
If we choose eager renaming, we might want to do a check here for
the identification of distinct free variables in the two theorems.
=DOC
val â€_left_elimá : THM -> THM;
=DESCRIBE
Give the left conjunct of a conjunction.
=RULE
€_left_elim
É
ö … a € b
É
ö … a
=TEX
($CONJUNCT1$ in Cambridge HOL).
=FAILURE
7007	Theorem is not a conjunction
=ENDDOC
=DOC
val â€_right_elimá : THM -> THM;
=DESCRIBE
Give the right conjunct of a conjunction.
=RULE
€_right_elim
É
ö … a € b
É
ö … b
=TEX
($CONJUNCT2$ in Cambridge HOL).
=FAILURE
7007	Theorem is not a conjunction
=ENDDOC
Cambridge HOL has $CONJ\_PAIR$, that returns the pair of theorems
resulting individually from the above two elimination rules.
We choose not to provide this.
=DOC
val âlist_€_introá : THM list -> THM;
=DESCRIBE
Conjoin a list of theorems.
=RULE
list_€_intro 
É
[ö1 … t1, ..., ön … tn]
É
ö1 ¡ ... ön … t1 € ... tn
=TEX
($LIST\_CONJ$ in Cambridge HOL).
=ENDDOC
=DOC
val âstrip_€_ruleá : THM -> THM list;
=DESCRIBE
Break a theorem into conjuncts as far as possible.
=RULE
strip_€_rule
É
ö … t
É
[ö … t1, ..., ö … tn]
=TEX
where $t$ can be formed from the $t_i$ by $€\_intro$ alone, with
no duplication, exception or reordering.
($CONJUNCTS$ in Cambridge HOL).
=EXAMPLE
strip_€_rule (… (a € b) € (c € d))
=
[… a, … b, … c, … d]
=ENDDOC
=DOC
val âŠ_€_ruleá : THM -> THM;
=DESCRIBE
A double implication is equivalent to a conjunction and an 
implication.
=RULE
Š_€_rule
É
ö … a Š b Š c
É
ö … (a € b) Š c
=TEX
=FAILURE
7008	Theorem is not a double implication
=ENDDOC
=DOC
val â€_Š_ruleá : THM -> THM;
=DESCRIBE
Change a conjunction hypothesis into a double implication. 
implication.
=RULE
€_Š_rule
É
ö … (a € b) Š c
É
ö … a Š b Š c
=TEX
=FAILURE
7009	Theorem is not an implication whose hypothesis is a conjunction
=ENDDOC
The above two are from \cite{Manna74}, as derived rules
of inference.
\subsection{Concerning }
=DOC
val â_left_introá : TERM -> THM -> THM;
=DESCRIBE
Introduce a disjunct to the left of a theorem's conclusion.
=RULE
_left_intro
(a : TERM)
É
ö … b
É
ö … a  b
=TEX
($DISJ2$ in Cambridge HOL).
=FAILURE
7002	Term is not boolean
=ENDDOC
=DOC
val â_right_introá : THM -> TERM -> THM;
=DESCRIBE
Introduce a disjunct to the right of a theorem's conclusion.
=RULE
_right_intro
(a : TERM)
É
ö … b
É
ö … b  a
=TEX
($DISJ1$ in Cambridge HOL).
=FAILURE
7002	Term is not boolean
=ENDDOC

=DOC
val â_elimá : THM -> THM -> THM -> THM;
=DESCRIBE
Given a disjunctive theorem, and two further theorems, each 
containing one of the disjuncts in their assumptions, but
with the same conclusion, we may eliminate the disjunct assumption
from the second of the theorems.
=RULE
_elim
É
ö1 … t1  t2
ö2, t1' … t
ö3, t2' … t'
É
ö1 ¡ ö2 ¡ ö3 … t
=TEX
where $t1$ and $t1'$ are $\alpha$-convertible, as are
$t2$ and $t2'$, and $t$ and $t'$.
($DISJ\_CASES$ in Cambridge HOL).

=FAILURE
7010	First theorem is not a disjunction
7004	Theorems do not fit rules pattern
=ENDDOC

=DOC
val â_cancel_ruleá : THM -> THM -> THM;
=DESCRIBE
If we know a disjunction is true, and one of its disjuncts is
false, then the other must be true.
If the second theorem is the negation of both disjuncts,
then the second disjunct will be eliminated.
(modus tollendo ponens)
=RULE
_cancel_rule
É
ö1 … t1  t2; ö2 … Œt1'
É
ö1 ¡ ö2 … t2
=TEX
And:
=RULE
_cancel_rule
É
ö1 … t1  t2; ö2 … Œt2'
É
ö1 ¡ ö2 … t1
=TEX
where $t1'$ and $t1$ are $\alpha$-convertible, as are
$t2$ and $t2'$.
=FAILURE
7048	First theorem is not a disjunction
7050	Second theorem is not the negation of either disjunct
=ENDDOC
\subsection{Concerning Š}
See \cite{DS/FMU/IED/DTD006} for $Š\_intro$, $Š\_elim$.
=DOC
val âundisch_ruleá : THM -> THM ;
=DESCRIBE
Undischarge the hypothesis of an implication into the assumption list.
=RULE
undisch_rule
É
ö … a Š b
É
ö ¡ {a} … b
=TEX
($UNDISCH$ in Cambridge HOL).
=FAILURE
7011	Theorem is not an implication
=ENDDOC
=DOC
val âstrip_Š_ruleá : THM -> THM;
=DESCRIBE
Repeatedly apply $undisch\_rule$:
=RULE
strip_Š_rule
É
ö … t1 Š ... Š tn Š b
É
ö ¡ {t1, ..., tn} … b
=TEX
($UNDISCH\_ALL$ in Cambridge HOL).
=ENDDOC
=DOC
val âassum_Š_introá :THM -> THM;
=DESCRIBE
Discharge all members of assumption list using $Š\_intro$.
=RULE
assum_disch_rule
É
{t1, ..., tn} … t
É
… t1 Š ... Š tn Š b
=TEX
($DISCH\_ALL$ in Cambridge HOL).
=ENDDOC
=DOC
val âŠ_trans_ruleá : THM -> THM -> THM;
=DESCRIBE
Transitivity of $Š$.
=RULE
Š_trans_rule
É
ö1 … t1 Š t2; ö2 … t2' Š t3
É
ö1 ¡ ö2 … t1 Š t3
=TEX
where $t2$ and $t2'$ are $\alpha$-convertible.
($IMP\_TRANS$ in Cambridge HOL).
=FAILURE
7040	First theorem is not an implication
7041	Second theorem is not an implication
7042	Conclusion of first implication not alpha-convertible to hypothesis of second
=ENDDOC
=DOC
val âŠ_match_mp_ruleá : THM -> THM -> THM ;
=DESCRIBE
A matching Modus Ponens rule for implication.
=RULE
Š_match_mp_rule
É
ö1 … t1; ö2 … ƒ x1 ... Ž t1' Š t2'
É
ö1 ¡ ö2 … t2'
=TEX
where we type instantiate and specialise the second theorem
to get its hypothesis to match the conclusion of the
first theorem.
($MATCH\_MP$ in Cambridge HOL).
=FAILURE
7043	Second theorem is not of the form ƒ x1 ... Ž t1 Š t2
7044	Cannot match the theorems
=ENDDOC
=DOC
val âmodus_tollens_ruleá : THM -> THM;
=DESCRIBE
If the conclusion of an implication is false, then so must be
the hypothesis (modus tollens).
=RULE
modus_tollens_rule
É
ö1 … a Š b; ö2 … Œb'
É
ö1 ¡ ö2 … Œa
=TEX
where $b$ and $b'$ are $\alpha$-convertible.
=FAILURE
7040	First theorem is not an implication
7051	Second theorem is not the negation of the conclusion of the first
=ENDDOC

\subsection{Concerning ‚}
In \cite{DS/FMU/IED/DTD006} we provide: $‚\_mp\_rule$,
$eq\_refl\_rule$(which works with $‚$ as well),
$eq\_trans\_rule$(which works with $‚$ as well),
$eq\_sym\_rule$(which works with $‚$ as well), and
$subst\_rule$.
=DOC
val â‚_introá : THM -> THM -> THM;
=DESCRIBE
Join two implications into an iff.
=RULE
‚_intro
É
ö … a Š b; ö … b' Š a'
É
ö … a ‚ b
=TEX
where $a$ and $a'$ are $\alpha$-convertible, as are
$b$ and $b'$. 
($CONJ\_IFF$ and $IMP\_ANTISYM\_RULE$ in Cambridge HOL).
=FAILURE
7004	Theorems do not fit rules pattern
=ENDDOC
=DOC
val â‚_elimá : THM -> (THM * THM);
=DESCRIBE
Split an Iff., into two implications
=RULE
‚_elim
É
ö … a ‚ b
É
ö … a Š b; ö … b Š a
=TEX
($IFF\_CONJ$ and $EQ\_IMP\_RULE$ in Cambridge HOL).
=FAILURE
7062	Theorem is not an iff.
=ENDDOC
Perhaps we want $‚\_left\_elim$ and $‚\_right\_elim$ as well,
being no more than $fst\ o\ ‚\_elim$ and $snd\ o\ ‚\_elim$.

\subsection{Concerning =}
In \cite{DS/FMU/IED/DTD006} we provide: 
$eq\_refl\_rule$,
$eq\_trans\_rule$,
$eq\_sym\_rule$, and
$subst\_rule$.
=DOC
val âŒ_eq_sym_ruleá : THM -> THM ;
=DESCRIBE
If $a$ is not equal to $b$ then $b$ is not equal to $a$.
=RULE
Œ_eq_sym_rule
É
ö … Œ(a = b)
É
ö … Œ(b = a)
=TEX
and
=RULE
Œ_eq_sym_rule
É
ö … Œ(a ‚ b)
É
ö … Œ(b ‚ a)
=TEX
($NOT\_EQ\_SYM$ in Cambridge HOL).
=ENDDOC
=DOC
val ârewrite_convá : THM -> CONV ;
=DESCRIBE
This is the core of the rewriting rules of reasoning.
It matches the LHS of an equational theorem to a term,
instantiating the RHS accordingly.
The equation may be partially or fully universally quantified,
without affecting the result of the conversion.
=RULE
rewrite_conv
(t : TERM)
É
ö … u = v
É
ö … t = v'
=TEX
and
=RULE
rewrite_conv
(t : TERM)
É
ö … u ‚ v
É
ö … t ‚ v'
=TEX
where $v'$ is the result of applying the instantiation rules required to match $u$ to $t$ to $v$.
If there are free variables on the RHS of the supplied equation (when stripped of all universal quantification)
they will be renamed as necessary to avoid identification with
any variables in $t$.
($REWRITE\_CONV$ in Cambridge HOL).
=ENDDOC
The process of renaming to avoid identification is a minimum requirement on free variables on the RHS.
More powerful requirements (e.g. something like $genvar$) could be appropriate.
This conversion could equally well be called $match\_conv$.

We do not give detailed designs for the rewriting rule family
(e.g. $REWRITE\_RULE$ of Cambridge HOL),
as they are dependent on decisions not yet taken.

Nor do we give their associated canonicalisation rules $IMP\_CANON$ 
and $RES\_CANON$, or the tautology generating rules that might be rewritten with, such as $TAUT\_RULE$.
\subsection{Concerning $if\ldots then\ldots else \ldots$}

=DOC
val âif_introá : TERM -> THM -> THM -> THM;
=DESCRIBE
Introduce a conditional, based on the assumptions of two theorems.
=RULE
if_intro
(a: TERM)
É
ö1, a … tt ;  ö2, Œa' … et
É
ö1 ¡ ö2 … if a then tt else et
=TEX
where $a$ and $a'$ are $\alpha$-convertible.
=FAILURE
7002	Term is not boolean
7004	Theorems do not fit rules pattern
7005	Term is not present in assumption list
=ENDDOC
Perhaps the theorems could be in either order, the rule working out
which.
=DOC
val âif_then_elimá : THM -> THM;
=DESCRIBE
Give the dependence of the $then$ branch of a conditional
upon the condition.
=RULE
if_then_elim
É
ö … if a then tt else et
É
ö … a Š tt
=TEX
=FAILURE
7012	Theorem is not a conditional
=ENDDOC
=DOC
val âif_else_elimá : THM -> THM;
=DESCRIBE
Give the dependence of the $else$ branch of a conditional
upon the condition.
=RULE
if_else_elim
É
ö … if a then tt else et
É
ö … Œ a Š et
=TEX
=FAILURE
7012	Theorem is not a conditional
=ENDDOC

As the ICL HOL conditional on booleans is the same as that on other
types,  we choose a different presentation to \cite{Manna74},
where this is not true.
However, Manna's rules for conditionals on other types can be derived from those present here, and vice versa.
=DOC
val âif_fun_ruleá : TERM -> THM -> THM;
=DESCRIBE
Move a function application out of a conditional.
=RULE
if_fun_rule
(f : TERM)
É
ö … if a then f' b else f'' c
É
ö … f' (if a then b else c)
=TEX
where $f$, $f'$ and $f''$ are $\alpha$-convertible.
=FAILURE
7012	Theorem is not a conditional
7052	Term is not found applied to both branches of conditional
=ENDDOC
=DOC
val âfun_if_ruleá : THM -> THM;
=DESCRIBE
Move a function application into a conditional.
=RULE
if_fun_rule
É
ö … f(if a then b else c)
É
ö … if a then f b else f c
=TEX
=FAILURE
7053	Theorem is not a function applied to a conditional
=ENDDOC

\subsection{Concerning }
In \cite{DS/FMU/IED/DTD006} we provide $abs\_rule$ and $beta\_conv$.
=DOC
val â_ruleá : TERM -> THM -> THM;
=DESCRIBE
An introduction rule for $$:
=RULE
_rule
(x : TERM)
É
ö … t[x]
É
ö … ( x Ž t[x]) x
=TEX
where $x$ must be allowed by the ICL HOL syntax,
and $x$ may or may not be present in $t$, or even $ö$.
=FAILURE
7056	Term is not an allowed variable structure
=ENDDOC
=DOC
val âpaired_beta_convá : CONV;
=DESCRIBE
A full $\beta$ conversion.
=RULE
paired_beta_conv
(( x Ž t[x])y)
É
É
… (( x Ž t[x])y) = t'[y]
=TEX
where $x$ may be any variable structure allowed by the ICL HOL syntax
, $y$ is an instance of this structure,
and $t'$ is $\alpha$-convertible to $t$, to avoid variable capture.
=SEEALSO
$beta\_conv$
=FAILURE
7029	Term is not an abstraction applied to a value
7057	Argument to abstraction not an instance of abstracted variable structure
=ENDDOC
This may be renamed to $\beta\_conv$, if the original is renamed
$simple\_\beta\_conv$.
=DOC
val âall_beta_convá : CONV;
=DESCRIBE
A conversion to eliminate all instances of $\beta$ redexes,
including paired abstraction redexes, in a term, regardless of nesting, or even that the $\beta$ redex was created as the result of
an earlier reduction in the conversion's evaluation.
=RULE
all_beta_conv
(t : TERM)
É
É
… t = t'
=TEX
$t'$ is $t$ with all $\beta$ redexes reduced.
=USES
This uses an optimised term traversal algorithm, superior in speed
to the general term traversal algorithms used with conversions,
and should be used in preference to them and $paired\_beta\_conv$.
=ENDDOC
=DOC
val âbeta_ruleá : THM -> THM;
=DESCRIBE
Eliminate all instances of $\beta$ redexes,
including paired abstraction redexes, in a theorem, regardless of nesting, or even that the $\beta$ redex was created as the result of
an earlier reduction in the rule's evaluation.
=RULE
beta_rule
É
ö … t
É
ö … t'
=TEX
$t'$ is $t$ with all $\beta$-redexes reduced.
($BETA\_RULE$ in Cambridge HOL).
=ENDDOC
=DOC
val âeta_convá : CONV ;
=DESCRIBE
The rule for $\eta$ conversion.
=RULE
eta_conv
( x Ž t x : TERM)
É
É
… ( x Ž t x) = t
=TEX
where $t$ contains no instances of $x$.
($ETA\_CONV$ in Cambridge HOL).
=FAILURE
7030	Term is not an abstraction
7031	Term is not of form  x Ž t x with t not containing x
=ENDDOC

\subsection{Concerning ƒ}
In \cite{DS/FMU/IED/DTD006} we provide
$ƒ\_intro$ and $ƒ\_elim$.
=DOC
val âlist_ƒ_introá : TERM list -> THM -> THM;
=DESCRIBE
Generalised $ƒ$ introduction.
=RULE
list_ƒ_intro
[v1, ..., vn]
É
ö … t[v1, ..., vn]
É
ö … ƒ v1 ... vn Ž t[v1, ..., vn]
=TEX
($GENL$ in Cambridge HOL).
=SEEALSO
$ƒ\_intro$
=FAILUREC
\paragraph{Failure}
Same messages as $ƒ\_intro$.
=ENDDOC
=DOC
val âlist_ƒ_elimá : TERM list -> THM -> THM;
=DESCRIBE
Generalised $ƒ$ elimination.
=RULE
list_ƒ_elim
[t1, ..., tn]
É
ö … ƒ v1 ... vn Ž t[v1, ..., vn]
É
t[t1, ..., tn]
=TEX
($SPECL$ in Cambridge HOL).
=SEEALSO
$ƒ\_elim$
=FAILUREC
\paragraph{Failure}
Same messages as $ƒ\_elim$.
=ENDDOC
=DOC
val âall_ƒ_introá : THM -> THM;
=DESCRIBE
Generalises all the free variables in a theorem:
=RULE
all_ƒ_intro
É
ö … t
É
ö … ƒ v1 ... vn Ž t
=TEX
where $v1, \ldots, vn$ are all the free variables of $t$.
($GEN\_ALL$ in Cambridge HOL).
=ENDDOC
=DOC
val âall_ƒ_elimá : THM -> THM;
=DESCRIBE
Specialises all the free variables in a theorem:
=RULE
all_ƒ_elim
É
ö … ƒ v1 ... vn Ž t[v1, ..., vn]
É
ö … t[v1', ..., vn']
=TEX
where $v1', \ldots, vn'$ are renamed from $v1, \ldots, vn$ as necessary to avoid clashes with
free variables in the assumption list.
($GEN\_ALL$ in Cambridge HOL).
=ENDDOC
Do we want a sequence of rules that handle arbitrary paired universal quantifiers.
=DOC
val âŒ_ƒ_convá : CONV;
=DESCRIBE
Move $Œ$ into a $ƒ$ construct.
=RULE
Œ_ƒ_conv
(Œ (ƒ x Ž t[x]) : TERM)
É
É
… (Œ (ƒ x Ž t[x])) ‚ „ x Ž Œ t[x]
=TEX
This will work with any paired universal quantifier.
($NOT\_FORALL\_CONV$ in Cambridge HOL).
=FAILURE
7036	Not a negated universal quantifier
=ENDDOC
=DOC
val âƒ_‚_ruleá : TERM -> THM -> THM;
=DESCRIBE
Universally quantify a variable on both sides of an equivalence.
=RULE
ƒ_‚_rule
(x : TERM)
É
ö … p ‚ q
É
ö … (ƒ x Ž p) ‚ (ƒ x Ž q)
=TEX
where $x$ is a variable structure.
($FORALL\_EQ$ in Cambridge HOL).
=FAILURE
7037	Theorem is not a boolean equation
7056	Term is not an allowed variable structure
7063	Term would cause variable capture
=ENDDOC
=DOC
val âƒ_arb_elimá : THM -> THM;
=DESCRIBE
Specialise a universally quantified theorem with a machine generated variable.
=RULE
ƒ_arb_elim
É
ö … ƒ x Ž p[x]
É
ö … p[x']
=TEX
where $x'$ is not a variable (free or bound) in $p$.
($GSPEC$ in Cambridge HOL).
=ENDDOC
The precise rules for the name formation of $x$ will not be given here.
=DOC
val âƒ_assum_ruleá : TERM -> TERM -> THM -> THM;
=DESCRIBE
Generalise an assumption (Left $ƒ$ introduction).
=RULE
ƒ_assum_rule
(x : TERM)
(p[x] : TERM)
É
ö, p'[x] … q[x]
É
ö, ƒ x Ž p'[x] … q[x]
=TEX
where $p$ and $p'$ are $\alpha$-convertible.
$x$ {\bf may} be free in $ö$.
=FAILURE
7054	First term is not a variable
7055	Second term is not in theorems assumption list
=ENDDOC
We do not give a rule for $ƒƒ$ introduction from \cite{Manna74}.
\subsection{Concerning „}
=DOC
val â„_introá : TERM -> THM -> THM ;
=DESCRIBE
Introduce an existential quantifier by reference to a witness.
=RULE
„_intro
(„ x Ž t1[x] : TERM)
É
ö … t1[t2]
É
ö … „ x Ž t1[x]
=TEX
($EXISTS$ in Cambridge HOL).
=FAILURE
7047	Term cannot be matched to conclusion of theorem
=ENDDOC
In Cambridge HOL you give $t2$ as another argument, though this
seems only to speed the correctness check, as it may be
derived via $term\_match$.
=DOC
val â„_elimá : TERM -> THM -> THM -> THM ;
=DESCRIBE
Eliminate an existential quantifier by reference to an arbitrary variable satisfying the predicate.
=RULE
„_elim
(t1[v] : TERM)
É
ö1 … „ x Ž t1[x]; ö2, t1[v] … t2
É
ö1 ¡ ö2 … t2
=TEX
where $v$ must be a free variable, not present elsewhere in theorems.
($CHOOSE$ in Cambridge HOL).
=FAILURE
7002	Term is not boolean
7013	Term is not present in assumption list of second theorem
7014	Cannot match term to conclusion of first theorem and gain a free variable
=ENDDOC
=DOC
val âŒ_„_convá : CONV;
=DESCRIBE
Move $Œ$ into an $„$ construct.
=RULE
Œ_„_conv
(Œ („ x Ž t[x]) : TERM)
É
É
… (Œ („ x Ž t[x])) ‚ ƒ x Ž Œ t[x]
=TEX
This will work with any paired existential quantifier.
($NOT\_EXISTS\_CONV$ in Cambridge HOL).
=FAILURE
7058	Not a negated existential quantifier
=ENDDOC
=DOC
val â„_assum_ruleá : TERM -> TERM -> THM -> THM;
=DESCRIBE
Generalise an assumption (Left $„$ introduction).
=RULE
„_assum_rule
(x : TERM)
(p[x] : TERM)
É
ö, p'[x] … q[x]
É
ö, „ x Ž p'[x] … q[x]
=TEX
where $p$ and $p'$ are $\alpha$-convertible.
$x$ {\bf may} be free in $ö$.
=FAILURE
7054	First term is not a variable
7055	Second term is not in theorems assumption list
=ENDDOC
We do not give a rule for $„„$ introduction from \cite{Manna74}.
\subsection{Concerning À}
For the time being this will be $„\_1$ instead.
=DOC
val â„_1_introá : TERM -> THM -> THM -> THM;
=DESCRIBE
Introduce $„_1$ by reference to a witness, and a uniqueness theorem.
=RULE
„_1_intro
É
ö1 … P'[t']
ö2 … ƒ x Ž P[x] Š x = t
É
ö1 ¡ ö2 … „_1 x Ž P[x]
=TEX
Where $P'$ is $\alpha$-convertible to $P$, and
$t'$ is $\alpha$-convertible to $t$.
Notice that for the resulting theorem we take the bound variable name, $x$, and the form of the predicate, $P$, from the second theorem.
=FAILURE
7004	Theorems do not fit rules pattern
=ENDDOC
=DOC
val â„_1_elimá : THM -> THM;
=DESCRIBE
Express a $„_1$ in terms of $„$ and a uniqueness property.
=RULE
„_1_elim
É
ö … „_1 x Ž P[x]
É
ö … „ x Ž P[x] € ƒ y Ž P[y] Š y = x
=TEX
=FAILURE
7015	Theorem is not a unique existence theorem
=ENDDOC
\subsection{Concerning $Select$}
=DOC
val âselect_intro_ruleá : THM -> THM;
=DESCRIBE
Given a theorem whose conclusion is a function application,
we know that the ``function'' is a predicate, and the rule states that
$Select$ of this predicate will satisfy the predicate.
=RULE
select_intro_rule
É
ö … t1 t2
É
ö … t1 (Select t1)
=TEX
($SELECT\_INTRO$ in Cambridge HOL).
=FAILURE
7016	Conclusion of theorem is not a function application
=ENDDOC
$Select$ is not part of natural deduction so the rule cannot really be suffixed by just $\_intro$.
=DOC
val âselect_elim_ruleá : TERM -> THM -> THM -> THM;
=DESCRIBE
Given that $Select$ of a predicate satisfies that predicate, then
in a different theorem we may eliminate an assumption that 
claims an otherwise unused variable satisfies the predicate.
=RULE
select_elim_rule
(t1 v : TERM)
É
ö1 … t1 (Select t1);
ö2, t1 v … t
É
ö1 ¡ ö2 … t
=TEX
where $v$ if a free variable occurring nowhere else in the theorems
($SELECT\_ELIM$ in Cambridge HOL).
=FAILURE
7017	Term must be predicate applied to variable
7005	Term is not present in assumption list
7018	Variable in term found free in theorems
7019	First theorem must be of form … t1(Select t1)
=ENDDOC
=DOC
val â„_select_ruleá : THM -> THM;
=DESCRIBE
Give that $Select$ of a predicate satisfies the predicate by reference to an $„$ construct.
=RULE
„_select_rule
É
ö … „ x Ž p[x]
É
ö … p(Select x Ž p x)
=TEX
($SELECT\_RULE$ in Cambridge HOL).
=ENDDOC
\subsection{Concerning Local Definitions}
=DOC
val âlet_intro_ruleá : (string * TERM) -> THM -> THM;
=DESCRIBE
Introduce a local definition.
=RULE
let_intro_rule
([(v, t1),...,(vn,...,tn)] : 
	(string * TERM) list)
É
ö … t[t1,...tn]
É
ö … let v1' = t1 and ... vn' = tn in t2[v']
=TEX
where $v_i'$ in the result are variables with the names $v_i$, and with the type of $t_i$, perhaps made into variants to avoid variable capture.
=ENDDOC
Perhaps we should provide a template of what $t[...]$ should look like, so that not all instances of $t_i$ are changed to $v_i$.
Perhaps we should fail, rather than rename, if variable capture occurs.
=DOC
val âlet_elim_ruleá : THM -> THM;
=DESCRIBE
Eliminate an outermost $let\ldots and\ldots in\ldots$ construct.
=RULE
let_elim_rule
É
ö … let v1 = t1 and ... vn = tn 
	in t[v1,...,vn]
É
ö … t[t1,...,tn]
=TEX
=ENDDOC

\subsection{Concerning $Uncurry$}
I don't believe we need a rule for eliminating $Uncurry$,
and its introduction is mostly behind the scenes.

\subsection{Concerning Sets}
A much wider set of rules than the below could be given .
=DOC
val âenum_set_ruleá : TERM -> TERM list -> THM;
=DESCRIBE
Give that something within an enumerated set is a member of that set.
=RULE
enum_set_rule
(ti : TERM)
([t1,...tn] : TERM list)
É
É
… ti  {t1,...,tn}
=TEX
where $ti$ is alpha convertible to one of $t1,\ldots,tn$.
=FAILURE
7020	Term list may not be empty
7021	Differing types in term list
7022	Term has different type to elements in term list
=ENDDOC
A speculative form of rule, but the functionality will be useful
when handling sets.
=DOC
val âset_ruleá : TERM -> string -> THM -> THM;
=DESCRIBE
Given that $x$ satisfies a predicate $P$, show that $x$ is a member of the
set constructed from $P$.
=RULE
set_rule
(x : TERM)
(v : string)
É
ö … P [x]
É
ö … x  {v' | P[v']}
=TEX
where $v'$ is a variable with name $v$ (or a variant as necessary,
to avoid variable capture) and the type of $x$.
=ENDDOC
A speculative form of rule, but the functionality will be useful when handling sets.
Perhaps we should provide a template for $P$, to allow only 
some instances of $x$ to be ``captured''.
\subsection{Concerning Functional Application}
See \cite{DS/FMU/IED/DTD006} for $mk\_comb\_rule$.
We might later want a variant of $mk\_comb\_rule$ that prevents the
identification of free variables in the two theorems.
=DOC
val âap_fun_ruleá : TERM -> THM -> THM ;
=DESCRIBE
Apply a function to both sides of an equation.
=RULE
ap_fun_rule
(f : TERM)
É
ö … x = y
É
ö … f x = f y
=TEX
Or:
=RULE
ap_fun_rule
(f : TERM)
É
ö … x = y
É
ö … f x ‚ f y
=TEX
($AP\_TERM$ in Cambridge HOL).
=FAILURE
7023	Theorem is not an equation
7024	Term may not be applied to each side of equation
=ENDDOC
=DOC
val âap_arg_ruleá : THM -> TERM -> THM;
=DESCRIBE
Apply both sides of an equation to an argument.
=RULE
ap_arg_rule
(x : TERM)
É
ö … f = g
É
ö … f x = g x
=TEX
Or:
=RULE
ap_arg_rule
(x : TERM)
É
ö … f = g
É
ö … f x ‚ g x
=TEX
($AP\_THM$ in Cambridge HOL).
=FAILURE
7023	Theorem is not an equation
7025	Sides of equation may not be applied to term
=ENDDOC
=DOC
val âext_ruleá : THM -> THM;
=DESCRIBE
Extensionality of functions in ICL HOL.
=RULE
ext_rule
É
ö … f = g
É
ö … ƒ x Ž f x = g x
=TEX
Or:
=RULE
ext_rule
É
ö … f = g
É
ö … ƒ x Ž f x ‚ g x
=TEX
where $x$ is a machine-generated variable of appropriate type,
not found free in the equation.
($EXT$ in Cambridge HOL).
=FAILURE
7023	Theorem is not an equation
7026	Theorem is not an equation of functions
=ENDDOC
\subsection{Concerning Assumptions}
See \cite{DS/FMU/IED/DTD006} for $assum\_rule$.
=DOC
val âassum_introá : TERM -> THM -> THM;
=DESCRIBE
Introduce a new assumption to an existing theorem.
=RULE
assum_intro
(t1 : TERM)
É
ö … t2
É
ö ¡ {t1} … t2
=TEX
($ADD\_ASSUM$ in Cambridge HOL).
=FAILURE
7002	Term is not boolean
=ENDDOC
=DOC
val âassum_elimá : TERM -> THM -> THM;
=DESCRIBE
Eliminate an assumption with reference to contradictory assumption lists.
=RULE
assum_elim
(a : TERM)
É
ö1, a' … t; ö2, Œa''  … t
É
ö1 ¡ ö2 … t
=TEX
where $a$, $a'$ and $a''$ are $\alpha$-convertible.
=FAILURE
7002	Term is not boolean
7027	Term is not in assumption list of first theorem
7028	Negation of term is not in assumption list of second theorem
=ENDDOC
=DOC
val âprove_hyp_ruleá : THM -> THM -> THM;
=DESCRIBE
Eliminate an assumption with reference to a the assumption being a conclusion of a theorem.
=RULE
prove_hyp_rule
É
ö1 … t1; ö2, t1 … t2
É
ö1 ¡ ö2 … t2
=TEX
($PROVE\_HYP$ in Cambridge HOL).
=ENDDOC
This could easily be a (the?) assumption elimination rule, though \cite{Manna74} doesn't so use it.
\subsection{Concerning $\alpha$-conversion}
=DOC
val âalpha_ruleá : TERM -> TERM -> THM;
=DESCRIBE
Returns a theorem that two terms are equal, should they be
$\alpha$-convertible.
=RULE
alpha_rule
(t1 : TERM)
(t2 : TERM)
É
É
… t1 = t2
=TEX
($ALPHA$ in Cambridge HOL).
=FAILURE
7033	Terms are not of same type
7034	Terms are not alpha-convertible
=ENDDOC
Should be renamed $\alpha\_rule$.
=DOC
val âalpha_convá : TERM -> CONV;
=DESCRIBE
Rename a bound variable name, as a conversion.
This only works with simple abstractions.
=RULE
alpha_conv
(v : string)
( x Ž t[x])
É
É
… ( x Ž t[x]) = ( v Ž t[v])
=TEX
($ALPHA\_CONV$ in Cambridge HOL).
=FAILURE
7030	Term is not an abstraction
7035	Cannot rename bound variable to ?1 as this would cause variable capture
=ENDDOC
=DOC
val âbinder_alpha_convá : TERM -> CONV;
=DESCRIBE
Rename a bound variable name, through any single binder, as a conversion.
This only works with simple abstractions.
=RULE
binder_alpha_conv
(v : string)
(B x Ž t[x])
É
É
… (B x Ž t[x]) = (B v Ž t[v])
=TEX
where $B$ is a binder.
($GEN\_ALPHA\_CONV$ in Cambridge HOL).
=FAILURE
7059	Term is not an binder
7035	Cannot rename bound variable to ?1 as this would cause variable capture
=ENDDOC

\subsection{Concerning Conversions}
\subsubsection{Building Blocks}
=DOC
val ârefl_convá : CONV;
=DESCRIBE
The reflexivity of equality considered as a conversion.
=RULE
refl_conv
(t : TERM)
É
É
… t = t
=TEX
($ALL\_CONV$ in Cambridge HOL).
=USES
In building term-traversing conversions.
=SEEALSO
$refl\_rule$
=ENDDOC
=DOC
val âfail_convá : CONV;
=DESCRIBE
This conversion always fails.
($NO\_CONV$ in Cambridge HOL).
=FAILURE
7061	Failed as requested
=ENDDOC
\subsubsection{Conversionals}
=DOC
val âTHEN_Cá : (CONV * CONV) -> CONV;
=DESCRIBE
Combine the effect of two conversions.
=RULE
(c1: CONV) THEN_C (c2: CONV)
(t : TERM)
É
É
ö … t = t''
=TEX
where $c1\ t$ returns $ö1 … t = t'$, and $c2\ t'$ returns
$ö2 … t' = t''$ and
$ö$ equals $ö1 ¡ ö2$.
($THENC$ in Cambridge HOL).
=SEEALSO
$LIST\_THEN\_C$
=FAILUREC
\paragraph{Failure}
If any, as the failures of $c1$ and $c2$ applied to $t$ and $t'$ respectively.
=ENDDOC
=DOC
val âORELSE_Cá : (CONV * CONV) -> CONV;
=DESCRIBE
Attempt to apply one conversion, and if that fails, try the second one.
=RULE
(c1: CONV) ORELSE_C (c2: CONV)
(t : TERM)
É
É
ö … t = t'
=TEX
where $c1\ t$ returns $ö … t = t'$, or $c1$ fails, and
$c2\ t$ returns
$ö … t' = t'$.
($ORELSEC$ in Cambridge HOL).
=SEEALSO
$LIST\_ORELSE\_C$
=FAILUREC
\paragraph{Failure}
As the failure of $c2$, should both $c1$ and $c2$ fail.
=ENDDOC
=DOC
val âREPEAT_Cá : CONV -> CONV;
=DESCRIBE
Repeatedly apply a conversion to a term.
To be more precise, the functionality will be equivalent that of the following definition:
ó
fun REPEAT_C (c:CONV) = 
	(c THEN_C (REPEAT_C c)) ORELSE_C refl_conv
æ
($REPEATC$ in Cambridge HOL).
=ENDDOC
=DOC
val âLIST_THEN_Cá : CONV list -> CONV;
=DESCRIBE
Apply each conversion in the list, in the sequence given.
($EVERYC$ in Cambridge HOL).
=SEEALSO
$THEN\_C$
=FAILUREC
\paragraph{Failure}
As the failure of any constituent conversion.
=ENDDOC
=DOC
val âLIST_ORELSE_Cá : CONV list -> CONV;
=DESCRIBE
Attempt to apply each conversion in the list, in the sequence given, until one succeeds, or all fail.
($FIRSTC$ in Cambridge HOL).
=SEEALSO
$ORELSE\_C$
=FAILUREC
\paragraph{Failure}
As the failure of the last conversion.
=ENDDOC
=DOC
val âCHANGED_Cá : CONV -> CONV;
=DESCRIBE
Applies a conversion, and fail if either the conversion fails,
or it causes no change.
Even $\alpha$-convertible changes count as a change for this purpose.
($CHANGED\_CONV$ in Cambridge HOL).
=FAILURE
7032	Conversion failed to cause a change
=FAILUREC
It may also failed with the error message of the conversion argument.
=ENDDOC
=DOC
val âTRY_Cá : CONV -> CONV;
=DESCRIBE
Attempt to apply a conversion, and if it fails, apply $refl\_conv$.
($TRY\_CONV$ in Cambridge HOL).
=ENDDOC
\subsubsection{Term Traversal Algorithms for Conversions}
There will be a term traversal conversion tool, prototyped in \cite{DS/FMU/IED/SML019}.
Thus we do not provide as full a tool kit as possible.
In particular we do not give equivalents to $DEPTH\_FORALL\_CONV$
and $DEPTH\_EXISTS\_CONV$.
=DOC
val âRAND_Cá : CONV -> CONV;
=DESCRIBE
Apply a conversion to the operand of a combination:
=RULE
RAND_C
(c : CONV)
(f a : TERM)
É
É
… f a = f a'
=TEX
where $c\ a$ gives $… a = a'$.
($RAND\_CONV$ in Cambridge HOL).
=FAILURE
7045	Term is not a combination
=ENDDOC
=DOC
val âRATOR_Cá : CONV -> CONV;
=DESCRIBE
Apply a conversion to the operator of a combination:
=RULE
RATOR_C
(c : CONV)
(f a : TERM)
É
É
… f a = f' a
=TEX
where $c\ f$ gives $… f = f'$.
($RAND\_CONV$ in Cambridge HOL).
=FAILURE
7045	Term is not a combination
=ENDDOC
=DOC
val âABS_Cá : CONV -> CONV;
=DESCRIBE
Apply a conversion to the body of a simple abstraction:
=RULE
ABS_C
(c : CONV)
( x Ž p : TERM)
É
É
… ( x Ž p[x]) = ( x Ž p'[x])
=TEX
where $c\ p[x]$ gives $… p[x] = p'[x]$.
($ABS\_CONV$ in Cambridge HOL).
=SEEALSO
$BINDER\_C$
=FAILURE
7030	Term is not an abstraction
=ENDDOC
=DOC
val âBINDER_Cá : CONV -> CONV;
=DESCRIBE
Apply a conversion to the body of a simple binder term:
=RULE
BINDER_C
(c : CONV)
(B x Ž p : TERM)
É
É
… (B x Ž p[x]) = (B x Ž p'[x])
=TEX
where $c\ p[x]$ gives $… p[x] = p'[x]$,
and $B$ is a binder.
($BINDER\_CONV$ in Cambridge HOL).
=FAILURE
7046	Term is not a binding
=ENDDOC
=DOC
val âSUB_Cá : CONV -> CONV;
=DESCRIBE
Apply a conversion to each of the constituents of a term,
however that term might be constructed,
and recombine the results.
Thus:
ó
SUB_C cnv var = cnv var

SUB_C cnv const = cnv const

SUB_C cnv (f x) = ö … f x = f' x' 
	where cnv f = ö1 … f = f'
	and   cnv x = ö2 … x = x'
	and ö = ö1 ¡ ö2

SUB_C cnv ( x Ž t) = ö … ( x Ž t) = ( x Ž t')
	where cnv t = ö … t = t'
æ
($SUB\_CONV$ in Cambridge HOL).
=ENDDOC
The following traversal schemes are those provided by Cambridge HOL,
and are by no means a complete set of ``reasonable'' traversal schemes.
Indeed, $TRAVERSE\_C4$ is unlikely to ever be an efficient traversal scheme.
The choice of name indicates no more than a traversal scheme, and
is intended to stop misconceptions about the schemes.
A more meaningful naming system would be nice.
=DOC
val âTRAVERSE_C1á : CONV -> CONV;
=DESCRIBE
This traverses a term from the root node to its leaves,
attempting to apply its conversion argument.
If it successfully applies the conversion to any subterm
then it will not further traverse that subterm,
but will still continue on other branches.
If it fails to apply its conversion to a leaf, it then applies $refl\_conv$.
It traverses from left to right, though this should only matter for
conversions that work by side-effect.
($ONCE\_DEPTH\_CONV$ in Cambridge HOL).
=ENDDOC
=DOC
val âTRAVERSE_C2á : CONV -> CONV;
=DESCRIBE
This traverses a term from its leaves to its root node.
It will repeat the application of its conversion argument, until failure,
on each subterm encountered en route.
At each node the conversion is applied to the sub-term that results from the application of the preceding traversal, not the original.
It traverses from left to right, though this should only matter for
conversions that work by side-effect.
($DEPTH\_CONV$ in Cambridge HOL).
=ENDDOC
=DOC
val âTRAVERSE_C3á : CONV -> CONV;
=DESCRIBE
This traverses a term from its root node to its leaves.
It will repeat the application of its conversion argument, until failure,
on each subterm encountered en route.
It descends through the sub-term that results from the application of the preceding traversal, not the original.
It traverses from left to right, though this should only matter for
conversions that work by side-effect.
($TOP\_DEPTH\_CONV$ in Cambridge HOL).
=ENDDOC
=DOC
val âTRAVERSE_C4á : CONV -> CONV;
=DESCRIBE
This traverses a term from its leaves to its root node.
It will repeat the application of its conversion argument, until failure,
on each subterm encountered en route.
At each node the conversion is applied to the sub-term that results from the application of the preceding traversal, not the original.
At any subterm the conversion is successfully applied, the resulting
subterm will be completely re-traversed once more.
It traverses from left to right, though this should only matter for
conversions that work by side-effect.
($REDEPTH\_CONV$ in Cambridge HOL).
=ENDDOC
\subsubsection{Conversions as Rules}
=DOC
val âconv_ruleá : CONV -> THM -> THM;
=DESCRIBE
Apply a conversion to the conclusion of a theorem, and do $‚$ modus ponens between the original theorem and the result of the conversion
=RULE
conv_rule
(c : CONV)
É
ö1 … t
É
ö1 ¡ ö2 … t'
=TEX
where $c\ t$ equals $ö2 … t ‚ t'$.
($CONV\_RULE$ in Cambridge HOL).
=ENDDOC
=SML
end; (* signature of DerivedRulesOfReasoning *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
