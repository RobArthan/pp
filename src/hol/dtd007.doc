=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design for the Derived Rules of Inference}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the Derived Rules of Inference}
\TPPref{DS/FMU/IED/DTD007}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
derived rules of inference in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Changes after RDA comments.
\item [Issue 1.3,1.4]
Moved statements about Cambridge HOL outside of documentation
boxes.
Added some conversions paralleling the functionality of some of the rules given in \cite{DS/FMU/IED/DTD006} and this document.
\item [Issue 1.5]
Put in designs for primitive and built-in rules,
derived from \cite{DS/FMU/IED/DTD006}.
Some tidying up.
\item [Issue 1.6]
Changed $suc\_conv$ to fail if given $0$, as in proto-type.
Various changes to error messages, introduced a few new
conversionals.
Primitive and built-in inference rules, and conversionals
all module tested to these designs.
\item [Issue 1.7]
Corrected minor errors.
\item [Issue 1.8]
Split contents between this document,
\cite{DS/FMU/IED/DTD026} and \cite{DS/FMU/IED/DTD027}.
\item [Issue 1.9]
Corrected $if$ rules, added $disch\_rule$, placed set material in \cite{DS/FMU/IED/DTD027},
removed $ƒ\_t\_thm$, added $Œ\_1\_thm$.
\item [1.11]
Renamed $LIST\_THEN\_C$ to $EVERY\_C$ and $LIST\_ORELSE\_C$ to $FIRST\_C$.
Added $COMB\_C$.
\end{description}
\subsection{Changes forecast}
Most of the text outside the documentation boxes is a discussion
of the design process, rather than being part of the final design.
It will thus be removed or rephrased in later issues.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
derived rules of inference.
This is called for in section ??? of ???.
The design is
implemented in \cite{DS/FMU/IED/IMP007}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for some 
derived rules of inference in Release 001 of ICL HOL.
Though other rules of inference will be introduced, this 
document should provide a core set, at least covering the rules
of natural deduction, and providing at least easy access to the functionality
of the rules of inference for the prototype ICL HOL
(other than rewriting)
Studies of this coverage may be found in \cite{DS/FMU/IED/WRK013} and
\cite{DS/FMU/IED/WRK014}.
Rewriting rules will be covered by \cite{DS/FMU/IED/DTD026}
and rules of inference concerning paired abstractions
(rather than simple quantifiers) in \cite{DS/FMU/IED/DTD027}.

The document provides groups of rules of inference, related by their core operator.
Certain inference rules are noted as primitive, or built-in.
This means that their implementation will just be ``sugar'' surrounding a call to an inference rule from \cite{DS/FMU/IED/DTD006}, the new name being formed by stripping off the prefix $icl'$ from the name in \cite{DS/FMU/IED/DTD006}.

All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP007}.

All successful calls of inference rules given in this document,
other than the conversionals, will be profiled
(i.e. a call to $prof$ will be made).
\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.

This document places requirements upon the constants handled by the
inference rules discussed.
In summary, the requirements are that the definitions of the constants must be such that the designs of the rules are satisfiable.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}
\section{INFIX DIRECTIVES}
A Standard ML $infix$ command must be given at the ``top level''.
Thus we give the commands here for those functions declared in the following signatures.
=SML
infix 4 THEN_C;
infix 4 ORELSE_C;
infix 4 FURTHER_C;
infix 4 EITHER_C;
=TEX
(The priorities given are probably not appropriate)
\section{THE DERIVED RULES OF REASONING}
=DOC
signature âDerivedInferenceRulesá = sig
=DESCRIBE
This provides the derived rules of inference in Release 001 of ICL HOL.
Though other rules of inference may be introduced, this 
document's signature should provide a core set, at least covering the common rules
of natural deduction.
It subsumes the inference rules of the abstract data type $THM$.
=FAILURE
6036	Theorem is from deleted theory ?0 (internally theory ?1)
6065	Theorem not valid as it may depend on a deleted axiom or definition of theory ?0
6066	Theorem was created in the context of theory ?0 which is not in scope
6072	Theorems theory, ?0, not properly in current hierarchy	
=ENDDOC
\subsection{Concerning Instantiation}
=DOC
val âinst_term_ruleá : (TERM * TERM) list -> THM -> THM;
=DESCRIBE
Parallel instantiation of term variables within a theorem's conclusion to some other values.
=RULE
inst_term_rule
[..., (»ti¼, »xi¼), ...]
É
ö … t[x1, ..., xn]
É
ö … t[t1, ..., tn]
=TEX
A built-in inference rule.
=FAILURE
6026	Term association list is not of the form: `[..., (»t¼, »x¼), ...]`
	where »x¼ is a variable
6027	Types of element (»t¼, »?0¼) in term association list differ
6028	Instantiation variable ?0 free in assumption list
=ENDDOC
($INST$ in Cambridge HOL)
=DOC
val âinst_type_ruleá : (TYPE * TYPE) list -> THM -> THM;
=DESCRIBE
Parallel instantiation of some of the type variables of the conclusion of a theorem.
=RULE
inst_type_rule
[(þ1, tyv1), ..., (þn,tyvn)]
É
ö … t[tyv1,...tyvn]
É
ö … t[þ1,...þn]
=TEX
$inst\_type\_rule$ $talist$ $thm$ will instantiate each type variable in
$talist$ with its associated type.
It will decorate free variables that would become identified with
other variables (both in conclusion and assumptions)
by their types becoming the same and the names originally being the same.
To instantiate types in the assumption list, see $asm\_inst\_type\_rule$.

A primitive inference rule.
=SEEALSO
$asm\_inst\_type\_rule$ for something that also works
on type variables in the assumption list.
=FAILURE
6006	Trying to instantiate type variable ?0, which occurs in assumption list
6007	Type association list is not of the form: `[...,(»:tyi¼, »:tyvi¼),...]`
	where the »:tyvi¼ are all type-variables
=ENDDOC
($INST\_TYPE$ in Cambridge HOL)

\subsection{Concerning $T$}
$t\_thm$ will be declared in section \ref{theorems}.
=DOC
val â‚_t_introá :  THM -> THM;
=DESCRIBE
The conclusion of a theorem is equal to $T$.
=RULE
‚_t_intro
É
ö … t
É
ö … t ‚ T
=TEX
=ENDDOC
($EQT\_INTRO$ in Cambridge HOL)
An informal justification may be found in \cite{DS/FMU/IED/DTD006}.
=DOC
val â‚_t_elimá :  THM -> THM;
=DESCRIBE
We can always eliminate $\ldots ‚ T$.
=RULE
‚_t_elim
É
ö … t ‚ T
É
ö … t
=TEX
=FAILURE
7106	Theorem not of the form `ö … t ‚ T`
=ENDDOC
($EQT\_ELIM$ in Cambridge HOL)
An informal justification may be found in \cite{DS/FMU/IED/DTD006}.
\subsection{Concerning $F$}
$f\_thm$ will be declared in section \ref{theorems}.
=DOC
val âcontr_ruleá : TERM -> THM -> THM;
=DESCRIBE
Intuitionistic contradiction rule:
=RULE
contr_rule
»t¼
É
ö … F
É
ö … t
=TEX
=FAILURE
7001	Theorem is not of form: `ö … F`
7002	Term is not boolean
=ENDDOC
($CONTR$ in Cambridge HOL)
=DOC
val âc_contr_ruleá : TERM -> THM -> THM;
=DESCRIBE
Classical contradiction rule:
=RULE
c_contr_rule
»t¼
É
ö, Œt … F
É
ö … t
=TEX
Note that the argument is the unnegated form of what must be present 
in the assumption list for success.
Works up to $\alpha$-conversion.
=FAILURE
7002	Term is not boolean
7003	Negation of term is not in assumption list
=ENDDOC
($CCONTR$ in Cambridge HOL)
\subsection{Concerning Negation}
=DOC
val âŒ_introá : TERM -> THM -> THM -> THM;
=DESCRIBE
Given two theorems with contradictory conclusions
(up to $\alpha$-convertibility), their assumptions must be inconsistent, and thus any member of the lists 
(or indeed, anything else)
may be proven false on the assumption of the remainder
(reductio ad absurdum).
=RULE
Œ_intro
»a¼
É
ö1 … b ; ö2 … Œ b
É
(ö1 ¡ ö2) \ {a} … Œ a
=TEX
Works up to $\alpha$-conversion, and input theorems may be
in either order.
=FAILURE
7002	Term is not boolean
7004	Theorems are not of the form: `ö1 … b` and `ö2 … Œ b`
=ENDDOC
=DOC
val âŒ_elimá : TERM -> THM -> THM -> THM;
=DESCRIBE
Given two contradictory theorems with the same assumptions,
conclude any other fact from the assumptions.
=RULE
Œ_elim
»b¼
É
ö1 … a ; ö2 … Œ a
É
ö1 ¡ ö2 … b
=TEX
=FAILURE
7002	Term is not boolean
7060	Theorems are not of the form: `ö … a` and `ö … Œ a`
=ENDDOC
=DOC
val âŒ_Œ_introá : THM -> THM;
=DESCRIBE
We may always introduce a double negation.
=RULE
Œ_Œ_intro
É
ö … t
É
ö … Œ (Œ t)
=TEX
=ENDDOC
=DOC
val âŒ_Œ_elimá : THM -> THM;
=DESCRIBE
A double negation is redundant.
=RULE
Œ_Œ_elim
É
ö … Œ (Œ t)
É
ö … t
=TEX
=FAILURE
7006	Theorem is not of the form: `ö … Œ (Œ t)`
=ENDDOC
=DOC
val âŒ_Œ_convá : CONV;
=DESCRIBE
A double negation is redundant.
=CONVERSION
Œ_Œ_conv
»Œ (Œ t)¼
É
É
ö … Œ (Œ t) = t
=TEX
=FAILURE 
7022	Term is not of the form:»Œ (Œ t)¼
=ENDDOC

\subsection{Concerning €}
=DOC
val â€_introá : THM -> THM -> THM;
=DESCRIBE
Conjoin two theorems.
=RULE
€_intro
É
ö1 … t1; ö2 … t2
É
ö1 ¡ ö2 … t1 € t2
=TEX
=ENDDOC
($CONJ$ in Cambridge HOL)
If we choose eager renaming, we might want to do a check here for
the identification of distinct free variables in the two theorems.
=DOC
val â€_left_elimá : THM -> THM;
=DESCRIBE
Give the left conjunct of a conjunction.
=RULE
€_left_elim
É
ö … t1 € t2
É
ö … t1
=TEX
=FAILURE
7007	Theorem is not of the form: `ö … t1 € t2`
=ENDDOC
($CONJUNCT1$ in Cambridge HOL)
=DOC
val â€_right_elimá : THM -> THM;
=DESCRIBE
Give the right conjunct of a conjunction.
=RULE
€_right_elim
É
ö … t1 € t2
É
ö … t2
=TEX
=FAILURE
7007	Theorem is not of the form: `ö … t1 € t2`
=ENDDOC
($CONJUNCT2$ in Cambridge HOL)
Cambridge HOL has $CONJ\_PAIR$, that returns the pair of theorems
resulting individually from the above two elimination rules.
We choose not to provide this.
=DOC
val âlist_€_introá : THM list -> THM;
=DESCRIBE
Conjoin a list of theorems.
=RULE
list_€_intro 
É
[ö1 … t1, ..., ön … tn]
É
ö1 ¡ ... ön … t1 € ... tn
=TEX
=FAILURE
7107	List may not be empty
=ENDDOC
($LIST\_CONJ$ in Cambridge HOL)
=DOC
val âstrip_€_ruleá : THM -> THM list;
=DESCRIBE
Break a theorem into conjuncts as far as possible.
=RULE
strip_€_rule
É
ö … t
É
[ö … t1, ..., ö … tn]
=TEX
where $t$ can be formed from the $t_i$ by $€\_intro$ alone, with
no duplication, exception or reordering.
=EXAMPLE
strip_€_rule `… (a € b) € (a € c € d)`
=
[`… a`, `… b`, `… a`, `… c`, `… d`]
=ENDDOC
($CONJUNCTS$ in Cambridge HOL)
=DOC
val âŠ_€_ruleá : THM -> THM;
=DESCRIBE
A double implication is equivalent to a conjunction and an 
implication.
=RULE
Š_€_rule
É
ö … a Š b Š c
É
ö … (a € b) Š c
=TEX
=FAILURE
7008	Theorem is not of the form: `ö … a Š b Š c`
=ENDDOC
=DOC
val â€_Š_ruleá : THM -> THM;
=DESCRIBE
Change a conjunction hypothesis into a double implication. 
=RULE
€_Š_rule
É
ö … (a € b) Š c
É
ö … a Š b Š c
=TEX
=FAILURE
7009	Theorem is not of the form: `ö … (a € b) Š c`
=ENDDOC
The above two are from \cite{Manna74}, as derived rules
of inference.

\subsection{Concerning }
=DOC
val â_left_introá : TERM -> THM -> THM;
=DESCRIBE
Introduce a disjunct to the left of a theorem's conclusion.
=RULE
_left_intro
»a¼
É
ö … b
É
ö … a  b
=TEX
=FAILURE
7002	Term is not boolean
=ENDDOC
($DISJ2$ in Cambridge HOL)
=DOC
val â_right_introá : TERM -> THM -> THM;
=DESCRIBE
Introduce a disjunct to the right of a theorem's conclusion.
=RULE
_right_intro
»a¼
É
ö … b
É
ö … b  a
=TEX
=FAILURE
7002	Term is not boolean
=ENDDOC
($DISJ1$ in Cambridge HOL)

=DOC
val â_elimá : THM -> THM -> THM -> THM;
=DESCRIBE
Given a disjunctive theorem, and two further theorems, each 
containing one of the disjuncts in their assumptions, but
with the same conclusion, we may eliminate the disjunct assumption
from the second of the theorems.
=RULE
_elim
É
ö1 … t1  t2
ö2, t1' … t
ö3, t2' … t'
É
ö1 ¡ ö2 ¡ ö3 … t
=TEX
where $t1$ and $t1'$ are $\alpha$-convertible, as are
$t2$ and $t2'$, and $t$ and $t'$.

=FAILURE
7010	First theorem is not of the form: `ö … t1  t2`
7083	Theorems are not of the form: `ö1 … t1  t2`, `ö2, t1' … t3`
	and `ö3, t2' … t3'`, where »t1¼ and »t1'¼, »t2¼ and »t2'¼, 
	»t3¼ and »t3'¼ are each %alpha%-convertible
=ENDDOC
($DISJ\_CASES$ in Cambridge HOL)

=DOC
val â_cancel_ruleá : THM -> THM -> THM;
=DESCRIBE
If we know a disjunction is true, and one of its disjuncts is
false, then the other must be true.
If the second theorem is the negation of both disjuncts,
then the second disjunct will be eliminated.
(modus tollendo ponens)
=RULE
_cancel_rule
É
ö1 … t1  t2; ö2 … Œt1'
É
ö1 ¡ ö2 … t2
=TEX
And:
=RULE
_cancel_rule
É
ö1 … t1  t2; ö2 … Œt2'
É
ö1 ¡ ö2 … t1
=TEX
where $t1'$ and $t1$ are $\alpha$-convertible, as are
$t2$ and $t2'$.
=FAILURE
7010	First theorem is not of the form: `ö … t1  t2`
7050	Theorems are not of the form: `ö1 … t1  t2` and `ö2 … Œt3`
	where »t3¼ is %alpha%-convertible to »t1¼ or »t2¼
=ENDDOC
\subsection{Concerning Š}
=DOC
val âŠ_introá : TERM -> THM -> THM;
=DESCRIBE
Create an implication theorem, removing, if $\alpha$-convertibly present, the hypothesis of the implication from the assumption list.
=RULE
Š_intro
»t1¼
É
ö … t2
É
ö - {t1} … t1 Š t2
=TEX
A primitive inference rule.
=SEEALSO
$disch\_rule$ (which fails if term not in assumption list)
=FAILURE
6009	Term is not boolean
=ENDDOC
($DISCH$ in Cambridge HOL)
=DOC
val âdisch_ruleá : TERM -> THM -> THM;
=DESCRIBE
Create an implication theorem, removing, if $\alpha$-convertibly present, the hypothesis of the implication from the assumption list,
and failing if it is not present.
=RULE
disch_rule
»t1¼
É
ö, t1' … t2
É
ö … t1 Š t2
=TEX
=SEEALSO
$Š\_intro$ (does not fail if term not in assumption list)
=FAILURE
6009	Term is not boolean
7031	Term not %alpha%-convertibly present in assumption list
=ENDDOC
($DISCH$ in Cambridge HOL)
=DOC
val âŠ_elimá : THM -> THM -> THM;
val âŠ_mp_ruleá : THM -> THM -> THM;
=DESCRIBE
Modus Ponens upon an implication
(which is why we introduce the alias $Š\_mp\_rule$,
though $Š\_elim$ is shorter, conventional, and the preferred name).
=RULE
Š_elim
É
ö1 … t1 Š t2; ö2 … t1'
É
ö1 ¡ ö2 … t2
=TEX
where $t1$ and $t1'$ must be $\alpha$-convertible.
A primitive inference rule.
=SEEALSO
$‚\_mp\_rule$(Modus Ponens on $‚$),
$Š\_match\_mp\_rule$ (a ``matching'' version of this function).
=FAILURE
6010	First argument is not of the form: `ö … t1 Š t2`
6011	Theorems are not of the form: `ö1 … t1 Š t2` and `ö2 … t1'` where
	»t1¼ and »t1'¼ are %alpha%-convertible
=ENDDOC
($MP$ in Cambridge HOL)
=DOC
val âsimple_Š_match_mp_ruleá : THM -> THM -> THM ;
=DESCRIBE
A matching Modus Ponens rule for implication.
=RULE
simple_Š_match_mp_rule
É
ö1 … ƒ x1 ... Ž t1 Š t2; ö2 … t1'
É
ö1' ¡ ö2 … t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's hypothesis to match the conclusion of the
second theorem.
Simple universal quantification, or the lack of it, in the first theorem makes no difference to the matching.
=FAILURE
7043	First theorem is not of the form: `ƒ x1 ... Ž t1 Š t2`
	where the »xi¼ are variables
7044	Cannot match the theorems
=ENDDOC
($MATCH\_MP$ in Cambridge HOL)
=DOC
val âundisch_ruleá : THM -> THM ;
=DESCRIBE
Undischarge the hypothesis of an implication into the assumption list.
=RULE
undisch_rule
É
ö … a Š b
É
ö ¡ {a} … b
=TEX
=FAILURE
7011	Theorem is not of the form: `ö … a Š b`
=ENDDOC
($UNDISCH$ in Cambridge HOL)
=DOC
val âstrip_Š_ruleá : THM -> THM;
=DESCRIBE
Repeatedly apply $undisch\_rule$:
=RULE
strip_Š_rule
É
ö … t1 Š ... Š tn Š t
É
ö ¡ {t1, ..., tn} … t
=TEX
=ENDDOC
($UNDISCH\_ALL$ in Cambridge HOL)
=DOC
val âall_Š_introá :THM -> THM;
=DESCRIBE
Discharge all members of assumption list using $Š\_intro$.
=RULE
all_Š_intro
É
{t1, ..., tn} … t
É
… t1 Š ... Š tn Š t
=TEX
=ENDDOC
($DISCH\_ALL$ in Cambridge HOL)
=DOC
val âŠ_trans_ruleá : THM -> THM -> THM;
=DESCRIBE
Transitivity of $Š$.
=RULE
Š_trans_rule
É
ö1 … t1 Š t2; ö2 … t2' Š t3
É
ö1 ¡ ö2 … t1 Š t3
=TEX
where $t2$ and $t2'$ are $\alpha$-convertible.
=FAILURE
7040	First theorem is not of the form: `ö … t1 Š t2`
7041	Second theorem is not of the form: `ö … t1 Š t2`
7042	Theorems are not of the form: `ö1 … t1 Š t2` and `ö2 … t2' Š t3`
	where »t2¼ and »t2'¼ are %alpha%-convertible
=ENDDOC
($IMP\_TRANS$ in Cambridge HOL)
=DOC
val âmodus_tollens_ruleá : THM -> THM -> THM;
=DESCRIBE
If the conclusion of an implication is false, then so must be
the hypothesis (modus tollens).
=RULE
modus_tollens_rule
É
ö1 … t1 Š t2; ö2 … Œt2'
É
ö1 ¡ ö2 … Œt1
=TEX
where $t2$ and $t2'$ are $\alpha$-convertible.
=FAILURE
7040	First theorem is not of the form: `ö … t1 Š t2`
7051	Theorems are not of the form: `ö1 … t1 Š t2` and `ö2 … Œt2'`
	where »t2¼ and »t2'¼ are %alpha%-convertible
=ENDDOC
This might be renamed $mt\_rule$ if we wanted the name shortened.
\subsection{Concerning ‚}
This section is complemented by the inference rules
concerning equality, section \ref{EqualityInference}

=DOC
val â‚_introá : THM -> THM -> THM;
=DESCRIBE
Join two implications into an Iff.
=RULE
‚_intro
É
ö1 … t1 Š t2; ö2 … t1' Š t2'
É
ö1 ¡ ö2 … t1 ‚ t2
=TEX
where $t1$ and $t1'$ are $\alpha$-convertible, as are
$t2$ and $t2'$. 
=FAILURE
7040	First theorem is not of the form: `ö … t1 Š t2`
7041	Second theorem is not of the form: `ö … t1 Š t2`
7064	Theorems are not of the form: `ö … t1 Š t2; ö … t2' Š t1'`
	where »t1¼ and »t1'¼, »t2¼ and »t2'¼, are %alpha%-convertible
=ENDDOC
($CONJ\_IFF$ and $IMP\_ANTISYM\_RULE$ in Cambridge HOL)
=DOC
val â‚_elimá : THM -> (THM * THM);
=DESCRIBE
Split an Iff., into two implications
=RULE
‚_elim
É
ö … t1 ‚ t2
É
ö … t1 Š t2; ö … t2 Š t1
=TEX
=FAILURE
7062	Theorem is not of the form: `ö … t1 ‚ t2`
=ENDDOC
($IFF\_CONJ$ and $EQ\_IMP\_RULE$ in Cambridge HOL)
Perhaps we want to give
$‚\_left\_elim$ and $‚\_right\_elim$ as well,
being no more than $fst\ o\ ‚\_elim$ and $snd\ o\ ‚\_elim$.
=DOC
val â‚_mp_ruleá : THM -> THM -> THM;
=DESCRIBE
Modus Ponens for $‚$.
=RULE
‚_mp_rule
É
ö1 … t1 ‚ t2; ö2 … t1'
É
ö1 ¡ ö2 … t2
=TEX
where $t1$ and $t1'$ must be $\alpha$-convertible.

A built-in inference rule.
=SEEALSO
$Š\_elim$ (Modus Ponens on $Š$),
$‚\_match\_mp\_rule$ (a ``matching'' version of $‚\_mp\_rule$)
=FAILURE
6024	Theorems are not of the form: `ö1 … t1 ‚ t2` and `ö2 … t1'`
	where »t1¼ and »t1'¼ are %alpha%-convertible
6030	First theorem is not of the form: `ö … t1 ‚ t2`
=ENDDOC
($EQ\_MP$ in Cambridge HOL)

=DOC
val âsimple_‚_match_mp_ruleá : THM -> THM -> THM;
=DESCRIBE
A matching Modus Ponens for $‚$.
=RULE
simple_‚_match_mp_rule
É
ö1 … ƒ x1 ... Ž t1 ‚ t2; ö2 … t1'
É
ö1' ¡ ö2 … t2'
=TEX
where we type instantiate, generalise and specialise
to get the first theorem's LHS to match the conclusion of the
second theorem.
Simple universal quantification, or the lack of it, in the first theorem makes no difference to the matching.
=SEEALSO
$Š\_elim$ (Modus Ponens on $Š$)
=FAILURE
7099	First theorem is not of the form: `ƒ x1 ... Ž t1 ‚ t2`
	where the »xi¼ are variables
7044	Cannot match the theorems
=ENDDOC

\subsection{Concerning =}
\label{EqualityInference}
=DOC
val âsubst_ruleá : (THM * TERM) list -> TERM -> THM -> THM;
=DESCRIBE
Substitution of equality theorems according to a template.
=RULE
subst_rule
É
[ö1 … t1=t1', ... , ön … tn=tn']
ö … t[t1,...tn]
É
ö1 ¡ ... ön ¡ ö … t[t1',...tn']
=TEX
$subst\_rule$ $[(thm_1, x_1),\ldots,(thm_n, x_n)]$ $template$ $thm$
returns a theorem in which $template$ determines where in $thm$ the $thm_i$ are substituted.
The $x_i$ must be variables.
The template is of the form $t[x_1,\ldots,x_n]$, and wherever the $x_i$ are free in $template$ their associated equality theorem, $thm_i$,
is substituted into $thm$.
The rule will rename as necessary to avoid bound variable capture.
The assumption list of the resulting theorem will be the union of all
substitution theorems, regardless of use.

The conclusion of the resulting theorem will take its bound variable names
from $template$, not $thm$, as shown in the following example.
This provides an $\alpha$-conversion facility.

The function will usefully partially evaluate with one or two arguments.

A primitive inference rule.
=EXAMPLE
subst_rule [(`… p = q`, »x1¼), (`… r = s`, »x2¼)] 
	(»ƒ y Ž f x1 r y + g x2 p = h y¼)
	(`… ƒ x Ž f p r x + g r p = h x`)
	=
	`… ƒ y Ž f q r y + g s p = h y`
=SEEALSO
$subst\_conv$
=FAILURE
6001	Template term does not substitute to conclusion of theorem
6002	A substitution theorem is not of the form: `ö … t1 = t2` or `ö … t1 ‚ t2`
6003	First argument is not of the form: `[...,(thm1,»x¼),...]` where »x¼ is a variable
6029	First argument is not of the form: `[...,(ö … t1 = t2,»?0¼),...]` 
	where the type of »?0¼ is the same as the type of »t1¼ 
=ENDDOC
($SUBST$ in Cambridge HOL)

=DOC
val âsubst_convá : (THM * TERM) list -> TERM -> CONV;
=DESCRIBE
Substitution of equality theorems according to a template.
=CONVERSION
subst_conv
[...,(`öi … ti=ti'`,»xi¼), ...]
»t[...,xi,...]¼
»t[...,ti,...]¼
É
É
ö1 ¡ ... ön … t[...,ti,...] = t[...,ti',...]
=TEX
or
=CONVERSION
subst_conv
[...,(`öi … ti=ti'`,»xi¼), ...]
»t[...,xi,...]¼
»t[...,ti,...]¼
É
É
ö1 ¡ ... ön … t[...,ti,...] ‚ t[...,ti',...]
=TEX

$subst\_conv$ $[(thm_1, x_1),\ldots,(thm_n, x_n)]$ $template$ $term$
returns a theorem in which $template$ determines where in $term$ the $thm_i$ are substituted, when forming the RHS of the equation.
The $x_i$ must be variables.
The template is of the form $t[x_1,\ldots,x_n]$, and wherever the $x_i$ are free in $template$ their associated equality theorem, $thm_i$,
is substituted into $thm$.
The rule will rename as necessary to avoid bound variable capture.
The assumption list of the resulting theorem will be the union of all
substitution theorems, regardless of use.

The RHS of the resulting theorem will take its bound variable names
from $template$, not $term$, as shown in the following example.
This provides an $\alpha$-conversion facility.

This may partially evaluate with only one argument.
=EXAMPLE
subst_conv [(`… p = q`, »x1¼), (`… r = s`, »x2¼)] 
	(»ƒ y Ž f x1 r y + g x2 p = h y¼)
	(»ƒ x Ž f p r x + g r p = h x¼)
	=
	`… (ƒ x Ž f p r x + g r p = h x) ‚ 
	    ƒ y Ž f q r y + g s p = h y`
=SEEALSO
$subst\_rule$
=FAILURE
7084	Template term does not substitute to term
7085	A substitution theorem is not of the form: `ö … t1 = t2` or `ö … t1 ‚ t2`
7086	First argument is not of the form: `[...,(thm1,»x¼),...]` where »x¼ is a variable
7087	First argument is not of the form: `[...,(ö … t1 = t2,»?0¼),...]` 
	where the type of »?0¼ is the same as the type of »t1¼ 
=ENDDOC
=DOC
val ârefl_convá : CONV;
=DESCRIBE
The reflexivity of equality considered as a conversion.
=RULE
refl_conv
»t¼
É
É
… t = t
=TEX
Or, if $t$ is boolean:
=RULE
refl_conv
»t¼
É
É
… t ‚ t
=TEX
A primitive inference rule.
=ENDDOC
($ALL\_CONV$ and $REFL$ in Cambridge HOL)
=DOC
val âeq_trans_ruleá : THM -> THM -> THM;
=DESCRIBE
Transitivity of equality and $‚$:
=RULE
eq_trans_rule
É
ö1 … t1 = t2; ö2 … t2' = t3
É
ö1 ¡ ö2 … t3
=TEX
And:
=RULE
eq_trans_rule
É
ö1 … t1 ‚ t2; ö2 … t2' ‚ t3
É
ö1 ¡ ö2 … t1 ‚ t3
=TEX
where »t2¼ and »t2'¼ are $\alpha$ convertible.
A built-in inference rule.
=FAILURE
6020	First theorem is not of the form: `ö … t1 = t2` or `ö … t1 ‚ t2`
6021	Second theorem is not of the form: `ö … t1 = t2` or `ö … t1 ‚ t2`
6022	Theorems are not of the form: `ö1 … t1 = t2` and `ö2 … t2' = t3`
	where »t2¼ and »t2'¼ are %alpha%-convertible
=ENDDOC
($TRANS$ in Cambridge HOL)
=DOC
val âeq_sym_ruleá : THM -> THM;
=DESCRIBE
Symmetry of equality and $‚$
=RULE
eq_sym_rule
É
ö … t1 = t2
É
ö … t2 = t1
=TEX
And:
=RULE
eq_sym_rule
É
ö … t1 ‚ t2
É
ö … t2 ‚ t1
=TEX
A built-in inference rule.
=SEEALSO
$eq\_sym\_conv$
=FAILURE
6025	Theorem is not of the form: `ö … t1 = t2` or `ö … t1 ‚ t2`
=ENDDOC
($SYM$ in Cambridge HOL)
=DOC
val âeq_sym_convá : CONV;
=DESCRIBE
Symmetry of equality and $‚$
=RULE
eq_sym_conv
»t1 = t2¼
É
É
… (t1 = t2) ‚ (t2 = t1)
=TEX
And:
=RULE
eq_sym_conv
»t1 ‚ t2¼
É
É
… (t1 ‚ t2) ‚ (t2 ‚ t1)
=TEX
=SEEALSO
$eq\_sym\_rule$
=FAILURE
7090	Term is not of the form: »t1 = t2¼ or »t1 ‚ t2¼
=ENDDOC
($SYM\_CONV$ in Cambridge HOL)
=DOC
val âŒ_eq_sym_ruleá : THM -> THM ;
=DESCRIBE
If $a$ is not equal to $b$ then $b$ is not equal to $a$.
=RULE
Œ_eq_sym_rule
É
ö … Œ(a = b)
É
ö … Œ(b = a)
=TEX
and
=RULE
Œ_eq_sym_rule
É
ö … Œ(a ‚ b)
É
ö … Œ(b ‚ a)
=TEX
=FAILURE
7091	Theorem is not of form: `ö … Œ(a = b)` or `ö … Œ(a ‚ b)`
=ENDDOC
($NOT\_EQ\_SYM$ in Cambridge HOL)
=DOC
val âsimple_eq_match_convá : THM -> CONV ;
=DESCRIBE
This matches the LHS of an equation to a term,
instantiating the RHS accordingly.
The equation may be partially or fully universally quantified
(simple quantification only),
without affecting the result of the conversion.
=CONVERSION
simple_eq_match_conv
(ö … ƒ ... Ž u = v)
»t¼
É
É
ö' … t = v'
=TEX
and
=CONVERSION
simple_eq_match_conv
(ö … ƒ ... Ž u ‚ v)
»t¼
É
É
ö' … t ‚ v'
=TEX
where $v'$ is the result of applying to $v$ the instantiation rules required to match $u$ to $t$
(including both term and type instantiation).
If there are free variables on the RHS of the supplied equation (when stripped of all universal quantification)
they will be renamed as necessary to avoid identification with
any variables in $t$.
=FAILURE
7095	Theorem is not of the form `ö … ƒ x1 ... xn Ž u = v`
	where »xi¼ are variables
7076	Could not match term to LHS of theorem
=ENDDOC
($REWRITE\_CONV$ in Cambridge HOL)
The process of renaming to avoid identification is a minimum requirement on free variables on the RHS.
More powerful requirements (e.g. something like Cambridge HOL's $genvar$) could be appropriate.
=DOC
val âsimple_eq_match_1_convá : THM -> CONV ;
=DESCRIBE
This matches the LHS of an universally quantified (simple quantifiers only) equation to a term,
instantiating the RHS accordingly.
The conversion will only instantiate its universal quantifications,
and type variables not present in the assumptions, 
and not its free term variables.
=CONVERSION
simple_eq_match_1_conv
(ö … ƒ x1 ... xn Ž u[x1,...,xn] = 
   v[x1,...,xn])
»t¼
É
É
ö … t = v[t1,...,tn]
=TEX
and
=RULE
simple_eq_match_1_conv
(ö … ƒ x1 ... xn Ž u[x1,...,xn] ‚ 
   v[x1,...,xn])
»t¼
É
É
ö' … t = v[t1,...,tn]
=TEX
where »u[t1,...,tn]¼ is $\alpha$-convertible to »t¼.
If there are free variables on the RHS of the supplied equation (when stripped of all universal quantification)
they will be renamed as necessary to avoid identification with
any variables in $t$.

This conversion may be partially evaluated with only its theorem argument.
=USES
In producing a limited rewriting facility, that only instantiates
explicitly identified variables.
=FAILURE
7095	Theorem is not of the form `ö … ƒ x1 ... xn Ž u = v`
	where »xi¼ are variables
7076	Could not match term to LHS of theorem
=ENDDOC
An alternative method of indicating what may be instantiated 
is to give a ``forbidden list'' of variables that may not be instantiated,
whether they be universally quantified or free in the original theorem.
This could of course be a ``only modify'' list instead.

As this is calculated once per application of $eq\_match\_1_conv$ to a theorem, and not once per application to a term, it is not 
a major potential time-saver either way.
What this function must be fast at is its application to a term.

We may want a specialised $term\_match$ function that understands
a ``forbidden list'' of variables that it may not modify.

We might also want some way of matching, such that free variables in the assumption list are also instantiated. This would work best with a ``forbidden list'' style, rather than a style that only
allows the universally quantified variables to be instantiated.
This question is particularly important if we want the possibility
of clever assumption introduction mechanisms during rewriting,
especially those involved in rewriting with implications.
\subsection{Concerning $if\ldots then\ldots else \ldots$}

=DOC
val âif_introá : TERM -> THM -> THM -> THM;
=DESCRIBE
Introduce a conditional, based on the assumptions of two theorems.
=RULE
if_intro
»a¼
É
ö1, a … x = tt ;  ö2, Œa' … x = et
É
ö1 ¡ ö2 … x = if a then tt else et
=TEX
where $a$ and $a'$ are $\alpha$-convertible.
=FAILURE
7002	Term is not boolean
7065	Theorems are not of the form: `ö1, a … x = tt` and  `ö2, Œa' … x = et`
	where »a¼ and »a'¼ are %alpha%-convertible
7005	Term is not in assumption list
=ENDDOC
Perhaps the theorems could be in either order, the rule working out
which.
=DOC
val âif_then_elimá : THM -> THM;
=DESCRIBE
Give the dependence of the $then$ branch of a conditional
upon the condition.
=RULE
if_then_elim
É
ö … x = if tc then tt else te
É
ö … tc Š x = tt
=TEX
=FAILURE
7012	Theorem is not of the form: `ö … x = if tc then tt else te`
=ENDDOC
=DOC
val âif_else_elimá : THM -> THM;
=DESCRIBE
Give the dependence of the $else$ branch of a conditional
upon the condition.
=RULE
if_else_elim
É
ö … x = if tc then tt else te
É
ö … Œ tc Š x = te
=TEX
=FAILURE
7012	Theorem is not of the form: `ö … x = if tc then tt else te`
=ENDDOC

As the ICL HOL conditional on booleans is the same as that on other
types,  we choose a different presentation to \cite{Manna74},
where this is not true.
However, Manna's rules for conditionals on other types can be derived from those present here, and vice versa.
=DOC
val âif_fun_ruleá : THM -> THM;
=DESCRIBE
Move a function application out of a conditional.
=RULE
if_fun_rule
É
ö … if a then f' b else f'' c
É
ö … f' (if a then b else c)
=TEX
where $f$, $f'$ and $f''$ are $\alpha$-convertible.
=FAILURE
7038	Theorem is not of the form: `ö … if tc then tt else te`
7052	Theorem is not of the form: `ö … if a then f b else f' c`
	where term argument, »f¼ and »f'¼ are %alpha%-convertible
=ENDDOC
=DOC
val âfun_if_ruleá : THM -> THM;
=DESCRIBE
Move a function application into a conditional.
=RULE
if_fun_rule
É
ö … f(if a then b else c)
É
ö … if a then f b else f c
=TEX
=FAILURE
7053	Theorem is not of the form: `ö … f(if a then b else c)`
=ENDDOC
=DOC
val âfun_if_convá : CONV;
=DESCRIBE
Move a function application into a conditional.
=CONVERSION
fun_if_conv
»f(if a then b else c)¼
É
É
… f(if a then b else c) = 
	(if a then f b else f c)
=TEX
=FAILURE
7098	Term is not of the form: »f(if a then b else c)¼
=ENDDOC

\subsection{Concerning }
=DOC
val âsimple_%beta%_convá : CONV;
=DESCRIBE
Apply a $\beta$-reduction to a simple abstraction.
=CONVERSION
simple_%beta%_conv
»( x Ž t1[x]) t2¼
É
É
… ( x Ž t1[x]) t2 = t1[t2]
=TEX
Or, if the term is of type $BOOL$:
=CONVERSION
simple_%beta%_conv
»( x Ž t1[x]) t2¼
É
É
… ( x Ž t1[x]) t2 ‚ t1[t2]
=TEX
A primitive inference rule.
=SEEALSO
$\beta\_conv$
=FAILURE
6012	Term is not of the form: »( x Ž t1[x])t2¼ where »x¼ is a variable
=ENDDOC
($BETA\_CONV$ in Cambridge HOL)
=DOC
val âsimple_abs_ruleá : TERM -> THM -> THM;
=DESCRIBE
Given an equality theorem, return the equation formed by abstracting the term argument (which must be a variable) from both sides.
=RULE
simple_abs_rule
»x¼
É
ö … t1[x] = t2[x]
É
ö … ( x Ž t1[x]) = ( x Ž t2[x])
=TEX
And:
=RULE
simple_abs_rule
»x¼
É
ö … t1[x] ‚ t2[x]
É
ö … ( x Ž t1[x]) = ( x Ž t2[x])
=TEX
A primitive inference rule.
=SEEALSO
$abs\_conv$, $abs\_rule$
=FAILURE
6004	Term is not a variable
6005	?0 occurs free in assumption list
6025	Theorem is not of the form: `ö … t1 = t2` or `ö … t1 ‚ t2`
=ENDDOC
($ABS$ in Cambridge HOL)
=DOC
val â_ruleá : TERM -> THM -> THM;
=DESCRIBE
An introduction rule for $$:
=RULE
_rule
»t¼
É
ö … s[t]
É
ö … ( x Ž s[x]) t
=TEX
where $x$ is a machine generated variable.
=ENDDOC
=DOC
val âall_simple_%beta%_convá : CONV;
=DESCRIBE
A conversion to eliminate all instances of simple $\beta$ redexes in a term, regardless of nesting, or even that the $\beta$ redex was created as the result of
an earlier reduction in the conversion's evaluation.
=RULE
all_simple_%beta%_conv
»t¼
É
É
… t = t'
=TEX
$t'$ is $t$ with all simple $\beta$ redexes reduced.
=USES
This uses an optimised term traversal algorithm, superior in speed
to the general term traversal algorithms used with conversions,
and should be used in preference to them and $\beta\_conv$.
=FAILURE
7020	Term contains no %beta%-redexes	
=ENDDOC
=DOC
val âall_simple_%beta%_ruleá : THM -> THM;
=DESCRIBE
Eliminate all instances of simple $\beta$ redexes in a theorem, regardless of nesting, or even that the $\beta$ redex was created as the result of
an earlier reduction in the rule's evaluation.
=RULE
all_simple_%beta%_rule
É
ö … t
É
ö … t'
=TEX
$t'$ is $t$ with all $\beta$-redexes reduced.
=FAILURE
7021	Theorem contains no %beta%-redexes
=ENDDOC
($BETA\_RULE$ in Cambridge HOL)

\subsection{Concerning ƒ}
=DOC
val âsimple_ƒ_introá : TERM -> THM -> THM;
=DESCRIBE
Introduce a simple universal quantification.
=RULE
simple_ƒ_intro
»x¼
É
ö … t
É
ö … ƒ x Ž t
=TEX
A built-in inference rule.
=SEEALSO
$ƒ\_intro$
=FAILURE
6004	Term is not a variable
6005	?0 occurs free in assumption list
=ENDDOC
($GEN$ in Cambridge HOL)
=DOC
val âsimple_ƒ_elimá : TERM -> THM -> THM;
=DESCRIBE
Instantiate a universally quantified variable to a given value.
=RULE
simple_ƒ_elim
»t1¼
É
ö … ƒ x Ž t2[x]
É
ö … t2'[t1]
=TEX
where $t2'$ is renamed from $t2$ to prevent bound variable capture,
and $x$ is a variable.
=FAILURE
7039	Theorem is not of the form: `ö … ƒ x Ž t` where »x¼ is a variable
7046	Theorem is not of the form: `ö … ƒ ?0 Ž t` where the type of »?0¼ 
	is the type of the term argument
=ENDDOC
($SPEC$ in Cambridge HOL)
=DOC
val âsimple_list_ƒ_introá : TERM list -> THM -> THM;
=DESCRIBE
Generalised simple $ƒ$ introduction.
=RULE
simple_list_ƒ_intro
[»x1¼, ..., »xn¼]
É
ö … t[x1, ..., xn]
É
ö … ƒ x1 ... xn Ž t[x1, ..., xn]
=TEX
=SEEALSO
$ƒ\_intro$
=FAILUREC
\paragraph{Errors}
Same messages as $simple\_ƒ\_intro$.
=ENDDOC
($GENL$ in Cambridge HOL)
=DOC
val âsimple_list_ƒ_elimá : TERM list -> THM -> THM;
=DESCRIBE
Generalised $ƒ$ elimination.
=RULE
simple_list_ƒ_elim
[»t1¼, ..., »tn¼]
É
ö … ƒ x1 ... xn Ž t[x1, ..., xn]
É
t[t1, ..., tn]
=TEX
A built-in inference rule.
=SEEALSO
$ƒ\_elim$
=FAILURE
6018	Theorem is not of the form: `ö … ƒ ...xi... Ž t` where 
	the »xi¼ are ?0 variables
6019	Theorem is not of the form: `ö … ƒ ...xi... Ž t` where the types of ?0 
	equal the types of the corresponding term arguments
=ENDDOC
($SPECL$ in Cambridge HOL)
=DOC
val âall_ƒ_introá : THM -> THM;
=DESCRIBE
Generalises all the free variables (otherthan those in the assumption list) in a theorem:
=RULE
all_ƒ_intro
É
ö … t
É
ö … ƒ x1 ... xn Ž t
=TEX
where $x1, \ldots, xn$ are all the free variables of $t$.
=ENDDOC
($GEN\_ALL$ in Cambridge HOL)
=DOC
val âall_simple_ƒ_elimá : THM -> THM;
=DESCRIBE
Specialises all the simple universally quantified variables in a theorem:
=RULE
all_ƒ_elim
É
ö … ƒ x1 ... xn Ž t[x1, ..., xn]
É
ö … t[x1', ..., xn']
=TEX
where $x1', \ldots, xn'$ are renamed from $x1, \ldots, xn$ as necessary to avoid clashes with
free variables in the assumption list.
=ENDDOC
($GEN\_ALL$ in Cambridge HOL)
=DOC
val âsimple_Œ_ƒ_convá : CONV;
=DESCRIBE
Move $Œ$ into a $ƒ$ construct.
=RULE
simple_Œ_ƒ_conv
»Œ (ƒ x Ž t[x])¼
É
É
… (Œ (ƒ x Ž t[x])) ‚ „ x Ž Œ t[x]
=TEX
This will work with any simple universal quantifier.
=FAILURE
7036	Term not of the form: »Œ (ƒ x Ž t[x])¼
=ENDDOC
($NOT\_FORALL\_CONV$ in Cambridge HOL)
We do not give a rule for $ƒƒ$ introduction from \cite{Manna74}.
\subsection{Concerning „}
=DOC
val âsimple_„_introá : TERM -> THM -> THM ;
=DESCRIBE
Introduce an existential quantifier by reference to a witness.
=RULE
simple_„_intro
»„ x Ž t1[x]¼
É
ö … t1[t2]
É
ö … „ x Ž t1[x]
=TEX
where »x¼ is a variable.
=FAILURE
7094	Term is not of the form: »„ x Ž t1[x]¼ where »x¼ is a variable
7047	Term cannot be matched to conclusion of theorem
=ENDDOC
($EXISTS$ in Cambridge HOL)
In Cambridge HOL you give $t2$ (i.e. the witness that satisfies the predicate) as another argument, though this
seems only to speed the correctness check, as it may be
derived via $term\_match$.
=DOC
val âsimple_„_elimá : TERM -> THM -> THM -> THM ;
=DESCRIBE
Eliminate an existential quantifier by reference to an arbitrary variable structure satisfying the predicate.
=RULE
simple_„_elim
»t1[y]¼
É
ö1 … „ x Ž t1[x]; ö2, t1[y] … t2
É
ö1 ¡ ö2 … t2
=TEX
where $x$ and $y$ must be variables, and $y$ not present elsewhere in the theorems.
=FAILURE
7002	Term is not boolean
7013	Term is not in assumption list of second theorem
7014	Cannot match term to conclusion of first theorem and gain a variable structure
7109	First theorem is not of the form `ö … „ x Ž t[x]`
=ENDDOC
($CHOOSE$ in Cambridge HOL)
=DOC
val âsimple_Œ_„_convá : CONV;
=DESCRIBE
Move $Œ$ into an $„$ construct.
=RULE
simple_Œ_„_conv
»Œ („ x Ž t[x])¼
É
É
… (Œ („ x Ž t[x])) ‚ ƒ x Ž Œ t[x]
=TEX
This will work with any simple existential quantifier.
=FAILURE
7058	Term is not of the form: »Œ („ x Ž t[x])¼
	where »x¼ is a variable
=ENDDOC
($NOT\_EXISTS\_CONV$ in Cambridge HOL)
We do not give a rule for $„„$ introduction from \cite{Manna74}.
\subsection{Concerning „$_1$}
=DOC
val âsimple_„%down%1_introá : THM -> THM -> THM;
=DESCRIBE
Introduce $„_1$ by reference to a witness, and a uniqueness theorem.
=RULE
simple_„%down%1_intro
É
ö1 … P'[t']
ö2 … ƒ x Ž P[x] Š x = t
É
ö1 ¡ ö2 … „%down%1 x Ž P[x]
=TEX
Where $P'$ is $\alpha$-convertible to $P$, and
$t'$ is $\alpha$-convertible to $t$.
Notice that for the resulting theorem we take the bound variable name, $x$, and the form of the predicate, $P$, from the second theorem.
=FAILURE
7067	Theorems are not of the form: `ö1 … Pa[ta]` and `ö2 … ƒ x Ž P[x] Š x = t`
	where »Pa¼ and »P¼, »ta¼ and »t¼ are %alpha%-convertible
=ENDDOC
=DOC
val âsimple_„%down%1_elimá : THM -> THM;
=DESCRIBE
Express a $„_1$ in terms of $„$ and a uniqueness property.
=RULE
simple_„%down%1_elim
É
ö … „%down%1 x Ž P[x]
É
ö … „ x Ž P[x] € ƒ y Ž P[y] Š y = x
=TEX
=FAILURE
7015	Theorem is not of the form: `ö … „%down%1 x Ž P[x]`
=ENDDOC
This could be rewritten to produce two theorems,
`$„\ x\ Ž\ P[x]$` and `$ƒ\ x\ y\ Ž\ P[x]\ €\ P[y]\ Š\ x\ =\ y$`
\subsection{Concerning ‡}
=DOC
val â‡_intro_ruleá : THM -> THM;
=DESCRIBE
Given a theorem whose conclusion is a function application,
we know that the ``function'' is a predicate, and the rule states that
$‡$ of this predicate will satisfy the predicate.
=RULE
‡_intro_rule
É
ö … t1 t2
É
ö … t1 (‡ t1)
=TEX
=FAILURE
7016	Theorem is not of the form: `ö … t1 t2`
=ENDDOC
($SELECT\_INTRO$ in Cambridge HOL)
$‡$ is not part of natural deduction so the rule cannot really be suffixed by just $\_intro$.
We might want an introduction function that requires a template $t1[x]$ and $x$, and a theorem of the form
`$… t1 [t2]$`,
rather than the above more limited form.
=DOC
val â‡_elim_ruleá : TERM -> THM -> THM -> THM;
=DESCRIBE
Given that $‡$ of a predicate satisfies that predicate, then
in a different theorem we may eliminate an assumption that 
claims an otherwise unused variable satisfies the predicate.
=RULE
‡_elim_rule
»x¼
É
ö1 … t' (‡ t'');
ö2, t x … s
É
ö1 ¡ ö2 … s
=TEX
where $t$, $t'$ and $t''$ are $\alpha$-convertible, and $x$ is a free variable occurring nowhere else in the theorems
other than shown.
=FAILURE
7017	Term is not a variable
7108	Arguments not of the form »?0¼, `ö1 … t (‡ t)` and
	`ö2, t ?0 … s` where »t ?0¼ is not in assumption list
	of second theorem
7018	?0 found free elsewhere in theorems
7019	First theorem is not of the form: `ö … t1(‡ t1)`
=ENDDOC
($SELECT\_ELIM$ in Cambridge HOL)
As with the introduction rule, we might want a more general interface.
=DOC
val âsimple_„_‡_ruleá : THM -> THM;
=DESCRIBE
Give that $‡$ of a predicate satisfies the predicate by reference to an $„$ construct.
It can properly handle paired existence.
=RULE
simple_„_‡_rule
É
ö … „ x Ž p[x]
É
ö … p[‡ x Ž p x]
=TEX
=SEEALSO
$„\_‡\_conv$
=FAILURE
7092	Theorem is not of the form: `ö … „ x Ž p[x]`
=ENDDOC
($SELECT\_RULE$ in Cambridge HOL)
=DOC
val âsimple_„_‡_convá : CONV;
=DESCRIBE
Give that $‡$ of a predicate satisfies the predicate by reference to an $„$ construct.
=RULE
simple_„_‡_conv
»„ x Ž p[x]¼
É
É
ö … („ x Ž p[x]) = p[‡ x Ž p [x]]
=TEX
=SEEALSO
$„\_‡\_rule$
=FAILURE
7093	Term is not of the form: »„ x Ž p[x]¼
=ENDDOC

\subsection{Concerning Functional Application}
=DOC
val âmk_comb_ruleá : THM -> THM -> THM;
=DESCRIBE
Given two equations, one being of two functions, apply the two functions
to the LHS and RHS of the other equation.
=RULE
mk_comb_rule
É
ö1 … u1 = u2; ö2 … v1 = v2
É
ö1 ¡ ö2 … u1 v1 = u2 v2
=TEX
The second input theorem or the result may be expressed using $‚$.

A built-in inference rule.
=FAILURE
6020	First theorem is not of the form: `ö … t1 = t2` or `ö … t1 ‚ t2`
6021	Second theorem is not of the form: `ö … t1 = t2` or `ö … t1 ‚ t2`
6023	Theorems are not of the form `ö1 … u1 = u2` and `ö2 … v1 = v2`
	where »u1¼ can be functionally applied to »v1¼
=ENDDOC
($MK\_COMB$ in Cambridge HOL)
We might later want a variant of $mk\_comb\_rule$ that prevents the
identification of free variables in the two theorems.
=DOC
val âap_fun_ruleá : TERM -> THM -> THM ;
=DESCRIBE
Apply a function to both sides of an equation.
=RULE
ap_fun_rule
»f¼
É
ö … a = b
É
ö … f a = f b
=TEX
Or:
=RULE
ap_fun_rule
»f¼
É
ö … a = b
É
ö … f a ‚ f b
=TEX
=FAILURE
7023	Theorem is not of the form: `ö … t1 = t2` or `ö … t1 ‚ t2`
7024	Term may not be applied to each side of equation
=ENDDOC
($AP\_TERM$ in Cambridge HOL)
=DOC
val âap_arg_ruleá : TERM -> THM -> THM;
=DESCRIBE
Apply both sides of an equation to an argument.
=RULE
ap_arg_rule
»x¼
É
ö … f = g
É
ö … f x = g x
=TEX
Or:
=RULE
ap_arg_rule
»x¼
É
ö … f = g
É
ö … f x ‚ g x
=TEX
=FAILURE
7023	Theorem is not of the form: `ö … t1 = t2` or `ö … t1 ‚ t2`
7025	Sides of equation may not be applied to term
=ENDDOC
($AP\_THM$ in Cambridge HOL)
=DOC
val âext_ruleá : THM -> THM;
=DESCRIBE
Extensionality of functions in ICL HOL.
=RULE
ext_rule
É
ö … f = g
É
ö … ƒ x Ž f x = g x
=TEX
Or:
=RULE
ext_rule
É
ö … f = g
É
ö … ƒ x Ž f x ‚ g x
=TEX
where $x$ is a machine-generated variable of appropriate type,
not found free in the equation.
=FAILURE
7023	Theorem is not of the form: `ö … t1 = t2` or `ö … t1 ‚ t2`
7026	Theorem is not an equation of functions
=ENDDOC
($EXT$ in Cambridge HOL)
\subsection{Concerning Assumptions}
=DOC
val âasm_ruleá : TERM -> THM;
=DESCRIBE
A term is true on the assumption that it is true.
=RULE
asm_rule
»t¼
É
É
t … t
=TEX
A primitive inference rule.
=FAILURE
6009	Term is not boolean
=ENDDOC
($ASSUME$ in Cambridge HOL)
=DOC
val âasm_introá : TERM -> THM -> THM;
=DESCRIBE
Introduce a new assumption to an existing theorem.
=RULE
asm_intro
»t1¼
É
ö … t2
É
ö ¡ {t1} … t2
=TEX
=FAILURE
7002	Term is not boolean
=ENDDOC
($ADD\_ASSUM$ in Cambridge HOL)
=DOC
val âasm_elimá : TERM -> THM -> THM -> THM;
=DESCRIBE
Eliminate an assumption with reference to contradictory assumption lists.
=RULE
asm_elim
»a¼
É
ö1, a' … t; ö2, Œa''  … t'
É
ö1 ¡ ö2 … t
=TEX
where $a$, $a'$ and $a''$,
as well as $t$ and $t'$ are $\alpha$-convertible.
=FAILURE
7002	Term is not boolean
7027	Term is not in assumption list of first theorem
7028	Negation of term is not in assumption list of second theorem
7029	Theorems are not of the form:`ö1, a' … t` and `ö2, Œa''  … ta`
	where »t¼ and »ta¼ are %alpha%-convertible
=ENDDOC
=DOC
val âprove_asm_ruleá : THM -> THM -> THM;
=DESCRIBE
Eliminate an assumption with reference to a the assumption being a conclusion of a theorem.
=RULE
prove_asm_rule
É
ö1 … t1; ö2, t1 … t2
É
ö1 ¡ ö2 … t2
=TEX
=FAILURE
7037	Theorems not of form `ö1 … t1` and `ö2, t1a … t2`
	where »t1¼ and »t1a¼ are %alpha%-convertible
=ENDDOC
($PROVE\_HYP$ in Cambridge HOL)
This could easily be a (the?) assumption elimination rule, though \cite{Manna74} doesn't so use it.
=DOC
val âasm_inst_type_ruleá : (TYPE * TYPE) list -> THM -> THM;
=DESCRIBE
Parallel instantiation of some of the type variables of both the conclusion and assumptions of a theorem.
=RULE
asm_inst_type_rule
[(þ1, tv1), ..., (þn,tvn)]
É
ö … t[tv1,...tvn]
É
ö' … t[þ1,...þn]
=TEX
$asm\_inst\_type\_rule$ $talist$ $thm$ will instantiate each type variable in
$talist$ with its associated type.
It will decorate free variables that would become identified with
other variables by their types becoming the same and the names originally being the same.
$\alpha$-convertible duplicate assumptions will be eliminated.
=SEEALSO
$inst\_type\_rule$
=FAILURE
7068	Type association list is not of the form: `[...,(»:tyi¼, »:tyvi¼),...]`
	where the »:tyvi¼ are all type-variables
=ENDDOC
\subsection{Concerning $\alpha$-conversion}
=DOC
val â%alpha%_convá : TERM -> CONV;
=DESCRIBE
Returns a theorem that two terms are equal, should they be
$\alpha$-convertible.
=RULE
%alpha%_conv
»t2¼
»t1¼
É
É
… t1 = t2
=TEX
=FAILURE
7033	Terms are not of same type
7034	Terms are not %alpha%-convertible
=ENDDOC
($ALPHA$ in Cambridge HOL)
=DOC
val âsimple_%alpha%_convá : string -> CONV;
=DESCRIBE
Rename a bound variable name, as a conversion.
This only works with simple abstractions.
=RULE
simple_%alpha%_conv
(v : string)
» x Ž t[x]¼
É
É
… ( x Ž t[x]) = ( v Ž t[v])
=TEX
=FAILURE
7030	Term is not of the form: » x Ž t[x]¼
	where »x¼ is a variable
7035	Cannot rename bound variable to ?0 as this would cause variable capture
=ENDDOC
($ALPHA\_CONV$ in Cambridge HOL)
\subsection{Concerning Numbers, Characters and Strings}
=DOC
val âsuc_convá : CONV;
=DESCRIBE
This function defines the meaning of the constants with names consisting only of decimal digits, and type $NUM$.
=RULE
suc_conv
(mk_† (m+1))
É
É
… ^(mk_†(m+1)) = Suc ^(mk_† m)
=TEX
The conversion fails if given $0$.

A primitive inference rule(axiom schemata), except that it
fails on $0$.
=FAILURE
6013	Term is not a literal numeric constant
7100	Term must be literal numeric constant > 0
=SEEALSO
$mk\_†$
=ENDDOC
($num\_CONV$ in Cambridge HOL)
=DOC
val âstring_convá : CONV;
=SYNOPSIS
This function defines the meaning of the constants with name starting with $"$, and type $STRING$
(an abbreviation of $CHAR\ LIST$).
=DESCRIBE
A literal string constant is indicated by the constant's name starting with a double quote($"$), as well as being of type $STRING$.
This is equivalent to a list of literal character constants,
one for each but the first ($"$) character of the string constant's name.
This conversion defines this relationship, by returning the head and unexploded tail of the list of characters.
A literal character constant is indicated by the constant's name starting with single quote ($'$), as well as being of type $CHAR$.
=RULE
string_conv
(mk_string ("c..."))
É
É
… ^(mk_string("c...")) = 
Cons ^(mk_char("c")) ^(mk_string("..."))
=TEX
Or:
=RULE
string_conv
(mk_string "")
É
É
… ^(mk_string("")) = Nil
=TEX
A primitive inference rule(axiom schemata).
=SEEALSO
$mk\_string$
=FAILURE
6014	Term is not a literal string constant
=ENDDOC
=DOC
val âchar_convá : CONV;
=DESCRIBE
This function gives a relationship between literal character constants and their ASCII code (derived by the Standard ML function $ord$).
A literal character constant is indicated by the constant's name starting with single quote ($'$), as well as being of type $CHAR$.
=RULE
char_conv
(mk_char("c"))
É
É
… ^(mk_char("c")) = AbsChar ^(ord "c")
=TEX
A primitive inference rule(axiom schemata).
=SEEALSO
$mk\_char$
=FAILURE
6015	Term is not a literal character constant
=ENDDOC
=DOC
val âdiv2_convá : CONV;
=DESCRIBE
Provides the value of $Div\ 2$ of a natural number.
=RULE
div2_conv
»^(mk_† n) Div 2¼
É
É
… ^(mk_† n) Div 2 = ^(mk_†(n div 2))
=TEX
A built-in inference rule.
=USES
For doing fast arithmetic proofs.
=FAILURE
6085	Term is not of the form »^(mk_† n) Div 2¼
=ENDDOC
=DOC
val âmod2_convá : CONV;
=DESCRIBE
Provides the value of $Mod\ 2$ of a natural number.
=RULE
mod2_conv
»(mk_† n) Mod 2¼
É
É
… ^(mk_† n) Mod 2 = ^(mk_†(n mod 2))
=TEX
A built-in inference rule.
=USES
For doing fast arithmetic proofs.
=FAILURE
6086	Term is not of the form »^(mk_† n) Mod 2¼
=ENDDOC

\subsection{Concerning Conversions}
\subsubsection{Building Blocks}
=DOC
val âfail_convá : CONV;
=DESCRIBE
This conversion always fails.
=FAILURE
7061	Failed as requested
=ENDDOC
($NO\_CONV$ in Cambridge HOL)
=DOC
val âfail_with_convá : string -> CONV;
=DESCRIBE
This conversion always fails, with the error message being its string
argument.
=FAILURE
7075	?0
=ENDDOC
($FAIL\_CONV$ in Cambridge HOL)
\subsubsection{Conversionals}
=DOC
val âTHEN_Cá : (CONV * CONV) -> CONV;
=DESCRIBE
Combine the effect of two successful conversions.
=RULE
(c1: CONV) THEN_C (c2: CONV)
»t¼
É
É
ö … t = t'''
=TEX
where $c1\ t$ returns `$ö1 … t = t'$`, $c2\ t'$ returns
`$ö2 … t'' = t'''$`, $t'$ and $t''$ are $\alpha$-convertible and
$ö$ equals $ö1 ¡ ö2$.
=SEEALSO
$EVERY\_C$(the iterated version of this function), $FURTHER\_C$, $EITHER\_C$, $ORELSE\_C$
=FAILURE
7101	Result of first conversion not an equality
7102	LHS (if any) of result of second conversion not 
	%alpha%-convertible to RHS of first
=FAILUREC
\paragraph{Errors}
If any, as the failures of $c1$ and $c2$ applied to $t$ and $t'$ respectively.
=ENDDOC
($THENC$ in Cambridge HOL)
=DOC
val âFURTHER_Cá : (CONV * CONV) -> CONV;
=DESCRIBE
Combine the effect of two conversions, ignoring the failure
of the second if necessary.
That is, if the first conversion results in an equation
whose RHS can have the second conversion applied,
and the two resulting theorems composed,
then that composition;
otherwise the result of the first conversion alone is returned.
=SEEALSO
$THEN\_C$, $EITHER\_C$, $ORELSE\_C$
=FAILUREC
\paragraph{Errors}
As the failure of $c1$.
=ENDDOC

=DOC
val âORELSE_Cá : (CONV * CONV) -> CONV;
=DESCRIBE
Attempt to apply one conversion, and if that fails, try the second one.
=RULE
(c1: CONV) ORELSE_C (c2: CONV)
»t¼
É
É
ö … t = t'
=TEX
where $c1\ t$ returns $ö … t = t'$, or $c1$ fails, and
$c2\ t$ returns
$ö … t = t'$.
=SEEALSO
$FIRST\_C$(the iterated version of this function), $THEN\_C$, $EITHER\_C$, $FURTHER\_C$
=FAILUREC
\paragraph{Errors}
As the failure of second conversion, should both conversions fail.
=ENDDOC
($ORELSEC$ in Cambridge HOL)
=DOC
val âEITHER_Cá : (CONV * CONV) -> CONV;
=DESCRIBE
$c1\ EITHER\_C\ c2$ will succeed if it can apply
one or both of $c1$ or $c2$.
If it cannot compose the results of applying both
conversions successfully (indicating an ill-formed conversion result)
it will return the result of the first conversion application.
=SEEALSO
$FURTHER\_C$, $ORELSE\_C$, $THEN\_C$
=FAILUREC
\paragraph{Errors}

As the failure message of the second conversion
(implying that neither conversion was successfully applied).
=ENDDOC
=DOC
val âREPEAT_Cá : CONV -> CONV;
=DESCRIBE
Repeatedly apply a conversion to a term.
To be more precise, the functionality will be equivalent that of the following definition:
ó
fun REPEAT_C (c:CONV) = 
	(c THEN_C (REPEAT_C c)) ORELSE_C refl_conv
æ
=SEEALSO
$REPEAT1\_C$
=ENDDOC
($REPEATC$ in Cambridge HOL)
=DOC
val âREPEAT1_Cá : CONV -> CONV;
=DESCRIBE
Repeatedly apply a conversion to a term,
failing if not successfully applied at least once.
To be more precise, the functionality will be equivalent that of the following definition:
ó
fun REPEAT1_C (c:CONV) = (c FURTHER_C REPEAT1_C c)
æ
=FAILUREC
\paragraph{Errors}
As the error of the conversion if it cannot be applied at
least once.
=ENDDOC
=DOC
val âEVERY_Cá : CONV list -> CONV;
=DESCRIBE
Apply each conversion in the list, in the sequence given.
=SEEALSO
$THEN\_C$(which this function iterates)
=FAILURE
7103	List may not be empty
=FAILUREC
or as the failure of any constituent conversion,
or as $THEN\_C$.
=ENDDOC
($EVERYC$ in Cambridge HOL)
=DOC
val âFIRST_Cá : CONV list -> CONV;
=DESCRIBE
Attempt to apply each conversion in the list, in the sequence given, until one succeeds, or all fail.
=SEEALSO
$ORELSE\_C$(which this function iterates)
=FAILURE
7103	List may not be empty
=FAILUREC
or as the failure of the last conversion.
=ENDDOC
($FIRSTC$ in Cambridge HOL)
=DOC
val âCHANGED_Cá : CONV -> CONV;
=DESCRIBE
Applies a conversion, and fails if either the conversion fails,
has ill-formed results in certain ways,
or it causes no change.
Even $\alpha$-convertible changes count as a change for this purpose.
=FAILURE
7032	Conversion failed to cause a change
7104	Result of conversion ill-formed
=FAILUREC
It may also fail with the error message of the conversion argument.
=ENDDOC
($CHANGED\_CONV$ in Cambridge HOL)
=DOC
val âTRY_Cá : CONV -> CONV;
=DESCRIBE
Attempt to apply a conversion, and if it fails, apply $refl\_conv$.
=ENDDOC
($TRY\_CONV$ in Cambridge HOL)

\subsubsection{Term Traversal Algorithms for Conversions}
There will be a term traversal conversion tool, prototyped in \cite{DS/FMU/IED/SML019}.
Thus we do not provide as full a tool kit as possible.
In particular we do not give equivalents to $DEPTH\_FORALL\_CONV$
and $DEPTH\_EXISTS\_CONV$.
=DOC
val âRAND_Cá : CONV -> CONV;
=DESCRIBE
Apply a conversion to the operand of a combination:
=RULE
RAND_C
(c : CONV)
»f a¼
É
É
… f a = f a'
=TEX
where $c\ a$ gives $… a = a'$.
=FAILURE
7045	Term is not of the form: »f a¼
7104	Result of conversion ill-formed
=FAILUREC
Also as the failure of the conversion.
=ENDDOC
($RAND\_CONV$ in Cambridge HOL)
=DOC
val âRATOR_Cá : CONV -> CONV;
=DESCRIBE
Apply a conversion to the operator of a combination:
=RULE
RATOR_C
(c : CONV)
»f a¼
É
É
… f a = f' a
=TEX
where $c\ f$ gives $`… f = f'`$.
=FAILURE
7045	Term is not of the form: »f a¼
7104	Result of conversion ill-formed
=FAILUREC
Also as the failure of the conversion.
=ENDDOC
($RAND\_CONV$ in Cambridge HOL)
=DOC
val âCOMB_Cá : (CONV * CONV) -> CONV;
=DESCRIBE
Apply one conversion to the operator of a combination,
and a second to the operand.
=RULE
COMB_C
(c1 : CONV,
c2 : CONV)
»f a¼
É
É
… f a = f' a'
=TEX
where $c1\ f$ gives $`… f = f'`$,
and $c2\ f$ gives $`… a = a'`$.
=FAILURE
7045	Term is not of the form: »f a¼
7104	Result of conversion ill-formed
=FAILUREC
Also as the failure of the conversions.
=ENDDOC
=DOC
val âABS_Cá : CONV -> CONV;
=DESCRIBE
Apply a conversion to the body of a simple abstraction:
=RULE
ABS_C
(c : CONV)
» x Ž p¼
É
É
… ( x Ž p[x]) = ( x Ž p'[x])
=TEX
where $c\ p[x]$ gives $`… p[x] = p'[x]`$.
=SEEALSO
$BINDER\_C$
=FAILURE
7030	Term is not of the form: » x Ž t[x]¼
	where »x¼ is a variable
7104	Result of conversion ill-formed
=FAILUREC
Also as the failure of the conversion.
=ENDDOC
($ABS\_CONV$ in Cambridge HOL)
=DOC
val âBINDER_Cá : CONV -> CONV;
=DESCRIBE
Apply a conversion to the body of a simple binder term:
=RULE
BINDER_C
(c : CONV)
»B x Ž p¼
É
É
… (B x Ž p[x]) = (B x Ž p'[x])
=TEX
where $c\ p[x]$ gives $`… p[x] = p'[x]`$,
and $B$ is a binder.
=FAILURE
7059	Term is not of the form: »B x Ž p[x]¼ where »B¼ is a binder
7104	Result of conversion ill-formed
=FAILUREC
Also as the failure of the conversion.
=ENDDOC
($BINDER\_CONV$ in Cambridge HOL)
=DOC
val âSUB_Cá : CONV -> CONV;
=DESCRIBE
Apply a conversion to each of the constituents of a term,
however that term might be constructed,
and recombine the results.
Thus:
ó
SUB_C cnv var = refl_conv var

SUB_C cnv const = refl_conv const

SUB_C cnv (f x) = ö … f x = f' x' 
	where cnv f = ö1 … f = f'
	and   cnv x = ö2 … x = x'
	and ö = ö1 ¡ ö2

SUB_C cnv ( x Ž t) = ö … ( x Ž t) = ( x Ž t')
	where cnv t = ö … t = t'
æ
=SEEALSO
$SUB1_C$
=ENDDOC
($SUB\_CONV$ in Cambridge HOL)
=DOC
val âSUB1_Cá : CONV -> CONV;
=DESCRIBE
Apply a conversion to each of the constituents of a term,
failing if the term cannot be broken up, or the
conversion fails on all constituents
(if only one of the two constituents of a $mk\_comb$ have failures,
then the offending term will be $refl\_conv$ed instead).
Thus:
ó
SUB1_C cnv var = fail_conv var

SUB1_C cnv const = fail_conv const

SUB1_C cnv (f x) = ö … f x = f' x' 
	where cnv f = ö1 … f = f'
	and   cnv x = ö2 … x = x'
	and ö = ö1 ¡ ö2

SUB1_C cnv ( x Ž t) = ö … ( x Ž t) = ( x Ž t')
	where cnv t = ö … t = t'
æ
=FAILURE
7104	Result of conversion ill-formed
7105	Term has no constituents
=FAILUREC
There may be failure messages from the conversions.
=ENDDOC

The following traversal schemes are those provided by Cambridge HOL,
and are by no means a complete set of ``reasonable'' traversal schemes.
Indeed, $REPEAT\_TRAVERSE\_C$ is unlikely to ever be an efficient traversal scheme, but merely complete.

When they fail, the resulting error message is somewhat ``non-deterministic'', it may 
come from a function implementing the traversal scheme used,
or from the conversion traversed through the term.
=DOC
val âONCE_TRAVERSE_Cá : CONV -> CONV;
=DESCRIBE
This traverses a term from the root node to its leaves,
attempting to apply its conversion argument.
If it successfully applies the conversion to any subterm
then it will not further traverse that subterm,
but will still continue on other branches.
If it fails to apply its conversion to a leaf, its functionality is equivalent to then applying $refl\_conv$.
It traverses from left to right, though this should only matter for
conversions that work by side-effect.
It will fail if the conversion succeeds nowhere in the tree,
or if the results of certain conversion applications are ill-formed.
=ENDDOC
($ONCE\_DEPTH\_CONV$ in Cambridge HOL)
=DOC
val âTRAVERSE_Cá : CONV -> CONV;
=DESCRIBE
This traverses a term from its leaves to its root node.
It will repeat the application of its conversion argument, until failure,
on each subterm encountered en route.
At each node the conversion is applied to the sub-term that results from the application of the preceding traversal, not the original.
It traverses from left to right, though this should only matter for
conversions that work by side-effect.
It fails if the conversion applies nowhere within the tree.
=ENDDOC
($DEPTH\_CONV$ in Cambridge HOL)
=DOC
val âREPEAT_TRAVERSE_Cá : CONV -> CONV;
=DESCRIBE
This traverses a term from its leaves to its root node.
It will attempt the application of its conversion argument
on each subterm encountered en route.
If the conversion is successfully applied 
to a given sub-term,
then the resulting sub-term from the conversion
is re-traversed by the function.
It traverses from left to right, though this should only matter for
conversions that work by side-effect.
It fails if the conversion is not applicable anywhere within
the term, or if certain applications of the conversion
have ill-formed results.
=ENDDOC
($REDEPTH\_CONV$ in Cambridge HOL)
=DOC
val âTOP_TRAVERSE_Cá : CONV -> CONV;
=DESCRIBE
This traverses a term from its root node to its leaves.
It will repeat the application of its conversion argument, until failure,
on each subterm encountered en route.
It descends through the sub-term that results from the application of the preceding traversal, not the original.
It traverses from left to right, though this should only matter for
conversions that work by side-effect.
It fails if the conversion is applied nowhere within the term.
=ENDDOC
($TOP\_DEPTH\_CONV$ in Cambridge HOL)
\subsubsection{Conversions as Rules}
=DOC
val âconv_ruleá : CONV -> THM -> THM;
=DESCRIBE
Apply a conversion to the conclusion of a theorem, and do $‚$ modus ponens between the original theorem and the result of the conversion
=RULE
conv_rule
(c : CONV)
É
ö1 … t
É
ö1 ¡ ö2 … t'
=TEX
where $c\ t$ gives $ö2 … t ‚ t'$.
=FAILURE
7104	Result of conversion ill-formed
=FAILUREC
Also as the failure of the conversion upon the conclusion of the
theorem.
=ENDDOC
($CONV\_RULE$ in Cambridge HOL)
\section{SUPPORTING THEORY}
\label{theorems}
Some of the above inference rules will be implemented by appealing
to theorems, some of which we make visible to the user in the following.
=DOC
val ât_thmá : THM;
=DESCRIBE
``True'' is true.
=THEOREM
t_thm
É
É
… T
=TEX
=ENDDOC
($TRUTH$ in Cambridge HOL)
=DOC
val âf_thmá : THM;
=DESCRIBE
``Not False'' is true.
=THEOREM
f_thm
É
É
… Œ F
=TEX
=ENDDOC
=DOC
val âŒ_t_thmá : THM;
=DESCRIBE
``Not true is false''.
=THEOREM
Œ_t_thm
É
É
Œ T ‚ F
=TEX
=ENDDOC
=DOC
val âŒ_1_thmá : THM;
=DESCRIBE
``Not t if and only if t is false.''
=THEOREM
Œ_1_thm
É
É
… ƒ t Ž (Œ t) ‚ (t ‚ F)
=TEX
=ENDDOC
=DOC
val âŒ_thmá : THM;
=DESCRIBE
Expanded form of definition of $Œ$:
=THEOREM
Œ_thm
É
É
ƒ t Ž (Œ t) = (t Š F)
=TEX
=ENDDOC
=DOC
val â€_thmá : THM;
=DESCRIBE
Expanded form of definition of $€$
=THEOREM
€_thm
É
É
ƒ t1 t2 Ž (t1 € t2) = 
	(ƒ b Ž (t1 Š t2 Š b) Š b)
=TEX
=ENDDOC
=DOC
val â_thmá : THM;
=DESCRIBE
Expanded form of definition of $$
=THEOREM
_thm
É
É
ƒ t1 t2 Ž (t1  t2) = 
	(ƒ b Ž (t1 Š b) Š (t2 Š b) Š b)
=TEX
=ENDDOC
=DOC
val â„%down%1_thmá : THM;
=DESCRIBE
Expanded form of definition of $„_1$
=THEOREM
„%down%1_thm
É
É
… ƒ P Ž ($„%down%1 P) ‚ 
	(„ t Ž (P t) € (ƒ x Ž (P x) Š x = t))
=TEX
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of DerivedInferenceRules *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
