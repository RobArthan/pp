%  mdt011.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Lexical Analyser}  %% Mandatory field
\TPPref{DS/FMU/IED/MDT015}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document comprises test cases and test code/data for
testing the lexically analyser described in the document
DS/FMU/IED/DTD015.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1]
First version, based on DS/FMU/IED/DTD011.
\item[Issue 1.2]
Changed tests in accordance with changed interface to module test harness.

\item[Issue 1.3]
	Load module test harness initialisation and add a test summary.

\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises test cases and test code/data for
testing the module test harness specified in \cite{DS/FMU/IED/DTD015}.

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the HOL parser
analyser as defined in \cite{DS/FMU/IED/DTD019} and implemented
in \cite{DS/FMU/IED/IMP019}. The tests are intended to meet
the requirements for tests identified in the quality plan
\cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}

These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

There are no known deficiencies.

\section{TEST CASES}
\begin{description}
\item[Parser.1] In this group of tests an instance of each alternative in the
grammar is parsed and the form of the result is checked.
If an alternative contains an optional construct, then a form with and a form
without that construct are checked. Similarlay an iterated construct is
checked with 0, 1 and 2 occurrences.
\item[Parser.2] This group of tests checks that the disambiguation rules
given in sections 2.1.1 and 2.1.2 of \cite{DS/FMU/IED/DEF001}
are implemented correctly.
\item[Parser.3] This group of tests checks the binder forms discussed
in section 2.1.4 of \cite{DS/FMU/IED/DEF001} and the
local definition forms of section 2.1.5 are translated correctly.
(These are given a separate group of tests since the translation is
more complex than other forms).
\item[Parser.4] This group of tests exhibits the reachable error
messages.
\end{description}
\section{PREAMBLE}
=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results();

open Parser;
=TEX
The following code is a modification of
what appears in the parser interface, see \cite{DS/FMU/IED/IMP022}, and
causes HOL term quotations to evaluate to the corresponding stream
of lexical tokens.
=SML
local
        open Lex SymbolTable;
        fun classify (s : string) : HOL_TOKEN = (
        case get_fixity s of
                SymbolTable.Nonfix => HTBlob
        |       SymbolTable.Binder => HTBinder s
        |       SymbolTable.Infix prec => HTInOp{name=s, prec=prec, is_term_op=true, is_type_op=true}
        |       SymbolTable.Prefix prec => HTPreOp{name=s, prec=prec}
        |       SymbolTable.Postfix prec => HTPostOp{name=s, prec=prec}
	);
in
        fun HOL_term_recogniser (_, _, x, _) =
                (lex (get_terminators()) classify) x;
	val test_parse = HOL_parser;
end;
=TEX
The following code sets up some useful values and utilities:
=SML
val x = Id "x";
val y = Id "y";
val z = Id "z";
val a = Id "a";
val b = Id "b";
val c = Id "c";
val d = Id "d";
local
	val prec1 = case get_fixity "=" of Infix p => p | _ => 0;
	val prec2 = case get_fixity "Œ" of Prefix p => p | _ => 0;
	val _ = declare_postfix (200, "!");
in
	fun eq x y = App(App(Id "=", x, Nonfix), y, Infix prec1);
	fun not x = App(Id "Œ", x, Prefix prec2);
	fun fact x = App(Id "!", x, Postfix 200);
end;
declare_infix(150, ",");
new_type("tau", 1);
new_type("sigma", 2);
val tm = mk_var("", BOOL);
val ty = BOOL;
=TEX
\section{THE TESTS}
\subsection{Group 1}
=TEX
The first block of tests in group 1 checks out the alternatives
for $Tm$ (and also $OTm$ and $OptTms$).
=SML
store_mt_results_show mt_run
[
 ("Parser.1.1.1", test_parse, »ƒxy¼, Binder ("ƒ", x , y) ),
 ("Parser.1.1.2", test_parse, »let x = y in x¼, Let([(x, y)], x) ),
 ("Parser.1.1.3", test_parse, »let x = y and a = b in x¼, Let([(x, y), (a,b)], x) ),
 ("Parser.1.1.4", test_parse, »let x = y and a = b and c = d in x¼, Let([(x,y), (a,b), (c,d)], x) ),
 ("Parser.1.1.5", test_parse, »if a then b else c¼, Cond(a, b, c)),
 ("Parser.1.1.6", test_parse, »a = b¼, eq a b),
 ("Parser.1.1.7", test_parse, »Œb¼, not b),
 ("Parser.1.1.8", test_parse, »c!¼, fact c),
 ("Parser.1.1.9", test_parse, »x:»%down%SML: ty¼¼, TmTyped(x, TyAq ty)),
 ("Parser.1.1.10", test_parse, »x¼, x),
 ("Parser.1.1.11", test_parse, »"x"¼, StringLit "x"),
 ("Parser.1.1.12", test_parse, »""¼, StringLit ""),
 ("Parser.1.1.13", test_parse, »"abcd effg"¼, StringLit "abcd effg"),
 ("Parser.1.1.14", test_parse, »`x`¼, CharLit "x"),
 ("Parser.1.1.15", test_parse, »»%down%SML tm¼¼, TmAq tm),
 ("Parser.1.1.16", test_parse, »{}¼, SetDisplay []),
 ("Parser.1.1.17", test_parse, »{x}¼, SetDisplay [x]),
 ("Parser.1.1.18a", test_parse, »{x; y}¼, SetDisplay [x, y]),
 ("Parser.1.1.18b", test_parse, »{x | y}¼, SetComprehension (x, y)),
 ("Parser.1.1.20", test_parse, »(x)¼, x),
 ("Parser.1.1.21", test_parse, »[]¼, ListDisplay []),
 ("Parser.1.1.22", test_parse, »[x]¼, ListDisplay [x]),
 ("Parser.1.1.23", test_parse, »[x; y]¼, ListDisplay [x, y])
];
=TEX
The second block in group 1 checks out the alternatives for $Ty$
(and $Typars$).
=SML
fun xty ty = TmTyped(x, ty);
store_mt_results_show mt_run
[
 ("Parser.1.2.1", test_parse, »x:BOOL¼, xty(TyAtom"BOOL") ),
 ("Parser.1.2.2", test_parse, »x:»%down%SML: ty¼¼, xty(TyAq ty) ),
 ("Parser.1.2.3", test_parse, »x:'a tau¼, xty(TyCompound([TyAtom"'a"], "tau", Nonfix))),
 ("Parser.1.2.4", test_parse, »x:('a)tau¼, xty(TyCompound([TyAtom"'a"], "tau", Nonfix))),
 ("Parser.1.2.5", test_parse, »x:('a, 'b)sigma¼, xty(TyCompound([TyAtom"'a", TyAtom"'b"], "sigma", Nonfix))),
 ("Parser.1.2.6", test_parse, »x:'a ‹ 'b¼, xty(TyCompound([TyAtom"'a", TyAtom"'b"], "‹", get_fixity"‹"))),
 ("Parser.1.2.7", test_parse, »x:('a ‹ 'b)¼, xty(TyCompound([TyAtom"'a", TyAtom"'b"], "‹", get_fixity"‹")))
];
=TEX
The third block in group 1 checks out the alternatives for $V$ and $V1$:
=SML
fun pair x y = App(App(Id ",", x, Nonfix), y, get_fixity ",");
store_mt_results_show mt_run
[
 ("Parser.1.3.1", test_parse, »xy¼, Binder("", x, y) ),
 ("Parser.1.3.2a", test_parse, »x:'ay¼, Binder("", xty(TyAtom"'a"), y) ),
 ("Parser.1.3.3", test_parse, »(x:'a)y¼, Binder("", xty(TyAtom"'a"), y) ),
 ("Parser.1.3.4", test_parse, »(x:'a, y)y¼, Binder("",pair(xty(TyAtom"'a")) y, y) ),
 ("Parser.1.3.5", test_parse, »(x, y, z)y¼, Binder("",pair x (pair y z), y) ),
 ("Parser.1.3.2b", test_parse, »((x, y), z)y¼, Binder("", pair (pair x y) z, y) )
];
=TEX
The fourth block in group 1 checks out the alternatives for $L$, $Vs$ and $V1s$:
=SML
store_mt_results_show mt_run
[
 ("Parser.1.4.1", test_parse, »let x = y in z¼, Let([(x, y)], z) ),
 ("Parser.1.4.2", test_parse, »let (a, b) = y in z¼, Let([(pair a b, y)], z) ),
 ("Parser.1.4.3", test_parse, »let d x = y in z¼, Let([(d, Binder("", x, y))], z) ),
 ("Parser.1.4.4", test_parse, »let d x y = y in z¼, Let([(d, Binder("", x, Binder("", y, y)))], z) ),
 ("Parser.1.4.5", test_parse, »let d (a, b) (y, z) (c, d) = y in z¼, Let([(d, Binder("", pair a b, Binder("", pair y z, Binder("", pair c d, y))))], z) )
];
=TEX
\subsection{Group 2}
To code the tests in this group we use some utilities:
=SML
fun class (Binder _) = "Binder"
|   class (Let _) = "Let"
|   class (Cond _) = "Cond"
|   class (App (Id f, _,_)) = f
|   class (App (other, _, _)) = class other
|   class (TmTyped _) = "TmTyped"
|   class (TmAq _) = "TmAq"
|   class (SetDisplay _) = "SetDisplay"
|   class (SetComprehension _) = "SetComprehension"
|   class (ListDisplay _) = "ListDisplay"
|   class (Id _) = "Id"
|   class (CharLit _) = "CharLit"
|   class (StringLit _) = "StringLit"
|   class (NumLit _) = "NumLit";
=TEX
=SML
fun ty_class (TmTyped (_, TyAtom s)) = s
|   ty_class (TmTyped (_, TyCompound(_, s, _))) = s
|   ty_class _ = "?";
=TEX
=SML
fun outer s1 s2 = (
	let	fun aux (Infix p) = p
		|   aux (Prefix p) = p
		|   aux (Postfix p) = p
		|   aux _ = 0;
	in	if aux (get_fixity s1) > aux (get_fixity s2) then s2 else s1
	end
);
=TEX
The first block in group 2 checks out disambiguation rule 2.1.1/1:
=SML
store_mt_results_show mt_run
[
 ("Parser.2.1.1", class o test_parse, »xa = b¼, "Binder"),
 ("Parser.2.1.2", class o test_parse, »let a = b in a = b¼, "Let"),
 ("Parser.2.1.3", class o test_parse, »if a = b then a else a = b¼, "Cond"),
 ("Parser.2.1.4", class o test_parse, »xa!¼, "Binder"),
 ("Parser.2.1.5", class o test_parse, »let a = b in a!¼, "Let"),
 ("Parser.2.1.6", class o test_parse, »if a = b then a else a!¼, "Cond"),
 ("Parser.2.1.7", class o test_parse, »xŒa¼, "Binder"),
 ("Parser.2.1.8", class o test_parse, »let a = b in Œa¼, "Let"),
 ("Parser.2.1.9", class o test_parse, »if a = b then a else Œa¼, "Cond"),
 ("Parser.2.1.10", class o test_parse, »xa:'a¼, "Binder"),
 ("Parser.2.1.11", class o test_parse, »let a = b in a:'a¼, "Let"),
 ("Parser.2.1.12", class o test_parse, »if a = b then a else a:'a¼, "Cond"),
 ("Parser.2.1.13", class o test_parse, »xf a¼, "Binder"),
 ("Parser.2.1.14", class o test_parse, »let a = b in f a¼, "Let"),
 ("Parser.2.1.15", class o test_parse, »if a = b then a else f a¼, "Cond"),
 ("Parser.2.1.16", class o test_parse, »a = b:'a¼, "="),
 ("Parser.2.1.17", class o test_parse, »a:'a = b:'a¼, "="),
 ("Parser.2.1.18", class o test_parse, »a:'a!¼, "!"),
 ("Parser.2.1.19", class o test_parse, »Œa:BOOL¼, "Œ"),
 ("Parser.2.1.20", class o test_parse, »a = f a¼, "="),
 ("Parser.2.1.21", class o test_parse, »f a = f b¼, "="),
 ("Parser.2.1.22", class o test_parse, »f b!¼, "!"),
 ("Parser.2.1.23", class o test_parse, »f a:BOOL¼, "TmTyped")
];
=TEX
The second block in group 2 checks that certain easily forgotten cases
which are allowed by the grammar are handled (viz. application-like
constructs where the rightmost operand is a binder, let-term or conditional:
=SML
store_mt_results_show mt_run
[
 ("Parser.2.2.1", class o test_parse, »f xa = b¼, "f"),
 ("Parser.2.2.2", class o test_parse, »f let a = b in a = b¼, "f"),
 ("Parser.2.2.3", class o test_parse, »f if a = b then a else a = b¼, "f"),
 ("Parser.2.2.4", class o test_parse, »a = xa = b¼, "="),
 ("Parser.2.2.5", class o test_parse, »a = let a = b in a = b¼, "="),
 ("Parser.2.2.6", class o test_parse, »a = if a = b then a else a = b¼, "="),
 ("Parser.2.2.7", class o test_parse, »Œ ƒxa = b¼, "Œ"),
 ("Parser.2.2.8", class o test_parse, »Œ let a = b in a = b¼, "Œ"),
 ("Parser.2.2.9", class o test_parse, »Œ if a = b then a else a = b¼, "Œ")
];
=TEX
The third block in group 2 checks disambiguation rule 2.1.1/2:
=SML
new_type("+", 2);
new_const("+", mk_fun(mk_fun(BOOL, BOOL), BOOL));
declare_infix (10, "+");
store_mt_results_show mt_run
[
 ("Parser.2.3.1", class o test_parse, »f : BOOL BOOL : BOOL¼, "TmTyped"),
 ("Parser.2.3.2", class o test_parse, »x : BOOL + BOOL = y¼, "=")
];
=TEX
The fourth block in group 2 checks disambiguation rule 2.1.1/3:
=SML
declare_prefix(1000, "&");
declare_postfix(0, "#");
declare_prefix(0, "&&");
declare_postfix(1000, "##");
store_mt_results_show mt_run
[
 ("Parser.2.4.1", class o test_parse, »a  b € c¼, outer"""€"),
 ("Parser.2.4.2", class o test_parse, »a € b  c¼, outer"€"""),
 ("Parser.2.4.3", class o test_parse, »Œb  c¼, outer"Œ"""),
 ("Parser.2.4.4", class o test_parse, »b  c!¼, outer"""!"),
 ("Parser.2.4.5", class o test_parse, »&b  c¼, outer"&"""),
 ("Parser.2.4.6", class o test_parse, »b  c#¼, outer"""#"),
 ("Parser.2.4.7", class o test_parse, »&&b  c¼, outer"&&"""),
 ("Parser.2.4.8", class o test_parse, »b  c##¼, outer"""##")
];
store_mt_results_show mt_run
[
 ("Parser.2.4.9", (fn (App(App _, _, _)) => true | _ => false) o test_parse, »a € b € c¼, true)
];
=TEX
The fifth block in group 2 checks disambiguation rule 2.1.1/4:
=SML
store_mt_results_show mt_run
[
 ("Parser.2.5.1a", test_parse, »x y z¼, App(App(x, y, Nonfix), z, Nonfix))
];
=TEX
The sixth block in group 2 checks disambiguation rule 2.2.2/1:
=SML
store_mt_results_show mt_run
[
 ("Parser.2.5.1b", ty_class o test_parse, »x:'a ‹ 'b tau¼, "‹")
];
=TEX
The sixth block in group 2 checks disambiguation rule 2.2.2/2:
=SML
store_mt_results_show mt_run
[
 ("Parser.2.6.1a", ty_class o test_parse, »x:'a ‹ 'b + 'c¼, outer"‹""+"),
 ("Parser.2.6.2a", ty_class o test_parse, »x:'a + 'b ‹ 'c¼, outer"+""‹")
];
store_mt_results_show mt_run
[
 ("Parser.2.6.3c",
 (fn TmTyped(_, TyCompound([TyAtom _, _], _, _)) => true | _ => false) o test_parse,
 »x:'a + 'b + 'c¼,
 true)
];
=TEX
\subsection{Group 3}
We check that complex binders and local definitions
behave by comparing abbreviated forms
with their expansions:
=SML
store_mt_results_show mt_run
[
 ("Parser.2.6.1b", test_parse, »x yx¼, test_parse»xyx¼),
 ("Parser.2.6.2b", test_parse, »x y:'ax¼, test_parse»x:'ay:'ax¼),
 ("Parser.2.6.3c", test_parse, »x y:'a; a b:'bx¼, test_parse»x:'ay:'aa:'bb:'bx¼),
 ("Parser.2.6.4a", test_parse, »let f (a, b) (x : 'a)= y in f¼, test_parse»let f = (a, b); x : 'ay in f¼)
];
=TEX
\subsubsection{Group 4}
=TEX
The first block of test check each of the alternatives for $Tm$ and $Ty$ etc.
to exhibit straight syntax errors (i.e. error 17000 rather than the context-sensitive
errors 17002 and 17004)
=SML
fun msg n = gen_fail_msg "HOL parser" n [];
store_mt_results_show mt_run_fail
[
 ("Parser.2.6.1c", test_parse, »x y¼, msg 17000),
 ("Parser.2.6.2c", test_parse, »y¼, msg 17000),
 ("Parser.2.6.3c", test_parse, »Let a = b in c¼, msg 17000),
 ("Parser.2.6.4b", test_parse, »let a = b In c¼, msg 17000),
 ("Parser.2.6.5", test_parse, »let a in b¼, msg 17000),
 ("Parser.2.6.6", test_parse, »if then b else c¼, msg 17000),
 ("Parser.2.6.7", test_parse, »if a then else c¼, msg 17000),
 ("Parser.2.6.8", test_parse, »if a then b else¼, msg 17000),
 ("Parser.2.6.9", test_parse, »If a then b else c¼, msg 17000),
 ("Parser.2.6.10", test_parse, »if a Then b else c¼, msg 17000),
 ("Parser.2.6.11", test_parse, »if a then b Else c¼, msg 17000),
 ("Parser.2.6.12", test_parse, »!¼, msg 17000),
 ("Parser.2.6.13", test_parse, »Œ!¼, msg 17000),
 ("Parser.2.6.14", test_parse, »Œ x €¼, msg 17000),
 ("Parser.2.6.15", test_parse, » b¼, msg 17000),
 ("Parser.2.6.16", test_parse, »x:¼, msg 17000),
 ("Parser.2.6.17", test_parse, »x:if a then 'a else 'b¼, msg 17000),
 ("Parser.2.6.18", test_parse, »{x;}¼, msg 17000),
 ("Parser.2.6.19", test_parse, »{;}¼, msg 17000),
 ("Parser.2.6.20", test_parse, »{if}¼, msg 17000),
 ("Parser.2.6.21", test_parse, »{x|}¼, msg 17000),
 ("Parser.2.6.22", test_parse, »{|y}¼, msg 17000),
 ("Parser.2.6.23", test_parse, »{|}¼, msg 17000),
 ("Parser.2.6.24", test_parse, »(¼, msg 17000),
 ("Parser.2.6.25", test_parse, »()¼, msg 17000),
 ("Parser.2.6.26", test_parse, »())¼, msg 17000),
 ("Parser.2.6.27", test_parse, »)¼, msg 17000),
 ("Parser.2.6.28", test_parse, »[x;]¼, msg 17000),
 ("Parser.2.6.29", test_parse, »[;]¼, msg 17000),
 ("Parser.2.6.30", test_parse, »[if]¼, msg 17000),
 ("Parser.2.6.31", test_parse, »x:(,)tau¼, msg 17000),
 ("Parser.2.6.32", test_parse, »x:('a,)tau¼, msg 17000),
 ("Parser.2.6.33", test_parse, »x:('a))tau¼, msg 17000),
 ("Parser.2.6.34", test_parse, »x:‹'a¼, msg 17000),
 ("Parser.2.6.35", test_parse, »x:'a‹=y¼, msg 17000)
];
=TEX

\section{SUMMARY OF RESULTS}

=SML
diag_string(summarize_mt_results());
=TEX

\end{document}
