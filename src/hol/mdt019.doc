%  mdt011.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Lexical Analyser}  %% Mandatory field
\TPPref{DS/FMU/IED/MDT015}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document comprises test cases and test code/data for
testing the lexically analyser described in the document
DS/FMU/IED/DTD015.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1]
First version, based on DS/FMU/IED/DTD011.
\item[Issue 1.2]
Changed tests in accordance with changed interface to module test harness.

\item[Issue 1.3]
	Load module test harness initialisation and add a test summary.

\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises test cases and test code/data for
testing the module test harness specified in \cite{DS/FMU/IED/DTD015}.

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the HOL parser
analyser as defined in \cite{DS/FMU/IED/DTD019} and implemented
in \cite{DS/FMU/IED/IMP019}. The tests are intended to meet
the requirements for tests identified in the quality plan
\cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}

These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

There are no known deficiencies.

\section{TEST CASES}
\begin{description}
\item[Parser.1] In this group of tests an instance of each alternative in the
grammar is parsed and the form of the result is checked.
If an alternative contains an optional construct, then a form with and a form
without that construct are checked. Similarlay an iterated construct is
checked with 0, 1 and 2 occurrences.
\item[Parser.2] This group of tests checks that the disambiguation rules
given in sections 2.1.1 and 2.1.2 of \cite{DS/FMU/IED/DEF001}
are implemented correctly.
\item[Parser.3] This group of tests checks the binder forms discussed
in section 2.1.4 of \cite{DS/FMU/IED/DEF001} and the
local definition forms of section 2.1.5 are translated correctly.
(These are given a separate group of tests since the translation is
more complex than other forms).
\item[Parser.4] This group of tests exhibits the reachable error
messages.
\end{description}
\section{PREAMBLE}
=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results();

open Parser;
=TEX
The following code is a modification of
what appears in the parser interface, see \cite{DS/FMU/IED/IMP022}, and
causes HOL term quotations to evaluate to the corresponding stream
of lexical tokens.
=SML
local
        open Lex SymbolTable;
        fun classify (s : string) : HOL_TOKEN = (
        case get_fixity s of
                SymbolTable.Nonfix => HTBlob
        |       SymbolTable.Binder => HTBinder s
        |       SymbolTable.Infix prec => HTInOp{name=s, prec=prec, is_term_op=true, is_type_op=true}
        |       SymbolTable.Prefix prec => HTPreOp{name=s, prec=prec}
        |       SymbolTable.Postfix prec => HTPostOp{name=s, prec=prec}
	);
in
        fun HOL_term_recogniser (_, _, x, _) =
                (lex (get_terminators()) classify) x;
	val test_parse = HOL_parser;
end;
=TEX
The following code sets up some useful values and utilities:
=SML
val x = Id "x";
val y = Id "y";
val z = Id "z";
val a = Id "a";
val b = Id "b";
val c = Id "c";
val d = Id "d";
local
	val prec1 = case get_fixity "=" of Infix p => p | _ => 0;
	val prec2 = case get_fixity "å" of Prefix p => p | _ => 0;
	val _ = declare_postfix (200, "!");
in
	fun eq x y = App(App(Id "=", x, Nonfix), y, Infix prec1);
	fun not x = App(Id "å", x, Prefix prec2);
	fun fact x = App(Id "!", x, Postfix 200);
end;
declare_infix(150, ",");
new_type("tau", 1);
new_type("sigma", 2);
val tm = mk_var("", BOOL);
val ty = BOOL;
=TEX
\section{THE TESTS}
\subsection{Group 1}
=TEX
The first block of tests in group 1 checks out the alternatives
for $Tm$ (and also $OTm$ and $OptTms$).
=SML
store_mt_results_show mt_run
[
 ("Parser.1.1.1", test_parse, ªÉxéyº, Binder ("É", x , y) ),
 ("Parser.1.1.2", test_parse, ªlet x = y in xº, Let([(x, y)], x) ),
 ("Parser.1.1.3", test_parse, ªlet x = y and a = b in xº, Let([(x, y), (a,b)], x) ),
 ("Parser.1.1.4", test_parse, ªlet x = y and a = b and c = d in xº, Let([(x,y), (a,b), (c,d)], x) ),
 ("Parser.1.1.5", test_parse, ªif a then b else cº, Cond(a, b, c)),
 ("Parser.1.1.6", test_parse, ªa = bº, eq a b),
 ("Parser.1.1.7", test_parse, ªåbº, not b),
 ("Parser.1.1.8", test_parse, ªc!º, fact c),
 ("Parser.1.1.9", test_parse, ªx:ª%down%SML: tyºº, TmTyped(x, TyAq ty)),
 ("Parser.1.1.10", test_parse, ªxº, x),
 ("Parser.1.1.11", test_parse, ª"x"º, StringLit "x"),
 ("Parser.1.1.12", test_parse, ª""º, StringLit ""),
 ("Parser.1.1.13", test_parse, ª"abcd effg"º, StringLit "abcd effg"),
 ("Parser.1.1.14", test_parse, ª`x`º, CharLit "x"),
 ("Parser.1.1.15", test_parse, ªª%down%SML tmºº, TmAq tm),
 ("Parser.1.1.16", test_parse, ª{}º, SetDisplay []),
 ("Parser.1.1.17", test_parse, ª{x}º, SetDisplay [x]),
 ("Parser.1.1.18a", test_parse, ª{x; y}º, SetDisplay [x, y]),
 ("Parser.1.1.18b", test_parse, ª{x | y}º, SetComprehension (x, y)),
 ("Parser.1.1.20", test_parse, ª(x)º, x),
 ("Parser.1.1.21", test_parse, ª[]º, ListDisplay []),
 ("Parser.1.1.22", test_parse, ª[x]º, ListDisplay [x]),
 ("Parser.1.1.23", test_parse, ª[x; y]º, ListDisplay [x, y])
];
=TEX
The second block in group 1 checks out the alternatives for $Ty$
(and $Typars$).
=SML
fun xty ty = TmTyped(x, ty);
store_mt_results_show mt_run
[
 ("Parser.1.2.1", test_parse, ªx:BOOLº, xty(TyAtom"BOOL") ),
 ("Parser.1.2.2", test_parse, ªx:ª%down%SML: tyºº, xty(TyAq ty) ),
 ("Parser.1.2.3", test_parse, ªx:'a tauº, xty(TyCompound([TyAtom"'a"], "tau", Nonfix))),
 ("Parser.1.2.4", test_parse, ªx:('a)tauº, xty(TyCompound([TyAtom"'a"], "tau", Nonfix))),
 ("Parser.1.2.5", test_parse, ªx:('a, 'b)sigmaº, xty(TyCompound([TyAtom"'a", TyAtom"'b"], "sigma", Nonfix))),
 ("Parser.1.2.6", test_parse, ªx:'a ã 'bº, xty(TyCompound([TyAtom"'a", TyAtom"'b"], "ã", get_fixity"ã"))),
 ("Parser.1.2.7", test_parse, ªx:('a ã 'b)º, xty(TyCompound([TyAtom"'a", TyAtom"'b"], "ã", get_fixity"ã")))
];
=TEX
The third block in group 1 checks out the alternatives for $V$ and $V1$:
=SML
fun pair x y = App(App(Id ",", x, Nonfix), y, get_fixity ",");
store_mt_results_show mt_run
[
 ("Parser.1.3.1", test_parse, ªçxéyº, Binder("ç", x, y) ),
 ("Parser.1.3.2a", test_parse, ªçx:'aéyº, Binder("ç", xty(TyAtom"'a"), y) ),
 ("Parser.1.3.3", test_parse, ªç(x:'a)éyº, Binder("ç", xty(TyAtom"'a"), y) ),
 ("Parser.1.3.4", test_parse, ªç(x:'a, y)éyº, Binder("ç",pair(xty(TyAtom"'a")) y, y) ),
 ("Parser.1.3.5", test_parse, ªç(x, y, z)éyº, Binder("ç",pair x (pair y z), y) ),
 ("Parser.1.3.2b", test_parse, ªç((x, y), z)éyº, Binder("ç", pair (pair x y) z, y) )
];
=TEX
The fourth block in group 1 checks out the alternatives for $L$, $Vs$ and $V1s$:
=SML
store_mt_results_show mt_run
[
 ("Parser.1.4.1", test_parse, ªlet x = y in zº, Let([(x, y)], z) ),
 ("Parser.1.4.2", test_parse, ªlet (a, b) = y in zº, Let([(pair a b, y)], z) ),
 ("Parser.1.4.3", test_parse, ªlet d x = y in zº, Let([(d, Binder("ç", x, y))], z) ),
 ("Parser.1.4.4", test_parse, ªlet d x y = y in zº, Let([(d, Binder("ç", x, Binder("ç", y, y)))], z) ),
 ("Parser.1.4.5", test_parse, ªlet d (a, b) (y, z) (c, d) = y in zº, Let([(d, Binder("ç", pair a b, Binder("ç", pair y z, Binder("ç", pair c d, y))))], z) )
];
=TEX
\subsection{Group 2}
To code the tests in this group we use some utilities:
=SML
fun class (Binder _) = "Binder"
|   class (Let _) = "Let"
|   class (Cond _) = "Cond"
|   class (App (Id f, _,_)) = f
|   class (App (other, _, _)) = class other
|   class (TmTyped _) = "TmTyped"
|   class (TmAq _) = "TmAq"
|   class (SetDisplay _) = "SetDisplay"
|   class (SetComprehension _) = "SetComprehension"
|   class (ListDisplay _) = "ListDisplay"
|   class (Id _) = "Id"
|   class (CharLit _) = "CharLit"
|   class (StringLit _) = "StringLit"
|   class (NumLit _) = "NumLit";
=TEX
=SML
fun ty_class (TmTyped (_, TyAtom s)) = s
|   ty_class (TmTyped (_, TyCompound(_, s, _))) = s
|   ty_class _ = "?";
=TEX
=SML
fun outer s1 s2 = (
	let	fun aux (Infix p) = p
		|   aux (Prefix p) = p
		|   aux (Postfix p) = p
		|   aux _ = 0;
	in	if aux (get_fixity s1) > aux (get_fixity s2) then s2 else s1
	end
);
=TEX
The first block in group 2 checks out disambiguation rule 2.1.1/1:
=SML
store_mt_results_show mt_run
[
 ("Parser.2.1.1", class o test_parse, ªçxéa = bº, "Binder"),
 ("Parser.2.1.2", class o test_parse, ªlet a = b in a = bº, "Let"),
 ("Parser.2.1.3", class o test_parse, ªif a = b then a else a = bº, "Cond"),
 ("Parser.2.1.4", class o test_parse, ªçxéa!º, "Binder"),
 ("Parser.2.1.5", class o test_parse, ªlet a = b in a!º, "Let"),
 ("Parser.2.1.6", class o test_parse, ªif a = b then a else a!º, "Cond"),
 ("Parser.2.1.7", class o test_parse, ªçxéåaº, "Binder"),
 ("Parser.2.1.8", class o test_parse, ªlet a = b in åaº, "Let"),
 ("Parser.2.1.9", class o test_parse, ªif a = b then a else åaº, "Cond"),
 ("Parser.2.1.10", class o test_parse, ªçxéa:'aº, "Binder"),
 ("Parser.2.1.11", class o test_parse, ªlet a = b in a:'aº, "Let"),
 ("Parser.2.1.12", class o test_parse, ªif a = b then a else a:'aº, "Cond"),
 ("Parser.2.1.13", class o test_parse, ªçxéf aº, "Binder"),
 ("Parser.2.1.14", class o test_parse, ªlet a = b in f aº, "Let"),
 ("Parser.2.1.15", class o test_parse, ªif a = b then a else f aº, "Cond"),
 ("Parser.2.1.16", class o test_parse, ªa = b:'aº, "="),
 ("Parser.2.1.17", class o test_parse, ªa:'a = b:'aº, "="),
 ("Parser.2.1.18", class o test_parse, ªa:'a!º, "!"),
 ("Parser.2.1.19", class o test_parse, ªåa:BOOLº, "å"),
 ("Parser.2.1.20", class o test_parse, ªa = f aº, "="),
 ("Parser.2.1.21", class o test_parse, ªf a = f bº, "="),
 ("Parser.2.1.22", class o test_parse, ªf b!º, "!"),
 ("Parser.2.1.23", class o test_parse, ªf a:BOOLº, "TmTyped")
];
=TEX
The second block in group 2 checks that certain easily forgotten cases
which are allowed by the grammar are handled (viz. application-like
constructs where the rightmost operand is a binder, let-term or conditional:
=SML
store_mt_results_show mt_run
[
 ("Parser.2.2.1", class o test_parse, ªf çxéa = bº, "f"),
 ("Parser.2.2.2", class o test_parse, ªf let a = b in a = bº, "f"),
 ("Parser.2.2.3", class o test_parse, ªf if a = b then a else a = bº, "f"),
 ("Parser.2.2.4", class o test_parse, ªa = çxéa = bº, "="),
 ("Parser.2.2.5", class o test_parse, ªa = let a = b in a = bº, "="),
 ("Parser.2.2.6", class o test_parse, ªa = if a = b then a else a = bº, "="),
 ("Parser.2.2.7", class o test_parse, ªå Éxéa = bº, "å"),
 ("Parser.2.2.8", class o test_parse, ªå let a = b in a = bº, "å"),
 ("Parser.2.2.9", class o test_parse, ªå if a = b then a else a = bº, "å")
];
=TEX
The third block in group 2 checks disambiguation rule 2.1.1/2:
=SML
new_type("+", 2);
new_const("+", mk_fun(mk_fun(BOOL, BOOL), BOOL));
declare_infix (10, "+");
store_mt_results_show mt_run
[
 ("Parser.2.3.1", class o test_parse, ªf : BOOL BOOL : BOOLº, "TmTyped"),
 ("Parser.2.3.2", class o test_parse, ªx : BOOL + BOOL = yº, "=")
];
=TEX
The fourth block in group 2 checks disambiguation rule 2.1.1/3:
=SML
declare_prefix(1000, "&");
declare_postfix(0, "#");
declare_prefix(0, "&&");
declare_postfix(1000, "##");
store_mt_results_show mt_run
[
 ("Parser.2.4.1", class o test_parse, ªa Å b Ä cº, outer"Å""Ä"),
 ("Parser.2.4.2", class o test_parse, ªa Ä b Å cº, outer"Ä""Å"),
 ("Parser.2.4.3", class o test_parse, ªåb Å cº, outer"å""Å"),
 ("Parser.2.4.4", class o test_parse, ªb Å c!º, outer"Å""!"),
 ("Parser.2.4.5", class o test_parse, ª&b Å cº, outer"&""Å"),
 ("Parser.2.4.6", class o test_parse, ªb Å c#º, outer"Å""#"),
 ("Parser.2.4.7", class o test_parse, ª&&b Å cº, outer"&&""Å"),
 ("Parser.2.4.8", class o test_parse, ªb Å c##º, outer"Å""##")
];
store_mt_results_show mt_run
[
 ("Parser.2.4.9", (fn (App(App _, _, _)) => true | _ => false) o test_parse, ªa Ä b Ä cº, true)
];
=TEX
The fifth block in group 2 checks disambiguation rule 2.1.1/4:
=SML
store_mt_results_show mt_run
[
 ("Parser.2.5.1a", test_parse, ªx y zº, App(App(x, y, Nonfix), z, Nonfix))
];
=TEX
The sixth block in group 2 checks disambiguation rule 2.2.2/1:
=SML
store_mt_results_show mt_run
[
 ("Parser.2.5.1b", ty_class o test_parse, ªx:'a ã 'b tauº, "ã")
];
=TEX
The sixth block in group 2 checks disambiguation rule 2.2.2/2:
=SML
store_mt_results_show mt_run
[
 ("Parser.2.6.1a", ty_class o test_parse, ªx:'a ã 'b + 'cº, outer"ã""+"),
 ("Parser.2.6.2a", ty_class o test_parse, ªx:'a + 'b ã 'cº, outer"+""ã")
];
store_mt_results_show mt_run
[
 ("Parser.2.6.3c",
 (fn TmTyped(_, TyCompound([TyAtom _, _], _, _)) => true | _ => false) o test_parse,
 ªx:'a + 'b + 'cº,
 true)
];
=TEX
\subsection{Group 3}
We check that complex binders and local definitions
behave by comparing abbreviated forms
with their expansions:
=SML
store_mt_results_show mt_run
[
 ("Parser.2.6.1b", test_parse, ªçx yéxº, test_parseªçxéçyéxº),
 ("Parser.2.6.2b", test_parse, ªçx y:'aéxº, test_parseªçx:'aéçy:'aéxº),
 ("Parser.2.6.3c", test_parse, ªçx y:'a; a b:'béxº, test_parseªçx:'aéçy:'aéça:'béçb:'béxº),
 ("Parser.2.6.4a", test_parse, ªlet f (a, b) (x : 'a)= y in fº, test_parseªlet f = ç(a, b); x : 'aéy in fº)
];
=TEX
\subsubsection{Group 4}
=TEX
The first block of test check each of the alternatives for $Tm$ and $Ty$ etc.
to exhibit straight syntax errors (i.e. error 17000 rather than the context-sensitive
errors 17002 and 17004)
=SML
fun msg n = gen_fail_msg "HOL parser" n [];
store_mt_results_show mt_run_fail
[
 ("Parser.2.6.1c", test_parse, ªçx yéº, msg 17000),
 ("Parser.2.6.2c", test_parse, ªçéyº, msg 17000),
 ("Parser.2.6.3c", test_parse, ªLet a = b in cº, msg 17000),
 ("Parser.2.6.4b", test_parse, ªlet a = b In cº, msg 17000),
 ("Parser.2.6.5", test_parse, ªlet a in bº, msg 17000),
 ("Parser.2.6.6", test_parse, ªif then b else cº, msg 17000),
 ("Parser.2.6.7", test_parse, ªif a then else cº, msg 17000),
 ("Parser.2.6.8", test_parse, ªif a then b elseº, msg 17000),
 ("Parser.2.6.9", test_parse, ªIf a then b else cº, msg 17000),
 ("Parser.2.6.10", test_parse, ªif a Then b else cº, msg 17000),
 ("Parser.2.6.11", test_parse, ªif a then b Else cº, msg 17000),
 ("Parser.2.6.12", test_parse, ª!º, msg 17000),
 ("Parser.2.6.13", test_parse, ªå!º, msg 17000),
 ("Parser.2.6.14", test_parse, ªå x Äº, msg 17000),
 ("Parser.2.6.15", test_parse, ªÅ bº, msg 17000),
 ("Parser.2.6.16", test_parse, ªx:º, msg 17000),
 ("Parser.2.6.17", test_parse, ªx:if a then 'a else 'bº, msg 17000),
 ("Parser.2.6.18", test_parse, ª{x;}º, msg 17000),
 ("Parser.2.6.19", test_parse, ª{;}º, msg 17000),
 ("Parser.2.6.20", test_parse, ª{if}º, msg 17000),
 ("Parser.2.6.21", test_parse, ª{x|}º, msg 17000),
 ("Parser.2.6.22", test_parse, ª{|y}º, msg 17000),
 ("Parser.2.6.23", test_parse, ª{|}º, msg 17000),
 ("Parser.2.6.24", test_parse, ª(º, msg 17000),
 ("Parser.2.6.25", test_parse, ª()º, msg 17000),
 ("Parser.2.6.26", test_parse, ª())º, msg 17000),
 ("Parser.2.6.27", test_parse, ª)º, msg 17000),
 ("Parser.2.6.28", test_parse, ª[x;]º, msg 17000),
 ("Parser.2.6.29", test_parse, ª[;]º, msg 17000),
 ("Parser.2.6.30", test_parse, ª[if]º, msg 17000),
 ("Parser.2.6.31", test_parse, ªx:(,)tauº, msg 17000),
 ("Parser.2.6.32", test_parse, ªx:('a,)tauº, msg 17000),
 ("Parser.2.6.33", test_parse, ªx:('a))tauº, msg 17000),
 ("Parser.2.6.34", test_parse, ªx:ã'aº, msg 17000),
 ("Parser.2.6.35", test_parse, ªx:'aã=yº, msg 17000)
];
=TEX

\section{SUMMARY OF RESULTS}

=SML
diag_string(summarize_mt_results());
=TEX

\end{document}
