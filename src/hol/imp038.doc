=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FORMAL METHODS UNIT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Elementary Theory of Arithmetic}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP038}  %% Mandatory field
\def\SCCSversion{$Date$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    R.D.~Arthan \\ K.~Blackburn
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
First version.

\subsection{Changes forecast}

Under development.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of the elementary
theory of arithmetic for the ICL HOL proof development system.
\subsection{Introduction}
\subsection{Purpose and Background}
This document will be called for in the yet-to-be-written
\cite{DS/FMU/IED/DTD038}.
\subsection{Dependencis}
The document depends on the theory of pairs given in
\cite{DS/FMU/IED/DTD037}.
\subsection{Deficiencies}
The Standard ML code is not packaged in a structure yet.

Operator precedences and names need reviewing against requirements.
\subsection{Possible Enhancements}
It might be better to give a loose definition of subtraction.
\section{INTRODUCING THE TYPE Ü}
In this section we create the new theory and define the type Ü.
First of all we make sure we are in the right theory:
=SML
open_theory"pair";
new_theory"Ü";
=TEX
The following lemma asserts the existence of what will be the representations
of the $Suc$ and $0$. The characterising property it uses
is the first step on the way from the axiom of infinity to the Peano
postulates and brings out the fact that the successor function is not onto.
=SML
push_goal([], ª
Ñsuc:INDãIND; zero:INDé OneOne suc Ä (Éxéåsuc x = zero)
º);
a(strip_asm_tac infinity_axiom THEN simple_Ñ_tacªf:INDãINDº THEN asm_rewrite_tac[]);
a(undisch_tacªå Onto (f:INDãIND)º THEN rewrite_tac[onto_def] THEN REPEAT strip_tac);
a(simple_Ñ_tacªy:INDº THEN strip_tac THEN conv_tac(ONCE_MAP_C eq_sym_conv) THEN asm_rewrite_tac[]);
=TEX
=SML
val ‚lemma1· : THM = pop_thm();
=TEX
The next lemma is for use in loosely specifying the defining predicate
for the new type. It asserts that for some
subset of $IND$, analogues of the Peano postulates hold for
appropriate representatives of $Suc$ and $0$. The lemma is formulated
for use with $new\_specification$ to define $Is\_Ü\_Rep$.

Note that the lemma is slightly stronger than what is strictly necessary, in
that the last two conjuncts are not relativised to the subset determined
by $Is\_Ü\_Rep$. This makes later proofs a little easier.
=SML
push_goal([], ª
ÑIs_Ü_Rep:IND ã BOOLé
	Ñ zero sucé
		(Is_Ü_Rep zero Ä ÉnéIs_Ü_Rep n ä Is_Ü_Rep(suc n))
	Ä	(ÉnéIs_Ü_Rep n ä å suc n = zero)
	Ä	OneOne suc
	Ä	(Épé	p zero Ä (Émép m ä p (suc m))
		 ä	(ÉnéIs_Ü_Rep n ä p n))
º);
(* First bring in the lemma: *)
a(strip_asm_tac(rewrite_rule[one_one_def] lemma1));
(* Now exhibit the witnesses: *)
a(simple_Ñ_tacªçi:INDéÉqé q zero Ä (Éné q n ä q (suc n)) ä q iº);
a(simple_Ñ_tacªzero:INDº);
a(simple_Ñ_tacªsuc:INDãINDº);
(* Get rid of beta-redexes and strip the goal: *)
a(rewrite_tac[one_one_def] THEN REPEAT strip_tac);
(* 4 subgoals. 1: *)
a(DROP_NTH_ASM_T 3 (ante_tac o all_simple_É_elim) THEN asm_rewrite_tac[]);
(* 2: *)
a(asm_rewrite_tac[]);
(* 3: *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* 4: *)
a(POP_ASM_T (ante_tac o simple_É_elimªp:INDãBOOLº) THEN asm_rewrite_tac[]);
=TEX
=SML
val ‚is_Ü_rep_thm· : THM = pop_thm();
=TEX
We now define $Is\_Ü\_Rep$:
=SML
val ‚is_Ü_rep_def· : THM = new_specification(["Is_Ü_Rep"], 1, is_Ü_rep_thm);
=SML
=TEX
In order to use $Is\_Ü\_Rep$, to define the new type, we need to show
that the subset of $IND$ which it determines is non-empty:
=SML
push_goal([], ªÑx:INDé Is_Ü_Rep xº);
a(strip_asm_tac is_Ü_rep_def);
a(simple_Ñ_tac ªzero:INDº THEN asm_rewrite_tac[]);
val ‚Ü_exist_thm· : THM = pop_thm();
=TEX
Now we can introduce the new type:
=SML
val ‚Ü_def· : THM = new_type_defn("Ü", "Ü", [], Ü_exist_thm);
=TEX
\section{THE PEANO POSTULATES}
We now prove the existence of a zero-element and a successor
function for the new type satisfying the Peano postulates.
This is just a simple matter of lifting already-proved properties of the
representations of these objects up to the new type, and like most such
simple activities it is rather more difficult than one would hope.

The theorem is formulated for use to define $Zero$ and $Suc$ with
$new\_specification$. Note that the names $Zero$ and $Suc$ used here,
do, and must, agree with those used by $icl'suc\_conv$ as defined
in \cite{DS/FMU/IED/DTD006}.

=SML
push_goal([], ª
	Ñ Zero:Ü; Suc:Ü ã Üé
		(Éné å Suc n = Zero)
	Ä	OneOne Suc
	Ä	(Épé p Zero Ä (Émép m ä p (Suc m)) ä (Énép n))
º);
(* We use the type lemmas to bring abstraction and representation functions *)
(* for the new type into the assumptions: *)
a (strip_asm_tac (simple_ä_match_mp_rule type_lemmas_thm Ü_def));
a (strip_asm_tac (rewrite_rule[one_one_def] is_Ü_rep_def));
(* Now we can introduce the witnesses: *)
a (simple_Ñ_tac ª(abs:IND ã Ü)zeroº);
a (simple_Ñ_tac ªça:Üé(abs:IND ã Ü)(suc((rep:Ü ã IND) a))º);
a (asm_rewrite_tac[one_one_def] THEN REPEAT strip_tac);
(* 3 subgoals: 1: *)
a (lemma_tac ªIs_Ü_Rep((rep:Ü ã IND) n)º THEN_LIST [asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so ony 1 subgoal *)
a (lemma_tac ªIs_Ü_Rep(suc((rep:Ü ã IND)n))º);
(* 1.1: *)
a (DROP_NTH_ASM_T 5 (ante_tac o simple_É_elimª(rep:Ü ã IND)nº) THEN
	REPEAT strip_tac);
(* 1.2: *)
a c_contr_tac;
a (lemma_tacª(rep:Ü ã IND)((abs:IND ã Ü)(suc(rep n)))= rep(abs zero)º
	THEN_LIST [asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so ony 1 subgoal *)
a (GET_NTH_ASM_T 10 (ante_tac o simple_É_elimªsuc((rep:Ü ã IND)n):INDº) THEN
	REPEAT strip_tac);
a (GET_NTH_ASM_T 11 (ante_tac o simple_É_elimªzero:INDº) THEN
	REPEAT strip_tac);
a (GET_NTH_ASM_T 9 (ante_tac o simple_É_elimª((rep:Ü ã IND)n)º) THEN
	REPEAT strip_tac);
a (GET_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* Completes 1.2 and 1. 2: *)
a (lemma_tacª(rep:Ü ã IND)x1 = rep x2º);
(* 2.1: *)
a (lemma_tacª(suc:INDãIND)((rep:Ü ã IND)x1) = suc(rep x2)º);
(* 2.1.1: *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* only 1 subgoal. *)
a (lemma_tac ª(rep:Ü ã IND)((abs:IND ã Ü)(rep x2)) = rep x2 Ä rep(abs(rep x1)) = rep x1º
	THEN_LIST [asm_rewrite_tac[], id_tac]);
a (GET_NTH_ASM_T 3 (ante_tac o simple_É_elimª(rep:Ü ã IND)x2º) THEN
	REPEAT strip_tac);
a (GET_NTH_ASM_T 4 (ante_tac o simple_É_elimª(rep:Ü ã IND)x1º) THEN
	REPEAT strip_tac);
a (GET_NTH_ASM_T 6 (ante_tac o ap_fun_rule ªrep:Ü ã INDº) THEN asm_rewrite_tac[]);
(* Completes 2.1.1. 2.1.2: *)
a (GET_NTH_ASM_T 4 (ante_tac o list_simple_É_elim[ª(rep:Ü ã IND)x1º, ª(rep:Ü ã IND)x2º]) THEN
	REPEAT strip_tac);
(* Completes 2.1.2. 2.2: *)
a (POP_ASM_T (ante_tac o ap_fun_rule ªabs:IND ã Üº) THEN asm_rewrite_tac[]);
(* Completes 2. 3: *)
a (lemma_tacªÉa:INDéIs_Ü_Rep a ä Is_Ü_Rep a Ä p ((abs:IND ã Ü) a)º);
(* 2 subgoals. 3.1: *)
a (lemma_tacªÉa:INDéIs_Ü_Rep a Ä p ((abs:IND ã Ü) a) ä
			Is_Ü_Rep (suc a) Ä p (abs (suc a))º);
(* 2 subgoals. 3.1.1: *)
a (REPEAT strip_tac);
(* 2 subgoals. 3.1.1.1: *)
a (GET_NTH_ASM_T 2 (undisch_tac o concl) THEN asm_rewrite_tac[]);
(* Completes 3.1.1.1. 3.1.1.2: *)
a (GET_NTH_ASM_T 3 (ante_tac o simple_É_elimª(abs:IND ã Ü)mº));
a (GET_NTH_ASM_T 2 (undisch_tac o concl) THEN GET_NTH_ASM_T 9 rewrite_thm_tac);
a (strip_tac THEN asm_rewrite_tac[]);
a (GET_NTH_ASM_T 3 (ante_tac o simple_É_elimª(abs:IND ã Ü)aº) THEN 
	POP_ASM_T rewrite_thm_tac THEN REPEAT strip_tac);
(* Completes 3.1.1. 3.1.2: *)
a (GET_NTH_ASM_T 4 (ante_tac o simple_É_elimª
	çaé Is_Ü_Rep a Ä p ((abs:IND ã Ü) a)º) THEN 
	conv_tac all_simple_%beta%_conv THEN taut_tac);
(* Completes 3.1. 3.2: *)
a (lemma_tac ªIs_Ü_Rep ((rep:Ü ã IND) n)º THEN_LIST [asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so only one subgoal *)
a (GET_NTH_ASM_T 2 (ante_tac o simple_É_elimª(rep:Ü ã IND) nº)
	THEN GET_NTH_ASM_T 11 rewrite_thm_tac THEN REPEAT strip_tac);
=TEX
=SML
val ‚zero_suc_thm· : THM = pop_thm();
=TEX
$new\_specification$ may now be used to introduce the basic operations
on the natural numbers.
=SML
val ‚zero_suc_def· : THM = new_specification(["‚Zero·", "‚Suc·"], 2, zero_suc_thm);
=TEX
=SML
val ‚zero_conv· : CONV = ONCE_MAP_C (simple_eq_match_conv (eq_sym_rule(icl'Kernel.icl'suc_conv ª0º)));
=TEX
=SML
val ‚mk_0· = ª0º;
val ‚Ü_type· = ª:Üº;
=TEX
=SML
val ‚suc_conv· : CONV = (fn tm => 
	if tm = mk_0
	then fail "suc_conv" 99999 []
	else icl'Kernel.icl'suc_conv tm
);
=TEX
The individual Peano postulates are trivial to extract from the
definition of $Suc$ and $Zero$:
=SML
val ‚å_suc_thm· = (conv_rule zero_conv)(Ä_left_elim zero_suc_def);
=TEX
=SML
val ‚one_one_suc_thm· = rewrite_rule[one_one_def] (Ä_left_elim (Ä_right_elim zero_suc_def));
=TEX
=SML
val ‚suc_induction_thm· = (conv_rule zero_conv)(Ä_right_elim (Ä_right_elim zero_suc_def));
=TEX
\section{INDUCTION TACTIC}
The following tactic implements ordinary mathematical induction.
It takes as its argument the variable on which induction is to be performed.

It is unsatisfactory for two reasons at the moment. Firstly, its error
messages aren't defined. Secondly, and deeper, it assumes that the variable
on which induction is being performed is free in the goal. Requirements here
need investigation. 
=SML
fun ‚suc_induction_tac· (tm : TERM) : TACTIC = (
	if not(is_var tm andalso type_of tm = Ü_type)
	then term_fail "suc_induction_tac" 99999 [tm]
	else let fun aux_tac (gl as (asms, conc)) = (
			let	val abs = mk_simple_ç(tm, conc);
				val thm0 = (conv_rule
						(ONCE_MAP_C (simple_%beta%_conv))
						(simple_É_elim abs suc_induction_thm));
				val thm1 = undisch_rule(conv_rule
	((RATOR_C o RAND_C o RAND_C o RAND_C)(simple_%alpha%_conv (fst(dest_var tm))))
						thm0);
				val thm2 = simple_É_elim tm thm1;
				val conc' = (hd (hyps thm2));
			in	([(asms, conc')],
				 (fn [th] => prove_asm_rule th thm2
				  | _ => bad_proof "suc_induction_tac"))
			end
		);
	in	aux_tac THEN Ä_tac THEN_LIST [id_tac, simple_É_tac THEN ä_tac]
	end
);
=TEX
=TEX
\section{PRIMITIVE RECURSION THEOREM}
Our approach to the primitive recursion theorem is a straightforward
adaptation of the approach one might take in set theory.

It is usual in set theory to prove a ``principle of definition by
induction''. E.g. in \cite{Halmos74}, Halmos proves what he calls
the ``recursion theorem'', which (modulo names and a uniqueness assertion)
is the following:

\paragraph{Principle of Definition by Induction (PDI):} Let $X$ be a set, let $z \in X$,
and let $s$ be a function from $X$ to itself, then there exists a unique
function $f$ from $Ü$ to $X$ such that $f(0) = z$ and
for any $n$, $f(n+1)=s(f n)$.

We wish to prove the slightly stronger ``principle of definition by
primitive recursion'', and the informal statement of which is:

\paragraph{Principle of Definition by Primitive Recursion(PDPR):}
Let $X$ be a set, let $z \in X$,
and let $s$ be a function of two arguments with domain and first codomain
$X$ and with the second codomain $Ü$, then there exists a unique
function $f$ from $Ü$ to $X$ such that $f(0) = z$ and
for any $n$, $f(n+1)=s(f n)n$.

Now, $PDPR$, is decidedly more useful than $PDI$, as is clear
when one examines almost any real-life recursive definition, e.g that
of the factorial function. However,
a mathematician would probably not bother to state $PDPR$ result separately,
since it is a fairly trivial consequence of $PDI$: given the problem
data of $PDPR$, one uncurries $s$ and combines it with the identity function
to give a function from $XâÜ$ to itself to which $PDI$ may be applied
to give a function from $Ü$ to $XâÜ$ which composes with the projection
onto the first factor to give the desired function for $PDPR$.
(In both $PDI$ and $PDPR$ the uniqueness part is an easy induction. Halmos
does not even bother to mention it.)

Our plan for proving $PDPR$ therefore is to prove $PDI$ by adapting the
standard proof from set-theory and to derive $PDPR$ from it by formalising
the remarks of the previous paragraph.

\subsection{On Functional Relations}
The set-theoretic proof relies on the identification of functions with
single valued relations in set theory. To adapt it to HOL we need
a theorem to justify this line of argument.
The following theorem does just that by allowing
us to rewrite problems about function
existence in terms of two-place relations and so facilitates the use
of standard set-theoretic means of constructing functions.
=SML
push_goal([], ªÉr:'aã'bãBOOLé
	(ÑféÉx yéf x = y Ç r x y) Ç (ÉxéÑyér x y Ä Ézér x z ä z = y)
º);
a(REPEAT strip_tac);
(* 2 subgoals 1: *)
a(simple_Ñ_tacª(f:'aã'b)xº);
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN
	LEMMA_T ªr x ((f:'aã'b)x):BOOLº (fn th => asm_rewrite_tac[th]));
(* Above leaves only the lemma to do: *)
a(POP_ASM_T (rewrite_thm_tac o conv_rule (ONCE_MAP_C eq_sym_conv)));
(* Completes 1. 2: *)
a(simple_Ñ_tac ªçx:'aéáy:'bér x yº THEN conv_tac all_simple_%beta%_conv);
a(REPEAT strip_tac);
(* 2 subgoals: 2.1: *)
a(LEMMA_T ªÑy:'bér (x:'a)yº (ante_tac o simple_Ñ_á_rule)
	THEN GET_NTH_ASM_T 2 (strip_asm_tac o simple_É_elimªx:'aº));
(* 2 subgoals. 2.1.1: *)
a(simple_Ñ_tacªy':'bº THEN asm_rewrite_tac[]);
(* Completes 2.1.1. 2.1.2: *)
a(asm_rewrite_tac[]);
(* Completes 2.1. 2.2: *)
a(LEMMA_T ªÑy':'bér (x:'a)y'º (asm_tac o simple_Ñ_á_rule));
(* 2 subgoals. 2.2.1: *)
a(simple_Ñ_tacªy:'bº THEN asm_rewrite_tac[]);
(* Completes 2.2.1. 2.2.2: *)
a(GET_NTH_ASM_T 3 (strip_asm_tac o simple_É_elimªx:'aº));
a(TOP_ASM_T (strip_asm_tac o simple_É_elimªáy:'bé r (x:'a) yº));
a(GET_NTH_ASM_T 2 (strip_asm_tac o simple_É_elimªy:'bº));
a(asm_rewrite_tac[]);
=TEX
=SML
val ‚fun_rel_thm· = pop_thm();
=TEX
\subsection{Definition by Induction}
As we have mentioned we will
prove the principle of definition by induction following the usual
set-theoretic proof, which may be found, for example, in \cite{Halmos74}.
The informal statement and a sketch of the proof is as follows:

\paragraph{Principle of Definition by Induction:} Let $X$ be a set, let $z \in X$,
and let $s$ be a function from $X$ to itself, then there exists a unique
function $f$ from $Ü$ to $X$ such that $f(0) = z$ and
for any $n$, $f(n+1)=s(f n)$.

\paragraph{Sketch Proof} The uniqueness part is a straight forward proof by
induction; for the existence, let $\cal C$ be the collection of all subsets, $R$,  of
$Ü \times X$ such that $(0, z)\in R$ and for any $n\in Ü$ and $x\in X$,
$(n+1, s x)\in X$ if $(n, x)\in X$. Let $Q = \bigcap \cal C$. We then
prove the following:

\begin{enumerate}
\item $Q \in \cal C$;
\item $Q$ is the graph of a function;
\item the function whose graph is $Q$ is the desired function $f$.
\end{enumerate}

This completes the proof.

This proof translates into HOL reasonably straightforwardly. To avoid
a dependency on the theory of sets, we work with two-place relations instead
of subsets of $Ü \times X$.

Much of the work of the proof is in exhibiting elements from the collection
$\cal C$ satisfying certain requirements. This is done in the following
lemmas, the first of which is fairly easy. In terms of the informal proof,
it says that exists an $R\in \cal C$ such that $(0, x)\in R$ iff. $x = z$.
Note that the first two conjuncts in the HOL statement below stand for
the assertion that $R\in \cal C$.
=SML
push_goal([],
	ªÉz:'aéÉs:'aã'aé Ñr:Üã'aãBOOLé
		r 0 z
	Ä	(Én xér n x ä r(Suc n)(s x))
	Ä	Éx:'aér 0 x ä x = zº);
a(REPEAT strip_tac THEN simple_Ñ_tacªç(k:Ü) (y:'a)éå(k = 0) Å (k = 0 Ä y = z)º);
a(rewrite_tac[å_suc_thm]);
val ‚rec_lemma1· = pop_thm();
=TEX
The second lemma exhibiting an element of $\cal C$ is rather harder, and
requires the following arithmetic result:
=SML
push_goal([], ªÉn:Üéå(Suc n = n)º);
a(REPEAT strip_tac THEN suc_induction_tac ªn:Üº);
(* 2 subgoals: 1: *)
a(rewrite_tac[å_suc_thm]);
(* 2: *)
a(c_contr_tac THEN strip_asm_tac (list_simple_É_elim[ªSuc nº, ªn:Üº]
	one_one_suc_thm));
val ‚rec_lemma2· = pop_thm();
=TEX
The second lemma exhibiting an element of $\cal C$ asserts that for
any $k\in Ü$, there exists $R\in \cal C$ and $t\in X$ such that
$(k, x)\in R$ iff. $x = t$. Note that this implies
that $\bigcap \cal C$ is the graph of a (possibly partial) function on $Ü$.
=SML
push_goal([],
	ªÉz:'aéÉs:'aã'aé Ék:ÜéÑr:Üã'aãBOOLé
		r 0 z
	Ä	(Én xér n x ä r(Suc n)(s x))
	Ä	Ñtér k t Ä Éx:'aér k x ä x = tº);
a(REPEAT strip_tac THEN suc_induction_tacªk:Üº);
(* 2 subgoals: 1 (base case): *)
a(strip_asm_tac (all_simple_É_elim rec_lemma1) THEN simple_Ñ_tacªr:Üã'aãBOOLº);
a(asm_rewrite_tac[] THEN simple_Ñ_tacªz:'aº THEN asm_rewrite_tac[]);
(* 2 *)
a(simple_Ñ_tacªç(i:Ü) (y:'a)éif Suc k = i then y = s (t:'a) else r i yº
	THEN rewrite_tac[å_suc_thm] THEN REPEAT strip_tac);
(* 7 subgoals: 2.1: *)
a(strip_asm_tac (list_simple_É_elim[ªk:Üº, ªn:Üº]one_one_suc_thm));
a(undisch_tac ª(r:Üã'aãBOOL) n xº THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(lemma_tac ª(r:Üã'aãBOOL) k x ä x = tº THEN asm_rewrite_tac[]);
(* 2.2: *)
a(undisch_tac ª(r:Üã'aãBOOL) n xº THEN asm_rewrite_tac[]);
(* 2.3: *)
a(undisch_tac ªSuc k = nº THEN asm_rewrite_tac[rec_lemma2]);
(* 2.4 *)
a(LEMMA_T ª(r:Üã'aãBOOL) n xº ante_tac);
(* 2 subgoals. 2.4.1: *)
a(DROP_ASM_TªSuc k = nº (asm_rewrite_thm_tac o eq_sym_rule));
a(undisch_tac ª(r:Üã'aãBOOL) k tº THEN asm_rewrite_tac[]);
(* 2.4.2: *)
a(asm_rewrite_tac[]);
(* 2.5: *)
a(strip_asm_tac (list_simple_É_elim[ªk:Üº, ªn:Üº]one_one_suc_thm));
a(undisch_tac ª(r:Üã'aãBOOL) n xº THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(lemma_tac ª(r:Üã'aãBOOL) k x ä x = tº THEN asm_rewrite_tac[]);
(* 2.6: *)
a(undisch_tac ª(r:Üã'aãBOOL) n xº THEN asm_rewrite_tac[]);
(* 2.7: *)
a(simple_Ñ_tacª(s:'aã'a)tº THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
=TEX
=SML
val ‚rec_lemma3· = pop_thm();
=TEX
We can now prove the existence part of the principle of definition of
induction (in terms of two-place relations):
=SML
push_goal([],
	ªÉz:'aéÉs:'aã'aé Ñr:Üã'aãBOOLé
		r 0 z
	Ä	(Én xér n x ä r(Suc n)(s x))
	Ä	(ÉméÑyér m y Ä Éxér m x ä x = y)º);

a(REPEAT strip_tac THEN
  simple_Ñ_tacª(ç(k:Ü) (y:'a)é(Éqé(q 0 z Ä (Én xéq n x ä q(Suc n)(s x))) ä q k y))º);
a(rewrite_tac[] THEN REPEAT strip_tac);
(* 2 subgoals: 1: *)
a(DROP_NTH_ASM_T 3 (ante_tac o simple_É_elimªq:Üã'aãBOOLº) THEN asm_rewrite_tac[]);
(* 1.2: *)
a(suc_induction_tac ªm:Üº);
(* 2 subgoals: 2.1: *)
a(simple_Ñ_tacªz:'aº THEN REPEAT strip_tac);
a(strip_asm_tac(all_simple_É_elim rec_lemma1));
a(DROP_NTH_ASM_T 4 (ante_tac o simple_É_elimªr:Üã'aãBOOLº) THEN asm_rewrite_tac[]);
(* 2.2: *)
a(simple_Ñ_tac ª(s:'aã'a)yº THEN REPEAT strip_tac);
(* 2 subgoals: 2.2.1: *)
a(DROP_NTH_ASM_T 4 (ante_tac o simple_É_elimªq:Üã'aãBOOLº) THEN asm_rewrite_tac[]);
(* 2.2.2: *)
a(strip_asm_tac(list_simple_É_elim[ªz:'aº, ªs:'aã'aº, ªSuc mº]rec_lemma3));
a(lemma_tac ª(r:Üã'aãBOOL)m yº);
(* 2.2.2.1: *)
a(DROP_NTH_ASM_T 7 (ante_tac o simple_É_elimªr:Üã'aãBOOLº) THEN asm_rewrite_tac[]);
(* 2.2.2.2: *)
a(lemma_tac ª(r:Üã'aãBOOL)(Suc m) (s:'aã'a y)º);
(* 2.2.2.2.1: *)
a(DROP_NTH_ASM_T 4 (ante_tac o list_simple_É_elim[ªm:Üº, ªy:'aº]) THEN asm_rewrite_tac[]);
(* 2.2.2.2.2: *)
a(lemma_tac ª(r:Üã'aãBOOL)(Suc m) xº);
(* 2.2.2.2.2.1: *)
a(DROP_NTH_ASM_T 7 (ante_tac o simple_É_elimªr:Üã'aãBOOLº) THEN asm_rewrite_tac[]);
(* 2.2.2.2.2.2: *)
a(GET_NTH_ASM_T 4 (ante_tac o simple_É_elimªx:'aº));
a(DROP_NTH_ASM_T 4 (ante_tac o simple_É_elimªs:'aã'a yº));
a(strip_tac THEN asm_rewrite_tac[]);

val ‚rec_lemma4· = pop_thm();
=TEX
It turns out to be slightly more convenient to have available
the following trivial consequence of $fun\_rel\_thm$:
=SML
push_goal([], ªÉr:'aã'bãBOOLé
	(ÉxéÑyér x y Ä Ézér x z ä z = y) ä (ÑféÉx yé(f x = y) = r x y)
º);
a(rewrite_tac[fun_rel_thm]);

val ‚rec_lemma5· = pop_thm();
=TEX
The following result gives the uniqueness part of the principle
of definition by induction:
=SML
push_goal([],
	ªÉz:'aéÉs:'aã'aé Éf g:Üã'aé
	(	(	f 0 = z
		Ä	Én:Üéf(Suc n) = s(f n))
		Ä (	g 0 = z
		Ä	Én:Üég(Suc n) = s(g n)))
	ä	f = gº);
a(REPEAT strip_tac THEN pure_once_rewrite_tac[ext_thm]);
a(strip_tac THEN suc_induction_tac ªx:Üº THEN asm_rewrite_tac[]);
=TEX
=SML
val ‚rec_lemma6· = pop_thm();
=TEX
Using $rec_lemma5$, we now prove the existence part of the principle
of definition by induction in terms of HOL functions:
=SML
push_goal([],
	ªÉz:'aéÉs:'aã'aé Ñf:Üã'aé
		f 0 = z
	Ä	Én:Üéf(Suc n) = s(f n)º);

a(REPEAT strip_tac);
a((strip_asm_tac o all_simple_É_elim) rec_lemma4);
a( (ante_tac o simple_É_elimªr:Üã'aãBOOLº o
	inst_type_rule[(ª:Üº, ª:'aº), (ª:'aº, ª:'bº)]) rec_lemma5);
a(asm_rewrite_tac [] THEN REPEAT strip_tac);
a(simple_Ñ_tacªf:Üã'aº);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
(* Only 1 subgoal *)
a(suc_induction_tacªn:Üº);
(* 2 subgoals: 1 (base case): *)
a(LEMMA_T ª(f 0):'a=zº rewrite_thm_tac);
(* 1.1: *)
a(asm_rewrite_tac[]);
(* 1.2: *)
a(undisch_tacª(r:Üã'aãBOOL) 0 zº THEN asm_rewrite_tac[]);
(* 2 (step): *)
a(LEMMA_Tª(f(Suc n)):'a=s(f n)º rewrite_thm_tac);
(* 2.1: *)
a(asm_rewrite_tac[]);
(* 2.2: *)
a(TOP_ASM_T (undisch_tac o concl) THEN asm_rewrite_tac[]);

val ‚rec_lemma7· = pop_thm();
=TEX
We can now assemble the existence and uniqueness parts of the
theorem to give the desired principle of definition by induction:
=SML
push_goal([],
	ªÉz:'aéÉs:'aã'aé Ñ%down%1f:Üã'aé
		f 0 = z
	Ä	Én:Üéf(Suc n) = s(f n)º);

a(REPEAT strip_tac THEN conv_tac simple_Ñ%down%1_conv);
a(strip_asm_tac(all_simple_É_elim rec_lemma7) THEN simple_Ñ_tacªf:Üã'aº);
a(asm_rewrite_tac[]);
a(REPEAT strip_tac THEN
	ante_tac (list_simple_É_elim[ªz:'aº, ªs:'aã'aº, ªf:Üã'aº, ªx:Üã'aº]rec_lemma6));
a(asm_rewrite_tac[] THEN ä_T (accept_tac o eq_sym_rule));

val ‚induct_def_thm· = save_thm("induct_def_thm", pop_thm());
=TEX
\subsection{Primitive Recursion Theorem}
As we have already mentioned, the existence part
of the primitive recursion theorem is a straightforward consequence of
the principle of definition by induction: given a set $X$, an element $z\in X$
and a two-place function, $s$, from $X â Ü$ to X, we use the principle of
definition by induction to define a function from $Ü$ to $X â Ü$
which sends $0$ to $(0, z) an,d for any $n$, sends $n+1$ to
$(n+1, s(f n))$. The composite of this function with projection onto
the first factor of $X â Ü gives the desired function, $f$ say, from
$Ü$ to $X$ satisfying $f(0)=z$ and $f(n+1)=s(f(n), n)$.

The HOL translation of the above argument is the following:

=SML
push_goal([],
	ªÉz:'aéÉs:'aãÜã'aé Ñf:Üã'aé
		f 0 = z
	Ä	Én:Üéf(Suc n) = s(f n)nº);
a(REPEAT strip_tac THEN strip_asm_tac
	(list_simple_É_elim[ª((z:'a), 0)º, ªç ix:'a â Üé((s (Fst ix) (Snd ix):'a), Suc(Snd ix))º]
	(inst_type_rule[(ª:'a â Üº, ª:'aº)] rec_lemma7)));
a(simple_Ñ_tac ªçiéFst((f:Üã('a â Ü)) i)º);
a(GET_ASM_T ª(f 0:'a â Ü) = (z, 0)º (fn th=> rewrite_tac[pair_ops_def, th]));
a(strip_tac THEN suc_induction_tacªn:Üº);
(* 2 subgoals: 1 (base case) *)
a(asm_rewrite_tac[pair_ops_def]);
(* 1/2: (step) *)
a(asm_rewrite_tac[pair_ops_def]);
a(LEMMA_T ªÉkéSnd((f:Üã('a â Ü))k) = kº rewrite_thm_tac);
a(strip_tac THEN suc_induction_tacªk:Üº THEN asm_rewrite_tac[pair_ops_def]);

val ‚rec_lemma8· = pop_thm();
=TEX
The uniqueness part of the primitive recursion theorem is
straightforward:
=SML
push_goal([],
	ªÉz:'aéÉs:'aãÜã'aé Éf g:Üã'aé
	(	(	f 0 = z
		Ä	Én:Üéf(Suc n) = s(f n)n)
		Ä (	g 0 = z
		Ä	Én:Üég(Suc n) = s(g n)n))
	ä	f = gº);
a(REPEAT strip_tac THEN pure_once_rewrite_tac[ext_thm]);
a(strip_tac THEN suc_induction_tacªx:Üº THEN asm_rewrite_tac[]);
=TEX
=SML
val ‚rec_lemma9· = pop_thm();
=TEX
Assembling $rec_lemma8$ and $rec_lemma9$ to give the primitive recursion theorem
in its usual form, is just like the corresponding step in the
proof of the principle of definition by induction:
=SML
push_goal([],
	ªÉz:'aéÉs:'aãÜã'aé Ñ%down%1f:Üã'aé
		f 0 = z
	Ä	Én:Üéf(Suc n) = s(f n)nº);
a(REPEAT strip_tac THEN conv_tac simple_Ñ%down%1_conv);
a(strip_asm_tac(all_simple_É_elim rec_lemma8) THEN simple_Ñ_tacªf:Üã'aº);
a(asm_rewrite_tac[]);
a(REPEAT strip_tac THEN
	ante_tac (list_simple_É_elim[ªz:'aº, ªs:'aãÜã'aº, ªf:Üã'aº, ªx:Üã'aº]rec_lemma9));
a(asm_rewrite_tac[] THEN ä_T (accept_tac o eq_sym_rule));


val ‚suc_prim_rec_thm· = save_thm("suc_prim_rec_thm", pop_thm());

=TEX
\section{INTRODUCING THE ARITHMETIC OPERATORS}
\subsection{Fixity Declarations}
We choose fixities for the arithmetic operations as follows:
=SML
declare_infix(210, "<");
declare_infix(210, ">");
declare_infix(210, "û");
declare_infix(210, "ü");
declare_infix(300, "+");
declare_infix(300, "-");
declare_infix(310, "*");
declare_infix(310, "div");
declare_infix(310, "mod");
=TEX
Thus, the relational operations are lower precedence than the operations
which return numbers. Addition and subtraction are lower precedence than
multiplication, division and modulus.

These precedences may need to be altered in the light of comparison with
other theories.
\subsection{Addition}
The defining property for $+$ includes a clause about the relation
of $+$ with $Suc$, with a view to freeing the world from $Suc$ as soon
as possible. Indeed, it would, in principle, be possible to build
the theory without ever defining $Suc$, however this would effectively
involve proving all of the results we have proved to date relativised to
the representation type for $Ü$ followed by a mammoth task of lifting them
to $Ü$. Since some people seem to like $Suc$, and it will have its uses from the
efficiency point of view in coding some proof procedures, we have taken it
as primitive.
=SML
push_goal([], ª
	Ñ$+:ÜãÜãÜé Ém né
		0 + n = n
	Ä	(m + 1) + n = (m + n) + 1
	Ä	Suc m = m + 1
º);

a(lemma_tac ª
	Ñ$+:ÜãÜãÜé Ém né
		0 + n = n
	Ä	(Suc m) + n = Suc (m + n)
º);
(* 1: *)
a(strip_asm_tac	(conv_rule all_simple_%beta%_conv
	(list_simple_É_elim
	[ªçn:Üénº, ªçf:ÜãÜéçm:ÜéçnéSuc(f n)º]
	(inst_type_rule[(ª:ÜãÜº, ª:'aº)]suc_prim_rec_thm))));
a(simple_Ñ_tac ªf:ÜãÜãÜº);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
(* 2: *)
a(simple_Ñ_tac ª$+:ÜãÜãÜº THEN asm_rewrite_tac[]);
a(LEMMA_T ªÉmém + 1 = Suc mº asm_rewrite_thm_tac);
(* The rewriting proves the goal, so only the lemma to do *)
a(strip_tac THEN suc_induction_tac ªm:Üº);
(* 2.1: *)
a (conv_tac (ONCE_MAP_C suc_conv) THEN asm_rewrite_tac[]);
(* 2.2 *)
a (asm_rewrite_tac[]);
=TEX
=SML
val ‚plus_def· = new_specification(["+"], 1, pop_thm());

=TEX
\subsection{Some Earlier Work Revisited}
We use $+1$ in preference to $Suc$ from now on and so we must carry
the induction and primitive recursion theorems over to use
this notation.
=SML
val induction_thm = rewrite_rule[plus_def] suc_induction_thm;
val prim_rec_thm = rewrite_rule[plus_def] suc_prim_rec_thm;
=TEX
=SML
fun ‚induction_tac· (tm : TERM) : TACTIC = (
	if not(is_var tm andalso type_of tm = Ü_type)
	then term_fail "induction_tac" 99999 [tm]
	else let fun aux_tac (gl as (asms, conc)) = (
			let	val abs = mk_simple_ç(tm, conc);
				val thm0 = (conv_rule
						(ONCE_MAP_C (simple_%beta%_conv))
						(simple_É_elim abs induction_thm));
				val thm1 = undisch_rule(conv_rule
	((RATOR_C o RAND_C o RAND_C o RAND_C)(simple_%alpha%_conv (fst(dest_var tm))))
						thm0);
				val thm2 = simple_É_elim tm thm1;
				val conc' = (hd (hyps thm2));
			in	([(asms, conc')],
				 (fn [th] => prove_asm_rule th thm2
				  | _ => bad_proof "induction_tac"))
			end
		);
	in	aux_tac THEN Ä_tac THEN_LIST [id_tac, simple_É_tac THEN ä_tac]
	end
);
=TEX
\subsection{Arithmetic Relations}
We first define $>$ and $<$, using their obvious recursive definition as
characterising theorem. Then we define $ü$ and $û$ in terms of them
=SML
push_goal([], ª
	Ñ$>:ÜãÜãBOOLé Ém né
		(å0 > n)
	Ä	(m+1 > n Ç m = n Å m > n)
º);
=TEX
=SML
a(strip_asm_tac	(conv_rule all_simple_%beta%_conv
	(list_simple_É_elim
	[ªçn:ÜéFº, ªçf:ÜãBOOLéçm:Üéçném = n Å f nº]
	(inst_type_rule[(ª:ÜãBOOLº, ª:'aº)]prim_rec_thm))));
a(simple_Ñ_tac ªf:ÜãÜãBOOLº);
a(asm_rewrite_tac[]);
=TEX
=SML
val ‚gt_def· = new_specification([">"], 1, pop_thm());
=TEX
=SML
push_goal([], ª
	Ñ$<:ÜãÜãBOOLé Ém né
		(åm < 0)
	Ä	(m < n+1 Ç m = n Å m < n)
º);
=TEX
=SML
a(once_rewrite_tac[eq_sym_convªm:Ü=nº]);
a(simple_Ñ_tac ªçm nén > mº);
a(rewrite_tac[gt_def]);
=TEX
=SML
val ‚lt_def· = new_specification(["<"], 1, pop_thm());
=TEX
=SML
push_goal([], ª
	Ñ$ü:ÜãÜãBOOLé Ém ném ü n Ç m = n Å m > n
º);
=TEX
=SML
a(simple_Ñ_tac ªçm ném > n Å m = nº);
a(rewrite_tac[] THEN REPEAT strip_tac);
=TEX
=SML
val ‚ge_def· = new_specification(["ü"], 1, pop_thm());
=TEX
=SML
push_goal([], ª
	Ñ$û:ÜãÜãBOOLé Ém ném û n Ç m = n Å m < n
º);
=TEX
=SML
a(simple_Ñ_tac ªçm ném = n Å m < nº);
a(rewrite_tac[] THEN REPEAT strip_tac);
=TEX
=SML
val ‚le_def· = new_specification(["û"], 1, pop_thm());
=TEX
\subsection{Subtraction}
It would be possible to define subtraction loosely, so that
$x-y$ was unspecified for $x < y$. It seems however to be traditional
in automated theorem proving not to do this but instead to
define $x-y$ to be $0$ if $x < y$.
=SML
push_goal([], ª
	Ñ$-:ÜãÜãÜé Ém né
		0 - n = 0
	Ä	(m + 1) - n = if m < n then 0 else (m - n) + 1
º);
=TEX
=SML
a(strip_asm_tac	(conv_rule all_simple_%beta%_conv
	(list_simple_É_elim
	[ªçn:Üé0º, ªçf:ÜãÜéçm:Üéçnéif m < n then 0 else (f n) + 1º]
	(inst_type_rule[(ª:ÜãÜº, ª:'aº)]prim_rec_thm))));
a(simple_Ñ_tac ªf:ÜãÜãÜº);
a(asm_rewrite_tac[]);
=TEX
=SML
val ‚minus_def· = new_specification(["-"], 1, pop_thm());
=TEX
\subsection{Multiplication}
=SML
push_goal([], ª
	Ñ$*:ÜãÜãÜé Ém né
		0 * n = 0
	Ä	(m + 1) * n = m * n + n
º);
=TEX
=SML
a(strip_asm_tac	(conv_rule all_simple_%beta%_conv
	(list_simple_É_elim
	[ªçn:Üé0º, ªçf:ÜãÜéçm:Üéçnéf n + n
º]
	(inst_type_rule[(ª:ÜãÜº, ª:'aº)]prim_rec_thm))));
a(simple_Ñ_tac ªf:ÜãÜãÜº);
a(asm_rewrite_tac[]);
=TEX
=SML
val ‚times_def· = new_specification(["*"], 1, pop_thm());
=TEX
\subsection{Modulus}
We characterise $mod$ by an odometer-style definition. This seems to be the
most straightforward way.
=SML
push_goal([], ª
	Ñ$mod:ÜãÜãÜé Ém né
		0 mod n = 0
	Ä	(m + 1) mod n = if m mod n < n then m mod n + 1 else 0
º);
=TEX
=SML
a(strip_asm_tac	(conv_rule all_simple_%beta%_conv
	(list_simple_É_elim
	[ªçn:Üé0º, ªçf:ÜãÜéçm:Üéçnéif f n < n then f n + 1 else 0
º]
	(inst_type_rule[(ª:ÜãÜº, ª:'aº)]prim_rec_thm))));
a(simple_Ñ_tac ªf:ÜãÜãÜº);
a(asm_rewrite_tac[]);
=TEX
=SML
val ‚mod_def· = new_specification(["mod"], 1, pop_thm());
=TEX
\subsection{Division}
We characterise $div$ using $mod$. The definition gives no information
about $n\,div\,0$ for any $n$.
=SML
push_goal([], ª
	Ñ$div:ÜãÜãÜé Ém né
		ån = 0
	ä	0 div n = 0
	Ä	(m + 1) div n = if m mod n < n then m div n else m div n + 1
º);
=TEX
=SML
a(strip_asm_tac	(conv_rule all_simple_%beta%_conv
	(list_simple_É_elim
	[ªçn:Üé0º, ªçf:ÜãÜéçm:Üéçnéif m mod n < n then f n else f n + 1
º]
	(inst_type_rule[(ª:ÜãÜº, ª:'aº)]prim_rec_thm))));
a(simple_Ñ_tac ªf:ÜãÜãÜº);
a(asm_rewrite_tac[]);
=TEX
=SML
val ‚div_def· = new_specification(["div"], 1, pop_thm());
=TEX
\end{document}

