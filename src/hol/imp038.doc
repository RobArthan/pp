=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FORMAL METHODS UNIT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Elementary Theory of Arithmetic}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP038}  %% Mandatory field
\def\SCCSversion{$Date$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    R.D.~Arthan \\ K.~Blackburn
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item[Issue 1.5 (25 August 1991)] First draft
\item[Issue 1.9 (25 August 1991)] First version with design and test
\item[Issue 1.10 (16th October 1991)] Brought in line with issue 1.3 design.
\item[Issue 1.11 (17th October 1991)] 
Lost $fun\_rel\_thm$ to \cite{DS/FMU/IED/IMP037}.
\item[Issue 1.13 (15 November 1991)] Corrected definition of $>$. Corrected $lt\_trans\_thm$.
\item[Issue \SCCSversion (\FormatDate{$Date$%
})] Change names of complete induction material (now called
course-of-values induction). Added theorem about uniqueness of
division and modulus.
\end{description}
\subsection{Changes Forecast}

Under development.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation of the elementary
theory of arithmetic for the ICL HOL proof development system.
\subsection{Introduction}
\subsection{Purpose and Background}
This document will be called for in the yet-to-be-written
\cite{DS/FMU/IED/DTD038}.
\subsection{Dependencis}
The document depends on the theory of pairs given in
\cite{DS/FMU/IED/DTD037}.
\subsection{Deficiencies}
The Standard ML code is not packaged in a structure yet.

Operator precedences and names need reviewing against requirements.
\subsection{Possible Enhancements}
It might be better to give a loose definition of subtraction.
\section{PROLOGUE}
In this section we create the new theory and begin the structure which
contains the theory.
We actually use two structures, both called $Ü$
(so the second overwrites the first),
and where the second includes the first.
This is to ease processing.

=TEX
=SML
structure ‚Ü· = struct
=TEX
First of all we make sure we are in the right theory:
=SML
val _ = open_theory"pair";
val _ = new_theory"Ü";
=TEX
\section{INTRODUCING THE TYPE Ü}
In this section we define the type Ü.
The following lemma asserts the existence of what will be the representations
of the $Suc$ and $0$. The characterising property it uses
is the first step on the way from the axiom of infinity to the Peano
postulates and brings out the fact that the successor function is not onto.
=SML
val ‚lemma1· : THM = (
push_goal([], ª
Ñsuc:INDãIND; zero:INDé OneOne suc Ä (Éxéåsuc x = zero)
º);
=TEX
=SML
a(strip_asm_tac infinity_axiom THEN simple_Ñ_tacªf:INDãINDº THEN asm_rewrite_tac[]);
a(undisch_tacªå Onto (f:INDãIND)º THEN rewrite_tac[onto_def] THEN REPEAT strip_tac);
a(simple_Ñ_tacªy:INDº THEN strip_tac THEN conv_tac(ONCE_MAP_C eq_sym_conv) THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
The next lemma is for use in loosely specifying the defining predicate
for the new type. It asserts that for some
subset of $IND$, analogues of the Peano postulates hold for
appropriate representatives of $Suc$ and $0$. The lemma is formulated
for use with $new\_specification$ to define $Is\_Ü\_Rep$.

Note that the lemma is slightly stronger than what is strictly necessary, in
that the last two conjuncts are not relativised to the subset determined
by $Is\_Ü\_Rep$. This makes later proofs a little easier.
=SML
val ‚is_Ü_rep_thm· : THM = (
push_goal([], ª
ÑIs_Ü_Rep:IND ã BOOLé
	Ñ zero sucé
		(Is_Ü_Rep zero Ä ÉnéIs_Ü_Rep n ä Is_Ü_Rep(suc n))
	Ä	(ÉnéIs_Ü_Rep n ä å suc n = zero)
	Ä	OneOne suc
	Ä	(Épé	p zero Ä (Émép m ä p (suc m))
		 ä	(ÉnéIs_Ü_Rep n ä p n))
º);
=TEX
=SML
(* First bring in the lemma: *)
a(strip_asm_tac(rewrite_rule[one_one_def] lemma1));
(* Now exhibit the witnesses: *)
a(simple_Ñ_tacªçi:INDéÉqé q zero Ä (Éné q n ä q (suc n)) ä q iº);
a(simple_Ñ_tacªzero:INDº);
a(simple_Ñ_tacªsuc:INDãINDº);
(* Get rid of beta-redexes and strip the goal: *)
a(rewrite_tac[one_one_def] THEN REPEAT strip_tac);
(* 4 subgoals. 1: *)
a(DROP_NTH_ASM_T 3 (ante_tac o all_simple_É_elim) THEN asm_rewrite_tac[]);
(* 2: *)
a(asm_rewrite_tac[]);
(* 3: *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* 4: *)
a(POP_ASM_T (ante_tac o simple_É_elimªp:INDãBOOLº) THEN asm_rewrite_tac[]);
=TEX
=SML
pop_thm()
);
=TEX
We now define $Is\_Ü\_Rep$:
=SML
val ‚is_Ü_rep_def· : THM = new_specification(["Is_Ü_Rep"], 1, is_Ü_rep_thm);
=SML
=TEX
In order to use $Is\_Ü\_Rep$, to define the new type, we need to show
that the subset of $IND$ which it determines is non-empty:
=SML
val ‚Ü_exist_thm· : THM = (
push_goal([], ªÑx:INDé Is_Ü_Rep xº);
=TEX
=SML
a(strip_asm_tac is_Ü_rep_def);
a(simple_Ñ_tac ªzero:INDº THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
Now we can introduce the new type:
=SML
val ‚Ü_def· : THM = new_type_defn("Ü", "Ü", [], Ü_exist_thm);
=TEX
\section{THE PEANO POSTULATES}
We now prove the existence of a zero-element and a successor
function for the new type satisfying the Peano postulates.
This is just a simple matter of lifting already-proved properties of the
representations of these objects up to the new type, and like most such
simple activities it is rather more difficult than one would hope.

The theorem is formulated for use to define $Zero$ and $Suc$ with
$new\_specification$. Note that the names $Zero$ and $Suc$ used here,
do, and must, agree with those used by $icl'suc\_conv$ as defined
in \cite{DS/FMU/IED/DTD006}.

=SML
val ‚zero_suc_thm· : THM = (
push_goal([], ª
	Ñ Zero:Ü; Suc:Ü ã Üé
		(Éné å Suc n = Zero)
	Ä	OneOne Suc
	Ä	(Épé p Zero Ä (Émép m ä p (Suc m)) ä (Énép n))
º);
=TEX
=SML
(* We use the type lemmas to bring abstraction and representation functions *)
(* for the new type into the assumptions: *)
a (strip_asm_tac (simple_ä_match_mp_rule type_lemmas_thm Ü_def));
a (strip_asm_tac (rewrite_rule[one_one_def] is_Ü_rep_def));
(* Now we can introduce the witnesses: *)
a (simple_Ñ_tac ª(abs:IND ã Ü)zeroº);
a (simple_Ñ_tac ªça:Üé(abs:IND ã Ü)(suc((rep:Ü ã IND) a))º);
a (asm_rewrite_tac[one_one_def] THEN REPEAT strip_tac);
(* 3 subgoals: 1: *)
a (lemma_tac ªIs_Ü_Rep((rep:Ü ã IND) n)º THEN_LIST [asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so ony 1 subgoal *)
a (lemma_tac ªIs_Ü_Rep(suc((rep:Ü ã IND)n))º);
(* 1.1: *)
a (DROP_NTH_ASM_T 5 (ante_tac o simple_É_elimª(rep:Ü ã IND)nº) THEN
	REPEAT strip_tac);
(* 1.2: *)
a c_contr_tac;
a (lemma_tacª(rep:Ü ã IND)((abs:IND ã Ü)(suc(rep n)))= rep(abs zero)º
	THEN_LIST [asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so ony 1 subgoal *)
a (GET_NTH_ASM_T 10 (ante_tac o simple_É_elimªsuc((rep:Ü ã IND)n):INDº) THEN
	REPEAT strip_tac);
a (GET_NTH_ASM_T 11 (ante_tac o simple_É_elimªzero:INDº) THEN
	REPEAT strip_tac);
a (GET_NTH_ASM_T 9 (ante_tac o simple_É_elimª((rep:Ü ã IND)n)º) THEN
	REPEAT strip_tac);
a (GET_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* Completes 1.2 and 1. 2: *)
a (lemma_tacª(rep:Ü ã IND)x1 = rep x2º);
(* 2.1: *)
a (lemma_tacª(suc:INDãIND)((rep:Ü ã IND)x1) = suc(rep x2)º);
(* 2.1.1: *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* only 1 subgoal. *)
a (lemma_tac ª(rep:Ü ã IND)((abs:IND ã Ü)(rep x2)) = rep x2 Ä rep(abs(rep x1)) = rep x1º
	THEN_LIST [asm_rewrite_tac[], id_tac]);
a (GET_NTH_ASM_T 3 (ante_tac o simple_É_elimª(rep:Ü ã IND)x2º) THEN
	REPEAT strip_tac);
a (GET_NTH_ASM_T 4 (ante_tac o simple_É_elimª(rep:Ü ã IND)x1º) THEN
	REPEAT strip_tac);
a (GET_NTH_ASM_T 6 (ante_tac o ap_fun_rule ªrep:Ü ã INDº) THEN asm_rewrite_tac[]);
(* Completes 2.1.1. 2.1.2: *)
a (GET_NTH_ASM_T 4 (ante_tac o list_simple_É_elim[ª(rep:Ü ã IND)x1º, ª(rep:Ü ã IND)x2º]) THEN
	REPEAT strip_tac);
(* Completes 2.1.2. 2.2: *)
a (POP_ASM_T (ante_tac o ap_fun_rule ªabs:IND ã Üº) THEN asm_rewrite_tac[]);
(* Completes 2. 3: *)
a (lemma_tacªÉa:INDéIs_Ü_Rep a ä Is_Ü_Rep a Ä p ((abs:IND ã Ü) a)º);
(* 2 subgoals. 3.1: *)
a (lemma_tacªÉa:INDéIs_Ü_Rep a Ä p ((abs:IND ã Ü) a) ä
			Is_Ü_Rep (suc a) Ä p (abs (suc a))º);
(* 2 subgoals. 3.1.1: *)
a (REPEAT strip_tac);
(* 2 subgoals. 3.1.1.1: *)
a (GET_NTH_ASM_T 2 (undisch_tac o concl) THEN asm_rewrite_tac[]);
(* Completes 3.1.1.1. 3.1.1.2: *)
a (GET_NTH_ASM_T 3 (ante_tac o simple_É_elimª(abs:IND ã Ü)mº));
a (GET_NTH_ASM_T 2 (undisch_tac o concl) THEN GET_NTH_ASM_T 9 rewrite_thm_tac);
a (strip_tac THEN asm_rewrite_tac[]);
a (GET_NTH_ASM_T 3 (ante_tac o simple_É_elimª(abs:IND ã Ü)aº) THEN 
	POP_ASM_T rewrite_thm_tac THEN REPEAT strip_tac);
(* Completes 3.1.1. 3.1.2: *)
a (GET_NTH_ASM_T 4 (ante_tac o simple_É_elimª
	çaé Is_Ü_Rep a Ä p ((abs:IND ã Ü) a)º) THEN 
	conv_tac all_simple_%beta%_conv THEN taut_tac);
(* Completes 3.1. 3.2: *)
a (lemma_tac ªIs_Ü_Rep ((rep:Ü ã IND) n)º THEN_LIST [asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so only one subgoal *)
a (GET_NTH_ASM_T 2 (ante_tac o simple_É_elimª(rep:Ü ã IND) nº)
	THEN GET_NTH_ASM_T 11 rewrite_thm_tac THEN REPEAT strip_tac);
=TEX
=SML
pop_thm()
);
=TEX
$new\_specification$ may now be used to introduce the basic operations
on the natural numbers.
=SML
val ‚zero_suc_def· : THM = new_specification(["‚Zero·", "‚Suc·"], 2, zero_suc_thm);
=TEX
=SML
val ‚zero_conv· : CONV = ONCE_MAP_C (simple_eq_match_conv (eq_sym_rule(icl'Kernel.icl'suc_conv ª0º)));
=TEX
=SML
val ‚Ü_type· = ª:Üº;
=TEX
The individual Peano postulates are trivial to extract from the
definition of $Suc$ and $Zero$:
=SML
val ‚å_suc_thm· = (conv_rule zero_conv)(Ä_left_elim zero_suc_def);
=TEX
=SML
val ‚one_one_suc_thm· = rewrite_rule[one_one_def] (Ä_left_elim (Ä_right_elim zero_suc_def));
=TEX
=SML
val ‚suc_induction_thm· = (conv_rule zero_conv)(Ä_right_elim (Ä_right_elim zero_suc_def));
=TEX
\section{INDUCTION TACTIC}
The following tactic implements ordinary mathematical induction.
It takes as its argument the variable on which induction is to be performed.

It is unsatisfactory for two reasons at the moment. Firstly, its error
messages aren't defined. Secondly, and deeper, it assumes that the variable
on which induction is being performed is free in the goal. Requirements here
need investigation. 
=SML
fun ‚suc_induction_tac· (tm : TERM) : TACTIC = (
	if not(is_var tm andalso type_of tm = Ü_type)
	then term_fail "suc_induction_tac" 99999 [tm]
	else let fun aux_tac (gl as (asms, conc)) = (
			let	val abs = mk_simple_ç(tm, conc);
				val thm0 = (conv_rule
						(ONCE_MAP_C (simple_%beta%_conv))
						(simple_É_elim abs suc_induction_thm));
				val thm1 = undisch_rule(conv_rule
	((RATOR_C o RAND_C o RAND_C o RAND_C)(simple_%alpha%_conv (fst(dest_var tm))))
						thm0);
				val thm2 = simple_É_elim tm thm1;
				val conc' = (hd (hyps thm2));
			in	([(asms, conc')],
				 (fn [th] => prove_asm_rule th thm2
				  | _ => bad_proof "suc_induction_tac"))
			end
		);
	in	aux_tac THEN Ä_tac THEN_LIST [id_tac, simple_É_tac THEN ä_tac]
	end
);
=TEX
=TEX
\section{PRIMITIVE RECURSION THEOREM}
Our approach to the primitive recursion theorem is a straightforward
adaptation of the approach one might take in set theory.

It is usual in set theory to prove a ``principle of definition by
induction''. E.g. in \cite{Halmos74}, Halmos proves what he calls
the ``recursion theorem'', which (modulo names and a uniqueness assertion)
is the following:

\paragraph{Principle of Definition by Induction (PDI):} Let $X$ be a set, let $z \in X$,
and let $s$ be a function from $X$ to itself, then there exists a unique
function $f$ from $Ü$ to $X$ such that $f(0) = z$ and
for any $n$, $f(n+1)=s(f n)$.

We wish to prove the slightly stronger ``principle of definition by
primitive recursion'', and the informal statement of which is:

\paragraph{Principle of Definition by Primitive Recursion(PDPR):}
Let $X$ be a set, let $z \in X$,
and let $s$ be a function of two arguments with domain and first codomain
$X$ and with the second codomain $Ü$, then there exists a unique
function $f$ from $Ü$ to $X$ such that $f(0) = z$ and
for any $n$, $f(n+1)=s(f n)n$.

Now, $PDPR$, is decidedly more useful than $PDI$, as is clear
when one examines almost any real-life recursive definition, e.g that
of the factorial function. However,
a mathematician would probably not bother to state $PDPR$ result separately,
since it is a fairly trivial consequence of $PDI$: given the problem
data of $PDPR$, one uncurries $s$ and combines it with the identity function
to give a function from $XâÜ$ to itself to which $PDI$ may be applied
to give a function from $Ü$ to $XâÜ$ which composes with the projection
onto the first factor to give the desired function for $PDPR$.
(In both $PDI$ and $PDPR$ the uniqueness part is an easy induction. Halmos
does not even bother to mention it.)

Our plan for proving $PDPR$ therefore is to prove $PDI$ by adapting the
standard proof from set-theory and to derive $PDPR$ from it by formalising
the remarks of the previous paragraph.

\subsection{Definition by Induction}
As we have mentioned we will
prove the principle of definition by induction following the usual
set-theoretic proof, which may be found, for example, in \cite{Halmos74}.
The informal statement and a sketch of the proof is as follows:

\paragraph{Principle of Definition by Induction:} Let $X$ be a set, let $z \in X$,
and let $s$ be a function from $X$ to itself, then there exists a unique
function $f$ from $Ü$ to $X$ such that $f(0) = z$ and
for any $n$, $f(n+1)=s(f n)$.

\paragraph{Sketch Proof} The uniqueness part is a straight forward proof by
induction; for the existence, let $\cal C$ be the collection of all subsets, $R$,  of
$Ü \times X$ such that $(0, z)\in R$ and for any $n\in Ü$ and $x\in X$,
$(n+1, s x)\in X$ if $(n, x)\in X$. Let $Q = \bigcap \cal C$. We then
prove the following:

\begin{enumerate}
\item $Q \in \cal C$;
\item $Q$ is the graph of a function;
\item the function whose graph is $Q$ is the desired function $f$.
\end{enumerate}

This completes the proof.

This proof translates into HOL reasonably straightforwardly. To avoid
a dependency on the theory of sets, we work with two-place relations instead
of subsets of $Ü \times X$.

Much of the work of the proof is in exhibiting elements from the collection
$\cal C$ satisfying certain requirements. This is done in the following
lemmas, the first of which is fairly easy. In terms of the informal proof,
it says that exists an $R\in \cal C$ such that $(0, x)\in R$ iff. $x = z$.
Note that the first two conjuncts in the HOL statement below stand for
the assertion that $R\in \cal C$.
=SML
val ‚rec_lemma1· = (
push_goal([],
	ªÉz:'aéÉs:'aã'aé Ñr:Üã'aãBOOLé
		r 0 z
	Ä	(Én xér n x ä r(Suc n)(s x))
	Ä	Éx:'aér 0 x ä x = zº);
=TEX
=SML
a(REPEAT strip_tac THEN simple_Ñ_tacªç(k:Ü) (y:'a)éå(k = 0) Å (k = 0 Ä y = z)º);
a(rewrite_tac[å_suc_thm]);
pop_thm()
);
=TEX
The second lemma exhibiting an element of $\cal C$ is rather harder, and
requires the following arithmetic result:
=SML
val ‚rec_lemma2· = (
push_goal([], ªÉn:Üéå(Suc n = n)º);
=TEX
=SML
a(REPEAT strip_tac THEN suc_induction_tac ªn:Üº);
(* 2 subgoals: 1: *)
a(rewrite_tac[å_suc_thm]);
(* 2: *)
a(c_contr_tac THEN strip_asm_tac (list_simple_É_elim[ªSuc nº, ªn:Üº]
	one_one_suc_thm));
pop_thm()
);
=TEX
The second lemma exhibiting an element of $\cal C$ asserts that for
any $k\in Ü$, there exists $R\in \cal C$ and $t\in X$ such that
$(k, x)\in R$ iff. $x = t$. Note that this implies
that $\bigcap \cal C$ is the graph of a (possibly partial) function on $Ü$.
=SML
val ‚rec_lemma3· = (
push_goal([],
	ªÉz:'aéÉs:'aã'aé Ék:ÜéÑr:Üã'aãBOOLé
		r 0 z
	Ä	(Én xér n x ä r(Suc n)(s x))
	Ä	Ñtér k t Ä Éx:'aér k x ä x = tº);
=TEX
=SML
a(REPEAT strip_tac THEN suc_induction_tacªk:Üº);
(* 2 subgoals: 1 (base case): *)
a(strip_asm_tac (all_simple_É_elim rec_lemma1) THEN simple_Ñ_tacªr:Üã'aãBOOLº);
a(asm_rewrite_tac[] THEN simple_Ñ_tacªz:'aº THEN asm_rewrite_tac[]);
(* 2 *)
a(simple_Ñ_tacªç(i:Ü) (y:'a)éif Suc k = i then y = s (t:'a) else r i yº
	THEN rewrite_tac[å_suc_thm] THEN REPEAT strip_tac);
(* 7 subgoals: 2.1: *)
a(strip_asm_tac (list_simple_É_elim[ªk:Üº, ªn:Üº]one_one_suc_thm));
a(undisch_tac ª(r:Üã'aãBOOL) n xº THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(lemma_tac ª(r:Üã'aãBOOL) k x ä x = tº THEN asm_rewrite_tac[]);
(* 2.2: *)
a(undisch_tac ª(r:Üã'aãBOOL) n xº THEN asm_rewrite_tac[]);
(* 2.3: *)
a(undisch_tac ªSuc k = nº THEN asm_rewrite_tac[rec_lemma2]);
(* 2.4 *)
a(LEMMA_T ª(r:Üã'aãBOOL) n xº ante_tac);
(* 2 subgoals. 2.4.1: *)
a(DROP_ASM_TªSuc k = nº (asm_rewrite_thm_tac o eq_sym_rule));
a(undisch_tac ª(r:Üã'aãBOOL) k tº THEN asm_rewrite_tac[]);
(* 2.4.2: *)
a(asm_rewrite_tac[]);
(* 2.5: *)
a(strip_asm_tac (list_simple_É_elim[ªk:Üº, ªn:Üº]one_one_suc_thm));
a(undisch_tac ª(r:Üã'aãBOOL) n xº THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(lemma_tac ª(r:Üã'aãBOOL) k x ä x = tº THEN asm_rewrite_tac[]);
(* 2.6: *)
a(undisch_tac ª(r:Üã'aãBOOL) n xº THEN asm_rewrite_tac[]);
(* 2.7: *)
a(simple_Ñ_tacª(s:'aã'a)tº THEN REPEAT strip_tac THEN asm_rewrite_tac[]);
=TEX
=SML
pop_thm()
);
=TEX
We can now prove the existence part of the principle of definition of
induction (in terms of two-place relations):
=SML
val ‚rec_lemma4· = (
push_goal([],
	ªÉz:'aéÉs:'aã'aé Ñr:Üã'aãBOOLé
		r 0 z
	Ä	(Én xér n x ä r(Suc n)(s x))
	Ä	(ÉméÑyér m y Ä Éxér m x ä x = y)º);

a(REPEAT strip_tac THEN
  simple_Ñ_tacª(ç(k:Ü) (y:'a)é(Éqé(q 0 z Ä (Én xéq n x ä q(Suc n)(s x))) ä q k y))º);
a(rewrite_tac[] THEN REPEAT strip_tac);
(* 2 subgoals: 1: *)
a(DROP_NTH_ASM_T 3 (ante_tac o simple_É_elimªq:Üã'aãBOOLº) THEN asm_rewrite_tac[]);
(* 1.2: *)
a(suc_induction_tac ªm:Üº);
(* 2 subgoals: 2.1: *)
a(simple_Ñ_tacªz:'aº THEN REPEAT strip_tac);
a(strip_asm_tac(all_simple_É_elim rec_lemma1));
a(DROP_NTH_ASM_T 4 (ante_tac o simple_É_elimªr:Üã'aãBOOLº) THEN asm_rewrite_tac[]);
(* 2.2: *)
a(simple_Ñ_tac ª(s:'aã'a)yº THEN REPEAT strip_tac);
(* 2 subgoals: 2.2.1: *)
a(DROP_NTH_ASM_T 4 (ante_tac o simple_É_elimªq:Üã'aãBOOLº) THEN asm_rewrite_tac[]);
(* 2.2.2: *)
a(strip_asm_tac(list_simple_É_elim[ªz:'aº, ªs:'aã'aº, ªSuc mº]rec_lemma3));
a(lemma_tac ª(r:Üã'aãBOOL)m yº);
(* 2.2.2.1: *)
a(DROP_NTH_ASM_T 7 (ante_tac o simple_É_elimªr:Üã'aãBOOLº) THEN asm_rewrite_tac[]);
(* 2.2.2.2: *)
a(lemma_tac ª(r:Üã'aãBOOL)(Suc m) (s:'aã'a y)º);
(* 2.2.2.2.1: *)
a(DROP_NTH_ASM_T 4 (ante_tac o list_simple_É_elim[ªm:Üº, ªy:'aº]) THEN asm_rewrite_tac[]);
(* 2.2.2.2.2: *)
a(lemma_tac ª(r:Üã'aãBOOL)(Suc m) xº);
(* 2.2.2.2.2.1: *)
a(DROP_NTH_ASM_T 7 (ante_tac o simple_É_elimªr:Üã'aãBOOLº) THEN asm_rewrite_tac[]);
(* 2.2.2.2.2.2: *)
a(GET_NTH_ASM_T 4 (ante_tac o simple_É_elimªx:'aº));
a(DROP_NTH_ASM_T 4 (ante_tac o simple_É_elimªs:'aã'a yº));
a(strip_tac THEN asm_rewrite_tac[]);
=TEX
=SML
pop_thm()
);
=TEX
It turns out to be slightly more convenient to have available
the following trivial consequence of $fun\_rel\_thm$:
=SML
val ‚rec_lemma5· = (
push_goal([], ªÉr:'aã'bãBOOLé
	(ÉxéÑyér x y Ä Ézér x z ä z = y) ä (ÑféÉx yé(f x = y) = r x y)
º);
=TEX
=SML
a(rewrite_tac[fun_rel_thm]);
pop_thm()
);
=TEX
The following result gives the uniqueness part of the principle
of definition by induction:
=SML
val ‚rec_lemma6· = (
push_goal([],
	ªÉz:'aéÉs:'aã'aé Éf g:Üã'aé
	(	(	f 0 = z
		Ä	Én:Üéf(Suc n) = s(f n))
		Ä (	g 0 = z
		Ä	Én:Üég(Suc n) = s(g n)))
	ä	f = gº);
=TEX
=SML
a(REPEAT strip_tac THEN pure_once_rewrite_tac[ext_thm]);
a(strip_tac THEN suc_induction_tac ªx:Üº THEN asm_rewrite_tac[]);
=TEX
=SML
pop_thm()
);
=TEX
Using $rec_lemma5$, we now prove the existence part of the principle
of definition by induction in terms of HOL functions:
=SML
val ‚rec_lemma7· = (
push_goal([],
	ªÉz:'aéÉs:'aã'aé Ñf:Üã'aé
		f 0 = z
	Ä	Én:Üéf(Suc n) = s(f n)º);
=TEX
=SML
a(REPEAT strip_tac);
a((strip_asm_tac o all_simple_É_elim) rec_lemma4);
a( (ante_tac o simple_É_elimªr:Üã'aãBOOLº o
	inst_type_rule[(ª:Üº, ª:'aº), (ª:'aº, ª:'bº)]) rec_lemma5);
a(asm_rewrite_tac [] THEN REPEAT strip_tac);
a(simple_Ñ_tacªf:Üã'aº);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
(* Only 1 subgoal *)
a(suc_induction_tacªn:Üº);
(* 2 subgoals: 1 (base case): *)
a(LEMMA_T ª(f 0):'a=zº rewrite_thm_tac);
(* 1.1: *)
a(asm_rewrite_tac[]);
(* 1.2: *)
a(undisch_tacª(r:Üã'aãBOOL) 0 zº THEN asm_rewrite_tac[]);
(* 2 (step): *)
a(LEMMA_Tª(f(Suc n)):'a=s(f n)º rewrite_thm_tac);
(* 2.1: *)
a(asm_rewrite_tac[]);
(* 2.2: *)
a(TOP_ASM_T (undisch_tac o concl) THEN asm_rewrite_tac[]);
=TEX
=SML
pop_thm()
);
=TEX
We can now assemble the existence and uniqueness parts of the
theorem to give the desired principle of definition by induction:
=SML
val ‚induct_def_thm· = (
push_goal([],
	ªÉz:'aéÉs:'aã'aé Ñ%down%1f:Üã'aé
		f 0 = z
	Ä	Én:Üéf(Suc n) = s(f n)º);
=TEX
=SML
a(REPEAT strip_tac THEN conv_tac simple_Ñ%down%1_conv);
a(strip_asm_tac(all_simple_É_elim rec_lemma7) THEN simple_Ñ_tacªf:Üã'aº);
a(asm_rewrite_tac[]);
a(REPEAT strip_tac THEN
	ante_tac (list_simple_É_elim[ªz:'aº, ªs:'aã'aº, ªf:Üã'aº, ªx:Üã'aº]rec_lemma6));
a(asm_rewrite_tac[] THEN ä_T (accept_tac o eq_sym_rule));
pop_thm()
);
=TEX
\subsection{Primitive Recursion Theorem}
As we have already mentioned, the existence part
of the primitive recursion theorem is a straightforward consequence of
the principle of definition by induction: given a set $X$, an element $z\in X$
and a two-place function, $s$, from $X â Ü$ to X, we use the principle of
definition by induction to define a function from $Ü$ to $X â Ü$
which sends $0$ to $(0, z) an,d for any $n$, sends $n+1$ to
$(n+1, s(f n))$. The composite of this function with projection onto
the first factor of $X â Ü gives the desired function, $f$ say, from
$Ü$ to $X$ satisfying $f(0)=z$ and $f(n+1)=s(f(n), n)$.

The HOL translation of the above argument is the following:

=SML
val ‚rec_lemma8· = (
push_goal([],
	ªÉz:'aéÉs:'aãÜã'aé Ñf:Üã'aé
		f 0 = z
	Ä	Én:Üéf(Suc n) = s(f n)nº);
=TEX
=SML
a(REPEAT strip_tac THEN strip_asm_tac
	(list_simple_É_elim[ª((z:'a), 0)º, ªç ix:'a â Üé((s (Fst ix) (Snd ix):'a), Suc(Snd ix))º]
	(inst_type_rule[(ª:'a â Üº, ª:'aº)] rec_lemma7)));
a(simple_Ñ_tac ªçiéFst((f:Üã('a â Ü)) i)º);
a(GET_ASM_T ª(f 0:'a â Ü) = (z, 0)º (fn th=> rewrite_tac[pair_clauses, th]));
a(strip_tac THEN suc_induction_tacªn:Üº);
(* 2 subgoals: 1 (base case) *)
a(asm_rewrite_tac[pair_clauses]);
(* 1/2: (step) *)
a(asm_rewrite_tac[pair_clauses]);
a(LEMMA_T ªÉkéSnd((f:Üã('a â Ü))k) = kº rewrite_thm_tac);
a(strip_tac THEN suc_induction_tacªk:Üº THEN asm_rewrite_tac[pair_clauses]);
=TEX
=SML
pop_thm()
);
=TEX
The uniqueness part of the primitive recursion theorem is
straightforward:
=SML
val ‚rec_lemma9· = (
push_goal([],
	ªÉz:'aéÉs:'aãÜã'aé Éf g:Üã'aé
	(	(	f 0 = z
		Ä	Én:Üéf(Suc n) = s(f n)n)
		Ä (	g 0 = z
		Ä	Én:Üég(Suc n) = s(g n)n))
	ä	f = gº);
=TEX
=SML
a(REPEAT strip_tac THEN pure_once_rewrite_tac[ext_thm]);
a(strip_tac THEN suc_induction_tacªx:Üº THEN asm_rewrite_tac[]);
=TEX
=SML
pop_thm()
);
=TEX
Assembling $rec_lemma8$ and $rec_lemma9$ to give the primitive recursion theorem
in its usual form, is just like the corresponding step in the
proof of the principle of definition by induction:
=SML
val ‚suc_prim_rec_thm· = (
push_goal([],
	ªÉz:'aéÉs:'aãÜã'aé Ñ%down%1f:Üã'aé
		f 0 = z
	Ä	Én:Üéf(Suc n) = s(f n)nº);
=TEX
=SML
a(REPEAT strip_tac THEN conv_tac simple_Ñ%down%1_conv);
a(strip_asm_tac(all_simple_É_elim rec_lemma8) THEN simple_Ñ_tacªf:Üã'aº);
a(asm_rewrite_tac[]);
a(REPEAT strip_tac THEN
	ante_tac (list_simple_É_elim[ªz:'aº, ªs:'aãÜã'aº, ªf:Üã'aº, ªx:Üã'aº]rec_lemma9));
a(asm_rewrite_tac[] THEN ä_T (accept_tac o eq_sym_rule));
pop_thm()
);

=TEX
\section{THE ARITHMETIC OPERATORS}
\subsection{Interlude}
The following is required to circumvent a compiler problem which would
be caused if we attempted to include all the material in this document
in one Standard ML structure:
=SML
end; (* of structure Ü *)
structure Ü : Ü = struct
open Ü;
=TEX
\subsection{Fixity Declarations}
We choose fixities for the arithmetic operations as follows:
=SML
val side_effect = (
declare_infix(210, "<");
declare_infix(210, ">");
declare_infix(210, "û");
declare_infix(210, "ü");
declare_infix(300, "+");
declare_infix(300, "-");
declare_infix(310, "*");
declare_infix(310, "Div");
declare_infix(310, "Mod")
);
=TEX
Thus, the relational operations are lower precedence than the operations
which return numbers. Addition and subtraction are lower precedence than
multiplication, division and modulus.

These precedences may need to be altered in the light of comparison with
other theories.
\subsection{Addition}
The defining property for $+$ includes a clause about the relation
of $+$ with $Suc$, with a view to freeing the world from $Suc$ as soon
as possible. Indeed, it would, in principle, be possible to build
the theory without ever defining $Suc$, however this would effectively
involve proving all of the results we have proved to date relativised to
the representation type for $Ü$ followed by a mammoth task of lifting them
to $Ü$. Since some people seem to like $Suc$, and it will have its uses from the
efficiency point of view in coding some proof procedures, we have taken it
as primitive.
=SML
val ‚plus_def· = new_specification(["+"], 1, (
push_goal([], ª
	Ñ$+:ÜãÜãÜé Ém né
		0 + n = n
	Ä	(m + 1) + n = (m + n) + 1
	Ä	Suc m = m + 1
º);
=TEX
=SML
a(lemma_tac ª
	Ñ$+:ÜãÜãÜé Ém né
		0 + n = n
	Ä	(Suc m) + n = Suc (m + n)
º);
(* 1: *)
a(strip_asm_tac	(conv_rule all_simple_%beta%_conv
	(list_simple_É_elim
	[ªçn:Üénº, ªçf:ÜãÜéçm:ÜéçnéSuc(f n)º]
	(inst_type_rule[(ª:ÜãÜº, ª:'aº)]suc_prim_rec_thm))));
a(simple_Ñ_tac ªf:ÜãÜãÜº);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
(* 2: *)
a(simple_Ñ_tac ª$+:ÜãÜãÜº THEN asm_rewrite_tac[]);
a(LEMMA_T ªÉmém + 1 = Suc mº asm_rewrite_thm_tac);
(* The rewriting proves the goal, so only the lemma to do *)
a(strip_tac THEN suc_induction_tac ªm:Üº);
(* 2.1: *)
a (conv_tac (ONCE_MAP_C suc_conv) THEN asm_rewrite_tac[]);
(* 2.2 *)
a (asm_rewrite_tac[]);
=TEX
=SML
pop_thm()
));
=TEX
\subsection{Some Earlier Work Revisited}
We use $+1$ in preference to $Suc$ from now on and so we must carry
the induction and primitive recursion theorems etc. over to use
this notation.
=SML
val ‚induction_thm· = save_thm("induction_thm",
	rewrite_rule[plus_def] suc_induction_thm);
val ‚å_plus1_thm· = save_thm("å_plus1_thm",
		rewrite_rule[plus_def] å_suc_thm);
val ‚one_one_plus1_thm· = save_thm("one_one_plus1_thm",
		rewrite_rule[plus_def] one_one_suc_thm);
val ‚prim_rec_thm· = save_thm("prim_rec_thm",
	rewrite_rule[plus_def] suc_prim_rec_thm);
=TEX
=SML
fun ‚INDUCTION_T· (tm : TERM) : (THM -> TACTIC) -> TACTIC = (
	if not(is_var tm andalso type_of tm = Ü_type)
	then term_fail "INDUCTION_T" 38001 [tm]
	else (fn thmtac =>
		let fun aux_tac (gl as (asms, conc)) = (
			if not (is_free_in tm conc)
			then term_fail "INDUCTION_T" 38002 [tm]
			else if any asms (is_free_in tm)
			then	term_fail "INDUCTION_T" 38003 [tm]
			else let
				val abs = mk_simple_ç(tm, conc);
				val thm0 = (conv_rule
						(ONCE_MAP_C (simple_%beta%_conv))
						(simple_É_elim abs induction_thm));
				val thm1 = undisch_rule(conv_rule
	((RATOR_C o RAND_C o RAND_C o RAND_C)(simple_%alpha%_conv (fst(dest_var tm))))
						thm0);
				val thm2 = simple_É_elim tm thm1;
				val conc' = (hd (hyps thm2));
			in	([(asms, conc')],
				 (fn [th] => prove_asm_rule th thm2
				  | _ => bad_proof "INDUCTION_T"))
			end
		);
		in	aux_tac THEN Ä_tac THEN_LIST [id_tac, simple_É_tac THEN ä_T thmtac]
		end)
);
=TEX
=SML
fun ‚induction_tac· (tm : TERM) : TACTIC = (
	let	val tac = (INDUCTION_T tm strip_asm_tac);
	in	fn gl => (tac gl
			handle ex => pass_on ex "INDUCTION_T" "induction_tac")
	end handle ex => pass_on ex "INDUCTION_T" "induction_tac"
);
=TEX
=SML
val ‚plus1_lemma· = tac_proof(([], ªÉméSuc m = m + 1º), rewrite_tac[plus_def]);
val ‚plus1_conv· : CONV = (fn tm =>
	((suc_conv THEN_C simple_eq_match_conv plus1_lemma) tm)
	handle ex => pass_on ex "suc_conv" "plus1_conv");	
=TEX
\subsection{Arithmetic Relations}
We first define $û$ using an obvious definition as
characterising theorem. Then we define $ü$, $<$ and $>$
in terms of it.

=SML
val ‚le_def· = new_specification(["û"], 1, (
push_goal([], ª
	Ñ$û:ÜãÜãBOOLé Ém né m û n Ç Ñ i:Ü é m + i = n
º);
=TEX
=SML
a(simple_Ñ_tacªçm n é Ñ i:Ü é m + i = nº THEN rewrite_tac[]);
=TEX
=SML
pop_thm()
));
=TEX
=SML
val ‚ge_def· = new_specification(["ü"], 1, (
push_goal([], ª
	Ñ$ü:ÜãÜãBOOLé Ém né m ü n Ç n û m
º);
=TEX
=SML
a(simple_Ñ_tac ªçm né n û mº THEN rewrite_tac[]);
=TEX
=SML
pop_thm()
));
=TEX
=SML
val ‚lt_def· = new_specification(["<"], 1, (
push_goal([], ª
	Ñ$<:ÜãÜãBOOLé Ém né m < n Ç m + 1 û n
º);
=TEX
=SML
a(simple_Ñ_tac ªçm né m + 1 û nº THEN rewrite_tac[]);
=TEX
=SML
pop_thm()
));
=TEX
=SML
val ‚gt_def· = new_specification([">"], 1, (
push_goal([], ª
	Ñ$>:ÜãÜãBOOLé Ém né m > n Ç n < m
º);
=TEX
=SML
a(simple_Ñ_tac ªçm né n < mº THEN rewrite_tac[]);
=TEX
=SML
pop_thm()
));
=TEX
\subsection{Multiplication}
=SML
val ‚times_def· = new_specification(["*"], 1, (
push_goal([], ª
	Ñ$*:ÜãÜãÜé Ém né
		0 * n = 0
	Ä	(m + 1) * n = m * n + n
º);
=TEX
=SML
a(strip_asm_tac	(conv_rule all_simple_%beta%_conv
	(list_simple_É_elim
	[ªçn:Üé0º, ªçf:ÜãÜéçm:Üéçnéf n + n
º]
	(inst_type_rule[(ª:ÜãÜº, ª:'aº)]prim_rec_thm))));
a(simple_Ñ_tac ªf:ÜãÜãÜº);
a(asm_rewrite_tac[]);
=TEX
=SML
pop_thm()
));
=TEX
\subsection{Modulus}
We characterise $Mod$ by an odometer-style definition. This seems to be the
most straightforward way.
=SML
val ‚mod_def· = new_specification(["Mod"], 1, (
push_goal([], ª
	Ñ$Mod:ÜãÜãÜé Ém né
		0 < n ä
		0 Mod n = 0
	Ä	(m + 1) Mod n = if m Mod n + 1 < n then m Mod n + 1 else 0
º);
=TEX
=SML
a(strip_asm_tac	(conv_rule all_simple_%beta%_conv
	(list_simple_É_elim
	[ªçn:Üé0º, ªçf:ÜãÜéçm:Üéçnéif f n + 1 < n then f n + 1 else 0
º]
	(inst_type_rule[(ª:ÜãÜº, ª:'aº)]prim_rec_thm))));
a(simple_Ñ_tac ªf:ÜãÜãÜº);
a(asm_rewrite_tac[]);
=TEX
=SML
pop_thm()
));
=TEX
\subsection{Division}
We characterise $Div$ using $Mod$.
=SML
val ‚div_def· = new_specification(["Div"], 1, (
push_goal([], ª
	Ñ$Div:ÜãÜãÜé Ém né
		0 < n ä
		0 Div n = 0
	Ä	(m + 1) Div n = if m Mod n + 1 < n then m Div n else m Div n + 1
º);
=TEX
=SML
a(strip_asm_tac	(conv_rule all_simple_%beta%_conv
	(list_simple_É_elim
	[ªçn:Üé0º, ªçf:ÜãÜéçm:Üéçnéif m Mod n + 1 < n then f n else f n + 1
º]
	(inst_type_rule[(ª:ÜãÜº, ª:'aº)]prim_rec_thm))));
a(simple_Ñ_tac ªf:ÜãÜãÜº);
a(asm_rewrite_tac[]);
=TEX
=SML
pop_thm()
));
=TEX
\subsection{Associativity of $+$}

We wish to prove the associativity of $+$.

=SML
val ‚plus_assoc_thm· = (
push_goal([],ªÉ i m n é (i + m) + n  =  i + m + nº);
=TEX
=SML
a(strip_tac THEN induction_tac ªi:Üº THEN
	asm_rewrite_tac[plus_def]);
save_pop_thm"plus_assoc_thm"
);
=TEX
=SML
val ‚plus_assoc_thm1· = (
push_goal([],ªÉ i m n é i + m + n  =  (i + m) + nº);
=TEX
=SML
a(rewrite_tac[plus_assoc_thm]);
save_pop_thm"plus_assoc_thm1"
);
=TEX

\subsection{Commutativity of $+$}

We wish to prove the commutativity of $+$.
=SML
val ‚plus_comm_thm· = (
push_goal([],ªÉ m n é m + n  =  n + mº);
=TEX
=SML
a(MAP_EVERY (fn x => strip_tac THEN induction_tac x)[ªm:Üº,ªn:Üº]);
(* *** Goal "1" *** *)
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[plus_def]);
a(TOP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[plus_def]);
(* *** Goal "3" *** *)
a(rewrite_tac[plus_def]);
a(TOP_ASM_T (rewrite_thm_tac o simple_É_elimª0º));
a(rewrite_tac[plus_def]);
(* *** Goal "4" *** *)
a(rewrite_tac[plus_def]);
a(TOP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(once_rewrite_tac[plus_def]);
a(rewrite_tac[plus_assoc_thm]);
save_pop_thm"plus_comm_thm"
);
=TEX
=SML
val ‚plus_def1· = (
push_goal ([],ª
É m né m + 0 = m Ä m + (n + 1) = (m + n) + 1
º);
a(rewrite_tac[plus_assoc_thm]);
a(once_rewrite_tac[plus_comm_thm] THEN rewrite_tac[plus_def]);
pop_thm()
);
=TEX
\subsection{Reordering Sums}
If we specialise $i$ in the following theorem to $t$ say, repeated rewriting
with the resulting theorem will change any term of the form
$a + b + \ldots + t + \ldots$ into a term of the form $t + \ldots$.
=SML
val ‚plus_order_thm· = (
push_goal([], ªÉi m né
		m + i = i + m
	Ä	(i + m) + n = i + m + n
	Ä	m + i + n = i + m + n
º);
a(rewrite_tac[plus_assoc_thm, simple_É_elimªm:Üºplus_comm_thm]);
save_pop_thm"plus_order_thm"
);
=IGN
rewrite_conv[simple_É_elimª1ºplus_order_thm] ª
	(101 + 102) + 2 + 3 + (1 + 2 + 99) + (55 + 10) +
	(101 + 102) + 2 + 3 + (3 + 1 + 99) + (55 + 10) 
	º;
=TEX
\subsection{Cancellation Rules for $+$}
=SML
val ‚plus_lemma1· = (
push_goal([], ªÉmé
		m + 0 = m
	Ä	0 + m = m
º);
a(rewrite_tac[plus_def, plus_def1]);
pop_thm()
);
=TEX
=SML
val ‚plus_lemma2· = (
push_goal([], ªÉm né
		m + 1 = n + 1 Ç m = n
º);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac (list_simple_É_elim[ªm:Üº, ªn:Üº]one_one_plus1_thm));
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val ‚plus_lemma3· = (
push_goal([], ªå1 = 0º);
a(conv_tac (ONCE_MAP_C suc_conv) THEN rewrite_tac[å_suc_thm]);
pop_thm()
);
=TEX
=SML
val ‚plus_lemma4· = (
push_goal([], ªÉm ném + n = 0 Ç m = 0 Ä n = 0º);
a(strip_tac THEN strip_tac THEN induction_tacªn:Üº
	THEN asm_rewrite_tac[plus_assoc_thm1, å_plus1_thm, plus_lemma1, plus_lemma3]);
pop_thm()
);
=TEX
=SML
val ‚plus_lemma5· = (
push_goal([], ªÉm n ié
		(m + i = n + i Ç m = n)
	Ä	(m + i = i Ç m = 0)
º);
a(REPEAT strip_tac THEN TRY_T (asm_rewrite_tac[plus_lemma1])
	THEN POP_ASM_T ante_tac THEN induction_tacªi:Üº
	THEN asm_rewrite_tac[plus_lemma1, plus_assoc_thm1, plus_lemma2]);
pop_thm()
);
=SML
val ‚plus_clauses· = (
push_goal([], ªÉm n ié
		(m + i = n + i Ç m = n)
	Ä	(i + m = n + i Ç m = n)
	Ä	(m + i = i + n Ç m = n)
	Ä	(i + m = i + n Ç m = n)
	Ä	(m + i = i Ç m = 0)
	Ä	(i + m = i Ç m = 0)
	Ä	(i = i + n Ç n = 0)
	Ä	(i = n + i Ç n = 0)
	Ä	(m + i = 0 Ç m = 0 Ä i = 0)
	Ä	(m + 0 = m Ä 0 + m = m)
	Ä	å1 = 0
	Ä	å0 = 1
º);
a(rewrite_tac[eq_sym_convª0 = 1º, eq_sym_convªi = n + iº,
	simple_É_elimªi:Üº plus_comm_thm,
	plus_lemma1, plus_lemma2, plus_lemma3, plus_lemma4, plus_lemma5]);
save_pop_thm"plus_clauses"
);
=TEX
\subsection{Transitivity for $û$ and $<$}
=SML
val ‚le_trans_thm· = (
push_goal([], ªÉm i ném û i Ä  i û n ä m û nº);
a(rewrite_tac[le_def] THEN REPEAT strip_tac);
a(simple_Ñ_tacªi' + i''º THEN asm_rewrite_tac[plus_assoc_thm1]);
save_pop_thm"le_trans_thm"
);
=TEX
=SML
val ‚lt_trans_thm· = (
push_goal([], ªÉm i ném < i Ä  i < n ä m < nº);
a(rewrite_tac[le_def, lt_def] THEN REPEAT strip_tac);
a(simple_Ñ_tacªi' + 1 + i''º THEN asm_rewrite_tac[plus_assoc_thm1]);
save_pop_thm"lt_trans_thm"
);
=TEX
\subsection{Cancellation Rules for $û$}
=SML
val ‚le_lemma1· = (
push_goal([], ªÉm n iém + i û  n + i Ç m û nº);
a(rewrite_tac[le_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(simple_Ñ_tacªi':Üº THEN POP_ASM_T ante_tac
	THEN rewrite_tac[plus_assoc_thm, simple_É_elimªi:Üº plus_comm_thm]);
a(rewrite_tac[plus_assoc_thm1, plus_clauses]);
(* *** Goal "2" *** *)
a(simple_Ñ_tacªi':Üº THEN rewrite_tac[plus_assoc_thm, simple_É_elimªi:Üº plus_comm_thm]);
a(asm_rewrite_tac[plus_assoc_thm1]);
pop_thm()
);
=TEX
=SML
val ‚le_lemma2· = (
push_goal([], ªÉmé0 û m Ä å1 û 0º);
a(rewrite_tac[le_def] THEN REPEAT strip_tac);
a(simple_Ñ_tacªm:Üº THEN rewrite_tac[plus_clauses]);
a(rewrite_tac[plus_clauses]);
pop_thm()
);
=TEX
=SML
val ‚le_lemma3· = (
push_goal([], ªÉm ié m + i û i Ç m = 0º);
a(rewrite_tac[le_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN
	rewrite_tac[simple_É_elimªm:Üº plus_comm_thm,
		plus_assoc_thm, plus_clauses] THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(simple_Ñ_tacª0º THEN asm_rewrite_tac[plus_clauses]);
pop_thm()
);
=TEX
=SML
val ‚le_lemma4· = (
push_goal([], ªÉm ié m û m + iº);
a(rewrite_tac[le_def] THEN REPEAT strip_tac THEN simple_Ñ_tacªi:Üº
	THEN rewrite_tac[plus_clauses]);
pop_thm()
);
=TEX
=SML
val ‚le_lemma5· = (
push_goal([], ªÉm iém + i û 0 Ç m = 0 Ä i = 0º);
a(rewrite_tac[le_def, plus_clauses] THEN REPEAT strip_tac);
a(simple_Ñ_tacª0º THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val ‚le_lemma6· = (
push_goal([], ªÉmém û mº);
a(rewrite_tac[le_def] THEN REPEAT strip_tac THEN simple_Ñ_tacª0º
	THEN rewrite_tac[plus_clauses]);
pop_thm()
);
=TEX
=SML
val ‚le_lemma7· = (
push_goal([], ªÉmém û 0 Ç m = 0º);
a(rewrite_tac[le_def] THEN REPEAT strip_tac);
a(all_undisch_tac THEN rewrite_tac[plus_clauses] THEN REPEAT strip_tac);
a(simple_Ñ_tacª0º THEN asm_rewrite_tac[plus_clauses]);
pop_thm()
);
=TEX
=SML
val ‚le_clauses· = (
push_goal([], ªÉm n ié
		(m + i û n + i Ç m û n)
	Ä	(i + m û n + i Ç m û n)
	Ä	(m + i û i + n Ç m û n)
	Ä	(i + m û i + n Ç m û n)
	Ä	(m + i û i Ç m = 0)
	Ä	(i + m û i Ç m = 0)
	Ä	(m + i û 0 Ç m = 0 Ä i = 0)
	Ä	(m û 0 Ç m = 0)
	Ä	m û m + i
	Ä	m û i + m
	Ä	m û m
	Ä	0 û m
	Ä	å1 û 0
º);
a(rewrite_tac[simple_É_elimªi:Üº plus_comm_thm,
	le_lemma1, le_lemma2, le_lemma3, le_lemma4, le_lemma5, le_lemma6, le_lemma7]);
save_pop_thm"le_clauses"
);
=TEX
\subsection{Cancellation Rules for $<$}
=TEX
=SML
val ‚lt_clauses· = (
push_goal([], ªÉm n ié
		(m + i < n + i Ç m < n)
	Ä	(i + m < n + i Ç m < n)
	Ä	(m + i < i + n Ç m < n)
	Ä	(i + m < i + n Ç m < n)
	Ä	(m < m + i Ç 0 < i)
	Ä	(m < i + m Ç 0 < i)
	Ä	åm + i < m
	Ä	åm + i < i
	Ä	åm < 0
	Ä	åm < m
	Ä	0 < m + 1
	Ä	0 < 1 + m
	Ä	0 < 1
º);
a(rewrite_tac[lt_def, simple_É_elimªi:Üº plus_order_thm, le_clauses, plus_clauses]);
a(rewrite_tac[simple_É_elimªm:Üº plus_order_thm, le_clauses, plus_clauses]);
save_pop_thm"lt_clauses"
);
=TEX
\subsection{Case Analysis Etc.}
=SML
val ‚Ü_cases_thm· = (
push_goal([], ªÉmé m = 0 Å Ñié m = i + 1º);
a(strip_tac THEN induction_tacªm:Üº THEN asm_rewrite_tac[plus_clauses]);
a(simple_Ñ_tacª0º THEN rewrite_tac[]);
a(simple_Ñ_tacªm:Üº THEN rewrite_tac[]);
save_pop_thm"Ü_cases_thm"
);
=TEX
=SML
val ‚le_cases_thm· = (
push_goal([], ªÉm ném û n Å n û mº);
a(rewrite_tac[le_def] THEN REPEAT_N 2 strip_tac THEN induction_tacªm:Üº
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (ante_tac o simple_É_elimªn:Üº) THEN rewrite_tac[plus_clauses]);
(* *** Goal "2" *** *)
a(strip_asm_tac(simple_É_elimªi:Üº Ü_cases_thm));
(* *** Goal "2.1" *** *)
a(simple_Ñ_tacª1º THEN undisch_tacªm + i = nº THEN asm_rewrite_tac[plus_clauses]);
a(ä_T rewrite_thm_tac);
(* *** Goal "2.2" *** *)
a(undisch_tacªm + i = nº THEN
	POP_ASM_T (rewrite_thm_tac o once_rewrite_rule[plus_comm_thm])
	THEN asm_rewrite_tac[plus_assoc_thm1]);
(* *** Goal "3" *** *)
a(simple_Ñ_tacªi+1º THEN asm_rewrite_tac[plus_assoc_thm1]);
save_pop_thm"le_cases_thm"
);
=TEX
=SML
val ‚le_plus1_thm· = (
push_goal([], ªÉm ném û n + 1 Ç m = n + 1 Å m û nº);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_undisch_tac THEN rewrite_tac[le_def] THEN REPEAT strip_tac);
a(strip_asm_tac(simple_É_elimªi:Üº Ü_cases_thm));
(* *** Goal "1.1" *** *)
a(undisch_tacªm + i = n + 1º THEN asm_rewrite_tac[plus_clauses]);
(* *** Goal "1.2" *** *)
a(simple_Ñ_tacªi':Üº);
a(undisch_tacªm + i = n + 1º THEN asm_rewrite_tac[plus_clauses, plus_assoc_thm1]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[le_clauses]);
(* *** Goal "3" *** *)
a(lemma_tacªn û n + 1º);
a(asm_rewrite_tac[le_clauses]);
a(strip_asm_tac(list_simple_É_elim[ªm:Üº, ªn:Üº, ªn+1º] le_trans_thm));
save_pop_thm"le_plus1_thm"
);
=TEX
=SML
val ‚plus1_le_thm· = (
push_goal([], ªÉm ném + 1 û n Ç m û n Ä åm = nº);
a(rewrite_tac[le_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(simple_Ñ_tacª1+iº THEN asm_rewrite_tac[plus_assoc_thm1]);
(* *** Goal "2" *** *)
a(c_contr_tac THEN undisch_tacª(m + 1) + i = nº THEN
	asm_rewrite_tac[plus_assoc_thm, plus_clauses]);
(* *** Goal "3" *** *)
a(strip_asm_tac(simple_É_elimªiºÜ_cases_thm));
(* *** Goal "3.1" *** *)
a(undisch_tacªm + i = nº THEN asm_rewrite_tac[plus_clauses]);
(* *** Goal "3.2" *** *)
a(simple_Ñ_tacªi'º THEN undisch_tacªm + i = nº);
a(asm_rewrite_tac[plus_assoc_thm, simple_É_elimª1º plus_comm_thm]);
save_pop_thm"plus1_le_thm"
);
=TEX
=SML
val ‚å_plus1_le_thm· = (
push_goal([], ªÉm néåm + 1 û n Ç n û mº);
a(rewrite_tac[le_def] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_undisch_tac THEN induction_tacªn:Üº);
(* *** Goal "1.1" *** *)
a(rewrite_tac[plus_clauses] THEN simple_Ñ_tacªm:Üº THEN rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(REPEAT strip_tac);
a(LEMMA_T ª(m+1)+i+1 = n+1º ante_tac);
(* *** Goal "1.2.1" *** *)
a(GET_NTH_ASM_T 2 (fn th=>rewrite_tac[plus_assoc_thm1, th]));
(* *** Goal "1.2.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "1.3" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(simple_É_elimªiºÜ_cases_thm));
(* *** Goal "1.3.1" *** *)
a(undisch_tac ªn + i = mº THEN asm_rewrite_tac[plus_clauses] THEN strip_tac);
a(LEMMA_Tª(m+1)+0 = n+1º ante_tac);
a(DROP_NTH_ASM_T 3 (fn _ => id_tac) THEN asm_rewrite_tac[plus_clauses]);
a(asm_rewrite_tac[]);
(* *** Goal "1.3.2" *** *)
a(simple_Ñ_tacªi'º THEN undisch_tac ªn + i = mº THEN
	asm_rewrite_tac[plus_assoc_thm, simple_É_elimª1º plus_comm_thm]);
(* *** Goal "2" *** *)
a(C_CONTR_T (asm_tac o eq_sym_rule o rewrite_rule[]));
a(undisch_tac ªn + i = mº THEN asm_rewrite_tac[plus_clauses, plus_assoc_thm]);
save_pop_thm"å_plus1_le_thm"
);
=TEX
=SML
val ‚lt_cases_thm· = (
push_goal([], ªÉm ném < n Å m = n Å n < mº);
a(rewrite_tac[lt_def] THEN REPEAT strip_tac);
a(rewrite_tac[plus1_le_thm] THEN conv_tac(ONCE_MAP_C eq_sym_conv));
a(undisch_tac ªå m + 1 û nº THEN asm_rewrite_tac[å_plus1_le_thm]);
save_pop_thm"lt_cases_thm"
);
=TEX
=SML
val ‚å_lt_plus1_thm· = (
push_goal([], ªÉm néåm < n + 1 Ç n < mº);
a(rewrite_tac[lt_def, å_plus1_le_thm]);
save_pop_thm"å_lt_plus1_thm"
);
=TEX
=SML
val ‚lt_plus1_thm· = (
push_goal([], ªÉm ném < n + 1 Ç m = n Å m < nº);
a(rewrite_tac[lt_def, le_plus1_thm, plus_clauses]);
save_pop_thm"lt_plus1_thm"
);
=TEX
=SML
val ‚plus1_lt_thm· = (
push_goal([], ªÉm ném + 1 < n Ç m < n Ä åm + 1 = nº);
a(rewrite_tac[lt_def, plus1_le_thm, plus_clauses] THEN REPEAT strip_tac);
save_pop_thm"plus1_lt_thm"
);
=TEX
=SML
val ‚le_antisym_thm· = (
push_goal([], ªÉm ném û n Ä n û m Ç m = nº);
a(REPEAT strip_tac THEN TRY_T(asm_rewrite_tac[le_clauses]));
a(all_undisch_tac THEN asm_rewrite_tac[le_def] THEN REPEAT strip_tac);
a(POP_ASM_T (fn th => all_undisch_tac THEN
		rewrite_tac[eq_sym_rule th, plus_assoc_thm, plus_clauses] THEN
		REPEAT strip_tac));
save_pop_thm"le_antisym_thm"
);
==TEX
=SML
val ‚lt_irrefl_thm· = (
push_goal([], ªÉm néå(m < n Ä n < m)º);
a(rewrite_tac[lt_def, le_def] THEN REPEAT strip_tac);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule) THEN
	rewrite_tac[plus_assoc_thm, plus_clauses]);
save_pop_thm"lt_irrefl_thm"
);
=TEX
\subsection{Complete Induction}
=SML
val ‚cov_induction_thm· = (
push_goal([], ªÉpé(Éné(Émém < n ä p m) ä p n) ä (Énép n)º);
a(REPEAT strip_tac);
a(lemma_tacªÉmém < n ä p mº);
(* *** Goal "1" *** *)
a(induction_tacªn:Üº);
(* *** Goal "1.1" *** *)
a(rewrite_tac[lt_clauses]);
(* *** Goal "1.2" *** *)
a(rewrite_tac[lt_plus1_thm] THEN REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(POP_ASM_T rewrite_thm_tac THEN POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
save_pop_thm"cov_induction_thm"
);
=TEX
=SML
fun ‚COV_INDUCTION_T· (tm : TERM) : (THM -> TACTIC) -> TACTIC = (
	if not(is_var tm andalso type_of tm = Ü_type)
	then term_fail "COV_INDUCTION_T" 38001 [tm]
	else (fn thmtac =>
		 let fun aux_tac (gl as (asms, conc)) = (
			if not (is_free_in tm conc)
			then term_fail "COV_INDUCTION_T" 38002 [tm]
			else if any asms (is_free_in tm)
			then	term_fail "COV_INDUCTION_T" 38003 [tm]
			else let
				val abs = mk_simple_ç(tm, conc);
				val thm0 = (conv_rule
						(ONCE_MAP_C (simple_%beta%_conv))
						(simple_É_elim abs cov_induction_thm));
				val thm1 = undisch_rule(conv_rule
	((RATOR_C o RAND_C o RAND_C)(simple_%alpha%_conv (fst(dest_var tm))))
						thm0);
				val thm2 = simple_É_elim tm thm1;
				val conc' = (hd (hyps thm2));
			in	([(asms, conc')],
				 (fn [th] => prove_asm_rule th thm2
				  | _ => bad_proof "COV_INDUCTION_T"))
			end
		);
		in	aux_tac THEN simple_É_tac THEN ä_T thmtac
		end)
);
=TEX
=SML
fun ‚cov_induction_tac· (tm : TERM) : TACTIC = (
	let	val tac = (COV_INDUCTION_T tm strip_asm_tac);
	in	fn gl => (tac gl
			handle ex => pass_on ex
				"COV_INDUCTION_T" "cov_induction_tac")
	end handle ex => pass_on ex "COV_INDUCTION_T" "cov_induction_tac"
);
=TEX
=SML
val ‚lt_well_order_thm· = (
push_goal([], ªÉpé(Ñiép i) Ç Ñmé p m Ä Éié p i ä åi < mº);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(undisch_tacªp iº THEN cov_induction_tacªiº);
a(strip_tac THEN cases_tacªÑnén < i Ä p nº);
(* *** Goal "1.1" *** *)
a(GET_NTH_ASM_T 4 (strip_asm_tac o simple_É_elim ªnº));
a(simple_Ñ_tacªmº THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(simple_Ñ_tacªiº THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 2 (strip_asm_tac o simple_É_elim ªi'º));
(* *** Goal "2" *** *)
a(simple_Ñ_tacªmº THEN asm_rewrite_tac[]);
save_pop_thm"lt_well_order_thm"
);
=TEX
=SML
val ‚å_lt_thm· = (
push_goal([], ªÉm né åm < n Ç n û mº);
a(rewrite_tac[lt_def, å_plus1_le_thm]);
save_pop_thm"å_lt_thm"
);
=TEX
=SML
val ‚å_le_thm· = (
push_goal([], ªÉm né åm û n Ç n < mº);
a(REPEAT strip_tac THEN strip_asm_tac(list_simple_É_elim[ªn:Üº, ªm:Üº]å_lt_thm));
save_pop_thm"å_le_thm"
);
=TEX
=SML
val ‚le_well_order_thm· = (
push_goal([], ªÉpé(Ñiép i) Ç Ñmé p m Ä Éié p i ä m û iº);
a(accept_tac (rewrite_rule[å_lt_thm]lt_well_order_thm));
save_pop_thm"le_well_order_thm"
);
=TEX
\subsection{Theorems on Multiplication}
=TEX
=SML
val ‚times_lemma1· = (
push_goal([], ªÉmé m * 0 = 0º);
a(strip_tac THEN induction_tacªm:Üº THEN asm_rewrite_tac[times_def, plus_clauses]);
pop_thm()
);
=TEX
=SML
val ‚times_lemma2· = (
push_goal([], ªÉm né m * (n + 1) = m * n + mº);
a(strip_tac THEN induction_tacªm:Üº THEN asm_rewrite_tac[times_def, plus_clauses]);
a(rewrite_tac[plus_assoc_thm1, plus_clauses]);
a(rewrite_tac[plus_assoc_thm, plus_clauses]);
pop_thm()
);
=TEX
=SML
val ‚times_comm_thm· = (
push_goal([], ªÉm né m * n = n * mº);
a(strip_tac THEN induction_tacªm:Üº THEN rewrite_tac[times_def, times_lemma1]);
a(asm_rewrite_tac[times_lemma2]);
save_pop_thm"times_comm_thm"
);
=TEX
=SML
val ‚times_lemma3· = (
push_goal([], ªÉi m né (i + m) * n = i * n + m * nº);
a(strip_tac THEN induction_tacªi:Üº THEN rewrite_tac[times_def, plus_clauses]);
a(LEMMA_TªÉi m'é(i + 1) + m' = (i + m') + 1º rewrite_thm_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[plus_assoc_thm, plus_clauses]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[times_def, plus_assoc_thm, plus_clauses]);
pop_thm()
);
=TEX
=SML
val ‚times_assoc_thm· = (
push_goal([], ªÉi m né (i * m) * n = i * (m * n)º);
a(strip_tac THEN induction_tacªi:Üº THEN rewrite_tac[times_def]);
a(asm_rewrite_tac[times_lemma3, plus_clauses]);
save_pop_thm"times_assoc_thm"
);
=TEX
=SML
val ‚times_plus_distrib_thm· = (
push_goal([], ªÉi m né
		(i + m) * n = i * n + m * n
	Ä	i * (m + n) = i * m + i * nº);
a(rewrite_tac[times_lemma3]);
a(rewrite_tac[simple_É_elimªi:Üº times_comm_thm, times_lemma3]);
save_pop_thm"times_plus_distrib_thm"
);
=TEX
=SML
val ‚times_lemma4· = (
push_goal([], ªÉmé 1 * m  = mº);
a(conv_tac (ONCE_MAP_C plus1_conv) THEN rewrite_tac[times_def, plus_clauses]);
pop_thm()
);
=TEX
=SML
val ‚times_clauses· = (
push_goal([], ªÉmé
		m * 0 = 0
	Ä	0 * m = 0
	Ä	m * 1 = m
	Ä	1 * m = mº);
a(rewrite_tac[
	simple_É_elimªm:Üº times_comm_thm,
	times_def, times_lemma4]); 
save_pop_thm"times_clauses"
);
=TEX
\subsection{Theorems on Division and Modulus}
=TEX
=SML
val ‚mod_lt_thm· = (
push_goal([], ªÉm né 0 < n ä m Mod n < nº);
a(strip_tac THEN strip_tac THEN induction_tacªm:Üº);
(* *** Goal "1" *** *)
a(strip_tac THEN strip_asm_tac (all_simple_É_elim mod_def)
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(strip_tac);
(* *** Goal "3" *** *)
a(strip_tac THEN strip_asm_tac (all_simple_É_elim mod_def)
	THEN asm_rewrite_tac[]);
a(CASES_T ªm Mod n + 1 < nº asm_rewrite_thm_tac);
save_pop_thm"mod_lt_thm"
);
=TEX
=SML
val ‚div_mod_thm· = (
push_goal([], ªÉm né 0 < n ä m = (m Div n) * n + m Mod nº);
a(strip_tac THEN strip_tac THEN induction_tacªm:Üº);
(* *** Goal "1" *** *)
a(strip_tac THEN strip_asm_tac (all_simple_É_elim mod_def)
	THEN strip_asm_tac (all_simple_É_elim div_def)
	THEN asm_rewrite_tac[times_def, plus_clauses]);
(* *** Goal "2" *** *)
a(strip_tac);
(* *** Goal "3" *** *)
a(strip_tac THEN strip_asm_tac (all_simple_É_elim mod_def)
	THEN strip_asm_tac (all_simple_É_elim div_def));
a(REPEAT_N 4 (POP_ASM_T (TRY_T o rewrite_thm_tac)));
a(CASES_Tªm Mod n + 1 < nº (fn th => rewrite_tac[th] THEN asm_tac th));
(* *** Goal "3.1" *** *)
a(rewrite_tac[plus_assoc_thm1, plus_clauses] THEN strip_tac);
(* *** Goal "3.2" *** *)
a(strip_asm_tac (list_simple_É_elim[ªmº, ªnº] mod_lt_thm));
a(DROP_ASM_T ªåm Mod n + 1 < nº (strip_asm_tac o rewrite_rule[plus1_lt_thm]));
a(rewrite_tac[times_def, plus_clauses]);
a(LEMMA_T ªm + 1 = (m Div n) * n + m Mod n + 1º
	(fn th => rewrite_tac[th, plus_clauses] THEN strip_tac));
a(rewrite_tac[plus_assoc_thm1, plus_clauses] THEN strip_tac);
save_pop_thm"div_mod_thm"
);
=SML
val ‚lt_lemma1· = (
push_goal([], ªÉm né m < n ä 0 < nº);
a(rewrite_tac[lt_def, le_def] THEN REPEAT strip_tac);
a(simple_Ñ_tacªm+iº THEN
	LEMMA_Tª(0 + 1) + (m + i) = (m + 1) + iº asm_rewrite_thm_tac);
a(rewrite_tac[plus_clauses, plus_assoc_thm1]);
pop_thm()
);
=TEX
=SML
val ‚mod_lemma1· = (
push_goal([], ªÉm né m < n ä m Mod n = mº);
a(REPEAT simple_É_tac THEN induction_tacªm:Üº);
(* *** Goal "1" *** *)
a(strip_tac THEN strip_asm_tac(all_simple_É_elim mod_def));
(* *** Goal "2" *** *)
a(strip_tac THEN lemma_tac ªm + 1 < n ä m < nº);
a(strip_asm_tac (list_simple_É_elim[ªmº, ªm+1º, ªnº]lt_trans_thm));
a(undisch_tacªå m < m + 1º THEN rewrite_tac[lt_clauses]);
(* *** Goal "3" *** *)
a(strip_tac THEN strip_asm_tac(list_simple_É_elim[ªm + 1º, ªnº]lt_lemma1));
a(strip_asm_tac (simple_É_introªm:Üº(undisch_rule(all_simple_É_elim mod_def))));
a(asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val ‚mod_lemma2· = (
push_goal([], ªÉné 0 < n ä n Mod n = 0º);
a(REPEAT strip_tac);
a(lemma_tacªÑién Mod n = (i + 1) Mod n Ä i < n Ä i Mod n + 1 = nº);
(* *** Goal "1" *** *)
a(POP_ASM_T(strip_asm_tac o rewrite_rule
		[lt_def, le_def, plus_clauses, simple_É_elimª1ºplus_comm_thm]));
a(simple_Ñ_tac ªiº THEN asm_rewrite_tac[]);
a(lemma_tacªi < nº);
(* *** Goal "1.1" *** *)
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule) THEN rewrite_tac[lt_clauses]);
(* *** Goal "1.2" *** *)
a(strip_tac THEN strip_asm_tac (list_simple_É_elim[ªiº, ªnº]mod_lemma1));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac(list_simple_É_elim[ªiº, ªnº]mod_def));
a(asm_rewrite_tac[lt_clauses]);
pop_thm()
);
=TEX
=SML
val ‚mod_lemma3· = (
push_goal([], ªÉm né 0 < n ä (m + n) Mod n = m Mod nº);
a(REPEAT strip_tac THEN 
	strip_asm_tac (simple_É_introªm:Üº(undisch_rule(all_simple_É_elim mod_def)))
	THEN induction_tacªm:Üº);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[plus_clauses]);
a(strip_asm_tac (simple_É_elim ªnº mod_lemma2));
a(LEMMA_Tª(m + 1) + n = (m + n) + 1º asm_rewrite_thm_tac);
a(rewrite_tac[plus_assoc_thm, plus_clauses]);
pop_thm()
);
=TEX
=SML
val ‚mod_lemma4· = (
push_goal([], ªÉm n ié 0 < n ä (m*n + i) Mod n = i Mod nº);
a(REPEAT strip_tac THEN induction_tacªm:Üº);
(* *** Goal "1" *** *)
a(rewrite_tac[times_clauses, plus_clauses]);
(* *** Goal "2" *** *)
a(LEMMA_Tª(m + 1) * n + i = (m * n + i) + nº rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac[times_plus_distrib_thm, plus_assoc_thm, plus_clauses, times_clauses]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac(list_simple_É_elim[ªm * n + iº, ªnº]mod_lemma3));
a(asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val ‚div_lemma1· = (
push_goal([], ªÉné 0 < n ä n Div n = 1º);
a(REPEAT strip_tac THEN
	STRIP_THM_THEN ante_tac(list_simple_É_elim[ªn:Üº, ªn:Üº] div_mod_thm));
a(strip_asm_tac(simple_É_elimªnº mod_lemma2) THEN POP_ASM_T rewrite_thm_tac);
a(strip_asm_tac(list_simple_É_elim[ªn Div nº, ª1º] lt_cases_thm) THEN c_contr_tac);
(* *** Goal "1" *** *)
a(lemma_tac ªn Div n = 0º);
(* *** Goal "1.1" *** *)
a(strip_asm_tac (simple_É_elimªn Div nº Ü_cases_thm));
a(undisch_tacªn Div n < 1º THEN asm_rewrite_tac[lt_clauses]);
(* *** Goal "1.2" *** *)
a(undisch_tacªn = (n Div n) * n + 0º THEN asm_rewrite_tac[plus_clauses, times_clauses]);
a(c_contr_tac THEN undisch_tacª0 < nº  THEN rewrite_tac[lt_def, le_def]
	THEN REPEAT strip_tac);
a(asm_rewrite_tac[plus_clauses]);
(* *** Goal "2" *** *)
a(undisch_tacª1 < n Div nº THEN
	rewrite_tac[lt_def, le_def, simple_É_elimªi:Üº plus_order_thm] THEN
	REPEAT strip_tac);
a(conv_tac (RAND_C eq_sym_conv));
a(c_contr_tac THEN undisch_tac ªn = (n Div n) * n + 0º);
a(asm_rewrite_tac[plus_clauses, times_plus_distrib_thm, times_clauses, plus_assoc_thm1]);
a(REPEAT strip_tac);
a(undisch_tac ª0 < nº THEN asm_rewrite_tac[lt_clauses]);
pop_thm()
);
=TEX
=SML
val ‚div_lemma2· = (
push_goal([], ªÉm né 0 < n ä (m + n) Div n = m Div n + 1º);
a(REPEAT strip_tac THEN 
	strip_asm_tac (simple_É_introªm:Üº(undisch_rule(all_simple_É_elim div_def)))
	THEN induction_tacªm:Üº);
(* *** Goal "1" *** *)
a(strip_asm_tac(simple_É_elimªnºdiv_lemma1) THEN asm_rewrite_tac[plus_clauses]);
(* *** Goal "2" *** *)
a(LEMMA_Tª(m + 1) + n = (m + n) + 1º rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(rewrite_tac [plus_assoc_thm, plus_clauses]);
(* *** Goal "2.2" *** *)
a(strip_asm_tac (simple_É_introªm:Üº(undisch_rule(all_simple_É_elim mod_lemma3))));
a(asm_rewrite_tac[]);
a(cases_tacªm Mod n + 1 < nº THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val ‚div_lemma3· = (
push_goal([], ªÉn ié i < n ä i Div n = 0º);
a(REPEAT strip_tac);
a(strip_asm_tac (list_simple_É_elim[ªiº, ªnº]lt_lemma1));
a(strip_asm_tac (simple_É_introªm:Üº(undisch_rule(all_simple_É_elim div_def))));
a(undisch_tacªi < nº THEN induction_tacªiº THEN asm_rewrite_tac[]
	THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tacªi < i + 1º);
(* *** Goal "1.1" *** *)
a(rewrite_tac[lt_clauses]);
(* *** Goal "1.2" *** *)
a(strip_asm_tac(list_simple_É_elim[ªiº, ªi + 1º, ªnº]lt_trans_thm));
(* *** Goal "2" *** *)
a(lemma_tacªi < nº);
(* *** Goal "2.1" *** *)
a(lemma_tacªi < i + 1º);
(* *** Goal "2.1.1" *** *)
a(rewrite_tac[lt_clauses]);
(* *** Goal "2.1.2" *** *)
a(strip_asm_tac(list_simple_É_elim[ªiº, ªi + 1º, ªnº]lt_trans_thm));
(* *** Goal "2.2" *** *)
a(strip_asm_tac(list_simple_É_elim[ªiº, ªnº]mod_lemma1));
a(asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val ‚div_lemma4· = (
push_goal([], ªÉm n ié i < n ä (m * n + i) Div n = mº);
a(REPEAT strip_tac THEN induction_tacªm:Üº);
(* *** Goal "1" *** *)
a(strip_asm_tac(list_simple_É_elim[ªnº, ªiº]div_lemma3));
a(asm_rewrite_tac[times_clauses, plus_clauses]);
(* *** Goal "2" *** *)
a(strip_asm_tac(list_simple_É_elim[ªiº, ªnº]lt_lemma1));
a(strip_asm_tac(list_simple_É_elim[ªm * n + iº, ªnº]div_lemma2));
a(LEMMA_Tª(m + 1) * n + i = (m * n + i) + nº asm_rewrite_thm_tac);
a(rewrite_tac[times_plus_distrib_thm, plus_assoc_thm, times_clauses, plus_clauses]);
pop_thm()
);
=TEX
=SML
val ‚div_mod_unique_thm· = (
push_goal([], ªÉm n d ré r < n ä (m = d * n + r ä d = m Div n Ä r = m Mod n)º);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(strip_asm_tac(list_simple_É_elim[ªdº, ªnº, ªrº]div_lemma4));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac(list_simple_É_elim[ªrº, ªnº]lt_lemma1));
a(strip_asm_tac(list_simple_É_elim[ªdº, ªnº, ªrº]mod_lemma4));
a(strip_asm_tac(list_simple_É_elim[ªrº, ªnº]mod_lemma1));
a(asm_rewrite_tac[]);
pop_thm()
);
=TEX
\subsection{Subtraction}
=SML
val ‚minus_def· = new_specification(["-"], 1, (
push_goal([], ª
	Ñ$-:ÜãÜãÜé Ém né
		(m + n) - n = m
º);
=TEX
=SML
a(strip_asm_tac	(conv_rule all_simple_%beta%_conv
	(list_simple_É_elim
	[ªçn:Üé0º, ªçf:ÜãÜéçm:Üéçnéif m < n then 0 else (f n) + 1º]
	(inst_type_rule[(ª:ÜãÜº, ª:'aº)]prim_rec_thm))));
a(simple_Ñ_tac ªf:ÜãÜãÜº);
a(strip_tac THEN strip_tac THEN induction_tacªm:Üº);
(* *** Goal "1" *** *)
a(rewrite_tac[plus_clauses] THEN induction_tacªnº THEN asm_rewrite_tac[lt_clauses]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[plus_def, lt_clauses]);
=TEX
=SML
pop_thm()
));
=TEX
=SML
val ‚minus_lemma1· = (
push_goal([], ªÉmé m - m = 0º);
a(LEMMA_T ªÉmé (0 + m) - m = 0º
	(rewrite_thm_tac o rewrite_rule[plus_clauses])
	THEN rewrite_tac[minus_def]);
pop_thm()
);
=TEX
=SML
val ‚minus_lemma2· = (
push_goal([], ªÉmé m - 0 = mº);
a(LEMMA_T ªÉmé (m + 0) - 0 = mº
	(rewrite_thm_tac o rewrite_rule[plus_clauses])
	THEN rewrite_tac[minus_def]);
pop_thm()
);
=TEX
=SML
val ‚minus_clauses· = (
push_goal([], ªÉm né
		m - m = 0
	Ä	m - 0 = m
	Ä	(m + n) - n = m
º);
a(rewrite_tac[minus_lemma1, minus_lemma2, minus_def]);
save_pop_thm"minus_clauses"
);
=TEX
\section{EPILOGUE}
=SML
end; (* of structure Ü *)
open Ü;
=TEX	

=TEX
\end{document}

