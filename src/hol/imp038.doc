=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FORMAL METHODS UNIT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Elementary Theory of Arithmetic}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP038}  %% Mandatory field
\def\SCCSversion{$Date$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    R.D.~Arthan \\ K.~Blackburn
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
First version.

\subsection{Changes forecast}

Under development, highly incomplete, totally volatile.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains parts of the ICL HOL
proof development system.
\subsection{Introduction}
=TEX
=SML
open_theory"pair";
new_theory"†";
=TEX
The following is the Cambridge $MP\_TAC$.
=SML
fun âante_tacá (thm : THM) : TACTIC = (fn (asms, conc) =>
	([(asms, mk_Š(concl thm, conc))],
	 fn [th] => Š_elim th thm | _ => bad_proof "ante_tac")
	handle ex => divert ex "mk_Š" "ante_tac" 99999 []	
);
=TEX
The following few tactics etc
is a simple means of using universally quantified theorems:
=SML
fun âSIMPLE_Š_THM_THENá (antes : THM list) (ttac : THM_TACTIC) : THM_TACTIC = (fn thm => 
	let	val concs = mapfilter (simple_Š_match_mp_rule thm) antes;
	in	EVERY(mapfilter ttac concs)
	end
);
=TEX
=SML
fun âSIMPLE_Š_THM_Tá (ttac : THM -> TACTIC) : THM -> TACTIC = (fn thm =>
	GET_ASMS_T (fn thms => SIMPLE_Š_THM_THEN thms ttac thm)
);
=TEX
=SML
val âsimple_Š_thm_tacá : THM -> TACTIC = SIMPLE_Š_THM_T strip_asm_tac;
=TEX
=SML
declare_prefix(110, "Œ");
=SML
push_goal([], »
„suc:IND‹IND; zero:INDŽ OneOne suc € (ƒxŽŒsuc x = zero)
¼);
a(strip_asm_tac infinity_axiom THEN simple_„_tac»f:IND‹IND¼ THEN asm_rewrite_tac[]);
a(undisch_tac»Œ Onto (f:IND‹IND)¼ THEN rewrite_tac[onto_def] THEN REPEAT strip_tac);
a(simple_„_tac»y:IND¼ THEN strip_tac THEN conv_tac(ONCE_MAP_C eq_sym_conv) THEN asm_rewrite_tac[]);
=TEX
=SML
val âlemma1á : THM = pop_thm();
=TEX
=SML
push_goal([], »
„Is_†_Rep:IND ‹ BOOLŽ
	„ zero sucŽ
		(Is_†_Rep zero € ƒnŽIs_†_Rep n Š Is_†_Rep(suc n))
	€	(ƒnŽIs_†_Rep n Š Œ suc n = zero)
	€	OneOne suc
	€	(ƒpŽ	p zero € (ƒmŽp m Š p (suc m))
		 Š	(ƒnŽIs_†_Rep n Š p n))
¼);
(* First bring in the lemma: *)
a(strip_asm_tac(rewrite_rule[one_one_def] lemma1));
(* Now exhibit the witnesses: *)
a(simple_„_tac»i:INDŽƒqŽ q zero € (ƒnŽ q n Š q (suc n)) Š q i¼);
a(simple_„_tac»zero:IND¼);
a(simple_„_tac»suc:IND‹IND¼);
(* Get rid of beta-redexes and strip the goal: *)
a(rewrite_tac[one_one_def] THEN REPEAT strip_tac);
(* 4 subgoals. 1: *)
a(DROP_NTH_ASM_T 3 (ante_tac o simple_all_ƒ_elim) THEN asm_rewrite_tac[]);
(* 2: *)
a(asm_rewrite_tac[]);
(* 3: *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* 4: *)
a(POP_ASM_T (ante_tac o simple_ƒ_elim»p:IND‹BOOL¼) THEN asm_rewrite_tac[]);
=TEX
=SML
val âis_†_rep_thmá : THM = pop_thm();
=TEX
=SML
val âis_†_rep_defá : THM = new_specification(["Is_†_Rep"], 1, is_†_rep_thm);
=SML
=TEX
=SML
push_goal([], »„x:INDŽ Is_†_Rep x¼);
a(strip_asm_tac is_†_rep_def);
a(simple_„_tac »zero:IND¼ THEN asm_rewrite_tac[]);
val â†_exist_thmá : THM = pop_thm();
=TEX
=SML
val â†_defá : THM = new_type_defn("†", "†", [], †_exist_thm);
=TEX
=SML
push_goal([], »
	„ Zero:†; Suc:† ‹ †Ž
		(ƒnŽ Œ Suc n = Zero)
	€	OneOne Suc
	€	(ƒpŽ p Zero € (ƒmŽp m Š p (Suc m)) Š (ƒnŽp n))
¼);
(* We use the type lemmas to bring abstraction and representation functions *)
(* for the new type into the assumptions: *)
a (strip_asm_tac (simple_Š_match_mp_rule type_lemmas_thm †_def));
a (strip_asm_tac (rewrite_rule[one_one_def] is_†_rep_def));
(* Now we can introduce the witnesses: *)
a (simple_„_tac »(abs:IND ‹ †)zero¼);
a (simple_„_tac »a:†Ž(abs:IND ‹ †)(suc((rep:† ‹ IND) a))¼);
a (asm_rewrite_tac[one_one_def] THEN REPEAT strip_tac);
(* 3 subgoals: 1: *)
a (lemma_tac »Is_†_Rep((rep:† ‹ IND) n)¼ THEN_LIST [asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so ony 1 subgoal *)
a (lemma_tac »Is_†_Rep(suc((rep:† ‹ IND)n))¼);
(* 1.1: *)
a (DROP_NTH_ASM_T 5 (ante_tac o simple_ƒ_elim»(rep:† ‹ IND)n¼) THEN
	REPEAT strip_tac);
(* 1.2: *)
a c_contr_tac;
a (lemma_tac»(rep:† ‹ IND)((abs:IND ‹ †)(suc(rep n)))= rep(abs zero)¼
	THEN_LIST [asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so ony 1 subgoal *)
a (GET_NTH_ASM_T 10 (ante_tac o simple_ƒ_elim»suc((rep:† ‹ IND)n):IND¼) THEN
	REPEAT strip_tac);
a (GET_NTH_ASM_T 11 (ante_tac o simple_ƒ_elim»zero:IND¼) THEN
	REPEAT strip_tac);
a (GET_NTH_ASM_T 9 (ante_tac o simple_ƒ_elim»((rep:† ‹ IND)n)¼) THEN
	REPEAT strip_tac);
a (GET_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* Completes 1.2 and 1. 2: *)
a (lemma_tac»(rep:† ‹ IND)x1 = rep x2¼);
(* 2.1: *)
a (lemma_tac»(suc:IND‹IND)((rep:† ‹ IND)x1) = suc(rep x2)¼);
(* 2.1.1: *)
a (DROP_NTH_ASM_T 5 ante_tac THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* only 1 subgoal. *)
a (lemma_tac »(rep:† ‹ IND)((abs:IND ‹ †)(rep x2)) = rep x2 € rep(abs(rep x1)) = rep x1¼
	THEN_LIST [asm_rewrite_tac[], id_tac]);
a (GET_NTH_ASM_T 3 (ante_tac o simple_ƒ_elim»(rep:† ‹ IND)x2¼) THEN
	REPEAT strip_tac);
a (GET_NTH_ASM_T 4 (ante_tac o simple_ƒ_elim»(rep:† ‹ IND)x1¼) THEN
	REPEAT strip_tac);
a (GET_NTH_ASM_T 6 (ante_tac o ap_fun_rule »rep:† ‹ IND¼) THEN asm_rewrite_tac[]);
(* Completes 2.1.1. 2.1.2: *)
a (GET_NTH_ASM_T 4 (ante_tac o simple_list_ƒ_elim[»(rep:† ‹ IND)x1¼, »(rep:† ‹ IND)x2¼]) THEN
	REPEAT strip_tac);
(* Completes 2.1.2. 2.2: *)
a (POP_ASM_T (ante_tac o ap_fun_rule »abs:IND ‹ †¼) THEN asm_rewrite_tac[]);
(* Completes 2. 3: *)
a (lemma_tac»ƒa:INDŽIs_†_Rep a Š Is_†_Rep a € p ((abs:IND ‹ †) a)¼);
(* 2 subgoals. 3.1: *)
a (lemma_tac»ƒa:INDŽIs_†_Rep a € p ((abs:IND ‹ †) a) Š
			Is_†_Rep (suc a) € p (abs (suc a))¼);
(* 2 subgoals. 3.1.1: *)
a (REPEAT strip_tac);
(* 2 subgoals. 3.1.1.1: *)
a (GET_NTH_ASM_T 2 (undisch_tac o concl) THEN asm_rewrite_tac[]);
(* Completes 3.1.1.1. 3.1.1.2: *)
a (GET_NTH_ASM_T 3 (ante_tac o simple_ƒ_elim»(abs:IND ‹ †)m¼));
a (GET_NTH_ASM_T 2 (undisch_tac o concl) THEN GET_NTH_ASM_T 9 rewrite_thm_tac);
a (strip_tac THEN asm_rewrite_tac[]);
a (GET_NTH_ASM_T 3 (ante_tac o simple_ƒ_elim»(abs:IND ‹ †)a¼) THEN 
	POP_ASM_T rewrite_thm_tac THEN REPEAT strip_tac);
(* Completes 3.1.1. 3.1.2: *)
a (GET_NTH_ASM_T 4 (ante_tac o simple_ƒ_elim»
	aŽ Is_†_Rep a € p ((abs:IND ‹ †) a)¼) THEN 
	conv_tac simple_all_%beta%_conv THEN taut_tac);
(* Completes 3.1. 3.2: *)
a (lemma_tac »Is_†_Rep ((rep:† ‹ IND) n)¼ THEN_LIST [asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so only one subgoal *)
a (GET_NTH_ASM_T 2 (ante_tac o simple_ƒ_elim»(rep:† ‹ IND) n¼)
	THEN GET_NTH_ASM_T 11 rewrite_thm_tac THEN REPEAT strip_tac);
=TEX
=SML
val âzero_suc_thmá : THM = pop_thm();
=TEX
$new\_specification$ may now be used to introduce the basic operations
on the natural numbers:
=SML
val âzero_suc_defá : THM = new_specification(["âZeroá", "âSucá"], 2, zero_suc_thm);
=TEX
=SML
val âzero_convá : CONV = ONCE_MAP_C (simple_eq_match_conv (eq_sym_rule(icl'Kernel.icl'suc_conv »0¼)));
=TEX
=SML
val âmk_0á = »0¼;
val âmk_†á = »:†¼;
=TEX
=SML
val âsuc_convá : CONV = (fn tm => 
	if tm = mk_0
	then fail "suc_conv" 99999 []
	else icl'Kernel.icl'suc_conv tm
);
=SML
val âŒ_suc_thmá = (conv_rule zero_conv)(€_left_elim zero_suc_def);
=TEX
=SML
val âone_one_suc_thmá = rewrite_rule[one_one_def] (€_left_elim (€_right_elim zero_suc_def));
=TEX
=SML
val âinduction_thmá = (conv_rule zero_conv)(€_right_elim (€_right_elim zero_suc_def));
=TEX
=SML
fun âinduction_tacá (tm : TERM) : TACTIC = (
	if not(is_var tm andalso type_of tm =  mk_†)
	then term_fail "induction_tac" 99999 [tm]
	else let fun aux_tac (gl as (asms, conc)) = (
			let	val abs = simple_mk_(tm, conc);
				val thm0 = (conv_rule
						(ONCE_MAP_C (simple_%beta%_conv))
						(simple_ƒ_elim abs induction_thm));
				val thm1 = undisch_rule(conv_rule
	((RATOR_C o RAND_C o RAND_C o RAND_C)(simple_%alpha%_conv (fst(dest_var tm))))
						thm0);
				val thm2 = simple_ƒ_elim tm thm1;
				val conc' = (hd (hyps thm2));
			in	([(asms, conc')],
				 (fn [th] => prove_asm_rule th thm2
				  | _ => bad_proof "induction_tac"))
			end
		);
	in	aux_tac THEN €_tac THEN_LIST [id_tac, simple_ƒ_tac THEN Š_tac]
	end
);
=TEX
\end{document}

=IGN
