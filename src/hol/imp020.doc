=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation for ICL HOL Symbol Table}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD020}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the implementation for the
symbol table module for ICL HOL.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library\\RDA\\AJH\\DJK}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue 1.3]
First draft for comment.
\item [Issue 1.4]
Corrected a use of $get\_const\_type$.
\item [Issue 1.5]
The name atom  ``definition(s)'' changed to ``defn(s)'', and
``constant(s)'' to ``const(s)''.

\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the symbol table module for ICL HOL.
The detailed design for this material is given in \cite{DS/FMU/IED/DTD020}.
\subsection{Introduction}
\subsection{Dependencies}
The symbol table module is dependent on the interface to the
abstract data type $THM$, \cite{DS/FMU/IED/IMP012}
and on the lexical analyser module, \cite{DS/FMU/IED/IMP015}.
\subsection{Algorithms}
The most straightforward implementation of the
design would simply define an encoding allowing finite functions
from identifiers to an appropriate record type to
be stored in a theory (as $USER\_DATA$) and would implement the various
access functions by direct access to the information stored in the theory.
However, this approach would be slow (since it would imply
linear table searches to find the information pertaining to an identifier)
and would also consume unnecessary space (since ``most'' identifiers do
not have any special properties, all we need to know about them is
already stored in the theory database). 

For the purposes of parsing, type inferring and pretty printing, the interrogative
functions:
$get\_terminators$, $get\_fixity$, $get\_const\_info$,
$get\_const\_type$, $resolve\_alias$, $get\_type\_info$,
$expand\_type\_abbrev$, $get\_language$ 
and, perhaps, $get\_sym\_tab\_info$, need to be quite fast.
Consequently, we maintain caches containing the 
information required to compute these functions
in the current context. As an optimisation (to the space usage) we do
not keep records for identifers with no special properties. The relevant
symbol table information for such an identifier may readily be computed
from the theory database as necessary.

We store in each theory an encoding of the
declarative operations ($declare\_terminator$, $declare\_infix$ etc.) which
have been made in the context of that theory.
Then, in essence, corresponding to each
declarative operation we define an operation on the cache and an operation
on the current theory. Thus a context change is effected by replaying
a sequence of operations on the cache which correspond to the declarations
which apply in that context. The declarative operations performed by the
user are implemented by performing the corresponding operations on both
the current theory and the cache,

\subsection{Possible Enhancements}
It is not yet known whether the encoding of symbol table information
in the theory database is adequately compact.
\subsection{Deficiencies}
It would be desirable for the symbol table module to check before
a type or constant was deleted whether or not there was an abbreviation
or alias in force relating to the type or constant. Implementing this would
require extensions to dtd012.

The treatment of languages is simply wrong at the moment.

\section{PREAMBLE}
=SML
structure SymbolTable : SymbolTable = struct
=SML
open Lex;
=TEX
\subsection{Utilities}
=TEX
$split_string\,sep\,s$ splits string into a list of strings treating
characters for which $sep$ returns true as separator characters.
Runs of more than one separator are treated like a single separator.
=SML
fun âsplit_stringá (sep : string -> bool) (s : string) = (
	let	fun aux words "" (ch :: more) = (
			if sep ch
			then aux words "" more
			else aux words ch more
		) | aux words word (ch :: more) = (
			if sep ch
			then aux (words @ [word]) "" more
			else aux words (word ^ ch) more
		) | aux words "" [] = (words
		) | aux words word [] = words @ [word];
	in	aux [] "" (explode s)
	end
);
=TEX
$words\,s$ splits $s$ into a list of  strings treating formatting characters
as separators.
=SML
val âwordsá : string -> string list = split_string is_space;
=TEX
$is\_same\_type\,ty1,\,ty2$ is true iff. $ty1$ and $ty2$ are the same
type modulo renaming of type variables.
=SML
fun âis_same_typeá (ty1:TYPE) (ty2:TYPE) : bool = (
	is_type_instance ty1 ty2 andalso is_type_instance ty2 ty1
);
=TEX
\section{TYPES}\label{TYPES}
In this section we give the Standard ML types used in the symbol table module.
\subsection{Visible Types}
=TEX
=SML
datatype âFIXITYá	=	âNonfixá
			|	âBinderá
			|	âInfixá of int
			|	âPrefixá of int
			|	âPostfixá of int;
=TEX
\subsection{Private Types}
The following datatype is used to encode the various declarative operations.
Note that:

\begin{enumerate}
\item
the various fixity operations are merged into a single case parameterised
by a $FIXITY$;
\item
there is no $UnDeclFixity$ --- this operation corresponds to a nonfix
declaration;
\item
the $set\_language$ operation is not catered for here.
\end{enumerate}
=SML
datatype âDECLá	=	âDeclTerminatorá of string
			|	âUnDeclTerminatorá of string
			|	âDeclFixityá of string * FIXITY
			|	âDeclAliasá of string * (string * TYPE)
			|	âUnDeclAliasá of string * (string * TYPE)
			|	âDeclTypeAbbrevá of string * (string list * TYPE)
			|	âUnDeclTypeAbbrevá of string
			|	âSetLanguageá of string;
=TEX
\section{THE CACHES AND THEIR ACCESS FUNCTIONS}
In this section we define the caches in which symbol table information relating
to the current context is stored for rapid access. We also define the
functions which read and write these caches (the read functions are part of
the visible interface).


=SML
val âty_info_cacheá : (int * (((string list) * TYPE)OPT)) E_DICT ref = ref initial_e_dict;
=TEX
=SML
val âconst_info_cacheá : (TYPE * ((string * TYPE)list)) E_DICT ref = ref initial_e_dict;
=TEX
=SML
val âfixity_cacheá : FIXITY E_DICT ref = ref initial_e_dict;
=TEX
=SML
val âterminatorsá : string list list ref = ref[];
=TEX
For uniformity, the current language is held in an assignable variable
(although it may fairly rapidly be computed from the theory database).
=SML
val âlanguageá : string ref = ref "HOL";
=TEX
The remaining caches are unlike the others in that their values are not
set by declarations but instead are calculated from the theory database
as theories are loaded.
=SML
val âconst_theory_cacheá : string E_DICT ref = ref initial_e_dict;
=TEX
=SML
val âty_theory_cacheá : string E_DICT ref = ref initial_e_dict;
=TEX
The following function restores the caches to their initial state:
=SML
fun âclear_cachesá (():unit) : unit = (
	ty_info_cache := initial_e_dict;
	const_info_cache := initial_e_dict;
	fixity_cache := initial_e_dict;
	terminators := [];
	language := "HOL";
	const_theory_cache := initial_e_dict;
	ty_theory_cache := initial_e_dict
);
=TEX
It is actually more convenient to have a single update function
parameterised by the type of declaration being made. This requires a few
local utilities to cope with the more complex cases:
=SML
local
=TEX
=SML
fun âcache_terminatorá (t : string) = (
	let	val et = explode t;
		val len = length et;
		fun aux [] = [et]
		|   aux (h :: more) = (
			if length h > len
			then h :: aux more
			else et :: h :: more
		);
	in	terminators := aux(!terminators)
	end
);
=TEX
=SML
fun âuncache_terminatorá (t : string) = (
	terminators := !terminators less explode t
);
=TEX
=SML
fun âcache_fixityá (s : string, fix : FIXITY) = (
	case fix of
		Nonfix => fixity_cache := e_delete s (!fixity_cache)
	|	_ => fixity_cache := e_enter s fix (!fixity_cache)
);
=TEX
=SML
fun âcache_aliasá (a : string, (s:string, ty : TYPE)) : unit = (
	const_info_cache :=
	e_enter
	a
	(case e_lookup a (!const_info_cache) of
		Value(ty', alinfs) => (
			 (Antiunify.antiunify(ty, ty'), (s, ty) :: alinfs)
	) |	Nil => (
			 (ty, [(s, ty)])
	))
	(!const_info_cache)
);
=TEX
We need to antiunify lists of types when aliases are deleted:
=SML
fun âlist_antiunifyá ([] : TYPE list) : TYPE = mk_vartype "'a"
|   list_antiunify [ty] = ty
|   list_antiunify (ty :: more) = Antiunify.antiunify(ty, list_antiunify more);
=TEX
=SML
fun âuncache_aliasá (a : string, (s:string, ty : TYPE)) : unit = (
	case e_lookup a (!const_info_cache) of
		Value(_, alinfs) => const_info_cache := (
			case alinfs drop 
					(fn(s', ty') => s = s' andalso is_same_type ty ty')
			of
				[] => e_delete a (!const_info_cache)
			|	some => e_enter a(list_antiunify (map snd some) , some)(!const_info_cache)
	) |	Nil => ( ()
	)
);
=TEX
=SML
fun âcache_type_abbrevá(a : string, (args : string list, ty : TYPE)) : unit = (
	ty_info_cache := e_enter a (length args, Value(args, ty)) (!ty_info_cache)
);
=TEX
=SML
fun âuncache_type_abbrevá(a : string) : unit = (
	case get_type_arity a of
		Nil => ty_info_cache := e_delete a (!ty_info_cache)
	|	Value ar => ty_info_cache := e_enter a (ar, Nil) (!ty_info_cache)
);
=TEX
=SML
fun âcache_languageá (lang : string) = (
	language := lang
);
=TEX
=SML
in
fun âcache_declá (dec : DECL) : unit = (
	case dec of
		DeclTerminator t => cache_terminator t
	|	UnDeclTerminator t => uncache_terminator t
	|	DeclFixity sfix  => cache_fixity sfix
	|	DeclAlias asty => cache_alias asty
	|	UnDeclAlias asty => uncache_alias asty
	|	DeclTypeAbbrev aargsty => cache_type_abbrev aargsty
	|	UnDeclTypeAbbrev  a => uncache_type_abbrev a
	|	SetLanguage lang => cache_language lang
);
end; (* of local ... in ... end *)
=TEX
\subsection{THEORY DATABASE ACCESS FUNCTIONS}
The symbol table module uses a single slot in the theory user data 
under the key ``icl'st'' to hold the declarations which apply
to the theory. The declarations are held as a fairly direct encoding
of a list of $DECL$s.

\subsection{Utilities For Accessing the User Data}
In this section we define the functions we use to fetch and store the
lists of $USER\_DATUM$s belonging to the symbol table held in theories.
=SML
val ud_key = "icl'st";
=TEX
=SML
fun fetch_sym_tab_data (thy : string) : USER_DATUM list = (
	if thy mem theory_names ()
	then	case get_user_datum thy ud_key handle Fail _ => UD_Int(0, []) of
			(UD_Int(0, uds)) => uds
		|	_ => fail "fetch_sym_tab_data" 20001 [fn()=>thy]
	else	fail "fetch_sym_tab_data" 20601 [fn()=>thy]
);
=TEX
The theory name argument to $store\_sym\_tab\_datum$ and
$delete\_sym\_tab\_datum$ are only used in error messages.
=SML
fun store_sym_tab_datum (ud : USER_DATUM) : unit = (
	let	val uds = (
			case get_user_datum "-" ud_key handle Fail _ => UD_Int(0, []) of
				(UD_Int(0, uds)) => uds
			|	_ => fail "fetch_sym_tab_data" 20001 [fn()=>"-"]);
	in 	set_user_datum(ud_key, UD_Int(0, ud :: uds))
	end
);
=TEX
We sometimes need to delete entries. $delete\_sym\_tab\_datum$
does this (and does nothing if the entry to be deleted is not there).
=SML
fun delete_sym_tab_datum (ud : USER_DATUM) : unit = (
	let	val uds = (
			case get_user_datum "-" ud_key handle Fail _ => UD_Int(0, []) of
				(UD_Int(0, uds)) => uds
			|	_ => fail "fetch_sym_tab_data" 20001 [fn()=>"-"])
	in 	set_user_datum(ud_key, UD_Int(0, uds less ud))
	end
);
=TEX
\subsection{Encoding and Decoding Functions}
First of all we give an encoding for $FIXITY$ values.
We encode constructors as small numbers, since on most Standard ML compilers
these are held in a single word of storage.
=SML
fun âencode_fixityá (fix : FIXITY) : USER_DATUM = (
	case fix of
		Nonfix => UD_Int(0, [])
	|	Binder => UD_Int(1, [])
	|	Infix p => UD_Int(2, [UD_Int(p, [])])
	|	Prefix p => UD_Int(3, [UD_Int(p, [])])
	|	Postfix p => UD_Int(4, [UD_Int(p, [])])
);
=TEX
=SML
fun âdecode_fixityá (ud : USER_DATUM) : FIXITY = (
	case ud of
		UD_Int(0, []) => Nonfix
	|	UD_Int(1, []) => Binder
	|	UD_Int(2, [UD_Int(p, [])]) => Infix p
	|	UD_Int(3, [UD_Int(p, [])]) => Prefix p
	|	UD_Int(4, [UD_Int(p, [])]) => Postfix p
	|	_ => fail "decode_fixity" 20001 []
);
=TEX
=SML
fun âencode_declá (dec : DECL) : USER_DATUM = (
	case dec of
		DeclTerminator t => UD_Int(0, [UD_String(t, [])])
	|	UnDeclTerminator t => UD_Int(1, [UD_String(t, [])])
	|	DeclFixity (s, fix)  => UD_Int(2, [UD_String(s, [encode_fixity fix])])
	|	DeclAlias (a, (s, ty)) =>
			UD_Int(3, [UD_String(a, [UD_String(s, [UD_Type(ty, [])])])])
	|	UnDeclAlias (a, (s, ty)) =>
			UD_Int(4, [UD_String(a, [UD_String(s, [UD_Type(ty, [])])])])
	|	DeclTypeAbbrev (a, (args, ty)) =>
			UD_Int(5, [UD_String(a, [UD_Type(ty, map ((switch(curry UD_String))[]) args)])])
	|	UnDeclTypeAbbrev a => UD_Int(6, [UD_String(a, [])])
	|	SetLanguage lang => UD_Int(7, [UD_String(lang, [])])
);
=TEX
=SML
fun âdecode_declá (thy : string) (ud : USER_DATUM) : DECL = (
	case ud of
		UD_Int(0, [UD_String(t, [])]) => DeclTerminator t
	|	UD_Int(1, [UD_String(t, [])]) => UnDeclTerminator t
	|	UD_Int(2, [UD_String(s, [fix])]) => DeclFixity (s, decode_fixity fix)
	|	UD_Int(3, [UD_String(a, [UD_String(s, [UD_Type(ty, [])])])]) => 
				DeclAlias (a, (s, ty))
	|	UD_Int(4, [UD_String(a, [UD_String(s, [UD_Type(ty, [])])])]) => 
				UnDeclAlias (a, (s, ty))
	|	UD_Int(5, [UD_String(a, [UD_Type(ty, args)])]) =>
			DeclTypeAbbrev (a, (map
				(fn UD_String(arg, []) => arg
				| _ => fail "decode_decl" 20001 [fn()=> thy]) args, ty))
	|	UD_Int(6, [UD_String(a, [])]) => UnDeclTypeAbbrev a
	|	UD_Int(7, [UD_String(lang, [])]) => SetLanguage lang
	|	_ => fail "decode_decl" 20001 [fn()=> thy]
);
=TEX
Occasionally we need to extract from a theory the
declarations relating to a particular name.
=SML
fun get_id_data (id : string) (thy : string) : USER_DATUM list = (
		fetch_sym_tab_data thy
	drop	(fn UD_Int(_, [UD_String(s, _)]) => s <> id | _ => true)
);
=TEX
\subsection{Update Functions}
As with the cache update functions, it is convenient to have a single update
function parameterised by the type of declaration being made.
As theory updates are never done without also updating the cache the theory
update function calls the cache update function when its own work is complete.
Again we have a section of local utilities to assist:
=SML
local
=TEX
=SML
fun store_terminator (thy : string) (s : string) : unit = (
	delete_sym_tab_datum (encode_decl(UnDeclTerminator s));
	store_sym_tab_datum (encode_decl(DeclTerminator s))
);
=TEX
=SML
fun unstore_terminator (thy : string) (s : string) : unit = (
	let	val uds = get_id_data s thy;
		fun aux ud = (
			case decode_decl thy ud of
				DeclTerminator s' => s' = s
			|	_ => false
		);
	in	if any uds aux
		then	delete_sym_tab_datum (find uds aux)
		else	store_sym_tab_datum (encode_decl(UnDeclTerminator s))
	end
);
=TEX
=SML
fun store_fixity (thy : string) (s : string, fix : FIXITY) : unit = (
	let	val uds = get_id_data s thy;
		fun aux ud = (
			case decode_decl thy ud of
				DeclFixity(s', _) => s' = s
			|	_ => false
		);
	in	if any uds aux
		then 	case fix of
				Nonfix => delete_sym_tab_datum (find uds aux)
			|	_ => (
					delete_sym_tab_datum (find uds aux);
					store_sym_tab_datum (encode_decl(DeclFixity (s, fix)))
			)
		else	store_sym_tab_datum (encode_decl(DeclFixity (s, fix)))
	end
);
=TEX
=SML
fun store_alias (thy : string) (a : string, (s:string, ty:TYPE)) : unit = (
	store_sym_tab_datum (encode_decl(DeclAlias (a, (s, ty))))
);
=TEX
=SML
fun unstore_alias (thy : string) (a : string, (s:string, ty:TYPE)) : unit = (
	let	val uds = get_id_data a thy;
		fun aux ud = (
			case decode_decl thy ud of
				DeclAlias(a', (s', ty')) => a = a' andalso s = s'
					andalso is_same_type ty ty' 
			|	_ => false
		);
	in	if any uds aux
		then	delete_sym_tab_datum (find uds aux)
		else	store_sym_tab_datum (encode_decl(DeclAlias (a, (s, ty))))
	end
);
=TEX
=SML
fun store_type_abbrev (thy : string) (a : string, (args:string list, ty:TYPE)) : unit = (
	let	val uds = get_id_data a thy;
		fun aux ud = (
			case decode_decl thy ud of
				DeclTypeAbbrev(a', _) => a = a'
			|	_ => false
		);
	in	if any uds aux
		then	delete_sym_tab_datum (find uds aux)
		else	()
	end;
	store_sym_tab_datum (encode_decl(DeclTypeAbbrev (a, (args, ty))))
);
=TEX
=SML
fun unstore_type_abbrev (thy : string) (a : string) : unit = (
	let	val uds = get_id_data a thy;
		fun aux ud = (
			case decode_decl thy ud of
				DeclTypeAbbrev(a', _) => a = a'
			|	_ => false
		);
	in	if any uds aux
		then	delete_sym_tab_datum (find uds aux)
		else	store_sym_tab_datum (encode_decl(UnDeclTypeAbbrev a))
	end
);
=TEX
=SML
fun store_language (thy : string) (lang : string) : unit = (
	let	val uds = fetch_sym_tab_data thy;
		fun aux ud = (
			case decode_decl thy ud of
				SetLanguage _ => true
			|	_ => false
		);
	in	if any uds aux
		then	delete_sym_tab_datum (find uds aux)
		else	()
	end;
	store_sym_tab_datum (encode_decl(SetLanguage lang))
);
=TEX
=SML
in
fun âstore_declá (area : string) (dec : DECL) : unit = (
	let	val thy = get_current_theory_name();
	in
		case get_current_theory_status() of
			TSNormal => (
				(case dec of
					DeclTerminator t => store_terminator thy t
				|	UnDeclTerminator t => unstore_terminator thy t
				|	DeclFixity sfix  => store_fixity thy sfix
				|	DeclAlias asty => store_alias thy asty
				|	UnDeclAlias asty => unstore_alias thy asty
				|	DeclTypeAbbrev aargsty => store_type_abbrev thy aargsty
				|	UnDeclTypeAbbrev  a => unstore_type_abbrev thy a
				|	SetLanguage lang => store_language thy lang);
				cache_decl dec
		) |	_ => fail area 20002 [fn () => thy]
	end
);
end; (* of local ... in ... end *)
=TEX
=TEX
\section{ACCESS FUNCTIONS}
\subsection{Terminators}
=SML
fun âget_terminatorsá (():unit) : string list list =(
	!terminators
);
=TEX
The following function checks that a string obeys the rules for terminators
identified in \cite{DS/FMU/IED/DEF001}. 
=SML
fun is_ok_terminator (s : string) = (
	let	fun strip_macro (s :: more) = (
			if is_macro s
			then more
			else strip_macro more
		) | strip_macro [] = [];

		fun ok_rest (s :: more) = (
			(is_alnum s orelse is_symbolic s orelse is_copula s)
			andalso ok_rest more
		) | ok_rest [] = true;
	in	case explode s of
			s :: more => (
				if is_macro s
				then ok_rest(strip_macro more)
				else is_symbolic s andalso ok_rest more
		) |	[] => false
	end
);
=SML
fun âdeclare_terminatorá (s :  string) : unit = (
	if not(is_ok_terminator s)
	then fail "declare_terminator" 20101 [fn()=>s]
	else if explode s mem (!terminators)
	then fail "declare_terminator" 20102 [fn()=>s]
	else store_decl "declare_terminator" (DeclTerminator s)
);
=TEX
=SML
fun âundeclare_terminatorá (s : string) : unit = (
	if not(explode s mem !terminators)
	then fail "undeclare_terminator" 20102 [fn()=>s]
	else store_decl "undeclare_terminator" (UnDeclTerminator s)
);
=TEX
\subsection{Fixity}
=SML
fun âget_fixityá (s : string) : FIXITY = (
	case e_lookup s (!fixity_cache) of
		Value fix => fix
	| 	_ => Nonfix
);
=SML
fun âdeclare_binderá (s : string) = (
	store_decl "declare_binder" (DeclFixity(s, Binder))
);
=TEX
=SML
fun âdeclare_infixá (prec : int, s : string) : unit = (
	store_decl "declare_infix" (DeclFixity(s, Infix prec))
);
=TEX
=SML
fun âdeclare_prefixá (prec : int, s : string) : unit = (
	store_decl "declare_prefix" (DeclFixity(s, Prefix prec))
);
=TEX
=SML
fun âdeclare_postfixá (prec : int, s : string) : unit = (
	store_decl "declare_postfix" (DeclFixity(s, Postfix prec))
);
=SML
fun âdeclare_nonfixá (s : string) : unit = (
	case get_fixity s of
		Nonfix => ()
	|	_ => store_decl "declare_nonfix" (DeclFixity(s, Nonfix))
);
=TEX
\subsection{Constants and Aliases}
=SML
fun âget_const_infoá (c : string) : (TYPE * ((string * TYPE)list)) OPT = (
	case e_lookup c (!const_info_cache) of
		Nil => (
			case get_const_type c of
				Value ty => Value(ty, [(c, ty)])
			|	Nil => Nil
	) |	v => v
);
=SML
fun âdeclare_aliasá (s : string, tm : TERM) : unit = (
	if not (is_const tm)
	then fail "declare_alias" 20301 []
	else	let	val (c, ty) = dest_const tm
		in	case get_const_info s of
				Nil => store_decl"declare_alias"(DeclAlias(s, (c, ty)))
			|	Value (_, stys) => (
					if any stys (fn (c', ty') => c = c' andalso is_same_type ty ty')
					then fail "declare_alias" 20302 [fn()=>s, fn()=>c]
					else store_decl"declare_alias"(DeclAlias(s, (c, ty)))
			)
		end
);
=TEX
=SML
fun âundeclare_aliasá (s : string, tm : TERM) : unit = (
	if not (is_const tm)
	then fail "undeclare_alias" 20301 []
	else	let	val (c, ty) = dest_const tm
		in	case get_const_info s of
				Nil => store_decl"undeclare_alias"(DeclAlias(s, (c, ty)))
			|	Value (_, stys) => (
					if not(any stys (fn (c', ty') => c = c' andalso is_same_type ty ty'))
					then fail "undeclare_alias" 20303 [fn()=>s, fn()=>c]
					else store_decl"undeclare_alias"(UnDeclAlias(s, (c, ty)))
			)
		end
);
=TEX
=SML
fun âresolve_aliasá (s : string, ty : TYPE) = (
	case get_const_info s of
		Nil => fail "resolve_alias" 20304 [fn()=>s]
	|	Value (_, stys) => (
			(mk_const(fst(find stys (fn(s', ty') => is_type_instance ty ty')), ty))
			handle Fail _ => fail "resolve_alias" 20304 [fn()=>s]
	)
);
=TEX
\subsection{Types and Type Abbreviations}
=SML
fun âget_type_infoá (t : string) : (int * (string list * TYPE) OPT) OPT = (
	case e_lookup t (!ty_info_cache) of
		Nil => (
			case get_type_arity t of
				Value a => Value(a, Nil)
			|	Nil => Nil
	) |	v => v
);
=TEX
=SML
fun âdeclare_type_abbrevá (a : string, args : string list, ty : TYPE) : unit = (
	if not(all_different args)
	then fail "declare_type_abbrev" 20407 [fn()=>format_list Combinators.I args ", "]
	else case get_type_info a of
		Nil => (
			store_decl"declare_type_abbrev"(DeclTypeAbbrev (a, (args, ty)))
	) |	Value(_, Value _) => (
			warn "declare_type_abbrev" 20401 [fn()=>a];
			store_decl"declare_type_abbrev"(DeclTypeAbbrev (a, (args, ty)))
	) |	Value(_, Nil) => (
			warn "declare_type_abbrev" 20402 [fn()=>a];
			store_decl"declare_type_abbrev"(DeclTypeAbbrev (a, (args, ty)))
	)
);
=TEX
=SML
fun âundeclare_type_abbrevá (a : string) : unit = (
	case get_type_info a of
		Value(_, Value _) => store_decl"undeclare_type_abbrev"(UnDeclTypeAbbrev a)
	|	_ => fail "undeclare_type_abbrev" 20403 [fn()=>a]
);
=TEX
=SML
fun âis_type_abbrevá (a : string) : bool =(
	case get_type_info a of
		Value(_, Value _) => true
	|	_ => false
);
=TEX
=SML
fun âexpand_type_abbrevá (a : string, actuals : TYPE list) : TYPE = (
	case get_type_info a of
		Value(_, Value (formals, ty)) => (
			let	val subs = (combine actuals formals)
					handle X =>
						divert X "combine" "expand_type_abbrev"
						(if length formals = 1 then 20405 else 20406)
						[fn()=>string_of_int(length formals),
						 fn()=>string_of_int(length actuals)];
			in	icl'inst_type subs ty
			end
	) |	_ => fail "expand_type_abbrev" 20404 [fn()=>a]
);
=TEX
\subsection{Languages}
=SML
fun âset_current_languageá (lang : string) : unit = (
	store_decl "set_current_language" (SetLanguage lang)
);
=TEX
=SML
fun âget_current_languageá (() : unit) : string = (
	!language
);
=TEX
=SML
fun âget_const_languageá (s : string) : string = (
	case e_lookup s (!const_theory_cache) of
		Value thy => (
			let	fun aux (ud :: more) = (
					case decode_decl thy ud of
						SetLanguage lang => lang
					|	_ => aux more
				) | aux [] = "HOL";
			in	aux(fetch_sym_tab_data thy)
			end
	) |	Nil => get_current_language()
);
=TEX
=SML
fun âget_type_languageá (s : string) : string = (
	case e_lookup s (!ty_theory_cache) of
		Value thy => (
			let	fun aux (ud :: more) = (
					case decode_decl thy ud of
						SetLanguage lang => lang
					|	_ => aux more
				) | aux [] = "HOL";
			in	aux(fetch_sym_tab_data thy)
			end
	) |	Nil => get_current_language()
);
=TEX
\subsection{Miscellaneous Functions}
=SML
fun get_selected_ids (thy : string) (sel : DECL -> bool) (uds : USER_DATUM list) : string list = (
	case uds of
		[] => []
	|	ud :: more => (
			let	val dec = decode_decl thy ud;
			in	if sel dec
				then 	case dec of
						DeclTerminator t => [t]
					|	UnDeclTerminator t => [t]
					|	DeclFixity (s, _)  => [s]
					|	DeclAlias (a, _) => [a]
					|	UnDeclAlias (a, _) => [a]
					|	DeclTypeAbbrev (a, _) => [a]
					|	UnDeclTypeAbbrev a => [a]
					|	SetLanguage lang => []
				else []
			end @ get_selected_ids thy sel more
	)
);
=TEX
=SML
fun âget_bindersá (thy : string) : string list = (
	let	fun sel (DeclFixity(_, Binder)) = true
		|   sel _ = false;
	in	get_selected_ids thy sel (fetch_sym_tab_data thy)
	end	handle X => reraise X "get_binders"
);
=TEX
=SML
fun âget_infixesá (thy : string) : string list = (
	let	fun sel (DeclFixity(_, Infix _)) = true
		|   sel _ = false;
	in	get_selected_ids thy sel (fetch_sym_tab_data thy)
	end	handle X => reraise X "get_infixes"
);
=TEX
=SML
fun âget_prefixesá (thy : string) : string list = (
	let	fun sel (DeclFixity(_, Prefix _)) = true
		|   sel _ = false;
	in	get_selected_ids thy sel (fetch_sym_tab_data thy)
	end	handle X => reraise X "get_prefixes"
);
=TEX
=SML
fun âget_postfixesá (thy : string) : string list = (
	let	fun sel (DeclFixity(_, Postfix _)) = true
		|   sel _ = false;
	in	get_selected_ids thy sel (fetch_sym_tab_data thy)
	end	handle X => reraise X "get_postfixes"
);
=TEX
=SML
fun âget_nonfixesá (thy : string) : string list = (
	let	fun sel (DeclFixity(_, Nonfix)) = true
		|   sel _ = false;
	in	get_selected_ids thy sel (fetch_sym_tab_data thy)
	end	handle X => reraise X "get_nonfixes"
);
=TEX
=SML
fun âget_type_abbrevsá (thy : string) : string list = (
	let	fun sel (DeclTypeAbbrev _) = true
		|   sel _ = false;
	in	get_selected_ids thy sel (fetch_sym_tab_data thy)
	end	handle X => reraise X "get_type_abbrevs"
);
=TEX
=SML
fun âget_undeclared_type_abbrevsá (thy : string) : string list = (
	let	fun sel (UnDeclTypeAbbrev _) = true
		|   sel _ = false;
	in	get_selected_ids thy sel (fetch_sym_tab_data thy)
	end	handle X => reraise X "get_undeclared_type_abbrevs"
);
=TEX
=SML
fun âget_aliasesá (thy : string) : string list = (
	let	fun sel (DeclAlias _) = true
		|   sel _ = false;
	in	get_selected_ids thy sel (fetch_sym_tab_data thy)
	end	handle X => reraise X "get_aliases"
);
=TEX
=SML
fun âget_undeclared_aliasesá (thy : string) : string list = (
	let	fun sel (UnDeclAlias _) = true
		|   sel _ = false;
	in	get_selected_ids thy sel (fetch_sym_tab_data thy)
	end	handle X => reraise X "get_undeclared_aliases"
);
=TEX
=SML
fun âget_const_theoryá (c : string) : string = (
	case e_lookup c (!const_theory_cache) of
		Value thy => thy
	|	Nil => fail "get_const_theory" 20603 [fn()=>c]
);
=TEX
=SML
fun âget_type_theoryá (ty : string) : string = (
	case e_lookup ty (!const_theory_cache) of
		Value thy => thy
	|	Nil => fail "get_type_theory" 20604 [fn()=>ty]
);
=SML
fun restore_defaults (():unit) : unit = (
	warn "restore_defaults" 20602 [get_current_theory_name];
	set_user_datum(ud_key, UD_Int(0, []))
);
=TEX
\section{HANDLING CONTEXT CHANGES}
Of the various classes of kernel state change, identified in
\cite{DS/FMU/IED/DTD012}, only $open\_theory$, $new\_parent$ and the
operations which introduce or
delete types or constants are currently of relevance
to the symbol table module.

When a theory is opened, we rebuild the caches from scratch. Schemes which
attempted to preserve the information from theories which have not been
unloaded have been considered, but seem to be too complex, because of the
need to ``undo undeclarations'' e.g. if theory $thy1$ has $thy2$ as an ancestor
and $thy1$ contains a nonfix declaration overriding a binder declaration
in $thy2$, then when we change context from $thy1$ to $thy2$ we must
undo the nonfix declaration.
=TEX
=SML
fun âbuild_theory_cachesá (thy : string) = (
	let	val conids = map (fst o dest_const) (get_consts thy)
		val tyids = map (fst o dest_type) (get_types thy);
		fun aux dict [] = dict
		|   aux dict (id :: more) = aux (e_enter id thy dict) more;
	in	const_theory_cache := aux (!const_theory_cache) conids;
		ty_theory_cache := aux (!ty_theory_cache) tyids
	end
);
=TEX
=SML
fun âcache_constsá (cs : string list) : unit = (
	let	fun do1 c = (
			const_theory_cache :=
			e_enter c(get_current_theory_name())(!const_theory_cache)
		);
	in	map do1 cs; ()
	end
);
=TEX
=SML
fun âuncache_constá (t : TERM) : unit = (
	const_theory_cache := e_delete (fst(dest_const t))(!const_theory_cache)
	handle Fail X => error "uncache_const" 20002 [fn()=>get_message X]
);
=TEX
=SML
fun âuncache_tyá (ty : string) : unit = (
	ty_theory_cache := e_delete ty(!ty_theory_cache)
);
=TEX
=SML
fun âcache_tysá (tys : string list) : unit = (
	let	fun do1 ty = (
			ty_theory_cache :=
			e_enter ty(get_current_theory_name())(!ty_theory_cache)
		);
	in	map do1 tys; ()
	end
);
=TEX
$cache\_ancestry$ loads the symbol table information
contained in a theory and all its ancestors into the caches:
=SML
fun cache_theory (current : string) : unit = (
	clear_caches();
	map
	(fn thy => ((map (cache_decl o decode_decl thy) (fetch_sym_tab_data thy));
		build_theory_caches thy))
	(get_ancestors current);
	()
);
=TEX
Finally we declare our interest in kernel state changes using
the interface defined in \cite{DS/FMU/IED/DTD012}:
=SML
val SideEffect = on_kernel_state_change
	(fn	OpenTheory (current, (_, _)) => cache_theory current
	|	NewParent _ => cache_theory(get_current_theory_name())
	|	NewConst (c, _) => cache_consts [c]
	|	SimpleNewDefn ((_, c, _), _) => cache_consts[c]
	|	NewSpecification ((_, i, thm), _) => (
			cache_consts(map(fst o dest_var)((fst(strip_((snd o dest_thm) thm))) to (i-1)))
	) |	NewType (ty, _) => cache_tys [ty]
	|	NewTypeDefn ((_, ty, _, _), _) => cache_tys [ty]
	|	DeleteConst c => uncache_const c
	|	DeleteType ty => uncache_ty ty
	|	_ => ()
);
=TEX
\section{EPILOGUE}
=SML
end; (* of structure SymbolTable *)
=TEX
=SML
open SymbolTable;
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}
