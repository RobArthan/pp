=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation for ICL HOL Symbol Table}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD020}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the implementation for the
symbol table module for ICL HOL.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library\\RDA\\AJH\\DJK}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion (\FormatDate{$Date$%
})]
First draft for comment.
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the symbol table module for ICL HOL.
The detailed design for this material is given in \cite{DS/FMU/IED/DTD020}.
\subsection{Introduction}
\subsection{Dependencies}
The symbol table module is dependent on the interface to the
abstract data type $THM$, \cite{DS/FMU/IED/IMP012}
and on the lexical analyser module, \cite{DS/FMU/IED/IMP015}.
\subsection{Algorithms}
The most straightforward implementation of the
design would simply define an encoding allowing finite functions
from identifiers to an appropriate record type to
be stored in a theory (as $USER\_DATA$) and would implement the various
access functions by direct access to the information stored in the theory.
However, this approach would be slow (since it would imply
linear table searches to find the information pertaining to an identifier)
and would also consume unnecessary space (since ``most'' identifiers do
not have any special properties, all we need to know about them is
already stored in the theory database). 

For the purposes of parsing, type inferring and pretty printing, the interrogative
functions:
$get\_terminators$, $get\_fixity$, $get\_const\_info$,
$get\_const\_type$, $resolve\_alias$, $get\_type\_info$,
$expand\_type\_abbrev$, $get\_language$ 
and, perhaps, $get\_sym\_tab\_info$, need to be quite fast.
Consequently, we maintain caches containing the 
information required to compute these functions
in the current context. As an optimisation (to the space usage) we do
not keep records for identifers with no special properties. The relevant
symbol table information for such an identifier may readily be computed
from the theory database as necessary.

We store in each theory an encoding of the
declarative operations ($declare\_terminator$, $declare\_infix$ etc.) which
have been made in the context of that theory.
Then, in essence, corresponding to each
declarative operation we define an operation on the cache and an operation
on the current theory. Thus a context change is effected by replaying
a sequence of operations on the cache which correspond to the declarations
which apply in that context. The declarative operations performed by the
user are implemented by performing the corresponding operations on both
the current theory and the cache,

\subsection{Possible Enhancements}
It is not yet known whether the encoding of symbol table information
in the theory database is adequately compact.
\subsection{Deficiencies}
\section{PREAMBLE}
=SML
structure SymbolTable = struct
=SML
open Lex;
=TEX
\subsection{Utilities}
=TEX
$split_string\,sep\,s$ splits string into a list of strings treating
characters for which $sep$ returns true as separator characters.
Runs of more than one separator are treated like a single separator.
=SML
fun âsplit_stringá (sep : string -> bool) (s : string) = (
	let	fun aux words "" (ch :: more) = (
			if sep ch
			then aux words "" more
			else aux words ch more
		) | aux words word (ch :: more) = (
			if sep ch
			then aux (words @ [word]) "" more
			else aux words (word ^ ch) more
		) | aux words "" [] = (words
		) | aux words word [] = words @ [word];
	in	aux [] "" (explode s)
	end
);
=TEX
$words\,s$ splits $s$ into a list of  strings treating formatting characters
as separators.
=SML
val âwordsá : string -> string list = split_string is_space;
=TEX
$is\_same\_type\,ty1,\,ty2$ is true iff. $ty1$ and $ty2$ are the same
type modulo renaming of type variables.
=SML
fun âis_same_typeá (ty1:TYPE) (ty2:TYPE) : bool = (
	is_type_instance ty1 ty2 andalso is_type_instance ty2 ty1
);
=TEX
\section{TYPES}\label{TYPES}
In this section we give the Standard ML types used in the symbol table module.
\subsection{Visible Types}
=IGN
(* Dummy for definition of USER_DATUM *)
open EfficientDictionary SimpleDictionary;

datatype âUSER_DATUMá =
	âUD_Termá of TERM * (USER_DATUM list) |
	âUD_Typeá of TYPE * (USER_DATUM list) |
	âUD_Stringá of string * (USER_DATUM list) |
	âUD_Intá of int * (USER_DATUM list);
(* Dummy get_const_type *)
fun get_const_type (s : string) : TYPE OPT = (
	case s of
		"=" =>  Value(mk_fun(mk_vartype "'a", mk_fun(mk_vartype"'a", BOOL)))
	|	"‡" =>  Value(mk_fun(mk_fun(mk_vartype"'a", BOOL), mk_vartype "'a"))
	|	"Š" =>  Value(mk_fun(BOOL, mk_fun(BOOL, BOOL)))
	|	_ => Nil
);
(* Dummy get_type_arity *)
fun get_type_arity (s : string) : int OPT = (
	case s of
		"‹" => Value 2
	|	"BOOL" => Value 0
	|	"IND" => Value 0
	|	_ => Nil
);
(* dummy get_constants *)
fun get_constants (thy : string) = (
	map (fn s => mk_const(s, force_value(get_const_type s))) ["=", "‡", "Š"]
);
(* dummy get_types *)
fun get_types (thy : string) = (
	let	fun do1 (s, i) = (
			 mk_type(s, map (fn j =>mk_vartype("'"^string_of_int j))(interval 1 i))
		);
	in	map (fn s => do1(s, force_value(get_type_arity s)))
		["‹", "BOOL", "IND"]
	end
);
(* Dummy USER_DATA type etc. *)

type âUSER_DATAá = (USER_DATUM ref) S_DICT;

val current_user_data : USER_DATA ref  = ref initial_s_dict;

fun get_user_datum (_:string) (key:string) : USER_DATUM OPT = (
	case s_lookup key (!current_user_data) of
		Nil => Nil
	|	Value(ref ud) => Value ud
);
fun set_user_datum (key:string, ud : USER_DATUM) = (
	case s_lookup key (!current_user_data) of
		Nil => current_user_data := s_enter key (ref ud) (!current_user_data)
	|	Value refud => refud := ud
);

=TEX
=SML
datatype âFIXITYá	=	âNonfixá
			|	âBinderá
			|	âInfixá of int
			|	âPrefixá of int
			|	âPostfixá of int;
=TEX
\subsection{Private Types}
The following datatype is used to encode the various declarative operations.
Note that:

\begin{enumerate}
\item
the various fixity operations are merged into a single case parameterised
by a $FIXITY$;
\item
there is no $UnDeclFixity$ --- this operation corresponds to a nonfix
declaration;
\item
the $set\_language$ operation is not catered for here.
\end{enumerate}
=SML
datatype âDECLá	=	âDeclTerminatorá of string
			|	âUnDeclTerminatorá of string
			|	âDeclFixityá of string * FIXITY
			|	âDeclAliasá of string * (string * TYPE)
			|	âUnDeclAliasá of string * (string * TYPE)
			|	âDeclTypeAbbrevá of string * (string list * TYPE)
			|	âUnDeclTypeAbbrevá of string
			|	âSetLanguageá of string;
=TEX
\section{THE CACHES AND THEIR ACCESS FUNCTIONS}
In this section we define the caches in which symbol table information relating
to the current context is stored for rapid access. We also define the
functions which read and write these caches (the read functions are part of
the visible interface).


=SML
val âty_info_cacheá : (int * (((string list) * TYPE)OPT)) E_DICT ref = ref initial_e_dict;
=TEX
=SML
val âconst_info_cacheá : (TYPE * ((string * TYPE)list)) E_DICT ref = ref initial_e_dict;
=TEX
=SML
val âlanguage_cacheá : string E_DICT ref = ref initial_e_dict;
=TEX
=SML
val âfixity_cacheá : FIXITY E_DICT ref = ref initial_e_dict;
=TEX
=SML
val âterminatorsá : string list list ref = ref[];
=TEX
For uniformity, the current language is held in an assignable variable
(although it may fairly rapidly be computed from the theory database).
=SML
val âlanguageá : string ref = ref "HOL";
=TEX
It is actually more convenient to have a single update function
parameterised by the type of declaration being made. This requires a few
local utilities to cope with the more complex cases:
=SML
local
=TEX
=SML
fun âcache_terminatorá (t : string) = (
	let	val et = explode t;
		val len = length et;
		fun aux [] = [et]
		|   aux (h :: more) = (
			if length h > len
			then h :: aux more
			else et :: h :: more
		);
	in	terminators := aux(!terminators)
	end
);
=TEX
=SML
fun âuncache_terminatorá (t : string) = (
	terminators := !terminators less explode t
);
=TEX
=SML
fun âcache_fixityá (s : string, fix : FIXITY) = (
	case fix of
		Nonfix => fixity_cache := e_delete s (!fixity_cache)
	|	_ => fixity_cache := e_enter s fix (!fixity_cache)
);
=TEX
=SML
fun âcache_aliasá (a : string, (s:string, ty : TYPE)) : unit = (
	const_info_cache :=
	e_enter
	a
	(case e_lookup a (!const_info_cache) of
		Value(ty', alinfs) => (
			 (Antiunify.antiunify(ty, ty'), (s, ty) :: alinfs)
	) |	Nil => (
			 (ty, [(s, ty)])
	))
	(!const_info_cache)
);
=TEX
We need to antiunify lists of types when aliases are deleted:
=SML
fun âlist_antiunifyá ([] : TYPE list) : TYPE = mk_vartype "'a"
|   list_antiunify [ty] = ty
|   list_antiunify (ty :: more) = Antiunify.antiunify(ty, list_antiunify more);
=TEX
=SML
fun âuncache_aliasá (a : string, (s:string, ty : TYPE)) : unit = (
	case e_lookup a (!const_info_cache) of
		Value(_, alinfs) => const_info_cache := (
			case alinfs drop 
					(fn(s', ty') => s = s' andalso is_same_type ty ty')
			of
				[] => e_delete a (!const_info_cache)
			|	some => e_enter a(list_antiunify (map snd some) , some)(!const_info_cache)
	) |	Nil => ( ()
	)
);
=TEX
=SML
fun âcache_type_abbrevá(a : string, (args : string list, ty : TYPE)) : unit = (
	ty_info_cache := e_enter a (length args, Value(args, ty)) (!ty_info_cache)
);
=TEX
=SML
fun âuncache_type_abbrevá(a : string) : unit = (
	case get_type_arity a of
		Nil => ty_info_cache := e_delete a (!ty_info_cache)
	|	Value ar => ty_info_cache := e_enter a (ar, Nil) (!ty_info_cache)
);
=TEX
=SML
fun âcache_languageá (lang : string) = (
	let	val ids = map (fst o dest_const) (get_constants "-") cup
			map (fst o dest_type) (get_types "-");
		fun aux dict [] = dict
		|   aux dict (id :: more) = aux (e_enter id lang dict) more;
	in	language_cache := aux (!language_cache) ids
	end;
	language := lang
);
=TEX
=SML
in
fun âcache_declá (dec : DECL) : unit = (
	case dec of
		DeclTerminator t => cache_terminator t
	|	UnDeclTerminator t => uncache_terminator t
	|	DeclFixity sfix  => cache_fixity sfix
	|	DeclAlias asty => cache_alias asty
	|	UnDeclAlias asty => uncache_alias asty
	|	DeclTypeAbbrev aargsty => cache_type_abbrev aargsty
	|	UnDeclTypeAbbrev  a => uncache_type_abbrev a
	|	SetLanguage lang => cache_language lang
);
end; (* of local ... in ... end *)
=TEX
\subsection{THEORY DATABASE ACCESS FUNCTIONS}
The symbol table module uses a single slot in the theory user data 
under the key ``icl'st'' to hold the declarations which apply
to the theory. The declarations are held as a fairly direct encoding
of a list of $DECL$s.

\subsection{Utilities For Accessing the User Data}
In this section we define the functions we use to fetch and store the
lists of $USER\_DATUM$s belonging to the symbol table held in theories.
=SML
val ud_key = "icl'st";
=TEX
=SML
fun fetch_sym_tab_data (thy : string) : USER_DATUM list = (
	case get_user_datum thy ud_key handle Fail _ => UD_Int(0, []) of
		(UD_Int(0, uds)) => uds
	|	_ => fail "fetch_sym_tab_data" 20001 [fn()=>thy]
);
=TEX
The theory name argument to $store\_sym\_tab\_datum$ and
$delete\_sym\_tab\_datum$ are only used in error messages.
=SML
fun store_sym_tab_datum (ud : USER_DATUM) : unit = (
	let	val uds = (
			case get_user_datum "-" ud_key handle Fail _ => UD_Int(0, []) of
				(UD_Int(0, uds)) => uds
			|	_ => fail "fetch_sym_tab_data" 20001 [fn()=>"-"]);
	in 	set_user_datum(ud_key, UD_Int(0, ud :: uds))
	end
);
=TEX
We sometimes need to delete entries. $delete\_sym\_tab\_datum$
does this (and does nothing if the entry to be deleted is not there).
=SML
fun delete_sym_tab_datum (ud : USER_DATUM) : unit = (
	let	val uds = (
			case get_user_datum "-" ud_key handle Fail _ => UD_Int(0, []) of
				(UD_Int(0, uds)) => uds
			|	_ => fail "fetch_sym_tab_data" 20001 [fn()=>"-"])
	in 	set_user_datum(ud_key, UD_Int(0, uds less ud))
	end
);
=TEX
\subsection{Encoding and Decoding Functions}
First of all we give an encoding for $FIXITY$ values.
We encode constructors as small numbers, since on most Standard ML compilers
these are held in a single word of storage.
=SML
fun âencode_fixityá (fix : FIXITY) : USER_DATUM = (
	case fix of
		Nonfix => UD_Int(0, [])
	|	Binder => UD_Int(1, [])
	|	Infix p => UD_Int(2, [UD_Int(p, [])])
	|	Prefix p => UD_Int(3, [UD_Int(p, [])])
	|	Postfix p => UD_Int(4, [UD_Int(p, [])])
);
=TEX
=SML
fun âdecode_fixityá (ud : USER_DATUM) : FIXITY = (
	case ud of
		UD_Int(0, []) => Nonfix
	|	UD_Int(1, []) => Binder
	|	UD_Int(2, [UD_Int(p, [])]) => Infix p
	|	UD_Int(3, [UD_Int(p, [])]) => Prefix p
	|	UD_Int(4, [UD_Int(p, [])]) => Postfix p
	|	_ => fail "decode_fixity" 20001 []
);
=TEX
=SML
fun âencode_declá (dec : DECL) : USER_DATUM = (
	case dec of
		DeclTerminator t => UD_Int(0, [UD_String(t, [])])
	|	UnDeclTerminator t => UD_Int(1, [UD_String(t, [])])
	|	DeclFixity (s, fix)  => UD_Int(2, [UD_String(s, [encode_fixity fix])])
	|	DeclAlias (a, (s, ty)) =>
			UD_Int(3, [UD_String(a, [UD_String(s, [UD_Type(ty, [])])])])
	|	UnDeclAlias (a, (s, ty)) =>
			UD_Int(4, [UD_String(a, [UD_String(s, [UD_Type(ty, [])])])])
	|	DeclTypeAbbrev (a, (args, ty)) =>
			UD_Int(5, [UD_String(a, [UD_Type(ty, map ((switch(curry UD_String))[]) args)])])
	|	UnDeclTypeAbbrev a => UD_Int(6, [UD_String(a, [])])
	|	SetLanguage lang => UD_Int(7, [UD_String(lang, [])])
);
=TEX
=SML
fun âdecode_declá (thy : string) (ud : USER_DATUM) : DECL = (
	case ud of
		UD_Int(0, [UD_String(t, [])]) => DeclTerminator t
	|	UD_Int(1, [UD_String(t, [])]) => UnDeclTerminator t
	|	UD_Int(2, [UD_String(s, [fix])]) => DeclFixity (s, decode_fixity fix)
	|	UD_Int(3, [UD_String(a, [UD_String(s, [UD_Type(ty, [])])])]) => 
				DeclAlias (a, (s, ty))
	|	UD_Int(4, [UD_String(a, [UD_String(s, [UD_Type(ty, [])])])]) => 
				UnDeclAlias (a, (s, ty))
	|	UD_Int(5, [UD_String(a, [UD_Type(ty, args)])]) =>
			DeclTypeAbbrev (a, (map
				(fn UD_String(arg, []) => arg
				| _ => fail "decode_decl" 20001 [fn()=> thy]) args, ty))
	|	UD_Int(6, [UD_String(a, [])]) => UnDeclTypeAbbrev a
	|	UD_Int(7, [UD_String(lang, [])]) => SetLanguage lang
	|	_ => fail "decode_decl" 20001 [fn()=> thy]
);
=TEX
Occasionally we need to extract from a theory the
declarations relating to a particular name.
=SML
fun get_id_data (id : string) (thy : string) : USER_DATUM list = (
		fetch_sym_tab_data thy
	drop	(fn UD_Int(_, [UD_String(s, _)]) => s <> id | _ => true)
);
=TEX
\subsection{Update Functions}
As with the cache update functions, it is convenient to have a single update
function parameterised by the type of declaration being made.
As theory updates are never done without also updating the cache the theory
update function calls the cache update function when its own work is complete.
Again we have a section of local utilities to assist:
=SML
local
=TEX
=SML
fun store_terminator (thy : string) (s : string) : unit = (
	delete_sym_tab_datum (encode_decl(UnDeclTerminator s));
	store_sym_tab_datum (encode_decl(DeclTerminator s))
);
=TEX
=SML
fun unstore_terminator (thy : string) (s : string) : unit = (
	let	val uds = get_id_data s thy;
		fun aux ud = (
			case decode_decl thy ud of
				DeclTerminator s' => s' = s
			|	_ => false
		);
	in	if any uds aux
		then	delete_sym_tab_datum (find uds aux)
		else	store_sym_tab_datum (encode_decl(UnDeclTerminator s))
	end
);
=TEX
=SML
fun store_fixity (thy : string) (s : string, fix : FIXITY) : unit = (
	let	val uds = get_id_data s thy;
		fun aux ud = (
			case decode_decl thy ud of
				DeclFixity(s', _) => s' = s
			|	_ => false
		);
	in	if any uds aux
		then 	case fix of
				Nonfix => delete_sym_tab_datum (find uds aux)
			|	_ => (
					delete_sym_tab_datum (find uds aux);
					store_sym_tab_datum (encode_decl(DeclFixity (s, fix)))
			)
		else	store_sym_tab_datum (encode_decl(DeclFixity (s, fix)))
	end
);
=TEX
=SML
fun store_alias (thy : string) (a : string, (s:string, ty:TYPE)) : unit = (
	store_sym_tab_datum (encode_decl(DeclAlias (a, (s, ty))))
);
=TEX
=SML
fun unstore_alias (thy : string) (a : string, (s:string, ty:TYPE)) : unit = (
	let	val uds = get_id_data a thy;
		fun aux ud = (
			case decode_decl thy ud of
				DeclAlias(a', (s', ty')) => a = a' andalso s = s'
					andalso is_same_type ty ty' 
			|	_ => false
		);
	in	if any uds aux
		then	delete_sym_tab_datum (find uds aux)
		else	store_sym_tab_datum (encode_decl(DeclAlias (a, (s, ty))))
	end
);
=TEX
=SML
fun store_type_abbrev (thy : string) (a : string, (args:string list, ty:TYPE)) : unit = (
	store_sym_tab_datum (encode_decl(DeclTypeAbbrev (a, (args, ty))))
);
=TEX
=SML
fun unstore_type_abbrev (thy : string) (a : string) : unit = (
	let	val uds = get_id_data a thy;
		fun aux ud = (
			case decode_decl thy ud of
				DeclTypeAbbrev(a', _) => a = a'
			|	_ => false
		);
	in	if any uds aux
		then	delete_sym_tab_datum (find uds aux)
		else	store_sym_tab_datum (encode_decl(UnDeclTypeAbbrev a))
	end
);
=TEX
=SML
fun store_language (thy : string) (lang : string) : unit = (
	store_sym_tab_datum (encode_decl(SetLanguage lang))
);
=TEX
=SML
in
fun âstore_declá (area : string) (dec : DECL) : unit = (
	let	val thy = get_current_theory_name();
	in
		case get_current_theory_status() of
			TSNormal => (
				(case dec of
					DeclTerminator t => store_terminator thy t
				|	UnDeclTerminator t => unstore_terminator thy t
				|	DeclFixity sfix  => store_fixity thy sfix
				|	DeclAlias asty => store_alias thy asty
				|	UnDeclAlias asty => unstore_alias thy asty
				|	DeclTypeAbbrev aargsty => store_type_abbrev thy aargsty
				|	UnDeclTypeAbbrev  a => unstore_type_abbrev thy a
				|	SetLanguage lang => store_language thy lang);
				cache_decl dec
		) |	_ => fail area 20002 [fn () => thy]
	end
);
end; (* of local ... in ... end *)
=TEX
=TEX
\section{ACCESS FUNCTIONS}
\subsection{Terminators}
=SML
fun âget_terminatorsá (():unit) : string list list =(
	!terminators
);
=TEX
The following function checks that a string obeys the rules for terminators
identified in \cite{DS/FMU/IED/DEF001}. 
=SML
fun is_ok_terminator (s : string) = (
	let	fun strip_macro (s :: more) = (
			if is_macro s
			then more
			else strip_macro more
		) | strip_macro [] = [];

		fun ok_rest (s :: more) = (
			(is_alnum s orelse is_symbolic s orelse is_copula s)
			andalso ok_rest more
		) | ok_rest [] = true;
	in	case explode s of
			s :: more => (
				if is_macro s
				then ok_rest(strip_macro more)
				else is_symbolic s andalso ok_rest more
		) |	[] => false
	end
);
=SML
fun âdeclare_terminatorá (s :  string) : unit = (
	if not(is_ok_terminator s)
	then fail "declare_terminator" 20101 [fn()=>s]
	else if explode s mem (!terminators)
	then fail "declare_terminator" 20102 [fn()=>s]
	else store_decl "declare_terminator" (DeclTerminator s)
);
=TEX
=SML
fun âundeclare_terminatorá (s : string) : unit = (
	if not(explode s mem !terminators)
	then fail "undeclare_terminator" 20102 [fn()=>s]
	else store_decl "undeclare_terminator" (UnDeclTerminator s)
);
\subsection{Fixity}
=SML
fun âget_fixityá (s : string) : FIXITY = (
	case e_lookup s (!fixity_cache) of
		Value fix => fix
	| 	_ => Nonfix
);
=SML
fun âdeclare_binderá (s : string) = (
	store_decl "declare_binder" (DeclFixity(s, Binder))
);
=TEX
=SML
fun âdeclare_infixá (prec : int, s : string) : unit = (
	store_decl "declare_infix" (DeclFixity(s, Infix prec))
);
=TEX
=SML
fun âdeclare_prefixá (prec : int, s : string) : unit = (
	store_decl "declare_prefix" (DeclFixity(s, Prefix prec))
);
=TEX
=SML
fun âdeclare_postfixá (prec : int, s : string) : unit = (
	store_decl "declare_postfix" (DeclFixity(s, Postfix prec))
);

=SML
fun âdeclare_nonfixá (s : string) : unit = (
	case get_fixity s of
		Nonfix => ()
	|	_ => store_decl "declare_nonfix" (DeclFixity(s, Nonfix))
);
\subsection{Constants and Aliases}
=SML
fun âget_const_infoá (c : string) : (TYPE * ((string * TYPE)list)) OPT = (
	(e_lookup c (!const_info_cache))
	handle Fail _ => (
		case get_constant_type c of
			Value ty => Value(ty, [(c, ty)])
		|	Nil => Nil
	)
);
=SML
fun âdeclare_aliasá (s : string, tm : TERM) : unit = (
	if not (is_const tm)
	then fail "declare_alias" 20301 []
	else	let	val (c, ty) = dest_const tm
		in	case get_const_info s of
				Nil => store_decl"declare_alias"(DeclAlias(s, (c, ty)))
			|	Value (_, stys) => (
					if any stys (fn (c', ty') => c = c' andalso is_same_type ty ty')
					then fail "declare_alias" 20302 [fn()=>s, fn()=>c]
					else store_decl"declare_alias"(DeclAlias(s, (c, ty)))
			)
		end
);
=TEX
=SML
fun âundeclare_aliasá (s : string, tm : TERM) : unit = (
	if not (is_const tm)
	then fail "undeclare_alias" 20301 []
	else	let	val (c, ty) = dest_const tm
		in	case get_const_info s of
				Nil => store_decl"undeclare_alias"(DeclAlias(s, (c, ty)))
			|	Value (_, stys) => (
					if not(any stys (fn (c', ty') => c = c' andalso is_same_type ty ty'))
					then fail "undeclare_alias" 20303 [fn()=>s, fn()=>c]
					else store_decl"undeclare_alias"(UnDeclAlias(s, (c, ty)))
			)
		end
);
=DOC
fun âresolve_aliasá (s : string, ty : TYPE) = (
	case get_const_info s of
		Nil => fail "resolve_alias" 20304 [fn()=>s]
	|	Value (_, stys) => (
			(mk_const(fst(find stys (fn(s', ty') => is_type_instance ty ty')), ty))
			handle Fail _ => fail "resolve_alias" 20304 [fn()=>s]
	)
);

\subsection{Types and Type Abbreviations}
=SML
fun âget_type_infoá (t : string) : (int * (string * TYPE list) OPT) OPT = (
	(e_lookup t (!ty_info_cache))
	handle Fail _ => (
		case get_type_arity c of
			Value a => Value(a, Nil)
		|	Nil => Nil
	)
);
=TEX
!!! GOT HERE
=DOC
	val âdeclare_type_abbrevá : (string * TYPE list * TYPE) -> FIXITY;
=DESCRIBE
$declare\_type\_abbrev\,(s, [\alpha_1, \ldots, \alpha_k], \tau)$
declares $(\alpha_1, \ldots, \alpha_k)s$
as a type abbreviation for the type $\tau$.
The formal parameters $\alpha_1, \ldots, \alpha_k$ must all be type variables.
=FAILURE
20401	The formal parameter ?0 is not a type variable.
=ENDDOC
=DOC
	val âundeclare_type_abbrevá : string -> FIXITY;
=DESCRIBE
$undeclare\_type\_abbrev\,(s, [\alpha_1, \ldots, \alpha_k], \tau)$
reverses the effect of a declaration of $s$ as a type abbreviation.
=FAILURE
20402	The identifier ?0 is not declared as a type abbreviation
=ENDDOC

=DOC
	val âis_type_abbrevá : string -> bool;
=DESCRIBE
$is\_type\_abbrev$ returns $true$ iff. $s$ is declared as a type abbreviation
=ENDDOC

=DOC
	val âexpand_type_abbrevá : (string * TYPE list) -> TYPE;
=DESCRIBE
$expand\_type\_abbrev\,s,[\tau_1, \ldots, \tau_k]$ is the
expansion of the type abbreviation $s$ with respect to the arguments
$[\tau_1, \ldots, \tau_k]$. 
=FAILURE
20403	The identifier ?0 is not declared as a type abbreviation
20404	The type abbreviation ?0 should have ?1 argument not ?2
20405	The type abbreviation ?0 should have ?1 arguments not ?2
=ENDDOC
\subsection{Languages}
The symbol table stores a language indicator in each theory.
This determines the language in the symbol table records for the names
in that theory. The language indicator for a new theory is initially taken
from its (first) parent. The language indicator for the initial theory
$MIN$ is set to ``$HOL$''.
=DOC
	val âset_current_languageá : string -> unit;
=DESCRIBE
$set\_current\_language\,s$ sets the language indicator associated with
the current theory to $s$.
=ENDDOC
=DOC
	val âget_current_languageá : unit -> string;
=DESCRIBE
$get\_current\_language()$ returns the language indicator associated with
the current theory.
=ENDDOC
=DOC
	val âget_languageá : string -> string;
=DESCRIBE
$get\_language\,s$ returns the language indicator associated with
the name $s$ in the current context. If there is no symbol table record
associated with $s$ $get\_language\,s$ the language indicator associated
with the current theory is returned
=ENDDOC

\subsection{Miscellaneous Functions}
% Errors in this subsection start with 206
=DOC
	val âget_sym_tab_idsá : string -> string list;
=DESCRIBE
$get\_sym\_tab\_ids\,thy$ returns the list of identifiers which have a symbol
table record in the theory $thy$.
=ENDDOC

=SML
fun restore_defaults (():unit) : unit = (
	warn "restore_defaults" 20601 [get_current_theory_name];
	set_user_datum(ud_key, UD_Int(0, []))
);
=SML
end; (* of signature SymbolTable *)
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}

cache_decl (DeclTerminator "„1");
cache_decl (DeclTerminator "ƒ1");
cache_decl (UnDeclTerminator "„1");

cache_decl (DeclFixity ("+", Infix 20));
cache_decl (DeclFixity ("-", Infix 20));
cache_decl (DeclFixity ("-", Prefix 30));
cache_decl (DeclFixity ("-", Nonfix));
cache_decl (DeclFixity ("+", Nonfix));

cache_decl (DeclAlias("‚", ("=", mk_fun(BOOL, mk_fun(BOOL, BOOL)))));
cache_decl (DeclAlias("‚", ("xyz", mk_fun(mk_vartype"'a", mk_vartype"'b"))));
cache_decl (DeclAlias("‚", ("abc", mk_fun(BOOL, mk_vartype"'b"))));

cache_decl (UnDeclAlias("‚", ("xyz", mk_fun(mk_vartype"'a", mk_vartype"'b"))));
cache_decl (UnDeclAlias("‚", ("abc", mk_fun(BOOL, mk_vartype"'b"))));
cache_decl (UnDeclAlias("‚", ("=", mk_fun(BOOL, mk_fun(BOOL, BOOL)))));

cache_decl (DeclTypeAbbrev("auto", (["'a"], mk_fun(mk_vartype"'a", mk_vartype"'a"))));
cache_decl (DeclTypeAbbrev("revfun", (["'a", "'b"], mk_fun(mk_vartype"'b", mk_vartype"'a"))));
cache_decl (UnDeclTypeAbbrev "auto");
cache_decl (UnDeclTypeAbbrev "revfun");

cache_decl (SetLanguage "Z");
cache_decl (SetLanguage "HOL");

fun sh () = (
	map (decode_decl "-")(fetch_sym_tab_data "-")
);
val s = sh o store_decl "-";

s (DeclTerminator "„1");
s (DeclTerminator "ƒ1");
s (UnDeclTerminator "„1");
s (UnDeclTerminator "ƒ1");

s (DeclFixity ("+", Infix 20));
s (DeclFixity ("-", Infix 20));
s (DeclFixity ("-", Prefix 30));
s (DeclFixity ("-", Nonfix));
s (DeclFixity ("+", Nonfix));

s (DeclAlias("‚", ("=", mk_fun(BOOL, mk_fun(BOOL, BOOL)))));
s (DeclAlias("‚", ("xyz", mk_fun(mk_vartype"'a", mk_vartype"'b"))));
s (DeclAlias("‚", ("abc", mk_fun(BOOL, mk_vartype"'b"))));

s (UnDeclAlias("‚", ("xyz", mk_fun(mk_vartype"'a", mk_vartype"'b"))));
s (UnDeclAlias("‚", ("abc", mk_fun(BOOL, mk_vartype"'b"))));
s (UnDeclAlias("‚", ("=", mk_fun(BOOL, mk_fun(BOOL, BOOL)))));

s (DeclTypeAbbrev("auto", (["'a"], mk_fun(mk_vartype"'a", mk_vartype"'a"))));
s (DeclTypeAbbrev("revfun", (["'a", "'b"], mk_fun(mk_vartype"'b", mk_vartype"'a"))));
s (UnDeclTypeAbbrev "auto");
s (UnDeclTypeAbbrev "revfun");

s (SetLanguage "Z");
s (SetLanguage "HOL");


