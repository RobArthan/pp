% imp020.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation for ICL HOL Symbol Table}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD020}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the implementation for the
symbol table module for ICL HOL.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library\\RDA\\AJH\\DJK}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue 1.3]
First draft for comment.
\item [Issue 1.4]
Corrected a use of $get\_const\_type$.
\item [Issue 1.5]
The name atom  ``definition(s)'' changed to ``defn(s)'', and
``constant(s)'' to ``const(s)''.
\item [Issue 1.7 (22 May 1991)]
Added $get\_alias$. Corrected handling of languages.
\item [Issue 1.8 (25 July 1991)] Added $get\_language$. $get\_terminators$ renamed as
$get\_current\_terminators$ and $get\_terminators$ added as theory
access function. Slight reorganisation of last part of document.
\item [Issue 1.9 (25 July 1991)]
Delete $FIXITY$ (moved to lexical analyser~\cite{DS/FMU/IED/DTD015}).
\item [Issue 1.10 (26 July 1991)]
Rework of theory access and type abbreviation interfaces.
\item [Issue \SCCSversion (\FormatDate{$Date$%
})]
Changed names of syntax functions.

\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the symbol table module for ICL HOL.
The detailed design for this material is given in \cite{DS/FMU/IED/DTD020}.
\subsection{Introduction}
\subsection{Dependencies}
The symbol table module is dependent on the interface to the
abstract data type $THM$, \cite{DS/FMU/IED/IMP012}
and on the lexical analyser module, \cite{DS/FMU/IED/IMP015}.
\subsection{Algorithms}
The most straightforward implementation of the
design would simply define an encoding allowing finite functions
from identifiers to an appropriate record type to
be stored in a theory (as $USER\_DATA$) and would implement the various
access functions by direct access to the information stored in the theory.
However, this approach would be slow (since it would imply
linear table searches to find the information pertaining to an identifier)
and would also consume unnecessary space (since ``most'' identifiers do
not have any special properties, all we need to know about them is
already stored in the theory database). 

For the purposes of parsing, type inferring and pretty printing, the interrogative
functions:
$get\_terminators$, $get\_fixity$, $get\_const\_info$,
$get\_const\_type$, $resolve\_alias$, $get\_alias$, $get\_type\_info$,
$expand\_type\_abbrev$, $get\_language$ 
and, perhaps, $get\_sym\_tab\_info$, need to be quite fast.
Consequently, we maintain caches containing the 
information required to compute these functions
in the current context. As an optimisation (to the space usage) we do
not keep records for identifers with no special properties. The relevant
symbol table information for such an identifier may readily be computed
from the theory database as necessary.

We store in each theory an encoding of the
declarative operations ($declare\_terminator$, $declare\_infix$ etc.) which
have been made in the context of that theory.
Then, in essence, corresponding to each
declarative operation we define an operation on the cache and an operation
on the current theory. Thus a context change is effected by replaying
a sequence of operations on the caches which correspond to the declarations
which apply in that context. The declarative operations performed by the
user are implemented by performing the corresponding operations on both
the current theory and the caches,

\subsection{Possible Enhancements}
It is not yet known whether the encoding of symbol table information
in the theory database is adequately compact.
\subsection{Deficiencies}
It would be desirable for the symbol table module to check before
a type or constant was deleted whether or not there was an abbreviation
or alias in force relating to the type or constant. Implementing this would
require extensions to dtd012.

\section{PREAMBLE}
=SML
structure SymbolTable : SymbolTable = struct
=SML
open Lex;
=TEX
\subsection{Utilities}
=TEX
$is\_same\_type\,ty1,\,ty2$ is true iff. $ty1$ and $ty2$ are the same
type modulo renaming of type variables.
=SML
fun âis_same_typeá (ty1:TYPE) (ty2:TYPE) : bool = (
	is_type_instance ty1 ty2 andalso is_type_instance ty2 ty1
);
=TEX
\section{TYPES}\label{TYPES}
In this section we give the Standard ML types used in the symbol table module.

%\subsection{Visible Types}
%\subsection{Private Types}
The following datatype is used to encode the various declarative operations.
Note that:

\begin{enumerate}
\item
the various fixity operations are merged into a single case parameterised
by a $FIXITY$;
\item
there is no $UnDeclFixity$ --- this operation corresponds to a nonfix
declaration;
\item
the $set\_language$ operation is not catered for here.
\end{enumerate}
=SML
datatype âDECLá	=	âDeclTerminatorá of string
			|	âUnDeclTerminatorá of string
			|	âDeclFixityá of string * FIXITY
			|	âDeclAliasá of string * (string * TYPE)
			|	âUnDeclAliasá of string * (string * TYPE)
			|	âDeclTypeAbbrevá of string * (string list * TYPE)
			|	âUnDeclTypeAbbrevá of string
			|	âSetLanguageá of string;
=TEX
\section{THE CACHES AND THEIR ACCESS FUNCTIONS}
In this section we define the caches in which symbol table information relating
to the current context is stored for rapid access. We also define the
functions which read and write these caches (the read functions are part of
the visible interface).

The type information cache contains entries as suggested by the
discussion of $get\_type\_info$ in the detailed design.
=SML
val âty_info_cacheá : (int * (((string list) * TYPE)OPT)) E_DICT ref = ref initial_e_dict;
=TEX
The constant information cache contains a field for each
name which gives the
information returned by $get\_const\_info$
(this is the field used by $resolve\_alias$)
and in a field giving any aliases which may resolve to the name
(this is the field used by $get\_alias$).
=SML
val âconst_info_cacheá : ((TYPE * ((string * TYPE)list)) * ((string * TYPE)list))E_DICT ref
					= ref initial_e_dict;
=TEX
=SML
val âfixity_cacheá : FIXITY E_DICT ref = ref initial_e_dict;
=TEX
=SML
val âterminatorsá : string list list ref = ref[];
=TEX
For uniformity, the current language is held in an assignable variable
(although it may fairly rapidly be computed from the theory database).
=SML
val âlanguageá : string ref = ref "HOL";
=TEX
The remaining two caches are unlike the others in that their values are not
set by declarations but instead are calculated from the theory database
as theories are loaded.
They give for each constant and type which is in scope the name 
and language of theory to
which it belongs.
=SML
val âconst_theory_cacheá : (string * string) E_DICT ref = ref initial_e_dict;
=TEX
=SML
val âty_theory_cacheá : (string * string) E_DICT ref = ref initial_e_dict;
=TEX
The following function restores the caches to their initial state:
=SML
fun âclear_cachesá (():unit) : unit = (
	ty_info_cache := initial_e_dict;
	const_info_cache := initial_e_dict;
	fixity_cache := initial_e_dict;
	terminators := [];
	language := "HOL";
	const_theory_cache := initial_e_dict;
	ty_theory_cache := initial_e_dict
);
=TEX
It is actually more convenient to have a single update function
parameterised by the type of declaration being made. This requires a few
local utilities to cope with the more complex cases:
=SML
local
=TEX
=SML
fun âcache_terminatorá (t : string) = (
	let	val et = explode t;
		val len = length et;
		fun aux [] = [et]
		|   aux (h :: more) = (
			if length h > len
			then h :: aux more
			else et :: h :: more
		);
	in	terminators := aux(!terminators)
	end
);
=TEX
=SML
fun âuncache_terminatorá (t : string) = (
	terminators := !terminators less explode t
);
=TEX
=SML
fun âcache_fixityá (s : string, fix : FIXITY) = (
	case fix of
		Nonfix => fixity_cache := e_delete s (!fixity_cache)
	|	_ => fixity_cache := e_enter s fix (!fixity_cache)
);
=TEX
=SML
fun âcache_aliasá (thy : string) (a : string, (s:string, ty : TYPE)) : unit = (
	let
val cache1 = 
	e_enter
	a
	(case e_lookup a (!const_info_cache) of
		Value((ty', alinfs), atys) => (
			 ((Antiunify.antiunify(ty, ty'), (s, ty) :: alinfs), atys)
	) |	Nil => (
			 ((ty, [(s, ty)]), [])
	))
	(!const_info_cache);
val cache2 =
	e_enter
	s
	(case e_lookup s (!const_info_cache) of
		Value((ty', alinfs), atys) => (
			 ((ty', alinfs), (a, ty) :: atys)
	) |	Nil => (
			case get_const_type s of
				Value ty' => ((ty', [(s, ty')]), [(a, ty)])
			|	Nil => fail "cache_alias" 20001 [fn()=>thy]
	))
	cache1;
	in	const_info_cache := cache2
	end
);
=TEX
We need to antiunify lists of types when aliases are deleted:
=SML
fun âlist_antiunifyá ([] : TYPE list) : TYPE = mk_vartype "'a"
|   list_antiunify [ty] = ty
|   list_antiunify (ty :: more) = Antiunify.antiunify(ty, list_antiunify more);
=TEX
=SML
fun âuncache_aliasá (a : string, (s:string, ty : TYPE)) : unit = (
	let
val cache1 =
	case e_lookup a (!const_info_cache) of
		Value((_, alinfs), atys) => (
			case alinfs drop 
					(fn(s', ty') => s = s' andalso is_same_type ty ty')
			of
				[] => e_delete a (!const_info_cache)
			|	some => e_enter
					a
					((list_antiunify (map snd some) , some), atys)
					(!const_info_cache)
	) |	Nil => ( !const_info_cache
	);
val cache2 =
	case e_lookup s cache1 of
		Value((ty', alinfs), atys) => (
			e_enter
			s
			((ty', alinfs), atys drop 
				(fn(a', ty') => a = a' andalso is_same_type ty ty'))
			cache1
	) |	Nil => ( cache1
	);
	in	const_info_cache := cache2
	end
);
=TEX
=SML
fun âcache_type_abbrevá(a : string, (args : string list, ty : TYPE)) : unit = (
	ty_info_cache := e_enter a (length args, Value(args, ty)) (!ty_info_cache)
);
=TEX
=SML
fun âuncache_type_abbrevá(a : string) : unit = (
	case get_type_arity a of
		Nil => ty_info_cache := e_delete a (!ty_info_cache)
	|	Value ar => ty_info_cache := e_enter a (ar, Nil) (!ty_info_cache)
);
=TEX
=SML
fun âcache_languageá (thy : string) (lang : string) = (
	let	val conids = map (fst o dest_const) (get_consts thy)
		val tyids = map (fst o dest_ctype) (get_types thy);
		fun aux dict [] = dict
		|   aux dict (id :: more) = aux (e_enter id (thy, lang) dict) more;
	in	const_theory_cache := aux (!const_theory_cache) conids;
		ty_theory_cache := aux (!ty_theory_cache) tyids;
		language := lang
	end
);
=TEX
=SML
in
fun âcache_declá (thy : string) (dec : DECL) : unit = (
	case dec of
		DeclTerminator t => cache_terminator t
	|	UnDeclTerminator t => uncache_terminator t
	|	DeclFixity sfix  => cache_fixity sfix
	|	DeclAlias asty => cache_alias thy asty
	|	UnDeclAlias asty => uncache_alias asty
	|	DeclTypeAbbrev aargsty => cache_type_abbrev aargsty
	|	UnDeclTypeAbbrev  a => uncache_type_abbrev a
	|	SetLanguage lang => cache_language thy lang
);
end; (* of local ... in ... end *)
=TEX
\subsection{THEORY DATABASE ACCESS FUNCTIONS}
The symbol table module uses a single slot in the theory user data 
under the key ``icl'st'' to hold the declarations which apply
to the theory. The declarations are held as a fairly direct encoding
of a list of $DECL$s.

\subsection{Utilities For Accessing the User Data}
In this section we define the functions we use to fetch and store the
lists of $USER\_DATUM$s belonging to the symbol table held in theories.
=SML
val ud_key = "icl'st";
=TEX
The following function is the only place at which we pass an unknown
theory name to the kernel interface.
=SML
fun fetch_sym_tab_data (thy : string) : USER_DATUM list = (
	if thy mem theory_names () orelse thy = "-"
	then	case get_user_datum thy ud_key handle Fail _ => UD_Int(0, []) of
			(UD_Int(0, uds)) => uds
		|	_ => fail "fetch_sym_tab_data" 20001 [fn()=>thy]
	else	fail "fetch_sym_tab_data" 20601 [fn()=>thy]
);
=TEX
The theory name argument to $store\_sym\_tab\_datum$ and
$delete\_sym\_tab\_datum$ are only used in error messages.
=SML
fun store_sym_tab_datum (ud : USER_DATUM) : unit = (
	let	val uds = (
			case get_user_datum "-" ud_key handle Fail _ => UD_Int(0, []) of
				(UD_Int(0, uds)) => uds
			|	_ => fail "fetch_sym_tab_data" 20001 [fn()=>"-"]);
	in 	set_user_datum(ud_key, UD_Int(0, ud :: uds))
	end
);
=TEX
We sometimes need to delete entries. $delete\_sym\_tab\_datum$
does this (and does nothing if the entry to be deleted is not there).
=SML
fun delete_sym_tab_datum (ud : USER_DATUM) : unit = (
	let	val uds = (
			case get_user_datum "-" ud_key handle Fail _ => UD_Int(0, []) of
				(UD_Int(0, uds)) => uds
			|	_ => fail "fetch_sym_tab_data" 20001 [fn()=>"-"])
	in 	set_user_datum(ud_key, UD_Int(0, uds less ud))
	end
);
=TEX
\subsection{Encoding and Decoding Functions}
First of all we give an encoding for $FIXITY$ values.
We encode constructors as small numbers, since on most Standard ML compilers
these are held in a single word of storage.
=SML
fun âencode_fixityá (fix : FIXITY) : USER_DATUM = (
	case fix of
		Nonfix => UD_Int(0, [])
	|	Binder => UD_Int(1, [])
	|	Infix p => UD_Int(2, [UD_Int(p, [])])
	|	Prefix p => UD_Int(3, [UD_Int(p, [])])
	|	Postfix p => UD_Int(4, [UD_Int(p, [])])
);
=TEX
=SML
fun âdecode_fixityá (ud : USER_DATUM) : FIXITY = (
	case ud of
		UD_Int(0, []) => Nonfix
	|	UD_Int(1, []) => Binder
	|	UD_Int(2, [UD_Int(p, [])]) => Infix p
	|	UD_Int(3, [UD_Int(p, [])]) => Prefix p
	|	UD_Int(4, [UD_Int(p, [])]) => Postfix p
	|	_ => fail "decode_fixity" 20001 []
);
=TEX
=SML
fun âencode_declá (dec : DECL) : USER_DATUM = (
	case dec of
		DeclTerminator t => UD_Int(0, [UD_String(t, [])])
	|	UnDeclTerminator t => UD_Int(1, [UD_String(t, [])])
	|	DeclFixity (s, fix)  => UD_Int(2, [UD_String(s, [encode_fixity fix])])
	|	DeclAlias (a, (s, ty)) =>
			UD_Int(3, [UD_String(a, [UD_String(s, [UD_Type(ty, [])])])])
	|	UnDeclAlias (a, (s, ty)) =>
			UD_Int(4, [UD_String(a, [UD_String(s, [UD_Type(ty, [])])])])
	|	DeclTypeAbbrev (a, (args, ty)) =>
			UD_Int(5, [UD_String(a, [UD_Type(ty, map ((switch(curry UD_String))[]) args)])])
	|	UnDeclTypeAbbrev a => UD_Int(6, [UD_String(a, [])])
	|	SetLanguage lang => UD_Int(7, [UD_String(lang, [])])
);
=TEX
=SML
fun âdecode_declá (thy : string) (ud : USER_DATUM) : DECL = (
	case ud of
		UD_Int(0, [UD_String(t, [])]) => DeclTerminator t
	|	UD_Int(1, [UD_String(t, [])]) => UnDeclTerminator t
	|	UD_Int(2, [UD_String(s, [fix])]) => DeclFixity (s, decode_fixity fix)
	|	UD_Int(3, [UD_String(a, [UD_String(s, [UD_Type(ty, [])])])]) => 
				DeclAlias (a, (s, ty))
	|	UD_Int(4, [UD_String(a, [UD_String(s, [UD_Type(ty, [])])])]) => 
				UnDeclAlias (a, (s, ty))
	|	UD_Int(5, [UD_String(a, [UD_Type(ty, args)])]) =>
			DeclTypeAbbrev (a, (map
				(fn UD_String(arg, []) => arg
				| _ => fail "decode_decl" 20001 [fn()=> thy]) args, ty))
	|	UD_Int(6, [UD_String(a, [])]) => UnDeclTypeAbbrev a
	|	UD_Int(7, [UD_String(lang, [])]) => SetLanguage lang
	|	_ => fail "decode_decl" 20001 [fn()=> thy]
);
=TEX
Occasionally we need to extract from a theory the
declarations relating to a particular name.
=SML
fun get_id_data (id : string) (thy : string) : USER_DATUM list = (
		fetch_sym_tab_data thy
	drop	(fn UD_Int(_, [UD_String(s, _)]) => s <> id | _ => true)
);
=TEX
\subsection{Update Functions}
As with the cache update functions, it is convenient to have a single update
function parameterised by the type of declaration being made.
As theory updates are never done without also updating the cache the theory
update function calls the cache update function when its own work is complete.
Again we have a section of local utilities to assist:
=SML
local
=TEX
=SML
fun store_terminator (thy : string) (s : string) : unit = (
	delete_sym_tab_datum (encode_decl(UnDeclTerminator s));
	store_sym_tab_datum (encode_decl(DeclTerminator s))
);
=TEX
=SML
fun unstore_terminator (thy : string) (s : string) : unit = (
	let	val uds = get_id_data s thy;
		fun aux ud = (
			case decode_decl thy ud of
				DeclTerminator s' => s' = s
			|	_ => false
		);
	in	if any uds aux
		then	delete_sym_tab_datum (find uds aux)
		else	store_sym_tab_datum (encode_decl(UnDeclTerminator s))
	end
);
=TEX
=SML
fun store_fixity (thy : string) (s : string, fix : FIXITY) : unit = (
	let	val uds = get_id_data s thy;
		fun aux ud = (
			case decode_decl thy ud of
				DeclFixity(s', _) => s' = s
			|	_ => false
		);
	in	if any uds aux
		then 	case fix of
				Nonfix => delete_sym_tab_datum (find uds aux)
			|	_ => (
					delete_sym_tab_datum (find uds aux);
					store_sym_tab_datum (encode_decl(DeclFixity (s, fix)))
			)
		else	store_sym_tab_datum (encode_decl(DeclFixity (s, fix)))
	end
);
=TEX
=SML
fun store_alias (thy : string) (a : string, (s:string, ty:TYPE)) : unit = (
	store_sym_tab_datum (encode_decl(DeclAlias (a, (s, ty))))
);
=TEX
=SML
fun unstore_alias (thy : string) (a : string, (s:string, ty:TYPE)) : unit = (
	let	val uds = get_id_data a thy;
		fun aux ud = (
			case decode_decl thy ud of
				DeclAlias(a', (s', ty')) => a = a' andalso s = s'
					andalso is_same_type ty ty' 
			|	_ => false
		);
	in	if any uds aux
		then	delete_sym_tab_datum (find uds aux)
		else	store_sym_tab_datum (encode_decl(DeclAlias (a, (s, ty))))
	end
);
=TEX
=SML
fun store_type_abbrev (thy : string) (a : string, (args:string list, ty:TYPE)) : unit = (
	let	val uds = get_id_data a thy;
		fun aux ud = (
			case decode_decl thy ud of
				DeclTypeAbbrev(a', _) => a = a'
			|	_ => false
		);
	in	if any uds aux
		then	delete_sym_tab_datum (find uds aux)
		else	()
	end;
	store_sym_tab_datum (encode_decl(DeclTypeAbbrev (a, (args, ty))))
);
=TEX
=SML
fun unstore_type_abbrev (thy : string) (a : string) : unit = (
	let	val uds = get_id_data a thy;
		fun aux ud = (
			case decode_decl thy ud of
				DeclTypeAbbrev(a', _) => a = a'
			|	_ => false
		);
	in	if any uds aux
		then	delete_sym_tab_datum (find uds aux)
		else	store_sym_tab_datum (encode_decl(UnDeclTypeAbbrev a))
	end
);
=TEX
=SML
fun store_language (thy : string) (lang : string) : unit = (
	let	val uds = fetch_sym_tab_data thy;
		fun aux ud = (
			case decode_decl thy ud of
				SetLanguage _ => true
			|	_ => false
		);
	in	if any uds aux
		then	delete_sym_tab_datum (find uds aux)
		else	()
	end;
	store_sym_tab_datum (encode_decl(SetLanguage lang))
);
=TEX
=SML
in
fun âstore_declá (area : string) (dec : DECL) : unit = (
	let	val thy = get_current_theory_name();
	in
		case get_current_theory_status() of
			TSNormal => (
				(case dec of
					DeclTerminator t => store_terminator thy t
				|	UnDeclTerminator t => unstore_terminator thy t
				|	DeclFixity sfix  => store_fixity thy sfix
				|	DeclAlias asty => store_alias thy asty
				|	UnDeclAlias asty => unstore_alias thy asty
				|	DeclTypeAbbrev aargsty => store_type_abbrev thy aargsty
				|	UnDeclTypeAbbrev  a => unstore_type_abbrev thy a
				|	SetLanguage lang => store_language thy lang);
				cache_decl thy dec
		) |	_ => fail area 20002 [fn () => thy]
	end
);
end; (* of local ... in ... end *)
=TEX
=TEX
\section{ACCESS FUNCTIONS}
\subsection{Terminators}
=SML
fun âget_current_terminatorsá (():unit) : string list list =(
	!terminators
);
=TEX
The following function checks that a string obeys the rules for terminators
identified in \cite{DS/FMU/IED/DEF001}. 
=SML
fun is_ok_terminator (s : string) = (
	let	fun strip_macro (s :: more) = (
			if is_macro s
			then more
			else strip_macro more
		) | strip_macro [] = [];

		fun ok_rest (s :: more) = (
			(is_alnum s orelse is_symbolic s orelse is_copula s)
			andalso ok_rest more
		) | ok_rest [] = true;
	in	case explode s of
			s :: more => (
				if is_macro s
				then ok_rest(strip_macro more)
				else is_symbolic s andalso ok_rest more
		) |	[] => false
	end
);
=SML
fun âdeclare_terminatorá (s :  string) : unit = (
	if not(is_ok_terminator s)
	then fail "declare_terminator" 20101 [fn()=>s]
	else if explode s mem (!terminators)
	then fail "declare_terminator" 20102 [fn()=>s]
	else store_decl "declare_terminator" (DeclTerminator s)
);
=TEX
=SML
fun âundeclare_terminatorá (s : string) : unit = (
	if not(explode s mem !terminators)
	then fail "undeclare_terminator" 20102 [fn()=>s]
	else store_decl "undeclare_terminator" (UnDeclTerminator s)
);
=TEX
\subsection{Fixity}
=SML
fun âget_fixityá (s : string) : FIXITY = (
	case e_lookup s (!fixity_cache) of
		Value fix => fix
	| 	_ => Nonfix
);
=SML
fun âdeclare_binderá (s : string) = (
	store_decl "declare_binder" (DeclFixity(s, Binder))
);
=TEX
=SML
fun âdeclare_infixá (prec : int, s : string) : unit = (
	store_decl "declare_infix" (DeclFixity(s, Infix prec))
);
=TEX
=SML
fun âdeclare_prefixá (prec : int, s : string) : unit = (
	store_decl "declare_prefix" (DeclFixity(s, Prefix prec))
);
=TEX
=SML
fun âdeclare_postfixá (prec : int, s : string) : unit = (
	store_decl "declare_postfix" (DeclFixity(s, Postfix prec))
);
=SML
fun âdeclare_nonfixá (s : string) : unit = (
	case get_fixity s of
		Nonfix => ()
	|	_ => store_decl "declare_nonfix" (DeclFixity(s, Nonfix))
);
=TEX
\subsection{Constants and Aliases}
=SML
fun âget_const_infoá (c : string) : (TYPE * ((string * TYPE)list)) OPT = (
	case e_lookup c (!const_info_cache) of
		Nil => (
			case get_const_type c of
				Value ty => Value(ty, [(c, ty)])
			|	Nil => Nil
	) |	Value (v, _) => Value v
);
=TEX
=SML
fun âdeclare_aliasá (s : string, tm : TERM) : unit = (
	if not (is_const tm)
	then term_fail "declare_alias" 20301 [tm]
	else	let	val (c, ty) = dest_const tm
		in	if is_Nil(get_const_type c)
			then term_fail "declare_alias" 20305 [tm]
			else case get_const_info s of
				Nil => store_decl"declare_alias"(DeclAlias(s, (c, ty)))
			|	Value (_, stys) => (
					if any stys (fn (c', ty') => c = c' andalso is_same_type ty ty')
					then fail "declare_alias" 20302 [fn()=>s, fn()=>c]
					else store_decl"declare_alias"(DeclAlias(s, (c, ty)))
			)
		end
);
=TEX
=SML
fun âundeclare_aliasá (s : string, tm : TERM) : unit = (
	if not (is_const tm)
	then term_fail "undeclare_alias" 20301 [tm]
	else	let	val (c, ty) = dest_const tm
		in	case get_const_info s of
				Nil => store_decl"undeclare_alias"(UnDeclAlias(s, (c, ty)))
			|	Value (_, stys) => (
					if not(any stys (fn (c', ty') => c = c' andalso is_same_type ty ty'))
					then fail "undeclare_alias" 20303 [fn()=>s, fn()=>c]
					else store_decl"undeclare_alias"(UnDeclAlias(s, (c, ty)))
			)
		end
);
=TEX
=SML
fun âresolve_aliasá (s : string, ty : TYPE) : TERM = (
	case get_const_info s of
		Nil => fail "resolve_alias" 20304 [fn()=>s]
	|	Value (_, stys) => (
			(mk_const(fst(find stys (fn(s', ty') => is_type_instance ty ty')), ty))
			handle Fail _ => fail "resolve_alias" 20304 [fn()=>s]
	)
);
=TEX
=SML
fun âget_aliasá (s : string, ty : TYPE) : string = (
	case e_lookup s (!const_info_cache) of
		Value (_, atys) => (
			(fst(find atys (fn(a, ty') => is_type_instance ty ty')))
			handle Fail _ => s
		) |	Nil => s
);
=TEX
\subsection{Types and Type Abbreviations}
=SML
fun âget_type_infoá (t : string) : (int * (string list * TYPE) OPT) OPT = (
	case e_lookup t (!ty_info_cache) of
		Nil => (
			case get_type_arity t of
				Value a => Value(a, Nil)
			|	Nil => Nil
	) |	v => v
);
=TEX
=SML
fun âdeclare_type_abbrevá (a : string, args : string list, ty : TYPE) : unit = (
	if not(all_different args)
	then fail "declare_type_abbrev" 20407 [fn()=>format_list Combinators.I args ", "]
	else case get_type_info a of
		Nil => (
			store_decl"declare_type_abbrev"(DeclTypeAbbrev (a, (args, ty)))
	) |	Value(_, Value _) => (
			warn "declare_type_abbrev" 20401 [fn()=>a];
			store_decl"declare_type_abbrev"(DeclTypeAbbrev (a, (args, ty)))
	) |	Value(_, Nil) => (
			warn "declare_type_abbrev" 20402 [fn()=>a];
			store_decl"declare_type_abbrev"(DeclTypeAbbrev (a, (args, ty)))
	)
);
=TEX
=SML
fun âundeclare_type_abbrevá (a : string) : unit = (
	case get_type_info a of
		Value(_, Value _) => store_decl"undeclare_type_abbrev"(UnDeclTypeAbbrev a)
	|	_ => fail "undeclare_type_abbrev" 20403 [fn()=>a]
);
=TEX
=SML
fun âis_type_abbrevá (a : string) : bool =(
	case get_type_info a of
		Value(_, Value _) => true
	|	_ => false
);
=TEX
=SML
fun âget_type_abbrevá (a : string) : string list * TYPE = (
	case get_type_info a of
		Value(_, Value (formals, ty)) => (formals, ty)
	|	_ => fail "expand_type_abbrev" 20404 [fn()=>a]
);
=TEX
=SML
fun âexpand_type_abbrevá (a : string, actuals : TYPE list) : TYPE = (
	case get_type_info a of
		Value(_, Value (formals, ty)) => (
			let	val subs = (combine actuals (map mk_vartype formals))
					handle X =>
						divert X "combine" "expand_type_abbrev"
						(if length formals = 1 then 20405 else 20406)
						[fn()=> a,
						 fn()=>string_of_int(length formals),
						 fn()=>string_of_int(length actuals)];
			in	inst_type subs ty
			end
	) |	_ => fail "expand_type_abbrev" 20404 [fn()=>a]
);
=TEX
\subsection{Languages}
=SML
fun âset_current_languageá (lang : string) : unit = (
	store_decl "set_current_language" (SetLanguage lang)
);
=TEX
=SML
fun âget_current_languageá (() : unit) : string = (
	!language
);
=TEX
=SML
fun âget_const_languageá (s : string) : string = (
	case e_lookup s (!const_theory_cache) of
		Value (_, lang) => lang
	|	Nil => get_current_language()
);
=TEX
=SML
fun âget_type_languageá (s : string) : string = (
	case e_lookup s (!ty_theory_cache) of
		Value (_, lang) => lang
	|	Nil => get_current_language()
);
=TEX
\subsection{Theory Access Functions}
=TEX
All the theory access functions go via the following utility which
selects the relevant information from the theory. 
=SML
fun get_selected_ids (thy : string) (sel : DECL -> bool) (uds : USER_DATUM list) : (DECL) list = (
	case uds of
		[] => []
	|	ud :: more => (
			let	val dec = decode_decl thy ud;
			in	if sel dec
				then 	dec :: get_selected_ids thy sel more
				else get_selected_ids thy sel more
			end
	)
);
=TEX
=SML
fun âget_terminatorsá (thy : string) : string list = (
	let	fun sel (DeclTerminator _) = true
		|   sel _ = false;
		fun coerce(DeclTerminator t) = t
		|   coerce _ = fail "get_terminators" 20003 [fn()=> "coercion failed"];
	in	map coerce(get_selected_ids thy sel (fetch_sym_tab_data thy))
	end	handle X => reraise X "get_terminators"
);
=TEX
=TEX
=SML
fun âget_undeclared_terminatorsá (thy : string) : string list = (
	let	fun sel (UnDeclTerminator _) = true
		|   sel _ = false;
		fun coerce(UnDeclTerminator t) = t
		|   coerce _ = fail "get_undeclared_terminators" 20003 [fn()=> "coercion failed"];
	in	map coerce(get_selected_ids thy sel (fetch_sym_tab_data thy))
	end	handle X => reraise X "get_terminators"
);
=TEX
=SML
fun âget_bindersá (thy : string) : string list = (
	let	fun sel (DeclFixity(_, Binder)) = true
		|   sel _ = false;
		fun coerce(DeclFixity(s, Binder)) = s
		|   coerce _ = fail "get_binders" 20003 [fn()=> "coercion failed"];
	in	map coerce(get_selected_ids thy sel (fetch_sym_tab_data thy))
	end	handle X => reraise X "get_binders"
);
=TEX
=SML
fun âget_infixesá (thy : string) : (int * string) list = (
	let	fun sel (DeclFixity(_, Infix _)) = true
		|   sel _ = false;
		fun coerce(DeclFixity(s, Infix p)) = (p, s)
		|   coerce _ = fail "get_infixes" 20003 [fn()=> "coercion failed"];
	in	map coerce(get_selected_ids thy sel (fetch_sym_tab_data thy))
	end	handle X => reraise X "get_infixes"
);
=TEX
=SML
fun âget_prefixesá (thy : string) : (int * string) list = (
	let	fun sel (DeclFixity(_, Prefix _)) = true
		|   sel _ = false;
		fun coerce(DeclFixity(s, Prefix p)) = (p, s)
		|   coerce _ = fail "get_prefixes" 20003 [fn()=> "coercion failed"];
	in	map coerce(get_selected_ids thy sel (fetch_sym_tab_data thy))
	end	handle X => reraise X "get_prefixes"
);
=TEX
=SML
fun âget_postfixesá (thy : string) : (int * string) list = (
	let	fun sel (DeclFixity(_, Postfix _)) = true
		|   sel _ = false;
		fun coerce(DeclFixity(s, Postfix p)) = (p, s)
		|   coerce _ = fail "get_postfixes" 20003 [fn()=> "coercion failed"];
	in	map coerce(get_selected_ids thy sel (fetch_sym_tab_data thy))
	end	handle X => reraise X "get_postfixes"
);
=TEX
=SML
fun âget_nonfixesá (thy : string) : string list = (
	let	fun sel (DeclFixity(_, Nonfix)) = true
		|   sel _ = false;
		fun coerce(DeclFixity(s, Nonfix)) = s
		|   coerce _ = fail "get_nonfixes" 20003 [fn()=> "coercion failed"];
	in	map coerce(get_selected_ids thy sel (fetch_sym_tab_data thy))
	end	handle X => reraise X "get_nonfixes"
);
=TEX
=SML
fun âget_type_abbrevsá (thy : string) : (string * (string list * TYPE)) list = (
	let	fun sel (DeclTypeAbbrev _) = true
		|   sel _ = false;
		fun coerce(DeclTypeAbbrev tyab) = tyab
		|   coerce _ = fail "get_type_abbrevs" 20003 [fn()=> "coercion failed"];
	in	map coerce(get_selected_ids thy sel (fetch_sym_tab_data thy))
	end	handle X => reraise X "get_type_abbrevs"
);
=TEX
=SML
fun âget_undeclared_type_abbrevsá (thy : string) : string list = (
	let	fun sel (UnDeclTypeAbbrev _) = true
		|   sel _ = false;
		fun coerce(UnDeclTypeAbbrev tyab) = tyab
		|   coerce _ = fail "get_undeclared_type_abbrevs" 20003 [fn()=> "coercion failed"];
	in	map coerce(get_selected_ids thy sel (fetch_sym_tab_data thy))
	end	handle X => reraise X "get_undeclared_type_abbrevs"
);
=TEX
=SML
fun âget_aliasesá (thy : string) : (string * TERM) list = (
	let	fun sel (DeclAlias _) = true
		|   sel _ = false;
		fun coerce(DeclAlias (a, sty)) = (a, mk_const sty)
		|   coerce _ = fail "get_aliases" 20003 [fn()=> "coercion failed"];
	in	map coerce(get_selected_ids thy sel (fetch_sym_tab_data thy))
	end	handle X => reraise X "get_aliases"
);
=TEX
=SML
fun âget_undeclared_aliasesá (thy : string) : (string * TERM) list = (
	let	fun sel (UnDeclAlias _) = true
		|   sel _ = false;
		fun coerce(UnDeclAlias (a, sty)) = (a, mk_const sty)
		|   coerce _ = fail "get_undeclared_aliases" 20003 [fn()=> "coercion failed"];
	in	map coerce(get_selected_ids thy sel (fetch_sym_tab_data thy))
	end	handle X => reraise X "get_undeclared_aliases"
);
=TEX
=TEX
=SML
fun âget_languageá (thy : string) : string = (
	let	fun sel (SetLanguage _) = true
		|   sel _ = false;
	in	case get_selected_ids thy sel (fetch_sym_tab_data thy) of
			SetLanguage lang :: _ => lang
		|	_ => "HOL"
	end	handle X => reraise X "get_language"
);
=TEX
=SML
fun âget_const_theoryá (c : string) : string = (
	case e_lookup c (!const_theory_cache) of
		Value (thy, _) => thy
	|	Nil => fail "get_const_theory" 20701 [fn()=>c]
);
=TEX
=SML
fun âget_type_theoryá (ty : string) : string = (
	case e_lookup ty (!ty_theory_cache) of
		Value (thy, _) => thy
	|	Nil => fail "get_type_theory" 20702 [fn()=>ty]
);
=SML
fun restore_defaults (():unit) : unit = (
	warn "restore_defaults" 20703 [get_current_theory_name];
	set_user_datum(ud_key, UD_Int(0, []))
);
=TEX
\section{HANDLING CONTEXT CHANGES}
Of the various classes of kernel state change, identified in
\cite{DS/FMU/IED/DTD012}, only $open\_theory$, $new\_parent$ and the
operations which introduce or
delete types or constants are currently of relevance
to the symbol table module.

When a theory is opened, we rebuild the caches from scratch. Schemes which
attempted to preserve the information from theories which have not been
unloaded have been considered, but seem to be too complex, because of the
need to ``undo undeclarations'' e.g. if theory $thy1$ has $thy2$ as an ancestor
and $thy1$ contains a nonfix declaration overriding a binder declaration
in $thy2$, then when we change context from $thy1$ to $thy2$ we must
undo the nonfix declaration.
=TEX
=SML
fun get_theory_language (thy : string) : string = (
	let	fun aux (ud :: more) = (
			case decode_decl thy ud of
				SetLanguage lang => lang
			|	_ => aux more
		) | aux [] = "HOL";
	in	aux(fetch_sym_tab_data thy)
	end
);
=TEX
=SML
fun âbuild_theory_cachesá (thy : string) = (
	cache_decl thy (SetLanguage(get_theory_language thy))
);
=TEX
=SML
fun âcache_constsá (cs : string list) : unit = (
	let	val curthy = get_current_theory_name();
		val curlang = get_theory_language curthy
		fun do1 c = (
			const_theory_cache :=
			e_enter c(curthy, curlang)(!const_theory_cache)
		);
	in	map do1 cs; ()
	end
);
=TEX
=SML
fun âuncache_constá (t : TERM) : unit = (
	let	val s = fst(dest_const t);
		val aliases = (
			case get_const_info s of
				Value (_, atys) => atys
			|	Nil => []);
		fun aux ((a, ty) :: more) = (
			undeclare_alias (a, mk_const(s, ty));
			aux more
		) | aux [] = ();
	in	(aux aliases;
		const_theory_cache := e_delete s (!const_theory_cache))
	end
	handle Fail X => error "uncache_const" 20002 [fn()=>get_message X]
);
=TEX
=SML
fun âuncache_tyá (ty : string) : unit = (
	ty_theory_cache := e_delete ty(!ty_theory_cache)
);
=TEX
=SML
fun âcache_tysá (tys : string list) : unit = (
	let	val curthy = get_current_theory_name();
		val curlang = get_theory_language curthy
		fun do1 ty = (
			ty_theory_cache :=
			e_enter ty(curthy, curlang)(!ty_theory_cache)
		);
	in	map do1 tys; ()
	end
);
=TEX
$cache\_ancestry$ loads the symbol table information
contained in a theory and all its ancestors into the caches:
=SML
fun cache_theory (current : string) : unit = (
	clear_caches();
	map
	(fn thy => ((map (cache_decl thy o decode_decl thy) (fetch_sym_tab_data thy));
		build_theory_caches thy))
	(get_ancestors current);
	()
);
=TEX
Finally we declare our interest in kernel state changes using
the interface defined in \cite{DS/FMU/IED/DTD012}:
=SML
val SideEffect = on_kernel_state_change
	(fn	OpenTheory (current, (_, _)) => cache_theory current
	|	NewParent _ => cache_theory(get_current_theory_name())
	|	NewConst (c, _) => cache_consts [c]
	|	SimpleNewDefn ((_, c, _), _) => cache_consts[c]
	|	NewSpecification ((_, i, thm), _) => (
			cache_consts(map(fst o dest_var)((fst(strip_„((snd o dest_thm) thm))) to (i-1)))
	) |	NewType (ty, _) => cache_tys [ty]
	|	NewTypeDefn ((_, ty, _, _), _) => cache_tys [ty]
	|	DeleteConst c => uncache_const c
	|	DeleteType ty => uncache_ty ty
	|	_ => ()
);
=TEX
\section{EPILOGUE}
=SML
end; (* of structure SymbolTable *)
=TEX
=SML
open SymbolTable;
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}
