%  mdt016.doc %Z% $Date$ $Revision$ $RCSfile$

=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Type Inference}  %% Mandatory field
\TPPref{DS/FMU/IED/MDT016}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}
%\TPPstatus{Approved}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document comprises test cases and test data for
the type inference mechanism.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1 - 1.6]
Initial drafts.

\item[Issue 1.7]
Changes made as required by desk check report ID0084.

\item[Issue 2.1]
This is an approved version of issue 1.7.

\item[Issue 2.2 21 November 1991]
Modified as a result of changes to the implementation
of type inference (Re: new unification algorithm). Also
renamed $ty\_to\_type$ to $make\_type$.

\item[Issue 2.3 (29 November 1991)]
Added additional miscellaneous tests which are known
to highlight various classes of problems in unification.


\item[Issue 2.4, \FormatDate{92/01/20} ] Updated to use new fonts.

\item[Issue \SCCSversion, \FormatDate{92/02/25} ]
Change the function $mt\_run\_fail1$ to bring into
line with the new exception raised  when a
type checking error occurs.

\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises tests of the functions
$is\_varstruct$, $make\_type$ and $make\_term$
which are specified in \cite{DS/FMU/IED/IMP016}.

\subsection{Introduction}

\subsubsection{Background and Purpose}

The purpose of this document is to test
the functions in accordance with the test policy in
\cite{DS/FMU/IED/DTD016} and the guidelines laid out in the
quality plan, \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}

This document depends on the signature $TypeInference$ specified
in \cite{DS/FMU/IED/DTD016}, and the structure $TypeInference$
specified in \cite{DS/FMU/IED/IMP016}. It makes use of the
module test harness described in \cite{DS/FMU/IED/DTD013} and
\cite{DS/FMU/IED/IMP013}.

\subsubsection{Possible Enhancements}

None.

\subsubsection{Deficiencies}

None Known.

\section{MODULE TEST DESIGN}

The module tests provided in this document test the
type inference mechanism defined in \cite{DS/FMU/IED/DTD016}.

In general, in this document, later tests make use
of test data of earlier tests, and this principle
has to some extent determined the order in which
the tests appear, and is the justification for
testing constructs in a different order from which
they are introduced in other documents
\cite{DS/FMU/IED/DTD016}\cite{DS/FMU/IED/DTD019}.
It therefore follows, failure of earlier tests will
probably cause later tests to fail.

Test data is stored in ML variables which follow the
naming
convention $i\_casename\_1$, $i\_casename\_2$ and
so on for input data, and $o\_casename\_1$, $o\_casename\_2$
for expected results.

The description of test cases is in each case followed
by the corresponding test data.

\section{TEST CASES AND TEST DATA}

\subsection{Initialisation}

Initialise the test harness.

=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results ();
=TEX

First, we print a message to indicate to the user to expect
error messages to appear. Using the error message subsystem
\cite{DS/FMU/IED/DTD002}, it is not possible to suppress
nor re-route the messages which are printed when an failure
message is generated.

=SML
map diag_line ["Successful execution of these tests will cause error",
"messages to be generated. You should check visually that",
"the error messages are sensible since the harness itself",
"is incapable of doing this. You can consider that the",
"module tests have run successfully provided that",
"	a) you are satisfied with the error messages and",
"	b) that the report states that all module tests have",
"	   passed."];
=TEX
Next, we make the parser and type inference interfaces
directly available to the tests.
=SML
local
open Parser TypeInference;
=TEX

The following function may one day appear in the module
test package. It runs a set of module tests and expects
an exception constructed with ``Fail'' to be raised. Since
it is not possible to check the output, we don't bother.

=SML
fun Ûmt_run_fail1Ý (nil : (string * ('a -> 'b) * 'a) list)
	: (string * bool) list = nil
  | mt_run_fail1 ((tcase, f, arg)::rest) = (
	let val res = f arg
	in
		(tcase, false)::mt_run_fail1 rest
	end

	handle	QuotationError => (tcase,true)::mt_run_fail1 rest
	|	ANY => (tcase,false)::mt_run_fail1 rest
);

=TEX

To test the mechanism, we have to define some constants. The
following function will enter various useful constants into
the symbol table.

=SML
fun Ûload_symtabÝ() = (
let
val vartype_a = mk_vartype "'a";
val vartype_b = mk_vartype "'b";

val dummy = new_type ("­", 2);
val dummy = new_type ("¸", 2);
val dummy = new_const (",", mk_­_type (vartype_a, mk_­_type (vartype_b,
	mk_ctype ("¸", [vartype_a, vartype_b]))));
val dummy = map declare_infix [(100, "­"), (200, "¸")];
val dummy = map declare_terminator ["­", "¸"];


val dummy = new_type ("BOOL", 0);
val dummy = new_const ("T", BOOL);
val dummy = new_const ("F", BOOL);

val dummy = new_const ("=", mk_­_type (vartype_a,mk_­_type (vartype_a, BOOL)));
val dummy = new_const ("³", mk_­_type (BOOL, BOOL));

val dummy = new_const ("µ", mk_­_type (mk_­_type (vartype_a, BOOL), BOOL));
val dummy = new_const ("¶", mk_­_type (mk_­_type (vartype_a, BOOL), BOOL));

val dummy = map declare_binder ["Ì", "µ", "¶"];
val dummy = map declare_prefix [(300, "³")];
val dummy = declare_infix (50, "=");
val dummy = map declare_terminator ["³", "="];

val dummy = new_type ("î", 0);
val dummy = new_const (">", mk_­_type (î, mk_­_type (î, BOOL)));
val dummy = map declare_infix [(60, ">"), (100, ",")];
val dummy = declare_terminator ">";

val CHAR = new_type ("CHAR", 1);
val SET = new_type ("SET", 1);
val LIST = new_type ("LIST", 1);

val dummy = new_const ("Í", mk_­_type (mk_­_type (mk_vartype "'a", BOOL),
	mk_vartype "'a"));
val dummy = declare_binder "Í";
val dummy = declare_terminator "Í";

in
	"Symbol Table Now Loaded"
end);
=TEX
We only load the symbol table of it has not already been
loaded.
=SML
val dummy = case (get_const_info "T") of
Value _	=> "Symbol Table Already Present"
|Nil		=> load_symtab();

val dummy = case (get_type_info "î") of
Value _	=>	"Constant î is already present"
|Nil	=>
let	val dummy = new_type ("î", 0);
	val dummy = declare_infix (200, "î");
	val dummy = declare_terminator "î";
in
	"Constant î is now defined"
end;

val dummy = case (get_const_info ">") of
Value _	=>	"Constant > is already present"
|Nil	=>
let	val dummy = new_const (">", mk_­_type (î, mk_­_type (î, BOOL)));
	val dummy = map declare_infix [(60, ">"), (100, ",")];
	val dummy = declare_terminator ">";
in
	"Constant > is now defined"
end;

val dummy = case (get_type_info "¸") of
Value _	=>	"Constant ¸ is already present"
|Nil	=>
let	val dummy = new_type ("¸", 2);
	val dummy = declare_infix (200, "¸");
	val dummy = declare_terminator "¸";
in
	"Constant ¸ is now defined"
end;

val dummy = case (get_const_info ",") of
Value _	=>	"Constant , is already present"
|Nil	=>
let	val dummy = new_const (",", mk_­_type (mk_vartype "'a",
		mk_­_type (mk_vartype "'b",
		mk_ctype ("¸", [mk_vartype "'a", mk_vartype "'b"]))));
	val dummy = declare_infix (120, ",");
in
	"Constant , is now defined"
end;

val dummy = case (get_const_info "Uncurry") of
Value _	=>	"Constant Uncurry is already present"
|Nil	=>
let	val tya = mk_­_type (mk_vartype "'a",
		  mk_­_type (mk_vartype "'b", mk_vartype "'c"));
	val tyb = mk_­_type (mk_ctype ("¸",[mk_vartype "'a",
		mk_vartype "'b"]), mk_vartype "'c");
	val tyc = mk_­_type (tya, tyb);
	val dummy = new_const ("Uncurry", tyc);
in
	"Constant Uncurry is now defined"
end;

=TEX
The following function is used to find out the type of
a constant defined in the symbol table.
=SML
exception Type_of_c of string;
fun Ûtype_of_cÝ s = (
	case get_const_info s of
	Value (t, _) => t
	|	 Nil => raise Type_of_c s
);
=TEX
=SML
val m = make_term;
=TEX
First we define some Standard ML constants which will
be useful throughout the tests.
=SML
val fixity = Lex.Nonfix;

val Í = Id "Í" and
    T = Id "T" and
    F = Id "F" and
    ³ = Id "³" and
    eq = Id "=" and
    gt = Id ">" and
    lt = Id "<" and
    µ = Id "µ" and
    ¶ = Id "¶" and
    comma = Id ",";

val free_1 = Id "free_1" and
    free_2 = Id "free_2" and
    free_3 = Id "free_3" and
    free_4 = Id "free_4" and
    free_5 = Id "free_5" and
    free_6 = Id "free_6";

val typevar_a = TyAq (mk_vartype "'a") and
    typevar_b = TyAq (mk_vartype "'b") and
    typevar_c = TyAq (mk_vartype "'c");

val flag = TmTyped (Id "flag", TyAq BOOL);

val x = TmTyped (Id "x", TyAq î) and
    y = TmTyped (Id "y", TyAq î) and
    z = TmTyped (Id "z", TyAq î);

val n0 = NumLit 0 and
    n1 = NumLit 1 and
    n2 = NumLit 2;

val s0 = StringLit "0" and
    s1 = StringLit "1" and
    s2 = StringLit "2";

val c0 = CharLit "0" and
    c1 = CharLit "1" and
    c2 = CharLit "2";
=TEX

=SML
val o_flag = mk_var ("flag", BOOL);

val o_typevar_a = mk_vartype "'a" and
    o_typevar_b = mk_vartype "'b" and
    o_typevar_c = mk_vartype "'c";

val o_free_1a = mk_var("free_1", o_typevar_a) and
    o_free_1b = mk_var("free_1", o_typevar_b) and
    o_free_1c = mk_var("free_1", o_typevar_c) and
    o_free_2a = mk_var("free_2", o_typevar_a) and
    o_free_2b = mk_var("free_2", o_typevar_b) and
    o_free_2c = mk_var("free_2", o_typevar_c) and
    o_free_3a = mk_var("free_3", o_typevar_a) and
    o_free_3b = mk_var("free_3", o_typevar_b) and
    o_free_3c = mk_var("free_3", o_typevar_c) and
    o_free_1BOOL = mk_var("free_1", BOOL) and
    o_free_2BOOL = mk_var("free_2", BOOL) and
    o_free_3BOOL = mk_var("free_3", BOOL);

val o_x = mk_var ("x", î) and
    o_y = mk_var ("y", î) and
    o_z = mk_var ("z", î);


val o_Í = mk_const ("Í", mk_­_type (mk_­_type (o_typevar_a, BOOL), o_typevar_a)) and
    o_T = mk_const ("T", type_of_c "T") and
    o_F = mk_const ("F", type_of_c "F") and
    o_³ = mk_const ("³", type_of_c "³") and
    o_eq = mk_const ("=", mk_­_type (î, mk_­_type (î, BOOL))) and
    o_eqb = mk_const ("=", mk_­_type (BOOL, mk_­_type (BOOL, BOOL))) and
    o_gt = mk_const (">", mk_­_type (î, mk_­_type (î, BOOL))) and
    o_lt = mk_const ("<", mk_­_type (î, mk_­_type (î, BOOL))) and
    o_µ = mk_const ("µ", type_of_c "µ") and
    o_µn = mk_const ("µ", mk_­_type (mk_­_type (î, BOOL), BOOL)) and
    o_¶ = mk_const ("¶", mk_­_type (mk_­_type (î, BOOL), BOOL)) and
    o_comma = mk_const (",", mk_­_type (o_typevar_a, mk_­_type (o_typevar_b,
		mk_ctype ("¸", [o_typevar_a, o_typevar_b]))));
=TEX

\subsection{Identifiers}

We need to test that variables
translate to variables with a free type and that
constants (denoted by their presence in the symbol table)
translate to constants.

=SML
val i_id_1 = free_1;
val o_id_1 = o_free_1a;
val i_id_2 = T;
val o_id_2 = mk_const ("T", BOOL);

val dummy = store_mt_results mt_run [
("ti.id.1", m, i_id_1, o_id_1),
("ti.id.2", m, i_id_2, o_id_2)
];
=TEX

\subsection{Literals}

For literals, we need to check the translation of
each type of literal and that it is correctly typed.
(Note that some of the values defined will be used later).

=SML
val i_n0 = n0 and
    i_n1 = n1 and
    i_n2 = n2;
val i_s0 = s0 and
    i_s1 = s1 and
    i_s2 = s2;
val i_c0 = c0 and
    i_c1 = c1 and
    i_c2 = c2;

val o_n0 = mk_î 0 and
    o_n1 = mk_î 1 and
    o_n2 = mk_î 2;
val o_s0 = mk_string "0" and
    o_s1 = mk_string "1" and
    o_s2 = mk_string "2";
val o_c0 = mk_char "0" and
    o_c1 = mk_char "1" and
    o_c2 = mk_char "2";

val dummy = store_mt_results mt_run [
("ti.numlit", m, i_n0, o_n0),
("ti.stringlit", m, i_s0, o_s0),
("ti.charlit", m, i_c0, o_c0)
];
=TEX

\subsection{Types}

There are three value constructors which form types.
Each of these is tested in turn using the interface
$make\_type$. This interface is itself used by
the type inference mechanism.

\begin{description}

\item[Atomic Types]
Test that a type atom which begins with a ``\'\/''
translates to a corresponding $Vartype$, and that a
type atom which begins with any other character
translates to a corresponding $Type$ with an
empty parameter list.

\item[Antiquoted Types]
Test that an antiquoted type translated yields the
type which is antiquoted.

\item[Compound Types]
Test that a type compound translates correctly to
a $Type$. This needs to be tested when the type
has no parameters, one parameter and more than one
parameter.

\end{description}

=SML
val dummy = case (get_type_info "XXX") of
Value _	=>	"Type XXX is already present"
|Nil	=>
let	val dummy = new_type ("XXX", 0);
	val dummy = new_type("ZZZ", 0);
	val dummy = new_type("WWW", 1);
	val dummy = new_type("SSS", 3);
in
	"Types XXX, ZZZ, WWW and SSS are now defined"
end;

val i_tyatom_1 = TyAtom "XXX";
val o_tyatom_1 = mk_ctype ("XXX",[]);
val i_tyatom_2 = TyAtom "'YYY";
val o_tyatom_2 = mk_vartype "'YYY";
val i_tyaq_1 = TyAq (mk_ctype ("XXX",[]));
val o_tyaq_1 = mk_ctype ("XXX",[]);
val i_tyaq_2 = TyAq (mk_vartype "YYY");
val o_tyaq_2 = mk_vartype "YYY";
val i_tyaq_3 = TyAq (mk_vartype "'RRR");
val o_tyaq_3 = mk_vartype "'RRR";
val i_tycompound_1 = TyCompound ([],"ZZZ",fixity);
val o_tycompound_1 = mk_ctype ("ZZZ",[]);
val i_tycompound_2 = TyCompound ([i_tyatom_1],"WWW", fixity);
val o_tycompound_2 = mk_ctype ("WWW",[o_tyatom_1]);

val i_tycompound_3 = TyCompound ([i_tycompound_1,
	i_tycompound_2, i_tyatom_2],"SSS", fixity);
val o_tycompound_3 = mk_ctype ("SSS",[o_tycompound_1,
	o_tycompound_2, o_tyatom_2]);

val dummy = store_mt_results mt_run [
("make_type.tyatom_1", make_type, i_tyatom_1, o_tyatom_1),
("make_type.tyatom_2", make_type, i_tyatom_2, o_tyatom_2),
("make_type.tyaq_1", make_type, i_tyaq_1, o_tyaq_1),
("make_type.tyaq_2", make_type, i_tyaq_2, o_tyaq_2),
("make_type.tyaq_3", make_type, i_tyaq_3, o_tyaq_3),
("make_type.tycompound_1",make_type, i_tycompound_1, o_tycompound_1),
("make_type.tycompound_2",make_type, i_tycompound_2, o_tycompound_2),
("make_type.tycompound_3",make_type, i_tycompound_3, o_tycompound_3)
];
=TEX

\subsection{Binding Types to Identifiers and Literals}

We need to test that a free variable which
is typed is correctly typed when type-inferred. A typed
constant when explicitly typed should yield a constant of
the correct type. A typed constant which is explicitly typed
with a different type should yeild a type checking error.

=SML

val i_tmtyped_1 = TmTyped (free_1, TyAq î);
val o_tmtyped_1 = mk_var ("free_1", î);
val i_tmtyped_2 = TmTyped (T, TyAq BOOL);
val o_tmtyped_2 = mk_const ("T", BOOL);
val i_tmtyped_3 = TmTyped (c0, TyAq CHAR);
val o_tmtyped_3 = mk_char "0";
val i_tmtyped_4 = TmTyped (c0, TyAtom "CHAR");
val o_tmtyped_4 = mk_char "0";

val i_tmtyped_1f = TmTyped (c0, TyAq STRING);
val i_tmtyped_2f = TmTyped (T, TyAq î);

val dummy = store_mt_results mt_run [
("ti.tmtyped_1", m, i_tmtyped_1, o_tmtyped_1),
("ti.tmtyped_2", m, i_tmtyped_2, o_tmtyped_2),
("ti.tmtyped_3", m, i_tmtyped_3, o_tmtyped_3),
("ti.tmtyped_4", m, i_tmtyped_4, o_tmtyped_4)
];

val dummy = store_mt_results mt_run_fail1 [
("ti.tmtyped_1f", m, i_tmtyped_1f),
("ti.tmtyped_2f", m, i_tmtyped_2f)
];
=TEX

\subsection{Antiquoted Terms}

The following cases should be tested:

\begin{enumerate}

\item
antiquotation of a typed variable

\item
antiquotation of a constant

\item
antiquotation of a free variable

\item
that the type of an antiquotation of a free variable is
that which is expected

\item
that the type of an antiquotation of a typed variable is
that which is expected

\end{enumerate}

We also need to check that constants with non-function types applied to anything
causes a type checking error.



=SML
val i_tmaq_1 = TmAq o_x;
val o_tmaq_1 = o_x;
val i_tmaq_2 = TmAq o_T;
val o_tmaq_2 = o_T;
val i_tmaq_3 = TmAq o_free_1a;
val o_tmaq_3 = o_free_1a;
val i_tmaq_4 = TmTyped (TmAq (o_free_1a), typevar_a);
val o_tmaq_4 = o_free_1a;
val i_tmaq_5 = TmTyped (TmAq (o_n0), TyAq î);
val o_tmaq_5 = o_n0;

val dummy = store_mt_results mt_run [
("ti.tmaq_1", m, i_tmaq_1, o_tmaq_1),
("ti.tmaq_2", m, i_tmaq_2, o_tmaq_2),
("ti.tmaq_3", m, i_tmaq_3, o_tmaq_3),
("ti.tmaq_4", m, i_tmaq_4, o_tmaq_4),
("ti.tmaq_5", m, i_tmaq_5, o_tmaq_5)
];

=TEX
\subsection{Variable Structures}

We need to test that the type inference mechanism recognises
variable structures. These tests test the function
$is_varstruct$. The following cases should be tested:

\begin{enumerate}

\item
that a free variable is a valid varstruct

\item
that a typed free variable is a valid varstruct

\item
that a pair of free variables is a valid varstruct

\item
that a typed pair of free variables is a valid varstruct

\item
that a typed pair of typed variables is a valid varstruct

\item
that a constant is not a valid varstruct

\item
that a conditional clause is not a valid varstruct

\item
that a function application (other that the pair constructor)
is not a valid varstruct

\item
that a set display is not a valid varstruct

\item
that a list display is not a valid varstruct

\item
that a set comprehension is not a valid varstruct

\item
that a numeric literal is not a valid varstruct 

\item
that a string literal is not a valid varstruct 

\item
that a character literal is not a valid varstruct 

\item
that an antiquoted term is not a valid varstruct 

\item
that a binder clause is not a valid varstruct 

\item
that a let clause is not a valid varstruct 

\end{enumerate}

=SML
val i_varstruct_1 = free_1;
val i_varstruct_2 = x;
val i_varstruct_3 = App (App (comma, free_1, fixity), free_2, fixity);
val i_varstruct_4 = TmTyped (App (App (comma, free_1, fixity), free_2, fixity),
	TyAq (mk_ctype ("¸", [o_typevar_a, o_typevar_b])));
val i_varstruct_5 = TmTyped (App (App (comma, x, fixity), y, fixity),
	TyAq (mk_ctype ("¸", [î, î])));
val i_varstruct_6 = T;
val i_varstruct_7 = Cond (T, T, F);
val i_varstruct_8 = App (³, T, fixity);
val i_varstruct_9 = SetDisplay [T,T];
val i_varstruct_10 = ListDisplay [T,T];
val i_varstruct_11 = SetComprehension (x, T);
val i_varstruct_12 = n0;
val i_varstruct_13 = s0;
val i_varstruct_14 = c0;
val i_varstruct_15 = TmAq o_x;
val i_varstruct_16 = Binder ("µ", x, T);
val i_varstruct_17 = Let ([], T);

val dummy = store_mt_results mt_run [
("varstruct_1", is_varstruct, i_varstruct_1, true),
("varstruct_2", is_varstruct, i_varstruct_2, true),
("varstruct_3", is_varstruct, i_varstruct_3, true),
("varstruct_4", is_varstruct, i_varstruct_4, true),
("varstruct_5", is_varstruct, i_varstruct_5, true),
("varstruct_6", is_varstruct, i_varstruct_6, false),
("varstruct_7", is_varstruct, i_varstruct_7, false),
("varstruct_8", is_varstruct, i_varstruct_8, false),
("varstruct_9", is_varstruct, i_varstruct_9, false),
("varstruct_10", is_varstruct, i_varstruct_10, false),
("varstruct_11", is_varstruct, i_varstruct_11, false),
("varstruct_12", is_varstruct, i_varstruct_12, false),
("varstruct_13", is_varstruct, i_varstruct_13, false),
("varstruct_14", is_varstruct, i_varstruct_14, false),
("varstruct_15", is_varstruct, i_varstruct_15, false),
("varstruct_16", is_varstruct, i_varstruct_16, false),
("varstruct_17", is_varstruct, i_varstruct_17, false)
];
=TEX

\subsection{Binder Construction with lambda}

The following cases should be tested for the construct
$ Ì x · p$.

\begin{enumerate}

\item
when x and p are both free variables

\item
when x is a free variable and p is a boolean variable

\item
when x is a free variable and p is a boolean constant

\item
when x is a typed variable and p is a boolean constant

\item
when x is a typed variable and p is a boolean expression
containing x.

\item
that the type of the resulting expression matches a set of type
x.

\item
when x is a pair and p is a boolean constant.

\end{enumerate}

We should also check
that a type checking error is raised when
x is not a well formed variable.

=SML
val i_binderÌ_1 = Binder ("Ì", free_1, free_2);
val o_binderÌ_1 = mk_Ì (o_free_1a, o_free_2b);
val i_binderÌ_2 = Binder ("Ì", free_1, flag);
val o_binderÌ_2 = mk_Ì (o_free_1a, o_flag);
val i_binderÌ_3 = Binder ("Ì", free_1, T);
val o_binderÌ_3 = mk_Ì (o_free_1a, o_T);
val i_binderÌ_4 = Binder ("Ì", x, T);
val o_binderÌ_4 = mk_Ì (o_x, o_T);

val i_binderÌ_5 = Binder ("Ì", x, App (App (gt, x, fixity), y, fixity));
val o_binderÌ_5 = mk_Ì (o_x, mk_app (mk_app (o_gt, o_x), o_y));
val i_binderÌ_6 =TmTyped (Binder ("Ì", x, T),
	TyAq (mk_­_type (î, BOOL)));
val o_binderÌ_6 = mk_Ì (o_x, o_T);
val i_binderÌ_7 =Binder ("Ì", i_varstruct_5, T);
local
	val o_varstruct_5 = make_term i_varstruct_5
in
	val o_binderÌ_7 = mk_Ì (o_varstruct_5, o_T)
end;

val i_binderÌ_1f = Binder ("Ì", T, T);
val i_binderÌ_2f = Binder ("Ì", i_varstruct_10, T);

val dummy = store_mt_results mt_run [
("ti.binderÌ_1", m, i_binderÌ_1, o_binderÌ_1),
("ti.binderÌ_2", m, i_binderÌ_2, o_binderÌ_2),
("ti.binderÌ_3", m, i_binderÌ_3, o_binderÌ_3),
("ti.binderÌ_4", m, i_binderÌ_4, o_binderÌ_4),
("ti.binderÌ_5", m, i_binderÌ_5, o_binderÌ_5),
("ti.binderÌ_6", m, i_binderÌ_6, o_binderÌ_6),
("ti.binderÌ_7", m, i_binderÌ_7, o_binderÌ_7)
];

val dummy = store_mt_results mt_run_fail1 [
("ti.binderÌ_1f", m, i_binderÌ_1f),
("ti.binderÌ_2f", m, i_binderÌ_2f)
];
=TEX

\subsection{Other Binder Constructions}

The following cases should be tested for the construct
$bnd\ x · p$.

\begin{enumerate}

\item
when bnd is a constant, x and p are free variables

\item
when bnd is a constant, x and p are typed variables

\item
when bnd is a constant, x is a typed variable and
p is a constant

\item
when bnd is not a constant, x is a variable
and p is a constant

\end{enumerate}

We should also check
that a type checking error is raised when
x is not a well formed variable.


=SML
val i_binder_1 = Binder ("µ", free_1, free_2);
val o_binder_1 = mk_app (o_µ, mk_Ì (o_free_1a, mk_var ("free_2", BOOL)));
val i_binder_2 = Binder ("µ", x, flag);
val o_binder_2 = mk_app (o_µn, mk_Ì (o_x, o_flag));
val i_binder_3 = Binder ("µ", x, T);
val o_binder_3 = mk_app (o_µn, mk_Ì (o_x, o_T));
val i_binder_4 = Binder ("Aardvark", free_1, T);
val o_binder_4 = mk_app (mk_var("Aardvark",mk_­_type (mk_­_type (o_typevar_b, BOOL),
	o_typevar_a)), mk_Ì (o_free_1b, o_T));

val i_binder_1f = Binder ("µ", T, T);
val i_binder_2f = Binder ("¶", i_varstruct_10, T);

val dummy = store_mt_results mt_run [
("ti.binder_1", m, i_binder_1, o_binder_1),
("ti.binder_2", m, i_binder_2, o_binder_2),
("ti.binder_3", m, i_binder_3, o_binder_3),
("ti.binder_4", m, i_binder_4, o_binder_4)
];

val dummy = store_mt_results mt_run_fail1 [
("ti.binder_1f", m, i_binder_1f),
("ti.binder_2f", m, i_binder_2f)
];
=TEX

\subsection{Let Statements}

The following cases should be tested for clauses of the form:
$Let\ ([\ ],\ p)$;

\begin{enumerate}

\item
when p is a free variable

\item
when p is a typed variable

\item
when p is a constant

\item
that the clause has the same type as the type of p

\end{enumerate}

The following cases should be tested for clauses of the form:
$Let\ ([(x, y)],\ p)$;

\begin{enumerate}

\item
when p is a constant, and y is a free variable

\item
when p is the variable x, and y is a constant

\item
that when p is an expression containing and denoting the
type of x, and y is a free variable, that the type of y
is correctly type-inferred

\end{enumerate}

We also need to check that
when x is not a varstruct then an type checking error
occurs.

Finally we need to check that a clause of the form
$Let\ ([(x1,\ y1),\ (x2,\ y2)]),\ p$ to check that
the types of y1 can be inferred from y2 and vice-versa.

=SML
val i_let_empty_1 = Let ([], free_1);
val o_let_empty_1 = mk_let ([],o_free_1a);
val i_let_empty_2 = Let ([], x);
val o_let_empty_2 = mk_let ([],o_x);
val i_let_empty_3 = Let ([], T);
val o_let_empty_3 = mk_let ([], o_T);
val i_let_empty_4 = TmTyped (Let ([], T), TyAq BOOL);
val o_let_empty_4 = mk_let ([], o_T);

val i_let_one_1 = Let ([(free_1, free_2)], T);
val o_let_one_1 = mk_let ([(o_free_1a, o_free_2a)], o_T);
val i_let_one_2 = Let ([(free_1, T)], free_1);
val o_let_one_2 = mk_let ([(o_free_1BOOL, o_T)], o_free_1BOOL);
val i_let_one_3 = Let ([(free_1, free_2)], App (³, free_1, fixity));
val o_let_one_3 = mk_let ([(o_free_1BOOL, o_free_2BOOL)], mk_app (o_³, o_free_1BOOL));
val i_let_two_1 = Let ([(free_1, free_2), (free_3, T)],
	App (App (eq, free_1, fixity), flag, fixity));
val o_let_two_1 = mk_let ([(o_free_1BOOL, o_free_2BOOL),
	(o_free_3BOOL, o_T)], mk_app (mk_app (o_eqb, o_free_1BOOL), o_flag));
val i_let_two_2 = Let ([(free_3, T), (free_1, free_2)],
	App (App (eq, free_1, fixity), flag, fixity));
val o_let_two_2 = mk_let ([(o_free_3BOOL, o_T), (o_free_1BOOL, o_free_2BOOL)],
	mk_app (mk_app (o_eqb, o_free_1BOOL), o_flag));

val i_let_one_1f = Let ([(i_varstruct_10, free_1)], free_2);

val dummy = store_mt_results mt_run [
("ti.let_empty_1", m, i_let_empty_1, o_let_empty_1),
("ti.let_empty_2", m, i_let_empty_2, o_let_empty_2),
("ti.let_empty_3", m, i_let_empty_3, o_let_empty_3),
("ti.let_one_1", m, i_let_one_1, o_let_one_1),
("ti.let_one_2", m, i_let_one_2, o_let_one_2),
("ti.let_one_3", m, i_let_one_3, o_let_one_3),
("ti.let_two_1", m, i_let_two_1, o_let_two_1),
("ti.let_two_2", m, i_let_two_2, o_let_two_2)
];

val dummy = store_mt_results mt_run_fail1 [
("ti.let_1f", m, i_let_one_1f)
];
=TEX

\subsection{Function Application}

The following cases should be tested:

\begin{enumerate}

\item
The application of a free variable to a free variable

\item
The application of a free variable to a constant

\item
The application of a constant to a free variable

\item
The application of a constant to a constant

\item
That the type resulting from an application of a function
is that which is expected

\end{enumerate}

We also need to check
that constants with non-function types applied to anything
causes a type checking error.

=SML
val i_app_1 = App (free_1, free_2, fixity);
val o_app_1 = mk_app (mk_var ("free_1", mk_­_type(mk_vartype "'b", mk_vartype "'a")),
	o_free_2b);
val i_app_2 = App (free_1, T, fixity);
val o_app_2 = mk_app (mk_var ("free_1", mk_­_type(BOOL, mk_vartype "'a")), o_T);
val i_app_3 = App (³, free_1, fixity);
val o_app_3 = mk_app (o_³, o_free_1BOOL);
val i_app_4 = App (³, T, fixity);
val o_app_4 = mk_app (o_³, o_T);
val i_app_5 = TmTyped (App (Id "³", flag, fixity), TyAq BOOL);
val o_app_5 = mk_app (o_³, o_flag);

val i_app_1f = App (T, T, fixity);
val i_app_2f = App (T, x, fixity);
val i_app_3f = App (Id ">", T, fixity);

val dummy = store_mt_results mt_run [
("ti.app_1", m, i_app_1, o_app_1),
("ti.app_2", m, i_app_2, o_app_2),
("ti.app_3", m, i_app_3, o_app_3),
("ti.app_4", m, i_app_4, o_app_4),
("ti.app_5", m, i_app_4, o_app_4)
];

val dummy = store_mt_results mt_run_fail1 [
("ti.app_1f", m, i_app_1f),
("ti.app_2f", m, i_app_2f),
("ti.app_3f", m, i_app_3f)
];
=TEX

\subsection{Conditional Statements}

The following cases should be tested for $Cond\ (c,\ a,\ b)$:

\begin{enumerate}

\item
when c, a and b are all free variables

\item
when c is a boolean constant and a and b are free variables

\item
when c is a free variable, and a and b are constants

\item
when c is a free variable and a and b are typed variables

\item
when c, a and b are all typed variables

\item
when c, a and b are all constants

\item
that the types of a are correctly inferred from b when c is a typed variable

\item
that the types of b are correctly inferred from a when c is a typed variable

\item
that the type of the expression matches the type of a
and b

\end{enumerate}

We also need to check the following:

\begin{enumerate}

\item
when c is not of type BOOL, that a type checking error occurs

\item
when a and b are not of the same type that a type checking
error occurs

\end{enumerate}

=SML
val i_cond_1 = Cond (free_1, free_2, free_3);
val o_cond_1 = mk_if (o_free_1BOOL, o_free_2a, o_free_3a);
val i_cond_2 = Cond (T, free_2, free_3);
val o_cond_2 = mk_if (o_T, o_free_2a, o_free_3a);
val i_cond_3 = Cond (free_1, Í, Í);
val o_cond_3 = mk_if (o_free_1BOOL, o_Í, o_Í);
val i_cond_4 = Cond (free_1, x, y);
val o_cond_4 = mk_if (o_free_1BOOL, o_x, o_y);
val i_cond_5 = Cond (flag, x, y);
val o_cond_5 = mk_if (o_flag, o_x, o_y);
val i_cond_6 = Cond (T, T, F);
val o_cond_6 = mk_if (o_T, o_T, o_F);
val i_cond_7 = Cond (T, free_1, i_app_5);
val o_cond_7 = mk_if (o_T, o_free_1BOOL, o_app_5);
val i_cond_8 = Cond (T, i_app_5, free_1);
val o_cond_8 = mk_if (o_T, o_app_5, o_free_1BOOL);
val i_cond_9 = TmTyped (Cond (T, T, F), TyAq BOOL);
val o_cond_9 = mk_if (o_T, o_T, o_F);

val i_cond_1f = Cond (NumLit 0, T, T);
val i_cond_2f = Cond (T, NumLit 0, F);
val i_cond_3f = Cond (T, T, NumLit 0);

val dummy = store_mt_results mt_run [
("ti.cond_1", m, i_cond_1, o_cond_1),
("ti.cond_2", m, i_cond_2, o_cond_2),
("ti.cond_3", m, i_cond_3, o_cond_3),
("ti.cond_4", m, i_cond_4, o_cond_4),
("ti.cond_5", m, i_cond_5, o_cond_5),
("ti.cond_6", m, i_cond_6, o_cond_6),
("ti.cond_7", m, i_cond_7, o_cond_7),
("ti.cond_8", m, i_cond_8, o_cond_8),
("ti.cond_9", m, i_cond_9, o_cond_9)
];

val dummy = store_mt_results mt_run_fail1 [
("ti.cond_1f", m, i_cond_1f),
("ti.cond_2f", m, i_cond_2f),
("ti.cond_3f", m, i_cond_3f)
];
=TEX

\subsection{Sets}

The following cases should be tested:

\begin{enumerate}

\item
an empty set of an unknown type

\item
an empty set of a fixed type

\item
a set with one element

\item
a set with more than one element

\item
that a set containing elements of a particular type has
the correct overall type

\item
that in a set containing variables of known types and a free
variable that the free
variable is correctly type-inferred

\end{enumerate}

We also need to check
that a set containing elements of different types causes a
type checking error.

=SML
val i_setdisplay_1 = SetDisplay [];
val o_setdisplay_1 = mk_š (o_typevar_a);
val i_setdisplay_2 = TmTyped (SetDisplay [], TyAq (mk_ctype ("SET", [BOOL])));
val o_setdisplay_2 = mk_š (BOOL);
val i_setdisplay_3 = SetDisplay [x];
val o_setdisplay_3 = mk_enum_set [o_x];
val i_setdisplay_4 = SetDisplay [x,y,z];
val o_setdisplay_4 = mk_enum_set [o_x, o_y, o_z];
val i_setdisplay_5 = TmTyped (SetDisplay [T],
	TyAq (mk_ctype ("SET", [BOOL])));
val o_setdisplay_5 = mk_enum_set [o_T];
val i_setdisplay_6 = SetDisplay [T, F, free_1];
val o_setdisplay_6 = mk_enum_set [o_T, o_F, o_free_1BOOL];

val i_setdisplay_1f = SetDisplay [T, n0];
val i_setdisplay_2f = SetDisplay [T, F, T, n0];

val dummy = store_mt_results mt_run [
("ti.setdisplay_1", m, i_setdisplay_1, o_setdisplay_1),
("ti.setdisplay_2", m, i_setdisplay_2, o_setdisplay_2),
("ti.setdisplay_3", m, i_setdisplay_3, o_setdisplay_3),
("ti.setdisplay_4", m, i_setdisplay_4, o_setdisplay_4),
("ti.setdisplay_5", m, i_setdisplay_5, o_setdisplay_5),
("ti.setdisplay_6", m, i_setdisplay_6, o_setdisplay_6)
];

val dummy = store_mt_results mt_run_fail1 [
("ti.setdisplay_1f", m, i_setdisplay_1f),
("ti.setdisplay_2f", m, i_setdisplay_2f)
];
=TEX


\subsection{Set Comprehension}

The following cases should be tested for terms of the
form $\{x\ |\ p\}$:

\begin{enumerate}

\item
when x and p are both free variables

\item
when x is a free variable and p is a boolean variable

\item
when x is a free variable and p is a boolean constant

\item
when x is a typed variable and p is a boolean constant

\item
when x is a typed variable and p is a boolean expression
containing x

\item
that the type of the resulting expression matches a set of type
x

\item
when x is a pair and p is a boolean constant

\end{enumerate}

We also need to check
that a type checking error is raised when either p is not
boolean or x is not a well formed variable.

=SML
val i_setcomp_1 = SetComprehension (free_1, free_2);
val o_setcomp_1 = mk_set_comp (o_free_1a, o_free_2BOOL);
val i_setcomp_2 = SetComprehension (free_1, flag);
val o_setcomp_2 = mk_set_comp (o_free_1a, o_flag);
val i_setcomp_3 = SetComprehension (free_1, T);
val o_setcomp_3 = mk_set_comp (o_free_1a, o_T);
val i_setcomp_4 = SetComprehension (x, T);
val o_setcomp_4 = mk_set_comp (o_x, o_T);

val i_setcomp_5 = SetComprehension (x, App (App (gt, x, fixity), y, fixity));
val o_setcomp_5 = mk_set_comp (o_x, mk_app (mk_app (o_gt, o_x), o_y));
val i_setcomp_6 =TmTyped (SetComprehension (x, T),
	TyAq (mk_ctype ("SET", [î])));
val o_setcomp_6 = mk_set_comp (o_x, o_T);
val i_setcomp_7 =SetComprehension (i_varstruct_5, T);
local
	val o_varstruct_5 = make_term i_varstruct_5
in
	val o_setcomp_7 = mk_set_comp (o_varstruct_5, o_T)
end;

val i_setcomp_1f = SetComprehension (x, n0);
val i_setcomp_2f = SetComprehension (T, T);
val i_setcomp_3f = SetComprehension (i_varstruct_10, T);

val dummy = store_mt_results mt_run [
("ti.setcomp_1", m, i_setcomp_1, o_setcomp_1),
("ti.setcomp_2", m, i_setcomp_2, o_setcomp_2),
("ti.setcomp_3", m, i_setcomp_3, o_setcomp_3),
("ti.setcomp_4", m, i_setcomp_4, o_setcomp_4),
("ti.setcomp_5", m, i_setcomp_5, o_setcomp_5),
("ti.setcomp_6", m, i_setcomp_6, o_setcomp_6),
("ti.setcomp_7", m, i_setcomp_7, o_setcomp_7)
];

val dummy = store_mt_results mt_run_fail1 [
("ti.setcomp_1f", m, i_setcomp_1f),
("ti.setcomp_2f", m, i_setcomp_2f),
("ti.setcomp_3f", m, i_setcomp_3f)
];
=TEX

\subsection{Lists}

The following cases should be tested:

\begin{enumerate}

\item
an empty list of an unknown type

\item
an empty list of a fixed type

\item
a list with one element

\item
a list with more than one element

\item
that a list containing elements of a particular type has
the correct overall type

\item
that in a set containing variables of known types and a free
variable that the free
variable is correctly type-inferred

\end{enumerate}

We also need to check
that a list containing elements of different types causes a
type checking error.

=SML
val i_listdisplay_1 = ListDisplay [];
val o_listdisplay_1 = mk_empty_list (o_typevar_a);
val i_listdisplay_2 = TmTyped (ListDisplay [], TyAq (mk_ctype ("LIST", [BOOL])));
val o_listdisplay_2 = mk_empty_list (BOOL);
val i_listdisplay_3 = ListDisplay [x];
val o_listdisplay_3 = mk_list [o_x];
val i_listdisplay_4 = ListDisplay [x,y,z];
val o_listdisplay_4 = mk_list [o_x, o_y, o_z];
val i_listdisplay_5 = TmTyped (ListDisplay [T],
	TyAq (mk_ctype ("LIST", [BOOL])));
val o_listdisplay_5 = mk_list [o_T];
val i_listdisplay_6 = ListDisplay [T, F, free_1];
val o_listdisplay_6 = mk_list [o_T, o_F, o_free_1BOOL];

val i_listdisplay_1f = ListDisplay [T, n0];
val i_listdisplay_2f = ListDisplay [T, F, T, n0];

val dummy = store_mt_results mt_run [
("ti.listdisplay_1", m, i_listdisplay_1, o_listdisplay_1),
("ti.listdisplay_2", m, i_listdisplay_2, o_listdisplay_2),
("ti.listdisplay_3", m, i_listdisplay_3, o_listdisplay_3),
("ti.listdisplay_4", m, i_listdisplay_4, o_listdisplay_4),
("ti.listdisplay_5", m, i_listdisplay_5, o_listdisplay_5),
("ti.listdisplay_6", m, i_listdisplay_6, o_listdisplay_6)
];

val dummy = store_mt_results mt_run_fail1 [
("ti.listdisplay_1f", m, i_listdisplay_1f),
("ti.listdisplay_2f", m, i_listdisplay_2f)
];
=TEX

\subsection{Miscellaneous Tests}

These tests comprise a miscellaneous collection of terms
which have been known to cause the type inferrer (unification)
to fail in past instances of the implementation.
=SML
val dummy = store_mt_results mt_run [
("ti.misc_1", type_of, ¬Uncurry f = Ì x · f (Fst x) (Snd x)®, ¬:BOOL®)
];
=IGN
The following terms should fail on the occurs check. It
has been the case that type inference on these terms has not
terminated. The problem has been corrected. (Try them).
¬Uncurry f = Ì y · f y y®;
¬Uncurry f = Ì y · f y®;
=SML
in
	val dummy = diag_string(summarize_mt_results())
end;

=TEX




%\newpage
%\twocolumn[\section{INDEX OF DEFINED TERMS}]
%\printindex
\end{document}


