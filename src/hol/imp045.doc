%  $Id$ %Z%
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the General Purpose Theories}  %% Mandatory field
\def\TPPheadtitle{Implementation for the General Purpose Theories}
\TPPref{DS/FMU/IED/IMP045}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document creates the theories
``one'', ``combin'' and ``sum''.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Taken $ext\_thm$ from elsewhere, and used $ante\_tac$.
\item [Issue 1.3]
Made ``set'' the parent.
\item [Issue 1.4]
Made ``sets'' the parent.
\item [Issue 1.5]
Changes after comments.
Renamed constants $S$, $K$ and $I$ to $CombS$, $CombK$ and $CombI$.
\item [Issue 1.6]
Changed precedence of ``+''.

\item[Issue 1.7, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.8 (23rd January 1992)]
$new\_axiom$, $simple\_new\_type\_defn$ and $new\_type\_defn$
all changed to take lists of keys, rather than single ones.
\item[Issue 1.9 (27th January 1992)]
Corrected a typo.
\end{description}
% \subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the general purpose theories.
This is called for in \cite{DS/FMU/IED/HLD011}.
The design is in \cite{DS/FMU/IED/DTD045}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the 
general purpose theories.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD045},
and also requires the theory ``sets'' defined in
\cite{DS/FMU/IED/DTD044}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{THE THEORY ``one''}
=SML
structure ÛOneTheoryÝ : OneTheory = struct
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",true);
val _ = open_theory "sets";
val _ = new_theory "one";
=TEX
=SML
val Ûis_one_rep_defÝ = new_specification(["IsOneRep","is_one_rep_def"],1, (
push_goal([],¬¶ IsOneRep:BOOL ­ BOOL ·
	¶ one : BOOL · 
	µ x: BOOL· IsOneRep x ¤ (x ¤ one)®);
a(simple_¶_tac¬Ì x · x = T® THEN 
 simple_¶_tac¬T® THEN
 rewrite_tac[]);
pop_thm()));
=TEX
=SML
val Ûone_def1Ý = new_type_defn(["ONE","one_def1"],"ONE",[],(
push_goal([],¬¶ x: BOOL · IsOneRep x®);
a(strip_asm_tac (get_defn "-" "IsOneRep"));
a(simple_¶_tac ¬one:BOOL® THEN
  asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val Ûone_defÝ = new_specification(["One","one_def"],1,(
push_goal([],¬¶ One : ONE · µ x: ONE· x = One®);
a (strip_asm_tac (simple_´_match_mp_rule type_lemmas_thm
	(get_defn "-" "ONE")));
a(strip_asm_tac (get_defn "-" "IsOneRep"));
a(simple_¶_tac ¬abs (one:BOOL):ONE®);
a simple_µ_tac;
a(GET_NTH_ASM_T 2 (fn th1 => DROP_NTH_ASM_T 1 (fn th2
	=> ante_tac (rewrite_rule [th1] th2))));
a(´_T (ante_tac o simple_µ_elim ¬rep (x:ONE):BOOL®));
a(asm_rewrite_tac[]);
a(´_T (fn x=> asm_rewrite_tac[eq_sym_rule x]));
pop_thm()));
=TEX
=SML
val Ûone_fns_thmÝ = save_thm("one_fns_thm",(
push_goal([],¬µ f: 'a ­ ONE · f = Ì x · One®);
a(rewrite_tac[ext_thm,one_def]);
pop_thm()));
=TEX
=SML
val _ = new_const("Arbitrary",¬:'a®);
=TEX
\subsection{End of Theory ``one''}
=SML
val lsubgoal_package_quiet 
	= set_flag("subgoal_package_quiet",lsubgoal_package_quiet);
end; (* of structure OneTheory *)
open OneTheory;
=TEX
\section{THE THEORY ``combin''}
=SML
structure ÛCombinTheoryÝ : CombinTheory = struct
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",true);
val _ = new_theory "combin";
=TEX
=SML
val _ = declare_infix (300, "o");
val Ûo_defÝ = new_specification(["o","o_def"],1,(
push_goal([],¬¶ $o · µ (f:'b ­ 'c) (g:'a ­ 'b) (x: 'a) ·
	(f o g) x = f(g x)®);
a(simple_¶_tac ¬Ì (f:'b ­ 'c) (g:'a ­ 'b) (x: 'a) · f(g x)® THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val Ûcomb_s_defÝ = new_specification(["CombS","comb_s_def"],1,(
push_goal([],¬¶ CombS · µ (f:'a ­ 'b ­ 'c) (g:'a ­ 'b) (x:'a) ·
	CombS f g x = f x (g x)®);
a(simple_¶_tac ¬Ì (f:'a ­ 'b ­ 'c) (g:'a ­ 'b) (x:'a) ·
	f x (g x)® THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val Ûcomb_k_defÝ = new_specification(["CombK","comb_k_def"],1,(
push_goal([],¬¶ CombK · µ (x : 'a) (y : 'b) · CombK x y = x®);
a(simple_¶_tac ¬Ì (x : 'a) (y : 'b) · x® THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val Ûcomb_i_defÝ = new_specification(["CombI","comb_i_def"],1,(
push_goal([],¬¶ CombI · µ (x : 'a) · CombI x = x®);
a(simple_¶_tac ¬Ì (x : 'a) · x® THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val Ûs_k_thmÝ = save_thm ("s_k_thm", (
push_goal([],¬µ x · (CombS:('a ­ 'b ­ 'a) ­ ('a ­ 'b) ­ 'a ­ 'a) CombK x = CombI®);
a(simple_µ_tac THEN rewrite_tac[ext_thm, comb_s_def, comb_k_def, comb_i_def]);
pop_thm()));
=TEX
=SML
val Ûo_assoc_thmÝ = save_thm ("o_assoc_thm",(
push_goal([],¬µ (f:'a ­ 'b) (g:'c ­ 'a) (h :'d ­ 'c)· 
	f o (g o h) = (f o g) o h®);
a(REPEAT simple_µ_tac THEN rewrite_tac[ext_thm,o_def]);
pop_thm()));
=TEX
=SML
val Ûo_i_thmÝ = save_thm ("o_i_thm",(
push_goal([],¬µ f : 'a ­ 'b·
	((CombI o f) = f) ± ((f o CombI) = f)®);
a(REPEAT simple_µ_tac THEN rewrite_tac[ext_thm,o_def, comb_i_def]);
pop_thm()));
=TEX
\subsection{End of Theory ``combin''}
=SML
val lsubgoal_package_quiet 
	= set_flag("subgoal_package_quiet",lsubgoal_package_quiet);
end; (* of struct CombinTheory *)
open CombinTheory;
=TEX
\section{THE THEORY ``sum''}
=SML
structure ÛSumTheoryÝ : SumTheory = struct
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",true);
val _ = new_theory "sum";
=TEX
=SML
val Ûis_sum_rep_defÝ = new_specification(["IsSumRep","is_sum_rep_def"],1,(
push_goal([],¬¶ IsSumRep · 
¶ (inl:'a ­  'a ¸ 'b ¸ BOOL) (inr:'b ­  'a ¸ 'b ¸ BOOL)
  (outl:'a ¸ 'b ¸ BOOL ­ 'a) (outr:'a ¸ 'b ¸ BOOL ­ 'b)
  (isl:'a ¸ 'b ¸ BOOL ­ BOOL) (isr:'a ¸ 'b ¸ BOOL ­ BOOL) ·
µ (x1:'a) (x2:'a) (y1:'b) (y2:'b) (z: 'a ¸ 'b ¸ BOOL) ·
	IsSumRep(inl x1) ±
	IsSumRep(inr y1) ±
	(IsSumRep z ´ (inl(outl z) = z ² inr(outr z) = z)) ±
	(inl x1 = inl x2 ¤ x1 = x2) ±
	(inr y1 = inr y2 ¤ y1 = y2) ±
	³(inl x1 = inr y1) ±
	³(inr y1 = inl x1) ±
	outl(inl x1) = x1 ±
	outr(inr y1) = y1 ±
	(IsSumRep z ´ (isl z ¤ inl(outl z) = z)) ±
	(IsSumRep z ´ (isr z ¤ inr(outr z) = z))
	®);
a(MAP_EVERY simple_¶_tac [
	¬Ì ((a:'a), (b:'b), c) · 
	 if c then (b = Arbitrary) else (a = Arbitrary)®,
	¬Ì a:'a· (a, Arbitrary, T)®,
	¬Ì b:'b· (Arbitrary, b, F)®,
	¬Ì ((a:'a), (b:'b), (c:BOOL)) · a®,
	¬Ì ((a:'a), (b:'b), (c:BOOL)) · b®,
	¬Ì ((a:'a), (b:'b), (c:BOOL)) · c®,
	¬Ì ((a:'a), (b:'b), c) · ³ c®]
	THEN rewrite_tac[pair_clauses]);
a(REPEAT strip_tac THEN (asm_rewrite_tac[pair_clauses] ORELSE_T id_tac));
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[pair_clauses]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[pair_clauses]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[pair_clauses]);
pop_thm()));
=TEX
=SML
val _ = declare_infix (300,"+");
val Ûsum_defÝ = new_type_defn(["+","sum_def"],"+",["'a","'b"],(
push_goal([],¬¶ x: 'a ¸ 'b ¸ BOOL · IsSumRep x®);
a(strip_asm_tac (get_defn "-" "IsSumRep"));
a(simple_¶_tac¬inl (x:'a):'a ¸ 'b ¸ BOOL®);
a(asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val Ûsum_clausesÝ = new_specification(["InL", "InR", "OutL", "OutR", "IsL", "IsR","sum_clauses"],6,(
push_goal([],¬
¶ InL InR OutL OutR IsL IsR ·
µ (x1:'a) (x2:'a) (y1:'b) (y2:'b) (z: 'a + 'b) ·
	(InL(OutL z) = z ² InR(OutR z) = z) ±
	((InL x1 : 'a + 'b) = InL x2 ¤ x1 = x2) ±
	((InR y1 : 'a + 'b) = InR y2 ¤ y1 = y2) ±
	³(InL x1 = InR y1) ±
	³(InR y1 = InL x1) ±
	OutL(InL x1:'a + 'b) = x1 ±
	OutR(InR y1:'a + 'b) = y1 ±
	(IsL z ¤ InL(OutL z) = z) ±
	(IsR z ¤ InR(OutR z) = z)
	®);
a (strip_asm_tac (simple_´_match_mp_rule type_lemmas_thm
	(get_defn "-" "+")));
a(strip_asm_tac (get_defn "-" "IsSumRep"));
a(MAP_EVERY simple_¶_tac
	[¬(abs o (inl : 'a ­ 'a ¸ 'b ¸ BOOL)):'a ­ 'a + 'b®,
	¬(abs o (inr : 'b ­ 'a ¸ 'b ¸ BOOL)):'b ­ 'a + 'b®,
	¬((outl:'a ¸ 'b ¸ BOOL ­ 'a) o rep):'a + 'b ­ 'a®,
	¬((outr:'a ¸ 'b ¸ BOOL ­ 'b) o rep):'a + 'b ­ 'b®,
	¬((isl:'a ¸ 'b ¸ BOOL ­ BOOL) o rep):'a + 'b ­ BOOL®,
	¬((isr:'a ¸ 'b ¸ BOOL ­ BOOL) o rep):'a + 'b ­ BOOL®]
);
a(REPEAT simple_µ_tac THEN rewrite_tac[o_def]);
a(GET_NTH_ASM_T 2 (fn th1 => DROP_NTH_ASM_T 1 (fn th2
	=> ante_tac (rewrite_rule [th1] th2))));
a(´_T(ante_tac o all_µ_intro o list_simple_µ_elim [
	¬x1: 'a®, ¬x2: 'a®, ¬y1: 'b®, ¬y2: 'b®, ¬rep (z:'a+'b):'a ¸ 'b ¸ BOOL®]));
a(asm_rewrite_tac[]);
a(´_T(MAP_EVERY (asm_tac o all_µ_intro) o
	(strip_±_rule o all_simple_µ_elim)));
a(asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 10 (strip_asm_tac o all_simple_µ_elim));
(* *** Goal "1.1" *** *)
a(undisch_tac(get_asm 2) THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 1 (ante_tac o ap_fun_rule ¬rep:'a + 'b ­ ('a ¸ 'b ¸ BOOL)®)
	THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(DROP_NTH_ASM_T 1 (ante_tac o ap_fun_rule ¬rep:'a + 'b ­ ('a ¸ 'b ¸ BOOL)®)
	THEN asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "6" *** *)
a(³_tac ¬T® THEN (rewrite_tac[] ORELSE_T accept_tac t_thm));
a(POP_ASM_T (ante_tac o ap_fun_rule ¬rep:'a + 'b ­ ('a ¸ 'b ¸ BOOL)®)
	THEN asm_rewrite_tac[]);
(* *** Goal "7" *** *)
a(³_tac ¬T® THEN (rewrite_tac[] ORELSE_T accept_tac t_thm));
a(POP_ASM_T (ante_tac o ap_fun_rule ¬rep:'a + 'b ­ ('a ¸ 'b ¸ BOOL)®)
	THEN asm_rewrite_tac[]);
(* *** Goal "8" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "9" *** *)
a(POP_ASM_T (ante_tac o ap_fun_rule ¬rep:'a + 'b ­ ('a ¸ 'b ¸ BOOL)®)
	THEN asm_rewrite_tac[]);
(* *** Goal "10" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "11" *** *)
a(POP_ASM_T (ante_tac o ap_fun_rule ¬rep:'a + 'b ­ ('a ¸ 'b ¸ BOOL)®)
	THEN asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val Ûsum_cases_thmÝ = save_thm("sum_cases_thm",
	all_µ_intro(hd(strip_±_rule(all_simple_µ_elim sum_clauses))));
=TEX
=SML
val Ûsum_fns_thmÝ = save_thm("sum_fns_thm",(
push_goal([],¬µ (f: 'a ­ 'c) (g: 'b ­ 'c) ·
	¶%down%1 h: 'a + 'b ­ 'c ·
	h o InL = f ± h o InR = g®);
a(REPEAT strip_tac);
a(conv_tac simple_¶%down%1_conv);
a(simple_¶_tac ¬Ì x:'a+'b·
	if IsL x then ((f: 'a ­ 'c)(OutL x)) else ((g: 'b ­ 'c)(OutR x))®);
a(rewrite_tac[ext_thm, o_def,sum_clauses]);
a(REPEAT strip_tac);
a(²_THEN asm_tac (simple_µ_elim ¬x'® sum_cases_thm));
(* *** Goal "1" *** *)
a(POP_ASM_T (fn x=> once_rewrite_tac[eq_sym_rule x]));
a(asm_rewrite_tac[sum_clauses]);
(* *** Goal "2" *** *)
a(POP_ASM_T (fn x=> once_rewrite_tac[eq_sym_rule x]));
a(asm_rewrite_tac[sum_clauses]);
pop_thm()));
=TEX
\subsection{End of Theory ``sum''}
=SML
val lsubgoal_package_quiet 
	= set_flag("subgoal_package_quiet",lsubgoal_package_quiet);
end; (* of struct SumTheory *)
open SumTheory;
=TEX
\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


