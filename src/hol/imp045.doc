%  $Id$ %Z%
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the General Purpose Theories}  %% Mandatory field
\def\TPPheadtitle{Implementation for the General Purpose Theories}
\TPPref{DS/FMU/IED/IMP045}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document creates the theories
``one'', ``combin'' and ``sum''.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Taken $ext\_thm$ from elsewhere, and used $ante\_tac$.
\item [Issue 1.3]
Made ``set'' the parent.
\item [Issue 1.4]
Made ``sets'' the parent.
\item [Issue 1.5]
Changes after comments.
Renamed constants $S$, $K$ and $I$ to $CombS$, $CombK$ and $CombI$.
\item [Issue 1.6]
Changed precedence of ``+''.

\item[Issue 1.7, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.8 (23rd January 1992)]
$new\_axiom$, $simple\_new\_type\_defn$, $new\_type\_defn$
all changed to take lists of keys, rather than single ones.
\item[Issue 1.9 (27th January 1992)]
Corrected a typo.
\item [Issue 1.10 (13th April 1992)]
Changes due to CR0017.
\item [Issue 1.12 (14th May 1992)]
Tidying up proof contexts.
\item [Issue 1.14 (2nd June 1992)]
Added hierarchy sealing.
\end{description}
% \subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the general purpose theories.
This is called for in \cite{DS/FMU/IED/HLD011}.
The design is in \cite{DS/FMU/IED/DTD045}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the 
general purpose theories.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD045},
and also requires the theory ``sets'' defined in
\cite{DS/FMU/IED/DTD044}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{THE THEORY ``basic$\_$hol''}
=SML
structure €BasicHolTheory› : BasicHolTheory = struct
val _ = open_theory "char";
val _ = new_theory "€basic_hol›";
val _ = icl'Kernel.icl'seal_hierarchy();
val _ = push_merge_pcs ["propositions",
		"simple_abstractions"];
end;
=TEX
\section{THE THEORY ``one''}
=SML
structure €OneTheory› : OneTheory = struct
val _ = open_theory "basic_hol";
val _ = new_theory "€one›";
=TEX
=SML
val €is_one_rep_def› = new_spec(["IsOneRep","is_one_rep_def"],1, (
push_goal([],¨∂ IsOneRep:BOOL ≠ BOOL ∑
	∂ one : BOOL ∑ 
	µ x: BOOL∑ IsOneRep x § (x § one)Æ);
a(simple_∂_tac¨Ã x ∑ x = TÆ THEN 
 simple_∂_tac¨TÆ THEN
 rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €one_def1› = new_type_defn(["ONE","one_def1"],"ONE",[],(
push_goal([],¨∂ x: BOOL ∑ IsOneRep xÆ);
a(strip_asm_tac (get_defn "-" "IsOneRep"));
a(simple_∂_tac ¨one:BOOLÆ THEN
  asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €one_def› = new_spec(["One","one_def"],1,(
push_goal([],¨∂ One : ONE ∑ µ x: ONE∑ x = OneÆ);
a (strip_asm_tac (simple_¥_match_mp_rule type_lemmas_thm
	(get_defn "-" "ONE")));
a(strip_asm_tac (get_defn "-" "IsOneRep"));
a(simple_∂_tac ¨abs (one:BOOL):ONEÆ);
a simple_µ_tac;
a(GET_NTH_ASM_T 2 (fn th1 => DROP_NTH_ASM_T 1 (fn th2
	=> ante_tac (rewrite_rule [th1] th2))));
a(¥_T (ante_tac o simple_µ_elim ¨rep (x:ONE):BOOLÆ));
a(asm_rewrite_tac[]);
a(¥_T (fn x=> asm_rewrite_tac[eq_sym_rule x]));
pop_thm()));
=TEX
=SML
val €one_fns_thm› = save_thm("one_fns_thm",(
push_goal([],¨µ f: 'a ≠ ONE ∑ f = Ã x ∑ OneÆ);
a(rewrite_tac[ext_thm,one_def]);
pop_thm()));
=TEX
\subsection{End of Theory ``one''}
=SML
end; (* of structure OneTheory *)
open OneTheory;
=TEX
\section{THE THEORY ``combin''}
=SML
structure €CombinTheory› : CombinTheory = struct
val _ = open_theory "basic_hol";
val _ = new_theory "€combin›";
=TEX
=SML
val _ = declare_infix (300, "o");
val €o_def› = new_spec(["o","o_def"],1,(
push_goal([],¨∂ $o ∑ µ (f:'b ≠ 'c) (g:'a ≠ 'b) (x: 'a) ∑
	(f o g) x = f(g x)Æ);
a(simple_∂_tac ¨Ã (f:'b ≠ 'c) (g:'a ≠ 'b) (x: 'a) ∑ f(g x)Æ THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €comb_s_def› = new_spec(["CombS","comb_s_def"],1,(
push_goal([],¨∂ CombS ∑ µ (f:'a ≠ 'b ≠ 'c) (g:'a ≠ 'b) (x:'a) ∑
	CombS f g x = f x (g x)Æ);
a(simple_∂_tac ¨Ã (f:'a ≠ 'b ≠ 'c) (g:'a ≠ 'b) (x:'a) ∑
	f x (g x)Æ THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €comb_k_def› = new_spec(["CombK","comb_k_def"],1,(
push_goal([],¨∂ CombK ∑ µ (x : 'a) (y : 'b) ∑ CombK x y = xÆ);
a(simple_∂_tac ¨Ã (x : 'a) (y : 'b) ∑ xÆ THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €comb_i_def› = new_spec(["CombI","comb_i_def"],1,(
push_goal([],¨∂ CombI ∑ µ (x : 'a) ∑ CombI x = xÆ);
a(simple_∂_tac ¨Ã (x : 'a) ∑ xÆ THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €s_k_thm› = save_thm ("s_k_thm", (
push_goal([],¨µ x ∑ (CombS:('a ≠ 'b ≠ 'a) ≠ ('a ≠ 'b) ≠ 'a ≠ 'a) CombK x = CombIÆ);
a(simple_µ_tac THEN rewrite_tac[ext_thm, comb_s_def, comb_k_def, comb_i_def]);
pop_thm()));
=TEX
=SML
val €o_assoc_thm› = save_thm ("o_assoc_thm",(
push_goal([],¨µ (f:'a ≠ 'b) (g:'c ≠ 'a) (h :'d ≠ 'c)∑ 
	f o (g o h) = (f o g) o hÆ);
a(REPEAT simple_µ_tac THEN rewrite_tac[ext_thm,o_def]);
pop_thm()));
=TEX
=SML
val €o_i_thm› = save_thm ("o_i_thm",(
push_goal([],¨µ f : 'a ≠ 'b∑
	((CombI o f) = f) ± ((f o CombI) = f)Æ);
a(REPEAT simple_µ_tac THEN rewrite_tac[ext_thm,o_def, comb_i_def]);
pop_thm()));
=TEX
\subsection{End of Theory ``combin''}
=SML
end; (* of struct CombinTheory *)
open CombinTheory;
=TEX
\section{THE THEORY ``sum''}
=SML
structure €SumTheory› : SumTheory = struct
val _ = open_theory "combin";
val _ = new_theory "€sum›";
=TEX
=SML
val €is_sum_rep_def› = new_spec(["IsSumRep","is_sum_rep_def"],1,(
push_goal([],¨∂ IsSumRep ∑ 
∂ (inl:'a ≠  'a ∏ 'b ∏ BOOL) (inr:'b ≠  'a ∏ 'b ∏ BOOL)
  (outl:'a ∏ 'b ∏ BOOL ≠ 'a) (outr:'a ∏ 'b ∏ BOOL ≠ 'b)
  (isl:'a ∏ 'b ∏ BOOL ≠ BOOL) (isr:'a ∏ 'b ∏ BOOL ≠ BOOL) ∑
µ (x1:'a) (x2:'a) (y1:'b) (y2:'b) (z: 'a ∏ 'b ∏ BOOL) ∑
	IsSumRep(inl x1) ±
	IsSumRep(inr y1) ±
	(IsSumRep z ¥ (inl(outl z) = z ≤ inr(outr z) = z)) ±
	(inl x1 = inl x2 § x1 = x2) ±
	(inr y1 = inr y2 § y1 = y2) ±
	≥(inl x1 = inr y1) ±
	≥(inr y1 = inl x1) ±
	outl(inl x1) = x1 ±
	outr(inr y1) = y1 ±
	(IsSumRep z ¥ (isl z § inl(outl z) = z)) ±
	(IsSumRep z ¥ (isr z § inr(outr z) = z))
	Æ);
a(MAP_EVERY simple_∂_tac [
	¨Ã ((a:'a), (b:'b), c) ∑ 
	 if c then (b = Arbitrary) else (a = Arbitrary)Æ,
	¨Ã a:'a∑ (a, Arbitrary, T)Æ,
	¨Ã b:'b∑ (Arbitrary, b, F)Æ,
	¨Ã ((a:'a), (b:'b), (c:BOOL)) ∑ aÆ,
	¨Ã ((a:'a), (b:'b), (c:BOOL)) ∑ bÆ,
	¨Ã ((a:'a), (b:'b), (c:BOOL)) ∑ cÆ,
	¨Ã ((a:'a), (b:'b), c) ∑ ≥ cÆ]
	THEN rewrite_tac[pair_clauses]);
a(REPEAT strip_tac THEN (asm_rewrite_tac[pair_clauses] ORELSE_T id_tac));
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[pair_clauses]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[pair_clauses]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[pair_clauses]);
pop_thm()));
=TEX
=SML
val _ = declare_infix (300,"+");
val €sum_def› = new_type_defn(["+","sum_def"],"+",["'a","'b"],(
push_goal([],¨∂ x: 'a ∏ 'b ∏ BOOL ∑ IsSumRep xÆ);
a(strip_asm_tac (get_defn "-" "IsSumRep"));
a(simple_∂_tac¨inl (x:'a):'a ∏ 'b ∏ BOOLÆ);
a(asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €sum_clauses› = new_spec(["InL", "InR", "OutL", "OutR", "IsL", "IsR","sum_clauses"],6,(
push_goal([],¨
∂ InL InR OutL OutR IsL IsR ∑
µ (x1:'a) (x2:'a) (y1:'b) (y2:'b) (z: 'a + 'b) ∑
	(InL(OutL z) = z ≤ InR(OutR z) = z) ±
	((InL x1 : 'a + 'b) = InL x2 § x1 = x2) ±
	((InR y1 : 'a + 'b) = InR y2 § y1 = y2) ±
	≥(InL x1 = InR y1) ±
	≥(InR y1 = InL x1) ±
	OutL(InL x1:'a + 'b) = x1 ±
	OutR(InR y1:'a + 'b) = y1 ±
	(IsL z § InL(OutL z) = z) ±
	(IsR z § InR(OutR z) = z)
	Æ);
a (strip_asm_tac (simple_¥_match_mp_rule type_lemmas_thm
	(get_defn "-" "+")));
a(strip_asm_tac (get_defn "-" "IsSumRep"));
a(MAP_EVERY simple_∂_tac
	[¨(abs o (inl : 'a ≠ 'a ∏ 'b ∏ BOOL)):'a ≠ 'a + 'bÆ,
	¨(abs o (inr : 'b ≠ 'a ∏ 'b ∏ BOOL)):'b ≠ 'a + 'bÆ,
	¨((outl:'a ∏ 'b ∏ BOOL ≠ 'a) o rep):'a + 'b ≠ 'aÆ,
	¨((outr:'a ∏ 'b ∏ BOOL ≠ 'b) o rep):'a + 'b ≠ 'bÆ,
	¨((isl:'a ∏ 'b ∏ BOOL ≠ BOOL) o rep):'a + 'b ≠ BOOLÆ,
	¨((isr:'a ∏ 'b ∏ BOOL ≠ BOOL) o rep):'a + 'b ≠ BOOLÆ]
);
a(REPEAT simple_µ_tac THEN rewrite_tac[o_def]);
a(GET_NTH_ASM_T 2 (fn th1 => DROP_NTH_ASM_T 1 (fn th2
	=> ante_tac (rewrite_rule [th1] th2))));
a(¥_T(ante_tac o all_µ_intro o list_simple_µ_elim [
	¨x1: 'aÆ, ¨x2: 'aÆ, ¨y1: 'bÆ, ¨y2: 'bÆ, ¨rep (z:'a+'b):'a ∏ 'b ∏ BOOLÆ]));
a(asm_rewrite_tac[]);
a(¥_T(MAP_EVERY (asm_tac o all_µ_intro) o
	(strip_±_rule o all_simple_µ_elim)));
a(asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 10 (strip_asm_tac o all_simple_µ_elim));
(* *** Goal "1.1" *** *)
a(asm_ante_tac(get_asm 2) THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 1 (ante_tac o app_fun_rule ¨rep:'a + 'b ≠ ('a ∏ 'b ∏ BOOL)Æ)
	THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(DROP_NTH_ASM_T 1 (ante_tac o app_fun_rule ¨rep:'a + 'b ≠ ('a ∏ 'b ∏ BOOL)Æ)
	THEN asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "6" *** *)
a(≥_tac ¨TÆ THEN (rewrite_tac[] ORELSE_T accept_tac t_thm));
a(POP_ASM_T (ante_tac o app_fun_rule ¨rep:'a + 'b ≠ ('a ∏ 'b ∏ BOOL)Æ)
	THEN asm_rewrite_tac[]);
(* *** Goal "7" *** *)
a(≥_tac ¨TÆ THEN (rewrite_tac[] ORELSE_T accept_tac t_thm));
a(POP_ASM_T (ante_tac o app_fun_rule ¨rep:'a + 'b ≠ ('a ∏ 'b ∏ BOOL)Æ)
	THEN asm_rewrite_tac[]);
(* *** Goal "8" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "9" *** *)
a(POP_ASM_T (ante_tac o app_fun_rule ¨rep:'a + 'b ≠ ('a ∏ 'b ∏ BOOL)Æ)
	THEN asm_rewrite_tac[]);
(* *** Goal "10" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "11" *** *)
a(POP_ASM_T (ante_tac o app_fun_rule ¨rep:'a + 'b ≠ ('a ∏ 'b ∏ BOOL)Æ)
	THEN asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val €sum_cases_thm› = save_thm("sum_cases_thm",
	all_µ_intro(hd(strip_±_rule(all_simple_µ_elim sum_clauses))));
=TEX
=SML
val €sum_fns_thm› = save_thm("sum_fns_thm",(
push_goal([],¨µ (f: 'a ≠ 'c) (g: 'b ≠ 'c) ∑
	∂â1 h: 'a + 'b ≠ 'c ∑
	h o InL = f ± h o InR = gÆ);
a(REPEAT strip_tac);
a(conv_tac simple_∂â1_conv);
a(simple_∂_tac ¨Ã x:'a+'b∑
	if IsL x then ((f: 'a ≠ 'c)(OutL x)) else ((g: 'b ≠ 'c)(OutR x))Æ);
a(rewrite_tac[ext_thm, o_def,sum_clauses]);
a(REPEAT strip_tac);
a(≤_THEN asm_tac (simple_µ_elim ¨x'Æ sum_cases_thm));
(* *** Goal "1" *** *)
a(POP_ASM_T (fn x=> once_rewrite_tac[eq_sym_rule x]));
a(asm_rewrite_tac[sum_clauses]);
(* *** Goal "2" *** *)
a(POP_ASM_T (fn x=> once_rewrite_tac[eq_sym_rule x]));
a(asm_rewrite_tac[sum_clauses]);
pop_thm()));
=TEX
\subsection{End of Theory ``sum''}
=SML
end; (* of struct SumTheory *)
open SumTheory;
=TEX
\section{THE THEORY ``hol''}
=SML
=SML
structure €HolTheory› : HolTheory = struct
val _ = open_theory "one";
val _ = new_theory "€hol›";
val _ = new_parent "sum";
val _ = pop_pc();
end;
=TEX

\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


