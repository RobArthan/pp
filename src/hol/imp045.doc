=IGN
********************************************************************************
imp045.doc: this file is part of the PPHol system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
%  $Id: imp045.doc,v 1.20 2005/12/16 10:34:27 rda Exp rda $ %Z%
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the General Purpose Theories}  %% Mandatory field
\def\TPPheadtitle{Implementation for the General Purpose Theories}
\TPPref{DS/FMU/IED/IMP045}  %% Mandatory field
\def\SCCSversion{$Revision: 1.20 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2005/12/16 10:34:27 $ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document creates the theories
``one'', ``combin'' and ``sum''.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Taken $ext\_thm$ from elsewhere, and used $ante\_tac$.
\item [Issue 1.3]
Made ``set'' the parent.
\item [Issue 1.4]
Made ``sets'' the parent.
\item [Issue 1.5]
Changes after comments.
Renamed constants $S$, $K$ and $I$ to $CombS$, $CombK$ and $CombI$.
\item [Issue 1.6]
Changed precedence of ``+''.

\item[Issue 1.7, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.8 (23rd January 1992)]
$new\_axiom$, $simple\_new\_type\_defn$, $new\_type\_defn$
all changed to take lists of keys, rather than single ones.
\item[Issue 1.9 (27th January 1992)]
Corrected a typo.
\item [Issue 1.10 (13th April 1992)]
Changes due to CR0017.
\item [Issue 1.12 (14th May 1992)]
Tidying up proof contexts.
\item [Issue 1.14 (2nd June 1992)]
Added hierarchy sealing.
\item[Issue 1.15 (24th June 1992)]
Renamings from issue 1.6 of \cite{DS/FMU/IED/WRK038},
mostly proof context name changes.
\item [Issue 1.16,1.17 (7th July 1992)]
Greater support for reasoning about sum types.
\item[Issue 1.18] Copyright and banner updates for open source release.
\item[Issue 1.19] PPHol-specific updates for open source release
\item[Issue 1.20] The prefix for private interfaces is now $pp'$ rather than $icl'$.
\item[Issue 1.21] Now use $new\_spec1$ rather than $new\_spec$.
\end{description}
% \subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the general purpose theories.
This is called for in \cite{DS/FMU/IED/HLD011}.
The design is in \cite{DS/FMU/IED/DTD045}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the 
general purpose theories.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD045},
and also requires the theory ``sets'' defined in
\cite{DS/FMU/IED/DTD044}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\section{THE THEORY ``basic$\_$hol''}
=SML
structure ÛBasicHolTheoryÝ : BasicHolTheory = struct
val _ = open_theory "char";
val _ = new_theory "Ûbasic_holÝ";
val _ = pp'Kernel.pp'seal_hierarchy();
val _ = push_merge_pcs ["'propositions",
		"'simple_abstractions"];
end;
=TEX
\section{THE THEORY ``one''}
=SML
structure ÛOneTheoryÝ : OneTheory = struct
val _ = open_theory "basic_hol";
val _ = new_theory "ÛoneÝ";
=TEX
=SML
val Ûis_one_rep_defÝ = new_spec1(["IsOneRep","is_one_rep_def"], ["IsOneRep"], (
push_goal([],¬¶ IsOneRep:BOOL ­ BOOL ·
	¶ one : BOOL · 
	µ x: BOOL· IsOneRep x ¤ (x ¤ one)®);
a(simple_¶_tac¬Ì x · x = T® THEN 
 simple_¶_tac¬T® THEN
 rewrite_tac[]);
pop_thm()));
=TEX
=SML
val Ûone_def1Ý = new_type_defn(["ONE","one_def1"],"ONE",[],(
push_goal([],¬¶ x: BOOL · IsOneRep x®);
a(strip_asm_tac (get_defn "-" "IsOneRep"));
a(simple_¶_tac ¬one:BOOL® THEN
  asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val Ûone_defÝ = new_spec1(["One","one_def"], ["One"], (
push_goal([],¬¶ One : ONE · µ x: ONE· x = One®);
a (strip_asm_tac (simple_´_match_mp_rule type_lemmas_thm
	(get_defn "-" "ONE")));
a(strip_asm_tac (get_defn "-" "IsOneRep"));
a(simple_¶_tac ¬abs (one:BOOL):ONE®);
a simple_µ_tac;
a(GET_NTH_ASM_T 2 (fn th1 => DROP_NTH_ASM_T 1 (fn th2
	=> ante_tac (rewrite_rule [th1] th2))));
a(´_T (ante_tac o simple_µ_elim ¬rep (x:ONE):BOOL®));
a(asm_rewrite_tac[]);
a(´_T (fn x=> asm_rewrite_tac[eq_sym_rule x]));
pop_thm()));
=TEX
=SML
val Ûone_fns_thmÝ = save_thm("one_fns_thm",(
push_goal([],¬µ f: 'a ­ ONE · f = Ì x · One®);
a(rewrite_tac[ext_thm,one_def]);
pop_thm()));
=TEX
\subsection{End of Theory ``one''}
=SML
end; (* of structure OneTheory *)
open OneTheory;
=TEX
\section{THE THEORY ``combin''}
=SML
structure ÛCombinTheoryÝ : CombinTheory = struct
val _ = open_theory "basic_hol";
val _ = new_theory "ÛcombinÝ";
=TEX
=SML
val _ = declare_infix (300, "o");
val Ûo_defÝ = new_spec1(["o","o_def"], ["o"] ,(
push_goal([],¬¶ $o · µ (f:'b ­ 'c) (g:'a ­ 'b) (x: 'a) ·
	(f o g) x = f(g x)®);
a(simple_¶_tac ¬Ì (f:'b ­ 'c) (g:'a ­ 'b) (x: 'a) · f(g x)® THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val Ûcomb_s_defÝ = new_spec1(["CombS","comb_s_def"], ["CombS"], (
push_goal([],¬¶ CombS · µ (f:'a ­ 'b ­ 'c) (g:'a ­ 'b) (x:'a) ·
	CombS f g x = f x (g x)®);
a(simple_¶_tac ¬Ì (f:'a ­ 'b ­ 'c) (g:'a ­ 'b) (x:'a) ·
	f x (g x)® THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val Ûcomb_k_defÝ = new_spec1(["CombK","comb_k_def"], ["CombK"], (
push_goal([],¬¶ CombK · µ (x : 'a) (y : 'b) · CombK x y = x®);
a(simple_¶_tac ¬Ì (x : 'a) (y : 'b) · x® THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val Ûcomb_i_defÝ = new_spec1(["CombI","comb_i_def"], ["CombI"], (
push_goal([],¬¶ CombI · µ (x : 'a) · CombI x = x®);
a(simple_¶_tac ¬Ì (x : 'a) · x® THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val Ûs_k_thmÝ = save_thm ("s_k_thm", (
push_goal([],¬µ x · (CombS:('a ­ 'b ­ 'a) ­ ('a ­ 'b) ­ 'a ­ 'a) CombK x = CombI®);
a(simple_µ_tac THEN rewrite_tac[ext_thm, comb_s_def, comb_k_def, comb_i_def]);
pop_thm()));
=TEX
=SML
val Ûo_assoc_thmÝ = save_thm ("o_assoc_thm",(
push_goal([],¬µ (f:'a ­ 'b) (g:'c ­ 'a) (h :'d ­ 'c)· 
	f o (g o h) = (f o g) o h®);
a(REPEAT simple_µ_tac THEN rewrite_tac[ext_thm,o_def]);
pop_thm()));
=TEX
=SML
val Ûo_i_thmÝ = save_thm ("o_i_thm",(
push_goal([],¬µ f : 'a ­ 'b·
	((CombI o f) = f) ± ((f o CombI) = f)®);
a(REPEAT simple_µ_tac THEN rewrite_tac[ext_thm,o_def, comb_i_def]);
pop_thm()));
=TEX
\subsection{End of Theory ``combin''}
=SML
end; (* of struct CombinTheory *)
open CombinTheory;
=TEX
\section{THE THEORY ``sum''}
=SML
structure ÛSumTheoryÝ : SumTheory = struct
val _ = open_theory "combin";
val _ = new_theory "ÛsumÝ";
=TEX
=SML
val Ûis_sum_rep_defÝ = new_spec1(["IsSumRep","is_sum_rep_def"], ["IsSumRep"], (
push_goal([],¬¶ IsSumRep · 
¶ (inl:'a ­  'a ¸ 'b ¸ BOOL) (inr:'b ­  'a ¸ 'b ¸ BOOL)
  (outl:'a ¸ 'b ¸ BOOL ­ 'a) (outr:'a ¸ 'b ¸ BOOL ­ 'b)
  (isl:'a ¸ 'b ¸ BOOL ­ BOOL) (isr:'a ¸ 'b ¸ BOOL ­ BOOL) ·
µ (x1:'a) (x2:'a) (y1:'b) (y2:'b) (z: 'a ¸ 'b ¸ BOOL) ·
	IsSumRep(inl x1) ±
	IsSumRep(inr y1) ±
	(IsSumRep z ´ (inl(outl z) = z ² inr(outr z) = z)) ±
	(inl x1 = inl x2 ¤ x1 = x2) ±
	(inr y1 = inr y2 ¤ y1 = y2) ±
	³(inl x1 = inr y1) ±
	³(inr y1 = inl x1) ±
	outl(inl x1) = x1 ±
	outr(inr y1) = y1 ±
	(IsSumRep z ´ (isl z ¤ inl(outl z) = z)) ±
	(IsSumRep z ´ (isr z ¤ inr(outr z) = z))
	®);
a(MAP_EVERY simple_¶_tac [
	¬Ì ((a:'a), (b:'b), c) · 
	 if c then (b = Arbitrary) else (a = Arbitrary)®,
	¬Ì a:'a· (a, Arbitrary, T)®,
	¬Ì b:'b· (Arbitrary, b, F)®,
	¬Ì ((a:'a), (b:'b), (c:BOOL)) · a®,
	¬Ì ((a:'a), (b:'b), (c:BOOL)) · b®,
	¬Ì ((a:'a), (b:'b), (c:BOOL)) · c®,
	¬Ì ((a:'a), (b:'b), c) · ³ c®]
	THEN rewrite_tac[pair_clauses]);
a(REPEAT strip_tac THEN (asm_rewrite_tac[pair_clauses] ORELSE_T id_tac));
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[pair_clauses]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[pair_clauses]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[pair_clauses]);
pop_thm()));
=TEX
=SML
val _ = declare_infix (300,"+");
val Ûsum_defÝ = new_type_defn(["+","sum_def"],"+",["'a","'b"],(
push_goal([],¬¶ x: 'a ¸ 'b ¸ BOOL · IsSumRep x®);
a(strip_asm_tac (get_defn "-" "IsSumRep"));
a(simple_¶_tac¬inl (x:'a):'a ¸ 'b ¸ BOOL®);
a(asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val Ûsum_clausesÝ = new_spec1(["InL", "InR", "OutL", "OutR", "IsL", "IsR","sum_clauses"],
	["InL", "InR", "OutL", "OutR", "IsL", "IsR"], (
push_goal([],¬
¶ InL InR OutL OutR IsL IsR ·
µ (x1:'a) (x2:'a) (y1:'b) (y2:'b) (z: 'a + 'b) ·
	(InL(OutL z) = z ² InR(OutR z) = z) ±
	((InL x1 : 'a + 'b) = InL x2 ¤ x1 = x2) ±
	((InR y1 : 'a + 'b) = InR y2 ¤ y1 = y2) ±
	³(InL x1 = InR y1) ±
	³(InR y1 = InL x1) ±
	OutL(InL x1:'a + 'b) = x1 ±
	OutR(InR y1:'a + 'b) = y1 ±
	(IsL z ¤ InL(OutL z) = z) ±
	(IsR z ¤ InR(OutR z) = z)
	®);
a (strip_asm_tac (simple_´_match_mp_rule type_lemmas_thm
	(get_defn "-" "+")));
a(strip_asm_tac (get_defn "-" "IsSumRep"));
a(MAP_EVERY simple_¶_tac
	[¬(abs o (inl : 'a ­ 'a ¸ 'b ¸ BOOL)):'a ­ 'a + 'b®,
	¬(abs o (inr : 'b ­ 'a ¸ 'b ¸ BOOL)):'b ­ 'a + 'b®,
	¬((outl:'a ¸ 'b ¸ BOOL ­ 'a) o rep):'a + 'b ­ 'a®,
	¬((outr:'a ¸ 'b ¸ BOOL ­ 'b) o rep):'a + 'b ­ 'b®,
	¬((isl:'a ¸ 'b ¸ BOOL ­ BOOL) o rep):'a + 'b ­ BOOL®,
	¬((isr:'a ¸ 'b ¸ BOOL ­ BOOL) o rep):'a + 'b ­ BOOL®]
);
a(REPEAT simple_µ_tac THEN rewrite_tac[o_def]);
a(GET_NTH_ASM_T 2 (fn th1 => DROP_NTH_ASM_T 1 (fn th2
	=> ante_tac (rewrite_rule [th1] th2))));
a(´_T(ante_tac o all_µ_intro o list_simple_µ_elim [
	¬x1: 'a®, ¬x2: 'a®, ¬y1: 'b®, ¬y2: 'b®, ¬rep (z:'a+'b):'a ¸ 'b ¸ BOOL®]));
a(asm_rewrite_tac[]);
a(´_T(MAP_EVERY (asm_tac o all_µ_intro) o
	(strip_±_rule o all_simple_µ_elim)));
a(asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 10 (strip_asm_tac o all_simple_µ_elim));
(* *** Goal "1.1" *** *)
a(asm_ante_tac(get_asm 2) THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 1 (ante_tac o app_fun_rule ¬rep:'a + 'b ­ ('a ¸ 'b ¸ BOOL)®)
	THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(DROP_NTH_ASM_T 1 (ante_tac o app_fun_rule ¬rep:'a + 'b ­ ('a ¸ 'b ¸ BOOL)®)
	THEN asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "6" *** *)
a(³_tac ¬T® THEN (rewrite_tac[] ORELSE_T accept_tac t_thm));
a(POP_ASM_T (ante_tac o app_fun_rule ¬rep:'a + 'b ­ ('a ¸ 'b ¸ BOOL)®)
	THEN asm_rewrite_tac[]);
(* *** Goal "7" *** *)
a(³_tac ¬T® THEN (rewrite_tac[] ORELSE_T accept_tac t_thm));
a(POP_ASM_T (ante_tac o app_fun_rule ¬rep:'a + 'b ­ ('a ¸ 'b ¸ BOOL)®)
	THEN asm_rewrite_tac[]);
(* *** Goal "8" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "9" *** *)
a(POP_ASM_T (ante_tac o app_fun_rule ¬rep:'a + 'b ­ ('a ¸ 'b ¸ BOOL)®)
	THEN asm_rewrite_tac[]);
(* *** Goal "10" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "11" *** *)
a(POP_ASM_T (ante_tac o app_fun_rule ¬rep:'a + 'b ­ ('a ¸ 'b ¸ BOOL)®)
	THEN asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val Ûsimple_sum_cases_thmÝ =(
	all_µ_intro(hd(strip_±_rule(all_simple_µ_elim sum_clauses)))
);

val Ûsum_cases_thmÝ = (
push_goal([],¬µ x:'a + 'b · (¶ y · x = InL y) ² 
		(¶ z · x = InR z)®);
a(simple_µ_tac);
a(strip_asm_tac (conv_rule (ONCE_MAP_C eq_sym_conv) (simple_µ_elim ¬x® simple_sum_cases_thm)));
(* *** Goal "1" *** *)
a(once_asm_rewrite_tac[]);
a(²_left_tac THEN simple_¶_tac ¬(OutL x)® THEN rewrite_tac[]);
(* *** Goal "2" *** *)
a(once_asm_rewrite_tac[]);
a(²_right_tac THEN simple_¶_tac ¬(OutR x)® THEN rewrite_tac[]);
save_thm("sum_cases_thm", pop_thm()));
=TEX
=SML
val Ûsum_fns_thmÝ = save_thm("sum_fns_thm",(
push_goal([],¬µ (f: 'a ­ 'c) (g: 'b ­ 'c) ·
	¶1 h: 'a + 'b ­ 'c ·
	h o InL = f ± h o InR = g®);
a(REPEAT strip_tac);
a(conv_tac simple_¶1_conv);
a(simple_¶_tac ¬Ì x:'a+'b·
	if IsL x then ((f: 'a ­ 'c)(OutL x)) else ((g: 'b ­ 'c)(OutR x))®);
a(rewrite_tac[ext_thm, o_def,sum_clauses]);
a(REPEAT strip_tac);
a(²_THEN asm_tac (simple_µ_elim ¬x'® simple_sum_cases_thm));
(* *** Goal "1" *** *)
a(POP_ASM_T (fn x=> once_rewrite_tac[eq_sym_rule x]));
a(asm_rewrite_tac[sum_clauses]);
(* *** Goal "2" *** *)
a(POP_ASM_T (fn x=> once_rewrite_tac[eq_sym_rule x]));
a(asm_rewrite_tac[sum_clauses]);
pop_thm()));
=TEX
=SML
fun Ûis_sum_typeÝ (ty : TYPE) : bool = (
	case (dest_simple_type ty) of
	Ctype("+",[_,_]) => true
	| _ => false
);
=TEX
=SML
val Ûµ_sum_thmÝ = 
(push_goal([],¬µ p · (µ x : 'a + 'b · p x) ¤ 
	((µ y : 'a · p (InL y)) ± (µ z : 'b · p (InR z)))®);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(strip_asm_tac (simple_µ_elim ¬x® sum_cases_thm));
(* *** Goal "1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[]);
pop_thm());
local
	val vaty = 'a®;
	val vbty = 'b®;
in	
val Ûµ_sum_convÝ : CONV = (fn tm =>
let	val (x,bdy) = dest_simple_µ tm
		handle (Fail _) =>
		term_fail "µ_sum_conv" 45001 [tm];
	val lxbdy = snd(dest_app tm);
	val (aty,bty) = case dest_simple_type (type_of x) of
		Ctype("+",[a,b]) => (a,b)
		| _ => term_fail "µ_sum_conv" 45001 [tm];
	val xnm = fst(dest_var x);
	val (xnm',xnm'') = (
			case list_variant (frees bdy) 
				[mk_var(xnm,aty), mk_var(xnm,bty)] of
			[a,b] => (fst(dest_var a),fst(dest_var b))
			| _ => term_fail "µ_sum_conv" 45001 [tm]);
	val s1 = simple_µ_elim lxbdy 
		(inst_type_rule [(aty,vaty),(bty,vbty)]
		 µ_sum_thm);
	val s2 = conv_rule (ONCE_MAP_C simple_Â_conv) s1;
	val s3 = conv_rule (RAND_C
		(APP_C (RAND_C(RAND_C (simple_Á_conv xnm')),
		RAND_C(simple_Á_conv xnm''))))
			s2;
	val s4 = eq_trans_rule (refl_conv tm) s3;
in
	s4
end);
end;
=TEX
=SML
fun Ûlintro_µ_tacÝ (x : TERM) : TACTIC = (fn (seqasms, conc) =>
	([(seqasms, mk_simple_µ(x, conc))],
		(fn [thm] => simple_µ_elim x thm | _ => bad_proof "lintro_µ_tac"))
);

=TEX
=SML
fun Ûsum_cases_tacÝ (tm : TERM) : TACTIC = (fn gl as (seqasms,conc) =>
	if not(is_var tm andalso is_sum_type (type_of tm))
	then term_fail "sum_cases_tac" 45002 [tm]
	else if not (is_free_in tm conc)
	then term_fail "sum_cases_tac" 38002 [tm]
	else if any seqasms (is_free_in tm)
	then term_fail "sum_cases_tac" 38003 [tm]
	else 
		(lintro_µ_tac tm THEN
		conv_tac µ_sum_conv THEN 
		±_tac THEN 
		simple_µ_tac) gl
);

=TEX
\subsection{End of Theory ``sum''}
=SML
end; (* of struct SumTheory *)
open SumTheory;
=TEX
\section{THE THEORY ``hol''}
=SML
=SML
structure ÛHolTheoryÝ : HolTheory = struct
val _ = open_theory "one";
val _ = new_theory "ÛholÝ";
val _ = new_parent "sum";
val _ = pop_pc();
end;
=TEX

\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


