%  $Id$ %Z%
=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Implementation for the General Purpose Theories}  %% Mandatory field
\def\TPPheadtitle{Implementation for the General Purpose Theories}
\TPPref{DS/FMU/IED/IMP045}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document creates the theories
``one'', ``combin'' and ``sum''.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Taken $ext\_thm$ from elsewhere, and used $ante\_tac$.
\end{description}
% \subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the general purpose theories.
This is called for in \cite{DS/FMU/IED/HLD011}.
The design is in \cite{DS/FMU/IED/DTD045}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the 
general purpose theories.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD045},
and also requires the theory ``pair'' defined in
\cite{DS/FMU/IED/DTD037}.
However, the actual parent will eventualy be $set$.
\subsubsection{Deficiencies}
Parentage in doubt!
\subsubsection{Possible Enhancements}
None known.
\section{THE THEORY ``one''}
=SML
structure ‚OneTheory· : OneTheory = struct
val _ = new_theory "one";
=TEX
=SML
val _ = new_specification(["IsOneRep"],1, (
push_goal([],ªÑ IsOneRep:BOOL ã BOOL é
	Ñ one : BOOL é 
	É x: BOOLé IsOneRep x Ç (x Ç one)º);
a(simple_Ñ_tacªç x é x = Tº THEN 
 simple_Ñ_tacªTº THEN
 rewrite_tac[]);
pop_thm()));
=TEX
=SML
val _ = new_type_defn("ONE","ONE",[],(
push_goal([],ªÑ x: BOOL é IsOneRep xº);
a(strip_asm_tac (get_defn "-" "IsOneRep"));
a(simple_Ñ_tac ªone:BOOLº THEN
  asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val ‚one_def· = new_specification(["One"],1,(
push_goal([],ªÑ One : ONE é É x: ONEé x = Oneº);
a (strip_asm_tac (simple_ä_match_mp_rule type_lemmas_thm
	(get_defn "-" "ONE")));
a(strip_asm_tac (get_defn "-" "IsOneRep"));
a(simple_Ñ_tac ªabs (one:BOOL):ONEº);
a simple_É_tac;
a(GET_NTH_ASM_T 2 (fn th1 => DROP_NTH_ASM_T 1 (fn th2
	=> ante_tac (rewrite_rule [th1] th2))));
a(ä_T (ante_tac o simple_É_elim ªrep (x:ONE):BOOLº));
a(asm_rewrite_tac[]);
a(ä_T (fn x=> asm_rewrite_tac[eq_sym_rule x]));
pop_thm()));
=TEX
=SML
val ‚one_fns_thm· = save_thm("one_fns_thm",(
push_goal([],ªÉ f: 'a ã ONE é f = ç x é Oneº);
a(rewrite_tac[ext_thm,one_def]);
pop_thm()));
=TEX
\subsection{End of Theory ``one''}
=SML
end; (* of structure OneTheory *)
open OneTheory;
=TEX
\section{THE THEORY ``combin''}
=SML
structure CombinTheory : CombinTheory = struct
val _ = new_theory "combin";
=TEX
=SML
val _ = declare_infix (300, "o");
val ‚o_def· = new_specification(["o"],1,(
push_goal([],ªÑ $o é É (f:'b ã 'c) (g:'a ã 'b) (x: 'a) é
	(f o g) x = f(g x)º);
a(simple_Ñ_tac ªç (f:'b ã 'c) (g:'a ã 'b) (x: 'a) é f(g x)º THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val ‚s_def· = new_specification(["S"],1,(
push_goal([],ªÑ S é É (f:'a ã 'b ã 'c) (g:'a ã 'b) (x:'a) é
	S f g x = f x (g x)º);
a(simple_Ñ_tac ªç (f:'a ã 'b ã 'c) (g:'a ã 'b) (x:'a) é
	f x (g x)º THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val ‚k_def· = new_specification(["K"],1,(
push_goal([],ªÑ K é É (x : 'a) (y : 'b) é K x y = xº);
a(simple_Ñ_tac ªç (x : 'a) (y : 'b) é xº THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val ‚i_def· = new_specification(["I"],1,(
push_goal([],ªÑ I é É (x : 'a) é I x = xº);
a(simple_Ñ_tac ªç (x : 'a) é xº THEN rewrite_tac[]);
pop_thm()));
=TEX
=SML
val ‚s_k_thm· = save_thm ("s_k_thm", (
push_goal([],ªÉ x é (S:('a ã 'b ã 'a) ã ('a ã 'b) ã 'a ã 'a) K x = Iº);
a(simple_É_tac THEN rewrite_tac[ext_thm, s_def, k_def, i_def]);
pop_thm()));
=TEX
=SML
val ‚o_assoc_thm· = save_thm ("o_assoc_thm",(
push_goal([],ªÉ (f:'a ã 'b) (g:'c ã 'a) (h :'d ã 'c)é 
	f o (g o h) = (f o g) o hº);
a(REPEAT simple_É_tac THEN rewrite_tac[ext_thm,o_def]);
pop_thm()));
=TEX
=SML
val ‚o_i_thm· = save_thm ("o_i_thm",(
push_goal([],ªÉ f : 'a ã 'bé
	((I o f) = f) Ä ((f o I) = f)º);
a(REPEAT simple_É_tac THEN rewrite_tac[ext_thm,o_def, i_def]);
pop_thm()));
=TEX
\subsection{End of Theory ``combin''}
=SML
end; (* of struct CombinTheory *)
open CombinTheory;
=TEX
\section{THE THEORY ``sum''}
=SML
structure SumTheory : SumTheory = struct
val _ = new_theory "sum";
=TEX
=SML
val ‚is_sum_rep_def· = new_specification(["IsSumRep"],1,(
push_goal([],ªÑ IsSumRep é 
Ñ (inl:'a ã  'a â 'b â BOOL) (inr:'b ã  'a â 'b â BOOL)
  (outl:'a â 'b â BOOL ã 'a) (outr:'a â 'b â BOOL ã 'b)
  (isl:'a â 'b â BOOL ã BOOL) (isr:'a â 'b â BOOL ã BOOL) é
É (x1:'a) (x2:'a) (y1:'b) (y2:'b) (z: 'a â 'b â BOOL) é
	IsSumRep(inl x1) Ä
	IsSumRep(inr y1) Ä
	(IsSumRep z ä (inl(outl z) = z Å inr(outr z) = z)) Ä
	(inl x1 = inl x2 Ç x1 = x2) Ä
	(inr y1 = inr y2 Ç y1 = y2) Ä
	å(inl x1 = inr y1) Ä
	å(inr y1 = inl x1) Ä
	outl(inl x1) = x1 Ä
	outr(inr y1) = y1 Ä
	(IsSumRep z ä (isl z Ç inl(outl z) = z)) Ä
	(IsSumRep z ä (isr z Ç inr(outr z) = z))
	º);
a(MAP_EVERY simple_Ñ_tac [
	ªç ((a:'a), (b:'b), c) é 
	 if c then (b = á x éT) else (a = á yéT)º,
	ªç a:'aé (a, (á x:'b éT), T)º,
	ªç b:'bé ((á y:'a éT), b, F)º,
	ªç ((a:'a), (b:'b), (c:BOOL)) é aº,
	ªç ((a:'a), (b:'b), (c:BOOL)) é bº,
	ªç ((a:'a), (b:'b), (c:BOOL)) é cº,
	ªç ((a:'a), (b:'b), c) é å cº]
	THEN rewrite_tac[pair_clauses]);
a(REPEAT strip_tac THEN (asm_rewrite_tac[pair_clauses] ORELSE_T id_tac));
(* *** Goal "1" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[pair_clauses]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[pair_clauses]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[pair_clauses]);
pop_thm()));
=TEX
=SML
val _ = declare_infix (120,"+");
val ‚sum_def· = new_type_defn("+","+",["'a","'b"],(
push_goal([],ªÑ x: 'a â 'b â BOOL é IsSumRep xº);
a(strip_asm_tac (get_defn "-" "IsSumRep"));
a(simple_Ñ_tacªinl (x:'a):'a â 'b â BOOLº);
a(asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val ‚sum_clauses· = new_specification(["InL", "InR", "OutL", "OutR", "IsL", "IsR"],6,(
push_goal([],ª
Ñ InL InR OutL OutR IsL IsR é
É (x1:'a) (x2:'a) (y1:'b) (y2:'b) (z: 'a + 'b) é
	(InL(OutL z) = z Å InR(OutR z) = z) Ä
	((InL x1 : 'a + 'b) = InL x2 Ç x1 = x2) Ä
	((InR y1 : 'a + 'b) = InR y2 Ç y1 = y2) Ä
	å(InL x1 = InR y1) Ä
	å(InR y1 = InL x1) Ä
	OutL(InL x1:'a + 'b) = x1 Ä
	OutR(InR y1:'a + 'b) = y1 Ä
	(IsL z Ç InL(OutL z) = z) Ä
	(IsR z Ç InR(OutR z) = z)
	º);
a (strip_asm_tac (simple_ä_match_mp_rule type_lemmas_thm
	(get_defn "-" "+")));
a(strip_asm_tac (get_defn "-" "IsSumRep"));
a(MAP_EVERY simple_Ñ_tac
	[ª(abs o (inl : 'a ã 'a â 'b â BOOL)):'a ã 'a + 'bº,
	ª(abs o (inr : 'b ã 'a â 'b â BOOL)):'b ã 'a + 'bº,
	ª((outl:'a â 'b â BOOL ã 'a) o rep):'a + 'b ã 'aº,
	ª((outr:'a â 'b â BOOL ã 'b) o rep):'a + 'b ã 'bº,
	ª((isl:'a â 'b â BOOL ã BOOL) o rep):'a + 'b ã BOOLº,
	ª((isr:'a â 'b â BOOL ã BOOL) o rep):'a + 'b ã BOOLº]
);
a(REPEAT simple_É_tac THEN rewrite_tac[o_def]);
a(GET_NTH_ASM_T 2 (fn th1 => DROP_NTH_ASM_T 1 (fn th2
	=> ante_tac (rewrite_rule [th1] th2))));
a(ä_T(ante_tac o all_É_intro o list_simple_É_elim [
	ªx1: 'aº, ªx2: 'aº, ªy1: 'bº, ªy2: 'bº, ªrep (z:'a+'b):'a â 'b â BOOLº]));
a(asm_rewrite_tac[]);
a(ä_T(MAP_EVERY (asm_tac o all_É_intro) o
	(strip_Ä_rule o all_simple_É_elim)));
a(asm_rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 10 (strip_asm_tac o all_simple_É_elim));
(* *** Goal "1.1" *** *)
a(undisch_tac(get_asm 2) THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(DROP_NTH_ASM_T 1 (ante_tac o ap_fun_rule ªrep:'a + 'b ã ('a â 'b â BOOL)º)
	THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(DROP_NTH_ASM_T 1 (ante_tac o ap_fun_rule ªrep:'a + 'b ã ('a â 'b â BOOL)º)
	THEN asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "6" *** *)
a(å_tac ªTº THEN (rewrite_tac[] ORELSE_T accept_tac t_thm));
a(POP_ASM_T (ante_tac o ap_fun_rule ªrep:'a + 'b ã ('a â 'b â BOOL)º)
	THEN asm_rewrite_tac[]);
(* *** Goal "7" *** *)
a(å_tac ªTº THEN (rewrite_tac[] ORELSE_T accept_tac t_thm));
a(POP_ASM_T (ante_tac o ap_fun_rule ªrep:'a + 'b ã ('a â 'b â BOOL)º)
	THEN asm_rewrite_tac[]);
(* *** Goal "8" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "9" *** *)
a(POP_ASM_T (ante_tac o ap_fun_rule ªrep:'a + 'b ã ('a â 'b â BOOL)º)
	THEN asm_rewrite_tac[]);
(* *** Goal "10" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "11" *** *)
a(POP_ASM_T (ante_tac o ap_fun_rule ªrep:'a + 'b ã ('a â 'b â BOOL)º)
	THEN asm_rewrite_tac[]);
pop_thm()));
=TEX
=SML
val ‚sum_cases_thm· = save_thm("sum_cases_thm",
	all_É_intro(hd(strip_Ä_rule(all_simple_É_elim sum_clauses))));
=TEX
=SML
val ‚sum_fns_thm· = save_thm("sum_fns_thm",(
push_goal([],ªÉ (f: 'a ã 'c) (g: 'b ã 'c) é
	Ñ%down%1 h: 'a + 'b ã 'c é
	h o InL = f Ä h o InR = gº);
a(REPEAT strip_tac);
a(conv_tac simple_Ñ%down%1_conv);
a(simple_Ñ_tac ªç x:'a+'bé
	if IsL x then ((f: 'a ã 'c)(OutL x)) else ((g: 'b ã 'c)(OutR x))º);
a(rewrite_tac[ext_thm, o_def,sum_clauses]);
a(REPEAT strip_tac);
a(Å_THEN asm_tac (simple_É_elim ªx'º sum_cases_thm));
(* *** Goal "1" *** *)
a(POP_ASM_T (fn x=> once_rewrite_tac[eq_sym_rule x]));
a(asm_rewrite_tac[sum_clauses]);
(* *** Goal "2" *** *)
a(POP_ASM_T (fn x=> once_rewrite_tac[eq_sym_rule x]));
a(asm_rewrite_tac[sum_clauses]);
pop_thm()));
=TEX
\subsection{End of Theory ``sum''}
=SML
end; (* of struct SumTheory *)
open SumTheory;
=TEX
\newpage
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
