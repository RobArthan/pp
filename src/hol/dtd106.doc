=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\def\TPPheadtitle{Arithmetic Proof Procedures For Z}
\TPPtitle{Detailed Design of Arithmetic Proof Procedures For Z}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD106}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D.~Arthan & WIN01}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document contains the detailed design of proof
procedures for integer arithmetic in Z.
The main proof procedures provided are arithmetic normalisation and a linear arithmetic prover.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item[Issues 1.1-1.3] Author's drafts.
\item[Issue 1.4] First attempt at integration.
\item[Issue 1.5] Changed language of the theory to HOL.
This is only necessary, because the theory listing in the gives {\LaTeX} errors.
However, the definitions in the theory aren't Z, so this solution has some justification.
\item[Issue 1.6]
Added $(')z\_lin\_arith1$ proof context.
\item{Issue 1.7]
Correction for SML97.
\end{description}
\subsection{Changes forecast}
As determined by comments and use.
\newpage
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design of part of the \ProductZ\ system.
The document responds to \cite{DS/FMU/IED/HLD016}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
The purpose of this document is to provide facilities for the integers in Z analogous to those for the integers in HOL as described in \cite{DS/FMU/IED/DTD093}.
The main facilities are a conversion to put arithmetic expressions into a normal form and a decision procedure for zero-order linear arithmetic.

For simplicity of implementation, the facilities are provided by an interface to those for HOL.
This enables much better re-use of existing material than would be possible in a direct implementation (because the arithmetic

\subsubsection{Dependencies}
This document depends on the theory $z\_numbers$ defined in
\cite{DS/FMU/IED/DTD086}, on the conversions and other tools in  \cite{DS/FMU/IED/DTD105}.

\subsubsection{Algorithms}
For simplicity of implementation, the facilities are provided by an interface to those for HOL.
This enables much better re-use of existing material than would be possible in a direct implementation (at heart, because the generic support for arithmetic normalisation in \cite{DS/FMU/IED/DTD081} deals with curried HOL functions and adjusting it to work with Z infix operators would involve a relatively large amount of custom re-coding or interfacing).

For the arithmetic normalisation, the main interface here uses the HOL conversion and then converts back to Z.
As the linear arithmetic prover is a prove-or-fail black box, most users will be not need any understanding of the conversion to HOL behind the scenes.


\subsubsection{Possible Enhancements}
Several additions could be made.
E.g., more interfaces for the tactic programmer (e.g., see $and\_conv1$ in the implementation.
\newpage
\section{THE THEORY}
=SML
open_theory"z_numbers";
new_theory"z_arithmetic_tools";
set_current_language"HOL";
¹HOLCONST
Ü	z_ú ú_z: ú ­ ú
÷
Ü	ú_z (îú 1) = ñ1® 
Ü
Ü±	(µ i j· ú_z (i +‰Z j) = ñ¬ú_z i® + ¬ú_z j®®)
Ü±	(µ i· ú_z (~‰Z i) = ñ~¬ú_z i®®)
Ü
Ü±	z_ú ñ1® = îú 1
Ü
Ü±	(µ i j· z_ú ñi + j® = z_ú i +‰Z z_ú j)
Ü±	(µ i· z_ú ñ~ i® = ~‰Z(z_ú i))
Ü
Ü±	(µx· z_ú(ú_z x) = x) ± (µy· ú_z(z_ú y) = y)
°
=TEX
\section{SIGNATURE}
=DOC 
signature ÛZArithmeticToolsÝ = sig
=DESCRIBE
This is the signature of a structure containing arithmetic and an automatic linear
arithmetic prover for the integers in Z.
=ENDDOC
\subsection{Conversion of Z Arithmetic to HOL Arithmetic}

=DOC 
	val Ûz_ú_convÝ : CONV;
	val Ûú_z_convÝ : CONV;
=DESCRIBE
In the theory $z\_arithmetic\_tools$, isomorphisms, $z\_ú$ and $ú\_z$, are defined between the Z integers and the HOL integers.
These may be used to translate an arithmetic problem in Z into one in HOL.
These conversions implement this translation and its inverse.

The operators handled by the conversions are
=INLINEFT
+, *, ~
=TEX
\ and $-$.

The translation to HOL is carried out according to the following scheme:

=GFT
z_úñt1 + t2®	­	¬z_ú t1 + z_ú  t2®
z_úñt1 * t2®	­	¬z_ú t1 * z_ú  t2®
z_úñ~t1®	­	¬~ z_ú t1®
z_úñú_z t1®	­	¬t1®
z_úñZ'Int c®	­	¬îú c®
=TEX

$z\_ú\_conv$ implements the above scheme recursively to translate the
result of applying $z\_ú$ to a Z arithmetic expression into HOL.

$ú\_z\_conv$ is the analogue of $z\_ú\_conv$, performing the translation of $ú\_z$ applied to a HOL integer arithmetic expression into Z.
=USES
Tactic programming.
=SEEALSO
=INLINEFT
z_anf_conv, z_lin_arith, 'z_lin_arith
=FAILURE
106001	?0 is not of the form ¬z_ú ñt®® where ñt® is constructed from +, ~, -, * or
	integer constants
106002	?0 is not of the form ¬ú_z ¬t®® where ¬t® is constructed from +, ~, -, * or
	integer constants
=ENDDOC
\subsection{Arithmetic Normalisation}

=DOC 
	val Ûz_anf_convÝ : CONV;
=DESCRIBE
=INLINEFT
z_anf_conv
=TEX
\ is a conversion which proves theorems of the form
=INLINEFT
ô t1 = t2
=TEX
\ where $t1$ is a Z expression formed from atoms of type ú and
$t2$ is in what we may call additive normal form, i.e. it has the form:
=INLINEFT
t‰1 + t‰2 + ...
=TEX
, where the 
=INLINEFT
t‰i
=TEX
\ have the form
=INLINEFT
s‰1 * s‰2 * ...
=TEX
where the
=INLINEFT
s‰i
=TEX
\ are atoms.
Here, by atom
we mean an expression which is not of the form
=INLINEFT
t‰1 + t‰2 + ...
=TEX
or
=INLINEFT
s‰1 * s‰2 * ...
=TEX
.

The summands
=INLINEFT
t‰i
=TEX
\ and,
within them,
the factors
=INLINEFT
s‰j
=TEX
\ are given in increasing order with respect to the ordering
on terms analogous to that given by the function 
=INLINEFT
z_term_order
=TEX
, q.v. Arithmetic computation is carried out on atoms to ensure
that at most one of the summands is a numeric literal and that, within
each summand, at most one factor is a numeric literal. Any literal appears
at the beginning of its factor or summand and addition of $0$
or multiplication by $1$ is simplified out.
Any signs are moved to the first factor in each summand.

The conversion fails with error number 106010 if there no changes can be
made to the term.

=FAILURE
106010	?0 is not of type ”ú® or is already in additive normal form
=ENDDOC


\section{PROOF CONTEXTS}
=DOC
(* Proof Context: Ûz_lin_arithÝ *)
(* Proof Context: Ûz_lin_arith1Ý *)
=DESCRIBE
``$z\_lin\_arith$'' is a proof context whose main purpose is to supply a decision procedure
for problems in linear arithmetic in Z.
``$z\_lin\_arith1$''  differs from it only by using ``$'z\_numbers1$''.
The proof context provides an interface to the proof context $'ú\_lin\_arith$ which provides the analogous facilities for the HOL integers.
\paragraph{Contents}
The proof context is the result of merging $z\_predicates$, $'z\_numbers(1)$ and $'z\_lin\_arith$.

\paragraph{Examples}
=INLINEFT
PC_T1"z_lin_arith"prove_tac[]
=TEX
\ will prove any of the following goals:
=GFT
	([], ñµa, b, c:ú·a ¼ b ± (a + b < c + a) ´ a < c®)
	([], ñµa, b, c:ú·a ¾ b ± ³ b < c ´ a ¾ c®)
	([], ñµa, b, c:ú·a + 2*b < 2*a ´ b + b < a®)
	([], ñµ x, y:ú· ³ (2*x + y = 4 ± 4*x + 2*y = 7)®)
=TEX

In the following example, an induction reduces the problem to linear
arithmetic, and then the automatic proof tactic in $z\_lin\_arith$
completes the proof.
=GFT
set_goal([], ñµb:î·(b + 1)*(b + 1) > 0®);
a(PC_T1 "z_library" REPEAT strip_tac);
a( z_¼_induction_tacñb® THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
pop_thm();
=TEX
=SEEALSO
=INLINEFT
'z_lin_arith
=FAILUREC
\paragraph{Errors}
The errors reported by the automatic proof tactic are as for $'ú\_lin\_arith$.
=ENDDOC
=DOC
(* Proof Context: Û'z_lin_arithÝ *)
(* Proof Context: Û'z_lin_arith1Ý *)
=DESCRIBE
``$'z\_lin\_arith$'' is a component proof context whose purpose is to supply a decision procedure
for problems in linear arithmetic for the integers in Z.
``$'z\_lin\_arith1$'' i a copy, only differing in using ``$'z_numbers1$''. 
\paragraph{Contents}
The rewriting, theorem stripping and conclusion stripping components
are those from $'z_numbers$ augmented with the following
transformations:
=GFT
ñ(a º ú) = b®		­	ña ¼ b ± b ¼ a®
ña ¼ b®		­	¬‘TRY_C z_ú_conv ¬z_ú a®® ¼ ‘TRY_C z_ú_conv ¬b®®®
ña < b®		­	¬‘TRY_C z_ú_conv ¬a®® < ‘TRY_C z_ú_conv ¬b®®®
ñx  î®		­	¬0 ¼ x®
=TEX
(where all variables are of type ú).
The effect of the above scheme is to transformed any Z equation or inequality in ¼ or $<$ into an equivalent inequality over the HOL integers.
The automatic proof procedures for the proof context are (slight adaptations of) the ones in the proof context $ú\_lin\_arith$, which can then automatically prove the transformed form if it is a theorem of linear arithmetic.

The automatic proof components is an interface to the one for $'ú\_lin\_arith$.
Other components are as for $'z\_numbers$.

\paragraph{Examples}
A typical use of the proof context would be to solve problems containing
a mixture of (linear) arithmetic and set theory.

For example,
=INLINEFT
MERGE_PCS_T1["z_sets_ext", "'z_lin_arith"]prove_tac[]
=TEX
will prove any of the following goals:
=GFT
	([], ñµm:ú· {i:ú | m ¼ i ± i < m+3} = {m, m+1, m+2}®)
	([], ñ{i, j : ú | 30*i = 105*j} = {i, j : ú | 2*i = 7*j}®)
	([], ñ{i : ú | 5*i = 6*i} = {0}®)
=SEEALSO
=INLINEFT
z_lin_arith, z_numbers, 'z_numbers
=FAILUREC
\paragraph{Errors}
The errors reported by the automatic proof tactic are as for $'ú\_lin\_arith$.
=ENDDOC
\section{THEOREMS}
=DOC
val Ûz_ú_defÝ : THM;
val Ûú_z_defÝ : THM;
val Ûz_ú_plus_thmÝ : THM;
val Ûz_ú_times_thmÝ : THM;
val Ûz_ú_subtract_thmÝ : THM;
val Ûz_ú_minus_thmÝ : THM;
val Ûú_z_plus_thmÝ : THM;
val Ûú_z_times_thmÝ : THM;
val Ûú_z_subtract_thmÝ : THM;
val Ûú_z_minus_thmÝ : THM;
val Ûz_ú_one_one_thmÝ : THM;
val Ûú_z_one_one_thmÝ : THM;
val Ûz_¼_ú_¼_thmÝ : THM;
val Ûz_less_ú_less_thmÝ : THM;
=DESCRIBE
These are the Standard ML bindings for the theorems saved in the theory $z\_arithmetic\_tools$ which provides isomorphisms between the ring of integers in HOL and the ring of integers in Z.
The main purpose of this theory is to allow proof procedures for HOL integers to be adapted to work with Z.
The most common way of using these isomorphisms is via the proof context $z\_lin\_arith$, q.v.
=ENDDOC
=THDOC
req_name Û"z_arithmetic_tools"Ý (Value "z_numbers");
req_language "HOL";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $z\_arithmetic\_tools$ contains definitions allowing proof procedures for HOL integers to be adapted to work with Z.
=ENDDOC
=THDOC
req_consistency_thm¬ú_z®;
req_consistency_thm¬z_ú®;
req_thm("z_ú_plus_thm",
	([], ¬µ i j· ñ¬z_ú ñi + j®®® = ñ¬z_ú i®® +‰Z ñ¬z_ú j®®®));
req_thm("z_ú_times_thm",
	([], ¬µ i j· ñ¬z_ú ñi * j®®® = ñ¬z_ú i®® *‰Z ñ¬z_ú j®®®));
req_thm("z_ú_subtract_thm",
	([], ¬µ i j· ñ¬z_ú ñi - j®®® = ñ¬z_ú i®® -‰Z ñ¬z_ú j®®®));
req_thm("z_ú_minus_thm",
	([], ¬µ i· ñ¬z_ú ñ~ i®®® = ~‰Z ñ¬z_ú i®®®));
req_thm("ú_z_plus_thm",
	([], ¬µ i j· ñ¬ú_z (i +‰Z j)®® = ñ¬ú_z i® + ¬ú_z j®®®));
req_thm("ú_z_times_thm",
	([], ¬µ i j· ñ¬ú_z (i *‰Z j)®® = ñ¬ú_z i® * ¬ú_z j®®®));
req_thm("ú_z_subtract_thm",
	([], ¬µ i j· ñ¬ú_z (i -‰Z j)®® = ñ¬ú_z i® - ¬ú_z j®®®));
req_thm("ú_z_minus_thm",
	([], ¬µ i· ñ¬ú_z (~‰Z i)®® = ñ~ ¬ú_z i®®®));
req_thm("z_ú_one_one_thm",
	([], ¬µ i j· ñ¬z_ú i®® = ñ¬z_ú j®® ¤ i = j®));
req_thm("ú_z_one_one_thm",
	([], ¬µ i j· ñ¬ú_z i®® = ñ¬ú_z j®® ¤ i = j®));
req_thm("z_¼_ú_¼_thm",
	([], ¬µ i j· ñ(i, j)®  ñ(_ ¼ _)® ¤ ñ¬z_ú i®® ¼‰Z ñ¬z_ú j®®®));
req_thm("z_less_ú_less_thm",
	([], ¬µ i j· ñ(i, j)®  ñ(_ < _)® ¤ ñ¬z_ú i®® <‰Z ñ¬z_ú j®®®));
=DESCRIBE
These theorems are of use in programming with the isomorphisms $z\_ú$
and $ú\_z$ which relate the Z and HOL integers.
=ENDDOC
\section{EPILOGUE}
=SML
end (* of signature ZArithmeticTools *);
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

