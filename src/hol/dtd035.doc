=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design for Theory Design Support Tools}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for Theory Design Support Tools}
\TPPref{DS/FMU/IED/DTD035}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
tools that support the production of theory designs.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Changes after comments.
\item [Issue 1.3]
Made $req\_flag$ explicit, added $list\_?$. 
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
tools that support the production of theory designs.
The tools and techniques described should be used
to document all ICL supplied theories.
However, the tools do not form part of a release of ICL HOL.
The design is
implemented in \cite{DS/FMU/IED/IMP035}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the
tools that support the production of theory designs.
In addition, it describes how these tools are to be used.
\subsubsection{Dependencies}
This document depends on the presence of \cite{DS/FMU/IED/IMP020}.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}
A method of displaying the required ``theory'',
or some other fuller item than just $summarize\-\_td\-\_results$.
\newpage
\section{DISCUSSION}
A design of a theory should, when complete, define exactly what
is present in a given theory.
When providing user documentation this ``presence'' includes the
associated tactics, conversions, etc, dedicated to handling
constructs introduced by the theory.
However for the purposes of this document we are only 
interested in items accessed from the theory database by
the interface functions of \cite{DS/FMU/IED/DTD012}.
Indeed, we are also interested in only specific portions of the user data
of a theory, as well as not being interested in its ancestors (as opposed to parents), its children, or its status.

We do not adopt the alternative requirement, which is for the design to demand merely that those 
things stated in the design be present, thus allowing 
additional things. This seems unreasonably liberal, and encourages
unnecessary clutter.

Given a theory design, we wish to be able to automatically check that the design type checks and that a particular theory satisfies the design.
We choose to do this by introducing a ``=THDOC'' keyword
and declaring a ``thdoc'' option for $screen$
in the standard screenfile.
This keyword acts in a similar manner to ``=DOC'', but the
information box is considered as not for the user's consumption, and is for extraction only with the ``thdoc'' or ``tex'' filters, and in particular not with the ``sml'' filter.
We also provide a ``=THSML'' keyword, corresponding to ``=SML'' but only seen in $tex$ and $thdoc$ screen views.

An alternative to the ``=THDOC'' approach would have been to introduce one new
keyword per kind of object in a theory.
This would allow for a tidier presentation, but at additional
implementation and document processing costs.

Complimenting ``=THDOC'' is the provision of a set
of functions prefixed with $req\_$: e.g. $req\_const$ and $req\_axiom$.
These ``require functions'' have one of two effects, depending on the
value of the flag $req\_flag$.
In ``declare'' mode they will do sufficient work to create a theory in which all subsequent $req\_$ functions will evaluate successfully, using $new\_const$ and $new\_type$ to allow successful parsing.
This mode allows a design to be type-checked,
without having to create a theory implementation.

In ``check'' mode the $req\_$ functions indicate that their argument must be
present in the theory being checked, and that nothing else
must be in the theory other than those things noted by the sum of the $req\_$ functions used.
\section{METHOD OF USE}
The implementor will first create a detailed design (``dtd'' sequence) document,
containing both a function design, that may be 
processed to give some structure signatures,
and a theory design.
The pieces of the theory design may be given mingled with
the signature declaration, as the two are extracted separately.
The theory design is constrained to declare its name before any other declarations, and declare parents, types and constants
before their use in terms that require parsing, but otherwise the ordering
chosen does not in turn constrain the order of implementation.
For a running example let us assume the design document we start with
is  ``dtd123.doc''.

Using ``doc4errors'' the implementor may extract the signature
and error messages into a file called ``dtd123.sml'' which may be checked by loading into
Standard ML.
Then, using ``doc4thdesign'' the implementor may extract the theory design, with lines indicating $req\_flag$ set to ``declare'' mode, and loading the theory design support tools.
This  produces a ``dtd123.tds'' file which also may be checked by loading into
Standard ML, separately from the ``dtd123.sml'' file.

The implementor then produces an implementation (``imp'' sequence) document, ``imp123.doc''.
From this they produce a ``imp123.sml'' file using ``doc4errors''.
This is checked against the design's signature by 
first loading ``dtd123.sml'' and then ``imp123.sml''.

They then produce a theory check file from the 
detailed design document, using ``doc4thcheck'',
producing the file ``dtd123.thc''.
This has lines indicating $req\_flag$ set to ``check'' mode, and that the theory design support tools should be loaded,
and that a description and summary of the results
of the check should be made.
The check is made by loading ``dtd123.sml'', ``imp123.sml'' and then ``dtd123.thc'', and examining the log
of the load of ``dtd123.thc'' to see if it gave any complaint.

The implementor then produces a module test ($mdt$ sequence) document, $mdt123.doc$.
A request to load ``dtd123.thc'' will be embedded in
this file.
In addition, the theory support tools will provide a 
function $theory\-\_check\-\_success$ that returns $true$ or $false$ depending on the
success of the check, and after the loading of the ``.thc'' document the module test document should,
if it is using the material from \cite{DS/FMU/IED/DTD013},
contain the lines:
ó
store_mt_results[("theory check",
	theory_check_success,
	(),
	true)];
æ
This ensures that the module test summary records the 
success of the theory check.
The author of a module test document is strongly advised to
make the theory check as the last module test, so that the theory design check
summary is close to the end of the log of the main module test.

Having two (rather than one) additional document strippers has the advantage that ``wrapping'' clutter need not occur in the 
the detailed design documents,
nor need a check involve more than a just a single $usefile$ command.
\section{EXAMPLE OF USE}
For our example we choose a possible theory introducing
the type of pairs: the actual theory is somewhat different.
It is presented as if it is the source text of the ``dtdnnn.doc'', before processing by ``doc4...''.
óExample of use
 =TEX
\section{THE THEORY pair}
...
 =THDOC
req_name "pair" (OPT "misc");
 =DESCRIBE
This is the theory of pairs, and the functions upon them.
We use many features of the parent theory "misc" in implementing pairs.
 =ENDDOC
...
 =THDOC
req_infix "‰";
req_type ("‰",2);
req_type_defn ([],»„ f Ž TypeDefinition PairPred f¼);
 =DESCRIBE
The actual type and its definition.
 =ENDDOC
...
æ
óExample of use
 =THDOC
req_infix ",";
req_const ("Fst",»:('1 ‰ '2) ‹ '1¼);
req_const ("Snd",»:('1 ‰ '2) ‹ '2¼);
req_const (",",»:'1 ‹ '2 ‹ ('1 ‰ '2)¼);
req_defn (["Fst","Snd",","],([],
	»ƒ (a:'1) (b:'2) (c:'1) (d:'2) (e:''1 ‰ '2) Ž 
	 (Fst(a,b) = a) € 
	 (Snd(a,b) = b) €
	 (((a,b) = (c,d)) ‚ ((a = c) € (b = b))) €
	 ((Fst e, Snd e) = e)¼));
 =DESCRIBE
...
 =USES
...
 =ENDDOC
...
 =THDOC
req_thm ("pair_exists_thm",([],
	»ƒ c : '1 ‰ '2 Ž „ x y Ž c = (x, y)¼));
 =DESCRIBE
...
 =USES
...
 =ENDDOC
...
\section{END OF THEORY}
...
æ
\section{THE SUPPORT TOOLS}
=DOC
signature âTheoryDesignSupportá = sig
=DESCRIBE
This signature contains the tools for declaring
and checking a theory design.
=FAILURE
35001	Theory name not declared
=FAILUREC
The theory design tools in ``declare'' mode must
be given a new theory name by $req\_name$ to work in before
any other $req\_$ functions are used.
In ``check'' mode they must be informed of a theory to
check against before other $req\_$ functions can do anything.
The error message 35001 indicates that one of these requirements
have not been met.
=ENDDOC
\subsection{Starting and Stopping}
=DOC
datatype MODE = Declare | Check;
val âreq_flagá : MODE ref;
=DESCRIBE
This sets whether the theory design tools are in ``declare mode'' ($Declare$) and ``check mode'' ($Check$).
It should be set before  a call to $initialise\_td\_results$
(q.v.).
The default is ``check mode''.
=ENDDOC
=DOC
val âinitialise_td_resultsá : unit  -> unit;
=DESCRIBE
This function initialises the process of either type-checking a theory design, or checking a theory implementation
against a design.
If $req\_flag$ (q.v.) is $Declare$ then it is in ``declare'' mode, and the purpose of the following processing is to type check the theory design.
If $Check$ then it is in ``check'' mode, and the purpose of the following processing is to check that the design
and implementation match.
The ``require functions'' are called in the same manner for both modes.
=ENDDOC
=DOC
val âsummarize_td_resultsá : unit -> unit;
=DESCRIBE
This function is only useful in ``check'' mode, and 
executes the check that the theory components so far 
declared match the implementation.
It informs the user of mismatches by side-effect, rather
than failure.
In ``declare'' mode it will complain about those things
not saved on the theory by the require functions
(e.g. theorems), and otherwise remain quiet.

=FAILURE
35002	Theory ?0 is missing parent(s): ?1
35003	Theory ?0 has additional parent(s): ?1
35004	Theory ?0 is missing constant(s): ?1
35005	Theory ?0 has additional constant(s): ?1
35006	Theory ?0 is missing type(s): ?1
35007	Theory ?0 has additional type(s): ?1
35008	Theory ?0 is missing axiom(s): ?1
35009	Theory ?0 has additional axiom(s): ?1
35010	Theory ?0 is missing definition(s): ?1
35011	Theory ?0 has additional definition(s): ?1
35012	Theory ?0 is missing terminator(s): ?1
35013	Theory ?0 has additional terminator(s): ?1
35014	Theory ?0 is missing theorem(s): ?1
35015	Theory ?0 has additional theorem(s): ?1
35016	Theory ?0 gives ?1 the status ?2 when design calls for ?3
35017	Theory ?0 has language ?1 when design calls for ?2
35031	Theory ?0 has missing alias(es): ?1
35032	Theory ?0 has additional alias(es): ?1
35033	Theory ?0 has missing type abbreviation(s): ?1
35034	Theory ?0 has additional type abbreviation(s): ?1
35035	Theory ?0 checks completed without mismatch
35036	Theory ?0 checks showed mismatch(s)
=ENDDOC
=DOC
val âtheory_check_successá : unit -> bool;
=DESCRIBE
This function returns true if in ``check'' mode and
the design matchs the implementation.
It always returns $true$ in ``declare'' mode, as in this
mode we only want to avoid an exception being raised: no more.
=USES
For adding a call to the module test harness, by:
ó
store_mt_results[("theory check",
	theory_check_success,
	(),
	true)];
æ
=ENDDOC
\subsection{Require Functions}
Each of the following functions mirror some
theory declaration mechanisms, and will have, where
appropriate, the same arguments as those functions.
Thus the meaning of the arguments to the functions below should usually be
determined by seeing the description of the functions reflected.

Apart from error 35001 (``Theory name not declared''),
and 35030 (``Cannot open required theory'')
the $req\_$ functions should not give rise to errors
in ``check'' mode, though, for instance, if their arguments are parsed then their parsing may give parse errors.
=DOC
val âreq_nameá : string -> string OPT -> unit;
=DESCRIBE
$req\_name$ $tname$ $(Value$ $parent)$ declares the name of the theory being declared or checked.
In ``declare'' mode the 
function will open the theory $parent$,
and then the named theory, $tname$ will be used
as an argument to $new\_theory$ (q.v.), to give a ``clean''
area to attempt the declarations.
In ``check'' mode $tname$ will be used as an argument to
$open\_theory$ (q.v), and $parent$ added to the list of
declared parents.

The $parent$ argument is optional to allow the 
design of $min$, the only theory without a parent, to be made.
If the $parent$ argument is $Nil$ $req\_name$ will just attempt
to open the named theory, as $req\_name$ cannot create an 
initially parentless theory.
Apart from this case it is not possible to type-check the design of a theory
that is already present in the theory database.

This function must be called before any other $declare$ function
(otherwise they will give error message 35001), and may not be called more than once.
=FAILURE
35018	Cannot open parent theory ?0
35019	Cannot create a new theory ?0
35020	A theory name, ?0, has already been declared
35030	Cannot open required theory ?0
=ENDDOC
=DOC
val âreq_languageá : string -> unit;
=DESCRIBE
This requires the theory to have a particular language.
If not otherwise required the language defaults to being ``HOL''.
In ``declare'' mode the language is set as the language of the theory.
=FAILURE
35037	A language, ?0, has already been required
=ENDDOC
=DOC
val âreq_parentá : string -> unit;
=DESCRIBE
This declares the name of a parent to the theory.
In ``declare'' mode this will cause a call to $new\_parent$(q.v.).
Note that $req\_name$ declares an initial parent:
no additional call to $req\_parent$ should be made
for this parent name.
=FAILURE
35021	Cannot make ?0 a parent
=ENDDOC
=DOC
val âreq_constá : (string * TYPE) -> unit;
=DESCRIBE
This declares the name and type of a constant.
In ``declare'' mode this will cause a call to $new\_const$ (q.v).
=FAILURE
35022	Cannot make ?0 a constant
=ENDDOC
=DOC
val âreq_typeá : (string * int) -> unit;
=DESCRIBE
This declares the name and type of a type.
In ``declare'' mode this will cause a call to $new\_type$ (q.v).
=FAILURE
35038	Cannot make ?0 a type
=ENDDOC
=DOC
val âreq_axiomá : (string * SEQ) -> unit;
val âlist_req_axiomá : (string list * SEQ) -> unit;
=DESCRIBE
$req\_axiom$ declares the name and sequent of an axiom.
In ``declare'' mode this will check for duplication of keys:
summarize\_td\_results will manifest warnings of duplication
in ``check'' mode.
$list\_req\_axiom$ is used when an axiom is to be saved under 
more than one name.
=FAILURE
35023	Key ?0 already required for an axiom
35039	List of names may not be empty
=ENDDOC
=DOC
val âreq_defná : (string * SEQ) -> unit;
val âlist_req_defná : (string list * SEQ) -> unit;
=DESCRIBE
This declares the keys and sequent of a definition.
This function should be used for specifications and type definitions,
as well as ``simple'' definitions.
In ``declare'' mode this will check for duplication of keys:
summarize\_td\_results will manifest warnings of duplication
in ``check'' mode.
$list\_req\_defn$ is used when a definition is to be saved under 
more than one name.
=FAILURE
35024	Key ?0 already required for a definition
35039	List of names may not be empty
35040	A definition will not contain free variables, but ?0 are free in sequent
=ENDDOC
=DOC
val âreq_thmá : (string * SEQ) -> unit;
val âlist_req_thmá : (string list * SEQ) -> unit;
=DESCRIBE
This declares the key and sequent of a theorem.
In ``declare'' mode this will check for duplication of keys:
summarize\_td\_results will manifest warnings of duplication
in ``check'' mode.
$list\_req\_thm$ is used when a theorem is to be saved under 
more than one name.
=FAILURE
35025	Key ?0 already required for a theorem
35039	List of names may not be empty
=ENDDOC
=DOC
val âreq_binderá : string -> unit;
=DESCRIBE
This declares the name to have binder status.
In ``declare'' mode this makes a call to $declare\_binder$ (q.v), and will $pass\_on$(q.v) any error messages.
=FAILURE
35027	Name ?0 already required to have a fixity status
=ENDDOC
=DOC
val âreq_infixá : (int * string) -> unit;
=DESCRIBE
This declares the name to have infix status with
the noted precedence.
In ``declare'' mode this makes a call to $declare\_infix$ (q.v), and will $pass\_on$(q.v) any error messages.
=FAILURE
35027	Name ?0 already required to have a fixity status
=ENDDOC
=DOC
val âreq_nonfixá : string -> unit;
=DESCRIBE
This declares the name to have nonfix status.
In ``declare'' mode this makes a call to $declare\_nonfix$ (q.v.), and will $pass\_on$(q.v) any error messages.
By default any name not required to have a fixity status has the
status ``nonfix''.
=FAILURE
35027	Name ?0 already required to have a fixity status
=ENDDOC
=DOC
val âreq_prefixá : (int * string) -> unit;
=DESCRIBE
This declares the name to have prefix status with
the noted precedence.
In ``declare'' mode this makes a call to $declare\_prefix$ (q.v.), and will $pass\_on$(q.v) any error messages.
=FAILURE
35027	Name ?0 already required to have a fixity status
=ENDDOC
=DOC
val âreq_postfixá : (int * string) -> unit;
=DESCRIBE
This declares the name to have postfix status with
the noted precedence.
In ``declare'' mode this makes a call to $declare\_postfix$ (q.v), and will $pass\_on$(q.v) any error messages.
=FAILURE
35027	Name ?0 already required to have a fixity status
=ENDDOC
=DOC
val âreq_terminatorá : string -> unit;
=DESCRIBE
This declares the name to be a terminator.
In ``declare'' mode this makes a call to $declare\_terminator$ (q.v), and will $pass\_on$(q.v) any error messages.
Anything not declared to be a terminator is a non-terminator.
=FAILURE
35028	Name ?0 already required to be a terminator
20101	The string ?0 is not a valid terminator. Terminators must start
	with a symbolic character, must not contain spaces,
	and must not end with underscore, %up% or %down%
=ENDDOC
=DOC
val âreq_aliasá : (string * TERM) -> unit;
=DESCRIBE
This declares the name to be an alias for the given constant.
In ``declare'' mode this makes a call to $declare\_alias$ (q.v).
=FAILURE
35026	Name ?0 already required to be an alias
20301	The term ?0 is not a constant
20305	The constant ?0 is not in scope
=ENDDOC
=DOC
val âreq_type_abbrevá : (string * (string list * TYPE)) -> unit;
=DESCRIBE
This declares the name to be a type abbreviation for the given type.
In ``declare'' mode this makes a call to $declare\_type\_abbrev$ (q.v), and will $pass\_on$(q.v) any error messages.
=FAILURE
35029	Name ?0 already required to be a type abbreviation
20402	The identifier ?0 is already declared as a type constructor
20407	The formal parameter list ?0 contains duplicate type variable names
=FAILUREC
Note that message 20402 is a warning, from $declare\_type\_abbrev$.
=ENDDOC

\section{END OF THE SIGNATURE}
=SML
end; (* signature of TheoryDesignSupport *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested according to the criteria given in
\cite{DS/FMU/IED/PLN008}.
However, the functions are not part of the ICL HOL build,
though their correct functioning is important for the 
correct execution of the ICL HOL module tests.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
