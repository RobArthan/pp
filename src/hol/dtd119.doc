=IGN
********************************************************************************
dtd119.doc: this file is part of the PPHol system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex

\def\Title{ Quantifier Elimination Toolkit: Detailed Design }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document gives the detailed design for tools that assist in developing quantifier elimination procedures.}
\end{center}}

\def\Reference{LEMMA1/HOL/DTD119}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.25 $%
}
\def\Date{\FormatDate{$Date: 2007/05/16 15:23:37 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\newpage
\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1] First draft.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}

Lemma 1 build system.

\newpage

\section{Introduction}
\subsection{Scope}
This document gives the detailed design for various tools that assist in developing quantifier elimination procedures.

\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD011}.


\section{THE SIGNATURE}


=SML
signature ÛQuantElimToolsÝ = sig
=DOC
	val ÛFIRST_THEN_CÝ : (CONV * (CONV -> CONV)) list -> CONV;
=DESCRIBE
$FIRST\_THEN\_C$ takes a list of conversion-conversional pairs and gives which acts as follows:
the conversions in the klist are tried one after the other, and the process only fails if none of the conversions is applicable;
when a conversion succeeds, $FIRST\_THEN\_C$ is applied recursively to the remainder of the list as if by $X\_C\,FIRST\_THEN\_C$, where $X\_C$ is the conversional associated with the successful conversion.
The conversionals are intended to allow the process to be diverted into subterms of the result of a transformation.
For example, one might transform a unique existential quantification into an existential whose matrix contains a universal and then divert attention to the universal.
=ENDDOC
=DOC
	val ÛID_CÝ : CONV -> CONV;
=DESCRIBE
The identity conversional: $ID\_C\,conv$ is the same as $conv$.
This is for use with other conversionals such as $FIRST\_THEN\_C$, q.v.,
which take a conversional as an input.
=ENDDOC
=DOC
	val ÛINNERMOST_QUANT_CÝ : CONV -> CONV;
=DESCRIBE
$INNERMOST\_QUANT\_C$ is a conversional that maps its argument over the innermost quantified subterms of a term.
=ENDDOC
=DOC
	val ÛPROP_ATOM_CÝ : CONV -> CONV;
	val ÛPROP_LIT_CÝ : CONV -> CONV;
=DESCRIBE
$PROP\_ATOM\_C$ is a conversional that maps its argument over the outermost propositional atoms in a term.
$PROP\_LIT\_C$ maps its argument over the outermost propositional literals in a term.
Here a propositional atom is any term other than one formed using one of the propositional connectives ±, ², ´, ¤ or ³.
A propositional literal is either a propositional atom or the negation of a propositional atom.
=ENDDOC
=DOC
	val ÛQUANTS_CÝ : CONV -> CONV;
=DESCRIBE
$QUANTS\_C$ is a conversional that maps its argument over the matrix of each quantification in a nest of quantified terms, processing the innermost matrix first.
E.g.,
=INLINEFT
QUANTS_C conv ¬¶x·µy·x = y®
=TEX
\ applies $conv$ to $x = y$ and then to the resulting universally quantified subterm forming the converted matrix of the existential quantifier.
=ENDDOC
=DOC
	val ÛQUANT_CÝ : CONV -> CONV;
=DESCRIBE
$QUANT\_C$ is a conversional that applies its argument to the matrix of a quantified term.
=ENDDOC
=DOC
	val ÛQUANT_MAP_CÝ : CONV -> CONV;
=DESCRIBE
$QUANT\_MAP\_C$ is a conversional that maps a conversion over all the quantifiers in a term, innermost quantifiers first.
If the conversion succeeds it is retried, so it should fail if it cannot make any progress.
=ENDDOC
=DOC
	val Ûsimple_µ_³_¶_³_convÝ : CONV;
=DESCRIBE
This conversion proves theorems of the form
=INLINEFT
ô (µx·t) ¤ (³(¶x·³t))
=ENDDOC

=DOC
	val Ûdest_quantÝ : TERM -> TERM * TERM * TERM;
	val Ûis_quantÝ : TERM -> bool;
	val Ûmk_quantÝ : TERM * TERM * TERM -> TERM;
=DESCRIBE
These functions are the destructor, discriminator and constructor functions for quantified terms, i.e., boolean terms formed by applying a constant to a (possibly paired) $\lambda$-abstraction.
=FAILURE
119001	?0 is not a quantified term
=ENDDOC
=DOC
	val Ûfind_in_±_convÝ : (TERM -> bool) -> CONV;
=DESCRIBE
Given a function specifying a property of terms and an iterated conjunction,
=INLINEFT
a ± b ± c ± d
=TEX
, this conversion finds conjunct with the property, e.g., $c$
and ripples it up to the top:
=INLINEFT
c ± a ± b ± d
=TEX
.
It fails if there is nothing to do or if no operand satisfies the property.

=ENDDOC
=DOC
	val Ûnnf_convÝ : CONV;
=DESCRIBE
This conversion puts a propositional formula into negation normal form, i.e., the normal form in which ³ is pushed through the other propositional connectives and simplified using the following rules:
=GFT
	³(p1 ± p2) ¤ ³p1 ² ³p2	³(p1 ² p2) ¤ ³p1 ± ³p2
	³(p1 ´ p2) ¤ p1 ± ³p2	³(p1 ¤ p2) ¤ p1 ± ³p2 ² ³p1 ± p2
	(p1 ¤ p2) ¤ p1 ± p2 ² ³p1 ± ³p2	³(³p) ¤ p
	³T ¤ F	³F ¤ T
=ENDDOC
=DOC
	val Ûprop_simp_convÝ : CONV;
=DESCRIBE
This conversion simplifies propositional formula using the following rules:
=GFT
	³(³p) ¤ p		³F ¤ T	³T ¤ F
	F ² p ¤ p		p ² F ¤ p	T ² p ¤ T		p ² T ¤ T
	p ± F ¤ F		F ± p ¤ F	T ± p ¤ p		p ± T ¤ p
	p ´ T ¤ T		T ´ p ¤ p	F ´ p ¤ T		p ´ F ¤ ³p
	(p ¤ T) ¤ p		(T ¤ p) ¤ p	(F ¤ p) ¤ ³p	(p ¤ F) ¤ ³p
=ENDDOC
=DOC
	val Ûsimple_¶_const_elim_convÝ : CONV;
=DESCRIBE
This conversion proves all theorems of the form:
=INLINEFT
ô (¶x·p) ¤ p
=TEX
\ where the variable $x$ does not appear free in $p$.
=ENDDOC
=DOC
	val Ûsimple_one_point_convÝ : CONV;
=DESCRIBE
This conversion proves all theorems of the form:
=INLINEFT
ô (¶x·x = c ± p) ¤ p[c/x]
=TEX
\ where $p[c/x]$ denotes the result of substituting $c$ for occurrences of the variable $x$ in $p$.
=ENDDOC
=DOC
	val Ûsplit_±_convÝ : (TERM -> bool) -> CONV;
=DESCRIBE
Given a function specifying a property of terms and an iterated conjunction,
=INLINEFT
a ± b ± ...
=TEX
, this conversion splits it up in to the form:
=INLINEFT
(c ± d ± ...) ± (e ± f ± ...)
=TEX
, where $c, d, \ldots$ satisfy the property and $e, f, \ldots$ do not.
It fails there is nothing to do, i.e., if all the conjuncts satisfy the property, if none of the conjuncts satisfy the property or if the first conjunct satisfies the property and the others do not.
=ENDDOC
=SML
end (* of signature QuantElimTools *);
=TEX

\section{TEST POLICY}
There are no special module test requirements.
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}







