=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for the Derived Rules of Inference}  %% Mandatory field
\def\TPPheadtitle{Module Tests for the erived Rules of Inference}
\TPPref{DS/FMU/IED/MDT007}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
%\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
\TPPauthors{K.Blackburn & WIN01\\D.J.~King & WIN01}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the 
the abstract data type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue 1.1]
First draft version.
Primitive and built-in inference rules, and conversionals
all module tested.
\item [Issue 1.2]
Corrected test ``simple$\_$abs$\_$rule 6025'',
removed printing utilities (as unused),
and changed test theory names used.
\end{description}
\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the Derived Rules of Inference, required by ???.
The design is in \cite{DS/FMU/IED/DTD007}
and it is
implemented in \cite{DS/FMU/IED/IMP007}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD007},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD007},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP007}.
\subsubsection{Deficiencies}
The coverage of the tests, as called for by the test specification, may currently be incomplete.
\section{INITIALISATION}
Get a new theory to work in:
=SML
val start_theory = get_current_theory_name();
new_theory "test_mdt007";
=TEX
Initialise the test package:
=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results();
=TEX
\section{VALUE BINDINGS}
=SML
val v1 = mk_var("v1", BOOL);
val v2 = mk_var("v2", BOOL);
val tv1 = mk_vartype "'1";
val tv2 = mk_vartype "'2";
val tva = mk_vartype "'a";
val N0 = mk_Ü 0;
val N1 = mk_Ü 1;
val N2 = mk_Ü 2;
=TEX
Test scopes:
=SML
val Deleted = new_const ("Deleted",BOOL);
val const_deleted_thm = asm_rule ªp = qº;
val ignore_warnings = set_flag("ignore_warnings",true); 
val side_effect = delete_constant Deleted;
val side_effect = set_flag("ignore_warnings",ignore_warnings); 
val side_effect = new_theory "out_of_scope_mdt007";
val out_of_scope_thm = asm_rule ªp = qº;
val side_effect = open_theory "test_mdt007";
val side_effect = new_theory "deleted_theory_mdt007";
val del_theory_index = (string_of_int (icl'Kernel.icl'get_current_theory_name()));

val deleted_thm = asm_rule ªp = qº;
val side_effect = open_theory "test_mdt007";
val side_effect = delete_theory "deleted_theory_mdt007";

val p_eq_q_thm = asm_rule ªp = qº;
val pq_thm = asm_rule ªÑ p é qº;
val pq_ax = new_axiom("pq_ax", ªÑ p é qº);
val t_eq_f = asm_rule ªT = Fº;
val q_eq_F = new_axiom("q_eq_F",ªq = Fº);
val T = ªTº;
val F = ªFº;
val so_isso_axiom = new_axiom("so_isso_axiom", ªÑ So IsSo é So ä IsSoº);
val so_isso_def = new_specification(["So","IsSo"],2,so_isso_axiom);
val so_axiom = new_axiom("so_axiom",ªSoº);
val Ü = new_type("Ü",0) handle _ => Ü;
val tDiv = mk_const("Div",mk_fun(Ü,mk_fun(Ü,Ü)));
val tMod = mk_const("Mod",mk_fun(Ü,mk_fun(Ü,Ü)));
val Suc = new_const("Suc",mk_fun(Ü, Ü))
	handle _ => mk_const("Suc",mk_fun(Ü, Ü));

val strip_Ä_T_conv: CONV = ( fn (tm : TERM) =>
	if is_Ä tm
	then let val (p,q) = dest_Ä tm
		in
		if q = T
		then asm_rule(mk_eq (tm, p))
		else fail_with_conv "strip_Ä_T_conv" tm
	end
	else fail_with_conv "strip_Ä_T_conv" tm
);

val sample = ª(ç f x y é (f x Ä y) Ä (ç p é p) q)(ç x é å x) T ((ç p é p) q)º;
=TEX
\section{THE TESTS}
The tests proper:
\subsection{subst\_rule}
=SML
store_mt_results mt_run_fail[
	("subst_rule 6001 1",
	subst_rule [] ªÑ p é q1º,
	pq_thm,
	gen_fail_msg "subst_rule" 6001 []),
	("subst_rule 6001 2",
	subst_rule [(t_eq_f, ªq:BOOLº)] ªT = qº,
	t_eq_f,
	gen_fail_msg "subst_rule" 6001 []),
	("subst_rule 6036 1",
	subst_rule [] ªÑ p é qº,
	deleted_thm,
	gen_fail_msg "subst_rule" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("subst_rule 6065 1",
	subst_rule [] ªÑ p é qº,
	const_deleted_thm,
	gen_fail_msg "subst_rule" 6065 ["test_mdt007"]),
	("subst_rule 6066 1",
	subst_rule [] ªÑ p é qº,
	out_of_scope_thm,
	gen_fail_msg "subst_rule" 6066 ["out_of_scope_mdt007"]),
	("subst_rule 6036 2",
	subst_rule [(deleted_thm,ªq :'aº)] ªT = Fº,
	t_eq_f,
	gen_fail_msg "subst_rule" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("subst_rule 6065 2",
	subst_rule [(const_deleted_thm,ªq :'aº)] ªT = Fº,
	t_eq_f,
	gen_fail_msg "subst_rule" 6065 ["test_mdt007"]),
	("subst_rule 6066 2",
	subst_rule [(out_of_scope_thm,ªq :'aº)] ªT = Fº,
	t_eq_f,
	gen_fail_msg "subst_rule" 6066 ["out_of_scope_mdt007"])
	];

store_mt_results mt_run_fail [
	("subst_rule 6002",
	subst_rule,
	[(asm_rule T, ªp:BOOLº)],
	gen_fail_msg "subst_rule" 6002 []),
	("subst_rule 6003",
	subst_rule,
	[(t_def, ªTº)],
	gen_fail_msg "subst_rule" 6003 []),
	("subst_rule 6029",
	subst_rule,
	[(t_def, ªq : Üº)],
	gen_fail_msg "subst_rule" 6029 ["q"])
	];

store_mt_results mt_run [("subst_rule_1",
	dest_thm o subst_rule [] ªÑ p é qº,
	pq_thm,
	dest_thm pq_thm),
	("subst_rule_2",
	dest_thm o subst_rule [] ªÑ p1 é qº,
	pq_thm,
	([ªÑ p é qº],ªÑ p1 é qº)),
	("subst_rule_3",
	dest_thm o subst_rule [(t_eq_f, ªq : BOOLº)] ªq = Fº,
	t_eq_f,
	([ªT = Fº],ªF = Fº)),
	("subst_rule_4",
	dest_thm o subst_rule [(t_def, ªq : BOOLº)] ªq = Fº,
	t_eq_f,
	([ªT = Fº],ª((ç x:BOOLéx)=(ç x éx)) = Fº))];

=TEX
\subsection{simple\_abs\_rule}
=SML
store_mt_results mt_run [("simple_abs_rule",
	dest_thm o simple_abs_rule ªq : BOOLº,
	q_eq_F,
	([],ª(ç q:BOOL é q) = (ç q é F)º))
	];

store_mt_results mt_run_fail[
	("simple_abs_rule 6004",
	simple_abs_rule T,
	q_eq_F,
	gen_fail_msg "simple_abs_rule" 6004 []),
	("simple_abs_rule 6005",
	simple_abs_rule ªq : BOOLº,
	asm_rule ªq = Fº,
	gen_fail_msg "simple_abs_rule" 6005 ["q"]),
	("simple_abs_rule 6025",
	simple_abs_rule ªq : BOOLº,
	pq_ax,
	gen_fail_msg "simple_abs_rule" 6025 []),
	("simple_abs_rule 6036",
	simple_abs_rule ªq : BOOLº,
	deleted_thm,
	gen_fail_msg "simple_abs_rule" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("simple_abs_rule 6065",
	simple_abs_rule ªq : BOOLº,
	const_deleted_thm,
	gen_fail_msg "simple_abs_rule" 6065 ["test_mdt007"]),
	("simple_abs_rule 6066",
	simple_abs_rule ªq : BOOLº,
	out_of_scope_thm,
	gen_fail_msg "simple_abs_rule" 6066 ["out_of_scope_mdt007"])
	];
=TEX
\subsection{inst\_type\_rule}
So far unconverted tests:
=SML
store_mt_results mt_run [("inst_type_rule_1",
	dest_thm o inst_type_rule [(BOOL, tva)],
	pq_ax,
	([],ªÑ p : BOOL é qº)),
	("inst_type_rule_2",
	dest_thm o inst_type_rule [(BOOL, tv1)],
	pq_ax,
	([],ªÑ p : 'a é qº))
	];

store_mt_results mt_run_fail [
	("inst_type_rule 6006",
	inst_type_rule [(BOOL, tva)],
	(asm_rule ªv = vº),
	gen_fail_msg "inst_type_rule" 6006 ["'a"]),
	("inst_type_rule 6007",
	inst_type_rule [(BOOL, BOOL)],
	pq_ax,
	gen_fail_msg "inst_type_rule" 6007 []),
	("inst_type_rule 6036",
	inst_type_rule [(BOOL, tva)],
	deleted_thm,
	gen_fail_msg "inst_type_rule" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("inst_type_rule 6065",
	inst_type_rule [(BOOL, tva)],
	const_deleted_thm,
	gen_fail_msg "inst_type_rule" 6065 ["test_mdt007"]),
	("inst_type_rule 6066",
	inst_type_rule [(BOOL, tva)],
	out_of_scope_thm,
	gen_fail_msg "inst_type_rule" 6066 ["out_of_scope_mdt007"])
];
=TEX
\subsection{ä\_intro}
=SML
store_mt_results mt_run [
	("ä_intro_1",
	dest_thm o ä_intro v1,
	pq_ax,
	([],ªv1 ä Ñ p é qº)),
	("ä_intro_1",
	dest_thm o ä_intro v1,
	asm_rule v1,
	([],ªv1 ä v1º))
	];

store_mt_results mt_run_fail [
	("ä_intro 6009",
	ä_intro N1,
	pq_ax,
	gen_fail_msg "ä_intro" 6009 []),
	("ä_intro 6036",
	ä_intro v1,
	deleted_thm,
	gen_fail_msg "ä_intro" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("ä_intro 6065",
	ä_intro v1,
	const_deleted_thm,
	gen_fail_msg "ä_intro" 6065 ["test_mdt007"]),
	("ä_intro 6066",
	ä_intro v1,
	out_of_scope_thm,
	gen_fail_msg "ä_intro" 6066 ["out_of_scope_mdt007"])
	];
=TEX
\subsection{ä\_elim}
=SML
store_mt_results mt_run [("ä_elim_1",
	dest_thm o ä_elim  so_isso_def,
	so_axiom,
	([],ªIsSoº))
	];

store_mt_results mt_run_fail [
	("ä_elim 6010",
	ä_elim so_isso_axiom,
	so_axiom,
	gen_fail_msg "ä_elim" 6010 []),
	("ä_elim 6011",
	ä_elim so_isso_def,
	so_isso_def,
	gen_fail_msg "ä_elim" 6011 []),
	("ä_elim 6036 1",
	ä_elim so_isso_def,
	deleted_thm,
	gen_fail_msg "ä_elim" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("ä_elim 6065 1",
	ä_elim so_isso_def,
	const_deleted_thm,
	gen_fail_msg "ä_elim" 6065 ["test_mdt007"]),
	("ä_elim 6066 1",
	ä_elim so_isso_def,
	out_of_scope_thm,
	gen_fail_msg "ä_elim" 6066 ["out_of_scope_mdt007"]),
	("ä_elim 6036 2",
	ä_elim deleted_thm,
	so_axiom,
	gen_fail_msg "ä_elim" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("ä_elim 6065 2",
	ä_elim const_deleted_thm,
	so_axiom,
	gen_fail_msg "ä_elim" 6065 ["test_mdt007"]),
	("ä_elim 6066 2",
	ä_elim out_of_scope_thm,
	so_axiom,
	gen_fail_msg "ä_elim" 6066 ["out_of_scope_mdt007"])
	];
=TEX
\subsection{asm\_rule}
=SML
store_mt_results mt_run [
	("asm_rule 1",
	dest_thm o asm_rule,
	mk_const("rubbish",BOOL),
	([mk_const("rubbish",BOOL)],mk_const("rubbish",BOOL)))
	];

store_mt_results mt_run_fail [
	("asm_rule 6009",
	asm_rule,
	N0,
	gen_fail_msg "asm_rule" 6009 [])
	];
=TEX
\subsection{refl\_conv}
=SML
store_mt_results mt_run [
	("refl_conv 1",
	dest_thm o refl_conv,
	mk_const("rubbish",BOOL),
	([],mk_eq(mk_const("rubbish",BOOL), mk_const("rubbish",BOOL)))),
	("refl_conv 2",
	dest_thm o refl_conv,
	mk_const("rubbish",Ü),
	([],mk_eq(mk_const("rubbish",Ü), mk_const("rubbish",Ü))))
	];
=TEX
\subsection{simple\_$\beta$\_conv}
=SML
store_mt_results mt_run [
	("simple_%beta%_conv 1",
	dest_thm o simple_%beta%_conv,
	ª(ç p : 'a é f p) qº,
	([],ª((ç p : 'a é f p) q) = f qº)),
	("simple_%beta%_conv 2",
	dest_thm o simple_%beta%_conv,
	ª(ç p q: '1 é f p q) qº,
	([],ª((ç p q: '1 é f p q) q) = (ç q': '1 é f q q')º))
	];

store_mt_results mt_run_fail [
	("simple_%beta%_conv 6012",
	simple_%beta%_conv,
	ª(ç p q: '1 é f p q)º,
	gen_fail_msg "simple_%beta%_conv" 6012 [])
	];
=TEX
\subsection{suc\_conv}
=SML
store_mt_results mt_run [
	("suc_conv 1",
	dest_thm o suc_conv,
	ª3º,
	([],ª3 = Suc 2º))
	];

store_mt_results mt_run_fail [
	("suc_conv 6013",
	suc_conv,
	mk_const("Number",Ü),
	gen_fail_msg "suc_conv" 6013 []),
	("suc_conv 7100",
	suc_conv,
	ª0º,
	gen_fail_msg "suc_conv" 7100 [])
	];
=TEX
\subsection{string\_conv}
=SML
store_mt_results mt_run [
	("string_conv_1",
	dest_thm o string_conv,
	ª"abc"º,
	([],ª"abc" = ª%down%SML mk_const("Cons",
		mk_fun(CHAR,mk_fun(STRING,STRING)))º 
		ª%down%SML mk_char "a"º "bc"º)),
	("string_conv_2",
	dest_thm o string_conv,
	ª""º,
	([],ª"" = ª%down%SML mk_const("Nil",STRING)ºº))
	];

store_mt_results mt_run_fail [
	("string_conv 6014",
	string_conv,
	ª0º,
	gen_fail_msg "string_conv" 6014 [])
	];
=TEX
\subsection{char\_conv}
=SML
store_mt_results mt_run [
	("char_conv_1",
	dest_thm o char_conv,
	ª'aº,
	([],ª'a = ª%down%SML mk_const("AbsChar",mk_fun(Ü,CHAR))º 97º)),
	("char_conv_2",
	dest_thm o char_conv,
	mk_char "Ü",
	([],ªª%down%SML mk_char "Ü"º = 
		ª%down%SML mk_const("AbsChar",mk_fun(Ü,CHAR))º 134º))
	];

store_mt_results mt_run_fail [
	("char_conv 6015",
	char_conv,
	mk_const("he",CHAR),
	gen_fail_msg "char_conv" 6015 [])
	];

=TEX
\subsection{eq\_sym\_rule}
=SML
store_mt_results mt_run[
	("eq_sym_rule_1",
	dest_thm o eq_sym_rule,
	asm_ruleª0=1º,
	([ª0=1º],ª1=0º)),
	("eq_sym_rule_2",
	dest_thm o eq_sym_rule,
	asm_ruleªT=Fº,
	([ªT=Fº],ªF=Tº))
	];

store_mt_results mt_run_fail[
	("eq_sym_rule 6025",
	eq_sym_rule,
	pq_ax,
	gen_fail_msg "eq_sym_rule" 6025 []),
	("eq_sym_rule 6036",
	eq_sym_rule,
	deleted_thm,
	gen_fail_msg "eq_sym_rule" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("eq_sym_rule 6065",
	eq_sym_rule,
	const_deleted_thm,
	gen_fail_msg "eq_sym_rule" 6065 ["test_mdt007"]),
	("eq_sym_rule 6066",
	eq_sym_rule,
	out_of_scope_thm,
	gen_fail_msg "eq_sym_rule" 6066 ["out_of_scope_mdt007"])
	];
=TEX
\subsection{simple\_list\_É\_elim}
=SML
store_mt_results mt_run[
	("simple_list_É_elim_1",
	dest_thm o simple_list_É_elim [F],
	asm_rule ªÉ v1 é v1 ä Tº,
	([ªÉ v1 é v1 ä Tº],ªF ä Tº)),
	("simple_list_É_elim_2",
	dest_thm o simple_list_É_elim [ªv2 : BOOLº],
	asm_ruleªÉ v1 é (ç v2: BOOL é v1) Tº,
	([ªÉ v1 é (ç v2: BOOL é v1) Tº],ª(ç v2': BOOL é v2) T : BOOLº)),
	("simple_list_É_elim_3",
	dest_thm o simple_list_É_elim [ªv2 : BOOLº,ªv2 : BOOLº],
	asm_ruleªÉ v1 v2 é v1 Ä v2º,
	([ªÉ v1 v2 é v1 Ä v2º],ªv2 Ä v2º)),
	("simple_list_É_elim_4",
	dest_thm o simple_list_É_elim [ªv1 : BOOLº,ªv1 : BOOLº],
	asm_ruleªÉ v1 v2 é v1 Ä v2º,
	([ªÉ v1 v2 é v1 Ä v2º],ªv1 Ä v1º))
	];

store_mt_results mt_run_fail[
	("simple_list_É_elim 6018",
	simple_list_É_elim [T],
	pq_ax,
	gen_fail_msg "simple_list_É_elim" 6018 ["1"]),
	("simple_list_É_elim 6019",
	simple_list_É_elim [N0],
	asm_ruleªÉ v1 é v1 ä Tº,
	gen_fail_msg "simple_list_É_elim" 6019 ["v1 "]),
	("simple_list_É_elim 6036",
	simple_list_É_elim [v1],
	deleted_thm,
	gen_fail_msg "simple_list_É_elim" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("simple_list_É_elim 6065",
	simple_list_É_elim [v1],
	const_deleted_thm,
	gen_fail_msg "simple_list_É_elim" 6065 ["test_mdt007"]),
	("simple_list_É_elim 6066",
	simple_list_É_elim [v1],
	out_of_scope_thm,
	gen_fail_msg "simple_list_É_elim" 6066 ["out_of_scope_mdt007"])
	];
=TEX
\subsection{simple\_É\_elim}
=SML
store_mt_results mt_run[
	("simple_É_elim_1",
	dest_thm o simple_É_elim F,
	asm_rule ªÉ v1 é v1 ä Tº,
	([ªÉ v1 é v1 ä Tº],ªF ä Tº)),
	("simple_É_elim_2",
	dest_thm o simple_É_elim ªv2 : BOOLº,
	asm_ruleªÉ v1 é (ç v2: BOOL é v1) Tº,
	([ªÉ v1 é (ç v2: BOOL é v1) Tº],ª(ç v2': BOOL é v2) T : BOOLº))
	];

store_mt_results mt_run_fail[
	("simple_É_elim 7039",
	simple_É_elim T,
	pq_ax,
	gen_fail_msg "simple_É_elim" 7039 []),
	("simple_É_elim 7046",
	simple_É_elim N0,
	asm_ruleªÉ v1 é v1 ä Tº,
	gen_fail_msg "simple_É_elim" 7046 ["v1"]),
	("simple_É_elim 6036",
	simple_É_elim v1,
	deleted_thm,
	gen_fail_msg "simple_É_elim" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("simple_É_elim 6065",
	simple_É_elim v1,
	const_deleted_thm,
	gen_fail_msg "simple_É_elim" 6065 ["test_mdt007"]),
	("simple_É_elim 6066",
	simple_É_elim v1,
	out_of_scope_thm,
	gen_fail_msg "simple_É_elim" 6066 ["out_of_scope_mdt007"])
	];
=TEX
\subsection{eq\_trans\_rule}
=SML
store_mt_results mt_run[
	("eq_trans_rule_1",
	dest_thm o eq_trans_rule (asm_rule ª0=1º),
	asm_rule ª1 = 2º,
	([ª0=1º, ª1 = 2º],ª0 = 2º))
	];

store_mt_results mt_run_fail[
	("eq_trans_rule 6020",
	eq_trans_rule pq_ax,
	asm_ruleª1=2º,
	gen_fail_msg "eq_trans_rule" 6020 []),
	("eq_trans_rule 6021",
	eq_trans_rule (asm_ruleª1=2º),
	pq_ax,
	gen_fail_msg "eq_trans_rule" 6021 []),
	("eq_trans_rule 6022 a",
	eq_trans_rule (asm_rule ª0=1º),
	p_eq_q_thm,
	gen_fail_msg "eq_trans_rule" 6022 []),
	("eq_trans_rule 6022 b",
	eq_trans_rule (asm_rule ª0=1º),
	asm_rule ª0 = 2º,
	gen_fail_msg "eq_trans_rule" 6022 []),
	("eq_trans_rule 6036 a",
	eq_trans_rule so_isso_axiom,
	deleted_thm,
	gen_fail_msg "eq_trans_rule" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("eq_trans_rule 6065 a",
	eq_trans_rule so_isso_axiom,
	const_deleted_thm,
	gen_fail_msg "eq_trans_rule" 6065 ["test_mdt007"]),
	("eq_trans_rule 6066 a",
	eq_trans_rule so_isso_axiom,
	out_of_scope_thm,
	gen_fail_msg "eq_trans_rule" 6066 ["out_of_scope_mdt007"]),
	("eq_trans_rule 6036 b",
	eq_trans_rule deleted_thm,
	so_isso_axiom,
	gen_fail_msg "eq_trans_rule" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("eq_trans_rule 6065 b",
	eq_trans_rule const_deleted_thm,
	so_isso_axiom,
	gen_fail_msg "eq_trans_rule" 6065 ["test_mdt007"]),
	("eq_trans_rule 6066 b",
	eq_trans_rule out_of_scope_thm,
	so_isso_axiom,
	gen_fail_msg "eq_trans_rule" 6066 ["out_of_scope_mdt007"])
	];
=TEX
\subsection{mk\_comb\_rule}
=SML
store_mt_results mt_run[
	("mk_comb_rule_1",
	dest_thm o mk_comb_rule (asm_ruleª(f : Ü ã Ü) = gº),
	asm_rule ª1 = 2º,
	([ª(f : Ü ã Ü) = gº,ª1 = 2º],ª(f 1 : Ü) = g 2º))
	];

store_mt_results mt_run_fail[
	("mk_comb_rule 6020",
	mk_comb_rule pq_ax,
	asm_rule ª1 = 2º,
	gen_fail_msg "mk_comb_rule" 6020 []),
	("mk_comb_rule 6021",
	mk_comb_rule (asm_rule ª1=2º),
	pq_ax,
	gen_fail_msg "mk_comb_rule" 6021 []),
	("mk_comb_rule 6023 a",
	mk_comb_rule (refl_conv T ),
	(asm_rule ª1=2º),
	gen_fail_msg "mk_comb_rule" 6023 []),
	("mk_comb_rule 6023 b",
	mk_comb_rule (asm_rule ª0=1º),
	(asm_rule ª1=2º),
	gen_fail_msg "mk_comb_rule" 6023 []),
	("mk_comb_rule 6036 a",
	mk_comb_rule so_isso_axiom,
	deleted_thm,
	gen_fail_msg "mk_comb_rule" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("mk_comb_rule 6065 a",
	mk_comb_rule so_isso_axiom,
	const_deleted_thm,
	gen_fail_msg "mk_comb_rule" 6065 ["test_mdt007"]),
	("mk_comb_rule 6066 a",
	mk_comb_rule so_isso_axiom,
	out_of_scope_thm,
	gen_fail_msg "mk_comb_rule" 6066 ["out_of_scope_mdt007"]),
	("mk_comb_rule 6036 b",
	mk_comb_rule deleted_thm,
	so_isso_axiom,
	gen_fail_msg "mk_comb_rule" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("mk_comb_rule 6065 b",
	mk_comb_rule const_deleted_thm,
	so_isso_axiom,
	gen_fail_msg "mk_comb_rule" 6065 ["test_mdt007"]),
	("mk_comb_rule 6066 b",
	mk_comb_rule out_of_scope_thm,
	so_isso_axiom,
	gen_fail_msg "mk_comb_rule" 6066 ["out_of_scope_mdt007"])
	];
=TEX
\subsection{Ç\_mp\_rule}
=SML
store_mt_results mt_run[
	("Ç_mp_rule_1",
	dest_thm o Ç_mp_rule t_eq_f,
	asm_rule ªTº,
	([ªT = Fº,ªTº],ªFº))
	];

store_mt_results mt_run_fail[
	("Ç_mp_rule 6024",
	Ç_mp_rule t_eq_f,
	(asm_rule ªFº),
	gen_fail_msg "Ç_mp_rule" 6024 []),
	("Ç_mp_rule 6030",
	Ç_mp_rule (asm_rule ªTº),
	t_eq_f,
	gen_fail_msg "Ç_mp_rule" 6030 []),
	("Ç_mp_rule 6036 a",
	Ç_mp_rule so_isso_axiom,
	deleted_thm,
	gen_fail_msg "Ç_mp_rule" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("Ç_mp_rule 6065 a",
	Ç_mp_rule so_isso_axiom,
	const_deleted_thm,
	gen_fail_msg "Ç_mp_rule" 6065 ["test_mdt007"]),
	("Ç_mp_rule 6066 a",
	Ç_mp_rule so_isso_axiom,
	out_of_scope_thm,
	gen_fail_msg "Ç_mp_rule" 6066 ["out_of_scope_mdt007"]),
	("Ç_mp_rule 6036 b",
	Ç_mp_rule deleted_thm,
	so_isso_axiom,
	gen_fail_msg "Ç_mp_rule" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("Ç_mp_rule 6065 b",
	Ç_mp_rule const_deleted_thm,
	so_isso_axiom,
	gen_fail_msg "Ç_mp_rule" 6065 ["test_mdt007"]),
	("Ç_mp_rule 6066 b",
	Ç_mp_rule out_of_scope_thm,
	so_isso_axiom,
	gen_fail_msg "Ç_mp_rule" 6066 ["out_of_scope_mdt007"])
	];

=TEX
\subsection{simple\_É\_intro}
=SML
store_mt_results mt_run[
	("simple_É_intro_1",
	dest_thm o simple_É_intro v1,
	t_eq_f,
	([ªT = Fº],ªÉ v1 : BOOL é T = Fº)),
	("simple_É_intro_1",
	dest_thm o simple_É_intro ªq : BOOLº,
	pq_ax,
	([],ªÉ q : BOOL é Ñ p : 'a é qº))
	];

store_mt_results mt_run_fail[
	("simple_É_intro 6004",
	simple_É_intro T,
	t_eq_f,
	gen_fail_msg "simple_É_intro" 6004 []),
	("simple_É_intro 6005",
	simple_É_intro v1,
	(asm_rule v1),
	gen_fail_msg "simple_É_intro" 6005 ["v1"]),
	("simple_É_intro 6036",
	simple_É_intro v1,
	deleted_thm,
	gen_fail_msg "simple_É_intro" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("simple_É_intro 6065",
	simple_É_intro v1,
	const_deleted_thm,
	gen_fail_msg "simple_É_intro" 6065 ["test_mdt007"]),
	("simple_É_intro 6066",
	simple_É_intro v1,
	out_of_scope_thm,
	gen_fail_msg "simple_É_intro" 6066 ["out_of_scope_mdt007"])	];

=TEX
\subsection{inst\_term\_rule}
=SML
store_mt_results mt_run[
	("inst_term_rule_1",
	dest_thm o inst_term_rule [(T,v1),(F,v2)],
	simple_É_elim v2 
		(simple_É_elim v1 (
		(asm_rule ªÉ v1 v2 : BOOL é v1 = v2º))),
	([ªÉ v1 v2 : BOOL é v1 = v2º],ªT = Fº)),
	("inst_term_rule_2",
	dest_thm o inst_term_rule [(v2,v1),(v1,v2)],
	simple_É_elim v2 
		(simple_É_elim v1 (
		(asm_rule ªÉ v1 v2 : BOOL é v1 = v2º))),
	([ªÉ v1 v2 : BOOL é v1 = v2º],ª(v2:BOOL) = v1º)),
	("inst_term_rule_3",
	dest_thm o inst_term_rule [],
	simple_É_elim v2 
		(simple_É_elim v1 (
		(asm_rule ªÉ v1 v2 : BOOL é v1 = v2º))),
	([ªÉ v1 v2 : BOOL é v1 = v2º],ª(v1:BOOL) = v2º))
	];

store_mt_results mt_run_fail[
	("inst_term_rule 6026",
	inst_term_rule [(v2,T)],
	(asm_rule v1),
	gen_fail_msg "inst_term_rule" 6026 []),
	("inst_term_rule 6027",
	inst_term_rule [(N0,v1)],
	(asm_rule v1),
	gen_fail_msg "inst_term_rule" 6027 ["v1"]),
	("inst_term_rule 6028",
	inst_term_rule [(v2,v1)],
	(asm_rule v1),
	gen_fail_msg "inst_term_rule" 6028 ["v1"]),
	("inst_term_rule 6036",
	inst_term_rule [],
	deleted_thm,
	gen_fail_msg "inst_term_rule" 6036 ["deleted_theory_mdt007",del_theory_index]),
	("inst_term_rule 6065",
	inst_term_rule [],
	const_deleted_thm,
	gen_fail_msg "inst_term_rule" 6065 ["test_mdt007"]),
	("inst_term_rule 6066",
	inst_term_rule [],
	out_of_scope_thm,
	gen_fail_msg "inst_term_rule" 6066 ["out_of_scope_mdt007"])	];
=TEX
\subsection{div2\_conv}
=SML
store_mt_results mt_run [
	("div2_conv 1",
	dest_thm o div2_conv,
	list_mk_comb(tDiv,[ª7º,ª2º]),
	([],mk_eq(list_mk_comb(tDiv,[ª7º,ª2º]),ª3º))),
	("div2_conv 2",
	dest_thm o div2_conv,
	list_mk_comb(tDiv,[ª0º,ª2º]),
	([],mk_eq(list_mk_comb(tDiv,[ª0º,ª2º]),ª0º)))
	];

store_mt_results mt_run_fail [
	("div2_conv 6085 a",
	div2_conv,
	list_mk_comb(tDiv,[N0,N1]),
	gen_fail_msg "div2_conv" 6085 []),
	("div2_conv 6085 b",
	div2_conv,
	list_mk_comb(tDiv,[ªn : Üº,N2]),
	gen_fail_msg "div2_conv" 6085 [])
	];
=TEX
\subsection{mod2\_conv}
=SML
store_mt_results mt_run [
	("mod2_conv 1",
	dest_thm o mod2_conv,
	list_mk_comb(tMod,[ª7º,ª2º]),
	([],mk_eq(list_mk_comb(tMod,[ª7º,ª2º]),ª1º))),
	("mod2_conv 2",
	dest_thm o mod2_conv,
	list_mk_comb(tMod,[ª0º,ª2º]),
	([],mk_eq(list_mk_comb(tMod,[ª0º,ª2º]),ª0º)))
	];

store_mt_results mt_run_fail [
	("mod2_conv 6086 a",
	mod2_conv,
	list_mk_comb(tMod,[N0,N1]),
	gen_fail_msg "mod2_conv" 6086 []),
	("mod2_conv 6086 b",
	mod2_conv,
	list_mk_comb(tMod,[ªn : Üº,N2]),
	gen_fail_msg "mod2_conv" 6086 [])
	];
=TEX
\section{DERIVED INFERENCE RULES}
We will from now on assume that out of scope or invalid
theorems will have been properly handled, by being
caught by the interfaces to the primitive and built-in inference rules.
\subsection{ap\_fun\_rule}
=SML
store_mt_results mt_run [
	("ap_fun_rule",
	dest_thm o ap_fun_rule ªf : Ü ã Üº,
	asm_rule ª 0 = 1 º,
	([ª 0 = 1 º], ª (f 0 : Ü) = f 1 º))
	];

store_mt_results mt_run_fail [
	("ap_fun_rule 7023",
	ap_fun_rule  ªf : Ü ã Üº,
	pq_ax,
	gen_fail_msg "ap_fun_rule" 7023 []),
	("ap_fun_rule 7024",
	ap_fun_rule  ªf : Ü ã Üº,
	t_eq_f,
	gen_fail_msg "ap_fun_rule" 7024 [])
	];

=TEX
\subsection{ap\_arg\_rule}
=SML
store_mt_results mt_run [
	("ap_arg_rule",
	dest_thm o ap_arg_rule ª2º,
	asm_rule ª (f : Ü ã Ü)  = gº,
	([ª (f : Ü ã Ü)  = gº], ª (f 2 : Ü) = g 2 º))
	];

store_mt_results mt_run_fail [
	("ap_arg_rule 7023",
	ap_arg_rule  ª2º,
	pq_ax,
	gen_fail_msg "ap_arg_rule" 7023 []),
	("ap_arg_rule 7025",
	ap_arg_rule  ªf : Ü ã Üº,
	t_eq_f,
	gen_fail_msg "ap_arg_rule" 7025 [])
	];

=TEX
\section{CONVERSIONS AND CONVERSIONALS}
\subsection{fail\_conv}
=SML
store_mt_results mt_run_fail [
	("fail_conv",
	fail_conv,
	T,
	gen_fail_msg "fail_conv" 7061 [])
	];

=TEX
\subsection{fail\_with\_conv}
=SML
store_mt_results mt_run_fail [
	("fail_with_conv",
	fail_with_conv "testing",
	T,
	gen_fail_msg "fail_with_conv" 7075 ["testing"])
	];
=TEX
\subsection{THEN\_C}
=SML
store_mt_results mt_run [
	("THEN_C",
	dest_thm o suc_conv THEN_C (RAND_C suc_conv),
	ª3º,
	([],ª3 = Suc(Suc 1)º))
	];

store_mt_results mt_run_fail [
	("THEN_C 7101",
	(fn x => pq_ax) THEN_C suc_conv,
	ª3º,
	gen_fail_msg "THEN_C" 7101 []),
	("THEN_C 7102",
	suc_conv THEN_C (fn x => pq_ax),
	ª3º,
	gen_fail_msg "THEN_C" 7102 []),
	("THEN_C 1st fails",
	(fail_with_conv "testing THEN_C") THEN_C suc_conv,
	ª3º,
	gen_fail_msg "fail_with_conv" 7075 ["testing THEN_C"]),
	("THEN_C 2nd fails",
	suc_conv THEN_C (fail_with_conv "testing THEN_C"),
	ª3º,
	gen_fail_msg "fail_with_conv" 7075 ["testing THEN_C"])
	];

=TEX
\subsection{FURTHER\_C}
=SML
store_mt_results mt_run [
	("FURTHER_C a",
	dest_thm o suc_conv FURTHER_C (RAND_C suc_conv),
	ª3º,
	([],ª3 = Suc(Suc 1)º)),
	("FURTHER_C b",
	dest_thm o suc_conv FURTHER_C (fail_with_conv "testing FURTHER_C"),
	ª3º,
	([],ª3 = Suc 2º)),
	("FURTHER_C c",
	dest_thm o suc_conv FURTHER_C (fn x => pq_ax),
	ª3º,
	([],ª3 = Suc 2º)),
	("FURTHER_C d",
	dest_thm o (fn x => pq_ax) FURTHER_C suc_conv,
	ª3º,
	([],ªÑ p : 'a é qº))
	];

store_mt_results mt_run_fail [
	("FURTHER_C 1st fails",
	(fail_with_conv "testing FURTHER_C") FURTHER_C suc_conv,
	ª3º,
	gen_fail_msg "fail_with_conv" 7075 ["testing FURTHER_C"])
	];

=TEX
\subsection{ORELSE\_C}
=SML
store_mt_results mt_run [
	("ORELSE_C a",
	dest_thm o suc_conv ORELSE_C refl_conv,
	ª3º,
	([],ª3 = Suc 2º)),
	("ORELSE_C b",
	dest_thm o (fail_with_conv "testing ORELSE_C") ORELSE_C suc_conv,
	ª3º,
	([],ª3 = Suc 2º))
	];

store_mt_results mt_run_fail [
	("ORELSE_C both fail",
	(fail_with_conv "testing ORELSE_C a") ORELSE_C 
		(fail_with_conv "testing ORELSE_C b"),
	ª3º,
	gen_fail_msg "fail_with_conv" 7075 ["testing ORELSE_C b"])
	];

=TEX
\subsection{EITHER\_C}
=SML
store_mt_results mt_run [
	("EITHER_C a",
	dest_thm o suc_conv EITHER_C (RAND_C suc_conv),
	ª3º,
	([],ª3 = Suc(Suc 1)º)),
	("EITHER_C b",
	dest_thm o suc_conv EITHER_C (fail_with_conv "testing EITHER_C"),
	ª3º,
	([],ª3 = Suc 2º)),
	("EITHER_C c",
	dest_thm o suc_conv EITHER_C (fn x => pq_ax),
	ª3º,
	([],ª3 = Suc 2º)),
	("EITHER_C d",
	dest_thm o (fn x => pq_ax) EITHER_C suc_conv,
	ª3º,
	([],ªÑ p : 'a é qº)),
	("EITHER_C e",
	dest_thm o (fail_with_conv "testing EITHER_C") EITHER_C suc_conv,
	ª3º,
	([],ª3 = Suc 2º))
	];

store_mt_results mt_run_fail [
	("EITHER_C both fail",
	(fail_with_conv "testing EITHER_C a") EITHER_C 
		(fail_with_conv "testing EITHER_C b"),
	ª3º,
	gen_fail_msg "fail_with_conv" 7075 ["testing EITHER_C b"])
	];

=TEX
\subsection{REPEAT\_C}
=SML
store_mt_results mt_run [
	("REPEAT_C a",
	dest_thm o REPEAT_C strip_Ä_T_conv,
	ª((a Ä T) Ä T) Ä Tº,
	([ª(((a Ä T) Ä T) Ä T) = ((a Ä T) Ä T)º,
		ª((a Ä T) Ä T) = (a Ä T)º,
		ª(a Ä T) = aº],
	ª(((a Ä T) Ä T) Ä T) = aº)),
	("REPEAT_C b",
	dest_thm o REPEAT_C strip_Ä_T_conv,
	ªa: BOOLº,
	([],ª(a:BOOL) = aº))	
	];

=TEX
\subsection{REPEAT1\_C}
=SML
store_mt_results mt_run [
	("REPEAT1_C",
	dest_thm o REPEAT1_C strip_Ä_T_conv,
	ª((a Ä T) Ä T) Ä Tº,
	([ª(((a Ä T) Ä T) Ä T) = ((a Ä T) Ä T)º,
		ª((a Ä T) Ä T) = (a Ä T)º,
		ª(a Ä T) = aº],
	ª(((a Ä T) Ä T) Ä T) = aº))
	];

store_mt_results mt_run_fail [
	("REPEAT1_C 7075",
	REPEAT1_C strip_Ä_T_conv,
	ªa : BOOLº,
	gen_fail_msg "fail_with_conv" 7075 ["strip_Ä_T_conv"])
	];

=TEX
\subsection{LIST\_THEN\_C}
=SML
store_mt_results mt_run [
	("EVERY_C a",
	dest_thm o EVERY_C [strip_Ä_T_conv],
	ª((a Ä T) Ä T) Ä Tº,
	([ª(((a Ä T) Ä T) Ä T) = ((a Ä T) Ä T)º],
	ª(((a Ä T) Ä T) Ä T) = ((a Ä T) Ä T)º)),
	("EVERY_C b",
	dest_thm o EVERY_C [strip_Ä_T_conv, strip_Ä_T_conv, strip_Ä_T_conv],
	ª((a Ä T) Ä T) Ä Tº,
	([ª(((a Ä T) Ä T) Ä T) = ((a Ä T) Ä T)º,
		ª((a Ä T) Ä T) = (a Ä T)º,
		ª(a Ä T) = aº],
	ª(((a Ä T) Ä T) Ä T) = aº))
	];

store_mt_results mt_run_fail [
	("EVERY_C too many",
	EVERY_C [strip_Ä_T_conv, strip_Ä_T_conv, 
		strip_Ä_T_conv, strip_Ä_T_conv],
	ª((a Ä T) Ä T) Ä Tº,
	gen_fail_msg "fail_with_conv" 7075 ["strip_Ä_T_conv"]),
	("EVERY_C one fails",
	EVERY_C [strip_Ä_T_conv, strip_Ä_T_conv, 
		fail_with_conv "testing EVERY_C", strip_Ä_T_conv],
	ª((a Ä T) Ä T) Ä Tº,
	gen_fail_msg "fail_with_conv" 7075 ["testing EVERY_C"])
	];

store_mt_results mt_run_fail[
	("EVERY_C 7103",
	EVERY_C,
	[],
	gen_fail_msg "EVERY_C" 7103 [])
	];
=TEX
\subsection{LIST\_ORELSE\_C}
=SML
store_mt_results mt_run [
	("FIRST_C a",
	dest_thm o FIRST_C [strip_Ä_T_conv],
	ª((a Ä T) Ä T) Ä Tº,
	([ª(((a Ä T) Ä T) Ä T) = ((a Ä T) Ä T)º],
	ª(((a Ä T) Ä T) Ä T) = ((a Ä T) Ä T)º)),
	("FIRST_C b",
	dest_thm o FIRST_C [strip_Ä_T_conv, strip_Ä_T_conv, strip_Ä_T_conv],
	ª((a Ä T) Ä T) Ä Tº,
	([ª(((a Ä T) Ä T) Ä T) = ((a Ä T) Ä T)º],
	ª(((a Ä T) Ä T) Ä T) = ((a Ä T) Ä T)º)),
	("FIRST_C c",
	dest_thm o FIRST_C [strip_Ä_T_conv,
		fail_with_conv "testing FIRST_C"],
	ª((a Ä T) Ä T) Ä Tº,
	([ª(((a Ä T) Ä T) Ä T) = ((a Ä T) Ä T)º],
	ª(((a Ä T) Ä T) Ä T) = ((a Ä T) Ä T)º))
	];

store_mt_results mt_run_fail[
	("FIRST_C 7103",
	FIRST_C,
	[],
	gen_fail_msg "FIRST_C" 7103 [])
	];
=TEX
\subsection{CHANGED\_C}
=SML
store_mt_results mt_run [
	("CHANGED_C",
	dest_thm o CHANGED_C suc_conv,
	ª3º,
	([],ª3 = Suc 2º))
	];

store_mt_results mt_run_fail [
	("CHANGED_C 7032",
	CHANGED_C refl_conv,
	ª3º,
	gen_fail_msg "CHANGED_C" 7032 []),
	("CHANGED_C 7104",
	CHANGED_C (fn x => pq_ax),
	ª3º,
	gen_fail_msg "CHANGED_C" 7104 [])
	];

=TEX
\subsection{TRY\_C}
=SML
store_mt_results mt_run [
	("TRY_C a",
	dest_thm o TRY_C suc_conv,
	ª3º,
	([],ª3 = Suc 2º)),
	("TRY_C a",
	dest_thm o TRY_C fail_conv,
	ª3º,
	([],ª3 = 3º))
	];

=TEX
\subsection{RAND\_C}
=SML
store_mt_results mt_run [
	("RAND_C",
	dest_thm o RAND_C suc_conv,
	ªSuc 3º,
	([],ªSuc 3 = Suc(Suc 2)º))
	];

store_mt_results mt_run_fail [
	("RAND_C conv fails",
	RAND_C (fail_with_conv "testing RAND_C"),
	ªSuc 3º,
	gen_fail_msg "fail_with_conv" 7075 ["testing RAND_C"]),
	("RAND_C conv 7045",
	RAND_C suc_conv,
	ª3º,
	gen_fail_msg "RAND_C" 7045 []),
	("RAND_C conv 7104",
	RAND_C (fn x => pq_ax),
	ªSuc 3º,
	gen_fail_msg "RAND_C" 7104 [])
	];
	
=TEX
\subsection{RATOR\_C}
=SML
store_mt_results mt_run [
	("RATOR_C",
	dest_thm o RATOR_C simple_%beta%_conv,
	ª(ç x y : Ü é plus x y) 3 4 : Üº,
	([],ª(ç x y : Ü é plus x y) 3 4  = ((ç y : Ü é plus 3 y) 4 : Ü)º))
	];

store_mt_results mt_run_fail [
	("RATOR_C conv fails",
	RATOR_C (fail_with_conv "testing RATOR_C"),
	ªSuc 3º,
	gen_fail_msg "fail_with_conv" 7075 ["testing RATOR_C"]),
	("RATOR_C conv 7045",
	RATOR_C suc_conv,
	ª3º,
	gen_fail_msg "RATOR_C" 7045 []),
	("RATOR_C conv 7104",
	RATOR_C (fn x => pq_ax),
	ªSuc 3º,
	gen_fail_msg "RATOR_C" 7104 [])
	];
	
=TEX
\subsection{ABS\_C}
=SML
store_mt_results mt_run [
	("ABS_C",
	dest_thm o ABS_C suc_conv,
	ªç x é 3º,
	([],ª(ç x é 3) = (ç x é Suc 2)º))
	];

store_mt_results mt_run_fail [
	("ABS_C conv fails",
	ABS_C (fail_with_conv "testing ABS_C"),
	ªç x é Suc 3º,
	gen_fail_msg "fail_with_conv" 7075 ["testing ABS_C"]),
	("ABS_C conv 7030",
	ABS_C suc_conv,
	ª3º,
	gen_fail_msg "ABS_C" 7030 []),
	("ABS_C conv 7104",
	ABS_C (fn x => pq_ax),
	ªç x é Suc 3º,
	gen_fail_msg "ABS_C" 7104 [])
	];

=TEX
\subsection{BINDER\_C}
=SML
store_mt_results mt_run [
	("BINDER_C",
	dest_thm o BINDER_C (RAND_C suc_conv),
	ªÉ x é x = 3º ,
	([],ª(É x é x = 3) = (É x é x = Suc 2)º))
	];

store_mt_results mt_run_fail [
	("BINDER_C conv fails",
	BINDER_C (fail_with_conv "testing BINDER_C"),
	ªÉ x é x = 3º,
	gen_fail_msg "fail_with_conv" 7075 ["testing BINDER_C"]),
	("BINDER_C conv 7059",
	BINDER_C suc_conv,
	ª3º,
	gen_fail_msg "BINDER_C" 7059 []),
	("BINDER_C conv 7104",
	BINDER_C (fn x => pq_ax),
	ªÉ x é x = 3º,
	gen_fail_msg "BINDER_C" 7104 [])
	];

=TEX
\subsection{SUB\_C}
=SML
store_mt_results mt_run [
	("SUB_C a",
	dest_thm o SUB_C suc_conv,
	v1,
	([],ª(v1:BOOL) = v1º)),
	("SUB_C b",
	dest_thm o SUB_C suc_conv,
	T,
	([],ªT = Tº)),
	("SUB_C c",
	dest_thm o SUB_C suc_conv,
	ªf 3º,
	([],ªf 3 = f (Suc 2)º)),
	("SUB_C d",
	dest_thm o SUB_C (RAND_C suc_conv),
	ªf 3 4º,
	([],ªf 3 4 = f (Suc 2) 4º)),
	("SUB_C e",
	dest_thm o SUB_C (RAND_C suc_conv ORELSE_C suc_conv),
	ªf 3 4º,
	([],ªf 3 4 = f (Suc 2) (Suc 3)º)),
	("SUB_C f",
	dest_thm o SUB_C suc_conv,
	ªç x é 3º,
	([],ª(ç x é 3) = (ç x é (Suc 2))º)),
	("SUB_C g",
	dest_thm o SUB_C (fail_with_conv "testing SUB_C"),
	ªf x : BOOLº,
	([],ª(f x : BOOL) = (f x)º)),
	("SUB_C h",
	dest_thm o SUB_C (fn x => pq_ax),
	ªf x : BOOLº,
	([],ª(f x : BOOL) = (f x)º))
	];
=TEX
\subsection{SUB1\_C}
=SML
store_mt_results mt_run [
	("SUB1_C a",
	dest_thm o SUB1_C suc_conv,
	ªf 3º,
	([],ªf 3 = f (Suc 2)º)),
	("SUB1_C b",
	dest_thm o SUB1_C (RAND_C suc_conv),
	ªf 3 4º,
	([],ªf 3 4 = f (Suc 2) 4º)),
	("SUB1_C c",
	dest_thm o SUB1_C (RAND_C suc_conv ORELSE_C suc_conv),
	ªf 3 4º,
	([],ªf 3 4 = f (Suc 2) (Suc 3)º)),
	("SUB1_C d",
	dest_thm o SUB1_C suc_conv,
	ªç x é 3º,
	([],ª(ç x é 3) = (ç x é (Suc 2))º)),
	("SUB1_C e",
	dest_thm o SUB1_C (fn x => if is_comb x
		then pq_ax
		else suc_conv x),
	ªf 3 4º,
	([],ªf 3 4 = f 3 (Suc 3)º))
	];

store_mt_results mt_run_fail [
	("SUB1_C 7104 a",
	SUB1_C (fn x => pq_ax),
	ªf 3º,
	gen_fail_msg "SUB1_C" 7104 []),
	("SUB1_C 7104 b",
	SUB1_C (RAND_C (fn x => pq_ax) ORELSE_C (fn x => pq_ax)),
	ªf 3 4º,
	gen_fail_msg "SUB1_C" 7104 []),
	("SUB1_C 7104 c",
	SUB1_C (fn x => pq_ax),
	ªç x é 3º,
	gen_fail_msg "SUB1_C" 7104 []),
	("SUB1_C 7105 a",
	SUB1_C suc_conv,
	v1,
	gen_fail_msg "SUB1_C" 7105 []),
	("SUB1_C 7105 b",
	SUB1_C suc_conv,
	T,
	gen_fail_msg "SUB1_C" 7105 []),
	("SUB1_C conv fails",
	SUB1_C (fail_with_conv "testing SUB1_C"),
	ªf xº,
	gen_fail_msg "fail_with_conv" 7075 ["testing SUB1_C"])
	];
=TEX
\subsection{ONCE\_TRAVERSE\_C}
=SML
store_mt_results mt_run [
	("ONCE_TRAVERSE_C",
	dest_thm o ONCE_TRAVERSE_C simple_%beta%_conv,
	sample,
	([],mk_eq(sample,
	ª(ç x y é ((ç x é å x) x Ä y) Ä (ç p é p) q) T qº)))
	];
=TEX
The failure message if a conversion applies nowhere is
a bit non-deterministic.
=SML
store_mt_results mt_run_fail [
	("ONCE_TRAVERSE_C cnv fails everywhere",
	ONCE_TRAVERSE_C (fail_with_conv "testing ONCE_TRAVERSE_C"),
	sample,
	gen_fail_msg "SUB1_C" 7105 [])
	];
=TEX
\subsection{TRAVERSE\_C}
=SML
store_mt_results mt_run [
	("TRAVERSE_C",
	dest_thm o TRAVERSE_C simple_%beta%_conv,
	sample,
	([],mk_eq(sample,
	ª((ç x é å x) T Ä q) Ä qº)))
	];
=TEX
The failure message if a conversion applies nowhere is
a bit non-deterministic.
=SML
store_mt_results mt_run_fail [
	("TRAVERSE_C cnv fails everywhere",
	TRAVERSE_C (fail_with_conv "testing TRAVERSE_C"),
	sample,
	gen_fail_msg "fail_with_conv" 7075 ["testing TRAVERSE_C"])
	];
=TEX
\subsection{REPEAT\_TRAVERSE\_C}
=SML
store_mt_results mt_run [
	("REPEAT_TRAVERSE_C",
	dest_thm o REPEAT_TRAVERSE_C simple_%beta%_conv,
	sample,
	([],mk_eq(sample,
	ª((å T) Ä q) Ä qº)))
	];
=TEX
The failure message if a conversion applies nowhere is
a bit non-deterministic.
=SML
store_mt_results mt_run_fail [
	("REPEAT_TRAVERSE_C cnv fails everywhere",
	REPEAT_TRAVERSE_C (fail_with_conv "testing REPEAT_TRAVERSE_C"),
	sample,
	gen_fail_msg "fail_with_conv" 7075 ["testing REPEAT_TRAVERSE_C"])
	];
=TEX
\subsection{TOP\_TRAVERSE\_C}
=SML
store_mt_results mt_run [
	("TOP_TRAVERSE_C",
	dest_thm o TOP_TRAVERSE_C simple_%beta%_conv,
	sample,
	([],mk_eq(sample,
	ª(ç x y é ((å x) Ä y) Ä q) T qº)))
	];
=TEX
The failure message if a conversion applies nowhere is
a bit non-deterministic.
=SML
store_mt_results mt_run_fail [
	("TOP_TRAVERSE_C cnv fails everywhere",
	TOP_TRAVERSE_C (fail_with_conv "testing TOP_TRAVERSE_C"),
	sample,
	gen_fail_msg "SUB1_C" 7105 [])
	];
=TEX
\subsection{conv\_rule}
=SML
store_mt_results mt_run [
	("conv_rule",
	dest_thm o conv_rule (REPEAT_TRAVERSE_C suc_conv),
	div2_conv (list_mk_comb(tDiv,[ª3º,ª2º])),
	([],mk_eq(list_mk_comb(tDiv,[ªSuc(Suc(Suc 0))º,ª(Suc(Suc 0))º]),
		ªSuc 0º)))
	];

store_mt_results mt_run_fail [
	("conv_rule 7104",
	conv_rule (fn x => pq_ax),
	asm_rule T,
	gen_fail_msg "conv_rule" 7104 []),
	("conv_rule cnv fails",
	conv_rule (fail_with_conv "testing conv_rule"),
	asm_rule T,
	gen_fail_msg "fail_with_conv" 7075 ["testing conv_rule"])
	];

=TEX
\section{END OF TESTS}
=SML
summarize_mt_results();
=TEX
Undo theory creation, etc
=SML
(*
open_theory start_theory;
delete_theory "out_of_scope_mdt007";
delete_theory "test_mdt007";
*)
(* PolyML.quit(); *)
=TEX
\section{UNTESTED ERROR MESSAGES}
The following are not tested for various reasons:

\begin{tabular}{| l | p{4.5in} |}\hline
Test & Comment \\ \hline
\hline
\end{tabular}
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
=TEX
\end{document}
