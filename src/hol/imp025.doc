% imp025.doc   %Z% $Date$ $Revision$ $RCSfile$

=TEX
% imp025.doc   %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol1,11pt,TQ]{article}

\TPPtitle{Implementation of Pretty Printer}
\TPPref{DS/FMU/IED/IMP025}
\def\SCCSissue{$Revision$%
}
\TPPissue{\SCCSissue}
\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{FST PROJECT}

=IGN

Commands to process this document in various ways.

make -f rel001.mkf imp025.dvi
doc4tex imp025
tex4dvi imp025
bibtex imp025
doc4tex imp025 ; tex4dvi imp025
doc4tex imp025 ; tex4dvi imp025 ; bibtex imp025
dvipage imp025 &

doc4errors imp025
use_file "imp025.sml";

lasp -s imp025.doc > zz1
lasp -s -u imp025.OKwords imp025.doc > zz1

=TEX
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{SML Literate Script}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the user interface to
	the pretty printer.  It also installs the pretty printing
	functions into the PolyML printer.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

%\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

%********************************************************************

\subsection{Contents List}
\tableofcontents
% \listoftables

%********************************************************************

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

%********************************************************************

\subsection{Changes History}

\begin{description}

\item[Issue 1.1 to 1.10 ] Initial drafts.

\item[\FormatDate{91/09/12}, issue 2.1 ] First approved issue.

\item[Issue 2.2, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 2.3 (13th April 1992)]
Changes due to CR0017.

%\item[\FormatDate{$Date$%
%}, issue \SCCSissue~]

\end{description}

%********************************************************************

%\subsection{Changes Forecast} \label{ChangesForecast}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the pretty printer for the ICL HOL system, it
implements the interfaces defined in the detailed design
in~\cite{DS/FMU/IED/DTD025}.

%********************************************************************

\subsection{Introduction}

%--------------------------------------------------------------------

\subsubsection{Purpose and Background}

A number of interfaces are required in ICL~HOL for printing out types,
terms and theorems.  The functions in signature $PrettyPrinter$ provide
the functions needed by the users of the pretty printer, these allow a
user to obtain textual forms of types, terms and theorems in
Standard~ML strings.  Another group of functions interface to the
PolyML pretty printing system so that type, term and theorem values are
printed correctly as (parts of) Standard~ML values shown at top-level.

%--------------------------------------------------------------------

\subsubsection{Dependencies}

This is last of the four structures that together form the HOL pretty
printer.  This document depends upon the other three structures:
Oppen style printing~\cite{DS/FMU/IED/IMP024};
pretty printer support~\cite{DS/FMU/IED/IMP031};
and,
HOL pretty printer functions~\cite{DS/FMU/IED/IMP032}.

%--------------------------------------------------------------------

%\subsubsection{Interface}
%\subsubsection{Algorithms}
%\subsubsection{Possible Enhancements}

%--------------------------------------------------------------------

%\subsubsection{Deficiencies}

%--------------------------------------------------------------------

%\subsubsection{Terminology}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{PRETTY PRINTER}

%********************************************************************

\subsection{Prelude}

=SML
structure ÛPrettyPrinterÝ : PrettyPrinter = struct

open OppenFormatting;
open PrettyPrinterSupport;
open HOLPrettyPrinter;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{CALLED INTERFACE FOR PRINTERS}

These functions are the outermost printing functions for the supported
types.  They all produce a textual form of their main argument by using
the set of Oppen printing functions provided as another argument.

%********************************************************************

\subsection{Types}

At present there is no support for printing types in languages other
than HOL.  All HOL types (i.e., of Standard~ML type $TYPE$) are printed
out using the HOL syntax.

=SML
fun Ûshow_typeÝ (add_language:bool) (oppen_funs:OPPEN_FUNS) (ty:TYPE) : unit = (
	let
		val lang ="HOL:";

		val env = initial_env lang oppen_funs;
	in
		if add_language then start_new_language env lang else ();
		main_type_pp env ty;
		if add_language then conclude_new_language env lang else ()
	end
);
=TEX

%********************************************************************

\subsection{Terms}

The first task when printing terms is to determine which language to
use.  A simple algorithm is used here: if the outermost construct in
the term is a constant applied to a list of arguments then the language
of that constant is chosen, in all other cases ``HOL'' is chosen.

{\hfuzz 1pt
=SML
fun Ûshow_term_inÝ (lang:string) (add_language:bool) (oppen_funs:OPPEN_FUNS)
			(tm:TERM) : unit = (
	let
		val env = initial_env lang oppen_funs;
	in
		if add_language then start_new_language env lang else ();
		main_term_pp env tm;
		if add_language then conclude_new_language env lang else ()
	end
);
=TEX
}

=SML
fun Ûshow_termÝ (add_language:bool) (oppen_funs:OPPEN_FUNS) (tm:TERM) : unit = (
	let
		val lang =	case get_first_const tm
				of Value name => get_const_language name
				| Nil => "HOL";

		val enclose = add_language orelse 
			(get_current_language()) <> lang;
	in
		show_term_in lang enclose oppen_funs tm
	end
);
=TEX

%********************************************************************

\subsection{Theorems}

Theorems are considered to be a series of terms, each of which is
printed in isolation but without any language start and end symbols.
The complexity here comes from getting the correct spacing and
indentation.  Assumptions and conclusions should be consistently
spaced, but the turnstile and conclusion kept together.  When they
are formatted over several lines all the terms have their left ends
lined up and the turnstile sticks out to the left.  With no
assumptions there should be no spaces before the turnstile (function
$pr_assumptions$ achieves this).

=SML
fun Ûshow_theoremÝ(o_funs as (addstring, beginb, space, endb):OPPEN_FUNS) (th : THM) : unit = (
let
	val (assumptions, conclusion) = dest_thm th;

	val lang =	case get_first_const conclusion
			of Value name => get_const_language name
			| Nil => "HOL";

	fun aux t s = (	beginb(2, false);
			show_term_in lang false o_funs t;
			addstring s;
			endb()
	);

	fun pr_ass nil = ()
	| pr_ass (a :: nil) = aux a ""
	| pr_ass (a :: rest) = (aux a ","; space(1, 4); pr_ass rest);

	fun pr_assumptions nil = ()
	| pr_assumptions assum = (pr_ass assum; space(1, 2));
in
	beginb(0, true);
	pr_assumptions assumptions ;
	beginb(2, false);
	addstring "ô ";
	show_term_in lang false o_funs conclusion;
	endb();
	endb()
end
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\section{INSTALLATION}

%********************************************************************

\subsection{Installing PolyML Printers}

Based on observation of PolyML and the function $PolyML.install_pp$ it
seems that any unhandled exceptions from the installed printing
function are quietly ignored.  As there is considerable complexity in
the pretty printing code in this document and, furthermore, users may
add their own printing functions it seems desirable to catch and report
any problems.

=SML
local
	fun grumble ex_name msg source = (
		output(std_out, "Exception " ^ ex_name ^ 
		msg ^ " handled by " ^ source ^ "\n")
	);

	fun ÛinterposeÝ f f_name a b = (
		(f a b)
		handle Error args => grumble "Error " (PolyML.makestring args) f_name
		| Fail args => grumble "Fail " (PolyML.makestring args) f_name
		| E => grumble "" (PolyML.makestring E) f_name
	);
in

fun Ûpp_initÝ (() : unit) : unit = (
	PolyML.install_pp  (interpose (show_term true) "show_term");
	PolyML.install_pp  (interpose (show_type true) "show_type");
	PolyML.install_pp  (interpose show_theorem "show_theorem")
);

end;

val side_effect = pp_init();
=TEX

%********************************************************************

\subsection{Pretty Printing Interface}

=SML
fun Ûformat_termÝ (b : bool) (t : TERM) : string list = (
	oppen_format get_line_length (show_term b) t
);

fun Ûformat_typeÝ (b : bool) (t : TYPE) : string list = (
	oppen_format get_line_length (show_type b) t
);

fun Ûformat_thmÝ (t : THM) : string list = (
	oppen_format get_line_length show_theorem t
);
=TEX

=SML
fun Ûformat_term1Ý (b : bool) (l : int) (t : TERM) : string list = (
	oppen_format (fn () => l) (show_term b) t
);

fun Ûformat_type1Ý (b : bool) (l : int) (t : TYPE) : string list = (
	oppen_format (fn () => l) (show_type b) t
);

fun Ûformat_thm1Ý (l : int) (t : THM) : string list = (
	oppen_format (fn () => l) show_theorem t
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{FINALE}

=SML
end (* of structure PrettyPrinter *);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\makeatletter
\def\refstepcounter#1{\stepcounter{#1}\global\edef\@currentlabel{\csname
	p@#1\endcsname\csname the#1\endcsname}}
\makeatother

%\twocolumn[\section{INDEX}]
\section{INDEX}

\footnotesize
\printindex

\onecolumn

\end{document}


