=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation for Theory Lister}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP033}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the implementation for the
theory lister module for ICL HOL.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library\\RDA\\AJH\\DJK}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue 1.3]
First draft for comment.
\item [Issue 1.4]
Corrected a use of $get\_const\_type$.
\item [Issue 1.5]
The name atom  ``definition(s)'' changed to ``defn(s)'', and
``constant(s)'' to ``const(s)''.
\item [Issue \SCCSversion (\FormatDate{$Date$%
})] Added $get\_alias$. Corrected handling of languages.
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the symbol table module for ICL HOL.
The detailed design for this material is given in \cite{DS/FMU/IED/DTD020}.
\subsection{Introduction}
\subsection{Dependencies}
\subsection{Algorithms}
\subsection{Possible Enhancements}
\subsection{Deficiencies}
$print\_theory$ is currently coded to work with non-proportionately
spaced fonts. The code may be adapted to work with proportionately
spaced fonts as follows:

\section{PREAMBLE}
=SML
structure ‚Lister· : Lister = struct
open PrettyPrinter;
open Sort;
=IGN
fun my_get_terminators (s:string) = get_terminators ();
val format_thm1 = format_theorem1;
=SML
=TEX
\subsection{Utilities}
The following gives us a name for the number of spaces in a tab character.
=SML
val ‚tabstop· = 8;
=TEX
The following rounds up  $what$ to a non-negative multiple of $factor$
=SML
fun ‚roundup· (what : int) (factor : int) = (
	if factor = 0 orelse what <= 0
	then 0
	else (((what + factor - 1) div factor) * factor)
);
=TEX
The following function returns a string containing $n$ tabs:
=SML
fun ‚tabs· (n : int) : string = (
	if n <= 0 then "" else "\t" ^ tabs (n-1)
);
=TEX
$deal\,n\,default\,items$ returns a list of lists which are the rows of a
table with $n$ columns, with entries taken from $items$. The $items$ are
laid out down the columns of the table and surplus fields in the table
contain $default$.
=SML
fun ‚deal· (n : int) (default : 'a) (items : 'a list) : 'a list list = (
	if n <= 1
	then map (fn x => [x]) items
	else let
		fun myhd (what :: more) = what
		|   myhd [] = default;
		fun mytl ( _ :: more) = more
		|   mytl [] = [];
		fun paste listlists = (
			if all listlists is_nil
			then []
			else map myhd listlists :: paste (map mytl listlists)
		);
		val height = (length items + n - 1) div n;
		fun splitrev (cur, old) i (item :: more) = (
			if i = height
			then splitrev ([], cur :: old) 0 (item :: more)
			else splitrev (item :: cur, old) (i+1) more
		) | splitrev (cur, old) _ [] = cur :: old;
	in	paste (rev (map rev (splitrev ([], []) 0 items)))
	end
);
=IGN
deal 2 99 (interval 1 10);
deal 2 99 (interval 1 11);
deal 4 99 (interval 1 21);
deal 4 99 (interval 1 25);
=TEX
Given a list of strings, the following function, $make\_table$
formats them into a columnar format.
$siz$ is a function to return the length of a string in some units.
$width$ gives the desired width of the
table in the same units as $siz$ uses. The first component
of the result is a list of lists
of string-integer pairs, with the integer components giving the length
of the corresponding string (to save the caller having to recompute it
if it should involve lots of computation).`
The second component gives the width of the columns (in the units used
by $siz$).
$padlastcol$ indicates whether the table is  to have the last column of entries
blank-padded or not. This actually affects the length fields
in the last column of the table which
are set greater than the column width if blank-padding is not desired
(on the presumption that the calling function will use the length fields
to control insertion of intercolumn white space).

It is the caller's responsibility to supply a $siz$ function which
actually allocates sufficient space in the intended application. For example,
if $siz$ simply returns the length of the string, then $make\_table$ will
make a table whose columns are precisely the width of the longest
string in $items$,
so that there will be no intercolumn space  around the longest string. 

Negative results from $siz$ are treated as $0$.
Values of width less than $1$ are treated as $1$.

=SML
fun ‚make_table· (siz : string -> int) (width : int) (items : string list)
	(padlastcol : bool)
			: (string * int) list list * int= (
	let	val mywidth = if width < 1 then 1 else width;
		fun mysiz item = (
			let	val s = siz item;
			in	if s < 0 then 0 else s
			end
		);
		val itemlens = map (fn item => (item, mysiz item)) items;
		val max = fold
				(fn ((_, i), max) => if i > max then i else max)
				itemlens 1;
		val quot = mywidth div max;
		val res1 = deal quot ("", 0) itemlens;
		fun unpad ((s, i) :: []) = [(s, max+1)]
		|   unpad (si :: more) = si :: unpad more
		|   unpad [] = [];
	in	(	if padlastcol
			then res1
			else map unpad res1,
			max	)
	end
);
=TEX
The following function is intended for use as a $siz$ argument to
$make\_table$. It returns the number of $tabstop$ units required
to contain a string (on the assumption of fixed-width characters).
Note that a string whose length is an exact multiple of $tabstop$ has
its length rounded up by 1 unit.
=SML
fun tabsize (s : string) : int = (
	(size s + tabstop) div tabstop
);
=IGN
make_table tabsize 2 ["a", "b", "c", "d", "e", "f", "g", "h"];
make_table tabsize 8 ["abcdefgh", "b", "c", "abcdefgh", "a", "b", "c"];
=TEX
The following package is used to parameterise the pretty printer.
The fields are as follows:

\begin{description}
\item[$outp$:] the function which actual performs the output of strings;
\item[$siz$:]  a function to compute the size of a string in some
units  as used in $make\_table$;
\item[$width$]
the desired width of the lines to be
output;
\item[$indent$]
the minimum desired field width for labels.
\item[$pad$]
a function to pad out a string, with
precomputed length as returned by $make\_table$, to a given length
(it may  also add text formatting red-tape);
\item[$boln$]a string to be output at the beginning of each line of output;
\item[$eoln$]a string to be output at the end of each line of output.
\item[$bbanner$]a string to be output before the banner at the beginning
of the listing
\item[$ebanner$]a string to be output after the banner at the beginning
of the listing
\item[$btrailer$]a string to be output before the trailer at the end
of the listing
\item[$etrailer$]a string to be output after the trailer at the end
of the listing
\item[$bsection$]a string to be output before each section heading
\item[$esection$]a string to be output after each section heading
\item[$btable$]a string to be output before each multicolumn table
\item[$etable$]a string to be output after each multicolumn table
\item[$bother$]a string to be output before each section which
is not multicolumn table
\item[$eother$]a string to be output after each section which
is not multicolumn table
\item[$ppwidth$] gives the length parameter to be passed to calls of
pretty printer functions in order to fit them on lines allowing $indent$
amount of space for a label. This is a hack to circumvent the fact that
the pretty printer assumes fixed size characters at the moment.
\end{description}

=SML
type IO_INFO = 	{
		outp : string -> unit,
		siz : string -> int,
		pad : int -> (string * int) -> string,
		boln : string,
		eoln : string,
		bbanner : string,
		ebanner : string,
		btrailer : string,
		etrailer : string,
		bsection : string,
		esection : string,
		btable : string,
		etable : string,
		bother : string,
		eother : string,
		width : int,
		indent : int,
		ppwidth : int};
=TEX
$print\_table$ prints a labelled table.Note that $pad$ is applied when the label is printed, so that the
length of its string argument may be longer than the given length.
In this case the label is printed on a line of its own.
=SML
fun ‚print_table·
	({	outp,
		siz,
		pad,
		boln,
		eoln,
		width,
		indent,
		...} : IO_INFO)
	(label : string)
	(items : string list) = (
	let	val labwidth = siz label;
		val t = width - indent;
		val tabwidth =	let val t = width - indent
				in if t < 1 then 1 else t end;
		val (rows, fieldwidth) = make_table siz tabwidth items false;
		fun endrow items = (
			map (outp o pad fieldwidth) items;
			outp eoln
		);
		fun startln () = outp boln;
		val blank = pad indent ("", siz "");
		fun doindent () = (startln(); outp blank);
		fun dorow row = (doindent (); endrow row);
	in	startln();
		outp(pad indent (label, labwidth));
		if labwidth > indent
		then 	(outp eoln;
			map dorow rows; ())
		else case rows of
			[] => outp eoln
		|	row :: more => (endrow row; map dorow more; ())
	end
);
=TEX
=SML
fun ‚tabpad· (fieldwidth : int) (what : string, width : int) : string = (
	if width > fieldwidth orelse width = 0
	then what
	else what ^ tabs (fieldwidth - width + 1)
);
=TEX
=SML
fun ‚latexpad· (fieldwidth : int) (what : string, width : int) : string = (
	if width > fieldwidth orelse width = 0
	then what
	else what ^ tabs 1
);
=TEX
=SML
fun ‚out_line· ({outp, boln, eoln, ...} : IO_INFO) (s : string) : unit = (
	outp boln;
	outp s;
	outp eoln
);
=TEX
The following little utility is needed in some places, where a list
of strings is available and a single string is required:
=SML
val ‚cat· : string list -> string = switch(fold (op ^)) "";
=IGN
val myii : IO_INFO = {pad=tabpad, siz=tabsize,
	outp= fn s=>output(std_out, s),
	boln="", eoln="\n",
	bbanner= "=== ",
	ebanner= " ===",
	btrailer= "=== ",
	etrailer= "=== ",
	bsection= "--- ",
	esection= "--- ",
	btable= "",
	etable= "",
	bother= "",
	eother= "",
	width=80 div tabstop, indent= 2, ppwidth=(80 div tabstop-2)*tabstop};
val mypt = print_table myii;
mypt "label"["abcdefgh", "b", "c", "abcdefgh", "a", "b", "c"];
val names = ["abbe","abbey","abbot","Abbott",
"abbreviate","abc","abdicate","abdomen",
"abdominal","abduct","Abe","abed",
"Abel","Abelian","Abelson","Aberdeen",
"Abernathy","aberrant","aberrate","abet",
"abetted","abetting","abeyance","abeyant",
"abhorred","abhorrent","abide","Abidjan",
"Abigail","abject","ablate","ablaze",
"able","ablution","Abner","abnormal",
"Abo","aboard","abode","abolish",
"abolition","abominable","abominate","aboriginal",
"aborigine","aborning","abort","abound",
"about","above","aboveboard","aboveground",
"abovementioned","abrade","Abraham","Abram",
"Abramson"];
mypt "label"names;
=TEX
\subsection{Generic Lister Support};
=TEX
Note that the functions which use the pretty printer below
change the flag $pp\_show\_HOL\_types$ as needed.
=SML
val ‚show_types· : string = "pp_show_HOL_types";
=TEX
Note that the functions also assume that the theory being listed is in
scope.
=SML
val ‚sorted_listings· : bool ref = ref false;
val ‚listing_indent· : int ref = ref 2;
=TEX
=SML
val ‚side_effect· = new_flag{name="sorted_listings",
			control=sorted_listings, default=fn() => false};
val ‚side_effect· = new_int_control{name="listing_indent",
			control=listing_indent, check=
			fn i =>	i >= 0 orelse fail "listing_indent" 33052 [],
			default = fn() => 2};
=TEX
=SML
fun ‚mysort· (namef : 'a -> string) (items : 'a list) : 'a list = (
	if !sorted_listings
	then sort (fn x => fn y => stringorder (namef x) (namef y)) items
	else items
);
=SML
fun ‚do_banner· (ii : IO_INFO) (thyn : string) : unit = (
	if thyn = "-"
	then (#outp ii)
	(#bbanner ii ^ (get_error_message 33001 [get_current_theory_name()])
	^ #ebanner ii)
	else (#outp ii) 
	(#bbanner ii ^ get_error_message 33001 [thyn]
	^ #ebanner ii)
);
=TEX
=SML
fun ‚do_section·	(ii : IO_INFO)
			(msg : int)
			(getter : string -> 'a list)	
			(how : 'a list -> 'b)
			(istable : bool)
			(thyn : string) : unit = (
	case getter thyn of
		[] => ()
	|	items => (
			(#outp ii)
		(#bsection ii ^ get_error_message msg [] ^ #esection ii);
			if istable
			then (#outp ii) (#btable ii)
			else (#outp ii) (#bother ii);
			how items;
			if istable
			then (#outp ii) (#etable ii)
			else (#outp ii) (#eother ii)
	)
);
=SML
fun ‚do_parents· (ii : IO_INFO) (thyn : string) : unit = (
	do_section ii 33002 (mysort Combinators.I o get_parents)
		(print_table ii "") true thyn
);
=TEX
=SML
fun ‚do_children· (ii : IO_INFO) (thyn : string) :unit = (
	do_section ii 33003 (mysort Combinators.I o get_children)
		(print_table ii "") true thyn
);
=TEX
It would be most remarkable if the call to $format\_term1$ below did not
deliver a list with exactly one element. However, the code below
defends itself against this possibility by concatenating the elements of the
list.
=SML
fun ‚do_consts· (ii : IO_INFO) (thyn : string) :unit = (
	let	val old_st = set_flag(show_types, false);
	in let	fun do1 c = (
			let	val lab = format_term1 (#ppwidth ii) c;
				val ty = format_type1 (#ppwidth ii) (type_of c);
			in	print_table ii (fold (op ^) lab "") ty
			end
		);
	in	do_section ii 33004 (rev o get_consts)
		(map do1 o mysort (fst o dest_const)) false thyn
	end 	handle ex => (set_flag(show_types, old_st); raise ex);
	set_flag(show_types, old_st); ()
	end
);
=TEX
=SML
fun ‚do_aliases· (ii : IO_INFO) (thyn : string) :unit = (
	let	val old_st = set_flag("pp_show_HOL_types", true);
	in let	fun do1 (a, tm) = (
			let	val tab = format_term1 (#ppwidth ii) tm;
			in	print_table ii a tab
			end
		);
	in	do_section ii 33005 (rev o get_aliases)
		(map do1 o mysort fst) false thyn
	end 	handle ex => (set_flag(show_types, old_st); raise ex);
	set_flag(show_types, old_st); ()
	end
);
=TEX
=SML
fun ‚do_undeclared_aliases· (ii : IO_INFO) (thyn : string) :unit = (
	let	val old_st = set_flag("pp_show_HOL_types", true);
	in let	fun do1 (a, tm) = (
			let	val tab = format_term1 (#ppwidth ii) tm;
			in	print_table ii a tab
			end
		);
	in	do_section ii 33013 (rev o get_undeclared_aliases)
		(map do1 o mysort fst) false thyn
	end 	handle ex => (set_flag(show_types, old_st); raise ex);
	set_flag(show_types, old_st); ()
	end
);
=TEX
=SML
fun ‚do_types· (ii : IO_INFO) (thyn : string) :unit = (
	let	fun do1 t = (
			let	val ty = format_type1 (#ppwidth ii) t;
			in	map (out_line ii) ty
			end
		);
	in	do_section ii 33006 (rev o get_types)
		(map do1 o mysort (fst o dest_type)) false thyn
	end
);
=TEX
=SML
fun ‚do_type_abbrevs· (ii : IO_INFO) (thyn : string) :unit = (
	let	fun do1 (s, (args, ty)) = (
			let	val lab = format_type1 (#ppwidth ii)
				(mk_type(s, map mk_vartype args));
				val tab = format_type1 (#ppwidth ii) ty
			in	print_table ii (cat lab) tab
			end
		);
	in	do_section ii 33007 (rev o get_type_abbrevs)
		(map do1 o mysort fst) false thyn
	end
);
=TEX
=SML
fun ‚do_undeclared_type_abbrevs· (ii : IO_INFO) (thyn : string) :unit = (
	do_section ii 33014
	(mysort Combinators.I o rev o get_undeclared_type_abbrevs)
	(print_table ii "") true thyn
);
=TEX
We now define two functions which support the fixity part of the listing.
Both of these functions do nothing if their list argument is empty.

The function below always sorts the operators within each precedence (since
the division by precedence destroys any useful ordering by order of
definition).
=SML
fun ‚do_prec_fixity· (_ : int)  (_ : IO_INFO)([] : (int * string) list) : unit  = ()
|   do_prec_fixity  msg ii items = (
	let	fun myorder (i1, s1) (i2, s2) = ( 
			case i1 - i2 of
				0 => stringorder s1 s2
			|	x => x
		);
		val sitems = sort myorder items;
		fun strip1 ( (i1, s1) :: (i2, s2) :: more ) = (
			if i1 = i2
			then	let val (this, rest) = strip1 ((i2, s2):: more);
				in	((i1, s1) :: this, rest)
				end
			else	([(i1, s1)], (i2, s2) :: more)
		) | strip1 ( (i1, s1) :: [] ) = ([(i1, s1)], [])
		|   strip1 [] = ([], []);
		fun go (iss as (i1, _) :: _) = (
			let 	val (this, rest) = strip1 iss;
				val lab = get_error_message msg[string_of_int i1];
			in	print_table ii lab (map snd this);
				go rest
			end
		) | go [] = ();
	in	go sitems
	end
);
=TEX
For uniformity with the above function the following always sorts the
identifiers.
=SML
fun ‚do_other_fixity· (msg : int) (ii : IO_INFO) ([] : string list) = ()
|   do_other_fixity  msg ii items = (
	let	val sitems = sort stringorder items;
		val lab = get_error_message msg[];
	in	print_table ii lab items
	end
);
=TEX
=SML
datatype ‚FIXITY_INFO·	=	Binders of string list
			|	Infixes of (int * string) list
			|	Nonfixes of string list
			|	Postfixes of (int * string) list
			|	Prefixes of (int * string) list;
=TEX
=SML
fun ‚do_fixities· (ii : IO_INFO) (items : FIXITY_INFO list) : unit = (
	let	fun aux (Binders x) = do_other_fixity 33020 ii x
		|   aux (Infixes x) = do_prec_fixity 33021 ii x
		|   aux (Nonfixes x) = do_other_fixity 33022 ii x
		|   aux (Postfixes x) = do_prec_fixity 33023 ii x
		|   aux (Prefixes x) = do_prec_fixity 33024 ii x;
	in	map aux items; ()
	end
);
=TEX
=SML
fun ‚get_fixities· (thyn : string) : FIXITY_INFO list = (
	let	fun add con [] acc = acc
		|   add con xs acc = con xs :: acc;
	in	add Binders (get_binders thyn) (
		add Infixes (get_infixes thyn) (
		add Nonfixes (get_nonfixes thyn) (
		add Postfixes (get_postfixes thyn) (
		add Prefixes (get_prefixes thyn) [] ))))
	end
		
);
=TEX
=SML
fun ‚do_fixity· (ii : IO_INFO) (thyn : string) : unit = (
	do_section ii 33008 get_fixities (do_fixities ii) true thyn
);
=TEX
=SML
fun ‚do_terminators· (ii : IO_INFO) (thyn : string) : unit = (
	do_section ii 33009 get_terminators (print_table ii "") true thyn
);
=TEX
=SML
fun ‚do_undeclared_terminators· (ii : IO_INFO) (thyn : string) : unit = (
	do_section ii 33015 get_undeclared_terminators (print_table ii "") true thyn
);
=TEX
=SML
fun ‚do_thms_aux· (ii : IO_INFO) (items : (string list * THM) list) = (
	let	fun do1 (name :: (more as (_ :: _)), thm) = (
			out_line ii name;
			do1 (more, thm) 
		) | do1 (name :: [], thm) = (
			let	val th = format_thm1 (#ppwidth ii) thm;
			in	print_table ii name th
			end
		) | do1 ([], seq) = do1 ([""], seq);
	in	map do1 (rev items)
	end
);
=TEX
=SML
fun ‚do_axioms· (ii : IO_INFO) (thyn : string) = (
	do_section ii 33010 get_axioms (do_thms_aux ii) false thyn
);
=TEX
=SML
fun ‚do_defns· (ii : IO_INFO) (thyn : string) = (
	do_section ii 33011 get_defns (do_thms_aux ii) false thyn
);
=TEX
=SML
fun ‚do_thms· (ii : IO_INFO) (thyn : string) = (
	do_section ii 33012 get_thms (do_thms_aux ii) false thyn
);
=TEX
=SML
fun ‚do_trailer· (ii : IO_INFO) (thyn : string) : unit = (
	if thyn = "-"
	then out_line ii
	(#btrailer ii ^ (get_error_message 33030 [get_current_theory_name()])
	^ #etrailer ii)
	else out_line ii 
	(#btrailer ii ^ get_error_message 33030 [thyn]
	^ #etrailer ii)
);
=TEX
=SML
fun ‚do_theory· (ii : IO_INFO) (thyn : string) : unit = (
	if not (get_current_theory_name () mem get_descendants thyn)
		handle ex => divert ex "get_descendants"
			"do_theory" 33051 [fn () => thyn]
	then fail "do_theory" 33050 [fn () => thyn]
	else (
		do_banner ii thyn;
		do_parents ii thyn;
		do_children ii thyn;
		do_consts ii thyn;
		do_aliases ii thyn;
		do_undeclared_aliases ii thyn;
		do_types ii thyn;
		do_type_abbrevs ii thyn;
		do_undeclared_type_abbrevs ii thyn;
		do_fixity ii thyn;
		do_terminators ii thyn;
		do_undeclared_terminators ii thyn;
		do_axioms ii thyn;
		do_defns ii thyn;
		do_thms ii thyn;
		do_trailer ii thyn
	)
);
=SML
=TEX
\subsection{The Screen Lister}
The following computer of $IO\_INFO$s assumes (incorrectly) a fixed width font.
The computation of the line length to use attempts to ensure that the
minimum width of 20 spaces acceptable to the pretty printer is available.
=SML
fun ‚screen_ii· () : IO_INFO = ( 
	let	val ll = get_line_length () div tabstop;
		val min = 20 div tabstop + !listing_indent + 1;
		val actll = if ll < min then min else ll;
	in	{	pad=tabpad,
			siz=tabsize,
			outp= fn s=>output(std_out, s),
			boln="",
			eoln="\n",
			bbanner= "=== ",
			ebanner= " ===\n",
			btrailer= "\n=== ",
			etrailer= " ===",
			bsection= "\n--- ",
			esection= " ---\n\n",
			btable= "",
			etable= "",
			bother= "",
			eother= "",
			width=actll, indent = !listing_indent,
			ppwidth=(actll - !listing_indent)*tabstop}
	end
);
=TEX
=SML
fun ‚print_theory· (thyn : string) : unit = (
	(do_theory (screen_ii()) thyn)
	handle ex => (
		if area_of ex = "do_theory"
		then reraise ex "print_theory"
		else raise ex
	)
);
=TEX
\subsection{The \LaTeX\ Lister}
The following computer of $IO\_INFO$s assumes (incorrectly) a fixed width font
of about 0.1 inch width for 6.5 inch printing width with a 1 inch indent. It works in units of 0.01 inches. 
=SML
fun ‚latex_ii· (filename : string) : IO_INFO = ( 
	let	val stream = open_out filename;
		val ll = 650;
		val latextabstop = 100;
		fun latexsize (s : string) : int = (
			(size s * 10 + latextabstop) div latextabstop
		);
	in	{	pad=latexpad,
			siz=latexsize,
			outp= fn s=>output(stream, s),
			boln="",
			eoln="\n",
			bbanner= "=THEORYLISTINGBANNER\n",
			ebanner= "\n=TEX\n",
			btrailer= "=THEORYLISTINGTRAILER\n",
			etrailer= "\n=TEX\n",
			bsection= "=THEORYLISTINGSECTION\n",
			esection= "\n=TEX\n",
			btable= "=THEORYLISTINGTABLE\n",
			etable= "=TEX\n",
			bother= "=THEORYLISTINGOTHER\n",
			eother= "=TEX\n",
			width=ll,
			indent = 100,
			ppwidth=(ll - latextabstop) div latexsize " "}
	end	handle Io msg => fail "output_theory" 33051 [fn()=>msg]
);
=TEX
=SML
fun ‚output_theory· {theory : string, outfile:string} : unit = (
	(do_theory (latex_ii outfile) theory)
	handle ex => (
		if area_of ex = "do_theory"
		then reraise ex "print_theory"
		else raise ex
	)
);
=TEX
\section{EPILOGUE}
=TEX
=SML
end; (* of structure Lister *)
open Lister;
=TEX
=SML
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}

=IGN
fun pt thyn = (open_theory thyn; print_theory thyn);

fun ot s = output_theory{theory=s, outfile=""};
fun ‚do_defns· (ii : IO_INFO) (thyn : string) = (
	do_section ii 33011 get_defns (do_thms_aux ii) false thyn
);
