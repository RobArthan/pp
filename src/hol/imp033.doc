=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation for Theory Lister}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD033}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the implementation for the
theory lister module for ICL HOL.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library\\RDA\\AJH\\DJK}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue 1.3]
First draft for comment.
\item [Issue 1.4]
Corrected a use of $get\_const\_type$.
\item [Issue 1.5]
The name atom  ``definition(s)'' changed to ``defn(s)'', and
``constant(s)'' to ``const(s)''.
\item [Issue \SCCSversion (\FormatDate{$Date$%
})] Added $get\_alias$. Corrected handling of languages.
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the symbol table module for ICL HOL.
The detailed design for this material is given in \cite{DS/FMU/IED/DTD020}.
\subsection{Introduction}
\subsection{Dependencies}
\subsection{Algorithms}
\subsection{Possible Enhancements}
\subsection{Deficiencies}
$print\_theory$ is currently coded to work with non-proportionately
spaced fonts. The code may be adapted to work with proportionately
spaced fonts as follows:

\section{PREAMBLE}
=IGN_SML
structure ‚TheoryLister· : TheoryLister = struct
=SML
=TEX
\subsection{Utilities}
The following gives us a name for the number of spaces in a tab character.
=SML
val ‚tabstop· = 8;
=TEX
The following rounds up  $what$ to a non-negative multiple of $factor$
=SML
fun ‚roundup· (what : int) (factor : int) = (
	if factor = 0 orelse what <= 0
	then 0
	else (((what + factor - 1) div factor) * factor)
);
=TEX
The following function returns a string containing $n$ tabs:
=SML
fun ‚tabs· (n : int) : string = (
	if n <= 0 then "" else "\t" ^ tabs (n-1)
);
=TEX
$deal\,n\,default\,items$ returns a list of lists which are the rows of a
table with $n$ columns, with entries taken from $items$. The $items$ are
laid out down the columns of the table and surplus fields in the table
contain $default$.
=SML
fun ‚deal· (n : int) (default : 'a) (items : 'a list) : 'a list list = (
	if n <= 1
	then map (fn x => [x]) items
	else let
		fun myhd (what :: more) = what
		|   myhd [] = default;
		fun mytl ( _ :: more) = more
		|   mytl [] = [];
		fun paste listlists = (
			if all listlists is_nil
			then []
			else map myhd listlists :: paste (map mytl listlists)
		);
		val height = (length items + n - 1) div n;
		fun splitrev (cur, old) i (item :: more) = (
			if i = height
			then splitrev ([], cur :: old) 0 (item :: more)
			else splitrev (item :: cur, old) (i+1) more
		) | splitrev (cur, old) _ [] = cur :: old;
	in	paste (rev (map rev (splitrev ([], []) 0 items)))
	end
);
=IGN
deal 2 99 (interval 1 10);
deal 2 99 (interval 1 11);
deal 4 99 (interval 1 21);
deal 4 99 (interval 1 25);
=TEX
Given a list of strings, the following function, $make\_table$
formats them into a columnar format.
$siz$ is a function to return the length of a string in some units.
$width$ gives the desired width of the
table in the same units as $siz$ uses. The first component
of the result is a list of lists
of string-integer pairs, with the integer components giving the length
of the corresponding string (to save the caller having to recompute it
if it should involve lots of computation).`
The second component gives the width of the columns (in the units used
by $siz$).
$padlastcol$ indicates whether the table is  to have the last column of entries
blank-padded or not. This actually affects the length fields
in the last column of the table which
are set greater than the column width if blank-padding is not desired
(on the presumption that the calling function will use the length fields
to control insertion of intercolumn white space).

It is the caller's responsibility to supply a $siz$ function which
actually allocates sufficient space in the intended application. For example,
if $siz$ simply returns the length of the string, then $make\_table$ will
make a table whose columns are precisely the width of the longest
string in $items$,
so that there will be no intercolumn space  around the longest string. 

Negative results from $siz$ are treated as $0$.
Values of width less than $1$ are treated as $1$.

=SML
fun ‚make_table· (siz : string -> int) (width : int) (items : string list)
	(padlastcol : bool)
			: (string * int) list list * int= (
	let	val mywidth = if width < 1 then 1 else width;
		fun mysiz item = (
			let	val s = siz item;
			in	if s < 0 then 0 else s
			end
		);
		val itemlens = map (fn item => (item, mysiz item)) items;
		val max = fold
				(fn ((_, i), max) => if i > max then i else max)
				itemlens 1;
		val quot = mywidth div max;
		val res1 = deal quot ("", 0) itemlens;
		fun unpad ((s, i) :: []) = [(s, max+1)]
		|   unpad (si :: more) = si :: unpad more
		|   unpad [] = [];
	in	(	if padlastcol
			then res1
			else map unpad res1,
			max	)
	end
);
=TEX
The following function is intended for use as a $siz$ argument to
$make\_table$. It returns the number of $tabstop$ units required
to contain a string (on the assumption of fixed-width characters).
Note that a string whose length is an exact multiple of $tabstop$ has
its length rounded up by 1 unit.
=SML
fun tabsize (s : string) : int = (
	(size s + tabstop) div tabstop
);
=IGN
make_table tabsize 2 ["a", "b", "c", "d", "e", "f", "g", "h"];
make_table tabsize 8 ["abcdefgh", "b", "c", "abcdefgh", "a", "b", "c"];
=TEX
The following package is used to parameterise the pretty printer.
The fields are as follows:

\begin{description}
\item[$outp$:] the function which actual performs the output of strings;
\item[$siz$:]  a function to compute the size of a string in some
units  as used in $make\_table$;
\item[$width$]
the desired width of the lines to be
output;
\item[$indent$]
the minimum desired field
width for labels.
\item[$pad$]
a function to pad out a string, with
precomputed length as returned by $make\_table$, to a given length
(it may  also add text formatting red-tape);
\item[$boln$]a string to be output at the beginning of each line of output;
\item[$eoln$]a string to be output at the end of each line of output.
\end{description}
=SML
type IO_INFO = 	{
		outp : string -> unit,
		siz : string -> int,
		pad : int -> (string * int) -> string,
		boln : string,
		eoln : string,
		width : int,
		indent : int};

=TEX
$print\_table$ prints a labelled table.Note that $pad$ is applied when the label is printed, so that the
length of its string argument may be longer than the given length.
In this case the label is printed on a line of its own.
=SML
fun ‚print_table·
	({	outp : string -> unit,
		siz : string -> int,
		pad : int -> (string * int) -> string,
		boln : string,
		eoln : string,
		width : int,
		indent : int} : IO_INFO)
	(label : string)
	(items : string list) = (
	let	val labwidth = siz label;
		val t = width - indent;
		val tabwidth =	let val t = width - indent
				in if t < 1 then 1 else t end;
		val (rows, fieldwidth) = make_table siz tabwidth items false;
		fun endrow items = (
			map (outp o pad fieldwidth) items;
			outp eoln
		);
		fun startln () = outp boln;
		val blank = pad indent ("", siz "");
		fun doindent () = (startln(); outp blank);
		fun dorow row = (doindent (); endrow row);
	in	startln();
		outp(pad indent (label, labwidth));
		if labwidth > indent
		then 	(outp eoln;
			map dorow rows; ())
		else case rows of
			[] => outp eoln
		|	row :: more => (endrow row; map dorow more; ())
	end
);
=TEX
=SML
fun tabpad (fieldwidth : int) (what : string, width : int) : string = (
	if width > fieldwidth orelse width = 0
	then what
	else what ^ tabs (fieldwidth - width + 1)
);
=TEX
=SML
fun out_line ({outp, boln, eoln, ...} : IO_INFO) (s : string) : unit = (
	outp boln;
	outp s;
	outp eoln
);
=IGN
val myrec = {pad=tabpad, siz=tabsize,
	outp= fn s=>output(std_out, s),
	boln="", eoln="\n",
	width=10, indent= 2};
val mypt = print_table myrec;
mypt "label"["abcdefgh", "b", "c", "abcdefgh", "a", "b", "c"];
val names = ["abbe","abbey","abbot","Abbott",
"abbreviate","abc","abdicate","abdomen",
"abdominal","abduct","Abe","abed",
"Abel","Abelian","Abelson","Aberdeen",
"Abernathy","aberrant","aberrate","abet",
"abetted","abetting","abeyance","abeyant",
"abhorred","abhorrent","abide","Abidjan",
"Abigail","abject","ablate","ablaze",
"able","ablution","Abner","abnormal",
"Abo","aboard","abode","abolish",
"abolition","abominable","abominate","aboriginal",
"aborigine","aborning","abort","abound",
"about","above","aboveboard","aboveground",
"abovementioned","abrade","Abraham","Abram",
"Abramson"];
mypt "label"names;
=TEX
\subsection{Generic Lister Support};
=TEX
=SML
fun do_banner (ii : IO_INFO) (thyn : string) : unit = (
	if thyn = "-"
	then out_line ii (get_error_message 33001 [get_current_theory_name()])
	else out_line ii thyn
);
=TEX
=SML
fun do_parents (ii : IO_INFO) (thyn : string) = (
	case get_parents thyn of
		[] => ()
	|	pars => (
			out_line ii "";
			out_line ii (get_error_message 33002 []);
			out_line ii "";
			print_table ii "" pars
	)
);
=TEX
=SML
fun do_children (ii : IO_INFO) (thyn : string) = (
	case get_children thyn of
		[] => ()
	|	pars => (
			out_line ii "";
			out_line ii (get_error_message 33003 []);
			out_line ii "";
			print_table ii "" pars
	)
);
=TEX
=SML
=TEX
\section{EPILOGUE}
=SML
end; (* of structure TheoryLister *)
=TEX
=SML
open SymbolTable;
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}

=IGN
fun f s = (open_theory "Ü" ; new_theory s);
open_theory (hd names);

new_theory "child";
map new_parent (tl names);


