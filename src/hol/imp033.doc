=IGN
********************************************************************************
imp033.doc: this file is part of the PPHol system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% imp033.doc   %Z% $Date: 2012/03/17 15:01:00 $ $Revision: 1.36 $ $RCSfile: imp033.doc,v $
=TEX
%%%%% YOU MAY WANT TO CHANGE POINT SIZE IN THE FOLLOWING:
\documentclass[a4paper,11pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{latexsym}
\usepackage{epsf}
\makeindex

%%%%% YOU WILL WANT TO CHANGE THE FOLLOWING TO SUIT YOU AND YOUR DOCUMENT:

\def\Title{Implementation for Theory Lister}

\def\AbstractText{This document contains the implementation for the theory lister module for ICL HOL.}

\def\Reference{DS/FMU/IED/IMP033}

\def\Author{R.D. Arthan}


\def\EMail{C/O {\tt rda@lemma-one.com}}

\def\Phone{C/O +44 7497 030682}

\def\Abstract{\begin{center}{\bf Abstract}\par\parbox{0.7\hsize}
{\small \AbstractText}
\end{center}}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{\VCVersion}
\def\Date{\FormatDate{\VCDate}}

%% LaTeX2e port: =TEX
%% LaTeX2e port: % TQtemplate.tex
%% LaTeX2e port: \documentstyle[hol1,11pt,TQ]{article}
%% LaTeX2e port: \ftlinepenalty=9999
\def\Hide#1{}
%% LaTeX2e port: \def\Bool{``$\it{:}bool\,$''}
%% LaTeX2e port: \makeindex
%% LaTeX2e port: \TPPproject{FST PROJECT}  %% Mandatory field
%% LaTeX2e port: %\TPPvolume{}
%% LaTeX2e port: %\TPPpart{}
%% LaTeX2e port: \TPPtitle{Implementation for Theory Lister}  %% Mandatory field
%% LaTeX2e port: \TPPref{DS/FMU/IED/IMP033}  %% Mandatory field
%% LaTeX2e port: \def\SCCSversion{$Revision: 1.36 $%
%% LaTeX2e port: }
%% LaTeX2e port: \TPPissue{\SCCSversion}  %% Mandatory field
%% LaTeX2e port: \TPPdate{$Date: 2012/03/17 15:01:00 $%
%% LaTeX2e port: }
%% LaTeX2e port: \TPPstatus{Draft}			%% Mandatory field
%% LaTeX2e port: \TPPtype{Specification}
%% LaTeX2e port: \TPPkeywords{HOL}
%% LaTeX2e port: \TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%% LaTeX2e port: %\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
%% LaTeX2e port: \TPPauthorisation{R.D.~Arthan & FST Team Leader}
%% LaTeX2e port: \TPPabstract{
%% LaTeX2e port: This document contains the implementation for the
%% LaTeX2e port: theory lister module for ICL HOL.}
%% LaTeX2e port: %\TPPabstractB{}
%% LaTeX2e port: %\TPPabstractC{}
%% LaTeX2e port: %\TPPabstractD{}
%% LaTeX2e port: %\TPPabstractE{}
%% LaTeX2e port: %\TPPabstractF{}
%% LaTeX2e port: \TPPdistribution{\parbox[t]{4.0in}{%
%% LaTeX2e port: 	Library}}
%% LaTeX2e port: 
%% LaTeX2e port: %\TPPclass{CLASSIFICATION}
%% LaTeX2e port: %\def\TPPheadlhs{}
%% LaTeX2e port: %\def\TPPheadcentre{}
%% LaTeX2e port: %def\TPPheadrhs{}
%% LaTeX2e port: %\def\TPPfootlhs{}
%% LaTeX2e port: %\def\TPPfootcentre{}
%% LaTeX2e port: %\def\TPPfootrhs{}
%% LaTeX2e port: 
%% LaTeX2e port: \begin{document}
%% LaTeX2e port: \TPPsetsizes
%% LaTeX2e port: \makeTPPfrontpage
%% LaTeX2e port: 
%% LaTeX2e port: \vfill
%% LaTeX2e port: \begin{centering}
%% LaTeX2e port: 
%% LaTeX2e port: \bf Copyright \copyright\ : Lemma 1 Ltd. \number\year
%% LaTeX2e port: 
%% LaTeX2e port: \end{centering}

\begin{document}

\headsep=0mm
\FrontPage
\headsep=10mm

\setcounter{section}{-1}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issue 1.4 (1991/07/29)]
Changed as result of changes caused by IR0016.
\item [Issue 1.5 (1991/08/07)]
$new\_flag$ parameter change.
\item[\FormatDate{91/08/22}, issue 1.12~]
	Function $format\_term1$ and $format\_type1$ have new arguments.

\item[Issue 1.13 (1992/01/20), \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.14 (1992/04/14) (13th April 1992)]
Changes due to CR0017.

\item[Issue 1.15 (1992/04/21), (\FormatDate{92/04/21})]
	Add routine to print single column tables.
	Tidy up some of the text.

\item[Issue 1.16 (1992/05/19)]
	Made it use $translate\-\_for\-\_output$ on output strings
	not generated by $format\-\_thm$ etc.
\item [Issue 1.17 (1992/05/26) (26th May 1992)]
Renamings from version 1.5 of DS/FMU/IED/WRK038.

\item [Issue 1.18 (1992/05/27) (27 May 1992)]
	Add width controls for $output\_theory$ and make
	it actually use $listing\_indent$.

\item [Issue 1.19 (1992/06/01) (1 June 1992)]
	Cange the way $translate\-\_for\-\_output$ is used.

\item[Issue 1.20 (1992/08/24)~(\FormatDate{92/08/24%
})]	Output from $output_theory$ now include indexing characters.
	Add $output_theory1$ function.
\item[Issue 1.21 (1992/10/01)~(\FormatDate{92/10/01
})]	Added $output_theory1$; some bug-fixes.
\item[Issue 1.22 (1992/11/25)]	Added generic theory lister.
\item[Issue 1.23 (1992/12/21)~(\FormatDate{92/10/01})] Prevented
indexing of empty labels in user-supplied string and table
entries for generic lister.
\item[Issue 1.24 (1993/07/07)~(\FormatDate{93/07/07})] Addressed bug 125.
\item[Issue 1.25 (1999/02/12)-1.28 (2002/10/17)] Update for SML97
\item[Issue 1.28 (2002/10/17)] Copyright and banner updates for open source release.
\item[Issue 1.29 (2002/10/17)] PPHol-specific updates for open source release
\item[Issue 1.30 (2004/11/10)] Output file names are now passed through {\it translate\_for\_output}.
\item[Issue 1.31 (2005/04/24)] Now uses {\tt app} rather than {\tt map} wherever appropriate.
\item[Issue 1.32 (2005/05/07)] HOL now supports left-associative operators.
\item[Issue 1.33 (2008/12/13)--1.35 (2008/12/14)] Now supports nested structures.
\item[Issue 1.36 (2012/03/17)] Now need to stop the pretty-printer using type abbreviations when the type abbreviations are listed.
\item[Issue 1.37 (2012/03/17)] Symbol table interfaces now return results in the order of declaration.
\item[2014/07/23]
Augmented old RCS version numbers in the changes history with dates.
Dates will be used in place of version numbers in future.

%%%% END OF CHANGES HISTORY %%%%
\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the symbol table module for ICL HOL.
The detailed design for this material is given in \cite{DS/FMU/IED/DTD020}.
\subsection{Introduction}
\subsection{Dependencies}
\subsection{Algorithms}
\subsection{Possible Enhancements}
\subsection{Deficiencies}
$print\_theory$ is currently coded to work with non-proportionately
spaced fonts.  It might be adapted to work with proportionately
spaced fonts.
\section{PREAMBLE}
The two structures are actually coded together and then further structure
bindings with signature constraints are used at the end of the document
to create the desired structures for the user.
=SML
structure €ListerSupport›  = struct
open PrettyPrinter;
open Sort;
=IGN
fun my_get_terminators (s:string) = get_terminators ();
=SML
=TEX
\section{Steering Datatype}
=SML
datatype €LISTER_SECTION›
			=	€LSBanner›
			|	€LSParents›
			|	€LSChildren›
			|	€LSConsts›
			|	€LSAliases›
			|	€LSUndeclaredAliases›
			|	€LSTypes›
			|	€LSTypeAbbrevs›
			|	€LSUndeclaredTypeAbbrevs›
			|	€LSFixity›
			|	€LSTerminators›
			|	€LSUndeclaredTerminators›
			|	€LSAxioms›
			|	€LSDefns›
			|	€LSThms›
			|	€LSTrailer›

			|	€LSADString› of string -> (string list * string)
			|	€LSADStrings› of string -> (string list * string list)
			|	€LSADTables› of string -> (string list * string list) list
			|	€LSADThms› of string -> (string list * THM) list
			|	€LSADTerms› of string -> (string list * TERM) list
			|	€LSADTypes› of string -> (string list * TYPE) list

			|	€LSADSection› of string -> string
			|	€LSADNestedStructure› of string -> (string * LISTER_SECTION list);
=SML
=TEX
\subsection{Utilities}
The following gives us a name for the number of spaces in a tab character.
=SML
val €tabstop› = 8;
=TEX
The following function returns a string containing $n$ tabs:
=SML
fun €tabs› (n : int) : string = (
	if n <= 0 then "" else "\t" ^ tabs (n-1)
);
=TEX
$deal\,n\,default\,items$ returns a list of lists which are the rows of a
table with $n$ columns, with entries taken from $items$. The $items$ are
laid out down the columns of the table and surplus fields in the table
contain $default$.
=SML
fun €deal› (n : int) (default : 'a) (items : 'a list) : 'a list list = (
	if n <= 1
	then map (fn x => [x]) items
	else let
		fun myhd (what :: more) = what
		|   myhd [] = default;
		fun mytl ( _ :: more) = more
		|   mytl [] = [];
		fun paste listlists = (
			if all listlists is_nil
			then []
			else map myhd listlists :: paste (map mytl listlists)
		);
		val height = (length items + n - 1) div n;
		fun splitrev (cur, old) i (item :: more) = (
			if i = height
			then splitrev ([], cur :: old) 0 (item :: more)
			else splitrev (item :: cur, old) (i+1) more
		) | splitrev (cur, old) _ [] = cur :: old;
	in	paste (rev (map rev (splitrev ([], []) 0 items)))
	end
);
=IGN
deal 2 99 (interval 1 10);
deal 2 99 (interval 1 11);
deal 4 99 (interval 1 21);
deal 4 99 (interval 1 25);
=TEX
Given a list of strings, the following function, $make\_table$
formats them into a columnar format.
$siz$ is a function to return the length of a string in some units.
$width$ gives the desired width of the
table in the same units as $siz$ uses. The first component
of the result is a list of lists
of string-integer pairs, with the integer components giving the length
of the corresponding string (to save the caller having to recompute it
if it should involve lots of computation).
The second component gives the width of the columns (in the units used
by $siz$).
The final component of the result gives the number of columns.

$padlastcol$ indicates whether the table is  to have the last column of entries
blank-padded or not. This actually affects the length fields
in the last column of the table which
are set greater than the column width if blank-padding is not desired
(on the presumption that the calling function will use the length fields
to control insertion of intercolumn white space).

It is the caller's responsibility to supply a $siz$ function which
actually allocates sufficient space in the intended application. For example,
if $siz$ simply returns the length of the string, then $make\_table$ will
make a table whose columns are precisely the width of the longest
string in $items$,
so that there will be no intercolumn space  around the longest string.

Negative results from $siz$ are treated as $0$.
Values of width less than $1$ are treated as $1$.

=SML
fun €make_table› (siz : string -> int) (width : int) (items : string list)
	(padlastcol : bool)
			: (string * int) list list * int * int = (
	let	val mywidth = if width < 1 then 1 else width;
		fun mysiz item = (
			let	val s = siz item;
			in	if s < 0 then 0 else s
			end
		);
		val itemlens = map (fn item => (item, mysiz item)) items;
		val max = fold
				(fn ((_, i), max) => if i > max then i else max)
				itemlens 1;
		val quot = mywidth div max;
		val res1 = deal quot ("", 0) itemlens;
		fun unpad ((s, i) :: []) = [(s, max+1)]
		|   unpad (si :: more) = si :: unpad more
		|   unpad [] = [];
	in	(	if padlastcol
			then res1
			else map unpad res1,
			max,
			quot	)
	end
);
=TEX
The following function is intended for use as a $siz$ argument to
$make\_table$. It returns the number of $tabstop$ units required
to contain a string (on the assumption of fixed-width characters).
Note that a string whose length is an exact multiple of $tabstop$ has
its length rounded up by 1 unit.
=SML
fun tabsize (s : string) : int = (
	(size s + tabstop) div tabstop
);
=IGN
make_table tabsize 2 ["a", "b", "c", "d", "e", "f", "g", "h"];
make_table tabsize 8 ["abcdefgh", "b", "c", "abcdefgh", "a", "b", "c"];
=TEX
The following package is used to parameterise the pretty printer.
The fields are as follows:

\begin{description}
\item[$outp$] the function which actual performs the output of strings
(the argument to this function will not have been passed through
$translate\_for\_output$);
\item[$siz$]  a function to compute the size of a string in some
units as used in $make\_table$;
\item[$width$]
the desired width of the lines to be
output;
\item[$indent$]
the minimum desired field width for labels;
\item[$pad$]
a function to pad out a string, with
precomputed length as returned by $make\_table$, to a given length
(it may  also add text formatting red-tape);
\item[$boln$]a string to be output at the beginning of each line of output;
\item[$eoln$]a string to be output at the end of each line of output;
\item[$bbanner$]a string to be output before the banner at the beginning
of the listing;
\item[$ebanner$]a string to be output after the banner at the beginning
of the listing;
\item[$btrailer$]a string to be output before the trailer at the end
of the listing;
\item[$etrailer$]a string to be output after the trailer at the end
of the listing;
\item[$bsection$]a string to be output before each section heading;
\item[$esection$]a string to be output after each section heading;
\item[$btable$]a string to be output before each multicolumn table
it is given as argument the number of columns in the table
(not including the label column);
\item[$etable$]a string to be output after each multicolumn table;
\item[$bother$]a string to be output before each section which
is not multicolumn table;
\item[$add_index$]indicates whether `declarative' uses of names
should be enclosed in indexing characters in the output;
\item[$eother$]a string to be output after each section which
is not multicolumn table;
\item[$ppwidth$] gives the length parameter to be passed to calls of
pretty printer functions in order to fit them on lines allowing $indent$
amount of space for a label. This is a hack to circumvent the fact that
the pretty printer assumes fixed size characters at the moment.
\end{description}

=SML
type IO_INFO = 	{
		outp : string -> unit,
		siz : string -> int,
		pad : int -> (string * int) -> string,
		boln : string,
		eoln : string,
		bbanner : string,
		ebanner : string,
		btrailer : string,
		etrailer : string,
		bsection : string,
		esection : string,
		btable : string,
		etable : string,
		bother : string,
		eother : string,
		add_index : bool,
		width : int,
		indent : int,
		ppwidth : int};
=TEX
Functions $print\_table$ and $print\_single\_column\_table$ print out
labelled tables.  As they are so similar an auxiliary function
does the work.
Note that $pad$ is applied when the label is printed, so that the
length of its string argument may be longer than the given length.
In this case the label is printed on a line of its own.

=SML
val (€index_start_char›, €index_end_char›) =
=SMLLITERAL
	("€", "›");
=TEX

=SML
local (* for print_table and print_single_column_table *)

fun €print_table_aux›
	(	outp : string -> unit,
		siz : string -> int,
		pad : int -> (string * int) -> string,
		boln : string,
		eoln : string,
		width : int,
		indent : int)
	(label : string)
	(items : string list) : unit = (
	let	val labwidth = siz label;
		val t = width - indent;
		val tabwidth =	let val t = width - indent
				in if t < 1 then 1 else t end;
		val (rows, fieldwidth, _) = make_table siz tabwidth items false;
		fun endrow items = (
			app (outp o pad fieldwidth) items;
			outp eoln
		);
		fun startln () = outp boln;
		val blank = pad indent ("", siz "");
		fun doindent () = (startln(); outp blank);
		fun dorow row = (doindent (); endrow row);
	in	startln();
		outp(pad indent (label, labwidth));
		if labwidth > indent
		then 	(outp eoln;
			app dorow rows)
		else case rows of
			[] => outp eoln
		|	row :: more => (endrow row; app dorow more)
	end
);
=TEX

=SML
in

fun €print_table›
	({	outp,
		siz,
		pad,
		boln,
		eoln,
		width,
		indent,
		...} : IO_INFO)
	(label : string)
	(items : string list) : unit =
(
	print_table_aux
		(outp, siz, pad, boln, eoln, width, indent)
		label
		items
);

fun €print_single_column_table›
	({	outp,
		siz,
		pad,
		boln,
		eoln,
		indent,
		...} : IO_INFO)
	(label : string)
	(items : string list) : unit =
(
	print_table_aux
		(outp, siz, pad, boln, eoln, 1, indent)
		label
		items
);

end (* of local for print_table and print_single_column_table *)
=TEX

=SML
fun €tabpad› (fieldwidth : int) (what : string, width : int) : string = (
	if width > fieldwidth orelse width = 0
	then what
	else what ^ tabs (fieldwidth - width + 1)
);
=TEX
=SML
fun €latexpad› (fieldwidth : int) (what : string, width : int) : string = (
	if width > fieldwidth orelse width = 0
	then what
	else what ^ tabs 1
);
=TEX
=SML
fun €out_line› ({outp, boln, eoln, ...} : IO_INFO) (s : string) : unit = (
	outp boln;
	outp s;
	outp eoln
);
=TEX
=TEX
\subsection{Generic Lister Support}
Note that the functions which use the pretty printer below
change the flag $pp\_show\_HOL\_types$ as needed.
=SML
val €show_types› : string = "pp_show_HOL_types";
val €use_alias› : string = "pp_use_alias";
val €show_index› : string = "pp_show_index";
=TEX
Note that the functions also assume that the theory being listed is in
scope.

=SML
fun €thl_fail› (s:string) = (
	fail "theory_lister" 33052 [fn() => s]
);
=TEX
The signatures of the following two functions are the same as
$new\_flag$, $new\_int\_control$ respectively.
=SML
fun €my_new_flag› pars = (new_flag pars handle Fail _ => ());
fun €my_new_int_control› pars = (new_int_control pars handle Fail _ => ());
=TEX

=SML
val €sorted_listings› : bool ref = ref false;
val €listing_indent› : int ref = ref 2;
=TEX
=SML
val €side_effect› = my_new_flag{name="sorted_listings",
			control=sorted_listings,
			check=fun_true, default=fun_false};
val €side_effect› = my_new_int_control{name="listing_indent",
			control=listing_indent, check=
			fn i =>	i >= 0 orelse thl_fail "listing_indent",
			default = fn() => 2};
=TEX
=SML
fun €mysort› (namef : 'a -> string) (items : 'a list) : 'a list = (
	if get_flag "sorted_listings"
	then sort (fn x => fn y => string_order (namef x) (namef y)) items
	else items
);
fun €do_banner_aux› (ii : IO_INFO) (str : string) : unit = (
	(#outp ii) (#bbanner ii ^ str ^ #ebanner ii)
);
fun €do_banner› (ii : IO_INFO) (msg : int) (thyn : string) : unit = (
	if thyn = "-"
	then do_banner_aux ii (get_error_message msg [get_current_theory_name()])
	else do_banner_aux ii (get_error_message msg [thyn])
);
=TEX
=SML
fun €do_section_header›	(ii : IO_INFO) (hdr : string) : unit = (
	(#outp ii)(#bsection ii ^ hdr ^ #esection ii)
);
=TEX
=SML
fun €do_section›	(ii : IO_INFO)
			(msg : int)
			(getter : string -> 'a list)	
			(how : 'a list -> unit)
			(istable : bool)
			(thyn : string) : unit = (
	case getter thyn of
		[] => ()
	|	items => (
			do_section_header ii (get_error_message msg []);
			if istable
			then (#outp ii) (#btable ii)
			else (#outp ii) (#bother ii);
			how items;
			if istable
			then (#outp ii) (#etable ii)
			else (#outp ii) (#eother ii)
	)
);
=TEX
=SML
fun €do_parents› (ii : IO_INFO) (thyn : string) : unit = (
	do_section ii 33002 (mysort Combinators.I o get_parents)
		(print_table ii "") true thyn
);
=TEX
=SML
fun €do_children› (ii : IO_INFO) (thyn : string) :unit = (
	do_section ii 33003 (mysort Combinators.I o get_children)
		(print_table ii "") true thyn
);
=TEX
It would be most remarkable if the call to $format\_term1$ below did not
deliver a list with exactly one element. However, the code below
defends itself against this possibility by concatenating the elements of the
list.
=SML
fun €do_consts› (ii : IO_INFO) (thyn : string) :unit = (
	let	val old_st = set_flag(show_types, false);
		val old_ua = set_flag(use_alias, false);
		val old_si = set_flag(show_index, false);
	in let	fun do1 c = (
			let
				val SideEffect = set_flag(show_index, #add_index ii);
				val lab = format_term1 false (#ppwidth ii) c;
				val SideEffect = set_flag(show_index, false);
				val ty = format_type1 false (#ppwidth ii) (type_of c);
			in	print_single_column_table ii (fold (op ^) lab "") ty
			end
		);
	in	do_section ii 33004 (rev o get_consts)
		(app do1 o mysort (fst o dest_const)) false thyn
	end 	handle ex => (	set_flag(show_types, old_st);
				set_flag(use_alias, old_ua);
				set_flag(show_index, old_si);
				raise ex);
	set_flag(show_types, old_st);
	set_flag(use_alias, old_ua);
	set_flag(show_index, old_si);
	()
	end
);
=TEX
=SML
fun €do_aliases› (ii : IO_INFO) (thyn : string) :unit = (
	let	val old_st = set_flag(show_types, true);
		val old_ua = set_flag(use_alias, false);
	in let	fun do1 (a, tm) = (
			let
				val aa =	if #add_index ii
						then index_start_char ^ a ^ index_end_char
						else a
				val tab = format_term1 false (#ppwidth ii) tm;
			in	print_single_column_table ii aa tab
			end
		);
	in	do_section ii 33005 get_aliases
		(app do1 o mysort fst) false thyn
	end 	handle ex => (	set_flag(show_types, old_st);
				set_flag(use_alias, old_ua);
				raise ex);
	set_flag(show_types, old_st);
	set_flag(use_alias, old_ua);
	()
	end
);
=TEX
=SML
fun €do_undeclared_aliases› (ii : IO_INFO) (thyn : string) :unit = (
	let	val old_st = set_flag(show_types, true);
		val old_ua = set_flag(use_alias, false);
	in let	fun do1 (a, tm) = (
			let
				val aa =	if #add_index ii
						then index_start_char ^ a ^ index_end_char
						else a
				val tab = format_term1 false (#ppwidth ii) tm;
			in	print_single_column_table ii aa tab
			end
		);
	in	do_section ii 33013 get_undeclared_aliases
		(app do1 o mysort fst) false thyn
	end 	handle ex => (	set_flag(show_types, old_st);
				set_flag(use_alias, old_ua);
				raise ex);
	set_flag(show_types, old_st);
	set_flag(use_alias, old_ua);
	()
	end
);
=TEX
=SML
fun €do_types› (ii : IO_INFO) (thyn : string) :unit = (
	let
		val old_si = set_flag(show_index, #add_index ii);
		fun do1 t = (
			let	val ty = format_type1 false (#ppwidth ii) t;
			in	app (out_line ii) ty
			end
		);
	in
		(	do_section ii 33006 (rev o get_types)
			(app do1 o mysort (fst o dest_ctype)) false thyn
		) handle ex => (	set_flag(show_index, old_si);
					raise ex)
		;
		set_flag(show_index, old_si);
		()
	end
);
=TEX
=SML
fun €do_type_abbrevs› (ii : IO_INFO) (thyn : string) :unit = (
	let	val old_si = get_flag show_index;
		val old_uta = set_flag("pp_use_type_abbrev", false);
		fun do1 (s, (args, ty)) = (
			let
				val _ = set_flag(show_index, #add_index ii);
				val lab = format_type1 false (#ppwidth ii)
				(mk_ctype(s, map mk_vartype args));
				val _ = set_flag(show_index, false);
				val tab = format_type1 false (#ppwidth ii) ty
			in	print_single_column_table ii (implode lab) tab
			end
		);
	in	(do_section ii 33007 get_type_abbrevs
		(app do1 o mysort fst) false thyn
		handle ex => (
			set_flag(show_index, old_si);
			set_flag("pp_use_type_abbrev", old_uta);
			raise ex
		));
		set_flag(show_index, old_si);
		set_flag("pp_use_type_abbrev", old_uta);
		()
	end
);
=TEX
=SML
fun €do_undeclared_type_abbrevs› (ii : IO_INFO) (thyn : string) :unit = (
let
	val getter = (mysort Combinators.I o get_undeclared_type_abbrevs);

	val getter1 =
		if #add_index ii
		then
			fn x => map (fn a => index_start_char ^ a ^ index_end_char) (getter x)
		else
			getter;
in
	do_section ii 33014
	getter1
	(print_table ii "") true thyn
end
);
=TEX
We now define two functions which support the fixity part of the listing.
Both of these functions do nothing if their list argument is empty.

The function below always sorts the operators within each precedence (since
the division by precedence destroys any useful ordering by order of
definition).
=SML
fun €do_prec_fixity› (_ : int)  (ii : IO_INFO)([] : (int * string) list) : unit  = ()
|   do_prec_fixity  msg ii items = (
	let	fun myorder (i1, s1) (i2, s2) = (
			case i1 - i2 of
				0 => string_order s1 s2
			|	x => x
		);
		val sitems = sort myorder items;
		fun strip1 ( (i1, s1) :: (i2, s2) :: more ) = (
			if i1 = i2
			then	let val (this, rest) = strip1 ((i2, s2):: more);
				in	((i1, s1) :: this, rest)
				end
			else	([(i1, s1)], (i2, s2) :: more)
		) | strip1 ( (i1, s1) :: [] ) = ([(i1, s1)], [])
		|   strip1 [] = ([], []);

		val get_name =	if #add_index ii
				then
					fn (_, a) => index_start_char ^ a ^ index_end_char
				else
					snd;

		fun go (iss as (i1, _) :: _) = (
			let 	val (this, rest) = strip1 iss;
				val lab = get_error_message msg[string_of_int i1];
			in	print_table ii lab (map get_name this);
				go rest
			end
		) | go [] = ();
	in	go sitems
	end
);
=TEX
For uniformity with the above function the following always sorts the
identifiers.
=SML
fun €do_other_fixity› (msg : int) (ii : IO_INFO) ([] : string list) = ()
|   do_other_fixity  msg ii items = (
	let
		val sitems = sort string_order items;
		val sitems1 =	if #add_index ii
				then
					map (fn a => index_start_char ^ a ^ index_end_char) sitems
				else
					sitems;
		val lab = get_error_message msg[];
	in	print_table ii lab sitems1
	end
);
=TEX
=SML
datatype €FIXITY_INFO›	=	Binders of string list
			|	LeftInfixes of (int * string) list
			|	RightInfixes of (int * string) list
			|	Nonfixes of string list
			|	Postfixes of (int * string) list
			|	Prefixes of (int * string) list;
=TEX
=SML
fun €do_fixities› (ii : IO_INFO) (items : FIXITY_INFO list) : unit = (
	let	fun aux (Binders x) = do_other_fixity 33020 ii x
		|   aux (LeftInfixes x) = do_prec_fixity 33021 ii x
		|   aux (RightInfixes x) = do_prec_fixity 33022 ii x
		|   aux (Nonfixes x) = do_other_fixity 33023 ii x
		|   aux (Postfixes x) = do_prec_fixity 33024 ii x
		|   aux (Prefixes x) = do_prec_fixity 33025 ii x;
	in	app aux items
	end
);
=TEX
=SML
fun €get_fixities› (thyn : string) : FIXITY_INFO list = (
	let	fun add con [] acc = acc
		|   add con xs acc = con xs :: acc;
	in	add Binders (get_binders thyn) (
		add LeftInfixes (get_left_infixes thyn) (
		add RightInfixes (get_right_infixes thyn) (
		add Nonfixes (get_nonfixes thyn) (
		add Postfixes (get_postfixes thyn) (
		add Prefixes (get_prefixes thyn) [] )))))
	end
		
);
=TEX
=SML
fun €do_fixity› (ii : IO_INFO) (thyn : string) : unit = (
	do_section ii 33008 get_fixities (do_fixities ii) true thyn
);
=TEX
=SML
fun €do_terminators› (ii : IO_INFO) (thyn : string) : unit = (
	do_section ii 33009 get_terminators (print_table ii "") true thyn
);
=TEX
=SML
fun €do_undeclared_terminators› (ii : IO_INFO) (thyn : string) : unit = (
	do_section ii 33015 get_undeclared_terminators (print_table ii "") true thyn
);
=TEX
The following is very like $do\_things$ which is used for the application-defined
lists of labelled theorems, types or whatever. The main difference is
that it does the $rev$ which is required to get the theorems, axioms
or what-have-you in the right order when not sorting.
=SML
fun €do_thms_aux› (ii : IO_INFO) (items : (string list * THM) list)
	: unit = (
	let	fun do1 (name :: (more as (_ :: _)), thm) = (
			out_line ii (	if #add_index ii
					then index_start_char ^ name ^ index_end_char
					else name);
			do1 (more, thm)
		) | do1 (name :: [], thm) = (
			let	val th = format_thm1 (#ppwidth ii) thm;
			in	print_single_column_table ii
					(if #add_index ii
					then index_start_char ^ name ^ index_end_char
					else name
					)
					th
			end
		) | do1 ([], seq) = do1 ([""], seq);
		fun key (ss, _) = (fold (op ^) ss "");
	in	app do1 (mysort key (rev items))
	end
);
=TEX
=SML
fun €do_axioms› (ii : IO_INFO) (thyn : string) : unit = (
	do_section ii 33010 get_axioms (do_thms_aux ii) false thyn
);
=TEX
=SML
fun €do_defns› (ii : IO_INFO) (thyn : string) : unit = (
	do_section ii 33011 get_defns (do_thms_aux ii) false thyn
);
=TEX
=SML
fun €do_thms› (ii : IO_INFO) (thyn : string) : unit = (
	do_section ii 33012 get_thms (do_thms_aux ii) false thyn
);
=TEX
=SML
fun €do_strings› (ii : IO_INFO) ((keys, strs) : (string list * string list)) : unit = (
	let	fun do1 (key :: (more as (_ :: _))) = (
			out_line ii (	if #add_index ii andalso key <> ""
					then index_start_char ^ key ^ index_end_char
					else key);
			do1 more
		) | do1 (key :: []) = (
			print_single_column_table ii
				(if #add_index ii andalso key <> ""
				then index_start_char ^ key ^ index_end_char
				else key
				)
				strs
		) | do1 [] = do1 [""];
	in	do1 keys
	end
);
=TEX
=SML
fun €do_string› (ii : IO_INFO) ((keys, str) : (string list * string)) : unit = (
	do_strings ii (keys, [str])
);
=TEX
=SML
fun €do_table› (ii : IO_INFO) ((keys, strs) : (string list * string list)): unit  = (
	let	fun do1 (key :: (more as (_ :: _))) = (
			out_line ii (	if #add_index ii andalso key <> ""
					then index_start_char ^ key ^ index_end_char
					else key);
			do1 more
		) | do1 (key :: []) = (
			print_table ii
				(if #add_index ii andalso key <> ""
				then index_start_char ^ key ^ index_end_char
				else key
				)
				strs
		) | do1 [] = do1 [""];
	in	do1 keys
	end
);
=TEX
=SML
fun €do_things› (fmt : int -> 'a -> string list)
	(ii : IO_INFO)
	(items : (string list * 'a) list) : unit
	= (
	let	fun do1 (name :: (more as (_ :: _)), thing) = (
			out_line ii (	if #add_index ii
					then index_start_char ^ name ^ index_end_char
					else name);
			do1 (more, thing)
		) | do1 (name :: [], thing) = (
			let	val strs = fmt (#ppwidth ii) thing;
			in	print_single_column_table ii
					(if #add_index ii
					then index_start_char ^ name ^ index_end_char
					else name
					)
					strs
			end
		) | do1 ([], thing) = do1 ([""], thing);
		fun key (ss, _) = (fold (op ^) ss "");
	in	app do1 (mysort key items)
	end
);
val €do_ad_thms› : IO_INFO -> (string list * THM) list -> unit
	= do_things format_thm1;
val €do_ad_terms› : IO_INFO -> (string list * TERM) list -> unit
	= do_things (format_term1 false);
val €do_ad_types› : IO_INFO -> (string list * TYPE) list -> unit
	= do_things (format_type1 false);
=TEX
=SML
fun €do_trailer› (ii : IO_INFO) (thyn : string) : unit = (
	if thyn = "-"
	then out_line ii
	(#btrailer ii ^
	(get_error_message 33030[get_current_theory_name()])
	^ #etrailer ii)
	else out_line ii
	(#btrailer ii ^
	(get_error_message 33030[thyn])
	^ #etrailer ii)
);
=TEX
=SML
fun €do_red_tape›	(ii : IO_INFO)
			(how : 'a -> 'b)
			(istable : bool)
			(what : 'a) : unit = (
	if istable
	then (#outp ii) (#btable ii)
	else (#outp ii) (#bother ii);
	how what;
	if istable
	then (#outp ii) (#etable ii)
	else (#outp ii) (#eother ii)
);
=TEX
=SML
fun €list_do_red_tape›	(ii : IO_INFO)
			(how : 'a  list -> 'b)
			(istable : bool)
			(what : 'a list) : unit = (
	case what of
		[] => ()
	|	_ => do_red_tape ii how istable what
);
=TEX
$gen\_do\_section$ and $gen\_do\_section$ pulls all the above together.
In the case of a nested structure, it is not very clear whether
caller would ever want to enable check that the theory
exists and is in scope, since
presumably they would have got that right, but
we pass the flag in any case.
=SML
fun €gen_do_section› (chk : bool)
	(ii : IO_INFO) (banner : string -> string) (thyn : string)
	(sec : LISTER_SECTION) : unit = (
	case sec of
		LSBanner => do_banner_aux ii (banner thyn)
	|	LSParents => do_parents ii thyn
	|	LSChildren => do_children ii thyn
	|	LSConsts => do_consts ii thyn
	|	LSAliases => do_aliases ii thyn
	|	LSUndeclaredAliases => do_undeclared_aliases ii thyn
	|	LSTypes => do_types ii thyn
	|	LSTypeAbbrevs => do_type_abbrevs ii thyn
	|	LSUndeclaredTypeAbbrevs => do_undeclared_type_abbrevs ii thyn
	|	LSFixity => do_fixity ii thyn
	|	LSTerminators => do_terminators ii thyn
	|	LSUndeclaredTerminators => do_undeclared_terminators ii thyn
	|	LSAxioms => do_axioms ii thyn
	|	LSDefns => do_defns ii thyn
	|	LSThms => do_thms ii thyn
	|	LSTrailer => do_trailer ii thyn
	|	LSADString f => do_string ii (f thyn)
	|	LSADStrings f => do_strings ii (f thyn)
	|	LSADTables f => (app (do_red_tape ii(do_table ii)true)(f thyn))
	|	LSADThms f => list_do_red_tape ii (do_ad_thms ii) false (f thyn)
	|	LSADTerms f => list_do_red_tape ii (do_ad_terms ii) false (f thyn)
	|	LSADTypes f => list_do_red_tape ii (do_ad_types ii) false (f thyn)
	|	LSADSection f => (
			case f thyn of
				"" => ()
			|	str => do_section_header ii str
	) |	LSADNestedStructure f => (
			let	val (thyn1, secs) = f thyn;
			in	gen_do_sections chk ii banner thyn secs
			end
	)
(*
=TEX
=SML
*)
) and €gen_do_sections›
	(chk : bool)
	(ii : IO_INFO)
	(banner : string -> string)
	(thyn : string)
	(secs : LISTER_SECTION list) : unit = (
	if 	chk
	andalso	not (get_current_theory_name () mem get_descendants thyn)
			handle ex => divert ex "get_descendants"
				"gen_do_sections" 33051 [fn () => thyn]
	then	fail "gen_do_sections" 33050 [fn () => thyn]
	else	(app (gen_do_section chk ii banner thyn) secs)
);
=TEX
For the HOL lister, for historic reasons, we use a hard-wired approach.
=SML
fun €do_theory› (ii : IO_INFO) (bannermsg : int) (thyn : string) : unit = (
	if not (get_current_theory_name () mem get_descendants thyn)
		handle ex => divert ex "get_descendants"
			"do_theory" 33051 [fn () => thyn]
	then fail "do_theory" 33050 [fn () => thyn]
	else (
		do_banner ii bannermsg thyn;
		do_parents ii thyn;
		do_children ii thyn;
		do_consts ii thyn;
		do_aliases ii thyn;
		do_undeclared_aliases ii thyn;
		do_types ii thyn;
		do_type_abbrevs ii thyn;
		do_undeclared_type_abbrevs ii thyn;
		do_fixity ii thyn;
		do_terminators ii thyn;
		do_undeclared_terminators ii thyn;
		do_axioms ii thyn;
		do_defns ii thyn;
		do_thms ii thyn;
		do_trailer ii thyn
	)
);
=TEX
\subsection{The Screen Lister}
The following computer of $IO\_INFO$s assumes (incorrectly) a fixed width font.
The computation of the line length to use attempts to ensure that the
minimum width of 20 spaces acceptable to the pretty printer is available.

Whilst this function is called $screen_ii$ its purpose is to create an
$IO_INFO$ for screen-like outputs, it therefore takes a stream as its
argument.

=SML
fun €screen_ii› (stream : outstream) : IO_INFO = (
	let	val ll = get_line_length () div tabstop;
		val ind = get_int_control "listing_indent";
		val min = 20 div tabstop + ind + 1;
		val actll = if ll < min then min else ll;
	in	{	pad=tabpad,
			siz=tabsize,
			outp= fn s=>output(stream, translate_for_output s),
			boln="",
			eoln="\n",
			bbanner= "=== ",
			ebanner= " ===\n",
			btrailer= "\n=== ",
			etrailer= " ===",
			bsection= "\n--- ",
			esection= " ---\n\n",
			btable= "",
			etable= "",
			bother= "",
			eother= "",
			add_index= false,
			width=actll,
			indent = ind,
			ppwidth=(actll - ind)*tabstop}
	end
);
=TEX
=SML
fun €print_theory› (thyn : string) : unit = (
	(do_theory (screen_ii std_out) 33001 thyn)
	handle ex => (
		if area_of ex = "do_theory"
		then reraise ex "print_theory"
		else raise ex
	)
);
=TEX
\subsection{The \LaTeX\ Lister}
The following computer of $IO\_INFO$s assumes (incorrectly) a fixed width font
of about 0.08 inch width for 6.5 inch printing width with a 1 inch indent.
It computes character widths in units of 0.01 inch then rounds them to multiples
of 0.5 inch.

\subsection{Some Width Controls}

The following computer of $IO\_INFO$s assumes (incorrectly) a fixed width font
of about 0.07~inch width for 6.5~inch printing width with a 1~inch indent.
It computes character widths in units of 0.01~inch then rounds them to multiples
of 0.5~inch.
These dimensions are controlled as follows.

\begin{center}
\begin{tabular}{|l|l|l|l|l|}
\hline
Width		& Initial	& Control		& Unit		& Purpose \\
(inches)	& value		&			&		&	\\\hline\hline
6.5		& 13		& $thl_line_width$	& inch/2	& Line width for \LaTeX\\\hline
0.5		& 50		& $thl_tab_width$	& inch/100	& Tab width for \LaTeX\\\hline
0.07		& 7		& $thl_char_width$	& inch/100	& Character width for \LaTeX\\\hline
5		& 5		& $thl_chars_per_tab$	& 		& Chars per tab-width for \LaTeX\\\hline
\end{tabular}
\end{center}

=SML
val €thl_line_width› : int ref = ref 13;
val side_effect =
my_new_int_control{name="thl_line_width",
	control=thl_line_width, check=
	fn i =>	i >= 0 orelse thl_fail "thl_line_width",
	default = fn() => 13};

val €thl_tab_width› : int ref = ref 50;
val side_effect =
my_new_int_control{name="thl_tab_width",
	control=thl_tab_width, check=
	fn i =>	i >= 0 orelse thl_fail "thl_tab_width",
	default = fn() => 50};

val €thl_char_width› : int ref = ref 7;
val side_effect =
my_new_int_control{name="thl_char_width",
	control=thl_char_width, check=
	fn i =>	i > 0 orelse thl_fail "thl_char_width",
	default = fn() => 7};

val €thl_chars_per_tab› : int ref = ref 5;
val side_effect =
my_new_int_control{name="thl_chars_per_tab",
	control=thl_chars_per_tab, check=
	fn i =>	i >= 0 orelse thl_fail "thl_chars_per_tab",
	default = fn() => 5};
=TEX

\subsection{The Lister}

=SML
fun €latex_ii› (stream : outstream) : IO_INFO = (
	let	val ll = get_int_control "thl_line_width";
		val latextabstop = get_int_control "thl_tab_width";
		val char_width = get_int_control "thl_char_width";
		val list_indent = get_int_control "listing_indent";
		val chars_per_tab = get_int_control "thl_chars_per_tab";
		fun latexsize (s : string) : int = (
			(size s * char_width + latextabstop) div latextabstop
		);
	in	{	pad=latexpad,
			siz=latexsize,
			outp= fn s=>output(stream, translate_for_output s),
			boln="",
			eoln="\n",
			bbanner= "=THEORYLISTINGBANNER\n",
			ebanner= "\n=TEX\n",
			btrailer= "=THEORYLISTINGTRAILER\n",
			etrailer= "\n=TEX\n",
			bsection= "=THEORYLISTINGSECTION\n",
			esection= "\n=TEX\n",
			btable= "=THEORYLISTINGTABLE\n",
			etable= "=TEX\n",
			bother= "=THEORYLISTINGOTHER\n",
			eother= "=TEX\n",
			add_index= true,
			width=ll,
			indent = list_indent,
			ppwidth=(ll - list_indent) * chars_per_tab}
	end
);
=TEX
=SML
fun €output_theory› {theory : string, out_file:string} : unit = (
	let	val stream =
			if out_file <> ""
			then open_out (translate_for_output out_file)
			else std_out;
	in
		(do_theory (latex_ii stream) 33031 theory)
		handle ex => (
			if area_of ex = "do_theory"
			then reraise ex "output_theory"
			else raise ex
		);
		if out_file <> "" then close_out stream else ()
	end	handle ex as Io _ =>
		fail "output_theory" 33101 [fn()=>out_file, fn()=>string_of_exn ex]
);
=TEX

\subsection{The File Lister}

This uses the same format as the screen lister.

=SML
fun €output_theory1› {theory : string, out_file:string} : unit = (
	let	val stream =
			if out_file <> ""
			then open_out (translate_for_output out_file)
			else std_out;
	in
		(do_theory (screen_ii stream) 33001 theory)
		handle ex => (
			if area_of ex = "do_theory"
			then reraise ex "output_theory1"
			else raise ex
		);
		if out_file <> "" then close_out stream else ()
	end	handle ex as Io _ =>
		fail "output_theory1" 33101 [fn()=>out_file, fn()=>string_of_exn ex]
);
=TEX
\subsection{The Application-Defined Listers}
=SML
fun €gen_theory_lister_aux› (chk : bool) (secs : LISTER_SECTION list) :
	{print : (string -> string) -> string -> unit,
	out : (string -> string) -> {theory: string, out_file: string} -> unit,
	out1 : (string -> string) -> {theory: string, out_file: string} -> unit} = (
	let	fun print banner thy = (
			(gen_do_sections chk (screen_ii std_out) banner thy secs)
				handle ex => (
					if area_of ex = "gen_do_sections"
					then reraise ex "gen_theory_lister"
					else raise ex
				)
		);
		fun out f banner {theory : string, out_file:string} = (
			let	val stream =
					if out_file <> ""
					then open_out (translate_for_output out_file)
					else std_out;
			in	gen_do_sections chk (f stream) banner theory secs
				handle ex => (
					if area_of ex = "gen_do_sections"
					then reraise ex "gen_theory_lister"
					else raise ex
				);
				if out_file <> "" then close_out stream else ()
			end
			handle ex as Io _ =>
				fail "gen_theory_lister" 33101
				[fn()=>out_file, fn()=>string_of_exn ex]
		);
	in	{print=print, out=out latex_ii, out1= out screen_ii}
	end
);
=TEX
=SML
val €gen_theory_lister› : LISTER_SECTION list ->
	{print : (string -> string) -> string -> unit,
	 out : (string -> string) -> {theory: string, out_file: string} -> unit,
	 out1 : (string -> string) -> {theory: string, out_file: string} -> unit} =
	gen_theory_lister_aux true;
=TEX
=SML
val €gen_theory_lister1› : LISTER_SECTION list ->
	{print : (string -> string) -> string -> unit,
	 out : (string -> string) -> {theory: string, out_file: string} -> unit,
	 out1 : (string -> string) -> {theory: string, out_file: string} -> unit} =
	gen_theory_lister_aux false;
=TEX
\section{EPILOGUE}
=SML
end; (* of structure ListerSupport *)
structure Lister : Lister = ListerSupport;
structure ListerSupport : ListerSupport = ListerSupport;
open Lister;
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}
