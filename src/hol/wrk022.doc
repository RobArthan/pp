=TEX
\documentstyle[hol,11pt,TQ]{article}
%
% PRINTING THEORY LISTINGS
% ======== ====== ========
% Use the following command to hol to generate the theory listing:
%	output_theory{theory="wrk022", outfile="wrk022.thl.doc"};
% Then use the shell command
%	doc4tex wrk022.thl
% to generate wrk022.thl.tex. THIS SECOND STEP NEEDS THE SCREENFILE
% IN THE DIRECTORY TO BE THE IED SCREENFILE AT AT LEAST VERSION 1.5
% Then print off this document in the normal way. 
%
% LaTeX hacks
%
\makeatletter
% The following definition makes ˜ print as a diamond symbol
\def˜{\@Mm{\diamondsuit}}
%
% next two definitions get around a problem with indexing things whose
% declarations occur in strings etc:
%
\def\HOLindex#1{{\bf#1}}
\def\myindex#1{\HOLsetchars\index{$#1$}}
%
% Next three definitions set up the environment used for theory listings.
%
\def\@thlist{\bgroup
 \HOLsetchars\let\+=\relax\let\\=\cr
  \catcode`\^^I=4
  \halign\bgroup
  \hbox to 1.2in {$##$\hss} &&\hbox to 0.5in{$##$\hss}\hfil\cr}
\def\@endthlist{\egroup\egroup}
\newenvironment{thlist}{\par\@thlist}{\@endthlist}
\makeatother
% That's sll the LaTeX hacks.
\ftlinepenalty=9999
\makeindex
\TPPproject{FORMAL METHODS UNIT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Modal Logic in HOL}  %% Mandatory field
\TPPref{DS/FMU/IED/WRK022}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Informal}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D. Arthan &WIN01&}
\TPPabstract{The possible
worlds semantics for the modal propositional calculus is defined
in HOL and some well-known theorems about the
semantics are proved. The use of such a semantics to give proof support
for a modal logic is discussed.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    R.D.~Arthan \\ K.~Blackburn
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item[Issue 1.4 19 (August 1991)]First version.
\item[\SCCSversion (\FormatDate{$Date$%
})] Typos etc. corrected, index added.
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document reports on a brief investigation into embedding the
possible worlds semantics for modal logic in HOL.

The purpose of the investigation was to demonstrate some of the new
capabilities of the ICL HOL proof tool and to show
by means of examples
how a semantic embedding of this sort is used to provide
proof support for formalisms other than HOL.

The treatment of the possible worlds semantics we give is by no means new.
It is essentially just a translation into HOL (i.e. polymorphic type theory)
of the sort of set-theoretic treatment which may be found
in any text-book on modal logic, for example, \cite{Boolos79}.


\subsection{Introduction}
\subsubsection{Modal Logics}
Modal propositional calculus is the ordinary propositional calculus
augmented by an additional connective, $ÿ$. If $A$ is a proposition
then $ÿA$, the {\em necessitation} of $A$, was originally intended
to connote the idea that $A$ was, in some sense, a necessary rather
than a contingent fact. The semantics for this calculus due to
Kripke, explicates this notion of necessity in terms of systems,
called {\em frames} in the literature
A frame comprises a set of
{\em possible worlds} supplied with a relation of {\em accessibility}
between worlds. A proposition is viewed as necessary in a world
if its truth in a world, $x$, implies its truth in every world
accessible from $x$.

It turns out that by placing various constraints on the accessibility
relation, we arrive at semantics which interpret the
necessitation operator in interesting and useful ways, for example:

\begin{itemize}
\item
transitive accessibility relations for which all ascending chains
are finite correspond to
a view of $ÿ$ which is closely related to the provability
predicate for Peano arithmetic. This leads to a useful conceptual framework
for understanding provability, consistency and self-reference
in the theory of arithmetic (see \cite{Boolos79}).
\item
Various forms of linear accessibility relation correspond to a view of $ÿ$
as a temporal operator, with $ÿA$ meaning that $A$ will always hold
if it holds now (see, e.g., \cite{Benthem88}).
\item
Taking the worlds as the states of a computer and taking ``$x$ is accessible
from $y$'' to mean ``$x$ results when we execute program $p$ in state $y$'',
we get a modal logic which is closely connected with weakest-precondition
semantics for programming languages (see \cite{Benthem88}).
\item
Taking the worlds as the possible states of knowledge (or belief)
of some individual and taking
the accessibility to represent ways in which these states
grow through the acquisition of new knowledge (or belief), we get various forms
of {\em epistemic modal logic} or ({\em doxastic
modal logic}, in which $ÿA$ means that $A$ is known (or believed).
Such logics, usually extended to cover relationships between
the knowledge (or belief) of several individuals,
have many applications in artificial intelligence and in
the study of communication protocols in distributed computer systems
(see \cite{Ramsay88,burrows89}).
\end{itemize}

In the sequel we are going to formalise the possible worlds semantics
in HOL and prove the semantic justification of two rules
of inference for modal logic.

We will also prove some theorems, due to Kripke about
some axioms used in various modal calculi.
To state the axioms we introduce the {\em possibility} operator, $\diamondsuit$.
$\diamondsuit A$ is defined as $å(ÿ(åA))$. 
In each case, the theorem we prove says that an axiom is valid provided
the accessibility relation possesses a certain property. The axioms
and properties are shown in the following table:

\begin{center}
\begin{tabular}{|l|l|l|}\hline
Axiom 1 & $ÿAäA$ & Reflexive \\\hline 
Axiom 2 & $ÿAäÿ(ÿA)$ & Transitive \\\hline 
Axiom 3 & $Aäÿ(˜A)$ & Symmetric \\\hline 
Axiom 4 & $˜Aäÿ(˜A)$ & Euclidean \\\hline 
\end{tabular}
\end{center}

(The notion of a euclidean relation is defined in section \ref{AUXILIARYDEFINITIONS}
below.)

Note that the appropriateness of the above axioms depends on the application.
For example, they are all arguably appropriate for the epistemic reading,
for which, say, 2 is the so-called principle of ``positive introspection'':
`if $A$ is known, then it is known that $A$ is known.
However axiom 1 is inappropriate for the doxastic reading: we have no
reason to believe that $A$ is true just because it is believed.

\subsection{The HOL Proof Tool}
HOL (Higher Order Logic) is a polymorphic version of Church's type theory
due to M.J.C. Gordon  \cite{gordon87}). A system produced
by Cambridge University supporting
machine-checked reasoning has been available in the public domain for
several years \cite{SRI89a}. The Cambridge HOL system has been widely
used for a range of verification tasks in academiac and has
been successfully exploited by a number of industrial users including
the Formal Methods Unit at ICL.

ICL are currently engaged in a research programme into formal proof
technology which includes a re-engineering of the HOL proof tool to
meet more fully the requirements of industrial use and to give a basis
for exploiting more recent research on the HOL technology. The ICL HOL
proof tool has been specifically designed with a view to its use to
provide support for specification and proof in formalisms other
than the HOL logic itself.
After a significant prototyping exercise early in the project,
a first version of this system is currently being integrated and tested.


As the HOL logic is well-established and uncontroversial
mathematically, and as the HOL proof tools
are constructed so as to maximise assurance in the
correctness of the theorems it proves with respect
to that logic, use of HOL to support other formalisms
means that the soundness of such support tools {\em ad hoc} does not
have to be established on an {\em ad hoc} basis.

Space does not permit us to give a full exposition of the operation
of the HOL proof tool here. However, we hope that some aspects of
this will be clear from the examples we give. It may be worth mentioning
some basic concepts. The system is implemented in the interactive
functional programming language Standard ML. ML, often referred to
as the {\em metalanguage}, also acts as the command language through which
the user interacts with the system.

The types and terms of the HOL language are implemented as abstract
data types, $TYPE$ and $TERM$.
The constructors of the
data type of terms guarantee that all values of type $TERM$ obey
the typing rules of the HOL language. Proof is conducted, at the most
primitive level, by computing theorems, i.e. values of an abstract
data type, $THM$. The constructors of this abstract data type implement
the primitive inference rules of the
logic. Thus, the only way to compute a theorem is via a sequence of
primitive inferences, and so any value of type $THM$ is indeed a theorem
of the HOL logic. On top of this logical kernel are implemented a wide
range of proof procedures which assist the user in performing proofs.
The great merit of this organisation of the system is that the logical
kernel guarantees that the soundness of the system cannot be compromised
by infelicities in the coding of these derived proof procedures.

\subsubsection{Notation}
The present document is a
{\em literate script} containing a mixture of narrative
text and input for the ICL HOL system, which
is a tool for developing specifications and proofs in
the mathematical notation HOL.
Thus
The appendix contains a listing of the HOL theory set up by the script.

The inputs for HOL consists of a sequence of commands in an extension
of the interactive programming language Standard ML.


HOL constants are introduced using constant definition
boxes which have the form:
 »
	c : ty
…
	P
À
The intention of this is to introduce a new constants, $c$, 
of type $ty$, satisfying the property $P$. In the present document
$P$ will usually be a simple equation definition of a value or a function.

\subsection{HOL Preamble}
The following HOL commands create a new HOL theory in which
we will save our definitions and theorems and then  make some
special symbols we wish to use available.

=SML
open_theory"pair";
new_theory"wrk022";
ReaderWriterSupport.PrettyNames.add_new_symbols[(["box"], Value"ÿ",
	ReaderWriterSupport.PrettyNames.Simple)];
ReaderWriterSupport.PrettyNames.add_new_symbols[(["diamond"], Value"˜",
	ReaderWriterSupport.PrettyNames.Simple)];
=IGN
open_theory"pair";
delete_theory"modal_logic";
=TEX
\section{AUXILIARY DEFINITIONS}\label{AUXILIARYDEFINITIONS}
We need definitions of the concepts of $reflexive$, $transitive$,
$symmetric$ and $euclidean$ relations in HOL.

HOL is a polymorphic variant
of Church's type theory. Properties of values of type $\tau$ are
represented as propositional functions, that is to say they are
objects of type $\tau ã BOOL$, where $BOOL$ is the two-point type
of truth values. A binary relation on a type $\tau$
is a two-argument propositional function, i.e., it has type
$\tauã\tauãBOOL$.

Polymorphism allows us to use variables
which range over types, such type variables are distinguished syntactically
by having names beginning with the character $'$.
The propositional functions $Reflexive$, $Transitive$, etc. which
we will shortly define are polymorphic constants, they may be applied
to any value whose type has the form $\tauã\tauãBOOL$.

The definitions of the four properties of relations we need follow:

»
	Reflexive: ('a ã 'a ã BOOL) ã BOOL
…
	Érelé Reflexive rel Ç Éxé rel x x
À
\myindex{Reflexive}
»
	Transitive: ('a ã 'a ã BOOL) ã BOOL
…
	Érelé Transitive rel Ç Éx y zé rel x y Ä rel y z ä rel x z
À
\myindex{Transitive}
»
	Symmetric: ('a ã 'a ã BOOL) ã BOOL
…
	Érelé Symmetric rel Ç Éx yé rel x y ä rel y x
À
\myindex{Symmetric}
»
	Euclidean: ('a ã 'a ã BOOL) ã BOOL
…
	Érelé Euclidean rel Ç Éx y zé rel x y Ä rel x z ä rel y z
À
\myindex{Euclidean}

\section{POSSIBLE WORLD SEMANTICS IN HOL}
\subsection{Frames}
In a set-theoretic treatment a {\em frame} consists of a non-empty set $W$, of
{\em possible worlds}, equipped with a binary relation, $R$, the
{\em accessibility} relation. We will use a type variable
$'W$ to represent the set of possible worlds, so that our general treatment
can be instantiated to a particular type of possible worlds.
We can thus capture the notion
of a frame using the following type abbreviation:
=SML
declare_type_abbrev (‚"FRAME"·, ["'W"], ª:'W ã 'W ã BOOLº);
=TEX
\myindex{FRAME}
The above declaration introduces a new type abbreviation $FRAME$ with a single
formal parameter $'W$; The effect of the declaration is that, for example,
the type expression  $ª{:}(Ü)FRAMEº$ will represent the type
$ª:Ü ã Ü ã BOOLº$ of binary
relations on the type $Ü$ of natural numbers. Thus a value
of type $ª{:}(Ü)FRAMEº$ can be viewed as a frame in which the possible
worlds are numbers.

We will use the variable $R$ for accessibility relations,
and $x$, $y$ and $z$ for worlds. 
=TEX
\subsection{Valuations}
A {\em valuation} will be a function assigning a truth-value to every possible
world. In a syntactic treatment we would work with an {\em evaluator}
assigning valuations in this sense to the propositional variables. In our
approach we can use HOL variables of the appropriate type to represent
the semantics directly. We use the following type abbreviation for
valuations:
=SML
declare_type_abbrev (‚"VALUATION"·, ["'W"], ª:'W ãBOOLº);
=TEX
\myindex{VALUATION}
Thus, for example, a value of type $ª{:}(Ü)VALUATIONº$ is a propositional function on
the natural numbers.

We will use the variables $A$, $B$ and $C$ for valuations.
\subsection{Propositional Connectives}
It is straightforward to give the semantics of the ordinary
propositional connectives in their modal guise.
In each case the modal version of a connective
combines the valuations which are its operands to give a valuation
which asserts that for every world
the corresponding propositional connective holds
between the values taken by the operands in that world.
The definitions of these connectives are therefore independent of
any accessibility relation.

We will take implication and negation as our primitive connectives
and define others in terms of them:

»
	‚ä_modal·: ('W)VALUATION ã ('W)VALUATION ã ('W)VALUATION
…
	ÉA B xé ä_modal A B x Ç A x ä B x
À
\myindex{ä\_modal}
 
»
	‚å_modal·: ('W)VALUATION ã ('W)VALUATION
…
	ÉA xé å_modal A x Ç åA x
À
\myindex{å\_modal}
In making the above definitions, we had to distinguish the names for the modal
connectives from those already reserved for the propositional connectives
in HOL. The alias mechanism supported by ICL HOL allows us to use
the usual names instead as syntactic abbreviations. The following
declarations achieve this:
=SML
declare_alias(‚"ä"·, ªä_modal: ('W)VALUATION ã ('W)VALUATION ã ('W)VALUATIONº);
declare_alias(‚"å"·, ªå_modal: ('W)VALUATION ã ('W)VALUATIONº);
=TEX
To see how this works, we can now use a more natural syntax for
the definition of modal disjunction and conjunction:

»
	‚Å_modal·: ('W)VALUATION ã ('W)VALUATION ã ('W)VALUATION
…
	ÉA Bé Å_modal A B = (åA ä B)
À
\myindex{Å\_modal}
»
	‚Ä_modal·: ('W)VALUATION ã ('W)VALUATION ã ('W)VALUATION
…
	ÉA Bé Ä_modal A B = å(A ä åB)
À
\myindex{Ä\_modal}
Note here that $å$ and $ä$ refer to the modal connectives. The HOL
$å$ and $ä$ may still be used --- the ICL HOL system
identifies the appropriate internal representation on the basis of the types
of the operands.

As with the other connectives we make alias declarations for the
modal disjunction and conjunction:
=SML
declare_alias("‚Å·", ªÅ_modal: ('W)VALUATION ã ('W)VALUATION ã ('W)VALUATIONº);
declare_alias("‚Ä·", ªÄ_modal: ('W)VALUATION ã ('W)VALUATION ã ('W)VALUATIONº);
=TEX


\subsection{Necessitation}
The necessitation operator, $ÿ$, is defined with respect to
a given frame $R$; The necessitation of a valuation, $A$, is the valuation
which is true at a world $x$ if and only if $A$ is true at every world
accessible from $x$. The HOL definition of this is as follows
»
	‚ÿ·: ('W)FRAME ã ('W)VALUATION ã ('W)VALUATION
…
	ÉR A xé ÿR A x Ç Éyé R x y ä A y
À
\myindex{ÿ}
\subsection{Possibility}
The possibility operator, $˜$, is defined in terms of
necessitation and negation as follows:
»
	‚˜·: ('W)FRAME ã ('W)VALUATION ã ('W)VALUATION
…
	ÉR Aé ˜R A = å(ÿR(åA))
À

\subsection{Validity}
A valuation is valid if it is true in every world. Thus:
»	
	‚Valid·: ('W)VALUATION ã BOOL
…
	ÉAé Valid A Ç Éxé A x
À
\myindex{Valid}
\subsection{A Rewrite System}

In the sequel, we will use the above definitions to prove some theorems
about the semantics. The proofs will have a common pattern, in which
the first step is to expand out the above definitions to reduce the goal
to be proved to a proposition in the predicate calculus. The following
ML command gives us an ML value containing the list of defining theorems
which we use to do this.
=SML
val ‚modal_rewrites· = map snd (get_defns"-");
=TEX
\myindex{modal\_rewrites}
This pattern of proof is common in most applications of HOL: at the beginning
of building a theory, one often has to reduce problems to first principles.
Usually, once one has established a basic repertoire of theorems
characterising the problem domain, subsequent
proofs are performed at a higher-level using the characterising theorems.

\section{INFERENCE RULES}\label{INFERENCERULES}
Using the definitions of the previous section we can now prove
some results about the the modal operators.
In this section we prove two theorems which are the semantic justifications
for the two inference rules usually associated with modal logics.


\subsection{Modus Ponens}
The rule of modus ponens for modal logic is given by the following
HOL theorem.
As an inference rule, modus ponens says that from (the theoremhood of)
$A\,ä\,B$ and (the theoremhood of) $A$ we may infer
(the theoremhood of) $B$.
The semantic justification of this is the theorem we shall now 
prove which asserts that if
$A\,ä\,B$ and $A$ are valid, then so is $B$.

In the following statement of this theorem note that the conjunction
and the second implication are the HOL logical connectives. The first
implication is the modal one.
=SML
push_goal([], ªÉA Bé Valid (A ä B) Ä Valid A ä Valid Bº);
=TEX
The above command initiates a session with the ICL HOL subgoal package,
the standard means of finding proofs by a goal oriented search.
Goals are reduced to subgoals by applying tactics. A discussion of
how proofs are conducted is outside the scope of this document.
The proofs give here follow a common pattern. First we rewrite with
the definitions to reduce the goal to a predicate calculus proposition.
We then break this down using the standard tactic for simplifying
such propositions, $strip\_tac$.
This simplification gives us a simpler goal and some assumptions
with which to prove it. In most of the present proofs, one or more of the
assumptions turns out to be a universally quantified
formula, which we use to prove the goal by specialisation and rewriting.
=SML
a(rewrite_tac modal_rewrites);
a(REPEAT strip_tac);
a(POP_ASM_T (ante_tac o simple_É_elimªxº) THEN asm_rewrite_tac[]);
=TEX
This completes the proof of our goal. We save the theorem in
the HOL theory as follows:
=SML
val ‚modal_mp_thm· = save_thm("modal_mp_thm", pop_thm());
=TEX
\myindex{modal\_mp\_thm}
\subsection{Necessitation}
The rule of necessitation says that from $A$ we may infer $ÿA$.
Again this rule holds for any accessibility relation.
=SML
push_goal([], ªÉR:('W) FRAME; Aé Valid A ä Valid (ÿR A)º);
=TEX
=SML
a(rewrite_tac modal_rewrites);
a(REPEAT strip_tac THEN asm_rewrite_tac[]);
=TEX
=SML
val ‚necessitation_thm· = save_thm("necessitation_thm", pop_thm());
=TEX
\myindex{necessitation\_thm}
\section{FOUR AXIOMS}
In this section we prove the promised four theorems about the interplay
between certain modal axioms and properties of the accessibility
relation. 
\subsection{Axiom 1}
This axiom holds for reflexive accessibility relations:
=SML
push_goal([], ªÉRé Reflexive R ä ÉAé Valid(ÿR A ä A)º);
=TEX
=SML
a(rewrite_tac modal_rewrites);
a(REPEAT strip_tac);
a(POP_ASM_T (ante_tac o simple_É_elimªxº) THEN asm_rewrite_tac[]);
=TEX
=SML
val ‚axiom1_thm· = save_thm("axiom1_thm", pop_thm());
=TEX
\myindex{axiom1\_thm}
\subsection{Axiom 2}
This axiom holds for transitive accessibility relations:
=SML
push_goal([], ªÉRé Transitive R ä ÉAé Valid(ÿR A ä ÿR (ÿR A))º);
=TEX
=SML
a(rewrite_tac modal_rewrites);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (ante_tac o list_simple_É_elim[ªxº, ªyº, ªy'º]) THEN asm_rewrite_tac[]);
=TEX
=SML
val ‚axiom2_thm· = save_thm("axiom2_thm", pop_thm());
=TEX
\myindex{axiom2\_thm}
\subsection{Axiom 3}
This axiom holds for symmetric accessibility relations:
=SML
push_goal([], ªÉRé Symmetric R ä ÉAé Valid(A ä ÿR (˜R A))º);
=TEX
=SML
a(rewrite_tac modal_rewrites);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 3 (ante_tac o list_simple_É_elim[ªxº, ªyº]) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN simple_Ñ_tacªxº THEN asm_rewrite_tac[]);
=TEX
=SML
val ‚axiom3_thm· = save_thm("axiom3_thm", pop_thm());
=TEX
\myindex{axiom3\_thm}
\subsection{Axiom 4}
This axiom holds for euclidean accessibility relations:
=SML
push_goal([], ªÉRé Euclidean R ä ÉAé Valid(˜R A ä ÿR (˜R A))º);
=TEX
=SML
a(rewrite_tac modal_rewrites);
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 4 (ante_tac o list_simple_É_elim[ªxº, ªy'º, ªyº]) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN simple_Ñ_tacªyº THEN asm_rewrite_tac[]);
=TEX
=SML
val ‚axiom4_thm· = save_thm("axiom4_thm", pop_thm());
=TEX
\myindex{axiom4\_thm}
\section{PROOF SUPPORT FOR A MODAL LOGIC}
In this section we implement inference rules for modal logic,
and also implement (as a proof procedure in HOL) the axiom schema for 
the modal logic traditionally called $T$.

\subsection{Implementing the Rules}
In this section we implement derived rules in HOL corresponding
to the theorems proved in section \ref{INFERENCERULES} above.

=SML
fun ‚modal_mp_rule· (thm1 : THM) (thm2 : THM) : THM = (
	simple_ä_match_mp_rule modal_mp_thm (Ä_intro thm1 thm2)
);
=TEX
=SML
fun ‚nec_rule· (thm : THM) : THM = (
	simple_ä_match_mp_rule modal_mp_thm thm
);
=TEX
It is usual in modal calculi to take all ordinary propositional
tautologies as axioms. The following ML code implements this on
the basis of our semantic definitions by rewriting with the
definitions of validity and all the modal connectives except ÿ and then
using an HOL tactic to prove the resulting tautology.
=SML
fun ‚modal_taut_rule· (tm : TERM) : THM = (
	tac_proof( ([], tm),
	rewrite_tac
	(map(get_defn"-")
	["˜", "Ä_modal", "Å_modal", "å_modal", "ä_modal", "Valid"])
	THEN REPEAT strip_tac)
);
=TEX
Evaluating $modal\_taut\_rule\,tm$ will prove the
theorem $Ö\,tm$ if $tm$ is a modal tautology.
As an example, evaluating:
=SML
modal_taut_rule ªValid((A ä B) ä (åB ä åA))º;
=TEX
gives the following theorem:
ÛHOL Output
val it = Ö Valid ((A ä B) ä å B ä å A) : THM 
Ê  
=TEX
\subsection{Implementing the Axiom Schema}
With reference to our theorem about axiom 1, to implement the system $T$
we will assume that some unspecified accessibility relation
$R$ is symmetric throughout.
Thus our starting point is the following 
rule which proves instances of axiom 1 on the assumption of a symmetric
accessibility relation.
=SML
fun ‚axiom1_rule· (tm : TERM) : THM = (
	Ç_t_elim(rewrite_conv[undisch_rule(all_simple_É_elim axiom1_thm)] tm)
);
=TEX
\subsection{Example Proofs}

As examples, we will prove the (semantic justifications of)
the following two theorems of the system $T$ which comprise
theorem 6 of chapter 1 of \cite{Boolos79}:

ÛInformal Example
Ö A ä ˜A
Ö ÿA ä ˜A
Ê
The following sequence of computations is the HOL implementation
of the proof of these results given in \cite{Boolos79}. After each step
we show the output produced by the HOL system.
=SML
val ‚lemma1· = axiom1_rule ªValid(ÿR (åA) ä åA)º;
ÛHOL Output
val lemma1 = Reflexive R Ö Valid (ÿ R (å A) ä å A) : THM   
Ê
=SML
val ‚lemma2· = modal_taut_ruleªValid((ÿR(åA) ä åA) ä (A ä ˜R A))º;
ÛHOL Output
val lemma2 = Ö Valid ((ÿ R (å A) ä å A) ä A ä ˜ R A) : THM   
Ê
=SML
val ‚result1· = save_thm("result1", modal_mp_rule lemma2 lemma1);
ÛHOL Output
val result1 = Reflexive R Ö Valid (A ä ˜ R A) : THM   
Ê
=SML
val ‚lemma3· = modal_taut_ruleªValid((ÿR A ä A) ä (A ä ˜R A) ä (ÿR A ä ˜R A))º;
ÛHOL Output
val lemma3 = Ö Valid ((ÿ R A ä A) ä (A ä ˜ R A) ä ÿ R A ä ˜ R A) : THM   
Ê
=SML
val ‚lemma4· = axiom1_rule ªValid(ÿR A ä A)º;
ÛHOL Output
val lemma4 = Reflexive R Ö Valid (ÿ R A ä A) : THM   
Ê
=SML
val ‚lemma5· = modal_mp_rule lemma3 lemma4;
ÛHOL Output
val lemma5 = Reflexive R Ö Valid ((A ä ˜ R A) ä ÿ R A ä ˜ R A) : THM   
Ê
=SML
val ‚result2· = save_thm("result2", modal_mp_rule lemma5 result1);
ÛHOL Output
val result2 = Reflexive R Ö Valid (ÿ R A ä ˜ R A) : THM   
Ê
=SML
=TEX

\section{PRACTICAL SYSTEMS}
While based on a semantics similar to the semantics discussed here,
systems of modal logic intended for practical applications,
e.g. for program verification or protocol verification, will
involve application-specific syntactic features. It is important
for the ease of use of proof tools that the user should
interact with the tool using the natural formalism for the task at hand.
As we have seen, this can come with very little extra work in the case of
a sufficiently simple logical language.

Proof support offering this feature for more complex languages
may be supplied by combining
a semantic approach like the one given here  with use of the facilities
offered by the HOL proof development system for manipulating syntax.
This technique is usually referred to as {\em semantic embedding} (as
opposed to a {\em syntactic} treatment, in which one would use HOL to reason
about syntactic notions, e.g. inference rules, rather than
semantic ones, e.g. the accessibility relation in the present treatment of
modal propositional logic).

In the semantic embedding technique,
sentences of the language to be supported are represented by
semantically equivalent HOL terms.
A parser maps sentences in the desired
concrete syntax to the underlying HOL and a pretty-printer automatically
inverts this mapping when terms are displayed.
Tools assisting in the production of parsers and pretty-printers are
supplied in HOL.
On the basis of theorems proved about the semantic objects
proof procedures
may be produced which preserve the required syntax as far as the user
is concerned (usually by customising existing proof procedures for HOL).
If valid inference rules for the language are known, then they
can be used as the basis for such proof procedures
(this would be the role of the sort of
theorem proved in this document).  

An important advantage of the semantic embedding techniques is
that, compared with other approaches, such as coding a complete system
for manipulating syntax from scratch,
it drastically reduces the amount of code in which
errors can make the system inconsistent (i.e. allow the user to prove
an invalid result).

A system of this sort offering proof support for Z is currently being
prototyped in ICL and good results are emerging.
Z is in many respects much harder to accomodate than most of
the formalisms based on modal logics
which have been proposed for computer science applications, and so such
formalisms promise to be good applications for this semantic
embedding techniques.
TEX
{\small
\twocolumn[\section{INDEX}]
\printindex}
=TEX
\onecolumn
\appendix
\input{wrk022.thl.tex}
\end{document}
