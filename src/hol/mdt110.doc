% mdt005.doc %Z% $Date$ $Revision$ $RCSfile$

=TEX
% mdt005.doc %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol1,11pt,TQ]{article}

\TPPtitle{Module Tests of the File and Terminal Reader Writer}
\def\TPPheadtitle{Module Tests of the File and\cr Terminal Reader Writer}
\TPPref{DS/FMU/IED/MDT005}
\def\SCCSissue{$Revision$%
}
\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{FST PROJECT}

=IGN

Commands to process this document in various ways.

doc4errors mdt005
usefile "mdt005.sml";

doc4tex mdt005
tex4dvi mdt005
bibtex mdt005
doc4tex mdt005 ; tex4dvi mdt005
pstex mdt005

lasp -s mdt005.doc > zz1
lasp -s -u mdt005.OKwords mdt005.doc > zz1

=TEX
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{SML Literate Script}
\TPPkeywords{HOL}
\TPPissue{\SCCSissue}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the module tests of the reading
	and writing functions that form the outermost level of user
	interface for Release~1 of ICL~HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\catcode`\_=\active
\def\_{\kern.06em\vbox{\hrule height.1ex width.3em}\hskip0.1em\relax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage
\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}

\item[Issues 1.1 to 1.2 ] Initial drafts.

\item[13 September 1991, issue 2.1 ] First approved issue.

\item[20 January 1992, issue 2.2 ] Updated to use new fonts.

\end{description}
%\subsection{Changes Forecast}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\newpage

\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains a a number of tests of the file and terminal
reading and writing functions which are contained in the ``Reader
Writer'' subsystem of Release~1 ICL~HOL.  The design and implementation
of the reader writer are in~\cite{DS/FMU/IED/DTD005}
and~\cite{DS/FMU/IED/IMP005} respectively.

%********************************************************************

\subsection{Introduction}

The `basic reader writer' of the Release~1 ICL~HOL system supports an
extension to Standard~ML that allows `extended characters' to be used
in Standard~ML text.  A second part of the basic reader writer, the
`embedding interface', allows readers for other languages to be
embedded, allowing the (enhanced) Standard~ML to be used as a
metalanguage for supporting work in other languages.

The tests within this document are those identified as ``functional
interfaces'' in the test strategy section of the detailed
design~\cite{DS/FMU/IED/DTD005}.

%--------------------------------------------------------------------

%\subsubsection{Purpose and Background}

%--------------------------------------------------------------------

\subsubsection{Dependencies}

These tests assume that the reader writer
files~\cite{DS/FMU/IED/DTD005} and~\cite{DS/FMU/IED/IMP005} have been
successfully compiled.  The facilities of the Module
Test Harness~\cite{DS/FMU/IED/DTD013} are used.

%--------------------------------------------------------------------

%\subsubsection{Interface}

%--------------------------------------------------------------------

%\subsubsection{Possible Enhancements}

%--------------------------------------------------------------------

%\subsubsection{Deficiencies}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TEST HARNESS INITIALISATION}

=IGN
Get the test harness files
sccs -d ~ied get dtd013.doc imp013.doc
doc4errors dtd013
doc4errors imp013

doc4errors mdt005
usefile "mdt005.sml";

=TEX

Load and initialise the module test system.

=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results ();
=TEX

An identity function is required for the `function to apply' in
some of the test cases.

=SML
fun I x = x;
=TEX

Characters and repeated characters.

=SML
val C_sp	: string = chr 32;	(* space *)
val C_dq	: string = chr 34;	(* double quote " *)  (*="=*)
val C_lq	: string = chr 96;	(* left quote ` *)
val C_nl	: string = chr 10;	(* newline \n *)
val C_ast	: string = chr 42;	(* asterisk * *)
val C_orb	: string = chr 40;	(* asterisk ( *)
val C_crb	: string = chr 41;	(* asterisk ) *)
val C_pc	: string = chr 37;	(* percent  *)
val C_Q	: string = chr 81;	(* letter Q *)

fun replicate ch num =
let fun aux n = if n <= 0 then nil else ch ::(aux (n-1));
in implode(aux num)
end;
fun stars n = replicate C_ast n;
fun b_stars n = C_orb ^ (stars n) ^ C_crb;
=TEX

Some functions to wrap strings with various characters.

=SML
fun W_pc s = C_pc ^ s ^ C_pc;
fun W_dq s = C_dq ^ s ^ C_dq;
fun W_1Q s = C_Q ^ s ^ C_Q;
fun W_2Q s = C_Q ^ (W_1Q s) ^ C_Q;
fun W_3Q s = C_Q ^ (W_2Q s) ^ C_Q;
fun W_4Q s = C_Q ^ (W_3Q s) ^ C_Q;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{STRING TESTS}

Some tests that Standard~ML comments, strings and various expressions
are treated properly.  Build some strings using Standard~ML.  Strings
are tested first since they are also used for test identification.

=SML
store_mt_results_show mt_run[
("str_01", I, "ab\     \cd", "abcd"),
("str_02", I, "ab\

  \cd", "abcd"),
("str_03", I, "ab\  \  \"", "ab  " ^ C_dq),  (*="=*)
("str_04", I, "abc{\nd", "abc{" ^ C_nl ^ "d"),
("str_05", I, "abc\"def", "abc" ^ C_dq ^ "def"),  (*="=*)
("str_06", I, "abc`def", "abc" ^ C_lq ^ "def"),
("str_07", I, "abc```def", "abc" ^ C_lq ^ C_lq ^ C_lq ^ "def")
];
=TEX

{\NoMoaning
=SMLLITERAL
store_mt_results_show mt_run[

("str_08", I, " €‚ƒ„…†‡ˆ‰\
	\Š‹ŒŽ‘’“\
	\”•–—˜™š›œ\
	\žŸ ¡¢£¤¥¦§¨©ª\
	\«¬­®¯°±²³\
	\´µ¶·¸¹º»¼½¾¿ÀÁ\
	\ÂÃÄÅÆÇ\
	\ÈÉÊËÌÍÎÏÐ\
	\ÑÒÓÔÕÖ×ØÙ\
	\ÚÛÜÝÞß\
	\àáâãäåæ\
	\çèéêëì\
	\íîïðñòó\
	\ôõö÷øùúûüýþÿ ",
		" " ^ (implode(map chr (interval 128 255)) ^ " "))
];
=TEX
}

Check that asterisks are retained in strings so that
the `$us_\ldots$' tests are going to run as expected.

=SML
let
val C_ast_20 = replicate C_ast 20;

in
store_mt_results_show mt_run[
("str_09", I, "********************", C_ast_20),
("str_10", I, "*********************", C_ast_20^C_ast),
("str_11", I, "(********************)", "(" ^ C_ast_20 ^ ")"),
("str_12", I, "(*********************)", "(" ^ C_ast_20 ^ C_ast ^ ")")
]
end;
=TEX

=SML
store_mt_results_show mt_run[
("str_13", I, "", implode nil),
("str_14", I, "\n", C_nl),
("str_15", I, "\n\n", C_nl ^ C_nl),
("str_16", I, "\n\n\n", C_nl ^ C_nl ^ C_nl),
("str_17", I, "\123\077\000\255\127\128", (implode o map chr)
		[123, 077, 000, 255, 127, 128]),
("str_18", I, " \^A\^B\t", (implode o map chr)[ord C_sp, 1, 2, 9])
];
=TEX

There are many tests of the handling of percent ``{\tt\%}'' characters and
percent keywords in section~\ref{TranslatingForOutput} below.

\section{FUNCTION $usestring$ TESTS}

=SML
val us_ans : int ref = ref 0;

fun U x = (usestring x ; !us_ans);
=TEX

=SML
store_mt_results_show mt_run[
("us_01", U, "us_ans := 1", 1),
("us_02", U, "us_ans := 2", 2)
];
=TEX

Had some problems with long strings of asterisks
at one stage in the reader writer's development.

=SML
store_mt_results_show mt_run[
("us_03", U, "us_ans (**):=(***) !(****) us_ans(*****) +(******)1;", 3),
("us_04", U, "us_ans :=" ^ (b_stars 32) ^ " !us_ans+1;", 4),
("us_05", U, "us_ans :=" ^ (b_stars 33) ^ " !us_ans+1", 5),
("us_06", U, "us_ans :=" ^ (b_stars 34) ^ " !us_ans+1", 6),
("us_07", U, "us_ans :=" ^ (b_stars 35) ^ " !us_ans+1;", 7),
("us_08", U, "us_ans :=" ^ (b_stars 36) ^ " !us_ans+1", 8),
("us_09", U, "us_ans :=" ^ (b_stars 92) ^ " !us_ans+1", 9),
("us_10", U, "us_ans :=" ^ (b_stars 93) ^ " !us_ans+1;", 10),
("us_11", U, "us_ans :=" ^ (b_stars 94) ^ " !us_ans+1", 11),
("us_12", U, "us_ans :=" ^ (b_stars 95) ^ " !us_ans+1;", 12),
("us_13", U, "us_ans :=" ^ (b_stars 96) ^ " !us_ans+1", 13),
("us_14", U, "us_ans :=" ^ (b_stars 97) ^ " !us_ans+1", 14),
("us_15", U, "us_ans := !us_ans+1", 15)
];
=TEX

=SML
store_mt_results_show mt_run[
("us_16", U, "us_ans := !us_ans(*******(some text)***************************)+1", 16),
("us_17", U, "us_ans := !us_ans(************(some text)***********************)+1", 17),
("us_18", U, "us_ans := !us_ans(************(some text)************************)+1", 18),
("us_19", U, "us_ans := !us_ans(*(*(*comm(*co(*co(*comment*)ment*)ment\
	\*)nt*)om(*comment*)e(*comment*)t*)*)+1", 19),
("us_20", U, "us_ans := !us_ans (*(*(*comm(*co(*co(*comment*)ment*)men\
	\t*)nt*)om(*comment*)e(*comment*)t*)*) +1", 20)
];
=TEX

=SML
store_mt_results_show mt_run[
("us_21", U, "us_ans := !us_ans(* )))))))))))))))))))))))))))))))))))))))))*)+1", 21),
("us_22", U, "us_ans := !us_ans(*(((((((((((((((((((((((((((((( **)+1", 22),
("us_23", U, "us_ans := !us_ans(*((((((((((((((((((((((((((((((* *)*)+1", 23),
("us_24", U, "us_ans := !us_ans(*((((((((((((((((((((((((((((((**)*)+1", 24),
("us_25", U, "us_ans := !us_ans(*(**)))))))))))))))))))))))))))))))))))))))))*)+1", 25),
("us_26", U, "us_ans := !us_ans(*)))))))))))))))))))))))))))))))))))))))))*)+1", 26),
("us_27", U, "us_ans := !us_ans+1", 27),
("us_28", U, "us_ans := !us_ans+1", 28),
("us_29", U, "us_ans := !us_ans+1", 29)
];
=TEX

=IGN
("us_30", U, "us_ans := !us_ans+1", 30),
("us_31", U, "us_ans := !us_ans+1", 31),
("us_32", U, "us_ans := !us_ans+1", 32),
("us_33", U, "us_ans := !us_ans+1", 33),
("us_34", U, "us_ans := !us_ans+1", 34),
("us_35", U, "us_ans := !us_ans+1", 35),
("us_36", U, "us_ans := !us_ans+1", 36),
("us_37", U, "us_ans := !us_ans+1", 37),
("us_38", U, "us_ans := !us_ans+1", 38),
("us_39", U, "us_ans := !us_ans+1", 39),
];
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TRANSLATING FOR OUTPUT} \label{TranslatingForOutput}

Function $translate_for_output$, a lot of the test cases here are to
ensure that the strings being manipulated have the expected contents.
Remember that percent signs get processed on both input and output,
capital letter `{\tt Q}'s are processed on output, they are also
processed by function $translate_for_output$ which is the focus of
these tests.  Thus we must ensure that the input and output processing
is accommodated here.

=SML
let
val to_1 = "%Delta%";
val to_2 = "%%Delta%%";
val to_3 = "%Delta%%calA%";
val to_4 = "%%Delta%%%%calA%%";

val to_5 = "QQDeltaQQ";
val to_6 = "QQQQDeltaQQQQ";
val to_7 = "QQDeltaQQQQcalAQQ";
val to_8 = "QQQQDeltaQQQQQQQQcalAQQQQ";

val T = ReaderWriter.translate_for_output;
fun ST s = T(W_dq s);
in
set_flag("use_extended_chars", true);
=TEX

Check that the input strings are built correctly, by length and by content.

=IGN
map size[to_1, to_2, to_3, to_4, to_5, to_6, to_7, to_8];

=SML
store_mt_results_show mt_run[
("to_1a", size, to_1, 1),
("to_2a", size, to_2, 7),
("to_3a", size, to_3, 7),
("to_4a", size, to_4, 13),
("to_5a", size, to_5, 9),
("to_6a", size, to_6, 13),
("to_7a", size, to_7, 17),
("to_8a", size, to_8, 25)
];

store_mt_results_show mt_run[
("to_1b", I, to_1, "„"),
("to_2b", I, to_2, W_pc "Delta"),
("to_3b", I, to_3, "„" ^ (W_pc "calA")),
("to_4b", I, to_4, (W_pc "Delta") ^ (W_pc "calA")),
("to_5b", I, to_5, W_2Q "Delta"),
("to_6b", I, to_6, W_4Q "Delta"),
("to_7b", I, to_7, (W_2Q "Delta") ^ (W_2Q "calA")),
("to_8b", I, to_8, (W_4Q "Delta") ^ (W_4Q "calA"))
];
=TEX

Run the tests.  Function $T$ does a translate, function $ST$ encloses
the text in double quotes, then does a translate.

=SML
store_mt_results_show mt_run[
("to_1c", T, to_1, "„"),
("to_2c", T, to_2, "„"),
("to_3c", T, to_3, "„" ^ (W_pc "calA")),
("to_4c", T, to_4, "„" ^ (W_pc "calA")),
("to_5c", T, to_5, "„"),
("to_6c", T, to_6, "QDeltaQ"),
("to_7c", T, to_7, "„" ^ (W_pc "calA")),
("to_8c", T, to_8, "QDeltaQQcalAQ")
];

store_mt_results_show mt_run[
("to_1d", ST, to_1, W_dq "„"),
("to_2d", ST, to_2, W_dq "„"),
("to_3d", ST, to_3, W_dq("„" ^ (W_pc "calA"))),
("to_4d", ST, to_4, W_dq("„" ^ (W_pc "calA"))),
("to_5d", ST, to_5, W_dq(W_2Q "Delta")),
("to_6d", ST, to_6, W_dq(W_4Q "Delta")),
("to_7d", ST, to_7, W_dq((W_2Q "Delta") ^ (W_2Q "calA"))),
("to_8d", ST, to_8, W_dq((W_4Q "Delta") ^ (W_4Q "calA")))
];
=TEX

Run the tests again without using extended characters.

=SML
set_flag("use_extended_chars", false);

store_mt_results_show mt_run[
("to_1e", T, to_1, W_pc "Delta"),
("to_2e", T, to_2, W_pc "Delta"),
("to_3e", T, to_3, (W_pc "Delta") ^ (W_pc "calA")),
("to_4e", T, to_4, (W_pc "Delta") ^ (W_pc "calA")),
("to_5e", T, to_5, W_pc "Delta"),
("to_6e", T, to_6, W_1Q "Delta"),
("to_7e", T, to_7, (W_pc "Delta") ^ (W_pc "calA")),
("to_8e", T, to_8, (W_1Q "Delta") ^ (W_1Q "calA"))
];

store_mt_results_show mt_run[
("to_1f", ST, to_1, W_dq((W_pc "Delta"))),
("to_2f", ST, to_2, W_dq((W_pc "Delta"))),
("to_3f", ST, to_3, W_dq((W_pc "Delta") ^ (W_pc "calA"))),
("to_4f", ST, to_4, W_dq((W_pc "Delta") ^ (W_pc "calA"))),
("to_5f", ST, to_5, W_dq(W_2Q "Delta")),
("to_6f", ST, to_6, W_dq(W_4Q "Delta")),
("to_7f", ST, to_7, W_dq((W_2Q "Delta") ^ (W_2Q "calA"))),
("to_8f", ST, to_8, W_dq((W_4Q "Delta") ^ (W_4Q "calA")))
];

set_flag("use_extended_chars", true)
end;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TESTS OF SIMPLE FUNCTIONS}

Functions $local_error$ and $local_warn$ return units but print things out.

=SML
let open ReaderWriterSupport; in
store_mt_results_show mt_run[
("sf_local_error", local_error "aardvark" 5004, [fn () => "aardvark"], ()),
("sf_local_warn", local_warn "aardvark" 5011, nil, ())
] end;
=TEX

=SML
let open ReaderWriterSupport; in
store_mt_results_show mt_run[
("sf_add_error_code", add_error_code, (21, ["zzz"]), [" ERROR__21 ", "zzz"])
] end;
=TEX

=SML
let open ReaderWriterSupport; in
store_mt_results_show mt_run[
("sf_add_error_codes_1", add_error_codes, ([22, 23, 24], ["zzz"]),
	[" ERROR__22 ", " ERROR__23 ", " ERROR__24 ", "zzz"]),
("sf_add_error_codes_2", add_error_codes, (nil, ["zzz"]), ["zzz"])
] end;
=TEX

=SML
let open ReaderWriterSupport; in
store_mt_results_show mt_run[
("sf_is_special_char_1", is_special_char, "!", true),
("sf_is_special_char_2", is_special_char, ":", true),
("sf_is_special_char_3", is_special_char, "@", true),
("sf_is_special_char_4", is_special_char, "*", true),
("sf_is_special_char_5", is_special_char, "", false),
("sf_is_special_char_6", is_special_char, "!!", false),
("sf_is_special_char_7", is_special_char, C_dq, false),
("sf_is_special_char_8", is_special_char, " ", false),
("sf_is_special_char_9", is_special_char, "abc", false),
("sf_is_special_char_10", is_special_char, "A", false),
("sf_is_special_char_11", is_special_char, "b", false)
] end;
=TEX

=SML
let open ReaderWriterSupport; in
store_mt_results_show mt_run[
("sf_string_of_int3_1", string_of_int3, 0, "000"),
("sf_string_of_int3_2", string_of_int3, 1, "001"),
("sf_string_of_int3_3", string_of_int3, 27, "027"),
("sf_string_of_int3_4", string_of_int3, 145, "145"),
("sf_string_of_int3_5", string_of_int3, 367, "367"),
("sf_string_of_int3_6", string_of_int3, 998, "998"),
("sf_string_of_int3_7", string_of_int3, 999, "999")
] end;
=TEX

=SML
let open ReaderWriterSupport; in
store_mt_results_show mt_run[
("sf_to_ML_string_1", to_ML_string, " abcdef(* *)\n", " abcdef(* *)\n"),
("sf_to_ML_string_2", to_ML_string, "\241", "\\241"),
("sf_to_ML_string_3", to_ML_string, "\000\001\002", "\\000\\001\\002"),
("sf_to_ML_string_4", to_ML_string, "\126\127\128\129", "\126\\127\\128\\129"),
("sf_to_ML_string_5", to_ML_string, "\030\031\032\033\034", "\\030\\031\032\033\034"),
("sf_to_ML_string_6", to_ML_string, "\255\254\253", "\\255\\254\\253")
] end;
=TEX

=SML
let open ReaderWriterSupport; in
store_mt_results_show mt_run_fail[
("sf_string_of_int3_8", string_of_int3, 1000, gen_fail_msg "string_of_int3" 5040 ["1000"]),
("sf_string_of_int3_9", string_of_int3, ~1, gen_fail_msg "string_of_int3" 5040 ["~1"]),
("sf_string_of_int3_10", string_of_int3, ~1001,
			gen_fail_msg "string_of_int3" 5040 ["~1001"]),
("sf_string_of_int3_11", string_of_int3, 20051, gen_fail_msg "string_of_int3" 5040 ["20051"])
] end;
=TEX

\subsection{Extended Character Database}

First tests are to see if some expected keywords and characters are
present and absent.

=SML
let
open ReaderWriterSupport.PrettyNames;

fun	aux1 Simple = "Simple"
|	aux1 Ignore = "Ignore"
|	aux1 Invalid = "Invalid"
|	aux1 (Starting(_, str)) = "Starting" ^ str
|	aux1 (Middle str) = "Middle" ^ str
|	aux1 (Ending str) = "Ending" ^ str;

fun	aux2 Nil = Nil
|	aux2 (Value(a, b, c)) = Value(a, b, aux1 c);

fun N s = aux2(find_name s);
fun C s = aux2(find_char s);

in
=TEX

=SMLLITERAL
store_mt_results_show mt_run[
("ecd_1", N, "<", Value (["<"], Value "¬", "Starting")),
("ecd_2", N, "BT", Value (["BT"], Value "÷", "Middle),(")),
("ecd_3", N, "lambda", Value (["fn", "lambda"], Value "Ì", "Simple")),
("ecd_4", N, "fn", Value (["fn", "lambda"], Value "Ì", "Simple")),
("ecd_5", N, "notakeyword", Nil)
];

store_mt_results_show mt_run[
("ecd_6", C, "¬", Value (["<"], Value "¬", "Starting")),
("ecd_7", C, "÷", Value (["BT"], Value "÷", "Middle),(")),
("ecd_8", C, "Ì", Value (["fn", "lambda"], Value "Ì", "Simple")),
("ecd_9", C, "X", Nil),
("ecd_10", C, "Q", Value (["Q"], Value "Q", "Simple"))
]
end;
=TEX

These tests all return a value of type unit, they do not fail.
With some future version of the reader writer failure may be
more appropriate.

=SML
let	val A = ReaderWriterSupport.PrettyNames.add_new_symbols;
	val S = ReaderWriterSupport.PrettyNames.Simple;
in
store_mt_results_show mt_run[
("ans_1_5100", (fn () => true) o A, [
	([	"abcQQdef"],	Nil,				S),
	([	"QQdef"],	Nil,				S),
	([	"abcQQ"],	Nil,				S),
	([	"QQ"],		Nil,				S)
], true)
];

store_mt_results_show mt_run_fail[
("ans_2_5103", A, [
	([	"Q"],		Nil,				S)
], gen_fail_msg "add_new_symbols" 5103 [C_Q])
];

store_mt_results_show mt_run_fail[
("ans_3_5104", A, [
	([	"ans_3_5104"],	Value "Ì",			S)
], gen_fail_msg "add_new_symbols" 5104 ["Ì"])
];

store_mt_results_show mt_run[
("ans_4_5101", (fn () => true) o A, [
	([	],		Nil,				S)
], true)
];

store_mt_results_show mt_run[
("ans_5_5102", (fn () => true) o A, [
	([	],		Value "Ab",			S),
	([	],		Value "",			S)
], true)
]
end;
=TEX

\subsection{Reader Functions}

Setting and getting reader functions manipulates values of functional
type, indeed these functions are the access to a database of functional
values.  The module test harness does not allow comparison of
functional values so we only check the non-functional part of the
values returned.

=SML
let
fun GG s = case ReaderWriterSupport.look_up_general_reader s
		of Nil => Nil | Value (_, x) => Value x;
in
store_mt_results_show mt_run[
("rf_1a", GG, ("¬", "HOL"), Value "Lex.Term"),
("rf_2a", GG, ("¬", "HOL:"), Value "Lex.Type"),
("rf_6a", GG, ("¬", "XR"), Nil),
("rf_9a", GG, ("¬", ""), Value "Lex.Term")
]
end;
=TEX

=SML
let
fun GS s = case ReaderWriterSupport.look_up_specific_reader s
		of Nil => Nil | Value (_, x) => Value x;
in
store_mt_results_show mt_run[
("rf_3a", GS, "HOL", Nil),
("rf_4a", GS, "”", Value "Lex.Type"),
("rf_5a", GS, "XS", Nil),
("rf_10a", GS, "‘", Value "Lex.Term")
]
end;
=TEX

=SML
let
fun GN s = case ReaderWriterSupport.look_up_named_reader s
		of Nil => Nil | Value (_, x) => Value x;
in
store_mt_results_show mt_run[
("rfn_1a", GN, ("¹", ""), Nil),
("rfn_2a", GN, ("¹", "HOLCONST"), Value "NONE"),
("rfn_3a", GN, ("¹", "XS"), Nil)
]
end;
=TEX

General reader tests.

=SML
let
val add_G = ReaderWriterSupport.add_general_reader;
val look_G = ReaderWriterSupport.look_up_general_reader;

fun GG s = case look_G s of Nil => Nil | Value (_, x) => Value x;

val Value(SML_general_reader, "Lex.Term") = look_G ("¬", "");
in

store_mt_results_show mt_run[
("rf_add_1", (fn () => true) o add_G, ("¬", "XG", "rf_gg::rf_gg", SML_general_reader), true)
];

store_mt_results_show mt_run[
("rf_1b", GG, ("¬", "HOL"), Value "Lex.Term"),
("rf_2b", GG, ("¬", "HOL:"), Value "Lex.Type"),
("rf_6b", GG, ("¬", "XS"), Nil),
("rf_8b", GG, ("¬", "XG"), Value "rf_gg::rf_gg")
];

store_mt_results_show mt_run_fail[
("rf_add_3", add_G, ("¬", "XG", "rf_gg::rf_gg", SML_general_reader),
	gen_fail_msg "add_general_reader" 5033 ["¬XG"])
]end;
=TEX

Specific reader tests.

=SML
let
val add_S = ReaderWriterSupport.add_specific_reader;
val look_S = ReaderWriterSupport.look_up_specific_reader;

fun GS s = case look_S s of Nil => Nil | Value (_, x) => Value x;

val Value(SML_specific_reader, "Lex.Term") = look_S "‘";
in

store_mt_results_show mt_run[
("rf_add_2", (fn () => true) o add_S, ("‚", "rf_ss::rf_ss", SML_specific_reader), true)
];

store_mt_results_show mt_run[
("rf_3b", GS, "HOL", Nil),
("rf_4b", GS, "HOL:", Nil),
("rf_5b", GS, "‚", Value "rf_ss::rf_ss"),
("rf_7b", GS, "XG", Nil)
];

store_mt_results_show mt_run_fail[
("rf_add_4", add_S, ("‚", "rf_ss::rf_ss", SML_specific_reader),
	gen_fail_msg "add_specific_reader" 5033 ["‚"])
]end;
=TEX

Named reader tests.

=SML
let
val add_N = ReaderWriterSupport.add_named_reader;
val look_N = ReaderWriterSupport.look_up_named_reader;

fun GN s = case look_N s of Nil => Nil | Value (_, x) => Value x;

val Value(prod_named_reader, _) = look_N("¹", "HOLLABPROD");
in

store_mt_results_show mt_run[
("rfn_add_2", (fn () => true) o add_N, ("¹", "XN", "rfn_ss::rfn_ss",
		prod_named_reader), true)
];

store_mt_results_show mt_run[
("rfn_3b", GN, ("¹", "HOL"), Nil),
("rfn_4b", GN, ("¹", "HOL:"), Nil),
("rfn_5b", GN, ("¹", "XN"), Value "rfn_ss::rfn_ss"),
("rfn_7b", GN, ("¹", "XG"), Nil)
];

store_mt_results_show mt_run_fail[
("rfn_add_4", add_N, ("¹", "XN", "rf_ss::rf_ss", prod_named_reader),
	gen_fail_msg "add_named_reader" 5033 ["¹XN"])
]end;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{SYMBOL EXPANSION}

=SML
let
	open ReaderWriterSupport;
	val es = expand_symbol;
	fun get_kw k = force_value(PrettyNames.find_name k);
in
store_mt_results_show mt_run[
("es_ch",	es, SymCharacter	"abc", "abc"),
("es_wh",	es, SymWhite		[" ", " ", "\t", "\n"], "\n\t  "),
("es_knt",	es, SymKnown		("and", true, get_kw "and"), W_pc "and"),
("es_knf",	es, SymKnown		("±", false, get_kw "and"), "±"),
("es_ukwt",	es, SymUnknownKw	("abc", true), W_pc "abc"),
("es_ukwf",	es, SymUnknownKw	("abc", false), C_pc ^ "abc"),
("es_uc",	es, SymUnknownChar	"X", "X"),
("es_dp",	es, SymDoublePercent	, C_pc ^ C_pc)
]
end;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{FAULT HANDLING}

Provoke some reader writer error messages.  Note that there is no way
to provide a handler for these messages.  They are generated by the
reader writer, the calling environment (i.e., $useterminal$, $usefile$
or $usestring$) then handles them and continues or exits.  These error
messages generate text that is written on standard output.  To allow
the test to run the non-stop-mode option of $usefile$ must be enabled.

Notes on error codes which cannot be tested and error codes which
generate the text for output messages.

\begin{description}

\item[5502 ] holds text that is printed with each of the messages in
	the tests below, it indicates that $usefile$ is continuing
	after an error whilst in non-stop-mode.

\item[5503 ] holds text printed when $usefile$ stops reading a file
	after an error is detected.  It can only be tested during
	integration tests.

\item[5012 {\rm and} 5013 ] relate to function $ask_at_terminal$, code
	5012 is only issued when $useterminal$ is not active, but it is
	active whilst these tests are running.  Code 5013 is dependent
	upon how the PolyML session was started, it can only be tested
	during integration tests.

\item[5512 ] holds text printed when $usestring$ stops reading a string
	after an error is detected.  It is tested here but its number
	is not printed.

\item[5521 {\rm and} 5522 ] can only be checked during integration
	testing, they hold text printed when function $useterminal$
	handles an exception returned by PolyML at top level.

\item[5523 ] holds text printed when $useterminal$ reads an end of file
	and stops the whole session by calling $PolyML.quit$.

\end{description}
 
=SML
"Setting usefile_non_stop_mode = true";
set_flag("usefile_non_stop_mode", true);

"e_5001";	usestring "(* end of (input) in comment";
"e_5002";	usestring "\" end of (input) in string";   (*="=*)
"e_5003_a";	usestring "\"unknown keyword %%aardvark%% in string\"";
"e_5003_b";	usestring "unknown keyword %%aardvark%% in ML text";
"e_5003_c";	usestring "%%<%%unknown keyword %%aardvark%% in HOL text%%>%%";
"e_5005_a";	usestring "(168 \168)  (150  \150)";
"e_5005_b";	usestring "%%<%%(168 \168)  (150  \150)%%>%%";
"e_5006";	usestring "%%<%%%%down%%unknown (168 \168)  (150  \150)%%>%%";
=TEX
There are no characters of type $Invalid$ at present,
if and when we get some then
do some tests of error 5007.

=IGN
"e_5007_a";	usestring "\214 known character, but invalid";
"e_5007_b";	usestring "%%<%% \214 known character, but invalid%%>%%";
=SML
"e_5008_rb";	usestring "(123]";
"e_5008_rc";	usestring "(123}";
"e_5008_br";	usestring "[123)";
"e_5008_bc";	usestring "[123}";
"e_5008_cb";	usestring "{123]";
"e_5008_cr";	usestring "{123)";
"e_5010_a";	usestring "%%<%%%%down%%unknown skipped text%%>%%";
"e_5010_b";	usestring("%%<%%%%down%%unknown skipped %%<%% skipped" ^
			"HOL text %%>%% text%%>%%");
"e_5014";	usestring "\"abc\ndef\"";
"e_5012";	usestring "let exception aadrvark in raise aadrvark end;";
"e_5030";	usestring "%%<%%%%down%%unknown end of (input) in skipped quotation";
"e_5032";	usestring "%%<%%%%down%%SML end of (input) in SML quotation";

set_flag("usefile_non_stop_mode", false);
"Setting usefile_non_stop_mode = false";
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{SML RECOGNISER}

=SML
store_mt_results_show mt_run[
("sr_1", I, %<%%down%SML 27%>%, 27)
];

store_mt_results_show mt_run[
("sr_1a", I, ‘ 27%>%, 27)
];

store_mt_results_show mt_run[
("sr_2", I, ReaderWriterSupport.SML_recogniser("%<%", "SML", 27, "%>%"), 27)
];

let
	val smlr = ReaderWriterSupport.SML_recogniser;
	val gf = gen_fail_msg "SML_recogniser" 5050;
in
store_mt_results_show mt_run_fail[
("sr_3a", smlr, ("", "SML", 27, "%>%"), gf ["", "SML", "%>%"]),
("sr_3b", smlr, ("%<%", "", 27, "%>%"), gf ["%<%", "", "%>%"]),
("sr_3c", smlr, ("%<%", "SML", 27, ""), gf ["%<%", "SML", ""])
]
end;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{SIMPLE OUTPUT}
The results of these tests must in part be checked by eye,
checking that the line lengths and separation of the output is correct.
$get\_line\_length$ is tested implicitly by ``$set\-\_line\-\_length$ 1''.
Note that tabs are counted as one character wide in $diag\_string$, etc, and thus might give actual line lengths
greater than desired.
=SML
val orig_line_length = get_line_length ();

val teststring = "sdljfv lkirhnf d;fljnq lkwedjfn ldkfjbnwqd;kfjn  " ^
" ;ouinwefw  ;kiweujnbfwqel  iwe;lnfbu   wedjbnfkl; l;dkifcujbn l" ^
"  kwjedb lk jbn  el;i  uew bhnl;kij we bljhweb ,";
val twentytabs = 
	"t \tt \tt \tt \tt \t"^
	"t \tt \tt \tt \tt \t"^
	"t \tt \tt \tt \tt \t"^
	"t \tt \tt \tt \tt \tt";
diag_string teststring;
diag_string twentytabs;
store_mt_results mt_run [("set_line_length 1",
	set_line_length,
	20,
	orig_line_length)
	];
store_mt_results mt_run_fail [("set_line_length 1015",
	set_line_length,
	10,
	gen_fail_msg "set_line_length" 1015 [])];
diag_string teststring;
diag_string twentytabs;
store_mt_results mt_run [("set_line_length 2",
	set_line_length,
	orig_line_length,
	20)
	];
diag_string teststring;

list_diag_string ["abc","def","gh ij"];

map diag_line ["one", "two", "three"];
map diag_string ["one", "two", "three"];
=TEX
Now test whether it is indeed doing some translation:
=SML
val test_string2 = "%and%²";
val temp_use_extended_chars = set_flag("use_extended_chars",true);
diag_string test_string2;
list_diag_string [test_string2,test_string2];
diag_line test_string2;
set_flag("use_extended_chars",false);
diag_string test_string2;
list_diag_string [test_string2,test_string2];
diag_line test_string2;
set_flag("use_extended_chars",temp_use_extended_chars);
=TEX

\section{END OF TEST FILE}

=SML
"End of test file";

diag_line(summarize_mt_results());
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\end{document}

\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}


