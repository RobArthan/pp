=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design for Tactics II}
\TPPref{DS/FMU/IED/DTD028}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Design}
\TPPkeywords{}
\TPPauthor{R.D. Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D. Arthan & FST Team Leader}
\TPPabstract{This document gives the detailed design for the 
second group of tactics and tacticals in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.6 (2 July 1991)]
First draft issue (incorporating much of former DS/FMU/IED/DTD009).
\item [Issue 1.8 (\FormatDate{91/07/09
})]
Update to expose some of the internal conversions and theorems.
Negated conditionals now handled.
Commentary etc. updated in the light of comments received.
\item [Issue 1.11 (\FormatDate{91/09/04%
})] Issue for desk-check (reworked error messages and addition of
$ante\_tac$).
\item [Issue 1.12 (25th October 1991)]
Changes in response to deskcheck ID0029.
\item [Issue 1.13 (30th October 1991)]
Reacted to opening of $NetTools$, improved some error messages.
\item [Issue 1.14 (31th October 1991)]
Added $Š\_THEN$.
\end{description}
\subsection{Changes Forecast}
As determined by comments and review.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the 
second group of tactics and tacticals for ICL HOL.
This group is mainly concerned with supplying support for predicate calculus
connectives (including boolean conditionals but not boolean $let$-expressions).
This is called for in \cite{DS/FMU/IED/HLD009}.
The design is implemented in \cite{DS/FMU/IED/IMP028}.
\subsection{Introduction}
The second group of tactics and tacticals is mainly concerned with supplying support for predicate calculus
connectives (including boolean conditionals but not boolean $let$-expressions).
The main objective is to supply adequate goal, theorem
and assumption stripping tactics and tacticals (sufficiently
powerful to prove all tautologies). These and the other tactics defined
here may then be used to construct the rewriting tactics and
the elementary theory of pairs and so enable definition
of the tactics (and supporting rules)
which handle paired abstractions and other term constructs
which are not covered here.

This document contains first of all a general discussion of some of
the design issues and decisions concerning the tactics and tacticals
(section \ref{GENERALREMARKS}).
Section \ref{THETACTICSANDTACTICALS} then contains the specifications
of the tactics and tacticals, starting with the important tactics
which relate to stripping goals and theorems and then giving those
which relate to particular predicate calculus connectives.

Section \ref{CONVERSIONS} describes two conversions which are required
to implement the tactics and which also need some of the tactics for
their proof. As these conversions are likely to be required elsewhere they
are made visible here. Fortunately from the user's point of view they
are `simple' versions of conversions whose more general form will appear
in a more appropriate place.
\subsubsection{Purpose and Background}
Study material which relates to the coverage of the tactics and tacticals
may be found in \cite{DS/FMU/IED/WRK013} and
\cite{DS/FMU/IED/WRK014}.

The section of general remarks in the document describing the more
elementary tactics, \cite{DS/FMU/IED/DTD009} also apply to this document.

\subsubsection{Dependencies}
Loading this document is dependent on \cite{DS/FMU/IED/IMP009}
and \cite{DS/FMU/IED/IMP051}.

\subsubsection{Deficiencies}
There is  currently no way of extending the stripping techniques more
generally than by adding extra conversions. If there is a requirement for
adding stripping techniques which do there own Skolemisation or assumption
(without going via an equivalent HOL existential quantifier, or one of the HOL
propositional connectives), then more general hooks into
$STRIP\_THM\_THEN$ and $STRIP\_GOAL\_THEN$ would need to be exposed.
Such hooks have been rejected for the time being since it is felt that they
would be rather hard to explain and because misuse of such hooks could
prevent $strip\_tac$ being an equivalence transformation.

\subsubsection{Possible Enhancements}
One could supply $strip\_tac$ etc. in versions with the
extra conversions as arguments. The present formulation, in which these
conversions are stored in assignable variables, has the advantage that
any application-specific conversions then permeate into all of the
tactics which introduce new assumptions via $strip\_asm\_tac$ (e.g.
$cases\_tac$). Versions of the stripping functions with the conversions
as explicit arguments could be supplied as well
if there was a requirement for them.
\subsubsection{Terminology}
{\em Stripping} is a process of generating subgoals from a goal or breaking
a theorem into simpler parts by considering only its outermost connective, or top level ``form''.

An {\em equational context} is a list of conversions,
each paired with term index. It represents a statement of
how to
rewrite a term to result in an equational theorem,
guided by the outermost form of the term to be rewritten.
An equational context will be of type $EQN\_CXT$
(== $(TERM\ *\ CONV)list$).
=TEX
\section{GENERAL REMARKS}\label{GENERALREMARKS}
\subsection{Coverage}
We wish to supply tactics which correspond
to (a useful subset of) the inference rules for the predicate
calculus connectives given in \cite{DS/FMU/IED/DTD007}. Here by
predicate calculus connective we mean one of the following:

ó
€, , Š, ‚, Œ, (if ... then ... else):BOOL, ƒ, „, T, F
æ

It would be perfectly feasible to handle boolean $let$-expressions
as well. However, it is considered more appropriate to let the
user explicitly control the expansion of local definitions rather than
make the general purpose predicate calculus tactics expand them automatically
(and thereby run a risk of making the user's goal large and incomprehensible) 

In general, for each connective, $con$, (and also for some combinations of
connectives, e.g. $‚ \,T$), we supply:

\begin{enumerate}
\item
a tactical, $con\_T$, which takes one or more theorem tactic arguments,
and which may be used to attack a goal whose principal connective is
$con$ by inverting the introduction rule for $con$ to give one or more
subgoals. The theorem tactic arguments are then applied to any extra assumptions
in the antecedents of the rule, in an attempt to further simplify the goal.
E.g. $Š\_T\,thmtac$ is a tactic which works on a goal with conclusion of the
form $t1Št2$ by applying $thmtac(t1…t1)$ to a goal with the same assumptions
and with conclusion $t2$;
\item
a theorem tactical, $con\_THEN$, which helps to use a theorem with $con$
as its principal connective by using the elimination rule for
$con$ to simplify the goal.
E.g. $„\_THEN\,thmtac$ is a theorem tactic which uses a theorem
of the form $…„xŽt$ by applying $thmtac(t … t)$ to the goal and composing
the resulting proof with the existential elimination rule;
\item
a tactic, $con\_tac$, which inverts the introduction rule for $con$ and
applies the standard stripping tactic to any extra assumptions in the antecedents
of the rule.
\end{enumerate}

In cases where there is more than one introduction rule (e.g. disjunction, for
which there are left and right rules), there will be corresponding $con\_tac$s
with suitably decorated names.
Every connective has a $con\_tac$, but
$con\_T$ and $con\_THEN$ are not always supplied. E.g. $con\_T$ is only
supplied for connectives for which the introduction rule eliminates some
assumptions (i.e. introduces assumptions when inverted), so, for instance, $ƒ\_T$
is not needed.

N.B. $con\_tac$ or $con\_T$, may well not be the best or most
common way of handling a
goal whose principal connective is $con$. E.g. negation is usually best
handled by moving the negation inside other connectives when possible rather
than by attempting a proof inverting negation introduction (which latter amounts
to the variant of proof by contradiction in which one proves $… Œa$ by demonstrating
that $a … b$ and $a … Œb$ for some suitable choice of $b$).

It turns out in practice that $Œ$ and $F$ are some of the trickier
connectives to deal with and the tactics supplied to deal with them include
various tactics, mostly variations on the theme of proof by contradiction which
do not fit into the above scheme.
Similarly we supply some {\em ad hoc}, but very useful, tactics relating to the connective $Š$ and to case analysis.
 
\subsection{Strengthening}
The phrase ``N.B. loses information.'' in a tactic description
indicates that the tactic strengthens the goal to be proved,
by losing some information that \underline{might} have been necessary
to complete the proof.
This is, of course, a common proof approach, but it is worth knowing when
such tactics have been used in case one generates an unprovable goal
--- which may indicate either that the main
goal is unprovable, or just that an incorrect choice of proof has been made.
All information-losing tactics will be noted.

\pagebreak
\subsection{Stripping Goals, Theorems and Assumptions}\label{StrippingGoalsTheoremsandAssumptions}
One of the most important purposes of the present design is to
supply the tacticals which are used to strip goals
and theorems. These tacticals support some common
techniques for proving goals or using theorems within
tactic proofs in a uniform fashion.
For example, a goal of the form $\{ö\}a € b$ is almost always
proved by reducing it to $\{ö\}a$ and $\{ö\}b$, and, dually, a theorem of
the form $… a  b$ is almost always used to do a case split.

Very commonly the theorem stripping techniques are used to strip theorems
corresponding to new assumptions introduced by a tactic. For example,
the obvious way of proving a goal of the form $\{ö\}(a  b) Š c$
is to reduce it to two subgoals  $\{a, ö\}c$ and $\{b, ö\}c$. A uniform
means of performing this type of reduction is to have the tactic which strips
a goal of the form $\{ö\}t1 Š t2$ pass the theorem $t1 … t1$ to the theorem
stripper which then decomposes $t1 … t1$ into primitive constituents, performs any
relevant case splits and passes the primitive constituents on to a suitable
theorem tactic (typically $asm\_tac$). A more precise definition of
how this is done may be found in the following subsections.

The goal stripping techniques are packaged as a tactical
$STRIP\_GOAL\_T$ whose argument is a theorem tactic which
is used to process any new assumptions which may arise from stripping
the goal. The theorem stripping techniques are packaged as a theorem
tactical $STRIP\_THM\_THEN$. 
Both of these are parameterised by ``equational contexts'',
which state how stripping is to occur if the built-in
techniques fail.
The design approach taken is to move as much as possible into
the parameterised equational contexts,
and then we provide initial equational contexts that match the 
level of coverage of the rest of this document.
This allows application-specific transformations
to be handled in a uniform manner with the predicate calculus transformations
dealt with in the initial contexts. Note that any remarks below about termination of the
stripping process are made on the assumption that these conversions do not
lead to a loop.

The following subsections describe in outline the stripping facilities
supplied. This description is slightly simplified (as may be seen
by comparison with section \ref{THETACTICSANDTACTICALS}). For example,
it often turns out to be appropriate to supply a general theorem tactical
combinator, say $con\_THEN2$ which takes two arguments and obtain the more usual
$con\_THEN$ as a special case. The discussion below is not
concerned with such refinements.

\subsubsection{Stripping Goals}
Schematically, the effect on a goal of the goal stripping capabilities
supplied here is as follows:

ó
simple_ƒ_tac		({ö}, ƒxŽt)			‹	({ö}, t)

€_tac 			({ö}, t1 € t2)			‹	({ö}, t1) ; ({ö}, t2)


Š_T ttac		({ö}, t1 Š t2)			‹	ttac(t1 … t1) ({ö}, t)

t_tac			({ö}, T)			‹	[]

goal_in_asms_tac	({ö, t}, t)			‹	[]
æ
where $[]$ denotes an empty list of subgoals, i.e.that the tactic
proves the goal.
The initial equational context will provide the additional
rules:
ó
({ö}, t1  Œt2)		‹	({ö}, t2 Š t1)
({ö}, t1  t2)			‹	({ö}, Œt1 Š t2)
({ö}, t1 ‚ t2)			‹	({ö}, (t1 Š t2) € (t2 Š t1));
({ö}, if a then t1 else t2)	‹	({ö}, a € t1  Œ a € t2) ;
({ö}, Œt)			‹	({ö}, rhs(Œ_in_conv(Œt)))
æ
and where $Œ\_in\_conv$ is a conversion which moves negations over the
other connectives, i.e. it proves theorems of the following forms
(and fails if none of them applies):
ó
	…	ŒŒt			= t
	…	Œ(t1 € t2)		= Œt1  Œt2
	…	Œ(t1  t2)		= Œt1 € Œt2
	…	Œ(t1 Š t2)		= t1 € Œt2
	…	Œ(t1 ‚ t2)		= (t1 € Œt2)  (t2 € Œt1)
	…	Œif a then t1 else t2)
					= if a then Œt1 else Œt2
	…	ŒƒxŽt			= „xŽŒt
	…	Œ„xŽt			= ƒxŽŒt
	…	Œ„%down%1xŽt[x]	= ƒxŽŒ(t[x] € ƒx'Žt[x'] Š x' = x)
	…	ŒT			= F
	…	ŒF			= T
æ

Note that in the present document we do not deal with paired abstractions (e.g. $„(x,y)Ž...$).
However, we expect this feature to be addressed purely through additional equational contexts.


$STRIP\_GOAL\_T\,ttac$ (as set up here) attempts to apply each of the
above ``tactics'' until it finds one which is appropriate.

Each of the above stripping tactics is an equivalence transformation
(in the sense that the original goal is valid iff. all of the subgoals indicated
are valid). If we also assume that the theorem tactic $ttac$ above always
either achieves its goal or produces a set of subgoals which is
logically equivalent to its goal and which has a possibly
increased stock of assumptions but the same conclusion, then we see that
iteration of these stripping tactics, with the initial parameters stated will always terminate
and result in a conclusion of one of the following forms (which we will
call {\em conclusion literals} in the discussion in this document, but
not in the descriptions for the user in section \ref{THETACTICSANDTACTICALS}
below):

ó
	„xŽt	„%down%1xŽt	F	Œa	a
æ

where the principal connective of $a$ is not one of our predicate calculus
connectives.

Note that the treatment of disjunctions is asymmetrical. A utility
tactic $swap\_\_tac$ is supplied which allows the user to interchange
the operands of a disjunctive goal in circumstances where the choice
of simplifications made by $STRIP\_GOAL\_T$ is inappropriate.

\subsubsection{Stripping Theorems}

The theorem stripping capability supplied here may be shown schematically
as follows:
ó
€_THEN ttac (ñ … a € b)	({ö} t)		‹ (ttac (ñ … a) THEN ttac (ñ … b)) ({ö} t)
_THEN ttac (ñ … a  b)	({ö} t)		‹ ttac (a … a) ({ö} t) ; ttac (b … b) ({ö} t)
„_THEN ttac (ñ … „xŽa)	({ö} t)		‹ ttac (a[x'/x] … a[x'/x]) ({ö} t)
æ

where $a[x'/x]$ denotes $a$ with $x'$ substituted for $x$, where $x'$ is a
variable which does not appear free anywhere in the theorem or the goal.

The initial parameterisation will further provide:
ó
(ö … a Š b)		‹ (ö … Œa  b)
(ö … a ‚ b)		‹ (ö … a Š b € b Š a)
(ö … if a then b else c)	‹ (ö … a € b  Œ a € c)
(ö … Œa)		‹ (ö … rhs(Œ_conv(Œa)))
(ö … „%down%1 xŽa)	‹ (ö … „xŽa € ƒyŽa[y] Š y = x)
æ

(The negation and existence approaches defined in this document are actually
$simple\_$ versions since we do not handle paired abstractions here.)

$STRIP\_THM\_THEN$ (as set up here) is a theorem tactical which uses
the first of the above theorem tacticals which applies to the
given theorem.

Each of the above theorem tacticals is an equivalence transformation
in the sense that if applications of the theorem tactic $ttac$ do not
lose any information then neither does its transform under the theorem
tactical. Moreover if we repeatedly apply the above theorem tacticals
we will ultimately apply $ttac$ to theorems with conclusions having
one of the following forms (which we will call {\em assumption literals}
in the discussion below):

ó
	ƒxŽt	T	F	Œa	a
æ
where the principal connective of $a$ is not one of our predicate
calculus connectives.

\subsubsection{Stripping Assumptions}

$strip\_asm\_tac$ is a theorem tactic which repeatedly applies
$STRIP\_THM\_THEN$ to a theorem tactic $check\_asm\_tac$ which
acts as follows:

ó
check_asm_tac (ñ … T) ({ö} t)	‹ ({ö} t)
check_asm_tac (ñ … F) ({ö} t)	‹ []
check_asm_tac (ñ … Œa) ({ö, a} t)	‹ []
check_asm_tac (ñ … a) ({ö, Œa} t)	‹ []
check_asm_tac (ñ … a) ({ö} t)		‹ ({a, ö}, t)
æ

where $[]$ denotes an empty list of subgoals, i.e. that the tactic proves
the goal.
Note that $check\-\_asm\-\_tac$ does not lose information.

\subsubsection{$strip\_tac$}
The general purpose stripping tactic $strip\_tac$ is now
defined as $STRIP\_GOAL\_T\,strip\_asm\_tac$. From our observations
above on the goal and theorem stripping facilities this uses, we see that
repeated application of $strip\_tac$ reduces any goal to an equivalent collection
of subgoals each of which may be obtained from the original goal by (a)
replacing the conclusion by a conclusion literal and (b) adding zero or
more assumption literals to the assumptions.
Moreover, within each of the subgoals, each new assumption
will be distinct from any other assumption
and from the negation of any other assumption and from the conclusion.

As we will see in the next section the stripping tactic plus initial parameterisation we offer the user
actually goes further then is needed to prove all tautologies (too far, in
fact --- it will not prove certain substitution instances of tautologies in which
a quantified subterm appears both positively and negatively).
However, it does not go to the extreme of putting the goal into a clausal form
(e.g. as might be represented by a collection of goals all of which had
$F$ as the conclusion and had assumptions comprising universally quantified
disjunctions of propositional literals).

The form of goal is considered to be a convenient
compromise between the two extremes, in that it simplifies
existentially quantified assumptions and universally quantified conclusions
without rendering the goal incomprehensible to the interactive user.
A resolution-style tactic could sensibly start from a goal in this form, either
by continuing to reduce to clausal form (for a fully automatic proof) or
by just doing some propositional calculus normalisations
inside the assumptions to 
allow derivation of obvious immediate consequences of the assumptions
in a form which is still comprehensible to the user.

\subsubsection{$taut\_tac$}
By using a subset of the stripping techniques discussed in the
previous sections, a tactic which will prove any goal whose
conclusion is a substitution instance
of a tautology may be produced. (Here we define a {\em tautology} to be 
a term formed from propositional variables and the propositional constants
$T$ and $F$ using the non-quantifying predicate calculus connectives, which
is true for any assignment of truth values to the propositional variables).

To see this, consider (without loss of generality) the case when the original goal
has no assumptions and observe that by applying only transformations
for the non-quantifying connectives we will reduce any goal to
an equivalent collection of subgoals in which each conclusion and each assumptions is
what we shall call  a {\em propositional literal}, i.e.
either a {\em propositional atom} ---  a term which has a quantifier or a
non-predicate calculus connective as principal connective ---
or the negation of such a propositional atom.
Moreover, each subgoal, $\{ö\}t$ say is {\em (a)} such that no assumption
$a  ö$ is $\alpha$-convertible with $t$ or with the negation of
any other assumption in that subgoal or with $T$, $F$, $ŒT$ or $ŒF$,
and  {\em (b)} such that $t$ is not $T$ or $ŒF$ or $ŒT$.

Now assume that the original goal had a tautology as its conclusion.
In this case, each subgoal produced by the stripping process of the previous paragraph
must be true with respect to any (consistent) assignment of truth values
to the non-constant propositional
atoms which appear (possibly negated) as its conclusion or in its assumptions.
I claim that no subgoal of the form discussed
in the previous paragraph can be true with respect to all such assignments.
For, there are two possibilities: either, (a), the
subgoal has the form $\{ö\}F$, in which case, as no assumption $a  ö$
also appears negated in $ö$, we can choose an assignment which makes all the assumptions true and so make the subgoal false,
or, (b), the subgoal has the form $\{ö\}t$ or $\{ö\}Œt$
where $t$ is not a propositional constant, but then, as no assumption is
$\alpha$-convertible with the conclusion $t$ or $Œt$, we can choose
an assignment which makes each assumption true, makes the conclusion
false and so makes the subgoal false.
It follows that as the original goal had a tautology as its conclusion
then the stripping process of the previous paragraph must result in an
empty collection of subgoals, i.e. it will prove the original goal. 

(The above is a straightforward adaptation of a standard argument see, e.g. \cite{wang60}).

\subsection{Introduction of New Assumptions}
Many of the tactics $con\_tac$ (where $con$ stands for some predicate calculus
connective) naturally introduce additional assumptions. For example,
$Š\_tac$ might reduce $\{ö\} a Š b$ to $\{a, ö\} b$. However, in the
majority of cases it is best to strip the new assumptions as described
in section \ref{StrippingGoalsTheoremsandAssumptions} before adding them
to the assumptions. Note that, in general, this may cause case splits.

For ease of use, therefore, those tactics, $con\_tac$, which
introduce new assumptions will always strip the assumptions. 
I.e. $con\_tac$ will be implemented as $con\_T\,strip\_asm\_tac$.
In the more specialised cases where stripping is not required the user may use
$con\_T\,asm\_tac$ to achieve the desired effect.

To describe such a tactic we use the notation $(\{strip a, ö\}t)$ to denote
$strip\_asm\_tac(a … a) (\{ö\}t)$.

\section{THE TACTICS AND TACTICALS}\label{THETACTICSANDTACTICALS}
=DOC
signature âTactics2á = sig
=DESCRIBE
This provides the second group of tactics and tacticals in ICL HOL.
These are mainly concerned with the predicate calculus.
=ENDDOC
=TEX
\subsection{Equational Contexts}
(New errors in this section begin with 2814).
=DOC
type âEQN_CXTá;
=DESCRIBE
An equational context is a list of conversions,
each paired with term index. It represents a statement of
how to
rewrite a term to result in an equational theorem,
guided by the outermost form of the term to be rewritten,
which is matched against the term index of each conversion.
It is used to create a single conversion via $eqn\_cxt\_conv$ (q.v.).

A theorem may be converted into a member of 
an equational context by $thm\_for\_eqn\_cxt$.
A pre-existing conversion may be converted by determining
the term index that matches at least all terms that 
the conversion must work on
(see $net\_enter$ for details), and pair it with the conversion.
ó
type EQN_CXT = (TERM * CONV) list;
æ
Note that equational contexts can be merged by appending.
An equational context may be transformed into a conversion 
discrimination net by $make\_net$ or $list\_net\_enter$(q.v.).
=ENDDOC
=DOC
val âthm_for_eqn_cxtá : THM -> (TERM * CONV);
=DESCRIBE
A theorem may be transformation into a suitable member of 
an equational context ($EQN\_CXT$ q.v.)
by $thm\_for\_eqn\_cxt$.
ó
thm_for_eqn_cxt `ö … ƒ x1 ... Ž LHS = RHS` ‹
	(LHS, simple_eq_match_1_conv `ö … ƒ x1 ... Ž LHS = RHS`)
æ
where the universal quantifiers must be simple.
=SEEALSO
$canon\_thm\_for\_eqn\_cxt$ which canonicalises
a theorem before transformation.
=FAILURE
7095	?0 is not of the form `ö … ƒ x1 ... xn Ž u = v' where »xi¼ are variables
=ENDDOC
=DOC
val âeqn_cxt_convá : EQN_CXT -> CONV;
=DESCRIBE
This function creates a single conversion from an equational
context.
This is done via $make\_net$ and $net\_lookup$(q.v).
There is an implicit $CHANGED\_C$ wrapped around each
conversion in the equational context.
=FAILURE
28142	Equational context gave no conversions that succeeded for ?0
=ENDDOC

=TEX
\subsection{Stripping Tactics and Tacticals}
(New errors in this section begin with 2800).
Could choose to do $goal_in_asms_tac$ after the conversions,
to gain a performance increase.
=DOC
val âstrip_tacá : TACTIC;
=DESCRIBE
$strip\_tac$ is a general purpose tactic for simplifying away the outermost
connective or combination of a goal by applying the first applicable
member of the following collection of tactics:
ó
simple_ƒ_tac,		€_tac,			
Š_T ttac,		t_tac
æ
If none of these tactics succeeds, $strip\_tac$ uses the 
equational context that parameterises $STRIP\_GOAL\_T$ (q.v),
to rewrite the outermost connective in the goal.
Failing that being successful, we try $goal\_in\_asms\_tac$,
and failing that, return the error message below.

Any new assumptions generated by the tactic are processed using
$strip\_asm\_tac$. Thus $strip\_tac$ may produce several new
subgoals or may prove the goal.

$REPEAT\,strip\_tac$ given the initial parameterisation
of $STRIP\-\_GOAL\-\_T$ and $STRIP\-\_THM\-\_THEN$ will prove all
tautologies automatically. It will, however, 
not succeed in proving some substitution instances
of tautologies involving positive and
negative instances of a quantified subterm. 
=USES
With the initial parameterisation this is the usual way of simplifying a goal involving predicate
calculus connectives.
=SEEALSO
$strip\_asm\_tac$, $taut\_tac$, $STRIP\_GOAL\_T$, $STRIP\_THM\_THEN$,
$swap\_\_tac$.
=FAILURE
28003	There is no stripping technique for ?0 in the current proof context
=ENDDOC
=DOC
val âstrip_asm_tacá : THM -> TACTIC;
=DESCRIBE
$strip\_asm\_tac$ is a general purpose tactic for splitting a theorem up
into useful pieces using a range of
simplification techniques, including a parameterised part, before using it to increase the stock of assumptions.

The simplification techniques applied will always include the
following.
Using $sat$ as an abbreviation for $strip\_asm\_tac$:
ó
sat (… a € b) 			‹	sat (… a) THEN sat (… b)
sat („x.a)			‹	sat (… a[x'/x] … a[x'/x])
sat (… a  b)({ö} t)		‹	sat (a … a) ({ö} t) ; sat (b … b) ({ö} t)
æ

i.e. $strip\_asm\_tac$ does a case split resulting in two subgoals when
it processes a disjunction.

When none of the above transformations apply $strip\_asm\_tac$ attempts to use something in the 
equational context that parameterises $STRIP\_THM\_T$ (q.v),
to rewrite the outermost connective in the theorem
before proceeding.

After all of the available simplification techniques have been attempted
$strip\_asm\_tac$ then proceeds as $check\_asm\_tac$ (q.v.) to use the simplified theorem
either to prove the goal or to generate additional assumptions.
=SEEALSO
$check\_asm\_tac$, $strip\_tac$, $STRIP\_THM\_THEN$
=ENDDOC
=DOC
val âcheck_asm_tacá : THM -> TACTIC;
=DESCRIBE
$check\_asm\_tac\,thm$ is a tactic which checks the form of the theorem, $thm$,
and then takes the first applicable action from the following table:

{\centering
\begin{tabular}{|l|p{4in}|}\hline
$thm$ & action \\ \hline
$ö … t$ & proves goal if its conclusion is $t$ \\ \hline
$ö … T$ & as $id\_tac$ (i.e. the theorem is discarded) \\ \hline
$ö … F$ & proves goal\\ \hline
$ö … Œt$ & proves goal if $t$ in assumptions, else as $asm\_tac$\\ \hline
$ö … t$ & proves goal if $Œt$ in assumptions, else as $asm\_tac$\\ \hline
\end{tabular}}

During the search through the assumptions in the last two cases,
$check\_asm\_tac$ also checks to see whether any of the assumptions is
equal to the conclusion goal, and if so proves the goal.
=USES
Tactic programming.
=SEEALSO
$strip\_asm\_tac$, $strip\_tac$.
=ENDDOC
=DOC
val âSTRIP_THM_THENá : THM_TACTICAL;
=DESCRIBE
$STRIP\_THM\_THEN$ provides a general purpose way of
stripping theorems into primitive constituents before
using them in a tactic proof.
It attempts to apply a theorem tactical from the following list (in order):
ó
€_THEN,			_THEN,		SIMPLE_„_THEN
æ
If none of the above apply $STRIP\_THM\_THEN$ attempts
to find an applicable conversion in the
evaluated equational context held for the function by $get\_proof\_context$
to rewrite the theorem.

The equational context is evaluated in the proof context
by just applying $eqn\_cxt\_conv$.

The function is partially evaluated with only the
theorem tactic and theorem arguments.
=USES
Tactic programming.
=SEEALSO
$strip\_asm\_tac$, $strip\_tac$.
$initial\_strip\_proof\_context$ for initial configuration.
=FAILURE
28003	There is no stripping technique for ?0 in the current proof context
=ENDDOC
An experiment that needs to be made is to see what
effect ignoring the term indexes and using $FIRST\_C$
to implement the evaluation of the proof context.
Even if this is initially a better approach, the effect for
longer parameters should also be checked.

Could choose to do $goal_in_asms_tac$ after the conversions,
to gain a performance increase.
=DOC
val âSTRIP_GOAL_Tá : (THM -> TACTIC) -> TACTIC;
=DESCRIBE
$STRIP\_GOAL\_T\,ttac$ is a general purpose way of stripping
goals and passing any new assumptions generated by the stripping
to a tactic generating function.
It attempts to apply one of the following list of tactics
(in order):
ó
simple_ƒ_tac,		€_tac,			
Š_T ttac,		t_tac
æ
If none of the above apply $STRIP\_GOAL\_T$ attempts
to find an applicable conversion in the 
evaluated equational context held for the function by $get\_proof\_context$ to rewrite the goal.

The equational context is evaluated in the proof context
by just applying $eqn\_cxt\_conv$.
=USES
Tactic programming.
=SEEALSO
$strip\_asm\_tac$, $strip\_tac$.
$initial\_strip\_proof\_context$ for initial configuration.
=FAILURE
28003	There is no stripping technique for ?0 in the current proof context
=ENDDOC
An experiment that needs to be made is to see what
effect ignoring the term indexes and using $FIRST\_C$
to implement the evaluation of the proof context.
Even if this is initially a better approach, the effect for
longer parameters should also be checked.
=DOC
val âinitial_strip_proof_contextá : PROOF_CONTEXT;
val âeinitial_strip_proof_contextá : EPROOF_CONTEXT;
=DESCRIBE
$initial\_strip\_proof\_context$ contains the initial
setting of the parameters of $STRIP\-\_THM\-\_THEN$
and $STRIP\_GOAL\_T$,
and dummy entries for the other fields.
The $sa\_eqn\_cxt$ parameter (for $STRIP\-\_THM\-\_THEN$) is:
ó
[(thm_for_eqn_cxt Š_thm),
 (thm_for_eqn_cxt ‚_thm),
 (thm_for_eqn_cxt `… ƒ a t1 t2Ž (if a then t1 else t2) ‚ (a Š t1) € (Œ a Š t2)`),
 (»Œ x¼, simple_Œ_in_conv),
 (»„%down%1 x Ž p¼, simple_„%down%1_conv)]
æ
The $sg\_eqn\_cxt$ parameter (for $STRIP\-\_GOAL\-\_T$) is:
ó
[(thm_for_eqn_cxt `… ƒ t1 t2 Ž (t1  Œ t2) ‚ (t2 Š t1)`),
 (thm_for_eqn_cxt `… ƒ t1 t2 Ž (Œ t1  t2) ‚ (t1 Š t2)`),
 (thm_for_eqn_cxt `… ƒ t1 t2 Ž (t1  t2) ‚ (Œ t1 Š t2)`),
 (thm_for_eqn_cxt ‚_thm),
 (thm_for_eqn_cxt `… ƒ a t1 t2Ž (if a then t1 else t2) ‚ (a Š t1) € (Œ a Š t2)`),
 (»Œ x¼, simple_Œ_conv)]
æ
The evaluated proof context is:
ó
val einitial_strip_proof_context = {
	sa_conv = eqn_cxt_conv (initial_strip_proof_context.sa_eqn_cxt),
	sg_conv = eqn_cxt_conv (initial_strip_proof_context.sg_eqn_cxt),
	... }
æ
with dummy entries for the other fields.
=SEEALSO
$(e)paired\_strip\_proof\_context$ for the addition
of paired abstraction material.
=ENDDOC
=DOC 
val âgoal_in_asms_tacá : TACTIC;
=DESCRIBE
$goal\_in\_asms\_tac$ is a tactic which checks whether the conclusion of
the goal is also in the assumptions, and if so proves the goal.
=TACTIC
goal_in_asms_tac
É
{ ö, t } t'
É
=TEX
where $t$ and $t'$ are $\alpha$-convertible.
=USES
Tactic programming.
=SEEALSO
$strip\_tac$.
=FAILURE
28002	Goal does not appear in the assumptions
=ENDDOC

\subsection{Concerning $T$}
(New errors in this section begin with 2801.)

=DOC
val ât_tacá :  TACTIC;
=DESCRIBE
Prove a goal with conclusion `$T$'.
=TACTIC
t_tac
É
{ ö } T
É
=TEX
=SEEALSO
$strip\_tac$, $taut\_tac$.
=USES
Tactic programming.
=FAILURE
28011	Goal does not have the form {ö}T
=ENDDOC
=DOC
val â‚_t_tacá : TACTIC;
=DESCRIBE
Simplifies a goal of the form: $... ‚ T$ or $T ‚ ...$.
=TACTIC
‚_t_tac
É
{ ö } t ‚ T
É
{ ö } t
=TEX
and
=TACTIC
‚_T_tac
É
{ ö } T ‚ t
É
{ ö } t
=TEX
=FAILURE
28012	Goal not of form: { ö } t ‚ T or { ö } T ‚ t
=SEEALSO
$strip\_tac$
=USES
Tactic programming. 
=ENDDOC

\subsection{Concerning $F$}
(New errors in this section begin with 2802.)
=DOC
val âcontr_tacá : TACTIC;
=DESCRIBE
Prove a goal by showing that the assumptions are contradictory.

N.B. loses information.
=TACTIC
contr_tac
É
{ ö } t
É
{ ö } F
=TEX
=USES
If a proof is to be carried out by showing the assumptions inconsistent,
then the conclusion of the subgoal is irrelevant and may be removed.
=ENDDOC
=DOC
val âf_thm_tacá : THM -> TACTIC;
=DESCRIBE
Prove a goal by using a theorem of the form $ö … F$.
=TACTIC
f_thm_tac (ö1 … F)
É
{ ö2 } t
É
=TEX
where the assumptions, $ö1$, of the theorem are contained in the assumptions,
$ö2$, of the goal.
=FAILURE
28021	?0 does not have the form ö … F
=USES
In tactic programming, to use a theorem which shows that the assumptions are contradictory.
=SEEALSO
$strip\_asm\_tac$.
=ENDDOC
=DOC
val âc_contr_tacá : TACTIC;
=DESCRIBE
A form of proof by contradiction: $t$ holds if $Œt … F$.

(The name stands for classical contradiction, as opposed to the
intuitonistic contradiction proof of $contr\_tac$.)
=TACTIC
c_contr_tac
É
{ ö } t
É
{strip Œt, ö} F
=TEX
=USES
Proof by contradiction.
=SEEALSO
$strip\_tac$, $Œ\_tac$.
=FAILURE
28027	Conclusion of goal does not have type »:BOOL¼
=ENDDOC
=DOC
val âC_CONTR_Tá : (THM -> TACTIC) -> TACTIC;
=DESCRIBE
A form of proof by contradiction as a tactical.
$C\_CONTR\_T\,thmtac$ is a tactic which attempts to solve a goal $(ö, t)$,
by applying $thmtac(Œt … Œt)$ to the goal $(ö, F)$.
=TACTIC
C_CONTR_T
thmtac
É
{ ö } t
É
thmtac (Œt … Œt) ({ö} F)
=TEX
=USES
Proof by contradiction in combination with a theorem tactic.
=SEEALSO
$c\_contr\_tac$, $Œ\_T$.
=FAILURE
28027	Conclusion of goal does not have type »:BOOL¼
=ENDDOC

\subsection{Concerning Œ}
=DOC
val âŒ_tacá : TERM -> TACTIC;
=DESCRIBE
A form of proof by contradiction as a tactic: $Œt2$  holds if $t2 … t1$ and
$t2 … Œt1$ for some term $t1$.

Note that $strip\_tac$ may be used to push a negation inside other logical connectives,
which is often the best way of handling a negated goal.
=TACTIC
Œ_tac
»t1¼
É
{ ö } Œt2
É
{strip t2, ö } t1; {strip t2, ö } Œ t1
=TEX
=USES
To prove a negated term by showing that assuming the term gives rise to a contradiction.
=SEEALSO
$strip\_tac$, $c\_contr\_tac$, $Œ\_T$
=FAILURE
28022	?0 is not boolean
28023	Goal is not of the form »Œ t¼
=ENDDOC

=DOC
val âsimple_Œ_in_tacá : TACTIC;
=DESCRIBE
This is a tactic which moves negations inside other predicate calculus
connectives using the following rules:
ó
		ŒŒt			‹	 t
		Œ(t1 € t2)		‹	 Œt1  Œt2
		Œ(t1  t2)		‹	 Œt1 € Œt2
		Œ(t1 Š t2)		‹	 t1 € Œt2
		Œ(t1 ‚ t2)		‹	 (t1 € Œt2)  (t2 € Œt1)
		ŒƒxŽt			‹	 „xŽŒt
		Œ„xŽt			‹	 ƒxŽŒt
		Œ„%down%1xŽt	‹	 ƒxŽŒ(t € ƒx'Žt[x'] Š x' = x)
		ŒT			‹	 F
		ŒF			‹	 T
æ
It fails with paired quantifiers.
=USES
The more general $Œ\_in\_tac$ is just as efficient as $simple\_Œ\_in\_tac$
in cases where both succeed.
=SEEALSO
$strip\_tac$, $c\_contr\_tac$, $Œ\_T$, $Œ\_in\_tac$
=FAILURE
28025	No applicable rule for this goal
=ENDDOC

=DOC
val âSIMPLE_Œ_IN_THENá : THM_TACTICAL;
=DESCRIBE
This is a theorem tactical which applies a given 
theorem tactic to the result of transforming a theorem
by moving a top level negation inside other predicate calculus
connectives using the following rules:
ó
		ŒŒt			‹	 t
		Œ(t1 € t2)		‹	 Œt1  Œt2
		Œ(t1  t2)		‹	 Œt1 € Œt2
		Œ(t1 Š t2)		‹	 t1 € Œt2
		Œ(t1 ‚ t2)		‹	 (t1 € Œt2)  (t2 € Œt1)
		ŒƒxŽt			‹	 „xŽŒt
		Œ„xŽt			‹	 ƒxŽŒt
		Œ„%down%1xŽt	‹	 ƒxŽŒ(t € ƒx'Žt[x'] Š x' = x)
		ŒT			‹	 F
		ŒF			‹	 T
æ
It fails with paired quantifiers.
=USES
The more general $Œ\_IN\_THEN$ is just as efficient as $SIMPLE\_Œ\_IN\_THEN$
in cases where both succeed.
=SEEALSO
$strip\_tac$, $STRIP\_THM\_THEN$
=FAILURE
28026	No applicable rule for this theorem
=ENDDOC

=DOC
val âŒ_Tá : TERM -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
A form of proof by contradiction using a theorem tactic to
simplify the subgoals.

Note that $strip\_tac$ may be used to push a negation inside other logical connectives,
which is often the best way of handling a negated goal.
=TACTIC
Œ_T
ttac
»t1¼
É
{ ö } Œt2
É
ttac (t2 … t2) { ö } t1; 
ttac (t2 … t2) { ö } Œ t1
=TEX
=USES
To prove a negated term by showing that assuming the term gives rise to a contradiction.
=SEEALSO
$strip\_tac$, $c\_contr\_tac$, $Œ\_tac$, $STRIP\_GOAL\_T$, $Œ\_in\_conv$
=FAILURE
28022	?0 is not boolean
28023	Goal is not of the form »Œ t¼
=ENDDOC

=DOC
val âŒ_T2á : TERM -> (THM -> TACTIC) -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
A form of proof by contradiction using two theorem tactics to
simplify the subgoals.

Note that $strip\_tac$ may be used to push a negation inside other logical connectives,
which is often the best way of handling a negated goal.
=TACTIC
Œ_T2
ttac1 ttac2
»t1¼
É
{ ö } Œt2
É
ttac1 (t2 … t2) { ö } t1; 
ttac2 (t2 … t2) { ö } Œ t1
=TEX
=USES
To prove a negated term by showing that assuming the term gives rise to a contradiction.
=SEEALSO
$strip\_tac$, $c\_contr\_tac$, $Œ\_tac$, $STRIP\_GOAL\_T$, $Œ\_in\_conv$
=FAILURE
28022	?0 is not boolean
28023	Goal is not of the form »Œ t¼
=ENDDOC

=DOC
val âŒ_elim_tacá : TERM -> TACTIC;
=DESCRIBE
Proof by showing assumptions give rise to two contradictory
subgoals.

N.B. loses information.
=TACTIC
Œ_elim_tac
»t1¼
É
{ ö } t2
É
{ ö } t1; { ö } Œ t1
=TEX
=USES
In tactic programming.
If an assumption has its negation also in the assumption list
this will make for a rapid proof.
$undisch\_tac\,t1\,THEN\,strip\_tac$ is a more memorable idiom for handling
such a case in interactive use but is a little slower.
=SEEALSO
$strip\_tac$
=FAILURE
28022	?0 is not boolean
=ENDDOC

\subsection{Concerning €}
(New errors in this section begin with 2803.)
=DOC
val â€_tacá : TACTIC;
=DESCRIBE
Reduce the proof of a conjunction to the proof of its conjuncts.
=TACTIC
€_tac
É
{ ö } t1 € t2
É
{ ö } t1; { ö } t2
=TEX
=SEEALSO
$strip\_tac$
=FAILURE
28031	Goal is not of the form: { ö } t1 € t2
=ENDDOC
=DOC
val â€_THENá : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical to apply a given theorem tactic to the conjuncts of 
a theorem of the form $ö … t1 € t2$.
ó
€_THEN thmtac (ö … t1 € t2) = thmtac (ö … t1) THEN thmtac (ö … t2)
æ
=SEEALSO
$€\_THEN2$, $STRIP\_THM\_THEN$
=FAILURE
28032	?0 is not of the form: `ö … t1 € t2`
=ENDDOC
=DOC
val â€_THEN2á : (THM -> TACTIC) -> (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical to apply given theorem tactics to the conjuncts of 
a theorem of the form $ö … t1 € t2$.
ó
€_THEN2 thmtac1 thmtac2 (ö … t1 € t2) = thmtac1 (ö … t1) THEN thmtac2 (ö … t2)
æ
=SEEALSO
$€\_THEN$, $STRIP\_THM\_THEN$
=FAILURE
28032	?0 is not of the form: `ö … t1 € t2`
=ENDDOC
\subsection{Concerning }
(New errors in this section begin with 2804.)
=DOC
val â_left_tacá : TACTIC;
=DESCRIBE
Take the left disjunct of the current
goal as the subgoal.

N.B. loses information.
=TACTIC
_left_tac
É
{ ö } a  b
É
{ ö } a
=TEX
=SEEALSO
$\_left\_tac$, $swap\_\_tac$, $strip\_tac$
=FAILURE
28041	Goal is not of the form: { ö } a  b
=ENDDOC

=DOC
val â_right_tacá : TACTIC;
=DESCRIBE
Take the right disjunct of the current
subgoal as the new subgoal.

N.B. loses information.
=TACTIC
_right_tac
É
{ ö } a  b
É
{ ö } b
=TEX
=SEEALSO
$\_right\_tac$, $swap\_\_tac$, $strip\_tac$
=FAILURE
28041	Goal is not of the form: { ö } a  b
=ENDDOC
=DOC
val âswap__tacá : TACTIC;
=DESCRIBE
Interchange the disjuncts of a disjunctive goal.
=TACTIC
swap__tac
É
{ ö } a  b
É
{ ö } b  a
=TEX
=USES
For use in conjunction with $strip\_tac$ (q.v.) when the reduction
of $\{ ö \} a  b$ to $\{ Œa, ö \} b$ is inappropriate.
=SEEALSO
$\_left\_tac$, $\_right\_tac$, $swap\_\_tac$, $strip\-\_tac$
=FAILURE
28041	Goal is not of the form: { ö } a  b
=ENDDOC
=DOC
val â_THENá : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical to perform a case split on a given disjunctive theorem
applying a tactic generating function to the extra assumption in each branch.
ó
_THEN ttac (ñ … t1  t2) ({ö} t) = ttac (t1 … t1) ({ö} t); ttac (t2 … t2)({ö} t)
æ
=TEX
=SEEALSO
$STRIP\_THM\_THEN$, $\_THEN2$
=FAILURE
28042	?0 is not of the form: `ö … t1  t2`
=ENDDOC

=DOC
val â_THEN2á : (THM -> TACTIC) -> (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical to perform a case split on a given disjunctive theorem
applying tactic generating functions to the extra assumption in each branch.
ó
_THEN2 ttac1 ttac2 (ñ … t1  t2) ({ö} t) = 
	ttac1 (t1 … t1) ({ö} t); ttac2 (t2 … t2)({ö} t)
æ
=TEX
=SEEALSO
$STRIP\_THM\_THEN$, $\_THEN$
=FAILURE
28042	?0 is not of the form: `ö … t1  t2`
=ENDDOC

=DOC
val âcases_tacá : TERM -> TACTIC;
=DESCRIBE
Do a case split on a given boolean term.
=TACTIC
cases_tac
»t1¼
É
{ ö } t2
É
{strip t1, ö } t2; {strip Œt1, ö } t2
=TEX
=SEEALSO
$CASES\_T$, $\_THEN$
=FAILURE
28022	?0 is not boolean
=ENDDOC

=DOC
val âCASES_Tá : TERM -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
Do a case split on a given boolean term using a tactic generating function:
ó
CASES_T t1 ttac ({ö} t2) = ttac(t1 … t1)({ö} t2) ; ttac(Œt1 … Œt1)({ö} t2)
æ
=SEEALSO
$cases\_tac$, $\_THEN$, $CASES\_T2$
=FAILURE
28022	?0 is not boolean
=ENDDOC

=DOC
val âCASES_T2á : TERM -> (THM -> TACTIC) -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
Do a case split on a given boolean term using two tactic generating functions:
ó
CASES_T2 t1 ttac1 ttac2 ({ö} t2) = ttac1(t1 … t1)({ö} t2) ; ttac2(Œt1 … Œt1)({ö} t2)
æ
=SEEALSO
$cases\_tac$, $\_THEN$, $CASES\_T$
=FAILURE
28022	?0 is not boolean
=ENDDOC

\subsection{Concerning Š}
(New errors in this section begin with 2805)
=DOC
val âŠ_tacá : TACTIC;
=DESCRIBE
Strip the antecedent of an implicative goal into the assumption list.
=TACTIC
Š_tac
É
{ ö } t1 Š t2
É
{strip t1, ö } t2
=TEX
=FAILURE
28051	Goal is not of form: { ö } t1 Š t2
=ENDDOC

=DOC
val âŠ_Tá : (THM -> TACTIC) -> TACTIC;
=DESCRIBE
Reduce an implicative goal
by passing the antecedent to a tactic generating function.
=TACTIC
Š_T
ttac
É
{ ö } t1 Š t2
É
ttac{ t1, ö } t2
=TEX
=FAILURE
28051	Goal is not of form: { ö } t1 Š t2
=ENDDOC
=DOC
val âŠ_THENá : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical to apply a given theorem tactic to the result
of eliminating $Š$ from a theorem of the form $ö … t1 Š t2$.
ó
Š_THEN thmtac (ö … t1 Š t2) = thmtac (ö … Œ t1  t2)
æ
=FAILURE
28054	?0 is not of the form: `ö … t1 Š t2`
=ENDDOC

=DOC
val âundisch_tacá : TERM -> TACTIC ;
=DESCRIBE
Bring a term out of the assumption list into the goal as the antecedent
of an implication.
=RULE
undisch_tac
»t1¼
É
{ ö, t1' } t2
É
{ ö } … t1 Š t2
=TEX
where $t1$ and $t1'$ are $\alpha$-convertible.
Note that all assumptions $\alpha$-convertible with $t1$ are removed.
=USES
Typically to make the assumption amenable to manipulation, e.g. by
a rewriting tactic.
=SEEALSO
$list\_undisch\_tac$, $all\_undisch\_tac$
=FAILURE
28052	Term ?0 is not in the assumptions
28027	Conclusion of goal does not have type »:BOOL¼
=ENDDOC

=DOC
val âlist_undisch_tacá : TERM list -> TACTIC;
=DESCRIBE
Repeatedly apply $undisch\_tac$.
=RULE
list_undisch_tac
[»t1¼,...,»tn¼]
É
{ ö, t1, ..., tn } t
É
{ ö } t1 Š ... Š tn Š t
=TEX
$\alpha$-equivalent assumptions will only appear once in the resulting
goal.
=SEEALSO
$undisch\_tac$, $all\_undisch\_tac$
=FAILURE
28052	Term ?0 is not in the assumptions
=ENDDOC

=DOC
val âall_undisch_tacá : TACTIC;
=DESCRIBE
Apply $undisch\_tac$ to every assumption in turn:
=TACTIC
all_undisch_tac
É
{ t1, ..., tn } t
É
{} tn Š ... Š t1 Š t
=TEX
$\alpha$-equivalent assumptions will only appear once in the resulting
goal.
=SEEALSO
$undisch\_tac$, $list\_undisch\_tac$
=ENDDOC

=DOC
val âante_tacá : THM -> TACTIC;
=DESCRIBE
Replace a goal with conclusion $t2$ by $t1 Š t2$, where
the antecedent, $t1$, of the implication is the conclusion of
a theorem:
=TACTIC
ante_tac (ö1 … t1)
É
{ ö2 } t2
É
{ ö2 } t1 Š t2
=TEX
where the assumptions, $ö1$, of the theorem are contained in the
assumptions, $ö2$ of the goal.
=USES
This is often useful if one needs to transform the conclusion of
theorem e.g. by rewriting with the assumptions.
=SEEALSO
$asm\_tac$, $strip\_asm\_tac$
=FAILURE
28053	Conclusion of goal does not have type »:BOOL¼
=ENDDOC

\subsection{Concerning ‚}
(New errors in this section begin with 2806.)
=DOC
val â‚_tacá : TACTIC;
=DESCRIBE
Reduce a bi-implication to two subgoals.
=TACTIC
‚_tac
É
{ ö } t1 ‚ t2
É
{strip t1, ö } … t2; {strip t2, ö } … t1
=TEX
=SEEALSO
$strip\_tac$, $‚_T$
=FAILURE
28061	Goal is not of the form: { ö } t1 ‚ t2
=ENDDOC

=DOC
val â‚_Tá : (THM -> TACTIC) -> TACTIC;
=DESCRIBE
Reduce a bi-implication by passing each operand to a tactic generating
function.
=TACTIC
‚_T
ttac
É
{ ö } t1 ‚ t2
É
ttac{ t1, ö } … t2; ttac{ t2, ö } … t1
=TEX
=SEEALSO
$‚\_T2$, $STRIP\_GOAL\_T$
=FAILURE
28061	Goal is not of the form: { ö } t1 ‚ t2
=ENDDOC

=DOC
val â‚_T2á : (THM -> TACTIC) -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
Reduce a bi-implication by passing the operands to tactic generating
functions.
=TACTIC
‚_T2
ttac1 ttac2
É
{ ö } t1 ‚ t2
É
ttac1{ t1, ö } … t2; ttac2{ t2, ö } … t1
=TEX
=SEEALSO
$‚\_T$, $STRIP\_GOAL\_T$
=FAILURE
28061	Goal is not of the form: { ö } t1 ‚ t2
=ENDDOC

=DOC
val â‚_THENá : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical to apply a given theorem tactic to the result
of eliminating $‚$ from a theorem of the form $ö … t1 ‚ t2$.
ó
‚_THEN thmtac (ö … t1 ‚ t2) = thmtac (ö … t1 Š t2) THEN thmtac (ö … t2 Š t1)
æ
=SEEALSO
$‚\_THEN2$, $STRIP\_THM\_THEN$
=FAILURE
28062	?0 is not of the form: `ö … t1 ‚ t2`
=ENDDOC

=DOC
val â‚_THEN2á : (THM -> TACTIC) -> (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical to apply given theorem tactics to the the result
of eliminating $‚$ from a theorem of the form $ö … t1 ‚ t2$.
ó
‚_THEN2 ttac1 ttac2(ö … t1 ‚ t2) = ttac1(ö … t1 Š t2) THEN ttac2(ö … t2 Š t1)
æ
=SEEALSO
$‚\_THEN$, $STRIP\_THM\_THEN$
=FAILURE
28062	?0 is not of the form: `ö … t1 ‚ t2`
=ENDDOC


\subsection{Concerning $if\ldots then\ldots else \ldots$}
(New errors in this section begin with 2807.)

=DOC
val âif_tacá : TACTIC;
=DESCRIBE
Reduce a conditional subgoal by performing a case split on the
selector.
=TACTIC
if_tac
É
{ ö } if a then tt else et
É
{strip a, ö } tt ;  {strip Œa, ö } et
=TEX
=SEEALSO
$strip\_tac$
=FAILURE
28071	Goal is not of the form: { ö } if a then tt else et
=ENDDOC


=DOC
val âIF_Tá : (THM -> TACTIC) -> TACTIC;
=DESCRIBE
Reduce a conditional by applying a tactic generating function to the
two cases for the selector.
=TACTIC
IF_T
ttac
É
{ ö } if a then tt else et
É
ttac{ a, ö } … tt; ttac{ Œa, ö } … et
=TEX
=SEEALSO
$IF\_T2$, $STRIP\_GOAL\_T$
=FAILURE
28071	Goal is not of the form: { ö } if a then tt else et
=ENDDOC

=DOC
val âIF_T2á : (THM -> TACTIC) -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
Reduce a conditional by applying tactic generating functions to the
two cases for the selector.
=TACTIC
IF_T2
ttac1 ttac2
É
{ ö } if a then tt else et
É
ttac1{ a, ö } … tt; ttac2{ Œa, ö } … et
=TEX
=SEEALSO
$‚\_T$, $STRIP\_GOAL\_T$
=FAILURE
28071	Goal is not of the form: { ö } if a then tt else et
=ENDDOC

=DOC
val âIF_THENá : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical to apply a given theorem tactic to the result
of eliminating the conditional from a theorem with a conditional as its
conclusion.
ó
IF_THEN ttac (ö … if a then tt else et) = ttac (a, ö … tt) THEN ttac (Œa, ö … et)
æ
=SEEALSO
$IF\_THEN2$, $STRIP\_THM\_THEN$
=FAILURE
7012	?0 is not of the form: `ö … if tc then tt else te`
=ENDDOC

=DOC
val âIF_THEN2á : (THM -> TACTIC) -> (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
=DESCRIBE
A theorem tactical to apply given theorem tactics to the result
of eliminating the conditional from a theorem with a conditional as its
conclusion.
ó
IF_THEN ttac (ö … if a then tt else et) = ttac1 (a, ö … tt) THEN ttac2 (Œa, ö … et)
æ
=SEEALSO
$IF\_THEN$, $STRIP\_THM\_THEN$
=FAILURE
7012	?0 is not of the form: `ö … if tc then tt else te`
=ENDDOC

\subsection{Concerning ƒ}
(New errors in this section begin with 2808.)

=DOC
val âsimple_ƒ_tacá : TACTIC;
=DESCRIBE
Reduce a universally quantified goal.
It fails with paired quantifiers.
=TACTIC
simple_ƒ_tac
É
{ ö } ƒ x Ž t[x]
É
{ ö } t[x']
=TEX
where $x'$ is a variant name of $x$, different from any 
variable in $ö$ or $t$.
=USES
Tactic programming.
The more general $ƒ\_tac$ is just as efficient as $simple\_ƒ\_tac$
in cases where both succeed.
=SEEALSO
$ƒ\_tac$
=FAILURE
28081	Goal is not of the form: { ö } ƒ x Ž t[x]
=ENDDOC


\subsection{Concerning „}
(New errors in this section begin with 2809.)

=DOC
val âsimple_„_tacá : TERM -> TACTIC ;
=DESCRIBE
Provide a witness for an existential subgoal.
It fails with paired quantifiers.

N.B. loses information.
=TACTIC
simple_„_tac
»t1¼
É
{ ö } „ x Ž t2[x]
É
{ ö } t2[t1]
=TEX
where $t1$ must have the same type as $x$.
=USES
Tactic programming.
The more general $„\_tac$ is just as efficient as $simple\_„\_tac$
in cases where both succeed.
=FAILURE
28091	Goal is not of the form: { ö } „ x Ž t2[x] 
28092	Term ?0 has the wrong type
=ENDDOC
$„\_tac$ is expected to be able to type instantiate
its argument if necessary, but $simple\_„\_tac$ is not required to do this.
=DOC
val âSIMPLE_„_THENá : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical which applies a given theorem tactic to the result
of eliminating the outermost quantifier from a theorem of the form
$ö … „xŽt$.
It fails with paired quantifiers.
ó
SIMPLE_„_THEN thmtac (ö … „xŽt) = thmtac (ö … t[x'/x])
æ
where »x'¼ is a variant of »x¼ which does not appear in $ö$ or in
the assumption or conclusion of the goal.
=USES
Tactic programming. Note that the more general $„\_THEN$ is just as
efficient as $SIMPLE\_„\_THEN$ in cases where both succeed.
=SEEALSO
$„\_THEN$
=FAILURE
28093	?0 is not of the form: `ö … „ x Ž t`
=ENDDOC

\subsection{Concerning À}
(New errors in this section begin with 2810.)

=DOC
val âsimple_„%down%1_tacá : TERM -> TACTIC;
=DESCRIBE
Simplify a unique existentially quantified goal with a particular
witness.
It fails with paired quantifiers.

N.B. loses information.
=TACTIC
simple_„%down%1_tac1
»t¼
É
{ ö } simple_„%down%1 x Ž P[x]
É
{ ö } P[t];
{ ö } ƒ x' Ž P[x'] Š x' = t
=TEX
where $x'$ is a variant of $x$ which does not occur free in $t$.
=USES
Tactic programming.
The more general $„_1\_tac$ is just as efficient as $simple\-\_„_1\_tac$
in cases where both succeed.
=FAILURE
28101	Goal is not of the form: { ö } „%down%1 x Ž P[x]
28092	Term ?0 has the wrong type
=ENDDOC
Like $simple\_„\_tac$, $simple\_„_1\_tac$ is not required to be able
to type instantiate its argument.
=DOC
val âSIMPLE_„%down%1_THENá : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical which applies a given theorem tactic to the result
of eliminating the outermost quantifier from a theorem of the form
$ö … „_1xŽt$.
It fails with paired quantifiers.
ó
SIMPLE_„%down%1_THEN thmtac (ö … „%down%1xŽt) = 
	thmtac (ö … t[x'/x] € ƒx''ŽP[x''] Š x'' = x)
æ
where »x'¼ and »x''¼ are distinct variants of »x¼ which do not appear free in $ö$ or in
the assumptions or conclusion of the goal.
=USES
Tactic programming.
The more general $„_1\_THEN$ is just as efficient as $SIMPLE\-\_„_1\_THEN$
in cases where both succeed.
=FAILURE
28102	?0 is not of the form: `ö … „%down%1 x Ž t`
=ENDDOC

\subsection{$lemma\_tac$}
(New errors in this section begin with 2811.)
=DOC
val âlemma_tacá : TERM -> TACTIC;
=DESCRIBE
Introduce a lemma (the term argument) to be proved,
and then added as an assumption.

N.B. loses information.
=TACTIC
lemma_tac
»t1¼
É
{ ö } t2
É
{strip t1, ö} t2;
{ ö } t1
=TEX
=SEEALSO
$LEMMA\_T$
=ENDDOC
\subsection{Tautology Prover}
(New errors in this section begin with 2812.)
Note that unlike the tautology provers in earlier instances of HOL,
our $taut\_tac$ proves a goal if and only if its conclusion is
a tautology in the precise sense defined in the following box.
It will not prove $1 = 1$ or $ƒxŽT$.
=DOC
val âtaut_tacá : TACTIC;
=DESCRIBE
A tautology prover.
If the conclusion of the goal is a tautology  then $taut\_tac$ will prove
the goal.
A tautology is taken to be any substitution
instance of a term which is formed from boolean variables,
the constants $T$ and $F$ and the following
connectives:
ó
€, , Š, ‚, Œ, if ... then ... else
æ
and which is true for any assignment of truth values to the variables.
=TACTIC
taut_tac
É
{ ö } t
É
=TEX
=SEEALSO
$strip\_tac$
=FAILURE
28121	Conclusion of the goal is not a tautology
=ENDDOC
($TAUT\_TAC$ in Cambridge HOL)
\section{CONVERSIONS}\label{CONVERSIONS}
(New errors in this section begin with 2813.)
=DOC
val âsimple_Œ_in_convá : CONV;
=DESCRIBE
This is a conversion which moves negations inside other predicate
calculus connectives using whichever of the following rules applies:
ó
		ŒŒt			=	 t
		Œ(t1 € t2)		=	 Œt1  Œt2
		Œ(t1  t2)		=	 Œt1 € Œt2
		Œ(t1 Š t2)		=	 t1 € Œt2
		Œ(t1 ‚ t2)		=	 (t1 € Œt2)  (t2 € Œt1)
		Œ(if a then t1 else t2)
					=	 (if a then Œt1 else Œt2)
		ŒƒxŽt			=	 „xŽŒt
		Œ„xŽt			=	 ƒxŽŒt
		Œ„%down%1xŽt	=	 ƒxŽŒ(t € ƒx'Žt[x'] Š x' = x)
		ŒT			=	 F
		ŒF			=	 T
æ
It does not handle paired quantifiers.
=USES
Tactic and conversion programming.
The more general $Œ\_in\_conv$ is just as efficient as $simple\_Œ\_in\_conv$
in cases where both succeed.
=SEEALSO
$strip\_tac$
=FAILURE
28131	No applicable rules for the term ?0
=ENDDOC
=DOC
val âsimple_„%down%1_convá : CONV;
=DESCRIBE
This is a conversion which turns a unique existential quantifier into
an equivalent existential quantifier
=CONVERSION
simple_„%down%1_conv
»„%down%1xŽt¼
É
É
… („%down%1xŽt[x]) ‚ 
	(„xŽt[x] € ƒx'Žt[x'] Š x' = x)
=USES
Tactic and conversion programming.
The more general $„_1\_conv$ is just as efficient as $simple\_„_1\_conv$
in cases where both succeed.
=SEEALSO
$strip\_tac$
=FAILURE
28132	?0 is not of the form „%down%1xŽt
=ENDDOC
\section{THEOREMS}
The following sets of theorems will be needed to code the tactics and because
of their general utility are saved for reuse (as a space optimisation, since
their proofs are trivial once the tactics defined here are available).
=DOC
val âŒ_Œ_thmá : THM
val âŒ__thmá : THM
val âŒ_€_thmá : THM
val âŒ_Š_thmá : THM
val âŒ_‚_thmá : THM
val âŒ_if_thmá : THM
val âŒ_f_thmá : THM

val âŠ_thmá : THM
val â‚_thmá : THM
val âif_thmá : THM
=DESCRIBE
These theorems are tautologies saved in the theory
``misc'' because they are frequently used in tactic
and conversion programming.

The first seven theorems are De Morgan's laws for the various
propositional connectives formulated so that they can be used to normalise
a propositional term by moving all negations inside other connectives.
$Œ\_t\_thm$ is also provided but is documented elsewhere.

The last three theorems give definitions for implication, bi-implication
and conditional in terms of disjunction, conjunction and negation.
ó
Œ_Œ_thm		… ƒaŽŒ Œa ‚ a
Œ__thm		… ƒa bŽŒ (a  b) ‚ (Œa € Œb)
Œ_€_thm		… ( Œ(a € b) ‚ (Œa  Œb)
Œ_Š_thm		… ƒa bŽŒ(a Š b) ‚ (a € Œb)
Œ_‚_thm		… ƒ a b Ž Œ (a ‚ b) ‚ a € Œ b  b € Œ a
Œ_if_thm		… ƒ a b Ž Œ (if a then T else T) ‚ (if a then Œ T else Œ T)

Œ_f_thm		… ŒF ‚ T
Š_thm			… ƒa bŽ(a Š b) ‚ (Œa  b)
‚_thm			… ƒa bŽ(a ‚ b) ‚ (a Š b) € (b Š a)
if_thm			… ƒa b cŽ(if a then b else c) ‚ (a € b)  (Œa € c)
æ
=SEEALSO
$Œ\_t\_thm$.
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of Tactics2 *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested according to the
general criteria given in \cite{DS/FMU/IED/PLN008}.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

