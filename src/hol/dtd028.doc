=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design for Tactics II}
\TPPref{DS/FMU/IED/DTD028}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Design}
\TPPkeywords{}
\TPPauthor{R.D. Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D. Arthan & FST Team Leader}
\TPPabstract{This document gives the detailed design for the 
second group of tactics and tacticals in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.6 (2 July 1991)]
First draft issue (incorporating much of former DS/FMU/IED/DTD009).
\item [Issue 1.8 (\FormatDate{91/07/09
})]
Update to expose some of the internal conversions and theorems.
Negated conditionals now handled.
Commentary etc. updated in the light of comments received.
\item [Issue 1.11 (\FormatDate{91/09/04%
})] Issue for desk-check (reworked error messages and addition of
$ante\_tac$).
\item [Issue 1.12 (25th October 1991)]
Changes in response to deskcheck ID0029.
\item [Issue 1.13 (30th October 1991)]
Reacted to opening of $NetTools$, improved some error messages.
\item [Issue 1.14 (31th October 1991)]
Added $´\_THEN$.
\item [Issue 1.15 (18th November 1991)]
Reacting to issue 1.5/6 of \cite{DS/FMU/IED/DTD051}.

\item[Issue 1.16 (\FormatDate{92/01/20})] Updated to use new fonts.
\item[Issue 1.17 (4th February 1992)]
Modified $strip\_tac$, added $swap\_asm\_concl\_tac$ et al.
\item[Issue 1.18 (10th February 1992)]
Minor corrections.
\item [Issue 1.20(11th March 1992)]
Various minor additions and extensions.
\item [Issue 1.21 (26th March 1992)]
Changed to use proof context material of issue 1.13 of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.22 (13th April 1992)]
Changes due to CR0017.
\item [Issue 1.23 (28th April 1992)]
Corrected documentation typos.
\item [Issue  (14th May 1992)]
Reorganisation of proof contexts.
\end{description}
% \subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the 
second group of tactics and tacticals for ICL HOL.
This group is mainly concerned with supplying support for predicate calculus
connectives (including boolean conditionals but not boolean $let$-expressions).
This is called for in \cite{DS/FMU/IED/HLD009}.
The design is implemented in \cite{DS/FMU/IED/IMP028}.
\subsection{Introduction}
The second group of tactics and tacticals is mainly concerned with supplying support for predicate calculus
connectives (including boolean conditionals but not boolean $let$-expressions).
The main objective is to supply adequate goal, theorem
and assumption stripping tactics and tacticals (sufficiently
powerful to prove all tautologies). These and the other tactics defined
here may then be used to construct the rewriting tactics and
the elementary theory of pairs and so enable definition
of the tactics (and supporting rules)
which handle paired abstractions and other term constructs
which are not covered here.

This document contains first of all a general discussion of some of
the design issues and decisions concerning the tactics and tacticals
(section \ref{GENERALREMARKS}).
Section \ref{THETACTICSANDTACTICALS} then contains the specifications
of the tactics and tacticals, starting with the important tactics
which relate to stripping goals and theorems and then giving those
which relate to particular predicate calculus connectives.

Section \ref{CONVERSIONS} describes two conversions which are required
to implement the tactics and which also need some of the tactics for
their proof. As these conversions are likely to be required elsewhere they
are made visible here. Fortunately from the user's point of view they
are `simple' versions of conversions whose more general form will appear
in a more appropriate place.
\subsubsection{Purpose and Background}
Study material which relates to the coverage of the tactics and tacticals
may be found in \cite{DS/FMU/IED/WRK013} and
\cite{DS/FMU/IED/WRK014}.

The section of general remarks in the document describing the more
elementary tactics, \cite{DS/FMU/IED/DTD009} also apply to this document.

\subsubsection{Dependencies}
Loading this document is dependent on \cite{DS/FMU/IED/IMP009}
and \cite{DS/FMU/IED/IMP051}.

\subsubsection{Deficiencies}
There is  currently no way of extending the stripping techniques more
generally than by adding extra conversions. If there is a requirement for
adding stripping techniques which do there own Skolemisation or assumption
(without going via an equivalent HOL existential quantifier, or one of the HOL
propositional connectives), then more general hooks into
$STRIP\_THM\_THEN$ and $STRIP\-\_CONCL\_THEN$ would need to be exposed.
Such hooks have been rejected for the time being since it is felt that they
would be rather hard to explain and because misuse of such hooks could
prevent $strip\_tac$ being an equivalence transformation.

\subsubsection{Possible Enhancements}
One could supply $strip\_tac$ etc. in versions with the
extra conversions as arguments. The present formulation, in which these
conversions are stored in proof contexts, has the advantage that
any application-specific conversions then permeate into all of the
tactics which introduce new assumptions via $strip\_asm\_tac$ (e.g.
$cases\_tac$). Versions of the stripping functions with the conversions
as explicit arguments could be supplied as well
if there was a requirement for them.
\subsubsection{Terminology}
{\em Stripping} is a process of generating subgoals from a goal or breaking
a theorem into simpler parts by considering only its outermost connective, or top level ``form''.

\section{GENERAL REMARKS}\label{GENERALREMARKS}
\subsection{Coverage}
We wish to supply tactics which correspond
to (a useful subset of) the inference rules for the predicate
calculus connectives given in \cite{DS/FMU/IED/DTD007}. Here by
predicate calculus connective we mean one of the following:

=GFT
±, ², ´, ¤, ³, (if ... then ... else):BOOL, µ, ¶, T, F
=TEX

It would be perfectly feasible to handle boolean $let$-expressions
as well. However, it is considered more appropriate to let the
user explicitly control the expansion of local definitions rather than
make the general purpose predicate calculus tactics expand them automatically
(and thereby run a risk of making the user's goal large and incomprehensible) 

In general, for each connective, $con$, (and also for some combinations of
connectives, e.g. $¤ \,T$), we supply:

\begin{enumerate}
\item
a tactical, $con\_T$, which takes one or more theorem tactic arguments,
and which may be used to attack a goal whose principal connective is
$con$ by inverting the introduction rule for $con$ to give one or more
subgoals. The theorem tactic arguments are then applied to any extra assumptions
in the antecedents of the rule, in an attempt to further simplify the goal.
E.g. $´\_T\,thmtac$ is a tactic which works on a goal with conclusion of the
form $t1´t2$ by applying $thmtac(t1ôt1)$ to a goal with the same assumptions
and with conclusion $t2$;
\item
a theorem tactical, $con\_THEN$, which helps to use a theorem with $con$
as its principal connective by using the elimination rule for
$con$ to simplify the goal.
E.g. $¶\_THEN\,thmtac$ is a theorem tactic which uses a theorem
of the form $ô¶x·t$ by applying $thmtac(t ô t)$ to the goal and composing
the resulting proof with the existential elimination rule;
\item
a tactic, $con\_tac$, which inverts the introduction rule for $con$ and
applies the standard stripping tactic to any extra assumptions in the antecedents
of the rule.
\end{enumerate}

In cases where there is more than one introduction rule (e.g. disjunction, for
which there are left and right rules), there will be corresponding $con\_tac$s
with suitably decorated names.
Every connective has a $con\_tac$, but
$con\_T$ and $con\_THEN$ are not always supplied. E.g. $con\_T$ is only
supplied for connectives for which the introduction rule eliminates some
assumptions (i.e. introduces assumptions when inverted), so, for instance, $µ\_T$
is not needed.

N.B. $con\_tac$ or $con\_T$, may well not be the best or most
common way of handling a
goal whose principal connective is $con$. E.g. negation is usually best
handled by moving the negation inside other connectives when possible rather
than by attempting a proof inverting negation introduction (which latter amounts
to the variant of proof by contradiction in which one proves $ô ³a$ by demonstrating
that $a ô b$ and $a ô ³b$ for some suitable choice of $b$).

It turns out in practice that $³$ and $F$ are some of the trickier
connectives to deal with and the tactics supplied to deal with them include
various tactics, mostly variations on the theme of proof by contradiction which
do not fit into the above scheme.
Similarly we supply some {\em ad hoc}, but very useful, tactics relating to the connective $´$ and to case analysis.
 
\subsection{Strengthening}
The phrase ``N.B. loses information.'' in a tactic description
indicates that the tactic strengthens the goal to be proved,
by losing some information that \underline{might} have been necessary
to complete the proof.
This is, of course, a common proof approach, but it is worth knowing when
such tactics have been used in case one generates an unprovable goal
--- which may indicate either that the main
goal is unprovable, or just that an incorrect choice of proof has been made.
All information-losing tactics will be noted.

\pagebreak
\subsection{Stripping Goals, Theorems and Assumptions}\label{StrippingGoalsTheoremsandAssumptions}
One of the most important purposes of the present design is to
supply the tacticals which are used to strip goals
and theorems. These tacticals support some common
techniques for proving goals or using theorems within
tactic proofs in a uniform fashion.
For example, a goal of the form $\{\}a ± b$ is almost always
proved by reducing it to $\{\}a$ and $\{\}b$, and, dually, a theorem of
the form $ô a ² b$ is almost always used to do a case split.

Very commonly the theorem stripping techniques are used to strip theorems
corresponding to new assumptions introduced by a tactic. For example,
the obvious way of proving a goal of the form $\{\}(a ² b) ´ c$
is to reduce it to two subgoals  $\{a, \}c$ and $\{b, \}c$. A uniform
means of performing this type of reduction is to have the tactic which strips
a goal of the form $\{\}t1 ´ t2$ pass the theorem $t1 ô t1$ to the theorem
stripper which then decomposes $t1 ô t1$ into primitive constituents, performs any
relevant case splits and passes the primitive constituents on to a suitable
theorem tactic (typically $asm\_tac$). A more precise definition of
how this is done may be found in the following subsections.

The goal stripping techniques are packaged as a tactical
$STRIP\-\_CONCL\_T$ whose argument is a theorem tactic which
is used to process any new assumptions which may arise from stripping
the goal. The theorem stripping techniques are packaged as a theorem
tactical $STRIP\_THM\_THEN$. 
Both of these are parameterised by conversions held in the current proof context,
which state how stripping is to be attempted before the built-in
techniques are tried.
The design approach taken is to move as much as possible into
the parameterised conversions,
and then we provide initial conversions that match the 
level of coverage of the rest of this document.
This allows application-specific transformations
to be handled in a uniform manner with the predicate calculus transformations
dealt with in the initial contexts. Note that any remarks below about termination of the
stripping process are made on the assumption that these conversions do not
lead to a loop.

The following subsections describe in outline the stripping facilities
supplied. This description is slightly simplified (as may be seen
by comparison with section \ref{THETACTICSANDTACTICALS}). For example,
it often turns out to be appropriate to supply a general theorem tactical
combinator, say $con\_THEN2$ which takes two arguments and obtain the more usual
$con\_THEN$ as a special case. The discussion below is not
concerned with such refinements.

\subsubsection{Stripping Goals}
Schematically, the effect on a goal of the goal stripping capabilities
supplied here is as follows:

=GFT
simple_µ_tac		({}, µx·t)			­	({}, t)

±_tac 			({}, t1 ± t2)			­	({}, t1) ; ({}, t2)


´_T ttac		({}, t1 ´ t2)			­	ttac(t1 ô t1) ({}, t)

t_tac			({}, T)			­	[]

concl_in_asms_tac	({, t}, t)			­	[]
=TEX
where $[]$ denotes an empty list of subgoals, i.e.that the tactic
proves the goal.
The initial conversion from the proof context will provide the additional
rules:
=GFT
({}, t1 ² ³t2)		­	({}, t2 ´ t1)
({}, t1 ² t2)			­	({}, ³t1 ´ t2)
({}, t1 ¤ t2)			­	({}, (t1 ´ t2) ± (t2 ´ t1));
({}, if a then t1 else t2)	­	({}, a ± t1 ² ³ a ± t2) ;
({}, ³t)			­	({}, rhs(simple_³_in_conv(³t)))
=TEX
and where $simple\_³\_in\_conv$ is a conversion which moves negations over the
other connectives, i.e. it proves theorems of the following forms
(and fails if none of them applies):
=GFT
	ô	³³t			= t
	ô	³(t1 ± t2)		= ³t1 ² ³t2
	ô	³(t1 ² t2)		= ³t1 ± ³t2
	ô	³(t1 ´ t2)		= t1 ± ³t2
	ô	³(t1 ¤ t2)		= (t1 ± ³t2) ² (t2 ± ³t1)
	ô	³if a then t1 else t2)
					= if a then ³t1 else ³t2
	ô	³µx·t			= ¶x·³t
	ô	³¶x·t			= µx·³t
	ô	³¶1x·t[x]	= µx·³(t[x] ± µx'·t[x'] ´ x' = x)
	ô	³T			= F
	ô	³F			= T
=TEX

Note that in the present document we do not deal with paired abstractions (e.g. $¶(x,y)·...$).
However, we expect this feature to be addressed purely through additional equational contexts.


$STRIP\-\_CONCL\_T\,ttac$ (as set up here) attempts to apply each of the
above ``tactics'' until it finds one which is appropriate.

Each of the above stripping tactics is an equivalence transformation
(in the sense that the original goal is valid iff. all of the subgoals indicated
are valid). If we also assume that the theorem tactic $ttac$ above always
either achieves its goal or produces a set of subgoals which is
logically equivalent to its goal and which has a possibly
increased stock of assumptions but the same conclusion, then we see that
iteration of these stripping tactics, with the initial parameters stated will always terminate
and result in a conclusion of one of the following forms (which we will
call {\em conclusion literals} in the discussion in this document, but
not in the descriptions for the user in section \ref{THETACTICSANDTACTICALS}
below):

=GFT
	¶x·t	¶1x·t	F	³a	a
=TEX

where the principal connective of $a$ is not one of our predicate calculus
connectives.

Note that the treatment of disjunctions is asymmetrical. A utility
tactic $swap\_²\_tac$ is supplied which allows the user to interchange
the operands of a disjunctive goal in circumstances where the choice
of simplifications made by $STRIP\-\_CONCL\_T$ is inappropriate.

\subsubsection{Stripping Theorems}

The theorem stripping capability supplied here may be shown schematically
as follows:
=GFT
±_THEN ttac ( ô a ± b)	({} t)	­ (ttac ( ô a) THEN ttac ( ô b)) ({} t)
²_THEN ttac ( ô a ² b)	({} t)	­ ttac (a ô a) ({} t) ; ttac (b ô b) ({} t)
¶_THEN ttac ( ô ¶x·a)	({} t)	­ ttac (a[x'/x] ô a[x'/x]) ({} t)
=TEX

where $a[x'/x]$ denotes $a$ with $x'$ substituted for $x$, where $x'$ is a
variable which does not appear free anywhere in the theorem or the goal.

The initial parameterisation will further provide:
=GFT
( ô a ´ b)		­ ( ô ³a ² b)
( ô a ¤ b)		­ ( ô a ´ b ± b ´ a)
( ô if a then b else c)	­ ( ô a ± b ² ³ a ± c)
( ô ³a)		­ ( ô rhs(simple_³_in_conv(³a)))
( ô ¶1 x·a)	­ ( ô ¶x·a ± µy·a[y] ´ y = x)
=TEX

(The negation and existence approaches defined in this document are actually
$simple\_$ versions since we do not handle paired abstractions here.)

$STRIP\_THM\_THEN$ (as set up here) is a theorem tactical which uses
the first of the above theorem tacticals which applies to the
given theorem.

Each of the above theorem tacticals is an equivalence transformation
in the sense that if applications of the theorem tactic $ttac$ do not
lose any information then neither does its transform under the theorem
tactical. Moreover if we repeatedly apply the above theorem tacticals
we will ultimately apply $ttac$ to theorems with conclusions having
one of the following forms (which we will call {\em assumption literals}
in the discussion below):

=GFT
	µx·t	T	F	³a	a
=TEX
where the principal connective of $a$ is not one of our predicate
calculus connectives.

\subsubsection{Stripping Assumptions}

$strip\_asm\_tac$ is a theorem tactic which repeatedly applies
$STRIP\_THM\_THEN$ to a theorem tactic $check\_asm\_tac$ which
acts as follows:

=GFT
check_asm_tac ( ô T) ({} t)	­ ({} t)
check_asm_tac ( ô F) ({} t)	­ []
check_asm_tac ( ô ³a) ({, a} t)	­ []
check_asm_tac ( ô a) ({, ³a} t)	­ []
check_asm_tac ( ô a) ({} t)		­ ({a, }, t)
=TEX

where $[]$ denotes an empty list of subgoals, i.e. that the tactic proves
the goal.
Note that $check\-\_asm\-\_tac$ does not lose information.

\subsubsection{$strip\_tac$}
The general purpose stripping tactic $strip\_tac$ is now
defined as $STRIP\-\_CONCL\_T\,strip\_asm\_tac$. From our observations
above on the goal and theorem stripping facilities this uses, we see that
repeated application of $strip\_tac$ reduces any goal to an equivalent collection
of subgoals each of which may be obtained from the original goal by (a)
replacing the conclusion by a conclusion literal and (b) adding zero or
more assumption literals to the assumptions.
Moreover, within each of the subgoals, each new assumption
will be distinct from any other assumption
and from the negation of any other assumption and from the conclusion.

As we will see in the next section the stripping tactic plus initial parameterisation we offer the user
actually goes further then is needed to prove all tautologies (too far, in
fact --- it will not prove certain substitution instances of tautologies in which
a quantified subterm appears both positively and negatively).
However, it does not go to the extreme of putting the goal into a clausal form
(e.g. as might be represented by a collection of goals all of which had
$F$ as the conclusion and had assumptions comprising universally quantified
disjunctions of propositional literals).

The form of goal is considered to be a convenient
compromise between the two extremes, in that it simplifies
existentially quantified assumptions and universally quantified conclusions
without rendering the goal incomprehensible to the interactive user.
A resolution-style tactic could sensibly start from a goal in this form, either
by continuing to reduce to clausal form (for a fully automatic proof) or
by just doing some propositional calculus normalisations
inside the assumptions to 
allow derivation of obvious immediate consequences of the assumptions
in a form which is still comprehensible to the user.

\subsubsection{$taut\_tac$}
By using a subset of the stripping techniques discussed in the
previous sections, a tactic which will prove any goal whose
conclusion is a substitution instance
of a tautology may be produced. (Here we define a {\em tautology} to be 
a term formed from propositional variables and the propositional constants
$T$ and $F$ using the non-quantifying predicate calculus connectives, which
is true for any assignment of truth values to the propositional variables).

To see this, consider (without loss of generality) the case when the original goal
has no assumptions and observe that by applying only transformations
for the non-quantifying connectives we will reduce any goal to
an equivalent collection of subgoals in which each conclusion and each assumptions is
what we shall call  a {\em propositional literal}, i.e.
either a {\em propositional atom} ---  a term which has a quantifier or a
non-predicate calculus connective as principal connective ---
or the negation of such a propositional atom.
Moreover, each subgoal, $\{\}t$ say is {\em (a)} such that no assumption
$a  $ is $\alpha$-convertible with $t$ or with the negation of
any other assumption in that subgoal or with $T$, $F$, $³T$ or $³F$,
and  {\em (b)} such that $t$ is not $T$ or $³F$ or $³T$.

Now assume that the original goal had a tautology as its conclusion.
In this case, each subgoal produced by the stripping process of the previous paragraph
must be true with respect to any (consistent) assignment of truth values
to the non-constant propositional
atoms which appear (possibly negated) as its conclusion or in its assumptions.
I claim that no subgoal of the form discussed
in the previous paragraph can be true with respect to all such assignments.
For, there are two possibilities: either, (a), the
subgoal has the form $\{\}F$, in which case, as no assumption $a  $
also appears negated in $$, we can choose an assignment which makes all the assumptions true and so make the subgoal false,
or, (b), the subgoal has the form $\{\}t$ or $\{\}³t$
where $t$ is not a propositional constant, but then, as no assumption is
$\alpha$-convertible with the conclusion $t$ or $³t$, we can choose
an assignment which makes each assumption true, makes the conclusion
false and so makes the subgoal false.
It follows that as the original goal had a tautology as its conclusion
then the stripping process of the previous paragraph must result in an
empty collection of subgoals, i.e. it will prove the original goal. 

(The above is a straightforward adaptation of a standard argument see, e.g. \cite{wang60}).

\subsection{Introduction of New Assumptions}
Many of the tactics $con\_tac$ (where $con$ stands for some predicate calculus
connective) naturally introduce additional assumptions. For example,
$´\_tac$ might reduce $\{\} a ´ b$ to $\{a, \} b$. However, in the
majority of cases it is best to strip the new assumptions as described
in section \ref{StrippingGoalsTheoremsandAssumptions} before adding them
to the assumptions. Note that, in general, this may cause case splits.

For ease of use, therefore, those tactics, $con\_tac$, which
introduce new assumptions will always strip the assumptions. 
I.e. $con\_tac$ will be implemented as $con\_T\,strip\_asm\_tac$.
In the more specialised cases where stripping is not required the user may use
$con\_T\,asm\_tac$ to achieve the desired effect.

To describe such a tactic we use the notation $(\{strip\ a, \}t)$ to denote
$strip\_asm\_tac(a ô a) (\{\}t)$.

\section{THE TACTICS AND TACTICALS}\label{THETACTICSANDTACTICALS}
=DOC
signature ÛTactics2Ý = sig
=DESCRIBE
This provides the second group of tactics and tacticals in ICL HOL.
These are mainly concerned with the predicate calculus.
=ENDDOC
=TEX
\subsection{Stripping Tactics and Tacticals}
(New errors in this section begin with 2800).
=DOC
val Ûstrip_tacÝ : TACTIC;
=DESCRIBE
$strip\_tac$ is a general purpose tactic for simplifying away the outermost
connective or combination of a goal by applying the first applicable
member of the following collection of tactics:
=GFT
simple_µ_tac,		±_tac,			
´_T ttac,		t_tac
=TEX
Before seeing whether any of these tactics succeed, $strip\_tac$ will attempt to use the 
conversion that parameterises $STRIP\-\_CONCL\-\_T$ (q.v),
to rewrite the outermost connective in the goal.
Failing either being successful, we try $concl\-\_in\-\_asms\-\_tac$,
and failing that, return the error message below.

Any new assumptions generated by the tactic are processed using
$strip\_asm\_tac$. Thus $strip\_tac$ may produce several new
subgoals or may prove the goal.

$REPEAT\,strip\_tac$ given the initial parameterisation
of $STRIP\-\_CONCL\-\_T$ and $STRIP\-\_THM\-\_THEN$ will prove all
tautologies automatically. It will, however, 
not succeed in proving some substitution instances
of tautologies involving positive and
negative instances of a quantified subterm. 
=USES
With the initial parameterisation this is the usual way of simplifying a goal involving predicate
calculus connectives.
=SEEALSO
$strip\_asm\_tac$, $taut\_tac$, $STRIP\-\_CONCL\_T$, $STRIP\_THM\_THEN$,
$swap\_²\_tac$.
=FAILURE
28003	There is no stripping technique for ?0 in the current proof context
=ENDDOC
=DOC
val Ûstrip_asm_tacÝ : THM -> TACTIC;
=DESCRIBE
$strip\_asm\_tac$ is a general purpose tactic for splitting a theorem up
into useful pieces using a range of
simplification techniques, including a parameterised part, before using it to increase the stock of assumptions.

The simplification techniques applied will always include the
following.
Using $sat$ as an abbreviation for $strip\_asm\_tac$:
=GFT
sat (ô a ± b) 			­	sat (ô a) THEN sat (ô b)
sat (¶x.a)			­	sat (ô a[x'/x] ô a[x'/x])
sat (ô a ² b)({} t)		­	sat (a ô a) ({} t) ; sat (b ô b) ({} t)
=TEX

I.e. $strip\_asm\_tac$ does a case split resulting in two subgoals when
it processes a disjunction.

In addition, before attempting to use the above transformations $strip\_asm\_tac$ attempts to use the 
conversion that parameterises $STRIP\_THM\_T$ (q.v),
to rewrite the outermost connective in the theorem
before proceeding.

After all of the available simplification techniques have been attempted
$strip\_asm\_tac$ then proceeds as $check\_asm\_tac$ (q.v.) to use the simplified theorem
either to prove the goal or to generate additional assumptions.
=SEEALSO
$check\_asm\_tac$, $strip\_tac$, $STRIP\_THM\_THEN$
=ENDDOC
=DOC
val Ûcheck_asm_tacÝ : THM -> TACTIC;
=DESCRIBE
$check\_asm\_tac\,thm$ is a tactic which checks the form of the theorem, $thm$,
and then takes the first applicable action from the following table:

{\centering
\begin{tabular}{|l|p{4in}|}\hline
$thm$ & action \\ \hline
$ ô t$ & proves goal if its conclusion is $t$ \\ \hline
$ ô T$ & as $id\_tac$ (i.e. the theorem is discarded) \\ \hline
$ ô F$ & proves goal\\ \hline
$ ô ³t$ & proves goal if $t$ in assumptions, else as $asm\_tac$\\ \hline
$ ô t$ & proves goal if $³t$ in assumptions, else as $asm\_tac$\\ \hline
\end{tabular}}

During the search through the assumptions in the last two cases,
$check\_asm\_tac$ also checks to see whether any of the assumptions is
equal to the conclusion goal, and if so proves the goal.
=USES
Tactic programming.
=SEEALSO
$strip\_asm\_tac$, $strip\_tac$.
=ENDDOC
=DOC
val ÛSTRIP_THM_THENÝ : THM_TACTICAL;
=DESCRIBE
$STRIP\_THM\_THEN$ provides a general purpose way of
stripping theorems into primitive constituents before
using them in a tactic proof.
$STRIP\_THM\_THEN$ attempts
the conversion held for the function in the current proof context
extracted by $current\_ad\_st\_conv$.
to rewrite the theorem.
If that fails it attempts to apply a theorem tactical from the following list (in order):
=GFT
±_THEN,			²_THEN,		SIMPLE_¶_THEN
=TEX
The conversion in the current proof context
got by $current\_ad\_st\_conv$ (q.v.)
is derived by applying $eqn\_cxt\_conv$ to an equational context in the proof context extracted by $get\_st\_eqn\_cxt$.

The function is partially evaluated with only the
theorem tactic and theorem arguments.
=USES
Tactic programming.
=SEEALSO
$strip\_asm\_tac$, $strip\_tac$.
=FAILURE
28003	There is no stripping technique for ?0 in the current proof context
=ENDDOC
An experiment that needs to be made is to see what
effect ignoring the term indexes and using $FIRST\_C$
to implement the evaluation of the proof context.
Even if this is initially a better approach, the effect for
longer parameters should also be checked.
=DOC
val ÛSTRIP_CONCL_TÝ : (THM -> TACTIC) -> TACTIC;
=DESCRIBE
$STRIP\-\_CONCL\_T\,ttac$ is a general purpose way of stripping
goals and passing any new assumptions generated by the stripping
to a tactic generating function.
$STRIP\-\_CONCL\_T$ attempts
to apply the conversion
held for the function in the current proof context of to rewrite the goal,
extracted by $current\_ad\_sg\_conv$.
If that fails it attempts to apply one of the following list of tactics
(in order):
=GFT
simple_µ_tac,		±_tac,			
´_T ttac,		t_tac
=TEX
If none of the above apply Failing that it tries $concl\-\_in\-\_asms\-\_tac$,
and failing that, return the error message below.

The conversion in the current proof context
held by $current\_ad\_sg\_conv$ (q.v.)
is derived by applying $eqn\_cxt\_conv$ to an equational context in the proof context,
extracted by $get\_sg\_eqn\_cxt$.
=USES
Tactic programming.
=SEEALSO
$strip\_asm\_tac$, $strip\_tac$.
=FAILURE
28003	There is no stripping technique for ?0 in the current proof context
=ENDDOC
An experiment that needs to be made is to see what
effect ignoring the term indexes and using $FIRST\_C$
to implement the evaluation of the proof context.
Even if this is initially a better approach, the effect for
longer parameters should also be checked.
=DOC
val Ûconcl_in_asms_tacÝ : TACTIC;
=DESCRIBE
$concl\-\_in\-\_asms\-\_tac$ is a tactic which checks whether the conclusion of
the goal is also in the assumptions, and if so proves the goal.
=FRULE 2 Tactic
concl_in_asms_tac
÷
{ , t } t'
÷
=TEX
where $t$ and $t'$ are $\alpha$-convertible.
=USES
Tactic programming.
=SEEALSO
$strip\_tac$.
=FAILURE
28002	Goal does not appear in the assumptions
=ENDDOC

\subsection{Concerning $T$}
(New errors in this section begin with 2801.)

=DOC
val Ût_tacÝ :  TACTIC;
=DESCRIBE
Prove a goal with conclusion `$T$'.
=FRULE 2 Tactic
t_tac
÷
{  } T
÷
=TEX
=SEEALSO
$strip\_tac$, $taut\_tac$.
=USES
Tactic programming.
=FAILURE
28011	Goal does not have the form {}T
=ENDDOC
=DOC
val Û¤_t_tacÝ : TACTIC;
=DESCRIBE
Simplifies a goal of the form: $... ¤ T$ or $T ¤ ...$.
=FRULE 2 Tactic
¤_t_tac
÷
{  } t ¤ T
÷
{  } t
=TEX
and
=FRULE 2 Tactic
¤_t_tac
÷
{  } T ¤ t
÷
{  } t
=TEX
=FAILURE
28012	Goal not of form: {  } t ¤ T or {  } T ¤ t
=SEEALSO
$strip\_tac$
=USES
Tactic programming. 
=ENDDOC

\subsection{Concerning $F$}
(New errors in this section begin with 2802.)
=DOC
val Ûi_contr_tacÝ : TACTIC;
=DESCRIBE
Prove a goal by showing that the assumptions are contradictory.

N.B. loses information.
=FRULE 2 Tactic
i_contr_tac
÷
{  } t
÷
{  } F
=TEX
=USES
If a proof is to be carried out by showing the assumptions inconsistent,
then the conclusion of the subgoal is irrelevant and may be removed.
=ENDDOC
=DOC
val Ûf_thm_tacÝ : THM -> TACTIC;
=DESCRIBE
Prove a goal by using a theorem of the form $ ô F$.
=FRULE 2 Tactic
f_thm_tac (1 ô F)
÷
{ 2 } t
÷
=TEX
where the assumptions, $1$, of the theorem are contained in the assumptions,
$2$, of the goal.
=FAILURE
28021	?0 does not have the form  ô F
=USES
In tactic programming, to use a theorem which shows that the assumptions are contradictory.
=SEEALSO
$strip\_asm\_tac$.
=ENDDOC
=DOC
val Ûcontr_tacÝ : TACTIC;
=DESCRIBE
A form of proof by contradiction: $t$ holds if $³t ô F$.

(The name stands for classical contradiction, as opposed to the
intuitionistic contradiction proof of $i\_contr\_tac$.)
=FRULE 2 Tactic
contr_tac
÷
{  } t
÷
{strip ³t, } F
=TEX
=USES
Proof by contradiction.
=SEEALSO
$strip\_tac$, $³\_tac$.
=FAILURE
28027	Conclusion of goal does not have type BOOL®
=ENDDOC
=DOC
val ÛC_CONTR_TÝ : (THM -> TACTIC) -> TACTIC;
=DESCRIBE
A form of proof by contradiction as a tactical.
$C\_CONTR\_T\,thmtac$ is a tactic which attempts to solve a goal $(, t)$,
by applying $thmtac(³t ô ³t)$ to the goal $(, F)$.
=FRULE 2 Tactic
C_CONTR_T
thmtac
÷
{  } t
÷
thmtac (³t ô ³t) ({} F)
=TEX
=USES
Proof by contradiction in combination with a theorem tactic.
=SEEALSO
$contr\_tac$, $³\_T$.
=FAILURE
28027	Conclusion of goal does not have type BOOL®
=ENDDOC

\subsection{Concerning ³}
=DOC
val Û³_tacÝ : TERM -> TACTIC;
=DESCRIBE
A form of proof by contradiction as a tactic: $³t2$  holds if $t2 ô t1$ and
$t2 ô ³t1$ for some term $t1$.

Note that $strip\_tac$ may be used to push a negation inside other logical connectives,
which is often the best way of handling a negated goal.
=FRULE 2 Tactic
³_tac
¬t1®
÷
{  } ³t2
÷
{strip t2,  } t1; {strip t2,  } ³ t1
=TEX
=USES
To prove a negated term by showing that assuming the term gives rise to a contradiction.
=SEEALSO
$strip\_tac$, $contr\_tac$, $³\_T$
=FAILURE
28022	?0 is not boolean
28023	Goal is not of the form ¬³ t®
=ENDDOC

=DOC
val Ûsimple_³_in_tacÝ : TACTIC;
=DESCRIBE
This is a tactic which moves negations inside other predicate calculus
connectives using the following rules:
=GFT
		³³t			­	 t
		³(t1 ± t2)		­	 ³t1 ² ³t2
		³(t1 ² t2)		­	 ³t1 ± ³t2
		³(t1 ´ t2)		­	 t1 ± ³t2
		³(t1 ¤ t2)		­	 (t1 ± ³t2) ² (t2 ± ³t1)
		³µx·t			­	 ¶x·³t
		³¶x·t			­	 µx·³t
		³¶1x·t	­	 µx·³(t ± µx'·t[x'] ´ x' = x)
		³T			­	 F
		³F			­	 goal solved
=TEX
It fails with paired quantifiers.
=USES
The more general $³\_in\_tac$ is just as efficient as $simple\_³\_in\_tac$
in cases where both succeed.
=SEEALSO
$strip\_tac$, $contr\_tac$, $³\_T$, $³\_in\_tac$
=FAILURE
28025	No applicable rule for this goal
=ENDDOC

=DOC
val ÛSIMPLE_³_IN_THENÝ : THM_TACTICAL;
=DESCRIBE
This is a theorem tactical which applies a given 
theorem tactic to the result of transforming a theorem
by moving a top level negation inside other predicate calculus
connectives using the following rules:
=GFT
		³³t			­	 t
		³(t1 ± t2)		­	 ³t1 ² ³t2
		³(t1 ² t2)		­	 ³t1 ± ³t2
		³(t1 ´ t2)		­	 t1 ± ³t2
		³(t1 ¤ t2)		­	 (t1 ± ³t2) ² (t2 ± ³t1)
		³µx·t			­	 ¶x·³t
		³¶x·t			­	 µx·³t
		³¶1x·t	­	 µx·³(t ± µx'·t[x'] ´ x' = x)
		³T			­	 F
		³F			­	 T
=TEX
The function may be partially evaluated with only its theorem tactic and theorem arguments.
It fails with paired quantifiers.
=USES
The more general $³\_IN\_THEN$ is just as efficient as $SIMPLE\_³\_IN\_THEN$
in cases where both succeed.
=SEEALSO
$strip\_tac$, $STRIP\_THM\_THEN$
=FAILURE
28026	No applicable rule for this theorem
=ENDDOC

=DOC
val Û³_TÝ : TERM -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
A form of proof by contradiction using a theorem tactic to
simplify the subgoals.

Note that $strip\_tac$ may be used to push a negation inside other logical connectives,
which is often the best way of handling a negated goal.
=FRULE 2 Tactic
³_T
ttac
¬t1®
÷
{  } ³t2
÷
ttac (t2 ô t2) {  } t1; 
ttac (t2 ô t2) {  } ³ t1
=TEX
=USES
To prove a negated term by showing that assuming the term gives rise to a contradiction.
=SEEALSO
$strip\_tac$, $contr\_tac$, $³\_tac$, $STRIP\-\_CONCL\_T$, $³\_in\_conv$
=FAILURE
28022	?0 is not boolean
28023	Goal is not of the form ¬³ t®
=ENDDOC

=DOC
val Û³_T2Ý : TERM -> (THM -> TACTIC) -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
A form of proof by contradiction using two theorem tactics to
simplify the subgoals.

Note that $strip\_tac$ may be used to push a negation inside other logical connectives,
which is often the best way of handling a negated goal.
=FRULE 2 Tactic
³_T2
ttac1 ttac2
¬t1®
÷
{  } ³t2
÷
ttac1 (t2 ô t2) {  } t1; 
ttac2 (t2 ô t2) {  } ³ t1
=TEX
=USES
To prove a negated term by showing that assuming the term gives rise to a contradiction.
=SEEALSO
$strip\_tac$, $contr\_tac$, $³\_tac$, $STRIP\-\_CONCL\_T$, $³\_in\_conv$
=FAILURE
28022	?0 is not boolean
28023	Goal is not of the form ¬³ t®
=ENDDOC

=DOC
val Û³_elim_tacÝ : TERM -> TACTIC;
=DESCRIBE
Proof by showing assumptions give rise to two contradictory
subgoals.

N.B. loses information.
=FRULE 2 Tactic
³_elim_tac
¬t1®
÷
{  } t2
÷
{  } t1; {  } ³ t1
=TEX
The function may be partially evaluated with only its term argument.
=USES
In tactic programming.
If an assumption has its negation also in the assumption list
this will make for a rapid proof.
$asm\-\_ante\-\_tac\,t1\,THEN\,strip\_tac$ is a more memorable idiom for handling
such a case in interactive use but is a little slower.
=SEEALSO
$strip\_tac$
=FAILURE
28022	?0 is not boolean
=ENDDOC

\subsection{Concerning ±}
(New errors in this section begin with 2803.)
=DOC
val Û±_tacÝ : TACTIC;
=DESCRIBE
Reduce the proof of a conjunction to the proof of its conjuncts.
=FRULE 2 Tactic
±_tac
÷
{  } t1 ± t2
÷
{  } t1; {  } t2
=TEX
=SEEALSO
$strip\_tac$
=FAILURE
28031	Goal is not of the form: {  } t1 ± t2
=ENDDOC
=DOC
val Û±_THENÝ : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical to apply a given theorem tactic to the conjuncts of 
a theorem of the form $ ô t1 ± t2$.
=GFT
±_THEN thmtac ( ô t1 ± t2) = thmtac ( ô t1) THEN thmtac ( ô t2)
=TEX
The function may be partially evaluated with only its theorem tactic and theorem arguments.
=SEEALSO
$±\_THEN2$, $STRIP\_THM\_THEN$
=FAILURE
28032	?0 is not of the form: ` ô t1 ± t2`
=ENDDOC
=DOC
val Û±_THEN2Ý : (THM -> TACTIC) -> (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical to apply given theorem tactics to the conjuncts of 
a theorem of the form $ ô t1 ± t2$.
=GFT
±_THEN2 thmtac1 thmtac2 ( ô t1 ± t2) = thmtac1 ( ô t1) THEN thmtac2 ( ô t2)
=TEX
=SEEALSO
$±\_THEN$, $STRIP\_THM\_THEN$
=FAILURE
28032	?0 is not of the form: ` ô t1 ± t2`
=ENDDOC
\subsection{Concerning ²}
(New errors in this section begin with 2804.)
=DOC
val Û²_left_tacÝ : TACTIC;
=DESCRIBE
Take the left disjunct of the current
goal as the subgoal.

N.B. loses information.
=FRULE 2 Tactic
²_left_tac
÷
{  } a ² b
÷
{  } a
=TEX
=SEEALSO
$²\_left\_tac$, $swap\_²\_tac$, $strip\_tac$
=FAILURE
28041	Goal is not of the form: {  } a ² b
=ENDDOC

=DOC
val Û²_right_tacÝ : TACTIC;
=DESCRIBE
Take the right disjunct of the current
subgoal as the new subgoal.

N.B. loses information.
=FRULE 2 Tactic
²_right_tac
÷
{  } a ² b
÷
{  } b
=TEX
=SEEALSO
$²\_right\_tac$, $swap\_²\_tac$, $strip\_tac$
=FAILURE
28041	Goal is not of the form: {  } a ² b
=ENDDOC
=DOC
val Ûswap_²_tacÝ : TACTIC;
=DESCRIBE
Interchange the disjuncts of a disjunctive goal.
=FRULE 2 Tactic
swap_²_tac
÷
{  } a ² b
÷
{  } b ² a
=TEX
=USES
For use in conjunction with $strip\_tac$ (q.v.) when the reduction
of $\{  \} a ² b$ to $\{ ³a,  \} b$ is inappropriate.
=SEEALSO
$²\_left\_tac$, $²\_right\_tac$, $swap\_²\_tac$, $strip\-\_tac$
=FAILURE
28041	Goal is not of the form: {  } a ² b
=ENDDOC
=DOC
val Û²_THENÝ : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical to perform a case split on a given disjunctive theorem
applying a tactic generating function to the extra assumption in each branch.
=GFT
²_THEN ttac ( ô t1 ² t2) ({} t) = ttac (t1 ô t1) ({} t); ttac (t2 ô t2)({} t)
=TEX
The function may be partially evaluated with only its theorem tactic and theorem arguments.
=SEEALSO
$STRIP\_THM\_THEN$, $²\_THEN2$
=FAILURE
28042	?0 is not of the form: ` ô t1 ² t2`
=ENDDOC

=DOC
val Û²_THEN2Ý : (THM -> TACTIC) -> (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical to perform a case split on a given disjunctive theorem
applying tactic generating functions to the extra assumption in each branch.
=GFT
²_THEN2 ttac1 ttac2 ( ô t1 ² t2) ({} t) = 
	ttac1 (t1 ô t1) ({} t); ttac2 (t2 ô t2)({} t)
=TEX
The function may be partially evaluated with only its theorem tactic and theorem arguments.
=SEEALSO
$STRIP\_THM\_THEN$, $²\_THEN$
=FAILURE
28042	?0 is not of the form: ` ô t1 ² t2`
=ENDDOC

=DOC
val Ûcases_tacÝ : TERM -> TACTIC;
=DESCRIBE
Do a case split on a given boolean term.
=FRULE 2 Tactic
cases_tac
¬t1®
÷
{  } t2
÷
{strip t1,  } t2; {strip ³t1,  } t2
=TEX
=SEEALSO
$CASES\_T$, $²\_THEN$
=FAILURE
28022	?0 is not boolean
=ENDDOC

=DOC
val ÛCASES_TÝ : TERM -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
Do a case split on a given boolean term using a tactic generating function:
=GFT
CASES_T t1 ttac ({} t2) = ttac(t1 ô t1)({} t2) ; ttac(³t1 ô ³t1)({} t2)
=TEX
=SEEALSO
$cases\_tac$, $²\_THEN$, $CASES\_T2$
=FAILURE
28022	?0 is not boolean
=ENDDOC

=DOC
val ÛCASES_T2Ý : TERM -> (THM -> TACTIC) -> 
	(THM -> TACTIC) -> TACTIC;
=DESCRIBE
Do a case split on a given boolean term using two tactic generating functions:
=GFT
CASES_T2 t1 ttac1 ttac2 ({} t2) = ttac1(t1 ô t1)({} t2) ; ttac2(³t1 ô ³t1)({} t2)
=TEX
=SEEALSO
$cases\_tac$, $²\_THEN$, $CASES\_T$
=FAILURE
28022	?0 is not boolean
=ENDDOC

\subsection{Concerning ´}
(New errors in this section begin with 2805)
=DOC
val Û´_tacÝ : TACTIC;
=DESCRIBE
Strip the antecedent of an implicative goal into the assumption list.
=FRULE 2 Tactic
´_tac
÷
{  } t1 ´ t2
÷
{strip t1,  } t2
=TEX
=FAILURE
28051	Goal is not of form: {  } t1 ´ t2
=ENDDOC

=DOC
val Û´_TÝ : (THM -> TACTIC) -> TACTIC;
=DESCRIBE
Reduce an implicative goal
by passing the antecedent to a tactic generating function.
=FRULE 2 Tactic
´_T
ttac
÷
{  } t1 ´ t2
÷
ttac{ t1,  } t2
=TEX
=FAILURE
28051	Goal is not of form: {  } t1 ´ t2
=ENDDOC
=DOC
val Û´_THENÝ : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical to apply a given theorem tactic to the result
of eliminating $´$ from a theorem of the form $ ô t1 ´ t2$.
=GFT
´_THEN thmtac ( ô t1 ´ t2) = thmtac ( ô ³ t1 ² t2)
=TEX
The function is partially evaluated with only the
theorem tactic and theorem arguments.
=FAILURE
28054	?0 is not of the form: ` ô t1 ´ t2`
=ENDDOC

=DOC
val Ûasm_ante_tacÝ : TERM -> TACTIC ;
=DESCRIBE
Bring a term out of the assumption list into the goal as the antecedent
of an implication.
=FRULE 1 Rule
asm_ante_tac
¬t1®
÷
{ , t1' } t2
÷
{  } ô t1 ´ t2
=TEX
where $t1$ and $t1'$ are $\alpha$-convertible.
Note that all assumptions $\alpha$-convertible with $t1$ are removed.
=USES
Typically to make the assumption amenable to manipulation, e.g. by
a rewriting tactic.
=SEEALSO
$list\_asm\-\_ante\-\_tac$, $all\_asm\-\_ante\-\_tac$,
$swap\-\_asm\-\_concl\-\_tac$, $DROP\-\_ASM\-\_T$.
=FAILURE
28052	Term ?0 is not in the assumptions
28055	The conclusion or an assumption of goal does not have type BOOL®
=ENDDOC

=DOC
val Ûlist_asm_ante_tacÝ : TERM list -> TACTIC;
=DESCRIBE
Repeatedly apply $asm\-\_ante\-\_tac$.
=FRULE 1 Rule
list_asm_ante_tac
[¬t1®,...,¬tn®]
÷
{ , t1, ..., tn } t
÷
{  } t1 ´ ... ´ tn ´ t
=TEX
$\alpha$-equivalent assumptions will only appear once in the resulting
goal,
in their rightmost position,
(which also means that duplicates in the list are ignored).
=SEEALSO
$asm\-\_ante\-\_tac$, $all\_asm\-\_ante\-\_tac$
=FAILURE
28052	Term ?0 is not in the assumptions
28055	The conclusion or an assumption of goal does not have type BOOL®
=ENDDOC

=DOC
val Ûall_asm_ante_tacÝ : TACTIC;
=DESCRIBE
Apply $asm\-\_ante\-\_tac$ to every assumption in turn:
=FRULE 2 Tactic
all_asm_ante_tac
÷
{ t1, ..., tn } t
÷
{} tn ´ ... ´ t1 ´ t
=TEX
$\alpha$-equivalent assumptions will only appear once in the resulting
goal.
Notice that the first assumption becomes the rightmost antecedent.
=SEEALSO
$asm\-\_ante\-\_tac$, $list\_asm\-\_ante\-\_tac$
=FAILURE
28055	The conclusion or an assumption of goal does not have type BOOL®
=ENDDOC

=DOC
val Ûante_tacÝ : THM -> TACTIC;
=DESCRIBE
Replace a goal with conclusion $t2$ by $t1 ´ t2$, where
the antecedent, $t1$, of the implication is the conclusion of
a theorem:
=FRULE 2 Tactic
ante_tac (1 ô t1)
÷
{ 2 } t2
÷
{ 2 } t1 ´ t2
=TEX
where the assumptions, $1$, of the theorem are contained in the
assumptions, $2$ of the goal.
=USES
This is often useful if one needs to transform the conclusion of
theorem e.g. by rewriting with the assumptions.
=SEEALSO
$asm\_tac$, $strip\_asm\_tac$
=FAILURE
28027	Conclusion of goal does not have type BOOL®
=ENDDOC

\subsection{Concerning ¤}
(New errors in this section begin with 2806.)
=DOC
val Û¤_tacÝ : TACTIC;
=DESCRIBE
Reduce a bi-implication to two subgoals.
=FRULE 2 Tactic
¤_tac
÷
{  } t1 ¤ t2
÷
{strip t1,  } ô t2; {strip t2,  } ô t1
=TEX
=SEEALSO
$strip\_tac$, $¤_T$
=FAILURE
28061	Goal is not of the form: {  } t1 ¤ t2
=ENDDOC

=DOC
val Û¤_TÝ : (THM -> TACTIC) -> TACTIC;
=DESCRIBE
Reduce a bi-implication by passing each operand to a tactic generating
function.
=FRULE 2 Tactic
¤_T
ttac
÷
{  } t1 ¤ t2
÷
ttac{ t1,  } ô t2; ttac{ t2,  } ô t1
=TEX
=SEEALSO
$¤\_T2$, $STRIP\-\_CONCL\_T$
=FAILURE
28061	Goal is not of the form: {  } t1 ¤ t2
=ENDDOC

=DOC
val Û¤_T2Ý : (THM -> TACTIC) -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
Reduce a bi-implication by passing the operands to tactic generating
functions.
=FRULE 2 Tactic
¤_T2
ttac1 ttac2
÷
{  } t1 ¤ t2
÷
ttac1{ t1,  } ô t2; ttac2{ t2,  } ô t1
=TEX
=SEEALSO
$¤\_T$, $STRIP\-\_CONCL\_T$
=FAILURE
28061	Goal is not of the form: {  } t1 ¤ t2
=ENDDOC

=DOC
val Û¤_THENÝ : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical to apply a given theorem tactic to the result
of eliminating $¤$ from a theorem of the form $\ ô\ t1\ ¤\ t2$.
=GFT
¤_THEN thmtac ( ô t1 ¤ t2) = thmtac ( ô t1 ´ t2) THEN thmtac ( ô t2 ´ t1)
=TEX
The function is partially evaluated with only the
theorem tactic and theorem arguments.
=SEEALSO
$¤\_THEN2$, $STRIP\_THM\_THEN$
=FAILURE
28062	?0 is not of the form: ` ô t1 ¤ t2`
=ENDDOC

=DOC
val Û¤_THEN2Ý : (THM -> TACTIC) -> (THM -> TACTIC) -> 
	(THM -> TACTIC);
=DESCRIBE
A theorem tactical to apply given theorem tactics to the the result
of eliminating $¤$ from a theorem of the form $ ô t1 ¤ t2$.
=GFT
¤_THEN2 ttac1 ttac2( ô t1 ¤ t2) = ttac1( ô t1 ´ t2) THEN ttac2( ô t2 ´ t1)
=TEX
The function is partially evaluated with only the
theorem tactic and theorem arguments.
=SEEALSO
$¤\_THEN$, $STRIP\_THM\_THEN$
=FAILURE
28062	?0 is not of the form: ` ô t1 ¤ t2`
=ENDDOC


\subsection{Concerning $if\ldots then\ldots else \ldots$}
(New errors in this section begin with 2807.)

=DOC
val Ûif_tacÝ : TACTIC;
=DESCRIBE
Reduce a conditional subgoal by performing a case split on the
selector.
=FRULE 2 Tactic
if_tac
÷
{  } if a then tt else et
÷
{strip a,  } tt ;  {strip ³a,  } et
=TEX
=SEEALSO
$strip\_tac$
=FAILURE
28071	Goal is not of the form: {  } if a then tt else et
=ENDDOC

=DOC
val ÛIF_TÝ : (THM -> TACTIC) -> TACTIC;
=DESCRIBE
Reduce a conditional by applying a tactic generating function to the
two cases for the selector.
=FRULE 2 Tactic
IF_T
ttac
÷
{  } if a then tt else et
÷
ttac{ a,  } ô tt; ttac{ ³a,  } ô et
=TEX
=SEEALSO
$IF\_T2$, $STRIP\-\_CONCL\_T$
=FAILURE
28071	Goal is not of the form: {  } if a then tt else et
=ENDDOC

=DOC
val ÛIF_T2Ý : (THM -> TACTIC) -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
Reduce a conditional by applying tactic generating functions to the
two cases for the selector.
=FRULE 2 Tactic
IF_T2
ttac1 ttac2
÷
{  } if a then tt else et
÷
ttac1{ a,  } ô tt; ttac2{ ³a,  } ô et
=TEX
=SEEALSO
$¤\_T$, $STRIP\-\_CONCL\_T$
=FAILURE
28071	Goal is not of the form: {  } if a then tt else et
=ENDDOC

=DOC
val ÛIF_THENÝ : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical to apply a given theorem tactic to the result
of eliminating the conditional from a theorem with a conditional as its
conclusion.
=GFT
IF_THEN ttac ( ô if a then tt else et) = ttac ( ô a ´ tt) THEN ttac ( ô ³ a ´ et)
=TEX
The function is partially evaluated with only the
theorem tactic and theorem arguments.
=SEEALSO
$IF\_THEN2$, $STRIP\_THM\_THEN$
=FAILURE
7012	?0 is not of the form: ` ô if tc then tt else te`
=ENDDOC

=DOC
val ÛIF_THEN2Ý : (THM -> TACTIC) -> (THM -> TACTIC) -> 
	(THM -> TACTIC);
=DESCRIBE
A theorem tactical to apply given theorem tactics to the result
of eliminating the conditional from a theorem with a conditional as its
conclusion.
=GFT
IF_THEN ttac ( ô if a then tt else et) = ttac1 (a,  ô tt) THEN ttac2 (³a,  ô et)
=TEX
The function is partially evaluated with only the
theorem tactic and theorem arguments.
=SEEALSO
$IF\_THEN$, $STRIP\_THM\_THEN$
=FAILURE
7012	?0 is not of the form: ` ô if tc then tt else te`
=ENDDOC

\subsection{Concerning µ}
(New errors in this section begin with 2808.)

=DOC
val Ûsimple_µ_tacÝ : TACTIC;
=DESCRIBE
Reduce a universally quantified goal.
It fails with paired quantifiers.
=FRULE 2 Tactic
simple_µ_tac
÷
{  } µ x · t[x]
÷
{  } t[x']
=TEX
where $x'$ is a variant name of $x$, different from any 
variable in $$ or $t$.
=USES
Tactic programming.
The more general $µ\_tac$ is just as efficient as $simple\_µ\_tac$
in cases where both succeed.
=SEEALSO
$µ\_tac$
=FAILURE
28081	Goal is not of the form: {  } µ x · t[x]
=ENDDOC


\subsection{Concerning ¶}
(New errors in this section begin with 2809.)

=DOC
val Ûsimple_¶_tacÝ : TERM -> TACTIC ;
=DESCRIBE
Provide a witness for an existential subgoal.
It fails with paired quantifiers.

N.B. loses information.
=FRULE 2 Tactic
simple_¶_tac
¬t1®
÷
{  } ¶ x · t2[x]
÷
{  } t2[t1]
=TEX
where $t1$ must have the same type as $x$.
=USES
Tactic programming.
The more general $¶\_tac$ is just as efficient as $simple\_¶\_tac$
in cases where both succeed.
=FAILURE
28091	Goal is not of the form: {  } ¶ x · t2[x] 
28092	Term ?0 has the wrong type
=ENDDOC
$¶\_tac$ is expected to be able to type instantiate
its argument if necessary, but $simple\_¶\_tac$ is not required to do this.
=DOC
val ÛSIMPLE_¶_THENÝ : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical which applies a given theorem tactic to the result
of eliminating the outermost quantifier from a theorem of the form
$ ô ¶x·t$.
It fails with paired quantifiers.
=GFT
SIMPLE_¶_THEN thmtac ( ô ¶x·t) = thmtac ( ô t[x'/x])
=TEX
where ¬x'® is a variant of ¬x® which does not appear in $$ or in
the assumption or conclusion of the goal.
The function is partially evaluated with only the
theorem tactic and theorem arguments.
=USES
Tactic programming. Note that the more general $¶\_THEN$ is just as
efficient as $SIMPLE\_¶\_THEN$ in cases where both succeed.
=SEEALSO
$¶\_THEN$
=FAILURE
28093	?0 is not of the form: ` ô ¶ x · t`
=ENDDOC

\subsection{Concerning ¶$_1$}
(New errors in this section begin with 2810.)

=DOC
val Ûsimple_¶1_tacÝ : TERM -> TACTIC;
=DESCRIBE
Simplify a unique existentially quantified goal with a particular
witness.
It fails with paired quantifiers.

N.B. loses information.
=FRULE 2 Tactic
simple_¶1_tac1
¬t®
÷
{  } simple_¶1 x · P[x]
÷
{  } P[t];
{  } µ x' · P[x'] ´ x' = t
=TEX
where $x'$ is a variant of $x$ which does not occur free in $t$.
=USES
Tactic programming.
The more general $¶_1\_tac$ is just as efficient as $simple\-\_¶_1\_tac$
in cases where both succeed.
=FAILURE
28101	Goal is not of the form: {  } ¶1 x · P[x]
28092	Term ?0 has the wrong type
=ENDDOC
Like $simple\_¶\_tac$, $simple\_¶_1\_tac$ is not required to be able
to type instantiate its argument.
=DOC
val ÛSIMPLE_¶1_THENÝ : (THM -> TACTIC) -> (THM -> TACTIC);
=DESCRIBE
A theorem tactical which applies a given theorem tactic to the result
of eliminating the outermost quantifier from a theorem of the form
$ ô ¶_1x·t$.
It fails with paired quantifiers.
=GFT
SIMPLE_¶1_THEN thmtac ( ô ¶1x·t) = 
	thmtac ( ô t[x'/x] ± µx''·P[x''] ´ x'' = x)
=TEX
where ¬x'® and ¬x''® are distinct variants of ¬x® which do not appear free in $$ or in
the assumptions or conclusion of the goal.
=USES
Tactic programming.
The more general $¶1\_THEN$ is just as efficient as $SIMPLE\-\_¶1\_THEN$
in cases where both succeed.
=FAILURE
28102	?0 is not of the form: ` ô ¶1 x · t`
=ENDDOC
\subsection{Concerning Assumptions}
Much of the subgoal assumption handling material provided in ICL
HOL has already been given in \cite{DS/FMU/IED/DTD009},
as the $GET\_ASM\_T$ family.
The following family of functions are related, allowing the
user to ``swap'' one or more assumptions with the current goal,
negating and stripping as necessary.
=DOC
val Ûswap_asm_concl_tacÝ : TERM -> TACTIC;
val Ûswap_nth_asm_concl_tacÝ : int -> TACTIC;
=DESCRIBE
Strip the negation of current goal into the assumption list
and make an assumption, suitably negated, into the 
current goal.
If the simplifications it does are ignored, 
=INLINEFT
swap_asm_concl_tac asm
=TEX
is equivalent to
=GFT Example
contr_tac THEN asm_ante_tac asm 
=TEX
and
=INLINEFT
swap_nth_asm_concl_tac n
=TEX
is equivalent to
=GFT Example
contr_tac THEN DROP_NTH_ASM_T n ante_tac 
=TEX

=FRULE 2 Tactic
swap_asm_concl_tac
¬t1®
÷
{ , ¬t1® } t2
÷
{strip ¬³ t2®, } ³ t1
=TEX
=FRULE 2 Tactic
swap_nth_asm_concl_tac
m
÷
{ ¬t1®, ..., ¬tm®,..., ¬tn®} t
÷
{strip ¬³ t®, ¬t1®,..., ¬tn®} ³ tm
=TEX
If the assumption is a negated term then the double negation
will be eliminated.
=SEEALSO
Other $swap$ and $SWAP$ functions.
=FAILURE
9303	the index ?0 is out of range
28052	Term ?0 is not in the assumptions
=ENDDOC
=DOC
val Ûlist_swap_asm_concl_tacÝ : TERM list -> TACTIC;
val Ûlist_swap_nth_asm_concl_tacÝ : int list -> TACTIC;
=DESCRIBE
Strip the negation of current goal into the assumption list
and make some assumptions, suitably negated, into a disjunction forming the 
current goal.
If the list is empty then the conclusion will become $¬F®$.

=FRULE 2 Tactic
list_swap_asm_concl_tac
[¬t1®,...,¬tn®]
÷
{  } t2
÷
{strip ¬³ t2®,  - {¬t1®,...,¬tn®}} 
	³ t1 ² ... ² ³ tn
=TEX
=FRULE 2 Tactic
list_swap_nth_asm_concl_tac
[p,...,q]
÷
{  } t
÷
{strip ¬³ t®,  - {¬tp®, ..., ¬tq®}} 
	³ tp ² ... ³ tq
=TEX
If any assumption is a negated term then the double negation
will be eliminated.
=SEEALSO
Other $swap$ and $SWAP$ functions.
=FAILURE
9303	the index ?0 is out of range
28052	Term ?0 is not in the assumptions
=ENDDOC

=DOC
val ÛSWAP_ASM_CONCL_TÝ : TERM -> (THM -> TACTIC) -> TACTIC;
val ÛSWAP_NTH_ASM_CONCL_TÝ : int -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
Process the negation of current goal with the supplied theorem tactic
and make an assumption, suitably negated, into the 
current goal.
If the simplifications it does are ignored, 
=INLINEFT
SWAP_ASM_CONCL_T asm ttac
=TEX
is equivalent to
=GFT Example
C_CONTR_T (fn x => asm_ante_tac asm THEN ttac x)
=TEX
and
=INLINEFT
SWAP_NTH_ASM_CONCL_T n ttac
=TEX
is equivalent to
=GFT Example
C_CONTR_T (fn x => (DROP_NTH_ASM_T n ante_tac) THEN ttac x)
=TEX

=FRULE 2 Tactic
SWAP_ASM_CONCL_T
¬t1®
ttac
÷
{ , ¬t1® } t2
÷
ttac(asm_rule ¬³t2® )({} ³ t1)
=TEX
=FRULE 2 Tactic
SWAP_NTH_ASM_CONCL_T
m
ttac
÷
{ ¬t1®, ..., ¬tm®, ..., ¬tn®} t
÷
ttac(asm_rule ¬³t® ) 
	({¬t1®, ..., ¬tn®} ³ tm)
=TEX
If the assumption is a negated term then the double negation
will be eliminated.
=SEEALSO
Other $swap$ and $SWAP$ functions.
=FAILURE
9303	the index ?0 is out of range
28027	Conclusion of goal does not have type BOOL®
28052	Term ?0 is not in the assumptions
=ENDDOC
=DOC
val ÛLIST_SWAP_ASM_CONCL_TÝ 
	: TERM list -> (THM -> TACTIC) -> TACTIC;
val ÛLIST_SWAP_NTH_ASM_CONCL_TÝ 
	: int list -> (THM -> TACTIC) -> TACTIC;
=DESCRIBE
Process the negation of current goal with the supplied theorem tactic
and make some assumptions, suitably negated, into a disjunction forming the 
current goal.
=FRULE 2 Tactic
LIST_SWAP_ASM_CONCL_T
[¬tp®,...¬tq®]
ttac
÷
{  } t
÷
ttac(asm_rule ¬³t® )
	({ - {¬tp®,...¬tq®}} ³ t1)
=TEX
=FRULE 2 Tactic
LIST_SWAP_NTH_ASM_CONCL_T
[p, ..., q]
ttac
÷
{  } t
÷
ttac(asm_rule ¬³t® ) 
	({ - {¬tp®, ..., ¬tq®}} ³ tm)
=TEX
If an assumption is a negated term then the double negation
will be eliminated.
If the list is empty then the conclusion (before applying the tactic argument) will become $¬F®$.
=SEEALSO
Other $swap$ and $SWAP$ functions.
=FAILURE
9303	the index ?0 is out of range
28052	Term ?0 is not in the assumptions
28027	Conclusion of goal does not have type BOOL®
=ENDDOC

\subsection{$lemma\_tac$}
(New errors in this section begin with 2811.)
=DOC
val Ûlemma_tacÝ : TERM -> TACTIC;
=DESCRIBE
Introduce a lemma (the term argument) to be proved,
and then added as an assumption.

N.B. loses information.
=FRULE 2 Tactic
lemma_tac
¬t1®
÷
{  } t2
÷
{  } t1;
{strip t1, } t2
=TEX
=SEEALSO
$LEMMA\_T$
=FAILURE
9603	the term ?0 is not boolean
=ENDDOC
\subsection{Tautology Prover}
(New errors in this section begin with 2812.)
Note that unlike the tautology provers in earlier instances of HOL,
our $taut\_tac$ proves a goal if and only if its conclusion is
a tautology in the precise sense defined in the following box.
It will not prove $1 = 1$ or $µx·T$.
=DOC
val Ûsimple_taut_tacÝ : TACTIC;
=DESCRIBE
A tautology prover.
If the conclusion of the goal is a tautology then $taut\_tac$ will prove
the goal.
A tautology is taken to be any substitution
instance of a term which is formed from boolean variables,
the constants $T$ and $F$ and the following
connectives:
=GFT
±, ², ´, ¤, ³, if ... then ... else
=TEX
and which is true for any assignment of truth values to the variables.
=FRULE 2 Tactic
simple_taut_tac
÷
{  } t
÷
=TEX
=SEEALSO
$strip\_tac$
=FAILURE
28121	Conclusion of the goal is not a tautology
=ENDDOC
($TAUT\_TAC$ in Cambridge HOL)
\section{CONVERSIONS}\label{CONVERSIONS}
(New errors in this section begin with 2813.)
=DOC
val Ûsimple_³_in_convÝ : CONV;
=DESCRIBE
This is a conversion which moves negations inside other predicate
calculus connectives using whichever of the following rules applies:
=GFT
		³³t			=	 t
		³(t1 ± t2)		=	 ³t1 ² ³t2
		³(t1 ² t2)		=	 ³t1 ± ³t2
		³(t1 ´ t2)		=	 t1 ± ³t2
		³(t1 ¤ t2)		=	 (t1 ± ³t2) ² (t2 ± ³t1)
		³(if a then t1 else t2)
					=	 (if a then ³t1 else ³t2)
		³µx·t			=	 ¶x·³t
		³¶x·t			=	 µx·³t
		³¶1x·t	=	 µx·³(t ± µx'·t[x'] ´ x' = x)
		³T			=	 F
		³F			=	 T
=TEX
It does not handle paired quantifiers.
=USES
Tactic and conversion programming.
The more general $³\_in\_conv$ is just as efficient as $simple\_³\_in\_conv$
in cases where both succeed.
=SEEALSO
$strip\_tac$
=FAILURE
28131	No applicable rules for the term ?0
=ENDDOC
=DOC
val Ûsimple_¶1_convÝ : CONV;
=DESCRIBE
This is a conversion which turns a unique existential quantifier into
an equivalent existential quantifier
=FRULE 1 Conversion
simple_¶1_conv
¬¶1x·t®
÷
÷
ô (¶1x·t[x]) ¤ 
	(¶x·t[x] ± µx'·t[x'] ´ x' = x)
=USES
Tactic and conversion programming.
The more general $¶_1\_conv$ is just as efficient as $simple\_¶_1\_conv$
in cases where both succeed.
=SEEALSO
$strip\_tac$
=FAILURE
4019	?0 is not of form: ¬¶1 v· t®
=ENDDOC
\section{THEOREMS}
The following sets of theorems will be needed to code the tactics and because
of their general utility are saved for reuse (as a space optimisation, since
their proofs are trivial once the tactics defined here are available).
=DOC
val Û³_³_thmÝ : THM
val Û³_²_thmÝ : THM
val Û³_±_thmÝ : THM
val Û³_´_thmÝ : THM
val Û³_¤_thmÝ : THM
val Û³_if_thmÝ : THM
val Û³_f_thmÝ : THM

val Û´_thmÝ : THM
val Û¤_thmÝ : THM
val Ûif_thmÝ : THM
=DESCRIBE
These theorems are tautologies saved in the theory
``misc'' because they are frequently used in tactic
and conversion programming.

The first seven theorems are De Morgan's laws for the various
propositional connectives formulated so that they can be used to normalise
a propositional term by moving all negations inside other connectives.
$³\_t\_thm$ is also provided but is documented elsewhere.

The last three theorems give definitions for implication, bi-implication
and conditional in terms of disjunction, conjunction and negation.
=GFT
³_³_thm		ô µa·³ ³a ¤ a
³_²_thm		ô µa b·³ (a ² b) ¤ (³a ± ³b)
³_±_thm		ô ( ³(a ± b) ¤ (³a ² ³b)
³_´_thm		ô µa b·³(a ´ b) ¤ (a ± ³b)
³_¤_thm		ô µ a b · ³ (a ¤ b) ¤ a ± ³ b ² b ± ³ a
³_if_thm		ô µ a b · ³ (if a then T else T) ¤ (if a then ³ T else ³ T)

³_f_thm		ô ³F ¤ T
´_thm			ô µa b·(a ´ b) ¤ (³a ² b)
¤_thm			ô µa b·(a ¤ b) ¤ (a ´ b) ± (b ´ a)
if_thm			ô µa b c·(if a then b else c) ¤ (a ± b) ² (³a ± c)
=TEX
=SEEALSO
$³\_t\_thm$.
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of Tactics2 *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested according to the
general criteria given in \cite{DS/FMU/IED/PLN008}.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}



