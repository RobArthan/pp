=IGN
********************************************************************************
imp111.doc: this file is part of the PPHol system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
%Z% $Id: imp111.doc,v 1.27 2004/01/24 12:55:04 rda Exp rda $
=TEX
% %Z% $Id: imp111.doc,v 1.27 2004/01/24 12:55:04 rda Exp rda $
\documentstyle[11pt,TQ,hol1]{article}

\TPPtitle{Implementation of the UNIX Interface for ProofPower under Solaris 2 and Linux}
\TPPref{DS/FMU/IED/IMP099}
\def\SCCSissue{$Revision: 1.27 $%
}
\TPPissue{\SCCSissue}
\TPPdate{\FormatDate{$Date: 2004/01/24 12:55:04 $%
}}
\TPPproject{FST PROJECT}

\TPPstatus{Draft}
\TPPtype{Literate Script}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & Lemma 1}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & Lemma 1}
\TPPabstract{This document contains the implementation of the
	\Product{} UNIX Interface, and in particular the 
	standard way of invoking versions of \Product{} compiled under Standard ML of New Jersey.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

\ftlinepenalty=9999
\makeindex

\underscoreoff

\begin{document}
\makeTPPfrontpage
\vfill
\begin{center}
\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year
\end{center}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}

\begin{description}
\item[Issue 1.1]
First version based in DS/FMU/IED/IMP069.

\item[Issue 1.2--1.5]
Miscellaneous improvements after module and system testing.
\item[Issue 1.5--1.7]
Fixes during acceptance testing.
\item[Issue 1.8]
Fixed mode of $zed\_list$ and $hol_list$.
\item[Issue 1.9]
Corrected handling of `Q' in file names.
\item[Issue 1.10,1.11] Updates for Poly/ML port.
\item[Issue 1.11] No longer uses an initialisation error file.
\item[Issues 1.12, 1.13] Various improvements supplied by Phil Clayton of QinetiQ (PBC);
fixed bug when parent database in {\it pp\_make\_database} isn't writable but needs to be.
\item[Issue 1.14] {\tt pp\_read} really has been withdrawn now.
\item[Issue 1.15] Added missing line to {\it pp\_make\_database}
that allows the parent to be specified with or without a suffix.
\item[Issue 1.18] Copyright and banner updates for open source release.
\item[Issue 1.19] PPHol-specific updates for open source release
\item[Issue 1.20] Added code from Phil Clayton to let {\it pp\_make\_database} adjust Poly/ML database
size limits.
\item[Issue 1.21]  Removed attempt to test that parent size limit has been minimized
from {\it pp\_make\_database} (since it is an overhead and David Matthews says the
method used for the test may not always work).
\item[Issue 1.22] {\it pp\_make\_database} now picks up default value for COMPACT
from an environment variable PPCOMPACT for compatibility with Poly/ML 4.1.2.
\item[Issue 1.23] Updates for Poly/ML v 4.1.2.
\item[Issue 1.24] More work on PPCOMPACT.
\item[Issue 1.25] Fixed Solaris incompatibility.
\item[Issue 1.26,1.27] First cut for out-of-the-box running.
\end{description}

\subsection{Changes Forecast}
None known.

\newpage

\section{GENERAL}

\subsection{Scope}

This document contains the implementation of the \Product{}/ UNIX  interface programs under Solaris 2
called for by~\cite{DS/FMU/IED/HLD005},
and given a detailed design in \cite{DS/FMU/IED/DTD111}.

\subsection{Introduction}

\subsubsection{Purpose and Background}
This document contains the implementation of the \Product/ UNIX  interface programs for Solaris 2
given a detailed design in \cite{DS/FMU/IED/DTD111}.

\subsubsection{Dependencies}
To be called by this interface, an ML database providing
the features defined in \cite{DS/FMU/DTD036} is required.

\subsubsection{Interface}

The user interface is described in the style of UNIX manual pages in
\cite{DS/FMU/IED/HLD005}.

\subsubsection{Possible Enhancements}
None known.

\subsubsection{Deficiencies}
None known.

\newpage
\section{STRUCTURE OF THIS DOCUMENT}

The program code in this document may be extracted for
compilation.  The whole of the text may be used as source to the
\LaTeX{} document processing system, after some formatting instructions
are added to the text of the program code.  The {\tt sieve} program
(see \cite{DS/FMU/IED/DTD053}) perfoms the necessary extraction and
adding of format instructions.  This process is known as
``sieving''.  The source text is augmented by sieving directives
which delimit the sorts of text.   The {\tt sieve} program is driven
by steering files which describe how to process the various sorts of
text.

Thus the commands given an implementation in this document will be 
implemented by shell scripts ``sieved'' from \cite{DS/FMU/IED/IMP099}.
An appropriate invocation of sieving is just:

\begin{verbatim}
docsml imp099
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{COMMON MATERIAL}
Note: the following code is also in \cite{DS/FMU/IED/IMP100} so if there is a bug here
it should be fixed there as well.
=DUMP hol_common
PROGNAME=`basename $0`
diag() {
	echo $PROGNAME: $* 1>&2
}
if test "$PPENVDEBUG" = ""
then
	env_diag() {
		true
	}
else
	env_diag() {
		diag $*
	}
fi
set_pp_home() {
	if test "$PPHOME" = ""
	then
		BINDIR=`dirname $0`
		if test "$BINDIR" = ""
		then
			BINDIR="."
		fi
		FINDFILE=$BINDIR/findfile
		if test -x $FINDFILE && BINFILE=`$FINDFILE -r $0`
		then
			env_diag "found real path to executable $0 at $BINFILE"
			REALBINDIR=`dirname $BINFILE`
			PPHOME=`dirname $REALBINDIR`
			if test -d $PPHOME
			then
				env_diag "using PPHOME=$PPHOME"
				export PPHOME
				PATH=$PPHOME/bin:$PATH
				env_diag "using PATH=$PATH"
			else
				env_diag cannot access $PPHOME
				diag "cannot locate the ProofPower installation directory"
			fi
		else
			env_diag "cannot find real path to executable $0"
			diag "cannot locate the ProofPower installation directory"
			exit 1
		fi
	else	env_diag "PPHOME set by caller to $PPHOME"
		env_diag "PATH set by caller to $PATH"
	fi
	if test "$PPDATABASEPATH" = ""
	then
		PPDATABASEPATH=".:$HOME/db:$PPHOME/db:$PATH"
		export PPDATABASEPATH
		env_diag "using PPDATABASEPATH=$PPDATABASEPATH"
	else
		env_diag "PPDATABASEPATH set by caller to $PPDATABASEPATH"
	fi
}
=TEX
\section{RUN A SESSION}
In outline the program $pp$ and its special invocations ($hol$ and $zed$) should in order:
\begin{enumerate}
\item
Do initial argument proccessing;
\item
Find a database;
\item
Enable the list of initialisation script names and current theory name to be accessed.
\item
Run {\tt poly} on the database.
\end{enumerate}
The program relies on the start of session initialisation
routines of \cite{DS/FMU/IED/DTD036} to set the line length,
load up the theory hierarchy,
set the current theory,
and read in the named scripts,
before returning control to the user.
These actions are done by consulting the UNIX environment,
and the value of $icl'database\_info$.

\subsection{Program {\tt hol}}
=DUMP hol
#! /bin/sh
#	hol   From: $Id: imp111.doc,v 1.27 2004/01/24 12:55:04 rda Exp rda $ %Z%
#
# Shell script to start a ProofPower-HOL session
PROGNAME=hol
USAGE="$PROGNAME [-d database[#theoryname]] [-i files] [-f files [-n|-s] [-v]] [-- ml_flags]"
export PROGNAME USAGE
pp -d hol $*
=TEX
\subsection{Program {\tt zed}}
=DUMP zed
#! /bin/sh
#	zed   From: $Id: imp111.doc,v 1.27 2004/01/24 12:55:04 rda Exp rda $ %Z%
#
# Shell script to start a ProofPower-Z session
PROGNAME=zed
USAGE="$PROGNAME [-d database[#theoryname]] [-i files] [-f files [-n|-s] [-v]] [-- ml_flags]"
export PROGNAME USAGE
pp -d zed $*
=TEX
\subsection{Program {\tt pp}}
=DUMP pp
#! /bin/sh
#	pp   From: $Id: imp111.doc,v 1.27 2004/01/24 12:55:04 rda Exp rda $ %Z%
#
# Shell script to start a ProofPower session

if test -z "$PROGNAME"
then
	PROGNAME=`basename $0`
	USAGE=\
"$PROGNAME -d database[#theoryname] [-i files] [-f files [-n|-s] [-v]] [-- ml_flags]"
fi
USAGEMSG="usage: $USAGE"
=SH
cat hol_common >>pp
=DUMPMORE pp
BATCH=""
DBN=""
FILES=""
INITS=""
MLFLAGS=""
NFLAG=""
VERBOSE="false"
SFLAG=""
SAVE_ON_SUCCESS="true"
SAVE_ON_FAIL="false"
=TEX

Process arguments

=DUMPMORE pp
while getopts d:i:f:nsv arg
do
	case $arg in
	d)	DBN=$OPTARG ;;
	i)	INITS="$INITS,$OPTARG" ;;
	f)	BATCH="y"
		if	test -z "$FILES"
		then	FILES="$OPTARG"
		else	FILES="$FILES,$OPTARG"
		fi ;;
	n)	NFLAG="y"
		if test -n "$SFLAG"
		then
			SFLAG=""
			diag "$PROGNAME: warning: -s flag ignored"
		fi ;;
	s)	if test -z "$NFLAG"
		then
			SFLAG="y"
		else
			SFLAG=""
			diag "$PROGNAME: warning: -s flag ignored"
		fi ;;
	v)	VERBOSE="true" ;;
	esac
done
shift `expr $OPTIND - 1`
MLFLAGS=$*
=TEX

Check consistency of arguments: $-n$ and $-s$ control the way $-f$
works and don't make sense without it.

=DUMPMORE pp
if test -z "$BATCH"
then
	if test -n "$NFLAG" -o -n "$SFLAG" -o "$VERBOSE" = "true"
	then
		diag "the flags -n, -s and -v are only for use with the -f flag"
		diag $USAGEMSG
		exit 1
	fi
fi
=TEX

Call function from common code to set up PPHOME etc. if necessary:

=DUMPMORE pp
set_pp_home
=TEX

Make sure we have a database name:

=DUMPMORE pp
if test -z "$DBN"
then
	diag $USAGEMSG
	exit 1
fi
=TEX

Get the directory name and base name for the database. Set path to "." if the database name contains slashes.

=DUMPMORE pp
DATABASE=`echo $DBN|sed -e "s/#.*//"` >&2
if test `basename $DATABASE` = $DATABASE
then
	DDATABASE=""
	BDATABASE=`basename $DATABASE`
else
	DDATABASE=`dirname $DATABASE`"/"
	BDATABASE=`basename $DATABASE`
	PPDATABASEPATH="."
fi
=TEX

Test for compiler to use:
=POLYDUMPMORE pp
COMPILER=${PPCOMPILER:-POLYML}
=NJMLDUMPMORE pp
COMPILER=${PPCOMPILER:-SMLNJ}
=DUMPMORE pp
if test "$PPCOMPILER" = ""
then
	env_diag "Using PPCOMPILER=$COMPILER"
else
	env_diag "PPCOMPILER set by caller to $PPCOMPILER"
fi
if test "$COMPILER" = POLYML
then
	RUNML="poly $MLFLAGS "
	HEAP_SUFFIX=polydb
elif test "$COMPILER" = SMLNJ
then
	RUNML="sml $MLFLAGS @SMLload="
	eval `.arch-n-opsys`
else
	diag "$PROGNAME: environment variable PPCOMPILER is "$COMPILER" but should be POLYML or SMLNJ"
	exit 1
fi
=TEX
Test for compiler to use and the for the heap suffix, or none at all:
=DUMPMORE pp
BDATABASE=`basename $BDATABASE .$HEAP_SUFFIX`
=TEX

Extract current theory name:

=DUMPMORE pp
hol_current_theory=`echo $DBN| grep "#" | sed -e "s/.*#//"`
export hol_current_theory
hol_initialisation_scripts=$INITS
export hol_initialisation_scripts
=TEX

Find a database:

[PBC] Added `.' to path\\
[PBC] DATABASEPATH used instead of PATH\\
[PBC] Changed DATABASEFN to DATABASEN\\
[PBC] Removed leading `./' from filename, and not later\\
[PBC] Changed position of first double quote sign for uniformity\\
[PBC] Put more precise db name

For out-of-the-box running, we end up using findfile twice.
We call it for real to get the name into DATABASESN, which
may involve symbolic links.
Then we call it with -r to resolve any symbolic links (otherwise the name might not
be consistentent when called with PPHOME calculated rather than set by caller).
=DUMPMORE pp
DATABASESN=`findfile $DDATABASE$BDATABASE.$HEAP_SUFFIX $PPDATABASEPATH`
DATABASEN=`findfile -r $DATABASESN`
if test $? != 0
then
	diag "$PROGNAME: database $DDATABASE$BDATABASE.$HEAP_SUFFIX not found"
	exit 1
fi
=TEX
[PBC] Changed position of first double quote sign for uniformity

[PBC] Put more precise db name

=DUMPMORE pp
if test -r $DATABASEN
then
	:
else
	diag "$PROGNAME: database $DDATABASE$BDATABASE.$HEAP_SUFFIX not readable"
	exit 1
fi
=TEX

Get an absolute pathname

[PBC] Leading `./' already removed from filename\\
[PBC] Changed DATABASEFN to DATABASEN on rhs below

=DUMPMORE pp
PWD=`pwd | sed -e 's/\\//\\\\\\//g'`
DATABASEFN=`echo $DATABASEN | sed -e "s/^[^/]/$PWD\/&/"`
=TEX
=TEX

trap resetting on normal exit (0) and others.
From this point on need to set $exit\_status$ rather than use $exit$ command.
=DUMPMORE pp
exit_status=1
trap "exit \$exit_status" 0
trap "exit 1" 1 3 15
if test "$NFLAG" = "y"
then
	SAVE_ON_SUCCESS="false"
else	if test "$SFLAG" = "y"
	then
		SAVE_ON_FAIL="true"
	fi
fi
#
#
=TEX
Run the session:
=DUMPMORE pp
if test -n "$BATCH"
then
	QUOTED_NAMES=`echo $FILES | sed -e 's/[^,][^,]*/"&"/g'`
	trap "exit 1" 2
	COMMAND=" \
	  let \
	    val reset_quiet = set_flag(\"subgoal_package_quiet\","$VERBOSE") \
					handle Fail _ => false; \
	    val ok = HOLSystem.load_files (map translate_for_output["$QUOTED_NAMES"]); \
	    val dummy = set_flag(\"subgoal_package_quiet\", reset_quiet) \
					handle Fail _ => false; \
	  in \
		if ok \
		then	if "$SAVE_ON_SUCCESS" \
			then	save_and_exit 0 \
			else	exit 0 \
		else	if "$SAVE_ON_FAIL" \
			then	save_and_exit 1 \
			else	exit 1 \
	  end;"
	echo $COMMAND | $RUNML$DATABASEFN 2>&1
	EXIT_STATUS=$?
else
	$RUNML$DATABASEFN
	EXIT_STATUS=$?
fi
#
=TEX

Check that the program exited with status 0:
=DUMPMORE pp
if test $EXIT_STATUS -ne 0
then
	diag "$PROGNAME :\"$RUNML$DATABASEFN\" exited with status $EXIT_STATUS"
	exit_status=1
	exit 1
fi
=TEX
Clean exit:
=DUMPMORE pp
exit_status=0
=TEX

=TEX
Now make the programs executable
=SH
chmod +x hol zed pp
=TEX
\section{CHILD DATABASES}
\subsection{Program {\tt pp\_make\_database}}
In outline this program should in order:
\begin{enumerate}
\item
Do initial argument proccessing;
\item
Find the parent database file name;
\item
Determine the new database's filename and actual name;
\item
Run poly on the parent database,
\item
Try to see whether 
=GFTSHOW
icl'Kernel.icl'new_hierarchy();
=TEX
succeeds.
If not,
freeze the theory hierarchy.
=GFTSHOW
icl'Kernel.icl'freeze_hierarchy();
=GFTSHOW
val icl'theory_hierarchy = Value (icl'Kernel.icl'new_hierarchy ());
=TEX
\item
Load that hierarchy.
\item
Open the selected parent theory and then create
a new theory.
=GFTSHOW
open_theory <pttheory>;
new_theory <cttheory>;
=TEX
\item
Save and quit.
=GFTSHOW
save_and_quit();
=TEX

\end{enumerate}
If the process fails through delete the child database.
=DUMP pp_make_database
#! /bin/sh
#	pp_make_database   From: $Id: imp111.doc,v 1.27 2004/01/24 12:55:04 rda Exp rda $ %Z%
#
# Shell script to create a ProofPower child database

PROGNAME=`basename $0`
USAGE="$PROGNAME [-f] -p parentdatabase[#parenttheoryname] newdatabase[#cachetheory]"
USAGEMSG="$PROGNAME: usage: $USAGE"
=SH
cat hol_common >>pp_make_database
=DUMPMORE pp_make_database
LOGFILE=/tmp/pp_make_database.log.$$
=TEX
Process arguments
=DUMPMORE pp_make_database
PARENT=""
FORCE=false
VERBOSE=false
COMPACT=${PPCOMPACT:-y}
case $COMPACT in
	y|Y) COMPACT=true ;;
	n|N) COMPACT=false ;;
	*) diag "If set, the environment variable PPCOMPACT must be one of y, Y, n or N"; exit 1;;
esac
if test "$PPCOMPACT" = ""
then
	env_diag "Using PPCOMPACT=$COMPACT"
else
	env_diag "PPCOMPACT set by caller to $PPCOMPACT"
fi
while true
do
	case $1 in
	-p)		PARENT="$2"	; shift ; shift	;;
	-f)		FORCE=true	; shift ;;
	-v)		VERBOSE=true	; shift ;;
	-c)		COMPACT=false	; shift;;
	-*)		diag "Bad flag for $PROGNAME: $1";
			diag $USAGEMSG;
			exit 1 ;;
	*)							  break ;;
	esac
done
=TEX
Test that there is a parent database name
=DUMPMORE pp_make_database
if test "$PARENT" = ""
then
	diag $USAGEMSG
	exit 1
fi
=TEX
Set up PPHOME etc. if necessary
=DUMPMORE pp_make_database
set_pp_home
=TEX
Test that there is a child database name
=DUMPMORE pp_make_database
if test $# -ne 1
then
	diag $USAGEMSG
	exit 1
fi

NEWDB=$1
PDATABASE=`echo $PARENT|sed -e "s/#.*//"`
=TEX

Get directory name and base name for parent database:
=DUMPMORE pp_make_database
if test `basename $PDATABASE` = $PDATABASE
then
	PDDATABASE=""
	PBDATABASE=`basename $PDATABASE`
else
	PDDATABASE=`dirname $PDATABASE`"/"
	PBDATABASE=`basename $PDATABASE`
	PPDATABASEPATH="."
fi

hol_current_theory=`echo $PARENT| grep "#" | sed -e "s/.*#//"`
CDATABASE=`echo $NEWDB|sed -e "s/#.*//"`
=TEX
[PBC] Split child into dirname and basename
=DUMPMORE pp_make_database
if test `basename $CDATABASE` = $CDATABASE
then
	CDDATABASE=""
	CBDATABASE=`basename $CDATABASE`
else
	CDDATABASE=`dirname $CDATABASE`"/"
	CBDATABASE=`basename $CDATABASE`
fi

export hol_current_theory
=TEX
Test for compiler to use

[PBC] Start of move here from (*) to define HEAP_SUFFIX earlier
=POLYDUMPMORE pp_make_database
COMPILER=${PPCOMPILER:-POLYML}
=NJMLDUMPMORE pp_make_database
COMPILER=${PPCOMPILER:-SMLNJ}
=DUMPMORE pp_make_database
if test "$PPCOMPILER" = ""
then
	env_diag "Using PPCOMPILER=$COMPILER"
else
	env_diag "PPCOMPILER set by caller to $PPCOMPILER"
fi
if test "$COMPILER" = POLYML
then
	RUNML="poly $MLFLAGS "
	HEAP_SUFFIX=polydb
elif test "$COMPILER" = SMLNJ
then
	RUNML="sml $MLFLAGS @SMLload="
	eval `.arch-n-opsys`
else
	diag "if set, the environment variable PPCOMPILER must be one of POLYML or SMLNJ" >&2
	exit 1
fi

=TEX

[PBC] Removed check to disallow child database path

[PBC] Removed check to disallow suffix
=DUMPMORE pp_make_database
CBDATABASE=`basename $CBDATABASE .$HEAP_SUFFIX`
CCACHE=`echo $NEWDB| grep "#" | sed -e "s/.*#//"`
if test ""$CCACHE = ""
then	CCACHE="cache'"$CDATABASE
fi
if test ""$CCACHE = ""
then	
	diag "$PROGNAME: No name for new cache theory"
	exit 1
fi
=TEX
Find a parent database:

[PBC] Changed PDATABASE to PBDATABASE on the line below.

[PBC] Added `.' to path

[PBC] DATABASEPATH used instead of PATH

[PBC] Changed PDATABASE to PBDATABASE on rhs of the line below.

[PBC] Changed PDATABASEFN to PDATABASEN on lhs of the line below, since
it is not necessarily the full path.  Want to use PDATABASEN in
`frozen database' message later since PDATABASEN is same form as

[PBC] Added `.' to path

[PBC] DATABASEPATH used instead of PATH

[PBC] Removed leading `./' from filename, and not later

[PBC] Use more precise db name which includes suffix in error message

See also comments on the analogous parts of the pp script.

=DUMPMORE pp_make_database
PBDATABASE=`basename $PBDATABASE .$HEAP_SUFFIX`
PDATABASESN=`findfile $PDDATABASE$PBDATABASE.$HEAP_SUFFIX $PPDATABASEPATH`
PDATABASEN=`findfile -r $PDATABASESN`
if test $? != 0
then
	diag "$PROGNAME: database $PDDATABASE$PBDATABASE.$HEAP_SUFFIX not found"
	exit 1
fi
=TEX
[PBC] Changed PDATABASEFN to PDATABASEN in the test

[PBC] Changed position of first double quote sign for uniformity

[PBC] Put more precise db name

=DUMPMORE pp_make_database
if test ! -r $PDATABASEN
then
	diag "$PROGNAME: $PDATABASEN not readable"
	exit 1
fi
=TEX
Get an absolute pathname

[PBC] CHILDDB now uses path, must be absolute for SML/NJ

[PBC] CHILDDB replaced by CDATABASEN

=DUMPMORE pp_make_database
PWD=`pwd | sed -e 's/\\//\\\\\\//g'`
PDATABASEFN=`echo $PDATABASEN | sed -e "s/^[^/]/$PWD\/&/"`
CDATABASEN=$CDDATABASE$CBDATABASE.$HEAP_SUFFIX
CDATABASEFN=`echo $CDATABASEN | sed -e "s/^[^/]/$PWD\/&/"`
=TEX
=DUMPMORE pp_make_database
if test "$COMPILER" = POLYML
then
	if	test -w $PDATABASEFN
	then
		SAVE_QUIT="save_and_quit()"
		NEWCHILD_SAVE_QUIT="(PolyML.make_database(translate_for_output \"$CDATABASEN\"); save_and_quit())"
	else
		SAVE_QUIT="(diag_line \"\"; diag_line \"Write access is needed for $PDATABASEFN to make its first child\"; exit 1)"
		NEWCHILD_SAVE_QUIT="(diag_line \"\"; diag_line \"Write access is needed for $PDATABASEFN to make its first child\"; exit 1)"
	fi
	QUIT="quit()"
	NEWCHILD_QUIT="(PolyML.make_database(translate_for_output \"$CDATABASEN\"); quit())"
elif test "$COMPILER" = SMLNJ
then
	NEWCHILD_SAVE_QUIT="(PPBuild.pp'save_name := translate_for_output \"$CDATABASEFN\"; save_and_quit())"
	NEWCHILD_QUIT="$NEWCHILD_SAVE_QUIT"
fi
if test -s $CDATABASEN
then 	if test $FORCE != true
	then
		diag "$PROGNAME: $CDATABASEN already exists; use the -f flag to overwrite it"
		exit 1
	fi
fi
=TEX
Delete the child database if anything goes wrong,
always delete the initialisation error file.
From now on must set $exit\_status$ rather than use $exit$ command.
=DUMPMORE pp_make_database
exit_status=1

trap "'rm' -f $LOGFILE; \
	exit \$exit_status" 0
trap "'rm' -f $CHILDDB; 
	'rm' -f $LOGFILE; \
	exit 1" 1 2 3 15
=TEX

[PBC] The value of NEW does not need to be defined when $COMPILER is not POLYML.
 --- result of \verb!test "$COMPILER" = POLYML -a $NEW -ne 0! below would
still be 1 (false).
=DUMPMORE pp_make_database

=TEX
Run the parent session:
=DUMPMORE pp_make_database
if test "$COMPILER" = POLYML
then	$RUNML$PDATABASEFN > /dev/null 2>&1 << ++++
(icl'Kernel.icl'new_hierarchy(); ($QUIT)) handle _ => PPCompiler.exit 1
++++
	NEW=$?
else	NEW=1
fi
if test "$COMPILER" = POLYML -a "$NEW" -ne 0 -a "$COMPACT" = true
then

	if test -r $PDATABASEFN~
	then
		diag "$PROGNAME: temporary file $PDATABASEN~ already exists"
		exit 1
	fi
=TEX
[PBC]
This will fail if the directory containing the parent database
does not have write permissions.
=DUMPMORE pp_make_database
	if cp -f $PDATABASEFN $PDATABASEN~ > /dev/null 2>&1
	then	true
	else
		diag "$PROGNAME: cannot create temporary file $PDATABASEN~"
		exit 1
	fi
	echo "Freezing $PDATABASEN~"
	$RUNML$PDATABASEN~ > $LOGFILE 2>&1 << ++++
if "$hol_current_theory"<>""
then (open_theory "$hol_current_theory"
	handle _ =>
	(diag_string ("cannot open parent theory"^"$hol_current_theory");
	PPCompiler.exit 1))
else ();
(
	open_theory "$CCACHE";
	diag_string "New cache theory exists in parent database";
	PPCompiler.exit 0
)
handle _ => ();
((icl'Kernel.icl'freeze_hierarchy())
handle (Fail _) => 
(diag_string "pp_make_database: Need to freeze parent database hierarchy, but cannot";
PPCompiler.exit 1));
($SAVE_QUIT);
++++
	EXIT_STATUS=$?
	if test $EXIT_STATUS -ne 0
	then
		cat $LOGFILE
		echo
		echo "$PROGNAME: $RUNML$PDATABASEN~ exited with status $EXIT_STATUS"
		exit 1
	fi
	if test "$VERBOSE" = true; then cat $LOGFILE; fi
	echo "Compacting $PDATABASEN~"
	if poly -d -c $PDATABASEN~ > $LOGFILE 2>&1
	then	true
	else
		cat $LOGFILE
		echo
		echo "$PROGNAME: failed to compact $PDATABASEN~"
		exit 1
	fi
	if test "$VERBOSE" = true; then cat $LOGFILE; fi
	echo "Minimizing address space used by $PDATABASEN~"
	poly -d -Smin $PDATABASEN~ > $LOGFILE 2>&1
	if test "$VERBOSE" = true; then cat $LOGFILE; fi
=TEX
At this point, \verb!$PDATABASEN~! is ready to be a parent.  Therefore, even if the next
$RUNML command fails, it does not matter that \verb!$PDATABASEFN! is overwritten.
To subsequent runs of \verb!pp_make_database!, it will behave as if \verb!$PDATABASEFN! already
has a child.
=DUMPMORE pp_make_database
	echo "Setting $PDATABASEN~ to parent database $PDATABASEN"
	if ( cat $PDATABASEN~ >$PDATABASEFN && rm $PDATABASEFN~ ) > $LOGFILE 2>&1
	then	true
	else
		cat $LOGFILE
		echo
		diag "$PROGNAME: failed to replace $PDATABASEFN by $PDATABASEN~"
		exit 1
	fi
	if test "$VERBOSE" = true; then cat $LOGFILE; fi
	echo "Parent database $PDATABASEN now has a frozen theory hierarchy"
=TEX
Now run the ML to make the child:
=DUMPMORE pp_make_database
	$RUNML$PDATABASEFN > $LOGFILE 2>&1 << ++++
$NEWCHILD_QUIT
++++
	EXIT_STATUS=$?
else	# "$COMPILER" = SMLNJ -o NEW -eq 0 -o "$COMPACT" = false
	$RUNML$PDATABASEFN > $LOGFILE 2>&1 << ++++
=TEX
Now the actual commands to the session:

First a few sanity checks - quoted parent theories must
exist, and the new cache theory name must neither be ``''
nor currently exist.
=DUMPMORE pp_make_database
if "$hol_current_theory"<>""
then (open_theory "$hol_current_theory"
	handle _ =>
	(diag_string ("cannot open parent theory"^"$hol_current_theory");
	PPCompiler.exit 1))
else ();

(
	open_theory "$CCACHE";
	diag_string "New cache theory exists in parent database";
	PPCompiler.exit 0
)
handle _ => ();
=TEX
Since matters are reasonably sane, carry on with the desired
commands.
We only need to save the database if we need to freeze the
hierarchy.
=DUMPMORE pp_make_database
if
((icl'Kernel.icl'new_hierarchy() ; false)
handle (Fail _) =>
((icl'Kernel.icl'freeze_hierarchy(); true)
handle (Fail _) => 
(diag_string "pp_make_database: Need to freeze parent dababase hierarchy, but cannot";
PPCompiler.exit 1; false)))
then ($NEWCHILD_SAVE_QUIT)
else  ($NEWCHILD_QUIT);
++++
=TEX
That ends commands to make the child database; Now check that we got a child database:

[PBC] CHILDDB replaced by CDATABASEN
=DUMPMORE pp_make_database
	EXIT_STATUS=$?
	if test $VERBOSE = true -o ! -r $CDATABASEN -o $EXIT_STATUS -ne 0
	then
		cat $LOGFILE
	fi
	if test	$EXIT_STATUS -ne 0
	then	diag "$PROGNAME: $RUNML$PDATABASEFN exited with status $EXIT_STATUS"
		exit 1
	fi
	if test -r $CDATABASEN
	then
		echo "$PROGNAME: parent database $PDATABASEN now has a frozen theory hierarchy" >&2
	fi
fi

if test $VERBOSE = true -o ! -r $CDATABASEN -o $EXIT_STATUS -ne 0
then
	cat $LOGFILE
fi
if test $EXIT_STATUS -ne 0
then
	echo
	diag "$PROGNAME: $RUNML$PDATABASEFN exited with status $EXIT_STATUS"
	exit 1
fi
if test -r $CDATABASEN
then	true
else
	echo
	diag "$PROGNAME: unable to create child database"
	exit_status=1
	exit 1
fi
=TEX
Now run the child database:
=DUMPMORE pp_make_database
	$RUNML$CDATABASEN > $LOGFILE 2>&1 << ++++
	abandon_reader_writer() handle _ => ();
	use_terminal();
	PrettyPrinter.pp_init();
	BasicError.icl'error_init();
	Initialisation.init();
	val icl'theory_hierarchy = Value (icl'Kernel.icl'new_hierarchy ());
	icl'Kernel.icl'load_hierarchy (force_value icl'theory_hierarchy);
	new_theory "$CCACHE";
	set_cache_theories ("$CCACHE" :: get_cache_theories());
	save_and_quit();
++++
EXIT_STATUS=$?
=TEX
Check that there were no initialisation errors:
=DUMPMORE pp_make_database
if test "$VERBOSE" = true -o $EXIT_STATUS -ne 0
then
	cat $LOGFILE
	echo
fi
if test $EXIT_STATUS -ne 0
then
	diag "$PROGNAME: error creating child database"
	exit_status=1
	exit 1
fi
=TEX
Clean exit:
=DUMPMORE pp_make_database
diag "$PROGNAME: child database $CDATABASEN created and initialised"
if test "$COMPILER" = POLYML -a "$COMPACT"  = true
then
	echo "$PROGNAME: maximizing address space available to child database $CDATABASEN"
	poly -d -Smax $CDATABASEN > $LOGFILE 2>&1
fi
if test "$VERBOSE" = true; then cat $LOGFILE; fi
exit_status=0
=TEX
Now make this executable
=SH
chmod +x pp_make_database
=TEX
\section{THEORY LISTINGS}
\subsection{Program {\tt hol\_list}}
At v0.8.2 and later this is just an alias of $pp\_list$.

=DUMP hol_list
#! /bin/sh
#	hol_list   From: $Id: imp111.doc,v 1.27 2004/01/24 12:55:04 rda Exp rda $ %Z%
# Shell script to list HOL theories - obsolete, use pp_list instead.
pp_list $*
=TEX
\subsection{Program {\tt zed\_list}}
At v0.8.2 and later this is just an alias of $pp\_list$.
=DUMP zed_list
#! /bin/sh
#	zed_list   From: $Id: imp111.doc,v 1.27 2004/01/24 12:55:04 rda Exp rda $ %Z%
#
# Shell script to list Z theories - obsolete, use pp_list instead.
pp_list $*
=TEX
\subsection{Program {\tt pp\_list}}
=DUMP pp_list
#! /bin/sh
#	pp_list   From: $Id: imp111.doc,v 1.27 2004/01/24 12:55:04 rda Exp rda $ %Z%
#
# Shell script to list ProofPower theories
PROGNAME=`basename $0`
USAGE="$PROGNAME [-c] -d database[#theory] [-i script] [-l lang] [-v] [-a | theory ...]"
USAGEMSG="$PROGNAME: usage: $USAGE"
=SH
cat hol_common >>pp_list
=DUMPMORE pp_list
=TEX
Process arguments
=DUMPMORE pp_list

hol_initialisation_scripts=""
DBN=""
ALL=1
print_caches="no"
languages=""
verbose="no"
while true
do
	case $1 in
	-a)	ALL=0 ; shift ;;
	-c)	print_caches="yes" ; shift ;;
	-d)	DBN="$2" ; shift ; shift ;;
	-i)	hol_initialisation_scripts="$hol_initialisation_scripts,$2"	; shift ; shift	;;
	-l)	languages="$languages$2," ; shift ; shift ;;
	-v)	verbose="yes"; shift ;;
	-*)	diag "Bad flag for $PROGNAME: $1" ;
		diag $USAGEMSG;
		exit 1 ;;
	*)							  break ;;
	esac
done
if test "x$DBN" = "x"
then
	diag $USAGEMSG
	exit 1
fi
export languages
=TEX
Make sure that, if necessary, the arguments have been used up:
=DUMPMORE pp_list
if test $ALL -eq 0
then
	if test $# -ne 0
	then
		diag $USAGEMSG
		exit 1
	fi
fi
=TEX
Set up PPHOME etc. if necessary:
=DUMPMORE pp_list
set_pp_home
=TEX
Get the list of files to print:
=DUMPMORE pp_list
if test $ALL -eq 0
then
	print_theories=""
elif test $# -eq 0
then print_theories="just names,"
else print_theories=""
fi
while test $# -ne 0
do
	print_theories=$print_theories","$1 ; shift
done
export print_theories
=TEX
Allow $poly$ to work out whether we want to print caches:
=DUMPMORE pp_list
export print_caches
=TEX
From now on must set $exit\_status$ rather than use $exit$ command.
=DUMPMORE pp_list
exit_status=1
=TEX
Run the session:
=DUMPMORE pp_list
TEMP_FILE=/tmp/`basename $0`.$$
if test "$hol_initialisation_scripts" != ""
then
	MINUSI="-i"
else
	MINUSI=
fi
pp -d $DBN $MINUSI $hol_initialisation_scripts > $TEMP_FILE 2>/dev/null << smlcommands3
=TEX
The commands below set up printing for caches;
setup printers for the various possible languages;
=DUMPMORE pp_list
local
open ListerSupport;
val {print = bprint_cache, out = boutput_cache, out1 = boutput_cache1} =
	gen_theory_lister
	[LSBanner, LSParents, LSChildren, 
	LSADSection (fn nm => "Notes"),
	LSADString(fn nm => ([],"This theory is a cache theory; its contents have not been listed.")),
	LSTrailer];
val print_cache = bprint_cache (fn nm => get_error_message 33031 [nm]);
val output_cache1 = boutput_cache1 (fn nm => get_error_message 33031 [nm]);
in
val output_cache = boutput_cache (fn nm => get_error_message 33031 [nm]);
end;
local
	val ordA = ord "A";
	val ordZ = ord "Z";
	val orda = ord "a";
	val change = orda-ordA;
fun lcase c = (
	if ord c >= ordA andalso ord c <= ordZ
	then chr (ord c + change)
	else c
);
in
val word_lcase = implode o map lcase o explode;
end;

local

val languages_source = get_shell_var "languages";
fun mk_languages acc [] = [implode (rev acc)]
| mk_languages acc [","] = [implode(rev acc)]
| mk_languages acc ("," :: x) = (implode(rev acc) :: mk_languages [] x)
| mk_languages acc (a :: x) = mk_languages (a :: acc) x;
in
val languages = if languages_source = ""
		then []
		else mk_languages [] (explode languages_source);

val language_procs = (("HOL","output_theory") :: 
	map (fn lang =>
	(use_string(word_lcase lang ^ "_output_theory;"); (lang,word_lcase lang ^ "_output_theory"))
	handle _ =>
	(lang,"output_theory"))
	(((map get_language (get_descendants "min")) cup languages) less "HOL"));
end;
let
val print_caches = get_shell_var "print_caches";
val caches = get_cache_theories();

fun output_lang_theory lang {theory = thnm, out_file = out_file} = (
	(use_string( lassoc3 language_procs lang ^  
		"{theory = \""^thnm^"\", out_file = \""^out_file^"\"};"))
);

fun output_a_theory thnm lang = (
	open_theory thnm
	handle _ => open_theory (#theory icl'database_info);
	(if print_caches = "yes" orelse not(thnm mem caches)
	then
		output_lang_theory lang {theory = thnm, out_file = ""}
	else
		output_cache {theory = thnm, out_file = ""}
	)
	handle complaint => (diag_line "";
	pass_on complaint "output_theory" "pp_list")
);

val single_language = (case languages of
	[] => Nil
	| _ => Value(hd languages));

val output_a_theory1 = (
	case single_language of
	Nil => (fn thnm => output_a_theory thnm (get_language thnm))
	| Value sl => (fn thnm => output_a_theory thnm sl)
);

val output_a_theory2 = (fn thnm => output_a_theory thnm (get_language thnm));

fun aux acc [] = (if is_nil acc
		then ()
		else (output_a_theory1 (implode(rev acc)))
) | aux acc ("," :: rest) = ((if is_nil acc
		then ()
		else (output_a_theory1 (implode(rev acc))));
			aux [] rest
)| aux acc (a :: x) = aux (a :: acc) x;

val do_theories = (Sort.sort Sort.string_order 
	(
	if languages = []
	then (get_descendants "min")
	else filter (fn nm => (get_language nm) mem languages)
	(get_descendants "min")
	)
);

val print_theories = get_shell_var "print_theories";
in
(diag_line "START_OF_LISTING"; 
(case print_theories of
	"" => (map output_a_theory2 do_theories; ())
	| "just names," =>
		(map diag_line do_theories; ()) 
	| _ => aux [] (explode print_theories));
diag_line "END_OF_LISTING")
end ; 
quit();
=TEX
After the commands - only output listing material:
=DUMPMORE pp_list
smlcommands3
=TEX
Check that the program exited with status 0:
=DUMPMORE pp_list
EXIT_STATUS=$?
if test $EXIT_STATUS -ne 0
then
	cat $TEMP_FILE
	diag "$PROGNAME: \"pp -d $DBN\" exited with status $EXIT_STATUS"
	exit_status=1
	exit 1
fi
=TEX
Otherwise print the relevant parts out:
=DUMPMORE pp_list
if grep START_OF_LISTING $TEMP_FILE > /dev/null
then if grep END_OF_LISTING $TEMP_FILE > /dev/null
then
	if test $verbose = "yes"
	then
		cat $TEMP_FILE >&2
	else
		sed -e '1,/START_OF_LISTING/ d' \
		-e '/END_OF_LISTING/,$ d' \
		-e '/val it = () : unit/d' < $TEMP_FILE
	fi
else
	cat $TEMP_FILE >&2
	echo >&2
	diag "$PROGNAME: exited with ill-formed listing"
	exit_status=1
	exit 1
fi
else
	cat $TEMP_FILE >&2
	echo >&2
	diag "$PROGNAME: exited with ill-formed listing"
	exit_status=1
	exit 1
fi

=TEX
Clean exit:
=DUMPMORE pp_list
exit_status=0
=TEX
Now make the scripts executable
=SH
chmod +x pp_list hol_list zed_list
=TEX


\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
