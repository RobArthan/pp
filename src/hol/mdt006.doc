=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for the Abstract Data Type $THM$}  %% Mandatory field
\def\TPPheadtitle{Module Tests for the Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/MDT006}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the 
the abstract data type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue 1.1]
First draft version.
\item [Issue 1.2]
Corrected typos, slight improvement to layout.
\item [Issue 1.3]
Changed to match issue 1.9 of \cite{DS/FMU/IED/DTD006}.
\item [Issue 1.4]
Testing corrections made to implementation.
\item [Issue 1.5]
Now reloads ``imp006.sml'' to start off from an empty ``min'' theory.
\item [Issue 1.6,1.7]
Changed to match issue 1.11 of \cite{DS/FMU/IED/DTD006}.
\item [Issue 1.8]
Changed a $list\_mk\_„$ to $list\_simple\_mk\_„$.
\item [Issue 1.8]
Changed a $mk\_„$ to $simple\_mk\_„$.
\item [Issue 1.9]
Added a test for $icl'simple\_list\_ƒ\_elim$ with duplicate quantifiers.
\item [Issue 1.10]
The prefix $simple$ is moved to being the first prefix, bar $icl'$.
Changed to match issue 1.12 of \cite{DS/FMU/IED/DTD006}.
\item [Issue 1.11]
Clears out theory hierarchy, rather than reloading imp006.
\item [Issue 1.12,1.13]
Deals with some glitches.
\item [Issue 1.14]
Initial use of material from \cite{DS/FMU/IED/DTD013}.
\end{description}
\subsection{Changes forecast}
Many.
Use of DJK test harness work.
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the the Abstract Data Type $THM$, required by Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The design is in \cite{DS/FMU/IED/DTD006}
and it is
implemented in \cite{DS/FMU/IED/IMP006}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD006},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD006},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP006}.
\subsubsection{Deficiencies}
The coverage of the tests, as called for by the test specification, may currently be incomplete.
\section{UTILITIES}
=SML
PolyML.print_depth 10;
=TEX
Initialise the test package:
=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results();
=TEX
We want to test in the context of empty theories,
and at least the icl'Kernel so:
=SML
open icl'Kernel;
icl'open_theory "min";

fun âtheory_namesá ((): unit) : string list = (
let	val hier = icl'get_hierarchy();
in
	map fst (hier drop 
		(fn (_,{status = status,...}) => status = TSDeleted))
end);

map (fn x => icl'delete_theory x 
	handle (Fail _) => ()) (theory_names());
map (fn x => icl'delete_theory x 
	handle (Fail _) => ()) (theory_names());
fun delete_all () = (
	(icl'delete_extension ();
	delete_all ())
	handle (Fail _) => ());

delete_all ();
=TEX
We provide a list of diagnostic printing functions. 
Those called $string\_of\_\ldots$ turn objects of various significant types ($TERM$, $THM$, etc)
into strings,
those called $print\_\ldots$ apply $diag\_string$ to the output
of the associated $string\_of\_\ldots$.
=SML
fun âstring_of_typeá (t: TYPE) : string = (
let
	fun aux ty = (
	if is_vartype ty then 
		(" " ^ dest_vartype ty)
	else if is_funtype ty then
		(let val(t1,t2) = dest_funtype ty
		in
		( "(" ^ aux t1 ^ " ‹" ^ aux t2 ^")" )
		end)
	else (let 
		fun aux1 ("‰",[t1,t2]) = (
		"(" ^ aux t1 ^ " ‰" ^ aux t2 ^")"
		) | aux1 ((s,[])) = (
		" " ^ s
		) | aux1 ((s,tyl)) = (
		"((" ^ implode (map ((fn x => x ^", ") o aux) tyl)^ ")" ^ s ^ ")")
		in
			aux1 (dest_type ty)
		end)
	)
in
	(":" ^ aux t)
end);
val âprint_typeá = diag_line o string_of_type;

local
	fun simple_print_dest_term (Comb(t1,t2)) = (
	"Comb (" ^ simple_print_dest_term(simple_dest_term t1) ^", " ^
		simple_print_dest_term(simple_dest_term t2) ^ ")"
) | simple_print_dest_term (Const(s,ty)) = s ^ string_of_type ty
| simple_print_dest_term (Var(s,ty)) = s ^ string_of_type ty
| simple_print_dest_term (Abs(v,b)) = (
	let val (vs,vt) = dest_var v
	in
	" " ^ vs ^ string_of_type vt ^ " Ž " ^ simple_print_dest_term (simple_dest_term b)
	end);
in

fun âstring_of_termá (tm : TERM) = simple_print_dest_term (simple_dest_term tm);

fun âprint_termá (tm: TERM) = diag_line(string_of_term tm);
end;
=TEX
We also provide a pair of functions on $TERM$ that don't give the type information.
=SML
local fun simple_print_dest_term (Comb(t1,t2)) = (
	"(" ^ simple_print_dest_term(simple_dest_term t1) ^ " " ^
		simple_print_dest_term(simple_dest_term t2) ^ ")"
) | simple_print_dest_term (Const(s,ty)) = s
| simple_print_dest_term (Var(s,ty)) = s
| simple_print_dest_term (Abs(v,b)) = (
	let val (vs,vt) = dest_var v
	in
	"( " ^ vs ^ " Ž " ^ simple_print_dest_term (simple_dest_term b) ^")"
	end);
in
	fun âstring_of_term1á (tm: TERM): string = (
		simple_print_dest_term (simple_dest_term tm)
	);

	fun âprint_term1á (tm: TERM): unit = diag_line(string_of_term1 tm);

	fun âstring_of_seqá ((tml , tm): SEQ) : string = (
		format_list string_of_term1 tml ", " ^
		"… " ^ string_of_term1 tm
	);

	fun âprint_seqá (seq: SEQ) : unit = diag_line(string_of_seq seq);
end;

fun âstring_of_thmá (key:string) (them : THM) : string = (
let val {level=level,theory={name=iname,...},sequent=sequent} =
		icl'dest_thm them
	in
		"In theory "^ string_of_int iname ^ 
		", at level "^ string_of_int level ^ 
		", with key "^ key ^
		"\n" ^
		string_of_seq sequent
end);

fun âprint_thmá (key:string) (them : THM) : unit = diag_line(string_of_thm key them);

fun âstring_of_thyá ({name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} : THEORY) : string = (
	"Internal name " ^ string_of_int iname ^
	", Current Level " ^ string_of_int current_level^
	", Parents " ^ format_list string_of_int parents ", " ^
	"\n***Types***\n" ^
	implode (map (fn (nm,{arity=arity,level=level}) =>
		("     " ^ nm ^ 
		": arity="^string_of_int arity ^
		", level="^string_of_int level ^ "\n"))
		ty_env) ^
	"***Constants***\n" ^
	implode (map (fn (nm,{ty=ty,level=level}) =>
		("     " ^ nm ^ 
		": ty="^string_of_type ty ^
		", level="^string_of_int level ^ "\n"))
		con_env) ^
	(format_list (Combinators.I)
	(["***Theorems***"] @
	(map (uncurry string_of_thm) thm_dict) @
	["***Definitions***"] @
	(map (uncurry string_of_thm) defn_dict) @
	["***Axioms***"] @
	(map (uncurry string_of_thm) axiom_dict)) "\n")
);

fun âprint_thyá (thy  : THEORY) : unit = diag_line(string_of_thy thy);

fun âstring_of_tiá ({status : THEORY_STATUS,
	inscope : bool,
	contents : THEORY,
	children : int list,
	name : string}:THEORY_INFO) : string = (
	"Theory " ^ name ^ "\n" ^
	(if inscope then "In Scope, " else "Out of Scope, ") ^
	(case status of
	TSNormal => "Status: Normal, "
	| TSDeleted => "Status: Deleted, "
	| TSLocked => "Status: Locked, "
	| TSAncestor => "Status: Ancestor, ") ^
	"Children:" ^ (format_list string_of_int children ", ") ^ "\n" ^

	string_of_thy contents
);

fun âprint_tiá (ti : THEORY_INFO) : unit = diag_line(string_of_ti ti);

fun âstring_of_hierarchyá (():unit) : string = (
	implode(map (fn (p,q) => ("------ti key: "^p^"------\n" ^
		string_of_ti q ^ "\n"))
	(icl'get_hierarchy ())));

fun âprint_hierarchyá (():unit) : unit = diag_line(string_of_hierarchy ());

=TEX
\section{THE TESTS}
=TEX
Our initial hierarchy of (empty) theories.
All theories bar ``min'' should have status $Deleted$, and ``min'' should be
 empty.
=SML
print_hierarchy ();
=TEX
=SML
val next_index = icl'new_theory "next";
store_mt_results mt_run [("icl'new_theory 1",
	icl'new_theory,
	"another",
	next_index+1)];
store_mt_results mt_run [("icl'open_theory 1 a",
	icl'open_theory,
	"next",
	([next_index],[]))];
store_mt_results mt_run [("icl'new_theory a",
	icl'new_theory,
	"yet_again",
	next_index+2)];
store_mt_results mt_run_fail [("icl'new_theory 6040",
	icl'new_theory,
	"yet_again",
	gen_fail_msg "icl'new_theory" 6040 ["yet_again"])];
store_mt_results mt_run_fail [("icl'open_theory 6035 a",
	icl'open_theory,
	"rubbish",
	gen_fail_msg "icl'open_theory" 6035 ["rubbish"])];

print_hierarchy ();
=TEX
=SML
store_mt_results mt_run [("icl'new_type 1",
	icl'new_type,
	("BOOL",0),
	mk_type("BOOL",[]))];

val v1 = mk_var("v1", BOOL);
val v2 = mk_var("v2", BOOL);
store_mt_results mt_run [("icl'get_theory_name 1",
	icl'get_theory_name,
	next_index,
	"next")];
store_mt_results mt_run_fail [("icl'get_theory_name 6043 a",
	icl'get_theory_name,
	100,
	gen_fail_msg "icl'get_theory_name" 6043 ["100"]),
	("icl'get_theory_name 6043 b",
	icl'get_theory_name,
	~1,
	gen_fail_msg "icl'get_theory_name" 6043 ["-1"])];

print_ti(icl'get_theory_info "next");
store_mt_results mt_run_fail [("icl'get_theory_info 6035 a",
	icl'get_theory_info,
	"rubbish",
	gen_fail_msg "icl'get_theory_info" 6035 ["rubbish"])];

store_mt_results mt_run [("icl'new_type 2",
	icl'new_type,
	("†",0),
	mk_type("†",[]))];
store_mt_results mt_run_fail [("icl'new_type 6045",
	icl'new_type,
	("†",0),
	gen_fail_msg "icl'new_type" 6045 ["†"])];

print_ti(icl'get_theory_info "next");

val n1 = icl'list_save_thm(["n1"], icl'asm_rule v1);
store_mt_results mt_run_fail [("icl'list_save_thm 6039",
	icl'list_save_thm,
	(["n1"], icl'asm_rule v1),
	gen_fail_msg "icl'list_save_thm" 6039 ["n1","next"]),
	("icl'list_save_thm 6031",
	icl'list_save_thm,
	([], icl'asm_rule v1),
	gen_fail_msg "icl'list_save_thm" 6031 []),
	("icl'list_save_thm 6038 a",
	icl'list_save_thm,
	(["n2"], icl'refl_conv (mk_var("rv",mk_type("rubbish",[])))),
	gen_fail_msg "icl'list_save_thm" 6038 [])
	];

store_mt_results mt_run [("icl'open_theory 2 a",
	icl'open_theory,
	"another",
	([next_index+1],[next_index])),
	("icl'open_theory 2 b",
	icl'open_theory,
	"another",
	([],[]))];
store_mt_results mt_run_fail [("icl'list_save_thm 6038 b",
	icl'list_save_thm,
	(["n2"], icl'asm_rule v1),
	gen_fail_msg "icl'list_save_thm" 6038 [])
	];
store_mt_results mt_run [("icl'open_theory 1 b",
	icl'open_theory,
	"next",
	([next_index],[next_index+1]))];
store_mt_results mt_run [("icl'new_type 3",
	icl'new_type,
	("‰",2),
	mk_type("‰",[mk_vartype "'1",mk_vartype "'2"])),
	("icl'new_type 4",
	icl'new_type,
	("‹",2),
	mk_type("‹",[mk_vartype "'1",mk_vartype "'2"]))];
val N0 = mk_† 0;
val N1 = mk_† 1;
val N2 = mk_† 2;
val T = icl'new_const("T",BOOL);
val F = icl'new_const("F",BOOL);
store_mt_results mt_run [("icl'new_const",
	icl'new_const,
	("Test",BOOL),
	mk_const("Test",BOOL))];
store_mt_results mt_run_fail [("icl'new_const 6075",
	icl'new_const,
	("TypeWrong",mk_type("TYPEWRONG",[])),
	gen_fail_msg "icl'new_const" 6075 ["next"])];

print_ti(icl'get_theory_info "next");
store_mt_results mt_run [("icl'open_theory 3 a",
	icl'open_theory,
	"min",
	([],[next_index]))];

store_mt_results mt_run_fail [("icl'new_type 6034",
	icl'new_type,
	("‰",2),
	gen_fail_msg "icl'new_type" 6034 ["‰"]),
	("icl'new_type 6088",
	icl'new_type,
	("rubbish",~1),
	gen_fail_msg "icl'new_type" 6088 [])];
val UNIT = icl'new_type ("UNIT",0);
val Unit = icl'new_const("Unit",UNIT);
print_ti(icl'get_theory_info "min");
store_mt_results mt_run [("icl'open_theory 1 c",
	icl'open_theory,
	"next",
	([next_index],[]))];
val AlsoUnit = icl'new_const("AlsoUnit",UNIT);
store_mt_results mt_run [("icl'open_theory 3 b",
	icl'open_theory,
	"min",
	([],[next_index]))];
store_mt_results mt_run_fail [("icl'new_const 6063",
	icl'new_const,
	("AlsoUnit",UNIT),
	gen_fail_msg "icl'new_const" 6063 ["AlsoUnit"])];
store_mt_results mt_run_fail [("icl'new_defn 6063",
	icl'new_defn,
	(["AlsoUnit"],"AlsoUnit", Unit),
	gen_fail_msg "icl'new_defn" 6063 ["AlsoUnit"])];
store_mt_results mt_run [("icl'open_theory 4 a",
	icl'open_theory,
	"yet_again",
	([next_index,next_index+2],[]))];
store_mt_results mt_run [("icl'open_theory 2 c",
	icl'open_theory,
	"another",
	([next_index+1],[next_index,next_index+2]))];
store_mt_results mt_run [("icl'new_type 5",
	icl'new_type,
	("BOOL",0),
	mk_type("BOOL",[]))];
val T = icl'new_const("T",BOOL);
val F = icl'new_const("F",BOOL);

print_ti(icl'get_theory_info "another");
store_mt_results mt_run [("icl'delete_extension 1",
	icl'delete_extension,
	(),
	3)];
print_ti(icl'get_theory_info "-");
val s1 = icl'list_save_thm(["s1"], icl'asm_rule v1);
store_mt_results mt_run_fail [("icl'delete_extension 6077",
	icl'delete_extension,
	(),
	gen_fail_msg "icl'delete_extension" 6077 ["another","s1"])];
store_mt_results mt_run [("icl'delete_thm 1",
	dest_thm o icl'delete_thm,
	"s1",
	([v1],v1))];
store_mt_results mt_run [("icl'delete_extension 2",
	icl'delete_extension,
	(),
	2)];
val TorF = icl'new_const("TorF",BOOL);
print_ti(icl'get_theory_info "-");
store_mt_results mt_run [("icl'delete_extension 3",
	icl'delete_extension,
	(),
	6),
	("icl'delete_extension 4",
	icl'delete_extension,
	(),
	1)];
store_mt_results mt_run_fail [("icl'delete_extension 6050",
	icl'delete_extension,
	(),
	gen_fail_msg "icl'delete_extension" 6050 ["another"])];
store_mt_results mt_run [("icl'open_theory 4 b",
	icl'open_theory,
	"yet_again",
	([next_index,next_index+2],[next_index+1]))];
store_mt_results mt_run [("icl'new_axiom 1",
	dest_thm o icl'new_axiom,
	(["truth_axiom"],T),
	([],T)),
	("icl'new_axiom 2",
	dest_thm o icl'new_axiom,
	(["not so", "No way!"],F),
	([],F)),
	("icl'new_axiom 3",
	dest_thm o icl'new_axiom,
	(["testing"],mk_comb(mk_var("f",mk_fun(BOOL,BOOL)), T)),
	([],mk_comb(mk_var("f",mk_fun(BOOL,BOOL)), T)))
	];
store_mt_results mt_run_fail [("icl'new_axiom 6047",
	icl'new_axiom,
	(["truth_axiom"],T),
	gen_fail_msg "icl'new_axiom" 6047 ["truth_axiom","yet_again"]),
	("icl'new_axiom 6048",
	icl'new_axiom,
	(["type_wrong_axiom"],mk_eq(mk_var("v",mk_type("V",[])), 
		mk_var("v",mk_type("V",[])))),
	gen_fail_msg "icl'new_axiom" 6048 ["yet_again"]),
	("icl'new_axiom 6031",
	icl'new_axiom,
	([],T),
	gen_fail_msg "icl'new_axiom" 6031 []),
	("icl'new_axiom 6009",
	icl'new_axiom,
	(["Not Bool"],N0),
	gen_fail_msg "icl'new_axiom" 6009 [])];
store_mt_results mt_run [("icl'open_theory 2 d",
	icl'open_theory,
	"another",
	([next_index+1],[next_index, next_index+2]))];
store_mt_results mt_run_fail [("icl'new_axiom 6048",
	icl'new_axiom,
	(["truth_axiom"],T),
	gen_fail_msg "icl'new_axiom" 6048 ["another"])];
store_mt_results mt_run [("icl'open_theory 4 c",
	icl'open_theory,
	"yet_again",
	([next_index,next_index+2],[next_index+1]))];
store_mt_results mt_run [("icl'list_save_thm 1",
	dest_thm o icl'list_save_thm,
	(["tbd"],icl'asm_rule T),
	([T],T))];

icl'lock_theory "yet_again";
print_ti(icl'get_theory_info "yet_again");
store_mt_results mt_run_fail [("icl'lock_theory 1",
	icl'new_axiom,
	(["Truth_axiom"],T),
	gen_fail_msg "icl'new_axiom" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 2",
	icl'list_save_thm,
	(["Example"],icl'asm_rule v1),
	gen_fail_msg "icl'list_save_thm" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 3",
	icl'new_const,
	("ForT",BOOL),
	gen_fail_msg "icl'new_const" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 4",
	icl'new_type,
	("SOMETHING",3),
	gen_fail_msg "icl'new_type" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 5",
	icl'delete_extension,
	(),
	gen_fail_msg "icl'delete_extension" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 6",
	icl'delete_thm,
	"tba",
	gen_fail_msg "icl'delete_thm" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 7",
	icl'new_defn,
	(["SomeWhere"],"SomeWhere",F),
	gen_fail_msg "icl'new_defn" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 8",
	icl'new_type_defn,
	( [ "TestType"], "TestType", ["'2"], icl'asm_rule T),
	gen_fail_msg "icl'new_type_defn" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 9",
	icl'new_specification,
	( [ "TestSpec"], 1, icl'asm_rule T),
	gen_fail_msg "icl'new_specification" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 10",
	icl'new_parent,
	"another",
	gen_fail_msg "icl'new_parent" 6037 ["yet_again"])];
store_mt_results mt_run [("icl'lock_theory 11",
	get_current_theory_status,
	(),
	TSLocked)];

icl'unlock_theory "yet_again";
=TEX
=SML
store_mt_results mt_run [("icl'unlock_theory 11",
	get_current_theory_status,
	(),
	TSNormal)];
store_mt_results mt_run [("icl'open_theory 3 c",
	icl'open_theory,
	"min",
	([],[next_index, next_index+2]))];
store_mt_results mt_run_fail [("icl'delete_extension 6076",
	icl'delete_extension,
	(),
	gen_fail_msg "icl'delete_extension" 6076 ["min"])];
store_mt_results mt_run [("icl'open_theory 1 d",
	icl'open_theory,
	"next",
	([next_index],[]))];
val tdb_index = icl'new_theory "to_be_deleted";
store_mt_results mt_run [("icl'open_theory 5",
	icl'open_theory,
	"to_be_deleted",
	([tdb_index],[]))];
val thy_deleted_thm = icl'list_save_thm(["thy_deleted_thm"],
	icl'asm_rule v1);
store_mt_results mt_run [("icl'open_theory 1 e",
	icl'open_theory,
	"next",
	([],[tdb_index]))];
icl'delete_theory "to_be_deleted";
print_hierarchy();
store_mt_results mt_run_fail [("icl'get_theory_info 6035 b",
	icl'get_theory_info,
	"to_be_deleted",
	gen_fail_msg "icl'get_theory_info" 6035 ["to_be_deleted"])];
store_mt_results mt_run_fail [("icl'get_theory_name 6089",
	icl'get_theory_name,
	tdb_index,
	gen_fail_msg "icl'get_theory_name" 6089 [string_of_int tdb_index])];

store_mt_results mt_run_fail [("icl'open_theory 6035 b",
	icl'open_theory,
	"to_be_deleted",
	gen_fail_msg "icl'open_theory" 6035 ["to_be_deleted"])];
store_mt_results mt_run_fail [("icl'delete_theory 6035 b",
	icl'delete_theory,
	"to_be_deleted",
	gen_fail_msg "icl'delete_theory" 6035 ["to_be_deleted"])];
store_mt_results mt_run_fail [("icl'lock_theory 6035 a",
	icl'lock_theory,
	"to_be_deleted",
	gen_fail_msg "icl'lock_theory" 6035 ["to_be_deleted"]),
	("icl'lock_theory 6035 b",
	icl'lock_theory,
	"rubbish",
	gen_fail_msg "icl'lock_theory" 6035 ["rubbish"])];
store_mt_results mt_run [("icl'new_theory 3",
	icl'new_theory,
	"to_be_deleted",
	tdb_index+1)];
icl'delete_theory "to_be_deleted"; 
store_mt_results mt_run_fail [("icl'delete_theory 6076",
	icl'delete_theory,
	"min",
	gen_fail_msg "icl'delete_theory" 6076 ["min"])];

icl'lock_theory "yet_again";
store_mt_results mt_run_fail [("icl'lock_theory 12",
	icl'delete_theory,
	"yet_again",
	gen_fail_msg "icl'delete_theory" 6037 ["yet_again"])];
icl'unlock_theory "yet_again";
store_mt_results mt_run [("icl'open_theory 4 d",
	icl'open_theory,
	"yet_again",
	([next_index+2],[]))];
store_mt_results mt_run_fail [("icl'delete_theory 6069",
	icl'delete_theory,
	"yet_again",
	gen_fail_msg "icl'delete_theory" 6069 ["yet_again"])];
store_mt_results mt_run_fail [("icl'unlock_theory 6035 a",
	icl'unlock_theory,
	"to_be_deleted",
	gen_fail_msg "icl'unlock_theory" 6035 ["to_be_deleted"]),
	("icl'lock_theory 6035 b",
	icl'unlock_theory,
	"rubbish",
	gen_fail_msg "icl'unlock_theory" 6035 ["rubbish"]),
	("icl'lock_theory 6068",
	icl'unlock_theory,
	"yet_again",
	gen_fail_msg "icl'unlock_theory" 6068 ["yet_again"])];

print_ti(icl'get_theory_info "next");
icl'duplicate_theory "next" "copy_of_next";
print_ti(icl'get_theory_info "copy_of_next");

store_mt_results mt_run_fail [("icl'duplicate_theory 6040",
	icl'duplicate_theory "rubbish",
	"copy_of_next",
	gen_fail_msg "icl'duplicate_theory" 6040 ["copy_of_next"]),
	("icl'duplicate_theory 6035 a",
	icl'duplicate_theory "rubbish",
	"copy_of_rubbish",
	gen_fail_msg "icl'duplicate_theory" 6035 ["rubbish"]),
	("icl'duplicate_theory 6035 b",
	icl'duplicate_theory "to_be_deleted",
	"copy_of_rubbish",
	gen_fail_msg "icl'duplicate_theory" 6035 ["to_be_deleted"])
];
store_mt_results mt_run_fail [("icl'delete_thm 6046",
	icl'delete_thm,
	"rubbish",
	gen_fail_msg "icl'delete_thm" 6046 ["rubbish","yet_again"])];
store_mt_results mt_run_error [("icl'list_save_thm 6036",
	icl'list_save_thm,
	(["s2"], thy_deleted_thm),
	gen_fail_msg "icl'list_save_thm" 6036 ["to_be_deleted",string_of_int tdb_index])];

=TEX
Here, for the time being, we stop protecting failures:
=SML
set_flag("usefile_non_stop_mode",true);
=TEX
Now the rest of the tests:
=SML
icl'new_defn (["True"],"True",T);
icl'new_defn (["True"],"True1",T); (* fails *)
icl'new_defn (["False"],"False",F);
print_ti(icl'get_theory_info "-");
icl'new_defn (["0"],"0",mk_const("0",†)); (* fails *)
val zero_def = icl'new_defn (["ZeRo"],"ZeRo",mk_† 0);
val ZeRo = mk_const("ZeRo",†);
print_ti(icl'get_theory_info "-");
icl'delete_extension ();
print_ti(icl'get_theory_info "-");
icl'new_defn ([],"rubbish",mk_const("F",BOOL));
icl'new_defn (["False"],"False",mk_const("F",BOOL));
icl'new_defn (["Somewhere"],"Somewhere",mk_const("Somehow",BOOL));
icl'new_defn (["Somewhere"],"Somewhere",mk_var("Somehow",BOOL)); (* fails *)
val tv1 = mk_vartype "'1";
val tv2 = mk_vartype "'2";
icl'new_const("Everywhere",tv1);

icl'new_defn (["Somewhere"],"Somewhere",
	mk_comb(
	simple_mk_abs(mk_var("Somehow",tv1),T),
	mk_const("Everywhere",tv1)
		)); (* fails *)
store_mt_results mt_run [("icl'open_theory 1 f",
	icl'open_theory,
	"next",
	([],[next_index+2]))];
icl'new_const("=",mk_fun(tv1, mk_fun(tv1, BOOL)));
icl'new_const("„",mk_fun(mk_fun(tv1,BOOL),BOOL));
icl'new_const("ƒ",mk_fun(mk_fun(tv1,BOOL),BOOL));
icl'new_const("TypeDefn",mk_fun(mk_fun(tv1,BOOL),
	mk_fun(mk_fun(tv2,tv1),BOOL)));
val Tv1Pred = icl'new_const("Tv1Pred",mk_fun(tv1,BOOL));
store_mt_results mt_run [("icl'open_theory 4 e",
	icl'open_theory,
	"yet_again",
	([next_index+2],[]))];

local val x= mk_var("x",tv1)
in
val etype_exax = icl'new_axiom(["etype_exax"],
	simple_mk_„(x,mk_comb(Tv1Pred,x)))
end;
val etype_def = icl'new_type_defn( [ "ETYPE"], "ETYPE", ["'1"], etype_exax);
val etype_def = icl'new_type_defn( [ "ETYPE"], "ETYPE1", ["'1"], etype_exax); (* fails *)
val etype_def = icl'new_type_defn([], "ETYPEd", ["'1"], etype_exax); (* fails *)
print_thm "" etype_def;
print_ti(icl'get_theory_info "-");
local val x= mk_var("x",tv2)
in
val etype2_exax = icl'new_axiom(["etype2_exax"],
	simple_mk_„(x,mk_comb(icl'inst [] [(tv2,"'1")]Tv1Pred,x)))
end;
val etype2_def = icl'new_type_defn( [ "ETYPE2"], "ETYPE2", ["'2"], etype2_exax);
icl'new_type_defn( [ "ETYPE2a"], "ETYPE2a", ["'2"], etype2_exax);
icl'new_type_defn( [ "ETYPE2c"], "ETYPE2c", ["'1"], etype2_exax);
icl'new_type_defn( [ "ETYPE2a"], "ETYPE2b", ["'2"], etype2_exax); (* fails *)
icl'new_type_defn( [ "ETYPE2b"], "ETYPE2b", ["'2"], 
	icl'asm_rule(snd(dest_thm etype2_exax))); (* fails *)
icl'new_type_defn( [ "ETYPE2b"], "ETYPE2b", ["'2"], 
	icl'asm_rule(snd(dest_thm etype2_exax))); (* fails *)
local val x= mk_var("x",tv2);
	val y= mk_var("y",tv2)
in
val etype6_exax = icl'new_axiom(["etype6_exax"],
	simple_mk_„(x,mk_comb(icl'inst [] [(tv2,"'1")]Tv1Pred,y)))
end;
icl'new_type_defn( [ "ETYPE6"], "ETYPE6", ["'2"], etype6_exax); (* fails *)

print_ti(icl'get_theory_info "-");
icl'new_type_defn( [ "rubbish"], "BOOL", [], etype2_exax); (* fails *)
store_mt_results mt_run [("icl'open_theory 3 e",
	icl'open_theory,
	"min",
	([],[next_index, next_index+2]))];
icl'new_type_defn( [ "rubbish"], "BOOL", [], etype2_exax); (* fails *)
store_mt_results mt_run [("icl'open_theory 4 f",
	icl'open_theory,
	"yet_again",
	([next_index,next_index+2],[]))];
icl'new_type_defn( [ "rubbish"], "rubbish", [], thy_deleted_thm); (* fails *)

local val x= mk_var("x",tv2)
in
val etype3_exax = icl'new_axiom(["etype3_exax"],
	simple_mk_ƒ(x,mk_comb(icl'inst [] [(tv2,"'1")]Tv1Pred,x)))
end;
val etype3_def = icl'new_type_defn( [ "ETYPE3"], "ETYPE3", ["'2"], etype3_exax); (* fails *)
local val x= mk_var("x",tv1);
	val y= mk_const("Everywhere",tv1);	
in
val etype4_exax = icl'new_axiom(["etype4_exax"],
	simple_mk_„(x,mk_comb(Tv1Pred,y)))
end;
val etype4_def = icl'new_type_defn( [ "ETYPE4"], "ETYPE4", ["'1"], etype4_exax); (* fails *)
local val x= mk_var("x",tv1);
	val y= mk_const("Everywhere",tv1);	
in
val etype5_exax = icl'new_axiom(["etype5_exax"],
	simple_mk_„(x,T))
end;
val etype5_def = icl'new_type_defn( [ "ETYPE5"], "ETYPE5", ["'1"], etype5_exax); (* fails *)
icl'new_type_defn( [ "ETYPE6"], "ETYPE6", ["'2","'2"], etype2_exax); (* fails *)
icl'new_type_defn( [ "ETYPE8"], "ETYPE8", [], 
	icl'asm_rule(mk_const("rubbish",BOOL))); (* fails *)

store_mt_results mt_run [("icl'open_theory 1 g",
	icl'open_theory,
	"next",
	([],[next_index+2]))];
icl'new_const("Š",mk_fun(BOOL,mk_fun(BOOL,BOOL)));
local
	val So = mk_var("So",BOOL);
	val IsSo = mk_var("IsSo",BOOL)
in
	val so_isso_axiom = icl'new_axiom(["so_isso_axiom"],
		simple_list_mk_„([So,IsSo],mk_Š(So,IsSo)));
end;
store_mt_results mt_run [("icl'open_theory 4 g",
	icl'open_theory,
	"yet_again",
	([next_index+2],[]))];
val so_isso_def = icl'new_specification (["So","IsSo"],2,so_isso_axiom);
icl'new_specification (["Soa","IsSoa"],2,so_isso_axiom); (* fails *)
icl'new_specification (["Soa","IsSoa"],2,icl'asm_rule(mk_const("rubbish",BOOL))); (* fails *)
store_mt_results mt_run [("icl'open_theory 1 h",
	icl'open_theory,
	"next",
	([],[next_index+2]))];
icl'new_specification (["Soa","IsSoa"],2,so_isso_axiom); (* fails *)
store_mt_results mt_run [("icl'open_theory 4 h",
	icl'open_theory,
	"yet_again",
	([next_index+2],[]))];
val xx_ax = icl'new_axiom(["xx_ax"],simple_mk_„(v1,simple_mk_„(v1,T)));
icl'new_specification (["X"],2,xx_ax);
local val x = mk_var("x",tv1);
	val y = mk_var("y",tv2);
in
val xy_ax = icl'new_axiom(["xy_ax"],simple_mk_„(x,simple_mk_„(y,T)))
end;
icl'new_specification (["X","Y"],2,xy_ax);
local val x = mk_var("x",tv1);
in
val v1_ax = icl'new_axiom(["v1_ax"],simple_mk_„(v1,
	simple_mk_ƒ(x,mk_eq(x,x))))
end;
icl'new_specification (["V1"],1,v1_ax);


print_ti(icl'get_theory_info "-");
val x_def = icl'new_specification (["x"],1,etype5_exax);
print_ti(icl'get_theory_info "-");
icl'new_specification ([],1,etype5_exax); (* fails *)
icl'new_specification (["x1"],0,etype5_exax); (* fails *)
icl'new_specification (["x1"],1,etype5_exax); (* fails *)
local val y = mk_var("y",BOOL)
in
val y_ax = icl'new_axiom(["y_ax"],simple_mk_„(y,T))
end;
icl'new_specification (["x"],1,y_ax); (* fails *)
icl'new_specification (["x2"],1,icl'asm_rule(simple_mk_„(v1,T))); (* fails *)
icl'new_specification (["x1"],1,etype3_exax); (* fails *)
local val p= mk_var("p",tv1);
	val q= mk_var("q",BOOL);	
in
val pq_ax = icl'new_axiom(["pq_ax"],simple_mk_„(p,q))
end;
icl'new_specification (["x1"],1,pq_ax); (* fails *)
icl'new_specification (["x3"],1,thy_deleted_thm);
store_mt_results mt_run [("icl'open_theory 2 e",
	icl'open_theory,
	"another",
	([next_index+1],[next_index,next_index+2]))];
val NEWTYPE = icl'new_type("NEWTYPE",1);
val NewThing = icl'new_const("NewThing",NEWTYPE);
store_mt_results mt_run [("icl'open_theory 4 i",
	icl'open_theory,
	"yet_again",
	([next_index,next_index+2],[next_index+1]))];
icl'list_save_thm(["x3"],icl'asm_rule(mk_eq(NewThing, NewThing))); (* fails *)
icl'new_parent "another";
icl'new_parent "rubbish"; (* fails *)
icl'list_save_thm(["x3"],icl'asm_rule(mk_eq(NewThing, NewThing))); (* succeeds *)

print_hierarchy();
store_mt_results mt_run [("icl'open_theory 3 f",
	icl'open_theory,
	"min",
	([],[next_index,next_index+1, next_index+2]))];
vaql test_index = icl'new_theory "test";
icl'open_theory "test";
val F' = icl'new_const("F",UNIT);
store_mt_results mt_run [("icl'open_theory 4 j",
	icl'open_theory,
	"yet_again",
	([next_index+2],[test_index]))];
icl'new_parent "test"; (* fails *)
icl'new_parent "min"; (* fails *)
store_mt_results mt_run [("icl'open_theory 3 f",
	icl'open_theory,
	"min",
	([],[test_index]))];
icl'new_parent "yet_again"; (* fails *)
icl'get_theory "min";
icl'get_theory "rubbish";
get_current_theory_status();


let val p= mk_var("p",tv1);
	val q= mk_var("q",BOOL);	
in
print_thm "" (icl'subst_rule [] (simple_mk_„(p,q)) pq_ax)
end; (* fails - not in scope *)
store_mt_results mt_run [("icl'open_theory 4 k",
	icl'open_theory,
	"yet_again",
	([next_index,next_index+1,next_index+2],[]))];
val DeleteIt = icl'new_const("DeleteIt",BOOL);
val level_deleted_thm = icl'asm_rule DeleteIt;
icl'delete_extension();

let val p= mk_var("p",tv1);
	val q= mk_var("q",BOOL);	
in
print_thm "" (icl'subst_rule [] (simple_mk_„(p,q)) pq_ax)
end;
let val p1= mk_var("p1",tv1);
	val q= mk_var("q",BOOL);	
in
print_thm "" (icl'subst_rule [] (simple_mk_„(p1,q)) pq_ax)
end;
let val p1= mk_var("p1",tv1);
	val q1 = mk_var("q1",BOOL);	
in
print_thm "" (icl'subst_rule [] (simple_mk_„(p1,q1)) pq_ax)
end; (* fails *)
val T_eq_F = icl'new_axiom(["silly"],mk_eq(T,F));

let val q = mk_var("q",BOOL);	
in
print_thm "" (icl'subst_rule [(T_eq_F, q)] (mk_eq(q,F)) T_eq_F)
end;
let val q = mk_var("q",BOOL);	
in
print_thm "" (icl'subst_rule [(icl'asm_rule(mk_eq(T,F)), q)] (mk_eq(q,F)) T_eq_F)
end;
let val q = mk_var("q",BOOL);	
in
print_thm "" (icl'subst_rule [(icl'asm_rule(mk_eq(T,F)), mk_var("n",†))] (mk_eq(q,F)) T_eq_F)
end; (* fails *)
let val q = mk_var("q",BOOL);	
in
print_thm "" (icl'subst_rule [(icl'asm_rule(mk_eq(T,F)), T)] (mk_eq(q,F)) T_eq_F)
end; (* fails *)
let val q = mk_var("q",BOOL);	
in
print_thm "" (icl'subst_rule [(icl'asm_rule T, q)] (mk_eq(q,F)) T_eq_F)
end; (* fails *)
let val q = mk_var("q",BOOL);	
in
icl'subst_rule [(T_eq_F, q)] (mk_eq(T,q)) T_eq_F
end; (* fails *)
icl'subst_rule [(T_eq_F, v1)] v1 thy_deleted_thm; (* fails *)
icl'subst_rule [(T_eq_F, v1)] v1 level_deleted_thm; (* fails *)
icl'subst_rule [(thy_deleted_thm, v1)] v1 T_eq_F; (* fails *)
icl'subst_rule [(level_deleted_thm, v1)] v1 T_eq_F; (* fails *)
=TEX
Check partial evaluation in $icl'subst\_rule$
doesn't allow out of scope theorems to be used when evaluation
taken to completed.
=SML
val DeleteIt2 = icl'new_const("DeleteIt2",BOOL);
val level_deleted_thm2 = icl'refl_conv DeleteIt2;
val pe_subst_rule = icl'subst_rule [(level_deleted_thm2, v1)] v1;
icl'delete_extension();
pe_subst_rule T_eq_F; (* fails *)

=TEX
Now continue with the other rules.
=SML
let val q = mk_var("q",BOOL);	
in
print_thm "" (icl'simple_abs_rule q T_eq_F)
end;
let val q = mk_var("q",BOOL);	
in
	icl'simple_abs_rule q (icl'asm_rule(mk_eq(q,F)))
end; (* fails *)
icl'simple_abs_rule v1 thy_deleted_thm; (* fails *)
icl'simple_abs_rule v1 level_deleted_thm; (* fails *)

let val q = mk_const("q",BOOL);	
in
print_thm "" (icl'simple_abs_rule q T_eq_F)
end; (* fails *)
let val q = mk_var("q",BOOL);	
in
print_thm "" (icl'simple_abs_rule q pq_ax)
end; (* fails *)

icl'inst_type_rule [(BOOL, tv1)] pq_ax;
icl'inst_type_rule [(BOOL, BOOL)] pq_ax;
icl'inst_type_rule [(BOOL, tv1)] (icl'asm_rule(mk_eq(mk_var("v",tv1), mk_var("v",tv1))));
icl'inst_type_rule [(BOOL, tv1)] thy_deleted_thm; (* fails *)
icl'inst_type_rule [(BOOL, tv1)] level_deleted_thm; (* fails *)

print_thm "" (icl'Š_intro v1 pq_ax);
icl'Š_intro N1 pq_ax; (* fail *)
icl'Š_intro v1 thy_deleted_thm; (* fails *)
icl'Š_intro v1 level_deleted_thm; (* fails *)

val so_axiom = icl'new_axiom(["so_axiom"],mk_const("So",BOOL));
print_thm "" (icl'Š_elim  so_isso_def so_axiom);
icl'Š_elim  so_isso_axiom so_axiom; (* fails *)
icl'Š_elim  so_isso_def so_isso_def; (* fails *)
icl'Š_elim so_isso_axiom thy_deleted_thm; (* fails *)
icl'Š_elim so_isso_def level_deleted_thm; (* fails *)
icl'Š_elim thy_deleted_thm so_isso_axiom; (* fails *)
icl'Š_elim level_deleted_thm so_isso_def; (* fails *)

print_thm "" (icl'asm_rule (mk_const("rubbish",BOOL)));
print_thm "" (icl'asm_rule (mk_const("rubbish",†))); (* fails *)

print_thm "" (icl'refl_conv (mk_const("rubbish",BOOL)));
print_thm "" (icl'refl_conv (mk_const("rubbish",†)));

let val p = mk_var("p", tv1);	
	val f = mk_var("f",mk_fun(tv1,BOOL));
	val q = mk_var("q",tv1);
in
print_thm "" (icl'simple_%beta%_conv (mk_comb(simple_mk_abs(p,mk_comb(f,p)),q)))
end;
let val p = mk_var("p", tv1);	
	val f = mk_var("f",mk_fun(tv1,mk_fun(tv1,BOOL)));
	val q = mk_var("q",tv1);
in
print_thm "" (icl'simple_%beta%_conv (mk_comb(
	simple_mk_abs(p,simple_mk_abs(q,list_mk_comb(f,[p,q]))),
	q)))
end;
let val p = mk_var("p", tv1);	
	val f = mk_var("f",mk_fun(tv1,BOOL));
	val q = mk_var("q",tv1);
in
	icl'simple_%beta%_conv (simple_mk_abs(p,mk_comb(f,p)))
end; (* fails *)

print_thm "" (icl'suc_conv (mk_† 0));
print_thm "" (icl'suc_conv (mk_† 3));
print_thm "" (icl'suc_conv (mk_const("Number",†))); (* fails *)

print_thm "" (icl'string_conv (mk_string "abc"));
print_thm "" (icl'string_conv (mk_string ""));
print_thm "" (icl'string_conv (mk_const("hello",STRING))); (* fail *)

print_thm "" (icl'char_conv (mk_char "a"));
print_thm "" (icl'char_conv (mk_char "†"));
print_thm "" (icl'char_conv (mk_const("he",CHAR))); (* fail *)

print_thm "" (icl'eq_sym_rule(icl'asm_rule(mk_eq(N1,N0))));
print_thm "" (icl'eq_sym_rule(icl'asm_rule(mk_eq(T,F))));
icl'eq_sym_rule pq_ax; (* fails *)
icl'eq_sym_rule thy_deleted_thm; (* fails *)
icl'eq_sym_rule level_deleted_thm; (* fails *)

print_thm "" (icl'simple_list_ƒ_elim [F](icl'asm_rule(
	simple_mk_ƒ(v1,mk_Š(v1,T)))));
print_thm "" (icl'simple_list_ƒ_elim [T,F](icl'asm_rule(
	simple_mk_ƒ(v1,simple_mk_ƒ(v2,mk_Š(v1,v2))))));
print_thm "" (icl'simple_list_ƒ_elim [v2,v2](icl'asm_rule(
	simple_mk_ƒ(v1,simple_mk_ƒ(v2,mk_Š(v1,v2))))));

print_thm "" (icl'simple_list_ƒ_elim [v2] (icl'asm_rule(
	simple_mk_ƒ(v1,mk_Š(v1,
		mk_comb(simple_mk_abs(v2,v1),T))))));
let
	val x = mk_var("x",BOOL);
	val tm = simple_mk_ƒ(x,simple_mk_ƒ(x,x));
in
(print_thm "" (icl'simple_list_ƒ_elim [T, F]
	(icl'asm_rule tm));
"This better be   ... … F")
end; 
icl'simple_list_ƒ_elim [T] pq_ax; (* fails *)
icl'simple_list_ƒ_elim [v1] thy_deleted_thm; (* fails *)
icl'simple_list_ƒ_elim [v1] level_deleted_thm; (* fails *)
icl'simple_list_ƒ_elim [N0](icl'asm_rule(
	simple_mk_ƒ(v1,mk_Š(v1,T)))); (* fails *)

print_thm "" (icl'eq_trans_rule (icl'asm_rule(mk_eq(N0,N1)))
	(icl'asm_rule(mk_eq(N1,N2))));
print_thm "" (icl'eq_trans_rule (icl'asm_rule(mk_eq(N0,N1))) pq_ax); (* fails *)
icl'eq_trans_rule (pq_ax) (icl'asm_rule(mk_eq(N1,N2))); (* fails *)
icl'eq_trans_rule (icl'asm_rule(mk_eq(N0,N1)))
	(icl'asm_rule(mk_eq(N0,N2))); (* fails *)
icl'eq_trans_rule so_isso_axiom thy_deleted_thm; (* fails *)
icl'eq_trans_rule so_isso_def level_deleted_thm; (* fails *)
icl'eq_trans_rule thy_deleted_thm so_isso_axiom; (* fails *)
icl'eq_trans_rule level_deleted_thm so_isso_def; (* fails *)

print_thm "" (icl'mk_comb_rule (icl'refl_conv(mk_const("Suc",
		mk_fun(†,†))))
	(icl'asm_rule(mk_eq(N1,N2))));
icl'mk_comb_rule (icl'refl_conv(T)) (icl'asm_rule(mk_eq(N1,N2))); (* fails *)
icl'mk_comb_rule pq_ax (icl'asm_rule(mk_eq(N1,N2))); (* fails *)
icl'mk_comb_rule (icl'asm_rule(mk_eq(N1,N2))) (pq_ax); (* fails *)
icl'mk_comb_rule (icl'asm_rule(mk_eq(N0,N1)))
	(icl'asm_rule(mk_eq(N0,N2))); (* fails *)
icl'mk_comb_rule so_isso_axiom thy_deleted_thm; (* fails *)
icl'mk_comb_rule so_isso_def level_deleted_thm; (* fails *)
icl'mk_comb_rule thy_deleted_thm so_isso_axiom; (* fails *)
icl'mk_comb_rule level_deleted_thm so_isso_def; (* fails *)

print_thm "" (icl'‚_mp_rule  (icl'asm_rule(mk_eq(T,F)))
	(icl'asm_rule T));
icl'‚_mp_rule (icl'asm_rule(mk_eq(T,F))) (icl'asm_rule F); (* fails *)
icl'‚_mp_rule (icl'asm_rule T) (icl'asm_rule(mk_eq(T,F))); (* fails *)
icl'‚_mp_rule so_isso_axiom thy_deleted_thm; (* fails *)
icl'‚_mp_rule so_isso_def level_deleted_thm; (* fails *)
icl'‚_mp_rule thy_deleted_thm so_isso_axiom; (* fails *)
icl'‚_mp_rule level_deleted_thm so_isso_def; (* fails *)

print_thm "" (icl'simple_ƒ_intro v1  (icl'asm_rule(mk_eq(T,F))));
icl'simple_ƒ_intro v1  (icl'asm_rule v1); (* fails *)
let val c1 = mk_const("c1",BOOL)
in
icl'simple_ƒ_intro c1  (icl'asm_rule c1)
end; (* fails *)
icl'simple_ƒ_intro v1 thy_deleted_thm; (* fails *)
icl'simple_ƒ_intro v1 level_deleted_thm; (* fails *)

let val p = mk_var("p",BOOL);
	val q = mk_var("q",BOOL);
	val thm1 = icl'simple_list_ƒ_elim [p,q]
		(icl'asm_rule(simple_list_mk_ƒ([p,q],mk_eq(p,q))));
in
	(print_thm "" thm1;
	print_thm "" (icl'inst_term_rule [(T,p),(F,q)] thm1))
end;
let val p = mk_var("p",BOOL);
	val q = mk_var("q",BOOL);
	val thm1 = icl'simple_list_ƒ_elim [p,q]
		(icl'asm_rule(simple_list_mk_ƒ([p,q],mk_eq(p,q))));
in
	print_thm "" (icl'inst_term_rule [(q,p),(p,q)] thm1)
end;
icl'inst_term_rule [(v2,v1)] (icl'asm_rule v1) ; (* fails *)
icl'inst_term_rule [] thy_deleted_thm; (* fails *)
icl'inst_term_rule [] level_deleted_thm; (* fails *)
let val p = mk_var("p",BOOL);
	val q = mk_var("q",BOOL);
	val thm1 = icl'simple_list_ƒ_elim [p,q]
		(icl'asm_rule(simple_list_mk_ƒ([p,q],mk_eq(p,q))));
in
	icl'inst_term_rule [(q,p),(p,T)] thm1
end; (* fail *)
let val p = mk_var("p",BOOL);
	val q = mk_var("q",BOOL);
	val thm1 = icl'simple_list_ƒ_elim [p,q] 
		(icl'asm_rule(simple_list_mk_ƒ([p,q],mk_eq(p,q))));
in
	icl'inst_term_rule [(q,p),(N0,q)] thm1
end; (* fail *)

val tDiv = icl'new_const("Div",mk_fun(†,mk_fun(†,†)));

print_thm "" (icl'div2_conv (list_mk_comb(tDiv,[mk_† 7,N2])));
print_thm "" (icl'div2_conv (list_mk_comb(tDiv,[mk_† 0,N2])));
icl'div2_conv (list_mk_comb(tDiv,[mk_† 0,N1])); (* fails *)
icl'div2_conv (list_mk_comb(tDiv,[ZeRo,N2])); (* fails *)

val tMod = icl'new_const("Mod",mk_fun(†,mk_fun(†,†)));
print_thm "" (icl'mod2_conv (list_mk_comb(tMod,[mk_† 7,N2])));
print_thm "" (icl'mod2_conv (list_mk_comb(tMod,[mk_† 0,N2])));
icl'mod2_conv (list_mk_comb(tMod,[mk_† 0,N1])); (* fails *)
icl'mod2_conv (list_mk_comb(tMod,[ZeRo,N2])); (* fails *)
=TEX
Test hooks into environments.
=SML
get_const_type "5"; (* built in *)
get_const_type ""; (* Nil *)
get_const_type "T";
get_const_type "TorF"; (* Nil *)
get_const_type "rubbish"; (* Nil *)
get_type_arity "BOOL";
get_type_arity ""; (* Nil*)
get_type_arity "†";
get_type_arity "‹";
get_type_arity "rubbish"; (* Nil *)
=TEX
Test the built in scopes:
=SML
icl'new_const("1",BOOL); (* fails *)
icl'new_const("123",BOOL); (* fails *)
icl'new_const("12a",BOOL); (* succeeds! *)
icl'new_const("'a",BOOL); (* fails *)
icl'new_const("'abcd",BOOL); (* succeeds! *)
icl'new_const("\"a",BOOL); (* fails *)
icl'new_const("\"abc",BOOL); (* fails *)
=TEX
Test the sealing of theories:
=SML
store_mt_results mt_run [("icl'open_theory 1 i",
	icl'open_theory,
	"next",
	([],[next_index+1,next_index+2]))];
icl'seal_hierarchy();
store_mt_results mt_run [("icl'open_theory 1 j",
	icl'open_theory,
	"next",
	([],[]))];
icl'open_theory "min"; (* fails *)
icl'open_theory "another"; (* fails *)
store_mt_results mt_run [("icl'open_theory 4 l",
	icl'open_theory,
	"yet_again",
	([next_index+1,next_index+2],[]))];
=TEX
Tests on hierarchies : do after all others, as things are made read only.
=SML
val newhier = icl'new_hierarchy();
print_hierarchy();
icl'new_axiom(["Truth_axiom1"],T); (* fails *)
icl'new_const("ForT1",BOOL); (* fails *)
icl'new_type("SOMETHING1",3); (* fails *)
icl'new_defn (["True1"],"True1",T); (* fails *)
icl'delete_extension(); (* fails *)
icl'list_save_thm(["Example1"],icl'asm_rule v1); (* fails *)
icl'delete_thm "Example";
icl'delete_theory "yet_again"; (* fails *)
icl'lock_theory "yet_again"; (* fails *)
icl'new_parent "another"; (* fails *)
val etype_def = icl'new_type_defn( [ "ETYPE7"], "ETYPE7", ["'1"], etype_exax); (* fails *)
icl'new_specification (["So1","IsSo1"],2,so_isso_axiom); (* fails *)
icl'load_hierarchy newhier;
icl'new_theory "another_test";
icl'load_hierarchy newhier; (* fails *)

=TEX
\subsection{End of Tests}
=SML
summarize_mt_results();
(* PolyML.quit(); *)
=TEX
\section{UNTESTED ERROR MESSAGES}
The following are not tested for various reasons:

\begin{tabular}{| l | p{4.5in} |}\hline
Test & Comment \\ \hline
6072 & This is where a theorem has a duff theory pointer: difficult to recreate. \\
6066 & Only tested for $icl'subst\_rule$. \\
(6033) & Can't easily test whether we can load a hierarchy that
is a superset of the current hierarchies theories. \\ \hline
\end{tabular}
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
=TEX
\end{document}
