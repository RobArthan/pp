=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for the Abstract Data Type $THM$}  %% Mandatory field
\def\TPPheadtitle{Module Tests for the Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/MDT006}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the 
the abstract data type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue 1.1]
First draft version.
\item [Issue 1.2]
Corrected typos, slight improvement to layout.
\item [Issue 1.3]
Changed to match issue 1.9 of \cite{DS/FMU/IED/DTD006}.
\item [Issue 1.4]
Testing corrections made to implementation.
\item [Issue 1.5]
Now reloads ``imp006.sml'' to start off from an empty ``min'' theory.
\item [Issue 1.6,1.7]
Changed to match issue 1.11 of \cite{DS/FMU/IED/DTD006}.
\item [Issue 1.8]
Changed a $list\_mk\_„$ to $list\_simple\_mk\_„$.
\item [Issue 1.8]
Changed a $mk\_„$ to $simple\_mk\_„$.
\item [Issue 1.9]
Added a test for $icl'simple\_list\_ƒ\_elim$ with duplicate quantifiers.
\item [Issue 1.10]
The prefix $simple$ is moved to being the first prefix, bar $icl'$.
Changed to match issue 1.12 of \cite{DS/FMU/IED/DTD006}.
\item [Issue 1.11]
Clears out theory hierarchy, rather than reloading imp006.
\item [Issue 1.12,1.13]
Deals with some glitches.
\item [Issue 1.14]
Initial use of material from \cite{DS/FMU/IED/DTD013}.
\item [Issue 1.15]
Further use of material from \cite{DS/FMU/IED/DTD013}.
Stopped using parser.
\end{description}
\subsection{Changes forecast}
Many.
Use of DJK test harness work.
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the the Abstract Data Type $THM$, required by Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The design is in \cite{DS/FMU/IED/DTD006}
and it is
implemented in \cite{DS/FMU/IED/IMP006}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD006},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD006},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP006}.
It does not depend on the ICL HOL parser, and only incidentally
on the pretty printer.
This is because these tools rely on the correct setting of
scopes by functions relying on those of this document.
\subsubsection{Deficiencies}
The coverage of the tests, as called for by the test specification, may currently be incomplete.
\section{UTILITIES}
=SML
PolyML.print_depth 10;
=TEX
Initialise the test package:
=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results();
=TEX
We want to test in the context of empty theories,
and at least the icl'Kernel so:
=SML
open icl'Kernel;
icl'open_theory "min";

fun âtheory_namesá ((): unit) : string list = (
let	val hier = icl'get_hierarchy();
in
	map fst (hier drop 
		(fn (_,{status = status,...}) => status = TSDeleted))
end);

map (fn x => icl'delete_theory x 
	handle (Fail _) => ()) (theory_names());
map (fn x => icl'delete_theory x 
	handle (Fail _) => ()) (theory_names());
fun delete_all () = (
	(icl'delete_extension ();
	delete_all ())
	handle (Fail _) => ());

delete_all ();
=TEX
We provide a list of diagnostic printing functions. 
Those called $string\_of\_\ldots$ turn objects of various significant types ($TERM$, $THM$, etc)
into strings,
those called $print\_\ldots$ apply $diag\_string$ to the output
of the associated $string\_of\_\ldots$.
=SML
fun âstring_of_typeá (t: TYPE) : string = (
let
	fun aux ty = (
	if is_vartype ty then 
		(" " ^ dest_vartype ty)
	else if is_funtype ty then
		(let val(t1,t2) = dest_funtype ty
		in
		( "(" ^ aux t1 ^ " ‹" ^ aux t2 ^")" )
		end)
	else (let 
		fun aux1 ("‰",[t1,t2]) = (
		"(" ^ aux t1 ^ " ‰" ^ aux t2 ^")"
		) | aux1 ((s,[])) = (
		" " ^ s
		) | aux1 ((s,tyl)) = (
		"((" ^ implode (map ((fn x => x ^", ") o aux) tyl)^ ")" ^ s ^ ")")
		in
			aux1 (dest_type ty)
		end)
	)
in
	(":" ^ aux t)
end);
val âprint_typeá = diag_line o string_of_type;

local
	fun icl'simple_print_dest_term (Comb(t1,t2)) = (
	"Comb (" ^ icl'simple_print_dest_term(simple_dest_term t1) ^", " ^
		icl'simple_print_dest_term(simple_dest_term t2) ^ ")"
) | icl'simple_print_dest_term (Const(s,ty)) = s ^ string_of_type ty
| icl'simple_print_dest_term (Var(s,ty)) = s ^ string_of_type ty
| icl'simple_print_dest_term (Abs(v,b)) = (
	let val (vs,vt) = dest_var v
	in
	" " ^ vs ^ string_of_type vt ^ " Ž " ^ icl'simple_print_dest_term (simple_dest_term b)
	end);
in

fun âstring_of_termá (tm : TERM) = icl'simple_print_dest_term (simple_dest_term tm);

fun âprint_termá (tm: TERM) = diag_line(string_of_term tm);
end;
=TEX
We also provide a pair of functions on $TERM$ that don't give the type information.
=SML
local fun icl'simple_print_dest_term (Comb(t1,t2)) = (
	"(" ^ icl'simple_print_dest_term(simple_dest_term t1) ^ " " ^
		icl'simple_print_dest_term(simple_dest_term t2) ^ ")"
) | icl'simple_print_dest_term (Const(s,ty)) = s
| icl'simple_print_dest_term (Var(s,ty)) = s
| icl'simple_print_dest_term (Abs(v,b)) = (
	let val (vs,vt) = dest_var v
	in
	"( " ^ vs ^ " Ž " ^ icl'simple_print_dest_term (simple_dest_term b) ^")"
	end);
in
	fun âstring_of_term1á (tm: TERM): string = (
		icl'simple_print_dest_term (simple_dest_term tm)
	);

	fun âprint_term1á (tm: TERM): unit = diag_line(string_of_term1 tm);

	fun âstring_of_seqá ((tml , tm): SEQ) : string = (
		format_list string_of_term1 tml ", " ^
		"… " ^ string_of_term1 tm
	);

	fun âprint_seqá (seq: SEQ) : unit = diag_line(string_of_seq seq);
end;

fun âstring_of_thmá (key:string) (them : THM) : string = (
let val {level=level,theory={name=iname,...},sequent=sequent} =
		icl'dest_thm them
	in
		"In theory "^ string_of_int iname ^ 
		", at level "^ string_of_int level ^ 
		", with key "^ key ^
		"\n" ^
		string_of_seq sequent
end);

fun âprint_thmá (key:string) (them : THM) : unit = diag_line(string_of_thm key them);

fun âstring_of_thyá ({name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		defn_dict = defn_dict,
		thm_dict = thm_dict,
		current_level = current_level,
		user_data = user_data} : THEORY) : string = (
	"Internal name " ^ string_of_int iname ^
	", Current Level " ^ string_of_int current_level^
	", Parents " ^ format_list string_of_int parents ", " ^
	"\n***Types***\n" ^
	implode (map (fn (nm,{arity=arity,level=level}) =>
		("     " ^ nm ^ 
		": arity="^string_of_int arity ^
		", level="^string_of_int level ^ "\n"))
		ty_env) ^
	"***Constants***\n" ^
	implode (map (fn (nm,{ty=ty,level=level}) =>
		("     " ^ nm ^ 
		": ty="^string_of_type ty ^
		", level="^string_of_int level ^ "\n"))
		con_env) ^
	(format_list (Combinators.I)
	(["***Theorems***"] @
	(map (uncurry string_of_thm) thm_dict) @
	["***Definitions***"] @
	(map (uncurry string_of_thm) defn_dict) @
	["***Axioms***"] @
	(map (uncurry string_of_thm) axiom_dict)) "\n")
);

fun âprint_thyá (thy  : THEORY) : unit = diag_line(string_of_thy thy);

fun âstring_of_tiá ({status : THEORY_STATUS,
	inscope : bool,
	contents : THEORY,
	children : int list,
	name : string}:THEORY_INFO) : string = (
	"Theory " ^ name ^ "\n" ^
	(if inscope then "In Scope, " else "Out of Scope, ") ^
	(case status of
	TSNormal => "Status: Normal, "
	| TSDeleted => "Status: Deleted, "
	| TSLocked => "Status: Locked, "
	| TSAncestor => "Status: Ancestor, ") ^
	"Children:" ^ (format_list string_of_int children ", ") ^ "\n" ^

	string_of_thy contents
);

fun âprint_tiá (ti : THEORY_INFO) : unit = diag_line(string_of_ti ti);

fun âstring_of_hierarchyá (():unit) : string = (
	implode(map (fn (p,q) => ("------ti key: "^p^"------\n" ^
		string_of_ti q ^ "\n"))
	(icl'get_hierarchy ())));

fun âprint_hierarchyá (():unit) : unit = diag_line(string_of_hierarchy ());

=TEX
\section{VALUE BINDINGS}
Such as can be given here:
=SML
val v1 = mk_var("v1", BOOL);
val v2 = mk_var("v2", BOOL);
val tv1 = mk_vartype "'tv1";
val tva = mk_vartype "'a";
val tv'1 = mk_vartype "'1";
val tv'2 = mk_vartype "'2";
val vtv1 = mk_var("vtv1",tv1);
val v1 = mk_var("v1", BOOL);
val v2 = mk_var("v2", BOOL);
val N0 = mk_† 0;
val N1 = mk_† 1;
val N2 = mk_† 2;
val N3 = mk_† 3;
val N7 = mk_† 7;
val pB = mk_var("p",BOOL);
val qB = mk_var("q",BOOL);
val xB = mk_var("x",BOOL);
val p1 = mk_var("p",tv'1);
val q1 = mk_var("q",tv'1);
val pa = mk_var("p",tva);
val qa = mk_var("q",tva);
val qa' = mk_var("q'",tva);
val p11 = mk_var("p1",tv'1);
val q1B = mk_var("q1",BOOL);
val pa = mk_var("p",tva);
val exists_p_q = mk_„(p1, qB);
val exists_pB_q = mk_„(pB, qB);
val exists_pa_q = mk_„(pa, qB);
val exists_p_q1 = mk_„(p1,q1B);
val exists_p1_q = mk_„(p11, qB);
val So = mk_const("So",BOOL);
val IsSo = mk_const("IsSo",BOOL);
val vSo = mk_var("So",BOOL);
val vIsSo = mk_var("IsSo",BOOL);
=TEX
\section{THE TESTS}
=TEX
Our initial hierarchy of (empty) theories.
All theories bar ``min'' should have status $Deleted$, and ``min'' should be
 empty.
=SML
print_hierarchy ();
=TEX
=SML
val next_index = icl'new_theory "next";
store_mt_results mt_run [("icl'new_theory 1",
	icl'new_theory,
	"another",
	next_index+1)];
store_mt_results mt_run [("icl'open_theory 1 a",
	icl'open_theory,
	"next",
	([next_index],[]))];
store_mt_results mt_run [("icl'new_theory a",
	icl'new_theory,
	"yet_again",
	next_index+2)];
store_mt_results mt_run_fail [("icl'new_theory 6040",
	icl'new_theory,
	"yet_again",
	gen_fail_msg "icl'new_theory" 6040 ["yet_again"])];
store_mt_results mt_run_fail [("icl'open_theory 6035 a",
	icl'open_theory,
	"rubbish",
	gen_fail_msg "icl'open_theory" 6035 ["rubbish"])];

print_hierarchy ();
=TEX
A test of scopes: an older version of imp006 would give a failure, if this executes at all it is OK.
The failure was to do with scopes not being completely cleared of that what was going out of scope before new material was added.
=SML
icl'open_theory "next";
icl'new_type("ScopeTest",1);
icl'open_theory "another";
icl'new_type("ScopeTest",2);
icl'open_theory "next";
icl'open_theory "another";
icl'open_theory "next";
=TEX
=SML
store_mt_results mt_run [("icl'new_type 1",
	icl'new_type,
	("BOOL",0),
	mk_type("BOOL",[]))];

store_mt_results mt_run [("icl'get_theory_name 1",
	icl'get_theory_name,
	next_index,
	"next")];
store_mt_results mt_run_fail [("icl'get_theory_name 6043 a",
	icl'get_theory_name,
	100,
	gen_fail_msg "icl'get_theory_name" 6043 ["100"]),
	("icl'get_theory_name 6043 b",
	icl'get_theory_name,
	~1,
	gen_fail_msg "icl'get_theory_name" 6043 ["-1"])];

print_ti(icl'get_theory_info "next");
store_mt_results mt_run_fail [("icl'get_theory_info 6035 a",
	icl'get_theory_info,
	"rubbish",
	gen_fail_msg "icl'get_theory_info" 6035 ["rubbish"])];

store_mt_results mt_run [("icl'new_type 2",
	icl'new_type,
	("†",0),
	mk_type("†",[]))];
store_mt_results mt_run_fail [("icl'new_type 6045",
	icl'new_type,
	("†",0),
	gen_fail_msg "icl'new_type" 6045 ["†"])];

print_ti(icl'get_theory_info "next");

val n1 = icl'list_save_thm(["n1"], icl'asm_rule v1);
store_mt_results mt_run_fail [("icl'list_save_thm 6039",
	icl'list_save_thm,
	(["n1"], icl'asm_rule v1),
	gen_fail_msg "icl'list_save_thm" 6039 ["n1","next"]),
	("icl'list_save_thm 6031",
	icl'list_save_thm,
	([], icl'asm_rule v1),
	gen_fail_msg "icl'list_save_thm" 6031 []),
	("icl'list_save_thm 6038 a",
	icl'list_save_thm,
	(["n2"], icl'refl_conv (mk_var("rv",mk_type("rubbish",[])))),
	gen_fail_msg "icl'list_save_thm" 6038 [])
	];

store_mt_results mt_run [("icl'open_theory 2 a",
	icl'open_theory,
	"another",
	([next_index+1],[next_index])),
	("icl'open_theory 2 b",
	icl'open_theory,
	"another",
	([],[]))];
store_mt_results mt_run_fail [("icl'list_save_thm 6038 b",
	icl'list_save_thm,
	(["n2"], icl'asm_rule v1),
	gen_fail_msg "icl'list_save_thm" 6038 [])
	];
store_mt_results mt_run [("icl'open_theory 1 b",
	icl'open_theory,
	"next",
	([next_index],[next_index+1]))];
store_mt_results mt_run [("icl'new_type 3",
	icl'new_type,
	("‰",2),
	mk_type("‰",[tv'1,tv'2])),
	("icl'new_type 4",
	icl'new_type,
	("‹",2),
	mk_type("‹",[tv'1,tv'2]))];
store_mt_results mt_run [ 
	("icl'new_const 1",
	icl'new_const,
	("T",BOOL),
	mk_t),
	("icl'new_const 2",
	icl'new_const,
	("F",BOOL),
	mk_f)
	];
store_mt_results mt_run [("icl'new_const",
	icl'new_const,
	("Test",BOOL),
	mk_const("Test",BOOL))];
store_mt_results mt_run_fail [("icl'new_const 6075",
	icl'new_const,
	("TypeWrong",mk_type("TYPEWRONG",[])),
	gen_fail_msg "icl'new_const" 6075 ["next"])];

print_ti(icl'get_theory_info "next");
store_mt_results mt_run [("icl'open_theory 3 a",
	icl'open_theory,
	"min",
	([],[next_index]))];

store_mt_results mt_run_fail [("icl'new_type 6034",
	icl'new_type,
	("‰",2),
	gen_fail_msg "icl'new_type" 6034 ["‰"]),
	("icl'new_type 6088",
	icl'new_type,
	("rubbish",~1),
	gen_fail_msg "icl'new_type" 6088 [])];
val UNIT = icl'new_type ("UNIT",0);
val Unit = icl'new_const("Unit",UNIT);
print_ti(icl'get_theory_info "min");
store_mt_results mt_run [("icl'open_theory 1 c",
	icl'open_theory,
	"next",
	([next_index],[]))];
val AlsoUnit = icl'new_const("AlsoUnit",UNIT);
store_mt_results mt_run [("icl'open_theory 3 b",
	icl'open_theory,
	"min",
	([],[next_index]))];
store_mt_results mt_run_fail [("icl'new_const 6063",
	icl'new_const,
	("AlsoUnit",UNIT),
	gen_fail_msg "icl'new_const" 6063 ["AlsoUnit"])];
store_mt_results mt_run_fail [("icl'new_defn 6063",
	icl'new_defn,
	(["AlsoUnit"],"AlsoUnit", Unit),
	gen_fail_msg "icl'new_defn" 6063 ["AlsoUnit"])];
store_mt_results mt_run [("icl'open_theory 4 a",
	icl'open_theory,
	"yet_again",
	([next_index,next_index+2],[]))];
store_mt_results mt_run [("icl'open_theory 2 c",
	icl'open_theory,
	"another",
	([next_index+1],[next_index,next_index+2]))];
store_mt_results mt_run [("icl'new_type 5",
	icl'new_type,
	("BOOL",0),
	mk_type("BOOL",[]))];
store_mt_results mt_run [ 
	("icl'new_const 1",
	icl'new_const,
	("T",BOOL),
	mk_t),
	("icl'new_const 2",
	icl'new_const,
	("F",BOOL),
	mk_f)
	];

print_ti(icl'get_theory_info "another");
store_mt_results mt_run [("icl'delete_extension 1",
	icl'delete_extension,
	(),
	4)];
print_ti(icl'get_theory_info "-");
val s1 = icl'list_save_thm(["s1"], icl'asm_rule v1);
store_mt_results mt_run_fail [("icl'delete_extension 6077",
	icl'delete_extension,
	(),
	gen_fail_msg "icl'delete_extension" 6077 ["another","s1"])];
store_mt_results mt_run [("icl'delete_thm 1",
	dest_thm o icl'delete_thm,
	"s1",
	([v1],v1))];
store_mt_results mt_run [("icl'delete_extension 2",
	icl'delete_extension,
	(),
	3)];
val TorF = icl'new_const("TorF",BOOL);
print_ti(icl'get_theory_info "-");
fun icl'delete_extension (u:unit): int = (
let val n = icl'Kernel.icl'delete_extension u
in
	(diag_line("icl'delete_extension @ "^string_of_int n);
	n)
end);
store_mt_results mt_run [("icl'delete_extension 3",
	icl'delete_extension,
	(),
	7),
	("icl'delete_extension 4",
	icl'delete_extension,
	(),
	2),
	("icl'delete_extension 5",
	icl'delete_extension,
	(),
	1)];
store_mt_results mt_run_fail [("icl'delete_extension 6050",
	icl'delete_extension,
	(),
	gen_fail_msg "icl'delete_extension" 6050 ["another"])];
store_mt_results mt_run [("icl'open_theory 4 b",
	icl'open_theory,
	"yet_again",
	([next_index,next_index+2],[next_index+1]))];
store_mt_results mt_run [("icl'new_axiom 1",
	dest_thm o icl'new_axiom,
	(["truth_axiom"],mk_t),
	([],mk_t)),
	("icl'new_axiom 2",
	dest_thm o icl'new_axiom,
	(["not so", "No way!"], mk_f),
	([], mk_f)),
	("icl'new_axiom 3",
	dest_thm o icl'new_axiom,
	(["testing"],mk_comb(mk_var("f",mk_fun(BOOL,BOOL)), mk_t)),
	([],mk_comb(mk_var("f",mk_fun(BOOL,BOOL)), mk_t)))
	];
store_mt_results mt_run_fail [("icl'new_axiom 6047",
	icl'new_axiom,
	(["truth_axiom"],mk_t),
	gen_fail_msg "icl'new_axiom" 6047 ["truth_axiom","yet_again"]),
	("icl'new_axiom 6048",
	icl'new_axiom,
	(["type_wrong_axiom"],mk_eq(mk_var("v",mk_type("V",[])), 
		mk_var("v",mk_type("V",[])))),
	gen_fail_msg "icl'new_axiom" 6048 ["yet_again"]),
	("icl'new_axiom 6031",
	icl'new_axiom,
	([],mk_t),
	gen_fail_msg "icl'new_axiom" 6031 []),
	("icl'new_axiom 6009",
	icl'new_axiom,
	(["Not Bool"],N0),
	gen_fail_msg "icl'new_axiom" 6009 [])];
store_mt_results mt_run [("icl'open_theory 2 d",
	icl'open_theory,
	"another",
	([next_index+1],[next_index, next_index+2]))];
store_mt_results mt_run_fail [("icl'new_axiom 6048",
	icl'new_axiom,
	(["truth_axiom"],mk_t),
	gen_fail_msg "icl'new_axiom" 6048 ["another"])];
store_mt_results mt_run [("icl'open_theory 4 c",
	icl'open_theory,
	"yet_again",
	([next_index,next_index+2],[next_index+1]))];
store_mt_results mt_run [("icl'list_save_thm 1",
	dest_thm o icl'list_save_thm,
	(["tbd"],icl'asm_rule mk_t),
	([mk_t],mk_t))];

icl'lock_theory "yet_again";
print_ti(icl'get_theory_info "yet_again");
store_mt_results mt_run_fail [("icl'lock_theory 1",
	icl'new_axiom,
	(["Truth_axiom"],mk_t),
	gen_fail_msg "icl'new_axiom" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 2",
	icl'list_save_thm,
	(["Example"],icl'asm_rule v1),
	gen_fail_msg "icl'list_save_thm" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 3",
	icl'new_const,
	("ForT",BOOL),
	gen_fail_msg "icl'new_const" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 4",
	icl'new_type,
	("SOMETHING",3),
	gen_fail_msg "icl'new_type" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 5",
	icl'delete_extension,
	(),
	gen_fail_msg "icl'delete_extension" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 6",
	icl'delete_thm,
	"tba",
	gen_fail_msg "icl'delete_thm" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 7",
	icl'new_defn,
	(["SomeWhere"],"SomeWhere", mk_f),
	gen_fail_msg "icl'new_defn" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 8",
	icl'new_type_defn,
	( [ "TestType"], "TestType", ["'2"], icl'asm_rule mk_t),
	gen_fail_msg "icl'new_type_defn" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 9",
	icl'new_specification,
	( [ "TestSpec"], 1, icl'asm_rule mk_t),
	gen_fail_msg "icl'new_specification" 6037 ["yet_again"])];
store_mt_results mt_run_fail [("icl'lock_theory 10",
	icl'new_parent,
	"another",
	gen_fail_msg "icl'new_parent" 6037 ["yet_again"])];
store_mt_results mt_run [("icl'lock_theory 11",
	get_current_theory_status,
	(),
	TSLocked)];

icl'unlock_theory "yet_again";
=TEX
=SML
store_mt_results mt_run [("icl'unlock_theory 11",
	get_current_theory_status,
	(),
	TSNormal)];
store_mt_results mt_run [("icl'open_theory 3 c",
	icl'open_theory,
	"min",
	([],[next_index, next_index+2]))];
store_mt_results mt_run_fail [("icl'delete_extension 6076",
	icl'delete_extension,
	(),
	gen_fail_msg "icl'delete_extension" 6076 ["min"])];
store_mt_results mt_run [("icl'open_theory 1 d",
	icl'open_theory,
	"next",
	([next_index],[]))];
val tdb_index = icl'new_theory "to_be_deleted";
store_mt_results mt_run [("icl'open_theory 5",
	icl'open_theory,
	"to_be_deleted",
	([tdb_index],[]))];
val thy_deleted_thm = icl'list_save_thm(["thy_deleted_thm"],
	icl'asm_rule v1);
store_mt_results mt_run [("icl'open_theory 1 e",
	icl'open_theory,
	"next",
	([],[tdb_index]))];
icl'delete_theory "to_be_deleted";
print_hierarchy();
store_mt_results mt_run_fail [("icl'get_theory_info 6035 b",
	icl'get_theory_info,
	"to_be_deleted",
	gen_fail_msg "icl'get_theory_info" 6035 ["to_be_deleted"])];
store_mt_results mt_run_fail [("icl'get_theory_name 6089",
	icl'get_theory_name,
	tdb_index,
	gen_fail_msg "icl'get_theory_name" 6089 [string_of_int tdb_index])];

store_mt_results mt_run_fail [("icl'open_theory 6035 b",
	icl'open_theory,
	"to_be_deleted",
	gen_fail_msg "icl'open_theory" 6035 ["to_be_deleted"])];
store_mt_results mt_run_fail [("icl'delete_theory 6035 b",
	icl'delete_theory,
	"to_be_deleted",
	gen_fail_msg "icl'delete_theory" 6035 ["to_be_deleted"])];
store_mt_results mt_run_fail [("icl'lock_theory 6035 a",
	icl'lock_theory,
	"to_be_deleted",
	gen_fail_msg "icl'lock_theory" 6035 ["to_be_deleted"]),
	("icl'lock_theory 6035 b",
	icl'lock_theory,
	"rubbish",
	gen_fail_msg "icl'lock_theory" 6035 ["rubbish"])];
store_mt_results mt_run [("icl'new_theory 3",
	icl'new_theory,
	"to_be_deleted",
	tdb_index+1)];
icl'delete_theory "to_be_deleted"; 
store_mt_results mt_run_fail [("icl'delete_theory 6076",
	icl'delete_theory,
	"min",
	gen_fail_msg "icl'delete_theory" 6076 ["min"])];

icl'lock_theory "yet_again";
store_mt_results mt_run_fail [("icl'lock_theory 12",
	icl'delete_theory,
	"yet_again",
	gen_fail_msg "icl'delete_theory" 6037 ["yet_again"])];
icl'unlock_theory "yet_again";
store_mt_results mt_run [("icl'open_theory 4 d",
	icl'open_theory,
	"yet_again",
	([next_index+2],[]))];
store_mt_results mt_run_fail [("icl'delete_theory 6069",
	icl'delete_theory,
	"yet_again",
	gen_fail_msg "icl'delete_theory" 6069 ["yet_again"])];
store_mt_results mt_run_fail [("icl'unlock_theory 6035 a",
	icl'unlock_theory,
	"to_be_deleted",
	gen_fail_msg "icl'unlock_theory" 6035 ["to_be_deleted"]),
	("icl'lock_theory 6035 b",
	icl'unlock_theory,
	"rubbish",
	gen_fail_msg "icl'unlock_theory" 6035 ["rubbish"]),
	("icl'lock_theory 6068",
	icl'unlock_theory,
	"yet_again",
	gen_fail_msg "icl'unlock_theory" 6068 ["yet_again"])];

print_ti(icl'get_theory_info "next");
icl'duplicate_theory "next" "copy_of_next";
print_ti(icl'get_theory_info "copy_of_next");

store_mt_results mt_run_fail [("icl'duplicate_theory 6040",
	icl'duplicate_theory "rubbish",
	"copy_of_next",
	gen_fail_msg "icl'duplicate_theory" 6040 ["copy_of_next"]),
	("icl'duplicate_theory 6035 a",
	icl'duplicate_theory "rubbish",
	"copy_of_rubbish",
	gen_fail_msg "icl'duplicate_theory" 6035 ["rubbish"]),
	("icl'duplicate_theory 6035 b",
	icl'duplicate_theory "to_be_deleted",
	"copy_of_rubbish",
	gen_fail_msg "icl'duplicate_theory" 6035 ["to_be_deleted"])
];
store_mt_results mt_run_fail [("icl'delete_thm 6046",
	icl'delete_thm,
	"rubbish",
	gen_fail_msg "icl'delete_thm" 6046 ["rubbish","yet_again"])];
store_mt_results mt_run_error [("icl'list_save_thm 6036",
	icl'list_save_thm,
	(["s2"], thy_deleted_thm),
	gen_fail_msg "icl'list_save_thm" 6036 ["to_be_deleted",string_of_int tdb_index])];

=TEX
\subsubsection{icl'new\_defn}
=SML
icl'open_theory "next";
icl'new_const("=",mk_fun(tv1, mk_fun(tv1, BOOL)));
icl'new_const("„",mk_fun(mk_fun(tv1,BOOL),BOOL));
icl'new_const("ƒ",mk_fun(mk_fun(tv1,BOOL),BOOL));
icl'new_const("Š",mk_fun(BOOL,mk_fun(BOOL,BOOL)));
icl'new_const("€",mk_fun(BOOL,mk_fun(BOOL,BOOL)))
	handle _ => mk_t;
icl'new_const("",mk_fun(BOOL,mk_fun(BOOL,BOOL)))
	handle _ => mk_t;
icl'new_const("Œ",mk_fun(BOOL,BOOL))
	handle _ => mk_t;
icl'open_theory "yet_again";

store_mt_results mt_run [ 
	("icl'new_defn 1",
	dest_thm o icl'new_defn,
	(["True"],"True",mk_t),
	([],mk_‚(mk_const("True",BOOL),mk_t))),
	("icl'new_defn 2",
	dest_thm o icl'new_defn,
	(["False"],"False",mk_f),
	([],mk_‚(mk_const("False",BOOL),mk_f)))
	];
print_ti(icl'get_theory_info "-");
store_mt_results mt_run_fail [
	("icl'new_defn 6031",
	icl'new_defn,
	([],"True1",mk_t),
	gen_fail_msg "icl'new_defn" 6031 []),
	("icl'new_defn 6048",
	icl'new_defn,
	(["x"],"Rubbish",mk_var("v",mk_type("RUBBISH",[]))),
	gen_fail_msg "icl'new_defn" 6048 ["yet_again"]),
	("icl'new_defn 6049",
	icl'new_defn,
	(["True"],"True",mk_t),
	gen_fail_msg "icl'new_defn" 6049 ["True"]),
	("icl'new_defn 6049",
	icl'new_defn,
	(["0"],"0",N0),
	gen_fail_msg "icl'new_defn" 6049 ["0"]),
	("icl'new_defn 6051",
	icl'new_defn,
	(["True"],"True1",mk_t),
	gen_fail_msg "icl'new_defn" 6051 ["True","yet_again"]),
	("icl'new_defn 6058",
	icl'new_defn,
	(["Maybe1"],"Maybe1",mk_ƒ(vtv1,mk_eq(vtv1,vtv1))),
	gen_fail_msg "icl'new_defn" 6058 ["'tv1"]),
	("icl'new_defn 6059",
	icl'new_defn,
	(["Maybe"],"Maybe",v1),
	gen_fail_msg "icl'new_defn" 6059 ["v1"])
	];

val zero_def = icl'new_defn (["ZeRo"],"ZeRo",N0);
val ZeRo = mk_const("ZeRo",†);
print_ti(icl'get_theory_info "-");
icl'delete_extension ();
print_ti(icl'get_theory_info "-");
=TEX
\subsection{Type Definitions}
=SML
icl'new_const("TypeDefn",mk_fun(mk_fun(tv1,BOOL),
	mk_fun(mk_fun(tv'2,tv1),BOOL)));
val Tv1Pred = icl'new_const("Tv1Pred",mk_fun(tv1,BOOL));

val etype_ax = icl'new_axiom(["etype_ax"],
	simple_mk_„(vtv1,mk_comb(Tv1Pred,vtv1)));

local val x= mk_var("x",tv'2)
in
val etype2_exax = icl'new_axiom(["etype2_exax"],
	simple_mk_„(x,mk_comb(icl'inst [] [(tv'2,"'tv1")]Tv1Pred,x)))
end;
val etype_def = icl'new_type_defn(["ETYPE"], "ETYPE", 
	["'tv1"], etype_ax);
val etype2_def = icl'new_type_defn( [ "ETYPE2"], "ETYPE2", ["'2"], etype2_exax);
print_ti(icl'get_theory_info "-");
let
	fun f t1 t2 = mk_var("f",mk_fun(t1,t2));
in
store_mt_results mt_run [ 
	("icl'new_type_defn 1",
	dest_thm,
	etype_def,
	([], mk_„(f (mk_type("ETYPE",[tv1])) tv1,
		list_mk_comb(
		mk_const("TypeDefn",mk_fun(mk_fun(tv1,BOOL),
			mk_fun(mk_fun(mk_type("ETYPE",[tv1]),tv1),BOOL))),
		[icl'inst [] [] Tv1Pred,f (mk_type("ETYPE",[tv1])) tv1])))),
	("icl'new_type_defn 2",
	dest_thm,
	etype2_def,
	([], mk_„(f (mk_type("ETYPE2",[tv'2])) (tv'2),
		list_mk_comb(
		mk_const("TypeDefn",mk_fun(mk_fun(tv'2,BOOL),
			mk_fun(mk_fun(mk_type("ETYPE2",[tv'2]),tv'2),BOOL))),
		[icl'inst [] [(tv'2,"'tv1")] Tv1Pred,
		f (mk_type("ETYPE2",[tv'2])) (tv'2)]))))
	]
end;
val etype_ax_6054 = icl'new_axiom(["etype_ax_6054"], mk_t);
val etype_ax_6055 = icl'new_axiom(["etype_ax_6055"], 
	mk_„(mk_var("x",tv1),mk_t));
val etype_ax_6056 = icl'new_axiom(["etype_ax_6056"], 
	mk_„(mk_var("x",tv1),mk_comb(mk_var("p",mk_fun(tv1,BOOL)), mk_var("x",tv1))));
val etype_ax_6080 = icl'new_axiom(["etype_ax_6080"], 
	mk_„(mk_var("x",tv1),mk_comb(mk_const("Œ",mk_fun(BOOL,BOOL)), mk_t)));
store_mt_results mt_run_fail [
	("icl'new_type_defn 6031",
	icl'new_type_defn,
	([], "ETYPE1", ["'tv1"], etype_ax),
	gen_fail_msg "icl'new_type_defn" 6031 []),
	("icl'new_type_defn 6045",
	icl'new_type_defn,
	(["ETYPE1"], "ETYPE", ["'tv1"], etype_ax),
	gen_fail_msg "icl'new_type_defn" 6045 ["ETYPE"]),
	("icl'new_type_defn 6052",
	icl'new_type_defn,
	(["ETYPE"], "ETYPE1", ["'tv1"], etype_ax),
	gen_fail_msg "icl'new_type_defn" 6052 ["ETYPE","yet_again"]),
	("icl'new_type_defn 6053",
	icl'new_type_defn,
	(["ETYPE1"], "ETYPE1", ["'tv1"], icl'asm_rule mk_t),
	gen_fail_msg "icl'new_type_defn" 6053 []),
	("icl'new_type_defn 6054",
	icl'new_type_defn,
	(["ETYPE1"], "ETYPE1", ["'tv1"], etype_ax_6054),
	gen_fail_msg "icl'new_type_defn" 6054 []),
	("icl'new_type_defn 6055",
	icl'new_type_defn,
	(["ETYPE1"], "ETYPE1", ["'tv1"], etype_ax_6055),
	gen_fail_msg "icl'new_type_defn" 6055 []),
	("icl'new_type_defn 6056",
	icl'new_type_defn,
	(["ETYPE1"], "ETYPE1", ["'tv1"], etype_ax_6056),
	gen_fail_msg "icl'new_type_defn" 6056 ["p"]),
	("icl'new_type_defn 6057",
	icl'new_type_defn,
	(["ETYPE1"], "ETYPE1", ["'not_there"], etype_ax),
	gen_fail_msg "icl'new_type_defn" 6057 ["'tv1"]),
	("icl'new_type_defn 6079",
	icl'new_type_defn,
	(["ETYPE1"], "ETYPE1", ["'tv1","'tv1"], etype_ax),
	gen_fail_msg "icl'new_type_defn" 6079 ["'tv1"]),	("icl'new_type_defn 6080",
	icl'new_type_defn,
	(["ETYPE1"], "ETYPE1", ["'tv1"], etype_ax_6080),
	gen_fail_msg "icl'new_type_defn" 6080 [])
	];
store_mt_results mt_run_error [
	("icl'new_type_defn 6036",
	icl'new_type_defn,
	( ["rubbish"], "rubbish", [], thy_deleted_thm),
	gen_fail_msg "icl'new_type_defn" 6036 ["to_be_deleted",string_of_int tdb_index])
	];

store_mt_results mt_run [("icl'open_theory 3 e",
	icl'open_theory,
	"min",
	([],[next_index, next_index+2]))];
store_mt_results mt_run_fail [
	("icl'new_type_defn 6034",
	icl'new_type_defn,
	( [ "rubbish"], "BOOL", [], etype2_exax),
	gen_fail_msg "icl'new_type_defn" 6034 ["BOOL"])
	];

store_mt_results mt_run [("icl'open_theory 4 f",
	icl'open_theory,
	"yet_again",
	([next_index,next_index+2],[]))];
=TEX
\subsection{icl'new\_specification}
=SML
val so_isso_axiom = icl'new_axiom(["so_isso_axiom"],
	simple_list_mk_„([vSo,vIsSo],mk_Š(vSo,vIsSo)));
val so_isso_def = icl'new_specification (["So","IsSo"],2,so_isso_axiom);
store_mt_results mt_run [ 
	("icl'new_specification",
	dest_thm,
	so_isso_def,
	([],mk_Š(So,IsSo)))
	];
val spec_ax_6016 = icl'new_axiom(["spec_ax_6016"],
	list_mk_„([mk_var("x",BOOL),mk_var("x",BOOL)],
		mk_€(mk_var("x",BOOL),mk_var("x",BOOL))));
val spec_ax_6051 = icl'new_axiom(["spec_ax_6051"],
	mk_„(mk_var("x",BOOL),mk_var("x",BOOL)));
val spec_ax_6056 = icl'new_axiom(["spec_ax_6056"],
	mk_„(mk_var("x",BOOL),mk_eq(mk_var("x",BOOL),v1)));
val spec_ax_6061 = icl'new_axiom(["spec_ax_6061"],
	mk_„(mk_var("x",BOOL),mk_eq(mk_var("x",BOOL),
		mk_ƒ(mk_var("y",tv1), mk_t))));
val spec_ax_6081 = icl'new_axiom(["spec_ax_6081"],
	list_mk_„([mk_var("y",tv'2),mk_var("x",BOOL)],
		mk_€(mk_var("x",BOOL),mk_var("x",BOOL))));
store_mt_results mt_run_fail [
	("icl'new_specification 6016",
	icl'new_specification,
	(["x1","x2"],2,spec_ax_6016),
	gen_fail_msg "icl'new_specification" 6016 ["x"]),
	("icl'new_specification 6031",
	icl'new_specification,
	([],2,so_isso_axiom),
	gen_fail_msg "icl'new_specification" 6031 []),
	("icl'new_specification 6044",
	icl'new_specification,
	(["nowhere"],0,so_isso_axiom),
	gen_fail_msg "icl'new_specification" 6044 []),
	("icl'new_specification 6049",
	icl'new_specification,
	(["Soa","IsSoa"],2,so_isso_axiom),
	gen_fail_msg "icl'new_specification" 6049 ["So"]),
	("icl'new_specification 6051",
	icl'new_specification,
	(["So","IsSo"],1,spec_ax_6051),
	gen_fail_msg "icl'new_specification" 6051 ["IsSo","yet_again"]),
	("icl'new_specification 6053",
	icl'new_specification,
	(["So","IsSo"],2,icl'asm_rule mk_t),
	gen_fail_msg "icl'new_specification" 6053 []),
	("icl'new_specification 6056",
	icl'new_specification,
	(["x"],1,spec_ax_6056),
	gen_fail_msg "icl'new_specification" 6056 ["v1"]),
	("icl'new_specification 6060",
	icl'new_specification,
	(["Some"],3,so_isso_axiom),
	gen_fail_msg "icl'new_specification" 6060 ["3"]),
	("icl'new_specification 6061",
	icl'new_specification,
	(["x"],1,spec_ax_6061),
	gen_fail_msg "icl'new_specification" 6061 ["'tv1"]),
	("icl'new_specification 6081",
	icl'new_specification,
	(["x"],2,spec_ax_6081),
	gen_fail_msg "icl'new_specification" 6081 [])
	];
store_mt_results mt_run_error [
	("icl'new_specification 6036",
	icl'new_specification,
	([],2,thy_deleted_thm),
	gen_fail_msg "icl'new_specification" 6036 ["to_be_deleted",string_of_int tdb_index])
	];
store_mt_results mt_run [("icl'open_theory 1 h",
	icl'open_theory,
	"next",
	([],[next_index+2]))];
local
	val So = mk_var("So",BOOL);
	val IsSo = mk_var("IsSo",BOOL)
in
	val so_isso_axiom1 = icl'new_axiom(["so_isso_axiom"],
		simple_list_mk_„([So,IsSo],mk_Š(So,IsSo)));
end;
store_mt_results mt_run_fail [
	("icl'new_specification 6063",
	icl'new_specification,
	(["Soa","IsSoa"],2,so_isso_axiom1),
	gen_fail_msg "icl'new_specification" 6063 ["So"])
	];
=TEX
\subsection{Miscellaneous}
=SML
store_mt_results mt_run [("icl'open_theory 4 h",
	icl'open_theory,
	"yet_again",
	([next_index+2],[]))];

store_mt_results mt_run [("icl'open_theory 2 e",
	icl'open_theory,
	"another",
	([next_index+1],[next_index,next_index+2]))];
val NEWTYPE = icl'new_type("NEWTYPE",1);
val NewThing = icl'new_const("NewThing",NEWTYPE);
store_mt_results mt_run [("icl'open_theory 4 i",
	icl'open_theory,
	"yet_again",
	([next_index,next_index+2],[next_index+1]))];
=TEX
\subsection{icl'new\_parent}
=SML
store_mt_results mt_run_fail [
	("icl'list_save_thm 6038",
	icl'list_save_thm,
	(["new_parent_test"],icl'asm_rule(mk_eq(NewThing, NewThing))),
	gen_fail_msg "icl'list_save_thm" 6038 [])
	];
store_mt_results mt_run [ 
	("icl'new_parent 1",
	icl'new_parent,
	"another",
	[next_index+1])
	];
store_mt_results mt_run_fail [
	("icl'new_parent 6035",
	icl'new_parent,
	"rubbish",
	gen_fail_msg "icl'new_parent" 6035 ["rubbish"])
	];
store_mt_results mt_run [ 
	("icl'new_parent 2",
	dest_thm o icl'list_save_thm,
	(["new_parent_test"],icl'asm_rule(mk_eq(NewThing, NewThing))),
	([mk_eq(NewThing, NewThing)],mk_eq(NewThing, NewThing)))
	];

print_hierarchy();
store_mt_results mt_run [("icl'open_theory 3 f",
	icl'open_theory,
	"min",
	([],[next_index,next_index+1, next_index+2]))];
val test_index = icl'new_theory "test";
store_mt_results mt_run [("icl'open_theory 5 a",
	icl'open_theory,
	"test",
	([test_index],[]))];
val F' = icl'new_const("F",UNIT);
store_mt_results mt_run [("icl'open_theory 4 j",
	icl'open_theory,
	"yet_again",
	([next_index,next_index+1,next_index+2],[test_index]))];
store_mt_results mt_run_fail [
	("icl'new_parent 6067",
	icl'new_parent,
	"test",
	gen_fail_msg "icl'new_parent" 6067 ["test"]),
	("icl'new_parent 6082",
	icl'new_parent,
	"min",
	gen_fail_msg "icl'new_parent" 6082 ["min"])
	];

store_mt_results mt_run [("icl'open_theory 3 g",
	icl'open_theory,
	"min",
	([],[next_index,next_index+1,next_index+2]))];
store_mt_results mt_run_fail [
	("icl'new_parent 6084",
	icl'new_parent,
	"yet_again",
	gen_fail_msg "icl'new_parent" 6084 ["yet_again"])
	];
=TEX
\subsection{icl'get\_theory et al}
=SML
icl'get_theory "min";
store_mt_results mt_run_fail [
	("icl'get_theory 6035",
	icl'get_theory,
	"rubbish",
	gen_fail_msg "icl'get_theory" 6035 ["rubbish"])
	];
store_mt_results mt_run [ 
	("get_current_theory_status",
	get_current_theory_status,
	(),
	TSNormal)
	];
=TEX
\section{INFERENCE RULES}
Test scopes:
=SML
icl'open_theory "yet_again";
val Deleted = icl'new_const ("Deleted",BOOL);
val const_deleted_thm = icl'asm_rule (mk_eq(p1,q1));
val side_effect = icl'delete_extension();
val side_effect = icl'new_theory "out_of_scope_mdt006";
val side_effect = icl'open_theory "out_of_scope_mdt006";
val out_of_scope_thm = icl'asm_rule (mk_eq(p1,q1));
val side_effect = icl'open_theory "yet_again";
val del_theory_index = string_of_int(icl'new_theory "deleted_theory_mdt006");
val side_effect = icl'open_theory "deleted_theory_mdt006";
val deleted_thm = icl'asm_rule (mk_eq(p1,q1));
val side_effect = icl'open_theory "yet_again";
val side_effect = icl'delete_theory "deleted_theory_mdt006";

val p_eq_q_thm = icl'asm_rule (mk_eq(p1,q1));
val pq_thm = icl'asm_rule (exists_p_q);
val pq_ax = icl'new_axiom(["pq_ax"], exists_p_q);
val t_eq_f = icl'asm_rule (mk_eq(mk_t,mk_f));
val q_eq_F = icl'new_axiom(["q_eq_F"],(mk_eq(qB,mk_f)));
val so_axiom = icl'new_axiom(["so_axiom"],So);
val † = icl'new_type("†",0) handle _ => †;
val tDiv = mk_const("Div",mk_fun(†,mk_fun(†,†)));
val tMod = mk_const("Mod",mk_fun(†,mk_fun(†,†)));
val Suc = icl'new_const("Suc",mk_fun(†, †))
	handle _ => mk_const("Suc",mk_fun(†, †));
val strip_€_T_conv : CONV = ( fn (tm : TERM) =>
	if is_€ tm
	then let val (p,q) = dest_€ tm
		in
		if q = mk_t
		then icl'asm_rule(mk_eq (tm, p))
		else fail "strip_€_T_conv" 0 []
	end
	else fail "strip_€_T_conv" 0 []
);
val t_def = icl'new_axiom(["t_def"],
	mk_eq(mk_t,mk_eq(mk_abs(xB,xB),mk_abs(xB,xB))));
=TEX
\subsection{Valid Theorems}
=SML
store_mt_results mt_run[
	("valid_thm 1",
	valid_thm,
	pq_thm,
	true),
	("valid_thm 2",
	valid_thm,
	const_deleted_thm,
	false),
	("valid_thm 3",
	valid_thm,
	out_of_scope_thm,
	false),
	("valid_thm 4",
	valid_thm,
	deleted_thm,
	false)
	];
=TEX
\section{THE TESTS - PRIMITVES AND BUILT-IN}
The tests proper:
\subsection{icl'subst\_rule}
=SML
store_mt_results mt_run_fail[
	("icl'subst_rule 6001 1",
	icl'subst_rule [] (exists_p_q1),
	pq_thm,
	gen_fail_msg "icl'subst_rule" 6001 []),
	("icl'subst_rule 6001 2",
	icl'subst_rule [(t_eq_f, qB)] (mk_eq(mk_t,qB)),
	t_eq_f,
	gen_fail_msg "icl'subst_rule" 6001 [])
	];
store_mt_results mt_run_error [
	("icl'subst_rule 6036 1",
	icl'subst_rule [] exists_p_q,
	deleted_thm,
	gen_fail_msg "icl'subst_rule" 6036 ["deleted_theory_mdt006",del_theory_index]),
	("icl'subst_rule 6065 1",
	icl'subst_rule [] exists_p_q,
	const_deleted_thm,
	gen_fail_msg "icl'subst_rule" 6065 ["yet_again"]),
	("icl'subst_rule 6066 1",
	icl'subst_rule [] exists_p_q,
	out_of_scope_thm,
	gen_fail_msg "icl'subst_rule" 6066 ["out_of_scope_mdt006"]),
	("icl'subst_rule 6036 2",
	icl'subst_rule [(deleted_thm, q1)] (mk_eq(mk_t,mk_f)),
	t_eq_f,
	gen_fail_msg "icl'subst_rule" 6036 ["deleted_theory_mdt006",del_theory_index]),
	("icl'subst_rule 6065 2",
	icl'subst_rule [(const_deleted_thm, q1)] (mk_eq(mk_t,mk_f)),
	t_eq_f,
	gen_fail_msg "icl'subst_rule" 6065 ["yet_again"]),
	("icl'subst_rule 6066 2",
	icl'subst_rule [(out_of_scope_thm, q1)] (mk_eq(mk_t,mk_f)),
	t_eq_f,
	gen_fail_msg "icl'subst_rule" 6066 ["out_of_scope_mdt006"])
	];

store_mt_results mt_run_fail [
	("icl'subst_rule 6002",
	icl'subst_rule,
	[(icl'asm_rule mk_t, pB)],
	gen_fail_msg "icl'subst_rule" 6002 []),
	("icl'subst_rule 6003",
	icl'subst_rule,
	[(t_def, mk_t)],
	gen_fail_msg "icl'subst_rule" 6003 []),
	("icl'subst_rule 6029",
	icl'subst_rule,
	[(t_def, (mk_var("q",†)))],
	gen_fail_msg "icl'subst_rule" 6029 ["q"])
	];

store_mt_results mt_run [("icl'subst_rule_1",
	dest_thm o icl'subst_rule [] exists_p_q,
	pq_thm,
	dest_thm pq_thm),
	("icl'subst_rule_2",
	dest_thm o icl'subst_rule [] exists_p1_q,
	pq_thm,
	([exists_p_q],exists_p1_q)),
	("icl'subst_rule_3",
	dest_thm o icl'subst_rule [(t_eq_f, qB)] (mk_eq(qB,mk_f)),
	t_eq_f,
	([(mk_eq(mk_t,mk_f))],mk_‚(mk_f,mk_f))),
	("icl'subst_rule_4",
	dest_thm o icl'subst_rule [(t_def, qB)] (mk_eq(qB,mk_f)),
	t_eq_f,
	([(mk_eq(mk_t,mk_f))],
	mk_eq(mk_eq(mk_abs(xB,xB),mk_abs(xB,xB)),mk_f)))];

=TEX
\subsection{icl'simple\_abs\_rule}
=SML
store_mt_results mt_run [("icl'simple_abs_rule",
	dest_thm o icl'simple_abs_rule qB,
	q_eq_F,
	([],mk_eq(mk_abs(qB,qB),mk_abs(qB,mk_f))))
	];

store_mt_results mt_run_fail[
	("icl'simple_abs_rule 6004",
	icl'simple_abs_rule mk_t,
	q_eq_F,
	gen_fail_msg "icl'simple_abs_rule" 6004 []),
	("icl'simple_abs_rule 6005",
	icl'simple_abs_rule qB,
	icl'asm_rule (mk_eq(qB,mk_f)),
	gen_fail_msg "icl'simple_abs_rule" 6005 ["q"]),
	("icl'simple_abs_rule 6025",
	icl'simple_abs_rule qB,
	pq_ax,
	gen_fail_msg "icl'simple_abs_rule" 6025 [])
	];
store_mt_results mt_run_error [
	("icl'simple_abs_rule 6036",
	icl'simple_abs_rule qB,
	deleted_thm,
	gen_fail_msg "icl'simple_abs_rule" 6036 ["deleted_theory_mdt006",del_theory_index]),
	("icl'simple_abs_rule 6065",
	icl'simple_abs_rule qB,
	const_deleted_thm,
	gen_fail_msg "icl'simple_abs_rule" 6065 ["yet_again"]),
	("icl'simple_abs_rule 6066",
	icl'simple_abs_rule qB,
	out_of_scope_thm,
	gen_fail_msg "icl'simple_abs_rule" 6066 ["out_of_scope_mdt006"])
	];
=TEX
\subsection{icl'inst\_type\_rule}
=SML
store_mt_results mt_run [("icl'inst_type_rule_1",
	dest_thm o icl'inst_type_rule [(BOOL, tva)],
	pq_ax,
	([],exists_p_q)),
	("icl'inst_type_rule_2",
	dest_thm o icl'inst_type_rule [(BOOL, tv'1)],
	pq_ax,
	([],exists_pB_q))
	];

store_mt_results mt_run_fail [
	("icl'inst_type_rule 6006",
	icl'inst_type_rule [(BOOL, tva)],
	(icl'asm_rule (mk_eq(qa,qa))),
	gen_fail_msg "icl'inst_type_rule" 6006 ["'a"]),
	("icl'inst_type_rule 6007",
	icl'inst_type_rule [(BOOL, BOOL)],
	pq_ax,
	gen_fail_msg "icl'inst_type_rule" 6007 [])
	];
store_mt_results mt_run_error [
	("icl'inst_type_rule 6036",
	icl'inst_type_rule [(BOOL, tva)],
	deleted_thm,
	gen_fail_msg "icl'inst_type_rule" 6036 ["deleted_theory_mdt006",del_theory_index]),
	("icl'inst_type_rule 6065",
	icl'inst_type_rule [(BOOL, tva)],
	const_deleted_thm,
	gen_fail_msg "icl'inst_type_rule" 6065 ["yet_again"]),
	("icl'inst_type_rule 6066",
	icl'inst_type_rule [(BOOL, tva)],
	out_of_scope_thm,
	gen_fail_msg "icl'inst_type_rule" 6066 ["out_of_scope_mdt006"])
	];
=TEX
\subsection{icl'Š\_intro}
=SML
store_mt_results mt_run [
	("icl'Š_intro 1",
	dest_thm o icl'Š_intro v1,
	pq_ax,
	([],mk_Š(v1,exists_p_q))),
	("icl'Š_intro 2",
	dest_thm o icl'Š_intro v1,
	icl'asm_rule v1,
	([],mk_Š(v1,v1)))
	];

store_mt_results mt_run_fail [
	("icl'Š_intro 6009",
	icl'Š_intro N1,
	pq_ax,
	gen_fail_msg "icl'Š_intro" 6009 [])
	];
store_mt_results mt_run_error [
	("icl'Š_intro 6036",
	icl'Š_intro v1,
	deleted_thm,
	gen_fail_msg "icl'Š_intro" 6036 ["deleted_theory_mdt006",del_theory_index]),
	("icl'Š_intro 6065",
	icl'Š_intro v1,
	const_deleted_thm,
	gen_fail_msg "icl'Š_intro" 6065 ["yet_again"]),
	("icl'Š_intro 6066",
	icl'Š_intro v1,
	out_of_scope_thm,
	gen_fail_msg "icl'Š_intro" 6066 ["out_of_scope_mdt006"])
	];
=TEX
\subsection{icl'Š\_elim}
=SML
store_mt_results mt_run [("icl'Š_elim_1",
	dest_thm o icl'Š_elim  so_isso_def,
	so_axiom,
	([],IsSo))
	];

store_mt_results mt_run_fail [
	("icl'Š_elim 6010",
	icl'Š_elim so_isso_axiom,
	so_axiom,
	gen_fail_msg "icl'Š_elim" 6010 []),
	("icl'Š_elim 6011",
	icl'Š_elim so_isso_def,
	so_isso_def,
	gen_fail_msg "icl'Š_elim" 6011 [])
	];
store_mt_results mt_run_error [
	("icl'Š_elim 6036 1",
	icl'Š_elim so_isso_def,
	deleted_thm,
	gen_fail_msg "icl'Š_elim" 6036 ["deleted_theory_mdt006",del_theory_index]),
	("icl'Š_elim 6065 1",
	icl'Š_elim so_isso_def,
	const_deleted_thm,
	gen_fail_msg "icl'Š_elim" 6065 ["yet_again"]),
	("icl'Š_elim 6066 1",
	icl'Š_elim so_isso_def,
	out_of_scope_thm,
	gen_fail_msg "icl'Š_elim" 6066 ["out_of_scope_mdt006"]),
	("icl'Š_elim 6036 2",
	icl'Š_elim deleted_thm,
	so_axiom,
	gen_fail_msg "icl'Š_elim" 6036 ["deleted_theory_mdt006",del_theory_index]),
	("icl'Š_elim 6065 2",
	icl'Š_elim const_deleted_thm,
	so_axiom,
	gen_fail_msg "icl'Š_elim" 6065 ["yet_again"]),
	("icl'Š_elim 6066 2",
	icl'Š_elim out_of_scope_thm,
	so_axiom,
	gen_fail_msg "icl'Š_elim" 6066 ["out_of_scope_mdt006"])
	];
=TEX
\subsection{icl'asm\_rule}
=SML
store_mt_results mt_run [
	("icl'asm_rule 1",
	dest_thm o icl'asm_rule,
	mk_const("rubbish",BOOL),
	([mk_const("rubbish",BOOL)],mk_const("rubbish",BOOL)))
	];

store_mt_results mt_run_fail [
	("icl'asm_rule 6009",
	icl'asm_rule,
	N0,
	gen_fail_msg "icl'asm_rule" 6009 [])
	];
=TEX
\subsection{icl'refl\_conv}
=SML
store_mt_results mt_run [
	("icl'refl_conv 1",
	dest_thm o icl'refl_conv,
	mk_const("rubbish",BOOL),
	([],mk_eq(mk_const("rubbish",BOOL), mk_const("rubbish",BOOL)))),
	("icl'refl_conv 2",
	dest_thm o icl'refl_conv,
	mk_const("rubbish",†),
	([],mk_eq(mk_const("rubbish",†), mk_const("rubbish",†))))
	];
=TEX
\subsection{icl'simple\_$\beta$\_conv}
=SML
store_mt_results mt_run [
	("icl'simple_%beta%_conv 1",
	dest_thm o icl'simple_%beta%_conv,
	mk_comb(mk_abs(pa,mk_comb(mk_var("f",mk_fun(tva,tv1)),pa)),qa),
	([],mk_eq(mk_comb(mk_abs(pa,mk_comb(
		mk_var("f",mk_fun(tva,tv1)),pa)),
		qa),
		mk_comb(mk_var("f",mk_fun(tva,tv1)), qa)))),
	("icl'simple_%beta%_conv 2",
	dest_thm o icl'simple_%beta%_conv,
	mk_comb(mk_abs(pa,mk_abs(qa,mk_comb(mk_comb(mk_var("f",
		mk_fun(tva,mk_fun(tva,tv1))),
		pa),qa))),qa),
	([],mk_eq(mk_comb(mk_abs(pa,mk_abs(qa,mk_comb(mk_comb(mk_var("f",
		mk_fun(tva,mk_fun(tva,tv1))),
		pa),qa))),qa),
	mk_abs(qa',mk_comb(mk_comb(mk_var("f",
		mk_fun(tva,mk_fun(tva,tv1))),
		qa),qa')))))
	];

store_mt_results mt_run_fail [
	("icl'simple_%beta%_conv 6012",
	icl'simple_%beta%_conv,
	mk_abs(pa,mk_abs(qa,mk_comb(mk_comb(mk_var("f",
		mk_fun(tva,mk_fun(tva,tv1))),
		pa),qa))),
	gen_fail_msg "icl'simple_%beta%_conv" 6012 [])
	];
=TEX
\subsection{icl'suc\_conv}
=SML
store_mt_results mt_run [
	("icl'suc_conv 1",
	dest_thm o icl'suc_conv,
	N3,
	([],mk_eq(N3,mk_comb(Suc,N2)))),
	("icl'suc_conv 2",
	dest_thm o icl'suc_conv,
	N0,
	([],mk_eq(N0,mk_const("Zero",†))))
	];

store_mt_results mt_run_fail [
	("icl'suc_conv 6013",
	icl'suc_conv,
	mk_const("Number",†),
	gen_fail_msg "icl'suc_conv" 6013 [])
	];
=TEX
\subsection{icl'string\_conv}
=SML
store_mt_results mt_run [
	("icl'string_conv_1",
	dest_thm o icl'string_conv,
	mk_string "abc",
	([],mk_eq(mk_string "abc",
		list_mk_comb(mk_const("Cons",
			mk_fun(CHAR,mk_fun(STRING,STRING))),
		[mk_char "a", mk_string "bc"])))),
	("icl'string_conv_2",
	dest_thm o icl'string_conv,
	mk_string "",
	([],mk_eq(mk_string "",mk_const("Nil",STRING))))
	];

store_mt_results mt_run_fail [
	("icl'string_conv 6014",
	icl'string_conv,
	N0,
	gen_fail_msg "icl'string_conv" 6014 [])
	];
=TEX
\subsection{icl'char\_conv}
=SML
store_mt_results mt_run [
	("icl'char_conv_1",
	dest_thm o icl'char_conv,
	mk_char "a",
	([],mk_eq(mk_char "a",mk_comb(mk_const("AbsChar",mk_fun(†,CHAR)),
		mk_† 97)))),
	("icl'char_conv_2",
	dest_thm o icl'char_conv,
	mk_char "†",
	([],mk_eq(mk_char "†",
		mk_comb(mk_const("AbsChar",mk_fun(†,CHAR)),
		mk_† 134))))
	];

store_mt_results mt_run_fail [
	("icl'char_conv 6015",
	icl'char_conv,
	mk_const("he",CHAR),
	gen_fail_msg "icl'char_conv" 6015 [])
	];

=TEX
\subsection{icl'eq\_sym\_rule}
=SML
store_mt_results mt_run[
	("icl'eq_sym_rule_1",
	dest_thm o icl'eq_sym_rule,
	icl'asm_rule(mk_eq(N0,N1)),
	([(mk_eq(N0,N1))],mk_eq(N1,N0))),
	("icl'eq_sym_rule_2",
	dest_thm o icl'eq_sym_rule,
	icl'asm_rule(mk_eq(mk_t,mk_f)),
	([(mk_eq(mk_t,mk_f))],mk_eq(mk_f,mk_t)))
	];

store_mt_results mt_run_fail[
	("icl'eq_sym_rule 6025",
	icl'eq_sym_rule,
	pq_ax,
	gen_fail_msg "icl'eq_sym_rule" 6025 [])
	];
store_mt_results mt_run_error [
	("icl'eq_sym_rule 6036",
	icl'eq_sym_rule,
	deleted_thm,
	gen_fail_msg "icl'eq_sym_rule" 6036 ["deleted_theory_mdt006",del_theory_index]),
	("icl'eq_sym_rule 6065",
	icl'eq_sym_rule,
	const_deleted_thm,
	gen_fail_msg "icl'eq_sym_rule" 6065 ["yet_again"]),
	("icl'eq_sym_rule 6066",
	icl'eq_sym_rule,
	out_of_scope_thm,
	gen_fail_msg "icl'eq_sym_rule" 6066 ["out_of_scope_mdt006"])
	];
=TEX
\subsection{icl'simple\_list\_ƒ\_elim}
=SML
store_mt_results mt_run[
	("icl'simple_list_ƒ_elim_1",
	dest_thm o icl'simple_list_ƒ_elim [mk_f],
	icl'asm_rule (mk_ƒ(v1,mk_Š(v1,mk_t))),
	([(mk_ƒ(v1,mk_Š(v1,mk_t)))],mk_Š(mk_f,mk_t))),
	("icl'simple_list_ƒ_elim_2",
	dest_thm o icl'simple_list_ƒ_elim [v2],
	icl'asm_rule(mk_ƒ(v1,mk_comb(mk_abs(v2,v1),mk_t))),
	([mk_ƒ(v1,mk_comb(mk_abs(v2,v1),mk_t))],
		mk_comb(mk_abs(mk_var("v2'",BOOL),v2),mk_t))),
	("icl'simple_list_ƒ_elim_3",
	dest_thm o icl'simple_list_ƒ_elim [v2,v2],
	icl'asm_rule(list_mk_ƒ([v1,v2],mk_€(v1,v2))),
	([(list_mk_ƒ([v1,v2],mk_€(v1,v2)))],mk_€(v2,v2))),
	("icl'simple_list_ƒ_elim_4",
	dest_thm o icl'simple_list_ƒ_elim [v1,v1],
	icl'asm_rule(list_mk_ƒ([v1,v2],mk_€(v1,v2))),
	([list_mk_ƒ([v1,v2],mk_€(v1,v2))],mk_€(v1,v1))),
	("icl'simple_list_ƒ_elim_5",
	dest_thm o icl'simple_list_ƒ_elim [mk_t,mk_f],
	icl'asm_rule(list_mk_ƒ([v1,v1],v1)),
	([list_mk_ƒ([v1,v1],v1)],mk_f))
	];

store_mt_results mt_run_fail[
	("icl'simple_list_ƒ_elim 6018",
	icl'simple_list_ƒ_elim [mk_t],
	pq_ax,
	gen_fail_msg "icl'simple_list_ƒ_elim" 6018 ["1"]),
	("icl'simple_list_ƒ_elim 6019",
	icl'simple_list_ƒ_elim [N0],
	icl'asm_rule(mk_ƒ(v1,mk_Š(v1,mk_t))),
	gen_fail_msg "icl'simple_list_ƒ_elim" 6019 ["v1 "])
	];
store_mt_results mt_run_error [
	("icl'simple_list_ƒ_elim 6036",
	icl'simple_list_ƒ_elim [v1],
	deleted_thm,
	gen_fail_msg "icl'simple_list_ƒ_elim" 6036 ["deleted_theory_mdt006",del_theory_index]),
	("icl'simple_list_ƒ_elim 6065",
	icl'simple_list_ƒ_elim [v1],
	const_deleted_thm,
	gen_fail_msg "icl'simple_list_ƒ_elim" 6065 ["yet_again"]),
	("icl'simple_list_ƒ_elim 6066",
	icl'simple_list_ƒ_elim [v1],
	out_of_scope_thm,
	gen_fail_msg "icl'simple_list_ƒ_elim" 6066 ["out_of_scope_mdt006"])
	];
=TEX
\subsection{icl'eq\_trans\_rule}
=SML
store_mt_results mt_run[
	("icl'eq_trans_rule_1",
	dest_thm o icl'eq_trans_rule (icl'asm_rule (mk_eq(N0,N1))),
	icl'asm_rule (mk_eq(N1,N2)),
	([(mk_eq(N0,N1)), (mk_eq(N1,N2))],(mk_eq(N0,N2))))
	];

store_mt_results mt_run_fail[
	("icl'eq_trans_rule 6020",
	icl'eq_trans_rule pq_ax,
	icl'asm_rule (mk_eq(N1,N2)),
	gen_fail_msg "icl'eq_trans_rule" 6020 []),
	("icl'eq_trans_rule 6021",
	icl'eq_trans_rule (icl'asm_rule (mk_eq(N1,N2))),
	pq_ax,
	gen_fail_msg "icl'eq_trans_rule" 6021 []),
	("icl'eq_trans_rule 6022 a",
	icl'eq_trans_rule (icl'asm_rule (mk_eq(N0,N1))),
	p_eq_q_thm,
	gen_fail_msg "icl'eq_trans_rule" 6022 []),
	("icl'eq_trans_rule 6022 b",
	icl'eq_trans_rule (icl'asm_rule (mk_eq(N0,N1))),
	icl'asm_rule (mk_eq(N0,N2)),
	gen_fail_msg "icl'eq_trans_rule" 6022 [])
	];
store_mt_results mt_run_error [
	("icl'eq_trans_rule 6036 a",
	icl'eq_trans_rule so_isso_axiom,
	deleted_thm,
	gen_fail_msg "icl'eq_trans_rule" 6036 ["deleted_theory_mdt006",del_theory_index]),
	("icl'eq_trans_rule 6065 a",
	icl'eq_trans_rule so_isso_axiom,
	const_deleted_thm,
	gen_fail_msg "icl'eq_trans_rule" 6065 ["yet_again"]),
	("icl'eq_trans_rule 6066 a",
	icl'eq_trans_rule so_isso_axiom,
	out_of_scope_thm,
	gen_fail_msg "icl'eq_trans_rule" 6066 ["out_of_scope_mdt006"]),
	("icl'eq_trans_rule 6036 b",
	icl'eq_trans_rule deleted_thm,
	so_isso_axiom,
	gen_fail_msg "icl'eq_trans_rule" 6036 ["deleted_theory_mdt006",del_theory_index]),
	("icl'eq_trans_rule 6065 b",
	icl'eq_trans_rule const_deleted_thm,
	so_isso_axiom,
	gen_fail_msg "icl'eq_trans_rule" 6065 ["yet_again"]),
	("icl'eq_trans_rule 6066 b",
	icl'eq_trans_rule out_of_scope_thm,
	so_isso_axiom,
	gen_fail_msg "icl'eq_trans_rule" 6066 ["out_of_scope_mdt006"])
	];
=TEX
\subsection{icl'mk\_comb\_rule}
=SML
store_mt_results mt_run[
	("icl'mk_comb_rule_1",
	dest_thm o icl'mk_comb_rule (icl'asm_rule
		(mk_eq(mk_var("f",mk_fun(†,†)),mk_var("g",mk_fun(†,†))))),
	icl'asm_rule (mk_eq(N1,N2)),
	([mk_eq(mk_var("f",mk_fun(†,†)),mk_var("g",mk_fun(†,†))),(mk_eq(N1,N2))],
		mk_eq(mk_comb(mk_var("f",mk_fun(†,†)),N1),
			mk_comb(mk_var("g",mk_fun(†,†)),N2))))
	];

store_mt_results mt_run_fail[
	("icl'mk_comb_rule 6020",
	icl'mk_comb_rule pq_ax,
	icl'asm_rule (mk_eq(N1,N2)),
	gen_fail_msg "icl'mk_comb_rule" 6020 []),
	("icl'mk_comb_rule 6021",
	icl'mk_comb_rule (icl'asm_rule  (mk_eq(N1,N2))),
	pq_ax,
	gen_fail_msg "icl'mk_comb_rule" 6021 []),
	("icl'mk_comb_rule 6023 a",
	icl'mk_comb_rule (icl'refl_conv mk_t ),
	(icl'asm_rule  (mk_eq(N1,N2))),
	gen_fail_msg "icl'mk_comb_rule" 6023 []),
	("icl'mk_comb_rule 6023 b",
	icl'mk_comb_rule (icl'asm_rule (mk_eq(N0,N1))),
	(icl'asm_rule  (mk_eq(N1,N2))),
	gen_fail_msg "icl'mk_comb_rule" 6023 [])
	];
store_mt_results mt_run_error [
	("icl'mk_comb_rule 6036 a",
	icl'mk_comb_rule so_isso_axiom,
	deleted_thm,
	gen_fail_msg "icl'mk_comb_rule" 6036 ["deleted_theory_mdt006",del_theory_index]),
	("icl'mk_comb_rule 6065 a",
	icl'mk_comb_rule so_isso_axiom,
	const_deleted_thm,
	gen_fail_msg "icl'mk_comb_rule" 6065 ["yet_again"]),
	("icl'mk_comb_rule 6066 a",
	icl'mk_comb_rule so_isso_axiom,
	out_of_scope_thm,
	gen_fail_msg "icl'mk_comb_rule" 6066 ["out_of_scope_mdt006"]),
	("icl'mk_comb_rule 6036 b",
	icl'mk_comb_rule deleted_thm,
	so_isso_axiom,
	gen_fail_msg "icl'mk_comb_rule" 6036 ["deleted_theory_mdt006",del_theory_index]),
	("icl'mk_comb_rule 6065 b",
	icl'mk_comb_rule const_deleted_thm,
	so_isso_axiom,
	gen_fail_msg "icl'mk_comb_rule" 6065 ["yet_again"]),
	("icl'mk_comb_rule 6066 b",
	icl'mk_comb_rule out_of_scope_thm,
	so_isso_axiom,
	gen_fail_msg "icl'mk_comb_rule" 6066 ["out_of_scope_mdt006"])
	];
=TEX
\subsection{icl'‚\_mp\_rule}
=SML
store_mt_results mt_run[
	("icl'‚_mp_rule_1",
	dest_thm o icl'‚_mp_rule t_eq_f,
	icl'asm_rule mk_t,
	([(mk_eq(mk_t,mk_f)),mk_t],mk_f))
	];

store_mt_results mt_run_fail[
	("icl'‚_mp_rule 6024",
	icl'‚_mp_rule t_eq_f,
	(icl'asm_rule mk_f),
	gen_fail_msg "icl'‚_mp_rule" 6024 []),
	("icl'‚_mp_rule 6030",
	icl'‚_mp_rule (icl'asm_rule mk_t),
	t_eq_f,
	gen_fail_msg "icl'‚_mp_rule" 6030 [])
	];
store_mt_results mt_run_error [
	("icl'‚_mp_rule 6036 a",
	icl'‚_mp_rule so_isso_axiom,
	deleted_thm,
	gen_fail_msg "icl'‚_mp_rule" 6036 ["deleted_theory_mdt006",del_theory_index]),
	("icl'‚_mp_rule 6065 a",
	icl'‚_mp_rule so_isso_axiom,
	const_deleted_thm,
	gen_fail_msg "icl'‚_mp_rule" 6065 ["yet_again"]),
	("icl'‚_mp_rule 6066 a",
	icl'‚_mp_rule so_isso_axiom,
	out_of_scope_thm,
	gen_fail_msg "icl'‚_mp_rule" 6066 ["out_of_scope_mdt006"]),
	("icl'‚_mp_rule 6036 b",
	icl'‚_mp_rule deleted_thm,
	so_isso_axiom,
	gen_fail_msg "icl'‚_mp_rule" 6036 ["deleted_theory_mdt006",del_theory_index]),
	("icl'‚_mp_rule 6065 b",
	icl'‚_mp_rule const_deleted_thm,
	so_isso_axiom,
	gen_fail_msg "icl'‚_mp_rule" 6065 ["yet_again"]),
	("icl'‚_mp_rule 6066 b",
	icl'‚_mp_rule out_of_scope_thm,
	so_isso_axiom,
	gen_fail_msg "icl'‚_mp_rule" 6066 ["out_of_scope_mdt006"])
	];

=TEX
\subsection{icl'simple\_ƒ\_intro}
=SML
store_mt_results mt_run[
	("icl'simple_ƒ_intro_1",
	dest_thm o icl'simple_ƒ_intro v1,
	t_eq_f,
	([(mk_eq(mk_t,mk_f))],mk_ƒ(v1,(mk_eq(mk_t,mk_f))))),
	("icl'simple_ƒ_intro_1",
	dest_thm o icl'simple_ƒ_intro qB,
	pq_ax,
	([],mk_ƒ( qB,exists_p_q)))
	];

store_mt_results mt_run_fail[
	("icl'simple_ƒ_intro 6004",
	icl'simple_ƒ_intro mk_t,
	t_eq_f,
	gen_fail_msg "icl'simple_ƒ_intro" 6004 []),
	("icl'simple_ƒ_intro 6005",
	icl'simple_ƒ_intro v1,
	(icl'asm_rule v1),
	gen_fail_msg "icl'simple_ƒ_intro" 6005 ["v1"])
	];
store_mt_results mt_run_error [
	("icl'simple_ƒ_intro 6036",
	icl'simple_ƒ_intro v1,
	deleted_thm,
	gen_fail_msg "icl'simple_ƒ_intro" 6036 ["deleted_theory_mdt006",del_theory_index]),
	("icl'simple_ƒ_intro 6065",
	icl'simple_ƒ_intro v1,
	const_deleted_thm,
	gen_fail_msg "icl'simple_ƒ_intro" 6065 ["yet_again"]),
	("icl'simple_ƒ_intro 6066",
	icl'simple_ƒ_intro v1,
	out_of_scope_thm,
	gen_fail_msg "icl'simple_ƒ_intro" 6066 ["out_of_scope_mdt006"])
	];

=TEX
\subsection{icl'inst\_term\_rule}
=SML
store_mt_results mt_run[
	("icl'inst_term_rule_1",
	dest_thm o icl'inst_term_rule [(mk_t,v1),(mk_f,v2)],
	icl'simple_list_ƒ_elim [v1,v2]
		(icl'asm_rule (list_mk_ƒ([v1,v2],mk_eq(v1,v2)))),
	([(list_mk_ƒ([v1,v2],mk_eq(v1,v2)))],(mk_eq(mk_t,mk_f)))),
	("icl'inst_term_rule_2",
	dest_thm o icl'inst_term_rule [(v2,v1),(v1,v2)],
	icl'simple_list_ƒ_elim [v1,v2]
		(icl'asm_rule (list_mk_ƒ([v1,v2],mk_eq(v1,v2)))),
	([(list_mk_ƒ([v1,v2],mk_eq(v1,v2)))],mk_eq(v2,v1))),
	("icl'inst_term_rule_3",
	dest_thm o icl'inst_term_rule [],
	icl'simple_list_ƒ_elim [v1,v2 ]
		(icl'asm_rule (list_mk_ƒ([v1,v2],mk_eq(v1,v2)))),
	([(list_mk_ƒ([v1,v2],mk_eq(v1,v2)))],mk_eq(v1,v2)))
	];

store_mt_results mt_run_fail[
	("icl'inst_term_rule 6026",
	icl'inst_term_rule [(v2,mk_t)],
	(icl'asm_rule v1),
	gen_fail_msg "icl'inst_term_rule" 6026 []),
	("icl'inst_term_rule 6027",
	icl'inst_term_rule [(N0,v1)],
	(icl'asm_rule v1),
	gen_fail_msg "icl'inst_term_rule" 6027 ["v1"]),
	("icl'inst_term_rule 6028",
	icl'inst_term_rule [(v2,v1)],
	(icl'asm_rule v1),
	gen_fail_msg "icl'inst_term_rule" 6028 ["v1"])
	];
store_mt_results mt_run_error [
	("icl'inst_term_rule 6036",
	icl'inst_term_rule [],
	deleted_thm,
	gen_fail_msg "icl'inst_term_rule" 6036 ["deleted_theory_mdt006",del_theory_index]),
	("icl'inst_term_rule 6065",
	icl'inst_term_rule [],
	const_deleted_thm,
	gen_fail_msg "icl'inst_term_rule" 6065 ["yet_again"]),
	("icl'inst_term_rule 6066",
	icl'inst_term_rule [],
	out_of_scope_thm,
	gen_fail_msg "icl'inst_term_rule" 6066 ["out_of_scope_mdt006"])
	];
=TEX
\subsection{icl'div2\_conv}
=SML
store_mt_results mt_run [
	("icl'div2_conv 1",
	dest_thm o icl'div2_conv,
	list_mk_comb(tDiv,[N7,N2]),
	([],mk_eq(list_mk_comb(tDiv,[N7,N2]),N3))),
	("icl'div2_conv 2",
	dest_thm o icl'div2_conv,
	list_mk_comb(tDiv,[N0,N2]),
	([],mk_eq(list_mk_comb(tDiv,[N0,N2]),N0)))
	];

store_mt_results mt_run_fail [
	("icl'div2_conv 6085 a",
	icl'div2_conv,
	list_mk_comb(tDiv,[N0,N1]),
	gen_fail_msg "icl'div2_conv" 6085 []),
	("icl'div2_conv 6085 b",
	icl'div2_conv,
	list_mk_comb(tDiv,[mk_var("n",†),N2]),
	gen_fail_msg "icl'div2_conv" 6085 [])
	];
=TEX
\subsection{icl'mod2\_conv}
=SML
store_mt_results mt_run [
	("icl'mod2_conv 1",
	dest_thm o icl'mod2_conv,
	list_mk_comb(tMod,[N7,N2]),
	([],mk_eq(list_mk_comb(tMod,[N7,N2]),N1))),
	("icl'mod2_conv 2",
	dest_thm o icl'mod2_conv,
	list_mk_comb(tMod,[N0,N2]),
	([],mk_eq(list_mk_comb(tMod,[N0,N2]),N0)))
	];

store_mt_results mt_run_fail [
	("icl'mod2_conv 6086 a",
	icl'mod2_conv,
	list_mk_comb(tMod,[N0,N1]),
	gen_fail_msg "icl'mod2_conv" 6086 []),
	("icl'mod2_conv 6086 b",
	icl'mod2_conv,
	list_mk_comb(tMod,[mk_var("n",†),N2]),
	gen_fail_msg "icl'mod2_conv" 6086 [])
	];
=TEX
\section{FUTHER THEORY FUNCTIONS}
Test hooks into environments.
=SML
store_mt_results mt_run [ 
	("get_const_type 1",
	get_const_type,
	"5",
	Value †),
	("get_const_type 2",
	get_const_type,
	"",
	Nil),
	("get_const_type 3",
	get_const_type,
	"T",
	Value BOOL),
	("get_const_type 4",
	get_const_type,
	"TorF",
	Nil),
	("get_const_type 5",
	get_const_type,
	"rubbish",
	Nil)
	];
store_mt_results mt_run [ 
	("get_type_arity 1",
	get_type_arity,
	"BOOL",
	Value 0),
	("get_type_arity 2",
	get_type_arity,
	"†",
	Value 0),
	("get_type_arity 3",
	get_type_arity,
	"",
	Nil),
	("get_type_arity 4",
	get_type_arity,
	"‹",
	Value 2),
	("get_type_arity 5",
	get_type_arity,
	"RUBBISH",
	Nil)
	];
=TEX
Test the built in scopes:
=SML
store_mt_results mt_run [ 
	("icl'new_const 1",
	icl'new_const,
	("12a",BOOL),
	mk_const("12a",BOOL)),
	("icl'new_const 2",
	icl'new_const,
	("`12",BOOL),
	mk_const("`12",BOOL))
	];
store_mt_results mt_run_fail [
	("icl'new_const 6049 a",
	icl'new_const,
	("1",BOOL),
	gen_fail_msg "icl'new_const" 6049 ["1"]),
	("icl'new_const 6049 b",
	icl'new_const,
	("123",BOOL),
	gen_fail_msg "icl'new_const" 6049 ["123"]),
	("icl'new_const 6049 c",
	icl'new_const,
	("`a",BOOL),
	gen_fail_msg "icl'new_const" 6049 ["`a"]),
	("icl'new_const 6049 d",
	icl'new_const,
	("\"abc",BOOL),
	gen_fail_msg "icl'new_const" 6049 ["\"abc"])
	];
=TEX
Test the sealing of theories:
=SML
store_mt_results mt_run [("icl'open_theory 1 i",
	icl'open_theory,
	"next",
	([],[next_index+1,next_index+2]))];
icl'seal_hierarchy();
store_mt_results mt_run [("icl'open_theory 1 j",
	icl'open_theory,
	"next",
	([],[]))];
store_mt_results mt_run_fail [
	("icl'seal_hierarchy 1",
	icl'open_theory,
	"min",
	gen_fail_msg "icl'open_theory" 6017 ["min","next"]),
	("icl'seal_hierarchy 2",
	icl'open_theory,
	"another",
	gen_fail_msg "icl'open_theory" 6017 ["another","next"])
	];
store_mt_results mt_run [("icl'open_theory 4 l",
	icl'open_theory,
	"yet_again",
	([next_index+1,next_index+2],[]))];
=TEX
Tests on hierarchies : do after all others, as things are made read only.
=SML
val newhier = icl'new_hierarchy();
print_hierarchy();
store_mt_results mt_run_fail [
	("icl'new_axiom 6071",
	icl'new_axiom,
	(["Truth_axiom1"],mk_t),
	gen_fail_msg "icl'new_axiom" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("icl'new_const 6071",
	icl'new_const,
	("ForT1",BOOL),
	gen_fail_msg "icl'new_const" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("icl'new_type 6071",
	icl'new_type,
	("SOMETHING1",3),
	gen_fail_msg "icl'new_type" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("icl'new_defn 6071",
	icl'new_defn,
	(["True1"],"True1",mk_t),
	gen_fail_msg "icl'new_defn" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("icl'delete_extension 6071",
	icl'delete_extension,
	(),
	gen_fail_msg "icl'delete_extension" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("icl'list_save_thm 6071",
	icl'list_save_thm,
	(["Example1"],icl'asm_rule v1),
	gen_fail_msg "icl'list_save_thm" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("icl'delete_thm 6071",
	icl'delete_thm,
	"Example",
	gen_fail_msg "icl'delete_thm" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("icl'delete_theory 6071",
	icl'delete_theory,
	"test",
	gen_fail_msg "icl'delete_theory" 6071 ["test"])
	];
store_mt_results mt_run_fail [
	("icl'lock_theory 6071",
	icl'lock_theory,
	"yet_again",
	gen_fail_msg "icl'lock_theory" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("icl'new_parent 6071",
	icl'new_parent,
	"another",
	gen_fail_msg "icl'new_parent" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("icl'new_type_defn 6071",
	icl'new_type_defn,
	( [ "ETYPE7"], "ETYPE7", ["'1"], etype_ax),
	gen_fail_msg "icl'new_type_defn" 6071 ["yet_again"])
	];
store_mt_results mt_run_fail [
	("icl'new_specification 6071",
	icl'new_specification,
	(["So1","IsSo1"],2,so_isso_axiom),
	gen_fail_msg "icl'new_specification" 6071 ["yet_again"])
	];
icl'load_hierarchy newhier;
icl'new_theory "another_test";
store_mt_results mt_run_fail [
	("icl'load_hierarchy 6033",
	icl'load_hierarchy,
	newhier,
	gen_fail_msg "icl'load_hierarchy" 6033 [])
	];

=TEX
\subsection{End of Tests}
=SML
summarize_mt_results();
(* PolyML.quit(); *)
=TEX
\section{UNTESTED ERROR MESSAGES}
The following are not tested for various reasons:

\begin{tabular}{| l | p{4.5in} |}\hline
Test & Comment \\ \hline
6072 & This is where a theorem has a duff theory pointer: difficult to recreate. \\
(6033) & Can't easily test whether we can load a hierarchy that
is a superset of the current hierarchies theories. \\ \hline
\end{tabular}
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
=TEX
\end{document}
