=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for the Abstract Data Type $THM$}  %% Mandatory field
\def\TPPheadtitle{Module Tests for the Abstract Data Type $THM$}
\TPPref{DS/FMU/IED/MDT006}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the 
the abstract data type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue 1.1]
First draft version.
\item [Issue 1.2]
Corrected typos, slight improvement to layout.
\item [Issue 1.3]
Changed to match issue 1.9 of \cite{DS/FMU/IED/DTD006}.
\item [Issue 1.4]
Testing corrections made to implementation.
\item [Issue 1.5]
Now reloads ``imp006.sml'' to start off from an empty ``min'' theory.
\item [Issue 1.6,1.7]
Changed to match issue 1.11 of \cite{DS/FMU/IED/DTD006}.
\item [Issue 1.8]
Changed a $list\_mk\_„$ to $list\_simple\_mk\_„$.
\item [Issue 1.8]
Changed a $mk\_„$ to $simple\_mk\_„$.
\end{description}
\subsection{Changes forecast}
Many.
Use of DJK test harness work.
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the the Abstract Data Type $THM$, required by Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The design is in \cite{DS/FMU/IED/DTD006}
and it is
implemented in \cite{DS/FMU/IED/IMP006}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD006},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD006},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP006}.
\subsubsection{Deficiencies}
The coverage of the tests, as called for by the test specification, may currently be incomplete.
\section{UTILITIES}
=SML
PolyML.print_depth 10;
=TEX
Reload the kernel from file, and get the structure opened.
This ensures that theory "min" is fresh.
=SML
local
val dummy = usefile "imp006.sml";
in
open icl'Kernel;
end;
=TEX
We provide a list of diagnostic printing functions. 
Those called $string\_of\_\ldots$ turn objects of various significant types ($TERM$, $THM$, etc)
into strings,
those called $print\_\ldots$ apply $diag\_string$ to the output
of the associated $string\_of\_\ldots$.
=SML
fun âstring_of_typeá (t: TYPE) : string = (
let
	fun aux ty = (
	if is_vartype ty then 
		(" " ^ dest_vartype ty)
	else if is_funtype ty then
		(let val(t1,t2) = dest_funtype ty
		in
		( "(" ^ aux t1 ^ " ‹" ^ aux t2 ^")" )
		end)
	else (let 
		fun aux1 ("‰",[t1,t2]) = (
		"(" ^ aux t1 ^ " ‰" ^ aux t2 ^")"
		) | aux1 ((s,[])) = (
		" " ^ s
		) | aux1 ((s,tyl)) = (
		"((" ^ implode (map ((fn x => x ^", ") o aux) tyl)^ ")" ^ s ^ ")")
		in
			aux1 (dest_type ty)
		end)
	)
in
	(":" ^ aux t)
end);
val âprint_typeá = diag_line o string_of_type;

local
	fun print_simple_dest_term (Comb(t1,t2)) = (
	"Comb (" ^ print_simple_dest_term(simple_dest_term t1) ^", " ^
		print_simple_dest_term(simple_dest_term t2) ^ ")"
) | print_simple_dest_term (Const(s,ty)) = s ^ string_of_type ty
| print_simple_dest_term (Var(s,ty)) = s ^ string_of_type ty
| print_simple_dest_term (Abs(v,b)) = (
	let val (vs,vt) = dest_var v
	in
	" " ^ vs ^ string_of_type vt ^ " Ž " ^ print_simple_dest_term (simple_dest_term b)
	end);
in

fun âstring_of_termá (tm : TERM) = print_simple_dest_term (simple_dest_term tm);

fun âprint_termá (tm: TERM) = diag_line(string_of_term tm);
end;
=TEX
We also provide a pair of functions on $TERM$ that don't give the type information.
=SML
local fun print_simple_dest_term (Comb(t1,t2)) = (
	"(" ^ print_simple_dest_term(simple_dest_term t1) ^ " " ^
		print_simple_dest_term(simple_dest_term t2) ^ ")"
) | print_simple_dest_term (Const(s,ty)) = s
| print_simple_dest_term (Var(s,ty)) = s
| print_simple_dest_term (Abs(v,b)) = (
	let val (vs,vt) = dest_var v
	in
	"( " ^ vs ^ " Ž " ^ print_simple_dest_term (simple_dest_term b) ^")"
	end);
in
	fun âstring_of_term1á (tm: TERM): string = (
		print_simple_dest_term (simple_dest_term tm)
	);

	fun âprint_term1á (tm: TERM): unit = diag_line(string_of_term1 tm);

	fun âstring_of_seqá ((tml , tm): SEQ) : string = (
		format_list string_of_term1 tml ", " ^
		"… " ^ string_of_term1 tm
	);

	fun âprint_seqá (seq: SEQ) : unit = diag_line(string_of_seq seq);
end;

fun âstring_of_thmá (key:string) (them : THM) : string = (
let val {level=level,theory={name=iname,...},sequent=sequent} =
		icl'dest_thm them
	in
		"In theory "^ string_of_int iname ^ 
		", at level "^ string_of_int level ^ 
		", with key "^ key ^
		"\n" ^
		string_of_seq sequent
end);

fun âprint_thmá (key:string) (them : THM) : unit = diag_line(string_of_thm key them);

fun âstring_of_thyá ({name = iname,
		ty_env = ty_env,
		con_env = con_env,
		parents = parents,
		del_levels = del_levels,
		axiom_dict = axiom_dict,
		definition_dict = definition_dict,
		theorem_dict = theorem_dict,
		current_level = current_level,
		user_data = user_data} : THEORY) : string = (
	"Internal name " ^ string_of_int iname ^
	", Current Level " ^ string_of_int current_level^
	", Parents " ^ format_list string_of_int parents ", " ^
	"\n***Types***\n" ^
	implode (map (fn (nm,{arity=arity,level=level}) =>
		("     " ^ nm ^ 
		": arity="^string_of_int arity ^
		", level="^string_of_int level ^ "\n"))
		ty_env) ^
	"***Constants***\n" ^
	implode (map (fn (nm,{ty=ty,level=level}) =>
		("     " ^ nm ^ 
		": ty="^string_of_type ty ^
		", level="^string_of_int level ^ "\n"))
		con_env) ^
	(format_list (Combinators.I)
	(["***Theorems***"] @
	(map (uncurry string_of_thm) theorem_dict) @
	["***Definitions***"] @
	(map (uncurry string_of_thm) definition_dict) @
	["***Axioms***"] @
	(map (uncurry string_of_thm) axiom_dict)) "\n")
);

fun âprint_thyá (thy  : THEORY) : unit = diag_line(string_of_thy thy);

fun âstring_of_tiá ({status : THEORY_STATUS,
	inscope : bool,
	contents : THEORY,
	children : int list,
	name : string}:THEORY_INFO) : string = (
	"Theory " ^ name ^ "\n" ^
	(if inscope then "In Scope, " else "Out of Scope, ") ^
	(case status of
	TSNormal => "Status: Normal, "
	| TSDeleted => "Status: Deleted, "
	| TSLocked => "Status: Locked, "
	| TSAncestor => "Status: Ancestor, ") ^
	"Children:" ^ (format_list string_of_int children ", ") ^ "\n" ^

	string_of_thy contents
);

fun âprint_tiá (ti : THEORY_INFO) : unit = diag_line(string_of_ti ti);

fun âstring_of_hierarchyá (():unit) : string = (
	implode(map (fn (p,q) => ("------ti key: "^p^"------\n" ^
		string_of_ti q ^ "\n"))
	(icl'get_hierarchy ())));

fun âprint_hierarchyá (():unit) : unit = diag_line(string_of_hierarchy ());

=TEX
\section{THE TESTS}
We give rise to various errors, which we don't want 
$usefile$ to halt loading on, so:
=SML
set_flag("usefile_non_stop_mode",true);
=TEX
Our initial hierarchy of (empty) theories:
=SML
icl'new_theory "next";
icl'new_theory "another";
icl'open_theory "next";
icl'new_theory "yet_again";

print_hierarchy ();
=TEX
The tests proper:
=SML
icl'new_type("BOOL",0);
val v1 = mk_var("v1", BOOL);
val v2 = mk_var("v2", BOOL);

icl'get_theory_name 1;
icl'get_theory_name 20;
icl'get_theory_name ~1;

print_ti(icl'get_theory_info "next");
icl'new_type ("†",0);
icl'new_type ("†",0); (* fails *)
print_ti(icl'get_theory_info "next");
val n1 = icl'list_save_thm(["n1"], icl'asm_rule v1);
val n1 = icl'list_save_thm(["n1"], icl'asm_rule v1);
val n1 = icl'list_save_thm([], icl'asm_rule v1); (* fails *)
icl'list_save_thm(["n2"], icl'asm_rule(mk_var("rv",mk_type("rubbish",[])))); (* fails *)
icl'open_theory "another";
icl'list_save_thm(["n2"], icl'asm_rule v1); (* fails *)
icl'open_theory "next";
icl'new_type("‰",2);
icl'new_type("‹",2);
val N0 = mk_† 0;
val N1 = mk_† 1;
val N2 = mk_† 2;
val T = icl'new_const("T",BOOL);
val F = icl'new_const("F",BOOL);
print_ti(icl'get_theory_info "next");
val n2 = icl'list_save_thm(["n2"], n1);
print_ti(icl'get_theory_info "next");
icl'open_theory "min";
icl'new_type("‰",2); (* fails *)
val UNIT = icl'new_type ("UNIT",0);
val Unit = icl'new_const("Unit",UNIT);
print_ti(icl'get_theory_info "min");
icl'open_theory "next";
val AlsoUnit = icl'new_const("AlsoUnit",UNIT);
icl'open_theory "min";
icl'new_const("AlsoUnit",UNIT); (* fails *)
icl'new_definition(["AlsoUnit"],"AlsoUnit", Unit); (* fails *)
icl'open_theory "yet_again";
val n3 = icl'list_save_thm(["n3"], n1);
print_ti(icl'get_theory_info "-");
icl'open_theory "another";
icl'new_type("BOOL",0);
icl'new_type("rubbish",~1); (* fails *)
val T = icl'new_const("T",BOOL);
val F = icl'new_const("F",BOOL);

print_ti(icl'get_theory_info "another");
icl'new_theory "yet_again"; (* fails *)
icl'delete_extension();
print_ti(icl'get_theory_info "-");
val s1 = icl'list_save_thm(["s1"], icl'asm_rule v1);
icl'new_const("F",BOOL);
print_ti(icl'get_theory_info "another");
icl'delete_extension();
icl'delete_extension(); (* fails *)
icl'delete_thm "s1";
icl'delete_extension();
print_ti(icl'get_theory_info "-");
val TorF = icl'new_const("TorF",BOOL);
icl'new_const("TorF",BOOL); (* fails *)
icl'new_const("TypeWrong",mk_type("TYPEWRONG",[])); (* fails *)
print_ti(icl'get_theory_info "-");
icl'delete_extension();
print_ti(icl'get_theory_info "-");
icl'delete_extension();
print_ti(icl'get_theory_info "-");
icl'delete_extension(); (* fails *)

icl'open_theory "yet_again";
icl'open_theory "yet_again";
icl'new_axiom(["truth_axiom"],T);
print_ti(icl'get_theory_info "yet_again");
icl'new_axiom(["truth_axiom"],T); (* fails *)
icl'new_axiom(["not so", "No way!"],F);
icl'new_axiom(["testing"],mk_const("rubbish",BOOL)); (* fails *)
icl'new_axiom(["testing"],mk_comb(mk_var("f",mk_fun(BOOL,BOOL)), T)); 
print_ti(icl'get_theory_info "yet_again");
icl'open_theory "another";
icl'new_axiom(["testing2"],mk_comb(mk_var("f",mk_fun(BOOL,BOOL)), T)); (* fails *)
icl'open_theory "yet_again";
icl'new_axiom(["testing2"],mk_comb(mk_const("f",mk_fun(BOOL,BOOL)), T)); (* fails *)
icl'new_axiom([],T); (* fails *)
icl'new_axiom(["Rubbish"],N0); (* fails *)
let val t = mk_type("rubbish",[])
in
icl'new_axiom(["testing2"],mk_comb(mk_var("f",mk_fun(t,BOOL)), mk_var("x",t)))
end; (* fails *)
icl'lock_theory "yet_again";
icl'new_axiom(["Truth_axiom"],T); (* fails *)
icl'new_const("ForT",BOOL); (* fails *)
icl'new_type("SOMETHING",3); (* fails *)
icl'delete_extension(); (* fails *)
icl'list_save_thm(["Example"],icl'asm_rule v1); (* fails *)
icl'unlock_theory "yet_again";
icl'new_axiom(["Truth_axiom"],T); 
icl'new_const("ForT",BOOL); 
icl'new_type("SOMETHING",3); 
icl'delete_extension();
icl'list_save_thm(["Example"],icl'asm_rule v1);
icl'lock_theory "yet_again";
icl'delete_thm "Example";
icl'unlock_theory "yet_again";
icl'delete_thm "Example";

print_ti(icl'get_theory_info "-");
icl'open_theory "min";
icl'delete_extension();
icl'open_theory "another";
print_ti(icl'get_theory_info "rubbish"); (* fails *)
icl'get_theory_name 0;
icl'get_theory_name 5; (* fails *)
icl'open_theory "rubbish";
icl'open_theory "next";
val tdb_index = icl'new_theory "to_be_deleted";
icl'open_theory "to_be_deleted";
print_ti(icl'get_theory_info "to_be_deleted"); 
val thy_deleted_thm = icl'list_save_thm(["thy_deleted_thm"],
	icl'asm_rule v1);
icl'open_theory "next";
icl'delete_theory "to_be_deleted";
print_ti(icl'get_theory_info "to_be_deleted"); (* fails *)
icl'get_theory_name tdb_index; (* fails *)
print_hierarchy();
icl'open_theory "to_be_deleted"; (* fails *)

icl'delete_theory "to_be_deleted"; (* fails *)
icl'new_theory "to_be_deleted"; (* succeeds! *)
print_ti(icl'get_theory_info "to_be_deleted");
icl'delete_theory "to_be_deleted"; 

icl'delete_theory "min"; (* fails *)
icl'lock_theory "yet_again";
print_ti(icl'get_theory_info "yet_again");
icl'delete_theory "yet_again"; (* fails *)
icl'lock_theory "yet_again"; (* fails *)
icl'unlock_theory "yet_again";
icl'open_theory "yet_again";
icl'delete_theory "yet_again"; (* fails *)
icl'lock_theory "to_be_deleted"; (* fails *)
icl'lock_theory "rubbish"; (* fails *)
icl'unlock_theory "to_be_deleted"; (* fails *)
icl'unlock_theory "rubbish"; (* fails *)
icl'unlock_theory "yet_again"; (* fails *)
print_ti(icl'get_theory_info "next");
icl'duplicate_theory "next" "copy_of_next";
print_ti(icl'get_theory_info "copy_of_next");
icl'duplicate_theory "rubbish" "copy_of_next"; (* fails *)
icl'duplicate_theory "rubbish" "copy_of_rubbish"; (* fails *)
icl'duplicate_theory "to_be_deleted" "copy_of_rubbish";
icl'delete_thm "rubbish";
icl'list_save_thm(["s2"], thy_deleted_thm); (* fails *)
icl'new_definition (["True"],"True",T);
icl'new_definition (["True"],"True1",T); (* fails *)
icl'new_definition (["False"],"False",F);
print_ti(icl'get_theory_info "-");
icl'new_definition (["0"],"0",mk_const("0",†)); (* fails *)
val zero_def = icl'new_definition (["Zero"],"Zero",mk_† 0);
val Zero = mk_const("Zero",†);
print_ti(icl'get_theory_info "-");
icl'delete_extension ();
print_ti(icl'get_theory_info "-");
icl'new_definition ([],"rubbish",mk_const("F",BOOL));
icl'new_definition (["False"],"False",mk_const("F",BOOL));
icl'new_definition (["Somewhere"],"Somewhere",mk_const("Somehow",BOOL));
icl'lock_theory "-";
icl'new_definition (["Somewhere"],"Somewhere",mk_const("False",BOOL));
icl'unlock_theory "-";
icl'new_definition (["Somewhere"],"Somewhere",mk_var("Somehow",BOOL)); (* fails *)
val tv1 = mk_vartype "'1";
val tv2 = mk_vartype "'2";
icl'new_const("Everywhere",tv1);

icl'new_definition (["Somewhere"],"Somewhere",
	mk_comb(
	simple_mk_abs(mk_var("Somehow",tv1),T),
	mk_const("Everywhere",tv1)
		)); (* fails *)
icl'open_theory "next";
icl'new_const("=",mk_fun(tv1, mk_fun(tv1, BOOL)));
icl'new_const("„",mk_fun(mk_fun(tv1,BOOL),BOOL));
icl'new_const("ƒ",mk_fun(mk_fun(tv1,BOOL),BOOL));
icl'new_const("TypeDefinition",mk_fun(mk_fun(tv1,BOOL),
	mk_fun(mk_fun(tv2,tv1),BOOL)));
val Tv1Pred = icl'new_const("Tv1Pred",mk_fun(tv1,BOOL));
icl'open_theory "yet_again";

local val x= mk_var("x",tv1)
in
val etype_exax = icl'new_axiom(["etype_exax"],
	simple_mk_„(x,mk_comb(Tv1Pred,x)))
end;
val etype_def = icl'new_type_definition( [ "ETYPE"], "ETYPE", ["'1"], etype_exax);
val etype_def = icl'new_type_definition( [ "ETYPE"], "ETYPE1", ["'1"], etype_exax);
val etype_def = icl'new_type_definition([], "ETYPEd", ["'1"], etype_exax);
print_thm "" etype_def;
print_ti(icl'get_theory_info "-");
local val x= mk_var("x",tv2)
in
val etype2_exax = icl'new_axiom(["etype2_exax"],
	simple_mk_„(x,mk_comb(icl'inst [] [(tv2,"'1")]Tv1Pred,x)))
end;
val etype2_def = icl'new_type_definition( [ "ETYPE2"], "ETYPE2", ["'2"], etype2_exax);
icl'lock_theory "-";
icl'new_type_definition( [ "ETYPE2a"], "ETYPE2a", ["'2"], etype2_exax); (* fails *)
icl'unlock_theory "-";
icl'new_type_definition( [ "ETYPE2a"], "ETYPE2a", ["'2"], etype2_exax);
icl'new_type_definition( [ "ETYPE2c"], "ETYPE2c", ["'1"], etype2_exax);
icl'new_type_definition( [ "ETYPE2a"], "ETYPE2b", ["'2"], etype2_exax); (* fails *)
icl'new_type_definition( [ "ETYPE2b"], "ETYPE2b", ["'2"], 
	icl'asm_rule(snd(dest_thm etype2_exax))); (* fails *)
icl'new_type_definition( [ "ETYPE2b"], "ETYPE2b", ["'2"], 
	icl'asm_rule(snd(dest_thm etype2_exax))); (* fails *)
local val x= mk_var("x",tv2);
	val y= mk_var("y",tv2)
in
val etype6_exax = icl'new_axiom(["etype6_exax"],
	simple_mk_„(x,mk_comb(icl'inst [] [(tv2,"'1")]Tv1Pred,y)))
end;
icl'new_type_definition( [ "ETYPE6"], "ETYPE6", ["'2"], etype6_exax); (* fails *)

print_ti(icl'get_theory_info "-");
icl'new_type_definition( [ "rubbish"], "BOOL", [], etype2_exax); (* fails *)
icl'open_theory "min";
icl'new_type_definition( [ "rubbish"], "BOOL", [], etype2_exax); (* fails *)
icl'open_theory "yet_again";
icl'new_type_definition( [ "rubbish"], "rubbish", [], thy_deleted_thm); (* fails *)

local val x= mk_var("x",tv2)
in
val etype3_exax = icl'new_axiom(["etype3_exax"],
	simple_mk_ƒ(x,mk_comb(icl'inst [] [(tv2,"'1")]Tv1Pred,x)))
end;
val etype3_def = icl'new_type_definition( [ "ETYPE3"], "ETYPE3", ["'2"], etype3_exax); (* fails *)
local val x= mk_var("x",tv1);
	val y= mk_const("Everywhere",tv1);	
in
val etype4_exax = icl'new_axiom(["etype4_exax"],
	simple_mk_„(x,mk_comb(Tv1Pred,y)))
end;
val etype4_def = icl'new_type_definition( [ "ETYPE4"], "ETYPE4", ["'1"], etype4_exax); (* fails *)
local val x= mk_var("x",tv1);
	val y= mk_const("Everywhere",tv1);	
in
val etype5_exax = icl'new_axiom(["etype5_exax"],
	simple_mk_„(x,T))
end;
val etype5_def = icl'new_type_definition( [ "ETYPE5"], "ETYPE5", ["'1"], etype5_exax); (* fails *)
icl'new_type_definition( [ "ETYPE6"], "ETYPE6", ["'2","'2"], etype2_exax); (* fails *)
icl'new_type_definition( [ "ETYPE8"], "ETYPE8", [], 
	icl'asm_rule(mk_const("rubbish",BOOL))); (* fails *)

icl'open_theory "next";
icl'new_const("Š",mk_fun(BOOL,mk_fun(BOOL,BOOL)));
local
	val So = mk_var("So",BOOL);
	val IsSo = mk_var("IsSo",BOOL)
in
	val so_isso_axiom = icl'new_axiom(["so_isso_axiom"],
		list_simple_mk_„([So,IsSo],mk_Š(So,IsSo)));
end;
icl'open_theory "yet_again";
icl'lock_theory "-";
val so_isso_def = icl'new_specification (["So","IsSo"],2,so_isso_axiom); (* fails *)
icl'unlock_theory "-";
val so_isso_def = icl'new_specification (["So","IsSo"],2,so_isso_axiom);
icl'new_specification (["Soa","IsSoa"],2,so_isso_axiom); (* fails *)
icl'new_specification (["Soa","IsSoa"],2,icl'asm_rule(mk_const("rubbish",BOOL))); (* fails *)
icl'open_theory "next";
icl'new_specification (["Soa","IsSoa"],2,so_isso_axiom); (* fails *)
icl'open_theory "yet_again";
val xx_ax = icl'new_axiom(["xx_ax"],simple_mk_„(v1,simple_mk_„(v1,T)));
icl'new_specification (["X"],2,xx_ax);
local val x = mk_var("x",tv1);
	val y = mk_var("y",tv2);
in
val xy_ax = icl'new_axiom(["xy_ax"],simple_mk_„(x,simple_mk_„(y,T)))
end;
icl'new_specification (["X","Y"],2,xy_ax);
local val x = mk_var("x",tv1);
in
val v1_ax = icl'new_axiom(["v1_ax"],simple_mk_„(v1,
	simple_mk_ƒ(x,mk_eq(x,x))))
end;
icl'new_specification (["V1"],1,v1_ax);


print_ti(icl'get_theory_info "-");
val x_def = icl'new_specification (["x"],1,etype5_exax);
print_ti(icl'get_theory_info "-");
icl'new_specification ([],1,etype5_exax); (* fails *)
icl'new_specification (["x1"],0,etype5_exax); (* fails *)
icl'new_specification (["x1"],1,etype5_exax); (* fails *)
local val y = mk_var("y",BOOL)
in
val y_ax = icl'new_axiom(["y_ax"],simple_mk_„(y,T))
end;
icl'new_specification (["x"],1,y_ax); (* fails *)
icl'new_specification (["x2"],1,icl'asm_rule(simple_mk_„(v1,T))); (* fails *)
icl'new_specification (["x1"],1,etype3_exax); (* fails *)
local val p= mk_var("p",tv1);
	val q= mk_var("q",BOOL);	
in
val pq_ax = icl'new_axiom(["pq_ax"],simple_mk_„(p,q))
end;
icl'new_specification (["x1"],1,pq_ax); (* fails *)
icl'new_specification (["x3"],1,thy_deleted_thm);
icl'open_theory "another";
val NEWTYPE = icl'new_type("NEWTYPE",1);
val NewThing = icl'new_const("NewThing",NEWTYPE);
icl'open_theory "yet_again";
icl'list_save_thm(["x3"],icl'asm_rule(mk_eq(NewThing, NewThing))); (* fails *)
icl'lock_theory "-";
icl'new_parent "another"; (* fails *)
icl'unlock_theory "-";
icl'new_parent "another";
icl'new_parent "rubbish";
icl'list_save_thm(["x3"],icl'asm_rule(mk_eq(NewThing, NewThing))); (* succeeds *)

print_hierarchy();
icl'open_theory "min";
icl'new_theory "test";
icl'open_theory "test";
val F' = icl'new_const("F",UNIT);
icl'open_theory "yet_again";
icl'new_parent "test"; (* fails *)
icl'new_parent "min"; (* fails *)
icl'open_theory "min";
icl'new_parent "yet_again"; (* fails *)
icl'get_theory "min";
icl'get_theory "rubbish";
get_current_theory_status();
icl'lock_theory "-";
get_current_theory_status();
icl'unlock_theory "-";


let val p= mk_var("p",tv1);
	val q= mk_var("q",BOOL);	
in
print_thm "" (icl'subst_rule [] (simple_mk_„(p,q)) pq_ax)
end; (* fails - not in scope *)
icl'open_theory "yet_again";
val DeleteIt = icl'new_const("DeleteIt",BOOL);
val level_deleted_thm = icl'asm_rule DeleteIt;
icl'delete_extension();

let val p= mk_var("p",tv1);
	val q= mk_var("q",BOOL);	
in
print_thm "" (icl'subst_rule [] (simple_mk_„(p,q)) pq_ax)
end;
let val p1= mk_var("p1",tv1);
	val q= mk_var("q",BOOL);	
in
print_thm "" (icl'subst_rule [] (simple_mk_„(p1,q)) pq_ax)
end;
let val p1= mk_var("p1",tv1);
	val q1 = mk_var("q1",BOOL);	
in
print_thm "" (icl'subst_rule [] (simple_mk_„(p1,q1)) pq_ax)
end; (* fails *)
val T_eq_F = icl'new_axiom(["silly"],mk_eq(T,F));

let val q = mk_var("q",BOOL);	
in
print_thm "" (icl'subst_rule [(T_eq_F, q)] (mk_eq(q,F)) T_eq_F)
end;
let val q = mk_var("q",BOOL);	
in
print_thm "" (icl'subst_rule [(icl'asm_rule(mk_eq(T,F)), q)] (mk_eq(q,F)) T_eq_F)
end;
let val q = mk_var("q",BOOL);	
in
print_thm "" (icl'subst_rule [(icl'asm_rule(mk_eq(T,F)), mk_var("n",†))] (mk_eq(q,F)) T_eq_F)
end;
let val q = mk_var("q",BOOL);	
in
print_thm "" (icl'subst_rule [(icl'asm_rule(mk_eq(T,F)), T)] (mk_eq(q,F)) T_eq_F)
end; (* fails *)
let val q = mk_var("q",BOOL);	
in
print_thm "" (icl'subst_rule [(icl'asm_rule T, q)] (mk_eq(q,F)) T_eq_F)
end; (* fails *)
let val q = mk_var("q",BOOL);	
in
icl'subst_rule [(T_eq_F, q)] (mk_eq(T,q)) T_eq_F
end; (* fails *)
icl'subst_rule [(T_eq_F, v1)] v1 thy_deleted_thm; (* fails *)
icl'subst_rule [(T_eq_F, v1)] v1 level_deleted_thm; (* fails *)
icl'subst_rule [(thy_deleted_thm, v1)] v1 T_eq_F; (* fails *)
icl'subst_rule [(level_deleted_thm, v1)] v1 T_eq_F; (* fails *)
=TEX
Check partial evaluation in $icl'subst\_rule$
doesn't allow out of scope theorems to be used when evaluation
taken to completed.
=SML
val DeleteIt2 = icl'new_const("DeleteIt2",BOOL);
val level_deleted_thm2 = icl'refl_conv DeleteIt2;
val pe_subst_rule = icl'subst_rule [(level_deleted_thm2, v1)] v1;
icl'delete_extension();
pe_subst_rule T_eq_F; (* fails *)

=TEX
Now continue with the other rules.
=SML
let val q = mk_var("q",BOOL);	
in
print_thm "" (icl'simple_abs_rule q T_eq_F)
end;
let val q = mk_var("q",BOOL);	
in
	icl'simple_abs_rule q (icl'asm_rule(mk_eq(q,F)))
end; (* fails *)
icl'simple_abs_rule v1 thy_deleted_thm; (* fails *)
icl'simple_abs_rule v1 level_deleted_thm; (* fails *)

let val q = mk_const("q",BOOL);	
in
print_thm "" (icl'simple_abs_rule q T_eq_F)
end; (* fails *)
let val q = mk_var("q",BOOL);	
in
print_thm "" (icl'simple_abs_rule q pq_ax)
end; (* fails *)

icl'inst_type_rule [(BOOL, tv1)] pq_ax;
icl'inst_type_rule [(BOOL, BOOL)] pq_ax;
icl'inst_type_rule [(BOOL, tv1)] (icl'asm_rule(mk_eq(mk_var("v",tv1), mk_var("v",tv1))));
icl'inst_type_rule [(BOOL, tv1)] thy_deleted_thm; (* fails *)
icl'inst_type_rule [(BOOL, tv1)] level_deleted_thm; (* fails *)

print_thm "" (icl'Š_intro v1 pq_ax);
icl'Š_intro N1 pq_ax; (* fail *)
icl'Š_intro v1 thy_deleted_thm; (* fails *)
icl'Š_intro v1 level_deleted_thm; (* fails *)

val so_axiom = icl'new_axiom(["so_axiom"],mk_const("So",BOOL));
print_thm "" (icl'Š_elim  so_isso_def so_axiom);
icl'Š_elim  so_isso_axiom so_axiom; (* fails *)
icl'Š_elim  so_isso_def so_isso_def; (* fails *)
icl'Š_elim so_isso_axiom thy_deleted_thm; (* fails *)
icl'Š_elim so_isso_def level_deleted_thm; (* fails *)
icl'Š_elim thy_deleted_thm so_isso_axiom; (* fails *)
icl'Š_elim level_deleted_thm so_isso_def; (* fails *)

print_thm "" (icl'asm_rule (mk_const("rubbish",BOOL)));
print_thm "" (icl'asm_rule (mk_const("rubbish",†))); (* fails *)

print_thm "" (icl'refl_conv (mk_const("rubbish",BOOL)));
print_thm "" (icl'refl_conv (mk_const("rubbish",†)));

let val p = mk_var("p", tv1);	
	val f = mk_var("f",mk_fun(tv1,BOOL));
	val q = mk_var("q",tv1);
in
print_thm "" (icl'simple_%beta%_conv (mk_comb(simple_mk_abs(p,mk_comb(f,p)),q)))
end;
let val p = mk_var("p", tv1);	
	val f = mk_var("f",mk_fun(tv1,mk_fun(tv1,BOOL)));
	val q = mk_var("q",tv1);
in
print_thm "" (icl'simple_%beta%_conv (mk_comb(
	simple_mk_abs(p,simple_mk_abs(q,list_mk_comb(f,[p,q]))),
	q)))
end;
let val p = mk_var("p", tv1);	
	val f = mk_var("f",mk_fun(tv1,BOOL));
	val q = mk_var("q",tv1);
in
	icl'simple_%beta%_conv (simple_mk_abs(p,mk_comb(f,p)))
end; (* fails *)

print_thm "" (icl'suc_conv (mk_† 0));
print_thm "" (icl'suc_conv (mk_† 3));
print_thm "" (icl'suc_conv (mk_const("Number",†))); (* fails *)

print_thm "" (icl'string_conv (mk_string "abc"));
print_thm "" (icl'string_conv (mk_string ""));
print_thm "" (icl'string_conv (mk_const("hello",STRING))); (* fail *)

print_thm "" (icl'char_conv (mk_char "a"));
print_thm "" (icl'char_conv (mk_char "†"));
print_thm "" (icl'char_conv (mk_const("he",CHAR))); (* fail *)

print_thm "" (icl'eq_sym_rule(icl'asm_rule(mk_eq(N1,N0))));
print_thm "" (icl'eq_sym_rule(icl'asm_rule(mk_eq(T,F))));
icl'eq_sym_rule pq_ax; (* fails *)
icl'eq_sym_rule thy_deleted_thm; (* fails *)
icl'eq_sym_rule level_deleted_thm; (* fails *)

print_thm "" (icl'simple_list_ƒ_elim [F](icl'asm_rule(
	simple_mk_ƒ(v1,mk_Š(v1,T)))));
print_thm "" (icl'simple_list_ƒ_elim [T,F](icl'asm_rule(
	simple_mk_ƒ(v1,simple_mk_ƒ(v2,mk_Š(v1,v2))))));
print_thm "" (icl'simple_list_ƒ_elim [v2,v2](icl'asm_rule(
	simple_mk_ƒ(v1,simple_mk_ƒ(v2,mk_Š(v1,v2))))));

print_thm "" (icl'simple_list_ƒ_elim [v2] (icl'asm_rule(
	simple_mk_ƒ(v1,mk_Š(v1,
		mk_comb(simple_mk_abs(v2,v1),T))))));
icl'simple_list_ƒ_elim [T] pq_ax; (* fails *)
icl'simple_list_ƒ_elim [v1] thy_deleted_thm; (* fails *)
icl'simple_list_ƒ_elim [v1] level_deleted_thm; (* fails *)
icl'simple_list_ƒ_elim [N0](icl'asm_rule(
	simple_mk_ƒ(v1,mk_Š(v1,T)))); (* fails *)

print_thm "" (icl'eq_trans_rule (icl'asm_rule(mk_eq(N0,N1)))
	(icl'asm_rule(mk_eq(N1,N2))));
print_thm "" (icl'eq_trans_rule (icl'asm_rule(mk_eq(N0,N1))) pq_ax); (* fails *)
icl'eq_trans_rule (pq_ax) (icl'asm_rule(mk_eq(N1,N2))); (* fails *)
icl'eq_trans_rule (icl'asm_rule(mk_eq(N0,N1)))
	(icl'asm_rule(mk_eq(N0,N2))); (* fails *)
icl'eq_trans_rule so_isso_axiom thy_deleted_thm; (* fails *)
icl'eq_trans_rule so_isso_def level_deleted_thm; (* fails *)
icl'eq_trans_rule thy_deleted_thm so_isso_axiom; (* fails *)
icl'eq_trans_rule level_deleted_thm so_isso_def; (* fails *)

print_thm "" (icl'mk_comb_rule (icl'refl_conv(mk_const("Suc",
		mk_fun(†,†))))
	(icl'asm_rule(mk_eq(N1,N2))));
icl'mk_comb_rule (icl'refl_conv(T)) (icl'asm_rule(mk_eq(N1,N2))); (* fails *)
icl'mk_comb_rule pq_ax (icl'asm_rule(mk_eq(N1,N2))); (* fails *)
icl'mk_comb_rule (icl'asm_rule(mk_eq(N1,N2))) (pq_ax); (* fails *)
icl'mk_comb_rule (icl'asm_rule(mk_eq(N0,N1)))
	(icl'asm_rule(mk_eq(N0,N2))); (* fails *)
icl'mk_comb_rule so_isso_axiom thy_deleted_thm; (* fails *)
icl'mk_comb_rule so_isso_def level_deleted_thm; (* fails *)
icl'mk_comb_rule thy_deleted_thm so_isso_axiom; (* fails *)
icl'mk_comb_rule level_deleted_thm so_isso_def; (* fails *)

print_thm "" (icl'‚_mp_rule  (icl'asm_rule(mk_eq(T,F)))
	(icl'asm_rule T));
icl'‚_mp_rule (icl'asm_rule(mk_eq(T,F))) (icl'asm_rule F); (* fails *)
icl'‚_mp_rule (icl'asm_rule T) (icl'asm_rule(mk_eq(T,F))); (* fails *)
icl'‚_mp_rule so_isso_axiom thy_deleted_thm; (* fails *)
icl'‚_mp_rule so_isso_def level_deleted_thm; (* fails *)
icl'‚_mp_rule thy_deleted_thm so_isso_axiom; (* fails *)
icl'‚_mp_rule level_deleted_thm so_isso_def; (* fails *)

print_thm "" (icl'simple_ƒ_intro v1  (icl'asm_rule(mk_eq(T,F))));
icl'simple_ƒ_intro v1  (icl'asm_rule v1); (* fails *)
let val c1 = mk_const("c1",BOOL)
in
icl'simple_ƒ_intro c1  (icl'asm_rule c1)
end; (* fails *)
icl'simple_ƒ_intro v1 thy_deleted_thm; (* fails *)
icl'simple_ƒ_intro v1 level_deleted_thm; (* fails *)

let val p = mk_var("p",BOOL);
	val q = mk_var("q",BOOL);
	val thm1 = icl'simple_list_ƒ_elim [p,q]
		(icl'asm_rule(list_simple_mk_ƒ([p,q],mk_eq(p,q))));
in
	(print_thm "" thm1;
	print_thm "" (icl'inst_term_rule [(T,p),(F,q)] thm1))
end;
let val p = mk_var("p",BOOL);
	val q = mk_var("q",BOOL);
	val thm1 = icl'simple_list_ƒ_elim [p,q]
		(icl'asm_rule(list_simple_mk_ƒ([p,q],mk_eq(p,q))));
in
	print_thm "" (icl'inst_term_rule [(q,p),(p,q)] thm1)
end;
icl'inst_term_rule [(v2,v1)] (icl'asm_rule v1) ; (* fails *)
icl'inst_term_rule [] thy_deleted_thm; (* fails *)
icl'inst_term_rule [] level_deleted_thm; (* fails *)
let val p = mk_var("p",BOOL);
	val q = mk_var("q",BOOL);
	val thm1 = icl'simple_list_ƒ_elim [p,q]
		(icl'asm_rule(list_simple_mk_ƒ([p,q],mk_eq(p,q))));
in
	icl'inst_term_rule [(q,p),(p,T)] thm1
end; (* fail *)
let val p = mk_var("p",BOOL);
	val q = mk_var("q",BOOL);
	val thm1 = icl'simple_list_ƒ_elim [p,q] 
		(icl'asm_rule(list_simple_mk_ƒ([p,q],mk_eq(p,q))));
in
	icl'inst_term_rule [(q,p),(N0,q)] thm1
end; (* fail *)

val tDiv = icl'new_const("Div",mk_fun(†,mk_fun(†,†)));

print_thm "" (icl'div2_conv (list_mk_comb(tDiv,[mk_† 7,N2])));
print_thm "" (icl'div2_conv (list_mk_comb(tDiv,[mk_† 0,N2])));
icl'div2_conv (list_mk_comb(tDiv,[mk_† 0,N1])); (* fails *)
icl'div2_conv (list_mk_comb(tDiv,[Zero,N2])); (* fails *)

val tMod = icl'new_const("Mod",mk_fun(†,mk_fun(†,†)));
print_thm "" (icl'mod2_conv (list_mk_comb(tMod,[mk_† 7,N2])));
print_thm "" (icl'mod2_conv (list_mk_comb(tMod,[mk_† 0,N2])));
icl'mod2_conv (list_mk_comb(tMod,[mk_† 0,N1])); (* fails *)
icl'mod2_conv (list_mk_comb(tMod,[Zero,N2])); (* fails *)
=TEX
Test hooks into environments.
=SML
get_const_type "5"; (* built in *)
get_const_type "T";
get_const_type "TorF"; (* Nil *)
get_const_type "rubbish"; (* Nil *)
get_type_arity "BOOL";
get_type_arity "†";
get_type_arity "‹";
get_type_arity "rubbish"; (* Nil *)
=TEX
Test the built in scopes:
=SML
icl'new_const("1",BOOL); (* fails *)
icl'new_const("123",BOOL); (* fails *)
icl'new_const("12a",BOOL); (* succeeds! *)
icl'new_const("'a",BOOL); (* fails *)
icl'new_const("'abc",BOOL); (* succeeds! *)
icl'new_const("\"a",BOOL); (* fails *)
icl'new_const("\"abc",BOOL); (* fails *)
=TEX
Test the sealing of theories:
=SML
icl'open_theory "next";
icl'seal_hierarchy();
icl'open_theory "next";
icl'open_theory "min"; (* fails *)
icl'open_theory "another"; (* fails *)
icl'open_theory "yet_again";
=TEX
Tests on hierarchies : do after all others, as things are made read only.
=SML
icl'open_theory "yet_again";
val newhier = icl'new_hierarchy();
print_hierarchy();
icl'new_axiom(["Truth_axiom1"],T); (* fails *)
icl'new_const("ForT1",BOOL); (* fails *)
icl'new_type("SOMETHING1",3); (* fails *)
icl'new_definition (["True1"],"True1",T); (* fails *)
icl'delete_extension(); (* fails *)
icl'list_save_thm(["Example1"],icl'asm_rule v1); (* fails *)
icl'delete_thm "Example";
icl'delete_theory "yet_again"; (* fails *)
icl'lock_theory "yet_again"; (* fails *)
icl'new_parent "another"; (* fails *)
val etype_def = icl'new_type_definition( [ "ETYPE7"], "ETYPE7", ["'1"], etype_exax); (* fails *)
icl'new_specification (["So1","IsSo1"],2,so_isso_axiom); (* fails *)
icl'load_hierarchy newhier;
icl'new_theory "another_test";
icl'load_hierarchy newhier; (* fails *)

=TEX
\subsection{End of Tests}
=SML
set_flag("usefile_non_stop_mode",false);
(* PolyML.quit(); *)
=TEX
\section{UNTESTED ERROR MESSAGES}
The following are not tested for various reasons:

\begin{tabular}{| l | p{4.5in} |}\hline
Test & Comment \\ \hline
6072 & This is where a theorem has a duff theory pointer: difficult to recreate. \\
6066 & Only tested for $icl'subst\_rule$. \\
(6033) & Can't easily test whether we can load a hierarchy that
is a superset of the current hierarchies theories. \\ \hline
\end{tabular}
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
=TEX
\end{document}
