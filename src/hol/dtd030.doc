=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design for the Subgoal Package}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the Subgoal Package}
\TPPref{DS/FMU/IED/DTD030}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
subgoal package in ICL HOL.
This allows tactics to be used in a backward proof mechanism.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Major changes after RDA comments.
\item [Issue 1.3]
Main Goal stack made ``infinite''.
Operations that change the number of states on this stack now inform the
user about the current number.
Added $top\_thm$.
Added a relabelling feature to $modify\_goal\_state\_thm$.
\item [Issue 1.4]
Changes during implementation.
\item [Issue 1.5]
Changes during testing.
Added $icl'ts\_thm$.
Corrected errors.
\item [Issue 1.6]
Capitalised error messages.
\item [Issue 1.7]
Changed format of goal printing.
Added $before\_kernel\_state\_change$ material.
Changes following comments on issue 1.6.
Added message 30058.
$top\_current\_goal$ becomes $top\_goal$.
Mentioned sensitivity to additional assumptions
in deficiencies section.
\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
subgoaling package.
This is called for in \cite{DS/FMU/IED/HLD009}.
The design is
implemented in \cite{DS/FMU/IED/IMP030}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the
subgoal package in Release 001 of ICL HOL.
This document is based on the discussion document
\cite{DS/FMU/IED/WRK018}.
\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.
In particular it depends on \cite{DS/FMU/IED/IMP009},
in which
the type abbreviations $TACTIC$, $GOAL$ and $PROOF$ are defined.
\subsubsection{Deficiencies}
The document mixes functions which are tools for the naive user
and those for the advanced system builder, which makes for an uneven presentation.

To be handled properly by the subgoal package the proofs given by tactics must be written to be insensitive to additional assumptions to those requested being present
in its argument theorems.
This will be true of all ICL supplied tactics,
and is likely to be true of any tactic, but
certain coding techniques may cause problems.
\subsubsection{Possible Enhancements}
The subgoal package as stated provides no direct link to 
whatever conversion package becomes available.
It may be that the interface already provided is sufficient to
link the two packages, or a later release of this document may
provide a more specific link.

The package does not contain any integral help system:
such as tactic suggestions.
This is because in release 001 the appropriate level of functionality could be satisfactorily provided outside of the
package.
If the help system was to maintain, for instance, a window
offering tactic suggestions based on the current goal,
then this, or some notification mechanism, would need to be embedded within the system.
\subsubsection{General Comments}
All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP030}.

\newpage
\section{TERMINOLOGY}
Some of the following is originally covered in \cite{DS/FMU/IED/DTD009}.

A {\em tactic} is a function which attempts to {\em achieve}, or progress the achievement of, a goal. 
Here a {\em goal} is just a sequent (of type $SEQ$),
and achievement would be providing a theorem which achieves the goal.
Here, roughly speaking,
a theorem, $\Gamma…t$, {\em achieves} a goal, $gl$,
iff. $gl = (\Gamma, t)$.

Given a goal of a form which it finds acceptable, a tactic
returns a list of new goals (often referred to as
the {\em subgoals}), together with a {\em proof}, i.e. a function
value which given theorems achieving the subgoals can compute a theorem
matching the original goal. 

A {\em goal state} contains the state of a proof within the subgoal package.
In particular in contains which goals are yet to be achieved,
and a theorem embedding the inference work so far.
A user invokes the subgoal package by setting a {\em main goal}:
which is the sequent they wish to achieve by a theorem.
This produces an initial {\em goal state}, that is 
pushed onto
the {\em main goal stack}.
It is an infinite stack (within memory bounds).
The user may ``pop'' main goals from this stack either by achieving and then popping, or by abandoning (dropping) the current main goal.
The {\em current goal state} is the top entry of the main goal stack.

A goal state has a {\em current goal}, 
and the user will {\em apply} tactics to the current goal of the
current goal state.
If the tactic returns some subgoals then the ``first'' of these
will become the new current goal.
If the tactic produces a theorem
that achieves the current goal
(i.e. the list of subgoals it generates is empty), then the {\em next goal}
will become the current one
(the next goal to a goal of a given label is defined in \ref{NextGoal}).
The successful application of a tactic and of most other commands that affect the goal state will result in the
current goal state being pushed onto the subgoal package's {\em undo buffer},
and a new goal state, based on the tactics application, becomes the current one
(replacing the previous ``current goal state'' at the top of the main goal stack).
The user may then {\em undo} such commands by retrieving past
goal states from the undo buffer to the limit of the buffer.
If the buffer fills then it will discard the oldest goal states to make room for new ones.
Note that the undo buffer is not part of any goal state,
and so, for example, pushing a goal onto the main goal stack
discards the old undo buffer contents from the system.

Each goal within a goal state will have one or more {\em labels},
by which the goal may be referred to.
The labels will be presented to and input from the user as strings, consisting of natural numbers, separated by dots.
The numbers indicate a subgoal of the goal indicated to the
left of the number, e.g. ``1.2.3'' is the third subgoal of the
goal labelled ``1.2''.
If a goal has a single subgoal, that subgoal inherits the goals label.
If the main goal is set normally (using $push\_goal$)
then the single current goal will have label ``''
(i.e. the empty string).

The current goal state has as one component the current {\em goal state theorem}, which embodies the results of all successful tactic applications since the setting of the current main goal.
If the main goal has been achieved then the goal state's {\em achieved theorem} is the theorem whose sequent is the main goal.

When discussing the internal handling of goals we need to refer to a {\em term form} of our ({\em sequent form}) goals.
These two forms are semantically equivalent.
The term form uses the constant $icl'TS$ as a place marker for the sequent's turnstile.
\section{THE SUBGOAL PACKAGE}
=DOC
signature âSubgoalPackageá = sig
=DESCRIBE
This provides the subgoal package, which provides an interactive backward proof mechanism, based on the application of
tactics.
=FAILURE
30009	There are no goals to prove
30015	DESIGN ERROR:duplicated label in labelled
30017	Label ?0 has no corresponding goal
30021	DESIGN ERROR:goal is unprintable
30023	?0 cannot be viewed as a goal
30028	Label may not contain ?0, as less than 1
30031	DESIGN ERROR:superseded label in labelled
30041	Label ?0 has been superseded
30042	Label may not contain 0
30043	Label ?0 has been achieved
30045	Label cannot be empty
30055	Goal state theorem is not valid in current context
30056	?0 may invalidate a subgoal package goal state
=FAILUREC
Warning message 30056 is given before any command that
might invalidate a theorem due to change of scope or
deletion of conservative extensions, whenever the
main goal stack is not empty.
The user may know the change to be benign, so this 
is not an automatic failure.
=ENDDOC
\subsection{Type of Goal State}
=DOC
type âGOAL_STATEá;
=DESCRIBE
This is an abstract data type that embodies a goal state,
in particular it contains which goals are yet to be achieved
and a theorem embedding the inference work so far.
The subgoal package has a current goal state, a stack of
goal states for different main goals, and a buffer of goal states to allow some operations to be undone.
=SEEALSO
$print\_goal\_state$
=ENDDOC
\subsection{Starting a New Main Goal}
=DOC
val âpush_goalá : GOAL -> unit;
=DESCRIBE
Sets a new current main goal, creating an appropriate goal state and pushing it
onto the main goal stack.
The current (and only) goal in the new goal state will be the main goal, with label ``''.
The current goal will be displayed.
The undo buffer will be emptied.
=FAILURE
30001	Now ?0 goal?1 on the main goal stack
30002	The conclusion of the goal, ?0, is not of type BOOL
30003	An assumption of the goal, ?0, is not of type BOOL
30004	Two assumption of the goal (?0 and ?1) are %alpha%-convertible
30058	Two distinct variables with name ?0 occur free in the goal
=FAILUREC
Message 30001 is only for the users information.
=ENDDOC
A work around if the user really wishes to prove a theorem with
two distinct variables with the same name is to prove a theorem
with different names, and use $inst\_term\_rule$ on the result.
=DOC
val âpush_goal_state_thmá : THM -> unit;
=DESCRIBE
Given a theorem that is of the form of a goal state theorem
(e.g. gained by $top\_goal\_state\_thm$, q.v.),
set a new current main goal to be the conclusion of the input theorem
(viewed as a term form goal).
The current goal in the new goal state will be the first assumption of the input theorem, viewed as a term form goal.
If it is the only assumption of the theorem argument then the corresponding goal will have label ``'';
otherwise label ``1'',
and the other assumptions of the theorem will become subsequent goals with labels ``2'',``3'',...
This new goal state is pushed onto the main goal stack.
The undo buffer will be emptied.
=USES
For the advanced user, interested in partial proof.
=FAILURE
30001	Now ?0 goal?1 on the main goal stack
30005	Theorem cannot be viewed as a goal state theorem
30047	Current goal is:
30048	All goals proven
30055	Goal state theorem is not valid in current context
30058	The variable ?0 occurs in free in the goal with two different types
=FAILUREC
Message 30001 is only for the users information.
=ENDDOC
\subsection{Applying Tactics}
\label{NextGoal}
In discussing the following we need the concept of the {\em next goal}.
If ``label'' is a valid label
(i.e. a string of dot separated natural numbers),
and ``n'' a string representation of an integer then the next goal of a goal labelled ``label.n'' is :
\begin{itemize}
\item
If there are yet-to-be-achieved goals labelled ``label.m$<...>$'', where $n\ <\ m$,
then the goal of these labelled with the ``smallest'' suffix will be the next goal.
\item
Otherwise, if there are yet-to-be-achieved goals labelled ``label.m$<...>$'', where $m\ <\ n$,
then the goal of these labelled with the ``smallest'' suffix will be the next goal.
\item
Otherwise the next goal to label ``label.n'' is recursively defined as the ``next'' goal to the label ``label''.
\end{itemize}
Thus if we have the labels ``1.2'',``1.3.1'',``1.3.2'',``2.2'',``3'', and ``4.1'' in a goal state,
then the next label to ``1.3.1'' is ``1.3.2'',
the next to ``1.3.2'' is ``1.3.1'',
the next to ``2.2'' is ``3'',
and the next to ``4.1'' is ``1.2'.
=DOC
val âapply_tacticá : TACTIC -> unit;
val âaá : TACTIC -> unit;
=DESCRIBE
$apply\_tactic$ applies a tactic to the current goal,
and $a$ is an alias for it.
If successful, the previous goal state will be put in the undo buffer, and the new goal state, current goal, etc,
will be based on the tactic's application.
If the tactic returns some subgoals then the ``first'' of these
will become the new current goal.
If there is only one subgoal it will inherit the label of the previous current goal, otherwise if the old label was ``label'' then it will be considered in the goal state as superseded,
and the new subgoals will be labeled ``label.1'', ``label.2'', etc.
If it produces a theorem
that achieves the current goal
(i.e. the list of subgoals is empty), then the ``next'' goal
will become the current one,
and the previous goal's label will be noted as achieved.

The subgoals created, or if none, the ``next'' goal, will be displayed.
=SEEALSO
$print\_goal$ for the display format of the goals.
=FAILURE
30006	The subgoal ?0 is %alpha%-convertible to its goal
30007	There is no current goal
30008	Result of tactic did not match the current goal
30020	DESIGN ERROR: corrupted goal state
30029	Tactics proof introduced the goal ?0 but did not request it as a subgoal
30030	Tactics proof introduced the goal ?0, did
	did not request it as a subgoal, and the
	resulting goal is duplicated as goal?1 labelled ?2
30032	The subgoal ?0 duplicates goal?1 labelled ?2
30033	Tactic requested the following unnecessary subgoal:
30034	Tactic did not change the goal state
30035	Current goal achieved, next goal is:
30036	Current and main goal achieved
30037	Tactic produced ?0 subgoal?1:
=FAILUREC
Messages 30006, 30029 to 30037 are for the users information, and are
not failures.
They will occur after the display of all the subgoals.
=ENDDOC
\subsection{The Results of the Package}
=DOC
val âpop_thmá : unit -> THM;
=DESCRIBE
If the top achieved theorem
is available
(i.e. the theorem whose sequent is the main goal has been achieved), 
this function returns it,
and then pops the previous goal state (if any) off the main goal stack,
restoring its current goal and labelling.
If the current proof is incomplete the function fails, having no effect.

If the user wishes to examine the top achieved theorem without
popping the main goal stack, then they should use $top\_thm$ (q.v.).
=SEEALSO
$save\_pop\_thm$, $top\_thm$
=FAILURE
30001	Now ?0 goal?1 on the main goal stack
30010	The subgoal package is not in use
30011	The current proof is incomplete
30024	The main goal has changed from the initially set main goal
=FAILUREC
Message 30001 is only for the users information,
and, if it exists, will be followed by a display of what is
now the top current goal.
Message 30024 indicates that some facility employing $modify\_goal\_state\_thm$(q.v) has been used in a manner that changes the main goal, and is just for the information of the user.
=ENDDOC
=DOC
val âtop_thmá : unit -> THM;
=DESCRIBE
If the top achieved theorem
(i.e. the theorem whose sequent is the main goal has been achieved)
is available, this function returns it,
without affecting the current goal state.
If the current proof is incomplete the function fails.
=SEEALSO
$pop\_thm$, $save\_pop\_thm$
=FAILURE
30010	The subgoal package is not in use
30011	The current proof is incomplete
30024	The main goal has changed from the initially set main goal
=FAILUREC
Message 30024 indicates that some facility employing $modify\_goal\_state\_thm$(q.v) has been used in a manner that changes the main goal, and is just for the information of the user.
=ENDDOC
=DOC
val âsave_pop_thmá : string -> THM;
=DESCRIBE
If the top achieved theorem
is available
(i.e. the theorem whose sequent is the main goal has been achieved),
this function returns it,
as well as saving it under the given string key on the current theory,
and then pops the previous goal state (if any) of the main goal stack,
restoring its current goal and labelling.
If the current proof is incomplete, or the key is already used in the current theory, the function fails, having no effect.
=SEEALSO
$pop\_thm$, $top\_thm$
=FAILURE
30001	Now ?0 goal?1 on the main goal stack
30010	The subgoal package is not in use
30011	The current proof is incomplete
30024	The main goal has changed from the initially set main goal
=FAILUREC
Failures also as $save\_thm$, but given as originating from this function.
Message 30001 is only for the users information,
and, if it exists, will be followed by a display of what is
now the top current goal.
Message 30024 indicates that some facility employing $modify\_goal\_state\_thm$(q.v) has been used in a manner that changes the main goal, and is just for the information of the user.
=ENDDOC
=DOC
val âtop_goal_state_thmá : unit -> THM;
=DESCRIBE
This returns the goal state theorem of the current goal state.
It is a partial proof of the main goal, though in a somewhat unwieldy form,
as it encodes the main goal, and its other goals in a term form.
It may be simplified by using $simplify\_goal\_state\_thm$(q.v).
The theorem is suitable for setting a new main goal, by using $push\_goal\_state\_thm$(q.v).
=USES
For the advanced user, interested in partial proofs.
=FAILURE
30010	The subgoal package is not in use
30024	The main goal has changed from the initially set main goal
30038	Goal state has achieved its theorem
=FAILUREC
Message 30038 is for the users information, and is not a failure.
Message 30024 indicates that some facility employing $modify\_goal\_state\_thm$(q.v) has been used in a manner that changes the main goal, and is just for the information of the user.
=ENDDOC
=DOC
val âsimplify_goal_state_thmá : THM -> THM;
=DESCRIBE
This will simplify a goal state theorem
(e.g from $top\_goal\_state\_thm$, q.v.), stripping off assumptions from the conclusion of the theorem up to the turnstile place marker, then removing the place marker itself in both conclusion and assumptions.
=USES
For the advanced user, interested in partial proofs.
=FAILURE
30005	Theorem cannot be viewed as a goal state theorem
=ENDDOC
=DOC
val âdrop_main_goalá : unit -> GOAL;
=DESCRIBE
Pop the curent goal state from the main goal stack
throwing away it and any work upon it,
and
making the following entry on the stack the new current goal state.
The function returns the main goal dropped.
=FAILURE
30001	Now ?0 goal?1 on the main goal stack
30010	The subgoal package is not in use
=FAILUREC
Message 30001 is only for the users information,
and, if it exists, will be followed by a display of what is
now the top current goal.
=ENDDOC
\subsection{Undoing and Redoing}
=DOC
val âundoá : int -> unit;
=DESCRIBE
$undo$ $n$ will take the $n$th entry from the undo buffer, if there are sufficient,
as the current goal state.
Attempting to go past the end of the buffer will cause a failure, rather than a partial undoing.
A single $undo$ command can itself be undone by $redo$(q.v),
but otherwise entries on the undo buffer between its start and the $n$th entry will be discarded.
=FAILURE
30010	The subgoal package is not in use
30012	Attempted to undo ?0 time?1 with only ?2 entr?3 in the undo buffer
30013	Must undo a positive number of times
30047	Current goal is:
30048	All goals proven
=ENDDOC
=DOC
val âredoá : unit -> unit;
=DESCRIBE
If the last command to affect the goal state was an $undo$(q.v)
then this command will undo its effect
(including leaving the undo buffer in its previous form,
without mention of the $undo$ or $redo$).
=FAILURE
30014	The last command to affect the goal state was not an undo
30047	Current goal is:
=ENDDOC
\subsection{Navigation}
=DOC
val âset_labelled_goalá : string -> unit;
=DESCRIBE
If the string is a valid label in the current goal state,
then set the corresponding goal as the current goal,
and then display it.
=FAILURE
30010	The subgoal package is not in use
30016	?0 is not of the form "n1.n2....nm"
30017	Label ?0 has no corresponding goal
30041	Label ?0 has been superseded
30043	Label ?0 has been achieved
30047	Current goal is:
=ENDDOC
\subsection{Handling Goal States}
=DOC
val âtop_goal_stateá : unit -> GOAL_STATE;
=DESCRIBE
This provides the current goal state as a value:
note that this does not contain the undo buffer.
=SEEALSO
$push\_goal\_state$
=FAILURE
30010	The subgoal package is not in use
=ENDDOC
=DOC
val âpush_goal_stateá : GOAL_STATE -> unit;
=DESCRIBE
If the value given is ``well-formed'', then this function pushes the current goal state onto the main goal stack,
and sets the given value as the current goal state.
The most likely reason that a goal state value is ill-formed
is that it is not being pushed in the same context as it was formed, e.g. it was formed in a theory that is now out of scope, e.g. because the user has changed theory since
the states creation.
The undo buffer will be emptied.
=SEEALSO
$top\_goal\_state$
=FAILURE
30001	Now ?0 goal?1 on the main goal stack
30037	Tactic produced ?0 subgoal?1:
30047	Current goal is:
30048	All goals proven
30055	Goal state theorem is not valid in current context
=FAILUREC
Message 30001 is only for the users information.
=ENDDOC
\subsection{Information Requests}
=DOC
val âprint_goalá : GOAL -> unit;
=DESCRIBE
Display a goal (i.e. a conclusion and a list of assumptions)
in the manner of the other subgoal package functions.
This presents the the assumptions first, numbered, and
in reverse order,
and then the conclusion, distinguished from the assumptions by a turnstile.
=EXAMPLE
(* 	3 *)	»a Š Œ b¼ 
(* 	2 *)	»a Š 
		 a Š
		 a Š b¼ 
(*	1 *)	»Œ b Š a¼ 

(*	?… *)	»a  b¼

=TEX
where $»Œ\ b\ Š\ a¼$ is the first assumption, and the second assumption is too long to fit on one line.
Then with no assumptions:
=EXAMPLE
(*	?… *)	»a  b¼

=TEX

=ENDDOC
The following four messages are methods of parameterising the
output of the subgoal package.
See \cite{DS/FMU/IED/IMP030} for details.
Note that messages 30053, 30054, 30057 have two spaces after its last printed character,
and messages 30052, 30054 and 30057 should have ``?0'' set to
``\backslash n'' in the implementation (regardless of whether ``?0'' is present in the message below)
.
Roughly their uses are:

\begin{tabular}{| l | l|} \hline
30052 & Format a goal label \\
30053 & Format an assumption label \\
30054 & Format a conclusion label if there are assumptions \\
30057 & Format a conclusion label if no assumptions \\ \hline
\end{tabular}

=FAILURE
30052	?0(* *** Goal "?1" *** *)?0
30053	(* ?0 *)  
30054	?0(* ?1?… *)  
30057	(* ?1?… *)  
=TEX
=DOC
val âtop_main_goalá : unit -> GOAL;
=DESCRIBE
Return the current main goal: the objective of the current proof attempt.
=FAILURE
30025	There is no current main goal
=ENDDOC
=DOC
val âtop_goalá : unit -> GOAL;
=DESCRIBE
Returns the current goal of the current goal state: the goal to which a tactic will be applied.
=FAILURE
30026	There is no current goal
=ENDDOC
=DOC
val âprint_current_goalá : unit -> unit;
=DESCRIBE
Displays, with its label, the current goal of the current goal state: the goal to which a tactic will be applied.
=FAILURE
30026	There is no current goal
=ENDDOC
=DOC
val âtop_current_labelá : unit -> string;
=DESCRIBE
Returns the label of the current goal: the goal to which a tactic will be applied.
=FAILURE
30026	There is no current goal
=ENDDOC
=DOC
val âtop_labelled_goalá : string -> GOAL;
=DESCRIBE
Returns the goal with the given label, should it exist in the current goal state.
Note that superseded and achieved goals are not available from the goal state.
=FAILURE
30016	?0 is not of the form "n1.n2....nm"
30017	Label ?0 has no corresponding goal
30041	Label ?0 has been superseded
30043	Label ?0 has been achieved
=ENDDOC
=DOC
val âget_asmá : int -> TERM;
=DESCRIBE
$get\_asm$ $n$ returns the $n$th assumption of the current goal.
=FAILURE
30026	There is no current goal
30027	There is no assumption ?0 in the current goal
=ENDDOC
=DOC
val âtop_goalsá : unit -> (string list * GOAL)list;
=DESCRIBE
Returns all the goals yet to be achieved, and their associated labels (they may have more than one), in the current goal state.
=USES
To determine what goals are left to achieve.
=FAILURE
30010	The subgoal package is not in use
=ENDDOC
=DOC
val âprint_goal_stateá : GOAL_STATE -> unit;
=DESCRIBE
Display the given goal state.
=FAILURE
30047	Current goal is:
30048	All goals proven
30049	Main goal is:
30050	Goals to be proven are:
=ENDDOC
\subsection{Parameterising the Subgoal Package}
=DOC
(* âundo_buffer_lengthá : int *)
=DESCRIBE
This is a system control, handled by $set\_int\_control$, etc,
which sets the maximum number of entries that can be held on
the undo buffer: i.e. how many tactic applications, etc, may be undone.
It is initially set to 12,
and cannot be made negative.
=ENDDOC
\subsection{Modifying the Goal State Theorem}
=DOC
val âmodify_goal_state_thmá : (THM -> THM) -> ((string list * GOAL)list) -> unit;
=DESCRIBE
$modify\_goal\_state\_thm$ $rule$ $label$ is a powerful hook into the subgoal package that works as follows:
\begin{enumerate}
\item
Extract the goal state theorem
\item
Apply a user-supplied inference rule $rule$ to the theorem.
\item
Make a new goal state, in which the goal state theorem is this
 new theorem.
\item
In the new goal state label any goals  found 
(up to $\alpha$-conversion) in the association list $label$
with their corresponding labels.
Multiple entries for the same term in the list will cause the labels to be 
accumulated.
If $top\_goals()$ (q.v.) is used for this association list
then all unchanged goals will gain their original labels.
\item
Label otherwise unlabelled goals with unused single natural number labels (the first available ones from the list ``1'', ``2'',...)
\item
Treat this new goal state as if it had been created by a tactics application, e.g. it becomes the current goal state,
the previous goal state is put on the undo list, the user is
told the next goal to prove, etc.
\end{enumerate}

This will issue a warning on its use should the main goal have changed, and on attempting to extract 
an achieved, or goal state, theorem from a goal state that
is derived from the modified one,
This is so that the user is warned that the result of an apparently successful $pop\_thm$ is not
an achievement of the initially set main goal.
=USES
This function is intended for system builders wishing to write extensions to the package that change the overall proof tree, not an individual goal.
=FAILURE
30024	The main goal has changed from the initially set main goal
30039	Two labels clash: ?0 and ?1
30040	Duplicate labels ?0 given for different terms
30047	Current goal is:
30048	All goals proven
30051	Inference rule returned '?0' which is not a goal state theorem
=FAILUREC
Message 30024 indicates that some facility employing $modify\_goal\_state\_thm$(q.v) has been used in a manner that changes the main goal, and is just for the information of the user.
=ENDDOC

Two example uses of it are:
\begin{enumerate}
\item
Add an assumption to the main goal ``on the fly''.
This would involve adding the assumption to the
conclusion of the goal state theorem,
as well as to each goal's assumption list (held in a term form).
This will save on having to restart the subgoal package if the original main
goal was not satisfiable, but an additional assumption
would allow it to become so.
\item
Combine two goals into one, by having the inference rule
``merge'' the two assumptions representing the goals,
into a single  term form goal.
\end{enumerate}
Both these uses could allow the proof structure to be recovered
using the $label$ association list.
\subsection{Supporting Theory}
=DOC
(* âicl'TSá *)
=DESCRIBE
The theory will contain a constant named $icl'TS$,
defined by a definition with key ``icl'TS''.
This is used is creating a term form goal.
Using this constant explicitly within the subgoal
package may cause unexpected behaviour.
=SEEALSO
$icl'ts\_thm$
=ENDDOC
=DOC
val âicl'ts_thmá : THM;
=DESCRIBE
ó
icl'ts_thm = ƒ x Ž (icl'TS x) ‚ x
æ
=USES
To be used when analysing goal state theorems, or using
$modify\-\_goal\-\_state\-\_thm$ (q.v.) - both operations
are only for the advanced user of the system.
=ENDDOC
\section{END OF THE SIGNATURE}
=SML
end; (* signature of SubgoalPackage *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested according to the criteria given in
\cite{DS/FMU/IED/PLN008}.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
