=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design for the Subgoal Package}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the Subgoal Package}
\TPPref{DS/FMU/IED/DTD030}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
subgoal package in ICL HOL.
This allows tactics to be used in a backward proof mechanism.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Major changes after RDA comments.
\end{description}
\subsection{Changes forecast}
Most of the text outside the documentation boxes is a discussion
of the design process, rather than being part of the final design.
It will thus be removed or rephrased in later issues.
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design for the 
subgoaling package.
This is called for in section ??? of ???.
The design is
implemented in \cite{DS/FMU/IED/IMP030}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design for the
subgoal package in Release 001 of ICL HOL.
This document is based on the discussion document
\cite{DS/FMU/IED/WRK018}.

All functions require all their arguments to begin evaluation,
unless otherwise noted.

Note also that the order of declaration given in this document will
not necessarily reflect the order of implementation in
\cite{DS/FMU/IED/IMP030}.
\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.
In particular it depends on \cite{DS/FMU/IED/IMP009},
in which
the type abbreviations $TACTIC$, $GOAL$ and $PROOF$ are defined.
\subsubsection{Deficiencies}
\subsubsection{Possible Enhancements}
The subgoal package as stated provides no direct link to 
whatever conversion package becomes available.
It may be that the interface already provided is sufficient to
link the two packages, or a later release of this document may
provide a more specific link.

Neither does the package contain any integral help system:
such as tactic suggestions.
This is because in release 001 the appropriate level of functionality could be satisfactorily provided outside of the
package.
If the help system was to maintain, for instance, a window
offering tactic suggestions based on the current goal,
then this, or some notification mechanism, would need to be embedded within the system.
\newpage
\section{TERMINOLOGY}
Some of the following is originally covered in \cite{DS/FMU/IED/DTD009}.

A {\em tactic} is a function which attempts to {\em achieve}, or progress the achievement of, a goal. 
Here a {\em goal} is just a sequent (of type $SEQ$),
and achievement would be providing a theorem which achieves the goal.
Here, roughly speaking,
a theorem, $\Gamma…t$, {\em achieves} a goal, $gl$,
iff. $gl = (\Gamma, t)$.

Given a goal of a form which it finds acceptable, a tactic
returns a list of new goals (often referred to as
the {\em subgoals}), together with a {\em proof}, i.e. a function
value which given theorems achieving the subgoals can compute a theorem
matching the original goal. 

A {\em goal state} contains the state of a proof within the subgoal package, 
in particular what goals are yet to be achieved,
and a theorem embedding the inference work so far.
A user invokes the subgoal package by setting a {\em main goal}:
the sequent they wish to achieve by a theorem.
This produces an initial {\em goal state}, that is 
pushed onto 
the {\em main goal stack}:
the {\em current goal state} is always the top of the main goal stack.
It is a finite stack, that will refuse
user attempts to push more goal states onto it than it 
can contain.
The user may ``pop'' main goals from this stack either by achieving or abandoning (dropping) the current main goal.

A goal state has a {\em current goal}, 
and the user will {\em apply} tactics to the current goal of the
current goal state.
If the tactic returns some subgoals then the ``first'' of these
will become the new current goal, and if it produces a theorem
that achieves the current goal
(i.e. the list of subgoals is empty), then the {\em next goal}
will become the current one
(the next goal to a goal of a given label is defined in \ref{NextGoal}).
The successful application of a tactic and of most other commands that affect the goal state will result in the
current goal state being pushed onto the {\em undo buffer},
and a new goal state based on the tactics application becomes the current one
(replacing the top of the main goal stack).
The user may then {\em undo} such commands by retriving past
goal states from the undo buffer to the limit of the buffer.
If the buffer fills then it will discard the oldest goal states to make room for new ones.

Each goal within a goal state will have one or more {\em labels},
by which the goal may be referred to.
The labels will be presented and input from the user as strings, consisting of natural numbers, separated by dots.
The numbers indicate a subgoal of the goal indicated to the
left of the number, e.g. ``label.3'' is the third subgoal of the
goal labelled ``label''.
If a goal has a single subgoal, that subgoal inherits the goals label.

The current goal state has as one component the current {\em goal state theorem}, which embodies the results of all successful tactic applications since the setting of the current main goal.
If the main goal has been achieved then the goal state's {\em achieved theorem} is the theorem whose sequent is the main goal.

When discussing the internal handling of goals we need to refer to a {\em term form} of our ({\em sequent form}) goals.
These two forms are semantically equivalent.
The term form uses the constant $icl'TS$ as a place marker for the sequent's turnstile.
\section{THE SUBGOAL PACKAGE}
=DOC
signature âSubgoalPackageá = sig
=DESCRIBE
This provides the subgoal package, which provides an interactive backward proof mechanism, based on the application of
tactics.
=ENDDOC
\subsection{Type of Goal State}
=DOC
type âGOAL_STATEá;
=DESCRIBE
This is an abstract data type that embodies a goal state,
in particular it contain what goals are yet to be achieved
and a theorem embedding the inference work so far.
The subgoal package has a current goal state, a stack of
goal states for different main goals, and a buffer of goal states to allow some operations to be undone.
=SEEALSO
$print\_goal\_state$
=ENDDOC
\subsection{Starting the Subgoal Package}
=DOC
val âpush_goalá : GOAL -> unit;
=DESCRIBE
Sets a new current main goal, pushing it
onto the main goal stack.
The current (and only) goal will be the main goal, with label ``1''.
The current subgoal will be displayed.
=FAILURE
30001	the main goal stack is full
30002	the conclusion of the goal, ?0, is not of type BOOL
30003	an assumption of the goal, ?0, is not of type BOOL
30004	two assumption of the goal (?0 and ?1) are %alpha%-convertible
=ENDDOC
=DOC
val âpush_goal_state_thmá : THM -> unit;
=DESCRIBE
Given a theorem that is of the form of a goal state theorem
(e.g. gained by $top\_goal\_state\_thm$, q.v.),
set a new current main goal to be the conclusion of the input theorem
(viewed as a term form goal).
The current goal will be the first assumption of the input theorem, viewed as a term form goal, with label ``1''.
The other assumptions of the theorem will become subsequent goals with labels ``2'',``3'',...
This new goal state is pushed onto the main goal stack.
=USES
For the advanced user, interested in partial proof.
=FAILURE
30001	the main goal stack is full
30005	theorem cannot be viewed as a goal state theorem
=ENDDOC
\subsection{Applying Tactics}
\label{NextGoal}
In discussing the following we need the concept of the {\em next goal}.
The next goal of a goal labelled ``label.n'' is:
\begin{itemize}
\item
If there are yet-to-be-achieved goals labelled ``label.m$<...>$'', where $n\ <\ m$,
then the goal of these labelled with the ``smallest'' suffix will be the next goal.
\item
Otherwise, if there are yet-to-be-achieved goals labelled ``label.m$<...>$'', where $m\ <\ n$,
then the goal of these labelled with the ``smallest'' suffix will be the next goal.
\item
Otherwise the next goal to label ``label.n'' is recursively defined as the ``next'' goal to the label ``label''.
\end{itemize}
Thus is we have the labels ``1.2'',``1.3.1'',``1.3.2'',``2.2'',``3'', and ``4.1'' in a goal state,
then the next label to ``1.3.1'' is ``1.3.2'',
the next to ``1.3.2'' is ``1.3.1'',
the next to ``2.2'' is ``3'',
and the next to ``4.1'' is ``1.2'.
=DOC
val âapply_tacticá : TACTIC -> unit;
val âaá : TACTIC -> unit;
=DESCRIBE
$apply\_tactic$ applies a tactic to the current goal,
and $a$ is an alias for it.
If successful, the previous goal state will be put in the undo buffer, and the new goal state, current goal, etc,
will be based on the tactic's application.
If the tactic returns some subgoals then the ``first'' of these
will become the new current goal.
If there is only one subgoal it will inherit the label of the previous current goal, otherwise if the old label was ``label'' then it will be noted in the goal state as superseded,
and the new subgoals will be labeled ``label.1'', ``label.2'', etc.
If it produces a theorem
that achieves the current goal
(i.e. the list of subgoals is empty), then the ``next'' goal
will become the current one,
(the next goal to a goal of a given label is defined in $set\_next\_goal$)
and the previous goal's label will be noted as achieved.
=FAILURE
30007	there is no current goal
30008	result of tactic did not match current goal
30029	tactic introduced the new assumption ?0 not already in
	the assumption list: the resulting additional goal is:
30030	tactic introduced the new assumption ?0, but the 
	resulting goal is duplicated elsewhere, so not added
30031	tactic produced ?0 duplicate subgoals of the following
	subgoal, labelled : ?2
30032	the following subgoal duplicates some previous goal?0 labelled ?1:
30033	tactic requested the following unnecessary (and unadded) subgoal?0:  ?1
30034	tactic did not change the goal state
30035	current goal achieved, next goal is:
30036	current and main goal achieved
30037	tactic produced ?0 subgoals:
=FAILUREC
Messages 30029 to 30037 are for the users information, and are
not failures.
=ENDDOC
\subsection{The Results of the Package}
=DOC
val âpop_thmá : unit -> THM;
=DESCRIBE
If available, this returns the top achieved theorem
(i.e. the theorem whose sequent is the main goal),
and then pops the previous goal state (if any) of the main goal stack,
restoring its current goal and labelling.
If there is no top achieved theorem the function fails, having no effect.

If the user wishes to examine the top achieved theorem, without
popping the main goal stack they should use $top\_goal\_state\_thm$ and $simplify\_goal\_state\_thm$ (q.v.).
=SEEALSO
$save\_pop\_thm$
=FAILURE
30010	there is no current goal state
30011	there is no top achieved theorem
30024	modify_goal_state_thm has been used on current main goal
=ENDDOC
=DOC
val âsave_pop_thmá : string -> THM;
=DESCRIBE
If available, this returns the top achieved theorem
(i.e. the theorem whose sequent is the main goal)
as well as saving it under the given string key on the current theory,
and then pops the previous goal state (if any) of the main goal stack,
restoring its current goal and labelling.
If there is no top achieved theorem, or the key is already used in the current theory, the function fails, having no effect.
=FAILURE
30010	there is no current goal state
30011	there is no top achieved theorem
30023	the key ?0 is already used in theory ?1
30024	modify_goal_state_thm has been used on current main goal
=ENDDOC
=DOC
val âtop_goal_state_thmá : unit -> THM;
=DESCRIBE
This returns the goal state theorem of the current goal state.
It is a partial proof of the main goal, though in a somewhat unwieldy form,
as it encodes the main goal, and its other goals in a term form.
It may be simplified by using $simplify\_goal\_state\_thm$(q.v).
The theorem is suitable for setting a new main goal, by using $push\_goal\_state\_thm\_as\_goal$(q.v).
=USES
For the advanced user, interested in partial proofs.
=FAILURE
30010	there is no current goal state
30024	modify_goal_state_thm has been used on current main goal
30038	goal state has achieved its theorem
=FAILUREC
Message 30038 is for the users information, and is not a failure.
=ENDDOC
=DOC
val âsimplify_goal_state_thmá : THM -> THM;
=DESCRIBE
This will simplify a goal state theorem
(e.g from $top\_goal\_state\_thm$, q.v.), stripping off assumptions from the conclusion of the theorem up to the turnstile place marker, then removing the place marker itself in both conclusion and assumptions.
=USES
For the advanced user, interested in partial proofs.
=FAILURE
30005	theorem cannot be viewed as a goal state theorem
=ENDDOC
=DOC
val âdrop_main_goalá : unit -> unit;
=DESCRIBE
Pop the previous goal state (if any) from the main goal stack,
throwing away any work on the current main goal.
=FAILURE
30010	there is no current goal state
=ENDDOC
\subsection{Undoing and Redoing}
=DOC
val âundoá : int -> unit;
=DESCRIBE
$undo$ $n$ will take the $n$th entry from the undo buffer, if there are sufficient,
as the current goal state.
$undo$ $0$ has no effect.
Attempting to go past the end of the buffer will cause a failure, rather than a partial undoing.
A single $undo$ can itself be undone by $redo$(q.v),
but otherwise entries on the undo buffer between its start and the $n$th entry will be discarded.
=FAILURE
30010	there is no current goal state
30012	attempted to undo ?0 times when there are only ?1 entries in the undo buffer
30013	cannot undo a negative number of times
=ENDDOC
=DOC
val âredoá : unit -> unit;
=DESCRIBE
If the last command to affect the goal state was an $undo$(q.v)
then this command will undo its effect
(including leaving the undo buffer in its previous form,
without mention of the $undo$ or $redo$).
=FAILURE
30014	the last command to affect the goal state was not an undo
=ENDDOC
\subsection{Navigation}
=DOC
val âset_labelled_goalá : string -> unit;
=DESCRIBE
If the string is valid label in the current goal state,
then set the corresponding goal as the current goal,
and then display it.
=FAILURE
30016	?0 is not of the form "n1.n2....nm"
30017	label ?0 has no corresponding goal
30018	the goal labelled ?0 has been reduced to its subgoals ?1
30019	the goal labelled ?0 has been achieved
=ENDDOC
\subsection{Changing Goal States}
=DOC
val âtop_goal_stateá : unit -> GOAL_STATE;
=DESCRIBE
This provides the current goal state as a value.
=SEEALSO
$push\_goal\_state$
=FAILURE
30010	there is no current goal state
=ENDDOC
=DOC
val âpush_goal_stateá : GOAL_STATE -> unit;
=DESCRIBE
If the value given is ``well-formed'', then this function pushes the current goal state onto the main goal stack,
and sets the given value as the current goal state.
The most likely reason that a goal state value is ill-formed
is that it is not being pushed in the same context as it was formed, e.g. it was formed in a theory that is now out of scope.
=SEEALSO
$top\_goal\_state$
=FAILURE
30001	the main goal stack is full
30022	goal state is ill-formed
=ENDDOC
\subsection{Modifying the Goal State Theorem}
=DOC
val âmodify_goal_state_thmá : (THM -> THM) -> unit;
=DESCRIBE
A rather drastic hook into the subgoal package that works as follows:
\begin{enumerate}
\item
Extract the goal state theorem
\item
Apply a user-supplied inference rule to the theorem.
\item
Set the resulting theorem as if by $push\_goal\_state\_thm$,
Thus the goals will be relabelled as all being
``top level'' ones.
\item
Keep the old undo list, so this hook's effect can be undone.
This step could not be mimicked by other functions available to the user.
\end{enumerate}

This will issue a warning on its use, and on attempting to extract 
an achieved, or goal state, theorem from a goal state that
is derived from the modified one,
as it may alter the original main goal, so that the result of an apparently successful $pop\_thm$ might not be
an achievement of the original main goal.
=USES
Two example uses of it are:
\begin{enumerate}
\item
Add an assumption to the main goal ``on the fly''.
This would involve adding the assumption to the
conclusion of the goal state theorem,
as well as to each goal's assumption list (held in a term form).
This will save on having to restart the subgoal package if the original main
goal was not satisfiable, but an additional assumption
would allow it to become so.
\item
Combine two goals into one, by having the inference rule
``merge'' the two assumptions representing the goals,
into a single  term form goal.
\end{enumerate}
This is intended for system builders wishing to write extensions to the
subgoal package.
=FAILURE
30024	modify_goal_state_thm has been used on current main goal
=ENDDOC
\subsection{Information Requests}
=DOC
val âtop_main_goalá : unit -> GOAL;
=DESCRIBE
Return the current main goal: the objective of the current proof attempt.
=FAILURE
30025	there is no current main goal
=ENDDOC
=DOC
val âtop_current_goalá : unit -> GOAL;
=DESCRIBE
Returns the current goal: the goal to which a tactic will be applied.
=FAILURE
30026	there is no current goal
=ENDDOC
=DOC
val âtop_current_labelá : unit -> string;
=DESCRIBE
Returns the label of the current goal: the goal to which a tactic will be applied.
=FAILURE
30026	there is no current goal
=ENDDOC
=DOC
val âtop_labelled_goalá : string -> GOAL;
=DESCRIBE
Returns the goal with the given label, should it exist in the current goal state.
Note that superseded and achieved goals are not available from the goal state.
=FAILURE
30016	?0 is not of the form "n1.n2....nm"
30017	label ?0 has no corresponding goal
30018	the goal labelled ?0 has been reduced to its subgoals ?1
30019	the goal labelled ?0 has been achieved
=ENDDOC
=DOC
val âget_asmá : int -> TERM;
=DESCRIBE
$get\_asm$ $n$ returns the $n$th assumption of the current goal.
=FAILURE
30026	there is no current goal
30027	there is no ?0 th assumption in the current goal
=ENDDOC
=DOC
val âtop_goalsá : unit -> (string list * GOAL)list;
=DESCRIBE
Returns all the goals yet to be achieved, and their associated labels, in the current goal state.
=USES
To determine what goals are left to achieve.
=FAILURE
30010	there is no current goal state
=ENDDOC
=DOC
val âprint_goal_stateá : GOAL_STATE -> unit;
=DESCRIBE
Print out user-orientated details of the given goal state.
=FAILURE
=ENDDOC
\subsection{Parameterising the Subgoal Package}
=DOC
(* âmain_goal_stack_lengthá : int *)
=DESCRIBE
This is a system control, handled by $set\_int\_control$, etc,
which sets the maximum number of entries that can be held on
the main goal stack: i.e. how many $push\_goal$ calls may be stacked before failure.
This value includes counting the current goal state, that is
at the top of the stack.
It is initially set at 4.
The control can neither be set to less than 1, nor to less than the current
number of entries currently on the stack.
=ENDDOC
=DOC
(* âundo_buffer_lengthá : int *)
=DESCRIBE
This is a system control, handled by $set\_int\_control$, etc,
which sets the maximum number of entries that can be held on
the undo buffer: i.e. how many tactic applications, etc, may be undone
It is initially set to 12,
and cannot be made negative.
=ENDDOC

\section{END OF THE SIGNATURE}
=SML
end; (* signature of SubgoalPackage *)
=TEX
\section{TEST POLICY}
The functions in this document should be tested according to the criteria given in
\cite{DS/FMU/IED/PLN008}.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
