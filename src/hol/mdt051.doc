=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Proof Contexts}  %% Mandatory field
\def\TPPheadtitle{Module Tests for Proof Contexts}
\TPPref{DS/FMU/IED/MDT051}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the 
proof context functions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1]
First draft version.
\item [Issue 1.2]
Reacted to $NetTools$ being open.
\item [Issue 1.3]
Proof context becomes an ADT.
\item [Issue 1.4]
Fixed bug in $thm\_eqn\_cxt$ tests.
\item [Issue 1.5]
Added $cs\_¶\_rule$ material.
\item [Issue 1.6]
Added existence prover parameterisation.

\item[Issue 1.7, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.8]
Removed duplicate labels.

\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the proof context functions.
The design is in \cite{DS/FMU/IED/DTD051}
and it is
implemented in \cite{DS/FMU/IED/IMP051}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD051},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD051},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP051}.
It requires the presence of theory ``$î$'',
and the initial stripping context $initial\_strip\_epc$.
\subsubsection{Deficiencies}

\section{TEST HARNESS MATERIAL}
=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results ();
open_theory "î";
=TEX
\section{TEST DATA}
This section contains data used in the test, that
in themselves are not part of the tests.
However, they may fail if the functions tested are ill-formed.
=SML
val epc : EPROOF_CONTEXT = 
	set_epc_name "epc"
	(set_epc_rw_net (make_net [(¬x+y®,plus_conv)])
	(set_epc_rw_canon (fn thm => [thm,thm])
	(set_epc_sg_conv suc_conv
	(set_epc_cs_¶_rule (fn tm => if tm = mk_t then t_thm else 
		fail "cs_¶_rule" 0 [])
	(set_epc_¶_vs_thm [("vs",([],t_thm))]
	(set_epc_¶_cd_thm [([],[],BOOL,[],t_thm)]
	(set_epc_st_conv simple_%beta%_conv initial_epc)))))));
val pc : PROOF_CONTEXT = 
	set_pc_name "pc"
	(set_pc_rw_eqn_cxt [(¬x+y®,plus_conv),(¬5®,suc_conv),(¬6®,suc_conv)]
	(set_pc_rw_canons [fn thm => [thm,thm]]
	(set_pc_sg_eqn_cxt [(¬5®,suc_conv),(¬6®,suc_conv)]
	(set_pc_cs_¶_rule (fn tm => if tm = mk_t then t_thm else 
		fail "cs_¶_rule" 0 [])
	(set_pc_¶_vs_thm [("vs",([],t_thm))]
	(set_pc_¶_cd_thm [t_thm]
	(set_pc_st_eqn_cxt [(¬3®,suc_conv)] initial_pc)))))));

val beta_redex = ¬(Ì x · (x ´ F)) T®;
=TEX
We wish to start with the initial proof context, so
=SML
repeat pop_proof_context;
=TEX
\section{THE TESTS}
\subsection{Equational Contexts}
=SML
store_mt_results mt_run [("thm_eqn_cxt",
	(Combinators.I ** (fn f => snd(dest_thm (f ¬y®))))
		o thm_eqn_cxt,
	all_µ_intro (refl_conv ¬x®),
	(¬x®,¬y = y®))];
store_mt_results mt_run_fail [("thm_eqn_cxt 7095",
	thm_eqn_cxt,
	t_thm,
	gen_fail_msg "thm_eqn_cxt" 7095 ["ô T"])];
=TEX
=SML
let
	val sideeffect = push_proof_context initial_strip_epc;
	val thm = tac_proof(([],¬µ x · (x ± x) ¤ x®),
		REPEAT strip_tac);
	val sideeffect = pop_proof_context();
in
store_mt_results mt_run [("eqn_cxt_conv",
	dest_thm o eqn_cxt_conv [thm_eqn_cxt thm],
	¬y ± y®,
	([],¬y ± y ¤ y®))]
end;
store_mt_results mt_run_fail [("eqn_cxt_conv 51005",
	eqn_cxt_conv [],
	¬y®,
	gen_fail_msg "eqn_cxt_conv" 51005 ["¬y®"])];
=TEX
\subsection{Proof Contexts}

=SML
store_mt_results mt_run [
	("get_pc_rw_eqn_cxt",
	length o get_pc_rw_eqn_cxt,
	pc,
	3)];
store_mt_results mt_run [
	("get_pc_st_eqn_cxt",
	length o get_pc_st_eqn_cxt,
	pc,
	1)];
store_mt_results mt_run [
	("get_pc_sg_eqn_cxt",
	length o get_pc_sg_eqn_cxt,
	pc,
	2)];
store_mt_results mt_run [
	("get_pc_rw_canons",
	length o get_pc_rw_canons,
	pc,
	1)];
store_mt_results mt_run [
	("get_pc_name",
	get_pc_name,
	pc,
	"pc")];
store_mt_results mt_run [
	("get_pc_cs_¶_rule",
	dest_thm o get_pc_cs_¶_rule pc,
	mk_t,
	([],¬T®))];
store_mt_results mt_run [
	("get_pc_¶_vs_thm",
	fst o hd o get_pc_¶_vs_thm,
	pc,
	"vs")];
store_mt_results mt_run [
	("get_epc_¶_vs_thm",
	fst o hd o get_epc_¶_vs_thm,
	epc,
	"vs")];
store_mt_results mt_run [
	("get_pc_¶_cd_thm",
	dest_thm o hd o get_pc_¶_cd_thm,
	pc,
	([],¬T®))];
store_mt_results mt_run [
	("get_epc_¶_cd_thm",
	(fn (_,_,ty,_,_) => ty) o hd o get_epc_¶_cd_thm,
	epc,
	BOOL)];
=TEX
$push/pop/get\_proof\_context$ and $initial\_epc$ are implicitly tested by the following:
=SML
store_mt_results mt_run [
	("?_proof_context 1",
	dest_thm o TRY_C(get_epc_st_conv (get_proof_context())),
	beta_redex,
	dest_thm(id_conv beta_redex))];
push_proof_context epc;
store_mt_results mt_run [
	("?_proof_context 2a",
	dest_thm o get_epc_st_conv (get_proof_context()),
	beta_redex,
	dest_thm(simple_%beta%_conv beta_redex))];
store_mt_results mt_run [
	("?_proof_context 2b",
	dest_thm o get_epc_sg_conv (get_proof_context()),
	¬2®,
	dest_thm(suc_conv ¬2®))];
store_mt_results mt_run [
	("?_proof_context 2c",
	dest_thm o hd(net_lookup (get_epc_rw_net (get_proof_context()))¬2 + 3®),
	¬2 + 3®,
	dest_thm(plus_conv ¬2+3®))];
store_mt_results mt_run [
	("?_proof_context 2d",
	length o get_epc_rw_canon (get_proof_context()),
	t_thm,
	2)];
store_mt_results mt_run [
	("?_proof_context 2e",
	get_epc_name,
	get_proof_context(),
	"epc")];
store_mt_results mt_run [
	("get_epc_cs_¶_rule",
	dest_thm o get_epc_cs_¶_rule (get_proof_context()),
	mk_t,
	([],¬T®))];
val epc1 = pop_proof_context ();
store_mt_results mt_run [
	("?_proof_context 3",
	dest_thm o TRY_C(get_epc_st_conv (get_proof_context())),
	beta_redex,
	dest_thm(id_conv beta_redex))];
push_proof_context epc1;
store_mt_results mt_run [
	("?_proof_context 4",
	dest_thm o get_epc_st_conv (get_proof_context()),
	beta_redex,
	dest_thm(simple_%beta%_conv beta_redex))];
val epc2 = pop_proof_context ();
store_mt_results mt_run_fail [
	("pop_proof_context 51001",
	pop_proof_context,
	(),
	gen_fail_msg "pop_proof_context" 51001 [])
	];
=TEX
\subsection{End of Tests}
=SML
diag_string(summarize_mt_results ());
=TEX
\end{document}


