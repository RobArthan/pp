% mdt051.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Proof Contexts}  %% Mandatory field
\def\TPPheadtitle{Module Tests for Proof Contexts}
\TPPref{DS/FMU/IED/MDT051}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the 
proof context functions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1]
First draft version.
\item [Issue 1.2]
Reacted to $NetTools$ being open.
\item [Issue 1.3]
Proof context becomes an ADT.
\item [Issue 1.4]
Fixed bug in $thm\_eqn\_cxt$ tests.
\item [Issue 1.5]
Added $cs\_¶\_rule$ material.
\item [Issue 1.6]
Added existence prover parameterisation.

\item[Issue 1.7, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.8]
Removed duplicate labels.
\item [Issue 1.9]
Changed to reflect changes in issue 1.12 of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.10,1.11 (9th April 1992)]
Changes required by CR0016.
\item [Issue 1.14 (14th April 1992)]
Changes required by CR0017.
\item [Issue 1.15 (15th April 1992)]
Change to $show\_stack\_pcs$, added $delete_pc\_fields$.
\item [Issue 1.16 (22 April 1992)]
Fix test $eqn_cxt_conv$ to make it work.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the proof context functions.
The design is in \cite{DS/FMU/IED/DTD051}
and it is
implemented in \cite{DS/FMU/IED/IMP051}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD051},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD051},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP051}.
It requires the presence of theory ``$misc$'',
and the initial stripping context $initial\_strip$ to test the erquational contexts.
\subsubsection{Deficiencies}
\section{TEST CASES}
All functions and all their error cases are tested, but
the precise order and method of testing is not uniform,
and in particular does not follow the order in \cite{DS/FMU/IED/DTD051}.
\section{TEST HARNESS MATERIAL}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results ();
open_theory "misc";
=TEX
=SML
fun list_eq (eq:'a * 'a -> bool) ((a :: x), (b :: y)) : bool = (
	eq(a,b) andalso list_eq eq (x, y)
) | list_eq eq ([], []) = true
| list_eq _ _ = false;
=TEX
=SML
infix 3 =**$;
fun (a,b) =**$ (c,d) = (a =$ c) andalso (b =$ d);
=TEX
\section{TEST DATA}
This section contains data used in the test, that
in themselves are not part of the tests.
However, they may fail if the functions tested are ill-formed.
=SML

val tm_a = mk_var("a",BOOL);
val tm_³_b = mk_³(mk_var("b",BOOL));
val tm_cc = mk_±(mk_var("c",BOOL),mk_var("c",BOOL));
val conv1 = (fn tm => if tm =$ tm_a
		then ¤_t_intro (asm_rule tm_a)
		else fail_conv tm);
val conv2 = (fn tm => if tm =$ tm_³_b
		then ¤_t_intro (asm_rule tm_³_b)
		else fail_conv tm);
val conv3 = (fn tm => if tm =$ tm_cc
		then ¤_t_intro (asm_rule tm_cc)
		else fail_conv tm);
val rule1 = (fn tm => if tm =$ mk_t then t_thm else fail "rule1" 0 []);
val rule2 = (fn tm => if tm =$ mk_³ mk_f then f_thm else fail "rule2" 0 []);

=TEX
\section{THE TESTS}
\subsection{Equational Contexts}
=SML
push_pc "initial";
store_mt_results (mt_runf (op =**$))[("thm_eqn_cxt",
	(Combinators.I ** (fn f => snd(dest_thm (f ¬y®))))
		o thm_eqn_cxt,
	all_µ_intro (refl_conv ¬x®),
	(¬x®,¬y = y®))];
store_mt_results mt_run_fail [("thm_eqn_cxt 7095",
	thm_eqn_cxt,
	t_thm,
	gen_fail_msg "thm_eqn_cxt" 7095 ["ô T"])];
=TEX
=SML
let
	val thm = tac_proof(([],¬µ x · (x ± x) ¤ x®),
		pure_rewrite_tac(
			(map (simple_µ_intro¬t:BOOL®)
			(strip_±_rule(all_simple_µ_elim ±_rewrite_thm)))
			@ [eq_rewrite_thm,µ_rewrite_thm]));
in
store_mt_results (mt_runf (op =#))[("eqn_cxt_conv",
	dest_thm o eqn_cxt_conv [thm_eqn_cxt thm],
	¬y ± y®,
	([],¬y ± y ¤ y®))]
end;
store_mt_results mt_run_fail [("eqn_cxt_conv 51005",
	eqn_cxt_conv [],
	¬y®,
	gen_fail_msg "eqn_cxt_conv" 51005 ["¬y®"])];
=TEX
\subsection{Proof Contexts}
We wish to start with the initial proof context, so
=SML
repeat pop_pc;
mapfilter (delete_pc o fst) (show_pcs ());
=TEX
We wish to start with the original (flawed) evaluation functions:
=SML
icl'set_eval_ad_rw_net make_net;
icl'set_eval_ad_rw_canon (fn cans => (hd cans
	handle _ => (fn thm => [thm])) );
icl'set_eval_ad_st_conv eqn_cxt_conv;
icl'set_eval_ad_sg_conv eqn_cxt_conv;

let
	fun try_all [] tm = fail "current_ad_cs_¶_conv" 51015 []
	| try_all (afun :: x) tm = (
		afun tm
		handle (Fail _) =>
		try_all x tm
	);
in
icl'set_eval_ad_cs_¶_convs try_all
end;
	
icl'set_eval_ad_¶_cd_thms (fn _ => []);
icl'set_eval_ad_¶_vs_thms  Combinators.I;
=TEX
We form new proof contexts:
=SML
new_pc "mdt051_test1";
set_rw_eqn_cxt [(tm_a,conv1)] "mdt051_test1";
set_rw_canons [(fn thm => [thm,thm])] "mdt051_test1";
set_st_eqn_cxt [(tm_a,conv1)] "mdt051_test1";
set_sg_eqn_cxt [(tm_a,conv1)] "mdt051_test1";
set_cs_¶_convs [rule1] "mdt051_test1";
set_¶_cd_thms [t_thm] "mdt051_test1";
set_¶_vs_thms [("T",([mk_t],t_thm))] "mdt051_test1";
commit_pc "mdt051_test1";
=TEX
=SML
new_pc "mdt051_test2";
set_rw_eqn_cxt [(tm_³_b,conv2)] "mdt051_test2";
set_rw_canons [(fn thm => if thm =|- t_thm
		then [] else [thm])] "mdt051_test2";
set_st_eqn_cxt [(tm_³_b,conv2)] "mdt051_test2";
set_sg_eqn_cxt [(tm_³_b,conv2)] "mdt051_test2";
set_cs_¶_convs [rule2] "mdt051_test2";
set_¶_cd_thms [f_thm] "mdt051_test2";
set_¶_vs_thms [("F",([mk_f],f_thm))] "mdt051_test2";
=TEX
=SML
new_pc "mdt051_test3";
set_rw_eqn_cxt [(tm_³_b,conv2)] "mdt051_test3";
set_rw_canons [(fn thm => if thm =|- t_thm
		then [] else [thm])] "mdt051_test3";
set_st_eqn_cxt [(tm_³_b,conv2)] "mdt051_test3";
set_sg_eqn_cxt [(tm_³_b,conv2)] "mdt051_test3";
set_cs_¶_convs [rule2] "mdt051_test3";
set_¶_cd_thms [f_thm] "mdt051_test3";
set_¶_vs_thms [("F",([mk_f],f_thm))] "mdt051_test3";
commit_pc "mdt051_test3";

=TEX

\subsubsection{Set and Get User Data Functions}
=SML
open Combinators;
store_mt_results (mt_runf (op =#))[
	("get_rw_eqn_cxt",
	dest_thm o (snd(hd(fst(hd (get_rw_eqn_cxt "mdt051_test1"))))),
	tm_a,
	dest_thm (conv1 tm_a))];
store_mt_results (mt_runf (list_eq(op =#))) [
	("get_rw_canons",
	map dest_thm o (hd(fst(hd (get_rw_canons "mdt051_test1")))),
	t_thm,
	map dest_thm [t_thm,t_thm])];
store_mt_results (mt_runf (op =#))[
	("get_st_eqn_cxt",
	dest_thm o (snd(hd(fst(hd (get_st_eqn_cxt "mdt051_test1"))))),
	tm_a,
	dest_thm (conv1 tm_a))];
store_mt_results (mt_runf (op =#))[
	("get_sg_eqn_cxt",
	dest_thm o (snd(hd(fst(hd (get_sg_eqn_cxt "mdt051_test1"))))),
	tm_a,
	dest_thm (conv1 tm_a))];
store_mt_results (mt_runf (op =#))[
	("get_cs_¶_convs",
	dest_thm o hd(fst(hd (get_cs_¶_convs "mdt051_test1"))),
	mk_t,
	dest_thm t_thm)];
store_mt_results (mt_runf (op =#))[
	("get_¶_cd_thms",
	dest_thm,
	hd(get_¶_cd_thms "mdt051_test1"),
	dest_thm t_thm)];
let
fun aux ((a,(b,c)),(d,(e,f))) = (a=d) andalso list_eq (op =$) (b,e)
	andalso (c =|- f);
in
store_mt_results (mt_runf aux)[
	("get_¶_vs_thms",
	hd,
	(get_¶_vs_thms "mdt051_test1"),
	("T",([mk_t],t_thm)))]
end;
=TEX
=SML
store_mt_results mt_run_fail [(
	"get_rw_eqn_cxt 51010",
	get_rw_eqn_cxt,
	"rubbish",
	gen_fail_msg "get_rw_eqn_cxt" 51010 ["rubbish"])];
store_mt_results mt_run_fail [(
	"get_rw_canons 51010",
	get_rw_canons,
	"rubbish",
	gen_fail_msg "get_rw_canons" 51010 ["rubbish"])];
store_mt_results mt_run_fail [(
	"get_st_eqn_cxt 51010",
	get_st_eqn_cxt,
	"rubbish",
	gen_fail_msg "get_st_eqn_cxt" 51010 ["rubbish"])];
store_mt_results mt_run_fail [(
	"get_sg_eqn_cxt 51010",
	get_sg_eqn_cxt,
	"rubbish",
	gen_fail_msg "get_sg_eqn_cxt" 51010 ["rubbish"])];
store_mt_results mt_run_fail [(
	"get_cs_¶_convs 51010",
	get_cs_¶_convs,
	"rubbish",
	gen_fail_msg "get_cs_¶_convs" 51010 ["rubbish"])];
store_mt_results mt_run_fail [(
	"get_¶_cd_thms 51010",
	get_¶_cd_thms,
	"rubbish",
	gen_fail_msg "get_¶_cd_thms" 51010 ["rubbish"])];
store_mt_results mt_run_fail [(
	"get_¶_vs_thms 51010",
	get_¶_vs_thms,
	"rubbish",
	gen_fail_msg "get_¶_vs_thms" 51010 ["rubbish"])];
=TEX
=SML
store_mt_results mt_run_fail [(
	"set_rw_eqn_cxt 51010",
	set_rw_eqn_cxt [(tm_a,conv1)],
	"rubbish",
	gen_fail_msg "set_rw_eqn_cxt" 51010 ["rubbish"])];
store_mt_results mt_run_fail [(
	"set_rw_canons 51010",
	set_rw_canons [(fn thm => [thm,thm])],
	"rubbish",
	gen_fail_msg "set_rw_canons" 51010 ["rubbish"])];
store_mt_results mt_run_fail [(
	"set_st_eqn_cxt 51010",
	set_st_eqn_cxt [(tm_a,conv1)],
	"rubbish",
	gen_fail_msg "set_st_eqn_cxt" 51010 ["rubbish"])];
store_mt_results mt_run_fail [(
	"set_sg_eqn_cxt 51010",
	set_sg_eqn_cxt [(tm_a,conv1)],
	"rubbish",
	gen_fail_msg "set_sg_eqn_cxt" 51010 ["rubbish"])];
store_mt_results mt_run_fail [(
	"set_cs_¶_convs 51010",
	set_cs_¶_convs [rule1],
	"rubbish",
	gen_fail_msg "set_cs_¶_convs" 51010 ["rubbish"])];
store_mt_results mt_run_fail [(
	"set_¶_cd_thms 51010",
	set_¶_cd_thms [t_thm],
	"rubbish",
	gen_fail_msg "set_¶_cd_thms" 51010 ["rubbish"])];
store_mt_results mt_run_fail [(
	"set_¶_vs_thms 51010",
	set_¶_vs_thms [("T",([mk_t],t_thm))],
	"rubbish",
	gen_fail_msg "set_¶_vs_thms" 51010 ["rubbish"])];
=TEX
=SML
store_mt_results mt_run_fail [(
	"set_rw_eqn_cxt 51016",
	set_rw_eqn_cxt [(tm_a,conv1)],
	"mdt051_test1",
	gen_fail_msg "set_rw_eqn_cxt" 51016 ["mdt051_test1"])];
store_mt_results mt_run_fail [(
	"set_rw_canons 51016",
	set_rw_canons [(fn thm => [thm,thm])],
	"mdt051_test1",
	gen_fail_msg "set_rw_canons" 51016 ["mdt051_test1"])];
store_mt_results mt_run_fail [(
	"set_st_eqn_cxt 51016",
	set_st_eqn_cxt [(tm_a,conv1)],
	"mdt051_test1",
	gen_fail_msg "set_st_eqn_cxt" 51016 ["mdt051_test1"])];
store_mt_results mt_run_fail [(
	"set_sg_eqn_cxt 51016",
	set_sg_eqn_cxt [(tm_a,conv1)],
	"mdt051_test1",
	gen_fail_msg "set_sg_eqn_cxt" 51016 ["mdt051_test1"])];
store_mt_results mt_run_fail [(
	"set_cs_¶_convs 51016",
	set_cs_¶_convs [rule1],
	"mdt051_test1",
	gen_fail_msg "set_cs_¶_convs" 51016 ["mdt051_test1"])];
store_mt_results mt_run_fail [(
	"set_¶_cd_thms 51016",
	set_¶_cd_thms [t_thm],
	"mdt051_test1",
	gen_fail_msg "set_¶_cd_thms" 51016 ["mdt051_test1"])];
store_mt_results mt_run_fail [(
	"set_¶_vs_thms 51016",
	set_¶_vs_thms [("T",([mk_t],t_thm))],
	"mdt051_test1",
	gen_fail_msg "set_¶_vs_thms" 51016 ["mdt051_test1"])];
=TEX
Now test the scoping:
=SML
open_theory "hol";
new_pc "pc out of scope";
open_theory "misc";
=TEX
=SML
store_mt_results mt_run_fail [(
	"get_rw_eqn_cxt 51014",
	get_rw_eqn_cxt,
	"pc out of scope",
	gen_fail_msg "get_rw_eqn_cxt" 51014 ["pc out of scope","hol"])];
store_mt_results mt_run_fail [(
	"get_rw_canons 51014",
	get_rw_canons,
	"pc out of scope",
	gen_fail_msg "get_rw_canons" 51014 ["pc out of scope","hol"])];
store_mt_results mt_run_fail [(
	"get_st_eqn_cxt 51014",
	get_st_eqn_cxt,
	"pc out of scope",
	gen_fail_msg "get_st_eqn_cxt" 51014 ["pc out of scope","hol"])];
store_mt_results mt_run_fail [(
	"get_sg_eqn_cxt 51014",
	get_sg_eqn_cxt,
	"pc out of scope",
	gen_fail_msg "get_sg_eqn_cxt" 51014 ["pc out of scope","hol"])];
store_mt_results mt_run_fail [(
	"get_cs_¶_convs 51014",
	get_cs_¶_convs,
	"pc out of scope",
	gen_fail_msg "get_cs_¶_convs" 51014 ["pc out of scope","hol"])];
store_mt_results mt_run_fail [(
	"get_¶_cd_thms 51014",
	get_¶_cd_thms,
	"pc out of scope",
	gen_fail_msg "get_¶_cd_thms" 51014 ["pc out of scope","hol"])];
store_mt_results mt_run_fail [(
	"get_¶_vs_thms 51014",
	get_¶_vs_thms,
	"pc out of scope",
	gen_fail_msg "get_¶_vs_thms" 51014 ["pc out of scope","hol"])];
=TEX
=SML
store_mt_results mt_run_fail [(
	"set_rw_eqn_cxt 51014",
	set_rw_eqn_cxt [(tm_a,conv1)],
	"pc out of scope",
	gen_fail_msg "set_rw_eqn_cxt" 51014 ["pc out of scope","hol"])];
store_mt_results mt_run_fail [(
	"set_rw_canons 51014",
	set_rw_canons [(fn thm => [thm,thm])],
	"pc out of scope",
	gen_fail_msg "set_rw_canons" 51014 ["pc out of scope","hol"])];
store_mt_results mt_run_fail [(
	"set_st_eqn_cxt 51014",
	set_st_eqn_cxt [(tm_a,conv1)],
	"pc out of scope",
	gen_fail_msg "set_st_eqn_cxt" 51014 ["pc out of scope","hol"])];
store_mt_results mt_run_fail [(
	"set_sg_eqn_cxt 51014",
	set_sg_eqn_cxt [(tm_a,conv1)],
	"pc out of scope",
	gen_fail_msg "set_sg_eqn_cxt" 51014 ["pc out of scope","hol"])];
store_mt_results mt_run_fail [(
	"set_cs_¶_convs 51014",
	set_cs_¶_convs [rule1],
	"pc out of scope",
	gen_fail_msg "set_cs_¶_convs" 51014 ["pc out of scope","hol"])];
store_mt_results mt_run_fail [(
	"set_¶_cd_thms 51014",
	set_¶_cd_thms [t_thm],
	"pc out of scope",
	gen_fail_msg "set_¶_cd_thms" 51014 ["pc out of scope","hol"])];
store_mt_results mt_run_fail [(
	"set_¶_vs_thms 51014",
	set_¶_vs_thms [("T",([mk_t],t_thm))],
	"pc out of scope",
	gen_fail_msg "set_¶_vs_thms" 51014 ["pc out of scope","hol"])];
=TEX
\subsubsection{Adding Functions}
=SML
add_rw_thms [±_thm] "mdt051_test2";
add_st_thms [±_thm] "mdt051_test2";
add_sg_thms [±_thm] "mdt051_test2";
add_¶_cd_thms [±_thm] "mdt051_test2";
val cc' = ¬c ± c ¤ (µ b· (c ´ c ´ b) ´ b)®;
=TEX
=SML
store_mt_results (mt_runf (op =$))[
	("get_rw_eqn_cxt a",
	concl o (snd(hd(fst(hd (get_rw_eqn_cxt "mdt051_test2"))))),
	tm_cc,
	cc')];
store_mt_results (mt_runf (op =$))[
	("get_st_eqn_cxt a",
	concl o (snd(hd(fst(hd (get_st_eqn_cxt "mdt051_test2"))))),
	tm_cc,
	cc')];
store_mt_results (mt_runf (op =$))[
	("get_sg_eqn_cxt a",
	concl o (snd(hd(fst(hd (get_sg_eqn_cxt "mdt051_test2"))))),
	tm_cc,
	cc')];
store_mt_results (mt_runf (op =#))[
	("get_¶_cd_thms a",
	dest_thm,
	hd(get_¶_cd_thms "mdt051_test2"),
	dest_thm ±_thm)];
=TEX
=SML
store_mt_results mt_run_fail [(
	"add_rw_thms 51010",
	add_rw_thms [],
	"rubbish1",
	gen_fail_msg "add_rw_thms" 51010 ["rubbish1"]),
	("add_rw_thms 51014",
	add_rw_thms [],
	"pc out of scope",
	gen_fail_msg "add_rw_thms" 51014 ["pc out of scope","hol"])];
store_mt_results mt_run_fail [(
	"add_st_thms 51010",
	add_st_thms [],
	"rubbish1",
	gen_fail_msg "add_st_thms" 51010 ["rubbish1"]),
	("add_st_thms 51014",
	add_st_thms [],
	"pc out of scope",
	gen_fail_msg "add_st_thms" 51014 ["pc out of scope","hol"])];
store_mt_results mt_run_fail [(
	"add_sg_thms 51010",
	add_sg_thms [],
	"rubbish1",
	gen_fail_msg "add_sg_thms" 51010 ["rubbish1"]),
	("add_sg_thms 51014",
	add_sg_thms [],
	"pc out of scope",
	gen_fail_msg "add_sg_thms" 51014 ["pc out of scope","hol"])];
store_mt_results mt_run_fail [(
	"add_¶_cd_thms 51010",
	add_¶_cd_thms [],
	"rubbish1",
	gen_fail_msg "add_¶_cd_thms" 51010 ["rubbish1"]),
	("add_¶_cd_thms 51014",
	add_¶_cd_thms [],
	"pc out of scope",
	gen_fail_msg "add_¶_cd_thms" 51014 ["pc out of scope","hol"])];
=TEX
\subsubsection{Current Values}
``mdt051$\_$test1'' has been evaluated by commital, so:
=SML
push_pc "mdt051_test1";
let
val rw_net1 = current_ad_rw_net ();
in
store_mt_results (mt_runf (op =#))[(
	"current_ad_rw_net",
	dest_thm o (hd(net_lookup rw_net1 tm_a)),
	tm_a,
	dest_thm (conv1 tm_a))]
end;
store_mt_results mt_run [(
	"current_ad_rw_canon",
	length,
	(current_ad_rw_canon () t_thm),
	2)];
store_mt_results (mt_runf (op =#))[(
	"current_ad_st_conv",
	dest_thm o current_ad_st_conv (),
	tm_a,
	dest_thm (conv1 tm_a))];
store_mt_results (mt_runf (op =#))[(
	"current_ad_sg_conv",
	dest_thm o current_ad_sg_conv (),
	tm_a,
	dest_thm (conv1 tm_a))];
store_mt_results (mt_runf (op =#))[(
	"current_ad_cs_¶_conv",
	dest_thm o current_ad_cs_¶_conv (),
	mk_t,
	dest_thm t_thm)];
store_mt_results mt_run [
	("current_ad_¶_cd_thms",
	length,
	current_ad_¶_cd_thms (),
	0)];
store_mt_results mt_run [
	("current_ad_¶_vs_thms",
	length,
	current_ad_¶_vs_thms (),
	1)];
=TEX
\subsubsection{Merging Proof Contexts}
Notice the crude tests of duplicate removal.
=SML
new_pc "merge1 & 3";
merge_pcs ["mdt051_test1","mdt051_test1","mdt051_test3"] "merge1 & 3";
store_mt_results mt_run [("merge_pcs 1",
	length,
	get_rw_eqn_cxt "merge1 & 3",
	2)];
store_mt_results mt_run [("merge_pcs 2",
	length,
	get_rw_canons "merge1 & 3",
	2)];
store_mt_results mt_run [("merge_pcs 3",
	length,
	get_st_eqn_cxt "merge1 & 3",
	2)];
store_mt_results mt_run [("merge_pcs 4",
	length,
	get_sg_eqn_cxt "merge1 & 3",
	2)];
store_mt_results mt_run [("merge_pcs 5",
	length,
	get_cs_¶_convs "merge1 & 3",
	2)];
store_mt_results mt_run [("merge_pcs 6",
	length,
	get_¶_cd_thms "merge1 & 3",
	2)];
store_mt_results mt_run [("merge_pcs 7",
	length,
	get_¶_vs_thms "merge1 & 3",
	2)];
=TEX
Now test the deletion of fields:
=SML
delete_pc_fields ["rw_eqn_cxt","rw_canons","st_eqn_cxt","sg_eqn_cxt"] "merge1 & 3";
=TEX
=SML
store_mt_results mt_run [("delete_pc_fields 1",
	length,
	get_rw_eqn_cxt "merge1 & 3",
	0)];
store_mt_results mt_run [("delete_pc_fields 2",
	length,
	get_rw_canons "merge1 & 3",
	0)];
store_mt_results mt_run [("delete_pc_fields 3",
	length,
	get_st_eqn_cxt "merge1 & 3",
	0)];
store_mt_results mt_run [("delete_pc_fields 4",
	length,
	get_sg_eqn_cxt "merge1 & 3",
	0)];
store_mt_results mt_run [("delete_pc_fields 5",
	length,
	get_cs_¶_convs "merge1 & 3",
	2)];
store_mt_results mt_run [("delete_pc_fields 6",
	length,
	get_¶_cd_thms "merge1 & 3",
	2)];
store_mt_results mt_run [("delete_pc_fields 7",
	length,
	get_¶_vs_thms "merge1 & 3",
	2)];
=TEX
=SML
delete_pc_fields ["cs_¶_convs","¶_cd_thms","¶_vs_thms"] "merge1 & 3";
=TEX
=SML
store_mt_results mt_run [("delete_pc_fields a1",
	length,
	get_rw_eqn_cxt "merge1 & 3",
	0)];
store_mt_results mt_run [("delete_pc_fields a2",
	length,
	get_rw_canons "merge1 & 3",
	0)];
store_mt_results mt_run [("delete_pc_fields a3",
	length,
	get_st_eqn_cxt "merge1 & 3",
	0)];
store_mt_results mt_run [("delete_pc_fields a4",
	length,
	get_sg_eqn_cxt "merge1 & 3",
	0)];
store_mt_results mt_run [("delete_pc_fields a5",
	length,
	get_cs_¶_convs "merge1 & 3",
	0)];
store_mt_results mt_run [("delete_pc_fields a6",
	length,
	get_¶_cd_thms "merge1 & 3",
	0)];
store_mt_results mt_run [("delete_pc_fields a7",
	length,
	get_¶_vs_thms "merge1 & 3",
	0)];
=TEX
Now delete this empties proof context:
=SML
delete_pc "merge1 & 3";
=TEX
=SML
new_pc "merge1 & 3";
merge_pc_fields [{context = "mdt051_test1",
	fields = ["rw_eqn_cxt","rw_canons","st_eqn_cxt"]},
	{context = "mdt051_test1",
	fields = ["rw_eqn_cxt","rw_canons","st_eqn_cxt"]},
	{context = "mdt051_test3",
	fields = ["sg_eqn_cxt","cs_¶_convs","¶_cd_thms","¶_vs_thms"]}] 
	"merge1 & 3";
store_mt_results mt_run [("merge_pcs 1a",
	length,
	get_rw_eqn_cxt "merge1 & 3",
	1)];
store_mt_results mt_run [("merge_pcs 2a",
	length,
	get_rw_canons "merge1 & 3",
	1)];
store_mt_results mt_run [("merge_pcs 3a",
	length,
	get_st_eqn_cxt "merge1 & 3",
	1)];
store_mt_results mt_run [("merge_pcs 4a",
	length,
	get_sg_eqn_cxt "merge1 & 3",
	1)];
store_mt_results mt_run [("merge_pcs 5a",
	length,
	get_cs_¶_convs "merge1 & 3",
	1)];
store_mt_results mt_run [("merge_pcs 6a",
	length,
	get_¶_cd_thms "merge1 & 3",
	1)];
store_mt_results mt_run [("merge_pcs 7a",
	length,
	get_¶_vs_thms "merge1 & 3",
	1)];
delete_pc "merge1 & 3";
new_pc "merge1 & 3";
store_mt_results mt_run_fail [
	("merge_pcs 51010 a",
	merge_pcs ["rubbish1"],
	"mdt051_test2",
	gen_fail_msg "merge_pcs" 51010 ["rubbish1"]),
	("merge_pcs 51010 b",
	merge_pcs ["mdt051_test1"],
	"rubbish1",
	gen_fail_msg "merge_pcs" 51010 ["rubbish1"]),
	("merge_pcs 51014 a",
	merge_pcs ["pc out of scope"],
	"mdt051_test2",
	gen_fail_msg "merge_pcs" 51014 ["pc out of scope","hol"]),
	("merge_pcs 51014 b",
	merge_pcs ["mdt051_test1"],
	"pc out of scope",
	gen_fail_msg "merge_pcs" 51014 ["pc out of scope","hol"]),
	("merge_pcs 51016",
	merge_pcs ["mdt051_test1"],
	"mdt051_test1",
	gen_fail_msg "merge_pcs" 51016 ["mdt051_test1"]),
	("merge_pcs 51017",
	merge_pcs ["mdt051_test2"],
	"mdt051_test2",
	gen_fail_msg "merge_pcs" 51017 ["mdt051_test2"])
	];
=TEX
=SML
store_mt_results mt_run_fail [
	("merge_pc_fields 51010 a",
	merge_pc_fields [{context = "rubbish1",fields = ["rw_eqn_cxt"]}],
	"mdt051_test2",
	gen_fail_msg "merge_pc_fields" 51010 ["rubbish1"]),
	("merge_pc_fields 51010 b",
	merge_pc_fields [{context = "mdt051_test1",fields = ["rw_eqn_cxt"]}],
	"rubbish1",
	gen_fail_msg "merge_pc_fields" 51010 ["rubbish1"]),
	("merge_pc_fields 51014 a",
	merge_pc_fields [{context = "pc out of scope",fields = ["rw_eqn_cxt"]}],
	"mdt051_test2",
	gen_fail_msg "merge_pc_fields" 51014 ["pc out of scope","hol"]),
	("merge_pc_fields 51014 b",
	merge_pc_fields [{context = "mdt051_test1",fields = ["rw_eqn_cxt"]}],
	"pc out of scope",
	gen_fail_msg "merge_pc_fields" 51014 ["pc out of scope","hol"]),
	("merge_pc_fields 51016",
	merge_pc_fields [{context = "mdt051_test1",fields = ["rw_eqn_cxt"]}],
	"mdt051_test1",
	gen_fail_msg "merge_pc_fields" 51016 ["mdt051_test1"]),
	("merge_pc_fields 51017",
	merge_pc_fields [{context = "mdt051_test2",fields = ["rw_eqn_cxt"]}],
	"mdt051_test2",
	gen_fail_msg "merge_pc_fields" 51017 ["mdt051_test2"]),
	("merge_pc_fields 51019",
	merge_pc_fields [{context = "mdt051_test1",fields = ["rubbish"]}],
	"mdt051_test2",
	gen_fail_msg "merge_pc_fields" 51019 ["rubbish"])
	];
=TEX
=SML
store_mt_results mt_run_fail [
	("delete_pc_fields 51010",
	delete_pc_fields ["rw_eqn_cxt"],
	"rubbish1",
	gen_fail_msg "delete_pc_fields" 51010 ["rubbish1"]),
	("delete_pc_fields 51014",
	delete_pc_fields ["rw_eqn_cxt"],
	"pc out of scope",
	gen_fail_msg "delete_pc_fields" 51014 ["pc out of scope","hol"]),
	("delete_pc_fields 51016",
	delete_pc_fields ["rw_eqn_cxt"],
	"mdt051_test1",
	gen_fail_msg "delete_pc_fields" 51016 ["mdt051_test1"]),
	("delete_pc_fields 51019",
	delete_pc_fields ["rubbish"],
	"mdt051_test2",
	gen_fail_msg "delete_pc_fields" 51019 ["rubbish"])
	];
=TEX
\subsubsection{Proof Context Stack Errors}
=SML
store_mt_results mt_run_fail [
	("new_pc 51011",
	new_pc,
	"mdt051_test1",
	gen_fail_msg "new_pc" 51011 ["mdt051_test1"])];
=TEX
=SML
store_mt_results mt_run_fail [(
	"push_pc 51010",
	push_pc,
	"rubbish1",
	gen_fail_msg "push_pc" 51010 ["rubbish1"]),
	("push_pc 51014",
	push_pc,
	"pc out of scope",
	gen_fail_msg "push_pc" 51014 ["pc out of scope","hol"])];
=TEX
=SML
store_mt_results mt_run_fail [(
	"set_pc 51010",
	set_pc,
	"rubbish1",
	gen_fail_msg "set_pc" 51010 ["rubbish1"]),
	("set_pc 51014",
	set_pc,
	"pc out of scope",
	gen_fail_msg "set_pc" 51014 ["pc out of scope","hol"])];
=TEX
=SML
store_mt_results mt_run_fail [(
	"push_merge_pcs 51010",
	push_merge_pcs,
	["rubbish1"],
	gen_fail_msg "push_merge_pcs" 51010 ["rubbish1"]),
	("push_merge_pcs 51014",
	push_merge_pcs,
	["pc out of scope"],
	gen_fail_msg "push_merge_pcs" 51014 ["pc out of scope","hol"]),
	("push_merge_pcs 51020",
	push_merge_pcs,
	[],
	gen_fail_msg "push_merge_pcs" 51020 [])];
=TEX
=SML
store_mt_results mt_run_fail [(
	"set_merge_pcs 51010",
	set_merge_pcs,
	["rubbish1"],
	gen_fail_msg "set_merge_pcs" 51010 ["rubbish1"]),
	("set_merge_pcs 51014",
	set_merge_pcs,
	["pc out of scope"],
	gen_fail_msg "set_merge_pcs" 51014 ["pc out of scope","hol"]),
	("set_merge_pcs 51020",
	set_merge_pcs,
	[],
	gen_fail_msg "set_merge_pcs" 51020 [])];
=TEX
\subsubsection{Showing the Status}
=SML
new_theory "test_mdt051";
new_const("delete_me",BOOL);
new_pc "rubbish2";
set_pc "rubbish2";
store_mt_results mt_run [("show_current_pc 1",
	show_current_pc,
	(),
	(["rubbish2"],"test_mdt051"))];
push_merge_pcs ["mdt051_test1","mdt051_test2"];
set_merge_pcs ["mdt051_test1","mdt051_test2"];
store_mt_results mt_run [("show_current_pc 2",
	show_current_pc,
	(),
	(["mdt051_test1","mdt051_test2"],"test_mdt051"))];
val was = set_flag("ignore_warnings",true);
delete_const (mk_const("delete_me",BOOL));
val was = set_flag("ignore_warnings",was);
open_theory "misc";
store_mt_results mt_run [("show_current_pc 3",
	show_current_pc,
	(),
	(["mdt051_test1","mdt051_test2"],"test_mdt051 (out of scope, deleted, or modified)"))];
"show_current_pc 3";
show_current_pc ();
push_pc "mdt051_test1";
=TEX
=SML
store_mt_results mt_run [("show_pcs",
	show_pcs,
	(),
	[("rubbish2", "test_mdt051 (out of scope, deleted, or modified)"),
	("merge1 & 3", "misc"),
	("pc out of scope", "hol (out of scope, deleted, or modified)"),
	("mdt051_test3", "misc"), ("mdt051_test2", "misc"),
	("mdt051_test1", "misc"), ("initial", "min")])];
"show_pcs";
show_pcs ();
=TEX
=SML
store_mt_results mt_run [("show_stack_pcs",
	show_stack_pcs,
	(),
	[(["mdt051_test1"], "misc"), 
	(["mdt051_test1", "mdt051_test2"],
      "test_mdt051 (out of scope, deleted, or modified)"),
   (["rubbish2"], "test_mdt051 (out of scope, deleted, or modified)"),
   (["initial"], "min")])];
=TEX
=SML
repeat pop_pc;
store_mt_results mt_run_fail [
	("pop_pc 51001",
	pop_pc,
	(),
	gen_fail_msg "pop_pc" 51001 [])];

push_pc "mdt051_test1";
=TEX
\subsubsection{Commiting Proof Contexts - Failures}
=SML
store_mt_results mt_run_fail [("commit_pc 51010",
	commit_pc,
	"rubbish1",
	gen_fail_msg "commit_pc" 51010 ["rubbish1"]),
	("commit_pc 51016",
	commit_pc,
	"mdt051_test1",
	gen_fail_msg "commit_pc" 51016 ["mdt051_test1"])];
=TEX
\subsubsection{Deleting Proof Contexts}
=SML
store_mt_results mt_run_fail [(
	"delete_pc",
	add_¶_cd_thms [],
	"rubbish",
	gen_fail_msg "add_¶_cd_thms" 51010 ["rubbish"])];
=TEX
=SML
store_mt_results mt_run_fail [(
	"delete_pc 51010",
	delete_pc,
	"rubbish",
	gen_fail_msg "delete_pc" 51010 ["rubbish"]),
	("delete_pc 51012",
	delete_pc,
	"initial",
	gen_fail_msg "delete_pc" 51012 [])];
=TEX
\subsubsection{Setting Evaluation Functions}
Do these last!
=SML
icl'set_eval_ad_rw_net (fn _ => empty_net);
icl'set_eval_ad_rw_canon (fn _ => fn _ => []);
icl'set_eval_ad_st_conv (fn _ => fn _ => t_thm);
icl'set_eval_ad_sg_conv (fn _ => fn _ => t_thm);
icl'set_eval_ad_cs_¶_convs (fn _ => fn _ => t_thm);
icl'set_eval_ad_¶_cd_thms (fn _ => [([],[],BOOL,[],t_thm)]);
icl'set_eval_ad_¶_vs_thms (fn _ => []);
push_pc "mdt051_test2";
let
val rw_net1 = current_ad_rw_net ();
in
store_mt_results mt_run [(
	"current_ad_rw_net a",
	is_nil,
	(net_lookup rw_net1 tm_a),
	true)]
end;
store_mt_results mt_run [(
	"current_ad_rw_canon a",
	length,
	(current_ad_rw_canon () t_thm),
	0)];
store_mt_results (mt_runf (op =#))[(
	"current_ad_st_conv a",
	dest_thm o current_ad_st_conv (),
	tm_a,
	dest_thm t_thm)];
store_mt_results (mt_runf (op =#))[(
	"current_ad_sg_conv a",
	dest_thm o current_ad_sg_conv (),
	tm_a,
	dest_thm t_thm)];
store_mt_results (mt_runf (op =#))[(
	"current_ad_cs_¶_conv a",
	dest_thm o current_ad_cs_¶_conv (),
	mk_t,
	dest_thm t_thm)];
store_mt_results mt_run [
	("current_ad_¶_cd_thms a",
	length,
	current_ad_¶_cd_thms (),
	1)];
store_mt_results mt_run [
	("current_ad_¶_vs_thms a",
	length,
	current_ad_¶_vs_thms (),
	0)];

=TEX
\subsection{End of Tests}
=SML
diag_string(summarize_mt_results ());
open_theory "hol";
delete_theory "test_mdt051";
=TEX
\end{document}


