=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Proof Contexts}  %% Mandatory field
\def\TPPheadtitle{Module Tests for Proof Contexts}
\TPPref{DS/FMU/IED/MDT051}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the 
proof context functions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1]
First draft version.
\item [Issue 1.2]
Reacted to $NetTools$ being open.
\item [Issue 1.3]
Proof context becomes an ADT.
\item [Issue 1.4]
Fixed bug in $thm\_eqn\_cxt$ tests.
\end{description}
%\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the proof context functions.
The design is in \cite{DS/FMU/IED/DTD051}
and it is
implemented in \cite{DS/FMU/IED/IMP051}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD051},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD051},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP051}.
It requires the presence of theory ``$†$'',
and the initial stripping context $initial\_strip\_epc$.
\subsubsection{Deficiencies}

\section{TEST HARNESS MATERIAL}
=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results ();
open_theory "†";
=TEX
\section{TEST DATA}
This section contains data used in the test, that
in themselves are not part of the tests.
However, they may fail if the functions tested are ill-formed.
=SML
val epc : EPROOF_CONTEXT = 
	set_epc_name "epc"
	(set_epc_rw_net (make_net [(»x+y¼,plus_conv)])
	(set_epc_rw_canon (fn thm => [thm,thm])
	(set_epc_sg_conv suc_conv
	(set_epc_st_conv simple_%beta%_conv initial_epc))));
val pc : PROOF_CONTEXT = 
	set_pc_name "pc"
	(set_pc_rw_eqn_cxt [(»x+y¼,plus_conv),(»5¼,suc_conv),(»6¼,suc_conv)]
	(set_pc_rw_canons [fn thm => [thm,thm]]
	(set_pc_sg_eqn_cxt [(»5¼,suc_conv),(»6¼,suc_conv)]
	(set_pc_st_eqn_cxt [(»3¼,suc_conv)] initial_pc))));

val beta_redex = »( x Ž (x Š F)) T¼;
=TEX
We wish to start with the initial proof context, so
=SML
repeat pop_proof_context;
=TEX
\section{THE TESTS}
\subsection{Equational Contexts}
=SML
store_mt_results mt_run [("thm_eqn_cxt",
	(Combinators.I ** (fn f => snd(dest_thm (f »y¼))))
		o thm_eqn_cxt,
	all_ƒ_intro (refl_conv »x¼),
	(»x¼,»y = y¼))];
store_mt_results mt_run_fail [("thm_eqn_cxt 7095",
	thm_eqn_cxt,
	t_thm,
	gen_fail_msg "thm_eqn_cxt" 7095 ["… T"])];
=TEX
=SML
let
	val sideeffect = push_proof_context initial_strip_epc;
	val thm = tac_proof(([],»ƒ x Ž (x € x) ‚ x¼),
		REPEAT strip_tac);
	val sideeffect = pop_proof_context();
in
store_mt_results mt_run [("eqn_cxt_conv",
	dest_thm o eqn_cxt_conv [thm_eqn_cxt thm],
	»y € y¼,
	([],»y € y ‚ y¼))]
end;
store_mt_results mt_run_fail [("eqn_cxt_conv 51005",
	eqn_cxt_conv [],
	»y¼,
	gen_fail_msg "eqn_cxt_conv" 51005 ["»y¼"])];
=TEX
\subsection{Proof Contexts}

=SML
store_mt_results mt_run [
	("get_pc_rw_eqn_cxt",
	length o get_pc_rw_eqn_cxt,
	pc,
	3)];
store_mt_results mt_run [
	("get_pc_st_eqn_cxt",
	length o get_pc_st_eqn_cxt,
	pc,
	1)];
store_mt_results mt_run [
	("get_pc_sg_eqn_cxt",
	length o get_pc_sg_eqn_cxt,
	pc,
	2)];
store_mt_results mt_run [
	("get_pc_sg_eqn_cxt",
	length o get_pc_rw_canons,
	pc,
	1)];
store_mt_results mt_run [
	("get_pc_name",
	get_pc_name,
	pc,
	"pc")];
=TEX
$push/pop/get\_proof\_context$ and $initial\_epc$ are implicitly tested by the following:
=SML
store_mt_results mt_run [
	("?_proof_context 1",
	dest_thm o TRY_C(get_epc_st_conv (get_proof_context())),
	beta_redex,
	dest_thm(id_conv beta_redex))];
push_proof_context epc;
store_mt_results mt_run [
	("?_proof_context 2a",
	dest_thm o get_epc_st_conv (get_proof_context()),
	beta_redex,
	dest_thm(simple_%beta%_conv beta_redex))];
store_mt_results mt_run [
	("?_proof_context 2b",
	dest_thm o get_epc_sg_conv (get_proof_context()),
	»2¼,
	dest_thm(suc_conv »2¼))];
store_mt_results mt_run [
	("?_proof_context 2c",
	dest_thm o hd(net_lookup (get_epc_rw_net (get_proof_context()))»2 + 3¼),
	»2 + 3¼,
	dest_thm(plus_conv »2+3¼))];
store_mt_results mt_run [
	("?_proof_context 2d",
	length o get_epc_rw_canon (get_proof_context()),
	t_thm,
	2)];
store_mt_results mt_run [
	("?_proof_context 2e",
	get_epc_name,
	get_proof_context(),
	"epc")];
val epc1 = pop_proof_context ();
store_mt_results mt_run [
	("?_proof_context 3",
	dest_thm o TRY_C(get_epc_st_conv (get_proof_context())),
	beta_redex,
	dest_thm(id_conv beta_redex))];
push_proof_context epc1;
store_mt_results mt_run [
	("?_proof_context 4",
	dest_thm o get_epc_st_conv (get_proof_context()),
	beta_redex,
	dest_thm(simple_%beta%_conv beta_redex))];
val epc2 = pop_proof_context ();
store_mt_results mt_run_fail [
	("pop_proof_context 51001",
	pop_proof_context,
	(),
	gen_fail_msg "pop_proof_context" 51001 [])
	];
=TEX
\subsection{End of Tests}
=SML
diag_string(summarize_mt_results ());
=TEX
\end{document}
