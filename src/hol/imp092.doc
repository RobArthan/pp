%  dtd038.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Further Theorems About Sets}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP092}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & HAT Team Leader}
\TPPabstract{
This document contains the implementation for further theorems
about sets.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issue \SCCSversion (\FormatDate{$Date$%
})]
First draft.
\end{description}
\subsection{Changes Forecast}
Further results could be added (Schroeder-Bernstein?).
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for further
theorems about sets and relations for \ProductHOL.
The detailed design for this material is given in \cite{DS/FMU/IED/HLD011}.

\subsection{Introduction}
This document develops some more advanced theorems about sets and relations
than those offered in the basic theoriues of
\cite{DS/FMU/IED/DTD044,DS/FMU/IED/DTD044}. The theorems are Zorn's lemma
(in a purely set-theoretic guise and as the more general statement about
partial orderings) and the well-ordering theorem.
\subsubsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD011}.
\subsubsection{Dependencies}
This document depends on the theory design support
tools in \cite{DS/FMU/IED/DTD035} and
on the theory of relations in \cite{DS/FMU/IED/IMP071}
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Deficiencies}
None known.
=TEX
\documentstyle[TQa4,hol1]{article}
\begin{document}
\section{PRELIMINARIES}

=SML
open_theory"set_thms";
set_pc"sets_ext";
=TEX

\section{CONSISTENCY PROOFS}
=SML
set_pc"sets_ext";
push_consistency_goal¨ChooseÆ;
a(prove_∂_tac THEN REPEAT strip_tac);
a(cases_tac¨a' = {}Æ THEN asm_prove_tac[]);
save_consistency_thm ¨ChooseÆ (pop_thm());
=TEX
\section{ZORN'S LEMMA (SPECIAL CASE)}
=SML
val zorn_Ä_conj = ¨
	µu : 'a SET SET∑
		≥u = {}
	±	SubsetClosed u
	±	NestClosed u
	¥	∂a∑MaximalâÄ u aÆ;
=TEX

=SML
val €hat_def› = ¨µu:'a SET SET; a : 'a SET∑ hat u a = {x | ≥x ç a ± a ¿ {x} ç u}Æ;
val €g_def› = ¨µu:'a SET SET; a : 'a SET∑
		g u a = if ≥hat u a = {} then	a ¿ {Choose (hat u a)} else aÆ;
val €tower_def› = ¨µu:'a SET SET; t : 'a SET SET∑
		tower u t 
	§	t Ä u
	±	{} ç t
	±	(µa∑ a ç t ¥ g u a ç t)
	±	(µv∑ v Ä t ± Nest v ¥ ﬁv ç t)Æ;
val €t0_def› = ¨µu:'a SET SET∑
		t0 u = •{t : 'a SET SET | tower u t}Æ;
val €comparable_def› = ¨µu:'a SET SET; c : 'a SET∑
		comparable u c § c ç t0 u ± µa∑a ç t0 u ¥ a Ä c ≤ c Ä aÆ;
=TEX
=SML
fun €loc_def_tac› (defn : TERM) : TACTIC = (
	let	val fnc = (fst o strip_app o fst o dest_eq o snd o strip_µ) defn;
		val exi = mk_∂(fnc, defn);
		val thm = pc_rule"predicates" prove_∂_rule exi;
	in	strip_asm_tac thm
	end
);
=TEX
=SML
val €conj1› = ([¨SubsetClosed uÆ, hat_def, g_def],
	¨µa: 'a SET∑a ç u ¥ (MaximalâÄ u a § (g u a) = a)Æ);
=TEX
=SML
set_pc"predicates";
set_goal conj1;
a(asm_rewrite_tac[get_spec¨MaximalâÄÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(cases_tac ¨≥ {x|≥x ç a ± a ¿ {x} ç u} = {}Æ THEN asm_rewrite_tac[]);
a(i_contr_tac THEN POP_ASM_T ante_tac THEN PC_T "sets_ext" strip_tac);
a(lemma_tac ¨a Ä a ¿ {x}Æ THEN1 PC_T1 "sets_ext" prove_tac[]);
a(all_asm_fc_tac[]);
a(list_asm_ante_tac [¨≥ x ç aÆ, ¨a ¿ {x} = aÆ] THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[pc_rule1"sets_ext" prove_rule[] ¨b = a § a Ä b ± b Ä aÆ]
	THEN REPEAT strip_tac);
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(GET_ASM_T ¨SubsetClosed uÆ (asm_tac o rewrite_rule[get_spec¨SubsetClosedÆ]));
a(lemma_tac ¨a ¿ {x} Ä bÆ THEN1
	(list_asm_ante_tac [¨a Ä bÆ, ¨x ç bÆ] THEN PC_T1"sets_ext"prove_tac[]
		THEN asm_rewrite_tac[]));
a(rename_tac[] THEN all_asm_fc_tac[]);
a(swap_nth_asm_concl_tac 7);
a(lemma_tac¨≥ {x|≥x ç a ± a ¿ {x} ç u} = {}Æ THEN1
	(PC_T1"sets_ext" REPEAT strip_tac));
(* *** Goal "2.1" *** *)
a(∂_tac¨xÆ THEN PC_T1"sets_ext" REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[] THEN POP_ASM_T ante_tac THEN rewrite_tac[get_spec¨ChooseÆ]);
a(PC_T1"sets_ext" REPEAT strip_tac);
a(∂_tac¨Choose {x|≥ x ç a ± a ¿ {x} ç u}Æ THEN PC_T1"sets_ext" REPEAT strip_tac);
val €lemma1› = pop_thm ();
=TEX
=SML
val €conj2› = ([¨≥(u : 'a SET SET)  = {}Æ, ¨SubsetClosed uÆ, ¨NestClosed uÆ,
		hat_def, g_def, tower_def, t0_def],
	¨tower u ((t0 : 'a SET SET ≠ 'a SET SET) u) : BOOLÆ);
=TEX
=SML
set_pc"sets_ext";
set_goal conj2;
a(PC_T1 "predicates" asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (strip_asm_tac o µ_elim¨uÆ));
(* *** Goal "1.1" *** *)
a(i_contr_tac THEN REPEAT_N 3 (POP_ASM_T ante_tac));
a(rewrite_tac[get_spec¨SubsetClosedÆ] THEN REPEAT strip_tac);
a(list_spec_nth_asm_tac 2 [¨xÆ, ¨{}Æ]);
(* *** Goal "1.2" *** *)
a(i_contr_tac THEN POP_ASM_T ante_tac THEN rewrite_tac[get_spec¨ChooseÆ]);
a(cases_tac¨≥ Choose {x|≥ x ç a ± a ¿ {x} ç u} ç a
	± a ¿ {Choose {x|≥ x ç a ± a ¿ {x} ç u}} ç uÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.3" *** *)
a(LIST_GET_NTH_ASM_T [1,2,3,6] (MAP_EVERY ante_tac));
a(rewrite_tac[get_spec¨NestClosedÆ] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
a(lemma_tac¨v Ä sÆ);
(* *** Goal "3.1" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(all_asm_fc_tac[]);
val €lemma2› = pop_thm ();
=TEX
=SML
val €conj3› = ([¨≥(u : 'a SET SET) = {}Æ, ¨SubsetClosed uÆ, ¨NestClosed uÆ,
		hat_def, g_def, tower_def, t0_def],
	¨Nest ((t0 : 'a SET SET ≠ 'a SET SET) u) ¥ ∂a∑ MaximalâÄ u aÆ);
=TEX
=SML
set_pc"predicates";
set_goal conj3;
a(ante_tac lemma2 THEN GET_ASM_T tower_def rewrite_thm_tac);
a(REPEAT strip_tac);
a(∂_tac¨ﬁ(t0 u)Æ);
a(lemma_tac ¨ﬁ(t0 u) ç t0 uÆ);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 2 bc_thm_tac);
a(PC_T1"sets_ext" REPEAT strip_tac);
(* *** Goal "2" *** *)
a(lemma_tac ¨ﬁ(t0 u) ç uÆ THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(ALL_FC_T1 id_canon rewrite_tac [lemma1]);
a(PC_T1"sets_ext" REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(all_asm_fc_tac[]);
a(LIST_GET_NTH_ASM_T [2,3] (MAP_EVERY ante_tac) THEN PC_T1"sets_ext"prove_tac[]);
(* *** Goal "2.2" *** *)
a(GET_ASM_T g_def rewrite_thm_tac);
a(CASES_T¨≥ hat u (ﬁ (t0 u)) = {}Æ rewrite_thm_tac
	THEN PC_T"sets_ext" contr_tac THEN all_asm_fc_tac[]);
val €lemma3› = pop_thm ();
=TEX
=SML
val €conj4› = ([comparable_def],
	¨(µc : 'a SET∑ c ç t0 u ¥ comparable u c)
		¥ Nest ((t0 : 'a SET SET ≠ 'a SET SET) u)Æ);
=TEX
=SML
set_pc"predicates";
set_goal conj4;
a(asm_rewrite_tac[get_spec¨NestÆ, prove_rule[]¨µp q∑(p ¥ p ± q) § (p ¥ q)Æ]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
val €lemma4› = pop_thm ();
=TEX
=SML
val €conj5› = ([¨≥(u : 'a SET SET) = {}Æ, ¨SubsetClosed uÆ, ¨NestClosed uÆ,
		hat_def, g_def, tower_def, t0_def, comparable_def],
	¨tower u {c | comparable u c}
		¥ (µc: 'a SET∑ c ç t0 u ¥ comparable (u : 'a SET SET) c)Æ);
=TEX
=SML
set_pc"sets_ext";
set_goal conj5;
a(LIST_GET_ASM_T [tower_def, t0_def] rewrite_tac);
a(REPEAT strip_tac);
a(SPEC_NTH_ASM_T 1 ¨{c | comparable u c}Æ (strip_asm_tac o rewrite_rule[])
	THEN all_asm_fc_tac[]);
val €lemma5› = pop_thm ();
=TEX
=SML
val €conj6› = ([¨≥(u : 'a SET SET) = {}Æ, ¨SubsetClosed uÆ, ¨NestClosed uÆ,
		hat_def, g_def, tower_def, t0_def, comparable_def],
	¨(µc:'a SET∑ comparable (u : 'a SET SET) c ¥ comparable u (g u c))
		¥ tower u {c | comparable u c}Æ);
=TEX
=SML
set_pc"sets_ext";
set_goal conj6;
a(LIST_GET_ASM_T [tower_def] rewrite_tac);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac);
a(REPEAT strip_tac THEN asm_fc_tac[]);
(* *** Goal "2" *** *)
a(LIST_GET_ASM_T [comparable_def] rewrite_tac);
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac);
a(REPEAT strip_tac);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(LIST_GET_ASM_T [comparable_def]rewrite_tac);
a(REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac);
a(strip_tac);
a(POP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "4.2" *** *)
a(spec_nth_asm_tac 7 ¨sÆ);
a(LIST_GET_NTH_ASM_T [17] fc_tac);
a(list_spec_nth_asm_tac 2 [¨aÆ, ¨xÆ, ¨x'Æ]);
a(spec_nth_asm_tac 7 ¨sÆ);
val €lemma6› = pop_thm ();
=TEX
=SML
val €conj7› = ([¨≥(u : 'a SET SET) = {}Æ, ¨SubsetClosed uÆ, ¨NestClosed uÆ,
		hat_def, g_def, tower_def, t0_def, comparable_def],
	¨(µc:'a SET∑ comparable (u : 'a SET SET) c ¥ tower u {a | a ç t0 u ± (a Ä c ≤ g u c Ä a)})
		¥ (µc∑ comparable u c ¥ comparable u (g u c))Æ);
=TEX
=SML
set_merge_pcs["predicates", "'sets_alg"];
set_goal conj7;
a(DROP_ASM_T comparable_def rewrite_thm_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(spec_nth_asm_tac 5 ¨cÆ THEN1 all_asm_fc_tac[]);
a(lemma_tac¨t0 u Ä {a|a ç t0 u ± (a Ä c ≤ g u c Ä a)}Æ);
(* *** Goal "2.1" *** *)
a(GET_ASM_T t0_def (fn th => conv_tac (LEFT_C(rewrite_conv[th]))));
a(POP_ASM_T ante_tac THEN
	rewrite_tac[pc_rule1"sets_ext" prove_rule[]¨µf a∑f a ¥ •{b| f b} Ä aÆ]);
(* *** Goal "2.2" *** *)
a(POP_ASM_T (PC_T1 "sets_ext" strip_asm_tac));
a(spec_nth_asm_tac 1 ¨aÆ);
a(swap_nth_asm_concl_tac 4 THEN GET_ASM_T g_def rewrite_thm_tac);
a(asm_ante_tac ¨a Ä cÆ THEN CASES_T ¨≥ hat u c = {}Æ rewrite_thm_tac
	THEN PC_T1 "sets_ext" prove_tac[]);
val €lemma7› = pop_thm ();
=TEX
=SML
val €conj8› = ([¨≥(u : 'a SET SET) = {}Æ, ¨SubsetClosed uÆ, ¨NestClosed uÆ,
		hat_def, g_def, tower_def, t0_def, comparable_def],
	¨µc:'a SET∑ comparable (u : 'a SET SET) c ¥ tower u {a | a ç t0 u ± (a Ä c ≤ g u c Ä a)}Æ);
=TEX
=SML
set_merge_pcs["predicates", "'sets_alg"];
set_goal conj8;
a(LIST_GET_ASM_T[comparable_def, tower_def] rewrite_tac);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac THEN strip_tac);
a(asm_ante_tac ¨t0 u Ä uÆ THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2" *** *)
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac THEN strip_tac);
(* *** Goal "3" *** *)
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac THEN strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(lemma_tac¨g u a ç t0 uÆ);
(* *** Goal "4.1" *** *)
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac THEN strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "4.2" *** *)
a(spec_nth_asm_tac 5 ¨g u aÆ);
a(cases_tac¨a = cÆ THEN1 asm_rewrite_tac[]);
a(i_contr_tac THEN LIST_GET_NTH_ASM_T [1,2,4,5,13] (MAP_EVERY ante_tac));
a(DROP_ASMS_T (fn _ => id_tac) THEN STRIP_T rewrite_thm_tac);
a(CASES_T ¨≥ hat u a = {}Æ rewrite_thm_tac THEN PC_T1"sets_ext" prove_tac[]);
a(asm_fc_tac[]);
a(PC_T1 "prop_eq" asm_prove_tac[]);
(* *** Goal "5" *** *)
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac THEN strip_tac);
a(all_asm_fc_tac[]);
a(asm_ante_tac¨g u c Ä aÆ THEN GET_ASM_T g_def rewrite_thm_tac);
a(CASES_T ¨≥ hat u a = {}Æ rewrite_thm_tac THEN PC_T1"sets_ext" prove_tac[]);
(* *** Goal "7" *** *)
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac THEN strip_tac);
a(POP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
a(asm_ante_tac ¨v Ä {a|a ç t0 u ± (a Ä c ≤ g u c Ä a)}Æ
	THEN PC_T1"sets_ext" prove_tac[]);
(* *** Goal "8" *** *)
a(REPEAT_N 3 (POP_ASM_T ante_tac) THEN DROP_ASMS_T (fn _ => id_tac));
a(PC_T "sets_ext" (rewrite_tac[get_spec¨NestÆ] THEN REPEAT strip_tac));
a(PC_T1 "sets_ext" (spec_nth_asm_tac 6) ¨sÆ THEN
	contr_tac THEN all_asm_fc_tac[]);
val €lemma8› = pop_thm ();
=TEX
=SML
push_goal([], zorn_Ä_conj);
a(REPEAT strip_tac);
a(MAP_EVERY loc_def_tac [hat_def, g_def, tower_def, t0_def, comparable_def]);
a(MAP_EVERY ante_tac[lemma3, lemma4, lemma5, lemma6, lemma7, lemma8]);
a(taut_tac);
val €zorn_Ä_thm› = save_pop_thm "zorn_Ä_thm";
=TEX
\section{ZORN'S LEMMA (GENERAL CASE)}
=SML
open_theory"bin_rel_thms";
new_parent"fun_rel";
=TEX
=SML
set_pc"hol";
set_goal([], ¨µr : ('a ™ 'a); a : 'a SET∑
		r ç ReflexiveIn a
	±	r ç Transitive
	±	r ç Antisymmetric
	±	(µc∑ c Ä a ± c ç Chains r ¥ ∂x∑ x ç a ± x ç UpperBounds r c)
	¥	∂x∑ x ç MaximalElements r aÆ);
a(REPEAT strip_tac);
a(lemma_tac ¨∂u∑u = {c | c Ä a ± c ç Chains r }Æ THEN1 prove_∂_tac);
a(lemma_tac¨≥ u = {} ± SubsetClosed u ± NestClosed uÆ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(asm_rewrite_tac[] THEN PC_T1 "hol1" REPEAT strip_tac);
a(∂_tac¨{}Æ THEN rewrite_tac[get_spec¨ChainsÆ] THEN prove_tac[]);
(* *** Goal "1.2" *** *)
a(rewrite_tac[get_spec¨SubsetClosedÆ] THEN rename_tac[]
	THEN asm_rewrite_tac[get_spec¨ChainsÆ]);
a(PC_T1 "hol1" REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(asm_prove_tac[]);
(* *** Goal "1.2.2" *** *)
a(lemma_tac¨x ç a' ± y ç a'Æ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "1.3" *** *)
a(rewrite_tac[get_spec¨NestClosedÆ] THEN rename_tac[]
	THEN asm_rewrite_tac[get_spec¨ChainsÆ]);
a(PC_T1 "hol1" REPEAT strip_tac);
(* *** Goal "1.3.1" *** *)
a(PC_T1 "hol1" all_asm_fc_tac[]);
(* *** Goal "1.3.2" *** *)
a(PC_T "hol1"(DROP_ASM_T ¨Nest vÆ
	(strip_asm_tac o list_µ_elim[¨sÆ, ¨s'Æ] o rewrite_rule[get_spec¨NestÆ])));
(* *** Goal "1.3.2.1" *** *)
a(PC_T "hol1" (all_asm_fc_tac[] THEN all_asm_fc_tac[]));
(* *** Goal "1.3.2.2" *** *)
a(PC_T "hol1" (asm_fc_tac[] THEN all_asm_fc_tac[]));
(* *** Goal "2" *** *)
a(all_fc_tac[zorn_Ä_thm]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[get_spec¨MaximalâÄÆ]
	THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(∂_tac ¨xÆ THEN rewrite_tac[get_spec¨MaximalElementsÆ] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 3  ante_tac THEN rewrite_tac[get_spec¨UpperBoundsÆ]
	THEN REPEAT strip_tac);
a(lemma_tac¨a' ¿ {y} Ä a ± a' ¿ {y} ç Chains r ± a' Ä a' ¿ {y}Æ);
a(PC_T1 "hol1" REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(PC_T1 "hol1" all_asm_fc_tac[]);
(* *** Goal "2.1.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2.1.3" *** *)
a(asm_ante_tac ¨a' ç Chains rÆ THEN PC_T1 "hol1" rewrite_tac[get_spec¨ChainsÆ]);
a(REPEAT strip_tac);
(* *** Goal "2.1.3.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2.1.3.2" *** *)
a(POP_ASM_T ante_tac THEN POP_ASM_T rewrite_thm_tac);
a(LEMMA_T ¨(x', y) ç rÆ rewrite_thm_tac);
a(DROP_ASM_T ¨r ç TransitiveÆ (strip_asm_tac o rewrite_rule[get_spec¨TransitiveÆ]));
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2.1.3.3" *** *)
a(POP_ASM_T ante_tac THEN DROP_ASM_T ¨x' = yÆ rewrite_thm_tac);
a(LEMMA_T ¨(y', y) ç rÆ rewrite_thm_tac);
a(DROP_ASM_T ¨r ç TransitiveÆ (strip_asm_tac o rewrite_rule[get_spec¨TransitiveÆ]));
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2.1.3.4" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(DROP_ASM_T ¨r ç ReflexiveIn aÆ
	(strip_asm_tac o rewrite_rule[get_spec¨ReflexiveInÆ]));
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(all_asm_fc_tac[]);
a(asm_ante_tac ¨a' ¿ {y} = a'Æ THEN PC_T1 "hol1" REPEAT strip_tac);
a(lemma_tac¨y ç a'Æ THEN1 spec_nth_asm_tac 1 ¨yÆ);
a(all_asm_fc_tac[]);
a(DROP_ASM_T ¨r ç AntisymmetricÆ
	(strip_asm_tac o rewrite_rule[get_spec¨AntisymmetricÆ]));
a(all_asm_fc_tac[]);
val €zorn's_lemma› = save_pop_thm "zorn's_lemma";
=TEX
\section{CONSEQUENCES OF ZORN'S LEMMA}
=SML
set_merge_pcs["hol1", "'bin_rel_ext"];
set_goal([], ¨µf; a b; c d∑
		f ç (a ‡ c) ± g ç (b ‡ d)
	±	Dom f ° Dom g = {}
	±	Ran f ° Ran g = {}
	¥	f ¿ g ç a ¿ b ‡ c ¿ dÆ);
a(rewrite_tac[get_spec¨$‡Æ] THEN REPEAT strip_tac
	THEN_TRY (
		SOLVED_T(contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[])
		ORELSE asm_prove_tac[]));
val €‡_lemma› = pop_thm();
=TEX
=SML
set_goal([], ¨µf; a: 'a SET; b : 'b SET∑
		(f Á~Í ç Functional § f ç Injective)
	±	(f Á~Í ç Injective § f ç Functional)
	±	(f Á~Í ç Total b § f ç Surjective b)
	±	(f Á~Í ç Surjective a § f ç Total a)
	±	(f Á~Í ç b ™ a § f ç a ™ b)
	±	(f Á~Í Á~Í = f)Æ);
a(prove_tac[]);
(* *** Goal "1" *** *)
a(POP_ASM_T (asm_tac o once_rewrite_rule[prove_rule[]
	¨x = (Snd(Snd x, Fst x), Fst(Snd x, Fst x))Æ])
	THEN ALL_ASM_FC_T (MAP_EVERY(strip_asm_tac o rewrite_rule[]))[]);
(* *** Goal "2" *** *)
a(POP_ASM_T (asm_tac o once_rewrite_rule[prove_rule[]
	¨x = (Snd(Snd x, Fst x), Fst(Snd x, Fst x))Æ])
	THEN ALL_ASM_FC_T (MAP_EVERY(strip_asm_tac o rewrite_rule[]))[]);
(* *** Goal "3" *** *)
a(ALL_ASM_FC_T (MAP_EVERY(strip_asm_tac o rewrite_rule[]))[]);
(* *** Goal "4" *** *)
a(ALL_ASM_FC_T (MAP_EVERY(strip_asm_tac o rewrite_rule[]))[]);
val €rel_inv_lemma› = pop_thm();
=TEX
=SML
set_goal([], ¨µa : 'a SET; b : 'b SET; f : 'a ™ 'b ∑
		MaximalâÄ {h | ∂a1∑a1 Ä a ± h ç a1 ‡ b} f
	¥	(∂f∑ f ç a ‡ b) ≤ (∂g∑ g ç b ‡ a)Æ);
push_pc"hol";
a(REPEAT µ_tac THEN rewrite_tac[get_spec¨MaximalâÄÆ] THEN strip_tac);
a(cases_tac¨a = a1Æ THEN_LIST[
	≤_left_tac THEN ∂_tac ¨fÆ THEN asm_rewrite_tac[],
	≤_right_tac]);
a(∂_tac¨f Á~ÍÆ THEN asm_ante_tac ¨f ç a1 ‡ bÆ
	THEN PC_T1 "hol1" rewrite_tac(map get_spec[¨$‡Æ]));
a(rewrite_tac [rel_inv_lemma] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(list_asm_ante_tac [¨a1 Ä aÆ, ¨f ç a1 ™ bÆ]
	THEN MERGE_PCS_T1 ["hol1", "'bin_rel_ext"] prove_tac[]); 
(* *** Goal "2" *** *)
a(MERGE_PCS_T1 ["hol1", "'bin_rel_ext"]rewrite_tac[get_spec ¨SurjectiveÆ]);
a(contr_tac);
(* *** Goal "2.1" *** *)
a(lemma_tac ¨∂y∑y ç a \ a1Æ THEN1 (
	list_asm_ante_tac[¨≥ a = a1Æ, ¨a1 Ä aÆ] THEN PC_T1 "sets_ext" prove_tac[]));
a(lemma_tac ¨f ¿ {(y, x)} = fÆ);
(* *** Goal "2.1.1" *** *)
a(DROP_NTH_ASM_T 10 bc_thm_tac);
a(conv_tac (RIGHT_C (PC_C1 "sets_ext" prove_conv[])) THEN REPEAT strip_tac);
a(∂_tac¨a1 ¿ {y}Æ THEN REPEAT strip_tac);
(* *** Goal "2.1.1.1" *** *)
a(list_asm_ante_tac[¨y ç aÆ, ¨a1 Ä aÆ] THEN PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.1.1.1.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2.1.1.1.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2.1.1.2" *** *)
a(once_rewrite_tac[pc_rule1"sets_ext" prove_rule[]¨b = b ¿ bÆ]);
a(bc_tac[‡_lemma]);
(* *** Goal "2.1.1.2.1" *** *)
a(PC_T1 "hol1" asm_rewrite_tac[get_spec¨$‡Æ]);
(* *** Goal "2.1.1.2.2" *** *)
a(MERGE_PCS_T1 ["hol1", "'bin_rel_ext"] prove_tac[get_spec¨$‡Æ]
	THEN asm_rewrite_tac[]);
(* *** Goal "2.1.1.2.3" *** *)
a(rewrite_tac[get_spec¨DomÆ] THEN PC_T1 "sets_ext" REPEAT strip_tac);
a(swap_asm_concl_tac ¨(x', y') ç fÆ THEN asm_rewrite_tac[]);
a(swap_asm_concl_tac ¨f ç a1 ™ bÆ THEN PC_T1 "'bin_rel_ext" rewrite_tac[]);
a(REPEAT strip_tac);
a(∂_tac¨yÆ THEN REPEAT strip_tac);
a(∂_tac¨y'Æ THEN REPEAT strip_tac);
(* *** Goal "2.1.1.2.4" *** *)
a(rewrite_tac[get_spec¨RanÆ] THEN PC_T1 "sets_ext" REPEAT strip_tac);
a(swap_asm_concl_tac ¨(x'', x') ç fÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a(spec_asm_tac¨µ x'∑ ≥ (x', x) ç fÆ¨yÆ);
a(lemma_tac¨(y, x) ç fÆ);
a(GET_NTH_ASM_T 2 (once_rewrite_thm_tac o eq_sym_rule));
a(PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2.2" *** *)
a(swap_asm_concl_tac ¨f ç a1 ™ bÆ THEN PC_T1 "'bin_rel_ext" rewrite_tac[]);
a(REPEAT strip_tac);
a(∂_tac¨x'Æ THEN REPEAT strip_tac);
a(∂_tac¨xÆ THEN REPEAT strip_tac);
val €lemma10› = pop_thm();
=TEX
=SML
set_merge_pcs["hol1", "'bin_rel_ext"];
set_goal([], ¨µa : 'a SET; b : 'b SET∑
	(∂f∑ f ç a ‡ b) ≤ (∂g∑ g ç b ‡ a)Æ);
a(REPEAT µ_tac);
a(bc_tac[lemma10, zorn_Ä_thm]);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(∂_tac¨{}Æ THEN rewrite_tac(map get_spec[¨$‡Æ, ¨$™Æ]) THEN REPEAT strip_tac);
a(∂_tac¨{}Æ THEN rewrite_tac(map get_spec[¨Æ, ¨InjectiveÆ, ¨FunctionalÆ]) THEN
	REPEAT strip_tac THEN prove_tac(map get_spec[¨TotalÆ, ¨DomÆ]));
(* *** Goal "2" *** *)
a(rewrite_tac[get_spec¨SubsetClosedÆ] THEN REPEAT strip_tac);
a(∂_tac¨Dom b'Æ THEN rewrite_tac(map get_spec[¨DomÆ]) THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(all_asm_fc_tac[]);
a(asm_ante_tac¨a' ç a1 ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ, ¨$™Æ, ¨$∏Æ])
	THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(asm_ante_tac ¨Fst (x, y) ç a1Æ THEN rewrite_tac[] THEN strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(rewrite_tac(map get_spec[¨$‡Æ])THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(∂_tac ¨Snd xÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a(all_asm_fc_tac[]);
a(asm_ante_tac¨a' ç a1 ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "2.2.3" *** *)
a(asm_ante_tac¨a' ç a1 ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2.2.4" *** *)
a(asm_ante_tac¨a' ç a1 ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN PC_T1 "hol1" REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(rewrite_tac[get_spec¨NestClosedÆ, get_spec¨NestÆ] THEN REPEAT strip_tac);
a(∂_tac¨Dom (ﬁv)Æ THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(LIST_GET_NTH_ASM_T [4] all_fc_tac);
a(asm_ante_tac¨s ç a1 ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [4] all_fc_tac);
a(all_asm_fc_tac[]);
a(asm_ante_tac ¨Fst (x, y) ç a1Æ THEN rewrite_tac[] THEN strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(rewrite_tac(map get_spec[¨$‡Æ]) THEN REPEAT strip_tac);
(* *** Goal "3.2.1" *** *)
a(MAP_EVERY ∂_tac[¨Snd xÆ, ¨sÆ] THEN asm_rewrite_tac[]);
(* *** Goal "3.2.2" *** *)
a(LIST_GET_NTH_ASM_T [4] all_fc_tac);
a(asm_ante_tac¨s ç a1 ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [4] all_fc_tac);
(* *** Goal "3.2.3" *** *)
a(list_spec_nth_asm_tac 5 [¨sÆ, ¨s'Æ]);
(* *** Goal "3.2.3.1" *** *)
a(LIST_DROP_NTH_ASM_T [1, 7] all_fc_tac);
a(asm_ante_tac¨s' ç a1 ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [3] all_fc_tac);
(* *** Goal "3.2.3.2" *** *)
a(LIST_DROP_NTH_ASM_T [1, 7] all_fc_tac);
a(asm_ante_tac¨s ç a1' ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [3] all_fc_tac);
(* *** Goal "3.2.4" *** *)
a(list_spec_nth_asm_tac 5 [¨sÆ, ¨s'Æ]);
(* *** Goal "3.2.4.1" *** *)
a(LIST_DROP_NTH_ASM_T [1, 7] all_fc_tac);
a(asm_ante_tac¨s' ç a1 ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [2] all_fc_tac);
(* *** Goal "3.2.4.2" *** *)
a(LIST_DROP_NTH_ASM_T [1, 7] all_fc_tac);
a(asm_ante_tac¨s ç a1' ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [2] all_fc_tac);
val €comparability_thm› = save_pop_thm"comparability_thm";
=TEX
\section{TEST POLICY}

Any functions are to be tested according to then
general criteria laid down in the quality plan, \cite{DS/FMU/IED/PLN008}.
The theory implemented is to be checked by the theory design tools
of \cite{DS/FMU/IED/DTD035}.
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}

