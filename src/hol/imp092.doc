%  dtd038.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Further Theorems About Sets}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP092}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.B.Jones & HAT Team Leader}
\TPPabstract{
This document contains the implementation for further theorems
about sets.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item [Issue \SCCSversion (\FormatDate{$Date$%
})]
First draft.
\end{description}
\subsection{Changes Forecast}
Further results could be added (Schroeder-Bernstein?).
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for further
theorems about sets and relations for \ProductHOL.
The detailed design for this material is given in \cite{DS/FMU/IED/HLD011}.

\subsection{Introduction}
This document develops some more advanced theorems about sets and relations
than those offered in the basic theoriues of
\cite{DS/FMU/IED/DTD044,DS/FMU/IED/DTD044}. The theorems are Zorn's lemma
(in a purely set-theoretic guise and as the more general statement about
partial orderings) and the well-ordering theorem.
\subsubsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD011}.
\subsubsection{Dependencies}
This document depends on the theory design support
tools in \cite{DS/FMU/IED/DTD035} and
on the theory of relations in \cite{DS/FMU/IED/IMP071}
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Deficiencies}
None known.
=TEX
\documentstyle[TQa4,hol1]{article}
\begin{document}
\section{PRELIMINARIES}

=SML
open_theory"set_thms";
set_pc"sets_ext";
=TEX

\section{CONSISTENCY PROOFS}
=SML
set_pc"sets_ext";
push_consistency_goal¨ChooseÆ;
a(prove_∂_tac THEN REPEAT strip_tac);
a(cases_tac¨a' = {}Æ THEN asm_prove_tac[]);
save_consistency_thm ¨ChooseÆ (pop_thm());
=TEX
\section{ZORN'S LEMMA (SPECIAL CASE)}
=SML
val zorn_Ä_conj = ¨
	µu : 'a SET SET∑
		≥u = {}
	±	SubsetClosed u
	±	NestClosed u
	¥	∂a∑MaximalâÄ u aÆ;
=TEX

=SML
val €hat_def› = ¨µu:'a SET SET; a : 'a SET∑ hat u a = {x | ≥x ç a ± a ¿ {x} ç u}Æ;
val €g_def› = ¨µu:'a SET SET; a : 'a SET∑
		g u a = if ≥hat u a = {} then	a ¿ {Choose (hat u a)} else aÆ;
val €tower_def› = ¨µu:'a SET SET; t : 'a SET SET∑
		tower u t 
	§	t Ä u
	±	{} ç t
	±	(µa∑ a ç t ¥ g u a ç t)
	±	(µv∑ v Ä t ± Nest v ¥ ﬁv ç t)Æ;
val €t0_def› = ¨µu:'a SET SET∑
		t0 u = •{t : 'a SET SET | tower u t}Æ;
val €comparable_def› = ¨µu:'a SET SET; c : 'a SET∑
		comparable u c § c ç t0 u ± µa∑a ç t0 u ¥ a Ä c ≤ c Ä aÆ;
=TEX
=SML
fun €loc_def_tac› (defn : TERM) : TACTIC = (
	let	val fnc = (fst o strip_app o fst o dest_eq o snd o strip_µ) defn;
		val exi = mk_∂(fnc, defn);
		val thm = pc_rule"predicates" prove_∂_rule exi;
	in	strip_asm_tac thm
	end
);
=TEX
=SML
val €conj1› = ([¨SubsetClosed uÆ, hat_def, g_def],
	¨µa: 'a SET∑a ç u ¥ (MaximalâÄ u a § (g u a) = a)Æ);
=TEX
=SML
set_pc"predicates";
set_goal conj1;
a(asm_rewrite_tac[get_spec¨MaximalâÄÆ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(cases_tac ¨≥ {x|≥x ç a ± a ¿ {x} ç u} = {}Æ THEN asm_rewrite_tac[]);
a(i_contr_tac THEN POP_ASM_T ante_tac THEN PC_T "sets_ext" strip_tac);
a(lemma_tac ¨a Ä a ¿ {x}Æ THEN1 PC_T1 "sets_ext" prove_tac[]);
a(all_asm_fc_tac[]);
a(list_asm_ante_tac [¨≥ x ç aÆ, ¨a ¿ {x} = aÆ] THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2" *** *)
a(rewrite_tac[pc_rule1"sets_ext" prove_rule[] ¨b = a § a Ä b ± b Ä aÆ]
	THEN REPEAT strip_tac);
a(PC_T1 "sets_ext" REPEAT strip_tac);
a(GET_ASM_T ¨SubsetClosed uÆ (asm_tac o rewrite_rule[get_spec¨SubsetClosedÆ]));
a(lemma_tac ¨a ¿ {x} Ä bÆ THEN1
	(list_asm_ante_tac [¨a Ä bÆ, ¨x ç bÆ] THEN PC_T1"sets_ext"prove_tac[]
		THEN asm_rewrite_tac[]));
a(rename_tac[] THEN all_asm_fc_tac[]);
a(swap_nth_asm_concl_tac 7);
a(lemma_tac¨≥ {x|≥x ç a ± a ¿ {x} ç u} = {}Æ THEN1
	(PC_T1"sets_ext" REPEAT strip_tac));
(* *** Goal "2.1" *** *)
a(∂_tac¨xÆ THEN PC_T1"sets_ext" REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(asm_rewrite_tac[] THEN POP_ASM_T ante_tac THEN rewrite_tac[get_spec¨ChooseÆ]);
a(PC_T1"sets_ext" REPEAT strip_tac);
a(∂_tac¨Choose {x|≥ x ç a ± a ¿ {x} ç u}Æ THEN PC_T1"sets_ext" REPEAT strip_tac);
val €lemma1› = pop_thm ();
=TEX
=SML
val €conj2› = ([¨≥(u : 'a SET SET)  = {}Æ, ¨SubsetClosed uÆ, ¨NestClosed uÆ,
		hat_def, g_def, tower_def, t0_def],
	¨tower u ((t0 : 'a SET SET ≠ 'a SET SET) u) : BOOLÆ);
=TEX
=SML
set_pc"sets_ext";
set_goal conj2;
a(PC_T1 "predicates" asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(POP_ASM_T (strip_asm_tac o µ_elim¨uÆ));
(* *** Goal "1.1" *** *)
a(i_contr_tac THEN REPEAT_N 3 (POP_ASM_T ante_tac));
a(rewrite_tac[get_spec¨SubsetClosedÆ] THEN REPEAT strip_tac);
a(list_spec_nth_asm_tac 2 [¨xÆ, ¨{}Æ]);
(* *** Goal "1.2" *** *)
a(i_contr_tac THEN POP_ASM_T ante_tac THEN rewrite_tac[get_spec¨ChooseÆ]);
a(cases_tac¨≥ Choose {x|≥ x ç a ± a ¿ {x} ç u} ç a
	± a ¿ {Choose {x|≥ x ç a ± a ¿ {x} ç u}} ç uÆ THEN asm_rewrite_tac[]);
(* *** Goal "1.3" *** *)
a(LIST_GET_NTH_ASM_T [1,2,3,6] (MAP_EVERY ante_tac));
a(rewrite_tac[get_spec¨NestClosedÆ] THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
a(lemma_tac¨v Ä sÆ);
(* *** Goal "3.1" *** *)
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(all_asm_fc_tac[]);
val €lemma2› = pop_thm ();
=TEX
=SML
val €conj3› = ([¨≥(u : 'a SET SET) = {}Æ, ¨SubsetClosed uÆ, ¨NestClosed uÆ,
		hat_def, g_def, tower_def, t0_def],
	¨Nest ((t0 : 'a SET SET ≠ 'a SET SET) u) ¥ ∂a∑ MaximalâÄ u aÆ);
=TEX
=SML
set_pc"predicates";
set_goal conj3;
a(ante_tac lemma2 THEN GET_ASM_T tower_def rewrite_thm_tac);
a(REPEAT strip_tac);
a(∂_tac¨ﬁ(t0 u)Æ);
a(lemma_tac ¨ﬁ(t0 u) ç t0 uÆ);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 2 bc_thm_tac);
a(PC_T1"sets_ext" REPEAT strip_tac);
(* *** Goal "2" *** *)
a(lemma_tac ¨ﬁ(t0 u) ç uÆ THEN1 PC_T1 "sets_ext" asm_prove_tac[]);
a(ALL_FC_T1 id_canon rewrite_tac [lemma1]);
a(PC_T1"sets_ext" REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(all_asm_fc_tac[]);
a(LIST_GET_NTH_ASM_T [2,3] (MAP_EVERY ante_tac) THEN PC_T1"sets_ext"prove_tac[]);
(* *** Goal "2.2" *** *)
a(GET_ASM_T g_def rewrite_thm_tac);
a(CASES_T¨≥ hat u (ﬁ (t0 u)) = {}Æ rewrite_thm_tac
	THEN PC_T"sets_ext" contr_tac THEN all_asm_fc_tac[]);
val €lemma3› = pop_thm ();
=TEX
=SML
val €conj4› = ([comparable_def],
	¨(µc : 'a SET∑ c ç t0 u ¥ comparable u c)
		¥ Nest ((t0 : 'a SET SET ≠ 'a SET SET) u)Æ);
=TEX
=SML
set_pc"predicates";
set_goal conj4;
a(asm_rewrite_tac[get_spec¨NestÆ, prove_rule[]¨µp q∑(p ¥ p ± q) § (p ¥ q)Æ]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
val €lemma4› = pop_thm ();
=TEX
=SML
val €conj5› = ([¨≥(u : 'a SET SET) = {}Æ, ¨SubsetClosed uÆ, ¨NestClosed uÆ,
		hat_def, g_def, tower_def, t0_def, comparable_def],
	¨tower u {c | comparable u c}
		¥ (µc: 'a SET∑ c ç t0 u ¥ comparable (u : 'a SET SET) c)Æ);
=TEX
=SML
set_pc"sets_ext";
set_goal conj5;
a(LIST_GET_ASM_T [tower_def, t0_def] rewrite_tac);
a(REPEAT strip_tac);
a(SPEC_NTH_ASM_T 1 ¨{c | comparable u c}Æ (strip_asm_tac o rewrite_rule[])
	THEN all_asm_fc_tac[]);
val €lemma5› = pop_thm ();
=TEX
=SML
val €conj6› = ([¨≥(u : 'a SET SET) = {}Æ, ¨SubsetClosed uÆ, ¨NestClosed uÆ,
		hat_def, g_def, tower_def, t0_def, comparable_def],
	¨(µc:'a SET∑ comparable (u : 'a SET SET) c ¥ comparable u (g u c))
		¥ tower u {c | comparable u c}Æ);
=TEX
=SML
set_pc"sets_ext";
set_goal conj6;
a(LIST_GET_ASM_T [tower_def] rewrite_tac);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac);
a(REPEAT strip_tac THEN asm_fc_tac[]);
(* *** Goal "2" *** *)
a(LIST_GET_ASM_T [comparable_def] rewrite_tac);
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac);
a(REPEAT strip_tac);
(* *** Goal "3" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(LIST_GET_ASM_T [comparable_def]rewrite_tac);
a(REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac);
a(strip_tac);
a(POP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "4.2" *** *)
a(spec_nth_asm_tac 7 ¨sÆ);
a(LIST_GET_NTH_ASM_T [17] fc_tac);
a(list_spec_nth_asm_tac 2 [¨aÆ, ¨xÆ, ¨x'Æ]);
a(spec_nth_asm_tac 7 ¨sÆ);
val €lemma6› = pop_thm ();
=TEX
=SML
val €conj7› = ([¨≥(u : 'a SET SET) = {}Æ, ¨SubsetClosed uÆ, ¨NestClosed uÆ,
		hat_def, g_def, tower_def, t0_def, comparable_def],
	¨(µc:'a SET∑ comparable (u : 'a SET SET) c ¥ tower u {a | a ç t0 u ± (a Ä c ≤ g u c Ä a)})
		¥ (µc∑ comparable u c ¥ comparable u (g u c))Æ);
=TEX
=SML
set_merge_pcs["predicates", "'sets_alg"];
set_goal conj7;
a(DROP_ASM_T comparable_def rewrite_thm_tac THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(spec_nth_asm_tac 5 ¨cÆ THEN1 all_asm_fc_tac[]);
a(lemma_tac¨t0 u Ä {a|a ç t0 u ± (a Ä c ≤ g u c Ä a)}Æ);
(* *** Goal "2.1" *** *)
a(GET_ASM_T t0_def (fn th => conv_tac (LEFT_C(rewrite_conv[th]))));
a(POP_ASM_T ante_tac THEN
	rewrite_tac[pc_rule1"sets_ext" prove_rule[]¨µf a∑f a ¥ •{b| f b} Ä aÆ]);
(* *** Goal "2.2" *** *)
a(POP_ASM_T (PC_T1 "sets_ext" strip_asm_tac));
a(spec_nth_asm_tac 1 ¨aÆ);
a(swap_nth_asm_concl_tac 4 THEN GET_ASM_T g_def rewrite_thm_tac);
a(asm_ante_tac ¨a Ä cÆ THEN CASES_T ¨≥ hat u c = {}Æ rewrite_thm_tac
	THEN PC_T1 "sets_ext" prove_tac[]);
val €lemma7› = pop_thm ();
=TEX
=SML
val €conj8› = ([¨≥(u : 'a SET SET) = {}Æ, ¨SubsetClosed uÆ, ¨NestClosed uÆ,
		hat_def, g_def, tower_def, t0_def, comparable_def],
	¨µc:'a SET∑ comparable (u : 'a SET SET) c ¥ tower u {a | a ç t0 u ± (a Ä c ≤ g u c Ä a)}Æ);
=TEX
=SML
set_merge_pcs["predicates", "'sets_alg"];
set_goal conj8;
a(LIST_GET_ASM_T[comparable_def, tower_def] rewrite_tac);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac THEN strip_tac);
a(asm_ante_tac ¨t0 u Ä uÆ THEN PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2" *** *)
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac THEN strip_tac);
(* *** Goal "3" *** *)
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac THEN strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(lemma_tac¨g u a ç t0 uÆ);
(* *** Goal "4.1" *** *)
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac THEN strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "4.2" *** *)
a(spec_nth_asm_tac 5 ¨g u aÆ);
a(cases_tac¨a = cÆ THEN1 asm_rewrite_tac[]);
a(i_contr_tac THEN LIST_GET_NTH_ASM_T [1,2,4,5,13] (MAP_EVERY ante_tac));
a(DROP_ASMS_T (fn _ => id_tac) THEN STRIP_T rewrite_thm_tac);
a(CASES_T ¨≥ hat u a = {}Æ rewrite_thm_tac THEN PC_T1"sets_ext" prove_tac[]);
a(asm_fc_tac[]);
a(PC_T1 "prop_eq" asm_prove_tac[]);
(* *** Goal "5" *** *)
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac THEN strip_tac);
a(all_asm_fc_tac[]);
a(asm_ante_tac¨g u c Ä aÆ THEN GET_ASM_T g_def rewrite_thm_tac);
a(CASES_T ¨≥ hat u a = {}Æ rewrite_thm_tac THEN PC_T1"sets_ext" prove_tac[]);
(* *** Goal "7" *** *)
a(ante_tac lemma2 THEN LIST_GET_ASM_T [tower_def] rewrite_tac THEN strip_tac);
a(POP_ASM_T bc_thm_tac THEN REPEAT strip_tac);
a(asm_ante_tac ¨v Ä {a|a ç t0 u ± (a Ä c ≤ g u c Ä a)}Æ
	THEN PC_T1"sets_ext" prove_tac[]);
(* *** Goal "8" *** *)
a(REPEAT_N 3 (POP_ASM_T ante_tac) THEN DROP_ASMS_T (fn _ => id_tac));
a(PC_T "sets_ext" (rewrite_tac[get_spec¨NestÆ] THEN REPEAT strip_tac));
a(PC_T1 "sets_ext" (spec_nth_asm_tac 6) ¨sÆ THEN
	contr_tac THEN all_asm_fc_tac[]);
val €lemma8› = pop_thm ();
=TEX
=SML
push_goal([], zorn_Ä_conj);
a(REPEAT strip_tac);
a(MAP_EVERY loc_def_tac [hat_def, g_def, tower_def, t0_def, comparable_def]);
a(MAP_EVERY ante_tac[lemma3, lemma4, lemma5, lemma6, lemma7, lemma8]);
a(taut_tac);
val €zorn_Ä_thm› = save_pop_thm "zorn_Ä_thm";
=TEX
\section{ZORN'S LEMMA (GENERAL CASE)}
=SML
open_theory"bin_rel_thms";
new_parent"fun_rel";
=TEX
=SML
set_pc"hol";
set_goal([], ¨µr : ('a ™ 'a); a : 'a SET∑
		r ç ReflexiveIn a
	±	r ç Transitive
	±	r ç Antisymmetric
	±	(µc∑ c Ä a ± c ç Chains r ¥ ∂x∑ x ç a ± x ç UpperBounds r c)
	¥	∂x∑ x ç MaximalElements r aÆ);
a(REPEAT strip_tac);
a(lemma_tac ¨∂u∑ u = {c | c Ä a ± c ç Chains r }Æ THEN1 prove_∂_tac);
a(lemma_tac¨≥ u = {} ± SubsetClosed u ± NestClosed uÆ);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
(* *** Goal "1.1" *** *)
a(asm_rewrite_tac[] THEN PC_T1 "hol1" REPEAT strip_tac);
a(∂_tac¨{}Æ THEN rewrite_tac[get_spec¨ChainsÆ] THEN prove_tac[]);
(* *** Goal "1.2" *** *)
a(rewrite_tac[get_spec¨SubsetClosedÆ] THEN rename_tac[]
	THEN asm_rewrite_tac[get_spec¨ChainsÆ]);
a(PC_T1 "hol1" REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(asm_prove_tac[]);
(* *** Goal "1.2.2" *** *)
a(lemma_tac¨x ç a' ± y ç a'Æ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "1.3" *** *)
a(rewrite_tac[get_spec¨NestClosedÆ] THEN rename_tac[]
	THEN asm_rewrite_tac[get_spec¨ChainsÆ]);
a(PC_T1 "hol1" REPEAT strip_tac);
(* *** Goal "1.3.1" *** *)
a(PC_T1 "hol1" all_asm_fc_tac[]);
(* *** Goal "1.3.2" *** *)
a(PC_T "hol1"(DROP_ASM_T ¨Nest vÆ
	(strip_asm_tac o list_µ_elim[¨sÆ, ¨s'Æ] o rewrite_rule[get_spec¨NestÆ])));
(* *** Goal "1.3.2.1" *** *)
a(PC_T "hol1" (all_asm_fc_tac[] THEN all_asm_fc_tac[]));
(* *** Goal "1.3.2.2" *** *)
a(PC_T "hol1" (asm_fc_tac[] THEN all_asm_fc_tac[]));
(* *** Goal "2" *** *)
a(all_fc_tac[zorn_Ä_thm]);
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[get_spec¨MaximalâÄÆ]
	THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(∂_tac ¨xÆ THEN rewrite_tac[get_spec¨MaximalElementsÆ] THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 3  ante_tac THEN rewrite_tac[get_spec¨UpperBoundsÆ]
	THEN REPEAT strip_tac);
a(lemma_tac¨a' ¿ {y} Ä a ± a' ¿ {y} ç Chains r ± a' Ä a' ¿ {y}Æ);
a(PC_T1 "hol1" REPEAT strip_tac);
(* *** Goal "2.1.1" *** *)
a(PC_T1 "hol1" all_asm_fc_tac[]);
(* *** Goal "2.1.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2.1.3" *** *)
a(asm_ante_tac ¨a' ç Chains rÆ THEN PC_T1 "hol1" rewrite_tac[get_spec¨ChainsÆ]);
a(REPEAT strip_tac);
(* *** Goal "2.1.3.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2.1.3.2" *** *)
a(POP_ASM_T ante_tac THEN POP_ASM_T rewrite_thm_tac);
a(LEMMA_T ¨(x', y) ç rÆ rewrite_thm_tac);
a(DROP_ASM_T ¨r ç TransitiveÆ (strip_asm_tac o rewrite_rule[get_spec¨TransitiveÆ]));
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2.1.3.3" *** *)
a(POP_ASM_T ante_tac THEN DROP_ASM_T ¨x' = yÆ rewrite_thm_tac);
a(LEMMA_T ¨(y', y) ç rÆ rewrite_thm_tac);
a(DROP_ASM_T ¨r ç TransitiveÆ (strip_asm_tac o rewrite_rule[get_spec¨TransitiveÆ]));
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2.1.3.4" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
a(DROP_ASM_T ¨r ç ReflexiveIn aÆ
	(strip_asm_tac o rewrite_rule[get_spec¨ReflexiveInÆ]));
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(all_asm_fc_tac[]);
a(asm_ante_tac ¨a' ¿ {y} = a'Æ THEN PC_T1 "hol1" REPEAT strip_tac);
a(lemma_tac¨y ç a'Æ THEN1 spec_nth_asm_tac 1 ¨yÆ);
a(all_asm_fc_tac[]);
a(DROP_ASM_T ¨r ç AntisymmetricÆ
	(strip_asm_tac o rewrite_rule[get_spec¨AntisymmetricÆ]));
a(all_asm_fc_tac[]);
val €zorn's_lemma› = save_pop_thm "zorn's_lemma";
=TEX
\section{CONSEQUENCES OF ZORN'S LEMMA}
=SML
set_merge_pcs["'bin_rel", "hol2"];
set_goal([], ¨µf; a b; c d∑
		f ç (a ‡ c) ± g ç (b ‡ d)
	±	Dom f ° Dom g = {}
	±	Ran f ° Ran g = {}
	¥	f ¿ g ç a ¿ b ‡ c ¿ dÆ);
a(rewrite_tac[get_spec¨$‡Æ] THEN REPEAT strip_tac
	THEN contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
val €¿_‡_lemma› = pop_thm();
=TEX
=SML
set_goal([], ¨µf; a: 'a SET; b : 'b SET∑
		(f Á~Í ç Functional § f ç Injective)
	±	(f Á~Í ç Injective § f ç Functional)
	±	(f Á~Í ç Total b § f ç Surjective b)
	±	(f Á~Í ç Surjective a § f ç Total a)
	±	(f Á~Í ç b ™ a § f ç a ™ b)
	±	(f Á~Í Á~Í = f)Æ);
a(prove_tac[]);
val €rel_inv_lemma› = pop_thm();
=TEX
Note to maintainers: the proof context management in the following
proof is rather peculiar for historical reasons.
=SML
set_goal([], ¨µa : 'a SET; b : 'b SET; f : 'a ™ 'b ∑
		MaximalâÄ {h | ∂a1∑a1 Ä a ± h ç a1 ‡ b} f
	¥	(∂f∑ f ç a ‡ b) ≤ (∂g∑ g ç b ‡ a)Æ);
push_pc"hol";
a(REPEAT µ_tac THEN rewrite_tac[get_spec¨MaximalâÄÆ] THEN strip_tac);
a(cases_tac¨a = a1Æ THEN_LIST[
	≤_left_tac THEN ∂_tac ¨fÆ THEN asm_rewrite_tac[],
	≤_right_tac]);
a(∂_tac¨f Á~ÍÆ THEN asm_ante_tac ¨f ç a1 ‡ bÆ
	THEN PC_T1 "hol2" rewrite_tac(map get_spec[¨$‡Æ]));
a(rewrite_tac [rel_inv_lemma] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(list_asm_ante_tac [¨a1 Ä aÆ, ¨f ç a1 ™ bÆ]
	THEN MERGE_PCS_T1 ["hol2", "'bin_rel"] prove_tac[]); 
(* *** Goal "2" *** *)
a(MERGE_PCS_T1 ["hol2", "'bin_rel"]rewrite_tac[get_spec ¨SurjectiveÆ]);
a(contr_tac);
(* *** Goal "2.1" *** *)
a(lemma_tac ¨∂y∑y ç a \ a1Æ THEN1 (
	list_asm_ante_tac[¨≥ a = a1Æ, ¨a1 Ä aÆ] THEN PC_T1 "sets_ext" prove_tac[]));
a(lemma_tac ¨f ¿ {(y', y)} = fÆ);
(* *** Goal "2.1.1" *** *)
a(DROP_NTH_ASM_T 10 bc_thm_tac);
a(conv_tac (RIGHT_C (PC_C1 "sets_ext" prove_conv[])) THEN REPEAT strip_tac);
a(∂_tac¨a1 ¿ {y'}Æ THEN REPEAT strip_tac);
(* *** Goal "2.1.1.1" *** *)
a(list_asm_ante_tac[¨y' ç aÆ, ¨a1 Ä aÆ] THEN PC_T1 "sets_ext" REPEAT strip_tac);
(* *** Goal "2.1.1.1.1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2.1.1.1.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2.1.1.2" *** *)
a(once_rewrite_tac[pc_rule1"sets_ext" prove_rule[]¨b = b ¿ bÆ]);
a(bc_tac[¿_‡_lemma]);
(* *** Goal "2.1.1.2.1" *** *)
a(PC_T1 "hol1" asm_rewrite_tac[get_spec¨$‡Æ]);
(* *** Goal "2.1.1.2.2" *** *)
a(MERGE_PCS_T1 ["hol2", "'bin_rel"] prove_tac[get_spec¨$‡Æ]
	THEN asm_rewrite_tac[]);
(* *** Goal "2.1.1.2.3" *** *)
a(rewrite_tac[get_spec¨DomÆ] THEN PC_T1 "sets_ext" REPEAT strip_tac);
a(swap_asm_concl_tac ¨(x, y'') ç fÆ THEN asm_rewrite_tac[]);
a(swap_asm_concl_tac ¨f ç a1 ™ bÆ THEN PC_T1 "'bin_rel" rewrite_tac[]);
a(PC_T1 "hol1" REPEAT strip_tac);
a(∂_tac¨(y', y'')Æ THEN REPEAT strip_tac);
(* *** Goal "2.1.1.2.4" *** *)
a(rewrite_tac[get_spec¨RanÆ] THEN PC_T1 "sets_ext" REPEAT strip_tac);
a(swap_asm_concl_tac ¨(x', x) ç fÆ THEN asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a(spec_asm_tac¨µ x∑ ≥ (x, y) ç fÆ¨y'Æ);
a(lemma_tac¨(y', y) ç fÆ);
a(GET_NTH_ASM_T 2 (once_rewrite_thm_tac o eq_sym_rule));
a(PC_T1 "sets_ext" prove_tac[]);
(* *** Goal "2.2" *** *)
a(swap_asm_concl_tac ¨f ç a1 ™ bÆ THEN PC_T1 "'bin_rel" rewrite_tac[]);
a(PC_T1 "hol1" REPEAT strip_tac);
a(∂_tac¨(x, y)Æ THEN REPEAT strip_tac);
val €lemma10› = pop_thm();
=TEX
=SML
set_merge_pcs["hol2", "'bin_rel"];
set_goal([], ¨µa : 'a SET; b : 'b SET∑
	(∂f∑ f ç a ‡ b) ≤ (∂g∑ g ç b ‡ a)Æ);
a(REPEAT µ_tac);
a(bc_tac[lemma10, zorn_Ä_thm]);
(* *** Goal "1" *** *)
a(REPEAT strip_tac);
a(∂_tac¨{}Æ THEN rewrite_tac(map get_spec[¨$‡Æ, ¨$™Æ]) THEN REPEAT strip_tac);
a(∂_tac¨{}Æ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(rewrite_tac[get_spec¨SubsetClosedÆ] THEN REPEAT strip_tac);
a(∂_tac¨Dom b'Æ THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(all_asm_fc_tac[]);
a(asm_ante_tac¨a' ç a1 ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ, ¨$™Æ, ¨$∏Æ])
	THEN REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(rewrite_tac(map get_spec[¨$‡Æ])THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2.2" *** *)
a(all_asm_fc_tac[]);
a(asm_ante_tac¨a' ç a1 ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
(* *** Goal "2.2.3" *** *)
a(asm_ante_tac¨a' ç a1 ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2.2.4" *** *)
a(asm_ante_tac¨a' ç a1 ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(rewrite_tac[get_spec¨NestClosedÆ, get_spec¨NestÆ] THEN REPEAT strip_tac);
a(∂_tac¨Dom (ﬁv)Æ THEN REPEAT strip_tac);
(* *** Goal "3.1" *** *)
a(LIST_GET_NTH_ASM_T [4] all_fc_tac);
a(asm_ante_tac¨s ç a1 ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [4] all_fc_tac);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(rewrite_tac(map get_spec[¨$‡Æ]) THEN REPEAT strip_tac);
(* *** Goal "3.2.1" *** *)
a(MAP_EVERY ∂_tac[¨x2Æ, ¨sÆ] THEN asm_rewrite_tac[]);
(* *** Goal "3.2.2" *** *)
a(LIST_GET_NTH_ASM_T [4] all_fc_tac);
a(asm_ante_tac¨s ç a1 ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [4] all_fc_tac);
(* *** Goal "3.2.3" *** *)
a(list_spec_nth_asm_tac 5 [¨sÆ, ¨s'Æ]);
(* *** Goal "3.2.3.1" *** *)
a(LIST_DROP_NTH_ASM_T [1, 7] all_fc_tac);
a(asm_ante_tac¨s' ç a1 ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [3] all_fc_tac);
(* *** Goal "3.2.3.2" *** *)
a(LIST_DROP_NTH_ASM_T [1, 7] all_fc_tac);
a(asm_ante_tac¨s ç a1' ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [3] all_fc_tac);
(* *** Goal "3.2.4" *** *)
a(list_spec_nth_asm_tac 5 [¨sÆ, ¨s'Æ]);
(* *** Goal "3.2.4.1" *** *)
a(LIST_DROP_NTH_ASM_T [1, 7] all_fc_tac);
a(asm_ante_tac¨s' ç a1 ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [2] all_fc_tac);
(* *** Goal "3.2.4.2" *** *)
a(LIST_DROP_NTH_ASM_T [1, 7] all_fc_tac);
a(asm_ante_tac¨s ç a1' ‡ bÆ THEN rewrite_tac(map get_spec[¨$‡Æ])
	THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [2] all_fc_tac);
val €comparability_thm› = save_pop_thm"comparability_thm";
=TEX
We first prove the Schroeder-Bernstein theorem in the special case
where one of the two functions is the identify function, i.e. it
is the inclusion of a subset. The informal proof which guides the
HOL proof goes as follows:

Assume that 
=INLINEFT
c Ä b Ä a
=TEX
\ and that $f$ is a 1-1 function from $a$ into $c$.
The Schroeder-Bernstein theorem asserts that under these conditions
there exists a bijection between $a$ and $b$. To see this, first
define a function
$u$ from the natural numbers to the power set of $a$ as follows:

=GFT
	u(0) = a \ b
	u (i+1) = {y | ∂x∑ (x, y) ç f} ( = {y | ∂x∑f(x) = y}
=TEX
Consider the function $h$ defined for $x$ in $a$ by:
=GFT
	h(x) = if ∂i∑x ç u i then f x else x
=TEX
I claim that $h$ is the desired bijection between $a$ and $b$.
To prove this we must prove that $h$ is 1-1 and that its range
is $b$.

To see that $h$ is 1-1, consider two elements, $x$ and $y$, say,
of $x$, such that $h(x) = h(y)$.  If $x$ and $y$ are both in one of the
$u(i)$, then $f(x) = h(x) = h(y) = f(x)$, and so $x = y$, since $f$ is 1-1.
If neither $x$ nor $y$ is in one of the $u(i)$ then $x = h(x) = h(y) = y$.
If one of the $x$ and $y$, say w.l.o.g $x$, is in $u(i)$ for some $i$
but $y$ is not, then we have $f(x) = h(x) = y$, but then $y$ is in $u(i+1)$
by the definition of $u$, which is a contradiction: $h(x) = h(y)$ cannot
happen under these conditions. Thus $h$ is, indeed, 1-1.

Let $x$ be any element of $a$, if $x$ is not in $b$ then, $x$ is in $u(0)$,
(by the definition of $u$), so $h(x) = f(x)$ which is in $c$, and so
certainly in $a$. If $x$ is in $b$, then both $x$ and $f(x)$ are also
in $b$, so that $h(x)$ is in $b$ regardless of whether $x$ is in some $u(i)$.
This shows that the range of $h$ is contained in $b$.

Now let $y$ be any element of $b$, if $y$ is in $u(i)$ for some $i$, then
$i$ cannot be $0$ (by the definition of $u(0)$), and so $y = h(x)$ for
some $x$ in $u(i-1)$ and $y$ is in the range of $h$, if on the other hand
$y$ is not in any of the $u(i)$ then $h(y) = y$ and again $y$ is in the
range of $b$. Thus the range of $h$ contains $b$. Taking this with
the observation of the last paragraph shows that $h$ has range equal
to $b$ and so is a bijection between $a$ and $b$ as required.
=SML
set_merge_pcs["hol2", "'bin_rel"];
set_goal([], ¨µa b c : 'a SET; f : 'a ™ 'a∑
	c Ä b ± b Ä a ± f ç a ‡ c ¥ ∂h∑h ç a è bÆ);
a(rewrite_tac(map get_spec[¨$‡Æ]) THEN REPEAT strip_tac);
a(lemma_tac ¨∂u∑
		u 0 = a \ b
	±	µ i∑u (i+1) = {y | ∂x∑x ç u i ± (x, y) ç f}Æ
	THEN1 prove_∂_tac);
a(∂_tac¨{(x, y) |
		x ç a
	±	if ∂i∑x ç u i then (x, y) ç f else y = x}Æ);
a(asm_rewrite_tac(map get_spec[¨$èÆ]));
a(REPEAT strip_tac THEN_TRY all_var_elim_asm_tac
	THEN_TRY SOLVED_T(contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]));
(* *** Goal "1" of 6 but 5 is a duplicate; ëREPEAT strip_tacÆ alone gives 50 *** *)
a(POP_ASM_T (ante_tac o µ_elim¨0Æ) THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac¨x ç u(i + 1)Æ);
(* *** Goal "2.1" *** *)
a(GET_NTH_ASM_T 6 rewrite_thm_tac THEN REPEAT strip_tac);
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2.2" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3" *** *)
a(lemma_tac¨y ç u(i + 1)Æ);
(* *** Goal "3.1" *** *)
a(GET_NTH_ASM_T 6 rewrite_thm_tac THEN REPEAT strip_tac);
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "3.2" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "4" *** *)
a(cases_tac ¨≥∂i∑x ç u iÆ);
(* *** Goal "4.1" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "4.2" *** *)
a(strip_asm_tac (µ_elim¨iÆ Ó_cases_thm) THEN all_var_elim_asm_tac1);
(* *** Goal "4.2.1" *** *)
a(i_contr_tac THEN POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "4.2.2" *** *)
a(swap_nth_asm_concl_tac 1 THEN asm_rewrite_tac[]);
a(swap_nth_asm_concl_tac 1);
a(strip_tac THEN ∂_tac¨x'Æ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "6" (5 was a duplicate) *** *)
a(LEMMA_T ¨∂y∑(x, y) ç fÆ rewrite_thm_tac THEN1
	(contr_tac THEN asm_fc_tac[]));
a(cases_tac ¨≥∂i∑x ç u iÆ);
(* *** Goal "6.1" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "6.2" *** *)
a(LEMMA_T ¨∂i∑ x ç u iÆ rewrite_thm_tac THEN
	(contr_tac THEN asm_fc_tac[]));

val €schroeder_bernstein_thm1› = save_pop_thm"schroeder_bernstein_thm1";
=TEX
=SML
set_pc "hol";
set_goal([], ¨µa  : 'a SET; b : 'b SET; c : 'c SET; f : 'a ™ 'b; g :'b ™ 'c∑
	f ç a ‡ b ± g ç b ‡ c ¥ (g o f) ç a ‡ Ran (g o f)Æ);
a(rewrite_tac[get_spec¨$‡Æ]);
a(REPEAT strip_tac);
set_merge_pcs ["hol2", "'bin_rel"];
(* *** Goal "1" *** *)
a(list_asm_ante_tac [¨f ç a ™ bÆ, ¨g ç b ™ cÆ] THEN prove_tac[]);
(* *** Goal "2" *** *)
a(list_asm_ante_tac [¨f ç FunctionalÆ, ¨g ç FunctionalÆ]);
a(DROP_ASMS_T (fn _ => id_tac));
a(contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
a(all_var_elim_asm_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(list_asm_ante_tac [¨f ç InjectiveÆ, ¨g ç InjectiveÆ]);
a(DROP_ASMS_T (fn _ => id_tac));
a(contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
a(all_var_elim_asm_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(list_asm_ante_tac [¨f ç Total aÆ, ¨f ç a ™ bÆ, ¨g ç Total bÆ]);
a(DROP_ASMS_T (fn _ => id_tac));
a(contr_tac THEN REPEAT_N 4 (all_asm_fc_tac[]));
val ‡_o_lemma = pop_thm();
=TEX
=SML
set_pc"hol";
set_goal([], ¨µa  : 'a SET; b : 'b SET; f : 'a ™ 'b; g :'b ™ 'a∑
	f ç a ‡ b ± g ç b ‡ a ¥ ∂h∑h ç a è bÆ);
a(REPEAT strip_tac);
a(all_fc_tac [µ_elim¨aÆ ‡_o_lemma]);
a(strip_asm_tac (merge_pcs_rule1["hol2", "'bin_rel"]prove_rule[get_spec¨$‡Æ]
	¨Ran (g o f) Ä Ran g ± (g ç b ‡ a ¥ Ran g Ä a)Æ));
(* *** Goal "1" *** *)
a(all_fc_tac [schroeder_bernstein_thm1]);
a(∂_tac¨{(u, w) | ∂v∑ (u, v) ç h ± (w, v) ç g}Æ);
a(list_asm_ante_tac [¨g ç b ‡ aÆ, ¨h ç a è Ran gÆ]);
set_merge_pcs ["hol2", "'bin_rel"];
a(DROP_ASMS_T (fn _ => id_tac));
a(rewrite_tac(map get_spec[¨$‡Æ,  ¨$èÆ]) THEN REPEAT strip_tac
	THEN contr_tac THEN (all_asm_fc_tac[] THEN_TRY all_var_elim_asm_tac)
	THEN REPEAT_N 2 (all_asm_fc_tac[]));
val €schroeder_bernstein_thm› = save_pop_thm"schroeder_bernstein_thm";
=TEX
\section{TEST POLICY}

Any functions are to be tested according to then
general criteria laid down in the quality plan, \cite{DS/FMU/IED/PLN008}.
The theory implemented is to be checked by the theory design tools
of \cite{DS/FMU/IED/DTD035}.
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}

a(contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
