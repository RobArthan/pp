=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Module Tests for Tactics II}
\TPPref{DS/FMU/IED/MDT028}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthors{R.D.~Arthan & WIN01 \\ K.~Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the module tests for the 
first group of tactics and tacticals in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.3]
Tidying.
\item [Issue 1.4]
Adding new tests.
\item [Issue 1.5]
Reacting to issue 1.5/6 of \cite{DS/FMU/IED/DTD051}.

\item[Issue 1.6, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.7]
Removed duplicate labels.
\item [Issue 1.8]
Added $swap\_asm\_concl\_tac$ stuff.
\end{description}
\subsection{Changes Forecast}
Completion of coverage.
\section{GENERAL}
\subsection{Scope}
This document contains the module tests for the material
whose detailed design is given in in \cite{DS/FMU/IED/DTD009}.
\subsection{Introduction}
We are pretty cursory in the following, doing little more than just demonstrating
the tactics presence and error message origin.
\subsubsection{Dependencies}
The tests depend upon \cite{DS/FMU/IED/IMP028} and \cite{DS/FMU/IED/IMP013}.
In addition, testing by the subgoal package (section \ref{subgoalpackage})
depends on \cite{DS/FMU/IED/IMP030}.
\subsubsection{Deficiencies}
The testing could be more rigorous.
The coverage is incomplete, even at the given level of rigour.
\section{TEST CASES}
\begin{description}
\item[Group 1]
This checks the trivial tactics.
\end{description}
\section{PREAMBLE}
=SML
open_theory"misc";
new_theory"tst009";
usefile "dtd013";
usefile "imp013";
init_mt_results();
set_flag("subgoal_package_quiet",true);
=TEX
\section{TESTS}
\subsection{Testing by $tac\_proof$}
=SML
val th1 = tac_proof( ([], ¬T®), t_tac );

val th2 = tac_proof( ([¬A:BOOL®], ¬A ¤ T®), ¤_t_tac THEN POP_ASM_T accept_tac );
val th3 = tac_proof( ([¬A:BOOL®], ¬T ¤ A®), ¤_t_tac THEN POP_ASM_T accept_tac );
val th4 = tac_proof( ([], ¬T ¤ T®), ¤_t_tac THEN t_tac);

val th5 = tac_proof( ([¬F®], ¬A:BOOL®), contr_tac THEN POP_ASM_T accept_tac );

val th6 = tac_proof( ([], ¬³F:BOOL®),
	³_T2 ¬A:BOOL®
		(fn th => asm_tac th THEN accept_tac th5)
		(fn th => asm_tac th THEN accept_tac(inst_term_rule[(¬³A®, ¬A:BOOL®)]th5)) );

val th7 = tac_proof( ([], ¬³F:BOOL®),
	C_CONTR_T asm_tac THEN POP_ASM_T (accept_tac o ³_³_elim) );
=IGN
Don't work, don't understand it:
val th8 = tac_proof( ([], ¬³F®),
	³_T ¬F® (fn th => asm_tac th THEN accept_tac(asm_rule¬F®)) );
=TEX
=SML
val th9 = tac_proof( ([¬F®, ¬³F®], ¬A:BOOL®),
	³_elim_tac ¬F® THEN
		(accept_tac(asm_rule¬F®) ORELSE accept_tac(asm_rule¬³F®))  );

val th10 = tac_proof( ([], ¬T ± ³F®),
	±_tac THEN_LIST[t_tac, accept_tac f_thm]  );

val th11 = tac_proof( ([], ¬T ² F®),
	²_left_tac THEN t_tac  );


val th12 = tac_proof( ([], ¬F ² T®),
	²_right_tac THEN t_tac  );
=TEX
=SML
val th13 = tac_proof( ([], ¬A ´ A®),
	´_T accept_tac  );

val th14 = tac_proof( ([], ¬if a then a else ³a®),
	if_tac THEN POP_ASM_T accept_tac  );

val th15 = tac_proof( ([], ¬µx:'a·¶y:'a·x = y®),
	strip_tac THEN simple_¶_tac ¬x® THEN accept_tac(refl_conv ¬x®));

val th16 = tac_proof( ([], ¬µx:'a·¶%down%1y:'a·x = y®),
	strip_tac THEN simple_¶%down%1_tac ¬x®
	THEN_LIST
		[accept_tac(refl_conv ¬x®),
		simple_µ_tac THEN ´_T (accept_tac o eq_sym_rule)]);
=TEX
\subsection{Testing Using Subgoal Package}
\label{subgoalpackage}
The following functions apply a tactic to a selected goal
and returns the resulting top goal. 
This of course doesn't fully test tactics that return multiple
goals.
The functions differ in that $tac\_res1$ inputs and outputs
both assumptions and conclusion, while $tac\_res$
just assumes an empty assumption list.
=SML
fun Ûtac_resÝ tac goal = (push_goal([],goal);
		a tac;
		let val (asms,gl) = top_goal()
		in
			(drop_main_goal();
			gl)
		end);
fun Ûtac_res1Ý tac (asms, goal) = (
		push_goal(asms,goal);
		a tac;
		let val (asms,gl) = top_goal()
		in
			(drop_main_goal();
			(asms,gl))
		end);
=TEX
This function tests that a tactic proves a goal:
=SML
fun Ûtac_solveÝ tac (asms, goal) = (
	dest_thm (tac_proof ((asms,goal),tac))
	=
	(asms, goal)
);
=TEX
This function tests that a tactic fails on a goal:
=SML
fun Ûtac_failÝ tac (asms, goal) = (
	push_goal(asms,goal);
	a tac
	handle complaint =>
	(drop_main_goal();
	reraise complaint (area_of complaint))
);
=TEX
=SML

=TEX
We use the initial stripping context:
=SML
val _ = push_proof_context initial_strip_epc;
=TEX

\subsection{Stripping Tactics and Tacticals}
We don't test much of the moving in of negations, as
the tests for $simple\_³\_in\_conv$ may be considered adequate.
=SML
store_mt_results mt_run [
	("strip_tac 1",
	tac_res strip_tac,
	¬µ x · x ± y®,
	¬x ± y®),
	("strip_tac 2",
	tac_res strip_tac,
	¬a ± b®,
	¬a : BOOL®),
	("strip_tac 3",
	tac_res strip_tac,
	¬a ² ³ b®,
	¬b ´ a®),
	("strip_tac 4",
	tac_res strip_tac,
	¬³ a ² b®,
	¬a ´ b®),
	("strip_tac 5",
	tac_res strip_tac,
	¬a ² b®,
	¬³ a ´ b®),
	("strip_tac 6",
	tac_res strip_tac,
	¬a ¤ b®,
	¬(a ´ b) ± (b ´ a)®),
	("strip_tac 7",
	tac_res strip_tac,
	¬if a then (b:BOOL) else c®,
	¬(a ´ b) ± (³ a ´ c)®),
	("strip_tac 8",
	tac_res strip_tac,
	¬³ (a ² b)®,
	¬³ a ± ³ b®)];
store_mt_results mt_run [
	("strip_tac a1",
	tac_res1 strip_tac,
	([],¬a ´ b®),
	([¬a:BOOL®],¬b:BOOL®)),
	("strip_tac a2",
	tac_res1 strip_tac,
	([¬a:BOOL®],¬a ´ b®),
	([¬a:BOOL®],¬b:BOOL®)),
	("strip_tac a3",
	tac_res1 strip_tac,
	([],¬(a ± b) ´ c®),
	([¬b:BOOL®,¬a:BOOL®],¬c:BOOL®)),
	("strip_tac a4",
	tac_res1 strip_tac,
	([],¬(a ² b) ´ c®),
	([¬a:BOOL®],¬c:BOOL®)),
	("strip_tac a5",
	tac_res1 strip_tac,
	([],¬(¶ x · f x) ´ a®),
	([¬f x :BOOL®],¬a:BOOL®)),
	("strip_tac a6",
	tac_res1 strip_tac,
	([],¬(a ´ b) ´ c®),
	([¬³ a®],¬c:BOOL®)),
	("strip_tac a7",
	tac_res1 strip_tac,
	([],¬(a ¤ b) ´ c®),
	([¬³ b®,¬³ a®],¬c : BOOL®)),
	("strip_tac a8",
	tac_res1 strip_tac,
	([],¬(if a then b else c) ´ d®),
	([¬c:BOOL®,¬³ a®],¬d:BOOL®)),
	("strip_tac a9",
	tac_res1 strip_tac,
	([],¬(³( a ² b)) ´ c®),
	([¬³ b®,¬³ a®],¬c : BOOL®)),
	("strip_tac a10",
	tac_res1 strip_tac,
	([],¬(¶%down%1 x · f x) ´ a®),
	([¬µ x':'a · f x' ´ x' = x®,¬f x:BOOL®],¬a:BOOL®))
];
store_mt_results mt_run [
	("strip_tac tp1",
	tac_solve strip_tac,
	([],¬T®),
	true),
	("strip_tac tp2",
	tac_solve strip_tac,
	([¬a:BOOL®,¬b:BOOL®],¬a:BOOL®),
	true),
	("strip_tac tp3",
	tac_solve strip_tac,
	([],¬(a ± b) ´ a®),
	true),
	("strip_tac tp4",
	tac_solve strip_tac,
	([¬³ a®],¬(a ± b) ´ c®),
	true),
	("strip_tac tp5",
	tac_solve strip_tac,
	([¬a:BOOL®],¬³ (a ² b) ´ c®),
	true)
];
store_mt_results mt_run_fail [("strip_tac",
	tac_fail strip_tac,
	([],¬f x : BOOL®),
	gen_fail_msg "strip_tac" 28003 ["¬f x®"])];
=TEX
$strip\_asm\_tac$ has been tested in testing $strip\_tac$,
but for the record:
=SML
store_mt_results mt_run [("strip_asm_tac 1",
	tac_res1 (strip_asm_tac (asm_rule ¬a ± b®)),
	([¬a ± b®],¬c:BOOL®),
	([¬b:BOOL®,¬a:BOOL®,¬a ± b®],¬c:BOOL®)),
	("strip_asm_tac 2",
	tac_res1 (strip_asm_tac t_thm),
	([],¬c:BOOL®),
	([],¬c:BOOL®))];
=TEX
$check\_asm\_tac$ has been tested in testing $strip\_tac$,
but for the record:
=SML
store_mt_results mt_run [("check_asm_tac 1",
	tac_res1 (check_asm_tac (±_left_elim(asm_rule ¬a ± b®))),
	([¬a ± b®],¬c:BOOL®),
	([¬a:BOOL®,¬a ± b®],¬c:BOOL®)),
	("check_asm_tac 2",
	tac_res1 (check_asm_tac t_thm),
	([],¬c:BOOL®),
	([],¬c:BOOL®))];
=TEX
$STRIP\_THM\_THEN$ has been tested in testing $strip\_tac$,
but for the record:
=SML
store_mt_results mt_run [("STRIP_THM_THEN",
	tac_res1 ((STRIP_THM_THEN strip_asm_tac) (asm_rule ¬a ± b®)),
	([¬a ± b®],¬c:BOOL®),
	([¬b:BOOL®,¬a:BOOL®,¬a ± b®],¬c:BOOL®))];
store_mt_results mt_run_fail [("STRIP_THM_THEN 28003",
	STRIP_THM_THEN strip_asm_tac,
	t_thm,
	gen_fail_msg "STRIP_THM_THEN" 28003 ["ô T"])];
=TEX
$STRIP\_GOAL\_T$ has been tested in testing $strip\_tac$,
but for the record:
=SML
store_mt_results mt_run [("STRIP_GOAL_T",
	tac_res1 (STRIP_GOAL_T asm_tac),
	([],¬(a ± b) ´ c®),
	([¬a ± b®],¬c : BOOL®))];
store_mt_results mt_run_fail [("STRIP_GOAL_T 28003",
	tac_fail (STRIP_GOAL_T asm_tac),
	([],¬f x: BOOL®),
	gen_fail_msg "STRIP_GOAL_T" 28003 ["¬f x®"])];
=TEX
=SML
store_mt_results mt_run [
	("goal_in_asms_tac",
	tac_solve goal_in_asms_tac,
	([¬a:BOOL®,¬b:BOOL®,¬c:BOOL®],¬b:BOOL®),
	true)
];
store_mt_results mt_run_fail [
	("goal_in_asms_tac 28002 a",
	tac_fail goal_in_asms_tac,
	([],¬a:BOOL®),
	gen_fail_msg "goal_in_asms_tac" 28002 []),
	("goal_in_asms_tac 28002 b",
	tac_fail goal_in_asms_tac,
	([¬b:BOOL®,¬c:BOOL®],¬a:BOOL®),
	gen_fail_msg "goal_in_asms_tac" 28002 [])
	];
=TEX
\subsection{Concerning $T$}
=SML
store_mt_results mt_run [
	("t_tac",
	tac_solve t_tac,
	([¬a:BOOL®,¬b:BOOL®,¬c:BOOL®],¬T®),
	true)
];
store_mt_results mt_run_fail [
	("t_tac 28011",
	tac_fail t_tac,
	([],¬a:BOOL®),
	gen_fail_msg "t_tac" 28011 [])];
=TEX
=SML
store_mt_results mt_run [("¤_t_tac 1",
	tac_res ¤_t_tac,
	¬T ¤ a®,
	¬a:BOOL®),
	("¤_t_tac 2",
	tac_res ¤_t_tac,
	¬a ¤ T®,
	¬a:BOOL®)];
store_mt_results mt_run_fail [
	("¤_t_tac 28012",
	tac_fail ¤_t_tac,
	([],¬a:BOOL®),
	gen_fail_msg "¤_t_tac" 28012 [])];
=TEX
\subsection{Concerning $F$}
=SML
store_mt_results mt_run [("contr_tac",
	tac_res1 contr_tac,
	([¬a:BOOL®,¬³ a:BOOL®],¬c:BOOL®),
	([¬a:BOOL®,¬³ a:BOOL®],¬F:BOOL®))];
store_mt_results mt_run [("f_thm_tac",
	tac_res1 (f_thm_tac (asm_rule mk_f)),
	([],¬a:BOOL®),
	([],¬F:BOOL®))];
store_mt_results mt_run_fail [("f_thm_tac 28021",
	tac_fail (f_thm_tac t_thm),
	([],¬a:BOOL®),
	gen_fail_msg "f_thm_tac" 28021 ["ô T"])];
store_mt_results mt_run [("c_contr_tac",
	tac_res1 c_contr_tac ,
	([],¬a ² b®),
	([¬³ b®,¬³ a®],¬F®))];
store_mt_results mt_run [("C_CONTR_T",
	tac_res1 (C_CONTR_T asm_tac) ,
	([],¬a ² b®),
	([¬³(a ² b)®],¬F®))];
=TEX
\subsection{Concerning Assumptions}
=SML
store_mt_results mt_run [
	("swap_asm_concl_tac",
	tac_res1 (swap_asm_concl_tac ¬b ± c®),
	([¬a ± b®, ¬b ± c®, ¬c ± d®], ¬a ± d®),
	([¬³ a®, ¬a ± b®, ¬c ± d®], ¬³(b ± c)®))
	];
store_mt_results mt_run [
	("swap_nth_asm_concl_tac",
	tac_res1 (swap_nth_asm_concl_tac 2),
	([¬a ± b®, ¬b ± c®, ¬c ± d®], ¬a ± d®),
	([¬³ a®, ¬a ± b®, ¬c ± d®], ¬³(b ± c)®))
	];
store_mt_results mt_run [
	("list_swap_asm_concl_tac",
	tac_res1 (list_swap_asm_concl_tac [¬b ± c®,¬a ± b®]),
	([¬a ± b®, ¬b ± c®, ¬c ± d®], ¬a ± d®),
	([¬³ a®, ¬c ± d®], ¬³(b ± c) ² ³ (a ± b)®))
	];
store_mt_results mt_run [
	("list_swap_nth_asm_concl_tac",
	tac_res1 (list_swap_nth_asm_concl_tac [2,1]),
	([¬a ± b®, ¬b ± c®, ¬c ± d®], ¬a ± d®),
	([¬³ a®, ¬c ± d®], ¬³(b ± c) ² ³ (a ± b)®))
	];
=TEX
=SML
store_mt_results mt_run [
	("SWAP_ASM_CONCL_T",
	tac_res1 (SWAP_ASM_CONCL_T ¬b ± c® asm_tac),
	([¬a ± b®, ¬b ± c®, ¬c ± d®], ¬a ± d®),
	([¬³ (a ± d)®, ¬a ± b®, ¬c ± d®], ¬³(b ± c)®))
	];
store_mt_results mt_run [
	("SWAP_NTH_ASM_CONCL_T",
	tac_res1 (SWAP_NTH_ASM_CONCL_T 2 asm_tac),
	([¬a ± b®, ¬b ± c®, ¬c ± d®], ¬a ± d®),
	([¬³ (a ± d)®, ¬a ± b®, ¬c ± d®], ¬³(b ± c)®))
	];
store_mt_results mt_run [
	("LIST_SWAP_ASM_CONCL_T",
	tac_res1 (LIST_SWAP_ASM_CONCL_T [¬b ± c®,¬a ± b®] asm_tac),
	([¬a ± b®, ¬b ± c®, ¬c ± d®], ¬a ± d®),
	([¬³ (a ± d)®, ¬c ± d®], ¬³(b ± c) ² ³ (a ± b)®))
	];
store_mt_results mt_run [
	("LIST_SWAP_NTH_ASM_CONCL_T",
	tac_res1 (LIST_SWAP_NTH_ASM_CONCL_T [2,1] asm_tac),
	([¬a ± b®, ¬b ± c®, ¬c ± d®], ¬a ± d®),
	([¬³ (a ± d)®, ¬c ± d®], ¬³(b ± c) ² ³ (a ± b)®))
	];
=TEX
=SML
store_mt_results mt_run_fail [
	("swap_asm_concl_tac 28052 a",
	tac_fail (swap_asm_concl_tac ¬a:'a®),
	([],mk_t),
	gen_fail_msg "swap_asm_concl_tac" 28052 ["¬a®"]),
	("swap_asm_concl_tac 28052",
	tac_fail (swap_asm_concl_tac mk_t),
	([],mk_t),
	gen_fail_msg "swap_asm_concl_tac" 28052 ["¬T®"])];
store_mt_results mt_run_fail [
	("swap_nth_asm_concl_tac 9303",
	tac_fail (swap_nth_asm_concl_tac 1),
	([],mk_t),
	gen_fail_msg "swap_nth_asm_concl_tac" 9303 ["1"])];
store_mt_results mt_run_fail [
	("list_swap_asm_concl_tac 28052 a",
	tac_fail (list_swap_asm_concl_tac[ ¬a:'a®]),
	([],mk_t),
	gen_fail_msg "list_swap_asm_concl_tac" 28052 ["¬a®"]),
	("list_swap_asm_concl_tac 28052",
	tac_fail (list_swap_asm_concl_tac [mk_t]),
	([],mk_t),
	gen_fail_msg "list_swap_asm_concl_tac" 28052 ["¬T®"])];
store_mt_results mt_run_fail [
	("list_swap_nth_asm_concl_tac 9303",
	tac_fail (list_swap_nth_asm_concl_tac [1]),
	([],mk_t),
	gen_fail_msg "list_swap_nth_asm_concl_tac" 9303 ["1"])];
=TEX
=SML
store_mt_results mt_run_fail [
	("SWAP_ASM_CONCL_T 28052 a",
	tac_fail (SWAP_ASM_CONCL_T ¬a:'a® asm_tac),
	([],mk_t),
	gen_fail_msg "SWAP_ASM_CONCL_T" 28052 ["¬a®"]),
	("SWAP_ASM_CONCL_T 28052",
	tac_fail (SWAP_ASM_CONCL_T mk_t asm_tac),
	([],mk_t),
	gen_fail_msg "SWAP_ASM_CONCL_T" 28052 ["¬T®"])];
store_mt_results mt_run_fail [
	("SWAP_NTH_ASM_CONCL_T 9303",
	tac_fail (SWAP_NTH_ASM_CONCL_T 1 asm_tac),
	([],mk_t),
	gen_fail_msg "SWAP_NTH_ASM_CONCL_T" 9303 ["1"])];
store_mt_results mt_run_fail [
	("LIST_SWAP_ASM_CONCL_T 28052 a",
	tac_fail (LIST_SWAP_ASM_CONCL_T[ ¬a:'a®] asm_tac),
	([],mk_t),
	gen_fail_msg "LIST_SWAP_ASM_CONCL_T" 28052 ["¬a®"]),
	("LIST_SWAP_ASM_CONCL_T 28052",
	tac_fail (LIST_SWAP_ASM_CONCL_T [mk_t] asm_tac),
	([],mk_t),
	gen_fail_msg "LIST_SWAP_ASM_CONCL_T" 28052 ["¬T®"])];
store_mt_results mt_run_fail [
	("LIST_SWAP_NTH_ASM_CONCL_T 9303",
	tac_fail (LIST_SWAP_NTH_ASM_CONCL_T [1] asm_tac),
	([],mk_t),
	gen_fail_msg "LIST_SWAP_NTH_ASM_CONCL_T" 9303 ["1"])];
=TEX

\subsection{END OF TESTS}
=SML
set_flag("subgoal_package_quiet",false);
diag_string(summarize_mt_results ());
=TEX
\end{document}
=IGN
***********COPY**************
store_mt_results mt_run [("",
	tac_res ,
	¬®,
	¬®)];
store_mt_results mt_run [("",
	tac_res1 ,
	([¬®],¬®),
	([¬®],¬®))];
store_mt_results mt_run [
	("",
	tac_solve ,
	([],¬®),
	true),
];
store_mt_results mt_run_fail [("",
	tac_fail ,
	([],¬®),
	gen_fail_msg ""  [])];

store_mt_results mt_run [("",
	,
	,
	)];
store_mt_results mt_run_fail [("",
	,
	,
	gen_fail_msg ""  [])];

set_goal([], ¬a ± b®);
2 subgoals
¬b®
¬a®

set_goal([], ¬a ² b®);
¬³ a ´ b®

set_goal([], ¬a ² ³b®);
¬b ´ a®

set_goal([], ¬a ¤ b®);
¬b ´ a®
¬a ´ b®


set_goal([], ¬µx·a®);
¬a®
e strip_tac;

set_goal([], ¬³(a ± b)®);
¬³ a ² ³ b®

set_goal([], ¬³(a ² b)®);
¬³ a ± ³ b®
set_goal([], ¬³(a ¤ b)®);
¬a ± ³ b ² b ± ³ a®

set_goal([], ¬³µx·b®);

set_goal ([], ¬ (A ± B) ´ (A ² C) ®);
e(REPEAT strip_tac);
set_goal([], ¬ ((¶x·A x) ± X) ´ (Y ² (¶x·A x)) ®);

set_goal([], ¬ ((¶x·A x ¤ B x) ± X) ´ ((¶x·A x ¤ B x) ² Y) ®);
set_goal([], ¬ ((µx·A x ¤ B x) ± X) ´ ((µx·A x ¤ B x) ² Y)®);
set_goal([], ¬ ((µx·A x ¤ B x) ± X) ´ ((A x ¤ B x) ² Y)®);
set_goal([], ¬ ³(((µx·P x) ± B) ´ ((µx·P x) ² C)) ´ F®);
val thm = tac_proof ( ([], ¬ µa b · (a ² b) ¤ (b ² a)®), REPEAT strip_tac );

set_goal ([¬a ² b®, ¬c ² d®], ¬(b ² a) ± (d ² c)®);

e(REPEAT_UNTIL (is_² o snd) strip_tac THEN 
	conv_tac (simple_eq_match_conv thm) THEN goal_in_asms_tac);

set_goal ([¬a ² b®, ¬c ² d®], ¬(b ² a) ± X = X®);

e(REPEAT_UNTIL (is_² o snd) strip_tac);


set_goal([], ¬(a ² ³a)®);
e (CASES_T ¬a:BOOL® asm_tac);

e(²_left_tac THEN accept_tac (asm_rule¬a:BOOL®));
e(²_right_tac THEN accept_tac (asm_rule¬³a:BOOL®));

set_goal ([], ¬(a ¤ a)®);
e(¤_T accept_tac );

set_goal ([¬a ² b®], ¬(b ² a)®);

e(swap_²_tac THEN goal_in_asms_tac);


set_goal ([], ¬(a ± b) ² ³(a ¤ b) ² ³(a ² b)®);
e (REPEAT strip_tac);

set_goal ([], ¬(¶x y:'a·³(x =y)) ² µx y:'a·x = y®);
e(swap_²_tac THEN REPEAT strip_tac);
e(simple_¶_tac ¬x:'a® THEN simple_¶_tac ¬y:'a® THEN goal_in_asms_tac);

set_goal([¬a:BOOL®, ¬b:BOOL®, ¬c:BOOL®], ¬a ± b ± c®);
e (all_undisch_tac);
e taut_tac;

set_goal([¬a:BOOL®, ¬b:BOOL®, ¬c:BOOL®], ¬a ± b ± c®);
e (list_undisch_tac [¬a:BOOL®, ¬b:BOOL®, ¬c:BOOL®]);
e taut_tac;



