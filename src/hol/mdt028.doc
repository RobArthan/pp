=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Module Tests for Tactics I}
\TPPref{DS/FMU/IED/MDT028}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives the module tests for the 
first group of tactics and tacticals in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.3]
Tidying.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the module tests for the material
whose detailed design is given in in \cite{DS/FMU/IED/DTD009}.
\subsection{Introduction}
\subsubsection{Purpose and Background}

\subsubsection{Dependencies}

\subsubsection{Deficiencies}
\section{TEST CASES}
\begin{description}
\item[Group 1]
This checks the trivial tactics.
\end{description}
\section{PREAMBLE}
=SML
open_theory"misc";
new_theory"tst009";
open Tactics2;
init_mt_results();
=TEX
\section{TEST CODE AND DATA}
\section{Group 1}
=SML
val th1 = tac_proof( ([], ªTº), t_tac );

val th2 = tac_proof( ([ªA:BOOLº], ªA Ç Tº), Ç_t_tac THEN POP_ASM_T accept_tac );
val th3 = tac_proof( ([ªA:BOOLº], ªT Ç Aº), Ç_t_tac THEN POP_ASM_T accept_tac );
val th4 = tac_proof( ([], ªT Ç Tº), Ç_t_tac THEN t_tac);

val th5 = tac_proof( ([ªFº], ªA:BOOLº), contr_tac THEN POP_ASM_T accept_tac );

val th6 = tac_proof( ([], ªåF:BOOLº),
	å_T2 ªA:BOOLº
		(fn th => asm_tac th THEN accept_tac th5)
		(fn th => asm_tac th THEN accept_tac(inst_term_rule[(ªåAº, ªA:BOOLº)]th5)) );

val th7 = tac_proof( ([], ªåF:BOOLº),
	C_CONTR_T asm_tac THEN POP_ASM_T (accept_tac o å_å_elim) );

val th8 = tac_proof( ([], ªåFº),
	å_T (fn th => asm_tac th THEN accept_tac(asm_ruleªFº)) );

val th9 = tac_proof( ([ªFº, ªåFº], ªA:BOOLº),
	å_elim_tac ªFº THEN
		(accept_tac(asm_ruleªFº) ORELSE accept_tac(asm_ruleªåFº))  );

val th10 = tac_proof( ([], ªT Ä åFº),
	Ä_tac THEN_LIST[t_tac, accept_tac f_thm]  );

val th11 = tac_proof( ([], ªT Å Fº),
	Å_left_tac THEN t_tac  );


val th12 = tac_proof( ([], ªF Å Tº),
	Å_right_tac THEN t_tac  );
=TEX
Tests for other Å tactics deferred)
=SML
val th13 = tac_proof( ([], ªA ä Aº),
	ä_T accept_tac  );

val th14 = tac_proof( ([], ªif a then a else åaº),
	if_tac THEN POP_ASM_T accept_tac  );

val th15 = tac_proof( ([], ªÉx:'aéÑy:'aéx = yº),
	simple_strip_tac THEN simple_Ñ_tac ªxº THEN accept_tac(refl_conv ªxº));

val th16 = tac_proof( ([], ªÉx:'aéÑ%down%1y:'aéx = yº),
	simple_strip_tac THEN simple_Ñ%down%1_tac ªxº
	THEN_LIST
		[accept_tac(refl_conv ªxº),
		simple_É_tac THEN ä_T (accept_tac o eq_sym_rule)]);
=IGN


\printindex
\end{document}

set_goal([], ªa Ä bº);
2 subgoals
ªbº
ªaº

set_goal([], ªa Å bº);
ªå a ä bº

set_goal([], ªa Å åbº);
ªb ä aº

set_goal([], ªa Ç bº);
ªb ä aº
ªa ä bº


set_goal([], ªÉxéaº);
ªaº
e strip_tac;

set_goal([], ªå(a Ä b)º);
ªå a Å å bº

set_goal([], ªå(a Å b)º);
ªå a Ä å bº
set_goal([], ªå(a Ç b)º);
ªa Ä å b Å b Ä å aº

set_goal([], ªåÉxébº);

set_goal ([], ª (A Ä B) ä (A Å C) º);
e(REPEAT strip_tac);
set_goal([], ª ((ÑxéA x) Ä X) ä (Y Å (ÑxéA x)) º);

set_goal([], ª ((ÑxéA x Ç B x) Ä X) ä ((ÑxéA x Ç B x) Å Y) º);
set_goal([], ª ((ÉxéA x Ç B x) Ä X) ä ((ÉxéA x Ç B x) Å Y)º);
set_goal([], ª ((ÉxéA x Ç B x) Ä X) ä ((A x Ç B x) Å Y)º);
set_goal([], ª å(((ÉxéP x) Ä B) ä ((ÉxéP x) Å C)) ä Fº);
val thm = tac_proof ( ([], ª Éa b é (a Å b) Ç (b Å a)º), REPEAT strip_tac );

set_goal ([ªa Å bº, ªc Å dº], ª(b Å a) Ä (d Å c)º);

e(REPEAT_UNTIL (is_Å o snd) strip_tac THEN 
	conv_tac (simple_eq_match_conv thm) THEN goal_in_asms_tac);

set_goal ([ªa Å bº, ªc Å dº], ª(b Å a) Ä X = Xº);

e(REPEAT_UNTIL (is_Å o snd) strip_tac);


set_goal([], ª(a Å åa)º);
e (CASES_T ªa:BOOLº asm_tac);

e(Å_left_tac THEN accept_tac (asm_ruleªa:BOOLº));
e(Å_right_tac THEN accept_tac (asm_ruleªåa:BOOLº));

set_goal ([], ª(a Ç a)º);
e(Ç_T accept_tac );

set_goal ([ªa Å bº], ª(b Å a)º);

e(swap_Å_tac THEN goal_in_asms_tac);


set_goal ([], ª(a Ä b) Å å(a Ç b) Å å(a Å b)º);
e (REPEAT strip_tac);

set_goal ([], ª(Ñx y:'aéå(x =y)) Å Éx y:'aéx = yº);
e(swap_Å_tac THEN REPEAT strip_tac);
e(simple_Ñ_tac ªx:'aº THEN simple_Ñ_tac ªy:'aº THEN goal_in_asms_tac);

set_goal([ªa:BOOLº, ªb:BOOLº, ªc:BOOLº], ªa Ä b Ä cº);
e (all_undisch_tac);
e taut_tac;

set_goal([ªa:BOOLº, ªb:BOOLº, ªc:BOOLº], ªa Ä b Ä cº);
e (list_undisch_tac [ªa:BOOLº, ªb:BOOLº, ªc:BOOLº]);
e taut_tac;

