=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the Theory Design Support Tools}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Theory Design Support Tools}
\TPPref{DS/FMU/IED/IMP035}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
% \TPPauthors{K.~Blackburn & WIN01\\D.J.~King & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document implements the tools for supporting theory designs, allowing such designs to be both type-checked, and checked against a theory implementation.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the Standard ML tools that support the production of theory designs.
They will be complimented by some shell scripts for 
document stripping.
The tools and techniques described should be used
to document all ICL supplied theories.
However, the tools do not form part of a release of ICL HOL.
The design is in \cite{DS/FMU/IED/DTD035}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the Standard ML tools that support the production of theory designs.
They will be complimented by some shell scripts for 
document stripping.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}

\section{THE THEORY DESIGN PACKAGE}
=SML
structure âTheoryDesignSupportá : TheoryDesignSupport = struct
=TEX

\subsection{Types}
We want the fixity type material from structure Lex, so:
=SML
open Lex;
=TEX
=SML

type âTHEORY_DESIGNá = {name : string OPT,
	language : string OPT,
	parents : string list,
	consts : (string * TYPE) list,
	types : (string * int) list,
	axioms : (string * SEQ) list,
	defns : (string * SEQ) list,
	thms : (string * SEQ) list,
	fixity : (string * Lex.FIXITY) list,
	terminators : string list,
	aliases : (string * TERM) list,
	type_abbrevs : (string * (string list * TYPE)) list};

datatype MODE = Declare | Check;
=TEX
\subsection{Assignable Variables}
The mode of use of the design:
=SML
val req_flag : MODE ref = ref Declare;	
=TEX
The theory design data so far:
=SML
val theory_design : THEORY_DESIGN ref = ref {
	name = Nil, language = Nil, parents = [],
	consts = [], types = [], axioms = [],
	defns = [], thms = [],
	fixity = [], terminators = [], aliases = [],
	type_abbrevs = []};
=TEX
\subsection{Starting and Stopping}
=SML
fun âinitialise_td_resultsá (mode : bool) : unit = (
	req_flag := (if mode then Declare else Check);
	theory_design := {
		name = Nil, language = Nil, parents = [],
		consts = [], types = [], axioms = [],
		defns = [], thms = [],
		fixity = [], terminators = [], aliases = [],
		type_abbrevs = []};
	()
);
=TEX
=SML
local
	open Combinators;
	fun process_ns ((nm_lst, thm) :: x) = (
		map (fn nm => (nm, dest_thm thm)) nm_lst @ process_ns x)
	| process_ns [] = [];

	fun fm_ns (nm, ((asms, gl):SEQ)) : string = (
		format_list I
		(nm ::
		 (map PolyML.makestring asms) @
		 ["… ", PolyML.makestring gl])
		"\n	");

	fun string_fix Binder = "Binder"
	| string_fix (Infix n) = "Infix "^string_of_int n
	| string_fix Nonfix = "Nonfix"
	| string_fix (Postfix n) = "Postfix "^string_of_int n
	| string_fix (Prefix n) = "Prefix "^string_of_int n;
in
fun âtd_resultsá  (give_mismatch:bool) : bool = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;

	val name = case oname of
		Nil => fail "summarize_td_results" 35001 []
		| Value name => name;
=TEX
Output a suitable message:
=SML
	val warned : bool ref = ref false;
	fun om n lst = (
		if give_mismatch
		then diag_line(get_error_message n (name :: lst))
		else ();
		warned := true);
=TEX
Compare two sets in a standard manner:
=SML
	fun compare s1 s2 fmt miss add = (
	let	val sideeffect = (case (s1 diff s2) of
		[] => ()
		| lst => om miss [format_list fmt lst ";\n"]);
		val sideeffect = (case (s2 diff s1) of
		[] => ()
		| lst => om add [format_list fmt lst ";\n"]);
	in
		()
	end);
=TEX
Now do the tests:
=SML
	val sideeffect = (case olanguage of
		Nil => if get_current_language () = "HOL"
			then ()
			else om 35017 [get_current_language (), "HOL"]
				
		| Value language => if get_current_language () = language
			then ()
			else om 35017 [get_current_language (), language]);

	val sideeffect = compare parents (get_parents name)
			I 35002 35003;

	val sideeffect = compare consts (map dest_const (get_consts name))
			(fn (nm,ty) => nm^":"^ 
				PolyML.makestring ty)
			35004 35005;

	val sideeffect = compare types 
			(map ((I ** length) o dest_ctype) (get_types name))
			(fn (nm,ar) => nm^" of arity "^string_of_int ar)
			35006 35007;
 
	val sideeffect = compare axioms 
			(process_ns (get_axioms name))
			fm_ns
			35008 35009;

	val sideeffect = compare defns 
			(process_ns (get_defns name))
			fm_ns
			35010 35011;

	val sideeffect = compare thms 
			(process_ns (get_thms name))
			fm_ns
			35014 35015;

	val sideeffect = compare terminators 
			(get_terminators name)
			I
			35012 35013;

	val sideeffect = compare aliases 
			(get_aliases name)
			(fn (nm,tm) => nm^" for " ^ 
				PolyML.makestring tm)
			35031 35032;

	val sideeffect = compare type_abbrevs 
			(get_type_abbrevs name)
			(fn (nm,(nml,ty)) => (nm^" with " ^ 
				format_list I nml "," ^
				" and " ^ PolyML.makestring ty))
			35033 35034;
=TEX
First get a list of all the names we have fixity information for, either in design, or in real theory.
=SML
	val fix_names = list_cup [get_binders name,
		get_nonfixes name, 
		map snd (get_prefixes name),
		map snd (get_postfixes name),
		map snd (get_infixes name),
		map fst fixity];
=TEX
Now check fixity of each name, note that both $get\_fixity$ and this document default to $Nonfix$.
=SML
	val side_effect = map
			(fn nm => let val dfix = lassoc4 fixity Nonfix nm;
				val tfix = get_fixity nm;
			in
				if dfix = tfix
				then ()
				else om 35016 [nm,string_fix tfix, string_fix dfix]
			end)
			fix_names;
in
	(if give_mismatch
	then	(if (!warned)
		then diag_line(get_error_message 35036 [name])
		else diag_line(get_error_message 35035 [name]))
	else ();
	not(!warned))
end);
end;
=TEX
Now use this two-way function to give the interface functions:
=SML
fun âsummarize_td_resultsá () : unit = (
	td_results true;
	()
);
fun âtheory_check_successá () : bool = (
	case (!req_flag) of
	Declare => true
	| Check => td_results false
);
=TEX
\subsection{Require Functions}
=SML
fun âreq_nameá (nm : string) (oparent : string OPT) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => ()
		| (Value name) => fail "req_name" 35020 [fn () => name];
in
	case (!req_flag) of
	Declare => (case oparent of
=TEX
No parents - this means the name should be ``min'', or 
at least already exists.
=SML
		Nil => (open_theory nm
			handle complaint =>
			divert complaint "open_theory" "req_name" 35030 [fn () => nm];
			theory_design := {
			name = Value nm, language = olanguage, 
			parents = [], consts = consts, 
			types = types, axioms = axioms,
			defns = defns,  
			thms = thms, fixity = fixity, 
			terminators = terminators, aliases = aliases,
			type_abbrevs = type_abbrevs})
=TEX
Some parents, the normal mode:
=SML		
		| Value parent => (((open_theory parent;
			new_theory nm)
			handle complaint =>
			list_divert complaint "req_name"[
				("open_theory", 35018, [fn () => parent]),
				("new_theory", 35019, [fn () => nm])]);
			theory_design := {
			name = Value nm, language = olanguage, 
			parents = [parent], consts = consts, 
			types = types, axioms = axioms,
			defns = defns,  
			thms = thms, fixity = fixity, 
			terminators = terminators, aliases = aliases,
			type_abbrevs = type_abbrevs})
	)
=TEX
Now when $req\_flag$ is $Check$.
=SML
	| Check => (case oparent of
=TEX
No parents - this means the name should be ``min'', or 
at least already exists.
=SML
		Nil => (open_theory nm
			handle complaint =>
			divert complaint "open_theory" "req_name" 35030 [fn () => nm];
			theory_design := {
			name = Value nm, language = olanguage, 
			parents = [], consts = consts, 
			types = types, axioms = axioms,
			defns = defns,  
			thms = thms, fixity = fixity, 
			terminators = terminators, aliases = aliases,
			type_abbrevs = type_abbrevs})
=TEX
Some parents, the normal mode:
=SML		
		| Value parent => ((open_theory nm
			handle complaint =>
			divert complaint "open_theory" "req_name" 35030 [fn () => nm]);
			theory_design := {
			name = Value nm, language = olanguage, 
			parents = [parent], consts = consts, 
			types = types, axioms = axioms,
			defns = defns,  
			thms = thms, fixity = fixity, 
			terminators = terminators, aliases = aliases,
			type_abbrevs = type_abbrevs})
	)
end
);
=TEX
=SML
fun âreq_languageá (lang : string) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_language" 35001 []
		| (Value _) => ();
	val side_effect = case olanguage of
		(Value lang) => fail "req_language" 35037 [fn () => lang]
		| Nil => ();
	val side_effect = case (!req_flag) of
		Check => (set_current_language lang
		) | Declare => ();
in
	theory_design := {
		name = oname, language = Value lang, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun âreq_parentá (parent : string) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_parent" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (new_parent parent
			handle complaint =>
			divert complaint "new_parent" "req_parent" 35021 [fn () => parent]
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = (parent :: parents), consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun âreq_constá ((nm,ty) : string * TYPE) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_const" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => ((new_const (nm,ty);())
			handle complaint =>
			divert complaint "new_const" "req_const" 35021 [fn () => nm]
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = ((nm, ty) :: consts), 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun âreq_typeá ((nm,ar) : string * int) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_type" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => ((new_type (nm,ar);())
			handle complaint =>
			divert complaint "new_type" "req_type" 35038 [fn () => nm]
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = ((nm,ar) :: types), axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun âreq_axiomá ((nm,seq) : string * SEQ) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst axioms)
			then fail "req_axiom" 35023 [fn () => nm]
			else ()
		) | Check => ();
	val side_effect = case oname of
		Nil => fail "req_axiom" 35001 []
		| (Value _) => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = ((nm,seq) :: axioms),
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun âreq_defná ((nm,seq) : string * SEQ) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_defn" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst defns)
			then fail "req_defn" 35024 [fn () => nm]
			else ()
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = ((nm,seq) :: defns),  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun âreq_thmá ((nm,seq) : string * SEQ) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_thm" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst thms)
			then fail "req_thm" 35025 [fn () => nm]
			else ()
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = ((nm,seq)::thms), fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun âreq_binderá (nm : string) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_binder" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst fixity)
			then fail "req_binder" 35027 [fn () => nm]
			else (declare_binder nm
				handle complaint =>
				pass_on complaint "declare_binder" "req_binder")
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = ((nm, Binder) :: fixity), 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun âreq_infixá ((prec,nm) : int * string) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_infix" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst fixity)
			then fail "req_infix" 35027 [fn () => nm]
			else (declare_infix (prec,nm)
				handle complaint =>
				pass_on complaint "declare_infix" "req_infix")
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = ((nm, Infix prec) :: fixity), 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun âreq_prefixá ((prec,nm) : int * string) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_prefix" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst fixity)
			then fail "req_prefix" 35027 [fn () => nm]
			else (declare_prefix (prec,nm)
				handle complaint =>
				pass_on complaint "declare_prefix" "req_prefix")
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = ((nm, Prefix prec) :: fixity), 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun âreq_postfixá ((prec,nm) : int * string) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_postfix" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst fixity)
			then fail "req_postfix" 35027 [fn () => nm]
			else (declare_postfix (prec,nm)
				handle complaint =>
				pass_on complaint "declare_postfix" "req_postfix")
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = ((nm, Postfix prec) :: fixity), 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun âreq_nonfixá (nm : string) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_nonfix" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst fixity)
			then fail "req_nonfix" 35027 [fn () => nm]
			else (declare_nonfix nm
				handle complaint =>
				pass_on complaint "declare_nofix" "req_nonfix")
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = ((nm, Nonfix) :: fixity), 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun âreq_terminatorá (nm : string) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_terminator" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem terminators
			then fail "req_terminator" 35028 [fn () => nm]
			else (declare_terminator nm
				handle complaint =>
				pass_on complaint "declare_terminator" "req_terminator")
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = (nm :: terminators), aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun âreq_aliasá ((nm,tm) : string * TERM) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_alias" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst aliases)
			then fail "req_alias" 35026 [fn () => nm]
			else (declare_alias (nm,tm)
				handle complaint =>
				pass_on complaint "declare_alias" "req_alias")
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = ((nm,tm)::aliases),
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun âreq_type_abbrevá ((nm,nmlty) : string * (string list * TYPE)) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_type_abbrev" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst type_abbrevs)
			then fail "req_type_abbrev" 35029 [fn () => nm]
			else ((declare_type_abbrev (nm,fst nmlty, snd nmlty);())
				handle complaint =>
				pass_on complaint "declare_type_abbrev" "req_type_abbrev")
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = ((nm,nmlty)::type_abbrevs)}
end);
=TEX
\section{END OF THE STRUCTURE}
=SML
end; (* of structure TheoryDesignSupport *)
open TheoryDesignSupport;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN
Statistics:

open Sort;
fun comp_stats (s1,n1) (s2,n2) = (
	if n1 = n2
	then stringorder s1 s2
	else (n1 - n2)
);

sort comp_stats (get_stats ());
