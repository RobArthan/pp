=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the Theory Design Support Tools}  %% Mandatory field
\def\TPPheadtitle{Implementation for the Theory Design Support Tools}
\TPPref{DS/FMU/IED/IMP035}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
% \TPPauthors{K.~Blackburn & WIN01\\D.J.~King & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document implements the tools for supporting theory designs, allowing such designs to be both type-checked, and checked against a theory implementation.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item [Issue 1.2]
Reacted to issue 1.3 of \cite{DS/FMU/IED/DTD035}.

\item[Issue 1.3, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.4]
Some rewording, changed signature of $req\-\_type\-\_abbrev$,
corrected error message of $req\-\_const$, changed $(list\_)\-req\_axiom$ and $(list\_)\-req\_defn$.
\item [Issue 1.5 (8th April 1992)]
Changes required by CR0016.
\item [Issue 1.6 (13th April 1992)]
Changes due to CR0017.
\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the Standard ML tools that support the production of theory designs.
They will be complimented by some shell scripts for 
document stripping.
The tools and techniques described should be used
to document all ICL supplied theories.
However, the tools do not form part of a release of ICL HOL.
The design is in \cite{DS/FMU/IED/DTD035}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the Standard ML tools that support the production of theory designs.
They will be complimented by some shell scripts for 
document stripping.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.

\section{THE THEORY DESIGN PACKAGE}
=SML
structure ÛTheoryDesignSupportÝ : TheoryDesignSupport = struct
=TEX

\subsection{Types}
We want the fixity type material from structure Lex, so:
=SML
open Lex;
=TEX
=SML

type ÛTHEORY_DESIGNÝ = {name : string OPT,
	language : string OPT,
	parents : string list,
	consts : (string * TYPE) list,
	types : (string * int) list,
	axioms : (string * SEQ) list,
	defns : (string * SEQ) list,
	thms : (string * SEQ) list,
	fixity : (string * Lex.FIXITY) list,
	terminators : string list,
	aliases : (string * TERM) list,
	type_abbrevs : (string * string list * TYPE) list};

datatype ÛMODEÝ = Declare | Check;
=TEX
\subsection{Assignable Variables}
The mode of use of the design:
=SML
val Ûreq_flagÝ : MODE ref = ref Check;	
=TEX
The theory design data so far:
=SML
val Ûtheory_designÝ : THEORY_DESIGN ref = ref {
	name = Nil, language = Nil, parents = [],
	consts = [], types = [], axioms = [],
	defns = [], thms = [],
	fixity = [], terminators = [], aliases = [],
	type_abbrevs = []};
=TEX
Two specialised variants of $diff$:
=SML
fun Ûss_diffÝ ((s1 : (string * SEQ) list), (s2 : (string * SEQ) list)) = (
	s1 drop (fn x => present (fn ((a,b),(c,d)) => (a = c) andalso
		b =# d) x s2)
);
=TEX
=SML
fun Ûta_diffÝ ((s1 : (string * string list * TYPE) list), 
	(s2 : (string * string list * TYPE) list)) = (
	s1 drop (fn x => present (fn ((a,b,c),(d,e,f)) => a = d andalso
		b = e andalso c =: f) x s2)
);
=TEX
\subsection{Starting and Stopping}
=SML
fun Ûinitialise_td_resultsÝ (() : unit) : unit = (
	theory_design := {
		name = Nil, language = Nil, parents = [],
		consts = [], types = [], axioms = [],
		defns = [], thms = [],
		fixity = [], terminators = [], aliases = [],
		type_abbrevs = []};
	()
);
=TEX
=SML
local
	open Combinators;
	fun process_ns ((nm_lst, thm) :: x) = (
		map (fn nm => (nm, dest_thm thm)) nm_lst @ process_ns x)
	| process_ns [] = [];

	fun fm_ns (nm, ((asms, gl):SEQ)) : string = (
		format_list I
		(nm ::
		 (map PolyML.makestring asms) @
		 ["ô ", PolyML.makestring gl])
		"\n	");

	fun string_fix Binder = "Binder"
	| string_fix (Infix n) = "Infix "^string_of_int n
	| string_fix Nonfix = "Nonfix"
	| string_fix (Postfix n) = "Postfix "^string_of_int n
	| string_fix (Prefix n) = "Prefix "^string_of_int n;
in
fun Ûtd_resultsÝ  (give_mismatch:bool) : bool = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;

	val name = case oname of
		Nil => fail "summarize_td_results" 35001 []
		| Value name => name;
=TEX
Output a suitable message:
=SML
	val warned : bool ref = ref false;
	fun om n lst = (
		if give_mismatch
		then diag_line(get_error_message n (name :: lst))
		else ();
		warned := true);
=TEX
Compare two sets in a standard manner:
=SML
	fun compare s1 s2 ldiff fmt miss add = (
	let	val sideeffect = (case (ldiff (s1, s2)) of
		[] => ()
		| lst => om miss [format_list fmt lst ";\n"]);
		val sideeffect = (case (ldiff (s2, s1)) of
		[] => ()
		| lst => om add [format_list fmt lst ";\n"]);
	in
		()
	end);
=TEX
Now do the tests:
=SML
	val sideeffect = (case olanguage of
		Nil => if get_current_language () = "HOL"
			then ()
			else om 35017 [get_current_language (), "HOL"]
				
		| Value language => if get_current_language () = language
			then ()
			else om 35017 [get_current_language (), language]);

	val sideeffect = compare parents (get_parents name)
			(op diff) I 35002 35003;

	val sideeffect = compare consts (map dest_const (get_consts name))
			(fn (l1,l2) =>
				l1 drop (fn x => present (fn ((a,b),(c,d)) =>
				a = c andalso b =: d) x l2))
			(fn (nm,ty) => nm^":"^ 
				PolyML.makestring ty)
			35004 35005;

	val sideeffect = compare types 
			(map ((I ** length) o dest_ctype) (get_types name))
			(op diff)
			(fn (nm,ar) => nm^" of arity "^string_of_int ar)
			35006 35007;
 
	val sideeffect = compare axioms 
			(process_ns (get_axioms name))
			ss_diff
			fm_ns
			35008 35009;

	val sideeffect = compare defns 
			(process_ns (get_defns name))
			ss_diff
			fm_ns
			35010 35011;

	val sideeffect = compare thms 
			(process_ns (get_thms name))
			ss_diff
			fm_ns
			35014 35015;

	val sideeffect = compare terminators 
			(get_terminators name)
			(op diff)
			I
			35012 35013;

	val sideeffect = compare aliases 
			(get_aliases name)
			(fn (l1,l2) =>
			l1 drop (fn x => present (fn ((a,b),(c,d)) => 
				a = c andalso b =$ d) x l2))
			(fn (nm,tm) => nm^" for " ^ 
				PolyML.makestring tm)
			35031 35032;

	val sideeffect = compare type_abbrevs 
			(map (fn (x,(y,z)) => (x,y,z))(get_type_abbrevs name))
			ta_diff
			(fn (nm,nml,ty) => (nm^" with " ^ 
				format_list I nml "," ^
				" and " ^ PolyML.makestring ty))
			35033 35034;
=TEX
First get a list of all the names we have fixity information for, either in design, or in real theory.
=SML
	val fix_names = list_cup [get_binders name,
		get_nonfixes name, 
		map snd (get_prefixes name),
		map snd (get_postfixes name),
		map snd (get_infixes name),
		map fst fixity];
=TEX
Now check fixity of each name, note that both $get\_fixity$ and this document default to $Nonfix$.
=SML
	val side_effect = map
			(fn nm => let val dfix = lassoc4 fixity Nonfix nm;
				val tfix = get_fixity nm;
			in
				if dfix = tfix
				then ()
				else om 35016 [nm,string_fix tfix, string_fix dfix]
			end)
			fix_names;
in
	(if give_mismatch
	then	(if (!warned)
		then diag_line(get_error_message 35036 [name])
		else diag_line(get_error_message 35035 [name]))
	else ();
	not(!warned))
end);
end;
=TEX
Now use this two-way function to give the interface functions:
=SML
fun Ûsummarize_td_resultsÝ () : unit = (
	td_results true;
	()
);
fun Ûtheory_check_successÝ () : bool = (
	case (!req_flag) of
	Declare => true
	| Check => td_results false
);
=TEX
\subsection{Require Functions}
=SML
fun Ûreq_nameÝ (nm : string) (oparent : string OPT) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => ()
		| (Value name) => fail "req_name" 35020 [fn () => name];
in
	case (!req_flag) of
	Declare => (case oparent of
=TEX
No parents - this means the name should be ``min'', or 
at least already exists.
=SML
		Nil => (open_theory nm
			handle complaint =>
			divert complaint "open_theory" "req_name" 35030 [fn () => nm];
			theory_design := {
			name = Value nm, language = olanguage, 
			parents = [], consts = consts, 
			types = types, axioms = axioms,
			defns = defns,  
			thms = thms, fixity = fixity, 
			terminators = terminators, aliases = aliases,
			type_abbrevs = type_abbrevs})
=TEX
Some parents, the normal mode:
=SML
		| Value parent => (((open_theory parent;
			new_theory nm)
			handle complaint =>
			list_divert complaint "req_name"[
				("open_theory", 35018, [fn () => parent]),
				("new_theory", 35019, [fn () => nm])]);
			theory_design := {
			name = Value nm, language = olanguage, 
			parents = [parent], consts = consts, 
			types = types, axioms = axioms,
			defns = defns,  
			thms = thms, fixity = fixity, 
			terminators = terminators, aliases = aliases,
			type_abbrevs = type_abbrevs})
	)
=TEX
Now when $req\_flag$ is $Check$.
=SML
	| Check => (case oparent of
=TEX
No parents - this means the name should be ``min'', or 
at least already exists.
=SML
		Nil => (open_theory nm
			handle complaint =>
			divert complaint "open_theory" "req_name" 35030 [fn () => nm];
			theory_design := {
			name = Value nm, language = olanguage, 
			parents = [], consts = consts, 
			types = types, axioms = axioms,
			defns = defns,  
			thms = thms, fixity = fixity, 
			terminators = terminators, aliases = aliases,
			type_abbrevs = type_abbrevs})
=TEX
Some parents, the normal mode:
=SML
		| Value parent => ((open_theory nm
			handle complaint =>
			divert complaint "open_theory" "req_name" 35030 [fn () => nm]);
			theory_design := {
			name = Value nm, language = olanguage, 
			parents = [parent], consts = consts, 
			types = types, axioms = axioms,
			defns = defns,  
			thms = thms, fixity = fixity, 
			terminators = terminators, aliases = aliases,
			type_abbrevs = type_abbrevs})
	)
end
);
=TEX
=SML
fun Ûreq_languageÝ (lang : string) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_language" 35001 []
		| (Value _) => ();
	val side_effect = case olanguage of
		(Value lang) => fail "req_language" 35037 [fn () => lang]
		| Nil => ();
	val side_effect = case (!req_flag) of
		Check => (set_current_language lang
		) | Declare => ();
in
	theory_design := {
		name = oname, language = Value lang, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun Ûreq_parentÝ (parent : string) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_parent" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (new_parent parent
			handle complaint =>
			divert complaint "new_parent" "req_parent" 35021 [fn () => parent]
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = (parent :: parents), consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun Ûreq_constÝ ((nm,ty) : string * TYPE) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_const" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => ((new_const (nm,ty);())
			handle complaint =>
			divert complaint "new_const" "req_const" 35022 [fn () => nm]
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = ((nm, ty) :: consts), 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun Ûreq_typeÝ ((nm,ar) : string * int) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_type" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => ((new_type (nm,ar);())
			handle complaint =>
			divert complaint "new_type" "req_type" 35038 [fn () => nm]
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = ((nm,ar) :: types), axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
local
fun Ûlreq_axiomÝ ((nm,seq) : string * SEQ) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst axioms)
			then fail "req_axiom" 35023 [fn () => nm]
			else ()
		) | Check => ();
	val side_effect = case oname of
		Nil => fail "req_axiom" 35001 []
		| (Value _) => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = ((nm,seq) :: axioms),
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
in
fun Ûreq_axiomÝ (([],seq) : string list * SEQ) : unit = (
	fail "req_axiom" 35039 []
) | req_axiom (nml,seq) = (
	map (fn x => lreq_axiom (x, seq)) nml;
	()
);
end;
=TEX
=SML
local
fun Ûlreq_defnÝ ((nm,seq) : string * SEQ) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_defn" 35001 []
		| (Value _) => ();
	val frees = frees(snd seq) @ flat (map frees(fst seq));
	val side_effect = if is_nil frees
		then ()
		else term_fail "req_defn" 35040 frees;
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst defns)
			then fail "req_defn" 35024 [fn () => nm]
			else ()
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = ((nm,seq) :: defns),  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
in
fun Ûreq_defnÝ (([],seq) : string list * SEQ) : unit = (
	fail "req_defn" 35039 []
) | req_defn (nml,seq) = (
	map (fn x => lreq_defn (x, seq)) nml;
	()
);
end;
=TEX
=SML
fun Ûreq_thmÝ ((nm,seq) : string * SEQ) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_thm" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst thms)
			then fail "req_thm" 35025 [fn () => nm]
			else ()
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = ((nm,seq)::thms), fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun Ûlist_req_thmÝ (([],seq) : string list * SEQ) : unit = (
	fail "list_req_thm" 35039 []
) | list_req_thm (nml,seq) = (
	map (fn x => req_thm (x, seq)) nml;
	()
);
=TEX
=SML
fun Ûreq_binderÝ (nm : string) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_binder" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst fixity)
			then fail "req_binder" 35027 [fn () => nm]
			else (declare_binder nm
				handle complaint =>
				pass_on complaint "declare_binder" "req_binder")
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = ((nm, Binder) :: fixity), 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun Ûreq_infixÝ ((prec,nm) : int * string) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_infix" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst fixity)
			then fail "req_infix" 35027 [fn () => nm]
			else (declare_infix (prec,nm)
				handle complaint =>
				pass_on complaint "declare_infix" "req_infix")
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = ((nm, Infix prec) :: fixity), 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun Ûreq_prefixÝ ((prec,nm) : int * string) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_prefix" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst fixity)
			then fail "req_prefix" 35027 [fn () => nm]
			else (declare_prefix (prec,nm)
				handle complaint =>
				pass_on complaint "declare_prefix" "req_prefix")
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = ((nm, Prefix prec) :: fixity), 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun Ûreq_postfixÝ ((prec,nm) : int * string) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_postfix" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst fixity)
			then fail "req_postfix" 35027 [fn () => nm]
			else (declare_postfix (prec,nm)
				handle complaint =>
				pass_on complaint "declare_postfix" "req_postfix")
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = ((nm, Postfix prec) :: fixity), 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun Ûreq_nonfixÝ (nm : string) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_nonfix" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst fixity)
			then fail "req_nonfix" 35027 [fn () => nm]
			else (declare_nonfix nm
				handle complaint =>
				pass_on complaint "declare_nofix" "req_nonfix")
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = ((nm, Nonfix) :: fixity), 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun Ûreq_terminatorÝ (nm : string) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_terminator" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem terminators
			then fail "req_terminator" 35028 [fn () => nm]
			else (declare_terminator nm
				handle complaint =>
				pass_on complaint "declare_terminator" "req_terminator")
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = (nm :: terminators), aliases = aliases,
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun Ûreq_aliasÝ ((nm,tm) : string * TERM) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_alias" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map fst aliases)
			then fail "req_alias" 35026 [fn () => nm]
			else (declare_alias (nm,tm)
				handle complaint =>
				pass_on complaint "declare_alias" "req_alias")
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = ((nm,tm)::aliases),
		type_abbrevs = type_abbrevs}
end);
=TEX
=SML
fun Ûreq_type_abbrevÝ ((nm,nml,ty) : string * string list * TYPE) : unit = (
let	val {name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = type_abbrevs} = !theory_design;
	val side_effect = case oname of
		Nil => fail "req_type_abbrev" 35001 []
		| (Value _) => ();
	val side_effect = case (!req_flag) of
		Declare => (if nm mem (map (fn (x,_,_) => x) type_abbrevs)
			then fail "req_type_abbrev" 35029 [fn () => nm]
			else ((declare_type_abbrev (nm, nml, ty);())
				handle complaint =>
				pass_on complaint "declare_type_abbrev" "req_type_abbrev")
		) | Check => ();
in
	theory_design := {
		name = oname, language = olanguage, 
		parents = parents, consts = consts, 
		types = types, axioms = axioms,
		defns = defns,  
		thms = thms, fixity = fixity, 
		terminators = terminators, aliases = aliases,
		type_abbrevs = ((nm,nml,ty)::type_abbrevs)}
end);
=TEX
\section{END OF THE STRUCTURE}
=SML
end; (* of structure TheoryDesignSupport *)
open TheoryDesignSupport;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN
Statistics:

open Sort;
fun comp_stats (s1,n1) (s2,n2) = (
	if n1 = n2
	then string_order s1 s2
	else (n1 - n2)
);

sort comp_stats (get_stats ());


