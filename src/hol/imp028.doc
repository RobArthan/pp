=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation of Tactics II}
\TPPref{DS/FMU/IED/IMP028}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{91/03/11 %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D. Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
first group of tactics and tacticals in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.4 (2 July 1991)]
First draft version.
\item [Issue \SCCSversion (\FormatDate{$Date$%
})]
Fixed $IF\_T$.
\end{description}
\subsection{Changes forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for material
whose detailed design is given in in \cite{DS/FMU/IED/DTD028}.
\subsection{Introduction}
\subsubsection{Purpose and Background}

\subsubsection{Dependencies}

\subsubsection{Deficiencies}
\section{PREAMBLE}
=SML
structure ‚Tactics2· : Tactics2 = struct
=TEX
\section{UTILITIES}
=TEX
=IGN
fun show (th : THM) = (diag_line(PolyML.makestring th); th);
fun show_goal (gl : GOAL) = (diag_line(PolyML.makestring gl); gl);
=TEX
\section{TACTICALS FOR THE PREDICATE CALCULUS}
\subsection{Concerning $F$}
=SML
fun  ‚C_CONTR_T· (thmtac : THM -> TACTIC) : TACTIC = (fn gl as (asms, conc) =>
	let	val å_conc = mk_å conc;
		val (sgs, pf) =  (thmtac (asm_rule å_conc)) (asms, mk_f);
		fun rule thm = (
			if å_conc term_mem (hyps thm)
			then c_contr_rule conc thm
			else contr_rule å_conc thm
		);
	in	(sgs, rule o pf)
	end
);
=TEX
\subsection{Concerning Negation}
=TEX
=SML
fun  ‚å_T2· (t1 : TERM)
	(thmtac1 : THM -> TACTIC) (thmtac2 : THM -> TACTIC)
		: TACTIC = (fn gl as (asms, conc) =>
	let	val t2 = (dest_å conc)
			handle Fail _ => fail "å_T2" 28023 [];
		val å_t1 = (mk_å t1)
			handle Fail _ => term_fail "å_T2" 28022 [t1];
		val (sgs1, pf1) = (thmtac1 (asm_rule t2)) (asms, t1);
		val (sgs2, pf2) = (thmtac2 (asm_rule t2)) (asms, å_t1);
		fun rule [thm1, thm2] = å_intro t2 thm1 thm2
		|   rule _ = bad_proof "å_T2";
	in	(sgs1 @ sgs2, rule o mapshape[(pf1, length sgs1), (pf2, length sgs2)])
	end	
);
=TEX
=SML
fun  ‚å_T· (t1 : TERM) (thmtac : THM -> TACTIC) : TACTIC = (fn thm =>
	(å_T2 t1 thmtac thmtac thm)
	handle ex => pass_on ex "å_T2" "å_T"
);
=TEX
\subsection{Concerning Ä}
=SML
fun ‚Ä_THEN2· (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: THM -> TACTIC = (fn thm => 
	let	val thm1 = Ä_left_elim thm;
		val thm2 = Ä_right_elim thm;
	in	ttac1 thm1 THEN ttac2 thm2
	end
	handle ex => divert ex "Ä_left_elim" "Ä_THEN2" 28032 []
);
=TEX
=SML
fun ‚Ä_THEN· (ttac : THM -> TACTIC) : THM -> TACTIC = (fn thm => 
	(Ä_THEN2 ttac ttac thm)
	handle ex => pass_on ex "Ä_THEN2" "Ä_THEN"
);
=TEX
\subsection{Concerning Å}
=TEX
$Å\_LEFT\_T$ and $Å\_RIGHT\_T$ are deferred until we have support
to do them via $ä\_T$.
=SML
fun ‚Å_THEN2· (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: THM -> TACTIC = (fn thm => 
	let	val (t1, t2) = dest_Å(concl thm);
	in	(fn (asms, conc) =>
			let	val (sgs1, pf1) = ttac1 (asm_rule t1) (asms, conc);
				val (sgs2, pf2) = ttac2 (asm_rule t2) (asms, conc);
			in	(sgs1 @ sgs2,
				(fn thl =>
					let	val len = length sgs1;
					in	Å_elim thm (pf1(thl to (len - 1))) (pf2(thl from len))
					end
				))
			end)
	end
	handle ex => divert ex "dest_Å" "Å_THEN2" 28042 []
);
=TEX
=SML
fun ‚Å_THEN· (ttac : THM -> TACTIC) : THM -> TACTIC = Å_THEN2 ttac ttac;
=TEX
=SML
=TEX
=SML
fun ‚CASES_T2· (t1 : TERM) (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
					: TACTIC = (fn gl as (asms, conc) =>
	let	val (sgs1, pf1) = ttac1 (asm_rule t1) (asms, conc);
		val (sgs2, pf2) = ttac2 (asm_rule (mk_å t1)) (asms, conc);
	in	(sgs1 @ sgs2,
		(fn thl =>
			let	val len = length sgs1;
			in	asm_elim t1 (pf1(thl to (len - 1))) (pf2(thl from len))
			end
			))
	end
	handle ex => divert ex "asm_rule" "CASES_T2" 28024 []
);
=TEX
=SML
fun ‚CASES_T· (t1 : TERM) (ttac : THM -> TACTIC) : TACTIC = (fn gl =>
	((CASES_T2 t1 ttac ttac) gl)
	handle ex => pass_on ex "CASES_T2" "CASES_T"
);
=TEX
=IGN
fun ‚asm_cases_tac· (t1 : TERM) : TACTIC = (fn gl as (asms, conc) =>
	([(t1 :: asms, conc), (mk_å t1 :: asms, conc)],
	  fn [th1, th2] => asm_elim t1 th1 th2
	 | _ => bad_proof "asm_cases_tac")
	handle ex => divert ex "mk_å" "asm_cases_tac" 28002 []
);
=TEX
\subsection{Concerning ä}
=SML
fun ä_T (ttac : THM -> TACTIC) : TACTIC = (fn (asms, conc) =>
	let	val (t1, t2) = dest_ä conc;
		val (sgs, pf) = ttac (asm_rule t1) (asms, t2);
	in	(sgs, ä_intro t1 o pf)
	end
	handle ex => divert ex "dest_ä" "ä_T" 28051 []
);
=TEX
\subsection{Concerning Ç}
=SML
fun ‚Ç_THEN2· (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: THM -> TACTIC = (fn thm => 
	let	val (thm1, thm2) = Ç_elim thm;
	in	ttac1 thm1 THEN ttac2 thm2
	end
	handle ex => divert ex "Ç_elim" "Ä_THEN2" 28062 []
);
=TEX
=SML
fun ‚Ç_THEN· (ttac : THM -> TACTIC) : THM -> TACTIC = (fn thm => 
	(Ç_THEN2 ttac ttac thm)
	handle ex => pass_on ex "Ç_THEN2" "Ç_THEN"
);
=TEX
=SML
fun ‚Ç_T2· (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: TACTIC = (fn (asms, conc) => 
	let	val (t1, t2) = dest_Ç conc;
		val (sgs1, pf1) = ttac1 (asm_rule t1) (asms, t2);
		val (sgs2, pf2) = ttac2 (asm_rule t2) (asms, t1);
		fun rule [thm1, thm2] = Ç_intro (ä_intro t1 thm1) (ä_intro t2 thm2)
		|   rule _ = bad_proof "Ç_T2";
	in	(sgs1 @ sgs2, rule o mapshape[(pf1, length sgs1), (pf2, length sgs2)])
	end
	handle ex => divert ex "dest_Ç" "Ç_T2" 28061 []
);
=TEX
=SML
fun  ‚Ç_T· (ttac : THM -> TACTIC) : TACTIC = (fn thm =>
	(Ç_T2 ttac ttac thm)
	handle ex => pass_on ex "Ç_T2" "Ç_T"
);
=TEX
\subsection{Concerning $if \ldots then \ldots else \ldots$}
=SML
fun ‚IF_THEN2· (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: THM -> TACTIC = (fn thm => 
	let	val thm1 = if_then_elim thm;
		val thm2 = if_else_elim thm;
	in	ttac1 thm1 THEN ttac2 thm2
	end
	handle ex => divert ex "if_left_elim" "IF_THEN2" 28072 []
);
=TEX
=SML
fun ‚IF_THEN· (ttac : THM -> TACTIC) : THM -> TACTIC = (fn thm => 
	(IF_THEN2 ttac ttac thm)
	handle ex => pass_on ex "IF_THEN2" "IF_THEN"
);
=TEX
=SML
fun ‚IF_T2· (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC) : TACTIC = (fn (asms, conc) =>
	let	val (a, tt, et) = dest_if conc;
		val (tsgs, tpf) = ttac1 (asm_rule a) (asms, tt);
		val (esgs, epf) = ttac2 (asm_rule (mk_å a)) (asms, et);
		fun rule [thm1, thm2] = if_intro a thm1 thm2
		|   rule _ = bad_proof "åIF_T2";

	in	(tsgs @ esgs, rule o mapshape[(tpf, length tsgs), (epf, length esgs)])
	end handle ex => divert ex "dest_if" "IF_T2" 28071 []
);
=TEX
=SML
fun  ‚IF_T· (ttac : THM -> TACTIC) : TACTIC = (fn thm =>
	(IF_T2 ttac ttac thm)
	handle ex => pass_on ex "IF_T2" "IF_T"
);
=TEX
\subsection{Concerning Ñ}
=SML
fun ‚SIMPLE_Ñ_THEN· (ttac : THM -> TACTIC) = (fn thm =>
	let	val (x, b) = simple_dest_Ñ(concl thm);
	in	(fn (asms, conc) =>
			let	val x' = variant (flat(map frees
					(conc :: concl thm :: hyps thm @ asms))) x;
				val (sgs, pf) = ttac (asm_rule (var_subst[(x', x)] b)) (asms, conc);
			in	(sgs, (simple_Ñ_elim x' thm) o pf)
			end)
	end
	handle ex => divert ex "simple_dest_Ñ" "SIMPLE_Ñ_THEN" 28093 []
);
=TEX
\subsection{Concerning Ñ∞}
=SML
fun ‚SIMPLE_Ñ%down%1_THEN· (ttac : THM -> TACTIC) = (fn thm =>
	(SIMPLE_Ñ_THEN ttac (simple_Ñ%down%1_elim thm))
	handle ex => divert ex "simple_Ñ%down%1_elim" "SIMPLE_Ñ%down%1_THEN" 28102 []
);
=TEX
\section{TACTICS FOR THE PREDICATE CALCULUS 1}
We now give the tactics which do not involve $strip\_asm\_tac$. These
will enable us to prove various simple theorems required to set up 
the stripping tacticals.
=TEX
\subsection{Concerning $T$}
=SML
val ‚t_tac· : TACTIC = accept_tac t_thm;
=TEX
=SML
val ‚Ç_t_tac· : TACTIC = (fn (asms, conc) => 
	let	val (lhs, rhs) = dest_eq conc;
	in	if rhs = mk_t
		then	([(asms, lhs)],
			 fn [th] => Ç_t_intro th | _ => bad_proof "Ç_t_tac")
		else if lhs = mk_t
		then	([(asms, rhs)],
			 fn [th] => eq_sym_rule(Ç_t_intro th) | _ => bad_proof "Ç_t_tac")
		else fail "Ç_t_tac" 28012 []
	end	handle Fail _ => fail "Ç_t_tac" 28012 []
);
=TEX
\subsection{Concerning $F$}
=SML
val ‚contr_tac· : TACTIC = (fn (asms, conc) => 
	([(asms, mk_f)],
	 fn [th] => contr_rule conc th | _ => bad_proof "contr_tac")
);
=TEX
=SML
fun ‚f_thm_tac· (thm	 : THM) : TACTIC = (fn gl as (_, conc) => 
	let	val thm1 = contr_rule conc thm
	in	accept_tac thm1 gl
	end
	handle	ex => divert ex "contr_rule" "f_thm_tac" 28021 []
);
=TEX
\subsection{Concerning Negation}
=TEX
=SML
fun  ‚å_elim_tac· (tm : TERM) : TACTIC = (
	if type_of tm <> BOOL
	then fail "å_elim_tac" 28024 []
	else	(fn (asms, conc) =>
			([(asms, tm), (asms, mk_å tm)],
			 fn [th1, th2] => å_elim conc th1 th2
			 |   _ => bad_proof "å_elim_tac" )
		)
);
=TEX
\subsection{Concerning Ä}
=SML
val ‚Ä_tac· : TACTIC = (fn (asms, conc) =>
	let	val (t1, t2) = dest_Ä conc
	in	([(asms, t1), (asms, t2)],
			 fn [th1, th2] => Ä_intro th1 th2
			 |   _ => bad_proof "Ä_tac" )
	end handle ex => divert ex "dest_Ä" "Ä_tac" 28031 []
);
=TEX
\subsection{Concerning Å}
=SML
val  ‚Å_left_tac· : TACTIC = (fn (asms, conc) =>
	let	val (a, b) = dest_Å conc
	in	([(asms, a)],
			 fn [th] => Å_right_intro b th
			 |   _ => bad_proof "Å_left_tac" )
	end handle ex => divert ex "dest_Å" "Å_left_tac" 28041 []
);
=TEX
=SML
val  ‚Å_right_tac· : TACTIC = (fn (asms, conc) =>
	let	val (a, b) = dest_Å conc
	in	([(asms, b)],
			 fn [th] => Å_left_intro a th
			 |   _ => bad_proof "Å_right_tac" )
	end handle ex => divert ex "dest_Å" "Å_right_tac" 28041 []
);
=TEX
\subsection{Concerning ä}
=SML
fun ‚undisch_tac· (t1 : TERM) : TACTIC = (fn (asms, conc) =>
	if t1 term_mem asms
	then ([(asms term_less t1, mk_ä(t1, conc))],
		(fn [thm] => undisch_rule thm | _ => bad_proof "undisch_tac"))
	else  term_fail "undisch_tac" 28052 [t1]
);
=TEX
When we undischarge more than one assumption we need to be careful not
to fail if the list of assumptions we are discharging contains repeats
which is allowed with the convention that the repeats are ignored.
=SML
val ‚list_undisch_tac· : TERM list ->  TACTIC = MAP_EVERY (TRY_T o undisch_tac) o rev;
=TEX
=SML
val ‚all_undisch_tac· :  TACTIC = GET_ASMS_T (MAP_EVERY((TRY_T o undisch_tac) o concl));
=TEX
\subsection{Concerning É}
=SML
val ‚simple_É_tac· : TACTIC = (fn (asms, conc) =>
	let	val (x, b) = simple_dest_É conc;
		val x' = variant (flat(map frees(conc::asms))) x;
	in
		([(asms, var_subst[(x', x)] b)],
		(fn [thm] => simple_É_intro x' thm | _ => bad_proof "simple_É_tac"))
	end handle ex => divert ex "dest_É" "simple_É_tac" 28081 []
);
=TEX
\subsection{Concerning Ñ}
=TEX
=SML
fun ‚simple_Ñ_tac· (tm : TERM) : TACTIC = (fn (asms, conc) =>
	let	val (x, b) = simple_dest_Ñ conc;
	in
		([(asms, var_subst[(tm, x)] b)],
		(fn [thm] => simple_Ñ_intro conc thm | _ => bad_proof "simple_Ñ_tac"))
	end
	handle ex =>
	case area_of ex of
		"var_subst" => term_fail "simple_Ñ_tac" 28092 [tm]
	|	"simple_dest_Ñ conc" => fail "simple_Ñ_tac" 28091 []
	|	_ => raise ex
);
=TEX
\subsection{Concerning Ñ}
=SML
fun ‚simple_Ñ%down%1_tac· (tm : TERM) : TACTIC = (fn (asms, conc) =>
	let	val (x, b) = simple_dest_Ñ%down%1 conc;
		val u = mk_É(x, mk_ä(b, mk_eq(x, tm)))
	in
		([(asms, var_subst[(tm, x)] b), (asms, u)],
		(fn [th1, th2] => simple_Ñ%down%1_intro th1 th2
		| _ => bad_proof "simple_Ñ%down%1_tac"))
	end
	handle ex =>
	case area_of ex of
		"simple_dest_Ñ%down%1" => fail "simple_Ñ%down%1_tac" 28101 []
	|	"mk_eq conc" => term_fail "simple_Ñ%down%1_tac" 28092 [tm]
	|	_ => raise ex
);
=TEX
\section{STRIPPING THEOREMS AND GOALS}
=TEX
=SML
fun ‚check_asm_tac· (thm : THM) : TACTIC = (fn gl as (asms, conc) =>
	let	val t = concl thm;
	in	if aconv t conc
		then accept_tac thm
		else if is_t t
		then id_tac
		else if is_f t
		then f_thm_tac thm
		else if is_å t
		then	let	val t' = dest_å t;
				fun aux (asm :: more) = (
					if aconv t asm
					then id_tac
					else if aconv asm t'
					then accept_tac (å_elim conc (asm_rule asm) thm)
					else if aconv asm conc
					then accept_tac (asm_rule asm)
					else aux more
				) | aux [] = asm_tac thm;
			in	aux asms
			end
		else	let	fun aux (asm :: more) = (
					if aconv t asm
					then id_tac
					else if is_å asm andalso aconv (dest_å asm) t
					then accept_tac (å_elim conc thm (asm_rule asm))
					else if aconv asm conc
					then accept_tac (asm_rule asm)
					else aux more
					) | aux [] = asm_tac thm;
			in	aux asms
			end
	end	gl
);
=TEX
=SML
val ‚goal_in_asms_tac· : TACTIC = (fn gl as (asms, conc) =>
	if conc term_mem asms
	then accept_tac (asm_rule conc) gl
	else fail "goal_in_asms_tac" 28002 []
);
=TEX
We start of with theorem strippers and  goal strippers which understand a
subset of the desired final list. We then use these to construct 
$strip\_tac$ and then use it to prove results needed to supply
the missing strippers. There is currently no external access to
$strip\_thm\_thens$ and $strip\_goal\_ts$.
=SML
val ‚strip_thm_thens· : THM_TACTICAL list ref =	ref [Ä_THEN, Å_THEN, SIMPLE_Ñ_THEN];
=TEX
=SML
val strip_goal_ts : (THM_TACTIC -> TACTIC) list ref =
	ref[ 	fn _ => simple_É_tac,
		fn _ => Ä_tac,
		ä_T,
		Ç_T,
		fn _ => t_tac,
		fn _ => goal_in_asms_tac];
=TEX
The user control is via the access functions to the following data.
=SML
val ‚strip_thm_convs· : (string * CONV) list ref = ref [];
val ‚strip_goal_convs· : (string * CONV) list ref = ref [];
=TEX
=SML
fun ‚get_strip_thm_convs· (() : unit) : (string * CONV) list = (
	!strip_thm_convs
);
fun ‚get_strip_goal_convs· (() : unit) : (string * CONV) list = (
	!strip_goal_convs
);
=TEX
=SML
fun ‚set_strip_thm_convs· (sconvs : (string * CONV) list) : unit = (
	strip_thm_convs := sconvs
);
fun ‚set_strip_goal_convs· (sconvs : (string * CONV) list) : unit = (
	strip_goal_convs := sconvs
);
=TEX
=SML
val ‚STRIP_THM_THEN· : THM_TACTICAL = (fn thmtac =>
	(		FIRST_TTCL(!strip_thm_thens)
	ORELSE_TTCL	FIRST_TTCL (map(CONV_THEN o snd)(!strip_thm_convs) )) thmtac
);
=TEX
=SML
fun ‚STRIP_GOAL_T· (ttac : THM_TACTIC) : TACTIC = (fn gl =>
	(	FIRST(map (fn t => t ttac) (!strip_goal_ts))
	ORELSE	FIRST(map (conv_tac o snd)(!strip_goal_convs))) gl
);
=TEX
=SML
val ‚strip_asm_tac· : THM_TACTIC =
			REPEAT_TTCL STRIP_THM_THEN check_asm_tac;
=TEX
=SML
val  ‚strip_tac· : TACTIC = STRIP_GOAL_T strip_asm_tac;
=TEX
\subsection{Some Tautologies}
We now have some machinery in place with which we can prove the tautologies
need for the tacticals which support $simple\_strip\_tac$:
=SML
val ‚ä_thm· = tac_proof( ([], ªÉa bé(a ä b) Ç (åa Å b)º),
	REPEAT strip_tac
	THEN CASES_T ªa:BOOLº asm_tac THEN_LIST
	[Å_right_tac THEN all_undisch_tac THEN REPEAT strip_tac,
	 Å_left_tac THEN all_undisch_tac THEN REPEAT strip_tac]);
=TEX
=SML
val ‚å_å_thm· = tac_proof( ([], ªÉaéå åa Ç aº),
		REPEAT strip_tac THEN_LIST
	[accept_tac (å_å_elim (asm_rule ªååaº)),
	 accept_tac (å_å_intro (asm_rule ªa:BOOLº))]);
=TEX
=SML
val ‚å_Å_thm· = tac_proof( ([], ªÉa béå (a Å b) Ç (åa Ä åb)º),
	conv_tac(MAP_C (simple_eq_match_conv å_thm)) THEN
	REPEAT strip_tac THEN_LIST 
	[LEMMA_T ªa Å bº(accept_tac o ä_mp_rule (asm_rule ªa Å b ä Fº)) THEN 
		Å_left_tac THEN accept_tac(asm_rule ªa:BOOLº), 
	LEMMA_T ªa Å bº(accept_tac o ä_mp_rule (asm_rule ªa Å b ä Fº)) THEN
		Å_right_tac THEN accept_tac(asm_rule ªb:BOOLº),
	accept_tac(ä_mp_rule (asm_rule ªa ä Fº) (asm_rule ªa:BOOLº)),
	accept_tac(ä_mp_rule (asm_rule ªb ä Fº) (asm_rule ªb:BOOLº))] );
=TEX
=SML
val ‚Å_å_thm· = tac_proof( ([], ªÉa bé(a Å åb) Ç (b ä a)º),
	REPEAT strip_tac THEN
	CASES_T ªa:BOOLº asm_tac THEN_LIST
	[Å_left_tac THEN all_undisch_tac THEN REPEAT strip_tac,
	Å_right_tac THEN accept_tac(modus_tollens_rule(asm_ruleªb ä aº)(asm_ruleªåaº))]);
=TEX
=SML
val ‚å_Ä_thm· = ( (* Ö å(a Ä b) Ç (åa Å åb) *)
let	val thm1 = tac_proof( ([], ªå(a Ä b) Ç (a ä åb)º),
	conv_tac(MAP_C (simple_eq_match_conv å_thm))
	THEN REPEAT strip_tac
	THEN_LIST
	[CASES_Tªa:BOOLº asm_tac
		THEN LEMMA_T ªa Ä bº
		(fn th1 => accept_tac(ä_mp_rule(asm_ruleªa Ä b ä Fº)(asm_ruleªa Ä bº)))
		THEN REPEAT strip_tac,
		accept_tac(ä_mp_rule(ä_mp_rule(asm_ruleªa ä b ä Fº)
					(asm_ruleªa:BOOLº))(asm_ruleªb:BOOLº))]);
		val thm2 = tac_proof( ([], ª(a ä åb) Ç (åa Å åb)º),
	conv_tac(MAP_C(FIRST_C(map simple_eq_match_conv
	[ä_thm, å_å_thm, Ç_t_intro(refl_convªxº)])))
	THEN t_tac);
in	simple_list_É_intro[ªa:BOOLº, ªb:BOOLº](eq_trans_rule thm1 thm2)
end);
=TEX
=SML
val ‚å_ä_thm· = tac_proof( ([], ªÉa béå(a ä b) Ç (a Ä åb)º),
	conv_tac(TOP_MAP_C(FIRST_C (map simple_eq_match_conv
		[ä_thm, å_Å_thm, å_å_thm] )))
		THEN REPEAT strip_tac);
=TEX
=SML
=TEX
=SML
val ‚Ç_thm· = ( (* Ö (a Ç b) Ç (a ä b) Ä (b ä a) *)
let
	val thm1 = asm_rule ª(a ä b) Ä (b ä a)º; 
	val thm2 = Ç_intro(Ä_left_elim thm1) (Ä_right_elim thm1);
	val (thm3, thm4) = Ç_elim(asm_ruleªa Ç bº);
	val thm5 = Ä_intro thm3 thm4;
in
	simple_list_É_intro[ªa:BOOLº, ªb:BOOLº](Ç_intro(all_ä_intro thm5)(all_ä_intro thm2))
end);
=TEX
=SML
val ‚å_Ç_thm· = (* Ö É a b é å (a Ç b) Ç a Ä å b Å b Ä å a  *)
		simple_list_É_intro[ªa:BOOLº, ªb:BOOLº]
		((RAND_C(simple_eq_match_conv Ç_thm)
		THEN_C (simple_eq_match_conv å_Ä_thm)
		THEN_C (MAP_C(simple_eq_match_conv å_ä_thm)))
		ªå(a Ç b)º);
=TEX
=SML
val ‚å_f_thm· = tac_proof( ([], ªåF Ç Tº),
	Ç_t_tac THEN conv_tac (simple_eq_match_conv å_thm) THEN strip_tac);
=TEX
\subsection{Additional Conversions Tactics and Tacticals}
\subsubsection{Concerning Ñ∞}
=SML
val ‚simple_Ñ%down%1_conv· : CONV = (fn tm =>
	let	val (x, b) = simple_dest_Ñ%down%1 tm
		val s1 = ä_intro tm (simple_Ñ%down%1_elim (asm_rule tm));
		val y = variant (x :: frees b) x;
		val conj = mk_Ä(b, mk_É(y, mk_ä(var_subst[(y, x)]b, mk_eq(y, x))));
		val exi = mk_Ñ(x, conj)
		val s2 = asm_rule conj;
		val s3 = simple_Ñ%down%1_intro (Ä_left_elim s2) (Ä_right_elim s2)
		val s4 = simple_Ñ_elim conj (asm_rule exi) s3
		val s5 = ä_intro exi s4;
	in	Ç_intro s1 s5
	end handle ex => pass_on ex "simple_dest_Ñ%down%1" "simple_Ñ%down%1_conv"
);
=SML
val ‚simple_å_Ñ%down%1_conv· : CONV = (fn tm =>
	((RAND_C simple_Ñ%down%1_conv THEN_C simple_å_Ñ_conv) tm)
	handle  Fail _ => fail "simple_å_Ñ%down%1_conv" 28091 []
);
=TEX
\subsubsection{Concerning å}
=SML
val ‚simple_å_in_conv· : CONV = FIRST_C(
		map simple_eq_match_conv
		[å_å_thm, å_Ä_thm, å_Å_thm, å_ä_thm,
		 å_Ç_thm, å_t_thm, å_f_thm] 
	@	[simple_å_É_conv, simple_å_Ñ_conv, simple_å_Ñ%down%1_conv]);
=TEX
=SML
val ‚SIMPLE_å_IN_THEN· : THM_TACTICAL = (fn ttac => fn thm =>
	(ttac(Ç_mp_rule(simple_å_in_conv(concl thm))thm))
	handle Fail _ => fail "simple_å_in_tac" 28026 []
);
=TEX
=SML
val ‚simple_å_in_tac· : TACTIC = (fn gl => 
	((conv_tac simple_å_in_conv) gl)
	handle Fail _ => fail "simple_å_in_tac" 28025 []
);
=TEX
\subsubsection{Concerning ä}
=SML
val ‚ä_THEN· : THM_TACTICAL = (fn ttac => fn thm =>
	let	val (t1, t2) = dest_ä (concl thm)
	in	ttac(Ç_mp_rule(simple_list_É_elim[t1, t2]ä_thm)thm)
	end	handle ex => pass_on ex "dest_ä" "ä_THEN"
);
=TEX
\subsubsection{Concerning Å}
=SML
local
val ‚Å_conv· = FIRST_C(map simple_eq_match_conv
	[Å_å_thm,
	simple_list_É_intro[ªa:BOOLº, ªb:BOOLº](eq_sym_rule(simple_all_É_elim ä_thm))
,
	conv_rule(MAP_C(simple_eq_match_conv å_å_thm))
	(simple_list_É_intro[ªa:BOOLº, ªb:BOOLº]
			(eq_sym_rule(simple_list_É_elim[ªåaº, ªb:BOOLº]ä_thm)))]);
in
val ‚Å_tac· = conv_tac(Å_conv);
end;
=TEX
\section{Remaining Stripping Tacticals}
=SML
val ‚basic_strip_thm_thens· : THM_TACTICAL list =
	[	Ä_THEN,
		ä_THEN,
		Å_THEN,
		SIMPLE_å_IN_THEN,
		Ç_THEN,
		SIMPLE_Ñ_THEN,
		SIMPLE_Ñ%down%1_THEN,
		IF_THEN];
=TEX
=SML
val side_effect = strip_thm_thens := basic_strip_thm_thens;
=TEX
=SML
val ‚basic_strip_goal_ts· : (THM_TACTIC -> TACTIC) list =
	[	fn _ => simple_É_tac,
		fn _ => Ä_tac,
		ä_T,
		Ç_T,
		fn _ => simple_å_in_tac,
		fn _ => Å_tac,
		IF_T,
		fn _ => t_tac,
		fn _ => goal_in_asms_tac];
=TEX
=SML
val side_effect = strip_goal_ts := basic_strip_goal_ts;
=TEX
\section{TAUTOLOGY PROVER}
The tautology prover defends itself against changes in the theorem and goal
strippers by using a private version of $strip\_tac$: 
=SML
local
val ‚taut_å_in_conv· : CONV = FIRST_C(
		map simple_eq_match_conv
		[å_å_thm, å_Ä_thm, å_Å_thm, å_ä_thm,
		 å_Ç_thm, å_t_thm, å_f_thm]);
val ‚TAUT_å_IN_THEN· : THM_TACTICAL = (fn ttac => fn thm =>
	ttac(Ç_mp_rule(taut_å_in_conv(concl thm))thm)
);
val ‚taut_strip_thm_thens· : THM_TACTICAL list =
	[	Ä_THEN,
		ä_THEN,
		Å_THEN,
		TAUT_å_IN_THEN,
		Ç_THEN,
		IF_THEN];
val ‚taut_strip_goal_ts· : (THM_TACTIC -> TACTIC) list =
	[fn _ => Ä_tac,
		ä_T,
		Ç_T,
		fn _ => conv_tac taut_å_in_conv,
		fn _ => Å_tac,
		IF_T,
		fn _ => t_tac,
		fn _ => goal_in_asms_tac];

val ‚taut_strip_tac· : TACTIC = 
	FIRST
	(map(fn t => t(REPEAT_TTCL (FIRST_TTCL taut_strip_thm_thens) check_asm_tac))
		taut_strip_goal_ts);
in
val ‚taut_tac· : TACTIC = (fn gl =>
	case REPEAT taut_strip_tac gl of
		done as ([], _) => done
	|	_ => fail "simple_taut_tac" 28121 []
);
end;
=TEX
\section{TACTICS FOR THE PREDICATE CALCULUS 2}
We now give the remaining tactics.
\subsection{Concerning $F$}
=SML
val ‚c_contr_tac· : TACTIC = C_CONTR_T strip_asm_tac;
=TEX
\subsection{Concerning $å$}
=SML
fun ‚å_tac· (t : TERM) : TACTIC = å_T t strip_asm_tac;
=TEX
\subsection{Concerning Å}
=SML
val ‚Å_comm_thm· : THM = tac_proof(([], ªÉa béa Å b Ç b Å aº), REPEAT strip_tac);
=TEX
=SML
val ‚swap_Å_tac· : TACTIC = (fn gl =>
	((conv_tac(simple_eq_match_conv Å_comm_thm)) gl)
	handle ex => divert ex "simple_eq_match_conv" "swap_Å_tac" 28041 []
);
=TEX
=SML
fun ‚cases_tac· (tm : TERM) : TACTIC = CASES_T tm strip_asm_tac;
=TEX
\subsection{Concerning ä}
=SML
val ‚ä_tac· : TACTIC = ä_T strip_asm_tac;
=TEX
\subsection{Concerning Ç}
=SML
val ‚Ç_tac· : TACTIC = Ç_T strip_asm_tac;
=TEX
\subsection{Concerning $if \ldots then \ldots else \ldots$}
=SML
val ‚if_tac· : TACTIC = IF_T strip_asm_tac;
=TEX
\subsection{$lemma\_tac$}
=SML
fun ‚lemma_tac· (sg : TERM) : TACTIC = LEMMA_T sg strip_asm_tac;
=TEX

=SML
end; (* of structure Tactics2 *)
open Tactics2;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=SML
