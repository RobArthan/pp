=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation of Tactics II}
\TPPref{DS/FMU/IED/IMP028}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D. Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
first group of tactics and tacticals in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.4 (2 July 1991)]
First draft version.
\item [Issue 1.5 (3 July 1991)]
Fixed $IF\_T$.
\item [Issue 1.9 (12th August 1991)]
Update reflecting issue 1.8 design changes.
\item [Issue 1.10 (\FormatDate{91/08/15%
})]
Renamings of functions containing the name atom $simple$,
and renaming of $aconv$.
\item [Issue 1.11 (25th October 1991)]
Re-implementation of stripping material,
and other changes in response to deskcheck ID0029.
\item [Issue 1.12 (29th October 1991)]
Made $eqn\_cxt\_conv$ ignore ``no change'' conversions.
\item [Issue 1.13 (31st October 1991)]
Changes during testing.
\item [Issue 1.15 (18th November 1991)]
Corrected $C\_CONTR\_T$.
\item [Issue 1.16 (18th November 1991)]
Reacting to issue 1.5/6 of \cite{DS/FMU/IED/DTD051}.

\item[Issue 1.17, \FormatDate{92/01/20} ] Updated to use new fonts.

\item [Issue 1.18,1.19 (5th February 1992)]
Modified $strip\_tac$, added $swap\_asm\_concl\_tac$, et al.
\item [Issue 1.20,1.21 (10th,11th February 1992)]
Minor corrections.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for material
whose detailed design is given in in \cite{DS/FMU/IED/DTD028}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the implementation for the 
second group of tactics and tacticals for ICL HOL.
This group is mainly concerned with supplying support for predicate calculus
connectives (including boolean conditionals but not boolean $let$-expressions).

\subsubsection{Dependencies}
Loading this document is dependent on \cite{DS/FMU/IED/IMP009}
and \cite{DS/FMU/IED/IMP051}.
\subsubsection{Deficiencies}
None known.
\section{PREAMBLE}
=SML
structure €Tactics2› : Tactics2 = struct
=TEX
=SML
val €was_theory› = get_current_theory_name ();
val _ = open_theory "misc";
val _ = pop_proof_context() handle _ => ();
val _ = push_proof_context initial_epc;
=TEX
\section{TACTICALS FOR THE PREDICATE CALCULUS}
The following contain only those parts used in implementing
the stripping material.
\subsection{Concerning ±}
=SML
fun €±_THEN2› (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: THM -> TACTIC = (fn thm => 
	let	val thm1 = ±_left_elim thm;
		val thm2 = ±_right_elim thm;
	in	ttac1 thm1 THEN ttac2 thm2
	end
	handle ex => divert ex "±_left_elim" "±_THEN2" 28032 
		[fn () => string_of_thm thm]
);
=TEX
=SML
fun €±_THEN› (ttac : THM -> TACTIC) : THM -> TACTIC = (fn thm => 
	(±_THEN2 ttac ttac thm)
	handle ex => pass_on ex "±_THEN2" "±_THEN"
);
=TEX
\subsection{Concerning ≤}
$≤\_LEFT\_T$ and $≤\_RIGHT\_T$ are deferred until we have support
to do them via $¥\_T$.
=SML
fun €≤_THEN2› (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: THM -> TACTIC = (fn thm => 
	let	val (t1, t2) = dest_≤(concl thm);
	in	(fn (asms, conc) =>
			let	val (sgs1, pf1) = ttac1 (asm_rule t1) (asms, conc);
				val (sgs2, pf2) = ttac2 (asm_rule t2) (asms, conc);
			in	(sgs1 @ sgs2,
				(fn thl =>
					let	val len = length sgs1;
					in	≤_elim thm (pf1(thl to (len - 1))) (pf2(thl from len))
					end
				))
			end)
	end
	handle ex => divert ex "dest_≤" "≤_THEN2" 28042 
		[fn () => string_of_thm thm]
);
=TEX
=SML
fun €≤_THEN› (ttac : THM -> TACTIC) (thm : THM) : TACTIC = (
	≤_THEN2 ttac ttac thm
	handle complaint =>
	pass_on complaint "≤_THEN2" "≤_THEN"
);
=TEX
=SML
=TEX
=SML
fun €CASES_T2› (t1 : TERM) (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
					: TACTIC = (fn gl as (asms, conc) =>
	let	val (sgs1, pf1) = ttac1 (asm_rule t1) (asms, conc);
		val (sgs2, pf2) = ttac2 (asm_rule (mk_≥ t1)) (asms, conc);
	in	(sgs1 @ sgs2,
		(fn thl =>
			let	val len = length sgs1;
			in	asm_elim t1 (pf1(thl to (len - 1))) (pf2(thl from len))
			end
			))
	end
	handle ex => (
		if area_of ex = "asm_rule"
		then term_fail "CASES_T2" 28022 [t1]
		else raise ex
	)
);
=TEX
=SML
fun €CASES_T› (t1 : TERM) (ttac : THM -> TACTIC) : TACTIC = (fn gl =>
	((CASES_T2 t1 ttac ttac) gl)
	handle ex => pass_on ex "CASES_T2" "CASES_T"
);
=TEX
=IGN
fun €asm_cases_tac› (t1 : TERM) : TACTIC = (fn gl as (asms, conc) =>
	([(t1 :: asms, conc), (mk_≥ t1 :: asms, conc)],
	  fn [th1, th2] => asm_elim t1 th1 th2
	 | _ => bad_proof "asm_cases_tac")
	handle ex => divert ex "mk_≥" "asm_cases_tac" 28002 []
);
=TEX
\subsection{Concerning ¥}
=SML
fun €¥_T› (ttac : THM -> TACTIC) : TACTIC = (fn (asms, conc) =>
	let	val (t1, t2) = dest_¥ conc;
		val (sgs, pf) = ttac (asm_rule t1) (asms, t2);
	in	(sgs, ¥_intro t1 o pf)
	end
	handle ex => divert ex "dest_¥" "¥_T" 28051 []
);
=TEX
\subsection{Concerning ∂}
=SML
fun €SIMPLE_∂_THEN› (ttac : THM -> TACTIC) = (fn thm =>
	let	val (x, b) = dest_simple_∂(concl thm);
	in	(fn (asms, conc) =>
			let	val x' = variant (flat(map frees
					(conc :: concl thm :: hyps thm @ asms))) x;
				val (sgs, pf) = ttac (asm_rule (var_subst[(x', x)] b)) (asms, conc);
			in	(sgs, (simple_∂_elim x' thm) o pf)
			end)
	end
	handle ex => divert ex "dest_simple_∂" "SIMPLE_∂_THEN" 28093 
		[fn () => string_of_thm thm]
);
=TEX
\section{TACTICS FOR THE PREDICATE CALCULUS 1}
We now give the tactics which do not involve $strip\_asm\_tac$. These
will enable us to prove various simple theorems required to set up 
the stripping tacticals.
\subsection{Concerning $T$}
=SML
val €t_tac› : TACTIC = (fn gl =>
	accept_tac t_thm gl
	handle complaint =>
	divert complaint "accept_tac" "t_tac" 28011 []
);
=TEX
=SML
val €§_t_tac› : TACTIC = (fn (asms, conc) => 
	let	val (lhs, rhs) = dest_eq conc;
	in	if rhs = mk_t
		then	([(asms, lhs)],
			 fn [th] => §_t_intro th | _ => bad_proof "§_t_tac")
		else if lhs = mk_t
		then	([(asms, rhs)],
			 fn [th] => eq_sym_rule(§_t_intro th) | _ => bad_proof "§_t_tac")
		else fail "§_t_tac" 28012 []
	end	handle Fail _ => fail "§_t_tac" 28012 []
);
=TEX
\subsection{Concerning $F$}
=SML
val €contr_tac› : TACTIC = (fn (asms, conc) => 
	([(asms, mk_f)],
	 fn [th] => contr_rule conc th | _ => bad_proof "contr_tac")
);
=TEX
=SML
fun €f_thm_tac› (thm : THM) : TACTIC = (fn gl as (_, conc) => 
	let	val thm1 = contr_rule conc thm
	in	accept_tac thm1 gl
	end
	handle	ex => divert ex "contr_rule" "f_thm_tac" 28021 
		[fn () => string_of_thm thm]
);
=TEX
\subsection{Concerning ±}
=SML
val €±_tac› : TACTIC = (fn (asms, conc) =>
	let	val (t1, t2) = dest_± conc
	in	([(asms, t1), (asms, t2)],
			 fn [th1, th2] => ±_intro th1 th2
			 |   _ => bad_proof "±_tac" )
	end handle ex => divert ex "dest_±" "±_tac" 28031 []
);
=TEX
\subsection{Concerning ≤}
=SML
val  €≤_left_tac› : TACTIC = (fn (asms, conc) =>
	let	val (a, b) = dest_≤ conc
	in	([(asms, a)],
			 fn [th] => ≤_right_intro b th
			 |   _ => bad_proof "≤_left_tac" )
	end handle ex => divert ex "dest_≤" "≤_left_tac" 28041 []
);
=TEX
=SML
val  €≤_right_tac› : TACTIC = (fn (asms, conc) =>
	let	val (a, b) = dest_≤ conc
	in	([(asms, b)],
			 fn [th] => ≤_left_intro a th
			 |   _ => bad_proof "≤_right_tac" )
	end handle ex => divert ex "dest_≤" "≤_right_tac" 28041 []
);
=TEX
\subsection{Concerning §}
=SML
val €§_thm› = ( (* Ù µ a b ∑ (a § b) § (a ¥ b) ± (b ¥ a) *)
save_thm("§_thm",
let
	val thm1 = asm_rule ¨(a ¥ b) ± (b ¥ a)Æ; 
	val thm2 = §_intro(±_left_elim thm1) (±_right_elim thm1);
	val (thm3, thm4) = §_elim(asm_rule¨a § bÆ);
	val thm5 = ±_intro thm3 thm4;
in
	list_simple_µ_intro[¨a:BOOLÆ, ¨b:BOOLÆ](§_intro(all_¥_intro thm5)(all_¥_intro thm2))
end));
=TEX
\subsection{Concerning ¥}
=SML
fun €undisch_tac› (t1 : TERM) : TACTIC = (fn (asms, conc) =>
	(if t1 term_mem asms
	then ([(asms term_less t1, mk_¥(t1, conc))],
		(fn [thm] => undisch_rule thm | _ => bad_proof "undisch_tac"))
	else  term_fail "undisch_tac" 28052 [t1])
	handle ex => divert ex "mk_¥" "undisch_tac" 28055 []
);
=TEX
When we undischarge more than one assumption we need to be careful not
to fail if the list of assumptions we are discharging contains repeats
which is allowed with the convention that the repeats are ignored.
=SML
local
	fun try_undisch_tac allasms asm : TACTIC = (fn (asms,gl) =>
	undisch_tac asm (asms,gl)
	handle complaint =>
	if asm term_mem allasms andalso type_of asm = BOOL
		andalso type_of gl = BOOL
	then id_tac  (asms,gl)
	else pass_on complaint "undisch_tac" "list_undisch_tac"
	);
	fun try_undisch_tac1 asm : TACTIC = (fn (asms,gl) =>
	undisch_tac asm (asms,gl)
	handle complaint =>
	if type_of asm = BOOL andalso type_of gl = BOOL
	then id_tac  (asms,gl)
	else pass_on complaint "undisch_tac" "all_undisch_tac"
	);
in
fun €list_undisch_tac› (lasms : TERM list):  TACTIC = (fn (asms,gl) =>
	MAP_EVERY (try_undisch_tac asms) (rev lasms) (asms,gl)
);

val €all_undisch_tac› :  TACTIC = (fn (asms,gl) =>
	MAP_EVERY (try_undisch_tac1) asms (asms,gl)
);
end;
=TEX
=SML
fun €ante_tac› (thm : THM) : TACTIC = (fn (asms, conc) =>
	([(asms, mk_¥(concl thm, conc))],
	 fn [th] => ¥_elim th thm | _ => bad_proof "ante_tac")
	handle ex => divert ex "mk_¥" "ante_tac" 28027 []
);
=TEX
\subsection{Concerning µ}
=SML
val €simple_µ_tac› : TACTIC = (fn (asms, conc) =>
	let	val (x, b) = dest_simple_µ conc;
		val x' = variant (flat(map frees(conc::asms))) x;
	in
		([(asms, var_subst[(x', x)] b)],
		(fn [thm] => simple_µ_intro x' thm | _ => bad_proof "simple_µ_tac"))
	end handle ex => divert ex "dest_simple_µ" "simple_µ_tac" 28081 []
);
=TEX
\subsection{Concerning ∂}
=SML
fun €simple_∂_tac› (tm : TERM) : TACTIC = (fn (asms, conc) =>
	let	val (x, b) = dest_simple_∂ conc;
	in
		([(asms, var_subst[(tm, x)] b)],
		(fn [thm] => simple_∂_intro conc thm | _ => bad_proof "simple_∂_tac"))
	end
	handle ex =>
	case area_of ex of
		"var_subst" => term_fail "simple_∂_tac" 28092 [tm]
	|	"dest_simple_∂" => fail "simple_∂_tac" 28091 []
	|	_ => raise ex
);
=TEX
\section{STRIPPING THEOREMS AND GOALS}
=SML
fun €check_asm_tac› (thm : THM) : TACTIC = (fn gl as (asms, conc) =>
	let	val t = concl thm;
	in	if ¡_eq t conc
		then accept_tac thm
		else if is_t t
		then id_tac
		else if is_f t
		then f_thm_tac thm
		else if is_≥ t
		then	let	val t' = dest_≥ t;
				fun aux (asm :: more) = (
					if ¡_eq t asm
					then id_tac
					else if ¡_eq asm t'
					then accept_tac (≥_elim conc (asm_rule asm) thm)
					else if ¡_eq asm conc
					then accept_tac (asm_rule asm)
					else aux more
				) | aux [] = asm_tac thm;
			in	aux asms
			end
		else	let	fun aux (asm :: more) = (
					if ¡_eq t asm
					then id_tac
					else if is_≥ asm andalso ¡_eq (dest_≥ asm) t
					then accept_tac (≥_elim conc thm (asm_rule asm))
					else if ¡_eq asm conc
					then accept_tac (asm_rule asm)
					else aux more
					) | aux [] = asm_tac thm;
			in	aux asms
			end
	end	gl
);
=TEX
=SML
val €goal_in_asms_tac› : TACTIC = (fn gl as (asms, conc) =>
	if conc term_mem asms
	then accept_tac (asm_rule conc) gl
	else fail "goal_in_asms_tac" 28002 []
);
=TEX
We start off with theorem strippers and goal strippers which 
have no values in their parameterisation.

Even if we didn't have the error message, we would still
use the $(fn\ =>\ \ldots)$ form, to prevent
$get\_proof\_context()$ being evaluated before point of use.
=SML
val €STRIP_THM_THEN› : THM_TACTICAL = (fn ttac:THM_TACTIC => 
	fn thm :THM =>
	(FIRST_TTCL[CONV_THEN (get_epc_st_conv (get_proof_context())),
		±_THEN, 
		≤_THEN, 
		SIMPLE_∂_THEN]
	ORELSE_TTCL
		FAIL_WITH_THEN "STRIP_THM_THEN" 28003 
			[fn () => string_of_thm thm])
	ttac
	thm
);
=TEX

Even if we didn't have the error message, we would still
use the $(fn\ =>\ \ldots)$ form, to prevent
$get\_proof\_context()$ being evaluated before point of use.
=SML
fun €STRIP_GOAL_T› (ttac : THM_TACTIC) : TACTIC = (fn gl =>
	(FIRST[ conv_tac(get_epc_sg_conv (get_proof_context())),
		simple_µ_tac,
		±_tac,
		¥_T ttac,
		t_tac,
		goal_in_asms_tac]
	ORELSE_T
		fail_with_tac "STRIP_GOAL_T" 28003 
		[fn () => string_of_term(snd gl)])
	gl
);
=TEX
=SML
val €strip_asm_tac› : THM_TACTIC =
	REPEAT_TTCL STRIP_THM_THEN check_asm_tac;
=TEX
=SML
val  €strip_tac› : TACTIC = (fn gl => 
	STRIP_GOAL_T strip_asm_tac gl
	handle complaint =>
	pass_on complaint "STRIP_GOAL_T" "strip_tac");
=TEX
\subsection{Some Tautologies}
We now give a local context using $§\_thm$:
=SML
val €local_strip_thm_thens› : EQN_CXT =
	[ (thm_eqn_cxt §_thm) ];
=TEX
=SML
val €local_strip_goal_ts› : EQN_CXT =
	[ (thm_eqn_cxt §_thm) ];

val €local_strip_epc› : EPROOF_CONTEXT =  (
	set_epc_name "local_strip_epc"
	(set_epc_st_conv (eqn_cxt_conv local_strip_thm_thens)
	(set_epc_sg_conv (eqn_cxt_conv local_strip_goal_ts)
	initial_epc))
);
=TEX
Now put a local proof context on the otherwise empty stack.
=SML
val _ = push_proof_context local_strip_epc;
=TEX
We now have some machinery in place with which we can prove the tautologies
need for the tacticals which support $strip\_tac$:
=SML
val €¥_thm› = save_thm("¥_thm", tac_proof( ([], ¨µa b∑(a ¥ b) § (≥a ≤ b)Æ),
	REPEAT strip_tac
	THEN CASES_T ¨a:BOOLÆ asm_tac THEN_LIST
	[≤_right_tac THEN all_undisch_tac THEN REPEAT strip_tac,
	 ≤_left_tac THEN all_undisch_tac THEN REPEAT strip_tac]));
=TEX
=SML
val €≥_≥_thm› = save_thm("≥_≥_thm", tac_proof( ([], ¨µa∑≥ ≥a § aÆ),
		REPEAT strip_tac THEN_LIST
	[accept_tac (≥_≥_elim (asm_rule ¨≥≥aÆ)),
	 accept_tac (≥_≥_intro (asm_rule ¨a:BOOLÆ))]));
=TEX
=SML
val €≥_≤_thm› = save_thm("≥_≤_thm", tac_proof( ([], ¨µa b∑≥ (a ≤ b) § (≥a ± ≥b)Æ),
	conv_tac(MAP_C (simple_eq_match_conv ≥_thm)) THEN
	REPEAT strip_tac THEN_LIST 
	[LEMMA_T ¨a ≤ bÆ(accept_tac o ¥_mp_rule (asm_rule ¨a ≤ b ¥ FÆ)) THEN 
		≤_left_tac THEN accept_tac(asm_rule ¨a:BOOLÆ), 
	LEMMA_T ¨a ≤ bÆ(accept_tac o ¥_mp_rule (asm_rule ¨a ≤ b ¥ FÆ)) THEN
		≤_right_tac THEN accept_tac(asm_rule ¨b:BOOLÆ),
	accept_tac(¥_mp_rule (asm_rule ¨a ¥ FÆ) (asm_rule ¨a:BOOLÆ)),
	accept_tac(¥_mp_rule (asm_rule ¨b ¥ FÆ) (asm_rule ¨b:BOOLÆ))] ));
=TEX
The following is not asked for in the detailed design (because it does
not fit into any general framework, or at least we do not provide
the general framework it would fit into --- namely conversion of propositional
terms into the fragment of propositional calculus generated by implication
and falsity (or negation)).

The proof only works for $strip\_tac$ without additional
equational context material.
=SML
val €≤_≥_thm› = tac_proof( ([], ¨µa b∑(a ≤ ≥b) § (b ¥ a)Æ),
	REPEAT strip_tac THEN
	CASES_T ¨a:BOOLÆ asm_tac THEN_LIST
	[≤_left_tac THEN all_undisch_tac THEN REPEAT strip_tac,
	≤_right_tac THEN accept_tac(modus_tollens_rule(asm_rule¨b ¥ aÆ)(asm_rule¨≥aÆ))]);
=TEX
=SML
val €≥_±_thm› = ( (* Ù ≥(a ± b) § (≥a ≤ ≥b) *)
save_thm("≥_±_thm",
let	val thm1 = tac_proof( ([], ¨≥(a ± b) § (a ¥ ≥b)Æ),
	conv_tac(MAP_C (simple_eq_match_conv ≥_thm))
	THEN REPEAT strip_tac
	THEN_LIST
	[CASES_T¨a:BOOLÆ asm_tac
		THEN LEMMA_T ¨a ± bÆ
		(fn th1 => accept_tac(¥_mp_rule(asm_rule¨a ± b ¥ FÆ)(asm_rule¨a ± bÆ)))
		THEN REPEAT strip_tac,
		accept_tac(¥_mp_rule(¥_mp_rule(asm_rule¨a ¥ b ¥ FÆ)
					(asm_rule¨a:BOOLÆ))(asm_rule¨b:BOOLÆ))]);
		val thm2 = tac_proof( ([], ¨(a ¥ ≥b) § (≥a ≤ ≥b)Æ),
	conv_tac(MAP_C(FIRST_C(map simple_eq_match_conv
	[¥_thm, ≥_≥_thm, §_t_intro(refl_conv¨xÆ)])))
	THEN t_tac);
in	list_simple_µ_intro[¨a:BOOLÆ, ¨b:BOOLÆ](eq_trans_rule thm1 thm2)
end));
=TEX
=SML
val €≥_¥_thm› = save_thm("≥_¥_thm", tac_proof( ([], ¨µa b∑≥(a ¥ b) § (a ± ≥b)Æ),
	conv_tac(TOP_MAP_C(FIRST_C (map simple_eq_match_conv
		[¥_thm, ≥_≤_thm, ≥_≥_thm] )))
		THEN REPEAT strip_tac));
=TEX
=SML
val €≥_§_thm› = (* Ù µ a b ∑ ≥ (a § b) § a ± ≥ b ≤ b ± ≥ a  *)
		save_thm("≥_§_thm",
		list_simple_µ_intro[¨a:BOOLÆ, ¨b:BOOLÆ]
		((RAND_C(simple_eq_match_conv §_thm)
		THEN_C (simple_eq_match_conv ≥_±_thm)
		THEN_C (MAP_C(simple_eq_match_conv ≥_¥_thm)))
		¨≥(a § b)Æ));
=TEX
=SML
val €≥_f_thm› = save_thm("≥_f_thm", tac_proof( ([], ¨≥F § TÆ),
	§_t_tac THEN conv_tac (simple_eq_match_conv ≥_thm) THEN strip_tac));
=TEX
=SML
val €≥_if_thm› = (* Ù µ a b c∑ ≥(if a then b else c) § (if a then ≥b else ≥c)  *)
	save_thm("≥_if_thm", 
	list_simple_µ_intro[¨a:BOOLÆ, ¨b:BOOLÆ, ¨c:BOOLÆ]
		(fun_if_conv ¨≥(if a then b else c)Æ));
=TEX
\subsection{Additional Conversions, Tactics and Tacticals}
\subsubsection{Concerning ∂$_1$}
=SML
val €simple_∂â1_conv› : CONV = (fn tm =>
	let	val (x, b) = dest_simple_∂â1 tm
		val s1 = ¥_intro tm (simple_∂â1_elim (asm_rule tm));
		val y = variant (x :: frees b) x;
		val conj = mk_±(b, mk_µ(y, mk_¥(var_subst[(y, x)]b, mk_eq(y, x))));
		val exi = mk_∂(x, conj)
		val s2 = asm_rule conj;
		val s3 = simple_∂â1_intro (±_left_elim s2) (±_right_elim s2)
		val s4 = simple_∂_elim x (asm_rule exi) s3
		val s5 = ¥_intro exi s4;
	in	§_intro s1 s5
	end handle ex => pass_on ex "dest_simple_∂â1" "simple_∂â1_conv"
);
val €simple_≥_∂â1_conv› : CONV = (fn tm =>
	((RAND_C simple_∂â1_conv THEN_C simple_≥_∂_conv) tm)
	handle  Fail _ => term_fail "simple_≥_∂â1_conv" 28091 [tm]
);
=TEX
\subsubsection{Concerning ≥}
This requires proper testing against a ``try along list until fail''.
=SML
local
	val c = eqn_cxt_conv ((map thm_eqn_cxt
		[≥_≥_thm, ≥_±_thm, ≥_≤_thm, ≥_¥_thm,
		 ≥_§_thm, ≥_if_thm, ≥_t_thm, ≥_f_thm]) @
		[(¨≥(µ x ∑ y)Æ, simple_≥_µ_conv),
		(¨≥(∂ x ∑ y)Æ, simple_≥_∂_conv),
		(¨≥(∂â1 x ∑ y)Æ, simple_≥_∂â1_conv)]);
in
val €simple_≥_in_conv› : CONV = (fn tm =>
	c tm
	handle complaint =>
	divert complaint "eqn_cxt_conv" "simple_≥_in_conv" 28131
		[fn () => string_of_term tm]
);
end;
=TEX
=IGN
The following is a ``try along list until fail''
=SML
val €simple_≥_in_conv› : CONV = FIRST_C(
		map simple_eq_match_conv
		[≥_≥_thm, ≥_±_thm, ≥_≤_thm, ≥_¥_thm,
		 ≥_§_thm, ≥_if_thm, ≥_t_thm, ≥_f_thm] 
	@	[simple_≥_µ_conv, simple_≥_∂_conv, simple_≥_∂â1_conv])
	ORELSE_C (fn tm => term_fail "simple_≥_in_conv" 28131 [tm]);
=IGN
On the following list of test cases the $TRY\_C$ of the net version seems to run at twice the speed.

val test_simple_≥_in_conv = [
	¨≥ (≥ a)Æ,
	¨≥(a ± b)Æ,
	¨≥(a ≤ b)Æ,
	¨≥(a ¥ b)Æ,
	¨≥(a § b)Æ,
	¨≥(if a then b else c)Æ,
	¨≥ TÆ,
	¨≥ FÆ,
	¨≥(µ x ∑ f x y)Æ,
	¨≥(∂ x ∑ f x y)Æ,
	¨≥(∂â1 x ∑ f x y)Æ,
	¨xÆ,
	¨x ± yÆ,
	¨≥ aÆ,
	¨≥ (µ (x,y) ∑ x ± y)Æ];

Upon the following the net version is 33 times faster.
let
	val tm = ¨f (g x y)Æ
in
(map (TRY_C simple_≥_in_conv) (map (fn _ => tm) (interval 1 1000));())
end;

=SML
val €SIMPLE_≥_IN_THEN› : THM_TACTICAL = (fn ttac => fn thm =>
	(ttac(§_mp_rule(simple_≥_in_conv(concl thm))thm))
	handle complaint => 
	divert complaint "simple_≥_in_conv" "SIMPLE_≥_IN_THEN" 28026 []
);
=TEX
=SML
val €simple_≥_in_tac› : TACTIC = (fn gl => 
	((conv_tac simple_≥_in_conv) gl)
	handle complaint => 
	divert complaint "simple_≥_in_conv" "simple_≥_in_tac" 28025 []
);
=TEX
\subsubsection{Concerning ¥}
=SML
val €¥_THEN› : THM_TACTICAL = (fn ttac => fn thm =>
	let	val (t1, t2) = dest_¥ (concl thm)
	in	ttac(§_mp_rule(list_simple_µ_elim[t1, t2]¥_thm)thm)
	end	handle ex => 
	divert ex "dest_¥" "¥_THEN" 28054 [fn () => string_of_thm thm]
);
=TEX
\subsubsection{Concerning ≤}
=SML
val a_≤_≥b_thm = ≤_≥_thm;

val ≥a_≤_b_thm = list_simple_µ_intro[¨a:BOOLÆ, ¨b:BOOLÆ]
	(eq_sym_rule(all_simple_µ_elim ¥_thm));

val a_≤_b_thm = (
	conv_rule(MAP_C(simple_eq_match_conv ≥_≥_thm))
	(list_simple_µ_intro[¨a:BOOLÆ, ¨b:BOOLÆ]
			(eq_sym_rule(list_simple_µ_elim[¨≥aÆ, ¨b:BOOLÆ]¥_thm)))
);

local
val €≤_conv› = FIRST_C(map simple_eq_match_conv
	[a_≤_≥b_thm,
	≥a_≤_b_thm,
	a_≤_b_thm]);
in
val €≤_tac› = conv_tac(≤_conv);
end;
=TEX
\subsubsection{Concerning if...then...else}
=GFT
Ù µ a t1 t2∑ (if a then t1 else t2) § (a ¥ t1) ± (≥ a ¥ t2)
=TEX
=SML
val €local_if_thm› =  
let	val s1 = asm_rule ¨(a ¥ t1) ± (≥ a ¥ t2)Æ;
	val s2 = ±_left_elim s1;
	val s3 = ±_right_elim s1;
	val s4 = undisch_rule s2;
	val s5 = undisch_rule s3;
	val s6 = if_intro ¨a:BOOLÆ s4 s5;
	val s7 = all_¥_intro s6;
	val s8 = asm_rule ¨if a then t1 else t2: BOOLÆ;
	val s9 = if_then_elim s8;
	val s10 = if_else_elim s8;
	val s11 = ±_intro s9 s10;
	val s12 = all_¥_intro s11;
	val s13 = §_intro s12 s7;
	val s14 = all_µ_intro s13;
in	s14
end;
=TEX
\section{Stripping Contexts}
We could usefully expand out the call to $simple\_≥\_in\_conv$.
=SML
val €initial_strip_thm_thens› : EQN_CXT =
	[	(thm_eqn_cxt ¥_thm),
		(thm_eqn_cxt §_thm),
		(thm_eqn_cxt local_if_thm),
		(¨≥ xÆ, simple_≥_in_conv),
		(¨∂â1 x ∑ pÆ, simple_∂â1_conv)];
=TEX
=SML
val €initial_strip_goal_ts› : EQN_CXT =
	[	(thm_eqn_cxt §_thm),
		(¨≥ xÆ, simple_≥_in_conv),
		(thm_eqn_cxt a_≤_≥b_thm),
		(thm_eqn_cxt ≥a_≤_b_thm),
		(thm_eqn_cxt a_≤_b_thm),
		(thm_eqn_cxt local_if_thm)];
=TEX
Now we can declare and set the proof contexts:
=SML
val €initial_strip_pc› : PROOF_CONTEXT = (
	set_pc_name "initial_strip_pc"
	(set_pc_st_eqn_cxt initial_strip_thm_thens
	(set_pc_sg_eqn_cxt initial_strip_goal_ts
	initial_pc))
);
val €initial_strip_epc› : EPROOF_CONTEXT =  (
	set_epc_name "initial_strip_epc"
	(set_epc_st_conv (eqn_cxt_conv initial_strip_thm_thens)
	(set_epc_sg_conv (eqn_cxt_conv initial_strip_goal_ts)
	initial_epc))
);
val _ = pop_proof_context ();
val _ = push_proof_context initial_strip_epc;
=TEX
\subsection{Concerning $if ... then ... else ...$}
=SML
val €if_thm› = save_thm("if_thm",
	tac_proof( ([],
	¨µ a b c ∑ (if a then b else c) § (a ± b ≤ ≥ a ± c)Æ),
	REPEAT strip_tac));
=TEX
\section{TAUTOLOGY PROVER}
The tautology prover functions as a limited $strip\_tac$,
but is not an instantiation of it.
The following could perhaps be speeded up by further use of nets.
=SML
local
val €taut_strip_thm_conv› : CONV = (
	eqn_cxt_conv(
	map thm_eqn_cxt
	[≥_≥_thm, ≥_±_thm, ≥_≤_thm, ≥_¥_thm,
	 ≥_§_thm, ≥_t_thm, ≥_f_thm,
	¥_thm, §_thm, local_if_thm
]));

val €taut_strip_goal_conv› : CONV = (
	eqn_cxt_conv(
	map thm_eqn_cxt
	[≥_≥_thm, ≥_±_thm, ≥_≤_thm, ≥_¥_thm,
	 ≥_§_thm, ≥_t_thm, ≥_f_thm,
	§_thm, local_if_thm,
	a_≤_≥b_thm, ≥a_≤_b_thm, a_≤_b_thm]
));

val €taut_strip_thm_thens› : THM_TACTICAL list = [
	±_THEN,
	≤_THEN,
	CONV_THEN taut_strip_thm_conv
];

val €taut_strip_goal_ts› : (THM_TACTIC -> TACTIC) list = [
	fn _ => ±_tac,
	¥_T,
	fn _ => t_tac,
	fn _ => conv_tac taut_strip_goal_conv,
	fn _ => goal_in_asms_tac
];

val €taut_strip_tac› : TACTIC = (
	FIRST
	(map(fn t => t(REPEAT_TTCL (FIRST_TTCL taut_strip_thm_thens) check_asm_tac))
		taut_strip_goal_ts)
);
in
val €taut_tac› : TACTIC = (fn gl =>
	case REPEAT taut_strip_tac gl of
		done as ([], _) => done
	|	_ => fail "taut_tac" 28121 []
);
end;
=TEX
The above should be properly compared to an implementation
that doesn't use nets, and one that tries to use them harder.
=IGN
The following is written avoiding nets:
local
val €taut_≥_in_conv› : CONV = FIRST_C(
		map simple_eq_match_conv
		[≥_≥_thm, ≥_±_thm, ≥_≤_thm, ≥_¥_thm,
		 ≥_§_thm, ≥_t_thm, ≥_f_thm]);
val €TAUT_≥_IN_THEN› : THM_TACTICAL = (fn ttac => fn thm =>
	ttac(§_mp_rule(taut_≥_in_conv(concl thm))thm)
);
val €taut_strip_thm_thens› : THM_TACTICAL list =
	[	±_THEN,
		¥_THEN,
		≤_THEN,
		TAUT_≥_IN_THEN,
		§_THEN,
		IF_THEN];
val €taut_strip_goal_ts› : (THM_TACTIC -> TACTIC) list =
	[fn _ => ±_tac,
		¥_T,
		§_T,
		fn _ => conv_tac taut_≥_in_conv,
		fn _ => ≤_tac,
		IF_T,
		fn _ => t_tac,
		fn _ => goal_in_asms_tac];

val €taut_strip_tac› : TACTIC = 
	FIRST
	(map(fn t => t(REPEAT_TTCL (FIRST_TTCL taut_strip_thm_thens) check_asm_tac))
		taut_strip_goal_ts);
in
val €taut_tac1› : TACTIC = (fn gl =>
	case REPEAT taut_strip_tac gl of
		done as ([], _) => done
	|	_ => fail "taut_tac" 28121 []
);
end;
On the tautologies:

val tm = ¨(a ± b ± c ± d ¥ e) § (a ¥b ¥ c ¥ d ¥ e)Æ;
val tm1 = ¨(if a then t1 else t2) ± (if a then t3 else t4) § if a then (t1 ± t3) else (t2 ± t4)Æ;

the net version runs in roughly a third of the time
of the above.
=TEX
\section{TACTICS FOR THE PREDICATE CALCULUS 2}
We now give the remaining tactics.
\subsection{Concerning $F$}
=SML
fun  €C_CONTR_T› (thmtac : THM -> TACTIC) : TACTIC = (fn gl as (asms, conc) =>
	let	val ≥_conc = mk_≥ conc;
		val (sgs, pf) =  (thmtac (asm_rule ≥_conc)) (asms, mk_f);
		fun rule thm = (
			if ≥_conc term_mem (hyps thm)
			then c_contr_rule conc thm
			else contr_rule conc thm
		);
	in	(sgs, rule o pf)
	end
	handle ex => divert ex "mk_≥" "C_CONTR_T" 28027 []
);
=TEX
=SML
val €c_contr_tac› : TACTIC = (fn gl =>
	(C_CONTR_T strip_asm_tac gl)
	handle ex => pass_on ex "C_CONTR_T" "c_contr_tac"
);
=TEX
\subsection{Concerning ≥}
=SML
fun  €≥_elim_tac› (tm : TERM) : TACTIC = (
	if type_of tm <> BOOL
	then term_fail "≥_elim_tac" 28022 [tm]
	else	(fn (asms, conc) =>
			([(asms, tm), (asms, mk_≥ tm)],
			 fn [th1, th2] => ≥_elim conc th1 th2
			 |   _ => bad_proof "≥_elim_tac" )
		)
);
=TEX
=SML
fun  €≥_T2› (t1 : TERM)
	(thmtac1 : THM -> TACTIC) (thmtac2 : THM -> TACTIC)
		: TACTIC = (fn gl as (asms, conc) =>
	let	val t2 = (dest_≥ conc)
			handle Fail _ => fail "≥_T2" 28023 [];
		val ≥_t1 = (mk_≥ t1)
			handle Fail _ => term_fail "≥_T2" 28022 [t1];
		val (sgs1, pf1) = (thmtac1 (asm_rule t2)) (asms, t1);
		val (sgs2, pf2) = (thmtac2 (asm_rule t2)) (asms, ≥_t1);
		fun rule [thm1, thm2] = ≥_intro t2 thm1 thm2
		|   rule _ = bad_proof "≥_T2";
	in	(sgs1 @ sgs2, rule o mapshape[(pf1, length sgs1), 
			(pf2, length sgs2)])
	end	
);
=TEX
=SML
fun  €≥_T› (t1 : TERM) (thmtac : THM -> TACTIC) : TACTIC = (fn thm =>
	(≥_T2 t1 thmtac thmtac thm)
	handle ex => pass_on ex "≥_T2" "≥_T"
);
=TEX
=SML
fun €≥_tac› (t : TERM) : TACTIC = (fn gl =>
	(≥_T t strip_asm_tac gl)
	handle ex => pass_on ex "≥_T" "≥_tac"
);
=TEX
\subsection{Concerning ≤}
=SML
val €≤_comm_thm› : THM = tac_proof(([], ¨µa b∑a ≤ b § b ≤ aÆ), 
	REPEAT strip_tac);
=TEX
=SML
val €swap_≤_tac› : TACTIC = (fn gl =>
	((conv_tac(simple_eq_match_conv ≤_comm_thm)) gl)
	handle ex => divert ex "simple_eq_match_conv" "swap_≤_tac" 28041 []
);
=TEX
=SML
fun €cases_tac› (tm : TERM) : TACTIC = (fn gl =>
	(CASES_T tm strip_asm_tac gl)
	handle ex => pass_on ex "CASES_T" "cases_tac"
);
=TEX
\subsection{Concerning ¥}
=SML
val €¥_tac› : TACTIC = (fn gl =>
	(¥_T strip_asm_tac gl)
	handle ex => pass_on ex "¥_T" "¥_tac"
);
=TEX
\subsection{Concerning §}
=SML
fun €§_THEN2› (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: THM -> TACTIC = (fn thm => 
	let	val (thm1, thm2) = §_elim thm;
	in	ttac1 thm1 THEN ttac2 thm2
	end
	handle ex => divert ex "§_elim" "§_THEN2" 28062 
		[fn () => string_of_thm thm]
);
=TEX
=SML
fun €§_THEN› (ttac : THM -> TACTIC) : THM -> TACTIC = (fn thm => 
	(§_THEN2 ttac ttac thm)
	handle ex => pass_on ex "§_THEN2" "§_THEN"
);
=TEX
=SML
fun €§_T2› (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: TACTIC = (fn (asms, conc) => 
	let	val (t1, t2) = dest_§ conc;
		val (sgs1, pf1) = ttac1 (asm_rule t1) (asms, t2);
		val (sgs2, pf2) = ttac2 (asm_rule t2) (asms, t1);
		fun rule [thm1, thm2] = §_intro (¥_intro t1 thm1) (¥_intro t2 thm2)
		|   rule _ = bad_proof "§_T2";
	in	(sgs1 @ sgs2, rule o mapshape[(pf1, length sgs1), (pf2, length sgs2)])
	end
	handle ex => divert ex "dest_§" "§_T2" 28061 []
);
=TEX
=SML
fun  €§_T› (ttac : THM -> TACTIC) : TACTIC = (fn thm =>
	(§_T2 ttac ttac thm)
	handle ex => pass_on ex "§_T2" "§_T"
);
=TEX
=SML
val €§_tac› : TACTIC = (fn gl =>
	(§_T strip_asm_tac gl)
	handle ex => pass_on ex "§_T" "§_tac"
);
=TEX
\subsection{Concerning $if \ldots then \ldots else \ldots$}
=SML
fun €IF_THEN2› (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: THM -> TACTIC = (fn thm => 
	let	val thm1 = if_then_elim thm;
		val thm2 = if_else_elim thm;
	in	ttac1 thm1 THEN ttac2 thm2
	end
	handle ex => 
	pass_on ex "if_then_elim" "IF_THEN2"
);
=TEX
=SML
fun €IF_THEN› (ttac : THM -> TACTIC) : THM -> TACTIC = (fn thm => 
	(IF_THEN2 ttac ttac thm)
	handle ex => pass_on ex "IF_THEN2" "IF_THEN"
);
=TEX
=SML
fun €IF_T2› (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC) 
		: TACTIC = (fn (asms, conc) =>
	let	val (a, tt, et) = dest_if conc;
		val (tsgs, tpf) = ttac1 (asm_rule a) (asms, tt);
		val (esgs, epf) = ttac2 (asm_rule (mk_≥ a)) (asms, et);
		fun rule [thm1, thm2] = if_intro a thm1 thm2
		|   rule _ = bad_proof "≥IF_T2";

	in	(tsgs @ esgs, rule o mapshape[(tpf, length tsgs), (epf, length esgs)])
	end handle ex => divert ex "dest_if" "IF_T2" 28071 []
);
=TEX
=SML
fun  €IF_T› (ttac : THM -> TACTIC) : TACTIC = (fn thm =>
	(IF_T2 ttac ttac thm)
	handle ex => pass_on ex "IF_T2" "IF_T"
);
=TEX
=SML
val €if_tac› : TACTIC = (fn gl =>
	(IF_T strip_asm_tac gl)
	handle ex => pass_on ex "IF_T" "if_tac"
);
=TEX
\subsection{Concerning ∂$_1$}
=SML
fun €simple_∂â1_tac› (tm : TERM) : TACTIC = (fn (asms, conc) =>
	let	val (x, b) = dest_simple_∂â1 conc;
		val x' = variant (frees tm) x;
		val b' = var_subst[(x',x)]b;
		val u = mk_µ(x', mk_¥(b', mk_eq(x', tm)))
	in
		([(asms, var_subst[(tm, x')] b'), (asms, u)],
		(fn [th1, th2] => simple_∂â1_intro th1 th2
		| _ => bad_proof "simple_∂â1_tac"))
	end
	handle ex =>
	case area_of ex of
		"dest_simple_∂â1" => fail "simple_∂â1_tac" 28101 []
	|	"mk_eq" => term_fail "simple_∂â1_tac" 28092 [tm]
	|	_ => raise ex
);

fun €SIMPLE_∂â1_THEN› (ttac : THM -> TACTIC) = (fn thm =>
	(SIMPLE_∂_THEN ttac (simple_∂â1_elim thm))
	handle ex => divert ex "simple_∂â1_elim" 
		"SIMPLE_∂â1_THEN" 28102 
		[fn () => string_of_thm thm]
);
=TEX
\subsection{Swapping Assumptions and Conclusions}
=SML
local
	val thm1 = tac_proof(([], ¨µ f ∑ (f ¥ F) § ≥ fÆ),
		REPEAT strip_tac);
	val thm2 = tac_proof(([], ¨µ f ∑ ((≥ f) ¥ F) § fÆ),
		REPEAT strip_tac);
	val thm3 = tac_proof(([], ¨µ f g ∑ (f ¥ g) § ((≥ f) ≤ g)Æ),
		REPEAT strip_tac);
	val thm4 = tac_proof(([], ¨µ f g ∑ ((≥ f) ¥ g) § (f ≤ g)Æ),
		REPEAT strip_tac);
	val ¥_F_conv = (fn ntm =>
		let	val tm = fst(dest_¥ ntm);
		in
			if is_≥ tm
			then simple_µ_elim(dest_≥ tm) thm2
			else simple_µ_elim tm thm1
		end);
	fun local_conv (tm : TERM) : THM = (
	let	val (d1,d2) = dest_¥ tm;
	in
		if d2 = mk_f
		then ¥_F_conv tm
		else ((fn _ => if is_≥ d1
		then list_simple_µ_elim[dest_≥ d1, d2] thm4
		else list_simple_µ_elim[d1, d2] thm3)
			FURTHER_C (RAND_C local_conv)) tm
	end);
	fun local_tac ([] : THM list) : TACTIC = id_tac
	| local_tac thms = (
	let	val rthms = rev thms;
	in
		MAP_EVERY ante_tac rthms
		THEN conv_tac local_conv
	end);
	
	
in	
=TEX
=SML		
fun  €SWAP_ASM_CONCL_T› (asm:TERM) (thmtac:THM -> TACTIC) : TACTIC = (
fn gl as (asms, conc) =>
let	val ≥_conc = mk_≥ conc;
	val (sgs, pf) =  ((undisch_tac asm THEN
		conv_tac ¥_F_conv THEN
		thmtac (asm_rule ≥_conc)) (asms, mk_f))
		handle complaint =>
		pass_on complaint "undisch_tac" "SWAP_ASM_CONCL_T";
	fun rule thm = (
		if ≥_conc term_mem (hyps thm)
		then c_contr_rule conc thm
		else contr_rule conc thm
	);
in	(sgs, rule o pf)
end
handle complaint => 
divert complaint "mk_≥" "SWAP_ASM_CONCL_T" 28027 []
);
=TEX
=SML		
fun  €LIST_SWAP_ASM_CONCL_T› ([]:TERM list) (thmtac:THM -> TACTIC) : TACTIC = (
	C_CONTR_T thmtac
) | LIST_SWAP_ASM_CONCL_T lasms thmtac = (
fn gl as (asms, conc) =>
let	val ≥_conc = mk_≥ conc;
	val (sgs, pf) =  ((list_undisch_tac lasms THEN
		conv_tac (TRY_C local_conv) THEN
		thmtac (asm_rule ≥_conc)) (asms, mk_f))
		handle complaint =>
		pass_on complaint "list_undisch_tac" "LIST_SWAP_ASM_CONCL_T";
	fun rule thm = (
		if ≥_conc term_mem (hyps thm)
		then c_contr_rule conc thm
		else contr_rule conc thm
	);
in	(sgs, rule o pf)
end
handle complaint => 
divert complaint "mk_≥" "LIST_SWAP_ASM_CONCL_T" 28027 []
);
=TEX
=SML
fun  €SWAP_NTH_ASM_CONCL_T› (n:int) (thmtac:THM -> TACTIC) : TACTIC = (
fn gl as (asms, conc) =>
let	val ≥_conc = mk_≥ conc;
	val (sgs, pf) =  (((DROP_NTH_ASM_T n ante_tac) THEN
		conv_tac ¥_F_conv THEN
		thmtac (asm_rule ≥_conc)) (asms, mk_f))
		handle complaint =>
		pass_on complaint "DROP_NTH_ASM_T" "SWAP_NTH_ASM_CONCL_T";
	fun rule thm = (
		if ≥_conc term_mem (hyps thm)
		then c_contr_rule conc thm
		else contr_rule conc thm
	);
in	(sgs, rule o pf)
end
handle complaint => 
divert complaint "mk_≥" "SWAP_NTH_ASM_CONCL_T" 28027 []
);
=TEX
=SML		
fun €LIST_SWAP_NTH_ASM_CONCL_T› ([]:int list) (thmtac:THM -> TACTIC) : TACTIC = (
	C_CONTR_T thmtac
) | LIST_SWAP_NTH_ASM_CONCL_T ns thmtac = (
fn gl as (asms, conc) =>
let	val ≥_conc = mk_≥ conc;
	val (sgs, pf) =  ((LIST_DROP_NTH_ASM_T ns local_tac THEN
		thmtac (asm_rule ≥_conc)) (asms, mk_f))
		handle complaint =>
		pass_on complaint "LIST_DROP_NTH_ASM_T" "LIST_SWAP_NTH_ASM_CONCL_T";
	fun rule thm = (
		if ≥_conc term_mem (hyps thm)
		then c_contr_rule conc thm
		else contr_rule conc thm
	);
in	(sgs, rule o pf)
end
handle complaint => 
divert complaint "mk_≥" "LIST_SWAP_NTH_ASM_CONCL_T" 28027 []
);
=TEX
=SML
end;
=TEX
Now the standard forms:
=SML
fun €swap_asm_concl_tac› (tm : TERM) : TACTIC = (fn gl =>
	SWAP_ASM_CONCL_T tm strip_asm_tac gl
	handle complaint =>
	pass_on complaint "SWAP_ASM_CONCL_T" "swap_asm_concl_tac"
);
fun €swap_nth_asm_concl_tac› (n : int) : TACTIC = (fn gl =>
	SWAP_NTH_ASM_CONCL_T n strip_asm_tac gl
	handle complaint =>
	pass_on complaint "SWAP_NTH_ASM_CONCL_T" "swap_nth_asm_concl_tac"
);
fun €list_swap_asm_concl_tac› (tml : TERM list) : TACTIC = (fn gl =>
	LIST_SWAP_ASM_CONCL_T tml strip_asm_tac gl
	handle complaint =>
	pass_on complaint "LIST_SWAP_ASM_CONCL_T" "list_swap_asm_concl_tac"
);
fun €list_swap_nth_asm_concl_tac› (ns : int list) : TACTIC = (fn gl =>
	LIST_SWAP_NTH_ASM_CONCL_T ns strip_asm_tac gl
	handle complaint =>
	pass_on complaint "LIST_SWAP_NTH_ASM_CONCL_T" "list_swap_nth_asm_concl_tac"
);
=TEX
\subsection{$lemma\_tac$}
=SML
fun €lemma_tac› (sg : TERM) : TACTIC = (fn gl =>
	(LEMMA_T sg strip_asm_tac gl)
	handle ex => pass_on ex "LEMMA_T" "lemma_tac"
);
=TEX
\subsection{End of Structure}
Restore the previous theory:
=SML
val _ = open_theory was_theory;
=TEX
=SML
end; (* of structure Tactics2 *)
open Tactics2;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


