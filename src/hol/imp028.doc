=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation of Tactics II}
\TPPref{DS/FMU/IED/IMP028}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D. Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
first group of tactics and tacticals in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.4 (2 July 1991)]
First draft version.
\item [Issue 1.5 (3 July 1991)]
Fixed $IF\_T$.
\item [Issue 1.9 (12th August 1991)]
Update reflecting issue 1.8 design changes.
\item [Issue 1.10 (\FormatDate{91/08/15%
})]
Renamings of functions containing the name atom $simple$,
and renaming of $aconv$.
\item [Issue 1.11 (25th October 1991)]
Re-implementation of stripping material,
and other changes in response to deskcheck ID0029.
\item [Issue 1.12 (29th October 1991)]
Made $eqn\_cxt\_conv$ ignore ``no change'' conversions.
\item [Issue 1.13 (31st October 1991)]
Changes during testing.
\item [Issue 1.15 (18th November 1991)]
Corrected $CONTR\_T$.
\item [Issue 1.16 (18th November 1991)]
Reacting to issue 1.5/6 of \cite{DS/FMU/IED/DTD051}.

\item[Issue 1.17, \FormatDate{92/01/20} ] Updated to use new fonts.

\item [Issue 1.18,1.19 (5th February 1992)]
Modified $strip\_tac$, added $swap\_asm\_concl\_tac$, et al.
\item [Issue 1.20,1.21 (10th,11th February 1992)]
Minor corrections.
\item [Issue 1.23 (11th March 1992)]
Various minor additions and extensions.
\item [Issue 1.24,1.25 (26th March 1992)]
Changed to use proof context material of issue 1.13 of \cite{DS/FMU/IED/DTD051}.
\item [Issue 1.26 (1st April 1992)]
Changes required by CR0016.
\item [Issue 1.27 (13th April 1992)]
Changes due to CR0017.
\item [Issue 1.28 (14th May 1992)]
Tidying up proof contexts.
\item [Issue 1.29 (20th May 1992)]
Rearranging proof contexts.
\item [Issue 1.30 (26th May 1992)]
Renamings from version 1.5 of DS/FMU/IED/WRK038.
\item [Issue 1.31 (29th May 1992)]
Gained $prove\_tac$, $prove\_¶\_tac$.
\item [Issue 1.32 (2nd June 1992)]
Corrected equality theorems in proof contexts.
\item [Issue 1.33]
Added $intro\_µ\_tac$.
\item [Issue 1.34 (23rd June 1992)]
Corrected $prove(\_¶)\_tac$.
\item[Issue 1.35 (24th June 1992)]
Renamings from issue 1.6 of \cite{DS/FMU/IED/WRK038},
mostly proof context name changes.
\item[Issue 1.37 (31st July 1992)]
Extended error checking on $SIMPLE\_¶\_THEN$.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for material
whose detailed design is given in in \cite{DS/FMU/IED/DTD028}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the implementation for the 
second group of tactics and tacticals for ICL HOL.
This group is mainly concerned with supplying support for predicate calculus
connectives (including boolean conditionals but not boolean $let$-expressions).

\subsubsection{Dependencies}
Loading this document is dependent on \cite{DS/FMU/IED/IMP009}
and \cite{DS/FMU/IED/IMP051}.
\subsubsection{Deficiencies}
None known.
\section{PREAMBLE}
=SML
structure ÛTactics2Ý : Tactics2 = struct
=TEX
=SML
val Ûwas_theoryÝ = get_current_theory_name ();
val _ = open_theory "misc";
val _ = set_pc "initial";
=TEX
\section{TACTICALS FOR THE PREDICATE CALCULUS}
The following contain only those parts used in implementing
the stripping material.
\subsection{Concerning ±}
=SML
fun Û±_THEN2Ý (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: THM -> TACTIC = (fn thm => 
	let	val thm1 = ±_left_elim thm;
		val thm2 = ±_right_elim thm;
	in	ttac1 thm1 THEN ttac2 thm2
	end
	handle ex => divert ex "±_left_elim" "±_THEN2" 28032 
		[fn () => string_of_thm thm]
);
=TEX
=SML
fun Û±_THENÝ (ttac : THM -> TACTIC) : THM -> TACTIC = (fn thm => 
	(±_THEN2 ttac ttac thm)
	handle ex => pass_on ex "±_THEN2" "±_THEN"
);
=TEX
\subsection{Concerning ²}
$²\_LEFT\_T$ and $²\_RIGHT\_T$ are deferred until we have support
to do them via $´\_T$.
=SML
fun Û²_THEN2Ý (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: THM -> TACTIC = (fn thm => 
	let	val (t1, t2) = dest_²(concl thm);
	in	(fn (seqasms, conc) =>
			let	val (sgs1, pf1) = ttac1 (asm_rule t1) (seqasms, conc);
				val (sgs2, pf2) = ttac2 (asm_rule t2) (seqasms, conc);
			in	(sgs1 @ sgs2,
				(fn thl =>
					let	val len = length sgs1;
					in ²_elim thm (pf1(thl to (len - 1))) 
					  (pf2(thl from len))
					end
				))
			end)
	end
	handle ex => divert ex "dest_²" "²_THEN2" 28042 
		[fn () => string_of_thm thm]
);
=TEX
=SML
fun Û²_THENÝ (ttac : THM -> TACTIC) (thm : THM) : TACTIC = (
	²_THEN2 ttac ttac thm
	handle complaint =>
	pass_on complaint "²_THEN2" "²_THEN"
);
=TEX
=SML
=TEX
=SML
fun ÛCASES_T2Ý (t1 : TERM) (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
					: TACTIC = (fn gl as (seqasms, conc) =>
	let	val (sgs1, pf1) = ttac1 (asm_rule t1) (seqasms, conc);
		val (sgs2, pf2) = ttac2 (asm_rule (mk_³ t1)) (seqasms, conc);
	in	(sgs1 @ sgs2,
		(fn thl =>
			let	val len = length sgs1;
			in	asm_elim t1 (pf1(thl to (len - 1))) (pf2(thl from len))
			end
			))
	end
	handle ex => (
		if area_of ex = "asm_rule"
		then term_fail "CASES_T2" 28022 [t1]
		else raise ex
	)
);
=TEX
=SML
fun ÛCASES_TÝ (t1 : TERM) (ttac : THM -> TACTIC) : TACTIC = (fn gl =>
	((CASES_T2 t1 ttac ttac) gl)
	handle ex => pass_on ex "CASES_T2" "CASES_T"
);
=TEX
=IGN
fun Ûasm_cases_tacÝ (t1 : TERM) : TACTIC = (
	fn gl as (seqasms, conc) =>
	([(t1 :: seqasms, conc), (mk_³ t1 :: seqasms, conc)],
	  fn [th1, th2] => asm_elim t1 th1 th2
	 | _ => bad_proof "asm_cases_tac")
	handle ex => divert ex "mk_³" "asm_cases_tac" 28002 []
);
=TEX
\subsection{Concerning ´}
=SML
fun Û´_TÝ (ttac : THM -> TACTIC) : TACTIC = (fn (seqasms, conc) =>
	let	val (t1, t2) = dest_´ conc;
		val (sgs, pf) = ttac (asm_rule t1) (seqasms, t2);
	in	(sgs, ´_intro t1 o pf)
	end
	handle ex => divert ex "dest_´" "´_T" 28051 []
);
=TEX
\subsection{Concerning ¶}
=SML
fun ÛSIMPLE_¶_THENÝ (ttac : THM -> TACTIC) = (fn thm =>
	let	val (x, b) = dest_simple_¶(concl thm);
	in	(fn (seqasms, conc) =>
			let	val x' = variant (flat(map frees
				(conc :: concl thm :: asms thm @ seqasms))) x;
				val (sgs, pf) = ttac (asm_rule (var_subst[(x', x)] b)) 
					(seqasms, conc);
			in	(sgs, 
				(fn thm1 =>
				simple_¶_elim x' thm thm1
				handle complaint =>
				divert complaint 
					"simple_¶_elim" 
					"SIMPLE_¶_THEN"
					28094
					[fn () => string_of_term x',
					fn () => string_of_thm thm1,
					fn () => string_of_term x]
					) o pf)
			end)
	end
	handle ex => divert ex "dest_simple_¶" "SIMPLE_¶_THEN" 28093 
		[fn () => string_of_thm thm]
);
=TEX
\section{TACTICS FOR THE PREDICATE CALCULUS 1}
We now give the tactics which do not involve $strip\_asm\_tac$. These
will enable us to prove various simple theorems required to set up 
the stripping tacticals.
\subsection{Concerning $T$}
=SML
val Ût_tacÝ : TACTIC = (fn gl =>
	accept_tac t_thm gl
	handle complaint =>
	divert complaint "accept_tac" "t_tac" 28011 []
);
=TEX
=SML
val Û¤_t_tacÝ : TACTIC = (fn (seqasms, conc) => 
	let	val (lhs, rhs) = dest_eq conc;
	in	if rhs =$ mk_t
		then	([(seqasms, lhs)],
			 fn [th] => ¤_t_intro th | _ => bad_proof "¤_t_tac")
		else if lhs =$ mk_t
		then	([(seqasms, rhs)],
			 fn [th] => eq_sym_rule(¤_t_intro th) | _ => bad_proof "¤_t_tac")
		else fail "¤_t_tac" 28012 []
	end	handle Fail _ => fail "¤_t_tac" 28012 []
);
=TEX
\subsection{Concerning $F$}
=SML
val Ûi_contr_tacÝ : TACTIC = (fn (seqasms, conc) => 
	([(seqasms, mk_f)],
	 fn [th] => contr_rule conc th | _ => bad_proof "i_contr_tac")
);
=TEX
=SML
fun Ûf_thm_tacÝ (thm : THM) : TACTIC = (fn gl as (_, conc) => 
	let	val thm1 = contr_rule conc thm
	in	accept_tac thm1 gl
	end
	handle	ex => divert ex "contr_rule" "f_thm_tac" 28021 
		[fn () => string_of_thm thm]
);
=TEX
\subsection{Concerning ±}
=SML
val Û±_tacÝ : TACTIC = (fn (seqasms, conc) =>
	let	val (t1, t2) = dest_± conc
	in	([(seqasms, t1), (seqasms, t2)],
			 fn [th1, th2] => ±_intro th1 th2
			 |   _ => bad_proof "±_tac" )
	end handle ex => divert ex "dest_±" "±_tac" 28031 []
);
=TEX
\subsection{Concerning ²}
=SML
val  Û²_left_tacÝ : TACTIC = (fn (seqasms, conc) =>
	let	val (a, b) = dest_² conc
	in	([(seqasms, a)],
			 fn [th] => ²_right_intro b th
			 |   _ => bad_proof "²_left_tac" )
	end handle ex => divert ex "dest_²" "²_left_tac" 28041 []
);
=TEX
=SML
val  Û²_right_tacÝ : TACTIC = (fn (seqasms, conc) =>
	let	val (a, b) = dest_² conc
	in	([(seqasms, b)],
			 fn [th] => ²_left_intro a th
			 |   _ => bad_proof "²_right_tac" )
	end handle ex => divert ex "dest_²" "²_right_tac" 28041 []
);
=TEX
\subsection{Concerning ¤}
=SML
val Û¤_thmÝ = ( (* ô µ a b · (a ¤ b) ¤ (a ´ b) ± (b ´ a) *)
save_thm("¤_thm",
let
	val thm1 = asm_rule ¬(a ´ b) ± (b ´ a)®; 
	val thm2 = ¤_intro(±_left_elim thm1) (±_right_elim thm1);
	val (thm3, thm4) = ¤_elim(asm_rule¬a ¤ b®);
	val thm5 = ±_intro thm3 thm4;
in
	list_simple_µ_intro[¬a:BOOL®, ¬b:BOOL®]
		(¤_intro(all_´_intro thm5)(all_´_intro thm2))
end));
=TEX
\subsection{Concerning ´}
=SML
fun Ûasm_ante_tacÝ (t1 : TERM) : TACTIC = (fn (seqasms, conc) =>
	(if t1 term_mem seqasms
	then ([(seqasms term_less t1, mk_´(t1, conc))],
		(fn [thm] => undisch_rule thm | _ => bad_proof "asm_ante_tac"))
	else  term_fail "asm_ante_tac" 28052 [t1])
	handle ex => divert ex "mk_´" "asm_ante_tac" 28055 []
);
=TEX
When we undischarge more than one assumption we need to be careful not
to fail if the list of assumptions we are discharging contains repeats
which is allowed with the convention that the repeats are ignored.
=SML
local
	fun try_asm_ante_tac allasms asm : TACTIC = (fn (seqasms,conc) =>
	asm_ante_tac asm (seqasms,conc)
	handle complaint =>
	if asm term_mem allasms andalso type_of asm =: BOOL
		andalso type_of conc =: BOOL
	then id_tac  (seqasms,conc)
	else pass_on complaint "asm_ante_tac" "list_asm_ante_tac"
	);
	fun try_asm_ante_tac1 asm : TACTIC = (fn (seqasms,conc) =>
	asm_ante_tac asm (seqasms,conc)
	handle complaint =>
	if type_of asm =: BOOL andalso type_of conc =: BOOL
	then id_tac  (seqasms,conc)
	else pass_on complaint "asm_ante_tac" "all_asm_ante_tac"
	);
in
fun Ûlist_asm_ante_tacÝ (lasms : TERM list):  TACTIC = (fn (seqasms,conc) =>
	MAP_EVERY (try_asm_ante_tac seqasms) (rev lasms) (seqasms,conc)
);

val Ûall_asm_ante_tacÝ :  TACTIC = (fn (seqasms,conc) =>
	MAP_EVERY (try_asm_ante_tac1) seqasms (seqasms,conc)
);
end;
=TEX
=SML
fun Ûante_tacÝ (thm : THM) : TACTIC = (fn (seqasms, conc) =>
	([(seqasms, mk_´(concl thm, conc))],
	 fn [th] => ´_elim th thm | _ => bad_proof "ante_tac")
	handle ex => divert ex "mk_´" "ante_tac" 28027 []
);
=TEX
\subsection{Concerning µ}
=SML
val Ûsimple_µ_tacÝ : TACTIC = (fn (seqasms, conc) =>
	let	val (x, b) = dest_simple_µ conc;
		val x' = variant (flat(map frees(conc::seqasms))) x;
	in
		([(seqasms, var_subst[(x', x)] b)],
		(fn [thm] => simple_µ_intro x' thm | _ => bad_proof "simple_µ_tac"))
	end handle ex => divert ex "dest_simple_µ" "simple_µ_tac" 28081 []
);
=TEX
=SML
fun Ûintro_µ_tacÝ ((t1, x) : (TERM * TERM)) : TACTIC = (fn (seqasms, conc) =>
	let	val t' = subst[(x, t1)] conc;
	in	if if is_var t1 then not (is_free_in t1 conc) else t' =$ conc
		then	term_fail "intro_µ_tac" 28082 [t1]
		else	([(seqasms, mk_simple_µ(x, t'))],
			(fn [thm] => simple_µ_elim t1 thm | _ => bad_proof "intro_µ_tac"))
	end handle ex => (
		let val area = area_of ex;
		in	if area = "subst" orelse area = "mk_simple_µ"
			then reraise ex "intro_µ_tac" 
			else raise ex
		end
	)
);
=TEX
\subsection{Concerning ¶}
=SML
fun Ûsimple_¶_tacÝ (tm : TERM) : TACTIC = (fn (seqasms, conc) =>
	let	val (x, b) = dest_simple_¶ conc;
	in
		([(seqasms, var_subst[(tm, x)] b)],
		(fn [thm] => simple_¶_intro conc thm | _ => bad_proof "simple_¶_tac"))
	end
	handle ex =>
	case area_of ex of
		"var_subst" => term_fail "simple_¶_tac" 28092 [tm]
	|	"dest_simple_¶" => fail "simple_¶_tac" 28091 []
	|	_ => raise ex
);
=TEX
\section{STRIPPING THEOREMS AND GOALS}
=SML
fun Ûcheck_asm_tacÝ (thm : THM) : TACTIC = (fn gl as (seqasms, conc) =>
	let	val t = concl thm;
	in	if t ~=$ conc
		then accept_tac thm
		else if is_t t
		then id_tac
		else if is_f t
		then f_thm_tac thm
		else if is_³ t
		then	let	val t' = dest_³ t;
				fun aux (asm :: more) = (
					if t ~=$ asm
					then id_tac
					else if asm ~=$ t'
					then accept_tac (³_elim conc (asm_rule asm) thm)
					else if asm ~=$ conc
					then accept_tac (asm_rule asm)
					else aux more
				) | aux [] = asm_tac thm;
			in	aux seqasms
			end
		else	let	fun aux (asm :: more) = (
					if t ~=$ asm
					then id_tac
					else if is_³ asm andalso (dest_³ asm) ~=$ t
					then accept_tac (³_elim conc thm (asm_rule asm))
					else if asm ~=$ conc
					then accept_tac (asm_rule asm)
					else aux more
					) | aux [] = asm_tac thm;
			in	aux seqasms
			end
	end	gl
);
=TEX
=SML
val Ûconcl_in_asms_tacÝ : TACTIC = (fn gl as (seqasms, conc) =>
	if conc term_mem seqasms
	then accept_tac (asm_rule conc) gl
	else fail "concl_in_asms_tac" 28002 []
);
=TEX
We start off with theorem strippers and goal strippers which 
have no values in their parameterisation.

Even if we didn't have the error message, we would still
use the $(fn\ =>\ \ldots)$ form, to prevent
$current\-\_ad\-\_st\-\_conv()$ being evaluated before point of use.
=SML
val ÛSTRIP_THM_THENÝ : THM_TACTICAL = (fn ttac:THM_TACTIC => 
	fn thm :THM =>
	(FIRST_TTCL[CONV_THEN (current_ad_st_conv()),
		±_THEN, 
		²_THEN, 
		SIMPLE_¶_THEN]
	ORELSE_TTCL
		FAIL_WITH_THEN "STRIP_THM_THEN" 28003 
			[fn () => string_of_thm thm])
	ttac
	thm
);
=TEX

Even if we didn't have the error message, we would still
use the $(fn\ =>\ \ldots)$ form, to prevent
$current\-\_ad\-\_sc\- \_conv()$ being evaluated before point of use.
=SML
fun ÛSTRIP_CONCL_TÝ (ttac : THM_TACTIC) : TACTIC = (fn gl =>
	(FIRST[ conv_tac(current_ad_sc_conv()),
		simple_µ_tac,
		±_tac,
		´_T ttac,
		t_tac,
		concl_in_asms_tac]
	ORELSE_T
		fail_with_tac "STRIP_CONCL_T" 28003 
		[fn () => string_of_term(snd gl)])
	gl
);
=TEX
=SML
val Ûstrip_asm_tacÝ : THM_TACTIC =
	REPEAT_TTCL STRIP_THM_THEN check_asm_tac;
=TEX
=SML
val  Ûstrip_tacÝ : TACTIC = (fn gl => 
	STRIP_CONCL_T strip_asm_tac gl
	handle complaint =>
	pass_on complaint "STRIP_CONCL_T" "strip_tac");
=TEX
\subsection{Some Tautologies}
We now give a local context using $¤\_thm$:
=SML
val Ûlocal_strip_thm_thensÝ : EQN_CXT =
	[ (thm_eqn_cxt ¤_thm) ];
=TEX
=SML
val Ûlocal_strip_concl_tsÝ : EQN_CXT =
	[ (thm_eqn_cxt ¤_thm) ];
=TEX
We give some temporary settings to ``propositions'',
before its final setting in this document.
=SML
val _ = new_pc "Û'propositionsÝ";
val _ = set_st_eqn_cxt local_strip_thm_thens "'propositions";
val _ = set_sc_eqn_cxt local_strip_concl_ts "'propositions";
val _ = set_pc "'propositions";
=TEX
We now have some machinery in place with which we can prove the tautologies
need for the tacticals which support $strip\_tac$:
=SML
val Û´_thmÝ = save_thm("´_thm", tac_proof( ([], ¬µa b·(a ´ b) ¤ (³a ² b)®),
	REPEAT strip_tac
	THEN CASES_T ¬a:BOOL® asm_tac THEN_LIST
	[²_right_tac THEN all_asm_ante_tac THEN REPEAT strip_tac,
	 ²_left_tac THEN all_asm_ante_tac THEN REPEAT strip_tac]));
=TEX
=SML
val Û³_³_thmÝ = save_thm("³_³_thm", tac_proof( ([], ¬µa·³ ³a ¤ a®),
		REPEAT strip_tac THEN_LIST
	[accept_tac (³_³_elim (asm_rule ¬³³a®)),
	 accept_tac (³_³_intro (asm_rule ¬a:BOOL®))]));
=TEX
=SML
val Û³_²_thmÝ = save_thm("³_²_thm", tac_proof( ([], ¬µa b·³ (a ² b) ¤ (³a ± ³b)®),
	conv_tac(MAP_C (simple_eq_match_conv ³_thm)) THEN
	REPEAT strip_tac THEN_LIST 
	[LEMMA_T ¬a ² b®(accept_tac o ´_mp_rule (asm_rule ¬a ² b ´ F®)) THEN 
		²_left_tac THEN accept_tac(asm_rule ¬a:BOOL®), 
	LEMMA_T ¬a ² b®(accept_tac o ´_mp_rule (asm_rule ¬a ² b ´ F®)) THEN
		²_right_tac THEN accept_tac(asm_rule ¬b:BOOL®),
	accept_tac(´_mp_rule (asm_rule ¬a ´ F®) (asm_rule ¬a:BOOL®)),
	accept_tac(´_mp_rule (asm_rule ¬b ´ F®) (asm_rule ¬b:BOOL®))] ));
=TEX
The following is not asked for in the detailed design (because it does
not fit into any general framework, or at least we do not provide
the general framework it would fit into --- namely conversion of propositional
terms into the fragment of propositional calculus generated by implication
and falsity (or negation)).

The proof only works for $strip\_tac$ without additional
equational context material.
=SML
val Û²_³_thmÝ = tac_proof( ([], ¬µa b·(a ² ³b) ¤ (b ´ a)®),
	REPEAT strip_tac THEN
	CASES_T ¬a:BOOL® asm_tac THEN_LIST
	[²_left_tac THEN all_asm_ante_tac THEN REPEAT strip_tac,
	²_right_tac THEN accept_tac(modus_tollens_rule(asm_rule¬b ´ a®)(asm_rule¬³a®))]);
=TEX
=SML
val Û³_±_thmÝ = ( (* ô ³(a ± b) ¤ (³a ² ³b) *)
save_thm("³_±_thm",
let	val thm1 = tac_proof( ([], ¬³(a ± b) ¤ (a ´ ³b)®),
	conv_tac(MAP_C (simple_eq_match_conv ³_thm))
	THEN REPEAT strip_tac
	THEN_LIST
	[CASES_T¬a:BOOL® asm_tac
		THEN LEMMA_T ¬a ± b®
		(fn th1 => accept_tac(´_mp_rule(asm_rule¬a ± b ´ F®)(asm_rule¬a ± b®)))
		THEN REPEAT strip_tac,
		accept_tac(´_mp_rule(´_mp_rule(asm_rule¬a ´ b ´ F®)
					(asm_rule¬a:BOOL®))(asm_rule¬b:BOOL®))]);
		val thm2 = tac_proof( ([], ¬(a ´ ³b) ¤ (³a ² ³b)®),
	conv_tac(MAP_C(FIRST_C(map simple_eq_match_conv
	[´_thm, ³_³_thm, ¤_t_intro(refl_conv¬x®)])))
	THEN t_tac);
in	list_simple_µ_intro[¬a:BOOL®, ¬b:BOOL®](eq_trans_rule thm1 thm2)
end));
=TEX
=SML
val Û³_´_thmÝ = save_thm("³_´_thm", tac_proof( ([], ¬µa b·³(a ´ b) ¤ (a ± ³b)®),
	conv_tac(TOP_MAP_C(FIRST_C (map simple_eq_match_conv
		[´_thm, ³_²_thm, ³_³_thm] )))
		THEN REPEAT strip_tac));
=TEX
=SML
val Û³_¤_thmÝ = (* ô µ a b · ³ (a ¤ b) ¤ a ± ³ b ² b ± ³ a  *)
		save_thm("³_¤_thm",
		list_simple_µ_intro[¬a:BOOL®, ¬b:BOOL®]
		((RAND_C(simple_eq_match_conv ¤_thm)
		THEN_C (simple_eq_match_conv ³_±_thm)
		THEN_C (MAP_C(simple_eq_match_conv ³_´_thm)))
		¬³(a ¤ b)®));
=TEX
=SML
val Û³_f_thmÝ = save_thm("³_f_thm", tac_proof( ([], ¬³F ¤ T®),
	¤_t_tac THEN conv_tac (simple_eq_match_conv ³_thm) THEN strip_tac));
=TEX
=SML
val Û³_if_thmÝ = (* ô µ a b c· ³(if a then b else c) ¤ (if a then ³b else ³c)  *)
	save_thm("³_if_thm", 
	list_simple_µ_intro[¬a:BOOL®, ¬b:BOOL®, ¬c:BOOL®]
		(app_if_conv ¬³(if a then b else c)®));
=TEX
\subsection{Additional Conversions, Tactics and Tacticals}
\subsubsection{Concerning ¶$_1$}
=SML
val Ûsimple_¶‰1_convÝ : CONV = (fn tm =>
	let	val (x, b) = dest_simple_¶‰1 tm
		val s1 = ´_intro tm (simple_¶‰1_elim (asm_rule tm));
		val y = variant (x :: frees b) x;
		val conj = mk_±(b, mk_µ(y, mk_´(var_subst[(y, x)]b, mk_eq(y, x))));
		val exi = mk_¶(x, conj)
		val s2 = asm_rule conj;
		val s3 = simple_¶‰1_intro (±_left_elim s2) (±_right_elim s2)
		val s4 = simple_¶_elim x (asm_rule exi) s3
		val s5 = ´_intro exi s4;
	in	¤_intro s1 s5
	end handle ex => pass_on ex "dest_simple_¶‰1" "simple_¶‰1_conv"
);
val Û³_simple_¶‰1_convÝ : CONV = (fn tm =>
	((RAND_C simple_¶‰1_conv THEN_C ³_simple_¶_conv) tm)
	handle  Fail _ => term_fail "³_simple_¶‰1_conv" 28091 [tm]
);
=TEX
\subsubsection{Concerning ³}
This requires proper testing against a ``try along list until fail''.
=SML
local
	val c = eqn_cxt_conv ((map thm_eqn_cxt
		[³_³_thm, ³_±_thm, ³_²_thm, ³_´_thm,
		 ³_¤_thm, ³_if_thm, ³_t_thm, ³_f_thm]) @
		[(¬³(µ x · y)®, ³_simple_µ_conv),
		(¬³(¶ x · y)®, ³_simple_¶_conv),
		(¬³(¶‰1 x · y)®, ³_simple_¶‰1_conv)]);
in
val Ûsimple_³_in_convÝ : CONV = (fn tm =>
	c tm
	handle complaint =>
	divert complaint "eqn_cxt_conv" "simple_³_in_conv" 28131
		[fn () => string_of_term tm]
);
end;
=TEX
=IGN
The following is a ``try along list until fail''
=SML
val Ûsimple_³_in_convÝ : CONV = FIRST_C(
		map simple_eq_match_conv
		[³_³_thm, ³_±_thm, ³_²_thm, ³_´_thm,
		 ³_¤_thm, ³_if_thm, ³_t_thm, ³_f_thm] 
	@	[³_simple_µ_conv, ³_simple_¶_conv, ³_simple_¶‰1_conv])
	ORELSE_C (fn tm => term_fail "simple_³_in_conv" 28131 [tm]);
=IGN
On the following list of test cases the $TRY\_C$ of the net version seems to run at twice the speed.

val test_simple_³_in_conv = [
	¬³ (³ a)®,
	¬³(a ± b)®,
	¬³(a ² b)®,
	¬³(a ´ b)®,
	¬³(a ¤ b)®,
	¬³(if a then b else c)®,
	¬³ T®,
	¬³ F®,
	¬³(µ x · f x y)®,
	¬³(¶ x · f x y)®,
	¬³(¶‰1 x · f x y)®,
	¬x®,
	¬x ± y®,
	¬³ a®,
	¬³ (µ (x,y) · x ± y)®];

Upon the following the net version is 33 times faster.
let
	val tm = ¬f (g x y)®
in
(map (TRY_C simple_³_in_conv) (map (fn _ => tm) (interval 1 1000));())
end;

=SML
val ÛSIMPLE_³_IN_THENÝ : THM_TACTICAL = (fn ttac => fn thm =>
	(ttac(¤_mp_rule(simple_³_in_conv(concl thm))thm))
	handle complaint => 
	divert complaint "simple_³_in_conv" "SIMPLE_³_IN_THEN" 28026 []
);
=TEX
=SML
val Ûsimple_³_in_tacÝ : TACTIC = (fn gl => 
	((conv_tac simple_³_in_conv) gl)
	handle complaint => 
	divert complaint "simple_³_in_conv" "simple_³_in_tac" 28025 []
);
=TEX
\subsubsection{Concerning ´}
=SML
val Û´_THENÝ : THM_TACTICAL = (fn ttac => fn thm =>
	let	val (t1, t2) = dest_´ (concl thm)
	in	ttac(¤_mp_rule(list_simple_µ_elim[t1, t2]´_thm)thm)
	end	handle ex => 
	divert ex "dest_´" "´_THEN" 28054 [fn () => string_of_thm thm]
);
=TEX
\subsubsection{Concerning ²}
=SML
val a_²_³b_thm = ²_³_thm;

val ³a_²_b_thm = list_simple_µ_intro[¬a:BOOL®, ¬b:BOOL®]
	(eq_sym_rule(all_simple_µ_elim ´_thm));

val a_²_b_thm = (
	conv_rule(MAP_C(simple_eq_match_conv ³_³_thm))
	(list_simple_µ_intro[¬a:BOOL®, ¬b:BOOL®]
	(eq_sym_rule(list_simple_µ_elim[¬³a®, ¬b:BOOL®]´_thm)))
);

local
val Û²_convÝ = FIRST_C(map simple_eq_match_conv
	[a_²_³b_thm,
	³a_²_b_thm,
	a_²_b_thm]);
in
val Û²_tacÝ = conv_tac(²_conv);
end;
=TEX
\subsubsection{Concerning if...then...else}
=GFT
ô µ a t1 t2· (if a then t1 else t2) ¤ (a ´ t1) ± (³ a ´ t2)
=TEX
=SML
val Ûlocal_if_thmÝ =  
let	val s1 = asm_rule ¬(a ´ t1) ± (³ a ´ t2)®;
	val s2 = ±_left_elim s1;
	val s3 = ±_right_elim s1;
	val s4 = undisch_rule s2;
	val s5 = undisch_rule s3;
	val s6 = if_intro ¬a:BOOL® s4 s5;
	val s7 = all_´_intro s6;
	val s8 = asm_rule ¬if a then t1 else t2: BOOL®;
	val s9 = if_then_elim s8;
	val s10 = if_else_elim s8;
	val s11 = ±_intro s9 s10;
	val s12 = all_´_intro s11;
	val s13 = ¤_intro s12 s7;
	val s14 = all_µ_intro s13;
in	s14
end;
=TEX
=SML
local	val s1 = refl_conv ¬x:'a®;
	val s2 = ¤_t_intro s1;
	val s3 = app_fun_rule ¬$³® s2;
	val s4 = eq_trans_rule s3 ³_t_thm;
in
val Ûlocal_eq_thm1Ý = simple_µ_intro ¬x:'a® s2;
val Ûlocal_eq_thm2Ý = simple_µ_intro ¬x:'a® s4;
end;
=TEX
\section{Stripping Contexts}
We could expand out the call to $simple\_³\_in\_conv$,
rather than have a two stage discrimination net.
Now extend the build proof contexts (which will be completed and commited in 
\cite{DS/FMU/IED/IMP076}).
The following match the final settings of the relevent fields of
supplied proof context
``propositions''.
=SML
val Ûpropositions_st_eqn_cxtÝ : EQN_CXT =
	[	(thm_eqn_cxt ´_thm),
		(thm_eqn_cxt ¤_thm),
		(thm_eqn_cxt local_if_thm),
		(thm_eqn_cxt local_eq_thm1),
		(thm_eqn_cxt local_eq_thm2),
		(¬¶‰1 x · p®, simple_¶‰1_conv)];
=TEX
=SML
val Ûpropositions_sc_eqn_cxtÝ : EQN_CXT =
	[	(thm_eqn_cxt ¤_thm),
		(thm_eqn_cxt a_²_³b_thm),
		(thm_eqn_cxt ³a_²_b_thm),
		(thm_eqn_cxt a_²_b_thm),
		(thm_eqn_cxt local_eq_thm1),
		(thm_eqn_cxt local_eq_thm2),
		(thm_eqn_cxt local_if_thm)];
=TEX
Now we can set the proof context with its final values for this document.
=SML
val _ = set_st_eqn_cxt propositions_st_eqn_cxt "'propositions";
val _ = set_sc_eqn_cxt propositions_sc_eqn_cxt "'propositions";
=TEX
Now start the build version of proof context ``simple$\-\_$abstractions'', giving something that matched the final
``simple$\-\_$abstractions'' in the given fields.
=SML
val _ = new_pc "Û'simple_abstractionsÝ";
val _ = set_st_eqn_cxt [(¬³ x®, simple_³_in_conv)] "'simple_abstractions";
val _ = set_sc_eqn_cxt [(¬³ x®, simple_³_in_conv)] "'simple_abstractions";
=TEX
Now set the combination.
=SML
val _ = set_merge_pcs ["'propositions",
		"'simple_abstractions"];
=TEX
\subsection{Concerning $if ... then ... else ...$}
=SML
val Ûif_thmÝ = save_thm("if_thm",
	tac_proof( ([],
	¬µ a b c · (if a then b else c) ¤ 
		(a ± b ² ³ a ± c)®),
	REPEAT strip_tac));
=TEX
\section{TAUTOLOGY PROVER}
The tautology prover functions as a limited $strip\_tac$,
but is not an instantiation of it.
The following could perhaps be speeded up by further use of nets.
=SML
local
val Ûtaut_strip_thm_convÝ : CONV = (
	eqn_cxt_conv(
	map thm_eqn_cxt
	[³_³_thm, ³_±_thm, ³_²_thm, ³_´_thm,
	 ³_¤_thm, ³_t_thm, ³_f_thm,
	´_thm, ¤_thm, local_if_thm
]));

val Ûtaut_strip_concl_convÝ : CONV = (
	eqn_cxt_conv(
	map thm_eqn_cxt
	[³_³_thm, ³_±_thm, ³_²_thm, ³_´_thm,
	 ³_¤_thm, ³_t_thm, ³_f_thm,
	¤_thm, local_if_thm,
	a_²_³b_thm, ³a_²_b_thm, a_²_b_thm]
));

val Ûtaut_strip_thm_thensÝ : THM_TACTICAL list = [
	±_THEN,
	²_THEN,
	CONV_THEN taut_strip_thm_conv
];

val Ûtaut_strip_concl_tsÝ : (THM_TACTIC -> TACTIC) list = [
	fn _ => ±_tac,
	´_T,
	fn _ => t_tac,
	fn _ => conv_tac taut_strip_concl_conv,
	fn _ => concl_in_asms_tac
];

val Ûtaut_strip_tacÝ : TACTIC = (
	FIRST
	(map(fn t => t(REPEAT_TTCL (FIRST_TTCL taut_strip_thm_thens) 
			check_asm_tac))
		taut_strip_concl_ts)
);
in
val Ûsimple_taut_tacÝ : TACTIC = (fn gl =>
	case REPEAT taut_strip_tac gl of
		done as ([], _) => done
	|	_ => fail "simple_taut_tac" 28121 []
);
end;
=TEX
The above should be properly compared to an implementation
that doesn't use nets, and one that tries to use them harder.
=IGN
The following is written avoiding nets:
local
val Ûtaut_³_in_convÝ : CONV = FIRST_C(
		map simple_eq_match_conv
		[³_³_thm, ³_±_thm, ³_²_thm, ³_´_thm,
		 ³_¤_thm, ³_t_thm, ³_f_thm]);
val ÛTAUT_³_IN_THENÝ : THM_TACTICAL = (fn ttac => fn thm =>
	ttac(¤_mp_rule(taut_³_in_conv(concl thm))thm)
);
val Ûtaut_strip_thm_thensÝ : THM_TACTICAL list =
	[	±_THEN,
		´_THEN,
		²_THEN,
		TAUT_³_IN_THEN,
		¤_THEN,
		IF_THEN];
val Ûtaut_strip_concl_tsÝ : (THM_TACTIC -> TACTIC) list =
	[fn _ => ±_tac,
		´_T,
		¤_T,
		fn _ => conv_tac taut_³_in_conv,
		fn _ => ²_tac,
		IF_T,
		fn _ => t_tac,
		fn _ => concl_in_asms_tac];

val Ûtaut_strip_tacÝ : TACTIC = 
	FIRST
	(map(fn t => t(REPEAT_TTCL (FIRST_TTCL taut_strip_thm_thens) check_asm_tac))
		taut_strip_concl_ts);
in
val Ûsimple_taut_tac1Ý : TACTIC = (fn gl =>
	case REPEAT taut_strip_tac gl of
		done as ([], _) => done
	|	_ => fail "simple_taut_tac1" 28121 []
);
end;
On the tautologies:

val tm = ¬(a ± b ± c ± d ´ e) ¤ (a ´b ´ c ´ d ´ e)®;
val tm1 = ¬(if a then t1 else t2) ± (if a then t3 else t4) ¤ if a then (t1 ± t3) else (t2 ± t4)®;

the net version runs in roughly a third of the time
of the above.
=TEX
\section{TACTICS FOR THE PREDICATE CALCULUS 2}
We now give the remaining tactics.
\subsection{Concerning $F$}
=SML
fun  ÛCONTR_TÝ (thmtac : THM -> TACTIC) : TACTIC = (fn gl as (seqasms, conc) =>
	let	val ³_conc = mk_³ conc;
		val (sgs, pf) =  (thmtac (asm_rule ³_conc)) (seqasms, mk_f);
		fun rule thm = (
			if ³_conc term_mem (asms thm)
			then c_contr_rule conc thm
			else contr_rule conc thm
		);
	in	(sgs, rule o pf)
	end
	handle ex => divert ex "mk_³" "CONTR_T" 28027 []
);
=TEX
=SML
val Ûcontr_tacÝ : TACTIC = (fn gl =>
	(CONTR_T strip_asm_tac gl)
	handle ex => pass_on ex "CONTR_T" "contr_tac"
);
=TEX
\subsection{Concerning ³}
=SML
fun  Û³_elim_tacÝ (tm : TERM) : TACTIC = (
	if not(type_of tm =: BOOL)
	then term_fail "³_elim_tac" 28022 [tm]
	else	(fn (seqasms, conc) =>
			([(seqasms, tm), (seqasms, mk_³ tm)],
			 fn [th1, th2] => ³_elim conc th1 th2
			 |   _ => bad_proof "³_elim_tac" )
		)
);
=TEX
=SML
fun  Û³_T2Ý (t1 : TERM)
	(thmtac1 : THM -> TACTIC) (thmtac2 : THM -> TACTIC)
		: TACTIC = (fn gl as (seqasms, conc) =>
	let	val t2 = (dest_³ conc)
			handle Fail _ => fail "³_T2" 28023 [];
		val ³_t1 = (mk_³ t1)
			handle Fail _ => term_fail "³_T2" 28022 [t1];
		val (sgs1, pf1) = (thmtac1 (asm_rule t2)) (seqasms, t1);
		val (sgs2, pf2) = (thmtac2 (asm_rule t2)) (seqasms, ³_t1);
		fun rule [thm1, thm2] = ³_intro t2 thm1 thm2
		|   rule _ = bad_proof "³_T2";
	in	(sgs1 @ sgs2, rule o map_shape[(pf1, length sgs1), 
			(pf2, length sgs2)])
	end	
);
=TEX
=SML
fun  Û³_TÝ (t1 : TERM) (thmtac : THM -> TACTIC) : TACTIC = (fn thm =>
	(³_T2 t1 thmtac thmtac thm)
	handle ex => pass_on ex "³_T2" "³_T"
);
=TEX
=SML
fun Û³_tacÝ (t : TERM) : TACTIC = (fn gl =>
	(³_T t strip_asm_tac gl)
	handle ex => pass_on ex "³_T" "³_tac"
);
=TEX
\subsection{Concerning ²}
=SML
val Û²_comm_thmÝ : THM = tac_proof(([], ¬µa b·a ² b ¤ b ² a®), 
	REPEAT strip_tac);
=TEX
=SML
val Ûswap_²_tacÝ : TACTIC = (fn gl =>
	((conv_tac(simple_eq_match_conv ²_comm_thm)) gl)
	handle ex => divert ex "simple_eq_match_conv" "swap_²_tac" 28041 []
);
=TEX
=SML
fun Ûcases_tacÝ (tm : TERM) : TACTIC = (fn gl =>
	(CASES_T tm strip_asm_tac gl)
	handle ex => pass_on ex "CASES_T" "cases_tac"
);
=TEX
\subsection{Concerning ´}
=SML
val Û´_tacÝ : TACTIC = (fn gl =>
	(´_T strip_asm_tac gl)
	handle ex => pass_on ex "´_T" "´_tac"
);
=TEX
\subsection{Concerning ¤}
=SML
fun Û¤_THEN2Ý (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: THM -> TACTIC = (fn thm => 
	let	val (thm1, thm2) = ¤_elim thm;
	in	ttac1 thm1 THEN ttac2 thm2
	end
	handle ex => divert ex "¤_elim" "¤_THEN2" 28062 
		[fn () => string_of_thm thm]
);
=TEX
=SML
fun Û¤_THENÝ (ttac : THM -> TACTIC) : THM -> TACTIC = (fn thm => 
	(¤_THEN2 ttac ttac thm)
	handle ex => pass_on ex "¤_THEN2" "¤_THEN"
);
=TEX
=SML
fun Û¤_T2Ý (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: TACTIC = (fn (seqasms, conc) => 
	let	val (t1, t2) = dest_¤ conc;
		val (sgs1, pf1) = ttac1 (asm_rule t1) (seqasms, t2);
		val (sgs2, pf2) = ttac2 (asm_rule t2) (seqasms, t1);
		fun rule [thm1, thm2] = ¤_intro (´_intro t1 thm1) (´_intro t2 thm2)
		|   rule _ = bad_proof "¤_T2";
	in	(sgs1 @ sgs2, rule o map_shape[(pf1, length sgs1), (pf2, length sgs2)])
	end
	handle ex => divert ex "dest_¤" "¤_T2" 28061 []
);
=TEX
=SML
fun  Û¤_TÝ (ttac : THM -> TACTIC) : TACTIC = (fn thm =>
	(¤_T2 ttac ttac thm)
	handle ex => pass_on ex "¤_T2" "¤_T"
);
=TEX
=SML
val Û¤_tacÝ : TACTIC = (fn gl =>
	(¤_T strip_asm_tac gl)
	handle ex => pass_on ex "¤_T" "¤_tac"
);
=TEX
\subsection{Concerning $if \ldots then \ldots else \ldots$}
=SML
fun ÛIF_THEN2Ý (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: THM -> TACTIC = (fn thm => 
	let	val thm1 = if_then_elim thm;
		val thm2 = if_else_elim thm;
	in	ttac1 thm1 THEN ttac2 thm2
	end
	handle ex => 
	pass_on ex "if_then_elim" "IF_THEN2"
);
=TEX
=SML
fun ÛIF_THENÝ (ttac : THM -> TACTIC) : THM -> TACTIC = (fn thm => 
	(IF_THEN2 ttac ttac thm)
	handle ex => pass_on ex "IF_THEN2" "IF_THEN"
);
=TEX
=SML
fun ÛIF_T2Ý (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC) 
		: TACTIC = (fn (seqasms, conc) =>
	let	val (a, tt, et) = dest_if conc;
		val (tsgs, tpf) = ttac1 (asm_rule a) (seqasms, tt);
		val (esgs, epf) = ttac2 (asm_rule (mk_³ a)) (seqasms, et);
		fun rule [thm1, thm2] = if_intro a thm1 thm2
		|   rule _ = bad_proof "³IF_T2";

	in	(tsgs @ esgs, rule o map_shape[(tpf, length tsgs), (epf, length esgs)])
	end handle ex => divert ex "dest_if" "IF_T2" 28071 []
);
=TEX
=SML
fun  ÛIF_TÝ (ttac : THM -> TACTIC) : TACTIC = (fn thm =>
	(IF_T2 ttac ttac thm)
	handle ex => pass_on ex "IF_T2" "IF_T"
);
=TEX
=SML
val Ûif_tacÝ : TACTIC = (fn gl =>
	(IF_T strip_asm_tac gl)
	handle ex => pass_on ex "IF_T" "if_tac"
);
=TEX
\subsection{Concerning ¶$_1$}
=SML
fun Ûsimple_¶‰1_tacÝ (tm : TERM) : TACTIC = (fn (seqasms, conc) =>
	let	val (x, b) = dest_simple_¶‰1 conc;
		val x' = variant (frees tm) x;
		val b' = var_subst[(x',x)]b;
		val u = mk_µ(x', mk_´(b', mk_eq(x', tm)))
	in
		([(seqasms, var_subst[(tm, x')] b'), (seqasms, u)],
		(fn [th1, th2] => simple_¶‰1_intro th1 th2
		| _ => bad_proof "simple_¶‰1_tac"))
	end
	handle ex =>
	case area_of ex of
		"dest_simple_¶‰1" => fail "simple_¶‰1_tac" 28101 []
	|	"mk_eq" => term_fail "simple_¶‰1_tac" 28092 [tm]
	|	_ => raise ex
);

fun ÛSIMPLE_¶‰1_THENÝ (ttac : THM -> TACTIC) = (fn thm =>
	(SIMPLE_¶_THEN ttac (simple_¶‰1_elim thm))
	handle ex => divert ex "simple_¶‰1_elim" 
		"SIMPLE_¶‰1_THEN" 28102 
		[fn () => string_of_thm thm]
);
=TEX
\subsection{Swapping Assumptions and Conclusions}
=SML
local
	val thm1 = tac_proof(([], ¬µ f · (f ´ F) ¤ ³ f®),
		REPEAT strip_tac);
	val thm2 = tac_proof(([], ¬µ f · ((³ f) ´ F) ¤ f®),
		REPEAT strip_tac);
	val thm3 = tac_proof(([], 
		¬µ f g · (f ´ g) ¤ ((³ f) ² g)®),
		REPEAT strip_tac);
	val thm4 = tac_proof(([], 
		¬µ f g · ((³ f) ´ g) ¤ (f ² g)®),
		REPEAT strip_tac);
	val ´_F_conv = (fn ntm =>
		let	val tm = fst(dest_´ ntm);
		in
			if is_³ tm
			then simple_µ_elim(dest_³ tm) thm2
			else simple_µ_elim tm thm1
		end);
	fun local_conv (tm : TERM) : THM = (
	let	val (d1,d2) = dest_´ tm;
	in
		if d2 =$ mk_f
		then ´_F_conv tm
		else ((fn _ => if is_³ d1
		then list_simple_µ_elim[dest_³ d1, d2] thm4
		else list_simple_µ_elim[d1, d2] thm3)
			THEN_TRY_C (RAND_C local_conv)) tm
	end);
	fun local_tac ([] : THM list) : TACTIC = id_tac
	| local_tac thms = (
	let	val rthms = rev thms;
	in
		MAP_EVERY ante_tac rthms
		THEN conv_tac local_conv
	end);
	
	
in	
=TEX
=SML		
fun  ÛSWAP_ASM_CONCL_TÝ (asm:TERM) (thmtac:THM -> TACTIC) 
	: TACTIC = (
fn gl as (seqasms, conc) =>
let	val ³_conc = mk_³ conc;
	val (sgs, pf) =  ((asm_ante_tac asm THEN
		conv_tac ´_F_conv THEN
		thmtac (asm_rule ³_conc)) (seqasms, mk_f))
		handle complaint =>
		pass_on complaint "asm_ante_tac" "SWAP_ASM_CONCL_T";
	fun rule thm = (
		if ³_conc term_mem (asms thm)
		then c_contr_rule conc thm
		else contr_rule conc thm
	);
in	(sgs, rule o pf)
end
handle complaint => 
divert complaint "mk_³" "SWAP_ASM_CONCL_T" 28027 []
);
=TEX
=SML		
fun  ÛLIST_SWAP_ASM_CONCL_TÝ ([]:TERM list) (thmtac:THM -> TACTIC) 
	: TACTIC = (
	CONTR_T thmtac
) | LIST_SWAP_ASM_CONCL_T lasms thmtac = (
fn gl as (seqasms, conc) =>
let	val ³_conc = mk_³ conc;
	val (sgs, pf) =  ((list_asm_ante_tac lasms THEN
		conv_tac (TRY_C local_conv) THEN
		thmtac (asm_rule ³_conc)) (seqasms, mk_f))
		handle complaint =>
		pass_on complaint "list_asm_ante_tac" "LIST_SWAP_ASM_CONCL_T";
	fun rule thm = (
		if ³_conc term_mem (asms thm)
		then c_contr_rule conc thm
		else contr_rule conc thm
	);
in	(sgs, rule o pf)
end
handle complaint => 
divert complaint "mk_³" "LIST_SWAP_ASM_CONCL_T" 28027 []
);
=TEX
=SML
fun  ÛSWAP_NTH_ASM_CONCL_TÝ (n:int) (thmtac:THM -> TACTIC) : TACTIC = (
fn gl as (seqasms, conc) =>
let	val ³_conc = mk_³ conc;
	val (sgs, pf) =  (((DROP_NTH_ASM_T n ante_tac) THEN
		conv_tac ´_F_conv THEN
		thmtac (asm_rule ³_conc)) (seqasms, mk_f))
		handle complaint =>
		pass_on complaint "DROP_NTH_ASM_T" "SWAP_NTH_ASM_CONCL_T";
	fun rule thm = (
		if ³_conc term_mem (asms thm)
		then c_contr_rule conc thm
		else contr_rule conc thm
	);
in	(sgs, rule o pf)
end
handle complaint => 
divert complaint "mk_³" "SWAP_NTH_ASM_CONCL_T" 28027 []
);
=TEX
=SML		
fun ÛLIST_SWAP_NTH_ASM_CONCL_TÝ ([]:int list) (thmtac:THM -> TACTIC) 
	: TACTIC = (
	CONTR_T thmtac
) | LIST_SWAP_NTH_ASM_CONCL_T ns thmtac = (
fn gl as (seqasms, conc) =>
let	val ³_conc = mk_³ conc;
	val (sgs, pf) =  ((LIST_DROP_NTH_ASM_T ns local_tac THEN
		thmtac (asm_rule ³_conc)) (seqasms, mk_f))
		handle complaint =>
		pass_on complaint "LIST_DROP_NTH_ASM_T" 
			"LIST_SWAP_NTH_ASM_CONCL_T";
	fun rule thm = (
		if ³_conc term_mem (asms thm)
		then c_contr_rule conc thm
		else contr_rule conc thm
	);
in	(sgs, rule o pf)
end
handle complaint => 
divert complaint "mk_³" "LIST_SWAP_NTH_ASM_CONCL_T" 28027 []
);
=TEX
=SML
end;
=TEX
Now the standard forms:
=SML
fun Ûswap_asm_concl_tacÝ (tm : TERM) : TACTIC = (fn gl =>
	SWAP_ASM_CONCL_T tm strip_asm_tac gl
	handle complaint =>
	pass_on complaint "SWAP_ASM_CONCL_T" "swap_asm_concl_tac"
);
fun Ûswap_nth_asm_concl_tacÝ (n : int) : TACTIC = (fn gl =>
	SWAP_NTH_ASM_CONCL_T n strip_asm_tac gl
	handle complaint =>
	pass_on complaint "SWAP_NTH_ASM_CONCL_T" "swap_nth_asm_concl_tac"
);
fun Ûlist_swap_asm_concl_tacÝ (tml : TERM list) : TACTIC = (fn gl =>
	LIST_SWAP_ASM_CONCL_T tml strip_asm_tac gl
	handle complaint =>
	pass_on complaint "LIST_SWAP_ASM_CONCL_T" "list_swap_asm_concl_tac"
);
fun Ûlist_swap_nth_asm_concl_tacÝ (ns : int list) : TACTIC = (fn gl =>
	LIST_SWAP_NTH_ASM_CONCL_T ns strip_asm_tac gl
	handle complaint =>
	pass_on complaint "LIST_SWAP_NTH_ASM_CONCL_T" 
		"list_swap_nth_asm_concl_tac"
);
=TEX
\subsection{$lemma\_tac$}
=SML
fun Ûlemma_tacÝ (sg : TERM) : TACTIC = (fn gl =>
	(LEMMA_T sg strip_asm_tac gl)
	handle ex => pass_on ex "LEMMA_T" "lemma_tac"
);
=TEX
\subsection{Automatic Proof Procedures}
=SML
fun Ûprove_tacÝ (thms: THM list) :  TACTIC = (
let	val ct = current_ad_pr_tac () thms
		handle complaint => 
		pass_on complaint "current_ad_pr_tac" "prove_tac";
in
	DROP_ASMS_T(fn asms =>
	ct
	THEN MAP_EVERY check_asm_tac (rev asms))
end);
=TEX
=SML
val Ûprove_¶_tacÝ : TACTIC = (fn gl =>
	DROP_ASMS_T(fn asms =>
	conv_tac(current_ad_cs_¶_conv ())
	THEN MAP_EVERY check_asm_tac (rev asms)) gl
	handle complaint => 
	pass_on complaint "current_ad_cs_¶_conv" "prove_¶_tac"
);
=TEX

\subsection{End of Structure}
Restore the previous theory:
=SML
val _ = open_theory was_theory;
=TEX
=SML
end; (* of structure Tactics2 *)
open Tactics2;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


