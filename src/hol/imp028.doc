=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation of Tactics II}
\TPPref{DS/FMU/IED/IMP028}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D. Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
first group of tactics and tacticals in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.4 (2 July 1991)]
First draft version.
\item [Issue 1.5 (3 July 1991)]
Fixed $IF\_T$.
\item [Issue 1.9 (12th August 1991)]
Update reflecting issue 1.8 design changes.
\item [Issue 1.10 (\FormatDate{91/08/15%
})]
Renamings of functions containing the name atom $simple$,
and renaming of $aconv$.
\item [Issue 1.11 (25th October 1991)]
Re-implementation of stripping material,
and other changes in response to deskcheck ID0029.
\item [Issue 1.12 (29th October 1991)]
Made $eqn\_cxt\_conv$ ignore ``no change'' conversions.
\item [Issue 1.13 (31st October 1991)]
Changes during testing.
\item [Issue 1.15 (18th November 1991)]
Corrected $C\_CONTR\_T$.
\item [Issue 1.16 (18th November 1991)]
Reacting to issue 1.5/6 of \cite{DS/FMU/IED/DTD051}.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for material
whose detailed design is given in in \cite{DS/FMU/IED/DTD028}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the implementation for the 
second group of tactics and tacticals for ICL HOL.
This group is mainly concerned with supplying support for predicate calculus
connectives (including boolean conditionals but not boolean $let$-expressions).

\subsubsection{Dependencies}
Loading this document is dependent on \cite{DS/FMU/IED/IMP009}
and \cite{DS/FMU/IED/IMP051}.
\subsubsection{Deficiencies}
None known.
\section{PREAMBLE}
=SML
structure ‚Tactics2· : Tactics2 = struct
=TEX
=SML
val ‚was_theory· = get_current_theory_name ();
val _ = open_theory "misc";
=TEX
\section{TACTICALS FOR THE PREDICATE CALCULUS}
The following contain only those parts used in implementing
the stripping material.
\subsection{Concerning Ä}
=SML
fun ‚Ä_THEN2· (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: THM -> TACTIC = (fn thm => 
	let	val thm1 = Ä_left_elim thm;
		val thm2 = Ä_right_elim thm;
	in	ttac1 thm1 THEN ttac2 thm2
	end
	handle ex => divert ex "Ä_left_elim" "Ä_THEN2" 28032 
		[fn () => string_of_thm thm]
);
=TEX
=SML
fun ‚Ä_THEN· (ttac : THM -> TACTIC) : THM -> TACTIC = (fn thm => 
	(Ä_THEN2 ttac ttac thm)
	handle ex => pass_on ex "Ä_THEN2" "Ä_THEN"
);
=TEX
\subsection{Concerning Å}
=TEX
$Å\_LEFT\_T$ and $Å\_RIGHT\_T$ are deferred until we have support
to do them via $ä\_T$.
=SML
fun ‚Å_THEN2· (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: THM -> TACTIC = (fn thm => 
	let	val (t1, t2) = dest_Å(concl thm);
	in	(fn (asms, conc) =>
			let	val (sgs1, pf1) = ttac1 (asm_rule t1) (asms, conc);
				val (sgs2, pf2) = ttac2 (asm_rule t2) (asms, conc);
			in	(sgs1 @ sgs2,
				(fn thl =>
					let	val len = length sgs1;
					in	Å_elim thm (pf1(thl to (len - 1))) (pf2(thl from len))
					end
				))
			end)
	end
	handle ex => divert ex "dest_Å" "Å_THEN2" 28042 
		[fn () => string_of_thm thm]
);
=TEX
=SML
fun ‚Å_THEN· (ttac : THM -> TACTIC) : THM -> TACTIC = Å_THEN2 ttac ttac;
=TEX
=SML
=TEX
=SML
fun ‚CASES_T2· (t1 : TERM) (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
					: TACTIC = (fn gl as (asms, conc) =>
	let	val (sgs1, pf1) = ttac1 (asm_rule t1) (asms, conc);
		val (sgs2, pf2) = ttac2 (asm_rule (mk_å t1)) (asms, conc);
	in	(sgs1 @ sgs2,
		(fn thl =>
			let	val len = length sgs1;
			in	asm_elim t1 (pf1(thl to (len - 1))) (pf2(thl from len))
			end
			))
	end
	handle ex => (
		if area_of ex = "asm_rule"
		then term_fail "CASES_T2" 28022 [t1]
		else raise ex
	)
);
=TEX
=SML
fun ‚CASES_T· (t1 : TERM) (ttac : THM -> TACTIC) : TACTIC = (fn gl =>
	((CASES_T2 t1 ttac ttac) gl)
	handle ex => pass_on ex "CASES_T2" "CASES_T"
);
=TEX
=IGN
fun ‚asm_cases_tac· (t1 : TERM) : TACTIC = (fn gl as (asms, conc) =>
	([(t1 :: asms, conc), (mk_å t1 :: asms, conc)],
	  fn [th1, th2] => asm_elim t1 th1 th2
	 | _ => bad_proof "asm_cases_tac")
	handle ex => divert ex "mk_å" "asm_cases_tac" 28002 []
);
=TEX
\subsection{Concerning ä}
=SML
fun ä_T (ttac : THM -> TACTIC) : TACTIC = (fn (asms, conc) =>
	let	val (t1, t2) = dest_ä conc;
		val (sgs, pf) = ttac (asm_rule t1) (asms, t2);
	in	(sgs, ä_intro t1 o pf)
	end
	handle ex => divert ex "dest_ä" "ä_T" 28051 []
);
=TEX
\subsection{Concerning Ñ}
=SML
fun ‚SIMPLE_Ñ_THEN· (ttac : THM -> TACTIC) = (fn thm =>
	let	val (x, b) = dest_simple_Ñ(concl thm);
	in	(fn (asms, conc) =>
			let	val x' = variant (flat(map frees
					(conc :: concl thm :: hyps thm @ asms))) x;
				val (sgs, pf) = ttac (asm_rule (var_subst[(x', x)] b)) (asms, conc);
			in	(sgs, (simple_Ñ_elim x' thm) o pf)
			end)
	end
	handle ex => divert ex "dest_simple_Ñ" "SIMPLE_Ñ_THEN" 28093 
		[fn () => string_of_thm thm]
);
=TEX
\section{TACTICS FOR THE PREDICATE CALCULUS 1}
We now give the tactics which do not involve $strip\_asm\_tac$. These
will enable us to prove various simple theorems required to set up 
the stripping tacticals.
=TEX
\subsection{Concerning $T$}
=SML
val ‚t_tac· : TACTIC = (fn gl =>
	accept_tac t_thm gl
	handle complaint =>
	divert complaint "accept_tac" "t_tac" 28011 []
);
=TEX
=SML
val ‚Ç_t_tac· : TACTIC = (fn (asms, conc) => 
	let	val (lhs, rhs) = dest_eq conc;
	in	if rhs = mk_t
		then	([(asms, lhs)],
			 fn [th] => Ç_t_intro th | _ => bad_proof "Ç_t_tac")
		else if lhs = mk_t
		then	([(asms, rhs)],
			 fn [th] => eq_sym_rule(Ç_t_intro th) | _ => bad_proof "Ç_t_tac")
		else fail "Ç_t_tac" 28012 []
	end	handle Fail _ => fail "Ç_t_tac" 28012 []
);
=TEX
\subsection{Concerning $F$}
=SML
val ‚contr_tac· : TACTIC = (fn (asms, conc) => 
	([(asms, mk_f)],
	 fn [th] => contr_rule conc th | _ => bad_proof "contr_tac")
);
=TEX
=SML
fun ‚f_thm_tac· (thm : THM) : TACTIC = (fn gl as (_, conc) => 
	let	val thm1 = contr_rule conc thm
	in	accept_tac thm1 gl
	end
	handle	ex => divert ex "contr_rule" "f_thm_tac" 28021 
		[fn () => string_of_thm thm]
);
=TEX
\subsection{Concerning Ä}
=SML
val ‚Ä_tac· : TACTIC = (fn (asms, conc) =>
	let	val (t1, t2) = dest_Ä conc
	in	([(asms, t1), (asms, t2)],
			 fn [th1, th2] => Ä_intro th1 th2
			 |   _ => bad_proof "Ä_tac" )
	end handle ex => divert ex "dest_Ä" "Ä_tac" 28031 []
);
=TEX
\subsection{Concerning Å}
=SML
val  ‚Å_left_tac· : TACTIC = (fn (asms, conc) =>
	let	val (a, b) = dest_Å conc
	in	([(asms, a)],
			 fn [th] => Å_right_intro b th
			 |   _ => bad_proof "Å_left_tac" )
	end handle ex => divert ex "dest_Å" "Å_left_tac" 28041 []
);
=TEX
=SML
val  ‚Å_right_tac· : TACTIC = (fn (asms, conc) =>
	let	val (a, b) = dest_Å conc
	in	([(asms, b)],
			 fn [th] => Å_left_intro a th
			 |   _ => bad_proof "Å_right_tac" )
	end handle ex => divert ex "dest_Å" "Å_right_tac" 28041 []
);
=TEX
\subsection{Concerning Ç}
=SML
val ‚Ç_thm· = ( (* Ö É a b é (a Ç b) Ç (a ä b) Ä (b ä a) *)
save_thm("Ç_thm",
let
	val thm1 = asm_rule ª(a ä b) Ä (b ä a)º; 
	val thm2 = Ç_intro(Ä_left_elim thm1) (Ä_right_elim thm1);
	val (thm3, thm4) = Ç_elim(asm_ruleªa Ç bº);
	val thm5 = Ä_intro thm3 thm4;
in
	list_simple_É_intro[ªa:BOOLº, ªb:BOOLº](Ç_intro(all_ä_intro thm5)(all_ä_intro thm2))
end));
=TEX
\subsection{Concerning ä}
=SML
fun ‚undisch_tac· (t1 : TERM) : TACTIC = (fn (asms, conc) =>
	(if t1 term_mem asms
	then ([(asms term_less t1, mk_ä(t1, conc))],
		(fn [thm] => undisch_rule thm | _ => bad_proof "undisch_tac"))
	else  term_fail "undisch_tac" 28052 [t1])
	handle ex => divert ex "mk_ä" "undisch_tac" 28027 []
);
=TEX
When we undischarge more than one assumption we need to be careful not
to fail if the list of assumptions we are discharging contains repeats
which is allowed with the convention that the repeats are ignored.
=SML
val ‚list_undisch_tac· : TERM list ->  TACTIC = (
	MAP_EVERY (TRY_T o undisch_tac) o rev
);
=TEX
=SML
val ‚all_undisch_tac· :  TACTIC = (
	GET_ASMS_T (MAP_EVERY((TRY_T o undisch_tac) o concl))
);
=TEX
=SML
fun ‚ante_tac· (thm : THM) : TACTIC = (fn (asms, conc) =>
	([(asms, mk_ä(concl thm, conc))],
	 fn [th] => ä_elim th thm | _ => bad_proof "ante_tac")
	handle ex => divert ex "mk_ä" "ante_tac" 28027 []
);
=TEX
\subsection{Concerning É}
=SML
val ‚simple_É_tac· : TACTIC = (fn (asms, conc) =>
	let	val (x, b) = dest_simple_É conc;
		val x' = variant (flat(map frees(conc::asms))) x;
	in
		([(asms, var_subst[(x', x)] b)],
		(fn [thm] => simple_É_intro x' thm | _ => bad_proof "simple_É_tac"))
	end handle ex => divert ex "dest_É" "simple_É_tac" 28081 []
);
=TEX
\subsection{Concerning Ñ}
=TEX
=SML
fun ‚simple_Ñ_tac· (tm : TERM) : TACTIC = (fn (asms, conc) =>
	let	val (x, b) = dest_simple_Ñ conc;
	in
		([(asms, var_subst[(tm, x)] b)],
		(fn [thm] => simple_Ñ_intro conc thm | _ => bad_proof "simple_Ñ_tac"))
	end
	handle ex =>
	case area_of ex of
		"var_subst" => term_fail "simple_Ñ_tac" 28092 [tm]
	|	"dest_simple_Ñ conc" => fail "simple_Ñ_tac" 28091 []
	|	_ => raise ex
);
=TEX
\section{STRIPPING THEOREMS AND GOALS}
=SML
fun ‚check_asm_tac· (thm : THM) : TACTIC = (fn gl as (asms, conc) =>
	let	val t = concl thm;
	in	if %alpha%_eq t conc
		then accept_tac thm
		else if is_t t
		then id_tac
		else if is_f t
		then f_thm_tac thm
		else if is_å t
		then	let	val t' = dest_å t;
				fun aux (asm :: more) = (
					if %alpha%_eq t asm
					then id_tac
					else if %alpha%_eq asm t'
					then accept_tac (å_elim conc (asm_rule asm) thm)
					else if %alpha%_eq asm conc
					then accept_tac (asm_rule asm)
					else aux more
				) | aux [] = asm_tac thm;
			in	aux asms
			end
		else	let	fun aux (asm :: more) = (
					if %alpha%_eq t asm
					then id_tac
					else if is_å asm andalso %alpha%_eq (dest_å asm) t
					then accept_tac (å_elim conc thm (asm_rule asm))
					else if %alpha%_eq asm conc
					then accept_tac (asm_rule asm)
					else aux more
					) | aux [] = asm_tac thm;
			in	aux asms
			end
	end	gl
);
=TEX
=SML
val ‚goal_in_asms_tac· : TACTIC = (fn gl as (asms, conc) =>
	if conc term_mem asms
	then accept_tac (asm_rule conc) gl
	else fail "goal_in_asms_tac" 28002 []
);
=TEX
We start off with theorem strippers and goal strippers which 
have no values in their parameterisation.

Even if we didn't have the error message, we would still
use the $(fn\ =>\ \ldots)$ form, to prevent
$get\_proof\_context()$ being evaluated before point of use.
=SML
val ‚STRIP_THM_THEN· : THM_TACTICAL = (fn ttac:THM_TACTIC => 
	fn thm :THM =>
	(FIRST_TTCL[Ä_THEN, 
		Å_THEN, 
		SIMPLE_Ñ_THEN,
		CONV_THEN (get_epc_st_conv (get_proof_context()))]
	ORELSE_TTCL
		FAIL_WITH_THEN "STRIP_THM_THEN" 28003 
			[fn () => string_of_thm thm])
	ttac
	thm
);
=TEX

Even if we didn't have the error message, we would still
use the $(fn\ =>\ \ldots)$ form, to prevent
$get\_proof\_context()$ being evaluated before point of use.
=SML
fun ‚STRIP_GOAL_T· (ttac : THM_TACTIC) : TACTIC = (fn gl =>
	(FIRST[ simple_É_tac,
		Ä_tac,
		ä_T ttac,
		t_tac,
		conv_tac(get_epc_sg_conv (get_proof_context())),
		goal_in_asms_tac]
	ORELSE_T
		fail_with_tac "STRIP_GOAL_T" 28003 
		[fn () => string_of_term(snd gl)])
	gl
);
=TEX
=SML
val ‚strip_asm_tac· : THM_TACTIC =
	REPEAT_TTCL STRIP_THM_THEN check_asm_tac;
=TEX
=SML
val  ‚strip_tac· : TACTIC = (fn gl => 
	STRIP_GOAL_T strip_asm_tac gl
	handle complaint =>
	pass_on complaint "STRIP_GOAL_T" "strip_tac");
=TEX
\subsection{Some Tautologies}
We now give a local context using $Ç\_thm$:
=SML
val ‚local_strip_thm_thens· : EQN_CXT =
	[ (thm_eqn_cxt Ç_thm) ];
=TEX
=SML
val ‚local_strip_goal_ts· : EQN_CXT =
	[ (thm_eqn_cxt Ç_thm) ];

val ‚local_strip_epc· : EPROOF_CONTEXT =  (
	set_epc_name "local_strip_epc"
	(set_epc_st_conv (eqn_cxt_conv local_strip_thm_thens)
	(set_epc_sg_conv (eqn_cxt_conv local_strip_goal_ts)
	initial_epc))
);
=TEX
Now remove the local proof context, and put the fuller one 
on the stack.
=SML
val _ = push_proof_context local_strip_epc;
=TEX
We now have some machinery in place with which we can prove the tautologies
need for the tacticals which support $strip\_tac$:
=SML
val ‚ä_thm· = save_thm("ä_thm", tac_proof( ([], ªÉa bé(a ä b) Ç (åa Å b)º),
	REPEAT strip_tac
	THEN CASES_T ªa:BOOLº asm_tac THEN_LIST
	[Å_right_tac THEN all_undisch_tac THEN REPEAT strip_tac,
	 Å_left_tac THEN all_undisch_tac THEN REPEAT strip_tac]));
=TEX
=SML
val ‚å_å_thm· = save_thm("å_å_thm", tac_proof( ([], ªÉaéå åa Ç aº),
		REPEAT strip_tac THEN_LIST
	[accept_tac (å_å_elim (asm_rule ªååaº)),
	 accept_tac (å_å_intro (asm_rule ªa:BOOLº))]));
=TEX
=SML
val ‚å_Å_thm· = save_thm("å_Å_thm", tac_proof( ([], ªÉa béå (a Å b) Ç (åa Ä åb)º),
	conv_tac(MAP_C (simple_eq_match_conv å_thm)) THEN
	REPEAT strip_tac THEN_LIST 
	[LEMMA_T ªa Å bº(accept_tac o ä_mp_rule (asm_rule ªa Å b ä Fº)) THEN 
		Å_left_tac THEN accept_tac(asm_rule ªa:BOOLº), 
	LEMMA_T ªa Å bº(accept_tac o ä_mp_rule (asm_rule ªa Å b ä Fº)) THEN
		Å_right_tac THEN accept_tac(asm_rule ªb:BOOLº),
	accept_tac(ä_mp_rule (asm_rule ªa ä Fº) (asm_rule ªa:BOOLº)),
	accept_tac(ä_mp_rule (asm_rule ªb ä Fº) (asm_rule ªb:BOOLº))] ));
=TEX
The following is not asked for in the detailed design (because it does
not fit into any general framework, or at least we do not provide
the general framework it would fit into --- namely conversion of propositional
terms into the fragment of propositional calculus generated by implication
and falsity (or negation)).

The proof only works for $strip\_tac$ without additional
equational context material.
=SML
val ‚Å_å_thm· = tac_proof( ([], ªÉa bé(a Å åb) Ç (b ä a)º),
	REPEAT strip_tac THEN
	CASES_T ªa:BOOLº asm_tac THEN_LIST
	[Å_left_tac THEN all_undisch_tac THEN REPEAT strip_tac,
	Å_right_tac THEN accept_tac(modus_tollens_rule(asm_ruleªb ä aº)(asm_ruleªåaº))]);
=TEX
=SML
val ‚å_Ä_thm· = ( (* Ö å(a Ä b) Ç (åa Å åb) *)
save_thm("å_Ä_thm",
let	val thm1 = tac_proof( ([], ªå(a Ä b) Ç (a ä åb)º),
	conv_tac(MAP_C (simple_eq_match_conv å_thm))
	THEN REPEAT strip_tac
	THEN_LIST
	[CASES_Tªa:BOOLº asm_tac
		THEN LEMMA_T ªa Ä bº
		(fn th1 => accept_tac(ä_mp_rule(asm_ruleªa Ä b ä Fº)(asm_ruleªa Ä bº)))
		THEN REPEAT strip_tac,
		accept_tac(ä_mp_rule(ä_mp_rule(asm_ruleªa ä b ä Fº)
					(asm_ruleªa:BOOLº))(asm_ruleªb:BOOLº))]);
		val thm2 = tac_proof( ([], ª(a ä åb) Ç (åa Å åb)º),
	conv_tac(MAP_C(FIRST_C(map simple_eq_match_conv
	[ä_thm, å_å_thm, Ç_t_intro(refl_convªxº)])))
	THEN t_tac);
in	list_simple_É_intro[ªa:BOOLº, ªb:BOOLº](eq_trans_rule thm1 thm2)
end));
=TEX
=SML
val ‚å_ä_thm· = save_thm("å_ä_thm", tac_proof( ([], ªÉa béå(a ä b) Ç (a Ä åb)º),
	conv_tac(TOP_MAP_C(FIRST_C (map simple_eq_match_conv
		[ä_thm, å_Å_thm, å_å_thm] )))
		THEN REPEAT strip_tac));
=TEX
=SML
val ‚å_Ç_thm· = (* Ö É a b é å (a Ç b) Ç a Ä å b Å b Ä å a  *)
		save_thm("å_Ç_thm",
		list_simple_É_intro[ªa:BOOLº, ªb:BOOLº]
		((RAND_C(simple_eq_match_conv Ç_thm)
		THEN_C (simple_eq_match_conv å_Ä_thm)
		THEN_C (MAP_C(simple_eq_match_conv å_ä_thm)))
		ªå(a Ç b)º));
=TEX
=SML
val ‚å_f_thm· = save_thm("å_f_thm", tac_proof( ([], ªåF Ç Tº),
	Ç_t_tac THEN conv_tac (simple_eq_match_conv å_thm) THEN strip_tac));
=TEX
=SML
val ‚å_if_thm· = (* Ö É a b cé å(if a then b else c) Ç (if a then åb else åc)  *)
	save_thm("å_if_thm", 
	list_simple_É_intro[ªa:BOOLº, ªb:BOOLº, ªc:BOOLº]
		(fun_if_conv ªå(if a then b else c)º));
=TEX
\subsection{Additional Conversions, Tactics and Tacticals}
\subsubsection{Concerning Ñ$_1$}
=SML
val ‚simple_Ñ%down%1_conv· : CONV = (fn tm =>
	let	val (x, b) = dest_simple_Ñ%down%1 tm
		val s1 = ä_intro tm (simple_Ñ%down%1_elim (asm_rule tm));
		val y = variant (x :: frees b) x;
		val conj = mk_Ä(b, mk_É(y, mk_ä(var_subst[(y, x)]b, mk_eq(y, x))));
		val exi = mk_Ñ(x, conj)
		val s2 = asm_rule conj;
		val s3 = simple_Ñ%down%1_intro (Ä_left_elim s2) (Ä_right_elim s2)
		val s4 = simple_Ñ_elim x (asm_rule exi) s3
		val s5 = ä_intro exi s4;
	in	Ç_intro s1 s5
	end handle ex => pass_on ex "dest_simple_Ñ%down%1" "simple_Ñ%down%1_conv"
);
=SML
val ‚simple_å_Ñ%down%1_conv· : CONV = (fn tm =>
	((RAND_C simple_Ñ%down%1_conv THEN_C simple_å_Ñ_conv) tm)
	handle  Fail _ => term_fail "simple_å_Ñ%down%1_conv" 28091 [tm]
);
=TEX
\subsubsection{Concerning å}
This requires proper testing against a ``try along list until fail''.
=SML
local
	val c = eqn_cxt_conv ((map thm_eqn_cxt
		[å_å_thm, å_Ä_thm, å_Å_thm, å_ä_thm,
		 å_Ç_thm, å_if_thm, å_t_thm, å_f_thm]) @
		[(ªå(É x é y)º, simple_å_É_conv),
		(ªå(Ñ x é y)º, simple_å_Ñ_conv),
		(ªå(Ñ%down%1 x é y)º, simple_å_Ñ%down%1_conv)]);
in
val ‚simple_å_in_conv· : CONV = (fn tm =>
	c tm
	handle complaint =>
	divert complaint "eqn_cxt_conv" "simple_å_in_conv" 28131
		[fn () => string_of_term tm]
);
end;
=TEX
=IGN
The following is a ``try along list until fail''
=SML
val ‚simple_å_in_conv· : CONV = FIRST_C(
		map simple_eq_match_conv
		[å_å_thm, å_Ä_thm, å_Å_thm, å_ä_thm,
		 å_Ç_thm, å_if_thm, å_t_thm, å_f_thm] 
	@	[simple_å_É_conv, simple_å_Ñ_conv, simple_å_Ñ%down%1_conv])
	ORELSE_C (fn tm => term_fail "simple_å_in_conv" 28131 [tm]);
=IGN
On the following list of test cases the $TRY\_C$ of the net version seems to run at twice the speed.

val test_simple_å_in_conv = [
	ªå (å a)º,
	ªå(a Ä b)º,
	ªå(a Å b)º,
	ªå(a ä b)º,
	ªå(a Ç b)º,
	ªå(if a then b else c)º,
	ªå Tº,
	ªå Fº,
	ªå(É x é f x y)º,
	ªå(Ñ x é f x y)º,
	ªå(Ñ%down%1 x é f x y)º,
	ªxº,
	ªx Ä yº,
	ªå aº,
	ªå (É (x,y) é x Ä y)º];

Upon the following the net version is 33 times faster.
let
	val tm = ªf (g x y)º
in
(map (TRY_C simple_å_in_conv) (map (fn _ => tm) (interval 1 1000));())
end;

=SML
val ‚SIMPLE_å_IN_THEN· : THM_TACTICAL = (fn ttac => fn thm =>
	(ttac(Ç_mp_rule(simple_å_in_conv(concl thm))thm))
	handle Fail _ => fail "simple_å_in_tac" 28026 []
);
=TEX
=SML
val ‚simple_å_in_tac· : TACTIC = (fn gl => 
	((conv_tac simple_å_in_conv) gl)
	handle Fail _ => fail "simple_å_in_tac" 28025 []
);
=TEX
\subsubsection{Concerning ä}
=SML
val ‚ä_THEN· : THM_TACTICAL = (fn ttac => fn thm =>
	let	val (t1, t2) = dest_ä (concl thm)
	in	ttac(Ç_mp_rule(list_simple_É_elim[t1, t2]ä_thm)thm)
	end	handle ex => 
	divert ex "dest_ä" "ä_THEN" 28054 [fn () => string_of_thm thm]
);
=TEX
\subsubsection{Concerning Å}
=SML
val a_Å_åb_thm = Å_å_thm;

val åa_Å_b_thm = list_simple_É_intro[ªa:BOOLº, ªb:BOOLº]
	(eq_sym_rule(all_simple_É_elim ä_thm));

val a_Å_b_thm = (
	conv_rule(MAP_C(simple_eq_match_conv å_å_thm))
	(list_simple_É_intro[ªa:BOOLº, ªb:BOOLº]
			(eq_sym_rule(list_simple_É_elim[ªåaº, ªb:BOOLº]ä_thm)))
);

local
val ‚Å_conv· = FIRST_C(map simple_eq_match_conv
	[a_Å_åb_thm,
	åa_Å_b_thm,
	a_Å_b_thm]);
in
val ‚Å_tac· = conv_tac(Å_conv);
end;
=TEX
\subsubsection{Concerning if...then...else}
Û
Ö É a t1 t2é (if a then t1 else t2) Ç (a ä t1) Ä (å a ä t2)
Ê
=SML
val ‚local_if_thm· =  
let	val s1 = asm_rule ª(a ä t1) Ä (å a ä t2)º;
	val s2 = Ä_left_elim s1;
	val s3 = Ä_right_elim s1;
	val s4 = undisch_rule s2;
	val s5 = undisch_rule s3;
	val s6 = if_intro ªa:BOOLº s4 s5;
	val s7 = all_ä_intro s6;
	val s8 = asm_rule ªif a then t1 else t2: BOOLº;
	val s9 = if_then_elim s8;
	val s10 = if_else_elim s8;
	val s11 = Ä_intro s9 s10;
	val s12 = all_ä_intro s11;
	val s13 = Ç_intro s12 s7;
	val s14 = all_É_intro s13;
in	s14
end;
=TEX
\section{Stripping Contexts}
We could usefully expand out the call to $simple\_å\_in\_conv$.
=SML
val ‚initial_strip_thm_thens· : EQN_CXT =
	[	(thm_eqn_cxt ä_thm),
		(thm_eqn_cxt Ç_thm),
		(thm_eqn_cxt local_if_thm),
		(ªå xº, simple_å_in_conv),
		(ªÑ%down%1 x é pº, simple_Ñ%down%1_conv)];
=TEX
=SML
val ‚initial_strip_goal_ts· : EQN_CXT =
	[	(thm_eqn_cxt Ç_thm),
		(ªå xº, simple_å_in_conv),
		(thm_eqn_cxt a_Å_åb_thm),
		(thm_eqn_cxt åa_Å_b_thm),
		(thm_eqn_cxt a_Å_b_thm),
		(thm_eqn_cxt local_if_thm)];
=TEX
Now we can declare and set the proof contexts:
=SML
val ‚initial_strip_pc· : PROOF_CONTEXT = (
	set_pc_name "initial_strip_pc"
	(set_pc_st_eqn_cxt initial_strip_thm_thens
	(set_pc_sg_eqn_cxt initial_strip_goal_ts
	initial_pc))
);
val ‚initial_strip_epc· : EPROOF_CONTEXT =  (
	set_epc_name "initial_strip_epc"
	(set_epc_st_conv (eqn_cxt_conv initial_strip_thm_thens)
	(set_epc_sg_conv (eqn_cxt_conv initial_strip_goal_ts)
	initial_epc))
);
val _ = pop_proof_context ();
val _ = push_proof_context initial_strip_epc;
=TEX
\subsection{Concerning $if ... then ... else ...$}
=SML
val ‚if_thm· = save_thm("if_thm",
	tac_proof( ([],
	ªÉ a b c é (if a then b else c) Ç (a Ä b Å å a Ä c)º),
	REPEAT strip_tac));
=TEX
\section{TAUTOLOGY PROVER}
The tautology prover functions as a limited $strip\_tac$,
but is not an instantiation of it.
The following could perhaps be speeded up by further use of nets.
=SML
local
val ‚taut_strip_thm_conv· : CONV = (
	eqn_cxt_conv(
	map thm_eqn_cxt
	[å_å_thm, å_Ä_thm, å_Å_thm, å_ä_thm,
	 å_Ç_thm, å_t_thm, å_f_thm,
	ä_thm, Ç_thm, local_if_thm
]));

val ‚taut_strip_goal_conv· : CONV = (
	eqn_cxt_conv(
	map thm_eqn_cxt
	[å_å_thm, å_Ä_thm, å_Å_thm, å_ä_thm,
	 å_Ç_thm, å_t_thm, å_f_thm,
	Ç_thm, local_if_thm,
	a_Å_åb_thm, åa_Å_b_thm, a_Å_b_thm]
));

val ‚taut_strip_thm_thens· : THM_TACTICAL list = [
	Ä_THEN,
	Å_THEN,
	CONV_THEN taut_strip_thm_conv
];

val ‚taut_strip_goal_ts· : (THM_TACTIC -> TACTIC) list = [
	fn _ => Ä_tac,
	ä_T,
	fn _ => t_tac,
	fn _ => conv_tac taut_strip_goal_conv,
	fn _ => goal_in_asms_tac
];

val ‚taut_strip_tac· : TACTIC = (
	FIRST
	(map(fn t => t(REPEAT_TTCL (FIRST_TTCL taut_strip_thm_thens) check_asm_tac))
		taut_strip_goal_ts)
);
in
val ‚taut_tac· : TACTIC = (fn gl =>
	case REPEAT taut_strip_tac gl of
		done as ([], _) => done
	|	_ => fail "xtaut_tac" 28121 []
);
end;
=TEX
The above should be properly compared to an implementation
that doesn't use nets, and one that tries to use them harder.
=IGN
The following is written avoiding nets:
=IGN
local
val ‚taut_å_in_conv· : CONV = FIRST_C(
		map simple_eq_match_conv
		[å_å_thm, å_Ä_thm, å_Å_thm, å_ä_thm,
		 å_Ç_thm, å_t_thm, å_f_thm]);
val ‚TAUT_å_IN_THEN· : THM_TACTICAL = (fn ttac => fn thm =>
	ttac(Ç_mp_rule(taut_å_in_conv(concl thm))thm)
);
val ‚taut_strip_thm_thens· : THM_TACTICAL list =
	[	Ä_THEN,
		ä_THEN,
		Å_THEN,
		TAUT_å_IN_THEN,
		Ç_THEN,
		IF_THEN];
val ‚taut_strip_goal_ts· : (THM_TACTIC -> TACTIC) list =
	[fn _ => Ä_tac,
		ä_T,
		Ç_T,
		fn _ => conv_tac taut_å_in_conv,
		fn _ => Å_tac,
		IF_T,
		fn _ => t_tac,
		fn _ => goal_in_asms_tac];

val ‚taut_strip_tac· : TACTIC = 
	FIRST
	(map(fn t => t(REPEAT_TTCL (FIRST_TTCL taut_strip_thm_thens) check_asm_tac))
		taut_strip_goal_ts);
in
val ‚taut_tac1· : TACTIC = (fn gl =>
	case REPEAT taut_strip_tac gl of
		done as ([], _) => done
	|	_ => fail "taut_tac" 28121 []
);
end;
=IGN
On the tautologies:

val tm = ª(a Ä b Ä c Ä d ä e) Ç (a äb ä c ä d ä e)º;
val tm1 = ª(if a then t1 else t2) Ä (if a then t3 else t4) Ç if a then (t1 Ä t3) else (t2 Ä t4)º;

the net version runs in roughly a third of the time
of the above.
=TEX
\section{TACTICS FOR THE PREDICATE CALCULUS 2}
We now give the remaining tactics.
\subsection{Concerning $F$}
=SML
fun  ‚C_CONTR_T· (thmtac : THM -> TACTIC) : TACTIC = (fn gl as (asms, conc) =>
	let	val å_conc = mk_å conc;
		val (sgs, pf) =  (thmtac (asm_rule å_conc)) (asms, mk_f);
		fun rule thm = (
			if å_conc term_mem (hyps thm)
			then c_contr_rule conc thm
			else contr_rule conc thm
		);
	in	(sgs, rule o pf)
	end
	handle ex => divert ex "mk_å" "C_CONTR_T" 28027 []
);
=TEX
=SML
val ‚c_contr_tac· : TACTIC = (fn gl =>
	(C_CONTR_T strip_asm_tac gl)
	handle ex => pass_on ex "C_CONTR_T" "c_contr_tac"
);
=TEX
\subsection{Concerning å}
=SML
fun  ‚å_elim_tac· (tm : TERM) : TACTIC = (
	if type_of tm <> BOOL
	then term_fail "å_elim_tac" 28022 [tm]
	else	(fn (asms, conc) =>
			([(asms, tm), (asms, mk_å tm)],
			 fn [th1, th2] => å_elim conc th1 th2
			 |   _ => bad_proof "å_elim_tac" )
		)
);
=TEX
=SML
fun  ‚å_T2· (t1 : TERM)
	(thmtac1 : THM -> TACTIC) (thmtac2 : THM -> TACTIC)
		: TACTIC = (fn gl as (asms, conc) =>
	let	val t2 = (dest_å conc)
			handle Fail _ => fail "å_T2" 28023 [];
		val å_t1 = (mk_å t1)
			handle Fail _ => term_fail "å_T2" 28022 [t1];
		val (sgs1, pf1) = (thmtac1 (asm_rule t2)) (asms, t1);
		val (sgs2, pf2) = (thmtac2 (asm_rule t2)) (asms, å_t1);
		fun rule [thm1, thm2] = å_intro t2 thm1 thm2
		|   rule _ = bad_proof "å_T2";
	in	(sgs1 @ sgs2, rule o mapshape[(pf1, length sgs1), 
			(pf2, length sgs2)])
	end	
);
=TEX
=SML
fun  ‚å_T· (t1 : TERM) (thmtac : THM -> TACTIC) : TACTIC = (fn thm =>
	(å_T2 t1 thmtac thmtac thm)
	handle ex => pass_on ex "å_T2" "å_T"
);
=TEX
=SML
fun ‚å_tac· (t : TERM) : TACTIC = (fn gl =>
	(å_T t strip_asm_tac gl)
	handle ex => pass_on ex "å_T" "å_tac"
);
=TEX
\subsection{Concerning Å}
=SML
val ‚Å_comm_thm· : THM = tac_proof(([], ªÉa béa Å b Ç b Å aº), 
	REPEAT strip_tac);
=TEX
=SML
val ‚swap_Å_tac· : TACTIC = (fn gl =>
	((conv_tac(simple_eq_match_conv Å_comm_thm)) gl)
	handle ex => divert ex "simple_eq_match_conv" "swap_Å_tac" 28041 []
);
=TEX
=SML
fun ‚cases_tac· (tm : TERM) : TACTIC = (fn gl =>
	(CASES_T tm strip_asm_tac gl)
	handle ex => pass_on ex "CASES_T" "cases_tac"
);
=TEX
\subsection{Concerning ä}
=SML
val ‚ä_tac· : TACTIC = (fn gl =>
	(ä_T strip_asm_tac gl)
	handle ex => pass_on ex "ä_T" "ä_tac"
);
=TEX
\subsection{Concerning Ç}
=SML
fun ‚Ç_THEN2· (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: THM -> TACTIC = (fn thm => 
	let	val (thm1, thm2) = Ç_elim thm;
	in	ttac1 thm1 THEN ttac2 thm2
	end
	handle ex => divert ex "Ç_elim" "Ç_THEN2" 28062 
		[fn () => string_of_thm thm]
);
=TEX
=SML
fun ‚Ç_THEN· (ttac : THM -> TACTIC) : THM -> TACTIC = (fn thm => 
	(Ç_THEN2 ttac ttac thm)
	handle ex => pass_on ex "Ç_THEN2" "Ç_THEN"
);
=TEX
=SML
fun ‚Ç_T2· (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: TACTIC = (fn (asms, conc) => 
	let	val (t1, t2) = dest_Ç conc;
		val (sgs1, pf1) = ttac1 (asm_rule t1) (asms, t2);
		val (sgs2, pf2) = ttac2 (asm_rule t2) (asms, t1);
		fun rule [thm1, thm2] = Ç_intro (ä_intro t1 thm1) (ä_intro t2 thm2)
		|   rule _ = bad_proof "Ç_T2";
	in	(sgs1 @ sgs2, rule o mapshape[(pf1, length sgs1), (pf2, length sgs2)])
	end
	handle ex => divert ex "dest_Ç" "Ç_T2" 28061 []
);
=TEX
=SML
fun  ‚Ç_T· (ttac : THM -> TACTIC) : TACTIC = (fn thm =>
	(Ç_T2 ttac ttac thm)
	handle ex => pass_on ex "Ç_T2" "Ç_T"
);
=TEX
=SML
val ‚Ç_tac· : TACTIC = (fn gl =>
	(Ç_T strip_asm_tac gl)
	handle ex => pass_on ex "Ç_tac" "Ç_tac"
);
=TEX
\subsection{Concerning $if \ldots then \ldots else \ldots$}
=SML
fun ‚IF_THEN2· (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC)
						: THM -> TACTIC = (fn thm => 
	let	val thm1 = if_then_elim thm;
		val thm2 = if_else_elim thm;
	in	ttac1 thm1 THEN ttac2 thm2
	end
	handle ex => 
	pass_on ex "if_then_elim" "IF_THEN2"
);
=TEX
=SML
fun ‚IF_THEN· (ttac : THM -> TACTIC) : THM -> TACTIC = (fn thm => 
	(IF_THEN2 ttac ttac thm)
	handle ex => pass_on ex "IF_THEN2" "IF_THEN"
);
=TEX
=SML
fun ‚IF_T2· (ttac1 : THM -> TACTIC) (ttac2 : THM -> TACTIC) 
		: TACTIC = (fn (asms, conc) =>
	let	val (a, tt, et) = dest_if conc;
		val (tsgs, tpf) = ttac1 (asm_rule a) (asms, tt);
		val (esgs, epf) = ttac2 (asm_rule (mk_å a)) (asms, et);
		fun rule [thm1, thm2] = if_intro a thm1 thm2
		|   rule _ = bad_proof "åIF_T2";

	in	(tsgs @ esgs, rule o mapshape[(tpf, length tsgs), (epf, length esgs)])
	end handle ex => divert ex "dest_if" "IF_T2" 28071 []
);
=TEX
=SML
fun  ‚IF_T· (ttac : THM -> TACTIC) : TACTIC = (fn thm =>
	(IF_T2 ttac ttac thm)
	handle ex => pass_on ex "IF_T2" "IF_T"
);
=TEX
=SML
val ‚if_tac· : TACTIC = (fn gl =>
	(IF_T strip_asm_tac gl)
	handle ex => pass_on ex "IF_T" "if_tac"
);
=TEX
\subsection{Concerning Ñ$_1$}
=SML
fun ‚simple_Ñ%down%1_tac· (tm : TERM) : TACTIC = (fn (asms, conc) =>
	let	val (x, b) = dest_simple_Ñ%down%1 conc;
		val u = mk_É(x, mk_ä(b, mk_eq(x, tm)))
	in
		([(asms, var_subst[(tm, x)] b), (asms, u)],
		(fn [th1, th2] => simple_Ñ%down%1_intro th1 th2
		| _ => bad_proof "simple_Ñ%down%1_tac"))
	end
	handle ex =>
	case area_of ex of
		"dest_simple_Ñ%down%1" => fail "simple_Ñ%down%1_tac" 28101 []
	|	"mk_eq conc" => term_fail "simple_Ñ%down%1_tac" 28092 [tm]
	|	_ => raise ex
);

=SML
fun ‚SIMPLE_Ñ%down%1_THEN· (ttac : THM -> TACTIC) = (fn thm =>
	(SIMPLE_Ñ_THEN ttac (simple_Ñ%down%1_elim thm))
	handle ex => divert ex "simple_Ñ%down%1_elim" 
		"SIMPLE_Ñ%down%1_THEN" 28102 
		[fn () => string_of_thm thm]
);
=TEX
\subsection{$lemma\_tac$}
=SML
fun ‚lemma_tac· (sg : TERM) : TACTIC = (fn gl =>
	(LEMMA_T sg strip_asm_tac gl)
	handle ex => pass_on ex "LEMMA_T" "lemma_tac"
);
=TEX
\subsection{End of Structure}
Restore the previous theory:
=SML
val _ = open_theory was_theory;
=TEX
=SML
end; (* of structure Tactics2 *)
open Tactics2;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
