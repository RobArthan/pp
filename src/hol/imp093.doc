% imp093.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Theory of Integers}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP093}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthors{R.D.~Arthan & WIN01\\A.C.~Hayward & WIN01}
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of
the Z Library Numbers and Finiteness and their proof support.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1] Initial Draft.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation
of the Z Library numbers and finiteness, meeting the detailed design
given in \cite{DS/FMU/IED/DTD093}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD093}.
\subsection{Dependencies}

\subsection{Interface}
The interface for the structure is defined by the signature $ú$
(see\cite{DS/FMU/IED/DTD093}).

\subsection{Possible Enhancements}
None known.

\subsection{Deficiencies}
None known.

\section{PROLOGUE}
The structure is split into several pieces to make it small enough for
the Poly/ML compiler. The signature constraint is placed on the
final structure.

The structure wrapping is omitted during initial development:
=SML
(*
structure ÛúÝ = struct
*)
=TEX
=SML
	val dummy = open_theory "ú";
=TEX
\section{ML BINDINGS}
=TEX
Get the definitions:
=SML
(*
	val ú_def = get_spec ñ(ú)®;
	val z_î_def = get_spec ñ(î)®;
	val z_arith_def = get_spec ñ(_ + _)®;
	val z_inequality_def = get_spec ñ(_ < _)®;
	val z_î‰1_def = get_spec ñ(î‰1)®;
	val z_succ_def = get_spec ñ(succ)®;
	val z_iter_def = get_spec ñ(iter)®;
	val z_dots_def = get_spec ñ(_ .. _)®;
	val z_æ_def = get_spec ñ(æ _)®;
	val z_æ‰1_def = get_spec ñ(æ‰1 _)®;
	val z_hash_def = get_spec ñ(#)®;
	val z_Ÿ_def = get_spec ñ(_ Ÿ _)®;
	val z_ž_def = get_spec ñ(_ ž _)®;
	val z_min_def = get_spec ñ(min)®;
	val z_max_def = get_spec ñ(max)®;
	val z'int_def = get_axiom "-" "Z'Int";
*)
=TEX
\section{THEOREMS}
=SML
=SML
val _ = set_pc"hol";
=TEX
=SML
val _ = declare_infix(300, "plus");
val _ = declare_prefix(350, "neg");
=TEX
=SML
val ú_add_ops_exist_thm = (
set_goal([], ¬¶$plus: ú ­ ú ­ ú; $neg: ú ­ ú; iota: î ­ ú·
	(µi j k:ú·
		(i plus j) plus k = i plus (j plus k)
	±	i plus j = j plus i
	±	i plus neg i = iota 0
	±	i plus iota 0 = i)
±	(µm n· iota m plus iota n = iota(m + n))
±	OneOne iota
±	(µi·¶m· i = iota m ² i = neg iota m)®);
a (strip_asm_tac (simple_´_match_mp_rule type_lemmas_thm ú_def));
a(LEMMA_T¬µi·Is_ú_Rep (rep i)® (strip_asm_tac o rewrite_rule[get_spec¬Is_ú_Rep®])
	THEN1 asm_rewrite_tac[]);
a(¶_tac¬
	Ìi j·	abs { (x, y) | ¶m1 n1 m2 n2· (m1, n1)  rep i ± (m2, n2)  rep j ± m1 + m2 + y = n1 + n2 + x }®);
a(¶_tac¬Ìi· abs { (x, y) | (y, x)  rep i }®);
a(¶_tac¬Ìm· abs { (x, y) | ¶k·x = m + y }® THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" (Associativity) *** *)
a(bc_tac[prove_rule[]¬µf x y·x = y ´ f x = f y®]);
a(spec_nth_asm_tac 1 ¬i® THEN POP_ASM_T rewrite_thm_tac);
a(spec_nth_asm_tac 1 ¬j® THEN POP_ASM_T rewrite_thm_tac);
a(spec_nth_asm_tac 1 ¬k® THEN POP_ASM_T rewrite_thm_tac);
a(LEMMA_T ¬µa b c d·Is_ú_Rep {(x, y) | ¶ m1 n1 m2 n2 ·
		a + n1 = b + m1
	±	c + n2 = d + m2
	±	m1 + m2 + y = n1 + n2 + x}® ante_tac);
(* *** Goal "1.1" *** *)
a(rewrite_tac[get_spec¬Is_ú_Rep®]);
a(REPEAT strip_tac);
a(¶_tac¬a + c® THEN ¶_tac¬b + d® THEN PC_T1 "hol2" REPEAT strip_tac);
(* *** Goal "1.1.1" *** *)
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.1.2" *** *)
a(¶_tac¬a® THEN ¶_tac¬b®  THEN ¶_tac¬c®  THEN ¶_tac¬d®);
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(asm_rewrite_tac[] THEN STRIP_T rewrite_thm_tac);
a(rename_tac[] THEN PC_T1 "hol2" REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(¶_tac¬m® THEN ¶_tac¬n® THEN PC_T1 "lin_arith" rewrite_tac[]);
a(¶_tac¬m'+m2® THEN ¶_tac¬n'+n2® THEN PC_T1 "lin_arith" rewrite_tac[]);
a(strip_tac THEN_LIST [id_tac,  PC_T1 "lin_arith" asm_prove_tac[]]);
a(¶_tac¬m'® THEN ¶_tac¬n'®  THEN ¶_tac¬m''® THEN ¶_tac¬n''®
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.2" *** *)
a(¶_tac¬m+m1'® THEN ¶_tac¬n+n1'® THEN PC_T1 "lin_arith" rewrite_tac[]);
a(¶_tac¬m''® THEN ¶_tac¬n''® THEN PC_T1 "lin_arith" rewrite_tac[]);
a(strip_tac THEN_LIST [id_tac,  PC_T1 "lin_arith" asm_prove_tac[]]);
a(¶_tac¬m® THEN ¶_tac¬n®  THEN ¶_tac¬m'® THEN ¶_tac¬n'®
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2" (Commutativity) *** *)
a(bc_tac[prove_rule[]¬µf x y·x = y ´ f x = f y®]);
a(PC_T1 "hol2" REPEAT strip_tac);
(* *** Goal "2.1" (duplicates "2.2") *** *)
a(¶_tac¬m2® THEN ¶_tac¬n2® THEN ¶_tac¬m1®  THEN ¶_tac¬n1®
	THEN REPEAT strip_tac);
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "3" (inverse) *** *)
a(bc_tac[prove_rule[]¬µf x y·x = y ´ f x = f y®]);
a(spec_nth_asm_tac 1 ¬i® THEN POP_ASM_T rewrite_thm_tac);
a(LEMMA_T ¬µa b·Is_ú_Rep { (x, y) | a + x = b + y }® ante_tac);
(* *** Goal "3.1" *** *)
a(rewrite_tac[get_spec¬Is_ú_Rep®]);
a(REPEAT strip_tac);
a(¶_tac¬b® THEN ¶_tac¬a®);
a(conv_tac (LEFT_C (ONCE_MAP_C eq_sym_conv)) THEN strip_tac);
(* *** Goal "3.2" *** *)
a(asm_rewrite_tac[] THEN STRIP_T rewrite_thm_tac);
a(PC_T1 "hol2" REPEAT strip_tac);
(* *** Goal "3.2.1" *** *)
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.2" *** *)
a(¶_tac¬m® THEN ¶_tac¬n® THEN ¶_tac¬n®  THEN ¶_tac¬m®
	THEN PC_T1 "lin_arith" asm_rewrite_tac[]);
(* *** Goal "4" (zero property) *** *)
a(LEMMA_T ¬{(x, y) |¶ m1 n1 m2 n2 ·
		(m1, n1)  rep i
	± (m2, n2)  rep (abs {(x, y)|x = y})
	± m1 + m2 + y = n1 + n2 + x} = rep i® asm_rewrite_thm_tac);
a(spec_nth_asm_tac 1 ¬i® THEN POP_ASM_T rewrite_thm_tac);
a(LEMMA_T ¬µa b·Is_ú_Rep { (x, y) | x = y }® ante_tac);
(* *** Goal "4.1" *** *)
a(rewrite_tac[get_spec¬Is_ú_Rep®]);
a(REPEAT strip_tac);
a(¶_tac¬0® THEN ¶_tac¬0® THEN PC_T1 "hol2" REPEAT strip_tac THEN asm_rewrite_tac[]);
(* *** Goal "4.2" *** *)
a(asm_rewrite_tac[] THEN STRIP_T rewrite_thm_tac);
a(PC_T1 "hol2" REPEAT strip_tac);
(* *** Goal "4.2.1" *** *)
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "4.2.2" *** *)
a(¶_tac¬m® THEN ¶_tac¬n® THEN ¶_tac¬0®  THEN ¶_tac¬0®
	THEN asm_rewrite_tac[]);
(* *** Goal "5" (iota is a monoid homomorphism) *** *)
a(LEMMA_T ¬µa·Is_ú_Rep { (x, y) | x = a + y }® ante_tac);
(* *** Goal "5.1" *** *)
a(rewrite_tac[get_spec¬Is_ú_Rep®]);
a(REPEAT strip_tac);
a(¶_tac¬a® THEN ¶_tac¬0® THEN PC_T1 "hol2" REPEAT strip_tac
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "5.2" *** *)
a(asm_rewrite_tac[] THEN STRIP_T rewrite_thm_tac);
a(bc_tac[prove_rule[]¬µf x y·x = y ´ f x = f y®]);
a(PC_T1 "hol2" REPEAT strip_tac);
(* *** Goal "5.2.1" *** *)
a(PC_T1"lin_arith" asm_prove_tac[]);
(* *** Goal "5.2.2" *** *)
a(¶_tac¬m® THEN ¶_tac¬0® THEN ¶_tac¬n®  THEN ¶_tac¬0®
	THEN PC_T1"lin_arith" asm_prove_tac[]);
(* *** Goal "6" (iota is 1-1) *** *)
a(rewrite_tac[get_spec¬OneOne®] THEN REPEAT strip_tac);
a(LEMMA_T ¬rep(abs{(x, y)|x = x1 + y}) = rep(abs{(x, y)|x = x2 + y})®
	ante_tac THEN1 asm_rewrite_tac[]);
a(LEMMA_T ¬µa·Is_ú_Rep { (x, y) | x = a + y }® ante_tac);
(* *** Goal "6.1" *** *)
a(rewrite_tac[get_spec¬Is_ú_Rep®]);
a(REPEAT strip_tac);
a(¶_tac¬a® THEN ¶_tac¬0® THEN PC_T1 "hol2" REPEAT strip_tac
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "6.2" *** *)
a(GET_NTH_ASM_T 3 rewrite_thm_tac THEN STRIP_T rewrite_thm_tac);
a(PC_T1 "hol2" REPEAT strip_tac);
a(list_spec_nth_asm_tac 1 [¬x1®, ¬0®]);
a(asm_rewrite_tac[]);
(* *** Goal "7" *** *)
a(spec_nth_asm_tac 1 ¬i®);
a(strip_asm_tac(rewrite_rule[get_spec¬1 ¼ 2®]
	(list_µ_elim[¬m®, ¬n®] ¼_cases_thm)));
(* *** Goal "7.1" *** *)
a(¶_tac¬i'® THEN ²_right_tac);
a(LEMMA_T ¬µa·Is_ú_Rep { (x, y) | x = a + y }® ante_tac);
(* *** Goal "7.1.1" *** *)
a(rewrite_tac[get_spec¬Is_ú_Rep®]);
a(REPEAT strip_tac);
a(¶_tac¬a® THEN ¶_tac¬0® THEN PC_T1 "hol2" REPEAT strip_tac
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "7.1.2" *** *)
a(GET_NTH_ASM_T 4 rewrite_thm_tac THEN STRIP_T rewrite_thm_tac);
a(LEMMA_T¬abs(rep i) = abs{(x, y)|m + y = n + x}® ante_tac
	THEN1 GET_NTH_ASM_T 2 rewrite_thm_tac);
a(GET_NTH_ASM_T 5 rewrite_thm_tac);
a(STRIP_T rewrite_thm_tac);
a(bc_tac[prove_rule[]¬µf x y·x = y ´ f x = f y®]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(PC_T1 "lin_arith" rewrite_tac[]);
(* *** Goal "7.2" *** *)
a(¶_tac¬i'® THEN ²_left_tac);
a(LEMMA_T¬abs(rep i) = abs{(x, y)|m + y = n + x}® ante_tac
	THEN1 GET_NTH_ASM_T 2 rewrite_thm_tac);
a(GET_NTH_ASM_T 5 rewrite_thm_tac);
a(STRIP_T rewrite_thm_tac);
a(bc_tac[prove_rule[]¬µf x y·x = y ´ f x = f y®]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(PC_T1 "lin_arith" rewrite_tac[]);
a(conv_tac (LEFT_C(ONCE_MAP_C eq_sym_conv)) THEN strip_tac);
pop_thm()
);
=TEX
=SML
val _ = declare_nonfix"plus";
val _ = declare_nonfix"neg";
=TEX
=SML
val _ = (
push_consistency_goal ¬$+‰Z®;
a(strip_asm_tac ú_add_ops_exist_thm);
a(¶_tac¬($plus, $neg, $iota)®);
a(all_asm_ante_tac THEN taut_tac);
save_consistency_thm ¬$+‰Z® (pop_thm())
);
=TEX
=SML
val ú_plus_comm_thm = (
set_goal([], ¬µi j : ú·i + j = j + i®);
a(REPEAT strip_tac);
a(conv_tac(LEFT_C (once_rewrite_conv[get_spec¬îú®])) THEN rewrite_tac[]);
save_pop_thm"ú_plus_comm_thm"
);
=TEX
=SML
val ú_plus_assoc_thm = (
set_goal([], ¬µi j k: ú·(i + j) + k = i + (j + k)®);
a(REPEAT strip_tac);
a(conv_tac(LEFT_C (once_rewrite_conv[get_spec¬îú®])) THEN rewrite_tac[]);
save_pop_thm"ú_plus_assoc_thm"
);
=TEX
=SML
val ú_plus_assoc_thm1 = (
set_goal([], ¬µi j k: ú·i + (j + k) = (i + j) + k®);
a(rewrite_tac[ú_plus_assoc_thm]);
save_pop_thm"ú_plus_assoc_thm1"
);
=TEX
=SML
val ú_plus_order_thm = (
set_goal([], ¬µi: ú· µ j k: ú·
		j + i = i + j
	±	(i + j) + k = i + (j + k)
	±	j + i + k = i + j + k®);
a(rewrite_tac[ú_plus_assoc_thm]);
a(rewrite_tac[µ_elim¬i:ú®ú_plus_comm_thm]);
a(rewrite_tac[ú_plus_assoc_thm]);
save_pop_thm"ú_plus_order_thm"
);
=TEX
=SML
val ú_cases_thm = (
set_goal([], ¬µi: ú· ¶ m:î·i = îú m ² i = ~(îú m)®);
a(accept_tac(nth 3 (strip_±_rule (get_spec¬îú®))));
save_pop_thm"ú_cases_thm"
);
=TEX
=SML
val ú_plus0_thm = (
set_goal([], ¬µi: ú·i + (îú 0) = i ± (îú 0) + i = i®);
a(µ_tac);
a(rewrite_tac[µ_elim¬îú 0® ú_plus_comm_thm]);
a(rewrite_tac[get_spec¬îú®]);
save_pop_thm"ú_plus0_thm"
);
=TEX
=SML
val ú_plus_minus_thm = (
set_goal([], ¬µi: ú·i + ~ i = îú 0 ± ~i + i = îú 0®);
a(µ_tac);
a(rewrite_tac[µ_elim¬~i® ú_plus_comm_thm]);
a(rewrite_tac[get_spec¬îú®]);
save_pop_thm"ú_plus_minus_thm"
);
=TEX
=SML
val ú_eq_thm = (
set_goal([], ¬µi j: ú·i = j ¤ i + ~j = îú 0®);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[ú_plus_minus_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T ¬(i + ~ j) + j = îú 0 + j® ante_tac THEN1 asm_rewrite_tac[]);
a(rewrite_tac[ú_plus_assoc_thm, ú_plus_minus_thm, ú_plus0_thm]);
save_pop_thm"ú_eq_thm"
);
=TEX
=SML
val îú_plus_homomorphism_thm = (
set_goal([], ¬µm n: î· îú(m + n) = îú m + îú n®);
a(REPEAT strip_tac);
a(conv_tac(RIGHT_C (once_rewrite_conv[get_spec¬îú®])));
a(strip_tac);
save_pop_thm"îú_plus_homomorphism_thm"
);
=TEX
=SML
val ú_minus_clauses = (
set_goal([], ¬µi j: ú·
		~ (~ i) = i
	±	i + ~ i = îú 0
	±	~ i + i = îú 0
	±	~ (i + j) = ~ i + ~ j
	± 	~(îú 0) = (îú 0)®);
a(REPEAT µ_tac);
a(rewrite_tac[ú_plus_minus_thm]);
a(lemma_tac¬µi:ú·~(~ i) = i®);
(* *** Goal "1" *** *)
a(strip_tac THEN once_rewrite_tac[ú_eq_thm]);
a(once_rewrite_tac[ú_plus_comm_thm]);
a(rewrite_tac[ú_plus_minus_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[] THEN strip_tac);
(* *** Goal "2.1" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[ú_eq_thm]);
a(asm_rewrite_tac[µ_elim¬~ j®ú_plus_order_thm]);
a(rewrite_tac[µ_elim¬j®ú_plus_order_thm, ú_plus_minus_thm, ú_plus0_thm]);
(* *** Goal "2.2" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[ú_eq_thm]);
a(asm_rewrite_tac[ú_plus0_thm]);
save_pop_thm"ú_minus_clauses"
);
=TEX
=SML
val ú_cases_thm1 = (
set_goal([], ¬µi: ú· ¶ m:î·i = îú m ² i = ~(îú (m + 1))®);
a(strip_tac);
a(strip_asm_tac(µ_elim¬i® ú_cases_thm));
(* *** Goal "1" *** *)
a(¶_tac¬m® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac(µ_elim¬m®î_cases_thm));
(* *** Goal "2.1" *** *)
a(¶_tac¬0® THEN asm_rewrite_tac[ú_minus_clauses]);
(* *** Goal "2.2" *** *)
a(¶_tac¬i'® THEN asm_rewrite_tac[îú_plus_homomorphism_thm, ú_minus_clauses]);
save_pop_thm"ú_cases_thm1"
);
=TEX
=SML
val ú_induction_thm = (
set_goal([], ¬µp : ú ­ BOOL·
		p (îú 1)
	±	(µi· p i ´ p (~ i))
	±	(µi j· p i ± p j ´ p (i + j))
	´	(µi· p i)
®);
a(REPEAT strip_tac);
a(lemma_tac¬µ m·p (îú m) ± p (~(îú m))®);
(* *** Goal "1" *** *)
a(lemma_tac¬p (îú 0)®);
(* *** Goal "1.1" *** *)
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
a(asm_ante_tac ¬p (îú 1 + ~ (îú 1))®);
a(rewrite_tac[ú_minus_clauses]);
(* *** Goal "1.2" *** *)
a(REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(induction_tac¬m® THEN1 strip_tac);
a(all_asm_fc_tac[]);
a(asm_ante_tac ¬p (îú m + (îú 1))®);
a(rewrite_tac[îú_plus_homomorphism_thm]);
(* *** Goal "1.2.2" *** *)
a(induction_tac¬m® THEN asm_rewrite_tac[ú_minus_clauses, îú_plus_homomorphism_thm]);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac(µ_elim¬i®(nth 3 (strip_±_rule (get_spec¬îú®))))
	THEN asm_rewrite_tac[]);
save_pop_thm"ú_induction_thm"
);
=TEX
=SML
val îú_one_one_thm = (
set_goal([], ¬µm n:î· îú m = îú n ¤ m = n®);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(all_fc_tac[rewrite_rule[one_one_def] (get_spec¬îú®)]);
save_pop_thm"îú_one_one_thm"
);
=TEX
=SML
val ú_plus_clauses = (
set_goal([], ¬µi j k:ú·
		(i + k = j + k ¤ i = j)
	±	(k + i = j + k ¤ i = j)
	±	(i + k = k + j ¤ i = j)
	±	(k + i = k + j ¤ i = j)
	±	(i + k = k ¤ i = îú 0)
	±	(k + i = k ¤ i = îú 0)
	±	(k = k + j ¤ j = îú 0)
	±	(k = j + k ¤ j = îú 0)
	±	(i + îú 0 = i)
	±	(îú 0 + i = i)
	±	³ îú 1 = îú 0
	±	³ îú 0 = îú 1
®);
a(REPEAT µ_tac);
a(rewrite_tac[ú_plus0_thm, îú_one_one_thm, plus_clauses,
	µ_elim¬k® ú_plus_order_thm]);
a(once_rewrite_tac[µ_elim¬k + i® ú_eq_thm]);
a(once_rewrite_tac[µ_elim¬k® ú_eq_thm]);
a(rewrite_tac[ú_minus_clauses, µ_elim¬~ k® ú_plus_order_thm]);
a(rewrite_tac[ú_plus_assoc_thm1, ú_minus_clauses, ú_plus0_thm]);
a(once_rewrite_tac[µ_elim¬i® ú_eq_thm]);
a(rewrite_tac[]);
a(conv_tac(LEFT_C eq_sym_conv));
a(once_rewrite_tac[µ_elim¬îú 0® ú_eq_thm]);
a(rewrite_tac[ú_minus_clauses, ú_plus0_thm]);
save_pop_thm"ú_plus_clauses"
);
=TEX
=SML
val ú_¼_¼_0_thm = (
set_goal([], ¬µi j:ú· i ¼ j ¤ i + ~j ¼ îú 0®);
a(REPEAT µ_tac);
a(rewrite_tac[get_spec¬îú 0 ¼ îú 0®]);
a(once_rewrite_tac[ú_eq_thm]);
a(rewrite_tac[ú_minus_clauses, µ_elim¬~j®ú_plus_order_thm, ú_plus_clauses]);
save_pop_thm"ú_¼_¼_0_thm"
);
=TEX
=SML
val ú_minus_¼_thm = (
set_goal([], ¬µi j:ú· ~i ¼ ~j ¤ j ¼ i®);
a(REPEAT µ_tac);
a(rewrite_tac[get_spec¬îú 0 ¼ îú 0®]);
a(once_rewrite_tac[ú_eq_thm]);
a(rewrite_tac[ú_minus_clauses, µ_elim¬~i®ú_plus_order_thm, ú_plus_clauses]);
a(rewrite_tac[µ_elim¬îú m®ú_plus_order_thm]);
save_pop_thm"ú_minus_¼_thm"
);
=TEX
=SML
val ú_¼_minus_thm = (
set_goal([], ¬µi j:ú· i ¼ j ¤ ~j ¼ ~i®);
a(rewrite_tac[ú_minus_¼_thm]);
save_pop_thm"ú_¼_minus_thm"
);
=TEX
=SML
val ú_¼_clauses = (
set_goal([], ¬µi j k:ú·
		(i + k ¼ j + k ¤ i ¼ j)
	±	(k + i ¼ j + k ¤ i ¼ j)
	±	(i + k ¼ k + j ¤ i ¼ j)
	±	(k + i ¼ k + j ¤ i ¼ j)
	±	(i + k ¼ k ¤ i ¼ îú 0)
	±	(k + i ¼ k ¤ i ¼ îú 0)
	±	(k ¼ k + j ¤ îú 0 ¼ j)
	±	(k ¼ j + k ¤ îú 0 ¼ j)
	±	(i ¼ i)
	±	³ îú 1 ¼ îú 0
	±	îú 0 ¼ îú 1
®);
a(REPEAT µ_tac);
a(rewrite_tac[µ_elim¬k® ú_plus_order_thm]);
a(once_rewrite_tac[µ_elim¬k + i® ú_¼_¼_0_thm]);
a(once_rewrite_tac[µ_elim¬k® ú_¼_¼_0_thm]);
a(rewrite_tac[ú_minus_clauses, µ_elim¬~ k® ú_plus_order_thm]);
a(rewrite_tac[ú_plus_assoc_thm1, ú_minus_clauses, ú_plus0_thm]);
a(once_rewrite_tac[µ_elim¬i® ú_¼_¼_0_thm]);
a(once_rewrite_tac[µ_elim¬îú 0® ú_¼_¼_0_thm]);
a(rewrite_tac[ú_minus_clauses, ú_plus_clauses]);
a(rewrite_tac[get_spec¬îú 0 ¼ îú 0®]);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) îú_plus_homomorphism_thm]);
a(rewrite_tac[ú_plus_clauses, îú_one_one_thm]);
a(conv_tac(ONCE_MAP_C prove_¶_conv));
a(REPEAT strip_tac);
a(¶_tac¬1® THEN rewrite_tac[ú_minus_clauses]);
save_pop_thm"ú_¼_clauses"
);
=TEX
=SML
val îú_¼_thm = (
set_goal([], ¬µm n:î· îú m ¼ îú n ¤ m ¼ n®);
a(REPEAT µ_tac);
a(rewrite_tac[get_spec¬îú 0 ¼ îú 0®, get_spec¬0 ¼ 0®]);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) îú_plus_homomorphism_thm]);
a(rewrite_tac[îú_one_one_thm]);
save_pop_thm"îú_¼_thm"
);
=TEX
=SML
val ú_induction_tac = gen_induction_tac ú_induction_thm;
=TEX
=SML
val ú_times_consistent_thm = (
set_goal([], ¬µi: ú·¶f: ú ­ ú·
		f (îú 1) = i
	±	µj k·f(j + k) = f j + f k®);
a(strip_tac);
a(ú_induction_tac ¬i®);
(* *** Goal "1" *** *)
a(¶_tac¬Ìj·j® THEN rewrite_tac[]);
(* *** Goal "2" *** *)
a(¶_tac¬Ìj·~(f j)® THEN asm_rewrite_tac[ú_minus_clauses]);
(* *** Goal "3" *** *)
a(¶_tac¬Ìj·(f j) + (f' j)® THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(rewrite_tac[µ_elim¬f' j'®ú_plus_order_thm]);
a(rewrite_tac[µ_elim¬f j'®ú_plus_order_thm]);
pop_thm()
);
=TEX
=SML
val _ = (
push_consistency_goal ¬$*‰Z®;
a(prove_¶_tac);
a(strip_tac);
a(strip_asm_tac(µ_elim ¬i'® ú_times_consistent_thm));
a(¶_tac¬f® THEN asm_rewrite_tac[]);
save_consistency_thm ¬$*‰Z® (pop_thm())
);
=TEX
=SML
val ú_times_0_thm1 = (
set_goal([], ¬µi:ú· i * îú 0 = îú 0®);
a(accept_tac(
	all_µ_intro
	(rewrite_rule[ú_plus_clauses, ú_plus0_thm](prove_rule[get_spec¬$*‰Z®]
	¬i*(îú 0 + îú 0) = i * îú 0 + i * îú 0®))));
pop_thm()
);
=TEX
=SML
val îú_times_homomorphism_thm = (
set_goal([], ¬µm n:î· îú (m*n) = îú m * îú n®);
a(REPEAT strip_tac);
a(induction_tac¬n®);
(* *** Goal "1" *** *)
a(rewrite_tac[times_clauses, ú_times_0_thm1]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[times_plus_distrib_thm, get_spec¬$*‰Z®, îú_plus_homomorphism_thm]);
save_pop_thm"ú_times_homomorphism_thm"
);
=TEX
=SML
val ú_times_minus_thm1 = (
set_goal([], ¬µi j:ú· i * ~ j = ~(i * j)®);
a(REPEAT strip_tac);
a(lemma_tac ¬i * ~ j + i * j = îú 0®);
(* *** Goal "1" *** *)
a(LEMMA_T ¬i * ~ j + i * j = i * (~j + j)® rewrite_thm_tac
	THEN1 rewrite_tac[get_spec¬$*‰Z®]);
a(rewrite_tac[ú_minus_clauses, ú_times_0_thm1]);
(* *** Goal "2" *** *)
a(once_rewrite_tac[ú_eq_thm]);
a(asm_rewrite_tac[ú_minus_clauses]);
pop_thm()
);
=TEX
=SML
val ú_times_minus_thm2 = (
set_goal([], ¬µi j:ú· ~ i * j = ~(i * j)®);
a(REPEAT strip_tac);
a(ú_induction_tac¬j® THEN
	asm_rewrite_tac[get_spec¬$*‰Z®, ú_times_minus_thm1, ú_minus_clauses]);
pop_thm()
);
=TEX 
=SML
val ú_times_minus_thm = (
set_goal([], ¬µi j:ú· ~ i * j = ~(i * j) ± i * ~ j = ~(i * j) ± ~ i * ~ j = i * j®);
a(rewrite_tac[ú_times_minus_thm1, ú_times_minus_thm2, ú_minus_clauses]);
save_pop_thm"ú_times_minus_thm"
);
=TEX 
=SML
val ú_times_comm_thm = (
set_goal([], ¬µi j:ú· i * j = j * i®);
a(lemma_tac¬µa b:î·îú a * îú b = îú b * îú a®);
(* *** Goal "1" *** *)
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) îú_times_homomorphism_thm,
	µ_elim¬a:î®times_comm_thm]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¬i® ú_cases_thm) THEN strip_asm_tac(µ_elim¬j® ú_cases_thm)
	THEN POP_ASM_T rewrite_thm_tac THEN POP_ASM_T rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(POP_ASM_T (rewrite_thm_tac o µ_elim ¬m®));
(* *** Goal "2.2" *** *)
a(rewrite_tac[ú_times_minus_thm] THEN POP_ASM_T (rewrite_thm_tac o µ_elim ¬m®));
(* *** Goal "2.3" *** *)
a(rewrite_tac[ú_times_minus_thm] THEN POP_ASM_T (rewrite_thm_tac o µ_elim ¬m®));
(* *** Goal "2.4" *** *)
a(rewrite_tac[ú_times_minus_thm] THEN POP_ASM_T (rewrite_thm_tac o µ_elim ¬m®));
save_pop_thm"ú_times_comm_thm"
);
=TEX 
=SML
val ú_times_assoc_thm = (
set_goal([], ¬µi j k:ú· (i * j) * k  = i * (j * k)®);
a(REPEAT strip_tac);
a(ú_induction_tac ¬k®
	THEN asm_rewrite_tac[ú_times_minus_thm, get_spec¬$*‰Z®]);
save_pop_thm"ú_times_assoc_thm"
);
=TEX
=TEX
=SML
val ú_div_lemma1 = (
set_goal([], ¬µi:ú; n:î· 0 < n ´ ¶d·d * (îú n) ¼ i ± i < (d + îú 1) * îú n®);
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¬i® ú_cases_thm1));
(* *** Goal "1" *** *)
a(¶_tac¬îú (m Div n)® THEN POP_ASM_T rewrite_thm_tac);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) îú_times_homomorphism_thm,
	conv_rule(ONCE_MAP_C eq_sym_conv) îú_plus_homomorphism_thm,
	îú_one_one_thm,
	îú_¼_thm, get_spec¬$<‰Z®]);
a(strip_asm_tac(list_µ_elim[¬m®, ¬n®] div_mod_thm));
a(strip_asm_tac(list_µ_elim[¬m®, ¬n®] mod_less_thm));
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(rewrite_tac[get_spec¬$<‰Z®]);
a(once_rewrite_tac[ú_¼_minus_thm]);
a(¶_tac¬~(îú (m Div n)) + ~(îú 1)®);
a(rewrite_tac[ú_minus_clauses, ú_plus_assoc_thm, ú_plus0_thm]);
a(once_rewrite_tac[prove_rule[ú_times_minus_thm]¬µa b:ú·~ (a * b) = ~a * b®]);
a(rewrite_tac[ú_minus_clauses]);
a(rewrite_tac[îú_plus_homomorphism_thm, ú_plus_assoc_thm,
	ú_minus_clauses, ú_plus_clauses]);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) îú_times_homomorphism_thm,
	conv_rule(ONCE_MAP_C eq_sym_conv) îú_plus_homomorphism_thm,
	îú_one_one_thm,
	îú_¼_thm]);
a(strip_asm_tac(list_µ_elim[¬m®, ¬n®] div_mod_thm));
a(strip_asm_tac(list_µ_elim[¬m®, ¬n®] mod_less_thm));
a(PC_T1 "lin_arith" asm_prove_tac[]);
pop_thm()
);
=TEX
=SML

=SML
val _ = (
push_consistency_goal ¬$Div‰Z®;
a(prove_¶_tac THEN REPEAT strip_tac);
a(strip_asm_tac(µ_elim¬j''® ú_cases_thm1) THEN POP_ASM_T rewrite_thm_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[îú_one_one_thm, pc_rule1"lin_arith"prove_rule[]¬³ m = 0 ¤ 0 < m®]);
a(strip_asm_tac(list_µ_elim[¬i''®, ¬m®]ú_div_lemma1) THEN1 asm_rewrite_tac[]);
a(¶_tac¬i'' + ~ (d * îú m)® THEN ¶_tac ¬d® THEN strip_tac);
a(rewrite_tac[µ_elim¬i''® ú_plus_order_thm, ú_plus_clauses, ú_minus_clauses]);
a(POP_ASM_T (fn _ => id_tac) THEN all_asm_ante_tac);
a(rewrite_tac[get_spec¬$Abs‰Z®, get_spec¬$<‰Z®, îú_¼_thm]);
a(once_rewrite_tac[ú_¼_¼_0_thm]);
a(once_rewrite_tac[ú_times_comm_thm]);
a(rewrite_tac[get_spec¬$*‰Z®, ú_minus_clauses]);
a(rewrite_tac[µ_elim¬îú m * d® ú_plus_order_thm]);
a(rewrite_tac[µ_elim¬~(îú m * d)® ú_plus_order_thm]);
a(rewrite_tac[ú_plus_assoc_thm, ú_plus_clauses]);
a(taut_tac);
(* *** Goal "2" *** *)
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN once_rewrite_tac[ú_eq_thm]);
a(rewrite_tac[ú_plus0_thm, ú_minus_clauses,
	îú_one_one_thm, pc_rule1"lin_arith"prove_rule[]¬³ m = 0 ¤ 0 < m®]);
a(strip_asm_tac(list_µ_elim[¬i''®, ¬m+1®]ú_div_lemma1));
a(¶_tac¬i'' +  (~ d * îú (m+1))® THEN ¶_tac ¬~d®);
a(rewrite_tac[µ_elim¬i''® ú_plus_order_thm, ú_plus_clauses, ú_minus_clauses]);
a(all_asm_ante_tac);
a(rewrite_tac[get_spec¬$Abs‰Z®, get_spec¬$<‰Z®, îú_¼_thm]);
a(rewrite_tac[µ_elim¬îú 0® ú_¼_¼_0_thm,
	ú_minus_clauses, îú_¼_thm, ú_plus0_thm]);
a(rewrite_tac[îú_plus_homomorphism_thm, get_spec¬$*‰Z®]);
a(once_rewrite_tac[ú_times_comm_thm]);
a(rewrite_tac[îú_plus_homomorphism_thm, get_spec¬$*‰Z®]);
a(rewrite_tac[ú_minus_clauses]);
a(once_rewrite_tac[ú_times_comm_thm]);
a(rewrite_tac[get_spec¬$*‰Z®, ú_times_minus_thm]);
a(once_rewrite_tac[ú_¼_¼_0_thm]);
a(rewrite_tac[ú_minus_clauses]);
a(rewrite_tac[ú_plus_assoc_thm, µ_elim¬d * îú m ® ú_plus_order_thm]);
a(rewrite_tac[µ_elim¬~(d * îú m)® ú_plus_order_thm]);
a(rewrite_tac[µ_elim¬~d® ú_plus_order_thm]);
a(rewrite_tac[µ_elim¬d® ú_plus_order_thm]);
a(rewrite_tac[µ_elim¬~(îú m)® ú_plus_order_thm]);
a(rewrite_tac[ú_plus_assoc_thm1, ú_plus_clauses, ú_minus_clauses]);
a(taut_tac);
save_consistency_thm¬$Div‰Z® (pop_thm())
);
=TEX
\section{EPILOG}
=SML
(*
end (* of structure ú *) ;
structure ÛúÝ : ú = ú;
open ú;
*)
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
