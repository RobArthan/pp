=IGN
********************************************************************************
imp093.doc: this file is part of the ProofPower system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% imp093.doc   %Z% $Date: 2000/12/04 17:51:19 $ $Revision: 1.8 $ $RCSfile: imp093.doc,v $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Theory of Integers}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP093}  %% Mandatory field
\def\SCCSversion{$Revision: 1.8 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2000/12/04 17:51:19 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthors{R.D.~Arthan & WIN01\\A.C.~Hayward & WIN01}
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation of
the Z Library Numbers and Finiteness and their proof support.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1] Initial Draft.
\item[Issue 1.4] Minor changes for v1.5 of the DTD.
\item[Issue 1.5] Parent now ``sets'' not ``hol''.
\item[Issue 1.6] Update for SML'97.
\item[Issue 1.7] Update for new INTEGER type.
\item[Issue 1.8] New induction tactics to help with the real numbers.
\item[Issue 1.9] Copyright and banner updates for open source release.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation
of the Z Library numbers and finiteness, meeting the detailed design
given in \cite{DS/FMU/IED/DTD093}.
\subsection{Introduction}
\subsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD093}.
\subsection{Dependencies}

\subsection{Interface}
The interface for the structure is defined by the signature $˙$
(see\cite{DS/FMU/IED/DTD093}).

\subsection{Possible Enhancements}
None known.

\subsection{Deficiencies}
None known.

\section{PROLOGUE}
The structure is split into several pieces to make it small enough for
the Poly/ML compiler. The signature constraint is placed on the
final structure.

The structure wrapping is omitted during initial development:
=SML
structure €˙› = struct
=TEX
=SML
	val dummy = open_theory "˙";
=TEX
\section{ML BINDINGS}
=TEX
Get the definitions:
=SML
	val €Is_˙_Rep_def› = get_spec ¨Is_˙_RepÆ;
	val €˙_Ó˙_def› = get_spec ¨Ó˙Æ;
	val €˙_minus_def› = get_spec ¨$~âZÆ;
	val €˙_plus_def› = get_spec ¨$+âZÆ;
	val €˙_subtract_def› = get_spec ¨$-âZÆ;
	val €˙_times_def› = get_spec ¨$*âZÆ;
	val €˙_º_def› = get_spec ¨$ºâZÆ;
	val €˙_less_def› = get_spec ¨$<âZÆ;
	val €˙_æ_def› = get_spec ¨$æâZÆ;
	val €˙_greater_def› = get_spec ¨$>âZÆ;
	val €˙_abs_def› = get_spec ¨$AbsâZÆ;
	val €˙_mod_def› = get_spec ¨$ModâZÆ;
	val €˙_div_def› = get_spec ¨$DivâZÆ;
=TEX
\section{THEOREMS}
=SML
=SML
val _ = set_merge_pcs["'sets_alg", "basic_hol"];
=TEX
=SML
val _ = declare_infix(300, "plus");
val _ = declare_prefix(350, "neg");
=TEX
=SML
val €˙_add_ops_exist_thm› = (
set_goal([], ¨∂$plus: ˙ ≠ ˙ ≠ ˙; $neg: ˙ ≠ ˙; iota: Ó ≠ ˙∑
	(µi j k:˙∑
		(i plus j) plus k = i plus (j plus k)
	±	i plus j = j plus i
	±	i plus neg i = iota 0
	±	i plus iota 0 = i)
±	(µm n∑ iota m plus iota n = iota(m + n))
±	OneOne iota
±	(µi∑∂m∑ i = iota m ≤ i = neg iota m)Æ);
a (strip_asm_tac (simple_¥_match_mp_rule type_lemmas_thm ˙_def));
a(LEMMA_T¨µi∑Is_˙_Rep (rep i)Æ (strip_asm_tac o rewrite_rule[get_spec¨Is_˙_RepÆ])
	THEN1 asm_rewrite_tac[]);
a(∂_tac¨Ãi j∑	abs { (x, y) | ∂m1 n1 m2 n2 ∑
	(m1, n1) ç rep i ± (m2, n2) ç rep j ± m1 + m2 + y = n1 + n2 + x }Æ);
a(∂_tac¨Ãi∑ abs { (x, y) | (y, x) ç rep i }Æ);
a(∂_tac¨Ãm∑ abs { (x, y) | ∂k∑x = m + y }Æ THEN rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" (Associativity) *** *)
a(bc_tac[prove_rule[]¨µf x y∑x = y ¥ f x = f yÆ]);
a(spec_nth_asm_tac 1 ¨iÆ THEN POP_ASM_T rewrite_thm_tac);
a(spec_nth_asm_tac 1 ¨jÆ THEN POP_ASM_T rewrite_thm_tac);
a(spec_nth_asm_tac 1 ¨kÆ THEN POP_ASM_T rewrite_thm_tac);
a(LEMMA_T ¨µa b c d∑Is_˙_Rep {(x, y) | ∂ m1 n1 m2 n2 ∑
		a + n1 = b + m1
	±	c + n2 = d + m2
	±	m1 + m2 + y = n1 + n2 + x}Æ ante_tac);
(* *** Goal "1.1" *** *)
a(rewrite_tac[get_spec¨Is_˙_RepÆ]);
a(REPEAT strip_tac);
a(∂_tac¨a + cÆ THEN ∂_tac¨b + dÆ THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1.1.1" *** *)
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.1.2" *** *)
a(∂_tac¨aÆ THEN ∂_tac¨bÆ  THEN ∂_tac¨cÆ  THEN ∂_tac¨dÆ);
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.2" *** *)
a(asm_rewrite_tac[] THEN STRIP_T rewrite_thm_tac);
a(rename_tac[] THEN PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(∂_tac¨mÆ THEN ∂_tac¨nÆ THEN PC_T1 "lin_arith" rewrite_tac[]);
a(∂_tac¨m'+m2Æ THEN ∂_tac¨n'+n2Æ THEN PC_T1 "lin_arith" rewrite_tac[]);
a(strip_tac THEN_LIST [id_tac,  PC_T1 "lin_arith" asm_prove_tac[]]);
a(∂_tac¨m'Æ THEN ∂_tac¨n'Æ  THEN ∂_tac¨m''Æ THEN ∂_tac¨n''Æ
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "1.2.2" *** *)
a(∂_tac¨m+m1'Æ THEN ∂_tac¨n+n1'Æ THEN PC_T1 "lin_arith" rewrite_tac[]);
a(∂_tac¨m''Æ THEN ∂_tac¨n''Æ THEN PC_T1 "lin_arith" rewrite_tac[]);
a(strip_tac THEN_LIST [id_tac,  PC_T1 "lin_arith" asm_prove_tac[]]);
a(∂_tac¨mÆ THEN ∂_tac¨nÆ  THEN ∂_tac¨m'Æ THEN ∂_tac¨n'Æ
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2" (Commutativity) *** *)
a(bc_tac[prove_rule[]¨µf x y∑x = y ¥ f x = f yÆ]);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "2.1" (duplicates "2.2") *** *)
a(∂_tac¨m2Æ THEN ∂_tac¨n2Æ THEN ∂_tac¨m1Æ  THEN ∂_tac¨n1Æ
	THEN REPEAT strip_tac);
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "3" (inverse) *** *)
a(bc_tac[prove_rule[]¨µf x y∑x = y ¥ f x = f yÆ]);
a(spec_nth_asm_tac 1 ¨iÆ THEN POP_ASM_T rewrite_thm_tac);
a(LEMMA_T ¨µa b∑Is_˙_Rep { (x, y) | a + x = b + y }Æ ante_tac);
(* *** Goal "3.1" *** *)
a(rewrite_tac[get_spec¨Is_˙_RepÆ]);
a(REPEAT strip_tac);
a(∂_tac¨bÆ THEN ∂_tac¨aÆ);
a(conv_tac (LEFT_C (ONCE_MAP_C eq_sym_conv)) THEN strip_tac);
(* *** Goal "3.2" *** *)
a(asm_rewrite_tac[] THEN STRIP_T rewrite_thm_tac);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "3.2.1" *** *)
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "3.2.2" *** *)
a(∂_tac¨mÆ THEN ∂_tac¨nÆ THEN ∂_tac¨nÆ  THEN ∂_tac¨mÆ
	THEN PC_T1 "lin_arith" asm_rewrite_tac[]);
(* *** Goal "4" (zero property) *** *)
a(LEMMA_T ¨{(x, y) |∂ m1 n1 m2 n2 ∑
		(m1, n1) ç rep i
	± (m2, n2) ç rep (abs {(x, y)|x = y})
	± m1 + m2 + y = n1 + n2 + x} = rep iÆ asm_rewrite_thm_tac);
a(spec_nth_asm_tac 1 ¨iÆ THEN POP_ASM_T rewrite_thm_tac);
a(LEMMA_T ¨µa b∑Is_˙_Rep { (x, y) | x = y }Æ ante_tac);
(* *** Goal "4.1" *** *)
a(rewrite_tac[get_spec¨Is_˙_RepÆ]);
a(REPEAT strip_tac);
a(∂_tac¨0Æ THEN ∂_tac¨0Æ THEN MERGE_PCS_T1 ["sets_ext1", "basic_hol1"] REPEAT strip_tac
	THEN asm_rewrite_tac[]);
(* *** Goal "4.2" *** *)
a(asm_rewrite_tac[] THEN STRIP_T rewrite_thm_tac);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "4.2.1" *** *)
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "4.2.2" *** *)
a(∂_tac¨mÆ THEN ∂_tac¨nÆ THEN ∂_tac¨0Æ  THEN ∂_tac¨0Æ
	THEN asm_rewrite_tac[]);
(* *** Goal "5" (iota is a monoid homomorphism) *** *)
a(LEMMA_T ¨µa∑Is_˙_Rep { (x, y) | x = a + y }Æ ante_tac);
(* *** Goal "5.1" *** *)
a(rewrite_tac[get_spec¨Is_˙_RepÆ]);
a(REPEAT strip_tac);
a(∂_tac¨aÆ THEN ∂_tac¨0Æ THEN PC_T1 "sets_ext1" REPEAT strip_tac
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "5.2" *** *)
a(asm_rewrite_tac[] THEN STRIP_T rewrite_thm_tac);
a(bc_tac[prove_rule[]¨µf x y∑x = y ¥ f x = f yÆ]);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
(* *** Goal "5.2.1" *** *)
a(PC_T1"lin_arith" asm_prove_tac[]);
(* *** Goal "5.2.2" *** *)
a(∂_tac¨mÆ THEN ∂_tac¨0Æ THEN ∂_tac¨nÆ  THEN ∂_tac¨0Æ
	THEN PC_T1"lin_arith" asm_prove_tac[]);
(* *** Goal "6" (iota is 1-1) *** *)
a(rewrite_tac[get_spec¨OneOneÆ] THEN REPEAT strip_tac);
a(LEMMA_T ¨rep(abs{(x, y)|x = x1 + y}) = rep(abs{(x, y)|x = x2 + y})Æ
	ante_tac THEN1 asm_rewrite_tac[]);
a(LEMMA_T ¨µa∑Is_˙_Rep { (x, y) | x = a + y }Æ ante_tac);
(* *** Goal "6.1" *** *)
a(rewrite_tac[get_spec¨Is_˙_RepÆ]);
a(REPEAT strip_tac);
a(∂_tac¨aÆ THEN ∂_tac¨0Æ THEN PC_T1 "sets_ext1" REPEAT strip_tac
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "6.2" *** *)
a(GET_NTH_ASM_T 3 rewrite_thm_tac THEN STRIP_T rewrite_thm_tac);
a(PC_T1 "sets_ext1" REPEAT strip_tac);
a(list_spec_nth_asm_tac 1 [¨x1Æ, ¨0Æ]);
a(asm_rewrite_tac[]);
(* *** Goal "7" *** *)
a(spec_nth_asm_tac 1 ¨iÆ);
a(strip_asm_tac(rewrite_rule[get_spec¨1 º 2Æ]
	(list_µ_elim[¨mÆ, ¨nÆ] º_cases_thm)));
(* *** Goal "7.1" *** *)
a(∂_tac¨i'Æ THEN ≤_right_tac);
a(LEMMA_T ¨µa∑Is_˙_Rep { (x, y) | x = a + y }Æ ante_tac);
(* *** Goal "7.1.1" *** *)
a(rewrite_tac[get_spec¨Is_˙_RepÆ]);
a(REPEAT strip_tac);
a(∂_tac¨aÆ THEN ∂_tac¨0Æ THEN PC_T1 "sets_ext1" REPEAT strip_tac
	THEN PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "7.1.2" *** *)
a(GET_NTH_ASM_T 4 rewrite_thm_tac THEN STRIP_T rewrite_thm_tac);
a(LEMMA_T¨abs(rep i) = abs{(x, y)|m + y = n + x}Æ ante_tac
	THEN1 GET_NTH_ASM_T 2 rewrite_thm_tac);
a(GET_NTH_ASM_T 5 rewrite_thm_tac);
a(STRIP_T rewrite_thm_tac);
a(bc_tac[prove_rule[]¨µf x y∑x = y ¥ f x = f yÆ]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(PC_T1 "lin_arith" rewrite_tac[]);
(* *** Goal "7.2" *** *)
a(∂_tac¨i'Æ THEN ≤_left_tac);
a(LEMMA_T¨abs(rep i) = abs{(x, y)|m + y = n + x}Æ ante_tac
	THEN1 GET_NTH_ASM_T 2 rewrite_thm_tac);
a(GET_NTH_ASM_T 5 rewrite_thm_tac);
a(STRIP_T rewrite_thm_tac);
a(bc_tac[prove_rule[]¨µf x y∑x = y ¥ f x = f yÆ]);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(PC_T1 "lin_arith" rewrite_tac[]);
a(conv_tac (LEFT_C(ONCE_MAP_C eq_sym_conv)) THEN strip_tac);
pop_thm()
);
=TEX
=SML
val _ = declare_nonfix"plus";
val _ = declare_nonfix"neg";
=TEX
=SML
val _ = (
push_consistency_goal ¨$+âZÆ;
a(strip_asm_tac ˙_add_ops_exist_thm);
a(∂_tac¨($plus, $neg, $iota)Æ);
a(all_asm_ante_tac THEN taut_tac);
save_consistency_thm ¨$+âZÆ (pop_thm())
);
=TEX
=SML
val €˙_plus_comm_thm› = (
set_goal([], ¨µ i j : ˙ ∑ i + j = j + iÆ);
a(REPEAT strip_tac);
a(conv_tac(LEFT_C (once_rewrite_conv[get_spec¨Ó˙Æ])) THEN rewrite_tac[]);
save_pop_thm"˙_plus_comm_thm"
);
=TEX
=SML
val €˙_plus_assoc_thm› = (
set_goal([], ¨µ i j k : ˙ ∑ (i + j) + k = i + j + kÆ);
a(REPEAT strip_tac);
a(conv_tac(LEFT_C (once_rewrite_conv[get_spec¨Ó˙Æ])) THEN rewrite_tac[]);
save_pop_thm"˙_plus_assoc_thm"
);
=TEX
=SML
val €˙_plus_assoc_thm1› = (
set_goal([], ¨µ i j k: ˙ ∑ i + j + k = (i + j) + kÆ);
a(rewrite_tac[˙_plus_assoc_thm]);
save_pop_thm"˙_plus_assoc_thm1"
);
=TEX
=SML
val €˙_plus_order_thm› = (
set_goal([], ¨µ i j k : ˙ ∑ j + i = i + j
		± (i + j) + k = i + j + k
		± j + i + k = i + j + kÆ);
a(rewrite_tac[˙_plus_assoc_thm]);
a(rewrite_tac[µ_elim¨i:˙Æ˙_plus_comm_thm]);
a(rewrite_tac[˙_plus_assoc_thm]);
save_pop_thm"˙_plus_order_thm"
);
=TEX
=SML
val €˙_cases_thm› = (
set_goal([], ¨µ i : ˙ ∑ ∂ m : Ó ∑ i = Ó˙ m ≤ i = ~(Ó˙ m)Æ);
a(accept_tac(nth 3 (strip_±_rule (get_spec¨Ó˙Æ))));
save_pop_thm"˙_cases_thm"
);
=TEX
=SML
val €˙_plus0_thm› = (
set_goal([], ¨µ i : ˙ ∑ i + (Ó˙ 0) = i ± (Ó˙ 0) + i = iÆ);
a(µ_tac);
a(rewrite_tac[µ_elim¨Ó˙ 0Æ ˙_plus_comm_thm]);
a(rewrite_tac[get_spec¨Ó˙Æ]);
save_pop_thm"˙_plus0_thm"
);
=TEX
=SML
val €˙_plus_minus_thm› = (
set_goal([], ¨µ i : ˙ ∑ i + ~ i = Ó˙ 0 ± ~i + i = Ó˙ 0Æ);
a(µ_tac);
a(rewrite_tac[µ_elim¨~iÆ ˙_plus_comm_thm]);
a(rewrite_tac[get_spec¨Ó˙Æ]);
save_pop_thm"˙_plus_minus_thm"
);
=TEX
=SML
val €˙_eq_thm› = (
set_goal([], ¨µ i j : ˙ ∑ i = j § i + ~j = Ó˙ 0Æ);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[˙_plus_minus_thm]);
(* *** Goal "2" *** *)
a(LEMMA_T ¨(i + ~ j) + j = Ó˙ 0 + jÆ ante_tac THEN1 asm_rewrite_tac[]);
a(rewrite_tac[˙_plus_assoc_thm, ˙_plus_minus_thm, ˙_plus0_thm]);
save_pop_thm"˙_eq_thm"
);
=TEX
=SML
val €Ó˙_plus_homomorphism_thm› = (
set_goal([], ¨µ m n : Ó ∑ Ó˙(m + n) = Ó˙ m + Ó˙ nÆ);
a(REPEAT strip_tac);
a(conv_tac(RIGHT_C (once_rewrite_conv[get_spec¨Ó˙Æ])));
a(strip_tac);
save_pop_thm"Ó˙_plus_homomorphism_thm"
);
=TEX
=SML
val €˙_minus_clauses› = (
set_goal([], ¨µi j: ˙∑
		~ (~ i) = i
	±	i + ~ i = Ó˙ 0
	±	~ i + i = Ó˙ 0
	±	~ (i + j) = ~ i + ~ j
	± 	~(Ó˙ 0) = (Ó˙ 0)Æ);
a(REPEAT µ_tac);
a(rewrite_tac[˙_plus_minus_thm]);
a(lemma_tac¨µi:˙∑~(~ i) = iÆ);
(* *** Goal "1" *** *)
a(strip_tac THEN once_rewrite_tac[˙_eq_thm]);
a(once_rewrite_tac[˙_plus_comm_thm]);
a(rewrite_tac[˙_plus_minus_thm]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[] THEN strip_tac);
(* *** Goal "2.1" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[˙_eq_thm]);
a(asm_rewrite_tac[µ_elim¨~ jÆ˙_plus_order_thm]);
a(rewrite_tac[µ_elim¨jÆ˙_plus_order_thm, ˙_plus_minus_thm, ˙_plus0_thm]);
(* *** Goal "2.2" *** *)
a(conv_tac eq_sym_conv THEN once_rewrite_tac[˙_eq_thm]);
a(asm_rewrite_tac[˙_plus0_thm]);
save_pop_thm"˙_minus_clauses"
);
=TEX
=SML
val €˙_cases_thm1› = (
set_goal([], ¨µ i : ˙ ∑ ∂ m : Ó ∑ i = Ó˙ m ≤ i = ~(Ó˙ (m + 1))Æ);
a(strip_tac);
a(strip_asm_tac(µ_elim¨iÆ ˙_cases_thm));
(* *** Goal "1" *** *)
a(∂_tac¨mÆ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac(µ_elim¨mÆÓ_cases_thm));
(* *** Goal "2.1" *** *)
a(∂_tac¨0Æ THEN asm_rewrite_tac[˙_minus_clauses]);
(* *** Goal "2.2" *** *)
a(∂_tac¨i'Æ THEN asm_rewrite_tac[Ó˙_plus_homomorphism_thm, ˙_minus_clauses]);
save_pop_thm"˙_cases_thm1"
);
=TEX
=SML
val €˙_induction_thm› = (
set_goal([], ¨µ p : ˙ ≠ BOOL ∑ p (Ó˙ 1)
	±	(µi∑ p i ¥ p (~ i))
	±	(µi j∑ p i ± p j ¥ p (i + j))
	¥	(µi∑ p i) Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µ m∑p (Ó˙ m) ± p (~(Ó˙ m))Æ);
(* *** Goal "1" *** *)
a(lemma_tac¨p (Ó˙ 0)Æ);
(* *** Goal "1.1" *** *)
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
a(asm_ante_tac ¨p (Ó˙ 1 + ~ (Ó˙ 1))Æ);
a(rewrite_tac[˙_minus_clauses]);
(* *** Goal "1.2" *** *)
a(REPEAT strip_tac);
(* *** Goal "1.2.1" *** *)
a(induction_tac¨mÆ THEN1 strip_tac);
a(all_asm_fc_tac[]);
a(asm_ante_tac ¨p (Ó˙ m + (Ó˙ 1))Æ);
a(rewrite_tac[Ó˙_plus_homomorphism_thm]);
(* *** Goal "1.2.2" *** *)
a(induction_tac¨mÆ THEN asm_rewrite_tac[˙_minus_clauses, Ó˙_plus_homomorphism_thm]);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac(µ_elim¨iÆ(nth 3 (strip_±_rule (get_spec¨Ó˙Æ))))
	THEN asm_rewrite_tac[]);
save_pop_thm"˙_induction_thm"
);
=TEX
=SML
val €Ó˙_one_one_thm› = (
set_goal([], ¨µm n:Ó∑ Ó˙ m = Ó˙ n § m = nÆ);
a(REPEAT strip_tac THEN_TRY asm_rewrite_tac[]);
a(all_fc_tac[rewrite_rule[one_one_def] (get_spec¨Ó˙Æ)]);
save_pop_thm"Ó˙_one_one_thm"
);
=TEX
=SML
val €˙_plus_clauses› = (
set_goal([], ¨µ i j k : ˙ ∑ (i + k = j + k § i = j)
	±	(k + i = j + k § i = j)
	±	(i + k = k + j § i = j)
	±	(k + i = k + j § i = j)
	±	(i + k = k § i = Ó˙ 0)
	±	(k + i = k § i = Ó˙ 0)
	±	(k = k + j § j = Ó˙ 0)
	±	(k = j + k § j = Ó˙ 0)
	±	(i + Ó˙ 0 = i)
	±	(Ó˙ 0 + i = i)
	±	≥ Ó˙ 1 = Ó˙ 0
	±	≥ Ó˙ 0 = Ó˙ 1Æ);
a(REPEAT µ_tac);
a(rewrite_tac[˙_plus0_thm, Ó˙_one_one_thm, plus_clauses,
	µ_elim¨kÆ ˙_plus_order_thm]);
a(once_rewrite_tac[µ_elim¨k + iÆ ˙_eq_thm]);
a(once_rewrite_tac[µ_elim¨kÆ ˙_eq_thm]);
a(rewrite_tac[˙_minus_clauses, µ_elim¨~ kÆ ˙_plus_order_thm]);
a(rewrite_tac[˙_plus_assoc_thm1, ˙_minus_clauses, ˙_plus0_thm]);
a(once_rewrite_tac[µ_elim¨iÆ ˙_eq_thm]);
a(rewrite_tac[]);
a(conv_tac(LEFT_C eq_sym_conv));
a(once_rewrite_tac[µ_elim¨Ó˙ 0Æ ˙_eq_thm]);
a(rewrite_tac[˙_minus_clauses, ˙_plus0_thm]);
save_pop_thm"˙_plus_clauses"
);
=TEX
=SML
val €˙_º_º_0_thm› = (
set_goal([], ¨µ i j : ˙ ∑ i º j § i + ~j º Ó˙ 0Æ);
a(REPEAT µ_tac);
a(rewrite_tac[get_spec¨Ó˙ 0 º Ó˙ 0Æ]);
a(once_rewrite_tac[˙_eq_thm]);
a(rewrite_tac[˙_minus_clauses, µ_elim¨~jÆ˙_plus_order_thm, ˙_plus_clauses]);
save_pop_thm"˙_º_º_0_thm"
);
=TEX
=SML
val €˙_minus_º_thm› = (
set_goal([], ¨µi j:˙∑ ~i º ~j § j º iÆ);
a(REPEAT µ_tac);
a(rewrite_tac[get_spec¨Ó˙ 0 º Ó˙ 0Æ]);
a(once_rewrite_tac[˙_eq_thm]);
a(rewrite_tac[˙_minus_clauses, µ_elim¨~iÆ˙_plus_order_thm, ˙_plus_clauses]);
a(rewrite_tac[µ_elim¨Ó˙ mÆ˙_plus_order_thm]);
save_pop_thm"˙_minus_º_thm"
);
=TEX
=SML
val €˙_º_minus_thm› = (
set_goal([], ¨µi j:˙∑ i º j § ~j º ~iÆ);
a(rewrite_tac[˙_minus_º_thm]);
save_pop_thm"˙_º_minus_thm"
);
=TEX
=SML
val €˙_º_clauses› = (
set_goal([], ¨µi j k:˙∑
		(i + k º j + k § i º j)
	±	(k + i º j + k § i º j)
	±	(i + k º k + j § i º j)
	±	(k + i º k + j § i º j)
	±	(i + k º k § i º Ó˙ 0)
	±	(k + i º k § i º Ó˙ 0)
	±	(k º k + j § Ó˙ 0 º j)
	±	(k º j + k § Ó˙ 0 º j)
	±	(i º i)
	±	≥ Ó˙ 1 º Ó˙ 0
	±	Ó˙ 0 º Ó˙ 1 Æ);
a(REPEAT µ_tac);
a(rewrite_tac[µ_elim¨kÆ ˙_plus_order_thm]);
a(once_rewrite_tac[µ_elim¨k + iÆ ˙_º_º_0_thm]);
a(once_rewrite_tac[µ_elim¨kÆ ˙_º_º_0_thm]);
a(rewrite_tac[˙_minus_clauses, µ_elim¨~ kÆ ˙_plus_order_thm]);
a(rewrite_tac[˙_plus_assoc_thm1, ˙_minus_clauses, ˙_plus0_thm]);
a(once_rewrite_tac[µ_elim¨iÆ ˙_º_º_0_thm]);
a(once_rewrite_tac[µ_elim¨Ó˙ 0Æ ˙_º_º_0_thm]);
a(rewrite_tac[˙_minus_clauses, ˙_plus_clauses]);
a(rewrite_tac[get_spec¨Ó˙ 0 º Ó˙ 0Æ]);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) Ó˙_plus_homomorphism_thm]);
a(rewrite_tac[˙_plus_clauses, Ó˙_one_one_thm]);
a(conv_tac(ONCE_MAP_C prove_∂_conv));
a(REPEAT strip_tac);
a(∂_tac¨1Æ THEN rewrite_tac[˙_minus_clauses]);
save_pop_thm"˙_º_clauses"
);
=TEX
=SML
val €Ó˙_º_thm› = (
set_goal([], ¨µ m n : Ó ∑ Ó˙ m º Ó˙ n § m º nÆ);
a(REPEAT µ_tac);
a(rewrite_tac[get_spec¨Ó˙ 0 º Ó˙ 0Æ, get_spec¨0 º 0Æ]);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) Ó˙_plus_homomorphism_thm]);
a(rewrite_tac[Ó˙_one_one_thm]);
save_pop_thm"Ó˙_º_thm"
);
=TEX
=SML
val €˙_induction_tac› = gen_induction_tac ˙_induction_thm;
=TEX
=SML
val €˙_times_consistent_thm› = (
set_goal([], ¨µi: ˙∑∂f: ˙ ≠ ˙∑
		f (Ó˙ 1) = i
	±	µj k∑f(j + k) = f j + f kÆ);
a(strip_tac);
a(˙_induction_tac ¨iÆ);
(* *** Goal "1" *** *)
a(∂_tac¨Ãj∑jÆ THEN rewrite_tac[]);
(* *** Goal "2" *** *)
a(∂_tac¨Ãj∑~(f j)Æ THEN asm_rewrite_tac[˙_minus_clauses]);
(* *** Goal "3" *** *)
a(∂_tac¨Ãj∑(f j) + (f' j)Æ THEN asm_rewrite_tac[]);
a(REPEAT strip_tac);
a(rewrite_tac[µ_elim¨f' j'Æ˙_plus_order_thm]);
a(rewrite_tac[µ_elim¨f j'Æ˙_plus_order_thm]);
pop_thm()
);
=TEX
=SML
val _ = (
push_consistency_goal ¨$*âZÆ;
a(prove_∂_tac);
a(strip_tac);
a(strip_asm_tac(µ_elim ¨i'Æ ˙_times_consistent_thm));
a(∂_tac¨fÆ THEN asm_rewrite_tac[]);
save_consistency_thm ¨$*âZÆ (pop_thm())
);
=TEX
=SML
val €˙_times_0_thm1› = (
set_goal([], ¨µi:˙∑ i * Ó˙ 0 = Ó˙ 0Æ);
a(accept_tac(
	all_µ_intro
	(rewrite_rule[˙_plus_clauses, ˙_plus0_thm](prove_rule[get_spec¨$*âZÆ]
	¨i*(Ó˙ 0 + Ó˙ 0) = i * Ó˙ 0 + i * Ó˙ 0Æ))));
pop_thm()
);
=TEX
=SML
val €Ó˙_times_homomorphism_thm› = (
set_goal([], ¨µ m n : Ó ∑ Ó˙(m * n) = Ó˙ m * Ó˙ nÆ);
a(REPEAT strip_tac);
a(induction_tac¨nÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[times_clauses, ˙_times_0_thm1]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[times_plus_distrib_thm, get_spec¨$*âZÆ, Ó˙_plus_homomorphism_thm]);
save_pop_thm"Ó˙_times_homomorphism_thm"
);
=TEX
=SML
val €˙_times_minus_thm1› = (
set_goal([], ¨µi j:˙∑ i * ~ j = ~(i * j)Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨i * ~ j + i * j = Ó˙ 0Æ);
(* *** Goal "1" *** *)
a(LEMMA_T ¨i * ~ j + i * j = i * (~j + j)Æ rewrite_thm_tac
	THEN1 rewrite_tac[get_spec¨$*âZÆ]);
a(rewrite_tac[˙_minus_clauses, ˙_times_0_thm1]);
(* *** Goal "2" *** *)
a(once_rewrite_tac[˙_eq_thm]);
a(asm_rewrite_tac[˙_minus_clauses]);
pop_thm()
);
=TEX
=SML
val €˙_times_minus_thm2› = (
set_goal([], ¨µi j:˙∑ ~ i * j = ~(i * j)Æ);
a(REPEAT strip_tac);
a(˙_induction_tac¨jÆ THEN
	asm_rewrite_tac[get_spec¨$*âZÆ, ˙_times_minus_thm1, ˙_minus_clauses]);
pop_thm()
);
=TEX 
=SML
val €˙_times_minus_thm› = (
set_goal([], ¨µ i j : ˙ ∑
		~ i * j = ~(i * j)
	±	i * ~ j = ~(i * j)
	±	~ i * ~ j = i * jÆ);
a(rewrite_tac[˙_times_minus_thm1, ˙_times_minus_thm2, ˙_minus_clauses]);
save_pop_thm"˙_times_minus_thm"
);
=TEX 
=SML
val €˙_times_comm_thm› = (
set_goal([], ¨µ i j : ˙ ∑ i * j = j * iÆ);
a(lemma_tac¨µa b:Ó∑Ó˙ a * Ó˙ b = Ó˙ b * Ó˙ aÆ);
(* *** Goal "1" *** *)
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) Ó˙_times_homomorphism_thm,
	µ_elim¨a:ÓÆtimes_comm_thm]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨iÆ ˙_cases_thm) THEN strip_asm_tac(µ_elim¨jÆ ˙_cases_thm)
	THEN POP_ASM_T rewrite_thm_tac THEN POP_ASM_T rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(POP_ASM_T (rewrite_thm_tac o µ_elim ¨mÆ));
(* *** Goal "2.2" *** *)
a(rewrite_tac[˙_times_minus_thm] THEN POP_ASM_T (rewrite_thm_tac o µ_elim ¨mÆ));
(* *** Goal "2.3" *** *)
a(rewrite_tac[˙_times_minus_thm] THEN POP_ASM_T (rewrite_thm_tac o µ_elim ¨mÆ));
(* *** Goal "2.4" *** *)
a(rewrite_tac[˙_times_minus_thm] THEN POP_ASM_T (rewrite_thm_tac o µ_elim ¨mÆ));
save_pop_thm"˙_times_comm_thm"
);
=TEX 
=SML
val €˙_times_assoc_thm› = (
set_goal([], ¨µ i j k : ˙ ∑ (i * j) * k  = i * (j * k)Æ);
a(REPEAT strip_tac);
a(˙_induction_tac ¨kÆ
	THEN asm_rewrite_tac[˙_times_minus_thm, get_spec¨$*âZÆ]);
save_pop_thm"˙_times_assoc_thm"
);
=TEX
=TEX
=SML
val €˙_div_lemma1› = (
set_goal([], ¨µi:˙; n:Ó∑ 0 < n ¥ ∂d∑d * (Ó˙ n) º i ± i < (d + Ó˙ 1) * Ó˙ nÆ);
a(REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨iÆ ˙_cases_thm1));
(* *** Goal "1" *** *)
a(∂_tac¨Ó˙ (m Div n)Æ THEN POP_ASM_T rewrite_thm_tac);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) Ó˙_times_homomorphism_thm,
	conv_rule(ONCE_MAP_C eq_sym_conv) Ó˙_plus_homomorphism_thm,
	Ó˙_one_one_thm,
	Ó˙_º_thm, get_spec¨$<âZÆ]);
a(strip_asm_tac(list_µ_elim[¨mÆ, ¨nÆ] div_mod_thm));
a(strip_asm_tac(list_µ_elim[¨mÆ, ¨nÆ] mod_less_thm));
a(PC_T1 "lin_arith" asm_prove_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(rewrite_tac[get_spec¨$<âZÆ]);
a(once_rewrite_tac[˙_º_minus_thm]);
a(∂_tac¨~(Ó˙ (m Div n)) + ~(Ó˙ 1)Æ);
a(rewrite_tac[˙_minus_clauses, ˙_plus_assoc_thm, ˙_plus0_thm]);
a(once_rewrite_tac[prove_rule[˙_times_minus_thm]¨µa b:˙∑~ (a * b) = ~a * bÆ]);
a(rewrite_tac[˙_minus_clauses]);
a(rewrite_tac[Ó˙_plus_homomorphism_thm, ˙_plus_assoc_thm,
	˙_minus_clauses, ˙_plus_clauses]);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) Ó˙_times_homomorphism_thm,
	conv_rule(ONCE_MAP_C eq_sym_conv) Ó˙_plus_homomorphism_thm,
	Ó˙_one_one_thm,
	Ó˙_º_thm]);
a(strip_asm_tac(list_µ_elim[¨mÆ, ¨nÆ] div_mod_thm));
a(strip_asm_tac(list_µ_elim[¨mÆ, ¨nÆ] mod_less_thm));
a(PC_T1 "lin_arith" asm_prove_tac[]);
pop_thm()
);
=TEX
=SML

=SML
val _ = (
push_consistency_goal ¨$DivâZÆ;
a(prove_∂_tac THEN REPEAT strip_tac);
a(strip_asm_tac(µ_elim¨j''Æ ˙_cases_thm1) THEN POP_ASM_T rewrite_thm_tac);
(* *** Goal "1" *** *)
a(rewrite_tac[Ó˙_one_one_thm, pc_rule1"lin_arith"prove_rule[]¨≥ m = 0 § 0 < mÆ]);
a(strip_asm_tac(list_µ_elim[¨i''Æ, ¨mÆ]˙_div_lemma1) THEN1 asm_rewrite_tac[]);
a(∂_tac¨i'' + ~ (d * Ó˙ m)Æ THEN ∂_tac ¨dÆ THEN strip_tac);
a(rewrite_tac[µ_elim¨i''Æ ˙_plus_order_thm, ˙_plus_clauses, ˙_minus_clauses]);
a(POP_ASM_T (fn _ => id_tac) THEN all_asm_ante_tac);
a(rewrite_tac[get_spec¨$AbsâZÆ, get_spec¨$<âZÆ, Ó˙_º_thm]);
a(once_rewrite_tac[˙_º_º_0_thm]);
a(once_rewrite_tac[˙_times_comm_thm]);
a(rewrite_tac[get_spec¨$*âZÆ, ˙_minus_clauses]);
a(rewrite_tac[µ_elim¨Ó˙ m * dÆ ˙_plus_order_thm]);
a(rewrite_tac[µ_elim¨~(Ó˙ m * d)Æ ˙_plus_order_thm]);
a(rewrite_tac[˙_plus_assoc_thm, ˙_plus_clauses]);
a(taut_tac);
(* *** Goal "2" *** *)
a(conv_tac (ONCE_MAP_C eq_sym_conv) THEN once_rewrite_tac[˙_eq_thm]);
a(rewrite_tac[˙_plus0_thm, ˙_minus_clauses,
	Ó˙_one_one_thm, pc_rule1"lin_arith"prove_rule[]¨≥ m = 0 § 0 < mÆ]);
a(strip_asm_tac(list_µ_elim[¨i''Æ, ¨m+1Æ]˙_div_lemma1));
a(∂_tac¨i'' +  (~ d * Ó˙ (m+1))Æ THEN ∂_tac ¨~dÆ);
a(rewrite_tac[µ_elim¨i''Æ ˙_plus_order_thm, ˙_plus_clauses, ˙_minus_clauses]);
a(all_asm_ante_tac);
a(rewrite_tac[get_spec¨$AbsâZÆ, get_spec¨$<âZÆ, Ó˙_º_thm]);
a(rewrite_tac[µ_elim¨Ó˙ 0Æ ˙_º_º_0_thm,
	˙_minus_clauses, Ó˙_º_thm, ˙_plus0_thm]);
a(rewrite_tac[Ó˙_plus_homomorphism_thm, get_spec¨$*âZÆ]);
a(once_rewrite_tac[˙_times_comm_thm]);
a(rewrite_tac[Ó˙_plus_homomorphism_thm, get_spec¨$*âZÆ]);
a(rewrite_tac[˙_minus_clauses]);
a(once_rewrite_tac[˙_times_comm_thm]);
a(rewrite_tac[get_spec¨$*âZÆ, ˙_times_minus_thm]);
a(once_rewrite_tac[˙_º_º_0_thm]);
a(rewrite_tac[˙_minus_clauses]);
a(rewrite_tac[˙_plus_assoc_thm, µ_elim¨d * Ó˙ m Æ ˙_plus_order_thm]);
a(rewrite_tac[µ_elim¨~(d * Ó˙ m)Æ ˙_plus_order_thm]);
a(rewrite_tac[µ_elim¨~dÆ ˙_plus_order_thm]);
a(rewrite_tac[µ_elim¨dÆ ˙_plus_order_thm]);
a(rewrite_tac[µ_elim¨~(Ó˙ m)Æ ˙_plus_order_thm]);
a(rewrite_tac[˙_plus_assoc_thm1, ˙_plus_clauses, ˙_minus_clauses]);
a(taut_tac);
save_consistency_thm¨$DivâZÆ (pop_thm())
);
=TEX
=SML
val €Ó˙_plus_homomorphism_thm1› = (
set_goal([], ¨µ m n : Ó ∑ Ó˙ m + Ó˙ n = Ó˙(m + n)Æ);
a (rewrite_tac [Ó˙_plus_homomorphism_thm]);
save_pop_thm "Ó˙_plus_homomorphism_thm1"
);
=TEX
=SML
val €˙_Ó_induction_thm› = (
set_goal([], ¨µ p ∑ p (Ó˙ 0)
	±	(µ i ∑ Ó˙ 0 º i ± p i ¥ p (i + Ó˙ 1))
	¥	(µ m∑ Ó˙ 0 º m ¥ p m)Æ);
a (REPEAT strip_tac);
a (lemma_tac ¨µn ∑ p (Ó˙ n)Æ);
(* *** Goal "1" *** *)
a strip_tac;
a (induction_tac ¨nÆ);
(* *** Goal "1.1" *** *)
a (asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (spec_nth_asm_tac 3 ¨Ó˙ nÆ);
(* *** Goal "1.2.1" *** *)
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac [get_spec ¨Ó˙ 0 º Ó˙ 1Æ]);
a (∂_tac ¨nÆ);
a (rewrite_tac [˙_plus_clauses]);
(* *** Goal "1.2.2" *** *)
a (POP_ASM_T ante_tac);
a (rewrite_tac [Ó˙_plus_homomorphism_thm]);
(* *** Goal "2" *** *)
a (swap_nth_asm_concl_tac 2);
a (rewrite_tac [get_spec ¨Ó˙ 0 º Ó˙ 1Æ]);
a (rewrite_tac [˙_plus_clauses]);
a (swap_nth_asm_concl_tac 1);
a (POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a (asm_rewrite_tac[]);
save_pop_thm "˙_Ó_induction_thm"
);
=TEX
=SML
val €˙_Ó_induction_tac› = gen_induction_tac1 ˙_Ó_induction_thm;
=TEX
=SML
val €˙_Ó_plus_thm› = (
set_goal ([], ¨µ i j : ˙ ∑ Ó˙ 0 º i ± Ó˙ 0 º j ¥ Ó˙ 0 º i + jÆ);
a (rewrite_tac [get_spec ¨Ó˙ 0 º Ó˙ 1Æ, ˙_plus_clauses] THEN REPEAT strip_tac);
a (∂_tac ¨m+m'Æ);
a (asm_rewrite_tac [Ó˙_plus_homomorphism_thm]);
save_pop_thm "˙_Ó_plus_thm"
);
=TEX
=SML
val €˙_Ó_plus1_thm› = (
set_goal ([], ¨µ i : ˙ ∑ Ó˙ 0 º i ¥ Ó˙ 0 º i + Ó˙ 1Æ);
a (rewrite_tac [get_spec ¨Ó˙ 0 º Ó˙ 1Æ, ˙_plus_clauses] THEN REPEAT strip_tac);
a (∂_tac ¨m+1Æ);
a (asm_rewrite_tac [Ó˙_plus_homomorphism_thm]);
save_pop_thm "˙_Ó_plus1_thm"
);
=TEX
=SML
val €˙_minus_thm› = (
set_goal ([], ¨µ i j : ˙ ∑
		~ ( ~ i ) = i
	±	i + ~ i   = Ó˙ 0
	±	~ i + i   = Ó˙ 0
	±	~ (i + j) = ~ i + ~ j
	±	~ (Ó˙ 0) = Ó˙ 0  Æ);
a (rewrite_tac [˙_minus_clauses]);
save_pop_thm "˙_minus_thm"
);
=TEX
We need to break off here to prevent the structure becoming too large for
the Poly/ML compiler.
=SML
end (* of structure ˙ *);
structure €˙› = struct
open ˙;
=TEX
=SML
val €˙_Ó_cases_thm› = (
set_goal ([], ¨µ i ∑ Ó˙ 0 º i ¥ i = Ó˙ 0 ≤ (∂ j ∑ Ó˙ 0 º j ± i = j + Ó˙ 1)Æ);
a strip_tac;
a (˙_Ó_induction_tac);
(* *** Goal "1" *** *)
a (rewrite_tac[]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[]);
a (REPEAT strip_tac);
a (∂_tac ¨Ó˙ 0Æ);
a (rewrite_tac[˙_º_clauses]);
(* *** Goal "3" *** *)
a (asm_rewrite_tac[]);
a (REPEAT strip_tac);
a (∂_tac ¨iÆ);
a (REPEAT strip_tac);
save_pop_thm "˙_Ó_cases_thm"
);
=TEX
=SML
val €˙_Ó_≥_minus_thm› = (
set_goal ([], ¨µ i ∑ Ó˙ 0 º i ¥ i = Ó˙ 0 ≤ ≥ (Ó˙ 0 º ~i)Æ);
a strip_tac;
a (rewrite_tac [get_spec ¨Ó˙ 0 º Ó˙ 1Æ, ˙_plus_clauses]);
a (REPEAT strip_tac);
a (lemma_tac ¨Ó˙ (m + m') = Ó˙ 0Æ);
(* *** Goal "1" *** *)
a (asm_rewrite_tac [Ó˙_plus_homomorphism_thm, ˙_minus_clauses]);
(* *** Goal "2" *** *)
a (swap_nth_asm_concl_tac 1);
a (rewrite_tac [Ó˙_one_one_thm]);
a (swap_nth_asm_concl_tac 3);
a (asm_rewrite_tac[]);
a (swap_nth_asm_concl_tac 3);
a (asm_rewrite_tac[]);
save_pop_thm "˙_Ó_≥_minus_thm"
);
=TEX
=SML
val €˙_≥_Ó_thm› = (
set_goal([], ¨µ i : ˙ ∑ ≥ Ó˙ 0 º i ¥ Ó˙ 0 º ~ iÆ);
a (REPEAT strip_tac);
a (strip_asm_tac (µ_elim ¨iÆ ˙_cases_thm));
(* *** Goal "1" *** *)
a (swap_nth_asm_concl_tac 2);
a (asm_rewrite_tac[]);
a (rewrite_tac[get_spec ¨Ó˙ 0 º Ó˙ 1Æ]);
a (∂_tac ¨mÆ THEN rewrite_tac[˙_plus0_thm]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[˙_minus_clauses]);
a (rewrite_tac[get_spec ¨Ó˙ 0 º Ó˙ 1Æ]);
a (∂_tac ¨mÆ THEN rewrite_tac[˙_plus0_thm]);
save_pop_thm "˙_≥_Ó_thm"
);
=TEX
=SML
val €˙_plus_eq_thm› = (
set_goal([], ¨µ i j k : ˙ ∑ (i + j) = k § i = k + ~jÆ);
a (once_rewrite_tac [˙_eq_thm]);
a(rewrite_tac[˙_minus_clauses, µ_elim¨j : ˙Æ ˙_plus_order_thm]);
save_pop_thm "˙_plus_eq_thm"
);
=TEX
=SML
val €˙_Ó_≥_plus1_thm› = (
set_goal([], ¨µ i ∑ Ó˙ 0 º i ¥ ≥ i + (Ó˙ 1) = Ó˙ 0Æ);
a (REPEAT strip_tac);
a (rewrite_tac [˙_plus_eq_thm, ˙_plus0_thm]);
a (swap_nth_asm_concl_tac 1);
a (asm_rewrite_tac[]);
a (once_rewrite_tac[˙_º_º_0_thm]);
a (rewrite_tac [˙_minus_clauses, ˙_plus0_thm, ˙_º_clauses]);
save_pop_thm "˙_Ó_≥_plus1_thm"
);
=TEX
=SML
val €˙_times_assoc_thm1› = (
set_goal([], ¨µ i j k : ˙ ∑ i * j * k = (i * j) * kÆ);
a (REPEAT strip_tac);
a (rewrite_tac [˙_times_assoc_thm]);
save_pop_thm "˙_times_assoc_thm1"
);
=TEX
=SML
val €˙_times_order_thm› = (
set_goal([], ¨µ i : ˙ ∑ µ j k : ˙ ∑
		j * i = i * j
	±	(i * j) * k = i * j * k
	±	j * i * k = i * j * kÆ);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [list_µ_elim [¨jÆ,¨iÆ] ˙_times_comm_thm]);
(* *** Goal "2" *** *)
a (rewrite_tac [all_µ_elim ˙_times_assoc_thm]);
(* *** Goal "3" *** *)
a (rewrite_tac [list_µ_elim [¨jÆ,¨iÆ,¨kÆ] ˙_times_assoc_thm1]);
a (once_rewrite_tac [list_µ_elim [¨jÆ,¨iÆ] ˙_times_comm_thm]);
a (rewrite_tac [˙_times_assoc_thm]);
save_pop_thm "˙_times_order_thm"
);
=TEX
=SML
val €Ó˙_times_homomorphism_thm1› = (
set_goal([], ¨µ m n : Ó ∑ Ó˙ m * Ó˙ n = Ó˙(m * n)Æ);
a (REPEAT strip_tac);
a (rewrite_tac [all_µ_elim Ó˙_times_homomorphism_thm]);
save_pop_thm "Ó˙_times_homomorphism_thm1"
);
=TEX
=SML
val €˙_times1_thm› = (
set_goal ([], ¨µ i : ˙ ∑ i * (Ó˙ 1) = i ± (Ó˙ 1) * i = iÆ);
a (rewrite_tac [list_µ_elim [¨i : ˙Æ,¨Ó˙ 1Æ] ˙_times_comm_thm]);
a (REPEAT strip_tac);
a (strip_asm_tac (µ_elim ¨iÆ ˙_cases_thm));
(* *** Goal "1" *** *)
a (asm_rewrite_tac[Ó˙_times_homomorphism_thm1]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[]);
a (rewrite_tac[˙_times_minus_thm, Ó˙_times_homomorphism_thm1]);
save_pop_thm "˙_times1_thm"
);
=TEX
=SML
val €˙_times_plus_distrib_thm› = (
set_goal([], ¨µ i j k : ˙ ∑
		i * (j + k) = i * j + i * k
	±	(i + j) * k = i * k + j * kÆ);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [get_spec ¨Ó˙ 1 * Ó˙ 1Æ]);
(* *** Goal "2" *** *)
a (rewrite_tac [list_µ_elim [¨(i + j)Æ,¨kÆ] ˙_times_comm_thm]);
a (rewrite_tac [list_µ_elim [¨iÆ,¨kÆ] ˙_times_comm_thm]);
a (rewrite_tac [list_µ_elim [¨jÆ,¨kÆ] ˙_times_comm_thm]);
a (rewrite_tac [get_spec ¨Ó˙ 1 * Ó˙ 1Æ]);
save_pop_thm "˙_times_plus_distrib_thm"
);
=TEX
=SML
val €˙_times0_thm› = (
set_goal ([], ¨µ i : ˙ ∑ Ó˙ 0 * i = Ó˙ 0 ± i * Ó˙ 0 = Ó˙ 0Æ);
a (rewrite_tac [list_µ_elim [¨Ó˙ 0Æ,¨i:˙Æ] ˙_times_comm_thm]);
a strip_tac;
a (lemma_tac ¨Ó˙ 0 = j + ~jÆ);
(* *** Goal "1" *** *)
a (rewrite_tac [˙_minus_thm]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[˙_times_plus_distrib_thm]);
a (rewrite_tac [˙_minus_thm, ˙_times_minus_thm]);
save_pop_thm "˙_times0_thm"
);
=TEX
=SML
val €˙_eq_thm1› = (
set_goal ([], ¨µ i j∑ i = j § ~ i + j = Ó˙ 0Æ);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a (asm_rewrite_tac[˙_minus_clauses]);
(* *** Goal "2" *** *)
a (lemma_tac ¨i + (~i + j) = i + Ó˙ 0Æ THEN1 asm_rewrite_tac[]);
a (POP_ASM_T ante_tac);
a (rewrite_tac[˙_plus_assoc_thm1, ˙_plus_minus_thm, ˙_plus0_thm]);
a (strip_tac THEN asm_rewrite_tac[]);
save_pop_thm "˙_eq_thm1"
);
=TEX
=SML
val €˙_times_eq_0_thm› = (
set_goal ([], ¨µ i j : ˙ ∑ i * j = Ó˙ 0 § i = Ó˙ 0 ≤ j = Ó˙ 0Æ);
a (lemma_tac ¨µ a b : Ó ∑ a * b = 0 ¥ a = 0 ≤ b = 0Æ);
(* *** Goal "1" *** *)
a (REPEAT strip_tac);
a (strip_asm_tac (µ_elim ¨aÆ Ó_cases_thm));
a (strip_asm_tac (µ_elim ¨bÆ Ó_cases_thm));
a (asm_ante_tac ¨a * b = 0Æ);
a (asm_rewrite_tac[times_plus_distrib_thm]);
(* *** Goal "2" *** *)
a (REPEAT_N 4 strip_tac);
(* *** Goal "2.1" *** *)
a (strip_asm_tac (µ_elim ¨iÆ ˙_cases_thm)
	THEN strip_asm_tac (µ_elim ¨jÆ ˙_cases_thm)
	THEN asm_rewrite_tac[]);
(* *** Goal "2.1.1" *** *)
a (rewrite_tac [Ó˙_times_homomorphism_thm1, Ó˙_one_one_thm]);
a (asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a (rewrite_tac [˙_times_minus_thm]);
a (once_rewrite_tac[list_µ_elim [¨~ (Ó˙ m * Ó˙ m')Æ,¨Ó˙ 0Æ] ˙_eq_thm1]);
a (once_rewrite_tac[list_µ_elim [¨~ (Ó˙ m')Æ,¨Ó˙ 0Æ] ˙_eq_thm1]);
a (rewrite_tac[˙_minus_thm, ˙_plus0_thm]);
a (asm_rewrite_tac[Ó˙_times_homomorphism_thm1, Ó˙_one_one_thm]);
(* *** Goal "2.1.3" *** *)
a (rewrite_tac [˙_times_minus_thm]);
a (once_rewrite_tac[list_µ_elim [¨~ (Ó˙ m * Ó˙ m')Æ,¨Ó˙ 0Æ] ˙_eq_thm1]);
a (once_rewrite_tac[list_µ_elim [¨~ (Ó˙ m)Æ,¨Ó˙ 0Æ] ˙_eq_thm1]);
a (rewrite_tac[˙_minus_thm, ˙_plus0_thm]);
a (asm_rewrite_tac[Ó˙_times_homomorphism_thm1, Ó˙_one_one_thm]);
(* *** Goal "2.1.4" *** *)
a (rewrite_tac [˙_times_minus_thm]);
a (once_rewrite_tac[list_µ_elim [¨~ (Ó˙ m')Æ,¨Ó˙ 0Æ] ˙_eq_thm1]);
a (once_rewrite_tac[list_µ_elim [¨~ (Ó˙ m)Æ,¨Ó˙ 0Æ] ˙_eq_thm1]);
a (rewrite_tac[˙_minus_thm, ˙_plus0_thm]);
a (asm_rewrite_tac[Ó˙_times_homomorphism_thm1, Ó˙_one_one_thm]);
(* *** Goal "2.2" *** *)
a (REPEAT strip_tac THEN asm_rewrite_tac[˙_times0_thm]);
save_pop_thm "˙_times_eq_0_thm"
);
=TEX
=SML
val €˙_times_clauses› = (
set_goal ([], ¨µ i j : ˙ ∑
		Ó˙ 0 * i = Ó˙ 0
	±	i * Ó˙ 0 = Ó˙ 0
	±	i * Ó˙ 1 = i
	±	Ó˙ 1 * i = iÆ);
a (rewrite_tac [˙_times0_thm, ˙_times1_thm]);
save_pop_thm "˙_times_clauses"
);
=TEX
=SML
val €˙_Ó_times_thm› = (
set_goal ([], ¨µ i j ∑ Ó˙ 0 º i ± Ó˙ 0 º j ¥ Ó˙ 0 º i * jÆ);
a(REPEAT strip_tac THEN POP_ASM_T ante_tac);
a (˙_Ó_induction_tac);
(* *** Goal "1" *** *)
a (rewrite_tac [˙_times0_thm, ˙_º_clauses]);
(* *** Goal "2" *** *)
a (rewrite_tac [˙_times_plus_distrib_thm, ˙_times1_thm]);
a (all_asm_fc_tac[˙_Ó_plus_thm]);
save_pop_thm "˙_Ó_times_thm"
);
=TEX
=SML
val €˙_º_trans_thm› = (
set_goal ([], ¨µ i j k : ˙ ∑ i º j ± j º k ¥ i º kÆ);
a (rewrite_tac [get_spec ¨Ó˙ 0 º Ó˙ 1Æ]);
a (REPEAT strip_tac);
a (∂_tac ¨m+m'Æ);
a (rewrite_tac [Ó˙_plus_homomorphism_thm]);
a (eq_sym_nth_asm_tac 1);
a (eq_sym_nth_asm_tac 2);
a (lemma_tac ¨Ó˙ m = ~i + jÆ);
(* *** Goal "1" *** *)
a (asm_rewrite_tac[˙_plus_minus_thm, ˙_plus_assoc_thm1, ˙_plus0_thm]);
(* *** Goal "2" *** *)
a (lemma_tac ¨Ó˙ m' = ~j + kÆ);
(* *** Goal "2.1" *** *)
a (GET_NTH_ASM_T 3 rewrite_thm_tac);
a (rewrite_tac[˙_plus_minus_thm, ˙_plus_assoc_thm1, ˙_plus0_thm]);
(* *** Goal "2.2" *** *)
a (LIST_GET_NTH_ASM_T [1,2] rewrite_tac);
a (rewrite_tac[˙_plus_assoc_thm]);
a (rewrite_tac[˙_plus_minus_thm, ˙_plus_assoc_thm1, ˙_plus0_thm]);
save_pop_thm "˙_º_trans_thm"
);
=TEX
=SML
val €˙_º_cases_thm› = (
set_goal ([], ¨µ i j : ˙ ∑ i º j ≤ j º iÆ);
a (rewrite_tac [get_spec ¨Ó˙ 0 º Ó˙ 1Æ]);
a (REPEAT_N 2 strip_tac);
a (strip_asm_tac (µ_elim ¨i + ~ jÆ ˙_cases_thm));
(* *** Goal "1" *** *)
a (≤_right_tac);
a (∂_tac ¨mÆ);
a (eq_sym_nth_asm_tac 1);
a (asm_rewrite_tac[]);
a (rewrite_tac [µ_elim ¨iÆ ˙_plus_order_thm, ˙_plus_minus_thm, ˙_plus0_thm]);
(* *** Goal "2" *** *)
a (≤_left_tac);
a (∂_tac ¨mÆ);
a (eq_sym_nth_asm_tac 1);
a (lemma_tac ¨i = ~ (Ó˙ m) + jÆ THEN1 asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (rewrite_tac [˙_plus_assoc_thm, ˙_plus_minus_thm, ˙_plus0_thm]);
(* *** Goal "2.2" *** *)
a (once_asm_rewrite_tac[]);
a (rewrite_tac [list_µ_elim [¨~ (Ó˙ m)Æ,¨jÆ] ˙_plus_comm_thm]);
a (rewrite_tac [˙_plus_assoc_thm, ˙_plus_minus_thm, ˙_plus0_thm]);
save_pop_thm "˙_º_cases_thm"
);
=TEX
=SML
val €˙_º_refl_thm› = (
set_goal ([], ¨µ i : ˙ ∑ i º iÆ);
a (rewrite_tac [get_spec ¨Ó˙ 0 º Ó˙ 1Æ]);
a strip_tac;
a (∂_tac ¨0Æ);
a (rewrite_tac [˙_plus0_thm]);
save_pop_thm "˙_º_refl_thm"
);
=TEX
=SML
val €˙_º_º_0_thm1› = (
set_goal([], ¨µ i j : ˙ ∑ i º j § Ó˙ 0 º j + ~iÆ);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¨Ó˙ 0 º Ó˙ 1Æ]);
a (once_rewrite_tac [˙_eq_thm1]);
a (rewrite_tac [˙_minus_clauses, ˙_plus_clauses]);
a (rewrite_tac [list_µ_elim [¨~iÆ,¨~ (Ó˙ m)Æ] ˙_plus_comm_thm]);
a (rewrite_tac [list_µ_elim [¨jÆ,¨~iÆ] ˙_plus_comm_thm]);
a (rewrite_tac [˙_plus_assoc_thm]);
save_pop_thm "˙_º_º_0_thm1"
);
=TEX
=SML
val €˙_º_antisym_thm› = (
set_goal([], ¨µ i j : ˙ ∑ i º j ± j º i ¥ i = jÆ);
a (lemma_tac ¨µ m m' ∑ ~ (Ó˙ m) = ~ (Ó˙ m') § Ó˙ m' = Ó˙ mÆ);
a (REPEAT strip_tac THEN1 once_rewrite_tac[˙_eq_thm]
	THEN asm_rewrite_tac[˙_minus_thm]);
(* *** Goal "2" *** *)
a (REPEAT µ_tac);
a (strip_asm_tac (µ_elim ¨iÆ ˙_cases_thm)
	THEN strip_asm_tac (µ_elim ¨jÆ ˙_cases_thm));
(* *** Goal "2.1" *** *)
a (asm_rewrite_tac[Ó˙_º_thm, Ó˙_one_one_thm, º_antisym_thm]);
(* *** Goal "2.2" *** *)
a (asm_rewrite_tac[]);
a (once_rewrite_tac[˙_º_º_0_thm, ˙_eq_thm]);
a (once_rewrite_tac[list_µ_elim [¨~ (Ó˙ m') + ~ (Ó˙ m)Æ,¨Ó˙ 0Æ] ˙_º_º_0_thm1]);
a (rewrite_tac[˙_plus_clauses, ˙_minus_thm,Ó˙_plus_homomorphism_thm1]);
a (rewrite_tac[Ó˙_º_thm, Ó˙_one_one_thm, º_antisym_thm]);
(* *** Goal "2.3" *** *)
a (asm_rewrite_tac[]);
a (once_rewrite_tac[˙_º_º_0_thm1, ˙_eq_thm1]);
a (once_rewrite_tac[list_µ_elim [¨Ó˙ 0Æ,¨~ (Ó˙ m) + ~ (Ó˙ m')Æ] ˙_º_º_0_thm]);
a (rewrite_tac[˙_plus_clauses, ˙_minus_thm,Ó˙_plus_homomorphism_thm1]);
a (rewrite_tac[Ó˙_º_thm, Ó˙_one_one_thm, º_antisym_thm]);
(* *** Goal "2.4" *** *)
a (asm_rewrite_tac[˙_minus_º_thm]);
a (rewrite_tac[Ó˙_º_thm, Ó˙_one_one_thm, º_antisym_thm]);
save_pop_thm "˙_º_antisym_thm"
);
=TEX
=SML
val €˙_less_trans_thm› = (
set_goal([], ¨µ i j k : ˙ ∑ i < j ± j < k ¥ i < kÆ);
a (rewrite_tac [get_spec ¨Ó˙ 0 < Ó˙ 1Æ, get_spec ¨Ó˙ 0 º Ó˙ 1Æ]);
a (REPEAT strip_tac);
a (∂_tac ¨m + m' + 1Æ);
a (rewrite_tac[Ó˙_plus_homomorphism_thm]);
a (eq_sym_nth_asm_tac 1);
a (eq_sym_nth_asm_tac 2);
a (asm_rewrite_tac[˙_plus_assoc_thm]);
a (rewrite_tac[list_µ_elim [¨Ó˙ m'Æ,¨Ó˙ 1Æ] ˙_plus_comm_thm]);
save_pop_thm "˙_less_trans_thm"
);
=TEX
=SML
val €˙_less_irrefl_thm› = (
set_goal([], ¨µ i j : ˙ ∑ ≥ (i < j ± j < i)Æ);
a (rewrite_tac [get_spec ¨Ó˙ 0 < Ó˙ 1Æ, get_spec ¨Ó˙ 0 º Ó˙ 1Æ]);
a (REPEAT strip_tac);
a (eq_sym_nth_asm_tac 1);
a (asm_rewrite_tac[]);
a (rewrite_tac[˙_plus_assoc_thm, ˙_plus_clauses,
		Ó˙_plus_homomorphism_thm1, Ó˙_one_one_thm]);
save_pop_thm "˙_less_irrefl_thm"
);
=TEX
=SML
val €˙_less_cases_thm› = (
set_goal([], ¨µ i j : ˙ ∑ i < j ≤ i = j ≤ j < iÆ);
a (REPEAT µ_tac);
a (rewrite_tac[get_spec¨$<âZÆ, get_spec¨$ºâZÆ]);
a (strip_asm_tac (µ_elim ¨i + ~ jÆ ˙_cases_thm1));
(* *** Goal "1" *** *)
a (strip_asm_tac (µ_elim ¨mÆ Ó_cases_thm) THEN var_elim_nth_asm_tac 1);
(* *** Goal "1.1" *** *)
a (once_rewrite_tac[˙_eq_thm] THEN asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (≤_right_tac THEN ≤_right_tac THEN ∂_tac¨i'Æ);
a (once_rewrite_tac[˙_eq_thm1]);
a (all_asm_ante_tac THEN rewrite_tac [Ó˙_plus_homomorphism_thm]);
a (STRIP_T (ante_tac o once_rewrite_rule[˙_eq_thm]));
a (rewrite_tac[˙_minus_thm, µ_elim¨~jÆ ˙_plus_order_thm]);
a (rewrite_tac[µ_elim¨iÆ ˙_plus_order_thm]);
a (rewrite_tac[µ_elim¨~(Ó˙ 1)Æ ˙_plus_order_thm]);
(* *** Goal "2" *** *)
a (≤_left_tac THEN ∂_tac¨mÆ);
a (all_asm_ante_tac THEN rewrite_tac [Ó˙_plus_homomorphism_thm]);
a (once_rewrite_tac[˙_eq_thm1]);
a (rewrite_tac[˙_minus_thm, µ_elim¨jÆ ˙_plus_order_thm]);
a (rewrite_tac[µ_elim¨~iÆ ˙_plus_order_thm]);
a (rewrite_tac[µ_elim¨~(Ó˙ 1)Æ ˙_plus_order_thm]);
save_pop_thm "˙_less_cases_thm"
);
=TEX
=SML
val €Ó˙_less_thm› = (
set_goal([], ¨µ m n : Ó ∑ Ó˙ m < Ó˙ n § m < nÆ);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¨Ó˙ 0 < Ó˙ 1Æ, get_spec ¨0 < 1Æ]);
a (rewrite_tac [Ó˙_plus_homomorphism_thm1, Ó˙_º_thm]);
save_pop_thm "Ó˙_less_thm"
);
=TEX
=SML
val €˙_less_less_0_thm› = (
set_goal([], ¨µ i j : ˙ ∑ i < j § i + ~j < Ó˙ 0Æ);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¨Ó˙ 0 < Ó˙ 1Æ, get_spec ¨Ó˙ 0 º Ó˙ 1Æ]);
a (once_rewrite_tac [˙_eq_thm]);
a (rewrite_tac[˙_minus_clauses, µ_elim ¨~jÆ ˙_plus_order_thm, ˙_plus_clauses]);
save_pop_thm "˙_less_less_0_thm"
);
=TEX
=SML
val €˙_less_less_0_thm1› = (
set_goal([], ¨µ i j : ˙ ∑ i < j § Ó˙ 0 < j + ~iÆ);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¨Ó˙ 0 < Ó˙ 1Æ, get_spec ¨Ó˙ 0 º Ó˙ 1Æ]);
a (once_rewrite_tac[˙_eq_thm1]);
a (rewrite_tac [˙_plus_clauses, ˙_minus_clauses, ˙_plus_assoc_thm]);
a (rewrite_tac [µ_elim ¨~iÆ ˙_plus_order_thm]);
save_pop_thm "˙_less_less_0_thm1"
);
=TEX
=SML
val €˙_minus_less_thm› = (
set_goal([], ¨µ i j : ˙ ∑ ~ i < ~ j § j < iÆ);
a(REPEAT µ_tac);
a(rewrite_tac[get_spec¨Ó˙ 0 < Ó˙ 0Æ, get_spec ¨Ó˙ 0 º Ó˙ 1Æ]);
a(once_rewrite_tac[˙_eq_thm]);
a(rewrite_tac[˙_minus_clauses, µ_elim¨~iÆ˙_plus_order_thm, ˙_plus_clauses]);
a(rewrite_tac[µ_elim¨Ó˙ mÆ˙_plus_order_thm]);
a(rewrite_tac[µ_elim¨Ó˙ 1Æ˙_plus_order_thm]);
save_pop_thm "˙_minus_less_thm"
);
=TEX
=SML
val €˙_≥_less_thm› = (
set_goal([], ¨µ i j : ˙ ∑ ≥ i < j § j º iÆ);
a (REPEAT µ_tac);
a (strip_asm_tac (µ_elim ¨iÆ ˙_cases_thm)
	THEN strip_asm_tac (µ_elim ¨jÆ ˙_cases_thm)
	THEN asm_rewrite_tac[]);
(* *** Goal "1" *** *)
a (rewrite_tac[Ó˙_º_thm, Ó˙_less_thm, list_µ_elim [¨m:ÓÆ,¨m':ÓÆ] ≥_less_thm]);
(* *** Goal "2" *** *)
a (once_rewrite_tac[˙_º_º_0_thm1, ˙_less_less_0_thm]);
a (rewrite_tac[˙_minus_clauses]);
a (rewrite_tac[Ó˙_plus_homomorphism_thm1, Ó˙_º_thm, Ó˙_less_thm]);
(* *** Goal "3" *** *)
a (once_rewrite_tac[˙_º_º_0_thm, ˙_less_less_0_thm1]);
a (rewrite_tac[˙_minus_clauses, Ó˙_plus_homomorphism_thm1]);
a (pure_rewrite_tac[Ó˙_º_thm, Ó˙_less_thm]);
a (rewrite_tac[list_µ_elim [¨0Æ, ¨m' + m:ÓÆ] ≥_less_thm]);
(* *** Goal "4" *** *)
a (once_rewrite_tac[˙_minus_º_thm, ˙_minus_less_thm]);
a (rewrite_tac[Ó˙_º_thm, Ó˙_less_thm, list_µ_elim [¨m':ÓÆ,¨m:ÓÆ] ≥_less_thm]);
save_pop_thm "˙_≥_less_thm"
);
=TEX
=SML
val €˙_≥_º_thm› = (
set_goal([], ¨µ i j : ˙ ∑ ≥ i º j § j < iÆ);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv) ˙_≥_less_thm]);
save_pop_thm "˙_≥_º_thm"
);
=TEX
=SML
val €˙_º_less_eq_thm› = (
set_goal([], ¨µ i j : ˙ ∑ i º j § (i < j ≤ i = j)Æ);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a(swap_nth_asm_concl_tac 1);
a (rewrite_tac [eq_sym_rule (list_µ_elim [¨jÆ,¨iÆ] ˙_≥_º_thm)]);
a (contr_tac THEN asm_fc_tac [˙_º_antisym_thm]);
(* *** Goal "2" *** *)
a (rewrite_tac [eq_sym_rule (list_µ_elim [¨jÆ,¨iÆ] ˙_≥_less_thm)]);
a (contr_tac THEN asm_fc_tac [˙_less_irrefl_thm]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[˙_º_refl_thm]);
save_pop_thm "˙_º_less_eq_thm"
);
=TEX
=SML
val €˙_less_º_trans_thm› = (
set_goal([], ¨µ i j k : ˙ ∑ i < j ± j º k ¥ i < kÆ);
a (rewrite_tac [get_spec ¨Ó˙ 0 < Ó˙ 1Æ, get_spec ¨Ó˙ 0 º Ó˙ 1Æ]);
a (REPEAT strip_tac);
a (∂_tac ¨m+m'Æ);
a (eq_sym_nth_asm_tac 1);
a (eq_sym_nth_asm_tac 2);
a (asm_rewrite_tac[˙_plus_assoc_thm, Ó˙_plus_homomorphism_thm]);
save_pop_thm "˙_less_º_trans_thm"
);
=TEX
=SML
val €˙_º_less_trans_thm› = (
set_goal([], ¨µ i j k : ˙ ∑ i º j ± j < k ¥ i < kÆ);
a (rewrite_tac [get_spec ¨Ó˙ 0 < Ó˙ 1Æ, get_spec ¨Ó˙ 0 º Ó˙ 1Æ]);
a (REPEAT strip_tac);
a (∂_tac ¨m+m'Æ);
a (eq_sym_nth_asm_tac 1);
a (eq_sym_nth_asm_tac 2);
a (asm_rewrite_tac[˙_plus_assoc_thm, Ó˙_plus_homomorphism_thm]);
a (rewrite_tac [µ_elim ¨Ó˙ mÆ ˙_plus_order_thm]);
save_pop_thm "˙_º_less_trans_thm"
);
=TEX
=SML
val €˙_minus_Ó_º_thm› = (
set_goal([], ¨µ i m ∑ i + ~ (Ó˙ m) º iÆ);
a (rewrite_tac [get_spec ¨Ó˙ 0 º Ó˙ 1Æ]);
a (REPEAT µ_tac);
a (∂_tac ¨mÆ);
a (rewrite_tac [˙_plus_assoc_thm, ˙_plus_minus_thm, ˙_plus0_thm]);
save_pop_thm "˙_minus_Ó_º_thm"
);
=TEX
=SML
val €˙_º_plus_Ó_thm› = (
set_goal ([], ¨µ i m ∑ i º i + Ó˙ mÆ);
a (rewrite_tac [get_spec ¨Ó˙ 0 º Ó˙ 1Æ]);
a (REPEAT µ_tac);
a (∂_tac ¨mÆ THEN rewrite_tac[]);
save_pop_thm "˙_º_plus_Ó_thm"
);
=TEX
=SML
val €˙_ç_Ó_thm› = (
set_goal([], ¨µ i ∑ Ó˙ 0 º i § ∂ m ∑ i = Ó˙ mÆ);
a µ_tac;
a (rewrite_tac [get_spec ¨Ó˙ 0 º Ó˙ 1Æ, ˙_plus0_thm]);
a (REPEAT strip_tac THEN ∂_tac ¨mÆ THEN asm_rewrite_tac[]);
save_pop_thm "˙_ç_Ó_thm"
);
=TEX
=SML
val €˙_less_clauses ›= (
set_goal([], ¨µ i j k : ˙ ∑
		(i + k < j + k § i < j)
	±	(k + i < j + k § i < j)
	±	(i + k < k + j § i < j)
	±	(k + i < k + j § i < j)
	±	(i + k < k § i < Ó˙ 0)
	±	(k + i < k § i < Ó˙ 0)
	±	(i < k + i § Ó˙ 0 < k)
	±	(i < i + k § Ó˙ 0 < k)
	±	≥ i < i
	±	Ó˙ 0 < Ó˙ 1
	±	≥ Ó˙ 1 < Ó˙ 0 Æ);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¨Ó˙ 0 < Ó˙ 1Æ]);
a (rewrite_tac [˙_º_clauses, ˙_plus_assoc_thm]);
a (rewrite_tac [µ_elim ¨kÆ ˙_plus_order_thm]);
a (rewrite_tac [˙_º_clauses, ˙_plus0_thm]);
a (rewrite_tac [˙_≥_º_thm]);
a (rewrite_tac [get_spec ¨Ó˙ 0 < Ó˙ 1Æ]);
a (rewrite_tac [˙_plus_clauses, ˙_º_clauses]);
save_pop_thm "˙_less_clauses"
);
=TEX
=SML
val €˙_Ó_abs_thm› = (
set_goal ([], ¨µ m : Ó ∑ Abs (Ó˙ m) = Ó˙ m ± Abs (~(Ó˙ m)) = Ó˙ mÆ);
a (REPEAT strip_tac THEN rewrite_tac [get_spec ¨AbsÆ]);
(* *** Goal "1" *** *)
a (rewrite_tac [Ó˙_º_thm]);
(* *** Goal "2" *** *)
a (once_rewrite_tac [˙_º_º_0_thm]);
a (rewrite_tac [˙_plus0_thm, Ó˙_º_thm, ˙_minus_thm]);
a (strip_asm_tac (µ_elim ¨mÆ Ó_cases_thm));
(* *** Goal "2.1" *** *)
a (asm_rewrite_tac[˙_minus_clauses]);
(* *** Goal "2.2" *** *)
a (asm_rewrite_tac[]);
save_pop_thm "˙_Ó_abs_thm"
);
=TEX
=SML
val €˙_abs_thm› = (
set_goal ([], ¨µ i : ˙ ∑ Ó˙ 0 º i ¥ (Abs (i) = i ± Abs (~i) = i)Æ);
a µ_tac;
a (strip_asm_tac (µ_elim ¨iÆ ˙_cases_thm)
	THEN asm_rewrite_tac[˙_minus_thm, ˙_Ó_abs_thm]);
a (once_rewrite_tac [˙_º_º_0_thm]);
a (rewrite_tac [˙_minus_clauses, ˙_plus0_thm, Ó˙_º_thm]);
a (strip_tac THEN asm_rewrite_tac [˙_minus_clauses]);
save_pop_thm "˙_abs_thm"
);
=TEX
=SML
val €˙_abs_Ó_thm› = (
set_goal ([], ¨µ i : ˙ ∑ Ó˙ 0 º Abs iÆ);
a µ_tac;
a (strip_asm_tac (µ_elim ¨iÆ ˙_cases_thm)
	THEN asm_rewrite_tac[Ó˙_º_thm, ˙_Ó_abs_thm]);
save_pop_thm "˙_abs_Ó_thm"
);
=TEX
=SML
val €˙_abs_eq_0_thm› = (
set_goal ([], ¨µ i : ˙ ∑ Abs i = Ó˙ 0 § i = Ó˙ 0Æ);
a µ_tac;
a (strip_asm_tac (µ_elim ¨iÆ ˙_cases_thm)
	THEN asm_rewrite_tac[˙_minus_clauses, ˙_Ó_abs_thm]);
a (rewrite_tac [list_µ_elim [¨~ (Ó˙ m)Æ,¨Ó˙ 0Æ] ˙_eq_thm1]);
a (rewrite_tac [˙_minus_thm, ˙_plus0_thm]);
save_pop_thm "˙_abs_eq_0_thm"
);
=TEX
=SML
val €˙_abs_minus_thm› = (
set_goal([], ¨µ i : ˙ ∑ Abs (~i) = Abs iÆ);
a µ_tac;
a (strip_asm_tac (µ_elim ¨iÆ ˙_cases_thm)
	THEN asm_rewrite_tac[˙_Ó_abs_thm, ˙_minus_thm]);
save_pop_thm "˙_abs_minus_thm"
);
=TEX
=SML
val €˙_Ó_abs_minus_thm› = (
set_goal([], ¨µ i j : ˙ ∑ Ó˙ 0 º i ± Ó˙ 0 º j ± j º i ¥ Abs (i + ~j) º iÆ);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¨Ó˙ 0 º Ó˙ 1Æ, ˙_plus0_thm]);
a (REPEAT strip_tac);
a (∂_tac ¨m'Æ);
a (eq_sym_nth_asm_tac 1 THEN asm_rewrite_tac[]);
a (rewrite_tac[ µ_elim ¨Ó˙ m''Æ ˙_plus_order_thm, ˙_plus_minus_thm, ˙_plus0_thm]);
a (rewrite_tac[get_spec ¨AbsÆ, Ó˙_º_thm]);
save_pop_thm "˙_Ó_abs_minus_thm"
);
=TEX
=SML
val €˙_abs_times_thm› = (
set_goal([], ¨µ i j : ˙ ∑ Abs (i * j) = Abs i * Abs jÆ);
a(REPEAT strip_tac);
a (strip_asm_tac (µ_elim ¨iÆ ˙_cases_thm)
	THEN strip_asm_tac (µ_elim ¨jÆ ˙_cases_thm)
	THEN asm_rewrite_tac[]
	THEN rewrite_tac [˙_times_minus_thm, Ó˙_times_homomorphism_thm1]
	THEN rewrite_tac [˙_Ó_abs_thm]
	THEN rewrite_tac [Ó˙_times_homomorphism_thm]);
save_pop_thm "˙_abs_times_thm"
);
=TEX
=SML
val €˙_abs_plus_thm› = (
set_goal([], ¨µ i j : ˙ ∑ Abs (i + j) º Abs i + Abs jÆ);
a (REPEAT µ_tac);
a (strip_asm_tac (µ_elim ¨iÆ ˙_cases_thm)
	THEN strip_asm_tac (µ_elim ¨jÆ ˙_cases_thm));
(* *** Goal "1" *** *)
a (asm_rewrite_tac [Ó˙_plus_homomorphism_thm1, ˙_Ó_abs_thm, ˙_º_clauses]);
(* *** Goal "2" *** *)
a (strip_asm_tac (µ_elim ¨i + jÆ ˙_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "2.1" *** *)
a (rewrite_tac [˙_Ó_abs_thm]);
a (POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a (asm_rewrite_tac[˙_º_clauses]);
a (once_rewrite_tac [˙_º_º_0_thm1]);
a (rewrite_tac [˙_minus_thm, Ó˙_plus_homomorphism_thm1, Ó˙_º_thm]);
(* *** Goal "2.2" *** *)
a (rewrite_tac [˙_Ó_abs_thm]);
a (lemma_tac ¨Ó˙ m'' = ~ (Ó˙ m + ~ (Ó˙ m'))Æ
	THEN1 DROP_NTH_ASM_T 3 (rewrite_thm_tac o eq_sym_rule)
	THEN1 DROP_NTH_ASM_T 2 (rewrite_thm_tac o eq_sym_rule)
	THEN1 asm_rewrite_tac []
	THEN1 rewrite_tac [˙_minus_clauses] );
a (asm_rewrite_tac[]);
a (once_rewrite_tac [˙_º_º_0_thm1]);
a (rewrite_tac [˙_minus_clauses]);
a (rewrite_tac [µ_elim ¨Ó˙ mÆ ˙_plus_order_thm, ˙_minus_clauses]);
a (rewrite_tac [˙_plus0_thm, Ó˙_plus_homomorphism_thm1, Ó˙_º_thm]);
(* *** Goal "3" *** *)
a (strip_asm_tac (µ_elim ¨i + jÆ ˙_cases_thm) THEN asm_rewrite_tac[]);
(* *** Goal "3.1" *** *)
a (rewrite_tac [˙_Ó_abs_thm]);
a (POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a (asm_rewrite_tac[˙_º_clauses]);
a (once_rewrite_tac [˙_º_º_0_thm1]);
a (rewrite_tac [˙_minus_thm, Ó˙_plus_homomorphism_thm1, Ó˙_º_thm]);
(* *** Goal "3.2" *** *)
a (rewrite_tac [˙_Ó_abs_thm]);
a (lemma_tac ¨Ó˙ m'' = ~ (~(Ó˙ m) + Ó˙ m')Æ
	THEN1 DROP_NTH_ASM_T 3 (rewrite_thm_tac o eq_sym_rule)
	THEN1 DROP_NTH_ASM_T 2 (rewrite_thm_tac o eq_sym_rule)
	THEN1 asm_rewrite_tac []
	THEN1 rewrite_tac [˙_minus_clauses] );
a (asm_rewrite_tac[]);
a (once_rewrite_tac [˙_º_º_0_thm1]);
a (rewrite_tac [˙_minus_clauses]);
a (rewrite_tac [˙_plus_assoc_thm]);
a (rewrite_tac [µ_elim ¨Ó˙ m'Æ ˙_plus_order_thm, ˙_minus_clauses]);
a (rewrite_tac [˙_plus0_thm, Ó˙_plus_homomorphism_thm1, Ó˙_º_thm]);
(* *** Goal "4" *** *)
a (lemma_tac ¨~ (Ó˙ m) + ~ (Ó˙ m') = ~ (Ó˙ m + Ó˙ m')Æ
	THEN1 rewrite_tac [˙_minus_thm]);
a (asm_rewrite_tac [Ó˙_plus_homomorphism_thm1, ˙_Ó_abs_thm, ˙_º_clauses]);
save_pop_thm "˙_abs_plus_thm"
);
=TEX
=SML
val €˙_div_mod_unique_lemma1› = (
set_goal([], ¨µ i j : ˙ ∑ Ó˙ 0 º i ± Ó˙ 0 º j ± i * j < j
	¥ i = Ó˙ 0Æ);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¨Ó˙ 0 º Ó˙ 1Æ, ˙_plus0_thm]);
a (strip_tac);
a (POP_ASM_T ante_tac);
a (REPEAT (POP_ASM_T (rewrite_thm_tac o eq_sym_rule)));
a (rewrite_tac [Ó˙_one_one_thm, Ó˙_times_homomorphism_thm1, Ó˙_less_thm]);
a (strip_tac);
a (strip_asm_tac (µ_elim ¨mÆ Ó_cases_thm));
a (asm_ante_tac ¨m * m' < m'Æ);
a (asm_rewrite_tac[times_plus_distrib_thm]);
save_pop_thm "˙_div_mod_unique_lemma1"
);
=TEX
=SML
val €˙_div_mod_unique_lemma2› = (
set_goal([], ¨µ j d r : ˙ ∑ ≥j = Ó˙ 0
   ¥ ((d * j + r = Ó˙ 0 ± Ó˙ 0 º r ± r < Abs j) ¥ d = Ó˙ 0 ± r = Ó˙ 0)Æ);
a (REPEAT_UNTIL is_± strip_tac);
a (lemma_tac ¨d = Ó˙ 0Æ);
(* *** Goal "1" *** *)
a (lemma_tac ¨Abs (d * j) = Ó˙ 0Æ);
(* *** Goal "1.1" *** *)
a (lemma_tac ¨Abs (d * j) < Abs jÆ);
(* *** Goal "1.1.1" *** *)
a (lemma_tac ¨d * j = (d * j + r) + ~ rÆ);
(* *** Goal "1.1.1.1" *** *)
a (rewrite_tac [˙_plus_assoc_thm, ˙_minus_thm, ˙_plus0_thm]);
(* *** Goal "1.1.1.2" *** *)
a (POP_ASM_T once_rewrite_thm_tac);
a (bc_tac [˙_º_less_trans_thm]);
a (∂_tac ¨rÆ);
a (asm_rewrite_tac [˙_plus0_thm]);
a (strip_asm_tac (µ_elim ¨rÆ ˙_cases_thm));
(* *** Goal "1.1.1.2.1" *** *)
a (asm_rewrite_tac [˙_minus_thm, ˙_Ó_abs_thm, ˙_º_clauses]);
(* *** Goal "1.1.1.2.2" *** *)
a (DROP_ASM_T ¨Ó˙ 0 º rÆ ante_tac); 
a (asm_rewrite_tac[]);
a (once_rewrite_tac [˙_º_º_0_thm]);
a (rewrite_tac [˙_minus_clauses, ˙_plus0_thm, Ó˙_º_thm]);
a (strip_tac THEN asm_rewrite_tac[˙_plus0_thm, ˙_Ó_abs_thm, ˙_º_clauses]);
(* *** Goal "1.1.2" *** *)
a (POP_ASM_T ante_tac);
a (rewrite_tac [˙_abs_times_thm]);
a (strip_asm_tac (µ_elim ¨dÆ ˙_abs_Ó_thm));
a (strip_asm_tac (µ_elim ¨jÆ ˙_abs_Ó_thm));
a strip_tac;
a (ALL_FC_T rewrite_tac [˙_div_mod_unique_lemma1]);
a (rewrite_tac [˙_times0_thm]);
(* *** Goal "1.2" *** *)
a (POP_ASM_T ante_tac);
a (asm_rewrite_tac [˙_abs_eq_0_thm, ˙_times_eq_0_thm]);
(* *** Goal "2" *** *)
a (asm_rewrite_tac[]);
a (DROP_ASM_T ¨d * j + r = Ó˙ 0Æ ante_tac);
a (asm_rewrite_tac [˙_times0_thm, ˙_plus0_thm]);
save_pop_thm "˙_div_mod_unique_lemma2"
);
=TEX
=SML
val €˙_div_mod_unique_lemma3› = (
set_goal([], ¨µ i j d r D R : ˙ ∑ ≥j = Ó˙ 0 ¥
	(	(D * j + R = d * j + r ± Ó˙ 0 º r ± r º R ± R < Abs j)
	¥	D = d ± R = r)Æ);
a (REPEAT_UNTIL is_± strip_tac);
a (GET_ASM_T ¨D * j + R = d * j + rÆ (ante_tac o once_rewrite_rule [˙_eq_thm]));
a (lemma_tac ¨(D * j + R) + ~(d * j + r) = (D + ~d)*j + (R + ~r)Æ);
(* *** Goal "1" *** *)
a (rewrite_tac[˙_times_minus_thm, ˙_times_plus_distrib_thm,
	˙_minus_thm, ˙_plus_assoc_thm]);
a (rewrite_tac[µ_elim ¨RÆ ˙_plus_order_thm, ˙_minus_thm]);
(* *** Goal "2" *** *)
a (GET_NTH_ASM_T 1 rewrite_thm_tac);
a (lemma_tac ¨Ó˙ 0 º RÆ THEN1 all_fc_tac [˙_º_trans_thm]);
a (strip_asm_tac (list_µ_elim [¨RÆ,¨rÆ] ˙_Ó_abs_minus_thm));
a (GET_ASM_T ¨r º RÆ (asm_tac o once_rewrite_rule[˙_º_º_0_thm1]));
a (strip_asm_tac (µ_elim ¨R + ~rÆ ˙_abs_thm));
a (GET_ASM_T ¨Abs (R + ~ r) º RÆ ante_tac);
a (GET_ASM_T ¨Abs (R + ~ r) = R + ~ rÆ rewrite_thm_tac
	THEN strip_tac);
a (strip_asm_tac (list_µ_elim [¨R + ~rÆ,¨RÆ,¨Abs jÆ] ˙_º_less_trans_thm));
a (strip_tac
	THEN strip_asm_tac (list_µ_elim [¨jÆ,¨D + ~dÆ,¨R + ~rÆ]
		˙_div_mod_unique_lemma2));
a (once_rewrite_tac [˙_eq_thm] THEN REPEAT strip_tac);
save_pop_thm "˙_div_mod_unique_lemma3"
);
=TEX
=SML
val €˙_div_mod_unique_thm› = (
set_goal([], ¨µ i j d r : ˙ ∑ ≥j = Ó˙ 0 ¥
	(	(i = d * j + r ± Ó˙ 0 º r ± r < Abs j)
	§	(d = i Div j ± r = i Mod j)	)Æ);
a (REPEAT_N 8 strip_tac);
(* *** Goal "1" *** *)
a (strip_asm_tac (list_µ_elim [¨iÆ,¨jÆ] (get_spec ¨Ó˙ 2 Div Ó˙ 1Æ)));
a (strip_asm_tac (list_µ_elim [¨rÆ,¨i Mod jÆ] ˙_º_cases_thm));
(* *** Goal "1.1" *** *)
a (strip_asm_tac ˙_div_mod_unique_lemma3);
a (lemma_tac ¨(i Div j) * j + i Mod j = d * j + rÆ);
(* *** Goal "1.1.1" *** *)
a (DROP_ASM_T ¨i = d * j + rÆ (rewrite_thm_tac o eq_sym_rule));
a (DROP_ASM_T ¨i = (i Div j) * j + i Mod jÆ
	(rewrite_thm_tac o eq_sym_rule));
(* *** Goal "1.1.2" *** *)
a (DROP_ASM_T ¨i = d * j + rÆ (fn _ => id_tac));
a (DROP_ASM_T ¨i = (i Div j) * j + i Mod jÆ (fn _ => id_tac));
a (all_asm_fc_tac[]);
a (asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a (strip_asm_tac ˙_div_mod_unique_lemma3);
a (lemma_tac ¨d * j + r = (i Div j) * j + i Mod jÆ);
(* *** Goal "1.2.1" *** *)
a (DROP_ASM_T ¨i = d * j + rÆ (rewrite_thm_tac o eq_sym_rule));
a (DROP_ASM_T ¨i = (i Div j) * j + i Mod jÆ
	(rewrite_thm_tac o eq_sym_rule));
(* *** Goal "1.2.2" *** *)
a (DROP_ASM_T ¨i = d * j + rÆ (fn _ => id_tac));
a (DROP_ASM_T ¨i = (i Div j) * j + i Mod jÆ (fn _ => id_tac));
a (all_asm_fc_tac[]);
a (asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (strip_asm_tac (list_µ_elim [¨iÆ,¨jÆ] (get_spec ¨Ó˙ 2 Div Ó˙ 1Æ)));
a (DROP_ASM_T ¨i = (i Div j) * j + i Mod jÆ once_rewrite_thm_tac);
a (asm_rewrite_tac[]);
save_pop_thm "˙_div_mod_unique_thm"
);
=TEX
We need to break off here to prevent the structure becoming too large for
the Poly/ML compiler.
=SML
end (* of structure ˙ *);
structure €˙› = struct
open ˙;
=TEX
\section{SYNTAX FUNCTIONS}
=SML
val €minus› = (fst o dest_app) ¨~ (Ó˙ 42)Æ;
val €minusn› = (fst o dest_const) minus;
val €˙abs› = (fst o dest_app) ¨Abs (Ó˙ 42)Æ;
val €˙absn› = (fst o dest_const) ˙abs;
val €˙int› = (fst o dest_app) ¨Ó˙ 42Æ;
val €˙intn› = (fst o dest_const) ˙int;
=TEX
=SML
val €dest_˙_º› = dest_bin_op "dest_˙_º" 93101 (fst(dest_const ¨$ºâZÆ));
val €dest_˙_æ› = dest_bin_op "dest_˙_æ" 93102 (fst(dest_const ¨$æâZÆ));
val €dest_˙_greater› = dest_bin_op "dest_˙_greater" 93105 (fst(dest_const ¨$>âZÆ));
val €dest_˙_less› = dest_bin_op "dest_˙_less" 93106 (fst(dest_const ¨$<âZÆ));
val €dest_˙_plus› = dest_bin_op "dest_˙_plus" 93109 (fst(dest_const ¨$+âZÆ));
val €dest_˙_subtract› = dest_bin_op "dest_˙_subtract" 93111 (fst(dest_const ¨$-âZÆ));
val €dest_˙_times› = dest_bin_op "dest_˙_times" 93112 (fst(dest_const ¨$*âZÆ));
val €dest_˙_mod› = dest_bin_op "dest_˙_mod" 93108 (fst(dest_const ¨$ModâZÆ));
val €dest_˙_div› = dest_bin_op "dest_˙_div" 93104 (fst(dest_const ¨$DivâZÆ));
=TEX
=SML
fun €dest_˙_minus› (tm : TERM) : TERM = (
	let	val (sgn, a) = dest_app tm;
		val (s, _) = dest_const sgn;
	in	if s = minusn then a
			else term_fail "dest_˙_minus" 93107 [tm]
	end	handle Fail _ => term_fail "dest_˙_minus" 93107 [tm]
);
=TEX
=SML
fun €dest_˙_abs› (tm : TERM) : TERM = (
	let	val (sgn, a) = dest_app tm;
		val  (s,_) = dest_const sgn;
	in	if s = ˙absn then a
			else term_fail "dest_˙_abs" 93106 [tm]
	end	handle Fail _ => term_fail "dest_˙_abs" 93106 [tm]
);
=TEX
=SML
fun €dest_˙_signed_int› (tm : TERM) : INTEGER = (
	let	val (f, a) = dest_app tm;
		val (n, _) = dest_const f;
	in	if n = ˙intn then dest_Ó a
			else term_fail "dest_˙_signed_int" 93110 [tm]
	end	handle Fail _ => (
	let	val (sgn, a) = dest_app tm;
		val (s, _) = dest_const sgn;
		val (g, b) = dest_app a;
		val (n, _) = dest_const g;
	in	if s = minusn andalso n = ˙intn then @~(dest_Ó b)
			else term_fail "dest_˙_signed_int" 93110 [tm]
	end
	)	handle Fail _ => (
		term_fail "dest_˙_signed_int" 93110 [tm]
	)
);
=TEX
=SML
val €is_˙_º› = is_bin_op (fst(dest_const ¨$ºâZÆ));
val €is_˙_æ› = is_bin_op (fst(dest_const ¨$æâZÆ));
val €is_˙_less› = is_bin_op (fst(dest_const ¨$<âZÆ));
val €is_˙_greater› = is_bin_op (fst(dest_const ¨$>âZÆ));
val €is_˙_plus› = is_bin_op (fst(dest_const ¨$+âZÆ));
val €is_˙_subtract› = is_bin_op (fst(dest_const ¨$-âZÆ));
val €is_˙_times› = is_bin_op (fst(dest_const ¨$*âZÆ));
val €is_˙_mod› = is_bin_op (fst(dest_const ¨$ModâZÆ));
val €is_˙_div› = is_bin_op (fst(dest_const ¨$DivâZÆ));
=TEX
=SML
fun €is_˙_minus› (tm : TERM) : bool = (
	(dest_˙_minus tm; true) handle Fail _ => false
);
=TEX
=SML
fun €is_˙_abs› (tm : TERM) : bool = (
	(dest_˙_abs tm; true) handle Fail _ => false
);
=TEX
=SML
fun €is_˙_signed_int› (tm : TERM) : bool = (
	(dest_˙_signed_int tm; true) handle Fail _ => false
);
=TEX
=SML
fun €mk_˙_simple_bin_op› (tm : TERM) : TERM * TERM -> TERM = (fn (a1, a2) =>
	mk_app(mk_app(tm, a1), a2)
);
=TEX
=SML
val ˙_ty = î˙Æ;
fun €mk_˙_bin_op› (area : string) (tm : TERM) : (TERM * TERM) -> TERM = (
	let val f = mk_˙_simple_bin_op tm;
	in (fn tt as (t1, t2) => (
		if	type_of t1 =: ˙_ty
		then 	if	type_of t2 =: ˙_ty
			then	f tt
			else term_fail area 93201 [t2]
		else	term_fail area 93201 [t1]
	))
	end
);
=TEX
=SML
val €mk_˙_º› = mk_˙_bin_op "mk_˙_º" ¨$ºâZÆ;
val €mk_˙_æ› = mk_˙_bin_op "mk_˙_æ" ¨$æâZÆ;
val €mk_˙_less› = mk_˙_bin_op "mk_˙_less" ¨$<âZÆ;
val €mk_˙_greater› = mk_˙_bin_op "mk_˙_greater" ¨$>âZÆ;
val €mk_˙_plus› = mk_˙_bin_op "mk_˙_plus" ¨$+âZÆ;
val €mk_˙_subtract› = mk_˙_bin_op "mk_˙_subtract" ¨$-âZÆ;
val €mk_˙_times› = mk_˙_bin_op "mk_˙_times" ¨$*âZÆ;
val €mk_˙_mod› = mk_˙_bin_op "mk_˙_mod" ¨$ModâZÆ;
val €mk_˙_div› = mk_˙_bin_op "mk_˙_div" ¨$DivâZÆ;
=TEX
=SML
fun €mk_˙_minus› (tm : TERM) : TERM = (
	if type_of tm =: î˙Æ then mk_app (minus, tm)
			else term_fail "mk_˙_minus" 93201 [tm]
);
=TEX
=SML
fun €mk_˙_abs› (tm : TERM) : TERM = (
	if type_of tm =: î˙Æ then mk_app (˙abs, tm)
			else term_fail "mk_˙_abs" 93201 [tm]
);
=TEX
=SML
fun €mk_˙_signed_int› (i : INTEGER) : TERM = (
	(mk_app (˙int, (mk_Ó i)))
	handle ex => mk_app(minus, mk_app (˙int, (mk_Ó (@~i))))
);
=TEX
\section{ADDITIONAL INDUCTION PRINCIPLES}
=TEX
The following two induction theorems and corresponding tactics bring
the HOL support for induction up to the level provided for Z.
They should go somewhere in the {\ProductHOL} proof support tools.
(E.g., in the document that introduces the linear arithmetic
decision procedure for the integers).

First induction from an arbitrary starting point in the integers.
=SML
val €˙_º_induction_thm› = (
set_goal([], ¨µj p∑ p j ± (µi∑ j º i ± p i ¥ p (i + Ó˙ 1)) ¥ (µi∑j º i ¥ p i)Æ);
a(REPEAT strip_tac);
a(lemma_tac ¨µk∑Ó˙ 0 º k ¥ p(j + k)Æ);
(* *** Goal "1" *** *)
a(REPEAT µ_tac);
a(˙_Ó_induction_tac);
(* *** Goal "1.1" *** *)
a(asm_rewrite_tac[˙_plus_clauses]);
(* *** Goal "1.2" *** *)
a(LEMMA_T¨j º j + i'Æ asm_tac THEN1 asm_rewrite_tac[˙_º_clauses]);
a(PC_T1 "basic_hol" all_asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN rewrite_tac[˙_plus_assoc_thm]);
(* *** Goal "2" *** *)
a(GET_ASM_T ¨j º iÆ (strip_asm_tac o
	rewrite_rule[˙_minus_clauses] o
	once_rewrite_rule[conv_rule (ONCE_MAP_C eq_sym_conv) ˙_minus_º_thm] o
	once_rewrite_rule[˙_º_º_0_thm]));
a(all_asm_fc_tac[]);
a(POP_ASM_T ante_tac THEN rewrite_tac[µ_elim¨iÆ ˙_plus_order_thm, ˙_minus_clauses,
	˙_plus_clauses]);
save_pop_thm"˙_º_induction_thm"
);
=TEX
=SML
fun €˙_º_induction_tac› (tm : TERM) : TACTIC = (
	if not (is_var tm andalso type_of tm =: î˙Æ)
	then term_fail "˙_º_induction_tac" 93401 [tm]
	else ( fn(asms, conc) =>
	let	val asm = find asms (fn t => is_˙_º t andalso snd(dest_˙_º t) =$ tm)
			handle Fail _ => fail "˙_º_induction_tac" 93402 [];
		val thm = µ_elim (fst(dest_˙_º asm)) ˙_º_induction_thm;
	in	if not (is_free_in tm conc)
			then term_fail "˙_º_induction_tac" 93403 [tm]
		else if any (asms drop (fn t => t =$ asm)) (is_free_in tm)
			then term_fail "˙_º_induction_tac" 93404 [tm]
		else	(asm_ante_tac asm THEN gen_induction_tac1 thm) (asms, conc)
	end
	)
);
=TEX
Second, course-of-values induction, again starting from an arbitrary point.
=SML
val €˙_cov_induction_thm› = (
set_goal([], ¨µj : ˙; p∑ (µi∑ j º i ± (µk∑j º k ± k < i ¥ p k) ¥ p i) ¥ (µi∑j º i ¥ p i)Æ);
a(REPEAT strip_tac);
a(lemma_tac¨µ k∑ j º k ± k < i ¥ p kÆ);
(* *** Goal "1" *** *)
a(˙_º_induction_tac¨iÆ);
(* *** Goal "1.1" *** *)
a(REPEAT strip_tac);
a(lemma_tac ¨j < jÆ THEN_LIST [id_tac, all_fc_tac[˙_less_irrefl_thm]]);
a(bc_thm_tac ˙_º_less_trans_thm THEN ∂_tac¨kÆ THEN REPEAT strip_tac);
(* *** Goal "1.2" *** *)
a(REPEAT strip_tac);
a(strip_asm_tac (list_µ_elim[¨kÆ, ¨iÆ]˙_less_cases_thm) THEN1 all_asm_fc_tac[]);
(* *** Goal "1.2.1" *** *)
a(all_asm_fc_tac[] THEN asm_rewrite_tac[]);
(* *** Goal "1.2.2" *** *)
a(POP_ASM_T ante_tac THEN POP_ASM_T ante_tac THEN rewrite_tac[˙_less_def, ˙_º_clauses]);
a(REPEAT strip_tac);
a(LEMMA_T ¨i + Ó˙ 1 º iÆ ante_tac THEN_LIST [id_tac, rewrite_tac[˙_º_clauses]]);
a(bc_thm_tac ˙_º_trans_thm THEN ∂_tac¨kÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
save_pop_thm"˙_cov_induction_thm"
);
=TEX
=SML
fun €˙_cov_induction_tac› (tm : TERM) : TACTIC = (
	if not (is_var tm andalso type_of tm =: î˙Æ)
	then term_fail "˙_cov_induction_tac" 999001 [tm]
	else ( fn(asms, conc) =>
	let	val asm = find asms (fn t => is_˙_º t andalso snd(dest_˙_º t) =$ tm)
			handle Fail _ => fail "˙_cov_induction_tac" 93402 [];
		val thm = µ_elim (fst(dest_˙_º asm)) ˙_cov_induction_thm;
	in	if not (is_free_in tm conc)
			then term_fail "˙_cov_induction_tac" 93403 [tm]
		else if any (asms drop (fn t => t =$ asm)) (is_free_in tm)
			then term_fail "˙_cov_induction_tac" 93404 [tm]
		else	(asm_ante_tac asm THEN gen_induction_tac1 thm) (asms, conc)
	end
	)
);
=TEX

=TEX
\section{CONVERSIONS}
=SML
val _ = set_pc "predicates";
val €˙_plus_eg› = ¨i + j:˙Æ;
val €˙_times_eg› = ¨i * j:˙Æ;
val €˙_subtract_eg› = ¨i - j:˙Æ;
val €˙_greater_eg› = ¨i > j:˙Æ;
val €˙_æ_eg› = ¨i æ j:˙Æ;
val €˙_ç_Ó_eg› = ¨Ó˙ 0 º Ó˙ iÆ;
val €˙_abs_eg› = ¨Abs i:˙Æ;
val €˙_mod_eg› = ¨i Mod j:˙Æ;
val €˙_less_eg› = ¨i < j:˙Æ;
val €˙_div_eg› = ¨i Div j:˙Æ;
val €˙_º_eg› = ¨i º j:˙Æ;
val €˙_eq_eg› = ¨i = j:˙Æ;
=TEX
=SML
fun €accept_conv› (thm : THM) : CONV = (fn tm =>
	if	(fst(dest_eq (concl thm)) =$ tm) handle Fail _ => false
	then	thm
	else	fail_conv tm
);
=TEX
=SML
val €˙_Ó_plus_conv_thm› = (
set_goal([], ¨µ m n k ∑ m + n = k ¥ Ó˙ m + Ó˙ n = Ó˙ kÆ);
a (REPEAT strip_tac);
a (asm_rewrite_tac [Ó˙_plus_homomorphism_thm1, Ó˙_one_one_thm]);
pop_thm()
);
=TEX
=SML
val €˙_Ó_plus_conv› : CONV = (fn tm =>
	let	val ((_, hol_op1), (_, hol_op2)) =
			((dest_app ** dest_app)(dest_˙_plus tm))
			handle Fail _ => term_fail "˙_Ó_plus_conv" 93303 [tm, ˙_plus_eg];
		val thm1 = (plus_conv (mk_plus (hol_op1, hol_op2)))
			handle Fail _ => term_fail "˙_Ó_plus_conv" 93303 [tm, ˙_plus_eg];
		val thm2 = simple_¥_match_mp_rule ˙_Ó_plus_conv_thm thm1
			handle ex => reraise ex "˙_Ó_plus_conv";
	in	(accept_conv thm2 tm)
		handle Fail _ => term_fail "˙_Ó_plus_conv" 93303 [tm, ˙_plus_eg]
	end
);
=TEX
=SML
val €˙_Ó_times_conv_thm› = (
set_goal([], ¨µ m n k ∑ m * n = k ¥ Ó˙ m * Ó˙ n = Ó˙ kÆ);
a (REPEAT strip_tac);
a (asm_rewrite_tac [Ó˙_times_homomorphism_thm1, Ó˙_one_one_thm]);
pop_thm()
);
=TEX
=SML
val €˙_Ó_times_conv› : CONV = (fn tm =>
	let	val ((_, hol_op1), (_, hol_op2)) =
			((dest_app ** dest_app)(dest_˙_times tm))
			handle Fail _ => term_fail "˙_Ó_times_conv" 93301 [tm, ˙_times_eg];
		val thm1 = (times_conv (mk_times (hol_op1, hol_op2)))
			handle Fail _ => term_fail "˙_Ó_times_conv" 93301 [tm, ˙_times_eg];
		val thm2 = simple_¥_match_mp_rule ˙_Ó_times_conv_thm thm1
			handle ex => reraise ex "˙_Ó_times_conv";
	in	(accept_conv thm2 tm)
		handle Fail _ => term_fail "˙_Ó_times_conv" 93301 [tm, ˙_times_eg]
	end
);
=TEX
=SML
val €˙_subtract_minus_conv_thm› = (
set_goal([], ¨µ m n : ˙ ∑ m - n = m + ~nÆ);
a (rewrite_tac[get_spec¨$-âZÆ]);
pop_thm()
);
=TEX
=SML
val €˙_subtract_minus_conv› : CONV = (fn tm =>
	(simple_eq_match_conv ˙_subtract_minus_conv_thm tm)
	handle Fail _ => term_fail "˙_subtract_minus_conv" 93302 [tm, ˙_subtract_eg]
);
=TEX
=SML
val €˙_greater_less_conv_thm› = (
set_goal([], ¨µ i j : ˙ ∑ i > j § j < iÆ);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¨$>âZÆ]);
pop_thm()
);
=TEX
=SML
val €˙_greater_less_conv› : CONV = (fn tm =>
	((simple_eq_match_conv ˙_greater_less_conv_thm) tm)
	handle Fail _ => term_fail "˙_greater_less_conv" 93302 [tm, ˙_greater_eg]
);
=TEX
=SML
val €˙_æ_º_conv_thm› = (
set_goal([], ¨µ i j : ˙ ∑ i æ j § j º iÆ);
a (REPEAT µ_tac);
a (rewrite_tac[get_spec ¨$æâZÆ]);
pop_thm()
);
=TEX
=SML
val €˙_æ_º_conv› : CONV = (fn tm =>
	((simple_eq_match_conv ˙_æ_º_conv_thm) tm)
	handle Fail _ => term_fail "˙_æ_º_conv" 93302 [tm, ˙_æ_eg]
);
=TEX
=SML
val €˙_plus_conv_thm› = (
set_goal([], ¨µ k m n ∑
	(m + n = k ¥ Ó˙ m + Ó˙ n = Ó˙ k)
±	T
±	(n + k = m ¥ Ó˙ m + ~ (Ó˙ n) = Ó˙ k)
±	(m + k = n ¥ Ó˙ m + ~ (Ó˙ n) = ~ (Ó˙ k))
±	(m + k = n ¥ ~ (Ó˙ m) + Ó˙ n = Ó˙ k)
±	(n + k = m ¥ ~ (Ó˙ m) + Ó˙ n = ~ (Ó˙ k))
±	T
±	(m + n = k ¥ ~ (Ó˙ m) + ~ (Ó˙ n) = ~ (Ó˙ k))
Æ);
a (REPEAT strip_tac
	THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule)
	THEN rewrite_tac[Ó˙_plus_homomorphism_thm, ˙_minus_clauses]);
(* *** Goal "1" *** *)
a (rewrite_tac [µ_elim ¨Ó˙ kÆ ˙_plus_order_thm, ˙_minus_clauses, ˙_plus0_thm]);
(* *** Goal "2" *** *)
a (rewrite_tac [µ_elim ¨~ (Ó˙ k)Æ ˙_plus_order_thm, ˙_minus_clauses, ˙_plus0_thm]);
(* *** Goal "3" *** *)
a (rewrite_tac [µ_elim ¨Ó˙ kÆ ˙_plus_order_thm, ˙_minus_clauses, ˙_plus0_thm]);
(* *** Goal "4" *** *)
a (rewrite_tac [µ_elim ¨~ (Ó˙ k)Æ ˙_plus_order_thm, ˙_minus_clauses, ˙_plus0_thm]);
pop_thm()
);
=TEX
=SML
local
open PPVector;
val €˙_plus_conv_thms_forms› : (THM * (INTEGER*INTEGER -> INTEGER)) vector = vector(combine
	(map (list_µ_intro [¨m : ÓÆ, ¨n : ÓÆ, ¨k: ÓÆ])
		(strip_±_rule (all_µ_elim ˙_plus_conv_thm)))
	([op @+, op @+, op @-, op @- o swap, op @- o swap, op @-, op @+, op @+]
				: (INTEGER*INTEGER -> INTEGER) list)
);
val €plus_minus0_thm› = prove_rule[˙_plus0_thm, ˙_minus_thm] ¨µ i ∑ i + ~ (Ó˙ 0) = iÆ;
val €minus0_plus_thm› = prove_rule[˙_plus0_thm, ˙_minus_thm] ¨µ j ∑ ~ (Ó˙ 0) + j = jÆ;
fun €make_plus_conv_thm› (i : INTEGER) (j : INTEGER) : THM = (
	let	val m = iabs i;
		val n = iabs j;
		val ix =	(if i @< zero then 4 else 0) +
				(if j @< zero then 2 else 0) +
				(if i @+ j @< zero then 1 else 0);
		val (thm1, f) = sub(˙_plus_conv_thms_forms, ix);
		val mt = mk_Ó m;
		val nt = mk_Ó n;
		val kt = mk_Ó (f(m,n));
		val thm2 = list_simple_µ_elim [mt, nt, kt] thm1;
		val tm = (fst o dest_eq o fst o dest_¥ o concl) thm2;
	in ¥_mp_rule thm2 (plus_conv tm)
	end
);
in
val €˙_plus_conv› : CONV = (fn tm =>
	let	val (itm, jtm) = (dest_˙_plus tm);
		val i = dest_˙_signed_int itm;
		val j = dest_˙_signed_int jtm;
	in	(accept_conv (make_plus_conv_thm i j)
		ORELSE_C
		(fn t =>
		(if	j = zero
		then	accept_conv (simple_µ_elim itm plus_minus0_thm)
		else	fail_conv) t)
		ORELSE_C
		(fn t =>
		(if	i = zero
		then	accept_conv (simple_µ_elim jtm minus0_plus_thm)
		else	fail_conv) t)) tm
	end	handle Fail _ => term_fail "˙_plus_conv" 93303 [tm, ˙_plus_eg]
);
end;
=TEX
=SML
local
open PPVector;
val €times_convs› : ((CONV -> CONV) * CONV) vector = vector(
	combine
	[RAND_C, RAND_C, Combinators.I]
	(map (simple_eq_match_conv o prove_rule[˙_times_minus_thm])
	[	¨µ i j : ˙ ∑ i * ~j = ~(i * j)Æ,
		¨µ i j : ˙ ∑ ~i * j = ~(i * j)Æ,
		¨µ i j : ˙ ∑ ~i * ~j = i * jÆ]));
in
val €˙_times_conv› : CONV = (fn tm =>
	let	val (itm, jtm) = (dest_˙_times tm);
		val ix =	(if is_˙_minus itm then 2 else 0) +
				(if is_˙_minus jtm then 1 else 0);
	in	(if ix = 0
		then ˙_Ó_times_conv
		else	let val (f, c) = sub (times_convs, ix - 1)
			in c THEN_C f ˙_Ó_times_conv
			end) tm
	end	handle Fail _ => term_fail "˙_times_conv" 93303 [tm, ˙_times_eg]
);
end;
=TEX
=SML
local
val €˙_abs_conv_lemma› = prove_rule [Ó˙_º_thm, º_clauses] ¨µ m ∑ Ó˙ 0 º Ó˙ mÆ;
in
val €˙_abs_conv› : CONV = (fn tm =>
	let	val arg_tm = hd(snd(strip_app tm));
		val (itm, is_neg) = (dest_˙_minus arg_tm, true)
				handle Fail _ => (arg_tm, false);
		val i = snd(dest_app itm);
		val chk = dest_Ó i;
		val thm1 = µ_elim itm ˙_abs_thm;
		val thm2 = simple_µ_elim i ˙_abs_conv_lemma;
		val thm3 = ¥_mp_rule thm1 thm2;
	in	accept_conv
		(if is_neg	then ±_right_elim thm3
				else ±_left_elim thm3) tm
	end	handle Fail _ => term_fail "˙_abs_conv" 93303 [tm, ˙_abs_eg]
);
end;
=TEX
=SML
val €˙_div_mod_conv_thm› = (
set_goal([], ¨µ i j d r : ˙ ∑	d * j + r = i ± Ó˙ 0 º r ± r < Abs j
			¥	i Div j = d ± i Mod j = r	Æ);
a (conv_tac (ONCE_MAP_C eq_sym_conv) THEN REPEAT_UNTIL is_± strip_tac);
a (lemma_tac ¨≥j = Ó˙ 0Æ);
(* *** Goal "1" *** *)
a (swap_asm_concl_tac ¨r < Abs jÆ THEN asm_rewrite_tac[]);
a (asm_rewrite_tac [get_spec ¨$AbsâZÆ, ˙_º_clauses, ˙_≥_less_thm]);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac [˙_div_mod_unique_thm]);
pop_thm()
);
=TEX
=SML
val €˙_º_conv_thm1› = (
set_goal ([], ¨µ m n ∑ Ó˙ m º Ó˙ n § m º nÆ);
a (rewrite_tac [get_spec ¨Ó˙ 0 º Ó˙ 1Æ, get_spec ¨0 º 1Æ] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a (POP_ASM_T ante_tac);
a (rewrite_tac [Ó˙_plus_homomorphism_thm1, Ó˙_one_one_thm]);
a (strip_tac THEN ∂_tac ¨m'Æ THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a (rewrite_tac [Ó˙_plus_homomorphism_thm1, Ó˙_one_one_thm]);
a (∂_tac ¨iÆ THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val €˙_º_conv_thm2› = (
set_goal([], ¨µ i j k : ˙ ∑ i º j § i + k º j + kÆ);
a (REPEAT µ_tac);
a (rewrite_tac[˙_º_clauses]);
pop_thm()
);
=TEX
=SML
val €˙_º_conv› : CONV =(fn tm =>
	let	val (itm, jtm) = dest_˙_º tm;
		val i = dest_˙_signed_int itm;
		val j = dest_˙_signed_int jtm;
		val min = if i @< j then i else j;
		val k = if min @< zero then iabs min else zero;
		val ktm = mk_˙_signed_int k;
	in	(accept_conv(list_simple_µ_elim[itm, jtm, ktm] ˙_º_conv_thm2)
		THEN_C RANDS_C ˙_plus_conv
		THEN_C simple_eq_match_conv ˙_º_conv_thm1
		THEN_C º_conv) tm
	end	handle Fail _ => term_fail "˙_º_conv" 93303 [tm, ˙_º_eg]
);
=TEX
=SML
val €˙_less_conv_thm› = (
set_goal([], ¨µ i j : ˙ ∑ i < j § i + Ó˙ 1 º jÆ);
a (REPEAT µ_tac);
a (rewrite_tac [get_spec ¨Ó˙ 0 º Ó˙ 1Æ, get_spec ¨Ó˙ 0 < Ó˙ 1Æ]);
pop_thm()
);
=TEX
=SML
val €˙_less_conv› : CONV = (fn tm =>
	((eq_match_conv ˙_less_conv_thm
	THEN_C LEFT_C ˙_plus_conv
	THEN_C ˙_º_conv) tm)
	handle Fail _ => term_fail "˙_less_conv" 93303 [tm, ˙_less_eg]
);
=TEX
=SML
local
infix 7 ˙div ˙mod;
fun (i : INTEGER) €˙mod› (j : INTEGER) : INTEGER = (
	let	val mlm = i imod j;
	in	if mlm @>= zero
		then mlm
		else mlm @- j
	end
);
fun (i : INTEGER) €˙div› (j : INTEGER) : INTEGER = (
	let	val zm = i ˙mod j;
	in	(i @- zm) idiv j
	end
);
val €mk_˙0› = ¨Ó˙ 0Æ;
fun €˙_div_mod_conv› (is_div : bool): TERM * TERM -> THM = (fn (itm, jtm) =>
	let	val i = dest_˙_signed_int itm;
		val j = dest_˙_signed_int jtm;
		val dtm = mk_˙_signed_int (i ˙div j);
		val rtm = mk_˙_signed_int (i ˙mod j);
		val thm1 = (LEFT_C ˙_times_conv THEN_C ˙_plus_conv)
			(mk_˙_plus(mk_˙_times (dtm, jtm), rtm));
		val thm2 = §_t_elim (˙_º_conv (mk_˙_º(mk_˙0, rtm)));
		val thm3 = §_t_elim
			((RIGHT_C ˙_abs_conv THEN_C ˙_less_conv)
			(mk_˙_less (rtm, mk_˙_abs jtm)));
		val thm4 = ¥_mp_rule
			(list_simple_µ_elim[itm, jtm, dtm, rtm] ˙_div_mod_conv_thm)
			(list_±_intro [thm1, thm2, thm3]);
	in	(if is_div
		then ±_left_elim else ±_right_elim) thm4
	end
);
in
val €˙_div_conv› : CONV = (fn tm =>
	let	val (itm, jtm) = dest_˙_div tm;
	in	if jtm =$ mk_˙0
		then	term_fail "˙_div_conv" 93303 [tm, ˙_div_eg]
		else	(accept_conv (˙_div_mod_conv true (dest_˙_div tm)) tm)
			handle Fail _ => term_fail "˙_div_conv" 57003 [tm]
	end
);
val €˙_mod_conv› : CONV = (fn tm =>
	let	val (itm, jtm) = dest_˙_mod tm;
	in	if jtm =$ mk_˙0
		then	term_fail "˙_mod_conv" 93303 [tm, ˙_mod_eg]
		else	(accept_conv (˙_div_mod_conv false (dest_˙_mod tm)) tm)
			handle Fail _ => term_fail "˙_mod_conv" 57007 [tm]
	end
);
end;
=TEX
=SML
val €˙_minus0_thm› = (
set_goal([], ¨~ (Ó˙ 0) = Ó˙ 0Æ);
a (rewrite_tac [˙_minus_thm]);
pop_thm()
);
=TEX
=SML
val €˙_eq_conv_thm› = (
set_goal([], ¨µ i j : ˙ ∑ i < j ¥ (i = j § F)Æ);
a (REPEAT strip_tac);
(* *** Goal "1" *** *)
a(asm_ante_tac¨i < jÆ THEN asm_rewrite_tac[˙_less_clauses]);
(* *** Goal "2" *** *)
pop_thm()
);
=TEX
=SML
val €˙_eq_conv› : CONV = (fn tm =>
	let	val (itm, jtm) = dest_eq tm;
		val i = dest_˙_signed_int itm;
		val j = dest_˙_signed_int jtm;
	in	(if i @< j
		then	rewrite_conv [simple_¥_match_mp_rule ˙_eq_conv_thm
				(§_t_elim(˙_less_conv(mk_˙_less(itm, jtm))))]
		else if i = j
		then		LEFT_C (simple_eq_match_conv ˙_minus0_thm)
			AND_OR_C RIGHT_C (simple_eq_match_conv ˙_minus0_thm)
			AND_OR_C accept_conv (§_t_intro (refl_conv (mk_˙_signed_int i)))
		else (* i > j *)
				eq_sym_conv
			THEN_C accept_conv(simple_¥_match_mp_rule ˙_eq_conv_thm
				(§_t_elim (˙_less_conv (mk_˙_less (jtm, itm))))))
		tm
	end
);
=TEX
\section{PROOF CONTEXTS}
=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt (current_ad_rw_canon())) thms)
);
=TEX
=SML
val _ = delete_pc "'˙" handle Fail _ => ();
val _ = new_pc "'˙";
val _ = set_rw_eqn_cxt
		[	(¨i +âZ jÆ, ˙_plus_conv),
			(¨i *âZ jÆ, ˙_times_conv),
			(¨i -âZ jÆ, ˙_subtract_minus_conv),
			(¨AbsâZ iÆ, ˙_abs_conv),
			(¨i DivâZ jÆ, ˙_div_conv),
			(¨i ModâZ jÆ, ˙_mod_conv),
			(¨i = jÆ, ˙_eq_conv),
			(¨i ºâZ jÆ, ˙_º_conv),
			(¨i <âZ jÆ, ˙_less_conv),
			(¨i æâZ jÆ, ˙_æ_º_conv),
			(¨i >âZ jÆ, ˙_greater_less_conv)
		] "'˙";
val _ = add_rw_thms [˙_plus_clauses, ˙_minus_clauses, ˙_º_clauses,
			˙_less_clauses, ˙_times_clauses, ˙_≥_º_thm,
			˙_≥_less_thm]
	"'˙";
val €pos› = (thms_to_eqn_cxt [˙_minus_clauses, ˙_º_clauses, ˙_less_clauses]) @
		[	(¨i = jÆ, ˙_eq_conv),
			(¨i æâZ jÆ, ˙_æ_º_conv),
			(¨i >âZ jÆ, ˙_greater_less_conv)];
val €neg› = mapfilter (mk_≥ ** RAND_C) pos;
val €neutral› = thms_to_eqn_cxt [˙_≥_º_thm, ˙_≥_less_thm] @
		[(¨i ºâZ jÆ, ˙_º_conv), (¨i <âZ jÆ, ˙_less_conv)];
val €strip_eqn_cxt› = neutral @ pos @ neg;
val _ = set_st_eqn_cxt strip_eqn_cxt "'˙";
val _ = set_sc_eqn_cxt strip_eqn_cxt "'˙";
val _ = set_pr_tac basic_prove_tac "'˙";
val _ = set_pr_conv basic_prove_conv "'˙";
val _ = commit_pc "'˙";
=TEX
\section{EPILOG}
=SML
end (* of structure ˙ *);
structure €˙› : ˙ = ˙;
open ˙;

=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}
