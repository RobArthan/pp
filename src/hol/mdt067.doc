% $Id$ mdt067.doc
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Resolution Facilities}  %% Mandatory field
\def\TPPheadtitle{Module Tests for Automatic Existence Proofs}
\TPPref{DS/FMU/IED/MDT067}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the 
the automatic existence proof tools.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1]
First draft.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the resolution tools.
The design is in \cite{DS/FMU/IED/DTD067}
and it is
implemented in \cite{DS/FMU/IED/IMP067}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD067},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD067},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP067}.
\subsubsection{Deficiencies}
None known.
\section{TEST CASES}
We test each function of the signature of \cite{DS/FMU/IED/DTD067}
in turn, where possible in the same order as in the design document, testing both successful, and all error, cases.

Then we give some sample resolution problems, both
to test the system and give informal benchmarks.
\section{PROLOGUE}
Initialise the test package:
=SML
usefile "dtd013.sml";
usefile "imp013.sml";
init_mt_results();
=TEX
=SML
open_theory "hol";
=TEX
\section{SETTING THE PROOF CONTEXT}
To make the tests independent of some outside changes, we give a local 
proof context:
=SML
pop_proof_context();
push_proof_context prove_∂_epc;
=TEX
\section{THE TESTS OF COMPONENT FUNCTIONS}

\section{RESOLUTION PROBLEMS}
=SML
fun €thm_less› thms1 thms2 = (
let	val cthms2 = map dest_thm thms2;
in
	thms1 drop (fn thm => dest_thm thm mem cthms2)
end);
=TEX
Transitivity, Symmetry and existence of images
implies reflixity:

Using set of support:
=SML
basic_resolution_rule 100
	[(asm_rule ¨(≥ R (x:'a) x)Æ)]
	[(asm_rule ¨(µ x y z:'a ∑ R x y ± R y z ¥ R x z)Æ),
	(asm_rule ¨(µ x y:'a ∑ R x y ¥ R y x)Æ),
	(asm_rule ¨µ x :'a∑ R x (f x:'a)Æ)];
=TEX
without (won't finish in 100 steps).
=SML
basic_resolution_rule 100
	[(asm_rule ¨(≥ R (x:'a) x)Æ),
	(asm_rule ¨(µ x y z:'a ∑ R x y ± R y z ¥ R x z)Æ),
	(asm_rule ¨(µ x y:'a ∑ R x y ¥ R y x)Æ),
	(asm_rule ¨µ x :'a∑ R x (f x:'a)Æ)]
	[];
=TEX
=SML
push_goal([ ¨(µ x y z:'a ∑ R x y ± R y z ¥ R x z)Æ, 
	 ¨(µ x y:'a ∑ R x y ¥ R y x)Æ,
	 ¨µ x :'a∑ R x (f x:'a)Æ],
	¨(µ x:'a ∑ R x x)Æ);
a(basic_resolution_tac 5 []);
a(basic_resolution_tac 50 []);
pop_thm();
=TEX
Moore's Three Blocks Problem (Formal Methods in Artificial Intelligence, p81)
=SML
basic_resolution_rule 200 (* 100 is not enough *)
	[
	(asm_rule ¨on(A:'box,B:'box):BOOLÆ),
	(asm_rule ¨on(B:'box,C:'box):BOOLÆ),
	(asm_rule ¨green(A:'box):BOOLÆ),
	(asm_rule ¨≥ green(C:'box)Æ),
	(asm_rule ¨µ x y:'box∑ (green x ± on(x,y)) ¥ green yÆ)
	]
	[];
=TEX
Or
=SML
push_goal([],¨on(A:'box,B:'box) ± on(B:'box,C:'box) ±
	green(A:'box) ± ≥ green(C:'box)
	¥
	≥ µ x y ∑ ≥ (green x ± ≥ green y ± on(x,y))Æ);
a(basic_resolution_tac 200 []);
pop_thm();
=TEX



Examples from chapter 6 of Wos's book.

Predicate based set theory:

Try:
=TEX
πHOLCONST
IsPredGroup : (('a ∏ 'a ∏ 'a) ≠ BOOL) ≠ ('a ∏ 'a ≠ 'a) ≠ 'a ≠ ('a ≠ 'a) ≠ BOOL
˜
µ (p:('a ∏ 'a ∏ 'a) ≠ BOOL) (prod:'a ∏ 'a ≠ 'a) (e:'a) (inv:'a ≠ 'a) ∑
	IsPredGroup p prod e inv §
	((µ x ∑ p (e,x,x)) ±
	(µ x ∑ p (x,e,x)) ±
	(µ x ∑ p (inv x,x,e)) ±
	(µ x ∑ p (x, inv x, e)) ±
	(µ x y z u v w ∑ p(x, y, u) ± p (y, z, v) ± p(u, z, w) ¥ p(x,v,w)) ±
	(µ x y z u v w ∑ p(x, y, u) ± p (y, z, v) ± p(x, v, w) ¥ p(u, z, w)) ±
	(µ x y ∑ p(x, y, prod(x,y))) ±
	(µ x y u v ∑ p(x,y,u) ± p(x,y,v) ¥ (u = v)) ±
	(µ x :'a∑ x = x) ±
	(µ x y:'a ∑ (x = y) ≤ ≥(x = y)) ±
	(µ x y z:'a ∑ (x = y) ± (y = z) ¥ (x = z)) ±
	(µ u v x y ∑ (u = v) ± p(u,x,y) ¥ p(v,x,y)) ±
	(µ u v x y ∑ (u = v) ± p(x,u,y) ¥ p(x,v,y)) ±
	(µ u v x y ∑ (u = v) ± p(x,y,u) ¥ p(x,y,v)) ±
	(µ u v x ∑ (u = v) ¥ (prod(u,x) = prod(v,x))) ±
	(µ u v x ∑ (u = v) ¥ (prod(x,u) = prod(x,v))) ±
	(µ u v ∑ (u = v) ¥ (inv u = inv v)))
∞
A sample group:
=SML
val pthms = strip_±_rule (once_rewrite_rule[get_specification "IsPredGroup" ]
	(asm_rule ¨IsPredGroup P Prod E InvÆ));
=TEX
πHOLCONST
IsEqGroup : ('a ∏ 'a ≠ 'a) ≠ 'a ≠ ('a ≠ 'a) ≠ BOOL
˜
µ (e:'a) (inv:'a ≠ 'a)(prod:'a ∏ 'a ≠ 'a) ∑
	IsEqGroup prod e inv §
	((µ x :'a∑ prod(e,x) = x) ±
	(µ x :'a ∑ prod(x,e) = x) ±
	(µ x :'a ∑ prod(inv x, x) = e) ±
	(µ x :'a ∑ prod(x, inv x) = e) ±
	(µ x y z  :'a∑ prod(x,prod(y,z)) = prod(prod(x,y),z)) ±
	(µ x :'a∑ x = x) ±
	(µ x y z:'a ∑ (x = y) ± (y = z) ¥ (x = z)) ±
	(µ x y z:'a ∑ (x = y) ¥ (y = x)) ±
	(µ u v x ∑ (u = v) ¥ (prod(u,x) = prod(v,x))) ±
	(µ u v x ∑ (u = v) ¥ (prod(x,u) = prod(x,v))) ±
	(µ u v ∑ (u = v) ¥ (inv u = inv v)))
∞
A sample group:
=SML
val ethms = strip_±_rule (once_rewrite_rule[get_specification "IsEqGroup" ]
	(asm_rule ¨IsEqGroup Prod E InvÆ));
=TEX
Sanity test:
=SML
val rest = ethms;
val sos = [asm_rule ¨≥(e':'a = E)Æ,
	asm_rule ¨E:'a = e'Æ];
thm_less (basic_resolution_rule 40 sos rest) (sos @ rest);
=TEX
Some negated goals:

Identity is unique (as predicate):
=SML
¨µ e' :'a ∑ (µ x:'a ∑ P(e',x,x)) ± (µ x ∑ P(x,e',x)) ±
	¥
	(e' = E)Æ;
=TEX
Stripped and contradicted
=SML
val rest = pthms @ [
	asm_rule ¨(µ x:'a ∑ P(e':'a,x,x))Æ,
	asm_rule ¨(µ x:'a ∑ P(x,e':'a,x))Æ];
val sos = [asm_rule ¨≥(e':'a = E)Æ];
thm_less (basic_resolution_rule 50 sos rest) (sos @ rest);
=TEX
Identity is unique(via equality):
=SML
¨µ e' :'a ∑ (µ x:'a ∑ Prod(e',x) = x) ± (µ x ∑ Prod(x,e') = x)
	¥
	(e' = E)Æ;
=TEX
Stripped and contradicted
=SML
val rest = ethms;
val sos = [asm_rule ¨≥(e':'a = E)Æ,
	asm_rule ¨(µ x :'a∑ Prod(x,e':'a) = x)Æ];
thm_less (basic_resolution_rule 500 sos rest) (sos @ rest);
=TEX
Left inverse of a term is also its right inverse(predicate):
=SML
¨µ x x':'a ∑ P(x,x',E) ¥ P(x',x,E)Æ;
=TEX
Stripped and contradicted
=SML
val rest = pthms @ [asm_rule ¨P(x:'a,x':'a,E:'a):BOOLÆ];
val sos = [asm_rule ¨≥ P(x':'a,x:'a,E:'a)Æ];
thm_less (basic_resolution_rule 200 sos rest) (sos @ rest);
=TEX
and still doesn't get there!
Try a different set of support:
=SML
val rest = pthms;
val sos = [asm_rule ¨P(x:'a,x':'a,E:'a):BOOLÆ,
	asm_rule ¨≥ P(x':'a,x:'a,E:'a)Æ];
thm_less (basic_resolution_rule 200 sos rest) (sos @ rest);
=TEX

Left inverse of a term is also its right inverse(equality):
=SML
¨µ x x':'a ∑ P(x,x',E) ¥ P(x',x,E)Æ;
=TEX
Stripped and contradicted
=SML
val rest = ethms @ [asm_rule ¨Prod(x:'a,x':'a) :'a = EÆ];
val sos = asm_rule ¨≥(Prod(x':'a,x:'a):'a = E)Æ;
basic_resolution_rule 10 sos rest;
=TEX
If the square of every element is the identity, then the
group is commutative (predicate):
=SML
¨(µ x :'a ∑ P(x,x,E)) ¥ (µ x y v: 'a ∑ P(x, y, v) ¥ P(y, x, v)Æ;
=TEX
Stripped and contradicted
=SML
val rest = pthms @ [asm_rule ¨(µ x :'a ∑ P(x,x,E:'a))Æ,
	asm_rule ¨P(x:'a,y:'a,v:'a):BOOLÆ];
val sos = [asm_rule ¨≥ P(y:'a,x:'a,v:'a)Æ];
thm_less (basic_resolution_rule 200 sos rest) (sos @ rest);
=TEX
If the square of every element is the identity, then the
group is commutative (equality):
=SML
¨(µ x :'a ∑ Prod(x,x) = E) ¥ (µ x y: 'a ∑ Prod(x, y) = Prod(y,x))Æ;
=TEX
Stripped and contradicted
=SML
val rest = pthms @ [asm_rule ¨(µ x :'a ∑ Prod(x,x):'a = E)Æ];
val sos = [asm_rule ¨≥ (Prod(x:'a,y:'a):'a = Prod(y,x))Æ];
thm_less (basic_resolution_rule 200 sos rest) (sos @ rest);
=TEX
=SML
push_goal([],¨
	(∂z∑ p z)±(∂z∑ q z)
	¥	(((µz∑ p z ¥ r z) ± (µz∑ q z ¥ s z))
		§ (µz w∑ p z ± q w ¥ r z ± s w))
		Æ);
a(basic_resolution_tac 1 []);
undo 1;
a(basic_resolution_tac 2 []);
undo 1;
a(basic_resolution_tac 3 []);
undo 1;
a(basic_resolution_tac 4 []);
undo 1;
a(basic_resolution_tac 10 []);
undo 1;
a(basic_resolution_tac 20 []);
pop_thm();
=TEX
=SML
push_goal([],¨
	epsilon Ä alpha ± eta Ä beta ± ( alpha ° beta = {})
	¥ ((epsilon ¿ eta)\ alpha=eta) ±
		((epsilon ¿ eta)\ beta=epsilon)
		Æ);
a (rewrite_tac (map (get_defn "sets") ["Ä", "\\", "¿", "°", "ç", "Empty"]));
a (basic_resolution_tac 10 []);
pop_thm();
=TEX
=SML
push_goal([],¨
	epsilon Ä alpha ± eta Ä beta ± ( alpha ° beta = {})
	¥ ((epsilon ¿ eta)\ alpha=eta) ±
		((epsilon ¿ eta)\ beta=epsilon)
		Æ);
a (rewrite_tac (map (get_defn "sets") ["Ä", "\\", "¿", "°", "ç", "Empty"]));
a (c_contr_tac THEN basic_resolution_tac1 10 []);
pop_thm();
=TEX
=SML
push_goal([],¨
	epsilon Ä alpha ± eta Ä beta ± ( alpha ° beta = {})
	¥ ((epsilon ¿ eta)\ alpha=eta) ±
		((epsilon ¿ eta)\ beta=epsilon)
		Æ);
a (rewrite_tac (map (get_defn "sets") ["Ä", "\\", "¿", "°", "ç", "Empty"]));
a (basic_resolution_tac2 10 []);
pop_thm();
=TEX
=SML
push_goal([],¨
	epsilon Ä alpha ± eta Ä beta ± ( alpha ° beta = {})
	¥ ((epsilon ¿ eta)\ alpha=eta) ±
		((epsilon ¿ eta)\ beta=epsilon)
		Æ);
a (rewrite_tac (map (get_defn "sets") ["Ä", "\\", "¿", "°", "ç", "Empty"]));
a (c_contr_tac THEN basic_resolution_tac3 10 []);
pop_thm();
=TEX
\subsection{End of Tests}
=SML
diag_string(summarize_mt_results());
=TEX
\end{document}


