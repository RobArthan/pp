=IGN
********************************************************************************
mdt067.doc: this file is part of the ProofPower system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% %Z% $Revision: 1.10 $ $RCSfile: mdt067.doc,v $ $Date: 1999/02/24 13:32:17 $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Resolution Facilities}  %% Mandatory field
\def\TPPheadtitle{Module Tests for Automatic Existence Proofs}
\TPPref{DS/FMU/IED/MDT067}  %% Mandatory field
\def\SCCSversion{$Revision: 1.10 $ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 1999/02/24 13:32:17 $ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the 
the automatic existence proof tools.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1]
First draft.
\item [Issue 1.2,1.3 (9th April 1992)]
Changes required by CR0016.
\item [Issue 1.4 (14th April 1992)]
Changes required by CR0017.
\item [Issue 1.5 (13th May 1992)]
Changed signature of $get\_spec$.
\item [Issue 1.6 (14th May 1992)]
Tidying up proof contexts.
\item [Issue 1.12 (20th May 1992)]
Rearranging build proof contexts.
\item[Issue 1.8 (24th June 1992)]
Renamings from issue 1.6 of \cite{DS/FMU/IED/WRK038},
mostly proof context name changes.
\item[Issue 1.9 (14th December 1992)]
Changes to allow tests to be run on a parent database.
\item[Issue 1.10]
Update for SML97.
\item[Issue 1.11] Copyright and banner updates for open source release.
\end{description}
\subsection{Changes Forecast}
Empower more of the tests currently in ``=IGN'' sections,
as well as .
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the resolution tools.
The design is in \cite{DS/FMU/IED/DTD067}
and it is
implemented in \cite{DS/FMU/IED/IMP067}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD067},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD067},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP067}.
\subsubsection{Deficiencies}
Many functions not tested, or tested inadequately..
\section{TEST CASES}
We test each function of the signature of \cite{DS/FMU/IED/DTD067}
in turn, where possible in the same order as in the design document, testing both successful, and all error, cases.

Then we give some sample resolution problems, both
to test the system and give informal benchmarks.
\section{PROLOGUE}
Initialise the test package:
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results();
=TEX
=SML
open Resolution;
open_theory "hol";
new_theory "mdt067_test";
push_merge_pcs ["'propositions","'paired_abstractions"];
=TEX
\section{THE TESTS OF COMPONENT FUNCTIONS}
\section{RESOLUTION PROBLEMS}
=SML
fun €thm_less› thms1 thms2 = (
let	val cthms2 = map dest_thm thms2;
in
	thms1 drop (fn thm => present (op =#) (dest_thm thm) cthms2)
end);
=TEX
Transitivity, Symmetry and existence of images
implies reflixity:

Using set of support:
=SML
store_mt_results mt_run [
	("basic_res_rule 1",
	is_f o concl o hd o basic_res_rule 5
	 [(asm_rule ¨(≥ R (x:'a) x)Æ)],
	[(asm_rule ¨(µ x y z:'a ∑ R x y ± R y z ¥ R x z)Æ),
	(asm_rule ¨(µ x y:'a ∑ R x y ¥ R y x)Æ),
	(asm_rule ¨µ x :'a∑ R x (f x:'a)Æ)],
	true)];
=TEX
without:
=SML
store_mt_results mt_run [
	("basic_res_rule 2",
	is_f o concl o hd o basic_res_rule 5
	[(asm_rule ¨(≥ R (x:'a) x)Æ),
	(asm_rule ¨(µ x y z:'a ∑ R x y ± R y z ¥ R x z)Æ),
	(asm_rule ¨(µ x y:'a ∑ R x y ¥ R y x)Æ),
	(asm_rule ¨µ x :'a∑ R x (f x:'a)Æ)],
	[],
	true)];
=TEX
=SML
val gl1 = ([ ¨(µ x y z:'a ∑ R x y ± R y z ¥ R x z)Æ, 
	 ¨(µ x y:'a ∑ R x y ¥ R y x)Æ,
	 ¨µ x :'a∑ R x (f x:'a)Æ],
	¨(µ x:'a ∑ R x x)Æ);

push_goal gl1;
a(basic_res_tac 5 []);
store_mt_results (mt_runf (op =#)) [
	("basic_res_tac 1",
	dest_thm o pop_thm,
	(),
	gl1)];
=TEX
Moore's Three Blocks Problem (Formal Methods in Artificial Intelligence, p81)
=SML
store_mt_results mt_run [
	("basic_res_rule 3",
	is_f o concl o hd o basic_res_rule 5
	[
	(asm_rule ¨on(A:'box,B:'box):BOOLÆ),
	(asm_rule ¨on(B:'box,C:'box):BOOLÆ),
	(asm_rule ¨green(A:'box):BOOLÆ),
	(asm_rule ¨≥ green(C:'box)Æ),
	(asm_rule ¨µ x y:'box∑ (green x ± on(x,y)) ¥ green yÆ)
	],
	[],
	true)];
=TEX
Or
=SML
val gl2:GOAL = ([],¨on(A:'box,B:'box) ± on(B:'box,C:'box) ±
	green(A:'box) ± ≥ green(C:'box)
	¥
	≥ µ x y ∑ ≥ (green x ± ≥ green y ± on(x,y))Æ);

push_goal gl2;
a(strip_tac THEN basic_res_tac 5 []);
store_mt_results (mt_runf (op =#)) [
	("basic_res_tac 2",
	dest_thm o pop_thm,
	(),
	gl2)];
=TEX
Examples from chapter 6 of Wos's book.

Predicate based set theory:

Try:
=TEX
πHOLCONST
IsPredGroup : (('a ∏ 'a ∏ 'a) ≠ BOOL) ≠ ('a ∏ 'a ≠ 'a) ≠ 'a ≠ ('a ≠ 'a) ≠ BOOL
˜
µ (p:('a ∏ 'a ∏ 'a) ≠ BOOL) (prod:'a ∏ 'a ≠ 'a) (e:'a) (inv:'a ≠ 'a) ∑
	IsPredGroup p prod e inv §
	((µ x ∑ p (e,x,x)) ±
	(µ x ∑ p (x,e,x)) ±
	(µ x ∑ p (inv x,x,e)) ±
	(µ x ∑ p (x, inv x, e)) ±
	(µ x y z u v w ∑ p(x, y, u) ± p (y, z, v) ± p(u, z, w) ¥ p(x,v,w)) ±
	(µ x y z u v w ∑ p(x, y, u) ± p (y, z, v) ± p(x, v, w) ¥ p(u, z, w)) ±
	(µ x y ∑ p(x, y, prod(x,y))) ±
	(µ x y u v ∑ p(x,y,u) ± p(x,y,v) ¥ (u = v)) ±
	(µ x :'a∑ x = x) ±
	(µ x y:'a ∑ (x = y) ≤ ≥(x = y)) ±
	(µ x y z:'a ∑ (x = y) ± (y = z) ¥ (x = z)) ±
	(µ x y:'a ∑ (x = y) ¥ (y = x)) ±
	(µ u v x y ∑ (u = v) ± p(u,x,y) ¥ p(v,x,y)) ±
	(µ u v x y ∑ (u = v) ± p(x,u,y) ¥ p(x,v,y)) ±
	(µ u v x y ∑ (u = v) ± p(x,y,u) ¥ p(x,y,v)) ±
	(µ u v x ∑ (u = v) ¥ (prod(u,x) = prod(v,x))) ±
	(µ u v x ∑ (u = v) ¥ (prod(x,u) = prod(x,v))) ±
	(µ u v ∑ (u = v) ¥ (inv u = inv v)))
∞
A sample group:
=SML
val pthms = strip_±_rule (once_rewrite_rule[get_spec ¨IsPredGroupÆ ]
	(asm_rule ¨IsPredGroup P Prod E InvÆ));
=TEX
πHOLCONST
IsEqGroup : ('a ∏ 'a ≠ 'a) ≠ 'a ≠ ('a ≠ 'a) ≠ BOOL
˜
µ (e:'a) (inv:'a ≠ 'a)(prod:'a ∏ 'a ≠ 'a) ∑
	IsEqGroup prod e inv §
	((µ x :'a∑ prod(e,x) = x) ±
	(µ x :'a ∑ prod(x,e) = x) ±
	(µ x :'a ∑ prod(inv x, x) = e) ±
	(µ x :'a ∑ prod(x, inv x) = e) ±
	(µ x y z  :'a∑ prod(x,prod(y,z)) = prod(prod(x,y),z)) ±
	(µ x :'a∑ x = x) ±
	(µ x y z:'a ∑ (x = y) ± (y = z) ¥ (x = z)) ±
	(µ x y:'a ∑ (x = y) ¥ (y = x)) ±
	(µ u v x ∑ (u = v) ¥ (prod(u,x) = prod(v,x))) ±
	(µ u v x ∑ (u = v) ¥ (prod(x,u) = prod(x,v))) ±
	(µ u v ∑ (u = v) ¥ (inv u = inv v)))
∞
A sample group:
=SML
val ethms = strip_±_rule (once_rewrite_rule[get_spec ¨IsEqGroupÆ]
	(asm_rule ¨IsEqGroup Prod E InvÆ));
=TEX
Sanity tests:
=SML
val rest = ethms;
val sos = [asm_rule ¨≥(e':'a = E)Æ,
	asm_rule ¨E:'a = e'Æ];
store_mt_results mt_run [
	("basic_res_rule 7",
	is_f o concl o hd o basic_res_rule 5
	sos,
	rest,
	true)];
=TEX
=SML
val rest = pthms @ 
	[asm_rule ¨E:'a = e'Æ];
val sos = [asm_rule ¨≥(e':'a = E)Æ];
store_mt_results mt_run [
	("basic_res_rule 4",
	is_f o concl o hd o basic_res_rule 3
	sos,
	rest,
	true)];
=TEX
Some negated goals:

Identity is unique (as predicate):
=SML
¨µ e' :'a ∑ (µ x:'a ∑ P(e',x,x)) ± (µ x ∑ P(x,e',x))
	¥
	(e' = E)Æ;
=TEX
Stripped and contradicted
=SML
val rest = pthms @ [
	asm_rule ¨(µ x:'a ∑ P(e':'a,x,x))Æ,
	asm_rule ¨(µ x:'a ∑ P(x,e':'a,x))Æ];
val sos = [asm_rule ¨≥(e':'a = E)Æ];
store_mt_results mt_run [
	("basic_res_rule 5",
	is_f o concl o hd o basic_res_rule 5
	sos,
	rest,
	true)];
=TEX
Identity is unique(via equality):
=SML
¨µ e' :'a ∑ (µ x:'a ∑ Prod(e',x) = x) ± (µ x ∑ Prod(x,e') = x)
	¥
	(e' = E)Æ;
=TEX
Stripped and contradicted (too slow? at the moment)
=IGN
val rest = ethms @ 
	[asm_rule ¨≥(e':'a = E)Æ];
val sos = [asm_rule ¨(µ x :'a∑ Prod(x,e':'a) = x)Æ];
store_mt_results mt_run [
	("basic_res_rule 6",
	is_f o concl o hd o basic_res_rule 5
	sos,
	rest,
	true)];
=TEX
Left inverse of a term is also its right inverse(predicate):
=SML
¨µ x x':'a ∑ P(x,x',E) ¥ P(x',x,E)Æ;
=TEX
Stripped and contradicted
=IGN
val rest = pthms @ [asm_rule ¨P(x:'a,x':'a,E:'a):BOOLÆ];
val sos = [asm_rule ¨≥ P(x':'a,x:'a,E:'a)Æ];
thm_less (basic_res_rule 10 sos rest) (sos @ rest);
=TEX
Try a different set of support:
=IGN
val rest = pthms;
val sos = [asm_rule ¨P(x:'a,x':'a,E:'a):BOOLÆ,
	asm_rule ¨≥ P(x':'a,x:'a,E:'a)Æ];
thm_less (basic_res_rule 10 sos rest) (sos @ rest);
=TEX

Left inverse of a term is also its right inverse(equality):
=SML
¨µ x x':'a ∑ P(x,x',E) ¥ P(x',x,E)Æ;
=TEX
Stripped and contradicted
=IGN
val rest = ethms @ [asm_rule ¨Prod(x:'a,x':'a) :'a = EÆ];
val sos = asm_rule ¨≥(Prod(x':'a,x:'a):'a = E)Æ;
hd(basic_res_rule 10 sos rest);
=TEX
If the square of every element is the identity, then the
group is commutative (predicate):
=SML
¨(µ x :'a ∑ P(x,x,E)) ¥ (µ x y v: 'a ∑ P(x, y, v) ¥ P(y, x, v))Æ;
=TEX
Stripped and contradicted
=IGN
val rest = pthms @ [asm_rule ¨(µ x :'a ∑ P(x,x,E:'a))Æ,
	asm_rule ¨P(x:'a,y:'a,v:'a):BOOLÆ];
val sos = [asm_rule ¨≥ P(y:'a,x:'a,v:'a)Æ];
hd (basic_res_rule 10 sos rest);
=TEX
If the square of every element is the identity, then the
group is commutative (equality):
=SML
¨(µ x :'a ∑ Prod(x,x) = E) ¥ (µ x y: 'a ∑ Prod(x, y) = Prod(y,x))Æ;
=TEX
Stripped and contradicted
=IGN
val rest = pthms @ [asm_rule ¨(µ x :'a ∑ Prod(x,x):'a = E)Æ];
val sos = [asm_rule ¨≥ (Prod(x:'a,y:'a):'a = Prod(y,x))Æ];
hd (basic_res_rule 10 sos rest);
=TEX
=SML
val gl3 :GOAL = ([],¨
	(∂z∑ p z)±(∂z∑ q z)
	¥	(((µz∑ p z ¥ r z) ± (µz∑ q z ¥ s z))
		§ (µz w∑ p z ± q w ¥ r z ± s w))
		Æ);
push_goal gl3;
a(basic_res_tac 1 []);
undo 1;
a(basic_res_tac 2 []);
undo 1;
a(basic_res_tac 3 []);
store_mt_results (mt_runf (op =#)) [
	("basic_res_tac 3",
	dest_thm o pop_thm,
	(),
	gl3)];
=TEX
=SML
val gl4 : GOAL = ([],¨
	epsilon Ä alpha ± eta Ä beta ± ( alpha ° beta = {})
	¥ ((epsilon ¿ eta)\ alpha=eta) ±
		((epsilon ¿ eta)\ beta=epsilon)
		Æ);
push_goal gl4;
a (rewrite_tac (map (get_defn "sets") ["Ä", "\\", "¿", "°", "ç", "Empty"]));
a (basic_res_tac 5 []);
store_mt_results (mt_runf (op =#)) [
	("basic_res_tac 4",
	dest_thm o pop_thm,
	(),
	gl4)];
=TEX
=SML
push_goal gl4;
a (rewrite_tac (map (get_defn "sets") ["Ä", "\\", "¿", "°", "ç", "Empty"]));
a (contr_tac THEN basic_res_tac1 5 []);
store_mt_results (mt_runf (op =#)) [
	("basic_res_tac1 1",
	dest_thm o pop_thm,
	(),
	gl4)];
=TEX
=SML
push_goal gl4;
a (rewrite_tac (map (get_defn "sets") ["Ä", "\\", "¿", "°", "ç", "Empty"]));
a (basic_res_tac2 5 []);
store_mt_results (mt_runf (op =#)) [
	("basic_res_tac2 1",
	dest_thm o pop_thm,
	(),
	gl4)];
=TEX
=SML
push_goal gl4;
a (rewrite_tac (map (get_defn "sets") ["Ä", "\\", "¿", "°", "ç", "Empty"]));
a (contr_tac THEN basic_res_tac3 10 []);
store_mt_results (mt_runf (op =#)) [
	("basic_res_tac3 1",
	dest_thm o pop_thm,
	(),
	gl4)];
=TEX
\subsection{End of Tests}
=SML
diag_string(summarize_mt_results());
=TEX
\end{document}


