=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for Unification}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD014}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document gives the detailed design
of the module containing a function to compute the
unification of two types.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}

\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'

\begin{description}
\item[Issue 1.1]
Initial version, adapted from the HOL prototype version
described in DS/FMU/IED/SML007.

\item[Issue 1.2]
Corrected some minor typos. Added more description
about extended types. Revised section \ref{NamingConventions}.

\item[Issue 1.3]
Changed the arrow in the function ``funt'' from ``->''
to ``‹''. Also, changed the names of the value constructors
for extended types to be in line with the standard.

\end{description}

\subsection{Changes forecast}

None.

\pagebreak
\section{GENERAL}

\subsection{Scope}

This document contains part of the detailed design of the
ICL HOL system, concerned with the unification of types.
It is envisaged that the type unification algorithm covered
by this document will be used by the type inferer
to solve the type equations
in HOL terms which contain elements of type unknown.

\subsection{Introduction}
\subsubsection{Background and Purpose}
\label{BackgroundandPurpose}

This document contains a suite of functions which
support the function $unify$. Type checking and
type inference for the HOL language is based upon
the approach described in \cite{PeytonJones86}. This
describes a way of identifying the types of all the
elements in a term, as a process of solving linear
equations. The approach used here draws heavily from
\cite{PeytonJones86}, and the reader is refered to
this reference for background to the design of
the unification algorithm adopted here.

The unification of types has been a requirement in the
development of the prototype ICL HOL. The design
and implementation of a type unification algorithm
has been adapted from the prototype.

Changes have been made from the prototype in the
following areas:

\begin{enumerate}

\item
Exception and error handling will not done locally
anymore. Use will be made of the generic error handling
facilities described in \cite{DS/FMU/IED/DTD002}.

\item
The function $format\_TTYPE$ will no longer be required
for the reason above.

\item
Naming conventions will be changed in accordance
with \cite{DS/FMU/IED/DEF003}.

\end{enumerate}


The support for unification of HOL types are
potentially of use in constructing parsers for other
languages e.g. Z. This material is therefore also made
available for external use.

\subsubsection{Interface}

This document defines a signature Unification.

\subsubsection{Deficiencies}

None Known.

\subsubsection{Dependencies}

This document depends on the error handling system described
in document \cite{DS/FMU/IED/DTD002}.

\subsubsection{Algorithms}

The algorithms used in this document closely
follow the description of type inference
and unification for functional
programming languages which may be found in
chapters 8 and 9 of \cite{PeytonJones86}.
The analogy between our problem and the one discussed
in \cite{PeytonJones86} is very close. The typing rules
for HOL constants are like those for variables
bound in let-expressions in a functional programming
language and the typing rules for HOL variables are
like those for parameters.
Note however that the algorithm
described in \cite{PeytonJones86} computes
the type of a term, whereas we need to record
the types of all the constants and variables contained
in the term, and end up having to record the
types of every subterm. This is a very simple modification
of the algorithm.

The type inference algorithm turns out to be
essentially a matter of solving equations.
For example, consider the concrete term
``$(xŽa = x)F$''.
This contains no explicit type information
at all. However the theory database contains
information about the types of the constants
in the term: ``$=$'' has the polymorphic type
``$:'a‹'a‹'a$'' and ``$F$'' has type ``$:bool$''.
It follows that the bound variable ``$x$'' must have type
``$:bool$'', whence the instance of ``$=$'' has type
`$:bool‹bool‹bool$'', whence the free variable ``$a$'' must
have type ``$:bool$''. Since this determines
the types of all the variables and constants in the
term, this is all the information we
need to construct the corresponding abstract term
using the term constructors.

To represent the above reasoning as equation solving,
we use an extension of the algebra of HOL types which
includes an infinite collection of type unknowns,
which we shall write as ``$?1$'', ``$?2$'' etc.
To each distinct variable in the concrete term we
assign a distinct type unknown. To each constant we
assign an instance of the type stored in the theory
database for the constant; this instance has each type
variable in the type replaced by a distinct type unknown.
String and numeric constants are a special case here ---
their types are supplied by the parser.
Thus the term in the example becomes:
óExample
	(x:?1Ž ($=:?3‹?3‹bool) (a:?2) (x:?1))(F:bool)
æ
This results in the following equations, in which
additional type unknowns arise to represent the result
types of combinations:
óExample
	?3 ‹ ?3 ‹ bool	=	?2 ‹ ?4
	?4			=	?1 ‹ ?5
	?1 ‹ ?5		=	bool ‹ ?6
æ
We solve these above equations using a technique called
unification which returns a solution to any finite
set of equations which is the most general solution.
Its substitution instances comprise all the solutions
to the equations.

This technique is explained in detail in chapter 9
of \cite{PeytonJones86}.
The technique uses the notion of substitutions, i.e.
functions from type unknowns to extended types, which
differ from the identity in at most finitely many
places. Such a substitution may be used
to represent the solution to a set of equations between
extended types. E.g. in our example above, the
substitution giving the solution is:
óExample
	I • {?1 — bool, ?2 — bool, ?3 — bool, ?4 — bool ‹ bool, ?5 — bool, ?6 — bool}
æ
To find the substitution which gives the most general
solution to a set of equations, we take the equations
one at a time. Clearly the identity substitution is the
most general solution to an empty set of equations and,
if we have the solution $\phi$ for a set of equations $S$,
we may extend it to a solution for the set
$S\,¡\,\{\tau_1 = \tau_2\}$, if a solution exists, by a
recursion over
the structure of the $\tau_i$. Roughly
speaking this reduces
to extending the solution for additional equations
of the form $?n = \tau$ and checking that the resulting
solution is compatible with structure of the $\tau_i$.
\subsection{Possible Enhancements}
Various forms of overloading of names have been
proposed for HOL. One such scheme could be implemented
by additions to the code here to resolve the overloading. 

An explicit type constraint on a subterm or on a binding
occurrence of a variable are taken as requests that
the subterm or bound variable must have the type
indicated. It might be more desirable to allow the type
of the subterm or variable to be an instance of the
type. Thus, for example,
one could write ``$(f:'a‹'a)(12,\,[T,\,F])$'' instead of
``$(f(12,\,[T,\,F])):num*(bool list)$''.
(The disadvantage would be that it could prove confusing
in some cases and in such cases the user has to work
a little to find out what is going on.)

\subsection{Naming Conventions}
\label{NamingConventions}

Many of the functions and variables
in this document are given the
same names as those used in chapter 9 of \cite{PeytonJones86}.

\section{THE STRUCTURE $Unification$}

We now start the structure Unification which contains
the unification algorithm and some associated data types
and utilities.

=DOC
signature âUnificationá = sig
=DESCRIBE
$Unification$ is the signature comprising a suite
of functions used to compute the unification of
two types.
=ENDDOC
\subsection{Extended Types}

The type of extended types (i.e. types containing type unknowns) is
the following type $EXTYPE$.
The extended type corresponding
to a type variable is $EXVAR$ and is either known or unknown.
This is characterised by the value contructors $Known$ and
$Unknown$.
The extended type $EXTYPE$ is then constructed using $EXVAR$.

=DOC
	datatype âEXVARá = Known of string | Unknown of int;
	datatype âEXTYPEá = ExVartype of EXVAR | ExType of string * EXTYPE list;
=DESCRIBE
$EXVAR$ and $EXTYPE$ denote the type of extended types used
in unification and type inference.
=ENDDOC

\subsection{Substitutions}

Unification is carried out by using a substitution function.
This is a partial finite function mapping an extended type
to an extended type.

=DOC
	type âSUBSá;

=DESCRIBE
$SUBS$ denotes the type of the substitution function.
=ENDDOC

There are two forms of applying a substitution. The
first is using $apply\_subs$. This maps an unknown
type, represented as a number onto an extended type.
For example, if the unknown type is $Unknown\ 4$,
then $apply\_subs\ 4$ will yield the extended
type according to the substitution function, $SUBS$
corresponding to $Unknown\ 4$.

=DOC
	val âapply_subsá : SUBS -> int -> EXTYPE;
=DESCRIBE
$apply\_subs$ applies a substitution to a type
unknown (represented as an integer).
=ENDDOC

The other form of applying a substitution is to
use the function $sub\_type$. This takes an extended
type uses the substitution given by the finite function
$SUBS$ to yield a extended type, $EXTYPE$.
=DOC
	val âsub_typeá : SUBS -> EXTYPE -> EXTYPE;
=DESCRIBE
$sub\_type$ applies a substitution to a extended type.
=ENDDOC

The function $extype\_to\_type$ translates an extended type
to a type. Since not all extended types have a
corresponding type (ie. unknown types), special action
is required to handle these cases. If a value true
is supplied as second parameter to $extype\_to\_type$,
and an attempt is made to translate a type unknown, then
$extype\_to\_type$ will create a new name for the type.
If however, the parameter is set to false, then
if $extype\_to\_type$ attempts to translate a type
unknown, an exception with the ``Fail'' constructor
will be raised. This gives the type inferer the
choice in dealing with the translation of unknown types.

=DOC
	val âextype_to_typeá : SUBS -> bool -> EXTYPE -> TYPE;
=FAILURE
14004	Types Indeterminate
=DESCRIBE
The first parameter to $extype\_to\_type$ is the substitution
function. The second parameter to $extype\_to\_type$ is
an $ignore\_failure$ flag, which if set, precludes the
raising of an exception when translating a type unknown.
In this circumstance, a new name for the translated type
is generated. This will be of the form ``*?1'', ``*?2'', ...
and so on.
=ENDDOC

It is useful to create the composition of two substitutions.
For this, the function $scomp$ is provided.
=DOC
	val âscompá : SUBS -> SUBS -> SUBS;
=DESCRIBE
$scomp\,sub2\,sub1$ is the composition of the
substitutions $sub2$ and $sub1$. This is just the functional
composition, $sub2\,o\,sub1$.
=ENDDOC

The identity substitution, $id\_subs$ will also be useful.
=DOC
	val âid_subsá : SUBS;
=DESCRIBE
$id\_subs$ is the substitution function which when applied
to an extended type, yields the same extended type. It
is the identity function.
=ENDDOC

\subsection{Unification functions}

The function $unify$ computes the unification of two
extended types and yields a substitution function. This
can later be applied to type unknowns in a term to
find out what they are. If the unification fails then
an exception is raised.
=DOC
	val âunifyá : SUBS -> EXTYPE * EXTYPE -> SUBS;

=DESCRIBE
$unify$ computes the unification of two
extended types with respect to a substitution function.
The unification is in the form of a substitution function.
=FAILURE
14001	Failed to unify types ?0 with ?1. 
14002	Failed to unify types. 
=ENDDOC

It will also be useful to have a function which computes
the unification of a list of types.

=DOC
	val âlist_unifyá : SUBS -> EXTYPE list -> SUBS;
=DESCRIBE
The function $list\_unify$ computes the unification of
a list of extended types.
=ENDDOC

\subsection{Further Utilities}

The process of unifying two types requires a supply
of unique names. The utilities $start\_again$,
$next\_name$ and $new\_name$ serve this purpose.

=DOC
	val âstart_againá : unit -> unit;
	val ânext_nameá : unit -> int;
=DESCRIBE
$start\_again$ resets the internal record of the
next number to be generated to zero.
$next\_name$ will generate the next number in a sequence.
=ENDDOC

=DOC
	val ânew_nameá : 'a list -> ('a * int) list;
=DESCRIBE
$new\_name$ associates each item in the argument list
with a unique number. It returns a list of pairs. The
first of each pair is item and the second is the
unique number.
=USES
$new\_name$ is used when converting types to extended
types to supply a list of distinct type unknown names.
=ENDDOC

=DOC
	val âreplacedá : TYPE -> EXTYPE;
=DESCRIBE
$replaced$ is used whenever a constant is encountered
to give an extended type for the constant. Since the
same constant may have its type instantiated differently
at different instances in the same term, we replace all the
type variables in the new type by type unknowns using a
different set of type unknowns on every invocation.
=ENDDOC

=DOC
	val âfuntá : EXTYPE -> EXTYPE -> EXTYPE;
=DESCRIBE
$funt$ constructs extended function types. Supplied
with two arguments, t1 and t2, funt will construct the
extended function type, represented
as $ExType(``‹'',[t1,t2])$.
=ENDDOC

This completes the signature for the structure Unification.
=SML
end; (* of signature Unification *)
=TEX


\section{TEST POLICY}

The tests should follow the standards and guidelines laid down in \cite{DS/FMU/IED/PLN008}.
The design and implementation should be close to that
of the ICL HOL prototype described in \cite{DS/FMU/IED/SML007}.
It is suggested that particular attention be given to
testing the
areas which are new to this implementation of unification
as highlighted in section \ref{BackgroundandPurpose}.


\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}
