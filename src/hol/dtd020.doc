=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for ICL HOL Symbol Table}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD020}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
%\TPPdate{}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the detailed design for the
symbol table module for ICL HOL.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library\\RDA\\AJH\\DJK}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue 1.7 (22 May 1991)]
First draft for comment.
\item [Issue \SCCSversion (\FormatDate{$Date$%
})] Added $get\_alias$.
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the symbol table module for ICL HOL.
The high level design for this material is given in \cite{DS/FMU/IED/HLD008}.
Some of what is specified here implements facilities required explicitly in
\cite{DS/FMU/IED/DEF001}.
\subsection{Introduction}
In order to give the parser, type inferrer and pretty printer a uniform
interface to determine the properties of identifiers we have a symbol table
module which, in effect, supplies a mapping of identifiers onto
records encoding the properties of interest. The symbol table module
also contains the interfaces whereby the user sets certain properties of
identifiers (namely the interfaces for fixity, terminator, binder and type
abbreviation declarations).

The following general principles are followed (and should be respected by
maintainers and enhancers):

\begin{enumerate}
\item
The symbol table reflects a current context determined by the current theory.
All updates affect the current theory.
\item
All special properties of an identifier in one context can be suppressed
in any descendant context. This sometimes requires the use of undeclaration
records in the underlying $USER\_DATA$ value which is stored in the theory.
\item
The validity of identifiers is only checked when it is necessary to avoid
the user tying himself in serious knots (e.g. by declaring a space character
as a terminator).
Such things as infixes, type abbreviations etc. are completely unrestricted,
and since the lexis of \cite{DS/FMU/IED/DEF001} allows arbitrary strings
to be used as identifiers this is a feature not a bug, because, e.g., it allows the
HOL parser to interface with any other language embedded in HOL.
\item
Operations with a side effect are curried, so that there is less risk
of them being entered partially by the interactive user.
\end{enumerate}
\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD008}.
\subsection{Dependencies}
The symbol table module is dependent on the interface to the
abstract data type $THM$, \cite{DS/FMU/IED/DTD012}
and on the lexical analyser module, \cite{DS/FMU/IED/DTD015}.
\subsection{Possible Enhancements}
A function for finding the best possible abbreviation for a type (in some
sense to be decided) could be provided and would support a nicer pretty printing
option in a future release.
\subsection{Deficiencies}
None known.
\section{DISCUSSION}
The symbol table serves the lexical analyser,
parser, pretty printer and type inferrer
by supplying a mapping from identifiers onto information
which they may need.
Symbol table records are held for the following sorts of identifier:
\begin{enumerate}
\item
identifiers of type constructor
introduced with the interfaces defined in \cite{DS/FMU/IED/DTD012};
\item
identifiers of constants
introduced with the interfaces defined in \cite{DS/FMU/IED/DTD012};
\item
identifiers which have been declared as type abbreviations;
\item
identifiers which have been declared as aliases;
\item
identifiers which have been declared as binders, postfixes, infixes or prefixes;
\item
identifiers which have been declared as terminators.
\end{enumerate}

\section{PREAMBLE}
=DOC
signature SymbolTable = sig
=DESCRIBE
This is the signature for the structure which contains the symbol
table and its access functions.
This structure contains private functions which are invoked as one
navigates around the theory database.
These private functions may give rise to error 20001 if the
theory database user data has been corrupted (e.g. by explicit and incorrect use
of the lower level interfaces).

Any of the functions in the structure which update the current theory may
give rise to error 20002

=FAILURE
20001	A symbol table entry in theory ?0 is corrupt (use restore_defaults to clear)
20002	The current theory, ?0, is not open for writing
20003	Internal error: ?0
=ENDDOC
\section{DATA TYPES}\label{DATATYPES}
The following type is used to communicate syntactic status information.
=DOC
datatype FIXITY	=	Nonfix
			|	Binder
			|	Infix of int
			|	Prefix of int
			|	Postfix of int;
=DESCRIBE
This data type is used in the symbol table and elsewhere to give the
syntactic status of a name. $Nonfix$ means no special status.
The integer components are the precedences
for infix, prefix or postfix status.
=ENDDOC

\section{ACCESS FUNCTIONS}
\subsection{Terminators}
Errors in this subsection start with 201.

=DOC
	val âget_current_terminatorsá : unit -> string list list;
=DESCRIBE
$get\_current\_terminators()$ returns the list of identifiers which have been
declared as terminators in the current context using $new\_terminator$. The 
names are returned in exploded form, i.e. as a list of strings each containing
one character.
=ENDDOC
=DOC
	val âdeclare_terminatorá : string -> unit
=DESCRIBE
$declare\_terminator\,s$ checks that $s$ is a valid terminator, and if so declares
that $s$ is to be used as a lexical terminator in the current context.
=FAILURE
20101	The string ?0 is not a valid terminator. Terminators must start
	with a symbolic character, must not contain spaces,
	and must not end with underscore, %up% or %down%
20102	The string ?0 is already declared as a terminator
=ENDDOC
=DOC
	val âundeclare_terminatorá : string -> unit
=DESCRIBE
$undeclare\_terminator\,s$ removes $s$
from the list of identifiers which act as terminators for parsing purposes
in the current context.
=FAILURE
20103	?0 is not in the list of terminators in the current context
=ENDDOC
\subsection{Fixity}
Errors in this subsection should start with 202.

Note that there are not undeclare operations in this section. A fixity
declaration may be suppressed by a nonfix declaration. 
=DOC
	val âdeclare_binderá : string -> unit;
=DESCRIBE
$declare\_binder\,s$ declares $s$ to have the syntactic status of a binder
in the current context.
No checks are made on the form of $s$
=ENDDOC

=DOC
	val âdeclare_infixá : (int * string)-> unit;
=DESCRIBE
$declare\_infix\,(s, p)$ declares $s$ to have the syntactic status of an
infix operator with precedence $p$
in the current context.
No checks are made on the form of $s$
=ENDDOC
=ENDDOC

=DOC
	val âdeclare_prefixá : (int * string) -> unit;
=DESCRIBE
$declare\_prefix\,(s, p)$ declares $s$ to have the syntactic status of a
prefix operator with precedence $p$ in the current context.
No checks are made on the form of $s$
=ENDDOC

=DOC
	val âdeclare_postfixá : (int * string) -> unit;
=DESCRIBE
$declare\_postfix\,(s, p)$ declares $s$ to have the syntactic status of a
postfix operator with precedence $p$ in the current context.
No checks are made on the form of $s$
=ENDDOC

=DOC
	val âdeclare_nonfixá : string -> unit;
=DESCRIBE
$declare\_nonfix\,s$ declares $s$ to have no special
syntactic status in the current context.
No checks are made on the form of $s$
=ENDDOC
In line with the principle that everything should be undoable,
$declare\_nonfix$ actually deletes the symbol table record for the identifier
if the symbol table record for it
has $ty\_info$ and $const\_info$ field $Nil$ and language field
the same as the language of the current theory.

=DOC
	val âget_fixityá : string -> FIXITY;
=DESCRIBE
$get\_fixity\,s$ returns the syntactic status of $s$ in the current context.
=ENDDOC
\subsection{Constants and Aliases}
Errors in this subsection start with 203.

$get\_const\_info$ is the interface which the type inferrer will use to
give the type associated with a name in a parsed term. The type it should use
is the first element of the pair.

$get\_const\_info\,s$ is $Nil$ for an identifier, $s$ which is not the name of a constant 
or an alias in the current context.
If s is a constant or an alias $get\_const\_info\,s$
has the form $Value(\tau, [(s_1, \tau_1), \ldots, (s_k, \tau_k)])$.
Each $s_i$ gives the
actual constant name to be associated with an occurrence of $s$
which has type an instance of $\tau_i$.
$\tau$ is the antiunifier of the $\tau_i$. For a constant which is not an
alias $k = 1$ and $\tau = \tau_1$. 


Note that a name may be both an alias and an actual constant name.
For example, in the supplied system the conjunction
$get\_const\_info$``€'' will return something like:
óExample
		Value(»:BOOL‹BOOL‹BOOL¼, [("€", »:BOOL‹BOOL‹BOOL¼)])
æ
The user might wish to overload `€', e.g., by making it an alias of
the function `$fand$' defined by the following theorem:

óExample
	… ƒf g:'a->BOOLŽfand f g x = f x € g x
æ

The effect of the call
óExample
	new_alias("€", »fand:('a->BOOL)‹('a->BOOL)‹('a->BOOL)¼);
æ
is to make the symbol table entry for  `€' something like:

óExample
	Value(»:'b‹'b‹'b¼,
		[("fand", »:('a->BOOL)‹('a->BOOL)‹('a->BOOL)¼),
					 ("€", »:BOOL‹BOOL‹BOOL¼)])
æ


=DOC
	val âget_const_infoá : string -> (TYPE * ((string * TYPE)list)) OPT;
=DESCRIBE
$get\_const\_info\,s$ returns the information associated with
the name $s$ used as a constant name, if any.
See DS/FMU/IED/DTD020 for more information.
=ENDDOC


=DOC
	val âdeclare_aliasá : (string * TERM) -> unit;
=DESCRIBE
$declare\_alias\,(s, c)$ declares $s$ as an alias for the constant $c$.
=FAILURE
20301	The term ?0 is not a constant
20302	The string ?0 is already in use as an alias for ?1
20305	The constant ?0 is not in scope
=ENDDOC
=DOC
	val âundeclare_aliasá : (string * TERM) -> unit;
=DESCRIBE
$undeclare\_alias\,(s, c)$ reverses the effect
of a declaration of $s$ as an alias for the constant $c$ in the current context.
=FAILURE
20301	The term ?0 is not a constant
20303	The identifier ?0 is not declared as an alias for ?1
=ENDDOC

=DOC
	val âresolve_aliasá : (string * TYPE) -> TERM;
=DESCRIBE
$resolve\_alias(s, \tau)$ returns a term of the form $mk\_const(c, \tau)$ where
$c$ is the ``best' resolution for the identifier $s$. This best resolution
will be $s$ if $s$ has been introduced as a constant of type $\tau'$
where $\tau'$ is an instance of $\tau$.
If $s$ is an alias then $c$ is taken from the alias declaration for $s$
in which the aliased constant has a type $\tau'$ which can be instantiated
to $\tau$. If more than one such declaration is applicable the most recent
one is used. 
=FAILURE
20304	The identifier ?0 is not a valid constant name (or alias) at this type
=ENDDOC


=DOC
	val âget_aliasá : (string * TYPE) -> string;
=DESCRIBE
$resolve\_alias(c, \tau)$ returns the most appropriate alias for the constant
with name $c$ at the type $\tau$.
If no aliases for the name $c$ have been declared then $c$ is returned
otherwise the most recent alias $s$ associated with a type $\tau'$ which
can be instantiated to $\tau$ is returned.
=ENDDOC

\subsection{Types and Type Abbreviations}
Errors in this subsection start with 204.

$get\_type\_info\,s$ returns information about the identifier $s$ when
it appears as a type constructor or type abbreviation.
$get\_type\_info\,s$ is $Nil$ for an identifier
which is not a type constructor or a type
abbreviation in the current context.
Otherwise $get\_type\_info\,s$
gives the arity of the constructor or abbreviation and
a field which is $Nil$ for a constructor and which otherwise
gives the type for which $s$ is an abbreviation
together with the names of its formal parameters.

=DOC
	val âget_type_infoá : string -> (int * (string list * TYPE) OPT) OPT;
=DESCRIBE
$get\_type\_info\,s$ returns the type information, if any, associated
with $s$.
See DS/FMU/IED/DTD020 for more information.
=ENDDOC
=DOC
	val âdeclare_type_abbrevá : (string * string list * TYPE) -> unit;
=DESCRIBE
$declare\_type\_abbrev\,(s, [\alpha_1, \ldots, \alpha_k], \tau)$
declares $(\alpha_1, \ldots, \alpha_k)s$
as a type abbreviation for the type $\tau$.
The identifier $s$ may not already have been declared as
a type abbreviation or be the name of a type constructor defined in
the present context, in which cases a warning message is issued.
=FAILURE
20401	The identifier ?0 is already declared as a type abbreviation
20402	The identifier ?0 is already declared as a type constructor
20407	The formal parameter list ?0 contains duplicate type variable names
=ENDDOC
=DOC
	val âundeclare_type_abbrevá : string -> unit;
=DESCRIBE
$undeclare\_type\_abbrev\,(s, [\alpha_1, \ldots, \alpha_k], \tau)$
reverses the effect of a declaration of $s$ as a type abbreviation.
=FAILURE
20403	The identifier ?0 is not declared as a type abbreviation
=ENDDOC

=DOC
	val âis_type_abbrevá : string -> bool;
=DESCRIBE
$is\_type\_abbrev$ returns $true$ iff. $s$ is declared as a type abbreviation
=ENDDOC

=DOC
	val âexpand_type_abbrevá : (string * TYPE list) -> TYPE;
=DESCRIBE
$expand\_type\_abbrev\,s,[\tau_1, \ldots, \tau_k]$ is the
expansion of the type abbreviation $s$ with respect to the arguments
$[\tau_1, \ldots, \tau_k]$. 
=FAILURE
20404	The identifier ?0 is not declared as a type abbreviation
20405	The type abbreviation ?0 should have ?1 argument not ?2
20406	The type abbreviation ?0 should have ?1 arguments not ?2
=ENDDOC
\subsection{Languages}
Errors in this subsection start with 205.

The symbol table stores a language indicator in each theory.
This determines the language in the symbol table records for the names
in that theory. The language indicator for a new theory is initially taken
from its (first) parent. The language indicator for the initial theory
$MIN$ is set to ``$HOL$''.
=DOC
	val âset_current_languageá : string -> unit;
=DESCRIBE
$set\_current\_language\,s$ sets the language indicator associated with
the current theory to $s$.
=ENDDOC
=DOC
	val âget_current_languageá : unit -> string;
=DESCRIBE
$get\_current\_language\,()$ returns the language indicator associated with
the current theory.
=ENDDOC
=DOC
	val âget_const_languageá : string -> string;
=DESCRIBE
$get\_const\_language\,s$ returns the language indicator associated with
the name $s$ when used as a constant
in the current context. If there is no constant
called $s$, then $get\_const\_language\,s$ returns the language indicator associated
with the current theory. The language indicator
``$HOL$'' for all identifers supplied as part of the ICL HOL system.
=ENDDOC
=DOC
	val âget_type_languageá : string -> string;
=DESCRIBE
$get\_type\_language\,s$ returns the language indicator associated with
the name $s$ when used as a type constructor
in the current context. If there is no type constructor
called $s$, then $get\_type\_language\,s$ returns the language indicator associated
with the current theory. The language indicator
``$HOL$'' for all identifers supplied as part of the ICL HOL system.
=ENDDOC

\subsection{Theory Access Functions}
Errors in this subsection start with 206.

This section contains functions for accessing the symbol table records in
a given theory. The main client for these facilities is the theory
lister \cite{DS/FMU/IED/DTD03}, but they are, potentially, generally
useful. 

=DOC
	val âget_terminatorsá : string -> string list;
=DESCRIBE
$get\_binders\,thy$ returns the list of identifiers which have been
declared as terminators in the theory $thy$.
=FAILURE
20601	There is no theory called ?0
=ENDDOC

=DOC
	val âget_bindersá : string -> string list;
=DESCRIBE
$get\_binders\,thy$ returns the list of identifiers which have been
declared as binders in the theory $thy$.
=FAILURE
20601	There is no theory called ?0
=ENDDOC
=DOC
	val âget_infixesá : string -> string list;
=DESCRIBE
$get\_infixes\,thy$ returns the list of identifiers which have been
declared as infix operators in the theory $thy$.
=FAILURE
20601	There is no theory called ?0
=ENDDOC
=DOC
	val âget_prefixesá : string -> string list;
=DESCRIBE
$get\_prefixes\,thy$ returns the list of identifiers which have been
declared as prefix operators in the theory $thy$.
=FAILURE
20601	There is no theory called ?0
=ENDDOC
=ENDDOC
=DOC
	val âget_postfixesá : string -> string list;
=DESCRIBE
$get\_postfixes\,thy$ returns the list of identifiers which have been
declared as postfix operators in the theory $thy$.
=FAILURE
20601	There is no theory called ?0
=ENDDOC

=DOC
	val âget_nonfixesá : string -> string list;
=DESCRIBE
$get\_nonfixes\,thy$ returns the list of identifiers which have
had their binder, infix, prefix, or postfix syntactic status
suppressed in the theory $thy$.
=FAILURE
20601	There is no theory called ?0
=ENDDOC
=DOC
	val âget_type_abbrevsá : string -> string list;
=DESCRIBE
$get\_type\_abbrevs\,thy$ returns the list of identifiers which
have been declared as type abbreviations in the theory $thy$.
=FAILURE
20601	There is no theory called ?0
=ENDDOC
=DOC
	val âget_undeclared_type_abbrevsá : string -> string list;
=DESCRIBE
$get\_undeclared\_type\_abbrevs\,thy$ returns the list of identifiers which have
have had their status as type abbreviations suppressed in the theory $thy$.
=FAILURE
20601	There is no theory called ?0
=ENDDOC
=DOC
	val âget_aliasesá : string -> string list;
=DESCRIBE
$get\_aliases\,thy$ returns the list of identifiers which have
have been declared as aliases in the theory $thy$.
=FAILURE
20601	There is no theory called ?0
=ENDDOC
=DOC
	val âget_undeclared_aliasesá : string -> string list;
=DESCRIBE
$get\_undeclared\_aliases\,thy$ returns the list of identifiers which have
have their status as aliases  suppressed in the theory $thy$.
=FAILURE
20601	There is no theory called ?0
=ENDDOC

=DOC
	val âget_languageá : string -> string;
=DESCRIBE
$get\_language\,thy$ returns the language indicator associated
with the theory $thy$.
=FAILURE
20601	There is no theory called ?0
=ENDDOC


\subsection{Miscellaneous}
Errors in this subsection start with 207.

=DOC
	val âget_const_theoryá : string -> string;
=DESCRIBE
$get\_undeclared\_aliases\,c$ returns the name of the theory in which the constant
$c$ is defined.
=FAILURE
20701	There is no constant called ?0 in the current context
=ENDDOC
=DOC
	val âget_type_theoryá : string -> string;
=DESCRIBE
$get\_undeclared\_aliases\,ty$ returns the name of the theory in which the
type constructor $ty$ is defined.
=FAILURE
20702	There is no type constructor called ?0 in the current context
=ENDDOC

=DOC
	val ârestore_defaultsá : unit -> unit;
=DESCRIBE
$restore\_defaults()$ may be used to clear corrupted symbol
table information in the current theory. It does this by restoring the theory
to the state it would have if no terminator, fixity, alias, type abbreviations
or language declarations had been performed. A warning message is issued
(and the interactive user is prompted as to whether to continue) before the
operation is performed.
=FAILURE
20703	This operation will delete all symbol table information from theory ?0
=ENDDOC

=SML
end; (* of signature SymbolTable *)
=TEX
\section{TEST POLICY}
The symbol table functions are to be tested according to the
general criteria laid down in the quality plan, \cite{DS/FMU/IED/PLN008}.
\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}
