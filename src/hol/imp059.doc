=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Product Types}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP059}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation
of the tools for introducing HOL product types.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1] 
First version.
\item [Issues 1.2,1.3] 
Try based on cacheing implications.
\item [Issue 1.4]
Split cacheing into two.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Tools introducing HOL product types are called for in \cite{DS/FMU/IED/HLD010}.
A design for such tools is given in \cite{DS/FMU/IED/DTD059}.
This document provides an implementations for them.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation for the
tools introducing HOL product types.

$labelled\_product\_spec$ and $unlabelled\-\_product\-\_spec$
are implemented in terms of the subsidiary functions $cached\-\_(un)labelled\-\_product\-\_rule$,
and, should they require a new invocation of those function,
will take longer.
With the current implementation (January 1992) the timings for proving labelled and unlabelled cacheing theorems assuming that the $n - 1^{th}$ theorem is cached, and
labelled and unlabelled product types assuming the required cached theories are present,
are as follows:

\begin{tabular} {l | l l l l l l l l l l l}
n = & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\ \hline
lab. cache & 1.1 & 1.1 & 1.9 & 2.5 & 3.3 & 4.8 & 6.7 & 9.4 & 12.3 & 16.4 & 21.3 \\
unlab. cache & 0.8 & 1.0 & 1.5 & 2.0 & 2.1 & 2.8 & 4.0 & 4.8 & 6.0 & 7.4 &  9.3 \\
lab. & 0.4  & 0.9 & 1.1 & 1.5 & 2.3 & 3.3 & 4.3 & 5.8 & 7.3 & 9.5 & 12.1 \\
unlab. & 0.4 & 0.6 & 1.1 & 1.5 & 1.9 & 2.9 & 3.8 & 4.6 & 6.2 & 7.4 & 9.3 \\
\end{tabular}

\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD059}.
\subsubsection{Deficiencies}
In particular circumstances a function might add material into theories
but not complete the requested additions, leving an untidy state.
This would be particularly unfortunate in a cache theory,
where the partial effort cannot be deleted.
Some effort is made to prevent this, but it is not completely secured.
\subsubsection{Possible Enhancements}
None known.

\section{PREAMBLE}
=SML
structure âProductTypesá : ProductTypes = struct
=TEX
We need to work in some cache theory, probably set aside for that purpose alone.
=SML
val lthy = get_current_theory_name ();
val _ = open_theory "pair";
val _ = push_proof_context pair_epc;
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",
	true);
=TEX
\section{UTILITIES}
Still not global!
=SML
fun âlist_mk_‹_typeá ([ty]:TYPE list):TYPE = ty
| list_mk_‹_type (a :: x) = mk_‹_type (a, list_mk_‹_type x)
| list_mk_‹_type [] = fail "list_mk_‹_type" 0 [];
=TEX
=SML
fun âstrip_‹_typeá (ty:TYPE):TYPE list = (
let	val (ty1,ty2) = dest_‹_type ty
in
	ty1 :: strip_‹_type ty2
end
handle (Fail _) => [ty]);
=TEX
Some type variables:
=SML
val âtvaá = »:'a¼;
val âtvbá = »:'b¼;
val âtvcá = »:'c¼;
val âtv1á = »:'1¼;
val âtv2á = »:'2¼;
=TEX
Create $:(...((ty1 ‰ ty2) ‰ ty3) ...)$:
=SML
fun ârlist_mk_‰_typeá tys = (
let	fun aux [ty] = ty
	| aux (ty :: rest) = mk_‰_type(aux rest,ty)
	| aux _ = fail "rlist_mk_‰_type" 0 [];
in
	aux (rev tys)
end);
=TEX
Create $(...((c1\ €\ c2)\ €\ c3)...)$:
=SML
fun ârlist_mk_€á cnjs = (
let	fun aux [cnj] = cnj
	| aux (cnj :: rest) = mk_€(aux rest,cnj)
	| aux _ = fail "rlist_mk_€" 0 [];
in
	aux (rev cnjs)
end);
=TEX

\subsection{Timing}
The following value allows timing to be invoked as on one off
(false invokes timing).
A reference variable is inappropriate.
These functions are not currently used in the document,
but would become useful if further tuning is required.
=SML
val ânotimingá = true;
=TEX
Time the application of a tactic to a goal, and its resulting proof to its
arguments.
=SML
fun âTIME_Tá (name:string) (tac : TACTIC) : TACTIC = (
	if notiming 
	then tac
	else (fn (asms_gl) =>
let	val t1 = System.processtime ();
	val (sgs,prf) = tac asms_gl;
	val sideeffect = diag_string("Tactic setting for "^
		name^" took:"^
		string_of_int(System.processtime ()-t1));
in
	(sgs,(fn x => 
	let	val t2 = System.processtime ();
		val res = prf x;
		val sideeffect = diag_string("Tactic proof for "^
			name^" took:"^
			string_of_int(System.processtime ()-t2));
	in
		res
	end))
end));
=TEX
Time the application of a rule to a theorem.
=SML
fun âtime_ruleá (name:string) (rule : THM -> THM) : THM -> THM = (
	if notiming
	then rule
	else (fn (thm : THM) =>
let	val t1 = System.processtime ();
	val s1 = rule thm;
	val sideeffect = diag_string("Rule "^
			name^" took:"^
			string_of_int(System.processtime ()-t1));
in
	s1
end));
=TEX
Time the application of a theorem tactical:
=SML
fun âTIME_TTCLá (name:string) ttcl (ttac:THM -> TACTIC)(thm : THM) : TACTIC = (
	if notiming
	then ttcl ttac thm
	else
	(fn (asms_gl) =>
let	val t1 = System.processtime ();
	val (sgs,prf) = ttcl ttac thm asms_gl;
	val sideeffect = diag_string("Ttcl setting for "^
		name^" took:"^
		string_of_int(System.processtime ()-t1));
in
	(sgs,(fn x => 
	let	val t2 = System.processtime ();
		val res = prf x;
		val sideeffect = diag_string("Ttcl proof for "^
			name^" took:"^
			string_of_int(System.processtime ()-t2));
	in
		res
	end))
end));
=TEX

\subsection{Conversionals}
Distribute two always successful conversions over a conjunction:
=SML
fun â€_C2á conv1 conv2 tm = (
let	val (cnjt1,t2) = dest_app tm;
	val (cnj,t1) = dest_app cnjt1;
in
	mk_app_rule(ap_fun_rule cnj (conv1 t1))(conv2 t2)
end);
=TEX
Apply a conversion to the leftmost conjunction.
=SML
fun âLEFTMOST_€_Cá conv : CONV = (fn tm =>
	if is_€ tm
	then RATOR_C(RAND_C(LEFTMOST_€_C conv)) tm
	else conv tm
);
=TEX
Apply a conversion to all conjuncts nested by $((...(c1 € c2) € c3 ...)$.
=SML
fun âLALL_€_Cá conv : CONV = (fn tm =>
	if is_€ tm
	then APP_C ((RAND_C(LALL_€_C conv)), conv) tm
	else conv tm
);
=TEX
\subsection{Rules}
A limited form of matching $type\_lemmas\_thm$:
=RULE
simple_match_type_lemmas_thm
É
… „ f: ty1 ‹ ty2 Ž TypeDefn ( x Ž T) f
É
… „ abs repŽ (ƒ a:ty1Ž abs (rep a) = a) € 
	(ƒ r:ty2Ž rep (abs r) = r)
=TEX
=SML
local
	val s1 = simple_ƒ_elim »( x:'b Ž T)¼ type_lemmas_thm;
	val s2 = rewrite_rule [] s1;
	val atype = »:'a ‹ 'b¼;
in
fun âsimple_match_type_lemmas_thmá (thm : THM) : THM = (
let	val (f,_) = dest_simple_„(concl thm);
	val (ty1,ty2) = dest_‹_type (type_of f);
	val tyinsts = [(ty1,tva),(ty2,tvb)];
in
	Š_elim (inst_type_rule tyinsts s2) thm
end
handle complaint =>
reraise complaint "simple_match_type_lemmas_thm");
end;
=TEX
\subsection{Theorems}
=SML
val âpair_eq_thmá = tac_proof(([],
	»ƒ x y p qŽ ((x,y) = (p,q)) ‚ ((x = p) € (y = q))¼),
		rewrite_tac[pair_clauses]);
=TEX
=SML
val â„__x_t_thmá = tac_proof(([],»„ x:'a Ž ( x Ž T) x¼),
	rewrite_tac[]);
=TEX
Each theorem in the below is associated with a ``matching''
conversion.
=SML
val âlpair_ƒ_thmá = (
	push_goal([],»ƒ f Ž (ƒ p : '1 ‰ '2 Ž f p) 
		‚
		(ƒ p1 p2 Ž f (p1,p2))¼);
	a(REPEAT strip_tac);
	(* *** Goal "1" *** *)
	a(asm_rewrite_tac[]);
	(* *** Goal "2" *** *)
	a(LEMMA_T »p = (Fst p,Snd p)¼ once_rewrite_thm_tac);
	(* *** Goal "2.1" *** *)
	a(rewrite_tac[pair_clauses]);
	(* *** Goal "2.2" *** *)
	a(asm_rewrite_tac[]);
	rewrite_rule[eta_axiom](pop_thm()));
=TEX
=CONVERSION
lpair_ƒ_conv
»ƒ p : '1 ‰ '2 Ž f[p]¼
É
É
… (ƒ p : '1 ‰ '2 Ž f[p]) ‚ 
	(ƒ p1 p2 Ž f [(p1, p2)])
=TEX
=SML
local
	val atype = »:'1 ‰ '2¼;
in
fun âlpair_ƒ_convá tm = (
let	val (_,abs) = dest_app tm;
	val ptype = fst(dest_‹_type(type_of abs));
	val tyinsts = type_match ptype atype;
	val s1 = simple_ƒ_elim abs 
		(inst_type_rule tyinsts lpair_ƒ_thm);
	val s2 = conv_rule(RAND_C(BINDER_C
		(BINDER_C simple_%beta%_conv))) s1;
in
	s2
end
handle complaint =>
reraise complaint "lpair_ƒ_conv");
end; (* of local *)
=TEX
=SML
val lpair_„_thm = (
	push_goal([],»ƒ f Ž („ p : '1 ‰ '2 Ž f p) 
		‚
		(„ p1 p2 Ž f (p1,p2))¼);
	a(REPEAT strip_tac);
	(* *** Goal "1" *** *)
	a(simple_„_tac »Fst p¼ THEN simple_„_tac »Snd p¼);
	a(pure_rewrite_tac[pair_clauses] THEN goal_in_asms_tac);
	(* *** Goal "2" *** *)
	a(simple_„_tac »(p1,p2)¼ THEN goal_in_asms_tac);
	rewrite_rule[eta_axiom](pop_thm()));
=TEX
=CONVERSION
lpair_„_conv
»„ p : '1 ‰ '2 Ž f[p]¼
É
É
… („ p : '1 ‰ '2 Ž f[p]) ‚ 
	(„ p1 p2 Ž f [(p1, p2)])
=TEX
=SML
local
	val atype = »:'1 ‰ '2¼;
in
fun âlpair_„_convá tm = (
let	val (_,abs) = dest_app tm;
	val ptype = fst(dest_‹_type(type_of abs));
	val tyinsts = type_match ptype atype;
	val s1 = simple_ƒ_elim abs (inst_type_rule tyinsts lpair_„_thm);
	val s2 = conv_rule(RAND_C(BINDER_C
		(BINDER_C simple_%beta%_conv))) s1;
in
	s2
end
handle complaint =>
reraise complaint "lpair_„_conv");
end; (* of local *)
=TEX
=SML
val lpair_„_thm1 = (
	push_goal([],»ƒ f Ž („ p : 'a ‹ '1 ‰ '2 Ž f p) 
		‚
		(„ p1 p2 Ž f ( x Ž (p1 x,p2 x)))¼);
	a(REPEAT strip_tac);
	(* *** Goal "1" *** *)
	a(simple_„_tac »( x Ž Fst (p x))¼ THEN 
	  simple_„_tac »( x Ž Snd (p x))¼);
	a(rewrite_tac[pair_clauses, eta_axiom] THEN goal_in_asms_tac);
	(* *** Goal "2" *** *)
	a(simple_„_tac »( xŽ (p1 x, p2 x))¼ THEN goal_in_asms_tac);
	rewrite_rule[eta_axiom](pop_thm()));
=TEX
=CONVERSION
lpair_„_conv1
»„ p : 'a ‹ '1 ‰ '2 Ž f[p]¼
É
É
… („ p : 'a ‹ '1 ‰ '2 Ž f[p]) ‚ 
	(„ p1 p2 Ž f [( x Ž (p1 x, p2 x))])
=TEX
=SML
local
	val atype = »: 'a ‹ '1 ‰ '2¼;
in
fun âlpair_„_conv1á tm = (
let	val (_,abs) = dest_app tm;
	val ptype = fst(dest_‹_type(type_of abs));
	val tyinsts = type_match ptype atype;
	val s1 = simple_ƒ_elim abs (inst_type_rule tyinsts lpair_„_thm1);
	val s2 = conv_rule(RAND_C(BINDER_C(BINDER_C simple_%beta%_conv))) s1;
in
	s2
end
handle complaint =>
reraise complaint "lpair_„_conv1");
end; (* of local *)
=TEX
=SML
val â„_pair_conv_thmá = (
	push_goal([],»ƒ f Ž($„ (f: (('1 ‰ '2) ‹ 'a) ‹ BOOL)) ‚
		(„ con' Ž f ( (x, y) Ž  con' x y))¼);
	a(once_rewrite_tac[eq_sym_rule
		(simple_ƒ_elim »f:(('1 ‰ '2) ‹ 'a) ‹ BOOL¼
		(inst_type_rule [(»:(('1 ‰ '2) ‹ 'a)¼,»:'a¼),
			(»:BOOL¼,»:'b¼)] eta_axiom))]);
	a(rewrite_tac[]);
	a(REPEAT strip_tac);
	(* *** Goal "1" *** *)
	a(simple_„_tac » p q Ž x (p,q)¼);
	a(rewrite_tac[eta_axiom]);
	a(LEMMA_T »( (x',q) Ž x(x',q)) = ( y Ž x y)¼
		(fn x => asm_rewrite_tac[x,eta_axiom]));
	a (rewrite_tac[ext_thm, pair_clauses]);
	(* *** Goal "2" *** *)
	a(simple_„_tac »( (x, y)Ž con' x y)¼ THEN goal_in_asms_tac);
	pop_thm());
=TEX
=CONVERSION
l„_pair_conv
»„ p : '1 ‰ '2 ‹ 'a Ž f[p]¼
É
É
… („ p : '1 ‰ '2 ‹ 'a Ž f[p]) ‚ 
	(„ p' Ž f [((x,y) Ž p' x y)])
=TEX
=SML
local
	val atype = »:'1 ‰ '2 ‹ 'a¼;
in
fun âl„_pair_convá tm = (
let	val (_,abs) = dest_app tm;
	val ptype = fst(dest_‹_type(type_of abs));
	val tyinsts = type_match ptype atype;
	val s1 = simple_ƒ_elim abs (inst_type_rule tyinsts „_pair_conv_thm);
	val s2 = conv_rule(RAND_C(BINDER_C simple_%beta%_conv)) s1;
in
	s2
end
handle complaint =>
reraise complaint "l„_pair_conv");
end; (* of local *)
=TEX
=SML
local
	val uncurry_def = (get_defn "pair" "Uncurry");
in
val âl_%beta%_convá : CONV = (fn tm =>
let	val (p,q) = dest_app tm;
	val (q1,q2) = dest_pair q;
	val (uc,p') = dest_app p;
	val sideeffect = if fst(dest_const uc) <> "Uncurry"
		then fail "l_%beta%_conv" 0 []
		else ();
	val tyinsts = [(type_of q1,tva),(type_of q2,tvb),
		(snd(dest_‹_type(snd(dest_‹_type(type_of p')))),tvc)];
	val s1 = inst_type_rule tyinsts uncurry_def;
	val s2 = list_simple_ƒ_elim[p',q1,q2] s1;
	val s3 = conv_rule(RAND_C((RATOR_C simple_%beta%_conv) THEN_C
		simple_%beta%_conv)) s2;
in
	s3
end);
end;
=TEX
\section{MAIN FUNCTIONS}
\subsection{Theory Caches}
We must have an initial cache theory to allow the special case
of $cached\_product\_rule$ $1$ to be saved.
We currently assume it is the current theory.
=SML
local
	val cache_theories: string list ref = ref [get_current_theory_name ()];
in
fun âset_cache_theoriesá (slst: string list) : unit = (
	cache_theories := slst
);
fun âget_cache_theoriesá (():unit) : string list = (!cache_theories);
end;
=TEX
\subsection{Defining n-tuples}
We will declare the method of getting the two keys 
for saving cached theorems once for all.
=SML
fun âclp_keyá (num:int):string = string_of_int num ^ "CachedLabelledProduct";
fun âcup_keyá (num:int):string = string_of_int num ^ "CachedUnlabelledProduct";
=TEX
We need to initialise $cached\_labelled\_product\_rule$ by saving the result of $cached\_labelled\_product\_rule$ $1$ in the initial cache theory,
and similarly with the unlabelled product.
=SML
val _ = open_theory(hd(get_cache_theories()));
=TEX
=SML
val âcache_labelled_thm1á = (
	push_goal([],
	»(„ abs : '1 ‹ 'a Ž
	 „ rep : 'a ‹ '1 Ž
	 (ƒ aŽ abs(rep a) = a) € (ƒ r Ž rep(abs r) = r))
	Š
	„ 1Tuple:'1 ‹ 'a Ž
	(„ Lab1_1Ž ƒ t x1Ž Lab1_1 (1Tuple x1) = x1 € 1Tuple (Lab1_1 t) = t)¼);
	a strip_tac;
	a(simple_„_tac »abs : '1 ‹ 'a¼);
	a(simple_„_tac »rep:'a ‹ '1¼ THEN asm_rewrite_tac[]);
	pop_thm());
=TEX
=SML
val âcache_unlabelled_thm1á = (
	push_goal([],
	»(„ abs : '1 ‹ 'a Ž
	 „ rep : 'a ‹ '1 Ž
	 (ƒ aŽ abs(rep a) = a) € (ƒ r Ž rep(abs r) = r))
	Š
	„ 1Tuple:'1 ‹ 'a Ž
	(ƒ x1 y1Ž 1Tuple x1 = 1Tuple y1 ‚ x1 = y1) € 
		(ƒ tŽ „ x1Ž t = 1Tuple x1)¼);
	a strip_tac;
	a(simple_„_tac »abs : '1 ‹ 'a¼);
	a(REPEAT €_tac);
	a(REPEAT simple_ƒ_tac THEN ‚_T2 
		(fn thm => ante_tac(ap_fun_rule »rep:'a ‹ '1¼  thm) THEN
		asm_rewrite_tac[])
		(fn thm => pure_rewrite_tac[thm, eq_rewrite_thm]));
	a(simple_ƒ_tac THEN simple_„_tac »(rep:'a ‹ '1) t¼ 
		THEN asm_rewrite_tac[]);
	pop_thm());
=TEX
Now we can define $cached\_labelled\_product\_rule$ itself.
=SML
fun âcached_labelled_product_ruleá (arg: int) : THM = (
let
	val was_thy = get_current_theory_name();
=TEX
The following finds pre-existing copies of the $cached\_product\_rule$
theorem, should they exist.
=SML
fun âfind_n_tupleá (n:int):THM OPT = (
let	val key = clp_key n;
	fun aux [] = Nil
	| aux (thy :: rest) = (Value(get_thm thy key)
		handle (Fail _) => aux rest);
in
		aux (get_cache_theories())
end);
=TEX
The following declares a new n-tuple type, knowing that the type isn't
in scope.
=SML
fun âdeclare_n_tupleá (n:int) :THM = (
let	val cache_thy = (hd(get_cache_theories()))
		handle complaint =>
		divert complaint "hd" "cached_labelled_product_rule" 59006 [];
	val sideeffect = if is_theory_ancestor cache_thy was_thy
		then ()
		else fail "cached_labelled_product_rule" 59002 
			[fn () => cache_thy];
	val last_thm = cached_labelled_product_rule (n-1);
	val sideeffect = diag_string(get_error_message 59012 [string_of_int n]);
in let
	val sideeffect = open_theory cache_thy;
	val nstr = string_of_int n;
	val key = clp_key n;
	val inters = map string_of_int (interval 1 n);
	val tyvars = map (fn x => mk_vartype("'"^ x)) inters;
	val xi = map (fn x => mk_var("x"^x,mk_vartype("'"^ x))) inters;
	val yi = map (fn x => mk_var("y"^x,mk_vartype("'"^ x))) inters;
	val ntuple = mk_var(nstr^ "Tuple",list_mk_‹_type (tyvars @ [tva]));
	val labstr = "Lab"^nstr^"_";
	val labs = map (fn x => mk_var(labstr^x,
		mk_‹_type(tva,mk_vartype("'"^x)))) inters;
	val t = mk_var("t",tva);
	val ntuple_args = list_mk_app(ntuple,xi);
	val succedent = mk_simple_„(ntuple,
		list_mk_simple_„(labs,
		list_mk_simple_ƒ((t :: xi),
		rlist_mk_€(
		map (fn (lab,x) =>
		mk_eq(mk_app(lab,ntuple_args),x))
		(combine labs xi)
		@ [mk_eq(
		list_mk_app(ntuple,
		map (fn lab => mk_app(lab,t)) labs),
		t)])))
			);
	val ntuple_type = rlist_mk_‰_type tyvars;
	val abs = mk_var("abs",mk_‹_type(ntuple_type,tva));
	val rep = mk_var("rep",mk_‹_type(tva,ntuple_type));
	val avar = mk_var("a",tva);
	val rvar = mk_var("r",ntuple_type);
	val antecedent = (
		list_mk_simple_„([abs,rep],
		mk_€
		(mk_simple_ƒ(avar,
		mk_eq(mk_app(abs,mk_app(rep,avar)),avar)),
		mk_simple_ƒ(rvar,
		mk_eq(mk_app(rep,mk_app(abs,rvar)),rvar))))
	);
	val thm_concl = mk_Š(antecedent, succedent);
=TEX
We now have the theorems conclusion, $thm\_concl$: now to prove it.
We do so by instantiating the $n-1^{th}$ theorem.
=SML
	val old_tyvars = rev(tl(rev tyvars));
	val tyinsts = ((mk_‰_type(tv1,tv2),tv1) ::
		combine  (tl(tl tyvars)) (tl old_tyvars));
	val s1 = inst_type_rule tyinsts last_thm;
	val s2 = conv_rule (RAND_C(((BINDER_C
		((ALL_SIMPLE_„_C (BINDER_C lpair_ƒ_conv))
			THEN_C lpair_„_conv1
			THEN_C ALL_SIMPLE_„_C
			(ALL_SIMPLE_ƒ_C
			(€_C2
			(LEFTMOST_€_C((RATOR_C(RAND_C simple_%beta%_conv))
				THEN_C (simple_eq_match_1_conv pair_eq_thm))
			)
			(ONCE_MAP_C simple_%beta%_conv))
))
			)
		THEN_C l„_pair_conv THEN_C ONCE_MAP_C l_%beta%_conv)
		) THEN_C
		%alpha%_conv thm_concl) s1;
	val sideeffect = save_thm(key,s2)
		handle complaint =>
		pass_on complaint "save_thm" "cached_labelled_product_rule";
	val sideeffect = open_theory was_thy;
in
	s2
end
handle (complaint as (Fail _)) =>
(open_theory was_thy;
if area_of complaint = "cached_labelled_product_rule"
then reraise complaint "cached_labelled_product_rule"
else fail "cached_labelled_product_rule" 59003 [fn () => string_of_int n])
end
);
=TEX
Main function:
=SML
in
	if arg < 1 
	then fail "cached_labelled_product_rule" 59001 
		[fn () => string_of_int arg]
	else if arg = 1
	then (if is_theory_ancestor "pair" was_thy 
		then cache_labelled_thm1
		else fail "cached_labelled_product_rule" 59017 [])
	else (case (find_n_tuple arg) of
	Value thm => thm
	| Nil => declare_n_tuple arg)

end); (* of cached_labelled_product_rule *)
=TEX
We define $cached\_unlabelled\_product\_rule$ in a similar manner.
=SML
fun âcached_unlabelled_product_ruleá (arg: int) : THM = (
let
	val was_thy = get_current_theory_name();
=TEX
The following finds pre-existing copies of the $cached\_product\_rule$
theorem, should they exist.
=SML
fun âfind_n_tupleá (n:int):THM OPT = (
let	val key = cup_key n;
	fun aux [] = Nil
	| aux (thy :: rest) = (Value(get_thm thy key)
		handle (Fail _) => aux rest);
in
		aux (get_cache_theories())
end);
=TEX
The following declares a new n-tuple type, knowing that the type isn't
in scope.
=SML
fun âdeclare_n_tupleá (n:int) :THM = (
let	val cache_thy = (hd(get_cache_theories()))
		handle complaint =>
		divert complaint "hd" "cached_unlabelled_product_rule" 59006 [];
	val sideeffect = if is_theory_ancestor cache_thy was_thy
		then ()
		else fail "cached_unlabelled_product_rule" 59002 
			[fn () => cache_thy];
	val last_thm = cached_unlabelled_product_rule (n-1);
	val sideeffect = diag_string(get_error_message 59013 [string_of_int n]);
in let
	val sideeffect = open_theory cache_thy;
	val nstr = string_of_int n;
	val key = cup_key n;
	val inters = map string_of_int (interval 1 n);
	val tyvars = map (fn x => mk_vartype("'"^ x)) inters;
	val xi = map (fn x => mk_var("x"^x,mk_vartype("'"^ x))) inters;
	val yi = map (fn x => mk_var("y"^x,mk_vartype("'"^ x))) inters;
	val ntuple = mk_var(nstr^ "Tuple",list_mk_‹_type (tyvars @ [tva]));
	val t = mk_var("t",tva);
	val ntuple_args = list_mk_app(ntuple,xi);
	val succedent = mk_simple_„(ntuple,
		mk_€(
		 (list_mk_simple_ƒ(xi @ yi,mk_‚(
			mk_eq(ntuple_args,list_mk_app(ntuple,yi)),
			rlist_mk_€(map (fn (x,y) => mk_eq(x,y)) (combine xi yi))))),
		 (mk_simple_ƒ(t,
		 list_mk_simple_„(xi,
			 mk_eq(t,ntuple_args))))
		)
	);
	val ntuple_type = rlist_mk_‰_type tyvars;
	val abs = mk_var("abs",mk_‹_type(ntuple_type,tva));
	val rep = mk_var("rep",mk_‹_type(tva,ntuple_type));
	val avar = mk_var("a",tva);
	val rvar = mk_var("r",ntuple_type);
	val antecedent = (
		list_mk_simple_„([abs,rep],
		mk_€
		(mk_simple_ƒ(avar,
		mk_eq(mk_app(abs,mk_app(rep,avar)),avar)),
		mk_simple_ƒ(rvar,
		mk_eq(mk_app(rep,mk_app(abs,rvar)),rvar))))
	);
	val thm_concl = mk_Š(antecedent, succedent);
=TEX
We now have the theorems conclusion, $thm\_concl$: now to prove it.
We do so by instantiating the $n-1^{th}$ theorem.
=SML
	val old_tyvars = rev(tl(rev tyvars));
	val tyinsts = ((mk_‰_type(tv1,tv2),tv1) ::
		combine  (tl(tl tyvars)) (tl old_tyvars));
	val s1 = inst_type_rule tyinsts last_thm;
	val s2 = conv_rule ((RAND_C((BINDER_C
		(€_C2 (lpair_ƒ_conv THEN_C
				ONCE_MAP_C lpair_ƒ_conv THEN_C
				ALL_SIMPLE_ƒ_C (RAND_C(LEFTMOST_€_C 
					(simple_eq_match_1_conv pair_eq_thm))))
				(BINDER_C lpair_„_conv))
		) THEN_C
		l„_pair_conv THEN_C ONCE_MAP_C l_%beta%_conv))
		THEN_C %alpha%_conv thm_concl)
		 s1;
	val sideeffect = save_thm(key,s2)
		handle complaint =>
		pass_on complaint "save_thm" "cached_unlabelled_product_rule";
	val sideeffect = open_theory was_thy;
in
	s2
end
handle (complaint as (Fail _)) =>
(open_theory was_thy;
if area_of complaint = "cached_unlabelled_product_rule"
then reraise complaint "cached_unlabelled_product_rule"
else fail "cached_unlabelled_product_rule" 59004 [fn () => string_of_int n])
end);
=TEX
Main function:
=SML
in
	if arg < 1 
	then fail "cached_unlabelled_product_rule" 59001 
		[fn () => string_of_int arg]
	else if arg = 1
	then (if is_theory_ancestor "pair" was_thy 
		then cache_unlabelled_thm1
		else fail "cached_unlabelled_product_rule" 59017 [])
	else (case (find_n_tuple arg) of
	Value thm => thm
	| Nil => declare_n_tuple arg)

end); (* of cached_unlabelled_product_rule *)
=TEX
\subsection{Labelled Products}
=IGN
new_theory "first_cache_theory";
new_theory "temp";
new_parent "†";

val inp2 = {tyname = "HOLD2",tykey = "HOLD2",conname = "Hold2",
	constkeys= ["Hold2","First2","Second2"],
	labels = [("First2",†),("Second2",»:'1¼)],
	tyvars = Value[»:'1¼,»:'2¼]};
val inp3 = {tyname = "HOLD3",tykey = "HOLD3",conname = "Hold3",
	constkeys= ["Hold3","First3","Second3","Third3"],
	labels = [("First3",†),("Second3",»:'1¼),("Third3",»:'2¼)],
	tyvars = Value[»:'1¼,»:'2¼]};
val inp4 = {tyname = "HOLD4",tykey = "HOLD4",conname = "Hold4",
	constkeys= ["Hold4","First","Second","Third","Fourth"],
	labels = [("First",†),("Second",»:'1¼),("Third",»:'2¼),("Fourth",»:'1 ‰ '2¼)],
	tyvars = Value[»:'1¼,»:'2¼]};

val inp5 = {tyname = "HOLD5",tykey = "HOLD5",conname = "Hold5",
	constkeys= ["Hold5","First5","Second5","Third5","Fourth5","Fifth5"],
	labels = [("First5",†),("Second5",»:'1¼),("Third5",»:'2¼),
		("Fourth5",»:'1 ‰ '2¼),("Fifth5",»:'3¼)],
	tyvars = Value[»:'1¼,»:'2¼,»:'3¼]};
val inp6 = {tyname = "HOLD6",tykey = "HOLD6",conname = "Hold6",
	constkeys= ["Hold6","First6","Second6","Third6","Fourth6",
		"Fifth6","Sixth6"],
	labels = [("First6",†),("Second6",»:'1¼),("Third6",»:'2¼),
		("Fourth6",»:'1 ‰ '2¼),("Fifth6",»:'3¼),("Sixth6",»:'1¼)],
	tyvars = Value[»:'1¼,»:'2¼,»:'3¼]};
val inp7 = {tyname = "HOLD7",tykey = "HOLD7",conname = "Hold7",
	constkeys= ["Hold7","First7","Second7","Third7","Fourth7",
		"Fifth7","Sixth7","Seventh"],
	labels = [("First7",†),("Second7",»:'1¼),("Third7",»:'2¼),
		("Fourth7",»:'1 ‰ '2¼),("Fifth7",»:'3¼),("Sixth7",»:'1¼),
	("Seventh7",»:'1 ‰ '3¼)],
	tyvars = Value[»:'1¼,»:'2¼,»:'3¼]};
val inp8 = {tyname = "HOLD8",tykey = "HOLD8",conname = "Hold8",
	constkeys= ["Hold8","First8","Second8","Third8","Fourth8",
		"Fifth8","Sixth8","Seventh8","Eighth8"],
	labels = [("First8",†),("Second8",»:'1¼),("Third8",»:'2¼),
		("Fourth8",»:'1 ‰ '2¼),("Fifth8",»:'3¼),("Sixth8",»:'1¼),
	("Seventh8",»:'1 ‰ '3¼),("Eighth8",»:'3 ‰ '2¼)],
	tyvars = Value[»:'1¼,»:'2¼,»:'3¼]};
=SML
fun âlabelled_product_specá {tyname:string, tykey:string, conname:string, 
	constkeys:string list, labels:(string*TYPE)list, 
		tyvars:(TYPE list)OPT} : THM = (
let	val sideeffect = if is_nil constkeys orelse is_nil labels
		then fail "labelled_product_spec" 59010 []
		else();
	val nlabels = length labels;
	val tuple_thm = cached_labelled_product_rule nlabels
		handle complaint =>
		pass_on complaint "cached_labelled_product_rule" 
			"labelled_product_spec";
	val tuple_type = fst(dest_‹_type(type_of(fst(dest_simple_„(
		fst(dest_Š (concl tuple_thm)))))));
	val (lab_nms,lab_types) = split labels;
	val rep_type = rlist_mk_‰_type lab_types;
	val lab_tyvars = list_cup(map 
		(fn x => map mk_vartype (type_tyvars x)) lab_types);
	val used_tyvars = case tyvars of
		Nil => lab_tyvars
		| Value tys => (if lab_tyvars subset tys
			then (map dest_vartype tys
				handle complaint =>
				pass_on complaint "dest_vartype" 
					"labelled_product_spec"; tys)
			else fail "labelled_product_spec" 59015 [
			fn () => format_list(dest_vartype) 
				(lab_tyvars diff tys) ", "]);
	val abs_type = mk_ctype(tyname, used_tyvars);
	val „_thm = inst_type_rule[(rep_type, tva)] „__x_t_thm;
=TEX
Before we actually declare the new type we attempt to ensure that we will be able to introduce the new constants
as requested.
We do not catch the failure of constants being already defined in child theories,
nor are we very good at presenting all the errors we know.
=SML
	val used_keys = mapfilter (fn x => (get_defn "-" x;x))
		(tykey :: constkeys);
	val sideeffect = if is_nil used_keys
		then ()
		else fail "labelled_product_spec" 6052 [fn () => hd used_keys,
			fn () => get_current_theory_name ()];
	val used_constants = mapfilter (fn x => (force_value(get_const_type x);x))
		(conname :: lab_nms);
	val sideeffect = if is_nil used_constants
		then ()
		else fail "labelled_product_spec" 6049 
			[fn () => hd used_constants];
=TEX
Now the definition itself, which will flush out any writability problems that constant specification will have.
=SML
	val type_def = new_type_defn (tyname,tykey,map dest_vartype used_tyvars, „_thm)
		handle complaint =>
		pass_on complaint "new_type_defn" "labelled_product_spec";
	val inters = map string_of_int (interval 1 nlabels);
	val tyinsts = (abs_type,tva) :: (combine lab_types 
		(map (fn s => mk_vartype ("'"^s)) inters));
	val tuple_thm' = inst_type_rule tyinsts	tuple_thm;
	val s1 = simple_match_type_lemmas_thm type_def;
	val s2 = Š_elim tuple_thm' s1;
	val labs = map (fn (x,ty) => mk_var(x,mk_‹_type(abs_type,ty))) labels;
	val xi = map mk_var(combine (map (fn x => "x"^x) inters) lab_types);
	val con = mk_var(conname,list_mk_‹_type (lab_types @ [abs_type]));
	val t = mk_var("t",abs_type);
	val con_args = list_mk_app(con,xi);
	val abs = mk_var("abs",mk_‹_type(rep_type,abs_type));
	val rep = mk_var("rep",mk_‹_type(abs_type,rep_type));
	val thm_concl = mk_simple_„(con,
		list_mk_simple_„(labs,
		list_mk_simple_ƒ((t :: xi),
		rlist_mk_€(
		map (fn (lab,x) =>
		mk_eq(mk_app(lab,con_args),x))
		(combine labs xi)
		@ [mk_eq(
		list_mk_app(con,
		map (fn lab => mk_app(lab,t)) labs),
		t)]))));
	val s3 = conv_rule (%alpha%_conv thm_concl) s2;
in
	(new_specification(constkeys,1+nlabels,s3)
		handle complaint =>
		pass_on complaint "new_specification" 
			"labelled_product_spec")
end
handle (complaint as (Fail _)) =>
if area_of complaint = "labelled_product_spec"
then reraise complaint "labelled_product_spec"
else fail "labelled_product_spec" 59014 [fn () => tyname]
); (* labelled_product_spec *)
=TEX
\subsection{Unlabelled Products}
=IGN
val ulp2 = {tyname="ULP2", tykey="ULP2", conname="Ulp2", 
	conkeys=["Ulp2"], tyi=[»:'a ‰ 'b¼,»:'a ‰ 'b¼], 
	tyvars = Value [»:'a¼,»:'b¼]};
val ulp3 = {tyname="ULP3", tykey="ULP3", conname="Ulp3", 
	conkeys=["Ulp3"], tyi=[»:'a ‰ 'b¼,»:'a ‰ 'b¼,»:†¼], 
	tyvars = Value [»:'a¼,»:'b¼]};
val ulp4 = {tyname="ULP4", tykey="ULP4", conname="Ulp4", 
	conkeys=["Ulp4"], tyi=[»:'a ‰ 'b¼,»:'a ‰ 'b¼,»:†¼,»:'c ‰ 'a¼], 
	tyvars = Value [»:'a¼,»:'b¼,»:'c¼]};
val ulp5 = {tyname="ULP5", tykey="ULP5", conname="Ulp5", 
	conkeys=["Ulp5"], tyi=[»:'a ‰ 'b¼,»:'a ‰ 'b¼,»:†¼,»:'c ‰ 'a¼,BOOL], 
	tyvars = Nil};
val ulp6 = {tyname="ULP6", tykey="ULP6", conname="Ulp6", 
	conkeys=["Ulp6"], tyi=[»:'a ‰ 'b¼,»:'a ‰ 'b¼,»:†¼,»:'c ‰ 'a¼,BOOL,»:'1¼], 
	tyvars = Nil};
val ulp7 = {tyname="ULP7", tykey="ULP7", conname="Ulp7", 
	conkeys=["Ulp7"], tyi=[»:'d ‰ BOOL¼,»:'a ‰ 'b¼,»:'a ‰ 'b¼,
		»:†¼,»:'c ‰ 'a¼,BOOL,»:'1¼], 
	tyvars = Nil};
val ulp8 = {tyname="ULP8", tykey="ULP8", conname="Ulp8", 
	conkeys=["Ulp8"], tyi=[»:'d ‰ BOOL¼,»:'a ‰ 'b¼,»:'a ‰ 'b¼,
		»:†¼,»:'c ‰ 'a¼,BOOL,»:'1¼,»:'4¼], 
	tyvars = Nil};
=SML
fun âunlabelled_product_specá {tyname:string, tykey:string, conname:string, 
	conkeys:string list, tyi: TYPE list, tyvars:(TYPE list)OPT} : THM = (
let	val sideeffect = if is_nil conkeys
		then fail "unlabelled_product_spec" 59010 []
		else if is_nil tyi
		then fail "unlabelled_product_spec" 59011 []
		else();
	val nlabels = length tyi;
	val tuple_thm = cached_unlabelled_product_rule nlabels
		handle complaint =>
		pass_on complaint "cached_unlabelled_product_rule" 
			"unlabelled_product_spec";
	val rep_type = rlist_mk_‰_type tyi;
	val lab_tyvars = list_cup(map (fn x => map mk_vartype (type_tyvars x)) tyi);
	val used_tyvars = case tyvars of
		Nil => lab_tyvars
		| Value tys => (if lab_tyvars subset tys
			then (map dest_vartype tys
				handle complaint =>
				pass_on complaint "dest_vartype" 
					"unlabelled_product_spec"; tys)
			else fail "unlabelled_product_spec" 59016 [
				fn () => format_list(dest_vartype) 
				(lab_tyvars diff tys) ", "]);
	val abs_type = mk_ctype(tyname, used_tyvars);
	val „_thm = inst_type_rule[(rep_type, tva)] „__x_t_thm;
=TEX
Before we actually declare the new type we attempt to ensure that we will be able to introduce the new constants
as requested.
We do not catch the failure of constants being already defined in child theories,
nor are we very good at presenting all the errors we know.
=SML
	val used_keys = mapfilter (fn x => (get_defn "-" x;x))
		(tykey :: conkeys);
	val sideeffect = if is_nil used_keys
		then ()
		else fail "labelled_product_spec" 6052 [fn () => hd used_keys,
			fn () => get_current_theory_name ()];
	val sideeffect = case (get_const_type conname) of
		Value _ =>fail "unlabelled_product_spec" 6049 [fn () => conname]
		| Nil => ();
=TEX
Now the definition itself, which will flush out any writability problems that constant specification will have.
=SML
	val type_def = new_type_defn (tyname,tykey,
			map dest_vartype used_tyvars, „_thm)
		handle complaint =>
		pass_on complaint "new_type_defn" "unlabelled_product_spec";
	val inters = map string_of_int (interval 1 nlabels);
	val tyinsts = (abs_type,tva) :: combine tyi 
		(map (fn s => mk_vartype ("'"^s)) inters);
	val tuple_thm' = (inst_type_rule tyinsts tuple_thm);
	val s1 = simple_match_type_lemmas_thm type_def;
	val s2 = Š_elim tuple_thm' s1;
	val s3 = conv_rule(RAND_C (simple_%alpha%_conv conname))
		s2;
in
	(new_specification(conkeys,1,s3)
		handle complaint =>
		pass_on complaint "new_specification" "unlabelled_product_spec")
end
handle (complaint as (Fail _)) =>
if area_of complaint = "unlabelled_product_spec"
then reraise complaint "unlabelled_product_spec"
else fail "unlabelled_product_spec" 59014 [fn () => tyname]
); (* of unlabelled_product_spec *)
=TEX
\section{EPILOGUE}
=SML
val _ = open_theory lthy;
val _ = pop_proof_context();
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",
	lsubgoal_package_quiet);
end; (* of structure ProductTypes *)
open ProductTypes;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN
fun stat_sort (nm1,x1) (nm2,x2) = if x1 = x2
	then stringorder nm1 nm2
	else x1 - x2;
