=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Product Types}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP059}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation
of the tools for introducing HOL product types.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1] 
First version.
\item [Issues 1.2] 
Try based on cacheing implications.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Tools introducing HOL product types are called for in \cite{DS/FMU/IED/HLD010}.
A design for such tools is given in \cite{DS/FMU/IED/DTD059}.
This document provides an implementations for them.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation for the
tools introducing HOL product types.

$labelled\_product\_spec$ and $unlabelled\_product\_spec$
both are implemented in terms of $cached\_product\_rule$,
and, should they require a new invocation of that function,
$cached\-\_product\-\_rule$ about half the total executiontime of the first function, and will take the bulk of the total execution time of the second (unlabelled).
With the current implementation (January 1992) the timings for $cached\-\_product\-\_rule$ are:

\begin{tabular} {l | l l l l l l l l l }
n = & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\ \hline
Time(secs) &  \\
\end{tabular}

\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD059}.
\subsubsection{Deficiencies}
The initial cache theory is not set to a necessarily good value.
\subsubsection{Possible Enhancements}
None known.

\section{Preamble}
=IGN
structure âProductTypesá : ProductTypes = struct
=TEX
\section{THE THEORY}
=SML
val lthy = get_current_theory_name ();
val _ = open_theory "pair";
val _ = new_theory "first_cache_theory";
val _ = push_proof_context pair_epc;
=IGN
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",
	true);
=TEX
\section{UTILITIES}
Still not global!
=SML
fun âlist_mk_‹_typeá ([ty]:TYPE list):TYPE = ty
| list_mk_‹_type (a :: x) = mk_‹_type (a, list_mk_‹_type x)
| list_mk_‹_type [] = fail "list_mk_‹_type" 0 [];
=TEX
=SML
fun âstrip_‹_typeá (ty:TYPE):TYPE list = (
let	val (ty1,ty2) = dest_‹_type ty
in
	ty1 :: strip_‹_type ty2
end
handle (Fail _) => [ty]);
=TEX
Some type variables:
=SML
val âtvaá = »:'a¼;
val âtvbá = »:'b¼;
val âtvcá = »:'c¼;
val âtv1á = »:'1¼;
val âtv2á = »:'2¼;
=TEX

\subsection{Timing}
The following value allows timing to be invoked as on one off
(false invokes timing).
A reference variable is inappropriate.
=SML
val ânotimingá = false;
=TEX
Time the application of a tactic to a goal, and its resulting proof to its
arguments.
=SML
fun âTIME_Tá (name:string) (tac : TACTIC) : TACTIC = (
	if notiming 
	then tac
	else (fn (asms_gl) =>
let	val t1 = System.processtime ();
	val (sgs,prf) = tac asms_gl;
	val sideeffect = diag_string("Tactic setting for "^
		name^" took:"^
		string_of_int(System.processtime ()-t1));
in
	(sgs,(fn x => 
	let	val t2 = System.processtime ();
		val res = prf x;
		val sideeffect = diag_string("Tactic proof for "^
			name^" took:"^
			string_of_int(System.processtime ()-t2));
	in
		res
	end))
end));
=TEX
Time the application of a rule to a theorem.
=SML
fun âtime_ruleá (name:string) (rule : THM -> THM) : THM -> THM = (
	if notiming
	then rule
	else (fn (thm : THM) =>
let	val t1 = System.processtime ();
	val s1 = rule thm;
	val sideeffect = diag_string("Rule "^
			name^" took:"^
			string_of_int(System.processtime ()-t1));
in
	s1
end));
=TEX
Time the application of a theorem tactical:
=SML
fun âTIME_TTCLá (name:string) ttcl (ttac:THM -> TACTIC)(thm : THM) : TACTIC = (
	if notiming
	then ttcl ttac thm
	else
	(fn (asms_gl) =>
let	val t1 = System.processtime ();
	val (sgs,prf) = ttcl ttac thm asms_gl;
	val sideeffect = diag_string("Ttcl setting for "^
		name^" took:"^
		string_of_int(System.processtime ()-t1));
in
	(sgs,(fn x => 
	let	val t2 = System.processtime ();
		val res = prf x;
		val sideeffect = diag_string("Ttcl proof for "^
			name^" took:"^
			string_of_int(System.processtime ()-t2));
	in
		res
	end))
end));
=TEX

\subsection{Conversionals}
Distribute two always successful conversions over a conjunction:
=SML
fun â€_C2á conv1 conv2 tm = (
let	val (cnjt1,t2) = dest_app tm;
	val (cnj,t1) = dest_app cnjt1;
in
	mk_app_rule(ap_fun_rule cnj (conv1 t1))(conv2 t2)
end);
=TEX
Apply a conversion to the leftmost conjunction.
=SML
fun âLEFTMOST_€_Cá conv : CONV = (fn tm =>
	if is_€ tm
	then RATOR_C(RAND_C(LEFTMOST_€_C conv)) tm
	else conv tm
);
=TEX
Apply a conversion to all conjuncts nested by $((...(c1 € c2) € c3 ...)$.
=SML
fun âLALL_€_Cá conv : CONV = (fn tm =>
	if is_€ tm
	then APP_C ((RAND_C(LALL_€_C conv)), conv) tm
	else conv tm
);
=TEX
\subsection{Rules}
=RULE
„_€_left_rule
É
ö … „ x Ž p[x] € q[x]
É
ö … „ x Ž p[x]
=TEX
=SML
local
	val lthm = tac_proof(([],»ƒ p q Ž („ x : 'a Žp x € q x) Š $„ p¼),
		once_rewrite_tac[eq_sym_rule
		(simple_ƒ_elim »p:'a ‹ BOOL¼
		(inst_type_rule [(BOOL,tvb)] eta_axiom))] THEN
		rewrite_tac[] THEN
		REPEAT strip_tac THEN
		simple_„_tac »x:'a¼ THEN
		goal_in_asms_tac);
in
fun â„_€_left_ruleá (thm : THM) = (
let	val (x,bdy) = dest_simple_„ (concl thm);
	val (c1,c2) = dest_€ bdy;
	val s1 = inst_type_rule [(type_of x,tva)] lthm;
	val s2 = list_simple_ƒ_elim[mk_simple_(x,c1),
		mk_simple_(x,c2)] s1;
	val s3 = conv_rule(RATOR_C(
		RAND_C(BINDER_C(€_C2 simple_%beta%_conv simple_%beta%_conv))))
		 s2;
	val s4 = Š_elim s3 thm
in
	s4
end);
end;
=TEX
=RULE
„_€_right_rule
É
ö … „ x Ž p[x] € q[x]
É
ö … „ x Ž q[x]
=TEX
=SML
local
	val lthm = tac_proof(([],»ƒ p q Ž („ x : 'a Žp x € q x) Š $„ q¼),
		once_rewrite_tac[eq_sym_rule
		(simple_ƒ_elim »q:'a ‹ BOOL¼
		(inst_type_rule [(BOOL,tvb)] eta_axiom))] THEN
		rewrite_tac[] THEN
		REPEAT strip_tac THEN
		simple_„_tac »x:'a¼ THEN
		goal_in_asms_tac);
in
fun â„_€_right_ruleá (thm : THM) = (
let	val (x,bdy) = dest_simple_„ (concl thm);
	val (c1,c2) = dest_€ bdy;
	val s1 = inst_type_rule [(type_of x,tva)] lthm;
	val s2 = list_simple_ƒ_elim[mk_simple_(x,c1),
		mk_simple_(x,c2)] s1;
	val s3 = conv_rule(RATOR_C
		(RAND_C(BINDER_C(€_C2 simple_%beta%_conv simple_%beta%_conv)))) s2;
	val s4 = Š_elim s3 thm
in
	s4
end);
end;
=TEX
A limited form of matching $type\_lemmas\_thm$:
=RULE
simple_match_type_lemmas_thm
É
… „ f: ty1 ‹ ty2 Ž TypeDefn ( x Ž T) f
É
… „ abs repŽ (ƒ a:ty1Ž abs (rep a) = a) € (ƒ r:ty2Ž rep (abs r) = r)
=TEX
=SML
local
	val s1 = simple_ƒ_elim »( x:'b Ž T)¼ type_lemmas_thm;
	val s2 = rewrite_rule [] s1;
	val atype = »:'a ‹ 'b¼;
in
fun âsimple_match_type_lemmas_thmá (thm : THM) : THM = (
let	val (f,_) = dest_simple_„(concl thm);
	val (ty1,ty2) = dest_‹_type (type_of f);
	val tyinsts = [(ty1,tva),(ty2,tvb)];
in
	Š_elim (inst_type_rule tyinsts s2) thm
end
handle complaint =>
reraise complaint "simple_match_type_lemmas_thm");
end;
=TEX
\subsection{Theorems}
=SML
val âpair_eq_thmá = tac_proof(([],
	»ƒ x y p qŽ ((x,y) = (p,q)) ‚ ((x = p) € (y = q))¼),
		rewrite_tac[pair_clauses]);
=TEX
=SML
val â„__x_t_thmá = tac_proof(([],»„ x:'a Ž ( x Ž T) x¼),
	rewrite_tac[]);
=TEX
=SML
fun ârlist_mk_‰_typeá tys = (
let	fun aux [ty] = ty
	| aux (ty :: rest) = mk_‰_type(aux rest,ty)
	| aux _ = fail "rlist_mk_‰_type" 0 [];
in
	aux (rev tys)
end);
=TEX
=SML
fun ârlist_mk_€á cnjs = (
let	fun aux [cnj] = cnj
	| aux (cnj :: rest) = mk_€(aux rest,cnj)
	| aux _ = fail "rlist_mk_€" 0 [];
in
	aux (rev cnjs)
end);
=TEX
Each theorem in the below is associated with a ``matching''
conversion.
=SML
val âlpair_ƒ_thmá = (
	push_goal([],»ƒ f Ž (ƒ p : '1 ‰ '2 Ž f p) 
		‚
		(ƒ p1 p2 Ž f (p1,p2))¼);
	a(REPEAT strip_tac);
	(* *** Goal "1" *** *)
	a(asm_rewrite_tac[]);
	(* *** Goal "2" *** *)
	a(LEMMA_T »p = (Fst p,Snd p)¼ once_rewrite_thm_tac);
	(* *** Goal "2.1" *** *)
	a(rewrite_tac[pair_clauses]);
	(* *** Goal "2.2" *** *)
	a(asm_rewrite_tac[]);
	rewrite_rule[eta_axiom](pop_thm()));
=TEX
=CONVERSION
lpair_ƒ_conv
»ƒ p : '1 ‰ '2 Ž f[p]¼
É
É
… (ƒ p : '1 ‰ '2 Ž f[p]) ‚ (ƒ p1 p2 Ž f [(p1, p2)])
=TEX
=SML
local
	val atype = »:'1 ‰ '2¼;
in
fun âlpair_ƒ_convá tm = (
let	val (_,abs) = dest_app tm;
	val ptype = fst(dest_‹_type(type_of abs));
	val tyinsts = type_match ptype atype;
	val s1 = simple_ƒ_elim abs (inst_type_rule tyinsts lpair_ƒ_thm);
	val s2 = conv_rule(RAND_C(BINDER_C(BINDER_C simple_%beta%_conv))) s1;
in
	s2
end
handle complaint =>
reraise complaint "lpair_ƒ_conv");
end; (* of local *)
=TEX
=SML
val lpair_„_thm = (
	push_goal([],»ƒ f Ž („ p : '1 ‰ '2 Ž f p) 
		‚
		(„ p1 p2 Ž f (p1,p2))¼);
	a(REPEAT strip_tac);
	(* *** Goal "1" *** *)
	a(simple_„_tac »Fst p¼ THEN simple_„_tac »Snd p¼);
	a(pure_rewrite_tac[pair_clauses] THEN goal_in_asms_tac);
	(* *** Goal "2" *** *)
	a(simple_„_tac »(p1,p2)¼ THEN goal_in_asms_tac);
	rewrite_rule[eta_axiom](pop_thm()));
=TEX
=CONVERSION
lpair_„_conv
»„ p : '1 ‰ '2 Ž f[p]¼
É
É
… („ p : '1 ‰ '2 Ž f[p]) ‚ („ p1 p2 Ž f [(p1, p2)])
=TEX
=SML
local
	val atype = »:'1 ‰ '2¼;
in
fun âlpair_„_convá tm = (
let	val (_,abs) = dest_app tm;
	val ptype = fst(dest_‹_type(type_of abs));
	val tyinsts = type_match ptype atype;
	val s1 = simple_ƒ_elim abs (inst_type_rule tyinsts lpair_„_thm);
	val s2 = conv_rule(RAND_C(BINDER_C(BINDER_C simple_%beta%_conv))) s1;
in
	s2
end
handle complaint =>
reraise complaint "lpair_„_conv");
end; (* of local *)
=TEX
=SML
val lpair_„_thm1 = (
	push_goal([],»ƒ f Ž („ p : 'a ‹ '1 ‰ '2 Ž f p) 
		‚
		(„ p1 p2 Ž f ( x Ž (p1 x,p2 x)))¼);
	a(REPEAT strip_tac);
	(* *** Goal "1" *** *)
	a(simple_„_tac »( x Ž Fst (p x))¼ THEN 
	  simple_„_tac »( x Ž Snd (p x))¼);
	a(rewrite_tac[pair_clauses, eta_axiom] THEN goal_in_asms_tac);
	(* *** Goal "2" *** *)
	a(simple_„_tac »( xŽ (p1 x, p2 x))¼ THEN goal_in_asms_tac);
	rewrite_rule[eta_axiom](pop_thm()));
=TEX
=CONVERSION
lpair_„_conv1
»„ p : 'a ‹ '1 ‰ '2 Ž f[p]¼
É
É
… („ p : 'a ‹ '1 ‰ '2 Ž f[p]) ‚ („ p1 p2 Ž f [( x Ž (p1 x, p2 x))])
=TEX
=SML
local
	val atype = »: 'a ‹ '1 ‰ '2¼;
in
fun âlpair_„_conv1á tm = (
let	val (_,abs) = dest_app tm;
	val ptype = fst(dest_‹_type(type_of abs));
	val tyinsts = type_match ptype atype;
	val s1 = simple_ƒ_elim abs (inst_type_rule tyinsts lpair_„_thm1);
	val s2 = conv_rule(RAND_C(BINDER_C(BINDER_C simple_%beta%_conv))) s1;
in
	s2
end
handle complaint =>
reraise complaint "lpair_„_conv1");
end; (* of local *)
=TEX
=SML
val â„_pair_conv_thmá = (
	push_goal([],»ƒ f Ž($„ (f: (('1 ‰ '2) ‹ 'a) ‹ BOOL)) ‚
		(„ con' Ž f ( (x, y) Ž  con' x y))¼);
	a(once_rewrite_tac[eq_sym_rule
		(simple_ƒ_elim »f:(('1 ‰ '2) ‹ 'a) ‹ BOOL¼
		(inst_type_rule [(»:(('1 ‰ '2) ‹ 'a)¼,»:'a¼),
			(»:BOOL¼,»:'b¼)] eta_axiom))]);
	a(rewrite_tac[]);
	a(REPEAT strip_tac);
	(* *** Goal "1" *** *)
	a(simple_„_tac » p q Ž x (p,q)¼);
	a(rewrite_tac[eta_axiom]);
	a(LEMMA_T »( (x',q) Ž x(x',q)) = ( y Ž x y)¼
		(fn x => asm_rewrite_tac[x,eta_axiom]));
	a (rewrite_tac[ext_thm, pair_clauses]);
	(* *** Goal "2" *** *)
	a(simple_„_tac »( (x, y)Ž con' x y)¼ THEN goal_in_asms_tac);
	pop_thm());
=TEX
=CONVERSION
l„_pair_conv
»„ p : '1 ‰ '2 ‹ 'a Ž f[p]¼
É
É
… („ p : '1 ‰ '2 ‹ 'a Ž f[p]) ‚ („ p' Ž f [((x,y) Ž p' x y)])
=TEX
=SML
local
	val atype = »:'1 ‰ '2 ‹ 'a¼;
in
fun âl„_pair_convá tm = (
let	val (_,abs) = dest_app tm;
	val ptype = fst(dest_‹_type(type_of abs));
	val tyinsts = type_match ptype atype;
	val s1 = simple_ƒ_elim abs (inst_type_rule tyinsts „_pair_conv_thm);
	val s2 = conv_rule(RAND_C(BINDER_C simple_%beta%_conv)) s1;
in
	s2
end
handle complaint =>
reraise complaint "l„_pair_conv");
end; (* of local *)
=TEX
=SML
local
	val uncurry_def = (get_defn "pair" "Uncurry");
in
val âl_%beta%_convá : CONV = (fn tm =>
let	val (p,q) = dest_app tm;
	val (q1,q2) = dest_pair q;
	val (uc,p') = dest_app p;
	val sideeffect = if fst(dest_const uc) <> "Uncurry"
		then fail "l_%beta%_conv" 0 []
		else ();
	val tyinsts = [(type_of q1,tva),(type_of q2,tvb),
		(snd(dest_‹_type(snd(dest_‹_type(type_of p')))),tvc)];
	val s1 = inst_type_rule tyinsts uncurry_def;
	val s2 = list_simple_ƒ_elim[p',q1,q2] s1;
	val s3 = conv_rule(RAND_C((RATOR_C simple_%beta%_conv) THEN_C
		simple_%beta%_conv)) s2;
in
	s3
end);
end;
=TEX
\section{MAIN FUNCTIONS}
\subsection{Theory Caches}
We must have an initial cache theory to allow the special case
of $cached\_product\_rule$ $1$ to be saved.
We currently assume it is the current theory.
=SML
local
	val cache_theories: string list ref = ref [get_current_theory_name ()];
in
fun âset_cache_theoriesá (slst: string list) : unit = (
	cache_theories := slst
);
fun âget_cache_theoriesá (():unit) : string list = (!cache_theories);
end;
=TEX
\subsection{Defining n-tuples}
We need to initialise $cached\_product\_rule$ by saving the result of $cached\_product\_rule$ $1$ in the initial cache theory.
=SML
val _ = open_theory(hd(get_cache_theories()));

val tuple1_thm = save_thm("1TUPLE",(
	push_goal([],
	»(„ abs : '1 ‹ 'a Ž
	 „ rep : 'a ‹ '1 Ž
	 (ƒ aŽ abs(rep a) = a) € (ƒ r Ž rep(abs r) = r))
	Š
	„ 1Tuple:'1 ‹ 'a Ž
	(„ Lab1_1Ž ƒ t x1Ž Lab1_1 (1Tuple x1) = x1 € 1Tuple (Lab1_1 t) = t) €
	(ƒ x1 y1Ž 1Tuple x1 = 1Tuple y1 ‚ x1 = y1) € (ƒ tŽ „ x1Ž t = 1Tuple x1)¼);
	a strip_tac;
	a(simple_„_tac »abs : '1 ‹ 'a¼);
	a(REPEAT €_tac);
	a(simple_„_tac »rep:'a ‹ '1¼ THEN asm_rewrite_tac[]);
	a(REPEAT simple_ƒ_tac THEN ‚_T2 
		(fn thm => ante_tac(ap_fun_rule »rep:'a ‹ '1¼  thm) THEN
		asm_rewrite_tac[])
		(fn thm => pure_rewrite_tac[thm, eq_rewrite_thm]));
	a(simple_ƒ_tac THEN simple_„_tac »(rep:'a ‹ '1) t¼ 
		THEN asm_rewrite_tac[]);
	pop_thm()));
=TEX
Now we can define $cached\_product\_rule$ itself.

Start of main function.
Notice the addition of timing material to determine when this
is so slow - these will be removed in any product version.
=SML
fun âcached_product_ruleá (arg: int) : THM = (
let
=TEX
The following finds pre-existing copies of the $cached\_product\_rule$
theorem, should they exist.
=SML
fun âfind_n_tupleá (n:int):THM OPT = (
let	val key = string_of_int n ^ "TUPLE";
	fun aux [] = Nil
	| aux (thy :: rest) = (Value(get_thm thy key)
		handle (Fail _) => aux rest);
in
		aux (get_cache_theories())
end);
=TEX
The following declares a new n-tuple type, knowing that the type isn't
in scope.
=SML
fun âdeclare_n_tupleá (n:int) :THM = (
let	val last_thm = cached_product_rule (n-1);
	val was_thy = get_current_theory_name();
	val cache_thy = (hd(get_cache_theories()))
		handle complaint =>
		divert complaint "hd" "cached_product_rule" 59006 [];
	val sideeffect = if is_theory_ancestor cache_thy was_thy
		then ()
		else fail "cached_product_rule" 59002 [fn () => cache_thy];
	val sideeffect = open_theory cache_thy;
	val nstr = string_of_int n;
	val key = nstr ^ "TUPLE";
	val inters = map string_of_int (interval 1 n);
	val tyvars = map (fn x => mk_vartype("'"^ x)) inters;
	val xi = map (fn x => mk_var("x"^x,mk_vartype("'"^ x))) inters;
	val yi = map (fn x => mk_var("y"^x,mk_vartype("'"^ x))) inters;
	val ntuple = mk_var(nstr^ "Tuple",list_mk_‹_type (tyvars @ [tva]));
	val labstr = "Lab"^nstr^"_";
	val labs = map (fn x => mk_var(labstr^x,
		mk_‹_type(tva,mk_vartype("'"^x)))) inters;
	val t = mk_var("t",tva);
	val ntuple_args = list_mk_app(ntuple,xi);
	val succedent = mk_simple_„(ntuple,
	  mk_€(
		list_mk_simple_„(labs,
		list_mk_simple_ƒ((t :: xi),
		rlist_mk_€(
		map (fn (lab,x) =>
		mk_eq(mk_app(lab,ntuple_args),x))
		(combine labs xi)
		@ [mk_eq(
		list_mk_app(ntuple,
		map (fn lab => mk_app(lab,t)) labs),
		t)])))
		,
		mk_€(
		 (list_mk_simple_ƒ(xi @ yi,mk_‚(mk_eq(ntuple_args,list_mk_app(ntuple,yi)),
			rlist_mk_€(map (fn (x,y) => mk_eq(x,y)) (combine xi yi))))),
		 (mk_simple_ƒ(t,
		 list_mk_simple_„(xi,
			 mk_eq(t,ntuple_args))))
		)
	));
	val ntuple_type = rlist_mk_‰_type tyvars;
	val abs = mk_var("abs",mk_‹_type(ntuple_type,tva));
	val rep = mk_var("rep",mk_‹_type(tva,ntuple_type));
	val avar = mk_var("a",tva);
	val rvar = mk_var("r",ntuple_type);
	val antecedent = (
		list_mk_simple_„([abs,rep],
		mk_€
		(mk_simple_ƒ(avar,
		mk_eq(mk_app(abs,mk_app(rep,avar)),avar)),
		mk_simple_ƒ(rvar,
		mk_eq(mk_app(rep,mk_app(abs,rvar)),rvar))))
	);
	val thm_concl = mk_Š(antecedent, succedent);
=TEX
We now have the theorems conclusion, $thm\_concl$: now to prove it.
We do so by instantiating the $n-1\sup{th}$ theorem.
=SML
	val old_tyvars = rev(tl(rev tyvars));
	val tyinsts = ((mk_‰_type(tv1,tv2),tv1) ::
		combine  (tl(tl tyvars)) (tl old_tyvars));
	val s1 = time_rule "s1" (inst_type_rule tyinsts) last_thm;
	val s2 = time_rule "s2" (Š_elim s1) (asm_rule antecedent);
	val s3 = time_rule "s3" (conv_rule (BINDER_C
		(€_C2 ((ALL_SIMPLE_„_C (BINDER_C lpair_ƒ_conv))
			THEN_C lpair_„_conv1
			THEN_C ALL_SIMPLE_„_C
			(ALL_SIMPLE_ƒ_C
			(€_C2
			(LEFTMOST_€_C((RATOR_C(RAND_C simple_%beta%_conv))
				THEN_C (simple_eq_match_1_conv pair_eq_thm))
			)
			(ONCE_MAP_C simple_%beta%_conv))
))
			(€_C2 (lpair_ƒ_conv THEN_C
				ONCE_MAP_C lpair_ƒ_conv THEN_C
				ALL_SIMPLE_ƒ_C (RAND_C(LEFTMOST_€_C 
					(simple_eq_match_1_conv pair_eq_thm))))
				(BINDER_C lpair_„_conv)))
		)) s2;
	val s4 = time_rule "s4" (conv_rule (l„_pair_conv THEN_C ONCE_MAP_C l_%beta%_conv)) s3;
	val s5 = time_rule "s5" (conv_rule (%alpha%_conv thm_concl))
		(all_Š_intro s4);
	val sideeffect = save_thm(key,s5);
	val sideeffect = open_theory was_thy;
in
	s5
end);
=TEX
Main function:
=SML
in
	if arg < 1 
	then fail "cached_product_rule" 59001 [fn () => string_of_int arg]
	else (case (find_n_tuple arg) of
	Value thm => thm
	| Nil => declare_n_tuple arg)

end); (* of cached_product_rule *)
=TEX
\subsection{Labelled Products}
=IGN
new_parent "†";

val inp2 = {tyname = "HOLD2",tykey = "HOLD2",conname = "Hold2",
	constkeys= ["Hold2","First2","Second2"],
	labels = [("First2",†),("Second2",»:'1¼)],
	tyvars = Value[»:'1¼,»:'2¼]};
val inp3 = {tyname = "HOLD3",tykey = "HOLD3",conname = "Hold3",
	constkeys= ["Hold3","First3","Second3","Third3"],
	labels = [("First3",†),("Second3",»:'1¼),("Third3",»:'2¼)],
	tyvars = Value[»:'1¼,»:'2¼]};
val inp4 = {tyname = "HOLD4",tykey = "HOLD4",conname = "Hold4",
	constkeys= ["Hold4","First","Second","Third","Fourth"],
	labels = [("First",†),("Second",»:'1¼),("Third",»:'2¼),("Fourth",»:'1 ‰ '2¼)],
	tyvars = Value[»:'1¼,»:'2¼]};

val inp5 = {tyname = "HOLD5",tykey = "HOLD5",conname = "Hold5",
	constkeys= ["Hold5","First5","Second5","Third5","Fourth5","Fifth5"],
	labels = [("First5",†),("Second5",»:'1¼),("Third5",»:'2¼),("Fourth5",»:'1 ‰ '2¼),("Fifth5",»:'3¼)],
	tyvars = Value[»:'1¼,»:'2¼,»:'3¼]};
val inp6 = {tyname = "HOLD6",tykey = "HOLD6",conname = "Hold6",
	constkeys= ["Hold6","First6","Second6","Third6","Fourth6","Fifth6","Sixth6"],
	labels = [("First6",†),("Second6",»:'1¼),("Third6",»:'2¼),("Fourth6",»:'1 ‰ '2¼),("Fifth6",»:'3¼),("Sixth6",»:'1¼)],
	tyvars = Value[»:'1¼,»:'2¼,»:'3¼]};
val inp7 = {tyname = "HOLD7",tykey = "HOLD7",conname = "Hold7",
	constkeys= ["Hold7","First7","Second7","Third7","Fourth7","Fifth7","Sixth7","Seventh"],
	labels = [("First7",†),("Second7",»:'1¼),("Third7",»:'2¼),("Fourth7",»:'1 ‰ '2¼),("Fifth7",»:'3¼),("Sixth7",»:'1¼),
	("Seventh7",»:'1 ‰ '3¼)],
	tyvars = Value[»:'1¼,»:'2¼,»:'3¼]};
val inp8 = {tyname = "HOLD8",tykey = "HOLD8",conname = "Hold8",
	constkeys= ["Hold8","First8","Second8","Third8","Fourth8","Fifth8","Sixth8","Seventh8","Eighth8"],
	labels = [("First8",†),("Second8",»:'1¼),("Third8",»:'2¼),("Fourth8",»:'1 ‰ '2¼),("Fifth8",»:'3¼),("Sixth8",»:'1¼),
	("Seventh8",»:'1 ‰ '3¼),("Eighth8",»:'3 ‰ '2¼)],
	tyvars = Value[»:'1¼,»:'2¼,»:'3¼]};
=SML
fun âlabelled_product_specá {tyname:string, tykey:string, conname:string, 
	constkeys:string list, labels:(string*TYPE)list, tyvars:(TYPE list)OPT} : THM = (
let	val sideeffect = if is_nil constkeys orelse is_nil labels
		then fail "labelled_product_spec" 59010 []
		else();
	val nlabels = length labels;
	val nstr = string_of_int nlabels;
	val tuple_thm = cached_product_rule nlabels
		handle complaint =>
		pass_on complaint "cached_product_rule" "labelled_product_spec";
	val tuple_type = fst(dest_‹_type(type_of(fst(dest_simple_„(fst(dest_Š (concl tuple_thm)))))));
	val (lab_nms,lab_types) = split labels;
	val rep_type = rlist_mk_‰_type lab_types;
	val lab_tyvars = list_cup(map (fn x => map mk_vartype (type_tyvars x)) lab_types);
	val used_tyvars = case tyvars of
		Nil => lab_tyvars
		| Value tys => (if lab_tyvars subset tys
			then (map dest_vartype tys
				handle complaint =>
				pass_on complaint "dest_vartype" "labelled_product_spec"; tys)
			else fail "labelled_product_spec" 6057 [
			fn () => "A label",
			fn () => format_list(dest_vartype) (lab_tyvars diff tys) ", "]);
	val abs_type = mk_ctype(tyname, used_tyvars);
	val „_thm = inst_type_rule[(rep_type, tva)] „__x_t_thm;
=TEX
Before we actually declare the new type we attempt to ensure that we will be able to introduce the new constants
as requested.
We do not catch the failure of constants being already defined in child theories,
nor are we very good at presenting al the errors we know.
=SML
	val used_keys = mapfilter (fn x => (get_defn "-" x;x))
		(tykey :: constkeys);
	val sideeffect = if is_nil used_keys
		then ()
		else fail "labelled_product_spec" 6052 [fn () => hd used_keys,
			fn () => get_current_theory_name ()];
	val used_constants = mapfilter (fn x => (force_value(get_const_type x);x))
		(conname :: lab_nms);
	val sideeffect = if is_nil used_constants
		then ()
		else fail "labelled_product_spec" 6049 [fn () => hd used_constants];
=TEX
Now the definition itself, which will flush out any writability problems that constant specification will have.
=SML
	val type_def = new_type_defn (tyname,tykey,map dest_vartype used_tyvars, „_thm)
		handle complaint =>
		pass_on complaint "new_type_defn" "labelled_product_spec";
	val inters = map string_of_int (interval 1 nlabels);
	val tyinsts = (abs_type,tva) :: (combine lab_types (map (fn s => mk_vartype ("'"^s)) inters));
	val tuple_thm' = time_rule "tuple_thm'" (inst_type_rule tyinsts) tuple_thm;
	val s1 = time_rule "s1" simple_match_type_lemmas_thm type_def;
	val s2 = time_rule "s2" (Š_elim tuple_thm') s1;
	val s3 = time_rule "s3" „_€_left_rule s2;
	val labs = map (fn (x,ty) => mk_var(x,mk_‹_type(abs_type,ty))) labels;
	val xi = map mk_var(combine (map (fn x => "x"^x) inters) lab_types);
	val con = mk_var(conname,list_mk_‹_type (lab_types @ [abs_type]));
	val t = mk_var("t",abs_type);
	val con_args = list_mk_app(con,xi);
	val abs = mk_var("abs",mk_‹_type(rep_type,abs_type));
	val rep = mk_var("rep",mk_‹_type(abs_type,rep_type));
	val thm_concl = mk_simple_„(con,
		list_mk_simple_„(labs,
		list_mk_simple_ƒ((t :: xi),
		rlist_mk_€(
		map (fn (lab,x) =>
		mk_eq(mk_app(lab,con_args),x))
		(combine labs xi)
		@ [mk_eq(
		list_mk_app(con,
		map (fn lab => mk_app(lab,t)) labs),
		t)]))));
	val s4 = time_rule "s4" (conv_rule (%alpha%_conv thm_concl)) s3;
in
	(new_specification(constkeys,1+nlabels,s4)
		handle complaint =>
		pass_on complaint "new_specification" "labelled_product_spec")
end); (* labelled_product_spec *)
=TEX
\subsection{Unlabelled Products}
=IGN
val ulp2 = {tyname="ULP2", tykey="ULP2", conname="Ulp2", 
	conkeys=["Ulp2"], tyi=[»:'a ‰ 'b¼,»:'a ‰ 'b¼], 
	tyvars = Value [»:'a¼,»:'b¼]};
val ulp3 = {tyname="ULP3", tykey="ULP3", conname="Ulp3", 
	conkeys=["Ulp3"], tyi=[»:'a ‰ 'b¼,»:'a ‰ 'b¼,»:†¼], 
	tyvars = Value [»:'a¼,»:'b¼]};
val ulp4 = {tyname="ULP4", tykey="ULP4", conname="Ulp4", 
	conkeys=["Ulp4"], tyi=[»:'a ‰ 'b¼,»:'a ‰ 'b¼,»:†¼,»:'c ‰ 'a¼], 
	tyvars = Value [»:'a¼,»:'b¼,»:'c¼]};
val ulp5 = {tyname="ULP5", tykey="ULP5", conname="Ulp5", 
	conkeys=["Ulp5"], tyi=[»:'a ‰ 'b¼,»:'a ‰ 'b¼,»:†¼,»:'c ‰ 'a¼,BOOL], 
	tyvars = Nil};
val ulp6 = {tyname="ULP6", tykey="ULP6", conname="Ulp6", 
	conkeys=["Ulp6"], tyi=[»:'a ‰ 'b¼,»:'a ‰ 'b¼,»:†¼,»:'c ‰ 'a¼,BOOL,»:'1¼], 
	tyvars = Nil};
val ulp7 = {tyname="ULP7", tykey="ULP7", conname="Ulp7", 
	conkeys=["Ulp7"], tyi=[»:'d ‰ BOOL¼,»:'a ‰ 'b¼,»:'a ‰ 'b¼,»:†¼,»:'c ‰ 'a¼,BOOL,»:'1¼], 
	tyvars = Nil};
val ulp8 = {tyname="ULP8", tykey="ULP8", conname="Ulp8", 
	conkeys=["Ulp8"], tyi=[»:'d ‰ BOOL¼,»:'a ‰ 'b¼,»:'a ‰ 'b¼,»:†¼,»:'c ‰ 'a¼,BOOL,»:'1¼,»:'4¼], 
	tyvars = Nil};
=SML
fun âunlabelled_product_specá {tyname:string, tykey:string, conname:string, 
	conkeys:string list, tyi: TYPE list, tyvars:(TYPE list)OPT} : THM = (
let	val sideeffect = if is_nil conkeys orelse is_nil tyi
		then fail "unlabelled_product_spec" 59010 []
		else();
	val nlabels = length tyi;
	val nstr = string_of_int nlabels;
	val tuple_thm = cached_product_rule nlabels
		handle complaint =>
		pass_on complaint "cached_product_rule" "labelled_product_spec";
	val rep_type = rlist_mk_‰_type tyi;
	val lab_tyvars = list_cup(map (fn x => map mk_vartype (type_tyvars x)) tyi);
	val used_tyvars = case tyvars of
		Nil => lab_tyvars
		| Value tys => (if lab_tyvars subset tys
			then (map dest_vartype tys
				handle complaint =>
				pass_on complaint "dest_vartype" "labelled_product_spec"; tys)
			else fail "labelled_product_spec" 6057 [
			fn () => "A label",
			fn () => format_list(dest_vartype) (lab_tyvars diff tys) ", "]);
	val abs_type = mk_ctype(tyname, used_tyvars);
	val „_thm = inst_type_rule[(rep_type, tva)] „__x_t_thm;
=TEX
Before we actually declare the new type we attempt to ensure that we will be able to introduce the new constants
as requested.
We do not catch the failure of constants being already defined in child theories,
nor are we very good at presenting al the errors we know.
=SML
	val used_keys = mapfilter (fn x => (get_defn "-" x;x))
		(tykey :: conkeys);
	val sideeffect = if is_nil used_keys
		then ()
		else fail "labelled_product_spec" 6052 [fn () => hd used_keys,
			fn () => get_current_theory_name ()];
	val sideeffect = case (get_const_type conname) of
		Value _ =>fail "unlabelled_product_spec" 6049 [fn () => conname]
		| Nil => ();
=TEX
Now the definition itself, which will flush out any writability problems that constant specification will have.
=SML
	val type_def = new_type_defn (tyname,tykey,map dest_vartype used_tyvars, „_thm)
		handle complaint =>
		pass_on complaint "new_type_defn" "unlabelled_product_spec";
	val inters = map string_of_int (interval 1 nlabels);
	val tyinsts = (abs_type,tva) :: combine tyi (map (fn s => mk_vartype ("'"^s)) inters);
	val tuple_thm' = (inst_type_rule tyinsts tuple_thm);
	val s1 = time_rule "s1" simple_match_type_lemmas_thm type_def;
	val s2 = time_rule "s2" (Š_elim tuple_thm') s1;
	val s3 = time_rule "s3" „_€_right_rule s2;
	val s4 = time_rule "s4" (conv_rule(RAND_C (simple_%alpha%_conv conname))) s3;
in
	(new_specification(conkeys,1,s4)
		handle complaint =>
		pass_on complaint "new_specification" "unlabelled_product_spec")
end); (* of unlabelled_product_spec *)
=TEX
\section{EPILOGUE}
=IGN
val _ = open_theory lthy;
val _ = pop_proof_context();
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",
	lsubgoal_package_quiet);
end; (* of structure ProductTypes *)
open ProductTypes;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN
fun stat_sort (nm1,x1) (nm2,x2) = if x1 = x2
	then stringorder nm1 nm2
	else x1 - x2;
