=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Product Types}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP059}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation
of the tools for introducing HOL product types.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1] 
First version.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Tools introducing HOL product types are called for in \cite{DS/FMU/IED/HLD010}.
A design for such tools is given in \cite{DS/FMU/IED/DTD059}.
This document provides an implementations for them.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation for the
tools introducing HOL product types.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD059}.
\subsubsection{Deficiencies}
The initial cache theory is not set to a necessarily good value.
\subsubsection{Possible Enhancements}
None known.

\section{Preamble}
=SML
(* structure âProductTypesá : ProductTypes = struct *)
=TEX
\section{THE THEORY}
=SML
val lthy = get_current_theory_name ();
val _ = open_theory "pair";
val _ = new_theory "first_cache_theory";
val _ = push_proof_context pair_epc;
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",
	true);
=TEX
\section{UTILITIES}
Still not global!
=SML
fun âlist_mk_‹_typeá ([ty]:TYPE list):TYPE = ty
| list_mk_‹_type (a :: x) = mk_‹_type (a, list_mk_‹_type x)
| list_mk_‹_type [] = fail "list_mk_‹_type" 0 [];
=TEX
=SML
fun âstrip_‹_typeá (ty:TYPE):TYPE list = (
let	val (ty1,ty2) = dest_‹_type ty
in
	ty1 :: strip_‹_type ty2
end
handle (Fail _) => [ty]);
=TEX
Returns the eventual last type in a repeated function type.
=SML
fun âlast_‹_typeá (ty:TYPE):TYPE = (
let	val (_,ty2) = dest_‹_type ty
in
	last_‹_type ty2
end
handle (Fail _) => ty);
=TEX
The following are just quick ways of putting $Fst$ and $Snd$ on a term with a $‰$ type.
=SML
fun âmk_fstá tm = (
let	val ttm = type_of tm;
	val (ta,tb) = dest_‰_type ttm;
in
	mk_app(mk_const("Fst", mk_‹_type(ttm,ta)), tm)
end);
fun âmk_sndá tm = (
let	val ttm = type_of tm;
	val (ta,tb) = dest_‰_type ttm;
in
	mk_app(mk_const("Snd", mk_‹_type(ttm,tb)), tm)
end);
=TEX
\subsection{Conversions}
The following will do all the noted $\beta$ conversion in 
a term of the form:
ó
»( x1 ... xn Ž f[x1,...,xn])((y1 Ž f1[y1])z1)...((yn Ž fn[yn])zn)¼
æ
=SML
fun âtailored_beta_convá tm = (
	if is_app tm
	then (((APP_C (tailored_beta_conv, simple_%beta%_conv))
	THEN_C simple_%beta%_conv) tm)
	else refl_conv tm
);
=TEX
The following will do all the noted $\beta$ conversion in 
a term of the form:
ó
»( x1 ... xn Ž f[x1,...,xn])y1 ... yn¼
æ
=SML
fun âtailored_beta_conv1á tm = (
	if is_app tm
	then (((RATOR_C tailored_beta_conv1)
	THEN_C simple_%beta%_conv) tm)
	else refl_conv tm
);
=TEX
\subsection{Conversionals}
=SML
fun âEQ_Cá conv tm = (
let	val (eqt1,t2) = dest_app tm;
	val (eq,t1) = dest_app eqt1
in
	mk_app_rule(ap_fun_rule eq (conv t1))(conv t2)
end);
=TEX
=SML
fun â€_C2á conv1 conv2 tm = (
let	val (cnjt1,t2) = dest_app tm;
	val (cnj,t1) = dest_app cnjt1;
in
	mk_app_rule(ap_fun_rule cnj (conv1 t1))(conv2 t2)
end);
=TEX
=SML
fun âPAIR_C2á conv1 conv2 tm = (
let	val (pairt1,t2) = dest_app tm;
	val (pair,t1) = dest_app pairt1;
in
	mk_app_rule(ap_fun_rule pair (conv1 t1))(conv2 t2)
end);
=TEX
\subsection{Rules}

=RULE
„_€_left_rule
É
ö … „ x Ž p[x] € q[x]
É
ö … „ x Ž p[x]
=TEX
=SML
fun â„_€_left_ruleá (thm : THM) = (
let	val (x,bdy) = dest_simple_„ (concl thm);
	val (c1,c2) = dest_€ bdy;
in
	tac_proof((hyps thm,mk_simple_„(x,c1)),
	SIMPLE_„_THEN(asm_tac o €_left_elim) thm
	THEN simple_„_tac x
	THEN goal_in_asms_tac)
end);
=TEX
=RULE
„_€_right_rule
É
ö … „ x Ž p[x] € q[x]
É
ö … „ x Ž q[x]
=TEX
=SML
fun â„_€_right_ruleá (thm : THM) = (
let	val (x,bdy) = dest_simple_„ (concl thm);
	val (c1,c2) = dest_€ bdy;
in
	tac_proof((hyps thm,mk_simple_„(x,c2)),
	SIMPLE_„_THEN(asm_tac o €_right_elim) thm
	THEN simple_„_tac x
	THEN goal_in_asms_tac)
end);
=TEX
\subsection{Tactics}
=SML
fun âTIME_Tá (name:string) (tac : TACTIC) (asms_gl) = (
let	val t1 = System.processtime ();
	val (sgs,prf) = tac asms_gl;
	val sideeffect = diag_string("Tactic setting for "^
		name^" took:"^
		string_of_int(System.processtime ()-t1));
in
	(sgs,(fn x => 
	let	val t2 = System.processtime ();
		val res = prf x;
		val sideeffect = diag_string("Tactic proof for "^
			name^" took:"^
			string_of_int(System.processtime ()-t2));
	in
		res
	end))
end);
=TEX
=SML
fun âtime_ruleá (name:string) (rule : THM -> THM) (thm : THM) : THM = (
let	val t1 = System.processtime ();
	val s1 = rule thm;
	val sideeffect = diag_string("Rule "^
			name^" took:"^
			string_of_int(System.processtime ()-t1));
in
	s1
end);
=TEX
=SML
fun âTIME_TTCLá (name:string) ttcl (ttac:THM -> TACTIC)(thm : THM)
	(asms_gl) = (
let	val t1 = System.processtime ();
	val (sgs,prf) = ttcl ttac thm asms_gl;
	val sideeffect = diag_string("Ttcl setting for "^
		name^" took:"^
		string_of_int(System.processtime ()-t1));
in
	(sgs,(fn x => 
	let	val t2 = System.processtime ();
		val res = prf x;
		val sideeffect = diag_string("Ttcl proof for "^
			name^" took:"^
			string_of_int(System.processtime ()-t2));
	in
		res
	end))
end);
=TEX
The following strips a conjunctive goal, and should complete
the proof of each conjunct by the tactic given.
=SML
fun âREPEAT_€_COMPLETE_WITHá (tacs : TACTIC list) : TACTIC = (fn (asms, conc) =>
let	val conjs = strip_€ conc;
	val thms = map (fn (tac,conj) => 
		let val (sgs,prf) = tac(asms,conj)
		in
		if is_nil sgs
		then prf []
		else fail "REPEAT_€_COMPLETE_WITH" 0 []
		end)(combine tacs conjs);
in
	([],(fn _ => list_€_intro thms))
end);
=TEX
The following is no more than a rewritten:
ó
fun list_simple_„_tac wits = MAP_EVERY simple_„_tac wits;
æ
Its execution is quite a time consuming process,
taking the bulk of the time in handling the first conjunct
in $tuple\_spec$ (maybe a third of the total execution time).
An efficient $list\_simple\_„\_intro$ would help.
This timing information is gathered by the functions wrapping.
=SML
fun âlist_simple_„_tacá (wits : TERM list) : TACTIC = (fn(asms,gl) =>
let	fun aux [] bdy =([(asms,bdy)],(fn x => x))
	| aux (tm :: rest) bdy = (
	let	val (x, b) = dest_simple_„ bdy;
		val bdy' = var_subst[(tm, x)] b;
		val (sgs,prf) = aux rest bdy';
	in
		(sgs, fn x => simple_„_intro bdy (prf x))
	end);
	val (msgs,mprf) = aux wits gl;
in
	(msgs,(fn [thm] => mprf thm 
		| _ => bad_proof "list_simple_„_tac"))
end);
=TEX
Given a theorem that is a conjunction of (unquantified) equations of 
variables and values, convert the goal, as if by rewriting,
but with the knowledge of no repeated rewriting, and the
form of the equations.
=SML
fun âsubst_vars_tacá (thm:THM) : TACTIC = (
let	val thms = strip_€_rule thm;
	val assoc_list = map (fn t => (fst(dest_eq(concl t)),t)) thms;
	val cnv = (fn tm =>
		if is_var tm
		then lassoc3 assoc_list tm
		else fail_conv tm);
in
	conv_tac(ONCE_MAP_C cnv)
end);
=TEX
The following is a $strip\_asm\_tac$ tailored to 
$tuple\_spec$'s needs when stripping previously
proven results of $tuple\_spec$.
=SML

val âlstrip_asm_tacá = (SIMPLE_„_THEN
	(fn thm =>
	let	val thms = strip_€_rule thm;
		val thm1 = hd thms;
		val thm2 = hd(tl thms);
	in
		(TIME_TTCL "SIMPLE_„_THEN-lstrip_asm_tac" (REPEAT_TTCL SIMPLE_„_THEN)) asm_tac thm1
		THEN
		asm_tac thm2
	end));
=TEX
\subsection{Theorems}
Each theorem in the below is associated with a ``matching''
conversion.
=SML
val âtvaá = »:'a¼;
val âtvbá = »:'b¼;
=TEX
=SML
val âpair_eq_thmá = tac_proof(([],
	»ƒ x y p qŽ ((x,y) = (p,q)) ‚ ((x = p) € (y = q))¼),
		rewrite_tac[pair_clauses]);
fun âmatch_pair_eq_thm_convá tm = (
let	val (t1,t2) = dest_eq tm;
	val (t1a,t1b) = dest_pair t1;
	val (t2a,t2b) = dest_pair t2;
in
	list_simple_ƒ_elim[t1a,t1b,t2a,t2b](inst_type_rule
		[(type_of t1a, tva),(type_of t1b,tvb)]pair_eq_thm)
end);

local
	val pcs = initial_rw_canon pair_clauses;
in
val âfst_thmá = hd pcs;
val âsnd_thmá = hd(tl pcs);
end;
=TEX
=SML
val âmatch_fst_thm_convá :CONV = (fn tm =>
let	val (fst,pr) = dest_app tm;
	val (t1,t2) = dest_pair pr;
in
	list_simple_ƒ_elim [t2,t1]
	(inst_type_rule [(type_of t1,tva),(type_of t2,tvb)]
	fst_thm)
end);
val âmatch_snd_thm_convá :CONV = (fn tm =>
let	val (snd,pr) = dest_app tm;
	val (t1,t2) = dest_pair pr;
in
	list_simple_ƒ_elim [t2,t1]
	(inst_type_rule [(type_of t1,tva),(type_of t2,tvb)]
	snd_thm)
end);
=TEX
=SML
val âfst_snd_thmá = tac_proof(([],»ƒ t:'a ‰ 'bŽ(Fst t, Snd t) = t¼),
		rewrite_tac[pair_clauses]);
=SML
val âmatch_fst_snd_thm_convá : CONV = (fn tm =>
let	val (t1,t2) = dest_pair tm;
	val t1' = snd(dest_app t1);
	val (ty1,ty2) = dest_‰_type (type_of t1');
in
	simple_ƒ_elim t1' 
	(inst_type_rule [(ty1,tva),(ty2,tvb)]fst_snd_thm)
end);
=TEX
\section{MAIN FUNCTIONS}
\subsection{Theory Caches}
We must have an initial cache theory to allow the special case
of $tuple\_spec$ $1$ to be saved.
We currently assume it is the current theory.
=SML
local
	val cache_theories: string list ref = ref [get_current_theory_name ()];
in
fun âset_cache_theoriesá (slst: string list) : unit = (
	cache_theories := slst
);
fun âget_cache_theoriesá (():unit) : string list = (!cache_theories);
end;
=TEX
\subsection{Defining n-tuples}
We need to initialise $tuple\_spec$ by saving the result of $tuple\_spec$ $1$ in the initial cache theory.
=SML
val _ = open_theory(hd(get_cache_theories()));
val tuple1_def = new_type_defn("1TUPLE","1TUPLE",["'1"],
	tac_proof(([],»„ x : '1 Ž ( x Ž T) x¼),
		rewrite_tac[]));
val tuple1_thm = save_thm("1TUPLE",tac_proof(([],
	»„ 1Tuple:'1 ‹ '1 1TUPLE Ž
	(„ Lab1_1Ž ƒ t x1Ž Lab1_1 (1Tuple x1) = x1 € 1Tuple (Lab1_1 t) = t) €
	(ƒ x1 y1Ž 1Tuple x1 = 1Tuple y1 ‚ x1 = y1) € (ƒ tŽ „ x1Ž t = 1Tuple x1)¼),
	strip_asm_tac (rewrite_rule[] (simple_Š_match_mp_rule type_lemmas_thm tuple1_def))
	THEN
	simple_„_tac »abs : '1 ‹ '1 1TUPLE¼
	THEN
	REPEAT €_tac
	THEN_LIST_T
	[simple_„_tac »rep:'1 1TUPLE ‹ '1¼ THEN asm_rewrite_tac[],
	REPEAT simple_ƒ_tac THEN ‚_T2 
		(fn thm => ante_tac(ap_fun_rule »rep:'1 1TUPLE ‹ '1¼  thm) THEN
		asm_rewrite_tac[])
		(fn thm => pure_rewrite_tac[thm, eq_rewrite_thm]),
	simple_ƒ_tac THEN simple_„_tac »(rep:'1 1TUPLE ‹ '1) t¼ 
		THEN asm_rewrite_tac[]]));
=TEX
Now we can define $tuple\_spec$ itself.

First two local rewriting functions:
=SML
local
val rwc1 = pure_rewrite_conv[„_rewrite_thm];
val rwr1 = prim_rewrite_rule empty_net id_canon TOP_MAP_C
		[(»( x Ž y)z¼,simple_%beta%_conv)] 
		[tac_proof(([],»ƒ t Ž (T ‚ t) ‚ t¼),
			rewrite_tac[])];
in
=TEX
Start of main function.
Notice the addition of timing material to determine when this
is so slow - these will be removed in any product version.
=SML
fun âtuple_specá (arg: int) : THM = (
let
=TEX
The following finds pre-existing copies of the $tuple\_spec$
theorem, should they exist.
=SML
val start_time = System.processtime();
fun âfind_n_tupleá (n:int):THM OPT = (
let	val key = string_of_int n ^ "TUPLE";
in
	if is_Nil (get_type_arity key)
	then Nil
	else (let fun aux [] = fail "tuple_spec" 59003 [fn () => key]
	| aux (thy :: rest) = (Value(get_thm thy key)
		handle (Fail _) => aux rest)
	in
		aux (get_cache_theories())
	end)
end);
=TEX
The following declares a new n-tuple type, knowing that the type isn't
in scope.
=SML
fun âdeclare_n_tupleá (n:int) :THM = (
let	val was_thy = get_current_theory_name();
in let
	val cache_thy = (hd(get_cache_theories()))
		handle complaint =>
		divert complaint "hd" "tuple_spec" 59006 [];
	val sideeffect = if is_theory_ancestor cache_thy was_thy
		then ()
		else fail "tuple_spec" 59002 [fn () => cache_thy];
	val sideeffect = open_theory (hd(get_cache_theories()));
	val nstr = string_of_int n;
	val key = nstr ^ "TUPLE";
	val sideffect = ((get_thm cache_thy key;fail "tuple_spec" 59004 [fn () => key])
		handle complaint =>
		if area_of complaint = "get_thm"
		then ()
		else reraise complaint (area_of complaint));
	val inter = interval 1 n;
	val inters = map string_of_int inter;
	val tyvars = map (fn x => mk_vartype("'"^ x))
		inters;
=TEX
We will do our proof work by a binary split, basing our proof for $n$
on two previous theorems, one for $n\ div\ 2$, the other
$n - (n\ div\ 2)$.
We will access these theorems before creating the new type,
perhaps causing a cascade of proof.
=SML
	val ndiv2 = n div 2;
	val nrest = n - ndiv2;
	val ndiv2_thm = tuple_spec ndiv2;
	val nrest_thm = if ndiv2 = nrest
		then ndiv2_thm
		else tuple_spec nrest;
	val nrest_thm' = inst_type_rule 
		(combine (map (fn x => mk_vartype("'"^string_of_int x)) (interval (ndiv2+1) n))
		(map (fn x => mk_vartype("'"^string_of_int x)) (interval 1 nrest)))
		nrest_thm;
	val cndiv2_thm = concl ndiv2_thm;
	val cnrest_thm' = concl nrest_thm';
	val ntuples = list_variant[][fst(dest_simple_„ cndiv2_thm),
		fst(dest_simple_„ cnrest_thm')];
	val tuple1 = hd ntuples;
	val tuple2 = hd(tl ntuples);
	val nlabels = list_variant[]
		(fst(strip_simple_„(fst(dest_€(snd(dest_simple_„ cndiv2_thm))))) @
		fst(strip_simple_„(fst(dest_€(snd(dest_simple_„ cnrest_thm'))))));
	val rep_type = mk_‰_type (last_‹_type(type_of tuple1), 
		last_‹_type(type_of tuple2));
	val abs_type = mk_ctype(key,tyvars);
	val x = mk_var("x",rep_type);
	val „_thm_concl = mk_simple_„(x,
		mk_app(mk_simple_(x,mk_t),x));
	val „_thm = ‚_t_elim((BINDER_C simple_%beta%_conv
		THEN_C rwc1)„_thm_concl);
	val sideeffect = diag_string ("Defining type :"^key);
	val n_tuple_def = new_type_defn (key,key,map dest_vartype tyvars, „_thm)
		handle complaint =>
		pass_on complaint "new_type_defn" "labelled_product_spec";
	val done_defn_time = System.processtime();
=TEX
We now have the new type defined (by $n\_tuple\_def$), so let us create the form of the theorem
we wish to prove:
=SML
	val xi = map (fn x => mk_var("x"^x,mk_vartype("'"^ x))) inters;
	val yi = map (fn x => mk_var("y"^x,mk_vartype("'"^ x))) inters;
	val ntuple = mk_var(nstr^ "Tuple",list_mk_‹_type (tyvars @ [abs_type]));
	val labstr = "Lab"^nstr^"_";
	val labs = map (fn x => mk_var(labstr^x,
		mk_‹_type(abs_type,mk_vartype("'"^x)))) inters;
	val t = mk_var("t",abs_type);
	val ntuple_args = list_mk_app(ntuple,xi);
	val thm_concl = mk_simple_„(ntuple,
	  mk_€(
		list_mk_simple_„(labs,
		list_mk_simple_ƒ((t :: xi),
		list_mk_€(
		map (fn (lab,x) =>
		mk_eq(mk_app(lab,ntuple_args),x))
		(combine labs xi)
		@ [mk_eq(
		list_mk_app(ntuple,
		map (fn lab => mk_app(lab,t)) labs),
		t)])))
		,
		mk_€(
		 (list_mk_simple_ƒ(xi @ yi,mk_‚(mk_eq(ntuple_args,list_mk_app(ntuple,yi)),
			list_mk_€(map (fn (x,y) => mk_eq(x,y)) (combine xi yi))))),
		 (mk_simple_ƒ(t,
		 list_mk_simple_„(xi,
			 mk_eq(t,ntuple_args))))
		)
	));
=TEX
We now have the theorems conclusion, $thm\_concl$: now to prove it:
=SML
	val xito = xi to (ndiv2-1);
	val xifrom = xi from ndiv2;
	val abs = mk_var("abs",mk_‹_type(rep_type,abs_type));
	val rep = mk_var("rep",mk_‹_type(abs_type,rep_type));
	val n_tuple_witness =list_mk_simple_(xi,
		mk_app(abs,
		mk_pair(
		list_mk_app(tuple1,xito),
		list_mk_app(tuple2,xifrom))));
	val rept = mk_app(rep,t);
	val x_wits = (map (fn x => mk_app(x,mk_fst rept)))
			(nlabels  to (ndiv2-1)) @
		(map (fn x => mk_app(x,mk_snd rept))
			(nlabels  from ndiv2));
	val lab_wits = map (fn x => mk_simple_(t, x)) x_wits;
	val start_proof_time = System.processtime();
=TEX
The actual start of the proof. We first strip 
the definition of the new type, and the theorems for the
supporting results of $tuple\_spec$.
=SML
	val res_thm = 
	tac_proof(([],thm_concl),
	TIME_T "full tactic"(
	(TIME_T "stripping tuple thms"(lstrip_asm_tac ndiv2_thm THEN lstrip_asm_tac nrest_thm'))
	THEN
	(TIME_T "stripping type defn" (strip_asm_tac (rwr1 (simple_Š_match_mp_rule type_lemmas_thm n_tuple_def))))
	THEN
	TIME_T "main „" (simple_„_tac n_tuple_witness)
	THEN
=TEX
We now pull out the assumptions into variables, to allow more
precise handling,
and include some customised matching conversions,
tactics, etc.
=SML
	TIME_T "DROP_ASMS_T"
	(DROP_ASMS_T (fn asms =>
	let	val rep_abs_thm = nth 0 asms;
		val abs_rep_thm = nth 1 asms;
		val tuple2_eq_thm = nth 2 asms;
		val tuple2_labs_back_thm = nth 3 asms;
		val thm2s = initial_rw_canon tuple2_labs_back_thm;
		val tuple2_back_thm = nth nrest thm2s;
		val tuple2_labs_thms = thm2s to (nrest -1);
		val tuple1_eq_thm = nth 4 asms;
		val tuple1_labs_back_thm = nth 5 asms;
		val thm1s = initial_rw_canon tuple1_labs_back_thm;
		val tuple1_back_thm = nth ndiv2 thm1s;
		val tuple1_labs_thms = thm1s to (ndiv2 - 1);
		val match_rep_abs_thm_conv = (fn tm =>
			simple_ƒ_elim(snd(dest_app(snd(dest_app tm)))) 
			rep_abs_thm);
		val match_abs_rep_thm_conv = (fn tm =>
			simple_ƒ_elim(snd(dest_app(snd(dest_app tm)))) 
			abs_rep_thm);
		val match_tuple1_back_thm_conv = (fn tm =>
			simple_ƒ_elim(snd(dest_app(snd(dest_app tm)))) 
			tuple1_back_thm);
		val match_tuple2_back_thm_conv = (fn tm =>
			simple_ƒ_elim(snd(dest_app(snd(dest_app tm)))) 
			tuple2_back_thm);
		val ntuple_args_thm = tailored_beta_conv1 (list_mk_app(n_tuple_witness, xi));
		val local_tac1 = (
		conv_tac(RATOR_C(RAND_C (
		((RAND_C (fn x => ntuple_args_thm))
		THEN_C simple_%beta%_conv
		THEN_C
		(RAND_C(RAND_C match_rep_abs_thm_conv
		THEN_C (match_fst_thm_conv))))
		))))
		;
		val local_tac2 = (
		conv_tac(RATOR_C(RAND_C (
		((RAND_C (fn x => ntuple_args_thm))
		THEN_C simple_%beta%_conv
		THEN_C
		(RAND_C(RAND_C match_rep_abs_thm_conv
		THEN_C (match_snd_thm_conv))))
		))))
		;
		val local_tac3 = (
		conv_tac(RATOR_C(RAND_C (
		(tailored_beta_conv THEN_C
		RAND_C(PAIR_C2(match_tuple1_back_thm_conv)
			(match_tuple2_back_thm_conv)		
		THEN_C match_fst_snd_thm_conv)
		THEN_C match_abs_rep_thm_conv
		)))))
		;
	in
	TIME_T "REPEAT_€_COMPLETE_WITH"
	(REPEAT_€_COMPLETE_WITH	
=TEX
The proof is now split into handling three conjuncts,
the first and the third taking the bulk of the execution time.
The first conjunct proves the existence of projection
functions $Labn\_m$, and spends much of its time in $list\_simple\_„\_tac$.
=SML
	[(TIME_T "Conjunct 1"
	(list_simple_„_tac lab_wits THEN 
	REPEAT simple_ƒ_tac THEN 
	REPEAT_€_COMPLETE_WITH
	(map (fn thm => local_tac1 THEN 
		accept_tac (list_simple_ƒ_elim (rev xito) thm)) 
		tuple1_labs_thms @
	map (fn thm => local_tac2 THEN 
		accept_tac (list_simple_ƒ_elim (rev xifrom) thm)) 
		tuple2_labs_thms 
		@ [local_tac3 THEN accept_tac(refl_conv t)]
	)
	)),
=TEX
The second conjunct states a ``one-to-one'' result for the
abstraction function.
=SML
	(TIME_T "Conjunct 2"
	(REPEAT simple_ƒ_tac THEN  
	 conv_tac(RATOR_C(RAND_C (EQ_C tailored_beta_conv1))) THEN
		‚_T2 
		(fn thm => (accept_tac o list_€_intro o strip_€_rule)(
			conv_rule
			((EQ_C match_rep_abs_thm_conv THEN_C
			match_pair_eq_thm_conv THEN_C
			€_C2 (fn _ => list_simple_ƒ_elim
				(xito @ (yi to (ndiv2 - 1))) 
				tuple1_eq_thm)
			     (fn _ => list_simple_ƒ_elim
				(xifrom @ (yi from (ndiv2))) 
				tuple2_eq_thm)
			
			))
			(ap_fun_rule rep thm)))
		(fn thm => 
		subst_vars_tac thm
		THEN (fn (asms,gl) => accept_tac(refl_conv
			(fst(dest_eq gl))) (asms,gl))))
		),
=TEX
The third conjunction shows that the abstraction function ``covers'' the new type.
It is not clear way proving this conjunct takes 
approaching one half of the total execution time
for $tuple\_spec$.
It isn't spent in $list\_simple\_„\_tac$, unlike the first
conjunct.
=SML
	(TIME_T "Conjunct 3"
	(simple_ƒ_tac THEN list_simple_„_tac x_wits THEN 
	conv_tac(RAND_C (tailored_beta_conv1
	THEN_C RAND_C(PAIR_C2 (match_tuple1_back_thm_conv)
		(match_tuple2_back_thm_conv)
	THEN_C match_fst_snd_thm_conv)
	THEN_C match_abs_rep_thm_conv))
	THEN accept_tac (refl_conv t))
	)
	])
	end))));
	val done_proof_time = System.processtime();
	val sideeffect = diag_string (
		"Done defn at:" ^ string_of_int(done_defn_time - start_time) ^
		". Got thm concl at:"^string_of_int(start_proof_time - start_time) ^
		". Done proof at:"^string_of_int(done_proof_time - start_time)
	);
	val res = save_thm(key,res_thm);
	val sideeffect = open_theory was_thy;
in
	res
end
handle complaint =>
	(open_theory was_thy;
	reraise complaint (area_of complaint))
end
);
=TEX
Main function:
=SML
in
	if arg < 1 
	then fail "tuple_spec" 59001 [fn () => string_of_int arg]
	else (case (find_n_tuple arg) of
	Value thm => thm
	| Nil => declare_n_tuple arg)

end); (* of tuple_spec *)
end; (* of local *)
=TEX
\subsection{Labelled Products}
=IGN
val inp2 = {tyname = "HOLD2",tykey = "HOLD2",conname = "Hold2",
	constkeys= ["Hold2","First2","Second2"],
	labels = [("First2",†),("Second2",»:'1¼)],
	tyvars = Value[»:'1¼,»:'2¼]};
val inp3 = {tyname = "HOLD3",tykey = "HOLD3",conname = "Hold3",
	constkeys= ["Hold3","First3","Second3","Third3"],
	labels = [("First3",†),("Second3",»:'1¼),("Third3",»:'2¼)],
	tyvars = Value[»:'1¼,»:'2¼]};
val inp4 = {tyname = "HOLD4",tykey = "HOLD4",conname = "Hold4",
	constkeys= ["Hold4","First","Second","Third","Fourth"],
	labels = [("First",†),("Second",»:'1¼),("Third",»:'2¼),("Fourth",»:'1 ‰ '2¼)],
	tyvars = Value[»:'1¼,»:'2¼]};

val inp5 = {tyname = "HOLD5",tykey = "HOLD5",conname = "Hold5",
	constkeys= ["Hold5","First5","Second5","Third5","Fourth5","Fifth5"],
	labels = [("First5",†),("Second5",»:'1¼),("Third5",»:'2¼),("Fourth5",»:'1 ‰ '2¼),("Fifth5",»:'3¼)],
	tyvars = Value[»:'1¼,»:'2¼,»:'3¼]};
val inp6 = {tyname = "HOLD6",tykey = "HOLD6",conname = "Hold6",
	constkeys= ["Hold6","First6","Second6","Third6","Fourth6","Fifth6","Sixth6"],
	labels = [("First6",†),("Second6",»:'1¼),("Third6",»:'2¼),("Fourth6",»:'1 ‰ '2¼),("Fifth6",»:'3¼),("Sixth6",»:'1¼)],
	tyvars = Value[»:'1¼,»:'2¼,»:'3¼]};
val inp7 = {tyname = "HOLD7",tykey = "HOLD7",conname = "Hold7",
	constkeys= ["Hold7","First7","Second7","Third7","Fourth7","Fifth7","Sixth7","Seventh"],
	labels = [("First7",†),("Second7",»:'1¼),("Third7",»:'2¼),("Fourth7",»:'1 ‰ '2¼),("Fifth7",»:'3¼),("Sixth7",»:'1¼),
	("Seventh7",»:'1 ‰ '3¼)],
	tyvars = Value[»:'1¼,»:'2¼,»:'3¼]};
=SML
local
val rwc1 = pure_rewrite_conv[„_rewrite_thm];
val rwr1 = prim_rewrite_rule empty_net id_canon TOP_MAP_C
		[(»( x Ž y)z¼,simple_%beta%_conv)] 
		[tac_proof(([],»ƒ t Ž (T ‚ t) ‚ t¼),
			rewrite_tac[])];

in
fun âlabelled_product_specá {tyname:string, tykey:string, conname:string, 
	constkeys:string list, labels:(string*TYPE)list, tyvars:(TYPE list)OPT} : THM = (
let	val sideeffect = if is_nil constkeys orelse is_nil labels
		then fail "labelled_product_spec" 59010 []
		else();
	val nlabels = length labels;
	val nstr = string_of_int nlabels;
	val tuple_thm = tuple_spec nlabels
		handle complaint =>
		pass_on complaint "tuple_spec" "labelled_product_spec";
	val nm_tuple_type = nstr^"TUPLE";
	val (lab_nms,lab_types) = split labels;
	val rep_type = mk_ctype(nm_tuple_type,lab_types);
	val lab_tyvars = list_cup(map (fn x => map mk_vartype (type_tyvars x)) lab_types);
	val used_tyvars = case tyvars of
		Nil => lab_tyvars
		| Value tys => (if lab_tyvars subset tys
			then (map dest_vartype tys
				handle complaint =>
				pass_on complaint "dest_vartype" "labelled_product_spec"; tys)
			else fail "labelled_product_spec" 6057 [
			fn () => "A label",
			fn () => format_list(dest_vartype) (lab_tyvars diff tys) ", "]);
	val abs_type = mk_ctype(tyname, used_tyvars);
	val x = mk_var("x",rep_type);
	val „_thm_concl = mk_simple_„(x,
		mk_app(mk_simple_(x,mk_t),x));
	val „_thm = ‚_t_elim((BINDER_C simple_%beta%_conv
		THEN_C rwc1)„_thm_concl);
=TEX
Before we actually declare the new type we attempt to ensure that we will be able to introduce the new constants
as requested.
We do not catch the failure of constants being already defined in child theories,
nor are we very good at presenting al the errors we know.
=SML
	val used_keys = mapfilter (fn x => (get_defn "-" x;x))
		(tykey :: constkeys);
	val sideeffect = if is_nil used_keys
		then ()
		else fail "labelled_product_spec" 6052 [fn () => hd used_keys,
			fn () => get_current_theory_name ()];
	val used_constants = mapfilter (fn x => (force_value(get_const_type x);x))
		(conname :: lab_nms);
	val sideeffect = if is_nil used_constants
		then ()
		else fail "labelled_product_spec" 6049 [fn () => hd used_constants];
=TEX
Now the definition itself, which will flush out any writability problems that constant specification will have.
=SML
	val type_def = new_type_defn (tyname,tykey,map dest_vartype used_tyvars, „_thm)
		handle complaint =>
		pass_on complaint "new_type_defn" "labelled_product_spec";
	val tuple_thm' = „_€_left_rule tuple_thm;
	val inter = interval 1 nlabels;
	val inters = map string_of_int inter;
	val tyinsts = combine lab_types (map (fn s => mk_vartype ("'"^s)) inters);
	val tuple_thm'' = inst_type_rule tyinsts tuple_thm';
	val labs = map (fn (x,ty) => mk_var(x,mk_‹_type(abs_type,ty))) labels;
	val xi = map mk_var(combine (map (fn x => "x"^x) inters) lab_types);
	val con = mk_var(conname,list_mk_‹_type (lab_types @ [abs_type]));
	val t = mk_var("t",abs_type);
	val con_args = list_mk_app(con,xi);
	val abs = mk_var("abs",mk_‹_type(rep_type,abs_type));
	val rep = mk_var("rep",mk_‹_type(abs_type,rep_type));
	val thm_concl = mk_simple_„(con,
		list_mk_simple_„(labs,
		list_mk_simple_ƒ((t :: xi),
		list_mk_€(
		map (fn (lab,x) =>
		mk_eq(mk_app(lab,con_args),x))
		(combine labs xi)
		@ [mk_eq(
		list_mk_app(con,
		map (fn lab => mk_app(lab,t)) labs),
		t)]))));
	val replabstr = "Lab"^nstr^"_";
	val replabs = map (fn (x,ty) => mk_var(replabstr^x,
		mk_‹_type(rep_type,ty))) (combine inters lab_types);
	val ntuple = mk_var(nstr^ "Tuple",list_mk_‹_type (lab_types @ [rep_type]));
	val ntuple_args = list_mk_app(ntuple,xi);
	val con_wit = list_mk_simple_(xi,mk_app(abs,ntuple_args));
	val lab_wits = map (fn x => 
		mk_simple_(t,mk_app(x,mk_app(rep,t)))) replabs;
	val res_thm = 
	tac_proof(([],thm_concl),
	TIME_T "Main tactic"
	(TIME_T "stripping" (strip_asm_tac tuple_thm'' THEN 
	strip_asm_tac (rwr1 (simple_Š_match_mp_rule type_lemmas_thm type_def)))
	THEN
	TIME_T "list_simple_„_tac" (list_simple_„_tac (con_wit :: lab_wits))
	THEN
	REPEAT simple_ƒ_tac THEN 
	TIME_T "DROP_ASMS_T"
	(DROP_ASMS_T (fn asms =>
	let	val rep_abs_thm = nth 0 asms;
		val abs_rep_thm = nth 1 asms;
		val other_asm = nth 2 asms;
		val other_asms = strip_€_rule
			(all_simple_ƒ_elim other_asm);
		val tuple_back_thm = (simple_ƒ_intro 
			(fst(dest_simple_ƒ(concl other_asm))) 
			(nth nlabels other_asms));
		val tuple_labs_thms = other_asms to (nlabels-1);
 		val match_rep_abs_thm_conv = (fn tm =>
			simple_ƒ_elim(snd(dest_app(snd(dest_app tm)))) 
			rep_abs_thm);
		val match_abs_rep_thm_conv = (fn tm =>
			simple_ƒ_elim(snd(dest_app(snd(dest_app tm)))) 
			abs_rep_thm);
		val match_tuple_back_thm_conv = (fn tm =>
			simple_ƒ_elim(snd(dest_app(snd(dest_app tm)))) 
			tuple_back_thm);
		val ntuple_args_thm = tailored_beta_conv1 (list_mk_app(con_wit, xi));
		val local_tac1 = (
		conv_tac(RATOR_C(RAND_C (
		((RAND_C (fn x => ntuple_args_thm))
		THEN_C simple_%beta%_conv
		THEN_C
		(RAND_C match_rep_abs_thm_conv))
		))))
		;
		val local_tac2 = (
		conv_tac(RATOR_C(RAND_C (
		(tailored_beta_conv THEN_C
		RAND_C(match_tuple_back_thm_conv))
		THEN_C match_abs_rep_thm_conv
		))))
		;
	in
	TIME_T "REPEAT_€_COMPLETE_WITH"
	(REPEAT_€_COMPLETE_WITH	
	(map (fn thm => local_tac1 THEN accept_tac thm) 
		tuple_labs_thms
		@ [local_tac2 THEN accept_tac(refl_conv t)]))
	end
	))));
in
	(new_specification(constkeys,1+nlabels,res_thm)
		handle complaint =>
		pass_on complaint "new_specification" "labelled_product_spec")
end); (* labelled_product_spec *)
end; (* of local *)
=TEX
\subsection{Unlabelled Products}
=IGN
val ulp2 = {tyname="ULP2", tykey="ULP2", conname="Ulp2", 
	conkeys=["Ulp2"], tyi=[»:'a ‰ 'b¼,»:'a ‰ 'b¼], 
	tyvars = Value [»:'a¼,»:'b¼]};
val ulp3 = {tyname="ULP3", tykey="ULP3", conname="Ulp3", 
	conkeys=["Ulp3"], tyi=[»:'a ‰ 'b¼,»:'a ‰ 'b¼,»:†¼], 
	tyvars = Value [»:'a¼,»:'b¼]};
val ulp4 = {tyname="ULP4", tykey="ULP4", conname="Ulp4", 
	conkeys=["Ulp4"], tyi=[»:'a ‰ 'b¼,»:'a ‰ 'b¼,»:†¼,»:'c ‰ 'a¼], 
	tyvars = Value [»:'a¼,»:'b¼,»:'c¼]};
val ulp5 = {tyname="ULP5", tykey="ULP5", conname="Ulp5", 
	conkeys=["Ulp5"], tyi=[»:'a ‰ 'b¼,»:'a ‰ 'b¼,»:†¼,»:'c ‰ 'a¼,BOOL], 
	tyvars = Nil};
val ulp6 = {tyname="ULP6", tykey="ULP6", conname="Ulp6", 
	conkeys=["Ulp6"], tyi=[»:'a ‰ 'b¼,»:'a ‰ 'b¼,»:†¼,»:'c ‰ 'a¼,BOOL,»:'1¼], 
	tyvars = Nil};
val ulp7 = {tyname="ULP7", tykey="ULP7", conname="Ulp7", 
	conkeys=["Ulp7"], tyi=[»:'d ‰ BOOL¼,»:'a ‰ 'b¼,»:'a ‰ 'b¼,»:†¼,»:'c ‰ 'a¼,BOOL,»:'1¼], 
	tyvars = Nil};
=SML
local
val rwc1 = pure_rewrite_conv[„_rewrite_thm];
val rwr1 = prim_rewrite_rule empty_net id_canon TOP_MAP_C
		[(»( x Ž y)z¼,simple_%beta%_conv)] 
		[tac_proof(([],»ƒ t Ž (T ‚ t) ‚ t¼),
			rewrite_tac[])];

in
fun âunlabelled_product_specá {tyname:string, tykey:string, conname:string, 
	conkeys:string list, tyi: TYPE list, tyvars:(TYPE list)OPT} : THM = (
let	val sideeffect = if is_nil conkeys orelse is_nil tyi
		then fail "unlabelled_product_spec" 59010 []
		else();
	val nlabels = length tyi;
	val nstr = string_of_int nlabels;
	val tuple_thm = tuple_spec nlabels
		handle complaint =>
		pass_on complaint "tuple_spec" "labelled_product_spec";
	val nm_tuple_type = nstr^"TUPLE";
	val rep_type = mk_ctype(nm_tuple_type,tyi);
	val lab_tyvars = list_cup(map (fn x => map mk_vartype (type_tyvars x)) tyi);
	val used_tyvars = case tyvars of
		Nil => lab_tyvars
		| Value tys => (if lab_tyvars subset tys
			then (map dest_vartype tys
				handle complaint =>
				pass_on complaint "dest_vartype" "labelled_product_spec"; tys)
			else fail "labelled_product_spec" 6057 [
			fn () => "A label",
			fn () => format_list(dest_vartype) (lab_tyvars diff tys) ", "]);
	val abs_type = mk_ctype(tyname, used_tyvars);
	val x = mk_var("x",rep_type);
	val „_thm_concl = mk_simple_„(x,
		mk_app(mk_simple_(x,mk_t),x));
	val „_thm = ‚_t_elim((BINDER_C simple_%beta%_conv
		THEN_C rwc1)„_thm_concl);
=TEX
Before we actually declare the new type we attempt to ensure that we will be able to introduce the new constants
as requested.
We do not catch the failure of constants being already defined in child theories,
nor are we very good at presenting al the errors we know.
=SML
	val used_keys = mapfilter (fn x => (get_defn "-" x;x))
		(tykey :: conkeys);
	val sideeffect = if is_nil used_keys
		then ()
		else fail "labelled_product_spec" 6052 [fn () => hd used_keys,
			fn () => get_current_theory_name ()];
	val sideeffect = case (get_const_type conname) of
		Value _ =>fail "unlabelled_product_spec" 6049 [fn () => conname]
		| Nil => ();
=TEX
Now the definition itself, which will flush out any writability problems that constant specification will have.
=SML
	val type_def = new_type_defn (tyname,tykey,map dest_vartype used_tyvars, „_thm)
		handle complaint =>
		pass_on complaint "new_type_defn" "unlabelled_product_spec";
	val tuple_thm' = „_€_right_rule tuple_thm;
	val inter = interval 1 nlabels;
	val inters = map string_of_int inter;
	val tyinsts = combine tyi (map (fn s => mk_vartype ("'"^s)) inters);
	val tuple_thm'' = inst_type_rule tyinsts tuple_thm';
	val xi = map mk_var(combine (map (fn x => "x"^x) inters) tyi);
	val yi = map mk_var(combine (map (fn x => "y"^x) inters) tyi);
	val con = mk_var(conname,list_mk_‹_type (tyi @ [abs_type]));
	val t = mk_var("t",abs_type);
	val con_args = list_mk_app(con,xi);
	val abs = mk_var("abs",mk_‹_type(rep_type,abs_type));
	val rep = mk_var("rep",mk_‹_type(abs_type,rep_type));

	val thm_concl = mk_simple_„(con,
		mk_€(
		(list_mk_simple_ƒ(xi @ yi,
		 mk_‚(mk_eq(con_args,list_mk_app(con,yi)),
			list_mk_€(map (fn (x,y) => mk_eq(x,y)) (combine xi yi))))),
		 (mk_simple_ƒ(t,
		 list_mk_simple_„(xi,
			 mk_eq(t,con_args))))
		));
	val ntuple = mk_var(nstr^ "Tuple",list_mk_‹_type (tyi @ [rep_type]));
	val ntuple_args = list_mk_app(ntuple,xi);
	val con_wit = list_mk_simple_(xi,mk_app(abs,ntuple_args));
	val res_thm = 
	tac_proof(([],thm_concl),
	TIME_T "Main tactic"
	(TIME_T "stripping" (strip_asm_tac tuple_thm'' THEN 
	strip_asm_tac (rwr1 (simple_Š_match_mp_rule type_lemmas_thm type_def)))
	THEN
	TIME_T "simple_„_tac" (simple_„_tac con_wit)
	THEN
	TIME_T "DROP_ASMS_T"
	(DROP_ASMS_T (fn asms =>
	let	val rep_abs_thm = nth 0 asms;
		val abs_rep_thm = nth 1 asms;
		val cover_thm = nth 2 asms;
		val eq_thm = nth 3 asms;
 		val match_rep_abs_thm_conv = (fn tm =>
			simple_ƒ_elim(snd(dest_app(snd(dest_app tm)))) 
			rep_abs_thm);
		val match_abs_rep_thm_conv = (fn tm =>
			simple_ƒ_elim(snd(dest_app(snd(dest_app tm)))) 
			abs_rep_thm);
	in
	TIME_T "€_tac THEN_LIST_T"
	(€_tac THEN_LIST_T	
	[(REPEAT simple_ƒ_tac THEN 
	conv_tac (RATOR_C(RAND_C (EQ_C tailored_beta_conv1)))
	THEN 
	‚_T2 
		(fn thm => accept_tac(
			conv_rule
			((EQ_C match_rep_abs_thm_conv THEN_C
			(fn _ => all_simple_ƒ_elim eq_thm)			
			))
			(ap_fun_rule rep thm)))
		(fn thm => 
		subst_vars_tac thm
		THEN (fn (asms,gl) => accept_tac(refl_conv
			(fst(dest_eq gl))) (asms,gl))
		)),
	(simple_ƒ_tac THEN 
	REPEAT_TTCL STRIP_THM_THEN 
	(fn sthm =>
	list_simple_„_tac xi THEN
	conv_tac(RAND_C (tailored_beta_conv1
		THEN_C(RAND_C(fn _ => eq_sym_rule sthm))
		THEN_C match_abs_rep_thm_conv)))
		(simple_ƒ_elim (mk_app(rep,t)) cover_thm)
	THEN accept_tac(refl_conv t)
	)])
	end
	))));
in
	(new_specification(conkeys,1,res_thm)
		handle complaint =>
		pass_on complaint "new_specification" "unlabelled_product_spec")
end); (* of unlabelled_product_spec *)
end; (* of local *)
=TEX
\section{EPILOGUE}
=IGN
val _ = open_theory lthy;
val _ = pop_proof_context();
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",
	lsubgoal_package_quiet);
end; (* of structure ProductTypes *)
open ProductTypes;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
=IGN
This is a one shot proof, that works in isolation,
and roughly doubles for each increment of $n$,
with n = 5 being 33 seconds to evaluate.

Create pair types and terms:

fun list_mk_‰_type ([ty]:TYPE list):TYPE = ty
| list_mk_‰_type (a :: x) = mk_‰_type (a, list_mk_‰_type x)
| list_mk_‰_type [] = fail "list_mk_‰_type" 0 [];

fun list_mk_pair ([tm]:TERM list):TERM = tm
| list_mk_pair (a :: x) = mk_pair (a, list_mk_pair x)
| list_mk_pair [] = fail "list_mk_pair" 0 [];

local
val rwc1 = pure_rewrite_conv[„_rewrite_thm];
val rwr1 = prim_rewrite_rule empty_net id_canon TOP_MAP_C
		[(»( x Ž y)z¼,simple_%beta%_conv)] 
		[tac_proof(([],»ƒ t Ž (T ‚ t) ‚ t¼),
			rewrite_tac[])];
val rwt2 = asm_rewrite_tac(initial_rw_canon pair_clauses to 4);

val rwt3 = pure_asm_rewrite_tac[tac_proof(([],»ƒ tŽ(t Š t) ‚ T¼),
		rewrite_tac[]),
		tac_proof(([],»ƒ x y p qŽ ((x,y) = (p,q)) ‚ ((x = p) € (y = q))¼),
		rewrite_tac[pair_clauses])];
val rwt4 = pure_asm_rewrite_tac[tac_proof(([],»ƒ tŽ(Fst t, Snd t) = t¼),
		rewrite_tac[pair_clauses]),
		eq_rewrite_thm];

in
	val rep_type = list_mk_‰_type tyvars;
	val abs = mk_var("abs",mk_‹_type(rep_type,abs_type));
	val rep = mk_var("rep",mk_‹_type(abs_type,rep_type));
	val n_tuple_witness = list_mk_simple_(xi,
		mk_app(abs,list_mk_pair xi));
	fun aux [l] tm = [tm]
	| aux (a :: x) tm = mk_fst tm :: aux x (mk_snd tm)
	| aux _ _ = fail "tuple_spec" 0 [];
	val x_wits = aux labs (mk_app(rep,t));
	val lab_wits = map (fn x => mk_simple_(t,x)) x_wits;
	val res_thm = 
	tac_proof(([],thm_concl),
	strip_asm_tac (rwr1 (simple_Š_match_mp_rule type_lemmas_thm n_tuple_def))
	THEN
	simple_„_tac n_tuple_witness
	THEN
	conv_tac all_simple_%beta%_conv
	THEN
	REPEAT €_tac
	THEN_LIST_T
	[MAP_EVERY_T simple_„_tac lab_wits THEN rwt2,
	REPEAT simple_ƒ_tac THEN ‚_T2 
		(fn thm => ante_tac(ap_fun_rule rep thm) THEN
		rwt3)
		(fn thm => pure_rewrite_tac[thm, eq_rewrite_thm]),
	simple_ƒ_tac THEN MAP_EVERY_T simple_„_tac x_wits THEN rwt4]);



fun stat_sort (nm1,x1) (nm2,x2) = if x1 = x2
	then stringorder nm1 nm2
	else x1 - x2;

val simple_„_intro_thm = … ƒ P xŽ P x Š $„ P

val simple_„_intro_thm = (let 
	val tva = mk_vartype "'a";
	val tvb = mk_vartype "'b";
	val P = mk_var("P",mk_‹_type(tva,BOOL));
	val x = mk_var("x",tva);
	val Px = mk_app(P, x);
	val s1 = asm_rule Px;
	val s2 = ‡_intro_rule s1;
	val abs = mk_simple_(x,Px);
	val s3 = ap_arg_rule P „_def;
	val s4 = simple_%beta%_conv (snd(dest_eq(concl s3)));
	val s5 = eq_trans_rule s3 s4;
	val s6 = eq_sym_rule s5;
	val s7 = ‚_mp_rule s6 s2;
	val s8 = Š_intro Px s7;
	val s9 = simple_ƒ_intro x s8;
	val s10 = simple_ƒ_intro P s9;
in
	s10
end);

local
	val tva = mk_vartype "'a";
in
fun simple_„_intro (tm : TERM) (thm : THM) : THM = (
let	val (x, t1x) = dest_simple_„ tm
		handle complaint =>
		pass_on complaint "dest_simple_„" "simple_„_intro";
	val abs = snd(dest_app tm);
	val t2 = (case term_match (concl thm) t1x of
		(_, [(ltm, _)]) => ltm
		|(_, []) => x
		|Other => fail "simple_„_intro" 7047 [
			fn () => string_of_term tm,
			fn () => string_of_thm thm])
		handle complaint =>
		divert complaint "term_match" "simple_„_intro" 7047 [
			fn () => string_of_term tm,
			fn () => string_of_thm thm];
	val s1 = inst_type_rule[(type_of x, tva)]simple_„_intro_thm;
	val s2 = list_simple_ƒ_elim[abs,t2]s1;
	val abst2 = fst(dest_Š(concl s2));
	val s3 = simple_%beta%_conv abst2;
	val s4 = eq_sym_rule s3;
	val s5 = ‚_mp_rule s4 thm;
	val s6 = Š_elim s2 s5;
in
	(prof "simple_„_intro";
	s6)
end);
end;
val simple_„_elim_thm = (let 
	val tva = mk_vartype "'a";
	val tvb = mk_vartype "'b";
	val t1 = mk_var("t1",mk_‹_type(tva,BOOL));
	val t2 = mk_var("t2",BOOL);
	val y = mk_var("y",tva);
	val ƒt1y = mk_simple_ƒ(y,mk_Š(mk_app(t1,y),t2));
	
	val „t1 = mk_app(mk_const("„",mk_‹_type(mk_‹_type(tva,BOOL),BOOL)),t1);
	
	val s1 = asm_rule „t1;
	val s2 = ap_arg_rule t1 „_def;
	val s3 = ‚_mp_rule s2 s1;
	val s4 = simple_%beta%_conv (concl s3);
	val s5 = ‚_mp_rule s4 s3;
	val s6 = asm_rule ƒt1y;
	val s7 = simple_ƒ_elim (snd(dest_app(concl s5))) s6;
	val s8 = Š_elim s7 s5;
	val s9 = Š_intro ƒt1y s8;
	val s10 = Š_intro „t1 s9;
	val s11 = simple_ƒ_intro t2 s10;
	val s12 = simple_ƒ_intro t1 s11;
in
	s12
end);
local
	val tva = mk_vartype "'a";
in
fun simple_„_elim (v : TERM) (thm1 : THM) (thm2 : THM) : THM = (
let	val sideeffect = if is_var v
		then ()
		else term_fail "simple_„_elim" 3007 [v];
	val cthm1 = concl thm1;
	val (x, tx) = dest_simple_„ cthm1;
	val t1 = snd(dest_app cthm1);
	val t1v = mk_app (t1, v);
	val t2 = concl thm2;
	val sideeffect = if is_free_in v t2
		then fail "simple_„_elim" 7120 [
			fn () => string_of_term v,
			fn () => string_of_thm thm2]
		else ();
	val s1 = inst_type_rule [(type_of x,tva)] simple_„_elim_thm;
	val s2 = list_simple_ƒ_elim[t1,t2] s1;
	val s3 = Š_elim s2 thm1;
	val s4 = simple_%beta%_conv t1v;
	val t1y = snd(dest_eq(concl s4));
	val s5 = asm_rule t1v; (* fst(‚_elim...) *)
	val s6 = ‚_mp_rule s4 s5;
	val s8 = Š_intro t1y thm2;
	val s9 = Š_elim s8 s6;
	val s10 = Š_intro t1v s9;
	val s11 = simple_ƒ_intro v s10
		handle complaint =>
		divert complaint "simple_ƒ_intro" "simple_„_elim" 7121 [
			fn () => string_of_term v,
			fn () => string_of_thm thm2,
			fn () => string_of_term t1y];
	val s12 = Š_elim s3 s11;
in
	(prof "simple_„_elim";
	s12)
end
handle complaint =>
list_divert complaint "simple_„_elim" [
	("dest_simple_„",7109,[fn () => string_of_thm thm1]),
	("mk_app",7014,[fn () => string_of_term v])
	]
);
end;

