% imp009.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation of Tactics I}
\TPPref{DS/FMU/IED/DTD009}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
first group of tactics and tacticals in ICL HOL.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\item[Issue 1.6]
$always\_tac$ and $always\_ttcl$ renamed to $id\_tac$ and $id\_ttcl$.
\item [Issue 1.7]
Renamings of functions containing the name atom $simple$,
and renaming of $aconv$.
\item [Issue 1.11]
Function $format\_term$ has new argument.
\item [Issue 1.12, 1.13]
Reacting to issue 1.16 of \cite{DS/FMU/IED/DTD009}.
\item [Issue 1.14]
Corrected error message for $conv\_tac$.

\item[Issue \SCCSversion, \FormatDate{92/01/20} ] Updated to use new fonts.

\end{description}
\subsection{Changes Forecast}
Most of the text outside the documentation boxes is a discussion
of the design process, rather than being part of the final design.
It will thus be removed or rephrased in later issues.
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for material
whose detailed design is given in in \cite{DS/FMU/IED/DTD009}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
See \cite{DS/FMU/IED/DTD009}.
\subsubsection{Dependencies}
This document depends on the derived rules of inference implemented
in \cite{DS/FMU/IED/IMP007}.
\subsubsection{Deficiencies}
$simple\_tac\_proof$ currently uses the non-standard function $makestring$ to
format a list of goals for inclusion in an error message. This saves some work here
on pretty-printing goals. It would be better style if a $format\_seq$ function where available
in the pretty-printer module for use here.
\section{PREAMBLE}
=SML
structure ÛTactics1Ý : Tactics1 = struct
=TEX
=SML
open PrettyPrinter;
=TEX
\section{TYPE ABBREVIATIONS}
=SML
type GOAL		=	SEQ;
type PROOF		=	THM list -> THM;
type TACTIC		=	GOAL -> (GOAL list * PROOF);
=TEX
\section{UTILITIES}
\[mapshape\,[(f_1, n_1),(f_2, n_2) \ldots]\,[a_1,a_2 \ldots]\]
is \[[f_1[a_1,\ldots, a_{n_1}], f_2[a_{n_1+1},\ldots, a_{n_1+n_2}], \ldots]\].
It is used to combine proofs.
=SML
fun ÛmapshapeÝ (fns : (('a list -> 'b) * int) list)(args : 'a  list) : 'b list = (
	case fns of
		((f, n) :: morefns) => (
			f (args to (n-1)) :: mapshape morefns (args from n)
	) |	[] => []
);
=TEX
The following ought perhaps be elsewhere, and infix:
=SML
fun Ûterm_diffÝ (tml1:TERM list) (tml2:TERM list): TERM list =  (
	fold ((op less) o swap) tml2 tml1
);
=TEX
=SML
fun Ûbad_proofÝ (name : string) = (
	error name 9001 []
);
=TEX
=SML
fun Ûseq_eqÝ ((asms1, conc1) : GOAL) ((asms2, conc2) : GOAL) : bool = (
	let	fun	aux (t1 :: more1) (t2 :: more2) = %alpha%_eq t1 t2 andalso aux more1 more2
		|	aux [] [] = true
		|	aux _ _ = false;
	in	%alpha%_eq conc1 conc2 andalso aux asms1 asms2
	end
);
=TEX
\subsection{BASIC TACTICS 1}
=SML
val Ûid_tacÝ : TACTIC = (fn gl =>
	([gl], (fn [x] => x | _ => bad_proof "id_tac"))
);
=TEX
=SML
val Ûfail_tacÝ : TACTIC = (fn gl =>
	fail "fail_tac" 9201 []
);
=TEX
=SML
fun Ûfail_with_tacÝ (area : string) (msg : int) (inserts : (unit -> string) list): TACTIC = (fn gl =>
	fail area msg inserts
);
=TEX
=SML
fun Ûprove_asm_ruleÝ (thm1 : THM) (thm2 : THM) : THM = (
let
        val c1 = concl thm1;
        val s1 = ´_intro c1 thm2;
        val s2 = ´_elim s1 thm1;
in
        (prof "prove_asm_rule";
        s2)
end);
=TEX
\section{ELEMENTARY TACTICALS}
=SML
fun ((tac1 : TACTIC) ÛTHEN_TÝ (tac2 : TACTIC)) : TACTIC = (fn gl =>
	let	val (sgs1, pf) = tac1 gl;
		val (sgs2pfs2) = (map tac2 sgs1);
	in	(flat (map fst sgs2pfs2),
		pf o mapshape (map (fn (sgs, pf) => (pf, length sgs))sgs2pfs2))
	end
);
=TEX
=SML
val op ÛTHENÝ : (TACTIC * TACTIC) -> TACTIC = op THEN_T;
=TEX
=SML
fun (tac : TACTIC) ÛTHEN_LIST_TÝ (tacs : TACTIC list) : TACTIC = (fn gl =>
	let	val (sgs1, pf) = tac gl;
	in	if length tacs = length sgs1
		then	let	val sgs2pfs2 = (map (fn (f, a) => f a) (combine tacs sgs1));
			in	(flat (map fst sgs2pfs2),
				pf o mapshape (map (fn (sgs, pf) => (pf, length sgs))sgs2pfs2))
			end
		else	fail "THEN_LIST_T" 9101 []
	end
);
val op ÛTHEN_LISTÝ : (TACTIC * TACTIC list) -> TACTIC = op THEN_LIST_T;
=TEX
=SML
fun ÛEVERY_TÝ (tacs : TACTIC list) :  TACTIC = (fn gl =>
	(fold (op THEN_T) tacs id_tac) gl
);
=TEX
=SML
val ÛEVERYÝ : TACTIC list -> TACTIC = EVERY_T;
=TEX
=SML
fun ÛMAP_EVERY_TÝ (tacf : 'a -> TACTIC) (things : 'a list) : TACTIC = (
	EVERY (map tacf things)
);
=TEX
=SML
val ÛMAP_EVERYÝ : ('a -> TACTIC) -> 'a list -> TACTIC = MAP_EVERY_T;
=TEX
=SML
fun ((tac1 : TACTIC) ÛORELSE_TÝ (tac2 : TACTIC)) : TACTIC = (fn gl =>
	(tac1 gl) handle (Fail _) => tac2 gl
);
=TEX
=SML
val op ÛORELSEÝ : (TACTIC * TACTIC) -> TACTIC = op ORELSE_T;
=TEX
=SML
fun ÛFIRST_TÝ (tacs : TACTIC list) : TACTIC = (fn gl => 
	(fold (op ORELSE_T) tacs (fail_with_tac "FIRST_T" 9105 [])) gl
);
=TEX
=SML
val ÛFIRSTÝ : TACTIC list -> TACTIC = FIRST_T;
=TEX
=SML
fun ÛMAP_FIRST_TÝ (tacf : 'a -> TACTIC) (things : 'a list) : TACTIC = (
	FIRST (map tacf things)
);
=TEX
=SML
val ÛMAP_FIRSTÝ : ('a -> TACTIC) -> 'a list -> TACTIC = MAP_FIRST_T;
=TEX
=SML
fun ÛCOND_TÝ (p : GOAL -> bool) (tac1 : TACTIC) (tac2 : TACTIC) : TACTIC = (fn gl =>
	(if p gl then tac1 else tac2) gl
);
fun ÛREPEAT_TÝ (tac : TACTIC) : TACTIC = (fn g =>
	((tac THEN REPEAT_T tac) ORELSE_T id_tac) g
);
=TEX
=SML
val ÛREPEATÝ : TACTIC -> TACTIC = REPEAT_T;
=TEX
=SML
fun ÛREPEAT_N_TÝ (n : int) (tac : TACTIC) : TACTIC = (
	let	fun aux n g = (
			(if n > 0
			then tac THEN aux (n-1)
			else id_tac) g
		);
	in	aux n
	end
);
=TEX
=SML
val ÛREPEAT_NÝ : int -> TACTIC -> TACTIC = REPEAT_N_T;
=TEX
=SML
fun ÛREPEAT_UNTIL_TÝ (p : GOAL -> bool) (tac : TACTIC) : TACTIC = (
	REPEAT (COND_T p fail_tac tac)
);
=TEX
=SML
val ÛREPEAT_UNTILÝ : (GOAL -> bool) -> TACTIC -> TACTIC = REPEAT_UNTIL_T;
=TEX
\section{BASIC THEOREM TACTICALS AND COMBINATORS}
=SML
type ÛTHM_TACTICÝ = THM -> TACTIC;

type ÛTHM_TACTICALÝ = THM_TACTIC -> THM_TACTIC;
=TEX
=SML
val op ÛTHEN_TTCLÝ : (THM_TACTICAL * THM_TACTICAL) -> THM_TACTICAL = op o;
=TEX
=SML
fun  (ttcl1 : THM_TACTICAL) ÛORELSE_TTCLÝ (ttcl2 : THM_TACTICAL)
				: THM_TACTICAL = (fn ttac => fn th =>
	(ttcl1 ttac th) handle (Fail _) => (ttcl2 ttac th)
);
=TEX
=SML
val ÛID_THENÝ : THM_TACTICAL = Combinators.I;
=TEX
=SML
fun ÛCONV_THENÝ (conv : CONV) : THM_TACTICAL = (fn ttac => fn thm =>
	let	val thm1 = conv (concl thm);
	in	(ttac(¤_mp_rule thm1 thm)
		handle ex => divert ex "¤_mp_rule" "CONV_THEN" 9400 
		[fn () => string_of_thm thm1])
	end
);
=TEX
=SML
fun ÛFAIL_WITH_THENÝ (area : string) (msg : int) (inserts : (unit -> string) list)
						: THM_TACTICAL = (fn _ =>
	fail area msg inserts
);
=TEX
=SML
val ÛFAIL_THENÝ : THM_TACTICAL = (fn _ =>
	fail "FAIL_THEN" 9401 []
);
=TEX
=SML
fun ÛREPEAT_TTCLÝ (ttcl : THM_TACTICAL) : THM_TACTICAL= (fn ttac => fn th =>
	((ttcl THEN_TTCL (REPEAT_TTCL ttcl)) ORELSE_TTCL ID_THEN) ttac th
);
=TEX
=SML
fun ÛEVERY_TTCLÝ (ttcls : THM_TACTICAL list) : THM_TACTICAL = (
	fold op THEN_TTCL ttcls ID_THEN
);
=TEX
=SML
fun ÛFIRST_TTCLÝ (ttcls : THM_TACTICAL list) : THM_TACTICAL= (
	fold op ORELSE_TTCL ttcls (FAIL_WITH_THEN "FIRST_TTCL" 9402 [])
);
=TEX
\section{BASIC TACTICALS}
\subsection{Using Assumptions}
=SML
fun ÛGET_ASM_TÝ (tm : TERM) (thmtac : (THM -> TACTIC))
						: TACTIC = (fn gl as (asms, _) =>
	if tm term_mem asms
	then thmtac (asm_rule tm) gl
	else term_fail "GET_ASM_T" 9301 [tm]
);
fun ÛLIST_GET_ASM_TÝ (tml : TERM list) 
	(thmtac : (THM list -> TACTIC))
					: TACTIC = (fn gl as (asms, _) =>
	if all tml (fn tm => tm term_mem asms)
	then thmtac (map asm_rule tml) gl
	else term_fail "LIST_GET_ASM_T" 9301 
		[find tml (fn tm => not(tm term_mem asms))]
);
fun ÛDROP_ASM_TÝ (tm : TERM) (thmtac : (THM -> TACTIC))
						: TACTIC = (fn (asms, conc) =>
	if tm term_mem asms
	then (thmtac (asm_rule tm))(asms term_less tm, conc)
	else term_fail "DROP_ASM_T" 9301 [tm]
);
=TEX
=SML
fun ÛLIST_DROP_ASM_TÝ (tml : TERM list) 
		(thmtac : (THM list -> TACTIC))
					: TACTIC = (fn (asms, conc) =>
	if all tml (fn tm => tm term_mem asms)
	then (thmtac (map asm_rule tml))(term_diff asms tml, conc)
	else term_fail "LIST_DROP_ASM_T" 9301 
		[find tml (fn tm => not(tm term_mem asms))]
);
=TEX
=SML
fun ÛTOP_ASM_TÝ (thmtac : (THM -> TACTIC)) : TACTIC = (fn gl as (asms, _) =>
	case asms of
		asm :: _ => thmtac (asm_rule asm) gl
	|	_ =>  fail "TOP_ASM_T" 9302 []
);
=TEX
=SML
fun ÛPOP_ASM_TÝ (thmtac : (THM -> TACTIC)) : TACTIC = (fn (asms, conc) =>
	case asms of
		asm :: more => (thmtac (asm_rule asm))(more term_less asm, conc)
	|	_ =>  fail "POP_ASM_T" 9302 []
);
=TEX
=SML
fun ÛGET_ASMS_TÝ (thmstac : (THM list -> TACTIC)) : TACTIC = (fn gl as (asms, _) =>
	thmstac (map asm_rule asms) gl
);
=TEX
=SML
fun ÛDROP_ASMS_TÝ (thmstac : (THM list -> TACTIC)) : TACTIC = (fn (asms, conc) =>
	(thmstac (map asm_rule asms))([], conc)
);
=TEX
=SML
fun ÛGET_NTH_ASM_TÝ (i : int) (thmtac : (THM -> TACTIC))
						: TACTIC = (fn gl as (asms, _) =>
	((GET_ASM_T  (nth (i-1) asms) thmtac) gl)
	handle ex => divert ex "nth" "GET_NTH_ASM_T" 9303 [fn () => string_of_int i]
);
fun ÛLIST_GET_NTH_ASM_TÝ (ilst : int list) 
		(thmtac : (THM list -> TACTIC))
					: TACTIC = (fn gl as (asms, _) =>
	((LIST_GET_ASM_T  (map (fn i => nth (i-1) asms) ilst) thmtac) gl)
	handle ex => divert ex "nth" "LIST_GET_NTH_ASM_T" 9303 [fn () => 
		(let val lasms = length asms;
			val ei = find ilst (fn i => i> lasms orelse i < 0);
		in
			string_of_int ei
		end)]
);
fun ÛDROP_NTH_ASM_TÝ (i : int) (thmtac : (THM -> TACTIC))
						: TACTIC = (fn gl as (asms, _) =>
	((DROP_ASM_T  (nth (i-1) asms) thmtac) gl)
	handle ex => divert ex "nth" "DROP_NTH_ASM_T" 9303 [fn () => string_of_int i]
);
fun ÛLIST_DROP_NTH_ASM_TÝ (ilst : int list) 
		(thmtac : (THM list -> TACTIC))
					: TACTIC = (fn gl as (asms, _) =>
	(LIST_DROP_ASM_T  (map(fn i => nth (i-1) asms)ilst) thmtac) gl
	handle ex => divert ex "nth" "LIST_DROP_NTH_ASM_T" 9303 [fn () => 
		(let val lasms = length asms;
			val ei = find ilst (fn i => i> lasms orelse i < 0);
		in
			string_of_int ei
		end)]
);
=TEX
\subsection{Utility Tacticals}
=SML
fun ÛROTATE_TÝ (i : int) (tac : TACTIC) : TACTIC = (fn gl =>
	case tac gl of
		sgp as ([], _) => sgp
	|	(sgs, pf) => (
		let	val n = (length sgs);
			val i' = i mod n;
			val r' = n - i';
			val sgs' = (sgs from i') @ (sgs to (i'-1));
			fun pf' ths = (
				if length ths <> n
				then bad_proof "ROTATE_T"
				else pf ((ths from r') @ (ths to (r'-1)))
			);
		in	(sgs', pf')
		end
	)	
);
=TEX
=SML
fun ÛLEMMA_TÝ (newsg : TERM) (thmtac : THM -> TACTIC) : TACTIC = (fn gl as (asms, _) =>
	let	val (sgs, pf) = thmtac (asm_rule newsg) gl;
	in	((asms, newsg) :: sgs,
		(fn (thm :: thms) => prove_asm_rule thm (pf thms) |
		[] => bad_proof "LEMMA_T"))
	end	handle ex =>	if area_of ex = "asm_rule"
				then term_fail "LEMMA_T" 9603 [newsg]
				else raise ex
);
=TEX
=SML
fun ÛTRY_TÝ (tac : TACTIC) : TACTIC = tac ORELSE id_tac;
=TEX
=SML
fun ÛCHANGED_TÝ (tac : TACTIC) : TACTIC = (fn gl =>
	case tac gl of
		sgp as ([gl'], _) => (
			if seq_eq gl gl'
			then	fail "CHANGED_T" 9601 []
			else sgp
	) |	sgp => sgp
);
=TEX
=SML
fun ÛSOLVED_TÝ (tac : TACTIC) : TACTIC = (fn gl =>
	case tac gl of
		sgp as ([], _) => (sgp
	) |	sgp => fail "SOLVED_T" 9602 []
);
=TEX
\section{BASIC TACTICS 2}
=SML
fun Ûaccept_tacÝ (thm : THM) : TACTIC = (fn (asms, conc) =>
	if %alpha%_eq conc (concl thm) 
	then	([], (fn [] => thm | _ => bad_proof "accept_tac"))
	else	fail "accept_tac" 9102 [fn () => string_of_thm thm,
		fn () => string_of_term conc]
);
=TEX
=SML
fun  Ûasm_tacÝ (thm : THM) : TACTIC = (fn (asms, conc) =>
	([((concl thm) :: asms, conc)],
	(fn [thm1] => prove_asm_rule thm thm1 | _ => bad_proof "asm_tac"))
);
=TEX
=SML
fun Ûconv_tacÝ (conv : CONV) : TACTIC = (fn (asms, conc) =>
	let	val thm = conv conc;
		val (lhs, rhs) = dest_eq (concl thm);
	in	if is_t rhs
		then	([],
			(fn _ => ¤_t_elim thm))
		else ([(asms, rhs)],
			(fn [thm1] => ((¤_mp_rule (eq_sym_rule thm) thm1)
				handle ex => divert ex "¤_mp_rule" "conv_tac" 9400 
				[fn () => string_of_thm thm])
			| _ => bad_proof "conv_tac"))
	end
);
=TEX
\section{USING TACTICS}
=SML
fun simple_tac_proof (gl : GOAL, tac : TACTIC) : THM = (
	case (tac gl)
		handle Fail msg => fail "simple_tac_proof" 9502 [fn()=>get_message msg]
	 of
		([], pf) => ((pf [])
		handle Fail msg => fail "simple_tac_proof" 9503 [fn()=>get_message msg])
	|	(sgs, pf) => fail "simple_tac_proof" 9501 [fn () => PolyML.makestring sgs]
);
=TEX
$tac\_proof$ is surprisingly complicated. First of all we check that
the goal contains no duplicated assumptions and that all the terms in the
goal are boolean. we then use $simple\_tac\_proof$ to attempt to
prove the goal; this will either fail, in which case
$tac\_proof$ fails, or it will result in a theorem, $thm$ say.
Assume that the original goal was $([t1, \ldots, tk], c)$ and that the
$thm$ is $t1', \ldots, tm' ô c'$. We discharge each $t_i$ from $thm$ which
should produce a theorem of the form $ôt1 ´ \ldots ´ tk ´ c'$.
We check this by using $¤\_mp\_rule$ to attempt to derive
$ôt1 ´ \ldots ´ tk ´ c$ from it. If this succeeds and gives a theorem
with no assumptions then we can undischarge the $t_i$ to give the desired
theorem, otherwise the tactic has not achieved the desired goal and we report
an error.
=SML
fun tac_proof (gl as (asms, conc) : GOAL, tac : TACTIC) : THM = (
	let	fun chk_asms (asm :: more) = (
			if any more (%alpha%_eq asm)
			then term_fail "tac_proof" 9505 [asm, find more (%alpha%_eq asm)]
			else if type_of asm <> BOOL
			then term_fail "tac_proof" 9506 [asm]
			else chk_asms more
		) | chk_asms [] = ();
		val side_effect1 = chk_asms asms;
		val side_effect2 = (
			if type_of conc <> BOOL
			then term_fail  "tac_proof" 9507 [conc]
			else ());
		val thm = (simple_tac_proof(gl, tac))
			handle exn => reraise exn "tac_proof";
		fun aux1 (asm :: more) thm = ´_intro asm (aux1 more thm)
		| aux1 [] thm = thm;
		val thm' = ¤_mp_rule(refl_conv(list_mk_´(asms@[conc])))(aux1 asms thm)
			handle Fail _ => fail "tac_proof" 9504 [];
		fun aux2 (_ :: more) thm = undisch_rule (aux2 more thm)
		|   aux2 [] thm = thm;
	in	case hyps thm' of
			[] => aux2 asms thm'
		|	_ => fail "tac_proof" 9504 []
	end
);
=TEX
=SML
end; (* of structure Tactics1 *)
open Tactics1;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


