% imp027.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the Derived Rules of Inference II}  %% Mandatory field
\def\TPPheadtitle{Implementation for the \cr Derived Rules of Inference II}
\TPPref{DS/FMU/IED/IMP027}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{The implementation of the second group of derived rules of inference is given in this document.
They mainly concern handling paired abstractions.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1,1.2,1.3]
First drafts.
\item [Issue 1.4]
Changes to match issue 1.8 of \cite{DS/FMU/IED/DTD027}.
\item [Issue 1.5]
``Minimised'' theory in which work is done.

\item[Issue 1.6, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 1.7]
Changed theory in which work is done.
\item[Issue 1.8,1.9(13th February 1992)]
Moving material from 058 to 027.
\item [Issue 1.10(11th March 1992)]
Various minor additions and extensions.
\item [Issue 1.11(1st April 1992)]
Removed sets material.
\end{description}
\subsection{Changes Forecast}
More detailed descriptions of the tricky algorithms.
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the derived rules of inference part II.
This primarily concerns adding paired abstraction handling
to the functions of \cite{DS/FMU/IED/DTD007}.
This is called for in \cite{DS/FMU/IED/HLD012}.
The design is in \cite{DS/FMU/IED/DTD027},
and the functions tested in \cite{DS/FMU/IED/MDT027}
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the derived rules of inference part II.
This primarily concerns adding paired abstraction handling
to the functions of \cite{DS/FMU/IED/DTD007}.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD027}.
\subsubsection{Deficiencies}
Some of the coding could be tightened - e.g. eliminating uses of
$simple\-\_eq\-\_match\-\_conv$.
\subsubsection{Possible Enhancements}
None known.

\section{THE CODE}
=SML
structure ÛDerivedRules2Ý : DerivedRules2 = struct
=TEX
=SML
val Ûwas_theoryÝ = get_current_theory_name ();
val _ = open_theory "basic_hol";
=TEX
\subsection{Local Theorems}
We will need these in various places:
=SML
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",true);
val µ_uncurry_thm = (push_goal([],¬µ f :'a ­ 'b ­ BOOL · $µ (Uncurry f) ¤ 
		µ x · f (Fst x) (Snd x)®);
	a simple_µ_tac;
	a(rewrite_tac[µ_def]);
	a(rewrite_tac[ext_thm, pair_clauses]);
	pop_thm());
val fst_thm = tac_proof(([],¬µ a b · Fst (a,b) = a®),
	rewrite_tac[pair_clauses]);
val snd_thm = tac_proof(([],¬µ a b · Snd (a,b) = b®),
	rewrite_tac[pair_clauses]);
val sµ_uncurry_thm = (push_goal([],¬µ f :'a ­ 'b ­ BOOL · 
		(µ x · f (Fst x) (Snd x)) ¤ $
		µ (Uncurry f)®);
	a simple_µ_tac;
	a(rewrite_tac[µ_def]);
	a(rewrite_tac[ext_thm, pair_clauses]);
	pop_thm());
val sfst_thm = tac_proof(([],¬µ a b · a = Fst (a,b)®),
	rewrite_tac[pair_clauses]);
val ssnd_thm = tac_proof(([],¬µ a b · b = Snd (a,b)®),
	rewrite_tac[pair_clauses]);
val sfst_snd_thm = tac_proof(([],¬µ x · (Fst x,Snd x) = x®),
	rewrite_tac[pair_clauses]);
val ¶_uncurry_thm = (push_goal([],
		¬µ f · $¶ (Uncurry f) = ¶ x · f (Fst x) (Snd x)®);
	a simple_µ_tac;
	a(rewrite_tac[pair_clauses, ¶_def]);
	a(LEMMA_T ¬Uncurry f = Ì x · f (Fst x) (Snd x)®
		(fn x => rewrite_tac[x]));
	a(rewrite_tac[ext_thm, pair_clauses]);
	pop_thm());
val s¶_uncurry_thm = (push_goal([],
		¬µ f · (¶ x · f (Fst x) (Snd x)) = $¶ (Uncurry f)®);
	a simple_µ_tac;
	a(rewrite_tac[pair_clauses, ¶_def]);
	a(LEMMA_T ¬Uncurry f = Ì x · f (Fst x) (Snd x)®
		(fn x => rewrite_tac[x]));
	a(rewrite_tac[ext_thm, pair_clauses]);
	pop_thm());
val uc_thm = tac_proof(([],¬µ f · Uncurry f =
	Ì x · f (Fst x) (Snd x)®),
	rewrite_tac[ext_thm, pair_clauses]);
val ³_µ_uncurry_thm = (push_goal([],
		¬µ f · (³($µ(Uncurry f))) = ¶ p q · ³ f p q®);
	a (strip_tac THEN rewrite_tac[uc_thm]);
	a (REPEAT strip_tac);
	(* *** Goal "1" *** *)
	a(MAP_EVERY_T simple_¶_tac [¬Fst x®,¬Snd x®] THEN
		asm_rewrite_tac[]);
	(* *** Goal "2" *** *)
	a(simple_¶_tac ¬(p,q)® THEN
		asm_rewrite_tac[pair_clauses]);
	pop_thm());
val lsubgoal_package_quiet = set_flag("subgoal_package_quiet",
	lsubgoal_package_quiet);
=TEX
\subsection{Local Functions}
=SML
fun Ûmatch_simple_µ_elimÝ (tm:TERM) (thm:THM) = (
let	val (v,_) = dest_simple_µ (concl thm);
	val thm1 = inst_type_rule (fst(term_match tm v)) thm;
	val thm2 = simple_µ_elim tm thm1
in
	thm2
end);
=TEX
Note that $flat\_vs$ should not be capable of failing
on , e.g., the first part of the result of a $dest\_µ$
=SML
fun Ûflat_vsÝ (caller : string) (tm1:TERM) : TERM list = (
let	fun aux tm = (
	if is_var tm 
	then [tm]
	else ( let val (tm1,tm2) = dest_pair tm
		handle complaint =>
		divert complaint "dest_pair" caller 4016 [
			fn () => string_of_term tm];
	in
		(aux tm1 @ aux tm2)
	end));
in
	aux tm1
end);
=TEX
=SML
fun Ûmk_fstÝ tm = (
let	val ttm = type_of tm;
	val (ta,tb) = dest_¸_type ttm;
in
	mk_app(mk_const("Fst", mk_­_type(ttm,ta)), tm)
end);
fun Ûmk_sndÝ tm = (
let	val ttm = type_of tm;
	val (ta,tb) = dest_¸_type ttm;
in
	mk_app(mk_const("Snd", mk_­_type(ttm,tb)), tm)
end);
=TEX
The following are used in getting type instantiations.
=SML
val ÛtvaÝ = ¬:'a®;
val ÛtvbÝ = ¬:'b®;
val ÛtvcÝ = ¬:'c®;
=TEX
=SML
fun Ûtwo_the_sameÝ ((a:''a) :: x) : ''a OPT = (
	if a mem x
 	then Value a
 	else two_the_same x
) | two_the_same [] = Nil;
=TEX
The following function makes a variant variable structure
from a given list of frees, and duplicates within.
The conditional is given to prevent a new term being incorporated
that is equal to the old one.
=SML
fun Ûvarstruct_variantÝ (na : TERM list) (tm : TERM) : TERM = (
let	val nms = (map (fst o dest_var) na) cup []
		handle complaint =>
		pass_on complaint "dest_var" "varstruct_variant";
	fun aux anms tm = (
		if is_var tm
		then (let val (nm,ty) = dest_var tm;
			val nm' = string_variant anms nm;
		in
			((nm' :: anms), mk_var(nm', ty))
		end)
		else (let val (v1,v2) = dest_pair tm;
			val (anms',v2') = aux anms v2;
			val (anms'',v1') = aux anms' v1;
		in
			(anms'', mk_pair(v1',v2'))
		end)
	);
	val tm' = snd(aux nms tm)
in
	if tm' = tm
	then tm
	else tm'
end
handle complaint =>
divert complaint "dest_pair" "varstruct_variant" 4016
	[fn () => string_of_term tm]);
=TEX
Rename duplicate variables in a variable structure:
note this will fail on items that are not variable structures.
It must only rename name {\em and} type duplicates,
not just naming duplicates.
It must not rename any variable that was not initially duplicated.
I.e. the avoid list is only for new names, not current ones.
In these conditions it differs from $varstruct\_variant$,
and should only be used when these conditions are appropriate.
=SML
fun  Ûrename_dupsÝ (av: TERM list) (tm : TERM) = (
let	val orig_vars = frees tm;
	val av_nms = list_cup [(map (fst o dest_var) (orig_vars @ av))];
	fun rd_aux av seen tm1 = (
		if is_var tm1
		then (if tm1 mem seen
			then (let 
			val (nm,ty) = dest_var tm1;
			val new_nm = string_variant av nm;
			val new = mk_var(new_nm,ty);
			in
			(((new_nm :: av),seen),new)
			end)
			else ((av, (tm1 :: seen)), tm1)
		) else (let val (ftm,stm) = dest_pair tm1;
			val ((av',seen'),stm') = rd_aux av seen stm;
			val ((av'',seen''),ftm') = rd_aux av' seen' ftm;
		in
			((av'', seen''), mk_pair(ftm',stm'))
		end)
	);
in
	snd(rd_aux av_nms [] tm)
end
handle complaint =>
divert complaint "dest_pair" "rename_dups" 4016
	[fn () => string_of_term tm]);
=IGN
Tests:
rename_dups [] ¬(x,y)®; (* ¬(x,y)® *)
rename_dups [] (mk_pair(¬x:'a®,¬x:'b®)); (* ¬(x,x)® *)
rename_dups [] ¬(x,x)®; (* ¬(x',x)® *)
rename_dups [] ¬(x',x,x)®; (* ¬(x',x'',x)® *)
=TEX
\subsection{Core Paired Abstraction Functions}
The following functions provide a core, around which,
in combination with the rules for \cite{DS/FMU/IED/DTD007},
we can implement the other rules of \cite{DS/FMU/IED/DTD027}.

In the following we try to fail as fast as possible:
we could instead immediately try $simple\_\beta\_conv$,
and only be clever if we fail.
\subsubsection{Concerning Ì}
We do $Ì\_varstruct\_conv$ in with $\beta\_conv$ for a little
extra speed (as we have some of the necessary preprocessing
done).
It can be written as a derived rule, if so desired.
=SML
local
val uncurry_def = get_defn "pair" "Uncurry";
val fst_snd_thm = tac_proof(([],¬µ p · p = (Fst p, Snd p)®),
	rewrite_tac[pair_clauses]);
val prc = TRY_C(pure_rewrite_conv [sfst_snd_thm]);

fun aux (vs: TERM) (vl : TERM) : CONV = (
	if is_var vs
	then simple_Â_conv
	else if is_pair vl
	then (let  	val (vs1,vs2) = dest_pair vs;
			val (vl1,vl2) = dest_pair vl;
		in
			simple_eq_match_1_conv uncurry_def THEN_C
			RATOR_C (aux vs1 vl1) THEN_C
			aux vs2 vl2
		end
	) else (let	val vl_thm = match_simple_µ_elim vl fst_snd_thm;
			val vl' = snd(dest_eq(concl vl_thm));
		in
		RAND_C (fn x => vl_thm) THEN_C aux vs vl'
		end
	)
);
in
val ÛÂ_convÝ : CONV = (fn (tm : TERM) =>
let	val (br,vl) = dest_app tm
		handle complaint =>
		divert complaint "dest_app" "Â_conv" 27008
			[fn () => string_of_term tm];
	val res = (simple_Â_conv tm
		handle (Fail _) =>
		(let	val (vs,_) = (dest_Ì br
			handle complaint =>
			divert complaint "dest_app" "Â_conv" 27008
			[fn () => string_of_term tm]);
		in
			aux vs vl tm
		end));
in
	res
end);
=TEX
If pulling together $Fst$ and $Snd$ can solve a failure,
then it will, in step $s4$.
=SML
fun ÛÌ_varstruct_convÝ (tm1 : TERM) : CONV = (fn (tm2:TERM) =>
let	val totm1 = type_of tm1;
	val (dom,ran) = dest_­_type totm1;
	val x = hd(gen_vars [dom] [tm1, tm2]);
	val tm1' = mk_app(tm1,x);
	val tm2' = mk_app(tm2,x);
	val (vs1,_) = dest_Ì tm1;
	val (vs2,_) = dest_Ì tm2;
	val s1 = aux vs1 x tm1';
	val s2 = aux vs2 x tm2';
	val s3 = eq_sym_rule s1;
	val s4 = eq_trans_rule s2 s3
		handle (Fail _) =>
		eq_trans_rule (conv_rule (RAND_C prc) s2) 
		(conv_rule (RATOR_C prc) s3);
	val s5 = simple_µ_intro x s4;
	val s6 = inst_type_rule [(dom,tva),(ran,tvb)] ext_thm;
	val s7 = list_simple_µ_elim [tm2, tm1] s6;
	val s8 = eq_sym_rule s7;
	val s9 = ¤_mp_rule s8 s5;
in
	s9
end
handle (Fail _) =>
term_fail "Ì_varstruct_conv" 27050 [tm1,tm2]
);
end;
=TEX
=SML
local 
	val uc_type = ¬:('a ­ 'b ­ 'c) ­ 'a ¸ 'b ­ 'c®;
in
fun ÛÌ_eq_ruleÝ (x : TERM) (thm : THM) : THM = (
let	val side_effect = if is_eq(concl thm)
		then ()
		else thm_fail "Ì_eq_rule" 6020 [thm];
	fun aux x1 thm1 = (
	if is_var x1
	then (simple_Ì_eq_rule x1 thm1 
		handle complaint =>
		pass_on complaint "simple_Ì_eq_rule" "Ì_eq_rule")
	else (let	val (p,q) = dest_pair x1
			handle complaint =>
			term_fail "Ì_eq_rule" 4016 [x];
		val s1 = aux q thm1;
		val s2 = aux p s1;
		val uct = inst_type[(type_of p,tva), 
			(type_of q,tvb), 
			(type_of (fst(dest_eq(concl thm1))),tvc)] 
			uc_type;
		val uc = mk_const("Uncurry", uct);
		val s3 = ap_fun_rule uc s2;
	in
		s3
	end));
in
	aux x thm
end);
end;		
=TEX
=SML
fun ÛÌ_CÝ (cnv : CONV) : CONV = (fn (tm : TERM) =>
let	val (x,b) = dest_Ì tm
		handle complaint =>
		pass_on complaint "dest_Ì" "Ì_C";
	val s1 = cnv b;
	val s2 = Ì_eq_rule x s1
		handle complaint =>
		divert complaint "Ì_eq_rule" "Ì_C" 7104 
			[fn () => string_of_thm s1];
in
	s2
end);
=TEX
This could be implemented by $RAND\_C\ o\ Ì\_C$ but the
following gives better diagnostics:
=SML
fun ÛCBINDER_CÝ (cnv :  CONV): CONV = (fn (tm : TERM) =>
let	val (binder,abs) = dest_app tm;
	val (x,b) = dest_Ì abs;
	val s1 = cnv b;
	val s2 = ap_fun_rule binder (Ì_eq_rule x s1)
		handle complaint =>
		list_divert complaint "CBINDER_C" [
			("Ì_eq_rule",7104,[fn () => string_of_thm s1]),
			("ap_fun_rule",7104,[fn () => string_of_thm s1])];	
in
	s2
end
handle complaint =>
list_divert complaint "CBINDER_C" [
	("dest_Ì",27035,[fn () => string_of_term tm]),
	("dest_app",27035,[fn () => string_of_term tm])]
);
=TEX
\subsubsection{Concerning µ}
=SML
fun Ûµ_elimÝ (tm : TERM) (thm : THM) : THM = (
	simple_µ_elim tm thm
handle (Fail _) =>
let	val (vs,bdy) = dest_µ(concl thm)
		handle complaint =>
		divert complaint "dest_µ" "µ_elim" 27011 
			[fn () => string_of_thm thm];
	val side_effect = if type_of tm <> type_of vs
		then fail "µ_elim"  27012 [
			fn () => string_of_thm thm,
			fn () => string_of_term tm]
		else ();
	val res = (
		let	val s1 = conv_rule(simple_eq_match_conv µ_uncurry_thm)
				thm;
			val s2 = simple_µ_elim tm s1;
			val s3 = if is_pair tm
				then conv_rule
				(APP_C (RAND_C (simple_eq_match_conv fst_thm),
				simple_eq_match_conv snd_thm)) s2
				else s2;
			val s4 = conv_rule(RATOR_C Â_conv THEN_C Â_conv)
				s3;
		in
			s4
		end
	);
in
	res
end);
=TEX
=SML
fun Ûlist_µ_elimÝ (tml : TERM list) (thm : THM): THM = (
	list_simple_µ_elim tml thm
handle (Fail _) =>
revfold (uncurry µ_elim) tml thm
);
=TEX
The algorithm to introduce a universally quantified $tm$ to $thm$ in the following is:
\begin{enumerate}
\item
Try $simple\_µ\_intro$ $tm$ $‡\ ô\ conc$. If that succeeds then stop, otherwise:
\item
Rename any duplicate variables in $tm$, avoiding variables found
free in the conclusion or assumptions.
\item
For the invocation to be correct $tm$ must be of the form $(p,\ q)$.
Convert the theorem into $‡\ ô\ (Ì\ p\ q\ ·\ conc)\ p\ q$.
\item
Instantiate each variable of $tm$ with the matching components of variable $x$ (created by $Fst$ and $Snd$)
where $x$ has the same type as $tm$.
\item
Rewrite any introduced instances of $Fst\ y,\ Snd\ y$ with $y$.
\item
Generalise for $x$.
\item
Match the result with the theorem
=GFT HOL
ô µ f· (µ x· f (Fst x) (Snd x)) ¤ $µ (Uncurry f)
=TEX
\item
This should leave a theorem in the desired form, because
the replacement for $f$ should be of the right form for the result to
be displayed as $µ\ tm\ ·\ conc$.
\end{enumerate}
We needn't avoid variables in $tm$ because they have to be of
a ``smaller'' type than the $x$ we create.
=SML
local
fun aux (av: TERM list) (tm : TERM) : (TERM * (TERM * TERM) list) = (
let 	val x = hd(gen_vars [type_of tm] av);
	fun aux1 x1 tm1 = (
		if is_var tm1
		then [(x1,tm1)]
		else  (let val (ftm1,stm1) = dest_pair tm1;
			val snms = aux1 (mk_snd x1) stm1;
			val fnms = aux1 (mk_fst x1) ftm1;
		in
			(fnms @ snms)
		end)
	);
in
	(x, aux1 x tm)
end);
val prc = pure_rewrite_conv [sfst_snd_thm];
in
fun Ûµ_introÝ (tm : TERM) (thm : THM) : THM = (
	simple_µ_intro tm thm
handle (Fail _) =>
let	val conc = concl thm;
	val cf = frees conc;
	val tf = frees tm;
	val hf = list_cup(map frees (hyps thm));
	val side_effect = if (any tf (fn x => x mem hf)) 
		then term_fail "µ_intro" 6005 [find tf (fn x => x mem hf)]
		else ();
	val unbound_cf = cf diff tf;
	val avoid = (unbound_cf @ hf);
	val tm' = rename_dups avoid tm
		handle complaint =>
		pass_on complaint "rename_dups" "µ_intro";
	val (vs1,vs2) = dest_pair tm';
	val s1 = conv_rule (fn x:TERM => eq_sym_rule 
		((RATOR_C Â_conv THEN_C Â_conv)
		(list_mk_app(list_mk_Ì([vs1,vs2],conc),[vs1,vs2])))) thm;
	val (x, insts) = aux avoid tm';
	val s2 = inst_term_rule insts s1;
	val s4 = conv_rule (TRY_C(RATOR_C(RAND_C prc) EITHER_C RAND_C prc)) s2;
	val s5 = simple_µ_intro x s4;
	val s6 = conv_rule(simple_eq_match_conv sµ_uncurry_thm) s5;
in
	s6
end);
end;
val Ûµ_uncurry_convÝ : CONV = (fn (tm : TERM) =>
let	val (vs,bdy) = dest_µ tm;
	val side_effect = if is_pair vs
		then ()
		else term_fail "µ_uncurry_conv" 27038 [tm];
	val fvs = flat_vs "µ_uncurry_conv"  vs;
	val res_tm = list_mk_simple_µ (fvs, bdy);
	val s1 = asm_rule tm;
	val s2 = µ_elim vs s1;
	val s3 = list_simple_µ_intro fvs s2;
	val s4 = disch_rule tm s3;
	val s5 = asm_rule res_tm;
	val s6 = list_simple_µ_elim fvs s5;
	val s7 = µ_intro vs s6;
	val s8 = disch_rule res_tm s7;
	val s9 = ¤_intro s4 s8;
in
	s9
end
handle complaint =>
list_divert complaint "µ_uncurry_conv" [
	("dest_µ", 27038, [fn () => string_of_term tm])
	]
);
=TEX
=SML
val Ûall_µ_uncurry_convÝ : CONV = (fn tm =>
let fun aux tm' = (
	let val (tm1,tm2) = dest_app tm';
	in
	(if fst(dest_const tm1) = "µ"
	then (if is_simple_Ì tm2
		then BINDER_C aux
		else (CBINDER_C aux EITHER_C µ_uncurry_conv)
	) else fail_conv) tm'
	end);
in
	aux tm
end
handle complaint =>
list_divert  complaint "all_µ_uncurry_conv" [
	("fail_conv",27041,[fn () => string_of_term tm]),
	("dest_const",27041,[fn () => string_of_term tm]),
	("dest_app",27041,[fn () => string_of_term tm]),
	("µ_uncurry_conv",27041,[fn () => string_of_term tm])]
);

val Ûall_µ_uncurry_ruleÝ = conv_rule(TRY_C all_µ_uncurry_conv);
=TEX
=SML
fun Ûall_µ_elimÝ (thm: THM): THM = (
	all_simple_µ_elim thm
handle (Fail _) =>
let	val thm' = all_µ_uncurry_rule thm;
in
	all_simple_µ_elim thm'
end);
=TEX
\subsubsection{Concerning Í}
=SML
local
	val pfs = pure_rewrite_conv[sfst_snd_thm];
in
fun ÛcÍ_elim_ruleÝ (vs :TERM) (cthm : THM) (wthm : THM) : THM = (
	Í_elim_rule vs cthm wthm
handle (Fail _) =>
let	val fvs = flat_vs "cÍ_elim_rule" vs;
	val side_effect = case (two_the_same fvs) of
		Value x => term_fail "cÍ_elim_rule" 27043 [x,vs]
		| Nil => ();
	val wconc = concl wthm;
	val cconc = concl cthm;
	val fwconc = frees wconc;
	val fcconc = frees cconc;
	val (t,ct) = dest_app cconc;
	val asm = mk_app (t,vs);
	val side_effect = if any fvs (fn x => x mem fcconc)
		then fail "cÍ_elim_rule" 27051 [
			fn () => string_of_term vs,
			fn () => string_of_thm cthm]
		else if any fvs (fn x => x mem fwconc)
		then fail "cÍ_elim_rule" 27051 [
			fn () => string_of_term vs,
			fn () => string_of_thm wthm]
		else ();
	val x = (case gen_vars [type_of vs] (fwconc @ fcconc @ fvs 
		@ hyps cthm @ hyps wthm) of
		[term] => term
		| _ => error "cÍ_elim_rule" 6032 [])
		handle complaint =>
		pass_on complaint "gen_vars" "cÍ_elim_rule";
	val s1 = ´_intro asm wthm;
	val s2 = µ_intro vs s1
		handle complaint =>
		if area_of complaint <> "µ_intro"
		then reraise complaint (area_of complaint)
		else fail "cÍ_elim_rule" 27052 [
			fn () => string_of_term vs,
			fn () => string_of_thm wthm,
			fn () => string_of_term asm];
	val s3 = µ_elim x s2;
	val s4 = conv_rule(RATOR_C(RAND_C pfs)) s3;
	val s5 = undisch_rule s4;
	val s6 = Í_elim_rule x cthm s5;
in
	s6
end
handle complaint =>
list_divert complaint "cÍ_elim_rule" [
	("dest_app", 7019, [fn () => string_of_thm cthm]),
	("mk_app", 7054, [fn () => string_of_term vs]),
	("pure_rewrite_conv", 27045, [fn () => string_of_term vs,
			fn () => string_of_thm cthm,
			fn () => string_of_thm wthm
		])
	]);
end;
=TEX
\subsubsection{Concerning ¶}
=SML
fun Ûv_¶_introÝ (v : TERM) (thm : THM) : THM = (
let	val conc = concl thm;
	val abs = mk_Ì (v,conc)
		handle complaint =>
		pass_on complaint "mk_Ì" "v_¶_intro";
	val abst2 = mk_app (abs, v);
	val s1 = Â_conv abst2;
	val s2 = eq_sym_rule s1;
	val s3 = ¤_mp_rule s2 thm;
	val s4 = Í_intro_rule s3;
	val s5 = inst_type_rule [(type_of v, mk_vartype "'a")] ¶_def;
	val s6 = ap_arg_rule abs s5;
	val s7 = simple_Â_conv (snd(dest_eq(concl s6)));
	val s8 = eq_trans_rule s6 s7;
	val s9 = eq_sym_rule s8;
	val s10 = ¤_mp_rule s9 s4;
in
	s10
end);
=TEX
The algorithm we use is:
\begin{enumerate}
\item
Try $simple\_¶\_intro$ $tm$ $‡\ ô\ conc$. If that succeeds then stop, otherwise:
\item
For the remaining calls $tm$ must be of the form
$¶\ (vs1,vs2)\ ·\ bdy$.
We rename any duplicate variables in $(vs1,vs2)$, avoiding variables found
free in the conclusion or assumptions.
\item
We determine what the variables in $(vs1,vs2)$ must match
in the conclusion of $thm$.
\item
From these matches we determine the matching structures to $(vs1,vs2)$, say $(ivs1,ivs2)$
\item
Convert the theorem into $‡\ ô\ (Ì\ vs1\ vs2\ ·\ conc)\ ivs1\ ivs2$.
\item
Convert the theorem to the form
$‡\ ô\ (Ì\ vs1\ vs2\ ·\ conc)\ (Fst(ivs1,ivs2))\ (Snd(ivs1,ivs2))$.
\item
Use $simple\_¶\_intro$ to get 
$‡\ ô\ ¶\ x·\ (Ì\ vs1\ vs2\ ·\ conc)\ (Fst x)\ (Snd x)$.
\item
Match the result with the theorem
=GFT HOL
ô µ f· (¶ x· f (Fst x) (Snd x)) ¤ $¶ (Uncurry f)
=TEX
\item
This should leave a theorem in the desired form, because
the replacement for $f$ should be of the right form for the result to
be displayed as $¶\ tm\ ·\ conc$.
\end{enumerate}
There is a certain amount of trickery involving removing
duplicate names in the variable structure in the below.
=SML
fun Û¶_introÝ (tm : TERM) (thm : THM) = (
	simple_¶_intro tm thm
handle (Fail _) =>
let	val (vs,bdy) = dest_¶ tm
		handle complaint =>
		pass_on complaint "dest_¶" "¶_intro";
	val conc = concl thm;
	val (tys,einsts) = term_match conc bdy;
	val side_effect = case tys of
		[] => ()
		| _ => fail "¶_intro" 7047 [
			fn () =>string_of_term tm,
			fn () => string_of_thm thm];
	val cf = frees conc;
	val tf = frees tm;
	val vs' = rename_dups (cf @ tf) vs;
	val (vs1',vs2') = dest_pair vs';
	val (vs1,vs2) = dest_pair vs;
	val ivs1 = subst einsts vs1;
	val ivs2 = subst einsts vs2;
	val ivs = mk_pair(ivs1,ivs2);
	val Ìbit = list_mk_Ì([vs1',vs2'],bdy);
	val s1 = conv_rule (fn x:TERM => eq_sym_rule 
		((RATOR_C Â_conv THEN_C Â_conv)
		(list_mk_app(Ìbit,[ivs1,ivs2])))) thm;
	val ty_inst = [(type_of vs1,tva),(type_of vs2,tvb)];
	val ivs1_thm = list_simple_µ_elim [ivs1,ivs2]
		(inst_type_rule ty_inst sfst_thm);
	val ivs2_thm = list_simple_µ_elim [ivs1,ivs2]
		(inst_type_rule ty_inst ssnd_thm);
	val s2 = conv_rule (APP_C((RAND_C (fn x => ivs1_thm),
			(fn x => ivs2_thm)))) s1;
	val hf = list_cup (map frees (hyps thm));
	val x = hd(gen_vars [type_of vs] (cf @ hf));
	val template = mk_simple_¶(x, 
		list_mk_app(Ìbit,[mk_fst x, mk_snd x]));
	val s3 = simple_¶_intro template s2;
	val s4 = conv_rule(simple_eq_match_conv s¶_uncurry_thm) s3;
in
	s4
end
handle complaint =>
list_divert complaint "¶_intro" [
	("term_match", 7047, [fn () => string_of_term tm,
		fn () => string_of_thm thm])
	]);
=TEX
=SML
fun Û¶_elimÝ (vs : TERM) (thm1 : THM) (thm2 : THM) : THM = (
	simple_¶_elim vs thm1 thm2
handle (Fail _) =>
let	val cthm1 = concl thm1;
	val cthm2 = concl thm2;
	val (vsx,tx) = dest_¶ cthm1;
	val (tys,subs) = term_match vsx vs;
	val side_effect = if is_nil tys
		then ()
		else fail "¶_elim" 27042 [
		fn () => string_of_term vs,
		fn () => string_of_thm thm1];
	val t1 = snd(dest_app cthm1);
	val fvs = frees vs;
	val fs_thm1 = frees cthm1 cup (list_cup (map frees (hyps thm1)));
	val fs_cthm2 = frees cthm2
	val all_frees = fs_thm1 cup fs_cthm2 cup 
		list_cup (map frees (hyps thm2));
	val vs' = rename_dups (all_frees diff fvs) vs;
	val t1v = mk_app (t1, vs');
	val tvx = (case gen_vars [BOOL] (all_frees @ (frees vs')) of
		[term] => term
		| _ => error "¶_elim" 6032 [])
		handle complaint =>
		pass_on complaint "gen_vars" "¶_elim";
	val s1 = inst_type_rule [(type_of vs, tva)] ¶_def;
	val s2 = ap_arg_rule t1 s1;
	val s3 = ¤_mp_rule s2 thm1;
	val s5 = conv_rule simple_Â_conv s3;
	val s6 = Â_conv t1v;
	val s7 = eq_sym_rule s6;
	val asm = fst(dest_eq(concl s7))
	val fs_thm2_less = fs_cthm2 cup 
		list_cup (map frees (hyps thm2 less asm));
	val s8 = ´_intro asm thm2;
	val template = mk_´ (tvx, cthm2);
	val s10 = subst_rule [(s7, tvx)] template s8;
	val s11 = undisch_rule s10;
	val s12 = (cÍ_elim_rule vs' s5 s11)
		handle complaint =>
		(if any fvs (fn x => x mem fs_thm1)
		then fail "¶_elim" 27051 [
			fn () => string_of_term vs,
			fn () => string_of_thm thm1]
		else if any fvs (fn x => x mem fs_thm2_less)
		then fail "¶_elim" 27052 [
			fn () => string_of_term vs,
			fn () => string_of_thm thm2,
			fn () => string_of_term asm]
		else 
		pass_on complaint "cÍ_elim_rule" "¶_elim");
in
	s12
end
handle complaint =>
list_divert complaint "¶_elim" [
	("term_match", 27042, [
		fn () => string_of_term vs,
		fn () => string_of_thm thm1]),
	("dest_¶", 27046, [fn () => string_of_thm thm1])
	]);
=TEX
=SML
local
	fun list_v_¶_intro tml thm = fold (uncurry v_¶_intro) tml thm;
	fun list_simple_¶_elim [] tm wthm = wthm
	| list_simple_¶_elim (v :: rest) tm wthm = (
		let	val tm' = mk_simple_¶(v, tm);
		in
		list_simple_¶_elim rest tm'
			(simple_¶_elim v (asm_rule tm') wthm)
		end);
		
in
val Û¶_uncurry_convÝ : CONV = (fn (tm : TERM) =>
let	val (vs,bdy) = dest_¶ tm;
	val side_effect = if is_pair vs
		then ()
		else term_fail "¶_uncurry_conv" 27047 [tm];
	val fvs = flat_vs "¶_uncurry_conv" vs;
	val res_tm = list_mk_simple_¶ (fvs, bdy);
	val s1 = asm_rule tm;
	val s2 = asm_rule bdy;
	val s3 = list_v_¶_intro fvs s2;
	val s4 = ¶_elim vs s1 s3;
	val s5 = disch_rule tm s4;

	val s6 = asm_rule res_tm;
	val s7 = v_¶_intro vs s2;
	val s8 = list_simple_¶_elim (rev fvs) bdy s7;
	val s9 = disch_rule res_tm s8;
	val s10 = ¤_intro s5 s9;
in
	s10
end
handle complaint =>
list_divert complaint "¶_uncurry_conv" [
	("dest_¶", 27047, [fn () => string_of_term tm])
	]
);
end;
=TEX
=SML
val Ûall_¶_uncurry_convÝ : CONV = (fn tm =>
let fun aux tm' = (
	let val (tm1,tm2) = dest_app tm';
	in
	(if fst(dest_const tm1) = "¶"
	then (if is_simple_Ì tm2
		then BINDER_C aux
		else (CBINDER_C aux EITHER_C ¶_uncurry_conv)
	) else fail_conv) tm'
	end);
in
	aux tm
end
handle complaint =>
list_divert  complaint "all_¶_uncurry_conv" [
	("fail_conv",27048,[fn () => string_of_term tm]),
	("dest_const",27048,[fn () => string_of_term tm]),
	("dest_app",27048,[fn () => string_of_term tm]),
	("¶_uncurry_conv",27048,[fn () => string_of_term tm])]
);
val Ûall_¶_uncurry_ruleÝ = conv_rule(TRY_C all_¶_uncurry_conv);
=TEX
\subsection{Derived Rules}
\subsection{Concerning ´}
=SML
fun Û´_match_mp_ruleÝ (thm1 : THM) : THM -> THM = (
let	val thm1' = all_µ_uncurry_rule thm1;
	val r' = simple_´_match_mp_rule thm1';
in
	(fn (thm2 : THM) =>
	r' thm2
	handle complaint =>
	thm_fail "´_match_mp_rule" 7044 [thm1, thm2])
end);
=TEX
=SML
fun Û´_match_mp_rule1Ý (thm1 : THM) : THM -> THM = (
let	val thm1' = all_µ_uncurry_rule thm1;
	val r' = simple_´_match_mp_rule1 thm1';
in
	(fn (thm2 : THM) =>
	r' thm2
	handle complaint =>
	thm_fail "´_match_mp_rule1" 7044 [thm1, thm2])
end);
=TEX
\subsection{Concerning ¤}
=SML
fun Û¤_match_mp_ruleÝ (thm1 : THM) : THM -> THM = (
let	val thm1' = all_µ_uncurry_rule thm1;
	val r' = simple_¤_match_mp_rule thm1';
in
	(fn (thm2 : THM) =>
	r' thm2
	handle complaint =>
	thm_fail "¤_match_mp_rule" 7044 [thm1, thm2])
end);
=TEX
=SML
fun Û¤_match_mp_rule1Ý (thm1 : THM) : THM -> THM = (
let	val thm1' = all_µ_uncurry_rule thm1;
	val r' = simple_¤_match_mp_rule1 thm1';
in
	(fn (thm2 : THM) =>
	r' thm2
	handle complaint =>
	thm_fail "¤_match_mp_rule1" 7044 [thm1, thm2])
end);
=TEX
\subsection{Concerning =}
=SML
fun Ûeq_match_convÝ (thm: THM): CONV = (
let	val thm' = all_µ_uncurry_rule thm;
	val c' = simple_eq_match_conv thm';
in
	(fn tm => c' tm
	handle complaint =>
	fail "eq_match_conv" 7044 [
		fn () => string_of_term tm,	
		fn () => string_of_thm thm])
end);
=TEX
=SML
fun Ûeq_match_conv1Ý (thm: THM): CONV = (
let	val thm' = all_µ_uncurry_rule thm;
	val c' = simple_eq_match_1_conv thm'
		handle complaint =>
		if area_of complaint <> "simple_eq_match_1_conv"
		then reraise complaint (area_of complaint)
		else thm_fail "eq_match_conv1" 27003 [thm];
in
	(fn tm => c' tm
	handle complaint =>
	fail "eq_match_conv1" 7044 [
		fn () => string_of_term tm,	
		fn () => string_of_thm thm])
end);
=TEX
\subsection{Concerning Ì}
=SML
fun ÛÂ_ruleÝ (thm : THM): THM = (
	conv_rule Â_conv thm
	handle complaint =>
	divert complaint "Â_conv" "Â_rule" 27007
		[fn () => string_of_thm thm]
);
=TEX
The below follows the pattern of $all\_simple\_\beta\_conv$,
except that arguments to $Ì$-abstractions must be checked for
$Ì$-abstractions within pairs:
we do not try to work out whether such
paired abstractions will be exposed - we assume they will be.
=SML
local
	fun is_paired_Ì tm = (
	let	val (tm1,tm2) = dest_pair tm;
	in
		is_paired_Ì tm1 orelse is_paired_Ì tm2
	end
	handle (Fail _) => is_Ì tm
	);
in	
val Ûall_Â_convÝ : CONV = (
let
fun rhs (thm: THM) : TERM = snd(dest_eq(concl thm));
fun asbc (tm : TERM) : THM OPT = (
let	val dt = dest_simple_term tm;

	fun aux1 thm1 thm2 = (
	let	val s1 = mk_app_rule thm1 thm2
	in
		Value (
		if not(is_Ì(rhs thm1))
		then s1
		else (let val s2 = conv_rule (RAND_C Â_conv) s1;
		in
		if is_paired_Ì(rhs thm2)
		then (
			case (asbc (rhs s2)) of
			Nil => s2
			| Value s3 => eq_trans_rule s2 s3
		) else s2
		end)
		)
	end);

	fun aux2 (f : TERM) (x : TERM) : THM OPT = (
	if is_Ì f
	then 	(Value(
		if is_paired_Ì x
		then ((Â_conv FURTHER_C(fn tm1 =>
			force_value (asbc tm1))) tm)
		else (Â_conv tm)
		))
	else Nil);

	fun aux (App (f, x)) = (
	let	val fr = asbc f;
		val xr = asbc x;
	in
		case (fr,xr) of
		(Nil, Nil) => aux2 f x
		| (Value frt,Nil) => aux1 frt (refl_conv x)
		| (Nil, Value xrt) => aux1 (refl_conv f) xrt
		| (Value frt, Value xrt) => aux1 frt xrt
	end
	) | aux (SimpleÌ (x, b)) = (
	let	val br = asbc b
	in
		case br of
		Nil => Nil
		| (Value brt) => Value(simple_Ì_eq_rule x brt)
	end
	) | aux _ = Nil;
in
	aux dt
end);
in
	(fn (tm:TERM) => case (asbc tm) of
		Value red => red
		| Nil => term_fail "all_Â_conv" 27049 [tm])
end);
end;
=TEX
=SML
fun Ûall_Â_ruleÝ (thm : THM) =(
	conv_rule all_Â_conv thm
	handle complaint =>
	divert complaint "all_Â_conv"
		"all_Â_rule" 27049 [fn () => string_of_thm thm]
);
=TEX
=SML
val Û%eta%_convÝ : CONV = (fn (tm : TERM) =>
	simple_eq_match_conv eta_axiom tm
handle (Fail _) =>
let	val (vs,tvs') = dest_Ì tm;
	val (t,vs') = dest_app tvs';
in
	if is_pair vs andalso (vs = vs')
	then (simple_eq_match_conv uc_thm THEN_C
		Ì_C(RATOR_C Â_conv THEN_C Â_conv THEN_C
		RAND_C (MAP_C(simple_eq_match_conv sfst_snd_thm))) THEN_C
		simple_eq_match_conv eta_axiom)
		tm
	else term_fail "%eta%_conv" 27023 [tm]
end
handle complaint =>
list_divert complaint "%eta%_conv" [
	("dest_Ì", 27018, [fn () => string_of_term tm]),
	("dest_app", 27018, [fn () => string_of_term tm]),
	("MAP_C", 27023, [fn () => string_of_term tm]),
	("simple_eq_match_conv", 27023, [fn () => string_of_term tm])]
);
=TEX
=SML
=TEX
\subsection{Concerning µ}
As $list\_simple\_µ\_intro$ has the same pattern,
we don't attempt to use that function and fail, but go
straight into the complex form.
=SML
fun Ûlist_µ_introÝ (tml : TERM list) (thm : THM) : THM = (
	fold (uncurry µ_intro) tml thm
	handle complaint =>
	pass_on complaint "µ_intro" "list_µ_intro"
); 
=TEX
=SML
local
	fun aux 1 = simple_³_µ_conv
	| aux n = simple_³_µ_conv THEN_C (BINDER_C (aux(n-1)));
in
val Û³_µ_convÝ : CONV = (fn (tm : TERM) =>
	simple_³_µ_conv tm
handle (Fail _) =>
let	val (vs,bdy) = dest_µ(dest_³ tm);
	val lvs = length(flat_vs "³_µ_conv" vs);
in
	(RAND_C µ_uncurry_conv THEN_C
	aux lvs THEN_C
	(fn x => eq_sym_rule(¶_uncurry_conv (mk_¶(vs,mk_³ bdy))))) tm
end
handle complaint =>
list_divert complaint "³_µ_conv" [
	("dest_³",27019,[fn () => string_of_term tm]),
	("dest_µ",27019,[fn () => string_of_term tm])]
);
end;
=TEX
=SML
fun Ûµ_¤_ruleÝ (vs : TERM) (thm : THM)  : THM = (
	ap_fun_rule (quantifier "µ" (type_of vs) BOOL)
	(Ì_eq_rule vs thm
	handle complaint =>
	pass_on complaint "Ì_eq_rule" "µ_¤_rule")
handle complaint =>
divert complaint "ap_fun_rule" "µ_¤_rule" 7062 [fn () => string_of_thm thm]
);
=TEX
=IGN
fun mimic_vs vs froml = (
let	fun aux vs' froml' = (
		if is_pair vs'
		then (let val (vs1,vs2) = dest_pair vs';
			val (vs1',frml) = aux vs1 froml';
			val (vs2',frml') = aux vs2 frml;
		in
			(mk_pair(vs1',vs2'),frml')
		end)
		else (hd froml', tl froml)
	)
in
	hd(aux vs froml)
end);
fun arb_vs vs avoid = (
let	val fvs = flat_vs vs;
in
	mimic_vs vs (gen_vars (map type_of fvs) (fvs @ avoid))
end);
=TEX
The following is meant to be fast:
=SML
fun Ûµ_arb_elimÝ (thm : THM) :THM = (
let	val (asms,conc) = dest_thm thm;
	val (vs,bdy) = dest_µ conc;
	val (thm',fvs) = if is_var vs
		then (thm, [vs])
		else (conv_rule µ_uncurry_conv thm, 
			flat_vs "µ_arb_elim" vs);
	val fvs' = gen_vars (map type_of fvs) (conc :: (fvs @ asms));
in
	list_simple_µ_elim fvs' thm'
end
handle complaint =>
divert complaint "dest_µ" "µ_arb_elim" 27011 [fn () => string_of_thm thm]
);
=TEX
The following is meant to be fast:
=SML
fun Ûall_µ_arb_elimÝ (thm : THM) :THM = (
let	val thm' = all_µ_uncurry_rule thm;
	val (asms,conc) = dest_thm thm';
	val vl = fst(strip_simple_µ conc);
	val vl' = gen_vars (map type_of vl) (conc :: (vl @ asms));
in
	list_simple_µ_elim vl' thm'
end);
=TEX
=SML
fun Ûµ_asm_ruleÝ (vs : TERM) (asm : TERM) (thm :THM) : THM = (
let	val s1 = asm_rule (mk_µ(vs,asm));
	val s2 = µ_elim vs s1;
	val s3 = prove_asm_rule s2 thm;
in
	s3
end
handle complaint =>
pass_on complaint "mk_µ" "µ_asm_rule"
);
=TEX
=SML
fun  Ûµ_reorder_convÝ (tm1 : TERM) : CONV = (fn (tm2 : TERM) =>
let	val (vsl1,bdy1) = strip_µ tm1;
	val (vsl2,bdy2) = strip_µ tm2;
	val (tys,insts) = term_match bdy1 bdy2;
	val vsl1' = map (term_map(fn x=>lassoc3 insts)) vsl1;
	val vsl2' = map (term_map(fn x=>rassoc3 insts)) vsl2;
	val s1 = asm_rule tm1;
	val s2 = list_µ_elim vsl1' s1;
	val s3 = list_µ_intro vsl2 s2;
	val s4 = disch_rule tm1 s3;
	val s5 = asm_rule tm2;
	val s6 = list_µ_elim vsl2' s5;
	val s7 = list_µ_intro vsl1 s6;
	val s8 = disch_rule tm2 s7;
	val s9 = ¤_intro s8 s4;
	val s10 = eq_trans_rule (refl_conv tm2) s9;
	val s11 = eq_trans_rule s10 (refl_conv tm1);
in
	s11
end
handle complaint =>
term_fail "µ_reorder_conv" 27050 [tm1,tm2]
);

=TEX
\subsection{Concerning ¶}
=SML
local
	fun aux 1 = simple_³_¶_conv
	| aux n = simple_³_¶_conv THEN_C (BINDER_C (aux(n-1)));
in
val Û³_¶_convÝ : CONV = (fn (tm : TERM) =>
	simple_³_¶_conv tm
handle (Fail _) =>
let	val (vs,bdy) = dest_¶(dest_³ tm);
	val lvs = length(flat_vs "³_¶_conv" vs);
in
	(RAND_C ¶_uncurry_conv THEN_C
	aux lvs THEN_C
	(fn x => eq_sym_rule(µ_uncurry_conv (mk_µ(vs,mk_³ bdy))))) tm
end
handle complaint =>
list_divert complaint "³_¶_conv" [
	("dest_³",27020,[fn () => string_of_term tm]),
	("dest_¶",27020,[fn () => string_of_term tm])]
);
end;
=TEX
=SML
local
	fun list_v_¶_intro tml thm = fold (uncurry v_¶_intro) tml thm;
	fun list_¶_elim [] tm wthm = wthm
	| list_¶_elim (v :: rest) tm wthm = (
		let	val tm' = mk_¶(v, tm);
		in
		list_¶_elim rest tm'
			(¶_elim v (asm_rule tm') wthm)
		end);
		
in
fun  Û¶_reorder_convÝ (tm1 : TERM) : CONV = (fn (tm2 : TERM) =>
let	val (vsl1,bdy1) = strip_¶ tm1;
	val (vsl2,bdy2) = strip_¶ tm2;
	val (tys,insts) = term_match bdy1 bdy2;
	val vsl1' = map (term_map(fn x=>lassoc3 insts)) vsl1;
	val vsl2' = map (term_map(fn x=>rassoc3 insts)) vsl2;
	val s1 = asm_rule tm1;
	val s2 = asm_rule bdy1;
	val s3 = list_v_¶_intro vsl2' s2;
	val s4 = list_¶_elim (rev vsl1) bdy1 s3;
	val s5 = disch_rule tm1 s4;
	val s6 = asm_rule tm2;
	val s7 = asm_rule bdy2;
	val s8 = list_v_¶_intro vsl1' s7;
	val s9 = list_¶_elim (rev vsl2) bdy2 s8;
	val s10 = disch_rule tm2 s9;
	val s11 = ¤_intro s10 s5;
	val s12 = eq_trans_rule (refl_conv tm2) s11;
	val s13 = eq_trans_rule s12 (refl_conv tm1);
in
	s13
end
handle (Fail _) =>
term_fail "¶_reorder_conv" 27050 [tm1,tm2]
);
end;
=TEX
=SML
fun Û¶_asm_ruleÝ (vs : TERM) (asm : TERM) (thm : THM) : THM = (
let	val tm' = mk_¶(vs, asm)
		handle complaint =>
		pass_on complaint "mk_¶" "¶_asm_rule";
in
	¶_elim vs (asm_rule tm') thm
	handle complaint =>
	pass_on complaint "¶_elim" "¶_asm_rule"

end);
=TEX
\subsection{Concerning ¶$_1$}
These follow the same pattern as the simple rules.
=SML
local
	val prc = TRY_C(pure_rewrite_conv [sfst_snd_thm]);
in
fun Û¶‰1_introÝ (thm1 : THM) (thm2 : THM) : THM = (
let	val (x,rest) = dest_µ (concl thm2);
	val (Px,(x',t)) = (Combinators.I ** dest_eq)(dest_´ rest);
	val side_effect = if x = x'
		then ()
		else thm_fail "¶‰1_intro" 27054 [thm2];
	val insts = case (term_match (concl thm1) Px) of
		([],is) => is
		| _ => thm_fail "¶‰1_intro" 27021 [thm1,thm2];
	val witness = term_map (fn x => rassoc3 insts) x;
	val abs = mk_Ì(x,Px);
	val P_t = mk_app(abs, witness);
	val P_x = mk_app(abs, x);
	val s1 = Â_conv P_t;
	val s2 = eq_sym_rule s1;
	val s3 = ¤_mp_rule s2 thm1;
	val s4 = Â_conv P_x;
	val s5 = eq_sym_rule s4;
	val mgvs = gen_vars [BOOL, type_of x, type_of x] (frees rest);
	val mgv = hd mgvs;
	val mgv1 = hd(tl mgvs);
	val mgv2 = hd(tl(tl mgvs));
	val s6 = all_µ_elim thm2;
	val template = mk_´(mgv,mk_eq(x,t));
	val s7 = subst_rule [(s5,mgv)] template s6;
	val s8 = µ_intro x s7;
	val s9 = µ_elim mgv2 s8;
	val s10 = conv_rule (RAND_C(RATOR_C(RAND_C prc)) THEN_C
		RATOR_C(RAND_C(RAND_C prc))) s9;
	val s11 = simple_µ_intro mgv2 s10;
	val s12 = ±_intro s3 s11;
	val template2 = mk_¶(mgv1,
		mk_±(mk_app(abs,mgv1),
		mk_µ(mgv2,
		mk_´(
		mk_app(abs,mgv2), mk_eq(mgv2,mgv1)))));
	val s13 = ¶_intro template2 s12;
	val s14 = inst_type_rule[(type_of x,mk_vartype "'a")] 
		¶‰1_thm;
	val s15 = µ_elim abs s14;
	val s16 = eq_sym_rule s15;
	val s17 = ¤_mp_rule s16 s13;
	val s18 = conv_rule(RAND_C (Á_conv abs)) s17;
in
	(prof "¶‰1_intro";
	s18)
end
handle complaint =>
list_divert complaint "¶‰1_intro" [
	("term_match",27021,[fn () => string_of_thm thm1, 
		fn () => string_of_thm thm2]),
	("dest_µ",27054,[fn () => string_of_thm thm2]),
	("dest_´",27054,[fn () => string_of_thm thm2])
]
);
end;
=TEX
=SML
fun Û¶‰1_elimÝ (thm : THM) : THM = (
let	val conc = concl thm;
	val sideffect = if not (is_¶‰1 conc)
		then thm_fail "¶‰1_elim" 27022 [thm]
		else ();
	val (_,bdy) = dest_app conc;
	val (x,bdy') = dest_Ì bdy;
	val y = varstruct_variant (frees x @ frees bdy') x;
	val tmt = snd(term_match y x);
	val tm1 = mk_eq(y,x);
	val tm2 = var_subst tmt bdy';
	val tm3_Ì = mk_Ì(y,mk_´(tm2,tm1));
	val tm3 = mk_µ(y,mk_´(tm2,tm1));
	val target_tm = mk_¶(x,mk_±(bdy',tm3));
	val (xt,bt) = dest_­_type(type_of bdy);
	val s1 = inst_type_rule [(xt,mk_vartype "'a")] 
		¶‰1_thm;
	val s2 = simple_µ_elim bdy s1;
	val s3 = ¤_mp_rule s2 thm;
	val s4 = conv_rule (CBINDER_C
		((RAND_C(CBINDER_C(RATOR_C(RAND_C Â_conv))))
		THEN_C
		(RATOR_C(RAND_C Â_conv)))) s3;
	val (quant,abs) = dest_app (concl s4);
	val (t,¶_bdy) = dest_simple_Ì abs;
	val µ_bit = snd(dest_± ¶_bdy);
	val µ_bit' = subst[(x,t)] µ_bit;
	val bdy'' = mk_Ì(x,mk_±(bdy',µ_bit'));
	val s5 = conv_rule (RAND_C (Ì_varstruct_conv bdy'')) s4;
	val s6 = conv_rule (CBINDER_C(RAND_C(RAND_C (Ì_varstruct_conv tm3_Ì)))) s5;
in
	(prof "¶‰1_elim";
	s6)
end
handle complaint =>
list_divert complaint "¶‰1_elim" [
	("dest_app",27022,[fn () => string_of_thm thm]),
	("dest_Ì",27022,[fn () => string_of_thm thm]),
	("dest_fun",27022,[fn () => string_of_thm thm]),
	("¤_mp_rule",27022,[fn () => string_of_thm thm])]
);
=TEX
The following is very similar to the implementation of $¶_1\_elim$, and could have been used to code that function.
=SML
val Û¶‰1_convÝ : CONV = (fn tm =>
let	val sideffect = if not (is_¶‰1 tm)
		then term_fail "¶‰1_conv" 27053 [tm]
		else ();
	val (_,bdy) = dest_app tm;
	val (x,bdy') = dest_Ì bdy;
	val y = varstruct_variant (frees x @ frees bdy') x;
	val tmt = snd(term_match y x);
	val tm1 = mk_eq(y,x);
	val tm2 = var_subst tmt bdy';
	val tm3_Ì = mk_Ì(y,mk_´(tm2,tm1));
	val tm3 = mk_µ(y,mk_´(tm2,tm1));
	val target_tm = mk_¶(x,mk_±(bdy',tm3));
	val (xt,bt) = dest_­_type(type_of bdy);
	val s1 = inst_type_rule [(xt,mk_vartype "'a")] ¶‰1_thm;
	val s2 = simple_µ_elim bdy s1;
	val s3 = eq_trans_rule (refl_conv tm) s2;
	val s4 = conv_rule (RAND_C(CBINDER_C
		((RAND_C(CBINDER_C(RATOR_C(RAND_C Â_conv))))
		THEN_C
		(RATOR_C(RAND_C Â_conv))))) s3;
	val (quant,abs) = dest_app (snd(dest_eq(concl s4)));
	val (t,¶_bdy) = dest_simple_Ì abs;
	val µ_bit = snd(dest_± ¶_bdy);
	val µ_bit' = subst[(x,t)] µ_bit;
	val bdy'' = mk_Ì(x,mk_±(bdy',µ_bit'));
	val s5 = conv_rule (RAND_C(RAND_C (Ì_varstruct_conv bdy''))) s4;
	val s6 = conv_rule (RAND_C(CBINDER_C(RAND_C
		(RAND_C (Ì_varstruct_conv tm3_Ì))))) s5;
in
	(prof "¶‰1_conv";
	s6)
end
handle complaint =>
list_divert complaint "¶‰1_conv" [
	("dest_app",27022,[fn () => string_of_term tm]),
	("dest_Ì",27022,[fn () => string_of_term tm]),
	("dest_fun",27022,[fn () => string_of_term tm]),
	("¤_mp_rule",27022,[fn () => string_of_term tm])]
);
=TEX

\subsection{Concerning Í}
=SML
val Û¶_Í_convÝ : CONV = (fn (tm:TERM) =>
let	val (x, tx) = (dest_¶ tm)
		handle complaint =>
		pass_on complaint "dest_¶" "¶_Í_conv";
	val t1 = mk_Ì (x, tx);
	val s1 = inst_type_rule [(type_of x, mk_vartype "'a")] ¶_def;
	val s2 = ap_arg_rule t1 s1;
	val s3 = concl s2;
	val conv1 = (RAND_C Â_conv THEN_C
			RAND_C Â_conv)
	val s4 = conv1 s3;
	val s5 = ¤_mp_rule s4 s2;
in
	(prof "¶_Í_conv";
	s5)
end);
=TEX

=SML
fun Û¶_Í_ruleÝ (thm : THM) : THM = (
let	val s1 = conv_rule ¶_Í_conv thm
in
	(prof "¶_Í_rule";
	s1)
end
	handle complaint =>
	divert complaint "¶_Í_conv" "¶_Í_rule" 27024 
		[fn () => string_of_thm thm]
);
=TEX
\subsection{Concerning Local Definitions}
=SML
local
	val tLet = type_of ¬Let®;
	fun aux tm = (RATOR_C (RATOR_C(fn x => 
		inst_type_rule (type_match (type_of x) tLet) let_def))
		THEN_C
		RATOR_C simple_Â_conv THEN_C
		simple_Â_conv THEN_C
		(RATOR_C aux EITHER_C
		Â_conv)) tm;
in
val Ûlet_convÝ : CONV = (fn tm =>
	aux tm
	handle (Fail _) => 
	term_fail "let_conv" 4009 [tm]);
end;
=TEX
\subsection{Term Manipulation}
A number of functions in this document are
concerned with detailed term manipulation, rather
than just providing ``paired'' coverage of simple functions.

These are implemented together:
\subsubsection{Working Through µ Binders}
To work through an arbitrary number of simple universals:
=SML
fun ÛALL_SIMPLE_µ_CÝ (conv:CONV): CONV = (fn tm =>
	if is_simple_µ tm
	then (BINDER_C (ALL_SIMPLE_µ_C conv)) tm
	else conv tm
);
=TEX
\subsubsection{Working Through ¶ Binders}
To work through an arbitrary number of simple existentials:
=SML
fun ÛALL_SIMPLE_¶_CÝ (conv:CONV): CONV = (fn tm =>
	if is_simple_¶ tm
	then (BINDER_C (ALL_SIMPLE_¶_C conv)) tm
	else conv tm
);
=TEX
\subsubsection{Working Through ±}
A variant on $APP\_C$, but which will happily fail on one ``side'' of the application, and complete 
successfully if the other ``side'' works:
=SML
fun ÛAPP_C1Ý (cnv1 : CONV, cnv2 : CONV) : CONV = (fn (tm:TERM) =>
let	val (f,x) = dest_app tm
		handle complaint =>
		pass_on complaint "dest_app" "APP_C1";
in
	(let val thm1 = cnv1 f
	in
	(let val thm2 = (cnv2 x
		handle (Fail _) => refl_conv x)
	 in
		mk_app_rule thm1 thm2
	 end)
	end)
	handle (Fail _) =>
	(let val thm2 = cnv2 x
	in
		(ap_fun_rule f thm2
		handle complaint =>
		divert complaint "ap_fun_rule" "APP_1C" 7104
		[fn () => string_of_thm thm2])
	end)
end);
=TEX
To work through an arbitrary number of conjunctions:
=SML
local
	val rw_conv= eqn_cxt_conv(map thm_eqn_cxt (initial_rw_canon ±_rewrite_thm));
in
fun ÛALL_±_CÝ (conv:CONV): CONV = (fn tm =>
	if is_± tm
	then ((APP_C1(RAND_C (ALL_±_C conv),
		(ALL_±_C conv))) FURTHER_C rw_conv) tm
	else conv tm
);
end;
=TEX
\subsubsection{Working Through ²}
To work through an arbitrary number of conjunctions:
=SML
local
	val rw_conv= eqn_cxt_conv( map thm_eqn_cxt (initial_rw_canon ²_rewrite_thm));
in
fun ÛALL_²_CÝ (conv:CONV): CONV = (fn tm =>
	if is_² tm
	then ((APP_C1(RAND_C (ALL_²_C conv),
		(ALL_²_C conv))) FURTHER_C rw_conv) tm
	else conv tm
);
end;
=TEX
=TEX
\subsection{Swapping µ and ¶}
The following two theorems speed the swapping of $µ$ and $¶$.
=SML
val Ûµ_¶_thmÝ = (
push_goal([], ¬µP·(µx·¶y·P x y) ¤ (¶f:'a ­ 'b·µx·P x (f x))®);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(simple_¶_tac¬Ìa·Íb·P a b® THEN REPEAT strip_tac THEN rewrite_tac[]);
a(POP_ASM_T (accept_tac o ¶_Í_rule o all_µ_elim));
(* *** Goal "2" *** *)
a(simple_¶_tac¬f x® THEN asm_rewrite_tac[]);

pop_thm());
=TEX
=SML
val Û¶_µ_thmÝ = (
push_goal([], ¬µP·(¶x·µy·P x y) ¤ (µf:'a ­ 'b·¶x·P x (f x))®);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(simple_¶_tac¬x® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(C_CONTR_T (asm_tac o conv_rule (TOP_MAP_C(³_µ_conv ORELSE_C ³_¶_conv))));
a(undisch_tac¬µ f· ¶ x· P x (f x)® THEN rewrite_tac[]);
a(strip_tac);
a(simple_¶_tac¬Ìx·Íy·³P x y® THEN rewrite_tac[] THEN REPEAT strip_tac);
a(POP_ASM_T (accept_tac o ¶_Í_rule o µ_elim¬x'®));
pop_thm());
=TEX
In the following we are careful to maintain naming,
using $eq\_trans\_rule$ and $simple\_\alpha\_conv$.
=SML
val Ûsimple_µ_¶_convÝ :CONV = (fn tm =>
let	val (x, t) = dest_simple_µ tm;
	val (y, body) = dest_simple_¶ t;
	val abs = mk_simple_Ì(x, mk_simple_Ì(y, body));
	val thm1 = simple_µ_elim abs(inst_type_rule
			[(type_of x, tva), (type_of y, tvb)] µ_¶_thm);
	val newy = string_variant (map fst(term_vars tm)) (fst(dest_var y));
	val conv0 = RAND_C(RAND_C (simple_Á_conv newy
		THEN_C Ì_C(RAND_C(simple_Á_conv (fst(dest_var x))))));
	val conv1 = RATOR_C (simple_Â_conv) THEN_C simple_Â_conv;
	val conv2 = BINDER_C(BINDER_C conv1);
	val conv3 = conv0 THEN_C APP_C(RAND_C conv2, conv2);
	val thm2 = conv_rule conv3 thm1;
in
	eq_trans_rule (refl_conv tm) thm2
end
handle complaint =>
list_divert complaint "simple_µ_¶_conv"
	[("dest_simple_µ", 27031,[fn () => string_of_term tm]),
	("dest_simple_¶", 27031,[fn () => string_of_term tm]),
	("eq_trans_rule", 27034,[fn () => string_of_term tm])
]);
=IGN
simple_µ_¶_conv ¬µ p:'c · ¶ q : BOOL · q ² f p®;
simple_µ_¶_conv ¬µ x:'a · ¶ y:'b · g y x®;
=TEX
=SML
val Ûsimple_¶_µ_convÝ :CONV = (fn tm =>
let	val (x, t) = dest_simple_¶ tm;
	val (y, body) = dest_simple_µ t;
	val abs = mk_simple_Ì(x, mk_simple_Ì(y, body));
	val thm1 = simple_µ_elim abs(inst_type_rule
			[(type_of x, tva), (type_of y, tvb)] ¶_µ_thm);
	val newy = string_variant (map fst(term_vars tm)) 
		(fst(dest_var y));
	val conv0 = RAND_C(RAND_C (simple_Á_conv newy
		THEN_C Ì_C(RAND_C(simple_Á_conv 
			(fst(dest_var x))))));
	val conv1 = RATOR_C (simple_Â_conv) THEN_C simple_Â_conv;
	val conv2 = BINDER_C(BINDER_C conv1);
	val conv3 = conv0 THEN_C APP_C(RAND_C conv2, conv2);
	val thm2 = conv_rule conv3 thm1
in
	eq_trans_rule (refl_conv tm) thm2
end
handle complaint =>
list_divert complaint "simple_¶_µ_conv"
	[("dest_simple_µ", 27032,[fn () => string_of_term tm]),
	("dest_simple_¶", 27032,[fn () => string_of_term tm]),
	("eq_trans_rule", 27033,[fn () => string_of_term tm])
]);
=IGN
simple_¶_µ_conv ¬¶ p:'c · µ q : BOOL · q ² f p®;
simple_¶_µ_conv ¬¶ p:'c · µ q : BOOL · f (g q) p®;
simple_¶_µ_conv ¬¶ x:'a · µ y:'b · g y x®;
=TEX
=SML
val Û¶_µ_thm1Ý = (
push_goal([],¬µ P · (¶ f · µ x · P(f x) x) ¤ (µ x · ¶ f'·P f' x)®);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(simple_¶_tac¬f x® THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(POP_ASM_T(strip_asm_tac o conv_rule simple_µ_¶_conv));
a(simple_¶_tac ¬f''® THEN asm_rewrite_tac[]);
pop_thm());
=TEX

=FRULE 1 Conversion
simple_¶_µ_conv1
¬¶ f · µ x · P[f x, x]®
÷
÷
(¶ f · µ x · P[f x, x]) ¤ 
	(µ x · ¶ f' · P[f', x])
=TEX
=SML
val Ûsimple_¶_µ_conv1Ý :CONV = (fn tm =>
let	val (f, t) = dest_simple_¶ tm;
	val (x, body) = dest_simple_µ t;
	val fx = mk_app (f, x);
	val newfnm = string_variant (map fst(term_vars tm)) (fst(dest_var f));
	val newf = mk_var(newfnm, type_of fx);
	val body' = subst[(newf, fx)] body;
	val sideeffect = if is_free_in f body'
		then term_fail "simple_¶_µ_conv1" 27033 [tm]
		else ();
	val abs = mk_simple_Ì(newf, mk_simple_Ì(x, body'));
	val thm1 = simple_µ_elim abs(inst_type_rule
			[(snd(dest_­_type(type_of f)), tva), (type_of x, tvb)] ¶_µ_thm1);
	val conv0 = RAND_C(RAND_C (simple_Á_conv (fst(dest_var x))
		THEN_C Ì_C(RAND_C(simple_Á_conv newfnm))));
	val conv1 = RATOR_C (simple_Â_conv) THEN_C simple_Â_conv;
	val conv2 = BINDER_C(BINDER_C conv1);
	val conv3 = conv0 THEN_C APP_C(RAND_C conv2, conv2);
	val thm2 = conv_rule conv3 thm1
in
	eq_trans_rule (refl_conv tm) thm2
end
handle complaint =>
list_divert complaint "simple_¶_µ_conv1"
	[("mk_app", 27033,[fn () => string_of_term tm]),
	("dest_simple_µ", 27033,[fn () => string_of_term tm]),
	("dest_simple_¶", 27033,[fn () => string_of_term tm]),
	("eq_trans_rule", 27034,[fn () => string_of_term tm])
]);
=IGN
simple_¶_µ_conv1 ¬¶ p · µ q : BOOL · f q (p q) q (p q) ®;
simple_¶_µ_conv1 ¬¶ f · µ x · x ± f x®;
=TEX


=SML
=TEX
\section{END OF THE STRUCTURE}
Restore the previous theory:
=SML
val _ = open_theory was_theory;
=TEX
=SML
end; (* of structure DerivedRules2 *)
open DerivedRules2;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


