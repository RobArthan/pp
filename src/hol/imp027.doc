%  imp027.doc  @(#) 91/09/04 1.26 imp027.doc
=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Implementation for the Derived Rules of Inference II}  %% Mandatory field
\def\TPPheadtitle{Implementation for the \cr Derived Rules of Inference II}
\TPPref{DS/FMU/IED/IMP027}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
\end{description}
% \subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains an implementation of the derived rules of inference part II.
This primarily concerns adding paired abstraction handling
to the functions of {DS/FMU/IED/DTD007}.
This is called for in \cite{DS/FMU/IED/HLD012}.
The design is in \cite{DS/FMU/IED/DTD027},
and the functions tested in {DS/FMU/IED/MDT027}
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains an implementation of the derived rules of inference part II.
This primarily concerns adding paired abstraction handling
to the functions of {DS/FMU/IED/DTD007}.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD027}.
\subsubsection{Deficiencies}
Some of the coding could be tightened - e.g. elimanting uses of
$simple\-\_eq\-\_match\-\_conv$.
\subsubsection{Possible Enhancements}
None known.

\section{THE CODE}
=SML
(* structure âDerivedRulesIIá : DerivedRulesII = struct *)
=TEX
\subsection{Local Theorems}
We will need these in various places:
=SML

val ƒ_uncurry_thm = (push_goal([],»ƒ f :'a ‹ 'b ‹ BOOL Ž $ƒ (Uncurry f) ‚ ƒ x Ž f (Fst x) (Snd x)¼);
	a simple_ƒ_tac;
	a(rewrite_tac[ƒ_def]);
	a(rewrite_tac[ext_thm, pair_clauses]);
	pop_thm());
val fst_thm = tac_proof(([],»ƒ a b Ž Fst (a,b) = a¼),
	rewrite_tac[pair_clauses]);
val snd_thm = tac_proof(([],»ƒ a b Ž Snd (a,b) = b¼),
	rewrite_tac[pair_clauses]);
val sƒ_uncurry_thm = (push_goal([],»ƒ f :'a ‹ 'b ‹ BOOL Ž (ƒ x Ž f (Fst x) (Snd x)) ‚ $ƒ (Uncurry f)¼);
	a simple_ƒ_tac;
	a(rewrite_tac[ƒ_def]);
	a(rewrite_tac[ext_thm, pair_clauses]);
	pop_thm());
val sfst_thm = tac_proof(([],»ƒ a b Ž a = Fst (a,b)¼),
	rewrite_tac[pair_clauses]);
val ssnd_thm = tac_proof(([],»ƒ a b Ž b = Snd (a,b)¼),
	rewrite_tac[pair_clauses]);
val sfst_snd_thm = tac_proof(([],»ƒ x Ž (Fst x,Snd x) = x¼),
	rewrite_tac[pair_clauses]);
val „_uncurry_thm = (push_goal([],»ƒ f Ž $„ (Uncurry f) = „ x Ž f (Fst x) (Snd x)¼);
	a simple_ƒ_tac;
	a(rewrite_tac[pair_clauses, „_def]);
	a(LEMMA_T »Uncurry f =  x Ž f (Fst x) (Snd x)¼
		(fn x => rewrite_tac[x]));
	a(rewrite_tac[ext_thm, pair_clauses]);
	pop_thm());
val s„_uncurry_thm = (push_goal([],»ƒ f Ž („ x Ž f (Fst x) (Snd x)) = $„ (Uncurry f)¼);
	a simple_ƒ_tac;
	a(rewrite_tac[pair_clauses, „_def]);
	a(LEMMA_T »Uncurry f =  x Ž f (Fst x) (Snd x)¼
		(fn x => rewrite_tac[x]));
	a(rewrite_tac[ext_thm, pair_clauses]);
	pop_thm());
val uc_thm = tac_proof(([],»ƒ f Ž Uncurry f =
	 x Ž f (Fst x) (Snd x)¼),
	rewrite_tac[ext_thm, pair_clauses]);
val Œ_ƒ_uncurry_thm = (push_goal([],
		»ƒ f Ž (Œ($ƒ(Uncurry f))) = „ p q Ž Œ f p q¼);
	a (strip_tac THEN rewrite_tac[uc_thm]);
	a (REPEAT strip_tac);
	(* *** Goal "1" *** *)
	a(MAP_EVERY_T simple_„_tac [»Fst x¼,»Snd x¼] THEN
		asm_rewrite_tac[]);
	(* *** Goal "2" *** *)
	a(simple_„_tac »(p,q)¼ THEN
		asm_rewrite_tac[pair_clauses]);
	pop_thm());
=TEX
\subsection{Local Functions}
=SML
fun âmatch_simple_ƒ_elimá (tm:TERM) (thm:THM) = (
let	val (v,_) = dest_simple_ƒ (concl thm);
	val thm1 = inst_type_rule (fst(term_match tm v)) thm;
	val thm2 = simple_ƒ_elim tm thm1
in
	thm2
end);
=TEX
Note that $flat\_vs$ should not be capable of failing
on the first part of the result of a $dest\_ƒ$
=SML
fun âflat_vsá (caller : string) (tm1:TERM) : TERM list = (
let	fun aux tm = (
	if is_var tm 
	then [tm]
	else ( let val (tm1,tm2) = dest_pair tm
		handle complaint =>
		divert complaint "dest_pair" caller 27010 [
			fn () => string_of_term tm];
	in
		(aux tm1 @ aux tm2)
	end));
in
	aux tm1
end);
=TEX
=SML
fun âmk_fstá tm = (
let	val ttm = type_of tm;
	val (ta,tb) = dest_‰_type ttm;
in
	mk_app(mk_const("Fst", mk_‹_type(ttm,ta)), tm)
end);
fun âmk_sndá tm = (
let	val ttm = type_of tm;
	val (ta,tb) = dest_‰_type ttm;
in
	mk_app(mk_const("Snd", mk_‹_type(ttm,tb)), tm)
end);
=TEX
The following are used in getting type instantiations.
=SML
val âtvaá = »:'a¼;
val âtvbá = »:'b¼;
val âtvcá = »:'c¼;
=TEX
=SML
fun âtwo_the_sameá ((a:''a) :: x) : ''a OPT = (
	if a mem x
 	then Value a
 	else two_the_same x
) | two_the_same [] = Nil;
=TEX
Rename duplicate variables in a variable structure.
=SML
fun âreplace_dupsá (av: TERM list) (tm : TERM) = (
let	fun rd_aux av tm1 = (
		if is_var tm1
		then (let val new = variant av tm1 in
			((new :: av),new)
		end
		) else (let val (ftm,stm) = dest_pair tm1;
			val (av',stm') = rd_aux av stm;
			val (av'',ftm') = rd_aux av' ftm;
		in
			(av'', mk_pair(ftm',stm'))
		end)
	);
in
	snd(rd_aux av tm)
end);
=TEX
\subsection{Core Paired abstraction Functions}
The following functions provide a core, around which,
in combination with the rules for \cite{DS/FMU/IED/DTD007},
we can implement the other rules of \cite{DS/FMU/IED/DTD027}.

In the following we try to fail as fast as possible:
we could instead immediately try $simple\_\beta\_conv$,
and only be clever if we fail.
\subsubsection{Concerning $$}
=SML
local
val uncurry_def = get_defn "pair" "Uncurry";
val fst_snd_thm = tac_proof(([],»ƒ p Ž p = (Fst p, Snd p)¼),
	rewrite_tac[pair_clauses]);

fun aux (vs: TERM) (vl : TERM) : CONV = (
	if is_var vs
	then simple_%beta%_conv
	else if is_pair vl
	then (let  	val (vs1,vs2) = dest_pair vs;
			val (vl1,vl2) = dest_pair vl;
		in
			simple_eq_match_1_conv uncurry_def THEN_C
			RATOR_C (aux vs1 vl1) THEN_C
			aux vs2 vl2
		end
	) else (let	val vl_thm = match_simple_ƒ_elim vl fst_snd_thm;
			val vl' = snd(dest_eq(concl vl_thm));
		in
		RAND_C (fn x => vl_thm) THEN_C aux vs vl'
		end
	)
);
in
val â%beta%_convá : CONV = (fn (tm : TERM) =>
let	val (br,vl) = dest_app tm
		handle complaint =>
		divert complaint "dest_app" "%beta%_conv" 27008
			[fn () => string_of_term tm];
	val res = (simple_%beta%_conv tm
		handle (Fail _) =>
		(let	val (vs,_) = (dest_ br
			handle complaint =>
			divert complaint "dest_app" "%beta%_conv" 27008
			[fn () => string_of_term tm]);
		in
			aux vs vl tm
		end));
in
	res
end);
end;
=TEX
=SML
local 
	val uc_type = »:('a ‹ 'b ‹ 'c) ‹ 'a ‰ 'b ‹ 'c¼;
in
fun â_eq_ruleá (x : TERM) (thm : THM) : THM = (
let	val sideeffect = if is_eq(concl thm)
		then ()
		else thm_fail "_eq_rule" 6020 [thm];
	fun aux x1 thm1 = (
	if is_var x1
	then (simple__eq_rule x1 thm1 
		handle complaint =>
		pass_on complaint "simple__eq_rule" "_eq_rule")
	else (let	val (p,q) = dest_pair x1
			handle complaint =>
			term_fail "_eq_rule" 27010 [x];
		val s1 = aux q thm1;
		val s2 = aux p s1;
		val uct = inst_type[(type_of p,tva), 
			(type_of q,tvb), 
			(type_of (fst(dest_eq(concl thm1))),tvc)] 
			uc_type;
		val uc = mk_const("Uncurry", uct);
		val s3 = ap_fun_rule uc s2;
	in
		s3
	end));
in
	aux x thm
end);
end;		
=TEX
=SML
fun â_Cá (cnv : CONV) : CONV = (fn (tm : TERM) =>
let	val (x,b) = dest_ tm
		handle complaint =>
		pass_on complaint "dest_" "_C";
	val s1 = cnv b;
	val s2 = _eq_rule x s1
		handle complaint =>
		divert complaint "_eq_rule" "_C" 7104 
			[fn () => string_of_thm s1];
in
	s2
end);
=TEX
This could be implemented by $RAND\_C\ o\ \_C$ but the
following gives better diagnostics:
=SML
fun âCBINDER_Cá (cnv :  CONV): CONV = (fn (tm : TERM) =>
let	val (binder,abs) = dest_app tm;
	val (x,b) = dest_ abs;
	val s1 = cnv b;
	val s2 = ap_fun_rule binder (_eq_rule x s1)
		handle complaint =>
		list_divert complaint "CBINDER_C" [
			("_eq_rule",7104,[fn () => string_of_thm s1]),
			("ap_fun_rule",7104,[fn () => string_of_thm s1])];	
in
	s2
end
handle complaint =>
list_divert complaint "CBINDER_C" [
	("dest_",27035,[fn () => string_of_term tm]),
	("dest_app",27035,[fn () => string_of_term tm])]
);
=TEX
\subsubsection{Concerning $ƒ$}
=SML
fun âƒ_elimá (tm : TERM) (thm : THM) : THM = (
	simple_ƒ_elim tm thm
handle (Fail _) =>
let	val (vs,bdy) = dest_ƒ(concl thm)
		handle complaint =>
		divert complaint "dest_ƒ" "ƒ_elim" 27011 [fn () => string_of_thm thm];
	val side_effect = if type_of tm <> type_of vs
		then fail "ƒ_elim"  27012 [
			fn () => string_of_thm thm,
			fn () => string_of_term tm]
		else ();
	val res = (
		let	val s1 = conv_rule(simple_eq_match_conv ƒ_uncurry_thm) thm;
			val s2 = simple_ƒ_elim tm s1;
			val s3 = if is_pair tm
				then conv_rule(RAND_C (simple_eq_match_conv snd_thm) 
					THEN_C RATOR_C(RAND_C (simple_eq_match_conv fst_thm))) s2
				else s2;
			val s4 = conv_rule(RATOR_C %beta%_conv THEN_C %beta%_conv) s3;
		in
			s4
		end
	);
in
	res
end);
=TEX
The following function makes a variant variable structure
from a given list of frees, and duplicates within.
The conditional is given to prevent a new term being used
that is equal to the old one.
=SML
fun âvarstruct_variantá (na : TERM list) (tm : TERM) : TERM = (
let	val nms = (map (fst o dest_var) na) cup [];
	fun aux anms tm = (
		if is_var tm
		then (let val (nm,ty) = dest_var tm;
			val nm' = string_variant anms nm;
		in
			((nm :: anms), mk_var(nm', ty))
		end)
		else (let val (v1,v2) = dest_pair tm;
			val (anms',v1') = aux anms v1;
			val (anms'',v2') = aux anms' v2;
		in
			(anms'', mk_pair(v1',v2'))
		end)
	);
	val tm' = snd(aux nms tm)
in
	if tm' = tm
	then tm
	else tm'
end);
=TEX
=SML
val âlist_ƒ_elimá : TERM list -> THM -> THM = revfold (uncurry ƒ_elim);
=TEX
=SML
fun âall_ƒ_elimá (thm: THM): THM = (
let	val fa = list_cup (map frees (hyps thm));
fun strip_ƒ_elim (thm : THM) : THM = (
let	val (vs,bdy) = dest_ƒ(concl thm);
	val vs' = varstruct_variant fa vs;
	val res = (if is_var vs'
		then simple_ƒ_elim vs' thm
		else (
		let	val s1 = conv_rule(simple_eq_match_conv ƒ_uncurry_thm) thm;
			val s2 = simple_ƒ_elim vs' s1;
			val s3 = conv_rule(RAND_C (simple_eq_match_conv snd_thm) 
					THEN_C RATOR_C(RAND_C (simple_eq_match_conv fst_thm))) s2;
			val s4 = conv_rule(RATOR_C %beta%_conv THEN_C %beta%_conv) s3;
		in
			s4
		end)
	);
in
	res
end);
in
	iterate strip_ƒ_elim thm
end);
=TEX
=TEX
The algorithm to introduce a universally quantified $tm$ to $thm$ in the following is:
\begin{enumerate}
\item
Try $simple\_ƒ\_intro$ $tm$ $ö\ …\ conc$.
\item
Rename any duplicate variables in $tm$, avoiding variables found
free in the conclusion or assumptions.
\item
For the invocation to be correct $tm$ must be of the form $(p,\ q)$.
Convert the theorem into $ö\ …\ (\ p\ q\ Ž\ conc)\ p\ q$.
\item
Instantiate each variable of $tm$ with the matching components of variable $x$ (created by $Fst$ and $Snd$)
where $x$ has the same type as $tm$.
\item
Rewrite any introduced instances of $Fst\ y,\ Snd\ y$ with $y$.
\item
Generalise for $x$.
\item
Match the result with the theorem
óHOL
… ƒ fŽ (ƒ xŽ f (Fst x) (Snd x)) ‚ $ƒ (Uncurry f)
æ
\item
This should leave a theorem in the desired form, because
the replacement for $f$ should be of the right form for the result to
be displayed as $ƒ\ tm\ Ž\ conc$.
\end{enumerate}
We needn't avoid variables in $tm$ because they have to be of
a ``smaller'' type than the $x$ we create.
=SML
local
fun aux (av: TERM list) (tm : TERM) : (TERM * (TERM * TERM) list) = (
let 	val x = variant av (mk_var ("x",type_of tm));
	fun aux1 x1 tm1 = (
		if is_var tm1
		then [(x1,tm1)]
		else  (let val (ftm1,stm1) = dest_pair tm1;
			val snms = aux1 (mk_snd x1) stm1;
			val fnms = aux1 (mk_fst x1) ftm1;
		in
			(fnms @ snms)
		end)
	);
in
	(x, aux1 x tm)
end);
val prc = pure_rewrite_conv [sfst_snd_thm];
in
fun âƒ_introá (tm : TERM) (thm : THM) : THM = (
	simple_ƒ_intro tm thm
handle (Fail _) =>
let	val conc = concl thm;
	val cf = frees conc;
	val tf = frees tm;
	val hf = list_cup(map frees (hyps thm));
	val sideeffect = if (any tf (fn x => x mem hf)) 
		then term_fail "ƒ_intro" 6005 [find tf (fn x => x mem hf)]
		else ();
	val unbound_cf = cf diff tf;
	val avoid = (unbound_cf @ hf);
	val tm' = replace_dups avoid tm;
	val (vs1,vs2) = dest_pair tm';
	val s1 = conv_rule (fn x:TERM => eq_sym_rule ((RATOR_C %beta%_conv THEN_C %beta%_conv)
		(list_mk_app(list_mk_([vs1,vs2],conc),[vs1,vs2])))) thm;
	val (x, insts) = aux avoid tm';
	val s2 = inst_term_rule insts s1;
	val s4 = conv_rule (TRY_C(RATOR_C(RAND_C prc) EITHER_C RAND_C prc)) s2;
	val s5 = simple_ƒ_intro x s4;
	val s6 = conv_rule(simple_eq_match_conv sƒ_uncurry_thm) s5;
in
	s6
end
handle complaint =>
divert complaint "dest_pair" "ƒ_intro" 27010 [fn () => string_of_term tm]);
end;
=SML
val âƒ_uncurry_convá : CONV = (fn (tm : TERM) =>
let	val (vs,bdy) = dest_ƒ tm;
	val sideeffect = if is_pair vs
		then ()
		else term_fail "ƒ_uncurry_conv" 27038 [tm];
	val fvs = flat_vs "ƒ_uncurry_conv"  vs;
	val res_tm = list_mk_simple_ƒ (fvs, bdy);
	val s1 = asm_rule tm;
	val s2 = ƒ_elim vs s1;
	val s3 = list_simple_ƒ_intro fvs s2;
	val s4 = disch_rule tm s3;
	val s5 = asm_rule res_tm;
	val s6 = list_simple_ƒ_elim fvs s5;
	val s7 = ƒ_intro vs s6;
	val s8 = disch_rule res_tm s7;
	val s9 = ‚_intro s4 s8;
in
	s9
end
handle complaint =>
list_divert complaint "ƒ_uncurry_conv" [
	("dest_ƒ", 27038, [fn () => string_of_term tm])
	]
);
=TEX
=SML
val âall_ƒ_uncurry_convá : CONV = (fn tm =>
let fun aux tm' = (
	if is_ƒ tm'
	then (CBINDER_C aux EITHER_C ƒ_uncurry_conv)tm'
	else fail_conv tm');
in
	aux tm
end
handle complaint =>
list_divert  complaint "all_ƒ_uncurry_conv" [
	("fail_conv",27041,[fn () => string_of_term tm]),
	("ƒ_uncurry_conv",27041,[fn () => string_of_term tm])]
);

val âall_ƒ_uncurry_ruleá = conv_rule(TRY_C all_ƒ_uncurry_conv);
=TEX
\subsubsection{Concerning $‡$}
=SML
local
	val pfs = pure_rewrite_conv[sfst_snd_thm];
in
fun âc‡_elim_ruleá (vs :TERM) (cthm : THM) (wthm : THM) : THM = (
	‡_elim_rule vs cthm wthm
handle (Fail _) =>
let	val fvs = flat_vs "c‡_elim_rule" vs;
	val sideeffect = case (two_the_same fvs) of
		Value x => term_fail "c‡_elim_rule" 27043 [x,vs]
		| Nil => ();
	val wconc = concl wthm;
	val cconc = concl cthm;
	val fwconc = frees wconc;
	val fcconc = frees cconc;
	val (t,ct) = dest_app cconc;
	val asm = mk_app (t,vs);
	val sideeffect = if any fvs (fn x => x mem fcconc)
		then fail "c‡_elim_rule" 27044 [
			fn () => string_of_term (find fvs (fn x => x mem fcconc)),
			fn () => string_of_thm cthm]
		else if any fvs (fn x => x mem fwconc)
		then fail "c‡_elim_rule" 27044 [
			fn () => string_of_term (find fvs (fn x => x mem fwconc)),
			fn () => string_of_thm wthm]
		else ();
	val x = (case gen_vars [type_of vs] (fwconc @ fcconc @ fvs 
		@ hyps cthm @ hyps wthm) of
		[term] => term
		| _ => error "simple_„_elim" 6032 [])
		handle complaint =>
		pass_on complaint "gen_vars" "c‡_elim_rule";
	val s1 = Š_intro asm wthm;
	val s2 = ƒ_intro vs s1
		handle complaint =>
		pass_on complaint "ƒ_intro" "c‡_elim_rule";
	val s3 = ƒ_elim x s2;
	val s4 = conv_rule(RATOR_C(RAND_C pfs)) s3;
	val s5 = undisch_rule s4;
	val s6 = ‡_elim_rule x cthm s5;
in
	s6
end
handle complaint =>
list_divert complaint "c‡_elim_rule" [
	("dest_app", 7019, [fn () => string_of_thm cthm]),
	("mk_app", 7054, [fn () => string_of_term vs]),
	("pure_rewrite_conv", 27045, [fn () => string_of_term vs,
			fn () => string_of_thm cthm,
			fn () => string_of_thm wthm
		])
	]);
end;
=TEX
\subsubsection{Concerning $„$}
=SML
fun âv_„_introá (v : TERM) (thm : THM) : THM = (
let	val conc = concl thm;
	val abs = mk_ (v,conc)
		handle complaint =>
		pass_on complaint "mk_" "v_„_intro";
	val abst2 = mk_app (abs, v);
	val s1 = %beta%_conv abst2;
	val s2 = eq_sym_rule s1;
	val s3 = ‚_mp_rule s2 thm;
	val s4 = ‡_intro_rule s3;
	val s5 = inst_type_rule [(type_of v, mk_vartype "'a")] „_def;
	val s6 = ap_arg_rule abs s5;
	val s7 = simple_%beta%_conv (snd(dest_eq(concl s6)));
	val s8 = eq_trans_rule s6 s7;
	val s9 = eq_sym_rule s8;
	val s10 = ‚_mp_rule s9 s4;
in
	s10
end);
=TEX
The algorithm we use is:
\item
Try $simple\_„\_intro$ $tm$ $ö\ …\ conc$.
\item
For the remaining calls $tm$ must be of the form
$„\ (vs1,vs2)\ Ž\ bdy$.
We rename any duplicate variables in $(vs1,vs2)$, avoiding variables found
free in the conclusion or assumptions.
\item
We determine what the variables in $(vs1,vs2)$ must match
in the conclusion of $thm$.
\item
From these matches we determine the matching structures to $(vs1,vs2)$, say $(ivs1,ivs2)$
\item
Convert the theorem into $ö\ …\ (\ vs1\ vs2\ Ž\ conc)\ ivs1\ ivs2$.
\item
Convert the theorem to the form
$ö\ …\ (\ vs1\ vs2\ Ž\ conc)\ (Fst(ivs1,ivs2))\ (Snd(ivs1,ivs2))$.
\item
Use $simple\_„\_intro$ to get 
$ö\ …\ „\ xŽ\ (\ vs1\ vs2\ Ž\ conc)\ (Fst x)\ (Snd x)$.
\item
Match the result with the theorem
óHOL
… ƒ fŽ („ xŽ f (Fst x) (Snd x)) ‚ $„ (Uncurry f)
æ
\item
This should leave a theorem in the desired form, because
the replacement for $f$ should be of the right form for the result to
be displayed as $„\ tm\ Ž\ conc$.
\end{enumerate}

=SML
fun â„_introá (tm : TERM) (thm : THM) = (
	simple_„_intro tm thm
handle (Fail _) =>
let	val (vs,bdy) = dest_„ tm
		handle complaint =>
		pass_on complaint "dest_„" "„_intro";
	val conc = concl thm;
	val (tys,einsts) = term_match conc bdy;
	val sideeffect = case tys of
		[] => ()
		| _ => fail "„_intro" 7047 [
			fn () =>string_of_term tm,
			fn () => string_of_thm thm];
	val cf = frees conc;
	val tf = frees vs;
	val hf = list_cup(map frees (hyps thm));
	val unbound_cf = cf diff tf;
	val avoid = (unbound_cf @ hf);
	val vs' = replace_dups avoid vs;
	val (vs1,vs2) = dest_pair vs';
	val ivs1 = subst einsts vs1;
	val ivs2 = subst einsts vs2;
	val ivs = mk_pair(ivs1,ivs2);
	val bit = list_mk_([vs1,vs2],bdy);
	val s1 = conv_rule (fn x:TERM => eq_sym_rule ((RATOR_C %beta%_conv THEN_C %beta%_conv)
		(list_mk_app(bit,[ivs1,ivs2])))) thm;
	val ty_inst = [(type_of vs1,tva),(type_of vs2,tvb)];
	val ivs1_thm = list_simple_ƒ_elim [ivs1,ivs2]
		(inst_type_rule ty_inst sfst_thm);
	val ivs2_thm = list_simple_ƒ_elim [ivs1,ivs2]
		(inst_type_rule ty_inst ssnd_thm);
	val s2 = conv_rule (RATOR_C(RAND_C (fn x => ivs1_thm)) THEN_C RAND_C (fn x => ivs2_thm)) s1;
	val x = variant(cf @ hf)(mk_var("x",type_of vs));
	val template = mk_simple_„(x, 
		list_mk_app(bit,[mk_fst x, mk_snd x]));
	val s3 = simple_„_intro template s2;
	val s4 = conv_rule(simple_eq_match_conv s„_uncurry_thm) s3;
in
	s4
end
handle complaint =>
list_divert complaint "„_intro" [
	("term_match", 7047, [fn () => string_of_term tm,
		fn () => string_of_thm thm])
	]);
=TEX
=SML
fun â„_elimá (vs : TERM) (thm1 : THM) (thm2 : THM) : THM = (
	simple_„_elim vs thm1 thm2
handle (Fail _) =>
let	val cthm1 = concl thm1;
	val cthm2 = concl thm2;
	val (vsx,tx) = dest_„ cthm1;
	val (tys,subs) = term_match vsx vs;
	val sideeffect = if is_nil tys
		then ()
		else fail "„_elim" 27042 [
		fn () => string_of_term vs,
		fn () => string_of_thm thm1];
	val t1 = snd(dest_app cthm1);
	val all_frees = frees cthm1 cup frees cthm2 cup 
		list_cup (map frees (hyps thm1)) cup
		list_cup (map frees (hyps thm1));
	val vs' = replace_dups (all_frees diff (frees vs)) vs;
	val t1v = mk_app (t1, vs');
	val tvx = (case gen_vars [BOOL] (all_frees @ (frees vs')) of
		[term] => term
		| _ => error "„_elim" 6032 [])
		handle complaint =>
		pass_on complaint "gen_vars" "„_elim";
	val s1 = inst_type_rule [(type_of vs, tva)] „_def;
	val s2 = ap_arg_rule t1 s1;
	val s3 = ‚_mp_rule s2 thm1;
	val s5 = conv_rule simple_%beta%_conv s3;
	val s6 = %beta%_conv t1v;
	val s7 = eq_sym_rule s6;
	val asm = fst(dest_eq(concl s7))
	val s8 = Š_intro asm thm2;
	val template = mk_Š (tvx, cthm2);
	val s10 = subst_rule [(s7, tvx)] template s8;
	val s11 = undisch_rule s10;
	val s12 = (c‡_elim_rule vs' s5 s11)
		handle complaint =>
		pass_on complaint "c‡_elim_rule" "„_elim";
in
	s12
end
handle complaint =>
list_divert complaint "„_elim" [
	("term_match", 27042, [
		fn () => string_of_term vs,
		fn () => string_of_thm thm1]),
	("dest_„", 27046, [fn () => string_of_thm thm1])
	]);
=TEX
=SML
local
	fun list_v_„_intro tml thm = fold (uncurry v_„_intro) tml thm;
	fun list_simple_„_elim [] tm wthm = wthm
	| list_simple_„_elim (v :: rest) tm wthm = (
		let	val tm' = mk_simple_„(v, tm);
		in
		list_simple_„_elim rest tm'
			(simple_„_elim v (asm_rule tm') wthm)
		end);
		
in
val â„_uncurry_convá : CONV = (fn (tm : TERM) =>
let	val (vs,bdy) = dest_„ tm;
	val sideeffect = if is_pair vs
		then ()
		else term_fail "„_uncurry_conv" 27047 [tm];
	val fvs = flat_vs "„_uncurry_conv" vs;
	val res_tm = list_mk_simple_„ (fvs, bdy);
	val s1 = asm_rule tm;
	val s2 = asm_rule bdy;
	val s3 = list_v_„_intro fvs s2;
	val s4 = „_elim vs s1 s3;
	val s5 = disch_rule tm s4;

	val s6 = asm_rule res_tm;
	val s7 = v_„_intro vs s2;
	val s8 = list_simple_„_elim (rev fvs) bdy s7;
	val s9 = disch_rule res_tm s8;
	val s10 = ‚_intro s5 s9;
in
	s10
end
handle complaint =>
list_divert complaint "„_uncurry_conv" [
	("dest_„", 27047, [fn () => string_of_term tm])
	]
);
end;
=TEX
=SML
val âall_„_uncurry_convá : CONV = (fn tm =>
let fun aux tm' = (
	if is_„ tm'
	then (CBINDER_C aux EITHER_C „_uncurry_conv)tm'
	else fail_conv tm');
in
	aux tm
end
handle complaint =>
list_divert  complaint "all_„_uncurry_conv" [
	("fail_conv",27048,[fn () => string_of_term tm]),
	("„_uncurry_conv",27048,[fn () => string_of_term tm])]
);
val âall_„_uncurry_ruleá = conv_rule(TRY_C all_„_uncurry_conv);
=TEX
\subsection{Derived Rules}
\subsection{Concerning Š}
=SML
fun âŠ_match_mp_ruleá (thm1 : THM) : THM ‹ THM = (
let	val thm1' = all_ƒ_uncurry_rule thm1;
	val r' = simple_Š_match_mp_rule thm';
in
	(fn (thm2 : THM) =>
	r' thm2
	handle complaint =>
	pass_on complaint "simple_Š_match_mp_rule" "Š_match_mp_rule")
end
handle complaint =>
pass_on complaint "simple_Š_match_mp_rule" "Š_match_mp_rule");
=TEX
=SML
fun âŠ_match_mp_rule1á (thm1 : THM) : THM ‹ THM = (
let	val thm1' = all_ƒ_uncurry_rule thm1;
	val r' = simple_Š_match_mp_rule1 thm';
in
	(fn (thm2 : THM) =>
	r' thm2
	handle complaint =>
	pass_on complaint "simple_Š_match_mp_rule1" "Š_match_mp_rule1")
end
handle complaint =>
pass_on complaint "simple_Š_match_mp_rule1" "Š_match_mp_rule1");
=TEX
\subsection{Concerning ‚}
=SML
fun â‚_match_mp_ruleá (thm1 : THM) : THM ‹ THM = (
let	val thm1' = all_ƒ_uncurry_rule thm1;
	val r' = simple_‚_match_mp_rule thm';
in
	(fn (thm2 : THM) =>
	r' thm2
	handle complaint =>
	pass_on complaint "simple_‚_match_mp_rule" "‚_match_mp_rule")
end
handle complaint =>
pass_on complaint "simple_‚_match_mp_rule" "‚_match_mp_rule");
=TEX
=SML
fun â‚_match_mp_rule1á (thm1 : THM) : THM ‹ THM = (
let	val thm1' = all_ƒ_uncurry_rule thm1;
	val r' = simple_‚_match_mp_rule1 thm';
in
	(fn (thm2 : THM) =>
	r' thm2
	handle complaint =>
	pass_on complaint "simple_‚_match_mp_rule1" "‚_match_mp_rule1")
end
handle complaint =>
pass_on complaint "simple_‚_match_mp_rule1" "‚_match_mp_rule1");
=TEX
\subsection{Concerning =}
=SML
val âeq_match_convá (thm: THM): CONV = (
let	val thm' = all_ƒ_uncurry_rule thm;
	val c' = simple_eq_match_conv thm';
in
	(fn tm => c' tm
	handle complaint =>
	pass_on complaint "simple_eq_match_conv" "eq_match_conv")
end
handle complaint =>
pass_on complaint "simple_eq_match_conv" "eq_match_conv");
=TEX
=SML
val âeq_match_conv1á (thm: THM): CONV = (
let	val thm' = all_ƒ_uncurry_rule thm;
	val c' = simple_eq_match_conv1 thm';
in
	(fn tm => c' tm
	handle complaint =>
	pass_on complaint "simple_eq_match_conv1" "eq_match_conv1")
end
handle complaint =>
pass_on complaint "simple_eq_match_conv1" "eq_match_conv1");
=TEX
\subsection{Concerning }
=SML
val â%beta%_ruleá : THM -> THM = conv_rule %beta%_conv;
=TEX
The below follows the pattern of $all\_simple\_\beta\_conv$:
=SML
val âall_%beta%_convá : CONV = (
let
fun rhs (thm: THM) : TERM = snd(dest_eq(concl thm));
fun asbc (tm : TERM) : THM OPT = (
let	val dt = dest_simple_term tm;

	fun aux1 thm1 thm2 = (
	let	val s1 = mk_app_rule thm1 thm2
	in
		Value (
		if not(is_(rhs thm1))
		then s1
		else (let val s2 = conv_rule (RAND_C %beta%_conv) s1;
		in
		if is_(rhs thm2)
		then (
			case (asbc (rhs s2)) of
			Nil => s2
			| Value s3 => eq_trans_rule s2 s3
		) else s2
		end)
		)
	end);

	fun aux2 (f : TERM) (x : TERM) : THM OPT = (
	if is_ f
	then 	(Value(
		if is_ x
		then ((%beta%_conv FURTHER_C(fn tm1 =>
			force_value (asbc tm1))) tm)
		else (%beta%_conv tm)
		))
	else Nil);

	fun aux (App (f, x)) = (
	let	val fr = asbc f;
		val xr = asbc x;
	in
		case (fr,xr) of
		(Nil, Nil) => aux2 f x
		| (Value frt,Nil) => aux1 frt (refl_conv x)
		| (Nil, Value xrt) => aux1 (refl_conv f) xrt
		| (Value frt, Value xrt) => aux1 frt xrt
	end
	) | aux (Simple (x, b)) = (
	let	val br = asbc b
	in
		case br of
		Nil => Nil
		| (Value brt) => Value(simple__eq_rule x brt)
	end
	) | aux _ = Nil;
in
	aux dt
end);
in
	(fn (tm:TERM) => case (asbc tm) of
		Value red => red
		| Nil => term_fail "all_%beta%_conv" 27049 [tm])
end);
=TEX
=SML
fun âall_%beta%_ruleá (thm : THM) =(
	conv_rule all_%beta%_conv thm
	handle complaint =>
	divert complaint "all_%beta%_conv"
		"all_%beta%_rule" 27049 [fn () => string_of_thm thm]
);
=TEX
=SML
val â%eta%_convá : CONV = (fn (tm : TERM) =>
	simple_eq_match_conv eta_axiom tm
handle (Fail _) =>
let	val (vs,tvs') = dest_ tm;
	val (t,vs') = dest_app tvs';
in
	if is_pair vs andalso (vs = vs')
	then (simple_eq_match_conv uc_thm THEN_C
		_C(RATOR_C %beta%_conv THEN_C %beta%_conv THEN_C
		RAND_C (MAP_C(simple_eq_match_conv sfst_snd_thm))) THEN_C
		simple_eq_match_conv eta_axiom)
		tm
	else term_fail "%eta%_conv" 27023 [tm]
end
handle complaint =>
list_divert complaint "%eta%_conv" [
	("dest_", 27018, [fn () => string_of_term tm]),
	("dest_app", 27018, [fn () => string_of_term tm]),
	("MAP_C", 27023, [fn () => string_of_term tm]),
	("simple_eq_match_conv", 27023, [fn () => string_of_term tm])]
);
=TEX
\subsection{Concerning ƒ}
=SML
local
val âŒ_ƒ_convá : CONV = (fn (tm : TERM) =>
	Œ_ƒ_conv tm
handle (Fail _) =>
??? Œ_ƒ_uncurry_thm ??? 
\section{END OF THE STRUCTURE}
=SML
(* end; of structure DerivedRulesII *)
(* open DerivedRulesII *)
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
