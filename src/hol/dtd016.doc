=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for Type Inference}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD016}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document gives the detailed design
of the type inference mechanism.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}

\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'

\begin{description}
\item[Issue 1.1]
Initial version.
\end{description}
\subsection{Changes forecast}
\pagebreak
\section{GENERAL}

\subsection{Scope}

\subsection{Introduction}

\subsubsection{Background and Purpose}

\subsubsection{Interface}

This document defines a signature $TypeInference$.

\subsubsection{Deficiencies}

None Known.

\subsubsection{Dependencies}

This document depends on the error handling system described
in document \cite{DS/FMU/IED/DTD002}.

\section{DESIGN ISSUES}

The type inferer's jobs is to establish the types
of all the free variables in a term, whilst rejecting
terms which contain contraditions in typing.

The parser communicates to the type inferer via a
parse tree of type ``TY TM'' whose definition can be found
in \cite{DS/FMU/IED/DTD019}. The tree is partially typed
according to the types provided explicitly by the
textual term, or by constant definitions whose types are
stored in the symbol table.

The type inferer has three principle components.

\begin{description}

\item[Type Extension and Unification]

\item[Translation to Terms]

\item[Alias Resolution]

\end{description}

\section{RULES OF INFERENCE}
\begin{FruleLeftJustify}

\subsection{Types}

The inference rules for types are introduced first. Each
rule corresponds to a BNF production rule in the grammar
describing a term produced by the parser (of type ``\'a TM).

\subsubsection{Atomic Types}

Type atoms whose first character is ``\'\ '' will be
assumed by the type inferer to denote type variables.

=RULE
First of s is the character '
É
É
ENV … TyAtom s ‹ mk_vartype s
=TEX

Type atoms whose first character is not ``\'\ '' will
be use to constuct an actual type, whose name is
the parameter to $TyAtom$.

=RULE
First of s is NOT the character '
É
É
ENV … TyAtom s ‹ mk_type (s, nil)
=TEX

\subsubsection{Compound Types}

Compound types will comprise a list of types, an identifier
and a fixity. The fixity of the type is irrelevant to
the process of type inference and can be ignored.
Given that there is a mapping from the type list to a
list of actual types, the inference rule for compound
types is straightforward. An actual type os constructed
with the identifier given as part of the compound type, and
the type list as given by the mapping for type lists.
In the actual implementation, this will comprise a recursive
call to the type inference code for types. For the
moment, the representation below captures the essence.

=RULE
É
ENV … tyl ‹ TYL:TYPE list
É
ENV … TyCompound (tyl, s, _)
	‹ mk_type (s, TYL)
=TEX

\subsubsection{Antiquoted Types}

An antiquoted type simply yields the type which is
a parameter to the value constructor $TyAq$.

=RULE
É
É
ENV … TyAq þ ‹ þ
=TEX

\subsection{Terms}

The inference rules for terms are now introduced. Each
rule corresponds to a BNF production rule in the grammar
describing a term produced by the parser (of type ``\'a TM).

\subsubsection{Binders}

=RULE
binding constructor is ""
É
ENV … t° ‹ T°:þ°; ENV … t¬ ‹ T¬:þ¬;

ENV •
{n — VarInfo þ' | mk_var(n, þ')  frees T°}
	… t¬ ‹ T¬:þ¬
É
ENV … Binder ("", t°, t¬)
	‹ mk_abs(T°:þ°, T¬:þ¬)
=TEX

=RULE
binding constructor is  NOT ""
É
ENV … t° ‹ T°:þ°; ENV … t¬ ‹ T¬:þ¬;

ENV … TmAtom (Id s)
	‹ mk_const (s, (þ° ‹ þ¬) ‹ þ®);

ENV •
{n — VarInfo þ' | mk_var(n, þ')  frees T°}
	… t¬ ‹ T¬:þ¬
É
ENV … Binder (s, t°, t¬)
  ‹ (mk_comb(mk_const (s, (þ° ‹ þ¬) ‹ þ®),
    mk_abs(T°:þ°,T¬:þ¬))):þ®
=TEX

\subsubsection{Let}

=RULE
É
ENV … v° ‹ V°:þ°; ENV … v¬ ‹ V¬:þ¬; ...
	... ENV … vÕ ‹ VÕ:þÕ;

ENV … t° ‹ T°:þ°; ENV … t¬ ‹ T¬:þ¬; ...
	... ENV … tÕ ‹ TÕ:þÕ;

ENV • { n — VarInfo þ' | mk_var(n, þ')
   {frees V¸ | 1 ž c ž s}} … tm ‹ TM:þ;
É
Let ([(v°, t°), (v¬, t¬), ..., (vÕ, tÕ)], tm)
  ‹ (mk_let ([(V°:þ°, T°:þ°),
	(V¬:þ¬, T¬:þ¬), ...
	    ... ,(VÕ:þÕ,TÕ:þÕ)],TM:þ)):þ
=TEX

\subsubsection{Conditional Terms}

=RULE
É
ENV … c ‹ C:BOOL; ENV … t° ‹ T°:þ;
ENV … t¬ ‹ T¬:þ
É
ENV … Cond (c, t°, t¬)
	‹ (mk_if (C:BOOL, T°:þ, T¬:þ)):þ
=TEX


\subsubsection{Function Application}

=RULE
É
ENV … t° ‹ T°:(þ° ‹ þ¬);
ENV … t¬ ‹ T¬:þ°
É
ENV … App (t°, t¬, _)
  ‹ (mk_comb(T°:(þ° ‹ þ¬), T¬:þ°)):þ¬
=TEX

\subsubsection{TmTyped}
=RULE
É
ENV … t° ‹ T°:þ;
ENV … ty ‹ þ
É
ENV … TmTyped (t°, ty) ‹ T°:þ
=TEX

\subsubsection{TmAq}
=RULE
É
É
ENV … TmAq term:þ ‹ term:þ
=TEX

\subsubsection{SetDisplay}

=RULE
É
ENV … t° ‹ T°:þ; ENV … t¬ ‹ T¬:þ; ...
	... ENV … tÕ ‹ TÕ:þ
É
ENV … SetDisplay ([t°, t¬, ..., tÕ])
  ‹ (mk_enum_set ([T°, T¬, ..., TÕ])):þSET
=TEX

\subsubsection{SetComprehension}

=RULE
É
ENV … t° ‹ T°:þ; ENV … t¬ ‹ T¬:BOOL
É
ENV … SetComprehension (t°, t¬)
	‹ (mk_set (T°:þ, T¬:BOOL)):þSET
=TEX

\subsubsection{ListDisplay}

=RULE
É
ENV … t° ‹ T°:þ; ENV … t¬ ‹ T¬:þ; ...
	... ENV … tÕ ‹ TÕ:þ
É
ENV … ListDisplay ([t°, t¬, ..., tÕ])
  ‹ (mk_list ([T°, T¬, ..., TÕ])):þLIST
=TEX

\subsubsection{Identifiers}

=RULE
þ is an instance of þ'
É
É
ENV • {s — ConstInfo þ'}
	… Id s ‹ (mk_const(s, þ)):þ
=TEX

=RULE
É
É
ENV • {s — VarInfo þ}
	… Id s ‹ (mk_var(s, þ)):þ
=TEX

=RULE
þ is any type
É
É
{s} › ENV … Id s ‹ (mk_var(s, þ)):þ
=TEX


\subsubsection{Literals}

=RULE
É
É
ENV … CharLit s
	‹ (mk_const(c, CHAR)):CHAR
=TEX

=RULE
É
É
ENV … StringLit s
	‹ (mk_const(s, STRING)):STRING
=TEX

=RULE
É
É
ENV … NumLit i
	‹ (mk_†(i, †)):†
=TEX


\end{FruleLeftJustify}
\section{THE EXTENDED TERM}


\section{THE STRUCTURE $TypeInference$}

=DOC
signature âTypeInferenceá = sig
	local
		open Parser Unification;
	in
		val is_varstruct : 'a TM -> bool
		val fv_set : 'a TM -> string list
		val ty_to_type : TY -> TYPE
		val start_tyvar_name : unit -> unit
		val next_tyvar_name : unit -> string
		val get_tyvar_info : SUBS -> EXTYPE TM -> (int * string) list
		val make_term : TY TM -> TERM
	end

end; (* of signature TypeInference *)
=DESCRIBE
This is the signature for the structure TypeInference.
=FAILURE
16000	type checking error in quotation
16001	**** TYPE CHECKING ERROR  ****
16002	type error in »?0¼
16010	»?0¼ is not a valid variable or varstruct
16020	cannot unify »:?0¼ with »:?1¼
16021	cannot unify list of types »?0¼
16022	(?0)
16100	DESIGN ERROR 
16101	DESIGN ERROR (?0)
=ENDDOC

\section{TEST POLICY}
The tests should follow the standards and guidelines
laid down in \cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}

