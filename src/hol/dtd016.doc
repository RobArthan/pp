=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for Type Inference}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD016}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document gives the detailed design
of the type inference mechanism for ICL HOL.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}

\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'

\begin{description}
\item[Issue 1.1]
Initial version.

\item[Issue 1.2]
Added much more description of the design
.
\end{description}
\subsection{Changes forecast}
None.

\pagebreak
\section{GENERAL}

\subsection{Scope}

This document describes the detailed design of the type inference
mechanism for ICL HOL.

\subsection{Introduction}

\subsubsection{Background and Purpose}

The type inference mechanism is an implementation of the
type inference rules described in this document. The concrete syntax
is parsed by the ICL HOL parser \cite{DS/FMU/IED/DTD019} which
produces a parse tree. The output of the parser is significantly
more complex than that of the prototype HOL parser. This is
because there is a richer set of types represented in its output
with a view to increasing efficiency. As a consequence, the
type inferer is correspondingly more complex. Many of the ideas for
designing the type inferer come from the excellent book
\cite{PeytonJones86}, and to some extent from the design and code
for the HOL prototype \cite{DS/FMU/IED/SML007}. The inferer makes
use of the general type unification package \cite{DS/FMU/IED/DTD014},
which itself is almost identical to the HOL prototype.
It has been noted that much of the time of type inference is
spent in unification, and although the implementation of
unification has been coded efficiently, further improvements to
the performance of type inference is likely to be most effective in
the area of unification.

\subsubsection{Interface}

This document defines a signature $TypeInference$ and is described in
section \ref{SIGNATURE} of this document.

\subsubsection{Deficiencies}

None Known.

\subsubsection{Dependencies}

This document depends on the error handling system described
in document \cite{DS/FMU/IED/DTD002}.

\newpage
\section{THE TYPE INFERENCE MECHANISM}

\subsection{Overview}

The type inferer's job is to establish the types
of all the free variables in a term, whilst rejecting
terms which contain contraditions in typing.

The parser communicates to the type inferer via a
parse tree of type ``TY TM'' whose definition can be found
in \cite{DS/FMU/IED/DTD019}. The tree is partially typed
according to the types provided explicitly by the
textual term, or by constant definitions whose types are
stored in the symbol table.

The type inferer has the job of establishing the types of all the
sub-terms within a term. Because the type inferer is located functionally
between the parser and the tools which manage HOL terms, it is
additionally responsible for converting the output of the parser into
HOL terms.

The input to the type inferer is a structure whose type is TY TM.
This is an elaborate representation of a term, which the type inferer
must simplify to produce a term of type TERM, which is a type
with a much simpler structure. However, in the process of type
inference, the types of sub-terms must be unified. The rules governing
the nature of the unifications are presented in this document
and dictate the requirements on types within a term. Before unification
of terms and sub-terms can take place, the types of each term and sub-term
must be extended in a way which allows unification to fill in the unknowns.
A description of unification and type extension can be found
in \cite{DS/FMU/IED/DTD014} and \cite{PeytonJones86}.

The unification algorithm is invoked when a structure of a term has
been identified, and broken down into its sub-elements. The inference
rules then indicate how the types of the subelements are related.
At this point, the subelements are unified. If this is successful, then
a new substitution function is returned and is retained and
overridden subsequently. There eventually comes a point where
the term has been unified and we have three things:

\begin{enumerate}

\item
A term which has the structure of the input term, but all the
types have been replaced with extended types.

\item
A extended type of the overall term

\item
A substitution function which is produced by the unifications of
the sub-terms of the tree.

\end{enumerate}

What now remains is to produce a HOL term from this information.
The types the sub-terms are known as this information is inherent
in the substitution function. This information needs to be used
to type the sub-terms correctly, and to translate the input term
structure to the simpler HOL term structure.

The translation is made easy because the programming interfaces
for constructing HOL terms are available to us. The partially
inferred term needs to be broken up and re-constructed using the
programmer's interface utilities to generate a correctly typed HOL
term.

A Constant in the input term may be an alias for a term. The resolution
of the alias need not take place until the production of the HOL term.
If the alias were to be resolved at an earlier point during
type inference, an additional overhead of processing the consequence
would result, but with no apparent benefit. It is easy for the
type checker to resolve aliases since an interface is already available
from \cite{DS/FMU/IED/DTD020} which is ideally suited for the
context in which we want to resolve aliases.


In summary, the key functions of the type inference mechanism are:

\begin{enumerate}

\item
Type extension and unification

\item
Translation of an input term to a HOL term

\item
Resolution of aliases

\end{enumerate}

\subsection{Environment Management}

In practice, as variables and constants are put into scope, an environment
is constructed. This is a symbol table which maps a name onto
information about the object to which the name refers, the
nature of information depending on the type of object (eg. constant or
variable). An initial environment is set up by the type
inferer as a preliminary action. This comprises constants from the
HOL symbol table (accessible by the functions described
in \cite{DS/FMU/IED/DTD020}) and all the free variables in the
term to be type-inferred. When a new variable is brought into scope
then the environment is grown. If the environment is viewed as
a function, then growing the environment would correspond to
functional override.

\subsection{Identifying Free Variables}

It is necessary for the type inference mechanism to be able to identify
the free variables of a term. This can be achieved easily by
traversing the term and noting the variables/constants in the term.
A variable and a constant are differentiated by their absence or
otherwise in the HOL symbol table.

A similar requirement is to locate free variables in an term whose
types have been extended. Such variables need to be associated
with names such that subsequent display of a HOL term with free
types would contain type variable names starting at ``\'\ a''
counting upwards. The naming convention for type variables is
described in section \ref{FVNAMES}.

\subsection{Handling and Displaying Errors}

Errors will be handled by the generic error handler described
in \cite{DS/FMU/IED/DTD002}. It is highly desirable that the
error messages produced by the type inference mechanism and
the lexical analyser/parser be uniform in their presentation
of diagnostic information. The error
message formats have been adapted from \cite{DS/FMU/IED/DTD019}.

Errors found during type inference can be either due to there being
a problem with the input, these are known as {\bf failures}; and errors
due to an unforseen design fault, known from hereon as {\bf errors}.

When a failure occurs, then the sub-term which contains the error
is printed out. If the failure is caused by a failure to unify two types,
then some indication of the types causing the failure
should be printed.

It is debatable how much context information should be printed
out to aid the user in locating the source of the failure. If two
much of the term is printed, then it may be ambiguous as to which
occurrence of a sub-term caused the failure. Likewise, the same problem
may arise if too little of the term is printed.

Further changes in this area are envisaged when the ICL HOL pretty
printer is available which will permit terms to be displayed upto
a configurable depth.

\subsection{Production of a Term with Extended Types}

The mapping from types of type TY to
extended types of type EXTYPE is well-defined. Therefore the
conversions of types to extended types within a term can be
done by traversing the term carrying out the replacement where
appropriate. Clearly, there is a performance issue here, and
it is desirable to economize on the number of traversals. This
conversion can be done at the same time as the conversion of a
term into its corresponding HOL equivalent - the last stage
of type inference.

\subsection{Convertion of a Term to a HOL Term}

The conversion of a term to a HOL term is done when all the types
have been inferred, and a substitution tree has been produced.
The availability of the interfaces for making HOL terms means that
a single traversal of the term (containing extended types) is
sufficient to convert sub-terms to sub-terms of a HOL term.
Unknown type variables found at this stage are converted into
HOL type variables which are identified as described in section
\ref{FVNAMES}

\subsubsection{Unknown Types} \label{FVNAMES}

Terms which contain types which are not known are assigned type
variables. These are identified by the names 'a, 'b etc. upto
'z. Further names are produced if necessary of the
following form: '27, '28 ... and so on. The numbering
starts at 27 giving the impression that the numbers 1 to 26 were
used for a to z (although never appearing as such).

This notation for unknown types is similar to Standard ML and
is a break from the convention in HOL of using a ``*''
prefix.

\subsection{The Type Inference Mechanism Glue}

The type inference mechanism glue is a
functional composition of the components of the mechanism described
in this document. The mechanism is in fact a function which maps
a term of type TY TM onto a HOL term of type TERM. The function
is called $make\_term$ and is described in section \ref{SIGNATURE}.

\section{RULES OF INFERENCE} \label{INFRULES}
\begin{FruleLeftJustify}
The rules of inference are divided into those concerned with
types and those concerned with terms. These are further subdivided
into rules which correspond to each production rule of the grammar
defining TY and TM.

\subsection{Types}

The inference rules for types are introduced first.

\subsubsection{Atomic Types}

Type atoms whose first character is ``\'\ '' will be
assumed by the type inferer to denote type variables.

=RULE
First of s is the character '
É
É
ENV … TyAtom s ‹ mk_vartype s
=TEX

Type atoms whose first character is not ``\'\ '' will
be use to constuct an actual type, whose name is
the parameter to $TyAtom$.

=RULE
First of s is NOT the character '
É
É
ENV … TyAtom s ‹ mk_type (s, nil)
=TEX

\subsubsection{Compound Types}

Compound types will comprise a list of types, an identifier
and a fixity. The fixity of the type is irrelevant to
the process of type inference and can be ignored.
Given that there is a mapping from the type list to a
list of actual types, the inference rule for compound
types is straightforward. An actual type is constructed
with the identifier given as part of the compound type, and
the type list as given by the mapping for type lists.
In the actual implementation, this will comprise a recursive
call to the type inference code for types. For the
moment, the representation below captures the essence.

=RULE
É
ENV … tyl ‹ TYL:TYPE list
É
ENV … TyCompound (tyl, s, _)
	‹ mk_type (s, TYL)
=TEX

\subsubsection{Antiquoted Types}

An antiquoted type simply yields the type which is
a parameter to the value constructor $TyAq$.

=RULE
É
É
ENV … TyAq þ ‹ þ
=TEX

\subsection{Terms}

The inference rules for terms are now introduced. Each
rule corresponds to a BNF production rule in the grammar
describing a term produced by the parser (of type ``\'\ a'' TM).

\subsubsection{Binders}

Ultimately, all binding constructors are represented as
lambda abstractions. This case is therefore much simpler, and
we introduce this rule first.

The bound variables and
the body assume corresponding types to those given in the
input TM by some uniform mapping. The bound variables are brought into the scope of the body of the
construction by extending the environment. 

=RULE
binding constructor is ""
É
ENV … t° ‹ T°:þ°;

ENV •
{n — VarInfo þ' | mk_var(n, þ')  frees T°}
	… t¬ ‹ T¬:þ¬
É
ENV … Binder ("", t°, t¬)
	‹ mk_abs(T°:þ°, T¬:þ¬)
=TEX

For general binding constructions, the type of each element in
the input is uniformely mapped to a TYPE. The binder is itself typed
with free types, and subsequently unified.  The type of the
bound variables are put in the scope of the body.
=RULE
binding constructor is  NOT ""
É
ENV … t° ‹ T°:þ°;

ENV … TmAtom (Id s)
	‹ mk_const (s, (þ° ‹ þ¬) ‹ þ®);

ENV •
{n — VarInfo þ' | mk_var(n, þ')  frees T°}
	… t¬ ‹ T¬:þ¬
É
ENV … Binder (TmAtom (Id s), t°, t¬)
  ‹ (mk_comb(mk_const (s, (þ° ‹ þ¬) ‹ þ®),
    mk_abs(T°:þ°,T¬:þ¬))):þ®
=TEX

\subsubsection{Let}

The variable structures of the LHS of each clause in the
let statement are put in the scope of the body of the let
statement. The type of the overall term is the type of the
body of the term.
=RULE
É
ENV … v° ‹ V°:þ°; ENV … v¬ ‹ V¬:þ¬; ...
	... ENV … vÕ ‹ VÕ:þÕ;

ENV … t° ‹ T°:þ°; ENV … t¬ ‹ T¬:þ¬; ...
	... ENV … tÕ ‹ TÕ:þÕ;

ENV • { n — VarInfo þ' | mk_var(n, þ')
   {frees V¸ | 1 ž c ž s}} … tm ‹ TM:þ;
É
ENV … Let ([(v°, t°), (v¬, t¬), ..., (vÕ, tÕ)], tm)
  ‹ (mk_let ([(V°:þ°, T°:þ°),
	(V¬:þ¬, T¬:þ¬), ...
	    ... ,(VÕ:þÕ,TÕ:þÕ)],TM:þ)):þ
=TEX

\subsubsection{Conditional Terms}

The condition must unify to a bool, and the consequences and the
type of the overall term must all unify to the same type.

=RULE
É
ENV … c ‹ C:BOOL; ENV … t° ‹ T°:þ;
ENV … t¬ ‹ T¬:þ
É
ENV … Cond (c, t°, t¬)
	‹ (mk_if (C:BOOL, T°:þ, T¬:þ)):þ
=TEX


\subsubsection{Function Application}

The type of the function applied must have a domain type equal to
that to which the function is applied. The type of the overall
term is the type of object which the function yeilds.

=RULE
É
ENV … t° ‹ T°:(þ° ‹ þ¬);
ENV … t¬ ‹ T¬:þ°
É
ENV … App (t°, t¬, _)
  ‹ (mk_comb(T°:(þ° ‹ þ¬), T¬:þ°)):þ¬
=TEX

\subsubsection{TmTyped}

This rule constraints the explicit typing of a term to be unified
with the term.

=RULE
É
ENV … t° ‹ T°:þ;
ENV … ty ‹ þ
É
ENV … TmTyped (t°, ty) ‹ T°:þ
=TEX

\subsubsection{TmAq}

The type of an antiquoted term is assumed to be that of the term.
No explicit checking is done.

=RULE
É
É
ENV … TmAq term:þ ‹ term:þ
=TEX

\subsubsection{SetDisplay}

Each element in the set must have the same type $þ$. The overall set
has the type $þSET$
.
=RULE
É
ENV … t° ‹ T°:þ; ENV … t¬ ‹ T¬:þ; ...
	... ENV … tÕ ‹ TÕ:þ
É
ENV … SetDisplay ([t°, t¬, ..., tÕ])
  ‹ (mk_enum_set ([T°, T¬, ..., TÕ])):þSET
=TEX

\subsubsection{SetComprehension}

The bound variable in a set comprehension is brought into the
scope of the body of the comprehension. The type of the overall
expression is that of the bound variables

=RULE
É
ENV … t° ‹ T°:þ;

ENV •
{n — VarInfo þ' | mk_var(n, þ')  frees T°}
	… t¬ ‹ T¬:þ¬
É
ENV … SetComprehension (t°, t¬)
	‹ (mk_set (T°:þ, T¬:BOOL)):þSET
=TEX

\subsubsection{ListDisplay}

Each element in the list must have the same type $þ$. The overall list
has the type $þLIST$

=RULE
É
ENV … t° ‹ T°:þ; ENV … t¬ ‹ T¬:þ; ...
	... ENV … tÕ ‹ TÕ:þ
É
ENV … ListDisplay ([t°, t¬, ..., tÕ])
  ‹ (mk_list ([T°, T¬, ..., TÕ])):þLIST
=TEX

\subsubsection{Identifiers}

An identifier whose symbol is present in the symbol table will assume
the type corresponding to the symbol table entry.

=RULE
þ is an instance of þ'
É
É
ENV • {s — ConstInfo þ'}
	… Id s ‹ (mk_const(s, þ)):þ
=TEX

An identifier whose symbol is recognised in the environment denotes a
variable in scope. The type of the variable is given by the environment.

=RULE
É
É
ENV • {s — VarInfo þ}
	… Id s ‹ (mk_var(s, þ)):þ
=TEX

An identifier whose symbol is not in the symbol table denotes a
variable, and is given a free type.

=RULE
þ is any type
É
É
{s} › ENV … Id s ‹ (mk_var(s, þ)):þ
=TEX


\subsubsection{Literals}

Characters, strings and numbers are represented in HOL in distinct
ways. The inference rules for converting literals for these types
are straightforward. A character literal is mapped onto a character
constant, a string literal to a string constant and a numeric literal
to a numeric constant as follows:

=RULE
É
É
ENV … CharLit s
	‹ (mk_const(c, CHAR)):CHAR
=TEX

=RULE
É
É
ENV … StringLit s
	‹ (mk_const(s, STRING)):STRING
=TEX

=RULE
É
É
ENV … NumLit i
	‹ (mk_†(i, †)):†
=TEX


\end{FruleLeftJustify}

\section{THE SIGNATURE $TypeInference$} \label{SIGNATURE}

The signature $TypeInference$ is the interface to the type inference
mechanism, and it provides the outside world with three interfaces.
\begin{description}

\item[is\_varstruct]
This determines whether a term is a variable structure. A variable
structure is either a single variable or a tuple. This sort of thing
is useful to know, and cannot be determined from the grammar of
a parsed term alone.

\item[ty\_to\_type]
This converts a type as produced by the parser into a HOL type.

\item[make\_term]
This interface invokes the type inference mechanism and produces
a type-checked and infered HOL term from term delivered from the
parser.

\end{description}

=DOC
signature âTypeInferenceá = sig
local
	open Parser;
in
=DESCRIBE
This is the signature for the structure TypeInference.
=ENDDOC
=DOC
val âset_contextá : TERM list -> unit
=DESCRIBE
=ENDDOC
=DOC
val âget_contextá : unit -> TERM list
=DESCRIBE
=ENDDOC
=DOC
val âis_varstructá : 'a TM -> bool
=DESCRIBE
is\_varstruct determines whether or not a term (of type TM)
is a variable structure.
=ENDDOC
=DOC
val âty_to_typeá : TY -> TYPE
=DESCRIBE
This converts a type (of type TY) into a HOL type of type TYPE.
=ENDDOC
=DOC
val âmake_termá : TY TM -> TERM
=DESCRIBE
This interface invokes the type inference mechanism and produces
a type-checked and infered HOL term from term delivered from the
parser.
=FAILURE
16000	type checking error in quotation
16001	**** TYPE CHECKING ERROR  ****
16002	type error in »?0¼
16010	»?0¼ is not a valid variable or varstruct
16020	cannot unify »:?0¼ with »:?1¼
16021	cannot unify list of types »?0¼
16022	(?0)
16030	type constructor ?0 expects ?1 argument?2 not ?3 argument?4
16100	DESIGN ERROR 
16101	DESIGN ERROR (?0)
=ENDDOC

=SML
end
end; (* of signature TypeInference *)
=TEX

\section{TEST POLICY}
The tests should follow the standards and guidelines
laid down in \cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}

