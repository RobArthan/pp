=TEX
% TQtemplate.tex
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design for Type Inference}  %% Mandatory field
\TPPref{DS/FMU/IED/DTD016}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Approved}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document gives the detailed design
of the type inference mechanism for ICL HOL.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}

\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'

\begin{description}
\item[Issue 1.1 23 May 1991]
		Initial version.

\item[Issue 1.2 27 June 1991]
	Added textual description of the design.

\item[Issue 1.3 28 June 1991]
	Added much more description of the design.

\item[Issue 1.4 26 July 1991]
	Extended the signature for the functions $set\_context$
	and $get\_context$.

\item[Issue 1.5 29 July 1991]
	Changed names of syntax functions.

\item[Issue 1.6 2 August 1991]
	Added a description of the flag $TI\_verbose$ to the
	signature $TypeInference$.

\item[Issue 1.7 6 August 1991]
	Various changes to error messages. Also renamed $TI\_verbose$
	to $ti\_verbose$.

\item[Issue 1.8 15 August 1991]
	Added description of the type abbreviation facilities used,
	and description of the support required for type contexts.
	Also changed the names of two of the interfaces to
	$set\_ti\_context$ and $get\_ti\_context$.
	Document is now ready for inspection.

\item[Issue 1.9 15 August 1991]
	Rework done as required by Desk Check ID033.

\item[Issue 2.1 15 August 1991]
	Approved version of Issue 1.9.

\end{description}
\subsection{Changes forecast}

None.

\pagebreak
\section{GENERAL}

\subsection{Scope}

This document describes the detailed design of the type inference
mechanism for ICL HOL. The document responds to the
requirement in \cite{DS/FMU/IED/HLD008}.

\subsection{Introduction}

\subsubsection{Background and Purpose}

The type inference mechanism is an implementation of the
type inference rules described in this document. The concrete syntax
is parsed by the ICL HOL parser \cite{DS/FMU/IED/DTD019} which
produces a parse tree. The output of the parser is significantly
more complex than that of the prototype HOL parser. This is
because there is a richer set of types represented in its output
with a view to increasing efficiency. As a consequence, the
type inferrer is correspondingly more complex. Many of the ideas for
designing the type inferrer come from the excellent book
\cite{PeytonJones86}, and to some extent from the design and code
for the HOL prototype \cite{DS/FMU/IED/SML007}. The inferrer makes
use of the general type unification package \cite{DS/FMU/IED/DTD014},
which itself is almost identical to the HOL prototype.
It has been noted that much of the time of type inference is
spent in unification, and although the implementation of
unification has been coded efficiently, further improvements to
the performance of type inference is likely to be most effective in
the area of unification.

\subsubsection{Interface}

This document defines a signature $TypeInference$ and is described in
section \ref{SIGNATURE} of this document.

\subsubsection{Deficiencies}

None Known.

\subsubsection{Dependencies}

This document depends on the error handling system described
in document \cite{DS/FMU/IED/DTD002}, and the
datatypes defined in \cite{DS/FMU/IED/DTD003} and
\cite{DS/FMU/IED/DTD004}.

\newpage
\section{THE TYPE INFERENCE MECHANISM}

\subsection{Overview}

The type inferrer's job is to establish the types
of all the free variables in a term, whilst rejecting
terms which contain contradictions in typing.

The parser communicates to the type inferrer via a
parse tree of type TY TM whose definition can be found
in \cite{DS/FMU/IED/DTD019}. The tree is typed
according to the types provided by explicitly typed sub-terms,
and by types of constants which are defined in the symbol
table. Additional typing information comes from the
context.

The type inferrer has the job of establishing the types of all the
sub-terms within a term. The type inference works within a
context containing information relating to constants and variables
to types. The context determines the types of elements within terms.
The context comprises the HOL symbol table (in which constants are
defined) and a type inference context containing information about
variables used within a HOL ``session''. The support for setting
up the type inference context (for variables) is provided as part of this type inference package.

Since the type inferrer is located functionally
between the parser and the tools which manage HOL terms, it is
additionally responsible for converting the output of the parser into
HOL terms.

The input to the type inferrer is a structure whose type is TY TM.
This is an elaborate representation of a term, which the type inferrer
must simplify to produce a term of type TERM, which is a type
with a much simpler structure.

The term may contain type abbreviations. The first task in type inference
is to expand any type abbreviations present in the term.

Next, the types of sub-terms must be unified. The rules governing
the nature of the unifications are presented in this document
and dictate the requirements on types within a term. Before unification
of terms and sub-terms can take place, the types of each term and sub-term
must be extended \cite{DS/FMU/IED/DTD014} \cite{PeytonJones86} in a way which allows unification to fill in the unknowns.
A description of unification and type extension can be found
in \cite{DS/FMU/IED/DTD014} and \cite{PeytonJones86}.

The unification algorithm is invoked when a structure of a term has
been identified, and broken down into its sub-elements. The inference
rules then indicate how the types of the subelements are related.
At this point, the subelement types are unified. If this is successful, then
a new substitution function is returned and is retained and
overridden subsequently. There eventually comes a point where
the types in the term have been unified and we have three things:

\begin{enumerate}

\item
A term which has the structure of the input term, but all the
types have been replaced with extended types.

\item
An extended type of the overall term

\item
A substitution function which is produced by the unifications of
the sub-terms of the tree.

\end{enumerate}

What now remains is to produce a HOL term from this information.
The types of the sub-terms are known as this information is inherent
in the substitution function. This information needs to be used
to type the sub-terms correctly, and to translate the input term
structure to the simpler HOL term structure.

The translation is made easy because the programming interfaces
for constructing HOL terms are available to us. The partially
inferred term needs to be broken up and re-constructed using the
programmer's interface utilities to generate a correctly typed HOL
term.

A Constant in the input term may be an alias for a term. The resolution
of the alias need not take place until the production of the HOL term.
If the alias were to be resolved at an earlier point during
type inference, an additional overhead of processing the consequence
would result, but with no apparent benefit. Also we want
the best possible idea of the type of the constant
in order to do alias resolution. It is easy for the
type checker to resolve aliases since an interface is already available
from \cite{DS/FMU/IED/DTD020} which is ideally suited for the
context in which we want to resolve aliases.


In summary, the key functions of the type inference mechanism are:

\begin{enumerate}

\item
Type extension and unification

\item
Translation of an input term to a HOL term

\item
Resolution of aliases

\end{enumerate}

It is intended that the type inference mechanism is called by the
parser interface described in \cite{DS/FMU/IED/DTD022}, for producing
HOL terms.

\subsection{Environment Management}

\subsubsection{Context}

All type inference is done in a context of constants and variables.
All constants are defined in the symbol table. The context for
variables is called the type inference context $ti\_context$.
Variables which are required to have types which persist over
possibly several type inferences can be placed in the $ti\_context$.
This means that when such a variable appears in a term, it need not be
explicitly typed, since its type can be determined by the $ti\_context$.
This results in better usability, particularly for terms which are
supplied as an argument to a tactic such as $EXISTS\_TAC$ (when using
the subgoal package).
Two functions are supplied to support the type inference context,
vis. $set\_ti\_context$ which sets a context, and $get\_ti\_context$ which
gets a context. A description of these functions can be found in
section \ref{SIGNATURE}.

\subsubsection{Environment}

In practice, as variables and constants are put into scope, an environment
is constructed. This is a symbol table which maps a name onto
information about the object to which the name refers, the
nature of information depending on the type of object (eg. constant or
variable). An initial environment is set up by the type
inferrer as a preliminary action. This comprises constants from the
HOL symbol table (accessible by the functions described
in \cite{DS/FMU/IED/DTD020}), typed variables set up in the context,
and all the free variables in the
term to be type-inferred. When a new variable is brought into scope
then the environment is grown. If the environment is viewed as
a function, then growing the environment would correspond to
functional override.

\subsection{Identifying Free Variables}

It is necessary for the type inference mechanism to be able to identify
the free variables of a term. This can be achieved easily by
traversing the term and noting the variables/constants in the term.
A variable and a constant are differentiated by their absence or
otherwise in the HOL symbol table.

A similar requirement is to locate free variables in an term whose
types have been extended. Such variables need to be associated
with names such that subsequent display of a HOL term with free
types would contain type variable names starting at ``\'\ a''
counting upwards. The naming convention for type variables is
described in section \ref{FVNAMES}.

\subsection{Handling and Displaying Errors}

Errors will be handled by the generic error handler described
in \cite{DS/FMU/IED/DTD002}. It is highly desirable that the
error messages produced by the type inference mechanism and
the lexical analyser/parser be uniform in their presentation
of diagnostic information. The error
message formats have been adapted from \cite{DS/FMU/IED/DTD019}.

Errors found during type inference can be either due to there being
a problem with the input, these are known as {\bf failures}; and errors
due to an unforseen design fault, known from hereon as {\bf errors}.

When a failure occurs, then the sub-term which contains the error
is printed out. If the failure is caused by a failure to unify two types,
then some indication of the types causing the failure
should be printed.

It is debatable how much context information should be printed
out to aid the user in locating the source of the failure. If two
much of the term is printed, then it may be ambiguous as to which
occurrence of a sub-term caused the failure. Likewise, the same problem
may arise if too little of the term is printed.

Further changes in this area are envisaged when the ICL HOL pretty
printer is available which will permit terms to be displayed upto
a configurable depth.

\subsection{Production of a Term with Extended Types}

The mapping from types of type TY to type of type EXTYPE is
a composition of two functions, one of which takes a TY onto a TYPE, the
other takes a TYPE onto an EXTYPE. The first task in producing
extended types is to expand all the type abbreviations in the term.
This is done as part of the function taking a TY onto a TYPE.
The algorithm for expanding type abbreviations non-recursively is
supplied in the symbol table package. Types are expanding recursively
within the function mapping TYs to TYPEs making use of the
symbol table's supporting function.

The conversions of types to extended types within a term can be
done by traversing the term carrying out the replacement where
appropriate. Clearly, there is a performance issue here, and
it is desirable to economize on the number of traversals. This
conversion can be done at the same time as the conversion of a
term into its corresponding HOL equivalent --- the last stage
of type inference.

\subsection{Conversion of a Term to a HOL Term}

The conversion of a term to a HOL term is done when all the types
have been inferred, and a substitution tree has been produced.
The availability of the interfaces for making HOL terms means that
a single traversal of the term (containing extended types) is
sufficient to convert sub-terms to sub-terms of a HOL term.
Unknown type variables found at this stage are converted into
HOL type variables which are identified as described in section
\ref{FVNAMES}

\subsubsection{Unknown Types} \label{FVNAMES}

Terms which contain types which are not known are assigned type
variables. These are identified by the names 'a, 'b etc. upto
'z. Further names are produced if necessary of the
following form: '27, '28 ... and so on. The numbering
starts at 27 giving the impression that the numbers 1 to 26 were
used for a to z (although never appearing as such).

\subsection{The Type Inference Mechanism Glue}

The type inference mechanism glue is a
functional composition of the components of the mechanism described
in this document. The mechanism is in fact a function which maps
a term of type TY TM onto a HOL term of type TERM. The function
is called $make\_term$ and is described in section \ref{SIGNATURE}.

\section{RULES OF INFERENCE} \label{INFRULES}
\begin{FruleLeftJustify}
The rules of inference are divided into those concerned with
types and those concerned with terms. These are further subdivided
into rules which correspond to each production rule of the grammar
defining TY and TM.

\subsection{Types}

The inference rules for types are introduced first.

\subsubsection{Atomic Types}

Type atoms whose first character is ``\'\ '' will be
assumed by the type inferrer to denote type variables.

=RULE
First of s is the character '
É
É
ENV … TyAtom s ‹ mk_vartype s
=TEX

Type atoms whose first character is not ``\'\ '' will
be use to construct an actual type, whose name is
the parameter to $TyAtom$.

=RULE
First of s is NOT the character '
É
É
ENV … TyAtom s ‹ mk_ctype (s, nil)
=TEX

\subsubsection{Compound Types}

Compound types will comprise a list of types, an identifier
and a fixity. The fixity of the type is irrelevant to
the process of type inference and can be ignored.
Given that there is a mapping from the type list to a
list of actual types, the inference rule for compound
types is straightforward. An actual type is constructed
with the identifier given as part of the compound type, and
the type list as given by the mapping for type lists.
In the actual implementation, this will comprise a recursive
call to the type inference code for types. For the
moment, the representation below captures the essence.

=RULE
É
ENV … tyl ‹ TYL:TYPE list
É
ENV … TyCompound (tyl, s, _)
	‹ mk_ctype (s, TYL)
=TEX

\subsubsection{Antiquoted Types}

An antiquoted type simply yields the type which is
a parameter to the value constructor $TyAq$.

=RULE
É
É
ENV … TyAq þ ‹ þ
=TEX

\subsection{Terms}

The inference rules for terms are now introduced. Each
rule corresponds to a BNF production rule in the grammar
describing a term produced by the parser (of type ``\'\ a'' TM).

\subsubsection{Binders}

Ultimately, all binding constructors are represented as
lambda abstractions. This case is therefore much simpler, and
we introduce this rule first.

The bound variables and
the body assume corresponding types to those given in the
input TM by some uniform mapping. The bound variables are brought into the scope of the body of the
construction by extending the environment. 

=RULE
binding constructor is ""
É
ENV … t° ‹ T°:þ°;

ENV •
{n — VarInfo þ' | mk_var(n, þ')  frees T°}
	… t¬ ‹ T¬:þ¬
É
ENV … Binder ("", t°, t¬)
	‹ mk_(T°:þ°, T¬:þ¬)
=TEX

For general binding constructions, the type of each element in
the input is uniformly mapped to a TYPE. The binder is itself typed
with free types, and subsequently unified.  The type of the
bound variables are put in the scope of the body.
=RULE
binding constructor is  NOT ""
É
ENV … t° ‹ T°:þ°;

ENV … TmAtom (Id s)
	‹ mk_const (s, (þ° ‹ þ¬) ‹ þ®);

ENV •
{n — VarInfo þ' | mk_var(n, þ')  frees T°}
	… t¬ ‹ T¬:þ¬
É
ENV … Binder (TmAtom (Id s), t°, t¬)
  ‹ (mk_app(mk_const (s, (þ° ‹ þ¬) ‹ þ®),
    mk_(T°:þ°,T¬:þ¬))):þ®
=TEX

\subsubsection{Let}

The variable structures of the LHS of each clause in the
let statement are put in the scope of the body of the let
statement. The type of the overall term is the type of the
body of the term.
=RULE
V°, V¬ ... are variable structures
É
ENV … v° ‹ V°:þ°; ENV … v¬ ‹ V¬:þ¬; ...
	... ENV … vÕ ‹ VÕ:þÕ;

ENV … t° ‹ T°:þ°; ENV … t¬ ‹ T¬:þ¬; ...
	... ENV … tÕ ‹ TÕ:þÕ;

ENV • { n — VarInfo þ' | mk_var(n, þ')
   {frees V¸ | 1 ž c ž s}} … tm ‹ TM:þ;
É
ENV … Let ([(v°, t°), (v¬, t¬), ..., (vÕ, tÕ)], tm)
  ‹ (mk_let ([(V°:þ°, T°:þ°),
	(V¬:þ¬, T¬:þ¬), ...
	    ... ,(VÕ:þÕ,TÕ:þÕ)],TM:þ)):þ
=TEX

\subsubsection{Conditional Terms}

The condition must unify to a bool, and the consequences and the
type of the overall term must all unify to the same type.

=RULE
É
ENV … c ‹ C:BOOL; ENV … t° ‹ T°:þ;
ENV … t¬ ‹ T¬:þ
É
ENV … Cond (c, t°, t¬)
	‹ (mk_if (C:BOOL, T°:þ, T¬:þ)):þ
=TEX


\subsubsection{Function Application}

The type of the function applied must have a domain type equal to
that to which the function is applied. The type of the overall
term is the type of object which the function yields.

=RULE
É
ENV … t° ‹ T°:(þ° ‹ þ¬);
ENV … t¬ ‹ T¬:þ°
É
ENV … App (t°, t¬, _)
  ‹ (mk_app(T°:(þ° ‹ þ¬), T¬:þ°)):þ¬
=TEX

\subsubsection{TmTyped}

This rule constrains the explicit typing of a term to be unified
with the term.

=RULE
É
ENV … t° ‹ T°:þ;
ENV … ty ‹ þ
É
ENV … TmTyped (t°, ty) ‹ T°:þ
=TEX

\subsubsection{TmAq}

The type of an antiquoted term is assumed to be that of the term.
No explicit checking is done.

=RULE
É
É
ENV … TmAq term:þ ‹ term:þ
=TEX

\subsubsection{SetDisplay}

Each element in the set must have the same type $þ$. The overall set
has the type $þSET$
.
=RULE
É
ENV … t° ‹ T°:þ; ENV … t¬ ‹ T¬:þ; ...
	... ENV … tÕ ‹ TÕ:þ
É
ENV … SetDisplay ([t°, t¬, ..., tÕ])
  ‹ (mk_enum_set ([T°, T¬, ..., TÕ])):þSET
=TEX

\subsubsection{SetComprehension}

The bound variable in a set comprehension is brought into the
scope of the body of the comprehension. The type of the overall
expression is that of the bound variables

=RULE
É
ENV … t° ‹ T°:þ;

ENV •
{n — VarInfo þ' | mk_var(n, þ')  frees T°}
	… t¬ ‹ T¬:þ¬
É
ENV … SetComprehension (t°, t¬)
	‹ (mk_set_comp (T°:þ, T¬:BOOL)):þSET
=TEX

\subsubsection{ListDisplay}

Each element in the list must have the same type $þ$. The overall list
has the type $þLIST$

=RULE
É
ENV … t° ‹ T°:þ; ENV … t¬ ‹ T¬:þ; ...
	... ENV … tÕ ‹ TÕ:þ
É
ENV … ListDisplay ([t°, t¬, ..., tÕ])
  ‹ (mk_list ([T°, T¬, ..., TÕ])):þLIST
=TEX

\subsubsection{Identifiers}

An identifier whose symbol is present in the symbol table will assume
the type corresponding to the symbol table entry.

=RULE
þ is an instance of þ'
É
É
ENV • {s — ConstInfo þ'}
	… Id s ‹ (mk_const(s, þ)):þ
=TEX

An identifier whose symbol is recognised in the environment denotes a
variable in scope. The type of the variable is given by the environment.
=RULE
É
É
ENV • {s — VarInfo þ}
	… Id s ‹ (mk_var(s, þ)):þ
=TEX

An identifier which is an alias is resolved as follows:

=RULE
É
É
ENV • {s — Alias þ}
	… Id s ‹ (resolve_alias (s, þ)):þ
=TEX

An identifier whose symbol is not in the symbol table denotes a
variable, and is given a free type.

=RULE
þ is any type
É
É
{s} › ENV … Id s ‹ (mk_var(s, þ)):þ
=TEX


\subsubsection{Literals}

Characters, strings and numbers are represented in HOL in distinct
ways. The inference rules for converting literals for these types
are straightforward. A character literal is mapped onto a character
constant, a string literal to a string constant and a numeric literal
to a numeric constant as follows:

=RULE
É
É
ENV … CharLit s
	‹ (mk_char c):CHAR
=TEX

=RULE
É
É
ENV … StringLit s
	‹ (mk_string s):STRING
=TEX

=RULE
É
É
ENV … NumLit i
	‹ (mk_†(i, †)):†
=TEX


\end{FruleLeftJustify}

\section{THE SIGNATURE $TypeInference$} \label{SIGNATURE}

The signature $TypeInference$ is the interface to the type inference
mechanism, and it provides the outside world with five interfaces.
\begin{description}

\item[set\_ti\_context]
This sets a context which maps variable names onto types. It is
used when it is required that types of variables persist over several
type inferences.

\item[get\_ti\_context]
This gets the type inference context previously set by a call
to $set\_ti\_context$.

\item[is\_varstruct]
This determines whether a term is a variable structure. A variable
structure is either a single variable or a tuple. This sort of thing
is useful to know, and cannot be determined from the grammar of
a parsed term alone.

\item[ty\_to\_type]
This converts a type as produced by the parser into a HOL type.

\item[make\_term]
This interface invokes the type inference mechanism and produces
a type-checked and inferred HOL term from the term delivered by the
parser.

\end{description}

=DOC
signature âTypeInferenceá = sig
local
	open Parser;
in
=DESCRIBE
This is the signature for the structure TypeInference.
=ENDDOC

=DOC
val âset_ti_contextá : TERM list -> unit
=DESCRIBE
The $set\_ti\_context$ function sets a context in which type inference
takes place. The context comprises a set of relations of type variable
names with types. When type-inferring the types of a term which contains
variables in the context, the type of the variable in the context is
used. This means that a term which contains an untyped variable
can have its type inferred from the context.

The term list supplied as an argument to the function is a list
of terms. All the free variables in each term are placed in the
context with their corresponding types.

If any two free variables in the list of terms have the same name
but different types, then a failure message is printed and the type
inference context remains unchanged.
=FAILURE
16040	Variables with distinct types have the same name
=ENDDOC

=DOC
val âget_ti_contextá : unit -> TERM list
=DESCRIBE
The $get\_ti\_context$ function gets context information previously
set by a call to $set\_ti\_context$. The context is returned as
a list of terms. Each term comprises only a typed variable. The
context is the mapping from the name of a variable to its
type. The type of each term can be readily established by a call
to the function $type\_of$.
=ENDDOC

=DOC
val âis_varstructá : 'a TM -> bool
=DESCRIBE
is\_varstruct determines whether or not a term (of type TM)
is a variable structure.
=ENDDOC
=DOC
val âty_to_typeá : TY -> TYPE
=DESCRIBE
This converts a type (of type TY) into a HOL type of type TYPE.
=FAILURE
16030	Type constructor ?0 expects ?1 argument?2 not ?3 argument?4
16060	Type constructor or abbreviation ?0 is not in scope
=ENDDOC
=DOC
val âmake_termá : TY TM -> TERM
=DESCRIBE
This interface invokes the type inference mechanism and produces
a type-checked and inferred HOL term from term delivered from the
parser.
=FAILURE
16000	Type checking error in quotation
16001	**** TYPE CHECKING ERROR  ****
16002	Type error in »?0¼
16010	»?0¼ is not a valid variable or varstruct
16020	Cannot unify »:?0¼ with »:?1¼
16021	Cannot unify list of types »?0¼
16022	(?0)
16050	The following types were inferred for the free variables in the term:
16055	»?0:?1¼
16100	DESIGN ERROR 
16101	DESIGN ERROR (?0)
=ENDDOC
=DOC
(* âti_verboseá  - boolean flag declared by new_flag, default: false *)
=DESCRIBE
If set, then type checking failure causes a list
of free variables in the sub-term which failed to type-check,
and their associated types to be printed.
If it is not set, then printing of this information is suppressed.
=ENDDOC

=SML
end
end; (* of signature TypeInference *)
=TEX

\section{TEST POLICY}
The tests should follow the standards and guidelines
laid down in \cite{DS/FMU/IED/PLN008}.

\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}

