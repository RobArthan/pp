=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FORMAL METHODS UNIT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Theory of Lists}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP039}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{The theory of lists for ICL HOL is implemented.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue 1.1-1.8] Initial drafts.
\item [Issue 1.9 (15 October 1991)] Amended in accordance
with the changes of the names of theorems in the theory
of numbers.
\end{description}
\subsection{Changes forecast}
Under development.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains parts of the ICL HOL
proof development system called for in \cite{DS/FMU/IED/HLD011}.
\subsection{Introduction}

\section{ABSTRACTION AND REPRESENTATION FUNCTIONS}

Before we prove this we make sure we are in the right
theory.
	(Éxé IsListRep x ä (Éhéåcons h x = nil)) Ä
=SML
structure ‚ListTheory· : ListTheory = struct
=TEX
=SML
val _ = open_theory "Ü";
val _ = new_theory "list";
=TEX
Next lemma is required.
=SML
val ‚lt_ä_lt_plus_1_thm· = (
push_goal([],ªÉi m né  m < n ä m < n + iº);
a(strip_tac THEN induction_tacªi:Üº);
(* *** Goal "1" *** *)
a(rewrite_tac[plus_clauses]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o list_simple_É_elim
	[ªm':Üº,ªn:Üº]));
a(DROP_ASMS_T (MAP_EVERY ante_tac) THEN rewrite_tac
	[lt_def,le_def,plus_assoc_thm1]THEN REPEAT strip_tac);
a(simple_Ñ_tacªi''+1º);
a(asm_rewrite_tac[plus_assoc_thm1]);
pop_thm()
);
=TEX
=SML
val ‚lt_ä_å_lt_thm· = (
push_goal ([],ªÉ m né m < n ä å n < m + 1º);
a(rewrite_tac[lt_def,le_def]);
a(REPEAT strip_tac);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(rewrite_tac[plus_assoc_thm]);
a(rewrite_tac[plus_clauses]);
pop_thm()
);
=TEX
=SML
val ‚is_list_rep_thm· = (
push_goal ([],ªÑ IsListRep:((Üã'a)âÜ)ãBOOL é
Ñ nil:(Üã'a)âÜéÑ cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ) é
	(IsListRep nil) Ä
	(ÉxéIsListRep x
		ä (Éh:'aéåcons h x = nil)) Ä
	(Éx yéIsListRep x Ä IsListRep y
		ä (Éa bé cons a x = cons b y
			Ç (a=b Ä x=y))) Ä
	(ÉxéIsListRep x
		ä (Éh:'aéIsListRep (cons h x))) Ä

	(Ép:((Üã'a)âÜ)ãBOOL é p nil Ä
		(Émé p m ä (Éhé p (cons h m)))
			ä (Éné IsListRep n ä p n))
º);
a(simple_Ñ_tac ªçrepéÑféÑné
	rep=((çm:Üé(if m<n then (f:Üã'a) m
			else (áx:'aéT))),n:Ü)º);
a(rewrite_tac[]);
a(MAP_EVERY simple_Ñ_tac [
	ª(çm:ÜéáeéT),0:Üº,
	ªçh:'aéçt:(Üã'a)âÜé((çm:Üé
		if m = Snd t then h
		else ((Fst t)m)),
			(Snd t)+1)º]);
a(rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(MAP_EVERY simple_Ñ_tac [ªf:Üã'aº,ª0º]);
a(rewrite_tac[lt_clauses]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[pair_clauses] THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN rewrite_tac[plus_clauses]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac);
a(DROP_ASMS_T rewrite_tac);
a(rewrite_tac[pair_clauses]);
a(REPEAT strip_tac);
a(lemma_tac ªn:Ü=n'º);
(* *** Goal "3.1" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[plus_clauses]);
(* *** Goal "3.2" *** *)
a(DROP_NTH_ASM_T 3 (ante_tac o rewrite_rule[ext_thm])
	THEN asm_rewrite_tac[]);
a(strip_tac THEN POP_ASM_T (ante_tac o simple_É_elimªn':Üº)
	THEN rewrite_tac[]);
(* *** Goal "4" *** *)
a(POP_ASM_T ante_tac);
a(DROP_ASMS_T rewrite_tac);
a(rewrite_tac[pair_clauses]);
a(REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(lemma_tac ªn:Ü=n'º);
(* *** Goal "4.1.1" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[plus_clauses]);
(* *** Goal "4.1.2" *** *)
a(DROP_NTH_ASM_T 3 (ante_tac o rewrite_rule[ext_thm])
	THEN asm_rewrite_tac[]);
a(rewrite_tac[ext_thm] THEN REPEAT strip_tac);
a(POP_ASM_T (ante_tac o simple_É_elimªx:Üº));
a(cases_tacªx:Ü=n'º THEN asm_rewrite_tac[lt_clauses]);
(* *** Goal "5" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "6" *** *)
a(MAP_EVERY simple_Ñ_tac [ª(çméif m=n then h else f m):Üã'aº,ªn+1:Üº]);
a(DROP_ASMS_T (fn x => asm_rewrite_tac (pair_clauses::x)));
a(rewrite_tac[ext_thm]);
a(strip_tac);
a(cases_tacªx:Ü=nº THEN asm_rewrite_tac[lt_clauses]);
a(lemma_tacªn < n+1º);
(* *** Goal "6.1" *** *)
a(rewrite_tac[lt_clauses]);
(* *** Goal "6.2" *** *)
a(cases_tacªx<nº THEN asm_rewrite_tac[]);
(* *** Goal "6.2.1" *** *)
a(strip_asm_tac(list_simple_É_elim[
	ª1º,ªx:Üº,ªn:Üº]lt_ä_lt_plus_1_thm));
a(asm_rewrite_tac[]);
(* *** Goal "6.2.2" *** *)
a(LEMMA_T ªåx < n + 1º rewrite_thm_tac);
(* Lemma proves the goal, so only lemma to do *)
a(LEMMA_T ªn < xº (fn th => strip_asm_tac(
	simple_ä_match_mp_rule lt_ä_å_lt_thm th)));
(* Lemma proves the goal, so only lemma to do *)
a(strip_asm_tac (list_simple_É_elim[ªx:Üº, ªn:Üº]lt_cases_thm));
(* *** Goal "7" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(induction_tacªn'º);
(* *** Goal "7.1" *** *)
a(asm_rewrite_tac[lt_clauses]);
(* *** Goal "7.2" *** *)
a(DROP_NTH_ASM_T 2 
	(strip_asm_tac o rewrite_rule[pair_clauses] o
	simple_É_elimª((ç m'é if m' < n' then f m' else á xé T), n')º));
a(LEMMA_Tª	(ç m'é if m' < n' + 1 then f m' else á xé T)
	=	(ç m'é if m' = n' then f n' else if m' < n' then f m' else á xé T)º
	asm_rewrite_thm_tac);
(* Lemma proves the goal, so only lemma to do *)
a(rewrite_tac[ext_thm]);
a(strip_tac THEN cases_tacªx=n'º);
(* *** Goal "7.2.1" *** *)
a(asm_rewrite_tac[lt_clauses]);
(* *** Goal "7.2.2" *** *)
a(asm_rewrite_tac[]);
a(cases_tacªx<n'º THEN asm_rewrite_tac[]);
(* *** Goal "7.2.2.1" *** *)
a(strip_asm_tac (list_simple_É_elim[ª1º,ªxº,ªn'º]
	lt_ä_lt_plus_1_thm));
a(asm_rewrite_tac[]);
(* *** Goal "7.2.2.2" *** *)
a(LEMMA_T ªå x < n' + 1º rewrite_thm_tac);
(* Lemma proves the goal, so only lemma to do *)
a(strip_asm_tac (list_simple_É_elim[ªxº,ªn'º]lt_cases_thm));
a(strip_asm_tac (list_simple_É_elim[ªn'º,ªxº]
	lt_ä_å_lt_thm));
pop_thm()
);
=TEX
=SML
val ‚is_list_rep_def· = new_specification(["IsListRep"],1,is_list_rep_thm);
=TEX
In order to use IsListRep, to define the new type,
we need to show that the subset of representation
type which it determines is non-empty.
=SML
val ‚list_Ñ_thm· = (
push_goal([],ªÑx:(Üã'a)âÜ é IsListRep xº);
a(strip_asm_tac is_list_rep_def);
a(simple_Ñ_tacªnil:(Üã'a)âÜº THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
Now we can introduce the new type:
=SML
val ‚list_def· = new_type_defn("LIST","LIST",["'a"],list_Ñ_thm);
=TEX
=SML
val ‚nil_cons_thm· = (
push_goal ([],ª
Ñ Nil:'a LIST; Cons:'aã'a LISTã'a LIST é
	(É x : 'a; list:'a LIST é åCons x list = Nil) Ä
	(É x1 x2 : 'a; list1 list2 : 'a LIST é
		Cons x1 list1 = Cons x2 list2
			Ç (x1=x2 Ä list1=list2)) Ä
	(Ép:'a LISTãBOOL é p Nil Ä
		(Élist:'a LISTé p list ä (Éxé p (Cons x list)))
			ä (Élisté p list))
º);
a(strip_asm_tac (simple_ä_match_mp_rule type_lemmas_thm list_def));
a(strip_asm_tac (is_list_rep_def));
a(simple_Ñ_tac ª(abs:((Üã'a)âÜ)ã'a LIST)nilº);
a(simple_Ñ_tac ªçx:'aéçlist:'a LISTé
(abs:((Üã'a)âÜ)ã'a LIST)
	(cons x ((rep:'a LISTã((Üã'a)âÜ)) list))º);
a(rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac ªIsListRep((rep:'a LISTã((Üã'a)âÜ))list)º
	THEN_LIST[asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so only one sub-goal *)
a(lemma_tac ªIsListRep((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x 
	((rep:'a LISTã((Üã'a)âÜ)) list))º);
(* *** Goal "1.1" *** *)
a(DROP_NTH_ASM_T 3 (ante_tac o simple_É_elimª(rep:'a LISTã((Üã'a)âÜ))listº) THEN
	REPEAT strip_tac);
a(asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(GET_NTH_ASM_T 6 (strip_asm_tac o simple_É_elim
	ª(rep:'a LISTã((Üã'a)âÜ))listº));
a(POP_ASM_T (strip_asm_tac o simple_É_elimªx:'aº));
a(c_contr_tac);
a(lemma_tac ª(rep:'a LISTã((Üã'a)âÜ))
	((abs:((Üã'a)âÜ)ã'a LIST)
	((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x (rep list)))
	= rep (abs nil)º);
(* *** Goal "1.2.1" *** *)
a(POP_ASM_T rewrite_thm_tac);
(* *** Goal "1.2.2" *** *)
a(POP_ASM_T ante_tac);
a(GET_NTH_ASM_T 10 (strip_asm_tac o simple_É_elim
	ª(cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x 
	((rep:'a LISTã((Üã'a)âÜ)) list)º));
a(GET_NTH_ASM_T 11 (strip_asm_tac o simple_É_elim
	ªnil:(Üã'a)âÜº));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac ªIsListRep((rep:'a LISTã((Üã'a)âÜ))list1)º
	THEN_LIST[asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so only one sub-goal *)
a(lemma_tac ªIsListRep((rep:'a LISTã((Üã'a)âÜ))list2)º
	THEN_LIST[asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so only one sub-goal *)
a(lemma_tac ª(cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x1
	((rep:'a LISTã((Üã'a)âÜ)) list1)
	= cons x2 (rep list2)º);
(* *** Goal "2.1" *** *)
a(lemma_tac ªIsListRep((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x1 
	((rep:'a LISTã((Üã'a)âÜ)) list1))º);
(* *** Goal "2.1.1" *** *)
a(DROP_NTH_ASM_T 5 (ante_tac o simple_É_elimª(rep:'a LISTã((Üã'a)âÜ))list1º) THEN
	REPEAT strip_tac);
a(asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a(lemma_tac ªIsListRep((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x2 
	((rep:'a LISTã((Üã'a)âÜ)) list2))º);
(* *** Goal "2.1.2.1" *** *)
a(DROP_NTH_ASM_T 6 (ante_tac o simple_É_elimª(rep:'a LISTã((Üã'a)âÜ))list2º) THEN
	REPEAT strip_tac);
a(asm_rewrite_tac[]);
(* *** Goal "2.1.2.2" *** *)
a(GET_NTH_ASM_T 11 (strip_asm_tac o simple_É_elim
	ª(cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x1 
	((rep:'a LISTã((Üã'a)âÜ)) list1)º));
a(GET_NTH_ASM_T 12 (strip_asm_tac o simple_É_elim
	ª(cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x2 
	((rep:'a LISTã((Üã'a)âÜ)) list2)º));
a(lemma_tac ª(rep:'a LISTã((Üã'a)âÜ))
	((abs:((Üã'a)âÜ)ã'a LIST)
	((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x1 (rep list1)))
	= rep (abs (cons x2 (rep list2)))º);
(* *** Goal "2.1.2.2.1" *** *)
a(GET_NTH_ASM_T 2 ante_tac);
a(GET_NTH_ASM_T 7 rewrite_thm_tac);
(* *** Goal "2.1.2.2.2" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(GET_NTH_ASM_T 7 (strip_asm_tac o list_simple_É_elim
	[ª(rep:'a LISTã((Üã'a)âÜ))list1º,
	ª(rep:'a LISTã((Üã'a)âÜ))list2º]));
a(POP_ASM_T (strip_asm_tac o list_simple_É_elim
	[ªx1:'aº,ªx2:'aº]));
(* *** Goal "3" *** *)
a(lemma_tac ªIsListRep((rep:'a LISTã((Üã'a)âÜ))list1)º
	THEN_LIST[asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so only one sub-goal *)
a(lemma_tac ªIsListRep((rep:'a LISTã((Üã'a)âÜ))list2)º
	THEN_LIST[asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so only one sub-goal *)
a(lemma_tac ª(cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x1
	((rep:'a LISTã((Üã'a)âÜ)) list1)
	= cons x2 (rep list2)º);
(* *** Goal "3.1" *** *)
a(lemma_tac ªIsListRep((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x1 
	((rep:'a LISTã((Üã'a)âÜ)) list1))º);
(* *** Goal "3.1.1" *** *)
a(DROP_NTH_ASM_T 5 (ante_tac o simple_É_elimª(rep:'a LISTã((Üã'a)âÜ))list1º) THEN
	REPEAT strip_tac);
a(asm_rewrite_tac[]);
(* *** Goal "3.1.2" *** *)
a(lemma_tac ªIsListRep((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x2 
	((rep:'a LISTã((Üã'a)âÜ)) list2))º);
(* *** Goal "3.1.2.1" *** *)
a(DROP_NTH_ASM_T 6 (ante_tac o simple_É_elimª(rep:'a LISTã((Üã'a)âÜ))list2º) THEN
	REPEAT strip_tac);
a(asm_rewrite_tac[]);
(* *** Goal "3.1.2.2" *** *)
a(GET_NTH_ASM_T 11 (strip_asm_tac o simple_É_elim
	ª(cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x1 
	((rep:'a LISTã((Üã'a)âÜ)) list1)º));
a(GET_NTH_ASM_T 12 (strip_asm_tac o simple_É_elim
	ª(cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x2 
	((rep:'a LISTã((Üã'a)âÜ)) list2)º));
a(lemma_tac ª(rep:'a LISTã((Üã'a)âÜ))
	((abs:((Üã'a)âÜ)ã'a LIST)
	((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x1 (rep list1)))
	= rep (abs (cons x2 (rep list2)))º);
(* *** Goal "3.1.2.2.1" *** *)
a(GET_NTH_ASM_T 2 ante_tac);
a(GET_NTH_ASM_T 7 rewrite_thm_tac);
(* *** Goal "3.1.2.2.2" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(GET_NTH_ASM_T 7 (strip_asm_tac o list_simple_É_elim
	[ª(rep:'a LISTã((Üã'a)âÜ))list1º,
	ª(rep:'a LISTã((Üã'a)âÜ))list2º]));
a(POP_ASM_T (strip_asm_tac o list_simple_É_elim
	[ªx1:'aº,ªx2:'aº]));
a(GET_NTH_ASM_T 13 (strip_asm_tac o 
	eq_sym_rule o (simple_É_elimªlist1:'a LISTº)));
a(POP_ASM_T once_rewrite_thm_tac);
a(GET_NTH_ASM_T 13 (strip_asm_tac o 
	eq_sym_rule o (simple_É_elimªlist2:'a LISTº)));
a(POP_ASM_T once_rewrite_thm_tac);
a(POP_ASM_T rewrite_thm_tac);
(* *** Goal "4" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a(lemma_tac ªIsListRep((rep:'a LISTã((Üã'a)âÜ))list)º
	THEN_LIST[asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so only one sub-goal *)
a(lemma_tac ªIsListRep((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x 
	((rep:'a LISTã((Üã'a)âÜ)) list))º);
(* *** Goal "5.1" *** *)
a(DROP_NTH_ASM_T 5 (ante_tac o simple_É_elimª(rep:'a LISTã((Üã'a)âÜ))listº) THEN
	REPEAT strip_tac);
a(asm_rewrite_tac[]);
(* *** Goal "5.2" *** *)
a(lemma_tacªÉlist:((Üã'a)âÜ)éIsListRep list ä IsListRep list Ä
	p((abs:((Üã'a)âÜ)ã'a LIST) list)º);
(* *** Goal "5.2.1" *** *)
a(lemma_tacªÉlist:((Üã'a)âÜ)éIsListRep list Ä
	p((abs:((Üã'a)âÜ)ã'a LIST) list) ä
	IsListRep ((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x
		list) Ä p (abs (cons x list))º);
(* *** Goal "5.2.1.1" *** *)
a(REPEAT strip_tac);
(* *** Goal "5.2.1.1.1" *** *)
a(DROP_NTH_ASM_T 8 (ante_tac o simple_É_elimªlist':((Üã'a)âÜ)º));
a(strip_tac);
a(asm_rewrite_tac[]);
(* 5.2.1.1.2 *)
a(DROP_NTH_ASM_T 5 (ante_tac o simple_É_elimª(abs:((Üã'a)âÜ)ã'a LIST)list'º));
a(asm_rewrite_tac[]);
a(strip_tac THEN POP_ASM_T (ante_tac o simple_É_elimªx:'aº));
a(GET_NTH_ASM_T 2 (undisch_tac o concl) THEN asm_rewrite_tac[]);
a(strip_tac THEN asm_rewrite_tac[]);
(* *** 5.2.1.2 *** *)
a(GET_NTH_ASM_T 6 (ante_tac o simple_É_elim
	ªçaéIsListRep a Ä p((abs:((Üã'a)âÜ)ã'a LIST)a)º) THEN
	rewrite_tac[]);
a(strip_tac);
(* *** 5.2.1.2.1 *** *)
a(c_contr_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN rewrite_tac[]);
a(DROP_NTH_ASM_T 11 (ante_tac o simple_É_elimªm:((Üã'a)âÜ)º));
a(asm_rewrite_tac[]);
a(strip_tac THEN asm_rewrite_tac[]);
(* *** 5.2.1.2.2 *** *)
a(c_contr_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN rewrite_tac[]);
a(DROP_NTH_ASM_T 8 (ante_tac o simple_É_elimª(abs:((Üã'a)âÜ)ã'a LIST)mº));
a(asm_rewrite_tac[]);
a(lemma_tacª((rep:'a LISTã((Üã'a)âÜ))((abs:((Üã'a)âÜ)ã'a LIST)m))=mº);
(* *** 5.2.1.2.2.1 *** *)
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* *** 5.2.1.2.2.2 *** *)
a(asm_rewrite_tac[] THEN strip_tac THEN asm_rewrite_tac[]);
(* *** 5.2.2 *** *)
a(POP_ASM_T (ante_tac o simple_É_elimª(rep:'a LISTã((Üã'a)âÜ))listº));
a(GET_NTH_ASM_T 11 rewrite_thm_tac THEN REPEAT strip_tac);
pop_thm()
);
=TEX
=SML
val ‚nil_cons_def· = new_specification(["Nil","Cons"],2,
	nil_cons_thm);

val ‚å_cons_thm· = Ä_left_elim nil_cons_def;

val ‚one_one_cons_thm· = (Ä_left_elim o Ä_right_elim) nil_cons_def;

val ‚list_induction_thm· = save_thm ("list_induction_thm",
	Ä_right_elim (Ä_right_elim nil_cons_def));

val goal = ([],ªÉx:'aé åCons x thing = thingº):GOAL;
val asms = [];
val conc = ªÉx:'aé åCons x thing = thingº;
val tm = ªthing:'a LISTº;

fun ‚list_induction_tac· (tm : TERM) : TACTIC = (
if not(is_var tm)
then
	term_fail "list_induction_tac" 39000 [tm]
else
let fun aux_tac (gl as (asms, conc)) = (
	let	val abs = mk_simple_ç(tm, conc);

		val pred = (fst o dest_É o concl) list_induction_thm;
		val (tmy, _) = term_match abs pred;
		val lit_inst = inst_type_rule tmy list_induction_thm;
		val thm0 = (conv_rule
				(ONCE_MAP_C (simple_%beta%_conv))
				(simple_É_elim abs lit_inst));
		val thm1 = undisch_rule(conv_rule ((RATOR_C o RAND_C o
			RAND_C o RAND_C)(simple_%alpha%_conv
			(fst(dest_var tm))))thm0);
		val thm2 = simple_É_elim tm thm1;
		val conc' = (hd (hyps thm2));
	in	([(asms, conc')],
		 (fn [th] => prove_asm_rule th thm2
		  | _ => bad_proof "list_induction_tac"))
	end
handle complaint =>
list_divert complaint "list_induction_tac" [
	("term_match",39001,[fn ()=>string_of_term tm,
		fn ()=>string_of_term conc])]
);
in
	aux_tac THEN
	Ä_tac THEN_LIST
	[id_tac, simple_É_tac THEN ä_tac]
end
);

=TEX

\subsection{Definition by Induction}

\paragraph{Principle of Definition by Induction:} Let $X$ be a set, let $z \in X$,
and let $s$ be a function from $X$ to itself, then there exists a unique
function $f$ from $'a$ to $X$ such that $f(Nil) = z$ and
for any $x$ and $list$, $f(Cons x list)=s(f x list)$.

=SML
val ‚list_rec_lemma1· = (
push_goal([],
	ªÉn:'béÉc:'aã'bã'b é Ñr:'a LISTã'bãBOOLé
		r Nil n 
	Ä	(É list xér list x ä
			(Éaé r (Cons a list) (c a x)))
	Ä	Éx:'bér Nil x ä x = nº);
a(REPEAT strip_tac THEN simple_Ñ_tac
	ªç(l:'a LIST)(y:'b)éål=Nil Å (l=Nil Ä y=n)º);
a(rewrite_tac[å_cons_thm]);
pop_thm()
);
=TEX
=SML
val ‚list_rec_lemma2· = (
push_goal([],ªÉlist:'a LISTéÉx:'aé åCons x list = listº);
a(REPEAT strip_tac THEN list_induction_tacªlist:'a LISTº);
(* *** Goal "1" *** *)
a(rewrite_tac[å_cons_thm]);
(* *** Goal "2" *** *)
a(c_contr_tac THEN strip_asm_tac(list_simple_É_elim
	[ªx:'aº,ªx':'aº,ªCons x' listº,ªlist:'a LISTº]one_one_cons_thm));
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val ‚list_rec_lemma3· = (
push_goal([],
	ªÉn:'béÉc:'aã'bã'bé Ék:'a LISTéÑr:'a LISTã'bãBOOLé
		r Nil n
	Ä	(Élist xér list x ä (Éa:'aér(Cons a list)(c a x)))
	Ä	Ñtér k t Ä Éx:'bér k x ä x = tº);
a(REPEAT strip_tac THEN list_induction_tacªk:'a LISTº);
(* *** Goal "1" *** *)
a(strip_asm_tac (all_simple_É_elim list_rec_lemma1) THEN
	simple_Ñ_tacªr:'a LISTã'bãBOOLº);
a(asm_rewrite_tac[] THEN simple_Ñ_tacªn:'bº THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(simple_Ñ_tacªç(i:'a LIST) (y:'b)éif Cons x k = i then
	y = (c:'aã'bã'b) x t else r i yº
	THEN rewrite_tac[å_cons_thm] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(strip_asm_tac (list_simple_É_elim[
	ªx:'aº,ªa:'aº,ªk:'a LISTº, ªlist:'a LISTº]
	one_one_cons_thm));
a(DROP_NTH_ASM_T 4 ante_tac THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(lemma_tac ª(r:'a LISTã'bãBOOL) k x' ä x' = tº THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 6 (strip_asm_tac o list_simple_É_elim
	[ªlist:'a LISTº,ªx':'bº]) THEN asm_rewrite_tac[]);
(* *** Goal "2.3" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[list_rec_lemma2]);
(* *** Goal "2.4" *** *)
a(LEMMA_T ª(r:'a LISTã'bãBOOL)list x'º ante_tac);
(* *** Goal "2.4.1" *** *)
a(DROP_NTH_ASM_T 2 (asm_rewrite_thm_tac o eq_sym_rule));
a(DROP_NTH_ASM_T 5 (strip_asm_tac o list_simple_É_elim[
	ªk:'a LISTº,ªt:'bº]) THEN asm_rewrite_tac[]);
(* *** Goal "2.4.2" *** *)
a(DROP_NTH_ASM_T 6 (strip_asm_tac o list_simple_É_elim
	[ªlist:'a LISTº,ªx':'bº]) THEN asm_rewrite_tac[]);
(* *** Goal "2.5" *** *)
a(strip_asm_tac (list_simple_É_elim[
	ªx:'aº,ªa:'aº,ªk:'a LISTº, ªlist:'a LISTº]
	one_one_cons_thm));
a(DROP_NTH_ASM_T 4 ante_tac THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(lemma_tac ª(r:'a LISTã'bãBOOL) k x' ä x' = tº THEN asm_rewrite_tac[]);
(* *** Goal "2.6" *** *)
a(DROP_NTH_ASM_T 6 (strip_asm_tac o list_simple_É_elim
	[ªlist:'a LISTº,ªx':'bº]) THEN asm_rewrite_tac[]);
(* *** Goal "2.7" *** *)
a(simple_Ñ_tacª(c:'aã'bã'b)x tº THEN REPEAT strip_tac
	THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val ‚list_rec_lemma4· = (
push_goal([],
	ªÉn:'béÉc:'aã'bã'bé Ñr:'a LISTã'bãBOOLé
		r Nil n
	Ä	(Élist xér list x ä (Éa:'aé
			r(Cons a list)(c a x)))
	Ä	(ÉméÑyér m y Ä Éxér m x ä x = y)º);
a(REPEAT strip_tac THEN
  simple_Ñ_tacª(ç(k:'a LIST) (y:'b)é
	(Éqé(q Nil n Ä (Élist xéq list x
		ä (Éaéq(Cons a list)(c a x)))) ä q k y))º);
a(rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 3 (ante_tac o simple_É_elim
	ªq:'a LISTã'bãBOOLº) THEN asm_rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o all_simple_É_elim)
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(list_induction_tac ªm:'a LISTº);
(* *** Goal "2.1" *** *)
a(simple_Ñ_tacªn:'bº THEN REPEAT strip_tac);
a(strip_asm_tac(all_simple_É_elim list_rec_lemma1));
a(DROP_NTH_ASM_T 4 (ante_tac o simple_É_elimªr:'a LISTã'bãBOOLº)
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(strip_tac THEN simple_Ñ_tac ª(c:'aã'bã'b)x yº THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(DROP_NTH_ASM_T 4 (ante_tac o simple_É_elimªq:'a LISTã'bãBOOLº) THEN asm_rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o list_simple_É_elim
	[ªm:'a LISTº,ªy:'bº]) THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a(strip_asm_tac(list_simple_É_elim[ªn:'bº, ªc:'aã'bã'bº, ªCons x mº]list_rec_lemma3));
a(lemma_tac ª(r:'a LISTã'bãBOOL)m yº);
(* *** Goal "2.2.2.1" *** *)
a(DROP_NTH_ASM_T 7 (ante_tac o simple_É_elimªr:'a LISTã'bãBOOLº) THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(lemma_tac ª(r:'a LISTã'bãBOOL)(Cons x m) ((c:'aã'bã'b)x y)º);
(* *** Goal "2.2.2.2.1" *** *)
a(DROP_NTH_ASM_T 4 (strip_asm_tac o list_simple_É_elim[ªm:'a LISTº, ªy:'bº])
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a(lemma_tac ª(r:'a LISTã'bãBOOL)(Cons x m) x'º);
(* *** Goal "2.2.2.2.2.1" *** *)
a(DROP_NTH_ASM_T 7 (ante_tac o simple_É_elimªr:'a LISTã'bãBOOLº)
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.2" *** *)
a(GET_NTH_ASM_T 4 (ante_tac o simple_É_elimªx':'bº));
a(DROP_NTH_ASM_T 4 (ante_tac o simple_É_elimª(c:'aã'bã'b)x yº));
a(strip_tac THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val ‚list_rec_lemma5· = (
push_goal([],
	ªÉn:'béÉc:'aã'bã'bé Ñf:'a LISTã'bé
		f Nil = n
	Ä	Élist:'a LISTéÉa:'aéf(Cons a list) = c a (f list)º);
a(REPEAT strip_tac);
a((strip_asm_tac o all_simple_É_elim) list_rec_lemma4);
a((ante_tac o simple_É_elimªr:'a LISTã'bãBOOLº o
	inst_type_rule[(ª:'a LISTº, ª:'aº)]) rec_lemma5);
a(asm_rewrite_tac [] THEN REPEAT strip_tac);
a(simple_Ñ_tacªf:'a LISTã'bº);
a(strip_tac THEN asm_rewrite_tac[] THEN strip_tac);
a(list_induction_tacªlist:'a LISTº);
(* *** Goal "1" *** *)
a(LEMMA_T ª(f:'a LISTã'b) Nil=nº rewrite_thm_tac);
(* *** Goal "1.1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 3 (strip_asm_tac o list_simple_É_elim
	[ªNilº,ªn:'bº]) THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN LEMMA_T
	ª(f:'a LISTã'b)(Cons x list)=(c:'aã'bã'b) x (f list)º rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 4 (strip_asm_tac o list_simple_É_elim
	[ªCons x listº,ª(c:'aã'bã'b)x (f (list:'a LIST))º]));
(* *** Goal "2.2.1" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a(asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val ‚list_rec_lemma6· = (
push_goal([],
	ªÉn:'béÉc:'aã'bã'a LISTã'bé Ñf:'a LISTã'bé
		f Nil = n
	Ä	Élist:'a LISTéÉa:'aé
			f(Cons a list) = c a (f list)listº);
a(REPEAT strip_tac);
a(strip_asm_tac
	(list_simple_É_elim[ª((n:'b), Nil)º,
	ªç a; ix:'b â 'a LISTé((c a (Fst ix) (Snd ix):'b),
		Cons a (Snd ix))º]
	(inst_type_rule[(ª:'b â 'a LISTº, ª:'bº)] list_rec_lemma5)));
a(simple_Ñ_tac ªçiéFst((f:'a LISTã('b â 'a LIST)) i)º);
a(GET_NTH_ASM_T 2 (fn th=> rewrite_tac[pair_clauses, th]));
a(strip_tac THEN list_induction_tacªlist:'a LISTº);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[pair_clauses]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[pair_clauses]);
a(LEMMA_T ªÉkéSnd((f:'a LISTã('b â 'a LIST))k) = kº rewrite_thm_tac);
a(strip_tac THEN list_induction_tacªk:'a LISTº THEN asm_rewrite_tac[pair_clauses]);
pop_thm()
);
=TEX
The uniqueness part of the primitive recursion theorem is
straightforward:
=SML
val ‚list_rec_lemma7· = (
push_goal([],
	ªÉn:'béÉc:'aã'bã'a LISTã'bé Éf g:'a LISTã'bé
	(	(	f Nil = n
		Ä	Élist:'a LISTéÉa:'aé
			f(Cons a list) = c a (f list) list)
		Ä (	g Nil = n
		Ä	Élist:'a LISTéÉa:'aé
			g(Cons a list) = c a (g list) list))
	ä	f = gº);
a(REPEAT strip_tac THEN pure_once_rewrite_tac[ext_thm]);
a(strip_tac THEN list_induction_tacªx:'a LISTº THEN asm_rewrite_tac[]);
pop_thm()
);
=TEX
=SML
val ‚list_prim_rec_thm· = save_thm("list_prim_rec_thm", (
push_goal([],
	ªÉn:'béÉc:'aã'bã'a LISTã'bé Ñ%down%1f:'a LISTã'bé
		f Nil = n
	Ä	Élist:'a LISTéÉa:'aé
			f(Cons a list) = c a (f list) listº);
a(REPEAT strip_tac THEN conv_tac simple_Ñ%down%1_conv);
a(strip_asm_tac(all_simple_É_elim list_rec_lemma6) THEN simple_Ñ_tacªf:'a LISTã'bº);
a(asm_rewrite_tac[]);
a(REPEAT strip_tac THEN
	ante_tac (list_simple_É_elim[ªn:'bº, ªc:'aã'bã'a LISTã'bº, ªf:'a LISTã'bº, ªx:'a LISTã'bº]list_rec_lemma7));
a(asm_rewrite_tac[] THEN ä_T (accept_tac o eq_sym_rule));
pop_thm()
));
=TEX
\subsection{Functions for Use with Lists}
=SML
val ‚length_def· = new_specification(["Length"],1, (
push_goal([],
ªÑLength:'a LISTãÜ é
	Length (Nil:'a LIST) = 0 Ä
	É h:'a; list:'a LISTé
		Length (Cons h list) = Length list + 1º);

a(strip_asm_tac((list_simple_É_elim
	[ª0º, ªça:'a; b:Ü; c:'a LISTé b + 1º])
	(inst_type_rule[(ª:Üº, ª:'bº)]list_prim_rec_thm)));
a(simple_Ñ_tacªf:'a LISTãÜº);
a(asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val ‚hd_def· = new_specification(["Hd"], 1, (
push_goal([],
ªÑHd:'a LISTã'aé
	Éh:'a; list:'a LISTé Hd (Cons h list) = hº);
a(strip_asm_tac((list_simple_É_elim
	[ªx:'aº, ªça:'a; b:'a; c:'a LISTé aº])
	(inst_type_rule[(ª:'aº, ª:'bº)]list_prim_rec_thm)));
a(simple_Ñ_tacªfº);
a(asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val ‚tl_def· = new_specification(["Tl"], 1, (
push_goal([],
ªÑTl:'a LISTã'a LISTé
	Éh:'a; list:'a LISTé Tl (Cons h list) = listº);
a(strip_asm_tac((list_simple_É_elim
	[ªx:'a LISTº, ªça:'a; b:'a LIST; c:'a LISTé cº])
	(inst_type_rule[(ª:'a LISTº, ª:'bº)]list_prim_rec_thm)));
a(simple_Ñ_tacªfº);
a(asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val ‚append_def· = new_specification (["Append"], 1, (
push_goal([],
ªÑAppend:'a LISTã'a LISTã'a LIST é
	(Élist:'a LISTé Append Nil list = list) Ä
	(Éh:'a; list:'a LIST; list':'a LISTé
	  Append (Cons h list) list' = Cons h (Append list list'))º);
a(strip_asm_tac((list_simple_É_elim
	[ªçlist:'a LISTélistº,
		ªça:'a; b:'a LISTã'a LIST; c:'a LISTé
			çlistéCons a (b list)º])
	(inst_type_rule[(ª:'a LISTã'a LISTº, ª:'bº)]list_prim_rec_thm)));
a(simple_Ñ_tacªfº);
a(asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val unit = declare_alias ("@", ªAppendº);
val unit = declare_infix (300, "@");
=TEX
=SML
val ‚map_def· = new_specification (["Map"], 1, (
push_goal([],
ªÑMap: ('aã'b)ã'a LISTã'b LIST é
	(Ég:'aã'bé Map g Nil = Nil) Ä
	(Éh:'a; g:'aã'b; list:'a LISTé
	  Map g (Cons h list) = Cons (g h) (Map g list))º);
a(strip_asm_tac((list_simple_É_elim
	[ª(çgéNil):('aã'b)ã 'b LISTº,
	ªça:'a; b:('aã'b)ã'b LIST; c:'a LISTé
	    çgé Cons (g a) (b g)º])
	(inst_type_rule[(ª:('aã'b)ã'b LISTº, ª:'bº)]list_prim_rec_thm)));
a(simple_Ñ_tacª((çf a bé f b a)f):('aã'b)ã'a LISTã'b LISTº);
a(asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val ‚fold_def· = new_specification (["Fold"], 1, (
push_goal([],
ªÑFold: ('aã'bã'b)ã'a LISTã'bã'bé
	(Ég:'aã'bã'b; x:'bé Fold g Nil x = x) Ä
	(Éh:'a; g:'aã'bã'b; x:'b; list:'a LISTé
		Fold g (Cons h list) x = g h (Fold g list x))º);
a(strip_asm_tac((list_simple_É_elim
	[ª(çg xéx):('aã'bã'b)ã'bã'bº,
	ªça:'a; b:('aã'bã'b)ã'bã'b; c:'a LISTé
	    çg xé g a (b g x)º])
	(inst_type_rule[(ª:('aã'bã'b)ã'bã'bº, ª:'bº)]list_prim_rec_thm)));
a(simple_Ñ_tacª((çf a b cé f b a c)f):('aã'bã'b)ã'a LISTã'bã'bº);
a(asm_rewrite_tac[]);
pop_thm()
));
=TEX
=SML
val ‚split_def· = new_specification (["Split"], 1, (
push_goal([],
ªÑSplit:('aâ'b)LISTã('a LISTâ'b LIST)é
	Split (Nil:('aâ'b)LIST) = (Nil,Nil) Ä
	(É list:('aâ'b) LIST; h1:'a; h2:'bé
	 Split (Cons (h1,h2) list) =
		(Cons h1 (Fst(Split list)),
			Cons h2 (Snd(Split list))))
º);
a(strip_asm_tac((list_simple_É_elim
	[ª(Nil,Nil)º,
	ªç(a1,a2):'aâ'b; b:'a LISTâ'b LIST; c:('aâ'b) LISTé
	    (Cons a1 (Fst b), Cons a2 (Snd b))º])
	(inst_type_rule[(ª:'aâ'bº, ª:'aº),
			(ª:'a LISTâ'b LISTº, ª:'bº)]list_prim_rec_thm)));
a(simple_Ñ_tacªfº);
a(asm_rewrite_tac[pair_clauses]);
pop_thm()
));
=TEX
=SML
val ‚combine_def· = new_specification (["Combine"], 1, (
push_goal([],
ªÑCombine:'a LISTã'b LISTã('aâ'b)LISTé
	Combine (Nil:'a LIST) (Nil:'b LIST) = Nil Ä
	(É h1:'a; h2:'b; list1:'a LIST; list2:'b LISTé
		Combine (Cons h1 list1) (Cons h2 list2) =
		Cons (h1,h2) (Combine list1 list2))
º);
a(strip_asm_tac((list_simple_É_elim
	[ªçlist:'b LISTé(Nil:('aâ'b) LIST)º,
	ªça:'a; b:'b LISTã('aâ'b) LIST; c:'a LISTé
	 çlist:'b LISTéCons (a, Hd list) (b (Tl list))º])
	(inst_type_rule[(ª:'b LISTã('aâ'b) LISTº, ª:'bº)]list_prim_rec_thm)));
a(simple_Ñ_tacªfº);
a(asm_rewrite_tac[hd_def,tl_def]);
pop_thm()
));
=TEX
=SML
val ‚rev_def· = new_specification (["Rev"], 1, (
push_goal([],
ªÑRev:'a LISTã'a LISTé
	Rev (Nil:'a LIST) = Nil Ä
	É h:'a; list:'a LISTé
		Rev (Cons h list) = Append (Rev list) [h]
º);
a(strip_asm_tac((list_simple_É_elim
	[ªNilº,
	ªça:'a; b:'a LIST; c:'a LISTé
	    Append b [a]º])
	(inst_type_rule[(ª:'a LISTº, ª:'bº)]list_prim_rec_thm)));
a(simple_Ñ_tacªfº);
a(asm_rewrite_tac[]);
pop_thm()
));
=TEX
\section{Useful Theorems about Lists}
=SML
val ‚list_clauses· = save_thm ("list_clauses", (
push_goal([],ª
É x1 x2:'a; list1 list2 :'a LISTé
	åCons x1 list1 = Nil Ä
	åNil = Cons x1 list1 Ä
	(Cons x1 list1 = Cons x2 list2 Ç
		x1=x2 Ä list1=list2) Ä
	Hd (Cons x1 list1) = x1 Ä
	Tl (Cons x1 list1) = list1º);
a(rewrite_tac[nil_cons_def,hd_def,tl_def]);
a(REPEAT strip_tac THEN c_contr_tac);
a(POP_ASM_T (ante_tac o eq_sym_rule)
	THEN rewrite_tac[nil_cons_def]);
pop_thm()
));
=TEX

=SML
val ‚list_cases_thm· = save_thm ("list_cases_thm", (
push_goal([],ª
Élist1 :'a LISTé
	list1 = Nil Å
	Ñ x:'a; list2:'a LISTé list1 = Cons x list2º);
a(strip_tac THEN list_induction_tacªlist1:'a LISTº);
(* *** Goal "1" *** *)
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[list_clauses]);
a(strip_tac THEN MAP_EVERY simple_Ñ_tac[ªx:'aº,ªNilº]);
a(rewrite_tac[]);
(* *** Goal "3" *** *)
a(strip_tac THEN Å_right_tac);
a(MAP_EVERY simple_Ñ_tac[ªx':'aº,ªlist1º]);
a(rewrite_tac[]);
pop_thm()
));
=TEX

=SML
end (* of structure ListTheory *);
=TEX
=SML
open ListTheory;
=TEX
{\twocolumn[\section{INDEX OF DEFINED TERMS}]
{\makeatletter
\printindex}}
\end{document}
TypeInference.get_ti_context();


 
push_goal([],ª
É list:('aâ'b) LISTé
	(Uncurry Combine) (Split list) = listº);
a(strip_tac);
a(list_induction_tacªlist:('aâ'b) LISTº);
a(rewrite_tac[split_def,combine_def,uncurry_def]);


push_goal([],ª
É list1 list2 list3 list4:'a LISTé
	(Length list1 = Length list2 Ä
	Length list3 = Length list4)ä
	(Combine list1 list2 = Combine list3 list4
	Ç
	list1 = list3 Ä list2 = list4)º);





