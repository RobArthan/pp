=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FORMAL METHODS UNIT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Theory of Lists}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP039}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{The theory of lists for ICL HOL is implemented.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue 1.1 (28 August 1991)] First draft.
\end{description}
\subsection{Changes forecast}
Under development.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains parts of the ICL HOL
proof development system called for in \cite{DS/FMU/IED/HLD011}.
\subsection{Introduction}
=TEX
\section{ABSTRACTION AND REPRESENTATION FUNCTIONS}

Before we prove this we make sure we are in the right
theory.
=SML
open_theory"Ü";
new_theory "‚list·";
new_type ("‚LiST·", 1);

push_goal ([],ªÑ Is_List_Rep:'a LiSTãBOOLé
Ñ nil:'a LiSTéÑ cons:'aã'a LiSTã'a LiST é
	(Is_List_Rep nil) Ä
	(Éx:'a LiST é(Is_List_Rep x)
		ä (Éh:'aéIs_List_Rep (cons h x))) Ä
	(Ép:'a LiSTãBOOL é p nil Ä
		(Ém:'a LiSTé p m ä (Éhé p (cons h m)))
			ä (Éné Is_List_Rep n ä p n))
º);
a(simple_Ñ_tac ªçi:'a LiSTéÉq:'a LiSTãBOOLé
	q (nil:'a LiST) Ä
	(Énéq n ä (Éhéq ((cons:'aã'a LiSTã'a LiST) h n)))
	ä q iº);
a(simple_Ñ_tac ªnil:'a LiSTº);
a(simple_Ñ_tac ªcons:'a ã 'a LiST ã 'a LiSTº);
a(conv_tac all_simple_%beta%_conv);
a(REPEAT strip_tac);
(* 1 *)
a(lemma_tac ª(q:'a LiSTãBOOL) xº);
(* 1.1 *)
a(DROP_NTH_ASM_T 3 (ante_tac o (simple_É_elim ªq:'a LiSTãBOOLº)));
a(asm_rewrite_tac[]);
(* 1.2 *)
a(DROP_NTH_ASM_T 2 (ante_tac o simple_É_elim ªx:'a LiSTº));
a(asm_rewrite_tac[]);
a(strip_tac THEN asm_rewrite_tac[]);
(* 2 *)
a(POP_ASM_T (ante_tac o simple_É_elim ªp:'a LiSTãBOOLº));
a(asm_rewrite_tac[]);

val ‚is_list_rep_thm· = pop_thm();

val ‚is_list_rep_def· = new_specification(["Is_List_Rep"],
	1, is_list_rep_thm);

push_goal ([], ªÑx:'a LiSTé Is_List_Rep xº);
a(strip_asm_tac is_list_rep_def);
a(simple_Ñ_tac ªnil:'a LiSTº THEN asm_rewrite_tac[]);

val ‚list_exist_thm· = pop_thm();

val list_def‚list_def· = new_type_defn ("LIST","LIST",["'a"], list_exist_thm);


push_goal ([],ª
Ñ Nil:'a LIST; Cons:'aã'a LISTã'a LIST é
	(Ép:'a LISTãBOOL é p Nil Ä
		(Ém:'a LISTé p m ä (Éhé p (Cons h m)))
			ä (Éné p n))
º);
a(strip_asm_tac (simple_ä_match_mp_rule type_lemmas_thm list_def));
a(strip_asm_tac (is_list_rep_def));
a(simple_Ñ_tac ª(abs:'a LiSTã'a LIST)nilº);
a(simple_Ñ_tac ªçh:'aéça:'a LISTé
(abs:'a LiSTã'a LIST)(cons h ((rep:'a LISTã'a LiST) a))º);
a(conv_tac all_simple_%beta%_conv);
a(REPEAT strip_tac);
a(lemma_tac ªIs_List_Rep((rep:'a LISTã'a LiST)n)º
	THEN_LIST[asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so only one sub-goal *)
a(lemma_tac ªIs_List_Rep((cons:'aã'a LiSTã'a LiST) h ((rep:'a LISTã'a LiST) n))º);
(* 1 *)
a(DROP_NTH_ASM_T 5 (ante_tac o simple_É_elimª(rep:'a LISTã'a LiST)nº) THEN
	REPEAT strip_tac);
a(asm_rewrite_tac[]);
(* 2 *)
a(lemma_tacªÉa:'a LiSTéIs_List_Rep a ä Is_List_Rep a Ä
	p((abs:'a LiSTã'a LIST) a)º);
(* 2.1 *)
a(lemma_tacªÉa:'a LiSTéIs_List_Rep a Ä
	p((abs:'a LiSTã'a LIST) a) ä
	Is_List_Rep ((cons:'aã'a LiSTã'a LiST) h a) Ä p (abs (cons h a))º);
(* 2.1.1 *)
a(REPEAT strip_tac);
(* 2.1.1.1 *)
a(DROP_NTH_ASM_T 8 (ante_tac o simple_É_elimªa:'a LiSTº));
a(strip_tac);
a(asm_rewrite_tac[]);
(* 2.1.1.2 *)
a(DROP_NTH_ASM_T 5 (ante_tac o simple_É_elimª(abs:'a LiSTã'a LIST)aº));
a(asm_rewrite_tac[]);
a(strip_tac THEN POP_ASM_T (ante_tac o simple_É_elimªh:'aº));
a(GET_NTH_ASM_T 2 (undisch_tac o concl) THEN
asm_rewrite_tac[]);
a(strip_tac THEN asm_rewrite_tac[]);
(* 2.1.2 *)
a(GET_NTH_ASM_T 6 (ante_tac o simple_É_elim
	ªçaéIs_List_Rep a Ä p((abs:'a LiSTã'a LIST)a)º) THEN
	conv_tac all_simple_%beta%_conv);
a(strip_tac);
(* 2.1.2.1 *)
a(c_contr_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN rewrite_tac[]);
a(DROP_NTH_ASM_T 11 (ante_tac o simple_É_elimªm:'a LiSTº));
a(asm_rewrite_tac[]);
a(strip_tac THEN asm_rewrite_tac[]);
(* 2.1.2.2 *)
a(c_contr_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN rewrite_tac[]);
a(DROP_NTH_ASM_T 8 (ante_tac o simple_É_elimª(abs:'a LiSTã'a LIST)mº));
a(asm_rewrite_tac[]);
a(lemma_tacª((rep:'a LISTã'a LiST)((abs:'a LiSTã'a LIST)m))=mº);
(* 2.1.2.2.1 *)
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* 2.1.2.2.2 *)
a(asm_rewrite_tac[] THEN strip_tac THEN asm_rewrite_tac[]);
(* 2.2 *)
a(GET_NTH_ASM_T 1 (ante_tac o simple_É_elimª(rep:'a LISTã'a LiST)nº));
a(GET_NTH_ASM_T 10 rewrite_thm_tac THEN REPEAT strip_tac);
val ‚nil_cons_thm· = pop_thm();

val ‚nil_cons_def· = new_specification(["Nil","Cons"],
	2, nil_cons_thm);

val ‚list_induction_thm· = nil_cons_def;

fun ‚list_induction_tac· (tm : TERM) : TACTIC = (
	if not(is_var tm)
	then term_fail "list_induction_tac" 99999 [tm]
	else let fun aux_tac (gl as (asms, conc)) = (
			let	val abs = mk_simple_ç(tm, conc);
				val thm0 = (conv_rule
						(ONCE_MAP_C (simple_%beta%_conv))
						(simple_É_elim abs list_induction_thm));
				val thm1 = undisch_rule(conv_rule
	((RATOR_C o RAND_C o RAND_C o RAND_C)(simple_%alpha%_conv (fst(dest_var tm))))
						thm0);
				val thm2 = simple_É_elim tm thm1;
				val conc' = (hd (hyps thm2));
			in	([(asms, conc')],
				 (fn [th] => prove_asm_rule th thm2
				  | _ => bad_proof "list_induction_tac"))
			end
		);
	in	aux_tac THEN Ä_tac THEN_LIST [id_tac, simple_É_tac THEN ä_tac]
	end
);
=TEX
{\twocolumn[\section{INDEX OF DEFINED TERMS}]
{\makeatletter
\printindex}}
\end{document}

push_goal([],ªÉnén=2 Ä n=3º);
a(induction_tacªq:Üº);

push_goal([],ªÉl:'a LISTél=[] Ä Ñh x é l = Cons h xº);
a(list_induction_tacªx:'a LISTº);



