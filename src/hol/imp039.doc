=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FORMAL METHODS UNIT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Theory of Lists}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP039}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{The theory of lists for ICL HOL is implemented.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item [Issue 1.1 (28 August 1991)] First draft.
\end{description}
\subsection{Changes forecast}
Under development.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains parts of the ICL HOL
proof development system called for in \cite{DS/FMU/IED/HLD011}.
\subsection{Introduction}
=TEX
\section{ABSTRACTION AND REPRESENTATION FUNCTIONS}

Before we prove this we make sure we are in the right
theory.
	(Éxé IsListRep x ä (Éhéåcons h x = nil)) Ä
=SML
open_theory"Ü";
new_theory "list";
=TEX
=SML
push_goal ([],ªÉné 0 + n  =  n  Ä  n + 0  =  nº);
a(rewrite_tac[plus_def,plus_def1]);
val ‚plus_0_thm· = pop_thm();
=TEX
=SML
push_goal ([],ªÉm é åm < mº);
a(strip_tac);
a(rewrite_tac[lt_def,le_def]);
a(REPEAT strip_tac THEN MAP_EVERY induction_tac[ªi:Üº,ªm:Üº]);
(* *** Goal "1" *** *)
a(rewrite_tac[plus_def1,å_plus_1_thm]);
(* *** Goal "2" *** *)
a(POP_ASM_T ante_tac THEN
	once_rewrite_tac[plus_def1,plus_def]);
a(ante_tac (list_simple_É_elim [ªm+1º,ªm:Üº]one_one_plus_1_thm)
	THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN
	once_rewrite_tac[plus_def1,plus_def]);
a(rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv)
	plus_assoc_thm,å_plus_1_thm]);
(* *** Goal "4" *** *)
a(POP_ASM_T (asm_tac o
	rewrite_rule[simple_É_elimªi:Üºplus_comm_thm]));
a(POP_ASM_T ante_tac THEN
	once_rewrite_tac[conv_rule(ONCE_MAP_C eq_sym_conv)
	plus_assoc_thm]);
a(ante_tac (list_simple_É_elim
	[ª((m' + 1) + 1) + iº,ªm':Üº]one_one_plus_1_thm)
	THEN REPEAT strip_tac);
val ‚å_x_lt_x_thm· = pop_thm();
=TEX
=SML
push_goal([],ªÉi m né  m < n ä m < n + iº);
a(strip_tac THEN induction_tacªi:Üº);
(* *** Goal "1" *** *)
a(rewrite_tac[plus_0_thm]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(DROP_NTH_ASM_T 2 (strip_asm_tac o list_simple_É_elim
	[ªm':Üº,ªn:Üº]));
a(DROP_ASMS_T (MAP_EVERY ante_tac) THEN rewrite_tac
	[lt_def,le_def,plus_assoc_thm1]THEN REPEAT strip_tac);
a(simple_Ñ_tacªi''+1º);
a(asm_rewrite_tac[plus_assoc_thm1]);
val ‚lt_ä_lt_plus_1_thm· = pop_thm();
=TEX
=SML
push_goal([],ªÉ mé m = 0 Å Ñ ié i + 1 = mº);
a(strip_tac THEN induction_tacªm:Üº);
(* *** Goal "1" *** *)
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(Å_right_tac);
a(simple_Ñ_tacªm:Üº THEN rewrite_tac[]);
(* *** Goal "3" *** *)
a(Å_right_tac);
a(simple_Ñ_tacªi+1:Üº THEN asm_rewrite_tac[]);
val ‚Ü_cases_thm· = pop_thm();
=TEX
=SML
push_goal([],ªÉ m né   m < n Å m = n Å n < mº);
a(rewrite_tac[lt_def,le_def]);
a(strip_tac THEN strip_tac THEN induction_tac ªm:Üº);
(* *** Goal "1" *** *)
a(strip_asm_tac (simple_É_elimªn:ÜºÜ_cases_thm));
(* *** Goal "1.1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(Å_left_tac);
a(simple_Ñ_tacªi:Üº THEN rewrite_tac[plus_0_thm]);
a(once_rewrite_tac[plus_comm_thm] THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(strip_asm_tac (simple_É_elimªi:ÜºÜ_cases_thm));
(* *** Goal "2.1" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac
	[plus_0_thm] THEN REPEAT strip_tac);
(* *** Goal "2.2" *** *)
a(Å_left_tac);
a(simple_Ñ_tacªi':Üº THEN rewrite_tac[plus_assoc_thm]);
a(rewrite_tac[list_simple_É_elim[ª1º,ªi':Üº]plus_comm_thm]);
a(DROP_ASMS_T (rewrite_tac o map eq_sym_rule));
a(rewrite_tac[plus_assoc_thm]);
(* *** Goal "3" *** *)
a(asm_rewrite_tac[]);
a(Å_right_tac THEN Å_right_tac);
a(simple_Ñ_tacª0º THEN rewrite_tac[plus_0_thm]);
(* *** Goal "4" *** *)
a(Å_right_tac THEN Å_right_tac);
a(simple_Ñ_tacªi+1º);
a(asm_rewrite_tac[plus_assoc_thm1]);
val lt_cases_thm = pop_thm();
=TEX
=SML
push_goal ([],ªÉ m né m < n ä å n < m + 1º);
a(rewrite_tac[lt_def,le_def]);
a(REPEAT strip_tac);
a(POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(strip_asm_tac (rewrite_rule[lt_def,le_def](
	simple_É_elimªm+1ºå_x_lt_x_thm)));
a(POP_ASM_T (ante_tac o simple_É_elimªi+i'º));
a(rewrite_tac[plus_assoc_thm] THEN strip_tac);
a(LEMMA_T ªi + 1 + i'= 1 + i + i'º asm_rewrite_thm_tac);
(*proves main goal, so only lemma to do: *)
a(rewrite_tac[simple_É_elimª1ºplus_comm_thm, plus_assoc_thm]);
val lt_ä_å_lt_thm = top_thm();
=TEX
=SML
push_goal ([],ªÉ mé åm < 0º);
a(c_contr_tac);
a(POP_ASM_T (fn th => strip_asm_tac(
	simple_ä_match_mp_rule
	(simple_É_elim ªm:Üºlt_ä_lt_plus_1_thm) th)));
a(POP_ASM_T ante_tac THEN rewrite_tac[plus_0_thm, å_x_lt_x_thm]);
val å_lt_0_thm = pop_thm();
=TEX
=SML
push_goal ([],ªÉmé m < m + 1º);
a(strip_tac THEN rewrite_tac[lt_def,le_def]);
a(simple_Ñ_tacª0º THEN rewrite_tac[plus_0_thm]);
val m_lt_m_plus_1_thm = pop_thm();
=TEX
=SML
push_goal ([],ªÑ IsListRep:((Üã'a)âÜ)ãBOOL é
Ñ nil:(Üã'a)âÜéÑ cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ) é
	(IsListRep nil) Ä
	(ÉxéIsListRep x
		ä (Éh:'aéåcons h x = nil)) Ä
	(Éx yéIsListRep x Ä IsListRep y
		ä (Éa bé cons a x = cons b y
			Ç (a=b Ä x=y))) Ä
	(ÉxéIsListRep x
		ä (Éh:'aéIsListRep (cons h x))) Ä

	(Ép:((Üã'a)âÜ)ãBOOL é p nil Ä
		(Émé p m ä (Éhé p (cons h m)))
			ä (Éné IsListRep n ä p n))
º);
a(simple_Ñ_tac ªçrepéÑféÑné
	rep=((çm:Üé(if m<n then (f:Üã'a) m
			else (áx:'aéT))),n:Ü)º);
a(rewrite_tac[]);
a(MAP_EVERY simple_Ñ_tac [
	ª(çm:ÜéáeéT),0:Üº,
	ªçh:'aéçt:(Üã'a)âÜé((çm:Üé
		if m = Snd t then h
		else ((Fst t)m)),
			(Snd t)+1)º]);
a(rewrite_tac[]);
a(REPEAT strip_tac);
(* *** Goal "1" *** *)
a(MAP_EVERY simple_Ñ_tac [ªf:Üã'aº,ª0º]);
a(rewrite_tac[lt_def]);
a(lemma_tac ªÉmé å m + 1 û 0º);
(* *** Goal "1.1" *** *)
a(strip_tac THEN rewrite_tac[le_def]);
a(REPEAT strip_tac);
a(rewrite_tac[plus_def]);
a(rewrite_tac[å_plus_1_thm]);
(* *** Goal "1.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[pair_ops_def] THEN REPEAT strip_tac);
a(POP_ASM_T ante_tac THEN rewrite_tac[å_plus_1_thm]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac);
a(DROP_ASMS_T rewrite_tac);
a(rewrite_tac[pair_ops_def]);
a(REPEAT strip_tac);
a(lemma_tac ªn:Ü=n'º);
(* *** Goal "3.1" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[one_one_plus_1_thm]);
(* *** Goal "3.2" *** *)
a(DROP_NTH_ASM_T 3 (ante_tac o rewrite_rule[ext_thm])
	THEN asm_rewrite_tac[]);
a(strip_tac THEN POP_ASM_T (ante_tac o simple_É_elimªn':Üº)
	THEN rewrite_tac[]);
(* *** Goal "4" *** *)
a(POP_ASM_T ante_tac);
a(DROP_ASMS_T rewrite_tac);
a(rewrite_tac[pair_ops_def]);
a(REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(lemma_tac ªn:Ü=n'º);
(* *** Goal "4.1.1" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[one_one_plus_1_thm]);
(* *** Goal "4.1.2" *** *)
a(DROP_NTH_ASM_T 3 (ante_tac o rewrite_rule[ext_thm])
	THEN asm_rewrite_tac[]);
a(rewrite_tac[ext_thm] THEN REPEAT strip_tac);
a(POP_ASM_T (ante_tac o simple_É_elimªx:Üº));
a(cases_tacªx:Ü=n'º THEN asm_rewrite_tac[å_x_lt_x_thm]);
(* *** Goal "5" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "6" *** *)
a(MAP_EVERY simple_Ñ_tac [ª(çméif m=n then h else f m):Üã'aº,ªn+1:Üº]);
a(DROP_ASMS_T (fn x => asm_rewrite_tac (pair_ops_def::x)));
a(rewrite_tac[ext_thm]);
a(strip_tac);
a(cases_tacªx:Ü=nº THEN asm_rewrite_tac[]);
(* *** Goal "6.1" *** *)
a(lemma_tacªn < n+1º);
(* *** Goal "6.1.1" *** *)
a(rewrite_tac[lt_def,le_def]);
a(simple_Ñ_tacª0º THEN rewrite_tac[plus_0_thm]);
(* *** Goal "6.1.2" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "6.2" *** *)
a(cases_tacªx<nº THEN asm_rewrite_tac[]);
(* *** Goal "6.2.1" *** *)
a(strip_asm_tac(list_simple_É_elim[
	ª1º,ªx:Üº,ªn:Üº]lt_ä_lt_plus_1_thm));
a(asm_rewrite_tac[]);
(* *** Goal "6.2.2" *** *)
a(LEMMA_T ªåx < n + 1º rewrite_thm_tac);
(* Lemma proves the goal, so only lemma to do *)
a(LEMMA_T ªn < xº (fn th => strip_asm_tac( simple_ä_match_mp_rule lt_ä_å_lt_thm th)));
(* Lemma proves the goal, so only lemma to do *)
a(strip_asm_tac (list_simple_É_elim[ªx:Üº, ªn:Üº]lt_cases_thm));
(* *** Goal "7" *** *)
a(POP_ASM_T rewrite_thm_tac);
a(induction_tacªn':Üº);
(* *** Goal "7.1" *** *)
a(asm_rewrite_tac[å_lt_0_thm]);
(* *** Goal "7.2" *** *)
a(DROP_NTH_ASM_T 2 
	(strip_asm_tac o rewrite_rule[pair_ops_def] o
	simple_É_elimª((ç m'é if m' < n' then f m' else á xé T), n')º));
a(LEMMA_Tª	(ç m'é if m' < n' + 1 then f m' else á xé T)
	=	(ç m'é if m' = n' then f n' else if m' < n' then f m' else á xé T)º
	asm_rewrite_thm_tac);
(* Lemma proves the goal, so only lemma to do *)
a(rewrite_tac[ext_thm]);
a(strip_tac THEN cases_tacªx:Ü=n'º);
(* *** Goal "7.2.1" *** *)
a(asm_rewrite_tac[m_lt_m_plus_1_thm]);
(* *** Goal "7.2.2" *** *)
a(asm_rewrite_tac[]);
a(cases_tacªx<n'º THEN asm_rewrite_tac[]);
(* *** Goal "7.2.2.1" *** *)
a(strip_asm_tac (list_simple_É_elim[ª1º,ªx:Üº,ªn':Üº]
	lt_ä_lt_plus_1_thm));
a(asm_rewrite_tac[]);
(* *** Goal "7.2.2.2" *** *)
a(LEMMA_T ªå x < n' + 1º rewrite_thm_tac);
(* Lemma proves the goal, so only lemma to do *)
a(strip_asm_tac (list_simple_É_elim[ªx:Üº,ªn':Üº]lt_cases_thm));
a(strip_asm_tac (list_simple_É_elim[ªn':Üº,ªx:Üº]
	lt_ä_å_lt_thm));
val ‚is_list_rep_thm· = pop_thm();
val ‚is_list_rep_def· = new_specification(["IsListRep"],1,is_list_rep_thm);
=TEX
In order to use IsListRep, to define the new type,
we need to show that the subset of representation
type which it determines is non-empty.
=SML
push_goal([],ªÑx:(Üã'a)âÜ é IsListRep xº);
a(strip_asm_tac is_list_rep_def);
a(simple_Ñ_tacªnil:(Üã'a)âÜº THEN asm_rewrite_tac[]);
val ‚list_exist_thm· = pop_thm();
=TEX
Now we can introduce the new type:
=SML
val ‚list_def· = new_type_defn("LIST","LIST",["'a"],list_exist_thm);
=TEX
=SML
push_goal ([],ª
Ñ Nil:'a LIST; Cons:'aã'a LISTã'a LIST é
	(É x : 'a; list:'a LIST é åCons x list = Nil) Ä
	(É x1 x2 : 'a; list1 list2 : 'a LIST é
		Cons x1 list1 = Cons x2 list2
			Ç (x1=x2 Ä list1=list2)) Ä
	(Ép:'a LISTãBOOL é p Nil Ä
		(Élist:'a LISTé p list ä (Éxé p (Cons x list)))
			ä (Élisté p list))
º);
a(strip_asm_tac (simple_ä_match_mp_rule type_lemmas_thm list_def));
a(strip_asm_tac (is_list_rep_def));
a(simple_Ñ_tac ª(abs:((Üã'a)âÜ)ã'a LIST)nilº);
a(simple_Ñ_tac ªçx:'aéçlist:'a LISTé
(abs:((Üã'a)âÜ)ã'a LIST)
	(cons x ((rep:'a LISTã((Üã'a)âÜ)) list))º);
a(rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(lemma_tac ªIsListRep((rep:'a LISTã((Üã'a)âÜ))list)º
	THEN_LIST[asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so only one sub-goal *)
a(lemma_tac ªIsListRep((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x 
	((rep:'a LISTã((Üã'a)âÜ)) list))º);
(* *** Goal "1.1" *** *)
a(DROP_NTH_ASM_T 3 (ante_tac o simple_É_elimª(rep:'a LISTã((Üã'a)âÜ))listº) THEN
	REPEAT strip_tac);
a(asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(GET_NTH_ASM_T 6 (strip_asm_tac o simple_É_elim
	ª(rep:'a LISTã((Üã'a)âÜ))listº));
a(POP_ASM_T (strip_asm_tac o simple_É_elimªx:'aº));
a(c_contr_tac);
a(lemma_tac ª(rep:'a LISTã((Üã'a)âÜ))
	((abs:((Üã'a)âÜ)ã'a LIST)
	((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x (rep list)))
	= rep (abs nil)º);
(* *** Goal "1.2.1" *** *)
a(POP_ASM_T rewrite_thm_tac);
(* *** Goal "1.2.2" *** *)
a(POP_ASM_T ante_tac);
a(GET_NTH_ASM_T 10 (strip_asm_tac o simple_É_elim
	ª(cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x 
	((rep:'a LISTã((Üã'a)âÜ)) list)º));
a(GET_NTH_ASM_T 11 (strip_asm_tac o simple_É_elim
	ªnil:(Üã'a)âÜº));
a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(lemma_tac ªIsListRep((rep:'a LISTã((Üã'a)âÜ))list1)º
	THEN_LIST[asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so only one sub-goal *)
a(lemma_tac ªIsListRep((rep:'a LISTã((Üã'a)âÜ))list2)º
	THEN_LIST[asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so only one sub-goal *)
a(lemma_tac ª(cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x1
	((rep:'a LISTã((Üã'a)âÜ)) list1)
	= cons x2 (rep list2)º);
(* *** Goal "2.1" *** *)
a(lemma_tac ªIsListRep((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x1 
	((rep:'a LISTã((Üã'a)âÜ)) list1))º);
(* *** Goal "2.1.1" *** *)
a(DROP_NTH_ASM_T 5 (ante_tac o simple_É_elimª(rep:'a LISTã((Üã'a)âÜ))list1º) THEN
	REPEAT strip_tac);
a(asm_rewrite_tac[]);
(* *** Goal "2.1.2" *** *)
a(lemma_tac ªIsListRep((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x2 
	((rep:'a LISTã((Üã'a)âÜ)) list2))º);
(* *** Goal "2.1.2.1" *** *)
a(DROP_NTH_ASM_T 6 (ante_tac o simple_É_elimª(rep:'a LISTã((Üã'a)âÜ))list2º) THEN
	REPEAT strip_tac);
a(asm_rewrite_tac[]);
(* *** Goal "2.1.2.2" *** *)
a(GET_NTH_ASM_T 11 (strip_asm_tac o simple_É_elim
	ª(cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x1 
	((rep:'a LISTã((Üã'a)âÜ)) list1)º));
a(GET_NTH_ASM_T 12 (strip_asm_tac o simple_É_elim
	ª(cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x2 
	((rep:'a LISTã((Üã'a)âÜ)) list2)º));
a(lemma_tac ª(rep:'a LISTã((Üã'a)âÜ))
	((abs:((Üã'a)âÜ)ã'a LIST)
	((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x1 (rep list1)))
	= rep (abs (cons x2 (rep list2)))º);
(* *** Goal "2.1.2.2.1" *** *)
a(GET_NTH_ASM_T 2 ante_tac);
a(GET_NTH_ASM_T 7 rewrite_thm_tac);
(* *** Goal "2.1.2.2.2" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(GET_NTH_ASM_T 7 (strip_asm_tac o list_simple_É_elim
	[ª(rep:'a LISTã((Üã'a)âÜ))list1º,
	ª(rep:'a LISTã((Üã'a)âÜ))list2º]));
a(POP_ASM_T (strip_asm_tac o list_simple_É_elim
	[ªx1:'aº,ªx2:'aº]));
(* *** Goal "3" *** *)
a(lemma_tac ªIsListRep((rep:'a LISTã((Üã'a)âÜ))list1)º
	THEN_LIST[asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so only one sub-goal *)
a(lemma_tac ªIsListRep((rep:'a LISTã((Üã'a)âÜ))list2)º
	THEN_LIST[asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so only one sub-goal *)
a(lemma_tac ª(cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x1
	((rep:'a LISTã((Üã'a)âÜ)) list1)
	= cons x2 (rep list2)º);
(* *** Goal "3.1" *** *)
a(lemma_tac ªIsListRep((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x1 
	((rep:'a LISTã((Üã'a)âÜ)) list1))º);
(* *** Goal "3.1.1" *** *)
a(DROP_NTH_ASM_T 5 (ante_tac o simple_É_elimª(rep:'a LISTã((Üã'a)âÜ))list1º) THEN
	REPEAT strip_tac);
a(asm_rewrite_tac[]);
(* *** Goal "3.1.2" *** *)
a(lemma_tac ªIsListRep((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x2 
	((rep:'a LISTã((Üã'a)âÜ)) list2))º);
(* *** Goal "3.1.2.1" *** *)
a(DROP_NTH_ASM_T 6 (ante_tac o simple_É_elimª(rep:'a LISTã((Üã'a)âÜ))list2º) THEN
	REPEAT strip_tac);
a(asm_rewrite_tac[]);
(* *** Goal "3.1.2.2" *** *)
a(GET_NTH_ASM_T 11 (strip_asm_tac o simple_É_elim
	ª(cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x1 
	((rep:'a LISTã((Üã'a)âÜ)) list1)º));
a(GET_NTH_ASM_T 12 (strip_asm_tac o simple_É_elim
	ª(cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x2 
	((rep:'a LISTã((Üã'a)âÜ)) list2)º));
a(lemma_tac ª(rep:'a LISTã((Üã'a)âÜ))
	((abs:((Üã'a)âÜ)ã'a LIST)
	((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x1 (rep list1)))
	= rep (abs (cons x2 (rep list2)))º);
(* *** Goal "3.1.2.2.1" *** *)
a(GET_NTH_ASM_T 2 ante_tac);
a(GET_NTH_ASM_T 7 rewrite_thm_tac);
(* *** Goal "3.1.2.2.2" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "3.2" *** *)
a(GET_NTH_ASM_T 7 (strip_asm_tac o list_simple_É_elim
	[ª(rep:'a LISTã((Üã'a)âÜ))list1º,
	ª(rep:'a LISTã((Üã'a)âÜ))list2º]));
a(POP_ASM_T (strip_asm_tac o list_simple_É_elim
	[ªx1:'aº,ªx2:'aº]));
a(GET_NTH_ASM_T 13 (strip_asm_tac o 
	eq_sym_rule o (simple_É_elimªlist1:'a LISTº)));
a(POP_ASM_T once_rewrite_thm_tac);
a(GET_NTH_ASM_T 13 (strip_asm_tac o 
	eq_sym_rule o (simple_É_elimªlist2:'a LISTº)));
a(POP_ASM_T once_rewrite_thm_tac);
a(POP_ASM_T rewrite_thm_tac);
(* *** Goal "4" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "5" *** *)
a(lemma_tac ªIsListRep((rep:'a LISTã((Üã'a)âÜ))list)º
	THEN_LIST[asm_rewrite_tac[], id_tac]);
(* asm_rewrite_tac proves the lemma so only one sub-goal *)
a(lemma_tac ªIsListRep((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x 
	((rep:'a LISTã((Üã'a)âÜ)) list))º);
(* *** Goal "5.1" *** *)
a(DROP_NTH_ASM_T 5 (ante_tac o simple_É_elimª(rep:'a LISTã((Üã'a)âÜ))listº) THEN
	REPEAT strip_tac);
a(asm_rewrite_tac[]);
(* *** Goal "5.2" *** *)
a(lemma_tacªÉlist:((Üã'a)âÜ)éIsListRep list ä IsListRep list Ä
	p((abs:((Üã'a)âÜ)ã'a LIST) list)º);
(* *** Goal "5.2.1" *** *)
a(lemma_tacªÉlist:((Üã'a)âÜ)éIsListRep list Ä
	p((abs:((Üã'a)âÜ)ã'a LIST) list) ä
	IsListRep ((cons:'aã((Üã'a)âÜ)ã((Üã'a)âÜ)) x
		list) Ä p (abs (cons x list))º);
(* *** Goal "5.2.1.1" *** *)
a(REPEAT strip_tac);
(* *** Goal "5.2.1.1.1" *** *)
a(DROP_NTH_ASM_T 8 (ante_tac o simple_É_elimªlist':((Üã'a)âÜ)º));
a(strip_tac);
a(asm_rewrite_tac[]);
(* 5.2.1.1.2 *)
a(DROP_NTH_ASM_T 5 (ante_tac o simple_É_elimª(abs:((Üã'a)âÜ)ã'a LIST)list'º));
a(asm_rewrite_tac[]);
a(strip_tac THEN POP_ASM_T (ante_tac o simple_É_elimªx:'aº));
a(GET_NTH_ASM_T 2 (undisch_tac o concl) THEN asm_rewrite_tac[]);
a(strip_tac THEN asm_rewrite_tac[]);
(* 5.2.1.2 *)
a(GET_NTH_ASM_T 6 (ante_tac o simple_É_elim
	ªçaéIsListRep a Ä p((abs:((Üã'a)âÜ)ã'a LIST)a)º) THEN
	rewrite_tac[]);
a(strip_tac);
(* 5.2.1.2.1 *)
a(c_contr_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN rewrite_tac[]);
a(DROP_NTH_ASM_T 11 (ante_tac o simple_É_elimªm:((Üã'a)âÜ)º));
a(asm_rewrite_tac[]);
a(strip_tac THEN asm_rewrite_tac[]);
(* 5.2.1.2.2 *)
a(c_contr_tac);
a(DROP_NTH_ASM_T 3 ante_tac THEN rewrite_tac[]);
a(DROP_NTH_ASM_T 8 (ante_tac o simple_É_elimª(abs:((Üã'a)âÜ)ã'a LIST)mº));
a(asm_rewrite_tac[]);
a(lemma_tacª((rep:'a LISTã((Üã'a)âÜ))((abs:((Üã'a)âÜ)ã'a LIST)m))=mº);
(* 5.2.1.2.2.1 *)
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
(* 5.2.1.2.2.2 *)
a(asm_rewrite_tac[] THEN strip_tac THEN asm_rewrite_tac[]);
(* 5.2.2 *)
a(POP_ASM_T (ante_tac o simple_É_elimª(rep:'a LISTã((Üã'a)âÜ))listº));
a(GET_NTH_ASM_T 11 rewrite_thm_tac THEN REPEAT strip_tac);
val ‚nil_cons_thm· = pop_thm();
=TEX
=SML
val ‚nil_cons_def· = new_specification(["Nil","Cons"],2,
	nil_cons_thm);

val ‚å_cons_thm· = Ä_left_elim nil_cons_def;

val ‚one_one_cons_thm· = (Ä_left_elim o Ä_right_elim) nil_cons_def;

val ‚list_induction_thm· = Ä_right_elim (Ä_right_elim nil_cons_def);

fun ‚list_induction_tac· (tm : TERM) : TACTIC = (
	if not(is_var tm)
	then term_fail "list_induction_tac" 99999 [tm]
	else let fun aux_tac (gl as (asms, conc)) = (
			let	val abs = mk_simple_ç(tm, conc);
				val thm0 = (conv_rule
						(ONCE_MAP_C (simple_%beta%_conv))
						(simple_É_elim abs list_induction_thm));
				val thm1 = undisch_rule(conv_rule
	((RATOR_C o RAND_C o RAND_C o RAND_C)(simple_%alpha%_conv (fst(dest_var tm))))
						thm0);
				val thm2 = simple_É_elim tm thm1;
				val conc' = (hd (hyps thm2));
			in	([(asms, conc')],
				 (fn [th] => prove_asm_rule th thm2
				  | _ => bad_proof "list_induction_tac"))
			end
		);
	in	aux_tac THEN Ä_tac THEN_LIST [id_tac, simple_É_tac THEN ä_tac]
	end
);

=TEX
\subsection{Definition by Induction}

\paragraph{Principle of Definition by Induction:} Let $X$ be a set, let $z \in X$,
and let $s$ be a function from $X$ to itself, then there exists a unique
function $f$ from $'a$ to $X$ such that $f(Nil) = z$ and
for any $x$ and $list$, $f(Cons x list)=s(f x list)$.

=SML
push_goal([],
	ªÉn:'béÉc:'aã'bã'b é Ñr:'a LISTã'bãBOOLé
		r Nil n 
	Ä	(É list xér list x ä
			(Éaé r (Cons a list) (c a x)))
	Ä	Éx:'bér Nil x ä x = nº);
a(REPEAT strip_tac THEN simple_Ñ_tac
	ªç(l:'a LIST)(y:'b)éål=Nil Å (l=Nil Ä y=n)º);
a(rewrite_tac[å_cons_thm]);
val ‚list_rec_lemma1· = pop_thm();
=TEX
=SML
push_goal([],ªÉlist:'a LISTéÉx:'aé åCons x list = listº);
a(REPEAT strip_tac THEN list_induction_tacªlist:'a LISTº);
(* *** Goal "1" *** *)
a(rewrite_tac[å_cons_thm]);
(* *** Goal "2" *** *)
a(c_contr_tac THEN strip_asm_tac(list_simple_É_elim
	[ªx:'aº,ªx':'aº,ªCons x' listº,ªlist:'a LISTº]one_one_cons_thm));
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
val ‚list_rec_lemma2· = pop_thm();
=TEX
=SML
push_goal([],
	ªÉn:'béÉc:'aã'bã'bé Ék:'a LISTéÑr:'a LISTã'bãBOOLé
		r Nil n
	Ä	(Élist xér list x ä (Éa:'aér(Cons a list)(c a x)))
	Ä	Ñtér k t Ä Éx:'bér k x ä x = tº);
a(REPEAT strip_tac THEN list_induction_tacªk:'a LISTº);
(* *** Goal "1" *** *)
a(strip_asm_tac (all_simple_É_elim list_rec_lemma1) THEN
	simple_Ñ_tacªr:'a LISTã'bãBOOLº);
a(asm_rewrite_tac[] THEN simple_Ñ_tacªn:'bº THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac);
a(simple_Ñ_tacªç(i:'a LIST) (y:'b)éif Cons x k = i then
	y = (c:'aã'bã'b) x t else r i yº
	THEN rewrite_tac[å_cons_thm] THEN REPEAT strip_tac);
(* *** Goal "2.1" *** *)
a(strip_asm_tac (list_simple_É_elim[
	ªx:'aº,ªa:'aº,ªk:'a LISTº, ªlist:'a LISTº]
	one_one_cons_thm));
a(DROP_NTH_ASM_T 4 ante_tac THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(lemma_tac ª(r:'a LISTã'bãBOOL) k x' ä x' = tº THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 6 (strip_asm_tac o list_simple_É_elim
	[ªlist:'a LISTº,ªx':'bº]) THEN asm_rewrite_tac[]);
(* *** Goal "2.3" *** *)
a(DROP_NTH_ASM_T 2 ante_tac THEN asm_rewrite_tac[list_rec_lemma2]);
(* *** Goal "2.4" *** *)
a(LEMMA_T ª(r:'a LISTã'bãBOOL)list x'º ante_tac);
(* *** Goal "2.4.1" *** *)
a(DROP_NTH_ASM_T 2 (asm_rewrite_thm_tac o eq_sym_rule));
a(DROP_NTH_ASM_T 5 (strip_asm_tac o list_simple_É_elim[
	ªk:'a LISTº,ªt:'bº]) THEN asm_rewrite_tac[]);
(* *** Goal "2.4.2" *** *)
a(DROP_NTH_ASM_T 6 (strip_asm_tac o list_simple_É_elim
	[ªlist:'a LISTº,ªx':'bº]) THEN asm_rewrite_tac[]);
(* *** Goal "2.5" *** *)
a(strip_asm_tac (list_simple_É_elim[
	ªx:'aº,ªa:'aº,ªk:'a LISTº, ªlist:'a LISTº]
	one_one_cons_thm));
a(DROP_NTH_ASM_T 4 ante_tac THEN POP_ASM_T (rewrite_thm_tac o eq_sym_rule));
a(lemma_tac ª(r:'a LISTã'bãBOOL) k x' ä x' = tº THEN asm_rewrite_tac[]);
(* *** Goal "2.6" *** *)
a(DROP_NTH_ASM_T 6 (strip_asm_tac o list_simple_É_elim
	[ªlist:'a LISTº,ªx':'bº]) THEN asm_rewrite_tac[]);
(* *** Goal "2.7" *** *)
a(simple_Ñ_tacª(c:'aã'bã'b)x tº THEN REPEAT strip_tac
	THEN asm_rewrite_tac[]);
val ‚list_rec_lemma3· = pop_thm();
=TEX
=SML
push_goal([],
	ªÉn:'béÉc:'aã'bã'bé Ñr:'a LISTã'bãBOOLé
		r Nil n
	Ä	(Élist xér list x ä (Éa:'aé
			r(Cons a list)(c a x)))
	Ä	(ÉméÑyér m y Ä Éxér m x ä x = y)º);
a(REPEAT strip_tac THEN
  simple_Ñ_tacª(ç(k:'a LIST) (y:'b)é
	(Éqé(q Nil n Ä (Élist xéq list x
		ä (Éaéq(Cons a list)(c a x)))) ä q k y))º);
a(rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(DROP_NTH_ASM_T 3 (ante_tac o simple_É_elim
	ªq:'a LISTã'bãBOOLº) THEN asm_rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o all_simple_É_elim)
	THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(list_induction_tac ªm:'a LISTº);
(* *** Goal "2.1" *** *)
a(simple_Ñ_tacªn:'bº THEN REPEAT strip_tac);
a(strip_asm_tac(all_simple_É_elim list_rec_lemma1));
a(DROP_NTH_ASM_T 4 (ante_tac o simple_É_elimªr:'a LISTã'bãBOOLº)
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(strip_tac THEN simple_Ñ_tac ª(c:'aã'bã'b)x yº THEN REPEAT strip_tac);
(* *** Goal "2.2.1" *** *)
a(DROP_NTH_ASM_T 4 (ante_tac o simple_É_elimªq:'a LISTã'bãBOOLº) THEN asm_rewrite_tac[]);
a(POP_ASM_T (strip_asm_tac o list_simple_É_elim
	[ªm:'a LISTº,ªy:'bº]) THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a(strip_asm_tac(list_simple_É_elim[ªn:'bº, ªc:'aã'bã'bº, ªCons x mº]list_rec_lemma3));
a(lemma_tac ª(r:'a LISTã'bãBOOL)m yº);
(* *** Goal "2.2.2.1" *** *)
a(DROP_NTH_ASM_T 7 (ante_tac o simple_É_elimªr:'a LISTã'bãBOOLº) THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2" *** *)
a(lemma_tac ª(r:'a LISTã'bãBOOL)(Cons x m) ((c:'aã'bã'b)x y)º);
(* *** Goal "2.2.2.2.1" *** *)
a(DROP_NTH_ASM_T 4 (strip_asm_tac o list_simple_É_elim[ªm:'a LISTº, ªy:'bº])
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2" *** *)
a(lemma_tac ª(r:'a LISTã'bãBOOL)(Cons x m) x'º);
(* *** Goal "2.2.2.2.2.1" *** *)
a(DROP_NTH_ASM_T 7 (ante_tac o simple_É_elimªr:'a LISTã'bãBOOLº)
	THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2.2.2.2" *** *)
a(GET_NTH_ASM_T 4 (ante_tac o simple_É_elimªx':'bº));
a(DROP_NTH_ASM_T 4 (ante_tac o simple_É_elimª(c:'aã'bã'b)x yº));
a(strip_tac THEN asm_rewrite_tac[]);
val ‚list_rec_lemma4· = pop_thm();
=TEX
=SML
push_goal([],
	ªÉn:'béÉc:'aã'bã'bé Ñf:'a LISTã'bé
		f Nil = n
	Ä	Élist:'a LISTéÉa:'aéf(Cons a list) = c a (f list)º);
a(REPEAT strip_tac);
a((strip_asm_tac o all_simple_É_elim) list_rec_lemma4);
a((ante_tac o simple_É_elimªr:'a LISTã'bãBOOLº o
	inst_type_rule[(ª:'a LISTº, ª:'aº)]) rec_lemma5);
a(asm_rewrite_tac [] THEN REPEAT strip_tac);
a(simple_Ñ_tacªf:'a LISTã'bº);
a(strip_tac THEN asm_rewrite_tac[] THEN strip_tac);
a(list_induction_tacªlist:'a LISTº);
(* *** Goal "1" *** *)
a(LEMMA_T ª(f:'a LISTã'b) Nil=nº rewrite_thm_tac);
(* *** Goal "1.1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "1.2" *** *)
a(DROP_NTH_ASM_T 3 (strip_asm_tac o list_simple_É_elim
	[ªNilº,ªn:'bº]) THEN asm_rewrite_tac[]);
(* *** Goal "2" *** *)
a(REPEAT strip_tac THEN LEMMA_T
	ª(f:'a LISTã'b)(Cons x list)=(c:'aã'bã'b) x (f list)º rewrite_thm_tac);
(* *** Goal "2.1" *** *)
a(asm_rewrite_tac[]);
(* *** Goal "2.2" *** *)
a(DROP_NTH_ASM_T 4 (strip_asm_tac o list_simple_É_elim
	[ªCons x listº,ª(c:'aã'bã'b)x (f (list:'a LIST))º]));
(* *** Goal "2.2.1" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[]);
(* *** Goal "2.2.2" *** *)
a(asm_rewrite_tac[]);
val ‚list_rec_lemma5· = pop_thm();
=TEX
=SML
push_goal([],
	ªÉn:'béÉc:'aã'bã'a LISTã'bé Ñf:'a LISTã'bé
		f Nil = n
	Ä	Élist:'a LISTéÉa:'aé
			f(Cons a list) = c a (f list)listº);
a(REPEAT strip_tac);
a(strip_asm_tac
	(list_simple_É_elim[ª((n:'b), Nil)º,
	ªç a; ix:'b â 'a LISTé((c a (Fst ix) (Snd ix):'b),
		Cons a (Snd ix))º]
	(inst_type_rule[(ª:'b â 'a LISTº, ª:'bº)] list_rec_lemma5)));
a(simple_Ñ_tac ªçiéFst((f:'a LISTã('b â 'a LIST)) i)º);
a(GET_NTH_ASM_T 2 (fn th=> rewrite_tac[pair_ops_def, th]));
a(strip_tac THEN list_induction_tacªlist:'a LISTº);
(* *** Goal "1" *** *)
a(asm_rewrite_tac[pair_ops_def]);
(* *** Goal "2" *** *)
a(asm_rewrite_tac[pair_ops_def]);
a(LEMMA_T ªÉkéSnd((f:'a LISTã('b â 'a LIST))k) = kº rewrite_thm_tac);
a(strip_tac THEN list_induction_tacªk:'a LISTº THEN asm_rewrite_tac[pair_ops_def]);
val ‚list_rec_lemma6· = pop_thm();
=TEX
The uniqueness part of the primitive recursion theorem is
straightforward:
=SML
push_goal([],
	ªÉn:'béÉc:'aã'bã'a LISTã'bé Éf g:'a LISTã'bé
	(	(	f Nil = n
		Ä	Élist:'a LISTéÉa:'aé
			f(Cons a list) = c a (f list) list)
		Ä (	g Nil = n
		Ä	Élist:'a LISTéÉa:'aé
			g(Cons a list) = c a (g list) list))
	ä	f = gº);
a(REPEAT strip_tac THEN pure_once_rewrite_tac[ext_thm]);
a(strip_tac THEN list_induction_tacªx:'a LISTº THEN asm_rewrite_tac[]);
val ‚list_rec_lemma7· = pop_thm();
=TEX
=SML
push_goal([],
	ªÉn:'béÉc:'aã'bã'a LISTã'bé Ñ%down%1f:'a LISTã'bé
		f Nil = n
	Ä	Élist:'a LISTéÉa:'aé
			f(Cons a list) = c a (f list) listº);
a(REPEAT strip_tac THEN conv_tac simple_Ñ%down%1_conv);
a(strip_asm_tac(all_simple_É_elim list_rec_lemma6) THEN simple_Ñ_tacªf:'a LISTã'bº);
a(asm_rewrite_tac[]);
a(REPEAT strip_tac THEN
	ante_tac (list_simple_É_elim[ªn:'bº, ªc:'aã'bã'a LISTã'bº, ªf:'a LISTã'bº, ªx:'a LISTã'bº]list_rec_lemma7));
a(asm_rewrite_tac[] THEN ä_T (accept_tac o eq_sym_rule));
val ‚list_prim_rec_thm· = save_thm("list_prim_rec_thm", pop_thm());

=TEX

{\twocolumn[\section{INDEX OF DEFINED TERMS}]
{\makeatletter
\printindex}}
\end{document}

