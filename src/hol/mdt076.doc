% $Id$ %Z%
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for the Supplied Proof Contexts}  %% Mandatory field
\def\TPPheadtitle{Module Tests for the Supplied Proof Contexts}
\TPPref{DS/FMU/IED/MDT076}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$ %
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & Project Manager}
\TPPabstract{A set of module tests are given for the 
the supplied proof contexts.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issue 1.1,1.2,1.3]
First drafts.
\item [Issue 1.4 (27th May 1992)]
Bug fixing.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the module testing of the supplied proof contexts.
The design is in \cite{DS/FMU/IED/DTD076}
and it is
implemented in \cite{DS/FMU/IED/IMP076}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the module testing of the material given a design in \cite{DS/FMU/IED/DTD076},
following the test policy given in that document and the general policy given in \cite{DS/FMU/IED/PLN008}.

\subsubsection{Dependencies}
This document is derived from the detailed design in \cite{DS/FMU/IED/DTD076},
and is further influenced by the implementation, in  \cite{DS/FMU/IED/IMP076}.
\subsubsection{Deficiencies}
None known.
\section{TEST CASES}
We test the two functions of the signature of \cite{DS/FMU/IED/DTD076}
in turn.
We then test for the presence, effect, and ``out of problem domain'' for each supplied prof context.
\section{PROLOGUE}
Initialise the test package:
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results();
=TEX
=SML
open_theory "basic_hol";
set_pc "basic_hol";
=TEX
\section{FUNCTIONS}
=SML
store_mt_results (mt_runf (op =$)) [("supplied_prove_tac 1",
	concl o tac_proof,
	(([],¬µ x · x = x®),supplied_prove_tac []),
	¬µ x · x = x®),
	("supplied_prove_tac 2",
	concl o tac_proof,
	(([],concl prim_rec_thm),supplied_prove_tac [prim_rec_thm]),
	concl prim_rec_thm)];
=TEX
=SML
store_mt_results (mt_runf (op =$)) [("supplied_prove_conv 1",
	concl o supplied_prove_conv [],
	¬µ x · x = x®,
	¬(µ x · x = x) ¤ T®),
	("supplied_prove_conv 2",
	concl o supplied_prove_conv [prim_rec_thm],
	concl prim_rec_thm,
	mk_¤(concl prim_rec_thm, mk_t))];
store_mt_results mt_run_fail [("supplied_prove_conv 76001",
	supplied_prove_conv [],
	mk_f,
	gen_fail_msg "supplied_prove_conv" 76001 ["¬F®"])];
=TEX

\section{SUPPLIED PROOF CONTEXTS}
\subsection{Test Functions}
=SML
fun lprove_rule tm = tac_proof(([],tm),
	TRY_T(rewrite_tac[]) THEN
	REPEAT strip_tac)
	handle complaint =>
	divert complaint "tac_proof" "lprove_rule" 76001
		[fn () => string_of_term tm];
=TEX
\subsection{Proof Context: ``initial''}
=SML
set_pc "initial";
store_mt_results (mt_runf (op =$)) [("proof context initial",
	concl o lprove_rule,
	¬a ´ a®,
	¬a ´ a®)];
store_mt_results mt_run_fail [("proof context initial does not apply",
	lprove_rule,
	¬a ¤ a®,
	gen_fail_msg "lprove_rule" 76001 ["¬a ¤ a®"])];
=TEX

\subsection{Proof Context: ``basic$\_$prove$\_¶\_$conv''}
=SML
set_pc "basic_prove_¶_conv";
store_mt_results (mt_runf (op =$)) [("proof context basic_prove_¶_conv",
	concl o prove_¶_conv,
	¬¶ x · x = 1®,
	¬(¶ x · x = 1) ¤ T®)];
store_mt_results mt_run_fail [("proof context basic_prove_¶_conv does not apply a",
	lprove_rule,
	¬a ¤ a®,
	gen_fail_msg "lprove_rule" 76001 ["¬a ¤ a®"])];
=TEX
\subsection{Proof Context: ``simple$\_$abstractions''}
=SML
set_pc "simple_abstractions";
store_mt_results (mt_runf (op =$)) [("proof context simple_abstractions",
	concl o lprove_rule,
	¬(³(a ² b)) ´ ³ a®,
	¬(³(a ² b)) ´ ³ a®)];
store_mt_results mt_run_fail [("proof context simple_abstractions does not apply a",
	lprove_rule,
	¬a ¤ a®,
	gen_fail_msg "lprove_rule" 76001 ["¬a ¤ a®"]),
	("proof context simple_abstractions does not apply b",
	lprove_rule,
	¬µ (x, y)· x ´ x®,
	gen_fail_msg "lprove_rule" 76001 ["¬µ (x, y)· x ´ x®"])];
=TEX
\subsection{Proof Context: ``paired$\_$abstractions''}
=SML

set_pc "paired_abstractions";
store_mt_results (mt_runf (op =$)) [("proof context paired_abstractions",
	concl o lprove_rule,
	¬µ (x, y)· x ´ x®,
	¬µ (x, y)· x ´ x®)];
store_mt_results mt_run_fail [("proof context paired_abstractions does not apply",
	lprove_rule,
	¬a ¤ a®,
	gen_fail_msg "lprove_rule" 76001 ["¬a ¤ a®"])];
=TEX
\subsection{Proof Context: ``propositions''}
=SML
set_pc "propositions";
store_mt_results (mt_runf (op =$)) [("proof context propositions",
	concl o lprove_rule,
	¬a ¤ a®,
	¬a ¤ a®)];
store_mt_results mt_run_fail [("proof context propositions does not apply",
	lprove_rule,
	¬³(a ² b) ´ a®,
	gen_fail_msg "lprove_rule" 76001 ["¬³ (a ² b) ´ a®"])];
=TEX
\subsection{Proof Context: ``fun$\_$ext''}
=SML
set_pc "fun_ext";
store_mt_results (mt_runf (op =$)) [("proof context fun_ext",
	concl o lprove_rule,
	¬(µ x · f x = g x) ´ (f = g)®,
	¬(µ x · f x = g x) ´ (f = g)®)];
store_mt_results mt_run_fail [("proof context fun_ext does not apply",
	lprove_rule,
	¬a ¤ a®,
	gen_fail_msg "lprove_rule" 76001 ["¬a ¤ a®"])];
=TEX
\subsection{Proof Context: ``predicates''}
=SML
set_pc "predicates";
store_mt_results (mt_runf (op =$)) [("proof context predicates",
	concl o lprove_rule,
	¬µ (x,y) · ³(x ± y) ´ ³ x ² ³ y®,
	¬µ (x,y) · ³(x ± y) ´ ³ x ² ³ y®)];
store_mt_results mt_run_fail [("proof context predicates does not apply",
	lprove_rule,
	¬(µ x · f x = g x) ´ (f = g)®,
	gen_fail_msg "lprove_rule" 76001 ["¬(µ x· f x = g x) ´ f = g®"])];
=TEX
\subsection{Proof Context: ``predicates1''}
=SML
set_pc "predicates1";
store_mt_results (mt_runf (op =$)) [("proof context predicates1",
	concl o lprove_rule,
	¬(µ x · f x = g x) ¤ (f = g)®,
	¬(µ x · f x = g x) ¤ (f = g)®)];
store_mt_results mt_run_fail [("proof context predicates1 does not apply",
	lprove_rule,
	¬(a, b) = (c, d) ´ a = c®,
	gen_fail_msg "lprove_rule" 76001 ["¬(a, b) = (c, d) ´ a = c®"])];
=TEX
\subsection{Proof Context: ``pair''}
=SML
set_pc "pair";
store_mt_results (mt_runf (op =$)) [("proof context pair",
	concl o lprove_rule,
	¬((a, b) = (c, d)) ´ a = c®,
	¬((a, b) = (c, d)) ´ a = c®)];
store_mt_results mt_run_fail [("proof context pair does not apply a",
	lprove_rule,
	¬a ¤ a®,
	gen_fail_msg "lprove_rule" 76001 ["¬a ¤ a®"]),
	("proof context pair does not apply b",
	lprove_rule,
	¬((a, b) = c) ´ a = Fst c®,
	gen_fail_msg "lprove_rule" 76001 ["¬(a, b) = c ´ a = Fst c®"])];
=TEX
\subsection{Proof Context: ``pair1''}
=SML
set_pc "pair1";
store_mt_results (mt_runf (op =$)) [("proof context pair1",
	concl o lprove_rule,
	¬((a, b) = c) ´ a = Fst c®,
	¬((a, b) = c) ´ a = Fst c®)];
store_mt_results mt_run_fail [("proof context pair1 does not apply",
	lprove_rule,
	¬a ¤ a®,
	gen_fail_msg "lprove_rule" 76001 ["¬a ¤ a®"])];
=TEX
\subsection{Proof Context: ``î''}
=SML
set_pc "î";
store_mt_results (mt_runf (op =$)) [
	("proof context î",
	concl o lprove_rule,
	¬0 ¼ x®,
	¬0 ¼ x®)];
store_mt_results mt_run_fail [("proof context î does not apply a",
	lprove_rule,
	¬³(1 = 0)®,
	gen_fail_msg "lprove_rule" 76001 ["¬³ 1 = 0®"]),
	("proof context î does not apply b",
	lprove_rule,
	¬2 + 3 = 5®,
	gen_fail_msg "lprove_rule" 76001 ["¬2 + 3 = 5®"])];
=TEX
\subsection{Proof Context: ``î$\_$lit''}
=SML
set_pc "î_lit";
store_mt_results (mt_runf (op =$)) [("proof context î_lit",
	concl o lprove_rule,
	¬2 + 3 = 5®,
	¬2 + 3 = 5®)];
store_mt_results mt_run_fail [("proof context î_lit does not apply",
	lprove_rule,
	¬0 ¼ x®,
	gen_fail_msg "lprove_rule" 76001 ["¬0 ¼ x®"])];
=TEX
\subsection{Proof Context: ``list''}
=SML
set_pc "list";
store_mt_results (mt_runf (op =$)) [("proof context list",
	concl o lprove_rule,
	¬[a] = [b] ´ a = b®,
	¬[a] = [b] ´ a = b®)];
store_mt_results mt_run_fail [("proof context list does not apply",
	lprove_rule,
	¬a ¤ a®,
	gen_fail_msg "lprove_rule" 76001 ["¬a ¤ a®"])];
=TEX
\subsection{Proof Context: ``char''}
=SML
set_pc "char";
store_mt_results (mt_runf (op =$)) [("proof context char",
	concl o lprove_rule,
	¬"ab" = "cd" ´ x®,
	¬"ab" = "cd" ´ x®)];
store_mt_results mt_run_fail [("proof context char does not apply",
	lprove_rule,
	¬a ¤ a®,
	gen_fail_msg "lprove_rule" 76001 ["¬a ¤ a®"])];
=TEX
\subsection{Proof Context: ``basic$\_$hol''}
=SML
set_pc "basic_hol";
store_mt_results (mt_runf (op =$)) [("proof context basic_hol",
	concl o lprove_rule,
	¬³(0 = 1) ± ³("ab" = "ac")®,
	¬³(0 = 1) ± ³("ab" = "ac")®)];
store_mt_results mt_run_fail [("proof context basic_hol does not apply",
	lprove_rule,
	¬2 + 3 = 5®,
	gen_fail_msg "lprove_rule" 76001 ["¬2 + 3 = 5®"])];
=TEX
\subsection{Proof Context: ``basic$\_$hol1''}
=SML
set_pc "basic_hol1";
store_mt_results (mt_runf (op =$)) [("proof context basic_hol1",
	concl o lprove_rule,
	¬3 - (2+1) ¼ x®,
	¬3 - (2+1) ¼ x®)];
store_mt_results mt_run_fail [("proof context basic_hol1 does not apply",
	lprove_rule,
	¬F®,
	gen_fail_msg "lprove_rule" 76001 ["¬F®"])];
=TEX
\subsection{Proof Context: ``sum''}
=SML
open_theory "sum";
set_pc "sum";
store_mt_results (mt_runf (op =$)) [("proof context sum",
	concl o lprove_rule,
	¬InL x = InR x ´ y®,
	¬InL x = InR x ´ y®)];
store_mt_results mt_run_fail [("proof context sum does not apply",
	lprove_rule,
	¬a ¤ a®,
	gen_fail_msg "lprove_rule" 76001 ["¬a ¤ a®"])];
=TEX
\subsection{Proof Context: ``one''}
=SML
open_theory "one";
set_pc "one";
store_mt_results (mt_runf (op =$)) [("proof context one",
	concl o lprove_rule,
	¬(x:ONE) = y®,
	¬(x:ONE) = y®)];
store_mt_results mt_run_fail [("proof context one does not apply",
	lprove_rule,
	¬a ¤ a®,
	gen_fail_msg "lprove_rule" 76001 ["¬a ¤ a®"])];
=TEX
\subsection{Proof Context: ``combin''}
=SML
open_theory "combin";
set_pc "combin";
store_mt_results (mt_runf (op =$)) [("proof context combin",
	concl o lprove_rule,
	¬CombK T F®,
	¬CombK T F®)];
store_mt_results mt_run_fail [("proof context combin does not apply",
	lprove_rule,
	¬a ¤ a®,
	gen_fail_msg "lprove_rule" 76001 ["¬a ¤ a®"])];
=TEX
\subsection{Proof Context: ``sets$\_$alg''}
=SML
open_theory "sets";
set_pc "sets_alg";
store_mt_results (mt_runf (op =$)) [("proof context sets_alg",
	concl o lprove_rule,
	¬x  Universe®,
	¬x  Universe®)];
store_mt_results mt_run_fail [("proof context  does not apply",
	lprove_rule,
	¬a = b ´ {v | a} = {w | b}®,
	gen_fail_msg "lprove_rule" 76001 ["¬(a ¤ b) ´ {v|a} = {w|b}®"])];
=TEX
\subsection{Proof Context: ``sets$\_$ext''}
=SML
open_theory "sets";
set_pc "sets_ext";
store_mt_results (mt_runf (op =$)) [("proof context sets_ext",
	concl o lprove_rule,
	¬a = b ´ {v | a} = {w | b}®,
	¬a = b ´ {v | a} = {w | b}®)];
store_mt_results mt_run_fail [("proof context sets_ext does not apply a",
	lprove_rule,
	¬a ¤ a®,
	gen_fail_msg "lprove_rule" 76001 ["¬a ¤ a®"]),
	("proof context sets_ext does not apply b",
	lprove_rule,
	¬a ¡ b = b ¡ a®,
	gen_fail_msg "lprove_rule" 76001 ["¬a ¡ b = b ¡ a®"])];
=TEX
\subsection{Proof Context: ``hol''}
=SML
open_theory "hol";
set_pc "hol";
store_mt_results (mt_runf (op =$)) [("proof context hol",
	concl o lprove_rule,
	¬(x  a ¡ b) ¤ (x  b ¡ a)®,
	¬(x  a ¡ b) ¤ (x  b ¡ a)®)];
store_mt_results mt_run_fail [("proof context hol does not apply",
	lprove_rule,
	¬a ¡ b = b ¡ a®,
	gen_fail_msg "lprove_rule" 76001 ["¬a ¡ b = b ¡ a®"])];
=TEX
\subsection{Proof Context: ``hol1''}
=SML
open_theory "hol";
set_pc "hol1";
store_mt_results (mt_runf (op =$)) [("proof context hol1",
	concl o lprove_rule,
	¬a ¡ b = b ¡ a®,
	¬a ¡ b = b ¡ a®)];
store_mt_results mt_run_fail [("proof context hol1 does not apply",
	lprove_rule,
	¬F®,
	gen_fail_msg "lprove_rule" 76001 ["¬F®"])];
=TEX
=IGN
SPARE SPARE SPARE SPARE SPARE SPARE SPARE SPARE SPARE 
\subsection{Proof Context: ``''}
 =SML
set_pc "";
store_mt_results (mt_runf (op =$)) [("proof context ",
	concl o lprove_rule,
	¬®,
	¬®)];
store_mt_results mt_run_fail [("proof context  does not apply",
	lprove_rule,
	¬®,
	gen_fail_msg "lprove_rule" 76001 ["¬®"])];
=TEX
\subsection{End of Tests}
=SML
diag_string(summarize_mt_results());
=TEX
\end{document}


