=IGN
********************************************************************************
imp115.doc: this file is part of the ProofPower system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
=TEX
\documentclass[a4paper,12pt]{article}

%%%%% YOU CAN ADD OTHER PACKAGES AS NEEDED BELOW:
\usepackage{A4}
\usepackage{Lemma1}
\usepackage{ProofPower}
\usepackage{epsf}
\makeindex

\def\Title{ Implementation: Theory of Orderings }

\def\Abstract{\begin{center}
{\bf Abstract}\par\parbox{0.7\hsize}
{\small This document gives the implementation of a theory
of orderings that is used in constructing the representation
type for the real numbers in \ProductHOL.}
\end{center}}

\def\Reference{LEMMA1/HOL/IMP115}

\def\Author{R.D. Arthan}

\def\EMail{{\tt rda@lemma-one.com}}

\def\Phone{+44 118 958 4409}

\def\Fax{+44 118 956 1920}

%%%%% YOU MAY WANT TO CHANGE THE FOLLOWING TO GET A NICE FRONT PAGE:
\def\FrontPageTitle{ {\huge \Title } }
\def\FrontPageHeader{\raisebox{16ex}{\begin{tabular}[t]{c}
\bf Copyright \copyright\ : Lemma 1 Ltd \number\year\\\strut\\
\end{tabular}}}
\begin{centering}



\end{centering}

%%%%% THE FOLLOWING DEFAULTS WILL GENERALLY BE RIGHT:

\def\Version{$Revision: 1.1 $%
}
\def\Date{\FormatDate{$Date: 2000/12/05 16:21:10 $%
}}

%%%%% NOW BEGIN THE DOCUMENT AND MAKE THE FRONT PAGE

\begin{document}
\headsep=0mm
\FrontPage
\headsep=10mm

%%%%% STANDARD RED-TAPE SECTIONS (MAY WANT TO INTERLEAVE SOME \newpage COMMANDS IN THESE)

%%%%% CONTENTS:

\subsection{Contents}

\tableofcontents

%%%%% REFERENCES:

\newpage
\subsection{References}

\bibliographystyle{fmu}

%%%%% CHANGE THE FOLLOWING AS NECESSARY (E.G., TO PICK UP daz.bib):
{\raggedright
\bibliography{fmu}
}
%%%%% CHANGES HISTORY:
\subsection{Changes History}
\begin{description}
\item[Issues 1.1] First draft.
\item[Issue 1.2] Copyright and banner updates for open source release.
\end{description}

%%%%%  CHANGES FORECAST:

\subsection{Changes Forecast}

None.

%%%%% DISTRIBUTION LIST

\subsection{Distribution}

Lemma 1 build system.

\newpage

\section{Introduction}
\subsection{Scope}
See \cite{LEMMA1/HOL/DTD115}.

\subsection{Purpose and Background}
See \cite{DS/FMU/IED/HLD011}.
\section{PREAMBLE}
=SML
structure €Orders› : Orders = struct
=TEX
\section{THEOREMS}
We now prove some basic facts about the cuts construction.
The aim is to show that under suitable hypotheses on $X$
and $<<$, the set of cuts in $X$ ordered by strict set
inclusion will be a complete extension of $<<$ on $X$:
the {\em completion} of $<<$ on $X$.
We also want to show that dense subsets of $X$ give
rise to dense subsets of the completion.

The proofs nearly all proceed by expanding all definitions and
set theory notations and then carrying out the underlying
predicate calculus proofs.
=SML
val _ = open_theory"orders";
val €order_defs› = map get_spec(get_consts"-");
=TEX
=SML
val €down_sets_def› = get_spec ¨DownSetsÆ;
val €down_set_def› = get_spec¨DownSetÆ;
val €cuts_def› = get_spec¨CutsÆ;
val €complete_def› = get_spec¨CompleteÆ;
val €unbounded_below_def› = get_spec¨UnboundedBelowÆ;
val €unbounded_above_def› = get_spec¨UnboundedAboveÆ;
val €has_supremum_def› = get_spec¨$HasSupremumÆ;
val €upper_bound_def› = get_spec¨UpperBoundÆ;
val €dense_def› = get_spec¨DenseÆ;
val €dense_in_def› = get_spec¨$DenseInÆ;
val €linear_order_def› = get_spec¨LinearOrderÆ;
val €trich_def› = get_spec¨TrichÆ;
val €partial_order_def› = get_spec¨PartialOrderÆ;
val €trans_def› = get_spec¨TransÆ;
val €antisym_def› = get_spec¨AntisymÆ;
val €irrefl_def› = get_spec¨IrreflÆ;
=TEX
The ordering for the set of cuts will be strict
set inclusion. This is irreflexive without any hypotheses:
=SML
val _ = set_pc"sets_ext1";
=TEX
=SML
val €†_irrefl_thm› = (
set_goal([], ¨µV∑ Irrefl(V, $†)Æ);
a(rewrite_tac order_defs THEN REPEAT strip_tac);
save_pop_thm "†_irrefl_thm"
);
=TEX
Similarly strict set inclusion is antisymmetric without
any hypotheses:
=SML
val €†_antisym_thm› = (
set_goal([], ¨µV∑
	Antisym(V, $†)
Æ);
a(rewrite_tac order_defs THEN contr_tac THEN all_asm_fc_tac[]);
save_pop_thm "†_antisym_thm"
);
=TEX
Again transitivity requires no extra hypotheses:
=SML
val €†_trans_thm› = (
set_goal([], ¨µV∑ Trans(V, $†)Æ);
a(rewrite_tac order_defs THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(contr_tac THEN all_asm_fc_tac[] THEN all_asm_fc_tac[]);
save_pop_thm "†_trans_thm"
);
=TEX
Linearity certainly does not hold in general. We show that if $<<$ is transitive and trichotomous
on $X$, then strict inclusion is trichotomous on the cuts in $X$:

=SML
val €cuts_trich_thm› = (
set_goal([], ¨µX $<<∑ 
	Trans(X, $<<) ± Trich(X, $<<) ¥ Trich(Cuts(X, $<<), $†)Æ);
a(rewrite_tac order_defs THEN REPEAT strip_tac THEN_TRY
	SOLVED_T (contr_tac THEN all_asm_fc_tac[]));
(* *** Goal "1" *** *)
a(cases_tac ¨x''''''' << x''''''Æ THEN1 (all_asm_fc_tac[] THEN all_asm_fc_tac[]));
a(cases_tac ¨x''''''' = x''''''Æ THEN1 asm_rewrite_tac[]);
a(lemma_tac ¨x'''''' << x'''''''Æ THEN1 (all_asm_fc_tac[] THEN all_asm_fc_tac[]));
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(cases_tac ¨x''''' = x''''''Æ THEN1 all_var_elim_asm_tac);
a(lemma_tac ¨x''''' ç X ± x'''''' ç XÆ THEN1 (all_asm_fc_tac[] THEN REPEAT strip_tac));
a(list_spec_nth_asm_tac 21 [¨x'''''Æ, ¨x''''''Æ] THEN all_asm_fc_tac[]);
save_pop_thm "cuts_trich_thm"
);
=TEX
Now convenience packaging of the above for partial orders and linear orders:
=SML
val €cuts_partial_order_thm› = (
set_goal([], ¨µX $<<∑  PartialOrder(Cuts(X, $<<), $†)Æ);
a(pure_rewrite_tac [get_spec¨PartialOrderÆ] THEN 
	rewrite_tac[†_irrefl_thm, †_antisym_thm, †_trans_thm]);
save_pop_thm "cuts_partial_order_thm"
);
=TEX
=SML
val €cuts_linear_order_thm› = (
set_goal([], ¨µX $<<∑  LinearOrder(X, $<<) ¥ LinearOrder(Cuts(X, $<<), $†)Æ);
a(pure_rewrite_tac [get_spec¨LinearOrderÆ] THEN 
	rewrite_tac[cuts_partial_order_thm] THEN REPEAT strip_tac);
a(bc_thm_tac cuts_trich_thm THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 2 ante_tac THEN pure_rewrite_tac[get_spec¨PartialOrderÆ] THEN REPEAT strip_tac);
save_pop_thm "cuts_linear_orderthm"
);
=TEX

Perhaps surprisingly, completeness does hold in general for the cuts in $X$
without any additional hypotheses on the ordering $<<$. (One's first thought
might be that transitivity is required; however, in a sense, our definition of a cut
implicitly forms the transitive closure of $<<$ and so we do not need to assume $<<$
is transitive.)


=SML
val €cuts_complete_thm› = (
set_goal([], ¨µX $<<∑ Complete(Cuts(X, $<<), $†)Æ);
a(rewrite_tac order_defs THEN REPEAT strip_tac);
a(∂_tac¨ﬁAÆ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(spec_nth_asm_tac 9 ¨x'Æ);
a(∂_tac¨x''''Æ THEN REPEAT strip_tac);
a(∂_tac¨x'Æ THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(spec_nth_asm_tac 11 ¨sÆ);
a(spec_nth_asm_tac 4 ¨bÆ);
a(∂_tac¨cÆ THEN REPEAT strip_tac);
a(∂_tac¨sÆ THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(∂_tac¨x'''Æ THEN REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "5" *** *)
a(∂_tac¨sÆ THEN REPEAT strip_tac);
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "6" *** *)
a(∂_tac¨aÆ THEN REPEAT strip_tac);
(* *** Goal "7" *** *)
a(spec_nth_asm_tac 9 ¨aÆ);
a(∂_tac¨x''''Æ THEN REPEAT strip_tac);
a(∂_tac¨cÆ THEN REPEAT strip_tac);
(* *** Goal "8" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
save_pop_thm "cuts_complete_thm"
);
=TEX
Now we want to show that the downsets belonging to a subset $A$ of $X$
form a subset of the cuts. For this our hypotheses are that
$<<$ be irreflexive and transitive and that $A$ be unbounded
below and dense in $X$. The hypotheses on $A$ ensure that
the downsets are not empty and are not bounded above. These hypotheses
on $A$ could perhaps be weakened.
=SML
val €downsets_cuts_thm› = (
set_goal([], ¨µX $<< A∑ 
	A Ä X ± Irrefl(X, $<<) ± Trans(X, $<<) ± UnboundedBelow (A, $<<) ± A DenseIn (X, $<<) ¥
	DownSets(X, $<<, A) Ä Cuts(X, $<<)Æ);
a(rewrite_tac order_defs THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(LIST_GET_NTH_ASM_T [7] all_fc_tac);
a(LIST_GET_NTH_ASM_T [5] all_fc_tac);
a(∂_tac¨cÆ THEN asm_rewrite_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(POP_ASM_T ante_tac THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [9] all_fc_tac);
a(LIST_GET_NTH_ASM_T [6] all_fc_tac);
a(∂_tac¨aÆ THEN asm_rewrite_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(LIST_GET_NTH_ASM_T [7] all_fc_tac);
a(∂_tac¨x'Æ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
(* *** Goal "5" *** *)
a(LIST_GET_NTH_ASM_T [10] all_fc_tac);
a(DROP_NTH_ASM_T 4 ante_tac THEN asm_rewrite_tac[]);
a(REPEAT strip_tac THEN all_asm_fc_tac[]);
save_pop_thm "downsets_cuts_thm"
);
=TEX
Now we show that under suitable hypotheses (as for the previous theorem
but with antisymmetry instead of irreflexivity) the downsets belonging
to a dense subset $A$ are themselves dense in the completion.
In the proof, the assumptions tend to be rather over-productive if
we use forward chaining, so the specialisations are mostly done
individually.
=SML
val €downsets_dense_thm› = (
set_goal([], ¨µX $<<∑ 
	A Ä X ± Antisym(X, $<<) ± Trich(X, $<<) ±
	Trans(X, $<<) ± UnboundedBelow (A, $<<) ± A DenseIn (X, $<<) ¥
	DownSets(X, $<<, A) DenseIn (Cuts(X, $<<), $†)Æ);
a(rewrite_tac order_defs THEN REPEAT strip_tac);
a(spec_nth_asm_tac 7 ¨x'''''Æ);
a(spec_nth_asm_tac 11 ¨x'''''Æ);
a(spec_nth_asm_tac 12 ¨cÆ);
a(list_spec_nth_asm_tac 20 [¨x'''''Æ, ¨cÆ]);
a(∂_tac¨{v|v ç X ± v << a}Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(∂_tac¨aÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(spec_nth_asm_tac 23 ¨x''''''Æ);
(* *** Goal "3" *** *)
a(cases_tac¨x'''''' = aÆ THEN1 (all_var_elim_asm_tac THEN all_asm_fc_tac[]));
a(spec_nth_asm_tac 30 ¨aÆ);
a(spec_nth_asm_tac 25 ¨x''''''Æ);
a(list_spec_nth_asm_tac 30 [¨x''''''Æ, ¨aÆ]);
a(list_spec_nth_asm_tac 22 [¨x''''''Æ, ¨aÆ]);
a(list_spec_nth_asm_tac 23 [¨aÆ, ¨x'''''Æ]);
(* *** Goal "4" *** *)
a(∂_tac¨x'''''Æ THEN REPEAT strip_tac);
(* *** Goal "5" *** *)
a(spec_nth_asm_tac 30 ¨aÆ);
a(list_spec_nth_asm_tac 14 [¨cÆ, ¨aÆ]);
a(list_spec_nth_asm_tac 15 [¨aÆ, ¨x''''''Æ]);
(* *** Goal "6" *** *)
a(∂_tac¨cÆ THEN REPEAT strip_tac);
a(list_spec_nth_asm_tac 28 [¨aÆ, ¨cÆ]);
a(spec_nth_asm_tac 30 ¨aÆ);
save_pop_thm "downsets_dense_thm"
);
=TEX
When we use the above theorem, $<<$ will usually be a linear order, so we
derive this special case:
=SML
val €downsets_dense_thm1› = (
set_goal([], ¨µX $<<∑ 
	A Ä X ± LinearOrder(X, $<<) ± UnboundedBelow (A, $<<) ± A DenseIn (X, $<<) ¥
	DownSets(X, $<<, A) DenseIn (Cuts(X, $<<), $†)Æ);
a(rewrite_tac[get_spec¨LinearOrderÆ, get_spec¨PartialOrderÆ] THEN REPEAT strip_tac);
a(all_fc_tac[downsets_dense_thm]);
save_pop_thm "downsets_dense_thm1"
);
=TEX
Now we show that any superset of a dense subset is dense:
=SML
val €dense_superset_thm› = (
set_goal([], ¨µX $<<A B ∑ A Ä B ± B Ä X ± A DenseIn (X, $<<) ¥ B DenseIn (X, $<<)Æ);
a(rewrite_tac order_defs THEN REPEAT strip_tac);
a(all_asm_fc_tac[]);
a(∂_tac¨aÆ THEN all_asm_fc_tac[] THEN REPEAT strip_tac);
save_pop_thm "dense_superset_thm"
);
=TEX
As a corollary, if $X$ has a dense subset its ordering is dense:
=SML
val €dense_universe_thm› = (
set_goal([], ¨µX $<<A ∑ A Ä X ± A DenseIn (X, $<<) ¥ Dense(X, $<<)Æ);
a(rewrite_tac[get_spec¨DenseÆ] THEN REPEAT strip_tac);
a(bc_thm_tac dense_superset_thm);
a(∂_tac¨AÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
save_pop_thm "dense_universe_thm"
);
=TEX

Now we give a criterion for a downset to be a cut:
=SML
val €downset_cut_thm› = (
set_goal([], ¨µX $<< a∑ 
	a ç X ± Trans(X, $<<) ±
	UnboundedBelow(X, $<<) ± X DenseIn(X, $<<) ¥
		DownSet(X, $<<, a) ç Cuts(X, $<<) Æ);
a(rewrite_tac order_defs THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(LIST_GET_NTH_ASM_T [2] all_fc_tac);
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(LIST_GET_NTH_ASM_T [3] all_fc_tac);
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨aÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(all_asm_fc_tac[]);
save_pop_thm "downset_cut_thm"
);



=TEX
Now we give a criterion for one downset to be less than another
in the completion:
=SML
val €downsets_less_thm› = (
set_goal([], ¨µX $<< a b∑ 
	a ç X ± b ç X ± LinearOrder(X, $<<) ¥
		(DownSet(X, $<<, a) † DownSet(X, $<<, b) § a << b) Æ);
a(rewrite_tac order_defs THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(cases_tac¨x = aÆ THEN1 (all_var_elim_asm_tac THEN all_asm_fc_tac[]));
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨aÆ THEN contr_tac THEN all_asm_fc_tac[]);
save_pop_thm "downsets_less_thm"
);
=TEX
Now we show that the cuts are unbounded (above, resp. below) if
the underlying ordered set is linear and unbounded (above, resp. below):
=SML
val €cuts_unbounded_above_thm› = (
set_goal([], ¨µX $<<∑ 
	Irrefl(X, $<<) ± Trans(X, $<<) ±
	UnboundedAbove(X, $<<) ± X DenseIn(X, $<<) ¥
		UnboundedAbove(Cuts(X, $<<), $†) Æ);
a(rewrite_tac order_defs THEN REPEAT strip_tac);
a(spec_nth_asm_tac 8 ¨x'Æ);
a(∂_tac¨{t| t ç X ± t << c}Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "2" *** *)
a(LIST_GET_NTH_ASM_T [11] all_fc_tac);
a(contr_tac THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(∂_tac¨cÆ THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "5" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "6" *** *)
a(all_asm_fc_tac[] THEN all_asm_fc_tac[]);
(* *** Goal "7" *** *)
a(∂_tac¨x'Æ THEN REPEAT strip_tac);
a(contr_tac THEN all_asm_fc_tac[]);
save_pop_thm "cuts_unbounded_above_thm"
);
=TEX
=SML
val €cuts_unbounded_below_thm› = (
set_goal([], ¨µX $<<∑ 
	Irrefl(X, $<<) ± Trans(X, $<<) ±
	UnboundedBelow(X, $<<) ± X DenseIn(X, $<<) ¥
		UnboundedBelow(Cuts(X, $<<), $†) Æ);
a(rewrite_tac order_defs THEN REPEAT strip_tac);
a(spec_nth_asm_tac 6 ¨xÆ);
a(∂_tac¨{t| t ç X ± t << x}Æ THEN REPEAT strip_tac);
(* *** Goal "1" *** *)
a(spec_nth_asm_tac 9 ¨xÆ);
a(∂_tac¨cÆ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(LIST_GET_NTH_ASM_T [10] all_fc_tac);
a(∂_tac¨aÆ THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac);
(* *** Goal "4" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "5" *** *)
a(all_asm_fc_tac[]);
(* *** Goal "6" *** *)
a(∂_tac¨xÆ THEN REPEAT strip_tac THEN all_asm_fc_tac[]);
save_pop_thm "cuts_unbounded_below_thm"
);
=TEX
Now we show that a dense, complete subset of a unbounded, dense set must be the whole set:
=SML
val €dense_complete_subset_thm› = (
set_goal([], ¨µX $<< A ∑
	LinearOrder(X, $<<) ± A Ä X ± UnboundedAbove(X, $<<) ± UnboundedBelow(X, $<<) ±
	A DenseIn (X, $<<) ± Complete(A, $<<) ¥ A = XÆ);
a(rewrite_tac order_defs THEN REPEAT strip_tac THEN1 all_asm_fc_tac[]);
a(list_spec_nth_asm_tac 5 [¨xÆ]);
a(list_spec_nth_asm_tac 5 [¨xÆ, ¨cÆ]);
a(list_spec_nth_asm_tac 7 [¨{y | y ç A ± y << x} Æ, ¨aÆ]);
(* *** Goal "1" *** *)
a(list_spec_nth_asm_tac 10 [¨xÆ]);
a(list_spec_nth_asm_tac 11 [¨c'Æ, ¨xÆ]);
a(list_spec_nth_asm_tac 6 [¨a'Æ]);
(* *** Goal "2" *** *)
a(list_spec_nth_asm_tac 11 [¨bÆ, ¨xÆ] THEN all_asm_fc_tac[]);
(* *** Goal "3" *** *)
a(list_spec_nth_asm_tac 16 [¨a'Æ, ¨xÆ, ¨aÆ] THEN all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(LEMMA_T ¨x = yÆ asm_rewrite_thm_tac);
a(list_spec_nth_asm_tac 14 [¨yÆ]);
a(contr_tac THEN list_spec_nth_asm_tac 17 [¨xÆ, ¨yÆ]);
(* *** Goal "4.1" *** *)
a(list_spec_nth_asm_tac 14 [¨xÆ, ¨yÆ]);
a(list_spec_nth_asm_tac 7 [¨a'Æ]);
a(LIST_GET_NTH_ASM_T [23] all_fc_tac);
a(list_spec_nth_asm_tac 28 [¨a''Æ, ¨xÆ, ¨a'Æ]);
(* *** Goal "4.2" *** *)
a(list_spec_nth_asm_tac 14 [¨yÆ, ¨xÆ]);
a(list_spec_nth_asm_tac 8 [¨a'Æ]);
a(LIST_GET_NTH_ASM_T [21] all_fc_tac);
a(LIST_GET_NTH_ASM_T [26] all_fc_tac);
save_pop_thm "dense_complete_subset_thm"
);
=TEX
Now we consider orderings induced by a function mapping a type to an ordered set.
The three partial order properties are inherited by the induced orderings:

Irreflexivity:
=SML
val €induced_order_irrefl_thm› = (
set_goal([], ¨µX $<< f∑
	(µa∑f a ç X) ± Irrefl(X, $<<) ¥
	Irrefl(Universe, (Ãa b∑f a << f b))Æ);
a(rewrite_tac order_defs THEN REPEAT strip_tac);
a(POP_ASM_T bc_thm_tac THEN asm_rewrite_tac[]);
save_pop_thm "induced_order_irrefl_thm"
);
=TEX
Antisymmetry:
=SML
val €induced_order_antisym_thm› = (
set_goal([], ¨µX $<< f∑
	(µa∑f a ç X) ± Antisym(X, $<<) ¥
	Antisym(Universe, (Ãa b∑f a << f b))Æ);
a(rewrite_tac order_defs THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 2(ante_tac o list_µ_elim[¨f xÆ, ¨f yÆ]) THEN asm_rewrite_tac[]);
save_pop_thm "induced_order_antisym_thm"
);
=TEX
Transitivity:
=SML
val €induced_order_trans_thm› = (
set_goal([], ¨µX $<< f∑
	(µa∑f a ç X) ± Trans(X, $<<) ¥
	Trans(Universe, (Ãa b∑f a << f b))Æ);
a(rewrite_tac order_defs THEN REPEAT strip_tac);
a(GET_NTH_ASM_T 3 bc_thm_tac THEN ∂_tac¨f yÆ THEN asm_rewrite_tac[]);
save_pop_thm "induced_order_trans_thm"
);
=TEX
Linearity requires the function to be one-one:
=SML
val €induced_order_trich_thm› = (
set_goal([], ¨µX $<< f∑
	(µa∑f a ç X) ± OneOne f ± Trich(X, $<<) ¥
	Trich(Universe, (Ãa b∑f a << f b))Æ);
a(rewrite_tac (one_one_def::order_defs) THEN REPEAT strip_tac);
a(cases_tac¨f x = f yÆ THEN1 all_asm_fc_tac[]);
a(DROP_NTH_ASM_T 4 (ante_tac o list_µ_elim[¨f xÆ, ¨f yÆ]) THEN asm_rewrite_tac[]);
save_pop_thm "induced_order_trich_thm"
);
=TEX
We put the above pieces together to give convenience theorems for
partial and linear orders:
=SML
val €induced_partial_order_thm› = (
set_goal([], ¨µX $<< f∑
	(µa∑f a ç X) ± PartialOrder(X, $<<) ¥
	PartialOrder(Universe, (Ãa b∑f a << f b))Æ);
a(pure_rewrite_tac [get_spec¨PartialOrderÆ] THEN REPEAT strip_tac THEN
	all_fc_tac[induced_order_irrefl_thm, induced_order_antisym_thm, induced_order_trans_thm]);
save_pop_thm "induced_partial_order_thm"
);
=TEX
=SML
val €induced_linear_order_thm› = (
set_goal([], ¨µX $<< f∑
	(µa∑f a ç X) ± OneOne f ± LinearOrder(X, $<<) ¥
	LinearOrder(Universe, (Ãa b∑f a << f b))Æ);
a(pure_rewrite_tac [get_spec¨LinearOrderÆ] THEN REPEAT strip_tac THEN
	all_fc_tac[induced_partial_order_thm, induced_order_trich_thm]);
save_pop_thm "induced_linear_order_thm"
);
=TEX
Sufficient conditions for completeness are that the function
be one-one and that it map onto the ordered set:
=SML
val €induced_order_complete_thm› = (
set_goal([], ¨µX $<< f∑
	(µa∑f a ç X) ± OneOne f ± (µx∑x ç X ¥ ∂a∑x = f a) ± Complete(X, $<<) ¥
	Complete(Universe, (Ãa b∑f a << f b))Æ);
a(rewrite_tac (one_one_def::order_defs) THEN REPEAT strip_tac);
a(DROP_NTH_ASM_T 4
	(ante_tac o list_µ_elim[¨{s|s ç X ± ∂c∑c ç A ± s = f c}Æ, ¨f xÆ]) THEN
	asm_rewrite_tac[]);
a(contr_tac);
(* *** Goal "1" *** *)
a(swap_nth_asm_concl_tac 2 THEN REPEAT strip_tac);
a(∂_tac¨f x'Æ THEN REPEAT strip_tac THEN1 asm_rewrite_tac[]);
a(∂_tac¨x'Æ THEN REPEAT strip_tac);
(* *** Goal "2" *** *)
a(all_var_elim_asm_tac1);
a(swap_nth_asm_concl_tac 2 THEN REPEAT strip_tac);
a(LIST_GET_NTH_ASM_T [5] all_fc_tac);
a(∂_tac¨f c'Æ THEN asm_rewrite_tac[]);
a(∂_tac¨c'Æ THEN REPEAT strip_tac);
(* *** Goal "3" *** *)
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
(* *** Goal "4" *** *)
a(swap_nth_asm_concl_tac 1 THEN REPEAT strip_tac THEN rewrite_tac[]);
a(spec_nth_asm_tac 7 ¨yÆ THEN all_var_elim_asm_tac1);
a(∂_tac¨aÆ THEN REPEAT strip_tac);
(* *** Goal "4.1" *** *)
a(swap_nth_asm_concl_tac 3 THEN REPEAT strip_tac);
a(∂_tac¨f a'Æ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(∂_tac¨a'Æ THEN REPEAT strip_tac);
(* *** Goal "4.2" *** *)
a(swap_nth_asm_concl_tac 2 THEN REPEAT strip_tac);
a(∂_tac¨f y'Æ THEN asm_rewrite_tac[] THEN REPEAT strip_tac);
a(all_var_elim_asm_tac1 THEN all_asm_fc_tac[]);
save_pop_thm "induced_order_complete_thm"
);
=TEX
Sufficient conditions for a subset to be dense are that the function
be one-one and onto and that the subset map onto a dense subset of the ordered set:
=SML
val €induced_order_dense_thm› = (
set_goal([], ¨µX $<< f A ∑
	(µa∑f a ç X) ± OneOne f ± (µx∑x ç X ¥ ∂a∑x = f a) ±
	{x | ∂a∑ a ç A ± x = f a} DenseIn(X, $<<) ¥
	A DenseIn(Universe, (Ãa b∑f a << f b))Æ);
a(rewrite_tac (one_one_def::order_defs) THEN REPEAT strip_tac);
a(lemma_tac ¨f x ç X ± f y ç XÆ THEN1 asm_rewrite_tac[]);
a(LIST_GET_NTH_ASM_T [4] all_fc_tac THEN all_var_elim_asm_tac1);
a(∂_tac¨a'Æ THEN REPEAT strip_tac);
save_pop_thm "induced_order_dense_thm"
);
=TEX
Similarly for unboundedness (above and below):
=SML
val €induced_order_unbounded_above_thm› = (
set_goal([], ¨µX $<< f∑
	(µa∑f a ç X) ± OneOne f ± (µx∑x ç X ¥ ∂a∑x = f a) ± UnboundedAbove(X, $<<) ¥
	UnboundedAbove(Universe, (Ãa b∑f a << f b))Æ);
a(rewrite_tac (one_one_def::order_defs) THEN REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¨f bÆ THEN all_asm_fc_tac[]);
a(∂_tac ¨aÆ THEN all_var_elim_asm_tac1);
save_pop_thm "induced_order_unbounded_above_thm"
);
=TEX
=SML
val €induced_order_unbounded_below_thm› = (
set_goal([], ¨µX $<< f∑
	(µa∑f a ç X) ± OneOne f ± (µx∑x ç X ¥ ∂a∑x = f a) ± UnboundedBelow(X, $<<) ¥
	UnboundedBelow(Universe, (Ãa b∑f a << f b))Æ);
a(rewrite_tac (one_one_def::order_defs) THEN REPEAT strip_tac);
a(spec_nth_asm_tac 1 ¨f bÆ THEN all_asm_fc_tac[]);
a(∂_tac ¨aÆ THEN all_var_elim_asm_tac1);
save_pop_thm "induced_order_unbounded_below_thm"
);
=TEX
=TEX
\section{EPILOGUE}
=SML
end (* of structure Orders *);
open Orders;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex

\end{document}







