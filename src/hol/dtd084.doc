% dtd084.doc   %Z% $Date$ $Revision$ $RCSfile$

=TEX
% dtd084.doc   %Z% $Date$ $Revision$ $RCSfile$
\documentstyle[hol1,11pt,TQ]{article}

\TPPtitle{Detailed Design of Propositional Calculus with Equality Proof Procedures}
\def\TPPheadtitle{Detailed Design of Propositional Calculus with Equality\cr Proof Procedures}
\TPPref{DS/FMU/IED/DTD084}
\def\SCCSissue{$Revision$%
}
\TPPissue{\SCCSissue}
\TPPdate{\FormatDate{$Date$%
}}
\TPPproject{FST PROJECT}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Standard}
\TPPkeywords{HOL}
\TPPauthor{A.J. Hammon & WIN01}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{This document contains the detailed design of proof
	procedures for propositional calculus with equalities.}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library
}}

%\ftlinepenalty=9999
\makeindex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\underscoreoff

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\makeTPPfrontpage

\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{DOCUMENT CONTROL}

%********************************************************************

\subsection{Contents List}
\tableofcontents
% \listoftables

%********************************************************************

\subsection{Document Cross References}

\bibliographystyle{fmu}
\bibliography{fmu}

%********************************************************************

\subsection{Changes History}

\begin{description}

\item[\FormatDate{$Date$%
}, issue \SCCSissue~]
	Initial drafts.

%\item[\FormatDate{$Date$%
%}, issue \SCCSissue~]


\end{description}

%********************************************************************

%\subsection{Changes Forecast} \label{ChangesForecast}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{GENERAL}

%********************************************************************

\subsection{Scope}

This document contains the detailed design of the proof procedures for
propositional calculus with equality in the \Product{} system.  The high-level design
for this document in~\cite{DS/FMU/IED/HLD012}.

%********************************************************************

\subsection{Introduction}

%--------------------------------------------------------------------

\subsubsection{Purpose and Background}

We are concerned with supplying \Product{} with some simple facilities
to assist with equational reasoning.  There is an enormous body of
theory concerning rewrite systems, but we are only concerned with a
small and elementary part of it.  No doubt, more advanced techniques
such as the Knuth-Bendix completion algorithm could be of benefit in
\Product.  However, many problems which arise in practice require
nothing more than a more sophisticated approach to using equations
which are not quantified (i.e., from the point of view of the usual
theory of rewrite systems the variables in them act as constants).

As an example of a typical problem which requires more human
intervention than one would like, consider proving $x = y$ on the basis
of the equations $a = b$, $a = y$, and $b = x$. Without the sort of
support supplied in this document, this, while not difficult to do
requires some little thought.  Our main algorithm, therefore, is a
\Product{} solution to the following problem.

The proof procedures are implemented in~\cite{DS/FMU/IED/IMP084},
the module tests are in~\cite{DS/FMU/IED/HLD008}.

%--------------------------------------------------------------------

%\subsubsection{Dependencies}


%--------------------------------------------------------------------

%\subsubsection{Interface}


%--------------------------------------------------------------------

\subsubsection{Algorithms}

\paragraph{Decision Procedure for Quantifier-Free Rewriting}
Let
=INLINEFT
V = {v‰1, v‰2, ..., v‰m}
=TEX
\ be a set of $m$ variables.
Given a system, ‡, of $k$ equations,
=INLINEFT
x‰i = y‰i
=TEX
, where the
=INLINEFT
x‰i
=TEX
\ and
=INLINEFT
y‰i
=TEX
\ are variables drawn from and exhausting $V$, find
a system, „, of $m$ equations
=INLINEFT
v‰i = z‰i
=TEX
\ whose conjunction is logically equivalent to that
of ‡, and such that an equation
=INLINEFT
v‰i = v‰j
=TEX
\ is an equational consequence of ‡ iff. the equations in „ for
=INLINEFT
v‰i
=TEX
\ and
=INLINEFT
v‰j
=TEX
\ have the same right hand side.  (Here we say an equation is an
equational consequence of ‡ if  it can be derived from ‡ using only
the reflexivity, symmetry and transitivity of equality).

It is not hard to see that this problem is essentially the same as the
problem ``given the edges of a graph find its connected components''
and the algorithm we use is a relatively straightforward adaptation of
the graph-searching algorithm which naturally suggests itself,
(essentially Warshall's algorithm for finding the transitive closure of
a relation, see, e.g., \cite{Bornat79}).  Moreover, the algorithm can
conveniently be packaged as a canonicalisation function used to process
rewrite rules in \Product.

This decision procedure may readily be extended to give a decision
procedure for propositional logic with equality, and this is precisely
how the automatic proof procedures in the proof context defined in this
document works. The decision procedure may be described, in abstract
terms, as follows.

\begin{enumerate}
\vertbarfalse

\item
We are given a formulae, $A$ say, in the language of propositional
logic with equality. We can write $A$ as a conjunction of formulae of
the form:

=GFT
		A‰1 ± A‰2 ± ...  ´  ³B‰1 ² ³B‰2 ² ...
=TEX

where the
=INLINEFT
A‰i
=TEX
\ and
=INLINEFT
B‰i
=TEX
\ are atomic formulae (i.e. equations between variables). Since $A$ is
provable iff. each of the conjuncts is, we may assume without loss of
generality that $A$ has this form.


\item
We now apply the decision procedure for quantifier-free rewriting
to the equations
=INLINEFT
A‰i
=TEX
\ to give a system of equations,
=INLINEFT
A‰j'
=TEX
\ such that
=INLINEFT
A‰1 ± A‰2 ± ... ¤ A‰1' ± A‰2' ± ...
=TEX
\ and such that for any equation, $a = b$, with $a$ and $b$ variables,
the formula
=INLINEFT
A‰1' ± A‰2' ± ... ´ a = b
=TEX
\ is provable iff. the
=INLINEFT
A‰j'
=TEX
\ include equations of the form $a = x$ and $b = x$.
Let $A'$ be the formula:

=GFT
		A‰1' ± A‰2' ± ...  ´  ³B‰1 ² ³B‰2 ² ...
=TEX

Then by the above remarks
=INLINEFT
A ¤ A'
=TEX
.



\item
Now, using the fact that, for any formulae $C$ and variables $a$ and $b$,
=INLINEFT
ô a = b ´ C ¤ a = b ´ C[b/a]
=TEX
, we can prove
=INLINEFT
A' ¤ A''
=TEX
, where $A''$ has the form:

=GFT
		A‰1' ± A‰2' ± ...  ´  ³B‰1' ² ³B‰2' ² ...
=TEX

where, for each $i$, if 
=INLINEFT
B‰i
=TEX
\ is
=INLINEFT
v = u
=TEX
\ then
=INLINEFT
B‰i'
=TEX
\ is
=INLINEFT
v' = u'
=TEX
\ where $v'$ is $x$ if an equation
=INLINEFT
v' = x
=TEX
\ appears amongst the
=INLINEFT
A‰j'
=TEX
, and is $v$ otherwise, and similarly for $u'$.



\item
Now $A''$ is provable iff. some
=INLINEFT
B‰i'
=TEX
\ has the form
=INLINEFT
x = x
=TEX
, since {\em(i)} if some
=INLINEFT
B‰i'
=TEX
\ has this form then $A''$ is certainly provable by reflexivity, and
{\em(ii)} if no
=INLINEFT
B‰i'
=TEX
\ has this form, we can construct an interpretation, $I$, whose
universe is the set of all variables which appear either on the
right-hand side of some equation
=INLINEFT
A‰j'
=TEX
\ or on either side of some
=INLINEFT
B‰i'
=TEX
, and in which a variable $x$ is interpreted as $y$ if some
=INLINEFT
A‰j'
=TEX
\ is $x = y$, or as itself otherwise. Then $A''$, and so also $A$, is not
valid with respect to this interpretation, so $A$ cannot be provable.

\end{enumerate}


The good thing about the above procedure is that, given a
canonicalisation function acting as a decision procedure for
quantifier-free rewriting, its implementation in \Product{} is more
straightforward than the above description. The first step is little
more than
=INLINEFT
REPEAT strip_tac
=TEX
\, the rest is applying the canonicalisation function to the equational
assumptions and rewriting the other assumptions with the result.

This proof procedure may fail to prove some problems involving finite sets

%--------------------------------------------------------------------

%\subsubsection{Possible Enhancements}
%\subsubsection{Deficiencies}
%\subsubsection{Terminology}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{SIGNATURE} \label{StartSignature}

=DOC
signature ÛPropositionalEqualityÝ = sig
=DESCRIBE
This is the signature of a structure containing proof procedures for
propositional calculus with equalities.
=ENDDOC

%--------------------------------------------------------------------
=DOC
val Ûprop_eq_ruleÝ : THM list -> THM list * THM list;
=DESCRIBE
Given a list of theorems of the form %
=INLINEFT
¬ a‰i = b‰i ®
=TEX
{} for various $a‰i$ and $b‰i$ this function produces a set of
theorems that equate all members of each equivalence class to a common
value.  The equivalence classes are the sets of all $a‰i$ and $b‰i$
that are equated either directly or transitively, they comprise terms
that are $\alpha$-convertable rather than requiring strict equality.
For each of the equivalence classes a set of theorems equating each
term in the class to the ``simplest'' (see below) term in the class is
generated.  These new theorems have the simplest term as their right
hand comparand, duplicated theorems and identity theorems are
excluded.  The first list in the result tuple contains the new theorems
from all of the equivalence classes.  The second list in the result
tuple is any of the argument theorems which were not equalities.  The
new theorems are intended to be used as arguments for a rewriting
operation.

The choice of the ``simplest'' term is intended to give the most useful
rewriting theorems and those which are least likely to loop.  HOL
constants are considered the most simple, variables next.  Functional
applications and lamdba abstractions are considered the most complex.
A simple recursive counting function is used to traverse each term to
evaluate its complexity.  Function $term_order$ (q.v.) is used when the
counting function cannot decide.
=FAILURE
84002	Design error: some equalities left over
=ENDDOC
%--------------------------------------------------------------------

The specification of counting function mentioned above is deliberately
vague, however its body is as follows.  The code is included here to
allow comments upon the weights it uses, the intention is to remove the
code from this detailed design before its first proper issue.

=GFT
fun Ûterm_valueÝ(tm:TERM) : int = (
	case dest_simple_term tm
	of Const _ => 1
	| Var _ => 2
	| App (t1, t2) => 3 + (term_value t1) + (term_value t2)
	| SimpleÌ (t1, t2) => 4 + (term_value t1) + (term_value t2)
);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TACTICS AND TACTICALS}

%--------------------------------------------------------------------
=DOC
val Ûprop_eq_prove_tacÝ : THM list -> TACTIC;
=DESCRIBE
This tactic is an automatic proof procedure appropriate to the current
proof context, it aims to solve problems which may be solved by
reasoning in the propositional calculus with equalities.

The tactic has the following steps:
{\em(i)}~It applies $contr_tac$ to increase the stock of assumptions.
{\em(ii)}~It splits all of the assumptions into two groups, those which
	are equalities and those which are not.
{\em(iii)}~Using the equality assumptions and the given theorems, a new
	set of theorems are produced which equate all members of an
	equivalence classes to a common member of the class.
{\em(iv)}~It rewrites all of the other assumptions with these new
	theorems.
{\em(v)}~It strips the rewritten assumptions and the equality
	assumptions from step~{\em(ii)} back into the goal.
=ENDDOC
%--------------------------------------------------------------------

%--------------------------------------------------------------------
=DOC
val ÛASM_PROP_EQ_TÝ : (THM list -> TACTIC) -> THM list -> TACTIC
val ÛPROP_EQ_TÝ : (THM list -> TACTIC) -> THM list -> TACTIC
=DESCRIBE
These are theorem tacticals which process the argument theorems and the
assumptions before calling the argument theorem tactic.  A call of
``$ASM_PROP_EQ_T\;thm_tac\;thms$'' takes $thms$ plus theorems
representing any equalities from the assumptions, these are
cannonicalised by the rewriting canon of the current proof context,
then processed by $prop_eq_rule$ (q.v.) to form the arguments passed to
function $thm_tac$.  The order of the assumptions may be changed.
Tactical $PROP_EQ_T$ does not use the assumptions.
=USES
With the rewriting tactics.
=ENDDOC
%--------------------------------------------------------------------

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{CONVERSIONS}

%--------------------------------------------------------------------
=DOC
	val Ûpair_eq_convÝ : CONV
=DESCRIBE
This conversion transforms equalities involving pairs and the constants
$Fst$ and $Snd$ into a simpler form by using the first match found in
the following rules:
=GFT
Fst(a,b) = x		­	a = x
Snd(a,b) = y		­	b = y
x = Fst(a,b)		­	x = a
y = Snd(a,b)		­	y = b
(a,b) = (c,d)		­	a = c ± b = d
(a,b) = z		­	a = Fst z ± b = Snd z
z = (a,b)		­	Fst z = a ± Snd z = b
z = w			­	Fst z = Fst w ± Snd z = Snd w
=TEX
=USES
The conversion is intended for use in tactic and conversion
programming.  It is usefully applied before using $prop_eq_prove_tac$
or $ASM_PROP_EQ_T$ (q.v.). {} The normal interactive interface is via
rewriting or stripping in the proof context
HERE
=FAILURE
84001	?0 is not an equality involving pairs
=ENDDOC

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{THE PROOF CONTEXTS}

%--------------------------------------------------------------------
=DOC
(* Proof Context: Ûprop_eqÝ *)
=DESCRIBE
This is a proof context whose purpose is to supply a decision
procedure for problems involving sets of equalities and the
propositional calculus.
\paragraph{Contents}
The rewriting, theorem stripping and conclusion stripping components
are as for the proof context $predicates$ (q.v.). {}
The automatic proof tactic works by
{\em(i)}~applying $contr_tac$,
{\em(ii)}~splitting all of the assumptions into two groups, those which
	are equalities and those which are not,
{\em(iii)}~producing a set of theorems that rewrite all members of each
	equivalence classes in the equality assumptions to a common
	member of the class,
{\em(iv)}~rewriting all of the other assumptions with these equivalence
	class rewrite theorems,
{\em(v)}~stripping the rewritten theorems and assumptions back into
	the goal.
The automatic proof conversion just tries to prove its argument, $t$ say, using
the automatic proof tactic and returns $t = T$ if it succeeds.
=ENDDOC
%--------------------------------------------------------------------

%--------------------------------------------------------------------
=DOC
(* Proof Context: Û'prop_eqÝ *)
=DESCRIBE
This is a component proof context whose purpose is to
supply a decision
procedure for problems involving sets of equalities and the
propositional calculus.
\paragraph{Contents}
The automatic proof components are as for $prop_eq$. {}
Other components are blank.
=ENDDOC
%--------------------------------------------------------------------

%--------------------------------------------------------------------
=DOC
(* Proof Context: Ûprop_eq_pairÝ *)
=DESCRIBE
This is a proof context whose main purpose is to supply a decision
procedure for problems involving sets of equalities, the
propositional calculus and pairing.
\paragraph{Contents}
The rewriting, theorem stripping and conclusion stripping components
are as for the proof context $predicates$, q.v., each augmented with
conversions effecting the following transformations:
=GFT
Fst(a,b) = x		­	a = x
Snd(a,b) = y		­	b = y
x = Fst(a,b)		­	x = a
y = Snd(a,b)		­	y = b
(a,b) = (c,d)		­	a = c ± b = d
(a,b) = z		­	a = Fst z ± b = Snd z
z = (a,b)		­	Fst z = a ± Snd z = b
z = w			­	Fst z = Fst w ± Snd z = Snd w
=TEX
The automatic proof tactic works by
{\em(i)}~applying $contr_tac$,
{\em(ii)}~splitting all of the assumptions into two groups, those which
	are equalities and those which are not,
{\em(iii)}~producing a set of theorems that rewrite all members of each
	equivalence classes in the equality assumptions to a common
	member of the class,
{\em(iv)}~rewriting all of the other assumptions with these equivalence
	class rewrite theorems,
{\em(v)}~stripping the rewritten theorems and assumptions back into
	the goal.
The automatic proof conversion just tries to prove its argument, $t$ say, using
the automatic proof tactic and returns $t = T$ if it succeeds.
=ENDDOC
%--------------------------------------------------------------------

%--------------------------------------------------------------------
=DOC
(* Proof Context: Û'prop_eq_pairÝ *)
=DESCRIBE
This is a component proof context whose purpose is to
supply a decision
procedure for problems involving sets of equalities, the
propositional calculus and pairing.
\paragraph{Contents}
The automatic proof components are as for $prop_eq_pair$. {}
Other components are blank.
=ENDDOC
%--------------------------------------------------------------------


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{FINALE}

=DOC
end (* of signature PropositionalEquality *);
=ENDDOC

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{TEST POLICY}

A statement of the general principle of testing to be adopted is given
in~\cite{DS/FMU/IED/PLN008}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%********************************************************************
%--------------------------------------------------------------------

\makeatletter
\def\refstepcounter#1{\stepcounter{#1}\global\edef\@currentlabel{\csname
	p@#1\endcsname\csname the#1\endcsname}}
\makeatother

%\twocolumn[\section{INDEX}] \label{Index}
\section{INDEX}

\footnotesize
\printindex

\onecolumn

\end{document}


