=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design for Derived Terms}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for Derived Terms}
\TPPref{DS/FMU/IED/DTD004}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for functions concerning derived terms that are not used in defining the type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
Based on part of \cite{DS/FMU/IED/SML002}.
\item [Issue 1.2]
Fixed a duplicate error message, and ordered an index to be printed.
\item [Issue 1.3, 1.4]
Changes made during implementation of this documents designs.
\item [Issue 1.5]
Removed $mk\_fun\_type$ (as now $mk\_funtype$ in \cite{DS/FMU/IED/DTD003}).
Corrected examples for $mk\_let$.
Improved error messages.
\item [Issue 1.6]
Modified in line with changes in issue 1.9 of \cite{DS/FMU/IED/DTD003}.
The type $DERIV\_TERM$ becomes $DEST\_TERM$.
\item [Issue 1.7]
Added $mk\_empty\_$ for $enum\_set$ and $list$.
\item [Issue 1.8]
Added constructors, etc, for $Ñ_1$, $T$ and $F$.
Corrected some examples.
\item [Issue 1.9]
Redesigned $strip\_binder$, added $strip\_simple\_binder$.
Changed $?\_T$ and $?\_F$ to $?\_t$ and $?\_f$.
Added $strip\_simple\_Ñ$ and $strip\_simple\_É$.
\item [Issue 1.10]
Fixed some typos.
\item [Issue 1.11,1.12,1.13]
Changes in response to inspection ID0017.
\item [Issue 1.14]
Corrected typos.
\item [Issue 1.15]
Changes after comments upon issue 1.14 compared to ID0017.
Renamings of functions containing the name atom $simple$,
and renaming of $aconv$.
\end{description}
% \subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document gives the detailed design of the subsystem TypesAndTerms called for in  \cite{DS/FMU/IED/HLD007}.

The high-level specification for some of the code may be considered
to be given in \cite{DS/FMU/IED/SPC001}.
The design is
implemented in \cite{DS/FMU/IED/IMP004}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design of certain derived terms of ICL HOL, and functions to handle them.
\subsubsection{Dependencies}
Loading this document is dependent on \cite{DS/FMU/IED/IMP003}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Terminology}
In may be necessary when using the following terminology to remove ambiguity by prefixing some of the following with the word ``term'' or ``HOL''.
This will prevent confusions with 
Standard ML terminology, or, for instance, theorems
whose conclusions are describable in the same terms.

\begin{tabular}{p{1.3in} p{4.9in}}
pair & A term of the form $ª(x,\ y)º$, as constructed by $mk\_pair$: a tuple of two elements. \\
pair type & A HOL type of the form $ª:ty_1\ â\ ty_2º$, as constructed by $mk\_â\_type$: an instance of the HOL type of pairs. \\
conjunction & A term of the form $ªx\ Ä\ yº$, as constructed by $mk\_Ä$. \\
disjunction & A term of the form $ªx\ Å\ yº$, as constructed by $mk\_Å$. \\
negation & A term of the form $ªå xº$, as constructed by $mk\_å$. \\
bi-implication & A term of the form $ªx\ Ç\ yº$, as constructed by $mk\_Ç$. \\
conditional & A term of the form $ªif\ x\ then\ y\ else\ zº$, as constructed by $mk\_if$. \\
$let$-term & A term of the form $ªlet\ x\ =\ y\ in\ z[x]º$, as constructed by $mk\_let$: it provides local definition within a term. \\
enumerated set & A term of the form
$ª{a,\ b,\ ...}º$, as constructed by $mk\_enum\_set$: a set defined by the enumeration of its elements. \\
set comprehension & A term of the form
$ªSetComp\ x\ é\ P[x]º$, as constructed by $mk\_set\_comp$: a set defined to be those elements of a type that satisfy a predicate. \\
list-term & A term of the form $ª[a,\ b,\ ...]º$, as constructed by $mk\_list$: a list within the HOL object language. \\
$Ñ_1$-term & A term of the form $ªÑ_1\ x\ é\ P[x]º$ or $ªÑ_1\ (x,y)\ é\ P[x,y]º$, as constructed by $mk\_simple\_Ñ_1$ or $mk\_Ñ_1$. \\
$á$-term & A term of the form $ªá\ x\ é\ P[x]º$, as constructed by $mk\_á$: a choice from those elements of a type that satisfy a predicate. \\
an allowed variable structure & A term composed from variables and pairing operations, as allowed by the ICL HOL concrete syntax. \\
\end{tabular}

=TEX
=TEX
\section{DERIVED TERMS}
=DOC
signature ‚TypesAndTerms· = sig
=DESCRIBE
This provides various functions on derived $TERM$s, which are not considered necessary to create the abstract data type $THM$.
It also contains, by inclusion, the types, and functions on the types $TERM$ and $TYPE$ from structure $icl'TypesAndTerms$(q.v.).
=ENDDOC
We wish to have this signature as the one source of type and term functions, to allow a seamless movement of items from
this signature to $icl'TypesAndTerms$.
=SML
include icl'TypesAndTerms;
=TEX
\subsection{Destroyed Terms}
The following data type may act as a summary of all of the derived term constructors
provided by this document and \cite{DS/FMU/IED/DTD003},
which are in turn called for by \cite{DS/FMU/IED/HLD007}.
The names of those constructors may be derived from these value constructors by stripping off ``D'', making the
names lower case and using $\_$ as a separator for different atoms in a name, if appropriate, and prefixing each result by ``mk$\_$''.
The value constructors also follow the same typing of their single arguments
as the constructors.
=DOC
datatype ‚DEST_TERM· = ‚DVar· of string * TYPE |
	‚DConst· of string * TYPE |
	‚DApp· of TERM * TERM |
	‚Dç· of TERM * TERM |
	‚DEq· of TERM * TERM |
	‚Dä· of TERM * TERM |
	‚DT· |
	‚DF· |
	‚Då· of TERM |
	‚DPair· of TERM * TERM |
	‚DÄ· of TERM * TERM |
	‚DÅ· of TERM * TERM |
	‚DÇ· of TERM * TERM |
	‚DLet· of ((TERM * TERM)list * TERM) |
	‚DEnumSet· of TERM list |
	‚D§· of TYPE |
	‚DSetComp· of TERM * TERM |
	‚DList· of TERM list |
	‚DEmptyList· of TYPE |
	‚DÉ· of TERM * TERM |
	‚DÑ· of TERM * TERM |
	‚DÑ%down%1· of TERM * TERM |
	‚Dá· of TERM * TERM |
	‚DIf· of (TERM * TERM * TERM);
=DESCRIBE
This type is that of a term destroyed using the appropriate derived destructor functions (e.g. $dest\_eq$) as well as the primitive ones.
The type given to $D§$ and $DEmptyList$ is the type of an element of the associated set or list.
The type is related to $TERM$ by $mk\_term$ (q.v.) and $dest\_term$ (q.v)
=SEEALSO
$DEST\_SIMPLE\_TERM$
=ENDDOC
=DOC
val ‚dest_term· : TERM -> DEST_TERM
=DESCRIBE
This function returns the ``best'' interpretation of a term in the form of an object of type $DEST\_TERM$.
E.g. it will return $DEq(\ 1\ 2)$ rather than $DComb ((\$=\ 1), 2)$.
It will also use the paired abstraction forms of functions in preference to the simple forms, e.g., it uses $dest\_ç$ not $dest\_simple\_ç$.

The function assumes that the name of a constant is sufficient
to identify it without checking the type, as with, e.g., $dest\_bin\_op$(q.v).
=SEEALSO
$mk\_term$
=ENDDOC
=DOC
val ‚mk_term· : DEST_TERM -> TERM
=DESCRIBE
Create a term from a derived term.
It is an inverse to $dest\_term$ (q.v), and therefore understands how to handle paired abstractions.

The function is implemented using the individual primitive and derived term constructors (e.g. $mk\_const$ and $mk\_É$), with what checks they use.
=FAILUREC
\paragraph{Failure}
This function will fail with the same messages as the appropriate term construction functions.
=ENDDOC
\subsection{Boolean Constants}
=DOC
val ‚mk_t· : TERM;
=DESCRIBE
The term $ªT : BOOLº$.
=ENDDOC
=DOC
val ‚is_t· : TERM -> bool;
=DESCRIBE
Return true only when the term is $ªT : BOOLº$, and false otherwise: no exceptions can be raised.
=ENDDOC
=DOC
val ‚mk_f· : TERM;
=DESCRIBE
The term $ªF : BOOLº$.
=ENDDOC
=DOC
val ‚is_f· : TERM -> bool;
=DESCRIBE
Return true only when the term is $ªF : BOOLº$, and false otherwise: no exceptions can be raised.
=ENDDOC
Destructor and list versions of these functions are not necessary.
\subsection{Generic Binder Functions}
The following provide a standard pattern for implementing
constructor and destructor functions for binders.
=DOC
val ‚mk_binder· : string -> int -> (TYPE -> TYPE -> TERM) ->
	(TERM * TERM) -> TERM;
=DESCRIBE
A generic method of implementing binder constructor functions:
ÛDefinition
mk_binder area msg binder_nm (ªvarstructº, ªbodyº) = 
	ªbinder'(ç varstruct é body)º
Ê
$binder'$ is formed by applying $binder$ to the types of the 
$varstruct$ and $body$.
The $varstruct$ may be any term that follows the syntax of \cite{DS/FMU/IED/DEF001}.
=SEEALSO
$mk\_simple\_binder$
=FAILURE
4016	?0 is not an allowed variable structure
=FAILUREC
\paragraph{Failure}
If the term cannot be made, then the error will be from $area$, with a message indexed by $msg$.
If the first term argument is not an allowed variable structure
then failure 4016 is raised from area $area$.
=ENDDOC
=DOC
val ‚dest_binder· : string -> int -> string -> TERM -> TERM * TERM;
=DESCRIBE
A generic method of implementing binder destructor functions:
ÛDefinition
dest_binder area msg binder_nm ªbinder(ç varstruct é body)º = 
	(ªvarstructº, ªbodyº)
Ê
where $binder$ is a constant whose name is $binder\_nm$.
The $varstruct$ may be any allowed variable structure.
=SEEALSO
$dest\_simple\_binder$
=FAILUREC
\paragraph{Failure}
If the term cannot be destroyed, then the error will be from $area$, with a message indexed by $msg$.
=ENDDOC
=DOC
val ‚is_binder· : string -> TERM -> bool;
=DESCRIBE
$is\_binder$ $binder\_nm$ $tm$ returns true only when $tm$
has the form $ªbinder(ç\ vs\ é\ body)º$,
where $binder$ is a constant whose name is $binder\_nm$,
and $vs$ an allowed variable structure,
and flase otherwise.
It cannot raise an exception.
=SEEALSO
$is\_simple\_binder$
=ENDDOC
=DOC
val ‚strip_binder· : string -> TERM -> TERM list * TERM;
=DESCRIBE
$strip\_binder$ $binder$ applied to 
\[ªbinder(ç vs_1 é binder(ç vs_2 é \ldots é body)\ldots)º\]
will return
\[[ªvs_1º, ªvs_2º, \ldots], ªbodyº\]
where the $vs_i$ are allowed variable structures.
The function acts as $dest\_binder$ (q.v), and will handle paired abstraction terms.
It will return an empty list and the original term if the
supplied term is not formed using the binder.
=SEEALSO
$strip\_simple\_binder$
=ENDDOC
=DOC
val ‚strip_simple_binder· : string -> TERM -> TERM list * TERM;
=DESCRIBE
$strip\_simple\_binder$ $binder$ applied to 
\[ªbinder(ç v_1 é binder(ç v_2 é \ldots é body)\ldots)º\]
will return
\[[ªv_1º, ªv_2º, \ldots], ªbodyº\]
where the $v_i$ are simple variables.
The function acts as $dest\_simple\_binder$ (q.v), and will not handle paired abstraction terms.
It will return an empty list and the original term if the
supplied term is not formed using the binder.
=SEEALSO
$strip\_binder$
=ENDDOC
=DOC
val ‚list_mk_binder· : (TERM * TERM -> TERM) -> (TERM list * TERM) -> TERM;
=DESCRIBE 
If $maker$ $(ªvsº,ªbº)$ makes an abstraction $ªbind\ vs\ é\ bº$,
then
$list\_mk\_binder$ $maker$ $([ªvs_1º, ªvs_2º, \ldots],ªbodyº)$
returns
\[ªbind\ vs_1 é bind\ vs_2 é \ldots é bodyº\]
Notice that this can be used for implementing both simple and paired abstractions, with the $vs_i$ being variable structures when so allowed, and otherwise variables.
=ENDDOC
\subsection{Pairs}
=DOC
val ‚mk_â_type· : (TYPE * TYPE) -> TYPE
=DESCRIBE
$mk\_â\_type$ $(ª:ty_1º, ª:ty_2º)$ returns a pair type: $ª:ty_1\ â\ ty_2º$.
=ENDDOC
=DOC
val ‚dest_â_type· : TYPE -> (TYPE * TYPE)
=DESCRIBE
$dest\_â\_type$ $ª:ty_1\ â\ ty_2º$ returns $(ª:ty_1º, ª:ty_2º)$.
=FAILURE
4018	?0 is not of the form ª:ty1 â ty2º
=ENDDOC
=DOC
val ‚is_â_type· : TYPE -> bool;
=DESCRIBE
Return true only when the type is a pair type, i.e. of the form: $ª:ty_1\ â\ ty_2º$, and false otherwise: no exceptions can be raised.
=ENDDOC
=DOC
val ‚mk_pair· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating pairs.
ÛDefinition
mk_pair(ªt1º, ªt2º) = ª(t1, t2)º
Ê
=ENDDOC
It should always be possible to form a pair, but the implementation method gives a hook for a possible error so:
=FAILURE
4033	DESIGN ERROR : failed to form a pair from ?0 and ?1
=TEX
=DOC
val ‚dest_pair· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for pairs.
ÛDefinition
dest_pair ª(t1, t2)º = (ªt1º, ªt2º)
Ê
=FAILURE
4003	?0 is not of form: ª(t1,t2)º
=ENDDOC
=DOC
val ‚is_pair· : TERM -> bool;
=DESCRIBE
Return true only when the term is a pair, and false otherwise: no exceptions can be raised.
=ENDDOC
\subsection{(Paired) ç-abstractions}
=DOC
val ‚mk_ç· : TERM * TERM -> TERM
=DESCRIBE
This creates a $ç$-abstraction of an allowed variable structure from a term.
=EXAMPLE
mk_ç (ªxº , ªx + yº) = ªç x é x + yº
mk_ç (ª(x, y)º, ªx + yº) = ªç (x, y) é x + yº
mk_ç (ª((x1,x2), (y1,y2))º, ªx2 + y2º) = ªç ((x1,x2), (y1,y2)) é x2 + y2º
=SEEALSO
$mk\_simple\_ç$
=FAILURE
4016	?0 is not an allowed variable structure
=ENDDOC
=DOC
val ‚dest_ç·: TERM -> (TERM * TERM);
=DESCRIBE
Destroys a $ç$-abstraction.
It can destroy paired $ç$-abstractions, being an inverse of $mk\_ç$.
ÛDefinition
dest_ç ªç vs é tº = (ªvsº, ªtº)
Ê
=SEEALSO
$dest\_simple\_ç$
=FAILURE
4002	?0 is not of form: ªç vs é tº
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val ‚is_ç· : TERM -> bool;
=DESCRIBE
This function returns true iff. the term is of the form $ªç\ vs\ é\ tº$.
It cannot raise exceptions.
=SEEALSO
$is\_simple\_ç$
=ENDDOC
=DOC
val ‚list_mk_ç· : (TERM list * TERM) -> TERM;
=DESCRIBE
Repeatedly $ç$-abstract from a term.
ÛDefinition
list_mk_ç ([ªaº,ªbº,ªcº,...], ªbodyº) = ªç a b c ... é bodyº
Ê
This function is implemented using $mk\_ç$, not $mk\_simple\_ç$.
=SEEALSO
$list\_mk\_simple\_ç$
=FAILUREC
\paragraph{Failure}
May give rise to the error message from $mk\_ç$.
=ENDDOC
=DOC
val ‚strip_ç· : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a multiple $ç$-abstraction.
ÛDefinition
strip_ç ªç a b c ... é bodyº = [ªaº,ªbº,ªcº,...], ªbodyº
Ê
This uses $dest\_ç$ (q.v.) rather than $dest\_simple\_ç$.
=ENDDOC
\subsection{Conjunctions}
=DOC
val ‚mk_Ä· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating conjunctions.
ÛDefinition
mk_Ä (ªt1º, ªt2º) = ªt1 Ä t2º
Ê
=FAILURE
3015	?1 is not of type ª:BOOLº
3031	?0 is not of type ª:BOOLº
=ENDDOC
Message 3015, when processed, throws away its first argument:
this is so because of the implementation of $mk\_bin\_op$.
=DOC
val ‚dest_Ä· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for conjunctions.
ÛDefinition
dest_Ä  ªt1 Ä t2º = (ªt1º, ªt2º)
Ê
=FAILURE
4032	?0 is not of form: ªt1 Ä t2º
=ENDDOC
=DOC
val ‚is_Ä· : TERM -> bool;
=DESCRIBE
Return true only when the term is a conjunction, and false otherwise: no exceptions can be raised.
=ENDDOC
=DOC
val ‚list_mk_Ä· : TERM list -> TERM;
=DESCRIBE
Conjoin a list of terms:
ÛDefinition
list_mk_Ä [ªaº, ªbº, ªcº,...] = ªa Ä b Ä c ...º
Ê
=FAILURE
3017	An empty list argument is not allowed
3031	?0 is not of type ª:BOOLº
=ENDDOC
=DOC
val ‚strip_Ä· : TERM -> TERM list
=DESCRIBE
Break a term into its constituent conjuncts, descending recursively only to the right.
=EXAMPLE
strip_Ä ªa Ä (b Ä c) Ä dº = [ ªaº,ªb Ä cº, ªdº]
=ENDDOC
\subsection{Disjunctions}
=DOC
val ‚mk_Å· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating disjunctions.
ÛDefinition
mk_Å (ªt1º, ªt2º) = ªt1 Å t2º
Ê
=FAILURE
3015	?1 is not of type ª:BOOLº
3031	?0 is not of type ª:BOOLº
=ENDDOC
=DOC
val ‚dest_Å· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for disjunctions.
ÛDefinition
dest_Å ªt1 Å t2º = (ªt1º, ªt2º)
Ê
=FAILURE
4027	?0 is not of form: ªt1 Å t2º
=ENDDOC
=DOC
val ‚is_Å· : TERM -> bool;
=DESCRIBE
Return true only when the term is a disjunction, and false otherwise: no exceptions can be raised.
=ENDDOC
=DOC
val ‚list_mk_Å· : TERM list -> TERM;
=DESCRIBE
A function to make a disjunction of a list of terms.
ÛDefinition
list_mk_Å [ªaº, ªbº, ªcº,...] = ªa Å b Å c ...º
Ê
=FAILURE
3017	An empty list argument is not allowed
3031	?0 is not of type ª:BOOLº
=ENDDOC
=DOC
val ‚strip_Å· : TERM -> TERM list
=DESCRIBE
Break a term into its constituent disjuncts, descending recursively only to the right.
=EXAMPLE
strip_Å ªa Å (b Å c) Å dº = [ªaº,ªb Å cº, ªdº]
=ENDDOC
\subsection{Negations}
=DOC
val ‚mk_å· : TERM -> TERM;
=DESCRIBE
A derived term construction function for generating negations.
ÛDefinition
mk_å ªtº = ªå tº
Ê
=FAILURE
3031	?0 is not of type ª:BOOLº
=ENDDOC
=DOC
val ‚dest_å· : TERM -> TERM;
=DESCRIBE
A derived term destructor function for negations.
ÛDefinition
dest_å ªå tº = ªtº
Ê
=FAILURE
4029	?0 is not of form: ªå tº
=ENDDOC
=DOC
val ‚is_å· : TERM -> bool;
=DESCRIBE
Return true only when the term is a negation, and false otherwise: no exceptions can be raised.
=ENDDOC
=DOC
val ‚mk_multi_å· : (int * TERM) -> TERM;
=DESCRIBE
$mk\_multi\_å$ $(n,t)$ will apply the constructor $mk\_å$ n times to $t$.
=EXAMPLE
mk_multi_å (2, ªTº) = ªå(å T)º
=FAILURE
3031	?0 is not of type ª:BOOLº
4030	?0 is negative
=ENDDOC
=DOC
val ‚dest_multi_å· : TERM -> (int * TERM);
=DESCRIBE
$dest\_multi\_å$ $t$ will strip $å$ from $t$, returning the
number of times, as well as the result.
It will return $(0,t)$ if $t$ is either not boolean, or
has no negations.
=EXAMPLE
dest_multi_å ªå(å T)º = (2, ªTº)
=ENDDOC

\subsection{Bi-implications}
=DOC
val ‚mk_Ç· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating bi-implications.
ÛDefinition
mk_Ç (ªt1º, ªt2º) = ªt1 Ç t2º
Ê
=FAILURE
3015	?1 is not of type ª:BOOLº
3031	?0 is not of type ª:BOOLº
=ENDDOC
=DOC
val ‚dest_Ç· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for bi-implications.
N.B. this may be successfully applied to boolean equalities.
ÛDefinition
dest_Ç ªt1 Ç t2º = (ªt1º, ªt2º)
Ê
=FAILURE
4031	?0 is not of form: ªt1 Ç t2º
=ENDDOC
=DOC
val ‚is_Ç· : TERM -> bool;
=DESCRIBE
Return true only when the term is a bi-implication, and false otherwise: no exceptions can be raised.
N.B. this may be successfully applied to boolean equations.
=ENDDOC
\subsection{Conditionals}
=DOC
val ‚mk_if· : (TERM * TERM * TERM) -> TERM;
=DESCRIBE
Make a conditional.
ÛDefinition
mk_if (ªcº, ªyº, ªnº) = ªif c then y else nº
Ê
=FAILURE
3012	?0 and ?1 do not have the same types
3031	?0 is not of type ª:BOOLº
=ENDDOC
=DOC
val ‚dest_if· : TERM -> (TERM * TERM * TERM);
=DESCRIBE
Destroy a conditional.
ÛDefinition
dest_if ªif c then y else nº = (ªcº, ªyº, ªnº)
Ê
=FAILURE
4006	?0 is not of form: ªif c then y else nº
=ENDDOC
=DOC
val ‚is_if· : TERM -> bool;
=DESCRIBE
Return true only when the term is a conditional, and false otherwise: no exceptions can be raised.
=ENDDOC
\subsection{Let-terms}
=DOC
val ‚mk_let· : ((TERM * TERM)list * TERM) -> TERM
=DESCRIBE
A derived term construction function for generating $let$-terms.
The arguments may have any form allowed by ICL HOL Concrete Syntax.
Thus they may be variable structures formed by pairing, or single clause, non-recursive functions, whose arguments may only be variable structures formed by pairing.
=EXAMPLE
mk_let ([],ªxº) = ªxº
mk_let([(ªxº, ª1º)], ªx+1º) = ªlet x = 1 in x + 1º
mk_let([(ªxº, ª1º),(ªyº, ª2º)], ªx+yº) = 
	ªlet x = 1 and y = 2 in x + yº
mk_let([(ª(x,y)º, ª(1,2)º)], ªx+yº) = 
	ªlet (x,y) = (1,2) in x + yº
mk_let([(ª(x,y)º, ª(1,2)º)], ªx+yº) =
	 ªlet (x,y) = (1,2) in x + yº
mk_let([(ªf (x,y)º, ª(1,2)º)], ªx+yº) = 
	ªlet f = ç (x,y) é (1,2) in x + yº
=FAILURE
3012	?0 and ?1 do not have the same types
4007	?0 is not a well-formed LHS for mk_let
=ENDDOC
=DOC
val ‚dest_let· : TERM -> ((TERM * TERM)list * TERM);
=DESCRIBE
A derived term destructor function for $let$-terms.
See $mk\_let$ for details of format.
The distinction between a local function definition,
and a variable structure bound to an abstraction is lost,
with both being destroyed to the second form.
=EXAMPLE
dest_let(mk_let([(ªf xº, ªyº)],ªbdyº)) = 
	([(ªfº, ªç x é yº)], ªbdyº)
dest_let(mk_let([(ªfº, ªç x é yº)],ªbdyº)) = 
	([(ªfº, ªç x é yº)], ªbdyº)
=FAILURE
4009	?0 is not of form: ªlet ... in ...º
=FAILUREC
$dest\_let$ $(mk\_let([],term))$ will actually fail (unless $term$ is already a $let$-term),
as apply $mk\_let$ to $([],term))$ will just return $term$.
=ENDDOC
=DOC
val ‚is_let· : TERM -> bool;
=DESCRIBE
Return true only when the term is a $let$-term, and false otherwise: no exceptions can be raised.
=ENDDOC
=DOC
val ‚list_mk_let· : (((TERM * TERM)list)list * TERM) -> TERM
=DESCRIBE
This generates a nested $let$-term.
=EXAMPLE
list_mk_let ([[(ªxº,ª1º)],[(ªyº,ª2º)]],ªx+yº) = 
	ªlet x = 1 in let y = 2 in x+yº
=ENDDOC
=DOC
val ‚strip_let· : TERM -> ((TERM * TERM)list)list * TERM
=DESCRIBE
This destroys a sequence of nested $let$ constructs.
=ENDDOC
\subsection{Enumerated Sets} 
=DOC
val ‚mk_enum_set· : TERM list -> TERM
=DESCRIBE
A derived term construction function for generating enumerated sets.
The argument is a list of the members of the set.
The type of a set of elements of type $ª:TYº$ is $ª:TY\ SETº$.
If the term list is empty the function will fail 
(see $mk\_§$).
The set must be of terms with the same HOL type.
ÛDefinition
mk_enum_set [ªaº, ªbº, ...] = ª{a, b, ...}º
Ê
=FAILURE
3012	?0 and ?1 do not have the same types
3017	An empty list argument is not allowed
=ENDDOC
=DOC
val ‚mk_§· : TYPE -> TERM;
=DESCRIBE
A derived term construction function for generating an empty (enumerated) set with elements of a given type.
=SEEALSO
$mk\_enum\_set$
=ENDDOC
It is misleading to provide $is\_§$ as a syntax function,
as it would only test for an empty enumerated set.
=DOC
val ‚dest_enum_set· : TERM -> (TERM list);
=DESCRIBE
A derived term destructor function for enumerated sets.
ÛDefinition
dest_enum_set ª{a, b, ...}º = [ªaº, ªbº, ...]
Ê
=FAILURE
4011	?0 is not of form: ª{t1, ...}º
=ENDDOC
=DOC
val ‚is_enum_set· : TERM -> bool;
=DESCRIBE
Return true only when the term is an enumerated set, and false otherwise: no exceptions can be raised.
=ENDDOC
\subsection{Set Comprehensions}
=DOC
val ‚mk_set_comp· : (TERM * TERM) -> TERM
=DESCRIBE
A derived term construction function for generating set comprehensions.
=EXAMPLE
mk_set_comp (ªxº, ªx > 5º) = ª{ x | x > 5}º
=FAILURE
3015	?1 is not of type ª:BOOLº
4016	?0 is not an allowed variable structure
=ENDDOC
=DOC
val ‚dest_set_comp· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for set comprehensions.
=EXAMPLE
dest_set_comp ª{ x | x > 5}º = (ªxº, ªx > 5º) 
=FAILURE
4013	?0 is not of form: ª{v | p}º
=ENDDOC
=DOC
val ‚is_set_comp· : TERM -> bool;
=DESCRIBE
Return true only when the term is a set comprehension, and false otherwise: no exceptions can be raised.
=ENDDOC
\subsection{List-terms}
=DOC
val ‚mk_list· : TERM list -> TERM
=DESCRIBE
A derived term construction function for generating list-terms.
The argument is a list of the members of the list.
If the term list is empty the function will fail 
(see $mk\_empty\_list$).
The list must be of terms with the same HOL type.
ÛDefinition
mk_list [ªaº, ªbº, ...] = ª[a, b, ...]º
Ê
=FAILURE
3012	?0 and ?1 do not have the same types
3017	An empty list argument is not allowed
=ENDDOC
=DOC
val ‚mk_empty_list· : TYPE -> TERM
=DESCRIBE
A derived term construction function for generating an empty list term with elements of a given type.
=SEEALSO
$mk\_list$
=ENDDOC
=DOC
val ‚dest_list· : TERM -> (TERM list);
=DESCRIBE
A derived term destructor function for list-terms.
ÛDefinition
dest_list ª[a, b, ...]º = [ªaº, ªbº, ...]
dest_list ª[]º = []
Ê
=FAILURE
4015	?0 is not of form: ª[t1,...]º
=ENDDOC
=DOC
val ‚is_list· : TERM -> bool;
=DESCRIBE
Return true only when the term is a list-term, and false otherwise: no exceptions can be raised.
=ENDDOC
\subsection{(Paired) É-terms}
=DOC
val ‚mk_É· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating $É$-terms.
ÛDefinition
mk_É (ªvarstructº, ªbodyº) = ªÉ varstruct é bodyº
Ê
$varstruct$ may be any allowed variable structure.
=FAILURE
3015	?1 is not of type ª:BOOLº
4016	?0 is not an allowed variable structure
=SEEALSO
$mk\_simple\_É$
=ENDDOC
=DOC
val ‚dest_É· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for $É$-terms.
It may destroy a paired abstraction $É$-term, being the inverse of $mk\_É$.
ÛDefinition
dest_É  ªÉ varstruct é bodyº = (ªvarstructº, ªbodyº)
Ê
=FAILURE
4017	?0 is not of form: ªÉ vs é tº
=ENDDOC
=DOC
val ‚is_É· : TERM -> bool;
=DESCRIBE
Return true only when the term is a $É$-term, possibly formed with paired abstraction, and false otherwise: no exceptions can be raised.
=SEEALSO
$is\_simple\_É$
=ENDDOC
=DOC
val ‚list_mk_É· : TERM list * TERM -> TERM;
=DESCRIBE
Repeatedly universally quantify a term.
ÛDefinition
list_mk_É ([ªaº,ªbº,ªcº,...], ªbodyº) = ªÉ a b c ... é bodyº
Ê
This uses $mk\_É$ to generate its result.
=FAILUREC
\paragraph{Failure}
This may give the errors of $mk\_É$.
=ENDDOC
=DOC
val ‚strip_É· : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a multiply universally quantified term
(perhaps with paired abstractions).
ÛDefinition
strip_É ªÉ a b c ... é bodyº = [ªaº,ªbº,ªcº,...], ªbodyº
Ê
=ENDDOC
=DOC
val ‚strip_simple_É· : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a multiply universally simply quantified term.
ÛDefinition
strip_simple_É ªÉ a b c ... é bodyº = [ªaº,ªbº,ªcº,...], ªbodyº
Ê
=ENDDOC
\subsection{(Paired) Ñ-terms}
=DOC
val ‚mk_Ñ· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating $Ñ$-terms.
ÛDefinition
mk_Ñ (ªvarstructº, ªbodyº) = ªÑ varstruct é bodyº
Ê
$varstruct$ may be any allowed variable structure.
=FAILURE
3015	?1 is not of type ª:BOOLº
4016	?0 is not an allowed variable structure
=SEEALSO
$mk\_simple\_Ñ$
=ENDDOC
=DOC
val ‚dest_Ñ· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for $Ñ$-terms.
It may destroy paired abstraction $Ñ$-terms, being the inverse of $mk\_Ñ$.
ÛDefinition
dest_Ñ ªÑ varstruct é bodyº = (ªvarstructº, ªbodyº)
Ê
=FAILURE
4020	?0 is not of form: ªÑ vs é tº
=SEEALSO
$dest\_simple\_Ñ$
=ENDDOC
=DOC
val ‚is_Ñ· : TERM -> bool;
=DESCRIBE
Return true only when the term is a $Ñ$-term, possibly formed with paired abstraction, and false otherwise: no exceptions can be raised.
=SEEALSO
$is\_simple\_Ñ$
=ENDDOC
=DOC
val ‚list_mk_Ñ· : TERM list * TERM -> TERM;
=DESCRIBE
Repeatedly existentially quantify a term.
ÛDefinition
list_mk_Ñ ([ªaº,ªbº,ªcº,...], ªbodyº) = ªÑ a b c ... é bodyº
Ê
This uses $mk\_Ñ$ to generate its result.
=FAILUREC
\paragraph{Failure}
This may give the errors of $mk\_Ñ$.
=ENDDOC
=DOC
val ‚strip_Ñ· : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a repeatedly existentially quantified term, possibly formed with paired abstractions.
ÛDefinition
strip_Ñ ªÑ a b c ... é bodyº = [ªaº,ªbº,ªcº,...], ªbodyº
Ê
=ENDDOC
=DOC
val ‚strip_simple_Ñ· : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a repeatedly existentially simply quantified term.
ÛDefinition
strip_simple_Ñ ªÑ a b c ... é bodyº = [ªaº,ªbº,ªcº,...], ªbodyº
Ê
=ENDDOC
\subsection{Simple and Paired Ñ$_1$-terms}
=DOC
val ‚mk_simple_Ñ%down%1· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating simply abstracted $Ñ_1$-terms.
ÛDefinition
mk_simple_Ñ%down%1 (ªvarº, ªbodyº) = 
	ªÑ%down%1 var é bodyº
Ê
$var$ must be a variable.
=FAILURE
3007	?0 is not a term variable
3015	?1 is not of type ª:BOOLº
=SEEALSO
$mk\_Ñ_1$
=ENDDOC
=DOC
val ‚dest_simple_Ñ%down%1· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for simply abstracted $Ñ_1$-terms.
It may destroy only simple abstraction $Ñ_1$-terms, being the inverse of $mk\_simple\_Ñ_1$.
ÛDefinition
dest_simple_Ñ%down%1 ªÑ%down%1 var é bodyº = 
	(ªvarº, ªbodyº)
Ê
=FAILURE
4019	?0 is not of form: ªÑ%down%1 v é tº
=SEEALSO
$dest\_Ñ_1$
=ENDDOC
=DOC
val ‚is_simple_Ñ%down%1· : TERM -> bool;
=DESCRIBE
Return true only when the term is a $Ñ_1$-term, formed only by simple abstraction, and false otherwise: no exceptions can be raised.
=SEEALSO
$is\_Ñ_1$
=ENDDOC
=DOC
val ‚mk_Ñ%down%1· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating $Ñ_1$-terms.
ÛDefinition
mk_Ñ%down%1 (ªvarstructº, ªbodyº) = 
	ªÑ%down%1 varstruct é bodyº
Ê
$varstruct$ may be any allowed variable structure.
=FAILURE
3015	?1 is not of type ª:BOOLº
4016	?0 is not an allowed variable structure
=SEEALSO
$mk\_Ñ_1$
=ENDDOC
=DOC
val ‚dest_Ñ%down%1· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for $Ñ_1$-terms.
It may destroy paired abstraction $Ñ_1$-terms, being the inverse of $mk\_Ñ_1$.
ÛDefinition
dest_Ñ%down%1 ªÑ%down%1 varstruct é bodyº = 
	(ªvarstructº, ªbodyº)
Ê
=FAILURE
4021	?0 is not of form: ªÑ%down%1 vs é tº
=SEEALSO
$dest\_simple\_Ñ_1$
=ENDDOC
=DOC
val ‚is_Ñ%down%1· : TERM -> bool;
=DESCRIBE
Return true only when the term is a $Ñ_1$-term, possibly formed with paired abstraction, and false otherwise: no exceptions can be raised.
=SEEALSO
$is\_simple\_Ñ_1$
=ENDDOC
``list'' and ``stripping'' forms of unique existence seem
unnecessary.
\subsection{á-terms}
=DOC
val ‚mk_á· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating $á$-terms.
ÛDefinition
mk_á (ªvarstructº, ªbodyº) = ªá varstruct é bodyº
Ê
$varstruct$ may be any allowed variable structure.
=FAILURE
3015	?1 is not of type ª:BOOLº
4016	?0 is not an allowed variable structure
=ENDDOC
=DOC
val ‚dest_á· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for $á$-terms.
ÛDefinition
dest_á ªá varstruct é bodyº = (ªvarstructº, ªbodyº)
Ê
=FAILURE
4023	?0 is not of form: ªá vs é tº
=ENDDOC
=DOC
val ‚is_á· : TERM -> bool;
=DESCRIBE
Return true only when the term is a $á$-term, possibly formed with paired abstraction, and false otherwise: no exceptions can be raised.
=ENDDOC
The following two functions are only present for completeness,
rather than likely use.
=DOC
val ‚list_mk_á· : TERM list * TERM -> TERM;
=DESCRIBE
Repeatedly apply $á$ to a term.
ÛDefinition
list_mk_á ([ªaº,ªbº,ªcº,...], ªbodyº) = ªá a b c ... é bodyº
Ê
=FAILUREC
\paragraph{Failure}
This may give the errors of $mk\_á$.
=ENDDOC
=DOC
val ‚strip_á· : TERM -> (TERM list * TERM);
=DESCRIBE
Strip multiple $á$'s.
ÛDefinition
strip_á ªá a b c ... é bodyº = [ªaº,ªbº,ªcº,...], ªbodyº
Ê
=ENDDOC
=SML
end(* signature of TypesAndTerms *);
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

One facet that should receive attention is the handling of unusually formed terms. For instance, $Cons\ h\ t$, where $h$ and $t$ are variables, should not be recognised as a list for the purposes of $dest\_list$.
We claim that $mk\_term$ $o$ $dest\_term$ is the identity function on terms,
and this should be put to the test.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
