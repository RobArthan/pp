=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Detailed Design for Derived Terms}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for Derived Terms}
\TPPref{DS/FMU/IED/DTD004}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for functions concerning derived terms that are not used in defining the type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
Based on part of \cite{DS/FMU/IED/SML002}.
\item [Issue 1.2]
Fixed a duplicate error message, and ordered an index to be printed.
\item [Issue 1.3, 1.4]
Changes made during implementation of this documents designs.
\item [Issue 1.5]
Removed $mk\_fun\_type$ (as now $mk\_funtype$ in \cite{DS/FMU/IED/DTD003}).
Corrected examples for $mk\_let$.
Improved error messages.
\item [Issue 1.6]
Modified in line with changes in issue 1.9 of \cite{DS/FMU/IED/DTD003}.
The type $DERIV\_TERM$ becomes $DEST\_TERM$.
\item [Issue 1.7]
Added $mk\_empty\_$ for $enum\_set$ and $list$.
\end{description}
\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design of certain derived terms of ICL HOL, and utilities to handle them, called for by the first point of section 4.2 of the Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The high-level specification for the code may be considered
to be given in \cite{DS/FMU/IED/SPC001}.
The design is
implemented in \cite{DS/FMU/IED/IMP004}.
This document will not contain material required to define the type $THM$.
The interpretations of derived constructs follows that suggested by \cite{DS/FMU/IED/DEF001}, e.g. for $let \ldots in$.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design of certain derived terms of ICL HOL, and utilities to handle them.
\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}
=TEX
\section{DERIVED TERMS}
=DOC
signature âTypesAndTermsá = sig
=DESCRIBE
This provides various utilities on derived $TERM$s, but which are not considered necessary to create the abstract data type $THM$.
It also contains, by inclusion, the introduction and starting utilities on types $TERM$ and $TYPE$.
=ENDDOC
We wish to have this signature as the one source of type and term functions, to allow a seamless movement of items from
this signature to $icl'TypesAndTerms$.
=SML
include icl'TypesAndTerms;
=TEX
=DOC
val âstrip_binderá : (TERM -> bool) -> (TERM -> (TERM * TERM)) ->
	TERM -> TERM list * TERM;
=DESCRIBE
$strip\_binder$ $sel$ $dest$ applied to 
\[bind_1( v_1 Ž bind_2( v_2 Ž \ldots Ž body)\ldots)\]
where $sel\ bind_1$, $sel\ bind_2$, $\ldots$ are all true,
will return
\[[v_1, v_2, \ldots], body\]
The function will handle paired abstraction terms.
=USES
For implementing stripping functions for specific binders.
=ENDDOC
=DOC
val âlist_mk_binderá : (TERM * TERM -> TERM) -> (TERM list * TERM) -> TERM;
=DESCRIBE 
If $maker$ $(v,b)$ makes a binding $bind\ v\ Ž\ b$,
then
$list\_mk\_binder$ $maker$ $([v_1, v_2, \ldots],body)$
returns
\[bind\ v_1 Ž bind\ v_2 Ž \ldots Ž body)\ldots)\]
=USES
For implementing list constructing functions for specific binders.
=ENDDOC
=DOC
val âmk_pair_typeá : (TYPE * TYPE) -> TYPE
=DESCRIBE
$mk\_pair\_type$ $(t_1, t_2)$ returns $:t_1\ ‰\ t_2$.
=ENDDOC
=DOC
val âmk_pairá : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating pairs.
=FAILURE
4033	DESIGN ERROR : failed to form a pair
=ENDDOC
=DOC
val âdest_pairá : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for pairs.
=FAILURE
4003	Term is not of form: »(t1,t2)¼
=ENDDOC
=DOC
val âis_pairá : TERM -> bool;
=DESCRIBE
A derived term test for pairs.
=ENDDOC
=DOC
val âmk_absá : TERM * TERM -> TERM
=DESCRIBE
This creates an abstraction with the general syntax called for
by the ICL HOL Concrete Syntax.
=EXAMPLE
mk_abs (x , x + y) =  x Ž x + y
mk_abs ((x, y), x + y) =  (x, y) Ž x + y
mk_abs (((x1,x2), (y1,y2)), x2 + y2) =  ((x1,x2), (y1,y2)) Ž x2 + y2
=SEEALSO
$simple\_mk\_abs$
=FAILURE
4001	Argument is ill-formed
=ENDDOC
=DOC
val âdest_absá: TERM -> (TERM * TERM);
=DESCRIBE
Destroys a term with an abstraction's structure.
It can destroy paired abstractions, being an inverse of $mk\_abs$.
=SEEALSO
$simple\_dest\_abs$
=FAILURE
4002	Term is not of form: » vs Ž t¼
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val âis_absá : TERM -> bool;
=DESCRIBE
This function returns true iff. the term has a varstruct abstraction's structure.
=SEEALSO
$simple\_is\_abs$
=ENDDOC
=DOC
val âlist_mk_absá : (TERM list * TERM) -> TERM;
=DESCRIBE
Repeatedly abstract from a term.
óDefinition
list_mk_abs (["a","b","c",...], "body") =  a b c ... Ž body
æ
This function will be implemented using $mk\_abs$, not $simple\_mk\_abs$.
=SEEALSO
$list\_simple\_mk\_abs$
=FAILUREC
\paragraph{Failure}
May give rise to the error message from $mk\_abs$.
=ENDDOC
=DOC
val âstrip_absá : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a multiple abstraction.
óDefinition
strip_abs " a b c ... Ž body" = ["a","b","c",...], "body"
æ
This uses $dest\_abs$ (q.v.) rather than $simple\_dest\_abs$.
=ENDDOC
=DOC
val âmk_binderá : string -> int -> (TYPE -> TYPE -> TERM) ->
	(TERM * TERM) -> TERM;
=DESCRIBE
A generic method of implementing binder constructor functions:
óDefinition
mk_binder area msg binder (varstruct, body) = binder'( varstruct Ž body)
æ
$binder'$ is formed by applying $binder$ to the types of the 
$varstruct$ and $body$.
The $varstruct$ may be any term that follows the syntax of \cite{DS/FMU/IED/DEF001}.

=FAILUREC
\paragraph{Failure}
If the term cannot be made, then the error will be from $area$, with a message indexed by $msg$.
=ENDDOC
=DOC
val âdest_binderá : string -> int -> string -> TERM -> TERM * TERM;
=DESCRIBE
A generic method of implementing binder destructor functions:
óDefinition
dest_binder area msg binder (binder( varstruct Ž body)) = (varstruct, body)
æ
The $varstruct$ may be any structure allowed by the ICL HOL Concrete Syntax.
=FAILUREC
\paragraph{Failure}
If the term cannot be destroyed, then the error will be from $area$, with a message indexed by $msg$.
=ENDDOC
=DOC
val âis_binderá : (TERM -> 'a) -> TERM -> bool;
=DESCRIBE
$is\_binder$ $dest$ $term$ returns true Iff. $dest$ can be applied to $term$ considered as possibly generated by $mk\_binder$ with paired abstractions, without raising a catchable exception.
=ENDDOC
=DOC
val âmk_€á : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating conjunctions.
=FAILURE
4022	A conjunction must be between booleans
=ENDDOC
=DOC
val âdest_€á : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for conjunctions.
=FAILURE
4032	Term is not of form: »t1 € t2¼
=ENDDOC
=DOC
val âis_€á : TERM -> bool;
=DESCRIBE
A derived term test for conjunctions.
=ENDDOC
=DOC
val âlist_mk_€á : TERM list -> TERM;
=DESCRIBE
Conjoin a list of terms:
óDefinition
list_mk_€ ["a","b","c",...] = "a € b € c ..."
æ
=FAILURE
3017	An empty list argument is not allowed
4025	Argument list must be of booleans
=ENDDOC
=DOC
val âstrip_€á : TERM -> TERM list
=DESCRIBE
Break a term into its constituent conjuncts, descending recursively only to the right
=EXAMPLE
strip_€ "a € (b € c) € d" = ["a","b € c", "d"]
=ENDDOC
=DOC
val âmk_á : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating disjunctions.
=FAILURE
4026	A disjunction must be between booleans
=ENDDOC
=DOC
val âdest_á : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for disjunctions.
=FAILURE
4027	Term is not of form: »t1  t2¼
=ENDDOC
=DOC
val âis_á : TERM -> bool;
=DESCRIBE
A derived term test for disjunctions.
=ENDDOC
=DOC
val âlist_mk_á : TERM list -> TERM;
=DESCRIBE
A function to make a disjunction of a list of terms.
óDefinition
list_mk_ ["a","b","c",...] = "a  b  c ..."
æ
=FAILURE
3017	An empty list argument is not allowed
4025	Argument list must be of booleans
=ENDDOC
=DOC
val âstrip_á : TERM -> TERM list
=DESCRIBE
Break a term into its constituent disjuncts, descending recursively only to the right
=EXAMPLE
strip_ "a  (b  c)  d" = ["a","b  c", "d"]
=ENDDOC
=DOC
val âmk_Œá : TERM -> TERM;
=DESCRIBE
A derived term construction function for generating negations.
=FAILURE
4028	Negations are only on booleans
=ENDDOC
=DOC
val âdest_Œá : TERM -> TERM;
=DESCRIBE
A derived term destructor function for negations.
=FAILURE
4029	Term is not of form: »Œ t¼
=ENDDOC
=DOC
val âis_Œá : TERM -> bool;
=DESCRIBE
A derived term test for negations.
=ENDDOC
=DOC
val âmk_‚á : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating ‚ terms.
=FAILURE
4030	‚ must be between booleans
=ENDDOC
=DOC
val âdest_‚á : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for ‚.
N.B. this may be successfully applied to boolean equalities.
=FAILURE
4031	Term is not of form: »t1 ‚ t2¼
=ENDDOC
=DOC
val âis_‚á : TERM -> bool;
=DESCRIBE
A derived term test for ‚.
N.B. this may be successfully applied to boolean equalities.
=ENDDOC
=DOC
val âmk_ifá : (TERM * TERM * TERM) -> TERM;
=DESCRIBE
$mk\_if$ $(c,\ y,\ n)$ gives the term $if\ c\ then\ y\ else\ n$.
=FAILURE
4004	First argument must be a boolean term
4005	Second and third arguments must have the same type
=ENDDOC
=DOC
val âdest_ifá : TERM -> (TERM * TERM * TERM);
=DESCRIBE
Destroys a term of form $if\ c\ then\ y\ else\ n$.
=FAILURE
4006	Term is not of form: »if c then y else n¼
=ENDDOC
=DOC
val âis_ifá : TERM -> bool;
=DESCRIBE
A test for conditionals.
=ENDDOC
=DOC
val âmk_letá : ((TERM * TERM)list * TERM) -> TERM
=DESCRIBE
A derived term construction function for generating local definitions.
The arguments may have any form allowed by ICL HOL Concrete Syntax.
Thus they may be variable structures formed by pairing, or single clause, non-recursive functions, whose arguments may only be variable structures formed by pairing.
=EXAMPLE
mk_let ([],x) = x
mk_let([(x, 1)], (x+1)) = (let x = 1 in x + 1)
mk_let([(x, 1),(y, 2)], (x+y)) = (let x = 1 and y = 2 in x + y)
mk_let([((x,y), (1,2))], (x+y)) = (let (x,y) = (1,2) in x + y)
mk_let([((x,y), (1,2))], (x+y)) = (let (x,y) = (1,2) in x + y)
mk_let([(f (x,y), (1,2))], (x+y)) = (let f =  (x,y) Ž (1,2) in x + y)
=FAILURE
4007	Argument is not of form: `([...,(LHS,RHS),...],...)`
	where LHS is well-formed
4008	Argument is not of form: `([...,(LHS,RHS),...],...)`
	where type of LHS equals type of RHS 
=ENDDOC
=DOC
val âdest_letá : TERM -> ((TERM * TERM)list * TERM);
=DESCRIBE
A derived term destructor function for local definitions.
See $mk\_let$ for details of format.
The distinction between a local function definition,
and a variable structure bound to an abstraction is lost,
with both being destroyed to the second form.
=EXAMPLE
dest_let(mk_let([(f x, y)],bdy)) = ([(f,  x Ž y)], bdy)
dest_let(mk_let([(f,  x Ž y)],bdy)) = ([(f,  x Ž y)], bdy)
=FAILURE
4009	Term is not of form: »let ... in ...¼
=FAILUREC
$dest\_let$ $(mk\_let([],term))$ will actually fail (unless term is already a local definition),
as $(mk\_let([],term))$ is a null operation.
=ENDDOC
=DOC
val âis_letá : TERM -> bool;
=DESCRIBE
A derived term test for local definitions.
=ENDDOC
=DOC
val âlist_mk_letá : (((TERM * TERM)list)list * TERM) -> TERM
=DESCRIBE
This generates a nested $let$ construct .
=EXAMPLE
list_mk_let ([[(x,1)],[(y,2)]],x+y) = (let x = 1 in let y = 2 in x+y)
=ENDDOC
=DOC
val âstrip_letá : TERM -> ((TERM * TERM)list)list * TERM
=DESCRIBE
This destroys a sequence of nested $let$ constructs.
=ENDDOC
=DOC
val âmk_enum_setá : TERM list -> TERM
=DESCRIBE
A derived term construction function for generating enumerated set definitions.
The argument is a list of the members of the set.
The type of a set of elements of type $TY$ is $TY\ SET$.
If the term list is empty the function will fail 
(see $mk\_\empty\_enum\_set$)
=FAILURE
3017	An empty list argument is not allowed
4010	Elements of list must all be of one type
=ENDDOC
=DOC
val âmk_empty_enum_setá : TYPE -> TERM
=DESCRIBE
A derived term construction function for generating an empty enumerated set with elements of a given type.
=ENDDOC
=DOC
val âdest_enum_setá : TERM -> (TERM list);
=DESCRIBE
A derived term destructor function for enumerated sets.
=FAILURE
4011	Term is not of form: »{t1, ...}¼
=ENDDOC
=DOC
val âis_enum_setá : TERM -> bool;
=DESCRIBE
A derived term test for enumerated sets.
=ENDDOC
=DOC
val âmk_setá : (TERM * TERM) -> TERM
=DESCRIBE
A derived term construction function for generating set comprehensions.
=EXAMPLE
mk_set (x, x > 5) = SetComp x Ž x > 5
=FAILURE
4012	Second argument must be boolean
=ENDDOC
=DOC
val âdest_setá : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for set comprehensions.
=FAILURE
4013	Term is not of form: »{v | p}¼
=ENDDOC
=DOC
val âis_setá : TERM -> bool;
=DESCRIBE
A derived term test for set comprehensions.
=ENDDOC
=DOC
val âmk_listá : TERM list -> TERM
=DESCRIBE
A derived term construction function for generating lists.
The argument is a list of the members of the list.
If the term list is empty the function will fail 
(see $mk\_\empty\_list$)
=FAILURE
3017	An empty list argument is not allowed
4010	Elements of list must all be of one type
=ENDDOC
=DOC
val âmk_empty_listá : TYPE -> TERM
=DESCRIBE
A derived term construction function for generating an empty list with elements of a given type.
=ENDDOC
=DOC
val âdest_listá : TERM -> (TERM list);
=DESCRIBE
A derived term destructor function for lists.
=FAILURE
4015	Term is not of form: »[t1,...]¼
=ENDDOC
=DOC
val âis_listá : TERM -> bool;
=DESCRIBE
A derived term test for lists.
=ENDDOC
=DOC
val âmk_ƒá : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating a forall.
óDefinition
mk_ƒ (varstruct, body) = ƒ varstruct Ž body
æ
$varstruct$ may be anything allowed by ICL HOL Concrete Syntax.
=FAILURE
4016	Argument must have the form: `(varstruct, boolean)`
=SEEALSO
$simple\_mk\_ƒ$
=ENDDOC
=DOC
val âdest_ƒá : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for forall.
It may destroy a paired abstraction forall, being the inverse of $mk\_ƒ$.
=FAILURE
4017	Term is not of form: »ƒ vs Ž t¼
=ENDDOC
=DOC
val âis_ƒá : TERM -> bool;
=DESCRIBE
A derived term test for forall, possibly formed with paired abstractions.
=SEEALSO
$simple\_is\_ƒ$
=ENDDOC
=DOC
val âlist_mk_ƒá : TERM list * TERM -> TERM;
=DESCRIBE
Repeatedly universally quantify a term.
óDefinition
list_mk_ƒ ["a","b","c",...] body = "„ a b c ... Ž body"
æ
This uses $mk\_ƒ$ to generate its result.
=FAILUREC
\paragraph{Failure}
This may give the errors of $mk\_ƒ$.
=ENDDOC
=DOC
val âstrip_ƒá : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a multiply universally quantified term.
óDefinition
strip_ƒ "„ a b c ... Ž body = ["a","b","c",...], body
æ
This uses $dest\_ƒ$ to generate its result.
=ENDDOC
=DOC
val âmk_„á : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating exists.
óDefinition
mk_„ (varstruct, body) = „ varstruct Ž body
æ
$varstruct$ may be anything allowed by ICL HOL Concrete Syntax.
=FAILURE
4016	Argument must have the form: `(varstruct, boolean)`
=SEEALSO
$simple\_mk\_„$
=ENDDOC
=DOC
val âdest_„á : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for exists.
It may destroy paired abstraction exists, being the inverse of $mk\_„$.
=FAILURE
4020	Term is not of form: »„ vs Ž t¼
=SEEALSO
$simple\_dest\_„$
=ENDDOC
=DOC
val âis_„á : TERM -> bool;
=DESCRIBE
A derived term test for exist, possibly formed with paired abstractions.
=SEEALSO
$simple\_is\_„$
=ENDDOC
=DOC
val âlist_mk_„á : TERM list * TERM -> TERM;
=DESCRIBE
Repeatedly existentially quantify a term.
óDefinition
list_mk_„ ["a","b","c",...] body = "„ a b c ... Ž body"
æ
This uses $mk\_„$ to generate its result.
=FAILUREC
\paragraph{Failure}
This may give the errors of $mk\_„$.
=ENDDOC
=DOC
val âstrip_„á : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a repeatedly existentially quantified term.
óDefinition
strip_„ "„ a b c ... Ž body = ["a","b","c",...], body
æ
This uses $dest\_„$ to generate its result.
=ENDDOC
=DOC
val âmk_‡á : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating selects.
óDefinition
mk_‡ (varstruct, body) = ‡ varstruct Ž body
æ
$varstruct$ may be anything allowed by ICL HOL Concrete Syntax.
=FAILURE
4016	Argument must have the form: `(varstruct, boolean)`
=ENDDOC
=DOC
val âdest_‡á : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for selects.
=FAILURE
4023	Term is not of form: »‡ vs Ž t¼
=ENDDOC
=DOC
val âis_‡á : TERM -> bool;
=DESCRIBE
A derived term test for select.
=ENDDOC
The following two functions are only present for completeness,
rather than likely use.
=DOC
val âlist_mk_‡á : TERM list * TERM -> TERM;
=DESCRIBE
Repeatedly apply $‡$ to a term.
óDefinition
list_mk_‡ ["a","b","c",...], "body" = "‡ a b c ... Ž body"
æ
=FAILUREC
\paragraph{Failure}
This may give the errors of $mk\_‡$.
=ENDDOC
=DOC
val âstrip_‡á : TERM -> (TERM list * TERM);
=DESCRIBE
Strip multiple $‡$'s.
óDefinition
strip_‡ "‡ a b c ... Ž body" = ["a","b","c",...], "body"
æ
=ENDDOC
=DOC
datatype âDEST_TERMá = âDVará of string * TYPE |
	âDConstá of string * TYPE |
	âDCombá of TERM * TERM |
	âDAbsá of TERM * TERM |
	âDEqá of TERM * TERM |
	âDŠá of TERM * TERM |
	âDŒá of TERM |
	âDPairá of TERM * TERM |
	âD€á of TERM * TERM |
	âDá of TERM * TERM |
	âD‚á of TERM * TERM |
	âDLetá of ((TERM * TERM)list * TERM) |
	âDEnumSetá of (TERM list * TYPE) |
	âDSetá of TERM * TERM |
	âDListá of (TERM list * TYPE) |
	âDƒá of TERM * TERM |
	âD„á of TERM * TERM |
	âD‡á of TERM * TERM |
	âDIfá of (TERM * TERM * TERM);
=DESCRIBE
This type is that of a term destroyed using the appropriate derived destructor functions (e.g. $dest\_eq$) as well as the primitive ones.
The type given to $DEnumSet$ and $DList$ is the type of an element of the associated set or list.
The type is related to $TERM$ by $mk\_term$ (q.v.) and $dest\_term$ (q.v)
=SEEALSO
$SIMPLE\_DEST\_TERM$
=ENDDOC
=DOC
val âdest_termá : TERM -> DEST_TERM
=DESCRIBE
This function returns the ``best'' interpretation of a term in the form of an object of type $DEST\_TERM$.
E.g. it will return $DEq\ 1\ 2$ rather than $DComb (\$=\ 1) 2$.
It will also use the paired abstraction forms of functions in preference to the simple forms, e.g., it uses $dest\_abs$ not $simple\_dest\_abs$.
=SEEALSO
$mk\_term$
=ENDDOC
=DOC
val âmk_termá : DEST_TERM -> TERM
=DESCRIBE
Create a term from a derived term.
It is an inverse to $dest\_term$ (q.v), and therefore understands how to handle paired abstractions.

This may not give a well-formed term in the context of certain theories.
=FAILUREC
\paragraph{Failure}
This function will fail with the same messages as the appropriate term construction functions.
=ENDDOC
=SML
end(* signature of TypesAndTerms *);
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

One facet that should receive attention is the handling of unusually formed terms. For instance, $Cons\ h\ t$, where $h$ and $t$ are variables, should not be recognised as a list for the purposes of $dest\_list$.
We claim that $mk\_term$ $o$ $dest\_term$ is the identity function on terms,
and this should be put to the test.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
