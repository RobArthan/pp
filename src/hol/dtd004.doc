=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Release 1 ICL HOL: Detailed Design for Derived Terms}  %% Mandatory field
\def\TPPheadtitle{Release 1 ICL HOL \cr Detailed Design for Derived Terms}
\TPPref{DS/FMU/IED/DTD004}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for functions concerning derived terms that are not used in defining the type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
Based on the first part of DS/FMU/IED/SML002.
\end{description}
\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design of certain derived terms of ICL HOL, and utilities to handle them, called for by the first point of section 4.2 of the Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The high-level specification for the code may be considered
to be given in \cite{DS/FMU/IED/SPC001}.
The design is
implemented in \cite{DS/FMU/IED/IMP004}.
This document will not contain material required to define the type $THM$.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design of certain derived terms of ICL HOL, and utilities to handle them.
\subsubsection{Dependencies}

\subsubsection{Deficiencies}
The proposed pretty character facilities would allow such renamings as $mk\_forall$ to $mk\_ƒ$, which would be preferable.
\subsubsection{Possible Enhancements}
=TEX
\section{DERIVED TERMS}
=DOC
signature âDerivedTermsá = sig
=DESCRIBE
This provides the type of ICL HOL types: $TYPE$, of ICL HOL terms: $TERM$, and some
utility functions upon them.
=ENDDOC
We wish to have this signature as the one source of derived term functions, to allow a seamless movement of items from
this signature to $icl'TermsAndTypes$.
=SML
include icl'TypesAndTerms;
=TEX
=DOC
val âmk_absá : TERM * TERM -> TERM
=DESCRIBE
This creates an abstraction with the general syntax called for
by \cite{DS/FMU/IED/DEF001}.
=EXAMPLE
mk_paired_abs (x , x + y) =  x Ž x + y
mk_paired_abs ((x, y), x + y) =  (x, y) Ž x + y
mk_paired_abs (((x1,x2), (y1,y2)), x2 + y2) =  ((x1,x2), (y1,y2)) Ž x2 + y2
=FAILURE
4001	Argument is ill-formed
=SEEALSO
$mk\_simple\_abs$
=ENDDOC
=DOC
val âdest_absá: TERM -> (TERM * TERM);
=DESCRIBE
Destroys a term with an abstraction's structure.
It can destroy paired abstractions, being an inverse of $mk\_abs$.
=FAILURE
4002	Term is not an abstraction
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=SEEALSO
$dest\_simple\_abs$
=ENDDOC
=DOC
val âis_absá : TERM -> bool;
=DESCRIBE
This function returns true iff. the term has a varstruct abstraction's structure.
=SEEALSO
$is\_simple\_abs$
=ENDDOC
=DOC
val âlist_mk_absá : (TERM list * TERM) -> TERM;
=DESCRIBE
óDefinition
list_mk_abs (["a","b","c",...], "body") =  a b c ... Ž body
æ
This function will be implemented using $mk\_abs$, not $mk\_simple\_abs$.
=FAILUREC
\paragraph{Failure}
May give rise to the error message from $mk\_abs$.
=SEEALSO
$list\_mk\_simple\_abs$
=ENDDOC
=DOC
val âstrip_absá : TERM -> (TERM list * TERM);
=DESCRIBE
óDefinition
strip_abs " a b c ... Ž body" = ["a","b","c",...], "body"
æ
=ENDDOC
=DOC
val âmk_binderá : string -> int -> (TYPE -> TYPE -> TERM) ->
	(TERM * TERM) -> TERM;
=DESCRIBE
óDefinition
mk_binder area msg binder (varstruct, body) = binder( varstruct Ž body)
æ
The $varstruct$ may be any term that follows the syntax of \cite{DS/FMU/IED/DEF001}.
=FAILUREC
\paragraph{Failure}
If the term cannot be made, then the error will be from $area$, with a message indexed by $msg$.
=ENDDOC
=DOC
val âdest_binderá : string -> int -> string -> TERM -> TERM * TERM;
=DESCRIBE
óDefinition
dest_binder area msg binder (binder( varstruct Ž body)) = (varstruct, body)
æ
The $varstruct$ may be any structure allowed by the ICL HOL Concrete Syntax.
=FAILUREC
\paragraph{Failure}
If the term cannot be destroyed, then the error will be from $area$, with a message indexed by $msg$.
=ENDDOC
=DOC
val âis_binderá : (TERM -> 'a) -> TERM -> bool;
=DESCRIBE
$is\_binder$ $dest$ $term$ returns true iff. $dest$ can be applied to $term$ considered as possibly generated by $mk\_binder$ with paired abstractions, without raising a catchable exception.
=ENDDOC
=DOC
val âstrip_binderá : (TERM -> bool) -> (TERM -> (TERM * TERM)) ->
	TERM -> TERM list * TERM;
=DESCRIBE
$strip\_binder$ $sel$ $dest$ applied to 
\[bind_1( v_1 Ž bind_2( v_2 Ž \ldots Ž body)\ldots)\]
where $sel\ bind_1$, $sel\ bind_2$, $\ldots$ are all true,
will return
\[[v_1, v_2, \ldots], body\]
The function will handle paired abstraction terms properly.
=ENDDOC
=DOC
val âmk_conjá : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating conjunctions.
=FAILURE
4022	A conjunction must be between booleans
=ENDDOC
=DOC
val âdest_conjá : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for conjunctions.
=FAILURE
4023	Term is not a conjunction.
=ENDDOC
=DOC
val âis_conjá : TERM -> bool;
=DESCRIBE
A derived term test for conjunctions.
=ENDDOC
=DOC
val âlist_mk_conjá : TERM list -> TERM;
=DESCRIBE
óDefinition
list_mk_conj ["a","b","c",...] = "a € b € c ..."
æ
=FAILURE
4024	An empty list argument is not allowed
4025	Argument list must be of boolean terms.
=ENDDOC
=DOC
val âstrip_conjá : TERM -> TERM list
=DESCRIBE
Break a term into its constituent conjuncts, descending recursively only to the right
=EXAMPLE
strip_conj "(a € (b € c) € d" = ["a","b € c", "d"]
=ENDDOC
=DOC
val âmk_disjá : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating disjunctions.
=FAILURE
4026	A disjunction must be between booleans
=ENDDOC
=DOC
val âdest_disjá : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for disjunctions.
=FAILURE
4027	Term is not a disjunction.
=ENDDOC
=DOC
val âis_disjá : TERM -> bool;
=DESCRIBE
A derived term test for disjunctions.
=ENDDOC
=DOC
val âlist_mk_disjá : TERM list -> TERM;
=DESCRIBE
óDefinition
list_mk_disj ["a","b","c",...] = "a  b  c ..."
æ
=FAILURE
4024	An empty list argument is not allowed
4025	Argument list must be of boolean terms.
=ENDDOC
=DOC
val âstrip_disjá : TERM -> TERM list
=DESCRIBE
Break a term into its constituent disjuncts, descending recursively only to the right
=EXAMPLE
strip_disj "(a  (b  c)  d" = ["a","b  c", "d"]
=ENDDOC
=DOC
val âmk_negá : TERM -> TERM;
=DESCRIBE
A derived term construction function for generating negations.
=FAILURE
4028	Negations are only on boolean terms
=ENDDOC
=DOC
val âdest_negá : TERM -> TERM;
=DESCRIBE
A derived term destructor function for negations.
=FAILURE
4029	Term is not a negation
=ENDDOC
=DOC
val âis_negá : TERM -> bool;
=DESCRIBE
A derived term test for negations.
=ENDDOC
=DOC
val âmk_iffá : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating iff. terms.
=FAILURE
4030	iff must be between booleans
=ENDDOC
=DOC
val âdest_iffá : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for iff.
=FAILURE
4031	Term is not a iff
=ENDDOC
=DOC
val âis_iffá : TERM -> bool;
=DESCRIBE
A derived term test for iff.
=ENDDOC
=DOC
val âcommaá : TYPE -> TYPE -> TERM;
=DESCRIBE
$comma$ $ty_1$ $ty_2$ generates a constant  ",", of type
$ty_1 ‹ ty_2 ‹ (ty_1 ‰ ty_2)$.
=ENDDOC
=DOC
val âmk_pairá : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating pairs.
=ENDDOC
=DOC
val âdest_pairá : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for pairs.
=FAILURE
4003	Term is not a pair
=ENDDOC
=DOC
val âis_pairá : TERM -> bool;
=DESCRIBE
A derived term test for pairs.
=ENDDOC
=DOC
val âmk_Ifá : (TERM * TERM * TERM) -> TERM;
=DESCRIBE
$mk\_If$ $(c,\ y,\ n)$ gives the term $if\ c\ then\ y\ else\ c$.
=FAILURE
4004	First argument must be a boolean term
4005	Second and third arguments must have the same type
=ENDDOC
=DOC
val âdest_Ifá : TERM -> (TERM * TERM * TERM);
=DESCRIBE
Destroys a term of the form $if\ c\ then\ y\ else\ c$.
=FAILURE
4006	Term is not a conditional
=ENDDOC
=DOC
val âis_Ifá : TERM -> bool;
=DESCRIBE
A test for conditionals.
=ENDDOC
=DOC
val âmk_letá : ((TERM * TERM)list * TERM) -> TERM
=DESCRIBE
A derived term construction function for generating local definitions.
The arguments may have any form allowed by ICL HOL Concrete Syntax.
=EXAMPLE
mk_let ([],x) = x
mk_let([x, 1], (x+1)) = (let x = 1 in x + 1)
mk_let([(x, 1),(y, 2)], (x+y)) = (let x = 1 and y = 2 in x + y)
mk_let([((x,y), (1,2))], (x+y)) = (let x,y = 1,2 in x + y)
=FAILURE
4007	LHS argument not well formed
4008	LHS and RHS arguments must have same type 
=ENDDOC
=DOC
val âdest_letá : TERM -> ((TERM * TERM)list * TERM);
=DESCRIBE
A derived term destructor function for local definitions.
See $mk\_let$ for details of format.
=FAILURE
4009	Term is not a local definition
=ENDDOC
=DOC
val âis_letá : TERM -> bool;
=DESCRIBE
A derived term test for local definitions.
=ENDDOC
=DOC
val âlist_mk_letá : (((TERM * TERM)list)list * TERM) -> TERM
=DESCRIBE
This generates a nested $let$ construct .
=EXAMPLE
list_mk_let ([[(x,1)],[(y,2)]],x+y) = (let x = 1 in let y = 2 in x+y)
=ENDDOC
=DOC
val âmk_enum_setá : TERM list -> TERM
=DESCRIBE
A derived term construction function for generating enumerated set definitions.
The argument is a list of the members of the set.
=FAILURE
4010	Elements of list must all be of one type
=ENDDOC
=DOC
val âdest_enum_setá : TERM -> (TERM list);
=DESCRIBE
A derived term destructor function for enumerated sets.
=FAILURE
4011	Term is not an enumerated set
=ENDDOC
=DOC
val âis_enum_setá : TERM -> bool;
=DESCRIBE
A derived term test for enumerated sets.
=ENDDOC
=DOC
val âmk_setá : (TERM * TERM) -> TERM
=DESCRIBE
A derived term construction function for generating set comprehensions.
=EXAMPLE
mk_set (x, x > 5) = ( x Ž x > 5)
=FAILURE
4012	Second argument must be boolean
=ENDDOC
=DOC
val âdest_setá : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for set comprehensions.
=FAILURE
4013	Term is not a set comprehension.
=ENDDOC
=DOC
val âis_setá : TERM -> bool;
=DESCRIBE
A derived term test for set comprehensions.
=ENDDOC
=DOC
val âmk_listá : TERM list -> TERM
=DESCRIBE
A derived term construction function for generating lists.
The argument is a list of the members of the list.
The function will generate a warning if given an empty list, when it will produce the term $[] : 'a list$,
as it cannot derive a specific type for the list from its argument.
=FAILURE
4010	Elements of list must all be of one type
=ENDDOC
=DOC
val âdest_listá : TERM -> (TERM list);
=DESCRIBE
A derived term destructor function for lists.
=FAILURE
4015	Term is not a list
=ENDDOC
=DOC
val âis_listá : TERM -> bool;
=DESCRIBE
A derived term test for lists.
=ENDDOC
=DOC
val âmk_forallá : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating foralls.
óDefinition
mk_forall (varstruct, body) = ƒ varstruct Ž body
æ
$varstruct$ may be anything allowed by ICL HOL Concrete Syntax.
=FAILURE
4016	Argument must have the form: (varstruct, boolean)
=SEEALSO
$mk\_simple\_forall$
=ENDDOC
=DOC
val âdest_forallá : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for foralls.
It may destroy paired abstraction foralls, being the inverse of $mk\_forall$.
=FAILURE
4017	Term is not a forall
=ENDDOC
=DOC
val âis_forallá : TERM -> bool;
=DESCRIBE
A derived term test for forall, possibly formed with paired abstractions.
=ENDDOC
=DOC
val âlist_mk_forallá : TERM list * TERM -> TERM;
=DESCRIBE
óDefinition
list_mk_forall ["a","b","c",...] body = "„ a b c ... Ž body"
æ
This uses $mk\_forall$ to generate its result.
=FAILURE
4018	Argument list must be of term variables
=ENDDOC
=DOC
val âstrip_forallá : TERM -> (TERM list * TERM);
=DESCRIBE
óDefinition
strip_forall "„ a b c ... Ž body = ["a","b","c",...], body
æ
This uses $dest\_forall$ to generate its result.
=ENDDOC
=DOC
val âmk_existá : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating exists.
óDefinition
mk_exist (varstruct, body) = „ varstruct Ž body
æ
$varstruct$ may be anything allowed by ICL HOL Concrete Syntax.
=FAILURE
4016	Argument must have the form: (varstruct, boolean)
=SEEALSO
$mk\_simple\_exist$
=ENDDOC
=DOC
val âdest_existá : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for exists.
It may destroy paired abstraction exists, being the inverse of $mk\_exist$.
=FAILURE
4020	Term is not an exist
=SEEALSO
$dest\_simple\_exist$
=ENDDOC
=DOC
val âis_existá : TERM -> bool;
=DESCRIBE
A derived term test for exist, possibly formed with paired abstractions.
=ENDDOC
=DOC
val âlist_mk_existá : TERM list * TERM -> TERM;
=DESCRIBE
óDefinition
list_mk_exist ["a","b","c",...] body = "„ a b c ... Ž body"
æ
This uses $mk\_exist$ to generate its result.
=FAILURE
4021	Argument list contains ill-formed terms
=ENDDOC
=DOC
val âstrip_existá : TERM -> (TERM list * TERM);
=DESCRIBE
óDefinition
strip_exist "„ a b c ... Ž body = ["a","b","c",...], body
æ
This uses $dest\_exist$ to generate its result.
=ENDDOC
=DOC
val âmk_selectá : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating selects.
óDefinition
mk_select (varstruct, body) = ‡ varstruct Ž body
æ
$varstruct$ may be anything allowed by ICL HOL Concrete Syntax.
=FAILURE
4016	Argument must have the form: (varstruct, boolean)
=ENDDOC
=DOC
val âdest_selectá : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for selects.
=FAILURE
4023	Term is not a select
=ENDDOC
=DOC
val âis_selectá : TERM -> bool;
=DESCRIBE
A derived term test for select.
=ENDDOC
=DOC
val âlist_mk_selectá : TERM list * TERM -> TERM;
=DESCRIBE
óDefinition
list_mk_select ["a","b","c",...], "body" = "‡ a b c ... Ž body"
æ
=FAILURE
4021	Argument list contains ill-formed terms
=ENDDOC
=DOC
val âstrip_selectá : TERM -> (TERM list * TERM);
=DESCRIBE
óDefinition
strip_select "‡ a b c ... Ž body" = ["a","b","c",...], "body"
æ
=ENDDOC
=DOC
datatype âDERIV_TERMá = âDVará of string * TYPE |
	âDConstá of string * TYPE |
	âDCombá of TERM * TERM |
	âDAbsá of TERM * TERM |
	âDEqá of TERM * TERM |
	âDImpá of TERM * TERM |
	âDNegá of TERM |
	âDPairá of TERM * TERM |
	âDConjá of TERM * TERM |
	âDDisjá of TERM * TERM |
	âDIffá of TERM * TERM |
	âDLetá of (TERM * TERM * TERM) |
	âDEnumSetá of TERM list |
	âDSetá of TERM * TERM |
	âDListá of TERM list |
	âDForallá of TERM * TERM |
	âDExistá of TERM * TERM |
	âDSelectá of TERM * TERM |
	âDIfá of (TERM * TERM * TERM);
=DESCRIBE
This type is that of a term destroyed using the appropriate derived destructor functions (e.g. $dest\_eq$) as well as the primitive ones.
It is related to $TERM$ by $mk\_TERM\_DERIV$ and $dest\_TERM\_DERIV$
=SEEALSO
$DEST\_TERM$
=ENDDOC
=DOC
val âdest_TERM_DERIVá : TERM -> DERIV_TERM
=DESCRIBE
This function returns the ``best'' interpretation of a term in the form of an object of type $DERIV\_TERM$.
E.g. it will return $DEq\ 1\ 2$ rather than $DComb (\$=\ 1) 2$.
It will also use the paired abstraction forms of functions in preference to the simple forms, e.g., it uses $dest\_abs$ not $dest\_simple\_abs$.
=SEEALSO
$mk\_TERM\_DERIV$
=ENDDOC
=DOC
val âmk_TERM_DERIVá : DERIV_TERM -> TERM
=DESCRIBE
Create a term from a derived term.
It is an inverse to $dest\_TERM\_DERIV$, and therefore understands how to handle paired abstractions.

This may not give a well-formed term in the context of certain theories.
=FAILUREC
\paragraph{Failure}
This function will fail with the same messages as the appropriate term construction functions, though the area name will be $mk\_TERM\_DERIV$.
=SEEALSO
$dest\_TERM\_DERIV$
=ENDDOC
=SML
end(* signature of DerivedTerms *);
=TEX
\section{TESTING}
???
\end{document}
