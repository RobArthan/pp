%  dtd004.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design for Derived Terms}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for Derived Terms}
\TPPref{DS/FMU/IED/DTD004}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}
%\TPPstatus{Approved}
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for functions concerning derived terms that are not used in defining the type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 2.1 (16th August 1991)]
Approved version of issue 1.16.

\item[Issue 2.2, \FormatDate{92/01/20} ] Updated to use new fonts.
\item[Issue 2.3, (11th February 1992)]
Added functions $list\_mk\_­\_type$, $strip\_­\_type$,
$is\-\_empty\-\_list$, $dest\-\_empty\-\_list$,
$dest\-\_t$, $dest\-\_f$,
$is\-\_š$, and $dest\-\_š$.
\item [Issue 2.4 (16th March 1992)]
Added stripping combinators.
\item [Issue 2.5 (2nd April 1992)]
Changes required by CR0016.
\item [Issue 2.6 (13th April 1992)]
Changes due to CR0017.
\item[Issue 2.7 (14 May 1992)] Use correct quotation symbols.
\item[Issue 2.8 (21st May 1992)]
Clarified documentation.
\item [Issue 2.9 (3rd June 1992)]
Added literals to $DEST\_TERM$.
\end{description}
% \subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document gives the detailed design of the subsystem TypesAndTerms called for in  \cite{DS/FMU/IED/HLD007}.

The high-level specification for some of the code may be considered
to be given in \cite{DS/FMU/IED/SPC001}.
The design is
implemented in \cite{DS/FMU/IED/IMP004}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design of certain derived terms of ICL HOL, and functions to handle them.
\subsubsection{Dependencies}
Loading this document is dependent on \cite{DS/FMU/IED/IMP003}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Terminology}
In may be necessary when using the following terminology to remove ambiguity by prefixing some of the following with the word ``term'' or ``HOL''.
This will prevent confusions with 
Standard ML terminology, or, for instance, theorems
whose conclusions are describable in the same terms.

\begin{tabular}{p{1.3in} p{4.9in}}
pair & A term of the form $¬(x,\ y)®$, as constructed by $mk\_pair$: a tuple of two elements. \\
pair type & A HOL type of the form $”ty_1\ ¸\ ty_2®$, as constructed by $mk\_¸\_type$: an instance of the HOL type of pairs. \\
conjunction & A term of the form $¬x\ ±\ y®$, as constructed by $mk\_±$. \\
disjunction & A term of the form $¬x\ ²\ y®$, as constructed by $mk\_²$. \\
negation & A term of the form $¬³ x®$, as constructed by $mk\_³$. \\
bi-implication & A term of the form $¬x\ ¤\ y®$, as constructed by $mk\_¤$. \\
conditional & A term of the form $¬if\ x\ then\ y\ else\ z®$, as constructed by $mk\_if$. \\
$let$-term & A term of the form $¬let\ x\ =\ y\ in\ z[x]®$, as constructed by $mk\_let$: it provides local definition within a term. \\
enumerated set & A term of the form
$¬{a,\ b,\ ...}®$, as constructed by $mk\_enum\_set$: a set defined by the enumeration of its elements. \\
set comprehension & A term of the form
$¬SetComp\ x\ ·\ P[x]®$, as constructed by $mk\_set\_comp$: a set defined to be those elements of a type that satisfy a predicate. \\
list-term & A term of the form $¬[a,\ b,\ ...]®$, as constructed by $mk\_list$: a list within the HOL object language. \\
$¶_1$-term & A term of the form $¬¶_1\ x\ ·\ P[x]®$ or $¬¶_1\ (x,y)\ ·\ P[x,y]®$, as constructed by $mk\_simple\_¶_1$ or $mk\_¶_1$. \\
$Å$-term & A term of the form $¬Å\ x\ ·\ P[x]®$, as constructed by $mk\_Å$: a choice from those elements of a type that satisfy a predicate. \\
an allowed variable structure & A term composed from variables and pairing operations, as allowed by the ICL HOL concrete syntax. \\
\end{tabular}

\section{DERIVED TERMS}
=DOC
signature ÛTypesAndTermsÝ = sig
=DESCRIBE
This provides various functions on derived $TERM$s, which are not considered necessary to create the abstract data type $THM$.
It also contains, by inclusion, the types, and functions on the types $TERM$ and $TYPE$ from structure $icl'TypesAndTerms$(q.v.).
=ENDDOC
We wish to have this signature as the one source of type and term functions, to allow a seamless movement of items from
this signature to $icl'TypesAndTerms$.
=SML
include icl'TypesAndTerms;
=TEX
\subsection{Destroyed Terms}
The following data type may act as a summary of all of the derived term constructors
provided by this document and \cite{DS/FMU/IED/DTD003},
which are in turn called for by \cite{DS/FMU/IED/HLD007}.
The names of those constructors may be derived from these value constructors by stripping off ``D'', making the
names lower case and using $\_$ as a separator for different atoms in a name, if appropriate, and prefixing each result by ``mk$\_$''.
The value constructors also follow the same typing of their single arguments
as the constructors.
=DOC
datatype ÛDEST_TERMÝ = ÛDVarÝ of string * TYPE |
	ÛDConstÝ of string * TYPE |
	ÛDAppÝ of TERM * TERM |
	ÛDÌÝ of TERM * TERM |
	ÛDEqÝ of TERM * TERM |
	ÛD´Ý of TERM * TERM |
	ÛDTÝ |
	ÛDFÝ |
	ÛD³Ý of TERM |
	ÛDPairÝ of TERM * TERM |
	ÛD±Ý of TERM * TERM |
	ÛD²Ý of TERM * TERM |
	ÛD¤Ý of TERM * TERM |
	ÛDLetÝ of ((TERM * TERM)list * TERM) |
	ÛDEnumSetÝ of TERM list |
	ÛDšÝ of TYPE |
	ÛDSetCompÝ of TERM * TERM |
	ÛDListÝ of TERM list |
	ÛDEmptyListÝ of TYPE |
	ÛDµÝ of TERM * TERM |
	ÛD¶Ý of TERM * TERM |
	ÛD¶‰1Ý of TERM * TERM |
	ÛDÅÝ of TERM * TERM |
	ÛDIfÝ of (TERM * TERM * TERM) |
	ÛDîÝ of int |
	ÛDCharÝ of string |
	ÛDStringÝ of string;
=DESCRIBE
This type is that of a term destroyed using the appropriate derived destructor functions (e.g. $dest\_eq$) as well as the primitive ones.
The type given to $Dš$ and $DEmptyList$ is the type of an element of the associated set or list.
The type is related to $TERM$ by $mk\_term$ (q.v.) and $dest\_term$ (q.v)
=SEEALSO
$DEST\_SIMPLE\_TERM$
=ENDDOC
=DOC
val Ûdest_termÝ : TERM -> DEST_TERM
=DESCRIBE
This function returns the ``best'' interpretation of a term in the form of an object of type $DEST\_TERM$.
E.g. it will return $DEq(\ 1\ 2)$ rather than $DComb ((\$=\ 1), 2)$.
It will also use the paired abstraction forms of functions in preference to the simple forms, e.g., it uses $dest\_Ì$ not $dest\_simple\_Ì$.

The function assumes that the name of a constant is sufficient
to identify it without checking the type, as with, e.g., $dest\_bin\_op$(q.v).
=SEEALSO
$mk\_term$
=ENDDOC
=DOC
val Ûmk_termÝ : DEST_TERM -> TERM
=DESCRIBE
Create a term from a derived term.
It is an inverse to $dest\_term$ (q.v), and therefore understands how to handle paired abstractions.

The function is implemented using the individual primitive and derived term constructors (e.g. $mk\_const$ and $mk\_µ$), with what checks they use.
=FAILUREC
\paragraph{Failure}
This function will fail with the same messages as the appropriate term constructor functions.
=ENDDOC
\subsection{Derived Type Functions}
=DOC
val Ûlist_mk_­_typeÝ : TYPE list -> TYPE;
=DESCRIBE
Create the type of a multi-argument function.
=GFT Definition
list_mk_­_type [”ty1®,...,¬tyn®] = 
	”ty1 ­ ... ­ tyn®
=TEX
The supplied list may not be empty.
=FAILURE
3017	An empty list argument is not allowed
=ENDDOC
=DOC
val Ûstrip_­_typeÝ : TYPE -> TYPE list;
=DESCRIBE
Strip the type of a  multi-argument function into its
constituent types, only descending into the right hand result
of $dest\_­\_type$.
=GFT Definition
strip_­_type ”ty1 ­ ... ­ tyn® =
	[”ty1®,...,¬tyn®]
=TEX
=ENDDOC
\subsection{Boolean Constants}
=DOC
val Ûmk_tÝ : TERM;
=DESCRIBE
The term $¬T : BOOL®$.
=ENDDOC
$mk\_t$ is a bit of an anomaly amongst other $mk\_$ functions,
as it would be more proper for it to take $()$ as an argument.
This ``proper'' approach is, by local convention, not adopted.
=DOC
val Ûis_tÝ : TERM -> bool;
=DESCRIBE
Return true only when the term is $¬T : BOOL®$, and false otherwise: no exceptions can be raised.
=ENDDOC
=DOC
val Ûdest_tÝ : TERM -> unit;
=DESCRIBE
This will return $()$ if given the term $¬T®$, and otherwise fail.
=FAILURE
4036	?0 is not: ¬T®
=ENDDOC
=DOC
val Ûmk_fÝ : TERM;
=DESCRIBE
The term $¬F : BOOL®$.
=ENDDOC
$mk\_f$ is a bit of an anomaly amongst other $mk\_$ functions,
as it would be more proper for it to take $()$ as an argument.
This ``proper'' approach is, by local convention, not adopted.
=DOC
val Ûdest_fÝ : TERM -> unit;
=DESCRIBE
This will return $()$ if given the term $¬F®$, and otherwise fail.
=FAILURE
4037	?0 is not: ¬F®
=ENDDOC

=DOC
val Ûis_fÝ : TERM -> bool;
=DESCRIBE
Return true only when the term is $¬F : BOOL®$, and false otherwise: no exceptions can be raised.
=ENDDOC
Destructor and list versions of these functions are not necessary.
\subsection{Generic Stripping Functions}
=DOC
val Ûstrip_leavesÝ : ('a -> 'a * 'a) -> 'a -> 'a list;
=DESCRIBE
Given a function that destroys an object into a pair of objects (and here we are thinking of, for example, $dest\_±$),
recursively descend the results of destruction down both
branches, destroying until failure.
=EXAMPLE
strip_leaves dest_± ¬(a ± b) ± c ± d® =
	[¬a®, ¬b®, ¬c®, ¬d®]
=ENDDOC
=DOC
val Ûstrip_spine_leftÝ : ('a -> 'a * 'a) -> 'a -> 'a list;
=DESCRIBE
Given a function that destroys an object into a pair of objects (and here we are thinking of, for example, $dest\_±$),
recursively descend the left results of destruction, destroying until failure.
=EXAMPLE
strip_spine_left dest_± ¬(a ± b) ± c ± d® =
	[¬a®, ¬b®, ¬c ± d®]
=ENDDOC
=DOC
val Ûstrip_spine_rightÝ : ('a -> 'a * 'a) -> 'a -> 'a list;
=DESCRIBE
Given a function that destroys an object into a pair of objects (and here we are thinking of, for example, $dest\_±$),
recursively descend the right results of destruction, destroying until failure.
=SEEALSO
$strip\_bin\_op$ for stripping terms formed by binary (constant) term operators.
=EXAMPLE
strip_spine_left dest_± ¬(a ± b) ± c ± d® =
strip_± ¬(a ± b) ± c ± d® =
	[¬a ± b®, ¬c®, ¬d®]
=ENDDOC
We will use $strip\_spine\_right$ form of stripping in
any declared stripping of binary operators (e.g. $strip\_±$),
using $strip\_bin\_op$ by preference on terms as it is a more efficient.
\subsection{Generic Binder Functions}
The following provide a standard pattern for implementing
constructor and destructor functions for binders.
=DOC
val Ûmk_binderÝ : string -> int -> (TYPE -> TYPE -> TERM) ->
	(TERM * TERM) -> TERM;
=DESCRIBE
A generic method of implementing binder constructor functions:
=GFT Definition
mk_binder area msg binder_nm (¬varstruct®, ¬body®) = 
	¬binder'(Ì varstruct· body)® = 
	¬binder' varstruct· body®
=TEX
$binder'$ is formed by applying $binder$ to the types of the 
$varstruct$ and $body$.
The $varstruct$ may be any term that follows the syntax of \cite{DS/FMU/IED/DEF001}.
=SEEALSO
$mk\_simple\_binder$
=FAILURE
4016	?0 is not an allowed variable structure
=FAILUREC
\paragraph{Failure}
If the term cannot be made, then the error will be from $area$, with a message indexed by $msg$.
If the first term argument is not an allowed variable structure
then failure 4016 is raised from area $area$.
=ENDDOC
=DOC
val Ûdest_binderÝ : string -> int -> string -> TERM -> TERM * TERM;
=DESCRIBE
A generic method of implementing binder destructor functions:
=GFT Definition
dest_binder area msg binder_nm ¬binder(Ì varstruct· body)® = 
	(¬varstruct®, ¬body®)
=TEX
where $binder$ is a constant whose name is $binder\_nm$.
The $varstruct$ may be any allowed variable structure.
=SEEALSO
$dest\_simple\_binder$
=FAILUREC
\paragraph{Failure}
If the term cannot be destroyed, then the error will be from $area$, with a message indexed by $msg$.
=ENDDOC
=DOC
val Ûis_binderÝ : string -> TERM -> bool;
=DESCRIBE
$is\_binder$ $binder\_nm$ $tm$ is true only when $tm$
is of the form $¬binder(Ì\ vs·\ body)®$,
where $binder$ is a constant whose name is $binder\_nm$,
and $vs$ an allowed variable structure,
and false otherwise.
It cannot raise an exception.
=SEEALSO
$is\_simple\_binder$
=ENDDOC
=DOC
val Ûstrip_binderÝ : string -> TERM -> TERM list * TERM;
=DESCRIBE
$strip\_binder$ $binder$ applied to 
\[¬binder(Ì vs_1· binder(Ì vs_2· \ldots · body)\ldots)®\]
will return
\[[¬vs_1®, ¬vs_2®, \ldots], ¬body®\]
where the $vs_i$ are allowed variable structures.
The function acts as $dest\_binder$ (q.v), and will handle paired abstraction terms.
It will return an empty list and the original term if the
supplied term is not formed using the binder.
=SEEALSO
$strip\_simple\_binder$
=ENDDOC
=DOC
val Ûstrip_simple_binderÝ : string -> TERM -> TERM list * TERM;
=DESCRIBE
$strip\_simple\_binder$ $binder$ applied to 
\[¬binder(Ì v_1· binder(Ì v_2· \ldots · body)\ldots)®\]
will return
\[[¬v_1®, ¬v_2®, \ldots], ¬body®\]
where the $v_i$ are simple variables.
The function acts as $dest\_simple\_binder$ (q.v), and will not handle paired abstraction terms.
It will return an empty list and the original term if the
supplied term is not formed using the binder.
=SEEALSO
$strip\_binder$
=ENDDOC
=DOC
val Ûlist_mk_binderÝ : (TERM * TERM -> TERM) -> (TERM list * TERM) 
	-> TERM;
=DESCRIBE
If 
=INLINEFT
maker (¬vs®,¬b®)
=TEX
{} makes an abstraction 
=INLINEFT
¬bind vs · b®
=TEX
, then
=GFTSHOW
list_mk_binder maker ([¬vs_1®, ¬vs_2®, ...],¬body®)
=TEX
returns
=INLINEFT
¬bind vs_1· bind vs_2· ... · body®
=TEX
Notice that this can be used for implementing both simple and paired abstractions, with the $vs_i$ being variable structures when so allowed, and otherwise variables.
=ENDDOC
\subsection{Pairs}
=DOC
val Ûmk_¸_typeÝ : (TYPE * TYPE) -> TYPE
=DESCRIBE
$mk\_¸\_type$ $(”ty_1®, ”ty_2®)$ returns a pair type: $”ty_1\ ¸\ ty_2®$.
=ENDDOC
=DOC
val Ûdest_¸_typeÝ : TYPE -> (TYPE * TYPE)
=DESCRIBE
$dest\_¸\_type$ $”ty_1\ ¸\ ty_2®$ returns $(”ty_1®, ”ty_2®)$.
=FAILURE
4018	?0 is not of the form ”ty1 ¸ ty2®
=ENDDOC
=DOC
val Ûis_¸_typeÝ : TYPE -> bool;
=DESCRIBE
Return true only when the type is a pair type, i.e. of the form: $”ty_1\ ¸\ ty_2®$, and false otherwise: no exceptions can be raised.
=ENDDOC
=DOC
val Ûmk_pairÝ : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term constructor function for generating pairs.
=GFT Definition
mk_pair(¬t1®, ¬t2®) = ¬(t1, t2)®
=TEX
=ENDDOC
It should always be possible to form a pair, but the implementation method gives a hook for a possible error so:
=FAILURE
4033	DESIGN ERROR : failed to form a pair from ?0 and ?1
=TEX
=DOC
val Ûdest_pairÝ : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for pairs.
=GFT Definition
dest_pair ¬(t1, t2)® = (¬t1®, ¬t2®)
=TEX
=FAILURE
4003	?0 is not of form: ¬(t1,t2)®
=ENDDOC
=DOC
val Ûis_pairÝ : TERM -> bool;
=DESCRIBE
Return true only when the term is a pair
(i.e. of the form
=INLINEFT
¬(a, b)®
=TEX
{}), and false otherwise: no exceptions can be raised.
=ENDDOC
\subsection{(Paired) Ì-abstractions}
=DOC
val Ûmk_ÌÝ : TERM * TERM -> TERM
=DESCRIBE
This creates a $Ì$-abstraction of an allowed variable structure from a term.
=EXAMPLE
mk_Ì (¬x® , ¬x + y®) = ¬Ì x· x + y®
mk_Ì (¬(x, y)®, ¬x + y®) = ¬Ì (x, y)· x + y®
mk_Ì (¬((x1,x2), (y1,y2))®, ¬x2 + y2®) = ¬Ì ((x1,x2), (y1,y2))· x2 + y2®
=SEEALSO
$mk\_simple\_Ì$
=FAILURE
4016	?0 is not an allowed variable structure
=ENDDOC
=DOC
val Ûdest_ÌÝ: TERM -> (TERM * TERM);
=DESCRIBE
Destroys a $Ì$-abstraction.
It can destroy paired $Ì$-abstractions, being an inverse of $mk\_Ì$.
=GFT Definition
dest_Ì ¬Ì vs· t® = (¬vs®, ¬t®)
=TEX
=SEEALSO
$dest\_simple\_Ì$
=FAILURE
4002	?0 is not of form: ¬Ì vs· t®
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val Ûis_ÌÝ : TERM -> bool;
=DESCRIBE
This function returns true iff. the term is of the form $¬Ì\ vs\ ·\ t®$.
It cannot raise exceptions.
=SEEALSO
$is\_simple\_Ì$
=ENDDOC
=DOC
val Ûlist_mk_ÌÝ : (TERM list * TERM) -> TERM;
=DESCRIBE
Repeatedly $Ì$-abstract from a term.
=GFT Definition
list_mk_Ì ([¬a®,¬b®,¬c®,...], ¬body®) = ¬Ì a b c ...· body®
=TEX
This function is implemented using $mk\_Ì$, not $mk\_simple\_Ì$.
=SEEALSO
$list\_mk\_simple\_Ì$
=FAILUREC
\paragraph{Failure}
May give rise to the error message from $mk\_Ì$.
=ENDDOC
=DOC
val Ûstrip_ÌÝ : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a multiple $Ì$-abstraction.
=GFT Definition
strip_Ì ¬Ì a b c ...· body® = [¬a®,¬b®,¬c®,...], ¬body®
=TEX
This uses $dest\_Ì$ (q.v.) rather than $dest\_simple\_Ì$.
=ENDDOC
\subsection{Conjunctions}
=DOC
val Ûmk_±Ý : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term constructor function for generating conjunctions.
=GFT Definition
mk_± (¬t1®, ¬t2®) = ¬t1 ± t2®
=TEX
=FAILURE
3015	?1 is not of type ”BOOL®
3031	?0 is not of type ”BOOL®
=ENDDOC
Message 3015, when processed, throws away its first argument:
this is so because of the implementation of $mk\_bin\_op$.
=DOC
val Ûdest_±Ý : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for conjunctions.
=GFT Definition
dest_±  ¬t1 ± t2® = (¬t1®, ¬t2®)
=TEX
=FAILURE
4032	?0 is not of form: ¬t1 ± t2®
=ENDDOC
=DOC
val Ûis_±Ý : TERM -> bool;
=DESCRIBE
Return true only when the term is a conjunction
(i.e. of form 
=INLINEFT
¬a ± b®
=TEX
), and false otherwise: no exceptions can be raised.
=ENDDOC
=DOC
val Ûlist_mk_±Ý : TERM list -> TERM;
=DESCRIBE
Conjoin a list of terms:
=GFT Definition
list_mk_± [¬a®, ¬b®, ¬c®,...] = ¬a ± b ± c ...®
=TEX
=FAILURE
3017	An empty list argument is not allowed
3031	?0 is not of type ”BOOL®
=ENDDOC
=DOC
val Ûstrip_±Ý : TERM -> TERM list
=DESCRIBE
Break a term into its constituent conjuncts, descending recursively only to the right.
=EXAMPLE
strip_± ¬a ± (b ± c) ± d® = [ ¬a®,¬b ± c®, ¬d®]
=ENDDOC
\subsection{Disjunctions}
=DOC
val Ûmk_²Ý : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term constructor function for generating disjunctions.
=GFT Definition
mk_² (¬t1®, ¬t2®) = ¬t1 ² t2®
=TEX
=FAILURE
3015	?1 is not of type ”BOOL®
3031	?0 is not of type ”BOOL®
=ENDDOC
=DOC
val Ûdest_²Ý : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for disjunctions.
=GFT Definition
dest_² ¬t1 ² t2® = (¬t1®, ¬t2®)
=TEX
=FAILURE
4027	?0 is not of form: ¬t1 ² t2®
=ENDDOC
=DOC
val Ûis_²Ý : TERM -> bool;
=DESCRIBE
Return true only when the term is a disjunction
(i.e. of form
=INLINEFT
¬a ² b®
=TEX
{}), and false otherwise: no exceptions can be raised.
=ENDDOC
=DOC
val Ûlist_mk_²Ý : TERM list -> TERM;
=DESCRIBE
A function to make a disjunction of a list of terms.
=GFT Definition
list_mk_² [¬a®, ¬b®, ¬c®,...] = ¬a ² b ² c ...®
=TEX
=FAILURE
3017	An empty list argument is not allowed
3031	?0 is not of type ”BOOL®
=ENDDOC
=DOC
val Ûstrip_²Ý : TERM -> TERM list
=DESCRIBE
Break a term into its constituent disjuncts, descending recursively only to the right.
=EXAMPLE
strip_² ¬a ² (b ² c) ² d® = [¬a®,¬b ² c®, ¬d®]
=ENDDOC
\subsection{Negations}
=DOC
val Ûmk_³Ý : TERM -> TERM;
=DESCRIBE
A derived term constructor function for generating negations.
=GFT Definition
mk_³ ¬t® = ¬³ t®
=TEX
=FAILURE
3031	?0 is not of type ”BOOL®
=ENDDOC
=DOC
val Ûdest_³Ý : TERM -> TERM;
=DESCRIBE
A derived term destructor function for negations.
=GFT Definition
dest_³ ¬³ t® = ¬t®
=TEX
=FAILURE
4029	?0 is not of form: ¬³ t®
=ENDDOC
=DOC
val Ûis_³Ý : TERM -> bool;
=DESCRIBE
Return true only when the term is a negation
(i.e. of form
=INLINEFT
¬³ x®
=TEX
{}), and false otherwise: no exceptions can be raised.
=ENDDOC
=DOC
val Ûmk_multi_³Ý : (int * TERM) -> TERM;
=DESCRIBE
$mk\_multi\_³$ $(n,t)$ will apply the constructor $mk\_³$ n times to $t$.
=EXAMPLE
mk_multi_³ (2, ¬T®) = ¬³(³ T)®
=FAILURE
3031	?0 is not of type ”BOOL®
4030	?0 is negative
=ENDDOC
=DOC
val Ûdest_multi_³Ý : TERM -> (int * TERM);
=DESCRIBE
$dest\_multi\_³$ $t$ will strip $³$ from $t$, returning the
number of times, as well as the result.
It will return $(0,t)$ if $t$ is either not boolean, or
has no negations.
=EXAMPLE
dest_multi_³ ¬³(³ T)® = (2, ¬T®)
=ENDDOC

\subsection{Bi-implications}
=DOC
val Ûmk_¤Ý : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term constructor function for generating bi-implications.
=GFT Definition
mk_¤ (¬t1®, ¬t2®) = ¬t1 ¤ t2®
=TEX
=FAILURE
3015	?1 is not of type ”BOOL®
3031	?0 is not of type ”BOOL®
=ENDDOC
=DOC
val Ûdest_¤Ý : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for bi-implications.
N.B. this may be successfully applied to boolean equalities.
=GFT Definition
dest_¤ ¬t1 ¤ t2® = (¬t1®, ¬t2®)
=TEX
=FAILURE
4031	?0 is not of form: ¬t1 ¤ t2®
=ENDDOC
=DOC
val Ûis_¤Ý : TERM -> bool;
=DESCRIBE
Return true only when the term is a bi-implication
(i.e. of form
=INLINEFT
¬a ¤ b®
=TEX
{}), and false otherwise: no exceptions can be raised.
N.B. this may be successfully applied to boolean equations.
=ENDDOC
\subsection{Conditionals}
=DOC
val Ûmk_ifÝ : (TERM * TERM * TERM) -> TERM;
=DESCRIBE
Make a conditional.
=GFT Definition
mk_if (¬c®, ¬y®, ¬n®) = ¬if c then y else n®
=TEX
=FAILURE
3012	?0 and ?1 do not have the same types
3031	?0 is not of type ”BOOL®
=ENDDOC
=DOC
val Ûdest_ifÝ : TERM -> (TERM * TERM * TERM);
=DESCRIBE
Destroy a conditional.
=GFT Definition
dest_if ¬if c then y else n® = (¬c®, ¬y®, ¬n®)
=TEX
=FAILURE
4006	?0 is not of form: ¬if c then y else n®
=ENDDOC
=DOC
val Ûis_ifÝ : TERM -> bool;
=DESCRIBE
Return true only when the term is a conditional
(i.e. of form
=INLINEFT
¬if a then b else c®
=TEX
{}), and false otherwise: no exceptions can be raised.
=ENDDOC
\subsection{Let-terms}
=DOC
val Ûmk_letÝ : ((TERM * TERM)list * TERM) -> TERM
=DESCRIBE
A derived term constructor function for generating $let$-terms.
The arguments may have any form allowed by ICL HOL Concrete Syntax.
Thus they may be variable structures formed by pairing, or single clause, non-recursive functions, whose arguments may only be variable structures formed by pairing.
=EXAMPLE
mk_let ([],¬x®) = ¬x®
mk_let([(¬x®, ¬1®)], ¬x+1®) = ¬let x = 1 in x + 1®
mk_let([(¬x®, ¬1®),(¬y®, ¬2®)], ¬x+y®) = 
	¬let x = 1 and y = 2 in x + y®
mk_let([(¬(x,y)®, ¬(1,2)®)], ¬x+y®) = 
	¬let (x,y) = (1,2) in x + y®
mk_let([(¬(x,y)®, ¬(1,2)®)], ¬x+y®) =
	 ¬let (x,y) = (1,2) in x + y®
mk_let([(¬f (x,y)®, ¬(1,2)®)], ¬x+y®) = 
	¬let f = Ì (x,y)· (1,2) in x + y®
=FAILURE
3012	?0 and ?1 do not have the same types
4007	?0 is not a well-formed LHS for mk_let
=ENDDOC
=DOC
val Ûdest_letÝ : TERM -> ((TERM * TERM)list * TERM);
=DESCRIBE
A derived term destructor function for $let$-terms.
See $mk\_let$ for details of format.
The distinction between a local function definition,
and a variable structure bound to an abstraction is lost,
with both being destroyed to the second form.
=EXAMPLE
dest_let(mk_let([(¬f x®, ¬y®)],¬bdy®)) = 
	([(¬f®, ¬Ì x· y®)], ¬bdy®)
dest_let(mk_let([(¬f®, ¬Ì x· y®)],¬bdy®)) = 
	([(¬f®, ¬Ì x· y®)], ¬bdy®)
=FAILURE
4009	?0 is not of form: ¬let ... in ...®
=FAILUREC
$dest\_let$ $(mk\_let([],term))$ will actually fail (unless $term$ is already a $let$-term),
as apply $mk\_let$ to $([],term))$ will just return $term$.
=ENDDOC
=DOC
val Ûis_letÝ : TERM -> bool;
=DESCRIBE
Return true only when the term is a $let$-term
(i.e. of form
=INLINEFT
¬let x = y in z®
=TEX
{}), and false otherwise: no exceptions can be raised.
=ENDDOC
=DOC
val Ûlist_mk_letÝ : (((TERM * TERM)list)list * TERM) -> TERM
=DESCRIBE
This generates a nested $let$-term.
=EXAMPLE
list_mk_let ([[(¬x®,¬1®)],[(¬y®,¬2®)]],¬x+y®) = 
	¬let x = 1 in let y = 2 in x+y®
=ENDDOC
=DOC
val Ûstrip_letÝ : TERM -> ((TERM * TERM)list)list * TERM
=DESCRIBE
This destroys a sequence of nested $let$ constructs.
=GFT Example
strip_let ¬let x = 1 in let y = 2 in x+y® =
	([[(¬x®,¬1®)],[(¬y®,¬2®)]],¬x+y®)
=ENDDOC
\subsection{Enumerated Sets} 
=DOC
val Ûmk_enum_setÝ : TERM list -> TERM
=DESCRIBE
A derived term constructor function for generating enumerated sets.
The argument is a list of the members of the set.
The type of a set of elements of type $”TY®$ is $”TY\ SET®$.
If the term list is empty the function will fail 
(see $mk\_š$).
The set must be of terms with the same HOL type.
=GFT Definition
mk_enum_set [¬a®, ¬b®, ...] = ¬{a, b, ...}®
=TEX
=FAILURE
3012	?0 and ?1 do not have the same types
3017	An empty list argument is not allowed
=ENDDOC
=DOC
val Ûmk_šÝ : TYPE -> TERM;
=DESCRIBE
A derived term constructor function for generating an empty (enumerated) set with elements of a given type.
=GFT Definition
mk_š  ” ty® = ¬š : ty SET®
=TEX
=SEEALSO
$mk\_enum\_set$
=ENDDOC
=DOC
val Ûdest_enum_setÝ : TERM -> (TERM list);
=DESCRIBE
A derived term destructor function for enumerated sets.
=GFT Definition
dest_enum_set ¬{a, b, ...}® = [¬a®, ¬b®, ...]
=TEX
=FAILURE
4011	?0 is not of form: ¬{t1, ...}®
=ENDDOC
=DOC
val Ûdest_šÝ : TERM -> TYPE;
=DESCRIBE
A derived term destructor function for empty enumerated sets.
=GFT Definition
dest_š ¬š:ty SET® = ”ty®
=TEX
=FAILURE
4035	?0 is not of form: ¬š®
=ENDDOC
=DOC
val Ûis_enum_setÝ : TERM -> bool;
=DESCRIBE
Return true only when the term is an enumerated set
(i.e. of form
=INLINEFT
¬{a, b, ...}®
=TEX
{}), and false otherwise: no exceptions can be raised.
=ENDDOC
=DOC
val Ûis_šÝ : TERM -> bool;
=DESCRIBE
Return true only when the term is an empty enumerated set, $¬š®$, and false otherwise: no exceptions can be raised.
=ENDDOC
\subsection{Set Comprehensions}
=DOC
val Ûmk_set_compÝ : (TERM * TERM) -> TERM
=DESCRIBE
A derived term constructor function for generating set comprehensions.
=EXAMPLE
mk_set_comp (¬x®, ¬x > 5®) = ¬{ x | x > 5}®
=FAILURE
3015	?1 is not of type ”BOOL®
4016	?0 is not an allowed variable structure
=ENDDOC
=DOC
val Ûdest_set_compÝ : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for set comprehensions.
=EXAMPLE
dest_set_comp ¬{ x | x > 5}® = (¬x®, ¬x > 5®) 
=FAILURE
4013	?0 is not of form: ¬{v | p}®
=ENDDOC
=DOC
val Ûis_set_compÝ : TERM -> bool;
=DESCRIBE
Return true only when the term is a set comprehension
(i.e. of form
=INLINEFT
¬{v | p}®
=TEX
{}), and false otherwise: no exceptions can be raised.
=ENDDOC
\subsection{List-terms}
=DOC
val Ûmk_listÝ : TERM list -> TERM
=DESCRIBE
A derived term constructor function for generating list-terms.
The argument is a list of the members of the list.
If the term list is empty the function will fail 
(see $mk\_empty\_list$).
The list must be of terms with the same HOL type.
=GFT Definition
mk_list [¬a®, ¬b®, ...] = ¬[a, b, ...]®
=TEX
=FAILURE
3012	?0 and ?1 do not have the same types
3017	An empty list argument is not allowed
=ENDDOC
=DOC
val Ûmk_empty_listÝ : TYPE -> TERM
=DESCRIBE
A derived term constructor function for generating an empty list term with elements of a given type.
=GFT Definition
mk_empty_list  ” ty® = ¬[] : ty LIST®
=TEX
=SEEALSO
$mk\_list$
=ENDDOC
=DOC
val Ûdest_listÝ : TERM -> (TERM list);
=DESCRIBE
A derived term destructor function for list-terms.
=GFT Definition
dest_list ¬[a, b, ...]® = [¬a®, ¬b®, ...]
dest_list ¬[]® = []
=TEX
=FAILURE
4015	?0 is not of form: ¬[t1,...]®
=ENDDOC
=DOC
val Ûdest_empty_listÝ : TERM -> TYPE;
=DESCRIBE
A derived term destructor function for empty lists.
=GFT Definition
dest_list ¬[]:ty LIST® = ”ty®
=TEX
=FAILURE
4034	?0 is not of form: ¬[]®
=ENDDOC
=DOC
val Ûis_listÝ : TERM -> bool;
=DESCRIBE
Return true only when the term is a list-term
(i.e. of form
=INLINEFT
¬[a, b, ...]®
=TEX
{}), and false otherwise: no exceptions can be raised.
=ENDDOC
=DOC
val Ûis_empty_listÝ : TERM -> bool;
=DESCRIBE
Return true only when the term is an empty list-term, $¬[]®$, and false otherwise: no exceptions can be raised.
=ENDDOC
\subsection{(Paired) µ-terms}
=DOC
val Ûmk_µÝ : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term constructor function for generating $µ$-terms.
=GFT Definition
mk_µ (¬varstruct®, ¬body®) = ¬µ varstruct· body®
=TEX
$varstruct$ may be any allowed variable structure.
=FAILURE
3015	?1 is not of type ”BOOL®
4016	?0 is not an allowed variable structure
=SEEALSO
$mk\_simple\_µ$
=ENDDOC
=DOC
val Ûdest_µÝ : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for $µ$-terms.
It may destroy a paired abstraction $µ$-term, being the inverse of $mk\_µ$.
=GFT Definition
dest_µ  ¬µ varstruct· body® = (¬varstruct®, ¬body®)
=TEX
=FAILURE
4017	?0 is not of form: ¬µ vs· t®
=ENDDOC
=DOC
val Ûis_µÝ : TERM -> bool;
=DESCRIBE
Return true only when the term is a $µ$-term
(i.e. of form
=INLINEFT
¬µ vs · t®
=TEX
{}), possibly formed with paired abstraction, and false otherwise: no exceptions can be raised.
=SEEALSO
$is\_simple\_µ$
=ENDDOC
=DOC
val Ûlist_mk_µÝ : TERM list * TERM -> TERM;
=DESCRIBE
Repeatedly universally quantify a term.
=GFT Definition
list_mk_µ ([¬a®,¬b®,¬c®,...], ¬body®) = ¬µ a b c ...· body®
=TEX
This uses $mk\_µ$ to generate its result.
=FAILUREC
\paragraph{Failure}
This may give the errors of $mk\_µ$.
=ENDDOC
=DOC
val Ûstrip_µÝ : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a multiply universally quantified term
(perhaps with paired abstractions).
=GFT Definition
strip_µ ¬µ a b c ...· body® = [¬a®,¬b®,¬c®,...], ¬body®
=TEX
=ENDDOC
=DOC
val Ûstrip_simple_µÝ : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a multiply universally simply quantified term.
=GFT Definition
strip_simple_µ ¬µ a b c ...· body® = [¬a®,¬b®,¬c®,...], ¬body®
=TEX
=ENDDOC
\subsection{(Paired) ¶-terms}
=DOC
val Ûmk_¶Ý : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term constructor function for generating $¶$-terms.
=GFT Definition
mk_¶ (¬varstruct®, ¬body®) = ¬¶ varstruct· body®
=TEX
$varstruct$ may be any allowed variable structure.
=FAILURE
3015	?1 is not of type ”BOOL®
4016	?0 is not an allowed variable structure
=SEEALSO
$mk\_simple\_¶$
=ENDDOC
=DOC
val Ûdest_¶Ý : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for $¶$-terms.
It may destroy paired abstraction $¶$-terms, being the inverse of $mk\_¶$.
=GFT Definition
dest_¶ ¬¶ varstruct· body® = (¬varstruct®, ¬body®)
=TEX
=FAILURE
4020	?0 is not of form: ¬¶ vs· t®
=SEEALSO
$dest\_simple\_¶$
=ENDDOC
=DOC
val Ûis_¶Ý : TERM -> bool;
=DESCRIBE
Return true only when the term is a $¶$-term
(i.e. of form
=INLINEFT
¬¶ vs · t®
=TEX
{}), possibly formed with paired abstraction, and false otherwise: no exceptions can be raised.
=SEEALSO
$is\_simple\_¶$
=ENDDOC
=DOC
val Ûlist_mk_¶Ý : TERM list * TERM -> TERM;
=DESCRIBE
Repeatedly existentially quantify a term.
=GFT Definition
list_mk_¶ ([¬a®,¬b®,¬c®,...], ¬body®) = ¬¶ a b c ...· body®
=TEX
This uses $mk\_¶$ to generate its result.
=FAILUREC
\paragraph{Failure}
This may give the errors of $mk\_¶$.
=ENDDOC
=DOC
val Ûstrip_¶Ý : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a repeatedly existentially quantified term, possibly formed with paired abstractions.
=GFT Definition
strip_¶ ¬¶ a b c ...· body® = [¬a®,¬b®,¬c®,...], ¬body®
=TEX
=ENDDOC
=DOC
val Ûstrip_simple_¶Ý : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a repeatedly existentially simply quantified term.
=GFT Definition
strip_simple_¶ ¬¶ a b c ...· body® = [¬a®,¬b®,¬c®,...], ¬body®
=TEX
=ENDDOC
\subsection{Simple and Paired ¶$_1$-terms}
=DOC
val Ûmk_simple_¶‰1Ý : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term constructor function for generating simply abstracted $¶_1$-terms.
=GFT Definition
mk_simple_¶‰1 (¬var®, ¬body®) = 
	¬¶‰1 var· body®
=TEX
$var$ must be a variable.
=FAILURE
3007	?0 is not a term variable
3015	?1 is not of type ”BOOL®
=SEEALSO
$mk\_¶_1$
=ENDDOC
=DOC
val Ûdest_simple_¶‰1Ý : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for simply abstracted $¶_1$-terms.
It may destroy only simple abstraction $¶_1$-terms, being the inverse of $mk\_simple\_¶_1$.
=GFT Definition
dest_simple_¶‰1 ¬¶‰1 var· body® = (¬var®, ¬body®)
=TEX
=FAILURE
4019	?0 is not of form: ¬¶‰1 v· t®
=SEEALSO
$dest\_¶_1$
=ENDDOC
=DOC
val Ûis_simple_¶‰1Ý : TERM -> bool;
=DESCRIBE
Return true only when the term is a $¶_1$-term
(i.e. of form
=INLINEFT
¬¶‰1 x · t®
=TEX
{}), formed only by simple abstraction, and false otherwise: no exceptions can be raised.
=SEEALSO
$is\_¶_1$
=ENDDOC
=DOC
val Ûmk_¶‰1Ý : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term constructor function for generating $¶_1$-terms.
=GFT Definition
mk_¶‰1 (¬varstruct®, ¬body®) = 
	¬¶‰1 varstruct· body®
=TEX
$varstruct$ may be any allowed variable structure.
=FAILURE
3015	?1 is not of type ”BOOL®
4016	?0 is not an allowed variable structure
=SEEALSO
$mk\_¶_1$
=ENDDOC
=DOC
val Ûdest_¶‰1Ý : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for $¶_1$-terms.
It may destroy paired abstraction $¶_1$-terms, being the inverse of $mk\_¶_1$.
=GFT Definition
dest_¶‰1 ¬¶‰1 varstruct· body® = 
	(¬varstruct®, ¬body®)
=TEX
=FAILURE
4021	?0 is not of form: ¬¶‰1 vs· t®
=SEEALSO
$dest\_simple\_¶_1$
=ENDDOC
=DOC
val Ûis_¶‰1Ý : TERM -> bool;
=DESCRIBE
Return true only when the term is a $¶_1$-term
(i.e. of form
=INLINEFT
¬¶‰1 vs · t®
=TEX
{}), possibly formed with paired abstraction, and false otherwise: no exceptions can be raised.
=SEEALSO
$is\_simple\_¶_1$
=ENDDOC
``list'' and ``stripping'' forms of unique existence seem
unnecessary.
\subsection{Å-terms}
=DOC
val Ûmk_ÅÝ : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term constructor function for generating $Å$-terms.
=GFT Definition
mk_Å (¬varstruct®, ¬body®) = ¬Å varstruct· body®
=TEX
$varstruct$ may be any allowed variable structure.
=FAILURE
3015	?1 is not of type ”BOOL®
4016	?0 is not an allowed variable structure
=ENDDOC
=DOC
val Ûdest_ÅÝ : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for $Å$-terms.
=GFT Definition
dest_Å ¬Å varstruct· body® = (¬varstruct®, ¬body®)
=TEX
=FAILURE
4023	?0 is not of form: ¬Å vs· t®
=ENDDOC
=DOC
val Ûis_ÅÝ : TERM -> bool;
=DESCRIBE
Return true only when the term is a $Å$-term
(i.e. of form
=INLINEFT
¬Å vs · t®
=TEX
{}), possibly formed with paired abstraction, and false otherwise: no exceptions can be raised.
=ENDDOC
The following two functions are only present for completeness,
rather than likely use.
=DOC
val Ûlist_mk_ÅÝ : TERM list * TERM -> TERM;
=DESCRIBE
Repeatedly apply $Å$ to a term.
=GFT Definition
list_mk_Å ([¬a®,¬b®,¬c®,...], ¬body®) = ¬Å a b c ...· body®
=TEX
=FAILUREC
\paragraph{Failure}
This may give the errors of $mk\_Å$.
=ENDDOC
=DOC
val Ûstrip_ÅÝ : TERM -> (TERM list * TERM);
=DESCRIBE
Strip multiple $Å$'s.
=GFT Definition
strip_Å ¬Å a b c ...· body® = [¬a®,¬b®,¬c®,...], ¬body®
=TEX
=ENDDOC
=SML
end(* signature of TypesAndTerms *);
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

One facet that should receive attention is the handling of unusually formed terms. For instance, $Cons\ h\ t$, where $h$ and $t$ are variables, should not be recognised as a list for the purposes of $dest\_list$.
We claim that $mk\_term$ $o$ $dest\_term$ is the identity function on terms,
and this should be put to the test.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


