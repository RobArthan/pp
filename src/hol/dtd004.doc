=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
\TPPtitle{Detailed Design for Derived Terms}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for Derived Terms}
\TPPref{DS/FMU/IED/DTD004}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for functions concerning derived terms that are not used in defining the type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document Control}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item [Issue 1.1]
First version.
Based on part of \cite{DS/FMU/IED/SML002}.
\item [Issue 1.2]
Fixed a duplicate error message, and ordered an index to be printed.
\item [Issue 1.3, 1.4]
Changes made during implementation of this documents designs.
\item [Issue 1.5]
Removed $mk\_fun\_type$ (as now $mk\_funtype$ in \cite{DS/FMU/IED/DTD003}).
Corrected examples for $mk\_let$.
Improved error messages.
\item [Issue 1.6]
Modified in line with changes in issue 1.9 of \cite{DS/FMU/IED/DTD003}.
The type $DERIV\_TERM$ becomes $DEST\_TERM$.
\item [Issue 1.7]
Added $mk\_empty\_$ for $enum\_set$ and $list$.
\item [Issue 1.8]
Added constructors, etc, for $Ñ_1$, $T$ and $F$.
Corrected some examples.
\item [Issue 1.9]
Redesigned $strip\_binder$, added $simple\_strip\_binder$.
Changed $?\_T$ and $?\_F$ to $?\_t$ and $?\_f$.
Added $simple\_strip\_Ñ$ and $simple\_strip\_É$.
\item [Issue 1.10]
Fixed some typos.
\item [Issue 1.11,1.12]
Changes in response to inspection IR0017.
\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
As described in \cite{DS/FMU/IED/HLD007},
as an important contribution to ease of use, in addition to the two primitive
constructors for types, and the four for terms we supply a variety
of derived constructors --- composites of the primitive
constructors corresponding to common syntactic abbreviations.
The coverage of derived operations is such as to support the
concrete syntax defined in \cite{DS/FMU/IED/DEF001} and the
various object language types and constants needed to define
the logic in \cite{DS/FMU/IED/SPC003}. For uniformity, the derived
operations also cover any of the standard predicate calculus
connectives which are not mentioned in \cite{DS/FMU/IED/SPC003}
(e.g. unique existential quantifier).
This document completes the coverage started in
\cite{DS/FMU/IED/DTD003}, which only gave sufficient material
to declare the abstract data type $THM$.

The high-level specification for the code may be considered
to be given in \cite{DS/FMU/IED/SPC001}.
The design is
implemented in \cite{DS/FMU/IED/IMP004}.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design of certain derived terms of ICL HOL, and functions to handle them.
\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile,
in particular \cite{DS/FMU/IED/IMP003}.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}

\subsubsection{Terminology}
In may be necessary when using the following terminology to remove ambiguity by prefixing some of the following with the word ``term'' or ``HOL'', to constrast with 
Standard ML terminology, or, for instance, theorems
whose conclusions are describable in the same terms.

\begin{tabular}{p{1.3in} p{4.9in}}
pair & A term of the form $ª(x,\ y)º$, as constructed by $mk\_pair$: a tuple of two elements. \\
pair type & A HOL type of the form $ª:ty_1\ â\ ty_2º$, as constructed by $mk\_â\_type$: an instance of the HOL type of pairs. \\
conjunction & A term of the form $ªx\ Ä\ yº$, as constructed by $mk\_Ä$. \\
disjunction & A term of the form $ªx\ Å\ yº$, as constructed by $mk\_Å$. \\
negation & A term of the form $ªå xº$, as constructed by $mk\_å$. \\
bi-implication & A term of the form $ªx\ Ç\ yº$, as constructed by $mk\_Ç$. \\
conditional & A term of the form $ªif\ x\ then\ y\ else\ zº$, as constructed by $mk\_if$. \\
$let$-term & A term of the form $ªlet\ x\ =\ y\ in\ z[x]º$, as constructed by $mk\_let$: it provides local definition within a term. \\
enumerated set & A term of the form
$ª{a,\ b,\ ...}º$, as constructed by $mk\_enum\_set$: a set defined by the enumeration of its elements. \\
set comprehension & A term of the form
$ªSetComp\ x\ é\ P[x]º$, as constructed by $mk\_set\_comp$: a set defined to be those elements of a type that satisfy a predicate. \\
list-term & A term of the form $ª[a,\ b,\ ...]º$, as constructed by $mk\_list$: a list within the HOL object language. \\
$Ñ_1$-term & A term of the form $ªÑ_1\ x\ é\ P[x]º$ or $ªÑ_1\ (x,y)\ é\ P[x,y]º$, as constructed by $simple\_mk\_Ñ_1$ or $mk\_Ñ_1$. \\
$á$-term & A term of the form $ªá\ x\ é\ P[x]º$, as constructed by $mk\_á$: a choice from those elements of a type that satisfy a predicate. \\
\end{tabular}

=TEX
=TEX
\section{DERIVED TERMS}
=DOC
signature ‚TypesAndTerms· = sig
=DESCRIBE
This provides various functions on derived $TERM$s, which are not considered necessary to create the abstract data type $THM$.
It also contains, by inclusion, the types, and functions on the types $TERM$ and $TYPE$ from structure $icl'TypesAndTerms$(q.v.).
=ENDDOC
We wish to have this signature as the one source of type and term functions, to allow a seamless movement of items from
this signature to $icl'TypesAndTerms$.
=SML
include icl'TypesAndTerms;
=TEX
\subsection{Destroyed Terms}
The following data type may act as a summary of all of the term constructors
provided by this document.
The names may be derived from the value constructors by stripping off ``D'', making the
name lower case and using $\_$ as a separator for different atoms in a name, if appropriate, and prefixing the whole by ``mk$\_$''.
It also follows the same typing
as the constructors.
=DOC
datatype ‚DEST_TERM· = ‚DVar· of string * TYPE |
	‚DConst· of string * TYPE |
	‚DApp· of TERM * TERM |
	‚Dç· of TERM * TERM |
	‚DEq· of TERM * TERM |
	‚Dä· of TERM * TERM |
	‚DT· |
	‚DF· |
	‚Då· of TERM |
	‚DPair· of TERM * TERM |
	‚DÄ· of TERM * TERM |
	‚DÅ· of TERM * TERM |
	‚DÇ· of TERM * TERM |
	‚DLet· of ((TERM * TERM)list * TERM) |
	‚DEnumSet· of TERM list |
	‚D§· of TYPE |
	‚DSetComp· of TERM * TERM |
	‚DList· of TERM list |
	‚DEmptyList· of TYPE |
	‚DÉ· of TERM * TERM |
	‚DÑ· of TERM * TERM |
	‚DÑ%down%1· of TERM * TERM |
	‚Dá· of TERM * TERM |
	‚DIf· of (TERM * TERM * TERM);
=DESCRIBE
This type is that of a term destroyed using the appropriate derived destructor functions (e.g. $dest\_eq$) as well as the primitive ones.
The type given to $D§$ and $DEmptyList$ is the type of an element of the associated set or list.
The type is related to $TERM$ by $mk\_term$ (q.v.) and $dest\_term$ (q.v)
=SEEALSO
$SIMPLE\_DEST\_TERM$
=ENDDOC
=DOC
val ‚dest_term· : TERM -> DEST_TERM
=DESCRIBE
This function returns the ``best'' interpretation of a term in the form of an object of type $DEST\_TERM$.
E.g. it will return $DEq(\ 1\ 2)$ rather than $DComb ((\$=\ 1), 2)$.
It will also use the paired abstraction forms of functions in preference to the simple forms, e.g., it uses $dest\_ç$ not $simple\_dest\_ç$.

The function assumes that the name of a constant is sufficient
to identify it without checking the type, as with, e.g., $dest\_bin\_op$(q.v).
=SEEALSO
$mk\_term$
=ENDDOC
=DOC
val ‚mk_term· : DEST_TERM -> TERM
=DESCRIBE
Create a term from a derived term.
It is an inverse to $dest\_term$ (q.v), and therefore understands how to handle paired abstractions.

The function is implemented using the individual primitive and derived term constructors (e.g. $mk\_const$ and $mk\_É$), with what checks they use.
=FAILUREC
\paragraph{Failure}
This function will fail with the same messages as the appropriate term construction functions.
=ENDDOC
\subsection{Boolean Constants}
=DOC
val ‚mk_t· : TERM;
=DESCRIBE
The term ªT : BOOLº.
=ENDDOC
=DOC
val ‚is_t· : TERM -> bool;
=DESCRIBE
Is the term ªT : BOOLº ?
=ENDDOC
=DOC
val ‚mk_f· : TERM;
=DESCRIBE
The term ªF : BOOLº.
=ENDDOC
=DOC
val ‚is_f· : TERM -> bool;
=DESCRIBE
Is the term  ªF : BOOLº ?
=ENDDOC
Destructor and list versions of these functions are not necessary.
\subsection{Generic Binder Functions}
The following provide a standard pattern for implementing
constructor and destructor functions for binders.
=DOC
val ‚mk_binder· : string -> int -> (TYPE -> TYPE -> TERM) ->
	(TERM * TERM) -> TERM;
=DESCRIBE
A generic method of implementing binder constructor functions:
ÛDefinition
mk_binder area msg binder_nm (varstruct, body) = binder'(ç varstruct é body)
Ê
$binder'$ is formed by applying $binder$ to the types of the 
$varstruct$ and $body$.
The $varstruct$ may be any term that follows the syntax of \cite{DS/FMU/IED/DEF001}.
=FAILURE
4016	?0 is not an allowed variable structure
=FAILUREC
\paragraph{Failure}
If the term cannot be made, then the error will be from $area$, with a message indexed by $msg$.
If the first term argument is not an allowed variable structure
then failure 4016 is raised from area $area$.
=ENDDOC
=DOC
val ‚dest_binder· : string -> int -> string -> TERM -> TERM * TERM;
=DESCRIBE
A generic method of implementing binder destructor functions:
ÛDefinition
dest_binder area msg binder_nm ªbinder(ç varstruct é body)º = (varstruct, body)
Ê
where $binder$ is a constant whose name is $binder\_nm$.
The $varstruct$ may be any structure allowed by the ICL HOL Concrete Syntax.
=FAILUREC
\paragraph{Failure}
If the term cannot be destroyed, then the error will be from $area$, with a message indexed by $msg$.
=ENDDOC
=DOC
val ‚is_binder· : string -> TERM -> bool;
=DESCRIBE
$is\_binder$ $binder\_nm$ $term$ returns true Iff. $term$ 
is of the form $ªbinder(ç varstruct é body)º$,
where $binder$ is a constant whose name is $binder\_nm$.
=ENDDOC
=DOC
val ‚strip_binder· : string -> TERM -> TERM list * TERM;
=DESCRIBE
$strip\_binder$ $binder$ applied to 
\[ªbinder(ç vs_1 é binder(ç vs_2 é \ldots é body)\ldots)º\]
will return
\[[vs_1, vs_2, \ldots], body\]
where the $vs_i$ are allowed variable structures.
The function acts as $dest_binder$ (q.v), and will handle paired abstraction terms.
It will return an empty list and the original term if the
supplied term is not formed using the binder.
=ENDDOC
=DOC
val ‚simple_strip_binder· : string -> TERM -> TERM list * TERM;
=DESCRIBE
$simple\_strip\_binder$ $binder$ applied to 
\[ªbinder(ç v_1 é binder(ç v_2 é \ldots é body)\ldots)º\]
will return
\[[v_1, v_2, \ldots], body\]
The function acts as $simple\_dest\_binder$ (q.v), and will not handle paired abstraction terms.
It will return an empty list and the original term if the
supplied term is not formed using the binder.
=ENDDOC
=DOC
val ‚list_mk_binder· : (TERM * TERM -> TERM) -> (TERM list * TERM) -> TERM;
=DESCRIBE 
If $maker$ $(vs,b)$ makes an abstraction $ªbind\ vs\ é\ bº$,
then
$list\_mk\_binder$ $maker$ $([vs_1, vs_2, \ldots],body)$
returns
\[ªbind\ vs_1 é bind\ vs_2 é \ldots é bodyº\]
Notice that this can be used for implementing both simple and paired abstractions, with the $vs_i$ being variable structures when so allowed, and otherwsie variables.
=ENDDOC
\subsection{Pairs}
=DOC
val ‚mk_â_type· : (TYPE * TYPE) -> TYPE
=DESCRIBE
$mk\_â\_type$ $(t_1, t_2)$ returns a pair type: $ª:t_1\ â\ t_2º$.
=ENDDOC
=DOC
val ‚dest_â_type· : TYPE -> (TYPE * TYPE)
=DESCRIBE
$dest\_â\_type$ $ª:t_1\ â\ t_2º$ returns $(t_1, t_2)$.
=FAILURE
4018	?0 is not of the form ª:ty1 â ty2º
=ENDDOC
=DOC
val ‚is_â_type· : TYPE -> bool;
=DESCRIBE
Is the type a pair type, i.e. of the form: $ª:t_1\ â\ t_2º$?
=ENDDOC
=DOC
val ‚mk_pair· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating pairs.
=FAILURE
4033	DESIGN ERROR : failed to form a pair from ?0 and ?1
=ENDDOC
=DOC
val ‚dest_pair· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for pairs.
=FAILURE
4003	?0 is not of form: ª(t1,t2)º
=ENDDOC
=DOC
val ‚is_pair· : TERM -> bool;
=DESCRIBE
Is the term a pair?
=ENDDOC
\subsection{Paired ç-abstractions}
=DOC
val ‚mk_ç· : TERM * TERM -> TERM
=DESCRIBE
This creates a $ç$-abstraction with the general syntax called for
by the ICL HOL Concrete Syntax.
=EXAMPLE
mk_ç (x , x + y) = ç x é x + y
mk_ç ((x, y), x + y) = ç (x, y) é x + y
mk_ç (((x1,x2), (y1,y2)), x2 + y2) = ç ((x1,x2), (y1,y2)) é x2 + y2
=SEEALSO
$simple\_mk\_ç$
=FAILURE
4016	?0 is not an allowed variable structure
=ENDDOC
=DOC
val ‚dest_ç·: TERM -> (TERM * TERM);
=DESCRIBE
Destroys a $ç$-abstraction.
It can destroy paired $ç$-abstractions, being an inverse of $mk\_ç$.
=SEEALSO
$simple\_dest\_ç$
=FAILURE
4002	?0 is not of form: ªç vs é tº
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=ENDDOC
=DOC
val ‚is_ç· : TERM -> bool;
=DESCRIBE
This function returns true iff. the term is of the form $ªç\ vs\ é\ tº$.
=SEEALSO
$simple\_is\_ç$
=ENDDOC
=DOC
val ‚list_mk_ç· : (TERM list * TERM) -> TERM;
=DESCRIBE
Repeatedly $ç$-abstract from a term.
ÛDefinition
list_mk_ç ([ªaº,ªbº,ªcº,...], ªbodyº) = ªç a b c ... é bodyº
Ê
This function is implemented using $mk\_ç$, not $simple\_mk\_ç$.
=SEEALSO
$simple\_list\_mk\_ç$
=FAILUREC
\paragraph{Failure}
May give rise to the error message from $mk\_ç$.
=ENDDOC
=DOC
val ‚strip_ç· : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a multiple $ç$-abstraction.
ÛDefinition
strip_ç ªç a b c ... é bodyº = [ªaº,ªbº,ªcº,...], ªbodyº
Ê
This uses $dest\_ç$ (q.v.) rather than $simple\_dest\_ç$.
=ENDDOC
\subsection{Conjunctions}
=DOC
val ‚mk_Ä· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating conjunctions.
=FAILURE
3015	?1 is not of type ª:BOOLº
3031	?0 is not of type ª:BOOLº
=ENDDOC
=DOC
val ‚dest_Ä· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for conjunctions.
=FAILURE
4032	?0 is not of form: ªt1 Ä t2º
=ENDDOC
=DOC
val ‚is_Ä· : TERM -> bool;
=DESCRIBE
IS the term a conjunction?
=ENDDOC
=DOC
val ‚list_mk_Ä· : TERM list -> TERM;
=DESCRIBE
Conjoin a list of terms:
ÛDefinition
list_mk_Ä [ªaº, ªbº, ªcº,...] = ªa Ä b Ä c ...º
Ê
=FAILURE
3017	An empty list argument is not allowed
3031	?0 is not of type ª:BOOLº
=ENDDOC
=DOC
val ‚strip_Ä· : TERM -> TERM list
=DESCRIBE
Break a term into its constituent conjuncts, descending recursively only to the right.
=EXAMPLE
strip_Ä ªa Ä (b Ä c) Ä dº = [ªaº,ªb Ä cº, ªdº]
=ENDDOC
\subsection{Disjunctions}
=DOC
val ‚mk_Å· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating disjunctions.
=FAILURE
3015	?1 is not of type ª:BOOLº
3031	?0 is not of type ª:BOOLº
=ENDDOC
=DOC
val ‚dest_Å· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for disjunctions.
=FAILURE
4027	?0 is not of form: ªt1 Å t2º
=ENDDOC
=DOC
val ‚is_Å· : TERM -> bool;
=DESCRIBE
Is the term a disjunction?
=ENDDOC
=DOC
val ‚list_mk_Å· : TERM list -> TERM;
=DESCRIBE
A function to make a disjunction of a list of terms.
ÛDefinition
list_mk_Å [ªaº, ªbº, ªcº,...] = ªa Å b Å c ...º
Ê
=FAILURE
3017	An empty list argument is not allowed
3031	?0 is not of type ª:BOOLº
=ENDDOC
=DOC
val ‚strip_Å· : TERM -> TERM list
=DESCRIBE
Break a term into its constituent disjuncts, descending recursively only to the right.
=EXAMPLE
strip_Å ªa Å (b Å c) Å dº = [ªaº,ªb Å cº, ªdº]
=ENDDOC
\subsection{Negations}
=DOC
val ‚mk_å· : TERM -> TERM;
=DESCRIBE
A derived term construction function for generating negations.
=FAILURE
3031	?0 is not of type ª:BOOLº
=ENDDOC
=DOC
val ‚dest_å· : TERM -> TERM;
=DESCRIBE
A derived term destructor function for negations.
=FAILURE
4029	?0 is not of form: ªå tº
=ENDDOC
=DOC
val ‚is_å· : TERM -> bool;
=DESCRIBE
Is the term a negation?
=ENDDOC
=DOC
=DOC
val ‚mk_multi_å· : (int * TERM) -> TERM;
=DESCRIBE
$mk\_multi_\å$ $(n,t)$ will apply n times the constructor $mk\_å$ to $t$.
=FAILURE
3031	?0 is not of type ª:BOOLº
4030	?0 is negative
=ENDDOC
=DOC
val ‚dest_multi_å· : TERM -> (int * TERM);
=DESCRIBE
$dest\_multi_\å$ $t$ will strip $å$ from $t$, returning the
number of times, as well as the result.
It will return $(0,t)$ if $t$ is either not boolean, or
has no negations.
=ENDDOC

\subsection{Bi-implications}
=DOC
val ‚mk_Ç· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating bi-impications.
=FAILURE
3015	?1 is not of type ª:BOOLº
3031	?0 is not of type ª:BOOLº
=ENDDOC
=DOC
val ‚dest_Ç· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for bi-implications.
N.B. this may be successfully applied to boolean equalities.
=FAILURE
4031	?0 is not of form: ªt1 Ç t2º
=ENDDOC
=DOC
val ‚is_Ç· : TERM -> bool;
=DESCRIBE
Is the term a bi-implication?
N.B. this may be successfully applied to boolean equations.
=ENDDOC
\subsection{Conditionals}
=DOC
val ‚mk_if· : (TERM * TERM * TERM) -> TERM;
=DESCRIBE
$mk\_if$ $(c,\ y,\ n)$ gives the term $ªif\ c\ then\ y\ else\ nº$.
=FAILURE
3031	?0 is not of type ª:BOOLº
3012	?0 and ?1 do not have the same types
=ENDDOC
=DOC
val ‚dest_if· : TERM -> (TERM * TERM * TERM);
=DESCRIBE
Destroys a term of form $ªif\ c\ then\ y\ else\ nº$.
=FAILURE
4006	?0 is not of form: ªif c then y else nº
=ENDDOC
=DOC
val ‚is_if· : TERM -> bool;
=DESCRIBE
A test for conditionals.
=ENDDOC
\subsection{Let-terms}
=DOC
val ‚mk_let· : ((TERM * TERM)list * TERM) -> TERM
=DESCRIBE
A derived term construction function for generating $let$-terms.
The arguments may have any form allowed by ICL HOL Concrete Syntax.
Thus they may be variable structures formed by pairing, or single clause, non-recursive functions, whose arguments may only be variable structures formed by pairing.
=EXAMPLE
mk_let ([],x) = x
mk_let([(x, 1)], (x+1)) = (let x = 1 in x + 1)
mk_let([(x, 1),(y, 2)], (x+y)) = (let x = 1 and y = 2 in x + y)
mk_let([((x,y), (1,2))], (x+y)) = (let (x,y) = (1,2) in x + y)
mk_let([((x,y), (1,2))], (x+y)) = (let (x,y) = (1,2) in x + y)
mk_let([(f (x,y), (1,2))], (x+y)) = (let f = ç (x,y) é (1,2) in x + y)
=FAILURE
4007	?0 is not a well-formed LHS for mk_let
3012	?0 and ?1 do not have the same types
=ENDDOC
=DOC
val ‚dest_let· : TERM -> ((TERM * TERM)list * TERM);
=DESCRIBE
A derived term destructor function for $let$-terms.
See $mk\_let$ for details of format.
The distinction between a local function definition,
and a variable structure bound to an abstraction is lost,
with both being destroyed to the second form.
=EXAMPLE
dest_let(mk_let([(f x, y)],bdy)) = ([(f, ç x é y)], bdy)
dest_let(mk_let([(f, ç x é y)],bdy)) = ([(f, ç x é y)], bdy)
=FAILURE
4009	?0 is not of form: ªlet ... in ...º
=FAILUREC
$dest\_let$ $(mk\_let([],term))$ will actually fail (unless $term$ is already a $let$-term),
as $(mk\_let([],term))$ is a null operation.
=ENDDOC
=DOC
val ‚is_let· : TERM -> bool;
=DESCRIBE
A derived term test for $let$-terms.
=ENDDOC
=DOC
val ‚list_mk_let· : (((TERM * TERM)list)list * TERM) -> TERM
=DESCRIBE
This generates a nested $let$-term.
=EXAMPLE
list_mk_let ([[(x,1)],[(y,2)]],x+y) = (let x = 1 in let y = 2 in x+y)
=ENDDOC
=DOC
val ‚strip_let· : TERM -> ((TERM * TERM)list)list * TERM
=DESCRIBE
This destroys a sequence of nested $let$ constructs.
=ENDDOC
\subsection{Enumerated Sets} 
=DOC
val ‚mk_enum_set· : TERM list -> TERM
=DESCRIBE
A derived term construction function for generating enumerated sets.
The argument is a list of the members of the set.
The type of a set of elements of type $ª:TYº$ is $ª:TY\ SETº$.
If the term list is empty the function will fail 
(see $mk\_§$).
The set must be of terms with the same HOL type.
=FAILURE
3012	?0 and ?1 do not have the same types
3017	An empty list argument is not allowed
=ENDDOC
=DOC
val ‚mk_§· : TYPE -> TERM;
=DESCRIBE
A derived term construction function for generating an empty (enumerated) set with elements of a given type.
=ENDDOC
It is misleading to provide $is\_§$ as a syntax function,
as it would only test for an empty enumerated set.
=DOC
val ‚dest_enum_set· : TERM -> (TERM list);
=DESCRIBE
A derived term destructor function for enumerated sets.
=FAILURE
4011	?0 is not of form: ª{t1, ...}º
=ENDDOC
=DOC
val ‚is_enum_set· : TERM -> bool;
=DESCRIBE
A derived term test for enumerated sets.
=ENDDOC
\subsection{Set Comprehensions}
=DOC
val ‚mk_set_comp· : (TERM * TERM) -> TERM
=DESCRIBE
A derived term construction function for generating set comprehensions.
=EXAMPLE
mk_set_comp (ªxº, ªx > 5º) = ª{ x | x > 5}º
=FAILURE
3015	?1 is not of type ª:BOOLº
4016	?0 is not an allowed variable structure
=ENDDOC
=DOC
val ‚dest_set_comp· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for set comprehensions.
=FAILURE
4013	?0 is not of form: ª{v | p}º
=ENDDOC
=DOC
val ‚is_set_comp· : TERM -> bool;
=DESCRIBE
A derived term test for set comprehensions.
=ENDDOC
\subsection{List-terms}
=DOC
val ‚mk_list· : TERM list -> TERM
=DESCRIBE
A derived term construction function for generating lists.
The argument is a list of the members of the list.
If the term list is empty the function will fail 
(see $mk\_empty\_list$).
The list must be of terms with the same HOL type.
=FAILURE
3017	An empty list argument is not allowed
3012	?0 and ?1 do not have the same types
=ENDDOC
=DOC
val ‚mk_empty_list· : TYPE -> TERM
=DESCRIBE
A derived term construction function for generating an empty list with elements of a given type.
=ENDDOC
=DOC
val ‚dest_list· : TERM -> (TERM list);
=DESCRIBE
A derived term destructor function for lists.
=FAILURE
4015	?0 is not of form: ª[t1,...]º
=ENDDOC
=DOC
val ‚is_list· : TERM -> bool;
=DESCRIBE
A derived term test for lists.
=ENDDOC
\subsection{(Paired) É-terms}
=DOC
val ‚mk_É· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating a $É$-terms.
ÛDefinition
mk_É (varstruct, body) = ªÉ varstruct é bodyº
Ê
$varstruct$ may be anything allowed by ICL HOL Concrete Syntax.
=FAILURE
3015	?1 is not of type ª:BOOLº
4016	?0 is not an allowed variable structure
=SEEALSO
$simple\_mk\_É$
=ENDDOC
=DOC
val ‚dest_É· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for $É$-terms.
It may destroy a paired abstraction $É$-term, being the inverse of $mk\_É$.
=FAILURE
4017	?0 is not of form: ªÉ vs é tº
=ENDDOC
=DOC
val ‚is_É· : TERM -> bool;
=DESCRIBE
A derived term test for $É$-terms, possibly formed with paired abstractions.
=SEEALSO
$simple\_is\_É$
=ENDDOC
=DOC
val ‚list_mk_É· : TERM list * TERM -> TERM;
=DESCRIBE
Repeatedly universally quantify a term.
ÛDefinition
list_mk_É ([ªaº,ªbº,ªcº,...], ªbodyº) = ªÉ a b c ... é bodyº
Ê
This uses $mk\_É$ to generate its result.
=FAILUREC
\paragraph{Failure}
This may give the errors of $mk\_É$.
=ENDDOC
=DOC
val ‚strip_É· : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a multiply universally quantified term
(perhaps with paired abstractions).
ÛDefinition
strip_É ªÉ a b c ... é bodyº = [ªaº,ªbº,ªcº,...], ªbodyº
Ê
=ENDDOC
=DOC
val ‚simple_strip_É· : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a multiply universally simply quantified term.
ÛDefinition
simple_strip_É ªÉ a b c ... é bodyº = [ªaº,ªbº,ªcº,...], ªbodyº
Ê
=ENDDOC
\subsection{(Paired) Ñ-terms}
=DOC
val ‚mk_Ñ· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating $Ñ$-terms.
ÛDefinition
mk_Ñ (varstruct, body) = ªÑ varstruct é bodyº
Ê
$varstruct$ may be anything allowed by ICL HOL Concrete Syntax.
=FAILURE
3015	?1 is not of type ª:BOOLº
4016	?0 is not an allowed variable structure
=SEEALSO
$simple\_mk\_Ñ$
=ENDDOC
=DOC
val ‚dest_Ñ· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for $Ñ$-terms.
It may destroy paired abstraction $Ñ$-terms, being the inverse of $mk\_Ñ$.
=FAILURE
4020	?0 is not of form: ªÑ vs é tº
=SEEALSO
$simple\_dest\_Ñ$
=ENDDOC
=DOC
val ‚is_Ñ· : TERM -> bool;
=DESCRIBE
A derived term test for exist, possibly formed with paired abstractions.
=SEEALSO
$simple\_is\_Ñ$
=ENDDOC
=DOC
val ‚list_mk_Ñ· : TERM list * TERM -> TERM;
=DESCRIBE
Repeatedly existentially quantify a term.
ÛDefinition
list_mk_Ñ ([ªaº,ªbº,ªcº,...], ªbodyº) = ªÑ a b c ... é bodyº
Ê
This uses $mk\_Ñ$ to generate its result.
=FAILUREC
\paragraph{Failure}
This may give the errors of $mk\_Ñ$.
=ENDDOC
=DOC
val ‚strip_Ñ· : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a repeatedly existentially quantified term, possibly formed with paired abstractions.
ÛDefinition
strip_Ñ ªÑ a b c ... é bodyº = [ªaº,ªbº,ªcº,...], ªbodyº
Ê
=ENDDOC
=DOC
val ‚simple_strip_Ñ· : TERM -> (TERM list * TERM);
=DESCRIBE
Strip a repeatedly existentially simply quantified term.
ÛDefinition
simple_strip_Ñ ªÑ a b c ... é bodyº = [ªaº,ªbº,ªcº,...], ªbodyº
Ê
=ENDDOC
\subsection{Simple and Paired Ñ$_1$-terms}
=DOC
val ‚simple_mk_Ñ%down%1· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating simply abstracted $Ñ_1$-terms.
ÛDefinition
simple_mk_Ñ%down%1 (var, body) = 
	Ñ%down%1 var é body
Ê
$var$ must be a variable.
=FAILURE
3015	?0 is not of type ª:BOOLº
3007	?0 is not a term variable
=SEEALSO
$mk\_Ñ_1$
=ENDDOC
=DOC
val ‚simple_dest_Ñ%down%1· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for simply abstracted $Ñ_1$-terms.
It may destroy only simple abstraction $Ñ_1$-terms, being the inverse of $simple\_mk\_Ñ_1$.
=FAILURE
4019	?0 is not of form: ªÑ%down%1 v é tº
=SEEALSO
$dest\_Ñ_1$
=ENDDOC
=DOC
val ‚simple_is_Ñ%down%1· : TERM -> bool;
=DESCRIBE
A derived term test for $Ñ_1$-terms, testing only for simple abstractions.
=SEEALSO
$is\_Ñ_1$
=ENDDOC
=DOC
val ‚mk_Ñ%down%1· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating $Ñ_1$-terms.
ÛDefinition
mk_Ñ%down%1 (varstruct, body) = 
	Ñ%down%1 var é body
Ê
$varstruct$ may be anything allowed by ICL HOL Concrete Syntax.
=FAILURE
3015	?1 is not of type ª:BOOLº
4016	?0 is not an allowed variable structure
=SEEALSO
$mk\_Ñ_1$
=ENDDOC
=DOC
val ‚dest_Ñ%down%1· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for $Ñ_1$-terms.
It may destroy paired abstraction $Ñ_1$-terms, being the inverse of $mk\_Ñ_1$.
=FAILURE
4021	?0 is not of form: ªÑ%down%1 vs é tº
=SEEALSO
$simple\_dest\_Ñ_1$
=ENDDOC
=DOC
val ‚is_Ñ%down%1· : TERM -> bool;
=DESCRIBE
A derived term test for $Ñ_1$-terms, testing paired abstractions.
=SEEALSO
$simple\_is\_Ñ_1$
=ENDDOC
``list'' and ``stripping'' forms of unique existence seem
unnecessary.
\subsection{á-terms}
=DOC
val ‚mk_á· : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating $á$-terms.
ÛDefinition
mk_á (varstruct, body) = á varstruct é body
Ê
$varstruct$ may be anything allowed by ICL HOL Concrete Syntax.
=FAILURE
3015	?1 is not of type ª:BOOLº
4016	?0 is not an allowed variable structure
=ENDDOC
=DOC
val ‚dest_á· : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for $á$-terms.
=FAILURE
4023	?0 is not of form: ªá vs é tº
=ENDDOC
=DOC
val ‚is_á· : TERM -> bool;
=DESCRIBE
A derived term test for  $á$-terms.
=ENDDOC
The following two functions are only present for completeness,
rather than likely use.
=DOC
val ‚list_mk_á· : TERM list * TERM -> TERM;
=DESCRIBE
Repeatedly apply $á$ to a term.
ÛDefinition
list_mk_á ([ªaº,ªbº,ªcº,...], ªbodyº) = ªá a b c ... é bodyº
Ê
=FAILUREC
\paragraph{Failure}
This may give the errors of $mk\_á$.
=ENDDOC
=DOC
val ‚strip_á· : TERM -> (TERM list * TERM);
=DESCRIBE
Strip multiple $á$'s.
ÛDefinition
strip_á ªá a b c ... é bodyº = [ªaº,ªbº,ªcº,...], ªbodyº
Ê
=ENDDOC
=SML
end(* signature of TypesAndTerms *);
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

One facet that should receive attention is the handling of unusually formed terms. For instance, $Cons\ h\ t$, where $h$ and $t$ are variables, should not be recognised as a list for the purposes of $dest\_list$.
We claim that $mk\_term$ $o$ $dest\_term$ is the identity function on terms,
and this should be put to the test.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
