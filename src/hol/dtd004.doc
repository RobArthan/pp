=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{IED 1563}  %% Mandatory field
\TPPtitle{Release 1 ICL HOL: Detailed Design for Derived Terms}  %% Mandatory field
\def\TPPheadtitle{Release 1 ICL HOL \cr Detailed Design for Derived Terms}
\TPPref{DS/FMU/IED/DTD004}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.~Blackburn & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for functions concerning derived terms that are not used in defining the type $THM$.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Project Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}
\begin{description}
\item [Issue 1.1]
First version.
Based on part of \cite{DS/FMU/IED/SML002}.
\item [Issue 1.2]
Fixed a duplicate error message, and ordered an index to be printed.
\item [Issue 1.3, 1.4]
Changes made during implementation of this documents designs.
\item [Issue 1.5]
Prettified names.
\end{description}
\subsection{Changes forecast}
\section{GENERAL}
\subsection{Scope}
This document contains a detailed design of certain derived terms of ICL HOL, and utilities to handle them, called for by the first point of section 4.2 of the Release 1 ICL HOL Product Requirement Specification \cite{DS/FMU/IED/DEF004}.
The high-level specification for the code may be considered
to be given in \cite{DS/FMU/IED/SPC001}.
The design is
implemented in \cite{DS/FMU/IED/IMP004}.
This document will not contain material required to define the type $THM$.
The interpretations of derived constructs follows that suggested by \cite{DS/FMU/IED/DEF001}, e.g. for $let \ldots in$.
\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains a detailed design of certain derived terms of ICL HOL, and utilities to handle them.
\subsubsection{Dependencies}
Loading this document is dependent on those
files indicated as preceding it in the ICL HOL release 001 makefile.
\subsubsection{Deficiencies}

\subsubsection{Possible Enhancements}
The functions $?\_select$ may be modified to use $\varepsilon$ rather than $Select$ or $select$.
=TEX
\section{DERIVED TERMS}
=DOC
signature âDerivedTermsá = sig
=DESCRIBE
This provides various utilities on derived TERMs, but which are not considered necessary to create the abstract data type $THM$.
It also contains, by inclusion, the introduction and starting utilities on types $TERM$ and $TYPE$.
=ENDDOC
We wish to have this signature as the one source of derived term functions, to allow a seamless movement of items from
this signature to $icl'TermsAndTypes$.
=SML
include icl'TypesAndTerms;
=TEX
=DOC
val âdest_fun_typeá : TYPE -> (TYPE * TYPE);
=DESCRIBE
$dest\_fun\_type$ $(mk\_fun\ xy)$ returns $xy$
=FAILURE
4034	Not a function type
=ENDDOC
=DOC
val âstrip_binderá : (TERM -> bool) -> (TERM -> (TERM * TERM)) ->
	TERM -> TERM list * TERM;
=DESCRIBE
$strip\_binder$ $sel$ $dest$ applied to 
\[bind_1( v_1 Ž bind_2( v_2 Ž \ldots Ž body)\ldots)\]
where $sel\ bind_1$, $sel\ bind_2$, $\ldots$ are all true,
will return
\[[v_1, v_2, \ldots], body\]
The function will handle paired abstraction terms.
=ENDDOC
=DOC
val âlist_mk_binderá : (TERM * TERM -> TERM) -> (TERM list * TERM) -> TERM;
=DESCRIBE 
If $maker$ $(v,b)$ makes a binding $bind\ v\ Ž\ b$,
then
$list\_mk\_binder$ $maker$ $([v_1, v_2, \ldots],body)$
returns
\[bind\ v_1 Ž bind\ v_2 Ž \ldots Ž body)\ldots)\]
=ENDDOC
=DOC
val âmk_pair_typeá : (TYPE * TYPE) -> TYPE
=DESCRIBE
$mk\_pair\_type$ $(t_1, t_2)$ returns $:t_1\ ‰\ t_2$.
=ENDDOC
=DOC
val âmk_pairá : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating pairs.
=FAILURE
4033	DESIGN ERROR : failed to form a pair
=ENDDOC
=DOC
val âdest_pairá : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for pairs.
=FAILURE
4003	Term is not a pair
=ENDDOC
=DOC
val âis_pairá : TERM -> bool;
=DESCRIBE
A derived term test for pairs.
=ENDDOC
=DOC
val âmk_absá : TERM * TERM -> TERM
=DESCRIBE
This creates an abstraction with the general syntax called for
by the ICL HOL Concrete Syntax.
=EXAMPLE
mk_abs (x , x + y) =  x Ž x + y
mk_abs ((x, y), x + y) =  (x, y) Ž x + y
mk_abs (((x1,x2), (y1,y2)), x2 + y2) =  ((x1,x2), (y1,y2)) Ž x2 + y2
=FAILURE
4001	Argument is ill-formed
=SEEALSO
$mk\_simple\_abs$
=ENDDOC
=DOC
val âdest_absá: TERM -> (TERM * TERM);
=DESCRIBE
Destroys a term with an abstraction's structure.
It can destroy paired abstractions, being an inverse of $mk\_abs$.
=FAILURE
4002	Term is not an abstraction
=FAILUREC
Further details of the errors will be given, before the above exceptions are raised.
=SEEALSO
$dest\_simple\_abs$
=ENDDOC
=DOC
val âis_absá : TERM -> bool;
=DESCRIBE
This function returns true iff. the term has a varstruct abstraction's structure.
=SEEALSO
$is\_simple\_abs$
=ENDDOC
=DOC
val âlist_mk_absá : (TERM list * TERM) -> TERM;
=DESCRIBE
óDefinition
list_mk_abs (["a","b","c",...], "body") =  a b c ... Ž body
æ
This function will be implemented using $mk\_abs$, not $mk\_simple\_abs$.
=FAILUREC
\paragraph{Failure}
May give rise to the error message from $mk\_abs$.
=SEEALSO
$list\_mk\_simple\_abs$
=ENDDOC
=DOC
val âstrip_absá : TERM -> (TERM list * TERM);
=DESCRIBE
óDefinition
strip_abs " a b c ... Ž body" = ["a","b","c",...], "body"
æ
=ENDDOC
=DOC
val âmk_binderá : string -> int -> (TYPE -> TYPE -> TERM) ->
	(TERM * TERM) -> TERM;
=DESCRIBE
óDefinition
mk_binder area msg binder (varstruct, body) = binder'( varstruct Ž body)
æ
$binder'$ is formed by applying $binder$ to the types of the 
$varstruct$ and $body$.
The $varstruct$ may be any term that follows the syntax of \cite{DS/FMU/IED/DEF001}.

=FAILUREC
\paragraph{Failure}
If the term cannot be made, then the error will be from $area$, with a message indexed by $msg$.
=ENDDOC
=DOC
val âdest_binderá : string -> int -> string -> TERM -> TERM * TERM;
=DESCRIBE
óDefinition
dest_binder area msg binder (binder( varstruct Ž body)) = (varstruct, body)
æ
The $varstruct$ may be any structure allowed by the ICL HOL Concrete Syntax.
=FAILUREC
\paragraph{Failure}
If the term cannot be destroyed, then the error will be from $area$, with a message indexed by $msg$.
=ENDDOC
=DOC
val âis_binderá : (TERM -> 'a) -> TERM -> bool;
=DESCRIBE
$is\_binder$ $dest$ $term$ returns true Iff. $dest$ can be applied to $term$ considered as possibly generated by $mk\_binder$ with paired abstractions, without raising a catchable exception.
=ENDDOC
=DOC
val âmk_€á : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating conjunctions.
=FAILURE
4022	A conjunction must be between booleans
=ENDDOC
=DOC
val âdest_€á : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for conjunctions.
=FAILURE
4032	Term is not a conjunction.
=ENDDOC
=DOC
val âis_€á : TERM -> bool;
=DESCRIBE
A derived term test for conjunctions.
=ENDDOC
=DOC
val âlist_mk_€á : TERM list -> TERM;
=DESCRIBE
óDefinition
list_mk_€ ["a","b","c",...] = "a € b € c ..."
æ
=FAILURE
3017	An empty list argument is not allowed
4025	Argument list must be of boolean terms
=ENDDOC
=DOC
val âstrip_€á : TERM -> TERM list
=DESCRIBE
Break a term into its constituent conjuncts, descending recursively only to the right
=EXAMPLE
strip_€ "(a € (b € c) € d" = ["a","b € c", "d"]
=ENDDOC
=DOC
val âmk_á : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating disjunctions.
=FAILURE
4026	A disjunction must be between booleans
=ENDDOC
=DOC
val âdest_á : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for disjunctions.
=FAILURE
4027	Term is not a disjunction.
=ENDDOC
=DOC
val âis_á : TERM -> bool;
=DESCRIBE
A derived term test for disjunctions.
=ENDDOC
=DOC
val âlist_mk_á : TERM list -> TERM;
=DESCRIBE
óDefinition
list_mk_ ["a","b","c",...] = "a  b  c ..."
æ
=FAILURE
3017	An empty list argument is not allowed
4025	Argument list must be of boolean terms
=ENDDOC
=DOC
val âstrip_á : TERM -> TERM list
=DESCRIBE
Break a term into its constituent disjuncts, descending recursively only to the right
=EXAMPLE
strip_ "(a  (b  c)  d" = ["a","b  c", "d"]
=ENDDOC
=DOC
val âmk_Œá : TERM -> TERM;
=DESCRIBE
A derived term construction function for generating negations.
=FAILURE
4028	Negations are only on boolean terms
=ENDDOC
=DOC
val âdest_Œá : TERM -> TERM;
=DESCRIBE
A derived term destructor function for negations.
=FAILURE
4029	Term is not a negation
=ENDDOC
=DOC
val âis_Œá : TERM -> bool;
=DESCRIBE
A derived term test for negations.
=ENDDOC
=DOC
val âmk_‚á : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating ‚ terms.
=FAILURE
4030	‚ must be between booleans
=ENDDOC
=DOC
val âdest_‚á : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for ‚.
N.B. this may be successfully applied to boolean equalities.
=FAILURE
4031	Term is not a ‚
=ENDDOC
=DOC
val âis_‚á : TERM -> bool;
=DESCRIBE
A derived term test for ‚.
N.B. this may be successfully applied to boolean equalities.
=ENDDOC
=DOC
val âmk_Ifá : (TERM * TERM * TERM) -> TERM;
=DESCRIBE
$mk\_If$ $(c,\ y,\ n)$ gives the term $if\ c\ then\ y\ else\ c$.
=FAILURE
4004	First argument must be a boolean term
4005	Second and third arguments must have the same type
=ENDDOC
=DOC
val âdest_Ifá : TERM -> (TERM * TERM * TERM);
=DESCRIBE
Destroys a term of the form $if\ c\ then\ y\ else\ c$.
=FAILURE
4006	Term is not a conditional
=ENDDOC
=DOC
val âis_Ifá : TERM -> bool;
=DESCRIBE
A test for conditionals.
=ENDDOC
=DOC
val âmk_letá : ((TERM * TERM)list * TERM) -> TERM
=DESCRIBE
A derived term construction function for generating local definitions.
The arguments may have any form allowed by ICL HOL Concrete Syntax.
Thus they may be variable structures formed by pairing, or single clause, non-recursive functions, whose arguments may only be variable structures formed by pairing.
=EXAMPLE
mk_let ([],x) = x
mk_let([x, 1], (x+1)) = (let x = 1 in x + 1)
mk_let([(x, 1),(y, 2)], (x+y)) = (let x = 1 and y = 2 in x + y)
mk_let([((x,y), (1,2))], (x+y)) = (let x,y = 1,2 in x + y)
mk_let([((x,y), (1,2))], (x+y)) = (let x,y = 1,2 in x + y)
mk_let([(f (x,y), (1,2))], (x+y)) = (let f =  (x,y) Ž 1,2 in x + y)
=FAILURE
4007	LHS argument not well formed
4008	LHS and RHS arguments must have same type 
=ENDDOC
=DOC
val âdest_letá : TERM -> ((TERM * TERM)list * TERM);
=DESCRIBE
A derived term destructor function for local definitions.
See $mk\_let$ for details of format.
The distinction between a local function definition,
and a variable structure bound to an abstraction is lost,
with both being destroyed to the second form.
=EXAMPLE
dest_let(mk_let([(f x, y)],bdy)) = ([(f,  x Ž y)], bdy)
dest_let(mk_let([(f,  x Ž y)],bdy)) = ([(f,  x Ž y)], bdy)
=FAILURE
4009	Term is not a local definition
=FAILUREC
$dest\_let$ $(mk\_let([],term))$ will actually fail (unless term is already a local definition),
as $(mk\_let([],term))$ is a null operation.
=ENDDOC
=DOC
val âis_letá : TERM -> bool;
=DESCRIBE
A derived term test for local definitions.
=ENDDOC
=DOC
val âlist_mk_letá : (((TERM * TERM)list)list * TERM) -> TERM
=DESCRIBE
This generates a nested $let$ construct .
=EXAMPLE
list_mk_let ([[(x,1)],[(y,2)]],x+y) = (let x = 1 in let y = 2 in x+y)
=ENDDOC
=DOC
val âstrip_letá : TERM -> ((TERM * TERM)list)list * TERM
=DESCRIBE
This destroys a sequence of nested $let$ constructs.
=ENDDOC
=DOC
val âmk_enum_setá : TERM list -> TERM
=DESCRIBE
A derived term construction function for generating enumerated set definitions.
The argument is a list of the members of the set.
The type of a set of elements of type $TY$ is $TY\ SET$.
The type of $mk\_enum\_set[]$ is $'a\ SET$.
=FAILURE
4010	Elements of list must all be of one type
=ENDDOC
=DOC
val âdest_enum_setá : TERM -> (TERM list);
=DESCRIBE
A derived term destructor function for enumerated sets.
=FAILURE
4011	Term is not an enumerated set
=ENDDOC
=DOC
val âis_enum_setá : TERM -> bool;
=DESCRIBE
A derived term test for enumerated sets.
=ENDDOC
=DOC
val âmk_setá : (TERM * TERM) -> TERM
=DESCRIBE
A derived term construction function for generating set comprehensions.
=EXAMPLE
mk_set (x, x > 5) = SetComp x Ž x > 5
=FAILURE
4012	Second argument must be boolean
=ENDDOC
=DOC
val âdest_setá : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for set comprehensions.
=FAILURE
4013	Term is not a set comprehension.
=ENDDOC
=DOC
val âis_setá : TERM -> bool;
=DESCRIBE
A derived term test for set comprehensions.
=ENDDOC
=DOC
val âmk_listá : TERM list -> TERM
=DESCRIBE
A derived term construction function for generating lists.
The argument is a list of the members of the list.
The function will generate a warning if given an empty list, when it will produce the term $[] : 'a list$,
as it cannot derive a specific type for the list from its argument.
=FAILURE
4010	Elements of list must all be of one type
=ENDDOC
=DOC
val âdest_listá : TERM -> (TERM list);
=DESCRIBE
A derived term destructor function for lists.
=FAILURE
4015	Term is not a list
=ENDDOC
=DOC
val âis_listá : TERM -> bool;
=DESCRIBE
A derived term test for lists.
=ENDDOC
=DOC
val âmk_ƒá : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating a forall.
óDefinition
mk_ƒ (varstruct, body) = ƒ varstruct Ž body
æ
$varstruct$ may be anything allowed by ICL HOL Concrete Syntax.
=FAILURE
4016	Argument must have the form: (varstruct, boolean)
=SEEALSO
$mk\_simple\_ƒ$
=ENDDOC
=DOC
val âdest_ƒá : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for forall.
It may destroy a paired abstraction forall, being the inverse of $mk\_ƒ$.
=FAILURE
4017	Term is not a forall
=ENDDOC
=DOC
val âis_ƒá : TERM -> bool;
=DESCRIBE
A derived term test for forall, possibly formed with paired abstractions.
=SEEALSO
$is\_simple\_ƒ$
=ENDDOC
=DOC
val âlist_mk_ƒá : TERM list * TERM -> TERM;
=DESCRIBE
óDefinition
list_mk_ƒ ["a","b","c",...] body = "„ a b c ... Ž body"
æ
This uses $mk\_ƒ$ to generate its result.
=FAILUREC
\paragraph{Failure}
This may give the errors of $mk\_ƒ$.
=ENDDOC
=DOC
val âstrip_ƒá : TERM -> (TERM list * TERM);
=DESCRIBE
óDefinition
strip_ƒ "„ a b c ... Ž body = ["a","b","c",...], body
æ
This uses $dest\_ƒ$ to generate its result.
=ENDDOC
=DOC
val âmk_„á : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating exists.
óDefinition
mk_„ (varstruct, body) = „ varstruct Ž body
æ
$varstruct$ may be anything allowed by ICL HOL Concrete Syntax.
=FAILURE
4016	Argument must have the form: (varstruct, boolean)
=SEEALSO
$mk\_simple\_„$
=ENDDOC
=DOC
val âdest_„á : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for exists.
It may destroy paired abstraction exists, being the inverse of $mk\_„$.
=FAILURE
4020	Term is not an exists
=SEEALSO
$dest\_simple\_„$
=ENDDOC
=DOC
val âis_„á : TERM -> bool;
=DESCRIBE
A derived term test for exist, possibly formed with paired abstractions.
=SEEALSO
$is\_simple\_„$
=ENDDOC
=DOC
val âlist_mk_„á : TERM list * TERM -> TERM;
=DESCRIBE
óDefinition
list_mk_„ ["a","b","c",...] body = "„ a b c ... Ž body"
æ
This uses $mk\_„$ to generate its result.
=FAILUREC
\paragraph{Failure}
This may give the errors of $mk\_„$.
=ENDDOC
=DOC
val âstrip_„á : TERM -> (TERM list * TERM);
=DESCRIBE
óDefinition
strip_„ "„ a b c ... Ž body = ["a","b","c",...], body
æ
This uses $dest\_„$ to generate its result.
=ENDDOC
=DOC
val âmk_selectá : (TERM * TERM) -> TERM;
=DESCRIBE
A derived term construction function for generating selects.
óDefinition
mk_select (varstruct, body) = Select varstruct Ž body
æ
$varstruct$ may be anything allowed by ICL HOL Concrete Syntax.
=FAILURE
4016	Argument must have the form: (varstruct, boolean)
=ENDDOC
=DOC
val âdest_selectá : TERM -> (TERM * TERM);
=DESCRIBE
A derived term destructor function for selects.
=FAILURE
4023	Term is not a select
=ENDDOC
=DOC
val âis_selectá : TERM -> bool;
=DESCRIBE
A derived term test for select.
=ENDDOC
=DOC
val âlist_mk_selectá : TERM list * TERM -> TERM;
=DESCRIBE
óDefinition
list_mk_select ["a","b","c",...], "body" = "Select a b c ... Ž body"
æ
=FAILUREC
\paragraph{Failure}
This may give the errors of $mk\_select$.
=ENDDOC
=DOC
val âstrip_selectá : TERM -> (TERM list * TERM);
=DESCRIBE
óDefinition
strip_select "Select a b c ... Ž body" = ["a","b","c",...], "body"
æ
=ENDDOC
=DOC
datatype âDERIV_TERMá = âDVará of string * TYPE |
	âDConstá of string * TYPE |
	âDCombá of TERM * TERM |
	âDAbsá of TERM * TERM |
	âDEqá of TERM * TERM |
	âDŠá of TERM * TERM |
	âDŒá of TERM |
	âDPairá of TERM * TERM |
	âD€á of TERM * TERM |
	âDá of TERM * TERM |
	âD‚á of TERM * TERM |
	âDLetá of ((TERM * TERM)list * TERM) |
	âDEnumSetá of (TERM list * TYPE) |
	âDSetá of TERM * TERM |
	âDListá of (TERM list * TYPE) |
	âDƒá of TERM * TERM |
	âD„á of TERM * TERM |
	âDSelectá of TERM * TERM |
	âDIfá of (TERM * TERM * TERM);
=DESCRIBE
This type is that of a term destroyed using the appropriate derived destructor functions (e.g. $dest\_eq$) as well as the primitive ones.
It is related to $TERM$ by $mk\_DERIV\_TERM$ and $dest\_DERIV\_TERM$
=SEEALSO
$DEST\_TERM$
=ENDDOC
=DOC
val âmk_DERIV_TERMá : TERM -> DERIV_TERM
=DESCRIBE
This function returns the ``best'' interpretation of a term in the form of an object of type $DERIV\_TERM$.
E.g. it will return $DEq\ 1\ 2$ rather than $DComb (\$=\ 1) 2$.
It will also use the paired abstraction forms of functions in preference to the simple forms, e.g., it uses $dest\_abs$ not $dest\_simple\_abs$.
=SEEALSO
$dest\_TERM\_DERIV$
=ENDDOC
=DOC
val âdest_DERIV_TERMá : DERIV_TERM -> TERM
=DESCRIBE
Create a term from a derived term.
It is an inverse to $dest\_DERIV\_TERM$, and therefore understands how to handle paired abstractions.

This may not give a well-formed term in the context of certain theories.
=FAILUREC
\paragraph{Failure}
This function will fail with the same messages as the appropriate term construction functions.
=SEEALSO
$mk\_TERM\_DERIV$
=ENDDOC
=SML
end(* signature of DerivedTerms *);
=TEX
\section{TEST POLICY}
The functions in this document should be tested as described in
\cite{DS/FMU/IED/PLN008}.

One facet that should receive attention is the handling of unusually formed terms. For instance, $Cons\ h\ t$, where $h$ and $t$ are variables, should not be recognised as a list for the purposes of $dest\_list$.
The claim that $mk\_$ and $dest\_DERIV\_TERM$ are always inverses
should also be put to the test.
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
