=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Proof Contexts}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP076}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{K.Blackburn & WIN01}
\TPPauthorisation{R.D.Arthan & FST Team Leader}
\TPPabstract{This document contains the implementation
of the proof contexts supplied for theories up to theory ``hol''.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History} 
\begin{description}
\item [Issues 1.1] 
First version.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
Various proof contexts are called for in Appendix A
of \cite{DS/FMU/IED/HLD011},
and are given a detailed design in \cite{DS/FMU/IED/DTD076}.
This document provides a detailed design for these contexts.
\subsection{Introduction}
\subsubsection{Purpose and Background}
The mechanism of proof contexts is discussed in \cite{DS/FMU/IED/HLD009}, and is implemented in \cite{DS/FMU/IED/DTD051}.
There are however many proof contexts provided within 
the HOL PDS, implemented in various subsystems.
The sum of these should provide a coherent set,
with some proof contexts being appropriate
to be pushed onto the proof context stack in their
own right, and others allowing detail in creating
proof contexts based in part on existing context material.

This document implements these proof contexts.
\subsubsection{Dependencies}
This document takes its signature from \cite{DS/FMU/IED/DTD076}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
None known.

\section{PREAMBLE}
=SML
structure €SuppliedProofContexts› : SuppliedProofContexts = struct
=TEX
=SML
val _ = open_theory "basic_hol";
val _ = push_merge_pcs ["paired","prove_∂"];
=TEX
We will wish to delete any proof context created so far during the build process, other than initial, so we make a note of their names now:
=SML
val €pcs_to_delete› = (map fst (show_pcs())) less "initial";
=TEX
\section{TOOLS}
=SML
open Resolution;
fun €supplied_prove_tac› (thms: THM list) : TACTIC = (
	DROP_ASMS_T (MAP_EVERY (strip_asm_tac o 
	(fn thm => rewrite_rule thms thm
		handle (Fail _) => thm))) THEN
	(TRY_T (rewrite_tac thms)) THEN
	REPEAT strip_tac THEN_TRY
	(basic_res_tac2 3 [] ORELSE_T basic_res_tac3 3 [])
);
=TEX
=SML
fun €supplied_prove_conv› (thms: THM list) : CONV = (fn tm =>
(§_t_intro (
tac_proof(([],tm),
	TRY_T (rewrite_tac thms)  THEN 
	REPEAT strip_tac THEN_TRY
	(basic_res_tac2 3 [] ORELSE_T basic_res_tac3 3 []))
)
handle complaint =>
divert complaint "tac_proof" "supplied_prove_conv" 76001 [fn () => string_of_term tm]));
=TEX
Convert a list of theorems to equation contexts appropriate
to this document.
=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
	flat(map (cthm_eqn_cxt initial_rw_canon) thms)
);
=TEX
\section{THE PROOF CONTEXTS}
\subsection{Proof Contexts Built In Theory ``basic$\_$hol''}
=SML
val _ = pop_pc();
val _ = open_theory "basic_hol";
val _ = push_merge_pcs ["paired"];
=TEX
=SML
val _ = new_pc "simple_abstractions";
val _ = set_rw_eqn_cxt [(¨≥ xÆ,simple_≥_in_conv)] "simple_abstractions";
val _ = set_st_eqn_cxt [(¨≥ xÆ,simple_≥_in_conv)] "simple_abstractions";
val _ = set_sg_eqn_cxt [(¨≥ xÆ,simple_≥_in_conv)] "simple_abstractions";
val _ = set_rw_canons [simple_µ_rewrite_canon, 
	simple_≥_rewrite_canon] "simple_abstractions";
val _ = set_pr_tac supplied_prove_tac "simple_abstractions";
val _ = set_pr_conv supplied_prove_conv "simple_abstractions";
val _ = set_cs_∂_convs [basic_prove_∂_conv] "simple_abstractions";
val _ = commit_pc "simple_abstractions";
=TEX
=SML
val _ = new_pc "paired_abstractions";
val _ = set_rw_eqn_cxt [(¨Uncurry x yÆ, ¬_conv)] "paired_abstractions";
val _ = set_st_eqn_cxt [(¨≥ xÆ, ≥_in_conv),
	(¨$∂â1(Uncurry f)Æ, ∂â1_conv),
	(¨$µ (Uncurry f)Æ, µ_uncurry_conv),
	(¨$∂ (Uncurry f)Æ, ∂_uncurry_conv)] "paired_abstractions";
val _ = set_sg_eqn_cxt [(¨≥ xÆ, ≥_in_conv),
	(¨$µ (Uncurry f)Æ, µ_uncurry_conv)] "paired_abstractions";
val _ = set_rw_canons [µ_rewrite_canon, 
	≥_rewrite_canon] "paired_abstractions";
val _ = set_pr_tac supplied_prove_tac "paired_abstractions";
val _ = set_pr_conv supplied_prove_conv "paired_abstractions";
val _ = set_cs_∂_convs [basic_prove_∂_conv] "paired_abstractions";
val _ = commit_pc "paired_abstractions";
=TEX
=SML
val _ = new_pc "propositions";
val _ = set_rw_eqn_cxt ((thms_to_eqn_cxt [
		eq_rewrite_thm,
		§_rewrite_thm,
		≥_rewrite_thm,
		±_rewrite_thm,
		≤_rewrite_thm,
		¥_rewrite_thm,
		if_rewrite_thm,
		µ_rewrite_thm,
		∂_rewrite_thm,
		¬_rewrite_thm,
		eta_axiom]) @
	[(¨(Ã x ∑ y) zÆ, simple_¬_conv)]) "propositions";
local
	val aux1 = tac_proof(([],
		¨µ x:'a ∑ ((x = x) § T) ± (≥(x = x) § F)Æ),
		supplied_prove_tac []);
	val aux2 = tac_proof(([],
		¨µ a t1 t2:BOOL∑ 
		(if a then t1 else t2) § (a ¥ t1) ± (≥ a ¥ t2)Æ),
		supplied_prove_tac []);
	val aux3 = tac_proof(([],
		¨µa b∑(a ≤ ≥b) § (b ¥ a)Æ),
		supplied_prove_tac []);
	val aux4 = tac_proof(([],
		¨µ a b∑ ≥ a ≤ b § a ¥ bÆ),
		supplied_prove_tac []);
	val aux5 = tac_proof(([],
		¨µ a b∑ a ≤ b § ≥ a ¥ bÆ),
		supplied_prove_tac []);

in
val _ = set_st_eqn_cxt ((thms_to_eqn_cxt [¥_thm, §_thm,
		aux1, aux2]) @
	[(¨∂â1 x ∑ pÆ, simple_∂â1_conv)]) "propositions";
val _ = set_sg_eqn_cxt (thms_to_eqn_cxt[§_thm,
		aux1,aux2,aux3,aux4,aux5]) "propositions";
end;
val _ = set_rw_canons [±_rewrite_canon, f_rewrite_canon] "propositions";
val _ = set_pr_tac (fn _ => taut_tac) "propositions";
val _ = set_pr_conv (fn _ => taut_conv) "propositions";
val _ = set_cs_∂_convs [basic_prove_∂_conv] "propositions";
val _ = commit_pc "propositions";
=TEX
=SML
val _ = new_pc "fun_ext";
val _ = set_rw_eqn_cxt (thms_to_eqn_cxt[ext_thm]) "fun_ext";
val _ = set_st_eqn_cxt (thms_to_eqn_cxt[ext_thm]) "fun_ext";
val _ = set_sg_eqn_cxt (thms_to_eqn_cxt[ext_thm]) "fun_ext";
val _ = set_pr_tac (fn _ => taut_tac) "fun_ext";
val _ = set_pr_conv (fn _ => taut_conv) "fun_ext";
val _ = set_cs_∂_convs [basic_prove_∂_conv] "fun_ext";
val _ = commit_pc "fun_ext";
=TEX
=SML
val _ = new_pc "predicates";
val _ = merge_pcs ["propositions", "paired_abstractions"] "predicates";
val _ = commit_pc "predicates";
=TEX
=SML
val _ = new_pc "predicates1";
val _ = merge_pcs ["propositions", "fun_ext", "paired_abstractions"] "predicates1";
val _ = commit_pc "predicates1";
=TEX
=SML
val _ = new_pc "pair";
local
	val aux1 = tac_proof(([],
¨µ x y a b p fu fc
    ∑ Fst (x, y) = x
      ± Snd (x, y) = y
      ± ((a, b) = (x, y) § a = x ± b = y)
      ± (Fst p, Snd p) = p
      ± Curry fc x y = fc (x, y)
      ± Uncurry fu (x, y) = fu x y
      ± Uncurry fu p = fu (Fst p) (Snd p)Æ),
		supplied_prove_tac [pair_clauses]);
	val aux2 = tac_proof(([],
¨µ a b x y ∑ ((a, b) = (x, y) § a = x ± b = y)Æ),
		supplied_prove_tac [pair_clauses]);
	val aux3 = tac_proof(([],
¨µ x y p ∑
	Fst (x, y) = x ±
	Snd (x, y) = y ±
	(Fst p, Snd p) = pÆ),
		supplied_prove_tac [pair_clauses]);
in
val _ = set_rw_eqn_cxt (thms_to_eqn_cxt[aux1]) "pair";
val _ = set_st_eqn_cxt (thms_to_eqn_cxt[aux2]) "pair";
val _ = set_sg_eqn_cxt (thms_to_eqn_cxt[aux2]) "pair";
val _ = set_∂_vs_thms [(",",([¨FstÆ,¨SndÆ],aux3))] "pair";
end;
val _ = set_pr_tac supplied_prove_tac "pair";
val _ = set_pr_conv supplied_prove_conv "pair";
val _ = set_cs_∂_convs [basic_prove_∂_conv] "pair";
val _ = commit_pc "pair";
=TEX
=SML
val _ = new_pc "pair1";
local
	val aux1 = tac_proof(([],
¨µ a b p
    ∑ ((a, b) = p § a = Fst p ± b = Snd p)
      ± (p = (a, b) § Fst p = a ± Snd p = b)Æ),
		supplied_prove_tac [pair_clauses]);
in
val _ = set_rw_eqn_cxt (thms_to_eqn_cxt[aux1]) "pair1";
val _ = set_st_eqn_cxt (thms_to_eqn_cxt[aux1]) "pair1";
val _ = set_sg_eqn_cxt (thms_to_eqn_cxt[aux1]) "pair1";
end;
val _ = set_pr_tac supplied_prove_tac "pair1";
val _ = set_pr_conv supplied_prove_conv "pair1";
val _ = set_cs_∂_convs [basic_prove_∂_conv] "pair1";
val _ = commit_pc "pair1";
=TEX
=SML
val _ = new_pc "Ó";
val _ = set_rw_eqn_cxt (thms_to_eqn_cxt[æ_def, greater_def, 
	plus_clauses, times_clauses,
	º_clauses, less_clauses, minus_clauses]) "Ó";
val _ = set_st_eqn_cxt (thms_to_eqn_cxt[æ_def, greater_def, 
	plus_clauses, times_clauses,
	º_clauses, less_clauses, minus_clauses]) "Ó";
val _ = set_sg_eqn_cxt (thms_to_eqn_cxt[æ_def, greater_def, 
	plus_clauses, times_clauses,
	º_clauses, less_clauses, minus_clauses]) "Ó";
val _ = set_∂_cd_thms [prim_rec_thm] "Ó";
val _ = set_pr_tac supplied_prove_tac "Ó";
val _ = set_pr_conv supplied_prove_conv "Ó";
val _ = set_cs_∂_convs [basic_prove_∂_conv] "Ó";
val _ = commit_pc "Ó";
=TEX
=SML
val _ = new_pc "Ó_lit";
val _ = set_rw_eqn_cxt [
	(¨x + yÆ, plus_conv),
	(¨x * yÆ, times_conv),
	(¨x - yÆ, minus_conv),
	(¨x Div yÆ, div_conv),
	(¨x Mod yÆ, mod_conv),
	(¨x º yÆ, º_conv),
	(¨x < yÆ, less_conv),
	(¨x > yÆ, greater_conv),
	(¨x æ yÆ, æ_conv),
	(¨x = yÆ, Ó_eq_conv)] "Ó_lit";
val _ = set_st_eqn_cxt [
	(¨x º yÆ, º_conv),
	(¨x < yÆ, less_conv),
	(¨x > yÆ, greater_conv),
	(¨x æ yÆ, æ_conv),
	(¨x = yÆ, Ó_eq_conv)] "Ó_lit";
val _ = set_sg_eqn_cxt [
	(¨x º yÆ, º_conv),
	(¨x < yÆ, less_conv),
	(¨x > yÆ, greater_conv),
	(¨x æ yÆ, æ_conv),
	(¨x = yÆ, Ó_eq_conv)] "Ó_lit";
val _ = set_pr_tac supplied_prove_tac "Ó_lit";
val _ = set_pr_conv supplied_prove_conv "Ó_lit";
val _ = set_cs_∂_convs [basic_prove_∂_conv] "Ó_lit";
val _ = commit_pc "Ó_lit";
=TEX
=SML
val _ = new_pc "list";
val _ = set_rw_eqn_cxt (thms_to_eqn_cxt[list_clauses]) "list";
local
	val aux = tac_proof(([],¨µ x1 x2 list1 list2
    ∑ ≥ Cons x1 list1 = []
      ± ≥ [] = Cons x1 list1
      ± (Cons x1 list1 = Cons x2 list2 § x1 = x2 ± list1 = list2)Æ),
		supplied_prove_tac[list_clauses]);
in
val _ = set_st_eqn_cxt (thms_to_eqn_cxt[aux]) "list";
val _ = set_sg_eqn_cxt (thms_to_eqn_cxt[aux]) "list";
end;
val _ = set_∂_cd_thms [list_prim_rec_thm] "list";
val _ = set_pr_tac supplied_prove_tac "list";
val _ = set_pr_conv supplied_prove_conv "list";
val _ = set_cs_∂_convs [basic_prove_∂_conv] "list";
val _ = commit_pc "list";
=TEX
=SML
val _ = new_pc "char";
val _ = set_rw_eqn_cxt [(¨x = yÆ, char_eq_conv),
	(¨x = yÆ, string_eq_conv)] "char";
val _ = set_st_eqn_cxt [(¨x = yÆ, char_eq_conv),
	(¨x = yÆ, string_eq_conv)] "char";
val _ = set_sg_eqn_cxt [(¨x = yÆ, char_eq_conv),
	(¨x = yÆ, string_eq_conv)] "char";
val _ = set_pr_tac supplied_prove_tac "char";
val _ = set_pr_conv supplied_prove_conv "char";
val _ = set_cs_∂_convs [basic_prove_∂_conv] "char";
val _ = commit_pc "char";
=TEX
=SML
val _ = new_pc "basic_hol";
val _ = merge_pcs ["predicates","pair","Ó","list","char"] "basic_hol";
val _ = commit_pc "basic_hol";
=TEX
=SML
val _ = new_pc "basic_hol1";
val _ = merge_pcs ["predicates1","pair","pair1","Ó","Ó_lit",
	"list","char"] "basic_hol1";
val _ = commit_pc "basic_hol1";
=TEX
\subsection{Proof Contexts Built In Theory ``combin''}
=SML
val _ = pop_pc();
val _ = open_theory "combin";
val _ = push_merge_pcs ["paired"];
=TEX
=SML
val _ = new_pc "combin";
val _ = set_rw_eqn_cxt (thms_to_eqn_cxt[comb_i_def, comb_k_def, o_def, o_i_thm]) "combin";
val _ = set_pr_tac supplied_prove_tac "combin";
val _ = set_pr_conv supplied_prove_conv "combin";
val _ = set_cs_∂_convs [basic_prove_∂_conv] "combin";
val _ = commit_pc "combin";
=TEX
\subsection{Proof Contexts Built In Theory ``one''}
=SML
val _ = pop_pc();
val _ = open_theory "one";
val _ = push_merge_pcs ["paired"];
=TEX
=SML
val _ = new_pc "one";
val _ = set_rw_eqn_cxt (thms_to_eqn_cxt[one_def, one_fns_thm]) "one";
local
	val aux1 = tac_proof(([],¨µ x y : ONE ∑ (x = y) § TÆ),
		supplied_prove_tac[one_def]);
	val aux2 = tac_proof(([],¨µ x y : 'a ≠ ONE ∑ (x = y) § TÆ),
		supplied_prove_tac[one_fns_thm]);
	val pos = (thms_to_eqn_cxt[aux1,aux2]);
	val neg = map (mk_≥ ** RAND_C) pos;
in
val _ = set_st_eqn_cxt (pos @ neg) "one";
val _ = set_sg_eqn_cxt (pos @ neg) "one";
end;
val _ = set_pr_tac supplied_prove_tac "one";
val _ = set_pr_conv supplied_prove_conv "one";
val _ = set_cs_∂_convs [basic_prove_∂_conv] "one";
val _ = commit_pc "one";
=TEX
\subsection{Proof Contexts Built In Theory ``sets''}
=SML
val _ = pop_pc();
val _ = open_theory "sets";
val _ = push_merge_pcs ["build_sets_ext"];
=TEX
=SML
val _ = new_pc "sets_alg";
local
val aux1 = tac_proof(([],¨
	µ x a b
	∑ ≥ x ç {}
        ± x ç Universe
        ± (a ç {b} § a = b)Æ),
	supplied_prove_tac[]);
val new_rw =
	(¨x ç $SetComp yÆ, ç_comp_conv) ::
	(¨x ç $Insert y zÆ, ç_enum_set_conv) ::
	(flat(map (cthm_eqn_cxt initial_rw_canon)
	[complement_clauses, ¿_clauses, °_clauses, set_dif_clauses,
	Ä_clauses, †_clauses, ﬁ_clauses, •_clauses, _clauses,aux1]));
in
val _ = set_rw_eqn_cxt new_rw "sets_alg";
end;
local
val pos_bits = 
	[(¨x ç $SetComp yÆ, ç_comp_conv),
	(¨x ç $Insert y zÆ, ç_enum_set_conv)] @
	(thms_to_eqn_cxt [ç_in_clauses,Ä_clauses, †_clauses]);
val neg_strips = map (mk_≥ ** RAND_C) pos_bits;
val new_strips = pos_bits @ neg_strips;
in
val _ = set_st_eqn_cxt new_strips "sets_alg";
val _ = set_sg_eqn_cxt new_strips "sets_alg";
end;
val _ = set_pr_tac supplied_prove_tac "sets_alg";
val _ = set_pr_conv supplied_prove_conv "sets_alg";
val _ = set_cs_∂_convs [basic_prove_∂_conv] "sets_alg";
val _ = commit_pc "sets_alg";
=TEX
=SML
val _ = new_pc "sets_ext";
val _ = set_rw_eqn_cxt ((¨x ç $SetComp yÆ, ç_comp_conv) ::
	(¨x ç $Insert y zÆ, ç_enum_set_conv) ::
	(thms_to_eqn_cxt [ç_in_clauses,sets_ext_clauses])) "sets_ext";
local
val pos_bits = 
	[(¨x ç $SetComp yÆ, ç_comp_conv),
	(¨x ç $Insert y zÆ, ç_enum_set_conv)] @
	(thms_to_eqn_cxt [ç_in_clauses,sets_ext_clauses]);
val neg_strips = map (mk_≥ ** RAND_C) pos_bits;
val new_strips = pos_bits @ neg_strips;
in
val _ = set_st_eqn_cxt new_strips "sets_ext";
val _ = set_sg_eqn_cxt new_strips "sets_ext";
end;
val _ = set_pr_tac supplied_prove_tac "sets_ext";
val _ = set_pr_conv supplied_prove_conv "sets_ext";
val _ = set_cs_∂_convs [basic_prove_∂_conv] "sets_ext";
val _ = commit_pc "sets_ext";
=TEX
\subsection{Proof Contexts Built In Theory ``sum''}
=SML
val _ = pop_pc();
val _ = open_theory "sum";
val _ = push_merge_pcs ["paired","sum_prove_∂"];
=TEX
=SML
val _ = new_pc "sum";
local
val aux1 = tac_proof(([],¨µ x1 x2 y1 y2 z
    ∑ (InL x1 = InL x2 § x1 = x2)
      ± (InR y1 = InR y2 § y1 = y2)
      ± ≥ InL x1 = InR y1
      ± ≥ InR y1 = InL x1
      ± OutL (InL x1) = x1
      ± OutR (InR y1) = y1Æ),
	supplied_prove_tac[sum_clauses]);
val aux2 = tac_proof(([],¨µ x1 x2 y1 y2 z
    ∑ (InL x1 = InL x2 § x1 = x2)
      ± (InR y1 = InR y2 § y1 = y2)
      ± ≥ InL x1 = InR y1
      ± ≥ InR y1 = InL x1Æ),
	supplied_prove_tac[sum_clauses]);
in
val _ = set_rw_eqn_cxt (thms_to_eqn_cxt[aux1]) "sum";
val _ = set_st_eqn_cxt (thms_to_eqn_cxt[aux2]) "sum";
val _ = set_sg_eqn_cxt (thms_to_eqn_cxt[aux2]) "sum";
end;
val _ = set_∂_cd_thms [(rewrite_rule[ext_thm, o_def] sum_fns_thm)]
	"sum";
val _ = set_pr_tac supplied_prove_tac "sum";
val _ = set_pr_conv supplied_prove_conv "sum";
val _ = set_cs_∂_convs [basic_prove_∂_conv] "sum";
val _ = commit_pc "sum";
=TEX
\subsection{Proof Contexts Built In Theory ``hol''}
=SML
val _ = pop_pc();
val _ = open_theory "hol";
val _ = push_merge_pcs ["paired","prove_∂"];
=TEX
=SML
val _ = new_pc "hol";
val _ = merge_pcs ["basic_hol","sum","combin","sets_alg"] "hol";
val _ = commit_pc "hol";
=TEX
=SML
val _ = new_pc "hol1";
val _ = merge_pcs ["basic_hol1","one","sum","combin","sets_ext"] "hol1";
val _ = commit_pc "hol1";

=TEX
\section{EPILOGUE}
We now wish to delete all the ``build'' proof contexts,
leaving only ``initial'', and the proof contexts supplied in this
document.
=SML
val _ = repeat pop_pc;
val _ = set_pc "initial";
val _ = map delete_pc pcs_to_delete;
=TEX
Restore the previous theory, leave the proof context and current theory being "hol";
=SML
val _ = open_theory "hol";
val _ = push_pc "basic_hol";
=TEX
=SML
end; (* of structure SuppliedProofContexts *)
open SuppliedProofContexts;
=TEX
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}

