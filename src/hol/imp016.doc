% imp016.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Type Inference}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP016}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Approved}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This contains the Standard ML implementation of the
type inference mechanism.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}

\item[Issue 2.1]
This is an approved version of issue 1.16.

\item[Issue 2.2 27 August 1991]
Corrected the commented-out declaration of the
flag $ti\_verbose$.

\end{description}
\subsection{Changes forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document contains the Standard ML code for implementing
the type inference mechanism for the ICL product HOL.
It corresponds to the
detailed design of type inference
as specified in \cite{DS/FMU/IED/DTD016}.

\subsection{Introduction}

The type inference mechanism is a part of the ICL product
HOL. This document contains the Standard ML code which
implements the mechanism. Description of the functionality
is only provided where it is considered that the
code itself is complex. A description of the functional
aspects of the mechanism can be found in
\cite{DS/FMU/IED/DTD016}.

The type inference mechanism should be built as part of the
release for ICL product HOL. The procedures for building
HOL are described in \cite{DS/FMU/IED/DTD021}.

The interfaces which are externally available are described
in the signature for type inference \cite{DS/FMU/IED/DTD016}
but it is not expected or intended that the end user
should make use of these interfaces. The structure
is therefore left unopened.

\subsubsection{Background and Purpose}

The implementation of the type checker has been done
in response to its detailed design \cite{DS/FMU/IED/DTD016}
and its purpose is to infer all the types in any given
HOL term.

\subsubsection{Dependencies}

The Standard ML code in this document depends on the literate script
contained in \cite{DS/FMU/IED/DTD016} for the signature of
$TypeInference$,
and on~\cite{DS/FMU/IED/DTD015} for fixity information.

\subsubsection{Possible Enhancements}

None are envisaged at present.

\subsubsection{Deficiencies}

At present, there are no known deficiencies in this document.

\section{THE STANDARD ML CODE FOR TYPE INFERENCE}

This code is largely believed to be self-documenting. Where
this is not considered to be the case, additional description
has been provided.
The code is organised in to sections of the document
which correspond to sections of the same name in
the parent document \cite{DS/FMU/IED/DTD016}. A overview of
the features of the code in each section can be found in
\cite{DS/FMU/IED/DTD016}.
=SML
structure âTypeInferenceá : TypeInference = struct
=TEX

=SML
open Parser Unification;

val âti_verboseá = ref false;

val _ =
new_flag {name = "ti_verbose", control=ti_verbose, check=fun_true, default = fun_true};

type âENVá = string -> (EXTYPE*bool);
type âINF_TUPLEá = EXTYPE TM * EXTYPE * SUBS;
=TEX

\subsection{General Utilities}

=SML
fun âtype_of_constá (s : string) : TYPE OPT = (
	case get_const_info s of
		Value (t,_) => Value t
		|       Nil => Nil
);
=TEX

=SML
fun âeval_type_consá (s : string, tyl : TYPE list) : TYPE = (
	if is_type_abbrev s
	then
		expand_type_abbrev (s, tyl)
	else
		mk_ctype (s, tyl)
);
=TEX

=SML
fun âty_to_typeá ((TyAtom s) : TY) : TYPE  = (
	if (hd o explode) s = "'"
	then
		if is_type_abbrev s
		then
			expand_type_abbrev (s, [])
		else
			mk_vartype s
	else
		case get_type_info s of
			Value (0, _) => eval_type_cons (s, [])
		|	Nil => fail "HOL type inferrer" 16060 [fn() => s]
		|	Value (x, _) => fail "HOL type inferrer" 16030
			[fn() => s,
			 fn() => string_of_int x,
			 fn() => if x = 1 then "" else "s",
			 fn() => "0",
			 fn() => "s"]
)
  |  ty_to_type (TyCompound (tyl, s, _)) = (
	case get_type_info s of
	   Value (x, _) =>
		let
			val ltyl = length tyl
		in
		   if x = ltyl
		   then
			eval_type_cons (s, map ty_to_type tyl)
		   else
			fail "HOL type inferrer" 16030
			[fn() => s,
			 fn() => string_of_int x,
			 fn() => if x = 1 then "" else "s",
			 fn() => string_of_int ltyl,
			 fn() => if ltyl = 1 then "" else "s"
			]
		end

	|  Nil => fail "HOL type inferrer" 16060 [fn() => s]
)
  |  ty_to_type (TyAq ty) = ty;
=TEX

This determines whether or not a term is of the type
which can be a variable (i.e., a simple variable, a tuple etc.).
=SML
fun âis_varstructá (tm : 'a TM) : bool = (
	case tm of
		Id x =>
			(case type_of_const x of
			Value _ => false
			| Nil	=> true)
	|	TmTyped (t, _) => is_varstruct t
	|	App (Id ",", a, _) => is_varstruct a
	|	App (f, a, _) => is_varstruct f andalso is_varstruct a
	|	Other => false
);
=TEX

=SML
fun âsub_tyá (env : ENV) (phi : SUBS) : ENV = (
	fn s => 
		let val (ty, flag) = env s;
		in	((sub_type phi) ty, flag)
		end
);
=TEX

\subsection{Environment Management}

The variable reference $ti\_context\_info$ is used to store the context.

=SML
val âti_context_infoá : (string*TYPE) list ref = ref [];

fun âti_context_mapá ((tm::tml) : TERM list) :
		(string*TYPE) list = (
		(map dest_var (frees tm))@(ti_context_map tml)
	)
	  | ti_context_map _ = [];

fun âset_ti_contextá (tml : TERM list) : unit = (
let	val allterms = list_term_union (map frees tml);
	val di = all_different (map (fst o dest_var) allterms);
in
	if di
	then
		ti_context_info := ti_context_map tml
	else
		fail "HOL type inferrer" 16040 []
end);

fun âget_ti_contextá (() : unit) : TERM list =
	(map mk_var (!ti_context_info));

=TEX
=SML
fun âfv_setá ((Binder (s, a, b)) : 'a TM) : string list  = fv_set b diff fv_set a
  | fv_set (Let (tl, a)) = (
	let	val (lx, ly) = split tl;
		val aux = list_cup o map fv_set;
	in
		((fv_set a diff aux lx) cup aux ly)
	end)
  | fv_set (Cond (c, a, b)) = fv_set c cup fv_set a cup fv_set b
  | fv_set (App (f, a, _)) = fv_set f cup fv_set a
  | fv_set (TmTyped (a,_)) = fv_set a
  | fv_set (TmAq tm) = nil
  | fv_set (SetDisplay tl) = list_cup (map fv_set tl)
  | fv_set (SetComprehension (a,b)) = fv_set a cup fv_set b
  | fv_set (ListDisplay tl) =  list_cup (map fv_set tl)
  | fv_set (Id s) = (
	case type_of_const s of
		Value x => []
		|   Nil => [s]
	)
  | fv_set (CharLit c) = nil
  | fv_set (StringLit s) = nil
  | fv_set (NumLit i) = nil;
=TEX

=SML
fun âinit_envá (tm : 'a TM) : ENV = (
	let 	val freevars = fv_set tm;
		val freemap = new_name freevars;
	in
	   (fn s =>
		case type_of_const s of
			Value t => (replaced t, false)
			  | Nil =>
				(
				(type_to_extype (lassoc3
				  (!ti_context_info) s), true)
				handle (Fail msg) =>
				(ExVartype(Unknown(lassoc3 freemap s)), false))
	handle (Fail msg) =>
		error "init_env" 16101 [fn() => s]
	    )
	end);
=TEX
=SML
fun âgrow_envá (env : ENV) (tm : 'a TM) : ENV = (
	let 	val freevars = fv_set tm;
		val freemap = new_name freevars;
	in
	   (fn s =>
		case type_of_const s of
			Value t => (replaced t, false)
			  | Nil =>
				if s mem freevars
				then
					(ExVartype(Unknown(lassoc3 freemap s)), false)
				else
					env s
	handle (Fail msg) =>
		error "grow_env" 16101 [fn() => s]
	    )
	end);
=TEX

\subsection{Identification of Free Variables}

=SML
fun âfv_in_extyá (phi : SUBS) (ty : EXTYPE) : string list * int list = (
	case sub_type phi ty of
		ExVartype (Known x) => ([x],nil)
	|	ExVartype (Unknown tvn) => (nil, [tvn])
	|	ExType (_, tyl) => (
		let	fun aux (x::xs) = (
			  let	val (xk, xu) = fv_in_exty phi x;
		 	 	val (ak, au) = aux xs
			  in
				(xk @ ak, xu @ au)
			  end)
			  | aux nil = (nil,nil);

		in
			aux tyl
		end)
);
=TEX

=SML
fun âfv_in_extmá (phi : SUBS) ((Binder ("", a, b)) : EXTYPE TM) : string list * int list = (
	let	val (ak, au) = fv_in_extm phi a;
		val (bk, bu) = fv_in_extm phi b;
	in
		(ak @ bk, au @ bu)
	end
  )|fv_in_extm phi (Binder (_, _, _)) =
	error "fv_in_extm" 16101 [fn()=>"Invalid Binder Construct"]
  | fv_in_extm phi (Let (tl, a)) = (
	let	val (lx, ly) = split tl;
		fun aux (x::xs) = (
		  let	val (xk, xu) = fv_in_extm phi x;
		  	val (ak, au) = aux xs
		  in
			(xk @ ak, xu @ au)
		  end)
		  | aux nil = (nil,nil);
		val (lxk, lxu) = aux lx;
		val (lyk, lyu) = aux ly;
		val (ak, au) = fv_in_extm phi a ;
	in
		(lxk @ lyk @ ak, lxu @ lyu @ au)
	end)
  | fv_in_extm phi (Cond (c, a, b)) = (
	let	val (ck, cu) = fv_in_extm phi c;
		val (ak, au) = fv_in_extm phi a;
		val (bk, bu) = fv_in_extm phi b;
	in
		(ck @ ak @ bk, cu @ au @ bu)
	end)
  | fv_in_extm phi (App (f, a, _)) = (
	let	val (fk, fu) = fv_in_extm phi f;
		val (ak, au) = fv_in_extm phi a;
	in
		(fk @ ak, fu @ au)
	end)
  | fv_in_extm phi (TmTyped (Id s, ty)) =
	fv_in_exty phi ty
  | fv_in_extm phi (TmTyped (SetDisplay tl, ty)) = (
	let	val (lfvs, rfvs) = split (map (fv_in_extm phi) tl);
		val fk = flat lfvs;
		val fu = flat rfvs;
		val (tk, tu) = fv_in_exty phi ty;
	in
		(fk @ tk, fu @ tu)
	end)
  | fv_in_extm phi (TmTyped (ListDisplay tl, ty)) = (
	let	val (lfvs, rfvs) = split (map (fv_in_extm phi) tl);
		val fk = flat lfvs;
		val fu = flat rfvs;
		val (tk, tu) = fv_in_exty phi ty;
	in
		(fk @ tk, fu @ tu)
	end)
  | fv_in_extm phi (TmTyped (_, _)) =
	error "fv_in_extm" 16101 [fn() => "Invalid TmTyped Construct"]
  | fv_in_extm phi (TmAq tm) = (nil,nil)
  | fv_in_extm phi (SetDisplay _ ) =
	error "fv_in_extm" 16101 [fn() => "Invalid SetDisplay Construct"]
  | fv_in_extm phi (SetComprehension (a,b)) =
	let	val (ak, au) = fv_in_extm phi a;
		val (bk, bu) = fv_in_extm phi b;
	in
		(ak @ bk, au @ bu)
	end
  | fv_in_extm phi (ListDisplay _ ) =
	error "fv_in_extm" 16101 [fn() => "Invalid ListDisplay Construct"]
  | fv_in_extm phi (Id s) =
	error "fv_in_extm" 16101 [fn() => "Invalid Id Construct"]
  | fv_in_extm phi (CharLit c) = (nil,nil)
  | fv_in_extm phi (StringLit s) = (nil,nil)
  | fv_in_extm phi (NumLit s) = (nil,nil);

=TEX
=SML
local
	val âtyvar_nameá : int ref = ref 1;
in
	fun âstart_tyvar_nameá ((): unit) : unit = tyvar_name := 1;
	fun ânext_tyvar_nameá (() : unit) : string = (
		let	val x = !tyvar_name
		in
			(tyvar_name := x+1;
			"'"^(	if x > 26
				then
					string_of_int x
				else
					chr (x+(ord "a")-1))
			)
		end
	);
end;
=TEX
=SML
fun âelim_repeatsá (xl : ''a list) : ''a list = (
	let	fun aux nil ys = nil
		  | aux (x::xs) ys =
			if x mem ys
			then
				aux xs ys
			else
				x::(aux xs (x::ys))
	in
		aux xl nil
	end
);
=TEX
=SML
fun âget_tyvar_namesá ((ty_names, (unk::rest)) : string list * 'a list) : ('a * string) list = (
	let	fun aux() = (
		let
			val tvn = next_tyvar_name()
		in
			if tvn mem ty_names
			then
				aux()
			else
				tvn
		end);
	in
		(unk, aux())::get_tyvar_names (ty_names, rest)
	end)
  | get_tyvar_names (tynames, nil) = nil;

=TEX
=SML
fun âget_tyvar_infoá (phi : SUBS) (tm : EXTYPE TM) : (int * string) list = (
	let
		val side_effect = start_tyvar_name();
		val (known, unk) = fv_in_extm phi tm
	in
		get_tyvar_names (known, elim_repeats unk)
	end
);
=TEX

=SML
fun âget_tyvar_info_tyá (phi : SUBS) (ty : EXTYPE) : (int * string) list = (
	let	val side_effect = start_tyvar_name();
		val (known, unk) = fv_in_exty phi ty;
	in
		get_tyvar_names (known, elim_repeats unk)
	end
);
=TEX

=SML
fun âvars_in_termá (term : TY TM) (env : ENV) : (string*EXTYPE) list = (
let	val freevars = fv_set term;
	fun aux (var::rest) =
		(var, (fst o env) var)::(aux rest)
	  | aux _ = nil;
in
	aux freevars
end
);
=TEX

\subsection{Handling and Displaying Errors}

=SML
fun âbrktá (s : string) : string = (
	if size s = 0
	then
		s
	else
		"(" ^ s ^ ")"
);
=TEX

=SML
fun âformat_extypeá (phi : SUBS) (namemap : (int * string) list) (t : EXTYPE) : string = (
	case t of	
		ExVartype (Known s) => s
	|	ExVartype (Unknown x) =>
			(case apply_subs phi x of
			  ExVartype (Unknown y) =>
				((lassoc3 namemap y)
				handle Fail msg =>
				  error "format_extype" 16100 [fn()=>get_message_text msg])
			| Other => format_extype phi namemap Other)
	|	ExType (s, tys as [tya, tyb]) => (
		case get_fixity s of
		Lex.Infix _ =>
			brkt(format_extype phi namemap tya^" ‹ "^format_extype phi
					namemap tyb)
		|_	=>
			brkt(format_list (format_extype phi namemap) tys ", ") ^ s)
	|	ExType (s, tys) => (
			brkt(format_list (format_extype phi namemap) tys ", ") ^ s)
);
=TEX

=SML	
fun âformat_extype1á (phi : SUBS) (ty : EXTYPE) : string = (
	let	val namemap = get_tyvar_info_ty phi ty;
	in
		 format_extype phi namemap ty
	end
);

=SML
fun âti_errlineá (msg : int) (inserts : string list) : unit = (
	diag_string (get_error_message msg inserts)
);
=TEX

=SML
fun âti_failá (msg : int) (term : TY TM) (inserts : string list) : 'a = (
	ti_errline 16001 [];
	ti_errline 16002 [format_tm format_ty term];
	ti_errline msg inserts;
	fail "HOL type inferrer"  16000 []
);
=TEX

=SML
fun âti_errcontextá (tml : (string*EXTYPE) list) (phi : SUBS): unit = (
let	val thing = map (fv_in_exty phi) (map snd tml);
	val knowns = flat (map fst thing);
	val unknowns = flat (map snd thing);
	val side_effect = start_tyvar_name();

	val namemap = get_tyvar_names (knowns, elim_repeats unknowns);
	fun aux (((var,exty)::tml) : (string*EXTYPE) list) =
		(ti_errline 16055 [var, (format_extype phi namemap exty)];
		aux tml)
	  | aux _ = ();
in
	if get_flag "ti_verbose"
	then
	(
		(case tml of
		nil	=> ()
		|Other	=> (ti_errline 16050 [];
				aux  tml; ())
		);
		())
	else
		()
end);

=TEX

This is a version of the function $Unification.unify$
which handles errors in conformant way to the
error handling in type inference.

=SML
fun âunify1á (phi : SUBS) ((t1, t2) : EXTYPE * EXTYPE) (term : TY TM) (env : ENV) : SUBS = (
	unify phi (t1, t2)
	handle Fail msg =>
		(ti_errline 16001 [];
		ti_errline 16002
			[format_tm format_ty term];
		ti_errline 16020 [format_extype1 phi t1, format_extype1 phi t2];
		ti_errline 16022 [get_message_text msg];
		ti_errcontext (vars_in_term term env) phi;
		fail "HOL type inferrer"  16000 [])
);
=TEX

=SML
fun âlist_unify1á (phi : SUBS) (tl : EXTYPE list) (term : TY TM) (env : ENV) : SUBS = (
	list_unify phi tl
	handle Fail msg =>
		(ti_errline 16001 [];
		ti_errline 16002
			[format_tm format_ty term];
		ti_errline 16021 [format_list ((curry op ^ ":") o format_extype1 phi) tl ", "];
		ti_errline 16022 [get_message_text msg];
		ti_errcontext (vars_in_term term env) phi;
		fail "HOL type inferrer"  16000 [])
);
=TEX

=SML
fun âextype_to_type1á (phi : SUBS) (namemap : (int * string) list) (ty : EXTYPE) : TYPE = (
	extype_to_type phi namemap ty

	handle Fail msg => error "extype_to_type" 16101
		[fn() => get_message_text msg]
);
=TEX

\subsection{Production of a Term with Extended Types}

The function $ti$ and its related functions introduced
below implement the inference rules of \cite{DS/FMU/IED/DTD016}.

=SML
fun âtiá (env : ENV) ((term as (Binder (s, a, b))) : TY TM) : INF_TUPLE
	= ti_binder env s a b term
  | ti env (term as (Let (tl, a))) = ti_let env tl a term
  | ti env (term as (Cond (c, a, b))) = ti_cond env c a b term
  | ti env (term as (App (f, a, fix))) = ti_app env f a fix term
  | ti env (term as (TmTyped (a,ty))) = ti_tmtyped env a ty term
  | ti env (term as (TmAq tm)) = ti_tmaq env tm
  | ti env (term as (SetDisplay tl)) = ti_setdisplay env tl term
  | ti env (term as (SetComprehension (a,b))) = ti_setcomprehension env a b term
  | ti env (term as (ListDisplay tl)) = ti_listdisplay env tl term
  | ti env (term as (Id s)) = ti_id env s
  | ti env (term as (CharLit c)) = ti_charlit env c
  | ti env (term as (StringLit s)) = ti_stringlit env s
  | ti env (term as (NumLit i)) = ti_numlit env i
=TEX
=SML
and
âti_binderá (env : ENV) ("" : string) (a : TY TM) (b : TY TM) (term : TY TM)
	: INF_TUPLE = (

	if is_varstruct a
	then
		let	val newenv = grow_env env a;
			val (atm, aty, apsi) = ti newenv a;
			val newenv' = sub_ty newenv apsi;
			val (btm, bty, bpsi) = ti newenv' b;
			val phi = scomp bpsi apsi;
			val tty = funt aty bty;
		in
			((Binder ("", atm, btm)), tty, phi)
		end
	else
		ti_fail 16010 term [format_tm format_ty a])

|ti_binder env s a b term = (
	let	val newenv = grow_env env (Id s);
	in
		ti newenv (App (Id s, Binder("", a, b), Lex.Nonfix))
	end)
=TEX
=SML
and
âti_letá (env : ENV) (tmlist : (TY TM * TY TM) list) (a : TY TM) (term : TY TM)
	: INF_TUPLE = (

	let	fun list_is_varstruct nil = true
		  | list_is_varstruct (x::xs) = (
			if is_varstruct x
			then
				list_is_varstruct xs
			else
				ti_fail 16010 term [format_tm format_ty x]);
		val (left, right) = split tmlist;
		val side_effect = list_is_varstruct left;
	in
		ti_let1 env left right a term
	end)
=TEX
=SML
and
âti_let1á (env : ENV) (left : TY TM list) (right : TY TM list) (a : TY TM) (term : TY TM)
	: INF_TUPLE = (

	let
		fun rep_unify1 (psi::psil) (typair::tyl) term = (
			(unify1 psi typair term env)::(rep_unify1 psil tyl term)
		 )| rep_unify1 _ _ _ = [id_subs];

		fun ti_components env (t::tml) = (
			let	val newenv = grow_env env t;
				val next = ti_components newenv tml;

			in
				(fst next, (ti newenv t)::(snd next))
			end)
		  | ti_components env nil = (env, nil);

		val (x_right, phi_right) = list_ti env right;
		val (tm_right, ty_right, psi_right) = split3 x_right;
		val env' = sub_ty env phi_right;

		val (newenv, x_left) = ti_components env' left;
		val (tm_left, ty_left, psi_left) = split3 x_left;

		val newenv' = sub_ty newenv phi_right;

		val tm_list = combine tm_left tm_right;
		val ty_list = combine ty_left ty_right;
		val psi_list = combine psi_right psi_left;
		val c_psi_list = map (uncurry scomp) psi_list;

		val phi_list = rep_unify1 c_psi_list ty_list term;
		val phi = (list_scomp o rev) phi_list;
		val newenv'' = sub_ty newenv' phi;
		val (atm, aty, aphi) = ti newenv'' a;
		val phi' = scomp aphi phi;
	in
		(Let (tm_list, atm), aty, phi')
	end)
=TEX
=SML
and
âti_condá (env : ENV) (c : TY TM) (a : TY TM) (b : TY TM) (term : TY TM)
	: INF_TUPLE = (

	let	val (	(ctm, cty, _),
			(atm, aty, _),
			(btm, bty, _),
			psi) =
				(case list_ti env [c,a,b] of
				([cc,aa,bb],p)	=> (cc,aa,bb,p)
				| _		=> error "ti_cond" 16100 []);
		val psi' = unify1 psi (cty, type_to_extype BOOL) term env;
		val psi'' = unify1 psi' (aty, bty) term env
	in
		(Cond (ctm, atm, btm), bty, psi'')
	end)
=TEX
=SML
and
âti_appá (env : ENV) (f : TY TM) (a : TY TM) (fix : Lex.FIXITY) (term : TY TM)
	: INF_TUPLE = (

	let	val (ftm, fty, fpsi) = ti env f;
		val newenv = sub_ty env fpsi;
		val (atm, aty, apsi) = ti newenv a;
		val ty = ExVartype(Unknown(next_name()));
		val psi = scomp apsi fpsi;
		val nty = funt aty ty;
		val phi = unify1 psi (fty, nty) term env;
	in
		(App (ftm, atm, fix), ty, phi)
	end)
=TEX

=SML
and
âti_tmtypedá (env : ENV) (a : TY TM) (ty : TY) (term : TY TM) : INF_TUPLE = (
	let	val (atm, aty, apsi) = ti env a;
		val exty = (type_to_extype o ty_to_type) ty;
		val psi = unify1 apsi (aty, exty) term env;
	in
		(atm, aty, psi)
	end)
=TEX
=SML
and
âti_tmaqá (env : ENV) (tm : TERM) : INF_TUPLE = (
	TmAq tm, (type_to_extype o type_of) tm, id_subs)
=TEX
=SML
and
âti_setdisplayá (env : ENV) (tl : TY TM list) (term : TY TM) : INF_TUPLE = (
	let	val (tmlist, psi) = list_ti env tl;
		val (timl, tiyl, tpsil) = split3 tmlist;
		val phi = list_unify1 psi tiyl term env;
		val ty = 
			(case tiyl of
			  nil => ExVartype(Unknown(next_name()))
			  | _ => hd tiyl
			);
	in
		(TmTyped (SetDisplay timl, ty),
			ExType ("SET",[ty]), phi)
	end)
=TEX
=SML
and
âti_setcomprehensioná (env : ENV) (a : TY TM) (b : TY TM) (term : TY TM)
	: INF_TUPLE = (

	if is_varstruct a
	then
		let	val newenv = grow_env env a;
			val (atm, aty, apsi) = ti newenv a;
			val newenv' = sub_ty newenv apsi;
			val (btm, bty, bpsi) = ti newenv' b;
			val psi = scomp bpsi apsi;
			val boolty = type_to_extype BOOL;
			val phi = unify1 psi (bty, boolty) term env;
		in
			(SetComprehension (atm, btm),
				ExType ("SET", [aty]) , phi)
		end
	else
		ti_fail 16010 term [format_tm format_ty a])
=TEX
=SML
and
âti_listdisplayá (env : ENV) (tl : TY TM list) (term : TY TM) : INF_TUPLE = (

	let	val (tmlist, psi) = list_ti env tl;
		val (timl, tiyl, tpsil) = split3 tmlist;
		val phi = list_unify1 psi tiyl term env;
		val ty = 
			(case tiyl of
			  nil => ExVartype(Unknown(next_name()))
			  | _ => hd tiyl
			);
	in
		(TmTyped (ListDisplay timl, ty),
			ExType ("LIST",[ty]), phi)
	end)
=TEX
=SML
and
âti_idá (env : ENV) (s : string) : INF_TUPLE = (
	let	val ty = (fst o env) s;
	in
		(TmTyped(Id s, ty), ty, id_subs)
	end)
=TEX
=SML
and
âti_charlitá (env : ENV) (c : string) : INF_TUPLE = (
	CharLit c, type_to_extype CHAR, id_subs)
=TEX
=SML
and
âti_stringlitá (env : ENV) (s : string) : INF_TUPLE = (
	StringLit s, type_to_extype STRING, id_subs)
=TEX
=SML
and
âti_numlitá (env : ENV) (i : int) : INF_TUPLE = (
	NumLit i, type_to_extype †, id_subs)
=TEX
=SML
and
âlist_tiá (env : ENV) (tml : TY TM list) : INF_TUPLE list * SUBS = (
	let	fun list_ti_aux env phi nil = (nil, phi)
		  | list_ti_aux env phi (term::tml) = (
		let	val (titerm as (tm, ty, psi)) = ti env term;
			val newenv = sub_ty env psi;
			val psi' = scomp psi phi;
			val next = list_ti_aux newenv psi' tml;
		in
			(titerm::fst next, snd next)
		end);
	in
		list_ti_aux env id_subs tml
	end
)
=TEX
=SML
; (* End of definition of function ti and its friends *)
=TEX

\subsection{Conversion of a term to a ``HOL Term''}

=SML
fun âextm_to_termá (phi : SUBS) (namemap : (int * string) list) ((Binder ("", a, b))
	: EXTYPE TM) : TERM = (

	let	val ta = extm_to_term phi namemap a;
		val tb = extm_to_term phi namemap b;
	in
		mk_ (ta, tb)
		handle Fail msg =>
			error "extm_to_term" 16101 [fn() => get_message_text msg]
	end
  )|extm_to_term phi namemap (Binder (_, _, _)) =
	error "extm_to_term" 16101 [fn()=>"Invalid Binder Construct"]
  | extm_to_term phi namemap (Let (tl, a)) = (
	let	val (lx, ly) = split tl;
		val tlx = map (extm_to_term phi namemap) lx;
		val tly = map (extm_to_term phi namemap) ly;
		val til = combine tlx tly;
		val ta = extm_to_term phi namemap a;
	in
		mk_let (til, ta)
		handle Fail msg =>
			error "extm_to_term" 16101 [fn() => get_message_text msg]
	end)
  | extm_to_term phi namemap (Cond (c, a, b)) = (
	let	val tc = extm_to_term phi namemap c;
		val ta = extm_to_term phi namemap a;
		val tb = extm_to_term phi namemap b;
	in
		mk_if (tc, ta, tb)
		handle Fail msg =>
			error "extm_to_term" 16101 [fn() => get_message_text msg]
	end)
  | extm_to_term phi namemap (App (f, a, _)) = (
	let	val tf = extm_to_term phi namemap f;
		val ta = extm_to_term phi namemap a;
	in
		mk_app (tf, ta)
		handle Fail msg =>
			error "extm_to_term" 16101 [fn() => get_message_text msg]
	end)
  | extm_to_term phi namemap (TmTyped (Id s, ty)) = ((
	(case type_of_const s of
		Value _ => resolve_alias
	|	Nil => mk_var)
			(s, extype_to_type1 phi namemap ty)
	)
	handle Fail msg => error "extm_to_term" 16101 [fn() => get_message_text msg]
	)
  | extm_to_term phi namemap (TmTyped (SetDisplay tl, ty)) = (
	(case tl of
		nil =>	mk_¤ (extype_to_type1 phi namemap ty)
		| _ =>	(let val til = map (extm_to_term phi namemap) tl
			in
				mk_enum_set til
			end))

	handle Fail msg => error "extm_to_term" 16101 [fn() => get_message_text msg]
	)
  | extm_to_term phi namemap (TmTyped (ListDisplay tl, ty)) = (
	(case tl of
		nil =>	mk_empty_list (extype_to_type1 phi namemap ty)
		| _ =>	(let val til = map (extm_to_term phi namemap) tl
			in
				mk_list til
			end))

	handle Fail msg => error "extm_to_term" 16101 [fn() => get_message_text msg]

	)
  | extm_to_term phi namemap (TmTyped (a, ty)) = extm_to_term phi namemap a
  | extm_to_term phi namemap (TmAq tm) = tm
  | extm_to_term phi namemap (SetDisplay _ ) =
	error "extm_to_term" 16101 [fn() => "Invalid SetDisplay Construct"]
  | extm_to_term phi namemap (SetComprehension (a,b)) = (
	let	val ta = extm_to_term phi namemap a;
		val tb = extm_to_term phi namemap b;
	in
		mk_set_comp (ta, tb)
		handle Fail msg =>
			error "extm_to_term" 16101 [fn() => get_message_text msg]
	end)
  | extm_to_term phi namemap (ListDisplay _ ) =
	error "extm_to_term" 16101 [fn() => "Invalid ListDisplay Construct"]
  | extm_to_term phi namemap (Id s) =
	error "extm_to_term" 16101 [fn() => "Invalid Id Construct"]
  | extm_to_term phi namemap (CharLit c) = (
	mk_char c
	handle Fail msg => error "extm_to_term" 16101 [fn() => get_message_text msg]
	)
  | extm_to_term phi namemap (StringLit s) = (
	mk_string s
	handle Fail msg => error "extm_to_term" 16101 [fn() => get_message_text msg]
	)
  | extm_to_term phi namemap (NumLit s) = (
	mk_† s
	handle Fail msg => error "extm_to_term" 16101 [fn() => get_message_text msg]
	);
=TEX

\subsection{The Type Inference Mechanism Glue}

=SML
fun âmake_term1á (tm : TY TM) : INF_TUPLE = (
	let	val side_effect = start_again();
		val env = init_env tm;
	in
		ti env tm
	end
);
=TEX
fun âmake_term2á ((tm, ty, phi) : EXTYPE TM * 'a * SUBS) : TERM = (
=SML
fun âmake_term2á ((tm, ty, phi) : INF_TUPLE) : TERM = (
	let	val namemap = get_tyvar_info phi tm;
	in
		extm_to_term phi namemap tm
	end
);
=TEX
=SML
val âmake_termá : TY TM -> TERM = make_term2 o make_term1;
=TEX

=SML
end; (* of structure TypeInference *)
=TEX

This concludes the Standard ML code for type inference.

\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}
