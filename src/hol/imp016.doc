% imp016.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of Type Inference}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP016}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}
%\TPPstatus{Approved}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This contains the Standard ML implementation of the
type inference mechanism.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ R.D. Arthan\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}

\item[Issue 2.1]
This is an approved version of issue 1.16.

\item[Issue 2.2 27 August 1991]
Corrected the commented-out declaration of the
flag $ti\_verbose$.

\item[Issue 2.3 30 September 1991]
Fixed a bug in $set\_ti\_context$ which
causing repeated instances
of the same free variable in the context.

\item[Issue 2.4 21 November 1991]
Modified to use the new interface of the unification algorithm.
Re-coded $ti$ to reduce redundancy in the function call parameters.
Also improved the performance of
$fv\_in\_exty$ and $fv\_in\_extm$, and
as a consequence, removing the need for
$elim\_repeats$. Finally, renamed $ty\_to\_type$ to $make\_type$.

\item[Issue \SCCSversion, \FormatDate{92/01/20} ] Updated to use new fonts.

\end{description}
\subsection{Changes forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document contains the Standard ML code for implementing
the type inference mechanism for the ICL product HOL.
It corresponds to the
detailed design of type inference
as specified in \cite{DS/FMU/IED/DTD016}.

\subsection{Introduction}

The type inference mechanism is a part of the ICL product
HOL. This document contains the Standard ML code which
implements the mechanism. Description of the functionality
is only provided where it is considered that the
code itself is complex. A description of the functional
aspects of the mechanism can be found in
\cite{DS/FMU/IED/DTD016}.

The type inference mechanism should be built as part of the
release for ICL product HOL. The procedures for building
HOL are described in \cite{DS/FMU/IED/DTD021}.

The interfaces which are externally available are described
in the signature for type inference \cite{DS/FMU/IED/DTD016}
but it is not expected or intended that the end user
should make use of these interfaces. The structure
is therefore left unopened.

\subsubsection{Background and Purpose}

The implementation of the type checker has been done
in response to its detailed design \cite{DS/FMU/IED/DTD016}
and its purpose is to infer all the types in any given
HOL term.

\subsubsection{Dependencies}

The Standard ML code in this document depends on the literate script
contained in \cite{DS/FMU/IED/DTD016} for the signature of
$TypeInference$,
and on~\cite{DS/FMU/IED/DTD015} for fixity information.

\subsubsection{Possible Enhancements}

None are envisaged at present.

\subsubsection{Deficiencies}

At present, there are no known deficiencies in this document.

\section{THE STANDARD ML CODE FOR TYPE INFERENCE}

This code is largely believed to be self-documenting. Where
this is not considered to be the case, additional description
has been provided.
The code is organised in to sections of the document
which correspond to sections of the same name in
the parent document \cite{DS/FMU/IED/DTD016}. A overview of
the features of the code in each section can be found in
\cite{DS/FMU/IED/DTD016}.
=SML
structure ÛTypeInferenceÝ : TypeInference = struct
=TEX

=SML
open Parser Unification SparseArray;

val Ûti_verboseÝ = ref false;
val Ûarray_sizeÝ = 100;

val _ =
new_flag {name = "ti_verbose", control=ti_verbose, check=fun_true, default = fun_true};

type ÛENVÝ = string -> (EXTYPE*bool);
type ÛINF_TUPLEÝ = EXTYPE TM * EXTYPE;

val Ûti_subsÝ = new_subs array_size;
=TEX

\subsection{General Utilities}

=SML
fun Ûtype_of_constÝ (s : string) : TYPE OPT = (
	case get_const_info s of
		Value (t,_) => Value t
		|       Nil => Nil
);
=TEX

=SML
fun Ûeval_type_consÝ (s : string, tyl : TYPE list) : TYPE = (
	if is_type_abbrev s
	then
		expand_type_abbrev (s, tyl)
	else
		mk_ctype (s, tyl)
);
=TEX

=SML
fun Ûmake_typeÝ ((TyAtom s) : TY) : TYPE  = (
	if (hd o explode) s = "'"
	then
		if is_type_abbrev s
		then
			expand_type_abbrev (s, [])
		else
			mk_vartype s
	else
		case get_type_info s of
			Value (0, _) => eval_type_cons (s, [])
		|	Nil => fail "HOL-Parser" 16060 [fn() => s]
		|	Value (x, _) => fail "HOL-Parser" 16030
			[fn() => s,
			 fn() => string_of_int x,
			 fn() => if x = 1 then "" else "s",
			 fn() => "0",
			 fn() => "s"]
)
  |  make_type (TyCompound (tyl, s, _)) = (
	case get_type_info s of
	   Value (x, _) =>
		let
			val ltyl = length tyl
		in
		   if x = ltyl
		   then
			eval_type_cons (s, map make_type tyl)
		   else
			fail "HOL-Parser" 16030
			[fn() => s,
			 fn() => string_of_int x,
			 fn() => if x = 1 then "" else "s",
			 fn() => string_of_int ltyl,
			 fn() => if ltyl = 1 then "" else "s"
			]
		end

	|  Nil => fail "HOL-Parser" 16060 [fn() => s]
)
  |  make_type (TyAq ty) = ty;
=TEX

This determines whether or not a term is of the type
which can be a variable (i.e., a simple variable, a tuple etc.).
=SML
fun Ûis_varstructÝ (tm : 'a TM) : bool = (
	case tm of
		Id x =>
			(case type_of_const x of
			Value _ => false
			| Nil	=> true)
	|	TmTyped (t, _) => is_varstruct t
	|	App (Id ",", a, _) => is_varstruct a
	|	App (f, a, _) => is_varstruct f andalso is_varstruct a
	|	Other => false
);
=TEX

=SML
fun Ûsub_tyÝ (env : ENV) : ENV = (
	fn s => 
		let val (ty, flag) = env s;
		in	((sub_type ti_subs) ty, flag)
		end
);
=TEX

\subsection{Environment Management}

The variable reference $ti\_context\_info$ is used to store the context.

=SML
val Ûti_context_infoÝ : (string*TYPE) list ref = ref [];

fun Ûset_ti_contextÝ (tml : TERM list) : unit = (
let	val allterms = list_term_union (map frees tml);
	val di = all_different (map (fst o dest_var) allterms);
in
	if di
	then
		ti_context_info := map dest_var allterms
	else
		fail "HOL-Parser" 16040 []
end);

fun Ûget_ti_contextÝ (() : unit) : TERM list =
	(map mk_var (!ti_context_info));

=TEX
=SML
fun Ûfv_setÝ ((Binder (s, a, b)) : 'a TM) : string list  = fv_set b diff fv_set a
  | fv_set (Let (tl, a)) = (
	let	val (lx, ly) = split tl;
		val aux = list_cup o map fv_set;
	in
		((fv_set a diff aux lx) cup aux ly)
	end)
  | fv_set (Cond (c, a, b)) = fv_set c cup fv_set a cup fv_set b
  | fv_set (App (f, a, _)) = fv_set f cup fv_set a
  | fv_set (TmTyped (a,_)) = fv_set a
  | fv_set (TmAq tm) = nil
  | fv_set (SetDisplay tl) = list_cup (map fv_set tl)
  | fv_set (SetComprehension (a,b)) = fv_set a cup fv_set b
  | fv_set (ListDisplay tl) =  list_cup (map fv_set tl)
  | fv_set (Id s) = (
	case type_of_const s of
		Value x => []
		|   Nil => [s]
	)
  | fv_set (CharLit c) = nil
  | fv_set (StringLit s) = nil
  | fv_set (NumLit i) = nil;
=TEX

=SML
fun Ûinit_envÝ (tm : 'a TM) : ENV = (
	let 	val freevars = fv_set tm;
		val freemap = new_name freevars;
	in
	   (fn s =>
		case type_of_const s of
			Value t => (replaced t, false)
			  | Nil =>
				(
				(type_to_extype (lassoc3
				  (!ti_context_info) s), true)
				handle (Fail msg) =>
				(ExVartype(Unknown(lassoc3 freemap s)), false))
	handle (Fail msg) =>
		error "init_env" 16101 [fn() => s]
	    )
	end);
=TEX
=SML
fun Ûgrow_envÝ (env : ENV) (tm : 'a TM) : ENV = (
	let 	val freevars = fv_set tm;
		val freemap = new_name freevars;
	in
	   (fn s =>
		case type_of_const s of
			Value t => (replaced t, false)
			  | Nil =>
				if s mem freevars
				then
					(ExVartype(Unknown(lassoc3 freemap s)), false)
				else
					env s
	handle (Fail msg) =>
		error "grow_env" 16101 [fn() => s]
	    )
	end);
=TEX

\subsection{Identification of Free Variables}

=SML
fun Ûfv_in_extyÝ (ty : EXTYPE) : string list * int list = (
let	fun aux1 ty = 
	case ty of
		ExVartype (Known x) => ([x],nil)
	|	ExVartype (Unknown tvn) => (nil, [tvn])
	|	ExType (_, tyl) => (
		let	fun aux2 (x::xs) = (
			  let	val (xk, xu) = aux1 x;
		 	 	val (ak, au) = aux2 xs
			  in
				(xk cup ak, xu cup au)
			  end)
			  | aux2 nil = (nil,nil);

		in
			aux2 tyl
		end)
in
	aux1 (sub_type ti_subs ty)
end);
=TEX

=SML
fun Ûfv_in_extmÝ ((Binder ("Ì", a, b)) : EXTYPE TM) : string list * int list = (
	let	val (ak, au) = fv_in_extm a;
		val (bk, bu) = fv_in_extm b;
	in
		(ak cup bk, au cup bu)
	end
  )|fv_in_extm (Binder (_, _, _)) =
	error "fv_in_extm" 16101 [fn()=>"Invalid Binder Construct"]
  | fv_in_extm (Let (tl, a)) = (
	let	val (lx, ly) = split tl;
		fun aux (x::xs) = (
		  let	val (xk, xu) = fv_in_extm x;
		  	val (ak, au) = aux xs
		  in
			(xk cup ak, xu cup au)
		  end)
		  | aux nil = (nil,nil);
		val (lxk, lxu) = aux lx;
		val (lyk, lyu) = aux ly;
		val (ak, au) = fv_in_extm a ;
	in
		(lxk cup lyk cup ak, lxu cup lyu cup au)
	end)
  | fv_in_extm (Cond (c, a, b)) = (
	let	val (ck, cu) = fv_in_extm c;
		val (ak, au) = fv_in_extm a;
		val (bk, bu) = fv_in_extm b;
	in
		(ck cup ak cup bk, cu cup au cup bu)
	end)
  | fv_in_extm (App (f, a, _)) = (
	let	val (fk, fu) = fv_in_extm f;
		val (ak, au) = fv_in_extm a;
	in
		(fk cup ak, fu cup au)
	end)
  | fv_in_extm (TmTyped (Id s, ty)) =
	fv_in_exty ty
  | fv_in_extm (TmTyped (SetDisplay tl, ty)) = (
	let	val (lfvs, rfvs) = split (map fv_in_extm tl);
		val fk = flat lfvs;
		val fu = flat rfvs;
		val (tk, tu) = fv_in_exty ty;
	in
		(fk cup tk, fu cup tu)
	end)
  | fv_in_extm (TmTyped (ListDisplay tl, ty)) = (
	let	val (lfvs, rfvs) = split (map fv_in_extm tl);
		val fk = flat lfvs;
		val fu = flat rfvs;
		val (tk, tu) = fv_in_exty ty;
	in
		(fk cup tk, fu cup tu)
	end)
  | fv_in_extm (TmTyped (_, _)) =
	error "fv_in_extm" 16101 [fn() => "Invalid TmTyped Construct"]
  | fv_in_extm (TmAq tm) = (nil,nil)
  | fv_in_extm (SetDisplay _ ) =
	error "fv_in_extm" 16101 [fn() => "Invalid SetDisplay Construct"]
  | fv_in_extm (SetComprehension (a,b)) =
	let	val (ak, au) = fv_in_extm a;
		val (bk, bu) = fv_in_extm b;
	in
		(ak cup bk, au cup bu)
	end
  | fv_in_extm (ListDisplay _ ) =
	error "fv_in_extm" 16101 [fn() => "Invalid ListDisplay Construct"]
  | fv_in_extm (Id s) =
	error "fv_in_extm" 16101 [fn() => "Invalid Id Construct"]
  | fv_in_extm (CharLit c) = (nil,nil)
  | fv_in_extm (StringLit s) = (nil,nil)
  | fv_in_extm (NumLit s) = (nil,nil);

=TEX
=SML
local
	val Ûtyvar_nameÝ : int ref = ref 1;
in
	fun Ûstart_tyvar_nameÝ ((): unit) : unit = tyvar_name := 1;
	fun Ûnext_tyvar_nameÝ (() : unit) : string = (
		let	val x = !tyvar_name
		in
			(tyvar_name := x+1;
			"'"^(	if x > 26
				then
					string_of_int x
				else
					chr (x+(ord "a")-1))
			)
		end
	);
end;
=TEX
=SML
fun Ûget_tyvar_namesÝ ((ty_names, (unk::rest)) : string list * 'a list) : ('a * string) list = (
	let	fun aux() = (
		let
			val tvn = next_tyvar_name()
		in
			if tvn mem ty_names
			then
				aux()
			else
				tvn
		end);
	in
		(unk, aux())::get_tyvar_names (ty_names, rest)
	end)
  | get_tyvar_names (tynames, nil) = nil;

=TEX
=SML
fun Ûget_tyvar_infoÝ (tm : EXTYPE TM) : (int * string) list = (
	let
		val side_effect = start_tyvar_name();
		val (known, unk) = fv_in_extm tm
	in
		get_tyvar_names (known, unk)
	end
);
=TEX

=SML
fun Ûget_tyvar_info_tyÝ (ty : EXTYPE) : (int * string) list = (
	let	val side_effect = start_tyvar_name();
		val (known, unk) = fv_in_exty ty;
	in
		get_tyvar_names (known, unk)
	end
);
=TEX

=SML
fun Ûvars_in_termÝ (term : TY TM) (env : ENV) : (string*EXTYPE) list = (
let	val freevars = fv_set term;
	fun aux (var::rest) =
		(var, (fst o env) var)::(aux rest)
	  | aux _ = nil;
in
	aux freevars
end
);
=TEX

\subsection{Handling and Displaying Errors}

=SML
fun ÛbrktÝ (s : string) : string = (
	if size s = 0
	then
		s
	else
		"(" ^ s ^ ")"
);
=TEX

=SML
fun Ûformat_extypeÝ (namemap : (int * string) list) (t : EXTYPE) : string = (
	case t of	
		ExVartype (Known s) => s
	|	ExVartype (Unknown x) =>
			(case sub_opt (ti_subs, x) of
			  Nil => ((lassoc3 namemap x)
				handle Fail msg =>
				  error "format_extype" 16101 [fn()=>get_message_text msg])
			| Value y => format_extype namemap y)
	|	ExType (s, tys as [tya, tyb]) => (
		case get_fixity s of
		Lex.Infix _ =>
			brkt(format_extype namemap tya^s^format_extype
					namemap tyb)
		|_	=>
			brkt(format_list (format_extype namemap) tys ", ") ^ s)
	|	ExType (s, tys) => (
			brkt(format_list (format_extype namemap) tys ", ") ^ s)
);
=TEX

=SML
fun Ûformat_extype1Ý (ty : EXTYPE) : string = (
	let	val namemap = get_tyvar_info_ty ty;
	in
		 format_extype namemap ty
	end
);

fun Ûti_errlineÝ (msg : int) (inserts : string list) : unit = (
	diag_string (get_error_message msg inserts)
);
=TEX

=SML
fun Ûti_errcontextÝ (tml : (string*EXTYPE) list): unit = (
let	val thing = map fv_in_exty (map snd tml);
	val knowns = flat (map fst thing);
	val unknowns = flat (map snd thing);
	val side_effect = start_tyvar_name();

	val namemap = get_tyvar_names (knowns, unknowns);
	fun aux (((var,exty)::tml) : (string*EXTYPE) list) =
		(ti_errline 16055 [var, (format_extype namemap exty)];
		aux tml)
	  | aux _ = ();
in
	if get_flag "ti_verbose"
	then
	(
		(case tml of
		nil	=> ()
		|Other	=> (ti_errline 16050 [];
				aux  tml; ())
		);
		())
	else
		()
end);

=TEX
=SML
datatype ÛTIERRORÝ =
	ÛErrLetÝ of (TY TM*TY TM*EXTYPE*EXTYPE)
	| ÛErrCond1Ý of (TY TM*EXTYPE)
	| ÛErrCond2Ý of (TY TM*TY TM*EXTYPE*EXTYPE)
	| ÛErrAppÝ of (TY TM*TY TM*EXTYPE*EXTYPE)
	| ÛErrTmTypedÝ of (TY TM*EXTYPE*EXTYPE)
	| ÛErrDisplayÝ of (TY TM list*EXTYPE list*int)
	| ÛErrSetCompÝ of (TY TM*EXTYPE)
	| ÛErrVarstructÝ of TY TM;


fun ÛpluÝ (x1::x2::rest) = "s"
  | plu [x1] = ""
  | plu nil = error "plu" 16100 [];


fun Ûhandle_appÝ tm1 tm2 ty1 ty2 = (
let	fun aux (ty as ExVartype (Unknown x)) = (
		case sub_opt (ti_subs, x) of
		Nil => ty
		| Value ty' => ty'
	 ) | aux ty = ty;
	val sty1 = aux ty1;
in
	case tm1 of

	App(Id "=", tm1', _) => (
	   case sty1 of
		ExType (_,[ty1', _]) => (
			ti_errline 16560 [];
			ti_errline 16561 [];
			ti_errline 16562 [format_tm format_ty tm1',
				format_extype1 ty1'];
			ti_errline 16562 [format_tm format_ty tm2,
				format_extype1 ty2]
		) | Other =>  (
			error "handle_app" 16101 [fn()=>format_extype1 ty1]
		)

	) | Other => (
		ti_errline 16500 [format_tm format_ty tm1,
 			format_extype1 ty1];
		ti_errline 16501 [format_tm format_ty tm2,
 			format_extype1 ty2]
	)
end);

fun Ûhandle_displayÝ tml types ierr = (
let	
	fun sort1 (i1 : int, (tm1:string, ty1:string)) (i2, (tm2, ty2)) =
		if ty1 = ty2 then
			if tm1 = tm2 then 0
			else i1 - i2
		else	Sort.stringorder ty1 ty2;
	fun grpaux ((ty1, tmlist1)::rest1) ((tm2, ty2)::rest2) =
		if ty1 = ty2
		then grpaux ((ty1, tmlist1@[[tm2]])::rest1) rest2
		else grpaux ((ty2, [[tm2]])::(ty1,tmlist1)::rest1) rest2
	  | grpaux res _ = res;	

	fun grp ((tm, ty)::rest) = grpaux [(ty, [[tm]])] rest
	  | grp _ = error "ti_error_handler" 16100 [];
	fun do_errmsgs ((ty, tmlist)::rest) = (
		ti_errline 16505 [ty, plu tmlist];
		map (ti_errline 16506) tmlist;
		do_errmsgs rest
	) | do_errmsgs nil = nil;
	val stml = map (format_tm format_ty) tml;
	val styl = map format_extype1 types;
	val tmty = (combine stml styl);
	val itmty = combine (interval 1 (length styl)) tmty;
	val stmty = (map snd) (Sort.sort sort1 itmty);
in
	(ti_errline ierr [];
	do_errmsgs (grp stmty);()
	)
end);

fun Ûhandle_letÝ tm1 tm2 ty1 ty2 = (
	ti_errline 16560 [];
	ti_errline 16561 [];
	ti_errline 16562 [format_tm format_ty tm1,
		format_extype1 ty1];
	ti_errline 16562 [format_tm format_ty tm2,
		format_extype1 ty2]
);

fun Ûhandle_setcompÝ tm ty = (
	ti_errline 16520 [format_tm format_ty tm,
		format_extype1 ty]
);

fun Ûhandle_cond1Ý tm ty = (
	ti_errline 16550 [format_tm format_ty tm,
		format_extype1 ty]
);

fun Ûhandle_cond2Ý tm1 tm2 ty1 ty2 = (
	ti_errline 16551 [];
	ti_errline 16561 [];
	ti_errline 16562 [format_tm format_ty tm1,
		format_extype1 ty1];
	ti_errline 16562 [format_tm format_ty tm2,
		format_extype1 ty2]
);

fun Ûhandle_tmtyped tm1Ý ty1 ty2 = (
	ti_errline 16530 [format_tm format_ty tm1,
				format_extype1 ty1];
	ti_errline 16531 [format_extype1 ty2]
);
fun Ûhandle_varstructÝ a = (
	ti_errline 16010 [format_tm format_ty a]
);

fun Ûti_error_handlerÝ term info = (
	(
	ti_errline 16000 [format_tm format_ty term];
	case info of
	ErrLet (tm1, tm2, ty1, ty2) => (
		handle_let tm1 tm2 ty1 ty2
	) | ErrCond1 (tm, ty) => (
		handle_cond1 tm ty
	) | ErrCond2 (tm1, tm2, ty1, ty2) => (
		handle_cond2 tm1 tm2 ty1 ty2
	) | ErrApp (tm1, tm2, ty1, ty2) => (
		handle_app tm1 tm2 ty1 ty2
	) | ErrTmTyped (tm1, ty1, ty2) => (
		handle_tmtyped tm1 ty1 ty2
	) | ErrDisplay (tml, tyl, ierr) => (
		handle_display tml tyl ierr
	) | ErrSetComp (tm, ty) => (
		handle_setcomp tm ty
	) | ErrVarstruct tm => (
		handle_varstruct tm
	); (* end case ... of *)
	raise QuotationError
));
=TEX

This is a version of the function $Unification.unify$
which handles errors in conformant way to the
error handling in type inference.

=SML
fun Ûextype_to_type1Ý (namemap : (int * string) list) (ty : EXTYPE) : TYPE = (
	extype_to_type ti_subs namemap ty

	handle Fail msg => error "extype_to_type" 16101
		[fn() => get_message_text msg]
);
=TEX

\subsection{Production of a Term with Extended Types}

The function $ti$ and its related functions introduced
below implement the inference rules of \cite{DS/FMU/IED/DTD016}.

=SML
fun ÛtiÝ (env : ENV) ((term as (Binder ("Ì", a, b))) : TY TM) : INF_TUPLE = (

	if is_varstruct a
	then
		let	val newenv = grow_env env a;
			val (atm, aty) = ti newenv a;
			val newenv' = sub_ty newenv;
			val (btm, bty) = ti newenv' b;
			val tty = ExType("­",[aty, bty]);
		in
			((Binder ("Ì", atm, btm)), tty)
		end
	else
		ti_error_handler term (ErrVarstruct a))
=TEX
=SML
  | ti env (term as (Binder (s, a, b))) = (
	let	val newenv = grow_env env (Id s);
	in
		ti newenv (App (Id s, Binder("Ì", a, b), Lex.Nonfix))
	end)
=TEX
=SML
  | ti env (term as Let (tmlist, a)) = (

	let	fun list_is_varstruct nil = true
		  | list_is_varstruct (x::xs) = (
			if is_varstruct x
			then
				list_is_varstruct xs
			else
				ti_error_handler term (ErrVarstruct x));
		val (left, right) = split tmlist;
		val side_effect = list_is_varstruct left;
		fun rep_unify ((ty1, ty2)::tyl) ((tm1, tm2)::tml) = (
		let	val sd = unify ti_subs (ty1, ty2)
			handle Fail msg =>
			ti_error_handler term (ErrLet(tm1, tm2, ty1, ty2));

		in	rep_unify tyl tml
		end)
		  | rep_unify _ _ = ();

		fun ti_components env (t::tml) = (
			let	val newenv = grow_env env t;
				val (n1,n2) = ti_components newenv tml;

			in
				(n1, (ti newenv t)::n2)
			end)
		  | ti_components env nil = (env, nil);

		val x_right = list_ti env right;
		val (tm_right, ty_right) = split x_right;
		val env' = sub_ty env;
		val (newenv, x_left) = ti_components env' left;
		val (tm_left, ty_left) = split x_left;

		val newenv' = sub_ty newenv;

		val tm_list = combine tm_left tm_right;
		val ty_list = combine ty_left ty_right;
		val sd = rep_unify ty_list tmlist;
		val newenv'' = sub_ty newenv';
		val (atm, aty) = ti newenv'' a;
	in
		(Let (tm_list, atm), aty)
	end)
=TEX
=SML
  | ti env (term as (Cond (c, a, b))) = (

	case list_ti env [c, a, b] of

	[(ctm, cty), (atm, aty), (btm, bty)] => (
		let	val sd = unify ti_subs (cty, type_to_extype BOOL)
			   handle Fail msg => ti_error_handler term (ErrCond1(c, cty));
			val sd = unify ti_subs (aty, bty)
			   handle Fail msg => ti_error_handler term (ErrCond2(a, b, aty, bty));
		in
			(Cond (ctm, atm, btm), bty)
		end

	) | Other => (
		error "ti_cond" 16100 []
	)
)
=TEX
=SML
  | ti env (term as (App (f, a, fix))) = (

	let	val (ftm, fty) = ti env f;
		val newenv = sub_ty env;
		val (atm, aty) = ti newenv a;
		val ty = ExVartype(Unknown(next_name()));
		val nty = ExType ("­",[aty, ty]);
		val sd = unify ti_subs (fty, nty) 
			handle Fail msg =>
			ti_error_handler term (ErrApp(f, a, fty, aty));
	in
		(App (ftm, atm, fix), ty)
	end)
=TEX

=SML
  | ti env (term as (TmTyped (a,ty))) = (
	let	val (atm, aty) = ti env a;
		val exty = (type_to_extype o make_type) ty;
		val sd = unify ti_subs (aty, exty)
			handle Fail msg =>
			ti_error_handler term (ErrTmTyped(a, aty, exty));
	in
		(atm, aty)
	end)
=TEX
=SML
  | ti env (term as (TmAq tm)) = (
	TmAq tm, (type_to_extype o type_of) tm)
=TEX
=SML
  | ti env (term as (SetDisplay tl)) = (
	let	val tmlist = list_ti env tl;
		val (timl, tiyl) = split tmlist;
		val sd = list_unify ti_subs tiyl
			handle Fail msg =>
			ti_error_handler term (ErrDisplay(tl, tiyl, 16504));
		val ty = 
			(case tiyl of
			  nil => ExVartype(Unknown(next_name()))
			  | _ => hd tiyl
			);
	in
		(TmTyped (SetDisplay timl, ty),
			ExType ("SET",[ty]))
	end)
=TEX
=SML
  | ti env (term as (SetComprehension (a, b))) = (

	if is_varstruct a
	then
		let	val newenv = grow_env env a;
			val (atm, aty) = ti newenv a;
			val newenv' = sub_ty newenv;
			val (btm, bty) = ti newenv' b;
			val boolty = type_to_extype BOOL;
			val sd = unify ti_subs (bty, boolty)
				handle Fail msg =>
				ti_error_handler term (ErrSetComp(b, bty));

		in
			(SetComprehension (atm, btm),
				ExType ("SET", [aty]))
		end
	else
		ti_error_handler term (ErrVarstruct a))
=TEX
=SML
  | ti env (term as (ListDisplay tl)) = (
	let	val tmlist = list_ti env tl;
		val (timl, tiyl) = split tmlist;
		val sd = list_unify ti_subs tiyl
			handle Fail msg =>
			ti_error_handler term (ErrDisplay(tl, tiyl, 16510));
		val ty = 
			(case tiyl of
			  nil => ExVartype(Unknown(next_name()))
			  | _ => hd tiyl
			);
	in
		(TmTyped (ListDisplay timl, ty),
			ExType ("LIST",[ty]))
	end)
=TEX
=SML
  | ti env (Id s) = (
	let	val ty = (fst o env) s;
	in
		(TmTyped(Id s, ty), ty)
	end)
=TEX
=SML
  | ti env (CharLit c) = (
	CharLit c, type_to_extype CHAR)
=TEX
=SML
  | ti env (StringLit s) = (
	StringLit s, type_to_extype STRING)
=TEX
=SML
  | ti env (NumLit i) = (
	NumLit i, type_to_extype î)
=TEX
=SML
and
Ûlist_tiÝ (env : ENV) (tml : TY TM list) : INF_TUPLE list = (
	let	fun list_ti_aux env nil = nil
		  | list_ti_aux env (term::tml) = (
		let	val (titerm as (tm, ty)) = ti env term;
			val newenv = sub_ty env;
			val next = list_ti_aux newenv tml;
		in
			(titerm::next)
		end);
	in
		list_ti_aux env tml
	end
)
=TEX
=SML
; (* End of definition of function ti and its friends *)
=TEX

\subsection{Conversion of a term to a ``HOL Term''}

=SML
fun Ûextm_to_termÝ (namemap : (int * string) list) ((Binder ("Ì", a, b))
	: EXTYPE TM) : TERM = (

	let	val ta = extm_to_term namemap a;
		val tb = extm_to_term namemap b;
	in
		mk_Ì (ta, tb)
		handle Fail msg =>
			error "extm_to_term" 16101 [fn() => get_message_text msg]
	end
  )|extm_to_term namemap (Binder (_, _, _)) =
	error "extm_to_term" 16101 [fn()=>"Invalid Binder Construct"]
  | extm_to_term namemap (Let (tl, a)) = (
	let	val (lx, ly) = split tl;
		val tlx = map (extm_to_term namemap) lx;
		val tly = map (extm_to_term namemap) ly;
		val til = combine tlx tly;
		val ta = extm_to_term namemap a;
	in
		mk_let (til, ta)
		handle Fail msg =>
			error "extm_to_term" 16101 [fn() => get_message_text msg]
	end)
  | extm_to_term namemap (Cond (c, a, b)) = (
	let	val tc = extm_to_term namemap c;
		val ta = extm_to_term namemap a;
		val tb = extm_to_term namemap b;
	in
		mk_if (tc, ta, tb)
		handle Fail msg =>
			error "extm_to_term" 16101 [fn() => get_message_text msg]
	end)
  | extm_to_term namemap (App (f, a, _)) = (
	let	val tf = extm_to_term namemap f;
		val ta = extm_to_term namemap a;
	in
		mk_app (tf, ta)
		handle Fail msg =>
			error "extm_to_term" 16101 [fn() => get_message_text msg]
	end)
  | extm_to_term namemap (TmTyped (Id s, ty)) = ((
	(case type_of_const s of
		Value _ => resolve_alias
	|	Nil => mk_var)
			(s, extype_to_type1 namemap ty)
	)
	handle Fail msg => error "extm_to_term" 16101 [fn() => get_message_text msg]
	)
  | extm_to_term namemap (TmTyped (SetDisplay tl, ty)) = (
	(case tl of
		nil =>	mk_š (extype_to_type1 namemap ty)
		| _ =>	(let val til = map (extm_to_term namemap) tl
			in
				mk_enum_set til
			end))

	handle Fail msg => error "extm_to_term" 16101 [fn() => get_message_text msg]
	)
  | extm_to_term namemap (TmTyped (ListDisplay tl, ty)) = (
	(case tl of
		nil =>	mk_empty_list (extype_to_type1 namemap ty)
		| _ =>	(let val til = map (extm_to_term namemap) tl
			in
				mk_list til
			end))

	handle Fail msg => error "extm_to_term" 16101 [fn() => get_message_text msg]

	)
  | extm_to_term namemap (TmTyped (a, ty)) = extm_to_term namemap a
  | extm_to_term namemap (TmAq tm) = tm
  | extm_to_term namemap (SetDisplay _ ) =
	error "extm_to_term" 16101 [fn() => "Invalid SetDisplay Construct"]
  | extm_to_term namemap (SetComprehension (a,b)) = (
	let	val ta = extm_to_term namemap a;
		val tb = extm_to_term namemap b;
	in
		mk_set_comp (ta, tb)
		handle Fail msg =>
			error "extm_to_term" 16101 [fn() => get_message_text msg]
	end)
  | extm_to_term namemap (ListDisplay _ ) =
	error "extm_to_term" 16101 [fn() => "Invalid ListDisplay Construct"]
  | extm_to_term namemap (Id s) =
	error "extm_to_term" 16101 [fn() => "Invalid Id Construct"]
  | extm_to_term namemap (CharLit c) = (
	mk_char c
	handle Fail msg => error "extm_to_term" 16101 [fn() => get_message_text msg]
	)
  | extm_to_term namemap (StringLit s) = (
	mk_string s
	handle Fail msg => error "extm_to_term" 16101 [fn() => get_message_text msg]
	)
  | extm_to_term namemap (NumLit s) = (
	mk_î s
	handle Fail msg => error "extm_to_term" 16101 [fn() => get_message_text msg]
	);
=TEX

\subsection{The Type Inference Mechanism Glue}

=SML
fun Ûmake_term1Ý (tm : TY TM) : INF_TUPLE = (
	let	val side_effect = start_again();
		val env = init_env tm;
		val sd = init_subs ti_subs;
	in
		ti env tm
	end
);
=TEX
=SML
fun Ûmake_term2Ý ((tm, ty) : INF_TUPLE) : TERM = (
	let	val namemap = get_tyvar_info tm;
	in
		extm_to_term namemap tm
	end
);
=TEX
=SML
val Ûmake_termÝ : TY TM -> TERM = make_term2 o make_term1;
=TEX

=SML
end; (* of structure TypeInference *)
=TEX

This concludes the Standard ML code for type inference.

\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}

=IGN
¬1=`a`®;
¬let (x:î)=`a` in c®;
¬let (x,y)=1 in T®;

¬{7;4;`x`;8;7;"FRED"}®;
¬{x; Snd (x=42,`A`); x}®;
¬{x | 0}®;
¬`A` : î®;
¬let (X,y)=4 in T®;
¬µ T · T®;
¬Hd {}®;
¬if 3 then 4 else 5®;
¬if T then 4 else `A`®;
¬let (x,y)=6 in T®;



¬1 ² 2®;

¬T ± `a`®;


¬(a,b) c®;

¬1 == 2®;


declare_type_abbrev("TRIPLE", ["'a", "'b", "'c"], ” 'a ¸ 'b ¸ 'c®);
declare_type_abbrev("TRIO", ["'a", "'b"], ” 'a ¸ 'b ¸ 'c®);



¬(1,`a`,"abc"):('a,'b,'c)TRIPLE®;(* Remark 2 *)


¬f a b c 1 = f a b c `a`®;


¬µ z s· ¶‰1 f· f 0 = z ± (µ n· f s (n + 1) = s (f n) n)®;
 
¬let 12 = 12 in 12®; (* Remark 3 *)

¬if 1 then `a` else `b`®;	(* Remark 4 *)
¬if x=y then `a` else "b"®;	(* Remark 4 *)
¬if x=y then [1+2+3,1] else [1+2+3;2]®;


¬³(x + 1)®;

¬{a;h;i;`a`} = {} ± a = b ± b = c ± c = d ± h = c ± i = h ± b = "b"®;


¬a = b ± b = c ± c = d ± h = c ± i = h ± b = "b" ± {a;h;i;`a`} = {}®;


¬[1;2;`a`]®;


¬µx·f + 2®;


