% %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{HOL PDS System Initialisation}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP036}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the implementation for the
system initialisation functions.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library\\RDA\\AJH\\DJK}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1]
First draft.
\item[Issue 1.2]
Removed some hangovers from quick document creation.
Added setting of $profiling$ to $false$.
\item [Issue 1.3]
Added $reset\_flag$ $"subgoal\_package\_quiet"$.
\item[Issue 1.4, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.5]
Changes to reflect needs of \cite{DS/FMU/IED/DTD069}.
\item [Issue 1.6]
Added $print\_status$.
\item [Issue 1.7]
Changed save and exit commands.
\item [Issue 1.8 (26th May 1992)]
Renamings from version 1.5 of DS/FMU/IED/WRK038.
\item [Issue 1.9 (26th May 1992)]
Added $use\_terminal$ to initialisation list.
\item [Issue 1.10 (23rd June 1992)]
Removed spurious line in $icl'write\_to\_initialisation\_error\_file$.
\item [Issue 1.11 (29th June 1992)]
Recognise difference between unreadable and unprocessable
initialisation files.
\item [Issue 1.12 (29th June 1992)]
Changed formatting of $print\_status$ line.
\item [Issue 1.13, 1.14, 1.15(13th July 1992)]
Protecting against run-time environment errors.
\item [Issue 1.16 (14th September 1992)]
Swapped order of initialisation functions.
\item [Issue 1.17 (3rd November 1992)]
Improved banner mechanism, lost system version from $print\_status$.
\item [Issue 1.18 (15th December 1992)]
Improved $save\_and\_quit$.
\item [Issue 1.19 (22nd December 1992)]
Moved line length in initialisation functions.
\item [Issue 1.20 (6th January 1993)]
Protecting user from shell error messages.
\item [Issue 1.21,1.22 (11th,12th January 1993)]
Improved start of session error message database resetting.
\item [Issue 1.24 (19th January 1993)]
$save\_and\_quit$ now checks for state being inconsistent.
\item [Issue 1.25-1.26 (7th July 1993)]
Bug 126 fixed.
\item [Issue 1.27 (17th August 1993)]
Added clearing the type compactification cache into $save\_and\_quit$.
\item [Issue 1.28, 1.29 (1st February 1994)]
Changed $exit$ and $save\_and\_exit$ to return the exit status, provided
as an argument, to the calling process. Both functions now have type $int -> unit$.
Added $use\_files\_save\_and\_exit$ to support batch processing of files.
\item [Issue 1.30 (9th May 1994)]
Added the function $save()$ and recoded $save\_and\_quit$ and $save\_and\_exit$ to use it.
\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the system initialisation functions.
The detailed design for this material is given in \cite{DS/FMU/IED/DTD036}.
\subsection{Introduction}
\subsection{Dependencies}
\subsection{Algorithms}
\subsection{Possible Enhancements}
\subsection{Deficiencies}
A number of initialisation functions use
=INLINEFT
handle _ =>
=TEX
{} which is a bit crude.
We handle the error message database as follows.
We have a local assignable variable, $sos\_emdb$, which is set to the
start of session state of the error message database.
We then during the start of session add (using $icl'change\_error\_message$)
those messages in the $error\_messages$ field of our private database.

At the end of the session we determine what messages have been
added to the error message database (by using $sos\_emdb$), and record them in
the $error\_messages$ field of our private database.

Thus, because of the behaviour of assignable variables) the $error\_messages$ will no longer contain a particular
message after two saves if in the supplied database,
but if in a child database will remain in $error\_messages$
``forever''.
=SML
local

val €sos_emdb› : ({id:int, text:string} list) ref = 
	ref(get_error_messages());

local
fun sanitize str = (
	implode (
	map (fn c => case c of
		"\\" => "\\\\"
		| "\"" => "\\\""
		| "\n" => "\\n"
		| "\t" => "\\t"
		| _ => c)
	(explode str)
	)
);
in
fun €get_new_error_messages› () = (
let	val em = (get_error_messages()) from (length (!sos_emdb));
	val ems = "[" ^
		(format_list (fn {id=id, text=text} =>
		"{id="^string_of_int id^",text=\""^sanitize text^"\"}")
		em ",") 
		^ "]";
in
	ems
end);
end;
in
=TEX

\section{SYSTEM INITIALISATION}
=SML
structure €Initialisation› : Initialisation = struct
=TEX
=SML
val €init_funs› : (unit -> unit) list ref = ref [];
=TEX
=SML
fun €new_init_fun› (f : unit -> unit) : unit = (
	init_funs := !init_funs @ [f]
);
=TEX
=SML
local
	fun hcomplaint (Fail mess) = (
		diag_string(get_error_message
			36014 ["Fail",
				(get_message mess)])
	) | hcomplaint (Error mess) = (
		diag_string(get_error_message
			36014 ["Error",
				(get_message mess)])
	) | hcomplaint other = (
		diag_string(get_error_message 
			36014 [PolyML.makestring other, 
				""])
	);
in
fun €init› (() : unit) : unit = (
	map (fn f => (f() handle complaint => hcomplaint complaint)) (!init_funs);
	()
);
end;
=TEX
=SML
type €ICL'DATABASE_INFO_TYPE› = {
	theory : string,
	language : string,
	cache_theories : string list,
	controls : ((string * bool) list * 
		(string * int) list * 
		(string * string) list),
	error_messages : {id:int, text:string} list,
	stats : int S_DICT,
	pc_stack : unit -> unit,
	pc_database : unit -> unit,
	pc_evaluators : unit -> unit,
	ksc_functions : unit -> unit,
	subgoal_package : unit -> unit
};
=TEX
Make a good starting point:
=SML
val _ = set_cache_theories ["hol","basic_hol"];
val _ = open_theory "hol";
val _ = reset_controls();
=TEX
=SML
val €icl'theory_hierarchy›: icl'Kernel.icl'HIERARCHY OPT = Nil;
val €icl'database_info› : ICL'DATABASE_INFO_TYPE = { 
	theory = get_current_theory_name(), 
	language = get_current_language(), 
	cache_theories = get_cache_theories(), 
	controls = get_controls (), 
	error_messages = [], 
	stats = get_stats (), 
	pc_stack = pending_reset_pc_stack(), 
	pc_database = pending_reset_pc_database(), 
	pc_evaluators = pending_reset_pc_evaluators(), 
	ksc_functions = pending_reset_ksc_functions(), 
	subgoal_package = pending_reset_subgoal_package() 
	};
fun €icl'set_database_info› ():unit = (use_string (" \
\	PolyML.print_depth 0; \
\ val icl'database_info : Initialisation.ICL'DATABASE_INFO_TYPE = { \
\ 	theory = get_current_theory_name(), \
\ 	language = get_current_language(), \
\ 	cache_theories = get_cache_theories(), \
\ 	controls = get_controls (), \
\ 	error_messages = " ^ get_new_error_messages() ^ ", \
\ 	stats = get_stats (), \
\ 	pc_stack = pending_reset_pc_stack(), \
\ 	pc_database = pending_reset_pc_database(), \
\ 	pc_evaluators = pending_reset_pc_evaluators(), \
\ 	ksc_functions = pending_reset_ksc_functions(), \
\ 	subgoal_package = pending_reset_subgoal_package() \
\ 	}; \
\	PolyML.print_depth 999;");
	()
);
=TEX
=SML
end; (* of structure Initialisation *)
=TEX
We now wish to expose $icl'database_info$ and $icl'theory\_hierarchy$.
=SML
val €icl'database_info› = Initialisation.icl'database_info;
val €icl'theory_hierarchy› = Initialisation.icl'theory_hierarchy;
=TEX
\section{USER INTERFACES}
=SML
structure €HOLSystem› : HOLSystem = struct
=TEX
The following turns off profiling, so that though the system build
is profiled automatically, any further profiling must be
requested.
=SML
val side_effect3 = set_flag("profiling",false);
=TEX
The following sets the subgoal package ``quietness'' to its default (``noisy'').
This means that if the switch is quiet from its point of creation then
no subgoal pacage material will arrive in the log.
=SML
val side_effect4 = reset_flag "subgoal_package_quiet";
=TEX
To have the initialisation functions called appropriately, we use a stream
to detect whether or not the return from the $PolyML.commit$ is in the same
session or the new one. This works because in the new session the stream
will have become closed.
=SML

fun €quit› (():unit) : unit = ((
let	val resp = ask_at_terminal (get_error_message 36001 ["quit"]);
in
	if resp = "y\n"
	then PolyML.quit()
	else diag_line (get_error_message 36011 [])
end)
handle complaint =>
if area_of complaint = "ask_at_terminal"
then PolyML.quit()
else raise complaint);

fun €exit› (ret : int) : unit = ((
let	val resp = ask_at_terminal (get_error_message 36001 ["exit"]);
in
	if resp = "y\n"
	then PolyML.exit ret
	else diag_line (get_error_message 36018 [])
end)
handle complaint =>
if area_of complaint = "ask_at_terminal"
then PolyML.exit ret
else raise complaint);
=TEX
=SML
fun €save› (() : unit) : bool = (
let	val dummy = if valid_thm bool_cases_axiom
		then ()
		else error "save" 36017 [];
	val side_effect = clear_compactification_cache();
	val reset = Initialisation.icl'set_database_info();
in	if PolyML.commit()
	then	true	(* same session *)
	else	(Initialisation.init(); false) (* new session *)
end);
=TEX
=SML
fun €save_and_exit› (ret : int) : unit = (
	if save ()
	then	PolyML.exit ret	(* same session *)
	else	()			(* new session *)
);
=TEX
=SML
fun €save_and_quit› (() : unit) : unit = (
	save_and_exit 0
);
=TEX
=SML
fun €load_files› (filelist : string list) : bool = (
let	fun do_file (file : string) (last_one : bool) : bool = (
	let	val last_one_msg = if last_one then
				get_error_message 36024 []
				else "";
	in
		(
			use_file file;
			diag_line(get_error_message 36021 [
				file,
				get_error_message 36022 [],
				last_one_msg
				]);
			true
		)
		handle _ => (
			diag_line(get_error_message 36021 [
				file,
				get_error_message 36023 [],
				last_one_msg
				]);
			false
		)
	end);
	fun do_file_list (f1::f2::rest) : bool = (
		do_file f1 false andalso do_file_list (f2::rest)
	) | do_file_list (f1::rest) = (
		do_file f1 true
	) | do_file_list [] = true;
in
	do_file_list filelist
end);
=TEX

=SML

fun €print_status› () : unit = (
	map (fn x => diag_string(x ^";"))
	[get_error_message 36006 [get_current_theory_name()],
	get_error_message 36007 [
		format_list (Combinators.I) (fst(get_current_pc())) ", "],
	(get_error_message 36009 [string_of_int(length (top_goals()))]
		handle (Fail _) => 
		get_error_message 30010 [])];
	diag_string(
	(get_error_message 36008 [top_current_label()]
		handle (Fail _) => 
		get_error_message 30026 []) ^ ".")
);
=TEX

Noting that $ExtendedIO.execute$ will return its first
string will ``$\backslash n$'' at the end,
extract the value of an UNIX shell variable:
=SML
fun €get_shell_var› (var : string) : string = (
let	val (is,os) = ExtendedIO.execute("/bin/echo $"^var^"  2> /dev/null");
	val aline = ExtendedIO.input_line is;
	val ealine = explode aline;
	val ealine' =  rev(tl(rev ealine));
in
	implode ealine'
end
handle _ => "");
=TEX
Note that we deliberately catch any exceptions in the above.

Noting that {\tt /bin/stty size} returns output of the form
=GFTSHOW
<number of rows> <some space characters> <number of columns>
=TEX
extract the terminal's line length:
=SML
local
	fun aux1 (" " :: rest) = aux1 rest
	| aux1 x = x;

	fun aux (" " :: rest) = aux1 rest
	| aux (a :: rest) = aux rest
	| aux [] = [];
in
fun €get_terminal_line_length› () : int = (
let	val (is,os) = ExtendedIO.execute("/bin/stty size 2> /dev/null");
	val aline = ExtendedIO.input_line is;
	val ealine = explode aline;
	val ealine' = rev(tl(rev (aux ealine)));
in
	nat_of_string(implode ealine')
end
handle _ => fail "get_terminal_line_length" 36013 []);
end;
=TEX
Note that we deliberately catch any exceptions in the above.


\subsection{Initialisation Steps}
\subsubsection{Theory Hierarchy}
=SML
fun €init_theory_hierarchy› () : unit = (
	use_string(
	"case (icl'theory_hierarchy) of " ^
	"Value th => icl'Kernel.icl'load_hierarchy th " ^
	"| Nil => ();")
	handle _ => ()
);

val initial1 = Initialisation.new_init_fun init_theory_hierarchy;
=TEX
Note that we deliberately catch any exceptions in the above.

\subsubsection{Current State}
First a function to write a list of strings to
the initialisation error file:
=SML
fun €icl'write_to_initialisation_error_file› (sl : string list) : unit = (
	case (get_shell_var "hol_initialisation_error_file") of
	"" => diag_line (get_error_message 36004 [])
	| nm => (let val oo = open_out nm;
		in
		(map (fn s => (output(oo,s);output(oo,"\n"))) sl;
		close_out oo;
		())
		end)
);
=TEX
Then the function proper:
=SML
fun €init_current_state› () : unit = (
=TEX
Current theory:
=SML
	(case get_shell_var "hol_current_theory" of
	"" => (use_string(
		"open_theory (#theory icl'database_info);")
		handle _ => ()
	) | hct => (
		open_theory hct
		handle (Fail msg) =>
		(diag_line(get_message msg);
		icl'write_to_initialisation_error_file [
		get_error_message 36002 [hct]];
		PolyML.quit())
	));
	sos_emdb := get_error_messages();
	(use_string("( \
=TEX
Current language:
=SML
\	set_current_language (#language icl'database_info) \
\		handle _ => (); \
=TEX
Cache theories:
=SML
\	(set_cache_theories (#cache_theories icl'database_info)) \
\		handle _ => []; \
=TEX
Controls (flags, strings and integers):
=SML
\	(set_controls (#controls icl'database_info)) \
\		handle _ => (); \
=TEX
Error message database:
=SML
\	(set_error_messages (#error_messages icl'database_info)) \
\		handle _ => (); \
=TEX
Statistics from profiling:
=SML
\	(set_stats (#stats icl'database_info)) \
\		handle _ => (); \
=TEX
Proof context stack:
=SML
\	((#pc_stack icl'database_info) ()) \
\		handle _ => (); \
=TEX
Proof context evaluators:
=SML
\	((#pc_evaluators icl'database_info) ()) \
\		handle _ => (); \
=TEX
Proof context database:
=SML
\	(#pc_database icl'database_info) () \
\		handle _ => (); \
=TEX
Kernel State Change functions:
=SML
\	(#ksc_functions icl'database_info) () \
\		handle _ => (); \
=TEX
Subgoal package:
=SML
\	(#subgoal_package icl'database_info) () \
\		handle _ => (); \
=TEX
End of current state setting:
=SML
\	())"	
)));

val initial2 = Initialisation.new_init_fun init_current_state;
=TEX
Note that we deliberately catch any exceptions in the above.
\subsubsection{Line Length}
Some things such as rs232 lines often claim their line length is 0.
If this happens wie pick 80 rather than 20 as the sensible guess.
=SML
fun €init_line_length› () : unit = (
let	val ll = get_terminal_line_length () - 2;
in
	((if ll = 0
	then set_line_length 80
	else if ll < 20
	then set_line_length 20
	else set_line_length ll);())
end
handle complaint =>
if area_of complaint = "get_terminal_line_length"
then ()
else raise complaint);

val initial3 = Initialisation.new_init_fun init_line_length;
=TEX

\subsubsection{Initialisation Scripts}
=SML		
local
	fun aux acc [] = (if is_nil acc
		then []
		else [implode (rev acc)]
	) | aux acc ("," :: rest) = (
		if is_nil acc
		then aux [] rest
		else (implode(rev acc) :: aux [] rest)
	) | aux acc (a :: rest) = aux (a::acc) rest;
	fun aux1 [] = ()
	| aux1 (a :: x) = (
		((use_file a 
			handle (Io _) => 
			warn "load_scripts" 36012 [fn _ => a])
			handle _ =>
			warn "load_scripts" 36005 [fn _ => a]
		);
		aux1 x);
in		
fun €load_scripts› () : unit = (
let	val source = get_shell_var "hol_initialisation_scripts";
	val scripts = aux [] (explode source);
in
	(aux1 scripts)
end)
end;

val initial4 = Initialisation.new_init_fun load_scripts;
=TEX
Note that we deliberately catch any exceptions in the above.


\subsubsection{System Banner}
=SML
local
	val banner = ref (get_error_message 36000 [system_version]);
	val freeze_banner = ref false;
in

fun €print_banner› () : unit = (
	diag_string (get_error_message 36016 [!banner] )
);

fun €icl'set_banner› (Value (ban:string)) : string = (
let	val old = (!banner);
in
	if (!freeze_banner)
	then fail "icl'set_banner" 36015 []
	else (banner := ban; old)
end)
| icl'set_banner Nil = (freeze_banner := true; (!banner));
end;

val initial5 = Initialisation.new_init_fun print_banner;
=TEX
\subsubsection{Prompt}
=SML
val initial6 = Initialisation.new_init_fun use_terminal;
=TEX
=SML
end; (* of structure HOLSystem *)
open HOLSystem;
end; (* of local defining sos_emdb *);
=TEX

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}
