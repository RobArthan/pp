=IGN
********************************************************************************
imp036.doc: this file is part of the PPHol system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% %Z% 2009/04/21 11:15:21 1.62 imp036.doc,v
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{HOL PDS System Initialisation}  %% Mandatory field
\TPPref{DS/FMU/IED/IMP036}  %% Mandatory field
\def\SCCSversion{1.62%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{2009/04/21 11:15:21%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{ML Literate Script}
\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & FST Team Leader}
\TPPabstract{
This document contains the implementation for the
system initialisation functions.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library\\RDA\\AJH\\DJK}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1]
First draft.
\item[Issue 1.2]
Removed some hangovers from quick document creation.
Added setting of $profiling$ to $false$.
\item [Issue 1.3]
Added $reset\_flag$ $"subgoal\_package\_quiet"$.
\item[Issue 1.4, \FormatDate{92/01/20} ] Updated to use new fonts.
\item [Issue 1.5]
Changes to reflect needs of \cite{DS/FMU/IED/DTD069}.
\item [Issue 1.6]
Added $print\_status$.
\item [Issue 1.7]
Changed save and exit commands.
\item [Issue 1.8 (26th May 1992)]
Renamings from version 1.5 of DS/FMU/IED/WRK038.
\item [Issue 1.9 (26th May 1992)]
Added $use\_terminal$ to initialisation list.
\item [Issue 1.10 (23rd June 1992)]
Removed spurious line in $pp'write\_to\_initialisation\_error\_file$.
\item [Issue 1.11 (29th June 1992)]
Recognise difference between unreadable and unprocessable
initialisation files.
\item [Issue 1.12 (29th June 1992)]
Changed formatting of $print\_status$ line.
\item [Issue 1.13, 1.14, 1.15(13th July 1992)]
Protecting against run-time environment errors.
\item [Issue 1.16 (14th September 1992)]
Swapped order of initialisation functions.
\item [Issue 1.17 (3rd November 1992)]
Improved banner mechanism, lost system version from $print\_status$.
\item [Issue 1.18 (15th December 1992)]
Improved $save\_and\_quit$.
\item [Issue 1.19 (22nd December 1992)]
Moved line length in initialisation functions.
\item [Issue 1.20 (6th January 1993)]
Protecting user from shell error messages.
\item [Issue 1.21,1.22 (11th,12th January 1993)]
Improved start of session error message database resetting.
\item [Issue 1.24 (19th January 1993)]
$save\_and\_quit$ now checks for state being inconsistent.
\item [Issue 1.25-1.26 (7th July 1993)]
Bug 126 fixed.
\item [Issue 1.27 (17th August 1993)]
Added clearing the type compactification cache into $save\_and\_quit$.
\item [Issue 1.28, 1.29 (1st February 1994)]
Changed $exit$ and $save\_and\_exit$ to return the exit status, provided
as an argument, to the calling process. Both functions now have type $int -> unit$.
Added $use\_files\_save\_and\_exit$ to support batch processing of files.
\item [Issue 1.30 (9th May 1994)]
Added the function $save()$ and recoded $save\_and\_quit$ and $save\_and\_exit$ to use it.
\item [Issues 1.31,1.32]
Basic update for NJML.
\item [Issue 1.33,1.34]
Fixed bug in sanitize function.
\item [Issue 1.35]
Rationalised treatment of line lengths, environment variables and initialisation errors.
\item [Issue 1.36]
Now allows for control variables in child databases properly.
\item [Issue 1.37]
Fixed bug in restoring the system controls for a child database.
\item [Issue 1.38]
Made {\it load\_files} print file names containing `Q' properly.
\item[Issue 1.39] Copyright and banner updates for open source release.
\item[Issue 1.40] PPHol-specific updates for open source release
\item[Issue 1.41,1.42] Fix to problems with `Q' in file names.
\item[Issue 1.43] Removed restrictions on setting the banner and introduced a single function to restore the state at start of a session.
\item[Issue 1.44] Now provides {\em get\_init\_funs} and supports {\em new\_init\_fun}  in child databases under Poly/ML).
\item[Issue 1.45] {\em pending\_reset\_ksc\_functions} has been renamed as {\em pending\_reset\_kernel\_interface}.
\item[Issue 1.46] Made it better at reporting exceptions; updated to reflect kernel interface reform.
\item[Issue 1.47] The prefix for private interfaces is now $pp'$ rather than $icl'$.
\item[Issue 1.48] Moved restoring of the current theory forwards.
\item[Issue 1.49] Added $new\_save\_fun$.
\item[Issue 1.50] Initialisation scripts are now run after all the initialisation functions.
\ite[Issue 1.51] Rationalised initial cache theory set-up.
\item[Issues 1.52, 1.54] Initial current theory and initialisation scripts in {\tt pp} are now passed in environment variables with more conventional name (and the theory is opened using {\em use\_string} so that `Q's in the name are handled sensibly).
\item[Issues 1.55, 1.56] Revised interface for initialisation scripts.
\item[Issue 1.62] HACK TO AVOID BRANCH: revert to 1.56 then add code to work around a problem with user-defined readers on Poly/ML 4.1.3.
\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the system initialisation functions.
The detailed design for this material is given in \cite{DS/FMU/IED/DTD036}.
\subsection{Introduction}
\subsection{Dependencies}
\subsection{Algorithms}
\subsection{Possible Enhancements}
\subsection{Deficiencies}
A number of initialisation functions use
=INLINEFT
handle _ =>
=TEX
{} which is a bit crude.
We handle the error message database as follows.
We have a local assignable variable, $sos\_emdb$, which is set to the
start of session state of the error message database.
We then during the start of session add (using $pp'change\_error\_message$)
those messages in the $error\_messages$ field of our private database.

At the end of the session we determine what messages have been
added to the error message database (by using $sos\_emdb$), and record them in
the $error\_messages$ field of our private database.

Thus, because of the behaviour of assignable variables) the $error\_messages$ will no longer contain a particular
message after two saves if in the supplied database,
but if in a child database will remain in $error\_messages$
``forever''.

Because the string comprising a capital Q in between two percent signs
is an SCCS key word, we resort to knowledge of the ASCII character set here.
=SML
=TEX

\section{SYSTEM INITIALISATION}
=SML
structure ÛInitialisationÝ : Initialisation = struct
=TEX
=SML
val Ûinit_funsÝ : (unit -> unit) list ref = ref [];
=TEX
=SML
fun Ûnew_init_funÝ (f : unit -> unit) : unit = (
	init_funs := !init_funs @ [f]
);
=TEX
=SML
fun Ûget_init_funsÝ (() : unit) : (unit -> unit) list = (
	!init_funs
);
=TEX
=SML
val Ûsave_funsÝ : (unit -> unit) list ref = ref [];
=TEX
=SML
fun Ûnew_save_funÝ (f : unit -> unit) : unit = (
	save_funs := !save_funs @ [f]
);
=TEX
=SML
fun Ûget_save_funsÝ (() : unit) : (unit -> unit) list = (
	!save_funs
);
=TEX
=SML		
fun Ûload_scriptsÝ (() : unit) : unit = (
let	fun double_q s = (
		let	fun  aux "\081" = "Q"
			|   aux ch = ch;
		in	implode (map aux(explode s))
		end
	);
	fun aux i = (
		let	val s = ExtendedIO.get_env ("PPINITSCRIPT" ^ string_of_int i);
		in	if	s = ""
			then	()
			else	((((use_file1 s
					handle (Io _) => 
						warn "load_scripts" 36012
							[fn _ => double_q s])
					handle (Fail msg) => 
						warn "load_scripts" 36005
							[fn _ => double_q s, fn _ => get_message msg])
					handle ex =>
						warn "load_scripts" 36005
						[fn _ => double_q s, fn _ => string_of_exn ex]);
				aux (i+1))
		end
	);
in	aux 1
end);
=TEX
=SML
fun Ûprint_exnÝ (Fail mess) = (
	diag_string(get_error_message
		36014 ["Fail",
			(get_message mess)])
) | print_exn (Error mess) = (
	diag_string(get_error_message
		36014 ["Error",
			(get_message mess)])
) | print_exn other = (
	diag_string(get_error_message 
		36014 [string_of_exn other, ""])
);
=TEX
The following is allowing for the possibility of the initialisation functions adding extra initialisations to the list.
This happens, for example, when the initialisation functions are restored in {\em pp'reset\_database\_info}.

=SML
fun ÛinitÝ (() : unit) : unit = (
	let	val fs1 = !init_funs;
		fun go [] = ()
		|   go (f::fs) = (
			(f() handle ex => print_exn ex);
			go fs
		);
		val _ = go fs1;
		val fs2 = !init_funs from length fs1;
		val _ = go fs2;
		val _ = load_scripts();
	in	()
	end
);
=TEX
The following type and associated bindings is not really necessary
for NJML, but we retain it since there may be useful special
effects that can be obtained with it in the future.
=SML
type ÛICL'DATABASE_INFO_TYPEÝ = {
	theory : string,
	cache_theories : string list,
	control_state : unit -> unit,
	controls : ((string * bool) list * 
		(string * int) list * 
		(string * string) list),
	error_messages : unit -> unit,
	stats : int S_DICT,
	pc_stack : unit -> unit,
	pc_database : unit -> unit,
	pc_evaluators : unit -> unit,
	kernel_interface : unit -> unit,
	subgoal_package : unit -> unit,
	init_fun_state : (unit -> unit) list,
	save_fun_state : (unit -> unit) list
};
=TEX
Make a good starting point for the creation of cache theories in child databases.
=SML
val _ = set_cache_theories ["basic_hol"];
=TEX
Make it start up with theory hol current.
=SML
val _ = open_theory "basic_hol";
val _ = reset_controls();
=TEX
=SML
val Ûpp'theory_hierarchyÝ: pp'Kernel.pp'HIERARCHY OPT = Nil;
val Ûpp'database_infoÝ : ICL'DATABASE_INFO_TYPE = { 
	theory = get_current_theory_name(), 
	cache_theories = get_cache_theories(),
	control_state = pending_reset_control_state(),
	controls = get_controls (), 
	error_messages = pending_reset_error_messages(), 
	stats = get_stats (), 
	pc_stack = pending_reset_pc_stack(), 
	pc_database = pending_reset_pc_database(), 
	pc_evaluators = pending_reset_pc_evaluators(), 
	kernel_interface = pending_reset_kernel_interface(), 
	subgoal_package = pending_reset_subgoal_package(),
	init_fun_state = !init_funs,
	save_fun_state = !save_funs 
};
=TEX
=SML
fun Ûpp'set_database_infoÝ ():unit = (use_string (" \
\PPCompiler.print_depth 0; \
\  val pp'database_info : Initialisation.ICL'DATABASE_INFO_TYPE = { \
\  theory = get_current_theory_name(), \
\  cache_theories = get_cache_theories(), \
\  control_state = pending_reset_control_state(), \
\  controls = get_controls(), \
\  error_messages = pending_reset_error_messages(), \
\  stats = get_stats(), \
\  pc_stack = pending_reset_pc_stack(), \
\  pc_database = pending_reset_pc_database(), \
\  pc_evaluators = pending_reset_pc_evaluators(), \
\  kernel_interface = pending_reset_kernel_interface(), \
\  subgoal_package = pending_reset_subgoal_package(), \
\  init_fun_state = Initialisation.get_init_funs(), \
\  save_fun_state = Initialisation.get_save_funs() \
\  }; \
\ PPCompiler.print_depth 999;");
	()
);
=TEX
In the following it is important to reset the kernel interface before doing anything that might call a kernel interface function (i.e., almost anything, so do it first!).

=SML
fun Ûpp'reset_database_infoÝ
	(do_current_theory : bool)
	({	theory, 
		cache_theories,
		control_state,
		controls, 
		error_messages,
		stats, 
		pc_stack, 
		pc_database, 
		pc_evaluators, 
		kernel_interface, 
		subgoal_package,
		init_fun_state,
		save_fun_state} : ICL'DATABASE_INFO_TYPE) : unit = (
	(kernel_interface () handle ex => print_exn ex);
	(if	do_current_theory
	 then	open_theory theory handle ex => print_exn ex
	 else	());
	(set_cache_theories cache_theories; ()) handle ex => print_exn ex;
	(control_state () handle ex => print_exn ex);
	(set_controls controls handle ex => print_exn ex);
	(error_messages () handle ex => print_exn ex);
	(set_stats stats handle ex => print_exn ex);
	(pc_stack () handle ex => print_exn ex);
	(pc_evaluators () handle ex => print_exn ex);
	(pc_database () handle ex => print_exn ex);
	(subgoal_package () handle ex => print_exn ex);
	(init_funs := init_fun_state);
	(save_funs := save_fun_state);
	()
);
=TEX
=SML
end; (* of structure Initialisation *)
=TEX
We now wish to expose $pp'database_info$ and $pp'theory\_hierarchy$.
=SML
val Ûpp'database_infoÝ = Initialisation.pp'database_info;
val Ûpp'theory_hierarchyÝ = Initialisation.pp'theory_hierarchy;
=TEX
\section{USER INTERFACES}
=SML
structure ÛHOLSystemÝ : HOLSystem = struct
=TEX
The following turns off profiling, so that though the system build
is profiled automatically, any further profiling must be
requested.
=SML
val side_effect3 = set_flag("profiling",false);
=TEX
The following sets the subgoal package ``quietness'' to its default (``noisy'').
This means that if the switch is quiet from its point of creation then
no subgoal pacage material will arrive in the log.
=SML
val side_effect4 = reset_flag "subgoal_package_quiet";
=TEX
To have the initialisation functions called appropriately, we use a stream
to detect whether or not the return from the $PolyML.commit$ is in the same
session or the new one. This works because in the new session the stream
will have become closed.
=SML

fun ÛquitÝ (():unit) : unit = ((
let	val resp = ask_at_terminal (get_error_message 36001 ["quit"]);
in
	if resp = "y\n"
	then PPCompiler.exit 0
	else diag_line (get_error_message 36011 [])
end)
handle complaint =>
if area_of complaint = "ask_at_terminal"
then PPCompiler.exit 0
else raise complaint);

fun ÛexitÝ (ret : int) : unit = ((
let	val resp = ask_at_terminal (get_error_message 36001 ["exit"]);
in
	if resp = "y\n"
	then PPCompiler.exit ret
	else diag_line (get_error_message 36018 [])
end)
handle complaint =>
if area_of complaint = "ask_at_terminal"
then PPCompiler.exit ret
else raise complaint);
=TEX
=SML
fun ÛsaveÝ (() : unit) : bool = (
let	val dummy = if valid_thm bool_cases_axiom
		then ()
		else error "save" 36017 [];
	val _ = app (fn f => f()) (Initialisation.get_save_funs()); 
	val side_effect = clear_compactification_cache();
	val reset = Initialisation.pp'set_database_info();
in	if PPBuild.pp'save()
	then	true	(* same session *)
	else	(Initialisation.init(); false) (* new session *)
end);
=TEX
=SML
fun Ûsave_and_exitÝ (ret : int) : unit = (
	if save ()
	then	PPCompiler.exit ret	(* same session *)
	else	()			(* new session *)
);
=TEX
=SML
fun Ûsave_and_quitÝ (() : unit) : unit = (
	save_and_exit 0
);
=TEX
=SML
fun Ûload_filesÝ (filelist : string list) : bool = (
let	fun do_file (file : string) (last_one : bool) : bool = (
	let	val last_one_msg = if last_one then
				get_error_message 36024 []
				else "";
	in
		(
			use_file file;
			raw_diag_line(get_error_message 36021 [
				translate_for_output file,
				get_error_message 36022 [],
				last_one_msg
				]);
			true
		)
		handle ex => (
			(case ex of
				Io _ =>  warn "load_files" 36012 [fn _ => file]
			|	Fail msg => warn "load_files" 36005
					[fn _ => file, fn _ => get_message msg]
			|	ReaderWriterSupport.Stop => ()
			|	_ => warn "load_files" 36005
					[fn _ => file, fn _ => string_of_exn ex]);
			raw_diag_line(get_error_message 36021 [
				translate_for_output file,
				get_error_message 36023 [],
				last_one_msg
				]);
			false
		)
	end);
	fun do_file_list (f1::f2::rest) : bool = (
		do_file f1 false andalso do_file_list (f2::rest)
	) | do_file_list [f1] = (
		do_file f1 true
	) | do_file_list [] = true;
in
	do_file_list filelist
end);
=TEX

=SML

fun Ûprint_statusÝ () : unit = (
	map (fn x => diag_string(x ^";"))
	[get_error_message 36006 [get_current_theory_name()],
	get_error_message 36007 [
		format_list (Combinators.I) (fst(get_current_pc())) ", "],
	(get_error_message 36009 [string_of_int(length (top_goals()))]
		handle (Fail _) => 
		get_error_message 30010 [])];
	diag_string(
	(get_error_message 36008 [top_current_label()]
		handle (Fail _) => 
		get_error_message 30026 []) ^ ".")
);
=TEX

=SML
val Ûget_shell_varÝ : string -> string = ExtendedIO.get_env;
=TEX

\subsection{Initialisation Steps}
\subsubsection{Theory Hierarchy}
=SML
fun Ûinit_theory_hierarchyÝ () : unit = (
	use_string(
	"case (pp'theory_hierarchy) of " ^
	"Value th => pp'Kernel.pp'load_hierarchy th " ^
	"| Nil => ();")
	handle _ => ()
);

val _ = Initialisation.new_init_fun init_theory_hierarchy;
=TEX
Note that we deliberately catch any exceptions in the above.

\subsubsection{Current State}
=SML
=TEX
Then the function proper:
=SML
fun Ûinit_current_stateÝ () : unit = (
	(case get_shell_var "PPINITCURRENTTHEORY" of
	"" => (
		use_string
		"Initialisation.pp'reset_database_info true pp'database_info;"
	) | hct => (
		use_string
	(	"Initialisation.pp'reset_database_info false pp'database_info;\
\\	\\	\open_theory \"" ^ hct ^ "\"")
		handle (Fail msg) => (	diag_line(get_message msg);
			output(ExtendedIO.std_err,
				get_error_message 36002 [hct] ^ "\n");
			PPCompiler.exit 1
		) | _ => (
			output(ExtendedIO.std_err,
				get_error_message 36002 [hct] ^ "\n");
			ExtendedIO.flush_out ExtendedIO.std_err;
			PPCompiler.exit 1
		)
	));
	()
);
val _ = Initialisation.new_init_fun init_current_state;
=TEX
Note that we deliberately catch any exceptions in the above.
\subsubsection{Line Length}
Some things such as rs232 lines often claim their line length is 0.
If this happens wie pick 80 rather than 20 as the sensible guess.
=SML
fun Ûinit_line_lengthÝ () : unit = (
let	val ll = nat_of_string(get_shell_var "PPLINELENGTH")
		handle Fail _ => 80;
in
	((if ll = 0
	then set_line_length 80
	else if ll < 20
	then set_line_length 20
	else set_line_length ll);())
end);

val _ = Initialisation.new_init_fun init_line_length;
=TEX
=TEX
Note that we deliberately catch any exceptions in the above.


\subsubsection{System Banner}
=SML
fun Ûdefault_bannerÝ (():unit) : string = (
	get_error_message 36000 [system_version]
);
=TEX
=SML
val Ûsystem_bannerÝ : string ref = ref (default_banner());
=TEX
=SML
val _ = new_string_control {
	name = "system_banner",
	check = fun_true,
	control = system_banner,
	default = default_banner
} handle Fail _ => ();
=TEX
=SML
val Ûuser_bannerÝ : string ref = ref "";
=TEX
=SML
val _ = new_string_control {
	name = "user_banner",
	check = fun_true,
	control = user_banner,
	default = fn () => ""
} handle Fail _ => ();
=TEX
=SML
fun Ûprint_bannerÝ () : unit = (
	diag_string (get_error_message 36016 [!system_banner, !user_banner] )
);
=TEX
=SML
fun Ûpp'set_bannerÝ (Value (ban:string)) : string = (
	set_string_control("system_banner", ban)
) | pp'set_banner Nil = !system_banner;
=TEX
=SML
val _ = Initialisation.new_init_fun print_banner;
=TEX
\subsection{Control of Garbage Collector Messages}
With SML/NJ, we have to tell the garbage collector what to do at the start of
each session. Hence we need an initialisation function to remember the state.

=SML
local
	val gc_message_flag : bool ref = ref false;
	fun check_gc_flag (new : bool) : bool = (
		PPCompiler.gc_messages new;
		true
	);
	val _ = new_flag{
		name = "gc_messages",
		check = check_gc_flag,
		control = gc_message_flag,
		default = fn _ => false} handle Fail _ => ();
	fun init_gc_messages () : unit = (
		PPCompiler.gc_messages (!gc_message_flag)
	);
in
	val _ = Initialisation.new_init_fun init_gc_messages;
end;
=TEX
\subsubsection{Prompt}
=SML
val _ = Initialisation.new_init_fun use_terminal;
=TEX
=SML
end (* of structure HOLSystem *);
open HOLSystem;
=TEX
The following makes user-defined readers reinstall themselves on system start-up. This is not necessary in Poly/ML 5.X.
=SML
structure ReaderWriterSupport : ReaderWriterSupport = struct
	fun now_and_on_start_up (f : 'a -> unit) (x : 'a ) : unit = (
		let	fun init_fun () = (
				f x handle Fail _ => ()
			);
		in	Initialisation.new_init_fun init_fun;
			f x
		end
	);
	open ReaderWriterSupport;
	structure PrettyNames = struct
		open PrettyNames;
		val add_new_symbols = now_and_on_start_up add_new_symbols;
	end (* of structure PrettyNames *);

	val add_general_reader = now_and_on_start_up add_general_reader;
	val add_specific_reader = now_and_on_start_up add_specific_reader;
	val add_named_reader = now_and_on_start_up add_named_reader;
end (* of structure ReaderWriterSupport *);

=TEX

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}
