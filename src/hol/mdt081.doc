=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Algebraic Normalisation Conversions}  %% Mandatory field
\TPPref{DS/FMU/IED/MDT081}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthors{R.D.~Arthan & WIN01\\K.~Blackburn & WIN01}
\TPPauthorisation{R.B.~Jones & FMU Manager}
\TPPabstract{This document defines
various normalisation procedures and
associated utilities (such as an ordering function
for HOL terms).}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item[\SCCSversion~(\FormatDate{$Date$%}
)]]
First draft.
\end{description}
\subsection{Changes forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains module tests for the module defined 
in \cite{DS/FMU/IED/DTD081}.
\subsection{Introduction}
\subsubsection{Background and Purpose}
See \cite{DS/FMU/IED/DTD081}. The tests are intended to meet
the requirements for module tests identified in the quality plan
\cite{DS/FMU/IED/PLN008}.
\subsubsection{Dependencies}
These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Deficiencies}
None known.
\section{PREAMBLE}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
=TEX
\section{TEST CASES}
There are 7 groups of tests as follows:

\begin{description}
\item[1]
Ordering functions (there are no error cases for these)
\item[2]
Asymmetric equational reasoning (successful and error cases)
\item[3]
Monomial and polynomial normalisation: parameter validation
\item[4]
Monomial normalisation: correct operation
\item[5]
Polynomial normalisation: correct operation
\item[6]
Conjunctive and disjunctive normalisation (there are no error cases for these)
\item[7]
Additive normalisation (there are no error cases for these)
\end{description}

\section{THE TESTS}
\subsection{Group 1}
Ordering functions (there are no error cases for these)
=SML
store_mt_results_show (mt_runf (fn (i, j) => (i = 0 andalso j = 0) orelse i*j > 0)) [
	("Normalisation.1.1.1", uncurry type_order, (¬:'a®, ¬:'b®), ~1),
	("Normalisation.1.1.2", uncurry type_order, (¬:'b®, ¬:'a®), 1),
	("Normalisation.1.1.3", uncurry type_order, (¬:î + î®, ¬:î + î®), 0),
	("Normalisation.1.1.4", uncurry type_order, (¬:î + î®, ¬:'a®), 1)
];
=TEX
=SML
fun spec (t: TERM) : TERM * int = (
	let val i = dest_î t
	in (¬0®, if i mod 2 = 0 then i else ~i)
	end handle Fail _ => (t, 0)
);
=TEX
=SML
store_mt_results_show (mt_runf (fn (i, j) => (i = 0 andalso j = 0) orelse i*j > 0)) [
	("Normalisation.1.2.1", uncurry (gen_term_order spec), (¬1®, ¬0®), ~1),
	("Normalisation.1.2.2", uncurry (gen_term_order spec), (¬2®, ¬4®), ~1),
	("Normalisation.1.2.3", uncurry (gen_term_order spec), (¬5®, ¬3®), ~1)
];
=SML
store_mt_results_show (mt_runf (fn (i, j) => (i = 0 andalso j = 0) orelse i*j > 0)) [
	("Normalisation.1.3.1", uncurry term_order, (¬a®, ¬b®), ~1),
	("Normalisation.1.3.2", uncurry term_order, (¬a®, ¬a®), 0),
	("Normalisation.1.3.3", uncurry term_order, (¬b®, ¬a®), 1),
	("Normalisation.1.3.4", uncurry term_order, (¬a*b®, ¬a®), 1),
	("Normalisation.1.3.5", uncurry term_order, (¬³a®, ¬a®), 1),
	("Normalisation.1.3.6", uncurry term_order, (¬a®, ¬0*a®), ~1),
	("Normalisation.1.3.7", uncurry term_order, (¬12*a®, ¬99*a®), ~1)
];
=TEX
\subsection{Group 2}
Asymmetric equational reasoning (successful and error cases)
=SML
store_mt_results_show mt_run [
	("Normalisation.2.1.1", fn t => (ASYM_C plus_conv t; true), ¬1+2®, true),
	("Normalisation.2.1.2", fn t => (GEN_ASYM_C term_order plus_conv t; true) ,¬3+4®, true)
];
=TEX
=SML
store_mt_results_show mt_run_fail [
	("Normalisation.2.2.1", ASYM_C suc_conv, ¬1®, gen_fail_msg"GEN_ASYM_C" 81010 []),
	("Normalisation.2.2.2", GEN_ASYM_C term_order (fn _ =>bool_cases_axiom),
		¬1®, gen_fail_msg"GEN_ASYM_C" 81011
		[string_of_term¬1®, string_of_term(concl bool_cases_axiom)])
];
=TEX
\subsection{Group 3}
Monomial and polynomial normalisation: parameter validation.
=SML
store_mt_results_show mt_run_fail [
	("Normalisation.3.1.1", uncurry (sort_conv term_order),
		(bool_cases_axiom, bool_cases_axiom),
		gen_fail_msg"sort_conv" 81021 [string_of_thm bool_cases_axiom]),
	("Normalisation.3.1.2", uncurry (sort_conv term_order),
		(times_comm_thm, times_comm_thm),
		gen_fail_msg"sort_conv" 81022 [string_of_thm (all_µ_elim times_comm_thm)])
];
=TEX
=SML
val Ûdistrib_thmÝ =
	all_µ_intro(±_right_elim(all_µ_elim times_plus_distrib_thm));
=SML
store_mt_results_show mt_run_fail [
	("Normalisation.3.2.1", uncurry(uncurry (poly_conv term_order plus_comm_thm plus_assoc_thm)),
		((times_comm_thm, times_comm_thm), distrib_thm),
		gen_fail_msg"poly_conv" 81022 [string_of_thm (all_µ_elim times_comm_thm)]),
	("Normalisation.3.2.2", uncurry(uncurry (poly_conv term_order plus_comm_thm plus_assoc_thm)),
		((times_comm_thm, times_assoc_thm), times_assoc_thm),
		gen_fail_msg"poly_conv" 81023 [string_of_thm (all_µ_elim times_assoc_thm)])
];
=TEX
\subsection{Group 4}
Monomial normalisation: correct operation
=SML
fun Ûmy_conclÝ (thm : THM) : TERM = (
	case dest_thm thm of
		([], tm) => tm
	|	_ => fail "mdt081" 99999 []
);
=TEX
=SML
store_mt_results_show (mt_runf (op ~=$))[
	("Normalisation.4.1.1",
	my_concl o sort_conv term_order
		plus_comm_thm plus_assoc_thm fail_conv fail_conv,
		¬3+1+2®, ¬3+1+2=1+2+3®),
	("Normalisation.4.1.2",
	my_concl o sort_conv term_order
		plus_comm_thm plus_assoc_thm fail_conv suc_conv,
		¬3+1+2®, ¬3+1+2=Suc 0+Suc 1+Suc 2®),
	("Normalisation.4.1.3",
	my_concl o sort_conv term_order
		plus_comm_thm plus_assoc_thm plus_conv fail_conv,
		¬3+1+2®, ¬3+1+2=6®)
];
=TEX

\subsection{Group 5}
Polynomial normalisation: correct operation
=SML
store_mt_results_show (mt_runf (op ~=$))[
	("Normalisation.5.1.1",
	my_concl o poly_conv term_order
		plus_comm_thm plus_assoc_thm times_comm_thm times_assoc_thm
		distrib_thm fail_conv fail_conv fail_conv,
		¬(x+y)*(y+x)®, ¬(x+y)*(y+x) = x*x + x*y + x*y + y*y®),
	("Normalisation.5.1.2",
	my_concl o poly_conv term_order
		plus_comm_thm plus_assoc_thm times_comm_thm times_assoc_thm
		distrib_thm fail_conv times_conv fail_conv,
		¬(1+2)*(3+4)®, ¬(1+2)*(3+4) = 3 + 4 + 6 + 8®),
	("Normalisation.5.1.3",
	my_concl o poly_conv term_order
		plus_comm_thm plus_assoc_thm times_comm_thm times_assoc_thm
		distrib_thm fail_conv times_conv
		(COND_C (fn t => dest_î t > 1) plus1_conv fail_conv),
		¬(1+2)*2®, ¬(1+2)*2 = 1 + 1 + 1 + 1 + 1 + 1®)
];
=TEX
\subsection{Group 6}
Conjunctive and disjunctive normalisation (there are no error cases for these)
=SML
store_mt_results_show (mt_runf (op ~=$))[
	("Normalisation.6.1.1", my_concl o cnf_conv,
		¬(b ± a) ² c®, ¬(b ± a) ² c ¤ (a ² c) ± (b ² c)®),
	("Normalisation.6.1.2", my_concl o cnf_conv,
		¬a ´ b®, ¬a ´ b ¤ ³a ² b®),
	("Normalisation.6.1.3", my_concl o cnf_conv,
		¬if a then b else (c:BOOL)®,
		¬(if a then b else (c:BOOL)) ¤ (a ² c) ± (³a ² b) ± (b ² c)®)
];
=TEX
=SML
store_mt_results_show (mt_runf (op ~=$))[
	("Normalisation.6.2.1", my_concl o dnf_conv,
		¬(b ² a) ± c®, ¬(b ² a) ± c ¤ (a ± c) ² (b ± c)®),
	("Normalisation.6.2.2", my_concl o dnf_conv,
		¬a ´ b®, ¬a ´ b ¤ ³a ² b®),
	("Normalisation.6.2.3", my_concl o dnf_conv,
		¬if a then b else (c:BOOL)®,
		¬(if a then b else (c:BOOL)) ¤ (a ± b) ² (³a ± c)®)
];
=TEX
\subsection{Group 7}
Additive normalisation (there are no error cases for these)
=SML
store_mt_results_show (mt_runf (op ~=$))[
	("Normalisation.7.2.1", my_concl o anf_conv,
		¬3+1+2+x+4+y®, ¬3+1+2+x+4+y = 10 + x + y®),
	("Normalisation.7.2.2", my_concl o anf_conv,
		¬(1+2+3)*(x+1)®, ¬(1+2+3)*(x+1) = 6 + 6*x®),
	("Normalisation.7.2.3", my_concl o ANF_C(pure_rewrite_conv[minus_clauses]),
		¬(x - 0)*((x + y) - y)®, ¬(x - 0)*((x + y) - y) = x*x®)
];
=TEX
\section{SUMMARY OF RESULTS}
=SML
diag_string(summarize_mt_results());
=TEX

\end{document}

