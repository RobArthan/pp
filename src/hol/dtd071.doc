%  %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}
\TPPtitle{Detailed Design for the Theory of Relations}
\def\TPPheadtitle{Detailed Design for the \cr
Theory of Relations}
\TPPref{DS/FMU/IED/DTD071}
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}
\def\SCCSdate{\FormatDate{$Date$%
}}
\TPPdate{\SCCSdate}
\TPPstatus{Draft}
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.B.Jones & WIN01}
%\TPPauthors{R.D. Arthan & WIN01\\K. Blackburn & WIN01}
\TPPauthorisation{R.D. Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
theory of (binary) relations viewed as sets of pairs.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{center}
\bf Copyright \copyright\ : International Computers Ltd 1992
\end{center}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item[Issue 1.6 (\FormatDate{92/06/02})]
This is the first draft of the document.

\item[Issue 1.7 (\FormatDate{92/06/10})]
Revised in the light of comments received.

\item[Issue 1.8 - 1.10]
Added more comprehensive list of theorems and corrected miscellanea.
\item[Issue 1.11 (24th June 1992)]
Removed unproven theorem from signature.

\item[\FormatDate{$Date$%
}, issue \SCCSversion~]
	Add indexing characters.
	Add $bin\_rel\_ext\_clauses$ theorem.

%\item[\FormatDate{$Date$%
%}, issue \SCCSversion~]

\end{description}

\subsection{Changes Forecast}
More theorems and proof contexts.

\section{GENERAL}
\subsection{Scope}
This document contains a detailed design
for the theory ``bin\_rel''.
The design is implemented in \cite{DS/FMU/IED/IMP071}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the detailed design for the theory ``$bin\_rel$''.

\subsubsection{Dependencies}
This document depends on \cite{DS/FMU/IED/IMP044}, and the theory design tools of \cite{DS/FMU/IED/DTD035}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
\section{THE THEORY ``$bin\_rel$''}
\subsection{Design of the theory ``relation''}
\subsubsection{Preamble}
=THDOC
set_flag("tc_thms_only", true);
=DESCRIBE
We set the theorem check only flag since the definitions in the theory are
to be made via constant specification boxes.
=ENDDOC
=THDOC
req_name Û"bin_rel"İ (Value "hol");
=DESCRIBE
The theory ``$bin\_rel$'' contains the definitions of various operators upon sets of pairs and proves theorems relating to these for use in proof contexts.
=ENDDOC
=SML
val _ = open_theory "hol";
val _ = push_pc "basic_hol";
val _ = new_theory "bin_rel";
=TEX
The definition of the maplet symbol $"í"$ and type abbreviations $``ğ''$ and $``ª''$ are included to give a Z-like syntax:
=SML
val _ = declare_type_abbrev(Û"ğ"İ, ["'a"], ¬:('a)SET®);
val _ = declare_infix(240, "ª");
val _ = declare_type_abbrev(Û"ª"İ, ["'a","'b"], ¬:('a ¸ 'b)ğ®);
val _ = declare_infix(300, "í");
¹HOLCONST
Ü
Ü	$Ûíİ:'a ­ 'b ­ 'a ¸ 'b
÷üüüüüüüüüüüüüüüüüüü
Ü	$í = $,
Ü
°
The HOL constant $¸$ is the cartesian product constructor.
¹HOLCONST
Ü
Ü	$Û¸İ:'a ğ ­ 'b ğ ­ ('a ª 'b)
÷üüüüüüüüüüüüüüüüüüü
Ü	µ (x : 'a ğ) (y : 'b ğ)
Ü	· (x ¸ y) = {(v,w) | v  x ± w  y}
Ü
°
The HOL constant $Ûªİ$ is relation constructor.

¹HOLCONST
Ü
Ü	$Ûªİ:'a ğ ­ 'b ğ ­ ('a ª 'b) ğ
÷üüüüüüüüüüüüüüüüüüü
Ü	µ (x : 'a ğ) (y : 'b ğ)
Ü	· (x ª y) = ğ(x ¸ y)
Ü
°
The HOL constant $Dom$ is the function giving the domain of a relation.
¹HOLCONST
Ü
Ü	ÛDomİ:('a ª 'b) ­ ('a)ğ
÷üüüüüüüüüüüüüüüüüüü
Ü	µ (r : ('a ª 'b))
Ü	· Dom r = {x | ¶y · (x, y)  r}
Ü
°
The HOL constant $ÛRanİ$ is the function giving the range of a relation.
¹HOLCONST
Ü
Ü	ÛRanİ:('a ª 'b) ­ ('b)ğ
÷üüüüüüüüüüüüüüüüüüü
Ü	µ (r : ('a ª 'b))
Ü	· Ran r = {y | ¶x · (x, y)  r}
Ü
°
Given a set $a$, then ``$Id\,a$'' is the identity relation on $a$.
¹HOLCONST
Ü
Ü	ÛIdİ:('a)ğ ­ ('a ª 'a)
÷üüüüüüüüüüüüüüüüüüü
Ü	µ (s : ('a)ğ)
Ü	·  Id s = {(x, y) | x = y ± x  s}
Ü
°
$Graph$ converts an HOL function into the corresponding relation.

¹HOLCONST
Ü
Ü	ÛGraphİ:('a ­ 'b)­ ('a ª 'b)
÷üüüüüüüüüüüüüüüüüüü
Ü	µ f : 'a ­ 'b
Ü	·  Graph f = {(x, y) | y = f x}
Ü
°
=SML
val _ = declare_infix(240, "»");
¹HOLCONST
Ü	$Û»İ:('a ­ 'b) ­ ('b ­ 'c) ­ ('a ­ 'c)
÷üüüüüüüüüüüüüüüüüüü
Ü	µ (f:'a ­ 'b) (g:'b ­ 'c) · f » g = g o f
°
=SML
val _ = declare_infix(240, "R_»_R");
¹HOLCONST
Ü
Ü	$ÛR_»_Rİ:('a ª 'b) ­ ('b ª 'c) ­ ('a ª 'c)
÷üüüüüüüüüüüüüüüüüüü
Ü	µ r s · r R_»_R s =
Ü	{(x,z)|¶y· (x,y)  r ± (y,z)  s}
°
We make $»$ an alias of $R\_»\_R$ to make the syntax more Z-like:
=SML
val _ = declare_alias(Û"»"İ,¬$R_»_R®);
=TEX
=SML
val _ = declare_infix(240, "R_o_R");
¹HOLCONST
Ü	$ÛR_o_Rİ:('b ª 'c) ­ ('a ª 'b) ­ ('a ª 'c)
÷üüüüüüüüüüüüüüüüüüü
Ü	µ r s · r R_o_R s = s R_»_R r
°
=SML
val _ = declare_alias(Û"o"İ,¬$R_o_R®);

=TEX
=SML
val _ = declare_infix(240,"ò");

¹HOLCONST
Ü	$Ûòİ:('a)ğ ­ ('a ª 'b) ­ ('a ª 'b)
÷üüüüüüüüüüüüüüüüüüü
Ü	µ a r · a ò r = {(x,y)| x  a ± (x,y)  r}
°
=SML
val _ = declare_infix(240,"á");
=SML
val _ = declare_infix(240,"’");
¹HOLCONST
Ü	$Û’İ:('a ª 'b) ­ ('b)ğ ­ ('a ª 'b)
÷üüüüüüüüüüüüüüüüüüü
Ü	µ a r · r ’ a = {(x,y)| y  a ± (x,y)  r}
°
=SML
val _ = declare_infix(240,"á");

¹HOLCONST
Ü	$Ûáİ:('a)ğ ­ ('a ª 'b) ­ ('a ª 'b)
÷üüüüüüüüüüüüüüüüüüü
Ü	µ a r · a á r = {(x,y)| ³ x  a ± (x,y)  r}
°
=SML
val _ = declare_infix(240,"");
¹HOLCONST
Ü	$Ûİ:('a ª 'b) ­ ('b)ğ ­ ('a ª 'b)
÷üüüüüüüüüüüüüüüüüüü
Ü	µ a r · r  a = {(x,y)| ³ y  a ± (x,y)  r}
°
¹HOLCONST
Ü	$ÛInvRelİ:('a ª 'b) ­ ('b ª 'a)
÷üüüüüüüüüüüüüüüüüüü
Ü	µ r · InvRel r = {(x,y)| (y,x)  r}
°
Again to look like Z, we use an alias:
=SML
val _ = declare_alias(Û"ç~ê"İ,¬InvRel®);
val _ = declare_postfix(300,"ç~ê");
=TEX
$Image$ is the relational image operation, written, rather
unpleasantly, as $\_¨\_©$ in Z.
=SML
val _ = declare_infix(280,"Image");
¹HOLCONST
Ü	$ÛImageİ:('a ª 'b) ­ ('a)ğ ­ ('b)ğ
÷üüüüüüüüüüüüüüüüüüü
Ü	µ r s · r Image s = {y| ¶x· x  s ± (x, y)  r}
°
The following definitions of useful properties of relations are not
given in the Z library, but give a more readable way of defining
the closure operators and the various function-space arrows.
¹HOLCONST
Ü	$ÛReflexiveİ:('a ª 'a) ğ
÷üüüüüüüüüüüüüüüüüüü
Ü	Reflexive = {r | µx· (x, x)  r}
°
¹HOLCONST
Ü	$ÛSymmetricİ:('a ª 'a) ğ
÷üüüüüüüüüüüüüüüüüüü
Ü	Symmetric = {r | µx y· (x, y)  r ´ (y, x)  r}
°
¹HOLCONST
Ü	$ÛTransitiveİ:('a ª 'a) ğ
÷üüüüüüüüüüüüüüüüüüü
Ü	Transitive = {r | µx y z· (x, y)  r ± (y, z)  r ´ (x, z)  r}
°
¹HOLCONST
Ü	$ÛInjectiveİ:('a ª 'b) ğ
÷üüüüüüüüüüüüüüüüüüü
Ü	Injective = {r | µx y; z· (x, z)  r ± (y, z)  r ´ x = y}
°
¹HOLCONST
Ü	$ÛSurjectiveİ:('a ª 'b) ğ
÷üüüüüüüüüüüüüüüüüüü
Ü	Surjective = {r | µz· ¶x· (x, z)  r}
°
¹HOLCONST
Ü	$ÛTotalİ:('a ª 'b) ğ
÷üüüüüüüüüüüüüüüüüüü
Ü	Total = {r | µx· ¶z· (x, z)  r}
°
¹HOLCONST
Ü	$ÛFunctionalİ:('a ª 'b) ğ
÷üüüüüüüüüüüüüüüüüüü
Ü	Functional = {r | µx; w z· (x, w)  r ± (x, z)  r ´ w = z}
°

The semicolon in the above is a hint that $w$ and $z$ are of
the same type which is different to the type of $z$.
 
=SML
val _ = declare_infix(240,"«");
¹HOLCONST
Ü	$Û«İ:('a ª 'b) ­ ('a ª 'b) ­ ('a ª 'b)
÷üüüüüüüüüüüüüüüüüüü
Ü	µ r s · r « s = ((Dom s) á r) À s
°
=SML
val _ = declare_postfix(300,"ç+ê");
¹HOLCONST
Ü	$Ûç+êİ:('a ª 'a) ­ ('a ª 'a)
÷üüüüüüüüüüüüüüüüüüü
Ü	µ r · r ç+ê = ¥{q | r € q ± q  Transitive}
°
=SML
val _ = declare_postfix(300,"ç*ê");
¹HOLCONST
Ü	$Ûç*êİ:('a ª 'a) ­ ('a ª 'a)
÷üüüüüüüüüüüüüüüüüüü
Ü	µ r ·
Ü	r ç*ê = ¥{q | r € q ± q  Reflexive ± q  Transitive}
°

¹HOLCONST
Ü	$ÛRelCombineİ:('a ª 'b) ­ ('a ª 'c) ­ ('a ª ('b ¸ 'c))
÷üüüüüüüüüüüüüüüüüüü
Ü	µ f g · RelCombine f g 
Ü	= {(x, (y,z)) | (x,y)  f ± (x,z)  g}
°

\subsection{Theorems}


=THDOC
req_thm("rel__in_clauses",([],
¬
µ	a : 'a SET; b : 'b SET;
	x x1 :'a; y : 'b; z : 'c;
	r  r1 r2 : 'a ª 'b; s : 'b ª 'c; t : 'a ª 'c;	q : 'a ª 'a;
	f:'a ­ 'b
·
		(x í y  r ¤ (x, y)  r)
	±	((x, y)  (a ¸ b) ¤ x  a ± y  b)
	±	(r  (a ª b) ¤ r € (a ¸ b))
	±	(x  Dom r ¤ ¶y· (x, y)  r)
	±	(y  Ran r ¤ ¶x· (x, y)  r)
	±	((x, x1)  Id a ¤ x  a ± x = x1)
	±	((x, y)  Graph f ¤ y = f x)
	±	((x, z)  r R_»_R s ¤ ¶y· (x, y)  r ± (y, z)  s)
	±	((x, z)  (s R_o_R r) ¤ (x, z)  r R_»_R s)
	±	((x, y)  a ò r ¤ (x, y)  r ± x  a)
	±	((x, y)  r ’ b ¤ (x, y)  r ± y  b)
	±	((x, y)  a á r ¤ (x, y)  r ± ³x  a)
	±	((x, y)  r  b ¤ (x, y)  r ± ³y  b)
	±	((y, x)  InvRel r ¤ (x, y)  r)
	±	(y  r Image a ¤ ¶x· (x, y)  r ± x  a)
	±	(q  Reflexive ¤ µx·(x, x)  q)
	±	(q  Symmetric ¤ µx1 x2·(x1, x2)  q ´ (x2, x1)  q)
	±	(q  Transitive ¤
			µx1 x2 x3·(x1, x2)  q ± (x2, x3)  q ´ (x1, x3)  q)
	±	(r  Injective ¤ µx1 x2 y·(x1, y)  r ± (x2, y)  r ´ x1 = x2)
	±	(r  Surjective ¤ µy·¶x·(x, y)  r)
	±	(r  Total ¤ µx·¶y·(x, y)  r)
	±	(r  Functional ¤ µx y1 y2·(x, y1)  r ± (x, y2)  r ´ y1 = y2)
	±	((x, y)  r1 « r2 ¤ (x, y)  (Dom r2 á r1) À r2)
	±	((x, (y, z))  RelCombine r t ¤ (x, y)  r ± (x, z)  t)
®
));
=DESCRIBE
The theorem ``$¬rel\_\_in\_clauses®$'' gives what is required
to reduce problems in the vocabulary
of the theory $bin\_rel$ into the language of set theory. It is used in
the proof context $bin\_rel\_ext$ for this purpose.

Reasoning about the transitive and reflexive-transitive closure operations,
=INLINEFT
ç+ê
=TEX
\ and
=INLINEFT
ç*ê
=TEX
\ are not supported by this theorem.
=ENDDOC

=THDOC
req_thm("bin_rel_ext_clauses", ([],
¬
µ	r1 r2 : 'a ª 'b
·
		((r1   r2) ¤ ((µ x y · (x, y)  r1 ´ (x, y)  r2)
			± (¶ x y · ³((x, y)  r1) ± ((x, y)  r2))))
	±	((r1 € r2) ¤ µ x y · (x, y)  r1 ´ (x, y)  r2)
	±	((r1 = r2) ¤ (µ x y · (x, y)  r1 ¤ (x, y)  r2))
®
));
=DESCRIBE
The theorem ``$¬bin\_rel\_ext\_clauses®$'' gives theorems which express
extensionality of binary relations and closely related results.  They
are for use when set theoretic results are to be obtained by reasoning
about membership rather than by more algebraic means.

This theorem is very similar to ``$sets\_ext\_clauses$'', but the
intention here is that expressions about binary relations are rewritten
with expressions involving set membership of pairs of values allowing
other binary relation theorems to then be more readily used.
=ENDDOC

\subsection{Signature of the theory ``relation''}
=DOC
signature ÛBinRelTheoryİ = sig
	val Ûí_defİ : THM;
	val Û¸_defİ : THM;
	val Ûª_defİ : THM;
	val Ûdom_defİ : THM;
	val Ûran_defİ : THM;
	val Ûid_defİ : THM;
	val Û»_defİ : THM;
	val Ûr_»_r_defİ : THM;
	val Ûr_o_r_defİ : THM;
	val Ûò_defİ : THM;
	val Û’_defİ : THM;
	val Ûá_defİ : THM;
	val Û_defİ : THM;
	val Ûgraph_defİ : THM;
	val Ûinv_rel_defİ : THM;
	val Ûimage_defİ : THM;
	val Û«_defİ : THM;
	val Ûreflexive_defİ : THM;
	val Ûsymmetric_defİ : THM;
	val Ûtransitive_defİ : THM;
	val Ûinjective_defİ : THM;
	val Ûsurjective_defİ : THM;
	val Ûtotal_defİ : THM;
	val Ûfunctional_defİ : THM;
	val Ûtc_defİ : THM;
	val Ûrtc_defİ : THM;
	val Ûrel_combine_defİ : THM;
	val Ûrel__in_clausesİ : THM;
	val Ûbin_rel_ext_clausesİ : THM;
=DESCRIBE
This is the signature in which we declare theory ``relation''.
=ENDDOC

\section{PROOF CONTEXTS}
=DOC
(* proof context key Û"'bin_rel_ext"İ *)
=DESCRIBE
$bin\_rel\_ext$ extends $sets\_ext$ by adding $rel\_\_in\_thm$ into
the stripping of goals and theorems. The resulting proof context
reduces problems in the vocabulary of the theory $bin\_rel$ into
that of the theory $sets$ and then into the predicate calculus.
=ENDDOC
=SML
end;(* of signature BinRelTheory *)
=TEX

\section{TEST POLICY}

Any functions given in this document should be tested according to the
general criteria set out in~\cite{DS/FMU/IED/PLN008} using the tests
in~\cite{DS/FMU/IED/MDT071}.  In~\cite{DS/FMU/IED/MDT071} the theory
produced is checked by the theory design tools
of~\cite{DS/FMU/IED/DTD035} against the theory design provided.

The module tests should include automatic proof of all the ``rules''
in~\cite{Spivey92} expressible in this part of the theory of
relations.

Using the proof context formed as below, most of the rules on pages~96
to~102 of~\cite{Spivey92} are automatically proven.  Half of the
remainder can be solved by rewriting the goal with an equality from an
assumption then application of $strip\_tac$ or $prove\_tac$. {} The
others (seven in total) require some existance proofs.


\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}
