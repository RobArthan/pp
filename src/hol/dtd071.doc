%  $Id$ %Z%
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{FST Project}  %% Mandatory field
\TPPtitle{Detailed Design for the Theory of Relations}  %% Mandatory field
\def\TPPheadtitle{Detailed Design for the \cr
Theory of Sets}
\TPPref{DS/FMU/IED/DTD071}  %% Mandatory field
\def\SCCSversion{$Revision$ %
}
\TPPissue{\SCCSversion}  %% Mandatory field
\def\SCCSdate{\FormatDate{$Date$ %
}}
\TPPdate{\SCCSdate}  %% Mandatory field
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.B.Jones & WIN01}  %% Mandatory field
%\TPPauthors{R.D. Arthan & WIN01\\K. Blackburn & WIN01}
\TPPauthorisation{R.D. Arthan & FST Team Leader}
\TPPabstract{This document gives a detailed design for the 
theory of relations.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd 1992
\end{centering}
\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}
\begin{description}
\item[Issue \SCCSversion (\SCCSdate)]

This is the first draft of the document.

\end{description}
\subsection{Changes Forecast}

\section{GENERAL}
\subsection{Scope}
This document contains a detailed design
for the theory ``relation''.
The design is implemented in \cite{DS/FMU/IED/IMP071}.

\subsection{Introduction}
\subsubsection{Purpose and Background}
This document contains the detailed design for the theory ``relation''.

\subsubsection{Dependencies}
This document depends on \cite{DS/FMU/IED/IMP044}, and the theory design tools of \cite{DS/FMU/IED/DTD035}.
\subsubsection{Deficiencies}
None known.
\subsubsection{Possible Enhancements}
\section{THE THEORY ``relation''}
\subsection{Design of the theory ``relation''}
=IGN
req_flag := Declare;
initialise_td_results ();
=THDOC
req_name "relation" (Value "hol");
=DESCRIBE
The theory ``Ûrelationİ'' contains the definitions of various operators upon sets of pairs and proves theorems relating to these for use in proof contexts.
=ENDDOC
=THDOC
req_type_abbrev(Û"ğ"İ, ["'a"], ¬:('a)SET®);
req_infix(500, "í");
req_const(Û"í"İ,”'a ­ 'b ­ 'a ¸ 'b®);
req_defn(["í"],([],¬$í = $,®));
req_infix(100, "ª");
req_type_abbrev(Û"ª"İ, ["'a","'b"], ¬:('a ¸ 'b)ğ®);
=DESCRIBE
The definition of the maplet symbol $"í"$ and type abbreviations $``ğ''$ and $``ª''$ are included for compatibility with Z.
=ENDDOC
=THDOC
req_const(Û"¸"İ,¬:'a ğ ­ 'b ğ ­ ('a ª 'b)®);
req_defn(["¸"],
	([],¬µ (x : 'a ğ) (y : 'b ğ)· (x ¸ y) = {(v,w) | v  x ± w  y}®));
req_const(Û"ª"İ,¬:'a ğ ­ 'b ğ ­ ('a ª 'b) ğ®);
req_defn(["ª"],
	([],¬µ (x : 'a ğ) (y : 'b ğ)·
		(x ª y) = ğ(x ¸ y)®));
=DESCRIBE
The HOL constant $¸$ is the cartesian product contructor.
The HOL constant $Ûªİ$ is relation contructor.
=ENDDOC
=THDOC
req_const(Û"Dom"İ,¬:('a ª 'b) ­ ('a)ğ®);
req_defn(["Dom"], ([],¬µ (r : ('a ª 'b))· Dom r = {x | ¶y · (x, y)  r}®));
req_const(Û"Ran"İ,¬:('a ª 'b) ­ ('b)ğ®);
req_defn(["Ran"],	([],¬µ (r : ('a ª 'b))· Ran r = {y | ¶x · (x, y)  r}®));
=DESCRIBE
The HOL constant $Dom$ is the function giving the domain of a relation.
The HOL constant $ÛRanİ$ is the function giving the range of a relation.
=ENDDOC
=THDOC
req_const(Û"Id"İ,¬:('a)ğ ­ ('a ª 'a)®);
req_defn(["Id"], ([],¬µ (s : ('a)ğ)·  Id s = {(x,x) | T}®));
=DESCRIBE
=ENDDOC
=THDOC
req_infix(500, "»");
req_const(Û"»"İ,¬:('a ­ 'b) ­ ('b ­ 'c) ­ ('a ­ 'c)®);
req_defn(["»"],([],¬µ (f:'a ­ 'b) (g:'b ­ 'c) · f » g = g o f®));
req_infix(500, "R_»_R");
req_const(Û"R_»_R"İ,¬:('a ª 'b) ­ ('b ª 'c) ­ ('a ª 'c)®);
req_defn(["R_»_R"],([],¬µ f g · f R_»_R g =
	Ran {(y,(x,z))|(x,y)  f ± (y,z)  g}®));
(* req alias doesn't allow overloading
req_alias("»",¬$R_»_R®);
*)
req_infix(500, "F_»_R");
req_const(Û"F_»_R"İ,¬:('a ­ 'b) ­ ('b ª 'c) ­ ('a ª 'c)®);
req_defn(["F_»_R"],([],¬µ f g · f F_»_R g =
	Ran {(y,(x,z))| f x = y ± (y,z)  g}®));
(* req alias doesn't allow overloading
req_alias("»",¬$F»R®);
*)
req_infix(500, "R_»_F");
req_const(Û"R_»_F"İ,¬:('a ª 'b) ­ ('b ­ 'c) ­ ('a ª 'c)®);
req_defn(["R_»_F"],([],¬µ (f:'a ª 'b) (g:'b ­ 'c) · f R_»_F g =
	Ran {(y,(x,z))| (x,y)  f ± z = g y}®));
(* req alias doesn't allow overloading
req_alias("»",¬$R_»_F®);
*)
=DESCRIBE
=ENDDOC
=THDOC
req_infix(500, "R_o_R");
req_const(Û"R_o_R"İ,¬:('b ª 'c) ­ ('a ª 'b) ­ ('a ª 'c)®);
req_defn(["R_o_R"],([],¬µ f g · f R_o_R g = g R_»_R f®));
req_alias("o",¬$R_o_R®);
req_infix(500, "F_o_R");
req_const(Û"F_o_R"İ,¬:('b ­ 'c) ­ ('a ª 'b) ­ ('a ª 'c)®);
req_defn(["F_o_R"],([],¬µ f r · f F_o_R r = r R_»_F f®));
(* req alias doesn't allow overloading
req_alias("o",¬$F_o_R®);
*)
req_infix(500, "R_o_F");
req_const(Û"R_o_F"İ,¬:('b ª 'c) ­ ('a ­ 'b) ­ ('a ª 'c)®);
req_defn(["R_o_F"],([],¬µ r f · r R_o_F f = f F_»_R r®));
(* req alias doesn't allow overloading
req_alias("o",¬$R_o_F®);
*)
=DESCRIBE
=ENDDOC
=THDOC
req_infix(300,"ò");
req_const(Û"ò"İ,¬:('a)ğ ­ ('a ª 'b) ­ ('a ª 'b)®);
req_defn(["ò"],([],¬µ s r · s ò r = {(x,y)| x  s ± (x,y)  r}®));
req_infix(300,"’");
req_const(Û"’"İ,¬:('a ª 'b) ­ ('b)ğ ­ ('a ª 'b)®);
req_defn(["’"],([],¬µ s r · r ’ s = {(x,y)| y  s ± (x,y)  r}®));
=DESCRIBE
=ENDDOC
=THDOC
req_infix(300,"á");
req_const(Û"á"İ,¬:('a)ğ ­ ('a ª 'b) ­ ('a ª 'b)®);
req_defn(["á"],([],¬µ s r · s á r = {(x,y)| ³ x  s ± (x,y)  r}®));
req_infix(300,"");
req_const(Û""İ,¬:('a ª 'b) ­ ('b)ğ ­ ('a ª 'b)®);
req_defn([""],([],¬µ s r · r  s = {(x,y)| ³ y  s ± (x,y)  r}®));
=DESCRIBE
=ENDDOC
=THDOC
req_const(Û"InverseRelation"İ,¬:('a ª 'b) ­ ('b ª 'a)®);
req_defn(["InverseRelation"],([],
	¬µ r · InverseRelation r = {(x,y)| (y,x)  r}®));
req_alias(Û"~"İ,¬InverseRelation®);
req_infix(300,"Rim");
req_const(Û"Rim"İ,¬:('a ª 'b) ­ ('a)ğ ­ ('b)ğ®);
req_defn(["Rim"],([],
	¬µ r s · r Rim s = Ran {(x,y)| x  s ± (x,y)  r}®));
=DESCRIBE
=ENDDOC
=THDOC
req_infix(300,"«");
req_const(Û"«"İ,¬:('a ª 'b) ­ ('a ª 'b) ­ ('a ª 'b)®);
req_defn(["«"],([],¬µ r s · r « s = ((Dom s) á r) À s®));
req_postfix(500,"›+");
req_const(Û"›+"İ,¬:('a ª 'a) ­ ('a ª 'a)®);
req_defn(["›+"],([],¬µ r · r ›+ = ¥{q | r € q ± q R_»_R q € q}®));
req_postfix(500, "›*");
req_const(Û"›*"İ,¬:('a ª 'a) ­ ('a ª 'a)®);
req_defn(["›*"],([],¬µ r · r ›* =
	¥{q | Id Universe € q ± r € q ± q R_»_R q € q}®));
=DESCRIBE
The rest of the constants defined in \cite{Spivey89} section 4.2.
=ENDDOC
\subsection{Signature of the theory ``relation''}
=THDOC
req_const(Û"RelCombine"İ,¬:('a ª 'b) ­ ('a ª 'c) ­ ('a ª ('b ¸ 'c))®);
req_defn(["RelCombine"],([],¬µ f g · RelCombine f g 
	= {(x, (y,z)) | (x,y)  f ± (x,z)  g}®));
=DESCRIBE
=ENDDOC
=THDOC
req_thm("¸_ext_thm",([],¬µ (a : 'a ğ) (b : 'b ğ)(x : 'a)·
		x  (a ¸ b) ¤ Fst x  a ± Snd x  b®));
req_thm("ª_ext_thm",([],¬µ (a : 'a ğ) (b : 'b ğ)(x : 'a)·
		x  (a ª b) ¤ x € (a ¸ b)®));
req_thm("dom_ext_thm",([],¬µ (r : 'a ª 'b) (x : 'a)·
		x  Dom r ¤ ¶y· (x í y)  r®));
req_thm("ran_ext_thm",([],¬µ (r : 'a ª 'b) (y : 'b)·
		y  Ran r ¤ ¶x· (x í y)  r®));
req_thm("id_ext_thm",([],¬µ (x : 'a) (s : 'a ğ)·
		x  Id s ¤ Fst x  s ± Fst x = Snd x®));
req_thm("R_»_R_ext_thm",([],¬µ (f : 'a ª 'b) (g : 'b ª 'c) (x : 'a ¸ 'c)·
		x  (f R_»_R g) ¤ ¶y· (Fst x í y)  f ± (y í Snd x)  g®));
=DESCRIBE
=ENDDOC
=DOC
signature ÛRelationTheoryİ = sig
	val Ûí_defİ : THM;
	val Û¸_defİ : THM;
	val Ûª_defİ : THM;
	val Ûdom_defİ : THM;
	val Ûran_defİ : THM;
	val Ûid_defİ : THM;
	val Û»_defİ : THM;
	val Ûr_»_r_defİ : THM;
	val Ûf_»_r_defİ : THM;
	val Ûr_»_f_defİ : THM;
	val Ûr_o_r_defİ : THM;
	val Ûf_o_r_defİ : THM;
	val Ûr_o_f_defİ : THM;
	val Ûò_defİ : THM;
	val Û’_defİ : THM;
	val Ûá_defİ : THM;
	val Û_defİ : THM;
	val Ûinverse_relation_defİ : THM;
	val Ûrim_defİ : THM;
	val Û«_defİ : THM;
	val Ûtc_defİ : THM;
	val Ûrtc_defİ : THM;
	val Ûrel_combine_defİ : THM;
=DESCRIBE
This is the signature in which we declare theory ``relation''.
=ENDDOC
\section{PROOF CONTEXTS}
=DOC
(* proof context key "Ûrelation_extİ" *)
=DESCRIBE
$relation\_ext$ extends $sets_ext$ by:
\begin{description}
\item [Name]\ 

Becomes ``relation$\_$ext''.
\item [Stripping Goals and Theorems]\ 

Adding in ? applied at the top level or under a single negation.
\item [Rewriting Context]\ 

Adding in ?.
\end{description}
=ENDDOC
=DOC
(* proof context key Û"relation_alg"İ *)
=DESCRIBE
$relation\_alg$ extends $sets\_alg$ by:
\begin{description}
\item [Name]\ 

Becomes ``relation$\_$alg''.
\item [Stripping Goals and Theorems]\ 

Adding in ? applied at the top level or under a single negation.
\item [Rewriting Context]\ 

Adding in ?.
\end{description}
=ENDDOC
=SML
end;(* of signature SetsTheory *)
=TEX
\section{TEST POLICY}
Any functions given in this document should be tested according to the
general criteria set out in \cite{DS/FMU/IED/PLN008}, using the
tests in \cite{DS/FMU/IED/MDT071}.
In \cite{DS/FMU/IED/MDT071} the theory produced is checked by the theory design tools
of \cite{DS/FMU/IED/DTD035}, against the theory design provided.

The module tests should include automatic proof of all the ``rules'' in \cite{Spivey89} expressible in this part of the theory of relations.
\twocolumn[\section{INDEX}]
\small
\printindex
\end{document}


