% mdt503.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT} %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests: Compliance Notation Parser} %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT503} %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion} %% Mandatory field
\TPPdate{\FormatDate{$Date$
}} %% Mandatory field (with sensible default)
\TPPstatus{Draft}   %% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
%\TPPauthor{A.C.~Hayward & WIN01} %% Mandatory field
\TPPauthors{D.J.~King & WIN01\\A.C.~Hayward & WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{This document comprises test cases and test code/data for testing the DAZ parser as described in the document ISS/HAT/DAZ/DTD503.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
Library \\ A.C. Hayward\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History} % to get section number `0.3'
\begin{description}

\item[Issue 1.1, \FormatDate{94/03/29}]
First version.
\item[Issue 1.2, \FormatDate{94/03/30}]
Most tests now working.
\item[Issue 1.3, \FormatDate{94/03/30}]
Changed BOSparkNotmem to BOSparkNotMem.
\item[Issue 1.4, \FormatDate{94/04/07}]
Change to web\_cn since the formatting routines now return (int * string) list rather than string.
\item[Issue 1.5, \FormatDate{94/04/08}]
Change to web\_cn since the formatting routines now have FmtInfo as the first argument.
\item[Issue 1.8 \FormatDate{94/07/21}]
Major change. This module test is now solely for the parser.

\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises test cases and test code/data for testing the DAZ Compliance Notation as specified in \cite{ISS/HAT/DAZ/DTD503}.

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the DAZ Compliance Notation Parser as defined in \cite{ISS/HAT/DAZ/DTD503} and implemented in \cite{ISS/HAT/DAZ/IMP503}. The tests are intended to meet the requirements for tests identified in the quality plan \cite{ISS/HAT/DAZ/PLN003}.

\subsubsection{Dependencies}

These tests depend on the test harness as implemented in DS/FMU/IED/IMP013, and its corresponding detailed design document, DS/FMU/IED/DTD013.

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

There are no known deficiencies.

\section{INITIALISATION}

First we need to load the test harnes and initialise it.

=SML
use_file "dtd013";
use_file "imp013";
init_mt_results();
=TEX

\section{PREAMBLE}

Set up the theory database as necessary.

=SML
open_theory "z_library";
force_delete_theory "mdt503" handle (_) => ();
new_theory "mdt503";
=TEX

\section{TESTING CNParser}

This is the signature for the structure containing the parser for SPARK.

=SML
open CNTypes CNParser;
=TEX

\subsection{Supporting functions}

The following function looks at the label in a web clause (if there is one). The label determines the kind of web clause entered. This classification function is called from within the lexical analyser, and it is necessary for it to be called prior to the parser since the parser recognises a language in which the distinction between the kinds of web clause is made in the parser's input.

=SML
fun Ûclassify_labelÝ (itemlist : CN_LEX_ITEM list) : CN_LEX_ITEM list = (
    case itemlist
    of (LCOrd, _)::(LCNumericLiteral, CNText ntxt)::(LCCrd, _)::rest =>
    (
    (
    (
case nat_of_string ntxt
of 1 => LCCompLabel
| 2 => LCPPartLabel
| 3 => LCVPartLabel
| 4 => LCDecLabel
| 5 => LCStmtLabel
| 6 => LCSpecLabel
| _ => LCCompLabel
),
CNText ("("^ntxt^")")
)::rest
)
| _ => itemlist
);
=TEX

Set up the Compliance Notation Reader Writer. This reads the input and then passes it through Lexical Analyser and the Parser.

=SML
fun Ûcn_recogniserÝ (start:string, lang:string, value:Lex.INPUT list,
    finish:string) = (
    if ReaderWriterSupport.PrettyNames.is_same_symbol(start, "¹")
    andalso ReaderWriterSupport.PrettyNames.is_same_symbol(finish, "°")
    andalso (lang = "CN")
    then
        let val save_cn_parser_state = get_cn_parser_state();
        in
            (CNParser.cn_parser o CNLex.cn_lex classify_label) value
        end
    else
        fail "cn_recogniser" 504010
            [fn () => start, fn () => lang, fn () => finish]
);
=TEX

This takes a string, and passes it through the Lexical analyser and the Parser to create a Compliance Notation version.

=SML
fun cn_of_input (inp : Lex.INPUT list) : CNTypes.WEB_CLAUSE =
    (CNParser.cn_parser o (CNLex.cn_lex classify_label)) inp;
=TEX

When we test the parser, we only check that the the following bits of code
compile without any errors. In a later document we check that the compilance notation produced by the Parser is what was intended. The following function returns true if the code compiled okay, and false if an error was produced.

=SML
local
fun check_parser_aux (inp : Lex.INPUT list) : bool =
    (case (cn_of_input inp)
    of _ => true)
    handle _ => false;
in
fun check_parser ([] : (string*(Lex.INPUT list)) list) = []
|   check_parser ((n,inp)::xs : (string*(Lex.INPUT list)) list) =
    (n, check_parser_aux inp)::(check_parser xs);
end;
=TEX

\subsection{Expressions}

\subsection{Relations}

=SML
local
val t1 = "procedure relation1 is a,x,y,z : boolean; \
\begin a := x and y; a := x and y and z; end relation1;";
val t2 = "procedure relation2 is a,x,y,z : boolean; \
\begin a := x and then y; a := x and then y and then z; end relation2;";
val t3 = "procedure relation3 is a,x,y,z : boolean; \
\begin a := x or y; a := x or y or z; end relation3;";
val t4 = "procedure relation4 is a,x,y,z : boolean; \
\begin a := x or else y; a := x or else y or else z; end relation4;";
val t5 = "procedure relation5 is a,x,y,z : boolean; \
\begin a := x xor y; a := x xor y xor z; end relation5;";
val t6 = "procedure relation6 is a : boolean; x,y : integer; \
\begin a := x = y; a := x /= y; a := x < y; \
\a := x <= y; a := x > y; a := x >= y; end relation6;";
val t7 = "procedure relation7 is a : boolean; \
\begin a := 42 in 0..100; a := 42 not in 0..100; \
\a := 42 in integer; a := 42 not in integer; end relation7;";
in
val _ = store_mt_results check_parser [
    ("relation.1", [Lex.Text t1]),
    ("relation.2", [Lex.Text t2]),
    ("relation.3", [Lex.Text t3]),
    ("relation.4", [Lex.Text t4]),
    ("relation.5", [Lex.Text t5]),
    ("relation.6", [Lex.Text t6]),
    ("relation.7", [Lex.Text t7])];
end;
=TEX

\subsubsection{Arithmetic operations}

=SML
local
val t1 = "procedure factor1 is a : real; b : boolean; begin \
\a := 42.0; a := 42.0 ** 42.0; a := abs 42.0; b := not true; end factor1;";
val t2 = "procedure multiply1 is a : real; b : integer; begin \
\a := 42.0 * 42.0; a := 42.0 * 42.0 * 42.0; a := 42.0 / 3; \
\b := 42.0 mod 3; b := 42.0 rem 2; end multiply1;";
val t3 = [Lex.Text "procedure add1 is a : real; b : string; begin \
\a := 42.0 + 42.0; a := 42.0 + 42.0 + 42.0; a := 42.0 - 36.0; \
\b := ", Lex.String "Hello", Lex.Text "&", Lex.String " ", Lex.Text "&",
Lex.String "World", Lex.Text "; end add1;"];
val t4 = "procedure unary1 is a : real; begin \
\a := +42.0; a := -42.0; end unary1;";
in
val _ = store_mt_results check_parser [
    ("factor.1", [Lex.Text t1]),
    ("multiply.1", [Lex.Text t2]),
    ("add.1", t3),
    ("unary.1", [Lex.Text t4])];
end;
=TEX

\subsubsection{Primaries}

At the parsing stage, we are unable to distinguish between a type conversion
and a positional indexed component. Auxiliary expressions are not yet recognised and generated. Hence no test for them yet.

=SML
local
val t1 = "procedure numeric1 is a : integer; begin a := 42; end numeric1;";
val t2 = [Lex.Text "procedure char1 is a : char; begin a := ", Lex.String "a",
Lex.Text "; a := ", Lex.String "\"", Lex.Text "; a := ", Lex.String " ",
Lex.Text "; end char1; "];
val t3 = [Lex.Text "procedure string1 is a : string; begin a := ",
Lex.String "Hello, world", Lex.Text "; a := ",
Lex.String "Apples", Lex.Text "; a := ",
Lex.String "Zaphod Bebblebrox", Lex.Text "; end string1; "];
val t4 = "procedure indexed1 is a : integer; begin \
\a := apple(1,2,3); a := apple(1,2)(3,4); end indexed1;";
val t5 = "procedure selected1 is a : integer; begin \
\a := apple.ripe; a := apple(1).ripe; end selected1;";
val t6 = "procedure select1 is a : integer; begin \
\a := apple; a := apple.colour; a := apple.colour.ripe; \
\a := apple(1,2).colour; end select1;";
val t7 = "procedure funcall1 is a : integer; begin \
\a := apple; a := apple (colour => red); \
\a := apple (colour => red, ripe => true); a := apple (red); \
\a := apple (red, true); end funcall1;";
val t8 = "procedure qualified1 is a : colour; begin \
\a := colours'(blue); a := colours'(blue,red); a := colours'(first => blue); \
\a := colours'(first => blue, second => red); \
\a := colours'(first | second => blue); \
\a := colours'(integer range 1 .. 5 | 7 => blue, 10 .. 12 => red); \
\a := colours'(first => blue, others => red); \
\a := colours'(first => blue, second => red, others => white); \
\a := colours'(first | second => blue, others => red); \
\a := colours'(others => white); end qualified1;";
val t9 = "procedure attribute1 is a : colours; begin \
\a := colours'first; a := rainbow'base'first; \
\a := apple'colour(first); end attribute1;";
val t10 = "procedure bracket1 is a : integer; begin \
\a := (1 + 2); a := ((1 + 2) * (3 + 4)); \
\a := (((1 + 2) * 3) + 4); end bracket1;";
in
val _ = store_mt_results check_parser [
    ("numeric.1", [Lex.Text t1]),
    ("char.1", t2),
    ("string.1", t3),
    ("indexed.1", [Lex.Text t4]),
    ("selected.1", [Lex.Text t5]),
    ("select.1", [Lex.Text t6]),
    ("funcall.1", [Lex.Text t7]),
    ("qualified.1", [Lex.Text t8]),
    ("attribute.1", [Lex.Text t9]),
    ("bracket.1", [Lex.Text t10])];
end;
=TEX

\subsection{Declarations}

\subsubsection{Object declarations}

=SML
local
val t1 = [Lex.Text "procedure constant1 is x,y : constant string := ",
Lex.String "Hello, world", Lex.Text "; begin null; end constant1; "];
val t2 = "procedure variable1 is a : string; x,y,z : real; \
\begin null; end variable1;";
in
val _ = store_mt_results check_parser [
    ("constant.1", t1),
    ("variable.1", [Lex.Text t2])];
end;
=TEX

\subsubsection{Type declarations}

=SML
local
val t1 = "procedure enumeration1 is \
\type COLOUR is (red, orange, yellow, green, blue, indigo, violet); \
\type FRUIT is (apple, pear, orange, banana, grape); \
\begin null; end enumeration1;";
val t2 = "procedure integer1 is type AGE is range 0..100; \
\type x is range -42..42; \
\begin null; end integer1;";
val t3 = "procedure real1 is type a is digits 3; \
\type a is digits 3 range 0.00 .. 10.0; type b is delta 0.1; \
\type b is delta 0.1 range 0.0 .. 9.9; begin null; end real1;";
val t4 = "procedure array1 is \
\type COLOURS is array (wavelength range <>) of integer; \
\type A is array (integer range <>, integer range <>) of real; \
\type NOOFFRUIT is array (FRUITTYPE, RIPE) of integer; \
\begin null; end array1;";
val t5 = "procedure record1 is type data is record \
\day : day_range; month : month_range; year : year_range; end record;\
\begin null; end record1;";
val t6 = "procedure private1 is type a is private; \
\type b is limited private; begin null; end private1;";
in
val _ = store_mt_results check_parser [
    ("enumeration.1", [Lex.Text t1]),
    ("integer.1", [Lex.Text t2]),
    ("real.1", [Lex.Text t3]),
    ("array.1", [Lex.Text t4]),
    ("record.1", [Lex.Text t5]),
    ("private.1", [Lex.Text t6])];
end;
=TEX

\subsubsection{Subtype declarations}

=SML
local
val t1 = "procedure subtype1 is subtype a is integer range 1..10; \
\subtype rainbow is colours range red .. blue; begin null; end subtype1;";
in
val _ = store_mt_results check_parser [("subtype.1", [Lex.Text t1])];
end;
=TEX

\subsubsection{Deferred constant declarations}

=SML
local
val t1 = "procedure deferred1 is a : constant integer; \
\x,y : constant real; begin null; end deferred1;";
in
val _ = store_mt_results check_parser [("deferred.1", [Lex.Text t1])];
end;
=TEX

\subsubsection{Renaming declarations}

Why is this so different from the ADA standard.  Specificaly, the function name has to be in quotes, and the name at the end is in two parts.  Why the dot in the last part?

=SML
local
val t1 = [Lex.Text "(4) é function ", Lex.String "complex_add",
Lex.Text " (x,y : in complex; z : out complex) return complex renames junk.",
Lex.String "sfgd", Lex.Text "; "];
val t2 = "(4) é function complex_add (x,y : in complex; z : out complex) \
\return complex renames complex.add;";
in
val _ = store_mt_results check_parser [
    ("renaming.1", t1),
    ("renaming.2", [Lex.Text t2])];
end;
=TEX
\subsection{Statements};

\subsubsection{Misc statements}


The test for K slots is followed by a redefining clause to fill the first K slot.

=SML
local
val t1 = "procedure kslot1 is begin § more information ¢ \
\§ more information ¢ (10) end kslot1;";
val d1 = "Ã null;";
val t2 = "procedure specnoivars1 is begin  A [true] end specnoivars1;";
val t3 = "procedure conzdecl1 is begin \
\con z : ú ·  x, y [true, true] (4) end conzdecl1;";
val d2 = "Ã null;";
in
val _ = store_mt_results check_parser [
    ("kslot.1", [Lex.Text t1]),
    ("dummy.1", [Lex.Text d1]), 
    ("spec_no_ivars.1", [Lex.Text t2]),
    ("con_z_decl.1", [Lex.Text t3]),
    ("dummy.2", [Lex.Text d2])];
end;
=TEX

\subsubsection{Simple statements}

=SML
local
val t1 = "procedure null1 is begin null; end null1;";
val t2 = "procedure assign1 is begin a := 42; end assign1;";
val t3 = "procedure proccall1 is begin pick_apples; pick_apples(1,2); \
\pick_apples(day => monday, time => 6.00); end proccall1;";
val t4 = "procedure exit1 is begin exit; exit when 42 > 0; end exit1;";
val t5 = "procedure return1 is begin return 42.0 + 42.0; end return1;";
in
val _ = store_mt_results check_parser [
    ("null.1", [Lex.Text t1]),
    ("assign1", [Lex.Text t2]),
    ("proc_call.1", [Lex.Text t3]),
    ("exit.1", [Lex.Text t4]),
    ("return.1", [Lex.Text t5])];
end;
=TEX

\subsubsection{Compound statements}

=SML
local
val t1 = "procedure if1 is begin \
\if 42.0 > 0 then null; end if; if 42.0 > 0 then null; else null; end if; \
\if 42.0 > 0 then null; elsif 42 < 0 then null; end if; \
\if 42.0 > 0 then null; elsif 42 < 0 then null; else null; end if; \
\end if1;";
val t2 = "procedure case1 is begin \
\case a is when 1 => null; when 2..3|5|8 => null; when 4|6..7 => null; \
\when others => null; end case; \
\case a is when 1 => null; when 2..3|5|8 => null; when 4|6..7 => null; \
\end case; end case1;";
val t3 = "procedure loop1 is begin loop null; end loop;\
\till ûa>42ý loop null; end loop;\
\apple : loop null; end loop apple;\
\apple : till ûa>42ý loop null; end loop apple; end loop1;";
val t4 = "procedure while1 is begin while a < 42 loop null; end loop; \
\while a < 42 till ûb=falseý loop null; end loop; \
\apple : while a < 42 loop null; end loop apple; \
\apple : while a < 42 till ûb=falseý loop null; end loop apple; end while1;";
val t5 = "procedure for1 is begin \
\for a in colours loop null; end loop; \
\for a in reverse colours loop null; end loop; \
\for a in integer range 1..10 loop null; end loop; \
\for a in reverse integer range 1..10 loop null; end loop; \
\for a in colours till ûb=trueý loop null; end loop; \
\for a in reverse colours till ûb=trueý loop null; end loop; \
\for a in integer range 1..10 till ûb=trueý loop null; end loop; \
\for a in reverse integer range 1..10 till ûb=trueý loop null; end loop; \
\apple : for a in colours loop null; end loop apple; \
\apple : for a in reverse colours loop null; end loop apple; \
\apple : for a in integer range 1..10 loop null; end loop apple; \
\apple : for a in reverse integer range 1..10 loop null; end loop apple; \
\apple : for a in colours till ûb=trueý loop null; end loop apple; \
\apple : for a in reverse colours till ûb=trueý loop null; end loop apple; \
\apple : for a in integer range 1..10 till ûb=trueý loop null; end loop apple; \
\apple : for a in reverse integer range 1..10 till ûb=trueý loop null; \
\end loop apple; end for1;";
in
val _ = store_mt_results check_parser [
    ("if.1", [Lex.Text t1]),
    ("case.1", [Lex.Text t2]),
    ("loop.1", [Lex.Text t3]),
    ("while.1", [Lex.Text t4]),
    ("for.1", [Lex.Text t5])];
end;
=TEX

\subsection{Representation clauses}

=SML
local
(* length clause *)
val t1 = "(2) é for integer'size use 4*byte;";
(* enumeration clause *)
val t2 = "(2) é for colours use (red => 1, green => 2, blue => 3);";
(* record representation clause *)
val t3 = "(2) é for PROGRAM_STATUS_WORD use \
\record at mod 8; SYSTEM_MASK at 0*WORD range 0 .. 7; \
\PROTECTION_KEY at 0*WORD range 10 .. 11;\
\MACHINE_STATE at 0*WORD range 12 .. 15; \
\INTERRUPT_CAUSE at 0*WORD range 16 .. 31; \
\ILC at 1*WORD range 0 .. 1;\
\CC at 1*WORD range 2 .. 3; PROGRAM_MASK at 1*WORD range 4 .. 7; \
\INST_ADDRESS at 1*WORD range 8 .. 31; end record;";
(* address clause *)
val t4 = "(2) é for SWI use at 16#0002#;";
in
val _ = store_mt_results check_parser [
    ("length_rep.1", [Lex.Text t1]),
    ("enumeration_rep.1", [Lex.Text t2]),
    ("record_rep.1", [Lex.Text t3]),
    ("address_rep.1", [Lex.Text t4])];
end;
=TEX

\subsection{Specifications}

\raggedright{Checking procedure and function specifications means we can also check $formal\_part$, $parlist$, $parameter\_specification$ and $mode$.}

\subsubsection{Procedure specifications}

=SML
local
val t1 = "(3) é procedure orange;";
val t2 = "(3) é procedure orange  j,k [true];";
val t3 = "(3) é procedure orange (x, y : IN integer; z : OUT integer);";
val t4 = "(3) é procedure orange (x : IN OUT integer)  x [true];";
in
val _ = store_mt_results check_parser [
    ("procedure_spec.1", [Lex.Text t1]),
    ("procedure_spec.2", [Lex.Text t2]),
    ("procedure_spec.3", [Lex.Text t3]),
    ("procedure_spec.4", [Lex.Text t4])];
end;
=TEX

\subsubsection{Function specifications}

=SML
local
val t1 = "(3) é function orange return integer;";
val t2 = "(3) é function orange return integer  j,k [true];";
val t3 = "(3) é function orange (x : IN integer; y : OUT integer) return integer;";
val t4 = "(3) é function orange (x : IN int; y : OUT int) return integer  j,k [true];";
in
val _ = store_mt_results check_parser [
    ("function_spec.1", [Lex.Text t1]),
    ("function_spec.2", [Lex.Text t2]),
    ("function_spec.3", [Lex.Text t3]),
    ("function_spec.4", [Lex.Text t4])];
end;
=TEX

\subsubsection{Package specifications}

=SML
local
val t1 = "(4) é package complex is x,y : real; end complex;";
val t2 = "(4) é package complex is \
\function add_complex (z : in complex; w : out complex) return complex; \
\private x,y : real; end complex;";
in
val _ = store_mt_results check_parser [
    ("package_spec.1", [Lex.Text t1]),
    ("package_spec.2", [Lex.Text t2])];
end;
=TEX

\subsection{Web clauses}

\subsubsection{Compilations}

=SML
local
val t1 = "procedure print_complex (z : in complex) is \
\x,y : real; begin null; end print_complex;";
val t2 = "function add_complex (z,w : in complex) return complex is \
\x,y,u,v : real; begin null; end add_complex;";
val t3 = "with toolkit; package complex_tools is \
\function add_complex (z,w : in complex) return complex; \
\procedure print_complex (z : in complex); end complex_tools;";
val t4 = "with toolkit; procedure a is begin nulll; end a;";
val t5 = "with toolkit; function b return c is begin null; end b;";
val t6 = "package body complex_tools is type complex is record \
\x : real; y : real; end record; end complex_tools;";
val t7 = "package body complex_tools is type complex is record x : real; \
\y : real; end record; origin : real; begin origin.x := 0; \
\origin.y := 0;end complex_tools;";
val t8 = "separate (toolkit) package body complex_tools is type complex is \
\record x : real; y : real; end record; origin : real; begin origin.x := 0; \
\origin.y := 0; end complex_tools;";
val t9 = "with toolkit; package body complex_tools is type complex is \
\record x : real; y : real; end record; origin : real; begin origin.x := 0; \
\origin.y := 0; end complex_tools;";
val t10 = "with toolkit, extensions; separate (toolkit) package body \
\complex_tools is type complex is record x : real; y : real; end record; \
\origin : real; begin origin.x := 0; origin.y := 0; end complex_tools;";
in
val _ = store_mt_results check_parser [
    ("Compilation.1", [Lex.Text t1]),
    ("Compilation.2", [Lex.Text t2]),
    ("Compilation.3", [Lex.Text t3]),
    ("Compilation.4", [Lex.Text t4]),
    ("Compilation.5", [Lex.Text t5]),
    ("Compilation.6", [Lex.Text t6]),
    ("Compilation.7", [Lex.Text t7]),
    ("Compilation.8", [Lex.Text t8]),
    ("Compilation.9", [Lex.Text t9]),
    ("Compilation.10", [Lex.Text t10])];
end;
=TEX

\subsubsection{Private parts}

=SML
local
val t1 = "(2) é x,y : real;";
in
val _ = store_mt_results check_parser [("Private.1", [Lex.Text t1])];
end;
=TEX

\subsubsection{Visible parts}

=SML
local
val t1 = "(3) é procedure do_nothing;";
val t2 = "(3) é function zero return integer;";
in
val _ = store_mt_results check_parser [
    ("Visible.1", [Lex.Text t1]),
    ("Visible.2", [Lex.Text t2])];
end;
=TEX

\subsubsection{Dec}

=SML
local
val t1 = "(4) é  procedure do_nothing is begin null; end do_nothing;";
val t2 = "(4) é package body complex_tools is type complex is record \
\x : real; y : real; end record; origin : real; begin origin.x := 0; \
\origin.y := 0; end complex_tools;";
val t3 = "(4) é procedure print_complex(z : in complex) is separate;";
val t4 = "(4) é function add_complex(z,w : in complex) return complex \
\is separate;";
val t5 = "(4) é package body not_here is separate;";
in
val _ = store_mt_results check_parser [
    ("Dec.1", [Lex.Text t1]),
    ("Dec.2", [Lex.Text t2]),
    ("Dec.3", [Lex.Text t3]),
    ("Dec.4", [Lex.Text t4]),
    ("Dec.5", [Lex.Text t5])];
end;
=TEX

\subsubsection{Other Web clauses}

=SML
local 
val t1 = "§ nothing ¢";
val t2 = "é null;";
val t3 = "§ nothing ¢";
val t4 = "Ã null;";
in
val _ = store_mt_results check_parser [
    ("Web.1", [Lex.Text t1]),
    ("Web.2", [Lex.Text t2]),
    ("Web.3", [Lex.Text t3]),
    ("Web.4", [Lex.Text t4])];
end;
=TEX

\section{SUMMARY OF RESULTS}

=SML
diag_line(summarize_mt_results());
=TEX

\end{document}
