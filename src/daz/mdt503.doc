%  mdt503.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Compliance Notation Parser}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT503}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthors{D.J.~King & WIN01\\A.C.~Hayward & WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{
This document comprises test cases and test code/data for
testing the DAZ parser as described in the document
ISS/HAT/DAZ/DTD503.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ A.C. Hayward\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1]
First version.
\end{description}
\subsection{Changes Forecast}
As the DAZ Compliance Notation Parser is extended, so will this document.
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises test cases and test code/data for
testing the DAZ Compliance Notation Parser specified in \cite{ISS/HAT/DAZ/DTD503}.

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the DAZ Compliance Notation Parser as defined in \cite{ISS/HAT/DAZ/DTD503} and implemented in \cite{ISS/HAT/DAZ/IMP503}. The tests are intended to meet the requirements for tests identified in the quality plan \cite{ISS/HAT/DAZ/PLN003}.

\subsubsection{Dependencies}

These tests depend on the test harness as implemented in DS/FMU/IED/IMP013, and its corresponding detailed design document, DS/FMU/IED/DTD013.

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

There are no known deficiencies.

\section{TEST CASES}
\section{PREAMBLE}
Set up the theory database as necessary.
=SML
open BasicError;
open_theory "daz_toolkit_extensions";
force_delete_theory "mdt503_test" handle (_) => ();
new_theory "mdt503_test";
use_file "dtd013";
use_file "imp013";
=TEX
A couple functions needed for comparing the input to the Parser and the string generated by the Pretty Printer.
=SML
val white_space_set = [" ", "\n", "\t"];
fun isspace (x : string) : bool = x mem white_space_set;
fun to_upper x = CaseIndependence.to_upper x;
fun remove_most_spaces (s : string) : string =
let
    fun remove_head_spaces ([] : string list) : string list = []
      | remove_head_spaces (x::xs : string list) : string list =
        if isspace(x) then remove_head_spaces(xs) else x::xs;
    fun remove_spaces ([] : string list) : string list = []
      | remove_spaces ([x] : string list) : string list =
        if isspace(x) then [] else [x]
      | remove_spaces (x::y::xs : string list) : string list =
        if isspace(x)
        then
            if isspace(y)
                then remove_spaces(" "::xs)
                else " "::remove_spaces(y::xs)
        else x::remove_spaces(y::xs)
in
    implode(remove_spaces(remove_head_spaces(explode s)))
end;
=TEX
This section of code takes string and parses it into CN.
=SML
local
fun classify_label (itemlist : CN_LEX_ITEM list) : CN_LEX_ITEM list = (
	case itemlist of
	(LCOrd, _)::(LCNumericLiteral, CNText ntxt)::(LCCrd, _)::rest => (
		((case nat_of_string ntxt of
			  1 => LCCompLabel
			| 2 => LCPPartLabel
			| 3 => LCVPartLabel
			| 4 => LCDecLabel
			| 5 => LCStmtLabel
			| 6 => LCSpecLabel
			| _ => LCCompLabel
		), CNText ("("^ntxt^")"))::rest
	)|_ => itemlist
);
in
fun cn_of_string (s : string) : CNTypes.WEB_CLAUSE = (
    let
        val inp = [Lex.Text s];
    in
        (CNParser.cn_parser o (CNLex.cn_lex classify_label)) inp
    end)
end;
val cn = cn_of_string;
=TEX
The following code sets up some utilities for storing and printing the
results of this module test.
=SML
val test_results : ((string * bool) list ) ref = ref [];
fun init_test_results (() : unit) : unit = (test_results := []);
fun get_test_results (() : unit) : (string * bool) list = !test_results;
fun store_test_results (res : (string * bool) list) : (string * bool) list =
    (
    test_results := (!test_results) @ res;
    res
    );
fun failed_tests (nil : (string * bool) list) : string list = nil
  | failed_tests ((test,true)::xs) = failed_tests xs
  | failed_tests ((test,false)::xs) = test::failed_tests xs;
fun get_multiples (what : string list) : string list = (
	let
		fun strcmp x y =
			if x = y
			then 0
			else if PolyML.StringBuiltIns.lt(x,y)
			then ~1
			else 1;

		datatype TREE
			= SLeaf
			| SNode of string * int * TREE * TREE;

		fun enter (item, SLeaf) = SNode(item, 1, SLeaf, SLeaf)
		|   enter (item, SNode(x, c, l, r)) = (
			let
				val rel = strcmp item x;
			in
				if rel > 0
				then SNode(x, c, l, enter(item, r))
				else if rel < 0
				then SNode(x, c, enter(item, l), r)
				else SNode(x, c+1, l, r)
			end
		);

		fun flatten SLeaf = []
		|   flatten (SNode(x, c, l, r)) =
			flatten l
			@
			(	if c>1
				then x :: flatten r
				else flatten r
			);
	in
		flatten (fold enter what SLeaf)
	end
);
fun summarise_test_results (() : unit ) : string = (
  let
    fun pad_list ([] : string list) = "\n"
      | pad_list ([x] : string list) = "    "^x^"\n"
      | pad_list (x::xs : string list) = "    "^x^",\n"^(pad_list xs)
  in
    if get_test_results() = nil
    then
      "No tests done."
    else
    (
      (case get_multiples(map fst(get_test_results()))
        of nil => ""
         | dup_names => "Duplicated test identities:\n"^(pad_list dup_names)
      ) ^
      (case failed_tests (get_test_results())
        of nil => "All module tests passed."
         | ff  => "The following module tests failed:\n"^(pad_list ff)
      )
    )
  end
);

fun run_test_eq (eq_fun:'b*'b->bool, name:string, f:'a->'b, x:'a, r:'b) =
	(if eq_fun(f x, r) then (name, true) else (name, false))
    handle _ => (name, false);

fun eq_strngs (a, b : string) : bool =
let
	val c = to_upper(remove_most_spaces(a));
	val d = to_upper(remove_most_spaces(b));
in
	if c=d then true else false
end;

fun eq_ints (a, b : int) : bool = if a=b then true else false;

fun web_cn (x : string ) : string = fmt_web_clause (cn_of_string x, 0);

=TEX
\section{THE TESTS}
First we need to initialise the test results routine.
=SML
init_test_results();
=TEX
\subsection{Testing the Parser and Pretty Printer}
First we test some functions of the pretty printer.
=SML

store_test_results [
  run_test_eq (eq_ints, "fmt_tabs.1", length o explode o fmt_tabs,
    0, 0),
  run_test_eq (eq_ints, "fmt_tabs.2", length o explode o fmt_tabs,
    3, 3*get_PPTab_size())];

store_test_results [
  run_test_eq (eq_strngs, "fmt_id_list.1", fmt_id_list, [""], ""),
  run_test_eq (eq_strngs, "fmt_id_list.2", fmt_id_list, ["a"], "a"),
  run_test_eq (eq_strngs, "fmt_id_list.3", fmt_id_list,
    ["a","b","c","d"], "a, b, c, d")];

store_test_results [
  run_test_eq (eq_strngs, "fmt_tmark_list.1", fmt_tmark_list, [""], ""),
  run_test_eq (eq_strngs, "fmt_tmark_list.2", fmt_tmark_list, ["a"], "a"),
  run_test_eq (eq_strngs, "fmt_tmark_list.3", fmt_tmark_list,
    ["a", "b", "c", "d"], "a, b, c, d")];

store_test_results [
  run_test_eq (eq_strngs, "fmt_term.1", fmt_term, ñtrue®, "true"),
  run_test_eq (eq_strngs, "fmt_term.2", fmt_term,
    ñµ i : ú · i + 1 > i®, "µ i : ú · i + 1 > i")];

store_test_results [
  run_test_eq (eq_strngs, "fmt_label.1", fmt_label, LExplicit "(any)", "(any)"),
  run_test_eq (eq_strngs, "fmt_label.2", fmt_label, LImplicit, "")];

store_test_results [
  run_test_eq (eq_strngs, "fmt_unary_op.1", fmt_unary_op,
    UOSparkUnaryAdd, "+"),
  run_test_eq (eq_strngs, "fmt_unary_op.2", fmt_unary_op,
    UOSparkUnaryMinus, "-"),
  run_test_eq (eq_strngs, "fmt_unary_op.3", fmt_unary_op,
    UOSparkNot, "not "),
  run_test_eq (eq_strngs, "fmt_unary_op.4", fmt_unary_op,
    UOSparkAbs, "abs ")];

store_test_results [
  run_test_eq (eq_strngs, "fmt_binary_op.1", fmt_binary_op,
    BOSparkAnd, " and "),
  run_test_eq (eq_strngs, "fmt_binary_op.2", fmt_binary_op,
    BOSparkOr, " or "),
  run_test_eq (eq_strngs, "fmt_binary_op.3", fmt_binary_op,
    BOSparkXor, " xor "),
  run_test_eq (eq_strngs, "fmt_binary_op.4", fmt_binary_op,
    BOSparkEq, " = "),
  run_test_eq (eq_strngs, "fmt_binary_op.5", fmt_binary_op,
    BOSparkNotEq, " /= "),
  run_test_eq (eq_strngs, "fmt_binary_op.6", fmt_binary_op,
    BOSparkLess, " < "),
  run_test_eq (eq_strngs, "fmt_binary_op.7", fmt_binary_op,
    BOSparkLessEq, " <= "),
  run_test_eq (eq_strngs, "fmt_binary_op.8", fmt_binary_op,
    BOSparkGreater, " > "),
  run_test_eq (eq_strngs, "fmt_binary_op.9", fmt_binary_op,
    BOSparkGreaterEq, " >= "),
  run_test_eq (eq_strngs, "fmt_binary_op.10", fmt_binary_op,
    BOSparkAdd, " + "),
  run_test_eq (eq_strngs, "fmt_binary_op.11", fmt_binary_op,
    BOSparkMinus, " - "),
  run_test_eq (eq_strngs, "fmt_binary_op.12", fmt_binary_op,
    BOSparkTimes, " * "),
  run_test_eq (eq_strngs, "fmt_binary_op.13", fmt_binary_op,
    BOSparkIntdiv, " / "),
  run_test_eq (eq_strngs, "fmt_binary_op.14", fmt_binary_op,
    BOSparkMod, " mod "),
  run_test_eq (eq_strngs, "fmt_binary_op.15", fmt_binary_op,
    BOSparkRem, " rem "),
  run_test_eq (eq_strngs, "fmt_binary_op.16", fmt_binary_op,
    BOSparkExpon, " ** "),
  run_test_eq (eq_strngs, "fmt_binary_op.17", fmt_binary_op,
    BOSparkMem, " in "),
  run_test_eq (eq_strngs, "fmt_binary_op.18", fmt_binary_op,
    BOSparkNotmem, " not in "),
  run_test_eq (eq_strngs, "fmt_binary_op.19", fmt_binary_op,
    BOSparkAndThen, " and then "),
  run_test_eq (eq_strngs, "fmt_binary_op.20", fmt_binary_op,
    BOSparkConcat, " & "),
  run_test_eq (eq_strngs, "fmt_binary_op.21", fmt_binary_op,
    BOSparkOrElse, " or else ")];

store_test_results [
  run_test_eq (eq_strngs, "fmt_mode.1", fmt_mode, MSparkIn, " IN "),
  run_test_eq (eq_strngs, "fmt_mode.2", fmt_mode, MSparkOut, " OUT "),
  run_test_eq (eq_strngs, "fmt_mode.3", fmt_mode, MSparkInOut, " IN OUT ")];

store_test_results [
  run_test_eq (eq_strngs, "fmt_loop_direction.1", fmt_loop_direction,
    LDForwards, ""),
  run_test_eq (eq_strngs, "fmt_loop_direction.2", fmt_loop_direction,
    LDReverse, "REVERSE ")];

store_test_results [
  run_test_eq (eq_strngs, "fmt_operator_symbol"

local
val t = "\
\procedure test is type daysofweek is (mon, tue, wed, thur, fri, sat, sun); \
\begin null; end test;"
in
val z = store_test_results [
    run_test_eq(eq_strngs, "fmt_null.1", web_cn, t, t)
    ]
end;

local
val t = "\
\procedure test is type daysofweek is (mon, tue, wed, thur, fri, sat, sun); \
\begin x := 42; end test;"
in
val z = store_test_results [
    run_test_eq(eq_strngs, "fmt_assign.1", web_cn, t, t)
    ]
end;

local
val t = "\
\procedure test is type daysofweek is (mon, tue, wed, thur, fri, sat, sun); \
\begin „ J, K [true, true] end test;"
in
val z = store_test_results [
    run_test_eq(eq_strngs, "fmt_spec_no_ivars.1", web_cn, t, t)
    ]
end;

local
val t = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin a := 1; b := 2; end test;"
in
val z = store_test_results [
    run_test_eq(eq_strngs, "fmt_semi_colon.1", web_cn, t, t)
    ]
end;

local
val t1 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin if x = 1 then y := 11; end if; end test;";
val t2 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin if x = 1 then y := 11; else y := 3; end if; end test;"
in
val z = store_test_results [
    run_test_eq(eq_strngs, "fmt_if_then_else.1", web_cn, t1, t1),
    run_test_eq(eq_strngs, "fmt_if_then_else.2", web_cn, t2, t2)
    ]
end;

local
val t1 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin if x = 1 then y := 11; elsif x = 2 then y := 3; end if; end test;";
val t2 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin if x = 1 then y := 11; else if x = 2 then y := 3; end if; \
\end if; end test;";
val t3 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin if x = 1 then y := 11; else if x = 2 then y := 13; elsif x = 3 \
\then y := 17; elsif x = 4 then y := 19; end if; end if; end test;";
val t4 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin if x = 1 then y := 11; elsif x = 2 then y := 13; else if x = 3 \
\then y := 17; else if x = 4 then y := 19; end if; end if; end if; end test;"
in
val z = store_test_results [
    run_test_eq(eq_strngs, "fmt_elsif.1", web_cn, t1, t1),
    run_test_eq(eq_strngs, "fmt_elsif.2", web_cn, t2, t2),
    run_test_eq(eq_strngs, "fmt_elsif.3", web_cn, t3, t3),
    run_test_eq(eq_strngs, "fmt_elsif.4", web_cn, t4, t4)
    ]
end;

local
val t = "\
\procedure test is type daysofweek is (mon, tue, wed, thur, fri, sat, sun); \
\begin case x is when 1..5 => y := week; when 6|7 => y := weekend; \
\end case; end test;"
in
val z = store_test_results [
    run_test_eq(eq_strngs, "fmt_case.1", web_cn, t, t)
    ]
end;

local
val t1 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin loop a := a + 1; exit when a = 10; end loop; end test;";
val t2 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin till ûa = 10ý loop a := a + 1; exit when a = 10; end loop; end test;"
in
val z = store_test_results [
    run_test_eq(eq_strngs, "fmt_unnamed_loop.1", web_cn, t1, t1),
    run_test_eq(eq_strngs, "fmt_unnamed_loop.2", web_cn, t2, t2)
  ]
end;

local
val t1 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin testloopname: loop a := a + 1; exit when a = 10; \
\end loop testloopname; end test;";
val t2 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin testloopname: till ûa = 10ý loop a := a + 1; exit when a = 10; \
\end loop testloopname; end test;"
in
val z = store_test_results [
    run_test_eq(eq_strngs, "fmt_named_loop.1", web_cn, t1, t1),
    run_test_eq(eq_strngs, "fmt_named_loop.2", web_cn, t2, t2)
    ]
end;

local
val t1 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin while a < 10 loop a := a + 1; end loop; end test;";
val t2 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin while a < 10 till ûa = 10ý loop a := a + 1; end loop; end test;";
val t3 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin simpleloopname: while a < 10 loop a := a + 1; \
\end loop simpleloopname; end test;";
val t4 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin simpleloopname: while a < 10 till ûa = 10ý loop a := a + 1; \
\end loop simpleloopname; end test;"
in
val z = store_test_results [
    run_test_eq(eq_strngs, "fmt_while.1", web_cn, t1, t1),
    run_test_eq(eq_strngs, "fmt_while.2", web_cn, t2, t2),
    run_test_eq(eq_strngs, "fmt_while.3", web_cn, t3, t3),
    run_test_eq(eq_strngs, "fmt_while.4", web_cn, t4, t4)]
end;

local
val t1 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin for i in integer range 1..3 loop j := j + 1; end loop; end test;";
val t2 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin for i in integer range 1..3 till ûi = 30ý loop j := j + 1; \
\end loop; end test;";
val t3 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin for i in reverse integer range 1..3 loop j := j + 1; \
\end loop; end test;";
val t4 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin simpleloopname: for i in reverse integer range 1..3 till ûi = 30ý loop \
\j := j + 1; end loop simpleloopname; end test;"
in
val z = store_test_results [
    run_test_eq(eq_strngs, "fmt_for_static.1", web_cn, t1, t1),
    run_test_eq(eq_strngs, "fmt_for_static.2", web_cn, t2, t2),
    run_test_eq(eq_strngs, "fmt_for_static.3", web_cn, t3, t3),
    run_test_eq(eq_strngs, "fmt_for_static.4", web_cn, t4, t4)]
end;

local
val t1 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin for i in daysofweek loop j := j + 1; end loop; end test;";
val t2 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin for i in daysofweek till ûi = 30ý loop j := j + 1; \
\end loop; end test;";
val t3 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin for i in reverse daysofweek loop j := j + 1; \
\end loop; end test;";
val t4 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin simpleloopname: for i in reverse daysofweek till ûi = 30ý loop \
\j := j + 1; end loop simpleloopname; end test;"
in
val z = store_test_results [
    run_test_eq(eq_strngs, "fmt_for_tmark.1", web_cn, t1, t1),
    run_test_eq(eq_strngs, "fmt_for_tmark.2", web_cn, t2, t2),
    run_test_eq(eq_strngs, "fmt_for_tmark.3", web_cn, t3, t3),
    run_test_eq(eq_strngs, "fmt_for_tmark.4", web_cn, t4, t4)]
end;

=TEX
¹CN
procedure test is
subtype dayrange is integer range 1..31;
type monthrange is (jan, feb, mar, apr, may, jun, jul, aug, sep);
subtype yearrange is integer range 1..4000;
type a is range 1..4;
type date is
  record
    null
  end record;
begin
null;
end test;
°

Declaration KSLOT test
¹CN
procedure test is
x : constant real := 0.0;
y : constant real;
§ more declarations ¢
§ more declarations ¢ (1)
begin
null;
end test;
°

Representation Clause test
¹CN
procedure test is
type a is range 1 .. 4;
for a'first use 2;
for firstfew use (1..6|9 => 0);
for date use record day at 4 range 1..31; end record;
for zero use at 0;
begin
null;
end test;
°

Renaming Declarations test
¹CN
procedure test (x : in out integer) is
procedure a (x : in integer) renames a.x;
function sqrt (x : in integer) return integer renames sqrt.x;
begin
null;
end test;
°

Procedure Declaration test
¹CN
procedure test_one (x : in out integer) is

  procedure test_two (y : in out integer) is
  subtype dgts is integer range 0..9;
  begin
  printf("Procedure test_two, %%d", y);
  end test_two;

subtype tx is integer range 0..11;
begin
  printf("Procedure test_one, %%d", x);
  text_two(x);
end test_one;
°

¹CN
package body work_data is
  type day is (mon, tue, wed, thu, fri, sat, sun);
  type hours_spent is delta 0.25 range 0.0..24.0;
  type time_table is array (day) of hours_spent;
  work_hours : time_table;
  normal_hours : constant time_table := day'(mon..thu => 8.25, fro => 7.50, sat|sun => 0.0);
begin
null;
end work_data;
°
¹CN
package TRAFFIC is
  type COLOUR is (red, amber, green);
  type ROADS is (A, B, C, M);
  procedure CARS;
  function TRAFFICFLOW return real;
end TRAFFIC;
°
¹CN
procedure test is
  package body junk is separate;
begin
null;
end test;
°

¹CN
procedure test is
  normal_hours : constant time_table := day'(mon..thu => 8.25, fro => 7.50, sat|sun => 0.0);
x : constant integer := 0;
begin
null;
x := a(1..4 => 5);
end test;
°
 
:= (mon..thu => 8.25, fro => 7.50, sat|sun => 0.0);

  
-------------------------------------
don't delete this
¹CN
procedure test is
type daysofweek is (mon, tue, wed, thu, fri, sat, sun);
begin
hellothere;
end test;
°
-------------------------------------

Currently problems with:
------------------------

\section{SUMMARY OF RESULTS}

=SML
diag_line(summarise_test_results());
=TEX

\end{document}



