%  mdt503.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Compliance Notation Parser and SPARK Output Function}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT503}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
%\TPPauthor{A.C.~Hayward & WIN01}  %% Mandatory field
\TPPauthors{D.J.~King & WIN01\\A.C.~Hayward & WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{
This document comprises test cases and test code/data for
testing the DAZ parser as described in the document
ISS/HAT/DAZ/DTD503.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ A.C. Hayward\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1, \FormatDate{94/03/29}]
First version.
\item[Issue 1.2, \FormatDate{94/03/30}]
Most tests now working.
\item[Issue 1.3, \FormatDate{94/03/30}]
Changed BOSparkNotmem to BOSparkNotMem.
\item[Issue 1.4, \FormatDate{94/04/07}]
Change to web_cn since the formatting routines now return (int * string) list rather than string.
\item[Issue 1.5, \FormatDate{94/04/08}]
Change to web_cn since the formatting routines now have FmtInfo as the first argument.

\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises test cases and test code/data for
testing the DAZ Compliance Notation Parser specified in \cite{ISS/HAT/DAZ/DTD503}, and for the DAZ SPARK Output Function as specified in \cite{ISS/HAT/DAZ/DTD510}.

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the DAZ Compliance Notation Parser as defined in \cite{ISS/HAT/DAZ/DTD503} and implemented in \cite{ISS/HAT/DAZ/IMP503}, and for the DAZ SPARK Output Function as defined in \cite{ISS/HAZ/DAZ/DTD510} and implemented in \cite{ISS/HAT/DAZ/IMP510}. The tests are intended to meet the requirements for tests identified in the quality plan \cite{ISS/HAT/DAZ/PLN003}.

\subsubsection{Dependencies}

These tests depend on the test harness as implemented in DS/FMU/IED/IMP013, and its corresponding detailed design document, DS/FMU/IED/DTD013.

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

There are no known deficiencies.


\section{INITIALISATION}
First we need to load the test harnes and initialise it.

=SML
use_file "dtd013";
use_file "imp013";
init_mt_results();
=TEX

\section{PREAMBLE}
Set up the theory database as necessary.

=SML

open_theory "daz_toolkit_extensions";
force_delete_theory "mdt503" handle (_) => ();
new_theory "mdt503";
=TEX

=SML
local
	open	CNTypes CNPrettyPrinterSupport;
in
=TEX

\section{SUPPORTING FUNCTIONS}

A couple functions needed for comparing the input to the Parser and the string generated by the SPARK Output Function.

=SML

val white_space_set = [" ", "\n", "\t"];
fun isspace (x : string) : bool = x mem white_space_set;
fun to_upper x = CaseIndependence.to_upper x;
fun remove_most_spaces (s : string) : string =
let	fun remove_head_spaces ([] : string list) : string list = []
	  | remove_head_spaces (x::xs : string list) : string list =
		if isspace(x) then remove_head_spaces(xs) else x::xs;
	fun remove_spaces ([] : string list) : string list = []
	  | remove_spaces ([x] : string list) : string list =
		if isspace(x) then [] else [x]
	  | remove_spaces (x::y::xs : string list) : string list =
		if isspace(x)
		then
			if isspace(y)
			then	remove_spaces(" "::xs)
			else	" "::remove_spaces(y::xs)
		else x::remove_spaces(y::xs)
in
	implode(remove_spaces(remove_head_spaces(explode s)))
end;

=TEX

Two functions which compare their arguments, and return true or false.
The first compares strings, ignoring case and extra spaces.

=SML

fun Ûeq_strngsÝ (a, b : string) : bool =
let
  val c = to_upper(remove_most_spaces(a));
  val d = to_upper(remove_most_spaces(b));
in
  if c=d then true else false
end;

fun Ûeq_intsÝ (a, b : int) : bool = if a=b then true else false;

=TEX

Function which takes a string and passes it through the parser and then
the SPARK Output Function.

=SML

fun Ûweb_cnÝ (x : string ) : string =
    fmt_info_string_list(fmt_web_clause
	{tabs=0, line_length=80, fmtfn= Nil} (cn_of_string x));
=IGN
ACH wrote...
fun web_cn (x : string ) : string =
    fmt_int_string_list(fmt_web_clause 0 (cn_of_string x));
=TEX

\section{THE TESTS}

\subsection{Testing the Parser and SPARK Output Function}
\subsubsection{Basic output functions}

=SML

val oldtab = get_PPTab_size();
val _ = store_mt_results (mt_runf eq_ints) [
  ("PPTab_size.1", get_PPTab_size o set_PPTab_size, 9, 9),
  ("PPTab_size.2", get_PPTab_size o set_PPTab_size, 3, 3)];
val _ = set_PPTab_size (oldtab);
val _ = store_mt_results (mt_runf eq_ints) [
  ("fmt_tabs.1", length o explode o fmt_tabs, 0, 0),
  ("fmt_tabs.2", length o explode o fmt_tabs, 3, 3*get_PPTab_size())];

=TEX

\subsubsection{Lowest level functions}

=SML

val _ = store_mt_results (mt_runf eq_strngs) [
  ("fmt_term.1", fmt_term, ñtrue®, "true"),
  ("fmt_term.2", fmt_term, ñµ i : ú · i + 1 > i®, "µ i : ú · i + 1 > i")];
val _ = store_mt_results (mt_runf eq_strngs) [
  ("fmt_label.1", fmt_label, "(any)", "(any)")];
val _ = store_mt_results (mt_runf eq_strngs) [
  ("fmt_unary_op.1", fmt_unary_op, UOSparkUnaryAdd, "+"),
  ("fmt_unary_op.2", fmt_unary_op, UOSparkUnaryMinus, "-"),
  ("fmt_unary_op.3", fmt_unary_op, UOSparkNot, "not "),
  ("fmt_unary_op.4", fmt_unary_op, UOSparkAbs, "abs ")];
val _ = store_mt_results (mt_runf eq_strngs) [
  ("fmt_binary_op.1", fmt_binary_op, BOSparkAnd, " and "),
  ("fmt_binary_op.2", fmt_binary_op, BOSparkOr, " or "),
  ("fmt_binary_op.3", fmt_binary_op, BOSparkXor, " xor "),
  ("fmt_binary_op.4", fmt_binary_op, BOSparkEq, " = "),
  ("fmt_binary_op.5", fmt_binary_op, BOSparkNotEq, " /= "),
  ("fmt_binary_op.6", fmt_binary_op, BOSparkLess, " < "),
  ("fmt_binary_op.7", fmt_binary_op, BOSparkLessEq, " <= "),
  ("fmt_binary_op.8", fmt_binary_op, BOSparkGreater, " > "),
  ("fmt_binary_op.9", fmt_binary_op, BOSparkGreaterEq, " >= "),
  ("fmt_binary_op.10", fmt_binary_op, BOSparkAdd, " + "),
  ("fmt_binary_op.11", fmt_binary_op, BOSparkMinus, " - "),
  ("fmt_binary_op.12", fmt_binary_op, BOSparkTimes, " * "),
  ("fmt_binary_op.13", fmt_binary_op, BOSparkIntdiv, " / "),
  ("fmt_binary_op.14", fmt_binary_op, BOSparkMod, " mod "),
  ("fmt_binary_op.15", fmt_binary_op, BOSparkRem, " rem "),
  ("fmt_binary_op.16", fmt_binary_op, BOSparkExpon, " ** "),
  ("fmt_binary_op.17", fmt_binary_op, BOSparkMem, " in "),
  ("fmt_binary_op.18", fmt_binary_op, BOSparkNotMem, " not in "),
  ("fmt_binary_op.19", fmt_binary_op, BOSparkAndThen, " and then "),
  ("fmt_binary_op.20", fmt_binary_op, BOSparkConcat, " & "),
  ("fmt_binary_op.21", fmt_binary_op, BOSparkOrElse, " or else ")];
val _ = store_mt_results (mt_runf eq_strngs) [
  ("fmt_mode.1", fmt_mode, MSparkIn, " IN "),
  ("fmt_mode.2", fmt_mode, MSparkOut, " OUT "),
  ("fmt_mode.3", fmt_mode, MSparkInOut, " IN OUT ")];
val _ = store_mt_results (mt_runf eq_strngs) [
  ("fmt_loop_direction.1", fmt_loop_direction, LDForwards, ""),
  ("fmt_loop_direction.2", fmt_loop_direction, LDReverse, "REVERSE ")];
val _ = store_mt_results (mt_runf eq_strngs) [
  ("fmt_operator_symbol.1", fmt_operator_symbol, "add", "add"),
  ("fmt_operator_symbol.2", fmt_operator_symbol, "any_string", "any_string")];
val _ = store_mt_results (mt_runf eq_strngs) [
  ("fmt_id_list.1", fmt_id_list, [""], ""),
  ("fmt_id_list.2", fmt_id_list, ["a"], "a"),
  ("fmt_id_list.3", fmt_id_list, ["a","b","c","d"], "a, b, c, d")];
val _ = store_mt_results (mt_runf eq_strngs) [
  ("fmt_tmark_list.1", fmt_tmark_list, [""], ""),
  ("fmt_tmark_list.2", fmt_tmark_list, ["a"], "a"),
  ("fmt_tmark_list.3", fmt_tmark_list, ["a", "b", "c", "d"], "a, b, c, d")];
val _ = store_mt_results (mt_runf eq_strngs) [
  ("fmt_z_pred", fmt_z_pred, ñtrue®, "ñtrue®"),
  ("fmt_z_exp", fmt_z_exp, ñtrue®, "ñtrue®")];
val _ = store_mt_results (mt_runf eq_strngs) [
  ("fmt_z_id", fmt_z_id, "any_valid_identifier", "any_valid_identifier"),
  ("fmt_attrib", fmt_attrib, "any_valid_identifier", "any_valid_identifier"),
  ("fmt_int_lit", fmt_int_lit, "1234567890", "1234567890")];

=TEX

\subsubsection{Expressions}

=SML
local
val t = "\
\procedure expression_test is begin \
\x := p'(integer range 1..4 => 0); \
\x := p'(1..4 => 0); \
\x := p'(a|b|c => 0, d => 1); \
\x := p'(1, 3, 5, 7); \
\x := p'(1, 2, others => 42); \
\x := p'(others => 42); \
\x := p'(a => 1, b => 3, c => 5, d => 7); \
\x := p'(a => 1, b => 3, others => 42); \
\y := +42.0; \
\y := -42.0; \
\y := not true; \
\y := abs (-42.0); \
\y := (true and false) or (true xor false); \
\y := (2 * 3 + 4 / 5); \
\z := real'digits; \
\z := r'digits(2); \
\z := r(1, 2, 3); \
\z := r.first; \
\end expression_test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
  ("Expressions.1", web_cn, t, t)]
end;

=TEX

\subsubsection{Statements}

Test for fmt\_null;

=SML

local
val t = "\
\procedure test is type d is (mon, tue, wed, thu, fri, sat, sun); \
\begin null; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("fmt_null.1", web_cn, t, t)]
end;

=TEX

Test for fmt\_assign.

=SML

local
val t = "\
\procedure test is type d is (mon, tue, wed, thur, fri, sat, sun); \
\begin x := 42; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("fmt_assign.1", web_cn, t, t)]
end;

=TEX

Test for fmt\_spec\_no\_ivars.

=SML

local
val t = "\
\procedure test is type daysofweek is (mon, tue, wed, thur, fri, sat, sun); \
\begin „ J, K [true, true] (3) end test;";
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("fmt_spec_no_ivars.1", web_cn, t, t)]
end;

=TEX

Test for fmt\_semi\_colon;

=SML

local
val t = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin a := 1; b := 2; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("fmt_semi_colon.1", web_cn, t, t)]
end;

=TEX

Test for fmt\_return.

=SML

local
val t = "\
\function test (x : in real) return real is \
\y : real; begin y := x * x; return y; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("fmt_return.1", web_cn, t, t)]
end;

=TEX

Test for fmt\_proc\_call and fmt\_proc\_call\_no\_ivars.

=SML

local
val t = "\
\procedure test (x : in real) is y : real; \
\begin prtsqr (x); end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("fmt_proc_call_no_ivars.1", web_cn, t, t)]
end;

=TEX

Test for fmt\_if\_then\_else.

=SML

local
val t1 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin if x = 1 then y := 11; end if; end test;";
val t2 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin if x = 1 then y := 11; else y := 3; end if; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("fmt_if_then_else.1", web_cn, t1, t1),
    ("fmt_if_then_else.2", web_cn, t2, t2)]
end;

=TEX

Test for fmt\_elsif.

=SML

local
val t1 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin if x = 1 then y := 11; elsif x = 2 then y := 3; end if; end test;";
val t2 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin if x = 1 then y := 11; else if x = 2 then y := 3; end if; \
\end if; end test;";
val t3 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin if x = 1 then y := 11; else if x = 2 then y := 13; elsif x = 3 \
\then y := 17; elsif x = 4 then y := 19; end if; end if; end test;";
val t4 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin if x = 1 then y := 11; elsif x = 2 then y := 13; else if x = 3 \
\then y := 17; else if x = 4 then y := 19; end if; end if; end if; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("fmt_elsif.1", web_cn, t1, t1),
    ("fmt_elsif.2", web_cn, t2, t2),
    ("fmt_elsif.3", web_cn, t3, t3),
    ("fmt_elsif.4", web_cn, t4, t4)]
end;

=TEX

Test for fmt\_case.

=SML

local
val t = "\
\procedure test is type daysofweek is (mon, tue, wed, thur, fri, sat, sun); \
\begin case x is when 1..5 => y := week; when 6|7 => y := weekend; \
\end case; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("fmt_case.1", web_cn, t, t)
    ]
end;

=TEX

Test for fmt\_exit\_when.

=SML

local
val t1 = "\
\procedure test is type d is (mon, tue, wed, thu, fri, sat, sun); \
\begin loop get_char (ch); exit when ch = ' '; end loop; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("fmt_exit_when.1", web_cn, t1, t1)];
end;

=TEX

Test for fmt\_unnamed\_loop.

=SML

local
val t1 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin loop a := a + 1; exit when a = 10; end loop; end test;";
val t2 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin till ûa = 10ý loop a := a + 1; exit when a = 10; end loop; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("fmt_unnamed_loop.1", web_cn, t1, t1),
    ("fmt_unnamed_loop.2", web_cn, t2, t2)
  ]
end;

=TEX

Test for fmt\_named\_loop.

=SML

local
val t1 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin testloopname: loop a := a + 1; exit when a = 10; \
\end loop testloopname; end test;";
val t2 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin testloopname: till ûa = 10ý loop a := a + 1; exit when a = 10; \
\end loop testloopname; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("fmt_named_loop.1", web_cn, t1, t1),
    ("fmt_named_loop.2", web_cn, t2, t2)
    ]
end;

=TEX

Test for fmt\_while.

=SML

local
val t1 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin while a < 10 loop a := a + 1; end loop; end test;";
val t2 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin while a < 10 till ûa = 10ý loop a := a + 1; end loop; end test;";
val t3 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin simpleloopname: while a < 10 loop a := a + 1; \
\end loop simpleloopname; end test;";
val t4 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin simpleloopname: while a < 10 till ûa = 10ý loop a := a + 1; \
\end loop simpleloopname; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("fmt_while.1", web_cn, t1, t1),
    ("fmt_while.2", web_cn, t2, t2),
    ("fmt_while.3", web_cn, t3, t3),
    ("fmt_while.4", web_cn, t4, t4)]
end;

=TEX

Test for fmt\_for\_static.

=SML

local
val t1 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin for i in integer range 1..3 loop j := j + 1; end loop; end test;";
val t2 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin for i in integer range 1..3 till ûi = 30ý loop j := j + 1; \
\end loop; end test;";
val t3 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin for i in reverse integer range 1..3 loop j := j + 1; \
\end loop; end test;";
val t4 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin simpleloopname: for i in reverse integer range 1..3 till ûi = 30ý loop \
\j := j + 1; end loop simpleloopname; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("fmt_for_static.1", web_cn, t1, t1),
    ("fmt_for_static.2", web_cn, t2, t2),
    ("fmt_for_static.3", web_cn, t3, t3),
    ("fmt_for_static.4", web_cn, t4, t4)]
end;

=TEX

Test for fmt\_for\_tmark.

=SML

local
val t1 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin for i in daysofweek loop j := j + 1; end loop; end test;";
val t2 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin for i in daysofweek till ûi = 30ý loop j := j + 1; \
\end loop; end test;";
val t3 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin for i in reverse daysofweek loop j := j + 1; \
\end loop; end test;";
val t4 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\begin simpleloopname: for i in reverse daysofweek till ûi = 30ý loop \
\j := j + 1; end loop simpleloopname; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("fmt_for_tmark.1", web_cn, t1, t1),
    ("fmt_for_tmark.2", web_cn, t2, t2),
    ("fmt_for_tmark.3", web_cn, t3, t3),
    ("fmt_for_tmark.4", web_cn, t4, t4)]
end;

=TEX

Test for fmt\_log\_con.

=SML

local
val t = "procedure test is begin CON z : ú · „ x, y [true, true] (4) end test;";
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("fmt_log_con.1", web_cn, t, t)]
end;

=TEX

\subsubsection{Type Declarations}

=SML

local
val t1 = "\
\procedure test is type a is (mon, tue, wed, thu, fri, sat, sun); \
\subtype b is integer range 1..10; type c is array (b) of a; \
\x, y, z : real; u, v, w : integer; p, q : c; zero : constant integer := 0; \
\one : constant integer := 1; two : constant integer; begin null; end test;";
val t2 = "\
\procedure test is type device is (printer, disk, CD); \
\type state is (online, offline); type peripheral unit : device is \
\record status : state; case unit is when printer => line_count : integer; \
\when disk|CD => cylinder : integer; track : integer; end case; end record; \
\begin null; end test;";
val t3 = "\
\procedure test is type a is digits 4; type b is digits 4 range 0.0..120.0; \
\type c is delta 0.125; type d is delta 0.125 range -1.0..5.0; \
\begin null; end test;";
val t4 = "\
\procedure test is type daysofweek is (mon, tue, wed, thu, fri, sat, sun); \
\type monthnames is (jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, \
\dec); begin null; end test;";
val t5 = "\
\procedure test is type a is array (integer range <>, s range <>) of real; \
\begin null; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("Variables.1", web_cn, t1, t1),
    ("Records.1", web_cn, t2, t2),
    ("Reals.1", web_cn, t3, t3),
    ("Enumerated.1", web_cn, t4, t4),
    ("Array.1", web_cn, t5, t5)]
end;

=TEX

\subsubsection{Other Declarations}

Test for Subtype declarations.

=SML

local
val t = "\
\procedure test is subtype a is integer range 1..10; \
\subtype b is real digits 4; subtype c is real digits 4 range -1.0..5.0; \
\subtype d is real delta 0.125; subtype e is real delta 0.125 range 0.0..42.0; \
\begin null; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("Subtype.1", web_cn, t, t)]
end;

=TEX

Test for Private declarations.

=SML

local
val t = "\
\procedure test is type a is private; type b is limited private; \
\begin null; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("Private.1", web_cn, t, t)]
end;

=TEX

Test for K slot declarations.

=SML

local
val t = "\
\procedure test is x : constant real := 0.0; y : constant real; \
\§more declarations ¢ (1) §more declarations ¢ (2) begin null; end test;";
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("KSlot.1", web_cn, t, t)]
end;

=TEX

Test for Procedure and Function specifications.

=SML

local
val t = "\
\procedure test (x : in integer; y : out real; z : in out real) is \
\function test2 (a : in real) return real is begin return (a * a); end test2; \
\begin null; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("Procedures&Functions.1", web_cn, t, t)]
end;

=TEX

Test for Renaming declarations.

=SML

local
val t = "\
\procedure test (x : in out integer) is \
\procedure a (x : in integer) renames a.x; \
\function sqrt (x : in integer) return integer renames x.sqrt; \
\function a return b renames c.d; \
\begin null; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("Renaming.1", web_cn, t, t)]
end;

=IGNORE

Until cn_of_string is improved we can't use this test because of the
string literals.

local
val t = "function \"sqrt\" (x : in integer) return integer renames x.\"sqrt\";"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("Renaming.2", web_cn, t, t)]
end;

=TEX

Test for Representation Clauses.

=SML

local
val t = "\
\procedure test is type a is range 1..4; for a'first use 2; \
\for firstfew use (1..6|9 => 0); for date use record day at 4 range 1..31; \
\end record; for zero use at 0; begin null; end test;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("Representation.1", web_cn, t, t)]
end;

=TEX

\subsubsection{Compilation Units}

Test for Procedure, Function and Package Declarations, also Context Compilation Units and lists of Compilation Units.

=SML

local
val t = "\
\with one, two, three; package testone is procedure testtwo; \
\function testthree return real; end testone; package testfour is \
\procedure testfive; end testfour;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("Compilation.1", web_cn, t, t)]
end;

=TEX

Test for Procedure, Function and Package Stubs, also tests Package Body.

=SML

local
val t = "\
\package body testone is procedure testtwo is separate; \
\function testthree return real is separate; \
\package body testfour is separate; end testone;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("Stubs.1", web_cn, t, t)]
end;

=TEX

Test for Subunits.

=SML

local
val t = "\
\separate (testone) package body testone is procedure testtwo is \
\begin null; end testtwo; function testthree return real is \
\begin return (0.0); end testthree; end testone;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("Subunits.1", web_cn, t, t)]
end;

=TEX

Tests for the other forms of Web Clauses.

=SML

local
val t1 = "(1) é procedure test is begin null; end test;";
val t2 = "(2) é type a is range 1..10;";
val t3 = "(3) é type a is range 1..42;";
val t4 = "(4) é x : integer;";
val t5 = "(6) Ã x := 0.0;";
val t6 = "(6) é x := 0.0;"
in
val _ = store_mt_results (mt_runf eq_strngs) [
    ("ReplacedComp.1", web_cn, t1, t1),
    ("ReplacedPrivate.1", web_cn, t2, t2),
    ("ReplacedVisible.1", web_cn, t3, t3),
    ("ReplacedDecl.1", web_cn, t4, t4),
    ("Refinedby.1", web_cn, t5, t5),
    ("Replacedby.1", web_cn, t6, t6)]
end;

=TEX

\section{SUMMARY OF RESULTS}

=SML
end (* local...in *);

diag_line(summarize_mt_results());

=TEX

\end{document}
