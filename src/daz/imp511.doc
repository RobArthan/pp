% imp511.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Z Output Function}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP511}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{CN}
\TPPauthor{A.C.~Hayward & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the Z output function.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1, \FormatDate{94/07/11}]
Initial Draft.
\item[Issues 1.2, 1.3, 1.4 \FormatDate{94/07/11}]
Bug fixing
\item[Issue 1.5 \FormatDate{94/07/14}]
Minor typographical corrections.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD511}.  The module tests are in \cite{ISS/HAT/DAZ/WRK501}.
\subsection{Introduction}
\subsection{Purpose and Background}
\subsection{Algorithms}
\subsection{Dependencies}
\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX
\section{Start of Structure z_output}
\subsection{Preamble}
=SML
structure €CNZOutput› : CNZOutput = struct
local
        open icl'Kernel;
        open PrettyPrinter;
        open ZUserInterfaceSupport;
in
=TEX

\subsection{Dictionary}

Functions to break apart user data types.

=SML
fun €dest_ud_string› (UD_String (n, uds)) = (n, uds)
|   dest_ud_string _ = fail "" 0 [] (* Caller MUST catch this! *);
fun €dest_ud_int› (UD_Int (n, uds)) = (n, uds)
|   dest_ud_int _ = fail "" 0 [] (* Caller MUST catch this! *);
=TEX

Datatype used while storing information in the Dictionary.
=SML
datatype Z_DOC_PARAGRAPH = PTAxiom of THM
                           | PTDefn of THM
                           | PTVC of string * TERM
                           | PTFixity of CLASS * TEMPLATE
                           | PTSpec of string
                           | PTSubunit of string * int
                           | PTParent of string;
=TEX

Number governing the position of the fixity paragraphs in the output document.  Set to zero ensures they all appear at the beginning.

=SML
val €z_output_fixity_num› = 0;
=TEX

Function to add a new element to our sorted list.

=SML
local
    fun €add_sorted› ([],[]) (a,b) = [(a,b)]
    |   add_sorted (ys,rest as ((xy as (x, _))::xs)) (ab as (a, _) : int*'a) =
        (   if a<x
            then ys@ (ab ::  rest) 
            else add_sorted (ys@[xy],xs) ab )
    |   add_sorted (xs,[]) ab = (xs@[ab])
in
    fun €add_sorted_to_list› (xs : (int*'a) list)
        (x : int*'a) = (add_sorted ([],xs) x)
end;
=TEX

Function to remove everything in the sorted list before a given number.

=SML
fun €delete_sorted› ([]) (n : int) = []
|   delete_sorted ((a,b)::xs) (n : int) =
    (if a<=n then [] else [(a,b)])@(delete_sorted xs n);
=TEX

Functions to add a single element of each type to our dictionary.

=SML
fun €add_sort_defn› (dict) ((nms, thm) : (string list * THM)) =
    let val num = #level(icl'dest_thm thm);
    in
        add_sorted_to_list dict (num, (PTDefn thm))
    end;
fun €add_sort_axiom› (dict) ((nms, thm) : (string list * THM))  =
    let val num = #level(icl'dest_thm thm);
    in
        add_sorted_to_list dict (num, (PTAxiom thm))
    end;
fun €add_sort_vc› (dict) ((nms, (num, tm)) : (string list * (int * TERM))) =
    let val nm = hd nms
    in
        add_sorted_to_list dict (num, (PTVC (nm,tm)))
    end;
fun €add_sort_fix› (dict) ((clss, tmpl) : (CLASS * TEMPLATE)) =
    add_sorted_to_list dict (z_output_fixity_num, (PTFixity (clss, tmpl)));
fun €add_sort_create_spec› (dict) ((num, thy) : int * string) =
    add_sorted_to_list dict (num, (PTSpec thy));
fun €add_sort_create_subunit› (dict) ((num, (thy,level)) : int * (string * int)) =
    add_sorted_to_list dict (num, (PTSubunit (thy,level)));
fun €add_sort_new_parent› (dict) ((num, thy) : int * string) =
    add_sorted_to_list dict (num, (PTParent thy));
=TEX

Functions to add lists of elements to our dictionary.
=SML
fun €add_sort_defns› (dict) ([] : (string list * THM) list) = dict
|   add_sort_defns (dict) (defn::defns : (string list * THM) list) =
    let val newdict = add_sort_defn dict defn
    in
        add_sort_defns newdict defns
    end;
fun €add_sort_axioms› (dict) ([] : (string list * THM) list) = dict
|   add_sort_axioms (dict) (axm::axms : (string list * THM) list) =
    let val newdict = add_sort_axiom dict axm
    in
        add_sort_axioms newdict axms
    end;
fun €add_sort_vcs› (dict) ([] : (string list * (int * TERM)) list) = dict
|   add_sort_vcs (dict) (vc::more : (string list * (int*TERM)) list) =
    let val newdict = add_sort_vc dict vc
    in
        add_sort_vcs newdict more
    end;
fun €add_sort_fixs› (dict) ([] : (CLASS * TEMPLATE) list ) = dict
|   add_sort_fixs (dict) (fix::fixs : (CLASS * TEMPLATE) list) =
    let val newdict = add_sort_fix dict fix
    in
        add_sort_fixs newdict fixs
   end;
fun €add_sort_create_specs› (dict) ([] : USER_DATUM list) = dict
|   add_sort_create_specs (dict) (spec::xs : USER_DATUM list) =
    let val thy = (fst o dest_ud_string) spec;
        val num = (fst o dest_ud_int o hd o snd o dest_ud_string) spec;
        val newdict = add_sort_create_spec dict (num, thy)
    in
        add_sort_create_specs newdict xs
    end;
fun €add_sort_create_subunits› (dict) ([] : USER_DATUM list) = dict
|   add_sort_create_subunits (dict) (subunit::xs : USER_DATUM list) =
    let val thy = (fst o dest_ud_string) subunit;
        val num = (fst o dest_ud_int o hd o snd o dest_ud_string) subunit;
        val thy_level = (fst o dest_ud_int o hd o snd o dest_ud_int o hd o snd o dest_ud_string) subunit;
        val newdict = add_sort_create_subunit dict (num, (thy,thy_level))
    in
        add_sort_create_subunits newdict xs
    end;
fun €add_sort_new_parents› (dict) ([] : USER_DATUM list) = dict
|   add_sort_new_parents (dict) (parent::xs : USER_DATUM list) =
    let val thy = (fst o dest_ud_string) parent;
        val num = (fst o dest_ud_int o hd o snd o dest_ud_string) parent;
        val newdict = add_sort_new_parent dict (num, thy)
    in
        add_sort_new_parents newdict xs
    end;
=TEX 

These functions get some of the information we require from the theory user data.

=SML
fun €get_create_specs› (thy : string) : USER_DATUM list =
    (snd o dest_ud_string o get_user_datum thy) "CN'createspec"
        handle Fail _ => [];
fun €get_create_subunits› (thy : string) : USER_DATUM list =
    (snd o dest_ud_string o get_user_datum thy) "CN'createsubunit"
        handle Fail _ => [];
fun €get_new_parents› (thy : string) : USER_DATUM list =
    (snd o dest_ud_string o get_user_datum thy) "CN'newparent"
        handle Fail _ => [];
=TEX

These functions take a theory name as an argument, and add the relevant parts from that theory to our dictionary.

=SML
fun €add_defns› (dict) (thyn : string) =
    let val defns = rev(get_defns thyn)
    in
        add_sort_defns dict defns
    end;
fun €add_axioms› (dict) (thyn : string) =
    let val axms = rev(get_axioms thyn)
    in
        add_sort_axioms dict axms
    end;
fun €add_vcs› (dict) (thyn : string) =
    let val vcl = rev(get_conjectures thyn)
    in
        add_sort_vcs dict vcl
    end;
fun €add_fixs› (dict) (thyn : string) =
    let val fixs = rev(get_zfixity_infos thyn)
    in
        add_sort_fixs dict fixs
    end;
fun €add_create_specs› (dict) (thyn : string) =
    add_sort_create_specs dict (get_create_specs thyn);
fun €add_create_subunits› (dict) (thyn : string) =
    add_sort_create_subunits dict (get_create_subunits thyn);
fun €add_new_parents› (dict) (thyn : string) =
    add_sort_new_parents dict (get_new_parents thyn);
=TEX

\subsection{Formatting}

z\_thm\_rule is used to strip the Z Paragraph header from a theorem.
=SML
val €z_thm_rule› : THM -> THM = conv_rule (TRY_C z_para_pred_conv);
=TEX

Information needed by the formatting functions.
=SML
val €z_output_tab_width› = 4;
fun €z_output_mk_tab› (i : int) =
    (if i = 0 then "" else " "^(z_output_mk_tab (i-1)));
val €z_output_tab› = (z_output_mk_tab z_output_tab_width);
val €z_output_ll› = get_line_length();
=TEX

Generally useful functions
=SML
fun €fmt_string_list› ([] : string list) = ""
|   fmt_string_list (x::xs : string list) =
    x^"\n"^(fmt_string_list xs);
fun €concat_string_list› ([] : string list) =""
|   concat_string_list (x::xs : string list) =
        x^(concat_string_list xs);
fun €fmt_semi_colon› ([] : string list) = []
|   fmt_semi_colon ([x] : string list) = [x^";"]
|   fmt_semi_colon (x::xs : string list) = [x]@(fmt_semi_colon xs);
fun €fmt_body› ([] : string list) = []
|   fmt_body (x::xs : string list) = ["‹ "^x]@(fmt_body xs);
fun €fmt_prefix_tab› ([] : string list) = []
|   fmt_prefix_tab (x::xs : string list) =
        [z_output_tab^x]@(fmt_prefix_tab xs);
fun €dest_z_many_±› (t : TERM) =
    if (is_z_± t)
        then
            (dest_z_many_± (fst (dest_z_± t)))@
            (dest_z_many_± (snd (dest_z_± t)))
        else [t];
=TEX

Formatting functions for Declarations.
=SML
fun €fmt_var› (ZGVar (n,_,_) : Z_TERM, x) = n
|   fmt_var (ZLVar (n,_,_) : Z_TERM, x) = n
|   fmt_var (_ : Z_TERM, x) =
        fail "fmt_var" 511001 [fn () => string_of_term x];
fun €fmt_var_list› ([] : TERM list) = ""
|   fmt_var_list ([x] : TERM list) = (fmt_var ((dest_z_term x),x))
|   fmt_var_list (x::xs : TERM list) =
        (fmt_var ((dest_z_term x),x))^", "^(fmt_var_list xs);

fun €fmt_dec› (dec : TERM) = (
	[let	val (v, t) = dest_z_dec dec;
	in (fmt_var_list v)^" : "^(concat_string_list (format_term false t))
	end	handle Fail _ => (
		let	val (s, d) = dest_z_schema_dec dec
				handle Fail _ => (snd(dest_app dec), "");
		in	concat_string_list (format_term false s) ^ d
		end		
	)]
);

fun €fmt_dec_list› ([] : TERM list) = []
|   fmt_dec_list ([x] : TERM list) = (fmt_dec x)
|   fmt_dec_list (x::xs : TERM list) =
    (fmt_semi_colon (fmt_dec x))@(fmt_dec_list xs);
=TEX

Formatting functions for Predicates.
=SML
fun €fmt_pred_list› ([] : TERM list) = []
|   fmt_pred_list ([x]: TERM list) = (format_term false x)
|   fmt_pred_list (x::xs : TERM list) =
    (fmt_semi_colon (format_term false x))@(fmt_pred_list xs);
=TEX

Formatting functions for Z Schema Boxes
=SML
fun €fmt_schbox_name› (t : TERM) =
    let val s = (concat_string_list (format_term false t))
    in
=SMLLITERAL
        ["ˇ "^s^" ¸¸¸¸¸¸¸¸"]
=SML
    end;
fun €fmt_schbox› (defn : THM) =
    let val (_,schema) = dest_thm (z_thm_rule defn);
        val (name,body) = dest_eq (snd (strip_µ schema));
        val (decl, pred) = dest_z_h_schema body;
    in
        (fmt_schbox_name name)@
        (fmt_body (fmt_dec_list (dest_z_decl decl)))@
=SMLLITERAL
        ["˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸"]@
=SML
        (fmt_body (fmt_pred_list (dest_z_many_± pred)))@
=SMLLITERAL
        ["à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸"]
=SML
    end;
=TEX

Formatting functions for Z Abbreviation Definations
=SML
local
    fun fmt_abbdef_aux1 (varstr,expstr) =
        let val block = varstr@[" ¶ "]@expstr
    in
        ["πZ"]@(fmt_body [concat_string_list block])@["∞"]
    end;
    fun fmt_abbdef_aux2 (varstr,expstr) =
    
    ["πZ"]@
    (fmt_body [concat_string_list (varstr@[" ¶"])])@
    (fmt_body expstr)@["∞"];
in
    fun €fmt_abbdef› (defn : THM) =
        let val (var,exp) = dest_eq (snd (dest_thm (z_thm_rule defn)));
            val varstr = (format_term false var);
            val expstr = (format_term false exp);
            val block = (concat_string_list (varstr@expstr))
            val n = (z_output_ll-(2*z_output_tab_width))
        in
            if ((length o explode) block) < n
                then
                    fmt_abbdef_aux1 (varstr,expstr)
                else
                    fmt_abbdef_aux2 (varstr,expstr)
        end;
end;
=SML
    fun fmt_gset (gset : TERM) = (
        ["πZ", "[" ^ fmt_var(dest_z_term gset, gset) ^ "]" , "∞"]
	);
=TEX

Formatting functions for Definitions
=SML
fun €fmt_defns› (defn : THM) = (
	let	val (_,p) = (dest_thm defn);
		val (q,_) = (dest_app p);
	in let    val (r,_) = (dest_const q);
	in	if r = "Z'AbbDef"
		then	fmt_abbdef (defn)
		else if	 r = "Z'SchBox"
		then	fmt_schbox (defn)
		else	thm_fail "fmt_defns" 511002 [defn]
	end	handle Fail _ => 
		let	val (gset, u) = dest_eq p;
		in	if	is_u u
			then	fmt_gset gset
			else	thm_fail "fmt_defns" 511002 [defn]
		end
	end	handle Fail _ => thm_fail "fmt_defns" 511002 [defn]
);
=TEX

Formatting functions for Axioms
=SML
fun get_declared_consts (decl : TERM) : TERM list = (
	let	fun do_decs acc [] = acc
		|   do_decs acc (dec :: decs) = (
			(do_decs (fst (dest_z_dec dec) @ acc) decs)
			handle Fail _ =>
			let 	val bdg = (hd o snd o strip_app) dec;
			in	do_decs (map snd (dest_z_binding bdg) @ acc) decs
			end
		);
	in	do_decs [] (dest_z_decl decl)
	end
);
=SML
fun €fmt_axioms› (axiom : THM) =
    let val (_,axm) = dest_thm axiom;
        val (_,gbody) = dest_app axm;
	 val (gpars, body) = strip_µ gbody;
        val (decl,pred) = dest_± body;
    in	case gpars of
		[] => (
=SMLLITERAL
        ["πZAX"]@
=SML
        (fmt_body (fmt_dec_list (dest_z_decl decl)))@
=SMLLITERAL
        ["˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸"]@
=SML
        (fmt_body (fmt_pred_list (dest_z_many_± pred)))@
=SMLLITERAL
        ["∞"]
=SML
	) | _ :: _ => (
		let	val subs1 = map (fn t => (mk_u(type_of t), t)) gpars;
			val consts = get_declared_consts decl;
			val subs2 = map (fn c => (subst subs1 c, c)) consts;
			val decl' = subst subs2 decl;
			val pred' = subst subs2 pred;
		in
=SMLLITERAL
        ["ù[" ^ fmt_var_list gpars ^ "]úúúúúúúú"]@
=SML
        (fmt_body (fmt_dec_list (dest_z_decl decl')))@
=SMLLITERAL
        ["˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸"]@
=SML
        (fmt_body (fmt_pred_list (dest_z_many_± pred')))@
=SMLLITERAL
        ["à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸"]
		end
=SML
)
   end;
=TEX

Formatting functions for VCs.
=SML
fun €fmt_vcs› (nm : string, term : TERM) =
    let val termstr = (format_term1 false (z_output_ll - z_output_tab_width) term)
    in
        ["πZ","‹ "^nm^" ?Ù"]@
        (fmt_body (fmt_prefix_tab termstr))@["∞"]
    end;
=TEX

Formatting functions for Fixity Paragraphs
=SML
fun €fmt_fixs_fun› (i : int, tmpl : TEMPLATE) =
=SMLLITERAL
    ["πZ"]@
=SML
    (fmt_body ["fun "^(string_of_int i)^"    "^(format_template tmpl)])@
=SMLLITERAL
    ["∞"];
=SML
fun €fmt_fixs_gen› (i : int, tmpl : TEMPLATE) =
=SMLLITERAL
    ["πZ"]@
=SML
    (fmt_body ["gen "^(string_of_int i)^"    "^(format_template tmpl)])@
=SMLLITERAL
    ["∞"];
=SML
fun €fmt_fixs_rel› (tmpl : TEMPLATE) =
=SMLLITERAL
    ["πZ"]@(fmt_body ["rel    "^(format_template tmpl)])@["∞"];
=SML
fun €fmt_fixs› (ZClFun i : CLASS, tmpl : TEMPLATE) = (fmt_fixs_fun (i,tmpl))
|   fmt_fixs (ZClGen i : CLASS, tmpl : TEMPLATE) = (fmt_fixs_gen (i,tmpl))
|   fmt_fixs (ZClRel : CLASS, tmpl : TEMPLATE) = (fmt_fixs_rel tmpl);
=TEX

Formatting functions for the creation of a new parent for the current theory.
=SML
fun €fmt_new_parent› (thy : string) =
	["new_parent \""^thy^"\";"];
=TEX

Reference variables holding text about the number of VCs in a theory.

=SML
val vc_text : string list ref = ref [];
=TEX

Formatting functions for the creation of a package specification theory.
=SML
fun €fmt_create_spec› (thy : string) =
    let val old_thy = get_current_theory_name();
        val father = (hd o rev o get_parents) thy;
    in
        ["open_theory \""^father^"\";"]@[""]@
        ["new_theory \""^thy^"\";"]@[""]@
        (fmt_z_document thy 0 false)@
        ["open_theory \""^old_thy^"\";"]
        handle Fail _ =>
        fail "fmt_create_spec" 511003 [fn()=>thy]
    end
=TEX

Formatting functions for the creation of a subunit specification theory.
=SML
and €fmt_create_subunit› (thy : string, level : int) =
    let val old_thy = get_current_theory_name();
        val father = (hd o rev o get_parents) thy;
    in
        ["open_theory \""^father^"\";"]@[""]@
        ["duplicate_theory (\""^old_thy^"\", \""^thy^"\");"]@[""]@
        (fmt_z_document thy level false)@
        ["open_theory \""^old_thy^"\";"]
        handle Fail _ =>
        fail "fmt_create_subunit" 511004 [fn()=>thy]
   end
=TEX

Formatting functions for Z Paragraphs.
=SML
and €fmt_paragraph› (PTAxiom thm) = (fmt_axioms thm)
|   fmt_paragraph (PTDefn thm) = (fmt_defns thm)
|   fmt_paragraph (PTVC nmtm) = (fmt_vcs nmtm)
|   fmt_paragraph (PTFixity ct) = (fmt_fixs ct)
|   fmt_paragraph (PTSpec thy) = (fmt_create_spec thy)
|   fmt_paragraph (PTSubunit su) = (fmt_create_subunit su)
|   fmt_paragraph (PTParent thy) = (fmt_new_parent thy)
and €fmt_paragraphs› ((n,l)::ls : (int*(Z_DOC_PARAGRAPH)) list) =
        (fmt_paragraph l)@[""]@(fmt_paragraphs ls)
|   fmt_paragraphs ([]) = []
=TEX

Formatting function for the whole Z Document.  Takes as arguments the name of a theory, an integer and a flag.  The integer is a cutoff, only objects with indices greater than this will be printed.  This means to print the entire theory this needs to be < 0, it -1.  The flag is for whether to printout information relating to theories generated by this theory or not.
=SML
and €fmt_z_document› (thyn : string) (level : int) (flag : bool) = 
    let val old_thy = get_current_theory_name();
        val z_output_dict = [] : (int*(Z_DOC_PARAGRAPH)) list;
        val z_output_dict = if flag=true then (add_create_specs z_output_dict thyn) else z_output_dict;
        val z_output_dict = if flag=true then (add_create_subunits z_output_dict thyn) else z_output_dict;
        val z_output_dict = if flag=true then (add_new_parents z_output_dict thyn) else z_output_dict;
        val z_output_dict = add_axioms z_output_dict thyn;
        val z_output_dict = add_defns z_output_dict thyn;
        val z_output_dict = add_vcs z_output_dict thyn;
        val z_output_dict = add_fixs z_output_dict thyn
        val z_output_dict = delete_sorted z_output_dict level;
        val dummy1 = open_theory thyn;
        val st = fmt_paragraphs z_output_dict;
        val dummy2 = open_theory old_thy;
        val noofvcs = (string_of_int o length o get_conjectures) thyn;
        val vcs = ["(* Number of VCs in theory \""^thyn^"\" : "^noofvcs^" *)",""];
    in
        vc_text := !vc_text @ vcs;
        st
            handle Fail _ =>
            fail "fmt_z_document" 511005 [fn()=>thyn]
    end;
=TEX

\subsection{Epilogue}

Functions to print the Z Document to the the screen or to a file.

=SML
fun fmt_doc ( thy : string ) : string = (
	let	val thyn = if thy = "-" then get_current_theory_name() else thy;
		val father = (hd o rev o get_parents) thyn;
		val side1 = vc_text := [];
		val part1 = (
				"open_theory \""^father^"\";"
			::	""
			::	"new_theory \""^thyn^"\";"
			::	""
			::	fmt_z_document thyn ~1 true
		);
		val answer = fmt_string_list (part1 @ !vc_text);
	in	vc_text := [];
		answer
	end
);

fun €print_z_document› (thy : string) : unit =
    diag_line (fmt_doc thy);

fun €output_z_document› ({out_file : string, script : string}) =
    let val stream = open_out out_file;
        val text = ReaderWriter.translate_for_output (fmt_doc script);
    in
        output (stream, text);
        close_out stream
    end;
=TEX

\subsection{End of structure CNZOutput}
=SML
end (* of local open ... in ... end *);
end (* of structure CNZOutput *);
=TEX

\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
