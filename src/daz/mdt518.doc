% %Z%
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests: Compliance Notation Tactics Etc.}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT518}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & HAT Manager}
\TPPabstract{This document contains tests for the material defined
in ISS/HAT/DAZ/DTD518\cite{ISS/HAT/DAZ/DTD518}.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item[Issues 1.1-$Date$%
] Initial drafts.
\end{description}
\subsection{Changes forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains module tests for the module defined 
in \cite{ISS/HAT/DAZ/DTD518}.
\subsection{Introduction}
\subsubsection{Background and Purpose}
See \cite{ISS/HAT/DAZ/DTD518}. The tests are intended to meet
the requirements for module tests identified in the quality plan
\cite{ISS/HAT/DAZ/PLN002}.
\subsubsection{Dependencies}
These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.
\subsubsection{Possible Enhancements}
None known.
\subsubsection{Deficiencies}
None known.

\section{PREAMBLE}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results();
val v : bool ref = ref true	(* set false to reduce verbose output *);
v := false (* can skip this line for interactive working *);
=TEX
\section{THE TESTS}
\subsection{HOL TACTICS}\label{HT}
\subsubsection{The Rules}
=SML
open_theory"basic_hol";
force_delete_theory"mdt518A" handle Fail _ => ();
new_theory"mdt518A";
set_pc"basic_hol";
=TEX
=SML
new_const("iseven", î'a LIST ≠ BOOLÆ);
val ax1 = new_axiom(["ax1"], ¨iseven []Æ);;
val ax2 = new_axiom(["ax2"], ¨µx l∑ iseven l ¥ iseven(Cons x (Cons y l)) Æ);;
val r1_1 = hc_rule (!v) 10 hd [] [] [ax1, ax2];
val t1_1 = ¨iseven [x;y;z;a;b;c]Æ;
val t1_2 = ¨iseven []Æ;

val sr1 = store_mt_results_show
	(mt_runf(fn (th,t) => is_nil(asms th) andalso concl th =$ t));

sr1 [
	("mdt518.1.1", r1_1, t1_1, t1_1),
	("mdt518.1.2", r1_1, t1_2, t1_2)
];
=TEX
=SML
new_type("type", 0);
new_type("term", 0);
declare_infix(210, "->");
declare_infix(150, "∫");
declare_infix(300, "'");
new_const("->", îtype ≠ type ≠ typeÆ);
new_const("∫", îterm ≠ type ≠ BOOLÆ);
new_const("'", îterm ≠ term ≠ termÆ);
new_const("K", îtermÆ);
new_const("S", îtermÆ);
val k_ax = new_axiom(["k_ax"], ¨µA B∑ K ∫ A -> B -> AÆ);
val s_ax = new_axiom(["s_ax"], ¨µA B C∑ S ∫ (A -> B -> C) -> (A -> B) -> A -> CÆ);
val app_ax = new_axiom(["app_ax"], ¨µA B f x∑ f ∫ A -> B ¥ x ∫ A ¥ f ' x ∫ BÆ);
val app_ax1 = new_axiom(["app_ax1"], ¨µA B f x∑ f ∫ A -> B ± x ∫ A ¥ f ' x ∫ BÆ);
val r2_1 = hc_rule (!v) 100 hd [] [hc_∂_rule] [k_ax, s_ax, app_ax];
val t2_1 = ¨∂‘∑ S ' K ' K ∫ ‘Æ;
val t2_2 = ¨∂‘∑ (S ' K) ' K ∫ ‘ -> ‘Æ;
val t2_3 = ¨∂t; ‘∑ t ∫ ‘ -> ‘Æ;
val r2_2  = hc_rule (!v) 100 hd [] [hc_∂_rule, hc_±_rule] [k_ax, s_ax, app_ax1];
sr1 [
	("mdt518.2.1", r2_1, t2_1, t2_1),
	("mdt518.2.2", r2_1, t2_2, t2_2),
	("mdt518.2.3", r2_1, t2_3, t2_3),
	("mdt518.2.4", r2_2, t2_1, t2_1)
];
=TEX
=SML
new_type("tree", 0);
declare_infix(210, "--");
declare_infix(190, "mem");
new_const("--", îtree ≠ tree ≠ treeÆ);
new_const("mem", îtree ≠ tree ≠ BOOLÆ);
val ax3 = new_axiom(["ax3"], ¨µt∑ t mem tÆ);
val ax4 = new_axiom(["ax4"], ¨µt t1 t2∑ t mem t1 ≤ t mem t2 ¥ t mem t1 -- t2Æ);
val ax5 = new_axiom(["ax5"], ¨µt t1 t2∑
	t mem t1 -- t2 § t = t1 -- t2 ≤ t mem t1 ≤ t mem t2Æ);
val r3_1  = hc_rule (!v) 100 hd [] [hc_≤_rule] [ax3, ax4];
val t3_1 = ¨x mem xÆ;
val t3_2 = ¨x mem (x -- y)Æ;
val t3_3 = ¨x mem ((x -- y) -- (a -- b))Æ;
val t3_4 = ¨x mem ((a -- y) -- (a -- b)) -- (a -- (b -- x) -- a)Æ;
val r3_2  = hc_rule (!v) 100 hd [] [hc_≤_rule, hc_rule_of_conv (eq_match_conv ax5)] [ax3];
val thm3_3 = taut_rule¨µp q∑(p ¥ q) § ≥p ≤ qÆ; 
val r3_3  = hc_rule (!v) 100 hd []
	[hc_±_rule, hc_rule_of_conv(rewrite_conv[]),
		conv_then_hc_rule (eq_match_conv thm3_3) hc_≤_rule] [ax3, ax4];
val t3_5 = ¨≥x mem x ¥ x mem yÆ;
=TEX
=SML
sr1 [
	("mdt518.3.1", r3_1, t3_1, t3_1),
	("mdt518.3.2", r3_1, t3_2, t3_2),
	("mdt518.3.3", r3_1, t3_3, t3_3),
	("mdt518.3.4", r3_1, t3_4, t3_4),
	("mdt518.3.5", r3_2, t3_4, t3_4),
	("mdt518.3.6", r3_3, t3_5, t3_5)
];
=TEX
\subsubsection{The Tactics}
=SML
fun f4_1 () = (
set_goal([], t3_1);
a(hc_tac[ax3, ax4]);
diag_line(string_of_thm (top_thm()));
pop_thm()
);
=TEX
=SML
val tac4_2 = basic_hc_tac (!v) 100 hd id_canon
	[hc_±_rule, hc_rule_of_conv(rewrite_conv[]),
		conv_then_hc_rule (eq_match_conv thm3_3) hc_≤_rule] [ax3, ax4];
fun f4_2 () = (
set_goal([], t3_5);
a(tac4_2);
diag_line(string_of_thm (top_thm()));
pop_thm()
);
=TEX
=SML
val tac4_3 = basic_hc_tac (!v) 100 hd hc_canon
	[hc_≤_rule, hc_rule_of_conv(current_ad_st_conv())] [ax3, ax4];
fun f4_3 () = (
set_goal([], t3_5);
a(tac4_3);
diag_line(string_of_thm (top_thm()));
pop_thm()
);
=TEX
All that matters below is that the proof scripts don't fail.
=SML
store_mt_results_show (mt_runf fun_true) [
	("mdt518.4.1", f4_1, (), mk_t),
	("mdt518.4.2", f4_2, (), mk_t),
	("mdt518.4.3", f4_3, (), mk_t)
];

=TEX
\subsection{Z TACTICS}\label{ZT}
=SML
open_theory"z_library";
force_delete_theory"mdt518B" handle Fail _ => ();
new_theory"mdt518B";
new_parent(hd(get_cache_theories())) handle Fail _ => ();
set_pc"z_library";
=TEX
To test the two selection-membership rules, the easiest thing is to go proving things with them (after a quick direct test to see that the names are the right way round:
=TEX
=SML
val sr2 = store_mt_results_show
	(mt_runf(fn (th,t) => length(asms th) = 1 andalso concl th =$ t));
sr2 [
	("mdt518.10.1", z_selâs_ç_rule,
		Ò(a∫[abc,def:˙; ghi:˙ ∏ ˙; jkl :Ó]).jkl ç ÓÆ, 
		Ò(a∫[abc,def:˙; ghi:˙ ∏ ˙; jkl :Ó]).jkl ç ÓÆ),
	("mdt518.10.2", z_selât_ç_rule, 
		Ò(a ∫ (Ó ∏ ˙)).1 ç ÓÆ, Ò(a ∫ (Ó ∏ ˙)).1 ç ÓÆ)
];
=SML
val conv = simple_eq_match_conv (pc_rule1"z_library" prove_rule[]
		¨µx∑
	ëmk_z_º(mk_z_signed_int 0, ¨x:˙Æ)Æ §	ëmk_z_ç(¨x:˙Æ, ¨$"z'Ó"Æ)ÆÆ);
val z_rules = map
	(conv_then_hc_rule conv o curry (op o) (switch (curry (op::)) nil))
	[z_selât_ç_rule, z_selâs_ç_rule, z_app_ç_rule];
fun z_hc_sel (tms : TERM list) : TERM = (
	let	fun aux tm = (
			let	val (lhs, _) = dest_z_ç tm;
			in	is_z_gvar lhs orelse is_z_lvar lhs
			end	handle Fail _ => false
		);
	in	find tms aux handle Fail _ => hd tms
	end
);
val €z_hc_tac› : THM list -> TACTIC = (fn ths =>
	basic_hc_tac (!v) 100 z_hc_sel hc_canon
		(hc_rule_of_conv (current_ad_st_conv()) ::
			hc_±_rule :: hc_≤_rule ::z_rules)
		ths
);
=TEX
=SML
set_pc"z_library1";
=TEX
=SML
set_goal([], Òµi, j:Ó∑ i + j ç ÓÆ);
a(PC_T1 "z_lin_arith" prove_tac[]);
val z_plus_ç_Ó_thm = pop_thm();
=TEX
=SML
set_goal([], Òµi, j:Ó∑ i * j ç ÓÆ);
a(REPEAT strip_tac);
a(z_º_induction_tac ÒiÆ THEN
	rewrite_tac[z_times_plus_distrib_thm] THEN z_hc_tac[z_plus_ç_Ó_thm]);
val z_times_ç_Ó_thm = pop_thm();
=TEX
=SML
fun f11_1() = (
set_goal([], Òµi, j, k:Ó∑ (i + j * i * 2 + 99) * (i + j*k) ç ÓÆ);
a(REPEAT strip_tac);
a(z_hc_tac[z_plus_ç_Ó_thm, z_times_ç_Ó_thm]);
diag_line(string_of_thm (top_thm()));
pop_thm()
);
=TEX
=SML
fun f11_2() = (
set_goal([], Ò µx:[a:˙; b : Ó; c : ˙]∑ x.b + 99 ç ÓÆ);
a(REPEAT strip_tac);
a(z_hc_tac[z_plus_ç_Ó_thm, z_times_ç_Ó_thm]);
diag_line(string_of_thm (top_thm()));
pop_thm()
);
=TEX
=SML
=TEX
=SML
fun f11_3() = (
set_goal([], Òµf : Ó ≠ [a:˙; b : Ó; c : ˙] ∑
		(f 42).b + 99 ç Ó Æ);
a(REPEAT strip_tac);
a(z_hc_tac[z_plus_ç_Ó_thm, z_times_ç_Ó_thm]);
diag_line(string_of_thm (top_thm()));
pop_thm()
);
=TEX
=SML
fun f11_4() = (
set_goal([], Òµf : Ó ≠ [a:˙; b : Ó; c : ˙] ∑
		1 < 2 ± (44 < 3 ¥ false) ± (f 42).b + 99 ç Ó ± ((f 42).b + 100 ç Ó ≤ 1 = 2)Æ);
a(z_µ_tac THEN ¥_tac);
a(z_hc_tac[z_plus_ç_Ó_thm, z_times_ç_Ó_thm]);
diag_line(string_of_thm (top_thm()));
pop_thm()
);
=TEX
All that matters below is that the proof scripts don't fail.
=SML
store_mt_results_show (mt_runf fun_true) [
	("mdt518.11.1", f11_1, (), mk_t),
	("mdt518.11.2", f11_2, (), mk_t),
	("mdt518.11.3", f11_3, (), mk_t),
	("mdt518.11.4", f11_4, (), mk_t)
];
=TEX
\subsection{COMPLIANCE NOTATION TACTICS}\label{CNT}
=SML
open_theory"cn";
force_delete_theory"mdt518C" handle Fail _ => ();
new_theory"mdt518C";
set_pc"cn1";
=TEX
=SML
val t20_1 = Ò	µ	x : INTEGER; y : INTEGER; z : INTEGER
	|	(x + y) + 1 eq z = TRUE ± (x æ 0 ± y æ 0) ± x æ 0
	∑	x æ 0 ± z greater_eq 0 = TRUEÆ;
=TEX
=SML
fun f20_1() = (
set_goal([], t20_1);
a(cn_vc_simp_tac[]);
a(PC_T1 "z_lin_arith" prove_tac[]);
diag_line(string_of_thm (top_thm()));
pop_thm()
);
=TEX
=SML
val t20_2 = Ò	(x æ 0 ± y æ 0) ¥ x + y greater_eq 0 = TRUEÆ;
=TEX
=SML
fun f20_2() = (
set_goal([], t20_2);
a(cn_vc_simp_tac[]);
a(PC_T1 "z_lin_arith" prove_tac[]);
diag_line(string_of_thm (top_thm()));
pop_thm()
);
=TEX
πZ
‹ RANGE ¶ 1 .. 10 
∞
=TEX
=SML
val t20_3 = Ò	µ	x : RANGE
	|	x Ω 1
	∑	x greater_eq 2 and x less 11 = TRUE Æ;
=TEX
=SML
fun f20_3() = (
set_goal([], t20_3);
a(cn_vc_simp_tac[z_get_specÒRANGEÆ]);
a(PC_T1 "z_lin_arith" prove_tac[]);
diag_line(string_of_thm (top_thm()));
pop_thm()
);

=TEX
All that matters below is that the proof scripts don't fail.
=SML
store_mt_results_show (mt_runf fun_true) [
	("mdt518.20.1", f20_1, (), mk_t),
	("mdt518.20.2", f20_2, (), mk_t),
	("mdt518.20.3", f20_3, (), mk_t)
];
=TEX
=SML
fun f21_1 () = (
set_goal([], mk_f);
a(cn_vc_simp_tac[])
);
=SML
store_mt_results_show mt_run_fail [
	("mdt518.21.1", f21_1, (),
		gen_fail_msg "cn_vc_simp_tac" 518003 [string_of_term mk_f])
];
=TEX
\section{SUMMARY OF RESULTS}
=SML
diag_string(summarize_mt_results());
=TEX

\end{document}

