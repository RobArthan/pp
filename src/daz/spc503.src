=WARNING_EDIT_WITH_CARE spc503.src
=TEX
\documentclass{derarep5}
%\usepackage{cadiZ}

\usepackage{ProofPower}
\def\ZAxDesLabel{}
\def\ZGenericLabel{}
\def\ZOtherLabel{}
\def\ZSchemaLabel{}
\ftlmargin=4em
\tabstop=2em
\def\Hide#1{\relax}
%\ftlinepenalty=9999
\def\RCSVersion{$Revision: 1.15 $%
}

\makeindex


\docno{DRA/CIS/CSE3/TR/94/27/4.0}
\title{Specification of the compliance notation for SPARK and Z}
\volume{3}{3}
\author{C M O'Halloran\\ C T Sennett\\ A Smith}
\Author{O'Halloran C M, Sennett C T, Smith A}
\keywords{Z, SPARK, Refinement, Literate Programming}
\date{February 28, 2002}
\issuedate{February 28, 2002}

%\protmark{}
%\descriptor{}
%\caveat{}
%\codeword{}

\location{Issued by System Assurance Group, KIS Division, \\
QinetiQ, St. Andrews Road, Malvern, Worcestershire, WR14 3PS. \\
Telephone 01684-894320.}
\contractno{CRP8/TG10}
\periodcovered{April 2000 - March 2001}
\customer{DDEC(ISTAR)ET}
\reportprotmark{Not protectively marked}
\reportcaveat{None}
\reportdescriptor{None}
\conference{None}
\titleclass{Not protectively marked}
\keywords{Z, SPARK, Refinement, Literate Programming}
\abstractclass{Not protectively marked}

\raggedbottom

\begin{document}

\maketitle

\begin{center}\fbox{\hspace{3mm}\parbox[t]{130mm}{
\hspc \textbf{Customer Information} \hspc\\[5mm]
\hspc\begin{tabular}{ll}
    Package Number:     & TG10 \\
    Package Title:      & Computing, Information and Signal Processing \\
    Package Customer:   & DDEC(ISTAR)ET \\
    Package Manager:    & Graham Dean \\
    Research Objective: & 5 \\
    Technical Area:     & 3 \\
    Assignment Number:  & 2
\end{tabular}\hspc
}}\vspace{25mm}

\fbox{\hspace{3mm}\parbox[t]{130mm}{\rule[-2mm]{0mm}{8mm}
  This document has been prepared for MoD and, unless indicated, may
  be used and circulated in accordance with the conditions of the Order
  under which it was supplied.\\
  \hspace*{5mm}\\
  It may not be used or copied for any non-Governmental or commercial
  purpose without the written agreement of QinetiQ.
\rule[-4mm]{0mm}{8mm}}\hspace{3mm}}\vspace{25mm}

\copyright Copyright QinetiQ 2002\\
QinetiQ UK \\
\vspace{5mm}
Approval for wider use or release must be sought from:\\
\vspace{5mm}
Intellectual Property Department\\
QinetiQ\\
QinetiQ Farnborough\\
Farnborough, Hampshire GU14 0LX
\end{center}

\startpre

\section*{Authorisation}

\begin{center}
  \begin{tabular}[t]{@{}p{40mm}p{90mm}@{}}
     Prepared by:       & A Smith \\
     Title:             & Senior Scientist \\
                        & \\
     Signature:         & \hrulefill \\
     Date:              & \hrulefill \\
     Location:          & L113, QinetiQ Malvern \\
                        & \\
     Authorised by:     & M Hill \\
     Title:             & Project Manager \\
                        & \\
     Signature:         & \hrulefill \\
     Date:              & \hrulefill \\
                        & \\
                        & \\
     Principal authors  & \\
                        & \\
     Name:              & A Smith \\
     Appointment:       & Senior Scientist \\
     Location:          & QinetiQ(Malvern) \\
                        & \\
     Name:              & C M O'Halloran \\
     Appointment:       & Lead Researcher \\
     Location:          & QinetiQ(Malvern) \\
                        & \\
     Name:              & C T Sennett \\
     Appointment:       & QinetiQ Fellow \\
     Location:          & QinetiQ(Malvern) \\    
  \end{tabular}

  \vspace{25mm}
  
  Issued by: System Assurance Group, KIS Division \\
  QinetiQ \\
  St. Andrews Road \\
  Malvern \\
  Worcestershire, WR14 3PS. \\
  Telephone 01684-894320
\end{center}

\section*{Record of changes}

This is a controlled document. \\
Additional copies should be obtained through the issuing authority. \\
In the extreme event of copying locally, each document shall be marked
`Uncontrolled Copy'. \\
Amendments shall be by whole document replacement. \\
Proposals for change to this document should be forwarded in writing to the issuing authority.\\
\\[15mm]
\begin{tabular}{|l|l|l|} \hline
    Version\hspace{1cm} & Date\hspace{2cm} & Comments\hspace{5cm} \\ \hline
  1.0  &  March 25, 1994     &  First Issue \\
  1.1  &  June 13, 1994      &  Data refinement added  \\
  1.2  &  December 22, 1994  &  Omissions found during implementation \\
       &                     &  of version 1.1 \\
  2.0  &  July 5, 1995       &  Various enhancements \\
  2.1  &  January 12, 1996   &  Omissions found during implementation \\
       &                     &  of version 2.0 \\
  3.0  &  September 26, 1997 &  Enhancements as recommended by independent \\
       &                     &  evaluation report \\
  3.1  &  August 4, 2000     &  Further enhancements \\
  4.0  &  February 28, 2002  &  \parbox[t]{7cm}{\raggedright
			     The specifications are now maintained on QinetiQ's behalf
			     by Lemma 1 Ltd. The formal Z material is now checked
			     and typeset using {\Product}. The specification changes
			     recorded in the documents HLD507\cite{LEMMA1/DAZ/HLD507}
			     and HLD508\cite{LEMMA1/DAZ/HLD508} have been actioned.

			    }\\
  4.1  &  May 17, 2002  &  \parbox[t]{7cm}{\raggedright
			     The specification has been enhanced to support extra Ada language
                                                    features as described in the current, interim, version
                                                     of the document HLD509\cite{LEMMA1/DAZ/HLD509}.
			    }\\
  4.2  &  Febrary 6th, 2003  &  \parbox[t]{7cm}{\raggedright
			     The specification has been enhanced to support extra Ada language
                                                    features as described in the final version
                                                     of the document HLD509\cite{LEMMA1/DAZ/HLD509}.
			    }\\
                        &                   & \\
                        &                   & \\
                        &                   & \\
                        &                   & \\
                        &                   & \\
                        &                   & \\ \hline
\end{tabular}    

\vfill

{\tiny Lemma 1 RCS \RCSVersion}
\abstract{This volume formally specifies how to translate SPARK 
basic declarations and expressions to Z.}

\tableofcontents

\startmain

\section{Introduction}

\bpar{
This volume formally specifies how to translate SPARK basic declarations
and expressions to Z.
It is used by volume 1 to translate the SPARK basic declarations (for example type declarations)
that appear in a literate script to Z, so that they can be output to the Z document.
It is also used by volume 2 in constructing of the verification conditions (VCs)
from a refinement step, to translate the expressions that appear in the SPARK statements to Z. 
}\epar

\bpar{
We run the {\Product} commands to set up a theory to hold the specification.
The specification makes use of the {\ProductZ} library.
}\epar
\Hide{
=SML
set_flag("z_type_check_only", get_shell_var"PPTYPECHECKONLY" <> "false");
=TEX
}
=SML
open_theory "z_library";
new_theory"Volume_3";
=TEX

\bpar{
The specification is given in terms of a translation from an
abstract syntax of SPARK basic declarations and expressions to an abstract syntax of Z.
The translation is presented for each type of SPARK basic declaration and expression.
}\epar

\section{Abstract syntax of Z}

\subsection{Z declarations}

\bpar{
Concrete syntax. \\
\ \\
$A : T$\\
$SCHEMA$
}\epar

\bpar{
Abstract syntax.
}\epar

\bpar{
Optional values are required at several points in the abstract syntax of Z and Ada.
A member of the set
=INLINEFT
OPT[X]
=TEX
\ denotes an optional member of {\it X}.
To represent this, 
=INLINEFT
OPT[X]
=TEX
\ comprises all subsets of {\it X} with at most one element.
}\epar

=SPCZ  OPT
=TEX

\bpar*{
$Value\;x$ denotes an optional value supplied as $x$; $Nil$ denotes an optional value that has been omitted.
}\epar*

=SPCZ  Value
=TEX

\bpar*{
$Z\_ID$ is the set of Z identifiers and $Z\_EXP$ is the set of Z expressions.
The free type $Z\_EXP$ is recursive with some of its arms being schemas involving $Z\_EXP$.
The free type is defined in section 2.7.1. The schemas used in the arms of the free type are generic and will be instantiated at the point where they are used in defining the free type.
}\epar*

=SPCZ  Z_ID
=TEX

\bpar*{
The identifier for the variable in a Z declaration is optional. If it is omitted, the declaration is
a schema acting as a declaration and the expression gives the schema value, if it is present
the declaration is an ordinary declaration declaring a variable with the specified
identifier ranging over the set given by the expression.
}\epar*


=SPCZ  Z_Decl
=TEX


\subsection{Z unary expressions}

\bpar{
A Z unary expression consists of one of the following unary operators and an expression to its right.
}\epar

\vertbarfalse
=GFT
	ABSTRACT			CONCRETE
	z_unary_minus		-  
	z_bool_not			not 
	z_abs				abs
	z_real_unary_minus	~‰R
	z_real_abs			abs‰R
	z_array_not			array_not
	z_char_lit			char_lit
	z_string_lit			string_lit
=TEX
\vertbartrue
 

\bpar*{
$not$ and $abs$ are defined in the extension to the Z toolkit (appendix
B of volume 1).
}\epar*

=SPCZ  Z_UNARY_OP
=TEX

=SPCZ  Z_Unary_Exp
=TEX


\subsection{Z binary expressions}

\bpar{
A Z binary expression consists of one of the following infix operators in the middle of two expressions.
}\epar

\bpar*{
\vertbarfalse
=GFT
	ABSTRACT				CONCRETE
	z_bool_and				and		
	z_bool_or				or		
	z_bool_xor				xor		
	z_bool_eq				eq		
	z_bool_noteq				noteq		
	z_bool_less				less		
	z_bool_less_eq			less_eq		
	z_bool_greater			greater		
	z_bool_greater_eq			greater_eq		
	z_add					+		
	z_minus					-		
	z_times					*		
	z_intdiv					intdiv		
	z_mod					intmod		
	z_rem					rem		
	z_expon					**		
	z_bool_mem				mem		
	z_bool_notmem			notmem
	z_real_add				+‰R
	z_real_minus				-‰R
	z_real_times				*‰R
	z_real_over				/‰R
	z_real_expon				^‰R
	z_bool_real_less			real_less
	z_bool_real_less_eq		real_less_eq
	z_bool_real_greater		real_greater
	z_bool_real_greater_eq		real_greater_eq
	z_array_and				array_and
	z_array_or				array_or
	z_array_xor				array_xor
	z_array_greater			array_greater
	z_array_greater_eq		array_greater_eq
	z_array_less				array_less
	z_array_less_eq			array_less_eq
	z_array_array_cat		&‰0
	z_array_elem_cat			&‰1
	z_elem_array_cat			&‰2
=TEX
\vertbartrue


All but $+$,\ $-$,\ and $*$ are defined in the extension to the Z toolkit (appendix B of volume 1).
}\epar*

{\ftlinepenalty=9999
=SPCZ  Z_BIN_OP
=TEX
}

=SPCZ  Z_Bin_Exp
=TEX


\subsection{Z function calls}

\bpar{
Concrete syntax. \\
\ \\
$F(A, B, C)$
}\epar

\bpar{
Abstract syntax.
}\epar

=SPCZ  Z_Fun_Call
=TEX

\subsection{Z binding selections}

\bpar{
Concrete syntax. \\
\ \\
$B.X$
}\epar

\bpar{
Abstract syntax.
}\epar

=SPCZ  Z_Selection
=TEX

\subsection{Z bindings}

\bpar{
Concrete syntax. 
}\epar

\vertbarfalse
=GFT
(X ¦ E1, Y ¦ E2, Z ¦ E3)
=TEX
\vertbartrue

\bpar{
Abstract syntax.
}\epar

=SPCZ  Z_Binding
=TEX


\subsection{Z expressions}


\bpar{In constructing the Z document the following symbols are
required for Z expressions.

}\epar

\vertbarfalse
=GFT
	ABSTRACT			CONCRETE
	z_tfun				­
	z_pfun				ß
	z_int_rng			..
	z_real_rng			..‰R
	z_dom				dom
	z_dom_res			ò
	z_inv 				~
	z_id_rel				id
	z_size				# 
	z_set				{...}
	z_set_minus			\
	z_set_comp			{ ... | ... } 
	z_power				a›b 
	z_rel_comp			»
	z_seq 				§...¢
	z_cross 				¸
	z_many_cross 	 	... ¸ ... ¸ ...
	z_override			«
	z_many_union 		... À ... À ...
	z_maplet				í
	z_powerset			ð
	z_tuple 				(..., ..., ...)
	z_real_to_integer		real_to_integer
	z_integer_to_real		integer_to_real
	z_succ				succ
	z_theta				Ê
=TEX
\vertbartrue





\bpar*{
The constructor $z\_many\_cross$ may be used to form a ``cartesian product''
of just one set. In this case, $z\_many\_cross(\langle E \rangle)$ corresponds to the same concrete Z as the expression $E$.
The constructor $z\_tuple$ may be used to form a ``tuple'' of just one element.
In this case, $z\_tuple(\langle E \rangle)$ corresponds to the same concrete Z as the expression $E$.
}\epar*

\bpar*{
$Z\_PRED$ is the set of Z predicates. The free type $Z\_PRED$ is mutually recursive with $Z\_EXP$ and is defined in section 2.8.1. The schemas used in the arms of the free type are generic and will be instantiated at the point where they are used in defining the free type.

}\epar*



\bpar*{
In the definition of $Z\_EXP$ below all the arms except the
last represent the expressions that are
constructed by the compliance notation tool in producing the Z document.
However it is recognised that other user-defined Z expressions will appear in the literate script,
for example in the declaration of a logical constant.
To enable these other Z expressions to be represented in the abstract syntax
$OTHER\_Z\_EXP$ is introduced which forms the last arm of the free type
$Z\_EXP$.


=SPCZ  OTHER_Z_EXP
=TEX

Similarly, $OTHER\_Z\_PRED$ is used to represent user-defined predicates such
as those occurring in specification statements.

=SPCZ  OTHER_Z_PRED
=TEX

{\it Z\_REAL} stands for a type of reals in Z, typically called ¯.



=SPCZ  Z_REAL
=TEX

In the definition of {\it Z\_EXP} below, {\it z\_num}, {\it z\_real}, {\it z\_char}
and {\it z\_string}  are the constructors for
literals.


{\it Z\_STRING} is the type of string literals in Z.

}\epar*
=SPCZ  Z_STRING
=TEX

=SPCZ  Z_EXP
=TEX

\newpage


\subsection{Z predicates}

\bpar{In constructing the Z document the following symbols are required for Z predicates.
}\epar

\vertbarfalse
=GFT
	ABSTRACT		CONCRETE
	ztrue			true
	z_eq				=
	z_and			±
	z_many_and		...±...±...
	z_elem			
	z_notelem		Ž
	z_noteq			½
	z_less_eq		¼
	z_greater		>
	z_forall			µ
	z_exists			¶
	z_imp			´
	z_mem			
=TEX
\vertbartrue




\bpar*{
In the definition of $Z\_PRED$ (see below) all the arms except the last represent the predicates that are
constructed by the compliance notation tool in producing the Z document (with the exception of the second arm
which is used in the abstract syntax of statements in volume 2).
However it is recognised that other user-defined predicates will appear in the literate script,
for example in specification statements.
To enable these other Z predicates to be represented in the abstract syntax,
$OTHER\_Z\_PRED$ is used
which forms the last arm of the free type $Z\_PRED$.
}\epar* 


=SPCZ  Z_PRED
=TEX
\subsection{Z Identifiers and Variable Renaming}
The Z parser for the Compliance Notation is expected to provide some support
for Ada variable renamings. If a Z identifier is the translation of an Ada identifier
that has been introduced by an Ada variable renaming declaration, then
the identifier is to be replaced by the Z translation of the original variable  name.
In Z expressions built up in this specification, the constructor {\it z\_id} defined
above is never used directly. Instead, the following function is used and is expected
to handle variable renamings in the same way as the Z parser.

=SPCZ zid
=TEX


\subsection{Z given sets}

\bpar{
The concrete syntax $[FIX]$ is represented in the abstract syntax as
$z\_given(FIX)$ (see the definition of $Z\_PARA$ at the end of this section).
Given sets are used in the translation of Ada real types.
}\epar

\subsection{Z modules}



\bpar{
Z modules are constructed in the treatment of Ada {\tt with} clauses
and subunits. A modularity feature for Z similar to that of the draft Z standard is
required. We refer to the units of a Z specification as {\it modules}; these correspond
to the {\it sections} of the draft Z standard, or the {\it theories} of ProofPower.
A Z module paragraph means that the named Z module should be created and should become
the {\it current module}, in which subsequent given sets, schemas, etc. will be stored.
A Z parents paragraph means that the indicated parent modules should be made parents
of the current module (so that subsequent Z paragraphs within the current module will
be able to refer to Z objects defined in the parent modules).
An implementation that conformed strictly to the draft Z standard would have to gather
up the parents paragraphs in a module to give the complete section header.
}\epar

=SPCZ  Z_MODULE
=TEX

=SPCZ  Z_PARENTS
=TEX


\subsection{Z schemas}

\bpar{
Concrete syntax.
}\epar

¹ÿ ÛRECÝ
Ü	START : DAY
Ü	FINISH : DAY
Ü	YESTERDAY : ARR
ˆ


\bpar{
Abstract syntax.
}\epar

\bpar*{
Two kinds of schema are used in the translation of Ada record types:
schemas with ordinary variable declarations in their signature and schemas
with a schema expression given as a single Z identifier as their signature.
}\epar*

=SPCZ  Z_Schema
=TEX


=SPCZ  Z_Constrained_Schema
=TEX


\subsection{Z axiomatic descriptions}

\bpar{
Concrete syntax.
}\epar

¹IZAX
ÛPLUS_TWOÝ : INTEGER ­ INTEGER
÷
µA : INTEGER · true ´ PLUS_TWO A = A + 2
°


\bpar*{
Z axiomatic descriptions are used to translate Ada function specifications (see volume 1).
The translation of Ada function {\it calls} is specified in this document.
}\epar*

\bpar{
Abstract syntax.
}\epar

=SPCZ  Z_Ax
=TEX


\subsection{Z VCs}

\bpar{
Concrete syntax. 
}\epar

\vertbarfalse
=GFT
X,Y‰0: INTEGER |
Y‰0 = 7
X = 5
ô
X = 5 ± 8 = Y‰0 + 1
=TEX
\vertbartrue

\bpar{
Abstract syntax.
}\epar

\bpar*{
A VC is a sequent together with local declarations of the variables in the sequent.
}\epar*

=SPCZ  Sequent
=TEX


=SPCZ  VC
=TEX


\subsection{Z paragraphs}

\bpar{In constructing the Z document the following symbol is required for Z paragraphs.
\vertbarfalse
=GFT
	ABSTRACT		CONCRETE
	z_eq_eq			==
=TEX
\vertbartrue
}\epar

\bpar*{
A Z document is a sequence of Z paragraphs.
$Z\_PARA$ (see below) models Z paragraphs. All arms but the last represent the Z paragraphs that
are constructed by the compliance notation tool. However it is recognised that there will be other user-defined
Z paragraphs in the literate script (these are simply copied into the Z document).
To enable these other Z paragraphs to be represented in the abstract syntax,
$OTHER\_Z$ is introduced
which forms the last arm of the free type $Z\_PARA$.
}\epar* 

=SPCZ  OTHER_Z
=TEX

=SPCZ  Z_PARA
=TEX


\subsection{Z Types}

\bpar{
To enable the translation of some expressions and basic declarations
it is necessary to know the Z type of certain Z expressions. In the
definition of $Z\_TYPE$ below, $z\_int\_type$ represents the type $ú$,
$z\_power\_type$ represents a power type, $Z\_Schema\_Type$
is used to represent schema types and $OTHER\_Z\_TYPE$ is used to represent
the other Z types.
In particular, $Z\_Schema\_Type$ is needed to translate record aggregates.
Notice that it has been assumed that the components of $Z\_Schema\_Type$
have an order ($z\_sig$ is a {\it sequence}).
This order is the same as the order in the Ada record type.
This is necessary in order to
match up the components of the Ada record type with the right components
of the record aggregate.
}\epar

\bpar*{
It should be noted that in Z [6] there is, of course, no order to the
components in a schema. It is just that an order is required for the
purposes here. 
}\epar*

=SPCZ  Z_Schema_Type
=TEX

=SPCZ  OTHER_Z_TYPE
=TEX


=SPCZ  Z_TYPE
=TEX


\bpar*{
The function $z\_type\_of$ finds the Z type of a Z expression.
}\epar*

=SPCZ  z_type_of
=TEX


\section{Abstract syntax of SPARK expressions}

\subsection{Overview}


\bpar{
This section defines the abstract syntax for the various forms of SPARK expression.
$ÛEXPÝ$ is the set of SPARK expressions.
The free type $EXP$ is recursive with some of its arms being schemas involving $EXP$.
The free type is defined in section 3.20.2. The schemas used in the arms of the free type are generic and will be instantiated at the point where they are used in defining the free type.
}\epar




\subsection{Identifiers}

\bpar{
$ID$ is the set of Ada identifiers and machine-generated identifiers disjoint from them
     which may be generated during preprocessing.
}\epar

=SPCZ  ID
=TEX
\subsection{Aggregates (positional array)}

\bpar{
Concrete syntax.
}\epar

\begin{verbatim}
        ARR'(TUE, WED, THU, FRI, SAT, SUN, MON)
\end{verbatim}

\bpar*{
(Call this aggregate {\tt TOMORROW} for later example of array indexing).
}\epar*

\bpar{
Abstract syntax.
}\epar


\bpar*{
$TMARK$ is the set of type marks in the literate script.
}\epar*

=SPCZ  TMARK
=TEX

\bpar*{
$OPT\_TMARK$ represents an optional type mark. 
}\epar*

=SPCZ  OPT_TMARK
=TEX

=SPCZ  Agg_Pos
=TEX

\subsection{Aggregates (positional array with others)}

\bpar{
Concrete syntax.
}\epar

\begin{verbatim}
        ARR'(THU, WED, SUN, others => SAT)
\end{verbatim}

\bpar{
Abstract syntax.
}\epar

=SPCZ  Others
=TEX

=SPCZ  Agg_Pos_Others
=TEX


\subsection{Aggregates (array with just others)}

\bpar{
Concrete syntax.
}\epar

\begin{verbatim}
        ARR'(others => WED)
\end{verbatim}

\bpar{
Abstract syntax.
}\epar


=SPCZ  Agg_Others
=TEX


\subsection{Aggregates (named array)}

\bpar{
Concrete syntax.
}\epar

\begin{verbatim}
         ARR'(MON..THU | FRI => WED, SAT | SUN => TUE)
         ARR'(SUB'RANGE => MON, SAT | SUN => SAT)
         ARR'(WEEKDAY RANGE  MON .. FRI => MON, SAT | SUN => SAT)
         ARR'(WEEKDAY => MON, SAT | SUN => SUN)
         ARR'(WEEKDAY RANGE MON .. WED => MON, THU | SUN => SUN)
\end{verbatim}

\bpar{
Abstract syntax.
}\epar

\bpar*{
A range such as {\tt MON..THU} in the above aggregate.


A range attribute as a choice in an aggregate
is represented by taking {\it lo} and {\it hi} to be the
corresponding first and last attributes, e.g., {\tt\itshape SUB'FIRST .. SUB'LAST}
in place of {\tt\itshape SUB'RANGE}.

A subtype mark without a range constraint as a choice in an aggregate
is represented by taking {\it lo} and {\it hi} to be the
corresponding first and last attributes, e.g., {\tt\itshape SUB'FIRST .. SUB'LAST}
in place of {\tt\itshape SUB'RANGE}.

For a subtype mark with a range constraint as a choice in an aggregate,
{\it lo} and {\it hi} are taken from the range constraint (again
using the first and last attributes, if it comprises a range attribute).
}\epar*

=SPCZ  Range
=TEX


\bpar*{
An aggregate choice (terms separated by {\tt |}) such as {\tt MON..THU} or {\tt FRI}
in the above aggregate.
}\epar*

=SPCZ  AGG_CHOICE
=TEX

=SPCZ  agg_choice_range
=TEX


\bpar*{
A named association such as $MON..THU | FRI => WED$ in the above aggregate.
}\epar*

=SPCZ  Named_Assoc
=TEX


=SPCZ  Agg_Named
=TEX


\subsection{Aggregates (named array with others)}

\bpar{
Concrete syntax.
}\epar

\begin{verbatim}
        ARR'(MON..FRI => WED, others => TUE)
\end{verbatim}

\bpar{
Abstract syntax.
}\epar


=SPCZ  Agg_Named_Others
=TEX

\subsection{Aggregates (positional record)}

\bpar{
Concrete syntax.
}\epar

\begin{verbatim}
        REC'(WED, SUN, ARR'(others => THU))
\end{verbatim}

\bpar{
Abstract syntax.
}\epar


=SPCZ  Rec_Agg_Pos
=TEX


\subsection{Aggregates (named record)}

\bpar{
Concrete syntax.
}\epar

\begin{verbatim}
        REC'(START => THU,
             FINISH => FRI,
             YESTERDAY => ARR'(others => SUN))
\end{verbatim}

\bpar*{
(Call this aggregate {\tt REC2} for later example of record selection).
}\epar*

\bpar{
Abstract syntax.
}\epar

=SPCZ  Rec_Agg_Named
=TEX


\subsection{Unary expressions}

\bpar{A unary expression consists of one of the following unary operators and an expression to its right.
\vertbarfalse
=GFT
	ABSTRACT			CONCRETE
	spark_unary_add		+
	spark_unary_minus	-
	spark_not			not
	spark_abs			abs
=TEX
\vertbartrue
}\epar

=SPCZ  UNARY_OP
=TEX

=SPCZ  Unary_Exp
=TEX


\subsection{Binary expressions}

\bpar{A binary expression consists of one of the following infix operators in the middle of two expressions. 
The Ada operators {\tt in} and {\tt not in} are used both for forming binary
expressions and in the form where the upper and lower bounds of the range
comprising the right operand are given separately. The latter form
is discussed in section 3.12 below. 
When  {\tt in} and {\tt not in} are used to form a
binary expression, the right operand is either a range attribute
or a type mark. A type mark in this position to be treated as if it
were the identifier form of expression.

\vertbarfalse
=GFT
	ABSTRACT		CONCRETE
	spark_and		and
	spark_or			or
	spark_and_then	and then
	spark_or_else		or else
	spark_xor		xor
	spark_eq			=
	spark_noteq		/=
	spark_less		<
	spark_less_eq		<=
	spark_greater		>
	spark_greater_eq	>=
	spark_add		+
	spark_minus		-
	spark_times		*
	spark_div		/
	spark_mod		mod
	spark_rem		rem
	spark_expon		**
	spark_mem		in
	spark_notmem	not in
	spark_cat		&
=TEX
\vertbartrue
}\epar 

=SPCZ  BIN_OP
=TEX

=SPCZ  Bin_Exp
=TEX


\subsection{Membership of a range}

\bpar{
Concrete syntax.
}\epar

\begin{verbatim}
        PAY_DAY not in SAT..SUN
\end{verbatim}

\bpar{
Abstract syntax.
}\epar

\bpar*{

}\epar*

=SPCZ  MEM_OP
=TEX

=SPCZ  Mem_Range
=TEX


\subsection{Attributes}

\bpar{
Concrete syntax.
}\epar


\begin{verbatim}
        WEEKDAY'FIRST

        DAY'SUCC(WED)

        ARR2'RANGE(2)
\end{verbatim}

\bpar{
Abstract syntax.
}\epar

\bpar*{
The attribute designators {\tt FIRST, LAST, SUCC, PRED, POS, VAL, LENGTH, RANGE, DIGITS} and {\tt DELTA}. This list
gives the attributes that are generated from SPARK type declarations.
}\epar*

=SPCZ  fst
=TEX

=SPCZ  ATTRIB
=TEX



\bpar*{
The following list gives the remaining attributes that are recognised in SPARK expressions.
}\epar*

=SPCZ  aft
=TEX

=SPCZ  OTHER_ATTRIB
=TEX



\bpar*{
Attribute designators. The first arm covers attribute designators such as
{\tt FIRST} in the attribute {\tt WEEKDAY'FIRST}, while the second arm covers attribute designators
such as {\tt SUCC(WED)} in the attribute {\tt DAY'SUCC(WED)}.

{\tt ATTRIB\_DESIG} represents an attribute designator. Some kinds of attribute designator have an argument expression. If the set EXP were in scope at this point in the specification we could define {\tt ATTRIB\_DESIG} as a free type with two arms corresponding to attribute designators with and without arguments. However, EXP is not in scope yet, and, as Z does not permit generic free type definitions, we introduce {\tt ATTRIB\_DESIG} as a given set and define the two constructors {\tt attrib} and {\tt attrib\_arg} in a generic box.

}\epar*

=SPCZ  ATTRIB_DESIG
=TEX

=SPCZ  attrib
=TEX

\bpar*{
An attribute such as those at the start of this subsection. 
}\epar*

=SPCZ Attribute
=TEX

\subsection{Indexed components}

\bpar{
Concrete syntax.
}\epar

\begin{verbatim}
        TOMORROW(THU)
\end{verbatim}

\bpar{
Abstract syntax.
}\epar


=SPCZ  Indexed_Comp
=TEX

\subsection{Selected components}

\bpar{
Concrete syntax.
}\epar

\begin{verbatim}
        REC2.FINISH
\end{verbatim}

\bpar{
Abstract syntax.
}\epar

=SPCZ  Selected_Comp
=TEX


\subsection{Function calls}

\bpar{
Concrete syntax.
}\epar

\bpar*{
If {\tt MAX} is a function with Ada function specification \\
\ \\
{\tt function\ MAX (X : DAY; Y : DAY) return DAY} \\
\ \\
then {\tt MAX(WED, DAY'LAST)} is a function call.
}\epar*

\bpar{
Abstract syntax.
}\epar

=SPCZ  Fun_Call
=TEX


\subsection{Qualified expressions}

\bpar{
Concrete syntax.
}\epar

\bpar*{
{\tt TMARK'(EXP)}
}\epar*

\bpar{
Abstract syntax.
}\epar

=SPCZ  Qualified_Exp
=TEX


\subsection{Type conversions}

\bpar{
Concrete syntax.
}\epar

\bpar*{
{\tt TMARK(EXP)}
}\epar*

\bpar{
Abstract syntax.
}\epar

=SPCZ  Type_Conv
=TEX

\subsection{Integer literals}

\bpar{
$INT\_LIT$ are the integer literals such as
{\tt 25},\ {\tt 15\_234},\ {\tt 12E3},\ {\tt 2\#101\#}.
}

\epar

=SPCZ  INT_LIT
=TEX


\subsection{Real literals}

\bpar{
{\it REAL\_LIT} comprises the real literals such as {\tt 3.14159}, {\tt 0.271828e1}.
(Only decimal real literals are allowed in SPARK.)

=SPCZ  REAL_LIT
=TEX
}\epar

\subsection{Character Literals}

\bpar{
{\it CHAR\_LIT} comprises the character literals such as {\tt 'a'}, {\tt '?'}.

=SPCZ  CHAR_LIT
=TEX
}\epar


\subsection{String Literals}

\bpar{
{\it STRING\_LIT} comprises the string literals such as {\tt "hello world!"}.

=SPCZ  STRING_LIT
=TEX
}\epar



\subsection{Auxiliary expressions}

\bpar{
In the compliance notation a SPARK expression can also be a Z expression (auxiliary expression).
Auxiliary expressions are used in VC generation to deal with assignments
where the name on the left hand side of the {\tt ::=} involves array indexing.
}\epar 

\bpar{
Bringing all the above SPARK expressions together.
$OTHER\_EXP$ is used to denote the SPARK expressions that are not
covered by the
above abstract syntax. It will include string literals for example.
An array aggregate of string literals will be represented in the abstract syntax
as one of the $array\_agg$ arms of the free type $EXP$; the subexpressions
(the string literals themselves) will be represented in $OTHER\_EXP$.
}\epar

=SPCZ  OTHER_EXP
=TEX

=SPCZ  EXP
=TEX


\newpage

\section{Abstract syntax of SPARK basic declarations}

\subsection{Overview}

\bpar{
This section defines the abstract syntax for the various forms of SPARK basic declaration.
The various forms are gathered together at the end of the section in the free type $BASIC\_DECL$.
}\epar

\subsection{Constants}

\bpar{
Concrete syntax.
}\epar

\begin{verbatim}
        PAY_DAY : constant WEEKDAY := FRI;
\end{verbatim}

\bpar{
Abstract syntax.
}\epar

=SPCZ  Const_Decl
=TEX

\subsection{Enumeration types}

\bpar{
Type definitions (the type without its name) are modelled first and then a type
declaration (the type with its name) is defined later in the section.
}\epar

\bpar{
Concrete syntax.
}\epar

\begin{verbatim}
        type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);
\end{verbatim}

\bpar{
Abstract syntax.
}\epar

=SPCZ  Enum_Type_Def
=TEX


\subsection{Array types}

\bpar{
Concrete syntax.
}\epar

\begin{verbatim}
        type ARR is array (DAY) of DAY;
        type ARR2 is array (DAY, HOURS) of DAY;
        type UNCON is array (DAY range <>) of DAY;
        type UNCON2 is array (DAY range <>, HOURS range <>) of DAY;
\end{verbatim}

\bpar{
Abstract syntax.
}\epar

\newpage


=SPCZ  Array_Def
=TEX


\bpar*{
Constrained and unconstrained arrays are distinguished in the abstract syntax in the
free type $TYPE\_DEF$ defined at the end of this section.
}\epar*

\subsection{Record types}

\bpar{
Concrete syntax without discriminant part.
}\epar

\begin{verbatim}
        type REC is
        record
           START : DAY;
           FINISH : DAY;
           YESTERDAY : ARR;
        end record;
\end{verbatim}

\bpar*{
Concrete syntax with discriminant part.
}\epar*

\begin{verbatim}
        type BUF(LEN : INTEGER) is
        record
           DATA : CHARACTER(1 .. LEN);
        end record;
\end{verbatim}

\bpar{
Abstract syntax.
}\epar

\bpar*{
$Var\_Decl$ is an Ada variable declaration.
}\epar*

=SPCZ  Var_Decl
=TEX
\bpar*{
$COMP\_SUB\_IND$ represents the limited forms of subtype indication that contain
a discriminant such as $1 .. LEN$ in the above example.
}\epar*

=SPCZ  COMP_SUB_IND
=TEX
\bpar*{
$COMP\_CONSTRAINTS$ represents the limited forms of constraint that may
appear in a record type definition and contain discriminants.
$Comp\_Decl$ represents a component declaration comprising a variable declaration
together with this limited form of constraint.
}\epar*

=SPCZ COMP_CONSTRAINT
=TEX

=SPCZ Comp_Decl
=TEX

=SPCZ  Record_Type_Def
=TEX



\subsection{Integer types}

\bpar{
Concrete syntax.
}\epar

\begin{verbatim}
        type HOURS is range 0..23;
\end{verbatim}

\bpar{
Abstract syntax.
}\epar

\bpar*{
An integer type is characterised by its range (schema $Range$ defined in section 3).
}\epar*

\subsection{Real types}

\bpar{
Concrete syntax.
}\epar

\begin{verbatim}
        type FIX is delta 0.1 range 5.1 .. 10.0;
        type FLOAT1 is digits 7 range -1.0 .. 1.0;
        type FLOAT2 is digits 6;

\end{verbatim}

\bpar{
Abstract Syntax.

A fixed point type is characterised by its delta and its range (schema {\it Range} is defined in section 3).

=SPCZ  Fixed_Type_Def
=TEX


For a floating point type there is always a digits value, but the range is optional.

=SPCZ  Floating_Type_Def_Range
=TEX

=SPCZ  Floating_Type_Def_No_Range
=TEX


}\epar

\bpar{
Bring all the above type definitions together.
}\epar

=SPCZ  TYPE_DEF
=TEX


\bpar{
A type declaration is a type definition together with its name.
}\epar

=SPCZ  Type_Decl
=TEX


\subsection{Subtypes}

\bpar{
Concrete syntax.
}\epar



\begin{verbatim}
        subtype WEEKDAY is DAY range MON .. FRI;
        subtype SUBFIX1 is FIX range 7.0 .. 9.0;
        subtype SUB1 is INTEGER range INTEGER(7.2) .. 10;
        subtype SUBFLOAT is FLOAT1 digits 4 range -0.8 .. 0.8;
        subtype SUBFIX2 is FIX delta 0.3 range 6.0 .. 10.0;
        subtype SUB is UNCON(WEEKDAY);
        subtype SUB2 is UNCON(WEEKDAY, HOURS);
        subtype SUB3 is DAY;
\end{verbatim}

\bpar{
Abstract syntax.
}\epar

\bpar*{
The free type $CONSTRAINT$ below represents the constraints in a subtype
declaration. The arm $range\_con$ represents the constraints in the
declarations of {\tt WEEKDAY}, {\tt SUBFIX1} and {\tt SUB1}.
The arm $floating\_con$
represents the constraint in the declaration of {\tt SUBFLOAT}.
The arm $fixed\_con$ represents the constraint in the declaration of 
{\tt SUBFIX2} and the arm $index\_con$ represents the constraints in the
declarations of {\tt SUB} and {\tt SUB2}. The ranges in the concrete syntax
for subtype declarations with {\tt\itshape digits} or {\tt\itshape delta}
are optional; the translation into abstract syntax should use the {\tt\itshape first}
and {\tt\itshape last} attributes of the type after the keyword {\tt\itshape is}
to supply the lower and upper bounds of the range if the range is omitted in the concrete
syntax.
}\epar*

=SPCZ  CONSTRAINT
=TEX


\bpar*{
A subtype indication such as {\tt DAY range MON .. FRI} or {\tt UNCON(WEEKDAY)}
in the above examples.
}\epar*

=SPCZ  Sub_Ind
=TEX

\bpar*{
A subtype declaration such as {\tt WEEKDAY} and {\tt SUB} above.
}\epar*

=SPCZ  Subtype_Decl
=TEX


\bpar{
Type, subtype and constant declarations are all basic declarations.
}\epar

=SPCZ  BASIC_DECL
=TEX


\section{Translating SPARK expressions}

\subsection{The function trans\_exp}

\bpar{
This section defines the function $trans\_exp$.
It is defined over the free type $EXP$ (section 3).
The translation of expressions is largely syntactic; that is, in a lot of cases,
the expression is all that is needed by the function $trans\_exp$.
Sometimes Z type information is required.
The function $trans\_exp$ is partial because there are certain expressions
that the compliance notation can not yet translate into Z, for example
string literals, arrays of string literals, real literals and two-dimensional
array aggregates.
}\epar

=SPCZ  trans_exp
=TEX


\bpar*{
$Exp\_Pars$ are the parameters (argument and conclusion) of $trans\_exp$.
}\epar*

=SPCZ  Exp_Pars
=TEX


\subsection{Translating identifiers}

\bpar{
If the expression is an identifier then it is translated as prescribed by $trans\_id$.
The function $trans\_id$ (translate identifier) could be implemented by translating
SPARK alphanumerics to the identical Z alphanumerics,
SPARK underscore to Z underscore and SPARK dot (used to select components
of a package) to three underscores in Z. (Two Z underscores can be used to
translate SPARK attributes.)
}\epar
 
=SPCZ  trans_id
=TEX

\bpar*{
Inside packages within package bodies, it is permitted to use
identifiers of the form {\it package\_name.id} or {\it subprogram\_name.id} where
{\it package\_name} is the name of the
enclosing package and where {\it id} does not contain any further
package names. Such identifiers are to be
translated with the package name removed, i.e., they are 
to be translated in the same way as {\it id}.
The rules on redeclaration of names together with the Ada scope rules ensure that
it is valid to ignore the package or subprogram name.

Note that this only applies to SPARK identifiers used
within the declarative region of the containing
package body or subprogram. Outside a package body, the
package name must be used to identify an entity in the package. Outside a subprogram
body, the entities local to the subprogram may not be referred to in SPARK.
}\epar*

\bpar{
Formal specification.
}\epar

=SPCZ  Exp_Id
=TEX

\subsection{Translating aggregates (positional array)}

\bpar{
A positional array aggregate such as \\
\ \\
{\tt ARR'(TUE, WED, THU, FRI, SAT, SUN, MON)} \\
\ \\
is translated as 

}\epar

\vertbarfalse
=GFT
succç(1-ARRvFIRST)ê»§TUE, WED, THU, FRI, SAT, SUN, MON¢
=TEX
\vertbartrue

\bpar{
Formal specification.
}\epar

\bpar*{
Notice that the above translation uses the Z translation of the Ada attribute {\tt ARR'FIRST}.
Z translations of attribute designators such as {\tt FIRST} are therefore required.
All the translations of attribute designators required in this document are introduced at this point.
}\epar*

=SPCZ  zfst
=TEX

=SPCZ  zlst
=TEX

=SPCZ  zsuc
=TEX

=SPCZ  zpred
=TEX

=SPCZ  zpos
=TEX

=SPCZ  zval
=TEX

=SPCZ  zlength
=TEX

=SPCZ  zrange
=TEX

=SPCZ  zdelta
=TEX

=SPCZ  zdigits
=TEX

\bpar*{
The remaining attributes defined in section 3.13.2 may appear as the
result of translating a SPARK expression, but their Z names are not used
in this document.
}\epar*


\bpar*{
The following infix operator{}
=INLINEFT
_ ^ _
=TEX
{ }concatenates two Z identifiers.
It is used in the translation of attributes (its second argument is an attribute designator).
In Ada an apostrophe is used before the attribute designator so{}
=INLINEFT
_ ^ _
=TEX
{ }could be implemented
by having it put two Z underscores between its two arguments (the two underscores represent
the apostrophe).
}\epar*


=SPCZ  ^
=TEX



\bpar*{
The function $dimen$ appends a non-zero numeric suffix to a Z identifier.
This is used to translate attributes which take an array dimension number
as an optional argument.
A 0 argument to $dimen$ indicates the
case where no argument has been supplied to the attribute.
The suffix must be appended in such a way that the resulting identifier could not arise
from an Ada identifier with a numeric suffix (e.g., {\tt ARR'RANGE(2)} could be translated
as $ARRvRANGEv2$; {\tt ARR'RANGE} with no argument could be translated as
$ARRvRANGE$).
}\epar*

=SPCZ dimen
=TEX


\bpar*{
$map\ f\ s$ is the sequence $s$ with $f$ applied to each element.
}\epar*

=SPCZ map
=TEX

\newpage

\bpar*{
In order to translate multidimensional array aggregates, we need to distinguish between
an array aggregate appearing inside a qualified expression as a normal SPARK expression
and the special context of a subaggregate within a multidimensional array aggregate.
The function $trans\_array\_agg\_exp$ is used to do this.
Its first parameter gives the the type mark in the outer qualified expression,
the number of the dimension range we are currently working on and the total number
of dimensions.
This information is given in the schema $Array\_Agg\_Env$.
The situation where $this = max1 + 1$
means that we have finished processing the subaggregates of a multidimensional array
aggregate. The second parameter is the expression to be translated.
}\epar*

=SPCZ Array_Agg_Env
=TEX


\bpar*{
$trans\_array\_agg\_exp$ returns a partial function for the same reasons as $trans\_exp$.
The function is defined in stages. The predicate given here says that once
we have analysed all the dimensions we revert to using $trans\_exp$; this
will be strengthened later. 
}\epar*

=SPCZ trans_array_agg_exp
=TEX


\bpar*{
$Array\_Agg\_Pars$ represents the parameters (argument and result) of  $trans\_array\_agg$.
}\epar*

=SPCZ Array_Agg_Pars
=TEX


\bpar*{
$array\_first$ produces the Z translation of the {\tt FIRST} attribute we will require.
In the case of a one-dimensional array we drop the dimension specifier from the name.
}\epar*

=SPCZ array_first
=TEX

\newpage


=SPCZ Exp_Array_Agg_Pos
=TEX

\subsection{Translating aggregates (positional array with others)}

\bpar{
A positional array aggregate with an {\tt others} part such as \\
\ \\
{\tt ARR'(THU, WED, SUN, others => SAT)} \\
\ \\
is translated as 

}\epar
\vertbarfalse
=GFT
(ARRvRANGE ¸ {SAT}) « (succç(1-ARRvFIRST)ê»§THU, WED, SUN¢)
=TEX
\vertbartrue



\bpar{
Formal specification.
}\epar


=SPCZ Exp_Array_Agg_Pos_Others
=TEX

\subsection{Translating aggregates (array with just others)}

\bpar{
An array aggregate with just an {\tt others} part such as \\
\ \\
{\tt ARR'(others => WED)} \\
\ \\
is translated as 
}\epar

\vertbarfalse
=GFT
ARRvRANGE ¸ {WED}
=TEX
\vertbartrue



\bpar{
Formal specification.
$array\_range$ produces the Z translation of the {\tt RANGE} attribute we will require.
In the case of a one-dimensional array we drop the dimension specifier from the name.
}\epar

=SPCZ array_range
=TEX

=SPCZ Exp_Array_Agg_Others
=TEX

\subsection{Translating aggregates (named array)}

\bpar{
A named array aggregate such as \\
\ \\
{\tt ARR'(MON..THU | FRI => WED, SAT | SUN => TUE)} \\
\ \\
is translated as 
}\epar

\vertbarfalse
=GFT
(MON .. THU) À {FRI} ¸ {WED} À {SAT, SUN} ¸ {TUE}
=TEX
\vertbartrue

\bpar{
Formal specification.
Here and elsewhere it is convenient
to use the following function {\it z\_rng}. This expects its operands to be expressions that
are either both integers or both reals, and combines them with whichever
of {\it z\_int\_rng} {\it z\_real\_rng} makes the result well-typed.
(In the uses of {\it z\_rng} in translating aggregates, the operands will always be
integers if the SPARK program is well-typed.)

¹ZAX
Ü Ûz_rngÝ : Z_EXP ¸ Z_EXP ­ Z_EXP
°


The function $trans\_named\_assoc$ translates a named association such as {\tt MON..THU | FRI => WED}
in the above example. For example this particular named association is translated as{}
=INLINEFT
(MON .. THU) À {FRI} ¸ {WED}
=TEX
.
}\epar

\newpage


=SPCZ trans_named_assoc
=TEX

=SPCZ Exp_Array_Agg_Named
=TEX


\subsection{Translating aggregates (named array with others)}

\bpar{
A named array aggregate with an {\tt others} part such as \\
\ \\
{\tt ARR'(MON..FRI => WED, others => TUE)} \\
\ \\
is translated as 
}\epar

\vertbarfalse
=GFT
(ARRvRANGE ¸ {TUE}) « (MON .. FRI ¸ {WED})
=TEX
\vertbartrue


\bpar{
Formal specification.
}\epar


=SPCZ Exp_Array_Agg_Named_Others
=TEX


\bpar{
The following completes the definition of $trans\_array\_agg\_exp$.
We have already defined it for the situation when $this = max1 + 1$.
}\epar


{\def\PrNL#1\PrNN{\relax}
=SPCZ taaeconstraint
=TEX
}


\bpar*{
The function $array\_dim$ is given as argument a type mark.
If the type of the Z translation of this type mark matches the form{}
=INLINEFT
ð(X‰1 ¸ ... ¸ X‰n ­ X)
=TEX
,it returns $n$ --- the number of dimensions of the corresponding Ada array type.
It is partial, since the Z translation may not be of this form.
}\epar*

=SPCZ array_dim
=TEX

\bpar*{
The function $mk\_array\_agg$ applies one of the SPARK toolkit functions
that convert the translation of an array aggregate into the appropriate type.
The name of these functions depends on the maximum dimension of the array.
The functions are called $array\_agg2$, $array\_agg3$, $array\_agg4$ etc.,
and the function $z\_array\_agg$ calculates these names.
No conversion is required for one-dimensional array aggregates:
}\epar*

=SPCZ z_array_agg
=TEX

\newpage


=SPCZ mk_array_agg
=TEX


\bpar*{
The schema $Exp\_Array\_Agg$ packages up $trans\_array\_agg\_exp$ in
a form that can be used to define $trans\_exp$.
}\epar*

=SPCZ Exp_Array_Agg
=TEX

\subsection{Translating aggregates (positional record)}

\bpar{
A positional record aggregate such as \\
\ \\
{\tt REC'(WED, SUN, ARR'(others => THU))} \\
\ \\
is translated as 
}\epar

\vertbarfalse
=GFT
(START ¦ WED, FINISH ¦ SUN, YESTERDAY ¦ ARRvRANGE ¸ {THU})
=TEX
\vertbartrue

\bpar{
Formal specification.
When translating a record aggregate the names of the components of the record type are needed.
Unfortunately (unlike a {\it named} record aggregate) these names do not appear in a positional record aggregate. This information can be retrieved from the
Z type of the type mark in the aggregate ({\tt REC} in the above example).
}\epar


=SPCZ Exp_Rec_Agg_Pos
=TEX


\subsection{Translating aggregates (named record)}

\bpar{
A named record aggregate such as
}\epar

\begin{verbatim}
        REC'(START => THU,
             FINISH => FRI,
             YESTERDAY => ARR'(others => SUN))
\end{verbatim}

\bpar*{
is translated as 
}\epar*

\vertbarfalse
=GFT
(START ¦ THU, FINISH ¦ FRI, YESTERDAY ¦ ARRvRANGE ¸ {SUN})
=TEX
\vertbartrue

\bpar{
Formal specification.
}\epar

=SPCZ Exp_Rec_Agg_Named
=TEX

\subsection{Translating unary expressions}

\bpar{
When translating a unary expression, unary addition is dropped and the other unary operators
are translated as below; the Z $not$ and $abs$ are defined in the extension to the Z
toolkit (appendix B of volume 1).
\vertbarfalse
=GFT
	SPARK	Z
	-		unary_minus,real_unary_minus
	not		bool_not,array_not
	abs		abs,real_abs
=TEX
\vertbartrue

The specification of {\it trans\_unary\_op} is loose.
The implementation of {\it trans\_unary\_op} must select
from the set returned by {\it unary\_ops} the operator that
has the correct type to be applied to the operand whenever possible.
}\epar

\bpar{
Formal specification.
}\epar

=SPCZ unary_ops
=TEX

=SPCZ trans_unary_op
=TEX



=SPCZ Exp_Unary_Exp
=TEX


\subsection{Translating binary expressions}

\bpar{
When translating a binary expression the infix operators are translated as below;
where all but Z $+$,\ $-$,\ and $*$ are defined in the extension to the Z toolkit (appendix B of volume 1).
}\epar

\vertbarfalse
=GFT
SPARK	Z
and		bool_and, array_and 
or		bool_or, array_or  
and_then	bool_and 
or_else	bool_or 
xor		bool_xor 
eq		bool_eq 
noteq		bool_noteq 
less 		bool_less, array_less, bool_real_less 
less_eq	 	bool_less_eq, array_less_eq, bool_real_less_eq 
greater	 	bool_greater, array_greater, bool_real_greater 
greater_eq	bool_greater_eq, array_greater_eq, bool_real_greater_eq 
add		add, real_add 
minus		minus, real_minus 
times		times, real_times 
div 		intdiv, real_div 
mod		mod 
over 		real_over  
rem		rem 
expon 		expon, real_expon 
mem 		bool_mem 
notmem	bool_notmem 
cat 		array_array_cat, array_elem_cat, elem_array_cat 
=TEX	
\vertbartrue


\bpar{
The specification of {\it trans\_bin\_op} is loose.
The implementation of {\it trans\_bin\_op} must select
from the set returned by {\it bin\_ops} the operator that
has the correct type to be applied to the operands whenever possible,
subject to the constraint that the operator {z\_elem\_array\_cat} is only allowed when
the right-hand operand is a string literal.
}\epar


\bpar*{
Formal specification.
}\epar*

=SPCZ bin_ops
=TEX

=SPCZ trans_bin_op
=TEX

=SPCZ Exp_Bin_Exp
=TEX

\subsection{Translating membership of a range}

\bpar{
Membership of a range such as \\
\ \\
{\tt PAY\_DAY not in SAT .. SUN} \\
\ \\
is translated as 
}\epar

\vertbarfalse
=GFT
PAY_DAY notmem SAT .. SUN
=TEX
\vertbartrue


\bpar{
Formal specification.
}\epar

=SPCZ Exp_Mem_Range
=TEX

\subsection{Translating attributes}

\bpar{
An attribute such as {\tt WEEKDAY'FIRST} is translated as the Z identifier $WEEKDAYvFIRST$.
{\it trans\_attr\_prefix} converts the prefix of an attribute into
a Z identifier. This may involve replacing object names and expressions
such as function calls by their types and
replacing occurrences of the base attribute by the appropriate base type name. 

The generation of Z paragraphs declaring the Z translation of attributes in the
set {\it OTHER\_ATTRIB}, such as {\tt\itshape WEEKDAY'SIZE} is not specified formally.
The declarations could either be introduced by the user or generated
as needed by the tool so that the Z expressions resulting from the above translation
is well-typed.
}\epar

\bpar*{
Formal specification.
}\epar*

=SPCZ trans_attr_prefix
=TEX


=SPCZ Exp_Attrib
=TEX


\newpage


\bpar{
An attribute other than an array attribute, such as {\tt DAY'SUCC(WED)}, is translated as the Z function call $DAYvSUCC(WED)$.
}\epar

\bpar*{
Formal specification. $ARRAY\_ATTRIB$ is the set of identifiers for the array attributes that are
supported.
}\epar*

=SPCZ ARRAY_ATTRIB
=TEX

=SPCZ Exp_Nonarray_Attrib_Arg
=TEX


\bpar{
An array attribute such as {\tt ARR2'RANGE(2)} is translated as $ARR2vRANGEv2$.
}\epar

\bpar*{
Formal specification. The function $eval\_attr\_arg$ is intended to give the
result of static (i.e., compile-time)
evaluation of a SPARK expression. It is a partial function.
Only static expressions that evaluate to positive natural numbers are in its domain.
}\epar*

=SPCZ eval_attr_arg
=TEX

=SPCZ Exp_Array_Attrib_Arg
=TEX

=SPCZ Exp_Attrib_Arg
=TEX


\subsection{Translating indexed components}

\bpar{
An array component such as {\tt TOMORROW(DAY'FIRST)} is translated as the Z function call $TOMORROW(DAYvFIRST)$.
}\epar

\bpar{
Formal specification.
}\epar



=SPCZ Exp_Indexed_Comp
=TEX

\subsection{Translating selected components}

\bpar{
A record component such as {\tt REC2.FINISH} is translated as the Z binding selection $REC2.FINISH$.
}\epar

\bpar{
Formal specification.
}\epar

=SPCZ Exp_Selected_Comp
=TEX


\subsection{Translating function calls}



\bpar{
A function call such as {\tt MAX(WED, DAY'LAST)} is translated as the Z function call \\
$MAX(WED, DAYvLAST)$.
If the function {\tt F} has global dependencies, on the variables
{\tt A}, {\tt B} and {\tt C} say, then {\tt F(X, Y, Z)} is translated as $F(A, B, C)(X, Y, Z)$.
}\epar

\bpar{
Formal specification.
}\epar



\bpar*{
The function $fun\_globals$ finds the expressions representing
the list of global variables on which the function depends.
These correspond to the list of dependencies given, if any, given after $\Xi$
in the function specification statement.
For each item, $V$ in the list, the corresponding expression is the Z identifier, $V$ if
the $V$ denotes a program variable or an auxiliary variable and  is the expression $\theta V$
if $V$ denotes a schema.
In an implementation, this may be calculated from the $Formal\_Fun$
data structure associated with the function in volume 1.
}\epar*

=SPCZ fun_globals
=TEX
\bpar*{The function {\it fun\_param\_tmarks} gives the sequence of type marks for
the formal parameters of a function:

=SPCZ fun_param_tmarks

The function {\it slide\_to\_tmark} takes as parameters a Z expression and a type mark.
If the type mark denotes a constrained subtype of an
unconstrained array type, {\it slide\_to\_tmark}
returns a Z expression denoting the result of sliding the range of the array represented
by the Z expression so that it agrees with the range constraint defining the subtype.
For other sorts of type mark, {\it slide\_to\_tmark} just returns the Z expression
supplied as a parameter.
For example, consider the following declarations:
=GFT
	type UC_ARR is array (integer range <>) of character;
	type index1 is 1 .. 10;
	subtype CON_ARR1 is UC_ARR(index1);
	type index2 is 2 .. 11;
	subtype CON_ARR2 is UC_ARR(index2);
	x : CON_ARR2;
	y : float;
=TEX
In the scope of these declarations,
=INLINEFT
slide_to_tmark(ûXý, ûCON_ARR1ý)
=TEX
\ would return the Z expression
=INLINEFT
ûslide(X, INDEX1)ý
=TEX
, whereas
=INLINEFT
slide_to_tmark(ûYý, ûFLOATý)
=TEX
\ would return the Z expression
=INLINEFT
ûYý
=TEX
.
}\epar*

=SPCZ slide_to_tmark

\bpar*{
The function $trans\_fun\_name$ translates the function name into an appropriate Z expression.
}\epar*

=SPCZ trans_fun_name
=TEX

=SPCZ Exp_Fun_Call
=TEX


\subsection{Translating qualified expressions}

\bpar{
A qualified expression {\tt TMARK'(EXP)} is translated as $EXP$.
}\epar

\bpar{
Formal specification.
}\epar

=SPCZ Exp_Qualified
=TEX


\subsection{Translating type conversions}

\bpar{
A type conversion {\tt TMARK(EXP)} is translated as $EXP$ provided that the
conversion is between scalar types.
}\epar

\bpar{
Formal specification.
}\epar

=SPCZ Exp_Type_Conv
=TEX

\subsection{Translating integer literals}

\bpar{
Ada integer literals such as {\tt 25},\ {\tt 15\_234},\ {\tt 12E3} and {\tt 2\#101\#} could be translated
into Z as $25$,\ $15234$,\ $12000$ and $5$.
The extension to the Z toolkit (appendix B of volume 1) defines $**$ and so {\tt 12E3} could be translated as $12*10**3$.
}\epar

\bpar{
Formal specification.
}\epar

=SPCZ trans_int
=TEX


=SPCZ Exp_Int_Lit
=TEX

\subsection{Translating real literals}

\bpar{

The underlying Z tool must provide support for expressing real literal
values adequate to represent the decimal fractions with optional integer exponents
that occur as SPARK real literals.
}\epar

=SPCZ trans_real
=TEX

=SPCZ Exp_Real_Lit
=TEX

\subsection{Translating character literals}

\bpar{
We assume that the underlying Z tool has support for string literals but not
character literals. Character literals might then be represented as singleton strings
and {\it z\_char\_lit} would be a function that extracts the integer code for the member
of a singleton string.
}\epar

=SPCZ trans_char
=TEX

=SPCZ Exp_Char_Lit
=TEX

\subsection{Translating string literals}

\bpar{
We assume that the underlying Z tool has support for string literals, but we
do not expect them to have the same type as the sequences of integers that represent
Ada strings. {\it z\_string\_lit} is a function that converts a Z string literal into
a sequence of integer character codes.

}\epar

=SPCZ trans_string
=TEX

=SPCZ Exp_String_Lit
=TEX


\subsection{Translating auxiliary expressions}

\bpar{
An auxiliary expression is already a Z expression and so does not need translating.
}\epar

\bpar{
Formal specification.
}\epar 

=SPCZ Exp_Auxiliary_Exp
=TEX


\bpar{
Predicate stating that the above schemas define the function $trans\_exp$.
}\epar


{\def\PrNL#1\PrNN{\relax}
=SPCZ trans_expconstraint
=TEX
}
\section{Translating SPARK basic declarations}


\subsection{The function trans\_basic\_decl}

\bpar{
This section defines the function $trans\_basic\_decl$.
The function is defined on each arm of the free type $BASIC\_DECL$ (section 4).
The translation of basic declarations is largely syntactic;
that is, in a lot of cases, the basic declaration is all that is needed
by the function $trans\_basic\_decl$. Sometimes Z type information is required.
}\epar

=SPCZ trans_basic_decl
=TEX


\bpar*{
The parameters (argument and result) of $trans\_basic\_decl$.
}\epar*

=SPCZ Basic_Decl_Pars
=TEX


\subsection{Translating constants}

\bpar{
A constant declaration such as \\
\ \\
{\tt PAY\_DAY : constant WEEKDAY := FRI;} \\
\ \\
is translated as a Z axiomatic description:
=GFT
	PAY_DAY : WEEKDAY
÷
	PAY_DAY = FRI
=TEX
A named number declaration such as \\
\ \\
{\tt DAYS\_PER\_YEAR : constant := 365;} \\
\ \\
is translated as a Z abbreviation definition:
=GFT
	DAYS_PER_YEAR == 365
=TEX
}\epar

\bpar{
Formal specification.
}\epar

=SPCZ Basic_Decl_Const_1
=TEX

\bpar{
A constant declaration with a type mark for which the initial expression cannot be translated into Z
is translated into a Z axiomatic description with no predicate.

A named number declaration for which the
expression cannot be translated into Z cannot be handled formally
and is ignored. A tool may give a warning message when this happens,
since it will not be possible to handle uses of the named numbers formally.
}\epar


\bpar{
Formal specification.
}\epar

=SPCZ Basic_Decl_Const_2
=TEX


\subsection{Translating enumeration types}

\bpar{
An enumeration type declaration such as \\
\ \\
{\tt type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);} \\
\ \\
is translated as
}\epar

\vertbarfalse
=GFT 
MON == 0 
TUE == 1 
WED == 2 
THU == 3 
FRI == 4 
SAT == 5 
SUN == 6 
DAY == MON .. SUN 
DAYvFIRST == MON 
DAYvLAST == SUN 
DAYvSUCC == (DAY \ { DAYvLAST }) ò succ 
DAYvPRED == DAYvSUCC~ 
DAYvPOS == id DAY 
DAYvVAL == DAYvPOS~
=TEX
\vertbartrue



\bpar{
Formal specification.
The function $enum\_attrib$ generates the Z translation of the attributes for an enumeration type.
}\epar

=SPCZ enum_attrib
=TEX

=SPCZ Basic_Decl_Enum
=TEX


\subsection{Translating array types}


\bpar{
A constrained array type declaration such as \\
\ \\
{\tt type ARR is array (DAY) of DAY;} \\
\ \\
is translated as 
}\epar

\vertbarfalse
=GFT
ARR == DAY ­ DAY 
ARRvFIRST == DAYvFIRST
ARRvLAST == DAYvLAST 
ARRvLENGTH == #DAY 
ARRvRANGE == DAY 
ARRvFIRSTv1 == DAYvFIRST 
ARRvLASTv1 == DAYvLAST 
ARRvLENGTHv1 == #DAY 
ARRvRANGEv1 == DAY
=TEX
\vertbartrue


\newpage


\bpar*{
A 2-dimensional (or above) constrained array type declaration such as \\
\ \\
{\tt type ARR2 is array (DAY, HOURS) of DAY;} \\
\ \\
is translated as 
}\epar*

\vertbarfalse
=GFT
ARR2 == DAY ¸ HOURS ­ DAY 
ARR2vFIRST == DAYvFIRST 
ARR2vLAST == DAYvLAST 
ARR2vLENGTH == #DAY 
ARR2vRANGE == DAY 
ARR2vFIRSTv1 == DAYvFIRST 
ARR2vLASTv1 == DAYvLAST 
ARR2vLENGTHv1 == #DAY 
ARR2vRANGEv1 == DAY 
ARR2vFIRSTv2 == HOURSvFIRST 
ARR2vLASTv2 == HOURSvLAST 
ARR2vLENGTHv2 == #HOURS 
ARR2vRANGEv2 == HOURS
=TEX
\vertbartrue

\bpar*{
Formal specification.
The function $array\_attrib$ generates the Z translation of the attributes for a constrained array type.
}\epar*

=SPCZ array_attrib_aux
=TEX

=SPCZ array_attrib
=TEX


\newpage


=SPCZ Basic_Decl_Con_Array
=TEX

\bpar{
An unconstrained array type declaration such as \\
\ \\
{\tt type UNCON is array (DAY range <>) of DAY;} \\
\ \\
is translated as 
}\epar

¹IZAX
UNCON :  ð(DAY ß DAY)
°

\bpar*{
A 2-dimensional (or above) unconstrained array type declaration such as \\
\ \\
{\tt type UNCON2 is array (DAY range <>, HOURS range <>) of DAY;} \\
\ \\
is translated as 
}\epar*

¹IZAX
UNCON2 :  ð(DAY ¸ HOURS ß DAY)
°

\bpar*{
Formal specification.
An unconstrained array type declaration is translated as a subset
of all {\it partial} functions from the index
type to the component type.
(It is translated as a subset because the index of an array must be contiguous.)
This is because an unconstrained array type could later be constrained to
arrays of any length (using a subtype declaration).
}\epar*

\newpage


=SPCZ Basic_Decl_Uncon_Array
=TEX


\subsection{Translating record types}

\bpar{
A record type declaration such as
}\epar

\begin{verbatim}
        type REC is
        record
           START : DAY;
           FINISH : DAY;
           YESTERDAY : ARR;
        end record;
\end{verbatim}

\bpar*{
is translated as
}\epar*

¹ÿ ÛRECÝ
START : DAY 
FINISH : DAY 
YESTERDAY : ARR 	
ˆ


\bpar*{
This must be followed by definitions of functions for updating record components as
used in calculating weakest preconditions for assignment statements in volume 2.
For example:
}\epar*

\newpage

¹œ[g1, g2, g3]œœœœœœœœ
Ü RECuSTART : [START : g1; FINISH : g2; YESTERDAY : g3] ¸ g1 ­
Ü		[START : g1; FINISH : g2; YESTERDAY : g3];
Ü RECuFINISH : [START : g1; FINISH : g2; YESTERDAY : g3] ¸ g2 ­
Ü		[START : g1; FINISH : g2; YESTERDAY : g3];
Ü RECuYESTERDAY : [START : g1; FINISH : g2; YESTERDAY : g3] ¸ g3 ­
Ü		[START : g1; FINISH : g2; YESTERDAY : g3]
÷üüüüüüüüüüüüüüüüü
Ü µ r : [START : g1; FINISH : g2; YESTERDAY : g3]; x1 : g1; x2 : g2; x3 : g3
Ü   · RECuSTART (r, x1) 
Ü	= (FINISH ¦ r.FINISH, START ¦ x1, YESTERDAY ¦ r.YESTERDAY)
Ü     ± RECuFINISH (r, x2)
Ü       = (FINISH ¦ x2, START ¦ r.START, YESTERDAY ¦ r.YESTERDAY)
Ü     ± RECuYESTERDAY (r, x3)
Ü       = (FINISH ¦ r.FINISH, START ¦ r.START, YESTERDAY ¦ x3)
ˆüüüüüüüüüüüüüüüüü

\bpar{
Formal specification.
}\epar


=SPCZ trans_decl
=TEX

\bpar*{
The following function generates the Z definitions of
the record update functions for all the components
of the schema representing a record type (including
any discriminants).
}\epar*

=SPCZ record_update_defs
=TEX
\bpar*{
In translating a record type with a discriminant part,
a component declaration such as  {\tt C : ARR(DAY, 1 .. SIZE)}  with an index constraint 
containing a discriminant is translated into a Z  predicate requiring $C$ to belong to the set
of indices satisfying the constraint. The following function is used to construct the
Z expressions needed to describe this set.
}\epar*

=SPCZ trans_comp_sub_ind
=TEX

\bpar*{
In translating a record type with a discriminant part,
a component declaration such as  {\tt D : BUFFER(SIZE => 20)}  with a discriminant constraint 
containing a discriminant is translated into a Z  predicate requiring $D.SIZE.$ to be equal
to the actual discriminant expression, 20. The following function translates a component declaration
in to the resulting predicate.
}\epar*

=SPCZ trans_comp_decl
=TEX



=SPCZ Basic_Decl_Record
=TEX

\subsection{Translating integer types}

\bpar{
An integer type declaration such as \\
\ \\
{\tt type HOURS is range 0..23;} \\
\ \\
is translated as
}\epar

\bpar*{
$
HOURS == 0..23 \\
HOURSvFIRST == 0 \\
HOURSvLAST == 23 \\
| HOURSvSUCC : ú \pfun ú \\
| HOURSvPRED : ú \pfun ú \\
| HOURSvPOS : ú \pfun ú \\
| HOURSvVAL : ú \pfun ú
$
}\epar*

\bpar{
Formal specification.
The function $int\_type\_attrib$ generates the Z translation of the attributes for an integer type. $z\_ints$ represents the Z identifier $ú$.
}\epar

=SPCZ z_ints
=TEX

=SPCZ int_type_attrib
=TEX

=SPCZ Basic_Decl_Int_Type
=TEX

\subsection{Translating real types}

\bpar{

A fixed point type declaration such as:

{\tt\itshape type FIX is delta 0.1 range 5.1 .. 10.0;}

is translated as:

\vertbarfalse
=GFT
	FIX == 51 e ~1 ..‰R 1 e 1
	FIXvDELTA == 1 e ~1
	FIXvFIRST == 51 e ~1
	FIXvLAST == 1 e 1
=TEX
\vertbartrue

=SPCZ Basic_Decl_Fixed_Type
=TEX

A floating point type declaration such as:

{\tt\itshape type FLOAT1 is digits 7 range -1.0 .. 1.0;}

is translated as:

\vertbarfalse
=GFT
	FLOAT1 == ~‰R (1 e 0) ..‰R 1 e 0
	FLOAT1vDIGITS == 7
	FLOAT1vFIRST == ~‰R (1 e 0)
	FLOAT1vLAST == 1 e 0
=TEX
\vertbartrue

=SPCZ Basic_Decl_Floating_Type_Range
=TEX

A floating point type declaration with no range such as:

{\tt\itshape type FLOAT2 is digits 6;}

is translated as:

\vertbarfalse
=GFT
	FLOAT2vFIRST : ¯
	FLOAT2vLAST : ¯
	FLOAT2 == FLOAT2vFIRST .. FLOAT2vLAST
	FLOAT2vDIGITS == 6
=TEX
\vertbartrue


{\it z\_reals} represents the Z identifier for the set of all real numbers (¯).

}\epar

=SPCZ z_reals
=TEX

=SPCZ Basic_Decl_Floating_Type_No_Range
=TEX


\subsection{Translating subtypes}

\bpar{

In a subtype declaration with a range constraint, it
is possible either that the base type
is not translated into  Z with type {\sf P Z} or {\sf P R} (because
its definition contained expressions that are outside the domain of
{\it trans\_exp})
or that the range constraint cannot be translated into Z
(because it contains expressions that are outside the domain of
{\it trans\_exp}).
A subtype declaration of this sort is translated into an axiomatic description
with no defining predicate.
For example, if the user has not introduced Z paragraphs introducing
the Z translation of the attribute {\tt\itshape v'address}, then
the subtype declaration

{\tt\itshape subtype SUB1 is INTEGER range v'address .. v'address + 10;}

will be translated as:

\vertbarfalse
=GFT
SUB1 : ð INTEGER
=TEX
\vertbartrue


}\epar

\bpar*{
Formal specification.
The function $range\_con\_attrib$ generates the Z translation of the attributes for a subtype declaration
which has a range constraint.
}\epar*

=SPCZ range_con_attrib
=TEX

=SPCZ Basic_Decl_Subtype_Range_Con_1
=TEX


\bpar{
A subtype declaration, of a type that is {\it not} translated into Z with type
$ð\ ú$, or has a range constraint that can {\it not}
be translated into Z, such as \\
\ \\
{\tt subtype SUBFIX1 is FIX range 7.0 .. 9.0;} \\
{\tt subtype SUB1 is INTEGER range INTEGER(7.2) .. 10;} \\
\ \\
are translated as
}\epar

¹IZAX
SUBFIX1: ð FIX
°

¹IZAX
SUB1: ð INTEGER
°


\bpar*{
Formal specification.
}\epar*

=SPCZ Basic_Decl_Subtype_Range_Con_2
=TEX

\bpar{
A subtype declaration for a real type with a range constraint which can be translated
into Z such as:

{\tt\itshape subtype SUBFIX1 is FIX	 RANGE 7.0 .. 9.0;}

is translated into Z as follows:

\vertbarfalse
=GFT
SUBFIX1 == 7 e 0 ..‰R 9 e 0
SUBFIX1vDELTA = FIXvDELTA
SUBFIX1vFIRST == 7 e 0
SUBFIX1vLAST == 9 e 0
=TEX
\vertbartrue
}\epar

\bpar{
Formal specification. The formal specification uses an auxiliary function $type\_attrs$
to list the attributes that apply in some order. In the above example,
$type\_attrs\ DAY$ would be $\langle delta, fst, lst val \rangle$


=SPCZ type_attrs
=TEX

=SPCZ Basic_Decl_Subtype_Range_Con_3
=TEX
}\epar

\bpar{
Predicate stating that the above schemas define the function $trans\_basic\_decl$.
}\epar


\bpar{
Subtype declarations with floating or fixed point constraints such as \\
\ \\
{\tt subtype SUBFLOAT is FLOAT1 digits 4 range -0.8 .. 0.8;} \\
{\tt subtype SUBFIX2 is FIX delta 0.3 range 6.0 .. 10.0;} \\
\ \\
are translated as
}\epar

\vertbarfalse
=GFT
	SUBFLOAT == ~‰R (8 e 1) ..‰R 8 e 1
	SUBFLOATvDIGITS = 4
	SUBFLOATvFIRST == ~‰R(8 e ~1)
	SUBFLOATvLAST == 8 e ~‰R 1
 
	SUBFIX2 == 6 e 0 ..‰R 1 e 1
	SUBFIX2vDELTA == 3 e 1
	SUBFIX2vFIRST == 6 e 0
	SUBFIX2vLAST == 1 e 1
=TEX
\vertbartrue

\bpar*{
Formal specification.
}\epar*

=SPCZ Basic_Decl_Subtype_Fixed_Con
=TEX

=SPCZ Basic_Decl_Subtype_Floating_Con
=TEX


\newpage


\bpar{
A subtype declaration with an index constraint such as \\
\ \\
{\tt subtype SUB is UNCON(WEEKDAY);} \\
\ \\
is translated as 
}\epar

\vertbarfalse
=GFT
SUB == { U : UNCON | dom U = WEEKDAY} 
SUBvFIRST == WEEKDAYvFIRST
SUBvLAST == WEEKDAYvLAST 
SUBvLENGTH == #WEEKDAY 
SUBvRANGE == WEEKDAY 
SUBvFIRSTv1 == WEEKDAYvFIRST
SUBvLASTv1 == WEEKDAYvLAST 
SUBvLENGTHv1 == #WEEKDAY
SUBvRANGEv1 == WEEKDAY
=TEX
\vertbartrue


\newpage


\bpar*{
A subtype declaration with a 2-dimensional (or above) index constraint
such as \\
\ \\
{\tt subtype SUB2 is UNCON(WEEKDAY, HOURS);} \\
\ \\
is translated as 
}\epar*

\vertbarfalse
=GFT
SUB2 == { U : UNCON | dom U = WEEKDAY ¸ HOURS} 
SUB2vFIRST == WEEKDAYvFIRST
SUB2vLAST == WEEKDAYvLAST 
SUB2vLENGTH == \#WEEKDAY 
SUB2vRANGE == WEEKDAY 
SUB2vFIRSTv1 == WEEKDAYvFIRST
SUB2vLASTv1 == WEEKDAYvLAST 
SUB2vLENGTHv1 == #WEEKDAY
SUB2vRANGEv1 == WEEKDAY 
SUB2vFIRSTv2 == HOURSvFIRST 
SUB2vLASTv2 == HOURSvLAST 
SUB2vLENGTHv2 == #HOURS 
SUB2vRANGEv2 == HOURS
=TEX
\vertbartrue

\bpar*{
Formal specification.
}\epar*

=SPCZ Basic_Decl_Subtype_Index_Con
=TEX

\bpar{
A subtype declaration with a discriminant constraint such as \\
\ \\
{\tt subtype BUF80 is BUF(SIZE => 80);} \\
\ \\
is translated as 
}\epar

\vertbarfalse
=GFT
BUF80 == [BUF | SIZE = 80] 
=TEX
\vertbartrue



=SPCZ Basic_Decl_Subtype_Disc_Con
=TEX

\bpar{
A subtype declaration without a constraint such as \\
\ \\
{\tt subtype SUB3 is DAY;} \\
\ \\
is translated as 
}\epar

\vertbarfalse
=GFT
SUB3 == DAY 
SUB3vFIRST == DAYvFIRST 
SUB3vLAST == DAYvLAST 
SUB3vSUCC == DAYvSUCC 
SUB3vPRED == DAYvPRED 
SUB3vPOS == DAYvPOS 
SUB3vVAL == DAYvVAL
=TEX
\vertbartrue

\bpar*{
Here, all attributes that are available for $DAY$ are also made available for $SUB3$.




=SPCZ Basic_Decl_Subtype_No_Con
=TEX

{\def\PrNL#1\PrNN{\relax}
=SPCZ tbdconstraint
=TEX
}
}\epar*

\section{Preprocessing of Declarations for Subtypes}

\subsection{Abstract Syntax for Basic Declarations}
 
\bpar{
The derived Abstract Syntax allows free use of subtype indications
and ranges in places where the basic Abstract Syntax requires a type mark
but Ada allows the more general form.
Where a variable or schema in the derived Abstract Syntax is derived from one in the Abstract Syntax,
its name is derived by adding the prefix ``{\it SI\_}'' or ``{\it si\_}''.  In the input to preprocessing
typemarks will always be valid Ada identifiers, whereas the output contains additional identifiers
which are not valid Ada identifiers. These are the machine-generated identifiers of the implicit subtypes of the subprogram whose explicit declarations are introduced by the preprocessing.}\epar

\subsection{Discrete Ranges}
\bpar{At first sight the type of subtype indication might appear to be recursive because
index constraints can have subtype indications as arguments. However, these can only
be of discrete types and for these the form of constraint is just a simple range.
Discrete ranges can be expressed in terms of the post-processed abstract syntax for 
subtypes, thus avoiding circularity.}\epar

=SPCZ SI_Discrete_Range

\subsection{Constraints}
\bpar{Formal specification. Constraints include array constraints which use {\tt\itshape SI\_Discrete\_Range}.}\epar


=SPCZ SI_CONSTRAINT

\subsection{Subtype Indications}

\bpar{Formal specification. Subtype indications must be defined in terms of these more general constraints.}\epar

=SPCZ SI_Sub_Ind

\subsection{Constant declarations}
\bpar{Formal specification.}\epar

=SPCZ SI_Const_Decl
\subsection{Array types}

\bpar{Formal specification. An array type index position can contain either a subtype 
indication or a range (which could be a range attribute or an explicit range but will always
be presented to the preprocessing as the latter).}\epar

=SPCZ SI_Array_Def
 
\subsection{Record types}

\bpar{Formal specification. Variable declarations inside
record type definitions may contain subtype indications.}\epar
=SPCZ SI_Var_Decl

=SPCZ SI_Record_Type_Def

\subsection{Type definitions}

\bpar{Formal specification. In this derived syntax enumerated, integer and real types are as in the basic syntax}\epar

=SPCZ SI_TYPE_DEF
\subsection{Type declarations}

\bpar{Formal specification.}\epar

=SPCZ SI_Type_Decl

\subsection{Subtype declarations}
\bpar{Formal specification.}\epar

=SPCZ SI_Subtype_Decl
\subsection{Basic declarations}
\bpar{Formal specification.}\epar

=SPCZ SI_BASIC_DECL
\subsection{Preprocessing of Basic declarations}


\subsection{Machine generated identifiers}
\bpar{A basic declaration from the literate script is preprocessed to create one or more
basic declarations which are then translated in sequence.
Machine generated identifiers are used for any additional declarations
produced by the preprocessing.
The machine-generated identifiers that are produced must all be distinct.}\epar

=SPCZ generate_id
=SPCZ si_generate_id

\subsection{ Declaration of implied subtypes}

\bpar{The following schema relates a subtype indication, the fresh identifier made
for it, the generated explicit declaration for the subtype, if a proper subtype is indicated,
otherwise equates the name to the indicated type mark.}\epar

=SPCZ adjust_subtype

\subsection{Discrete Ranges}

\bpar{Discrete ranges give rise to explicit declarations either because they are 
subtypes or because they are ranges and are considered to define a subtype of 
the universal discrete type. The universal discrete type
is denoted by a type mark distinct from any Ada identifier
and from any machine-generated identifier. It is the Z name 
for the universal discrete type in the SPARK toolkit.}\epar

=SPCZ universal_discrete_type
=SPCZ adjust_discrete_range_subind
=SPCZ adjust_discrete_range_range
=SPCZ adjust_discrete_range
\subsection{Constraints}
\bpar{When we come to the index case of {\tt\itshape CONSTRAINT} we may find
implied declarations of discrete subtypes which must be made explicit.
{\tt\itshape adjust\_discrete\_range} is used below as if it were fully determined whereas this specification does not fully determine it and it is required to produce a fresh identifier for each new syntactic occurrence of an implicit subtype. The details of this are left to the implementationn}\epar


=SPCZ adjust_constraint
\subsection{General subtypes}

\bpar{We can now prescribe the preprocessing of general subtype indications.}\epar

=SPCZ adjust_general_subtype
\subsection{Constant declaration}
\bpar*{
Given an expression, $e$, which is an array aggregate with the optional type mark
omitted and a typemark, $tm$, $add\_tmark(e, tm)$ is the result of inserting the
supplied type mark in place of the omitted type mark in $e$. If $e$ has any other form,
 $add\_tmark(e, tm) = e$.
}\epar*

=SPCZ add_tmark

\bpar{{\it adjust\_const\_decl} preprocesses a constant declaration.}\epar
=SPCZ adjust_const_decl
\subsection{Elementary type declarations}

\bpar{Continuing with the preprocessing of basic declarations,
enumerated types, integer types and real types never contain subtype indications.}\epar

=SPCZ adjust_elementary_types

\bpar*{Then we can describe the transformation of elementary type declarations where the 
correspondence is one to one.}\epar*

=SPCZ adjust_elementary_type_decl
\subsection{Unconstrained array type declaration}

\bpar{Unconstrained array definitions can only use a subtype indication in the
element type position.}\epar

=SPCZ adjust_uncon_array_type_decl
\subsection{Constrained array type declaration}

\bpar{Each subscript position can hold a subtype indication or a range. For the 
range we declare a new subtype of the universal discrete type.}\epar

=SPCZ adjust_con_array_type_decl

\subsection{Record type declaration}
\bpar{{\it adjust\_record\_type\_decl} preprocesses a record type declaration.
This is complicated by having to handle discriminants. If a constraint in one
of the component declarations depends on a discriminant, we bypass the normal
preprocessing for the subtype indication for that component and represent the
ranges and type marks it contains as a $Comp\_Decl$.
To do this we begin with three schemas that determine whether a variable
declaration does depend on one of the discriminants.
}\epar

=SPCZ dependent_range
=TEX
=SPCZ dependent_constraint
=TEX
=SPCZ dependent_var_decl

\bpar*{
We now build up the function which converts a $SI\_Var\_Decl$ into a $Comp\_Decl$.
}\epar*
=TEX
=SPCZ adjust_comp_sub_ind
=TEX
=SPCZ adjust_comp_constraint
=TEX
=SPCZ adjust_comp_decl
=TEX

=SPCZ adjust_record_type_decl
\subsection{Subtype declaration}
\bpar{{\it adjust\_subtype\_decl} preprocesses a subtype declaration.}\epar


=SPCZ adjust_subtype_decl

\subsection{Non-variable basic declarations }


\bpar{The non-variable basic declarations are translated by {\it adjust\_basic\_decl}}\epar

=SPCZ adjust_basic_decl

\subsection{Variable declaration }

\bpar{The current variable declaration is held in global variable {\tt\itshape SI\_VAR\_DECL}.
The results of preprocessing  are an optional auxiliary declaration to be  recorded in environments
and the value of the global variable {\tt\itshape VAR\_DECL} which takes on the preprocessed form of the variable declaration.

The free type {\tt\itshape OPT\_INIT} is the type of an optional initialising expression in 
a variable declaration.}\epar

=SPCZ OPT_INIT

\bpar{Abstract syntax. A variable declaration in the literate script  is specified by an instance of the
following schema.}\epar

=SPCZ SI_VAR_DECL

\bpar{A variable declaration after preprocessing is specified by an instance of the 
following schema, which gives one of the global variables used by the SID
functions in volume 3. The variable
holds a {\it set} of declarations to cater for the case when more than one identifier is introduced.
The variable declaration may include an initial value; if there is an initial value, it applies to
all the variables in the declaration.
}\epar

=SPCZ VAR_DECL

\bpar{
A variable declaration is treated in two cases, which are used in the SID function
{\tt\itshape adjust\_var\_decl}.
When a variable declaration does not have an implied subtype declaration the preprocessing
is just a translation of corresponding constructs.}\epar

=SPCZ adjust_var_decl_no_subtype

\bpar{When there is an implied subtype all the declared variables must have the same one 
so there is just one basic declaration to process.}\epar


=SPCZ adjust_var_decl_subtype
\bpar{{\em adjust\_var\_decl} combines the two cases:}\epar

=SPCZ adjust_var_decl 


\nocite{DRA/CIS/CSE3/SWI/WP/7/2}		% was {example}
\nocite{Sennett92a}			% was {notation}
\nocite{DRA/CIS/CSE3/SWI/1}		% was {aux}
\nocite{Foster68}				% was {sid}
\nocite{DRA/CIS(SE2)/PROJ/SWI/TR/1/1.0}	% was {user}
\nocite{zstan26}				% was {zstandard}

\bibliographystyle{fmu}
\bibliography{daz,fmu}


\begin{tabular}{ll}
\multicolumn{2}{l}{The Draft Z Standard \cite{zstan26} is available via the Internet from:}\\
			&	{\tt http://www-users.cs.york.ac.uk/~ian/zstan/}\\
\hbox to 2.5cm{\hfill or\hfill}	&	{\tt ftp://ftp.cs.york.ac.uk/hise\_reports/cadiz/ZSTAN/}
\end{tabular}

\startpost

\small
\twocolumn[\section*{Index of identifiers}]
\printindex

\onecolumn

\thispagestyle{dera}

\end{document}
=WARNING_EDIT_WITH_CARE spc503.src
