%  dtd502.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Compliance Notation Lexis and Abstract Syntax}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD502}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan&WIN01}
\TPPabstract{
This document contains the detailed design for the lexis and abstract syntax for Compliance Notation}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion~\FormatDate{$Date$%
}) ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the abstract syntax for CN.

\subsection{Introduction}

\subsubsection{Purpose and Background}


\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{LEXIS}
=DOC
signature ÛCNTypesİ = sig
=DESCRIBE
This is the signature for the structure containing the types required for Compliance Notation.
=ENDDOC

=DOC
datatype ÛCN_LEX_CLASSİ
			=	ÛAbstractExpressionİ
			|	ÛAbsİ
			|	ÛAmpersandİ
			|	ÛAndİ
			|	ÛArrayİ
			|	ÛAtİ
			|	ÛBarİ
			|	ÛBBodyİ
			|	ÛBecomesİ
			|	ÛBeginİ
			|	ÛCaseİ
			|	ÛCharacterLiteralİ
			|	ÛColonİ
			|	ÛCommaİ
			|	ÛCompLabelİ
			|	ÛConstantİ
			|	ÛConİ
			|	ÛCrdİ
			|	ÛDecLabelİ
			|	ÛDeltaİ
			|	ÛDigitsİ
			|	ÛDivİ
			|	ÛDotDotİ
			|	ÛDotİ
			|	ÛElseİ
			|	ÛElsIfİ
			|	ÛEndİ
			|	ÛEqualsİ
			|	ÛExitİ
			|	ÛFatDotİ
			|	ÛForİ
			|	ÛFunctionNameİ
			|	ÛFunctionİ
			|	ÛGoesToİ
			|	ÛGreaterEqualsİ
			|	ÛGreaterThanİ
			|	ÛIdentifierİ
			|	ÛIfİ
			|	ÛInİ
			|	ÛIsİ
			|	ÛKSlotİ
			|	ÛLessEqualsİ
			|	ÛLessGreatİ
			|	ÛLessThanİ
			|	ÛLimitedİ
			|	ÛLoopİ
			|	ÛMinusİ
			|	ÛModİ
			|	ÛNaİ
			|	ÛNotEqualsİ
			|	ÛNotİ
			|	ÛNullİ
			|	ÛNumericLiteralİ
			|	ÛOfİ
			|	ÛOrdİ
			|	ÛOrİ
			|	ÛOthersİ
			|	ÛOutİ
			|	ÛPackageİ
			|	ÛPlusİ
			|	ÛPPartLabelİ
			|	ÛPrimeİ
			|	ÛPrimedIdentifierİ
			|	ÛPrivateİ
			|	ÛProcedureNameİ
			|	ÛProcedureİ
			|	ÛRecordİ
			|	ÛRefinedByİ
			|	ÛRemİ
			|	ÛRenamesİ
			|	ÛReplacedByİ
			|	ÛReturnİ
			|	ÛReverseİ
			|	ÛRRangeİ
			|	ÛSemiİ
			|	ÛSeparateİ
			|	ÛSpecLabelİ
			|	ÛStarStarİ
			|	ÛStarİ
			|	ÛStmtLabelİ
			|	ÛStringLiteralİ
			|	ÛSubTypeİ
			|	ÛThenİ
			|	ÛTillİ
			|	ÛTypeMarkİ
			|	ÛTypeİ
			|	ÛUseİ
			|	ÛVPartLabelİ
			|	ÛWhenOthersİ
			|	ÛWhenİ
			|	ÛWhileİ
			|	ÛWithİ
			|	ÛXorİ
			|	ÛEosİ
			|	ÛZİ
			|	ÛGrkDeltaİ
			|	ÛLSqBrackİ
			|	ÛRSqBrackİ
			|	ÛLBraceİ
			|	ÛRBraceİ
			|	ÛLStracheyİ
			|	ÛRStracheyİ
			|	ÛLChevronİ
			|	ÛRChevronİ;
=DESCRIBE
=ENDDOC

=DOC
datatype ÛCN_TOKENİ	=	ÛCNZİ of ZLex.Z_TOKEN list
			|	ÛCNTextİ of string
			|	ÛCNStringİ of string
			|	ÛCNKSlotİ of Lex.INPUT list
			|	ÛCNEosİ;
=DESCRIBE
=ENDDOC

=DOC
type ÛCN_LEX_ITEMİ
=DESCRIBE
=ENDDOC

\section{ABSTRACT SYNTAX}
\subsection{Basic Declarations}
\subsubsection{Identifiers}

ID is the set of Ada Identifiers.

¹Z
Ü	[ID]
°

=SML
type ÛIDİ (* = string *);
=TEX

\subsubsection{Enumerated Types}
Enum\_Type\_Def models enumerated types.

ÿEnum_Type_Defüüüüüüüüüüüü
Ü	vals : seq ID
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ÛEnum_Type_Defİ (* = {vals : ID list} *);
=TEX

\subsubsection{Type Marks}
TMARK is the set of type marks in the literate script.

¹ZAX
Ü	TMARK : ğ ID
°

=SML
type ÛTMARKİ (* = ID list *);
=TEX

\subsubsection{Array Types}
Array\_Def models array types.

ÿArray_Defüüüüüüüüüüüü
Ü	index, comp : TMARK
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ÛArray_Defİ (* = {index : TMARK, comp : TMARK} *);
=TEX

\subsubsection{Variable Declarations}
Var\_Decl is an Ada variable declaration.

ÿVar_Declüüüüüüüüüüüü
Ü	var : ID;
Ü	tmark : TMARK
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ÛVar_Declİ (* = {var : ID, tmark : TMARK} *);
=TEX

\subsubsection{Record Types}
Record\_Type\_Def models record types.

ÿÛRecord_Type_Defİüüüüüüüüüüüü
Ü	decl : seq Var_Decl
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ÛRecord_Type_Defİ (* = {decl : Var_Decl list} *);
=TEX

\subsubsection{Integer Types}

An integer type is characterised by its range.
¹Z
[EXP]
°

ÿRangeüüüüüüüüüüüü
Ü	lo, hi : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛRange'İ (* = {lo : 'EXP, hi : 'EXP} *);
=TEX

\subsubsection{Type Definitions}

TYPE\_DEF brings all the above type definitions together.

¹Z
TYPE_DEF ::= enum_type_def (Enum_Type_Def) | int_type_def (Range) |
		uncon_array_def (Array_Def) | con_array_def (Array_Def) |
		record_type_def (Record_Type_Def)
°

=SML
(* Deferred....
datatype ÛTYPE_DEFİ =
			Ûenum_type_defİ of Enum_Type_Def
		|	Ûint_type_defİ of ('EXP) Range'
		|	Ûuncon_array_defİ of Array_Def
		|	Ûcon_array_defİ of Array_Def
		|	Ûrecord_type_defİ of Record_Type_Def;
*)
=TEX
\subsubsection{Type Declarations}
Type\_Decl is a type declaration, that is a type definition together with its name.

ÿType_Declüüüüüüüüüüüü
Ü	name : ID;
Ü	type_def : TYPE_DEF
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('TYPE_DEF) ÛType_Decl'İ (* = {name : ID, type_def : 'TYPE_DEF} *);
=TEX

\subsubsection{SubTypes}
Subtype\_Decl models subtype declarations.

¹Z
CONSTRAINT ::= range_con (Range) | index_con (TMARK)
°

=SML
(* Deferred....
datatype ÛCONSTRAINTİ =
			Ûrange_conİ of ('EXP) Range'
		|	Ûindex_conİ of TMARK;
*)
=TEX

Sub\_Ind is a subtype indication.

ÿSub_Indüüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	con : CONSTRAINT
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('CONSTRAINT) ÛSub_Ind'İ (* = {tmark : TMARK, con : 'CONSTRAINT} *);
=TEX

ÿSubtype_Declüüüüüüüüüüüüüüüüü
Ü	name : ID;
Ü	Sub_Ind
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('CONSTRAINT) ÛSubtype_Decl'İ (* = {name : ID, sub_ind : ('CONSTRAINT) Sub_Ind'} *);
=TEX

\subsubsection{Constants}
Const\_Decl models constant declarations.

ÿConst_Declüüüüüüüüüüüüüüüüü
Ü	const : ID;
Ü	tm : TMARK;
Ü	expr : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛConst_Decl'İ (* = {const : ID, tm : TMARK, expr : 'EXP} *);
=TEX

\subsubsection{Type Definition for Basic Declarations}
¹Z
BASIC_DECL ::= const_decl (Const_Decl) | type_decl (Type_Decl) |
		subtype_decl (Subtype_Decl)
°

=SML
(* Deferred....
datatype ÛBASIC_DECLİ =
			Ûconst_declİ of Const_Decl
		|	Ûtype_declİ of Type_Decl
		|	Ûsubtype_declİ of Subtype_Decl;
*)
=TEX
\subsection{Expressions}
\subsubsection{Aggregates}
Agg\_Pos is a positional array or record aggregate.

ÿAgg_Posüüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	comps : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛAgg_Pos'İ (* = {tmark : TMARK, comps : 'EXP list} *);
=TEX

Agg\_Pos\_Others is a positional array with an others part.

ÿOthersüüüüüüüüüüüüüüüüü
Ü	others : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛOthers'İ (* = {others : 'EXP} *);
=TEX


ÿAgg_Pos_Othersüüüüüüüüüüüüüüüüü
Ü	Agg_Pos;
Ü	Others
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛAgg_Pos_Others'İ
		(* = {agg_pos : ('EXP) Agg_Pos', others : ('EXP) Others'} *);
=TEX

Agg\_Others is an array aggregate with just an others part.

ÿAgg_Othersüüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	Others
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛAgg_Others'İ (* = {tmark : TMARK, others : ('EXP) Others'} *);
=TEX

Agg\_Choice is an aggregate choice with terms separated by ``|''.

¹Z
Ü	AGG_CHOICE ::=
Ü		agg_choice_range (Range) | agg_choice_single (EXP)
°

=SML
(* Deferred....
datatype ÛAGG_CHOICEİ =
			Ûagg_choice_rangeİ of (EXP) Range
		|	Ûagg_choice_singleİ of EXP;
*)
=TEX


Agg\_Named models a named array aggregate.

ÿNamed_Assocüüüüüüüüüüüüüüüüü
Ü	choices : ğ AGG_CHOICE;
Ü	comp : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('AGG_CHOICE, 'EXP) ÛNamed_Assoc'İ (* = {choice : 'AGG_CHOICE list, comp : 'EXP} *);
=TEX

ÿAgg_Namedüüüüüüüüüüüüüüüüü
Ü	named_assocs : ğ Named_Assoc
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('AGG_CHOICE, 'EXP) ÛAgg_Named'İ (* = {named_assocs : ('AGG_CHOICE, 'EXP) Named_Assoc' list} *);
=TEX

Agg\_Named\_Others is a named array aggregate with an others part.

ÿAgg_Named_Othersüüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	Agg_Named;
Ü	Others
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('AGG_CHOICE, 'EXP) ÛAgg_Named_Others'İ
		(* = {tmark : TMARK, agg_named : ('AGG_CHOICE, 'EXP) Agg_Named', 
			others : ('EXP) Others'} *);
=TEX

Rec\_Agg\_Named is a named record aggregate. (Positional record aggregates are modelled by Agg\_Pos at the start of this section).

ÿRec_Agg_Namedüüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	named_assocs : ğ (ID ¸ EXP)
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛRec_Agg_Named'İ
		(* = {tmark : TMARK, named_assocs : (ID * 'EXP) list} *);
=TEX

\subsubsection{Unary Operations}

¹Z
Ü	UNARY_OP ::=
Ü	spark_unary_add | spark_unary_minus | spark_not | spark_abs
°

=SML
datatype ÛUNARY_OPİ =
			Ûspark_unary_addİ
		|	Ûspark_unary_minusİ
		|	Ûspark_notİ
		|	Ûspark_absİ;
=TEX


ÿUnary_Expüüüüüüüüüüüüüüüüü
Ü	op : UNARY_OP;
Ü	right : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛUnary_Exp'İ (* = {Op : UNARY_OP, right : 'EXP} *);
=TEX


\subsubsection{Binary Expressions}

¹Z
Ü	BIN_OP ::=
Ü	spark_and | spark_or | spark_xor | spark_eq | spark_noteq |
Ü	spark_less | spark_less_eq | spark_greater | spark_greater_eq |
Ü	spark_add | spark_minus | spark_times | spark_intdiv |
Ü	spark_mod | spark_rem | spark_expon | spark_mem | spark_notmem
°

=SML
datatype ÛBIN_OPİ =
			Ûspark_andİ
		|	Ûspark_orİ
		|	Ûspark_xorİ
		|	Ûspark_eqİ
		|	Ûspark_noteqİ
		|	Ûspark_lessİ
		|	Ûspark_less_eqİ
		|	Ûspark_greaterİ
		|	Ûspark_greater_eqİ
		|	Ûspark_addİ
		|	Ûspark_minusİ
		|	Ûspark_timesİ
		|	Ûspark_intdivİ
		|	Ûspark_modİ
		|	Ûspark_remİ
		|	Ûspark_exponİ
		|	Ûspark_memİ
		|	Ûspark_notmemİ;
=TEX

ÿBin_Expüüüüüüüüüüüüüüüüü
Ü	op : BIN_OP;
Ü	left, right : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛBin_Exp'İ (* = {Op : BIN_OP, left : 'EXP, right : 'EXP} *);
=TEX

Mem\_Range is the membership (or non-membership) of a range.

¹Z
Ü	MEM_OP ¦ {spark_mem, spark_nonmem}
°

=SML
type ÛMEM_OPİ (* = BIN_OP *);
=TEX

ÿMem_Rangeüüüüüüüüüüüüüüüüü
Ü	left : EXP;
Ü	op : MEM_OP;
Ü	Range
ˆüüüüüüüüüüüüüüüüüüüüü


=SML
type ('EXP) ÛMem_Range'İ (* = {left : 'EXP, Op : MEM_OP, range : ('EXP) Range'} *);
=TEX


\subsection{Attributes}
Attribute models Ada attributes.

ATTRIB are the attribute designators FIRST, LAST, SUCC, PRED, POS, VAL, LENGTH and RANGE.

¹ZAX
Ü	fst, lst, suc, pred, pos, val, length, range : ID
°

¹Z
Ü	ATTRIB ¦ {fst, lst, suc, pred, pos, val, length, range}
°

=SML
type ÛATTRIBİ (* = ID list *);
=TEX

ATTRIB\_DESIG models the attribute designators.

¹Z
Ü	ATTRIB_DESIG ::=
Ü		attrib (ATTRIB) | attrib_arg (ATTRIB ¸ EXP)
°

=SML
(* Deferred....
datatype ÛATTRIB_DESIGİ =
			Ûattribİ of ATTRIB
		|	Ûattrib_argİ of (ATTRIB * EXP);
*)
=TEX

ÿAttributeüüüüüüüüüüüüüüüüü
Ü	prefix : ID;
Ü	attribute_desig : ATTRIB_DESIG
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('ATTRIB_DESIG) ÛAttribute'İ
	(* = {prefix : ID, attribute_desig : 'ATTRIB_DESIG} *);
=TEX

\subsubsection{Indexed Component}
Indexed\_Comp is an array component.

ÿIndexed_Compüüüüüüüüüüüüüüüüü
Ü	prefix, index : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛIndexed_Comp'İ
	(* = {prefix : 'EXP, index : 'EXP} *);
=TEX

\subsubsection{Selected Component}
Selected\_Comp is a record component.

ÿSelected_Compüüüüüüüüüüüüüüüüü
Ü	prefix : EXP;
Ü	selector : ID
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛSelected_Comp'İ
	(* = {prefix : 'EXP, selector : ID} *);
=TEX

\subsubsection{Function Calls}
Fun\_Call is a function call.

ÿFun_Callüüüüüüüüüüüüüüüüü
Ü	fun_name : ID;
Ü	args : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛFun_Call'İ
	(* = {fun_name : ID, args : 'EXP list} *);
=TEX

\subsubsection{Integer Literals}
INT\_LIT are the integer literals.

¹Z
Ü	[INT_LIT]
°

=SML
type ÛINT_LITİ (* = string *);
=TEX

\subsubsection{Auxiliary Expressions}
In the Compliance Notation, a SPARK expression can also be a Z expression (auxiliary expression).

¹Z
Ü	[Z_EXP]
°

=SML
type Z_EXP (* = TERM *);
=TEX

\subsubsection{Type Definition for Expressions}

¹Z
Ü	EXP ::=	
Ü		Id (ID) | int (INT_LIT) | array_agg_pos (Agg_Pos) |
Ü		array_agg_pos_others (Agg_Pos_Others) |
Ü		array_agg_others (Agg_Others) |
Ü		array_agg_named (Agg_Named) |
Ü		array_agg_named_others (Agg_Named_Others) |
Ü		rec_agg_pos (Agg_Pos) | rec_agg_named (Rec_Agg_Named) |
Ü		unary_exp (Unary_Exp) | bin_exp (Bin_Exp) |
Ü		mem_range (Mem_Range) | attribute (Attribute) |
Ü		indexed_comp (Indexed_Comp) |
Ü		selected_comp (Selected_Comp) |
Ü		fun_call (Fun_Call) |
Ü		auxiliary_exp (Z_EXP)
°

=SML
datatype ÛTYPE_DEFİ =
			Ûenum_type_defİ of Enum_Type_Def
		|	Ûint_type_defİ of (EXP) Range'
		|	Ûuncon_array_defİ of Array_Def
		|	Ûcon_array_defİ of Array_Def
		|	Ûrecord_type_defİ of Record_Type_Def
=TEX
=SML
and ÛCONSTRAINTİ =
			Ûrange_conİ of (EXP) Range'
		|	Ûindex_conİ of TMARK
=TEX
=SML
and ÛBASIC_DECLİ =
			Ûconst_declİ of (EXP) Const_Decl'
		|	Ûtype_declİ of (TYPE_DEF) Type_Decl'
		|	Ûsubtype_declİ of (CONSTRAINT) Subtype_Decl'
=TEX
=SML
and ÛAGG_CHOICEİ =
			Ûagg_choice_rangeİ of (EXP) Range'
		|	Ûagg_choice_singleİ of EXP
=TEX
=SML
and ÛATTRIB_DESIGİ =
			Ûattribİ of ATTRIB
		|	Ûattrib_argİ of (ATTRIB * EXP)
=TEX
=SML
and ÛEXPİ =
		ÛIdİ of ID | Ûintİ of INT_LIT | Ûarray_agg_posİ of (EXP) Agg_Pos' |
		Ûarray_agg_pos_othersİ of (EXP) Agg_Pos_Others' |
		Ûarray_agg_othersİ of (EXP) Agg_Others' |
		Ûarray_agg_namedİ of (AGG_CHOICE, EXP) Agg_Named' |
		Ûarray_agg_named_othersİ of (AGG_CHOICE, EXP) Agg_Named_Others' |
		Ûrec_agg_posİ of (EXP) Agg_Pos' | Ûrec_agg_namedİ of (EXP) Rec_Agg_Named' |
		Ûunary_expİ of (EXP) Unary_Exp' | Ûbin_expİ of (EXP) Bin_Exp' |
		Ûmem_rangeİ of (EXP) Mem_Range' | Ûattributeİ of (ATTRIB_DESIG) Attribute' |
		Ûindexed_compİ of (EXP) Indexed_Comp' |
		Ûselected_compİ of (EXP) Selected_Comp' |
		Ûfun_callİ of (EXP) Fun_Call' |
		Ûauxiliary_expİ of Z_EXP;
=TEX


\subsection{Statements}

The Z specification of the abstract syntax uses a given set declaration to act as a forward declaration of the free type $Stmt$, permitting the free type to involve recursion through schema constructions.
Unfortunately, this style is not considered to be type correct in \ProductZ; this is readily circumvented by making the schema constructions generic where necessary.
For example, see section \ref{if-then-else} below.

Following this convention we may now work through the abstract syntax for SPARK statements following \cite{DRA/CIS/CSE3/SWI/WP/1}.

\subsubsection{Assignment}\label{assignment}

ÿÛAssignİüüüüüüüüüüüüüüüüü
Ü	name, E : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
SML
	type ÛAssignİ (* = {name : EXP, E : EXP}; *)
=TEX

ÿÛSpecİüüüüüüüüüüüüüüüüü
Ü	w, w‰0 : ğ Z_ID;
Ü	Pre, post : Z_PRED
÷üüüüüüüüüüüüüüü
Ü	Pre  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü

ÿÛSpec_No_Ivarsİüüüüüüüüüüüü
Ü	Spec
÷üüüüüüüüüüüüüüü
Ü	post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü
=TEX
In the translation into Standard ML of a schema which includes another,
we have various choices.
In this simple case where the new schema has the same signature as the included one, we just say that the new type is an abbreviation for the old one.
SML
	type ÛZ_PRED0İ (* = Z_PRED; *)
	type ÛSpecİ (* = {w : ID list, w0 : ID list, pre : Z_PRED, post : Z_PRED};*)
	type ÛSpec_No_Ivarsİ (* = Spec; *)
=TEX
\subsubsection{If-then-else}\label{if-then-else}

¹ZAX
Ü	ÛCONDİ : ğ EXP
°

ÿÛIf_Then_Elseİ[STMT]üüüüüüüüüüüüüüüüü
Ü	G : COND;
Ü	P, Q : STMT
ˆüüüüüüüüüüüüüüüüüüüüü
SML
	type ÛCONDİ (* = EXP; *)
	type ('STMT) ÛIf_Then_Elseİ (* = {G : COND, P : 'STMT, Q : 'STMT}; *)
=TEX
\subsubsection{Case}\label{case}

¹Z
Ü	CASE_CHOICE ::= case_exp EXP | case_range Range
°

ÿÛCase_Alternativeİ[STMT]üüüüüüüüüüüüüüüüü
Ü	choices : ğ CASE_CHOICE;
Ü	P : STMT
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
ÿÛCaseİüüüüüüüüüüüüüüüüü
Ü	E : EXP;
Ü	s : seq‰1 Case_Alternative
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
SML
	type ('STMT) ÛCase_Alternativeİ (* = {choices : CASE_CHOICE list, P : 'STMT}; *)
	type ('STMT) ÛCaseİ (* = {E : EXP, s : ('STMT) Case_Alternative list}; *)
=TEX
The fact that the list of arms may not be empty is not captured by the above.
The following exception is available for later code to raise if this constraint is violated.
SML
exception Empty_Case_Statement of string;
=TEX
\subsubsection{Loop}\label{loop}

ÿÛLoopİüüüüüüüüüüüüüüüüü
Ü	T : Z_PRED;
Ü	Spec_No_Ivars
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
As with the translation of $Spec\_No\_Ivars$, we have a choice of how to translate the schema inclusion.
This case is a little more complicated, however, but as there is no overlap between the signature of the included schema and other signature variables, we can adopt the following simple translation.
SML
	type ÛLoopİ (* = {T : Z_PRED, spec : Spec_No_Ivars}; *)
=TEX
\subsubsection{While Loop}\label{while-loop}
ÿÛWhileİüüüüüüüüüüüüüüüüü
Ü	G : COND;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
SML
	type ÛWhileİ (* = {G : COND, loop : Loop}; *)
=TEX
\subsubsection{For Loop (Values as Bounds)}\label{for-static}

¹ZAX
Ü	ÛSTATIC_EXPİ : ğ EXP
°
¹Z
Ü	rel	_ less_eq _
°
¹ZAX
Ü	_ less_eq _ : VALUE ª VALUE
°

ÿÛFor_Staticİüüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	lo, hi : STATIC_EXP;
Ü	Loop
÷üüüüüüüüüüüüüüüü
Ü	lo less_eq hi
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
SML
	type ÛSTATIC_EXPİ (* = EXP; *)
	type ÛFor_Staticİ (* = {i : ID, lo : STATIC_EXP, hi : STATIC_EXP, loop : Loop}; *)
=TEX
\subsubsection{For Loop (Type Mark as Range)}\label{for-typemark}

ÿÛFor_Tmarkİüüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	tmark : TMARK;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
SML
	type ÛFor_Tmarkİ (* = {i : ID, tmark : TMARK, loop : Loop}; *)
=TEX
\subsubsection{Exit}\label{exit}

ÿÛExitWhenİüüüüüüüüüüüüüüüüü
Ü	G : COND
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
SML
	type ÛExit_Whenİ (* = {G : COND};*)
=TEX
\subsubsection{Return}\label{return}

ÿÛReturnİüüüüüüüüüüüüüüüüü
Ü	E : EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
SML
	type ÛReturnİ (* = {E : EXP}; *)
=TEX
\subsubsection{Procedure Call}\label{procedure-call}

ÿÛProc_Callİüüüüüüüüüüüüüüüüü
Ü	name : ID;
Ü	actuals : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
SML
	type ÛProc_Callİ (* = {name : ID, actuals : EXP list}; *)
=TEX
ÿÛProc_Call_No_Ivarsİüüüüüüüüüüüüüüüüü
Ü	Proc_Call
÷üüüüüüüüüüüüüüüü
Ü	(retrieve_spec_stmt name).post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
SML
	type ÛProc_Call_No_Ivarsİ (* = Proc_Call; *)
=TEX
\subsubsection{$Stmt$}\label{stmt}
\ProductZ\ is currently non-standard in that it neither requires nor
allows the chevrons around the operands in a free type definition.
This mismatch with the Z standard is planned to be remedied in a future release of the system.
¹Z
	ÛStmtİ	::= 	Ûnullİ
		|	Ûassignİ (Assign)
		|	Ûspec_no_ivarsİ (Spec_No_Ivars)
		|	Ûsemicolonİ (Stmt ¸ Stmt)
		|	Ûif_then_elseİ (If_Then_Else)
		|	Ûcaseİ (Case[Stmt])
		|	Ûloopİ (Loop)
		|	Ûwhileİ (While)
		|	Ûfor_staticİ (For_Static)
		|	Ûfor_tmarkİ (For_Tmark)
		|	Ûexit_whenİ (Exit_When)
		|	Ûexitİ
		|	Ûretİ (Return)
		|	Ûproc_no_ivarsİ (Proc_Call_No_Ivars)
°
=TEX
The constructors $case$ and $while$ must be misspelt in the Standard ML datatype twhich implements the above because they are reserved identifiers.
SML
datatype 
	ÛStmtİ	= 	Ûnullİ
		|	Ûassignİ of (Assign)
		|	Ûspec_no_ivarsİ of (Spec_No_Ivars)
		|	Ûsemicolonİ of (Stmt * Stmt)
		|	Ûif_then_elseİ of ((Stmt)If_Then_Else)
		|	Ûkaseİ of ((Stmt)Case)
		|	Ûloopİ of (Loop)
		|	Ûwhyleİ of (While)
		|	Ûfor_staticİ of (For_Static)
		|	Ûfor_tmarkİ of (For_Tmark)
		|	Ûexit_whenİ of (Exit_When)
		|	Ûexitİ
		|	Ûretİ of (Return)
		|	Ûproc_no_ivarsİ of (Proc_Call_No_Ivars);
=TEX
\pagebreak
\subsubsection{Specification (with initial variables)}\label{specification-ivars}

ÿÛSpec_Ivarsİüüüüüüüüüüüü
Ü	Spec
÷üüüüüüüüüüüüüüü
Ü	post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü
=TEX
SML
	type ÛSpec_Ivarsİ (* = Spec; *)
=TEX
\subsubsection{For Loop (Non-Static Bounds)}\label{for-non-static-bounds}

ÿÛFor_Non_Staticİüüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	lo, hi : EXP;
Ü	Loop
÷üüüüüüüüüüüüüüüü
Ü		lo  STATIC_EXP
Ü	²
Ü		hi  STATIC_EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
SML
	type ÛFor_Non_Staticİ (* = {i : ID, lo : STATIC_EXP, hi : STATIC_EXP, loop : Loop}; *)
=TEX
\subsubsection{Logical Constants}\label{logical-constants}
¹ZAX
Ü	free_ids : Z_EXP ­ ğ Z_ID
°

ÿÛLog_Conİüüüüüüüüüüüü
Ü	X : Z_ID;
Ü	E : Z_EXP;
Ü	Spec;
Ü	pre‰1 : Z_PRED
÷üüüüüüüüüüüüüüü
Ü	Pre = z_and(z_eq(zid X, E), pre‰1);
Ü	X  free_ids E
ˆüüüüüüüüüüüüüüüüüüüüü
=TEX
The functions $free\_id$ may readily and reallistically be implemented using existing \Product\
syntax functions.
SML
	val Ûfree_idsİ : Z_EXP -> ID list
	type ÛLog_Conİ (* = {X : Z_ID, E : Z_EXP, spec : Spec, pre1 : Z_PRED}; *)
=TEX
\subsubsection{Procedure Calls}\label{procedure-calls}
ÿÛProc_Call_Ivarsİüüüüüüüüüüüü
Ü	Proc_Call
÷üüüüüüüüüüüüüüü
Ü	(retrieve_spec_stmt name).post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü

SML
	type ÛProc_Call_Ivarsİ (* = Proc_Call; *)
=TEX

\subsubsection{Statement}\label{statement}
¹Z
	ÛStatementİ
		::= 	Ûstmtİ (Stmt)
		|	Ûspec_ivarsİ (Spec_Ivars ¸ Stmt)
		|	Ûfor_non_staticİ (For_Non_Static ¸ Stmt)
		|	Ûlog_conİ (Log_Con ¸ Stmt)
		|	Ûproc_ivarsİ (Proc_Call_Ivars ¸ Stmt)
°
=TEX
SML
datatype 
	ÛStatementİ
		= 	Ûstmtİ of (Stmt)
		|	Ûspec_ivarsİ of (Spec_Ivars * Stmt)
		|	Ûfor_non_staticİ of (For_Non_Static * Stmt)
		|	Ûlog_conİ of (Log_Con * Stmt)
		|	Ûproc_ivarsİ of (Proc_Call_Ivars * Stmt);
=TEX


\section{EPILOGUE}

=SML
end; (* of signature CNTypes *)
=TEX

=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



