%  dtd502.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\def\TPPheadtitle{Compliance Notation Lexis and Abstract Syntax}  %% Mandatory field
\TPPtitle{Compliance Notation Lexis and Abstract Syntax}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD502}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{HOL}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan&HAT Team}
\TPPabstract{
This document contains the detailed design for the lexis and abstract syntax for Compliance Notation}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	C.~O'Halloran, DRA \\
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.37] Initial Drafts.

\item[Issue 1.38 (22nd Sept 1994)] Reworked according to desk check report 006.

\item[Issue 1.39 (7th Oct 1994)] Added lexical tokens for auxiliary expressions.
\item[Issue 1.40 (7th Oct 1994)] Corrected abstract syntax for specification statements w.r.t. labels.
\item[Issue 1.44 (13th Oct 1994)] Re-organised material and applied DRA's suggested corrections documented in \cite{ISS/HAT/DAZ/MIN004}.
\item[Issue 1.45 (13th Oct 1994)] Few minor changes in checking the rework.
\item[Issue 1.46-1.51] Bug fixes.
\item[Issue 1.52] Updated document references.
\item[Issue 1.53] Changed the text in the Test Policy section. Fixed a Z problem in the definition of Z\_PRED.
\item[Issue 1.54] Reworded the test policy section.
\item[Issue 1.55] Added pragmas, annotations and arbitrary replacements.
\item[Issue 1.60] Added Z Bindings and updated free type def. of Z\_EXP.
\item[Issue 1.61] Added qualified expressions and type conversions to the Z.
\end{description}

\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the lexis and abstract syntax for the Compliance Notation.

The lexis corresponds to that specified in \cite{pvl90}. The abstract syntax is based on the abstract syntax for basic declarations and expressions in \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/1.2} and the abstract syntax for SPARK statements in \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/1.2}. The abstract syntax for SPARK subprograms and packages has been derived from the concrete syntax for compliance notation in \cite[volume 1]{DRA/CIS/CSE3/TR/94/27/1.2}.

\subsection{Introduction}
\subsubsection{Purpose and Background}

The lexis is required to carry the lexical information of the input which has been computed by the lexical analyser. The grammar in \cite{ISS/HAT/DAZ/DTD503} is closely related to this lexis since the terminals in the grammar correspond to the lexemes in the datatype $CN\_LEX\_CLASS$. The lexical classes are themselves derived from the list of terminal symbols in \cite[volume 1, appendix A]{DRA/CIS/CSE3/TR/94/27/1.2}.

The abstract syntax for compliance notation constitutes the internal representation for web clauses. All web clauses and fragments of SPARK programs are represented using the abstract syntax type $WEB\_CLAUSE$. The representation is used by the basic declaration and expression generator \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/1.2}, the verification condition generator \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/1.2} and the SPARK output function which creates a human-readable form of the abstract representation corresponding to the input.

Web clauses of type $WEB\_CLAUSE$ are generated by the compliance notation parser \cite{ISS/HAT/DAZ/DTD503} from the literate script being processed.


\subsection{Compliance}

This document contains the signature for compliance notation lexis and compliance notation abstract syntax.

The correspondance between the lexis that that in \cite[volume 1, appendix A]{DRA/CIS/CSE3/TR/94/27/1.2} can be seen by simply comparing the list of type constructors of $CN\_LEX\_CLASS$ with the terminal symbols in \cite[volume 1, appendix A]{DRA/CIS/CSE3/TR/94/27/1.2}.


The correspondence between the Z specification of the abstract syntax in DRA's specification and the implementation is aided by the reproduction of the relevant Z of \cite{DRA/CIS/CSE3/TR/94/27/1.2} in this document. The implementation of each of the schemas is done using a Standard ML type. The details of this type do not appear in the Standard ML signature; the ML syntax does not allow it; but only in the structure. In order to maintain traceability, the information which appears in the structure is contained in this document. During the building of the tool, the {\Product} document processing facility $sieve$ filters out the implementation details into a separate file. The signature can then be processed, and the corresponding structure can be automatically generated from the filtered implementation details. The machinery to do this is very small and can be found in the companion implementation document to this \cite{ISS/HAT/DAZ/IMP503}.

It is intended that the compliance of the Z to the implementation can be done with a visual check in this document.

There are various points in the abstract syntax where the data types are ``wider'' than the corresponding Z. This is generally because it is necessary to carry some syntactic information which would otherwise be lost, in order to reproduce the SPARK program when all the web clauses have been entered. These points are identified by descriptive text later in this document.

Note also that Z expressions are stored as HOL terms in {\ProductZ}. The HOL terms which represent Z expressions are a subset of all HOL terms. This constitutes a ``widening''. This does not introduce any problem for the Compliance Tool.


\section{PREAMBLE}
\subsection{For Z Type-Checking}
The following initialises the theory database when performing a syntax and type check on the Z paragraphs in this document. (This preamble is not processed when building the compliance tool.)

=SMLZ
open_theory"z_library";
push_pc "z_library";
force_delete_theory"dtd502" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", false);
new_theory"dtd502";
=TEX

\subsection{The Signature}
=DOC
signature ÛCNTypesİ = sig
local
	open ZUserInterfaceSupport;
in
=DESCRIBE
This is the signature for the structure containing the types required for Compliance Notation.
=ENDDOC
\section{LEXIS}
=DOC
datatype ÛCN_LEX_CLASSİ
			= ÛLCAbsİ | ÛLCAmpersandİ | ÛLCAndİ
			| ÛLCAnnotationİ
			| ÛLCArbitraryAdaİ
			| ÛLCArrayİ |ÛLCAtİ
			| ÛLCBarİ |ÛLCBBodyİ | ÛLCBecomesİ | ÛLCBeginİ
			| ÛLCCaseİ| ÛLCCharacterLiteralİ
			| ÛLCColonİ | ÛLCCommaİ | ÛLCCommentİ
			| ÛLCCompLabelİ | ÛLCConstantİ
			| ÛLCConİ | ÛLCCrdİ | ÛLCDecLabelİ | ÛLCDeltaİ
			| ÛLCDigitsİ | ÛLCDivİ| ÛLCDotDotİ | ÛLCDotİ | ÛLCElseİ
			| ÛLCElsIfİ | ÛLCEndİ | ÛLCEqualsİ | ÛLCExitİ
			| ÛLCFatDotİ | ÛLCForİ | ÛLCFunctionİ
			| ÛLCGoesToİ | ÛLCGreaterEqualsİ
			| ÛLCGreaterThanİ
			| ÛLCIdentifierİ | ÛLCIfİ
			| ÛLCInİ | ÛLCIsİ
			| ÛLCKSlotİ | ÛLCLessEqualsİ | ÛLCLessGreatİ | ÛLCLessThanİ
			| ÛLCLimitedİ | ÛLCLoopİ | ÛLCMinusİ
			| ÛLCModİ | ÛLCNotEqualsİ | ÛLCNotİ | ÛLCNullİ
			| ÛLCNumericLiteralİ | ÛLCOfİ
			| ÛLCOrdİ | ÛLCOrİ | ÛLCOthersİ | ÛLCOutİ
			| ÛLCPackageİ | ÛLCPlusİ
			| ÛLCPPartLabelİ | ÛLCPrimeİ | ÛLCPrimedIdentifierİ
			| ÛLCPragmaİ
			| ÛLCPrivateİ | ÛLCProcedureİ
			| ÛLCRecordİ | ÛLCRefinedByİ | ÛLCRemİ
			| ÛLCRenamesİ | ÛLCReplacedByİ | ÛLCReturnİ
			| ÛLCReverseİ | ÛLCRRangeİ | ÛLCSemiİ
			| ÛLCSeparateİ | ÛLCSpecLabelİ | ÛLCStarStarİ
			| ÛLCStarİ | ÛLCStmtLabelİ
			| ÛLCStringLiteralİ | ÛLCSubTypeİ | ÛLCThenİ
			| ÛLCTillİ
			| ÛLCTypeİ | ÛLCUseİ | ÛLCVPartLabelİ
			| ÛLCWhenİ | ÛLCWhileİ | ÛLCWithİ | ÛLCXorİ | ÛLCEosİ
			| ÛLCZİ
			| ÛLCAuxiliaryİ | ÛLCUsingİ | ÛLCImplementİ | ÛLCByİ
			| ÛLCGrkDeltaİ | ÛLCLSqBrackİ | ÛLCRSqBrackİ
			| ÛLCLBraceİ | ÛLCRBraceİ | ÛLCLStracheyİ
			| ÛLCRStracheyİ | ÛLCLChevronİ | ÛLCRChevronİ;
=DESCRIBE
CN\_LEX\_CLASS is the datatype used to represent the lexical classes of tokens in compliance notation. 
=DESCRIBE
=ENDDOC

=DOC
datatype ÛCN_TOKENİ	=	ÛCNZİ of ZLex.Z_TOKEN list
			|	ÛCNTextİ of string
			|	ÛCNStringİ of string
			|	ÛCNKSlotİ of Lex.INPUT list
			|	ÛCNEosİ;

type ÛCN_LEX_ITEMİ
=TYPESTRUCT
	= CN_LEX_CLASS * CN_TOKEN;
=DESCRIBE
CN\_TOKEN is the datatype used to represent the lexical tokens required in compliance notation. CN\_LEX\_ITEM is a type used by the lexical analyser for communicating to the parser the lexical information. The class (the first of the pair) is the classification of the token (the second of the pair).
=ENDDOC

\subsection{Notes on Compliance}

The specification of the concrete syntax in \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/1.2} does not spell out the syntax for specification statements. Hence the terminal $specification statement$ is not represented in the list of lexical classes, but the syntactic components are instead provided, viz: $LCGrkDelta$, $LCLSqBrack$, $LCRSqBrack$, $LCLBrace$, $LCRBrace$.

Similarly for k-slots, $LCLChevron$ and $LCRChevron$; and auxiliary expressions, $LCLStrachey$ and $LCRStrachey$.

There is no need for an lexical class for a type mark as it is lexically equivalent to an identifier. 

A consequence of an ambiguity in handling primes, documented in \cite{ISS/HAT/DAZ/DTD503}, is the necessity of a lexical class to represent an identifier immediately followed by a prime; hence $LCPrimedIdentifier$. An end-of-input has also been added, $LCEos$.

Other consequences of changes to the grammar (also documented in \cite{ISS/HAT/DAZ/DTD503}) result in no requirement for lexical classes corresponding to $commagoesto$, $commaothers$, $whenothers$, $functionname$, $procedurename$, $z\_decl$, $z\_pred$ and $na$ of \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/1.2}.
\newpage

\section{Z ABSTRACT SYNTAX}

Since Z abstract syntax is already supported in {\ProductZ}, there is no requirement to provide specific implementations of most of the Z in this section. It is provided here mainly for the purpose of allowing the Z in this and other detailed design documents to type-check correctly.

\subsection{Z Declarations}

=DOC
type ÛZ_IDİ
=TYPESTRUCT
	= string;
=DESCRIBE
¹Z
Ü	[Z_ID]
°
=ENDDOC

=DOC
type ÛZ_DECLİ
=TYPESTRUCT
      = TERM;
=DESCRIBE
A Z declaration is represented as a HOL term using the primitive Z abstract machine constructor $mk\_z\_dec$. e.g. the Z declaration $x : ú$ is represented in {\Product} as the HOL term $ñ‘mk\_z\_dec([ñx®], ñú®)®®$ : TERM   

ÿZ_Decl[Z_EXP]üüüüüüüü
Ü	zvar : Z_ID;
Ü	zexp : Z_EXP
ˆüüüüüüüüüüüü
=ENDDOC

\subsection{Z Unary Expressions}

¹Z
Ü	Z_UNARY_OP ::= z_unary_minus | z_bool_not | z_abs
°


ÿZ_Unary_Exp[Z_EXP]üüüüüüüü
Ü	zop : Z_UNARY_OP;
Ü	zright : Z_EXP
ˆüüüüüüüüüüü

\subsection{Z Binary Expressions}

¹Z
Ü	Z_BIN_OP ::= z_bool_and | z_bool_or | z_bool_xor | z_bool_eq | z_bool_noteq |
Ü	z_bool_less | z_bool_less_eq | z_bool_greater | z_bool_greater_eq | z_add |
Ü	z_minus | z_times | z_intdiv | z_mod | z_rem | z_expon | z_bool_mem |
Ü	z_bool_notmem
°

ÿZ_Bin_Exp[Z_EXP]üüüüü
Ü	zop : Z_BIN_OP;
Ü	zleft, zright : Z_EXP
ˆüüüüüüüüüüü


\subsection{Z Function Calls}

ÿZ_Fun_Call[Z_EXP]üüüüü
Ü	zfun : Z_EXP;
Ü	zargs : seq Z_EXP
ˆüüüüüüüüüüü

\subsection{Z Binding Selections}

ÿZ_Selection[Z_EXP]üüüü
Ü	zbinding : Z_EXP;
Ü	zselector : Z_ID
ˆüüüüüüüüüüü

\subsection{Z Binding Selections}

ÿZ_Binding[Z_EXP]üüüü
Ü	zbinds : ğ (Z_Decl[Z_EXP])
ˆüüüüüüüüüüü

\subsection{Z Expressions and Predicates}

¹Z
Ü	[OTHER_Z_EXP]
°

¹Z
Ü	[OTHER_Z_PRED]
°
=DOC
type ÛZ_EXPİ
=TYPESTRUCT
	= TERM;
=ENDDOC

=DOC
type ÛZ_PREDİ
=TYPESTRUCT
	= TERM;
=ENDDOC

¹Z
Ü	Z_EXP ::=
Ü	zsucc | zid Z_ID | z_num ú | z_tfun (Z_EXP ¸ Z_EXP) |
Ü	z_pfun (Z_EXP ¸ Z_EXP) | z_rng (Z_EXP ¸ Z_EXP) |
Ü	z_dom Z_EXP | z_dom_res (Z_EXP ¸ Z_EXP) | z_inv Z_EXP |
Ü	z_id_rel Z_EXP | z_size Z_EXP | z_set (ğ Z_EXP) |
Ü	z_set_minus (Z_EXP ¸ Z_EXP) |
Ü	z_set_comp (Z_Decl[Z_EXP] ¸ Z_PRED) | z_power (Z_EXP ¸ Z_EXP) |
Ü	z_rel_comp (Z_EXP ¸ Z_EXP) |  z_seq (seq Z_EXP) |
Ü	z_cross (Z_EXP ¸ Z_EXP) | z_many_cross (seq Z_EXP) |
Ü	z_override (Z_EXP ¸ Z_EXP) | z_many_union (ğ Z_EXP)
Ü	z_unary_exp (Z_Unary_Exp[Z_EXP]) | z_bin_exp (Z_Bin_Exp[Z_EXP]) |
Ü	z_fun_call (Z_Fun_Call[Z_EXP]) | z_selection (Z_Selection[Z_EXP]) |
Ü	z_maplet (Z_EXP ¸ Z_EXP) | z_powerset Z_EXP |
Ü	z_binding (Z_Binding[Z_EXP]) | other_z_exp OTHER_Z_EXP
Ü &	
Ü	Z_PRED ::=
Ü	z_true | z_eq (Z_EXP ¸ Z_EXP) | z_and (Z_PRED ¸ Z_PRED) |
Ü	z_many_and (ğ Z_PRED) | z_elem (Z_EXP ¸ Z_EXP) |
Ü	z_noteq (Z_EXP ¸ Z_EXP) | z_less_eq (Z_EXP ¸ Z_EXP) |
Ü	z_greater (Z_EXP ¸ Z_EXP) | z_forall ((seq Z_Decl[Z_EXP]) ¸ Z_PRED) |
Ü	z_exists (ğ Z_Decl[Z_EXP] ¸ Z_PRED) | z_imp (Z_PRED ¸ Z_PRED) |
Ü	other_z_pred OTHER_Z_PRED
Ü
°


\subsection{Z Modules}

¹Z
Ü	[Z_MODULE]
°

\subsection{Z Schemas}

ÿZ_Schemaüüüüü
Ü	z_sname : Z_ID;
Ü	z_decls : ğ Z_Decl[Z_EXP]
ˆüüüüüüüüüüüüü

\subsection{Z Axiomatic Descriptions}

ÿZ_Axüüüüüüüü
Ü	decls : ğ Z_Decl[Z_EXP];
Ü	preds : ğ Z_PRED
ˆüüüüüüüüüüüüü

\subsection{Verification Conditions}

ÿSequentüüüüüüüü
Ü	H : ğ Z_PRED;
Ü	c : Z_PRED
ˆüüüüüüüüüüüüü

¹Z
Ü	VC ¦ (ğ Z_Decl[Z_EXP] ¸ Sequent)
°

\subsection{Z Paragraphs}

¹Z
Ü	[OTHER_Z]
°
¹Z
Ü	Z_PARA ::=
Ü	z_module (Z_MODULE) | z_eq_eq (Z_ID ¸ Z_EXP) |
Ü	z_schema (Z_Schema) | z_ax (Z_Ax) | z_vcs (ğ VC) |
Ü	other_z (OTHER_Z)
Ü
°

\newpage
\section{SPARK ABSTRACT SYNTAX}

\subsection{Expressions}

\subsubsection{Identifiers}

ID is the set of Ada Identifiers.

=DOC
type ÛIDİ
=TYPESTRUCT
	= string;
=DESCRIBE
¹Z
Ü	[ID]
°
=ENDDOC

\subsubsection{Aggregates (positional array)}

TMARK is the set of type marks in the literate script.

=DOC
type ÛTMARKİ
=TYPESTRUCT
	= ID;
=DESCRIBE
¹ZAX
Ü	TMARK : ğ ID
°
=ENDDOC

Agg\_Pos is a positional array or record aggregate.

=DOC
type ('EXP) ÛAGG_POSİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	comps : 'EXP list
	};
=DESCRIBE
ÿAgg_Pos[EXP]üüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	comps : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Aggregates (positional array with others)}
Agg\_Pos\_Others is a positional array with an others part.


=DOC
type ('EXP) ÛOTHERSİ
=TYPESTRUCT
      = {
	others : 'EXP
	};
=DESCRIBE
ÿOthers[EXP]üüüüüüüüüüüüüüüüü
Ü	others : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


=DOC
type 'EXP ÛAGG_POS_OTHERSİ
=TYPESTRUCT
      = {
	agg_pos : 'EXP AGG_POS,
	others : 'EXP OTHERS
	};
=DESCRIBE
ÿAgg_Pos_Others[EXP]üüüüüüüüüüüüü
Ü	Agg_Pos[EXP];
Ü	Others[EXP]
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Aggregates (positional array with just others)}
Agg\_Others is an array aggregate with just an others part.


=DOC
type 'EXP ÛAGG_OTHERSİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	others : 'EXP OTHERS
	};
=DESCRIBE
ÿAgg_Others[EXP]üüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	Others[EXP]
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Aggregates (named array)}

A range can be just a range attribute which can be represented by one expression. To support this, we introduce a type constructor for a range attribute. 

=DOC
type 'EXP ÛRANGELOHIİ
=TYPESTRUCT
      = {
	lo : 'EXP,
	hi : 'EXP
	};
=DESCRIBE
ÿRange[EXP]üüüüüüüüüüüü
Ü	lo, hi : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
=SML
datatype 'EXP ÛRANGEİ =
			ÛRRangeİ of 'EXP RANGELOHI
		|	ÛRRangeAttrİ of 'EXP
=TEX

Agg\_Choice is an aggregate choice with terms separated by vertical bars.

The datatype for AGG\_CHOICE is introduced in section \ref{datatypedefs}.

¹Z
Ü	[AGG_CHOICE]
°

Generic free type definitions are not permitted in Z, so for AGG\_CHOICE we write the following (as per \cite{Spivey92}).

[EXP]œœœœœœœœœœœœœœœœœœœœœœœœœœœœ
Ü	agg_choice_range : Range[EXP] à AGG_CHOICE;
Ü	agg_choice_single : EXP à AGG_CHOICE
÷üüüüüüüüüüüüüüüüüüüüü
Ü	disjoint §ran agg_choice_range, ran agg_choice_single¢ ±
Ü
Ü	(µ W : ğ AGG_CHOICE ·
Ü	agg_choice_range ¨Range[EXP]© À agg_choice_single ¨EXP© € W
Ü	´ AGG_CHOICE € W)
ˆüüüüüüüüüüüüüüüüüüüüüü

A discrete range can be a type mark with an optional range constraint. The abstract syntax is modified to cover this.
=DOC
type 'EXP ÛDISCRETE_RANGE_CONSTRAINEDİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	range : 'EXP RANGE
	};
=DESCRIBE
=ENDDOC

=DOC
type ('AGG_CHOICE, 'EXP) ÛNAMED_ASSOCİ
=TYPESTRUCT
      = {
	choice : 'AGG_CHOICE list,
	comp : 'EXP
	};
=DESCRIBE
ÿNamed_Assoc[EXP]üüüüüüüüüüüüüüüüü
Ü	choices : ğ AGG_CHOICE;
Ü	comp : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

Agg\_Named models a named array aggregate.


=DOC
type ('AGG_CHOICE, 'EXP) ÛAGG_NAMEDİ
=TYPESTRUCT
      = {
	named_assocs : ('AGG_CHOICE, 'EXP) NAMED_ASSOC list
	};
=DESCRIBE
ÿAgg_Named[EXP]üüüüüüüüüüüüü
Ü	named_assocs : ğ Named_Assoc[EXP]
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Aggregates (named array with others)}

Agg\_Named\_Others is a named array aggregate with an others part.


=DOC
type ('AGG_CHOICE, 'EXP) ÛAGG_NAMED_OTHERSİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	agg_named : ('AGG_CHOICE, 'EXP) AGG_NAMED, 
	others : ('EXP) OTHERS
	};
=DESCRIBE
ÿAgg_Named_Others[EXP]üüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	Agg_Named[EXP];
Ü	Others[EXP]
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

Rec\_Agg\_Named is a named record aggregate. (Positional record aggregates are modelled by Agg\_Pos at the start of this section). The type of $named\_assocs$ is replaced with that used in named array aggregates to support the full syntax.

\subsubsection{Aggregates (named record)}

=DOC
type ('AGG_CHOICE,'EXP) ÛREC_AGG_NAMEDİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	named_assocs : ('AGG_CHOICE, 'EXP) NAMED_ASSOC list
	};
=DESCRIBE
ÿRec_Agg_Named[EXP]üüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	named_assocs : ğ (ID ¸ EXP)
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


\subsubsection{Unary Operations}

=DOC
datatype ÛUNARY_OPİ =
			ÛUOSparkUnaryAddİ
		|	ÛUOSparkUnaryMinusİ
		|	ÛUOSparkNotİ
		|	ÛUOSparkAbsİ;
=DESCRIBE
¹Z
Ü	UNARY_OP ::=
Ü	spark_unary_add | spark_unary_minus | spark_not | spark_abs
°
=ENDDOC



=DOC
type ('EXP) ÛUNARY_EXPİ
=TYPESTRUCT
      = {
	uop : UNARY_OP,
	right : 'EXP
	};
=DESCRIBE
ÿUnary_Exp[EXP]üüüüüüüüüüüüüüüüü
Ü	op : UNARY_OP;
Ü	right : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


\subsubsection{Binary Expressions}


The binary operators $BOSparkAndThen$, $BOSparkOrElse$ and $BOSparkConcat$ have been added.
=DOC
datatype ÛBIN_OPİ =
			ÛBOSparkAndİ | ÛBOSparkAndThenİ
		|	ÛBOSparkOrİ | ÛBOSparkOrElseİ | ÛBOSparkXorİ
		|	ÛBOSparkEqİ | ÛBOSparkNotEqİ
		|	ÛBOSparkLessİ | ÛBOSparkLessEqİ
		|	ÛBOSparkGreaterİ | ÛBOSparkGreaterEqİ
		|	ÛBOSparkAddİ | ÛBOSparkMinusİ | ÛBOSparkTimesİ
		|	ÛBOSparkIntdivİ | ÛBOSparkModİ | ÛBOSparkRemİ
		|	ÛBOSparkExponİ
		|	ÛBOSparkMemİ | ÛBOSparkNotMemİ
		|	ÛBOSparkConcatİ;
=DESCRIBE
¹Z
Ü	BIN_OP ::=
Ü	spark_and | spark_or | spark_xor | spark_eq | spark_noteq |
Ü	spark_less | spark_less_eq | spark_greater | spark_greater_eq |
Ü	spark_add | spark_minus | spark_times | spark_intdiv |
Ü	spark_mod | spark_rem | spark_expon | spark_mem | spark_notmem
°
=ENDDOC


=DOC
type 'EXP ÛBIN_EXPİ
=TYPESTRUCT
      = {
	bop : BIN_OP,
	left : 'EXP,
	right : 'EXP
	};
=DESCRIBE
ÿBin_Exp[EXP]üüüüüüüüüüüüüüüüü
Ü	op : BIN_OP;
Ü	left, right : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

Mem\_Range is the membership (or non-membership) of a range.


=DOC
type ÛMEM_OPİ
=TYPESTRUCT
	= BIN_OP;
=DESCRIBE
¹Z
Ü	MEM_OP ¦ {spark_mem, spark_notmem}
°
=ENDDOC


$op$ is a reserved word in Standard ML; hence we rename $op$ to $mop$.

=DOC
type ('EXP) ÛMEM_RANGEİ
=TYPESTRUCT
      = {
	left : 'EXP,
	mop : MEM_OP,
	range : 'EXP RANGE
	};
=DESCRIBE
ÿMem_Range[EXP]üüüüüüüüüüüüüüüüü
Ü	left : EXP;
Ü	op : MEM_OP;
Ü	Range[EXP]
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


\subsubsection{Attributes}
Attribute models Ada attributes.

ATTRIB denotes the attribute designators FIRST, LAST, SUCC, PRED, POS, VAL, LENGTH and RANGE.


=DOC
type ÛATTRIBİ
=TYPESTRUCT
	= ID;
=DESCRIBE
¹ZAX
Ü	fst, lst, suc, pred, pos, val, length, range : ID
°
¹Z
Ü	ATTRIB ¦ {fst, lst, suc, pred, pos, val, length, range}
°
=ENDDOC

ATTRIB\_DESIG models the attribute designators.

Generic free type definitions are not permitted in Z, so for ATTRIB\_DESIG we write the following (as per \cite{Spivey92}).

¹Z
Ü	[ATTRIB_DESIG]
°

[EXP]œœœœœœœœœœœœœœœœœœœœœœœœœœœœ
Ü	attrib : ATTRIB à ATTRIB_DESIG;
Ü	attrib_arg : (ATTRIB ¸ EXP) à ATTRIB_DESIG
÷üüüüüüüüüüüüüüüüüüüüü
Ü	disjoint §ran attrib, ran attrib_arg¢ ±
Ü
Ü	(µ W : ğ ATTRIB_DESIG ·
Ü	attrib ¨ATTRIB© À attrib_arg ¨ATTRIB ¸ EXP© € W
Ü	´ ATTRIB_DESIG € W)
ˆüüüüüüüüüüüüüüüüüüüüüü



The datatype for ATTRIB\_DESIG is declared in section \ref{TypeDefExpr}.


The prefix can in fact be a name (i.e., an expression).
=DOC
type ('EXP,'ATTRIB_DESIG) ÛATTRIBUTEİ
=TYPESTRUCT
      = {
	prefix : 'EXP,
	attribute_desig : 'ATTRIB_DESIG
	};
=DESCRIBE
ÿAttributeüüüüüüüüüüüüüüüüü
Ü	prefix : ID;
Ü	attrib_desig : ATTRIB_DESIG
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Indexed Component}
Indexed\_Comp models an array component.


=DOC
type ('EXP) ÛINDEXED_COMPİ
=TYPESTRUCT
      = {
	prefix : 'EXP,
	index : 'EXP
	};
=DESCRIBE
ÿIndexed_Comp[EXP]üüüüüüüüüüüüüüüüü
Ü	prefix, index : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Selected Component}
Selected\_Comp is a record component.


=DOC
type ('EXP) ÛSELECTED_COMPİ
=TYPESTRUCT
      = {
	prefix : 'EXP,
	selector : ID
	};
=DESCRIBE
ÿSelected_Comp[EXP]üüüüüüüüüüüüüüüüü
Ü	prefix : EXP;
Ü	selector : ID
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Function Calls}
Fun\_Call is a function call.


=DOC
type ('EXP) ÛFUN_CALLİ
=TYPESTRUCT
      = {
	fun_name : ID,
	args : 'EXP list
	};
=DESCRIBE
ÿFun_Call[EXP]üüüüüüüüüüüüüüüüü
Ü	fun_name : ID;
Ü	args : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Qualified Expressions}


=DOC
type 'EXP ÛQUALIFIED_EXPRESSIONİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	exp : 'EXP
	};
=DESCRIBE
ÿQualified_Exp[EXP]üüüüüüüüüüüüüüüüü
Ü	ex : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
The ML formulation preserves the type mark for inclusion in the SPARK program.
=ENDDOC
\subsubsection{Type Conversions}


=DOC
type 'EXP ÛTYPE_CONVERSIONİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	exp : 'EXP
	};
=DESCRIBE
ÿType_Conv[EXP]üüüüüüüüüüüüüüüüü
Ü	tm : TMARK;
Ü	ex : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
The ML names are slightly less terse than the Z ones for historical reasons.
=ENDDOC
\subsubsection{Integer Literals}
INT\_LIT are the integer literals.


=DOC
type ÛINT_LITİ
=TYPESTRUCT
	= string;
=DESCRIBE
¹Z
Ü	[INT_LIT]
°
=ENDDOC


\subsubsection{Auxiliary Expressions}
In the Compliance Notation, a SPARK expression can also be a Z expression (auxiliary expression).

In their use, they are expressions so appear as a branch of expressions.

\subsubsection{Type Definition for Expressions}\label{TypeDefExpr}

In order to reproduce the SPARK program as the user entered it, it is necessary to store bracketing information in the abstract syntax. Also qualified expressions, type conversions, string and character literals have been added.

The Auxiliary expression is represented as a parsed (but not type-checked) Z term. The type inference occurs during VC generation. (Note $id$ is a reserved word in Z, therefore $Id$ is used instead.)

The datatype for EXP is introduced in section \ref{datatypedefs}.

¹Z
Ü	EXP ::=	
Ü		Id ID | int INT_LIT | array_agg_pos (Agg_Pos[EXP]) |
Ü		array_agg_pos_others (Agg_Pos_Others[EXP]) |
Ü		array_agg_others (Agg_Others[EXP]) |
Ü		array_agg_named (Agg_Named[EXP]) |
Ü		array_agg_named_others (Agg_Named_Others[EXP]) |
Ü		rec_agg_pos (Agg_Pos[EXP]) | rec_agg_named (Rec_Agg_Named[EXP]) |
Ü		unary_exp (Unary_Exp[EXP]) | bin_exp (Bin_Exp[EXP]) |
Ü		mem_range (Mem_Range[EXP]) | attribute Attribute |
Ü		indexed_comp (Indexed_Comp[EXP]) |
Ü		selected_comp (Selected_Comp[EXP]) |
Ü		fun_call (Fun_Call[EXP]) |
Ü		qualified_exp (Qualified_Exp[EXP]) |
Ü		type_conv (Type_Conv[EXP]) |
Ü		auxiliary_exp Z_EXP
°

\subsection{Basic Declarations}

The Z specification of the abstract syntax uses a given set declaration to act as a forward declaration of the free type $EXP$, permitting the free type to involve recursion through schema constructions.
Unfortunately, this style is not considered to be type correct in \ProductZ; this is readily circumvented by making the schema constructions generic where necessary.


\subsubsection{Constants}
Const\_Decl models constant declarations.


It is useful to keep a list of the constants declared in the same constant declaration for reproducability. The const component is therefore implemented as a list.
=DOC
type 'EXP ÛCONST_DECLİ
=TYPESTRUCT
      = {
	consts : ID list,
	tm : TMARK,
	expr : 'EXP
	};
=DESCRIBE
ÿConst_Decl[EXP]üüüüüüüüüüüüüüüüü
Ü	const : ID;
Ü	tm : TMARK;
Ü	expr : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Enumerated Types}
Enum\_Type\_Def models enumerated types.


=DOC
type ÛENUM_TYPE_DEFİ
=TYPESTRUCT
      = {
	vals : ID list
	};
=DESCRIBE
ÿEnum_Type_Defüüüüüüüüüüüü
Ü	vals : seq ID
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Array Types}
Array\_Def models array types.

To support the concrete syntax for multi-dimensional arrays, the index is implemented as a list rather than a single instance of a type mark.
=DOC
type ÛARRAY_DEFİ
=TYPESTRUCT
      = {
	index : TMARK list,
	comp : TMARK
	};
=DESCRIBE
ÿArray_Defüüüüüüüüüüüü
Ü	index, comp : TMARK
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


\subsubsection{Record Types}

Var\_Decl is an Ada variable declaration.

In order to maintain the reproducability of the input, it is necessary to include all the identifiers together in a VAR\_DECL.
=DOC
type ÛVAR_DECLİ
=TYPESTRUCT
      = {
	vars : ID list,
	tmark : TMARK
	};
=DESCRIBE
ÿVar_Declüüüüüüüüüüüü
Ü	var : ID;
Ü	tmark : TMARK
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


Record\_Type\_Def models record types.

=DOC
type ÛRECORD_TYPE_DEFİ
=TYPESTRUCT
      = {
	decl : VAR_DECL list
	};
=DESCRIBE
ÿRecord_Type_Defüüüüüüüüüüüü
Ü	decl : seq Var_Decl
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Integer Types}

An integer type is characterised by its range.

\subsubsection{Real Types}
There is a requirement to support real type in the syntax even though they are not handled formally (hence there is no Z specification for this).
=DOC
type 'EXP ÛFLOATING_POINT_CONSTRAINTİ
=TYPESTRUCT
      = {
	exp : 'EXP,
	range : 'EXP RANGE OPT
	};
=DESCRIBE
=ENDDOC
=DOC
type 'EXP ÛFIXED_POINT_CONSTRAINTİ
=TYPESTRUCT
	= 'EXP FLOATING_POINT_CONSTRAINT;
=DESCRIBE
=ENDDOC

=DOC
type 'EXP ÛFLOATING_TYPE_DEFİ
=TYPESTRUCT
	= 'EXP FLOATING_POINT_CONSTRAINT;
=DESCRIBE
=ENDDOC

=DOC
type 'EXP ÛFIXED_TYPE_DEFİ
=TYPESTRUCT
	= 'EXP FIXED_POINT_CONSTRAINT;
=DESCRIBE
=ENDDOC


\subsubsection{Type Definitions}

The datatype for TYPE\_DEF is introduced in section \ref{datatypedefs}.
¹Z
TYPE_DEF ::= enum_type_def Enum_Type_Def | int_type_def (Range[EXP]) |
		uncon_array_def Array_Def | con_array_def Array_Def |
		record_type_def Record_Type_Def
°

An additional constructor is provided for private types and for reals to support the complete syntax.

\subsubsection{Type Declarations}
Type\_Decl is a type declaration, that is a type definition together with its name.

=DOC
type 'TYPE_DEF ÛTYPE_DECLİ
=TYPESTRUCT
      = {
	name : ID,
	type_def : 'TYPE_DEF
	};
=DESCRIBE
ÿType_Declüüüüüüüüüüüü
Ü	name : ID;
Ü	type_def : TYPE_DEF
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{SubTypes}
Subtype\_Decl models subtype declarations.

The datatype for CONSTRAINT is introduced in section \ref{datatypedefs}.

¹Z
CONSTRAINT ::= range_con (Range[EXP]) | index_con TMARK
°

Sub\_Ind is a subtype indication.


=DOC
type 'CONSTRAINT ÛSUB_INDİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	con : 'CONSTRAINT
	};
=DESCRIBE
ÿSub_Indüüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	con : CONSTRAINT
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


=DOC
type 'CONSTRAINT ÛSUBTYPE_DECLİ
=TYPESTRUCT
      = {
	name : ID,
	sub_ind : 'CONSTRAINT SUB_IND
	};
=DESCRIBE
ÿSubtype_Declüüüüüüüüüüüüüüüüü
Ü	name : ID;
Ü	Sub_Ind
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


\subsubsection{Deferred Constants}

Abstract syntax is also required for deferred constants.
=DOC
type ÛDEFERRED_CONST_DECLİ
=TYPESTRUCT
      = {
	consts : ID list,
	tmark : TMARK
	};
=DESCRIBE
=ENDDOC
\subsubsection{Private Types}
Private types are part of the syntax.
=DOC
type ÛPRIVATE_TYPE_DECLİ
=TYPESTRUCT
      = {
	id : ID,
	limited : bool
	};
=DESCRIBE
=ENDDOC

\subsubsection{Pragma}\label{pragma}
=DOC
type ('AGG_CHOICE, 'EXP) ÛPRAGMAİ
=TYPESTRUCT
      = {id : ID,
	  args : ('AGG_CHOICE OPT * 'EXP) list};
=DESCRIBE
This type gives the abstract syntax of SPARK pragmas (which are just treated as data to be written out to the SPARK program by the compliance tool).
=ENDDOC
\subsubsection{Annotation}\label{annotation}
=DOC
type ÛANNOTATIONİ
=TYPESTRUCT
      = string list;
=DESCRIBE
This type gives the abstract syntax of SPARK annotations (which are just treated as data to be written out to the SPARK program by the compliance tool).
=ENDDOC
\subsubsection{Basic Declarations}

The datatype for BASIC\_DECL is introduced in section \ref{datatypedefs}.

¹Z
BASIC_DECL ::= const_decl (Const_Decl[EXP]) | type_decl Type_Decl |
		subtype_decl Subtype_Decl
°

\subsection{Datatypes for Free Type Definitions}\label{datatypedefs}

=SML
datatype ÛCONSTRAINTİ =
			ÛCRangeİ of EXP RANGE
		|	ÛCIndexİ of EXP list
		|	ÛCFloatingİ of EXP FLOATING_POINT_CONSTRAINT
		|	ÛCFixedİ of EXP FIXED_POINT_CONSTRAINT
and ÛCASE_CHOICEİ =
				ÛCCCaseExpİ of EXP
			|	ÛCCCaseRangeİ of DISCRETE_RANGE
and ÛBASIC_DECLİ =
			ÛBDConstDeclİ of (EXP) CONST_DECL
		|	ÛBDDeferredConstDeclİ of DEFERRED_CONST_DECL
		|	ÛBDTypeDeclİ of (TYPE_DEF) TYPE_DECL
		|	ÛBDVarDeclİ of VAR_DECL
		|	ÛBDSubtypeDeclİ of (CONSTRAINT) SUBTYPE_DECL
		|	ÛBDPrivateTypeDeclİ of PRIVATE_TYPE_DECL
		|	ÛBDPragmaİ of (AGG_CHOICE, EXP) PRAGMA
		|	ÛBDAnnotationİ of ANNOTATION
and ÛATTRIB_DESIGİ =
			ÛADAttribİ of ATTRIB
		|	ÛADAttribArgİ of (ATTRIB * EXP)
and ÛDISCRETE_RANGEİ =
			ÛDRRangeİ of EXP RANGE
		|	ÛDRConstrainedİ of EXP DISCRETE_RANGE_CONSTRAINED
and ÛAGG_CHOICEİ =
			ÛACAggChoiceRangeİ of DISCRETE_RANGE
		|	ÛACAggChoiceSingleİ of EXP

and ÛTYPE_DEFİ =
			ÛTDEnumTypeDefİ of ENUM_TYPE_DEF
		|	ÛTDIntTypeDefİ of EXP RANGE
		|	ÛTDFloatingTypeDefİ of EXP FLOATING_TYPE_DEF
		|	ÛTDFixedTypeDefİ of EXP FIXED_TYPE_DEF
		|	ÛTDUnconArrayDefİ of ARRAY_DEF
		|	ÛTDConArrayDefİ of ARRAY_DEF
		|	ÛTDRecordTypeDefİ of RECORD_TYPE_DEF

and ÛEXPİ =
		ÛEIdİ of ID
	|	ÛEIntİ of INT_LIT
	|	ÛEArrayAggPosİ of EXP AGG_POS
	|	ÛEArrayAggPosOthersİ of EXP AGG_POS_OTHERS
	|	ÛEArrayAggOthersİ of EXP AGG_OTHERS
	|	ÛEArrayAggNamedİ of (AGG_CHOICE,EXP) AGG_NAMED
	|	ÛEArrayAggNamedOthersİ of
			(AGG_CHOICE,EXP) AGG_NAMED_OTHERS
	|	ÛERecAggPosİ of EXP AGG_POS
	|	ÛERecAggNamedİ of (AGG_CHOICE,EXP) REC_AGG_NAMED
	|	ÛEUnaryExpİ of EXP UNARY_EXP
	|	ÛEBinExpİ of EXP BIN_EXP
	|	ÛEMemRangeİ of EXP MEM_RANGE
	|	ÛEAttributeİ of (EXP,ATTRIB_DESIG) ATTRIBUTE
	|	ÛEIndexedCompİ of EXP INDEXED_COMP
	|	ÛESelectedCompİ of EXP SELECTED_COMP
	|	ÛEFunCallİ of EXP FUN_CALL
	|	ÛEAuxiliaryExpİ of Z_TM
	|	ÛEQualifiedExpİ of EXP QUALIFIED_EXPRESSION
	|	ÛETypeConversionİ of EXP TYPE_CONVERSION
	|	ÛEBracketedİ of EXP
	|	ÛEStringLiteralİ of string
	|	ÛECharacterLiteralİ of string;

=TEX

\subsection{Statements}

The Z specification of the abstract syntax uses a given set declaration to act as a forward declaration of the free type $Stmt$, permitting the free type to involve recursion through schema constructions.
Unfortunately, this style is not considered to be type correct in \ProductZ; this is readily circumvented by making the schema constructions generic where necessary.
For example, see section \ref{if-then-else} below.

Following this convention we may now work through the abstract syntax for SPARK statements following \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/1.2}.

\subsubsection{Null}\label{null}

The abstract syntax for null is provided as a data constructor within the type $STMT$ (see section \ref{stmt}).

\subsubsection{Assignment}\label{assignment}


=DOC
type ÛASSIGNİ
=TYPESTRUCT
      = {
	name : EXP,
	e : EXP
	};
=DESCRIBE
ÿAssignüüüüüüüüüüüüüüüüü
Ü	name, E : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Specification Statements}


=DOC
type ÛZ_PRED‰0İ
=TYPESTRUCT
	= Z_PRED;
=DESCRIBE
¹ZAX
Ü	Z_PRED‰0 : ğ Z_PRED
°
=ENDDOC

Labels can appear next to k-slots or specification statements.
=DOC
type ÛLABELİ
=TYPESTRUCT
      = string;
=DESCRIBE
=ENDDOC
The pre- and post-conditions in the specification are represented as parsed but not type-checked Z terms. This is so that type inference can be performed in the correct environment during VC generation. Note that in the Z, $pre$ is a reserved word, and so we use $Pre$.
=DOC
type ÛSPECİ
=TYPESTRUCT
      = {
	w : Z_ID list,
	w0 : Z_ID list,
	pre : Z_TM,
	post : Z_TM
	};
=DESCRIBE
ÿSpecüüüüüüüüüüüüüüüüü
Ü	w, w‰0 : ğ Z_ID;
Ü	Pre, post : Z_PRED
÷üüüüüüüüüüüüüüü
Ü	Pre  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
A Specification statement may be labelled.
=DOC
type ÛSPEC_NO_IVARSİ
=TYPESTRUCT
      = {
	spec : SPEC,
	label : LABEL
	};
=DESCRIBE
ÿSpec_No_Ivarsüüüüüüüüüüüü
Ü	Spec
÷üüüüüüüüüüüüüüü
Ü	post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Semicolon}\label{semicolon}

The abstract syntax for semicolon is provided as a data constructor within the type $STMT$ (see section \ref{stmt}).

\subsubsection{If-then-else}\label{if-then-else}


In an nested if statement 

=GFT SPARK Fragment
IF	<cond>	THEN	<stmt>;
ELSIF	<cond>	THEN	<stmt>;
...
ELSIF	<cond>	THEN	<stmt>;
END IF;
=TEX
is equivalent to
=GFT SPARK Fragment
IF	<cond>	THEN	<stmt>;
ELSE IF	<cond>	THEN	<stmt>; 
...
ELSE IF	<cond>	THEN	<stmt>; END IF; ... END IF;
END IF;
=TEX

I.e., ELSIF is the same as writing ELSE IF. In order to make the input reproducable in the SPARK program to be generated, a flag is stored with each abstract representation of the if statement indicating whether the else condition was input as an ELSIF or not.
=DOC
type ÛCONDİ
=TYPESTRUCT
	= EXP;
=DESCRIBE
¹ZAX
Ü	COND : ğ EXP
°
=ENDDOC

=DOC
type ('STMT) ÛIF_THEN_ELSEİ
=TYPESTRUCT
      = {
	g : COND,
	p : 'STMT,
	q : 'STMT,
	elsif : bool
	};
=DESCRIBE
ÿIf_Then_Else[Stmt]üüüüüüüüüüüüüüüüü
Ü	G : COND;
Ü	P, Q : Stmt
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Case}\label{case}


The case choice can be a discrete range. It is added to support the full syntax.
The type definition is introduced in section \ref{datatypedefs}.

¹Z
Ü	CASE_CHOICE ::= case_exp EXP | case_range (Range[EXP])
°


A Case statement can have an others part.
=DOC
type 'STMT ÛCASE_ALTERNATIVEİ
=TYPESTRUCT
      = {
	choices : CASE_CHOICE list,
	p : 'STMT
	};
=DESCRIBE
ÿCase_Alternative[Stmt]üüüüüüüüüüüüüüüüü
Ü	choices : ğ CASE_CHOICE;
Ü	P : Stmt
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
=DOC
type 'STMT ÛCASEİ
=TYPESTRUCT
      = {
	e : EXP,
	s : ('STMT) CASE_ALTERNATIVE list,
	others : 'STMT
	};
=DESCRIBE
ÿCase[Stmt]üüüüüüüüüüüüüüüüüüüü
Ü	E : EXP;
Ü	s : seq‰1 Case_Alternative[Stmt]
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Loop}\label{loop}


As with the translation of $Spec\_No\_Ivars$, we have a choice of how to translate the schema inclusion.
This case is a little more complicated, however, but as there is no overlap between the signature of the included schema and other signature variables, we can adopt the following simple translation.

The till clause may not be present in which case the t component will be true. However we make t optional to reflect the concrete syntax so that the SPARK program can be reproduced authentically.

A loop body may be a sequence of statements in which case the treatment of the loop can only be informal with respect to generating verification conditions: hence $'STMT$ rather than $SPEC_NO_IVARS$.
A loop without an iteration scheme can have a name, so we introduce an additional type called NAMED\_LOOP.
=DOC
type 'STMT ÛLOOPİ
=TYPESTRUCT
      = {
	t : Z_TM OPT,
	stmt : 'STMT
	};
=DESCRIBE
The till part is represented as a parsed (but not type-checked) Z term to enable type inference to happen in the correct environment during VC generation.
ÿLoopüüüüüüüüüüüüüüüüü
Ü	T : Z_PRED;
Ü	Spec_No_Ivars
÷üüüüüü
Ü	T  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
=DOC
type 'STMT ÛNAMED_LOOPİ
=TYPESTRUCT
      = {
	name : ID,
	t : Z_TM OPT,
	stmt : 'STMT
	};
=DESCRIBE
The till part is represented as a parsed (but not type-checked) Z term to enable type inference to happen in the correct environment during VC generation.
=ENDDOC

\subsubsection{While Loop}\label{while-loop}

Loops can have names, so a name is introduced into the abstract representation.
=DOC
type 'STMT ÛWHILEİ
=TYPESTRUCT
      = {
	name : ID OPT,
	g : COND,
	loop : 'STMT LOOP
	};
=DESCRIBE
ÿWhileüüüüüüüüüüüüüüüüü
Ü	G : COND;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{For Loop (Static Bounds)}\label{for-static}


Loops can have names so a field in the abstract representation is reserved for name. Also we record in the abstract syntax the direction of the loop and the type mark for the purposes of reproducing the SPARK program.

=DOC
type ÛSTATIC_EXPİ
=TYPESTRUCT
	= EXP;
=ENDDOC
¹ZAX
Ü	STATIC_EXP : ğ EXP
°
=DOC
datatype ÛLOOP_DIRECTIONİ =
				ÛLDForwardsİ
			|	ÛLDReverseİ;
=DESCRIBE
=ENDDOC
A range component is used rather than a lo-hi pair in order to support the possibility of representing a range attribute.
=DOC
type 'STMT ÛFOR_STATICİ
=TYPESTRUCT
      = {
	name : ID OPT,
	i : ID,
	tmark : ID,
	range : EXP RANGE,
	dir : LOOP_DIRECTION,
	loop : 'STMT LOOP
	};
=DESCRIBE
ÿFor_Staticüüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	lo, hi : STATIC_EXP;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{For Loop (Type Mark as Range)}\label{for-typemark}


FOR\_TMARK is augmented in the same way as for FOR\_STATIC.

=DOC
type 'STMT ÛFOR_TMARKİ
=TYPESTRUCT
      = {
	name : ID OPT,
	i : ID,
	tmark : TMARK,
	dir : LOOP_DIRECTION,
	loop : 'STMT LOOP
	};
=DESCRIBE
ÿFor_Tmarküüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	tmark : TMARK;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Exit Statement (with condition)}\label{exit}


=DOC
type ÛEXIT_WHENİ
=TYPESTRUCT
      = {
	g : COND
	};
=DESCRIBE
ÿExit_Whenüüüüüüüüüüüüüüüüü
Ü	G : COND
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Exit Statement}\label{exit-stmt}
$Exit$ is implemented as a data constructor as part of $STMT$ (see section \ref{stmt}).


\subsubsection{Return}\label{return}


=DOC
type ÛRETURNİ
=TYPESTRUCT
      = {
	e : EXP
	};
=DESCRIBE
ÿReturnüüüüüüüüüüüüüüüüü
Ü	E : EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Procedure Call}\label{procedure-call}


The actual part can be a positional parameter association or a named parameter association.

=DOC
datatype ('AGG_CHOICE, 'EXP) ÛACTUALSİ =
			ÛAPositionalİ of EXP list
		|	ÛANamedİ of ('AGG_CHOICE, 'EXP) NAMED_ASSOC list;
=DESCRIBE
=ENDDOC
=DOC
type ('AGG_CHOICE,'EXP) ÛPROC_CALLİ
=TYPESTRUCT
      = {
	name : ID,
	actuals : ('AGG_CHOICE,'EXP) ACTUALS
	};
=DESCRIBE
ÿProc_Callüüüüüüüüüüüüüüüüü
Ü	name : ID;
Ü	actuals : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC



=DOC
type ('AGG_CHOICE,'EXP) ÛPROC_CALL_NO_IVARSİ
=TYPESTRUCT
	= ('AGG_CHOICE,'EXP) PROC_CALL;
=DESCRIBE
¹ZAX
Ü	retrieve_spec_stmt : ID ß Spec
°
ÿProc_Call_No_Ivarsüüüüüüüüüüüüüüüüü
Ü	Proc_Call
÷üüüüüüüüüüüüüüüü
Ü	(retrieve_spec_stmt name).post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


\subsubsection{$Stmt$}\label{stmt}
\ProductZ\ is currently non-standard in that it neither requires nor
allows the chevrons around the operands in a free type definition.
This mismatch with the Z standard is planned to be remedied in a future release of the system.


K-Slots are required in the abstract syntax as place markers so that when the SPARK program is reproduced from the abstract syntax, the expansions can be put back into the correct places.
=DOC
type ÛK_SLOTİ
=TYPESTRUCT
      = {
	content : string,
	label : LABEL
	};
=DESCRIBE
=ENDDOC
Note that $STImplicitNull$ has been introduced because there are cases where a null statement is required in the syntax (e.g., in $SSpecIvars$ of \ref{statement}) which might not have been present in the input. Therefore such a statement is recorded in the abstract syntax as an implicit null statement, denoting that it should not appear subsequently in the SPARK program. 
=DOC
datatype ÛSTMTİ
		= 	ÛSTNullİ
		| 	ÛSTImplicitNullİ
		|	ÛSTAssignİ of ASSIGN
		|	ÛSTSpecNoIvarsİ of SPEC_NO_IVARS
		|	ÛSTSemicolonİ of (STMT * STMT)
		|	ÛSTIfThenElseİ of  STMT IF_THEN_ELSE
		|	ÛSTCaseİ of STMT CASE
		|	ÛSTLoopİ of STMT LOOP
		|	ÛSTNamedLoopİ of STMT NAMED_LOOP
		|	ÛSTWhileİ of STMT WHILE
		|	ÛSTForStaticİ of STMT FOR_STATIC
		|	ÛSTForTmarkİ of STMT FOR_TMARK
		|	ÛSTExitWhenİ of EXIT_WHEN
		|	ÛSTExitİ
		|	ÛSTRetİ of RETURN
		|	ÛSTProcNoIvarsİ of (AGG_CHOICE,EXP) PROC_CALL_NO_IVARS
		|	ÛSTKSlotİ of K_SLOT
		|	ÛSTPragmaİ of (AGG_CHOICE, EXP) PRAGMA
		|	ÛSTAnnotationİ of ANNOTATION;
=DESCRIBE
¹Z
	Stmt	::= 	null
		|	assign Assign
		|	spec_no_ivars Spec_No_Ivars
		|	semicolon (Stmt ¸ Stmt)
		|	if_then_else (If_Then_Else[Stmt])
		|	case (Case[Stmt])
		|	loop Loop
		|	while While
		|	for_static For_Static
		|	for_tmark For_Tmark
		|	exit_when Exit_When
		|	exit
		|	ret Return
		|	proc_no_ivars Proc_Call_No_Ivars
°
=ENDDOC
\pagebreak
\subsubsection{Specification (with initial variables)}\label{specification-ivars}

A specification statement may be labelled.
=DOC
type ÛSPEC_IVARSİ 
=TYPESTRUCT
      = {
	spec :SPEC,
	label : LABEL
	};
=DESCRIBE
ÿSpec_Ivarsüüüüüüüüüüüü
Ü	Spec
÷üüüüüüüüüüüüüüü
Ü	post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{For Loop (Non-Static Bounds)}\label{for-non-static-bounds}


A loop may have an optional name. 

A range component is used rather than a lo-hi pair in order to support the possibility of representing a range attribute.
=DOC
type ÛFOR_NON_STATICİ
=TYPESTRUCT
      = {
	name : ID OPT,
	i : ID,
	range : STATIC_EXP RANGE,
	loop : STMT LOOP
	};
=DESCRIBE
ÿFor_Non_Staticüüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	lo, hi : EXP;
Ü	Loop
÷üüüüüüüüüüüüüüüü
Ü		lo  STATIC_EXP
Ü	²
Ü		hi  STATIC_EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Logical Constants}\label{logical-constants}


The function $free\_id$ may readily and realistically be implemented using existing \Product\
syntax functions.
$t$ represents the set of which $x$ is a member.
$t$ is represented as a parsed Z term. Type inference occurs during VC generation when the appropriate $Z\_EXP$ is generated. The values for $e$ and $pre1$ are filled in at this time.
Logical constants may also have a label.
=DOC
type ÛLOG_CONİ
=TYPESTRUCT
      = {
	x : Z_ID,
	t : Z_TM,
	e : Z_EXP,
	spec : SPEC,
	pre1 : Z_EXP,
	label : LABEL
	};
=DESCRIBE
¹ZAX
Ü	free_ids : Z_EXP ­ ğ Z_ID
°

ÿLog_Conüüüüüüüüüüüü
Ü	X : Z_ID;
Ü	E : Z_EXP;
Ü	Spec;
Ü	pre‰1 : Z_PRED
÷üüüüüüüüüüüüüüü
Ü	Pre = z_and(z_eq(zid X, E), pre‰1);
Ü	X  free_ids E
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Procedure Calls (initial variables in spec)}\label{procedure-calls}


=DOC
type ('AGG_CHOICE,'EXP) ÛPROC_CALL_IVARSİ
=TYPESTRUCT
	= ('AGG_CHOICE,'EXP) PROC_CALL;
=DESCRIBE
ÿProc_Call_Ivarsüüüüüüüüüüüü
Ü	Proc_Call
÷üüüüüüüüüüüüüüü
Ü	(retrieve_spec_stmt name).post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Statement}\label{statement}

=DOC
datatype ÛSTATEMENTİ =
		 	ÛSStmtİ of STMT
		|	ÛSSpecIvarsİ of SPEC_IVARS * STMT
		|	ÛSForNonStaticİ of FOR_NON_STATIC * STMT
		|	ÛSLogConİ of LOG_CON * STMT
		|	ÛSProcIvarsİ of
				(AGG_CHOICE,EXP) PROC_CALL_IVARS * STMT;
=DESCRIBE
¹Z
	Statement
		::= 	stmt Stmt
		|	spec_ivars (Spec_Ivars ¸ Stmt)
		|	for_non_static (For_Non_Static ¸ Stmt)
		|	log_con (Log_Con ¸ Stmt)
		|	proc_ivars (Proc_Call_Ivars ¸ Stmt)
°
=ENDDOC

\subsection{Subprogram Declarations}
The abstract syntax in this section and in the rest of the document is constructed from an abstraction of the concrete syntax of SPARK. It is not specified formally in \cite{DRA/CIS/CSE3/TR/94/27/1.2}, hence there is no transcribed Z specification here.
=DOC
datatype ÛMODEİ =	MSparkIn
		|	MSparkOut
		|	MSparkInOut;
=DESCRIBE
=ENDDOC
=DOC
type ÛPARAMETER_SPECIFICATIONİ
=TYPESTRUCT
      = {
	idlist : ID list,
	mode : MODE,
	name : TMARK
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛPROCEDURE_SPECIFICATIONİ
=TYPESTRUCT
      = {
	name : ID,
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT,
	annotation : ANNOTATION
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛFUNCTION_SPECIFICATIONİ
=TYPESTRUCT
      = {
	designator : ID,
	return : TMARK,
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT,
	annotation : ANNOTATION
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛSUBPROGRAM_SPECIFICATIONİ =
			ÛSSProcedureİ of PROCEDURE_SPECIFICATION
		|	ÛSSFunctionİ of FUNCTION_SPECIFICATION;
=DESCRIBE
=ENDDOC
=DOC
type ÛPROCEDURE_DECLARATIONİ
=TYPESTRUCT
	= PROCEDURE_SPECIFICATION;
=DESCRIBE
=ENDDOC
=DOC
type ÛFUNCTION_DECLARATIONİ
=TYPESTRUCT
	= FUNCTION_SPECIFICATION;
=DESCRIBE
=ENDDOC
=DOC
type ÛSUBPROGRAM_DECLARATIONİ
=TYPESTRUCT
	= SUBPROGRAM_SPECIFICATION;
=DESCRIBE
=ENDDOC
\subsection{Procedure and Function Calls}
=DOC
type ÛNAMED_PARAMİ
=TYPESTRUCT
      = {
	formal : ID,
	actual : EXP
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛNAMED_PARAMETER_ASSOCİ
=TYPESTRUCT
      = {
	params: NAMED_PARAM list
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛPOS_PARAMETER_ASSOCİ
=TYPESTRUCT
      = {
	params : EXP list
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛACTUAL_PARAMETER_PARTİ = 
			ÛAPPNamedİ of NAMED_PARAMETER_ASSOC
		|	ÛAPPPositionalİ of POS_PARAMETER_ASSOC;
=DESCRIBE
=ENDDOC
\subsection{Package Declaration}
=DOC
type ÛOPERATOR_SYMBOLİ
=TYPESTRUCT
	= string;
=DESCRIBE
=ENDDOC
=DOC
type ÛFUNCTION_RENAMINGİ
=TYPESTRUCT
      = {
	opsym1 : OPERATOR_SYMBOL,
	formal_part : PARAMETER_SPECIFICATION list,
	tmark : TMARK,
	name : ID,
	opsym2 : OPERATOR_SYMBOL
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛSUBPROGRAM_RENAMINGİ
=TYPESTRUCT
      = {
	subprogram_specification : SUBPROGRAM_SPECIFICATION,
	name1 : ID,
	name2 : ID
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛRENAMING_DECLARATIONİ =
			ÛRDFunctionİ of FUNCTION_RENAMING
		|	ÛRDSubprogramİ of SUBPROGRAM_RENAMING;
=DESCRIBE
=ENDDOC
=DOC
type ÛLENGTH_CLAUSEİ
=TYPESTRUCT
      = {
	attribute : EXP,
	exp : EXP
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛENUMERATION_REPRESENTATION_CLAUSEİ
=TYPESTRUCT
      = {
	name : ID,
	exp : EXP
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛCOMPONENT_CLAUSEİ
=TYPESTRUCT
      = {
	name : ID,
	exp : EXP,
	range : EXP RANGE
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛRECORD_REPRESENTATION_CLAUSEİ
=TYPESTRUCT
      = {
	name : ID,
	alignment_opt : EXP OPT,
	component_pack : COMPONENT_CLAUSE list
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛADDRESS_CLAUSEİ
=TYPESTRUCT
      = {
	name : ID,
	exp : EXP
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛREPRESENTATION_CLAUSEİ =
		ÛRCLengthİ of LENGTH_CLAUSE
	|	ÛRCEnumerationİ of ENUMERATION_REPRESENTATION_CLAUSE
	|	ÛRCRecordİ of RECORD_REPRESENTATION_CLAUSE
	|	ÛRCAddressİ of ADDRESS_CLAUSE;
=DESCRIBE
=ENDDOC
=DOC
type 'DECLARATION ÛPROCEDURE_BODYİ
=TYPESTRUCT
      = {
	procedure_spec : PROCEDURE_SPECIFICATION,
	declarative_part : 'DECLARATION list,
	statement : STATEMENT
	};
=DESCRIBE
=ENDDOC
=DOC
type 'DECLARATION ÛFUNCTION_BODYİ
=TYPESTRUCT
      = {
	function_spec : FUNCTION_SPECIFICATION,
	declarative_part : 'DECLARATION list,
	statement : STATEMENT
	};
=DESCRIBE
=ENDDOC
=DOC
type 'DECLARATION ÛPACKAGE_BODYİ
=TYPESTRUCT
      = {
	name : ID,
	decls : 'DECLARATION list,
	statement : STATEMENT,
	annotation : ANNOTATION
	};
=DESCRIBE
=ENDDOC
=DOC
type 'DECLARATION ÛPACKAGE_DECLARATIONİ
=TYPESTRUCT
      = {
	name : ID,
	visible_decs : 'DECLARATION list,
	private_decs : 'DECLARATION list,
	annotation : ANNOTATION
	};

=DESCRIBE
=ENDDOC
Auxiliary expressions are resolved by the presence of a using declaration. This is specified in \cite[volume 1]{DRA/CIS/CSE3/TR/94/27/1.2}. It is necessary to extend the abstract syntax to include ``using'' declarations.

Note that the component $basic\_decls$ is added in case we need to reproduce the user's input. The component $concrete\_vars$ is a subset of the basic declarations which are variables. 

$t$ represents the set of which $aux$ is a member.

=DOC
type ÛAUX_VARİ
=TYPESTRUCT
      = {
	aux : Z_ID,
	t : Z_TM
	};
=DESCRIBE
ÿAUX_VARüüüüüüüüüüüüüüüüü
Ü	aux : Z_Decl[Z_EXP]
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
type ÛUSING_DECİ
=TYPESTRUCT
      = {
	aux : Z_TM,
	concrete_vars : VAR_DECL list,
	basic_decls : BASIC_DECL list,
	invariant : Z_TM
	};
=DESCRIBE
ÿUSING_DECüüüüüüüüüüüüüüüüü
Ü	aux : Z_ID;
Ü	concrete_vars : ğ Var_Decl;
Ü	invariant : Z_PRED
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


=DOC
datatype ÛDEC_K_SLOT_TYPEİ =
			ÛDKPrivateİ
		|	ÛDKVisibleİ
		|	ÛDKDeclarationİ;
=DESCRIBE
This datatype is used in the datatype $DECLARATION$s to destinguish between the three types of k-slot which can occur as a declaration.
=ENDDOC

=DOC
datatype ÛDECLARATIONİ =
		ÛDDeclarationKSlotİ of (K_SLOT * DEC_K_SLOT_TYPE)
	|	ÛDRenamingDeclarationİ of RENAMING_DECLARATION
	|	ÛDBasicDeclİ of BASIC_DECL
	|	ÛDRepresentationClauseİ of REPRESENTATION_CLAUSE
	|	ÛDProperBodyİ of PROPER_BODY
	|	ÛDProcedureDeclarationİ of PROCEDURE_DECLARATION
	|	ÛDFunctionDeclarationİ of FUNCTION_DECLARATION
	|	ÛDPackageDeclarationİ of DECLARATION PACKAGE_DECLARATION
	|	ÛDProcedureStubİ of PROCEDURE_DECLARATION
	|	ÛDFunctionStubİ of FUNCTION_DECLARATION
	|	ÛDPackageStubİ of ID
	|	ÛDExternalProcedureStubİ of PROCEDURE_DECLARATION
	|	ÛDExternalFunctionStubİ of FUNCTION_DECLARATION
	|	ÛDAuxiliaryİ of AUX_VAR
	|	ÛDUsingİ of USING_DEC
=DESCRIBE
=ENDDOC
=DOC
and ÛPROPER_BODYİ =	ÛPBProcedureİ of DECLARATION PROCEDURE_BODY
		|	ÛPBFunctionİ of DECLARATION FUNCTION_BODY
		|	ÛPBPackageİ of DECLARATION PACKAGE_BODY;
=DESCRIBE
=ENDDOC

=DOC
type ÛCOMP_SUBUNITİ
=TYPESTRUCT
      = {
	name : ID,
	proper_body : PROPER_BODY
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛCOMPILATION_UNITİ =
		ÛCUPackageDeclarationİ of DECLARATION PACKAGE_DECLARATION
	|	ÛCUProperBodyİ of PROPER_BODY
	|	ÛCUSubUnitİ of COMP_SUBUNIT;

=DESCRIBE
=ENDDOC
=DOC
type ÛREFINED_BYİ
=TYPESTRUCT
      = {
	label : LABEL,
	statement : STATEMENT
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛREPLACED_BYİ
=TYPESTRUCT
      = {
	label : LABEL,
	statement : STATEMENT
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛREPLACED_BY_DECLİ
=TYPESTRUCT
      = {
	label : LABEL,
	decls : DECLARATION list
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛREPLACED_BY_VISIBLE_PARTİ
=TYPESTRUCT
      = {
	label : LABEL,
	visible : DECLARATION list
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛREPLACED_BY_PRIVATE_PARTİ
=TYPESTRUCT
      = {
	label : LABEL,
	private : DECLARATION list
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛCONTEXT_COMPILATION_UNITİ
=TYPESTRUCT
      = {
	context : ID list,
	comp_unit : COMPILATION_UNIT,
	pragmas : (AGG_CHOICE, EXP) PRAGMA list,
	annotation : ANNOTATION
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛKSLOT_COMPILATION_UNITİ =
			ÛKCUKSlotİ of K_SLOT
		|	ÛKCUUnitİ of CONTEXT_COMPILATION_UNIT
		|	ÛKCUPragmaİ of (AGG_CHOICE, EXP) PRAGMA;
=DESCRIBE
=ENDDOC
=DOC
type ÛREPLACED_BY_COMPİ
=TYPESTRUCT
      = {
	label : LABEL,
	comp : KSLOT_COMPILATION_UNIT list
	};
=ENDDOC
=DOC
type ÛREPLACED_BY_ARBITRARY_ADAİ
=TYPESTRUCT
      = {
	label : LABEL,
	replacement : string
	};
=DESCRIBE
This is the type for an arbitrary Ada replacment, which for the compliance tool,  is just textual data to be passed into the output SPARK program.
=ENDDOC
=DOC
datatype ÛWEB_CLAUSEİ = 
			ÛWCCompilationİ of KSLOT_COMPILATION_UNIT list
		|	ÛWCReplacedByCompilationİ of REPLACED_BY_COMP
		|	ÛWCReplacedByPrivatePartİ of REPLACED_BY_PRIVATE_PART
		|	ÛWCReplacedByVisiblePartİ of REPLACED_BY_VISIBLE_PART
		|	ÛWCReplacedByDeclİ of REPLACED_BY_DECL
		|	ÛWCReplacedByArbitraryAdaİ of REPLACED_BY_ARBITRARY_ADA
		|	ÛWCRefinedByİ of REFINED_BY
		|	ÛWCReplacedByİ of REPLACED_BY;
=DESCRIBE
=ENDDOC

\section{EPILOGUE}

=SML
end (* local ... in *);
end (* of signature CNTypes *);
=TEX

\section{TEST POLICY}
There are no module tests for the design in this document since it specifies no functions.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



