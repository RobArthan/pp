%  dtd502.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Compliance Notation Lexis and Abstract Syntax}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD502}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan&HAT Team}
\TPPabstract{
This document contains the detailed design for the lexis and abstract syntax for Compliance Notation}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion] Initial Draft.

\end{description}
\subsection{Changes Forecast}
This document is a prototype and is under development. 
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the abstract syntax for Compliance Notation.

\subsection{Introduction}
\subsubsection{Purpose and Background}
\subsubsection{Dependencies}
\subsubsection{Deficiencies}
None known.

\section{LEXIS}
=DOC
signature ÛCNTypesİ = sig
=DESCRIBE
This is the signature for the structure containing the types required for Compliance Notation.
=ENDDOC

=DOC
datatype ÛCN_LEX_CLASSİ
			= ÛLCAbstractExpressionİ
			| ÛLCAbsİ | ÛLCAmpersandİ | ÛLCAndİ | ÛLCArrayİ |ÛLCAtİ
			| ÛLCBarİ |ÛLCBBodyİ | ÛLCBecomesİ | ÛLCBeginİ
			| ÛLCCaseİ| ÛLCCharacterLiteralİ
			| ÛLCColonİ | ÛLCCommaİ | ÛLCCompLabelİ | ÛLCConstantİ
			| ÛLCConİ | ÛLCCrdİ | ÛLCDecLabelİ | ÛLCDeltaİ
			| ÛLCDigitsİ | ÛLCDivİ| ÛLCDotDotİ | ÛLCDotİ | ÛLCElseİ
			| ÛLCElsIfİ | ÛLCEndİ | ÛLCEqualsİ | ÛLCExitİ
			| ÛLCFatDotİ | ÛLCForİ | ÛLCFunctionNameİ | ÛLCFunctionİ
			| ÛLCGoesToİ | ÛLCGreaterEqualsİ
			| ÛLCGreaterThanİ | ÛLCIdentifierİ | ÛLCIfİ
			| ÛLCInİ | ÛLCIsİ
			| ÛLCKSlotİ | ÛLCLessEqualsİ | ÛLCLessGreatİ | ÛLCLessThanİ
			| ÛLCLimitedİ | ÛLCLoopİ | ÛLCMinusİ
			| ÛLCModİ | ÛLCNotEqualsİ | ÛLCNotİ | ÛLCNullİ
			| ÛLCNumericLiteralİ | ÛLCOfİ
			| ÛLCOrdİ | ÛLCOrİ | ÛLCOthersİ | ÛLCOutİ
			| ÛLCPackageİ | ÛLCPlusİ
			| ÛLCPPartLabelİ | ÛLCPrimeİ | ÛLCPrimedIdentifierİ
			| ÛLCPrivateİ | ÛLCProcedureNameİ | ÛLCProcedureİ
			| ÛLCRecordİ | ÛLCRefinedByİ | ÛLCRemİ
			| ÛLCRenamesİ | ÛLCReplacedByİ | ÛLCReturnİ
			| ÛLCReverseİ | ÛLCRRangeİ | ÛLCSemiİ
			| ÛLCSeparateİ | ÛLCSpecLabelİ | ÛLCStarStarİ
			| ÛLCStarİ | ÛLCStmtLabelİ
			| ÛLCStringLiteralİ | ÛLCSubTypeİ | ÛLCThenİ
			| ÛLCTillİ | ÛLCTypeMarkİ
			| ÛLCTypeİ | ÛLCUseİ | ÛLCVPartLabelİ
			| ÛLCWhenİ | ÛLCWhileİ | ÛLCWithİ | ÛLCXorİ | ÛLCEosİ
			| ÛLCZİ
			| ÛLCGrkDeltaİ | ÛLCLSqBrackİ | ÛLCRSqBrackİ
			| ÛLCLBraceİ | ÛLCRBraceİ | ÛLCLStracheyİ
			| ÛLCRStracheyİ | ÛLCLChevronİ | ÛLCRChevronİ;
=DESCRIBE
CN\_LEX\_CLASS is the datatype used to represent the lexical classes of tokens in compliance notation. 
=ENDDOC

=DOC
datatype ÛCN_TOKENİ	=	ÛCNZİ of ZLex.Z_TOKEN list
			|	ÛCNTextİ of string
			|	ÛCNStringİ of string
			|	ÛCNKSlotİ of Lex.INPUT list
			|	ÛCNEosİ;

type ÛCN_LEX_ITEMİ
=TYPESTRUCT
	= CN_LEX_CLASS * CN_TOKEN;
=DESCRIBE
CN\_TOKEN is the datatype used to represent the lexical tokens required in compliance notation. CN\_LEX\_ITEM is a type used by the lexical analyser for communicating to the parser the lexical information. The class (the first of the pair) is the classification of the token (the second of the pair).
=ENDDOC
\newpage
\section{ABSTRACT SYNTAX}

\subsection{Preamble for Z Type-Checking}
The following initialises the theory database when performing a syntax and type check on the Z paragraphs in this document. (This preamble is not processed when building the compliance tool.)

=SMLZ
open_theory"z_library";
push_pc "z_library";
delete_theory"dtd502" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", true);
new_theory"dtd502";
=TEX

\subsection{Basic Declarations}
The Z specification of the abstract syntax uses a given set declaration to act as a forward declaration of the free type $EXP$, permitting the free type to involve recursion through schema constructions.
Unfortunately, this style is not considered to be type correct in \ProductZ; this is readily circumvented by making the schema constructions generic where necessary.

\subsubsection{Identifiers}

ID is the set of Ada Identifiers.

¹Z
Ü	[ID]
°

=SML
type ÛIDİ
=TYPESTRUCT
	= string;
=TEX

\subsubsection{Enumerated Types}
Enum\_Type\_Def models enumerated types.

ÿEnum_Type_Defüüüüüüüüüüüü
Ü	vals : seq ID
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ÛENUM_TYPE_DEFİ
=TYPESTRUCT
      = {
	vals : ID list
	};
=TEX

\subsubsection{Type Marks}
TMARK is the set of type marks in the literate script.

¹ZAX
Ü	TMARK : ğ ID
°

=SML
type ÛTMARKİ
=TYPESTRUCT
	= ID;
=TEX

\subsubsection{Array Types}
Array\_Def models array types.

ÿArray_Defüüüüüüüüüüüü
Ü	index, comp : TMARK
ˆüüüüüüüüüüüüüüüüüüüüü

The index can be a list of type marks, so this is modelled below.
=SML
type ÛARRAY_DEFİ
=TYPESTRUCT
      = {
	index : TMARK list,
	comp : TMARK
	};
=TEX

\subsubsection{Variable Declarations}
Var\_Decl is an Ada variable declaration.

ÿVar_Declüüüüüüüüüüüü
Ü	var : ID;
Ü	tmark : TMARK
ˆüüüüüüüüüüüüüüüüüüüüü

In order to maintain the reproducability of the input, it is necessary to include all the identifiers together in a VAR\_DECL.
=SML
type ÛVAR_DECLİ
=TYPESTRUCT
      = {
	vars : ID list,
	tmark : TMARK
	};
=TEX
\subsubsection{Variants}
Variants are new.
=SML
type 'COMPONENT ÛVARIANTİ
=TYPESTRUCT
      = {
	ids : ID list,
	comp : 'COMPONENT list
	};
=TEX
=SML
type 'COMPONENT ÛVARIANT_PARTİ
=TYPESTRUCT
      = {
	id : ID,
	variants : 'COMPONENT VARIANT list
	};
=TEX
=SML
type 'COMPONENT ÛDECLARATION_VARIANTİ
=TYPESTRUCT
      = {
	decls : VAR_DECL list,
	variant : 'COMPONENT VARIANT_PART
	};
=TEX
=SML
datatype ÛCOMPONENTİ =
			ÛCDeclarationİ of VAR_DECL list
		|	ÛCVariantPartİ of COMPONENT VARIANT_PART
		|	ÛCDeclarationVariantİ of COMPONENT DECLARATION_VARIANT
		|	ÛCNoneİ;
=TEX


\subsubsection{Record Types}
Record\_Type\_Def models record types.

ÿRecord_Type_Defüüüüüüüüüüüü
Ü	decl : seq Var_Decl
ˆüüüüüüüüüüüüüüüüüüüüü

Record types can have variant records, so we use a different definition.
=SML
type 'COMPONENT ÛRECORD_TYPE_DEFİ
=TYPESTRUCT
      = {
	comps : 'COMPONENT list
	};
=TEX

\subsubsection{Integer Types}

An integer type is characterised by its range.

ÿRange[EXP]üüüüüüüüüüüü
Ü	lo, hi : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

A range can be just a range attribute which can be represented by one expression. To support this, we use the lo to store the range attribute and make the hi optional. 
=SML
type 'EXP ÛRANGEİ
=TYPESTRUCT
      = {
	lo : 'EXP,
	hi : 'EXP OPT
	};
=TEX

\subsubsection{Real Types}
=SML
type 'EXP ÛFLOATING_POINT_CONSTRAINTİ
=TYPESTRUCT
      = {
	exp : 'EXP,
	range : 'EXP RANGE OPT
	};
=TEX
=SML
type 'EXP ÛFIXED_POINT_CONSTRAINTİ
=TYPESTRUCT
	= 'EXP FLOATING_POINT_CONSTRAINT;
=TEX

=SML
type 'EXP ÛFLOATING_TYPE_DEFİ
=TYPESTRUCT
	= 'EXP FLOATING_POINT_CONSTRAINT;
=SML
type 'EXP ÛFIXED_TYPE_DEFİ
=TYPESTRUCT
	= 'EXP FIXED_POINT_CONSTRAINT;
=TEX

\subsubsection{Private Types}
=SML
type ÛPRIVATE_TYPE_DEFİ
=TYPESTRUCT
      = {
	id : ID,
	limited : bool
	};
=TEX
\subsubsection{Type Definitions}

TYPE\_DEF brings all the above type definitions together.

¹Z
TYPE_DEF ::= enum_type_def Enum_Type_Def | int_type_def Range |
		uncon_array_def Array_Def | con_array_def Array_Def |
		record_type_def Record_Type_Def
°

The datatype for TYPE\_DEF is declared with other datatypes co-recursively with EXP in section \ref{TypeDefExpr}.

An additional constructor is provided for private types and for reals.

\subsubsection{Type Declarations}
Type\_Decl is a type declaration, that is a type definition together with its name.

ÿType_Declüüüüüüüüüüüü
Ü	name : ID;
Ü	type_def : TYPE_DEF
ˆüüüüüüüüüüüüüüüüüüüüü

The optional discriminant part is required.
=SML
type DISCR_PART
=TYPESTRUCT
	= VAR_DECL OPT;
=TEX

=SML
type 'TYPE_DEF ÛTYPE_DECLİ
=TYPESTRUCT
      = {
	name : ID,
	discr : DISCR_PART,
	type_def : 'TYPE_DEF
	};
=TEX

\subsubsection{SubTypes}
Subtype\_Decl models subtype declarations.

¹Z
CONSTRAINT ::= range_con Range | index_con TMARK
°

The datatype for CONSTRAINT is declared with other datatypes co-recursively with EXP in section \ref{TypeDefExpr}.

A constraint can also be a fixed or a floating point constraint. The following changes remedy this.

Sub\_Ind is a subtype indication.

ÿSub_Indüüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	con : CONSTRAINT
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type 'CONSTRAINT ÛSUB_INDİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	con : 'CONSTRAINT
	};
=TEX

ÿSubtype_Declüüüüüüüüüüüüüüüüü
Ü	name : ID;
Ü	Sub_Ind
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type 'CONSTRAINT ÛSUBTYPE_DECLİ
=TYPESTRUCT
      = {
	name : ID,
	sub_ind : 'CONSTRAINT SUB_IND
	};
=TEX

\subsubsection{Constants}
Const\_Decl models constant declarations.

ÿConst_Decl[EXP]üüüüüüüüüüüüüüüüü
Ü	const : ID;
Ü	tm : TMARK;
Ü	expr : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

It is useful to keep a list of the constants declared in the same constant declaration for reproducability. The const component is therefore implemented as a list.
=SML
type 'EXP ÛCONST_DECLİ
=TYPESTRUCT
      = {
	consts : ID list,
	tm : TMARK,
	expr : 'EXP
	};
=TEX
Abstract syntax is also required for deferred constants.
=SML
type ÛDEFERRED_CONST_DECLİ
=TYPESTRUCT
      = {
	consts : ID list,
	tmark : TMARK
	};
=TEX

\subsubsection{Type Definition for Basic Declarations}
¹Z
BASIC_DECL ::= const_decl Const_Decl | type_decl Type_Decl |
		subtype_decl Subtype_Decl
°

The datatype for BASIC\_DECL is declared with other datatypes co-recursively with EXP in section \ref{TypeDefExpr}.
A type constructor is also required for deferred constants and for variable declarations.
\subsection{Expressions}
\subsubsection{Aggregates}
Agg\_Pos is a positional array or record aggregate.

ÿAgg_Pos[EXP]üüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	comps : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüü

Does the fact that there is only one type mark mean that all the components have to have the same type?
=SML
type ('EXP) ÛAGG_POSİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	comps : 'EXP list
	};
=TEX

Agg\_Pos\_Others is a positional array with an others part.

ÿOthers[EXP]üüüüüüüüüüüüüüüüü
Ü	others : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛOTHERSİ
=TYPESTRUCT
      = {
	others : 'EXP
	};
=TEX

ÿAgg_Pos_Othersüüüüüüüüüüüüüüüüü
Ü	Agg_Pos;
Ü	Others
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type 'EXP ÛAGG_POS_OTHERSİ
=TYPESTRUCT
      = {
	agg_pos : 'EXP AGG_POS,
	others : 'EXP OTHERS
	};
=TEX

Agg\_Others is an array aggregate with just an others part.

ÿAgg_Othersüüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	Others
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type 'EXP ÛAGG_OTHERSİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	others : 'EXP OTHERS
	};
=TEX

Agg\_Choice is an aggregate choice with terms separated by ``|''.

¹Z
Ü	AGG_CHOICE ::=
Ü		agg_choice_range Range | agg_choice_single EXP
°


A discrete range can be a type mark with an optional range constraint. The abstract syntax is modified to cover this.
=SML
type 'EXP ÛDISCRETE_RANGE_CONSTRAINEDİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	range : 'EXP RANGE
	};
=TEX
The datatype for DISCRETE RANGE is declared in section \ref{TypeDefExpr}.

The datatype for AGG\_CHOICE is declared with other datatypes co-recursively with EXP in section \ref{TypeDefExpr}.

Agg\_Named models a named array aggregate.

ÿNamed_Assoc[EXP]üüüüüüüüüüüüüüüüü
Ü	choices : ğ AGG_CHOICE;
Ü	comp : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('AGG_CHOICE, 'EXP) ÛNAMED_ASSOCİ
=TYPESTRUCT
      = {
	choice : 'AGG_CHOICE list,
	comp : 'EXP
	};
=TEX

ÿAgg_Namedüüüüüüüüüüüüüüüüü
Ü	named_assocs : ğ Named_Assoc
ˆüüüüüüüüüüüüüüüüüüüüü

Why doesn't the following have a type mark?
=SML
type ('AGG_CHOICE, 'EXP) ÛAGG_NAMEDİ
=TYPESTRUCT
      = {
	named_assocs : ('AGG_CHOICE, 'EXP) NAMED_ASSOC list
	};
=TEX

Agg\_Named\_Others is a named array aggregate with an others part.

ÿAgg_Named_Othersüüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	Agg_Named;
Ü	Others
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('AGG_CHOICE, 'EXP) ÛAGG_NAMED_OTHERSİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	agg_named : ('AGG_CHOICE, 'EXP) AGG_NAMED, 
	others : ('EXP) OTHERS
	};
=TEX

Rec\_Agg\_Named is a named record aggregate. (Positional record aggregates are modelled by Agg\_Pos at the start of this section). The type of named assocs is replaced with that used in named array aggregates.

ÿRec_Agg_Named[EXP]üüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	named_assocs : ğ (ID ¸ EXP)
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('AGG_CHOICE,'EXP) ÛREC_AGG_NAMEDİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	named_assocs : ('AGG_CHOICE, 'EXP) NAMED_ASSOC list
	};
=TEX

\subsubsection{Qualified Expressions}

The following implements abstract syntax for a qualified expression.

=SML
type 'EXP ÛQUALIFIED_EXPRESSIONİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	exp : 'EXP
	};
=TEX

\subsubsection{Unary Operations}

¹Z
Ü	UNARY_OP ::=
Ü	spark_unary_add | spark_unary_minus | spark_not | spark_abs
°

=SML
datatype ÛUNARY_OPİ =
			ÛUOSparkUnaryAddİ
		|	ÛUOSparkUnaryMinusİ
		|	ÛUOSparkNotİ
		|	ÛUOSparkAbsİ;
=TEX


ÿUnary_Exp[EXP]üüüüüüüüüüüüüüüüü
Ü	op : UNARY_OP;
Ü	right : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛUNARY_EXPİ
=TYPESTRUCT
      = {uop : UNARY_OP, right : 'EXP};
=TEX


\subsubsection{Binary Expressions}

¹Z
Ü	BIN_OP ::=
Ü	spark_and | spark_or | spark_xor | spark_eq | spark_noteq |
Ü	spark_less | spark_less_eq | spark_greater | spark_greater_eq |
Ü	spark_add | spark_minus | spark_times | spark_intdiv |
Ü	spark_mod | spark_rem | spark_expon | spark_mem | spark_notmem
°

The binary operators $BOSparkAndThen$, $BOSparkOrElse$ and $BOSparkConcat$ have been added.
=SML
datatype ÛBIN_OPİ =
			ÛBOSparkAndİ | ÛBOSparkAndThenİ
		|	ÛBOSparkOrİ | ÛBOSparkOrElseİ | ÛBOSparkXorİ
		|	ÛBOSparkEqİ | ÛBOSparkNotEqİ
		|	ÛBOSparkLessİ | ÛBOSparkLessEqİ
		|	ÛBOSparkGreaterİ | ÛBOSparkGreaterEqİ
		|	ÛBOSparkAddİ | ÛBOSparkMinusİ | ÛBOSparkTimesİ
		|	ÛBOSparkIntdivİ | ÛBOSparkModİ | ÛBOSparkRemİ
		|	ÛBOSparkExponİ
		|	ÛBOSparkMemİ | ÛBOSparkNotmemİ
		|	ÛBOSparkConcatİ;
=TEX

ÿBin_Exp[EXP]üüüüüüüüüüüüüüüüü
Ü	op : BIN_OP;
Ü	left, right : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type 'EXP ÛBIN_EXPİ
=TYPESTRUCT
      = {
	bop : BIN_OP,
	left : 'EXP,
	right : 'EXP
	};
=TEX

Mem\_Range is the membership (or non-membership) of a range.

¹Z
Ü	MEM_OP ¦ {spark_mem, spark_nonmem}
°

=SML
type ÛMEM_OPİ
=TYPESTRUCT
	= BIN_OP;
=TEX

ÿMem_Range[EXP]üüüüüüüüüüüüüüüüü
Ü	left : EXP;
Ü	op : MEM_OP;
Ü	Range
ˆüüüüüüüüüüüüüüüüüüüüü


=SML
type ('EXP) ÛMEM_RANGEİ
=TYPESTRUCT
      = {
	left : 'EXP,
	mop : MEM_OP,
	range : 'EXP RANGE
	};
=TEX


\subsubsection{Attributes}
Attribute models Ada attributes.

ATTRIB are the attribute designators FIRST, LAST, SUCC, PRED, POS, VAL, LENGTH and RANGE.

¹ZAX
Ü	fst, lst, suc, pred, pos, val, length, range : ID
°

¹Z
Ü	ATTRIB ¦ {fst, lst, suc, pred, pos, val, length, range}
°

=SML
type ÛATTRIBİ
=TYPESTRUCT
	= ID;
=TEX

ATTRIB\_DESIG models the attribute designators.

¹Z
Ü	ATTRIB_DESIG ::=
Ü		attrib (ATTRIB) | attrib_arg (ATTRIB ¸ EXP)
°
The datatype for ATTRIB DESIG is declared in section \ref{TypeDefExpr}.

ÿAttributeüüüüüüüüüüüüüüüüü
Ü	prefix : ID;
Ü	attribute_desig : ATTRIB_DESIG
ˆüüüüüüüüüüüüüüüüüüüüü

The prefix can in fact be a name (i.e., an expression).
=SML
type ('EXP,'ATTRIB_DESIG) ÛATTRIBUTEİ
=TYPESTRUCT
      = {
	prefix : 'EXP,
	attribute_desig : 'ATTRIB_DESIG
	};
=TEX

\subsubsection{Indexed Component}
Indexed\_Comp is an array component.

ÿIndexed_Comp[EXP]üüüüüüüüüüüüüüüüü
Ü	prefix, index : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛINDEXED_COMPİ
=TYPESTRUCT
      = {
	prefix : 'EXP,
	index : 'EXP
	};
=TEX

\subsubsection{Selected Component}
Selected\_Comp is a record component.

ÿSelected_Comp[EXP]üüüüüüüüüüüüüüüüü
Ü	prefix : EXP;
Ü	selector : ID
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛSELECTED_COMPİ
=TYPESTRUCT
      = {
	prefix : 'EXP,
	selector : ID
	};
=TEX

\subsubsection{Function Calls}
Fun\_Call is a function call.

ÿFun_Call[EXP]üüüüüüüüüüüüüüüüü
Ü	fun_name : ID;
Ü	args : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛFUN_CALLİ
=TYPESTRUCT
      = {
	fun_name : ID,
	args : 'EXP list
	};
=TEX

\subsubsection{Integer Literals}
INT\_LIT are the integer literals.

¹Z
Ü	[INT_LIT]
°

=SML
type ÛINT_LITİ
=TYPESTRUCT
	= string;
=TEX

\subsubsection{Auxiliary Expressions}
In the Compliance Notation, a SPARK expression can also be a Z expression (auxiliary expression).

¹Z
Ü	[Z_EXP]
°

=SML
type Z_EXP
=TYPESTRUCT
	= TERM;
=TEX

\subsubsection{Type Definition for Expressions}\label{TypeDefExpr}

¹Z
Ü	EXP ::=	
Ü		Id ID | int INT_LIT | array_agg_pos Agg_Pos |
Ü		array_agg_pos_others Agg_Pos_Others |
Ü		array_agg_others Agg_Others |
Ü		array_agg_named Agg_Named |
Ü		array_agg_named_others Agg_Named_Others |
Ü		rec_agg_pos Agg_Pos | rec_agg_named Rec_Agg_Named |
Ü		unary_exp Unary_Exp | bin_exp Bin_Exp |
Ü		mem_range Mem_Range | attribute Attribute |
Ü		indexed_comp Indexed_Comp |
Ü		selected_comp Selected_Comp |
Ü		fun_call Fun_Call |
Ü		auxiliary_exp Z_EXP
°

=SML
datatype ÛTYPE_DEFİ =
			ÛTDEnumTypeDefİ of ENUM_TYPE_DEF
		|	ÛTDIntTypeDefİ of EXP RANGE
		|	ÛTDFloatingTypeDefİ of EXP FLOATING_TYPE_DEF
		|	ÛTDFixedTypeDefİ of EXP FIXED_TYPE_DEF
		|	ÛTDUnconArrayDefİ of ARRAY_DEF
		|	ÛTDConArrayDefİ of ARRAY_DEF
		|	ÛTDRecordTypeDefİ of COMPONENT RECORD_TYPE_DEF
		|	ÛTDPrivateTypeDefİ of PRIVATE_TYPE_DEF
=TEX
=SML
and ÛCONSTRAINTİ =
			ÛCRangeİ of EXP RANGE
		|	ÛCFloatingİ of EXP FLOATING_POINT_CONSTRAINT
		|	ÛCFixedİ of EXP FIXED_POINT_CONSTRAINT
=TEX
=SML
and ÛBASIC_DECLİ =
			ÛBDConstDeclİ of (EXP) CONST_DECL
		|	ÛBDDeferredConstDeclİ of DEFERRED_CONST_DECL
		|	ÛBDTypeDeclİ of (TYPE_DEF) TYPE_DECL
		|	ÛBDVarDeclİ of VAR_DECL
		|	ÛBDSubtypeDeclİ of (CONSTRAINT) SUBTYPE_DECL
=TEX
=SML
and ÛDISCRETE_RANGEİ =
			ÛDRRangeİ of EXP RANGE
		|	ÛDRConstrainedİ of EXP DISCRETE_RANGE_CONSTRAINED
=TEX
=SML
and ÛAGG_CHOICEİ =
			ÛACAggChoiceRangeİ of DISCRETE_RANGE
		|	ÛACAggChoiceSingleİ of EXP
=TEX
=SML
and ÛATTRIB_DESIGİ =
			ÛADAttribİ of ATTRIB
		|	ÛADAttribArgİ of (ATTRIB * EXP)
=TEX
In order to reproduce the SPARK program as the user entered it, it is necessary to store bracketing information in the abstract syntax. Also string and character literals have been added.
=SML
and ÛEXPİ =
		ÛEIdİ of ID
	|	ÛEIntİ of INT_LIT
	|	ÛEArrayAggPosİ of EXP AGG_POS
	|	ÛEArrayAggPosOthersİ of EXP AGG_POS_OTHERS
	|	ÛEArrayAggOthersİ of EXP AGG_OTHERS
	|	ÛEArrayAggNamedİ of (AGG_CHOICE,EXP) AGG_NAMED
	|	ÛEArrayAggNamedOthersİ of (AGG_CHOICE,EXP) AGG_NAMED_OTHERS
	|	ÛERecAggPosİ of EXP AGG_POS
	|	ÛERecAggNamedİ of (AGG_CHOICE,EXP) REC_AGG_NAMED
	|	ÛEUnaryExpİ of EXP UNARY_EXP
	|	ÛEBinExpİ of EXP BIN_EXP
	|	ÛEMemRangeİ of EXP MEM_RANGE
	|	ÛEAttributeİ of (EXP,ATTRIB_DESIG) ATTRIBUTE
	|	ÛEIndexedCompİ of EXP INDEXED_COMP
	|	ÛESelectedCompİ of EXP SELECTED_COMP
	|	ÛEFunCallİ of EXP FUN_CALL
	|	ÛEAuxiliaryExpİ of Z_EXP
	|	ÛEQualifiedExpİ of EXP QUALIFIED_EXPRESSION
	|	ÛEBracketedİ of EXP
	|	ÛEStringLiteralİ of string
	|	ÛECharacterLiteralİ of string;
=TEX


\subsection{Statements}

The Z specification of the abstract syntax uses a given set declaration to act as a forward declaration of the free type $Stmt$, permitting the free type to involve recursion through schema constructions.
Unfortunately, this style is not considered to be type correct in \ProductZ; this is readily circumvented by making the schema constructions generic where necessary.
For example, see section \ref{if-then-else} below.

Following this convention we may now work through the abstract syntax for SPARK statements following \cite{DRA/CIS/CSE3/SWI/WP/1/3}.

\subsubsection{Assignment}\label{assignment}

ÿAssignüüüüüüüüüüüüüüüüü
Ü	name, E : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ÛASSIGNİ
=TYPESTRUCT
      = {
	name : EXP,
	e : EXP
	};
=TEX

\subsubsection{Specification Statements}

¹ZAX
Ü	Z_PRED‰0 : ğ Z_PRED
°

=SML
type ÛZ_PREDİ
=TYPESTRUCT
	= TERM;
=SML
type ÛZ_PRED‰0İ
=TYPESTRUCT
	= Z_PRED;
=SML
type ÛZ_IDİ
=TYPESTRUCT
	= ID;
=TEX

ÿSpecüüüüüüüüüüüüüüüüü
Ü	w, w‰0 : ğ Z_ID;
Ü	Pre, post : Z_PRED
÷üüüüüüüüüüüüüüü
Ü	Pre  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü

ÿSpec_No_Ivarsüüüüüüüüüüüü
Ü	Spec
÷üüüüüüüüüüüüüüü
Ü	post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü
=TEX
In the translation into Standard ML of a schema which includes another,
we have various choices.
In this simple case where the new schema has the same signature as the included one, we just say that the new type is an abbreviation for the old one.

Additionally Label is stored with the abstract syntax of the specification statement.
=SML
datatype ÛLABELİ =
			ÛLExplicitİ of string
		|	ÛLImplicitİ;
=TEX
=SML
type ÛSPECİ
=TYPESTRUCT
      = {
	w : Z_ID list,
	w0 : Z_ID list,
	pre : Z_PRED,
	post : Z_PRED,
	label : LABEL
	};
=TEX
=SML
type ÛSPEC_NO_IVARSİ
=TYPESTRUCT
	= SPEC;
=TEX
\subsubsection{If-then-else}\label{if-then-else}

¹ZAX
Ü	COND : ğ EXP
°

ÿIf_Then_Else[STMT]üüüüüüüüüüüüüüüüü
Ü	G : COND;
Ü	P, Q : STMT
ˆüüüüüüüüüüüüüüüüüüüüü

In an nested if statement 

=GFT SPARK Fragment
IF	<cond>	THEN	<stmt>; END IF;
ELSIF	<cond>	THEN	<stmt>; END IF;
...
ELSIF	<cond>	THEN	<stmt>;
END IF;
=TEX
is equivalent to
=GFT SPARK Fragment
IF	<cond>	THEN	<stmt>;
ELSE IF	<cond>	THEN	<stmt>; 
...
ELSE IF	<cond>	THEN	<stmt>; END IF; ... END IF;
END IF;
=TEX
I.e., ELSIF is the same as writing ELSEIF. In order to make the input reproducable in the SPARK program to be generated, a flag is stored with each abstract representation of the if statement indicating whether the else condition was input as an ELSIF or not.
=SML
type ÛCONDİ
=TYPESTRUCT
	= EXP;
=SML
type ('STMT) ÛIF_THEN_ELSEİ
=TYPESTRUCT
      = {
	g : COND,
	p : 'STMT,
	q : 'STMT,
	elsif : bool
	};
=TEX
\subsubsection{Case}\label{case}

¹Z
Ü	CASE_CHOICE ::= case_exp EXP | case_range Range
°

The case choice can be a discrete range.
=SML
datatype ÛCASE_CHOICEİ =
				ÛCCCaseExpİ of EXP
			|	ÛCCCaseRangeİ of DISCRETE_RANGE;
=TEX

ÿCase_Alternative[STMT]üüüüüüüüüüüüüüüüü
Ü	choices : ğ CASE_CHOICE;
Ü	P : STMT
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
ÿCaseüüüüüüüüüüüüüüüüü
Ü	E : EXP;
Ü	s : seq‰1 Case_Alternative
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

A Case statement can have an others part.
=SML
type 'STMT ÛCASE_ALTERNATIVEİ
=TYPESTRUCT
      = {
	choices : CASE_CHOICE list,
	p : 'STMT
	};
=TEX
=SML
type 'STMT ÛCASEİ
=TYPESTRUCT
      = {
	e : EXP,
	s : ('STMT) CASE_ALTERNATIVE list,
	others : 'STMT
	};
=TEX
\subsubsection{Loop}\label{loop}

ÿLoopüüüüüüüüüüüüüüüüü
Ü	T : Z_PRED;
Ü	Spec_No_Ivars
÷üüüüüü
Ü	T  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
As with the translation of $Spec\_No\_Ivars$, we have a choice of how to translate the schema inclusion.
This case is a little more complicated, however, but as there is no overlap between the signature of the included schema and other signature variables, we can adopt the following simple translation.

The till clause may not be present in which case the t component will be true. However we make t optional to reflect the concrete syntax so that the SPARK program can be reproduced authentically.

A loop body may be a sequence of statements in which case the treatment of the loop can only be informal with respect to generating verification conditions.
A loop without an iteration scheme can have a name, so we introduce an additional type called NAMED\_LOOP.
=SML
type 'STMT ÛLOOPİ
=TYPESTRUCT
      = {
	t : Z_PRED OPT,
	stmt : 'STMT
	};
=TEX
=SML
type 'STMT ÛNAMED_LOOPİ
=TYPESTRUCT
      = {
	name : ID,
	t : Z_PRED OPT,
	stmt : 'STMT
	};
=TEX

\subsubsection{While Loop}\label{while-loop}
ÿWhileüüüüüüüüüüüüüüüüü
Ü	G : COND;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

Loops can have names, so a name is introduced into the abstract representation.
=SML
type 'STMT ÛWHILEİ
=TYPESTRUCT
      = {
	name : ID OPT,
	g : COND,
	loop : 'STMT LOOP
	};
=TEX
\subsubsection{For Loop (Values as Bounds)}\label{for-static}

¹ZAX
Ü	STATIC_EXP : ğ EXP
°

ÿFor_Staticüüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	lo, hi : STATIC_EXP;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

Loops can have names so a field in the abstract representation is reserved for name. Also we record in the abstract syntax the direction of the loop and the type mark for the purposes of reproducing the SPARK program.

=SML
type ÛSTATIC_EXPİ
=TYPESTRUCT
	= EXP;
=SML
datatype ÛLOOP_DIRECTIONİ =
				ÛLDForwardsİ
			|	ÛLDReverseİ;
=TEX
Also, if the range is denoted by an attribute, then the range attribute is stored in the $lo$ component. The $hi$ component is therefore optional and its absence denotes that the $lo$ component denotes a range attribute.
=SML
type 'STMT ÛFOR_STATICİ
=TYPESTRUCT
      = {
	name : ID OPT,
	i : ID,
	tmark : ID,
	lo : STATIC_EXP,
	hi : STATIC_EXP OPT,
	dir : LOOP_DIRECTION,
	loop : 'STMT LOOP
	};
=TEX
\subsubsection{For Loop (Type Mark as Range)}\label{for-typemark}

ÿFor_Tmarküüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	tmark : TMARK;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

FOR\_TMARK is augmented in the same way as for FOR\_STATIC.

=SML
type 'STMT ÛFOR_TMARKİ
=TYPESTRUCT
      = {
	name : ID OPT,
	i : ID,
	tmark : TMARK,
	dir : LOOP_DIRECTION,
	loop : 'STMT LOOP
	};
=TEX
\subsubsection{Exit}\label{exit}

ÿExit_Whenüüüüüüüüüüüüüüüüü
Ü	G : COND
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=SML
type ÛEXIT_WHENİ
=TYPESTRUCT
      = {
	g : COND
	};
=TEX
\subsubsection{Return}\label{return}

ÿReturnüüüüüüüüüüüüüüüüü
Ü	E : EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=SML
type ÛRETURNİ
=TYPESTRUCT
      = {
	e : EXP
	};
=TEX
\subsubsection{Procedure Call}\label{procedure-call}

ÿProc_Callüüüüüüüüüüüüüüüüü
Ü	name : ID;
Ü	actuals : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
The actual part can be a positional parameter association or a named parameter association.

=SML
datatype ('AGG_CHOICE, 'EXP) ÛACTUALSİ =
			ÛAPositionalİ of EXP list
		|	ÛANamedİ of ('AGG_CHOICE, 'EXP) NAMED_ASSOC list;
=TEX
=SML
type ('AGG_CHOICE,'EXP) ÛPROC_CALLİ
=TYPESTRUCT
      = {
	name : ID,
	actuals : ('AGG_CHOICE,'EXP) ACTUALS
	};
=TEX

¹ZAX
Ü	retrieve_spec_stmt : ID ß Spec
°

ÿProc_Call_No_Ivarsüüüüüüüüüüüüüüüüü
Ü	Proc_Call
÷üüüüüüüüüüüüüüüü
Ü	(retrieve_spec_stmt name).post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=SML
type ('AGG_CHOICE,'EXP) ÛPROC_CALL_NO_IVARSİ
=TYPESTRUCT
	= ('AGG_CHOICE,'EXP) PROC_CALL;
=TEX
\subsubsection{$Stmt$}\label{stmt}
\ProductZ\ is currently non-standard in that it neither requires nor
allows the chevrons around the operands in a free type definition.
This mismatch with the Z standard is planned to be remedied in a future release of the system.
¹Z
	Stmt	::= 	null
		|	assign Assign
		|	spec_no_ivars Spec_No_Ivars
		|	semicolon (Stmt ¸ Stmt)
		|	if_then_else If_Then_Else
		|	case Case
		|	loop Loop
		|	while While
		|	for_static For_Static
		|	for_tmark For_Tmark
		|	exit_when Exit_When
		|	exit
		|	ret Return
		|	proc_no_ivars Proc_Call_No_Ivars
°
=TEX
KSLots are required in the abstract syntax as place markers so that when the SPARK program is reproduced from the abstract syntax, the expansions can be put back into the correct places.
=SML
type ÛK_SLOTİ
=TYPESTRUCT
      = {
	content : string,
	label : LABEL
	};
=TEX
=SML
datatype ÛSTMTİ	= 	ÛSTNullİ
		| 	ÛSTImplicitNullİ
		|	ÛSTAssignİ of ASSIGN
		|	ÛSTSpecNoIvarsİ of SPEC_NO_IVARS
		|	ÛSTSemicolonİ of (STMT * STMT)
		|	ÛSTIfThenElseİ of  STMT IF_THEN_ELSE
		|	ÛSTCaseİ of STMT CASE
		|	ÛSTLoopİ of STMT LOOP
		|	ÛSTNamedLoopİ of STMT NAMED_LOOP
		|	ÛSTWhileİ of STMT WHILE
		|	ÛSTForStaticİ of STMT FOR_STATIC
		|	ÛSTForTmarkİ of STMT FOR_TMARK
		|	ÛSTExitWhenİ of EXIT_WHEN
		|	ÛSTExitİ
		|	ÛSTRetİ of RETURN
		|	ÛSTProcNoIvarsİ of (AGG_CHOICE,EXP) PROC_CALL_NO_IVARS
		|	ÛSTKSlotİ of K_SLOT;
=TEX
\pagebreak
\subsubsection{Specification (with initial variables)}\label{specification-ivars}

ÿSpec_Ivarsüüüüüüüüüüüü
Ü	Spec
÷üüüüüüüüüüüüüüü
Ü	post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü
=TEX
=SML
type ÛSPEC_IVARSİ 
=TYPESTRUCT
	= SPEC;
=TEX
\subsubsection{For Loop (Non-Static Bounds)}\label{for-non-static-bounds}

ÿFor_Non_Staticüüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	lo, hi : EXP;
Ü	Loop
÷üüüüüüüüüüüüüüüü
Ü		lo  STATIC_EXP
Ü	²
Ü		hi  STATIC_EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
A loop may have an optional name. 
Also, if the range is denoted by an attribute, then the range attribute is stored in the $lo$ component. The $hi$ component is therefore optional and its absence denotes that the $lo$ component denotes a range attribute.

=SML
type ÛFOR_NON_STATICİ
=TYPESTRUCT
      = {
	name : ID OPT,
	i : ID,
	lo : STATIC_EXP,
	hi : STATIC_EXP OPT,
	loop : STMT LOOP
	};
=TEX
\subsubsection{Logical Constants}\label{logical-constants}
¹ZAX
Ü	free_ids : Z_EXP ­ ğ Z_ID
°

ÿLog_Conüüüüüüüüüüüü
Ü	X : Z_ID;
Ü	E : Z_EXP;
Ü	Spec;
Ü	pre‰1 : Z_PRED
÷üüüüüüüüüüüüüüü
Ü	Pre = z_and(z_eq(zid X, E), pre‰1);
Ü	X  free_ids E
ˆüüüüüüüüüüüüüüüüüüüüü
=TEX
The functions $free\_id$ may readily and reallistically be implemented using existing \Product\
syntax functions.
=SML
type ÛLOG_CONİ
=TYPESTRUCT
      = {
	x : Z_ID,
	e : Z_EXP,
	spec : SPEC,
	pre1 : Z_PRED
	};
=TEX
\subsubsection{Procedure Calls}\label{procedure-calls}
ÿProc_Call_Ivarsüüüüüüüüüüüü
Ü	Proc_Call
÷üüüüüüüüüüüüüüü
Ü	(retrieve_spec_stmt name).post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('AGG_CHOICE,'EXP) ÛPROC_CALL_IVARSİ
=TYPESTRUCT
	= ('AGG_CHOICE,'EXP) PROC_CALL;
=TEX

\subsubsection{Statement}\label{statement}
¹Z
	Statement
		::= 	stmt Stmt
		|	spec_ivars (Spec_Ivars ¸ Stmt)
		|	for_non_static (For_Non_Static ¸ Stmt)
		|	log_con (Log_Con ¸ Stmt)
		|	proc_ivars (Proc_Call_Ivars ¸ Stmt)
°
=TEX
=SML
datatype ÛSTATEMENTİ =
		 	ÛSStmtİ of STMT
		|	ÛSSpecIvarsİ of (SPEC_IVARS * STMT)
		|	ÛSForNonStaticİ of (FOR_NON_STATIC * STMT)
		|	ÛSLogConİ of (LOG_CON * STMT)
		|	ÛSProcIvarsİ of ((AGG_CHOICE,EXP) PROC_CALL_IVARS * STMT);
=TEX

\subsection{Subprogram Declarations}
=SML
datatype ÛMODEİ =	MSparkIn
		|	MSparkOut
		|	MSparkInOut;
=TEX
=SML
type ÛPARAMETER_SPECIFICATIONİ
=TYPESTRUCT
      = {
	idlist : ID list,
	mode : MODE,
	name : TMARK
	};
=TEX
=SML
type ÛPROCEDURE_SPECIFICATIONİ
=TYPESTRUCT
      = {
	name : ID,
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT
	};
=TEX
=SML
type ÛFUNCTION_SPECIFICATIONİ
=TYPESTRUCT
      = {
	designator : ID,
	return : TMARK,
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT
	};
=TEX
=SML
datatype ÛSUBPROGRAM_SPECIFICATIONİ =
			ÛSSProcedureİ of PROCEDURE_SPECIFICATION
		|	ÛSSFunctionİ of FUNCTION_SPECIFICATION;
=TEX
=SML
type ÛPROCEDURE_DECLARATIONİ
=TYPESTRUCT
	= PROCEDURE_SPECIFICATION;
=TEX
=SML
type ÛFUNCTION_DECLARATIONİ
=TYPESTRUCT
	= FUNCTION_SPECIFICATION;
=TEX
=SML
type ÛSUBPROGRAM_DECLARATIONİ
=TYPESTRUCT
	= SUBPROGRAM_SPECIFICATION;
=TEX
\subsection{Subprogram Bodies}
\subsection{Procedure and Function Calls}
=SML
type ÛNAMED_PARAMİ
=TYPESTRUCT
      = {
	formal : ID,
	actual : EXP
	};
=TEX
=SML
type ÛNAMED_PARAMETER_ASSOCİ
=TYPESTRUCT
      = {
	params: NAMED_PARAM list
	};
=TEX
=SML
type ÛPOS_PARAMETER_ASSOCİ
=TYPESTRUCT
      = {
	params : EXP list
	};
=TEX
=SML
datatype ÛACTUAL_PARAMETER_PARTİ = 
			ÛAPPNamedİ of NAMED_PARAMETER_ASSOC
		|	ÛAPPPositionalİ of POS_PARAMETER_ASSOC;
=TEX
\subsection{Package Declaration}
=SML
type ÛOPERATOR_SYMBOLİ
=TYPESTRUCT
	= string;
=TEX
=SML
type ÛFUNCTION_RENAMINGİ
=TYPESTRUCT
      = {
	opsym1 : OPERATOR_SYMBOL,
	formal_part : PARAMETER_SPECIFICATION list,
	tmark : TMARK,
	name : ID,
	opsym2 : OPERATOR_SYMBOL
	};
=TEX
=SML
type ÛSUBPROGRAM_RENAMINGİ
=TYPESTRUCT
      = {
	subprogram_specification : SUBPROGRAM_SPECIFICATION,
	name1 : ID,
	name2 : ID
	};
=TEX
=SML
datatype ÛRENAMING_DECLARATIONİ =
			ÛRDFunctionİ of FUNCTION_RENAMING
		|	ÛRDSubprogramİ of SUBPROGRAM_RENAMING;
=TEX
=SML
type ÛLENGTH_CLAUSEİ
=TYPESTRUCT
      = {
	attribute : EXP,
	exp : EXP
	};
=TEX
=SML
type ÛENUMERATION_REPRESENTATION_CLAUSEİ
=TYPESTRUCT
      = {
	name : ID,
	exp : EXP
	};
=TEX
=SML
type ÛCOMPONENT_CLAUSEİ
=TYPESTRUCT
      = {
	name : EXP,
	exp : EXP,
	range : EXP RANGE
	};
=TEX
=SML
type ÛRECORD_REPRESENTATION_CLAUSEİ
=TYPESTRUCT
      = {
	name : ID,
	alignment_opt : EXP OPT,
	component_pack : COMPONENT_CLAUSE list
	};
=TEX
=SML
type ÛADDRESS_CLAUSEİ
=TYPESTRUCT
      = {
	name : ID,
	exp : EXP
	};
=TEX
=SML
datatype ÛREPRESENTATION_CLAUSEİ =
			ÛRCLengthİ of LENGTH_CLAUSE
		|	ÛRCEnumerationİ of ENUMERATION_REPRESENTATION_CLAUSE
		|	ÛRCRecordİ of RECORD_REPRESENTATION_CLAUSE
		|	ÛRCAddressİ of ADDRESS_CLAUSE;
=TEX
=SML
type 'DECLARATION ÛPROCEDURE_BODYİ
=TYPESTRUCT
      = {
	procedure_spec : PROCEDURE_SPECIFICATION,
	declarative_part : 'DECLARATION list,
	statement : STATEMENT
	};
=TEX
=SML
type 'DECLARATION ÛFUNCTION_BODYİ
=TYPESTRUCT
      = {
	function_spec : FUNCTION_SPECIFICATION,
	declarative_part : 'DECLARATION list,
	statement : STATEMENT
	};
=TEX
=SML
type 'DECLARATION ÛPACKAGE_BODYİ
=TYPESTRUCT
      = {
	name : ID,
	decls : 'DECLARATION list,
	statement : STATEMENT
	};
=TEX
=SML
type 'DECLARATION ÛPACKAGE_DECLARATIONİ
=TYPESTRUCT
      = {
	name : ID,
	visible_decs : 'DECLARATION list,
	private_decs : 'DECLARATION list
	};

=TEX
=SML
datatype ÛDECLARATIONİ =
			ÛDDeclarationKSlotİ of K_SLOT
		|	ÛDRenamingDeclarationİ of RENAMING_DECLARATION
		|	ÛDBasicDeclİ of BASIC_DECL
		|	ÛDRepresentationClauseİ of REPRESENTATION_CLAUSE
		|	ÛDProperBodyİ of PROPER_BODY
		|	ÛDProcedureDeclarationİ of PROCEDURE_DECLARATION
		|	ÛDFunctionDeclarationİ of FUNCTION_DECLARATION
		|	ÛDPackageDeclarationİ of DECLARATION PACKAGE_DECLARATION
		|	ÛDProcedureStubİ of PROCEDURE_DECLARATION
		|	ÛDFunctionStubİ of FUNCTION_DECLARATION
		|	ÛDPackageStubİ of ID
=TEX
=SML
and ÛPROPER_BODYİ =	ÛPBProcedureİ of DECLARATION PROCEDURE_BODY
		|	ÛPBFunctionİ of DECLARATION FUNCTION_BODY
		|	ÛPBPackageİ of DECLARATION PACKAGE_BODY;
=TEX

=TEX
=SML
type ÛSUBUNITİ
=TYPESTRUCT
      = {
	name : EXP,
	proper_body : PROPER_BODY
	};
=TEX
=SML
datatype ÛCOMPILATION_UNITİ =
			ÛCUPackageDeclarationİ of DECLARATION PACKAGE_DECLARATION
		|	ÛCUProperBodyİ of PROPER_BODY
		|	ÛCUSubUnitİ of SUBUNIT;

=TEX
=SML
type ÛREFINED_BYİ
=TYPESTRUCT
      = {
	label : LABEL,
	statement : STATEMENT
	};
=TEX
=SML
type ÛREPLACED_BYİ
=TYPESTRUCT
      = {
	label : LABEL,
	statement : STATEMENT
	};
=TEX
=SML
type ÛREPLACED_BY_DECLİ
=TYPESTRUCT
      = {
	label : LABEL,
	decls : DECLARATION list
	};
=TEX
=SML
type ÛREPLACED_BY_VISIBLE_PARTİ
=TYPESTRUCT
      = {
	label : LABEL,
	visible : DECLARATION list
	};
=TEX
=SML
type ÛREPLACED_BY_PRIVATE_PARTİ
=TYPESTRUCT
      = {
	label : LABEL,
	private : DECLARATION list
	};
=TEX
=SML
type ÛCONTEXT_COMPILATION_UNITİ
=TYPESTRUCT
      = {
	context : ID list,
	comp_unit : COMPILATION_UNIT
	};
=TEX
=SML
datatype ÛKSLOT_COMPILATION_UNITİ =
			ÛKCUKSlotİ of K_SLOT
		|	ÛKCUUnitİ of CONTEXT_COMPILATION_UNIT;
=TEX
=SML
type ÛREPLACED_BY_COMPİ
=TYPESTRUCT
      = {
	label : LABEL,
	comp : KSLOT_COMPILATION_UNIT list
	};
=TEX
=SML
datatype ÛWEB_CLAUSEİ = 
			ÛWCCompilationİ of KSLOT_COMPILATION_UNIT list
		|	ÛWCReplacedByCompilationİ of REPLACED_BY_COMP
		|	ÛWCReplacedByPrivatePartİ of REPLACED_BY_PRIVATE_PART
		|	ÛWCReplacedByVisiblePartİ of REPLACED_BY_VISIBLE_PART
		|	ÛWCReplacedByDeclİ of REPLACED_BY_DECL
		|	ÛWCRefinedByİ of REFINED_BY
		|	ÛWCReplacedByİ of REPLACED_BY;
=TEX
\section{EPILOGUE}

=SML
end (* of signature CNTypes *);
=TEX

=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



