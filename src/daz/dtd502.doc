%  dtd502.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Compliance Notation Lexis and Abstract Syntax}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD502}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan&WIN01}
\TPPabstract{
This document contains the detailed design for the lexis and abstract syntax for Compliance Notation}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion~\FormatDate{$Date$%
}) ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the abstract syntax for CN.

\subsection{Introduction}

\subsubsection{Purpose and Background}


\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{LEXIS}
=DOC
signature ÛCNTypesİ = sig
=DESCRIBE
This is the signature for the structure containing the types required for Compliance Notation.
=ENDDOC

=DOC
datatype ÛCN_LEX_CLASSİ
			= ÛLCAbstractExpressionİ
			| ÛLCAbsİ | ÛLCAmpersandİ | ÛLCAndİ | ÛLCArrayİ |ÛLCAtİ
			| ÛLCBarİ |ÛLCBBodyİ | ÛLCBecomesİ | ÛLCBeginİ
			| ÛLCCaseİ| ÛLCCharacterLiteralİ
			| ÛLCColonİ | ÛLCCommaİ | ÛLCCompLabelİ | ÛLCConstantİ
			| ÛLCConİ | ÛLCCrdİ | ÛLCDecLabelİ | ÛLCDeltaİ
			| ÛLCDigitsİ | ÛLCDivİ| ÛLCDotDotİ | ÛLCDotİ | ÛLCElseİ
			| ÛLCElsIfİ | ÛLCEndİ | ÛLCEqualsİ | ÛLCExitİ
			| ÛLCFatDotİ | ÛLCForİ | ÛLCFunctionNameİ | ÛLCFunctionİ
			| ÛLCGoesToİ | ÛLCGreaterEqualsİ
			| ÛLCGreaterThanİ | ÛLCIdentifierİ | ÛLCIfİ
			| ÛLCInİ | ÛLCIsİ
			| ÛLCKSlotİ | ÛLCLessEqualsİ | ÛLCLessGreatİ | ÛLCLessThanİ
			| ÛLCLimitedİ | ÛLCLoopİ | ÛLCMinusİ
			| ÛLCModİ | ÛLCNotEqualsİ | ÛLCNotİ | ÛLCNullİ
			| ÛLCNumericLiteralİ | ÛLCOfİ
			| ÛLCOrdİ | ÛLCOrİ | ÛLCOthersİ | ÛLCOutİ
			| ÛLCPackageİ | ÛLCPlusİ
			| ÛLCPPartLabelİ | ÛLCPrimeİ | ÛLCPrimedIdentifierİ
			| ÛLCPrivateİ | ÛLCProcedureNameİ | ÛLCProcedureİ
			| ÛLCRecordİ | ÛLCRefinedByİ | ÛLCRemİ
			| ÛLCRenamesİ | ÛLCReplacedByİ | ÛLCReturnİ
			| ÛLCReverseİ | ÛLCRRangeİ | ÛLCSemiİ
			| ÛLCSeparateİ | ÛLCSpecLabelİ | ÛLCStarStarİ
			| ÛLCStarİ | ÛLCStmtLabelİ
			| ÛLCStringLiteralİ | ÛLCSubTypeİ | ÛLCThenİ
			| ÛLCTillİ | ÛLCTypeMarkİ
			| ÛLCTypeİ | ÛLCUseİ | ÛLCVPartLabelİ
			| ÛLCWhenOthersİ | ÛLCWhenİ
			| ÛLCWhileİ | ÛLCWithİ | ÛLCXorİ | ÛLCEosİ
			| ÛLCZİ
			| ÛLCGrkDeltaİ | ÛLCLSqBrackİ | ÛLCRSqBrackİ
			| ÛLCLBraceİ | ÛLCRBraceİ | ÛLCLStracheyİ
			| ÛLCRStracheyİ | ÛLCLChevronİ | ÛLCRChevronİ;
=DESCRIBE
=ENDDOC

=DOC
datatype ÛCN_TOKENİ	=	ÛCNZİ of ZLex.Z_TOKEN list
			|	ÛCNTextİ of string
			|	ÛCNStringİ of string
			|	ÛCNKSlotİ of Lex.INPUT list
			|	ÛCNEosİ;
=DESCRIBE
=ENDDOC

=DOC
type ÛCN_LEX_ITEMİ
=DESCRIBE
=ENDDOC

\section{ABSTRACT SYNTAX}

=SMLZ
open_theory"z_library";
push_pc "z_library";
delete_theory"z_dtd502" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", true);
new_theory"z_dtd502";
=TEX

\subsection{Basic Declarations}
The Z specification of the abstract syntax uses a given set declaration to act as a forward declaration of the free type $EXP$, permitting the free type to involve recursion through schema constructions.
Unfortunately, this style is not considered to be type correct in \ProductZ; this is readily circumvented by making the schema constructions generic where necessary.


\subsubsection{Identifiers}

ID is the set of Ada Identifiers.

¹Z
Ü	[ID]
°

=SML
type ÛIDİ (* = string *);
=TEX

\subsubsection{Enumerated Types}
Enum\_Type\_Def models enumerated types.

ÿEnum_Type_Defüüüüüüüüüüüü
Ü	vals : seq ID
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ÛENUM_TYPE_DEFİ (* = {vals : ID list} *);
=TEX

\subsubsection{Type Marks}
TMARK is the set of type marks in the literate script.

¹ZAX
Ü	TMARK : ğ ID
°

=SML
type ÛTMARKİ (* = ID *);
=TEX

\subsubsection{Array Types}
Array\_Def models array types.

ÿArray_Defüüüüüüüüüüüü
Ü	index, comp : TMARK
ˆüüüüüüüüüüüüüüüüüüüüü

The index can be a list of type marks, so this is modelled below.
=SML
type ÛARRAY_DEFİ (* = {index : TMARK list, comp : TMARK} *);
=TEX

\subsubsection{Variable Declarations}
Var\_Decl is an Ada variable declaration.

ÿVar_Declüüüüüüüüüüüü
Ü	var : ID;
Ü	tmark : TMARK
ˆüüüüüüüüüüüüüüüüüüüüü

In order to maintain the reproducability of the input, it is necessary to include all the identifiers together in a VAR\_DECL.
=SML
type ÛVAR_DECLİ (* = {vars : ID list, tmark : TMARK} *);
=TEX
\subsubsection{Variants}
=SML
type ('COMP) ÛVARIANTİ (* = {
	ids : ID list,
	comp : 'COMP list
	} *);

type 'COMP ÛVARIANT_PARTİ (* = {
	id : ID,
	variants : 'COMP VARIANT list
	} *);

type 'COMP ÛDECLARATION_VARIANTİ (*= {
	decls : VAR_DECL list,
	variant : 'COMP VARIANT_PART
	} *);

datatype ÛCOMPONENTİ =
				ÛCDeclarationİ of VAR_DECL list
			|	ÛCVariantPartİ of COMPONENT VARIANT_PART
			|	ÛCDeclarationVariantİ of COMPONENT DECLARATION_VARIANT
			|	ÛCNoneİ;
=TEX


\subsubsection{Record Types}
Record\_Type\_Def models record types.

ÿRecord_Type_Defüüüüüüüüüüüü
Ü	decl : seq Var_Decl
ˆüüüüüüüüüüüüüüüüüüüüü

Record types can have variant records, so we use a different definition.
=SML
type 'COMP ÛRECORD_TYPE_DEFİ (* = {comps : 'COMP list} *);
=TEX

\subsubsection{Integer Types}

An integer type is characterised by its range.

ÿRange[EXP]üüüüüüüüüüüü
Ü	lo, hi : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

A range can be just a range attribute which can be represented by one expression. To support this, we use the lo to store the range attribute and make the hi optional. 
=SML
type ('EXP) ÛRANGEİ (* = {lo : 'EXP, hi : 'EXP OPT} *);
=TEX

\subsubsection{Real Types}
=SML
type 'EXP ÛFLOATING_POINT_CONSTRAINTİ (* = {
	exp : 'EXP,
	range : 'EXP RANGE OPT
	} *);

type 'EXP ÛFIXED_POINT_CONSTRAINTİ (* = 'EXP FLOATING_POINT_CONSTRAINT *);
=TEX

=SML
type 'EXP ÛFLOATING_TYPE_DEFİ (* = 'EXP FLOATING_POINT_CONSTRAINT *);
type 'EXP ÛFIXED_TYPE_DEFİ (* = 'EXP FIXED_POINT_CONSTRAINT *);
=TEX

\subsubsection{Private Types}
=SML
type ÛPRIVATE_TYPE_DEFİ (* = {
	id : ID,
	limited : bool} *);
	
=TEX
\subsubsection{Type Definitions}

TYPE\_DEF brings all the above type definitions together.

¹Z
TYPE_DEF ::= enum_type_def Enum_Type_Def | int_type_def (Range[EXP]) |
		uncon_array_def Array_Def | con_array_def Array_Def |
		record_type_def Record_Type_Def
°

The datatype for TYPE\_DEF is declared with other datatypes co-recursively with EXP in section \ref{TypeDefExpr}.

An additional constructor is provided for private types and for reals.
=GFT
datatype ÛTYPE_DEFİ =
			ÛTDEnumTypeDefİ of ENUM_TYPE_DEF
		|	ÛTDIntTypeDefİ of EXP RANGE
		|	ÛTDFloatingTypeDefİ of EXP FLOATING_TYPE_DEF
		|	ÛTDFixedTypeDefİ of EXP FIXED_TYPE_DEF
		|	ÛTDUnconArrayDefİ of ARRAY_DEF
		|	ÛTDConArrayDefİ of ARRAY_DEF
		|	ÛTDRecordTypeDefİ of RECORD_TYPE_DEF
		|	ÛTDPrivateTypeDefİ of PRIVATE_TYPE_DEF;
=TEX
\subsubsection{Type Declarations}
Type\_Decl is a type declaration, that is a type definition together with its name.

ÿType_Declüüüüüüüüüüüü
Ü	name : ID;
Ü	type_def : TYPE_DEF
ˆüüüüüüüüüüüüüüüüüüüüü

The optional discriminant part is required.
=SML
type DISCR_PART (* = VAR_DECL OPT *);
=TEX

=SML
type 'TYPE_DEF ÛTYPE_DECLİ (* = {name : ID, discr : VAR_DECL, type_def : 'TYPE_DEF} *);
=TEX

\subsubsection{SubTypes}
Subtype\_Decl models subtype declarations.

¹Z
CONSTRAINT ::= range_con (Range[EXP]) | index_con TMARK
°

The datatype for CONSTRAINT is declared with other datatypes co-recursively with EXP in section \ref{TypeDefExpr}.

A constraint can also be a fixed or a floating point constraint. The following changes remedy this.
=GFT
datatype ÛCONSTRAINTİ =
			ÛCRangeİ of EXP RANGE
		|	ÛCFloatingİ of EXP FLOATING_POINT_CONSTRAINT
		|	ÛCFixedİ of EXP FIXED_POINT_CONSTRAINT;
=TEX

Sub\_Ind is a subtype indication.

ÿSub_Indüüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	con : CONSTRAINT
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('CONSTRAINT) ÛSUB_INDİ (* = {tmark : TMARK, con : 'CONSTRAINT} *);
=TEX

ÿSubtype_Declüüüüüüüüüüüüüüüüü
Ü	name : ID;
Ü	Sub_Ind
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('CONSTRAINT) ÛSUBTYPE_DECLİ (* = {name : ID, sub_ind : ('CONSTRAINT) SUB_IND} *);
=TEX

\subsubsection{Constants}
Const\_Decl models constant declarations.

ÿConst_Decl[EXP]üüüüüüüüüüüüüüüüü
Ü	const : ID;
Ü	tm : TMARK;
Ü	expr : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

It is useful to keep a list of the constants declared in the same constant declaration for reproducability. The const component is therefore implemented as a list.
=SML
type ('EXP) ÛCONST_DECLİ (* = {consts : ID list, tm : TMARK, expr : 'EXP} *);
=TEX
Abstract syntax is also required for deferred constants.
=SML
type ÛDEFERRED_CONST_DECLİ (* = {consts : ID list, tmark : TMARK} *);
=TEX

\subsubsection{Type Definition for Basic Declarations}
¹Z
BASIC_DECL ::= const_decl (Const_Decl) | type_decl (Type_Decl) |
		subtype_decl (Subtype_Decl)
°

The datatype for BASIC\_DECL is declared with other datatypes co-recursively with EXP in section \ref{TypeDefExpr}.
A type constructor is also required for deferred constants and for variable declarations.
=GFT
datatype ÛBASIC_DECLİ =
			ÛBDConstDeclİ of CONST_DECL
		|	ÛBDDeferredConstDeclİ of DEFERRED_CONST_DECL
		|	ÛBDVarDeclİ of VAR_DECL
		|	ÛBDTypeDeclİ of TYPE_DECL
		|	ÛBDSubtypeDeclİ of SUBTYPE_DECL;
=TEX
\subsection{Expressions}
\subsubsection{Aggregates}
Agg\_Pos is a positional array or record aggregate.

ÿAgg_Pos[EXP]üüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	comps : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛAGG_POSİ (* = {tmark : TMARK, comps : 'EXP list} *);
=TEX

Agg\_Pos\_Others is a positional array with an others part.

ÿOthers[EXP]üüüüüüüüüüüüüüüüü
Ü	others : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛOTHERSİ (* = {others : 'EXP} *);
=TEX


ÿAgg_Pos_Othersüüüüüüüüüüüüüüüüü
Ü	Agg_Pos;
Ü	Others
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛAGG_POS_OTHERSİ
		(* = {agg_pos : ('EXP) AGG_POS, others : ('EXP) Others} *);
=TEX

Agg\_Others is an array aggregate with just an others part.

ÿAgg_Othersüüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	Others
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛAGG_OTHERSİ (* = {tmark : TMARK, others : ('EXP) OTHERS} *);
=TEX

Agg\_Choice is an aggregate choice with terms separated by ``|''.

¹Z
Ü	AGG_CHOICE ::=
Ü		agg_choice_range (Range[EXP]) | agg_choice_single EXP
°


A discrete range can be a type mark with an optional range constraint. The abstract syntax is modified to cover this.
=SML
type 'EXP ÛDISCRETE_RANGE_CONSTRAINEDİ (* =  {
	tmark : TMARK,
	range : 'EXP RANGE} *);
=TEX
=GFT
datatype ÛDISCRETE_RANGEİ =
			ÛDRRangeİ of EXP RANGE
		|	ÛDRConstrainedİ of EXP DISCRETE_RANGE_CONSTRAINED
=TEX

The datatype for AGG\_CHOICE is declared with other datatypes co-recursively with EXP in section \ref{TypeDefExpr}.
=GFT
datatype ÛAGG_CHOICEİ =
			ÛACAggChoiceRangeİ of DISCRETE_RANGE
		|	ÛACAggChoiceSingleİ of EXP;
=TEX


Agg\_Named models a named array aggregate.

ÿNamed_Assoc[EXP]üüüüüüüüüüüüüüüüü
Ü	choices : ğ AGG_CHOICE;
Ü	comp : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('AGG_CHOICE, 'EXP) ÛNAMED_ASSOCİ (* = {choice : 'AGG_CHOICE list, comp : 'EXP} *);
=TEX

ÿAgg_Namedüüüüüüüüüüüüüüüüü
Ü	named_assocs : ğ Named_Assoc
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('AGG_CHOICE, 'EXP) ÛAGG_NAMEDİ (* = {named_assocs : ('AGG_CHOICE, 'EXP) NAMED_ASSOC list} *);
=TEX

Agg\_Named\_Others is a named array aggregate with an others part.

ÿAgg_Named_Othersüüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	Agg_Named;
Ü	Others
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('AGG_CHOICE, 'EXP) ÛAGG_NAMED_OTHERSİ
		(* = {tmark : TMARK, agg_named : ('AGG_CHOICE, 'EXP) AGG_NAMED, 
			others : ('EXP) OTHERS} *);
=TEX

Rec\_Agg\_Named is a named record aggregate. (Positional record aggregates are modelled by Agg\_Pos at the start of this section).

ÿRec_Agg_Named[EXP]üüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	named_assocs : ğ (ID ¸ EXP)
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛREC_AGG_NAMEDİ
		(* = {tmark : TMARK, named_assocs : (ID * 'EXP) list} *);
=TEX

\subsubsection{Unary Operations}

¹Z
Ü	UNARY_OP ::=
Ü	spark_unary_add | spark_unary_minus | spark_not | spark_abs
°

=SML
datatype ÛUNARY_OPİ =
			ÛUOSparkUnaryAddİ
		|	ÛUOSparkUnaryMinusİ
		|	ÛUOSparkNotİ
		|	ÛUOSparkAbsİ;
=TEX


ÿUnary_Exp[EXP]üüüüüüüüüüüüüüüüü
Ü	op : UNARY_OP;
Ü	right : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛUNARY_EXPİ (* = {uop : UNARY_OP, right : 'EXP} *);
=TEX


\subsubsection{Binary Expressions}

¹Z
Ü	BIN_OP ::=
Ü	spark_and | spark_or | spark_xor | spark_eq | spark_noteq |
Ü	spark_less | spark_less_eq | spark_greater | spark_greater_eq |
Ü	spark_add | spark_minus | spark_times | spark_intdiv |
Ü	spark_mod | spark_rem | spark_expon | spark_mem | spark_notmem
°

=SML
datatype ÛBIN_OPİ =
			ÛBOSparkAndİ
		|	ÛBOSparkOrİ
		|	ÛBOSparkXorİ
		|	ÛBOSparkEqİ
		|	ÛBOSparkNotEqİ
		|	ÛBOSparkLessİ
		|	ÛBOSparkLessEqİ
		|	ÛBOSparkGreaterİ
		|	ÛBOSparkGreaterEqİ
		|	ÛBOSparkAddİ
		|	ÛBOSparkMinusİ
		|	ÛBOSparkTimesİ
		|	ÛBOSparkIntdivİ
		|	ÛBOSparkModİ
		|	ÛBOSparkRemİ
		|	ÛBOSparkExponİ
		|	ÛBOSparkMemİ
		|	ÛBOSparkNotmemİ
=TEX
Added the following which are missing in the original.
=SML
		|	ÛBOSparkAndThenİ
		|	ÛBOSparkOrElseİ
		|	ÛBOSparkConcatİ;
=TEX

ÿBin_Exp[EXP]üüüüüüüüüüüüüüüüü
Ü	op : BIN_OP;
Ü	left, right : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛBIN_EXPİ (* = {bop : BIN_OP, left : 'EXP, right : 'EXP} *);
=TEX

Mem\_Range is the membership (or non-membership) of a range.

¹Z
Ü	MEM_OP ¦ {spark_mem, spark_nonmem}
°

=SML
type ÛMEM_OPİ (* = BIN_OP *);
=TEX

ÿMem_Range[EXP]üüüüüüüüüüüüüüüüü
Ü	left : EXP;
Ü	op : MEM_OP;
Ü	Range
ˆüüüüüüüüüüüüüüüüüüüüü


=SML
type ('EXP) ÛMEM_RANGEİ (* = {left : 'EXP, mop : MEM_OP, range : 'EXP RANGE} *);
=TEX


\subsection{Attributes}
Attribute models Ada attributes.

ATTRIB are the attribute designators FIRST, LAST, SUCC, PRED, POS, VAL, LENGTH and RANGE.

¹ZAX
Ü	fst, lst, suc, pred, pos, val, length, range : ID
°

¹Z
Ü	ATTRIB ¦ {fst, lst, suc, pred, pos, val, length, range}
°

=SML
type ÛATTRIBİ (* = ID *);
=TEX

ATTRIB\_DESIG models the attribute designators.

¹Z
Ü	ATTRIB_DESIG ::=
Ü		attrib (ATTRIB) | attrib_arg (ATTRIB ¸ EXP)
°

=GFT
datatype ÛATTRIB_DESIGİ =
			ÛADAttribİ of ATTRIB
		|	ÛADAttribArgİ of (ATTRIB * EXP);
=TEX

ÿAttributeüüüüüüüüüüüüüüüüü
Ü	prefix : ID;
Ü	attribute_desig : ATTRIB_DESIG
ˆüüüüüüüüüüüüüüüüüüüüü

The prefix can in fact be a name (i.e., an expression).
=SML
type ('EXP,'ATTRIB_DESIG) ÛATTRIBUTEİ
	(* = {prefix : 'EXP, attribute_desig : 'ATTRIB_DESIG} *);
=TEX

\subsubsection{Indexed Component}
Indexed\_Comp is an array component.

ÿIndexed_Comp[EXP]üüüüüüüüüüüüüüüüü
Ü	prefix, index : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛINDEXED_COMPİ
	(* = {prefix : 'EXP, index : 'EXP} *);
=TEX

\subsubsection{Selected Component}
Selected\_Comp is a record component.

ÿSelected_Comp[EXP]üüüüüüüüüüüüüüüüü
Ü	prefix : EXP;
Ü	selector : ID
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛSELECTED_COMPİ
	(* = {prefix : 'EXP, selector : ID} *);
=TEX

\subsubsection{Function Calls}
Fun\_Call is a function call.

ÿFun_Call[EXP]üüüüüüüüüüüüüüüüü
Ü	fun_name : ID;
Ü	args : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
type ('EXP) ÛFUN_CALLİ
	(* = {fun_name : ID, args : 'EXP list} *);
=TEX

\subsubsection{Integer Literals}
INT\_LIT are the integer literals.

¹Z
Ü	[INT_LIT]
°

=SML
type ÛINT_LITİ (* = string *);
=TEX

\subsubsection{Auxiliary Expressions}
In the Compliance Notation, a SPARK expression can also be a Z expression (auxiliary expression).

¹Z
Ü	[Z_EXP]
°

=SML
type Z_EXP (* = TERM *);
=TEX

\subsubsection{Type Definition for Expressions}\label{TypeDefExpr}

¹Z
Ü	EXP ::=	
Ü		Id (ID) | int (INT_LIT) | array_agg_pos (Agg_Pos) |
Ü		array_agg_pos_others (Agg_Pos_Others) |
Ü		array_agg_others (Agg_Others) |
Ü		array_agg_named (Agg_Named) |
Ü		array_agg_named_others (Agg_Named_Others) |
Ü		rec_agg_pos (Agg_Pos) | rec_agg_named (Rec_Agg_Named) |
Ü		unary_exp (Unary_Exp) | bin_exp (Bin_Exp) |
Ü		mem_range (Mem_Range) | attribute (Attribute) |
Ü		indexed_comp (Indexed_Comp) |
Ü		selected_comp (Selected_Comp) |
Ü		fun_call (Fun_Call) |
Ü		auxiliary_exp (Z_EXP)
°

=SML
datatype ÛTYPE_DEFİ =
			ÛTDEnumTypeDefİ of ENUM_TYPE_DEF
		|	ÛTDIntTypeDefİ of EXP RANGE
		|	ÛTDFloatingTypeDefİ of EXP FLOATING_TYPE_DEF
		|	ÛTDFixedTypeDefİ of EXP FIXED_TYPE_DEF
		|	ÛTDUnconArrayDefİ of ARRAY_DEF
		|	ÛTDConArrayDefİ of ARRAY_DEF
		|	ÛTDRecordTypeDefİ of COMPONENT RECORD_TYPE_DEF
		|	ÛTDPrivateTypeDefİ of PRIVATE_TYPE_DEF
=TEX
=SML
and ÛCONSTRAINTİ =
			ÛCRangeİ of EXP RANGE
		|	ÛCFloatingİ of EXP FLOATING_POINT_CONSTRAINT
		|	ÛCFixedİ of EXP FIXED_POINT_CONSTRAINT
=TEX
=SML
and ÛBASIC_DECLİ =
			ÛBDConstDeclİ of (EXP) CONST_DECL
		|	ÛBDDeferredConstDeclİ of DEFERRED_CONST_DECL
		|	ÛBDTypeDeclİ of (TYPE_DEF) TYPE_DECL
		|	ÛBDVarDeclİ of VAR_DECL
		|	ÛBDSubtypeDeclİ of (CONSTRAINT) SUBTYPE_DECL
=TEX
=SML
and ÛDISCRETE_RANGEİ =
			ÛDRRangeİ of EXP RANGE
		|	ÛDRConstrainedİ of EXP DISCRETE_RANGE_CONSTRAINED
=TEX
=SML
and ÛAGG_CHOICEİ =
			ÛACAggChoiceRangeİ of DISCRETE_RANGE
		|	ÛACAggChoiceSingleİ of EXP
=TEX
=SML
and ÛATTRIB_DESIGİ =
			ÛADAttribİ of ATTRIB
		|	ÛADAttribArgİ of (ATTRIB * EXP)
=TEX
In order to reproduce the SPARK program as the user entered it, it is necessary to store bracketing information in the abstract syntax. Also string and character literals have been added.
=SML
and ÛEXPİ =
		ÛEIdİ of ID | ÛEIntİ of INT_LIT | ÛEArrayAggPosİ of (EXP) AGG_POS |
		ÛEArrayAggPosOthersİ of (EXP) AGG_POS_OTHERS |
		ÛEArrayAggOthersİ of (EXP) AGG_OTHERS |
		ÛEArrayAggNamedİ of (AGG_CHOICE, EXP) AGG_NAMED |
		ÛEArrayAggNamedOthersİ of (AGG_CHOICE, EXP) AGG_NAMED_OTHERS |
		ÛERecAggPosİ of (EXP) AGG_POS | ÛERecAggNamedİ of (EXP) REC_AGG_NAMED |
		ÛEUnaryExpİ of (EXP) UNARY_EXP | ÛEBinExpİ of (EXP) BIN_EXP |
		ÛEMemRangeİ of (EXP) MEM_RANGE |
		ÛEAttributeİ of (EXP,ATTRIB_DESIG) ATTRIBUTE |
		ÛEIndexedCompİ of (EXP) INDEXED_COMP |
		ÛESelectedCompİ of (EXP) SELECTED_COMP |
		ÛEFunCallİ of (EXP) FUN_CALL |
		ÛEAuxiliaryExpİ of Z_EXP |
		ÛEBracketedİ of EXP |
		ÛEStringLiteralİ of string |
		ÛECharacterLiteralİ of string;
=TEX


\subsection{Statements}

The Z specification of the abstract syntax uses a given set declaration to act as a forward declaration of the free type $Stmt$, permitting the free type to involve recursion through schema constructions.
Unfortunately, this style is not considered to be type correct in \ProductZ; this is readily circumvented by making the schema constructions generic where necessary.
For example, see section \ref{if-then-else} below.

Following this convention we may now work through the abstract syntax for SPARK statements following \cite{DRA/CIS/CSE3/SWI/WP/1/3}.

\subsubsection{Assignment}\label{assignment}

ÿAssignüüüüüüüüüüüüüüüüü
Ü	name, E : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
	type ÛASSIGNİ (* = {name : EXP, e : EXP}; *)
=TEX

\subsubsection{Specification Statements}

¹ZAX
Ü	Z_PRED‰0 : ğ Z_PRED
°

=SML
type ÛZ_PREDİ (* = TERM; *)
type ÛZ_PRED‰0İ (* = Z_PRED; *)
type ÛZ_IDİ (* = ID; *)
=TEX

ÿSpecüüüüüüüüüüüüüüüüü
Ü	w, w‰0 : ğ Z_ID;
Ü	Pre, post : Z_PRED
÷üüüüüüüüüüüüüüü
Ü	Pre  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü

ÿSpec_No_Ivarsüüüüüüüüüüüü
Ü	Spec
÷üüüüüüüüüüüüüüü
Ü	post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü
=TEX
In the translation into Standard ML of a schema which includes another,
we have various choices.
In this simple case where the new schema has the same signature as the included one, we just say that the new type is an abbreviation for the old one.

Additionally Label is stored with the abstract syntax of the specification statement.
=SML
datatype ÛLABELİ =
			ÛLExplicitİ of string
		|	ÛLImplicitİ;
=TEX
=SML
	type ÛSPECİ (* = {w : Z_ID list, w0 : Z_ID list, pre : Z_PRED, post : Z_PRED, label : LABEL};*)
	type ÛSPEC_NO_IVARSİ (* = SPEC; *)
=TEX
\subsubsection{If-then-else}\label{if-then-else}

¹ZAX
Ü	COND : ğ EXP
°

ÿIf_Then_Else[STMT]üüüüüüüüüüüüüüüüü
Ü	G : COND;
Ü	P, Q : STMT
ˆüüüüüüüüüüüüüüüüüüüüü

In an nested if statement 

=GFT SPARK Fragment
IF	<cond>	THEN	<stmt>;
ELSIF	<cond>	THEN	<stmt>;
...
ELSIF	<cond>	THEN	<stmt>;
END IF;
=TEX
is equivalent to
=GFT SPARK Fragment
IF	<cond>	THEN	<stmt>;
ELSE IF	<cond>	THEN	<stmt>;
...
ELSE IF	<cond>	THEN	<stmt>;
END IF;
=TEX
I.e., ELSIF is the same as writing ELSEIF. In order to make the input reproducable in the SPARK program to be generated, a flag is stored with each abstract representation of the if statement indicating whether the else condition was input as an ELSIF or not.
=SML
	type ÛCONDİ (* = EXP; *)
	type ('STMT) ÛIF_THEN_ELSEİ (* = {
		g : COND, p : 'STMT, q : 'STMT, elsif : bool}; *)
=TEX
\subsubsection{Case}\label{case}

¹Z
Ü	CASE_CHOICE ::= case_exp EXP | case_range Range
°

The case choice can be a discrete range.
=SML
datatype ÛCASE_CHOICEİ =
				ÛCCCaseExpİ of EXP
			|	ÛCCCaseRangeİ of DISCRETE_RANGE;
=TEX

ÿCase_Alternative[STMT]üüüüüüüüüüüüüüüüü
Ü	choices : ğ CASE_CHOICE;
Ü	P : STMT
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
ÿCaseüüüüüüüüüüüüüüüüü
Ü	E : EXP;
Ü	s : seq‰1 Case_Alternative
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

A Case statement can have an others part.
=SML
type 'STMT ÛCASE_ALTERNATIVEİ (* = {choices : CASE_CHOICE list, p : 'STMT}; *)
type 'STMT ÛCASEİ (* = {e : EXP, s : ('STMT) CASE_ALTERNATIVE list,
				others : 'STMT}; *)
=TEX
\subsubsection{Loop}\label{loop}

ÿLoopüüüüüüüüüüüüüüüüü
Ü	T : Z_PRED;
Ü	Spec_No_Ivars
÷üüüüüü
Ü	T  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
As with the translation of $Spec\_No\_Ivars$, we have a choice of how to translate the schema inclusion.
This case is a little more complicated, however, but as there is no overlap between the signature of the included schema and other signature variables, we can adopt the following simple translation.

The till clause may not be present in which case the t component will be true. However we make t optional to reflect the concrete syntax so that the SPARK program can be reproduced authentically.

A loop body may be a sequence of statements in which case the treatment of the loop can only be informal with respect to generating verification conditions.
A loop without an iteration scheme can have a name, so we introduce an additional type called NAMED\_LOOP.
=SML
	type 'STMT ÛLOOPİ (* = {t : Z_PRED OPT, stmt : 'STMT}; *)
	type 'STMT ÛNAMED_LOOPİ (* = {name : ID, t : Z_PRED OPT, stmt : 'STMT}; *)
=TEX

\subsubsection{While Loop}\label{while-loop}
ÿWhileüüüüüüüüüüüüüüüüü
Ü	G : COND;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

Loops can have names, so a name is introduced into the abstract representation.
=SML
type 'STMT ÛWHILEİ (* = {name : ID OPT, g : COND, loop : 'STMT LOOP}; *)
=TEX
\subsubsection{For Loop (Values as Bounds)}\label{for-static}

¹ZAX
Ü	STATIC_EXP : ğ EXP
°

ÿFor_Staticüüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	lo, hi : STATIC_EXP;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

Loops can have names so a field in the abstract representation is reserved for name. Also we record in the abstract syntax the direction of the loop and the type mark for the purposes of reproducing the SPARK program.

=SML
type ÛSTATIC_EXPİ (* = EXP; *)

datatype ÛLOOP_DIRECTIONİ =
				LDForwards
			|	LDReverse;
=TEX
Also, if the range is denoted by an attribute, then the range attribute is stored in the $lo$ component. The $hi$ component is therefore optional and its absence denotes that the $lo$ component denotes a range attribute.
=SML
type 'STMT ÛFOR_STATICİ (* = {
	name : ID OPT,
	i : ID,
	tmark : ID,
	lo : STATIC_EXP,
	hi : STATIC_EXP OPT,
	dir : LOOP_DIRECTION,
	loop : 'STMT LOOP}; *)
=TEX
\subsubsection{For Loop (Type Mark as Range)}\label{for-typemark}

ÿFor_Tmarküüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	tmark : TMARK;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

FOR\_TMARK is augmented in the same way as for FOR\_STATIC.

=SML
type 'STMT ÛFOR_TMARKİ (* = {
	name : ID OPT,
	i : ID,
	tmark : TMARK,
	dir : LOOP_DIRECTION,
	loop : 'STMT LOOP}; *)
=TEX
\subsubsection{Exit}\label{exit}

ÿExitWhenüüüüüüüüüüüüüüüüü
Ü	G : COND
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=SML
	type ÛEXIT_WHENİ (* = {g : COND}; *)
=TEX
\subsubsection{Return}\label{return}

ÿReturnüüüüüüüüüüüüüüüüü
Ü	E : EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=SML
	type ÛRETURNİ (* = {e : EXP}; *)
=TEX
\subsubsection{Procedure Call}\label{procedure-call}

ÿProc_Callüüüüüüüüüüüüüüüüü
Ü	name : ID;
Ü	actuals : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=SML
	type ÛPROC_CALLİ (* = {name : ID, actuals : EXP list}; *)
=TEX
ÿProc_Call_No_Ivarsüüüüüüüüüüüüüüüüü
Ü	Proc_Call
÷üüüüüüüüüüüüüüüü
Ü	(retrieve_spec_stmt name).post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=SML
	type ÛPROC_CALL_NO_IVARSİ (* = PROC_CALL; *)
=TEX
\subsubsection{$Stmt$}\label{stmt}
\ProductZ\ is currently non-standard in that it neither requires nor
allows the chevrons around the operands in a free type definition.
This mismatch with the Z standard is planned to be remedied in a future release of the system.
¹Z
	Stmt	::= 	null
		|	assign (Assign)
		|	spec_no_ivars (Spec_No_Ivars)
		|	semicolon (Stmt ¸ Stmt)
		|	if_then_else (If_Then_Else)
		|	case (Case[Stmt])
		|	loop (Loop)
		|	while (While)
		|	for_static (For_Static)
		|	for_tmark (For_Tmark)
		|	exit_when (Exit_When)
		|	exit
		|	ret (Return)
		|	proc_no_ivars (Proc_Call_No_Ivars)
°
=TEX
KSLots are required in the abstract syntax as place markers so that when the SPARK program is reproduced from the abstract syntax, the expansions can be put back into the correct places.
=SML
type ÛK_SLOTİ (* = {content : string, label : LABEL} *);
=TEX
=SML
datatype ÛSTMTİ	= 	ÛSTNullİ
		| 	ÛSTImplicitNullİ
		|	ÛSTAssignİ of ASSIGN
		|	ÛSTSpecNoIvarsİ of SPEC_NO_IVARS
		|	ÛSTSemicolonİ of (STMT * STMT)
		|	ÛSTIfThenElseİ of  STMT IF_THEN_ELSE
		|	ÛSTCaseİ of STMT CASE
		|	ÛSTLoopİ of STMT LOOP
		|	ÛSTNamedLoopİ of STMT NAMED_LOOP
		|	ÛSTWhileİ of STMT WHILE
		|	ÛSTForStaticİ of STMT FOR_STATIC
		|	ÛSTForTmarkİ of STMT FOR_TMARK
		|	ÛSTExitWhenİ of EXIT_WHEN
		|	ÛSTExitİ
		|	ÛSTRetİ of RETURN
		|	ÛSTProcNoIvarsİ of PROC_CALL_NO_IVARS
		|	ÛSTKSlotİ of K_SLOT;
=TEX
\pagebreak
\subsubsection{Specification (with initial variables)}\label{specification-ivars}

ÿSpec_Ivarsüüüüüüüüüüüü
Ü	Spec
÷üüüüüüüüüüüüüüü
Ü	post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü
=TEX
=SML
	type ÛSPEC_IVARSİ (* = SPEC; *)
=TEX
\subsubsection{For Loop (Non-Static Bounds)}\label{for-non-static-bounds}

ÿFor_Non_Staticüüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	lo, hi : EXP;
Ü	Loop
÷üüüüüüüüüüüüüüüü
Ü		lo  STATIC_EXP
Ü	²
Ü		hi  STATIC_EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
A loop may have an optional name. 
Also, if the range is denoted by an attribute, then the range attribute is stored in the $lo$ component. The $hi$ component is therefore optional and its absence denotes that the $lo$ component denotes a range attribute.

=SML
	type ÛFOR_NON_STATICİ (* = {name : ID OPT, i : ID, lo : STATIC_EXP, hi : STATIC_EXP OPT, loop : STMT LOOP}; *)
=TEX
\subsubsection{Logical Constants}\label{logical-constants}
¹ZAX
Ü	free_ids : Z_EXP ­ ğ Z_ID
°

ÿLog_Conüüüüüüüüüüüü
Ü	X : Z_ID;
Ü	E : Z_EXP;
Ü	Spec;
Ü	pre‰1 : Z_PRED
÷üüüüüüüüüüüüüüü
Ü	Pre = z_and(z_eq(zid X, E), pre‰1);
Ü	X  free_ids E
ˆüüüüüüüüüüüüüüüüüüüüü
=TEX
The functions $free\_id$ may readily and reallistically be implemented using existing \Product\
syntax functions.
=SML
	val Ûfree_idsİ : Z_EXP -> ID list
	type ÛLOG_CONİ (* = {x : Z_ID, e : Z_EXP, spec : SPEC, pre1 : Z_PRED}; *)
=TEX
\subsubsection{Procedure Calls}\label{procedure-calls}
ÿProc_Call_Ivarsüüüüüüüüüüüü
Ü	Proc_Call
÷üüüüüüüüüüüüüüü
Ü	(retrieve_spec_stmt name).post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü

=SML
	type ÛPROC_CALL_IVARSİ (* = PROC_CALL; *)
=TEX

\subsubsection{Statement}\label{statement}
¹Z
	Statement
		::= 	stmt (Stmt)
		|	spec_ivars (Spec_Ivars ¸ Stmt)
		|	for_non_static (For_Non_Static ¸ Stmt)
		|	log_con (Log_Con ¸ Stmt)
		|	proc_ivars (Proc_Call_Ivars ¸ Stmt)
°
=TEX
=SML
datatype ÛSTATEMENTİ =
		 	ÛSStmtİ of STMT
		|	ÛSSpecIvarsİ of (SPEC_IVARS * STMT)
		|	ÛSForNonStaticİ of (FOR_NON_STATIC * STMT)
		|	ÛSLogConİ of (LOG_CON * STMT)
		|	ÛSProcIvarsİ of (PROC_CALL_IVARS * STMT);
=TEX

\subsection{Subprogram Declarations}
=SML
datatype ÛMODEİ = MSparkIn | MSparkOut | MSparkInOut;

type ÛPARAMETER_SPECIFICATIONİ (* = {
	idlist : ID list,
	mode : MODE,
	name : TMARK} *);

type ÛPROCEDURE_SPECIFICATIONİ (* = {
	name : ID,
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT} *);

type ÛFUNCTION_SPECIFICATIONİ (* = {
	designator : ID,
	return : TMARK,
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT} *);

datatype ÛSUBPROGRAM_SPECIFICATIONİ =
			SSProcedure of PROCEDURE_SPECIFICATION
		|	SSFunction of FUNCTION_SPECIFICATION;

type ÛPROCEDURE_DECLARATIONİ (* = PROCEDURE_SPECIFICATION *);
type ÛFUNCTION_DECLARATIONİ (* =FUNCTION_SPECIFICATION *);
type ÛSUBPROGRAM_DECLARATIONİ (* = SUBPROGRAM_SPECIFICATION *);
=TEX
\subsection{Subprogram Bodies}
\subsection{Procedure and Function Calls}
=SML
type ÛNAMED_PARAMİ (* = {
	formal : ID,
	actual : EXP} *);

type ÛNAMED_PARAMETER_ASSOCİ (* = {
	params: NAMED_PARAM list} *);

type ÛPOS_PARAMETER_ASSOCİ (* = {
	params : EXP list} *);

datatype ÛACTUAL_PARAMETER_PARTİ = 
			APPNamed of NAMED_PARAMETER_ASSOC
		|	APPPositional of POS_PARAMETER_ASSOC;

type ÛPROCEDURE_CALL_STATEMENTİ (* = {
	name : ID,
	params : ACTUAL_PARAMETER_PART OPT} *);

type ÛFUNCTION_CALLİ (* = {
	name : ID,
	params : ACTUAL_PARAMETER_PART OPT} *);

=TEX
\subsection{Package Declaration}
=SML
type ÛOPERATOR_SYMBOLİ (* = string *);

type ÛFUNCTION_RENAMINGİ (* = {
	opsym1 : OPERATOR_SYMBOL,
	formal_part : PARAMETER_SPECIFICATION list,
	tmark : TMARK,
	name : ID,
	opsym2 : OPERATOR_SYMBOL} *);

type ÛSUBPROGRAM_RENAMINGİ (* = {
	subprogram_specification : SUBPROGRAM_SPECIFICATION,
	name1 : ID,
	name2 : ID} *);

datatype ÛRENAMING_DECLARATIONİ =
			RDFunction of FUNCTION_RENAMING
		|	RDSubprogram of SUBPROGRAM_RENAMING;

type ÛLENGTH_CLAUSEİ (* = {
	attribute : EXP,
	exp : EXP} *);

type ÛENUMERATION_REPRESENTATION_CLAUSEİ (* = {
	name : ID,
	exp : EXP} *);

type ÛCOMPONENT_CLAUSEİ (* = {
	exp : EXP,
	range : EXP RANGE} *);

type ÛRECORD_REPRESENTATION_CLAUSEİ (* = {
	name : ID,
	alignment_opt : EXP OPT,
	component_pack : COMPONENT_CLAUSE list} *);

type ÛADDRESS_CLAUSEİ (* = {
	name : ID,
	exp : EXP} *);

datatype ÛREPRESENTATION_CLAUSEİ =
			RCLength of LENGTH_CLAUSE
		|	RCEnumeration of ENUMERATION_REPRESENTATION_CLAUSE
		|	RCRecord of RECORD_REPRESENTATION_CLAUSE
		|	RCAddress of ADDRESS_CLAUSE;
=TEX
=SML
type ÛPROCEDURE_BODYİ (* = {
	procedure_spec : PROCEDURE_SPECIFICATION,
	declarative_part : DECLARATION list,
	statement : STATEMENT} *);

type ÛFUNCTION_BODYİ (* = {
	function_spec : FUNCTION_SPECIFICATION,
	declarative_part : DECLARATION list,
	statement : STATEMENT} *);

type ÛPACKAGE_BODYİ (* = {
	name : ID,
	decls : DECLARATION list,
	statement : STATEMENT} *);

type ÛPACKAGE_DECLARATIONİ (* = {
	name : ID,
	visible_decs : DECLARATION list,
	private_decs : DECLARATION list} *);

=TEX
=SML
datatype ÛDECLARATIONİ =
			DDeclarationKSlot of K_SLOT
		|	DRenamingDeclaration of RENAMING_DECLARATION
		|	DBasicDecl of BASIC_DECL
		|	DRepresentationClause of REPRESENTATION_CLAUSE
		|	DProperBody of PROPER_BODY
		|	DProcedureDeclaration of PROCEDURE_DECLARATION
		|	DFunctionDeclaration of FUNCTION_DECLARATION
		|	DPackageDeclaration of PACKAGE_DECLARATION
		|	DProcedureStub of PROCEDURE_DECLARATION
		|	DFunctionStub of FUNCTION_DECLARATION
		|	DPackageStub of ID

and ÛPROPER_BODYİ =	PBProcedure of PROCEDURE_BODY
		|	PBFunction of FUNCTION_BODY
		|	PBPackage of PACKAGE_BODY;
=TEX

=TEX
=SML
type ÛSUBUNITİ (* = {
	id : ID,
	proper_body : PROPER_BODY} *);

datatype ÛCOMPILATION_UNITİ =
			CUPackageDeclaration of PACKAGE_DECLARATION
		|	CUProperBody of PROPER_BODY
		|	CUSubUnit of SUBUNIT;


type ÛREFINED_BYİ (* = {label : LABEL,  statement : STATEMENT} *);
type ÛREPLACED_BYİ (* = {label : LABEL,  statement : STATEMENT} *);

type ÛREPLACED_BY_DECLİ (* = {label : LABEL,  decls : DECLARATION list} *);
type ÛREPLACED_BY_VISIBLE_PARTİ (* = {label : LABEL, visible : DECLARATION list} *);
type ÛREPLACED_BY_PRIVATE_PARTİ (* = {label : LABEL, private : DECLARATION list} *);

type CONTEXT_COMPILATION_UNIT (* = {
	context : ID list,
	comp_unit : COMPILATION_UNIT} *);

datatype ÛKSLOT_COMPILATION_UNITİ =
			KCUKSlot of K_SLOT
		|	KCUUnit of CONTEXT_COMPILATION_UNIT;

type ÛREPLACED_BY_COMPİ (* = {label : ID,  comp : KSLOT_COMPILATION_UNIT list} *);

datatype ÛWEB_CLAUSEİ = 
			WCCompilation of KSLOT_COMPILATION_UNIT list
		|	WCReplacedByCompilation of REPLACED_BY_COMP
		|	WCReplacedByPrivatePart of REPLACED_BY_PRIVATE_PART
		|	WCReplacedByVisiblePart of REPLACED_BY_VISIBLE_PART
		|	WCReplacedByDecl of REPLACED_BY_DECL
		|	WCRefinedBy of REFINED_BY
		|	WCReplacedBy of REPLACED_BY;
=TEX
\section{EPILOGUE}

=SML
end; (* of signature CNTypes *)
=TEX

=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



