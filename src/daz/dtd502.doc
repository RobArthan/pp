%  dtd502.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\def\TPPheadtitle{Compliance Notation Lexis and Abstract Syntax}  %% Mandatory field
\TPPtitle{Compliance Notation Lexis and Abstract Syntax}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD502}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{HOL}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan&HAT Team}
\TPPabstract{
This document contains the detailed design for the lexis and abstract syntax for Compliance Notation}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	C.~O'Halloran, DRA \\
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.37] Initial Drafts.

\item[Issue 1.38 (22nd Sept 1994)] Reworked according to desk check report 006.

\item[Issue 1.39 (7th Oct 1994)] Added lexical tokens for auxiliary expressions.
\item[Issue 1.40 (7th Oct 1994)] Corrected abstract syntax for specification statements w.r.t. labels.
\item[Issue 1.44 (13th Oct 1994)] Re-organised material and applied DRA's suggested corrections documented in \cite{ISS/HAT/DAZ/MIN004}.
\item[Issue 1.45 (13th Oct 1994)] Few minor changes in checking the rework.
\item[Issue 1.46-1.51] Bug fixes.
\item[Issue 1.52] Updated document references.
\item[Issue 1.53] Changed the text in the Test Policy section. Fixed a Z problem in the definition of Z\_PRED.
\item[Issue 1.54] Reworded the test policy section.
\item[Issue 1.55] Added pragmas, annotations and arbitrary replacements.
\item[Issue 1.60] Added Z Bindings and updated free type def. of Z\_EXP.
\item[Issue 1.61] Added qualified expressions and type conversions to the Z.
\end{description}

\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the lexis and abstract syntax for the Compliance Notation.

The lexis corresponds to that specified in \cite{pvl90}. The abstract syntax is based on the abstract syntax for basic declarations and expressions in \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/1.2} and the abstract syntax for SPARK statements in \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/1.2}. The abstract syntax for SPARK subprograms and packages has been derived from the concrete syntax for compliance notation in \cite[volume 1]{DRA/CIS/CSE3/TR/94/27/1.2}.

\subsection{Introduction}
\subsubsection{Purpose and Background}

The lexis is required to carry the lexical information of the input which has been computed by the lexical analyser. The grammar in \cite{ISS/HAT/DAZ/DTD503} is closely related to this lexis since the terminals in the grammar correspond to the lexemes in the datatype $CN\_LEX\_CLASS$. The lexical classes are themselves derived from the list of terminal symbols in \cite[volume 1, appendix A]{DRA/CIS/CSE3/TR/94/27/1.2}.

The abstract syntax for compliance notation constitutes the internal representation for web clauses. All web clauses and fragments of SPARK programs are represented using the abstract syntax type $WEB\_CLAUSE$. The representation is used by the basic declaration and expression generator \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/1.2}, the verification condition generator \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/1.2} and the SPARK output function which creates a human-readable form of the abstract representation corresponding to the input.

Web clauses of type $WEB\_CLAUSE$ are generated by the compliance notation parser \cite{ISS/HAT/DAZ/DTD503} from the literate script being processed.


\subsection{Compliance}

This document contains the signature for compliance notation lexis and compliance notation abstract syntax.

The correspondance between the lexis that that in \cite[volume 1, appendix A]{DRA/CIS/CSE3/TR/94/27/1.2} can be seen by simply comparing the list of type constructors of $CN\_LEX\_CLASS$ with the terminal symbols in \cite[volume 1, appendix A]{DRA/CIS/CSE3/TR/94/27/1.2}.


The correspondence between the Z specification of the abstract syntax in DRA's specification and the implementation is aided by the reproduction of the relevant Z of \cite{DRA/CIS/CSE3/TR/94/27/1.2} in this document. The implementation of each of the schemas is done using a Standard ML type. The details of this type do not appear in the Standard ML signature; the ML syntax does not allow it; but only in the structure. In order to maintain traceability, the information which appears in the structure is contained in this document. During the building of the tool, the {\Product} document processing facility $sieve$ filters out the implementation details into a separate file. The signature can then be processed, and the corresponding structure can be automatically generated from the filtered implementation details. The machinery to do this is very small and can be found in the companion implementation document to this \cite{ISS/HAT/DAZ/IMP503}.

It is intended that the compliance of the Z to the implementation can be done with a visual check in this document.

There are various points in the abstract syntax where the data types are ``wider'' than the corresponding Z. This is generally because it is necessary to carry some syntactic information which would otherwise be lost, in order to reproduce the SPARK program when all the web clauses have been entered. These points are identified by descriptive text later in this document.

Note also that Z expressions are stored as HOL terms in {\ProductZ}. The HOL terms which represent Z expressions are a subset of all HOL terms. This constitutes a ``widening''. This does not introduce any problem for the Compliance Tool.


\section{PREAMBLE}
\subsection{For Z Type-Checking}
The following initialises the theory database when performing a syntax and type check on the Z paragraphs in this document. (This preamble is not processed when building the compliance tool.)

=SMLZ
open_theory"z_library";
push_pc "z_library";
force_delete_theory"dtd502" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", false);
new_theory"dtd502";
=TEX

\subsection{The Signature}
=DOC
signature €CNTypes› = sig
local
	open ZUserInterfaceSupport;
in
=DESCRIBE
This is the signature for the structure containing the types required for Compliance Notation.
=ENDDOC
\section{LEXIS}
=DOC
datatype €CN_LEX_CLASS›
			= €LCAbs› | €LCAmpersand› | €LCAnd›
			| €LCAnnotation›
			| €LCArbitraryAda›
			| €LCArray› |€LCAt›
			| €LCBar› |€LCBBody› | €LCBecomes› | €LCBegin›
			| €LCCase›| €LCCharacterLiteral›
			| €LCColon› | €LCComma› | €LCComment›
			| €LCCompLabel› | €LCConstant›
			| €LCCon› | €LCCrd› | €LCDecLabel› | €LCDelta›
			| €LCDigits› | €LCDiv›| €LCDotDot› | €LCDot› | €LCElse›
			| €LCElsIf› | €LCEnd› | €LCEquals› | €LCExit›
			| €LCFatDot› | €LCFor› | €LCFunction›
			| €LCGoesTo› | €LCGreaterEquals›
			| €LCGreaterThan›
			| €LCIdentifier› | €LCIf›
			| €LCIn› | €LCIs›
			| €LCKSlot› | €LCLessEquals› | €LCLessGreat› | €LCLessThan›
			| €LCLimited› | €LCLoop› | €LCMinus›
			| €LCMod› | €LCNotEquals› | €LCNot› | €LCNull›
			| €LCNumericLiteral› | €LCOf›
			| €LCOrd› | €LCOr› | €LCOthers› | €LCOut›
			| €LCPackage› | €LCPlus›
			| €LCPPartLabel› | €LCPrime› | €LCPrimedIdentifier›
			| €LCPragma›
			| €LCPrivate› | €LCProcedure›
			| €LCRecord› | €LCRefinedBy› | €LCRem›
			| €LCRenames› | €LCReplacedBy› | €LCReturn›
			| €LCReverse› | €LCRRange› | €LCSemi›
			| €LCSeparate› | €LCSpecLabel› | €LCStarStar›
			| €LCStar› | €LCStmtLabel›
			| €LCStringLiteral› | €LCSubType› | €LCThen›
			| €LCTill›
			| €LCType› | €LCUse› | €LCVPartLabel›
			| €LCWhen› | €LCWhile› | €LCWith› | €LCXor› | €LCEos›
			| €LCZ›
			| €LCAuxiliary› | €LCUsing› | €LCImplement› | €LCBy›
			| €LCGrkDelta› | €LCLSqBrack› | €LCRSqBrack›
			| €LCLBrace› | €LCRBrace› | €LCLStrachey›
			| €LCRStrachey› | €LCLChevron› | €LCRChevron›;
=DESCRIBE
CN\_LEX\_CLASS is the datatype used to represent the lexical classes of tokens in compliance notation. 
=DESCRIBE
=ENDDOC

=DOC
datatype €CN_TOKEN›	=	€CNZ› of ZLex.Z_TOKEN list
			|	€CNText› of string
			|	€CNString› of string
			|	€CNKSlot› of Lex.INPUT list
			|	€CNEos›;

type €CN_LEX_ITEM›
=TYPESTRUCT
	= CN_LEX_CLASS * CN_TOKEN;
=DESCRIBE
CN\_TOKEN is the datatype used to represent the lexical tokens required in compliance notation. CN\_LEX\_ITEM is a type used by the lexical analyser for communicating to the parser the lexical information. The class (the first of the pair) is the classification of the token (the second of the pair).
=ENDDOC

\subsection{Notes on Compliance}

The specification of the concrete syntax in \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/1.2} does not spell out the syntax for specification statements. Hence the terminal $specification statement$ is not represented in the list of lexical classes, but the syntactic components are instead provided, viz: $LCGrkDelta$, $LCLSqBrack$, $LCRSqBrack$, $LCLBrace$, $LCRBrace$.

Similarly for k-slots, $LCLChevron$ and $LCRChevron$; and auxiliary expressions, $LCLStrachey$ and $LCRStrachey$.

There is no need for an lexical class for a type mark as it is lexically equivalent to an identifier. 

A consequence of an ambiguity in handling primes, documented in \cite{ISS/HAT/DAZ/DTD503}, is the necessity of a lexical class to represent an identifier immediately followed by a prime; hence $LCPrimedIdentifier$. An end-of-input has also been added, $LCEos$.

Other consequences of changes to the grammar (also documented in \cite{ISS/HAT/DAZ/DTD503}) result in no requirement for lexical classes corresponding to $commagoesto$, $commaothers$, $whenothers$, $functionname$, $procedurename$, $z\_decl$, $z\_pred$ and $na$ of \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/1.2}.
\newpage

\section{Z ABSTRACT SYNTAX}

Since Z abstract syntax is already supported in {\ProductZ}, there is no requirement to provide specific implementations of most of the Z in this section. It is provided here mainly for the purpose of allowing the Z in this and other detailed design documents to type-check correctly.

\subsection{Z Declarations}

=DOC
type €Z_ID›
=TYPESTRUCT
	= string;
=DESCRIBE
πZ
‹	[Z_ID]
∞
=ENDDOC

=DOC
type €Z_DECL›
=TYPESTRUCT
      = TERM;
=DESCRIBE
A Z declaration is represented as a HOL term using the primitive Z abstract machine constructor $mk\_z\_dec$. e.g. the Z declaration $x : ˙$ is represented in {\Product} as the HOL term $Òëmk\_z\_dec([ÒxÆ], Ò˙Æ)ÆÆ$ : TERM   

ˇZ_Decl[Z_EXP]¸¸¸¸¸¸¸¸
‹	zvar : Z_ID;
‹	zexp : Z_EXP
à¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\subsection{Z Unary Expressions}

πZ
‹	Z_UNARY_OP ::= z_unary_minus | z_bool_not | z_abs
∞


ˇZ_Unary_Exp[Z_EXP]¸¸¸¸¸¸¸¸
‹	zop : Z_UNARY_OP;
‹	zright : Z_EXP
à¸¸¸¸¸¸¸¸¸¸¸

\subsection{Z Binary Expressions}

πZ
‹	Z_BIN_OP ::= z_bool_and | z_bool_or | z_bool_xor | z_bool_eq | z_bool_noteq |
‹	z_bool_less | z_bool_less_eq | z_bool_greater | z_bool_greater_eq | z_add |
‹	z_minus | z_times | z_intdiv | z_mod | z_rem | z_expon | z_bool_mem |
‹	z_bool_notmem
∞

ˇZ_Bin_Exp[Z_EXP]¸¸¸¸¸
‹	zop : Z_BIN_OP;
‹	zleft, zright : Z_EXP
à¸¸¸¸¸¸¸¸¸¸¸


\subsection{Z Function Calls}

ˇZ_Fun_Call[Z_EXP]¸¸¸¸¸
‹	zfun : Z_EXP;
‹	zargs : seq Z_EXP
à¸¸¸¸¸¸¸¸¸¸¸

\subsection{Z Binding Selections}

ˇZ_Selection[Z_EXP]¸¸¸¸
‹	zbinding : Z_EXP;
‹	zselector : Z_ID
à¸¸¸¸¸¸¸¸¸¸¸

\subsection{Z Binding Selections}

ˇZ_Binding[Z_EXP]¸¸¸¸
‹	zbinds :  (Z_Decl[Z_EXP])
à¸¸¸¸¸¸¸¸¸¸¸

\subsection{Z Expressions and Predicates}

πZ
‹	[OTHER_Z_EXP]
∞

πZ
‹	[OTHER_Z_PRED]
∞
=DOC
type €Z_EXP›
=TYPESTRUCT
	= TERM;
=ENDDOC

=DOC
type €Z_PRED›
=TYPESTRUCT
	= TERM;
=ENDDOC

πZ
‹	Z_EXP ::=
‹	zsucc | zid Z_ID | z_num ˙ | z_tfun (Z_EXP ∏ Z_EXP) |
‹	z_pfun (Z_EXP ∏ Z_EXP) | z_rng (Z_EXP ∏ Z_EXP) |
‹	z_dom Z_EXP | z_dom_res (Z_EXP ∏ Z_EXP) | z_inv Z_EXP |
‹	z_id_rel Z_EXP | z_size Z_EXP | z_set ( Z_EXP) |
‹	z_set_minus (Z_EXP ∏ Z_EXP) |
‹	z_set_comp (Z_Decl[Z_EXP] ∏ Z_PRED) | z_power (Z_EXP ∏ Z_EXP) |
‹	z_rel_comp (Z_EXP ∏ Z_EXP) |  z_seq (seq Z_EXP) |
‹	z_cross (Z_EXP ∏ Z_EXP) | z_many_cross (seq Z_EXP) |
‹	z_override (Z_EXP ∏ Z_EXP) | z_many_union ( Z_EXP)
‹	z_unary_exp (Z_Unary_Exp[Z_EXP]) | z_bin_exp (Z_Bin_Exp[Z_EXP]) |
‹	z_fun_call (Z_Fun_Call[Z_EXP]) | z_selection (Z_Selection[Z_EXP]) |
‹	z_maplet (Z_EXP ∏ Z_EXP) | z_powerset Z_EXP |
‹	z_binding (Z_Binding[Z_EXP]) | other_z_exp OTHER_Z_EXP
‹ &	
‹	Z_PRED ::=
‹	z_true | z_eq (Z_EXP ∏ Z_EXP) | z_and (Z_PRED ∏ Z_PRED) |
‹	z_many_and ( Z_PRED) | z_elem (Z_EXP ∏ Z_EXP) |
‹	z_noteq (Z_EXP ∏ Z_EXP) | z_less_eq (Z_EXP ∏ Z_EXP) |
‹	z_greater (Z_EXP ∏ Z_EXP) | z_forall ((seq Z_Decl[Z_EXP]) ∏ Z_PRED) |
‹	z_exists ( Z_Decl[Z_EXP] ∏ Z_PRED) | z_imp (Z_PRED ∏ Z_PRED) |
‹	other_z_pred OTHER_Z_PRED
‹
∞


\subsection{Z Modules}

πZ
‹	[Z_MODULE]
∞

\subsection{Z Schemas}

ˇZ_Schema¸¸¸¸¸
‹	z_sname : Z_ID;
‹	z_decls :  Z_Decl[Z_EXP]
à¸¸¸¸¸¸¸¸¸¸¸¸¸

\subsection{Z Axiomatic Descriptions}

ˇZ_Ax¸¸¸¸¸¸¸¸
‹	decls :  Z_Decl[Z_EXP];
‹	preds :  Z_PRED
à¸¸¸¸¸¸¸¸¸¸¸¸¸

\subsection{Verification Conditions}

ˇSequent¸¸¸¸¸¸¸¸
‹	H :  Z_PRED;
‹	c : Z_PRED
à¸¸¸¸¸¸¸¸¸¸¸¸¸

πZ
‹	VC ¶ ( Z_Decl[Z_EXP] ∏ Sequent)
∞

\subsection{Z Paragraphs}

πZ
‹	[OTHER_Z]
∞
πZ
‹	Z_PARA ::=
‹	z_module (Z_MODULE) | z_eq_eq (Z_ID ∏ Z_EXP) |
‹	z_schema (Z_Schema) | z_ax (Z_Ax) | z_vcs ( VC) |
‹	other_z (OTHER_Z)
‹
∞

\newpage
\section{SPARK ABSTRACT SYNTAX}

\subsection{Expressions}

\subsubsection{Identifiers}

ID is the set of Ada Identifiers.

=DOC
type €ID›
=TYPESTRUCT
	= string;
=DESCRIBE
πZ
‹	[ID]
∞
=ENDDOC

\subsubsection{Aggregates (positional array)}

TMARK is the set of type marks in the literate script.

=DOC
type €TMARK›
=TYPESTRUCT
	= ID;
=DESCRIBE
πZAX
‹	TMARK :  ID
∞
=ENDDOC

Agg\_Pos is a positional array or record aggregate.

=DOC
type ('EXP) €AGG_POS›
=TYPESTRUCT
      = {
	tmark : TMARK,
	comps : 'EXP list
	};
=DESCRIBE
ˇAgg_Pos[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	tmark : TMARK;
‹	comps : seq EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\subsubsection{Aggregates (positional array with others)}
Agg\_Pos\_Others is a positional array with an others part.


=DOC
type ('EXP) €OTHERS›
=TYPESTRUCT
      = {
	others : 'EXP
	};
=DESCRIBE
ˇOthers[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	others : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC


=DOC
type 'EXP €AGG_POS_OTHERS›
=TYPESTRUCT
      = {
	agg_pos : 'EXP AGG_POS,
	others : 'EXP OTHERS
	};
=DESCRIBE
ˇAgg_Pos_Others[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Agg_Pos[EXP];
‹	Others[EXP]
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\subsubsection{Aggregates (positional array with just others)}
Agg\_Others is an array aggregate with just an others part.


=DOC
type 'EXP €AGG_OTHERS›
=TYPESTRUCT
      = {
	tmark : TMARK,
	others : 'EXP OTHERS
	};
=DESCRIBE
ˇAgg_Others[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	tmark : TMARK;
‹	Others[EXP]
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\subsubsection{Aggregates (named array)}

A range can be just a range attribute which can be represented by one expression. To support this, we introduce a type constructor for a range attribute. 

=DOC
type 'EXP €RANGELOHI›
=TYPESTRUCT
      = {
	lo : 'EXP,
	hi : 'EXP
	};
=DESCRIBE
ˇRange[EXP]¸¸¸¸¸¸¸¸¸¸¸¸
‹	lo, hi : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=SML
datatype 'EXP €RANGE› =
			€RRange› of 'EXP RANGELOHI
		|	€RRangeAttr› of 'EXP
=TEX

Agg\_Choice is an aggregate choice with terms separated by vertical bars.

The datatype for AGG\_CHOICE is introduced in section \ref{datatypedefs}.

πZ
‹	[AGG_CHOICE]
∞

Generic free type definitions are not permitted in Z, so for AGG\_CHOICE we write the following (as per \cite{Spivey92}).

ù[EXP]úúúúúúúúúúúúúúúúúúúúúúúúúúúú
‹	agg_choice_range : Range[EXP] ‡ AGG_CHOICE;
‹	agg_choice_single : EXP ‡ AGG_CHOICE
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	disjoint ßran agg_choice_range, ran agg_choice_single¢ ±
‹
‹	(µ W :  AGG_CHOICE ∑
‹	agg_choice_range ®Range[EXP]© ¿ agg_choice_single ®EXP© Ä W
‹	¥ AGG_CHOICE Ä W)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

A discrete range can be a type mark with an optional range constraint. The abstract syntax is modified to cover this.
=DOC
type 'EXP €DISCRETE_RANGE_CONSTRAINED›
=TYPESTRUCT
      = {
	tmark : TMARK,
	range : 'EXP RANGE
	};
=DESCRIBE
=ENDDOC

=DOC
type ('AGG_CHOICE, 'EXP) €NAMED_ASSOC›
=TYPESTRUCT
      = {
	choice : 'AGG_CHOICE list,
	comp : 'EXP
	};
=DESCRIBE
ˇNamed_Assoc[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	choices :  AGG_CHOICE;
‹	comp : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

Agg\_Named models a named array aggregate.


=DOC
type ('AGG_CHOICE, 'EXP) €AGG_NAMED›
=TYPESTRUCT
      = {
	named_assocs : ('AGG_CHOICE, 'EXP) NAMED_ASSOC list
	};
=DESCRIBE
ˇAgg_Named[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	named_assocs :  Named_Assoc[EXP]
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsubsection{Aggregates (named array with others)}

Agg\_Named\_Others is a named array aggregate with an others part.


=DOC
type ('AGG_CHOICE, 'EXP) €AGG_NAMED_OTHERS›
=TYPESTRUCT
      = {
	tmark : TMARK,
	agg_named : ('AGG_CHOICE, 'EXP) AGG_NAMED, 
	others : ('EXP) OTHERS
	};
=DESCRIBE
ˇAgg_Named_Others[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	tmark : TMARK;
‹	Agg_Named[EXP];
‹	Others[EXP]
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

Rec\_Agg\_Named is a named record aggregate. (Positional record aggregates are modelled by Agg\_Pos at the start of this section). The type of $named\_assocs$ is replaced with that used in named array aggregates to support the full syntax.

\subsubsection{Aggregates (named record)}

=DOC
type ('AGG_CHOICE,'EXP) €REC_AGG_NAMED›
=TYPESTRUCT
      = {
	tmark : TMARK,
	named_assocs : ('AGG_CHOICE, 'EXP) NAMED_ASSOC list
	};
=DESCRIBE
ˇRec_Agg_Named[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	tmark : TMARK;
‹	named_assocs :  (ID ∏ EXP)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC


\subsubsection{Unary Operations}

=DOC
datatype €UNARY_OP› =
			€UOSparkUnaryAdd›
		|	€UOSparkUnaryMinus›
		|	€UOSparkNot›
		|	€UOSparkAbs›;
=DESCRIBE
πZ
‹	UNARY_OP ::=
‹	spark_unary_add | spark_unary_minus | spark_not | spark_abs
∞
=ENDDOC



=DOC
type ('EXP) €UNARY_EXP›
=TYPESTRUCT
      = {
	uop : UNARY_OP,
	right : 'EXP
	};
=DESCRIBE
ˇUnary_Exp[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	op : UNARY_OP;
‹	right : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC


\subsubsection{Binary Expressions}


The binary operators $BOSparkAndThen$, $BOSparkOrElse$ and $BOSparkConcat$ have been added.
=DOC
datatype €BIN_OP› =
			€BOSparkAnd› | €BOSparkAndThen›
		|	€BOSparkOr› | €BOSparkOrElse› | €BOSparkXor›
		|	€BOSparkEq› | €BOSparkNotEq›
		|	€BOSparkLess› | €BOSparkLessEq›
		|	€BOSparkGreater› | €BOSparkGreaterEq›
		|	€BOSparkAdd› | €BOSparkMinus› | €BOSparkTimes›
		|	€BOSparkIntdiv› | €BOSparkMod› | €BOSparkRem›
		|	€BOSparkExpon›
		|	€BOSparkMem› | €BOSparkNotMem›
		|	€BOSparkConcat›;
=DESCRIBE
πZ
‹	BIN_OP ::=
‹	spark_and | spark_or | spark_xor | spark_eq | spark_noteq |
‹	spark_less | spark_less_eq | spark_greater | spark_greater_eq |
‹	spark_add | spark_minus | spark_times | spark_intdiv |
‹	spark_mod | spark_rem | spark_expon | spark_mem | spark_notmem
∞
=ENDDOC


=DOC
type 'EXP €BIN_EXP›
=TYPESTRUCT
      = {
	bop : BIN_OP,
	left : 'EXP,
	right : 'EXP
	};
=DESCRIBE
ˇBin_Exp[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	op : BIN_OP;
‹	left, right : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

Mem\_Range is the membership (or non-membership) of a range.


=DOC
type €MEM_OP›
=TYPESTRUCT
	= BIN_OP;
=DESCRIBE
πZ
‹	MEM_OP ¶ {spark_mem, spark_notmem}
∞
=ENDDOC


$op$ is a reserved word in Standard ML; hence we rename $op$ to $mop$.

=DOC
type ('EXP) €MEM_RANGE›
=TYPESTRUCT
      = {
	left : 'EXP,
	mop : MEM_OP,
	range : 'EXP RANGE
	};
=DESCRIBE
ˇMem_Range[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	left : EXP;
‹	op : MEM_OP;
‹	Range[EXP]
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC


\subsubsection{Attributes}
Attribute models Ada attributes.

ATTRIB denotes the attribute designators FIRST, LAST, SUCC, PRED, POS, VAL, LENGTH and RANGE.


=DOC
type €ATTRIB›
=TYPESTRUCT
	= ID;
=DESCRIBE
πZAX
‹	fst, lst, suc, pred, pos, val, length, range : ID
∞
πZ
‹	ATTRIB ¶ {fst, lst, suc, pred, pos, val, length, range}
∞
=ENDDOC

ATTRIB\_DESIG models the attribute designators.

Generic free type definitions are not permitted in Z, so for ATTRIB\_DESIG we write the following (as per \cite{Spivey92}).

πZ
‹	[ATTRIB_DESIG]
∞

ù[EXP]úúúúúúúúúúúúúúúúúúúúúúúúúúúú
‹	attrib : ATTRIB ‡ ATTRIB_DESIG;
‹	attrib_arg : (ATTRIB ∏ EXP) ‡ ATTRIB_DESIG
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	disjoint ßran attrib, ran attrib_arg¢ ±
‹
‹	(µ W :  ATTRIB_DESIG ∑
‹	attrib ®ATTRIB© ¿ attrib_arg ®ATTRIB ∏ EXP© Ä W
‹	¥ ATTRIB_DESIG Ä W)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸



The datatype for ATTRIB\_DESIG is declared in section \ref{TypeDefExpr}.


The prefix can in fact be a name (i.e., an expression).
=DOC
type ('EXP,'ATTRIB_DESIG) €ATTRIBUTE›
=TYPESTRUCT
      = {
	prefix : 'EXP,
	attribute_desig : 'ATTRIB_DESIG
	};
=DESCRIBE
ˇAttribute¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	prefix : ID;
‹	attrib_desig : ATTRIB_DESIG
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\subsubsection{Indexed Component}
Indexed\_Comp models an array component.


=DOC
type ('EXP) €INDEXED_COMP›
=TYPESTRUCT
      = {
	prefix : 'EXP,
	index : 'EXP
	};
=DESCRIBE
ˇIndexed_Comp[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	prefix, index : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\subsubsection{Selected Component}
Selected\_Comp is a record component.


=DOC
type ('EXP) €SELECTED_COMP›
=TYPESTRUCT
      = {
	prefix : 'EXP,
	selector : ID
	};
=DESCRIBE
ˇSelected_Comp[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	prefix : EXP;
‹	selector : ID
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\subsubsection{Function Calls}
Fun\_Call is a function call.


=DOC
type ('EXP) €FUN_CALL›
=TYPESTRUCT
      = {
	fun_name : ID,
	args : 'EXP list
	};
=DESCRIBE
ˇFun_Call[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	fun_name : ID;
‹	args : seq EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\subsubsection{Qualified Expressions}


=DOC
type 'EXP €QUALIFIED_EXPRESSION›
=TYPESTRUCT
      = {
	tmark : TMARK,
	exp : 'EXP
	};
=DESCRIBE
ˇQualified_Exp[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	ex : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
The ML formulation preserves the type mark for inclusion in the SPARK program.
=ENDDOC
\subsubsection{Type Conversions}


=DOC
type 'EXP €TYPE_CONVERSION›
=TYPESTRUCT
      = {
	tmark : TMARK,
	exp : 'EXP
	};
=DESCRIBE
ˇType_Conv[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	tm : TMARK;
‹	ex : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
The ML names are slightly less terse than the Z ones for historical reasons.
=ENDDOC
\subsubsection{Integer Literals}
INT\_LIT are the integer literals.


=DOC
type €INT_LIT›
=TYPESTRUCT
	= string;
=DESCRIBE
πZ
‹	[INT_LIT]
∞
=ENDDOC


\subsubsection{Auxiliary Expressions}
In the Compliance Notation, a SPARK expression can also be a Z expression (auxiliary expression).

In their use, they are expressions so appear as a branch of expressions.

\subsubsection{Type Definition for Expressions}\label{TypeDefExpr}

In order to reproduce the SPARK program as the user entered it, it is necessary to store bracketing information in the abstract syntax. Also qualified expressions, type conversions, string and character literals have been added.

The Auxiliary expression is represented as a parsed (but not type-checked) Z term. The type inference occurs during VC generation. (Note $id$ is a reserved word in Z, therefore $Id$ is used instead.)

The datatype for EXP is introduced in section \ref{datatypedefs}.

πZ
‹	EXP ::=	
‹		Id ID | int INT_LIT | array_agg_pos (Agg_Pos[EXP]) |
‹		array_agg_pos_others (Agg_Pos_Others[EXP]) |
‹		array_agg_others (Agg_Others[EXP]) |
‹		array_agg_named (Agg_Named[EXP]) |
‹		array_agg_named_others (Agg_Named_Others[EXP]) |
‹		rec_agg_pos (Agg_Pos[EXP]) | rec_agg_named (Rec_Agg_Named[EXP]) |
‹		unary_exp (Unary_Exp[EXP]) | bin_exp (Bin_Exp[EXP]) |
‹		mem_range (Mem_Range[EXP]) | attribute Attribute |
‹		indexed_comp (Indexed_Comp[EXP]) |
‹		selected_comp (Selected_Comp[EXP]) |
‹		fun_call (Fun_Call[EXP]) |
‹		qualified_exp (Qualified_Exp[EXP]) |
‹		type_conv (Type_Conv[EXP]) |
‹		auxiliary_exp Z_EXP
∞

\subsection{Basic Declarations}

The Z specification of the abstract syntax uses a given set declaration to act as a forward declaration of the free type $EXP$, permitting the free type to involve recursion through schema constructions.
Unfortunately, this style is not considered to be type correct in \ProductZ; this is readily circumvented by making the schema constructions generic where necessary.


\subsubsection{Constants}
Const\_Decl models constant declarations.


It is useful to keep a list of the constants declared in the same constant declaration for reproducability. The const component is therefore implemented as a list.
=DOC
type 'EXP €CONST_DECL›
=TYPESTRUCT
      = {
	consts : ID list,
	tm : TMARK,
	expr : 'EXP
	};
=DESCRIBE
ˇConst_Decl[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	const : ID;
‹	tm : TMARK;
‹	expr : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\subsubsection{Enumerated Types}
Enum\_Type\_Def models enumerated types.


=DOC
type €ENUM_TYPE_DEF›
=TYPESTRUCT
      = {
	vals : ID list
	};
=DESCRIBE
ˇEnum_Type_Def¸¸¸¸¸¸¸¸¸¸¸¸
‹	vals : seq ID
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\subsubsection{Array Types}
Array\_Def models array types.

To support the concrete syntax for multi-dimensional arrays, the index is implemented as a list rather than a single instance of a type mark.
=DOC
type €ARRAY_DEF›
=TYPESTRUCT
      = {
	index : TMARK list,
	comp : TMARK
	};
=DESCRIBE
ˇArray_Def¸¸¸¸¸¸¸¸¸¸¸¸
‹	index, comp : TMARK
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC


\subsubsection{Record Types}

Var\_Decl is an Ada variable declaration.

In order to maintain the reproducability of the input, it is necessary to include all the identifiers together in a VAR\_DECL.
=DOC
type €VAR_DECL›
=TYPESTRUCT
      = {
	vars : ID list,
	tmark : TMARK
	};
=DESCRIBE
ˇVar_Decl¸¸¸¸¸¸¸¸¸¸¸¸
‹	var : ID;
‹	tmark : TMARK
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC


Record\_Type\_Def models record types.

=DOC
type €RECORD_TYPE_DEF›
=TYPESTRUCT
      = {
	decl : VAR_DECL list
	};
=DESCRIBE
ˇRecord_Type_Def¸¸¸¸¸¸¸¸¸¸¸¸
‹	decl : seq Var_Decl
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\subsubsection{Integer Types}

An integer type is characterised by its range.

\subsubsection{Real Types}
There is a requirement to support real type in the syntax even though they are not handled formally (hence there is no Z specification for this).
=DOC
type 'EXP €FLOATING_POINT_CONSTRAINT›
=TYPESTRUCT
      = {
	exp : 'EXP,
	range : 'EXP RANGE OPT
	};
=DESCRIBE
=ENDDOC
=DOC
type 'EXP €FIXED_POINT_CONSTRAINT›
=TYPESTRUCT
	= 'EXP FLOATING_POINT_CONSTRAINT;
=DESCRIBE
=ENDDOC

=DOC
type 'EXP €FLOATING_TYPE_DEF›
=TYPESTRUCT
	= 'EXP FLOATING_POINT_CONSTRAINT;
=DESCRIBE
=ENDDOC

=DOC
type 'EXP €FIXED_TYPE_DEF›
=TYPESTRUCT
	= 'EXP FIXED_POINT_CONSTRAINT;
=DESCRIBE
=ENDDOC


\subsubsection{Type Definitions}

The datatype for TYPE\_DEF is introduced in section \ref{datatypedefs}.
πZ
TYPE_DEF ::= enum_type_def Enum_Type_Def | int_type_def (Range[EXP]) |
		uncon_array_def Array_Def | con_array_def Array_Def |
		record_type_def Record_Type_Def
∞

An additional constructor is provided for private types and for reals to support the complete syntax.

\subsubsection{Type Declarations}
Type\_Decl is a type declaration, that is a type definition together with its name.

=DOC
type 'TYPE_DEF €TYPE_DECL›
=TYPESTRUCT
      = {
	name : ID,
	type_def : 'TYPE_DEF
	};
=DESCRIBE
ˇType_Decl¸¸¸¸¸¸¸¸¸¸¸¸
‹	name : ID;
‹	type_def : TYPE_DEF
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\subsubsection{SubTypes}
Subtype\_Decl models subtype declarations.

The datatype for CONSTRAINT is introduced in section \ref{datatypedefs}.

πZ
CONSTRAINT ::= range_con (Range[EXP]) | index_con TMARK
∞

Sub\_Ind is a subtype indication.


=DOC
type 'CONSTRAINT €SUB_IND›
=TYPESTRUCT
      = {
	tmark : TMARK,
	con : 'CONSTRAINT
	};
=DESCRIBE
ˇSub_Ind¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	tmark : TMARK;
‹	con : CONSTRAINT
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC


=DOC
type 'CONSTRAINT €SUBTYPE_DECL›
=TYPESTRUCT
      = {
	name : ID,
	sub_ind : 'CONSTRAINT SUB_IND
	};
=DESCRIBE
ˇSubtype_Decl¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	name : ID;
‹	Sub_Ind
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC


\subsubsection{Deferred Constants}

Abstract syntax is also required for deferred constants.
=DOC
type €DEFERRED_CONST_DECL›
=TYPESTRUCT
      = {
	consts : ID list,
	tmark : TMARK
	};
=DESCRIBE
=ENDDOC
\subsubsection{Private Types}
Private types are part of the syntax.
=DOC
type €PRIVATE_TYPE_DECL›
=TYPESTRUCT
      = {
	id : ID,
	limited : bool
	};
=DESCRIBE
=ENDDOC

\subsubsection{Pragma}\label{pragma}
=DOC
type ('AGG_CHOICE, 'EXP) €PRAGMA›
=TYPESTRUCT
      = {id : ID,
	  args : ('AGG_CHOICE OPT * 'EXP) list};
=DESCRIBE
This type gives the abstract syntax of SPARK pragmas (which are just treated as data to be written out to the SPARK program by the compliance tool).
=ENDDOC
\subsubsection{Annotation}\label{annotation}
=DOC
type €ANNOTATION›
=TYPESTRUCT
      = string list;
=DESCRIBE
This type gives the abstract syntax of SPARK annotations (which are just treated as data to be written out to the SPARK program by the compliance tool).
=ENDDOC
\subsubsection{Basic Declarations}

The datatype for BASIC\_DECL is introduced in section \ref{datatypedefs}.

πZ
BASIC_DECL ::= const_decl (Const_Decl[EXP]) | type_decl Type_Decl |
		subtype_decl Subtype_Decl
∞

\subsection{Datatypes for Free Type Definitions}\label{datatypedefs}

=SML
datatype €CONSTRAINT› =
			€CRange› of EXP RANGE
		|	€CIndex› of EXP list
		|	€CFloating› of EXP FLOATING_POINT_CONSTRAINT
		|	€CFixed› of EXP FIXED_POINT_CONSTRAINT
and €CASE_CHOICE› =
				€CCCaseExp› of EXP
			|	€CCCaseRange› of DISCRETE_RANGE
and €BASIC_DECL› =
			€BDConstDecl› of (EXP) CONST_DECL
		|	€BDDeferredConstDecl› of DEFERRED_CONST_DECL
		|	€BDTypeDecl› of (TYPE_DEF) TYPE_DECL
		|	€BDVarDecl› of VAR_DECL
		|	€BDSubtypeDecl› of (CONSTRAINT) SUBTYPE_DECL
		|	€BDPrivateTypeDecl› of PRIVATE_TYPE_DECL
		|	€BDPragma› of (AGG_CHOICE, EXP) PRAGMA
		|	€BDAnnotation› of ANNOTATION
and €ATTRIB_DESIG› =
			€ADAttrib› of ATTRIB
		|	€ADAttribArg› of (ATTRIB * EXP)
and €DISCRETE_RANGE› =
			€DRRange› of EXP RANGE
		|	€DRConstrained› of EXP DISCRETE_RANGE_CONSTRAINED
and €AGG_CHOICE› =
			€ACAggChoiceRange› of DISCRETE_RANGE
		|	€ACAggChoiceSingle› of EXP

and €TYPE_DEF› =
			€TDEnumTypeDef› of ENUM_TYPE_DEF
		|	€TDIntTypeDef› of EXP RANGE
		|	€TDFloatingTypeDef› of EXP FLOATING_TYPE_DEF
		|	€TDFixedTypeDef› of EXP FIXED_TYPE_DEF
		|	€TDUnconArrayDef› of ARRAY_DEF
		|	€TDConArrayDef› of ARRAY_DEF
		|	€TDRecordTypeDef› of RECORD_TYPE_DEF

and €EXP› =
		€EId› of ID
	|	€EInt› of INT_LIT
	|	€EArrayAggPos› of EXP AGG_POS
	|	€EArrayAggPosOthers› of EXP AGG_POS_OTHERS
	|	€EArrayAggOthers› of EXP AGG_OTHERS
	|	€EArrayAggNamed› of (AGG_CHOICE,EXP) AGG_NAMED
	|	€EArrayAggNamedOthers› of
			(AGG_CHOICE,EXP) AGG_NAMED_OTHERS
	|	€ERecAggPos› of EXP AGG_POS
	|	€ERecAggNamed› of (AGG_CHOICE,EXP) REC_AGG_NAMED
	|	€EUnaryExp› of EXP UNARY_EXP
	|	€EBinExp› of EXP BIN_EXP
	|	€EMemRange› of EXP MEM_RANGE
	|	€EAttribute› of (EXP,ATTRIB_DESIG) ATTRIBUTE
	|	€EIndexedComp› of EXP INDEXED_COMP
	|	€ESelectedComp› of EXP SELECTED_COMP
	|	€EFunCall› of EXP FUN_CALL
	|	€EAuxiliaryExp› of Z_TM
	|	€EQualifiedExp› of EXP QUALIFIED_EXPRESSION
	|	€ETypeConversion› of EXP TYPE_CONVERSION
	|	€EBracketed› of EXP
	|	€EStringLiteral› of string
	|	€ECharacterLiteral› of string;

=TEX

\subsection{Statements}

The Z specification of the abstract syntax uses a given set declaration to act as a forward declaration of the free type $Stmt$, permitting the free type to involve recursion through schema constructions.
Unfortunately, this style is not considered to be type correct in \ProductZ; this is readily circumvented by making the schema constructions generic where necessary.
For example, see section \ref{if-then-else} below.

Following this convention we may now work through the abstract syntax for SPARK statements following \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/1.2}.

\subsubsection{Null}\label{null}

The abstract syntax for null is provided as a data constructor within the type $STMT$ (see section \ref{stmt}).

\subsubsection{Assignment}\label{assignment}


=DOC
type €ASSIGN›
=TYPESTRUCT
      = {
	name : EXP,
	e : EXP
	};
=DESCRIBE
ˇAssign¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	name, E : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\subsubsection{Specification Statements}


=DOC
type €Z_PREDâ0›
=TYPESTRUCT
	= Z_PRED;
=DESCRIBE
πZAX
‹	Z_PREDâ0 :  Z_PRED
∞
=ENDDOC

Labels can appear next to k-slots or specification statements.
=DOC
type €LABEL›
=TYPESTRUCT
      = string;
=DESCRIBE
=ENDDOC
The pre- and post-conditions in the specification are represented as parsed but not type-checked Z terms. This is so that type inference can be performed in the correct environment during VC generation. Note that in the Z, $pre$ is a reserved word, and so we use $Pre$.
=DOC
type €SPEC›
=TYPESTRUCT
      = {
	w : Z_ID list,
	w0 : Z_ID list,
	pre : Z_TM,
	post : Z_TM
	};
=DESCRIBE
ˇSpec¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	w, wâ0 :  Z_ID;
‹	Pre, post : Z_PRED
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Pre é Z_PREDâ0
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
A Specification statement may be labelled.
=DOC
type €SPEC_NO_IVARS›
=TYPESTRUCT
      = {
	spec : SPEC,
	label : LABEL
	};
=DESCRIBE
ˇSpec_No_Ivars¸¸¸¸¸¸¸¸¸¸¸¸
‹	Spec
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	post é Z_PREDâ0
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsubsection{Semicolon}\label{semicolon}

The abstract syntax for semicolon is provided as a data constructor within the type $STMT$ (see section \ref{stmt}).

\subsubsection{If-then-else}\label{if-then-else}


In an nested if statement 

=GFT SPARK Fragment
IF	<cond>	THEN	<stmt>;
ELSIF	<cond>	THEN	<stmt>;
...
ELSIF	<cond>	THEN	<stmt>;
END IF;
=TEX
is equivalent to
=GFT SPARK Fragment
IF	<cond>	THEN	<stmt>;
ELSE IF	<cond>	THEN	<stmt>; 
...
ELSE IF	<cond>	THEN	<stmt>; END IF; ... END IF;
END IF;
=TEX

I.e., ELSIF is the same as writing ELSE IF. In order to make the input reproducable in the SPARK program to be generated, a flag is stored with each abstract representation of the if statement indicating whether the else condition was input as an ELSIF or not.
=DOC
type €COND›
=TYPESTRUCT
	= EXP;
=DESCRIBE
πZAX
‹	COND :  EXP
∞
=ENDDOC

=DOC
type ('STMT) €IF_THEN_ELSE›
=TYPESTRUCT
      = {
	g : COND,
	p : 'STMT,
	q : 'STMT,
	elsif : bool
	};
=DESCRIBE
ˇIf_Then_Else[Stmt]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	G : COND;
‹	P, Q : Stmt
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsubsection{Case}\label{case}


The case choice can be a discrete range. It is added to support the full syntax.
The type definition is introduced in section \ref{datatypedefs}.

πZ
‹	CASE_CHOICE ::= case_exp EXP | case_range (Range[EXP])
∞


A Case statement can have an others part.
=DOC
type 'STMT €CASE_ALTERNATIVE›
=TYPESTRUCT
      = {
	choices : CASE_CHOICE list,
	p : 'STMT
	};
=DESCRIBE
ˇCase_Alternative[Stmt]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	choices :  CASE_CHOICE;
‹	P : Stmt
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
type 'STMT €CASE›
=TYPESTRUCT
      = {
	e : EXP,
	s : ('STMT) CASE_ALTERNATIVE list,
	others : 'STMT
	};
=DESCRIBE
ˇCase[Stmt]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	E : EXP;
‹	s : seqâ1 Case_Alternative[Stmt]
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsubsection{Loop}\label{loop}


As with the translation of $Spec\_No\_Ivars$, we have a choice of how to translate the schema inclusion.
This case is a little more complicated, however, but as there is no overlap between the signature of the included schema and other signature variables, we can adopt the following simple translation.

The till clause may not be present in which case the t component will be true. However we make t optional to reflect the concrete syntax so that the SPARK program can be reproduced authentically.

A loop body may be a sequence of statements in which case the treatment of the loop can only be informal with respect to generating verification conditions: hence $'STMT$ rather than $SPEC_NO_IVARS$.
A loop without an iteration scheme can have a name, so we introduce an additional type called NAMED\_LOOP.
=DOC
type 'STMT €LOOP›
=TYPESTRUCT
      = {
	t : Z_TM OPT,
	stmt : 'STMT
	};
=DESCRIBE
The till part is represented as a parsed (but not type-checked) Z term to enable type inference to happen in the correct environment during VC generation.
ˇLoop¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	T : Z_PRED;
‹	Spec_No_Ivars
˜¸¸¸¸¸¸
‹	T é Z_PREDâ0
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
=DOC
type 'STMT €NAMED_LOOP›
=TYPESTRUCT
      = {
	name : ID,
	t : Z_TM OPT,
	stmt : 'STMT
	};
=DESCRIBE
The till part is represented as a parsed (but not type-checked) Z term to enable type inference to happen in the correct environment during VC generation.
=ENDDOC

\subsubsection{While Loop}\label{while-loop}

Loops can have names, so a name is introduced into the abstract representation.
=DOC
type 'STMT €WHILE›
=TYPESTRUCT
      = {
	name : ID OPT,
	g : COND,
	loop : 'STMT LOOP
	};
=DESCRIBE
ˇWhile¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	G : COND;
‹	Loop
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsubsection{For Loop (Static Bounds)}\label{for-static}


Loops can have names so a field in the abstract representation is reserved for name. Also we record in the abstract syntax the direction of the loop and the type mark for the purposes of reproducing the SPARK program.

=DOC
type €STATIC_EXP›
=TYPESTRUCT
	= EXP;
=ENDDOC
πZAX
‹	STATIC_EXP :  EXP
∞
=DOC
datatype €LOOP_DIRECTION› =
				€LDForwards›
			|	€LDReverse›;
=DESCRIBE
=ENDDOC
A range component is used rather than a lo-hi pair in order to support the possibility of representing a range attribute.
=DOC
type 'STMT €FOR_STATIC›
=TYPESTRUCT
      = {
	name : ID OPT,
	i : ID,
	tmark : ID,
	range : EXP RANGE,
	dir : LOOP_DIRECTION,
	loop : 'STMT LOOP
	};
=DESCRIBE
ˇFor_Static¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	i : ID;
‹	lo, hi : STATIC_EXP;
‹	Loop
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsubsection{For Loop (Type Mark as Range)}\label{for-typemark}


FOR\_TMARK is augmented in the same way as for FOR\_STATIC.

=DOC
type 'STMT €FOR_TMARK›
=TYPESTRUCT
      = {
	name : ID OPT,
	i : ID,
	tmark : TMARK,
	dir : LOOP_DIRECTION,
	loop : 'STMT LOOP
	};
=DESCRIBE
ˇFor_Tmark¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	i : ID;
‹	tmark : TMARK;
‹	Loop
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsubsection{Exit Statement (with condition)}\label{exit}


=DOC
type €EXIT_WHEN›
=TYPESTRUCT
      = {
	g : COND
	};
=DESCRIBE
ˇExit_When¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	G : COND
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsubsection{Exit Statement}\label{exit-stmt}
$Exit$ is implemented as a data constructor as part of $STMT$ (see section \ref{stmt}).


\subsubsection{Return}\label{return}


=DOC
type €RETURN›
=TYPESTRUCT
      = {
	e : EXP
	};
=DESCRIBE
ˇReturn¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	E : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsubsection{Procedure Call}\label{procedure-call}


The actual part can be a positional parameter association or a named parameter association.

=DOC
datatype ('AGG_CHOICE, 'EXP) €ACTUALS› =
			€APositional› of EXP list
		|	€ANamed› of ('AGG_CHOICE, 'EXP) NAMED_ASSOC list;
=DESCRIBE
=ENDDOC
=DOC
type ('AGG_CHOICE,'EXP) €PROC_CALL›
=TYPESTRUCT
      = {
	name : ID,
	actuals : ('AGG_CHOICE,'EXP) ACTUALS
	};
=DESCRIBE
ˇProc_Call¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	name : ID;
‹	actuals : seq EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC



=DOC
type ('AGG_CHOICE,'EXP) €PROC_CALL_NO_IVARS›
=TYPESTRUCT
	= ('AGG_CHOICE,'EXP) PROC_CALL;
=DESCRIBE
πZAX
‹	retrieve_spec_stmt : ID ﬂ Spec
∞
ˇProc_Call_No_Ivars¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Proc_Call
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	(retrieve_spec_stmt name).post é Z_PREDâ0
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC


\subsubsection{$Stmt$}\label{stmt}
\ProductZ\ is currently non-standard in that it neither requires nor
allows the chevrons around the operands in a free type definition.
This mismatch with the Z standard is planned to be remedied in a future release of the system.


K-Slots are required in the abstract syntax as place markers so that when the SPARK program is reproduced from the abstract syntax, the expansions can be put back into the correct places.
=DOC
type €K_SLOT›
=TYPESTRUCT
      = {
	content : string,
	label : LABEL
	};
=DESCRIBE
=ENDDOC
Note that $STImplicitNull$ has been introduced because there are cases where a null statement is required in the syntax (e.g., in $SSpecIvars$ of \ref{statement}) which might not have been present in the input. Therefore such a statement is recorded in the abstract syntax as an implicit null statement, denoting that it should not appear subsequently in the SPARK program. 
=DOC
datatype €STMT›
		= 	€STNull›
		| 	€STImplicitNull›
		|	€STAssign› of ASSIGN
		|	€STSpecNoIvars› of SPEC_NO_IVARS
		|	€STSemicolon› of (STMT * STMT)
		|	€STIfThenElse› of  STMT IF_THEN_ELSE
		|	€STCase› of STMT CASE
		|	€STLoop› of STMT LOOP
		|	€STNamedLoop› of STMT NAMED_LOOP
		|	€STWhile› of STMT WHILE
		|	€STForStatic› of STMT FOR_STATIC
		|	€STForTmark› of STMT FOR_TMARK
		|	€STExitWhen› of EXIT_WHEN
		|	€STExit›
		|	€STRet› of RETURN
		|	€STProcNoIvars› of (AGG_CHOICE,EXP) PROC_CALL_NO_IVARS
		|	€STKSlot› of K_SLOT
		|	€STPragma› of (AGG_CHOICE, EXP) PRAGMA
		|	€STAnnotation› of ANNOTATION;
=DESCRIBE
πZ
	Stmt	::= 	null
		|	assign Assign
		|	spec_no_ivars Spec_No_Ivars
		|	semicolon (Stmt ∏ Stmt)
		|	if_then_else (If_Then_Else[Stmt])
		|	case (Case[Stmt])
		|	loop Loop
		|	while While
		|	for_static For_Static
		|	for_tmark For_Tmark
		|	exit_when Exit_When
		|	exit
		|	ret Return
		|	proc_no_ivars Proc_Call_No_Ivars
∞
=ENDDOC
\pagebreak
\subsubsection{Specification (with initial variables)}\label{specification-ivars}

A specification statement may be labelled.
=DOC
type €SPEC_IVARS› 
=TYPESTRUCT
      = {
	spec :SPEC,
	label : LABEL
	};
=DESCRIBE
ˇSpec_Ivars¸¸¸¸¸¸¸¸¸¸¸¸
‹	Spec
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	post ç Z_PREDâ0
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsubsection{For Loop (Non-Static Bounds)}\label{for-non-static-bounds}


A loop may have an optional name. 

A range component is used rather than a lo-hi pair in order to support the possibility of representing a range attribute.
=DOC
type €FOR_NON_STATIC›
=TYPESTRUCT
      = {
	name : ID OPT,
	i : ID,
	range : STATIC_EXP RANGE,
	loop : STMT LOOP
	};
=DESCRIBE
ˇFor_Non_Static¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	i : ID;
‹	lo, hi : EXP;
‹	Loop
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹		lo é STATIC_EXP
‹	≤
‹		hi é STATIC_EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsubsection{Logical Constants}\label{logical-constants}


The function $free\_id$ may readily and realistically be implemented using existing \Product\
syntax functions.
$t$ represents the set of which $x$ is a member.
$t$ is represented as a parsed Z term. Type inference occurs during VC generation when the appropriate $Z\_EXP$ is generated. The values for $e$ and $pre1$ are filled in at this time.
Logical constants may also have a label.
=DOC
type €LOG_CON›
=TYPESTRUCT
      = {
	x : Z_ID,
	t : Z_TM,
	e : Z_EXP,
	spec : SPEC,
	pre1 : Z_EXP,
	label : LABEL
	};
=DESCRIBE
πZAX
‹	free_ids : Z_EXP ≠  Z_ID
∞

ˇLog_Con¸¸¸¸¸¸¸¸¸¸¸¸
‹	X : Z_ID;
‹	E : Z_EXP;
‹	Spec;
‹	preâ1 : Z_PRED
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Pre = z_and(z_eq(zid X, E), preâ1);
‹	X é free_ids E
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC
\subsubsection{Procedure Calls (initial variables in spec)}\label{procedure-calls}


=DOC
type ('AGG_CHOICE,'EXP) €PROC_CALL_IVARS›
=TYPESTRUCT
	= ('AGG_CHOICE,'EXP) PROC_CALL;
=DESCRIBE
ˇProc_Call_Ivars¸¸¸¸¸¸¸¸¸¸¸¸
‹	Proc_Call
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	(retrieve_spec_stmt name).post ç Z_PREDâ0
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

\subsubsection{Statement}\label{statement}

=DOC
datatype €STATEMENT› =
		 	€SStmt› of STMT
		|	€SSpecIvars› of SPEC_IVARS * STMT
		|	€SForNonStatic› of FOR_NON_STATIC * STMT
		|	€SLogCon› of LOG_CON * STMT
		|	€SProcIvars› of
				(AGG_CHOICE,EXP) PROC_CALL_IVARS * STMT;
=DESCRIBE
πZ
	Statement
		::= 	stmt Stmt
		|	spec_ivars (Spec_Ivars ∏ Stmt)
		|	for_non_static (For_Non_Static ∏ Stmt)
		|	log_con (Log_Con ∏ Stmt)
		|	proc_ivars (Proc_Call_Ivars ∏ Stmt)
∞
=ENDDOC

\subsection{Subprogram Declarations}
The abstract syntax in this section and in the rest of the document is constructed from an abstraction of the concrete syntax of SPARK. It is not specified formally in \cite{DRA/CIS/CSE3/TR/94/27/1.2}, hence there is no transcribed Z specification here.
=DOC
datatype €MODE› =	MSparkIn
		|	MSparkOut
		|	MSparkInOut;
=DESCRIBE
=ENDDOC
=DOC
type €PARAMETER_SPECIFICATION›
=TYPESTRUCT
      = {
	idlist : ID list,
	mode : MODE,
	name : TMARK
	};
=DESCRIBE
=ENDDOC
=DOC
type €PROCEDURE_SPECIFICATION›
=TYPESTRUCT
      = {
	name : ID,
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT,
	annotation : ANNOTATION
	};
=DESCRIBE
=ENDDOC
=DOC
type €FUNCTION_SPECIFICATION›
=TYPESTRUCT
      = {
	designator : ID,
	return : TMARK,
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT,
	annotation : ANNOTATION
	};
=DESCRIBE
=ENDDOC
=DOC
datatype €SUBPROGRAM_SPECIFICATION› =
			€SSProcedure› of PROCEDURE_SPECIFICATION
		|	€SSFunction› of FUNCTION_SPECIFICATION;
=DESCRIBE
=ENDDOC
=DOC
type €PROCEDURE_DECLARATION›
=TYPESTRUCT
	= PROCEDURE_SPECIFICATION;
=DESCRIBE
=ENDDOC
=DOC
type €FUNCTION_DECLARATION›
=TYPESTRUCT
	= FUNCTION_SPECIFICATION;
=DESCRIBE
=ENDDOC
=DOC
type €SUBPROGRAM_DECLARATION›
=TYPESTRUCT
	= SUBPROGRAM_SPECIFICATION;
=DESCRIBE
=ENDDOC
\subsection{Procedure and Function Calls}
=DOC
type €NAMED_PARAM›
=TYPESTRUCT
      = {
	formal : ID,
	actual : EXP
	};
=DESCRIBE
=ENDDOC
=DOC
type €NAMED_PARAMETER_ASSOC›
=TYPESTRUCT
      = {
	params: NAMED_PARAM list
	};
=DESCRIBE
=ENDDOC
=DOC
type €POS_PARAMETER_ASSOC›
=TYPESTRUCT
      = {
	params : EXP list
	};
=DESCRIBE
=ENDDOC
=DOC
datatype €ACTUAL_PARAMETER_PART› = 
			€APPNamed› of NAMED_PARAMETER_ASSOC
		|	€APPPositional› of POS_PARAMETER_ASSOC;
=DESCRIBE
=ENDDOC
\subsection{Package Declaration}
=DOC
type €OPERATOR_SYMBOL›
=TYPESTRUCT
	= string;
=DESCRIBE
=ENDDOC
=DOC
type €FUNCTION_RENAMING›
=TYPESTRUCT
      = {
	opsym1 : OPERATOR_SYMBOL,
	formal_part : PARAMETER_SPECIFICATION list,
	tmark : TMARK,
	name : ID,
	opsym2 : OPERATOR_SYMBOL
	};
=DESCRIBE
=ENDDOC
=DOC
type €SUBPROGRAM_RENAMING›
=TYPESTRUCT
      = {
	subprogram_specification : SUBPROGRAM_SPECIFICATION,
	name1 : ID,
	name2 : ID
	};
=DESCRIBE
=ENDDOC
=DOC
datatype €RENAMING_DECLARATION› =
			€RDFunction› of FUNCTION_RENAMING
		|	€RDSubprogram› of SUBPROGRAM_RENAMING;
=DESCRIBE
=ENDDOC
=DOC
type €LENGTH_CLAUSE›
=TYPESTRUCT
      = {
	attribute : EXP,
	exp : EXP
	};
=DESCRIBE
=ENDDOC
=DOC
type €ENUMERATION_REPRESENTATION_CLAUSE›
=TYPESTRUCT
      = {
	name : ID,
	exp : EXP
	};
=DESCRIBE
=ENDDOC
=DOC
type €COMPONENT_CLAUSE›
=TYPESTRUCT
      = {
	name : ID,
	exp : EXP,
	range : EXP RANGE
	};
=DESCRIBE
=ENDDOC
=DOC
type €RECORD_REPRESENTATION_CLAUSE›
=TYPESTRUCT
      = {
	name : ID,
	alignment_opt : EXP OPT,
	component_pack : COMPONENT_CLAUSE list
	};
=DESCRIBE
=ENDDOC
=DOC
type €ADDRESS_CLAUSE›
=TYPESTRUCT
      = {
	name : ID,
	exp : EXP
	};
=DESCRIBE
=ENDDOC
=DOC
datatype €REPRESENTATION_CLAUSE› =
		€RCLength› of LENGTH_CLAUSE
	|	€RCEnumeration› of ENUMERATION_REPRESENTATION_CLAUSE
	|	€RCRecord› of RECORD_REPRESENTATION_CLAUSE
	|	€RCAddress› of ADDRESS_CLAUSE;
=DESCRIBE
=ENDDOC
=DOC
type 'DECLARATION €PROCEDURE_BODY›
=TYPESTRUCT
      = {
	procedure_spec : PROCEDURE_SPECIFICATION,
	declarative_part : 'DECLARATION list,
	statement : STATEMENT
	};
=DESCRIBE
=ENDDOC
=DOC
type 'DECLARATION €FUNCTION_BODY›
=TYPESTRUCT
      = {
	function_spec : FUNCTION_SPECIFICATION,
	declarative_part : 'DECLARATION list,
	statement : STATEMENT
	};
=DESCRIBE
=ENDDOC
=DOC
type 'DECLARATION €PACKAGE_BODY›
=TYPESTRUCT
      = {
	name : ID,
	decls : 'DECLARATION list,
	statement : STATEMENT,
	annotation : ANNOTATION
	};
=DESCRIBE
=ENDDOC
=DOC
type 'DECLARATION €PACKAGE_DECLARATION›
=TYPESTRUCT
      = {
	name : ID,
	visible_decs : 'DECLARATION list,
	private_decs : 'DECLARATION list,
	annotation : ANNOTATION
	};

=DESCRIBE
=ENDDOC
Auxiliary expressions are resolved by the presence of a using declaration. This is specified in \cite[volume 1]{DRA/CIS/CSE3/TR/94/27/1.2}. It is necessary to extend the abstract syntax to include ``using'' declarations.

Note that the component $basic\_decls$ is added in case we need to reproduce the user's input. The component $concrete\_vars$ is a subset of the basic declarations which are variables. 

$t$ represents the set of which $aux$ is a member.

=DOC
type €AUX_VAR›
=TYPESTRUCT
      = {
	aux : Z_ID,
	t : Z_TM
	};
=DESCRIBE
ˇAUX_VAR¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	aux : Z_Decl[Z_EXP]
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC

=DOC
type €USING_DEC›
=TYPESTRUCT
      = {
	aux : Z_TM,
	concrete_vars : VAR_DECL list,
	basic_decls : BASIC_DECL list,
	invariant : Z_TM
	};
=DESCRIBE
ˇUSING_DEC¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	aux : Z_ID;
‹	concrete_vars :  Var_Decl;
‹	invariant : Z_PRED
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=ENDDOC


=DOC
datatype €DEC_K_SLOT_TYPE› =
			€DKPrivate›
		|	€DKVisible›
		|	€DKDeclaration›;
=DESCRIBE
This datatype is used in the datatype $DECLARATION$s to destinguish between the three types of k-slot which can occur as a declaration.
=ENDDOC

=DOC
datatype €DECLARATION› =
		€DDeclarationKSlot› of (K_SLOT * DEC_K_SLOT_TYPE)
	|	€DRenamingDeclaration› of RENAMING_DECLARATION
	|	€DBasicDecl› of BASIC_DECL
	|	€DRepresentationClause› of REPRESENTATION_CLAUSE
	|	€DProperBody› of PROPER_BODY
	|	€DProcedureDeclaration› of PROCEDURE_DECLARATION
	|	€DFunctionDeclaration› of FUNCTION_DECLARATION
	|	€DPackageDeclaration› of DECLARATION PACKAGE_DECLARATION
	|	€DProcedureStub› of PROCEDURE_DECLARATION
	|	€DFunctionStub› of FUNCTION_DECLARATION
	|	€DPackageStub› of ID
	|	€DExternalProcedureStub› of PROCEDURE_DECLARATION
	|	€DExternalFunctionStub› of FUNCTION_DECLARATION
	|	€DAuxiliary› of AUX_VAR
	|	€DUsing› of USING_DEC
=DESCRIBE
=ENDDOC
=DOC
and €PROPER_BODY› =	€PBProcedure› of DECLARATION PROCEDURE_BODY
		|	€PBFunction› of DECLARATION FUNCTION_BODY
		|	€PBPackage› of DECLARATION PACKAGE_BODY;
=DESCRIBE
=ENDDOC

=DOC
type €COMP_SUBUNIT›
=TYPESTRUCT
      = {
	name : ID,
	proper_body : PROPER_BODY
	};
=DESCRIBE
=ENDDOC
=DOC
datatype €COMPILATION_UNIT› =
		€CUPackageDeclaration› of DECLARATION PACKAGE_DECLARATION
	|	€CUProperBody› of PROPER_BODY
	|	€CUSubUnit› of COMP_SUBUNIT;

=DESCRIBE
=ENDDOC
=DOC
type €REFINED_BY›
=TYPESTRUCT
      = {
	label : LABEL,
	statement : STATEMENT
	};
=DESCRIBE
=ENDDOC
=DOC
type €REPLACED_BY›
=TYPESTRUCT
      = {
	label : LABEL,
	statement : STATEMENT
	};
=DESCRIBE
=ENDDOC
=DOC
type €REPLACED_BY_DECL›
=TYPESTRUCT
      = {
	label : LABEL,
	decls : DECLARATION list
	};
=DESCRIBE
=ENDDOC
=DOC
type €REPLACED_BY_VISIBLE_PART›
=TYPESTRUCT
      = {
	label : LABEL,
	visible : DECLARATION list
	};
=DESCRIBE
=ENDDOC
=DOC
type €REPLACED_BY_PRIVATE_PART›
=TYPESTRUCT
      = {
	label : LABEL,
	private : DECLARATION list
	};
=DESCRIBE
=ENDDOC
=DOC
type €CONTEXT_COMPILATION_UNIT›
=TYPESTRUCT
      = {
	context : ID list,
	comp_unit : COMPILATION_UNIT,
	pragmas : (AGG_CHOICE, EXP) PRAGMA list,
	annotation : ANNOTATION
	};
=DESCRIBE
=ENDDOC
=DOC
datatype €KSLOT_COMPILATION_UNIT› =
			€KCUKSlot› of K_SLOT
		|	€KCUUnit› of CONTEXT_COMPILATION_UNIT
		|	€KCUPragma› of (AGG_CHOICE, EXP) PRAGMA;
=DESCRIBE
=ENDDOC
=DOC
type €REPLACED_BY_COMP›
=TYPESTRUCT
      = {
	label : LABEL,
	comp : KSLOT_COMPILATION_UNIT list
	};
=ENDDOC
=DOC
type €REPLACED_BY_ARBITRARY_ADA›
=TYPESTRUCT
      = {
	label : LABEL,
	replacement : string
	};
=DESCRIBE
This is the type for an arbitrary Ada replacment, which for the compliance tool,  is just textual data to be passed into the output SPARK program.
=ENDDOC
=DOC
datatype €WEB_CLAUSE› = 
			€WCCompilation› of KSLOT_COMPILATION_UNIT list
		|	€WCReplacedByCompilation› of REPLACED_BY_COMP
		|	€WCReplacedByPrivatePart› of REPLACED_BY_PRIVATE_PART
		|	€WCReplacedByVisiblePart› of REPLACED_BY_VISIBLE_PART
		|	€WCReplacedByDecl› of REPLACED_BY_DECL
		|	€WCReplacedByArbitraryAda› of REPLACED_BY_ARBITRARY_ADA
		|	€WCRefinedBy› of REFINED_BY
		|	€WCReplacedBy› of REPLACED_BY;
=DESCRIBE
=ENDDOC

\section{EPILOGUE}

=SML
end (* local ... in *);
end (* of signature CNTypes *);
=TEX

\section{TEST POLICY}
There are no module tests for the design in this document since it specifies no functions.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



