%  dtd502.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of the Abstract Syntax for SPARK}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD502}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{
This document contains the detailed design for the abstract syntax for SPARK}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion~\FormatDate{$Date$%
}) ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the abstract syntax for SPARK.

\subsection{Introduction}

\subsubsection{Purpose and Background}


\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{PRELIMINARIES}
Before we do anything else, we set up a {\Product} theory, $vc\_gen$ to hold the Z specification which is contained in the document.
=SML
new_theory"vc_gen";
new_parent"z_library";
=TEX
We need either dummy versions of or {\em ad hoc} substitutes for such of material of \cite{DRA/CIS/CSE3/SWI/WP/2} as is used in \cite{DRA/CIS/CSE3/SWI/WP/1}.
These are given in the remaining subsections of this section.

\subsection{Expressions and Predicates}
We take the SPARK expressions, $EXP$ in the Z specification as a given type since for present purposes we do not wish to discuss the internal details.

¹Z
	[ÛIDİ, ÛEXPİ]
°

¹Z
	[ÛZ_IDİ, ÛZ_EXPİ, ÛZ_PREDİ]
°
¹Z
	[ÛZ_BINOPİ]
°
ÿÛZ_Bin_Expİüüüüüüüüüüüü
Ü	zop : Z_BINOP;
Ü	zleft, zright : Z_EXP
ˆüüüüüüüüüüüüüüüüüüüüü
¹ZAX
Ü	z_add : Z_BINOP
°
¹ZAX
Ü	z_bin_exp : Z_Bin_Exp ­ Z_EXP;
Ü	zid : Z_ID ­ Z_EXP;
Ü	z_num : ú ­ Z_EXP;
Ü	z_set : ğ Z_EXP ­ Z_EXP;
Ü	z_override : Z_EXP ¸ Z_EXP ­ Z_EXP;
Ü	z_rng : Z_EXP ¸ Z_EXP ­ Z_EXP;
Ü	z_maplet : Z_EXP ¸ Z_EXP ­ Z_EXP
°
¹ZAX
Ü	z_eq : Z_EXP ¸ Z_EXP ­ Z_PRED;
Ü	z_noteq : Z_EXP ¸ Z_EXP ­ Z_PRED;
Ü	z_less_eq : Z_EXP ¸ Z_EXP ­ Z_PRED;
Ü	z_greater : Z_EXP ¸ Z_EXP ­ Z_PRED;
Ü	z_elem : Z_EXP ¸ Z_EXP ­ Z_PRED
°
¹ZAX
Ü	z_and : Z_PRED ¸ Z_PRED ­ Z_PRED
°

¹ZAX
Ü	trans_id : ID ­ Z_ID;
Ü	trans_exp : EXP ­ Z_EXP
°

For simplicity, we use Z expressions represented as HOL terms to represent SPARK expressions.
Thus we can pretend that the expression translation of \cite{DRA/CIS/CSE3/SWI/WP/2} is just the identify function.
Note that the use of HOL terms to represent Z expressions is realistic --- and lies at the heart of the technique of ``semantic embedding'' used to implement support for reasoning in Z with \Product.

\subsection{Sequents, Declarations and VCs}
ÿÛSequentİüüüüüüüüüüüü
Ü	H : ğ Z_PRED;
Ü	c : Z_PRED
ˆüüüüüüüüüüüüüüüüüüüüü
A type of sequents adequate to represent sequents in the above sense is supplied as part of \Product.
It is simplifies matters later on to use this type here.
ÿÛZ_Declİüüüüüüüüüüüü
Ü	zvar : Z_ID;
Ü	zexp : Z_EXP
ˆüüüüüüüüüüüüüüüüüüüüü
¹Z
	VC ¦ (ğ Z_Decl ¸ Sequent)
°
The semantics of a $VC$ are presumably similar to those of the sequents used in Appendix F of the draft Z Standard, \cite{zip/prg/92/121} (which incorporate declarations in their antecedents).
I.e. the declarations act, in effect, as additional assumptions, which also serve to constrain the types of variables in the rest of the sequent.
In \Product, the semantics of this is probably best carried by representing a $VC$ as a sequent, with the declarations included in the assumptions.
Nonetheless we give Standard ML declarations reflecting the above Z.

\pagebreak


\section{ABSTRACT SYNTAX}
\section{SYNTAX OF SPARK STATEMENTS}
The Z specification of the abstract syntax uses a given set declaration to act as a forward declaration of the free type $Stmt$, permitting the free type to involve recursion through schema constructions.
Unfortunately, this style is not considered to be type correct in \ProductZ; this is readily circumvented by making the schema constructions generic where necessary.
For example, see section \ref{if-then-else} below.

Following this convention we may now work through the abstract syntax for SPARK statements following \cite{DRA/CIS/CSE3/SWI/WP/1}.

\subsection{Assignment}\label{assignment}

ÿÛAssignİüüüüüüüüüüüüüüüüü
Ü	x : ID;
Ü	E : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
\subsection{Array Assignment}\label{array-assignment}

ÿÛArray_Assignİüüüüüüüüüüüüüüüüü
Ü	a : ID;
Ü	E‰1, E‰2 : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
\subsection{Specification (No initial variables)}\label{specification-no-ivars}
¹ZAX
Ü	ÛZ_PRED‰0İ : ğ Z_PRED
°
($pre$ has to be renamed to $Pre$ below, because $pre$ is a reserved identifier.)

ÿÛSpecİüüüüüüüüüüüüüüüüü
Ü	w, w‰0 : ğ Z_ID;
Ü	Pre, post : Z_PRED
÷üüüüüüüüüüüüüüü
Ü	Pre  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü

ÿÛSpec_No_Ivarsİüüüüüüüüüüüü
Ü	Spec
÷üüüüüüüüüüüüüüü
Ü	post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü
=TEX
In the translation into Standard ML of a schema which includes another,
we have various choices.
In this simple case where the new schema has the same signature as the included one, we just say that the new type is an abbreviation for the old one.
\subsection{If-then-else}\label{if-then-else}

¹ZAX
Ü	ÛCONDİ : ğ EXP
°

ÿÛIf_Then_Elseİ[STMT]üüüüüüüüüüüüüüüüü
Ü	G : COND;
Ü	P, Q : STMT
ˆüüüüüüüüüüüüüüüüüüüüü
\subsection{Case}\label{case}

ÿÛCase_Segİ[STMT]üüüüüüüüüüüüüüüüü
Ü	when : ğ EXP;
Ü	P : STMT
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
ÿÛCaseİ[STMT]üüüüüüüüüüüüüüüüü
Ü	E : EXP;
Ü	s : seq‰1 Case_Seg[STMT]
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
The fact that the list of arms may not be empty is not captured by the above.
The following exception is available for later code to raise if this constraint is violated.
\subsection{Loop}\label{loop}

ÿÛLoopİüüüüüüüüüüüüüüüüü
Ü	u : Z_PRED;
Ü	Spec_No_Ivars
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
As with the translation of $Spec\_No\_Ivars$, we have a choice of how to translate the schema inclusion.
This case is a little more complicated, however, but as there is no overlap between the signature of the included schema and other signature variables, we can adopt the following simple translation.
\subsection{While Loop}\label{while-loop}
ÿÛWhileİüüüüüüüüüüüüüüüüü
Ü	G : COND;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
\subsection{For Loop (Values as Bounds)}\label{for-value}

¹ZAX
Ü	ÛVALUEİ : ğ EXP
°
¹Z
Ü	rel	_ less_eq _
°
¹ZAX
Ü	_ less_eq _ : VALUE ª VALUE
°

ÿÛFor_Valueİüüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	lo, hi : VALUE;
Ü	Loop
÷üüüüüüüüüüüüüüüü
Ü	lo less_eq hi
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
\subsection{Exit}\label{exit}

ÿÛExitİüüüüüüüüüüüüüüüüü
Ü	G : COND
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
\subsection{Return}\label{return}

ÿÛReturnİüüüüüüüüüüüüüüüüü
Ü	E : EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
\subsection{Procedure Call}\label{procedure-call}

ÿÛProc_Callİüüüüüüüüüüüüüüüüü
Ü	name : ID;
Ü	actuals : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
\subsection{$Stmt$}\label{stmt}
\ProductZ\ is currently non-standard in that it neither requires nor
allows the chevrons around the operands in a free type definition.
This mismatch with the Z standard is planned to be remedied in a future release of the system.
¹Z
	ÛStmtİ	::= 	Ûnullİ
		|	Ûassignİ (Assign)
		|	Ûarr_assignİ (Array_Assign)
		|	Ûspec_no_ivarsİ (Spec_No_Ivars)
		|	Ûsemicolonİ (Stmt ¸ Stmt)
		|	Ûif_then_elseİ (If_Then_Else[Stmt])
		|	Ûcaseİ (Case[Stmt])
		|	Ûloopİ (Loop)
		|	Ûwhileİ (While)
		|	Ûfor_valueİ (For_Value)
		|	Ûexitİ (Exit)
		|	Ûretİ (Return)
		|	Ûproc_no_ivarsİ (Proc_Call)
°
=TEX
The constructors $case$ and $while$ must be misspelt in the Standard ML datatype twhich implements the above because they are reserved identifiers.
\pagebreak
\subsection{For Loop (Bounds with Variables)}\label{for-var}

ÿÛFor_Varİüüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	lo, hi : EXP;
Ü	Loop
÷üüüüüüüüüüüüüüüü
Ü		lo  VALUE
Ü	²
Ü		hi  VALUE
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
\subsection{Specification (with initial variables)}\label{specification-ivars}

ÿÛSpec_Ivarsİüüüüüüüüüüüü
Ü	Spec
÷üüüüüüüüüüüüüüü
Ü	post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü
=TEX
\subsection{Logical Constants}\label{logical-constants}
¹ZAX
Ü	free_ids : Z_EXP ­ ğ Z_ID
°

ÿÛLog_Conİüüüüüüüüüüüü
Ü	X : Z_ID;
Ü	E : Z_EXP;
Ü	Spec;
Ü	pre‰1 : Z_PRED
÷üüüüüüüüüüüüüüü
Ü	Pre = z_and(z_eq(zid X, E), pre‰1);
Ü	X  free_ids E
ˆüüüüüüüüüüüüüüüüüüüüü
=TEX
The functions $free\_id$ may readily and reallistically be implemented using existing \Product\
syntax functions.
\subsection{Statement}\label{statement}
¹Z
	ÛStatementİ
		::= 	Ûstmtİ (Stmt)
		|	Ûfor_expİ (For_Var ¸ Stmt)
		|	Ûspec_ivarsİ (Spec_Ivars ¸ Stmt)
		|	Ûlog_conİ (Log_Con ¸ Stmt)
		|	Ûproc_ivarsİ (Proc_Call ¸ Stmt)
°
=TEX

=DOC
=DESCRIBE
=ENDDOC

\section{EPILOGUE}
=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



