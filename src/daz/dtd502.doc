%  dtd502.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Compliance Notation Lexis and Abstract Syntax}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD502}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan&WIN01}
\TPPabstract{
This document contains the detailed design for the lexis and abstract syntax for Compliance Notation}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion~\FormatDate{$Date$%
}) ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the abstract syntax for CN.

\subsection{Introduction}

\subsubsection{Purpose and Background}


\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{LEXIS}
=DOC
signature €CNTypes› = sig
=DESCRIBE
This is the signature for the structure containing the types required for Compliance Notation.
=ENDDOC

=DOC
datatype €CN_LEX_CLASS›
			= €LCAbstractExpression›
			| €LCAbs› | €LCAmpersand› | €LCAnd› | €LCArray› |€LCAt›
			| €LCBar› |€LCBBody› | €LCBecomes› | €LCBegin›
			| €LCCase›| €LCCharacterLiteral›
			| €LCColon› | €LCComma› | €LCCompLabel› | €LCConstant›
			| €LCCon› | €LCCrd› | €LCDecLabel› | €LCDelta›
			| €LCDigits› | €LCDiv›| €LCDotDot› | €LCDot› | €LCElse›
			| €LCElsIf› | €LCEnd› | €LCEquals› | €LCExit›
			| €LCFatDot› | €LCFor› | €LCFunctionName› | €LCFunction›
			| €LCGoesTo› | €LCGreaterEquals›
			| €LCGreaterThan› | €LCIdentifier› | €LCIf›
			| €LCIn› | €LCIs›
			| €LCKSlot› | €LCLessEquals› | €LCLessGreat› | €LCLessThan›
			| €LCLimited› | €LCLoop› | €LCMinus›
			| €LCMod› | €LCNotEquals› | €LCNot› | €LCNull›
			| €LCNumericLiteral› | €LCOf›
			| €LCOrd› | €LCOr› | €LCOthers› | €LCOut›
			| €LCPackage› | €LCPlus›
			| €LCPPartLabel› | €LCPrime› | €LCPrimedIdentifier›
			| €LCPrivate› | €LCProcedureName› | €LCProcedure›
			| €LCRecord› | €LCRefinedBy› | €LCRem›
			| €LCRenames› | €LCReplacedBy› | €LCReturn›
			| €LCReverse› | €LCRRange› | €LCSemi›
			| €LCSeparate› | €LCSpecLabel› | €LCStarStar›
			| €LCStar› | €LCStmtLabel›
			| €LCStringLiteral› | €LCSubType› | €LCThen›
			| €LCTill› | €LCTypeMark›
			| €LCType› | €LCUse› | €LCVPartLabel›
			| €LCWhenOthers› | €LCWhen›
			| €LCWhile› | €LCWith› | €LCXor› | €LCEos›
			| €LCZ›
			| €LCGrkDelta› | €LCLSqBrack› | €LCRSqBrack›
			| €LCLBrace› | €LCRBrace› | €LCLStrachey›
			| €LCRStrachey› | €LCLChevron› | €LCRChevron›;
=DESCRIBE
=ENDDOC

=DOC
datatype €CN_TOKEN›	=	€CNZ› of ZLex.Z_TOKEN list
			|	€CNText› of string
			|	€CNString› of string
			|	€CNKSlot› of Lex.INPUT list
			|	€CNEos›;
=DESCRIBE
=ENDDOC

=DOC
type €CN_LEX_ITEM›
=DESCRIBE
=ENDDOC

\section{ABSTRACT SYNTAX}

=SMLZ
open_theory"z_library";
push_pc "z_library";
delete_theory"z_dtd502" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", true);
new_theory"z_dtd502";
=TEX

\subsection{Basic Declarations}
The Z specification of the abstract syntax uses a given set declaration to act as a forward declaration of the free type $EXP$, permitting the free type to involve recursion through schema constructions.
Unfortunately, this style is not considered to be type correct in \ProductZ; this is readily circumvented by making the schema constructions generic where necessary.


\subsubsection{Identifiers}

ID is the set of Ada Identifiers.

πZ
‹	[ID]
∞

=SML
type €ID› (* = string *);
=TEX

\subsubsection{Enumerated Types}
Enum\_Type\_Def models enumerated types.

ˇEnum_Type_Def¸¸¸¸¸¸¸¸¸¸¸¸
‹	vals : seq ID
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type €ENUM_TYPE_DEF› (* = {vals : ID list} *);
=TEX

\subsubsection{Type Marks}
TMARK is the set of type marks in the literate script.

πZAX
‹	TMARK :  ID
∞

=SML
type €TMARK› (* = ID *);
=TEX

\subsubsection{Array Types}
Array\_Def models array types.

ˇArray_Def¸¸¸¸¸¸¸¸¸¸¸¸
‹	index, comp : TMARK
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type €ARRAY_DEF› (* = {index : TMARK, comp : TMARK} *);
=TEX

\subsubsection{Variable Declarations}
Var\_Decl is an Ada variable declaration.

ˇVar_Decl¸¸¸¸¸¸¸¸¸¸¸¸
‹	var : ID;
‹	tmark : TMARK
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type €VAR_DECL› (* = {var : ID, tmark : TMARK} *);
=TEX

\subsubsection{Record Types}
Record\_Type\_Def models record types.

ˇRecord_Type_Def¸¸¸¸¸¸¸¸¸¸¸¸
‹	decl : seq Var_Decl
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type €RECORD_TYPE_DEF› (* = {decl : VAR_DECL list} *);
=TEX

\subsubsection{Integer Types}

An integer type is characterised by its range.

ˇRange[EXP]¸¸¸¸¸¸¸¸¸¸¸¸
‹	lo, hi : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('EXP) €RANGE› (* = {lo : 'EXP, hi : 'EXP} *);
=TEX

\subsubsection{Type Definitions}

TYPE\_DEF brings all the above type definitions together.

πZ
TYPE_DEF ::= enum_type_def (ENUM_TYPE_DEF) | int_type_def (RANGE) |
		uncon_array_def (ARRAY_DEF) | con_array_def (ARRAY_DEF) |
		record_type_def (RECORD_TYPE_DEF)
∞

The datatype for TYPE\_DEF is declared with other datatypes co-recursively with EXP in section \ref{TypeDefExpr}.

=GFT
datatype €TYPE_DEF› =
			€EnumTypeDef› of ENUM_TYPE_DEF
		|	€IntTypeDef› of ('EXP) RANGE
		|	€UnconArrayDef› of ARRAY_DEF
		|	€ConArrayDef› of ARRAY_DEF
		|	€RecordTypeDef› of RECORD_TYPE_DEF;
=TEX
\subsubsection{Type Declarations}
Type\_Decl is a type declaration, that is a type definition together with its name.

ˇType_Decl¸¸¸¸¸¸¸¸¸¸¸¸
‹	name : ID;
‹	type_def : TYPE_DEF
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('TYPE_DEF) €TYPE_DECL› (* = {name : ID, type_def : 'TYPE_DEF} *);
=TEX

\subsubsection{SubTypes}
Subtype\_Decl models subtype declarations.

πZ
CONSTRAINT ::= range_con (RANGE) | index_con (TMARK)
∞

The datatype for CONSTRAINT is declared with other datatypes co-recursively with EXP in section \ref{TypeDefExpr}.
=GFT
datatype €CONSTRAINT› =
			€RangeCon› of ('EXP) Range
		|	€IndexCon› of TMARK;
=TEX

Sub\_Ind is a subtype indication.

ˇSub_Ind¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	tmark : TMARK;
‹	con : CONSTRAINT
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('CONSTRAINT) €SUB_IND› (* = {tmark : TMARK, con : 'CONSTRAINT} *);
=TEX

ˇSubtype_Decl¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	name : ID;
‹	Sub_Ind
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('CONSTRAINT) €SUBTYPE_DECL› (* = {name : ID, sub_ind : ('CONSTRAINT) SUB_IND} *);
=TEX

\subsubsection{Constants}
Const\_Decl models constant declarations.

ˇConst_Decl[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	const : ID;
‹	tm : TMARK;
‹	expr : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('EXP) €CONST_DECL› (* = {const : ID, tm : TMARK, expr : 'EXP} *);
=TEX

\subsubsection{Type Definition for Basic Declarations}
πZ
BASIC_DECL ::= const_decl (CONST_DECL) | type_decl (TYPE_DECL) |
		subtype_decl (SUBTYPE_DECL)
∞

The datatype for BASIC\_DECL is declared with other datatypes co-recursively with EXP in section \ref{TypeDefExpr}.
=GFT
datatype €BASIC_DECL› =
			€ConstDecl› of CONST_DECL
		|	€TypeDecl› of TYPE_DECL
		|	€SubtypeDecl› of SUBTYPE_DECL;
=TEX
\subsection{Expressions}
\subsubsection{Aggregates}
Agg\_Pos is a positional array or record aggregate.

ˇAgg_Pos[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	tmark : TMARK;
‹	comps : seq EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('EXP) €AGG_POS› (* = {tmark : TMARK, comps : 'EXP list} *);
=TEX

Agg\_Pos\_Others is a positional array with an others part.

ˇOthers[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	others : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('EXP) €OTHERS› (* = {others : 'EXP} *);
=TEX


ˇAgg_Pos_Others¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Agg_Pos;
‹	Others
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('EXP) €AGG_POS_OTHERS›
		(* = {agg_pos : ('EXP) AGG_POS, others : ('EXP) Others} *);
=TEX

Agg\_Others is an array aggregate with just an others part.

ˇAgg_Others¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	tmark : TMARK;
‹	Others
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('EXP) €AGG_OTHERS› (* = {tmark : TMARK, others : ('EXP) OTHERS} *);
=TEX

Agg\_Choice is an aggregate choice with terms separated by ``|''.

πZ
‹	AGG_CHOICE ::=
‹		agg_choice_range (RANGE) | agg_choice_single (EXP)
∞

The datatype for AGG\_CHOICE is declared with other datatypes co-recursively with EXP in section \ref{TypeDefExpr}.
=GFT
datatype €AGG_CHOICE› =
			€AggChoiceRange› of (EXP) RANGE
		|	€AggChoiceSingle› of EXP;
=TEX


Agg\_Named models a named array aggregate.

ˇNamed_Assoc[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	choices :  AGG_CHOICE;
‹	comp : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('AGG_CHOICE, 'EXP) €NAMED_ASSOC› (* = {choice : 'AGG_CHOICE list, comp : 'EXP} *);
=TEX

ˇAgg_Named¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	named_assocs :  Named_Assoc
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('AGG_CHOICE, 'EXP) €AGG_NAMED› (* = {named_assocs : ('AGG_CHOICE, 'EXP) NAMED_ASSOC list} *);
=TEX

Agg\_Named\_Others is a named array aggregate with an others part.

ˇAgg_Named_Others¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	tmark : TMARK;
‹	Agg_Named;
‹	Others
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('AGG_CHOICE, 'EXP) €AGG_NAMED_OTHERS›
		(* = {tmark : TMARK, agg_named : ('AGG_CHOICE, 'EXP) AGG_NAMED, 
			others : ('EXP) OTHERS} *);
=TEX

Rec\_Agg\_Named is a named record aggregate. (Positional record aggregates are modelled by Agg\_Pos at the start of this section).

ˇRec_Agg_Named[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	tmark : TMARK;
‹	named_assocs :  (ID ∏ EXP)
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('EXP) €REC_AGG_NAMED›
		(* = {tmark : TMARK, named_assocs : (ID * 'EXP) list} *);
=TEX

\subsubsection{Unary Operations}

πZ
‹	UNARY_OP ::=
‹	spark_unary_add | spark_unary_minus | spark_not | spark_abs
∞

=SML
datatype €UNARY_OP› =
			€SparkUnaryAdd›
		|	€SparkUnaryMinus›
		|	€SparkNot›
		|	€SparkAbs›;
=TEX


ˇUnary_Exp[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	op : UNARY_OP;
‹	right : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('EXP) €UNARY_EXP› (* = {Op : UNARY_OP, right : 'EXP} *);
=TEX


\subsubsection{Binary Expressions}

πZ
‹	BIN_OP ::=
‹	spark_and | spark_or | spark_xor | spark_eq | spark_noteq |
‹	spark_less | spark_less_eq | spark_greater | spark_greater_eq |
‹	spark_add | spark_minus | spark_times | spark_intdiv |
‹	spark_mod | spark_rem | spark_expon | spark_mem | spark_notmem
∞

=SML
datatype €BIN_OP› =
			€SparkAnd›
		|	€SparkOr›
		|	€SparkXor›
		|	€SparkEq›
		|	€SparkNotEq›
		|	€SparkLess›
		|	€SparkLessEq›
		|	€SparkGreater›
		|	€SparkGreaterEq›
		|	€SparkAdd›
		|	€SparkMinus›
		|	€SparkTimes›
		|	€SparkIntdiv›
		|	€SparkMod›
		|	€SparkRem›
		|	€SparkExpon›
		|	€SparkMem›
		|	€SparkNotmem›
=TEX
Added the following which are missing in the original.
=SML
		|	€SparkAndThen›
		|	€SparkOrElse›;
=TEX

ˇBin_Exp[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	op : BIN_OP;
‹	left, right : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('EXP) €BIN_EXP› (* = {Op : BIN_OP, left : 'EXP, right : 'EXP} *);
=TEX

Mem\_Range is the membership (or non-membership) of a range.

πZ
‹	MEM_OP ¶ {spark_mem, spark_nonmem}
∞

=SML
type €MEM_OP› (* = BIN_OP *);
=TEX

ˇMem_Range[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	left : EXP;
‹	op : MEM_OP;
‹	Range
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸


=SML
type ('EXP) €MEM_RANGE› (* = {left : 'EXP, Op : MEM_OP, range : ('EXP) RANGE} *);
=TEX


\subsection{Attributes}
Attribute models Ada attributes.

ATTRIB are the attribute designators FIRST, LAST, SUCC, PRED, POS, VAL, LENGTH and RANGE.

πZAX
‹	fst, lst, suc, pred, pos, val, length, range : ID
∞

πZ
‹	ATTRIB ¶ {fst, lst, suc, pred, pos, val, length, range}
∞

=SML
type €ATTRIB› (* = ID list *);
=TEX

ATTRIB\_DESIG models the attribute designators.

πZ
‹	ATTRIB_DESIG ::=
‹		attrib (ATTRIB) | attrib_arg (ATTRIB ∏ EXP)
∞

=GFT
datatype €ATTRIB_DESIG› =
			€Attrib› of ATTRIB
		|	€AttribArg› of (ATTRIB * EXP);
=TEX

ˇAttribute¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	prefix : ID;
‹	attribute_desig : ATTRIB_DESIG
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('ATTRIB_DESIG) €ATTRIBUTE›
	(* = {prefix : ID, attribute_desig : 'ATTRIB_DESIG} *);
=TEX

\subsubsection{Indexed Component}
Indexed\_Comp is an array component.

ˇIndexed_Comp[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	prefix, index : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('EXP) €INDEXED_COMP›
	(* = {prefix : 'EXP, index : 'EXP} *);
=TEX

\subsubsection{Selected Component}
Selected\_Comp is a record component.

ˇSelected_Comp[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	prefix : EXP;
‹	selector : ID
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('EXP) €SELECTED_COMP›
	(* = {prefix : 'EXP, selector : ID} *);
=TEX

\subsubsection{Function Calls}
Fun\_Call is a function call.

ˇFun_Call[EXP]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	fun_name : ID;
‹	args : seq EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
type ('EXP) €FUN_CALL›
	(* = {fun_name : ID, args : 'EXP list} *);
=TEX

\subsubsection{Integer Literals}
INT\_LIT are the integer literals.

πZ
‹	[INT_LIT]
∞

=SML
type €INT_LIT› (* = string *);
=TEX

\subsubsection{Auxiliary Expressions}
In the Compliance Notation, a SPARK expression can also be a Z expression (auxiliary expression).

πZ
‹	[Z_EXP]
∞

=SML
type Z_EXP (* = TERM *);
=TEX

\subsubsection{Type Definition for Expressions}\label{TypeDefExpr}

πZ
‹	EXP ::=	
‹		Id (ID) | int (INT_LIT) | array_agg_pos (Agg_Pos) |
‹		array_agg_pos_others (Agg_Pos_Others) |
‹		array_agg_others (Agg_Others) |
‹		array_agg_named (Agg_Named) |
‹		array_agg_named_others (Agg_Named_Others) |
‹		rec_agg_pos (Agg_Pos) | rec_agg_named (Rec_Agg_Named) |
‹		unary_exp (Unary_Exp) | bin_exp (Bin_Exp) |
‹		mem_range (Mem_Range) | attribute (Attribute) |
‹		indexed_comp (Indexed_Comp) |
‹		selected_comp (Selected_Comp) |
‹		fun_call (Fun_Call) |
‹		auxiliary_exp (Z_EXP)
∞

=SML
datatype €TYPE_DEF› =
			€EnumTypeDef› of ENUM_TYPE_DEF
		|	€IntTypeDef› of (EXP) RANGE
		|	€UnconArrayDef› of ARRAY_DEF
		|	€ConArrayDef› of ARRAY_DEF
		|	€RecordTypeDef› of RECORD_TYPE_DEF
=TEX
=SML
and €CONSTRAINT› =
			€RangeCon› of (EXP) RANGE
		|	€IndexCon› of TMARK
=TEX
=SML
and €BASIC_DECL› =
			€ConstDecl› of (EXP) CONST_DECL
		|	€TypeDecl› of (TYPE_DEF) TYPE_DECL
		|	€SubtypeDecl› of (CONSTRAINT) SUBTYPE_DECL
=TEX
=SML
and €AGG_CHOICE› =
			€AggChoiceRange› of (EXP) RANGE
		|	€AggChoiceSingle› of EXP
=TEX
=SML
and €ATTRIB_DESIG› =
			€Attrib› of ATTRIB
		|	€AttribArg› of (ATTRIB * EXP)
=TEX
=SML
and €EXP› =
		€Id› of ID | €Int› of INT_LIT | €ArrayAggPos› of (EXP) AGG_POS |
		€ArrayAggPos_others› of (EXP) AGG_POS_OTHERS |
		€ArrayAggOthers› of (EXP) AGG_OTHERS |
		€ArrayAggNamed› of (AGG_CHOICE, EXP) AGG_NAMED |
		€ArrayAggNamedOthers› of (AGG_CHOICE, EXP) AGG_NAMED_OTHERS |
		€RecAggPos› of (EXP) AGG_POS | €RecAggNamed› of (EXP) REC_AGG_NAMED |
		€UnaryExp› of (EXP) UNARY_EXP | €BinExp› of (EXP) BIN_EXP |
		€MemRange› of (EXP) MEM_RANGE | €Attribute› of (ATTRIB_DESIG) ATTRIBUTE |
		€IndexedComp› of (EXP) INDEXED_COMP |
		€SelectedComp› of (EXP) SELECTED_COMP |
		€FunCall› of (EXP) FUN_CALL |
		€AuxiliaryExp› of Z_EXP;
=TEX


\subsection{Statements}

The Z specification of the abstract syntax uses a given set declaration to act as a forward declaration of the free type $Stmt$, permitting the free type to involve recursion through schema constructions.
Unfortunately, this style is not considered to be type correct in \ProductZ; this is readily circumvented by making the schema constructions generic where necessary.
For example, see section \ref{if-then-else} below.

Following this convention we may now work through the abstract syntax for SPARK statements following \cite{DRA/CIS/CSE3/SWI/WP/1/3}.

\subsubsection{Assignment}\label{assignment}

ˇAssign¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	name, E : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
	type €ASSIGN› (* = {name : EXP, E : EXP}; *)
=TEX

\subsubsection{Specification Statements}

πZAX
‹	Z_PREDâ0 :  Z_PRED
∞

=SML
type €Z_PRED› (* = TERM; *)
type €Z_PREDâ0› (* = Z_PRED; *)
type €Z_ID› (* = ID; *)
=TEX

ˇSpec¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	w, wâ0 :  Z_ID;
‹	Pre, post : Z_PRED
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Pre é Z_PREDâ0
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

ˇSpec_No_Ivars¸¸¸¸¸¸¸¸¸¸¸¸
‹	Spec
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	post é Z_PREDâ0
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=TEX
In the translation into Standard ML of a schema which includes another,
we have various choices.
In this simple case where the new schema has the same signature as the included one, we just say that the new type is an abbreviation for the old one.
=SML
	type €SPEC› (* = {w : Z_ID list, w0 : Z_ID list, pre : Z_PRED, post : Z_PRED};*)
	type €SPEC_NO_IVARS› (* = SPEC; *)
=TEX
\subsubsection{If-then-else}\label{if-then-else}

πZAX
‹	COND :  EXP
∞

ˇIf_Then_Else[STMT]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	G : COND;
‹	P, Q : STMT
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=SML
	type €COND› (* = EXP; *)
	type ('STMT) €IF_THEN_ELSE› (* = {G : COND, P : 'STMT, Q : 'STMT}; *)
=TEX
\subsubsection{Case}\label{case}

πZ
‹	CASE_CHOICE ::= case_exp EXP | case_range Range
∞

=SML
datatype €CASE_CHOICE› =
				€CaseExp› of EXP
			|	€CaseRange› of (EXP) RANGE;
=TEX

ˇCase_Alternative[STMT]¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	choices :  CASE_CHOICE;
‹	P : STMT
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇCase¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	E : EXP;
‹	s : seqâ1 Case_Alternative
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=SML
	type ('STMT) €CASE_ALTERNATIVE› (* = {choices : CASE_CHOICE list, P : 'STMT}; *)
	type ('STMT) €CASE› (* = {E : EXP, s : ('STMT) CASE_ALTERNATIVE list}; *)
=TEX
\subsubsection{Loop}\label{loop}

ˇLoop¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	T : Z_PRED;
‹	Spec_No_Ivars
˜¸¸¸¸¸¸
‹	T é Z_PREDâ0
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
As with the translation of $Spec\_No\_Ivars$, we have a choice of how to translate the schema inclusion.
This case is a little more complicated, however, but as there is no overlap between the signature of the included schema and other signature variables, we can adopt the following simple translation.

=SML
	type €LOOP› (* = {T : Z_PRED, spec : SPEC_NO_IVARS}; *)
=TEX

\subsubsection{While Loop}\label{while-loop}
ˇWhile¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	G : COND;
‹	Loop
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
	type €WHILE› (* = {G : COND, loop : LOOP}; *)
=TEX
\subsubsection{For Loop (Values as Bounds)}\label{for-static}

πZAX
‹	STATIC_EXP :  EXP
∞

ˇFor_Static¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	i : ID;
‹	lo, hi : STATIC_EXP;
‹	Loop
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=SML
	type €STATIC_EXP› (* = EXP; *)
	type €FOR_STATIC› (* = {i : ID, lo : STATIC_EXP, hi : STATIC_EXP, loop : LOOP}; *)
=TEX
\subsubsection{For Loop (Type Mark as Range)}\label{for-typemark}

ˇFor_Tmark¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	i : ID;
‹	tmark : TMARK;
‹	Loop
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=SML
	type €FOR_TMARK› (* = {i : ID, tmark : TMARK, loop : LOOP}; *)
=TEX
\subsubsection{Exit}\label{exit}

ˇExitWhen¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	G : COND
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=SML
	type €EXIT_WHEN› (* = {G : COND}; *)
=TEX
\subsubsection{Return}\label{return}

ˇReturn¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	E : EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=SML
	type €RETURN› (* = {E : EXP}; *)
=TEX
\subsubsection{Procedure Call}\label{procedure-call}

ˇProc_Call¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	name : ID;
‹	actuals : seq EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=SML
	type €PROC_CALL› (* = {name : ID, actuals : EXP list}; *)
=TEX
ˇProc_Call_No_Ivars¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Proc_Call
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	(retrieve_spec_stmt name).post é Z_PREDâ0
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=SML
	type €PROC_CALL_NO_IVARS› (* = PROC_CALL; *)
=TEX
\subsubsection{$Stmt$}\label{stmt}
\ProductZ\ is currently non-standard in that it neither requires nor
allows the chevrons around the operands in a free type definition.
This mismatch with the Z standard is planned to be remedied in a future release of the system.
πZ
	Stmt	::= 	null
		|	assign (Assign)
		|	spec_no_ivars (Spec_No_Ivars)
		|	semicolon (Stmt ∏ Stmt)
		|	if_then_else (If_Then_Else)
		|	case (Case[Stmt])
		|	loop (Loop)
		|	while (While)
		|	for_static (For_Static)
		|	for_tmark (For_Tmark)
		|	exit_when (Exit_When)
		|	exit
		|	ret (Return)
		|	proc_no_ivars (Proc_Call_No_Ivars)
∞
=TEX
The constructors $case$ and $while$ must be misspelt in the Standard ML datatype twhich implements the above because they are reserved identifiers.
=SML
datatype €STMT›	= 	€Null›
		|	€Assign› of (ASSIGN)
		|	€SpecNoIvars› of (SPEC_NO_IVARS)
		|	€Semicolon› of (STMT * STMT)
		|	€IfThenElse› of ((STMT)IF_THEN_ELSE)
		|	€Case› of ((STMT)CASE)
		|	€Loop› of (LOOP)
		|	€While› of (WHILE)
		|	€ForStatic› of (FOR_STATIC)
		|	€ForTmark› of (FOR_TMARK)
		|	€ExitWhen› of (EXIT_WHEN)
		|	€Exit›
		|	€Ret› of (RETURN)
		|	€ProcNoIvars› of (PROC_CALL_NO_IVARS);
=TEX
\pagebreak
\subsubsection{Specification (with initial variables)}\label{specification-ivars}

ˇSpec_Ivars¸¸¸¸¸¸¸¸¸¸¸¸
‹	Spec
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	post ç Z_PREDâ0
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=TEX
=SML
	type €SPEC_IVARS› (* = SPEC; *)
=TEX
\subsubsection{For Loop (Non-Static Bounds)}\label{for-non-static-bounds}

ˇFor_Non_Static¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	i : ID;
‹	lo, hi : EXP;
‹	Loop
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹		lo é STATIC_EXP
‹	≤
‹		hi é STATIC_EXP
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=SML
	type €FOR_NON_STATIC› (* = {i : ID, lo : STATIC_EXP, hi : STATIC_EXP, loop : LOOP}; *)
=TEX
\subsubsection{Logical Constants}\label{logical-constants}
πZAX
‹	free_ids : Z_EXP ≠  Z_ID
∞

ˇLog_Con¸¸¸¸¸¸¸¸¸¸¸¸
‹	X : Z_ID;
‹	E : Z_EXP;
‹	Spec;
‹	preâ1 : Z_PRED
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	Pre = z_and(z_eq(zid X, E), preâ1);
‹	X é free_ids E
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
=TEX
The functions $free\_id$ may readily and reallistically be implemented using existing \Product\
syntax functions.
=SML
	val €free_ids› : Z_EXP -> ID list
	type €LOG_CON› (* = {X : Z_ID, E : Z_EXP, spec : SPEC, pre1 : Z_PRED}; *)
=TEX
\subsubsection{Procedure Calls}\label{procedure-calls}
ˇProc_Call_Ivars¸¸¸¸¸¸¸¸¸¸¸¸
‹	Proc_Call
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹	(retrieve_spec_stmt name).post ç Z_PREDâ0
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
	type €PROC_CALL_IVARS› (* = PROC_CALL; *)
=TEX

\subsubsection{Statement}\label{statement}
πZ
	Statement
		::= 	stmt (Stmt)
		|	spec_ivars (Spec_Ivars ∏ Stmt)
		|	for_non_static (For_Non_Static ∏ Stmt)
		|	log_con (Log_Con ∏ Stmt)
		|	proc_ivars (Proc_Call_Ivars ∏ Stmt)
∞
=TEX
=SML
datatype €STATEMENT› =
		 	€Stmt› of (STMT)
		|	€SpecIvars› of (SPEC_IVARS * STMT)
		|	€ForNonStatic› of (FOR_NON_STATIC * STMT)
		|	€LogCon› of (LOG_CON * STMT)
		|	€ProcIvars› of (PROC_CALL_IVARS * STMT);
=TEX

\subsection{Subprogram Declarations}
=SML
datatype €MODE› = SparkIn | SparkOut | SparkInOut;

type €PARAMETER_SPECIFICATION› (* = {
	idlist : ID list,
	mode : MODE,
	name : TMARK} *);

type €PROCEDURE_SPECIFICATION› (* = {
	name : ID,
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT} *);

type €FUNCTION_SPECIFICATION› (* = {
	designator : ID,
	return : TMARK,
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT} *);

datatype €SUBPROGRAM_SPECIFICATION› =
			procedure_specification of PROCEDURE_SPECIFICATION
		|	function_specification of FUNCTION_SPECIFICATION;

type €PROCEDURE_DECLARATION› (* = PROCEDURE_SPECIFICATION *);
type €FUNCTION_DECLARATION› (* =FUNCTION_SPECIFICATION *);
type €SUBPROGRAM_DECLARATION› (* = SUBPROGRAM_SPECIFICATION *);
=TEX
\subsection{Subprogram Bodies}
\subsection{Procedure and Function Calls}
=SML
type €NAMED_PARAM› (* = {
	formal : ID,
	actual : EXP} *);

type €NAMED_PARAMETER_ASSOC› (* = {
	params: NAMED_PARAM list} *);

type €POS_PARAMETER_ASSOC› (* = {
	params : EXP list} *);

datatype €ACTUAL_PARAMETER_PART› = 
			NamedParameterAssociation of NAMED_PARAMETER_ASSOC
		|	PositionalParameterAssociation of POS_PARAMETER_ASSOC;

type €PROCEDURE_CALL_STATEMENT› (* = {
	name : ID,
	params : ACTUAL_PARAMETER_PART OPT} *);

type €FUNCTION_CALL› (* = {
	name : ID,
	params : ACTUAL_PARAMETER_PART OPT} *);

=TEX
\subsection{Package Declaration}
=SML
type €K_SLOT› (* = {content : string, label : string} *);

type €OPERATOR_SYMBOL› (* = string *);

type €FUNCTION_RENAMING› (* = {
	opsym1 : OPERATOR_SYMBOL,
	formal_part : PARAMETER_SPECIFICATION list,
	tmark : TMARK,
	name : ID,
	opsym2 : OPERATOR_SYMBOL} *);

type €SUBPROGRAM_RENAMING› (* = {
	subprogram_specification : SUBPROGRAM_SPECIFICATION,
	name1 : ID,
	name2 : ID} *);

datatype €RENAMING_DECLARATION› =
			FunctionRenaming of FUNCTION_RENAMING
		|	SubprogramRenaming of SUBPROGRAM_RENAMING;

type €LENGTH_CLAUSE› (* = {
	attribute : (ATTRIB_DESIG) ATTRIBUTE,
	exp : EXP} *);

type €ENUMERATION_REPRESENTATION_CLAUSE› (* = {
	name : ID,
	exp : EXP} *);

type €COMPONENT_CLAUSE› (* = {
	exp : EXP,
	range : (EXP)RANGE} *);

type €RECORD_REPRESENTATION_CLAUSE› (* = {
	name : ID,
	alignment_opt : EXP OPT,
	component_pack : COMPONENT_CLAUSE list} *);

type €ADDRESS_CLAUSE› (* = {
	name : ID,
	exp : EXP} *);

datatype €REPRESENTATION_CLAUSE› =
			LengthClause of LENGTH_CLAUSE
		|	EnumerationRepresentationClause of ENUMERATION_REPRESENTATION_CLAUSE
		|	RecordRepresentationClause of RECORD_REPRESENTATION_CLAUSE
		|	AddressClause of ADDRESS_CLAUSE;
=TEX
=SML
type €PROCEDURE_BODY› (* = {
	procedure_spec : PROCEDURE_SPECIFICATION,
	declarative_part : DECLARATION list,
	statement : STATEMENT} *);

type €FUNCTION_BODY› (* = {
	function_spec : FUNCTION_SPECIFICATION,
	declarative_part : DECLARATION list,
	statement : STATEMENT} *);

type €PACKAGE_BODY› (* = {
	name : ID,
	decls : DECLARATION list,
	statement : STATEMENT} *);

type €PACKAGE_DECLARATION› (* = {
	name : ID,
	visible_decs : DECLARATION list,
	private_decs : DECLARATION list} *);

=TEX
=SML
datatype €DECLARATION› =
			DDeclarationKSlot of K_SLOT
		|	DRenamingDeclaration of RENAMING_DECLARATION
		|	DBasicDecl of BASIC_DECL
		|	DRepresentationClause of REPRESENTATION_CLAUSE
		|	DProperBody of PROPER_BODY
		|	DProcedureDeclaration of PROCEDURE_DECLARATION
		|	DFunctionDeclaration of FUNCTION_DECLARATION
		|	DPackageDeclaration of PACKAGE_DECLARATION
		|	DProcedureStub of PROCEDURE_DECLARATION
		|	DFunctionStub of FUNCTION_DECLARATION
		|	DPackageStub of ID

and €PROPER_BODY› =	PBProcedure of PROCEDURE_BODY
		|	PBFunction of FUNCTION_BODY
		|	PBPackage of PACKAGE_BODY;
=TEX

=TEX
=SML
type €SUBUNIT› (* = {
	id : ID,
	proper_body : PROPER_BODY} *);

datatype €COMPILATION_UNIT› =
			CUPackageDeclaration of PACKAGE_DECLARATION
		|	CUProperBody of PROPER_BODY
		|	CUSubUnit of SUBUNIT;


type €REFINED_BY› (* = {label : ID,  statement : STATEMENT} *);
type €REPLACED_BY› (* = {label : ID,  statement : STATEMENT} *);

type €REPLACED_BY_DECL› (* = {label : ID,  decls : DECLARATION list} *);
type €REPLACED_BY_VISIBLE_PART› (* = {label : ID, visible : DECLARATION list} *);
type €REPLACED_BY_PRIVATE_PART› (* = {label : ID, private : DECLARATION list} *);

type CONTEXT_COMPILATION_UNIT (* = {
	context : ID list,
	comp_unit : COMPILATION_UNIT} *);

datatype €KSLOT_COMPILATION_UNIT› =
			CompKSlot of K_SLOT
		|	CompUnit of CONTEXT_COMPILATION_UNIT;

type €REPLACED_BY_COMP› (* = {label : ID,  comp : KSLOT_COMPILATION_UNIT list} *);

datatype €WEB_CLAUSE› = 
			Compilation of KSLOT_COMPILATION_UNIT list
		|	ReplacedByCompilation of REPLACED_BY_COMP
		|	ReplacedByPrivatePart of REPLACED_BY_PRIVATE_PART
		|	ReplacedByVisiblePart of REPLACED_BY_VISIBLE_PART
		|	ReplacedByDecl of REPLACED_BY_DECL
		|	RefinedBy of REFINED_BY
		|	ReplacedBy of REPLACED_BY;
=TEX
\section{EPILOGUE}

=SML
end; (* of signature CNTypes *)
=TEX

=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



