=IGN
********************************************************************************
dtd502.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
%  dtd502.doc %Z% $Date: 2004/06/20 14:13:52 $ $Revision: 1.137 $ $RCSfile: dtd502.doc,v $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\def\TPPheadtitle{Compliance Notation Lexis and Abstract Syntax}  %% Mandatory field
\TPPtitle{Compliance Notation Lexis and Abstract Syntax}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD502}  %% Mandatory field
\def\SCCSversion{$Revision: 1.137 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2004/06/20 14:13:52 $%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{HOL}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan&HAT Team}
\TPPabstract{
This document contains the detailed design for the lexis and abstract syntax for Compliance Notation}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DRA \\
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.37] Initial Drafts.
\item[Issue 1.38] Reworked according to desk check report 006.
\item[Issue 1.39)] Added lexical tokens for auxiliary expressions.
\item[Issue 1.40] Corrected abstract syntax for specification statements w.r.t. labels.
\item[Issue 1.44] Re-organised material and applied DRA's suggested corrections documented in \cite{ISS/HAT/DAZ/MIN004}.
\item[Issue 1.45] Few minor changes in checking the rework.
\item[Issue 1.46-1.51] Bug fixes.
\item[Issue 1.52] Updated document references.
\item[Issue 1.53] Changed the text in the Test Policy section. Fixed a Z problem in the definition of Z\_PRED.
\item[Issue 1.54] Reworded the test policy section.
\item[Issue 1.55] Added pragmas, annotations and arbitrary replacements.
\item[Issue 1.60] Added Z Bindings and updated free type def. of Z\_EXP.
\item[Issue 1.61] Added qualified expressions and type conversions to the Z.
\item[Issue 1.62] Added short-circuit conditionals to Z syntax for SPARK.
\item[Issue 1.63] Documentary corrections prior to review of recent changes.
\item[Issue 1.64] Multi-dimensional arrays now part of the specification.
\item[Issue 1.65] Enhancement 3.
\item[Issue 1.66 (14th December 1995)] Changes according to desk check report 024.
\item[Issue 1.67] Typo corrected.
\item[Issue 1.68-1.69] Syntax changes for k-slots as annotations.
\item[Issue 1.70] WP 7 implementation.
\item[Issue 1.71] Changes for IUCT WP 2.
\item[Issue 1.72] IUCT WP 3 changes.
\item[Issue 1.73] IUCT WP 4 changes.
\item[Issue 1.73] Corrected Z syntax and type errors.
\item[Issue 1.74] Updated references.
\item[Issue 1.75] Added dummy defs for $Z\_TM$ and $Z\_PARA$ and $Z\_EXP$.
		Changes to allow compilation with zed.db
\item[Issue 1.77] Changes to allow compilation with hol.db
\item[Issue 1.78-1.79] Changes to allow compilation with just polyml.
\item[Issue 1.80] Update for SML 97.
\item[Issue 1.81] Typechecking enhancement ref. R5 from \cite{LEMMA1/DAZ/HLD506}
At this version only the Z and a few of the ML types have been changed.
The main ML changes will come later.
\item[Issue 1.82] Typechecking other enhancements from \cite{LEMMA1/DAZ/HLD506}.
\item[Issue 1.83] Prototyping enhancement R5: Initial Variables in Conditionals.
\item[Issue 1.84] Typechecking corrected approach to enhancement R2 --- Multiple Logical Constant Definitions.
\item[Issues 1.85, 1.86] Enhancement R2: Multiple Logical Constants.
\item[Issue 1.87] Enhancement R1: Multidimensional Arrays.
\item[Issue 1.88] CTLE II R1/2: ``Others'' in case statements.
\item[Issue 1.89] CTLE II R1/3: reverse loops.
\item[Issue 1.90] CTLE II R1/10: multiple with clauses.
\item[Issue 1.91] CTLE II R1/4 --- logical operators on arrays
of booleans, including overloading, and some parts of R1/1 (reals) and R1/8 (characters and strings).
\item[Issue 1.92] CTLE II R1/8 --- remainder of characters and strings.
\item[Issue 1.93] CTLE II R1/9 --- SPARK 83 attributes.
\item[Issue 1.94] CTLE II R2/1 --- global variable unsoundness.
\item[Issues 1.95,1.96] CTLE II R1/1 --- real types.
\item[Issue 1.97] Final adjustments to the Z specs.
\item[Issue 1.98] R0021: new treatment of AND THEN and OR ELSE.
\item[Issue 1.99] Removed local declarations for Poly/ML port.
\item[Issues 1.100-1.102] R0037: support for named numbers.
\item[Issue 1.103] Corrected error in use of the generic schema {\it Range}.
\item[Issue 1.104] Index brackets added.
\item[Issue 1.105--1.108] R0006: free use of subtype indications and ranges
\item[Issue 1.109] Moved CN\_ENV type here to simplify life with IMP508 etc.
\item[Issue 1.110] Fixed {\LaTeX} errors.
\item[Issue 1.111] Applying specification changes from HLD508.
\item[Issue 1.112] Fixing {\LaTeX} problems for SPC502 and SPC503.
\item[Issue 1.113] R0056: default parameter modes supported properly.
\item[Issues 1.114-1.116] Spring 2002 enhancements: syntax changes for interim release.
\item[Issues 1.117-1.119]  Support for R0047: renaming.
\item[Issues 1.120, 1.121] Formal spec updates for interim release.
\item[Issue 1.122] Fixed {\LaTeX} errors.
\item[Issue 1.123] R0079: assertions ({\it SPEC\_NO\_IVARS} now has a flag to indicate an assertion.
\item[Issue 1.124, 1.125] R0051/R0052: default parameters and block statements.
\item[Issue 1.126] Now support renaming of operator symbol with no package name prefix.
\item[Issue 1.127] Copyright and banner updates for open source release.
\item[Issue2 1.128, 1.129] DAZ-specific updates to banner for open source release
\item[Issue 1.130] Block statements now treated uniformly with other statement forms.
\item[Issue 1.131] Schemas-as-declarations now catered for in specification of Z syntax.
\item[Issue 1.132] $\theta$-expressions  now catered for in  specification of Z syntax.
\item[Issue 1.133] Support for NOTHING statement form.
\item[Issue 1.134] R0096: improved formatting of nothing statement form in web clauses
\item[Issue 1.135] Added lexical class for undeclared labels (for use in lexer and parser to
improve error messagaes).
\item[Issue 1.136] The name at the end of a proper body or a package declaration is now optional.
\item[Issues 1.137-1.138] Reform of the Environments.
\end{description}
\subsection{Changes Forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the lexis and abstract syntax for the Compliance Notation.

The lexis corresponds to that specified in \cite{pvl90}. The abstract syntax is based on the abstract syntax for basic declarations and expressions in \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0} and the abstract syntax for SPARK statements in \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}. The abstract syntax for SPARK subprograms and packages has been derived from the concrete syntax for compliance notation in \cite[volume 1]{DRA/CIS/CSE3/TR/94/27/3.0}.

\subsection{Introduction}
\subsubsection{Purpose and Background}

The lexis is required to carry the lexical information of the input which has been computed by the lexical analyser. The grammar in \cite{ISS/HAT/DAZ/DTD503} is closely related to this lexis since the terminals in the grammar correspond to the lexemes in the datatype $CN\_LEX\_CLASS$. The lexical classes are themselves derived from the list of terminal symbols in \cite[volume 1, appendix A]{DRA/CIS/CSE3/TR/94/27/3.0}.

The abstract syntax for compliance notation constitutes the internal representation for web clauses. All web clauses and fragments of SPARK programs are represented using the abstract syntax type $WEB\_CLAUSE$. The representation is used by the basic declaration and expression generator \cite[volume 3]{DRA/CIS/CSE3/TR/94/27/3.0}, the verification condition generator \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0} and the SPARK output function which creates a human-readable form of the abstract representation corresponding to the input.

Web clauses of type $WEB\_CLAUSE$ are generated by the compliance notation parser \cite{ISS/HAT/DAZ/DTD503} from the literate script being processed.


\subsection{Compliance}

This document contains the signature for compliance notation lexis and compliance notation abstract syntax.

The correspondance between the lexis and that in \cite[volume 1, appendix A]{DRA/CIS/CSE3/TR/94/27/3.0} can be seen by simply comparing the list of type constructors of $CN\_LEX\_CLASS$ with the terminal symbols in \cite[volume 1, appendix A]{DRA/CIS/CSE3/TR/94/27/3.0}.


The correspondence between the Z specification of the abstract syntax in DRA's specification and the implementation is aided by the reproduction of the relevant Z of \cite{DRA/CIS/CSE3/TR/94/27/3.0} in this document. The implementation of each of the schemas is done using a Standard ML type. The details of this type do not appear in the Standard ML signature; the ML syntax does not allow it; but only in the structure. In order to maintain traceability, the information which appears in the structure is contained in this document. During the building of the tool, the {\Product} document processing facility $sieve$ filters out the implementation details into a separate file. The signature can then be processed, and the corresponding structure can be automatically generated from the filtered implementation details. The machinery to do this is very small and can be found in the companion implementation document to this \cite{ISS/HAT/DAZ/IMP503}.

It is intended that the compliance of the Z to the implementation can be done with a visual check in this document.

There are various points in the abstract syntax where the data types are ``wider'' than the corresponding Z. This is generally because it is necessary to carry some syntactic information which would otherwise be lost, in order to reproduce the SPARK program when all the web clauses have been entered. These points are identified by descriptive text later in this document.

Note also that Z expressions are stored as HOL terms in {\ProductZ}. The HOL terms which represent Z expressions are a subset of all HOL terms. This constitutes a ``widening''. This does not introduce any problem for the Compliance Tool.


\section{PREAMBLE}
\subsection{For Z Type-Checking}
The following initialises the theory database when performing a syntax and type check on the Z paragraphs in this document. (This preamble is not processed when building the compliance tool.)

=SMLZ
open_theory"z_library";
push_pc "z_library";
force_delete_theory"dtd502" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", true);
new_theory"dtd502";
fun show_progress recogniser args = (
	recogniser args;
	(hd o get_consts) "-" handle Fail _ => ñNo progress®
);
val z_axbox_recogniser = show_progress ZParagraphRecognizers.z_axbox_recogniser;
val z_genbox_recogniser = show_progress ZParagraphRecognizers.z_genbox_recogniser;
val z_schbox_recogniser = show_progress ZParagraphRecognizers.z_schbox_recogniser;
val z_other_recogniser = show_progress ZParagraphRecognizers.z_other_recogniser;
=TEX

=TEX

\subsection{The Signature}
=DOC
signature ÛCNTypesİ = sig
=DESCRIBE
This is the signature for the structure containing the types required for Compliance Notation.
=ENDDOC
\section{LEXIS}
=DOC
datatype ÛCN_LEX_CLASSİ
			= ÛLCAbsİ | ÛLCAmpersandİ | ÛLCAndİ
			| ÛLCAnnotationİ | ÛLCAnnotationLabelİ | ÛLCArbitraryAdaİ
			| ÛLCArrayİ | ÛLCAtİ | ÛLCAuxiliaryİ 
			| ÛLCBarİ |ÛLCBBodyİ | ÛLCBecomesİ | ÛLCBeginİ | ÛLCByİ
			| ÛLCCaseİ| ÛLCCharacterLiteralİ
			| ÛLCColonİ | ÛLCCommaİ | ÛLCCommentİ
			| ÛLCCompLabelİ | ÛLCConstantİ
			| ÛLCConİ | ÛLCCrdİ
			| ÛLCDecLabelİ  | ÛLCDeclareİ| ÛLCDeltaİ | ÛLCDigitsİ | ÛLCDivİ
			| ÛLCDotDotİ | ÛLCDotİ
			| ÛLCElseİ | ÛLCElsIfİ | ÛLCEndİ | ÛLCEosİ | ÛLCEqualsİ | ÛLCExitİ
			| ÛLCFatDotİ | ÛLCForİ | ÛLCFunctionİ
			| ÛLCGoesToİ | ÛLCGreaterEqualsİ | ÛLCGreaterThanİ
			| ÛLCGrkGammaİ | ÛLCGrkDeltaİ | ÛLCGrkXiİ
			| ÛLCIdentifierİ | ÛLCIfİ | ÛLCImplementİ | ÛLCImplementedByİ
			| ÛLCInİ | ÛLCIsİ
			| ÛLCKSlotİ
			| ÛLCLBraceİ | ÛLCLChevronİ | ÛLCLessEqualsİ
			| ÛLCLessGreatİ | ÛLCLessThanİ
			| ÛLCLimitedİ | ÛLCLoopİ | ÛLCLSqBrackİ | ÛLCLStracheyİ
			| ÛLCMinusİ | ÛLCModİ
			| ÛLCNothingİ
			| ÛLCNotEqualsİ | ÛLCNotİ | ÛLCNullİ | ÛLCNumericLiteralİ
			| ÛLCOfİ | ÛLCOrdİ | ÛLCOrİ | ÛLCOthersİ | ÛLCOutİ
			| ÛLCPackageİ | ÛLCPlusİ | ÛLCPPartLabelİ | ÛLCPrimeİ
			| ÛLCPrimedIdentifierİ | ÛLCPragmaİ | ÛLCPrivateİ
			| ÛLCProcedureİ
			| ÛLCRBraceİ | ÛLCRChevronİ | ÛLCRecordİ
			| ÛLCReferencesİ | ÛLCRefinedByİ | ÛLCRemİ
			| ÛLCRenamesİ | ÛLCReplacedByİ | ÛLCReturnİ
			| ÛLCReverseİ | ÛLCRRangeİ | ÛLCRSqBrackİ | ÛLCRStracheyİ
			| ÛLCSemiİ | ÛLCSeparateİ | ÛLCSpecLabelİ | ÛLCStarStarİ
			| ÛLCStarİ | ÛLCStmtLabelİ | ÛLCStringLiteralİ
			| ÛLCSubTypeİ | ÛLCThenİ | ÛLCTillİ | ÛLCTypeİ
			| ÛLCUndeclaredLabelİ
			| ÛLCUseİ| ÛLCUsingİ | ÛLCVPartLabelİ
			| ÛLCWhenİ | ÛLCWhileİ | ÛLCWithİ
			| ÛLCXorİ
			| ÛLCZİ;
=DESCRIBE
CN\_LEX\_CLASS is the datatype used to represent the lexical classes of tokens in compliance notation. 
=DESCRIBE
=ENDDOC


=DOC
datatype ÛCN_TOKENİ	=	ÛCNZİ of ZLex.Z_TOKEN list
			|	ÛCNTextİ of string
			|	ÛCNStringİ of string
			|	ÛCNKSlotİ of Lex.INPUT list
			|	ÛCNEosİ;

type ÛCN_LEX_ITEMİ
=TYPESTRUCT
	= CN_LEX_CLASS * CN_TOKEN;
=DESCRIBE
CN\_TOKEN is the datatype used to represent the lexical tokens required in compliance notation. CN\_LEX\_ITEM is a type used by the lexical analyser for communicating to the parser the lexical information. The class (the first of the pair) is the classification of the token (the second of the pair).
=ENDDOC

\subsection{Notes on Compliance}

The specification of the concrete syntax in \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0} does not spell out the syntax for specification statements. Hence the terminal $specification statement$ is not represented in the list of lexical classes, but the syntactic components are instead provided, viz: $LCGrkDelta$, $LCLSqBrack$, $LCRSqBrack$, $LCLBrace$, $LCRBrace$.

Similarly for k-slots, $LCLChevron$ and $LCRChevron$; and auxiliary expressions, $LCLStrachey$ and $LCRStrachey$.

There is no need for an lexical class for a type mark as it is lexically equivalent to an identifier. 

A consequence of an ambiguity in handling primes, documented in \cite{ISS/HAT/DAZ/DTD503}, is the necessity of a lexical class to represent an identifier immediately followed by a prime; hence $LCPrimedIdentifier$. An end-of-input has also been added, $LCEos$.

Other consequences of changes to the grammar (also documented in \cite{ISS/HAT/DAZ/DTD503}) result in no requirement for lexical classes corresponding to $commagoesto$, $commaothers$, $whenothers$, $functionname$, $procedurename$, $z\_decl$, $z\_pred$ and $na$ of \cite[Volume 1]{DRA/CIS/CSE3/TR/94/27/3.0}.
\newpage

\section{Z ABSTRACT SYNTAX}
The following is implemented by the type
=INLINEFT
'a OPT
=TEX
\ with its constructors
=INLINEFT
Value
=TEX
\ and
=INLINEFT
Nil
=TEX
\ in ML.
¹Z
Ü ÛOPTİ[X] ¦ {A : ğX | µx, y: A· x = y}
°
[ X ]œœœœœœœœœœœ
Ü ÛValueİ : X ­ OPT[X];
Ü ÛNilİ : OPT[X]
÷üüüüüü
Ü µx: X· Value x = {x} ;
Ü Nil = {}
ˆüüüüüüüüüüüüüü

Since Z abstract syntax is already supported in {\ProductZ}, there is no requirement to provide specific implementations of most of the Z in this section. It is provided here mainly for the purpose of allowing the Z in this and other detailed design documents to type-check correctly.

\subsection{Z Declarations}

=DOC
type ÛZ_IDİ
=TYPESTRUCT
	= string;
=DESCRIBE
¹Z
Ü	[ÛZ_IDİ]
°
=ENDDOC

=DOC
type ÛZ_DECLİ
=TYPESTRUCT
      = TERM;
=DESCRIBE
A Z declaration is represented as a HOL term using the primitive Z abstract machine constructor $mk\_z\_dec$. e.g. the Z declaration $x : ú$ is represented in {\Product} as the HOL term $ñ‘mk\_z\_dec([ñx®], ñú®)®®$ : TERM   

ÿÛZ_Declİ[Z_EXP]üüüüüüüü
Ü	zvar : OPT[Z_ID];
Ü	zexp : Z_EXP
ˆüüüüüüüüüüüü
=ENDDOC

\subsection{Z Unary Expressions}

¹Z
Ü	ÛZ_UNARY_OPİ ::=
Ü		z_unary_minus
Ü	|	z_real_unary_minus
Ü	|	z_bool_not
Ü	|	z_abs
Ü	|	z_real_abs
Ü	|	z_char_lit
Ü	|	z_string_lit
Ü	|	z_array_not
°


ÿÛZ_Unary_Expİ[Z_EXP]üüüüüüüü
Ü	zop : Z_UNARY_OP;
Ü	zright : Z_EXP
ˆüüüüüüüüüüü

\subsection{Z Binary Expressions}

¹Z
Ü	ÛZ_BIN_OPİ ::=
Ü		z_bool_and
Ü	|	z_bool_or
Ü	|	z_bool_xor
Ü	|	z_bool_and_then
Ü	|	z_bool_or_else
Ü	|	z_bool_eq
Ü	|	z_bool_noteq
Ü	|	z_bool_less
Ü	|	z_bool_less_eq
Ü	|	z_bool_greater
Ü	|	z_bool_greater_eq
Ü	|	z_add
Ü	|	z_minus
Ü	|	z_times
Ü	|	z_intdiv
Ü	|	z_mod
Ü	|	z_rem
Ü	|	z_expon
Ü	|	z_bool_mem
Ü	|	z_bool_notmem
Ü	|	z_real_add
Ü	|	z_real_minus
Ü	|	z_real_times
Ü	|	z_real_over
Ü	|	z_real_expon
Ü	|	z_bool_real_less
Ü	|	z_bool_real_less_eq
Ü	|	z_bool_real_greater
Ü	|	z_bool_real_greater_eq
Ü	|	z_array_and
Ü	|	z_array_or
Ü	|	z_array_xor
Ü	|	z_array_greater
Ü	|	z_array_greater_eq
Ü	|	z_array_less
Ü	|	z_array_less_eq
Ü	|	z_array_array_cat
Ü	|	z_array_elem_cat
Ü	|	z_elem_array_cat
°

ÿÛZ_Bin_Expİ[Z_EXP]üüüüü
Ü	zop : Z_BIN_OP;
Ü	zleft, zright : Z_EXP
ˆüüüüüüüüüüü


\subsection{Z Function Calls}

ÿÛZ_Fun_Callİ[Z_EXP]üüüüü
Ü	zfun : Z_EXP;
Ü	zargs : seq Z_EXP
ˆüüüüüüüüüüü

\subsection{Z Binding Selections}

ÿÛZ_Selectionİ[Z_EXP]üüüü
Ü	zbinding : Z_EXP;
Ü	zselector : Z_ID
ˆüüüüüüüüüüü

\subsection{Z Bindings}

ÿÛZ_Bindingİ[Z_EXP]üüüü
Ü	zbinds : ğ (Z_Decl[Z_EXP])
ˆüüüüüüüüüüü

\subsection{Z Expressions and Predicates}
¹Z
Ü	[ÛZ_REALİ]
°

¹Z
Ü	[ÛZ_STRINGİ]
°


¹Z
Ü	[ÛOTHER_Z_EXPİ]
°

¹Z
Ü	[ÛOTHER_Z_PREDİ]
°
=DOC
type ÛZ_EXPİ
=TYPESTRUCT
	= TERM;
=ENDDOC

=DOC
type ÛZ_PREDİ
=TYPESTRUCT
	= TERM;
=ENDDOC

¹Z
Ü	ÛZ_EXPİ ::=
Ü	z_id Z_ID | z_num ú | z_tfun (Z_EXP ¸ Z_EXP) |
Ü	z_pfun (Z_EXP ¸ Z_EXP) |
Ü	z_int_rng (Z_EXP ¸ Z_EXP)  | z_real_rng (Z_EXP ¸ Z_EXP)|
Ü	z_dom Z_EXP | z_dom_res (Z_EXP ¸ Z_EXP) | z_inv Z_EXP |
Ü	z_id_rel Z_EXP | z_size Z_EXP | z_set (ğ Z_EXP) |
Ü	z_set_minus (Z_EXP ¸ Z_EXP) |
Ü	z_set_comp (Z_Decl[Z_EXP] ¸ Z_PRED) | z_power (Z_EXP ¸ Z_EXP) |
Ü	z_rel_comp (Z_EXP ¸ Z_EXP) |  z_seq (seq Z_EXP) |
Ü	z_cross (Z_EXP ¸ Z_EXP) | z_many_cross (seq Z_EXP) |
Ü	z_override (Z_EXP ¸ Z_EXP) | z_many_union (ğ Z_EXP) |
Ü	z_unary_exp (Z_Unary_Exp[Z_EXP]) | z_bin_exp (Z_Bin_Exp[Z_EXP]) |
Ü	z_fun_call (Z_Fun_Call[Z_EXP]) | z_selection (Z_Selection[Z_EXP]) |
Ü	z_maplet (Z_EXP ¸ Z_EXP) | z_powerset Z_EXP |
Ü	z_binding (Z_Binding[Z_EXP]) | z_tuple (seq‰1 Z_EXP) |
Ü	z_real (Z_REAL) | z_real_to_integer (Z_EXP) | z_integer_to_real (Z_EXP) |
Ü	z_string (Z_STRING) | z_succ | z_theta (Z_EXP) |
Ü	other_z_exp (OTHER_Z_EXP)
Ü& 	(* 
°
¹Z
	*)	
Ü	ÛZ_PREDİ ::=
Ü	z_true | z_eq (Z_EXP ¸ Z_EXP) | z_and (Z_PRED ¸ Z_PRED) |
Ü	z_many_and (ğ Z_PRED) |
Ü	z_elem (Z_EXP ¸ Z_EXP) | z_notelem (Z_EXP ¸ Z_EXP) |
Ü	z_noteq (Z_EXP ¸ Z_EXP) | z_less_eq (Z_EXP ¸ Z_EXP) |
Ü	z_greater (Z_EXP ¸ Z_EXP) | z_forall ((seq Z_Decl[Z_EXP]) ¸ Z_PRED) |
Ü	z_exists (ğ Z_Decl[Z_EXP] ¸ Z_PRED) | z_imp (Z_PRED ¸ Z_PRED) |
Ü	z_mem (Z_EXP ¸ Z_EXP) | other_z_pred (OTHER_Z_PRED)
Ü
°
¹ZAX
Ü Ûzidİ : Z_ID à Z_EXP
°


\subsection{Z Modules}

ÿ ÛZ_MODULEİ üüüüüüüüüüü
Ü mod_name : Z_ID
ˆüüüüüüüüüüüüüü

\subsection{Z Parents}

ÿ ÛZ_PARENTSİ üüüüüüüüüüü
Ü parents : ğZ_ID
ˆüüüüüüüüüüüüüü

\subsection{Z Schemas}

ÿÛZ_Schemaİüüüüü
Ü	z_sname : Z_ID;
Ü	z_decls : ğ Z_Decl[Z_EXP];
Ü	z_pred : Z_PRED
ˆüüüüüüüüüüüüü
ÿÛZ_Constrained_Schemaİüüüüü
	z_sname : Z_ID;
Ü	z_decl  : Z_ID;
Ü	z_pred : Z_PRED
ˆüüüüüüüüüüüüü

\subsection{Z Axiomatic Descriptions}

ÿÛZ_Axİüüüüüüüü
Ü	decls : ğ Z_Decl[Z_EXP];
Ü	preds : ğ Z_PRED
ˆüüüüüüüüüüüüü

\subsection{Verification Conditions}

ÿÛSequentİüüüüüüüü
Ü	H : ğ Z_PRED;
Ü	c : Z_PRED
ˆüüüüüüüüüüüüü

¹Z
Ü	ÛVCİ ¦ (ğ Z_Decl[Z_EXP] ¸ Sequent)
°

\subsection{Z Paragraphs}

¹Z
Ü	[ÛOTHER_Zİ]
°
¹Z
Ü	ÛZ_PARAİ ::=
Ü	z_given (Z_ID) | z_module (Z_MODULE) | z_parents (Z_PARENTS) |
Ü	z_eq_eq (Z_ID ¸ Z_EXP) | z_schema (Z_Schema) | 
Ü	z_constrained_schema(Z_Constrained_Schema) | z_ax (Z_Ax) |
Ü	z_vcs (ğ VC) | other_z (OTHER_Z)
Ü
°
\subsection{Z Types}

ÿÛZ_Schema_Typeİ [ Z_TYPE ] üüüüüüüü
Ü	z_sig : seq (Z_ID ¸ Z_TYPE)
ˆüüüüüüüüüüüüü

¹Z
Ü	[ÛOTHER_Z_TYPEİ]
°

¹Z
Ü	ÛZ_TYPEİ ::=
Ü	z_int_type | 
Ü	z_real_type | 
Ü	z_power_type (Z_TYPE) |
Ü	z_sch_type (Z_Schema_Type[Z_TYPE]) |
Ü	other_z_type (OTHER_Z_TYPE)
Ü
°
¹ZAX
Ü	Ûz_type_ofİ : Z_EXP ­ Z_TYPE
°

\newpage
\section{SPARK ABSTRACT SYNTAX}

\subsection{Expressions}

\subsubsection{Identifiers}

ID is the set of Ada Identifiers.

=DOC
type ÛIDİ
=TYPESTRUCT
	= string;
=DESCRIBE
¹Z
Ü	[ÛIDİ]
°
=ENDDOC

\subsubsection{Aggregates (positional array)}

TMARK is the set of type marks in the literate script.

=DOC
type ÛTMARKİ
=TYPESTRUCT
	= ID;
=DESCRIBE
¹ZAX
Ü	ÛTMARKİ : ğ ID
°
=ENDDOC

=DOC
type ÛOPT_TMARKİ
=TYPESTRUCT
      = TMARK OPT;
=DESCRIBE
¹Z
Ü ÛOPT_TMARKİ ::= opt_tmark_tmark (TMARK) | opt_tmark_none
°
=ENDDOC

Agg\_Pos is a positional array aggregate.

=DOC
type ('EXP) ÛAGG_POSİ
=TYPESTRUCT
      = {
	tmark : OPT_TMARK,
	comps : 'EXP list
	};
=DESCRIBE

ÿÛAgg_Posİ[EXP]üüüüüüüüüüüüüüüüü
Ü	tmark : OPT_TMARK;
Ü	comps : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Aggregates (positional array with others)}
Agg\_Pos\_Others is a positional array with an others part.


=DOC
type ('EXP) ÛOTHERSİ
=TYPESTRUCT
      = {
	others : 'EXP
	};
=DESCRIBE
ÿÛOthersİ[EXP]üüüüüüüüüüüüüüüüü
Ü	others : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


=DOC
type 'EXP ÛAGG_POS_OTHERSİ
=TYPESTRUCT
      = {
	agg_pos : 'EXP AGG_POS,
	others : 'EXP OTHERS
	};
=DESCRIBE
ÿÛAgg_Pos_Othersİ[EXP]üüüüüüüüüüüüü
Ü	Agg_Pos[EXP];
Ü	Others[EXP]
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Aggregates (positional array with just others)}
Agg\_Others is an array aggregate with just an others part.
In ML, the type mark is optional (the aggregate can
only be translated into Z without it when it is contained within an enclosing
aggregate which does have a type mark).


=DOC
type 'EXP ÛAGG_OTHERSİ
=TYPESTRUCT
      = {
	tmark : OPT_TMARK,
	others : 'EXP OTHERS
	};
=DESCRIBE
ÿÛAgg_Othersİ[EXP]üüüüüüüüüüüüü
Ü	tmark : OPT_TMARK;
Ü	Others[EXP]
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Aggregates (named array)}

A range can be just a range attribute which can be represented by one expression. To support this, we introduce a type constructor for a range attribute. 

=DOC
type 'EXP ÛRANGELOHIİ
=TYPESTRUCT
      = {
	lo : 'EXP,
	hi : 'EXP
	};
=DESCRIBE
ÿÛRangeİ[EXP]üüüüüüüüüüüü
Ü	lo, hi : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
=SML
datatype 'EXP ÛRANGEİ =
			ÛRRangeİ of 'EXP RANGELOHI
		|	ÛRRangeAttrİ of 'EXP;
=TEX

Agg\_Choice is an aggregate choice with terms separated by vertical bars.

The datatype for AGG\_CHOICE is introduced in section \ref{datatypedefs}.

¹Z
Ü	[ÛAGG_CHOICEİ]
°

Generic free type definitions are not permitted in Z, so for AGG\_CHOICE we write the following (as per \cite{Spivey92}).

[EXP]œœœœœœœœœœœœœœœœœœœœœœœœœœœœ
Ü	Ûagg_choice_rangeİ : Range[EXP] à AGG_CHOICE;
Ü	Ûagg_choice_singleİ : EXP à AGG_CHOICE
÷üüüüüüüüüüüüüüüüüüüüü
Ü	disjoint §ran agg_choice_range, ran agg_choice_single¢ ±
Ü
Ü	(µ W : ğ AGG_CHOICE ·
Ü	agg_choice_range ¨Range[EXP]© À agg_choice_single ¨EXP© € W
Ü	´ AGG_CHOICE € W)
ˆüüüüüüüüüüüüüüüüüüüüüü

A discrete range can be a type mark with an optional range constraint. The abstract syntax is modified to cover this.
=DOC
type 'EXP ÛDISCRETE_RANGE_CONSTRAINEDİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	range : 'EXP RANGE
	};
=DESCRIBE
=ENDDOC

=DOC
type ('AGG_CHOICE, 'EXP) ÛNAMED_ASSOCİ
=TYPESTRUCT
      = {
	choice : 'AGG_CHOICE list,
	comp : 'EXP
	};
=DESCRIBE
ÿÛNamed_Assocİ[EXP]üüüüüüüüüüüüüüüüü
Ü	choices : ğ AGG_CHOICE;
Ü	comp : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

Agg\_Named models a named array aggregate.
In ML, the type mark is optional (the aggregate cannot be translated into Z without it).


=DOC
type ('AGG_CHOICE, 'EXP) ÛAGG_NAMEDİ
=TYPESTRUCT
      = {
	tmark : OPT_TMARK,
	named_assocs : ('AGG_CHOICE, 'EXP) NAMED_ASSOC list
	};
=DESCRIBE
ÿÛAgg_Namedİ[EXP]üüüüüüüüüüüüü
Ü	tmark : OPT_TMARK;
Ü	named_assocs : ğ Named_Assoc[EXP]
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Aggregates (named array with others)}

Agg\_Named\_Others is a named array aggregate with an others part.
In ML, the type mark (if present) is inside the $agg\_named$ component.

=DOC
type ('AGG_CHOICE, 'EXP) ÛAGG_NAMED_OTHERSİ
=TYPESTRUCT
      = {
	agg_named : ('AGG_CHOICE, 'EXP) AGG_NAMED, 
	others : ('EXP) OTHERS
	};
=DESCRIBE
ÿÛAgg_Named_Othersİ[EXP]üüüüüüüüüüüüüü
Ü	tmark : OPT_TMARK;
Ü	Agg_Named[EXP];
Ü	Others[EXP]
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Aggregates (positional record)}

Rec\_Agg\_Pos is a positional record aggregate.

In ML, the type mark is optional (the aggregate cannot be translated into Z without it).

=DOC
type ('EXP) ÛREC_AGG_POSİ
=TYPESTRUCT
      = {
	tmark : OPT_TMARK,
	comps : 'EXP list
	};
=DESCRIBE
ÿÛRec_Agg_Posİ[EXP]üüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	comps : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Aggregates (named record)}
Rec\_Agg\_Named is a named record aggregate.
The type of $named\_assocs$ is replaced with that used in named array aggregates to support the full syntax.

In ML, the type mark is optional (the aggregate cannot be translated into Z without it).

=DOC
type ('AGG_CHOICE,'EXP) ÛREC_AGG_NAMEDİ
=TYPESTRUCT
      = {
	tmark : OPT_TMARK,
	named_assocs : ('AGG_CHOICE, 'EXP) NAMED_ASSOC list
	};
=DESCRIBE
ÿÛRec_Agg_Namedİ[EXP]üüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	named_assocs : ğ (ID ¸ EXP)
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


\subsubsection{Unary Operations}

=DOC
datatype ÛUNARY_OPİ =
			ÛUOSparkUnaryAddİ
		|	ÛUOSparkUnaryMinusİ
		|	ÛUOSparkNotİ
		|	ÛUOSparkAbsİ;
=DESCRIBE
¹Z
Ü	ÛUNARY_OPİ ::=
Ü	spark_unary_add | spark_unary_minus | spark_not | spark_abs
°
=ENDDOC



=DOC
type ('EXP) ÛUNARY_EXPİ
=TYPESTRUCT
      = {
	uop : UNARY_OP,
	right : 'EXP
	};
=DESCRIBE
ÿÛUnary_Expİ[EXP]üüüüüüüüüüüüüüüüü
Ü	op : UNARY_OP;
Ü	right : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


\subsubsection{Binary Expressions}


The binary operators $BOSparkAndThen$, $BOSparkOrElse$ and $BOSparkConcat$ have been added.
=DOC
datatype ÛBIN_OPİ =
			ÛBOSparkAndİ | ÛBOSparkAndThenİ
		|	ÛBOSparkOrİ | ÛBOSparkOrElseİ | ÛBOSparkXorİ
		|	ÛBOSparkEqİ | ÛBOSparkNotEqİ
		|	ÛBOSparkLessİ | ÛBOSparkLessEqİ
		|	ÛBOSparkGreaterİ | ÛBOSparkGreaterEqİ
		|	ÛBOSparkAddİ | ÛBOSparkMinusİ | ÛBOSparkTimesİ
		|	ÛBOSparkDivİ | ÛBOSparkModİ | ÛBOSparkRemİ
		|	ÛBOSparkExponİ
		|	ÛBOSparkMemİ | ÛBOSparkNotMemİ
		|	ÛBOSparkConcatİ;
=DESCRIBE
¹Z
Ü	ÛBIN_OPİ ::=
Ü	spark_and | spark_or | spark_xor | spark_and_then | spark_or_else |
Ü	spark_eq | spark_noteq | spark_less | spark_less_eq | spark_greater |
Ü	spark_greater_eq | spark_add | spark_minus | spark_times | spark_intdiv |
Ü	spark_mod | spark_rem | spark_expon | spark_mem | spark_notmem |
Ü	spark_over | spark_cat
°
=ENDDOC


=DOC
type 'EXP ÛBIN_EXPİ
=TYPESTRUCT
      = {
	bop : BIN_OP,
	left : 'EXP,
	right : 'EXP
	};
=DESCRIBE
ÿÛBin_Expİ[EXP]üüüüüüüüüüüüüüüüü
Ü	op : BIN_OP;
Ü	left, right : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

Mem\_Range is the membership (or non-membership) of a range.


=DOC
type ÛMEM_OPİ
=TYPESTRUCT
	= BIN_OP;
=DESCRIBE
¹Z
Ü	ÛMEM_OPİ ¦ {spark_mem, spark_notmem}
°
=ENDDOC


$op$ is a reserved word in Standard ML; hence we rename $op$ to $mop$.

=DOC
type ('EXP) ÛMEM_RANGEİ
=TYPESTRUCT
      = {
	left : 'EXP,
	mop : MEM_OP,
	range : 'EXP RANGE
	};
=DESCRIBE
ÿÛMem_Rangeİ[EXP]üüüüüüüüüüüüüüüüü
Ü	left : EXP;
Ü	op : MEM_OP;
Ü	Range[EXP]
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


\subsubsection{Attributes}
Attribute models Ada attributes.

ATTRIB denotes the attribute designators FIRST, LAST, SUCC, PRED, POS, VAL, LENGTH and RANGE.


=DOC
type ÛATTRIBİ
=TYPESTRUCT
	= ID;
=DESCRIBE
¹ZAX
Ü	Ûfstİ, Ûlstİ, Ûsucİ, Ûpredİ, Ûposİ, Ûvalİ, Ûlengthİ, Ûrangeİ, Ûdigitsİ, Ûdeltaİ : ID
°
¹Z
Ü	ÛATTRIBİ ¦ {fst, lst, suc, pred, pos, val, length, range, digits, delta}
°
¹ZAX
Ü Ûaftİ, Ûbaseİ, Ûemaxİ, Ûepsilonİ,
Ü Ûforeİ, Ûlargeİ, Ûmachine_emaxİ, Ûmachine_eminİ, 
Ü Ûmachine_mantissaİ, Ûmachine_overflowsİ,
Ü Ûmachine_radixİ, Ûmachine_roundsİ,
Ü Ûmantissaİ, Ûsafe_emaxİ, Ûsafe_largeİ, Ûsafe_smallİ,
Ü Ûsizeİ, Ûsmallİ : ID
°
¹Z
Ü ÛOTHER_ATTRIBİ ¦ {
Ü  aft, base, emax, epsilon,
Ü  fore, large, machine_emax, machine_emin, 
Ü  machine_mantissa, machine_overflows, machine_radix, machine_rounds,
Ü  mantissa, safe_emax, safe_large, safe_small,
Ü  size, small}
°
=ENDDOC

ATTRIB\_DESIG models the attribute designators.

Generic free type definitions are not permitted in Z, so for ATTRIB\_DESIG we write the following (as per \cite{Spivey92}).

¹Z
Ü	[ÛATTRIB_DESIGİ]
°

[EXP]œœœœœœœœœœœœœœœœœœœœœœœœœœœœ
Ü	Ûattribİ : ATTRIB À OTHER_ATTRIB à ATTRIB_DESIG;
Ü	Ûattrib_argİ : (ATTRIB ¸ EXP) à ATTRIB_DESIG
÷üüüüüüüüüüüüüüüüüüüüü
Ü	disjoint §ran attrib, ran attrib_arg¢ ±
Ü
Ü	(µ W : ğ ATTRIB_DESIG ·
Ü	attrib ¨ATTRIB À OTHER_ATTRIB© À attrib_arg ¨ATTRIB ¸ EXP© € W
Ü	´ ATTRIB_DESIG € W)
ˆüüüüüüüüüüüüüüüüüüüüüü



The datatype for ATTRIB\_DESIG is declared in section \ref{TypeDefExpr}.


The prefix can in fact be a name (i.e., an expression).
=DOC
type ('EXP,'ATTRIB_DESIG) ÛATTRIBUTEİ
=TYPESTRUCT
      = {
	prefix : 'EXP,
	attribute_desig : 'ATTRIB_DESIG
	};
=DESCRIBE
ÿÛAttributeİüüüüüüüüüüüüüüüüü
Ü	prefix : ID;
Ü	attrib_desig : ATTRIB_DESIG
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Indexed Component}
Indexed\_Comp models an array component.


=DOC
type ('EXP) ÛINDEXED_COMPİ
=TYPESTRUCT
      = {
	prefix : 'EXP,
	index : 'EXP
	};
=DESCRIBE
ÿÛIndexed_Compİ[EXP]üüüüüüüüüüüüüüüüü
Ü	prefix : EXP;
Ü	index : seq‰1 EXP
ˆüüüüüüüüüüüüüüüüüüüüü
Due to the overloading of round brackets in the Ada concrete syntax,
the sequence of expressions is represented by the parser as a positional
array aggregate ---  a single expression. The sequence given in the
specification by {\it index} is then the sequence of components of
this aggregate.
=ENDDOC

\subsubsection{Selected Component}
Selected\_Comp is a record component.


=DOC
type ('EXP) ÛSELECTED_COMPİ
=TYPESTRUCT
      = {
	prefix : 'EXP,
	selector : ID
	};
=DESCRIBE
ÿÛSelected_Compİ[EXP]üüüüüüüüüüüüüüüüü
Ü	prefix : EXP;
Ü	selector : ID
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Function Calls}
Fun\_Call is a function call.


=DOC
type ('EXP) ÛFUN_CALLİ
=TYPESTRUCT
      = {
	fun_name : ID,
	args : 'EXP list
	};
=DESCRIBE
ÿÛFun_Callİ[EXP]üüüüüüüüüüüüüüüüü
Ü	fun_name : ID;
Ü	args : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Qualified Expressions}


=DOC
type 'EXP ÛQUALIFIED_EXPRESSIONİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	exp : 'EXP
	};
=DESCRIBE
ÿÛQualified_Expİ[EXP]üüüüüüüüüüüüüüüüü
Ü	ex : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
The ML formulation preserves the type mark for inclusion in the SPARK program.
=ENDDOC
\subsubsection{Type Conversions}


=DOC
type 'EXP ÛTYPE_CONVERSIONİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	exp : 'EXP
	};
=DESCRIBE
ÿÛType_Convİ[EXP]üüüüüüüüüüüüüüüüü
Ü	tm : TMARK;
Ü	ex : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
The ML names are slightly less terse than the Z ones for historical reasons.
=ENDDOC
\subsubsection{Numeric Literals}
INT\_LIT comprises the integer literals
and REAL\_LIT comprises the real literals.



=DOC
type ÛINT_REAL_LITİ
=TYPESTRUCT
	= string;
=DESCRIBE
We use strings to represent numeric literals, either integer or real,
so that the precise lexical form of the input can be reproduced in the SPARK program.
Thus the above type NUM\_LIT is the ML representation of both integer and
real literals.
The string is converted into a number when an expression containing a literal
is converted into Z.
¹Z
Ü	[ÛINT_LITİ]
°
¹Z
Ü	[ÛREAL_LITİ]
°
=ENDDOC

\subsubsection{Character Literals}
CHAR\_LIT comprises the character literals.


=DOC
type ÛCHAR_LITİ
=TYPESTRUCT
	= string;
=DESCRIBE
¹Z
Ü	[ÛCHAR_LITİ]
°
=ENDDOC


\subsubsection{String Literals}
STRING\_LIT comprises the string literals.


=DOC
type ÛSTRING_LITİ
=TYPESTRUCT
	= string;
=DESCRIBE
¹Z
Ü	[ÛSTRING_LITİ]
°
=ENDDOC


\subsubsection{Auxiliary Expressions}
In the Compliance Notation, a SPARK expression can also be a Z expression (auxiliary expression).

In their use, they are expressions so appear as a branch of expressions.

\subsubsection{Type Definition for Expressions}\label{TypeDefExpr}

In order to reproduce the SPARK program as the user entered it, it is necessary to store bracketing information in the abstract syntax. Also qualified expressions, type conversions, string and character literals have been added.

The Auxiliary expression is represented as a parsed (but not type-checked) Z term. The type inference occurs during VC generation. (Note {\it id} is a toolkit operator in Z, therefore
{\it Id} is used instead.)

The datatype for EXP is introduced in section \ref{datatypedefs}.

¹Z
Ü	[ÛOTHER_EXPİ]
°

¹Z
Ü	ÛEXPİ ::=	
Ü		Id ID | int INT_LIT | array_agg_pos (Agg_Pos[EXP]) |
Ü		array_agg_pos_others (Agg_Pos_Others[EXP]) |
Ü		array_agg_others (Agg_Others[EXP]) |
Ü		array_agg_named (Agg_Named[EXP]) |
Ü		array_agg_named_others (Agg_Named_Others[EXP]) |
Ü		rec_agg_pos (Rec_Agg_Pos[EXP]) |
Ü		rec_agg_named (Rec_Agg_Named[EXP]) |
Ü		unary_exp (Unary_Exp[EXP]) | bin_exp (Bin_Exp[EXP]) |
Ü		mem_range (Mem_Range[EXP]) | attribute Attribute |
Ü		indexed_comp (Indexed_Comp[EXP]) |
Ü		selected_comp (Selected_Comp[EXP]) |
Ü		fun_call (Fun_Call[EXP]) |
Ü		qualified_exp (Qualified_Exp[EXP]) |
Ü		type_conv (Type_Conv[EXP]) |
Ü		char (CHAR_LIT) | string (STRING_LIT) | real (REAL_LIT) |
Ü		auxiliary_exp (Z_EXP) | other_exp (OTHER_EXP)
°

\subsection{Basic Declarations}

The Z specification of the abstract syntax uses a given set declaration to act as a forward declaration of the free type $EXP$, permitting the free type to involve recursion through schema constructions.
Unfortunately, this style is not considered to be type correct in \ProductZ; this is readily circumvented by making the schema constructions generic where necessary.



\subsubsection{Constants}
Const\_Decl models constant declarations.


It is useful to keep a list of the constants declared in the same constant declaration for reproducibility. The const component is therefore implemented as a list.
The type mark is optional to support named number declarations.
=DOC
type 'EXP ÛCONST_DECLİ
=TYPESTRUCT
      = {
	consts : ID list,
	tm : TMARK OPT,
	expr : 'EXP
	};
=DESCRIBE
ÿÛConst_Declİ[EXP]üüüüüüüüüüüüüüüüü
Ü	const : ID;
Ü	tm : OPT[TMARK];
Ü	expr : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Enumerated Types}
Enum\_Type\_Def models enumerated types.


=DOC
type ÛENUM_TYPE_DEFİ
=TYPESTRUCT
      = {
	vals : ID list
	};
=DESCRIBE
ÿÛEnum_Type_Defİüüüüüüüüüüüü
Ü	vals : seq ID
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Array Types}
Array\_Def models array types.

=DOC
type ÛARRAY_DEFİ
=TYPESTRUCT
      = {
	index : TMARK list,
	comp : TMARK
	};
=DESCRIBE
ÿÛArray_Defİüüüüüüüüüüüü
Ü	index : seq‰1 TMARK;
Ü	comp : TMARK
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


\subsubsection{Record Types}

Var\_Decl is an Ada variable declaration.

In order to maintain the reproducability of the input, it is necessary to include all the identifiers together in a VAR\_DECL.
=DOC
type ÛVAR_DECLİ
=TYPESTRUCT
      = {
	vars : ID list,
	tmark : TMARK
	};
=DESCRIBE
ÿÛVar_Declİüüüüüüüüüüüü
Ü	var : ID;
Ü	tmark : TMARK
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


Record\_Type\_Def models record types.

=DOC
datatype 'EXP ÛCOMP_CONSTRAINTİ =
		ÛCCNoConİ
	|	ÛCCIndexConİ of 'EXP list
	|	ÛCCDiscConİ of 'EXP list;
type 'EXP ÛCOMP_DECLİ
=TYPESTRUCT
      = VAR_DECL * 'EXP COMP_CONSTRAINT;
=DESCRIBE
¹Z
ÛCOMP_SUB_INDİ ::=
		comp_sub_ind_tmark (TMARK)
	|	comp_sub_ind_range (EXP ¸ EXP)
°
¹Z
ÛCOMP_CONSTRAINTİ ::=
		comp_no_con
	|	comp_index_con (seq COMP_SUB_IND)
	|	comp_disc_con (ID ß EXP)
°
ÿ ÛComp_Declİ üüüüüüüüüüü
Ü 	Var_Decl;
Ü	constraint : COMP_CONSTRAINT
ˆüüüüüüüüüüüüüü
In the implementation, the type {\it EXP} is wide enough to carry the semantics
of a {\it COMP\_SUB\_IND}.
=ENDDOC
=DOC
type ÛDISCRIMINANT_SPECIFICATIONİ
=TYPESTRUCT
      = VAR_DECL;
=DESCRIBE
=ENDDOC
=DOC
type 'EXP ÛRECORD_TYPE_DEFİ
=TYPESTRUCT
      = {
	decl : 'EXP COMP_DECL list,
	disc : DISCRIMINANT_SPECIFICATION list
	};
=DESCRIBE
ÿÛRecord_Type_Defİüüüüüüüüüüüü
Ü	decl : seq Comp_Decl;
Ü	disc : seq Var_Decl
ˆüüüüüüüüüüüüüüüüüüüüü
The ML representation covers both schemas (the first corresponding
to an empty list in the {\it disc} component).
=ENDDOC

\subsubsection{Integer Types}

An integer type is characterised by its range.

\subsubsection{Real Types}
=DOC
type 'EXP ÛFLOATING_POINT_CONSTRAINTİ
=TYPESTRUCT
      = {
	exp : 'EXP,
	range : 'EXP RANGE OPT
	};
=DESCRIBE
ÿÛFloating_Type_Def_Rangeİüüüüüüüüüüüü
Ü	digits : EXP;
Ü	Range[EXP]
ˆüüüüüüüüüüüüüüüüüüüüü

ÿÛFloating_Type_Def_No_Rangeİüüüüüüüüüüüü
Ü	digits : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
=DOC
type 'EXP ÛFIXED_POINT_CONSTRAINTİ
=TYPESTRUCT
	= 'EXP FLOATING_POINT_CONSTRAINT;
=DESCRIBE
ÿÛFixed_Type_Defİüüüüüüüüüüüü
Ü	delta : EXP;
Ü	Range[EXP]
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
type 'EXP ÛFLOATING_TYPE_DEFİ
=TYPESTRUCT
	= 'EXP FLOATING_POINT_CONSTRAINT;
=DESCRIBE
=ENDDOC

=DOC
type 'EXP ÛFIXED_TYPE_DEFİ
=TYPESTRUCT
	= 'EXP FIXED_POINT_CONSTRAINT;
=DESCRIBE
=ENDDOC


\subsubsection{Type Definitions}

The datatype for TYPE\_DEF is introduced in section \ref{datatypedefs}.
¹Z
ÛTYPE_DEFİ ::= enum_type_def Enum_Type_Def | int_type_def (Range[EXP]) |
		uncon_array_def Array_Def | con_array_def Array_Def |
		record_type_def Record_Type_Def |
		fixed_type_def Fixed_Type_Def |
		floating_type_def_range Floating_Type_Def_Range |
		floating_type_def_no_range Floating_Type_Def_No_Range
°

An additional constructor is provided for private types and for reals to support the complete syntax.

\subsubsection{Type Declarations}
Type\_Decl is a type declaration, that is a type definition together with its name.
=DOC
type 'TYPE_DEF ÛTYPE_DECLİ
=TYPESTRUCT
      = {
	name : ID,
	type_def : 'TYPE_DEF
	};
=DESCRIBE
ÿÛType_Declİüüüüüüüüüüüü
Ü	name : ID;
Ü	type_def : TYPE_DEF
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{SubTypes}
Subtype\_Decl models subtype declarations.

The datatype for CONSTRAINT is introduced in section \ref{datatypedefs}.

¹Z
ÛCONSTRAINTİ ::= range_con (Range[EXP])
	| floating_con Floating_Type_Def_Range
	| fixed_con Fixed_Type_Def
	| index_con (seq TMARK)
	| discriminant_con (ID ß EXP)
	| no_con
°

Sub\_Ind is a subtype indication.


=DOC
type 'CONSTRAINT ÛSUB_INDİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	con : 'CONSTRAINT
	};
=DESCRIBE
ÿÛSub_Indİüüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	con : CONSTRAINT
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


=DOC
type 'CONSTRAINT ÛSUBTYPE_DECLİ
=TYPESTRUCT
      = {
	name : ID,
	sub_ind : 'CONSTRAINT SUB_IND
	};
=DESCRIBE
ÿÛSubtype_Declİüüüüüüüüüüüüüüüüü
Ü	name : ID;
Ü	Sub_Ind
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


\subsubsection{Deferred Constants}

Abstract syntax is also required for deferred constants.
=DOC
type ÛDEFERRED_CONST_DECLİ
=TYPESTRUCT
      = {
	consts : ID list,
	tmark : TMARK
	};
=DESCRIBE
=ENDDOC
\subsubsection{Private Types}
Private types are part of the syntax.
=DOC
type ÛPRIVATE_TYPE_DECLİ
=TYPESTRUCT
      = {
	id : ID,
	disc : DISCRIMINANT_SPECIFICATION list,
	limited : bool
	};
=DESCRIBE
=ENDDOC

\subsubsection{Pragma}\label{pragma}
=DOC
type ('AGG_CHOICE, 'EXP) ÛPRAGMAİ
=TYPESTRUCT
      = {id : ID,
	  args : ('AGG_CHOICE OPT * 'EXP) list};
=DESCRIBE
This type gives the abstract syntax of SPARK pragmas (which are just treated as data to be written out to the SPARK program by the compliance tool).
=ENDDOC
\subsubsection{Labels}\label{labels}
Labels can appear next to k-slots or specification statements.
=DOC
type ÛLABELİ
=TYPESTRUCT
      = string;
=DESCRIBE
=ENDDOC
\subsubsection{K-Slots}\label{kslots}
K-Slots are required in the abstract syntax as place markers so that when the SPARK program is reproduced from the abstract syntax, the expansions can be put back into the correct places.
=DOC
type ÛK_SLOTİ
=TYPESTRUCT
      = {
	content : string,
	label : LABEL
	};
=DESCRIBE
=ENDDOC
\subsubsection{Annotation}\label{annotation}
=DOC
datatype ÛANNİ
      = ÛANStringİ of string | ÛANKSlotİ of K_SLOT;
type ÛANNOTATIONİ
=TYPESTRUCT
      = ANN list;
=DESCRIBE
These types gives the abstract syntax of SPARK annotations (which are just treated as data to be written out to the SPARK program by the compliance tool).
A k-slot can be used to defer presentation of the text of an annotation.
=ENDDOC
\subsubsection{Basic Declarations}

The datatype for BASIC\_DECL is introduced in section \ref{datatypedefs}.

¹Z
ÛBASIC_DECLİ ::= const_decl (Const_Decl[EXP]) | type_decl Type_Decl |
		subtype_decl Subtype_Decl
°

\subsection{Datatypes for Free Type Definitions}\label{datatypedefs}

=SML
datatype ÛCONSTRAINTİ =
			ÛCRangeİ of EXP RANGE
		|	ÛCFloatingİ of EXP FLOATING_POINT_CONSTRAINT
		|	ÛCFixedİ of EXP FIXED_POINT_CONSTRAINT
		|	ÛCIndexİ of EXP list
		|	ÛCDiscriminantİ of EXP list
		|	ÛCNoConİ 
and ÛCASE_CHOICEİ =
				ÛCCCaseExpİ of EXP
			|	ÛCCCaseRangeİ of DISCRETE_RANGE
and ÛBASIC_DECLİ =
			ÛBDConstDeclİ of (EXP) CONST_DECL
		|	ÛBDDeferredConstDeclİ of DEFERRED_CONST_DECL
		|	ÛBDTypeDeclİ of (TYPE_DEF) TYPE_DECL
		|	ÛBDVarDeclİ of VAR_DECL
		|	ÛBDVarDeclInitİ of (VAR_DECL * EXP)
		|	ÛBDSubtypeDeclİ of (CONSTRAINT) SUBTYPE_DECL
		|	ÛBDPrivateTypeDeclİ of PRIVATE_TYPE_DECL
		|	ÛBDPragmaİ of (AGG_CHOICE, EXP) PRAGMA
		|	ÛBDAnnotationİ of ANNOTATION
and ÛATTRIB_DESIGİ =
			ÛADAttribİ of ATTRIB
		|	ÛADAttribArgİ of (ATTRIB * EXP)
and ÛDISCRETE_RANGEİ =
			ÛDRRangeİ of EXP RANGE
		|	ÛDRConstrainedİ of EXP DISCRETE_RANGE_CONSTRAINED
and ÛAGG_CHOICEİ =
			ÛACAggChoiceRangeİ of DISCRETE_RANGE
		|	ÛACAggChoiceSingleİ of EXP

and ÛTYPE_DEFİ =
			ÛTDEnumTypeDefİ of ENUM_TYPE_DEF
		|	ÛTDIntTypeDefİ of EXP RANGE
		|	ÛTDFloatingTypeDefİ of EXP FLOATING_TYPE_DEF
		|	ÛTDFixedTypeDefİ of EXP FIXED_TYPE_DEF
		|	ÛTDUnconArrayDefİ of ARRAY_DEF
		|	ÛTDConArrayDefİ of ARRAY_DEF
		|	ÛTDRecordTypeDefİ of EXP RECORD_TYPE_DEF

and ÛEXPİ =
		ÛEIdİ of ID
	|	ÛEIntRealİ of INT_REAL_LIT
	|	ÛEArrayAggPosİ of EXP AGG_POS
	|	ÛEArrayAggPosOthersİ of EXP AGG_POS_OTHERS
	|	ÛEArrayAggOthersİ of EXP AGG_OTHERS
	|	ÛEArrayAggNamedİ of (AGG_CHOICE,EXP) AGG_NAMED
	|	ÛEArrayAggNamedOthersİ of
			(AGG_CHOICE,EXP) AGG_NAMED_OTHERS
	|	ÛERecAggPosİ of EXP AGG_POS
	|	ÛERecAggNamedİ of (AGG_CHOICE,EXP) REC_AGG_NAMED
	|	ÛEUnaryExpİ of EXP UNARY_EXP
	|	ÛEBinExpİ of EXP BIN_EXP
	|	ÛEMemRangeİ of EXP MEM_RANGE
	|	ÛEAttributeİ of (EXP,ATTRIB_DESIG) ATTRIBUTE
	|	ÛEIndexedCompİ of EXP INDEXED_COMP
	|	ÛESelectedCompİ of EXP SELECTED_COMP
	|	ÛEFunCallİ of EXP FUN_CALL
	|	ÛEAuxiliaryExpİ of ZUserInterfaceSupport.Z_TM
	|	ÛEQualifiedExpİ of EXP QUALIFIED_EXPRESSION
	|	ÛETypeConversionİ of EXP TYPE_CONVERSION
	|	ÛEBracketedİ of EXP
	|	ÛEStringLiteralİ of STRING_LIT
	|	ÛECharacterLiteralİ of CHAR_LIT
	|	ÛEDiscreteRangeİ of DISCRETE_RANGE;
=TEX
The constructor {\it EDiscreteRange} above is introduced for the convenience
of the parser. It will never appear in an expression formed from syntactically
correct Ada.
\subsection{Derived Abstract Syntax for Basic Declarations}
=DOC
datatype ÛSI_DISCRETE_RANGEİ =
		ÛSIDiscreteRangeSubIndİ of CONSTRAINT SUB_IND
	|	ÛSIDiscreteRangeRangeİ of EXP RANGE;
=DESCRIBE
¹Z
Ü ÛSI_Discrete_Rangeİ ::=
Ü	Ûsi_discrete_range_subindİ Sub_Ind
Ü |	Ûsi_discrete_range_rangeİ (Range[EXP]) 
°
=ENDDOC
=DOC
datatype ÛSI_CONSTRAINTİ =
		ÛSIRangeConİ of EXP RANGE
	|	ÛSIFixedConİ of EXP FIXED_POINT_CONSTRAINT
	|	ÛSIFloatingConİ of EXP FLOATING_POINT_CONSTRAINT
	|	ÛSIIndexConİ of SI_DISCRETE_RANGE list
	|	ÛSIDiscriminantConİ of EXP list
	|	ÛSINoConİ;
=DESCRIBE
¹Z
Ü ÛSI_CONSTRAINTİ ::=
Ü 	Ûsi_range_conİ (Range[EXP]) |  Ûsi_fixed_con Fixed_Type_Defİ |
Ü	Ûsi_floating_conİ Floating_Type_Def_Range |
Ü	Ûsi_index_conİ (seq SI_Discrete_Range) |
Ü	Ûsi_discriminant_conİ (ID ß EXP) | Ûsi_no_conİ
°
The context free parser is unable to distinguish between index constraints and discriminant
constraints, nor can it disentangle named parameter associations in discriminant
constraints. It produces a discriminant constraint containing a single expression which
is an aggregate representing the construct in brackets that was the concrete syntax encountered
as the constraint.
=ENDDOC
=DOC
type ÛSI_SUB_INDİ
=TYPESTRUCT
	= {	tmark : TMARK,
		con : SI_CONSTRAINT
	};
=DESCRIBE
ÿÛSI_Sub_Indİüü
Ü  tmark : TMARK;
Ü  con  : SI_CONSTRAINT
ˆü
=ENDDOC
=DOC
type ÛSI_CONST_DECLİ
=TYPESTRUCT
	= {	consts : ID list,
		t : SI_SUB_IND OPT,
		expr : EXP
	};
=DESCRIBE
ÿÛSI_Const_Declİüüü
Ü const : ID;
Ü t : OPT[SI_Sub_Ind];
Ü expr : EXP
ˆüüüüüüüüüü
=ENDDOC
=DOC
type ÛSI_ARRAY_DEFİ
=TYPESTRUCT
	= {	index : SI_DISCRETE_RANGE list,
		comp : SI_SUB_IND
	};
=DESCRIBE
ÿÛSI_Array_Defİüü
Ü index : seq‰1 SI_Discrete_Range;
Ü comp : SI_Sub_Ind
ˆüü
=ENDDOC
=DOC
type ÛSI_VAR_DECLİ
=TYPESTRUCT
	= {	vars : ID list,
		t : SI_SUB_IND
	};
=DESCRIBE
ÿÛSI_Var_Declİüüü
Ü var : ID;
Ü t : SI_Sub_Ind
ˆüü
=ENDDOC
=DOC
type ÛSI_RECORD_TYPE_DEFİ
=TYPESTRUCT
	= {
	decl : SI_VAR_DECL list,
	disc : DISCRIMINANT_SPECIFICATION list
	};
=DESCRIBE

ÿÛSI_Record_Type_Defİüüü
Ü decl : seq SI_Var_Decl;
Ü disc : seq Var_Decl
ˆ
=ENDDOC
=DOC
datatype ÛSI_TYPE_DEFİ =
		ÛSIEnumTypeDefİ of ENUM_TYPE_DEF
	|	ÛSIIntTypeDefİ of EXP RANGE
	|	ÛSIUnconArrayDefİ of SI_ARRAY_DEF
	|	ÛSIConArrayDefİ of SI_ARRAY_DEF
	|	ÛSIRecordTypeDefİ of SI_RECORD_TYPE_DEF
	|	ÛSIFloatingTypeDefİ of EXP FLOATING_TYPE_DEF
	|	ÛSIFixedTypeDefİ of EXP FIXED_TYPE_DEF;

=DESCRIBE
¹Z
Ü  ÛSI_TYPE_DEFİ ::=
Ü    Ûsi_enum_type_defİ Enum_Type_Def | Ûsi_int_type_defİ (Range[EXP]) |
Ü    Ûsi_uncon_array_defİ SI_Array_Def | Ûsi_con_array_defİ SI_Array_Def |
Ü    Ûsi_record_type_defİ SI_Record_Type_Def |
Ü    Ûsi_fixed_type_defİ Fixed_Type_Def |
Ü    Ûsi_floating_type_def_rangeİ Floating_Type_Def_Range |
Ü    Ûsi_floating_type_def_no_rangeİ Floating_Type_Def_No_Range
°
=ENDDOC
=DOC
type ÛSI_TYPE_DECLİ
=TYPESTRUCT
	= {	name : ID,
		type_def : SI_TYPE_DEF
};
=DESCRIBE
ÿÛSI_Type_Declİüü
Ü name : ID;
Ü type_def : SI_TYPE_DEF
ˆüü
=ENDDOC
=DOC
type ÛSI_SUBTYPE_DECLİ
=TYPESTRUCT
	= {	name : ID,
		type_def : SI_SUB_IND
};
=DESCRIBE
ÿÛSI_Subtype_Declİüü
Ü  name : ID;
Ü  SI_Sub_Ind
ˆüü
=ENDDOC
=DOC
datatype ÛSI_BASIC_DECLİ = 
		ÛSIConstDeclİ of SI_CONST_DECL
	|	ÛSIDeferredConstDeclİ of DEFERRED_CONST_DECL
	|	ÛSITypeDeclİ of SI_TYPE_DECL
	|	ÛSIVarDeclİ of SI_VAR_DECL
	|	ÛSIVarDeclInitİ of (SI_VAR_DECL * EXP)
	|	ÛSISubtypeDeclİ of SI_SUBTYPE_DECL
	|	ÛSIPrivateTypeDeclİ of PRIVATE_TYPE_DECL
	|	ÛSIPragmaİ of (AGG_CHOICE, EXP) PRAGMA
	|	ÛSIAnnotationİ of ANNOTATION;
=DESCRIBE
¹Z
Ü  ÛSI_BASIC_DECLİ ::=
Ü    Ûsi_const_declİ SI_Const_Decl | Ûsi_type_declİ SI_Type_Decl |
Ü    Ûsi_subtype_declİ SI_Subtype_Decl
°
=ENDDOC


\subsection{Statements}

The Z specification of the abstract syntax uses a given set declaration to act as a forward declaration of the free type $Statement$, permitting the free type to involve recursion through schema constructions.
Unfortunately, this style is not considered to be type correct in \ProductZ; this is readily circumvented by making the schema constructions generic where necessary.
For example, see section \ref{if-then-else} below.

Following this convention we may now work through the abstract syntax for SPARK statements following \cite[volume 2]{DRA/CIS/CSE3/TR/94/27/3.0}.

\subsubsection{Null}\label{null}

The abstract syntax for null is provided as a data constructor within the type $Statement$ (see section \ref{statement}).

\subsubsection{Assignment}\label{assignment}


=DOC
type ÛASSIGNİ
=TYPESTRUCT
      = {
	name : EXP,
	e : EXP
	};
=DESCRIBE
ÿÛAssignİüüüüüüüüüüüüüüüüü
Ü	name, E : EXP
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Specification Statements}


=DOC
(* type ÛZ_PREDİ *)
=TYPESTRUCT
(*	= Z_PRED; *)
=DESCRIBE
¹ZAX
Ü	ÛZ_PRED‰0İ : ğ Z_PRED
°
=ENDDOC

The pre- and post-conditions in the specification are represented as parsed but not type-checked Z terms. This is so that type inference can be performed in the correct environment during VC generation. Note that in the Z, $pre$ is a reserved word, and so we use $Pre$.
=DOC
type ÛSPECİ
=TYPESTRUCT
      = {
	w : Z_ID list,
	w0 : Z_ID list,
	pre : ZUserInterfaceSupport.Z_TM,
	post : ZUserInterfaceSupport.Z_TM
	};
=DESCRIBE
ÿÛSpecİüüüüüüüüüüüüüüüüü
Ü	w, w‰0 : ğ Z_ID;
Ü	Pre, post : Z_PRED
÷üüüüüüüüüüüüüüü
Ü	Pre  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
A specification statement may be labelled. It also has a boolean attribute indicating whether or
not it is an assertion (i.e., a specification statement introduced using $\Gamma$ rather than $\Delta$
and refined by no code).
=DOC
type ÛSPEC_NO_IVARSİ
=TYPESTRUCT
      = {
	spec : SPEC,
	label : LABEL,
	is_assertion : bool
	};
=DESCRIBE
ÿÛSpec_No_Ivarsİüüüüüüüüüüüü
Ü	Spec
÷üüüüüüüüüüüüüüü
Ü	post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Semicolon}\label{semicolon}

The abstract syntax for semicolon is provided as a data constructor within the type $STATEMENT$ (see section \ref{statement}).

\subsubsection{If-then-else}\label{if-then-else}


In a nested if statement 

=GFT SPARK Fragment
IF	<cond>	THEN	<stmt>;
ELSIF	<cond>	THEN	<stmt>;
...
ELSIF	<cond>	THEN	<stmt>;
END IF;
=TEX
is equivalent to
=GFT SPARK Fragment
IF	<cond>	THEN	<stmt>;
ELSE IF	<cond>	THEN	<stmt>; 
...
ELSE IF	<cond>	THEN	<stmt>; END IF; ... END IF;
END IF;
=TEX

I.e., ELSIF is the same as writing ELSE IF. In order to make the input reproducable in the SPARK program to be generated, a flag is stored with each abstract representation of the if statement indicating whether the else condition was input as an ELSIF or not.
=DOC
type ÛCONDİ
=TYPESTRUCT
	= EXP;
=DESCRIBE
¹ZAX
Ü	ÛCONDİ : ğ EXP
°
=ENDDOC

=DOC
type ('STATEMENT) ÛIF_THEN_ELSEİ
=TYPESTRUCT
      = {
	g : COND,
	p : 'STATEMENT,
	q : 'STATEMENT,
	elsif : bool
	};
=DESCRIBE
ÿÛIf_Then_Elseİ[Statement]üüüüüüüüüüüüüüüüü
Ü	G : COND;
Ü	P, Q : Statement
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Case}\label{case}


The case choice can be a discrete range. It is added to support the full syntax.
The type definition is introduced in section \ref{datatypedefs}.

¹Z
Ü	ÛCASE_CHOICEİ ::= case_exp EXP | case_range (Range[EXP])
°


=DOC
type 'STATEMENT ÛCASE_ALTERNATIVEİ
=TYPESTRUCT
      = {
	choices : CASE_CHOICE list,
	p : 'STATEMENT
	};
=DESCRIBE
ÿÛCase_Alternativeİ[Statement]üüüüüüüüüüüüüüüüü
Ü	choices : ğ CASE_CHOICE;
Ü	P : Statement
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
=DOC
type 'STATEMENT ÛCASEİ
=TYPESTRUCT
      = {
	e : EXP,
	s : ('STATEMENT) CASE_ALTERNATIVE list,
	others : 'STATEMENT
	};
=DESCRIBE
A Case statement can have an others part.
In the implementation the same ML record type is used for case
statements with and without others, using a special dummy others
part where the concrete syntax has no others part.
For historical reasons, and to emphasise the difference in
the representation, ``{\it others}'' is used rather than ``{\it q}''
for this component in the ML.

ÿÛCaseİ[Statement]üüüüüüüüüüüüüüüüüüüü
Ü	E : EXP;
Ü	s : seq‰1 Case_Alternative[Statement]
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
ÿÛCase_Othersİ[Statement]üüüüüüüüüüüüüüüüüüüü
Ü	Case;
Ü	Q : Statement
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Loop}\label{loop}


As with the translation of $Spec\_No\_Ivars$, we have a choice of how to translate the schema inclusion.
This case is a little more complicated, however, but as there is no overlap between the signature of the included schema and other signature variables, we can adopt the following simple translation.

The till clause may not be present in which case the t component will be true. However we make t optional to reflect the concrete syntax so that the SPARK program can be reproduced authentically.

A loop body may be a sequence of statements in which case the treatment of the loop can only be informal with respect to generating verification conditions: hence $'STATEMENT$ rather than $SPEC_NO_IVARS$.
A loop without an iteration scheme can have a name, so we introduce an additional type called NAMED\_LOOP.
=DOC
type 'STATEMENT ÛLOOPİ
=TYPESTRUCT
      = {
	t : ZUserInterfaceSupport.Z_TM OPT,
	stmt : 'STATEMENT
	};
=DESCRIBE
The till part is represented as a parsed (but not type-checked) Z term to enable type inference to happen in the correct environment during VC generation.
ÿÛLoopİüüüüüüüüüüüüüüüüü
Ü	T : Z_PRED;
Ü	Spec_No_Ivars
÷üüüüüü
Ü	T  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
=DOC
type 'STATEMENT ÛNAMED_LOOPİ
=TYPESTRUCT
      = {
	name : ID,
	t : ZUserInterfaceSupport.Z_TM OPT,
	stmt : 'STATEMENT
	};
=DESCRIBE
The till part is represented as a parsed (but not type-checked) Z term to enable type inference to happen in the correct environment during VC generation.
=ENDDOC

\subsubsection{While Loop}\label{while-loop}

Loops can have names, so a name is introduced into the abstract representation.
=DOC
type 'STATEMENT ÛWHILEİ
=TYPESTRUCT
      = {
	name : ID OPT,
	g : COND,
	loop : 'STATEMENT LOOP
	};
=DESCRIBE
ÿÛWhileİüüüüüüüüüüüüüüüüü
Ü	G : COND;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{For Loop (Static Bounds)}\label{for-static}


Loops can have names so a field in the abstract representation is reserved for name. Also we record in the abstract syntax the direction of the loop and the type mark for the purposes of reproducing the SPARK program.

=DOC
type ÛSTATIC_EXPİ
=TYPESTRUCT
	= EXP;
=ENDDOC
¹ZAX
Ü	ÛSTATIC_EXPİ : ğ EXP
°
=DOC
datatype ÛLOOP_DIRECTIONİ =
				ÛLDForwardsİ
			|	ÛLDReverseİ;
=DESCRIBE
¹Z
Ü ÛLOOP_DIRECTIONİ ::= Forwards | Reverse
°
=ENDDOC
A range component is used rather than a lo-hi pair in order to support the possibility of representing a range attribute.
Also the optional loop name and the type mark have to be recorded.
=DOC
type 'STATEMENT ÛFORİ
=TYPESTRUCT
      = {
	name : ID OPT,
	i : ID,
	tmark : ID OPT,
	range : EXP RANGE,
	dir : LOOP_DIRECTION,
	loop : 'STATEMENT LOOP
	};
=DESCRIBE
ÿÛForİüüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	lo, hi : EXP;
Ü	dir : LOOP_DIRECTION;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
=DOC
type 'STATEMENT ÛFOR_STATICİ
=TYPESTRUCT
	= 'STATEMENT FOR;
=DESCRIBE
ÿÛFor_Staticİüüüüüüüüüüüüüüüüü
Ü	For
÷üüüüüüüüüüüüüüü
Ü 	{lo, hi} € STATIC_EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{For Loop (Type Mark as Range)}\label{for-typemark}


FOR\_TMARK is augmented in the same way as for FOR\_STATIC.

=DOC
type 'STATEMENT ÛFOR_TMARKİ
=TYPESTRUCT
      = {
	name : ID OPT,
	i : ID,
	tmark : TMARK,
	dir : LOOP_DIRECTION,
	loop : 'STATEMENT LOOP
	};
=DESCRIBE
ÿÛFor_Tmarkİüüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	tmark : TMARK;
Ü	dir : LOOP_DIRECTION;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Exit Statement (with condition)}\label{exit}


=DOC
type ÛEXIT_WHENİ
=TYPESTRUCT
      = {
	g : COND,
	n : ID OPT
	};
=DESCRIBE
ÿÛExit_Whenİüüüüüüüüüüüüüüüüü
Ü	G : COND;
Ü	N : OPT[ID]
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Exit Statement}\label{exit-stmt}
=DOC
type ÛEXITİ
=TYPESTRUCT
      = {
	n : ID OPT
	};
=DESCRIBE
ÿÛExitİüüüüüüüüüüüüüüüüü
Ü	N : OPT[ID]
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC


\subsubsection{Return}\label{return}


=DOC
type ÛRETURNİ
=TYPESTRUCT
      = {
	e : EXP OPT
	};
=DESCRIBE
ÿÛReturnİüüüüüüüüüüüüüüüüü
Ü	E : OPT[EXP]
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Procedure Call}\label{procedure-call}


The actual part can be a positional parameter association or a named parameter association.

=DOC
datatype ('AGG_CHOICE, 'EXP) ÛACTUALSİ =
			ÛAPositionalİ of EXP list
		|	ÛANamedİ of ('AGG_CHOICE, 'EXP) NAMED_ASSOC list;
=DESCRIBE
=ENDDOC
=DOC
type ('AGG_CHOICE,'EXP) ÛPROC_CALLİ
=TYPESTRUCT
      = {
	name : ID,
	actuals : ('AGG_CHOICE,'EXP) ACTUALS
	};
=DESCRIBE
ÿÛProc_Callİüüüüüüüüüüüüüüüüü
Ü	name : ID;
Ü	actuals : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC



=DOC
type ('AGG_CHOICE,'EXP) ÛPROC_CALL_NO_IVARSİ
=TYPESTRUCT
	= ('AGG_CHOICE,'EXP) PROC_CALL;
=DESCRIBE
¹ZAX
Ü	Ûretrieve_spec_stmtİ : ID ß Spec
°
ÿÛProc_Call_No_Ivarsİüüüüüüüüüüüüüüüüü
Ü	Proc_Call
÷üüüüüüüüüüüüüüüü
Ü	(retrieve_spec_stmt name).post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC



\subsubsection{Specification (with initial variables)}\label{specification-ivars}

A specification statement may be labelled.
=DOC
type ÛSPEC_IVARSİ 
=TYPESTRUCT
      = {
	spec :SPEC,
	label : LABEL
	};
=DESCRIBE
ÿÛSpec_Ivarsİüüüüüüüüüüüü
Ü	Spec
÷üüüüüüüüüüüüüüü
Ü	post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{For Loop (Non-Static Bounds)}\label{for-non-static-bounds}


A loop may have an optional name. 

A range component is used rather than a lo-hi pair in order to support the possibility of representing a range attribute.
=DOC
type 'STATEMENT ÛFOR_NON_STATICİ
=TYPESTRUCT
      = 'STATEMENT FOR;
=DESCRIBE
ÿÛFor_Non_Staticİüüüüüüüüüüüüüüüüü
Ü	For
÷üüüüüüüüüüüüüüüü
Ü	³{lo, hi} € STATIC_EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Logical Constants}\label{logical-constants}


The function $free\_id$ may readily and realistically be implemented using existing \Product\
syntax functions.
In a {\it LOG\_CON\_DEF}, 
$t$ represents the set of which $x$ is a member and
is represented as a parsed Z term. Type inference occurs during VC generation when the appropriate $Z\_EXP$ is generated.
The values for $e$ and $pre1$ are filled in at this time (replacing dummy values planted by
the parser).
Logical constants also have a label.
=DOC
type ÛLOG_CON_DEFİ
=TYPESTRUCT
      = {
	x : Z_ID,
	t : ZUserInterfaceSupport.Z_TM,
	e : Z_EXP
	};
=DESCRIBE
¹ZAX
Ü	Ûfree_idsİ : Z_EXP ­ ğ Z_ID
°
ÿ ÛLog_Con_Defİ üüüüüüüüüüü
Ü	X : Z_ID;
Ü	T : Z_EXP;
Ü	E : Z_EXP
ˆüüüüüüüüüüüüüü
=ENDDOC
=DOC
type ÛLOG_CONİ
=TYPESTRUCT
      = {
	defs : LOG_CON_DEF list,
	spec : SPEC,
	pre1 : Z_EXP,
	label : LABEL
	};
=DESCRIBE
ÿÛLog_Conİüüüüüüüüüüüü
Ü	defs : seq‰1 Log_Con_Def;
Ü	Spec;
Ü	pre‰1 : Z_PRED
÷üüüüüüüüüüüüüüü
Üµi, n : dom defs· i ¼ n ´ (defs n).X  free_ids((defs i).E);
ÜPre = z_and(z_many_and {d: ran defs·z_eq(zid(d.X), d.E)}, pre‰1)
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
\subsubsection{Procedure Calls (initial variables in spec)}\label{procedure-calls}


=DOC
type ('AGG_CHOICE,'EXP) ÛPROC_CALL_IVARSİ
=TYPESTRUCT
	= ('AGG_CHOICE,'EXP) PROC_CALL;
=DESCRIBE
ÿÛProc_Call_Ivarsİüüüüüüüüüüüü
Ü	Proc_Call
÷üüüüüüüüüüüüüüü
Ü	(retrieve_spec_stmt name).post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

\subsubsection{Statement}\label{statement}

\ProductZ\ is currently non-standard in that it neither requires nor
allows the chevrons around the operands in a free type definition.
This mismatch with the Z standard is planned to be remedied in a future release of the system.


¹Z
	ÛStatementİ
		::= 	null
		|	assign Assign
		|	spec_no_ivars Spec_No_Ivars
		|	semicolon (Statement ¸ Statement)
		|	if_then_else (If_Then_Else[Statement])
		|	case (Case[Statement])
		|	case_others (Case_Others[Statement])
		|	loop Loop
		|	while While
		|	for_static For_Static
		|	for_tmark For_Tmark
		|	exit_when Exit_When
		|	exit Exit
		|	ret Return
		|	proc_no_ivars Proc_Call_No_Ivars
		|	spec_ivars Spec_Ivars
		|	for_non_static For_Non_Static
		|	log_con Log_Con
		|	proc_ivars Proc_Call_Ivars
°

To support the full syntax for block statements, the ML datatype for statements is declared
later on in mutual recursion with the syntax for declarations.

\subsection{Subprogram Declarations}
The abstract syntax in this section and in the rest of the document is constructed from an abstraction of the concrete syntax of SPARK. It is not specified formally in \cite{DRA/CIS/CSE3/TR/94/27/3.0}, hence there is no transcribed Z specification here.

An Ada formal parameter mode is represented by the following data type, in which
the boolean flag for an {\tt in} mode parameter indicates whether or not the
parameter mode was supplied explicitly ({\tt true}) or just omitted ({\tt false})
in the Ada source.
=DOC
datatype ÛMODEİ =	MSparkIn of bool
		|	MSparkOut
		|	MSparkInOut;
=DESCRIBE
=ENDDOC
=DOC
type ÛPARAMETER_SPECIFICATIONİ
=TYPESTRUCT
      = {
	idlist : ID list,
	mode : MODE,
	name : TMARK,
	default : EXP OPT
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛPROCEDURE_SPECIFICATIONİ
=TYPESTRUCT
      = {
	name : ID,
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT,
	annotation : ANNOTATION,
	globals : Z_ID list
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛFUNCTION_SPECIFICATIONİ
=TYPESTRUCT
      = {
	designator : ID,
	return : TMARK,
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT,
	annotation : ANNOTATION,
	globals : Z_ID list
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛSUBPROGRAM_SPECIFICATIONİ =
			ÛSSProcedureİ of PROCEDURE_SPECIFICATION
		|	ÛSSFunctionİ of FUNCTION_SPECIFICATION;
=DESCRIBE
=ENDDOC
=DOC
type ÛPROCEDURE_DECLARATIONİ
=TYPESTRUCT
	= PROCEDURE_SPECIFICATION;
=DESCRIBE
=ENDDOC
=DOC
type ÛFUNCTION_DECLARATIONİ
=TYPESTRUCT
	= FUNCTION_SPECIFICATION;
=DESCRIBE
=ENDDOC
=DOC
type ÛSUBPROGRAM_DECLARATIONİ
=TYPESTRUCT
	= SUBPROGRAM_SPECIFICATION;
=DESCRIBE
=ENDDOC
\subsection{Procedure and Function Calls}
=DOC
type ÛNAMED_PARAMİ
=TYPESTRUCT
      = {
	formal : ID,
	actual : EXP
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛNAMED_PARAMETER_ASSOCİ
=TYPESTRUCT
      = {
	params: NAMED_PARAM list
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛPOS_PARAMETER_ASSOCİ
=TYPESTRUCT
      = {
	params : EXP list
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛACTUAL_PARAMETER_PARTİ = 
			ÛAPPNamedİ of NAMED_PARAMETER_ASSOC
		|	ÛAPPPositionalİ of POS_PARAMETER_ASSOC;
=DESCRIBE
=ENDDOC
\subsection{Package Declaration}
=DOC
type ÛOBJECT_RENAMINGİ
=TYPESTRUCT
	= {
		new_name : ID,
		tmark : TMARK,
		old_name : ID
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛPACKAGE_RENAMINGİ
=TYPESTRUCT
	= {
		new_name : ID,
		old_name : ID
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛOPERATOR_SYMBOLİ
=TYPESTRUCT
	= string;
=DESCRIBE
=ENDDOC
=DOC
type ÛOPSYM_RENAMINGİ
=TYPESTRUCT
      = {
	new_name : ID OPT,
	formal_part : PARAMETER_SPECIFICATION list,
	tmark : TMARK,
	name1 : ID OPT,
	name2 : OPERATOR_SYMBOL
	};
=DESCRIBE
This is the case where the original name is an operator symbol, in which case
the Compliance Notation requires the new name to be the same operator
symbol or an ordinary function name. In the former case, we leave out the new
name in the abstract syntax.
{\it name1} is the package name part of the original operator symbol name, if any.
=ENDDOC
=DOC
type ÛSUBPROGRAM_RENAMINGİ
=TYPESTRUCT
      = {
	subprogram_specification : SUBPROGRAM_SPECIFICATION,
	name1 : ID OPT,
	name2 : ID
	};
=DESCRIBE
This includes the case where {\it name2} is an operator symbol
but not the case where {\it name1} is.
=ENDDOC
=DOC
datatype ÛRENAMING_DECLARATIONİ =
			ÛRDObjectİ of OBJECT_RENAMING
		|	ÛRDPackageİ of PACKAGE_RENAMING
		|	ÛRDOpsymİ of OPSYM_RENAMING
		|	ÛRDSubprogramİ of SUBPROGRAM_RENAMING;
=DESCRIBE
=ENDDOC
=DOC
type ÛLENGTH_CLAUSEİ
=TYPESTRUCT
      = {
	attribute : EXP,
	exp : EXP
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛENUMERATION_REPRESENTATION_CLAUSEİ
=TYPESTRUCT
      = {
	name : ID,
	exp : EXP
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛCOMPONENT_CLAUSEİ
=TYPESTRUCT
      = {
	name : ID,
	exp : EXP,
	range : EXP RANGE
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛRECORD_REPRESENTATION_CLAUSEİ
=TYPESTRUCT
      = {
	name : ID,
	alignment_opt : EXP OPT,
	component_pack : COMPONENT_CLAUSE list
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛADDRESS_CLAUSEİ
=TYPESTRUCT
      = {
	name : ID,
	exp : EXP
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛREPRESENTATION_CLAUSEİ =
		ÛRCLengthİ of LENGTH_CLAUSE
	|	ÛRCEnumerationİ of ENUMERATION_REPRESENTATION_CLAUSE
	|	ÛRCRecordİ of RECORD_REPRESENTATION_CLAUSE
	|	ÛRCAddressİ of ADDRESS_CLAUSE;
=DESCRIBE
=ENDDOC
=DOC
datatype ÛUSE_CLAUSEİ =
		ÛUCUseİ of ID list
	|	ÛUCUseTypeİ of ID list;
=DESCRIBE
=ENDDOC

The types for function, procedure and package bodies are declared later with the mutually recursive
datatype definitions for statements and declarations.


=DOC
type 'DECLARATION ÛPACKAGE_DECLARATIONİ
=TYPESTRUCT
      = {
	name : ID,
	end_name : ID OPT,
	visible_decs : 'DECLARATION list,
	private_decs : 'DECLARATION list,
	annotation : ANNOTATION
	};

=DESCRIBE
=ENDDOC
Auxiliary expressions are resolved by the presence of a using declaration. This is specified in \cite[volume 1]{DRA/CIS/CSE3/TR/94/27/3.0}. It is necessary to extend the abstract syntax to include ``using'' declarations.

Note that the component $basic\_decls$ is added in case we need to reproduce the user's input. The component $concrete\_vars$ is a subset of the basic declarations which are variables. 

$t$ represents the set of which $aux$ is a member.

=DOC
type ÛAUX_VARİ
=TYPESTRUCT
      = {
	aux : Z_ID,
	t : ZUserInterfaceSupport.Z_TM
	};
=DESCRIBE
ÿÛAUX_VARİüüüüüüüüüüüüüüüüü
Ü	aux : Z_Decl[Z_EXP]
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC

=DOC
type ÛUSING_DECİ
=TYPESTRUCT
      = {
	aux : ZUserInterfaceSupport.Z_TM,
	concrete_vars : VAR_DECL list,
	basic_decls : BASIC_DECL list,
	invariant : ZUserInterfaceSupport.Z_TM
	};
=DESCRIBE
ÿÛUSING_DECİüüüüüüüüüüüüüüüüü
Ü	aux : Z_ID;
Ü	concrete_vars : ğ Var_Decl;
Ü	invariant : Z_PRED
ˆüüüüüüüüüüüüüüüüüüüüü
=ENDDOC
=DOC
type ÛSI_USING_DECİ
=TYPESTRUCT
      = {
	aux : ZUserInterfaceSupport.Z_TM,
	basic_decls : SI_BASIC_DECL list,
	invariant : ZUserInterfaceSupport.Z_TM
	};
=DESCRIBE
This is the form delivered by the parser. The Z Generator separates out
the variable declarations as required by the specification.
=ENDDOC


=DOC
datatype ÛDEC_K_SLOT_TYPEİ =
			ÛDKPrivateİ
		|	ÛDKVisibleİ
		|	ÛDKDeclarationİ;
=DESCRIBE
This datatype is used in the datatype $DECLARATION$s to destinguish between the three types of k-slot which can occur as a declaration.
=ENDDOC
=DOC
datatype ÛST_NULL_TYPEİ =
			ÛSNNullİ
		|	ÛSNImplicitİ
		|	ÛSNNothingİ;
=DESCRIBE
This datatype is used to distinguish between the three different concrete forms that can result in
a null statement in the abstract syntax:  an  explicit null statement, an implicit null statement
arising from a form such as an if statement with no else part, and an explicit nothing statement.
=ENDDOC

=DOC
datatype ÛDECLARATIONİ =
		ÛDDeclarationKSlotİ of (K_SLOT * DEC_K_SLOT_TYPE)
	|	ÛDRenamingDeclarationİ of RENAMING_DECLARATION
	|	ÛDBasicDeclİ of SI_BASIC_DECL
	|	ÛDRepresentationClauseİ of REPRESENTATION_CLAUSE
	|	ÛDUseClauseİ of USE_CLAUSE
	|	ÛDProperBodyİ of PROPER_BODY
	|	ÛDProcedureDeclarationİ of PROCEDURE_DECLARATION
	|	ÛDFunctionDeclarationİ of FUNCTION_DECLARATION
	|	ÛDPackageDeclarationİ of DECLARATION PACKAGE_DECLARATION
	|	ÛDProcedureStubİ of PROCEDURE_DECLARATION
	|	ÛDFunctionStubİ of FUNCTION_DECLARATION
	|	ÛDPackageStubİ of ID
	|	ÛDExternalProcedureStubİ of PROCEDURE_DECLARATION
	|	ÛDExternalFunctionStubİ of FUNCTION_DECLARATION
	|	ÛDAuxiliaryİ of AUX_VAR
	|	ÛDUsingİ of SI_USING_DEC
=DESCRIBE
=ENDDOC
=DOC
and ÛPROPER_BODYİ =	ÛPBProcedureİ of PROCEDURE_BODY
		|	ÛPBFunctionİ of FUNCTION_BODY
		|	ÛPBPackageİ of PACKAGE_BODY
=DESCRIBE
=ENDDOC

The datatype for statements is now given in mutual recursion with the above.

Note that $STImplicitNull$ has been introduced because there are cases where a null statement is required in the syntax (e.g., in $SSpecIvars$ of \ref{statement}) which might not have been present in the input. Therefore such a statement is recorded in the abstract syntax as an implicit null statement, denoting that it should not appear subsequently in the SPARK program. 

\pagebreak
=DOC
and ÛSTATEMENTİ =
		 	ÛSTNullİ of ST_NULL_TYPE
		|	ÛSTAssignİ of ASSIGN
		|	ÛSTSpecNoIvarsİ of SPEC_NO_IVARS
		|	ÛSTSemicolonİ of (STATEMENT * STATEMENT)
		|	ÛSTIfThenElseİ of  STATEMENT IF_THEN_ELSE
		|	ÛSTCaseİ of STATEMENT CASE
		|	ÛSTLoopİ of STATEMENT LOOP
		|	ÛSTNamedLoopİ of STATEMENT NAMED_LOOP
		|	ÛSTWhileİ of STATEMENT WHILE
		|	ÛSTForStaticİ of STATEMENT FOR_STATIC
		|	ÛSTForTmarkİ of STATEMENT FOR_TMARK
		|	ÛSTExitWhenİ of EXIT_WHEN
		|	ÛSTExitİ of EXIT
		|	ÛSTRetİ of RETURN
		|	ÛSTProcNoIvarsİ of (AGG_CHOICE,EXP) PROC_CALL_NO_IVARS
		|	ÛSTKSlotİ of K_SLOT
		|	ÛSTPragmaİ of (AGG_CHOICE, EXP) PRAGMA
		|	ÛSTAnnotationİ of ANNOTATION
		|	ÛSSpecIvarsİ of SPEC_IVARS
		|	ÛSForNonStaticİ of STATEMENT FOR_NON_STATIC
		|	ÛSLogConİ of LOG_CON
		|	ÛSProcIvarsİ of
				(AGG_CHOICE,EXP) PROC_CALL_IVARS
		|	ÛSBlockStatementİ of BLOCK_STATEMENT
=DESCRIBE
In the ML, there is just one category for case statements, which covers
both of the Z categories.
=ENDDOC
=DOC
withtype ÛBLOCK_STATEMENTİ
	= {
		name : ID OPT,
		declarative_part : DECLARATION list OPT,
		statement : STATEMENT
	}
=DESCRIBE
=ENDDOC
=DOC
and ÛPROCEDURE_BODYİ
      = {
	procedure_spec : PROCEDURE_SPECIFICATION,
	declarative_part : DECLARATION list,
	statement : STATEMENT,
	end_name : ID OPT
	}
=DESCRIBE
=ENDDOC
=DOC
and ÛFUNCTION_BODYİ
      = {
	function_spec : FUNCTION_SPECIFICATION,
	declarative_part : DECLARATION list,
	statement : STATEMENT,
	end_name : ID OPT
	}
=DESCRIBE
=ENDDOC
=DOC
and ÛPACKAGE_BODYİ
      = {
	name : ID,
	decls : DECLARATION list,
	statement : STATEMENT,
	annotation : ANNOTATION,
	end_name : ID OPT
	};
=DESCRIBE
=ENDDOC

=DOC
type ÛCOMP_SUBUNITİ
=TYPESTRUCT
      = {
	name : ID,
	proper_body : PROPER_BODY
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛCOMPILATION_UNITİ =
		ÛCUPackageDeclarationİ of DECLARATION PACKAGE_DECLARATION
	|	ÛCUProperBodyİ of PROPER_BODY
	|	ÛCUSubUnitİ of COMP_SUBUNIT;

=DESCRIBE
=ENDDOC
=DOC
type ÛREFINED_BYİ
=TYPESTRUCT
      = {
	label : LABEL,
	statement : STATEMENT
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛREPLACED_BYİ
=TYPESTRUCT
      = {
	label : LABEL,
	statement : STATEMENT
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛREPLACED_BY_DECLİ
=TYPESTRUCT
      = {
	label : LABEL,
	decls : DECLARATION list
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛREPLACED_BY_VISIBLE_PARTİ
=TYPESTRUCT
      = {
	label : LABEL,
	visible : DECLARATION list
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛREPLACED_BY_PRIVATE_PARTİ
=TYPESTRUCT
      = {
	label : LABEL,
	private : DECLARATION list
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛCONTEXT_ITEMİ =
		ÛCIWithİ of ID list
	|	ÛCIUseİ of USE_CLAUSE
	|	ÛCIPragmaİ of (AGG_CHOICE, EXP) PRAGMA;
=DESCRIBE
=ENDDOC
=DOC
type ÛCONTEXT_COMPILATION_UNITİ
=TYPESTRUCT
      = {
	context : CONTEXT_ITEM list,
	references : ID list,
	comp_unit : COMPILATION_UNIT,
	annotation : ANNOTATION
	};
=DESCRIBE
The pragmas are kept together with the context
clauses they followed so that the SPARK program can be
assembled in the proper order.
=ENDDOC
=DOC
datatype ÛKSLOT_COMPILATION_UNITİ =
			ÛKCUKSlotİ of K_SLOT
		|	ÛKCUUnitİ of CONTEXT_COMPILATION_UNIT
		|	ÛKCUPragmaİ of (AGG_CHOICE, EXP) PRAGMA;
=DESCRIBE
=ENDDOC
=DOC
type ÛREPLACED_BY_COMPİ
=TYPESTRUCT
      = {
	label : LABEL,
	comp : KSLOT_COMPILATION_UNIT list
	};
=ENDDOC
=DOC
type ÛREPLACED_BY_ARBITRARY_ADAİ
=TYPESTRUCT
      = {
	label : LABEL,
	replacement : string
	};
=DESCRIBE
This is the type for an arbitrary Ada replacement, which for the compliance tool,  is just textual data to be passed into the output SPARK program.
=ENDDOC
=DOC
type ÛREPLACED_BY_ANNOTATIONİ
=TYPESTRUCT
      = {
	label : LABEL,
	replacement : ANNOTATION
	};
=DESCRIBE
This is the type for an annotation replacement.
It is used in the syntactic positions where an annotation is not just treated as an option for some other sort of construct (e.g., a declaration).
=ENDDOC
=DOC
datatype ÛWEB_CLAUSEİ = 
			ÛWCCompilationİ of KSLOT_COMPILATION_UNIT list
		|	ÛWCReplacedByCompilationİ of REPLACED_BY_COMP
		|	ÛWCReplacedByPrivatePartİ of REPLACED_BY_PRIVATE_PART
		|	ÛWCReplacedByVisiblePartİ of REPLACED_BY_VISIBLE_PART
		|	ÛWCReplacedByDeclİ of REPLACED_BY_DECL
		|	ÛWCReplacedByArbitraryAdaİ of 
						REPLACED_BY_ARBITRARY_ADA
		|	ÛWCReplacedByAnnotationİ of 
						REPLACED_BY_ANNOTATION
		|	ÛWCRefinedByİ of REFINED_BY
		|	ÛWCReplacedByİ of REPLACED_BY;
=DESCRIBE
=ENDDOC
=TEX
\section{CUSTOMIZED ENVIRONMENT HANDLING}

The {\em IN\_SCOPE} data type that features in the various environments in the specification is represented using a data refinement
Instead of having separate tables for different kinds of entity (variables, parameters etc.), there is a single table which maps identifiers to a data type representing the different types of entity and including both the information defined in the specification and any additional information needed by the implementation.
This approach also gives a convenient and uniform way of storing useful information about names in general.
This section defines the types that make up this representation.


The types in this section are not part of the syntax {\it per se}. However,
they are needed in the implementation of \cite[Volume 3]{DRA/CIS/CSE3/TR/94/27/3.0}
and it is a convenience in building the system to define them here rather
than in \cite{ISS/HAT/DAZ/DTD508}.

=DOC
type ÛPAR_INFOİ
=TYPESTRUCT
	= {
		id : ID,
		tmark : TMARK,
		default : Z_EXP OPT};
=SML
type ÛFUNCTION_INFOİ
=TYPESTRUCT
	= {
		formal : bool,
		deps : Z_ID list,
		pars : PAR_INFO list,
		return_tmark : TMARK};
=DESCRIBE
The information for functioins is what is needed {\em(a)} to translate a call of the function into Z, {\em(b)} to set up a type inference context appropriate for the body of the function and {\em(c)} to process renaming declarations for the function.
The information for a function includes a flag indicating whether this is a formal function the list of global dependencies, the list of formal
parameter names and corresponding type marks and defaults and the type mark for the return value of the
function.
=ENDDOC

=DOC

=SML
type ÛPARAM_SPECİ
=TYPESTRUCT
      = {
	var_decl : VAR_DECL,
	mode : MODE
	};
=SML
type ÛFORMAL_PROCİ
=TYPESTRUCT
      = {
	name : ID,
	formal_ids : PARAM_SPEC list,
	par_names_defs : (ID * Z_EXP OPT) list,
	globals : Z_ID list,
	spec : SPEC
	};
=SML
type ÛPROCEDURE_INFOİ
=TYPESTRUCT
	= {
		formal : bool,
		formal_proc : FORMAL_PROC};
=DESCRIBE
The type {\em FORMAL\_PROC} is defined here rather than in \cite{ISS/HAT/DAZ/DTD514}.

For a procedure, we have a flag indicating whether this is a formal procedure or not and
the {\em FORMAL\_PROC} of the procedure (or a dummy if this is not a formal procedure).
=ENDDOC
=DOC
datatype ÛVAR_KINDİ = Var | Par of MODE | OutOfScope
type ÛVAR_INFOİ
=TYPESTRUCT
	= {
		kind : VAR_KIND,
		tmark : TMARK};
=DESCRIBE
For a variable or formal parameter we have the type mark plus a marker distinguishing between variables proper, parameters (for which we also have the mode), and variables which are in scope in the Ada sense but not in scope in the Compliance Notation sense.
This is intended to allow improved error messages (the user can be told that the variable is not in scope as far as the Compliance Notation is concerned because it hasn't been cited in a frame or a global dependency list).
=ENDDOC
=DOC
type ÛAUX_VAR_INFOİ
=TYPESTRUCT
	= {
		in_scope : bool,
		decl : Z_EXP};
=SML
type ÛLOG_CON_INFOİ
=TYPESTRUCT
	= AUX_VAR_INFO;
=DESCRIBE
For an auxiliary variable or a logical constant we have the theZ declaration plus a flag indicating whether this variable is in scope in fhe Compliance Notation sense (just as for program variables, see above).
=ENDDOC
=DOC
type RECORD_TYPE_INFO
=TYPESTRUCT
	= {
		comp_names :  ID list,
		num_discs : int};
=DESCRIBE
For a record type we have the component names in their Ada order and the number of components that are discriminants of the type.
=ENDDOC
=DOC
type ÛCONSTANT_INFOİ
=TYPESTRUCT
	= {tmark : TMARK};
=DESCRIBE
For a constant we just need the Ada type mark.
=ENDDOC
=DOC
datatype ÛENTITY_INFOİ =
			ÛEIEnvFunctionİ of FUNCTION_INFO
		|	ÛEIEnvProcedureİ of PROCEDURE_INFO
		|	ÛEIEnvVarİ of VAR_INFO
		|	ÛEIEnvAuxVarİ of AUX_VAR_INFO
		|	ÛEIEnvLogConİ of LOG_CON_INFO
		|	ÛEIEnvRecordTypeİ of RECORD_TYPE_INFO
		|	ÛEIEnvOtherTypeİ
		|	ÛEIEnvConstantİ of CONSTANT_INFO
		|	ÛEIEnvOtherVarİ
		|	ÛEIEnvOtherİ;
type ENV_INFO
=TYPESTRUCT
	 = {
	tipe : TYPE OPT,
	canon_name : Z_ID,
	info : ENTITY_INFO};
=DESCRIBE
The data type collects together the different types of information held in the implementation of an {\em IN\_SCOPE}.
The ``other type'' alternative is for names corresponding to Ada types that are not record types.
The ``other variable'' alternative is for Z local variables set up in the type inference context (this is for testing).
The ``other'' allternative is for Z global variables that do not represent Ada entities, e.g., user-defined schemas.

Putting this all together, we get the new {\em ENV\_INFO} record type giving the information associated with a name, namely its HOL type (or a dummy type for a procedure), its canonical name (as happens as a result of renamings, use clauses and nested packages) and the entity info as above.
This will be what is stored in the dictionaries and returned by the {\em CN\_ENV} function.
=ENDDOC
=DOC
type ÛCN_ENVİ
=TYPESTRUCT
	= Z_ID ->  ENV_INFO OPT;
=DESCRIBE
$CN\_ENV$ is the type of a function which maps an identifier onto its type and yields contextual information about the identifier.
Such functions returns $Nil$ if the identifier is not in scope at the point at which the function is called.

=USES
A function of type $CN\_ENV$ is passed recursively into the generator for basic declarations and expressions so that the contextual information about an identifier is available at the point it is needed.
=ENDDOC


\section{EPILOGUE}
=SML
end (* of signature CNTypes *);
=TEX

\section{TEST POLICY}
There are no module tests for the design in this document since it specifies no functions.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



