%  dtd502.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Compliance Notation Lexis and Abstract Syntax}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD502}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.D.~Arthan&HAT Team}
\TPPabstract{
This document contains the detailed design for the lexis and abstract syntax for Compliance Notation}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion] Initial Draft.

\end{description}
\subsection{Changes Forecast}
This document is a prototype and is under development. 
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the abstract syntax for Compliance Notation.

\subsection{Introduction}
\subsubsection{Purpose and Background}
\subsubsection{Dependencies}
\subsubsection{Deficiencies}
None known.

\section{LEXIS}
=DOC
signature ÛCNTypesİ = sig
local
	open ZUserInterfaceSupport;
in
=DESCRIBE
This is the signature for the structure containing the types required for Compliance Notation.
=DESCRIBE
=ENDDOC

=DOC
datatype ÛCN_LEX_CLASSİ
			= ÛLCAbstractExpressionİ
			| ÛLCAbsİ | ÛLCAmpersandİ | ÛLCAndİ | ÛLCArrayİ |ÛLCAtİ
			| ÛLCBarİ |ÛLCBBodyİ | ÛLCBecomesİ | ÛLCBeginİ
			| ÛLCCaseİ| ÛLCCharacterLiteralİ
			| ÛLCColonİ | ÛLCCommaİ | ÛLCCompLabelİ | ÛLCConstantİ
			| ÛLCConİ | ÛLCCrdİ | ÛLCDecLabelİ | ÛLCDeltaİ
			| ÛLCDigitsİ | ÛLCDivİ| ÛLCDotDotİ | ÛLCDotİ | ÛLCElseİ
			| ÛLCElsIfİ | ÛLCEndİ | ÛLCEqualsİ | ÛLCExitİ
			| ÛLCFatDotİ | ÛLCForİ | ÛLCFunctionNameİ | ÛLCFunctionİ
			| ÛLCGoesToİ | ÛLCGreaterEqualsİ
			| ÛLCGreaterThanİ | ÛLCIdentifierİ | ÛLCIfİ
			| ÛLCInİ | ÛLCIsİ
			| ÛLCKSlotİ | ÛLCLessEqualsİ | ÛLCLessGreatİ | ÛLCLessThanİ
			| ÛLCLimitedİ | ÛLCLoopİ | ÛLCMinusİ
			| ÛLCModİ | ÛLCNotEqualsİ | ÛLCNotİ | ÛLCNullİ
			| ÛLCNumericLiteralİ | ÛLCOfİ
			| ÛLCOrdİ | ÛLCOrİ | ÛLCOthersİ | ÛLCOutİ
			| ÛLCPackageİ | ÛLCPlusİ
			| ÛLCPPartLabelİ | ÛLCPrimeİ | ÛLCPrimedIdentifierİ
			| ÛLCPrivateİ | ÛLCProcedureNameİ | ÛLCProcedureİ
			| ÛLCRecordİ | ÛLCRefinedByİ | ÛLCRemİ
			| ÛLCRenamesİ | ÛLCReplacedByİ | ÛLCReturnİ
			| ÛLCReverseİ | ÛLCRRangeİ | ÛLCSemiİ
			| ÛLCSeparateİ | ÛLCSpecLabelİ | ÛLCStarStarİ
			| ÛLCStarİ | ÛLCStmtLabelİ
			| ÛLCStringLiteralİ | ÛLCSubTypeİ | ÛLCThenİ
			| ÛLCTillİ | ÛLCTypeMarkİ
			| ÛLCTypeİ | ÛLCUseİ | ÛLCVPartLabelİ
			| ÛLCWhenİ | ÛLCWhileİ | ÛLCWithİ | ÛLCXorİ | ÛLCEosİ
			| ÛLCZİ
			| ÛLCGrkDeltaİ | ÛLCLSqBrackİ | ÛLCRSqBrackİ
			| ÛLCLBraceİ | ÛLCRBraceİ | ÛLCLStracheyİ
			| ÛLCRStracheyİ | ÛLCLChevronİ | ÛLCRChevronİ;
=DESCRIBE
CN\_LEX\_CLASS is the datatype used to represent the lexical classes of tokens in compliance notation. 
=DESCRIBE
=ENDDOC

=DOC
datatype ÛCN_TOKENİ	=	ÛCNZİ of ZLex.Z_TOKEN list
			|	ÛCNTextİ of string
			|	ÛCNStringİ of string
			|	ÛCNKSlotİ of Lex.INPUT list
			|	ÛCNEosİ;

type ÛCN_LEX_ITEMİ
=TYPESTRUCT
	= CN_LEX_CLASS * CN_TOKEN;
=DESCRIBE
CN\_TOKEN is the datatype used to represent the lexical tokens required in compliance notation. CN\_LEX\_ITEM is a type used by the lexical analyser for communicating to the parser the lexical information. The class (the first of the pair) is the classification of the token (the second of the pair).
=DESCRIBE
=ENDDOC
\newpage
\section{Z ABSTRACT SYNTAX}


\subsection{Z Declarations}

¹Z
[Z_ID, Z_EXP]
°

=DOC
type ÛZ_IDİ
=TYPESTRUCT
	= string;
=DESCRIBE
=ENDDOC

=DOC
type ÛZ_EXPİ
=TYPESTRUCT
	= TERM;
=DESCRIBE
This is a partially parsed Z expression which is mapped into HOL during the $trans\_exp$.
=SEEALSO
$trans\_exp$
=ENDDOC

=DOC
type ÛZ_DECLİ
=TYPESTRUCT
      = TERM;
=DESCRIBE
=ENDDOC
¹Z
Ü	[Z_PRED]
°

=DOC
type ÛZ_PREDİ
=TYPESTRUCT
	= TERM;
=DESCRIBE
=ENDDOC


\newpage
\section{SPARK ABSTRACT SYNTAX}

\subsection{Preamble for Z Type-Checking}
The following initialises the theory database when performing a syntax and type check on the Z paragraphs in this document. (This preamble is not processed when building the compliance tool.)

=SMLZ
open_theory"z_library";
push_pc "z_library";
force_delete_theory"dtd502" handle Fail _ => ();
val _ = set_flag ("z_type_check_only", true);
new_theory"dtd502";
=TEX

\subsection{Basic Declarations}
The Z specification of the abstract syntax uses a given set declaration to act as a forward declaration of the free type $EXP$, permitting the free type to involve recursion through schema constructions.
Unfortunately, this style is not considered to be type correct in \ProductZ; this is readily circumvented by making the schema constructions generic where necessary.

\subsubsection{Identifiers}

ID is the set of Ada Identifiers.

¹Z
Ü	[ID]
°

=DOC
type ÛIDİ
=TYPESTRUCT
	= string;
=DESCRIBE
=ENDDOC

\subsubsection{Enumerated Types}
Enum\_Type\_Def models enumerated types.

ÿEnum_Type_Defüüüüüüüüüüüü
Ü	vals : seq ID
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type ÛENUM_TYPE_DEFİ
=TYPESTRUCT
      = {
	vals : ID list
	};
=DESCRIBE
=ENDDOC
\subsubsection{Type Marks}
TMARK is the set of type marks in the literate script.

¹ZAX
Ü	TMARK : ğ ID
°

=DOC
type ÛTMARKİ
=TYPESTRUCT
	= ID;
=DESCRIBE
=ENDDOC
\subsubsection{Array Types}
Array\_Def models array types.

ÿArray_Defüüüüüüüüüüüü
Ü	index, comp : TMARK
ˆüüüüüüüüüüüüüüüüüüüüü

The index can be a list of type marks, so this is modelled below.
=DOC
type ÛARRAY_DEFİ
=TYPESTRUCT
      = {
	index : TMARK list,
	comp : TMARK
	};
=DESCRIBE
=ENDDOC
\subsubsection{Variable Declarations}
Var\_Decl is an Ada variable declaration.

ÿVar_Declüüüüüüüüüüüü
Ü	var : ID;
Ü	tmark : TMARK
ˆüüüüüüüüüüüüüüüüüüüüü

In order to maintain the reproducability of the input, it is necessary to include all the identifiers together in a VAR\_DECL.
=DOC
type ÛVAR_DECLİ
=TYPESTRUCT
      = {
	vars : ID list,
	tmark : TMARK
	};
=DESCRIBE
=ENDDOC
\subsubsection{Variants}
Variants are new.
=DOC
type 'COMPONENT ÛVARIANTİ
=TYPESTRUCT
      = {
	ids : ID list,
	comp : 'COMPONENT list
	};
=DESCRIBE
=ENDDOC
=DOC
type 'COMPONENT ÛVARIANT_PARTİ
=TYPESTRUCT
      = {
	id : ID,
	variants : 'COMPONENT VARIANT list
	};
=DESCRIBE
=ENDDOC
=DOC
type 'COMPONENT ÛDECLARATION_VARIANTİ
=TYPESTRUCT
      = {
	decls : VAR_DECL list,
	variant : 'COMPONENT VARIANT_PART
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛCOMPONENTİ =
			ÛCDeclarationİ of VAR_DECL list
		|	ÛCVariantPartİ of COMPONENT VARIANT_PART
		|	ÛCDeclarationVariantİ of COMPONENT DECLARATION_VARIANT
		|	ÛCNoneİ;
=DESCRIBE
=ENDDOC

\subsubsection{Record Types}
Record\_Type\_Def models record types.

ÿRecord_Type_Defüüüüüüüüüüüü
Ü	decl : seq Var_Decl
ˆüüüüüüüüüüüüüüüüüüüüü

Record types can have variant records, so we use a different definition.
=DOC
type 'COMPONENT ÛRECORD_TYPE_DEFİ
=TYPESTRUCT
      = {
	comps : 'COMPONENT list
	};
=DESCRIBE
=ENDDOC

\subsubsection{Integer Types}

An integer type is characterised by its range.

ÿRange[EXP]üüüüüüüüüüüü
Ü	lo, hi : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

A range can be just a range attribute which can be represented by one expression. To support this, we introduce a type constructor for a range attribute. 
=DOC
type 'EXP ÛRANGELOHIİ
=TYPESTRUCT
      = {
	lo : 'EXP,
	hi : 'EXP
	};
=DESCRIBE
=ENDDOC
=DOC
datatype 'EXP ÛRANGEİ =
			ÛRRangeİ of 'EXP RANGELOHI
		|	ÛRRangeAttrİ of 'EXP
=DESCRIBE
=ENDDOC

\subsubsection{Real Types}
=DOC
type 'EXP ÛFLOATING_POINT_CONSTRAINTİ
=TYPESTRUCT
      = {
	exp : 'EXP,
	range : 'EXP RANGE OPT
	};
=DESCRIBE
=ENDDOC
=DOC
type 'EXP ÛFIXED_POINT_CONSTRAINTİ
=TYPESTRUCT
	= 'EXP FLOATING_POINT_CONSTRAINT;
=DESCRIBE
=ENDDOC

=DOC
type 'EXP ÛFLOATING_TYPE_DEFİ
=TYPESTRUCT
	= 'EXP FLOATING_POINT_CONSTRAINT;
=DESCRIBE
=ENDDOC

=DOC
type 'EXP ÛFIXED_TYPE_DEFİ
=TYPESTRUCT
	= 'EXP FIXED_POINT_CONSTRAINT;
=DESCRIBE
=ENDDOC


\subsubsection{Type Definitions}

TYPE\_DEF brings all the above type definitions together.

¹Z
TYPE_DEF ::= enum_type_def Enum_Type_Def | int_type_def Range |
		uncon_array_def Array_Def | con_array_def Array_Def |
		record_type_def Record_Type_Def
°

The datatype for TYPE\_DEF is declared with other datatypes co-recursively with EXP in section \ref{TypeDefExpr}.

An additional constructor is provided for private types and for reals.

\subsubsection{Type Declarations}
Type\_Decl is a type declaration, that is a type definition together with its name.

ÿType_Declüüüüüüüüüüüü
Ü	name : ID;
Ü	type_def : TYPE_DEF
ˆüüüüüüüüüüüüüüüüüüüüü

The optional discriminant part is required.
=DOC
type DISCR_PART
=TYPESTRUCT
	= VAR_DECL OPT;
=DESCRIBE
=ENDDOC


=DOC
type 'TYPE_DEF ÛTYPE_DECLİ
=TYPESTRUCT
      = {
	name : ID,
	discr : DISCR_PART,
	type_def : 'TYPE_DEF
	};
=DESCRIBE
=ENDDOC

\subsubsection{SubTypes}
Subtype\_Decl models subtype declarations.

¹Z
CONSTRAINT ::= range_con Range | index_con TMARK
°

The datatype for CONSTRAINT is declared with other datatypes co-recursively with EXP in section \ref{TypeDefExpr}.

A constraint can also be a fixed or a floating point constraint. The following changes remedy this.

Sub\_Ind is a subtype indication.

ÿSub_Indüüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	con : CONSTRAINT
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type 'CONSTRAINT ÛSUB_INDİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	con : 'CONSTRAINT
	};
=DESCRIBE
=ENDDOC

ÿSubtype_Declüüüüüüüüüüüüüüüüü
Ü	name : ID;
Ü	Sub_Ind
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type 'CONSTRAINT ÛSUBTYPE_DECLİ
=TYPESTRUCT
      = {
	name : ID,
	sub_ind : 'CONSTRAINT SUB_IND
	};
=DESCRIBE
=ENDDOC

\subsubsection{Constants}
Const\_Decl models constant declarations.

ÿConst_Decl[EXP]üüüüüüüüüüüüüüüüü
Ü	const : ID;
Ü	tm : TMARK;
Ü	expr : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

It is useful to keep a list of the constants declared in the same constant declaration for reproducability. The const component is therefore implemented as a list.
=DOC
type 'EXP ÛCONST_DECLİ
=TYPESTRUCT
      = {
	consts : ID list,
	tm : TMARK,
	expr : 'EXP
	};
=DESCRIBE
=ENDDOC
Abstract syntax is also required for deferred constants.
=DOC
type ÛDEFERRED_CONST_DECLİ
=TYPESTRUCT
      = {
	consts : ID list,
	tmark : TMARK
	};
=DESCRIBE
=ENDDOC
\subsubsection{Private Types}
=DOC
type ÛPRIVATE_TYPE_DECLİ
=TYPESTRUCT
      = {
	id : ID,
	limited : bool
	};
=DESCRIBE
=ENDDOC

\subsubsection{Type Definition for Basic Declarations}
¹Z
BASIC_DECL ::= const_decl Const_Decl | type_decl Type_Decl |
		subtype_decl Subtype_Decl
°

The datatype for BASIC\_DECL is declared with other datatypes co-recursively with EXP in section \ref{TypeDefExpr}.
A type constructor is also required for deferred constants and for variable declarations.
\subsection{Expressions}
\subsubsection{Aggregates}
Agg\_Pos is a positional array or record aggregate.

ÿAgg_Pos[EXP]üüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	comps : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüü

Does the fact that there is only one type mark mean that all the components have to have the same type?
=DOC
type ('EXP) ÛAGG_POSİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	comps : 'EXP list
	};
=DESCRIBE
=ENDDOC

Agg\_Pos\_Others is a positional array with an others part.

ÿOthers[EXP]üüüüüüüüüüüüüüüüü
Ü	others : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type ('EXP) ÛOTHERSİ
=TYPESTRUCT
      = {
	others : 'EXP
	};
=DESCRIBE
=ENDDOC

ÿAgg_Pos_Othersüüüüüüüüüüüüüüüüü
Ü	Agg_Pos;
Ü	Others
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type 'EXP ÛAGG_POS_OTHERSİ
=TYPESTRUCT
      = {
	agg_pos : 'EXP AGG_POS,
	others : 'EXP OTHERS
	};
=DESCRIBE
=ENDDOC

Agg\_Others is an array aggregate with just an others part.

ÿAgg_Othersüüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	Others
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type 'EXP ÛAGG_OTHERSİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	others : 'EXP OTHERS
	};
=DESCRIBE
=ENDDOC

Agg\_Choice is an aggregate choice with terms separated by ``|''.

Generic free type definitions are not permitted in Z, so for AGG\_CHOICE we write the following (as per \cite{Spivey92}).

¹Z
Ü	[AGG_CHOICE]
°

[EXP]œœœœœœœœœœœœœœœœœœœœœœœœœœœœ
Ü	agg_choice_range : Range à AGG_CHOICE;
Ü	agg_choice_single : EXP à AGG_CHOICE
÷üüüüüüüüüüüüüüüüüüüüü
Ü	disjoint §ran agg_choice_range, ran agg_choice_single¢ ±
Ü
Ü	(µ W : ğ AGG_CHOICE ·
Ü	agg_choice_range ¨Range© À agg_choice_single ¨EXP© € W
Ü	´ AGG_CHOICE € W)
ˆüüüüüüüüüüüüüüüüüüüüüü

A discrete range can be a type mark with an optional range constraint. The abstract syntax is modified to cover this.
=DOC
type 'EXP ÛDISCRETE_RANGE_CONSTRAINEDİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	range : 'EXP RANGE
	};
=DESCRIBE
=ENDDOC
The datatype for DISCRETE RANGE is declared in section \ref{TypeDefExpr}.

The datatype for AGG\_CHOICE is declared with other datatypes co-recursively with EXP in section \ref{TypeDefExpr}.

Agg\_Named models a named array aggregate.

ÿNamed_Assoc[EXP]üüüüüüüüüüüüüüüüü
Ü	choices : ğ AGG_CHOICE;
Ü	comp : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type ('AGG_CHOICE, 'EXP) ÛNAMED_ASSOCİ
=TYPESTRUCT
      = {
	choice : 'AGG_CHOICE list,
	comp : 'EXP
	};
=DESCRIBE
=ENDDOC

ÿAgg_Namedüüüüüüüüüüüüüüüüü
Ü	named_assocs : ğ Named_Assoc
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type ('AGG_CHOICE, 'EXP) ÛAGG_NAMEDİ
=TYPESTRUCT
      = {
	named_assocs : ('AGG_CHOICE, 'EXP) NAMED_ASSOC list
	};
=DESCRIBE
=ENDDOC

Agg\_Named\_Others is a named array aggregate with an others part.

ÿAgg_Named_Othersüüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	Agg_Named;
Ü	Others
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type ('AGG_CHOICE, 'EXP) ÛAGG_NAMED_OTHERSİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	agg_named : ('AGG_CHOICE, 'EXP) AGG_NAMED, 
	others : ('EXP) OTHERS
	};
=DESCRIBE
=ENDDOC

Rec\_Agg\_Named is a named record aggregate. (Positional record aggregates are modelled by Agg\_Pos at the start of this section). The type of named assocs is replaced with that used in named array aggregates.

ÿRec_Agg_Named[EXP]üüüüüüüüüüüüüüüüü
Ü	tmark : TMARK;
Ü	named_assocs : ğ (ID ¸ EXP)
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type ('AGG_CHOICE,'EXP) ÛREC_AGG_NAMEDİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	named_assocs : ('AGG_CHOICE, 'EXP) NAMED_ASSOC list
	};
=DESCRIBE
=ENDDOC

\subsubsection{Qualified Expressions}

The following implements abstract syntax for a qualified expression.

=DOC
type 'EXP ÛQUALIFIED_EXPRESSIONİ
=TYPESTRUCT
      = {
	tmark : TMARK,
	exp : 'EXP
	};
=DESCRIBE
=ENDDOC

\subsubsection{Unary Operations}

¹Z
Ü	UNARY_OP ::=
Ü	spark_unary_add | spark_unary_minus | spark_not | spark_abs
°

=DOC
datatype ÛUNARY_OPİ =
			ÛUOSparkUnaryAddİ
		|	ÛUOSparkUnaryMinusİ
		|	ÛUOSparkNotİ
		|	ÛUOSparkAbsİ;
=DESCRIBE
=ENDDOC


ÿUnary_Exp[EXP]üüüüüüüüüüüüüüüüü
Ü	op : UNARY_OP;
Ü	right : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type ('EXP) ÛUNARY_EXPİ
=TYPESTRUCT
      = {uop : UNARY_OP, right : 'EXP};
=DESCRIBE
=ENDDOC


\subsubsection{Binary Expressions}

¹Z
Ü	BIN_OP ::=
Ü	spark_and | spark_or | spark_xor | spark_eq | spark_noteq |
Ü	spark_less | spark_less_eq | spark_greater | spark_greater_eq |
Ü	spark_add | spark_minus | spark_times | spark_intdiv |
Ü	spark_mod | spark_rem | spark_expon | spark_mem | spark_notmem
°

The binary operators $BOSparkAndThen$, $BOSparkOrElse$ and $BOSparkConcat$ have been added.
=DOC
datatype ÛBIN_OPİ =
			ÛBOSparkAndİ | ÛBOSparkAndThenİ
		|	ÛBOSparkOrİ | ÛBOSparkOrElseİ | ÛBOSparkXorİ
		|	ÛBOSparkEqİ | ÛBOSparkNotEqİ
		|	ÛBOSparkLessİ | ÛBOSparkLessEqİ
		|	ÛBOSparkGreaterİ | ÛBOSparkGreaterEqİ
		|	ÛBOSparkAddİ | ÛBOSparkMinusİ | ÛBOSparkTimesİ
		|	ÛBOSparkIntdivİ | ÛBOSparkModİ | ÛBOSparkRemİ
		|	ÛBOSparkExponİ
		|	ÛBOSparkMemİ | ÛBOSparkNotMemİ
		|	ÛBOSparkConcatİ;
=DESCRIBE
=ENDDOC

ÿBin_Exp[EXP]üüüüüüüüüüüüüüüüü
Ü	op : BIN_OP;
Ü	left, right : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type 'EXP ÛBIN_EXPİ
=TYPESTRUCT
      = {
	bop : BIN_OP,
	left : 'EXP,
	right : 'EXP
	};
=DESCRIBE
=ENDDOC

Mem\_Range is the membership (or non-membership) of a range.

¹Z
Ü	MEM_OP ¦ {spark_mem, spark_nonmem}
°

=DOC
type ÛMEM_OPİ
=TYPESTRUCT
	= BIN_OP;
=DESCRIBE
=ENDDOC

ÿMem_Range[EXP]üüüüüüüüüüüüüüüüü
Ü	left : EXP;
Ü	op : MEM_OP;
Ü	Range
ˆüüüüüüüüüüüüüüüüüüüüü


=DOC
type ('EXP) ÛMEM_RANGEİ
=TYPESTRUCT
      = {
	left : 'EXP,
	mop : MEM_OP,
	range : 'EXP RANGE
	};
=DESCRIBE
=ENDDOC


\subsubsection{Attributes}
Attribute models Ada attributes.

ATTRIB are the attribute designators FIRST, LAST, SUCC, PRED, POS, VAL, LENGTH and RANGE.

¹ZAX
Ü	fst, lst, suc, pred, pos, val, length, range : ID
°

¹Z
Ü	ATTRIB ¦ {fst, lst, suc, pred, pos, val, length, range}
°

=DOC
type ÛATTRIBİ
=TYPESTRUCT
	= ID;
=DESCRIBE
=ENDDOC

ATTRIB\_DESIG models the attribute designators.

Generic free type definitions are not permitted in Z, so for ATTRIB\_DESIG we write the following (as per \cite{Spivey92}).

¹Z
Ü	[ATTRIB_DESIG]
°

[EXP]œœœœœœœœœœœœœœœœœœœœœœœœœœœœ
Ü	attrib : ATTRIB à ATTRIB_DESIG;
Ü	attrib_arg : (ATTRIB ¸ EXP) à ATTRIB_DESIG
÷üüüüüüüüüüüüüüüüüüüüü
Ü	disjoint §ran attrib, ran attrib_arg¢ ±
Ü
Ü	(µ W : ğ ATTRIB_DESIG ·
Ü	attrib ¨ATTRIB© À attrib_arg ¨ATTRIB ¸ EXP© € W
Ü	´ ATTRIB_DESIG € W)
ˆüüüüüüüüüüüüüüüüüüüüüü



The datatype for ATTRIB DESIG is declared in section \ref{TypeDefExpr}.

ÿAttributeüüüüüüüüüüüüüüüüü
Ü	prefix : ID;
Ü	attribute_desig : ATTRIB_DESIG
ˆüüüüüüüüüüüüüüüüüüüüü

The prefix can in fact be a name (i.e., an expression).
=DOC
type ('EXP,'ATTRIB_DESIG) ÛATTRIBUTEİ
=TYPESTRUCT
      = {
	prefix : 'EXP,
	attribute_desig : 'ATTRIB_DESIG
	};
=DESCRIBE
=ENDDOC

\subsubsection{Indexed Component}
Indexed\_Comp is an array component.

ÿIndexed_Comp[EXP]üüüüüüüüüüüüüüüüü
Ü	prefix, index : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type ('EXP) ÛINDEXED_COMPİ
=TYPESTRUCT
      = {
	prefix : 'EXP,
	index : 'EXP
	};
=DESCRIBE
=ENDDOC

\subsubsection{Selected Component}
Selected\_Comp is a record component.

ÿSelected_Comp[EXP]üüüüüüüüüüüüüüüüü
Ü	prefix : EXP;
Ü	selector : ID
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type ('EXP) ÛSELECTED_COMPİ
=TYPESTRUCT
      = {
	prefix : 'EXP,
	selector : ID
	};
=DESCRIBE
=ENDDOC

\subsubsection{Function Calls}
Fun\_Call is a function call.

ÿFun_Call[EXP]üüüüüüüüüüüüüüüüü
Ü	fun_name : ID;
Ü	args : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type ('EXP) ÛFUN_CALLİ
=TYPESTRUCT
      = {
	fun_name : ID,
	args : 'EXP list
	};
=DESCRIBE
=ENDDOC

\subsubsection{Integer Literals}
INT\_LIT are the integer literals.

¹Z
Ü	[INT_LIT]
°

=DOC
type ÛINT_LITİ
=TYPESTRUCT
	= string;
=DESCRIBE
=ENDDOC

\subsubsection{Auxiliary Expressions}
In the Compliance Notation, a SPARK expression can also be a Z expression (auxiliary expression).


\subsubsection{Type Definition for Expressions}\label{TypeDefExpr}

¹Z
Ü	EXP ::=	
Ü		Id ID | int INT_LIT | array_agg_pos Agg_Pos |
Ü		array_agg_pos_others Agg_Pos_Others |
Ü		array_agg_others Agg_Others |
Ü		array_agg_named Agg_Named |
Ü		array_agg_named_others Agg_Named_Others |
Ü		rec_agg_pos Agg_Pos | rec_agg_named Rec_Agg_Named |
Ü		unary_exp Unary_Exp | bin_exp Bin_Exp |
Ü		mem_range Mem_Range | attribute Attribute |
Ü		indexed_comp Indexed_Comp |
Ü		selected_comp Selected_Comp |
Ü		fun_call Fun_Call |
Ü		auxiliary_exp Z_EXP
°

=DOC
datatype ÛTYPE_DEFİ =
			ÛTDEnumTypeDefİ of ENUM_TYPE_DEF
		|	ÛTDIntTypeDefİ of EXP RANGE
		|	ÛTDFloatingTypeDefİ of EXP FLOATING_TYPE_DEF
		|	ÛTDFixedTypeDefİ of EXP FIXED_TYPE_DEF
		|	ÛTDUnconArrayDefİ of ARRAY_DEF
		|	ÛTDConArrayDefİ of ARRAY_DEF
		|	ÛTDRecordTypeDefİ of COMPONENT RECORD_TYPE_DEF
=DESCRIBE
=ENDDOC
=DOC
and ÛCONSTRAINTİ =
			ÛCRangeİ of EXP RANGE
		|	ÛCIndexİ of EXP list
		|	ÛCFloatingİ of EXP FLOATING_POINT_CONSTRAINT
		|	ÛCFixedİ of EXP FIXED_POINT_CONSTRAINT
=DESCRIBE
=ENDDOC
=DOC
and ÛBASIC_DECLİ =
			ÛBDConstDeclİ of (EXP) CONST_DECL
		|	ÛBDDeferredConstDeclİ of DEFERRED_CONST_DECL
		|	ÛBDTypeDeclİ of (TYPE_DEF) TYPE_DECL
		|	ÛBDVarDeclİ of VAR_DECL
		|	ÛBDSubtypeDeclİ of (CONSTRAINT) SUBTYPE_DECL
		|	ÛBDPrivateTypeDeclİ of PRIVATE_TYPE_DECL
=DESCRIBE
=ENDDOC
=DOC
and ÛDISCRETE_RANGEİ =
			ÛDRRangeİ of EXP RANGE
		|	ÛDRConstrainedİ of EXP DISCRETE_RANGE_CONSTRAINED
=DESCRIBE
=ENDDOC
=DOC
and ÛAGG_CHOICEİ =
			ÛACAggChoiceRangeİ of DISCRETE_RANGE
		|	ÛACAggChoiceSingleİ of EXP
=DESCRIBE
=ENDDOC
=DOC
and ÛATTRIB_DESIGİ =
			ÛADAttribİ of ATTRIB
		|	ÛADAttribArgİ of (ATTRIB * EXP)
=DESCRIBE
=ENDDOC
In order to reproduce the SPARK program as the user entered it, it is necessary to store bracketing information in the abstract syntax. Also string and character literals have been added.
=DOC
and ÛEXPİ =
		ÛEIdİ of ID
	|	ÛEIntİ of INT_LIT
	|	ÛEArrayAggPosİ of EXP AGG_POS
	|	ÛEArrayAggPosOthersİ of EXP AGG_POS_OTHERS
	|	ÛEArrayAggOthersİ of EXP AGG_OTHERS
	|	ÛEArrayAggNamedİ of (AGG_CHOICE,EXP) AGG_NAMED
	|	ÛEArrayAggNamedOthersİ of (AGG_CHOICE,EXP) AGG_NAMED_OTHERS
	|	ÛERecAggPosİ of EXP AGG_POS
	|	ÛERecAggNamedİ of (AGG_CHOICE,EXP) REC_AGG_NAMED
	|	ÛEUnaryExpİ of EXP UNARY_EXP
	|	ÛEBinExpİ of EXP BIN_EXP
	|	ÛEMemRangeİ of EXP MEM_RANGE
	|	ÛEAttributeİ of (EXP,ATTRIB_DESIG) ATTRIBUTE
	|	ÛEIndexedCompİ of EXP INDEXED_COMP
	|	ÛESelectedCompİ of EXP SELECTED_COMP
	|	ÛEFunCallİ of EXP FUN_CALL
	|	ÛEAuxiliaryExpİ of Z_TM
	|	ÛEQualifiedExpİ of EXP QUALIFIED_EXPRESSION
	|	ÛEBracketedİ of EXP
	|	ÛEStringLiteralİ of string
	|	ÛECharacterLiteralİ of string;
=DESCRIBE
The Auxiliary expression is represented as a parsed (but not type-checked) Z term. The type inference occurs during VC generation.
=ENDDOC


\subsection{Statements}

The Z specification of the abstract syntax uses a given set declaration to act as a forward declaration of the free type $Stmt$, permitting the free type to involve recursion through schema constructions.
Unfortunately, this style is not considered to be type correct in \ProductZ; this is readily circumvented by making the schema constructions generic where necessary.
For example, see section \ref{if-then-else} below.

Following this convention we may now work through the abstract syntax for SPARK statements following \cite{DRA/CIS/CSE3/SWI/WP/1/3}.

\subsubsection{Assignment}\label{assignment}

ÿAssignüüüüüüüüüüüüüüüüü
Ü	name, E : EXP
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type ÛASSIGNİ
=TYPESTRUCT
      = {
	name : EXP,
	e : EXP
	};
=DESCRIBE
=ENDDOC

\subsubsection{Specification Statements}

¹Z
Ü	Z_PRED‰0 : ğ Z_PRED
°

=DOC
type ÛZ_PRED‰0İ
=TYPESTRUCT
	= Z_PRED;
=DESCRIBE
=ENDDOC

ÿSpecüüüüüüüüüüüüüüüüü
Ü	w, w‰0 : ğ Z_ID;
Ü	Pre, post : Z_PRED
÷üüüüüüüüüüüüüüü
Ü	Pre  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü

ÿSpec_No_Ivarsüüüüüüüüüüüü
Ü	Spec
÷üüüüüüüüüüüüüüü
Ü	post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü


In the translation into Standard ML of a schema which includes another,
we have various choices.
In this simple case where the new schema has the same signature as the included one, we just say that the new type is an abbreviation for the old one.

Additionally Label is stored with the abstract syntax of the specification statement.
=DOC
datatype ÛLABELİ =
			ÛLExplicitİ of string
		|	ÛLImplicitİ;
=DESCRIBE
=ENDDOC
=DOC
type ÛSPECİ
=TYPESTRUCT
      = {
	w : Z_ID list,
	w0 : Z_ID list,
	pre : Z_TM,
	post : Z_TM,
	label : LABEL
	};
=DESCRIBE
The pre- and post-conditions in the specification are represented as parsed but not type-checked Z terms. This is so that type inference can be performed in the correct environment during VC generation.
=ENDDOC
=DOC
type ÛSPEC_NO_IVARSİ
=TYPESTRUCT
	= SPEC;
=DESCRIBE
=ENDDOC
\subsubsection{If-then-else}\label{if-then-else}

¹ZAX
Ü	COND : ğ EXP
°

ÿIf_Then_Else[STMT]üüüüüüüüüüüüüüüüü
Ü	G : COND;
Ü	P, Q : STMT
ˆüüüüüüüüüüüüüüüüüüüüü

In an nested if statement 

=GFT SPARK Fragment
IF	<cond>	THEN	<stmt>; END IF;
ELSIF	<cond>	THEN	<stmt>; END IF;
...
ELSIF	<cond>	THEN	<stmt>;
END IF;
=TEX
is equivalent to
=GFT SPARK Fragment
IF	<cond>	THEN	<stmt>;
ELSE IF	<cond>	THEN	<stmt>; 
...
ELSE IF	<cond>	THEN	<stmt>; END IF; ... END IF;
END IF;
=TEX
I.e., ELSIF is the same as writing ELSEIF. In order to make the input reproducable in the SPARK program to be generated, a flag is stored with each abstract representation of the if statement indicating whether the else condition was input as an ELSIF or not.
=DOC
type ÛCONDİ
=TYPESTRUCT
	= EXP;
=ENDDOC

=DOC
type ('STMT) ÛIF_THEN_ELSEİ
=TYPESTRUCT
      = {
	g : COND,
	p : 'STMT,
	q : 'STMT,
	elsif : bool
	};
=DESCRIBE
=ENDDOC
\subsubsection{Case}\label{case}

¹Z
Ü	CASE_CHOICE ::= case_exp EXP | case_range Range
°

The case choice can be a discrete range.
=DOC
datatype ÛCASE_CHOICEİ =
				ÛCCCaseExpİ of EXP
			|	ÛCCCaseRangeİ of DISCRETE_RANGE;
=DESCRIBE
=ENDDOC

ÿCase_Alternative[STMT]üüüüüüüüüüüüüüüüü
Ü	choices : ğ CASE_CHOICE;
Ü	P : STMT
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü
ÿCaseüüüüüüüüüüüüüüüüü
Ü	E : EXP;
Ü	s : seq‰1 Case_Alternative
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

A Case statement can have an others part.
=DOC
type 'STMT ÛCASE_ALTERNATIVEİ
=TYPESTRUCT
      = {
	choices : CASE_CHOICE list,
	p : 'STMT
	};
=DESCRIBE
=ENDDOC
=DOC
type 'STMT ÛCASEİ
=TYPESTRUCT
      = {
	e : EXP,
	s : ('STMT) CASE_ALTERNATIVE list,
	others : 'STMT
	};
=DESCRIBE
=ENDDOC
\subsubsection{Loop}\label{loop}

ÿLoopüüüüüüüüüüüüüüüüü
Ü	T : Z_PRED;
Ü	Spec_No_Ivars
÷üüüüüü
Ü	T  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

As with the translation of $Spec\_No\_Ivars$, we have a choice of how to translate the schema inclusion.
This case is a little more complicated, however, but as there is no overlap between the signature of the included schema and other signature variables, we can adopt the following simple translation.

The till clause may not be present in which case the t component will be true. However we make t optional to reflect the concrete syntax so that the SPARK program can be reproduced authentically.

A loop body may be a sequence of statements in which case the treatment of the loop can only be informal with respect to generating verification conditions.
A loop without an iteration scheme can have a name, so we introduce an additional type called NAMED\_LOOP.
=DOC
type 'STMT ÛLOOPİ
=TYPESTRUCT
      = {
	t : Z_TM OPT,
	stmt : 'STMT
	};
=DESCRIBE
The till part is represented as a parsed (but not type-checked) Z term to enable type inference to happen in the correct environment during VC generation.
=ENDDOC
=DOC
type 'STMT ÛNAMED_LOOPİ
=TYPESTRUCT
      = {
	name : ID,
	t : Z_TM OPT,
	stmt : 'STMT
	};
=DESCRIBE
The till part is represented as a parsed (but not type-checked) Z term to enable type inference to happen in the correct environment during VC generation.
=ENDDOC

\subsubsection{While Loop}\label{while-loop}
ÿWhileüüüüüüüüüüüüüüüüü
Ü	G : COND;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

Loops can have names, so a name is introduced into the abstract representation.
=DOC
type 'STMT ÛWHILEİ
=TYPESTRUCT
      = {
	name : ID OPT,
	g : COND,
	loop : 'STMT LOOP
	};
=DESCRIBE
=ENDDOC
\subsubsection{For Loop (Values as Bounds)}\label{for-static}

¹ZAX
Ü	STATIC_EXP : ğ EXP
°

ÿFor_Staticüüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	lo, hi : STATIC_EXP;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

Loops can have names so a field in the abstract representation is reserved for name. Also we record in the abstract syntax the direction of the loop and the type mark for the purposes of reproducing the SPARK program.

=DOC
type ÛSTATIC_EXPİ
=TYPESTRUCT
	= EXP;
=ENDDOC
=DOC
datatype ÛLOOP_DIRECTIONİ =
				ÛLDForwardsİ
			|	ÛLDReverseİ;
=DESCRIBE
=ENDDOC
A range component is used rather than a lo-hi pair in order to support the possibility of representing a range attribute.
=DOC
type 'STMT ÛFOR_STATICİ
=TYPESTRUCT
      = {
	name : ID OPT,
	i : ID,
	tmark : ID,
	range : EXP RANGE,
	dir : LOOP_DIRECTION,
	loop : 'STMT LOOP
	};
=DESCRIBE
=ENDDOC
\subsubsection{For Loop (Type Mark as Range)}\label{for-typemark}

ÿFor_Tmarküüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	tmark : TMARK;
Ü	Loop
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

FOR\_TMARK is augmented in the same way as for FOR\_STATIC.

=DOC
type 'STMT ÛFOR_TMARKİ
=TYPESTRUCT
      = {
	name : ID OPT,
	i : ID,
	tmark : TMARK,
	dir : LOOP_DIRECTION,
	loop : 'STMT LOOP
	};
=DESCRIBE
=ENDDOC
\subsubsection{Exit}\label{exit}

ÿExit_Whenüüüüüüüüüüüüüüüüü
Ü	G : COND
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

=DOC
type ÛEXIT_WHENİ
=TYPESTRUCT
      = {
	g : COND
	};
=DESCRIBE
=ENDDOC
\subsubsection{Return}\label{return}

ÿReturnüüüüüüüüüüüüüüüüü
Ü	E : EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

=DOC
type ÛRETURNİ
=TYPESTRUCT
      = {
	e : EXP
	};
=DESCRIBE
=ENDDOC
\subsubsection{Procedure Call}\label{procedure-call}

ÿProc_Callüüüüüüüüüüüüüüüüü
Ü	name : ID;
Ü	actuals : seq EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

The actual part can be a positional parameter association or a named parameter association.

=DOC
datatype ('AGG_CHOICE, 'EXP) ÛACTUALSİ =
			ÛAPositionalİ of EXP list
		|	ÛANamedİ of ('AGG_CHOICE, 'EXP) NAMED_ASSOC list;
=DESCRIBE
=ENDDOC
=DOC
type ('AGG_CHOICE,'EXP) ÛPROC_CALLİ
=TYPESTRUCT
      = {
	name : ID,
	actuals : ('AGG_CHOICE,'EXP) ACTUALS
	};
=DESCRIBE
=ENDDOC

¹ZAX
Ü	retrieve_spec_stmt : ID ß Spec
°

ÿProc_Call_No_Ivarsüüüüüüüüüüüüüüüüü
Ü	Proc_Call
÷üüüüüüüüüüüüüüüü
Ü	(retrieve_spec_stmt name).post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

=DOC
type ('AGG_CHOICE,'EXP) ÛPROC_CALL_NO_IVARSİ
=TYPESTRUCT
	= ('AGG_CHOICE,'EXP) PROC_CALL;
=DESCRIBE
=ENDDOC
\subsubsection{$Stmt$}\label{stmt}
\ProductZ\ is currently non-standard in that it neither requires nor
allows the chevrons around the operands in a free type definition.
This mismatch with the Z standard is planned to be remedied in a future release of the system.

¹Z
	Stmt	::= 	null
		|	assign Assign
		|	spec_no_ivars Spec_No_Ivars
		|	semicolon (Stmt ¸ Stmt)
		|	if_then_else If_Then_Else
		|	case Case
		|	loop Loop
		|	while While
		|	for_static For_Static
		|	for_tmark For_Tmark
		|	exit_when Exit_When
		|	exit
		|	ret Return
		|	proc_no_ivars Proc_Call_No_Ivars
°

KSLots are required in the abstract syntax as place markers so that when the SPARK program is reproduced from the abstract syntax, the expansions can be put back into the correct places.
=DOC
type ÛK_SLOTİ
=TYPESTRUCT
      = {
	content : string,
	label : LABEL
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛSTMTİ	= 	ÛSTNullİ
		| 	ÛSTImplicitNullİ
		|	ÛSTAssignİ of ASSIGN
		|	ÛSTSpecNoIvarsİ of SPEC_NO_IVARS
		|	ÛSTSemicolonİ of (STMT * STMT)
		|	ÛSTIfThenElseİ of  STMT IF_THEN_ELSE
		|	ÛSTCaseİ of STMT CASE
		|	ÛSTLoopİ of STMT LOOP
		|	ÛSTNamedLoopİ of STMT NAMED_LOOP
		|	ÛSTWhileİ of STMT WHILE
		|	ÛSTForStaticİ of STMT FOR_STATIC
		|	ÛSTForTmarkİ of STMT FOR_TMARK
		|	ÛSTExitWhenİ of EXIT_WHEN
		|	ÛSTExitİ
		|	ÛSTRetİ of RETURN
		|	ÛSTProcNoIvarsİ of (AGG_CHOICE,EXP) PROC_CALL_NO_IVARS
		|	ÛSTKSlotİ of K_SLOT;
=DESCRIBE
=ENDDOC
\pagebreak
\subsubsection{Specification (with initial variables)}\label{specification-ivars}

ÿSpec_Ivarsüüüüüüüüüüüü
Ü	Spec
÷üüüüüüüüüüüüüüü
Ü	post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type ÛSPEC_IVARSİ 
=TYPESTRUCT
	= SPEC;
=DESCRIBE
=ENDDOC
\subsubsection{For Loop (Non-Static Bounds)}\label{for-non-static-bounds}

ÿFor_Non_Staticüüüüüüüüüüüüüüüüü
Ü	i : ID;
Ü	lo, hi : EXP;
Ü	Loop
÷üüüüüüüüüüüüüüüü
Ü		lo  STATIC_EXP
Ü	²
Ü		hi  STATIC_EXP
ˆüüüüüüüüüüüüüüüüüüüüüüüüüüü

A loop may have an optional name. 

A range component is used rather than a lo-hi pair in order to support the possibility of representing a range attribute.
=DOC
type ÛFOR_NON_STATICİ
=TYPESTRUCT
      = {
	name : ID OPT,
	i : ID,
	range : STATIC_EXP RANGE,
	loop : STMT LOOP
	};
=DESCRIBE
=ENDDOC
\subsubsection{Logical Constants}\label{logical-constants}

¹ZAX
Ü	free_ids : Z_EXP ­ ğ Z_ID
°

ÿLog_Conüüüüüüüüüüüü
Ü	X : Z_ID;
Ü	E : Z_EXP;
Ü	Spec;
Ü	pre‰1 : Z_PRED
÷üüüüüüüüüüüüüüü
Ü	Pre = z_and(z_eq(zid X, E), pre‰1);
Ü	X  free_ids E
ˆüüüüüüüüüüüüüüüüüüüüü

The functions $free\_id$ may readily and reallistically be implemented using existing \Product\
syntax functions.
$t$ represents the set of which $x$ is a member.
=DOC
type ÛLOG_CONİ
=TYPESTRUCT
      = {
	x : Z_ID,
	t : Z_TM,
	e : Z_EXP,
	spec : SPEC,
	pre1 : Z_EXP
	};
=DESCRIBE
$$ is represented as a parsed Z term. Type inference occurs during VC generation when the appropriate $Z\_EXP$ is generated. The values for $e$ and $pre1$ are filled in at this time.
=ENDDOC
\subsubsection{Procedure Calls}\label{procedure-calls}

ÿProc_Call_Ivarsüüüüüüüüüüüü
Ü	Proc_Call
÷üüüüüüüüüüüüüüü
Ü	(retrieve_spec_stmt name).post  Z_PRED‰0
ˆüüüüüüüüüüüüüüüüüüüüü

=DOC
type ('AGG_CHOICE,'EXP) ÛPROC_CALL_IVARSİ
=TYPESTRUCT
	= ('AGG_CHOICE,'EXP) PROC_CALL;
=DESCRIBE
=ENDDOC

\subsubsection{Statement}\label{statement}
¹Z
	Statement
		::= 	stmt Stmt
		|	spec_ivars (Spec_Ivars ¸ Stmt)
		|	for_non_static (For_Non_Static ¸ Stmt)
		|	log_con (Log_Con ¸ Stmt)
		|	proc_ivars (Proc_Call_Ivars ¸ Stmt)
°

=DOC
datatype ÛSTATEMENTİ =
		 	ÛSStmtİ of STMT
		|	ÛSSpecIvarsİ of (SPEC_IVARS * STMT)
		|	ÛSForNonStaticİ of (FOR_NON_STATIC * STMT)
		|	ÛSLogConİ of (LOG_CON * STMT)
		|	ÛSProcIvarsİ of ((AGG_CHOICE,EXP) PROC_CALL_IVARS * STMT);
=DESCRIBE
=ENDDOC

\subsection{Subprogram Declarations}
=DOC
datatype ÛMODEİ =	MSparkIn
		|	MSparkOut
		|	MSparkInOut;
=DESCRIBE
=ENDDOC
=DOC
type ÛPARAMETER_SPECIFICATIONİ
=TYPESTRUCT
      = {
	idlist : ID list,
	mode : MODE,
	name : TMARK
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛPROCEDURE_SPECIFICATIONİ
=TYPESTRUCT
      = {
	name : ID,
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛFUNCTION_SPECIFICATIONİ
=TYPESTRUCT
      = {
	designator : ID,
	return : TMARK,
	formal_part : PARAMETER_SPECIFICATION list,
	spec : SPEC OPT
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛSUBPROGRAM_SPECIFICATIONİ =
			ÛSSProcedureİ of PROCEDURE_SPECIFICATION
		|	ÛSSFunctionİ of FUNCTION_SPECIFICATION;
=DESCRIBE
=ENDDOC
=DOC
type ÛPROCEDURE_DECLARATIONİ
=TYPESTRUCT
	= PROCEDURE_SPECIFICATION;
=DESCRIBE
=ENDDOC
=DOC
type ÛFUNCTION_DECLARATIONİ
=TYPESTRUCT
	= FUNCTION_SPECIFICATION;
=DESCRIBE
=ENDDOC
=DOC
type ÛSUBPROGRAM_DECLARATIONİ
=TYPESTRUCT
	= SUBPROGRAM_SPECIFICATION;
=DESCRIBE
=ENDDOC
\subsection{Subprogram Bodies}
\subsection{Procedure and Function Calls}
=DOC
type ÛNAMED_PARAMİ
=TYPESTRUCT
      = {
	formal : ID,
	actual : EXP
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛNAMED_PARAMETER_ASSOCİ
=TYPESTRUCT
      = {
	params: NAMED_PARAM list
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛPOS_PARAMETER_ASSOCİ
=TYPESTRUCT
      = {
	params : EXP list
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛACTUAL_PARAMETER_PARTİ = 
			ÛAPPNamedİ of NAMED_PARAMETER_ASSOC
		|	ÛAPPPositionalİ of POS_PARAMETER_ASSOC;
=DESCRIBE
=ENDDOC
\subsection{Package Declaration}
=DOC
type ÛOPERATOR_SYMBOLİ
=TYPESTRUCT
	= string;
=DESCRIBE
=ENDDOC
=DOC
type ÛFUNCTION_RENAMINGİ
=TYPESTRUCT
      = {
	opsym1 : OPERATOR_SYMBOL,
	formal_part : PARAMETER_SPECIFICATION list,
	tmark : TMARK,
	name : ID,
	opsym2 : OPERATOR_SYMBOL
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛSUBPROGRAM_RENAMINGİ
=TYPESTRUCT
      = {
	subprogram_specification : SUBPROGRAM_SPECIFICATION,
	name1 : ID,
	name2 : ID
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛRENAMING_DECLARATIONİ =
			ÛRDFunctionİ of FUNCTION_RENAMING
		|	ÛRDSubprogramİ of SUBPROGRAM_RENAMING;
=DESCRIBE
=ENDDOC
=DOC
type ÛLENGTH_CLAUSEİ
=TYPESTRUCT
      = {
	attribute : EXP,
	exp : EXP
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛENUMERATION_REPRESENTATION_CLAUSEİ
=TYPESTRUCT
      = {
	name : ID,
	exp : EXP
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛCOMPONENT_CLAUSEİ
=TYPESTRUCT
      = {
	name : EXP,
	exp : EXP,
	range : EXP RANGE
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛRECORD_REPRESENTATION_CLAUSEİ
=TYPESTRUCT
      = {
	name : ID,
	alignment_opt : EXP OPT,
	component_pack : COMPONENT_CLAUSE list
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛADDRESS_CLAUSEİ
=TYPESTRUCT
      = {
	name : ID,
	exp : EXP
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛREPRESENTATION_CLAUSEİ =
			ÛRCLengthİ of LENGTH_CLAUSE
		|	ÛRCEnumerationİ of ENUMERATION_REPRESENTATION_CLAUSE
		|	ÛRCRecordİ of RECORD_REPRESENTATION_CLAUSE
		|	ÛRCAddressİ of ADDRESS_CLAUSE;
=DESCRIBE
=ENDDOC
=DOC
type 'DECLARATION ÛPROCEDURE_BODYİ
=TYPESTRUCT
      = {
	procedure_spec : PROCEDURE_SPECIFICATION,
	declarative_part : 'DECLARATION list,
	statement : STATEMENT
	};
=DESCRIBE
=ENDDOC
=DOC
type 'DECLARATION ÛFUNCTION_BODYİ
=TYPESTRUCT
      = {
	function_spec : FUNCTION_SPECIFICATION,
	declarative_part : 'DECLARATION list,
	statement : STATEMENT
	};
=DESCRIBE
=ENDDOC
=DOC
type 'DECLARATION ÛPACKAGE_BODYİ
=TYPESTRUCT
      = {
	name : ID,
	decls : 'DECLARATION list,
	statement : STATEMENT
	};
=DESCRIBE
=ENDDOC
=DOC
type 'DECLARATION ÛPACKAGE_DECLARATIONİ
=TYPESTRUCT
      = {
	name : ID,
	visible_decs : 'DECLARATION list,
	private_decs : 'DECLARATION list
	};

=DESCRIBE
=ENDDOC
=DOC
datatype ÛDECLARATIONİ =
			ÛDDeclarationKSlotİ of K_SLOT
		|	ÛDRenamingDeclarationİ of RENAMING_DECLARATION
		|	ÛDBasicDeclİ of BASIC_DECL
		|	ÛDRepresentationClauseİ of REPRESENTATION_CLAUSE
		|	ÛDProperBodyİ of PROPER_BODY
		|	ÛDProcedureDeclarationİ of PROCEDURE_DECLARATION
		|	ÛDFunctionDeclarationİ of FUNCTION_DECLARATION
		|	ÛDPackageDeclarationİ of DECLARATION PACKAGE_DECLARATION
		|	ÛDProcedureStubİ of PROCEDURE_DECLARATION
		|	ÛDFunctionStubİ of FUNCTION_DECLARATION
		|	ÛDPackageStubİ of ID
=DESCRIBE
=ENDDOC
=DOC
and ÛPROPER_BODYİ =	ÛPBProcedureİ of DECLARATION PROCEDURE_BODY
		|	ÛPBFunctionİ of DECLARATION FUNCTION_BODY
		|	ÛPBPackageİ of DECLARATION PACKAGE_BODY;
=DESCRIBE
=ENDDOC

=DOC
type ÛSUBUNITİ
=TYPESTRUCT
      = {
	name : EXP,
	proper_body : PROPER_BODY
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛCOMPILATION_UNITİ =
			ÛCUPackageDeclarationİ of DECLARATION PACKAGE_DECLARATION
		|	ÛCUProperBodyİ of PROPER_BODY
		|	ÛCUSubUnitİ of SUBUNIT;

=DESCRIBE
=ENDDOC
=DOC
type ÛREFINED_BYİ
=TYPESTRUCT
      = {
	label : LABEL,
	statement : STATEMENT
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛREPLACED_BYİ
=TYPESTRUCT
      = {
	label : LABEL,
	statement : STATEMENT
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛREPLACED_BY_DECLİ
=TYPESTRUCT
      = {
	label : LABEL,
	decls : DECLARATION list
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛREPLACED_BY_VISIBLE_PARTİ
=TYPESTRUCT
      = {
	label : LABEL,
	visible : DECLARATION list
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛREPLACED_BY_PRIVATE_PARTİ
=TYPESTRUCT
      = {
	label : LABEL,
	private : DECLARATION list
	};
=DESCRIBE
=ENDDOC
=DOC
type ÛCONTEXT_COMPILATION_UNITİ
=TYPESTRUCT
      = {
	context : ID list,
	comp_unit : COMPILATION_UNIT
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛKSLOT_COMPILATION_UNITİ =
			ÛKCUKSlotİ of K_SLOT
		|	ÛKCUUnitİ of CONTEXT_COMPILATION_UNIT;
=DESCRIBE
=ENDDOC
=DOC
type ÛREPLACED_BY_COMPİ
=TYPESTRUCT
      = {
	label : LABEL,
	comp : KSLOT_COMPILATION_UNIT list
	};
=DESCRIBE
=ENDDOC
=DOC
datatype ÛWEB_CLAUSEİ = 
			ÛWCCompilationİ of KSLOT_COMPILATION_UNIT list
		|	ÛWCReplacedByCompilationİ of REPLACED_BY_COMP
		|	ÛWCReplacedByPrivatePartİ of REPLACED_BY_PRIVATE_PART
		|	ÛWCReplacedByVisiblePartİ of REPLACED_BY_VISIBLE_PART
		|	ÛWCReplacedByDeclİ of REPLACED_BY_DECL
		|	ÛWCRefinedByİ of REFINED_BY
		|	ÛWCReplacedByİ of REPLACED_BY;
=DESCRIBE
=ENDDOC

\section{EPILOGUE}

=SML
end (* local ... in *);
end (* of signature CNTypes *);
=TEX

\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



