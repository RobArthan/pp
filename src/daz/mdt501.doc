% mdt501.doc    %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}    %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests: Compliance Notation Lexical Analyser}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT501}    %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}    %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}            %% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{A.C.~Hayward & WIN01}  %% Mandatory field
%\TPPauthors{D.J.~King & WIN01\\A.C.~Hayward & WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{This document comprises test cases for testing the DAZ Compliance Notation Lexical Analyser as described in the document ISS/HAT/DAZ/DTD501.}

%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ A.C. Hayward\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1 \FormatDate{94/07/19}] Initial draft.

\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises test cases and test code/data for testing the DAZ Compliance Notation Lexical Analyser as specified in \cite{ISS/HAT/DAZ/DTD501}.

\subsection{Introduction}

\subsubsection{Background and Purpose}

This document is intended to supply module tests for the DAZ Compliance Notation Lexical Analyser as defined in \cite{ISS/HAT/DAZ/DTD501} and implemented in \cite{ISS/HAT/DAZ/IMP501}. The tests are intended to meet the requirements for tests identified in the quality plan \cite{ISS/HAT/DAZ/PLN003}.

\subsubsection{Dependencies}

These tests depend on the test harness as implemented in DS/FMU/IED/IMP013, and its corresponding detailed design document, DS/FMU/IED/DTD013.

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

There are no known deficiencies.

\section{INITIALISATION}
First we need to load the test harness and initialise it.

=SML
use_file "dtd013";
use_file "imp013";
init_mt_results();
=TEX

\section{PREAMBLE}
Set up the theory database as necessary.

=SML
open_theory "z_library";
force_delete_theory "mdt501" handle (_) => ();
new_theory "mdt501";
=TEX

\section{THE TESTS}

\subsection{CaseIndependence}

This is a signature of a structure containing a number of utilities for use in implementng support for languages where identifiers are case independent.

=SML
open CaseIndependence;
=TEX

The functions $to\_upper$ and $to\_lower$ convert their string arguments to strings with all the characters converted to their upper or lower case equi    valences respectively.

=SML
store_mt_results mt_run [
    ("to_upper.1", to_upper, "", ""),
    ("to_upper.2", to_upper, "a", "A"),
    ("to_upper.3", to_upper, "A", "A"),
    ("to_upper.4", to_upper, "abcdefghIJKLMNOP", "ABCDEFGHIJKLMNOP"),
    ("to_upper.5", to_upper, "0123456789!@#$^&()", "0123456789!@#$^&()")];
store_mt_results mt_run [
    ("to_lower.1", to_lower, "", ""),
    ("to_lower.2", to_lower, "A", "a"),
    ("to_lower.3", to_lower, "a", "a"),
    ("to_lower.4", to_lower, "abcdefghIJKLMNOP", "abcdefghijklmnop"),
    ("to_lower.5", to_lower, "0123456789!@#$^&()", "0123456789!@#$^&()")];
=TEX

\subsection{CNLex}

This is the signature for the structure containing the lexical analyser for SPARK.

=SML
open  Lex ZLex CNLex CNTypes;
=TEX

The following function looks at the label in a web clause (if there is one). The label determines the kind of web clause entered. This classification function is called from within the lexical analyser, and it is necessary for it to be called prior to the parser since the parser recognises a language in which the distinction between the kinds of web clause is made in the parser's input.

=SML
fun Ûclassify_labelÝ (itemlist : CN_LEX_ITEM list) : CN_LEX_ITEM list = (
    case itemlist
    of (LCOrd, _)::(LCNumericLiteral, CNText ntxt)::(LCCrd, _)::rest =>
    (
        (
            (
                case nat_of_string ntxt
                of 1 => LCCompLabel
                |  2 => LCPPartLabel
                |  3 => LCVPartLabel
                |  4 => LCDecLabel
                |  5 => LCStmtLabel
                |  6 => LCSpecLabel
                |  _ => LCCompLabel
            ),
            CNText ("("^ntxt^")")
        )::rest
    )
    |  _ => itemlist
);
=TEX

Set up the Compliance Notation Reader Writer.  This reads the input and then passes it through the Lexical Analyser.

=SML
fun Ûcn_recogniserÝ
    (start:string, lang:string,    value:Lex.INPUT list, finish:string) = (
    if ReaderWriterSupport.PrettyNames.is_same_symbol(start, "¹")
        andalso ReaderWriterSupport.PrettyNames.is_same_symbol(finish, "°")
        andalso (lang = "CN")
    then
        CNLex.cn_lex classify_label    value
    else
        fail "cn_recogniser" 504010
            [fn () => start, fn () => lang, fn () => finish]
);
=TEX

This next function tests for equality of Compliance Notation Lexical tokens.

=SML
fun cn_token_eq ((x : CN_LEX_ITEM list), (y : CN_LEX_ITEM list)) =
    PolyML.makestring x = PolyML.makestring y;
=TEX

For the module test for the lexical analyser we check that all of the parts of the datatype $CN\_LEX\_CLASS$ can be generated and are correctly generated.

LCEos is generated by code in a later document, so we don't test it here.

=SML
local
    val t0 = ¹CN abs °
    val t1 = ¹CN & °
    val t2 = ¹CN and °
    val t3 = ¹CN array °
    val t4 = ¹CN at °
    val t5 = ¹CN | °
    val t6 = ¹CN body °
    val t7 = ¹CN := °
    val t8 = ¹CN begin °
    val t9 = ¹CN case °
    val a0 = [(LCAbs, CNText "abs")] : CN_LEX_ITEM list;
    val a1 = [(LCAmpersand, CNText "&")] : CN_LEX_ITEM list;
    val a2 = [(LCAnd, CNText "and")] : CN_LEX_ITEM list;
    val a3 = [(LCArray, CNText "array")] : CN_LEX_ITEM list;
    val a4 = [(LCAt, CNText "at")] : CN_LEX_ITEM list;
    val a5 = [(LCBar, CNText "|")] : CN_LEX_ITEM list;
    val a6 = [(LCBBody, CNText "body")] : CN_LEX_ITEM list;
    val a7 = [(LCBecomes, CNText ":=")] : CN_LEX_ITEM list;
    val a8 = [(LCBegin, CNText "begin")] : CN_LEX_ITEM list;
    val a9 = [(LCCase, CNText "case")] : CN_LEX_ITEM list;
in
    val _ = store_mt_results (mt_runf cn_token_eq) [
     ("cn_lex.0", (fn x => x), t0, a0),
     ("cn_lex.1", (fn x => x), t1, a1),
     ("cn_lex.2", (fn x => x), t2, a2),
     ("cn_lex.3", (fn x => x), t3, a3),
     ("cn_lex.4", (fn x => x), t4, a4),
     ("cn_lex.5", (fn x => x), t5, a5),
     ("cn_lex.6", (fn x => x), t6, a6),
     ("cn_lex.7", (fn x => x), t7, a7),
     ("cn_lex.8", (fn x => x), t8, a8),
     ("cn_lex.9", (fn x => x), t9, a9)];
end;
=TEX

=SML
local
    val t0 = ¹CN 'a' °
    val t1 = ¹CN : °
    val t2 = ¹CN , °
    val t3 = ¹CN (1) °
    val t4 = ¹CN constant °
    val t5 = ¹CN con °
    val t6 = ¹CN ) °
    val t7 = ¹CN (4) °
    val t8 = ¹CN delta °
    val t9 = ¹CN digits °
    val a0 = [(LCCharacterLiteral, CNString "a")] : CN_LEX_ITEM list;
    val a1 = [(LCColon, CNText ":")] : CN_LEX_ITEM list;
    val a2 = [(LCComma, CNText ",")] : CN_LEX_ITEM list;
    val a3 = [(LCCompLabel, CNText "(1)")] : CN_LEX_ITEM list;
    val a4 = [(LCConstant, CNText "constant")] : CN_LEX_ITEM list;
    val a5 = [(LCCon, CNText "con"), (LCZ, CNZ [ZTEos])] : CN_LEX_ITEM list;
    val a6 = [(LCCrd, CNText ")")] : CN_LEX_ITEM list;
    val a7 = [(LCDecLabel, CNText "(4)")] : CN_LEX_ITEM list;
    val a8 = [(LCDelta, CNText "delta")] : CN_LEX_ITEM list;
    val a9 = [(LCDigits, CNText "digits")] : CN_LEX_ITEM list;
in
    val _ = store_mt_results (mt_runf cn_token_eq) [
     ("cn_lex.10", (fn x => x), t0, a0),
     ("cn_lex.11", (fn x => x), t1, a1),
     ("cn_lex.12", (fn x => x), t2, a2),
     ("cn_lex.13", (fn x => x), t3, a3),
     ("cn_lex.14", (fn x => x), t4, a4),
     ("cn_lex.15", (fn x => x), t5, a5),
     ("cn_lex.16", (fn x => x), t6, a6),
     ("cn_lex.17", (fn x => x), t7, a7),
     ("cn_lex.18", (fn x => x), t8, a8),
     ("cn_lex.19", (fn x => x), t9, a9)];
end;
=TEX

=SML
local
    val t0 = ¹CN / °
    val t1 = ¹CN .. °
    val t2 = ¹CN . °
    val t3 = ¹CN else °
    val t4 = ¹CN elsif °
    val t5 = ¹CN end °
    val t6 = ¹CN = °
    val t7 = ¹CN exit °
    val t8 = ¹CN · °
    val t9 = ¹CN for °
    val a0 = [(LCDiv, CNText "/")] : CN_LEX_ITEM list;
    val a1 = [(LCDotDot, CNText "..")] : CN_LEX_ITEM list;
    val a2 = [(LCDot, CNText ".")] : CN_LEX_ITEM list;
    val a3 = [(LCElse, CNText "else")] : CN_LEX_ITEM list;
    val a4 = [(LCElsIf, CNText "elsif")] : CN_LEX_ITEM list;
    val a5 = [(LCEnd, CNText "end")] : CN_LEX_ITEM list;
    val a6 = [(LCEquals, CNText "=")] : CN_LEX_ITEM list;
    val a7 = [(LCExit, CNText "exit")] : CN_LEX_ITEM list;
    val a8 = [(LCFatDot, CNText "·")] : CN_LEX_ITEM list;
    val a9 = [(LCFor, CNText "for")] : CN_LEX_ITEM list;
in
    val _ = store_mt_results (mt_runf cn_token_eq) [
     ("cn_lex.20", (fn x => x), t0, a0),
     ("cn_lex.21", (fn x => x), t1, a1),
     ("cn_lex.22", (fn x => x), t2, a2),
     ("cn_lex.23", (fn x => x), t3, a3),
     ("cn_lex.24", (fn x => x), t4, a4),
     ("cn_lex.25", (fn x => x), t5, a5),
     ("cn_lex.26", (fn x => x), t6, a6),
     ("cn_lex.27", (fn x => x), t7, a7),
     ("cn_lex.28", (fn x => x), t8, a8),
     ("cn_lex.29", (fn x => x), t9, a9)];
end;
=TEX

=SML
local
    val t0 = ¹CN function °
    val t1 = ¹CN => °
    val t2 = ¹CN >= °
    val t3 = ¹CN > °
    val t4 = ¹CN banana °
    val t5 = ¹CN if °
    val t6 = ¹CN in °
    val t7 = ¹CN is °
    val t8 = ¹CN §apple¢ °
    val t9 = ¹CN <= °
    val a0 = [(LCFunction, CNText "function")] : CN_LEX_ITEM list;
    val a1 = [(LCGoesTo, CNText "=>")] : CN_LEX_ITEM list;
    val a2 = [(LCGreaterEquals, CNText ">=")] : CN_LEX_ITEM list;
    val a3 = [(LCGreaterThan, CNText ">")] : CN_LEX_ITEM list;
    val a4 = [(LCIdentifier, CNText "banana")] : CN_LEX_ITEM list;
    val a5 = [(LCIf, CNText "if")] : CN_LEX_ITEM list;
    val a6 = [(LCIn, CNText "in")] : CN_LEX_ITEM list;
    val a7 = [(LCIs, CNText "is")] : CN_LEX_ITEM list;
    val a8 = [(LCLChevron, CNText "§"), (LCKSlot, CNKSlot [Text "apple"]),
   (LCRChevron, CNText "¢")] : CN_LEX_ITEM list;
    val a9 = [(LCLessEquals, CNText "<=")] : CN_LEX_ITEM list;
in
    val _ = store_mt_results (mt_runf cn_token_eq) [
     ("cn_lex.30", (fn x => x), t0, a0),
     ("cn_lex.31", (fn x => x), t1, a1),
     ("cn_lex.32", (fn x => x), t2, a2),
     ("cn_lex.33", (fn x => x), t3, a3),
     ("cn_lex.34", (fn x => x), t4, a4),
     ("cn_lex.35", (fn x => x), t5, a5),
     ("cn_lex.36", (fn x => x), t6, a6),
     ("cn_lex.37", (fn x => x), t7, a7),
     ("cn_lex.38", (fn x => x), t8, a8),
     ("cn_lex.39", (fn x => x), t9, a9)];
end;
=TEX

=SML
local
    val t0 = ¹CN <> °
    val t1 = ¹CN <  °
    val t2 = ¹CN limited °
    val t3 = ¹CN loop °
    val t4 = ¹CN - °
    val t5 = ¹CN mod °
    val t6 = ¹CN /= °
    val t7 = ¹CN not °
    val t8 = ¹CN null °
    val t9 = ¹CN 4 °
    val a0 = [(LCLessGreat, CNText "<>")] : CN_LEX_ITEM list;
    val a1 = [(LCLessThan, CNText "<")] : CN_LEX_ITEM list;
    val a2 = [(LCLimited, CNText "limited")] : CN_LEX_ITEM list;
    val a3 = [(LCLoop, CNText "loop")] : CN_LEX_ITEM list;
    val a4 = [(LCMinus, CNText "-")] : CN_LEX_ITEM list;
    val a5 = [(LCMod, CNText "mod")] : CN_LEX_ITEM list;
    val a6 = [(LCNotEquals, CNText "/=")] : CN_LEX_ITEM list;
    val a7 = [(LCNot, CNText "not")] : CN_LEX_ITEM list;
    val a8 = [(LCNull, CNText "null")] : CN_LEX_ITEM list;
    val a9 = [(LCNumericLiteral, CNText "4")] : CN_LEX_ITEM list;
in
    val _ = store_mt_results (mt_runf cn_token_eq) [
     ("cn_lex.40", (fn x => x), t0, a0),
     ("cn_lex.41", (fn x => x), t1, a1),
     ("cn_lex.42", (fn x => x), t2, a2),
     ("cn_lex.43", (fn x => x), t3, a3),
     ("cn_lex.44", (fn x => x), t4, a4),
     ("cn_lex.45", (fn x => x), t5, a5),
     ("cn_lex.46", (fn x => x), t6, a6),
     ("cn_lex.47", (fn x => x), t7, a7),
     ("cn_lex.48", (fn x => x), t8, a8),
     ("cn_lex.49", (fn x => x), t9, a9)];
end;
=TEX

=SML
local
    val t0 = ¹CN of °
    val t1 = ¹CN ( °
    val t2 = ¹CN or °
    val t3 = ¹CN others °
    val t4 = ¹CN out °
    val t5 = ¹CN package °
    val t6 = ¹CN + °
    val t7 = ¹CN (2) °
    val t8 = ¹CN ' °
    val t9 = ¹CN 'world °
    val a0 = [(LCOf, CNText "of")] : CN_LEX_ITEM list;
    val a1 = [(LCOrd, CNText "(")] : CN_LEX_ITEM list;
    val a2 = [(LCOr, CNText "or")] : CN_LEX_ITEM list;
    val a3 = [(LCOthers, CNText "others")] : CN_LEX_ITEM list;
    val a4 = [(LCOut, CNText "out")] : CN_LEX_ITEM list;
    val a5 = [(LCPackage, CNText "package")] : CN_LEX_ITEM list;
    val a6 = [(LCPlus, CNText "+")] : CN_LEX_ITEM list;
    val a7 = [(LCPPartLabel, CNText "(2)")] : CN_LEX_ITEM list;
    val a8 = [(LCPrime, CNText "'")] : CN_LEX_ITEM list;
    val a9 = [(LCPrimedIdentifier, CNText "'world")] : CN_LEX_ITEM list;
in
    val _ = store_mt_results (mt_runf cn_token_eq) [
     ("cn_lex.50", (fn x => x), t0, a0),
     ("cn_lex.51", (fn x => x), t1, a1),
     ("cn_lex.52", (fn x => x), t2, a2),
     ("cn_lex.53", (fn x => x), t3, a3),
     ("cn_lex.54", (fn x => x), t4, a4),
     ("cn_lex.55", (fn x => x), t5, a5),
     ("cn_lex.56", (fn x => x), t6, a6),
     ("cn_lex.57", (fn x => x), t7, a7),
     ("cn_lex.58", (fn x => x), t8, a8),
     ("cn_lex.59", (fn x => x), t9, a9)];
end;
=TEX

=SML
local
    val t0 = ¹CN private °
    val t1 = ¹CN procedure °
    val t2 = ¹CN record °
    val t3 = ¹CN Ã °
    val t4 = ¹CN rem °
    val t5 = ¹CN renames °
    val t6 = ¹CN é °
    val t7 = ¹CN return °
    val t8 = ¹CN reverse °
    val t9 = ¹CN range °
    val a0 = [(LCPrivate, CNText "private")] : CN_LEX_ITEM list;
    val a1 = [(LCProcedure, CNText "procedure")] : CN_LEX_ITEM list;
    val a2 = [(LCRecord, CNText "record")] : CN_LEX_ITEM list;
    val a3 = [(LCRefinedBy, CNText "Ã")] : CN_LEX_ITEM list;
    val a4 = [(LCRem, CNText "rem")] : CN_LEX_ITEM list;
    val a5 = [(LCRenames, CNText "renames")] : CN_LEX_ITEM list;
    val a6 = [(LCReplacedBy, CNText "é")] : CN_LEX_ITEM list;
    val a7 = [(LCReturn, CNText "return")] : CN_LEX_ITEM list;
    val a8 = [(LCReverse, CNText "reverse")] : CN_LEX_ITEM list;
    val a9 = [(LCRRange, CNText "range")] : CN_LEX_ITEM list;
in
     val _ = store_mt_results (mt_runf cn_token_eq) [
     ("cn_lex.60", (fn x => x), t0, a0),
     ("cn_lex.61", (fn x => x), t1, a1),
     ("cn_lex.62", (fn x => x), t2, a2),
     ("cn_lex.63", (fn x => x), t3, a3),
     ("cn_lex.64", (fn x => x), t4, a4),
     ("cn_lex.65", (fn x => x), t5, a5),
     ("cn_lex.66", (fn x => x), t6, a6),
     ("cn_lex.67", (fn x => x), t7, a7),
     ("cn_lex.68", (fn x => x), t8, a8),
     ("cn_lex.69", (fn x => x), t9, a9)];
end;
=TEX

=SML
local
    val t0 = ¹CN ; °
    val t1 = ¹CN separate °
    val t2 = ¹CN (6) °
    val t3 = ¹CN ** °
    val t4 = ¹CN * °
    val t5 = ¹CN (5) °
    val t6 = ¹CN "Hello, world" °
    val t7 = ¹CN subtype °
    val t8 = ¹CN then °
    val t9 = ¹CN till °
    val a0 = [(LCSemi, CNText ";")] : CN_LEX_ITEM list;
    val a1 = [(LCSeparate, CNText "separate")] : CN_LEX_ITEM list;
    val a2 = [(LCSpecLabel, CNText "(6)")] : CN_LEX_ITEM list;
    val a3 = [(LCStarStar, CNText "**")] : CN_LEX_ITEM list;
    val a4 = [(LCStar, CNText "*")] : CN_LEX_ITEM list;
    val a5 = [(LCStmtLabel, CNText "(5)")] : CN_LEX_ITEM list;
    val a6 = [(LCStringLiteral, CNString "Hello, world")] : CN_LEX_ITEM list;
    val a7 = [(LCSubType, CNText "subtype")] : CN_LEX_ITEM list;
    val a8 = [(LCThen, CNText "then")] : CN_LEX_ITEM list;
    val a9 = [(LCTill, CNText "till")] : CN_LEX_ITEM list;
in
    val _ = store_mt_results (mt_runf cn_token_eq) [
     ("cn_lex.70", (fn x => x), t0, a0),
     ("cn_lex.71", (fn x => x), t1, a1),
     ("cn_lex.72", (fn x => x), t2, a2),
     ("cn_lex.73", (fn x => x), t3, a3),
     ("cn_lex.74", (fn x => x), t4, a4),
     ("cn_lex.75", (fn x => x), t5, a5),
     ("cn_lex.76", (fn x => x), t6, a6),
     ("cn_lex.77", (fn x => x), t7, a7),
     ("cn_lex.78", (fn x => x), t8, a8),
     ("cn_lex.79", (fn x => x), t9, a9)];
end;
=TEX

=SML
local
    val t0 = ¹CN type °
    val t1 = ¹CN use °
    val t2 = ¹CN (3) °
    val t3 = ¹CN when °
    val t4 = ¹CN while °
    val t5 = ¹CN with °
    val t6 = ¹CN xor °
    val t7 = ¹CN  true °
    val t8 = ¹CN [ °
    val t9 = ¹CN ] °
    val a0 = [(LCType, CNText "type")] : CN_LEX_ITEM list;
    val a1 = [(LCUse, CNText "use")] : CN_LEX_ITEM list;
    val a2 = [(LCVPartLabel, CNText "(3)")] : CN_LEX_ITEM list;
    val a3 = [(LCWhen, CNText "when")] : CN_LEX_ITEM list;
    val a4 = [(LCWhile, CNText "while")] : CN_LEX_ITEM list;
    val a5 = [(LCWith, CNText "with")] : CN_LEX_ITEM list;
    val a6 = [(LCXor, CNText "xor")] : CN_LEX_ITEM list;
    val a7 = [(LCGrkDelta, CNText ""), (LCZ, CNZ [ZTId "true", ZTEos])] : CN_LEX_ITEM list;
    val a8 = [(LCLSqBrack, CNText "[")] : CN_LEX_ITEM list;
    val a9 = [(LCRSqBrack, CNText "[")] : CN_LEX_ITEM list;
in
    val _ = store_mt_results (mt_runf cn_token_eq) [
     ("cn_lex.80", (fn x => x), t0, a0),
     ("cn_lex.81", (fn x => x), t1, a1),
     ("cn_lex.82", (fn x => x), t2, a2),
     ("cn_lex.83", (fn x => x), t3, a3),
     ("cn_lex.84", (fn x => x), t4, a4),
     ("cn_lex.85", (fn x => x), t5, a5),
     ("cn_lex.86", (fn x => x), t6, a6),
     ("cn_lex.87", (fn x => x), t7, a7),
     ("cn_lex.88", (fn x => x), t8, a8),
     ("cn_lex.89", (fn x => x), t9, a9)];
end;
=TEX

=SML
local
    val t0 = ¹CN { °
    val t1 = ¹CN } °
    val t2 = ¹CN û °
    val t3 = ¹CN ý °
    val t4 = ¹CN § °
    val t5 = ¹CN ¢ °
    val a0 = [(LCLBrace, CNText "{")] : CN_LEX_ITEM list;
    val a1 = [(LCRBrace, CNText "}")] : CN_LEX_ITEM list;
    val a2 = [(LCLStrachey, CNText "û"), (LCZ, CNZ [ZTEos])] : CN_LEX_ITEM list;
    val a3 = [(LCRStrachey, CNText "ý")] : CN_LEX_ITEM list;
    val a4 = [(LCLChevron, CNText "§"), (LCKSlot, CNKSlot [Text ""])] : CN_LEX_ITEM list;
    val a5 = [(LCRChevron, CNText "¢")] : CN_LEX_ITEM list;
in
    val _ = store_mt_results (mt_runf cn_token_eq) [
     ("cn_lex.90", (fn x => x), t0, a0),
     ("cn_lex.91", (fn x => x), t1, a1),
     ("cn_lex.92", (fn x => x), t2, a2),
     ("cn_lex.93", (fn x => x), t3, a3),
     ("cn_lex.94", (fn x => x), t4, a4),
     ("cn_lex.95", (fn x => x), t5, a5)];
end;
=TEX

\section{SUMMARY OF RESULTS}

=SML
diag_line "++++ Results for module test : mdt501.doc";
diag_line(summarize_mt_results());
=TEX

\end{document}

=IGNORE
fun cn_recogniser
    (start:string, lang:string, value:Lex.INPUT list, finish:string) = (
    if ReaderWriterSupport.PrettyNames.is_same_symbol(start, "¹")
        andalso ReaderWriterSupport.PrettyNames.is_same_symbol(finish, "°")
        andalso (lang = "CN")
    then
        value
    else
        fail "cn_recogniser" 504010
            [fn () => start, fn () => lang, fn () => finish]
);
