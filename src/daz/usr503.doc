% %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[11pt,hol1,fleqn,USR,epsf]{book}
% change depth of section numbering
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{3}
% temporary measure while waiting for LaTeXe to come along
\def\LaTeXe{\LaTeX$2_{\varepsilon}$}
\def\Hide#1{}
% Set the following macros as necessary as release
% numbers change.
\def\texrelease{\TeX\ version 3.1415}
\def\latexrelease{\LaTeXe}
\def\arch{sun4}
\def\solarisrelease{Solaris 2.3}
\def\motifrelease{Motif 1.2}
\def\polyrelease{Poly/ML 2.07MX}
\def\quicktexloc{{\tt /QLaTeX}} % NB one location needs this hard wired in
\def\daztool{Compliance Tool}
% just useful macros
\def\ltm{$^{\rm TM}$}
\def\Note#1{{\small\bf[ #1 ]}}
=IGN
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Proving VCs Using the Compliance Tool}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/USR503}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{Compliance Notation}
\TPPauthor{G.M.~Prout & HAT Team\\R.D.~Arthan & HAT Team}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & Project Manager}
\TPPabstract{
This document is a Tutorial Guide for the Compliance Tool Proof Facilities.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
\begin{tabular}[t]{lr}
A. Smith & DRA\\
Library & WIN01\\
\end{tabular}}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
\def\Hide#1{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadcentre{}
%\def\TPPheadcentreproject{}
%\def\TPPheadrhs{}
\let\TPPfootlhs=\TPPfootrhs
\def\TPPfootcentre{$\vcenter{\halign{\hfil\strut##\hfil\cr
COPYRIGHT  \copyright\ ICL 1994\cr}}$}
=TEX
\ftlmargin 0.0in
\ftrmargin 0.0in

\def\SCCSversion{$Revision$%
}
\def\SCCSdate{\FormatDate{$Date$%
}}

\USRmanual{Proving VCs Using the Compliance Tool}
\USRref{USR503}

\raggedbottom
\ftlinepenalty=9999
\makeindex

\begin{document}
\makeUSRfrontpage

\underscoreoff

\chapter*{CONTENTS}

\tableofcontents
%\listoffigures

\pagebreak

\setcounter{chapter}{-1}

\chapter{ABOUT THIS PUBLICATION} \label{intro}
\section{Purpose}

This document gives guidance on the use of the Compliance Tool proof facilities supplied with {\Product}.

\section{Readership}
This document is intended to be read by users of the Compliance Tool who  wish  to  produce machine-checked proofs of some or all of the VCs generated by the tool. These users are expected to have experience of using {\Product} for proofs in Z; in particular they should be familiar with the material in the \ZTUTORIAL.

\section{Related Publications}

A bibliography is given towards the end of this document.

\begin{itemize}

\item
The Compliance Tool User Guide can be found in :

{\em Using the Compliance Tool} \cite{ISS/HAT/DAZ/USR501}.

\item
An overview of the  Compliance notation can be found in the DRA document:

{\em A commentary on the Specification of the Compliance Notation for SPARK and Z} \cite{DRA/CIS.SE2/PROJ/SWI/TR/1/1.0}.

\item
A description of \Product{} may be found in:

{\em \ {\SOFTSERV}},

which also contains a full list of other \Product{} documentation, in particular the \ZTUTORIAL.

\end{itemize}

\section{Area Covered}

The user will have already undertaken the following tasks:
\begin{enumerate}
\item
Installed the Compliance Tool on his workstation, by following the procedure described in {\em Compliance Tool Installation and Operation} \cite{ISS/HAT/DAZ/USR502}
\item
Loaded a Compliance Notation script into the tool and generated the Z document from the script, by following the procedure described in {\em Using the Compliance Tool} \cite{ISS/HAT/DAZ/USR501}
\end{enumerate}

This tutorial  should then assist the user in working with the VCs, i.e. attempting to prove them, using {\Product} and Compliance Tool facilities. 
A
Compliance Notation example concerning the computational aspects of a simple calculator is included in this tutorial, see chapter \ref{CALCEX}. Proofs
are provided for some of the VCs generated by this example  to illustrate 
the techniques advocated in chapter \ref{VCPRFS}.
\section{Prerequisites}

This Tutorial is designed to assist a Compliance Tool user in the production of machine-checked proofs of the VCs generated by the tool. It is {\em not} intended to be an introduction to the Z language, or to the Compliance Notation, or indeed to the Compliance Tool itself.

Familiarity with Compliance Notation as specified in \cite{DRA/CIS/CSE3/TR/94/27/2.1} is very desirable, although not essential since VC proofs may be conducted independently without prior knowledge of the specification from which the VCs have been generated. Familiarity with the Compliance Tool and with the use of {\Product} for proofs in Z is essential. It is assumed that a user intent on using the Compliance Tool for proving VCs  will  be familiar with the material in both the  \ZTUTORIAL\ and {\em The Compliance Tool User Guide}, \cite{ISS/HAT/DAZ/USR501}.


A tool-independent description of the Compliance Notation is given in \cite{DRA/CIS.SE2/PROJ/SWI/TR/1/1.0}. {\em The Compliance Tool User Guide}, \cite{ISS/HAT/DAZ/USR501}, gives an introduction to the use of the Compliance Tool for loading a Compliance Notation Script and generating the Z document which contains the VCs.
The \ZTUTORIAL, gives an introduction to the use of {\Product} for specification and proof in Z. 

The {\Product} user documentation is supplied as part of the {\Product} release  included with the Compliance Tool and is available for on-line reference. 

The user interface to the tool described in this document is a Motif application  running under the X Windows System.
Users who are unfamiliar with X or Motif should consult local or supplier's documentation or expertise for further guidance (e.g. see \cite{sun92a}).



\section{Acknowledgements}
=IGN
The below are taken from Motif 1.2 Users Guide, July 1993
=TEX
Sun Microsystems is a registered trademark of Sun Microsystems Inc.  Sun-3, OpenWindows, Sun-4, SPARCstation, SunOS and Solaris are trademarks of Sun Microsystems Inc.

Motif is a registered trademark of the Open Software Foundation, Inc.

UNIX is a registered trademark of UNIX System Laboratories, Inc.

Poly/ML is an implementation of Standard ML with a few non-standard extensions.  Poly/ML, and its documentation, is copyright Abstract Hardware Limited.  

\TeX{} is copyright the American Mathematical Society and by Donald E. Knuth.
The \LaTeXe\ distribution tape is copyright the \LaTeX\ 3 project and its individual authors.

The X Windows System is a trademark of the Massachusetts Institute of Technology.
\chapter{INTRODUCTION}



=TEX
\chapter{REVIEW OF PROOF IN Z}\label{ZPROOF}
\Hide{%
=SML
open_theory"cn";
set_pc"z_library1";
force_delete_theory"usr503" handle Fail _ => ();
new_script {name="usr503", state=initial_cn_state};
=TEX
}
This chapter provides an overview of the material in the \ZTUTORIAL\ which describes how to use {\ProductZ} for doing proofs. It is assumed, in particular,
 that you know:
\begin{itemize}
\item
how to do backwards proofs, using $set_goal$
\item
about $pop_thm$ and $save_pop_thm$
\item
about proof contexts for providing context sensitive facilities. The following have been used in the examples:

\begin{tabular}{p{2in}l l}
&$set_pc$, $push_pc$, $pop_pc$\\
&$z_library1$\\
&$z_lin_arith$\\
&$z_predicates$\\
\end{tabular}

The example proofs in this chapter are all conducted in the proof
context $z_library1$. 
\item
about $tactics$ and $tacticals$, etc. The following have been used in the examples:

\begin{tabular}{p{2in}l l}
tactics:&\\ 
&$strip_tac$,$z_µ_tac$\\
&$asm_rewrite_tac$\\
&$lemma_tac$,$cases_tac$\\
&$z_spec_asm_tac$\\
&$ante_tac$,$discard_tac$\\
&$fc_tac$, $all_fc_tac$, $asm_fc_tac$, $all_asm_fc_tac$\\
&$eq_sym_asm_tac$, $eq_sym_nth_asm_tac$\\
&$var_elim_asm_tac$, $var_elim_nth_asm_tac$\\
&$all_var_elim_asm_tac$, $all_var_elim_asm_tac1$\\
&$z_app_eq_tac$\\
&$z_º_induction_tac$\\
\end{tabular}

\begin{tabular}{p{2in}l l}
tacticals:&\\
&$REPEAT$\\
&$ALL_FC_T$, $ALL_FC_T1$\\
&$¥_T$\\
&$THEN$, $THEN1$\\
&$REPEAT_TTCL$\\
&$±_THEN$\\
&$PC_T1$\\
&$LEMMA_T$\\
&$DROP_NTH_ASM_T$,$LIST_DROP_NTH_ASM_T$
\end{tabular}

\begin{tabular}{p{2in}l l}
canonicalisation functions:&\\
&$fc_§_canon$\\
\end{tabular}

\item
about forward inference: $rewrite_rule$ and $±_right_elim$ have been used
 in the examples
\item
how to access the specification with $z_get_spec$
\end{itemize}

You will find detailed information on all the above in the \REFERENCE.

A full account of using {\ProductZ} for proofs may be found in  the  \ZTUTORIAL,
which, in turn, refers to the \HTUTORIAL. There are some topics, for 
example linear arithmetic, which are fully covered in \HTUTORIAL\ but
to which no special importance is given in the \ZTUTORIAL. This is because
there is nothing extra to add about working in Z as opposed to HOL.
While it is assumed that you are  familiar with the material presented in these
tutorials, for convenience, a summary of the main methods advocated for dealing with Z proofs is given here. One way of revising the material in 
this chapter would be to read and try out the examples as
you go along. You may
also find it instructive to attempt the Z exercises from chapter 7 
of the \ZTUTORIAL, the solutions to which are in 
 chapter 8
of that tutorial. 

The revision material is divided into the following sections:
\begin{itemize}
\item[\ref {TWOTACTIC}] Proof by the ``two tactic'' method.
\item[\ref {STRIP}] Stripping.
\item[\ref {AUTOMATIC}] Automatic Proof.
\item[\ref {FORWARD}] Forward Chaining.
\item[\ref {EQUATIONS}] Predicate Calculus with Equality.
\item[\ref {REWRITE}] Rewriting.
\item[\ref {FUNCTIONS}] Function Application.
\item[\ref {LEMMAS}] Proving Lemmas ``on the fly''.
\item[\ref {CASES}] Case Analysis.
\item[\ref {INDUCTION}] Induction.
\end{itemize}



\section{The Two Tactic Method}\label{TWOTACTIC}

This method is given a high priority in the \ZTUTORIAL, although more for
pedagogical reasons than because it is a particularly natural way to tackle a proof. Proof by stripping, see section \ref{STRIP}, is effective in discharging a goal only where the reasoning is mainly propositional.
Where the proof will depend either on appropriate specialisation of universally quantified assumptions, or on the choice of a suitable witness for proving an existential conclusion, stripping will not suffice.

The two tactic method injects into the proof process based on stripping, user directed specialisation of universal assumptions.
In the context of a proof by contradiction (in which existential conclusions will not arise) this is sufficient to discharge any goals which are reduced to reasoning in the  first order predicate calculus.
The method is  sometimes unnatural because it destroys much
of the logical structure of the
original goal.  Schematically the method is:
=GFT SML
set_goal([],conjecture);
a contr_tac; 						(* once suffices *)
a (z_spec_asm_tac Ò assumption Æ Ò valueÆ);	(* as many times as necessary *)
=TEX
The choice of universal assumptions and of the values to specialise them to depends on the user identifying one or more specialisations which will result in the derivation of a contradiction from the assumptions. 
For example, this method transforms a goal with an existentially quantified
conclusion into one with a universally quantified assumption:
=SML
set_goal([],Ò[X](µx,y:X ∑(∂x:X ∑ x = y))Æ);
a contr_tac; 						
a (z_spec_asm_tac Ò µ x : X ∑ ≥ x = y Æ ÒyÆ);	
pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX



\section{Stripping}\label{STRIP}
This method is complete for propositional logic. The tactic $strip_tac$ performs a variety of simplifications, and is often usefully applied at the outset of  embarking on a proof.  The simplifications achieved by
=INLINEFT
strip_tac
=TEX
{} include the following:
\begin{itemize}
\item moving the antecedent of an implication from the conclusion to the assumptions of the goal
\item proving tautologies
\item removing leading universal quantifiers
\item using, where possible, relevant assumptions in the assumption-list.
\end{itemize}
This is often a more natural way to start a proof because it retains
some of the structure of the original goal. For example, the proof above in section \ref{TWOTACTIC} could have been achieved
by stripping  then applying  $z_∂_tac$ with a suitable witness then stripping
the trivial result:

=SML
set_goal([],Ò[X](µx,y:X ∑(∂x:X ∑ x = y))Æ);
a(REPEAT strip_tac); 
a(z_∂_tacÒyÆ);						
a(REPEAT strip_tac); 
pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX

\section{Automatic Proof}\label{AUTOMATIC}


An automatic proof procedure, in the form of $prove_tac$, is provided for each proof context. In most proof contexts this is  capable of solving results which are
reducible to simple theorems of the predicate calculus.
Even when the application of $prove_tac$ fails to prove a goal, it may have resulted in more simplification than would be obtained by other methods. This
can, however, prove to be a mixed blessing and result in more effort being
required than necessary in order to achieve a proof. For example, the fourth
conjunct in the assumption part of the the following goal is irrelevant. An application of $prove_tac$ is unable to solve the goal, and the ``simplification'' 
that ensues involves splitting that conjunct, which produces two subgoals:
=SML
set_goal([],Ò(µx,y,z:˙ | x = 4 ± y = 2 ± z = x+y ± (x = y § x = z) ∑ z=6)Æ);
a(prove_tac[]);
=TEX
=GFT ProofPower output
Tactic produced 2 subgoals:

(* *** Goal "2" *** *)

(*  3 *)  Òy = 4Æ
(*  2 *)  Òy = 2Æ
(*  1 *)  Òy = y + yÆ

(* ?Ù *)  Òy = 6Æ

(* *** Goal "1" *** *)

(*  5 *)  Òx = 4Æ
(*  4 *)  Òy = 2Æ
(*  3 *)  Òz = x + yÆ
(*  2 *)  Ò≥ x = yÆ
(*  1 *)  Ò≥ x = zÆ

(* ?Ù *)  Òz = 6Æ

=TEX
Clearly, in this case, the extra work involved in proving the additional subgoal
is minimal, but  
a more complicated expression could give rise to many additonal subgoals 
and obscure what is really going on. For this goal, the following would 
preserve the irrelevant bi-implication and put it in the assumption list:
=SML
set_goal([],Ò(µx,y,z:˙ | x = 4 ± y = 2 ± z = x+y ± (x = y § x = z) ∑ z=6)Æ);
a(z_µ_tac THEN ¥_T (REPEAT_TTCL ±_THEN asm_tac));
=TEX
=GFT ProofPower output
Tactic produced 1 subgoal:

(* *** Goal "" *** *)

(*  5 *)  Ò{x, y, z} Ä ˙Æ
(*  4 *)  Òx = 4Æ
(*  3 *)  Òy = 2Æ
(*  2 *)  Òz = x + yÆ
(*  1 *)  Òx = y § x = zÆ

(* ?Ù *)  Òz = 6Æ
=TEX
This also serves as an example of using a mixture of tacticals to achieve exactly the
effect that you want, viz separating the left hand side of the implication
obtained by removing the universal quantifier (with $z_µ_tac$) into separate
conjuncts and putting them in the assumption list, without breaking up the conjuncts themselves.

Finally, rewriting with the assumptions, see section \ref{REWRITE}, will complete the proof:
=SML
a(asm_rewrite_tac[]);
pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX

\subsection{Linear Arithmetic Proof Context}
The proof context $z_lin_arith$ contains an automatic
proof procedure for linear arithmetic. This means terms built up from:
\begin{itemize}
\item
"Atoms" (numeric literals, variables of type ˙, etc.)
\item
Multiplication by numeric literals
\item
Addition
\item
$=,º,æ,<,>$
\item
Logical operators
\end{itemize}
So, for example, the following are all proved by an application of $prove_tac$ in the proof context $z_lin_arith$:
=SML
set_goal([],Ò(µx,y,z:˙ | x º y ± x + y < z + x ∑ x < z)Æ);
a(PC_T1"z_lin_arith"prove_tac[]);
pop_thm();
=TEX
=SML
set_goal([],Ò(µx,z:˙ | (∂ y:Z ∑ x æ y ± ≥ y < z )∑ x æ z)Æ);
a(PC_T1"z_lin_arith"prove_tac[]);
pop_thm();
=TEX
=SML
set_goal([],Ò(µx,y:˙ | x + 2*y < 2*x ∑ y + y < x)Æ);
a(PC_T1"z_lin_arith"prove_tac[]);
pop_thm();
=TEX
=SML
set_goal([],Ò(µx,y:˙ ∑ ≥ (2*x + y = 4 ± 4*x + 2*y = 7))Æ);
a(PC_T1"z_lin_arith"prove_tac[]);
pop_thm();
=TEX

\section{Forward Chaining} \label{FORWARD}

Forward chaining facilities often provide an easier way of achieving proofs requiring instantiation of universal assumptions.

$all_asm_fc_tac$ will attempt to instantiate universally quantified assumptions which are effectively implications to values which will enable forward inference to take place.
This is achieved by matching the antecedent of the implication against other assumptions.

Consider the example in section \ref{TWOTACTIC}. After the application of $contr_tac$, you can derive the required contradiction using $all_asm_fc_tac$
with less effort than having to specialise the universally quantified assumption:

=SML
set_goal([],Ò[X](µx,y:X ∑(∂x:X ∑ x = y))Æ);
a contr_tac; 	
a (all_asm_fc_tac[]);
pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX

If forward chaining fails to solve a goal,  it may  generate a lot of irrelevant new assumptions, and so it should be used judiciously.

A related tactic suitable for use with Z is $all_fc_tac$, which chains forward using implications derived from a list of theorems supplied as an argument, matching these against the assumptions, using the assumptions to match the antecedents of the implications.

$fc_tac$ and $asm_fc_tac$ are also useful (see \REFERENCE), but these are liable to introduce HOL universals, leaving a mixed language subgoal.

\section{Predicate Calculus with Equality}\label{EQUATIONS}

The above facilities primarily support reasoning in the  predicate calculus, and a proof using these facilities may fail by failing to exploit equations which could be used to complete the proof.

A variety of additional proof facilities are available to make use of equations.

\begin{enumerate}
\item $asm_rewrite_tac$

may be used to cause equations in the assumptions to rewrite the conclusion of a subgoal.
This may sometimes prove sufficient to complete a proof.

\item $eq_sym_asm_tac$ or $eq_sym_nth_asm_tac$

may be used to turn round an equation in an assumption which is the wrong way round to achieve the required rewrite.

\item
$var_elim_asm_tac$ or $var_elim_nth_asm_tac$

may be used to completely eliminate from the subgoal occurrences of a variable which appears on one side of an equation in the specified assumption.
This causes the conclusion and all the other assumptions to be rewritten with the equation, eliminating occurrences of it.
The assumption will then be discarded.
These tactics will work whichever way round the equation appears in the assumption.

\item $all_var_elim_asm_tac$, $all_var_elim_asm_tac1$

automatically eliminate from the assumptions all equations of a sufficiently simple kind, by rewriting every term in the subgoal with them and then discarding the equations.
They avoid eliminating equations where this might cause a looping rewrite.
The first variant only eliminates equations where both sides are either variables or constants, the second variant will eliminate any equation of which one side is a variable which does not appear on the other side.

\end{enumerate}


\section{Rewriting}\label{REWRITE}

Rewriting using any collection of theorems from which equations are derivable is supported by the standard HOL rewriting facilities ($rewrite_tac$ etc.), see the \REFERENCE for details, using Z specific preprocessing of the rewrite theorems (supplied in the Z proof contexts).

Many Z paragraphs give rise to predicates which can be used without further preparation by these standard rewriting facilities.
This applies to given sets, abbreviation definitions and schema definitions.

Axiomatic descriptions, and generic axiomatic descriptions will result in equations which are likely to be effectively conditional.
In such cases it is necessary to establish the applicability of the rewrite before it can be undertaken.

One way of achieving this is by forward chaining using the conditional equation after establishing the relevant condition.
The relevant conditions are usually the membership assertions corresponding to the declaration part of the outer universal quantifier on the theorem to be used for rewriting.

For example, to prove the goal:
=SML
set_goal([], Ò µ i:Ó ∑ abs i = abs ~iÆ);
=TEX
using theorem $z_abs_thm$ (which is :
=INLINEFT
Ù µ i : Ó ∑ abs i = i ± abs ~ i = i
=TEX
).
First strip the goal:
=SML
a (REPEAT z_strip_tac);
=GFT ProofPower output
...
(*  1 *)  Ò0 º iÆ

(* ?Ù *)  Òabs i = abs ~ iÆ
...
=TEX
Then forward chain using the theorem and rewrite with the results:
=SML
a (ALL_FC_T rewrite_tac [z_abs_thm]);
save_pop_thm "abs_eq_abs_minus_thm";
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
In more complicated cases the proof of the required conditions may be non-trivial, often because reasoning about membership of expressions formed with function application is involved. The next section describes the proof support available for use in such cases.
\section{Function Application}\label{FUNCTIONS}
Reasoning at a low level, $z_app_eq_tac$ may be used to reduce an equation involving an application to sufficient conditions for its truth, in terms of the membership of the function, e.g.:
=SML
set_goal([],Ò f a = vÆ);
a z_app_eq_tac;
=GFT ProofPower output
...
(* ?Ù *)  Ò(µ f_a : U | (a, f_a) ç f ∑ f_a = v) ± (a, v) ç fÆ
...
=TEX
The first conjunct of this result is needed to ensure that $f$ is functional at $a$ (i.e. maps $a$ to only one value).
In the case that $f$ is known to be a function, the theorem $z_fun_app_clauses$ may be used with forward chaining, avoiding the need to prove that $f$ is functional at $a$.
=GFT
val z_fun_app_clauses =
  Ù µ f : U; x : U; y : U; X : U; Y : U
    ∑ (f ç X ﬂ Y
          ≤ f ç X ˛ Y
          ≤ f ç X œ Y
          ≤ f ç X ≠ Y
          ≤ f ç X ‡ Y
          ≤ f ç X Ô Y
          ≤ f ç X è Y)
        ± (x, y) ç f
      ¥ f x = y : THM
=TEX
In this case the result $(a,v)\ ç\ f$ would have to be proven and added to the assumptions before undertaking the forward chaining, e.g.:
=SML
drop_main_goal();
set_goal([], Ò[X,Y](µ f : X ≠ Y; x:X; y:Y  ∑ (x, y) ç f ¥ f x = y)Æ);
a (REPEAT z_strip_tac);
=GFT ProofPower output
...
(*  4 *)  Òf ç X ≠ YÆ
(*  3 *)  Òx ç XÆ
(*  2 *)  Òy ç YÆ
(*  1 *)  Ò(x, y) ç fÆ

(* ?Ù *)  Òf x = yÆ
=SML
a (all_fc_tac [z_fun_app_clauses]);
pop_thm();
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX

A common problem is to have to establish that the value of some expression formed by application falls within some particular set.
This is often needed to establish the conditions necessary for use of a rewriting equation on the expression.

In these circumstances the theorem $z_fun_ç_clauses$ may be used:
=GFT
val z_fun_ç_clauses = Ù µ f : U; x : U; X : U; Y : U
 ∑ ((f ç X ≠ Y ≤ f ç X ‡ Y ≤ f ç X Ô Y ≤ f ç X è Y) ± x ç X
 	¥ f x ç Y)
 ± ((f ç X ﬂ Y ≤ f ç X ˛ Y ≤ f ç X œ Y) ± x ç dom f
 	¥ f x ç Y) : THM
=TEX
The claim that a global variable is a member of a function space will often be obtained from the specification of the constant (as part of the predicate implicit in the declaration part of the specification).
Where the function is an expression the result is likely to have been established by forward inference using similar methods.

For example, consider the following specifications:
πZ
[T]
∞

πZAX
‹CONSTSPEC : â1 T Ô Ó
˜
‹true
∞
where we are required to demonstrate that $CONSTSPEC$ applied to something in  $T$ is in the set $Ó$. For this example, we need sets which do not occupy all of their types, 
otherwise the conjecture would be trivially true. Also,  from $z_fun_ç_clauses$ we have that given an $f ç X Ô Y$
and an $x ç X$, then we can conclude that $f x ç Y$. This means that 
the current proof context, $z_library1$, will be
too agressive  for our purposes because it will expand the definition
of  $Pâ1$, the $X$ in this case. So, we will use the proof context $z_predicates$ for this example:

=SML
push_pc"z_predicates";
set_goal([], Ò(µ x:â1 T∑ CONSTSPEC x ç Ó)Æ);
a(REPEAT strip_tac);
=GFT ProofPower output
...
(*  1 *)  Òx ç â1 TÆ

(* ?Ù *)  ÒCONSTSPEC x ç ÓÆ
...
=TEX
We need the fact about $CONSTSPEC$ which is found in its defining declaration  to make the required inference.

This is added to the assumptions as follows:
=SML
a (strip_asm_tac (z_get_spec ÒCONSTSPECÆ));
=GFT ProofPower output
...
(*  2 *)  Òx ç â1 TÆ
(*  1 *)  ÒCONSTSPEC ç â1 T Ô ÓÆ

(* ?Ù *)  ÒCONSTSPEC x ç ÓÆ
...
=TEX
Next we forward chain using the theorem $z_fun_ç_clauses$, which suffices to discharge the goal.
=SML
a (all_fc_tac[z_fun_ç_clauses]);
pop_thm();
pop_pc();
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
=TEX

\section{Using Lemmas} \label{LEMMAS}
Use of the tactic $lemma_tac$ may give a more natural feel to a proof. It allows
you to state and prove a lemma ``on the fly''. This will generate at least
two subgoals - one the statement of the lemma and the rest the result of stripping
the lemma into the assumptions. For example:
=SML
set_goal([],Ò(µx,y :˙ |x  º y ∑ P (x,y)) ± x = y ¥ P (x,y)Æ);
a(REPEAT strip_tac);
=TEX
=GFT ProofPower output
...
(*  2 *)  Òµ x, y : ˙ | x º y ∑ P (x, y)Æ
(*  1 *)  Òx = yÆ

(* ?Ù *)  ÒP (x, y)Æ
...
=TEX
=SML
a(lemma_tacÒx º yÆ);
=TEX
=GFT ProofPower output
Tactic produced 2 subgoals:

(* *** Goal "2" *** *)

(*  3 *)  Òµ x, y : ˙ | x º y ∑ P (x, y)Æ
(*  2 *)  Òx = yÆ
(*  1 *)  Òx º yÆ

(* ?Ù *)  ÒP (x, y)Æ


(* *** Goal "1" *** *)

(*  2 *)  Òµ x, y : ˙ | x º y ∑ P (x, y)Æ
(*  1 *)  Òx = yÆ

(* ?Ù *)  Òx º yÆ
=TEX
Rewriting with the assumptions will solve the
first goal:
=SML
a(asm_rewrite_tac[]);
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "2" *** *)
...
=TEX
and forward chaining the second:
=SML
a(all_asm_fc_tac[]);
pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
=TEX
In this example, one tactic solved the lemma. If you apply this with
$THEN1$, you can avoid the subgoal split:
=SML
set_goal([],Ò(µx,y :˙ |x  º y ∑ P (x,y)) ± x = y ¥ P (x,y)Æ);
a(REPEAT strip_tac);
a(lemma_tacÒx º yÆ THEN1 asm_rewrite_tac[]);
=GFT ProofPower output
Tactic produced 1 subgoal:

(* *** Goal "" *** *)

(*  3 *)  Òµ x, y : ˙ | x º y ∑ P (x, y)Æ
(*  2 *)  Òx = yÆ
(*  1 *)  Òx º yÆ

(* ?Ù *)  ÒP (x, y)Æ
...
=TEX
=SML
a(all_asm_fc_tac[]);
pop_thm();
=TEX
Applying $lemma_tac$ is equivalent to applying $LEMMA_T\ strip_asm_tac$. $LEMMA_T$
has an argument of type $THM\ ->\ TACTIC$ telling you what to do with 
the new assumption. Sometimes, you really want to put the lemma into the 
assumptions in exactly the way you have formulated it: $LEMMA_T\ asm_tac$
will achieve this. Another common thing you might want to do is to rewrite your
goal with the new assumption: $LEMMA_T\ rewrite_thm_tac$ will achieve this.


\section{Case Analysis} \label{CASES}
The tactic $cases_tac\ condition$ lets you reason by cases 
according as a chosen $condition$ is true or false. Consider
the example from section \ref{LEMMAS} that was progressed with $lemma_tac$.
This time, we will use $cases_tac$ which will generate a contradiction 
in the case where the condition is false:
=SML
set_goal([],Ò(µx,y :˙ |x º y ∑ P (x,y)) ± x = y ¥ P (x,y)Æ);
a(REPEAT strip_tac);
=TEX
=GFT ProofPower output
...
(*  2 *)  Òµ x, y : ˙ | x º y ∑ P (x, y)Æ
(*  1 *)  Òx = yÆ

(* ?Ù *)  ÒP (x, y)Æ
...
=TEX
=SML
a(cases_tacÒx º yÆ);
=TEX
=GFT ProofPower output
Tactic produced 2 subgoals:
(* *** Goal "2" *** *)

(*  3 *)  Òµ x, y : ˙ | x º y ∑ P (x, y)Æ
(*  2 *)  Òx = yÆ
(*  1 *)  Ò≥ x º yÆ

(* ?Ù *)  ÒP (x, y)Æ


(* *** Goal "1" *** *)

(*  3 *)  Òµ x, y : ˙ | x º y ∑ P (x, y)Æ
(*  2 *)  Òx = yÆ
(*  1 *)  Òx º yÆ

(* ?Ù *)  ÒP (x, y)Æ
=TEX
This time, forward chaining proves the first subgoal:
=SML
a(all_asm_fc_tac[]);
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current goal achieved, next goal is:

(* *** Goal "2" *** *)
...
=TEX
Eliminating $x$ should derive the expected contradiction to solve subgoal 2:
=SML
a(all_var_elim_asm_tac1);
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
\section{Induction}\label{INDUCTION}
Induction tactics for integers are available. The easiest one 
to use is $z_º_induction_tac$. For example: 
=SML
set_goal([],Òµ i,j:˙| 0 º  i ± 0 º j ∑ 0 º i*jÆ);
a(REPEAT strip_tac);
=TEX
=GFT ProofPower putput
...
(*  2 *)  Ò0 º iÆ
(*  1 *)  Ò0 º jÆ

(* ?Ù *)  Ò0 º i * jÆ
=TEX

Now apply the induction tactic:
=SML
a(z_º_induction_tacÒiÆ);
=TEX
=GFT ProofPower output
Tactic produced 2 subgoals:

(* *** Goal "2" *** *)

(*  3 *)  Ò0 º jÆ
(*  2 *)  Ò0 º iÆ
(*  1 *)  Ò0 º i * jÆ

(* ?Ù *)  Ò0 º (i + 1) * jÆ


(* *** Goal "1" *** *)

(*  1 *)  Ò0 º jÆ

(* ?Ù *)  Ò0 º 0 * jÆ
=TEX
Subgoal 1 is proved by rewriting with the assumptions. 
=SML
a(asm_rewrite_tac[]);
=TEX
Although the original goal was not a linear
arithmetic result, induction has reduced the problem to one
of linear arithmetic. Subgoal 2  can be proved in the  proof context 
$z_lin_arith$:
=SML
a(PC_T1"z_lin_arith"asm_prove_tac[]);
pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX

\chapter{PROVING VCS} \label{VCPRFS}
When faced with the task of providing a formal proof to any conjecture, the first recommendation would always be to inspect the conjecture to establish whether or not one believes it to be true. The VC conjectures have been machine generated by the Compliance Tool, and as such are typically not the sort of conjectures that a human user would dream up. In fact, some may prove to be trivially tautologically true. In section \ref{VCPRED}  we give an overview of the predicates  generated in VCs by way of illustrating the sort of constructs you might expect to have to work with.



\section{Predicates Generated in VCs} \label{VCPRED}
An analysis of the Compliance Notation statements demonstrates that each sort of statement generates a VC of a particular form. The predicate structure of a VC is a single universally closed implication, give or take the complexity introduced by quantifiers supplied by the user in pre- and post- conditions. In practice, it is found that VCs are often universally quantified propositional tautologies or are amenable to useful, purely propositional, simplification. Consider, for example, the VCs for refinement of one specification statement by another.

Given this (simplified) specification statement:
=GFT Compliance Notation
 procedure vc_specification
 is
    X ;
 begin
  Ñ X [ PRE X, POST (X, Xâ0) ]		(1)
 end vc_specification;
=TEX
With this refinement step:
=GFT Compliance Notation
 (1) √  Ñ X [ PRE1 X, POST1 (X, Xâ0) ] (2)
=TEX

The generated VCs are:

=GFT
vc1_1		µ X : INTEGER | PRE X ∑ PRE1 X
vc1_2		µ X, Xâ0 : INTEGER
	  | PRE Xâ0 ± POST1 (X, Xâ0)
	  ∑ POST (X, Xâ0)
=TEX

If the two pre-conditions are the same, then the first of the two VCs will be a tautology. If the two post-conditions are the same then the second VC will be a tautology. If the pre- and post-conditions have common conjuncts, say $PRE = A \land B$, $PRE1 = A \land C$, $POST = A \land D$, $POST1 = A \land E$, then $A$ can be eliminated from the conclusion of both VCs.

Schematic examples of the various types of atomic predicate which appear are shown in the
following table:

\begin{centering}
\begin{tabular}{|l|l|}\hline
Predicate & Statement Type \\\hline
=INLINEFT
EXP = TRUE
=TEX
&
If, While
\\\hline
=INLINEFT
EXP = FALSE
=TEX
&
If, While
\\\hline
=INLINEFT
EXP ç SET
=TEX
&
Case
\\\hline
=INLINEFT
I ç EXP .. EXP
=TEX
&
For
\\\hline
=INLINEFT
I Ω EXP
=TEX
&
For
\\\hline
=INLINEFT
I º EXP
=TEX
&
For
\\\hline
=INLINEFT
I < EXP
=TEX
&
For
\\\hline
\end{tabular}

\end{centering}

Here $EXP$ is the result of translating a more or less arbitrary SPARK expression into Z, $I$ is a for-loop variable, and $SET$ is formed from integer constants using ranges, set displays and unions.

All but the first two of these atomic predicate forms are already tractable using the current {\Product} proof facilities.
The first two are handled in some cases quite straightforwardly by the proof context $cn1$ provided with the current Compliance Tool.
However, in more complex cases some more assistance is needed.
E.g., consider
=INLINEFT
not F(X) = FALSE
=TEX
.
We would like to be able to recast this as $F(X) = TRUE$, however this can not currently be done automatically.
The problem arises because of the representation of SPARK booleans as numbers.
This means that the fact that 
=INLINEFT
not F(X) = FALSE § F(X)  = TRUE
=TEX
\ is actually conditional --- it only holds if
=INLINEFT
F(X) ç {0, 1}
=TEX
.
Now, if the expression comes from a well-typed SPARK expression, this condition will indeed be satisfied, but this fact currently needs to be established by hand before the predicates can be rewritten.

=IGN
\subsection{Expressions Generated in VCs} \label{VCEXP}
Most of the expression forms which appear have already been listed in the discussion of atomic predicates in the previous section. The remaining forms are shown by schematic examples in the following table.

\begin{centering}
\begin{tabular}{|l|l|}\hline
Expression & Statement Type \\\hline
 =INLINEFT
(A ¶ RHS, B ¶ LHS.B)
 =TEX
&
Assignment
\\\hline
 =INLINEFT
LHS ´ {INDEX Ì RHS}
 =TEX
&
Assignment
\\\hline
 =INLINEFT
LHS INDEX
 =TEX
&
Assignment
\\\hline
 =INLINEFT
(LHS INDEX).Y
 =TEX
&
Assignment
\\\hline
 =INLINEFT
I + 1
 =TEX
&
For
\\\hline
\end{tabular}

\end{centering}

In fact, complex combinations of the first four forms are possible.

{\ProductZ} provides proof support for all these forms, although as outlined in section \ref{GENPUR}, the user may want to arm himself with his own tailor made lemmas before attempting the VC proofs.
=TEX

\section{Tackling the Proofs}
As ordinary Z goals, VCs may be proved using all of the normal facilities provided by {\Product} for proof in Z. Chapter \ref {ZPROOF}
 provides an overview, based on the \ZTUTORIAL, of the recommended techniques for using {\ProductZ} for doing proofs. 
In addition, many VCs use Z toolkit extensions which 
 are contained in the theory $cn$. 
Some custom support is provided in the Compliance Tool to assist with reasoning in this theory, most notably the proof contexts $cn1$, $cn_ext$ and $cn$. 
There are 
also some purpose built tactics available, e.g. $cn_vc_simp_tac$ and
$cn_ç_type_tac$ which have been designed for use with VC proofs. The main objective
of this section is to show you how to use these tactics with facilities available in the proof context $cn1$
to strip away the ``Compliance Tool specific'' bits of a VC proof
to transform it into an ``ordinary'' Z proof. From there, hopefully the material in section \ref{ZPROOF}
 will guide you in progressing your proof. 
\subsection{Proof Contexts and Tactics}

The theory $cn$ contains the Compliance Tool Z toolkit extensions. 
The recommended user interface to the conversions etc. described there is via the proof context $cn1$. In this proof context  the SPARK boolean and relational operators are converted fairly directly into Z.  Additional theorems in the theory $cn$ are also available for reasoning about the numeric operators $intdiv$, $intmod$ and $rem$.
The more aggressive proof contexts, $cn$ and  $cn_ext$, are also available. These, and all the other custom proof tools are described in section 6.1 of The Compliance Tool User Guide, \cite{ISS/HAT/DAZ/USR501}. A full listing of the theory $cn$ is also provided in \cite{ISS/HAT/DAZ/USR501}. 

Application of the tactic $cn_vc_simp_tac$, see section 6.1 of \cite{ISS/HAT/DAZ/USR501}, is the favoured way of beginning a VC proof. In all but the 
most obscure cases this should simplify the goal, and may even be sufficient to achieve a proof. $cn_vc_simp_tac$ first rewrites the conclusion of the goal
with the rewriting rules of the current proof context, some associativity
theorems, and any theorems of your choice. Outer universal quantifiers are stripped away and any resulting redundancy in the goal removed. For example, 
 using the proof context $cn1$, $cn_vc_simp_tac$, will transform the goal:

=GFT
?Ù	µ	x : INTEGER; y : INTEGER; z : INTEGER
	|	(x + y) + 1 eq z = TRUE ± (x æ 0 ± y æ 0) ± x æ 0
	∑	x æ 0 ± z greater_eq 0 = TRUE 
=TEX
into:
=GFT
?Ù		x ç INTEGER ± y ç INTEGER ± z ç INTEGER
	±	x + y + 1 = z ± 0 º x ± 0 º y
	¥	0 º z	
=TEX

\subsection{Getting Started} \label{STARTED}

It is assumed that you are using the Compliance Tool and are 
in a position to access the VCs, i.e. you are either in the same theory as your specification, or in a theory which has your specification as a parent.
(\cite{ISS/HAT/DAZ/USR501}, gives a comprehensive account of the Compliance Notation functions, in particular how to access the VCs generated by the tool from a literate script). 

Processing a Compliance Notation script gives rise to definitions and axioms that are not necessarily in a form that makes for easy reasoning. Before you tackle the VC proofs, there is some Compliance Tool support available  that
generates some theorems for you that should facilitate rewriting when proving the VCS.
First  call the function $all_cn_make_script_support$ with your choice of name as string argument. For example:
=GFT
val my_thms = all_cn_make_script_support "mycn";
=TEX
generates all these supporting theorems, binds them (in a list) 
to the ML variable
 $my_thms$, and generates the supporting proof context $mycn$. 
After a few seconds, you will see a raft of theorems scroll 
by in the journal window. Each of 
the definitions and axioms generated by processing the Compliance
Notation give rise to one or two supporting theorems. There is always
one rewriting theorem, and if this does not contain all the type information implicit in the definition, there will be another signature
 theorem. These theorems are at least as good as what you get with $z_get_spec$, and in many cases
are in a much better form for rewriting.  

All supporting theorems are stored in 
the current theory, and are prefixed by $cn_$. The rewriting 
theorems finish with $_thm$, and the signature theorems finish with $_sig_thm$. 
The theorems are also bound to ML variables of the same name. Such theorems
will have been generated from all the definitions in your theory.
For example, the type $OPERATION$ 
in the package $TC$ in the calculator example, see section \ref{CALCEX}, 
gives rise to the definition $TCoOPERATION$, for which one supporting
theorem has been generated:
=GFT
cn_TCoOPERATION_thm	 
	Ù TCoOPERATION = TCoPLUS .. TCoEQUALS
=TEX
and an attribute definition $TCoOPERATIONvPOS$, for which two supporting
theorems have been generated:
=GFT
cn_TCoOPERATIONvPOS_thm	
	Ù µ i : TCoOPERATION ∑ TCoOPERATIONvPOS i = i
cn_TCoOPERATIONvPOS_sig_thm	
	Ù TCoOPERATIONvPOS ç TCoOPERATION ≠ TCoOPERATION
=TEX

The supporting proof context $mycn$ created for you is the proof context $cn1$
extended by these supporting theorems. It is not the intention that you
should set $mycn$ as a proof context, because it would typically be too aggressive. The effect of rewriting in proof context $mycn$ would be
to unwind everything in a goal with its basic definition. However, there are
some cases when this is exactly what you want to do, for example, when numerical values in a specification are significant. In this case, you would probably
have set the proof context to $cn1$ at the start of the proof, and then at some appropriate stage applied the following:
=GFT
a(PC_T1 "mycn" rewrite_tac[]);
=TEX

\subsection{Compliance Tool Proofs}

You should now be in a position to prove the VCs. 
The names of the VCs can be obtained from the current theory using $get_conjectures\ "-"$.

First, set the proof context,
typically $cn1$, and  set 
the VC, called, say, $vcn_n$,  as a {\ProductZ} goal. 

=GFT SML
set_pc"cn1";
set_goal([], get_conjecture"-""vcn_n");
=TEX
Now apply the simplification tactic $cn_vc_simp_tac$. This may achieve
the proof; if not and you believe that the goal is simply a predicate calculus result, perhaps
with a bit of linear arithmetic,
 then you may 
care to attack it with $prove_tac$ (in the linear arithmetic proof context if 
applicable). In general, though,  this type of automatic proof procedure 
would not be appropriate. Next, you might try the following (until the goal is achieved):
\ftlmargin=0.4in
\begin{itemize}
\item
Apply $REPEAT\ strip_tac$. If this results in the generation of
additional subgoals,  you 
may  want
to ``undo 1''  and then perform more controlled stripping. 
For example
=SML
set_pc"cn1";
set_goal([],Ò(µ x : X; y : X
             | P(x) ± Q(x)  ± x eq y = TRUE
             ∑ P(y) ± Q(y))Æ);
a(cn_vc_simp_tac[]);
=TEX
=GFT ProofPower output

(* *** Goal "" *** *)

(* ?Ù *)  Òx ç X ± y ç X ± P x ± Q x ± x = y ¥ P y ± Q yÆ

=TEX
$REPEAT\ strip_tac$
 will generate two subgoals from the conjunction
in the right hand side of the implication 
obtained by $cn_vc_simp_tac$:
=SML
a(REPEAT strip_tac);
=TEX
=GFT ProofPower output

Tactic produced 2 subgoals:

(* *** Goal "2" *** *)

(*  5 *)  Òx ç XÆ
(*  4 *)  Òy ç XÆ
(*  3 *)  ÒP xÆ
(*  2 *)  ÒQ xÆ
(*  1 *)  Òx = yÆ

(* ?Ù *)  ÒQ yÆ

(* *** Goal "1" *** *)

(*  5 *)  Òx ç XÆ
(*  4 *)  Òy ç XÆ
(*  3 *)  ÒP xÆ
(*  2 *)  ÒQ xÆ
(*  1 *)  Òx = yÆ

(* ?Ù *)  ÒP yÆ

=TEX
Whereas $¥_tac$ will strip the left hand side of the implication 
into the assumptions without affecting the right hand side:
=SML
undo 1;
a ¥_tac;
=TEX
=GFT ProofPower output

Tactic produced 1 subgoal:

(* *** Goal "" *** *)

(*  5 *)  Òx ç XÆ
(*  4 *)  Òy ç XÆ
(*  3 *)  ÒP xÆ
(*  2 *)  ÒQ xÆ
(*  1 *)  Òx = yÆ

(* ?Ù *)  ÒP y ± Q yÆ
=TEX

\item
Stripping may not suceed if it generates an assumption
which is an equation with a variable on one side of the equals. Eliminating that variable throughout, with a variation on the theme of $var_elim_asm_tac$, before 
using $asm_rewrite_tac$ or $asm_fc_tac$ may solve the goal.
The  example  above illustrates this. Eliminating x
from assumption 1 then rewriting with the assumptions should complete proof:
=SML
a(all_var_elim_asm_tac1);
a(asm_rewrite_tac[]);
pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX

\item
A For Loop Statement may give rise to a VC with an assumption which is quantified over a range $i\ ..\ i-1$. Such an assumption is false, and the application of $asm_prove_tac$ in the linear arithmetic proof context will suffice to prove the VC:

=INLINEFT
PC_T1"z_lin_arith"asm_prove_tac[]
=TEX

\item
Rewriting is usually the next thing to try. There are
two ``levels'' of definitions that can be unwound:
\begin{itemize}
\item
the SPARK definitions in the specification, e.g. the attributes
$TCoDIGITvFIRST$ and $TCoDIGITvLAST$ 
in the calculator example, section \ref{CALCEX}
\item
the Z in the specification, e.g. the Z schema $DO_DIGIT$ 
in the calculator example
\end{itemize}
Perhaps you could progress your proof by rewriting explicitly with the supporting theorems
 $cn_TCoDIGITvFIRST_thm$, or $cn_DO_DIGIT_thm$ that were generated for you
as described in section \ref{STARTED}.

It is worth remembering that forward chaining is often required
in order to obtain usable rewrites from Z definitions. For example, the
theorem available from 
the definition of $fact$ in the calculator example, section \ref{CALCEX}, is:
=GFT
Ù fact ç Ó ≠ Ó
    ± fact 0 = 1
    ± (µ m : Ó ∑ fact (m + 1) = (m + 1) * fact m)
=TEX
To use the third conjunct of this theorem, it is necessary to have an 
assumption of the form $m\ ç\ Ó$ so that you can forward chain, with, say, $fc_tac$, to obtain the result that 
=INLINEFT
fact (m + 1) = (m + 1) * fact m
=TEX
. It is also not uncommon to have the following pattern in 
a  Z axiomatic definition:
=GFT
‹SOMEPROPERTY : X ≠  Y
˜
‹µ x : X; y : Y  ∑ y ç SOMEPROPERTY x § SOMEPREDICATE
=TEX
Suppose you are required to prove the goal:
=GFT
a ç SOMEPROPERTY b
=TEX
Then, useful rewriting may be achieved by forward chaining using
=GFT
ALL_FC_T1 fc_§_canon rewrite_tac[z_get_specÒSOMEPROPERTYÆ]
=TEX
\item
Some insight as to ``what to do next'' may be gleaned from chapter  \ref{ZPROOF}
. The degree of difficulty experienced in proving VCs rather depends on 
the refinement steps which generated the VCs in the first place.
A complex sequence of intermediate refinements gives rise to complex VCs,
whereas refinements which rely heavily on the underlying Z may require you to unwind a lot of definitions.

It is worth remembering at this time that there is always the possibility that
the VC you are trying to prove may not be true, or more likely, may not be provable. You 
may save yourself pain  if, before you embark on the proof using the tool,
you spend a few minutes at the outset inspecting the VC to convince yourself that you have a fair chance of achieving
a proof. Problems will occur if the pre- condition of a 
refinement statement is too weak, or the  post- condition  too strong,
 to prove the VC.

\end{itemize}

Typically you may find it advantageous to prove subsidiary  lemmas before embarking upon a VC proof.
These will be either  general purpose lemmas that are not available in {\ProductZ} but can easily be proven with the proof support available, or they will be application specific. Such lemmas are proven separately either because they are results that are found to be needed repeatedly during the process of proving the VCs, or because proving them in isolation is simpler than proving them in the context of a VC proof. Actually, in practice, it is common to experience a sense of {\em deja vu} when in the middle of a proof. You find that you need a result that you have already proved in an earlier VC proof, and it is at that stage that you decide to backtrack and  extract the bits from the previous proof as a separate lemma.
Sections \ref{GENPUR} and \ref{APPSPEC} provide an overview of the sort of subsidiary lemmas that might typically be useful.

\ftlmargin=0in


\subsection{General Purpose Lemmas} \label{GENPUR}

In section \ref{VCPRED} there is a discussion about the way particular SPARK constructs are translated into Z. For example, the occurrence of functional overrides in the VCs arise from SPARK array assignments. These assignments
can be to an arbitrary level of nesting. Suppose in your VC proofs,
the following lemma would be useful:

=GFT
´_lemma
[X, Y, Z](µf : X ≠ Y ≠ Z; x:X;y2:Y;y1:U;z:U| ≥y2=y1∑
	(f ´ {x Ì f x ´ {y1 Ì z}})x y2= f x y2)
=TEX

Although this does not exist as a theorem in {\ProductZ}, it is 
straightforward for you to prove as a separate lemma
using $z_fun_ç_clauses$, as described
in section \ref{FUNCTIONS}, together with the theorems 
$z_´_Ì_app_thm$ and $z_´_Ì_app_thm1$:
=GFT
z_´_Ì_app_thm
Ù µ f : U; x : U; y : U ∑ (f ´ {x Ì y}) x = y 
=TEX
=GFT
z_´_Ì_app_thm1
Ù  [X,Y](µ f : X ≠ Y; x2 : X; x1 : U; y : U | ≥ x2 = x1 ∑ 
	 (f ´ {x1 Ì y}) x2 = f x2)
=TEX
=SML
set_goal([],Ò[X, Y, Z](µf : X ≠ Y ≠ Z; x:X;y2:Y;y1:U;z:U| ≥y2=y1∑
	(f ´ {x Ì f x ´ {y1 Ì z}})x y2= f x y2)Æ);
a(REPEAT strip_tac);
a(rewrite_tac[z_´_Ì_app_thm]);
a(all_asm_fc_tac[z_fun_ç_clauses]);
a(ALL_ASM_FC_T rewrite_tac[z_´_Ì_app_thm1]);
pop_thm();
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
margin
\subsection{Application Specific Lemmas} \label{APPSPEC}
The sort of application specific lemmas a user might require clearly depends on the sort of SPARK constructs that have been used. Two typical examples are:
\ftlmargin=0.4in
\begin{enumerate}
\item
\subsubsection*{Set Membership of Record Fields}
The form of this class of lemma is  
=INLINEFT
X.field ç set
=TEX
, which arises from indexing into an array of 
records in SPARK. The tactic $cn_ç_type_tac$ is available
to simplify the  proof of this type of lemma. A typical example of the set in
question is  $BOOLEAN$. For example, 
suppose we have the following specification snippet:
=GFT
subtype SWITCHTYPE is INTEGER range 1 .. 3;
 type SWITCHDATA is
    record
       STATE : BOOLEAN;  -- on or off
       NEXTSWITCH : INTEGER;
    end record;

 type SWITCHBOARD is array (SWITCHTYPE) of SWITCHDATA;
=TEX

\Hide{%
πCN
 procedure EX is

 subtype SWITCHTYPE is INTEGER range 1 .. 3;
 type SWITCHDATA is
    record
       STATE : BOOLEAN;  -- on or off
       NEXTSWITCH : INTEGER;
    end record;

 type SWITCHBOARD is array (SWITCHTYPE) of SWITCHDATA;

 begin 
 	null;
 end EX;				
∞
}
=SML
val switch_thms = all_cn_make_script_support "switch_cn";
=TEX
=SML
set_goal([],Òµ sb:SWITCHBOARD; s: SWITCHTYPE∑(sb s).STATE ç BOOLEANÆ);
a(REPEAT strip_tac);
a(PC_T1"switch_cn"cn_ç_type_tac[]);
=TEX


Forward chaining 
=INLINEFT
(sb s).STATE ç BOOLEAN
=TEX
with $cn_boolean_clauses1$ from the theory $cn$:
=GFT
Ù (µ x : BOOLEAN ∑ not x = Boolean (≥ x = Boolean true))
    ± (µ x, y : BOOLEAN
      ∑ x and y = Boolean (x = Boolean true ± y = Boolean true))
    ± (µ x, y : BOOLEAN
      ∑ x or y = Boolean (x = Boolean true ≤ y = Boolean true))
    ± (µ x, y : BOOLEAN
      ∑ x xor y = Boolean (≥ x = Boolean true § y = Boolean true)) 
=TEX
would provide several useful results. For example
=GFT
Ù not  (sb s).STATE = Boolean true §  (sb s).STATE = Boolean false 
=TEX
.
\item
\subsubsection*{Record a Member of Record Set}
The form of this class of lemma is 
=INLINEFT
(x ¶ x1,y ¶ y1,...) ç set of recs
=TEX
, which arises from assignment to an array of 
records in SPARK. Suppose the user wants to use $´_lemma$ from section \ref{GENPUR} in the case where the $z$ in question is a record. This must 
be proven to be of type $Z$, a record set in this case, before $´_lemma$ is applicable.
\end{enumerate}


\ftlmargin=0in

\pagebreak
\chapter{CALCULATOR EXAMPLE} \label{CALCEX}
This Compliance Notation
 example is concerned with the computational aspects of a simple calculator.
Section \ref{LITERATE} provides the literate script for the example and section
\ref{CALCEXVCS} overviews the VCs generated  then provides proofs for 
a subset of them. For reference purposes, a complete set of VC proofs is
available in a separate document, \cite{ISS/HAT/DAZ/WRK513}. A listing of the theory generated by the
calculator example is available
in appendix \ref{CALCVCS}. In addition,
a listing of the generated SPARK program  is available
in appendix \ref{CALCSPARK}. 
\Hide{%
=SML
open_theory"cn";
force_delete_theory"usr503calc" handle Fail _ => ();
new_script {name="usr503calc", state=initial_cn_state};
=TEX
}

\pagebreak

\section{The Literate Script} \label{LITERATE}
\subsection{Basic Definitions}
In this section, we define types and constants which will be of use throughout the rest of the script.

The SPARK package $TC$  below helps record the following facts:

\begin{itemize}
\item
The calculator deals with signed integers expressed using up to six decimal digits.

\item
It has a numeric keypad and 6 operation buttons labelled $+$, $-$, $\times$, $+/-$, $\sqrt{ }$, $!$, and $=$.
\end{itemize}

πCN
package TC is

    BASE : constant INTEGER := 10;
    PRECISION : constant INTEGER := 6;
    MAX_NUMBER : constant INTEGER := BASE ** PRECISION - 1;
    MIN_NUMBER : constant INTEGER := -MAX_NUMBER;

    subtype DIGIT is INTEGER range 0 .. BASE - 1;

    subtype NUMBER is INTEGER range MIN_NUMBER .. MAX_NUMBER;

    type OPERATION is
      (PLUS, MINUS, TIMES, CHANGE_SIGN, SQUARE_ROOT, FACTORIAL, EQUALS);

end TC;
∞

\newpage
\subsection{The State}
In this section, we define a package which contains all the state variables of the calculator.

The package $GV$ below defines the global variables we will use to implement the following informal description of part of the calculator's behaviour:

\begin{itemize}
\item
The calculator has two numeric state variables: the display, which contains the number currently being entered, and the accumulator, which contains the last result calculated.
\item
The user is considered to be in the process of entering a number whenever a digit button is pressed, and entry of a number is terminated by pressing one of the operation keys.
\item
When a binary operation key is pressed, the operation is remembered so that 
the appropriate value can be calculated when the second operand has been entered.
\end{itemize}

πCN
with TC;
package GV is

    DISPLAY, ACCUMULATOR : TC.NUMBER;

    LAST_OP : TC.OPERATION;

    IN_NUMBER : BOOLEAN;

end GV;
∞

\newpage
\subsection{The Operations}

In this section, we define a package which contains procedures corresponding to pressing the calculator buttons.

\subsubsection{Package Specification}

We now want to introduce a package $OPS$ which implements the following informal description of how the calculator responds to button presses:

\begin{itemize}
\item
The behaviour when a digit button is pressed depends on whether a number is currently being entered into the display. If a number is being entered, then the digit is taken as part of the number. If a number is not being entered (e.g., if an operation button has just been pressed), then the digit is taken as the most significant digit of a new number in the display.
\item
When a binary operation button is pressed, any outstanding calculation is carried out and the answer (which will be the first operand of the operation) is  displayed; the calculator is then ready for the user to enter the other operand of the operation.
\item
When a unary operation button is pressed, the result of performing that operation to the displayed number is computed and displayed; the accumulator is unchanged, but entry of the displayed number is considered to be complete.
\item
When the button marked $=$ is pressed, any outstanding calculation is carried out and the answer is displayed.
\end{itemize}

The package implementing this is defined in section \ref{PackageOPS} below after we have dealt with some preliminaries.

\paragraph{Z Preliminaries}
To abbreviate the description of the package, we do some work in Z first, corresponding to the various sorts of button press.

Note that the use of
=INLINEFT
˙
=TEX
\ rather than
=INLINEFT
TCoNUMBER
=TEX
\ reflects the fact that we are ignoring questions of arithmetic overflow here.
If we used the Z set which accurately represents the SPARK type, then we would have to add in pre-conditions saying that the operations do not overflow.
The following schema defines what happens when a digit button is pressed.

ˇ DO_DIGIT ¸¸¸¸¸¸¸¸¸¸¸
‹ GVoDISPLAYâ0, GVoDISPLAY : ˙;
‹ GVoIN_NUMBERâ0, GVoIN_NUMBER : BOOLEAN;
‹ D : TCoDIGIT
˜¸¸¸¸¸¸
‹	GVoIN_NUMBERâ0 = TRUE ¥ GVoDISPLAY = GVoDISPLAYâ0*TCoBASE + D;
‹	GVoIN_NUMBERâ0 = FALSE ¥  GVoDISPLAY = D;
‹	GVoIN_NUMBER = TRUE
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

We now define sets $UNARY$ and $BINARY$ which partition the two sorts of operation key.
Note that $=$ can be considered as a sort of binary operation (which given operands $x$ and $y$ returns $x$).
πZ
‹ UNARY ¶ {TCoCHANGE_SIGN, TCoFACTORIAL, TCoSQUARE_ROOT}
∞

πZ
‹ BINARY ¶ TCoOPERATION \ UNARY
∞
We need to define a function for computing factorials in order to define the response to the factorial operation button.

πZAX
‹	fact : Ó ≠ Ó
˜¸¸¸¸¸¸
‹	fact 0 = 1 ;
‹ 	µm:Ó∑ fact(m+1) = (m + 1) * fact m
∞
Unary operations behave as specified by the following schema.
In which we do specify explicitly  that the accumulator and last operation values are unchanged for clarity and for simplicity later on (when we group the unary and binary operations together).

ˇ DO_UNARY_OPERATION ¸¸¸¸¸¸¸¸¸¸¸
‹ GVoACCUMULATORâ0, GVoACCUMULATOR : ˙;
‹ GVoDISPLAYâ0, GVoDISPLAY : ˙;
‹ GVoLAST_OPâ0, GVoLAST_OP : ˙;
‹ GVoIN_NUMBER : BOOLEAN;
‹ O : UNARY
˜¸¸¸¸¸¸
‹	GVoIN_NUMBER = FALSE;
‹	GVoACCUMULATOR = GVoACCUMULATORâ0;
‹	GVoLAST_OP = GVoLAST_OPâ0;
‹	O = TCoCHANGE_SIGN ¥ GVoDISPLAY = ~GVoDISPLAYâ0;
‹	O = TCoFACTORIAL ± GVoDISPLAYâ0 æ 0 ¥ 
‹			GVoDISPLAY = fact GVoDISPLAYâ0;
‹	O = TCoSQUARE_ROOT  ± GVoDISPLAYâ0 æ 0 ¥
‹			GVoDISPLAY ** 2 º GVoDISPLAYâ0 < (GVoDISPLAY + 1) ** 2
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
\pagebreak

The binary operations are specified by the following schema.
ˇ DO_BINARY_OPERATION ¸¸¸¸¸¸¸¸¸¸¸
‹ GVoACCUMULATORâ0, GVoACCUMULATOR : ˙;
‹ GVoDISPLAYâ0, GVoDISPLAY : ˙;
‹ GVoLAST_OPâ0, GVoLAST_OP : ˙;
‹ GVoIN_NUMBER : BOOLEAN;
‹ O : BINARY
˜¸¸¸¸¸¸
‹	GVoIN_NUMBER = FALSE;
‹	GVoDISPLAY = GVoACCUMULATOR;
‹	GVoLAST_OP = O;
‹	GVoLAST_OPâ0 = TCoEQUALS ¥
‹			GVoACCUMULATOR = GVoDISPLAYâ0;
‹	GVoLAST_OPâ0 = TCoPLUS ¥
‹			GVoACCUMULATOR = GVoACCUMULATORâ0 + GVoDISPLAYâ0;
‹	GVoLAST_OPâ0 = TCoMINUS ¥
‹			GVoACCUMULATOR = GVoACCUMULATORâ0 - GVoDISPLAYâ0;
‹	GVoLAST_OPâ0 = TCoTIMES ¥
‹			GVoACCUMULATOR = GVoACCUMULATORâ0 * GVoDISPLAYâ0
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
The disjunction of the schemas for the unary and binary operations is then what is needed to define the response to pressing an arbitrary button press.
πZ
‹ DO_OPERATION ¶ DO_UNARY_OPERATION ≤ DO_BINARY_OPERATION
∞
\newpage
\subsubsection{The SPARK Package}\label{PackageOPS}
We now use the schemas of the previous section to define the package $OPS$.
πCN
with TC, GV;
package OPS is
procedure DIGIT_BUTTON (D : in TC.DIGIT)
        Ñ GVoDISPLAY, GVoIN_NUMBER [ DO_DIGIT ] ;
procedure OPERATION_BUTTON (O : in TC.OPERATION)
        Ñ GVoACCUMULATOR, GVoDISPLAY,
                GVoIN_NUMBER, GVoLAST_OP [ DO_OPERATION ] ;
end OPS;
∞
\subsubsection{Package Implementation}
\paragraph{Package Body}\label{PBODY}
The following specification of the package body is derived from the package specification in the obvious way. We leave a k-slot for any extra declarations we may need.
πCN
package body OPS is
     ß Extra Declarations ¢						( 500 )
procedure DIGIT_BUTTON (D : in TC.DIGIT)
        Ñ GVoDISPLAY, GVoIN_NUMBER [ DO_DIGIT ]
    is begin
        Ñ GVoDISPLAY, GVoIN_NUMBER [ DO_DIGIT ]			(3001)
    end DIGIT_BUTTON;
procedure OPERATION_BUTTON (O : in TC.OPERATION)
        Ñ GVoACCUMULATOR, GVoDISPLAY,
                 GVoIN_NUMBER, GVoLAST_OP [ DO_OPERATION ]
    is begin
        Ñ GVoACCUMULATOR, GVoDISPLAY,
                 GVoIN_NUMBER, GVoLAST_OP [ DO_OPERATION ]		(3002)
    end OPERATION_BUTTON;
end OPS;
∞
\paragraph{Supporting Functions} \label{FUNS}
We choose to separate out the computation of factorials and square roots into separate functions which replace the k-slot labelled 500.
In both cases, we prepare for the necessary algorithms.
Our approach for both functions is to introduce and initialise appropriately a variable called $RESULT$, demand that this be set to the desired function return value and return that value.


πCN
 (500) È 
    function FACT (M : NATURAL) return NATURAL
        Ñ [ FACT(M) = fact(M) ]
    is
        RESULT : NATURAL;
    begin
        RESULT := 1;
        Ñ RESULT [M æ 0 ± RESULT = 1, RESULT = fact M ]	(1001)
        return RESULT;
    end FACT;

    function SQRT (M : NATURAL) return NATURAL
        Ñ [SQRT(M) ** 2 º M < (SQRT(M) + 1) ** 2]
    is
        RESULT : NATURAL;
       ß other local vars ¢		(2)
    begin
       RESULT := 0;
       Ñ RESULT [RESULT = 0, RESULT ** 2 º M < (RESULT + 1) ** 2]	(2001)
      return RESULT;
    end SQRT;
∞

\paragraph{Algorithm for Factorial} \label{FACT}
Factorial is implemented by a for-loop with loop-counter $J$ and an invariant requiring that as $J$ steps from $2$ up to $M$, $RESULT$ is kept equal to the factorial of $J$:
πCN
  (1001) √
    for J in INTEGER range 2 .. M
    loop
        Ñ RESULT [J æ 1 ± RESULT = fact (J-1), RESULT = fact J] (1002)
    end loop;
∞
Now we can complete the implementation of the factorial function by providing the loop body:

πCN
  (1002) √
       RESULT := J * RESULT;
∞
\paragraph{Algorithm for Square Root} \label{SQRT}
For square root, we need two extra variables to implement a binary search for the square root.

πCN
(2) È
    MID, HI : INTEGER;
∞
The following just says that we propose to achieve the desired effect on $RESULT$ using $MID$ and $HI$ as well.
πCN
(2001) √
        Ñ RESULT, MID, HI
            [RESULT = 0, RESULT ** 2 º M < (RESULT + 1) ** 2] (2002)
∞
Now we give the initialisation for $HI$ and describe the loop which will find the square root:

πCN
(2002) √
       HI := M + 1;
       till ˚RESULT ** 2 º M < (RESULT + 1) ** 2˝
       loop
           Ñ RESULT, MID, HI
               [RESULT ** 2 º M < HI ** 2, RESULT ** 2 º M < HI ** 2] (2003)
       end loop;
∞
Now we implement the exit for the loop and specify the next step:
πCN
(2003) √
       exit when RESULT + 1 = HI;
       Ñ RESULT, MID, HI
            [RESULT ** 2 º M < HI ** 2, RESULT ** 2 º M < HI ** 2] (2004)
∞
Now we can fill in the last part of the loop:
πCN
(2004)    √ 
    MID := (RESULT + HI + 1) / 2;
    if      MID ** 2 > M
    then    HI := MID;
    else    RESULT := MID;
    end if;
∞
\paragraph{Digit Button Algorithm} \label{DIGBUT}
We now continue with the body of the digit button procedure.
An if-statement handling the two cases for updating the display, followed by an assignment to the flag should meet the bill here.
πCN
 (3001) √
    if    GV.IN_NUMBER
    then  GV.DISPLAY := GV.DISPLAY * TC.BASE + D;
    else  GV.DISPLAY := D;
    end if;
    GV.IN_NUMBER := true; 
∞
\paragraph{Operation Button Algorithm} \label{OPBUT}
We now complete the implementation and verification of the package $OPS$ by giving the body of the procedure for handling the operation buttons.

πCN
 (3002) √
    if      O = TC.CHANGE_SIGN
    then    GV.DISPLAY := -GV.DISPLAY;
    elsif   O = TC.FACTORIAL
    then    GV.DISPLAY := FACT(GV.DISPLAY);
    elsif   O = TC.SQUARE_ROOT
    then    GV.DISPLAY := SQRT(GV.DISPLAY);
    else    if      GV.LAST_OP = TC.EQUALS
            then    GV.ACCUMULATOR := GV.DISPLAY;
            elsif   GV.LAST_OP = TC.PLUS
            then   GV.ACCUMULATOR := GV.ACCUMULATOR + GV.DISPLAY;
            elsif   GV.LAST_OP = TC.MINUS
            then   GV.ACCUMULATOR := GV.ACCUMULATOR - GV.DISPLAY;
            elsif   GV.LAST_OP = TC.TIMES
            then   GV.ACCUMULATOR := GV.ACCUMULATOR * GV.DISPLAY;
            end if;
            GV.DISPLAY := GV.ACCUMULATOR;
            GV.LAST_OP := O;
    end if;
    GV.IN_NUMBER := false;
∞
=TEX
\pagebreak

\section{Proving the VCs} \label{CALCEXVCS}
The Compliance Tool has generated 37 VCs. The following list 
outlines where each group 
of VCs has come from, and proofs of a representative selection from
these groups are given below.

\begin{tabular}{l l l l}\\
\\ 
8& from the introduction of the package body:&$vcOPSbody_1$&\\
&&$vcOPSbody_2$&\\
&&$vcOPSbody_3$&\\
&&$vcOPSbody_4$&\\
&&$vcOPSbody_5$&\\
&&$vcOPSbody_6$&\\
&&$vcOPSbody_7$&\\
&&$vcOPSbody_8$&\\
&&&\\
4&from the introduction of supporting functions:&$vc500_1$&\\
&&$vc500_2$&\\
&&$vc500_3$&\\
&&$vc500_4$&\\
&&&\\
5&from the refinement steps in the body of $FACT$:&$vc1001_1$&\\
&&$vc1001_2$&\\
&&$vc1001_3$&\\
&&$vc1001_4$&\\
&&$vc1002_1$&\\
&&&\\
10&from the refinement steps in the body of $SQRT$:&$vc2001_1$&\\
&&$vc2001_2$&\\
&&$vc2002_1$&\\
&&$vc2002_2$&\\
&&$vc2002_3$&\\
&&$vc2003_1$&\\
&&$vc2003_2$&\\
&&$vc2003_3$&\\
&&$vc2004_1$&\\
&&$vc2004_2$&\\
&&&\\
2&from if-statement in the  digit button procedure:&$vc3001_1$&\\
&&$vc3001_2$&\\
&&&\\
8&from if-statement in the operations button procedure:&$vc3002_1$&1-3 from unary ops\\
&&$vc3002_2$&\\
&&$vc3002_3$&\\
&&$vc3002_4$&4-8 from binary ops\\
&&$vc3002_5$&\\
&&$vc3002_6$&\\
&&$vc3002_7$&\\
&&$vc3002_8$&\\
\end{tabular}

\pagebreak
\subsection{Preliminaries} \label{PRELIM}
The first thing to do is to generate the supporting theorems and supporting
proof context for the calculator example, as described in  
section \ref{STARTED}.
=SML
val calc_thms = all_cn_make_script_support "calc_cn";
=TEX
We will conduct the VC proofs in the proof context $cn1$; any  subsidiary
 general purpose results that we may need will be proved in
 the proof context $z_library1$. 

\subsection{Package Body VCs}
Eight VCs are produced from the 
introduction of the package body, see section \ref{PBODY}. These are trivial because the package body is derived directly from the package
specification. For example:
=GFT
vcOPSbody_1
	true ¥ true
=TEX

=GFT
vcOPSbody_2
	µ GVoDISPLAY, GVoDISPLAYâ0 : TCoNUMBER;
             GVoIN_NUMBER, GVoIN_NUMBERâ0 : BOOLEAN;
             D : TCoDIGIT | true ± DO_DIGIT ∑ DO_DIGIT
=TEX
$cn_vc_simp_tac$ will solve all of these  VCs. For example: 
=SML
set_pc"cn1";
set_goal([],get_conjecture"-""vcOPSbody_2");
a(cn_vc_simp_tac[]);
save_pop_thm"vcOPSbody_2";
=TEX

\subsection{Function Definition VCs}
These four VCs result from the requirement to show that the function bodies 
of $FACT$ and $SQRT$ achieve the statement of their specifications, see section \ref{FUNS}. For example:
=GFT
vc500_1
µ M : NATURAL ∑ M æ 0 ± 1 = 1
=TEX 

=GFT
vc500_2
FACT : NATURAL ≠ NATURAL; RESULT : NATURAL; M : NATURAL
             | true ± RESULT = fact M ± FACT M = RESULT
             ∑ FACT M = fact M
=TEX 
The proof of $vc500_1$  requires the following general purpose
lemma about SPARK natural numbers:

=SML
push_pc"z_library1";
set_goal([], Òµm : NATURAL∑ m æ 0Æ);
a(rewrite_tac[z_get_specÒNATURALÆ] THEN REPEAT strip_tac);
val natural_thm = save_pop_thm"natural_thm";
pop_pc();
=TEX
Now $cn_vc_simp_tac$ followed by forward chaining with $natural_thm$ 
will solve $vc500_1$:
=SML
set_goal([],get_conjecture"-""vc500_1");
a(cn_vc_simp_tac[]);
a(REPEAT strip_tac THEN all_fc_tac[natural_thm]);
save_pop_thm"vc500_1";
=TEX

After simplifying and stripping, $vc500_2$ is an example of predicate calculus with equality, see section \ref{EQUATIONS}, and is straightforward to prove using 
variable elimination, or just rewriting with the assumptions:
=SML
set_goal([],get_conjecture"-""vc500_2");
a(cn_vc_simp_tac[]);
a(REPEAT strip_tac);
a(all_var_elim_asm_tac1);
save_pop_thm"vc500_2";
=TEX

\subsection{$FACT$ Refinement Steps VCs}
The implementation of factorial  produces five VCs, see section \ref{FACT}. For example:
=GFT
vc1001_1
µ RESULT : NATURAL; M : NATURAL
  | (M æ 0 ± RESULT = 1) ± 2 º M
  ∑ 2 æ 1 ± RESULT = fact (2 - 1)
=TEX

=GFT
vc1001_2
µ RESULT : NATURAL; M : NATURAL
  | (M æ 0 ± RESULT = 1) ± 2 > M
  ∑ RESULT = fact M
=TEX

First, a general purpose
 lemma about the first two values of factorial (needed because our algorithm avoids the unnecessary pass through the loop with $J = 1$).
=SML
push_pc"z_library1";
set_goal([], Òfact 0 = 1 ± fact 1 = 1Æ);
a(rewrite_tac[z_get_specÒfactÆ,
	(rewrite_rule[z_get_specÒfactÆ] o z_µ_elimÒ0Æ o
			±_right_elim o ±_right_elim o z_get_spec)ÒfactÆ
]);
val fact_thm  = save_pop_thm"fact_thm";
pop_pc();
=TEX
To prove $vc1001_1$, simplify the VC, then strip and rewrite with $fact_thm$ 
and the assumptions:
=SML
set_goal([],get_conjecture"-""vc1001_1");
a(cn_vc_simp_tac[]);
a(REPEAT strip_tac THEN asm_rewrite_tac[fact_thm]);
save_pop_thm"vc1001_1";
=TEX

For $vc1001_2$, first simplify and then strip:

=SML
set_goal([],get_conjecture"-""vc1001_2");
a(cn_vc_simp_tac[]);
a(REPEAT strip_tac);
=TEX

=GFT ProofPower output
(* *** Goal "" *** *)

(*  5 *)  ÒRESULT ç NATURALÆ
(*  4 *)  ÒM ç NATURALÆ
(*  3 *)  Ò0 º MÆ
(*  2 *)  ÒRESULT = 1Æ
(*  1 *)  Ò≥ 2 º MÆ

(* ?Ù *)  ÒRESULT = fact MÆ

=TEX
Assumption 1 gives you $M\ =\ 0$ or $M\ =\ 1$, you will need 
the linear arithmetic proof context for this, then rewriting with $fact_thm$ 
completes the proof:
=SML
a(lemma_tacÒM = 0 ≤ M = 1Æ 
	THEN1 PC_T1"z_lin_arith"asm_prove_tac[]
	THEN asm_rewrite_tac[fact_thm]);
save_pop_thm"vc1001_2";
=TEX


\subsection{$SQRT$ Refinement Steps VCs}
The implementation of square root  produces ten VCs, see section \ref{SQRT}. Eight of them are trivial
and are proved by $cn_vc_simp_tac$. For example:

=GFT
vc2002_2
µ HI : INTEGER; RESULT, RESULTâ0 : NATURAL; M : NATURAL
  | RESULTâ0 = 0 ± RESULT ** 2 º M ± M < HI ** 2
  ∑ RESULT ** 2 º M ± M < HI ** 2
=TEX
=SML
set_goal([],get_conjecture"-""vc2002_2");
a(cn_vc_simp_tac[]);
save_pop_thm"vc2002_2";
=TEX


$vc2003_1$ also requires stripping and variable elimination to achieve a proof.
Extra work is needed in the proof of $vc2002_1$:
=GFT
vc2002_1
µ RESULT : NATURAL; M : NATURAL
             | RESULT = 0
             ∑ RESULT ** 2 º M ± M < (M + 1) ** 2
=TEX
This depends on some facts about the exponentiation operator, 
which you would probably provide as separate lemmas:
=SML
push_pc"z_library1";
set_goal([], Òµx: ˙∑  x ** 1 = xÆ);
a(REPEAT strip_tac);
a(rewrite_tac[rewrite_rule[](
    z_µ_elimÒ(x ¶ x, y ¶ 0)Æ (±_right_elim(z_get_specÒ(_**_)Æ)))]);
val star_star_1_thm = save_pop_thm"star_star_1_thm";
=TEX
=SML
set_goal([], Òµx: ˙∑  x ** 2 = x * xÆ);
a(REPEAT strip_tac);
a(rewrite_tac[star_star_1_thm, rewrite_rule[](
    z_µ_elimÒ(x ¶ x, y ¶ 1)Æ (±_right_elim(z_get_specÒ(_**_)Æ)))]);
val star_star_2_thm = save_pop_thm"star_star_2_thm";
pop_pc();
=TEX
To prove $vc2002_1$, first simplify the goal, strip the
assumptions and eliminate $RESULT$:

=SML
set_goal([], get_conjecture "-" "vc2002_1");
a(cn_vc_simp_tac[]);
a(REPEAT ¥_tac THEN all_var_elim_asm_tac1);
=TEX
=GFT ProofPower output
...
(*  2 *)  Ò0 ç NATURALÆ
(*  1 *)  ÒM ç NATURALÆ

(* ?Ù *)  Ò0 ** 2 º M ± ≥ (M + 1) ** 2 º MÆ
=TEX
Throw away the irrelevant assumption then forward chain with $natural_thm$:
=SML
a(DROP_NTH_ASM_T 2 discard_tac THEN all_fc_tac[natural_thm]);
=TEX
=GFT ProofPower output
...
(*  2 *)  ÒM ç NATURALÆ
(*  1 *)  Ò0 º MÆ

(* ?Ù *)  Ò0 ** 2 º M ± ≥ (M + 1) ** 2 º MÆ
=TEX
We no longer need assumption 2. Then rewriting with the assumptions and $star_star_2_thm$ will deal
with the first conjunct in the goal and expand the second:
=SML
a(DROP_NTH_ASM_T 2 discard_tac);
a(asm_rewrite_tac[star_star_2_thm]);
=TEX
The proof is progressed by induction on $M$:
=SML
a(z_º_induction_tacÒMÆ);
=TEX
=GFT ProofPower output
Tactic produced 2 subgoals:

(* *** Goal "2" *** *)

(*  2 *)  Ò0 º iÆ
(*  1 *)  Ò≥ (i + 1) * (i + 1) º iÆ

(* ?Ù *)  Ò≥ ((i + 1) + 1) * ((i + 1) + 1) º i + 1Æ


(* *** Goal "1" *** *)

(* ?Ù *)  Ò≥ (0 + 1) * (0 + 1) º 0Æ
=TEX
The first subgoal is proved by rewriting in the current proof context. The
second is proved automatically in the linear arithmetic proof context:
=SML
(* *** Goal "1" *** *)
a(rewrite_tac[]);
(* *** Goal "2" *** *)
a(PC_T1 "z_lin_arith" asm_prove_tac[]);
save_pop_thm "vc2002_1";
=TEX
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
=TEX
\subsection{Digit Button VCs}
Two VCs result from the if_statement in the digit button procedure, see section \ref{DIGBUT}. For example:
=GFT
µ GVoDISPLAY : TCoNUMBER; GVoIN_NUMBER : BOOLEAN; D : TCoDIGIT
             | true ± GVoIN_NUMBER = TRUE
             ∑ (D ¶ D, GVoDISPLAY ¶ GVoDISPLAY * TCoBASE + D,
                   GVoDISPLAYâ0 ¶ GVoDISPLAY, GVoIN_NUMBER ¶ TRUE,
                   GVoIN_NUMBERâ0 ¶ GVoIN_NUMBER)
               ç DO_DIGIT
=TEX
Both are proven by simplifying, stripping and then rewriting with
the definition of $DO_DIGIT$:

=SML
set_goal([],get_conjecture"-""vc3001_1");
a(cn_vc_simp_tac[]);
a(REPEAT strip_tac THEN asm_rewrite_tac[cn_DO_DIGIT_thm]);
save_pop_thm"vc3001_1";
=TEX


\subsection{Operations Button VCs}
Eight VCs result from the branches in the operations button procedure, 3 unary and 5 binary, see section \ref{OPBUT}. For example, the unary operation produces:
=GFT
vc3002_1
µ GVoDISPLAY, GVoACCUMULATOR : TCoNUMBER;
    GVoLAST_OP : TCoOPERATION;
    O : TCoOPERATION
  | true ± O eq TCoCHANGE_SIGN = TRUE
  ∑ (GVoACCUMULATOR ¶ GVoACCUMULATOR, 
	 GVoACCUMULATORâ0 ¶ GVoACCUMULATOR,
        GVoDISPLAY ¶ ~ GVoDISPLAY, GVoDISPLAYâ0 ¶ GVoDISPLAY,
        GVoIN_NUMBER ¶ FALSE, GVoLAST_OP ¶ GVoLAST_OP,
        GVoLAST_OPâ0 ¶ GVoLAST_OP, O ¶ O)
    ç DO_OPERATION
=TEX
To prove this VC, we do need to unwind the basic definitions, so we will
use the list of supporting theorems $calc_thms$ that we generated before starting
out on the proofs, section \ref{PRELIM}. (We could equally well have chosen 
to rewrite in the supporting proof context $calc_cn$ with no
additional theorems.) This proof gives an example of where $REPEAT\ strip_tac$ 
would be too brutal because it would generate many subgoals.

=SML
set_goal([], get_conjecture"-""vc3002_1");
a(cn_vc_simp_tac calc_thms);
a ¥_tac;
a(asm_rewrite_tac[]);
save_pop_thm"vc3002_1";
=TEX


The remaining two unary operations VCs require us to make the (reasonable) assumption that a non-negative number of the precision handled by the calculator will fit in a SPARK $NATURAL$.
This amounts to the following axiom:
πZ
‹ TCoMAX_NUMBER º INTEGERvLAST
∞
=SML
val number_ax = get_axiom"-""Constraint 1";
=TEX
To prove $vc3002_2$, apply the same tactics as for $vc3002_1$:
=SML
set_goal([], get_conjecture"-""vc3002_2");
a(cn_vc_simp_tac calc_thms);
a ¥_tac;
a(asm_rewrite_tac[]);
=TEX
=GFT ProofPower output
...
(* *** Goal "" *** *)

(* 10 *)  Ò~ 999999 º GVoDISPLAYÆ
(*  9 *)  ÒGVoDISPLAY º 999999Æ
(*  8 *)  Ò~ 999999 º GVoACCUMULATORÆ
(*  7 *)  ÒGVoACCUMULATOR º 999999Æ
(*  6 *)  Ò0 º GVoLAST_OPÆ
(*  5 *)  ÒGVoLAST_OP º 6Æ
(*  4 *)  Ò0 º OÆ
(*  3 *)  ÒO º 6Æ
(*  2 *)  Ò≥ O = 3Æ
(*  1 *)  ÒO = 5Æ

(* ?Ù *)  Ò0 º GVoDISPLAY ¥ FACT GVoDISPLAY = fact GVoDISPLAYÆ

=TEX
Then remove the redundant assumptions and strip the goal:
=SML
a(LIST_DROP_NTH_ASM_T[1,2,3,4,5,6,7,8,10] (MAP_EVERY discard_tac));
a strip_tac;
=TEX
=GFT ProofPower output
...
(* *** Goal "" *** *)

(*  2 *)  ÒGVoDISPLAY º 999999Æ
(*  1 *)  Ò0 º GVoDISPLAYÆ

(* ?Ù *)  ÒFACT GVoDISPLAY = fact GVoDISPLAYÆ
=TEX
All we need now is to add to the assumptions the fact that 
$GVoDISPLAY\ ç\ NATURAL$, then forward chain with the definition of $FACT$.
Notice that during the proof of the lemma we switch to the proof context
$calc_cn$ which contains the supporting theorems generated in section 
\ref{PRELIM}.
=SML
a(lemma_tac ÒGVoDISPLAY ç NATURALÆ);
(* *** Goal "1" *** *)
a(ante_tac number_ax);
a(PC_T1"calc_cn"asm_rewrite_tac[z_get_specÒNATURALÆ]);
a(DROP_NTH_ASM_T 2 ante_tac THEN PC_T1 "z_lin_arith" prove_tac[]);
(* *** Goal "2" *** *)
a(ALL_FC_T rewrite_tac[z_get_specÒFACTÆ]);
save_pop_thm"vc3002_2"; 
=TEX
The proof of $vc3002_3$ will be almost identical, except that the last 
step will be to forward chain with the definition of $SQRT$.

Because the binary operations only involve built-in arithmetic operators, they are a little easier to verify than the unary ones. For example the VC:
=GFT
vc3002_4
µ GVoDISPLAY, GVoACCUMULATOR : TCoNUMBER;
    GVoLAST_OP : TCoOPERATION;
    O : TCoOPERATION
  | true
    ± O eq TCoCHANGE_SIGN = FALSE
    ± O eq TCoFACTORIAL = FALSE
    ± O eq TCoSQUARE_ROOT = FALSE
    ± GVoLAST_OP eq TCoEQUALS = TRUE
  ∑ (GVoACCUMULATOR ¶ GVoDISPLAY, GVoACCUMULATORâ0 ¶ GVoACCUMULATOR,
        GVoDISPLAY ¶ GVoDISPLAY, GVoDISPLAYâ0 ¶ GVoDISPLAY,
        GVoIN_NUMBER ¶ FALSE, GVoLAST_OP ¶ O, GVoLAST_OPâ0 ¶ GVoLAST_OP,
        O ¶ O)
    ç DO_OPERATION
=TEX
will be proved by the following:
=SML
set_goal([], get_conjecture"-""vc3002_4");
a(PC_T1"calc_cn"cn_vc_simp_tac[]);
a(¥_tac THEN asm_rewrite_tac[]);
save_pop_thm"vc3002_4";
=TEX
The same proof will suffice for the remaining four binary operation VCs.


\appendix 

\chapter {CALCULATOR EXAMPLE THEORY} \label{CALCVCS}
\Hide{%
=SML
open_theory"usr503calc";
set_flag("pp_show_index",true);
z_output_theory{theory="usr503calc",out_file="usr503calc.thl.doc"};
=TEX
}
\input{usr503calc.thl.tex}

\pagebreak
\chapter {CALCULATOR EXAMPLE SPARK PROGRAM} \label{CALCSPARK}

=GFT
PACKAGE TC
IS
  BASE : CONSTANT INTEGER := 10;
  PRECISION : CONSTANT INTEGER := 6;
  MAX_NUMBER : CONSTANT INTEGER := BASE ** PRECISION - 1;
  MIN_NUMBER : CONSTANT INTEGER := -MAX_NUMBER;
  SUBTYPE DIGIT IS INTEGER RANGE 0..BASE - 1;
  SUBTYPE NUMBER IS INTEGER RANGE MIN_NUMBER..MAX_NUMBER;
  TYPE OPERATION IS 
    (PLUS, MINUS, TIMES, CHANGE_SIGN, SQUARE_ROOT, FACTORIAL, EQUALS);
END TC;

WITH TC;
PACKAGE GV
IS
  DISPLAY, ACCUMULATOR : TC.NUMBER;
  LAST_OP : TC.OPERATION;
  IN_NUMBER : BOOLEAN;
END GV;

WITH TC, GV;
PACKAGE OPS
IS
  PROCEDURE DIGIT_BUTTON (D : IN TC.DIGIT);
  PROCEDURE OPERATION_BUTTON (O : IN TC.OPERATION);
END OPS;
=TEX
\pagebreak
=GFT
PACKAGE BODY OPS
IS
  FUNCTION FACT (M : IN NATURAL) RETURN NATURAL
  IS
    RESULT : NATURAL;
  BEGIN
    RESULT := 1;
    FOR J IN INTEGER RANGE 2..M
    LOOP
      RESULT := J * RESULT;
    END LOOP;
    RETURN RESULT;
  END FACT;
 FUNCTION SQRT (M : IN NATURAL) RETURN NATURAL
  IS
    RESULT : NATURAL;
    MID, HI : INTEGER;
  BEGIN
    RESULT := 0;
    HI := M + 1;
    LOOP
      EXIT WHEN RESULT + 1 = HI;
      MID := (RESULT + HI + 1) / 2;
      IF MID ** 2 > M
      THEN
        HI := MID;
     ELSE
        RESULT := MID;
      END IF;
    END LOOP;
    RETURN RESULT;
  END SQRT;
  PROCEDURE DIGIT_BUTTON (D : IN TC.DIGIT)
  IS
  BEGIN
    IF GV.IN_NUMBER
    THEN
      GV.DISPLAY := GV.DISPLAY * TC.BASE + D;
    ELSE
      GV.DISPLAY := D;
    END IF;
    GV.IN_NUMBER := true;
  END DIGIT_BUTTON;
=TEX
\pagebreak
=GFT
  PROCEDURE OPERATION_BUTTON (O : IN TC.OPERATION)
  IS
  BEGIN
    IF O = TC.CHANGE_SIGN
    THEN
      GV.DISPLAY := -GV.DISPLAY;
    ELSIF O = TC.FACTORIAL
    THEN
      GV.DISPLAY := FACT(GV.DISPLAY);
    ELSIF O = TC.SQUARE_ROOT
    THEN
      GV.DISPLAY := SQRT(GV.DISPLAY);
  ELSE
      IF GV.LAST_OP = TC.EQUALS
      THEN
        GV.ACCUMULATOR := GV.DISPLAY;
      ELSIF GV.LAST_OP = TC.PLUS
      THEN
        GV.ACCUMULATOR := GV.ACCUMULATOR + GV.DISPLAY;
      ELSIF GV.LAST_OP = TC.MINUS
      THEN
        GV.ACCUMULATOR := GV.ACCUMULATOR - GV.DISPLAY;
      ELSIF GV.LAST_OP = TC.TIMES
      THEN
        GV.ACCUMULATOR := GV.ACCUMULATOR * GV.DISPLAY;
      END IF;
      GV.DISPLAY := GV.ACCUMULATOR;
      GV.LAST_OP := O;
    END IF;
   GV.IN_NUMBER := false;
  END OPERATION_BUTTON;
END OPS;
=TEX

\pagebreak

\chapter*{REFERENCES}

\addcontentsline{toc}{chapter}{REFERENCES}

\bibliographystyle{fmu}
\bibliography{fmu,daz}
 
\pagebreak
\twocolumn
\chapter*{INDEX}
\addcontentsline{toc}{chapter}{INDEX}
\small
 
\printindex

\end{document}


