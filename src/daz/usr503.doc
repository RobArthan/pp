% %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
% rash -W 6in -e usr503A.rs >usr503A.ps
% rash -W 6in -e usr503B.rs >usr503B.ps
% rash -W 6in -e usr503C.rs >usr503C.ps
% rash -W 6in -e usr503D.rs >usr503D.ps
\documentstyle[11pt,hol1,fleqn,USR,epsf]{book}
% temporary measure while waiting for LaTeXe to come along
\def\LaTeXe{\LaTeX$2_{\varepsilon}$}
\def\Hide#1{}
% Set the following macros as necessary as release
% numbers change.
\def\texrelease{\TeX\ version 3.1415}
\def\latexrelease{\LaTeXe}
\def\arch{sun4}
\def\solarisrelease{Solaris 2.3}
\def\motifrelease{Motif 1.2}
\def\polyrelease{Poly/ML 2.07MX}
\def\quicktexloc{{\tt /QLaTeX}} % NB one location needs this hard wired in
\def\daztool{Compliance Tool}
% just useful macros
\def\ltm{$^{\rm TM}$}
\def\Note#1{{\small\bf[ #1 ]}}
=IGN
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Proving VCs Using the Compliance Tool}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/USR503}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{Compliance Notation}
\TPPauthor{G.M.~Prout & WIN01}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & Project Manager}
\TPPabstract{
This document is a Tutorial Guide for the Compliance Tool Proof Facilities.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
\begin{tabular}[t]{lr}
A. Smith & DRA\\
Library & WIN01\\
\end{tabular}}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadcentre{}
%\def\TPPheadcentreproject{}
%\def\TPPheadrhs{}
\let\TPPfootlhs=\TPPfootrhs
\def\TPPfootcentre{$\vcenter{\halign{\hfil\strut##\hfil\cr
COPYRIGHT  \copyright\ ICL 1994\cr}}$}
=TEX
\ftlmargin 0.0in
\ftrmargin 0.0in

\def\SCCSversion{$Revision$%
}
\def\SCCSdate{\FormatDate{$Date$%
}}

\USRmanual{Proving VCs Using the Compliance Tool}
\USRref{USR503}

\raggedbottom
\ftlinepenalty=9999
\makeindex

\begin{document}
\makeUSRfrontpage

\underscoreoff

\chapter*{CONTENTS}

\tableofcontents
%\listoffigures

\pagebreak

\setcounter{chapter}{-1}

\chapter{ABOUT THIS PUBLICATION} \label{intro}
\section{Purpose}

This document gives guidance on the use of the Compliance Tool proof facilities supplied with {\Product}.

\section{Readership}
This document is intended to be read by users of the Compliance Tool who  wish  to  produce machine-checked proofs of some or all of the VCs generated by the tool. These users are expected to have experience of using {\Product} for proofs in Z; in particular they should be familiar with the material in the \ZTUTORIAL.

\section{Related Publications}

A bibliography is given towards the end of this document.

\begin{itemize}

\item
The Compliance Tool User Guide can be found in :

{\em Using the Compliance Tool} \cite{ISS/HAT/DAZ/USR501}.

\item
An overview of the  Compliance notation can be found in the DRA document:

{\em A commentary on the Specification of the Compliance Notation for SPARK and Z} \cite{DRA/CIS.SE2/PROJ/SWI/TR/1/1.0}.

\item
A description of \Product{} may be found in:

{\em \ {\SOFTSERV}},

which also contains a full list of other \Product{} documentation, in particular the \ZTUTORIAL.

\end{itemize}

\section{Area Covered}

The user will have already undertaken the following tasks:
\begin{enumerate}
\item
Installed the Compliance Tool on his workstation, by following the procedure described in {\em Compliance Tool Installation and Operation} \cite{ISS/HAT/DAZ/USR502}
\item
Loaded a Compliance Notation script into the tool and generated the Z document from the script, by following the procedure described in {\em Using the Compliance Tool} \cite{ISS/HAT/DAZ/USR501}
\end{enumerate}

This tutorial  should then assist the user in working with the VCs, i.e. attempting to prove them, using {\Product} and Compliance Tool facilities.

\section{Prerequisites}

This Tutorial is designed to assist a Compliance Tool user in the production of machine-checked proofs of the VCs generated by the tool. It is {\em not} intended to be an introduction to the Z language, or to the Compliance Notation, or indeed to the Compliance Tool itself.

Familiarity with Compliance Notation as specified in \cite{DRA/CIS/CSE3/TR/94/27/2.1} is very desirable, although not essential since VC proofs may be conducted independently without prior knowledge of the specification from which the VCs have been generated. Familiarity with the Compliance Tool and with the use of {\Product} for proofs in Z is essential. It is assumed that a user intent on using the Compliance Tool for proving VCs  will  be familiar with the material in both the  \ZTUTORIAL\ and {\em The Compliance Tool User Guide}, \cite{ISS/HAT/DAZ/USR501}.


A tool-independent description of the Compliance Notation is given in \cite{DRA/CIS.SE2/PROJ/SWI/TR/1/1.0}. {\em The Compliance Tool User Guide}, \cite{ISS/HAT/DAZ/USR501}, gives an introduction to the use of the Compliance Tool for loading a Compliance Notation Script and generating the Z document which contains the VCs.
The \ZTUTORIAL, gives an introduction to the use of {\Product} for specification and proof in Z. 

The {\Product} user documentation is supplied as part of the {\Product} release  included with the Compliance Tool and is available for on-line reference. 

The user interface to the tool described in this document is a Motif application  running under the X Windows System.
Users who are unfamiliar with X or Motif should consult local or supplier's documentation or expertise for further guidance (e.g. see \cite{sun92a}).



\section{Acknowledgements}
=IGN
The below are taken from Motif 1.2 Users Guide, July 1993
=TEX
Sun Microsystems is a registered trademark of Sun Microsystems Inc.  Sun-3, OpenWindows, Sun-4, SPARCstation, SunOS and Solaris are trademarks of Sun Microsystems Inc.

Motif is a registered trademark of the Open Software Foundation, Inc.

UNIX is a registered trademark of UNIX System Laboratories, Inc.

Poly/ML is an implementation of Standard ML with a few non-standard extensions.  Poly/ML, and its documentation, is copyright Abstract Hardware Limited.  

\TeX{} is copyright the American Mathematical Society and by Donald E. Knuth.
The \LaTeXe\ distribution tape is copyright the \LaTeX\ 3 project and its individual authors.

The X Windows System is a trademark of the Massachusetts Institute of Technology.

=TEX
\chapter{USING {\ProductZ} FOR PROOFS}\label{ZPROOFS}
A full account of using {\ProductZ} for proofs may be found in  the  \ZTUTORIAL.
While it is assumed that the reader is familiar with the material presented in the \ZTUTORIAL, for convenience a summary of the main methods advocated for dealing with Z proofs is given here:

\begin{enumerate}
\item
Proof by stripping. The tactic $strip_tac$ performs a variety of simplifications, and is often usefully applied at the outset of  embarking on a proof.  The simplifications achieved by
=INLINEFT
strip_tac
=TEX
{} include the following:
\begin{itemize}
\item moving the antecedent of an implication from the conclusion to the assumptions of the goal
\item proving tautologies
\item removing leading universal quantifiers
\item using, where possible, relevant assumptions in the assumption-list.
\end{itemize}

\item
Automatic proof. An automatic proof procedure is provided for each proof context which is usually capable of solving results reducible to the pure propositional calculus.
Even when the application of $prove_tac$ fails to prove a goal, it may have resulted in more simplification than would be obtained by other methods.
\item
Proof by the ``two tactic method''.
\item
Proof using forward chaining.
\item
Predicate Calculus with Equality.
\item
Rewriting.
\item
Function Application.
\end{enumerate}

The first two methods, which are complete for propositional logic may fail to solve some results in the pure predicate calculus.
For these a simple and systematic  approach known as the `two tactic' approach will suffice. This is described in section \ref{TWOTACTIC}. Alternatively, forward chaining, described in section \ref{FORWARD}, may suffice to obtain the result with less effort on the part of the user. The above facilities primarily support reasoning in the pure predicate calculus, and a proof using these facilities may fail by failing to exploit equations which could be used to complete the proof. Section \ref{EQUATIONS} describes some of the proof facilities available to make use of equations. Section \ref{REWRITE} provides an example of using rewriting techniques to progress a proof.


Finally, in more complicated cases the proof of the required conditions may be non-trivial, often because reasoning about membership of expressions formed with function application is involved. Section \ref{FUNCTIONS} describes some methods for reasoning in Z about  function application.

\section{The Two Tactic Method}\label{TWOTACTIC}

Proof by stripping is effective in discharging a goal only where the reasoning is mainly propositional.
Where the proof will depend either on appropriate specialisation of universally quantified assumptions, or on the choice of a suitable witness for proving an existential conclusion stripping will not suffice.

The two tactic method injects into the proof process based on stripping, user directed specialisation of universal assumptions.
In the context of a proof by contradiction (in which existential conclusions will not arise) this is sufficient to discharge any goals which are reduced to reasoning in the pure first order predicate calculus.

The method is therefore as follows:
=GFT SML
set_goal([],conjecture);
a contr_tac; 						(* once suffices *)
a (z_spec_asm_tac Ò assumption Æ Ò valueÆ);	(* as many times as necessary *)
=TEX
The choice of universal assumptions and of the values to specialise them to depends on the user identifying one or more specialisations which will result in the derivation of a contradiction from the assumptions. 

\section{Forward Chaining} \label{FORWARD}

Forward chaining facilities often provide an easier way of achieving proofs requiring instantiation of universal assumptions.

When a proof fails to be solved by $contr_tac$ alone, $all_asm_fc_tac$ may be capable progressing the proof.

$all_asm_fc_tac$ will attempt to instantiate universally quantified assumptions which are effectively implications to values which will enable forward inference to take place.
This is achieved by matching the antecedent of the implication against other assumptions.

If $contr_tac$ leaves goals outstanding, try progressing the proof using:

=GFT SML
a (all_asm_fc_tac[]); (* once or twice *)
=TEX

This may lead to the derivation of a contradiction with less effort from the user, however it will sometimes fail to solve a goal (and often generate a lot of irrelevant new asumptions).
If forward chaining is not heading anywhere useful, revert to the two tactic method.

A related tactic suitable for use with Z is $all_fc_tac$, which chains forward using implications derived from a list of theorems supplied as an argument, matching these against the assumptions, using the assumptions to match the antecedents of the implications.

$fc_tac$ and $asm_fc_tac$ are also useful (see \REFERENCE), but these are liable to introduce HOL universals, leaving a mixed language subgoal.

\section{Predicate Calculus with Equality}\label{EQUATIONS}

The above facilities primarily support reasoning in the pure predicate calculus, and a proof using these facilities may fail by failing to exploit equations which could be used to complete the proof.

A variety of additional proof facilities are available to make use of equations.

\begin{enumerate}
\item $asm_rewrite_tac$

may be used to cause equations in the assumptions to rewrite the conclusion of a subgoal.
This may sometimes prove sufficient to complete a proof.

\item $eq_sym_asm_tac$ or $eq_sym_nth_asm_tac$

may be used to turn round an equation in an assumption which is the wrong way round to achieve the required rewrite.

\item
$var_elim_asm_tac$ or $var_elim_nth_asm_tac$

may be used to completely eliminate from the subgoal occurrences of a variable which appears on one side of an equation in the specified assumption.
This causes the conclusion and all the other assumptions to be rewritten with the equation, eliminating occurrences of it.
The assumption will then be discarded.
These tactics will work whichever way round the equation appears in the assumption.

\item $all_var_elim_asm_tac$, $all_var_elim_asm_tac1$

automatically eliminate from the assumptions all equations of a sufficiently simple kind, by rewriting the subgoal with them and then discarding the equations.
They avoid eliminating equations where this might cause a looping rewrite.
The first variant only eliminates equations where both sides are either variables or constants, the second variant will eliminate any equation of which one side is a variable which does not appear on the other side.

\end{enumerate}


\section{Rewriting}\label{REWRITE}

Rewriting using any collection of theorems from which equations are derivable is supported by the standard HOL rewriting facilities ($rewrite_tac$ etc.), using Z specific preprocessing of the rewrite theorems (supplied in the Z proof contexts).

Many Z paragraphs give rise to predicates which can be used without further preparation by these standard rewriting facilities.
This applies to given sets, abbreviation definitions and schema definitions.

Axiomatic descriptions, and generic axiomatic descriptions will result in equations which are likely to be effectively conditional.
In such cases it is necessary to establish the applicability of the rewrite before it can be undertaken.

One way of achieving this is by forward chaining using the conditional equation after establishing the relevant condition.
The relevant conditions are usually the membership assertions corresponding to the declaration part of the outer universal quantifier on the theorem to be used for rewriting.

For example, to prove the goal:
=SML
set_pc "z_library";
set_goal([], Ò µ i:Ó ∑ abs i = abs ~iÆ);
=TEX
using theorem $z_abs_thm$ (which is :
=INLINEFT
Ù µ i : Ó ∑ abs i = i ± abs ~ i = i
=TEX
).
First strip the goal:
=SML
a (REPEAT z_strip_tac);
=GFT ProofPower output
...
(*  1 *)  Ò0 º iÆ

(* ?Ù *)  Òabs i = abs ~ iÆ
...
=TEX
Then forward chain using the theorem and rewrite with the results:
=SML
a (ALL_FC_T rewrite_tac [z_abs_thm]);
save_pop_thm "abs_eq_abs_minus_thm";
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX
In more complicated cases the proof of the required conditions may be non-trivial, often because reasoning about membership of expressions formed with function application is involved.
\section{Function Application}\label{FUNCTIONS}
Reasoning at a low level, $z_app_eq_tac$ may be used to reduce an equation involving an application to sufficient conditions for its truth, in terms of the membership of the function, e.g.:
=SML
set_goal([],Ò f a = vÆ);
a z_app_eq_tac;
=GFT ProofPower output
...
(* ?Ù *)  Ò(µ f_a : U | (a, f_a) ç f ∑ f_a = v) ± (a, v) ç fÆ
...
=TEX
The first conjunct of this result is needed to ensure that $f$ is functional at $a$ (i.e. maps $a$ to only one value).
In the case that $f$ is known to be a function, the theorem $z_fun_app_clauses$ may be used with forward chaining, avoiding the need to prove that $f$ is functional at $a$.
=GFT
val z_fun_app_clauses =
  Ù µ f : U; x : U; y : U; X : U; Y : U
    ∑ (f ç X ﬂ Y
          ≤ f ç X ˛ Y
          ≤ f ç X œ Y
          ≤ f ç X ≠ Y
          ≤ f ç X ‡ Y
          ≤ f ç X Ô Y
          ≤ f ç X è Y)
        ± (x, y) ç f
      ¥ f x = y : THM
=TEX
In this case the result $(a,v)\ ç\ f$ would have to be proven and added to the assumptions before undertaking the forward chaining, e.g.:
=SML
drop_main_goal();
set_goal([], Ò[X,Y](µ f : X ≠ Y; x:X; y:Y  ∑ (x, y) ç f ¥ f x = y)Æ);
a (REPEAT z_strip_tac);
=GFT ProofPower output
...
(*  4 *)  Òf ç X ≠ YÆ
(*  3 *)  Òx ç XÆ
(*  2 *)  Òy ç YÆ
(*  1 *)  Ò(x, y) ç fÆ

(* ?Ù *)  Òf x = yÆ
=SML
a (all_fc_tac [z_fun_app_clauses]);
pop_thm();
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
=TEX

A common problem is to have to establish that the value of some expression formed by application falls within some particular set.
This is often needed to establish the conditions necessary for use of a rewriting equation on the expression.

In these circumstances the theorem $z_fun_ç_clauses$ may be used:
=GFT
val z_fun_ç_clauses = Ù µ f : U; x : U; X : U; Y : U
 ∑ ((f ç X ≠ Y ≤ f ç X ‡ Y ≤ f ç X Ô Y ≤ f ç X è Y) ± x ç X
 	¥ f x ç Y)
 ± ((f ç X ﬂ Y ≤ f ç X ˛ Y ≤ f ç X œ Y) ± x ç dom f
 	¥ f x ç Y) : THM
=TEX
The claim that a global variable is a member of a function space will often be obtained from the specification of the constant (as part of the predicate implicit in the declaration part of the specification).
Where the function is an expression the result is likely to have been established by forward inference using similar methods.

For example, consider the following specifications:
πZ
[T1,T2]
∞

πZAX
‹CONSTSPEC : T1 Ô T2
˜
‹true
∞

where we are required to demonstrate that $CONSTSPEC$ applied to something of type $T1$ is indeed of type $T2$.

=SML
set_goal([], Ò(µ x:T1∑ CONSTSPEC x ç T2)Æ);
a (REPEAT z_strip_tac);
=GFT ProofPower output
...
(*  1 *)  Òx ç T1Æ

(* ?Ù *)  ÒCONSTSPEC x ç T2Æ
...
=TEX
We need the fact about $CONSTSPEC$ which is found in its defining declaration  to make the required inference.

This is added to the assumptions as follows:
=SML
a (strip_asm_tac (z_get_spec ÒCONSTSPECÆ));
=GFT ProofPower output
...
(*  2 *)  Òx ç T1Æ
(*  1 *)  ÒCONSTSPEC ç T1 Ô T2Æ

(* ?Ù *)  ÒCONSTSPEC x ç T2Æ
...
=TEX
Next we forward chain using the theorem $z_fun_ç_clauses$, which suffices to discharge the goal.
=SML
a (all_fc_tac [z_fun_ç_clauses]);
pop_thm();
=GFT ProofPower output
Tactic produced 0 subgoals:
Current and main goal achieved
...
=TEX

\chapter{VC PROOFS IN PARTICULAR}
When faced with the task of providing a formal proof to any conjecture, the first recommendation would always be to inspect the conjecture to establish whether or not one believes it to be true. The VC conjectures have been machine generated by the Compliance Tool, and as such are typically not the sort of conjectures that a human user would ``dream up''. In fact, some may prove to be trivially tautologically true. In sections \ref{VCPRED} and \ref{VCEXP} we give an overview of the predicates and expressions generated in VCs by way of illustrating the sort of constructs the user might expect to have to work with.



\subsection{Predicates Generated in VCs} \label{VCPRED}
An analysis of the Compliance Notation statements demonstrates that each sort of statement generates a VC of a particular form. The predicate structure of a VC is a single universally closed implication, give or take the complexity introduced by quantifiers supplied by the user in pre- and post- conditions. In practice, it is found that VCs are often universally quantified propositional tautologies or are amenable to useful, purely propositional, simplification. Consider, for example, the VCs for refinement of one specification statement by another.

Given this (simplified) specification statement:
πCN
 procedure vc_specification
 is
    X ;
 begin
  Ñ X [ PRE X, POST (X, Xâ0) ]		(1)
 end vc_specification;
∞
With this refinement step:
πCN
 (1) √  Ñ X [ PRE1 X, POST1 (X, Xâ0) ] (2)
∞

The generated VCs are:

=GFT
vc1_1		µ X : INTEGER | PRE X ∑ PRE1 X
vc1_2		µ X, Xâ0 : INTEGER
	  | PRE Xâ0 ± POST1 (X, Xâ0)
	  ∑ POST (X, Xâ0)
=TEX

If the two pre-conditions are the same, then the first of the two VCs will be a tautology. If the two post-conditions are the same then the second VC will be a tautology. If the pre- and post-conditions have common conjuncts, say $PRE = A \land B$, $PRE1 = A \land C$, $POST = A \land D$, $POST1 = A \land E$, then $A$ can be eliminated from the conclusion of both VCs.

Schematic examples of the various types of atomic predicate which appear are shown in the
following table:

\begin{centering}
\begin{tabular}{|l|l|}\hline
Predicate & Statement Type \\\hline
=INLINEFT
EXP = TRUE
=TEX
&
If, While
\\\hline
=INLINEFT
EXP = FALSE
=TEX
&
If, While
\\\hline
=INLINEFT
EXP ç SET
=TEX
&
Case
\\\hline
=INLINEFT
I ç EXP .. EXP
=TEX
&
For
\\\hline
=INLINEFT
I Ω EXP
=TEX
&
For
\\\hline
=INLINEFT
I º EXP
=TEX
&
For
\\\hline
=INLINEFT
I < EXP
=TEX
&
For
\\\hline
\end{tabular}

\end{centering}

Here $EXP$ is the result of translating a more or less arbitrary SPARK expression into Z, $I$ is a for-loop variable, and $SET$ is formed from integer constants using ranges, set displays and unions.

All but the first two of these atomic predicate forms are already tractable using the current {\Product} proof facilities.
The first two are handled in some cases quite straightforwardly by the proof context $cn$ provided with the current Compliance Tool.
However, in more complex cases some more assistance is needed.
E.g., consider
=INLINEFT
not F(X) = FALSE
=TEX
.
We would like to be able to recast this as $F(X) = TRUE$, however this can not currently be done automatically.
The problem arises because of the representation of SPARK booleans as numbers.
This means that the fact that 
=INLINEFT
not F(X) = FALSE § F(X)  = TRUE
=TEX
\ is actually conditional --- it only holds if
=INLINEFT
F(X) ç {0, 1}
=TEX
.
Now, if the expression comes from a well-typed SPARK expression, this condition will indeed be satisfied, but this fact currently needs to be established by hand before the predicates can be rewritten.

\subsection{Expressions Generated in VCs} \label{VCEXP}
Most of the expression forms which appear have already been listed in the discussion of atomic predicates in the previous section. The remaining forms are shown by schematic examples in the following table.

\begin{centering}
\begin{tabular}{|l|l|}\hline
Expression & Statement Type \\\hline
=INLINEFT
(A ¶ RHS, B ¶ LHS.B)
=TEX
&
Assignment
\\\hline
=INLINEFT
LHS ´ {INDEX Ì RHS}
=TEX
&
Assignment
\\\hline
=INLINEFT
LHS INDEX
=TEX
&
Assignment
\\\hline
=INLINEFT
(LHS INDEX).Y
=TEX
&
Assignment
\\\hline
=INLINEFT
I + 1
=TEX
&
For
\\\hline
\end{tabular}

\end{centering}

In fact, complex combinations of the first four forms are possible.

{\ProductZ} provides proof support for all these forms, although as outlined in section \ref{GENPUR}, the user may want to arm himself with his own tailor made lemmas before attempting the VC proofs.

\section{Getting Started}
{\em The Compliance Tool User Guide}, \cite{ISS/HAT/DAZ/USR501}, gives a comprehensive account of the Compliance Notation functions, in particular how to access the VCs generated by the tool from a literate script. We will assume  that a new daz database called, say,  {\tt mydatabase} has been created using a UNIX command line such as:

\begin{verbatim}
        pp_make_database -p pp_daz mydatabase
\end{verbatim}

Further, the formal material from a literate script {\tt myscript.doc} has been extracted using the UNIX command:

\begin{verbatim}
        docsml myscript
\end{verbatim}

and then loaded into the database, for example using the {\ProductML} command:

=GFT
	use_file "myscript";
=TEX

\section{Tackling the Proofs}
As ordinary Z goals, VCs may be proved using all of the normal facilities provided by {\Product} for proof in Z. Chapter \ref {ZPROOFS} provides an overview of the recommended techniques for using {\ProductZ} for doing proofs. 
In addition, many VCs use Z toolkit extensions which 
 are contained in the theory $cn$.
Some custom support is provided in the Compliance Tool to assist with reasoning in this theory, most notably the proof contexts $cn$ and $cn\_ext$.
These proof contexts and the other custom proof tools are described in section 6.1 of The Compliance Tool User Guide, \cite{ISS/HAT/DAZ/USR501}.
The user interface to the conversions etc. described there is via the proof contexts, so that most users will only need to be familiar with these proof contexts. The theorems in the proof context $cn$ convert the SPARK boolean and relational operators fairly directly into Z in a way that is transparent to the user. Additional theorems in the theory $cn$ are also available for reasoning about the numeric operators $intdiv$, $intmod$ and $rem$.
A full listing of the theory $cn$ is given in chapter \ref{TheTheorycn} at the
end of this document. 



The first step in the process of proving a VC is to set the proof context $cn$, and to set 
the VC, called, say, $vcn\_n$,  as a {\ProductZ} goal. 

The names of the VCs can be obtained from the current theory using $get\_conjectures\ "-"$.

=GFT
set_pc"cn";
set_goal([], get_conjecture"-""vcn_n");
=TEX

Next, the user might try the following (until the goal is achieved):

\begin{itemize}
\item
Inspect the VC to establish if it is a universally quantified tautology, as discussed in section \ref{VCPRED}. If so, an application of $z\_µ\_tac$ followed by $taut\_tac$ is all that is needed to prove it. 
\item
If not already a tautology, is a simple transformation  enough to achieve a tautology? For example  rewriting with $z\_plus\_assoc\_thm$. Then proceed as above.
\item
Try rewriting the goal before stripping followed by rewriting with (or
 forward chaining with) the assumptions. The effect of rewriting in the proof context $cn$ is to eliminate the vocabulary of the extended Z toolkit, for example $x\ eq\ y$ in favour of the plain Z toolkit construct $x\ =\ y$. 
\item
The above may not succeed if it generates an assumption which is
an equation with a variable on one side of it. Eliminating that variable throughout, with a variation on the theme of $var\_elim\_asm\_tac$, before 
using $asm\_rewrite\_tac$ or $asm\_fc\_tac$ may solve the goal.
\item
Some VCs may look provable by  stripping and rewriting, as described above, but the technique fails because the stripping needs to be controlled. For example, in the case where the same existential clause occurs in both the assumption and the conclusion of the goal, $REPEAT\ strip\_tac$ will destroy the existential that is stripped into the assumptions. Something like 
=INLINEFT
z_µ_tac THEN ¥_T (REPEAT_TTCL ±_THEN asm_tac)
=TEX
\ followed by $asm\_rewrite\_tac$ should do the trick.
\item
A For Loop Statement may give rise to a VC with an assumption which is quantified over a range $i\ ..\ i-1$. Such an assumption is false, and the application of $asm\_prove\_tac$ in the linear arithmetic proof context will suffice to prove the VC:

=INLINEFT
PC_T1"z_lin_arith"asm_prove_tac[]
=TEX

\item
The next level of proof requires expansion of definitions. This may be straightforward, or may require more subtle use of the definitions.
For example, the use of case-selection criteria for membership of a schema conjunction. Typically the user will find it advantageous to prove subsidiary  lemmas before embarking upon the VC proof.
These are either general purpose lemmas that are not available in {\ProductZ} but can easily be proven with the proof support available, or they are application specific. Such lemmas are proven separately either because they are results that are found to be needed repeatedly during the process of proving the VCs, or because proving them in isolation is simpler than proving them in the context of a VC proof. Actually, in practice, it is common to experience a sense of {\em deja vu} when in the middle of a proof. A user finds that he needs a result that he has already proved in an earlier VC proof, and it is at that stage that he decides to backtrack and  extract the bits from the previous proof as a separate lemma.
Sections \ref{GENPUR} and \ref{APPSPEC} provide an overview of the sort of subsidiary lemmas that might typically be useful.
\end{itemize}


\subsection{General Purpose Lemmas} \label{GENPUR}

Two examples of the sort of result a user might require are provied:
\begin{enumerate}
\item
In section \ref{VCPRED} and \ref{VCEXP} there is a discussion about the way particular SPARK constructs are translated into Z. For example, the occurrence of functional overrides in the VCs arise from SPARK array assignments. The 
following lemma may prove useful:
=GFT
´_lemma
Ù [X,Y,Z](µ f : X ≠ Y ≠ Z; x : X; y : Y; z : Z
    ∑ (f ´ {x Ì f x ´ {y Ì z}}) x y = z)
=TEX

This does not exist as a theorem in {\ProductZ}, but is straightforward to prove using $z\_app\_eq\_tac$ and $z\_fun\_ç\_clauses$, 
as described in section \ref{FUNCTIONS}. 
\item
Another class of problem has already been identified in section \ref{VCPRED}. The proof context $cn$ deals with SPARK booleans, but there are circumstances when $cn$ is unable to do as much as the user wants. Where he would
like to have 
=INLINEFT
not F(X) = FALSE
=TEX
\ recast by the more natural
=INLINEFT
F(X) = TRUE
=TEX
, this can not be done automatically in $cn$. (The result is dependent on F(X) being boolean.) A useful general purpose lemma for where this sort of result is required is:
=GFT
bool_lemma
µ X:BOOLEAN∑not X = Boolean true § X  = Boolean false 
=TEX
\end{enumerate}

Both of these examples are followed up in the next section. 


\subsection{Application Specific Lemmas} \label{APPSPEC}
The sort of application specific lemmas a user might require clearly depends on the sort of SPARK constructs that have been used. Two examples are:
\begin{enumerate}
\item
\subsubsection*{Set Membership of Record Fields}
The form of this class of lemma is  
=INLINEFT
X.field ç set
=TEX
, which arises from indexing into an array of 
records in SPARK. In particular, if the set is $BOOLEAN$ then forward chaining  this result with $bool\_lemma$, from section \ref{GENPUR}, would give
=INLINEFT
not X = Boolean true § X  = Boolean false 
=TEX
.
\item
\subsubsection*{Record a Member of Record Set}
The form of this class of lemma is 
=INLINEFT
(x ¶ x1,y ¶ y1,...) ç set of recs
=TEX
, which arises from assignment to an array of 
records in SPARK. Suppose the usere wants to use $´\_lemma$ from section \ref{GENPUR} in the case where the $z$ in question is a record. This must 
be proven to be of type $Z$, a record set in this case, before $´\_lemma$ is applicable.
\end{enumerate}

\subsection{Closing Remarks}
Some insight as to ``what to do next'' may be gleaned from chapter  \ref{ZPROOFS}. The degree of difficulty experienced in proving VCs that require delving into the definitons depends largely on the size and obscurity of the refinement steps which generated the VCs in the first place.

It is worth remembering at this time that there is always the possibility that
the VC in question may not be true, or more likely, may not be provable. The user would do well to spend a few minutes at the outset in convincing himself that he had a fair chance of achieving
a proof. A plausible scenario is one where the pre- and post- conditions of a refinement statement are too weak to prove the VC.

\pagebreak

\chapter{THE THEORY $cn$}\label{TheTheorycn}
The following is the listing of the theory $cn$ which consists of the extensions to the Z toolkit required for the DAZ Compliance Tool together with theorems and proof procedures which provide support for reasoning about objects defined in the theory.
=THEORYLISTINGSECTION
Parents
=TEX
=THEORYLISTINGTABLE
	z_library
=TEX
=THEORYLISTINGSECTION
Children
=TEX
=THEORYLISTINGTABLE
	cache'daz
=TEX
=THEORYLISTINGSECTION
Global Variables
=TEX
=THEORYLISTINGOTHER
€FALSE›	˙
€TRUE›	˙
€BOOLEAN›	 ˙
€BOOLEANvFIRST›
	˙
€BOOLEANvLAST›
	˙
€BOOLEANvSUCC›
	˙ ™ ˙
€BOOLEANvPRED›
	˙ ™ ˙
€BOOLEANvPOS›
	˙ ™ ˙
€BOOLEANvVAL›
	˙ ™ ˙
€(_ and _)›	˙ ∏ ˙ ™ ˙
€(_ or _)›	˙ ∏ ˙ ™ ˙
€(_ xor _)›	˙ ∏ ˙ ™ ˙
€(not _)›	˙ ™ ˙
€(_ eq _)[X]›
	X ∏ X ™ ˙
€(_ noteq _)[X]›
	X ∏ X ™ ˙
€(_ mem _)[X]›
	X ∏  X ™ ˙
€(_ notmem _)[X]›
	X ∏  X ™ ˙
€(_ less _)›	˙ ∏ ˙ ™ ˙
€(_ less_eq _)›
	˙ ∏ ˙ ™ ˙
€(_ greater _)›
	˙ ∏ ˙ ™ ˙
€(_ greater_eq _)›
	˙ ∏ ˙ ™ ˙
€(_ intdiv _)›
	˙ ∏ ˙ ™ ˙
€(_ rem _)›	˙ ∏ ˙ ™ ˙
€(_ intmod _)›
	˙ ∏ ˙ ™ ˙
€(_ ** _)›	˙ ∏ ˙ ™ ˙
€INTEGER›	 ˙
€INTEGERvSUCC›
	˙ ™ ˙
€INTEGERvPRED›
	˙ ™ ˙
€INTEGERvPOS›
	˙ ™ ˙
€INTEGERvVAL›
	˙ ™ ˙
€INTEGERvFIRST›
	˙
€INTEGERvLAST›
	˙
€NATURAL›	 ˙
€NATURALvFIRST›
	˙
€NATURALvLAST›
	˙
€NATURALvSUCC›
	˙ ™ ˙
€NATURALvPRED›
	˙ ™ ˙
€NATURALvPOS›
	˙ ™ ˙
€NATURALvVAL›
	˙ ™ ˙
€POSITIVE›	 ˙
€POSITIVEvFIRST›
	˙
€POSITIVEvLAST›
	˙
€POSITIVEvSUCC›
	˙ ™ ˙
€POSITIVEvPRED›
	˙ ™ ˙
€POSITIVEvPOS›
	˙ ™ ˙
€POSITIVEvVAL›
	˙ ™ ˙
€LONG_INTEGER›
	 ˙
€LONG_INTEGERvSUCC›
	˙ ™ ˙
€LONG_INTEGERvPRED›
	˙ ™ ˙
€LONG_INTEGERvPOS›
	˙ ™ ˙
€LONG_INTEGERvVAL›
	˙ ™ ˙
€LONG_INTEGERvFIRST›
	˙
€LONG_INTEGERvLAST›
	˙
€SHORT_INTEGER›
	 ˙
€SHORT_INTEGERvSUCC›
	˙ ™ ˙
€SHORT_INTEGERvPRED›
	˙ ™ ˙
€SHORT_INTEGERvPOS›
	˙ ™ ˙
€SHORT_INTEGERvVAL›
	˙ ™ ˙
€SHORT_INTEGERvFIRST›
	˙
€SHORT_INTEGERvLAST›
	˙
€CHARACTER›	 CHARACTER
€STRING›	 (˙ ™ CHARACTER)
€Boolean›	BOOL ™ ˙
=TEX
=THEORYLISTINGSECTION
Fixity
=TEX
=THEORYLISTINGTABLE
€fun 0›	(not _)	(_ and _)	(_ or _)	(_ xor _)
=TEX
=THEORYLISTINGTABLE
€fun 1›	(_ eq _)	(_ mem _)	(_ noteq _)	(_ notmem _)
=TEX
=THEORYLISTINGTABLE
€fun 2›	(_ greater _)	(_ less _)
	(_ greater_eq _)	(_ less_eq _)
=TEX
=THEORYLISTINGTABLE
€fun 4›	(_ intdiv _)	(_ intmod _)	(_ rem _)
=TEX
=THEORYLISTINGTABLE
€fun 5›	(_ ** _)
=TEX
=THEORYLISTINGSECTION
Axioms
=TEX
=THEORYLISTINGOTHER
€_ and _›
€_ or _›
€_ xor _›
€not _›	Ù ((not _) ç BOOLEAN ≠ BOOLEAN
	    ± {(_ and _), (_ or _), (_ xor _)}
	        Ä BOOLEAN ∏ BOOLEAN ≠ BOOLEAN)
	    ± (µ b : BOOLEAN
	      ∑ not FALSE = TRUE
	        ± not TRUE = FALSE
	        ± (b and FALSE = FALSE
	        ± b and TRUE = b)
	        ± (b or FALSE = b
	        ± b or TRUE = TRUE)
	        ± b xor FALSE = b
	        ± b xor TRUE = not b)
€_ eq _›
€_ noteq _›
€_ mem _›
€_ notmem _›	Ù [X](({(_ mem _)[X], (_ notmem _)[X]}
	        Ä X ∏  X ≠ BOOLEAN
	    ± {(_ eq _)[X], (_ noteq _)[X]} Ä X ∏ X ≠ BOOLEAN)
	    ± (µ x, y : X; S :  X; b : BOOLEAN
	      ∑ (b = (_ mem _)[X] (x, S) § b = TRUE § x ç S)
	        ± (b = (_ notmem _)[X] (x, S)
	          § b = TRUE
	          § x é S)
	        ± (b = (_ eq _)[X] (x, y) § b = TRUE § x = y)
	        ± (b = (_ noteq _)[X] (x, y)
	          § b = TRUE
	          § x Ω y)))
€_ less _›
€_ less_eq _›
€_ greater _›
€_ greater_eq _›
	Ù {(_ less _),
	        (_ less_eq _),
	        (_ greater _),
	        (_ greater_eq _)}
	        Ä ˙ ∏ ˙ ≠ BOOLEAN
	    ± (µ x, y : ˙; b : BOOLEAN
	      ∑ (b = x less y § b = TRUE § x < y)
	        ± (b = x less_eq y § b = TRUE § x º y)
	        ± (b = x greater y § b = TRUE § x > y)
	        ± (b = x greater_eq y § b = TRUE § x æ y))
=TEX
\pagebreak
=THEORYLISTINGOTHER
€_ intdiv _›
€_ rem _›
€_ intmod _›	Ù {(_ intdiv _), (_ rem _), (_ intmod _)}
	        Ä ˙ ∏ ˙ \ {0} ≠ ˙
	    ± (µ x, y : ˙
	      | y Ω 0
	      ∑ (x * y æ 0 ¥ x intdiv y = abs x div abs y)
	        ± (x * y < 0
	          ¥ x intdiv y = ~ (abs x div abs y))
	        ± x rem y = x - (x intdiv y) * y
	        ± (x * y æ 0 ≤ x rem y = 0
	          ¥ x intmod y = x rem y)
	        ± (x * y < 0 ± x rem y Ω 0
	          ¥ x intmod y = x rem y + y))
€_ ** _›	Ù (_ ** _) ç ˙ ∏ Ó ≠ ˙
	    ± (µ x : ˙; y : Ó
	      ∑ x ** 0 = 1 ± x ** (y + 1) = x * x ** y)
€INTEGER›	Ù INTEGER ç  ˙ ± true
€INTEGERvSUCC›
€INTEGERvPRED›
€INTEGERvPOS›
€INTEGERvVAL›
€INTEGERvFIRST›
€INTEGERvLAST›
	Ù ({INTEGERvFIRST, INTEGERvLAST} Ä ˙
	    ± {INTEGERvSUCC,
	        INTEGERvPRED,
	        INTEGERvPOS,
	        INTEGERvVAL}
	        Ä ˙ ﬂ ˙)
	    ± true
€LONG_INTEGER›
	Ù LONG_INTEGER ç  ˙ ± true
€LONG_INTEGERvSUCC›
€LONG_INTEGERvPRED›
€LONG_INTEGERvPOS›
€LONG_INTEGERvVAL›
€LONG_INTEGERvFIRST›
€LONG_INTEGERvLAST›
	Ù ({LONG_INTEGERvFIRST, LONG_INTEGERvLAST} Ä ˙
	    ± {LONG_INTEGERvSUCC,
	        LONG_INTEGERvPRED,
	        LONG_INTEGERvPOS,
	        LONG_INTEGERvVAL}
	        Ä ˙ ﬂ ˙)
	    ± true
€SHORT_INTEGER›
	Ù SHORT_INTEGER ç  ˙ ± true
€SHORT_INTEGERvSUCC›
€SHORT_INTEGERvPRED›
€SHORT_INTEGERvPOS›
€SHORT_INTEGERvVAL›
€SHORT_INTEGERvFIRST›
€SHORT_INTEGERvLAST›
	Ù ({SHORT_INTEGERvFIRST, SHORT_INTEGERvLAST} Ä ˙
	    ± {SHORT_INTEGERvSUCC,
	        SHORT_INTEGERvPRED,
	        SHORT_INTEGERvPOS,
	        SHORT_INTEGERvVAL}
	        Ä ˙ ﬂ ˙)
	    ± true
€STRING›	Ù STRING ç  (POSITIVE ﬂ CHARACTER) ± true
€Boolean›	Ù Boolean ç BOOL ≠ BOOLEAN
	    ± Boolean true = TRUE
	    ± Boolean false = FALSE
=TEX
=THEORYLISTINGSECTION
Definitions
=TEX
=THEORYLISTINGOTHER
€FALSE›	Ù FALSE = 0
€TRUE›	Ù TRUE = 1
€BOOLEAN›	Ù BOOLEAN = FALSE .. TRUE
€BOOLEANvFIRST›
	Ù BOOLEANvFIRST = FALSE
€BOOLEANvLAST›
	Ù BOOLEANvLAST = TRUE
€BOOLEANvSUCC›
	Ù BOOLEANvSUCC = (BOOLEAN \ {BOOLEANvLAST}) Ú succ
€BOOLEANvPRED›
	Ù BOOLEANvPRED = BOOLEANvSUCC Á~Í
€BOOLEANvPOS›
	Ù BOOLEANvPOS = id BOOLEAN
€BOOLEANvVAL›
	Ù BOOLEANvVAL = BOOLEANvPOS Á~Í
€NATURAL›	Ù NATURAL = 0 .. INTEGERvLAST
€NATURALvFIRST›
	Ù NATURALvFIRST = 0
€NATURALvLAST›
	Ù NATURALvLAST = INTEGERvLAST
€NATURALvSUCC›
	Ù NATURALvSUCC = INTEGERvSUCC
€NATURALvPRED›
	Ù NATURALvPRED = INTEGERvPRED
€NATURALvPOS›
	Ù NATURALvPOS = INTEGERvPOS
€NATURALvVAL›
	Ù NATURALvVAL = INTEGERvVAL
€POSITIVE›	Ù POSITIVE = 1 .. INTEGERvLAST
€POSITIVEvFIRST›
	Ù POSITIVEvFIRST = 1
€POSITIVEvLAST›
	Ù POSITIVEvLAST = INTEGERvLAST
€POSITIVEvSUCC›
	Ù POSITIVEvSUCC = INTEGERvSUCC
€POSITIVEvPRED›
	Ù POSITIVEvPRED = INTEGERvPRED
€POSITIVEvPOS›
	Ù POSITIVEvPOS = INTEGERvPOS
€POSITIVEvVAL›
	Ù POSITIVEvVAL = INTEGERvVAL
€CHARACTER›	Ù CHARACTER = U
=TEX
=THEORYLISTINGSECTION
Theorems
=TEX
=THEORYLISTINGOTHER
€cn_boolean_thm›
	Ù BOOLEAN = {FALSE, TRUE}
€cn_boolean_succ_thm›
	Ù BOOLEANvSUCC = {FALSE Ì TRUE}
€cn_boolean_pred_thm›
	Ù BOOLEANvPRED = {TRUE Ì FALSE}
€cn_boolean_pos_thm›
	Ù BOOLEANvPOS = id BOOLEAN
€cn_boolean_val_thm›
	Ù BOOLEANvVAL = id BOOLEAN
€cn_≥_true_eq_false_thm›
	Ù ≥ TRUE = FALSE
€cn_boolean_cases_thm›
	Ù µ x : BOOLEAN ∑ x = TRUE ≤ x = FALSE
€cn_boolean_clauses›
	Ù TRUE = Boolean true
	    ± FALSE = Boolean false
	    ± (µ p : U ∑ not Boolean p = Boolean (≥ p))
	    ± (µ p, q : U
	      ∑ Boolean p and Boolean q = Boolean (p ± q))
	    ± (µ p, q : U
	      ∑ Boolean p or Boolean q = Boolean (p ≤ q))
	    ± (µ p, q : U
	      ∑ Boolean p xor Boolean q = Boolean (≥ (p § q)))
	    ± (µ p, q : U ∑ Boolean p = Boolean q § p § q)
€cn_relational_clauses›
	Ù (µ x : U; S : U ∑ x mem S = Boolean (x ç S))
	    ± (µ x : U; S : U ∑ x notmem S = Boolean (≥ x ç S))
	    ± (µ x, y : U ∑ x eq y = Boolean (x = y))
	    ± (µ x, y : U ∑ x noteq y = Boolean (≥ x = y))
	    ± (µ x, y : U ∑ x less y = Boolean (x < y))
	    ± (µ x, y : U ∑ x less_eq y = Boolean (x º y))
	    ± (µ x, y : U ∑ x greater y = Boolean (x > y))
	    ± (µ x, y : U ∑ x greater_eq y = Boolean (x æ y))
=TEX
\pagebreak
=THEORYLISTINGOTHER
€cn_intdiv_0_thm›
	Ù µ j : ˙
	    | ≥
	    j = 0
	    ∑ 0 intdiv j = 0 ± 0 rem j = 0 ± 0 intmod j = 0
€cn_intdiv_thm›
	Ù µ i, j, k : ˙
	    | ≥
	    j = 0
	    ∑ i intdiv j = k
	      § (∂ m : ˙
	        ∑ i = k * j + m
	          ± abs m < abs j
	          ± (0 º i ± 0 º m ≤ i < 0 ± m º 0))
€cn_rem_thm›	Ù µ i, j, k : ˙
	    | ≥
	    j = 0
	    ∑ i rem j = k
	      § (∂ d : ˙
	        ∑ i = d * j + k
	          ± abs k < abs j
	          ± (0 º i ± 0 º k ≤ i < 0 ± k º 0))
€cn_intmod_thm›
	Ù µ i, j, k : ˙
	    | ≥
	    j = 0
	    ∑ i intmod j = k
	      § (∂ d : ˙
	        ∑ i = d * j + k
	          ± abs k < abs j
	          ± (0 º j ± 0 º k ≤ j < 0 ± k º 0))
=TEX
=THEORYLISTINGTRAILER
End of listing of theory cn
=TEX


\pagebreak

\chapter*{REFERENCES}

\addcontentsline{toc}{chapter}{REFERENCES}

\bibliographystyle{fmu}
\bibliography{fmu,daz}
 
\pagebreak
\twocolumn
\chapter*{INDEX}
\addcontentsline{toc}{chapter}{INDEX}
\small
 
\printindex

\end{document}


