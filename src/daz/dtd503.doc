%  dtd503.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Compliance Notation Parser}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD503}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{
This document contains the detailed design for the
DAZ parser.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.4] Initial Draft.
\item[Issue \SCCSversion~\FormatDate{$Date$%
}) ] Changed Names to be for Compliance Notation.

\end{description}
\subsection{Changes Forecast}
The phase 2 checks and transformations are yet to be documented.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the Compliance Notation parser.

It includes the Compliance Notation grammar in the format required by the {\tt SLRP} parser generator.

\subsection{Introduction}
The DRA document \cite{DRA/CIS/CSE3/SWI/WP/9} gives the grammar for the  Compliance Notation.
This document re-expresses that grammar in the format required by the {\tt SLRP} parser generator.
For easy comparison, cross-references with the SPARK manual (SM \cite{PVL90}) (and  hence with the Ada Language Reference Manual) have been added where appropriate.

 

\subsubsection{Purpose and Background}


\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{DESIGN ISSUES}

\section{PREAMBLE}
=DOC
signature €CNParser› = sig
=DESCRIBE
This is the signature for the structure containing the parser for SPARK.
=ENDDOC

\section{GRAMMAR}

This grammar is based on that specified in \cite{DRA/CIS/CSE3/SWI/WP/9}.

Z paragraphs are supported by \Product\/  and a production branch in
the $web\_clause$ is not required.

The entry point to the grammar (sentence symbol) is placed first, because that is where {\tt SLRP} expects to find it.

=DUMP dtd503.grm.txt
€web_clause› =	compilation
		|	`CompLabel`, `ReplacedBy`, compilation
		|	`PPartLabel`, `ReplacedBy`, private_part
		|	`VPartLabel`, `ReplacedBy`, visible_part
		|	`DecLabel`, `ReplacedBy`, dec, dp1
		|	`StmtLabel`, `ReplacedBy`, sequence_of_statements
		|	`SpecLabel`, `RefinedBy`, sequence_of_statements
		|	`RefinedBy`, sequence_of_statements
		|	`SpecLabel`, `ReplacedBy`, sequence_of_statements
		|	`ReplacedBy`, sequence_of_statements;
=TEX
SPARK manual 3.1:
=DUMPMORE dtd503.grm.txt

€basic_declaration› =	object_declaration
		|	type_declaration
		|	subtype_declaration
		|	deferred_constant_declaration;
=TEX
SPARK manual 3.2:
=DUMPMORE dtd503.grm.txt

€object_declaration› =	constant_declaration
			|	variable_declaration;
=TEX
SPARK manual 3.2:
=DUMPMORE dtd503.grm.txt

€constant_declaration› =	identifier_list, `Colon`, `Constant`,
				type_mark, `Becomes`, expression, `Semi`;
	
€variable_declaration› =	identifier_list, `Colon`, type_mark, `Semi`;

€identifier_list› =	`Identifier`, id_list;

€id_list›	=
		|	`Comma`, identifier_list;
(* **** should be able to elide id_list again as in SPARK manual **** *)
=TEX
SPARK manual 3.3.1:
=DUMPMORE dtd503.grm.txt
€type_declaration› =	full_type_declaration
		|	private_type_declaration;

€full_type_declaration› =	`Type`, `Identifier`, `Is`, type_definition, `Semi`;

€type_definition› =	enumeration_type_definition
		|	integer_type_definition
		|	real_type_definition
		|	array_type_definition
		|	record_type_definition;
=TEX
SPARK manual 3.3.2:
=DUMPMORE dtd503.grm.txt
€subtype_declaration› =	`SubType`, `Identifier`, `Is`, subtype_indication, `Semi`;

€subtype_indication› =	type_mark, constraint;

(* **** type_mark is just a name **** *)

€constraint›	=	range_constraint
		|	floating_point_constraint
		|	fixed_point_constraint
		|	index_constraint;
=TEX
SPARK manual 3.5:
=DUMPMORE dtd503.grm.txt
€range_constraint› =	`RRange`, range;

€range› =	simple_expression
		|	simple_expression, `DotDot`, simple_expression;

(* **** Don't understand: first alternative should be attribute **** *)
=TEX
SPARK manual 3.5.1:
=DUMPMORE dtd503.grm.txt

€enumeration_type_definition› =
			`Ord`, identifier_list, `Crd`;
=TEX
SPARK manual 3.5.4:
=DUMPMORE dtd503.grm.txt

€integer_type_definition› =
			range_constraint;
=TEX
SPARK manual 3.5.6:
=DUMPMORE dtd503.grm.txt

€real_type_definition› =	floating_point_constraint
			|	fixed_point_constraint;
=TEX
SPARK manual 3.5.7:
=DUMPMORE dtd503.grm.txt

€floating_point_constraint› =
			floating_accuracy_definition
		|	floating_accuracy_definition, range_constraint;

€floating_accuracy_definition› =
			`Digits`, simple_expression;
=TEX
SPARK manual 3.5.9:
=DUMPMORE dtd503.grm.txt

€fixed_point_constraint› =
			fixed_accuracy_definition
		|	fixed_accuracy_definition, range_constraint;

€fixed_accuracy_definition› =
			`Delta`, simple_expression;
=TEX
SPARK manual 3.6:
=DUMPMORE dtd503.grm.txt

€array_type_definition› =	unconstrained_array_definition
			|	constrained_array_definition;

€unconstrained_array_definition› =
			`Array`, `Ord`, index_subtype_definition_list, `Crd`, `Of`, type_mark;

€constrained_array_definition› =
			`Array`, index_constraint, `Of`, type_mark;

€index_subtype_definition_list› =
			index_subtype_definition, subtype_list;

€subtype_list› =
		|	`Comma`, index_subtype_definition_list;

(* **** should be able to elide subtype_list again as in SPARK manual **** *)

€index_subtype_definition› =
			type_mark, `RRange`, `LessGreat`;

€index_constraint› =	`Ord`, type_mark_list, `Crd`;

€type_mark_list› =	type_mark, type_list;

€type_list› =
		|	`Comma`, type_mark_list;
(* **** n.b.may want to identify type_mark_list with name list or similar **** *)

€discrete_range› =	type_mark
		|	type_mark, range_constraint
		|	range;
=TEX
SPARK manual 3.7:
=DUMPMORE dtd503.grm.txt

€record_type_definition› =
			`Record`, component_list, `End`, `Record`;

€component_list› =	component_declaration, comp_list;

€comp_list› =
		|	`Comma`, component_list;

€component_declaration› =	identifier_list, `Colon`, type_mark, `Semi`;
=TEX
SPARK manual 3.9:
=DUMPMORE dtd503.grm.txt

€declarative_part› =	dec, dp1;

€dp1› =
		|	dec, dp1;
(* **** Insisting on at least one declaration seems odd **** *)
(* **** dp1 could be elided **** *)

€dec› =		`KSlot`
		|	renaming_declaration
		|	basic_declarative_item
		|	package_declaration
		|	body;

€basic_declarative_item› =
			basic_declaration
		|	representation_clause;
(* **** this disallows SPARK's proof declarations **** *)

€body› =		proper_body
		|	body_stub;

€proper_body› =	subprogram_body
		|	package_body;
=TEX
SPARK manual 4.1:
=DUMPMORE dtd503.grm.txt
€name› =		simple_name, select;
(* **** this area doesn't seem to make sense **** *)
(* **** things like `f(1,2)(1,2,3)("a")' seem to be allowed as names **** *)

€select› =
		|	`Dot`, simple_name, select
		|	`Ord`, exp_list, `Crd`, select;

=TEX
with
=IGN
€name› =		simple_name
		|	indexed_component
		|	selected_component;
=TEX
SPARK manual 4.1.1:
=DUMPMORE dtd503.grm.txt

€indexed_component› =	prefix, `Ord`, expression_list, `Crd`; 
=TEX
SPARK manual 4.1.3:
=DUMPMORE dtd503.grm.txt

€selected_component› =	prefix, `Dot`, selector;

€selector› =		simple_name;

=TEX
=TEX
SPARK manual 4.1/4.1.1:
=DUMPMORE dtd503.grm.txt
(* **** this part is out of order **** *)
€simple_name› =		`Identifier`;

€prefix› =		name
		|	function_call;

€expression_list› =	expression, exp_list;

€exp_list› =
		|	`Comma`, expression_list;
=TEX
SPARK manual 4.1.4:
=DUMPMORE dtd503.grm.txt

€attribute› =		prefix, `Prime`, attribute_designator
		|	`CharacterLiteral`, `Prime`, attribute_designator;

€attribute_designator› =
			namexp, namexp_list;

€namexp_list› =
		|	`Prime`, attribute_designator;

€namexp› =		simple_name
		|	simple_name, `Ord`, expression, `Crd`;
=TEX
SPARK manual 4.3:
=DUMPMORE dtd503.grm.txt

€aggregate› =		`Ord`, component_association, `Crd`
		|	`Ord`, component_association, `CommaOthers`,
				`GoesTo`, expression, `Crd`
		|	`Ord`, `Others`, `GoesTo`, expression, `Crd`;

€component_association› =	`Na`, named_association
		|	positional_association;
(* **** What's `Na'? **** *)

€named_association› =	aggregate_choice_list, `GoesTo`, expression, ass_list;

€ass_list› =
		|	`Comma`, named_association;

€aggregate_choice_list› =
			aggregate_choice, ag_list;

€ag_list› =
		|	`Bar`, aggregate_choice_list;

€aggregate_choice› =	discrete_range;

€positional_association› =
			expression_list;
(* **** I don't see where the Ada LRM's rule that ``named notation is .... *)
(* .... required for an aggegrate with a single component'' comes in here **** *)

=TEX
SPARK manual 4.4:
=DUMPMORE dtd503.grm.txt

€expression› =		relation, reltail;

€reltail› =
		|	and_relation
		|	and_then_relation
		|	or_relation
		|	or_else_relation
		|	xor_relation;

€and_relation› =	`And`, relation
		|	`And`, relation, and_relation;

€and_then_relation› =	`And`, `Then`, relation
			|	`And`, `Then`, relation, and_then_relation;

€or_relation› =		`Or`, relation
		|	`Or`, relation, or_relation;

€or_else_relation› =	`Or`, `Else`, relation
		|	`Or`, `Else`, relation, or_else_relation;

€xor_relation› =	`Xor`, relation
		|	`Xor`, relation, xor_relation;
(* **** The above could all be abbreviated by making the LRM's class .... *)
(* .... ``logical operator'' a terminal symbol and imposing a later check **** *)

€relation› =		simple_expression, rel2;

€rel2› =
		|	relational_operator, simple_expression
		|	`In`, range
		|	`Not`, `In`, range
		|	`In`, type_mark
		|	`Not`, `In`, type_mark;

€simple_expression› =	term, binoptail
			|	unary_adding_operator, term, binoptail;

€binoptail› =
		|	binary_adding_operator, term, binoptail;

€term› =		factor, multoptail;

€multoptail› =
		|	multiplying_operator, factor;

€factor› =		primary
		|	primary, `StarStar`, primary
		|	`Abs`, primary
		|	`Not`, primary;

€primary› =		`NumericLiteral`
		|	`CharacterLiteral`
		|	`StringLiteral`
		|	name
		|	function_call
		|	type_conversion
		|	qualified_expression
		|	attribute
		|	`Ord`, expression, `Crd`
		|	`AbstractExpression`;
=TEX
SPARK manual 4.5:
=DUMPMORE dtd503.grm.txt
€relational_operator› =	`Equals`
			|	`NotEquals`
			|	`LessThan`
			|	`LessEquals`
			|	`GreaterThan`
			|	`GreaterEquals`;

€binary_adding_operator› =
			`Plus`
			|	`Minus`
			|	`Ampersand`;

€unary_adding_operator› =	`Plus`
		|	`Minus`;

€multiplying_operator› =	`Star`
		|	`Div`
		|	`Mod`
		|	`Rem`;
=TEX
SPARK manual 4.6:
=DUMPMORE dtd503.grm.txt

€type_conversion› =	type_mark, `Ord`, expression, `Crd`;
=TEX
SPARK manual 4.7:
=DUMPMORE dtd503.grm.txt

€qualified_expression› =	type_mark, `Prime`, aggregate;

=TEX
SPARK manual 5:
=DUMPMORE dtd503.grm.txt
€sequence_of_statements› =
			statement, statement_list;

€statement_list› =
		|	sequence_of_statements;

€statement› =		`KSlot`
		|	`SpecificationStatement`
		|	`Con`, `ZDecl`, `FatDot`, `SpecificationStatement`
		|	simple_statement
		|	compound_statement;
=TEX
SPARK manual 5.1:
=DUMPMORE dtd503.grm.txt

€simple_statement› =	null_statement
		|	assignment_statement
		|	procedure_call_statement
		|	exit_statement
		|	return_statement;

€compound_statement› =	if_statement
			|	case_statement
			|	loop_statement;

€null_statement› =	`Null`, `Semi`;

=TEX
SPARK manual 5.2:
=DUMPMORE dtd503.grm.txt
€assignment_statement› =	name, `Becomes`, expression, `Semi`;
=TEX
SPARK manual 5.3:
=DUMPMORE dtd503.grm.txt

€if_statement› = 		`If`, condition,
				`Then`, sequence_of_statements,
				elsif_part,
				else_part,
				`End`, `If`, `Semi`;

€elsif_part› =
		|		`ElsIf`, condition,
				`Then`, sequence_of_statements,
				elsif_part;

€else_part› =
		|		`Else`, sequence_of_statements;

€condition› = expression;
=TEX
SPARK manual 5.4:
=DUMPMORE dtd503.grm.txt

€case_statement› =	`Case`, expression,
			`Is`,
				case_statement_alternative_list,
				others_part,
			`End`, `Case`, `Semi`;

€case_statement_alternative_list› =
			case_statement_alternative
		|	case_statement_alternative, case_statement_alternative_list;

€case_statement_alternative› =
			`When`, case_choice_list, `GoesTo`, sequence_of_statements;

€case_choice_list› =	case_choice
		|	case_choice, `Bar`, case_choice_list;

€case_choice› =		discrete_range;

€others_part› =
		|	`WhenOthers`, `GoesTo`, sequence_of_statements;
=TEX
SPARK manual 5.5:
=DUMPMORE dtd503.grm.txt

€loop_statement› =	name_opt1, iteration_scheme_opt,
			until_opt,
			`Loop`, sequence_of_statements,
			`End`, `Loop`, name_opt2, `Semi`;
(* **** SPARK has no use for, and does not allow, the optional names  **** *)
(* **** Neither SPARK nor Ada have ``until'' **** *)

€name_opt1› =
		|	simple_name, `Colon`;

€name_opt2› =
		|	simple_name;

€iteration_scheme_opt› =
		|	iteration_scheme;

€iteration_scheme› =	`While`, condition
		|	`For`, loop_parameter_specification;


€loop_parameter_specification› =
			`Identifier`, `In`, type_mark
		|	`Identifier`, `In`, `Reverse`, type_mark
		|	`Identifier`, `In`, type_mark, `RRange`, range
		|	`Identifier`, `In`, `Reverse`, type_mark, `RRange`, range;

€until_opt› =
		|	`Until`, `AqTm`;
=TEX
SPARK manual 5.7:
=DUMPMORE dtd503.grm.txt

€exit_statement› =	`Exit`, `Semi`
		|	`Exit`, `When`, condition, `Semi`;
=TEX
SPARK manual 5.8:
=DUMPMORE dtd503.grm.txt

€return_statement› =	`Return`, expression, `Semi`;
=TEX
SPARK manual 6.1:
=DUMPMORE dtd503.grm.txt

€subprogram_declaration› =
			procedure_specification, `Semi`
		|	function_specification, `Semi`;
(* **** SPARK's annotations have been dropped  **** *)

€subprogram_specification› =
			procedure_specification
		|	function_specification;

€procedure_specification› =
			`Procedure`, `Identifier`
		|	`Procedure`, `Identifier`, `SpecificationStatement`
		|	`Procedure`, `Identifier`, formal_part
		|	`Procedure`, `Identifier`, formal_part, `SpecificationStatement`;

€function_specification› =
			`Function`, designator, `Return`, type_mark
		|	`Function`, designator, `Return`, type_mark,
			`SpecificationStatement`
		|	`Function`, designator, formal_part, `Return`, type_mark
		|	`Function`, designator, formal_part, `Return`, type_mark,
			`SpecificationStatement`;

€designator› =		`Identifier`;

€operator_symbol› =	`StringLiteral`;

€formal_part› =		`Ord`, parlist, `Crd`;

€parlist› =		parameter_specification
		|	parameter_specification, `Semi`, parlist;

€parameter_specification› =
			identifier_list, `Colon`, mode, type_mark;

€mode› =
		|	`In`
		|	`Out`
		|	`In`, `Out`;
=TEX
SPARK manual 6.3:
=DUMPMORE dtd503.grm.txt

€subprogram_body› =	procedure_specification, `Is`, subprogram_implementation
			|	function_specification, `Is`, subprogram_implementation;

€subprogram_implementation› =
			declarative_part,
			`Begin`,
			sequence_of_statements,
			`End`, designator, `Semi`;
(* **** SPARK's annotations have been dropped  **** *)
(* **** SPARK's code insertions have been dropped  **** *)
(* **** SPARK's hidden parts have been dropped  **** *)
=TEX
SPARK manual 6.4:
=DUMPMORE dtd503.grm.txt

€procedure_call_statement› =
			procedure_name, `Semi`
		|	procedure_name, actual_parameter_part, `Semi`;

€function_call› =		function_name
			|	function_name, actual_parameter_part;

€actual_parameter_part› =	`Ord`, parameter_association, `Crd`;

€parameter_association› =	named_parameter_association
			|	positional_parameter_association;

€named_parameter_association› =
			formal_parameter, `GoesTo`, actual_parameter
		|	formal_parameter, `GoesTo`, actual_parameter,
				`Comma`, named_parameter_association;

€positional_parameter_association› =
			actual_parameter
		|	actual_parameter, `Comma`, positional_parameter_association;
=TEX
$formal\_parameter$ changed from $simple\_name$ to $name$.
=DUMPMORE dtd503.grm.txt

€formal_parameter› =	simple_name;

€actual_parameter› =	expression;
=TEX
SPARK manual 7.1:
=DUMPMORE dtd503.grm.txt

€package_declaration› =	package_specification, `Semi`;

€package_specification› =
			`Package`, `Identifier`,
			`Is`,
				visible_part,
			`End`, simple_name
		|	`Package`, `Identifier`,
			`Is`,
				visible_part,
			`Private`,
				private_part,
			`End`, simple_name;

€visible_part› =	visdec
		|	visdec, visible_part;

€visdec› =		`KSlot`
		|	basic_declarative_item
		|	subprogram_declaration;

€private_part› =	pdec
		|	pdec, private_part;

€pdec› =		`KSlot`
		|	basic_declarative_item;

=TEX
=DUMPMORE dtd503.grm.txt
€package_body› =		`Package`, `BBody`, simple_name,
				`Is`,
					package_implementation,
				`End`, simple_name, `Semi`;

€package_implementation› =
			declarative_part
		|	declarative_part, `Begin`, package_initialization;

€package_initialization› =
			sequence_of_statements;
=TEX
SPARK manual 7.4:
=DUMPMORE dtd503.grm.txt

€private_type_declaration› =
			`Type`, `Identifier`, `Is`, `Private`, `Semi`
		|	`Type`, `Identifier`, `Is`, `Limited`, `Private`, `Semi`;

€deferred_constant_declaration› =
			identifier_list, `Colon`, `Constant`, type_mark, `Semi`;
=TEX
SPARK manual 8.5:
=DUMPMORE dtd503.grm.txt

€renaming_declaration› =	`Function`, operator_symbol, formal_part,
				`Return`, type_mark,
				`Renames`,
				simple_name, `Dot`, operator_symbol, `Semi`
			|	subprogram_specification,
				`Renames`,
				simple_name, `Dot`, simple_name, `Semi`;

=TEX
SPARK manual 10.1:
=DUMPMORE dtd503.grm.txt
€compilation› =		`KSlot`
		|	compilation_unit
		|	compilation_unit, compilation;

€compilation_unit› =	context_clause, library_unit
		|	context_clause, secondary_unit;

€library_unit› =		package_declaration
		|	main_program;

€secondary_unit› =	library_unit_body
		|	subunit;

€library_unit_body› =	package_body;

€main_program› =	subprogram_body;
=TEX
SPARK manual 10.1.1:
=DUMPMORE dtd503.grm.txt

€context_clause› =
		|	with_clause;

€with_clause› =		`With`, simple_name_list, `Semi`;

€simple_name_list› =	simple_name
		|	simple_name, `Comma`, simple_name_list;
=TEX
SPARK manual 10.2:
=DUMPMORE dtd503.grm.txt

€body_stub› =		procedure_specification, `Is`, `Separate`, `Semi`
		|	function_specification, `Is`, `Separate`, `Semi`
		|	`Package`, `BBody`, simple_name, `Is`, `Separate`, `Semi`;

€subunit› =		`Separate`, `Ord`, name, `Crd`, proper_body;
=TEX
SPARK manual 13.1:
=DUMPMORE dtd503.grm.txt

€representation_clause› =
			type_representation_clause, address_clause;

€type_representation_clause› =
			length_clause
		|	enumeration_representation_clause
		|	record_representation_clause;
=TEX
SPARK manual 13.2:
=DUMPMORE dtd503.grm.txt

€length_clause› =	`For`, attribute, `Use`, simple_expression, `Semi`;
=TEX
SPARK manual 13.3:
=DUMPMORE dtd503.grm.txt

€enumeration_representation_clause› =
			`For`, simple_name, `Use`, aggregate, `Semi`;
=TEX
SPARK manual 13.4:
=DUMPMORE dtd503.grm.txt

€record_representation_clause› =
			`For`, simple_name,
			`Use`,
			`Record`,
				alignment_opt, component_pack,
			`End`, `Record`, `Semi`;

€alignment_opt› =
		|	`At`, `Mod`, simple_expression, `Semi`;

€component_pack› =	component_clause
		|	component_clause, component_pack;

€component_clause› =	name, `At`, simple_expression, `RRange`, range, `Semi`;
=TEX
SPARK manual 13.5:
=DUMPMORE dtd503.grm.txt

€address_clause› =	`For`, simple_name, `Use`, `At`, simple_expression, `Semi`;
(* **** SPARK's code statements have been dropped **** *)
=TEX
The following are additions to the original specification.
=DUMPMORE dtd503.grm.txt
function_name =		`Identifier`;
procedure_name =	`Identifier`;
type_mark =		`Identifier`;
=TEX

\section{GENERATING THE TABLES}
=SH
(
poly `arch`slrp.db >dtd503.grm.run <<!
Slrp.slrp{
	in_file="dtd503.grm.txt",
	out_file="dtd503.grm.sml",
	logfile="dtd503.grm.log",
	eos="Eos",
	loglevel=2};
PolyML.quit();
!
)
=TEX
=TEX
\section{PARSER}
=TEX
\subsection{Context Free Parsing}
=DOC
val €cn_parser› : CNLex.LEX_ITEM list -> unit
=DESCRIBE
This is the context-free parser for Compliance Notation. It maps the lists of
tokens output by the CN lexical analyser onto datatypes representing
the CN abstract syntax.
=FAILURE
503000	Syntax error
503001	Syntax error in: ?0 <?> ?1
503003	?0 is not expected after ?1
503004	?0 is not a valid sequence or set type name
503011	Lexical analysis error: ?0 is not allowed here in Compliance Notation
503201	Parser internal error: ?0
=ENDDOC
=TEX
=SML
end; (* of signature CNParser *)
=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



