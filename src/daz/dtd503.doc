%  dtd503.doc %Z% $Date$ $Revision$ $RCSfile$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% This document has these percent lines dotted throughout to help the author
% with getting the formal text to fit within the page.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\def\Source{\cite{DRA/CIS/CSE3/SWI/WP/9/2}}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Compliance Notation Parser}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD503}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{
This document contains the detailed design for the
DAZ parser.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.4] Initial Draft.
\item[Issue \SCCSversion~\FormatDate{$Date$%
}) ] Changed Names to be for Compliance Notation.

\end{description}
\subsection{Changes Forecast}
The phase 2 checks and transformations are yet to be documented.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the Compliance Notation parser.

It includes the Compliance Notation grammar in the format required by the {\tt SLRP} parser generator.

\subsection{Introduction}
The DRA document \Source gives the grammar for the  Compliance Notation.
This document re-expresses that grammar in the format required by the {\tt SLRP} parser generator.
For easy comparison, cross-references with the SPARK manual (SM \cite{PVL90}) (and  hence with the Ada Language Reference Manual) have been added where appropriate.

 

\subsubsection{Purpose and Background}


\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{DESIGN ISSUES}

\section{PREAMBLE}
=DOC
signature ÛCNParserÝ = sig
=DESCRIBE
This is the signature for the structure containing the parser for SPARK.
=ENDDOC


\section{CHANGES FROM DRA/CIS/CSE3/SWI/WP/9/2}
\subsection{Type Mark}
Type marks are terminals in \Source. They are lexically indistinguishable from names. The grammar has been adjusted throughout to use names where type marks are to be found in \Source. The productions affected are listed in tabel \ref{RemovalofTypeMark}.

\begin{table}
\center
\begin{tabular}{||l|p{3.0in}||}\hline
Id &  Affected Productions\\\hline\hline
TM/1 & constant declaration \\\hline
TM/2 & variable declaration \\\hline
TM/3 & subtype indication \\\hline
TM/4 & unconstrained array definition \\\hline
TM/5 & constrained array definition \\\hline
TM/6 & index subtype definition \\\hline
TM/7 & component declaration \\\hline
TM/8 & discriminant part \\\hline
TM/9 & qualified expression \\\hline
TM/10 & loop parameter specification \\\hline
TM/11 & function specification \\\hline
TM/12 & parameter specification \\\hline
TM/13 & deferred constant declaration \\\hline
TM/14 & renaming declaration \\\hline
\end{tabular}
\caption{Removal of Type Mark}
\label{RemovalofTypeMark}
\end{table}

\subsection{Simple Names}

Simple names are lexically equivalent to identifiers, and where there are occurrences of simple name in \Source, identifier has been used here. The productions affected are listed in table \ref{RemovalofSimpleName}.

\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Productions\\\hline\hline
SN/1 & simple name \\\hline
SN/2 & selector \\\hline
SN/3 & name opt1 \\\hline
SN/4 & name opt2 \\\hline
SN/5 & package body \\\hline
SN/6 & renaming declaration \\\hline
SN/7 & enumeration representation clause \\\hline
SN/8 & address clause \\\hline
\end{tabular}
\caption{Removal of Simple Name}
\label{RemovalofSimpleName}
\end{table}


\subsection{Elision}\label{Elision}

In the LRM there are several productions of the form:

=GFT SPARK Manual 3.2:
identifier_list ::= identifier {, identifier}
=TEX

For this kind of grammatical rule, \Source has systematically introduced a new production which specifically handles the option, as shown in the following example.
=GFT BNF Example

identifier_list =	`Identifier`, id_list;

id_list	=
		|	`Comma`, identifier_list;
=TEX
It is equally possible to elide the new production and accept the same grammar by writing:
=GFT BNF Example

identifier_list =	`Identifier`
		|	`Identifier`, `Comma`, identifier_list;
=TEX

In the implemented grammar, the latter form has been used where possible since a) it is more efficient and b) it is LR(1).

The following productions elided in this way are listed in table \ref{ElidedProductions}.

\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id & Elided Production	& Affected Productions\\\hline\hline
EP/1 & id list & identifier list \\\hline
EP/2 & dp1 & web clause, declarative part \\\hline
EP/3 & exp list & expression list\\\hline
EP/4 & rel2 & relation\\\hline
EP/5 & reltail & expression\\\hline
EP/6 & ass list & named association\\\hline
EP/7 & ag list & aggregate choice list\\\hline
EP/8 & multoptail & term\\\hline
EP/9 & statement list & sequence of statements\\\hline
EP/10 & subtype list & index subtype definition list\\\hline
\end{tabular}
\caption{Elided Productions}
\label{ElidedProductions}
\end{table}

\subsection{Ranges}\label{Ranges}

\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Production & Action\\\hline\hline
RA/1 & range & Deleted \\\hline
RA/2 & sr expression & New \\\hline
RA/3 & relation & Changed \\\hline
RA/4 & loop parameter specification & Changed \\\hline
RA/5 & range constraint & Changed \\\hline
RA/6 & discrete range & Changed \\\hline
RA/7 & component clause & Changed \\\hline
\end{tabular}
\caption{Ranges}
\label{Ranges}
\end{table}

\subsection{Aggregates}\label{Aggregates}

\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Production & Action\\\hline\hline
AG/1 & aggregate & Changed \\\hline
AG/2 & component association & Changed \\\hline
AG/3 & named association & Changed \\\hline
AG/4 & aggregate choice list & Changed \\\hline
\end{tabular}
\caption{Widening of Aggregates}
\label{WideningofAggregates}
\end{table}

\subsection{Names}\label{Names}

\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Production & Action\\\hline\hline
NA/1 & name & Changed \\\hline
NA/2 & indexed component & New \\\hline
NA/3 & selected component & Changed \\\hline
NA/4 & select & Deleted \\\hline
\end{tabular}
\caption{Names}
\label{Names}
\end{table}

\subsection{Function Calls}\label{FunctionCalls}
\subsection{Parameter Association}\label{ParameterAssociation}
\subsection{SubType Indication}\label{SubTypeIndication}
elided:
formal parameter,
named parameter association

\subsection{Labels}\label{Labels}

\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Production & Action\\\hline\hline
LA/1 & label & Changed \\\hline
\end{tabular}
\caption{Labels}
\label{Labels}
\end{table}

\subsection{KSlots}\label{KSlots}
\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Production & Action\\\hline\hline
KS/1 & k slot & New \\\hline
\end{tabular}
\caption{K Slots}
\label{K Slots}
\end{table}


\subsection{Primed Identifiers}\label{PrimedIdentifiers}

\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Production & Action\\\hline\hline
AT/1 & attribute & Changed \\\hline
\end{tabular}
\caption{Primed Identifiers}
\label{PrimedIdentifiers}
\end{table}

\subsection{Z and Web Clauses}

Z paragraphs are supported by {\Product} and a production branch in
the $web\_clause$ is not required.

\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Production & Action\\\hline\hline
WC/1 & web clause/z & Deleted \\\hline
\end{tabular}
\caption{Labels}
\label{Labels}
\end{table}

\newpage
\section{GRAMMAR}
\subsection{Web Clause}
The entry point to the grammar (sentence symbol) is placed first, because that is where {\tt SLRP} expects to find it.


The production for replacing by declarations in \Source was expressed in terms of dec and dp1. Here we use declarative part which is identical.

=DUMP dtd503.grm.txt

Ûweb_clauseÝ =	compilation
		|	`CompLabel`, `ReplacedBy`, compilation
		|	`PPartLabel`, `ReplacedBy`, private_part
		|	`VPartLabel`, `ReplacedBy`, visible_part
		|	`DecLabel`, `ReplacedBy`, declarative_part
		|	`StmtLabel`, `ReplacedBy`, sequence_of_statements
		|	`SpecLabel`, `RefinedBy`, sequence_of_statements
		|	`RefinedBy`, sequence_of_statements
		|	`SpecLabel`, `ReplacedBy`, sequence_of_statements
		|	`ReplacedBy`, sequence_of_statements;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Declarations}

SPARK manual 3.1:
=DUMPMORE dtd503.grm.txt

Ûbasic_declarationÝ =		object_declaration
			|	type_declaration
			|	subtype_declaration
			|	deferred_constant_declaration;
=TEX

SPARK manual 3.2:
=DUMPMORE dtd503.grm.txt

Ûobject_declarationÝ =	constant_declaration
			|	variable_declaration;
=TEX
The production id list of \Source\  has been elided (see section \ref{Elision}).

SPARK manual 3.2:
=DUMPMORE dtd503.grm.txt

Ûconstant_declarationÝ =	identifier_list, `Colon`, `Constant`, name,
					`Becomes`, expression, `Semi`;
	
Ûvariable_declarationÝ =	identifier_list, `Colon`, name, `Semi`;

Ûidentifier_listÝ =	`Identifier`
		|	`Identifier`, `Comma`, identifier_list;
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
TBS Need to add discriminant part HADAZ11!
SPARK manual 3.3.1:
=DUMPMORE dtd503.grm.txt

Ûtype_declarationÝ =	full_type_declaration
		|	private_type_declaration;

Ûfull_type_declarationÝ =	`Type`, `Identifier`, discriminant_part, `Is`, type_definition, `Semi`
			|	`Type`, `Identifier`, `Is`, type_definition, `Semi`;

Ûtype_definitionÝ =	enumeration_type_definition
		|	integer_type_definition
		|	real_type_definition
		|	array_type_definition
		|	record_type_definition;
=TEX
A subtype indication which comprises a name (i.e., type mark in \Source) followed by an indexed constraint will appear in this grammar as an indexed component (See \ref{Constraint}. 

SPARK manual 3.3.2:
=DUMPMORE dtd503.grm.txt

Ûsubtype_declarationÝ =	`SubType`, `Identifier`, `Is`, subtype_indication, `Semi`;

Ûsubtype_indicationÝ =	name, constraint;
=TEX
A subtype indication which comprises a name (i.e., type mark in \Source) followed by an indexed constraint will appear in this grammar as an indexed component (See section \ref{SubtypeIndication}). 

SPARK manual 3.3.2:
=DUMPMORE dtd503.grm.txt

ÛconstraintÝ	=	range_constraint
		|	floating_point_constraint
		|	fixed_point_constraint;
=TEX

Description TBS!!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SPARK manual 3.5:
=DUMPMORE dtd503.grm.txt

Ûrange_constraintÝ =	`RRange`, sr_expression;
=TEX

SPARK manual 3.5.1:
=DUMPMORE dtd503.grm.txt

Ûenumeration_type_definitionÝ =	`Ord`, identifier_list, `Crd`;
=TEX

SPARK manual 3.5.4:
=DUMPMORE dtd503.grm.txt

Ûinteger_type_definitionÝ =	range_constraint;
=TEX

SPARK manual 3.5.6:
=DUMPMORE dtd503.grm.txt

Ûreal_type_definitionÝ =	floating_point_constraint
			|	fixed_point_constraint;
=TEX
SPARK manual 3.5.7:
=DUMPMORE dtd503.grm.txt

Ûfloating_point_constraintÝ =	floating_accuracy_definition
				|	floating_accuracy_definition, range_constraint;

Ûfloating_accuracy_definitionÝ =	`Digits`, simple_expression;
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SPARK manual 3.5.9:
=DUMPMORE dtd503.grm.txt

Ûfixed_point_constraintÝ =	fixed_accuracy_definition
			|	fixed_accuracy_definition, range_constraint;

Ûfixed_accuracy_definitionÝ =	`Delta`, simple_expression;
=TEX
Description TBS w.r.t. discrete range

SPARK manual 3.6:
=DUMPMORE dtd503.grm.txt

Ûarray_type_definitionÝ =	unconstrained_array_definition
			|	constrained_array_definition;

Ûunconstrained_array_definitionÝ =
			`Array`, `Ord`, index_subtype_definition_list, `Crd`, `Of`, name;

Ûconstrained_array_definitionÝ =
			`Array`, index_constraint, `Of`, name;

Ûindex_subtype_definition_listÝ =
			index_subtype_definition
		|	index_subtype_definition, `Comma`, index_subtype_definition_list;

Ûindex_subtype_definitionÝ =
			name, `RRange`, `LessGreat`;

Ûindex_constraintÝ =	`Ord`, name_list, `Crd`;

Ûname_listÝ =		name
		|	name, `Comma`, name_list;

Ûdiscrete_rangeÝ =	simple_expression, range_constraint
		|	sr_expression;
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
TBS Don't forget to add variant part... HADAZ11!

SPARK manual 3.7:
=DUMPMORE dtd503.grm.txt

Ûrecord_type_definitionÝ =	`Record`, component_list, `End`, `Record`;
=IGN
Ûcomponent_listÝ =	component_declaration
		|	component_declaration, `Comma`, component_list;
=DUMPMORE dtd503.grm.txt
Ûcomponent_listÝ =	component_declaration_list
		|	variant_part
		|	component_declaration_list, variant_part
		|	`Null`;

Ûcomponent_declaration_listÝ =	component_declaration
				|	component_declaration, component_declaration_list;

Ûcomponent_declarationÝ =	identifier_list, `Colon`, name, `Semi`;

Ûdiscriminant_partÝ =	`Identifier`, `Colon`, name;

Ûvariant_partÝ =	`Case`, `Identifier`, `Is`, variant_list, `End`, `Case`, `Semi`;

Ûvariant_listÝ =	variant
		|	variant, variant_list;

ÛvariantÝ =	`When`, variant_choice_list, `GoesTo`, component_list;

Ûvariant_choice_listÝ =	`Identifier`
			|	`Identifier`, `Bar`, variant_choice_list;
=TEX
Insisting on at least one declaration seems odd.

SPARK manual 3.9:
=DUMPMORE dtd503.grm.txt

Ûdeclarative_partÝ =	dec
		|	dec, declarative_part;

ÛdecÝ =		k_slot
	|	renaming_declaration
	|	basic_declarative_item
	|	package_declaration
	|	body;

Ûbasic_declarative_itemÝ =	basic_declaration
			|	representation_clause;

ÛbodyÝ =	proper_body
	|	body_stub;

Ûproper_bodyÝ =	subprogram_body
		|	package_body;
=TEX
The production rules in SPARK Manual 4.1 have been used since the grammar in \Source is probably too wide:

TBS - justify the attribute.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SPARK manual 4.1:
=DUMPMORE dtd503.grm.txt
ÛnameÝ =		`Identifier`
		|	indexed_component
		|	selected_component
		|	attribute;
=TEX
SPARK manual 4.1.1:
=DUMPMORE dtd503.grm.txt
Ûindexed_componentÝ =	name, actual_parameter_part;
=TEX
SPARK manual 4.1.3:
=DUMPMORE dtd503.grm.txt
Ûselected_componentÝ =	name, `Dot`, selector;

ÛselectorÝ =		`Identifier`;
=TEX
SPARK manual 4.1/4.1.1:
=DUMPMORE dtd503.grm.txt
Ûexpression_listÝ =	expression
		|	expression, `Comma`, expression_list;

=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SPARK manual 4.1.4:
=DUMPMORE dtd503.grm.txt
ÛattributeÝ =		name, `PrimedIdentifier`
		|	`CharacterLiteral`, `PrimedIdentifier`;
=TEX
SPARK manual 4.3:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SPARK manual 4.3:
=DUMPMORE dtd503.grm.txt

ÛaggregateÝ =		`Ord`, component_association, `Crd`;

Ûcomponent_associationÝ =	named_association
			|	positional_association;

Ûnamed_associationÝ =	aggregate_choice_list, `GoesTo`, expression
			|	aggregate_choice_list, `GoesTo`, expression, `Comma`,
				named_association;

Ûaggregate_choice_listÝ =	`Others`
			|	aggregate_choice
			|	aggregate_choice, `Bar`, aggregate_choice_list;

=TEX
I don't see where the Ada LRM's rule that ``named notation is required for an aggegrate with a single component'' comes in here.
=DUMPMORE dtd503.grm.txt

Ûaggregate_choiceÝ =	discrete_range;

Ûpositional_associationÝ =	expression_list;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Expressions}

reltail has been elided.

SPARK manual 4.4:
=DUMPMORE dtd503.grm.txt

ÛexpressionÝ =		relation
		|	relation, and_relation
		|	relation, and_then_relation
		|	relation, or_relation
		|	relation, or_else_relation
		|	relation, xor_relation;

Ûand_relationÝ =	`And`, relation
		|	`And`, relation, and_relation;

Ûand_then_relationÝ =	`And`, `Then`, relation
		|	`And`, `Then`, relation, and_then_relation;

Ûor_relationÝ =	`Or`, relation
		|	`Or`, relation, or_relation;

Ûor_else_relationÝ =	`Or`, `Else`, relation
		|	`Or`, `Else`, relation, or_else_relation;

Ûxor_relationÝ =	`Xor`, relation
		|	`Xor`, relation, xor_relation;
=TEX
rel2 has been elided.
The introduction of an intermediate production for sr expression is to support ranges as expressions and is described in section \ref{Ranges}.


SPARK manual 4.4:
=DUMPMORE dtd503.grm.txt

ÛrelationÝ =		sr_expression
		|	sr_expression, relational_operator, sr_expression
		|	sr_expression, `In`, sr_expression
		|	sr_expression, `Not`, `In`, sr_expression;

Ûsr_expressionÝ =	simple_expression
		|	simple_expression, `DotDot`, simple_expression;

Ûsimple_expressionÝ =	term, binoptail
			|	unary_adding_operator, term, binoptail;

ÛbinoptailÝ =
	|	binary_adding_operator, term, binoptail;

ÛtermÝ =	factor
	|	factor, multiplying_operator, factor;

ÛfactorÝ =	primary
	|	primary, `StarStar`, primary
	|	`Abs`, primary
	|	`Not`, primary;
=TEX

The production for primary/function call is not necessary because a function call appear as an indexed component. Similarly for type conversions.

Attributes now appear in the production for name. TBS more explanation...


TBS what has happened to qualified expressions.

=DUMPMORE dtd503.grm.txt
ÛprimaryÝ =		`NumericLiteral`
		|	`CharacterLiteral`
		|	`StringLiteral`
		|	name
		|	`Ord`, expression, `Crd`
		|	abstract_expression;
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SPARK manual 4.5:
=DUMPMORE dtd503.grm.txt
Ûrelational_operatorÝ =		`Equals`
			|	`NotEquals`
			|	`LessThan`
			|	`LessEquals`
			|	`GreaterThan`
			|	`GreaterEquals`;

Ûbinary_adding_operatorÝ =	`Plus`
			|	`Minus`
			|	`Ampersand`;

Ûunary_adding_operatorÝ =	`Plus`
			|	`Minus`;

Ûmultiplying_operatorÝ =	`Star`
			|	`Div`
			|	`Mod`
			|	`Rem`;
=TEX

\subsection{Type Conversion}

Type conversions [SPARK manual 4.6] appear as indexed components.
\subsection{Qualified Expression}

SPARK manual 4.7:
=DUMPMORE dtd503.grm.txt
Ûqualified_expressionÝ =	name, `Prime`, aggregate;
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Statements}
A production for specification statements has been added as a further refinement to \Source in which a specification statement is a terminal.
A label appended to a specification statement is parsed as a number in brackets. A subsequent check is required to ensure that the number comprises only digits.

A Z declaration in the statement/Con production appears as Z tokens. The parser then has to construct a Z declaration by placing the tokens in a context where a declaration could appear (i.e., a schema) and parse as a Z term using the Z parser. The term is then broken apart to yield the parsed Z declaration.

SPARK manual 5:
=DUMPMORE dtd503.grm.txt

Ûsequence_of_statementsÝ =		statement
				|	statement, sequence_of_statements;

ÛstatementÝ =		k_slot
		|	specification_statement
		|	`Con`, `Z`, `FatDot`, specification_statement
		|	simple_statement
		|	compound_statement;

Ûspecification_statementÝ =	`GrkDelta`, `Z`, `LSqBrack`, `Z`, `RSqBrack`
			|	`GrkDelta`, `Z`, `LBrace`, `Z`, `RBrace`
			|	`GrkDelta`, `Z`, `LSqBrack`, `Z`, `RSqBrack`, label
			|	`GrkDelta`, `Z`, `LBrace`, `Z`, `RBrace`, label;

ÛlabelÝ =	`Ord`, `NumericLiteral`, `Crd`;

Ûk_slotÝ =	`KSlot`
	|	`KSlot`, label;
=TEX
SPARK manual 5.1:
=DUMPMORE dtd503.grm.txt

Ûsimple_statementÝ =		null_statement
			|	assignment_statement
			|	procedure_call_statement
			|	exit_statement
			|	return_statement;

Ûcompound_statementÝ =		if_statement
				|	case_statement
				|	loop_statement;

Ûnull_statementÝ =	`Null`, `Semi`;

=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SPARK manual 5.2:
=DUMPMORE dtd503.grm.txt
Ûassignment_statementÝ =	name, `Becomes`, expression, `Semi`;
=TEX
SPARK manual 5.3:
=DUMPMORE dtd503.grm.txt

Ûif_statementÝ = 	`If`, condition,
			`Then`, sequence_of_statements,
				elsif_part,
				else_part,
			`End`, `If`, `Semi`;

Ûelsif_partÝ =
		|	`ElsIf`, condition,
			`Then`, sequence_of_statements,
			elsif_part;

Ûelse_partÝ =
		|	`Else`, sequence_of_statements;

ÛconditionÝ =		expression;
=TEX
SPARK manual 5.4:
=DUMPMORE dtd503.grm.txt

Ûcase_statementÝ =	`Case`, expression,
			`Is`,
				case_statement_alternative_list,
				others_part,
			`End`, `Case`, `Semi`;

Ûcase_statement_alternative_listÝ =
			case_statement_alternative
		|	case_statement_alternative, case_statement_alternative_list;

Ûcase_statement_alternativeÝ =
			`When`, case_choice_list, `GoesTo`, sequence_of_statements;

Ûcase_choice_listÝ =	case_choice
		|	case_choice, `Bar`, case_choice_list;

Ûcase_choiceÝ =	discrete_range;

Ûothers_partÝ =
		|	`WhenOthers`, `GoesTo`, sequence_of_statements;
=TEX
SPARK has no use for, and does not allow, the optional names.

SPARK manual 5.5:
=DUMPMORE dtd503.grm.txt

Ûloop_statementÝ =	name_opt1, iteration_scheme_opt,
			till_opt,
			`Loop`, sequence_of_statements,
			`End`, `Loop`, name_opt2, `Semi`;

Ûname_opt1Ý =
		|	`Identifier`, `Colon`;

Ûname_opt2Ý =
		|	`Identifier`;

Ûiteration_scheme_optÝ =
		|	iteration_scheme;

Ûiteration_schemeÝ =	`While`, condition
		|	`For`, loop_parameter_specification;
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Range has been replaced with a more general sr expression in loop parameter specification. A later check will be required to ensure that the sr expression is a range. See section \ref{Ranges} for further information.

Abstract Expressions comprise a ``û'' followed by some Z followed by ``ý''.

SPARK manual 5.5:
=DUMPMORE dtd503.grm.txt
Ûloop_parameter_specificationÝ =
			`Identifier`, `In`, name
		|	`Identifier`, `In`, `Reverse`, name
		|	`Identifier`, `In`, name, `RRange`, sr_expression
		|	`Identifier`, `In`, `Reverse`, name, `RRange`, sr_expression;

Ûtill_optÝ =
		|	`Till`, abstract_expression;

Ûabstract_expressionÝ =	`LStrachey`, `Z`, `RStrachey`;
=TEX
SPARK manual 5.7:
=DUMPMORE dtd503.grm.txt

Ûexit_statementÝ =	`Exit`, `Semi`
		|	`Exit`, `When`, condition, `Semi`;
=TEX
SPARK manual 5.8:
=DUMPMORE dtd503.grm.txt

Ûreturn_statementÝ =	`Return`, expression, `Semi`;
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SPARK manual 6.1:
=DUMPMORE dtd503.grm.txt

Ûsubprogram_declarationÝ =
			procedure_specification, `Semi`
		|	function_specification, `Semi`;

Ûsubprogram_specificationÝ =
			procedure_specification
		|	function_specification;
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SPARK manual 6.1:
=DUMPMORE dtd503.grm.txt

Ûprocedure_specificationÝ =
			`Procedure`, `Identifier`
		|	`Procedure`, `Identifier`, specification_statement
		|	`Procedure`, `Identifier`, formal_part
		|	`Procedure`, `Identifier`, formal_part, specification_statement;

Ûfunction_specificationÝ =
			`Function`, designator, `Return`, name
		|	`Function`, designator, `Return`, name,
			specification_statement
		|	`Function`, designator, formal_part, `Return`, name
		|	`Function`, designator, formal_part, `Return`, name,
			specification_statement;
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SPARK manual 6.1:
=DUMPMORE dtd503.grm.txt

ÛdesignatorÝ =		`Identifier`;

Ûoperator_symbolÝ =	`StringLiteral`;

Ûformal_partÝ =	`Ord`, parlist, `Crd`;

ÛparlistÝ =		parameter_specification
		|	parameter_specification, `Semi`, parlist;

Ûparameter_specificationÝ =	identifier_list, `Colon`, mode, name;

ÛmodeÝ =
	|	`In`
	|	`Out`
	|	`In`, `Out`;
=TEX
SPARK's annotations have been dropped
SPARK's code insertions have been dropped
SPARK's hidden parts have been dropped

SPARK manual 6.3:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
=DUMPMORE dtd503.grm.txt

Ûsubprogram_bodyÝ =	procedure_specification, `Is`, subprogram_implementation
			|	function_specification, `Is`, subprogram_implementation;

Ûsubprogram_implementationÝ =	declarative_part,
				`Begin`,
					sequence_of_statements,
				`End`, designator, `Semi`;
=TEX
SPARK manual 6.4:
=DUMPMORE dtd503.grm.txt
Ûprocedure_call_statementÝ =	name, `Semi`;
=TEX
=DUMPMORE dtd503.grm.txt
Ûactual_parameter_partÝ =	`Ord`, parameter_association, `Crd`;
=TEX
=DUMPMORE dtd503.grm.txt
Ûparameter_associationÝ =	named_association
			|	positional_parameter_association;
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
named parameter association and formal parameter have been elided. For an explanation see section \ref{ParameterAssociation}.
=DUMPMORE dtd503.grm.txt

Ûpositional_parameter_associationÝ =	actual_parameter
				|	actual_parameter, `Comma`,
						positional_parameter_association;
=TEX
=DUMPMORE dtd503.grm.txt
Ûactual_parameterÝ =	expression;
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SPARK manual 7.1:
=DUMPMORE dtd503.grm.txt
Ûpackage_declarationÝ =	package_specification, `Semi`;

Ûpackage_specificationÝ =
			`Package`, `Identifier`,
			`Is`,
				visible_part,
			`End`, `Identifier`
		|	`Package`, `Identifier`,
			`Is`,
				visible_part,
			`Private`,
				private_part,
			`End`, `Identifier`;

Ûvisible_partÝ =	visdec
		|	visdec, visible_part;

=TEX

SPARK manual 7.1:
=DUMPMORE dtd503.grm.txt
ÛvisdecÝ =		k_slot
		|	basic_declarative_item
		|	subprogram_declaration;

Ûprivate_partÝ =	pdec
		|	pdec, private_part;

ÛpdecÝ =	k_slot
	|	basic_declarative_item;

=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
=DUMPMORE dtd503.grm.txt
Ûpackage_bodyÝ =	`Package`, `BBody`, `Identifier`,
			`Is`,
				package_implementation,
			`End`, `Identifier`, `Semi`;

Ûpackage_implementationÝ =	declarative_part
				|	declarative_part, `Begin`, package_initialization;

Ûpackage_initializationÝ =	sequence_of_statements;
=TEX
SPARK manual 7.4:
=DUMPMORE dtd503.grm.txt

Ûprivate_type_declarationÝ =	`Type`, `Identifier`, `Is`, `Private`, `Semi`
				|	`Type`, `Identifier`, `Is`, `Limited`, `Private`, `Semi`;

Ûdeferred_constant_declarationÝ =	identifier_list, `Colon`, `Constant`, name, `Semi`;
=TEX
SPARK manual 8.5:
=DUMPMORE dtd503.grm.txt

Ûrenaming_declarationÝ =	`Function`, operator_symbol, formal_part,
					`Return`, name,
					`Renames`,
					`Identifier`, `Dot`, operator_symbol, `Semi`
			|	subprogram_specification,
					`Renames`,
					`Identifier`, `Dot`, `Identifier`, `Semi`;

=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SPARK manual 10.1:
=DUMPMORE dtd503.grm.txt

ÛcompilationÝ =	k_slot
		|	compilation_unit
		|	compilation_unit, compilation;
=TEX
SPARK manual 10.1:
=DUMPMORE dtd503.grm.txt

Ûcompilation_unitÝ =	context_clause, library_unit
		|	context_clause, secondary_unit;

Ûlibrary_unitÝ =	package_declaration
		|	main_program;

Ûsecondary_unitÝ =	library_unit_body
		|	subunit;

Ûlibrary_unit_bodyÝ =	package_body;

Ûmain_programÝ =	subprogram_body;
=TEX
SPARK manual 10.1.1:
=DUMPMORE dtd503.grm.txt

Ûcontext_clauseÝ =
		|	with_clause;
=TEX
In \Source, the with clause production refers to a simple name list. Since simple names are identifiers, here an identifier list is used instead. The production for simple name list is dispensed with.

SPARK manual 10.1.1:
=DUMPMORE dtd503.grm.txt
Ûwith_clauseÝ =	`With`, identifier_list, `Semi`;
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SPARK manual 10.2:
=DUMPMORE dtd503.grm.txt
Ûbody_stubÝ =		procedure_specification, `Is`, `Separate`, `Semi`
		|	function_specification, `Is`, `Separate`, `Semi`
		|	`Package`, `BBody`, `Identifier`, `Is`, `Separate`, `Semi`;

ÛsubunitÝ =	`Separate`, `Ord`, name, `Crd`, proper_body;
=TEX
SPARK manual 13.1:
=DUMPMORE dtd503.grm.txt

Ûrepresentation_clauseÝ =	type_representation_clause, address_clause;

Ûtype_representation_clauseÝ =	length_clause
				|	enumeration_representation_clause
				|	record_representation_clause;
=TEX
SPARK manual 13.2:
=DUMPMORE dtd503.grm.txt
Ûlength_clauseÝ =	`For`, attribute, `Use`, simple_expression, `Semi`;
=TEX
SPARK manual 13.3:
=DUMPMORE dtd503.grm.txt
Ûenumeration_representation_clauseÝ =	`For`, `Identifier`, `Use`, aggregate, `Semi`;
=TEX
SPARK manual 13.4:
=DUMPMORE dtd503.grm.txt

Ûrecord_representation_clauseÝ =
			`For`, `Identifier`,
			`Use`,
			`Record`,
				alignment_opt, component_pack,
			`End`, `Record`, `Semi`;
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SPARK manual 13.4:
=DUMPMORE dtd503.grm.txt
Ûalignment_optÝ =
		|	`At`, `Mod`, simple_expression, `Semi`;
=TEX
=DUMPMORE dtd503.grm.txt
Ûcomponent_packÝ =	component_clause
		|	component_clause, component_pack;
=TEX
SPARK manual 13.4:
=DUMPMORE dtd503.grm.txt
Ûcomponent_clauseÝ =	name, `At`, simple_expression, `RRange`, sr_expression, `Semi`;
=TEX
SPARK manual 13.5:
=DUMPMORE dtd503.grm.txt
Ûaddress_clauseÝ =	`For`, `Identifier`, `Use`, `At`, simple_expression, `Semi`;
=TEX

\section{GENERATING THE TABLES}
=SH
(
poly `arch`slrp.db >dtd503.grm.run <<!
Slrp.slrp{
	in_file="dtd503.grm.txt",
	out_file="dtd503.grm.sml",
	logfile="dtd503.grm.log",
	eos="Eos",
	loglevel=2};
PolyML.quit();
!
)
=TEX
=TEX
\section{PARSER}
=TEX
\subsection{Context Free Parsing}
=DOC
val Ûcn_parserÝ : CNTypes.CN_LEX_ITEM list -> unit
=DESCRIBE
This is the context-free parser for Compliance Notation. It maps the lists of
tokens output by the CN lexical analyser onto datatypes representing
the CN abstract syntax.
=FAILURE
503000	Syntax error
503001	Syntax error in: ?0 <?> ?1
503003	?0 is not expected after ?1
503004	?0 is not a valid sequence or set type name
503011	Lexical analysis error: ?0 is not allowed here in Compliance Notation
503201	Parser internal error: ?0
=ENDDOC
=TEX
=SML
end; (* of signature CNParser *)
=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\section{ISSUES ARISING}

\begin{enumerate}
\item{Why is the range/simple expression production in \Source not a range/attribute production?}
\item{In dec, the package declaration production does not have an optional renaming declaration as in the SPARK Manual 3.9.}
\item{Declarative part in the SPARK Manual (3.9) can be empty. That in \Source cannot.}
\item{In basic declarative clause, proof declarations in SM 3.9 are omitted in \Source.}
\end{enumerate}

\newpage
\section{COMPLIANCE ARGUMENT}

\begin{table}
\center
\begin{tabular}{||l|l|l|l||}\hline
BNF	& N(ew)/C(hanged) & Description	& Ref.	\\
Production	& /D(eleted)	& 		&	\\ \hline\hline
index constraint & D & &\\\hline
type mark list & D &  &\\\hline
prefix & D &  &\\\hline
attribute designator & D &  &\\\hline
name exp list & D &  &\\\hline
name exp & D &  &\\\hline
type conversion & D &  &\\\hline
function call & D &  &\\\hline
named parameter association & D &  &\\\hline
formal parameter & D &  &\\\hline
\end{tabular}
\caption{Schedule of Reviews}
\label{ScheduleOfReviewsX}
\end{table}

\begin{table}
\center
\begin{tabular}{||l|l|l|l||}\hline
BNF	& N(ew)/C(hanged) & Description	& Ref.	\\
Production	& /D(eleted)	& 		&	\\ \hline\hline
index constraint & C & name list &\\\hline
name list & N &  &\\\hline
attribute & C &  &\\\hline
primary & C &  &\\\hline
specification statement & N &  &\\\hline
label & N &  &\\\hline
abstract expression & N &  &\\\hline
till opt & C &  &\\\hline
procedure call statement & C &  &\\\hline
parameter association & C &  &\\\hline
\end{tabular}
\caption{Schedule of Reviews}
\label{ScheduleOfReviews}
\end{table}


\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



