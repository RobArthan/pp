%  dtd503.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Compliance Notation Parser}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD503}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{
This document contains the detailed design for the
DAZ parser.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.4] Initial Draft.
\item[Issue \SCCSversion~\FormatDate{$Date$%
}) ] Changed Names to be for Compliance Notation.

\end{description}
\subsection{Changes Forecast}
The phase 2 checks and transformations are yet to be documented.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the Compliance Notation parser.

It includes the Compliance Notation grammar in the format required by the {\tt SLRP} parser generator.

\subsection{Introduction}
The DRA document \cite{DRA/CIS/CSE3/SWI/WP/9} gives the grammar for the  Compliance Notation.
This document re-expresses that grammar in the format required by the {\tt SLRP} parser generator.
For easy comparison, cross-references with the SPARK manual (SM \cite{PVL90}) (and  hence with the Ada Language Reference Manual) have been added where appropriate.

 

\subsubsection{Purpose and Background}


\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{DESIGN ISSUES}

\section{PREAMBLE}
=DOC
signature ÛCNParserÝ = sig
=DESCRIBE
This is the signature for the structure containing the parser for SPARK.
=ENDDOC

\section{GRAMMAR}

This grammar is based on that specified in \cite{DRA/CIS/CSE3/SWI/WP/9}.

Z paragraphs are supported by \Product\/  and a production branch in
the $web\_clause$ is not required.

The entry point to the grammar (sentence symbol) is placed first, because that is where {\tt SLRP} expects to find it.

=DUMP dtd503.grm.txt
Ûweb_clauseÝ =	compilation
		|	`CompLabel`, `ReplacedBy`, compilation
		|	`PPartLabel`, `ReplacedBy`, private_part
		|	`VPartLabel`, `ReplacedBy`, visible_part
		|	`DecLabel`, `ReplacedBy`, dec, dp1
		|	`StmtLabel`, `ReplacedBy`, sequence_of_statements
		|	`SpecLabel`, `RefinedBy`, sequence_of_statements
		|	`RefinedBy`, sequence_of_statements
		|	`SpecLabel`, `ReplacedBy`, sequence_of_statements
		|	`ReplacedBy`, sequence_of_statements;
=TEX
SPARK manual 3.1:
=DUMPMORE dtd503.grm.txt

Ûbasic_declarationÝ =	object_declaration
		|	type_declaration
		|	subtype_declaration
		|	deferred_constant_declaration;
=TEX
SPARK manual 3.2:
=DUMPMORE dtd503.grm.txt

Ûobject_declarationÝ =	constant_declaration
			|	variable_declaration;
=TEX
SPARK manual 3.2:
=DUMPMORE dtd503.grm.txt

Ûconstant_declarationÝ =	identifier_list, `Colon`, `Constant`,
				type_mark, `Becomes`, expression, `Semi`;
	
Ûvariable_declarationÝ =	identifier_list, `Colon`, type_mark, `Semi`;

Ûidentifier_listÝ =	`Identifier`, id_list;

Ûid_listÝ	=
		|	`Comma`, identifier_list;
(* **** should be able to elide id_list again as in SPARK manual **** *)
=TEX
SPARK manual 3.3.1:
=DUMPMORE dtd503.grm.txt
Ûtype_declarationÝ =	full_type_declaration
		|	private_type_declaration;

Ûfull_type_declarationÝ =	`Type`, `Identifier`, `Is`, type_definition, `Semi`;

Ûtype_definitionÝ =	enumeration_type_definition
		|	integer_type_definition
		|	real_type_definition
		|	array_type_definition
		|	record_type_definition;
=TEX
SPARK manual 3.3.2:
=DUMPMORE dtd503.grm.txt
Ûsubtype_declarationÝ =	`SubType`, `Identifier`, `Is`, subtype_indication, `Semi`;

Ûsubtype_indicationÝ =	type_mark, constraint;

(* **** type_mark is just a name **** *)

ÛconstraintÝ	=	range_constraint
		|	floating_point_constraint
		|	fixed_point_constraint
		|	index_constraint;
=TEX
SPARK manual 3.5:
=DUMPMORE dtd503.grm.txt
Ûrange_constraintÝ =	`RRange`, range;

ÛrangeÝ =	simple_expression
		|	simple_expression, `DotDot`, simple_expression;

(* **** Don't understand: first alternative should be attribute **** *)
=TEX
SPARK manual 3.5.1:
=DUMPMORE dtd503.grm.txt

Ûenumeration_type_definitionÝ =
			`Ord`, identifier_list, `Crd`;
=TEX
SPARK manual 3.5.4:
=DUMPMORE dtd503.grm.txt

Ûinteger_type_definitionÝ =
			range_constraint;
=TEX
SPARK manual 3.5.6:
=DUMPMORE dtd503.grm.txt

Ûreal_type_definitionÝ =	floating_point_constraint
			|	fixed_point_constraint;
=TEX
SPARK manual 3.5.7:
=DUMPMORE dtd503.grm.txt

Ûfloating_point_constraintÝ =
			floating_accuracy_definition
		|	floating_accuracy_definition, range_constraint;

Ûfloating_accuracy_definitionÝ =
			`Digits`, simple_expression;
=TEX
SPARK manual 3.5.9:
=DUMPMORE dtd503.grm.txt

Ûfixed_point_constraintÝ =
			fixed_accuracy_definition
		|	fixed_accuracy_definition, range_constraint;

Ûfixed_accuracy_definitionÝ =
			`Delta`, simple_expression;
=TEX
SPARK manual 3.6:
=DUMPMORE dtd503.grm.txt

Ûarray_type_definitionÝ =	unconstrained_array_definition
			|	constrained_array_definition;

Ûunconstrained_array_definitionÝ =
			`Array`, `Ord`, index_subtype_definition_list, `Crd`, `Of`, type_mark;

Ûconstrained_array_definitionÝ =
			`Array`, index_constraint, `Of`, type_mark;

Ûindex_subtype_definition_listÝ =
			index_subtype_definition, subtype_list;

Ûsubtype_listÝ =
		|	`Comma`, index_subtype_definition_list;

(* **** should be able to elide subtype_list again as in SPARK manual **** *)

Ûindex_subtype_definitionÝ =
			type_mark, `RRange`, `LessGreat`;

Ûindex_constraintÝ =	`Ord`, type_mark_list, `Crd`;

Ûtype_mark_listÝ =	type_mark, type_list;

Ûtype_listÝ =
		|	`Comma`, type_mark_list;
(* **** n.b.may want to identify type_mark_list with name list or similar **** *)

Ûdiscrete_rangeÝ =	type_mark
		|	type_mark, range_constraint
		|	range;
=TEX
SPARK manual 3.7:
=DUMPMORE dtd503.grm.txt

Ûrecord_type_definitionÝ =
			`Record`, component_list, `End`, `Record`;

Ûcomponent_listÝ =	component_declaration, comp_list;

Ûcomp_listÝ =
		|	`Comma`, component_list;

Ûcomponent_declarationÝ =	identifier_list, `Colon`, type_mark, `Semi`;
=TEX
SPARK manual 3.9:
=DUMPMORE dtd503.grm.txt

Ûdeclarative_partÝ =	dec, dp1;

Ûdp1Ý =
		|	dec, dp1;
(* **** Insisting on at least one declaration seems odd **** *)
(* **** dp1 could be elided **** *)

ÛdecÝ =		`KSlot`
		|	renaming_declaration
		|	basic_declarative_item
		|	package_declaration
		|	body;

Ûbasic_declarative_itemÝ =
			basic_declaration
		|	representation_clause;
(* **** this disallows SPARK's proof declarations **** *)

ÛbodyÝ =		proper_body
		|	body_stub;

Ûproper_bodyÝ =	subprogram_body
		|	package_body;
=TEX
SPARK manual 4.1:
=DUMPMORE dtd503.grm.txt
ÛnameÝ =		simple_name, select;
(* **** this area doesn't seem to make sense **** *)
(* **** things like `f(1,2)(1,2,3)("a")' seem to be allowed as names **** *)

ÛselectÝ =
		|	`Dot`, simple_name, select
		|	`Ord`, exp_list, `Crd`, select;

=TEX
with
=IGN
ÛnameÝ =		simple_name
		|	indexed_component
		|	selected_component;
=TEX
SPARK manual 4.1.1:
=DUMPMORE dtd503.grm.txt

Ûindexed_componentÝ =	prefix, `Ord`, expression_list, `Crd`; 
=TEX
SPARK manual 4.1.3:
=DUMPMORE dtd503.grm.txt

Ûselected_componentÝ =	prefix, `Dot`, selector;

ÛselectorÝ =		simple_name;

=TEX
=TEX
SPARK manual 4.1/4.1.1:
=DUMPMORE dtd503.grm.txt
(* **** this part is out of order **** *)
Ûsimple_nameÝ =		`Identifier`;

ÛprefixÝ =		name
		|	function_call;

Ûexpression_listÝ =	expression, exp_list;

Ûexp_listÝ =
		|	`Comma`, expression_list;
=TEX
SPARK manual 4.1.4:
=DUMPMORE dtd503.grm.txt

ÛattributeÝ =		prefix, `Prime`, attribute_designator
		|	`CharacterLiteral`, `Prime`, attribute_designator;

Ûattribute_designatorÝ =
			namexp, namexp_list;

Ûnamexp_listÝ =
		|	`Prime`, attribute_designator;

ÛnamexpÝ =		simple_name
		|	simple_name, `Ord`, expression, `Crd`;
=TEX
SPARK manual 4.3:
=DUMPMORE dtd503.grm.txt

ÛaggregateÝ =		`Ord`, component_association, `Crd`
		|	`Ord`, component_association, `CommaOthers`,
				`GoesTo`, expression, `Crd`
		|	`Ord`, `Others`, `GoesTo`, expression, `Crd`;

Ûcomponent_associationÝ =	`Na`, named_association
		|	positional_association;
(* **** What's `Na'? **** *)

Ûnamed_associationÝ =	aggregate_choice_list, `GoesTo`, expression, ass_list;

Ûass_listÝ =
		|	`Comma`, named_association;

Ûaggregate_choice_listÝ =
			aggregate_choice, ag_list;

Ûag_listÝ =
		|	`Bar`, aggregate_choice_list;

Ûaggregate_choiceÝ =	discrete_range;

Ûpositional_associationÝ =
			expression_list;
(* **** I don't see where the Ada LRM's rule that ``named notation is .... *)
(* .... required for an aggegrate with a single component'' comes in here **** *)

=TEX
SPARK manual 4.4:
=DUMPMORE dtd503.grm.txt

ÛexpressionÝ =		relation, reltail;

ÛreltailÝ =
		|	and_relation
		|	and_then_relation
		|	or_relation
		|	or_else_relation
		|	xor_relation;

Ûand_relationÝ =	`And`, relation
		|	`And`, relation, and_relation;

Ûand_then_relationÝ =	`And`, `Then`, relation
			|	`And`, `Then`, relation, and_then_relation;

Ûor_relationÝ =		`Or`, relation
		|	`Or`, relation, or_relation;

Ûor_else_relationÝ =	`Or`, `Else`, relation
		|	`Or`, `Else`, relation, or_else_relation;

Ûxor_relationÝ =	`Xor`, relation
		|	`Xor`, relation, xor_relation;
(* **** The above could all be abbreviated by making the LRM's class .... *)
(* .... ``logical operator'' a terminal symbol and imposing a later check **** *)

ÛrelationÝ =		simple_expression, rel2;

Ûrel2Ý =
		|	relational_operator, simple_expression
		|	`In`, range
		|	`Not`, `In`, range
		|	`In`, type_mark
		|	`Not`, `In`, type_mark;

Ûsimple_expressionÝ =	term, binoptail
			|	unary_adding_operator, term, binoptail;

ÛbinoptailÝ =
		|	binary_adding_operator, term, binoptail;

ÛtermÝ =		factor, multoptail;

ÛmultoptailÝ =
		|	multiplying_operator, factor;

ÛfactorÝ =		primary
		|	primary, `StarStar`, primary
		|	`Abs`, primary
		|	`Not`, primary;

ÛprimaryÝ =		`NumericLiteral`
		|	`CharacterLiteral`
		|	`StringLiteral`
		|	name
		|	function_call
		|	type_conversion
		|	qualified_expression
		|	attribute
		|	`Ord`, expression, `Crd`
		|	`AbstractExpression`;
=TEX
SPARK manual 4.5:
=DUMPMORE dtd503.grm.txt
Ûrelational_operatorÝ =	`Equals`
			|	`NotEquals`
			|	`LessThan`
			|	`LessEquals`
			|	`GreaterThan`
			|	`GreaterEquals`;

Ûbinary_adding_operatorÝ =
			`Plus`
			|	`Minus`
			|	`Ampersand`;

Ûunary_adding_operatorÝ =	`Plus`
		|	`Minus`;

Ûmultiplying_operatorÝ =	`Star`
		|	`Div`
		|	`Mod`
		|	`Rem`;
=TEX
SPARK manual 4.6:
=DUMPMORE dtd503.grm.txt

Ûtype_conversionÝ =	type_mark, `Ord`, expression, `Crd`;
=TEX
SPARK manual 4.7:
=DUMPMORE dtd503.grm.txt

Ûqualified_expressionÝ =	type_mark, `Prime`, aggregate;

=TEX
SPARK manual 5:
=DUMPMORE dtd503.grm.txt
Ûsequence_of_statementsÝ =
			statement, statement_list;

Ûstatement_listÝ =
		|	sequence_of_statements;

ÛstatementÝ =		`KSlot`
		|	`SpecificationStatement`
		|	`Con`, `ZDecl`, `FatDot`, `SpecificationStatement`
		|	simple_statement
		|	compound_statement;
=TEX
SPARK manual 5.1:
=DUMPMORE dtd503.grm.txt

Ûsimple_statementÝ =	null_statement
		|	assignment_statement
		|	procedure_call_statement
		|	exit_statement
		|	return_statement;

Ûcompound_statementÝ =	if_statement
			|	case_statement
			|	loop_statement;

Ûnull_statementÝ =	`Null`, `Semi`;

=TEX
SPARK manual 5.2:
=DUMPMORE dtd503.grm.txt
Ûassignment_statementÝ =	name, `Becomes`, expression, `Semi`;
=TEX
SPARK manual 5.3:
=DUMPMORE dtd503.grm.txt

Ûif_statementÝ = 		`If`, condition,
				`Then`, sequence_of_statements,
				elsif_part,
				else_part,
				`End`, `If`, `Semi`;

Ûelsif_partÝ =
		|		`ElsIf`, condition,
				`Then`, sequence_of_statements,
				elsif_part;

Ûelse_partÝ =
		|		`Else`, sequence_of_statements;

ÛconditionÝ = expression;
=TEX
SPARK manual 5.4:
=DUMPMORE dtd503.grm.txt

Ûcase_statementÝ =	`Case`, expression,
			`Is`,
				case_statement_alternative_list,
				others_part,
			`End`, `Case`, `Semi`;

Ûcase_statement_alternative_listÝ =
			case_statement_alternative
		|	case_statement_alternative, case_statement_alternative_list;

Ûcase_statement_alternativeÝ =
			`When`, case_choice_list, `GoesTo`, sequence_of_statements;

Ûcase_choice_listÝ =	case_choice
		|	case_choice, `Bar`, case_choice_list;

Ûcase_choiceÝ =		discrete_range;

Ûothers_partÝ =
		|	`WhenOthers`, `GoesTo`, sequence_of_statements;
=TEX
SPARK manual 5.5:
=DUMPMORE dtd503.grm.txt

Ûloop_statementÝ =	name_opt1, iteration_scheme_opt,
			until_opt,
			`Loop`, sequence_of_statements,
			`End`, `Loop`, name_opt2, `Semi`;
(* **** SPARK has no use for, and does not allow, the optional names  **** *)
(* **** Neither SPARK nor Ada have ``until'' **** *)

Ûname_opt1Ý =
		|	simple_name, `Colon`;

Ûname_opt2Ý =
		|	simple_name;

Ûiteration_scheme_optÝ =
		|	iteration_scheme;

Ûiteration_schemeÝ =	`While`, condition
		|	`For`, loop_parameter_specification;


Ûloop_parameter_specificationÝ =
			`Identifier`, `In`, type_mark
		|	`Identifier`, `In`, `Reverse`, type_mark
		|	`Identifier`, `In`, type_mark, `RRange`, range
		|	`Identifier`, `In`, `Reverse`, type_mark, `RRange`, range;

Ûuntil_optÝ =
		|	`Until`, `AqTm`;
=TEX
SPARK manual 5.7:
=DUMPMORE dtd503.grm.txt

Ûexit_statementÝ =	`Exit`, `Semi`
		|	`Exit`, `When`, condition, `Semi`;
=TEX
SPARK manual 5.8:
=DUMPMORE dtd503.grm.txt

Ûreturn_statementÝ =	`Return`, expression, `Semi`;
=TEX
SPARK manual 6.1:
=DUMPMORE dtd503.grm.txt

Ûsubprogram_declarationÝ =
			procedure_specification, `Semi`
		|	function_specification, `Semi`;
(* **** SPARK's annotations have been dropped  **** *)

Ûsubprogram_specificationÝ =
			procedure_specification
		|	function_specification;

Ûprocedure_specificationÝ =
			`Procedure`, `Identifier`
		|	`Procedure`, `Identifier`, `SpecificationStatement`
		|	`Procedure`, `Identifier`, formal_part
		|	`Procedure`, `Identifier`, formal_part, `SpecificationStatement`;

Ûfunction_specificationÝ =
			`Function`, designator, `Return`, type_mark
		|	`Function`, designator, `Return`, type_mark,
			`SpecificationStatement`
		|	`Function`, designator, formal_part, `Return`, type_mark
		|	`Function`, designator, formal_part, `Return`, type_mark,
			`SpecificationStatement`;

ÛdesignatorÝ =		`Identifier`;

Ûoperator_symbolÝ =	`StringLiteral`;

Ûformal_partÝ =		`Ord`, parlist, `Crd`;

ÛparlistÝ =		parameter_specification
		|	parameter_specification, `Semi`, parlist;

Ûparameter_specificationÝ =
			identifier_list, `Colon`, mode, type_mark;

ÛmodeÝ =
		|	`In`
		|	`Out`
		|	`In`, `Out`;
=TEX
SPARK manual 6.3:
=DUMPMORE dtd503.grm.txt

Ûsubprogram_bodyÝ =	procedure_specification, `Is`, subprogram_implementation
			|	function_specification, `Is`, subprogram_implementation;

Ûsubprogram_implementationÝ =
			declarative_part,
			`Begin`,
			sequence_of_statements,
			`End`, designator, `Semi`;
(* **** SPARK's annotations have been dropped  **** *)
(* **** SPARK's code insertions have been dropped  **** *)
(* **** SPARK's hidden parts have been dropped  **** *)
=TEX
SPARK manual 6.4:
=DUMPMORE dtd503.grm.txt

Ûprocedure_call_statementÝ =
			procedure_name, `Semi`
		|	procedure_name, actual_parameter_part, `Semi`;

Ûfunction_callÝ =		function_name
			|	function_name, actual_parameter_part;

Ûactual_parameter_partÝ =	`Ord`, parameter_association, `Crd`;

Ûparameter_associationÝ =	named_parameter_association
			|	positional_parameter_association;

Ûnamed_parameter_associationÝ =
			formal_parameter, `GoesTo`, actual_parameter
		|	formal_parameter, `GoesTo`, actual_parameter,
				`Comma`, named_parameter_association;

Ûpositional_parameter_associationÝ =
			actual_parameter
		|	actual_parameter, `Comma`, positional_parameter_association;
=TEX
$formal\_parameter$ changed from $simple\_name$ to $name$.
=DUMPMORE dtd503.grm.txt

Ûformal_parameterÝ =	simple_name;

Ûactual_parameterÝ =	expression;
=TEX
SPARK manual 7.1:
=DUMPMORE dtd503.grm.txt

Ûpackage_declarationÝ =	package_specification, `Semi`;

Ûpackage_specificationÝ =
			`Package`, `Identifier`,
			`Is`,
				visible_part,
			`End`, simple_name
		|	`Package`, `Identifier`,
			`Is`,
				visible_part,
			`Private`,
				private_part,
			`End`, simple_name;

Ûvisible_partÝ =	visdec
		|	visdec, visible_part;

ÛvisdecÝ =		`KSlot`
		|	basic_declarative_item
		|	subprogram_declaration;

Ûprivate_partÝ =	pdec
		|	pdec, private_part;

ÛpdecÝ =		`KSlot`
		|	basic_declarative_item;

=TEX
=DUMPMORE dtd503.grm.txt
Ûpackage_bodyÝ =		`Package`, `BBody`, simple_name,
				`Is`,
					package_implementation,
				`End`, simple_name, `Semi`;

Ûpackage_implementationÝ =
			declarative_part
		|	declarative_part, `Begin`, package_initialization;

Ûpackage_initializationÝ =
			sequence_of_statements;
=TEX
SPARK manual 7.4:
=DUMPMORE dtd503.grm.txt

Ûprivate_type_declarationÝ =
			`Type`, `Identifier`, `Is`, `Private`, `Semi`
		|	`Type`, `Identifier`, `Is`, `Limited`, `Private`, `Semi`;

Ûdeferred_constant_declarationÝ =
			identifier_list, `Colon`, `Constant`, type_mark, `Semi`;
=TEX
SPARK manual 8.5:
=DUMPMORE dtd503.grm.txt

Ûrenaming_declarationÝ =	`Function`, operator_symbol, formal_part,
				`Return`, type_mark,
				`Renames`,
				simple_name, `Dot`, operator_symbol, `Semi`
			|	subprogram_specification,
				`Renames`,
				simple_name, `Dot`, simple_name, `Semi`;

=TEX
SPARK manual 10.1:
=DUMPMORE dtd503.grm.txt
ÛcompilationÝ =		`KSlot`
		|	compilation_unit
		|	compilation_unit, compilation;

Ûcompilation_unitÝ =	context_clause, library_unit
		|	context_clause, secondary_unit;

Ûlibrary_unitÝ =		package_declaration
		|	main_program;

Ûsecondary_unitÝ =	library_unit_body
		|	subunit;

Ûlibrary_unit_bodyÝ =	package_body;

Ûmain_programÝ =	subprogram_body;
=TEX
SPARK manual 10.1.1:
=DUMPMORE dtd503.grm.txt

Ûcontext_clauseÝ =
		|	with_clause;

Ûwith_clauseÝ =		`With`, simple_name_list, `Semi`;

Ûsimple_name_listÝ =	simple_name
		|	simple_name, `Comma`, simple_name_list;
=TEX
SPARK manual 10.2:
=DUMPMORE dtd503.grm.txt

Ûbody_stubÝ =		procedure_specification, `Is`, `Separate`, `Semi`
		|	function_specification, `Is`, `Separate`, `Semi`
		|	`Package`, `BBody`, simple_name, `Is`, `Separate`, `Semi`;

ÛsubunitÝ =		`Separate`, `Ord`, name, `Crd`, proper_body;
=TEX
SPARK manual 13.1:
=DUMPMORE dtd503.grm.txt

Ûrepresentation_clauseÝ =
			type_representation_clause, address_clause;

Ûtype_representation_clauseÝ =
			length_clause
		|	enumeration_representation_clause
		|	record_representation_clause;
=TEX
SPARK manual 13.2:
=DUMPMORE dtd503.grm.txt

Ûlength_clauseÝ =	`For`, attribute, `Use`, simple_expression, `Semi`;
=TEX
SPARK manual 13.3:
=DUMPMORE dtd503.grm.txt

Ûenumeration_representation_clauseÝ =
			`For`, simple_name, `Use`, aggregate, `Semi`;
=TEX
SPARK manual 13.4:
=DUMPMORE dtd503.grm.txt

Ûrecord_representation_clauseÝ =
			`For`, simple_name,
			`Use`,
			`Record`,
				alignment_opt, component_pack,
			`End`, `Record`, `Semi`;

Ûalignment_optÝ =
		|	`At`, `Mod`, simple_expression, `Semi`;

Ûcomponent_packÝ =	component_clause
		|	component_clause, component_pack;

Ûcomponent_clauseÝ =	name, `At`, simple_expression, `RRange`, range, `Semi`;
=TEX
SPARK manual 13.5:
=DUMPMORE dtd503.grm.txt

Ûaddress_clauseÝ =	`For`, simple_name, `Use`, `At`, simple_expression, `Semi`;
(* **** SPARK's code statements have been dropped **** *)
=TEX
The following are additions to the original specification.
=DUMPMORE dtd503.grm.txt
function_name =		`Identifier`;
procedure_name =	`Identifier`;
type_mark =		`Identifier`;
=TEX

\section{GENERATING THE TABLES}
=SH
(
poly `arch`slrp.db >dtd503.grm.run <<!
Slrp.slrp{
	in_file="dtd503.grm.txt",
	out_file="dtd503.grm.sml",
	logfile="dtd503.grm.log",
	eos="Eos",
	loglevel=2};
PolyML.quit();
!
)
=TEX
=TEX
\section{PARSER}
=TEX
\subsection{Context Free Parsing}
=DOC
val Ûcn_parserÝ : CNLex.LEX_ITEM list -> unit
=DESCRIBE
This is the context-free parser for Compliance Notation. It maps the lists of
tokens output by the CN lexical analyser onto datatypes representing
the CN abstract syntax.
=FAILURE
503000	Syntax error
503001	Syntax error in: ?0 <?> ?1
503003	?0 is not expected after ?1
503004	?0 is not a valid sequence or set type name
503011	Lexical analysis error: ?0 is not allowed here in Compliance Notation
503201	Parser internal error: ?0
=ENDDOC
=TEX
=SML
end; (* of signature CNParser *)
=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



