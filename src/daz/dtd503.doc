%  dtd502.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of the SPARK Parser}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD502}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{
This document contains the detailed design for the
DAZ parser.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion~\FormatDate{$Date$%
}) ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
The phase 2 checks and transformations are yet to be documented.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the SPARK parser.

\subsection{Introduction}

\subsubsection{Purpose and Background}


\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{DESIGN ISSUES}

\section{PREAMBLE}
=DOC
signature €SPARKParser› = sig
=DESCRIBE
This is the signature for the structure containing the parser for SPARK.
=ENDDOC

\section{GRAMMAR}

This grammar is based on that specified in \cite{DRA/CIS/CSE3/SWI/WP/9}.

Z paragraphs are supported by \Product\/  and a production branch in
the $web\_clause$ is not required.
=DUMP dtd502.grm.txt
€web_clause› =		compilation
		|	`CompLabel`, `ReplacedBy`, compilation
		|	`PPartLabel`, `ReplacedBy`, private_part
		|	`VPartLabel`, `ReplacedBy`, visible_part
		|	`DecLabel`, `ReplacedBy`, dec, dp1
		|	`StmtLabel`, `ReplacedBy`, sequence_of_statements
		|	`SpecLabel`, `RefinedBy`, sequence_of_statements
		|	`RefinedBy`, sequence_of_statements
		|	`SpecLabel`, `ReplacedBy`, sequence_of_statements
		|	`ReplacedBy`, sequence_of_statements;
=TEX
=DUMPMORE dtd502.grm.txt

€basic_declaration› =	object_declaration
		|	type_declaration
		|	subtype_declaration
		|	deferred_constant_declaration;

€object_declaration› =	constant_declaration
		|	variable_declaration;

€constant_declaration› =	identifier_list, `Colon`, `Constant`, `TypeMark`, `Becomes`, expression, `Semi`;
	
€variable_declaration› =	identifier_list, `Colon`, `TypeMark`, `Semi`;

€identifier_list› =	`Identifier`, id_list;

€id_list›	=
		|	`Comma`, identifier_list;
=TEX
=DUMPMORE dtd502.grm.txt
€type_declaration› =	full_type_declaration
		|	private_type_declaration;

€full_type_declaration› =	`Type`, `Identifier`, `Is`, type_definition, `Semi`;

€type_definition› =	enumeration_type_definition
		|	integer_type_definition
		|	real_type_definition
		|	array_type_definition
		|	record_type_definition;

€subtype_declaration› =	`SubType`, `Identifier`, `Is`, subtype_indication, `Semi`;

€subtype_indication› =	`TypeMark`, constraint;

€constraint›	=	range_constraint
		|	floating_point_constraint
		|	fixed_point_constraint
		|	index_constraint;

€range_constraint› =	`RRange`, range;

€range› =			simple_expression
		|	simple_expression, `DotDot`, simple_expression;


€enumeration_type_definition› =
			`Ord`, identifier_list, `Crd`;

€integer_type_definition› =
			range_constraint;

€real_type_definition› =	floating_point_constraint
		|	fixed_point_constraint;

€floating_point_constraint› =
			floating_accuracy_definition
		|	floating_accuracy_definition, range_constraint;

€floating_accuracy_definition› =
			`Digits`, simple_expression;

€fixed_point_constraint› =
			fixed_accuracy_definition
		|	fixed_accuracy_definition, range_constraint;

€fixed_accuracy_definition› =
			`Delta`, simple_expression;

€array_type_definition› =	unconstrained_array_definition
		|	constrained_array_definition;

€unconstrained_array_definition› =
			`Array`, `Ord`, index_subtype_definition_list, `Crd`, `Of`, `TypeMark`;

€constrained_array_definition› =
			`Array`, index_constraint, `Of`, `TypeMark`;

€index_subtype_definition_list› =
			index_subtype_definition, subtype_list;

€subtype_list› =
		|	`Comma`, index_subtype_definition_list;

€index_subtype_definition› =
			`TypeMark`, `RRange`, `LessGreat`;

€index_constraint› =	`Ord`, type_mark_list, `Crd`;

€type_mark_list› =	`TypeMark`, type_list;

€type_list› =
		|	`Comma`, type_mark_list;

€discrete_range› =	`TypeMark`
		|	`TypeMark`, range_constraint
		|	range;

€record_type_definition› =
			`Record`, component_list, `End`, `Record`;
=TEX
=DUMPMORE dtd502.grm.txt

€component_list› =	component_declaration, comp_list;

€comp_list› =
		|	`Comma`, component_list;

€component_declaration› =	identifier_list, `Colon`, `TypeMark`, `Semi`;

€declarative_part› =	dec, dp1;

€dp1› =
		|	dec, dp1;

€dec› =			`KSlot`
		|	renaming_declaration
		|	basic_declarative_item
		|	package_declaration
		|	body;

€basic_declarative_item› =
			basic_declaration
		|	representation_clause;

€body› =		proper_body
		|	body_stub;

€proper_body› =		subprogram_body
		|	package_body;
=TEX
replaced the following...
=GFT Original Grammar
€name› =		simple_name, select;

€select› =
		|	`Dot`, simple_name, select
		|	`Ord`, exp_list, `Crd`, select;
=TEX
with
=DUMPMORE dtd502.grm.txt
€name› =		simple_name
		|	indexed_component
		|	selected_component;

€indexed_component› =	prefix, `Ord`, expression_list, `Crd`; 

€selected_component› =	prefix, `Dot`, selector;

€selector› =		simple_name;

=TEX

=DUMPMORE dtd502.grm.txt
€simple_name› =		`Identifier`;

€prefix› =		name
		|	function_call;

€expression_list› =	expression, exp_list;

€exp_list› =
		|	`Comma`, expression_list;

€attribute› =		prefix, `Prime`, attribute_designator
		|	`CharacterLiteral`, `Prime`, attribute_designator;

€attribute_designator› =
			namexp, namexp_list;

€namexp_list› =
		|	`Prime`, attribute_designator;

€namexp› =		simple_name
		|	simple_name, `Ord`, expression, `Crd`;

€aggregate› =		`Ord`, component_association, `Crd`
		|	`Ord`, component_association, `CommaOthers`, `GoesTo`, expression, `Crd`
		|	`Ord`, `Others`, `GoesTo`, expression, `Crd`;

€component_association› =	`Na`, named_association
		|	positional_association;

€named_association› =	aggregate_choice_list, `GoesTo`, expression, ass_list;

€ass_list› =
		|	`Comma`, named_association;

€aggregate_choice_list› =
			aggregate_choice, ag_list;

€ag_list› =
		|	`Bar`, aggregate_choice_list;

€aggregate_choice› =	discrete_range;

€positional_association› =
			expression_list;
=TEX
=DUMPMORE dtd502.grm.txt

€expression› =		relation, reltail;

€reltail› =
		|	and_relation
		|	and_then_relation
		|	or_relation
		|	or_else_relation
		|	xor_relation;

€and_relation› =	`And`, relation
		|	`And`, relation, and_relation;

€and_then_relation› =	`And`, `Then`, relation
		|	`And`, `Then`, relation, and_then_relation;

€or_relation› =		`Or`, relation
		|	`Or`, relation, or_relation;

€or_else_relation› =	`Or`, `Else`, relation
		|	`Or`, `Else`, relation, or_else_relation;

€xor_relation› =	`Xor`, relation
		|	`Xor`, relation, xor_relation;

€relation› =		simple_expression, rel2;

€rel2› =
		|	relational_operator, simple_expression
		|	`In`, range
		|	`Not`, `In`, range
		|	`In`, `TypeMark`
		|	`Not`, `In`, `TypeMark`;

€simple_expression› =	term, binoptail
		|	unary_adding_operator, term, binoptail;

€binoptail› =
		|	binary_adding_operator, term, binoptail;

€term› =		factor, multoptail;

€multoptail› =
		|	multiplying_operator, factor;

€factor› =		primary
		|	primary, `StarStar`, primary
		|	`Abs`, primary
		|	`Not`, primary;

€primary› =		`NumericLiteral`
		|	`CharacterLiteral`
		|	`StringLiteral`
		|	name
		|	function_call
		|	type_conversion
		|	qualified_expression
		|	attribute
		|	`Ord`, expression, `Crd`
		|	`AbstractExpression`;

€relational_operator› =	`Equals`
		|	`NotEquals`
		|	`LessThan`
		|	`LessEquals`
		|	`GreaterThan`
		|	`GreaterEquals`;

€binary_adding_operator› =
			`Plus`
		|	`Minus`
		|	`Ampersand`;

€unary_adding_operator› =	`Plus`
		|	`Minus`;

€multiplying_operator› =	`Star`
		|	`Div`
		|	`Mod`
		|	`Rem`;

€type_conversion› =	`TypeMark`, `Ord`, expression, `Crd`;

€qualified_expression› =	`TypeMark`, `Prime`, aggregate;

=TEX
=DUMPMORE dtd502.grm.txt
€sequence_of_statements› =
			statement, statement_list;

€statement_list› =
		|	sequence_of_statements;

€statement› =		`KSlot`
		|	`SpecificationStatement`
		|	`Con`, `ZDecl`, `FatDot`, `SpecificationStatement`
		|	simple_statement
		|	compound_statement;

€simple_statement› =	null_statement
		|	assignment_statement
		|	procedure_call_statement
		|	exit_statement
		|	return_statement;

€compound_statement› =	if_statement
		|	case_statement
		|	loop_statement;

€null_statement› =	`Null`, `Semi`;

=TEX
=DUMPMORE dtd502.grm.txt
€assignment_statement› =	name, `Becomes`, expression, `Semi`;

€if_statement› = 		`If`, condition, `Then`, sequence_of_statements, elsif_part, else_part, `End`, `If`, `Semi`;

€elsif_part› =
		|	`ElsIf`, condition, `Then`, sequence_of_statements, elsif_part;

€else_part› =
		|	`Else`, sequence_of_statements;

€condition› = expression;

€case_statement› =	`Case`, expression, `Is`, case_statement_alternative_list, others_part, `End`, `Case`, `Semi`;

€case_statement_alternative_list› =
			case_statement_alternative
		|	case_statement_alternative, case_statement_alternative_list;

€case_statement_alternative› =
			`When`, case_choice_list, `GoesTo`, sequence_of_statements;

€case_choice_list› =	case_choice
		|	case_choice, `Bar`, case_choice_list;

€case_choice› =		discrete_range;

€others_part› =
		|	`WhenOthers`, `GoesTo`, sequence_of_statements;

€loop_statement› =	name_opt1, iteration_scheme_opt, until_opt, `Loop`, sequence_of_statements, `End`, `Loop`, name_opt2, `Semi`;

€name_opt1› =
		|	simple_name, `Colon`;

€name_opt2› =
		|	simple_name;

€iteration_scheme_opt› =
		|	iteration_scheme;

€iteration_scheme› =	`While`, condition
		|	`For`, loop_parameter_specification;


€loop_parameter_specification› =
			`Identifier`, `In`, `TypeMark`
		|	`Identifier`, `In`, `Reverse`, `TypeMark`
		|	`Identifier`, `In`, `TypeMark`, `RRange`, range
		|	`Identifier`, `In`, `Reverse`, `TypeMark`, `RRange`, range;

€until_opt› =
		|	`Until`, `AqTm`;

€exit_statement› =	`Exit`, `Semi`
		|	`Exit`, `When`, condition, `Semi`;

€return_statement› =	`Return`, expression, `Semi`;
=TEX
=DUMPMORE dtd502.grm.txt

€subprogram_declaration› =
			procedure_specification, `Semi`
		|	function_specification, `Semi`;

€subprogram_specification› =
			procedure_specification
		|	function_specification;

€procedure_specification› =
			`Procedure`, `Identifier`
		|	`Procedure`, `Identifier`, `SpecificationStatement`
		|	`Procedure`, `Identifier`, formal_part
		|	`Procedure`, `Identifier`, formal_part, `SpecificationStatement`;

€function_specification› =
			`Function`, designator, `Return`, `TypeMark`
		|	`Function`, designator, `Return`, `TypeMark`, `SpecificationStatement`
		|	`Function`, designator, formal_part, `Return`, `TypeMark`
		|	`Function`, designator, formal_part, `Return`, `TypeMark`, `SpecificationStatement`;

€designator› =		`Identifier`;

€operator_symbol› =	`StringLiteral`;

€formal_part› =		`Ord`, parlist, `Crd`;

€parlist› =		parameter_specification
		|	parameter_specification, `Semi`, parlist;

€parameter_specification› =
			identifier_list, `Colon`, mode, `TypeMark`;

€mode› =
		|	`In`
		|	`Out`
		|	`In`, `Out`;

€subprogram_body› =	procedure_specification, `Is`, subprogram_implementation
		|	function_specification, `Is`, subprogram_implementation;

€subprogram_implementation› =
			declarative_part, `Begin`, sequence_of_statements, `End`, designator, `Semi`;
=TEX
=DUMPMORE dtd502.grm.txt

€procedure_call_statement› =
			`ProcedureName`, `Semi`
		|	`ProcedureName`, actual_parameter_part, `Semi`;

€function_call› =		`FunctionName`
		|	`FunctionName`, actual_parameter_part;

€actual_parameter_part› =	`Ord`, parameter_association, `Crd`;

€parameter_association› =	named_parameter_association
		|	positional_parameter_association;

€named_parameter_association› =
			formal_parameter, `GoesTo`, actual_parameter
		|	formal_parameter, `GoesTo`, actual_parameter, `Comma`, named_parameter_association;

€positional_parameter_association› =
			actual_parameter
		|	actual_parameter, `Comma`, positional_parameter_association;
=TEX
$formal\_parameter$ changed from $simple\_name$ to $name$.
=DUMPMORE dtd502.grm.txt

€formal_parameter› =	simple_name;

€actual_parameter› =	expression;

€package_declaration› =	package_specification, `Semi`;

€package_specification› =
			`Package`, `Identifier`, `Is`, visible_part, `End`, simple_name
		|	`Package`, `Identifier`, `Is`, visible_part, `Private`, private_part, `End`, simple_name;

€visible_part› =	visdec
		|	visdec, visible_part;

€visdec› =		`KSlot`
		|	basic_declarative_item
		|	subprogram_declaration;

€private_part› =	pdec
		|	pdec, private_part;

€pdec› =		`KSlot`
		|	basic_declarative_item;

=TEX
=DUMPMORE dtd502.grm.txt
€package_body› =		`Package`, `BBody`, simple_name, `Is`, package_implementation, `End`, simple_name, `Semi`;

€package_implementation› =
			declarative_part
		|	declarative_part, `Begin`, package_initialization;

€package_initialization› =
			sequence_of_statements;

€private_type_declaration› =
			`Type`, `Identifier`, `Is`, `Private`, `Semi`
		|	`Type`, `Identifier`, `Is`, `Limited`, `Private`, `Semi`;

€deferred_constant_declaration› =
			identifier_list, `Colon`, `Constant`, `TypeMark`, `Semi`;

€renaming_declaration› =	`Function`, operator_symbol, formal_part, `Return`, `TypeMark`, `Renames`, simple_name, `Dot`, operator_symbol, `Semi`
		|	subprogram_specification, `Renames`, simple_name, `Dot`, simple_name, `Semi`;

=TEX
=DUMPMORE dtd502.grm.txt
€compilation› =		`KSlot`
		|	compilation_unit
		|	compilation_unit, compilation;

€compilation_unit› =	context_clause, library_unit
		|	context_clause, secondary_unit;

€library_unit› =		package_declaration
		|	main_program;

€secondary_unit› =	library_unit_body
		|	subunit;

€library_unit_body› =	package_body;

€main_program› =	subprogram_body;

€context_clause› =
		|	with_clause;

€with_clause› =		`With`, simple_name_list, `Semi`;

€simple_name_list› =	simple_name
		|	simple_name, `Comma`, simple_name_list;

€body_stub› =		procedure_specification, `Is`, `Separate`, `Semi`
		|	function_specification, `Is`, `Separate`, `Semi`
		|	`Package`, `BBody`, simple_name, `Is`, `Separate`, `Semi`;

€subunit› =		`Separate`, `Ord`, name, `Crd`, proper_body;

€representation_clause› =
			type_representation_clause, address_clause;

€type_representation_clause› =
			length_clause
		|	enumeration_representation_clause
		|	record_representation_clause;

€length_clause› =	`For`, attribute, `Use`, simple_expression, `Semi`;

€enumeration_representation_clause› =
			`For`, simple_name, `Use`, aggregate, `Semi`;

€record_representation_clause› =
			`For`, simple_name, `Use`, `Record`, alignment_opt, component_pack, `End`, `Record`, `Semi`;

€alignment_opt› =
		|	`At`, `Mod`, simple_expression, `Semi`;

€component_pack› =	component_clause
		|	component_clause, component_pack;

€component_clause› =	name, `At`, simple_expression, `RRange`, range, `Semi`;

€address_clause› =	`For`, simple_name, `Use`, `At`, simple_expression, `Semi`;

=TEX

\section{GENERATING THE TABLES}
=SH
(
poly /usr/tmp/`arch`slrp.db >dtd502.grm.run <<!
Slrp.slrp{
	in_file="dtd502.grm.txt",
	out_file="dtd502.grm.sml",
	logfile="dtd502.grm.log",
	eos="Eos",
	loglevel=2};
PolyML.quit();
!
)
=TEX
\section{ABSTRACT SYNTAX}
=DOC
=DESCRIBE
These types are used in representing the abstract syntax of SPARK.
=ENDDOC
=TEX
\section{INTERFACE}
=TEX
\subsection{Context Free Parsing}
=DOC
type €LEX_ITEM›
val €SPARK_parser› : LEX_ITEM list -> unit
=DESCRIBE
This is the context-free parser for SPARK. It maps the lists of
tokens output by the SPARK lexical analyser onto datatypes representing
the SPARK abstract syntax.
=FAILURE
502000	Syntax error
502001	Syntax error in: ?0 <?> ?1
502003	?0 is not expected after ?1
502004	?0 is not a valid sequence or set type name
502011	Lexical analysis error: ?0 is not allowed here in SPARK
502201	Parser internal error: ?0
=ENDDOC
=TEX
=SML
end; (* of signature SPARKParser *)
=TEX
\subsection{Case Independence}
=DOC
signature €CaseIndependence› = sig
=DESCRIBE
This is the signature of a structure containing utilities to assist
in implementing support for languages where equality of identifiers
is independent of the case of letters.
=ENDDOC
=DOC
val €to_lower› : string -> string
val €to_upper› : string -> string
=DESCRIBE
$to\_lower\,s$ is $s$ with all upper-case letters replaced by their
lower-case equivalents.

$to\_upper\,s$ is $s$ with all lower-case letters replaced by their
upper-case equivalents.
=ENDDOC
=DOC
val €ci_get_const_names› : string -> string list
=DESCRIBE
Given a string $s$, $ci\_get\_const\_names$ returns the list of
the names of all constants $c$ such that, (i) $c$ is in scope in the
current theory, (ii) the name of $c$ is the same as $s$ when one ignores
the case of any letters in the name.
=FAILURE
502100	Internal error in ci_get_const_names
=ENDDOC
=SML
end; (* of signature CaseIndependence *)
=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



