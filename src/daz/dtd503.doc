%  dtd503.doc %Z% $Date$ $Revision$ $RCSfile$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% This document has these percent lines dotted throughout to help the author
% with getting the formal text to fit within the page.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\def\Source{\cite{DRA/CIS/CSE3/SWI/WP/9/2}}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Compliance Notation Parser}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD503}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{
This document contains the detailed design for the
DAZ parser.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.4] Initial Draft.
\item[Issue \SCCSversion~\FormatDate{$Date$%
}) ] Changed Names to be for Compliance Notation.

\end{description}
\subsection{Changes Forecast}
The phase 2 checks and transformations are yet to be documented.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the Compliance Notation parser.

It includes the Compliance Notation grammar in the format required by the {\tt SLRP} parser generator.

\subsection{Introduction}
The DRA document \Source gives the grammar for the  Compliance Notation.
This document re-expresses that grammar in the format required by the {\tt SLRP} parser generator.
For easy comparison, cross-references with the SPARK manual (SM \cite{PVL90}) (and  hence with the Ada Language Reference Manual) have been added where appropriate.

 

\subsubsection{Purpose and Background}


\subsubsection{Dependencies}
The signature for the Compliance Notation Parser is called $CNParser$ and it depends on the structure $CNTypes$ whose signature is defined in \cite{ISS/HAT/DAZ/DTD502}.


%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{PREAMBLE}
=DOC
signature ÛCNParserÝ = sig
=DESCRIBE
This is the signature for the structure containing the parser for SPARK.
=ENDDOC


\section{CHANGES FROM DRA/CIS/CSE3/SWI/WP/9/2}
This section describes the changes made to the grammar defined in \cite{DRA/CIS/CSE3/SWI/WP/9/2}. The changes have been are grouped as follows:
\begin{description}
\item[To Increase Efficiency.]{In this case the language accepted by this grammar is the same as that specified in \cite{DRA/CIS/CSE3/SWI/WP/9/2}.}
\item[To Remove Ambiguity]{The grammar accepts a wider language. To make the language accepted the same as that in \cite{DRA/CIS/CSE3/SWI/WP/9/2} it is necessary to make various checks in the reduction functions.}
\item[To Add to the Grammar]
\item[Minor Changes]
\end{description}

\subsection{Changes to Remove Ambiguity}
\subsubsection{Ranges}\label{Ranges}

\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Production & Action\\\hline\hline
RA/1 & range & Deleted \\\hline
RA/2 & sr expression & New \\\hline
RA/3 & relation & Changed \\\hline
RA/4 & loop parameter specification & Changed \\\hline
RA/5 & range constraint & Changed \\\hline
RA/6 & discrete range & Changed \\\hline
RA/7 & component clause & Changed \\\hline
\end{tabular}
\caption{Changed Productions for Ranges}
\label{CPR}
\end{table}

\subsubsection{Aggregates}\label{Aggregates}

\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Production & Action\\\hline\hline
AG/1 & aggregate & Changed \\\hline
AG/2 & component association & Changed \\\hline
AG/3 & named association & Changed \\\hline
AG/4 & aggregate choice list & Changed \\\hline
AG/5 & parameter association & Changed \\\hline
AG/6 & named parameter association & Deleted \\\hline
AG/7 & formal parameter & Deleted \\\hline
\end{tabular}
\caption{Changed Productions for Aggregates}
\label{CPA}
\end{table}

\subsubsection{Names}\label{Names}

\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Production & Action\\\hline\hline
NA/1 & name & Changed \\\hline
NA/2 & indexed component & New \\\hline
NA/3 & selected component & Changed \\\hline
NA/4 & select & Deleted \\\hline
\end{tabular}
\caption{Changed Productions for Names}
\label{CPN}
\end{table}

\subsubsection{Function and Procedure Calls}\label{FunctionCalls}
\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Production & Action\\\hline\hline
FC/1 & function call & Deleted \\\hline
FC/2 & prefix & Deleted \\\hline
FC/3 & primary/function call & Deleted \\\hline
FC/4 & type conversion & Deleted \\\hline
FC/5 & procedure call statement & Changed \\\hline
\end{tabular}
\caption{Changed Productions for Function Calls}
\label{CPFC}
\end{table}

\subsection{Additions to the Grammar}

\subsection{Changes to Increase Efficiency}
\subsection{Elision}\label{Elision}

In the LRM there are several productions of the form:

=GFT SPARK Manual 3.2:
identifier_list ::= identifier {, identifier}
=TEX

For this kind of grammatical rule, \Source has systematically introduced a new production which specifically handles the option, as shown in the following example.
=GFT BNF Example

identifier_list =	`LCIdentifier`, id_list;

id_list	=
		|	`LCComma`, identifier_list;
=TEX
It is equally possible to elide the new production and accept the same grammar by writing:
=GFT BNF Example

identifier_list =	`LCIdentifier`
		|	`LCIdentifier`, `LCComma`, identifier_list;
=TEX

In the implemented grammar, the latter form has been used where possible since a) it is more efficient and b) it is LR(1).

The following productions elided in this way are listed in table \ref{ElidedProductions}.

\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id & Elided Production	& Affected Productions\\\hline\hline
EP/1 & id list & identifier list \\\hline
EP/2 & dp1 & web clause, declarative part \\\hline
EP/3 & exp list & expression list\\\hline
EP/4 & rel2 & relation\\\hline
EP/5 & reltail & expression\\\hline
EP/6 & ass list & named association\\\hline
EP/7 & ag list & aggregate choice list\\\hline
EP/8 & multoptail & term\\\hline
EP/9 & statement list & sequence of statements\\\hline
EP/10 & subtype list & index subtype definition list\\\hline
\end{tabular}
\caption{Elided Productions}
\label{ElidedProductions}
\end{table}

\subsection{Minor Changes}
\subsubsection{Simple Names}
Simple names are lexically equivalent to identifiers, and where there are occurrences of simple name in \Source, identifier has been used here. The productions affected are listed in table \ref{RemovalofSimpleName}.
\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Productions\\\hline\hline
SN/1 & simple name \\\hline
SN/2 & selector \\\hline
SN/3 & name opt1 \\\hline
SN/4 & name opt2 \\\hline
SN/5 & package body \\\hline
SN/6 & renaming declaration \\\hline
SN/7 & enumeration representation clause \\\hline
SN/8 & address clause \\\hline
\end{tabular}
\caption{Removal of Simple Name}
\label{RemovalofSimpleName}
\end{table}
\subsubsection{Type Mark}
Type marks are terminals in \Source. They are lexically indistinguishable from names. The grammar has been adjusted throughout to use names where type marks are to be found in \Source. The productions affected are listed in tabel \ref{RemovalofTypeMark}.
\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Production & Action\\\hline\hline
TM/1 & constant declaration & Changed \\\hline
TM/2 & variable declaration & Changed \\\hline
TM/3 & subtype indication & Changed \\\hline
TM/4 & unconstrained array definition & Changed \\\hline
TM/5 & constrained array definition & Changed \\\hline
TM/6 & index subtype definition & Changed\\\hline
TM/7 & index constraint & Changed \\\hline
TM/8 & type mark list & Deleted \\\hline
TM/9 & type list & Deleted \\\hline
TM/10 & name list & New \\\hline
TM/11 & component declaration & Changed \\\hline
TM/12 & discriminant part & Changed \\\hline
TM/13 & qualified expression & Changed \\\hline
TM/14 & loop parameter specification & Changed \\\hline
TM/15 & function specification & Changed \\\hline
TM/16 & parameter specification & Changed \\\hline
TM/17 & deferred constant declaration & Changed \\\hline
TM/18 & renaming declaration & Changed \\\hline
\end{tabular}
\caption{Removal of Type Mark}
\label{RemovalofTypeMark}
\end{table}

\subsubsection{K-Slots, Specification Statements and Labels}\label{KSSL}
A Production for labels for specification statements and K-Slots has been added. A classifier function is provided to recognise a `Ord`...`NumericLiteral`...`Crd`... sequence at the beginning of a web clause and turn it into a label terminal (e.g., `LCSpecLabel`, `LCDecLabel`) depending on environment information. This means that the grammar does not have to be changed from \Source.

However, labels which can appear optionally after a specification statement or a k-slot appear in the grammar as `Ord`...`NumericLiteral`...`Crd` since the embedding of the labels in the grammar (and their equivalence to a primary) makes it impossible to classify them as either a `DecLabel` or a `StmtLabel` prior to parsing the input. A new production is provided  for labels.

The grammar for specification statments is simple if the Z which it can contain is expressed as a terminal symbol. There is a new production for a specification statement.

K-Slots have an optional label which is semantically important. Therefore the body of the k-slot (including the chevrons) appear in the grammar as a terminal, an a new production for a k-slot is provided which allows an optional label to be appended. The changes are listed in table \ref{NPKSLSS}.
\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Production & Action\\\hline\hline
KS/1 & k slot & New \\\hline
LA/1 & label & New \\\hline
SS/1 & specification statement & New \\\hline
\end{tabular}
\caption{New Productions for K-Slots Labels and Specification Statements}
\label{NPKSLSS}
\end{table}

\subsubsection{Primed Identifiers}\label{PrimedIdentifiers}
Attribute designators may be reserved words (e.g., P'RANGE) in Ada. In order to aviod the problem of having to accept either a `Range` token for example, and an `Identifier`, it is more convenient to arrange for the lexical analyser to regard a Prime followed by an alpha-numeric literal as a separate kind of token. Thus P'RANGE is tokenised as [`Identifier`, `LCPrimedIdentifier`] rather than the more problematic [`Identifier`,`Prime`,`Range`]. The production affected is shown in table \ref{CPPI}.

TBS - more
\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Production & Action\\\hline\hline
AT/1 & attribute & Changed \\\hline
AT/2 & attribute designator & Deleted \\\hline
AT/3 & namexp list & Deleted \\\hline
AT/4 & namexp & Deleted \\\hline
AT/5 & primary & Changed \\\hline
\end{tabular}
\caption{Changed Productions for Primed Identifiers}
\label{CPPI}
\end{table}

\subsubsection{Abstract Expressions}\label{Abstract Expressions}
Abstract expressions appear in \Source as a terminal symbol. An abstract expression comprises some Z enclosed in Strachey brackets. A new production is provided to reflect this. The till clause is changed to accept an abstract expression rather than the terminal z\_decl.
The change is listed in table \ref{NCPAE}.
\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Production & Action\\\hline\hline
AE/1 & abstract expression & New \\\hline
AE/2 & till opt & Changed \\\hline
\end{tabular}
\caption{New/Changed Productions for Abstract Expressions}
\label{NCPAE}
\end{table}

\subsubsection{Z and Web Clauses}

Z paragraphs are supported by {\Product} and a production branch in
the $web\_clause$ is not required.

\begin{table}
\center
\begin{tabular}{||l|p{3.0in}|l||}\hline
Id &  Affected Production & Action\\\hline\hline
WC/1 & web clause/z & Deleted \\\hline
\end{tabular}
\caption{Labels}
\label{Labels}
\end{table}


\newpage
\section{GRAMMAR}
\subsection{Web Clause}
The entry point to the grammar (sentence symbol) is placed first, because that is where {\tt SLRP} expects to find it.

=DUMP dtd503.grm.txt

Ûweb_clauseÝ =	compilation
					(red_web_clause1 x1)
		|	`LCCompLabel`, `LCReplacedBy`, compilation
					(red_web_clause2 x1 x2 x3)
		|	`LCPPartLabel`, `LCReplacedBy`, private_part
					(red_web_clause3 x1 x2 x3)
		|	`LCVPartLabel`, `LCReplacedBy`, visible_part
					(red_web_clause4 x1 x2 x3)
		|	`LCDecLabel`, `LCReplacedBy`, declarative_part
					(red_web_clause5 x1 x2 x3)
		|	`LCStmtLabel`, `LCReplacedBy`, sequence_of_statements
					(red_web_clause6 x1 x2 x3)
		|	`LCSpecLabel`, `LCRefinedBy`, sequence_of_statements
					(red_web_clause7 x1 x2 x3)
		|	`LCRefinedBy`, sequence_of_statements
					(red_web_clause8 x1 x2)
		|	`LCSpecLabel`, `LCReplacedBy`, sequence_of_statements
					(red_web_clause9 x1 x2 x3)
		|	`LCReplacedBy`, sequence_of_statements
					(red_web_clause10 x1 x2);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Declarations and Types}

SPARK manual 3.1:
=DUMPMORE dtd503.grm.txt

Ûbasic_declarationÝ =		object_declaration
					(red_basic_declaration1 x1)
			|	type_declaration
					(red_basic_declaration2 x1)
			|	subtype_declaration
					(red_basic_declaration3 x1)
			|	deferred_constant_declaration
					(red_basic_declaration4 x1);
=TEX

SPARK manual 3.2:
=DUMPMORE dtd503.grm.txt

Ûobject_declarationÝ =	constant_declaration
					(red_object_declaration1 x1)
			|	variable_declaration
					(red_object_declaration2 x1);
=TEX
The production id list of \Source\  has been elided (see section \ref{Elision}).

SPARK manual 3.2:
=DUMPMORE dtd503.grm.txt

Ûconstant_declarationÝ =	identifier_list, `LCColon`, `LCConstant`, name,
					`LCBecomes`, expression, `LCSemi`
					(red_constant_declaration x1 x2 x3 x4 x5 x6 x7);
	
Ûvariable_declarationÝ =	identifier_list, `LCColon`, name, `LCSemi`
					(red_variable_declaration x1 x2 x3 x4);

Ûidentifier_listÝ =	`LCIdentifier`
					(red_identifier_list1 x1)
		|	`LCIdentifier`, `LCComma`, identifier_list
					(red_identifier_list2 x1 x2 x3);
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SPARK manual 3.3.1:
=DUMPMORE dtd503.grm.txt

Ûtype_declarationÝ =	full_type_declaration
					(red_type_declaration1 x1)
		|	private_type_declaration
					(red_type_declaration2 x1);

Ûfull_type_declarationÝ =	`LCType`, `LCIdentifier`, discriminant_part, `LCIs`, type_definition, `LCSemi`
					(red_full_type_declaration1 x1 x2 x3 x4 x5 x6)
			|	`LCType`, `LCIdentifier`, `LCIs`, type_definition, `LCSemi`
					(red_full_type_declaration2 x1 x2 x3 x4 x5);

Ûtype_definitionÝ =	enumeration_type_definition
					(red_type_definition1 x1)
		|	integer_type_definition
					(red_type_definition2 x1)
		|	real_type_definition
					(red_type_definition3 x1)
		|	array_type_definition
					(red_type_definition4 x1)
		|	record_type_definition
					(red_type_definition5 x1);
=TEX
SPARK manual 3.3.2:
=DUMPMORE dtd503.grm.txt

Ûsubtype_declarationÝ =	`LCSubType`, `LCIdentifier`, `LCIs`, subtype_indication, `LCSemi`
					(red_subtype_declaration x1 x2 x3 x4 x5);

Ûsubtype_indicationÝ =	name, constraint
					(red_subtype_indication x1 x2);
=TEX
SPARK manual 3.3.2:
=DUMPMORE dtd503.grm.txt

ÛconstraintÝ	=	range_constraint
					(red_constraint1 x1)
		|	floating_point_constraint
					(red_constraint2 x1)
		|	fixed_point_constraint
					(red_constraint3 x1);
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SPARK manual 3.5:
=DUMPMORE dtd503.grm.txt

Ûrange_constraintÝ =	`LCRRange`, sr_expression
					(red_range_constraint x1 x2);
=TEX

SPARK manual 3.5.1:
=DUMPMORE dtd503.grm.txt

Ûenumeration_type_definitionÝ =	`LCOrd`, identifier_list, `LCCrd`
					(red_enumeration_type_definition x1 x2 x3);

=TEX

SPARK manual 3.5.4:
=DUMPMORE dtd503.grm.txt

Ûinteger_type_definitionÝ =	range_constraint
					(red_integer_type_definition x1);

=TEX

SPARK manual 3.5.6:
=DUMPMORE dtd503.grm.txt

Ûreal_type_definitionÝ =	floating_point_constraint
					(red_real_type_definition1 x1)
			|	fixed_point_constraint
					(red_real_type_definition2 x1);
=TEX
SPARK manual 3.5.7:
=DUMPMORE dtd503.grm.txt

Ûfloating_point_constraintÝ =	floating_accuracy_definition
					(red_floating_point_constraint1 x1)
				|	floating_accuracy_definition, range_constraint
					(red_floating_point_constraint2 x1 x2);

Ûfloating_accuracy_definitionÝ =	`LCDigits`, simple_expression
					(red_floating_accuracy_definition x1 x2);
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SPARK manual 3.5.9:
=DUMPMORE dtd503.grm.txt

Ûfixed_point_constraintÝ =	fixed_accuracy_definition
					(red_fixed_point_constraint1 x1)
			|	fixed_accuracy_definition, range_constraint
					(red_fixed_point_constraint2 x1 x2);

Ûfixed_accuracy_definitionÝ =	`LCDelta`, simple_expression
					(red_fixed_accuracy_definition x1 x2);
=TEX
SPARK manual 3.6:
=DUMPMORE dtd503.grm.txt

Ûarray_type_definitionÝ =	unconstrained_array_definition
					(red_array_type_definition1 x1)
			|	constrained_array_definition
					(red_array_type_definition2 x1);
Ûunconstrained_array_definitionÝ =
			`LCArray`, `LCOrd`, index_subtype_definition_list, `LCCrd`, `LCOf`, name
					(red_unconstrained_array_definition x1 x2 x3 x4 x5 x6);

Ûconstrained_array_definitionÝ =
			`LCArray`, index_constraint, `LCOf`, name
					(red_constrained_array_definition x1 x2 x3 x4);
Ûindex_subtype_definition_listÝ =
			index_subtype_definition
					(red_index_subtype_definition_list1 x1)
		|	index_subtype_definition, `LCComma`, index_subtype_definition_list
					(red_index_subtype_definition_list2 x1 x2 x3);

Ûindex_subtype_definitionÝ =	name, `LCRRange`, `LCLessGreat`
					(red_index_subtype_definition x1 x2 x3);

Ûindex_constraintÝ =	`LCOrd`, name_list, `LCCrd`
					(red_index_constraint x1 x2 x3);

Ûname_listÝ =		name
					(red_name_list1 x1)
		|	name, `LCComma`, name_list
					(red_name_list2 x1 x2 x3);

Ûdiscrete_rangeÝ =	simple_expression, range_constraint
					(red_discrete_range1 x1 x2)
		|	sr_expression
					(red_discrete_range2 x1);
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SPARK manual 3.7:
=DUMPMORE dtd503.grm.txt

Ûrecord_type_definitionÝ =	`LCRecord`, component_list, `LCEnd`, `LCRecord`
					(red_record_type_definition x1 x2 x3 x4);
=TEX
=DUMPMORE dtd503.grm.txt

Ûcomponent_listÝ =	component_declaration_list
					(red_component_list1 x1)
		|	variant_part
					(red_component_list2 x1)
		|	component_declaration_list, variant_part
					(red_component_list3 x1 x2)
		|	`LCNull`
					(red_component_list4 x1);

Ûcomponent_declaration_listÝ =	component_declaration
					(red_component_declaration_list1 x1)
				|	component_declaration, component_declaration_list
					(red_component_declaration_list2 x1 x2);

Ûcomponent_declarationÝ =	identifier_list, `LCColon`, name, `LCSemi`
					(red_component_declaration x1 x2 x3 x4);

Ûdiscriminant_partÝ =	`LCIdentifier`, `LCColon`, name
					(red_discriminant_part x1 x2 x3);

Ûvariant_partÝ =	`LCCase`, `LCIdentifier`, `LCIs`, variant_list, `LCEnd`, `LCCase`, `LCSemi`
					(red_variant_part x1 x2 x3 x4 x5 x6 x7);

Ûvariant_listÝ =	variant
					(red_variant_list1 x1)
		|	variant, variant_list
					(red_variant_list2 x1 x2);

ÛvariantÝ =	`LCWhen`, variant_choice_list, `LCGoesTo`, component_list
					(red_variant x1 x2 x3 x4);

Ûvariant_choice_listÝ =	`LCIdentifier`
					(red_variant_choice_list1 x1)
			|	`LCIdentifier`, `LCBar`, variant_choice_list
					(red_variant_choice_list2 x1 x2 x3);
=TEX
SPARK manual 3.9:
=DUMPMORE dtd503.grm.txt

Ûdeclarative_partÝ =	dec
					(red_declarative_part1 x1)
		|	dec, declarative_part
					(red_declarative_part2 x1 x2);

ÛdecÝ =		k_slot
					(red_dec1 x1)
	|	renaming_declaration
					(red_dec2 x1)
	|	basic_declarative_item
					(red_dec3 x1)
	|	package_declaration
					(red_dec4 x1)
	|	body
					(red_dec5 x1);

Ûbasic_declarative_itemÝ =	basic_declaration
					(red_basic_declarative_item1 x1)
			|	representation_clause
					(red_basic_declarative_item2 x1);

ÛbodyÝ =	proper_body
					(red_body1 x1)
	|	body_stub
					(red_body2 x1);

Ûproper_bodyÝ =	subprogram_body
					(red_proper_body1 x1)
		|	package_body
					(red_proper_body2 x1);
=TEX
The production rules in SPARK Manual 4.1 have been used since the grammar in \Source is probably too wide (see \ref{Names}).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Names and Expressions}
SPARK manual 4.1:
=DUMPMORE dtd503.grm.txt
ÛnameÝ =		`LCIdentifier`
					(red_name1 x1)
		|	indexed_component
					(red_name2 x1)
		|	selected_component
					(red_name3 x1)
		|	attribute
					(red_name4 x1);
=TEX
SPARK manual 4.1.1:
=DUMPMORE dtd503.grm.txt
Ûindexed_componentÝ =	name, actual_parameter_part
					(red_indexed_component x1 x2);
=TEX
SPARK manual 4.1.3:
=DUMPMORE dtd503.grm.txt
Ûselected_componentÝ =	name, `LCDot`, selector
					(red_selected_component x1 x2 x3);

ÛselectorÝ =		`LCIdentifier`
					(red_selector x1);
=TEX
SPARK manual 4.1/4.1.1:
=DUMPMORE dtd503.grm.txt
Ûexpression_listÝ =	expression
					(red_expression_list1 x1)
		|	expression, `LCComma`, expression_list
					(red_expression_list2 x1 x2 x3);

=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SPARK manual 4.1.4:
=DUMPMORE dtd503.grm.txt
ÛattributeÝ =		name, `LCPrimedIdentifier`
					(red_attribute1 x1 x2)
		|	`LCCharacterLiteral`, `LCPrimedIdentifier`
					(red_attribute2 x1 x2);
=TEX
SPARK manual 4.3:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SPARK manual 4.3:
=DUMPMORE dtd503.grm.txt

ÛaggregateÝ =		`LCOrd`, component_association, `LCCrd`
					(red_aggregate x1 x2 x3);

Ûcomponent_associationÝ =	named_association
					(red_component_association1 x1)
			|	positional_association
					(red_component_association2 x1);

Ûnamed_associationÝ =	aggregate_choice_list, `LCGoesTo`, expression
					(red_named_association1 x1 x2 x3)
			|	aggregate_choice_list, `LCGoesTo`, expression, `LCComma`,
				named_association
					(red_named_association2 x1 x2 x3 x4 x5);

Ûaggregate_choice_listÝ =	`LCOthers`
					(red_aggregate_choice_list1 x1)
			|	aggregate_choice
					(red_aggregate_choice_list2 x1)
			|	aggregate_choice, `LCBar`, aggregate_choice_list
					(red_aggregate_choice_list3 x1 x2 x3);

=TEX
=DUMPMORE dtd503.grm.txt

Ûaggregate_choiceÝ =	discrete_range
					(red_aggregate_choice x1);

Ûpositional_associationÝ =	expression_list
					(red_positional_association x1);
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SPARK manual 4.4:
=DUMPMORE dtd503.grm.txt

ÛexpressionÝ =		relation
					(red_expression1 x1)
		|	relation, and_relation
					(red_expression2 x1 x2)
		|	relation, and_then_relation
					(red_expression3 x1 x2)
		|	relation, or_relation
					(red_expression4 x1 x2)
		|	relation, or_else_relation
					(red_expression5 x1 x2)
		|	relation, xor_relation
					(red_expression6 x1 x2);

Ûand_relationÝ =	`LCAnd`, relation
					(red_and_relation1 x1 x2)
		|	`LCAnd`, relation, and_relation
					(red_and_relation2 x1 x2 x3);

Ûand_then_relationÝ =	`LCAnd`, `LCThen`, relation
					(red_and_then_relation1 x1 x2 x3)
		|	`LCAnd`, `LCThen`, relation, and_then_relation
					(red_and_then_relation2 x1 x2 x3 x4);

Ûor_relationÝ =	`LCOr`, relation
					(red_or_relation1 x1 x2)
		|	`LCOr`, relation, or_relation
					(red_or_relation2 x1 x2 x3);

Ûor_else_relationÝ =	`LCOr`, `LCElse`, relation
					(red_or_else_relation1 x1 x2 x3)
		|	`LCOr`, `LCElse`, relation, or_else_relation
					(red_or_else_relation2 x1 x2 x3 x4);

Ûxor_relationÝ =	`LCXor`, relation
					(red_xor_relation1 x1 x2)
		|	`LCXor`, relation, xor_relation
					(red_xor_relation2 x1 x2 x3);
=TEX
The introduction of an intermediate production for sr expression is to support ranges as expressions and is described in section \ref{Ranges}.
SPARK manual 4.4:
=DUMPMORE dtd503.grm.txt

ÛrelationÝ =		sr_expression
					(red_relation1 x1)
		|	sr_expression, relational_operator, sr_expression
					(red_relation2 x1 x2 x3)
		|	sr_expression, `LCIn`, sr_expression
					(red_relation3 x1 x2 x3)
		|	sr_expression, `LCNot`, `LCIn`, sr_expression
					(red_relation4 x1 x2 x3 x4);

Ûsr_expressionÝ =	simple_expression
					(red_sr_expression1 x1)
		|	simple_expression, `LCDotDot`, simple_expression
					(red_sr_expression2 x1 x2 x3);

Ûsimple_expressionÝ =	term, binoptail
					(red_simple_expression1 x1 x2)
			|	unary_adding_operator, term, binoptail
					(red_simple_expression2 x1 x2 x3);

ÛbinoptailÝ =
					(red_binoptail1)
	|	binary_adding_operator, term, binoptail
					(red_binoptail2 x1 x2 x3);

ÛtermÝ =	factor
					(red_term1 x1)
	|	factor, multiplying_operator, term
					(red_term2 x1 x2 x3);

ÛfactorÝ =	primary
					(red_factor1 x1)
	|	primary, `LCStarStar`, primary
					(red_factor2 x1 x2 x3)
	|	`LCAbs`, primary
					(red_factor3 x1 x2)
	|	`LCNot`, primary
					(red_factor4 x1 x2);
=TEX

The production for primary/function call is not necessary because a function call appear as an indexed component. Similarly for type conversions. (See \ref{FunctionCalls}.
=DUMPMORE dtd503.grm.txt
ÛprimaryÝ =		`LCNumericLiteral`
					(red_primary1 x1)
		|	`LCCharacterLiteral`
					(red_primary2 x1)
		|	`LCStringLiteral`
					(red_primary3 x1)
		|	name
					(red_primary4 x1)
		|	`LCOrd`, expression, `LCCrd`
					(red_primary5 x1 x2 x3)
		|	abstract_expression
					(red_primary6 x1);
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SPARK manual 4.5:
=DUMPMORE dtd503.grm.txt
Ûrelational_operatorÝ =		`LCEquals`
					(red_relational_operator1 x1)
			|	`LCNotEquals`
					(red_relational_operator2 x1)
			|	`LCLessThan`
					(red_relational_operator3 x1)
			|	`LCLessEquals`
					(red_relational_operator4 x1)
			|	`LCGreaterThan`
					(red_relational_operator5 x1)
			|	`LCGreaterEquals`
					(red_relational_operator6 x1);

Ûbinary_adding_operatorÝ =	`LCPlus`
					(red_binary_adding_operator1 x1)
			|	`LCMinus`
					(red_binary_adding_operator2 x1)
			|	`LCAmpersand`
					(red_binary_adding_operator3 x1);

Ûunary_adding_operatorÝ =	`LCPlus`
					(red_unary_adding_operator1 x1)
			|	`LCMinus`
					(red_unary_adding_operator2 x1);

Ûmultiplying_operatorÝ =	`LCStar`
					(red_multiplying_operator1 x1)
			|	`LCDiv`
					(red_multiplying_operator2 x1)
			|	`LCMod`
					(red_multiplying_operator3 x1)
			|	`LCRem`
					(red_multiplying_operator4 x1);
=TEX

Type conversions [SPARK manual 4.6] appear as indexed components.
SPARK manual 4.7:
=DUMPMORE dtd503.grm.txt
Ûqualified_expressionÝ =	name, `LCPrime`, aggregate
					(red_qualified_expression x1 x2 x3);
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Statements}
A production for specification statements has been added as a further refinement to \Source in which a specification statement is a terminal.
A label appended to a specification statement is parsed as a number in brackets. A subsequent check is required to ensure that the number comprises only digits.

A Z declaration in the statement/Con production appears as Z tokens. The parser then has to construct a Z declaration by placing the tokens in a context where a declaration could appear (i.e., a schema) and parse as a Z term using the Z parser. The term is then broken apart to yield the parsed Z declaration.

SPARK manual 5:
=DUMPMORE dtd503.grm.txt

Ûsequence_of_statementsÝ =		statement
					(red_sequence_of_statements1 x1)
				|	statement, sequence_of_statements
					(red_sequence_of_statements2 x1 x2);

ÛstatementÝ =		k_slot
					(red_statement1 x1)
		|	specification_statement
					(red_statement2 x1)
		|	`LCCon`, `LCZ`, `LCFatDot`, specification_statement
					(red_statement3 x1 x2 x3 x4)
		|	simple_statement
					(red_statement4 x1)
		|	compound_statement
					(red_statement5 x1);

Ûspecification_statementÝ =	`LCGrkDelta`, `LCZ`, `LCLSqBrack`, `LCZ`, `LCRSqBrack`
					(red_specification_statement1 x1 x2 x3 x4 x5)
			|	`LCGrkDelta`, `LCZ`, `LCLBrace`, `LCZ`, `LCRBrace`
					(red_specification_statement2 x1 x2 x3 x4 x5)
			|	`LCGrkDelta`, `LCZ`, `LCLSqBrack`, `LCZ`, `LCRSqBrack`, label
					(red_specification_statement3 x1 x2 x3 x4 x5 x6)
			|	`LCGrkDelta`, `LCZ`, `LCLBrace`, `LCZ`, `LCRBrace`, label
					(red_specification_statement4 x1 x2 x3 x4 x5 x6);

ÛlabelÝ =	`LCOrd`, `LCNumericLiteral`, `LCCrd`
					(red_label x1 x2 x3);

Ûk_slotÝ =	`LCKSlot`
					(red_k_slot1 x1)
	|	`LCKSlot`, label
					(red_k_slot2 x1 x2);
=TEX
SPARK manual 5.1:
=DUMPMORE dtd503.grm.txt

Ûsimple_statementÝ =		null_statement
					(red_simple_statement1 x1)
			|	assignment_statement
					(red_simple_statement2 x1)
			|	procedure_call_statement
					(red_simple_statement3 x1)
			|	exit_statement
					(red_simple_statement4 x1)
			|	return_statement
					(red_simple_statement5 x1);

Ûcompound_statementÝ =		if_statement
					(red_compound_statement1 x1)
				|	case_statement
					(red_compound_statement2 x1)
				|	loop_statement
					(red_compound_statement3 x1);

Ûnull_statementÝ =	`LCNull`, `LCSemi`
					(red_null_statement x1 x2);

=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SPARK manual 5.2:
=DUMPMORE dtd503.grm.txt
Ûassignment_statementÝ =	name, `LCBecomes`, expression, `LCSemi`
					(red_assignment_statement x1 x2 x3 x4);
=TEX
SPARK manual 5.3:
=DUMPMORE dtd503.grm.txt

Ûif_statementÝ = 	`LCIf`, condition,
			`LCThen`, sequence_of_statements,
				elsif_part,
				else_part,
			`LCEnd`, `LCIf`, `LCSemi`
					(red_if_statement
						x1 x2 x3 x4 x5 x6 x7 x8 x9);

Ûelsif_partÝ =
					(red_elsif_part1)
		|	`LCElsIf`, condition,
			`LCThen`, sequence_of_statements,
			elsif_part
					(red_elsif_part2 x1 x2 x3 x4 x5);

Ûelse_partÝ =
					(red_else_part1)
		|	`LCElse`, sequence_of_statements
					(red_else_part2 x1 x2);

ÛconditionÝ =		expression
					(red_condition x1);
=TEX
SPARK manual 5.4:
=DUMPMORE dtd503.grm.txt

Ûcase_statementÝ =	`LCCase`, expression,
			`LCIs`,
				case_statement_alternative_list,
				others_part,
			`LCEnd`, `LCCase`, `LCSemi`
					(red_case_statement x1 x2 x3 x4 x5 x6 x7 x8);

Ûcase_statement_alternative_listÝ =
			case_statement_alternative
					(red_case_statement_alternative_list1 x1)
		|	case_statement_alternative, case_statement_alternative_list
					(red_case_statement_alternative_list2 x1 x2);

Ûcase_statement_alternativeÝ =
			`LCWhen`, case_choice_list, `LCGoesTo`, sequence_of_statements
					(red_case_statement_alternative x1 x2 x3 x4);

Ûcase_choice_listÝ =	case_choice
					(red_case_choice_list1 x1)
		|	case_choice, `LCBar`, case_choice_list
					(red_case_choice_list2 x1 x2 x3);

Ûcase_choiceÝ =	discrete_range
					(red_case_choice x1);

Ûothers_partÝ =
					(red_others_part1)
		|	`LCWhenOthers`, `LCGoesTo`, sequence_of_statements
					(red_others_part2 x1 x2 x3);
=TEX

SPARK manual 5.5:
=DUMPMORE dtd503.grm.txt

Ûloop_statementÝ =	name_opt1, iteration_scheme_opt,
			till_opt,
			`LCLoop`, sequence_of_statements,
			`LCEnd`, `LCLoop`, name_opt2, `LCSemi`
					(red_loop_statement
						x1 x2 x3 x4 x5 x6 x7 x8 x9);

Ûname_opt1Ý =
					(red_name_opt11)
		|	`LCIdentifier`, `LCColon`
					(red_name_opt12 x1 x2);

Ûname_opt2Ý =
					(red_name_opt21)
		|	`LCIdentifier`
					(red_name_opt22 x1);

Ûiteration_scheme_optÝ =
					(red_iteration_scheme_opt1)
		|	iteration_scheme
					(red_iteration_scheme_opt2 x1);

Ûiteration_schemeÝ =	`LCWhile`, condition
					(red_iteration_scheme1 x1 x2)
		|	`LCFor`, loop_parameter_specification
					(red_iteration_scheme2 x1 x2);
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Range has been replaced with a more general sr expression in loop parameter specification. A later check will be required to ensure that the sr expression is a range. See section \ref{Ranges} for further information.

Abstract Expressions comprise a ``û'' followed by some Z followed by ``ý''.

SPARK manual 5.5:
=DUMPMORE dtd503.grm.txt
Ûloop_parameter_specificationÝ =
			`LCIdentifier`, `LCIn`, name
					(red_loop_parameter_specification1 x1 x2 x3)
		|	`LCIdentifier`, `LCIn`, `LCReverse`, name
					(red_loop_parameter_specification2 x1 x2 x3 x4)
		|	`LCIdentifier`, `LCIn`, name, `LCRRange`, sr_expression
					(red_loop_parameter_specification3 x1 x2 x3 x4 x5)
		|	`LCIdentifier`, `LCIn`, `LCReverse`, name, `LCRRange`, sr_expression
					(red_loop_parameter_specification4 x1 x2 x3 x4 x5 x6);

Ûtill_optÝ =
					(red_till_opt1)
		|	`LCTill`, abstract_expression
					(red_till_opt2 x1 x2);

Ûabstract_expressionÝ =	`LCLStrachey`, `LCZ`, `LCRStrachey`
					(red_abstract_expression x1 x2 x3);
=TEX
SPARK manual 5.7:
=DUMPMORE dtd503.grm.txt

Ûexit_statementÝ =	`LCExit`, `LCSemi`
					(red_exit_statement1 x1 x2)
		|	`LCExit`, `LCWhen`, condition, `LCSemi`
					(red_exit_statement2 x1 x2 x3 x4);
=TEX
SPARK manual 5.8:
=DUMPMORE dtd503.grm.txt

Ûreturn_statementÝ =	`LCReturn`, expression, `LCSemi`
					(red_return_statement x1 x2 x3);
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Subprograms}
SPARK manual 6.1:
=DUMPMORE dtd503.grm.txt

Ûsubprogram_declarationÝ =
			procedure_specification, `LCSemi`
					(red_subprogram_declaration1 x1 x2)
		|	function_specification, `LCSemi`
					(red_subprogram_declaration2 x1 x2);

Ûsubprogram_specificationÝ =
			procedure_specification
					(red_subprogram_specification1 x1)
		|	function_specification
					(red_subprogram_specification2 x1);
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SPARK manual 6.1:
=DUMPMORE dtd503.grm.txt

Ûprocedure_specificationÝ =
			`LCProcedure`, `LCIdentifier`
					(red_procedure_specification1 x1 x2)
		|	`LCProcedure`, `LCIdentifier`, specification_statement
					(red_procedure_specification2 x1 x2 x3)
		|	`LCProcedure`, `LCIdentifier`, formal_part
					(red_procedure_specification3 x1 x2 x3)
		|	`LCProcedure`, `LCIdentifier`, formal_part, specification_statement
					(red_procedure_specification4 x1 x2 x3 x4);

Ûfunction_specificationÝ =
			`LCFunction`, designator, `LCReturn`, name
					(red_function_specification1 x1 x2 x3 x4)
		|	`LCFunction`, designator, `LCReturn`, name,
			specification_statement
					(red_function_specification2 x1 x2 x3 x4 x5)
		|	`LCFunction`, designator, formal_part, `LCReturn`, name
					(red_function_specification3 x1 x2 x3 x4 x5)
		|	`LCFunction`, designator, formal_part, `LCReturn`, name,
			specification_statement
					(red_function_specification4 x1 x2 x3 x4 x5 x6);
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

SPARK manual 6.1:
=DUMPMORE dtd503.grm.txt

ÛdesignatorÝ =		`LCIdentifier`
					(red_designator x1);

Ûoperator_symbolÝ =	`LCStringLiteral`
					(red_operator_symbol x1);

Ûformal_partÝ =	`LCOrd`, parlist, `LCCrd`
					(red_formal_part x1 x2 x3);

ÛparlistÝ =		parameter_specification
					(red_parlist1 x1)
		|	parameter_specification, `LCSemi`, parlist
					(red_parlist2 x1 x2 x3);

Ûparameter_specificationÝ =	identifier_list, `LCColon`, mode, name
					(red_parameter_specification x1 x2 x3 x4);

ÛmodeÝ =
					(red_mode1)
	|	`LCIn`
					(red_mode2 x1)
	|	`LCOut`
					(red_mode3 x1)
	|	`LCIn`, `LCOut`
					(red_mode4 x1 x2);
=TEX
SPARK's annotations have been dropped.

SPARK's code insertions have been dropped.

SPARK's hidden parts have been dropped.

SPARK manual 6.3:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
=DUMPMORE dtd503.grm.txt

Ûsubprogram_bodyÝ =	procedure_specification, `LCIs`, subprogram_implementation
					(red_subprogram_body1 x1 x2 x3)
			|	function_specification, `LCIs`, subprogram_implementation
					(red_subprogram_body2 x1 x2 x3);

Ûsubprogram_implementationÝ =	declarative_part,
				`LCBegin`,
					sequence_of_statements,
				`LCEnd`, designator, `LCSemi`
					(red_subprogram_implementation x1 x2 x3 x4 x5 x6);
=TEX
SPARK manual 6.4:
=DUMPMORE dtd503.grm.txt
Ûprocedure_call_statementÝ =	name, `LCSemi`
					(red_procedure_call_statement x1 x2);

Ûactual_parameter_partÝ =	`LCOrd`, parameter_association, `LCCrd`
					(red_actual_parameter_part x1 x2 x3);

Ûparameter_associationÝ =	named_association
					(red_parameter_association1 x1)
			|	positional_parameter_association
					(red_parameter_association2 x1);

Ûpositional_parameter_associationÝ =	actual_parameter
					(red_positional_parameter_association1 x1)
				|	actual_parameter, `LCComma`,
						positional_parameter_association
					(red_positional_parameter_association2 x1 x2 x3);
=TEX
=DUMPMORE dtd503.grm.txt
Ûactual_parameterÝ =	expression
					(red_actual_parameter x1);
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Packages}

SPARK manual 7.1:
=DUMPMORE dtd503.grm.txt
Ûpackage_declarationÝ =	package_specification, `LCSemi`
					(red_package_declaration x1 x2);

Ûpackage_specificationÝ =
			`LCPackage`, `LCIdentifier`,
			`LCIs`,
				visible_part,
			`LCEnd`, `LCIdentifier`
					(red_package_specification1 x1 x2 x3 x4 x5 x6)
		|	`LCPackage`, `LCIdentifier`,
			`LCIs`,
				visible_part,
			`LCPrivate`,
				private_part,
			`LCEnd`, `LCIdentifier`
					(red_package_specification2 x1 x2 x3 x4 x5 x6 x7 x8);

Ûvisible_partÝ =	visdec
					(red_visible_part1 x1)
		|	visdec, visible_part
					(red_visible_part2 x1 x2);

=TEX

SPARK manual 7.1:
=DUMPMORE dtd503.grm.txt
ÛvisdecÝ =		k_slot
					(red_visdec1 x1)
		|	basic_declarative_item
					(red_visdec2 x1)
		|	subprogram_declaration
					(red_visdec3 x1);

Ûprivate_partÝ =	pdec
					(red_private_part1 x1)
		|	pdec, private_part
					(red_private_part2 x1 x2);

ÛpdecÝ =	k_slot
					(red_pdec1 x1)
	|	basic_declarative_item
					(red_pdec2 x1);

=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
=DUMPMORE dtd503.grm.txt
Ûpackage_bodyÝ =	`LCPackage`, `LCBBody`, `LCIdentifier`,
			`LCIs`,
				package_implementation,
			`LCEnd`, `LCIdentifier`, `LCSemi`
					(red_package_body x1 x2 x3 x4 x5 x6 x7 x8);

Ûpackage_implementationÝ =	declarative_part
					(red_package_implementation1 x1)
				|	declarative_part, `LCBegin`, package_initialization
					(red_package_implementation2 x1 x2 x3);

Ûpackage_initializationÝ =	sequence_of_statements
					(red_package_initialization x1);
=TEX
SPARK manual 7.4:
=DUMPMORE dtd503.grm.txt

Ûprivate_type_declarationÝ =	`LCType`, `LCIdentifier`, `LCIs`, `LCPrivate`, `LCSemi`
					(red_private_type_declaration1 x1 x2 x3 x4 x5)
				|	`LCType`, `LCIdentifier`, `LCIs`, `LCLimited`, `LCPrivate`, `LCSemi`
					(red_private_type_declaration2 x1 x2 x3 x4 x5 x6);

Ûdeferred_constant_declarationÝ =	identifier_list, `LCColon`, `LCConstant`, name, `LCSemi`
					(red_deferred_constant_declaration x1 x2 x3 x4 x5);
=TEX
\subsection{Visibility Rules}
SPARK manual 8.5:
=DUMPMORE dtd503.grm.txt

Ûrenaming_declarationÝ =	`LCFunction`, operator_symbol, formal_part,
					`LCReturn`, name,
					`LCRenames`,
					`LCIdentifier`, `LCDot`, operator_symbol, `LCSemi`
					(red_renaming_declaration1
						x1 x2 x3 x4 x5 x6 x7 x8 x9 x10)
			|	subprogram_specification,
					`LCRenames`,
					`LCIdentifier`, `LCDot`, `LCIdentifier`, `LCSemi`
					(red_renaming_declaration2 x1 x2 x3 x4 x5 x6);

=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Program Structure and Compilation Issues}
SPARK manual 10.1:
=DUMPMORE dtd503.grm.txt

ÛcompilationÝ =	k_slot
					(red_compilation1)
		|	compilation_unit
					(red_compilation2 x1)
		|	compilation_unit, compilation
					(red_compilation3 x1 x2);
=TEX
SPARK manual 10.1:
=DUMPMORE dtd503.grm.txt

Ûcompilation_unitÝ =	context_clause, library_unit
					(red_compilation_unit1 x1 x2)
		|	context_clause, secondary_unit
					(red_compilation_unit2 x1 x2);

Ûlibrary_unitÝ =	package_declaration
					(red_library_unit1 x1)
		|	main_program
					(red_library_unit2 x1);

Ûsecondary_unitÝ =	library_unit_body
					(red_secondary_unit1 x1)
		|	subunit
					(red_secondary_unit2 x1);

Ûlibrary_unit_bodyÝ =	package_body
					(red_library_unit_body x1);

Ûmain_programÝ =	subprogram_body
					(red_main_program x1);
=TEX
SPARK manual 10.1.1:
=DUMPMORE dtd503.grm.txt

Ûcontext_clauseÝ =
					(red_context_clause1)
		|	with_clause
					(red_context_clause2 x1);
=TEX
In \Source, the with clause production refers to a simple name list. Since simple names are identifiers, here an identifier list is used instead. The production for simple name list is dispensed with.

SPARK manual 10.1.1:
=DUMPMORE dtd503.grm.txt
Ûwith_clauseÝ =	`LCWith`, identifier_list, `LCSemi`
					(red_with_clause x1 x2 x3);
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SPARK manual 10.2:
=DUMPMORE dtd503.grm.txt
Ûbody_stubÝ =		procedure_specification, `LCIs`, `LCSeparate`, `LCSemi`
					(red_body_stub1 x1 x2 x3 x4)
		|	function_specification, `LCIs`, `LCSeparate`, `LCSemi`
					(red_body_stub2 x1 x2 x3 x4)
		|	`LCPackage`, `LCBBody`, `LCIdentifier`, `LCIs`, `LCSeparate`, `LCSemi`
					(red_body_stub3 x1 x2 x3 x4 x5 x6);

ÛsubunitÝ =	`LCSeparate`, `LCOrd`, name, `LCCrd`, proper_body
					(red_subunit x1 x2 x3 x4 x5);
=TEX
\subsection{Representation Clauses}
SPARK manual 13.1:
=DUMPMORE dtd503.grm.txt

Ûrepresentation_clauseÝ =	type_representation_clause, address_clause
					(red_representation_clause x1 x2);

Ûtype_representation_clauseÝ =	length_clause
					(red_type_representation_clause1 x1)
				|	enumeration_representation_clause
					(red_type_representation_clause2 x1)
				|	record_representation_clause
					(red_type_representation_clause3 x1);
=TEX
SPARK manual 13.2:
=DUMPMORE dtd503.grm.txt
Ûlength_clauseÝ =	`LCFor`, attribute, `LCUse`, simple_expression, `LCSemi`
					(red_length_clause x1 x2 x3 x4 x5);
=TEX
SPARK manual 13.3:
=DUMPMORE dtd503.grm.txt
Ûenumeration_representation_clauseÝ =	`LCFor`, `LCIdentifier`, `LCUse`, aggregate, `LCSemi`
					(red_enumeration_representation_clause x1 x2 x3 x4 x5);
=TEX
SPARK manual 13.4:
=DUMPMORE dtd503.grm.txt

Ûrecord_representation_clauseÝ =
			`LCFor`, `LCIdentifier`,
			`LCUse`,
			`LCRecord`,
				alignment_opt, component_pack,
			`LCEnd`, `LCRecord`, `LCSemi`
					(red_record_representation_clause
						x1 x2 x3 x4 x5 x6 x7 x8 x9);
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SPARK manual 13.4:
=DUMPMORE dtd503.grm.txt
Ûalignment_optÝ =
					(red_alignment_opt1)
		|	`LCAt`, `LCMod`, simple_expression, `LCSemi`
					(red_alignment_opt2 x1 x2 x3 x4);
=TEX
=DUMPMORE dtd503.grm.txt
Ûcomponent_packÝ =	component_clause
					(red_component_pack1 x1)
		|	component_clause, component_pack
					(red_component_pack2 x1 x2);
=TEX
SPARK manual 13.4:
=DUMPMORE dtd503.grm.txt
Ûcomponent_clauseÝ =	name, `LCAt`, simple_expression, `LCRRange`, sr_expression, `LCSemi`
					(red_component_clause x1 x2 x3 x4 x5 x6);
=TEX
SPARK manual 13.5:
=DUMPMORE dtd503.grm.txt
Ûaddress_clauseÝ =	`LCFor`, `LCIdentifier`, `LCUse`, `LCAt`, simple_expression, `LCSemi`
					(red_address_clause x1 x2 x3 x4 x5 x6);
=TEX

\section{GENERATING THE TABLES}
=SH
(
poly `arch`slrp.db >dtd503.grm.run <<!
Slrp.slrp{
	in_file="dtd503.grm.txt",
	out_file="dtd503.grm.sml",
	logfile="dtd503.grm.log",
	eos="LCEos",
	loglevel=2};
PolyML.quit();
!
)
=TEX
=TEX
\section{PARSER}
=TEX
\subsection{Context Free Parsing}
=DOC
val Ûcn_parserÝ : CNTypes.CN_LEX_ITEM list -> unit
=DESCRIBE
This is the context-free parser for Compliance Notation. It maps the lists of
tokens output by the CN lexical analyser onto datatypes representing
the CN abstract syntax.
=FAILURE
503000	Syntax error
503001	Syntax error in: ?0 <?> ?1
503003	?0 is not expected after ?1
503004	?0 is not a valid sequence or set type name
503011	Lexical analysis error: ?0 is not allowed here in Compliance Notation
503201	Parser internal error: ?0
=ENDDOC
=TEX
=SML
end; (* of signature CNParser *)
=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\section{ISSUES ARISING}

\begin{enumerate}
\item{Why is the range/simple expression production in \Source not a range/attribute production?}
\item{In dec, the package declaration production does not have an optional renaming declaration as in the SPARK Manual 3.9.}
\item{Declarative part in the SPARK Manual (3.9) can be empty. That in \Source cannot.}
\item{In basic declarative clause, proof declarations in SM 3.9 are omitted in \Source.}
\end{enumerate}
\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



