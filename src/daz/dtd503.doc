%  dtd503.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\def\Source{\cite{DRA/CIS/CSE3/SWI/WP/9/2}}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Compliance Notation Parser}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD503}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{
This document contains the detailed design for the
DAZ parser.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.4] Initial Draft.
\item[Issue \SCCSversion~\FormatDate{$Date$%
}) ] Changed Names to be for Compliance Notation.

\end{description}
\subsection{Changes Forecast}
The phase 2 checks and transformations are yet to be documented.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the Compliance Notation parser.

It includes the Compliance Notation grammar in the format required by the {\tt SLRP} parser generator.

\subsection{Introduction}
The DRA document \Source gives the grammar for the  Compliance Notation.
This document re-expresses that grammar in the format required by the {\tt SLRP} parser generator.
For easy comparison, cross-references with the SPARK manual (SM \cite{PVL90}) (and  hence with the Ada Language Reference Manual) have been added where appropriate.

 

\subsubsection{Purpose and Background}


\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{DESIGN ISSUES}

\section{PREAMBLE}
=DOC
signature ÛCNParserÝ = sig
=DESCRIBE
This is the signature for the structure containing the parser for SPARK.
=ENDDOC

\section{GRAMMAR}

\subsection{Discussion}

This grammar is based on that specified in \Source.

Type marks are terminals in \Source. They are lexically indistinguishable from names. The grammar has been adjusted throughout to use names where type marks are to be found in \Source.

Simple names are lexically equivalent to identifiers, and where there are occurrences of simple name in \Source, identifier has been used here.

\subsubsection{Elision}\label{Elision}

In the LRM there are several productions of the form:

=GFT SPARK Manual 3.2:
identifier_list ::= identifier {, identifier}
=TEX

For this kind of grammatical rule, \Source has systematically introduced a new production which specifically handles the option, as shown in the following example.
=GFT BNF Example

Ûidentifier_listÝ =	`Identifier`, id_list;

Ûid_listÝ	=
		|	`Comma`, identifier_list;
=TEX
It is equally possible to elide the new production and accept the same grammar by writing:
=GFT BNF Example

Ûidentifier_listÝ =	`Identifier`
		|	`Identifier`, `Comma`, identifier_list;
=TEX

In the implemented grammar, the latter form has been used where possible since a) it is more efficient and b) it is LR(1).

\subsection{Web Clause}
The entry point to the grammar (sentence symbol) is placed first, because that is where {\tt SLRP} expects to find it.

=GFT Original Grammar
Ûweb_clauseÝ =		z
		|	compilation
		|	`CompLabel`, `ReplacedBy`, compilation
		|	`PPartLabel`, `ReplacedBy`, private_part
		|	`VPartLabel`, `ReplacedBy`, visible_part
		|	`DecLabel`, `ReplacedBy`, dec, dp1
		|	`StmtLabel`, `ReplacedBy`, sequence_of_statements
		|	`SpecLabel`, `RefinedBy`, sequence_of_statements
		|	`RefinedBy`, sequence_of_statements
		|	`SpecLabel`, `ReplacedBy`, sequence_of_statements
		|	`ReplacedBy`, sequence_of_statements;
=TEX
Z paragraphs are supported by {\Product} and a production branch in
the $web\_clause$ is not required.
DUMP dtd503.grm.txt
Ûweb_clauseÝ =		compilation
		|	`CompLabel`, `ReplacedBy`, compilation
		|	`PPartLabel`, `ReplacedBy`, private_part
		|	`VPartLabel`, `ReplacedBy`, visible_part
		|	`DecLabel`, `ReplacedBy`, dec, dp1
		|	`StmtLabel`, `ReplacedBy`, sequence_of_statements
		|	`SpecLabel`, `RefinedBy`, sequence_of_statements
		|	`RefinedBy`, sequence_of_statements
		|	`SpecLabel`, `ReplacedBy`, sequence_of_statements
		|	`ReplacedBy`, sequence_of_statements;
=TEX
DUMP dtd503.grm.txt
Ûweb_clauseÝ =		compilation
		|	gen_label, `ReplacedBy`, compilation
		|	gen_label, `ReplacedBy`, private_part
		|	gen_label, `ReplacedBy`, visible_part
		|	`DecLabel`, `ReplacedBy`, dec, dp1
		|	gen_label, `ReplacedBy`, sequence_of_statements
		|	gen_label, `RefinedBy`, sequence_of_statements
		|	`RefinedBy`, sequence_of_statements
		|	`ReplacedBy`, sequence_of_statements;

Ûgen_labelÝ =	`Ord`, `NumericLiteral`, `Ord`;
=TEX
=DUMP dtd503.grm.txt
ÛtopÝ =			expression;
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Declarations}

SPARK manual 3.1:
=DUMPMORE dtd503.grm.txt

Ûbasic_declarationÝ =	object_declaration
		|	type_declaration
		|	subtype_declaration
		|	deferred_constant_declaration;
=TEX

SPARK manual 3.2:
=DUMPMORE dtd503.grm.txt

Ûobject_declarationÝ =	constant_declaration
		|	variable_declaration;
=TEX
The production id list of \Source has been elided (see \ref{Elision}).

SPARK manual 3.2:
=DUMPMORE dtd503.grm.txt

Ûconstant_declarationÝ =	identifier_list, `Colon`, `Constant`, name,
					`Becomes`, expression, `Semi`;
	
Ûvariable_declarationÝ =	identifier_list, `Colon`, name, `Semi`;

Ûidentifier_listÝ =	`Identifier`
		|	`Identifier`, `Comma`, identifier_list;
=TEX

SPARK manual 3.3.1:
=DUMPMORE dtd503.grm.txt

Ûtype_declarationÝ =	full_type_declaration
		|	private_type_declaration;

Ûfull_type_declarationÝ =	`Type`, `Identifier`, `Is`, type_definition, `Semi`;

Ûtype_definitionÝ =	enumeration_type_definition
		|	integer_type_definition
		|	real_type_definition
		|	array_type_definition
		|	record_type_definition;
=TEX

SPARK manual 3.3.2:
=DUMPMORE dtd503.grm.txt

Ûsubtype_declarationÝ =	`SubType`, `Identifier`, `Is`, subtype_indication, `Semi`;

Ûsubtype_indicationÝ =	name, constraint;
=TEX
SPARK manual 3.3.2:
=GFT Original Grammar
constraint	=	range_constraint
		|	floating_point_constraint
		|	fixed_point_constraint
		|	index_constraint;
=TEX
An indexed constraint will appear in a subtype indication as an indexed component.
=DUMPMORE dtd503.grm.txt
ÛconstraintÝ	=	range_constraint
		|	floating_point_constraint
		|	fixed_point_constraint;
=TEX
Don't understand: first alternative should be attribute.

SPARK manual 3.5:
=GFT Original Grammar
range =		simple_expression
	|	simple_expression, `DotDot`, simple_expression;
=TEX
=DUMPMORE dtd503.grm.txt
Ûrange_constraintÝ =	`RRange`, sr_expression;
=TEX
SPARK manual 3.5.1:
=DUMPMORE dtd503.grm.txt
Ûenumeration_type_definitionÝ =	`Ord`, identifier_list, `Crd`;
=TEX
SPARK manual 3.5.4:
=DUMPMORE dtd503.grm.txt
Ûinteger_type_definitionÝ =	range_constraint;
=TEX
SPARK manual 3.5.6:
=DUMPMORE dtd503.grm.txt
Ûreal_type_definitionÝ =	floating_point_constraint
			|	fixed_point_constraint;
=TEX
SPARK manual 3.5.7:
=DUMPMORE dtd503.grm.txt
Ûfloating_point_constraintÝ =
			floating_accuracy_definition
		|	floating_accuracy_definition, range_constraint;
=TEX
=GFT Original Grammar
floating_accuracy_definition =	`Digits`, simple_expression;
=TEX
SPARK manual 3.5.7:
=DUMPMORE dtd503.grm.txt
Ûfloating_accuracy_definitionÝ =	`Digits`, sr_expression;
=TEX
SPARK manual 3.5.9:
=DUMPMORE dtd503.grm.txt
Ûfixed_point_constraintÝ =
			fixed_accuracy_definition
		|	fixed_accuracy_definition, range_constraint;
=TEX
SPARK manual 3.5.9:
=GFT Original Grammar
fixed_accuracy_definition =	`Delta`, simple_expression;
=TEX
=DUMPMORE dtd503.grm.txt
Ûfixed_accuracy_definitionÝ =	`Delta`, sr_expression;
=TEX
SPARK manual 3.6:
=DUMPMORE dtd503.grm.txt
Ûarray_type_definitionÝ =	unconstrained_array_definition
			|	constrained_array_definition;

Ûunconstrained_array_definitionÝ =
			`Array`, `Ord`, index_subtype_definition_list, `Crd`, `Of`, name;

Ûconstrained_array_definitionÝ =
			`Array`, index_constraint, `Of`, name;

Ûindex_subtype_definition_listÝ =
			index_subtype_definition, subtype_list;

Ûsubtype_listÝ =
		|	`Comma`, index_subtype_definition_list;

Ûindex_subtype_definitionÝ =
			name, `RRange`, `LessGreat`;
=TEX
SPARK manual 3.6:

=GFT Original Grammar
index_constraint =	`Ord`, typemark_list, `Crd`;

typemark_list =		name, type_list;

type_list =
		|	`Comma`, type_list;

discrete_range =	name
		|	name, range_constraint
		|	range, sr_expression;
=TEX

=DUMPMORE dtd503.grm.txt
Ûindex_constraintÝ =	`Ord`, name_list, `Crd`;

Ûname_listÝ =		name
		|	name, `Comma`, name_list;

Ûdiscrete_rangeÝ =	name, range_constraint
		|	sr_expression;
=TEX
SPARK manual 3.7:
=DUMPMORE dtd503.grm.txt

Ûrecord_type_definitionÝ =
			`Record`, component_list, `End`, `Record`;

Ûcomponent_listÝ =	component_declaration, comp_list;

Ûcomp_listÝ =
		|	`Comma`, component_list;

Ûcomponent_declarationÝ =	identifier_list, `Colon`, name, `Semi`;
=TEX
Insisting on at least one declaration seems odd.


SPARK manual 3.9:
=DUMPMORE dtd503.grm.txt
Ûdeclarative_partÝ =	dec, dp1;

Ûdp1Ý =
		|	dec, dp1;

ÛdecÝ =		`KSlot`
		|	renaming_declaration
		|	basic_declarative_item
		|	package_declaration
		|	body;

Ûbasic_declarative_itemÝ =
			basic_declaration
		|	representation_clause;
=TEX
This disallows SPARK's proof declarations.

SPARK manual 3.9:
=DUMPMORE dtd503.grm.txt
ÛbodyÝ =		proper_body
		|	body_stub;

Ûproper_bodyÝ =	subprogram_body
		|	package_body;
=TEX
SPARK manual 4.1:
=GFT dtd503.grm.txt
ÛnameÝ =		`Identifier`, select;

ÛselectÝ =
		|	`Dot`, `Identifier`, select
		|	`Ord`, exp_list, `Crd`, select;
=TEX
=DUMPMORE dtd503.grm.txt
ÛnameÝ =		`Identifier`
		|	indexed_component
		|	selected_component
		|	attribute;
=TEX
SPARK manual 4.1.1:
=GFT Original Grammar
indexed_component =	prefix, `Ord`, expression_list, `Crd`;
=TEX
=DUMPMORE dtd503.grm.txt
Ûindexed_componentÝ =	name, actual_parameter_part;
=TEX
SPARK manual 4.1.3:
=GFT Original Grammar
selected_component =	prefix, `Dot`, selector;
=TEX
=DUMPMORE dtd503.grm.txt
Ûselected_componentÝ =	name, `Dot`, selector;

ÛselectorÝ =		`Identifier`;
=TEX
SPARK manual 4.1/4.1.1:
=GFT Original Grammar
prefix =	name
	|	function_call;
=TEX
=DUMPMORE dtd503.grm.txt
Ûexpression_listÝ =	expression, exp_list;

Ûexp_listÝ =
		|	`Comma`, expression_list;
=TEX
SPARK manual 4.1.4:
=GFT Original Grammar

attribute =		prefix, `Prime`, attribute_designator
		|	`CharacterLiteral`, `Prime`, attribute_designator;

attribute_designator =	namexp, namexp_list;

namexp_list =
		|	`Prime`, attribute_designator;

namexp =		`Identifier`
		|	`Identifier`, `Ord`, expression, `Crd`;
=TEX
=DUMPMORE dtd503.grm.txt
ÛattributeÝ =		name, `Prime`, `Identifier`
		|	`CharacterLiteral`, `Prime`, `Identifier`;
=TEX
SPARK manual 4.3:
=GFT Original Grammar

aggregate =		`Ord`, component_association, `Crd`
		|	`Ord`, component_association, `CommaOthers`,
				`GoesTo`, expression, `Crd`
		|	`Ord`, `Others`, `GoesTo`, expression, `Crd`;

component_association =	`Na`, named_association
		|	positional_association;

named_association =	aggregate_choice_list, `GoesTo`, expression, ass_list;

ass_list =
		|	`Comma`, named_association;

aggregate_choice_list =
			aggregate_choice, ag_list;
=TEX
SPARK manual 4.3:
=DUMPMORE dtd503.grm.txt

ÛaggregateÝ =		`Ord`, component_association, `Crd`;

Ûcomponent_associationÝ =	named_association
			|	positional_association;

Ûnamed_associationÝ =	aggregate_choice_list, `GoesTo`, expression
		|	aggregate_choice_list, `GoesTo`, expression, `Comma`,
				named_association;

Ûaggregate_choice_listÝ =	`Others`
			|	aggregate_choice
			|	aggregate_choice, `Bar`, aggregate_choice_list;

=TEX
I don't see where the Ada LRM's rule that ``named notation is required for an aggegrate with a single component'' comes in here.
=DUMPMORE dtd503.grm.txt

Ûaggregate_choiceÝ =	discrete_range;

Ûpositional_associationÝ =
			expression_list;
=TEX
SPARK manual 4.4:
=DUMPMORE dtd503.grm.txt

ÛexpressionÝ =		relation, reltail;

ÛreltailÝ =
		|	and_relation
		|	and_then_relation
		|	or_relation
		|	or_else_relation
		|	xor_relation;

Ûand_relationÝ =	`And`, relation
		|	`And`, relation, and_relation;

Ûand_then_relationÝ =	`And`, `Then`, relation
			|	`And`, `Then`, relation, and_then_relation;

Ûor_relationÝ =		`Or`, relation
		|	`Or`, relation, or_relation;

Ûor_else_relationÝ =	`Or`, `Else`, relation
		|	`Or`, `Else`, relation, or_else_relation;

Ûxor_relationÝ =	`Xor`, relation
		|	`Xor`, relation, xor_relation;
=TEX
SPARK manual 4.4:
=GFT Original Grammar
relation =		simple_expression, rel2;

rel2 =
		|	relational_operator, simple_expression
		|	`In`, range
		|	`Not`, `In`, range
		|	`In`, name
		|	`Not`, `In`, name;
=TEX
rel2 of \Source has been elided.

=DUMPMORE dtd503.grm.txt

ÛrelationÝ =		sr_expression
		|	sr_expression, relational_operator, sr_expression
		|	sr_expression, `In`, sr_expression
		|	sr_expression, `Not`, `In`, sr_expression;

Ûsr_expressionÝ =	simple_expression
		|	simple_expression, `DotDot`, simple_expression;
=TEX
=DUMPMORE dtd503.grm.txt
Ûsimple_expressionÝ =	term, binoptail
			|	unary_adding_operator, term, binoptail;

ÛbinoptailÝ =
		|	binary_adding_operator, term, binoptail;

ÛtermÝ =		factor, multoptail;

ÛmultoptailÝ =
		|	multiplying_operator, factor;

ÛfactorÝ =		primary
		|	primary, `StarStar`, primary
		|	`Abs`, primary
		|	`Not`, primary;
=TEX
=GFT Original Grammar
primary =		`NumericLiteral`
		|	`CharacterLiteral`
		|	`StringLiteral`
		|	name
		|	function_call
		|	type_conversion
		|	qualified_expression
		|	attribute (* Now done in name *)
		|	`Ord`, expression, `Crd`
 		|	`AbstractExpression`;
=TEX
=DUMPMORE dtd503.grm.txt
ÛprimaryÝ =		`NumericLiteral`
		|	`CharacterLiteral`
		|	`StringLiteral`
		|	name
		|	`Ord`, expression, `Crd`
		|	`AqTm`;
=TEX
SPARK manual 4.5:
=DUMPMORE dtd503.grm.txt
Ûrelational_operatorÝ =	`Equals`
			|	`NotEquals`
			|	`LessThan`
			|	`LessEquals`
			|	`GreaterThan`
			|	`GreaterEquals`;

Ûbinary_adding_operatorÝ =
			`Plus`
			|	`Minus`
			|	`Ampersand`;

Ûunary_adding_operatorÝ =	`Plus`
		|	`Minus`;

Ûmultiplying_operatorÝ =	`Star`
		|	`Div`
		|	`Mod`
		|	`Rem`;
=TEX
SPARK manual 4.6:
=GFT Original Grammar

type_conversion =	name, `Ord`, expression, `Crd`; *)
=TEX
SPARK manual 4.7:
=DUMPMORE dtd503.grm.txt
Ûqualified_expressionÝ =	name, `Prime`, aggregate;
=TEX
SPARK manual 5:
=DUMPMORE dtd503.grm.txt
Ûsequence_of_statementsÝ =
			statement, statement_list;

Ûstatement_listÝ =
		|	sequence_of_statements;

ÛstatementÝ =		`KSlot`
		|	`SpecificationStatement`
		|	`Con`, `ZDecl`, `FatDot`, `SpecificationStatement`
		|	simple_statement
		|	compound_statement;
=TEX
SPARK manual 5.1:
=DUMPMORE dtd503.grm.txt

Ûsimple_statementÝ =	null_statement
		|	assignment_statement
		|	procedure_call_statement
		|	exit_statement
		|	return_statement;

Ûcompound_statementÝ =	if_statement
			|	case_statement
			|	loop_statement;

Ûnull_statementÝ =	`Null`, `Semi`;

=TEX
SPARK manual 5.2:
=DUMPMORE dtd503.grm.txt
Ûassignment_statementÝ =	name, `Becomes`, expression, `Semi`;
=TEX
SPARK manual 5.3:
=DUMPMORE dtd503.grm.txt

Ûif_statementÝ = 		`If`, condition,
				`Then`, sequence_of_statements,
				elsif_part,
				else_part,
				`End`, `If`, `Semi`;

Ûelsif_partÝ =
		|		`ElsIf`, condition,
				`Then`, sequence_of_statements,
				elsif_part;

Ûelse_partÝ =
		|		`Else`, sequence_of_statements;

ÛconditionÝ = expression;
=TEX
SPARK manual 5.4:
=DUMPMORE dtd503.grm.txt

Ûcase_statementÝ =	`Case`, expression,
			`Is`,
				case_statement_alternative_list,
				others_part,
			`End`, `Case`, `Semi`;

Ûcase_statement_alternative_listÝ =
			case_statement_alternative
		|	case_statement_alternative, case_statement_alternative_list;

Ûcase_statement_alternativeÝ =
			`When`, case_choice_list, `GoesTo`, sequence_of_statements;

Ûcase_choice_listÝ =	case_choice
		|	case_choice, `Bar`, case_choice_list;

Ûcase_choiceÝ =		discrete_range;

Ûothers_partÝ =
		|	`WhenOthers`, `GoesTo`, sequence_of_statements;
=TEX
SPARK has no use for, and does not allow, the optional names.

SPARK manual 5.5:
=DUMPMORE dtd503.grm.txt

Ûloop_statementÝ =	name_opt1, iteration_scheme_opt,
			till_opt,
			`Loop`, sequence_of_statements,
			`End`, `Loop`, name_opt2, `Semi`;

Ûname_opt1Ý =
		|	`Identifier`, `Colon`;

Ûname_opt2Ý =
		|	`Identifier`;

Ûiteration_scheme_optÝ =
		|	iteration_scheme;

Ûiteration_schemeÝ =	`While`, condition
		|	`For`, loop_parameter_specification;
=TEX
SPARK manual 5.5:
=GFT Original Grammar
loop_parameter_specification =
			`Identifier`, `In`, name
		|	`Identifier`, `In`, `Reverse`, name
		|	`Identifier`, `In`, name, `RRange`, range
		|	`Identifier`, `In`, `Reverse`, name, `RRange`, range;
=TEX
=DUMPMORE dtd503.grm.txt
Ûloop_parameter_specificationÝ =
			`Identifier`, `In`, name
		|	`Identifier`, `In`, `Reverse`, name
		|	`Identifier`, `In`, name, `RRange`, sr_expression
		|	`Identifier`, `In`, `Reverse`, name, `RRange`, sr_expression;

Ûtill_optÝ =
		|	`Till`, `AqTm`;
=TEX
SPARK manual 5.7:
=DUMPMORE dtd503.grm.txt

Ûexit_statementÝ =	`Exit`, `Semi`
		|	`Exit`, `When`, condition, `Semi`;
=TEX
SPARK manual 5.8:
=DUMPMORE dtd503.grm.txt

Ûreturn_statementÝ =	`Return`, expression, `Semi`;
=TEX
SPARK's annotations have been dropped.

SPARK manual 6.1:
=DUMPMORE dtd503.grm.txt

Ûsubprogram_declarationÝ =
			procedure_specification, `Semi`
		|	function_specification, `Semi`;

Ûsubprogram_specificationÝ =
			procedure_specification
		|	function_specification;

Ûprocedure_specificationÝ =
			`Procedure`, `Identifier`
		|	`Procedure`, `Identifier`, `SpecificationStatement`
		|	`Procedure`, `Identifier`, formal_part
		|	`Procedure`, `Identifier`, formal_part, `SpecificationStatement`;

Ûfunction_specificationÝ =
			`Function`, designator, `Return`, name
		|	`Function`, designator, `Return`, name,
			`SpecificationStatement`
		|	`Function`, designator, formal_part, `Return`, name
		|	`Function`, designator, formal_part, `Return`, name,
			`SpecificationStatement`;

ÛdesignatorÝ =		`Identifier`;

Ûoperator_symbolÝ =	`StringLiteral`;

Ûformal_partÝ =		`Ord`, parlist, `Crd`;

ÛparlistÝ =		parameter_specification
		|	parameter_specification, `Semi`, parlist;

Ûparameter_specificationÝ =
			identifier_list, `Colon`, mode, name;

ÛmodeÝ =
		|	`In`
		|	`Out`
		|	`In`, `Out`;
=TEX
SPARK's annotations have been dropped
SPARK's code insertions have been dropped
SPARK's hidden parts have been dropped

SPARK manual 6.3:
=DUMPMORE dtd503.grm.txt

Ûsubprogram_bodyÝ =	procedure_specification, `Is`, subprogram_implementation
			|	function_specification, `Is`, subprogram_implementation;

Ûsubprogram_implementationÝ =
			declarative_part,
			`Begin`,
			sequence_of_statements,
			`End`, designator, `Semi`;
=TEX
SPARK manual 6.4:
=GFT Original Grammar
procedure_call_statement =
			procedure_name, `Semi`
		|	procedure_name, actual_parameter_part, `Semi`;
=TEX
=DUMPMORE dtd503.grm.txt
Ûprocedure_call_statementÝ =
			name, `Semi`;
=TEX
=GFT Original Grammar
function_call =		function_name
		|	function_name, actual_parameter_part;
=TEX
=DUMPMORE dtd503.grm.txt
Ûactual_parameter_partÝ =	`Ord`, parameter_association, `Crd`;
=TEX
=GFT Original Grammar
parameter_association =		named_parameter_association
			|	positional_parameter_association;
=TEX
=DUMPMORE dtd503.grm.txt
Ûparameter_associationÝ =	named_association
			|	positional_parameter_association;
=TEX
=DUMPMORE dtd503.grm.txt
Ûnamed_parameter_associationÝ =
			formal_parameter, `GoesTo`, actual_parameter
		|	formal_parameter, `GoesTo`, actual_parameter,
				`Comma`, named_parameter_association;

Ûpositional_parameter_associationÝ =
			actual_parameter
		|	actual_parameter, `Comma`, positional_parameter_association;
=TEX
=DUMPMORE dtd503.grm.txt
Ûformal_parameterÝ =	`Identifier`;

Ûactual_parameterÝ =	expression;
=TEX
SPARK manual 7.1:
=DUMPMORE dtd503.grm.txt
Ûpackage_declarationÝ =	package_specification, `Semi`;

Ûpackage_specificationÝ =
			`Package`, `Identifier`,
			`Is`,
				visible_part,
			`End`, `Identifier`
		|	`Package`, `Identifier`,
			`Is`,
				visible_part,
			`Private`,
				private_part,
			`End`, `Identifier`;

Ûvisible_partÝ =	visdec
		|	visdec, visible_part;

=TEX
The visdec/K-slot and pdec/K-slot productions in \Source is handled as if it were a statement.

SPARK manual 7.1:
=DUMPMORE dtd503.grm.txt
ÛvisdecÝ =		basic_declarative_item
		|	subprogram_declaration;

Ûprivate_partÝ =	pdec
		|	pdec, private_part;

ÛpdecÝ =	basic_declarative_item;

=TEX
=DUMPMORE dtd503.grm.txt
Ûpackage_bodyÝ =		`Package`, `BBody`, `Identifier`,
				`Is`,
					package_implementation,
				`End`, `Identifier`, `Semi`;

Ûpackage_implementationÝ =
			declarative_part
		|	declarative_part, `Begin`, package_initialization;

Ûpackage_initializationÝ =
			sequence_of_statements;
=TEX
SPARK manual 7.4:
=DUMPMORE dtd503.grm.txt

Ûprivate_type_declarationÝ =
			`Type`, `Identifier`, `Is`, `Private`, `Semi`
		|	`Type`, `Identifier`, `Is`, `Limited`, `Private`, `Semi`;

Ûdeferred_constant_declarationÝ =
			identifier_list, `Colon`, `Constant`, name, `Semi`;
=TEX
SPARK manual 8.5:
=DUMPMORE dtd503.grm.txt

Ûrenaming_declarationÝ =	`Function`, operator_symbol, formal_part,
				`Return`, name,
				`Renames`,
				`Identifier`, `Dot`, operator_symbol, `Semi`
			|	subprogram_specification,
				`Renames`,
				`Identifier`, `Dot`, `Identifier`, `Semi`;

=TEX
The compilation/K-slot production in \Source is handled as if it were a statement.

SPARK manual 10.1:
=DUMPMORE dtd503.grm.txt

ÛcompilationÝ =		compilation_unit
		|	compilation_unit, compilation;
=TEX
SPARK manual 10.1:
=DUMPMORE dtd503.grm.txt

Ûcompilation_unitÝ =	context_clause, library_unit
		|	context_clause, secondary_unit;

Ûlibrary_unitÝ =		package_declaration
		|	main_program;

Ûsecondary_unitÝ =	library_unit_body
		|	subunit;

Ûlibrary_unit_bodyÝ =	package_body;

Ûmain_programÝ =	subprogram_body;
=TEX
SPARK manual 10.1.1:
=DUMPMORE dtd503.grm.txt

Ûcontext_clauseÝ =
		|	with_clause;
=TEX
SPARK manual 10.1.1:
=GFT Original Grammar
with_clause =		`With`, simple_name_list, `Semi`;

simple_name_list =	simple_name
		|	simple_name, `Comma`, simple_name_list;
=TEX
=DUMPMORE dtd503.grm.txt
Ûwith_clauseÝ =		`With`, id_list, `Semi`;
=TEX
SPARK manual 10.2:
=DUMPMORE dtd503.grm.txt
Ûbody_stubÝ =		procedure_specification, `Is`, `Separate`, `Semi`
		|	function_specification, `Is`, `Separate`, `Semi`
		|	`Package`, `BBody`, `Identifier`, `Is`, `Separate`, `Semi`;

ÛsubunitÝ =		`Separate`, `Ord`, name, `Crd`, proper_body;
=TEX
SPARK manual 13.1:
=DUMPMORE dtd503.grm.txt

Ûrepresentation_clauseÝ =
			type_representation_clause, address_clause;

Ûtype_representation_clauseÝ =
			length_clause
		|	enumeration_representation_clause
		|	record_representation_clause;
=TEX
SPARK manual 13.2:
=GFT Original Grammar
length_clause =	`For`, attribute, `Use`, simple_expression, `Semi`;
=TEX
=DUMPMORE dtd503.grm.txt
Ûlength_clauseÝ =	`For`, attribute, `Use`, sr_expression, `Semi`;
=TEX
SPARK manual 13.3:
=DUMPMORE dtd503.grm.txt
Ûenumeration_representation_clauseÝ =
			`For`, `Identifier`, `Use`, aggregate, `Semi`;
=TEX
SPARK manual 13.4:
=DUMPMORE dtd503.grm.txt

Ûrecord_representation_clauseÝ =
			`For`, `Identifier`,
			`Use`,
			`Record`,
				alignment_opt, component_pack,
			`End`, `Record`, `Semi`;
=TEX
SPARK manual 13.4:
=GFT Original Grammar
alignment_opt =
		|	`At`, `Mod`, simple_expression, `Semi`;
=TEX
=DUMPMORE dtd503.grm.txt
Ûalignment_optÝ =
		|	`At`, `Mod`, sr_expression, `Semi`;
=TEX
=DUMPMORE dtd503.grm.txt
Ûcomponent_packÝ =	component_clause
		|	component_clause, component_pack;
=TEX
SPARK manual 13.4:
=GFT Original Grammar
component_clause =	name, `At`, simple_expression, `RRange`, range, `Semi`;
=TEX
=DUMPMORE dtd503.grm.txt
Ûcomponent_clauseÝ =	name, `At`, sr_expression, `RRange`, (* range*) sr_expression, `Semi`;
=TEX
SPARK manual 13.5:
=GFT Original Grammar
address_clause =	`For`, `Identifier`, `Use`, `At`, simple_expression, `Semi`;
=TEX
SPARK's code statements have been dropped.
=DUMPMORE dtd503.grm.txt
Ûaddress_clauseÝ =	`For`, `Identifier`, `Use`, `At`, sr_expression, `Semi`;
=TEX

\section{GENERATING THE TABLES}
=SH
(
poly `arch`slrp.db >dtd503.grm.run <<!
Slrp.slrp{
	in_file="dtd503.grm.txt",
	out_file="dtd503.grm.sml",
	logfile="dtd503.grm.log",
	eos="Eos",
	loglevel=2};
PolyML.quit();
!
)
=TEX
=TEX
\section{PARSER}
=TEX
\subsection{Context Free Parsing}
=DOC
val Ûcn_parserÝ : CNLex.LEX_ITEM list -> unit
=DESCRIBE
This is the context-free parser for Compliance Notation. It maps the lists of
tokens output by the CN lexical analyser onto datatypes representing
the CN abstract syntax.
=FAILURE
503000	Syntax error
503001	Syntax error in: ?0 <?> ?1
503003	?0 is not expected after ?1
503004	?0 is not a valid sequence or set type name
503011	Lexical analysis error: ?0 is not allowed here in Compliance Notation
503201	Parser internal error: ?0
=ENDDOC
=TEX
=SML
end; (* of signature CNParser *)
=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



