%  dtd502.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design of the SPARK Parser}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD502}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King&WIN01}
\TPPauthorisation{R.B.~Jones & HAT Manager}
\TPPabstract{
This document contains the detailed design for the
DAZ parser.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion~\FormatDate{$Date$%
}) ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
The phase 2 checks and transformations are yet to be documented.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the detailed design for the SPARK parser.

\subsection{Introduction}

\subsubsection{Purpose and Background}


\subsubsection{Dependencies}
%\subsubsection{Possible Enhancements}
\subsubsection{Deficiencies}
None known.

\section{DESIGN ISSUES}

\section{PREAMBLE}
=DOC
signature ÛSPARKParserÝ = sig
=DESCRIBE
This is the signature for the structure containing the parser for SPARK.
=ENDDOC

\section{GRAMMAR}

This grammar is based on that specified in \cite{DRA/CIS/CSE3/SWI/WP/9}.

Z paragraphs are supported by \Product\/  and a production branch in
the $web\_clause$ is not required.
=DUMP dtd502.grm.txt
Ûweb_clauseÝ =		compilation
		|	`CompLabel`, `ReplacedBy`, compilation
		|	`PPartLabel`, `ReplacedBy`, private_part
		|	`VPartLabel`, `ReplacedBy`, visible_part
		|	`DecLabel`, `ReplacedBy`, dec, dp1
		|	`StmtLabel`, `ReplacedBy`, sequence_of_statements
		|	`SpecLabel`, `RefinedBy`, sequence_of_statements
		|	`RefinedBy`, sequence_of_statements
		|	`SpecLabel`, `ReplacedBy`, sequence_of_statements
		|	`ReplacedBy`, sequence_of_statements;
=TEX
=DUMPMORE dtd502.grm.txt

Ûbasic_declarationÝ =	object_declaration
		|	type_declaration
		|	subtype_declaration
		|	deferred_constant_declaration;

Ûobject_declarationÝ =	constant_declaration
		|	variable_declaration;

Ûconstant_declarationÝ =	identifier_list, `Colon`, `Constant`, `TypeMark`, `Becomes`, expression, `Semi`;
	
Ûvariable_declarationÝ =	identifier_list, `Colon`, `TypeMark`, `Semi`;

Ûidentifier_listÝ =	`Identifier`, id_list;

Ûid_listÝ	=
		|	`Comma`, identifier_list;
=TEX
=DUMPMORE dtd502.grm.txt
Ûtype_declarationÝ =	full_type_declaration
		|	private_type_declaration;

Ûfull_type_declarationÝ =	`Type`, `Identifier`, `Is`, type_definition, `Semi`;

Ûtype_definitionÝ =	enumeration_type_definition
		|	integer_type_definition
		|	real_type_definition
		|	array_type_definition
		|	record_type_definition;

Ûsubtype_declarationÝ =	`SubType`, `Identifier`, `Is`, subtype_indication, `Semi`;

Ûsubtype_indicationÝ =	`TypeMark`, constraint;

ÛconstraintÝ	=	range_constraint
		|	floating_point_constraint
		|	fixed_point_constraint
		|	index_constraint;

Ûrange_constraintÝ =	`RRange`, range;

ÛrangeÝ =			simple_expression
		|	simple_expression, `DotDot`, simple_expression;


Ûenumeration_type_definitionÝ =
			`Ord`, identifier_list, `Crd`;

Ûinteger_type_definitionÝ =
			range_constraint;

Ûreal_type_definitionÝ =	floating_point_constraint
		|	fixed_point_constraint;

Ûfloating_point_constraintÝ =
			floating_accuracy_definition
		|	floating_accuracy_definition, range_constraint;

Ûfloating_accuracy_definitionÝ =
			`Digits`, simple_expression;

Ûfixed_point_constraintÝ =
			fixed_accuracy_definition
		|	fixed_accuracy_definition, range_constraint;

Ûfixed_accuracy_definitionÝ =
			`Delta`, simple_expression;

Ûarray_type_definitionÝ =	unconstrained_array_definition
		|	constrained_array_definition;

Ûunconstrained_array_definitionÝ =
			`Array`, `Ord`, index_subtype_definition_list, `Crd`, `Of`, `TypeMark`;

Ûconstrained_array_definitionÝ =
			`Array`, index_constraint, `Of`, `TypeMark`;

Ûindex_subtype_definition_listÝ =
			index_subtype_definition, subtype_list;

Ûsubtype_listÝ =
		|	`Comma`, index_subtype_definition_list;

Ûindex_subtype_definitionÝ =
			`TypeMark`, `RRange`, `LessGreat`;

Ûindex_constraintÝ =	`Ord`, type_mark_list, `Crd`;

Ûtype_mark_listÝ =	`TypeMark`, type_list;

Ûtype_listÝ =
		|	`Comma`, type_mark_list;

Ûdiscrete_rangeÝ =	`TypeMark`
		|	`TypeMark`, range_constraint
		|	range;

Ûrecord_type_definitionÝ =
			`Record`, component_list, `End`, `Record`;
=TEX
=DUMPMORE dtd502.grm.txt

Ûcomponent_listÝ =	component_declaration, comp_list;

Ûcomp_listÝ =
		|	`Comma`, component_list;

Ûcomponent_declarationÝ =	identifier_list, `Colon`, `TypeMark`, `Semi`;

Ûdeclarative_partÝ =	dec, dp1;

Ûdp1Ý =
		|	dec, dp1;

ÛdecÝ =			`KSlot`
		|	renaming_declaration
		|	basic_declarative_item
		|	package_declaration
		|	body;

Ûbasic_declarative_itemÝ =
			basic_declaration
		|	representation_clause;

ÛbodyÝ =		proper_body
		|	body_stub;

Ûproper_bodyÝ =		subprogram_body
		|	package_body;
=TEX
replaced the following...
=GFT Original Grammar
ÛnameÝ =		simple_name, select;

ÛselectÝ =
		|	`Dot`, simple_name, select
		|	`Ord`, exp_list, `Crd`, select;
=TEX
with
=DUMPMORE dtd502.grm.txt
ÛnameÝ =		simple_name
		|	indexed_component
		|	selected_component;

Ûindexed_componentÝ =	prefix, `Ord`, expression_list, `Crd`; 

Ûselected_componentÝ =	prefix, `Dot`, selector;

ÛselectorÝ =		simple_name;

=TEX

=DUMPMORE dtd502.grm.txt
Ûsimple_nameÝ =		`Identifier`;

ÛprefixÝ =		name
		|	function_call;

Ûexpression_listÝ =	expression, exp_list;

Ûexp_listÝ =
		|	`Comma`, expression_list;

ÛattributeÝ =		prefix, `Prime`, attribute_designator
		|	`CharacterLiteral`, `Prime`, attribute_designator;

Ûattribute_designatorÝ =
			namexp, namexp_list;

Ûnamexp_listÝ =
		|	`Prime`, attribute_designator;

ÛnamexpÝ =		simple_name
		|	simple_name, `Ord`, expression, `Crd`;

ÛaggregateÝ =		`Ord`, component_association, `Crd`
		|	`Ord`, component_association, `CommaOthers`, `GoesTo`, expression, `Crd`
		|	`Ord`, `Others`, `GoesTo`, expression, `Crd`;

Ûcomponent_associationÝ =	`Na`, named_association
		|	positional_association;

Ûnamed_associationÝ =	aggregate_choice_list, `GoesTo`, expression, ass_list;

Ûass_listÝ =
		|	`Comma`, named_association;

Ûaggregate_choice_listÝ =
			aggregate_choice, ag_list;

Ûag_listÝ =
		|	`Bar`, aggregate_choice_list;

Ûaggregate_choiceÝ =	discrete_range;

Ûpositional_associationÝ =
			expression_list;
=TEX
=DUMPMORE dtd502.grm.txt

ÛexpressionÝ =		relation, reltail;

ÛreltailÝ =
		|	and_relation
		|	and_then_relation
		|	or_relation
		|	or_else_relation
		|	xor_relation;

Ûand_relationÝ =	`And`, relation
		|	`And`, relation, and_relation;

Ûand_then_relationÝ =	`And`, `Then`, relation
		|	`And`, `Then`, relation, and_then_relation;

Ûor_relationÝ =		`Or`, relation
		|	`Or`, relation, or_relation;

Ûor_else_relationÝ =	`Or`, `Else`, relation
		|	`Or`, `Else`, relation, or_else_relation;

Ûxor_relationÝ =	`Xor`, relation
		|	`Xor`, relation, xor_relation;

ÛrelationÝ =		simple_expression, rel2;

Ûrel2Ý =
		|	relational_operator, simple_expression
		|	`In`, range
		|	`Not`, `In`, range
		|	`In`, `TypeMark`
		|	`Not`, `In`, `TypeMark`;

Ûsimple_expressionÝ =	term, binoptail
		|	unary_adding_operator, term, binoptail;

ÛbinoptailÝ =
		|	binary_adding_operator, term, binoptail;

ÛtermÝ =		factor, multoptail;

ÛmultoptailÝ =
		|	multiplying_operator, factor;

ÛfactorÝ =		primary
		|	primary, `StarStar`, primary
		|	`Abs`, primary
		|	`Not`, primary;

ÛprimaryÝ =		`NumericLiteral`
		|	`CharacterLiteral`
		|	`StringLiteral`
		|	name
		|	function_call
		|	type_conversion
		|	qualified_expression
		|	attribute
		|	`Ord`, expression, `Crd`
		|	`AbstractExpression`;

Ûrelational_operatorÝ =	`Equals`
		|	`NotEquals`
		|	`LessThan`
		|	`LessEquals`
		|	`GreaterThan`
		|	`GreaterEquals`;

Ûbinary_adding_operatorÝ =
			`Plus`
		|	`Minus`
		|	`Ampersand`;

Ûunary_adding_operatorÝ =	`Plus`
		|	`Minus`;

Ûmultiplying_operatorÝ =	`Star`
		|	`Div`
		|	`Mod`
		|	`Rem`;

Ûtype_conversionÝ =	`TypeMark`, `Ord`, expression, `Crd`;

Ûqualified_expressionÝ =	`TypeMark`, `Prime`, aggregate;

=TEX
=DUMPMORE dtd502.grm.txt
Ûsequence_of_statementsÝ =
			statement, statement_list;

Ûstatement_listÝ =
		|	sequence_of_statements;

ÛstatementÝ =		`KSlot`
		|	`SpecificationStatement`
		|	`Con`, `ZDecl`, `FatDot`, `SpecificationStatement`
		|	simple_statement
		|	compound_statement;

Ûsimple_statementÝ =	null_statement
		|	assignment_statement
		|	procedure_call_statement
		|	exit_statement
		|	return_statement;

Ûcompound_statementÝ =	if_statement
		|	case_statement
		|	loop_statement;

Ûnull_statementÝ =	`Null`, `Semi`;

=TEX
=DUMPMORE dtd502.grm.txt
Ûassignment_statementÝ =	name, `Becomes`, expression, `Semi`;

Ûif_statementÝ = 		`If`, condition, `Then`, sequence_of_statements, elsif_part, else_part, `End`, `If`, `Semi`;

Ûelsif_partÝ =
		|	`ElsIf`, condition, `Then`, sequence_of_statements, elsif_part;

Ûelse_partÝ =
		|	`Else`, sequence_of_statements;

ÛconditionÝ = expression;

Ûcase_statementÝ =	`Case`, expression, `Is`, case_statement_alternative_list, others_part, `End`, `Case`, `Semi`;

Ûcase_statement_alternative_listÝ =
			case_statement_alternative
		|	case_statement_alternative, case_statement_alternative_list;

Ûcase_statement_alternativeÝ =
			`When`, case_choice_list, `GoesTo`, sequence_of_statements;

Ûcase_choice_listÝ =	case_choice
		|	case_choice, `Bar`, case_choice_list;

Ûcase_choiceÝ =		discrete_range;

Ûothers_partÝ =
		|	`WhenOthers`, `GoesTo`, sequence_of_statements;

Ûloop_statementÝ =	name_opt1, iteration_scheme_opt, until_opt, `Loop`, sequence_of_statements, `End`, `Loop`, name_opt2, `Semi`;

Ûname_opt1Ý =
		|	simple_name, `Colon`;

Ûname_opt2Ý =
		|	simple_name;

Ûiteration_scheme_optÝ =
		|	iteration_scheme;

Ûiteration_schemeÝ =	`While`, condition
		|	`For`, loop_parameter_specification;


Ûloop_parameter_specificationÝ =
			`Identifier`, `In`, `TypeMark`
		|	`Identifier`, `In`, `Reverse`, `TypeMark`
		|	`Identifier`, `In`, `TypeMark`, `RRange`, range
		|	`Identifier`, `In`, `Reverse`, `TypeMark`, `RRange`, range;

Ûuntil_optÝ =
		|	`Until`, `AqTm`;

Ûexit_statementÝ =	`Exit`, `Semi`
		|	`Exit`, `When`, condition, `Semi`;

Ûreturn_statementÝ =	`Return`, expression, `Semi`;
=TEX
=DUMPMORE dtd502.grm.txt

Ûsubprogram_declarationÝ =
			procedure_specification, `Semi`
		|	function_specification, `Semi`;

Ûsubprogram_specificationÝ =
			procedure_specification
		|	function_specification;

Ûprocedure_specificationÝ =
			`Procedure`, `Identifier`
		|	`Procedure`, `Identifier`, `SpecificationStatement`
		|	`Procedure`, `Identifier`, formal_part
		|	`Procedure`, `Identifier`, formal_part, `SpecificationStatement`;

Ûfunction_specificationÝ =
			`Function`, designator, `Return`, `TypeMark`
		|	`Function`, designator, `Return`, `TypeMark`, `SpecificationStatement`
		|	`Function`, designator, formal_part, `Return`, `TypeMark`
		|	`Function`, designator, formal_part, `Return`, `TypeMark`, `SpecificationStatement`;

ÛdesignatorÝ =		`Identifier`;

Ûoperator_symbolÝ =	`StringLiteral`;

Ûformal_partÝ =		`Ord`, parlist, `Crd`;

ÛparlistÝ =		parameter_specification
		|	parameter_specification, `Semi`, parlist;

Ûparameter_specificationÝ =
			identifier_list, `Colon`, mode, `TypeMark`;

ÛmodeÝ =
		|	`In`
		|	`Out`
		|	`In`, `Out`;

Ûsubprogram_bodyÝ =	procedure_specification, `Is`, subprogram_implementation
		|	function_specification, `Is`, subprogram_implementation;

Ûsubprogram_implementationÝ =
			declarative_part, `Begin`, sequence_of_statements, `End`, designator, `Semi`;
=TEX
=DUMPMORE dtd502.grm.txt

Ûprocedure_call_statementÝ =
			`ProcedureName`, `Semi`
		|	`ProcedureName`, actual_parameter_part, `Semi`;

Ûfunction_callÝ =		`FunctionName`
		|	`FunctionName`, actual_parameter_part;

Ûactual_parameter_partÝ =	`Ord`, parameter_association, `Crd`;

Ûparameter_associationÝ =	named_parameter_association
		|	positional_parameter_association;

Ûnamed_parameter_associationÝ =
			formal_parameter, `GoesTo`, actual_parameter
		|	formal_parameter, `GoesTo`, actual_parameter, `Comma`, named_parameter_association;

Ûpositional_parameter_associationÝ =
			actual_parameter
		|	actual_parameter, `Comma`, positional_parameter_association;
=TEX
$formal\_parameter$ changed from $simple\_name$ to $name$.
=DUMPMORE dtd502.grm.txt

Ûformal_parameterÝ =	simple_name;

Ûactual_parameterÝ =	expression;

Ûpackage_declarationÝ =	package_specification, `Semi`;

Ûpackage_specificationÝ =
			`Package`, `Identifier`, `Is`, visible_part, `End`, simple_name
		|	`Package`, `Identifier`, `Is`, visible_part, `Private`, private_part, `End`, simple_name;

Ûvisible_partÝ =	visdec
		|	visdec, visible_part;

ÛvisdecÝ =		`KSlot`
		|	basic_declarative_item
		|	subprogram_declaration;

Ûprivate_partÝ =	pdec
		|	pdec, private_part;

ÛpdecÝ =		`KSlot`
		|	basic_declarative_item;

=TEX
=DUMPMORE dtd502.grm.txt
Ûpackage_bodyÝ =		`Package`, `BBody`, simple_name, `Is`, package_implementation, `End`, simple_name, `Semi`;

Ûpackage_implementationÝ =
			declarative_part
		|	declarative_part, `Begin`, package_initialization;

Ûpackage_initializationÝ =
			sequence_of_statements;

Ûprivate_type_declarationÝ =
			`Type`, `Identifier`, `Is`, `Private`, `Semi`
		|	`Type`, `Identifier`, `Is`, `Limited`, `Private`, `Semi`;

Ûdeferred_constant_declarationÝ =
			identifier_list, `Colon`, `Constant`, `TypeMark`, `Semi`;

Ûrenaming_declarationÝ =	`Function`, operator_symbol, formal_part, `Return`, `TypeMark`, `Renames`, simple_name, `Dot`, operator_symbol, `Semi`
		|	subprogram_specification, `Renames`, simple_name, `Dot`, simple_name, `Semi`;

=TEX
=DUMPMORE dtd502.grm.txt
ÛcompilationÝ =		`KSlot`
		|	compilation_unit
		|	compilation_unit, compilation;

Ûcompilation_unitÝ =	context_clause, library_unit
		|	context_clause, secondary_unit;

Ûlibrary_unitÝ =		package_declaration
		|	main_program;

Ûsecondary_unitÝ =	library_unit_body
		|	subunit;

Ûlibrary_unit_bodyÝ =	package_body;

Ûmain_programÝ =	subprogram_body;

Ûcontext_clauseÝ =
		|	with_clause;

Ûwith_clauseÝ =		`With`, simple_name_list, `Semi`;

Ûsimple_name_listÝ =	simple_name
		|	simple_name, `Comma`, simple_name_list;

Ûbody_stubÝ =		procedure_specification, `Is`, `Separate`, `Semi`
		|	function_specification, `Is`, `Separate`, `Semi`
		|	`Package`, `BBody`, simple_name, `Is`, `Separate`, `Semi`;

ÛsubunitÝ =		`Separate`, `Ord`, name, `Crd`, proper_body;

Ûrepresentation_clauseÝ =
			type_representation_clause, address_clause;

Ûtype_representation_clauseÝ =
			length_clause
		|	enumeration_representation_clause
		|	record_representation_clause;

Ûlength_clauseÝ =	`For`, attribute, `Use`, simple_expression, `Semi`;

Ûenumeration_representation_clauseÝ =
			`For`, simple_name, `Use`, aggregate, `Semi`;

Ûrecord_representation_clauseÝ =
			`For`, simple_name, `Use`, `Record`, alignment_opt, component_pack, `End`, `Record`, `Semi`;

Ûalignment_optÝ =
		|	`At`, `Mod`, simple_expression, `Semi`;

Ûcomponent_packÝ =	component_clause
		|	component_clause, component_pack;

Ûcomponent_clauseÝ =	name, `At`, simple_expression, `RRange`, range, `Semi`;

Ûaddress_clauseÝ =	`For`, simple_name, `Use`, `At`, simple_expression, `Semi`;

=TEX

\section{GENERATING THE TABLES}
=SH
(
poly /usr/tmp/`arch`slrp.db >dtd502.grm.run <<!
Slrp.slrp{
	in_file="dtd502.grm.txt",
	out_file="dtd502.grm.sml",
	logfile="dtd502.grm.log",
	eos="Eos",
	loglevel=2};
PolyML.quit();
!
)
=TEX
\section{ABSTRACT SYNTAX}
=DOC
=DESCRIBE
These types are used in representing the abstract syntax of SPARK.
=ENDDOC
=TEX
\section{INTERFACE}
=TEX
\subsection{Context Free Parsing}
=DOC
type ÛLEX_ITEMÝ
val ÛSPARK_parserÝ : LEX_ITEM list -> unit
=DESCRIBE
This is the context-free parser for SPARK. It maps the lists of
tokens output by the SPARK lexical analyser onto datatypes representing
the SPARK abstract syntax.
=FAILURE
502000	Syntax error
502001	Syntax error in: ?0 <?> ?1
502003	?0 is not expected after ?1
502004	?0 is not a valid sequence or set type name
502011	Lexical analysis error: ?0 is not allowed here in SPARK
502201	Parser internal error: ?0
=ENDDOC
=TEX
=SML
end; (* of signature SPARKParser *)
=TEX
\subsection{Case Independence}
=DOC
signature ÛCaseIndependenceÝ = sig
=DESCRIBE
This is the signature of a structure containing utilities to assist
in implementing support for languages where equality of identifiers
is independent of the case of letters.
=ENDDOC
=DOC
val Ûto_lowerÝ : string -> string
val Ûto_upperÝ : string -> string
=DESCRIBE
$to\_lower\,s$ is $s$ with all upper-case letters replaced by their
lower-case equivalents.

$to\_upper\,s$ is $s$ with all lower-case letters replaced by their
upper-case equivalents.
=ENDDOC
=DOC
val Ûci_get_const_namesÝ : string -> string list
=DESCRIBE
Given a string $s$, $ci\_get\_const\_names$ returns the list of
the names of all constants $c$ such that, (i) $c$ is in scope in the
current theory, (ii) the name of $c$ is the same as $s$ when one ignores
the case of any letters in the name.
=FAILURE
502100	Internal error in ci_get_const_names
=ENDDOC
=SML
end; (* of signature CaseIndependence *)
=TEX
\section{TEST POLICY}
The functions in this document are to be tested according to the
criteria identified in \cite{ISS/HAT/DAZ/PLN003}.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



