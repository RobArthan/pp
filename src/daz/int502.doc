% %Z% $Date$ $Revision$ $RCSfile$
=TEX

% TQtemplate.tex
% use_file "daz_init";
% use_file "int502";
% z_print_theory"-";
% open CNZGenerator;
% print_spark_program();
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Bugfix Tests}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/INT502}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & HAT Team}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & WIN01}
\TPPabstract{%
This document contains tests for fixes to bugs in the Compliance Tool.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issues 1.1-$Revision$%
] Initial Drafts.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains test data for the Compliance Tool as specified in \cite{ISS/HAT/DAZ/HLD502} and \cite{ISS/HAT/DAZ/USR502}.
\subsection{Introduction}
This document contains specific tests to check fixes to bugs in the Compliance Tool.
\section{PRELIMINARIES}

\section{BATCH 1 - 30/3/95}
See file {\tt drabugs300395.doc} in the project SCCS directory.

=SML
use_file "dtd013";
use_file "imp013";
=TEX
Functions for recording some statistics of theories.

=SML
type theory_stats = {np : int, ng : int, na : int, nd : int, nc : int};
local
    fun noof_parents thy = (length o get_parents) thy;
    fun noof_global thy = (length o get_consts) thy;
    fun noof_axioms thy = (length o get_axioms) thy;
    fun noof_defns thy = (length o get_defns) thy;
    fun noof_conjectures thy = (length o get_conjectures) thy;
in
    fun get_theory_stats (thy : string) : theory_stats =
    let
        val np = noof_parents thy;
        val ng = noof_global thy;
        val na = noof_axioms thy;
        val nd = noof_defns thy;
        val nc = noof_conjectures thy;
    in
        {np = np, ng = ng, na = na, nd = nd, nc = nc}
    end;
end;
=TEX
The following function is a convenience in cases where we just want to
test that something fails without working out exactly what the
error message is:
=SML
fun check_fail (f: unit -> unit) : bool = (
		(f (); false)
	handle Fail msg => (
		diag_line (get_message_text msg);
		true
	)
);
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1}
Documentary --- no test.
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2}
Tested in \cite{ISS/HAT/DAZ/INT504}
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 3}
This bug is essentially cosmetic.
The following script exhibits the two sorts of required behaviour, but
it can only be checked by examnining the log.
=SML
new_script{name = "bug.1.3", state = initial_cn_state};
¹CN
procedure P is
	procedure proc_without_spec is separate;
	procedure proc_with_spec „ [true] is separate;
	function func_without_spec (x: integer) return integer is separate;
	function func_with_spec (x: integer) return integer „ [true] is separate;
begin
    null;
end P;
°
=SML
CNSparkOutput.print_spark_program();
CNSparkOutput.print_web_clause (!CNZGenerator.diag_web_clause);
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 4}
Concerns wording of two error messages:
=SML
get_error_message 505060 ["X"];
get_error_message 505064 ["A, B, C", "X"];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 5}
The following should not give a syntax error:
=SML
new_script{name = "bug.1.5", state = initial_cn_state};
fun bug_1_5 () = 
¹CN
procedure P is
   § Declarations ¢          (1)
begin
   § Initialisation ¢        (2)
   loop
      § Body ¢          (3)
   end loop;
end P;
°
=SML
store_mt_results_show mt_run [
    ("bug.1.5", bug_1_5, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 6}
=SML
new_script{name = "bug.1.6", state = initial_cn_state};
¹CN
procedure P is
    A : INTEGER;
    subtype S is INTEGER range 3 .. 10;
    procedure Q
        „ A [ A = S_APOST_FIRST ]
    is
        S_APOST_FIRST : INTEGER;
    begin
        S_APOST_FIRST := A;
    end Q;
begin
    „ A[A = 5]
end P;
°
The following should flag an error because it produces a VC with a free variable.
=SML
fun bug_1_6 () =
¹CN
  Ã 
    A := 10;
    Q;
    A := A + 2;
°
=SML
store_mt_results_show mt_run [
    ("bug.1.6", check_fail, bug_1_6, true)
];
=TEX
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 7}
The following will need correcting if someone changes the ProofPower-Z misfeature
whereby use of the schema $T$ below as a predicate does not bind
the global variable $O$.
(In which event, the example should just work).
=SML
new_script{name = "bug.1.7", state = initial_cn_state};
¹CN
procedure P is
    § Declarations ¢ (1)
begin
    § Initialisation ¢ (2)
    § Loop ¢ (3)
end P;
°
¹CN
(1) é 
 type S is range 0 .. 7;
 I : constant S := 0;
 O : constant S := 4;
 STATE : S;
°
ÿ T üüüüüüüüüüü
Ü STATE : S;
Ü O : ú
÷üüüüüü
Ü STATE = I
ˆüüüüüüüüüüüüü

¹CN
(2) é „ STATE [T]      (4)
°
=SML
fun bug_1_7_1 () =
¹CN
(4) Ã STATE := I;
°
The following should flag an error because it produces a VC with a free variable.
=SML
store_mt_results_show mt_run [
    ("bug.1.7.1", check_fail, bug_1_7_1, true)
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 8}
Tested in \cite{ISS/HAT/DAZ/INT503}
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 9}
=SML
new_script{name = "bug.1.9", state = initial_cn_state};
¹CN
procedure P is
    X : INTEGER;
    procedure Q (Y : in out INTEGER)
    „ Y [ Y = Y‰0 + 2 ]
    is
    begin
        Y := Y + 2;
    end Q;
begin
     „ X [X = X‰0 + 6] (1)
end P;
°
¹CN
 (1) Ã
        Q(X);
        X := X + 4;
°
The following gives some evidence that the Xs have been substituted for the Ys.
=SML
fun ok_1_9 () = (
	let 	val vs = (map fst o term_vars o get_conjecture "bug.1.9") "vc1_2";
	in	not ("Y‰0" mem vs orelse "Y" mem vs)
	end
);
=SML
store_mt_results_show mt_run [
    ("bug.1.9", ok_1_9, (), true)
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 10}
Not fixed.
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 11}
=SML
new_script{name = "bug11", state = initial_cn_state};
¹CN
procedure Q is
    type D is (THU, FRI, SAT);
    type A1 is array (D) of D;
    type A2 is array (D) of A1;
    A : A2;
begin
    „ A [A(THU)(SAT) = FRI]        (9)
end Q;
°
Following should not crash:
=SML
fun bug_1_11 () = 
¹CN
(9) Ã A(THU)(SAT) := FRI;
°
=SML
store_mt_results_show mt_run [
    ("bug.1.11", bug_1_11, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 12}
=SML
new_script{name = "bug12", state = initial_cn_state};

¹CN
package PACK is
     type REC is
     record
        X : INTEGER;
        Y : INTEGER;
     end record;
end PACK;
°
=SML
fun bug_1_12 () =
¹CN
with PACK;
procedure P is
begin
   null;
end P;
°
=SML
store_mt_results_show mt_run [
    ("bug.1.12", bug_1_12, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 13}
=SML
new_script{name = "bug.1.13", state = initial_cn_state};

¹CN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI);
   D : DAY;
begin
   for I in DAY
   loop
      „ D [D = I]            (1)
   end loop;
end P;
°
¹CN
(1) Ã D := I;
°
The following gives some evidence that the VC is as required.
=SML
fun ok_1_13 () = (
	let 	val vs = (map fst o term_consts o get_conjecture "bug.1.13") "vc1_1";
	in	"z'DAY" mem vs andalso not ("z'INTEGER" mem vs)
	end
);
=SML
store_mt_results_show mt_run [
    ("bug.1.13", ok_1_13, (), true)
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 14}
Bug in xpp, not the Compliance Tool (check by inspection of templates help).
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 15}
Documentary.
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 16}
=SML
new_script{name = "bug.1.16", state = initial_cn_state};
¹Z
Ü [A]
°
Printing Z document should not crash:
=SML
store_mt_results_show mt_run [
    ("bug.1.16.1", output_z_document,
		{script="bug.1.16", out_file="int502.1.16.zed"}, ())
];
=TEX
Reloading Z document should give similar theory:
=SML
val bug_1_16_stats = get_theory_stats "bug.1.16";
force_delete_theory"bug.1.16";
use_file"int502.1.16.zed";
store_mt_results_show mt_run [
    ("bug.1.16.2", get_theory_stats ,"bug.1.16", bug_1_16_stats)
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 17}
The following test is a bit more demanding than the failure case supplied by DRA.
=SML
new_script{name = "bug.1.17", state = initial_cn_state};
ÿ S üüüüüüüüüüü
Ü a : î
ˆüüüüüüüüüüüüüü

ÿ T üüüüüüüüüüü
Ü S
ˆüüüüüüüüüüüüüü

ÿ V üüüüüüüüüüü
Ü S!
ˆüüüüüüüüüüüüüü
¹Z
[A]
°
ÿ W[X, Y] üüüüüüüüüüü
Ü x, x':X;
Ü y, y' : Y;
Ü S
÷üüüüüüüüüü
Ü #{x, x'} ¼ a ± #{y, y'} ¾ a
ˆüüüüüüüüüüüüüü
[ X ]œœœœœœœœœœœ
Ü x, y : X
÷üüüüüü
Ü (¶a, b: X · a ½ b) ´ x ½ y
ˆüüüüüüüüüüüüüü
ÿ WW[X, Y] üüüüüüüüüüü
Ü x, x?:X;
Ü y, y? : Y;
Ü S!
÷üüüüüüüüüü
Ü #{x, x?} ¼ a! ± #{y, y?} ¾ a!
ˆüüüüüüüüüüüüüü
ÿ QQ[X, Y] üüüüüüüüüüü
Ü ab : X ; bc : Y
ˆüüüüüüüüüüüüüü
[ X , Y]œœœœœœœœœœœ
Ü QQ[X, Y]
ˆüüüüüüüüüüüüüü
¹ZAX
Ü S
°
ÿ RR[X, Y] üüüüüüüüüüü
Ü abc : X ; bcd : Y
ˆüüüüüüüüüüüüüü
¹Z
Ü Tree ::= AA (î) | BB (Tree ¸ Tree)
°
Printing Z document should not crash:
=SML
store_mt_results_show mt_run [
    ("bug.1.17.1", output_z_document,
		{script="bug.1.17", out_file="int502.1.17.zed"}, ())
];
=TEX
Reloading Z document should give similar theory:
=SML
val bug_1_17_stats = get_theory_stats "bug.1.17";
force_delete_theory"bug.1.17";
use_file"int502.1.17.zed";
store_mt_results_show mt_run [
    ("bug.1.17.2", get_theory_stats ,"bug.1.17", bug_1_17_stats)
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 18}
=SML
new_script{name = "bug.1.18", state = initial_cn_state};
[X]œœœœœœœœœœœ
Ü x : X
ˆüüüüüüüüüüüüüü
Printing Z document should not crash:
=SML
store_mt_results_show mt_run [
    ("bug.1.18.1", output_z_document,
		{script="bug.1.18", out_file="int502.1.18.zed"}, ())
];
=TEX
Reloading Z document should give similar theory:
=SML
val bug_1_18_stats = get_theory_stats "bug.1.18";
force_delete_theory"bug.1.18";
use_file"int502.1.18.zed";
store_mt_results_show mt_run [
    ("bug.1.18.2", get_theory_stats ,"bug.1.18", bug_1_18_stats)
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 19}
=SML
new_script{name = "bug.1.19", state = initial_cn_state};

¹CN
package PACK is
   type INT_TYPE is range 5 .. 90;
   X : INT_TYPE;
end PACK;
° 
The following should not crash:
=SML
fun bug_1_19 () = 
¹CN
with PACK;
procedure MAIN
„ PACKoX [PACKoX = 45]
is   
begin
   PACK.X := 45;
end MAIN;
°
=SML
store_mt_results_show mt_run [
    ("bug.1.19", bug_1_19, (), ())
];
=TEX
\section{BATCH 2 - 13/9/95}
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1}
=SML
force_delete_theory"bug.2.1" handle Fail _ => ();
new_script{name = "bug.2.1", state = initial_cn_state};
=TEX
The following should not crash:
=SML
fun bug_2_1 () = 
¹CN
procedure P is
    function F (X : INTEGER; Y : INTEGER; Z : INTEGER) return INTEGER is
    begin
        return 5;
    end F;
begin
    null;
end P;
° 

¹CN
procedure Q is
    type rec is record XYZ : INTEGER; ABC : INTEGER; end record;
begin
    null;
end Q;
° 

=SML
PolyML.exception_trace bug_2_1;
store_mt_results_show mt_run [
    ("bug.2.1", bug_2_1, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2}
=SML
force_delete_theory"bug.2.2" handle Fail _ => ();
new_script{name = "bug.2.2", state = initial_cn_state};
=TEX	
¹CN
procedure P is
    function F (X, Y : INTEGER) return INTEGER
    -- „ [F(X, Y) = 5]
 is
    begin
        return 5;
    end F;
begin
    null;
end P;
° 
=SML
store_mt_results_show mt_run [
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 3}
=SML
force_delete_theory"bug.2.3" handle Fail _ => ();
new_script{name = "bug.2.3", state = initial_cn_state};
=TEX	
¹CN
package PACK1 is
    C: constant INTEGER := 20;
    procedure P (Y : out INTEGER)
    „ Y [Y = C];
end PACK1;
° 
¹CN
with PACK1;
procedure MAIN is
    X : INTEGER;
begin
    „ X [ X = 20]
end MAIN;
° 
fun bug_2_3 () =
¹CN
  Ã PACK1.P(X);
°
=SML
bug_2_3();
store_mt_results_show mt_run [
    ("bug.2.3", bug_2_3, (), ())
];
=IGN
The following works fine!
¹CN
package body PACK1 is
    procedure P (Y : out INTEGER)
    „ Y [Y = C]
    is
    begin
        Y := 20;
    end P;
end PACK1;
° 
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 5}
=SML
force_delete_theory"bug.2.5" handle Fail _ => ();
new_script{name = "bug.2.5", state = initial_cn_state};
=TEX	
¹CN
procedure P is
     type UNCON is array (INTEGER range <>) of INTEGER;
     subtype SUB is INTEGER range 1 .. 10;
     subtype ARR is UNCON (SUB);
begin
     null;
end P;
° 
=SML
CNSparkOutput.print_spark_program();
=SML
store_mt_results_show mt_run [
    ("bug.2.5", bug_2_5, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 6}
=SML
force_delete_theory"bug.2.6" handle Fail _ => ();
new_script{name = "bug.2.6", state = initial_cn_state};
=TEX	
fun bug_2_6 () =
¹CN
procedure P is
    type REC is
    record
        X : INTEGER;
        Y : INTEGER;
    end record;
    C : constant REC := REC'(67, 89);
    D : constant INTEGER := C.X + 9;
begin
    null;
end P;
° 
=SML
bug_2_6();
store_mt_results_show mt_run [
    ("bug.2.6", bug_2_6, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 7}
=SML
force_delete_theory"bug.2.7" handle Fail _ => ();
new_script{name = "bug.2.7", state = initial_cn_state};
=SML
¹Z
	true
°
print_z_document"-";
=SML
store_mt_results_show mt_run [
    ("bug.2.7", bug_2_7, (), ())
];
=TEX	
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 20}
=SML
force_delete_theory"bug.2.20" handle Fail _ => ();
new_script{name = "bug.2.20", state = initial_cn_state};
¹CN
 procedure P is
    type REC is
    record
        X : INTEGER;
        Y : INTEGER;
    end record;
    for REC use
    record at mod 2;
        X at 0 range 0 .. 7;
        Y at 1 range 0 .. 7;
    end record;
    R : REC;
begin
    null;
end P;
°
=SML
CNSparkOutput.print_spark_program();
=SML
store_mt_results_show mt_run [
    ("bug.2.20", bug_2_20, (), ())
];
=TEX
\section{EPILOGUE}
=SML
diag_line (summarize_mt_results());
=TEX
\pagebreak
\end{document}
=IGN
