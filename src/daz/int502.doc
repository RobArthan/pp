% %Z% $Date$ $Revision$ $RCSfile$
=TEX

% TQtemplate.tex
% use_file "daz_init";
% use_file "int502";
% z_print_theory"-";
% open CNZGenerator;
% print_spark_program();
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Bugfix Tests}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/INT502}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{R.D.~Arthan & HAT Team}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & WIN01}
\TPPabstract{%
This document contains tests for fixes to bugs in the Compliance Tool.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issues 1.1-$Revision$%
] Initial Drafts.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains test data for the Compliance Tool as specified in \cite{ISS/HAT/DAZ/HLD502} and \cite{ISS/HAT/DAZ/USR502}.
\subsection{Introduction}
This document contains specific tests to check fixes to bugs in the Compliance Tool.
\section{PRELIMINARIES}

\section{BATCH 1 - 30/3/95}
See file {\tt drabugs300395.uue} in the project SCCS directory.

=SML
use_file "dtd013";
use_file "imp013";
=TEX
Function to clean up before doing a test.
=SML
fun clean_up () = (
	let	val thys = get_descendants "cn" less "cn";
		fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
	in	map del_thy thys
	end;	()
);
=TEX
Functions for recording some statistics of theories.

=SML
type theory_stats = {np : int, ng : int, na : int, nd : int, nc : int};
local
    fun noof_parents thy = (length o get_parents) thy;
    fun noof_global thy = (length o get_consts) thy;
    fun noof_axioms thy = (length o get_axioms) thy;
    fun noof_defns thy = (length o get_defns) thy;
    fun noof_conjectures thy = (length o get_conjectures) thy;
in
    fun get_theory_stats (thy : string) : theory_stats =
    let
        val np = noof_parents thy;
        val ng = noof_global thy;
        val na = noof_axioms thy;
        val nd = noof_defns thy;
        val nc = noof_conjectures thy;
    in
        {np = np, ng = ng, na = na, nd = nd, nc = nc}
    end;
end;
=TEX
The following function is a convenience in cases where we just want to
test that something fails without working out exactly what the
error message is:
=SML
fun check_fail (f: unit -> unit) : bool = (
		(f (); false)
	handle Fail msg => (
		diag_line (get_message_text msg);
		true
	)
);
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.1}
Documentary --- no test.
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.2}
Tested in \cite{ISS/HAT/DAZ/INT504}
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.3}
This bug is essentially cosmetic.
The following script exhibits the two sorts of required behaviour, but
it can only be checked by examnining the log.
=SML
clean_up();
new_script{name = "bug.1.3", state = initial_cn_state};
πCN
procedure P is
	procedure proc_without_spec is separate;
	procedure proc_with_spec Ñ [true] is separate;
	function func_without_spec (x: integer) return integer is separate;
	function func_with_spec (x: integer) return integer Ñ [true] is separate;
begin
    null;
end P;
∞
=SML
CNSparkOutput.print_spark_program();
CNSparkOutput.print_web_clause (!CNZGenerator.diag_web_clause);
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.4}
Concerns wording of two error messages:
=SML
get_error_message 505060 ["X"];
get_error_message 505064 ["A, B, C", "X"];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.5}
The following should not give a syntax error:
=SML
clean_up();
new_script{name = "bug.1.5", state = initial_cn_state};
fun bug_1_5 () = 
πCN
procedure P is
   ß Declarations ¢          (1)
begin
   ß Initialisation ¢        (2)
   loop
      ß Body ¢          (3)
   end loop;
end P;
∞
=SML
store_mt_results_show mt_run [
    ("bug.1.5", bug_1_5, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.6}
=SML
clean_up();
new_script{name = "bug.1.6", state = initial_cn_state};
πCN
procedure P is
    A : INTEGER;
    subtype S is INTEGER range 3 .. 10;
    procedure Q
        Ñ A [ A = S_APOST_FIRST ]
    is
        S_APOST_FIRST : INTEGER;
    begin
        S_APOST_FIRST := A;
    end Q;
begin
    Ñ A[A = 5]
end P;
∞
The following should flag an error because it produces a VC with a free variable.
=SML
fun bug_1_6 () =
πCN
  √ 
    A := 10;
    Q;
    A := A + 2;
∞
=SML
store_mt_results_show mt_run [
    ("bug.1.6", check_fail, bug_1_6, true)
];
=TEX
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.7}
The following will need correcting if someone changes the ProofPower-Z misfeature
whereby use of the schema $T$ below as a predicate does not bind
the global variable $O$.
(In which event, the example should just work).
=SML
clean_up();
new_script{name = "bug.1.7", state = initial_cn_state};
πCN
procedure P is
    ß Declarations ¢ (1)
begin
    ß Initialisation ¢ (2)
    ß Loop ¢ (3)
end P;
∞
πCN
(1) È 
 type S is range 0 .. 7;
 I : constant S := 0;
 O : constant S := 4;
 STATE : S;
∞
ˇ T ¸¸¸¸¸¸¸¸¸¸¸
‹ STATE : S;
‹ O : ˙
˜¸¸¸¸¸¸
‹ STATE = I
à¸¸¸¸¸¸¸¸¸¸¸¸¸

πCN
(2) È Ñ STATE [T]      (4)
∞
=SML
fun bug_1_7_1 () =
πCN
(4) √ STATE := I;
∞
The following should flag an error because it produces a VC with a free variable.
=SML
store_mt_results_show mt_run [
    ("bug.1.7.1", check_fail, bug_1_7_1, true)
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.8}
Tested in \cite{ISS/HAT/DAZ/INT503}
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.9}
=SML
clean_up();
new_script{name = "bug.1.9", state = initial_cn_state};
πCN
procedure P is
    X : INTEGER;
    procedure Q (Y : in out INTEGER)
    Ñ Y [ Y = Yâ0 + 2 ]
    is
    begin
        Y := Y + 2;
    end Q;
begin
     Ñ X [X = Xâ0 + 6] (1)
end P;
∞
πCN
 (1) √
        Q(X);
        X := X + 4;
∞
The following gives some evidence that the Xs have been substituted for the Ys.
=SML
fun ok_1_9 () = (
	let 	val vs = (map fst o term_vars o get_conjecture "bug.1.9") "vc1_2";
	in	not ("Yâ0" mem vs orelse "Y" mem vs)
	end
);
=SML
store_mt_results_show mt_run [
    ("bug.1.9", ok_1_9, (), true)
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.10}
Not fixed.
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.11}
=SML
clean_up();
new_script{name = "bug11", state = initial_cn_state};
πCN
procedure Q is
    type D is (THU, FRI, SAT);
    type A1 is array (D) of D;
    type A2 is array (D) of A1;
    A : A2;
begin
    Ñ A [A(THU)(SAT) = FRI]        (9)
end Q;
∞
Following should not crash:
=SML
fun bug_1_11 () = 
πCN
(9) √ A(THU)(SAT) := FRI;
∞
=SML
store_mt_results_show mt_run [
    ("bug.1.11", bug_1_11, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.12}
=SML
clean_up();
new_script{name = "bug12", state = initial_cn_state};

πCN
package PACK is
     type REC is
     record
        X : INTEGER;
        Y : INTEGER;
     end record;
end PACK;
∞
=SML
fun bug_1_12 () =
πCN
with PACK;
procedure P is
begin
   null;
end P;
∞
=SML
store_mt_results_show mt_run [
    ("bug.1.12", bug_1_12, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.13}
=SML
clean_up();
new_script{name = "bug.1.13", state = initial_cn_state};

πCN
procedure P is
   type DAY is (MON, TUE, WED, THU, FRI);
   D : DAY;
begin
   for I in DAY
   loop
      Ñ D [D = I]            (1)
   end loop;
end P;
∞
πCN
(1) √ D := I;
∞
The following gives some evidence that the VC is as required.
=SML
fun ok_1_13 () = (
	let 	val vs = (map fst o term_consts o get_conjecture "bug.1.13") "vc1_1";
	in	"z'DAY" mem vs andalso not ("z'INTEGER" mem vs)
	end
);
=SML
store_mt_results_show mt_run [
    ("bug.1.13", ok_1_13, (), true)
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.14}
Bug in xpp, not the Compliance Tool (check by inspection of templates help).
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.15}
Documentary.
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.16}
=SML
clean_up();
new_script{name = "bug.1.16", state = initial_cn_state};
πZ
‹ [A]
∞
Printing Z document should not crash:
=SML
store_mt_results_show mt_run [
    ("bug.1.16.1", output_z_document,
		{script="bug.1.16", out_file="int502.1.16.zed"}, ())
];
=TEX
Reloading Z document should give similar theory:
=SML
val bug_1_16_stats = get_theory_stats "bug.1.16";
clean_up();
use_file"int502.1.16.zed";
store_mt_results_show mt_run [
    ("bug.1.16.2", get_theory_stats ,"bug.1.16", bug_1_16_stats)
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.17}
The following test is a bit more demanding than the failure case supplied by DRA.
=SML
clean_up();
new_script{name = "bug.1.17", state = initial_cn_state};
ˇ S ¸¸¸¸¸¸¸¸¸¸¸
‹ a : Ó
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

ˇ T ¸¸¸¸¸¸¸¸¸¸¸
‹ S
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

ˇ V ¸¸¸¸¸¸¸¸¸¸¸
‹ S!
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
πZ
[A]
∞
ˇ W[X, Y] ¸¸¸¸¸¸¸¸¸¸¸
‹ x, x':X;
‹ y, y' : Y;
‹ S
˜¸¸¸¸¸¸¸¸¸¸
‹ #{x, x'} º a ± #{y, y'} æ a
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ù[ X ]úúúúúúúúúúú
‹ x, y : X
˜¸¸¸¸¸¸
‹ (∂a, b: X ∑ a Ω b) ¥ x Ω y
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇ WW[X, Y] ¸¸¸¸¸¸¸¸¸¸¸
‹ x, x?:X;
‹ y, y? : Y;
‹ S!
˜¸¸¸¸¸¸¸¸¸¸
‹ #{x, x?} º a! ± #{y, y?} æ a!
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ˇ QQ[X, Y] ¸¸¸¸¸¸¸¸¸¸¸
‹ ab : X ; bc : Y
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
ù[ X , Y]úúúúúúúúúúú
‹ QQ[X, Y]
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
πZAX
‹ S
∞
ˇ RR[X, Y] ¸¸¸¸¸¸¸¸¸¸¸
‹ abc : X ; bcd : Y
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
πZ
‹ Tree ::= AA (Ó) | BB (Tree ∏ Tree)
∞
Printing Z document should not crash:
=SML
store_mt_results_show mt_run [
    ("bug.1.17.1", output_z_document,
		{script="bug.1.17", out_file="int502.1.17.zed"}, ())
];
=TEX
Reloading Z document should give similar theory:
=SML
val bug_1_17_stats = get_theory_stats "bug.1.17";
clean_up();
use_file"int502.1.17.zed";
store_mt_results_show mt_run [
    ("bug.1.17.2", get_theory_stats ,"bug.1.17", bug_1_17_stats)
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.18}
=SML
clean_up();
new_script{name = "bug.1.18", state = initial_cn_state};
ù[X]úúúúúúúúúúú
‹ x : X
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸
Printing Z document should not crash:
=SML
store_mt_results_show mt_run [
    ("bug.1.18.1", output_z_document,
		{script="bug.1.18", out_file="int502.1.18.zed"}, ())
];
=TEX
Reloading Z document should give similar theory:
=SML
val bug_1_18_stats = get_theory_stats "bug.1.18";
clean_up();
use_file"int502.1.18.zed";
store_mt_results_show mt_run [
    ("bug.1.18.2", get_theory_stats ,"bug.1.18", bug_1_18_stats)
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 1.19}
=SML
clean_up();
new_script{name = "bug.1.19", state = initial_cn_state};

πCN
package PACK is
   type INT_TYPE is range 5 .. 90;
   X : INT_TYPE;
end PACK;
∞ 
The following should not crash:
=SML
fun bug_1_19 () = 
πCN
with PACK;
procedure MAIN
Ñ PACKoX [PACKoX = 45]
is   
begin
   PACK.X := 45;
end MAIN;
∞
PolyML.exception_trace bug_1_19;
=SML
store_mt_results_show mt_run [
    ("bug.1.19", bug_1_19, (), ())
];
=TEX
\section{BATCH 2 - 13/9/95}
See file {\tt drabugs201095.uue} in the project SCCS directory.
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.1}
=SML
clean_up();
new_script{name = "bug.2.1", state = initial_cn_state};
=TEX
The following should not crash:
=SML
fun bug_2_1 () = 
πCN
procedure P is
    function F (X : INTEGER; Y : INTEGER; Z : INTEGER) return INTEGER is
    begin
        return 5;
    end F;
begin
    null;
end P;
∞ 

πCN
procedure Q is
    type rec is record XYZ : INTEGER; ABC : INTEGER; end record;
begin
    null;
end Q;
∞ 

=SML
store_mt_results_show mt_run [
    ("bug.2.1", bug_2_1, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.2}
=SML
clean_up();
new_script{name = "bug.2.2", state = initial_cn_state};
=TEX	
πCN
procedure P is
    function F (X, Y : INTEGER) return INTEGER
    -- Ñ [F(X, Y) = 5]
 is
    begin
        return 5;
    end F;
begin
    null;
end P;
∞ 
=SML
fun chk_2_2 () = type_ofÒFÆ =: type_ofÒ(_+_)Æ;
store_mt_results_show mt_run [
    ("bug.2.2", chk_2_2, (), true)
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.3}
=SML
clean_up();
new_script{name = "bug.2.3", state = initial_cn_state};
=TEX	
πCN
package PACK1 is
    C: constant INTEGER := 20;
    procedure P (Y : out INTEGER)
    Ñ Y [Y = C];
    function F (X : INTEGER) return INTEGER
    Ñ [F(X) = 99 + C];
end PACK1;
∞ 
πCN
with PACK1;
procedure MAIN is
    X : INTEGER;
begin
    Ñ X [ X = 20]
end MAIN;
∞ 
=SML
fun bug_2_3_1 () =
πCN
  √ PACK1.P(X);
∞
=SML
store_mt_results_show mt_run [
    ("bug.2.3.1", bug_2_3_1, (), ())
];
=TEX
=SML
set_goal([], get_conjecture"-" "vc_1_2");
a(rewrite_tac[get_specÒPACK1oCÆ] THEN REPEAT strip_tac);
fun bug_2_3_2 () = (pop_thm(); ());
=SML
store_mt_results_show mt_run [
    ("bug.2.3.2", bug_2_3_2, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.4}
=SML
clean_up();
new_script{name = "bug.2.4", state = initial_cn_state};

πCN
package PACK is
   type INT is range 10 .. 20;
end PACK;
∞

πCN
with PACK;
procedure MAIN is
    function ">=" (left, right : PACK.INT) return BOOLEAN renames PACK.">=";
    I : PACK.INT;
begin
    Ñ I [I æ 15]
end MAIN;
∞

πCN
√ if I >= 15
   then null;
   else I := 16;
   end if;
∞
=SML
output_z_document{script="-", out_file="int502.zed"};
clean_up();
fun bug_2_4 () = use_file"int502.zed";
=SML
store_mt_results_show mt_run [
    ("bug.2.4", bug_2_4, (), ())
];
=TEX

% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.5}
=SML
clean_up();
new_script{name = "bug.2.5", state = initial_cn_state};
=TEX	
πCN
procedure P is
     type UNCON is array (INTEGER range <>) of INTEGER;
     subtype SUB is INTEGER range 1 .. 10;
     subtype ARR is UNCON (SUB);
begin
     null;
end P;
∞ 
=SML
CNSparkOutput.print_spark_program();
=SML
store_mt_results_show mt_run [
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.6}
=SML
clean_up();
new_script{name = "bug.2.6", state = initial_cn_state};
=TEX
=SML	
fun bug_2_6 () =
πCN
procedure P is
    type REC is
    record
        X : INTEGER;
        Y : INTEGER;
    end record;
    C : constant REC := REC'(67, 89);
    D : constant INTEGER := C.X + 9;
begin
    null;
end P;
∞ 
=SML
store_mt_results_show mt_run [
    ("bug.2.6", bug_2_6, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.7}
=SML
clean_up();
new_script{name = "bug.2.7", state = initial_cn_state};
=SML
πZ
	true
∞
=SML
fun bug_2_7 () = print_z_document"-";
store_mt_results_show mt_run [
    ("bug.2.7", bug_2_7, (), ())
];
=TEX	
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.8}
=SML
clean_up();
new_script{name = "bug.2.8", state = initial_cn_state};

=SML
fun bug_2_8 () =
πCN
procedure P is
    type INT is range 8 .. 10;
    type CHAR_ARRAY is array (INT) of CHARACTER;
    C : CHAR_ARRAY; 
begin
    C := CHAR_ARRAY'('e', 'j', 'f' );
end P;
∞
=SML
store_mt_results_show mt_run [
    ("bug.2.8", bug_2_8, (), ())
];
=TEX	
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.9}
=SML
clean_up();
new_script{name = "bug.2.9", state = initial_cn_state};

=SML
πCN
procedure P is
    type INT is range 8 .. 10;
    I : constant INT := INT'(9); 
begin
    null;
end P;
∞
=SML
fun bug_2_9 () = (prove_rule[z_get_specÒIÆ] ÒI = 9Æ; ());
store_mt_results_show mt_run [
    ("bug.2.9", bug_2_9, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.10}
=SML
clean_up();
new_script{name = "bug.2.10", state = initial_cn_state};
=TEX	
πCN
procedure P is 
begin
    for I in INTEGER range 1 .. 10
    till ˚ I = 7 ˝    
    loop
         Ñ [true]         (1)
    end loop;
end P;
∞

πCN
(1) √ exit when I = 8; 
∞
=SML
fun chk_2_10 () = (
	let val (_, _, tm) = dest_z_µ(get_conjecture "-" "vc1_1");
	in	tm =$ ÒI = 7Æ
	end
);
store_mt_results_show mt_run [
    ("bug.2.10", chk_2_10, (), true)
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.11}
=SML
clean_up();
new_script{name = "bug.2.11", state = initial_cn_state};
=TEX	
πCN
procedure P is 
begin
    for I in INTEGER range 1 .. 10
    till ˚ I = 7 ˝    
    loop
         Ñ [true]         (1)
    end loop;
end P;
∞

=SML
fun bug_2_11 () =
πCN
(1) √ if I = 8 then exit; end if; 
∞
=SML
store_mt_results_show mt_run [
    ("bug.2.11", bug_2_11, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.14}
=SML
clean_up();
new_script{name = "bug.2.14", state = initial_cn_state};
πCN
procedure P is
    type REC is record
        C : INTEGER;
        B : INTEGER;
        A : INTEGER;
    end record;
    R : REC;

begin
    Ñ R [R.A = 11]
end P;
∞

πCN
 √ R := REC'(11, 99, 5);
∞
=SML
fun chk_2_14 () = (
	(snd o dest_eq o concl o rewrite_conv[] o get_conjecture"-")"vc_1_1"
	=$ mk_f
);
=SML
store_mt_results_show mt_run [
    ("bug.2.14", chk_2_14, (), true)
];
=TEX	
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.16}
=SML
clean_up();
new_script{name = "bug.2.16.1", state = initial_cn_state};
πCN
package PACK is
     V : INTEGER;
end PACK;
∞

πCN
with PACK;
procedure MAIN is
     A : INTEGER;
begin
     Ñ A [A = 8]
end MAIN;
∞

=SML
fun bug_2_16_1 () = 
πCN
√ A := PACK.V;
∞
=SML
store_mt_results_show mt_run [
    ("bug.2.16.1", bug_2_16_1, (), ())
];
=SML
clean_up();
new_script{name = "bug.2.16.2", state = initial_cn_state};

πCN
package PACK is
     V : INTEGER;
end PACK;
∞

πCN
with PACK;
procedure MAIN is
     A : INTEGER;
begin
     Ñ A, PACKoV [A = 8]
end MAIN;
∞

=SML
fun bug_2_16_2_1 () = 
πCN
√ PACK.V := 8;
   A := PACK.V;
∞
=SML
fun bug_2_16_2_2() = 
	(pc_rule1"cn" prove_rule[] (get_conjecture"-""vc_1_1"); ());
=TEX
=SML
store_mt_results_show mt_run [
    ("bug.2.16.2.1", bug_2_16_2_1, (), ()),
    ("bug.2.16.2.2", bug_2_16_2_2, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.17}
=SML
clean_up();
new_script{name = "bug.2.17", state = initial_cn_state};
πZAX
‹ f : ˙ ≠ ˙
˜¸¸¸¸¸¸
‹ µi:˙∑f i = 0
∞

πCN
 function F (X : INTEGER) return INTEGER
 Ñ  [F(X) = f(X)]
 is
  begin
    return 0;
  end F;
∞
=SML
fun bug_2_17() =
	(pc_rule1"cn"prove_rule[z_get_specÒfÆ](get_conjecture"-""vcF_1");());
=TEX
=SML
store_mt_results_show mt_run [
    ("bug.2.17", bug_2_17, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.18}
=SML
clean_up();
new_script{name = "bug.2.18", state = initial_cn_state};
πCN
 procedure TEST is
    X : INTEGER;
 begin
    for I in INTEGER
    loop
       Ñ X [ X = 7 ]
    end loop;
 end TEST;
∞

πCN
 √ X := X + 9;
∞
=SML
fun chk_2_18 () = (
	let	val (decl, _,_) = dest_z_µ(get_conjecture"-""vc_1_1");
	in	length (dest_z_decl decl) = 1
	end
);
=TEX
=SML
store_mt_results_show mt_run [
    ("bug.2.18", chk_2_18, (), true)
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.19}
=SML
clean_up();
new_script{name = "bug.2.19", state = initial_cn_state};

πCN
procedure P is
   X : INTEGER;
begin
   Ñ X [X = 7]
end P;
∞

=SML
fun bug_2_19 () =
πCN
√ X := INTEGER'PRED(8);
∞
=TEX
=SML
store_mt_results_show mt_run [
    ("bug.2.19", bug_2_19, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.20}
=SML
clean_up();
new_script{name = "bug.2.20", state = initial_cn_state};
πCN
 procedure P is
    type REC is
    record
        X : INTEGER;
        Y : INTEGER;
    end record;
    for REC use
    record at mod 2;
        X at 0 range 0 .. 7;
        Y at 1 range 0 .. 7;
    end record;
    R : REC;
begin
    null;
end P;
∞
=SML
fun bug_2_20 () = CNSparkOutput.print_spark_program();
=SML
store_mt_results_show mt_run [
    ("bug.2.20", bug_2_20, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.21}
=SML
clean_up();
new_script{name = "bug.2.21", state = initial_cn_state};

ˇ S ¸¸¸¸¸¸¸¸¸¸¸
‹ y : Ó
˜¸¸¸¸¸¸
‹ y = 7
à¸¸¸¸¸¸¸¸¸¸¸¸¸¸

=SML
fun bug_2_21 () =
πZAX
‹ x : ˙
˜¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸¸
‹ S
∞
=SML
fun chk_2_21 () = (
	set_flag("standard_z_paras", true);
	(bug_2_21(); false) handle Fail _ => true
);
store_mt_results_show mt_run [
    ("bug.2.21", chk_2_21, (), true)
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.22}
=SML
clean_up();
new_script{name = "bug.2.22", state = initial_cn_state};

πCN
package PACK is
   type COLOUR is (RED, BLUE, GREEN);
   X : COLOUR;
   procedure P
   Ñ X [µ C : COLOUR ∑ true];
end PACK;
∞

πCN
with PACK;
procedure P is
    Y : PACK.COLOUR;
begin
    Ñ Y [Y = PACKoGREEN]         (1)
end P;
∞

=SML
fun bug_2_22 () =
πCN
(1) √ PACK.P;
∞
=SML
store_mt_results_show mt_run [
    ("bug.2.22", bug_2_22, (), ())
];
=TEX
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\subsection{Bug 2.23}
=SML
clean_up();
new_script{name = "bug.2.23.1", state = initial_cn_state};
πCN
package STACKS is

    subtype STACK_RANGE is INTEGER range 1 .. 10;
    type STACK_TYPE is array (STACK_RANGE) of INTEGER;
    subtype TOP_RANGE is INTEGER range 0 .. 10;
    type STACK is
    record
        ST : STACK_TYPE;
        TOP : TOP_RANGE;
    end record;

    procedure CLEAR_STACK (S : in out STACK)
    Ñ S [S.TOP = 0];

end STACKS;
∞
=SML
fun bug_2_23_1() =
πCN
with STACKS;
procedure MAIN is
    S : STACKS.STACK;
begin
    Ñ S [true]      (1)
end MAIN;
∞
=SML
store_mt_results_show mt_run [
    ("bug.2.23.1", bug_2_23_1, (), ())
];
=SML
clean_up();
new_script{name = "bug.2.23.2", state = initial_cn_state};
πCN
package STACKS is

    subtype STACK_RANGE is INTEGER range 1 .. 10;
    type STACK_TYPE is array (STACK_RANGE) of INTEGER;
    subtype TOP_RANGE is INTEGER range 0 .. 10;
    type STACK is
    record
        ST : STACK_TYPE;
        TOP : TOP_RANGE;
    end record;

    S : STACK;

    procedure CLEAR_STACK
    Ñ S [S.TOP = 0];

end STACKS;
∞

=SML
fun bug_2_23_2_1() =
πCN
with STACKS;
procedure P
Ñ STACKSoS [ STACKSoS.TOP + 1 = 1 ]
is
begin
    STACKS.CLEAR_STACK;
end P;
∞
fun bug_2_23_2_2 () = (
	map (pc_rule1 "cn" prove_rule[] o snd o snd) (get_conjectures"-"); ()
);
=SML
store_mt_results_show mt_run [
    ("bug.2.23.2.1", bug_2_23_2_1, (), ()),
    ("bug.2.23.2.2", bug_2_23_2_2, (), ())
];
=TEX
% #### #### #### #### #### #### #### #### #### #### #### #### #### ####
\section{Other Bugs Reported}
\subsection{Operator Associativity}
=SML
clean_up();
new_script{name = "op.assoc", state = initial_cn_state};
πCN
procedure P is
    C: constant INTEGER := 1 - 2 + 3;
    D: constant INTEGER := 1 / 1 * 3;
begin
    null;
end P;
∞
=SML
fun chk_op_assoc_1 () = (
	pc_rule1 "cn" prove_rule[z_get_specÒCÆ,z_get_specÒDÆ]ÒC = 2 ± D = 3Æ;
	()
);
=SML
store_mt_results_show mt_run [
    ("op.assoc.1",chk_op_assoc_1, (), ())
];
=TEX
\section{EPILOGUE}
=SML
diag_line (summarize_mt_results());
=TEX
\pagebreak
\end{document}
=IGN
