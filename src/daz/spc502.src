=WARNING_EDIT_WITH_CARE spc502.src
=TEX
\documentclass{derarep5}
%\usepackage{cadiZ}


\usepackage{ProofPower}
\def\ZAxDesLabel{}
\def\ZGenericLabel{}
\def\ZOtherLabel{}
\def\ZSchemaLabel{}
\def\Hide#1{\relax}
\ftlmargin=4em
\tabstop=2em
%\ftlinepenalty=9999
\def\RCSVersion{$Revision: 1.11 $%
}

\makeindex


\newcommand{\imp}{\mathrel{\mbox{$\Longrightarrow$}}}


\docno{DRA/CIS/CSE3/TR/94/27/4.0}
\title{Specification of the compliance notation for SPARK and Z}
\volume{2}{3}
\author{C M O'Halloran\\ C T Sennett\\ A Smith}
\Author{O'Halloran C M, Sennett C T, Smith A}
\keywords{Z, SPARK, Refinement, Literate Programming}
\date{February 28, 2002}
\issuedate{February 28, 2002}


%\protmark{}
%\descriptor{}
%\caveat{}
%\codeword{}

\location{Issued by System Assurance Group, KIS Division, \\
QinetiQ, St. Andrews Road, Malvern, Worcestershire, WR14 3PS. \\
Telephone 01684-894320.}
\contractno{CRP8/TG10}
\periodcovered{April 2000 - March 2001}
\customer{DDEC(ISTAR)ET}
\reportprotmark{Not protectively marked}
\reportcaveat{None}
\reportdescriptor{None}
\conference{None}
\titleclass{Not protectively marked}
\keywords{Z, SPARK, Refinement, Literate Programming}
\abstractclass{Not protectively marked}

\raggedbottom


\begin{document}

\maketitle

\begin{center}\fbox{\hspace{3mm}\parbox[t]{130mm}{
\hspc \textbf{Customer Information} \hspc\\[5mm]
\hspc\begin{tabular}{ll}
    Package Number:     & TG10 \\
    Package Title:      & Computing, Information and Signal Processing \\
    Package Customer:   & DDEC(ISTAR)ET \\
    Package Manager:    & Graham Dean \\
    Research Objective: & 5 \\
    Technical Area:     & 3 \\
    Assignment Number:  & 2
\end{tabular}\hspc
}}\vspace{25mm}

\fbox{\hspace{3mm}\parbox[t]{130mm}{\rule[-2mm]{0mm}{8mm}
  This document has been prepared for MoD and, unless indicated, may
  be used and circulated in accordance with the conditions of the Order
  under which it was supplied.\\
  \hspace*{5mm}\\
  It may not be used or copied for any non-Governmental or commercial
  purpose without the written agreement of QinetiQ.
\rule[-4mm]{0mm}{8mm}}\hspace{3mm}}\vspace{25mm}

\copyright Copyright QinetiQ 2002\\
QinetiQ UK \\
\vspace{5mm}
Approval for wider use or release must be sought from:\\
\vspace{5mm}
Intellectual Property Department\\
QinetiQ\\
QinetiQ Farnborough\\
Farnborough, Hampshire GU14 0LX
\end{center}

\startpre

\section*{Authorisation}

\begin{center}
  \begin{tabular}[t]{@{}p{40mm}p{90mm}@{}}
     Prepared by:       & A Smith \\
     Title:             & Senior Scientist \\
                        & \\
     Signature:         & \hrulefill \\
     Date:              & \hrulefill \\
     Location:          & L113, QinetiQ Malvern \\
                        & \\
     Authorised by:     & M Hill \\
     Title:             & Project Manager \\
                        & \\
     Signature:         & \hrulefill \\
     Date:              & \hrulefill \\
                        & \\
                        & \\
     Principal authors  & \\
                        & \\
     Name:              & A Smith \\
     Appointment:       & Senior Scientist \\
     Location:          & QinetiQ(Malvern) \\
                        & \\
     Name:              & C M O'Halloran \\
     Appointment:       & Lead Researcher \\
     Location:          & QinetiQ(Malvern) \\
                        & \\
     Name:              & C T Sennett \\
     Appointment:       & QinetiQ Fellow \\
     Location:          & QinetiQ(Malvern) \\    
  \end{tabular}

  \vspace{25mm}
  
  Issued by: System Assurance Group, KIS Division \\
  QinetiQ \\
  St. Andrews Road \\
  Malvern \\
  Worcestershire, WR14 3PS. \\
  Telephone 01684-894320
\end{center}

\section*{Record of changes}

This is a controlled document. \\
Additional copies should be obtained through the issuing authority. \\
In the extreme event of copying locally, each document shall be marked
`Uncontrolled Copy'. \\
Amendments shall be by whole document replacement. \\
Proposals for change to this document should be forwarded in writing to the issuing authority.\\
\\[15mm]
\begin{tabular}{|l|l|l|} \hline
    Version\hspace{1cm} & Date\hspace{2cm} & Comments\hspace{5cm} \\ \hline
  1.0  &  March 25, 1994     &  First Issue \\
  1.1  &  June 13, 1994      &  Data refinement added  \\
  1.2  &  December 22, 1994  &  Omissions found during implementation \\
       &                     &  of version 1.1 \\
  2.0  &  July 5, 1995       &  Various enhancements \\
  2.1  &  January 12, 1996   &  Omissions found during implementation \\
       &                     &  of version 2.0 \\
  3.0  &  September 26, 1997 &  Enhancements as recommended by independent \\
       &                     &  evaluation report \\
  3.1  &  August 4, 2000     &  Further enhancements \\
  4.0  &  February 28, 2002  &  \parbox[t]{7cm}{\raggedright
			     The specifications are now maintained on QinetiQ's behalf
			     by Lemma 1 Ltd. The formal Z material is now checked
			     and typeset using {\Product}. The specification changes
			     recorded in the documents HLD507\cite{LEMMA1/DAZ/HLD507}
			     and HLD508\cite{LEMMA1/DAZ/HLD508} have been actioned.

			    }\\
  4.1  &  May 17, 2002  &  \parbox[t]{7cm}{\raggedright
			     The specification has been enhanced to support extra Ada language
                                                    features as described in the current, interim, version
                                                     of the document HLD509\cite{LEMMA1/DAZ/HLD509}.
			    }\\
                       &                   & \\
                        &                   & \\
                        &                   & \\
                        &                   & \\
                        &                   & \\
                        &                   & \\ \hline
\end{tabular}    

\vfill
{\tiny Lemma 1 RCS \RCSVersion}

\abstract{This volume formally specifies how to obtain the verification 
conditions (VCs) from a refinement step.  The technical reasons behind the 
design of the algorithm are documented in [5].}

\tableofcontents

\startmain

\section{Introduction}

\bpar{
This volume formally specifies how to obtain the verification conditions (VCs) from a refinement step.
It is used by volume 1 which calls VC generation at certain points in a literate script.
These VCs are expressed in Z.
However, the sequence of SPARK statements introduced in a refinement step will of course contain SPARK
expressions. These SPARK expressions need to be translated to Z expressions which will appear in the VCs.
This translation is formally specified in volume 3 which specifies the translation of SPARK basic
declarations and expressions to Z.  
}\epar

\bpar*{
We run the {\Product} commands to set up a theory to hold the specification.
The specification depends upon the material in volume 3.
}\epar*

=SML
open_theory "Volume_3";
new_theory"Volume_2";
=TEX


\bpar{
The VCs are calculated using the idea of weakest preconditions (wp).
This volume gives the weakest precondition for each type of SPARK statement.
In order to do this an abstract syntax of SPARK statements is constructed
and then the weakest precondition is defined on this abstract syntax.
}\epar

\section{Structure of verification conditions}

\subsection{Sequents}

\bpar{
A $Sequent$ is defined in volume 3 as a set of hypotheses and a conclusion.
Here is some syntactic sugar for sequents.
}\epar


=SPCZ  Ù
=TEX


\bpar{
The correctness condition for a refinement step{}
=INLINEFT
Ñ w[pre,post] √ st
=TEX
{ }is simply \\

=INLINEFT
pre Ù wp(st, post)
=TEX
{ }where $wp(st,\ post)$ is the {\it weakest precondition} of $st$
with respect to $post$. Unfortunately for a large program
this will be a single large condition to prove. However the condition can be split up into a number of smaller
VCs using laws of propositional logic. This method of VC generation is therefore a two
stage process (calculating the correctness condition and then using laws of logic). However, the
algorithm presented in this volume does not need the second step. The trick is to
hold the wp at each point in its calculation as a number of small sequents (thus
the wp is being split up during its calculation). Using this approach there is a
need for the following infix function which adds a new hypothesis to a set
of sequents.
}\epar




=SPCZ  %Longrightarrow%
=TEX

\bpar{
In several places, a set of additional hypotheses must be
added to each of a set of sequents. The function {\it add\_hyps}
is used for this purpose.
}\epar

=SPCZ  add_hyps
=TEX

\subsection{Substitutions}

\bpar{
VC generation involves substitutions. The following functions perform these substitutions.
They are all loosely specified but perhaps could be implemented by using the
substitution symbol $\odot$ of standard Z [6].
This would avoid having to actually perform the substitutions on all the subexpressions of a term.
If substitutions are to be applied to a schema reference for example then without using $\odot$
the schema reference would have to be expanded; as well as having to perform the substitutions on the expansion
it will enlarge the VC and reduce traceability.
}\epar

\bpar{
$sub(pred,\ zid,\ zexp)$ is the predicate $pred$ with all free occurrences of $zid$ replaced by $zexp$.
}\epar


=SPCZ sub 
=TEX

\bpar{
$subs\_exp(zexp,\ w,\ w_0)$ is the expression $zexp$ with every occurrence of each variable in $w$ replaced
by its corresponding initial variable in $w_0$ ($w_0$ is simply the set $w$ with each element subscripted with 0).
The function $subs\_exp$ is partial because it is only ever called
with a set $w$ and its corresponding set $w_0$. It could perhaps be implemented by using repeated applications
of $\odot$.
}\epar 

=SPCZ subs_exp 
=TEX

\bpar{
The function $subs\_pred$ is similar to $subs\_exp$ but for predicates instead of expressions.
Also $subs\_pred$ is sometimes called with $w$ and $w_0$ the other way around, that is $subs\_pred(zpred,\ w_0,\ w)$,
which is $zpred$ with
every occurrence of each initial variable in $w_0$ replaced by its undecorated counterpart in $w$.
}\epar

=SPCZ subs_pred 
=TEX

\bpar{
The function $subseq$ is similar to $sub$ but for sets of sequents instead of predicates.
This function is necessary since the weakest precondition predicate is held throughout the algorithm as a set of sequents.
$subseq(sequents,\ zid,\ zexp)$ is the set of sequents $sequents$ with all free occurrences of $zid$
in every hypothesis and conclusion replaced by $zexp$.
}\epar

=SPCZ subseq 
=TEX


\section{Abstract syntax of SPARK statements}

\subsection{Overview}


\bpar{
The free type $€Statement›$ specifies those sequences of statements that can be introduced in a refinement step
for which VCs can be calculated.
Certain statement forms are allowed to appear anywhere in the sequence of statements for which
VCs are calculated.
These forms are considered in sections 3.2 to 3.15.
Other statement forms must appear either at the head of the sequence or inside a conditional
at the head of the sequence.
The reasons why these restrictions are imposed is explained in [5].
The restricted statement forms are considered in sections 3.16 to 3.19.
}\epar


\bpar{
The free type $Statement$ is recursive with some of its arms being schemas involving $Statement$.
The free type is defined in section 3.19.3. The schemas used in the arms of the free type are generic and will be instantiated at the point where they are used in defining the free type.

}\epar




\subsection{Null}



\bpar{
The concrete syntax {\tt null} is represented by the abstract syntax $null$ (see the free type $Statement$).
}\epar

\subsection{Assignment}

\bpar{
Concrete syntax. \\
\ \\
{\tt name := E}
}\epar

\bpar{
Abstract syntax.
}\epar

=SPCZ Assign 
=TEX



\subsection{Specification statement (no initial variables)}

\bpar{
Concrete syntax. \\
\ \\
$\Delta w\ [pre,\ post]$
}\epar



\bpar*{
Here the frame, $w$, is a comma-separated list of variable or schema names.
A schema name serves as a short-hand for the names in the signature of the schema.
}\epar*

\bpar{
Abstract syntax.
A {\it general} specification statement $Spec$ contains a frame $w$ of Z variables and pre and postconditions $pre$ and $post$
(Z predicates).
It is also convenient (for reasons of VC generation)
to hold $w_0$ in $Spec$ (even though $w_0$ does not explicitly occur in a
specification statement $\Delta w\ [pre,\ post]$) denoting the set $w$ but with its variables subscripted with 0.
Variables subscripted with 0 are called initial variables.
A $Spec$ definitely does not contain initial variables in its precondition but
may or may not contain initial variables in its postcondition.
}\epar



\bpar*{
In the abstract syntax, only variable names appear in frames.
Schema names are to be expanded in to lists of signature variable names during the
processing specified in volume 1.
}\epar*

\bpar*{
$Z\_PRED_0$ is the set of Z predicates that contain initial variables.
}\epar*

=SPCZ Z_PREDâ0 
=TEX

=SPCZ Spec 
=TEX




\bpar*{
$Spec$ does not form part of the free type $Statement$ but is needed in the definition of $Spec\_No\_Ivars$
(specification statement with {\it no} initial variables in postcondition) below which does form part of $Statement$.
Also $Spec$ is used to define $Spec\_Ivars$ (specification statement {\it with} initial variables in postcondition) later.
}\epar*

\bpar*{
$Spec$ is also used to define $Speclab$ (see section 5).
$Speclab$ contains the specification statement being refined
(that is, the specification statement on the left hand side of the refinement symbol).
$Spec$ is used in $Speclab$ to denote this specification statement
(as oppose to $Spec\_No\_Ivars$ or $Spec\_Ivars$) since any specification statement
can be refined; restrictions only apply to specification statements on the right of the refinement symbol.
}\epar*

\bpar*{
$Spec\_No\_Ivars$ is a specification statement with {\it no} initial variables in the postcondition.
}\epar*

=SPCZ Spec_No_Ivars 
=TEX


\subsection{Semicolon}



\bpar{
The concrete syntax {\tt P;Q} is represented in the abstract syntax as $semicolon(P, Q)$ (see the free type $Statement$).
}\epar

\subsection{If statement}

\bpar{
Concrete syntax. \\
\ \\
{\tt if\ G\ then\ P\ else\ Q\ end\ if}
}\epar

\bpar*{
Any user defined {\tt if} statement can be processed by the compliance notation tool to an {\tt if}
statement consisting of just {\tt if\ then\ else\ end\ if} statements.
}\epar*

\bpar{
Abstract syntax.
}\epar

\bpar*{
$COND$ represents the Ada Boolean expressions.
}\epar*

=SPCZ COND 
=TEX




=SPCZ If_Then_Else 
=TEX



\subsection{Case statement (no others)}

\bpar{
Concrete syntax. \\
\ \\
{
\tt case\ E\ is \\
\tt when\ choices\ => P \\
. \\
. \\
\tt end case
}
}\epar

\bpar{
Abstract syntax.
}\epar

\bpar*{
A $Case\_Alternative$ is one arm of a {\tt case} statement ({\tt when\ choices\ => P}). Range attributes and subtype indications as choices in a case statement
are represented using the corresponding first and last attributes, in
the same way as they are treated in aggregates.
}\epar*

=SPCZ CASE_CHOICE 
=TEX




=SPCZ Case_Alternative 
=TEX


=SPCZ Case 
=TEX

\subsection{Case statement (with others)}

\bpar{
Concrete Syntax. \\
\ \\
{
\tt case\ E\ is \\
\tt when\ choices\ => P \\
. \\
. \\
\tt others\ => Q \\
\tt end case
}
}\epar


\bpar{
Abstract syntax.

=SPCZ Case_Others 
=TEX

}\epar

\subsection{Undecorated loop}


\bpar{
Concrete syntax. \\
\ \\
{
\rm till\ $T$ \\
\tt loop \\
$\Delta\ w\ [pre,\ post]$ \\
\tt end\ loop
}
}\epar

\bpar{
Abstract syntax.
All loops are introduced with a specification statement
(no initial variables in postcondition) as loop body for reasons described in [5].
Also the abstract syntax for all the different kinds of loops
($Loop$, $While$, $For\_Static$, $For\_Tmark$ and $For\_Non\_Static$)
contains a {\it till} predicate $T$. If in the literate script the loop does not have a till
predicate then the part of the $SIDE$ condition (in the weakest precondition calculation for the loop) involving $T$ can be
removed (see section on weakest preconditions).
}\epar

=SPCZ Loop 
=TEX

\subsection{While loop}

\bpar{
Concrete syntax. \\
\ \\
{
\tt while\ G \\
\rm till\ $T$ \\
\tt loop \\
$\Delta\ w\ [pre,\ post]$ \\
\tt end\ loop
}
}\epar

\bpar{
Abstract syntax.
}\epar

=SPCZ While 
=TEX

\subsection{For loop (static bounds)}\label{AS_FOR_STATIC}

\bpar{
Concrete syntax. \\
\ \\
{
\tt for\ i\ in\ tmark\ range\ lo..hi \\
\rm till\ $T$ \\
\tt loop \\
$\Delta\ w\ [pre,\ post]$ \\
\tt end\ loop
} \\
\ \\

Alternative Concrete syntax. \\
\ \\
{
\tt for\ i\ in\ lo..hi \\
\rm till\ $T$ \\
\tt loop \\
$\Delta\ w\ [pre,\ post]$ \\
\tt end\ loop
} \\
\ \\


{\tt lo} and {\tt hi} are static expressions (do not contain variables).

Note that for both of these cases reverse transversal of the range may be specified by inserting the keyword {\tt reverse} after {\tt in}. The {\tt\itshape dir} signature variable in the abstract syntax
is set to {\tt\itshape Forwards} or {\tt\itshape Reverse} according to whether the keyword 
{\tt reverse} is absent or present, respectively.

}\epar

\bpar{
Abstract syntax.
}\epar

\bpar*{
If the range in the for-loop is given by a range attribute
it is represented by taking {\it lo} and {\it hi} to be the
corresponding first and last attributes, e.g., {\tt\itshape SUB'FIRST .. SUB'LAST}
in place of {\tt\itshape SUB'RANGE}. $STATIC\_EXP$ denotes the static expressions of Ada.
}\epar*

=SPCZ STATIC_EXP 
=TEX

=SPCZ LOOP_DIRECTION 
=TEX

=SPCZ For 
=TEX

=SPCZ For_Static 
=TEX

\subsection{For loop (type mark as range)}

\bpar{
Concrete syntax. \\
\ \\
{
\tt for\ i\ in\ tmark \\
\rm till\ $T$ \\
\tt loop \\
$\Delta\ w\ [pre,\ post]$ \\
\tt end\ loop
}
}\epar

\bpar{
Abstract syntax.
}\epar

=SPCZ For_Tmark 
=TEX


\subsection{Exit statement (with condition)}

\bpar{
Concrete syntax. \\
\ \\
{\tt exit\ when\ G}
}\epar

\bpar{
Abstract syntax.
}\epar

=SPCZ Exit_When 
=TEX

\subsection{Exit statement}


\bpar{
Concrete syntax. \\
Without a loop name:
\ \\
{\tt exit}
With a loop name:
\ \\
{\tt exitN}
}\epar

\bpar{
Abstract syntax.
}\epar

=SPCZ Exit
=TEX

\subsection{Return statement}

\bpar{
Concrete syntax. \\
\ \\
{\tt return\ E}
}\epar

\bpar{
Abstract syntax.
}\epar

=SPCZ Return 
=TEX


\subsection{Procedure call (no initial variables in spec)}

\bpar{
Concrete syntax. \\
\ \\
{\tt name(actuals)}
}\epar

\bpar{
If the sequence of statements introduced during a refinement step includes a procedure call then VCs are generated
by replacing the procedure call by an instantiated version of the procedure's specification statement.
Therefore similar restrictions apply to the placing of procedure calls as to specification statements.
}\epar



\bpar{
Abstract syntax.
$Proc\_Call$ is a {\it general} procedure call. It does not appear as an arm of the free type $Statement$ but is used in the
definition of $Proc\_Call\_No\_Ivars$ (procedure call where the procedure's specification statement contains {\it no}
initial variables in the postcondition)
below and in the definition of $Proc\_Call\_Ivars$ ({\it with} initial variables in the postcondition) later.
}\epar

=SPCZ Proc_Call 
=TEX

\bpar*{
The function $retrieve\_spec\_stmt$ returns a procedure's specification statement.
}\epar* 

=SPCZ  retrieve_spec_stmt
=TEX


\bpar*{
$Proc\_Call\_No\_Ivars$ is a procedure call where the procedure's specification statement contains {\it no}
initial variables in the postcondition.
}\epar*

=SPCZ  Proc_Call_No_Ivars
=TEX


\subsection{Specification statement (with initial variables)}

\bpar{
A specification statement containing initial variables in the postcondition must be the first statement in the sequence.
The technical reasons for this are in [5] but briefly it is because VC generation brings the initial variables
in the specification statement and those in the specification statement being refined (the $Spec$ of a $Speclab$ -
see section 5) together in the same VC. The initial variables in the two specification statements must therefore represent
the same values. This is achieved if a specification statement containing initial variables in the postcondition
is the first statement in the sequence.
}\epar

\bpar{
Abstract syntax.
}\epar

=SPCZ  Spec_Ivars
=TEX


\subsection{For loop (non-static bounds)}

\bpar{
Concrete syntax. \\
\ \\
{
\tt for\ i\ in\ tmark\ range\ lo..hi \\
\rm till\ $T$ \\
\tt loop \\
$\Delta\ w\ [pre,\ post]$ \\
\tt end\ loop
} \\
\ \\
{\tt lo} and {\tt hi} are non-static expressions (contain variables).
}\epar

\bpar{
A {\tt for} loop with non-static bounds (variables in the bounds) must be the first statement in the sequence.
Again the technical reasons for this are in [5] but briefly it is because the bounds of a {\tt for} loop are evaluated
at the {\it start} of the loop; initial variables are therefore used to express these bounds and so for reasons
similar to above such a {\tt for} loop must be the first in the sequence.
}\epar

\bpar*{
Alternative Concrete Syntax\\
As with {\tt for} loops with static bounds (see section~\ref{AS_FOR_STATIC}),
the type mark my be omitted and reverse traversal of the loop may be specified.
}\epar*

\bpar{
Abstract syntax.
}\epar 

=SPCZ  For_Non_Static
=TEX



\newpage

\subsection{Logical constant}



\bpar{
Concrete syntax. 
}\epar

\vertbarfalse
=GFT
con xâ1 : Tâ1; xâ2 : Tâ2; ... ∑ Ñ w [xâ1 = Eâ1 ± xâ2 = Eâ2 ± ... ± preâ1, post]
=TEX
\vertbartrue

\bpar{
A logical constant introduction must be the first statement in the sequence.
Again the technical reasons for this are in [5] but briefly it is because a logical constant is used to denote
the value of a program variable at some point in the program; this information is incorporated into the VCs by
using initial variables and so for reasons similar to above a logical constant introduction must be the first in the sequence.
Also the need for an existential quantifier in the VCs can be removed by demanding that the
logical constant is introduced using a precondition of the above form.
}\epar

\bpar{
Abstract syntax.
}\epar

\bpar*{
The function $free\_ids$ returns the identifiers that appear free in a Z expression.
}\epar*

=SPCZ  free_ids
=TEX




=SPCZ  Log_Con_Def
=TEX

=SPCZ  Log_Con
=TEX


\bpar*{
The defining equations in the abstract syntax must be taken in the same order
as they appear in the concrete syntax.
}\epar*

\subsection{Procedure call (initial variables in spec)}

\bpar{
If the sequence of statements contains a procedure call where the corresponding specification statement
contains initial variables in the postcondition then this call must be the first statement in the sequence.
This is because, for VC generation, the call is replaced with an instantiated version of the specification statement.
This instantiated version will contain initial variables in the postcondition and so the problem is the same as that in the
above subsection on specification statements with initial variables.
}\epar

\bpar{
Abstract syntax.
}\epar

=SPCZ  Proc_Call_Ivars
=TEX




\bpar{
Statement brings together the different statement forms, completing the recursive definition
that was begun in section 3.1.2. 
}\epar


=SPCZ Statement 
=TEX

\section{Weakest preconditions}

\subsection{The function wp}

\bpar{
The weakest precondition (wp) is calculated within an environment $Wp\_Env$ (see below).
For refinements inside a function body $return$ and $fun\_header$ are
needed to calculate the wp of a {\tt return} statement.
$till$ is needed when an {\tt exit} statement is introduced.
$formal\_procs$ is needed to calculate the wp of a procedure call. The call is replaced with
an instantiated version of the procedure's specification statement.
}\epar

\bpar{
The following definitions are needed to define $Wp\_Env$.
}\epar

\bpar*{
$MODE$ contains the various modes of formal parameters of Ada subprograms.
}\epar*

=SPCZ  MODE
=TEX


\bpar*{
$Param\_Spec$ is an Ada formal parameter specification.
}\epar*


=SPCZ  Param_Spec
=TEX

\bpar*{
The sequence {\it globals}
is the list of all global variables read or written by the procedure (including
its formal parameters); it is derived from the procedure specification statement
in the concrete syntax.
}\epar*


\bpar*{
A $Formal\_Proc$ is an Ada procedure specification together with a specification statement.
}\epar*

=SPCZ  Formal_Proc
=TEX


\bpar*{
An $Informal\_Fun$ is an Ada function specification.
The name $Informal\_Fun$ is used as it has no specification statement (therefore {\it informal}).
}\epar*

=SPCZ  Informal_Fun
=TEX

\bpar{
The definition of $Wp\_Env$.
}\epar

=SPCZ  Wp_Env
=TEX

\bpar{
In the definition of the $wp$ function that follows, $WP$ is the weakest
precondition of a statement $st$ with respect to a postcondition $A$ provided
the $SIDE$ conditions hold. These side conditions are also output as VCs and enable
the breakdown of the correctness condition into simple VCs (see [5]).
The function $wp$ is partial because it is called during the execution of the function
$vcs$ which is itself partial (see section 5).
}\epar 

=SPCZ  Result
=TEX

=SPCZ  wp
=TEX


\bpar*{
The schema $Pars$ contains the parameters (arguments and result) of the function $wp$.
}\epar*

=SPCZ  Pars
=TEX



\bpar{
The function $wp$ is defined on each arm of the free type $Statement$.
}\epar

\bpar{
To avoid generating unprovable VCs for programs which are correct
provided they do not raise exceptions, the function {\it wp} may include
additional hypotheses in the weakest pre-conditions and side conditions
in the {\it Result} that it calculates.
These additional hypotheses are called domain conditions.
These are added when the translations of SPARK expressions are included
in the {\it Result}. For example, the assignment statement
{\tt I := I/J} might result in the domain condition asserting that
$J \not= 0$ being included.

The domain conditions are required to satisfy the following soundness
condition:if a Z predicate
– appears as one of the domain conditions for a SPARK expression $\cal E$,
then any assignment of values to variables that makes – false
must be such as to cause execution of $\cal E$ to raise an exception.
The details of the domain condition calculation are not further
specified here and may, indeed, be under the control of the user
of the tool.

The function {\it domain\_conds} calculates the domain conditions
for an Ada expression that has been translated into Z:

=SPCZ  domain_conds
=TEX


The function {\it add\_domain\_conds} adds the domain conditions for
a set of Z expressions to the hypotheses of each of a set of sequents:

=SPCZ  add_domain_conds
=TEX

}\epar

\subsection{Null}

\bpar{

}\epar



=SPCZ  NULL
=TEX


\subsection{Assignment}

\bpar*{
In general, we do not expect to be able to calculate the type of an arbitrary
Ada expression. However, for the restricted forms of expression allowed on the
left-hand side of an assignment, the type mark may be calculated using the
translations of the type declarations from the Z document.
The function $tmark\_of\_prefix$ does this. Its domain must include
all expressions that are allowed as the prefixes of indexed or component
selections on the left-hand side of an assignment statement.
}\epar*

=SPCZ  tmark_of_prefix
=TEX

\bpar*{The function {\it slide\_assign} preprocesses an assignment statement by
performing the array sliding conversion to the right-hand side
of the assignment, if necessary.}\epar*
=SPCZ slide_assign
=TEX

\bpar{
Any assignment {\tt name := E} is transformed into the form where there is a simple identifier
{\tt x} to the left of the assignment ({\tt name} might include array indexing and record selection).
The wp can then be worked out simply as in the schema $SIMPLE\_ASSIGN$ below.
The two schemas after $SIMPLE\_ASSIGN$ show how the transformation of array indexing and record selection is achieved.
The process is recursive removing one lot of array indexing or record selection at a time.
}\epar


=SPCZ  SIMPLE_ASSIGN
=TEX

\bpar{
An assignment of the form 
=INLINEFT
prefix(index) := E
=TEX
\ is transformed to
\vertbarfalse
=GFT
prefix := ˚prefix ´ {index Ì E}˝.
=TEX
\vertbartrue
The brackets 
=INLINEFT
˚˝
=TEX
\ ($auxiliary\_exp$ in the schema below) enclose a Z expression.

Domain conditions for the expressions {\tt prefix} and {\tt index}
are added in {\it SIMPLE\_ASSIGN} by applying {\it add\_domain\_conds}
to this Z expression and so no domain conditions need to be added here.
}\epar

 

=SPCZ  ARRAY_ASSIGN
=TEX




\bpar{
An assignment of the form 
=INLINEFT
prefix.selector := E
=TEX
\ is transformed to
=INLINEFT
prefix := ˚binding˝
=TEX
\ where $binding$ is a Z expression denoting a binding
obtained by updating the $selector$ component to be equal to {\it E}.
I.e., $binding.y$ is to be equal to $prefix.y$ for each component, {\tt y},
of {\tt prefix} other than {\tt selector}; $binding.selector$ is to be equal
to {\it E}.
For example, suppose {\tt prefix} is a record with three components, {\tt a}, {\tt b} and
{\tt c} with {\tt selector} as {\tt b}, then $binding$ must be equal to the binding display{}
=INLINEFT
(a ¶ prefix.a, b ¶ E, c ¶ prefix.c)
=TEX
. However, for records with more than a few components, representing {\tt binding}
as a binding display would be unwieldy.
To avoid this, $binding$ is to be represented using record update functions
that are introduced when the record type declaration is translated into Z.
In the example just given, we represent $binding$ as
$TMARKuB(prefix, E)$ where $TMARK$ is the type mark of the expression $prefix$.
}\epar

\bpar*{
The function call $z\_record\_update(TMARK, B, prefix, E)$ calculates the Z expression
$TMARKuB(prefix, E)$.
}\epar*

=SPCZ  z_record_update
=TEX


\newpage



=SPCZ  RECORD_ASSIGN
=TEX

\subsection{Specification statement (no initial variables)}

\bpar{
There are two cases to consider depending on whether the frame $w$ is empty.
}\epar

\bpar{
Case 1. Non-empty frame. The theoretical treatment of the wp of a specification statement involves a universal quantifier
which prevents the breakdown of the correctness condition into simple VCs.
This problem is solved by outputting a side condition.
A full explanation of side conditions for this and other program constructs later in this document can be found in [5].
}\epar



=SPCZ  SPEC_NO_IVARS
=TEX


\bpar{
Case 2. Empty frame. If the frame is empty then there is no need for a universal quantifier.
Therefore no side condition is needed. 
Note that if the frame is empty then the variables do not change and so represent the same values in both
$pre$ and $post$. $pre$ and $post$ can therefore safely be brought together in the same expression to form
the weakest precondition.
}\epar


=SPCZ  SPEC_NO_IVARS_EMPTY
=TEX


\subsection{Semicolon}

\bpar{

}\epar

=SPCZ  Results
=TEX




=SPCZ  SEMICOLON
=TEX


\subsection{If statement}

\bpar{
$TRUE$ and $FALSE$ model the SPARK Booleans. They are in the extension to the Z toolkit (appendix B of volume 1).
}\epar

=SPCZ  TRUE
=TEX





=SPCZ  IF_THEN_ELSE
=TEX


\subsection{Case statement (no others)}

\bpar{
Defined recursively on the number of arms of the {\tt case} statement.
$CASE\_BASE$ defines the weakest precondition for a {\tt case} statement with one arm.
$CASE\_STEP$ defines the weakest precondition for a {\tt case} statement with more than one arm.
}\epar

\bpar{
The function $trans\_case\_choices$ takes the choices in an arm of a {\tt case} statement, such as
{\tt 3..6 | 8 | 14} and produces the Z expression $3..6 \cup \{8,\ 14\}$.
}\epar

=SPCZ  trans_case_choices
=TEX


\bpar{
Case statement with one arm.
}\epar

=SPCZ  Case_Base
=TEX




=SPCZ  CASE_BASE
=TEX


\bpar{
Case statement with more than one arm.
}\epar

=SPCZ  Case_Step
=TEX
\newpage



=SPCZ  CASE_STEP
=TEX

\subsection{Case statement (with others)}

=SPCZ  CASE_OTHERS
=TEX

\subsection{Undecorated loop}

\bpar{
If the loop does not contain a {\it till} predicate then remove $T \imp A$ from $SIDE$.
}\epar



=SPCZ  LOOP
=TEX


\subsection{While loop}

\bpar{
If the loop does not contain a {\it till} predicate then remove $T \imp A$ from $SIDE$.
}\epar



=SPCZ  WHILE
=TEX


\newpage

\subsection{For loop (static bounds)}

\bpar{
The {\tt for} loop variable does not need to be bound by an existential quantifier
because of the SPARK restriction on the re-declaration of identifiers.
If the loop does not contain a {\it till} predicate then remove $zran \imp (T \imp A)$ from $SIDE$.
}\epar



=SPCZ  FOR_STATIC
=TEX
\newpage

\subsection{For loop (type mark as range)}

\bpar{
If the loop does not contain a {\it till} predicate then remove $T \imp A$ from $SIDE$.
}\epar


=SPCZ  FOR_TMARK
=TEX


\newpage

\subsection{Exit statement (with condition)}

\bpar{

}\epar



=SPCZ  EXIT_WHEN
=TEX


\subsection{Exit statement}

\bpar{

}\epar



=SPCZ  EXIT
=TEX

\newpage

\subsection{Return statement}

\bpar{

}\epar

=SPCZ  PROC_RETURN
=TEX
=SPCZ  FUN_RETURN
=TEX


=SPCZ  RETURN
=TEX

\subsection{Procedure call (no initial variables in spec)}

\bpar{Discussion.\\
The function {\it proc\_call\_spec} is used to replace a procedure
call by a semantically equivalent sequence of statements not involving
a procedure call. The sequence of statements comprises a specification
statement followed by zero or more assignment statements.

The assignment statements generated by {\it proc\_call\_spec}
are used in handling
formal parameters of mode {\tt in out} or {\tt out} for which
the actual parameter is an expression involving indexed components
and/or selected components).
For each such parameter, {\it proc\_call\_spec} generates a new
Z variable name, uses this variable to represent the new value of
the expression in the post-condition of the specification statement and
generates an assignment statement assigning the value
of the variable to the expression.


The names of the new Z variables generated by {\it proc\_call\_spec}
must be outside the range of the function {\it trans\_id}.
The new Z variables must also be distinct from any logical constants or auxiliary
variables that are in scope and must not appear free
in the set of sequents whose weakest pre-condition is being calculated.


Since it has to translate the SPARK expressions giving the actual
parameters into Z, {\it proc\_call\_spec} also produces a set
of predicates giving the domain conditions for these expressions.



For each new Z variable, $v$, {\it proc\_call\_spec} includes
with the domain conditions a Z predicate
of the form, $v \in T$, where $T$ is the type of the corresponding formal
parameter. These predicates are included in the hypotheses of
the weakest pre-condition and are used in adding local declarations
for the new Z variables to the final VCs.



}\epar

=SPCZ  proc_call_spec
=TEX

\bpar*{
For example, consider the formal procedures:

\vertbarfalse
=GFT
	procedure PLUS_TEN (X: in INTEGER; Y : out INTEGER)
	Ñ Y [ X > 2, Y = X + 10 ]

	procedure INCR_COPY (X : in out INTEGER; Y : out INTEGER)
	Ñ X, Y [ X > 2, X = Xâ0 + 1 ± Y = Xâ0 ]
=TEX
\vertbartrue
{\raggedright
With the first formal procedure in scope,
{\it proc\_call\_spec} applied to the procedure call {\tt PLUS\_TEN(A(1), B)}
will yield the specification statement
=INLINEFT
Ñ B [A 1 > 2, B = A 1 + 10]
=TEX
, together with a null statement and a set of predicates giving
the domain conditions for the actual parameters.

With the second formal procedure in scope,
when applied to the procedure call {\tt INCR\_COPY(A(1), C(2))}, 
{\it proc\_call\_spec} will yield a specification statement of the form
=INLINEFT
ÑA, A[A 1 > 2, ¡ = Aâ0 1 + 1 ± ¬ = Aâ0 1]
=TEX
, together with the sequence of assignment statements
{\tt A(1) :=}
=INLINEFT
˚¡˝
=TEX
{\tt ; C(2) :=}
=INLINEFT
˚¬˝
=TEX
\ and the set of predicates comprising the domain conditions for
the actual parameters together with the predicates
=INLINEFT
¡ ç INTEGER
=TEX
\ and
=INLINEFT
¬ ç INTEGER
=TEX
.
Here ¡ and ¬ stand for the new Z variables that have been generated.

} % end of \raggedright

}\epar*

\bpar*{When an object whose type is a subtype of an unconstrained array type
is passed as an actual parameter to a procedure, the array object
may be subject to a sliding conversion that effectively renumbers the range of the array.
The function {\it proc\_call\_range\_checks} generates sequents which are
used as VCs to ensure that this conversion is compatible with the semantics
of the Z translation of the object.
These VCs have the form {\it dom p = r}, where {\it p} is the actual
parameter and {\it r} is the range of the formal parameter.}\epar*

=SPCZ proc_call_range_checks
=TEX

\newpage
\bpar{Formal Specification.
}\epar

=SPCZ  PROC_CALL_NO_IVARS
=TEX

\subsection{Specification statement (with initial variables)}

\bpar{

}\epar



=SPCZ  SPEC_IVARS
=TEX

\newpage
\subsection{For loop (non-static bounds)}

\bpar{
If the loop does not contain a {\it till} predicate then remove $zran \imp (T \imp WP_1)$ from $SIDE$.
}\epar

=SPCZ  FOR_NON_STATIC
=TEX

\subsection{Logical constant}

\bpar{

}\epar



=SPCZ  z_log_con_def
=TEX

\newpage


=SPCZ  LOG_CON
=TEX


\subsection{Procedure call (initial variables in spec)}

\bpar{

}\epar

=SPCZ  PROC_CALL_IVARS
=TEX

\newpage

\bpar{
Predicate stating that the above schemas define the function $wp$.
}\epar


{\def\PrNL#1\PrNN{\relax}
=SPCZ  wpconstraint
=TEX
}




\section{Verification condition generation}

\subsection{The function vcs}

\bpar{
The VC generation algorithm is called with a $Speclab$ (below) and a sequence of statements.
The $Speclab$ contains all the information the algorithm needs. The sequence of statements
refines the $Spec$.
}\epar

\bpar{
If VCs are required, a {\tt return} statement can only be introduced inside a {\it formal} function
(that is a function with a specification statement).
The restrictions of SPARK only ensure a {\tt return} statement is introduced inside a {\it function}
(formal or informal). For this reason $formal\_body\_flag$ is required.
If the sequence of statements contains a {\tt return} statement then $formal\_body\_flag$ must be $True$.
Also for refinements inside a formal function body
$fun\_header$ (inside $Wp\_Env$) is used to put a local declaration of the function in the VCs;
so that the Z
axiomatic description of the function can {\it not} be used, since it is not valid when {\it proving}
a function body satisfies its specification to {\it assume} that it does.
If $formal\_body\_flag$ and $fun\_flag$ ($fun\_flag$ is set to $True$ when a function is encountered, formal or informal)
are $True$ then a local declaration of the function is added to the VCs.
}\epar

\bpar*{
$till\_flag$ is needed
to ensure that an {\tt exit} statement with no loop name is only introduced (if VCs are required) inside a loop with a
{\it till} annotation. Ada compilation will only guard against an {\tt exit} statement being introduced {\it outside}
a loop. If the sequence of statements contains an {\tt exit} statement then $till\_flag$ must be $True$.
}\epar*

=SPCZ  FLAG
=TEX


\bpar{
$In\_Scope$ contains all the variables, formal parameters, logical constants, auxiliary variables and formal procedures
that are in scope.
The variables, formal parameters, logical constants and auxiliary variables are needed for the
local declarations of the VCs (used by the function $vc\_local\_decls$ below).
}\epar

\bpar*{
$LABEL$ denotes the labels that may appear in a literate script (labels of both k\_slots and specification statements).
}\epar*

=SPCZ  LABEL
=TEX

=SPCZ  In_Scope
=TEX


\bpar{
The definition of $Speclab$.
}\epar

=SPCZ  Speclab
=TEX

\bpar{
The following function $vc\_local\_decls$
adds local declarations to a sequent. For every element in $vc\_vars$ add both the variable
and its corresponding initial variable (subscript with 0). Do the same for every element of $vc\_pars$
unless the mode is $in$ in which case just add the parameter (no initial version).
Add the logical constants (no initial versions) and the auxiliary variables (both the variable and its
initial version).
If $formal\_body\_flag$ and $fun\_flag$ are $True$ add a declaration of the function (obtained from $fun\_header$).
For each hypothesis of a sequent having the form
=INLINEFT
¡ ç T
=TEX
\ where the variable ¡ is one of the new Z variables introduced
during the weakest precondition
calculation for procedure calls,
remove the hypothesis from the sequent and add a declaration
for ¡.
Finally remove any declarations which are not needed by the sequent and then type-check the
resulting VC. Note that, apart from logical constants and auxiliary variables, the declarations need translating to Z.
}\epar

=SPCZ  vc_local_decls
=TEX


\bpar{
Finally the definition of the function $vcs$ which generates the VCs for a refinement step.
}\epar

=SPCZ  vcs
=TEX


\subsection{Aliasing}

\bpar{
When calling the function $vcs$ the four anti-aliasing rules below must be obeyed
for every procedure call in the sequence of statements $st$.
The rules are required to avoid corrupting the VCs.
The rules below are given in terms of the procedure call $Proc\_Call$
and the corresponding $Formal\_Proc$ of the procedure (its Ada procedure specification
together with its specification statement).
The $Formal\_Proc$ will be available in the $Speclab$ argument of the function $vcs$.
The anti-aliasing rules are based on SPARK course notes (1990) and not those in the SPARK manual.
}\epar

\bpar*{
The following function $free\_vars\_zpred$ finds the free Z variables in a Z predicate.
For an initial variable such as $A_0$ record $A$.
For example $free\_vars\_zpred$ applied to $Y = B_0(X) + 7 \land A.Z = 1$ yields $ \{Y, B, X, A\}$. 
}\epar*

=SPCZ  free_vars_zpred
=TEX


=SPCZ  Anti_Aliasing_Pars
=TEX

\bpar*{

The anti-aliasing rules involve the notion of an {\it entire variable}.
The entire variable of an expression is the variable that would be
changed if that expression appeared on the left-hand side of an assignment
statement.

The function {\it entire\_var\_exp} finds the entire variable of an expression.
For example, {\it entire\_var\_exp} applied to {\tt A} yields
{\tt A} and {\it entire\_var\_exp} applied to {\tt B(I).date}
yields {\tt B}.
Expressions  such as {\tt 1 + 2} that do not denote a variable or a component
of a variable are not in the domain of {\it entire\_var\_exp}.
Ada type-checking and other
SPARK rules ensure that actual parameters of mode {\tt in out} or {\tt out}
will be in the domain of {\it entire\_var\_exp}.

=SPCZ  entire_var_exp
=TEX

The function {\it other\_vars\_exp}
gives the set of variables in a SPARK expression appearing in positions other than
that of its entire variable.
For an expression with no entire variable, {\it other\_vars\_exp},
finds the set of all variables in the expression.
For example {\it other\_vars\_exp} applied to 
the expressions {\tt M+1}, {\tt A(B**2 + C.X)}
and {\tt A(B**2 + A(I) + C.X)} yields the sets
\{{\tt M}\}, \{{\tt B, C}\} and \{{\tt A, B, C}\} respectively.

=SPCZ  other_vars_exp
=TEX


The function {\it vars\_exp} returns the set of
all variables that appear in an expression, e.g., it yields \{{\tt A, B, C}\} when applied to either
of the expressions {\tt A(B**2 + C.X)} 
or {\tt A(B**2 + A(I) + C.X)}.

=SPCZ  vars_exp
=TEX

}\epar*

\bpar{
The first rule states that a variable that may be read by
the procedure and is not a formal parameter must not occur
as the entire variable in an actual parameter where the corresponding
formal parameter has mode {\tt in out} or {\tt out}.
}\epar

=SPCZ  Anti_Aliasing_Check_1
=TEX

\bpar{
The second rule states that
a variable that appears in the frame, {\tt w}, of the procedure and is not
a formal parameter must not appear anywhere in the actual parameter list.
}\epar

=SPCZ  Anti_Aliasing_Check_2
=TEX

\bpar{
The third rule states that if a variable occurs as the entire
variable in an actual parameter of mode {\tt in out} or {\tt out} then the
variable must not appear anywhere else in that same actual
parameter or anywhere else in the parameter list.
}\epar


=SPCZ  Anti_Aliasing_Check_3
=TEX


=SPCZ  Anti_Aliasing_Check
=TEX


\subsection{Variable capture}

\bpar{
The VCs can also be corrupted due to variable capture, that is when an
identifier is re-declared at a point where an identifier of the same name is
already visible.
In the compliance notation there are two types of identifier;
SPARK identifiers and Z identifiers.  
A lot of cases of variable capture will be caught by the SPARK restriction
that an identifier can not be re-declared at a point where
the same identifier is already visible.
}\epar

\bpar{
However this still leaves the problem of two Z identifiers clashing and
a Z identifier clashing with a SPARK identifier.
In fact, the above SPARK restriction does not totally eliminate the problem
just with SPARK identifiers. This is because two SPARK identifiers could
be translated to the same Z identifier when forming the VCs
(with a certain implementations of $trans\_id$ in the 
compliance notation specification).
The check for re-declaration in the compliance notation
must therefore be made on the Z identifiers since it is the Z VCs that could
be corrupted.  
}\epar

\bpar{
For example consider a package {\tt PACK}
whose specification contains a SPARK declaration {\tt I : INTEGER}.
Consider also a procedure {\tt MAIN} which utilises {\tt PACK}.
{\tt I} is made available to {\tt MAIN} as {\tt PACK.I}
(prefixed with the name of the package).
Now suppose the decision has been taken to translate {\tt PACK.I} to Z
as $PACK\_DOT\_I$ (possible implementation of $trans\_id$ - other working
papers use the translation $PACK\_\_\_I$) then a SPARK declaration
{\tt PACK\_DOT\_I : INTEGER} in procedure {\tt MAIN} would cause variable
capture.
}\epar

\bpar{
A similar problem could occur with the translation of SPARK attributes,
e.g., {\tt SUB'FIRST}. However, a sensible choice of how to translate
the SPARK dot (package selection) and SPARK apostrophe (attributes)
will solve this particular problem; for example translating SPARK
identifiers to upper case identifiers in Z and using lower case identifiers
to translate SPARK dot and apostrophe.
}\epar

\bpar{
The Z identifiers that can cause variable capture are logical constants
and auxiliary variables.
In order to check for variable capture with logical constants their
scoping rules need to be known and they are as follows.
A logical constant is introduced with a specification statement
(see compliance notation syntax - appendix A of volume 1).
The logical constant is visible to that specification statement and its
subsequent refinements/expansions.
Thus a logical constant is similar to a local block in Ada.
}\epar

\bpar{
From a variable capture point of view (as oppose to a refinement point of view
- see below) the scoping rules for
auxiliary variables are the same as for ordinary SPARK variables.
An auxiliary variable such as $A$ is
declared in a package specification and is visible in the corresponding
package body. It is visible outside
the package by prefixing with the name of the
package (say as $PACK\_DOT\_A$).
(The scoping rule for auxiliary variables from a
variable capture point of view is slightly different to the scoping rule
from a refinement point of view
- in refinement the auxiliary variable is not made
visible to the package body thus demanding that data refinement
has occurred at the point the package body is declared.
The scoping rules for refinement are embodied in the environments
and SID functions of the compliance notation specification.
Variable capture checks therefore require different information to that
present in the environments.)
}\epar

\bpar{
The check for variable capture can be formalised as follows.
At any point $ID\_ENV$ contains the identifiers in scope.
$spark\_ids$ are the SPARK identifiers, $z\_log\_aux$ are the logical
constants and auxiliary variables and $z\_attribs$ are the Z names of the
attributes generated from a SPARK type or subtype declaration
(they appear in the Z document as $zname == ...$).
}\epar

=SPCZ  ID_ENV
=TEX


\bpar{
At the point a new identifier is declared the identifier
(including its attributes if a SPARK type or subtype declaration)
must not clash with the
SPARK identifiers, logical constants, auxiliary variables and
attributes that are in scope.
}\epar 

=SPCZ  New_Spark_Id
=TEX

=SPCZ  New_Z_Id
=TEX



\nocite{DRA/CIS/CSE3/SWI/WP/7/2}		% was {example}
\nocite{Sennett92a}			% was {notation}
\nocite{DRA/CIS/CSE3/SWI/1}		% was {aux}
\nocite{Foster68}				% was {sid}
\nocite{DRA/CIS(SE2)/PROJ/SWI/TR/1/1.0}	% was {user}
\nocite{zstan26}				% was {zstandard}

\bibliographystyle{fmu}
\bibliography{daz,fmu}


\begin{tabular}{ll}
\multicolumn{2}{l}{The Draft Z Standard \cite{zstan26} is available via the Internet from:}\\
			&	{\tt http://www-users.cs.york.ac.uk/~ian/zstan/}\\
\hbox to 2.5cm{\hfill or\hfill}	&	{\tt ftp://ftp.cs.york.ac.uk/hise\_reports/cadiz/ZSTAN/}
\end{tabular}

\startpost



\small
\twocolumn[\section*{Index of identifiers}]
\printindex

\onecolumn

\thispagestyle{dera}

\end{document}
=WARNING_EDIT_WITH_CARE spc502.src
