%  dtd509.doc %Z% $Date: 2001/05/29 13:45:16 $ $Revision: 1.37 $ $RCSfile: dtd509.doc,v $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999

\def\DRASpecs{\cite{DRA/CIS/CSE3/TR/94/27/3.0}}
\def\Volume#1{\cite[volume #1]{DRA/CIS/CSE3/TR/94/27/3.0}\/}
\def\VolumeOne{\Volume 1}
\def\VolumeTwo{\Volume 2}
\def\VolumeThree{\Volume 3}

\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Z Toolkit Extensions}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD509}  %% Mandatory field
\def\SCCSversion{$Revision: 1.37 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2001/05/29 13:45:16 $%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{SPARK}
\TPPauthors{D.J.~King&WIN01\\R.D.~Arthan&WIN01}
\TPPauthorisation{R.D.~Arthan & DAZ Team}
\TPPabstract{
This document defines a theory containing the extensions to the Z toolkit required for the DAZ Compliance Tool.
It also defines theorems and proof procedures to assist in reasoning about the objects defined in the theory.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DRA \\
	Library}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.6] Initial Drafts.
\item[Issue 1.7] Carried out rework according to desk check report 011.
\item[Issue 1.8] Added statement that there is no corresponding implementation document for this design.
\item[Issues 1.9] Theorems added; definition of $rem$ etc. revised.
\item[Issue 1.10] Proof context and signatures of proof procedures added.
\item[Issue 1.11] Responded to comments.
\item[Issue 1.12] Corrections after module testing the implementation.
\item[Issue 1.13] Amendments after further review.
\item[Issue 1.14] Updated document references.
\item[Issue 1.15] Updates for enhancements contract (enhancement no. 4).
\item[Issue 1.16] Corrected indexing of new definitions.
\item[Issue 1.17] Removed $DummyVC$ --- a variable can be used instead where this is needed.
\item[Issue 1.18] Updated document references.
\item[Issue 1.19] Fixed omissions which caused bug 13 (V0.6).
\item[Issue 1.20] Added theorems for reasoning about $intdiv$, $intmod$ and $rem$.
\item[Issue 1.21] Added variants to cn proof context.
\item[Issue 1.22] Added further results about $Boolean$.
\item[Issue 1.23] Improved proof context $cn1$.
\item[Issue 1.24] Removed $cn1$ and renamed and exposed a useful theorem.
\item[Issue 1.25] Added $z\_succçnê\_»\_thm$.
\item[Issue 1.26] Added $z\_size\_dot\_dot\_conv$ to $cn1$.
\item[Issue 1.27] Changes for IUCT WP 4.
\item[Issue 1.28] Adding indexing characters.
\item[Issue 1.29] Updated references to the DERA specifications.
\item[Issue 1.30] CTLE II R1/4: support for logical operators on boolean arrays.
\item[Issue 1.31] CTLE II R1/8: characters and strings.
\item[Issues 1.32,1.33] CTLE II R1/1: real types (interim solution with Z reals declared here).
\item[Issues 1.34,1.35] CTLE II R1/1: real types (using the official Z reals).
\item[Issues 1.36] Fixed typo in theory checking.
\item[Issue 1.37] R0021: new treatment of AND THEN and OR ELSE.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document responds to a requirement for a design of toolkit extensions in Z in \cite{ISS/HAT/DAZ/HLD503}. The specification of the toolkit extensions is provided in {\VolumeOne}.
The document also responds to the requirement for tools supporting proof of propositions expressed using the toolkit extensions also expressed in \cite{ISS/HAT/DAZ/HLD503}.

\subsection{Introduction}

\subsubsection{Purpose and Background}

This document provides the Z toolkit extensions required for the Compliance Tool and specified in {\VolumeOne}.
The toolkit extensions are implemented as a {\ProductZ} specification.

It also specifies the basic proof support tools for the toolkit extensions.
These tools comprise theorems, conversions and a proof context and are defined here in the same style as is used for {\Product} proof facilities.

In more detail, the structure of this document is as follows:

\begin{description}
\item[Section \ref{DESIGNISSUES}] discusses design issues and decisions which have been taken here;
\item[Section \ref{SPARKTOOLKIT}] gives the toolkit extensions as defined in {\VolumeOne};
\item[Section \ref{OTHERZDEFINITIONS}] contains some additional Z definitions which support the operation of the Compliance Tool;
\item[Section \ref{THESTRUCTURE}] defines the ML structure which gives the interface for the theorems, proof procedures etc. provided.
\end{description}

\subsubsection{Compliance}

The function $abs$ specified in {\VolumeOne} is not provided here because the {\ProductZ} toolkit already supplies an appropriate implementation.

The Z name for an attribute in {\VolumeOne} is denoted by a pair of underscore characters. {\Product-Z}'s lexical rules does not permit this. A lowercase ``v'' is used to denote an attribute instead.

\subsubsection{Dependencies}
The theory defined in this document is a child of the theory $z\_library$ defined in {\Product}.
The document is therefore dependent on {\Product} but not on any module of the Compliance Tool.
%\subsubsection{Possible Enhancements}

\section{DESIGN ISSUES}\label{DESIGNISSUES}

\subsection{Theory Hierarchy}
The theory created by this document is called ``$cn$''.
Its parent is the theory ``$z\_library$'' which gives access to the Z toolkit as provided in {\Product}.
When the compliance tool is invoked, the current theory should be ``$cn$'', and the function which introduces a new literate script should arrange for this.

\subsection{Proof Facilities}
The proof facilities follow a pattern which is common in {\Product}.
First of all, in section \ref{Theorems}, theorems are presented which allow basic semi-automatic reasoning about the objects defined in a theory.

Secondly, in section \ref{ProofProcedures}, proof procedures which cannot be captured as theorems are given as derived inference rules, typically conversions (i.e. proof rules which support equational reasoning by taking a term $tm$ as argument and proving a theorem of the form
=INLINEFT
ô tm = tm'
=TEX
.
E.g., the theorem schemata corresponding to the evaluation of expressions with constant operands are given as conversions which prove theorems such as
=INLINEFT
ô 12 intdiv 5 = 2
=TEX
.

Finally, in section \ref{ProofContexts} the more generally applicable theorems and proof procedures are packaged together in one or more proof contexts which make it convenient for a user to access a general purpose collection of simplifications customised for the theory.
These proof contexts typically come in two flavours: component proof contexts containing only the simplifications for this theory for use in combination with other proof contexts; and complete proof contexts which contain a comprehensive collection of simplifications for the theory and its ancestors.

=TEX
\newpage

=TEX
\pagebreak
\section{SPARK TOOLKIT}\label{SPARKTOOLKIT}
Sections \ref{Booleans} to \ref{CharactersandStrings} give the {\ProductZ} analogues of the toolkit extensions essentially as defined by DRA in {\VolumeOne}.
Any disparities with the DRA are discussed in the accompanying narrative.

\subsection{Preamble}

The following preamble creates the theory ``cn'' as a child of ``z\_library''
and makes the theory ``z\_reals'' a parent.

=SML
force_delete_theory"cn" handle Fail _ => ();
open_theory"z_library";
push_pc "z_library";
val _ = set_flag ("z_type_check_only", false);
val _ = set_flag ("z_use_axioms", true);
new_theory"cn";
new_parent"z_reals";
=TEX

The following paragraphs are required by {\Product} to determine the fixity of some of the names defined in the toolkit extensions.

¹Z
fun  not _
°

¹Z
fun  array_not _
°

¹Z
fun  char_lit _, string_lit _
°

¹Z
fun 0 _ and _, _ or _, _ xor _
°

¹Z
fun 0 _ and_then _, _ or_else _
°

¹Z
fun 0 _ array_and _, _ array_or _, _ array_xor _
°

¹Z
fun 1 _ mem _, _ notmem _, _ eq _, _ noteq _
°

¹Z
fun 2 _ less _, _ less_eq _, _ greater _, _ greater_eq _
°

¹Z
fun 2 _ real_less _, _ real_less_eq _, _ real_greater _, _ real_greater_eq _
°

¹Z
fun 2 _ array_less _, _ array_less_eq _, _ array_greater _, _ array_greater_eq _
°

¹Z
fun 3 _ &‰0 _, _ &‰1 _, _ &‰2 _
°

¹Z
fun 4 _ intdiv _, _ rem _, _ intmod _
°

¹Z
fun 5 _ ** _
°

¹Z
fun 7 _ e _
°

\subsection{Booleans}\label{Booleans}

¹Z
ÛFALSEİ ¦ 0
°

¹Z
ÛTRUEİ ¦ 1
°

¹Z
ÛBOOLEANİ ¦ FALSE..TRUE
°

¹Z
ÛBOOLEANvFIRSTİ ¦ FALSE
°

¹Z
ÛBOOLEANvLASTİ ¦ TRUE
°

¹Z
ÛBOOLEANvSUCCİ ¦ (BOOLEAN \ {BOOLEANvLAST}) ò succ
°

¹Z
ÛBOOLEANvPREDİ ¦ BOOLEANvSUCCç~ê
°

¹Z
ÛBOOLEANvPOSİ ¦ id BOOLEAN
°

¹Z
ÛBOOLEANvVALİ ¦ BOOLEANvPOSç~ê
°

\subsection{Boolean Operators}

¹ZAX
Ü Ûnotİ _ : BOOLEAN ­ BOOLEAN;
Ü _ Ûandİ _, _ Ûorİ _, _ Ûxorİ _ : (BOOLEAN ¸ BOOLEAN) ­ BOOLEAN
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ b : BOOLEAN ·
Ü	not FALSE = TRUE ± not TRUE = FALSE ±
Ü	(b and FALSE = FALSE ± b and TRUE = b) ±
Ü	(b or FALSE = b ± b or TRUE = TRUE) ±
Ü	(b xor FALSE = b ± b xor TRUE = not b)
°
¹ZAX
Ü _ Ûand_thenİ _, _ Ûor_elseİ _: (BOOLEAN ¸ BOOLEAN) ­ BOOLEAN
÷üüüüüüüüüüüüüüüüüüüüü
Ü (_ and_then _) = (_ and _) ± (_ or_else _) = (_ or _)
°


\subsection{Relational Operators returning Booleans}

[X]œœœœœœœœœœœœœœœœ
Ü _ Ûmemİ _, _ Ûnotmemİ _ : (X ¸ ğ X) ­ BOOLEAN;
Ü _ Ûeqİ _, _ Ûnoteqİ _ : (X ¸ X) ­ BOOLEAN
÷üüüüüüüüüüüüüüüüüü
Ü µ x, y : X; S : ğ X; b : BOOLEAN ·
Ü	(b = x mem S ¤ (b = TRUE ¤ x  S)) ±
Ü	(b = x notmem S ¤ (b = TRUE ¤ x  S)) ±
Ü	(b = x eq y ¤ (b = TRUE ¤ x = y)) ±
Ü	(b = x noteq y ¤ (b = TRUE ¤ x ½ y))
ˆüüüüüüüüüüüüüüüüüüüü

[X]œœœœœœœœœœœœœœœœ
Ü Ûarray_notİ _ : (X ß BOOLEAN) ­ (X ß BOOLEAN);
Ü _ Ûarray_andİ _,
Ü _ Ûarray_orİ _,
Ü _ Ûarray_xorİ _ : ((X ß BOOLEAN) ¸ (X ß BOOLEAN)) ­ (X ß BOOLEAN)
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ a, b : X ß BOOLEAN ·
Ü	array_not a = (Ìi : dom a· not (a i)) ±
Ü	a array_and b = (Ìi : dom a ¡ dom b· a i and b i) ±
Ü	a array_or b = (Ìi : dom a ¡ dom b· a i or b i) ±
Ü	a array_xor b = (Ìi : dom a ¡ dom b· a i xor b i)
ˆüüüüüüüüüüüüüüüüüüüü

¹ZAX
Ü _ Ûlessİ _, _ Ûless_eqİ _, _ Ûgreaterİ _,
Ü _ Ûgreater_eqİ _ : (ú ¸ ú) ­ BOOLEAN
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ x, y : ú; b : BOOLEAN ·
Ü	(b = x less y ¤ (b = TRUE ¤ x < y)) ±
Ü	(b = x less_eq y ¤ (b = TRUE ¤ x ¼ y)) ±
Ü	(b = x greater y ¤ (b = TRUE ¤ x > y)) ±
Ü	(b = x greater_eq y ¤ (b = TRUE ¤ x ¾ y))
°
¹ZAX
Ü _ Ûreal_lessİ _, _ Ûreal_less_eqİ _, _ Ûreal_greaterİ _,
Ü _ Ûreal_greater_eqİ _ : (¯ ¸ ¯) ­ BOOLEAN
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ x, y : ¯; b : BOOLEAN ·
Ü	(b = x real_less y ¤ (b = TRUE ¤ x <‰R y)) ±
Ü	(b = x real_less_eq y ¤ (b = TRUE ¤ x ¼‰R y)) ±
Ü	(b = x real_greater y ¤ (b = TRUE ¤ x >‰R y)) ±
Ü	(b = x real_greater_eq y ¤ (b = TRUE ¤ x ¾‰R y))
°


¹ZAX
Ü _ Ûarray_lessİ _,
Ü _ Ûarray_less_eqİ _,
Ü _ Ûarray_greaterİ _,
Ü _ Ûarray_greater_eqİ _ : ((ú ß ú) ¸ (ú ß ú)) ­ BOOLEAN
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ a, b : ú ß ú ·
Ü	(a array_less b = TRUE ¤
Ü	(¶i, j, k : ú·
Ü		{i, j} € dom b ± i - 1  dom b ± i + k - 1  dom a 
Ü	±	(µt : i .. j - 1· t + k  dom a ± b t = a(t + k))
Ü	±	j + k  dom a ´ a(j + k) < b j)) ±
Ü	a array_less_eq b = a array_less b or a eq b ±
Ü	a array_greater b = b array_less a ±
Ü	a array_greater_eq b = b array_less_eq a
°

\subsection{Numeric Operators}
The definitions of division etc. in {\VolumeOne} rely on the definitions of the analogous operations for Z in \cite{Spivey92}.
This part of the Z toolkit is in a state of flux in the standardisation activity and the {\ProductZ} toolkit differs from \cite{Spivey92}.
The following formulation defines division, remainder and modulo for SPARK using only Z division with non-negative operands.
It should therefore be independent of the final choice made in the Z standards work.
¹ZAX
Ü _ Ûintdivİ _, _ Ûremİ _, _Ûintmodİ_ : (ú ¸ ú \ {0}) ­ ú
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ x, y : ú | y ½ 0 ·
Ü	(x*y ¾ 0 ´ x intdiv y = abs x div abs y )
Ü±	(x*y < 0 ´ x intdiv y = ~(abs x div abs y))
Ü±	x rem y = x - (x intdiv y) * y 
Ü±	(x*y ¾ 0 ² x rem y = 0 ´ x intmod y = x rem y )
Ü±	(x*y < 0 ± x rem y ½ 0 ´ x intmod y = x rem y + y)
°
That the above definition agree with the Ada definitions is supported by
the result of a simple experiment with {\Product}.
The following list of theorems has been derived from the above definition and corresponds to parts of the table in section 4.5.5 of the Ada LRM.
=GFT ProofPower Output
val it = [ô (10 intdiv 5, 10 rem 5, 10 intmod 5) = (2, 0, 0),
   ô (12 intdiv 5, 12 rem 5, 12 intmod 5) = (2, 2, 2),
   ô (14 intdiv 5, 14 rem 5, 14 intmod 5) = (2, 4, 4),
   ô (10 intdiv ~ 5, 10 rem ~ 5, 10 intmod ~ 5) = (~ 2, 0, 0),
   ô (12 intdiv ~ 5, 12 rem ~ 5, 12 intmod ~ 5) = (~ 2, 2, ~ 3),
   ô (14 intdiv ~ 5, 14 rem ~ 5, 14 intmod ~ 5) = (~ 2, 4, ~ 1),
   ô (~ 10 intdiv 5, ~ 10 rem 5, ~ 10 intmod 5) = (~ 2, 0, 0),
   ô (~ 12 intdiv 5, ~ 12 rem 5, ~ 12 intmod 5) = (~ 2, ~ 2, 3),
   ô (~ 14 intdiv 5, ~ 14 rem 5, ~ 14 intmod 5) = (~ 2, ~ 4, 1),
   ô (~ 10 intdiv ~ 5, ~ 10 rem ~ 5, ~ 10 intmod ~ 5) = (2, 0, 0),
   ô (~ 12 intdiv ~ 5, ~ 12 rem ~ 5, ~ 12 intmod ~ 5) = (2, ~ 2, ~ 2),
   ô (~ 14 intdiv ~ 5, ~ 14 rem ~ 5, ~ 14 intmod ~ 5) = (2, ~ 4, ~ 4)] : THM list
¹ZAX
Ü _ Û**İ _ : (ú ¸ î) ­ ú
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ x : ú; y : î · x ** 0 = 1 ± x ** (y + 1) = x * x ** y
°

¹ZAX
Ü _ Ûeİ _ : ú ¸ ú ­ ¯
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ x, y : ú · x e y = real x *‰R (real 10 ^‰Z y)
°
¹ZAX
Ü Ûinteger_to_realİ: ú ­ ¯
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ i : ú · integer_to_real i = real i
°
¹ZAX
Ü Ûreal_to_integerİ : ¯ ­ ú
°

The $abs$ function is already provided in the {\ProductZ} mathematical toolkit and therefore does not need to be defined here.

\subsection{Integers}\label{Integers}

¹ZAX
Ü ÛINTEGERİ : ğ ú
°
¹ZAX
Ü ÛINTEGERvFIRSTİ, ÛINTEGERvLASTİ : ú ;
Ü ÛINTEGERvSUCCİ, ÛINTEGERvPREDİ, ÛINTEGERvPOSİ, ÛINTEGERvVALİ : ú ß ú
°
\subsection{Natural Numbers}\label{NaturalNumbers}
¹Z
Ü ÛNATURALİ ¦ 0 .. INTEGERvLAST
°
¹Z
Ü ÛNATURALvFIRSTİ ¦ 0
°
¹Z
Ü ÛNATURALvLASTİ ¦ INTEGERvLAST
°
¹Z
Ü ÛNATURALvSUCCİ ¦ INTEGERvSUCC
°
¹Z
Ü ÛNATURALvPREDİ ¦ INTEGERvPRED
°
¹Z
Ü ÛNATURALvPOSİ ¦ INTEGERvPOS
°
¹Z
Ü ÛNATURALvVALİ ¦ INTEGERvVAL
°

\subsection{Positive Numbers}\label{PositiveNumbers}
¹Z
Ü ÛPOSITIVEİ ¦ 1 .. INTEGERvLAST
°
¹Z
Ü ÛPOSITIVEvFIRSTİ ¦ 1
°
¹Z
Ü ÛPOSITIVEvLASTİ ¦ INTEGERvLAST
°
¹Z
Ü ÛPOSITIVEvSUCCİ ¦ INTEGERvSUCC
°
¹Z
Ü ÛPOSITIVEvPREDİ ¦ INTEGERvPRED
°
¹Z
Ü ÛPOSITIVEvPOSİ ¦ INTEGERvPOS
°
¹Z
Ü ÛPOSITIVEvVALİ ¦ INTEGERvVAL
°
\subsection{Long Integers}\label{LongIntegers}

¹ZAX
Ü ÛLONG_INTEGERİ : ğ ú
°
¹ZAX
Ü ÛLONG_INTEGERvFIRSTİ, ÛLONG_INTEGERvLASTİ : ú ;
Ü ÛLONG_INTEGERvSUCCİ, ÛLONG_INTEGERvPREDİ,
Ü ÛLONG_INTEGERvPOSİ,  ÛLONG_INTEGERvVALİ : ú ß ú
°
\subsection{Short Integers}\label{ShortIntegers}

¹ZAX
Ü ÛSHORT_INTEGERİ : ğ ú
°
¹ZAX
Ü ÛSHORT_INTEGERvFIRSTİ, ÛSHORT_INTEGERvLASTİ : ú ;
Ü ÛSHORT_INTEGERvSUCCİ, ÛSHORT_INTEGERvPREDİ,
Ü ÛSHORT_INTEGERvPOSİ, ÛSHORT_INTEGERvVALİ : ú ß ú
°
\subsection{Float}\label{Float}

¹ZAX
Ü ÛFLOATİ : ğ ¯
°
¹ZAX
Ü ÛFLOATvFIRSTİ, ÛFLOATvLASTİ : ¯ ;
Ü ÛFLOATvDIGITSİ : ú
°
\subsection{Short Float}\label{ShortFloat}

¹ZAX
Ü ÛSHORT_FLOATİ : ğ ¯
°
¹ZAX
Ü ÛSHORT_FLOATvFIRSTİ, ÛSHORT_FLOATvLASTİ : ¯ ;
Ü ÛSHORT_FLOATvDIGITSİ : ú
°
\subsection{Long Float}\label{LongFloat}

¹ZAX
Ü ÛLONG_FLOATİ : ğ ¯
°
¹ZAX
Ü ÛLONG_FLOATvFIRSTİ, ÛLONG_FLOATvLASTİ : ¯ ;
Ü ÛLONG_FLOATvDIGITSİ : ú
°

\subsection{Characters and Strings}\label{CharactersandStrings}
¹Z
Ü CHARACTERvFIRST ¦ 0
°
¹ZAX
Ü CHARACTERvLAST : ú
÷üüüüüü
Ü CHARACTERvLAST ¾ 127
°
¹Z
Ü CHARACTER ¦ CHARACTERvFIRST .. CHARACTERvLAST
°
¹Z
Ü CHARACTERvSUCC ¦ (CHARACTER \ {CHARACTERvLAST}) ò succ
°
¹Z
Ü CHARACTERvPRED ¦ CHARACTERvSUCCç~ê
°
¹Z
Ü CHARACTERvPOS ¦ id CHARACTER
°
¹Z
Ü CHARACTERvVAL ¦ CHARACTERvPOSç~ê
°

¹ZAX
Ü ÛSTRINGİ : ğ (POSITIVE ß CHARACTER)
°
¹Z
Ü ÛZ_CHARİ ¦ seq CHAR
°
¹Z
Ü ÛZ_STRINGİ ¦ seq CHAR
°
We have to resort to a HOL quotation to define a function
to return the integer code for a character. This should
perhaps be included as part of {\ProductZ}.


=SML
set_flag("standard_z_paras", false);
¹ZAX
Ü Ûdest_charİ : CHAR ­ ú
÷üüüüüü
Ü µch : CHAR· dest_char ch = ¬îú (RepChar ch)®
°
=SML
reset_flag("standard_z_paras");
=TEX
A string is then obtained by mapping {\it dest\_char} over the characters
of the string. Since the string is a Z sequence, mapping a function over
it amounts to functional composition of the function with the string.
¹ZAX
Ü Ûstring_litİ_ : Z_STRING ­ seq CHARACTER
÷üüüüüü
Ü µstr : Z_STRING· string_lit str = dest_char o str
°
And then a character code is obtained from a singleton
string by taking the head of the sequence obtained from {\it string\_lit}.

¹ZAX
Ü Ûchar_litİ_ : Z_CHAR ­ CHARACTER
÷üüüüüü
Ü (char_lit _) = head o (string_lit _)
°

=TEX
\subsection{Informal Functions}\label{InformalFunctions}
¹Z
Ü [ ÛINFORMAL_FUNCTIONİ ]
°
\subsection{Support for Arrays}\label{Arrays}
The definitions to support array aggregate definitions
are introduced using the ML function {\it array\_agg\_def}.
This is done in \cite{ISS/HAT/DAZ/IMP516}, since during
system build, {\it array\_agg\_def} has not yet been compiled
at the point when the Z in this document is loaded into the tool.

[X]œœœœœœœœœœœœœœœœ
Ü _Û&‰0İ_ : (ú ß X) ¸ (ú ß X) ­ (ú ß X);
Ü _Û&‰1İ_ : (ú ß X) ¸ X ­ (ú ß X);
Ü _Û&‰2İ_ : X  ¸ (ú ß X) ­ (ú ß X)
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ a, b : ú ß X; m, n : ú
Ü | dom a í m  max ± dom b í n  min ·
Ü	a &‰0 b = a « {i : dom b· i + m + 1 - n í b i};
Ü
Ü µ a : ú ß X· a &‰0 š = a;
Ü
Ü µ a : ú ß X; x : X· a &‰1 x = a &‰0 §x¢;
Ü
Ü µ a : ú ß X; x : X· x &‰2 a = §x¢ &‰0 a
ˆüüüüüüüüüüüüüüüüüüüü

\pagebreak
\section{OTHER Z DEFINITIONS}\label{OTHERZDEFINITIONS}

\subsection{Interface with Z Predicates}\label{InterfacewithZPredicates}

For the purposes of proof, a function is needed to convert a Z predicate
into a $BOOLEAN$.
Since this requires the higher-order features of {\ProductZ}, we
must set up the system to allow these features before defining this function:

=SML
set_flag("standard_z_paras", false);
=TEX
¹ZAX
Ü	ÛBooleanİ : BOOL ­ BOOLEAN
÷üüüüüüüüüüüüüüüüüüüü
Ü	Boolean true = TRUE
Ü±	Boolean false = FALSE
°
=SML
reset_flag("standard_z_paras");
=TEX
\pagebreak
\section{THE STRUCTURE}\label{THESTRUCTURE}
\subsection{Preamble}
=DOC
signature ÛCNToolkitExtensionsİ = sig
=DESCRIBE
This is the signature for the toolkit extensions required by the Compliance Tool. It is specified in DRA/CIS/CSE3/TR/94/27/3.0.
=ENDDOC
=THDOC
req_name Û"cn"İ (Value "z_library");
req_language "Z";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $cn$ contains definitions specified in DRA/CIS/CSE3/TR/94/27/3.0.
It is created in structure $CNToolkitExtensions$.
The specification of the theory name, and the language of the theory is defined using $req\_name$ and $req\_language$. This conforms to the technique used in the rest of the {\Product} design documentation for specifying the requirement for theories.
=ENDDOC
\subsection{Theorems}\label{Theorems}
Theorems are provided which allow systematic expansion of the objects in the theory in terms of the Z toolkit operations.
These theorems serve to support the proof procedures defined in section \ref{ProofProcedures} below and may also be directly applied by the user.
\subsubsection{Booleans}
=THDOC
req_thm(Û"cn_boolean_thm"İ, ([], ñBOOLEAN = {FALSE, TRUE}®));
req_thm(Û"cn_boolean_succ_thm"İ, ([], ñBOOLEANvSUCC = {FALSE í TRUE}®));
req_thm(Û"cn_boolean_pred_thm"İ, ([], ñBOOLEANvPRED = {TRUE í FALSE}®));
req_thm(Û"cn_boolean_pos_thm"İ, ([], ñBOOLEANvPOS = id BOOLEAN®));
req_thm(Û"cn_boolean_val_thm"İ, ([], ñBOOLEANvVAL = id BOOLEAN®));
=DESCRIBE
These theorems, together with the definitions of:
=GFT
FALSE, TRUE, BOOLEANvFIRST, BOOLEANvLAST
=TEX
\ permit the values, sets and functions associated with the type $BOOLEAN$ to be simplified away.

To maintain the understandability of intermediate results, expansion of
$TRUE$ and $FALSE$ as the numbers $0$ and $1$ is avoided in
the proof procedures.
This approach is reflected in these theorems.
The definitions of $TRUE$ and $FALSE$ may always be used directly to translate them into $0$ and $1$ by the user, when (rarely) required.
=ENDDOC
=THDOC
req_thm(Û"cn_³_true_eq_false_thm"İ, ([], ñ³TRUE = FALSE®));
req_thm(Û"cn_boolean_cases_thm"İ, ([], ñµx:BOOLEAN· x = TRUE ² x = FALSE®));
req_thm(Û"cn_boolean__boolean_thm"İ, ([], ñµ x : U · Boolean x  BOOLEAN®));
=DESCRIBE
These theorems give basic facts about the type $BOOLEAN$ which are required to justify the translation of Compliance Notation boolean expressions into Z predicates.
=ENDDOC
\subsubsection{Boolean Operators}
=THDOC
req_thm(Û"cn_boolean_clauses"İ, ([], ñ
	TRUE = Boolean true
±	FALSE = Boolean false
±	(µ p : U · not Boolean p = Boolean ((³p)))
±	(µ p, q : U · Boolean p and Boolean q = Boolean ((p ± q)))
±	(µ p, q : U · Boolean p or Boolean q = Boolean ((p ² q)))
±	(µ p, q : U · Boolean p xor Boolean q = Boolean ((³(p ¤ q))))
±	(µ p, q : U · Boolean p = Boolean q ¤ (p ¤ q))
®));
=DESCRIBE
The strategy for handling the boolean operators is to convert an expression
in $not$, $and$, $or$, and $xor$, into an expression of the form
$Boolean\,p$, where $p$ is constructed using the Z propositional operators.
When such expressions appear as the operands of an equality, the whole predicate can be converted to a Z predicate not involving $Boolean$.

These theorems support this strategy.
They use the universal set $U$ to make them easier to instantiate.
The cast $$ is a purely syntactic device used to allow a propositional connective in a function argument (see \cite{DS/FMU/IED/USR005}).
=SEEALSO
$cn\_boolean\_clauses1$, $cn\_boolean\_clauses2$.
=ENDDOC

=THDOC
req_thm(Û"cn_boolean_clauses1"İ, ([], ñ
	(µ x : BOOLEAN · (not x = Boolean ((³ x = Boolean true)))) ±
	(µ x, y : BOOLEAN · 
		(x and y) = Boolean (((x = Boolean true) ± (y = Boolean true)))) ±
	(µ x, y : BOOLEAN · 
		(x or y) = Boolean (((x = Boolean true) ² (y = Boolean true)))) ±
	(µ x, y : BOOLEAN · 
		(x xor y) = Boolean ((³ (x = Boolean true) ¤ (y = Boolean true))))
®));
=DESCRIBE
The strategy for handling the boolean operators is to convert an expression
in $not$, $and$, $or$, and $xor$, into an expression of the form
$Boolean\,p$, where $p$ is constructed using the Z propositional operators.
When such expressions appear as the operands of an equality, the whole predicate can be converted to a Z predicate not involving $Boolean$ (except applied to $true$).

This theorem, with $cn\_boolean\_clauses2$, support this strategy when one or both of the arguments of a boolean
operator are not of the form $Boolean\ x$ for some $x$.
In these cases, if the argument is known to be of type $BOOLEAN$
these theorems can be used.

One way to use the theorems in a tactic proof is if the leaves of a term created from the boolean operators are all associated with assumptions of the form $leaf  BOOLEAN$.
In this case the tactic:
=GFT
a(ALL_FC_T  (rewrite_tac) [cn_boolean_clauses1, cn_boolean_clauses2]);
=TEX
in a proof context also containing $cn\_boolean\_clauses$ as a rewrite rule,
will rewrite the term into one using Z boolean operators and predicates with the arguments equated to $Boolean\ true$, and with a single, outer, $Boolean$.
=EXAMPLE
E.g.
=GFT
(*  3 *)  ña  BOOLEAN®
(*  2 *)  ñb  BOOLEAN®
(*  1 *)  ñc  BOOLEAN®
(* ?ô *)  ñ... a and (b or c) ...®
with the above tactic applied becomes:
(*  3 *)  ña  BOOLEAN®
(*  2 *)  ñb  BOOLEAN®
(*  1 *)  ñc  BOOLEAN®
(* ?ô *)  ñ...Boolean((a = Boolean true) ± (b = Boolean true ² c = Boolean true))...®
=TEX
=ENDDOC
=THDOC
req_thm(Û"cn_boolean_clauses2"İ, ([], ñ
	(µ x : BOOLEAN ; p : U · 
		(x and Boolean p) = Boolean (((x = Boolean true) ± p))) ±
	(µ x : BOOLEAN ; p : U · 
		(Boolean p and x) = Boolean ((p ± (x = Boolean true)))) ±
	(µ x : BOOLEAN ; p : U · 
		(x or Boolean p) = Boolean (((x = Boolean true) ² p))) ±
	(µ x : BOOLEAN ; p : U · 
		(Boolean p or x) = Boolean ((p ² (x = Boolean true)))) ±
	(µ x : BOOLEAN ; p : U · 
		(x xor Boolean p) = Boolean ((³ (x = Boolean true) ¤ p))) ±
	(µ x : BOOLEAN ; p : U · 
		(Boolean p xor x) = Boolean ((³ p ¤ (x = Boolean true))))
®));
=DESCRIBE
See $cn\_boolean\_clauses1$ for use.
=ENDDOC
=THDOC
req_thm(Û"cn_and_then_or_else_clauses"İ, ([], ñ
	µx, y:U·	(x and_then y) = (x and y) ± (x or_else y) = (x or y)
®));
=DESCRIBE
The operators {\it and\_then} and {\it or\_else} are dealt
with by rewriting them in terms of {\it and} and {\it or}.
=ENDDOC
\subsubsection{Relational Operators returning Booleans}
=THDOC
req_thm(Û"cn_relational_clauses"İ, ([], ñ
	(µ x : U; S : U · x mem S = Boolean (x  S))
±	(µ x : U; S : U · x notmem S = Boolean ((³x  S)))
±	(µ x, y : U · x eq y = Boolean (x = y))
±	(µ x, y : U · x noteq y = Boolean ((³x = y)))
±	(µ x, y : U · x less y = Boolean (x < y))
±	(µ x, y : U · x less_eq y = Boolean (x ¼ y))
±	(µ x, y : U · x greater y = Boolean (x > y))
±	(µ x, y : U · x greater_eq y = Boolean (x ¾ y))
®));
=DESCRIBE
The strategy for handling the relational operators is to convert them into expressions of the form
$Boolean\,p$, where $p$ is an atomic Z predicate or the negation of one.

These theorems support this strategy.
They use the universal set $U$ to make them easier to instantiate.
The cast $$ is a purely syntactic device used to allow a propositional connective in a function argument (see \cite{DS/FMU/IED/USR005}).
=ENDDOC
=THDOC
req_thm(Û"cn_relational_clauses1"İ, ([], ñ
	(µ x, y : U · x real_less y = Boolean (x <‰R y))
±	(µ x, y : U · x real_less_eq y = Boolean (x ¼‰R y))
±	(µ x, y : U · x real_greater y = Boolean (x >‰R y))
±	(µ x, y : U · x real_greater_eq y = Boolean (x ¾‰R y))
®));
=DESCRIBE
These theorems support the strategy for handling the relational operators withe real operands.
=ENDDOC


The effect of rewriting with the theorems presented in this section
and the previous section is shown in the following example,
in which we show how the expression ``%
=INLINEFT
N eq 0 or not N less 4 = TRUE
=TEX
'' is rewritten as ``%
=INLINEFT
N = 0 ² ³ N < 4
=TEX
''.
=GFT Rewriting Example
N eq 0 or not N less 4 = TRUE
1)	===> Boolean (N = 0) or not Boolean (N < 4) = Boolean true
2)	===> Boolean (N = 0) or Boolean (³ N < 4) = Boolean true
3)	===> Boolean (N = 0 ² ³ N < 4) = Boolean true
4)	===> N = 0 ² ³ N < 4 ¤ true
5)	===> N = 0 ² ³ N < 4
=TEX
Here in step 1 the theorem of this section starts thing off by turning the
Compliance Notation atomic predicates into Z expressions involving $Boolean$.
In steps 2 and 3, the theorems of the previous section turn
the vocabulary of the theory $cn$ into the Z toolkit vocabulary using the argument of $Boolean$ to accumulate the result.
At step 4 $Boolean$ is eliminated. 
Finally a standard {\ProductZ} simplification removes the unnecessary ``%
=INLINEFT
¤ true
=TEX
''.
\subsubsection{Numeric Operators}
=THDOC
req_thm(Û"cn_intdiv_0_thm"İ,([], ñµ j: ú | ³j = 0 · 
	0 intdiv j = 0 ± 0 rem j = 0 ± 0 intmod j = 0®));
req_thm(Û"cn_intdiv_thm"İ,([], ñµ i,j,k : ú | ³j = 0 · (i intdiv j = k) ¤ 
	(¶ m : ú · i = k * j + m ± abs m < abs j 
	± ((0 ¼ i ± 0 ¼ m ) ² (i < 0 ± m ¼ 0)) )®));
req_thm(Û"cn_rem_thm"İ,([], ñµ i,j,k : ú | ³j = 0 · (i rem j = k) ¤ 
	(¶ d : ú · i = d * j + k ± abs k < abs j 
	± ((0 ¼ i ± 0 ¼ k ) ² (i < 0 ± k ¼ 0)) )®));
req_thm(Û"cn_intmod_thm"İ,([], ñµ i,j,k : ú | ³j = 0 · (i intmod j = k) ¤ 
	(¶ d : ú · i = d * j + k ± abs k < abs j 
	± ((0 ¼ j ± 0 ¼ k ) ² (j < 0 ± k ¼ 0)) )®));
=DESCRIBE
These theorems provide support for reasoning about $intmod$, $intdiv$ and $rem$.
=ENDDOC
=THDOC
req_thm(Û"z_succçnê_»_thm"İ, ([], ñµ x : U; y : U ·
	(succ ç x ê » y) = 
		{ a : U; b : U | 
		((1 ¼ x ± 0 ¼ a) ² (³ (0 ¼ x) ± ((0 - x) ¼ a)) ² (x = 0));
		(a + x, b)  y ·
		(a, b)}
	®));
=DESCRIBE
This is useful for handling array aggregate definitions.
=ENDDOC
=THDOC
req_thm(Û"cn_e_thm"İ, ([], ñ
	µ x, y : ú · x e y = real x *‰R real 10 ^‰Z y
®));
req_thm(Û"cn_e_0_thm"İ, ([], ñ
	µ x : ú · x e 0 = real x
®));
req_thm(Û"cn_integer_to_real_thm"İ, ([], ñ
	µ x : ú · integer_to_real x = real x
®));
=DESCRIBE
These theorems act as rewrite rules that
recast the relevant compliance notation global variables
in terms of the underlying Z ones.
=ENDDOC
\subsubsection{Integers}
Since there are no defining properties for the $INTEGER$ etc., no useful theorems can be provided.
Such theorems would have to be derived from additional axioms asserted by the user, perhaps representing the relevant parameters for a particular Ada compiler.
\subsection{ML Bindings for Theorems}
=DOC
val Ûcn_boolean_cases_thmİ : THM;
val Ûcn_boolean_clausesİ : THM;
val Ûcn_boolean_clauses1İ : THM;
val Ûcn_boolean_clauses2İ : THM;
val Ûcn_boolean_pos_thmİ : THM;
val Ûcn_boolean_pred_thmİ : THM;
val Ûcn_boolean_succ_thmİ : THM;
val Ûcn_boolean_thmİ : THM;
val Ûcn_boolean__boolean_thmİ : THM;
val Ûcn_boolean_val_thmİ : THM;
val Ûcn_relational_clausesİ : THM;
val Ûcn_relational_clauses1İ : THM;
val Ûcn_³_true_eq_false_thmİ : THM;
val Ûcn_intdiv_0_thmİ : THM;	
val Ûcn_intdiv_thmİ : THM;
val Ûcn_rem_thmİ : THM;
val Ûcn_intmod_thmİ : THM;
val Ûz_succçnê_»_thmİ : THM;
val Ûcn_e_thmİ : THM;
val Ûcn_e_0_thmİ : THM;
val Ûcn_integer_to_real_thmİ : THM;
=DESCRIBE
These are the ML names for the theorems in the theory ``$cn$'', which contains
extensions to the Z toolkit required to support the Compliance Notation.
=ENDDOC
\subsection{Proof Procedures}\label{ProofProcedures}
\subsubsection{Syntax Manipulation}
In coding proof procedures such as constant expression evaluators it is sometimes convenient to have functions to manipulate the syntax of the expressions in question.
The rewrite rules of section \ref{Theorems} are such that customised syntax functions will only be required for the numeric operators.
The boolean and relational operators are turned fairly directly into Z and will not need detailed syntax manipulation.

=DOC
val Ûmk_cn_intdivİ : TERM * TERM -> TERM;
val Ûmk_cn_remİ : TERM * TERM -> TERM;
val Ûmk_cn_intmodİ : TERM * TERM -> TERM;
val Ûmk_cn_star_starİ : TERM * TERM -> TERM;
val Ûdest_cn_intdivİ : TERM -> TERM * TERM;
val Ûdest_cn_remİ : TERM -> TERM * TERM;
val Ûdest_cn_intmodİ : TERM -> TERM * TERM;
val Ûdest_cn_star_starİ : TERM -> TERM * TERM;
val Ûis_cn_intdivİ : TERM -> bool;
val Ûis_cn_remİ : TERM -> bool;
val Ûis_cn_intmodİ : TERM -> bool;
val Ûis_cn_star_starİ : TERM -> bool;
=DESCRIBE
These are constructor, destructor and discriminator functions for the operators which support the numeric operations of the Compliance Notation.
=FAILURE
509001	?0 does not have type ú
509002	?0 is not of the form ñi intdiv j®
509003	?0 is not of the form ñi rem j®
509004	?0 is not of the form ñi intmod j®
509005	?0 is not of the form ñi ** j®
=ENDDOC
\subsubsection{Constant Expression Evaluation}
The rewrite rules of section \ref{Theorems} reduce everything except the numeric operators to a form where the facilities for evaluating Z constant expressions will do what is required.
=DOC
val Ûcn_intdiv_convİ : CONV;
val Ûcn_rem_convİ : CONV;
val Ûcn_intmod_convİ : CONV;
val Ûcn_star_star_convİ : CONV;
=DESCRIBE
These conversions  perform evaluation of expressions with constant operands formed using the operators which support the numeric operations of the Compliance Notation.

Each conversion expects an
expression of the form $i\,op\,j$ or $abs\,i$, where $op$ is
one of $intdiv$, $rem$, $intmod$, or $**$, and where $i$
and $j$ are signed integer literals (i.e., either numeric literals or of the form
=INLINEFT
~k
=TEX
, where $k$ is a numeric literal).
The resulting theorem has conclusion $i\,op\,j\,=\,r$, where $r$ is the signed literal resulting from evaluating the expression.

=FAILURE
509011	?0 is not of the form ñi intdiv j® where ñi® and ñj® are numeric literals
509012	?0 is not of the form ñi rem j® where ñi® and ñj® are numeric literals
509013	?0 is not of the form ñi intmod j® where ñi® and ñj® are numeric literals
509014	?0 is not of the form ñi ** j® where ñi® and ñj® are numeric literals
=ENDDOC
\subsubsection{Proof Contexts}\label{ProofContexts}

NOTE: The proof contexts $cn1'$ etc. are actually defined in \cite{ISS/HAT/DAZ/IMP518}. They are described here for convenience of
the user reading reference documentation derived from this document.
=DOC
(* Proof Context: Û'cnİ *)
(* Proof Context: Û'cn1İ *)
=DESCRIBE
Component proof context for the theory $cn$ which supports the Compliance Notation.
$'cn1$ is a slightly improved version of the original $'cn$.

The main purpose of these proof contexts is to automate the elimination of the vocabulary of the theory $cn$ in favour of plain Z toolkit constructs wherever this is possible without introducing excessive complexity.

Expressions and predicates treated by the proof contexts are constructs formed from:
=GFT
not_, _and_, _or_, _xor_, , _and_then_, _or_else_,
_mem_, _notmem_, _eq_, _noteq_,
_less_, _less_eq_, _greater_, _greater_eq_,
_intdiv_, _rem_, _**_
=TEX

\paragraph{Contents}\ 

Rewriting:
=GFT
cn_boolean_thm (cn only), cn_boolean_succ_thm, cn_boolean_pred_thm,
cn_boolean_pos_thm, cn_boolean_val_thm,
cn_boolean_clauses, cn_relational_clauses,
cn_intdiv_conv, cn_rem_conv, cn_intmod_conv, cn_star_star_conv
cn_boolean__boolean_thm (cn1 only)
z_size_dot_dot_conv (cn1 only)
cn_and_then_or_else_clauses
=TEX
Stripping theorems:
(none)
=SEEALSO
$cn$, $cn\_ext$
=ENDDOC
=DOC
(* Proof Context: Û'cn_realsİ *)
=DESCRIBE
Component proof context for the theory $cn$ which supports the Compliance Notation
treatment of Ada fixed and floating point types.

The purpose of the proof context is to automate the elimination of the vocabulary of the theory $cn$ concerned with real numbers
in favour of plain Z toolkit constructs wherever this is possible without introducing excessive complexity.

Expressions and predicates treated by the proof contexts are constructs formed from
the Z real arithmetic operators and the Compliance Notation operators
=INLINEFT
_e_, integer_to_real
=TEX
\ and
=INLINEFT
integer_to_real
=TEX
.

This proof context will typically be used in conjunction with one of the other Compliance Notation
proof contexts and the proof context for the Z real numbers. E.g.,
=GFT
set_merge_pcs["'cn_reals", "'z_reals", "cn"];
=TEX
\paragraph{Contents}\ 

Rewriting:
=GFT
cn_e_0_thm
cn_relational_clauses1
cn_integer_to_real_thm
=TEX
Stripping theorems:
=GFT
cn_relational_clauses1
=SEEALSO
$'cn$, $'cn1$
=ENDDOC
=DOC
(* Proof Context: Ûcnİ *)
(* Proof Context: Ûcn_extİ *)
(* Proof Context: Ûcn1İ *)
(* Proof Context: Ûcn1_extİ *)
=DESCRIBE
Complete proofs context for the theory $cn$ which supports the Compliance Notation. 
$cn1$ is the recommended proof context for normal use while reasoning about VCs generated  by the compliance tool.
$cn$ is still provided for backwards compatibility.

$cn1$ is the merge of the component proof contexts $'cn1$ and $z\_library1$.
$cn1\_ext$ is the merge of the component proof contexts $'cn$ and $z\_library1\_ext$.

$cn$ is the merge of the component proof contexts $'cn$ and $z\_library$.
$cn\_ext$ is the merge of the component proof contexts $'cn$ and $z\_library\_ext$.
=SEEALSO
$'cn1$, $'cn$, $z\_library1$, $z\_library1\_ext$
=ENDDOC

\subsection{Epilogue}
=SML
end (* end of signature CNToolkitExtensions *);
=TEX
=SML
reset_flag ("z_type_check_only");
reset_flag ("z_use_axioms");
reset_flag("standard_z_paras");
=TEX


=TEX
\section{TEST POLICY}

The module tests for this module are to follow the guidelines
identified in the quality plan~\cite{ISS/HAT/DAZ/PLN003}.
There are no special testing considerations.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



