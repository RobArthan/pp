=IGN
********************************************************************************
dtd509.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
%  dtd509.doc %Z% $Date: 2008/02/10 15:59:51 $ $Revision: 1.63 $ $RCSfile: dtd509.doc,v $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999

\def\DRASpecs{\cite{DRA/CIS/CSE3/TR/94/27/3.0}}
\def\Volume#1{\cite[volume #1]{DRA/CIS/CSE3/TR/94/27/3.0}\/}
\def\VolumeOne{\Volume 1}
\def\VolumeTwo{\Volume 2}
\def\VolumeThree{\Volume 3}

\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Z Toolkit Extensions}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD509}  %% Mandatory field
\def\SCCSversion{$Revision: 1.63 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2008/02/10 15:59:51 $%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{SPARK}
\TPPauthors{D.J.~King&WIN01\\R.D.~Arthan&WIN01}
\TPPauthorisation{R.D.~Arthan & DAZ Team}
\TPPabstract{
This document defines a theory containing the extensions to the Z toolkit required for the DAZ Compliance Tool.
It also defines theorems and proof procedures to assist in reasoning about the objects defined in the theory.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DRA \\
	Library}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
\def\TPPheadlhs{Lemma 1 Ltd.}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.6] Initial Drafts.
\item[Issue 1.7] Carried out rework according to desk check report 011.
\item[Issue 1.8] Added statement that there is no corresponding implementation document for this design.
\item[Issues 1.9] Theorems added; definition of $rem$ etc. revised.
\item[Issue 1.10] Proof context and signatures of proof procedures added.
\item[Issue 1.11] Responded to comments.
\item[Issue 1.12] Corrections after module testing the implementation.
\item[Issue 1.13] Amendments after further review.
\item[Issue 1.14] Updated document references.
\item[Issue 1.15] Updates for enhancements contract (enhancement no. 4).
\item[Issue 1.16] Corrected indexing of new definitions.
\item[Issue 1.17] Removed $DummyVC$ --- a variable can be used instead where this is needed.
\item[Issue 1.18] Updated document references.
\item[Issue 1.19] Fixed omissions which caused bug 13 (V0.6).
\item[Issue 1.20] Added theorems for reasoning about $intdiv$, $intmod$ and $rem$.
\item[Issue 1.21] Added variants to cn proof context.
\item[Issue 1.22] Added further results about $Boolean$.
\item[Issue 1.23] Improved proof context $cn1$.
\item[Issue 1.24] Removed $cn1$ and renamed and exposed a useful theorem.
\item[Issue 1.25] Added $z\_succçnê\_»\_thm$.
\item[Issue 1.26] Added $z\_size\_dot\_dot\_conv$ to $cn1$.
\item[Issue 1.27] Changes for IUCT WP 4.
\item[Issue 1.28] Adding indexing characters.
\item[Issue 1.29] Updated references to the DERA specifications.
\item[Issue 1.30] CTLE II R1/4: support for logical operators on boolean arrays.
\item[Issue 1.31] CTLE II R1/8: characters and strings.
\item[Issues 1.32,1.33] CTLE II R1/1: real types (interim solution with Z reals declared here).
\item[Issues 1.34,1.35] CTLE II R1/1: real types (using the official Z reals).
\item[Issues 1.36] Fixed typo in theory checking.
\item[Issues 1.37--1.39] R0021: new treatment of AND THEN and OR ELSE.
\item[Issues 1.40] R0032: Compliance Notation specification maintenance (added index brackets for Z global variables).
\item[Issues 1.41--1.43] R0006: free use of subtype indications and ranges.
\item[Issues 1.44] R0044: checks on array ranges.
\item[Issues 1.45] Fixing overfull hboxes for SPC501.
\item[Issues 1.46] Changed {\it INFORMAL\_FUNCTION} to {\it Informal\_Function}
to avoid possible clash with an Ada name.
\item[Issue  1.47] Added {\it Sequent\_Route} Z type for sequent provenance information in VCs.
                      This is in reponse to an operational and not a formal requirement.
\item[Issue 1.48] Added missing fixity paragraph for {\it SR\_proc\_call\_end}.
\item[Issue 1.49] R0081: added defining property for {\it real\_to\_integer}.
\item[Issue 1.50] Removed use of ICL logo font.
\item[Issue 1.51] Merged changes for R0062. Remove unusable (subprogram context) constructors from {\it Sequent\_Route}.
			Name changes {\it Sequent\_Route} to {\it VC\_Route} and
			constructor names become PP compatible e.g. {\it VCExitTillToSide}.
\item[Issue 1.52] Copyright and banner updates for open source release.
\item[Issue 1.53] DAZ-specific updates to banner for open source release
\item[Issue 1.54] DAZ-specific updates to banner for open source release
\item[Issue 1.55] The Z universal set is now called ƒ
\item[Issue 1.56] Allowed for ISO Z precedences and associativities that {\Product} now uses.
\item[Issue 1.57] Tidy-up of the operator precedences.
\item[Issue 1.58] Corrected precedence of logical negation.
\item[Issue 1.59] Allowed for introduction of – and ¿.
\item[Issue 1.60] Allowed for new symbol for functional composition.
\item[Issue 1.61] Ada real literals are now translated into Z floating point literals.
\item[Issue 1.62] Removed fixity declaration for $e$.
\item[Issue 1.63] Allowed for change to lexical rules for underscores in Z.
\item[Issue 1.64] Support for modular types.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document responds to a requirement for a design of toolkit extensions in Z in \cite{ISS/HAT/DAZ/HLD503}. The specification of the toolkit extensions is provided in {\VolumeOne}.
The document also responds to the requirement for tools supporting proof of propositions expressed using the toolkit extensions also expressed in \cite{ISS/HAT/DAZ/HLD503}.

\subsection{Introduction}

\subsubsection{Purpose and Background}

This document provides the Z toolkit extensions required for the Compliance Tool and specified in {\VolumeOne}.
The toolkit extensions are implemented as a {\ProductZ} specification.

It also specifies the basic proof support tools for the toolkit extensions.
These tools comprise theorems, conversions and a proof context and are defined here in the same style as is used for {\Product} proof facilities.

In more detail, the structure of this document is as follows:

\begin{description}
\item[Section \ref{DESIGNISSUES}] discusses design issues and decisions which have been taken here;
\item[Section \ref{SPARKTOOLKIT}] gives the toolkit extensions as defined in {\VolumeOne};
\item[Section \ref{OTHERZDEFINITIONS}] contains some additional Z definitions which support the operation of the Compliance Tool;
\item[Section \ref{THESTRUCTURE}] defines the ML structure which gives the interface for the theorems, proof procedures etc. provided.
\end{description}

\subsubsection{Compliance}

The function $abs$ specified in {\VolumeOne} is not provided here because the {\ProductZ} toolkit already supplies an appropriate implementation.

The Z name for an attribute in {\VolumeOne} is denoted by a pair of underscore characters. {\Product-Z}'s lexical rules does not permit this. A lowercase ``v'' is used to denote an attribute instead.

\subsubsection{Dependencies}
The theory defined in this document is a child of the theory $z\_library$ defined in {\Product}.
The document is therefore dependent on {\Product} but not on any module of the Compliance Tool.
%\subsubsection{Possible Enhancements}

\section{DESIGN ISSUES}\label{DESIGNISSUES}

\subsection{Theory Hierarchy}
The theory created by this document is called ``$cn$''.
Its parent is the theory ``$z\_library$'' which gives access to the Z toolkit as provided in {\Product}.
When the compliance tool is invoked, the current theory should be ``$cn$'', and the function which introduces a new literate script should arrange for this.

\subsection{Proof Facilities}
The proof facilities follow a pattern which is common in {\Product}.
First of all, in section \ref{Theorems}, theorems are presented which allow basic semi-automatic reasoning about the objects defined in a theory.

Secondly, in section \ref{ProofProcedures}, proof procedures which cannot be captured as theorems are given as derived inference rules, typically conversions (i.e. proof rules which support equational reasoning by taking a term $tm$ as argument and proving a theorem of the form
=INLINEFT
ô tm = tm'
=TEX
.
E.g., the theorem schemata corresponding to the evaluation of expressions with constant operands are given as conversions which prove theorems such as
=INLINEFT
ô 12 intdiv 5 = 2
=TEX
.

Finally, in section \ref{ProofContexts} the more generally applicable theorems and proof procedures are packaged together in one or more proof contexts which make it convenient for a user to access a general purpose collection of simplifications customised for the theory.
These proof contexts typically come in two flavours: component proof contexts containing only the simplifications for this theory for use in combination with other proof contexts; and complete proof contexts which contain a comprehensive collection of simplifications for the theory and its ancestors.

=TEX
\newpage

=TEX
\pagebreak
\section{SPARK TOOLKIT}\label{SPARKTOOLKIT}
Sections \ref{Booleans} to \ref{CharactersandStrings} give the {\ProductZ} analogues of the toolkit extensions essentially as defined by DRA in {\VolumeOne}.
Any disparities with the DRA are discussed in the accompanying narrative.

\subsection{Preamble}

The following preamble creates the theory ``cn'' as a child of ``z\_library''
and makes the theory ``z\_reals'' a parent.

=SML
force_delete_theory"cn" handle Fail _ => ();
open_theory"z_library";
push_pc "z_library";
val _ = set_flag ("z_type_check_only", false);
val _ = set_flag ("z_use_axioms", true);
new_theory"cn";
new_parent"z_reals";
=TEX

The following paragraphs are required by {\Product} to determine the fixity of some of the names defined in the toolkit extensions.

\HOLindexOff

¹Z
function 0 Ûchar_litİ _
°

¹Z
function 0 Ûstring_litİ _
°

¹Z
function 0 _ Ûandİ _, _ Ûorİ _, _ Ûxorİ _
°

¹Z
function 0 _ Ûand_thenİ _, _ Ûor_elseİ _
°

¹Z
function 0 _ Ûarray_andİ _, _ Ûarray_orİ _, _ Ûarray_xorİ _
°

¹Z
function 0 _ Ûmod_andİ _, _ Ûmod_orİ _, _ Ûmod_xorİ _
°

¹Z
function 10 _ Ûmemİ _, _ Ûnotmemİ _, _ Ûeqİ _, _ Ûnoteqİ _
°

¹Z
function 20 _ Ûlessİ _, _ Ûless_eqİ _, _ Ûgreaterİ _, _ Ûgreater_eqİ _
°

¹Z
function 20 _ Ûreal_lessİ _, _ Ûreal_less_eqİ _, _ Ûreal_greaterİ _, _ Ûreal_greater_eqİ _
°

¹Z
function 20 _ Ûarray_lessİ _, _ Ûarray_less_eqİ _,
      _ Ûarray_greaterİ _, _ Ûarray_greater_eqİ _
°

¹Z
function 30 _ Û&‰0İ _, _ Û&‰1İ _, _ Û&‰2İ _
°

¹Z
function 40 _ Ûintdivİ _, _ Ûremİ _, _ Ûintmodİ _
°

¹Z
function 50 _ Û**İ _, Ûnotİ _, Ûarray_notİ _, Ûmod_notİ _
°

\HOLindexOn

\subsection{Booleans}\label{Booleans}

¹Z
ÛFALSEİ ¦ 0
°

¹Z
ÛTRUEİ ¦ 1
°

¹Z
ÛBOOLEANİ ¦ FALSE..TRUE
°

¹Z
ÛBOOLEANvFIRSTİ ¦ FALSE
°

¹Z
ÛBOOLEANvLASTİ ¦ TRUE
°

¹Z
ÛBOOLEANvSUCCİ ¦ (BOOLEAN \ {BOOLEANvLAST}) ò succ
°

¹Z
ÛBOOLEANvPREDİ ¦ BOOLEANvSUCCç~ê
°

¹Z
ÛBOOLEANvPOSİ ¦ id BOOLEAN
°

¹Z
ÛBOOLEANvVALİ ¦ BOOLEANvPOSç~ê
°

\subsection{Boolean Operators}

¹ZAX
Ü Ûnotİ _ : BOOLEAN ­ BOOLEAN;
Ü _ Ûandİ _, _ Ûorİ _, _ Ûxorİ _ : (BOOLEAN ¸ BOOLEAN) ­ BOOLEAN
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ b : BOOLEAN ·
Ü	not FALSE = TRUE ± not TRUE = FALSE ±
Ü	(b and FALSE = FALSE ± b and TRUE = b) ±
Ü	(b or FALSE = b ± b or TRUE = TRUE) ±
Ü	(b xor FALSE = b ± b xor TRUE = not b)
°
¹ZAX
Ü _ Ûand_thenİ _, _ Ûor_elseİ _: (BOOLEAN ¸ BOOLEAN) ­ BOOLEAN
÷üüüüüüüüüüüüüüüüüüüüü
Ü (_ and_then _) = (_ and _) ± (_ or_else _) = (_ or _)
°

\subsection{Relational Operators returning Booleans}

[X]œœœœœœœœœœœœœœœœ
Ü _ Ûmemİ _, _ Ûnotmemİ _ : (X ¸ ğ X) ­ BOOLEAN;
Ü _ Ûeqİ _, _ Ûnoteqİ _ : (X ¸ X) ­ BOOLEAN
÷üüüüüüüüüüüüüüüüüü
Ü µ x, y : X; S : ğ X; b : BOOLEAN ·
Ü	(b = x mem S ¤ (b = TRUE ¤ x  S)) ±
Ü	(b = x notmem S ¤ (b = TRUE ¤ x  S)) ±
Ü	(b = x eq y ¤ (b = TRUE ¤ x = y)) ±
Ü	(b = x noteq y ¤ (b = TRUE ¤ x ½ y))
ˆüüüüüüüüüüüüüüüüüüüü

[X]œœœœœœœœœœœœœœœœ
Ü Ûarray_notİ _ : (X ß BOOLEAN) ­ (X ß BOOLEAN);
Ü _ Ûarray_andİ _,
Ü _ Ûarray_orİ _,
Ü _ Ûarray_xorİ _ : ((X ß BOOLEAN) ¸ (X ß BOOLEAN)) ­ (X ß BOOLEAN)
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ a, b : X ß BOOLEAN ·
Ü	array_not a = (Ìi : dom a· not (a i)) ±
Ü	a array_and b = (Ìi : dom a ¡ dom b· a i and b i) ±
Ü	a array_or b = (Ìi : dom a ¡ dom b· a i or b i) ±
Ü	a array_xor b = (Ìi : dom a ¡ dom b· a i xor b i)
ˆüüüüüüüüüüüüüüüüüüüü

¹ZAX
Ü _ Ûlessİ _, _ Ûless_eqİ _, _ Ûgreaterİ _,
Ü _ Ûgreater_eqİ _ : (ú ¸ ú) ­ BOOLEAN
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ x, y : ú; b : BOOLEAN ·
Ü	(b = x less y ¤ (b = TRUE ¤ x < y)) ±
Ü	(b = x less_eq y ¤ (b = TRUE ¤ x ¼ y)) ±
Ü	(b = x greater y ¤ (b = TRUE ¤ x > y)) ±
Ü	(b = x greater_eq y ¤ (b = TRUE ¤ x ¾ y))
°
¹ZAX
Ü _ Ûreal_lessİ _, _ Ûreal_less_eqİ _, _ Ûreal_greaterİ _,
Ü _ Ûreal_greater_eqİ _ : (¯ ¸ ¯) ­ BOOLEAN
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ x, y : ¯; b : BOOLEAN ·
Ü	(b = x real_less y ¤ (b = TRUE ¤ x <‰R y)) ±
Ü	(b = x real_less_eq y ¤ (b = TRUE ¤ x ¼‰R y)) ±
Ü	(b = x real_greater y ¤ (b = TRUE ¤ x >‰R y)) ±
Ü	(b = x real_greater_eq y ¤ (b = TRUE ¤ x ¾‰R y))
°


¹ZAX
Ü _ Ûarray_lessİ _,
Ü _ Ûarray_less_eqİ _,
Ü _ Ûarray_greaterİ _,
Ü _ Ûarray_greater_eqİ _ : ((ú ß ú) ¸ (ú ß ú)) ­ BOOLEAN
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ a, b : ú ß ú ·
Ü	(a array_less b = TRUE ¤
Ü	(¶i, j, k : ú·
Ü		{i, j} € dom b ± i - 1  dom b ± i + k - 1  dom a
Ü	±	(µt : i .. j - 1· t + k  dom a ± b t = a(t + k))
Ü	±	j + k  dom a ´ a(j + k) < b j)) ±
Ü	a array_less_eq b = a array_less b or a eq b ±
Ü	a array_greater b = b array_less a ±
Ü	a array_greater_eq b = b array_less_eq a
°

\subsection{Numeric Operators}
The definitions of division etc. in {\VolumeOne} rely on the definitions of the analogous operations for Z in \cite{Spivey92}.
This part of the Z toolkit is in a state of flux in the standardisation activity and the {\ProductZ} toolkit differs from \cite{Spivey92}.
The following formulation defines division, remainder and modulo for SPARK using only Z division with non-negative operands.
It should therefore be independent of the final choice made in the Z standards work.
¹ZAX
Ü _ Ûintdivİ _, _ Ûremİ _, _ Ûintmodİ _ : (ú ¸ ú \ {0}) ­ ú
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ x, y : ú | y ½ 0 ·
Ü	(x*y ¾ 0 ´ x intdiv y = abs x div abs y )
Ü±	(x*y < 0 ´ x intdiv y = ~(abs x div abs y))
Ü±	x rem y = x - (x intdiv y) * y
Ü±	(x*y ¾ 0 ² x rem y = 0 ´ x intmod y = x rem y )
Ü±	(x*y < 0 ± x rem y ½ 0 ´ x intmod y = x rem y + y)
°
That the above definition agree with the Ada definitions is supported by
the result of a simple experiment with {\Product}.
The following list of theorems has been derived from the above definition and corresponds to parts of the table in section 4.5.5 of the Ada LRM.
=GFT ProofPower Output
val it = [ô (10 intdiv 5, 10 rem 5, 10 intmod 5) = (2, 0, 0),
   ô (12 intdiv 5, 12 rem 5, 12 intmod 5) = (2, 2, 2),
   ô (14 intdiv 5, 14 rem 5, 14 intmod 5) = (2, 4, 4),
   ô (10 intdiv ~ 5, 10 rem ~ 5, 10 intmod ~ 5) = (~ 2, 0, 0),
   ô (12 intdiv ~ 5, 12 rem ~ 5, 12 intmod ~ 5) = (~ 2, 2, ~ 3),
   ô (14 intdiv ~ 5, 14 rem ~ 5, 14 intmod ~ 5) = (~ 2, 4, ~ 1),
   ô (~ 10 intdiv 5, ~ 10 rem 5, ~ 10 intmod 5) = (~ 2, 0, 0),
   ô (~ 12 intdiv 5, ~ 12 rem 5, ~ 12 intmod 5) = (~ 2, ~ 2, 3),
   ô (~ 14 intdiv 5, ~ 14 rem 5, ~ 14 intmod 5) = (~ 2, ~ 4, 1),
   ô (~ 10 intdiv ~ 5, ~ 10 rem ~ 5, ~ 10 intmod ~ 5) = (2, 0, 0),
   ô (~ 12 intdiv ~ 5, ~ 12 rem ~ 5, ~ 12 intmod ~ 5) = (2, ~ 2, ~ 2),
   ô (~ 14 intdiv ~ 5, ~ 14 rem ~ 5, ~ 14 intmod ~ 5) = (2, ~ 4, ~ 4)] : THM list
¹ZAX
Ü _ Û**İ _ : (ú ¸ î) ­ ú
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ x : ú; y : î · x ** 0 = 1 ± x ** (y + 1) = x * x ** y
°

¹ZAX
Ü Ûinteger_to_realİ: ú ­ ¯
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ i : ú · integer_to_real i = real i
°
¹ZAX
Ü Ûreal_to_integerİ : ¯ ­ ú
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ x : ¯ · ~‰R 0.5 ¼‰R x -‰R real (real_to_integer x) ¼‰R 0.5
°

The $abs$ function is already provided in the {\ProductZ} mathematical toolkit and therefore does not need to be defined here.

\subsection{Operations for Modular Types}

¹ZAX
Ü Û_ mod_and _İ, Û_ mod_or _İ, Û_ mod_xor _İ : î ¸ î ­ î
÷üüüüüü
Ü µi : î· i mod_and 0 = 0;
Ü µi : î; j : î‰1·
Ü	i mod_and j = 2*(i div 2 mod_and j div 2) + (i mod 2)*(j mod 2);
Ü µi : î· i mod_or 0 = i;
Ü µi : î; j : î‰1·
Ü	i mod_or j = 2*(i div 2 mod_or j div 2) + max{i mod 2, j mod 2};
Ü µi : î· i mod_xor 0 = i;
Ü µi : î; j : î‰1·
Ü	i mod_xor j = 2*(i div 2 mod_xor j div 2) + (i + j) mod 2
°


¹ZAX
Ü Ûmod_not _İ : ú ¸ ú ­ ú
÷üüüüüü
Ü µi, modulus : ú· mod_not(i, modulus) = modulus - (i + 1)
°


\subsection{Integers}\label{Integers}

¹ZAX
Ü ÛINTEGERİ : ğ ú
°
¹ZAX
Ü ÛINTEGERvFIRSTİ, ÛINTEGERvLASTİ : ú ;
Ü ÛINTEGERvSUCCİ, ÛINTEGERvPREDİ,
Ü ÛINTEGERvPOSİ, ÛINTEGERvVALİ : ú ß ú
°
\subsection{Natural Numbers}\label{NaturalNumbers}
¹Z
Ü ÛNATURALİ ¦ 0 .. INTEGERvLAST
°
¹Z
Ü ÛNATURALvFIRSTİ ¦ 0
°
¹Z
Ü ÛNATURALvLASTİ ¦ INTEGERvLAST
°
¹Z
Ü ÛNATURALvSUCCİ ¦ INTEGERvSUCC
°
¹Z
Ü ÛNATURALvPREDİ ¦ INTEGERvPRED
°
¹Z
Ü ÛNATURALvPOSİ ¦ INTEGERvPOS
°
¹Z
Ü ÛNATURALvVALİ ¦ INTEGERvVAL
°

\subsection{Positive Numbers}\label{PositiveNumbers}
¹Z
Ü ÛPOSITIVEİ ¦ 1 .. INTEGERvLAST
°
¹Z
Ü ÛPOSITIVEvFIRSTİ ¦ 1
°
¹Z
Ü ÛPOSITIVEvLASTİ ¦ INTEGERvLAST
°
¹Z
Ü ÛPOSITIVEvSUCCİ ¦ INTEGERvSUCC
°
¹Z
Ü ÛPOSITIVEvPREDİ ¦ INTEGERvPRED
°
¹Z
Ü ÛPOSITIVEvPOSİ ¦ INTEGERvPOS
°
¹Z
Ü ÛPOSITIVEvVALİ ¦ INTEGERvVAL
°
\subsection{Long Integers}\label{LongIntegers}

¹ZAX
Ü ÛLONG_INTEGERİ : ğ ú
°
¹ZAX
Ü ÛLONG_INTEGERvFIRSTİ, ÛLONG_INTEGERvLASTİ : ú ;
Ü ÛLONG_INTEGERvSUCCİ, ÛLONG_INTEGERvPREDİ,
Ü ÛLONG_INTEGERvPOSİ,  ÛLONG_INTEGERvVALİ : ú ß ú
°
\subsection{Short Integers}\label{ShortIntegers}

¹ZAX
Ü ÛSHORT_INTEGERİ : ğ ú
°
¹ZAX
Ü ÛSHORT_INTEGERvFIRSTİ, ÛSHORT_INTEGERvLASTİ : ú ;
Ü ÛSHORT_INTEGERvSUCCİ, ÛSHORT_INTEGERvPREDİ,
Ü ÛSHORT_INTEGERvPOSİ, ÛSHORT_INTEGERvVALİ : ú ß ú
°
¹ZAX
Ü Ûuniversal_discreteİ : ğú
°
¹ZAX
Ü Ûuniversal_discretevFIRSTİ, Ûuniversal_discretevLASTİ : ú ;
Ü Ûuniversal_discretevSUCCİ, Ûuniversal_discretevPREDİ,
Ü Ûuniversal_discretevPOSİ, Ûuniversal_discretevVALİ : ú ß ú
°

\subsection{Float}\label{Float}

¹ZAX
Ü ÛFLOATİ : ğ ¯
°
¹ZAX
Ü ÛFLOATvFIRSTİ, ÛFLOATvLASTİ : ¯ ;
Ü ÛFLOATvDIGITSİ : ú
°
\subsection{Short Float}\label{ShortFloat}

¹ZAX
Ü ÛSHORT_FLOATİ : ğ ¯
°
¹ZAX
Ü ÛSHORT_FLOATvFIRSTİ, ÛSHORT_FLOATvLASTİ : ¯ ;
Ü ÛSHORT_FLOATvDIGITSİ : ú
°
\subsection{Long Float}\label{LongFloat}

¹ZAX
Ü ÛLONG_FLOATİ : ğ ¯
°
¹ZAX
Ü ÛLONG_FLOATvFIRSTİ, ÛLONG_FLOATvLASTİ : ¯ ;
Ü ÛLONG_FLOATvDIGITSİ : ú
°

\subsection{Characters and Strings}\label{CharactersandStrings}
¹Z
Ü ÛCHARACTERvFIRSTİ ¦ 0
°
¹ZAX
Ü ÛCHARACTERvLASTİ : ú
÷üüüüüü
Ü CHARACTERvLAST ¾ 127
°
¹Z
Ü ÛCHARACTERİ ¦ CHARACTERvFIRST .. CHARACTERvLAST
°
¹Z
Ü ÛCHARACTERvSUCCİ ¦ (CHARACTER \ {CHARACTERvLAST}) ò succ
°
¹Z
Ü ÛCHARACTERvPREDİ ¦ CHARACTERvSUCCç~ê
°
¹Z
Ü ÛCHARACTERvPOSİ ¦ id CHARACTER
°
¹Z
Ü ÛCHARACTERvVALİ ¦ CHARACTERvPOSç~ê
°

¹ZAX
Ü ÛSTRINGİ : ğ (POSITIVE ß CHARACTER)
°
Characters in Z are represented by singleton strings:
¹Z
Ü ÛZ_CHARİ ¦ seq ¿
°
¹Z
Ü ÛZ_STRINGİ ¦ seq ¿
°
We have to resort to a HOL quotation to define a function
to return the integer code for a character. This should
perhaps be included as part of {\ProductZ}.


=SML
set_flag("standard_z_paras", false);
¹ZAX
Ü Ûdest_charİ : ¿ ­ ú
÷üüüüüü
Ü µch : ¿· dest_char ch = ¬îú (RepChar ch)®
°
=SML
reset_flag("standard_z_paras");
=TEX
A string is then obtained by mapping {\it dest\_char} over the characters
of the string. Since the string is a Z sequence, mapping a function over
it amounts to functional composition of the function with the string.
¹ZAX
Ü Ûstring_litİ _ : Z_STRING ­ seq CHARACTER
(*
°
¹Z
*)
÷üüüüüü
Ü µstr : Z_STRING· string_lit str = dest_char … str
°
And then a character code is obtained from a singleton
string by taking the head of the sequence obtained from {\it string\_lit}.

¹ZAX
Ü Ûchar_litİ _ : Z_CHAR ­ CHARACTER
(*
°
¹Z
*)
÷üüüüüü
Ü (char_lit _) = head … (string_lit _)
°

=TEX
\subsection{Informal Functions}\label{InformalFunctions}
¹Z
Ü [ ÛInformal_Functionİ ]
°
\subsection{Support for Arrays}\label{Arrays}
The definitions to support array aggregate definitions
are introduced using the ML function {\it array\_agg\_def}.
This is done in \cite{ISS/HAT/DAZ/IMP516}, since during
system build, {\it array\_agg\_def} has not yet been compiled
at the point when the Z in this document is loaded into the tool.

[X]œœœœœœœœœœœœœœœœ
Ü _Û&‰0İ_ : (ú ß X) ¸ (ú ß X) ­ (ú ß X);
Ü _Û&‰1İ_ : (ú ß X) ¸ X ­ (ú ß X);
Ü _Û&‰2İ_ : X  ¸ (ú ß X) ­ (ú ß X)
÷üüüüüüüüüüüüüüüüüüüüü
Ü µ a, b : ú ß X; m, n : ú
Ü | dom a í m  max ± dom b í n  min ·
Ü	a &‰0 b = a « {i : dom b· i + m + 1 - n í b i};
Ü
Ü µ a : ú ß X· a &‰0 š = a;
Ü
Ü µ a : ú ß X; x : X· a &‰1 x = a &‰0 §x¢;
Ü
Ü µ a : ú ß X; x : X· x &‰2 a = §x¢ &‰0 a
ˆüüüüüüüüüüüüüüüüüüüü
[X, Y]œœœœœœœœœœœ
Ü Ûslideİ : (X ß Y) ¸ ğX ­ (X ß Y)
÷üüüüüü
Ü µf : X ß Y; r : ğX | dom f = r · slide(f, r) = f
ˆüüüüüüüüüüüüüü

\pagebreak
\section{OTHER Z DEFINITIONS}\label{OTHERZDEFINITIONS}

\subsection{Interface with Z Predicates}\label{InterfacewithZPredicates}

For the purposes of proof, a function is needed to convert a Z predicate
into a $BOOLEAN$.
Since this requires the higher-order features of {\ProductZ}, we
must set up the system to allow these features before defining this function:

=SML
set_flag("standard_z_paras", false);
=TEX
¹ZAX
Ü	ÛBooleanİ : – ­ BOOLEAN
÷üüüüüüüüüüüüüüüüüüüü
Ü	Boolean true = TRUE
Ü±	Boolean false = FALSE
°
=SML
reset_flag("standard_z_paras");
=TEX
\subsection{Sequent Provenance Information}
We provide a Z type (\textit{\slshape VC\_Route}) that can carry information on the introduction, transformation and siding of sequents as they pass backwards up the SPARK abstract syntax tree.


The bracketed constructs are semicolon with \verb+semi+ and \verb+semi+,
 if-then-elsec, \verb+if-then+, \verb+if-else+ and \verb+end-if+ and case with
  \verb+case+, \verb+case-others+ and \verb+end-case+, webclause or subprogram body with \verb+refinement+, \verb+refinement_intro+
 (these outer constructs exist to hold the specification statements from which initial post-conditions are derived). Other constructs are atoms and
 describe introduction, passage and transition to side condition of the sequent in various
 statement forms.  The atoms that describe introduction always terminate such a string.

In carrying side conditions through statements we need just show that a statement has been
passed so we use \verb+any_statement+.

To be able to reproduce the skeleton independently of the actual abstract syntax tree
we need to remember whether an \textbf{if} clause was introduced implicitly for the
clause following \textbf{elsf} or not.

¹Z
Ü   ÛVRElsfIndİ ::= VRElsfTrue | VRElsfFalse
°

We now describe the free type for the route which describes the path recursively out of unary and nullary constructors. Some compression would of course be possible. Additionally, data replication would be saved
at the cost of processing time if the new information were appended to the list since then address prefixes would be in common.

¹Z
fun ÛVRAnyİ _
°

¹Z
fun ÛVRNullİ _
°

¹Z
fun ÛVRAssignİ _
°

¹Z
fun ÛVRSpecViaİ _
°

¹Z
fun ÛVRSpecToSideİ _
°

¹Z
fun ÛVRSemiİ _
°

¹Z
fun ÛVREndSemiİ _
°

¹Z
fun ÛVRIfThenİ _
°

¹Z
fun ÛVRIfElseİ _
°

¹Z
fun ÛVREndIfİ _
°

¹Z
fun ÛVRCaseBranchİ _
°

¹Z
fun ÛVRCaseOthersİ _
°

¹Z
fun ÛVREndCaseİ _
°

¹Z
fun ÛVRLoopUndecViaİ _
°

¹Z
fun ÛVRLoopUndecToSideİ _
°

¹Z
fun ÛVRWhileViaİ _
°

¹Z
fun ÛVRWhileWPToSideİ _
°

¹Z
fun ÛVRWhileToSideİ _
°

¹Z
fun ÛVRForViaİ _
°

¹Z
fun ÛVRForToSideİ _
°

¹Z
fun ÛVRForExitToSideİ _
°

¹Z
fun ÛVRExitViaİ _
°

¹Z
fun ÛVRProcCallİ _
°

¹Z
fun ÛVRProcCallEndİ _
°

¹Z
fun ÛVRLogConToSideİ _
°

¹Z
fun ÛVRRefinementBeginİ _
°

¹Z
Ü  ÛVC_Routeİ ::=
Ü (*
°

The short-circuit along descriptor which is used only for side conditions is \textit{\slshape VRAny}.

¹Z
Ü  *)
Ü    VRAny(VC_Route) |
Ü (*
°

The rest of the constructors describe the effects of given statements. Some are decorated with
information allowing a fuller skeleton of the tree to be drawn. This could be discarded in favour
of walking the path using the abstract syntax tree.

¹Z
Ü  *)
Ü    VRNull( VC_Route) |
Ü    VRAssign( VC_Route) |
Ü (*
°

In a specification statement we see several possible treatments of sequents: they can pass from
post-condition to pre-condition (often with additional hypotheses), this is described by
\textit{\slshape SR\_spec\_via}, they can pass from the post-condition to a side condition, shown by \textit{\slshape SR\_spec\_to\_side}, they can be introduced where the pre-condition of the specification
is injected as a pre-condition without hypotheses, shown by \textit{\slshape SR\_spec\_intro\_pre}.

¹Z
Ü  *)
Ü    VRSpecVia( VC_Route) | VRSpecToSide( VC_Route) |
Ü    VRSpecPreIntro |
Ü (*
°

Sequential composition is represented in the abstract syntax as a binary operator and handled accordingly by \textit{\slshape wp} so we use that representation.

¹Z
Ü  *)
Ü    VRSemi( VC_Route) | VREndSemi( VC_Route) |
Ü (*
°

For \textbf{if} and \textbf{case} clauses where control flow divides we need to know (not for side conditions!)  down which path a sequent was transformed;  for \textbf{if} clauses we can just use alternative constructors, for \textbf{case} clauses we separate out the \textbf{others} case and
then use an integer to identify the branch traversed.

¹Z
Ü  *)
Ü    VRIfThen( VRElsfInd ¸ VC_Route) | VRIfElse( VRElsfInd ¸ VC_Route) |
Ü    VREndIf( VC_Route) |
Ü    VRCaseBranch( î‰1 ¸ VC_Route) | VRCaseOthers( VC_Route) |
Ü    VREndCase( VC_Route) |
Ü (*
°

With an undecorated loop we have a new possibility, that a precondition of the specification statement which is the body of the loop is immediately turned into a side condition.

¹Z
Ü  *)
Ü    VRLoopUndecVia( VC_Route) |
Ü    VRLoopUndecPreIntro |
Ü    VRLoopUndecPreToSide |
Ü    VRLoopUndecToSide( VC_Route) |
Ü (*
°

For a \textbf{while} loop  \textit{\slshape wp} first computes the pre-condition and then derives a
side condition from it. This means that in this case we may have TWO constructors relating to
the single construct when a sequent becomes a side condition.

¹Z
Ü  *)
Ü    VRWhileVia( VC_Route) |
Ü    VRWhilePreIntro|
Ü    VRWhileWPToSide( VC_Route) |
Ü    VRWhileToSide( VC_Route) |
Ü (*
°

We don't see a requirement to distinguish the semantically different kinds of \textbf{for} loops
for this purpose - we use one set of constructors. There are two ways in which the post-condition
can become a side condition: either requiring that the body post-condition must achieve the
required post-condition on the final iteration or requiring (in the presence of a till clause)
that the till condition imply the required post-condition.

¹Z
Ü  *)
Ü    VRForVia( VC_Route) |
Ü    VRForPreIntro |
Ü    VRForPreToSide |
Ü    VRForToSide( VC_Route ) |
Ü    VRForExitToSide( VC_Route) |
Ü (*
°

Exit clauses can be conditional or unconditional (only \textit{\slshape SR\_exit\_till\_intro} occurs)  and may exit a named loop or the enclosing loop. A Return clause imposes the return condition under hypotheses expressing the parameter context.
¹Z
Ü  *)
Ü    VRExitTillIntro(Z_STRING) |
Ü    VRExitVia( VC_Route) |
Ü    VRReturnIntro |
Ü (*
°

With procedure call \textit{wp} finds the specification statement and may add write-back
assignments. These will decorate the sequents as they are processed. It is easiest initially
to consider the procedure call as a nested construct so that we can identify the write-back
assignments and specification statments. Side conditions are also added for range checks on the
parameters.

¹Z
Ü  *)
Ü    VRProcCall( VC_Route) |
Ü    VRProcCallEnd( VC_Route) |
Ü    VRProcCallRngIntro |
Ü (*
°

Logical constants statements produce side conditions from the required post-condition and
introduce new sequents from the specification pre-condition and the type membership tests.

¹Z
Ü  *)
Ü    VRLogConToSide( VC_Route) |
Ü    VRLogConPreIntro |
Ü    VRLogConTypeMemIntro |
Ü (*
°



At the outer level we can have a refinement or a subprogram body. We mark these both as refinement as we can't tell the difference here, noting that
sequents are introduced at the bottom of these constructs.


¹Z
Ü  *)
Ü   VRRefinementBegin VC_Route |
Ü   VRRefinementIntro
°


\pagebreak
\section{THE STRUCTURE}\label{THESTRUCTURE}
\subsection{Preamble}
=DOC
signature ÛCNToolkitExtensionsİ = sig
=DESCRIBE
This is the signature for the toolkit extensions required by the Compliance Tool. It is specified in DRA/CIS/CSE3/TR/94/27/3.0.
=ENDDOC
=THDOC
req_name Û"cn"İ (Value "z_library");
req_language "Z";
set_flag("tc_thms_only",true);
=DESCRIBE
The theory $cn$ contains definitions specified in DRA/CIS/CSE3/TR/94/27/3.0.
It is created in structure $CNToolkitExtensions$.
The specification of the theory name, and the language of the theory is defined using $req\_name$ and $req\_language$. This conforms to the technique used in the rest of the {\Product} design documentation for specifying the requirement for theories.
=ENDDOC
\subsection{Theorems}\label{Theorems}
Theorems are provided which allow systematic expansion of the objects in the theory in terms of the Z toolkit operations.
These theorems serve to support the proof procedures defined in section \ref{ProofProcedures} below and may also be directly applied by the user.
\subsubsection{Booleans}
=THDOC
req_thm(Û"cn_boolean_thm"İ, ([], ñBOOLEAN = {FALSE, TRUE}®));
req_thm(Û"cn_boolean_succ_thm"İ, ([], ñBOOLEANvSUCC = {FALSE í TRUE}®));
req_thm(Û"cn_boolean_pred_thm"İ, ([], ñBOOLEANvPRED = {TRUE í FALSE}®));
req_thm(Û"cn_boolean_pos_thm"İ, ([], ñBOOLEANvPOS = id BOOLEAN®));
req_thm(Û"cn_boolean_val_thm"İ, ([], ñBOOLEANvVAL = id BOOLEAN®));
=DESCRIBE
These theorems, together with the definitions of:
=GFT
FALSE, TRUE, BOOLEANvFIRST, BOOLEANvLAST
=TEX
\ permit the values, sets and functions associated with the type $BOOLEAN$ to be simplified away.

To maintain the understandability of intermediate results, expansion of
$TRUE$ and $FALSE$ as the numbers $0$ and $1$ is avoided in
the proof procedures.
This approach is reflected in these theorems.
The definitions of $TRUE$ and $FALSE$ may always be used directly to translate them into $0$ and $1$ by the user, when (rarely) required.
=ENDDOC
=THDOC
req_thm(Û"cn_³_true_eq_false_thm"İ, ([], ñ³TRUE = FALSE®));
req_thm(Û"cn_boolean_cases_thm"İ, ([], ñµx:BOOLEAN· x = TRUE ² x = FALSE®));
req_thm(Û"cn_boolean__boolean_thm"İ, ([], ñµ x : ƒ · Boolean x  BOOLEAN®));
=DESCRIBE
These theorems give basic facts about the type $BOOLEAN$ which are required to justify the translation of Compliance Notation boolean expressions into Z predicates.
=ENDDOC
\subsubsection{Boolean Operators}
=THDOC
req_thm(Û"cn_boolean_clauses"İ, ([], ñ
	TRUE = Boolean true
±	FALSE = Boolean false
±	(µ p : ƒ · not Boolean p = Boolean ((³p)))
±	(µ p, q : ƒ · Boolean p and Boolean q = Boolean ((p ± q)))
±	(µ p, q : ƒ · Boolean p or Boolean q = Boolean ((p ² q)))
±	(µ p, q : ƒ · Boolean p xor Boolean q = Boolean ((³(p ¤ q))))
±	(µ p, q : ƒ · Boolean p = Boolean q ¤ (p ¤ q))
®));
=DESCRIBE
The strategy for handling the boolean operators is to convert an expression
in $not$, $and$, $or$, and $xor$, into an expression of the form
$Boolean\,p$, where $p$ is constructed using the Z propositional operators.
When such expressions appear as the operands of an equality, the whole predicate can be converted to a Z predicate not involving $Boolean$.

These theorems support this strategy.
They use the universal set $ƒ$ to make them easier to instantiate.
The cast $$ is a purely syntactic device used to allow a propositional connective in a function argument (see \cite{DS/FMU/IED/USR005}).
=SEEALSO
$cn\_boolean\_clauses1$, $cn\_boolean\_clauses2$.
=ENDDOC

=THDOC
req_thm(Û"cn_boolean_clauses1"İ, ([], ñ
	(µ x : BOOLEAN · (not x = Boolean ((³ x = Boolean true)))) ±
	(µ x, y : BOOLEAN ·
		(x and y) = Boolean (((x = Boolean true) ± (y = Boolean true)))) ±
	(µ x, y : BOOLEAN ·
		(x or y) = Boolean (((x = Boolean true) ² (y = Boolean true)))) ±
	(µ x, y : BOOLEAN ·
		(x xor y) = Boolean ((³ (x = Boolean true) ¤ (y = Boolean true))))
®));
=DESCRIBE
The strategy for handling the boolean operators is to convert an expression
in $not$, $and$, $or$, and $xor$, into an expression of the form
$Boolean\,p$, where $p$ is constructed using the Z propositional operators.
When such expressions appear as the operands of an equality, the whole predicate can be converted to a Z predicate not involving $Boolean$ (except applied to $true$).

This theorem, with $cn\_boolean\_clauses2$, support this strategy when one or both of the arguments of a boolean
operator are not of the form $Boolean\ x$ for some $x$.
In these cases, if the argument is known to be of type $BOOLEAN$
these theorems can be used.

One way to use the theorems in a tactic proof is if the leaves of a term created from the boolean operators are all associated with assumptions of the form $leaf  BOOLEAN$.
In this case the tactic:
=GFT
a(ALL_FC_T  (rewrite_tac) [cn_boolean_clauses1, cn_boolean_clauses2]);
=TEX
in a proof context also containing $cn\_boolean\_clauses$ as a rewrite rule,
will rewrite the term into one using Z boolean operators and predicates with the arguments equated to $Boolean\ true$, and with a single, outer, $Boolean$.
=EXAMPLE
E.g.
=GFT
(*  3 *)  ña  BOOLEAN®
(*  2 *)  ñb  BOOLEAN®
(*  1 *)  ñc  BOOLEAN®
(* ?ô *)  ñ... a and (b or c) ...®
with the above tactic applied becomes:
(*  3 *)  ña  BOOLEAN®
(*  2 *)  ñb  BOOLEAN®
(*  1 *)  ñc  BOOLEAN®
(* ?ô *)  ñ...Boolean((a = Boolean true) ± (b = Boolean true ² c = Boolean true))...®
=TEX
=ENDDOC
=THDOC
req_thm(Û"cn_boolean_clauses2"İ, ([], ñ
	(µ x : BOOLEAN ; p : ƒ ·
		(x and Boolean p) = Boolean (((x = Boolean true) ± p))) ±
	(µ x : BOOLEAN ; p : ƒ ·
		(Boolean p and x) = Boolean ((p ± (x = Boolean true)))) ±
	(µ x : BOOLEAN ; p : ƒ ·
		(x or Boolean p) = Boolean (((x = Boolean true) ² p))) ±
	(µ x : BOOLEAN ; p : ƒ ·
		(Boolean p or x) = Boolean ((p ² (x = Boolean true)))) ±
	(µ x : BOOLEAN ; p : ƒ ·
		(x xor Boolean p) = Boolean ((³ (x = Boolean true) ¤ p))) ±
	(µ x : BOOLEAN ; p : ƒ ·
		(Boolean p xor x) = Boolean ((³ p ¤ (x = Boolean true))))
®));
=DESCRIBE
See $cn\_boolean\_clauses1$ for use.
=ENDDOC
=THDOC
req_thm(Û"cn_and_then_or_else_clauses"İ, ([], ñ
	µx, y:ƒ·	(x and_then y) = (x and y) ± (x or_else y) = (x or y)
®));
=DESCRIBE
The operators {\it and\_then} and {\it or\_else} are dealt
with by rewriting them in terms of {\it and} and {\it or}.
=ENDDOC
\subsubsection{Relational Operators returning BOOLEANs}
=THDOC
req_thm(Û"cn_relational_clauses"İ, ([], ñ
	(µ x : ƒ; S : ƒ · x mem S = Boolean (x  S))
±	(µ x : ƒ; S : ƒ · x notmem S = Boolean ((³x  S)))
±	(µ x, y : ƒ · x eq y = Boolean (x = y))
±	(µ x, y : ƒ · x noteq y = Boolean ((³x = y)))
±	(µ x, y : ƒ · x less y = Boolean (x < y))
±	(µ x, y : ƒ · x less_eq y = Boolean (x ¼ y))
±	(µ x, y : ƒ · x greater y = Boolean (x > y))
±	(µ x, y : ƒ · x greater_eq y = Boolean (x ¾ y))
®));
=DESCRIBE
The strategy for handling the relational operators is to convert them into expressions of the form
$Boolean\,p$, where $p$ is an atomic Z predicate or the negation of one.

These theorems support this strategy.
They use the universal set $ƒ$ to make them easier to instantiate.
The cast $$ is a purely syntactic device used to allow a propositional connective in a function argument (see \cite{DS/FMU/IED/USR005}).
=ENDDOC
=THDOC
req_thm(Û"cn_relational_clauses1"İ, ([], ñ
	(µ x, y : ƒ · x real_less y = Boolean (x <‰R y))
±	(µ x, y : ƒ · x real_less_eq y = Boolean (x ¼‰R y))
±	(µ x, y : ƒ · x real_greater y = Boolean (x >‰R y))
±	(µ x, y : ƒ · x real_greater_eq y = Boolean (x ¾‰R y))
®));
=DESCRIBE
These theorems support the strategy for handling the relational operators withe real operands.
=ENDDOC


The effect of rewriting with the theorems presented in this section
and the previous section is shown in the following example,
in which we show how the expression ``%
=INLINEFT
N eq 0 or not N less 4 = TRUE
=TEX
'' is rewritten as ``%
=INLINEFT
N = 0 ² ³ N < 4
=TEX
''.
=GFT Rewriting Example
N eq 0 or not N less 4 = TRUE
1)	===> Boolean (N = 0) or not Boolean (N < 4) = Boolean true
2)	===> Boolean (N = 0) or Boolean (³ N < 4) = Boolean true
3)	===> Boolean (N = 0 ² ³ N < 4) = Boolean true
4)	===> N = 0 ² ³ N < 4 ¤ true
5)	===> N = 0 ² ³ N < 4
=TEX
Here in step 1 the theorem of this section starts thing off by turning the
Compliance Notation atomic predicates into Z expressions involving $Boolean$.
In steps 2 and 3, the theorems of the previous section turn
the vocabulary of the theory $cn$ into the Z toolkit vocabulary using the argument of $Boolean$ to accumulate the result.
At step 4 $Boolean$ is eliminated.
Finally a standard {\ProductZ} simplification removes the unnecessary ``%
=INLINEFT
¤ true
=TEX
''.
\subsubsection{Numeric Operators}
=THDOC
req_thm(Û"cn_intdiv_0_thm"İ,([], ñµ j: ú | ³j = 0 ·
	0 intdiv j = 0 ± 0 rem j = 0 ± 0 intmod j = 0®));
req_thm(Û"cn_intdiv_thm"İ,([], ñµ i,j,k : ú | ³j = 0 · (i intdiv j = k) ¤
	(¶ m : ú · i = k * j + m ± abs m < abs j
	± ((0 ¼ i ± 0 ¼ m ) ² (i < 0 ± m ¼ 0)) )®));
req_thm(Û"cn_rem_thm"İ,([], ñµ i,j,k : ú | ³j = 0 · (i rem j = k) ¤
	(¶ d : ú · i = d * j + k ± abs k < abs j
	± ((0 ¼ i ± 0 ¼ k ) ² (i < 0 ± k ¼ 0)) )®));
req_thm(Û"cn_intmod_thm"İ,([], ñµ i,j,k : ú | ³j = 0 · (i intmod j = k) ¤
	(¶ d : ú · i = d * j + k ± abs k < abs j
	± ((0 ¼ j ± 0 ¼ k ) ² (j < 0 ± k ¼ 0)) )®));
=DESCRIBE
These theorems provide support for reasoning about $intmod$, $intdiv$ and $rem$.
=ENDDOC
=THDOC
req_thm(Û"z_succçnê_»_thm"İ, ([], ñµ x : ƒ; y : ƒ ·
	(succ ç x ê » y) =
		{ a : ƒ; b : ƒ |
		((1 ¼ x ± 0 ¼ a) ² (³ (0 ¼ x) ± ((0 - x) ¼ a)) ² (x = 0));
		(a + x, b)  y ·
		(a, b)}
	®));
=DESCRIBE
This is useful for handling array aggregate definitions.
=ENDDOC
=THDOC
req_thm(Û"cn_integer_to_real_thm"İ, ([], ñ
	µ x : ú · integer_to_real x = real x
®));
=DESCRIBE
This theorems act as a rewrite rule to
recast a compliance notation global variable
in terms of the underlying Z ones.
=ENDDOC
\subsubsection{Integers}
Since there are no defining properties for the $INTEGER$ etc., no useful theorems can be provided.
Such theorems would have to be derived from additional axioms asserted by the user, perhaps representing the relevant parameters for a particular Ada compiler.
\subsection{ML Bindings for Theorems}
=DOC
val Ûcn_boolean_cases_thmİ : THM;
val Ûcn_boolean_clausesİ : THM;
val Ûcn_boolean_clauses1İ : THM;
val Ûcn_boolean_clauses2İ : THM;
val Ûcn_and_then_or_else_clausesİ : THM;
val Ûcn_boolean_pos_thmİ : THM;
val Ûcn_boolean_pred_thmİ : THM;
val Ûcn_boolean_succ_thmİ : THM;
val Ûcn_boolean_thmİ : THM;
val Ûcn_boolean__boolean_thmİ : THM;
val Ûcn_boolean_val_thmİ : THM;
val Ûcn_relational_clausesİ : THM;
val Ûcn_relational_clauses1İ : THM;
val Ûcn_³_true_eq_false_thmİ : THM;
val Ûcn_intdiv_0_thmİ : THM;	
val Ûcn_intdiv_thmİ : THM;
val Ûcn_rem_thmİ : THM;
val Ûcn_intmod_thmİ : THM;
val Ûz_succçnê_»_thmİ : THM;
val Ûcn_integer_to_real_thmİ : THM;
=DESCRIBE
These are the ML names for the theorems in the theory ``$cn$'', which contains
extensions to the Z toolkit required to support the Compliance Notation.
=ENDDOC
\subsection{Proof Procedures}\label{ProofProcedures}
\subsubsection{Syntax Manipulation}
In coding proof procedures such as constant expression evaluators it is sometimes convenient to have functions to manipulate the syntax of the expressions in question.
The rewrite rules of section \ref{Theorems} are such that customised syntax functions will only be required for the numeric operators.
The boolean and relational operators are turned fairly directly into Z and will not need detailed syntax manipulation.

=DOC
val Ûmk_cn_intdivİ : TERM * TERM -> TERM;
val Ûmk_cn_remİ : TERM * TERM -> TERM;
val Ûmk_cn_intmodİ : TERM * TERM -> TERM;
val Ûmk_cn_star_starİ : TERM * TERM -> TERM;
val Ûdest_cn_intdivİ : TERM -> TERM * TERM;
val Ûdest_cn_remİ : TERM -> TERM * TERM;
val Ûdest_cn_intmodİ : TERM -> TERM * TERM;
val Ûdest_cn_star_starİ : TERM -> TERM * TERM;
val Ûis_cn_intdivİ : TERM -> bool;
val Ûis_cn_remİ : TERM -> bool;
val Ûis_cn_intmodİ : TERM -> bool;
val Ûis_cn_star_starİ : TERM -> bool;
=DESCRIBE
These are constructor, destructor and discriminator functions for the operators which support the numeric operations of the Compliance Notation.
=FAILURE
509001	?0 does not have type ú
509002	?0 is not of the form ñi intdiv j®
509003	?0 is not of the form ñi rem j®
509004	?0 is not of the form ñi intmod j®
509005	?0 is not of the form ñi ** j®
=ENDDOC
\subsubsection{Constant Expression Evaluation}
The rewrite rules of section \ref{Theorems} reduce everything except the numeric operators to a form where the facilities for evaluating Z constant expressions will do what is required.
=DOC
val Ûcn_intdiv_convİ : CONV;
val Ûcn_rem_convİ : CONV;
val Ûcn_intmod_convİ : CONV;
val Ûcn_star_star_convİ : CONV;
=DESCRIBE
These conversions  perform evaluation of expressions with constant operands formed using the operators which support the numeric operations of the Compliance Notation.

Each conversion expects an
expression of the form $i\,op\,j$ where $op$ is
one of $intdiv$, $rem$, $intmod$, or $**$, and where $i$
and $j$ are signed integer literals (i.e., either numeric literals or of the form
=INLINEFT
~k
=TEX
, where $k$ is a numeric literal).
The resulting theorem has conclusion $i\,op\,j\,=\,r$, where $r$ is the signed literal resulting from evaluating the expression.

=FAILURE
509011	?0 is not of the form ñi intdiv j® where ñi® and ñj® are numeric literals
509012	?0 is not of the form ñi rem j® where ñi® and ñj® are numeric literals
509013	?0 is not of the form ñi intmod j® where ñi® and ñj® are numeric literals
509014	?0 is not of the form ñi ** j® where ñi® and ñj® are numeric literals
=ENDDOC
=DOC
val Ûcn_mod_and_convİ : CONV;
val Ûcn_mod_or_convİ : CONV;
val Ûcn_mod_xor_convİ : CONV;
val Ûcn_mod_not_convİ : CONV;
=DESCRIBE
These conversions  perform evaluation of expressions with constant operands formed using the operators which support the numeric operations of the Compliance Notation.

Each conversion expects an
expression of the form $i\,op\,j$ or $mod\_not\,i$, where $op$ is
one of $mod\_and$, $mod\_or$, $mod\_xor$ and where $i$
and $j$ are signed integer literals (i.e., either numeric literals or of the form
=INLINEFT
~k
=TEX
, where $k$ is a numeric literal).
The resulting theorem has conclusion $i\,op\,j\,=\,r$, where $r$ is the signed literal resulting from evaluating the expression.

=FAILURE
509021	?0 is not of the form ñi mod_and j® where ñi® and ñj® are numeric literals
509022	?0 is not of the form ñi mod_or j® where ñi® and ñj® are numeric literals
509023	?0 is not of the form ñi mod_xor j® where ñi® and ñj® are numeric literals
509024	?0 is not of the form ñmod_not i® where ñi® is a numeric literal
=ENDDOC
\subsubsection{Proof Contexts}\label{ProofContexts}

NOTE: The proof contexts $cn1'$ etc. are actually defined in \cite{ISS/HAT/DAZ/IMP518}. They are described here for convenience of
the user reading reference documentation derived from this document.
=DOC
(* Proof Context: Û'cnİ *)
(* Proof Context: Û'cn1İ *)
=DESCRIBE
Component proof context for the theory $cn$ which supports the Compliance Notation.
$'cn1$ is a slightly improved version of the original $'cn$.

The main purpose of these proof contexts is to automate the elimination of the vocabulary of the theory $cn$ in favour of plain Z toolkit constructs wherever this is possible without introducing excessive complexity.

Expressions and predicates treated by the proof contexts are constructs formed from:
=GFT
not _, _ and _, _ or _, _ xor _, , _ and_then _, _ or_else _,
_ mem _, _ notmem _, _ eq _, _ noteq _,
_ less _, _ less_eq _, _ greater _, _ greater_eq _,
_ intdiv _, _ rem _, _ ** _, _ mod_and _, _ mod_or _,
_ mod_xor _, _mod_not
=TEX

\paragraph{Contents}\

Rewriting:
=GFT
cn_boolean_thm (cn only), cn_boolean_succ_thm, cn_boolean_pred_thm,
cn_boolean_pos_thm, cn_boolean_val_thm,
cn_boolean_clauses, cn_relational_clauses,
cn_intdiv_conv, cn_rem_conv, cn_intmod_conv, cn_star_star_conv
cn_boolean__boolean_thm (cn1 only)
z_size_dot_dot_conv (cn1 only)
cn_and_then_or_else_clauses
=TEX
Stripping theorems:
(none)
=SEEALSO
$cn$, $cn\_ext$
=ENDDOC
=DOC
(* Proof Context: Û'cn_realsİ *)
=DESCRIBE
Component proof context for the theory $cn$ which supports the Compliance Notation
treatment of Ada fixed and floating point types.

The purpose of the proof context is to automate the elimination of the vocabulary of the theory $cn$ concerned with real numbers
in favour of plain Z toolkit constructs wherever this is possible without introducing excessive complexity.

Expressions and predicates treated by the proof contexts are constructs formed from
the Z real arithmetic operators and the Compliance Notation operators
=INLINEFT
_e_, integer_to_real
=TEX
\ and
=INLINEFT
integer_to_real
=TEX
.

This proof context will typically be used in conjunction with one of the other Compliance Notation
proof contexts and the proof context for the Z real numbers. E.g.,
=GFT
set_merge_pcs["'cn_reals", "'z_reals", "cn"];
=TEX
\paragraph{Contents}\

Rewriting:
=GFT
cn_e_0_thm
cn_relational_clauses1
cn_integer_to_real_thm
=TEX
Stripping theorems:
=GFT
cn_relational_clauses1
=SEEALSO
$'cn$, $'cn1$
=ENDDOC
=DOC
(* Proof Context: Ûcnİ *)
(* Proof Context: Ûcn_extİ *)
(* Proof Context: Ûcn1İ *)
(* Proof Context: Ûcn1_extİ *)
=DESCRIBE
Complete proofs context for the theory $cn$ which supports the Compliance Notation.
$cn1$ is the recommended proof context for normal use while reasoning about VCs generated  by the compliance tool.
$cn$ is still provided for backwards compatibility.

$cn1$ is the merge of the component proof contexts $'cn1$ and $z\_library1$.
$cn1\_ext$ is the merge of the component proof contexts $'cn$ and $z\_library1\_ext$.

$cn$ is the merge of the component proof contexts $'cn$ and $z\_library$.
$cn\_ext$ is the merge of the component proof contexts $'cn$ and $z\_library\_ext$.
=SEEALSO
$'cn1$, $'cn$, $z\_library1$, $z\_library1\_ext$
=ENDDOC

\subsection{Epilogue}
=SML
end (* end of signature CNToolkitExtensions *);
=TEX
=SML
reset_flag ("z_type_check_only");
reset_flag ("z_use_axioms");
reset_flag("standard_z_paras");
=TEX


=TEX
\section{TEST POLICY}

The module tests for this module are to follow the guidelines
identified in the quality plan~\cite{ISS/HAT/DAZ/PLN003}.
There are no special testing considerations.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



