% %Z% $Date$ $Revision$ $RCSfile$

=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Variable Capture Test Material}  %% Mandatory field
\def\TPPheadtitle{Variable Capture Test Material}
\TPPref{ISS/HAT/DAZ/INT507}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
%\TPPkeywords{HOL}
\TPPauthor{A.C.~Hayward & HAT Team}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & WIN01}
\TPPabstract{%
This document gives a number of compliance notation scripts.  The Z documents generated by these scripts are checked against the original scripts.
}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\pagebreak
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'

\begin{description}

\item[Issue 1.1 (\FormatDate{94/12/19})] Initial Draft.

\end{description}

\subsection{Changes Forecast}

None.

\pagebreak

\section{GENERAL}

\subsection{Scope}

This document contains test data for the Compliance Tool as specified in \cite{ISS/HAT/DAZ/HLD501}.

\subsection{Introduction}

This document contains a number of compliance notation scripts.  These are loaded into the compliance tool and Z documents generated.  The Z documents are then reloading into the tool and compared with the original scripts.

\section{LITERAL SCRIPTS}

\subsection{Setting up of the enivronment}

Set up flags so the compilance tool works correctly .

=SML
set_flags [("z_type_check_only", false),("z_use_axioms", true)];
=TEX

Load the test harness.

=SML
use_file "dtd013";
use_file "imp013";
=TEX

\subsection{Useful functions}

Functions for recording some statistics of theories.

=SML
type theory_stats = {np : int, ng : int, na : int, nd : int, nc : int};
local
    fun noof_parents thy = (length o get_parents) thy;
    fun noof_global thy = (length o get_consts) thy;
    fun noof_axioms thy = (length o get_axioms) thy;
    fun noof_defns thy = (length o get_defns) thy;
    fun noof_conjectures thy = (length o get_conjectures) thy;
in
    fun get_theory_stats (thy : string) : theory_stats =
    let
        val np = noof_parents thy;
        val ng = noof_global thy;
        val na = noof_axioms thy;
        val nd = noof_defns thy;
        val nc = noof_conjectures thy;
    in
        {np = np, ng = ng, na = na, nd = nd, nc = nc}
    end;
end;
=TEX

\subsection{First literal script}

=SML
new_script "int507A";
=TEX

¹CN
procedure P is
   A : INTEGER;
   procedure Q
   „ A [A = 3]
   is
      A : INTEGER;
   begin
      A := 3;
   end Q;
begin
   „ A [A = 5]
end P;
°

¹CN
Ã  A := 10;
   Q;
   A := A + 2;
°

=SML
output_z_document{script="int507A", out_file="int507A.sml"};
output_spark_program{out_file="int507A.ada"};
=TEX

\section{LITERATE SCRIPT 2}

=SML
new_script "int507B";
=TEX

¹CN
procedure P is
   A : INTEGER;
   function F return INTEGER
   „ [F = 3]
   is
   begin
      return 3;
   end F;
   procedure Q
   „ A [A = F]
   is
      F : INTEGER;
   begin
      F := 20;
      A := F;
   end Q;
begin
   „ A [A = 7]
end P;
°

¹CN
Ã  Q;
   A := A + 4;
°

=SML
output_z_document{script="int507B", out_file="int507B.sml"};
output_spark_program{out_file="int507B.ada"};
=TEX

\section{LITERATE SCRIPT 3}

=SML
new_script "int507C";
=TEX

¹CN
procedure P is
   A, B : INTEGER;
begin
   A := 7;
   B := 1;
   „ A, B [A = A‰0 + 2 ± B = B‰0 + 10]				(1)
end P;
°

¹CN
(1) Ã con X : ú · „ A, B [X = A, A = X + 2 ± B = B‰0 + 10]	(2)
°

¹CN
(2) Ã con X : ú · „ A, B [X = B, A = X + 2 ± B = X + 10]	(3)
°

¹CN
(3) Ã
      A := B + 2;
      B := B + 10;
°

=SML
output_z_document{script="int507C", out_file="int507C.sml"};
output_spark_program{out_file="int507C.ada"};
=TEX

\section{LITERATE SCRIPT 4}

=SML
new_script "int507D";
=TEX

¹CN
procedure P is
   A, X : INTEGER;
begin
   A := 17;
   X := 11;
   „ A [A = A‰0 + X]					(1)
end P;
°

¹CN
(1) Ã con X : ú · „ A [X = A, A = X + X]		(2)
°

¹CN
(2) Ã A := A + A;
°

=SML
output_z_document{script="int507D", out_file="int507D.sml"};
output_spark_program{out_file="int507D.ada"};
=TEX

\section{LITERATE SCRIPT 5}

=SML
new_script "int507E";
=TEX

¹CN
package STACK is
   auxiliary S : seq ú;
   auxiliary MAX : î;
   procedure PUSH (X : in INTEGER)
   „ S, MAX [MAX = MAX‰0 + 1 ± S = S‰0 « {MAX í X}];
end STACK;
°

¹CN
package body STACK is
   using
   subtype STACK_RANGE is INTEGER range 1..10;
   type STACK_TYPE is array (STACK_RANGE) of INTEGER;
   S : STACK_TYPE;
   implement S by S = S;
   using
   subtype TOP_RANGE is INTEGER range 0..10;
   TOP : TOP_RANGE;
   implement MAX by MAX = TOP;
   procedure PUSH (X : in INTEGER)
   „ TOP [TOP = TOP‰0 + 1]
   is
   begin
      TOP := TOP + 1;
   end PUSH;
begin
   TOP := 0;
end STACK;
°

=SML
output_z_document{script="int507E", out_file="int507E.sml"};
output_spark_program{out_file="int507E.ada"};
=TEX

\section{Checks}

Save copies of the theory statistics.

=SML
val int507A_stats = get_theory_stats "int507A";
val int507B_stats = get_theory_stats "int507B";
val int507C_stats = get_theory_stats "int507C";
val int507D_stats = get_theory_stats "int507D";
val int507E_stats = get_theory_stats "int507E";
=TEX

Output the Z documents to disk.

=SML
output_z_document {script="int507A", out_file="int507A.sml"};
output_z_document {script="int507B", out_file="int507B.sml"};
output_z_document {script="int507C", out_file="int507C.sml"};
output_z_document {script="int507D", out_file="int507D.sml"};
output_z_document {script="int507E", out_file="int507E.sml"};
=TEX

Delete all the theories we've created.

=SML
open_theory "cn";
delete_theory "int507A";
delete_theory "int507B";
delete_theory "int507C";
delete_theory "int507D";
delete_theory "int507E";
=TEX

Reload the Z documents.

=SML
fun Ûuse_file_auxÝ (file : string) = (
    open_theory "cn";
    use_file file
    handle _ => ()
    );
use_file "int507A";
use_file "int507B";
use_file "int507C";
use_file "int507D";
use_file "int507E";
=TEX

Check the theory statistics are correct.

=SML
store_mt_results_show mt_run [
    ("int507A", get_theory_stats, "int507A", int507A_stats),
    ("int507B", get_theory_stats, "int507B", int507B_stats),
    ("int507C", get_theory_stats, "int507C", int507C_stats),
    ("int507D", get_theory_stats, "int507D", int507D_stats),
    ("int507E", get_theory_stats, "int507E", int507E_stats)];
=TEX

\section{EPILOGUE}
=SML
diag_line (summarize_mt_results());
=TEX

\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}
=IGN
