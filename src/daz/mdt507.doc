=IGN
********************************************************************************
mdt507.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% %Z% $Revision: 1.34 $ $RCSfile: mdt507.doc,v $ $Date: 2005/09/15 16:09:33 $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Z Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT507}  %% Mandatory field
\def\SCCSversion{$Revision: 1.34 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2005/09/15 16:09:33 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthor{K.~Blackburn & WIN01}
\TPPauthorisation{R.D.~Arthan & DAZ Manager}
\TPPabstract{This document contains tests for theory hierarchy material
implemented in the Z Generator material.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item[Issue 1.1-1.2]
First drafts.
\item[Issue 1.3]
Change to one compilation unit per script.
\item[Issue 1.4]
IUCT WP 2 changes.
\item[Issue 1.5]
Checking Check 17.
\item[Issue 1.6]
Adding renaming in specifications material.
\item[Issue 1.7 - 1.9]
Changes from IUCT WP 2 and WP 7.
\item[Issue 1.10]
Clashes between formal parameters and variables or constants.
\item[Issue 1.11-12]
IUCT WP 3 changes.
\item[Issue 1.13]
IUCT WP 5 changes.
\item[Issue 1.14]
IUCT WP 3 - references clauses package names must exist test.
\item[Issue 1.15,1.16]
IUCT WP 3 - extra references clauses required now $pack\_spec\_with\_modules$
has gone away.
\item[Issue 1.17]
Added tests for $print\_z\_document$ and $z\_prefix$ for non-axiomatic mode
definitions.
Added tests for references.
\item[Issue 1.18] CTLE II R2/1: global variable unsoundness.
\item[Issue 1.19] R0065: duplicate names now allowed in context clauses.
\item[Issue 1.20] {\it ExtendedIO.execute} has now been withdrawn.
\item[Issue 1.21] Allowed for slightly different error behavour as a result of spring 2002 enhancements..
\item[Issue 1.22] Copyright and banner updates for open source release.
\item[Issue 1.23] DAZ-specific updates to banner for open source release
\item[Issue 1.24] DAZ-specific updates to banner for open source release
\item[Issue 1.25] No longer relies on default setting for case of Ada keywords.
\item[Issue 1.26] Allowed for improved early type-checking of specification statements.
\item[Issue 1.27] Fixed broken test ``refer1.11''.
\item[Issue 1.28] The SPARK program is now referred to as the Ada program.
\item[Issues 1.29, 1.30] Allowed for some changed error messages.
\item[Issue 1.31] Fixed error in test on procedure renaming
\item[Issue 1.32] Compliance Notation reserved words are now prefixed by a dollar sign.
\item[Issues 1.33, 1.34] Allowed for enhanced error messages.
\item[Issues 1.35] Allowed for corrections to error analysis.
\end{description}
\subsection{Changes forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains module tests for theory hierarchy 
effects of the functions defined 
in \cite{ISS/HAT/DAZ/DTD507}.
\subsection{Introduction}
\subsubsection{Background and Purpose}
See \cite{ISS/HAT/DAZ/DTD507}. 
In general the material in this document is tested by the various
integration test documents in the DAZ project.
However, the changes in theory hierarchy structure caused by $new\_script1$
and other functions is not tested elsewhere.
\subsubsection{Dependencies}
These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.

The tests rely on ISS/HAT/DAZ/IMP516, or require the $CNZGenerator$ 
structure to be opened.

\subsubsection{Possible Enhancements}
None known.
\subsubsection{Deficiencies}
None known.

\section{PREAMBLE}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results();
=TEX
\section{THE TESTS}
We use upper case for Ada keywords in the tests:
=SML
set_string_control("case_of_ada_keywords", "upper");
=TEX
\subsection{Useful functions}
=SML
fun clean_up () = (
        let     val thys = (get_descendants "cn" less "cn")
                                        diff get_cache_theories();
                fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
        in      map del_thy thys
        end;    ()
);
=TEX
=SML
fun sl_format (sl : string list) : string = format_list Combinators.I sl ", ";
=TEX

\subsection{$new\_script$}
First check that we really need to use $new\_script$:
=SML
clean_up();
fun cn_created1 () = 
¹CN
package cn_created is
	VAR1 : INTEGER;
end cn_created;
°
=SML
store_mt_results_show mt_run_fail [
	("cn_created1", cn_created1, (), 
		gen_fail_msg "check17" 507056 [
			"CN_CREATED (internal specification)",
			"cn"])
];
=SML
new_theory "temp";
fun cn_created2 () = 
¹CN
package cn_created is
	VAR1 : INTEGER;
end cn_created;
°
=SML
store_mt_results mt_run_fail [
	("cn_created2", cn_created1, (), 
		gen_fail_msg "check17" 507056 [
			"CN_CREATED (internal specification)",
			"temp"])
];
=SML
clean_up();
new_script{name = "mdt507ns_1", state=initial_cn_state};
=TEX
¹CN
package mdt507NS_1_1 is
	VAR1 : INTEGER;

	procedure TEST1 (M : out INTEGER)
	„ M ˜ VAR1 [VAR1 = 0, M = 0];

end mdt507NS_1_1;
°
=SML
store_mt_results mt_run [
	("ns_1_1a_gp", sl_format o get_parents, "mdt507ns_1", "cn"),
	("ns_1_1a_gc", sl_format o get_children, "mdt507ns_1", ""),
	("ns_1_1a_gcnc", sl_format o get_children, "cn", "mdt507ns_1")
	
];
=TEX
=SML 
val statea = get_cn_state();
new_script{name = "mdt507ns_1a", state=statea};
¹CN
 with mdt507NS_1_1;
  procedure TEST2
  is
  begin
       mdt507NS_1_1.VAR1 := 0;
  end TEST2;
°
=SML
store_mt_results_show mt_run [
	("ns_1_1b_gp", sl_format o get_parents, "mdt507ns_1a", 
		"MDT507NS_1_1spec, cn"),
	("ns_1_1b_gc", sl_format o get_children, "mdt507ns_1a", ""),
	("ns_1_1b_gcnc", sl_format o get_children, "cn", 
		"MDT507NS_1_1spec, mdt507ns_1a, mdt507ns_1")
];
=TEX
=SML 
val stateb = get_cn_state();
new_script{name = "mdt507ns_1b", state=stateb};
¹CN
package body mdt507NS_1_1 is

	procedure TEST1 (M : out INTEGER)
	„ M ˜ VAR1 [VAR1 = 0, M = 0]
	is
	begin
		M := VAR1;
	end TEST1;

begin
	VAR1 := 2;

end mdt507NS_1_1;
°
=SML
store_mt_results mt_run [
	("ns_1_1c_gp", sl_format o get_parents, "mdt507ns_1b", 
		"mdt507ns_1, cn"),
	("ns_1_1c_gc", sl_format o get_children, "mdt507ns_1b", ""),
	("ns_1_1c_gcnc", sl_format o get_children, "cn", 
		"mdt507ns_1b, MDT507NS_1_1spec, mdt507ns_1a, mdt507ns_1")	
];

=TEX
=SML 
val statec = get_cn_state();
new_script{name = "mdt507ns_1c", state=statec};
¹CN
 procedure TEST3 is
    VAR2 : INTEGER;
    procedure TEST4 is separate;
    function TEST5 (I : INTEGER) return INTEGER is separate;
 begin
    null;
    TEST4;
    VAR2 := TEST5( 0 );
 end TEST3;
°
=SML
store_mt_results mt_run [
	("ns_1_1d_gp", sl_format o get_parents, "mdt507ns_1c", 
		"cn"),
	("ns_1_1d_gc", sl_format o get_children, "mdt507ns_1c", ""),
	("ns_1_1d_gcnc", sl_format o get_children, "cn", 
		"TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns_1c, mdt507ns_1b, MDT507NS_1_1spec, mdt507ns_1a, mdt507ns_1"),
	("ns_1_1d_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"cn"),
	("ns_1_1d_gcstub", sl_format o get_children, "TEST3oTEST5stub", "")
];
=TEX
=SML
val state_ns_1 = get_cn_state();
new_script{name="mdt507ns_2", state=state_ns_1};
¹CN
 separate (TEST3)
    procedure TEST4 is begin VAR2 := 1; end TEST4;
°
=SML
store_mt_results mt_run [
	("ns_1_1e_gp", sl_format o get_parents, "mdt507ns_2", 
		"TEST3oTEST4stub, cn"),
	("ns_1_1e_gc", sl_format o get_children, "mdt507ns_2", ""),
	("ns_1_1e_gcnc", sl_format o get_children, "cn", 
"mdt507ns_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns_1c, mdt507ns_1b, MDT507NS_1_1spec, mdt507ns_1a, mdt507ns_1"),
	("ns_1_1e_gpstub", sl_format o get_parents, "TEST3oTEST4stub", 
		"cn"),
	("ns_1_1e_gcstub", sl_format o get_children, "TEST3oTEST4stub",
		"mdt507ns_2")
];

=TEX
=SML
val state_ns_2 = get_cn_state();
new_script{name="mdt507ns_3", state=state_ns_2};
¹CN
 separate (TEST3)
    function TEST5 (I : INTEGER) return INTEGER is
    begin return 0; end TEST5;
°
=SML
store_mt_results mt_run [
	("ns_1_1f_gp", sl_format o get_parents, "mdt507ns_3", 
		"TEST3oTEST5stub, cn"),
	("ns_1_1f_gc", sl_format o get_children, "mdt507ns_3", ""),
	("ns_1_1f_gcnc", sl_format o get_children, "cn", 
"mdt507ns_3, mdt507ns_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns_1c, mdt507ns_1b, MDT507NS_1_1spec, mdt507ns_1a, mdt507ns_1"),
	("ns_1_1f_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"cn"),
	("ns_1_1f_gcstub", sl_format o get_children, "TEST3oTEST5stub",
		"mdt507ns_3")
];
=TEX
\subsection{$new\_script1$ - No Library theories}
=SML
clean_up();
new_script1{name = "mdt507ns1_1", state=initial_cn_state, library_theories=[]};
=TEX
¹CN
package mdt507NS_1_1 is
	VAR1 : INTEGER;

	procedure TEST1 (M : out INTEGER)
	„ M ˜ VAR1 [VAR1 = 0, M = 0];

end mdt507NS_1_1;
°
=SML
store_mt_results mt_run [
	("ns1_1_1a_gp", sl_format o get_parents, "mdt507ns1_1", "cn"),
	("ns1_1_1a_gc", sl_format o get_children, "mdt507ns1_1", ""),
	("ns1_1_1a_gcnc", sl_format o get_children, "cn", "mdt507ns1_1")
	
];
=TEX
=SML
val statea = get_cn_state();
new_script1{name = "mdt507ns1_1a", state=statea, library_theories=[]};
¹CN
 with mdt507NS_1_1;
  procedure TEST2
  is
  begin
       mdt507NS_1_1.VAR1 := 0;
  end TEST2;
°
=SML
store_mt_results mt_run [
	("ns1_1_1b_gp", sl_format o get_parents, "mdt507ns1_1a", 
		"MDT507NS_1_1spec, cn"),
	("ns1_1_1b_gc", sl_format o get_children, "mdt507ns1_1a", ""),
	("ns1_1_1b_gcnc", sl_format o get_children, "cn", 
		"MDT507NS_1_1spec, mdt507ns1_1a, mdt507ns1_1")
	
];
=TEX
=SML
val stateb = get_cn_state();
new_script1{name = "mdt507ns1_1b", state=stateb, library_theories=[]};
¹CN
package body mdt507NS_1_1 is

	procedure TEST1 (M : out INTEGER)
	„ M ˜ VAR1 [VAR1 = 0, M = 0]
	is
	begin
		M := VAR1;
	end TEST1;

begin
	VAR1 := 2;

end mdt507NS_1_1;
°
=SML
store_mt_results mt_run [
	("ns1_1_1c_gp", sl_format o get_parents, "mdt507ns1_1b", 
		"mdt507ns1_1, cn"),
	("ns1_1_1c_gc", sl_format o get_children, "mdt507ns1_1b", ""),
	("ns1_1_1c_gcnc", sl_format o get_children, "cn", 
		"mdt507ns1_1b, MDT507NS_1_1spec, mdt507ns1_1a, mdt507ns1_1")	
];
=TEX
=SML
val statec = get_cn_state();
new_script1{name = "mdt507ns1_1c", state=statec, library_theories=[]};
¹CN
 procedure TEST3 is
    VAR2 : INTEGER;
    procedure TEST4 is separate;
    function TEST5 (I : INTEGER) return INTEGER is separate;
 begin
    null;
    TEST4;
    VAR2 := TEST5( 0 );
 end TEST3;
°
=SML
store_mt_results mt_run [
	("ns1_1_1d_gp", sl_format o get_parents, "mdt507ns1_1c", 
		"cn"),
	("ns1_1_1d_gc", sl_format o get_children, "mdt507ns1_1c", ""),
	("ns1_1_1d_gcnc", sl_format o get_children, "cn", 
		"TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1_1c, mdt507ns1_1b, MDT507NS_1_1spec, mdt507ns1_1a, mdt507ns1_1"),
	("ns1_1_1d_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"cn"),
	("ns1_1_1d_gcstub", sl_format o get_children, "TEST3oTEST5stub", "")
];
=TEX
=SML
val state_ns1_1 = get_cn_state();
new_script1{name="mdt507ns1_2", state=state_ns1_1, library_theories=[]};
¹CN
 separate (TEST3)
    procedure TEST4 is begin VAR2 := 1; end TEST4;
°
=SML
store_mt_results mt_run [
	("ns1_1_1e_gp", sl_format o get_parents, "mdt507ns1_2", 
		"TEST3oTEST4stub, cn"),
	("ns1_1_1e_gc", sl_format o get_children, "mdt507ns1_2", ""),
	("ns1_1_1e_gcnc", sl_format o get_children, "cn", 
"mdt507ns1_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1_1c, mdt507ns1_1b, MDT507NS_1_1spec, mdt507ns1_1a, mdt507ns1_1"),
	("ns1_1_1e_gpstub", sl_format o get_parents, "TEST3oTEST4stub", 
		"cn"),
	("ns1_1_1e_gcstub", sl_format o get_children, "TEST3oTEST4stub",
		"mdt507ns1_2")
];

=TEX
=SML
val state_ns1_2 = get_cn_state();
new_script1{name="mdt507ns1_3", state=state_ns1_2, library_theories=[]};
¹CN
 separate (TEST3)
    function TEST5 (I : INTEGER) return INTEGER is
    begin return 0; end TEST5;
°
=SML
store_mt_results_show mt_run [
	("ns1_1_1f_gp", sl_format o get_parents, "mdt507ns1_3", 
		"TEST3oTEST5stub, cn"),
	("ns1_1_1f_gc", sl_format o get_children, "mdt507ns1_3", ""),
	("ns1_1_1f_gcnc", sl_format o get_children, "cn", 
"mdt507ns1_3, mdt507ns1_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1_1c, mdt507ns1_1b, MDT507NS_1_1spec, mdt507ns1_1a, mdt507ns1_1"),
	("ns1_1_1f_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"cn"),
	("ns1_1_1f_gcstub", sl_format o get_children, "TEST3oTEST5stub",
		"mdt507ns1_3")
];
=TEX
\subsection{$new\_script1$ - Two Library theories}
=SML
clean_up();
new_theory "A";
=TEX
¹Z
Ü ABST1 ::= Abs1
°
=SML
open_theory "cn";
new_theory "B";
=TEX
¹Z
Ü ABST2 ::= Abs2
°
=SML
open_theory "cn";
new_theory "C";
=TEX
¹Z
Ü ABST3 ::= Abs3
°
=SML
new_script1{name = "mdt507ns1x2_1", state=initial_cn_state, library_theories=["A", "B"]};
=TEX
¹CN
package mdt507NS1X2_1_1 is
	VAR1 : INTEGER;

	procedure TEST1 (M : out INTEGER)
	„ M ˜ VAR1 [VAR1 = 0, M = 0];

end mdt507NS1X2_1_1;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1a_gp", sl_format o get_parents, "mdt507ns1x2_1", "B, A, cn"),
	("ns1x2_1_1a_gc", sl_format o get_children, "mdt507ns1x2_1", ""),
	("ns1x2_1_1a_gcnc", sl_format o get_children, "cn", "mdt507ns1x2_1, C, B, A")	
];
=TEX
=SML
val statea = get_cn_state();
new_script1{name = "mdt507ns1x2_1a", state=statea, library_theories=["A", "B"]};
¹CN
 with mdt507NS1X2_1_1;
  procedure TEST2
  is
  begin
       mdt507NS1X2_1_1.VAR1 := 0;
  end TEST2;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1b_gp", sl_format o get_parents, "mdt507ns1x2_1a", 
		"MDT507NS1X2_1_1spec, B, A, cn"),
	("ns1x2_1_1b_gc", sl_format o get_children, "mdt507ns1x2_1a", ""),
	("ns1x2_1_1b_gcnc", sl_format o get_children, "cn", 
		"MDT507NS1X2_1_1spec, mdt507ns1x2_1a, mdt507ns1x2_1, C, B, A")
];
=TEX
=SML
val stateb = get_cn_state();
new_script1{name = "mdt507ns1x2_1b", state=stateb, library_theories=["A", "B"]};
¹CN
package body mdt507NS1X2_1_1 is

	procedure TEST1 (M : out INTEGER)
	„ M ˜ VAR1 [VAR1 = 0, M = 0]
	is
	begin
		M := VAR1;
	end TEST1;

begin
	VAR1 := 2;

end mdt507NS1X2_1_1;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1c_gp", sl_format o get_parents, "mdt507ns1x2_1b", 
		"mdt507ns1x2_1, B, A, cn"),
	("ns1x2_1_1c_gc", sl_format o get_children, "mdt507ns1x2_1b", ""),
	("ns1x2_1_1c_gcnc", sl_format o get_children, "cn", 
	"mdt507ns1x2_1b, MDT507NS1X2_1_1spec, mdt507ns1x2_1a, mdt507ns1x2_1, C, B, A")	
];
=TEX
=SML
val statec = get_cn_state();
new_script1{name = "mdt507ns1x2_1c", state=statec, library_theories=["A", "B"]};
¹CN
 procedure TEST3 is
    VAR2 : INTEGER;
    procedure TEST4 is separate;
    function TEST5 (I : INTEGER) return INTEGER is separate;
 begin
    null;
    TEST4;
    VAR2 := TEST5( 0 );
 end TEST3;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1d_gp", sl_format o get_parents, "mdt507ns1x2_1c", 
		"B, A, cn"),
	("ns1x2_1_1d_gc", sl_format o get_children, "mdt507ns1x2_1c", ""),
	("ns1x2_1_1d_gcnc", sl_format o get_children, "cn", 
		"TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1x2_1c, mdt507ns1x2_1b, MDT507NS1X2_1_1spec, mdt507ns1x2_1a, mdt507ns1x2_1, C, B, A"),
	("ns1x2_1_1d_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"B, A, cn"),
	("ns1x2_1_1d_gcstub", sl_format o get_children, "TEST3oTEST5stub", "")
];
=TEX
=SML
val state_ns1x2_1 = get_cn_state();
new_script1{name="mdt507ns1x2_2", state=state_ns1x2_1, library_theories=["C"]};
¹CN
 separate (TEST3)
    procedure TEST4 is begin VAR2 := 1; end TEST4;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1e_gp", sl_format o get_parents, "mdt507ns1x2_2", 
		"TEST3oTEST4stub, C, cn"),
	("ns1x2_1_1e_gc", sl_format o get_children, "mdt507ns1x2_2", ""),
	("ns1x2_1_1e_gcnc", sl_format o get_children, "cn", 
"mdt507ns1x2_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1x2_1c, mdt507ns1x2_1b, MDT507NS1X2_1_1spec, mdt507ns1x2_1a, mdt507ns1x2_1, C, B, A"),
	("ns1x2_1_1e_gpstub", sl_format o get_parents, "TEST3oTEST4stub", 
		"B, A, cn"),
	("ns1x2_1_1e_gcstub", sl_format o get_children, "TEST3oTEST4stub",
		"mdt507ns1x2_2")
];
=TEX
=SML
val state_ns1x2_2 = get_cn_state();
new_script1{name="mdt507ns1x2_3", state=state_ns1x2_2, library_theories=["C"]};
¹CN
 separate (TEST3)
    function TEST5 (I : INTEGER) return INTEGER is
    begin return 0; end TEST5;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1f_gp", sl_format o get_parents, "mdt507ns1x2_3", 
		"TEST3oTEST5stub, C, cn"),
	("ns1x2_1_1f_gc", sl_format o get_children, "mdt507ns1x2_3", ""),
	("ns1x2_1_1f_gcnc", sl_format o get_children, "cn", 
"mdt507ns1x2_3, mdt507ns1x2_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1x2_1c, mdt507ns1x2_1b, MDT507NS1X2_1_1spec, mdt507ns1x2_1a, mdt507ns1x2_1, C, B, A"),
	("ns1x2_1_1f_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"B, A, cn"),
	("ns1x2_1_1f_gcstub", sl_format o get_children, "TEST3oTEST5stub",
		"mdt507ns1x2_3")
];
=TEX
\subsection{Error Messages}
=IGN
new_error_message {id= 50742, text = 
"Library theory ?0 cannot be made a parent of the script theory: ?1" };
=SML
clean_up();
store_mt_results mt_run_fail [
   ("ns1_fail_507042a", new_script1,
	{name="fail1", state = initial_cn_state, library_theories=["rubbish"]},
	 gen_fail_msg "new_script1" 507042
	 ["rubbish", "Theory rubbish is not present in the current hierarchy" ])
];
clean_up();
store_mt_results mt_run_fail [
   ("ns1_fail_507042b", new_script1,
	{name="fail2", state = initial_cn_state, library_theories=["fail2"]},
	 gen_fail_msg "new_script1" 507042
	 ["fail2", "Suggested parent fail2 is a child of the current theory" ])
];
=TEX
\pagebreak
\section{CHECK 17}
This check concerns ensuring that a theory has not been used by a previous 
compilation unit.
The compilation unit types are:
\begin{enumerate}
\item
Internal Form of Package Specification (*)
\item
Package Body (*)
\item
Subprogram (Function) (*)
\item
Subprogram (Procedure) (*)
\item
Subunit (*)
\item
External Form of Package Specification (i.e. prefixed)
\item
Stub theory
\end{enumerate}
Those annotated by ``(*)'' are placed in theories chosen by the user,
usually via $new\_script$.
Because of the iplementation approach if any combination of a compilation
unit with some other compilation unit demonstrates its correctness.
=SML
clean_up();
new_script{name="c17_1_1", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
fun c17_1_1 () =
¹CN
package c17_2 is
	VAR1 : INTEGER;
end c17_2;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_1", c17_1_1, (),
	 gen_fail_msg "check17" 507045
	 ["C17_2 (internal specification)", "c17_1_1","C17_1 (internal specification)"])
];
=TEX
=SML
clean_up();
new_script{name="c17_1_2", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
fun c17_1_2 () =
¹CN
package body c17_1 is
begin
	VAR1 := 2;
end c17_1;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_2", c17_1_2, (),
	 gen_fail_msg "check17" 507045
	 ["C17_1body (body)", "c17_1_2","C17_1 (internal specification)"])
];
=TEX
=SML
clean_up();
new_script{name="c17_1_3", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
fun c17_1_3 () =
¹CN
  with c17_1;
  procedure c17_3
  is
  begin
       c17_1.VAR1 := 0;
  end c17_3;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_3", c17_1_3, (),
	 gen_fail_msg "check17" 507045
	 ["C17_3 (subprogram)", "c17_1_3","C17_1 (internal specification)"])
];
=TEX
=SML
clean_up();
new_script{name="c17_1_4", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
fun c17_1_4 () =
¹CN
    function c17_4 (I : INTEGER) return INTEGER is
    begin return 0; end c17_4;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_4", c17_1_4, (),
	 gen_fail_msg "check17" 507045
	 ["C17_4 (subprogram)", "c17_1_4","C17_1 (internal specification)"])
];
=TEX
=SML
clean_up();
new_script{name="c17_1_5", state=initial_cn_state};
¹CN
  procedure c17_6
  is
	VAR1 : INTEGER;
	procedure c17_5 is separate;
  begin
       VAR1 := 0;
  end c17_6;
°
=SML
fun c17_1_5 () =
¹CN
 separate (c17_5)
    procedure c17_5 is begin VAR1 := 1; end c17_5;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_5", c17_1_5, (),
	 gen_fail_msg "check17" 507045
	 ["C17_5oC17_5 (subunit)", "c17_1_5","C17_6 (subprogram)"])
];
=TEX
=SML
clean_up();
new_script{name="c17_1_6", state=initial_cn_state};
¹CN
  procedure c17_6
  is
	VAR1 : INTEGER;
	procedure c17_5 is separate;
  begin
       VAR1 := 0;
  end c17_6;
°
=SML
open_theory "C17_6oC17_5stub";
fun c17_1_6 () =
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
store_mt_results mt_run_fail [
   ("c17_1_6", c17_1_6, (),
	 gen_fail_msg "check17" 507045
	 ["C17_1 (internal specification)", 
	  "C17_6oC17_5stub","C17_6oC17_5stub (stub)"])
];
=TEX
=SML
clean_up();
new_script{name="c17_1_7", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
val c17_state1 = get_cn_state();
new_script{name="c17_1_7a", state=c17_state1};

¹CN
with c17_1;
package c17_2 is
	VAR2 : INTEGER;
end c17_2;
°
=SML
open_theory "C17_1spec";
fun c17_1_7 () =
¹CN
package body c17_1 is
begin
	VAR1 := 2;
end c17_1;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_7", c17_1_7, (),
	 gen_fail_msg "check17" 507045
	 ["C17_1body (body)", "C17_1spec","C17_1 (external specification)"])
];
=TEX
Now check that all the above combinations can be done properly.
=SML
clean_up();
new_script{name="c17_2_1", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
val state17b = get_cn_state();
new_script{name="c17_2_1a", state=state17b};
fun c17_2_1 () =
¹CN
package c17_2 is
	VAR1 : INTEGER;
end c17_2;
°

=SML
store_mt_results mt_run [
   ("c17_2_1", c17_2_1, (),())
];
=TEX
=SML
clean_up();
new_script{name="c17_2_2", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
val state17b = get_cn_state();
new_script{name="c17_2_2a", state=state17b};
fun c17_2_2 () =
¹CN
package body c17_1 is
begin
	VAR1 := 2;
end c17_1;
°

=SML
store_mt_results mt_run [
   ("c17_2_2", c17_2_2, (),())
];
=TEX
=SML
clean_up();
new_script{name="c17_2_3", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
val state17b = get_cn_state();
new_script{name="c17_2_3a", state=state17b};
fun c17_2_3 () =
¹CN
  with c17_1;
  procedure c17_3
  is
  begin
       c17_1.VAR1 := 0;
  end c17_3;
°

=SML
store_mt_results mt_run [
   ("c17_2_3", c17_2_3, (),())
];
=TEX
=SML
clean_up();
new_script{name="c17_2_4", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
val state17b = get_cn_state();
new_script{name="c17_2_4a", state=state17b};
fun c17_2_4 () =
¹CN
    function c17_4 (I : INTEGER) return INTEGER is
    begin return 0; end c17_4;
°

=SML
store_mt_results mt_run [
   ("c17_2_4", c17_2_4, (),())
];
=TEX
=SML
clean_up();
new_script{name="c17_2_5", state=initial_cn_state};
¹CN
  procedure c17_6
  is
	VAR1 : INTEGER;
	procedure c17_5 is separate;
  begin
       VAR1 := 0;
  end c17_6;
°
=SML
val state17b = get_cn_state();
new_script{name="c17_2_5a", state=state17b};
fun c17_2_5 () =
¹CN
 separate (c17_6)
    procedure c17_5 is begin VAR1 := 1; end c17_5;
°

=SML
store_mt_results mt_run [
   ("c17_2_5", c17_2_5, (),())
];
=TEX
=SML
clean_up();
new_script{name="c17_2_6", state=initial_cn_state};
¹CN
  procedure c17_6
  is
	VAR1 : INTEGER;
	procedure c17_5 is separate;
  begin
       VAR1 := 0;
  end c17_6;
°
=SML
val state17b = get_cn_state();
new_script{name="c17_2_6a", state=state17b};
fun c17_2_6 () =
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
store_mt_results mt_run [
   ("c17_2_6", c17_2_6, (),())
];
=TEX
=SML
clean_up();
new_script{name="c17_2_7", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
val c17_state1 = get_cn_state();
new_script{name="c17_2_7a", state=c17_state1};

¹CN
with c17_1;
package c17_2 is
	VAR2 : INTEGER;
end c17_2;
°
=SML
val state17b = get_cn_state();
new_script{name="c17_2_7b", state=state17b};
fun c17_2_7 () =
¹CN
package body c17_1 is
begin
	VAR1 := 2;
end c17_1;
°

=SML
store_mt_results mt_run [
   ("c17_2_7", c17_2_7, (),())
];
=TEX
\section{FUNCTIONS IN PACKAGE SPECIFICATION}
A function declared in a package specification may not be mentioned in the
Z specification of another function in the same package.
=SML
clean_up();
new_script{name = "fms1", state = initial_cn_state};
fun fms1 () = 
¹CN
package P is
  function F (X : INTEGER) return INTEGER
  ˜  [F(X) = 2*X];
  function G(X:INTEGER) return INTEGER
  ˜  [G(X) = 3*F(X)]	;
end P;
°
=SML
store_mt_results mt_run_fail [
   ("fms1", fms1, (),
	 gen_fail_msg "update_theory_db_with_parainfo" 49006
	 ["G", 	"F"])
];
=TEX
\section{Renaming in Package Specifications}
=SML
clean_up();
new_script{name = "rename1", state = initial_cn_state};
¹CN
package P is
  VAR1 : INTEGER;
  function F (X : INTEGER) return INTEGER
  ˜  [F(X) = 2*X];
  procedure TEST1 (M : out INTEGER)
  „ M ˜ VAR1 [M = VAR1];

end P;
°
=SML
val rn_state1 = get_cn_state();
new_script{name = "rename1a", state = rn_state1};
¹CN
with P;
package Q is
	VAR2 : INTEGER;
	function G  (X : INTEGER) return INTEGER renames P.F;
	procedure TEST2 (M : out INTEGER) renames P.TEST1;
end Q;
°
=SML
val rn_state2 = get_cn_state();
new_script{name = "rename1b", state = rn_state2};
¹CN
$references P;
package body Q is
	procedure TEST2 (M : out INTEGER) renames P.TEST1;
begin
	„ VAR2 [PoVAR1 = 0, VAR2 = 0] (1)
end Q;
°
=SML
¹CN
(1) Ã TEST2(VAR2);
   VAR2 := G(VAR2);
°
=SML
val rn_state3 = get_cn_state();
new_script{name = "rename1c", state = rn_state3};
¹CN
with Q;
package R is
	VAR3 : INTEGER;
end R;
°
=SML
val rn_state4 = get_cn_state();
new_script{name = "rename1d", state = rn_state4};
¹CN
with P, Q;
package body R is
begin
	„ VAR3 [PoVAR1 = 0, VAR3 = 0] (2)
end R;
°
¹CN
(2) Ã Q.TEST2(VAR3);
°
=TEX
=SML
set_pc "cn";
set_goal([], get_conjecture "-" "vc2_2");
a(REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(strip_tac);
store_mt_results (mt_runf (op =$)) [
	("rename_3", concl o pop_thm, (), 
		get_conjecture "-" "vc2_2")
];
=TEX

Now demonstrate that need the renaming in the specification
to get the renamed procedure used in a future ``with'' clause.
=SML
clean_up();
new_script{name = "rename1a", state = initial_cn_state};
¹CN
package P is
  VAR1 : INTEGER;
  function F (X : INTEGER) return INTEGER
  ˜  [F(X) = 2*X];
  procedure TEST1 (M : out INTEGER)
  „ M ˜ VAR1 [M = VAR1];

end P;
°
=SML
val rn_state1a = get_cn_state();
new_script{name = "rename1a1", state = rn_state1a};
¹CN
with P;
package Q1 is
	VAR2 : INTEGER;
end Q1;
°
=SML
val rn_state5 = get_cn_state();
new_script{name = "rename1b1", state = rn_state5};
¹CN
$references P;
package body Q1 is
	procedure TEST2 (M : out INTEGER) renames P.TEST1;
	function G  (X : INTEGER) return INTEGER renames P.F;
begin
	„ VAR2 [PoVAR1 = 0, VAR2 = 0] (1)
end Q1;
°
¹CN
(1) Ã TEST2(VAR2);
   VAR2 := G(VAR2);
°
=SML
val rn_state6 = get_cn_state();
new_script{name = "rename1c1", state = rn_state6};
¹CN
with P, Q1;
package R is
	VAR3 : INTEGER;
end R;
°
=IGN
force_delete_theory "rename1d1";
=SML
val rn_state7 = get_cn_state();
new_script{name = "rename1d1", state = rn_state7};
¹CN
with P, Q1;
package body R is
begin
	„ VAR3 [PoVAR1 = 0, VAR3 = 0] (3)
end R;
°
=SML
fun rename1_1 () =
¹CN
(3) Ã Q1.TEST2(VAR3);
°
=SML
store_mt_results mt_run_fail [
   ("rename1_1", rename1_1, (),
	 gen_fail_msg "check_1_d" 505063 ["Q1oTEST2"])
];
=TEX

Now with renamed items having no formal parts.
=SML
clean_up();
new_script{name = "rename2", state = initial_cn_state};
¹CN
package P is
  VAR1 : INTEGER;
  function F (X : INTEGER) return INTEGER
  ˜  [F(X) = 2*X];
  procedure TEST1 (M : out INTEGER)
  „ M ˜ VAR1 [M = VAR1];

end P;
°
=SML
val rn_state1 = get_cn_state();
new_script{name = "rename2a", state = rn_state1};
¹CN
with P;
package Q is
	VAR2 : INTEGER;
	function G (Y : INTEGER) return INTEGER renames P.F;
	procedure TEST2(X : out INTEGER)  renames P.TEST1;
end Q;
°
=SML
val rn_state2 = get_cn_state();
new_script{name = "rename2b", state = rn_state2};
¹CN
$references P;
package body Q is
	procedure TEST2 (M : out INTEGER) renames P.TEST1;
begin
	„ VAR2 [PoVAR1 = 0, VAR2 = 0] (1)
end Q;
°
=SML
¹CN
(1) Ã TEST2(VAR2);
   VAR2 := G(VAR2);
°
=SML
set_pc "cn";
set_goal([], get_conjecture "-" "vc1_2");
a(REPEAT strip_tac);
a(rewrite_tac[z_get_spec ñG®]);
a(all_var_elim_asm_tac1);
val thm1 = rewrite_rule[](z_µ_elim ñ0® (±_right_elim (z_get_spec ñPoF®)));
a(fc_tac[thm1]);
store_mt_results (mt_runf (op =$)) [
	("rename_2", concl o pop_thm, (), 
		get_conjecture "-" "vc1_2")
];
=TEX
\section{Prefixing Formal Parameters}
=SML
clean_up();
new_script{name="prefix_fp", state=initial_cn_state};
¹CN
package F is
type T1 is range 0 .. 10;
C1 : constant T1 := T1'FIRST;
V1 : INTEGER;
procedure P1 (X: in T1; Y: out INTEGER) 
 „ Y ˜ V1 [ X > T1vFIRST + V1 , Y > T1vFIRST + C1 ];
procedure P2 (X1: in T1; Y1: out INTEGER);
function F1 (X2: in T1; Y2: in INTEGER) return INTEGER
 ˜ [ X2 + Y2 > T1vFIRST , F1(X2, Y2) > T1vFIRST + C1 ];
function F2 (X3: in T1; Y3: in INTEGER) return T1
 ˜ [ X3 + Y3 > T1vFIRST , F2(X3, Y3) > T1vFIRST + C1 ];
function F3 (X2: in T1; Y2: in INTEGER) return INTEGER;
function F4 (X3: in T1; Y3: in INTEGER) return T1;
end F;
°
=SML
val state_pf1 = get_cn_state();
new_script{name="prefix_fp1", state=state_pf1};
fun prefix_fp () =
¹CN
with F;
package G is
V2 : INTEGER;
procedure P3 (X1: in F.T1; Y1: in out INTEGER) 
„ Y1 ˜ X1, FoV1, V2 [ FoF1(X1, Y1‰0) + FoF2(X1, Y1‰0) + FoV1 > FoT1vFIRST + V2,
    FoF3(X1, Y1) + FoF4(X1, Y1) > FoT1vFIRST];
end G;
°

store_mt_results mt_run [
   ("prefix_fp", prefix_fp, (),())
];

=TEX
\section{Immediate Checking of Package Specifications}
=SML
clean_up();
new_script{name="immed1", state = initial_cn_state};
fun immed1() =
¹CN
package F is
V : INTEGER;
procedure P1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ X > Z , Y > Z + V ];
end F;
°
=SML
fun immed2() =
¹CN
package F is
procedure P1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ X > Z + V, Y > Z];
end F;
°
=SML
fun immed1a() =
¹CN
package F is
V1, V2 : INTEGER;
procedure P1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ X > Z , Y > Z + V1 + V2 ];
end F;
°
=SML
fun immed2a() =
¹CN
package F is
procedure P1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ X > Z + V1 + V2, Y > Z];
end F;
°
=TEX
=SML
store_mt_results
mt_run_fail [
   ("immed1", immed1, (),
	 gen_fail_msg "call_vcs" 507121 [
		"ñY > Z + V®",
		"ñV®", "", "is"]),
   ("immed2", immed2, (),
	 gen_fail_msg "call_vcs" 507124 [
		"ñX > Z + V®",
		"ñV®", "", "is"]),
   ("immed1a", immed1a, (),
	 gen_fail_msg "call_vcs" 507121 [
		"ñY > Z + V1 + V2®",
		"ñV1®, ñV2®", "s", "are"]),
   ("immed2a", immed2a, (),
	 gen_fail_msg "call_vcs" 507124 [
		"ñX > Z + V1 + V2®",
		"ñV1®, ñV2®", "s", "are"])
];
=TEX
=SML
fun immed3() =
¹CN
package F is
procedure P1 (X: in RUBBISH; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ Y > Z , Y > Z + V ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed3", immed3, (),
	 gen_fail_msg "type_of_tmark" 507127  ["RUBBISH"])
];
=TEX
=SML
fun immed4() =
¹CN
package F is
function F1 (X: in INTEGER; Y: in INTEGER; Z: in INTEGER) return INTEGER
 ˜ Y [ X > Z , F1 Y (X, Y, Z) > V ];
end F;
°
=SML
fun immed5() =
¹CN
package F is
function F1 (X: in INTEGER; Y: in INTEGER; Z: in INTEGER) return INTEGER
 ˜ Y [ X > V + Z , F1 Y (X, Y, Z) > X ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed4", immed4, (),
	 gen_fail_msg "update_theory_db_with_parainfo" 49006 [
		"F1", "V"]),
   ("immed5", immed5, (),
	 gen_fail_msg "update_theory_db_with_parainfo" 49006 [
		"F1", "V"])
];
=TEX
=SML
fun immed6() =
¹CN
package F is
function F1 (X: in RUBBISH; Y: out INTEGER; Z: in out INTEGER) return INTEGER
 ˜ Y [ Y > Z , F1(X, Y, Z) > X ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed6", immed6, (),
	 gen_fail_msg "type_of_tmark" 507127  ["RUBBISH"])
];
=TEX
=SML
fun immed7() =
¹CN
package F is
function F1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) return INTEGER
 ˜ [ Y > Z , F1 (X, Y) > X ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed7", immed7, (), gen_fail_msg "Z-Parser" 62000 [])
];
=TEX
=SML
fun immed8() =
¹CN
package F is
procedure P1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ Y + Z , Y > Z + V ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed8", immed8, (),
	 gen_fail_msg "Z-Parser" 62000 [])
];
=TEX
=SML
fun immed9() =
¹CN
package F is
function F1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) return INTEGER
 ˜ Y [ Y + Z , F1(X, Y, Z) > X ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed9", immed9, (), gen_fail_msg "Z-Parser" 62000 [])
];
=TEX
\section{Clashes between Formal Parameters and Others}
=SML
clean_up();
new_script{name="fp_clash", state = initial_cn_state};
¹CN
package F is
X : INTEGER;
function F1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) return INTEGER
 ˜ [ X > Z , F1(X, Y, Z) > X ];
end F;
°
=SML
val state_fp_clash = get_cn_state();
new_script{name="fp_clash2", state = state_fp_clash};
¹CN
package G is
X : INTEGER;
procedure P2 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ X > Z, Y > Z];
end G;
°
=SML
val state_fp_clash1 = get_cn_state();
new_script{name="fp_clash3", state = state_fp_clash1};
fun fp_clash1 () =
¹CN
with F;
package F1 is
Y : INTEGER;
end F1;
°
=SML
fun fp_clash2 () =
¹CN
with G;
package G1 is
Y : INTEGER;
end G1;
°
=SML
store_mt_results_show mt_run_fail [
   ("fp_clash1", fp_clash1, (), gen_fail_msg "z_prefix" 507055 
	["X", "F"]),
   ("fp_clash2", fp_clash2, (), gen_fail_msg "z_prefix" 507055 
	["X", "G"])
];

=TEX
\section{REFERENCES CLAUSES}
\subsection{Only ``references''}
=SML
clean_up();
new_script{name="refer1", state = initial_cn_state};
¹CN
package MARK_F is
FX : INTEGER;
FY : constant INTEGER := 1;
end MARK_F;
°
=SML
val stater1 = get_cn_state();
new_script{name="refer2", state = stater1};
¹CN
package MARK_G is
GX : INTEGER;
GY : constant INTEGER := 2;
end MARK_G;
°
=SML
val stater2 = get_cn_state();
new_script{name="refer3", state = stater2};
¹CN
$references MARK_F, MARK_G;
package H is
procedure P(X : in out INTEGER) 
 „ X ˜ MARK_FoFX, MARK_GoGX[ X > MARK_FoFX + MARK_GoGY , 
	X > MARK_FoFY + MARK_GoGX ];
end H;
°
=TEX
Do the right theories exist, and have the right sort of constants:
=SML
store_mt_results_show mt_run [
   ("refer1.1", get_const_theory, "z'MARK_FoFY", "MARK_Fspec"),
   ("refer1.2", get_const_theory, "z'MARK_GoGY", "MARK_Gspec")
];
output_ada_program{script="-", out_file= "mdt507_refer1.ada"};
val _ = ExtendedIO.system "grep MARK_ mdt507_refer1.ada > mdt507.grep";
val is = open_in "mdt507.grep";
store_mt_results_show mt_run [
	("refer1.3", ExtendedIO.input_line, is, "")
];
val _ = close_in is;
=SML
val stater3 = get_cn_state();
new_script{name="refer4", state = stater3};
=TEX
A references clause is required to bring the variables
$MARK_FoFX$ and $MARK_GoGX$ into scope (the reference clause of the package specification
only brings constants, types and functions into scope).
We first demonstrate this, then do it right.
=SML
fun refer1() =
¹CN
package body H is
procedure P(X : in out INTEGER) 
 „ X ˜ MARK_FoFX, MARK_GoGX  [ X > MARK_FoFX + MARK_GoGY , 
	X > MARK_FoFY + MARK_GoGX ] is
   begin
	X := X + 10;
   end P;
end H;
°
=SML
store_mt_results_show mt_run_fail [
   ("refer1.11", refer1, (), 
	gen_fail_msg "check_19" 505084 [ "MARK_FoFX" ])
];

¹CN
$references MARK_F, MARK_G;
package body H is
procedure P(X : in out INTEGER) 
 „ X ˜ MARK_FoFX, MARK_GoGX [ X > MARK_FoFX + MARK_GoGY , 
	X > MARK_FoFY + MARK_GoGX ] is
   begin
	X := X + 10;
   end P;
end H;
°
=SML
output_ada_program{script="-", out_file= "mdt507_refer2.ada"};
val _ = ExtendedIO.system "grep MARK_ mdt507_refer2.ada > mdt507.grep";
val is = open_in "mdt507.grep";
store_mt_results_show mt_run [
	("refer1.4", ExtendedIO.input_line, is, "")
];
val _ = close_in is;
=TEX

\subsection{Mix of ``with'' and ``references''}
=SML
clean_up();
new_script{name="refer1a", state = initial_cn_state};
¹CN
package MARK_F is
FX : INTEGER;
FY : constant INTEGER := 1;
end MARK_F;
°
=SML
val stater1a = get_cn_state();
new_script{name="refer2a", state = stater1a};
¹CN
package MARK_G is
GX : INTEGER;
GY : constant INTEGER := 2;
end MARK_G;
°
=SML
val stater2a = get_cn_state();
new_script{name="refer5", state = stater2a};
¹CN
with MARK_F;
$references MARK_G;
package I is
procedure P(X : in out INTEGER) 
 „ X ˜ MARK_FoFX, MARK_GoGX [ X > MARK_FoFX + MARK_GoGY , 
	X > MARK_FoFY + MARK_GoGX ];
end I;
°
=TEX
=SML
output_ada_program{script="-", out_file= "mdt507_refer3.ada"};
val _ = ExtendedIO.system "grep MARK_ mdt507_refer3.ada > mdt507.grep";
val is = open_in "mdt507.grep";
store_mt_results_show mt_run [
	("refer1.5", ExtendedIO.input_line, is, "WITH MARK_F;\n")
];
val _ = close_in is;
=SML
val stater6 = get_cn_state();
new_script{name="refer7", state = stater6};
=TEX
The references below is required to bring the variables
$MARK_FoFX$ and $MARK_GoGX$ into scope (the reference clause of the package specification
only brings constants, types and functions into scope).
¹CN
$references MARK_F, MARK_G;
package body I is
procedure P(X : in out INTEGER) 
 „ X ˜ MARK_FoFX, MARK_GoGX[ X > MARK_FoFX + MARK_GoGY , 
	X > MARK_FoFY + MARK_GoGX ] is
   begin
	X := X + 10;
   end P;
end I;
°
=SML
output_ada_program{script="-", out_file= "mdt507_refer4.ada"};
val _ = ExtendedIO.system "grep MARK_ mdt507_refer4.ada > mdt507.grep";
val is = open_in "mdt507.grep";
store_mt_results_show mt_run [
	("refer1.6", ExtendedIO.input_line, is, "")
];
val _ = close_in is;
=TEX
\subsection{Only ``with''}
=SML
clean_up();
new_script{name="refer1b", state = initial_cn_state};
¹CN
package MARK_F is
FX : INTEGER;
FY : constant INTEGER := 1;
end MARK_F;
°
=SML
val stater1b = get_cn_state();
new_script{name="refer2b", state = stater1b};
¹CN
package MARK_G is
GX : INTEGER;
GY : constant INTEGER := 2;
end MARK_G;
°
=SML
val stater2b = get_cn_state();
new_script{name="refer8", state = stater2b};
¹CN
with MARK_F, MARK_G;
package J is
procedure P(X : in out INTEGER) 
 „ X ˜ MARK_FoFX, MARK_GoGX[ X > MARK_FoFX + MARK_GoGY , 
	X > MARK_FoFY + MARK_GoGX ];
end J;
°
=TEX
=SML
output_ada_program{script="-", out_file= "mdt507_refer5.ada"};
val _ = ExtendedIO.system "grep MARK_ mdt507_refer5.ada > mdt507.grep";
val is = open_in "mdt507.grep";
store_mt_results_show mt_run [
	("refer1.7", ExtendedIO.input_line, is, "WITH MARK_F, MARK_G;\n")
];
val _ = close_in is;
=SML
val stater8 = get_cn_state();
new_script{name="refer9", state = stater8};
=TEX
The references below is required to bring the variables
$MARK_FoFX$ and $MARK_GoGX$ into scope (the reference clause of the package specification
only brings constants, types and functions into scope).
¹CN
$references MARK_F, MARK_G;
package body J is
procedure P(X : in out INTEGER) 
 „ X ˜ MARK_FoFX, MARK_GoGX[ X > MARK_FoFX + MARK_GoGY , 
	X > MARK_FoFY + MARK_GoGX ] is
   begin
	X := X + 10;
   end P;
end J;
°
=SML
output_ada_program{script="-", out_file= "mdt507_refer6.ada"};
val _ = ExtendedIO.system "grep MARK_ mdt507_refer6.ada > mdt507.grep";
val is = open_in "mdt507.grep";
store_mt_results_show mt_run [
	("refer1.10", ExtendedIO.input_line, is, "")
];
val _ = close_in is;
=TEX
\subsection{Duplicate names}
=SML
clean_up();
new_script{name="refer1c", state = initial_cn_state};
¹CN
package MARK_F is
FX : INTEGER;
FY : constant INTEGER := 1;
end MARK_F;
°
=SML
val stater1c = get_cn_state();
new_script{name="refer2c", state = stater1c};
¹CN
package MARK_G is
GX : INTEGER;
GY : constant INTEGER := 2;
end MARK_G;
°
=SML
val stater2c = get_cn_state();
new_script{name="refer10", state = stater2c};
¹CN
$references MARK_F, MARK_G, MARK_F;
package K is
X : INTEGER;
end K;
°
=SML
store_mt_results_show
mt_run [
   ("refer2.1", get_parents, "refer10", ["MARK_Gspec", "MARK_Fspec", "cn"])
];
val stater3c = get_cn_state();
new_script{name="refer11", state = stater3c};
¹CN
with MARK_F;
$references MARK_G, MARK_F;
package L is
X : INTEGER;
end L;
°
=SML
store_mt_results_show mt_run [
   ("refer3.1", get_parents, "refer11", ["MARK_Gspec", "MARK_Fspec", "cn"])
];
=TEX
\subsection{Failure Conditions}
=SML
fun refer12() =
¹CN
$references MARK_F, RUBBISH, MARK_G;
package K is
X : INTEGER;
end K;
°
=SML
store_mt_results_show mt_run_fail [
   ("refer12.1", refer12, (), gen_fail_msg "context_clause_check"
	 507038 ["RUBBISH"])
];
=TEX
\section{WP 5 Checks}
=SML
clean_up();
new_script{name="BASIC", state=initial_cn_state};
=TEX
¹CN
package BASIC
is
  type INDEX is range 1 .. 10;
  $auxiliary FLAGS : ğ (1..10);
  procedure SET (I : in INDEX)
  „ FLAGS [ FLAGS = FLAGS‰0 À {I} ] ;
end BASIC;
°
=SML
val state1 = get_cn_state();
new_script{name="DERIVED", state=state1};
=TEX
¹CN
with BASIC;
package DERIVED
is
  procedure SET_ALL
  „ BASICoFLAGS
  [ BASICoFLAGS = BASICoINDEX ] ;
end DERIVED;
°
=SML
val state2 = get_cn_state();
new_script{name="MAIN", state=state2};
=TEX
¹CN
with BASIC;
procedure MAIN
„ BASICoFLAGS
[ BASICoFLAGS = BASICoINDEX ]
is
begin
  for I in BASIC.INDEX
  loop
    „ BASICoFLAGS
    [ 1.. I-1 € BASICoFLAGS,
      1 .. I € BASICoFLAGS ]
  end loop;
end MAIN;
°
¹CN
 Ã
    BASIC.SET(I);
°
=SML
val state3 = get_cn_state();
new_script{name="DERIVED_BODY", state=state3};

fun wp5_test1 () =
¹CN
with BASIC;
package body DERIVED
is
  procedure SET_ALL
  „ BASICoFLAGS
  [ BASICoFLAGS = BASICoINDEX ]
  is
  begin
    „ BASICoFLAGS
    [ BASICoFLAGS = BASICoINDEX ]
  end SET_ALL;
end DERIVED;
°
We are only interested in success, so:
=SML
store_mt_results_show mt_run [
	("wp5_test1", wp5_test1, (), ())
];
=TEX
=SML
clean_up();
new_script{name="A", state=initial_cn_state};
=TEX
¹CN
package A is
    V : INTEGER;
end A;
°
=SML
val state1=get_cn_state();
new_script{name="B", state= state1};
=TEX
¹CN
with A;
package B is
    procedure INIT
    „ AoV [AoV = 0];
end B;
°
=SML
val state2=get_cn_state();
new_script{name="B_BODY", state=state2};
=TEX
=SML
fun wp5_test2 () = 
¹CN
with A;
package body B is
    procedure INIT
    „ AoV [AoV = 0]
    is
    begin
        A.V := 0;
    end INIT;
end B;
°
We are only interested in success, so:
=SML
store_mt_results_show mt_run [
	("wp5_test2", wp5_test2, (), ())
];
=TEX
\section{Definitions with or without Axiomatic Mode}
=SML
clean_up();
new_script{name= "temp1", state = initial_cn_state};
val orig_z_use_axioms = set_flag("z_use_axioms", false);
¹ZAX
Ü f : ú ­ ú
÷üüüüüü
Ü f 0 = 1
°
¹ZAX
Ü g,h : ú ­ ú
÷üüüüüü
Ü g 0 = 1 ± h 0 = 2
°
[ Y ]œœœœœœœœœœœ
Ü j : Y ­ Y
÷üüüüüü
Ü ¶ x : Y · j x = x
ˆüüüüüüüüüüüüüü
¹ZAX
Ü k : ú ­ ú
°
[ Y ]œœœœœœœœœœœ
Ü l : Y ­ Y
ˆüüüüüüüüüüüüüü
=SML
set_flag("z_use_axioms", true);
¹ZAX
Ü f1 : ú ­ ú
÷üüüüüü
Ü f1 0 = 1
°
¹ZAX
Ü g1,h1 : ú ­ ú
÷üüüüüü
Ü g1 0 = 1 ± h1 0 = 2
°
[ Y ]œœœœœœœœœœœ
Ü j1 : Y ­ Y
÷üüüüüü
Ü ¶ x : Y · j1 x = x
ˆüüüüüüüüüüüüüü
¹ZAX
Ü k1 : ú ­ ú
°
[ Y ]œœœœœœœœœœœ
Ü l1 : Y ­ Y
ˆüüüüüüüüüüüüüü

¹CN
package P is
X : INTEGER;
end P;
°
=SML

store_mt_results mt_run [("mdt507_axiom_1.output",
	output_z_document, 
	{out_file="mdt507_axiom_temp1.zdoc", script="-"}, ())];
val temp1_consts = map (fst o dest_const) (get_consts "-");

new_script{name="temp2", state = get_cn_state()};
¹CN
with P;
package Q is
Y : INTEGER;
end Q;
°
=SML
store_mt_results mt_run [("mdt507_axiom_2.output",
	output_z_document,
	{out_file="mdt507_axiom_temp2.zdoc", script="-"},
	())];
val temp2_consts = map (fst o dest_const) (get_consts "temp2");
val Pspec_consts = map (fst o dest_const) (get_consts "Pspec");
=TEX
Now to read these back in:
=SML
clean_up();
store_mt_results mt_run [("mdt507_axiom_1.1",
	use_file, "mdt507_axiom_temp1.zdoc", ())];
store_mt_results_show (mt_runf (op ~=)) [("mdt507_axiom_1.2",
	map (fst o dest_const), (get_consts "temp1"), temp1_consts)];
store_mt_results mt_run [("mdt507_axiom_2.1",
	use_file, "mdt507_axiom_temp2.zdoc", ())];
store_mt_results_show (mt_runf (op ~=)) [("mdt507_axiom_2.2",
	map (fst o dest_const), (get_consts "temp2"), temp2_consts)];
store_mt_results_show (mt_runf (op ~=)) [("mdt507_axiom_2.3",
	map (fst o dest_const), (get_consts "Pspec"), Pspec_consts)];
set_flag ("z_use_axioms",orig_z_use_axioms);
=TEX
\section{Tests of References}
=SML
clean_up();
new_script{name="ref1", state = initial_cn_state};
¹CN
package REF1 is
function F1 return INTEGER
˜ [ F1 = 1 ];
end REF1;
°
=SML
new_script{name="ref2", state = get_cn_state()};
¹CN
$references REF1;
package REF2 is
function F2 return INTEGER
˜ [ F2 = REF1oF1 ];
end REF2;
°
=SML
new_script{name="ref3", state = get_cn_state()};
fun ref_test1 () =
¹CN
$references REF2;
package REF3 is
function F3 return INTEGER
˜ [ F3 = REF2oF2 ];
end REF3;
°
=SML
store_mt_results mt_run[("ref_test1",ref_test1, (), ())]; 
=TEX
Now repeat the test, but use a ``with''.
=SML
clean_up();
new_script{name="ref1", state = initial_cn_state};
¹CN
package REF1 is
function F1 return INTEGER
˜ [ F1 = 1 ];
end REF1;
°
=SML
new_script{name="ref2", state = get_cn_state()};
¹CN
with REF1;
package REF2 is
function F2 return INTEGER
˜ [ F2 = REF1oF1 ];
end REF2;
°
=SML
new_script{name="ref3", state = get_cn_state()};
fun ref_test2 () =
¹CN
$references REF2;
package REF3 is
function F3 return INTEGER
˜ [ F3 = REF2oF2 ];
end REF3;
°
=SML
store_mt_results mt_run[("ref_test2",ref_test2, (), ())]; 
=TEX
Now using library theories:
=SML
clean_up();
new_script{name="ref1", state = initial_cn_state};
¹CN
package REF1 is
function F1 return INTEGER
˜ [ F1 = 1 ];
end REF1;
°
=SML
new_script{name="dummy", state = get_cn_state()};
¹CN
with REF1;
package DUMMY is
X: INTEGER;
end DUMMY;
°
=SML
new_script1{name="ref2", state = get_cn_state(), library_theories = ["REF1spec"]};
¹CN
package REF2 is
function F2 return INTEGER
˜ [ F2 = REF1oF1 ];
end REF2;
°
=SML
new_script{name="ref3", state = get_cn_state()};
fun ref_test3 () =
¹CN
$references REF2;
package REF3 is
function F3 return INTEGER
˜ [ F3 = REF2oF2 ];
end REF3;
°
=SML
store_mt_results mt_run[("ref_test3",ref_test3, (), ())]; 
=TEX
Now to test that library theories of the *current* script are not added to 
the prefixed theory.
=SML
clean_up();
new_theory "temp";
new_script{name="ref1", state = initial_cn_state};
¹CN
package REF1 is
function F1 return INTEGER
˜ [ F1 = 1 ];
end REF1;
°
=SML
new_script1{name="ref2", state = get_cn_state(), library_theories = ["temp"]};
¹CN
with REF1;
package REF2 is
function F2 return INTEGER
˜ [ F2 = REF1oF1 ];
end REF2;
°
=SML
fun ref_test4 () = (not("temp" mem get_parents  "REF1spec"));
store_mt_results_show mt_run[("ref_test4",ref_test4, (), true)]; 
val _ = ExtendedIO.system "rm mdt507.grep";
=TEX
\section{SUMMARY OF RESULTS}
=SML
diag_string(summarize_mt_results());
=TEX

\end{document}

