% %Z% $Revision$ $RCSfile$ $Date$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Z Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT507}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthor{K.~Blackburn & WIN01}
\TPPauthorisation{R.D.~Arthan & DAZ Manager}
\TPPabstract{This document contains tests for theory hierarchy material
implemented in the Z Generator material.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item[Issue 1.1-1.2]
First drafts.
\item[Issue 1.3]
Change to one compilation unit per script.
\item[Issue 1.4]
IUCT WP 2 changes.
\item[Issue 1.5]
Checking Check 17.
\item[Issue 1.6]
Adding renaming in specifications material.
\item[Issue 1.7 - 1.9]
Changes from IUCT WP 2 and WP 7.
\end{description}
\subsection{Changes forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains module tests for theory hierarchy 
effects of the functions defined 
in \cite{ISS/HAT/DAZ/DTD507}.
\subsection{Introduction}
\subsubsection{Background and Purpose}
See \cite{ISS/HAT/DAZ/DTD507}. 
In general the material in this document is tested by the various
integration test documents in the DAZ project.
However, the changes in theory hierarchy structure caused by $new\_script1$
and other functions is not tested elsewhere.
\subsubsection{Dependencies}
These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.

The tests rely on ISS/HAT/DAZ/IMP516, or require the $CNZGenerator$ 
structure to be opened.

\subsubsection{Possible Enhancements}
None known.
\subsubsection{Deficiencies}
None known.

\section{PREAMBLE}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results();
=TEX
\section{THE TESTS}
\subsection{Useful functions}
=SML
fun clean_up () = (
        let     val thys = (get_descendants "cn" less "cn")
                                        diff get_cache_theories();
                fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
        in      map del_thy thys
        end;    ()
);
=TEX
=SML
fun sl_format (sl : string list) : string = format_list Combinators.I sl ", ";

=TEX
\subsection{$new\_script$}
=SML
clean_up();
new_script{name = "mdt507ns_1", state=initial_cn_state};
=TEX
¹CN
package mdt507NS_1_1 is
	VAR1 : INTEGER;

	procedure TEST1 (M : out INTEGER)
	„ M [VAR1 = 0, M = 0];

end mdt507NS_1_1;
°
=SML
store_mt_results mt_run [
	("ns_1_1a_gp", sl_format o get_parents, "mdt507ns_1", "cn"),
	("ns_1_1a_gc", sl_format o get_children, "mdt507ns_1", ""),
	("ns_1_1a_gcnc", sl_format o get_children, "cn", "mdt507ns_1")
	
];
=TEX
=SML 
val statea = get_cn_state();
new_script{name = "mdt507ns_1a", state=statea};
¹CN
 with mdt507NS_1_1;
  procedure TEST2
  is
  begin
       mdt507NS_1_1.VAR1 := 0;
  end TEST2;
°
=SML
store_mt_results_show mt_run [
	("ns_1_1b_gp", sl_format o get_parents, "mdt507ns_1a", 
		"MDT507NS_1_1spec, cn"),
	("ns_1_1b_gc", sl_format o get_children, "mdt507ns_1a", ""),
	("ns_1_1b_gcnc", sl_format o get_children, "cn", 
		"MDT507NS_1_1spec, mdt507ns_1a, mdt507ns_1")
];
=TEX
=SML 
val stateb = get_cn_state();
new_script{name = "mdt507ns_1b", state=stateb};
¹CN
package body mdt507NS_1_1 is

	procedure TEST1 (M : out INTEGER)
	„ M [VAR1 = 0, M = 0]
	is
	begin
		M := VAR1;
	end TEST1;

begin
	VAR1 := 2;

end mdt507NS_1_1;
°
=SML
store_mt_results mt_run [
	("ns_1_1c_gp", sl_format o get_parents, "mdt507ns_1b", 
		"mdt507ns_1, cn"),
	("ns_1_1c_gc", sl_format o get_children, "mdt507ns_1b", ""),
	("ns_1_1c_gcnc", sl_format o get_children, "cn", 
		"mdt507ns_1b, MDT507NS_1_1spec, mdt507ns_1a, mdt507ns_1")	
];

=TEX
=SML 
val statec = get_cn_state();
new_script{name = "mdt507ns_1c", state=statec};
¹CN
 procedure TEST3 is
    VAR2 : INTEGER;
    procedure TEST4 is separate;
    function TEST5 (I : INTEGER) return INTEGER is separate;
 begin
    null;
    TEST4;
    VAR2 := TEST5( 0 );
 end TEST3;
°
=SML
store_mt_results mt_run [
	("ns_1_1d_gp", sl_format o get_parents, "mdt507ns_1c", 
		"cn"),
	("ns_1_1d_gc", sl_format o get_children, "mdt507ns_1c", ""),
	("ns_1_1d_gcnc", sl_format o get_children, "cn", 
		"TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns_1c, mdt507ns_1b, MDT507NS_1_1spec, mdt507ns_1a, mdt507ns_1"),
	("ns_1_1d_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"cn"),
	("ns_1_1d_gcstub", sl_format o get_children, "TEST3oTEST5stub", "")
];
=TEX
=SML
val state_ns_1 = get_cn_state();
new_script{name="mdt507ns_2", state=state_ns_1};
¹CN
 separate (TEST3)
    procedure TEST4 is begin VAR2 := 1; end TEST4;
°
=SML
store_mt_results mt_run [
	("ns_1_1e_gp", sl_format o get_parents, "mdt507ns_2", 
		"TEST3oTEST4stub, cn"),
	("ns_1_1e_gc", sl_format o get_children, "mdt507ns_2", ""),
	("ns_1_1e_gcnc", sl_format o get_children, "cn", 
"mdt507ns_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns_1c, mdt507ns_1b, MDT507NS_1_1spec, mdt507ns_1a, mdt507ns_1"),
	("ns_1_1e_gpstub", sl_format o get_parents, "TEST3oTEST4stub", 
		"cn"),
	("ns_1_1e_gcstub", sl_format o get_children, "TEST3oTEST4stub",
		"mdt507ns_2")
];

=TEX
=SML
val state_ns_2 = get_cn_state();
new_script{name="mdt507ns_3", state=state_ns_2};
¹CN
 separate (TEST3)
    function TEST5 (I : INTEGER) return INTEGER is
    begin return 0; end TEST5;
°
=SML
store_mt_results mt_run [
	("ns_1_1f_gp", sl_format o get_parents, "mdt507ns_3", 
		"TEST3oTEST5stub, cn"),
	("ns_1_1f_gc", sl_format o get_children, "mdt507ns_3", ""),
	("ns_1_1f_gcnc", sl_format o get_children, "cn", 
"mdt507ns_3, mdt507ns_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns_1c, mdt507ns_1b, MDT507NS_1_1spec, mdt507ns_1a, mdt507ns_1"),
	("ns_1_1f_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"cn"),
	("ns_1_1f_gcstub", sl_format o get_children, "TEST3oTEST5stub",
		"mdt507ns_3")
];
=TEX
\subsection{$new\_script1$ - No Library theories}
=SML
clean_up();
new_script1{name = "mdt507ns1_1", state=initial_cn_state, library_theories=[]};
=TEX
¹CN
package mdt507NS_1_1 is
	VAR1 : INTEGER;

	procedure TEST1 (M : out INTEGER)
	„ M [VAR1 = 0, M = 0];

end mdt507NS_1_1;
°
=SML
store_mt_results mt_run [
	("ns1_1_1a_gp", sl_format o get_parents, "mdt507ns1_1", "cn"),
	("ns1_1_1a_gc", sl_format o get_children, "mdt507ns1_1", ""),
	("ns1_1_1a_gcnc", sl_format o get_children, "cn", "mdt507ns1_1")
	
];
=TEX
=SML
val statea = get_cn_state();
new_script1{name = "mdt507ns1_1a", state=statea, library_theories=[]};
¹CN
 with mdt507NS_1_1;
  procedure TEST2
  is
  begin
       mdt507NS_1_1.VAR1 := 0;
  end TEST2;
°
=SML
store_mt_results mt_run [
	("ns1_1_1b_gp", sl_format o get_parents, "mdt507ns1_1a", 
		"MDT507NS_1_1spec, cn"),
	("ns1_1_1b_gc", sl_format o get_children, "mdt507ns1_1a", ""),
	("ns1_1_1b_gcnc", sl_format o get_children, "cn", 
		"MDT507NS_1_1spec, mdt507ns1_1a, mdt507ns1_1")
	
];
=TEX
=SML
val stateb = get_cn_state();
new_script1{name = "mdt507ns1_1b", state=stateb, library_theories=[]};
¹CN
package body mdt507NS_1_1 is

	procedure TEST1 (M : out INTEGER)
	„ M [VAR1 = 0, M = 0]
	is
	begin
		M := VAR1;
	end TEST1;

begin
	VAR1 := 2;

end mdt507NS_1_1;
°
=SML
store_mt_results mt_run [
	("ns1_1_1c_gp", sl_format o get_parents, "mdt507ns1_1b", 
		"mdt507ns1_1, cn"),
	("ns1_1_1c_gc", sl_format o get_children, "mdt507ns1_1b", ""),
	("ns1_1_1c_gcnc", sl_format o get_children, "cn", 
		"mdt507ns1_1b, MDT507NS_1_1spec, mdt507ns1_1a, mdt507ns1_1")	
];
=TEX
=SML
val statec = get_cn_state();
new_script1{name = "mdt507ns1_1c", state=statec, library_theories=[]};
¹CN
 procedure TEST3 is
    VAR2 : INTEGER;
    procedure TEST4 is separate;
    function TEST5 (I : INTEGER) return INTEGER is separate;
 begin
    null;
    TEST4;
    VAR2 := TEST5( 0 );
 end TEST3;
°
=SML
store_mt_results mt_run [
	("ns1_1_1d_gp", sl_format o get_parents, "mdt507ns1_1c", 
		"cn"),
	("ns1_1_1d_gc", sl_format o get_children, "mdt507ns1_1c", ""),
	("ns1_1_1d_gcnc", sl_format o get_children, "cn", 
		"TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1_1c, mdt507ns1_1b, MDT507NS_1_1spec, mdt507ns1_1a, mdt507ns1_1"),
	("ns1_1_1d_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"cn"),
	("ns1_1_1d_gcstub", sl_format o get_children, "TEST3oTEST5stub", "")
];
=TEX
=SML
val state_ns1_1 = get_cn_state();
new_script1{name="mdt507ns1_2", state=state_ns1_1, library_theories=[]};
¹CN
 separate (TEST3)
    procedure TEST4 is begin VAR2 := 1; end TEST4;
°
=SML
store_mt_results mt_run [
	("ns1_1_1e_gp", sl_format o get_parents, "mdt507ns1_2", 
		"TEST3oTEST4stub, cn"),
	("ns1_1_1e_gc", sl_format o get_children, "mdt507ns1_2", ""),
	("ns1_1_1e_gcnc", sl_format o get_children, "cn", 
"mdt507ns1_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1_1c, mdt507ns1_1b, MDT507NS_1_1spec, mdt507ns1_1a, mdt507ns1_1"),
	("ns1_1_1e_gpstub", sl_format o get_parents, "TEST3oTEST4stub", 
		"cn"),
	("ns1_1_1e_gcstub", sl_format o get_children, "TEST3oTEST4stub",
		"mdt507ns1_2")
];

=TEX
=SML
val state_ns1_2 = get_cn_state();
new_script1{name="mdt507ns1_3", state=state_ns1_2, library_theories=[]};
¹CN
 separate (TEST3)
    function TEST5 (I : INTEGER) return INTEGER is
    begin return 0; end TEST5;
°
=SML
store_mt_results_show mt_run [
	("ns1_1_1f_gp", sl_format o get_parents, "mdt507ns1_3", 
		"TEST3oTEST5stub, cn"),
	("ns1_1_1f_gc", sl_format o get_children, "mdt507ns1_3", ""),
	("ns1_1_1f_gcnc", sl_format o get_children, "cn", 
"mdt507ns1_3, mdt507ns1_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1_1c, mdt507ns1_1b, MDT507NS_1_1spec, mdt507ns1_1a, mdt507ns1_1"),
	("ns1_1_1f_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"cn"),
	("ns1_1_1f_gcstub", sl_format o get_children, "TEST3oTEST5stub",
		"mdt507ns1_3")
];
=TEX
\subsection{$new\_script1$ - Two Library theories}
=SML
clean_up();
new_theory "A";
=TEX
¹Z
Ü ABST1 ::= Abs1
°
=SML
open_theory "cn";
new_theory "B";
=TEX
¹Z
Ü ABST2 ::= Abs2
°
=SML
open_theory "cn";
new_theory "C";
=TEX
¹Z
Ü ABST3 ::= Abs3
°
=SML
new_script1{name = "mdt507ns1x2_1", state=initial_cn_state, library_theories=["A", "B"]};
=TEX
¹CN
package mdt507NS1X2_1_1 is
	VAR1 : INTEGER;

	procedure TEST1 (M : out INTEGER)
	„ M [VAR1 = 0, M = 0];

end mdt507NS1X2_1_1;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1a_gp", sl_format o get_parents, "mdt507ns1x2_1", "B, A, cn"),
	("ns1x2_1_1a_gc", sl_format o get_children, "mdt507ns1x2_1", ""),
	("ns1x2_1_1a_gcnc", sl_format o get_children, "cn", "mdt507ns1x2_1, C, B, A")	
];
=TEX
=SML
val statea = get_cn_state();
new_script1{name = "mdt507ns1x2_1a", state=statea, library_theories=["A", "B"]};
¹CN
 with mdt507NS1X2_1_1;
  procedure TEST2
  is
  begin
       mdt507NS1X2_1_1.VAR1 := 0;
  end TEST2;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1b_gp", sl_format o get_parents, "mdt507ns1x2_1a", 
		"MDT507NS1X2_1_1spec, B, A, cn"),
	("ns1x2_1_1b_gc", sl_format o get_children, "mdt507ns1x2_1a", ""),
	("ns1x2_1_1b_gcnc", sl_format o get_children, "cn", 
		"MDT507NS1X2_1_1spec, mdt507ns1x2_1a, mdt507ns1x2_1, C, B, A")
];
=TEX
=SML
val stateb = get_cn_state();
new_script1{name = "mdt507ns1x2_1b", state=stateb, library_theories=["A", "B"]};
¹CN
package body mdt507NS1X2_1_1 is

	procedure TEST1 (M : out INTEGER)
	„ M [VAR1 = 0, M = 0]
	is
	begin
		M := VAR1;
	end TEST1;

begin
	VAR1 := 2;

end mdt507NS1X2_1_1;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1c_gp", sl_format o get_parents, "mdt507ns1x2_1b", 
		"mdt507ns1x2_1, B, A, cn"),
	("ns1x2_1_1c_gc", sl_format o get_children, "mdt507ns1x2_1b", ""),
	("ns1x2_1_1c_gcnc", sl_format o get_children, "cn", 
	"mdt507ns1x2_1b, MDT507NS1X2_1_1spec, mdt507ns1x2_1a, mdt507ns1x2_1, C, B, A")	
];
=TEX
=SML
val statec = get_cn_state();
new_script1{name = "mdt507ns1x2_1c", state=statec, library_theories=["A", "B"]};
¹CN
 procedure TEST3 is
    VAR2 : INTEGER;
    procedure TEST4 is separate;
    function TEST5 (I : INTEGER) return INTEGER is separate;
 begin
    null;
    TEST4;
    VAR2 := TEST5( 0 );
 end TEST3;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1d_gp", sl_format o get_parents, "mdt507ns1x2_1c", 
		"B, A, cn"),
	("ns1x2_1_1d_gc", sl_format o get_children, "mdt507ns1x2_1c", ""),
	("ns1x2_1_1d_gcnc", sl_format o get_children, "cn", 
		"TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1x2_1c, mdt507ns1x2_1b, MDT507NS1X2_1_1spec, mdt507ns1x2_1a, mdt507ns1x2_1, C, B, A"),
	("ns1x2_1_1d_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"B, A, cn"),
	("ns1x2_1_1d_gcstub", sl_format o get_children, "TEST3oTEST5stub", "")
];
=TEX
=SML
val state_ns1x2_1 = get_cn_state();
new_script1{name="mdt507ns1x2_2", state=state_ns1x2_1, library_theories=["C"]};
¹CN
 separate (TEST3)
    procedure TEST4 is begin VAR2 := 1; end TEST4;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1e_gp", sl_format o get_parents, "mdt507ns1x2_2", 
		"TEST3oTEST4stub, C, cn"),
	("ns1x2_1_1e_gc", sl_format o get_children, "mdt507ns1x2_2", ""),
	("ns1x2_1_1e_gcnc", sl_format o get_children, "cn", 
"mdt507ns1x2_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1x2_1c, mdt507ns1x2_1b, MDT507NS1X2_1_1spec, mdt507ns1x2_1a, mdt507ns1x2_1, C, B, A"),
	("ns1x2_1_1e_gpstub", sl_format o get_parents, "TEST3oTEST4stub", 
		"B, A, cn"),
	("ns1x2_1_1e_gcstub", sl_format o get_children, "TEST3oTEST4stub",
		"mdt507ns1x2_2")
];
=TEX
=SML
val state_ns1x2_2 = get_cn_state();
new_script1{name="mdt507ns1x2_3", state=state_ns1x2_2, library_theories=["C"]};
¹CN
 separate (TEST3)
    function TEST5 (I : INTEGER) return INTEGER is
    begin return 0; end TEST5;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1f_gp", sl_format o get_parents, "mdt507ns1x2_3", 
		"TEST3oTEST5stub, C, cn"),
	("ns1x2_1_1f_gc", sl_format o get_children, "mdt507ns1x2_3", ""),
	("ns1x2_1_1f_gcnc", sl_format o get_children, "cn", 
"mdt507ns1x2_3, mdt507ns1x2_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1x2_1c, mdt507ns1x2_1b, MDT507NS1X2_1_1spec, mdt507ns1x2_1a, mdt507ns1x2_1, C, B, A"),
	("ns1x2_1_1f_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"B, A, cn"),
	("ns1x2_1_1f_gcstub", sl_format o get_children, "TEST3oTEST5stub",
		"mdt507ns1x2_3")
];
=TEX
\subsection{Error Messages}
=IGN
new_error_message {id= 50742, text = 
"Library theory ?0 cannot be made a parent of the script theory: ?1" };
=SML
clean_up();
store_mt_results mt_run_fail [
   ("ns1_fail_507042a", new_script1,
	{name="fail1", state = initial_cn_state, library_theories=["rubbish"]},
	 gen_fail_msg "new_script1" 507042
	 ["rubbish", "Theory rubbish is not present in the current hierarchy" ])
];
clean_up();
store_mt_results mt_run_fail [
   ("ns1_fail_507042b", new_script1,
	{name="fail2", state = initial_cn_state, library_theories=["fail2"]},
	 gen_fail_msg "new_script1" 507042
	 ["fail2", "Suggested parent fail2 is a child of the current theory" ])
];
=TEX
\pagebreak
\section{CHECK 17}
This check concerns ensuring that a theory has not been used by a previous 
compilation unit.
The compilation unit types are:
\begin{enumerate}
\item
Internal Form of Package Specification (*)
\item
Package Body (*)
\item
Subprogram (Function) (*)
\item
Subprogram (Procedure) (*)
\item
Subunit (*)
\item
External Form of Package Specification (i.e. prefixed)
\item
Stub theory
\end{enumerate}
Those annotated by ``(*)'' are placed in theories chosen by the user,
usually via $new\_script$.
Because of the iplementation approach if any combination of a compilation
unit with some other compilation unit demonstrates its correctness.
=SML
clean_up();
new_script{name="c17_1_1", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
fun c17_1_1 () =
¹CN
package c17_2 is
	VAR1 : INTEGER;
end c17_2;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_1", c17_1_1, (),
	 gen_fail_msg "check17" 507045
	 ["C17_2spec (internal specification)", "c17_1_1","C17_1spec (internal specification)"])
];
=TEX
=SML
clean_up();
new_script{name="c17_1_2", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
fun c17_1_2 () =
¹CN
package body c17_1 is
begin
	VAR1 := 2;
end c17_1;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_2", c17_1_2, (),
	 gen_fail_msg "check17" 507045
	 ["C17_1body (body)", "c17_1_2","C17_1spec (internal specification)"])
];
=TEX
=SML
clean_up();
new_script{name="c17_1_3", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
fun c17_1_3 () =
¹CN
  with c17_1;
  procedure c17_3
  is
  begin
       c17_1.VAR1 := 0;
  end c17_3;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_3", c17_1_3, (),
	 gen_fail_msg "check17" 507045
	 ["C17_3 (subprogram)", "c17_1_3","C17_1spec (internal specification)"])
];
=TEX
=SML
clean_up();
new_script{name="c17_1_4", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
fun c17_1_4 () =
¹CN
    function c17_4 (I : INTEGER) return INTEGER is
    begin return 0; end c17_4;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_4", c17_1_4, (),
	 gen_fail_msg "check17" 507045
	 ["C17_4 (subprogram)", "c17_1_4","C17_1spec (internal specification)"])
];
=TEX
=SML
clean_up();
new_script{name="c17_1_5", state=initial_cn_state};
¹CN
  procedure c17_6
  is
	VAR1 : INTEGER;
	procedure c17_5 is separate;
  begin
       VAR1 := 0;
  end c17_6;
°
=SML
fun c17_1_5 () =
¹CN
 separate (c17_5)
    procedure c17_5 is begin VAR1 := 1; end c17_5;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_5", c17_1_5, (),
	 gen_fail_msg "check17" 507045
	 ["C17_5oC17_5 (subunit)", "c17_1_5","C17_6 (subprogram)"])
];
=TEX
=SML
clean_up();
new_script{name="c17_1_6", state=initial_cn_state};
¹CN
  procedure c17_6
  is
	VAR1 : INTEGER;
	procedure c17_5 is separate;
  begin
       VAR1 := 0;
  end c17_6;
°
=SML
open_theory "C17_6oC17_5stub";
fun c17_1_6 () =
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
store_mt_results mt_run_fail [
   ("c17_1_6", c17_1_6, (),
	 gen_fail_msg "check17" 507045
	 ["C17_1spec (internal specification)", 
	  "C17_6oC17_5stub","C17_6oC17_5stub (stub)"])
];
=TEX
=SML
clean_up();
new_script{name="c17_1_7", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
val c17_state1 = get_cn_state();
new_script{name="c17_1_7a", state=c17_state1};

¹CN
with c17_1;
package c17_2 is
	VAR2 : INTEGER;
end c17_2;
°
=SML
open_theory "C17_1spec";
fun c17_1_7 () =
¹CN
package body c17_1 is
begin
	VAR1 := 2;
end c17_1;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_7", c17_1_7, (),
	 gen_fail_msg "check17" 507045
	 ["C17_1body (body)", "C17_1spec","C17_1 (external specification)"])
];
=TEX
Now check that all the above combinations can be done properly.
=SML
clean_up();
new_script{name="c17_2_1", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
val state17b = get_cn_state();
new_script{name="c17_2_1a", state=state17b};
fun c17_2_1 () =
¹CN
package c17_2 is
	VAR1 : INTEGER;
end c17_2;
°

=SML
store_mt_results mt_run [
   ("c17_2_1", c17_2_1, (),())
];
=TEX
=SML
clean_up();
new_script{name="c17_2_2", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
val state17b = get_cn_state();
new_script{name="c17_2_2a", state=state17b};
fun c17_2_2 () =
¹CN
package body c17_1 is
begin
	VAR1 := 2;
end c17_1;
°

=SML
store_mt_results mt_run [
   ("c17_2_2", c17_2_2, (),())
];
=TEX
=SML
clean_up();
new_script{name="c17_2_3", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
val state17b = get_cn_state();
new_script{name="c17_2_3a", state=state17b};
fun c17_2_3 () =
¹CN
  with c17_1;
  procedure c17_3
  is
  begin
       c17_1.VAR1 := 0;
  end c17_3;
°

=SML
store_mt_results mt_run [
   ("c17_2_3", c17_2_3, (),())
];
=TEX
=SML
clean_up();
new_script{name="c17_2_4", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
val state17b = get_cn_state();
new_script{name="c17_2_4a", state=state17b};
fun c17_2_4 () =
¹CN
    function c17_4 (I : INTEGER) return INTEGER is
    begin return 0; end c17_4;
°

=SML
store_mt_results mt_run [
   ("c17_2_4", c17_2_4, (),())
];
=TEX
=SML
clean_up();
new_script{name="c17_2_5", state=initial_cn_state};
¹CN
  procedure c17_6
  is
	VAR1 : INTEGER;
	procedure c17_5 is separate;
  begin
       VAR1 := 0;
  end c17_6;
°
=SML
val state17b = get_cn_state();
new_script{name="c17_2_5a", state=state17b};
fun c17_2_5 () =
¹CN
 separate (c17_6)
    procedure c17_5 is begin VAR1 := 1; end c17_5;
°

=SML
store_mt_results mt_run [
   ("c17_2_5", c17_2_5, (),())
];
=TEX
=SML
clean_up();
new_script{name="c17_2_6", state=initial_cn_state};
¹CN
  procedure c17_6
  is
	VAR1 : INTEGER;
	procedure c17_5 is separate;
  begin
       VAR1 := 0;
  end c17_6;
°
=SML
val state17b = get_cn_state();
new_script{name="c17_2_6a", state=state17b};
fun c17_2_6 () =
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
store_mt_results mt_run [
   ("c17_2_6", c17_2_6, (),())
];
=TEX
=SML
clean_up();
new_script{name="c17_2_7", state=initial_cn_state};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
val c17_state1 = get_cn_state();
new_script{name="c17_2_7a", state=c17_state1};

¹CN
with c17_1;
package c17_2 is
	VAR2 : INTEGER;
end c17_2;
°
=SML
val state17b = get_cn_state();
new_script{name="c17_2_7b", state=state17b};
fun c17_2_7 () =
¹CN
package body c17_1 is
begin
	VAR1 := 2;
end c17_1;
°

=SML
store_mt_results mt_run [
   ("c17_2_7", c17_2_7, (),())
];
=TEX
\section{FUNCTIONS IN PACKAGE SPECIFICATION}
A function declared in a package specification may not be mentioned in the
Z specification of another function in the same package.
=SML
clean_up();
new_script{name = "fms1", state = initial_cn_state};
fun fms1 () = 
¹CN
package P is
  function F (X : INTEGER) return INTEGER
  „  [F(X) = 2*X];
  function G(X:INTEGER) return INTEGER
  „  [G(X) = 3*F(X)]	;
end P;
°
=SML
store_mt_results mt_run_fail [
   ("fms1", fms1, (),
	 gen_fail_msg "update_theory_db_with_parainfo" 49006
	 ["G", 	"F"])
];
=TEX
\section{Renaming in Package Specifications}
=SML
clean_up();
new_script{name = "rename1", state = initial_cn_state};
¹CN
package P is
  VAR1 : INTEGER;
  function F (X : INTEGER) return INTEGER
  „  [F(X) = 2*X];
  procedure TEST1 (M : out INTEGER)
  „ M [M = VAR1];

end P;
°
=SML
val rn_state1 = get_cn_state();
new_script{name = "rename1a", state = rn_state1};
¹CN
with P;
package Q is
	VAR2 : INTEGER;
	function G  (X : INTEGER) return INTEGER renames P.F;
	procedure TEST2 (M : out INTEGER) renames P.TEST1;
end Q;
°
=SML
val rn_state2 = get_cn_state();
new_script{name = "rename1b", state = rn_state2};
¹CN
package body Q is
	procedure TEST2 (M : out INTEGER) renames P.TEST1;
begin
	„ VAR2 [PoVAR1 = 0, VAR2 = 0] (1)
end Q;
°
=SML
¹CN
(1) Ã TEST2(VAR2);
   VAR2 := G(VAR2);
°
=SML
val rn_state3 = get_cn_state();
new_script{name = "rename1c", state = rn_state3};
¹CN
with Q;
package R is
	VAR3 : INTEGER;
end R;
°
=SML
val rn_state4 = get_cn_state();
new_script{name = "rename1d", state = rn_state4};
¹CN
with P, Q;
package body R is
begin
	„ VAR3 [PoVAR1 = 0, VAR3 = 0] (2)
end R;
°
¹CN
(2) Ã Q.TEST2(VAR3);
°
=TEX
=SML
set_pc "cn";
set_goal([], get_conjecture "-" "vc2_2");
a(REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(strip_tac);
store_mt_results (mt_runf (op =$)) [
	("rename_3", concl o pop_thm, (), 
		get_conjecture "-" "vc2_2")
];
=TEX

Now demonstrate that need the renaming in the specification
to get the renamed procedure used in a future ``with'' clause.
=SML
new_script{name = "rename1a1", state = rn_state1};
¹CN
with P;
package Q1 is
	VAR2 : INTEGER;
end Q1;
°
=SML
val rn_state5 = get_cn_state();
new_script{name = "rename1b1", state = rn_state5};
¹CN
package body Q1 is
	procedure TEST2 (M : out INTEGER) renames P.TEST1;
	function G  (X : INTEGER) return INTEGER renames P.F;
begin
	„ VAR2 [PoVAR1 = 0, VAR2 = 0] (1)
end Q1;
°
¹CN
(1) Ã TEST2(VAR2);
   VAR2 := G(VAR2);
°
=SML
val rn_state6 = get_cn_state();
new_script{name = "rename1c1", state = rn_state6};
¹CN
with P, Q1;
package R is
	VAR3 : INTEGER;
end R;
°
=IGN
force_delete_theory "rename1d1";
=SML
val rn_state7 = get_cn_state();
new_script{name = "rename1d1", state = rn_state7};
¹CN
with P, Q1;
package body R is
begin
	„ VAR3 [PoVAR1 = 0, VAR3 = 0] (3)
end R;
°
=SML
fun rename1_1 () =
¹CN
(3) Ã Q1.TEST2(VAR3);
°
=SML
store_mt_results mt_run_fail [
   ("rename1_1", rename1_1, (),
	 gen_fail_msg "check_1_d" 505063 ["Q1oTEST2"])
];
=TEX

Now with renamed items having no formal parts.
=SML
clean_up();
new_script{name = "rename2", state = initial_cn_state};
¹CN
package P is
  VAR1 : INTEGER;
  function F (X : INTEGER) return INTEGER
  „  [F(X) = 2*X];
  procedure TEST1 (M : out INTEGER)
  „ M [M = VAR1];

end P;
°
=SML
val rn_state1 = get_cn_state();
new_script{name = "rename2a", state = rn_state1};
¹CN
with P;
package Q is
	VAR2 : INTEGER;
	function G return INTEGER renames P.F;
	procedure TEST2  renames P.TEST1;
end Q;
°
=SML
val rn_state2 = get_cn_state();
new_script{name = "rename2b", state = rn_state2};
¹CN
package body Q is
	procedure TEST2 (M : out INTEGER) renames P.TEST1;
begin
	„ VAR2 [PoVAR1 = 0, VAR2 = 0] (1)
end Q;
°
=SML
¹CN
(1) Ã TEST2(VAR2);
   VAR2 := G(VAR2);
°
=SML
set_pc "cn";
set_goal([], get_conjecture "-" "vc1_2");
a(REPEAT strip_tac);
a(rewrite_tac[z_get_spec ñG®]);
a(all_var_elim_asm_tac1);
val thm1 = rewrite_rule[](z_µ_elim ñ0® (±_right_elim (z_get_spec ñPoF®)));
a(fc_tac[thm1]);
store_mt_results (mt_runf (op =$)) [
	("rename_2", concl o pop_thm, (), 
		get_conjecture "-" "vc1_2")
];
=TEX
\section{Prefixing Formal Parameters}
=SML
clean_up();
new_script{name="prefix_fp", state=initial_cn_state};
¹CN
package F is
type T1 is range 0 .. 10;
C1 : constant T1 := T1'FIRST;
V1 : INTEGER;
procedure P1 (X: in T1; Y: out INTEGER) 
 „ Y [ X > T1vFIRST + V1 , Y > T1vFIRST + C1 ];
procedure P2 (X1: in T1; Y1: out INTEGER);
function F1 (X2: in T1; Y2: in INTEGER) return INTEGER
 „ [ X2 + Y2 > T1vFIRST , F1(X2, Y2) > T1vFIRST + C1 ];
function F2 (X3: in T1; Y3: in INTEGER) return T1
 „ [ X3 + Y3 > T1vFIRST , F2(X3, Y3) > T1vFIRST + C1 ];
function F3 (X2: in T1; Y2: in INTEGER) return INTEGER;
function F4 (X3: in T1; Y3: in INTEGER) return T1;
end F;
°
=SML
val state_pf1 = get_cn_state();
new_script{name="prefix_fp1", state=state_pf1};
fun prefix_fp () =
¹CN
with F;
package G is
V2 : INTEGER;
procedure P3 (X1: in F.T1; Y1: in out INTEGER) 
„ Y1 [ FoF1(X1, Y1‰0) + FoF2(X1, Y1‰0) + FoV1 > FoT1vFIRST + V2,
    FoF3(X1, Y1) + FoF4(X1, Y1) > FoT1vFIRST];
end G;
°

store_mt_results mt_run [
   ("prefix_fp", prefix_fp, (),())
];

=TEX
\section{Immediate Checking of Package Specifications}
=SML
clean_up();
new_script{name="immed1", state = initial_cn_state};
fun immed1() =
¹CN
package F is
procedure P1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ X > Z , Y > Z + V ];
end F;
°
=SML
fun immed2() =
¹CN
package F is
procedure P1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ X > Z + V, Y > Z];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed1", immed1, (),
	 gen_fail_msg "store_vcs" 507051 [
		"ñµ X : INTEGER; Y : INTEGER; Z : INTEGER | X > Z · Y > Z + V®",
		"ñV®"]),
   ("immed2", immed2, (),
	 gen_fail_msg "store_vcs" 507051 [
		"ñµ X : INTEGER; Y : INTEGER; Z : INTEGER | X > Z + V · Y > Z®",
		"ñV®"])
];
=TEX
=SML
fun immed3() =
¹CN
package F is
procedure P1 (X: in RUBBISH; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ Y > Z , Y > Z + V ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed3", immed3, (),
	 gen_fail_msg "zid" 508021 ["RUBBISH"])
];
=TEX
=SML
fun immed4() =
¹CN
package F is
function F1 (X: in INTEGER; Y: in INTEGER; Z: in INTEGER) return INTEGER
 „ Y [ X > Z , F1(X, Y, Z) > V ];
end F;
°
=SML
fun immed5() =
¹CN
package F is
function F1 (X: in INTEGER; Y: in INTEGER; Z: in INTEGER) return INTEGER
 „ Y [ X > V + Z , F1(X, Y, Z) > X ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed4", immed4, (),
	 gen_fail_msg "update_theory_db_with_parainfo" 49006 [
		"F1", "V"]),
   ("immed5", immed5, (),
	 gen_fail_msg "update_theory_db_with_parainfo" 49006 [
		"F1", "V"])
];
=TEX
=SML
fun immed6() =
¹CN
package F is
function F1 (X: in RUBBISH; Y: out INTEGER; Z: in out INTEGER) return INTEGER
 „ Y [ Y > Z , F1(X, Y, Z) > X ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed6", immed6, (),
	 gen_fail_msg "zid" 508021 ["RUBBISH"])
];
=TEX
=SML
fun immed7() =
¹CN
package F is
function F1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) return INTEGER
 „ Y [ Y > Z , F1(X, Y) > X ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed7", immed7, (), gen_fail_msg "Z-Parser" 62000 [])
];
=TEX
=SML
fun immed8() =
¹CN
package F is
procedure P1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ Y + Z , Y > Z + V ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed8", immed8, (),
	 gen_fail_msg "Z-Parser" 62000 [])
];
=TEX
=SML
fun immed9() =
¹CN
package F is
function F1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) return INTEGER
 „ Y [ Y + Z , F1(X, Y, Z) > X ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed9", immed9, (), gen_fail_msg "Z-Parser" 62000 [])
];
=TEX

=TEX
\section{SUMMARY OF RESULTS}
=SML
diag_string(summarize_mt_results());
=TEX

\end{document}

