% @(#)
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Z Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT507}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$7%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthor{K.~Blackburn & WIN01}
\TPPauthorisation{R.D.~Arthan & DAZ Manager}
\TPPabstract{This document contains tests for theory hierarchy material
implemented in the Z Generator material.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : International Computers Ltd \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item[Issue 1.1-1.2]
First drafts.
\item[Issue 1.3]
Change to one compilation unit per script.
\end{description}
\subsection{Changes forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains module tests for theory hierarchy 
effects of the functions defined 
in \cite{ISS/HAT/DAZ/DTD507}.
\subsection{Introduction}
\subsubsection{Background and Purpose}
See \cite{ISS/HAT/DAZ/DTD507}. 
In general the material in this document is tested by the various
integration test documents in the DAZ project.
However, the changes in theory hierarchy structure caused by $new\_script1$
and other functions is not tested elsewhere.
\subsubsection{Dependencies}
These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.

The tests rely on ISS/HAT/DAZ/IMP516, or require the $CNZGenerator$ 
structure to be opened.

\subsubsection{Possible Enhancements}
None known.
\subsubsection{Deficiencies}
None known.

\section{PREAMBLE}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results();
=TEX
\section{THE TESTS}
\subsection{Useful functions}
=SML
fun clean_up () = (
        let     val thys = (get_descendants "cn" less "cn")
                                        diff get_cache_theories();
                fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
        in      map del_thy thys
        end;    ()
);
=TEX
=SML
fun sl_format (sl : string list) : string = format_list Combinators.I sl ", ";

=TEX
\subsection{$new\_script$}
=SML
clean_up();
new_script{name = "mdt507ns_1", state=initial_cn_state};
=TEX
¹CN
package mdt507NS_1_1 is
	VAR1 : INTEGER;

	procedure TEST1 (M : out INTEGER)
	„ M [VAR1 = 0, M = 0];

end mdt507NS_1_1;
°
=SML
store_mt_results mt_run [
	("ns_1_1a_gp", sl_format o get_parents, "mdt507ns_1", "cn"),
	("ns_1_1a_gc", sl_format o get_children, "mdt507ns_1", ""),
	("ns_1_1a_gcnc", sl_format o get_children, "cn", "mdt507ns_1")
	
];
=TEX
=SML 
val statea = get_cn_state();
new_script{name = "mdt507ns_1a", state=statea};
¹CN
 with mdt507NS_1_1;
  procedure TEST2
  is
  begin
       mdt507NS_1_1.VAR1 := 0;
  end TEST2;
°
=SML
store_mt_results_show mt_run [
	("ns_1_1b_gp", sl_format o get_parents, "mdt507ns_1a", 
		"MDT507NS_1_1spec, cn"),
	("ns_1_1b_gc", sl_format o get_children, "mdt507ns_1a", ""),
	("ns_1_1b_gcnc", sl_format o get_children, "cn", 
		"MDT507NS_1_1spec, mdt507ns_1a, mdt507ns_1")
];
=TEX
=SML 
val stateb = get_cn_state();
new_script{name = "mdt507ns_1b", state=stateb};
¹CN
package body mdt507NS_1_1 is

	procedure TEST1 (M : out INTEGER)
	„ M [VAR1 = 0, M = 0]
	is
	begin
		M := VAR1;
	end TEST1;

begin
	VAR1 := 2;

end mdt507NS_1_1;
°
=SML
store_mt_results mt_run [
	("ns_1_1c_gp", sl_format o get_parents, "mdt507ns_1b", 
		"cn"),
	("ns_1_1c_gc", sl_format o get_children, "mdt507ns_1b", ""),
	("ns_1_1c_gcnc", sl_format o get_children, "cn", 
		"mdt507ns_1b, MDT507NS_1_1spec, mdt507ns_1a, mdt507ns_1")	
];

=TEX
=SML 
val statec = get_cn_state();
new_script{name = "mdt507ns_1c", state=statec};
¹CN
 procedure TEST3 is
    VAR2 : INTEGER;
    procedure TEST4 is separate;
    function TEST5 (I : INTEGER) return INTEGER is separate;
 begin
    null;
    TEST4;
    VAR2 := TEST5( 0 );
 end TEST3;
°
=SML
store_mt_results mt_run [
	("ns_1_1d_gp", sl_format o get_parents, "mdt507ns_1c", 
		"cn"),
	("ns_1_1d_gc", sl_format o get_children, "mdt507ns_1c", ""),
	("ns_1_1d_gcnc", sl_format o get_children, "cn", 
		"TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns_1c, mdt507ns_1b, MDT507NS_1_1spec, mdt507ns_1a, mdt507ns_1"),
	("ns_1_1d_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"cn"),
	("ns_1_1d_gcstub", sl_format o get_children, "TEST3oTEST5stub", "")
];
=TEX
=SML
val state_ns_1 = get_cn_state();
new_script{name="mdt507ns_2", state=state_ns_1};
¹CN
 separate (TEST3)
    procedure TEST4 is begin VAR2 := 1; end TEST4;
°
=SML
store_mt_results mt_run [
	("ns_1_1e_gp", sl_format o get_parents, "mdt507ns_2", 
		"TEST3oTEST4stub, cn"),
	("ns_1_1e_gc", sl_format o get_children, "mdt507ns_2", ""),
	("ns_1_1e_gcnc", sl_format o get_children, "cn", 
"mdt507ns_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns_1c, mdt507ns_1b, MDT507NS_1_1spec, mdt507ns_1a, mdt507ns_1"),
	("ns_1_1e_gpstub", sl_format o get_parents, "TEST3oTEST4stub", 
		"cn"),
	("ns_1_1e_gcstub", sl_format o get_children, "TEST3oTEST4stub",
		"mdt507ns_2")
];

=TEX
=SML
val state_ns_2 = get_cn_state();
new_script{name="mdt507ns_3", state=state_ns_2};
¹CN
 separate (TEST3)
    function TEST5 (I : INTEGER) return INTEGER is
    begin return 0; end TEST5;
°
=SML
store_mt_results mt_run [
	("ns_1_1f_gp", sl_format o get_parents, "mdt507ns_3", 
		"TEST3oTEST5stub, cn"),
	("ns_1_1f_gc", sl_format o get_children, "mdt507ns_3", ""),
	("ns_1_1f_gcnc", sl_format o get_children, "cn", 
"mdt507ns_3, mdt507ns_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns_1c, mdt507ns_1b, MDT507NS_1_1spec, mdt507ns_1a, mdt507ns_1"),
	("ns_1_1f_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"cn"),
	("ns_1_1f_gcstub", sl_format o get_children, "TEST3oTEST5stub",
		"mdt507ns_3")
];
=TEX
\subsection{$new\_script1$ - No Library theories}
=SML
clean_up();
new_script1{name = "mdt507ns1_1", state=initial_cn_state, library_theories=[]};
=TEX
¹CN
package mdt507NS_1_1 is
	VAR1 : INTEGER;

	procedure TEST1 (M : out INTEGER)
	„ M [VAR1 = 0, M = 0];

end mdt507NS_1_1;
°
=SML
store_mt_results mt_run [
	("ns1_1_1a_gp", sl_format o get_parents, "mdt507ns1_1", "cn"),
	("ns1_1_1a_gc", sl_format o get_children, "mdt507ns1_1", ""),
	("ns1_1_1a_gcnc", sl_format o get_children, "cn", "mdt507ns1_1")
	
];
=TEX
=SML
val statea = get_cn_state();
new_script1{name = "mdt507ns1_1a", state=statea, library_theories=[]};
¹CN
 with mdt507NS_1_1;
  procedure TEST2
  is
  begin
       mdt507NS_1_1.VAR1 := 0;
  end TEST2;
°
=SML
store_mt_results mt_run [
	("ns1_1_1b_gp", sl_format o get_parents, "mdt507ns1_1a", 
		"MDT507NS_1_1spec, cn"),
	("ns1_1_1b_gc", sl_format o get_children, "mdt507ns1_1a", ""),
	("ns1_1_1b_gcnc", sl_format o get_children, "cn", 
		"MDT507NS_1_1spec, mdt507ns1_1a, mdt507ns1_1")
	
];
=TEX
=SML
val stateb = get_cn_state();
new_script1{name = "mdt507ns1_1b", state=stateb, library_theories=[]};
¹CN
package body mdt507NS_1_1 is

	procedure TEST1 (M : out INTEGER)
	„ M [VAR1 = 0, M = 0]
	is
	begin
		M := VAR1;
	end TEST1;

begin
	VAR1 := 2;

end mdt507NS_1_1;
°
=SML
store_mt_results mt_run [
	("ns1_1_1c_gp", sl_format o get_parents, "mdt507ns1_1b", 
		"cn"),
	("ns1_1_1c_gc", sl_format o get_children, "mdt507ns1_1b", ""),
	("ns1_1_1c_gcnc", sl_format o get_children, "cn", 
		"mdt507ns1_1b, MDT507NS_1_1spec, mdt507ns1_1a, mdt507ns1_1")	
];
=TEX
=SML
val statec = get_cn_state();
new_script1{name = "mdt507ns1_1c", state=statec, library_theories=[]};
¹CN
 procedure TEST3 is
    VAR2 : INTEGER;
    procedure TEST4 is separate;
    function TEST5 (I : INTEGER) return INTEGER is separate;
 begin
    null;
    TEST4;
    VAR2 := TEST5( 0 );
 end TEST3;
°
=SML
store_mt_results mt_run [
	("ns1_1_1d_gp", sl_format o get_parents, "mdt507ns1_1c", 
		"cn"),
	("ns1_1_1d_gc", sl_format o get_children, "mdt507ns1_1c", ""),
	("ns1_1_1d_gcnc", sl_format o get_children, "cn", 
		"TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1_1c, mdt507ns1_1b, MDT507NS_1_1spec, mdt507ns1_1a, mdt507ns1_1"),
	("ns1_1_1d_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"cn"),
	("ns1_1_1d_gcstub", sl_format o get_children, "TEST3oTEST5stub", "")
];
=TEX
=SML
val state_ns1_1 = get_cn_state();
new_script1{name="mdt507ns1_2", state=state_ns1_1, library_theories=[]};
¹CN
 separate (TEST3)
    procedure TEST4 is begin VAR2 := 1; end TEST4;
°
=SML
store_mt_results mt_run [
	("ns1_1_1e_gp", sl_format o get_parents, "mdt507ns1_2", 
		"TEST3oTEST4stub, cn"),
	("ns1_1_1e_gc", sl_format o get_children, "mdt507ns1_2", ""),
	("ns1_1_1e_gcnc", sl_format o get_children, "cn", 
"mdt507ns1_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1_1c, mdt507ns1_1b, MDT507NS_1_1spec, mdt507ns1_1a, mdt507ns1_1"),
	("ns1_1_1e_gpstub", sl_format o get_parents, "TEST3oTEST4stub", 
		"cn"),
	("ns1_1_1e_gcstub", sl_format o get_children, "TEST3oTEST4stub",
		"mdt507ns1_2")
];

=TEX
=SML
val state_ns1_2 = get_cn_state();
new_script1{name="mdt507ns1_3", state=state_ns1_2, library_theories=[]};
¹CN
 separate (TEST3)
    function TEST5 (I : INTEGER) return INTEGER is
    begin return 0; end TEST5;
°
=SML
store_mt_results_show mt_run [
	("ns1_1_1f_gp", sl_format o get_parents, "mdt507ns1_3", 
		"TEST3oTEST5stub, cn"),
	("ns1_1_1f_gc", sl_format o get_children, "mdt507ns1_3", ""),
	("ns1_1_1f_gcnc", sl_format o get_children, "cn", 
"mdt507ns1_3, mdt507ns1_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1_1c, mdt507ns1_1b, MDT507NS_1_1spec, mdt507ns1_1a, mdt507ns1_1"),
	("ns1_1_1f_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"cn"),
	("ns1_1_1f_gcstub", sl_format o get_children, "TEST3oTEST5stub",
		"mdt507ns1_3")
];
=TEX
\subsection{$new\_script1$ - Two Library theories}
=SML
clean_up();
new_theory "A";
=TEX
¹Z
Ü ABST1 ::= Abs1
°
=SML
open_theory "cn";
new_theory "B";
=TEX
¹Z
Ü ABST2 ::= Abs2
°
=SML
open_theory "cn";
new_theory "C";
=TEX
¹Z
Ü ABST3 ::= Abs3
°
=SML
new_script1{name = "mdt507ns1x2_1", state=initial_cn_state, library_theories=["A", "B"]};
=TEX
¹CN
package mdt507NS1X2_1_1 is
	VAR1 : INTEGER;

	procedure TEST1 (M : out INTEGER)
	„ M [VAR1 = 0, M = 0];

end mdt507NS1X2_1_1;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1a_gp", sl_format o get_parents, "mdt507ns1x2_1", "B, A, cn"),
	("ns1x2_1_1a_gc", sl_format o get_children, "mdt507ns1x2_1", ""),
	("ns1x2_1_1a_gcnc", sl_format o get_children, "cn", "mdt507ns1x2_1, C, B, A")	
];
=TEX
=SML
val statea = get_cn_state();
new_script1{name = "mdt507ns1x2_1a", state=statea, library_theories=["A", "B"]};
¹CN
 with mdt507NS1X2_1_1;
  procedure TEST2
  is
  begin
       mdt507NS1X2_1_1.VAR1 := 0;
  end TEST2;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1b_gp", sl_format o get_parents, "mdt507ns1x2_1a", 
		"MDT507NS1X2_1_1spec, B, A, cn"),
	("ns1x2_1_1b_gc", sl_format o get_children, "mdt507ns1x2_1a", ""),
	("ns1x2_1_1b_gcnc", sl_format o get_children, "cn", 
		"MDT507NS1X2_1_1spec, mdt507ns1x2_1a, mdt507ns1x2_1, C, B, A")
];
=TEX
=SML
val stateb = get_cn_state();
new_script1{name = "mdt507ns1x2_1b", state=stateb, library_theories=["A", "B"]};
¹CN
package body mdt507NS1X2_1_1 is

	procedure TEST1 (M : out INTEGER)
	„ M [VAR1 = 0, M = 0]
	is
	begin
		M := VAR1;
	end TEST1;

begin
	VAR1 := 2;

end mdt507NS1X2_1_1;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1c_gp", sl_format o get_parents, "mdt507ns1x2_1b", 
		"B, A, cn"),
	("ns1x2_1_1c_gc", sl_format o get_children, "mdt507ns1x2_1b", ""),
	("ns1x2_1_1c_gcnc", sl_format o get_children, "cn", 
	"mdt507ns1x2_1b, MDT507NS1X2_1_1spec, mdt507ns1x2_1a, mdt507ns1x2_1, C, B, A")	
];
=TEX
=SML
val statec = get_cn_state();
new_script1{name = "mdt507ns1x2_1c", state=statec, library_theories=["A", "B"]};
¹CN
 procedure TEST3 is
    VAR2 : INTEGER;
    procedure TEST4 is separate;
    function TEST5 (I : INTEGER) return INTEGER is separate;
 begin
    null;
    TEST4;
    VAR2 := TEST5( 0 );
 end TEST3;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1d_gp", sl_format o get_parents, "mdt507ns1x2_1c", 
		"B, A, cn"),
	("ns1x2_1_1d_gc", sl_format o get_children, "mdt507ns1x2_1c", ""),
	("ns1x2_1_1d_gcnc", sl_format o get_children, "cn", 
		"TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1x2_1c, mdt507ns1x2_1b, MDT507NS1X2_1_1spec, mdt507ns1x2_1a, mdt507ns1x2_1, C, B, A"),
	("ns1x2_1_1d_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"B, A, cn"),
	("ns1x2_1_1d_gcstub", sl_format o get_children, "TEST3oTEST5stub", "")
];
=TEX
=SML
val state_ns1x2_1 = get_cn_state();
new_script1{name="mdt507ns1x2_2", state=state_ns1x2_1, library_theories=["C"]};
¹CN
 separate (TEST3)
    procedure TEST4 is begin VAR2 := 1; end TEST4;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1e_gp", sl_format o get_parents, "mdt507ns1x2_2", 
		"TEST3oTEST4stub, C, cn"),
	("ns1x2_1_1e_gc", sl_format o get_children, "mdt507ns1x2_2", ""),
	("ns1x2_1_1e_gcnc", sl_format o get_children, "cn", 
"mdt507ns1x2_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1x2_1c, mdt507ns1x2_1b, MDT507NS1X2_1_1spec, mdt507ns1x2_1a, mdt507ns1x2_1, C, B, A"),
	("ns1x2_1_1e_gpstub", sl_format o get_parents, "TEST3oTEST4stub", 
		"B, A, cn"),
	("ns1x2_1_1e_gcstub", sl_format o get_children, "TEST3oTEST4stub",
		"mdt507ns1x2_2")
];
=TEX
=SML
val state_ns1x2_2 = get_cn_state();
new_script1{name="mdt507ns1x2_3", state=state_ns1x2_2, library_theories=["C"]};
¹CN
 separate (TEST3)
    function TEST5 (I : INTEGER) return INTEGER is
    begin return 0; end TEST5;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1f_gp", sl_format o get_parents, "mdt507ns1x2_3", 
		"TEST3oTEST5stub, C, cn"),
	("ns1x2_1_1f_gc", sl_format o get_children, "mdt507ns1x2_3", ""),
	("ns1x2_1_1f_gcnc", sl_format o get_children, "cn", 
"mdt507ns1x2_3, mdt507ns1x2_2, TEST3oTEST5stub, TEST3oTEST4stub, mdt507ns1x2_1c, mdt507ns1x2_1b, MDT507NS1X2_1_1spec, mdt507ns1x2_1a, mdt507ns1x2_1, C, B, A"),
	("ns1x2_1_1f_gpstub", sl_format o get_parents, "TEST3oTEST5stub", 
		"B, A, cn"),
	("ns1x2_1_1f_gcstub", sl_format o get_children, "TEST3oTEST5stub",
		"mdt507ns1x2_3")
];
=TEX
\subsection{Error Messages}
=IGN
new_error_message {id= 50742, text = 
"Library theory ?0 cannot be made a parent of the script theory: ?1" };
=SML
clean_up();
store_mt_results mt_run_fail [
   ("ns1_fail_507042a", new_script1,
	{name="fail1", state = initial_cn_state, library_theories=["rubbish"]},
	 gen_fail_msg "new_script1" 507042
	 ["rubbish", "Theory rubbish is not present in the current hierarchy" ])
];
clean_up();
store_mt_results mt_run_fail [
   ("ns1_fail_507042b", new_script1,
	{name="fail2", state = initial_cn_state, library_theories=["fail2"]},
	 gen_fail_msg "new_script1" 507042
	 ["fail2", "Suggested parent fail2 is a child of the current theory" ])
];
=TEX
\pagebreak

\section{SUMMARY OF RESULTS}
=SML
diag_string(summarize_mt_results());
=TEX

\end{document}

