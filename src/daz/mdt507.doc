=IGN
********************************************************************************
mdt507.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% %Z% $Revision: 1.42 $ $RCSfile: mdt507.doc,v $ $Date: 2006/03/29 08:07:09 $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Z Generator}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT507}  %% Mandatory field
\def\SCCSversion{$Revision: 1.42 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2006/03/29 08:07:09 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{SML Literate Script}
\TPPkeywords{}
%\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthor{K.~Blackburn & WIN01}
\TPPauthorisation{R.D.~Arthan & DAZ Manager}
\TPPabstract{This document contains tests for theory hierarchy material
implemented in the Z Generator material.}
\TPPdistribution{\parbox[t]{4.0in}{%
	    Library
}}
\begin{document}
\makeTPPfrontpage
\vfill
\begin{centering}
\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year
\end{centering}
\pagebreak
\section{Document control}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes history} 
\begin{description}
\item[Issue 1.1-1.2]
First drafts.
\item[Issue 1.3]
Change to one compilation unit per script.
\item[Issue 1.4]
IUCT WP 2 changes.
\item[Issue 1.5]
Checking Check 17.
\item[Issue 1.6]
Adding renaming in specifications material.
\item[Issue 1.7 - 1.9]
Changes from IUCT WP 2 and WP 7.
\item[Issue 1.10]
Clashes between formal parameters and variables or constants.
\item[Issue 1.11-12]
IUCT WP 3 changes.
\item[Issue 1.13]
IUCT WP 5 changes.
\item[Issue 1.14]
IUCT WP 3 - references clauses package names must exist test.
\item[Issue 1.15,1.16]
IUCT WP 3 - extra references clauses required now $pack\_spec\_with\_modules$
has gone away.
\item[Issue 1.17]
Added tests for $print\_z\_document$ and $z\_prefix$ for non-axiomatic mode
definitions.
Added tests for references.
\item[Issue 1.18] CTLE II R2/1: global variable unsoundness.
\item[Issue 1.19] R0065: duplicate names now allowed in context clauses.
\item[Issue 1.20] {\it ExtendedIO.execute} has now been withdrawn.
\item[Issue 1.21] Allowed for slightly different error behavour as a result of spring 2002 enhancements..
\item[Issue 1.22] Copyright and banner updates for open source release.
\item[Issue 1.23] DAZ-specific updates to banner for open source release
\item[Issue 1.24] DAZ-specific updates to banner for open source release
\item[Issue 1.25] No longer relies on default setting for case of Ada keywords.
\item[Issue 1.26] Allowed for improved early type-checking of specification statements.
\item[Issue 1.27] Fixed broken test ``refer1.11''.
\item[Issue 1.28] The SPARK program is now referred to as the Ada program.
\item[Issues 1.29, 1.30] Allowed for some changed error messages.
\item[Issue 1.31] Fixed error in test on procedure renaming
\item[Issue 1.32] Compliance Notation reserved words are now prefixed by a dollar sign.
\item[Issues 1.33, 1.34] Allowed for enhanced error messages.
\item[Issues 1.35] Allowed for corrections to error analysis.
\item[Issues 1.36, 1.37] Allowing for enhancement 117.
\item[Issue 1.38] Beginning on enhancement 118.
\item[Issue 1.39] More on enhancement 117.
\item[Issue 1.40] Allowed for automated state management.
\item[Issues 1.41, 1.42] Fully allowed for enhancement 118.
\item[Issue 1.43] Allowed for insistence on canonical names in Z under enhancement 117
\end{description}
\subsection{Changes forecast}
None.
\section{GENERAL}
\subsection{Scope}
This document contains module tests for theory hierarchy 
effects of the functions defined 
in \cite{ISS/HAT/DAZ/DTD507}.
\subsection{Introduction}
\subsubsection{Background and Purpose}
See \cite{ISS/HAT/DAZ/DTD507}. 
In general the material in this document is tested by the various
integration test documents in the DAZ project.
However, the changes in theory hierarchy structure caused by $new\_script1$
and other functions is not tested elsewhere.
\subsubsection{Dependencies}
These tests depend on
the test harness as implemented in DS/FMU/IED/IMP013, and
its corresponding detailed design document, DS/FMU/IED/DTD013.

The tests rely on ISS/HAT/DAZ/IMP516, or require the $CNZGenerator$ 
structure to be opened.

\subsubsection{Possible Enhancements}
None known.
\subsubsection{Deficiencies}
None known.

\section{PREAMBLE}
=SML
use_file "dtd013.sml";
use_file "imp013.sml";
init_mt_results();
=TEX
\section{THE TESTS}
We use upper case for Ada keywords in the tests:
=SML
set_string_control("case_of_ada_keywords", "upper");
=TEX
\subsection{Useful functions}
=SML
val reset_cn = pending_reset_cn_state();
fun clean_up () = (
        let     val thys = (get_descendants "cn" less "cn")
                                        diff get_cache_theories();
                fun del_thy thy = (force_delete_theory thy handle Fail _ => ());
        in 	map del_thy thys;
		reset_cn()
        end;	()
);
=TEX
=SML
fun sl_format (sl : string list) : string = format_list Combinators.I sl ", ";
=TEX

\subsection{$new\_script$}
First check that we really need to use $new\_script$:
=SML
clean_up();
fun cn_created1 () = 
¹CN
package cn_created is
	VAR1 : INTEGER;
end cn_created;
°
=SML
store_mt_results_show mt_run_fail [
	("cn_created1", cn_created1, (), 
		gen_fail_msg "check17" 507056 [
			"CN_CREATED",
			"cn"])
];
=SML
new_theory "temp";
fun cn_created2 () = 
¹CN
package cn_created is
	VAR1 : INTEGER;
end cn_created;
°
=SML
store_mt_results mt_run_fail [
	("cn_created2", cn_created1, (), 
		gen_fail_msg "check17" 507056 [
			"CN_CREATED",
			"temp"])
];
=SML
clean_up();
new_script{name = "MDT507NS_1_1'spec"};
=TEX
¹CN
package mdt507NS_1_1 is
	VAR1 : INTEGER;

	procedure TEST1 (M : out INTEGER)
	„ M ˜ MDT507NS_1_1oVAR1 [MDT507NS_1_1oVAR1 = 0, M = 0];

end mdt507NS_1_1;
°
=SML
store_mt_results mt_run [
	("ns_1_1a_gp", sl_format o get_parents, "MDT507NS_1_1'spec", "cn"),
	("ns_1_1a_gc", sl_format o get_children, "MDT507NS_1_1'spec", ""),
	("ns_1_1a_gcnc", sl_format o get_children, "cn", "MDT507NS_1_1'spec")
	
];
=TEX
=SML 
new_script{name = "TEST2'proc"};
¹CN
 with mdt507NS_1_1;
  procedure TEST2
  is
  begin
       mdt507NS_1_1.VAR1 := 0;
  end TEST2;
°
=SML
store_mt_results_show mt_run [
	("ns_1_1b_gp", sl_format o get_parents, "TEST2'proc", 
		"MDT507NS_1_1'spec, cn"),
	("ns_1_1b_gc", sl_format o get_children, "TEST2'proc", ""),
	("ns_1_1b_gcnc", sl_format o get_children, "cn", 
		"TEST2'proc, MDT507NS_1_1'spec")
];
=TEX
=SML 
new_script{name = "MDT507NS_1_1'body"};
¹CN
package body mdt507NS_1_1 is

	procedure TEST1 (M : out INTEGER)
	„ M ˜ MDT507NS_1_1oVAR1 [MDT507NS_1_1oVAR1 = 0, M = 0]
	is
	begin
		M := VAR1;
	end TEST1;

begin
	VAR1 := 2;

end mdt507NS_1_1;
°
=SML
store_mt_results mt_run [
	("ns_1_1c_gp", sl_format o get_parents, "MDT507NS_1_1'body", 
		"MDT507NS_1_1'spec, cn"),
	("ns_1_1c_gc", sl_format o get_children, "MDT507NS_1_1'body", ""),
	("ns_1_1c_gcnc", sl_format o get_children, "cn", 
		"MDT507NS_1_1'body, TEST2'proc, MDT507NS_1_1'spec")	
];

=TEX
=SML 
new_script{name = "TEST3'proc"};
¹CN
 procedure TEST3 is
    VAR2 : INTEGER;
    procedure TEST4 is separate;
    function TEST5 (I : INTEGER) return INTEGER is separate;
 begin
    null;
    TEST4;
    VAR2 := TEST5( 0 );
 end TEST3;
°
=SML
store_mt_results mt_run [
	("ns_1_1d_gp", sl_format o get_parents, "TEST3'proc", 
		"cn"),
	("ns_1_1d_gc", sl_format o get_children, "TEST3'proc", ""),
	("ns_1_1d_gcnc", sl_format o get_children, "cn", 
		"TEST3oTEST5'stub, TEST3oTEST4'stub, TEST3'proc, MDT507NS_1_1'body, TEST2'proc, MDT507NS_1_1'spec"),
	("ns_1_1d_gpstub", sl_format o get_parents, "TEST3oTEST5'stub", 
		"cn"),
	("ns_1_1d_gcstub", sl_format o get_children, "TEST3oTEST5'stub", "")
];
=TEX
=SML
new_script{name="TEST3oTEST4'proc"};
¹CN
 separate (TEST3)
    procedure TEST4 is begin VAR2 := 1; end TEST4;
°
=SML
store_mt_results mt_run [
	("ns_1_1e_gp", sl_format o get_parents, "TEST3oTEST4'proc", 
		"TEST3oTEST4'stub, cn"),
	("ns_1_1e_gc", sl_format o get_children, "TEST3oTEST4'proc", ""),
	("ns_1_1e_gcnc", sl_format o get_children, "cn", 
"TEST3oTEST4'proc, TEST3oTEST5'stub, TEST3oTEST4'stub, TEST3'proc, MDT507NS_1_1'body, TEST2'proc, MDT507NS_1_1'spec"),
	("ns_1_1e_gpstub", sl_format o get_parents, "TEST3oTEST4'stub", 
		"cn"),
	("ns_1_1e_gcstub", sl_format o get_children, "TEST3oTEST4'stub",
		"TEST3oTEST4'proc")
];

=TEX
=SML
new_script{name="TEST3oTEST5'func"};
¹CN
 separate (TEST3)
    function TEST5 (I : INTEGER) return INTEGER is
    begin return 0; end TEST5;
°
=SML
store_mt_results mt_run [
	("ns_1_1f_gp", sl_format o get_parents, "TEST3oTEST5'func", 
		"TEST3oTEST5'stub, cn"),
	("ns_1_1f_gc", sl_format o get_children, "TEST3oTEST5'func", ""),
	("ns_1_1f_gcnc", sl_format o get_children, "cn", 
"TEST3oTEST5'func, TEST3oTEST4'proc, TEST3oTEST5'stub, TEST3oTEST4'stub, TEST3'proc, MDT507NS_1_1'body, TEST2'proc, MDT507NS_1_1'spec"),
	("ns_1_1f_gpstub", sl_format o get_parents, "TEST3oTEST5'stub", 
		"cn"),
	("ns_1_1f_gcstub", sl_format o get_children, "TEST3oTEST5'stub",
		"TEST3oTEST5'func")
];
=TEX
\subsection{$new\_script1$ - No Library theories}
=SML
clean_up();
new_script1{name = "MDT507NS_1_1'spec", library_theories=[]};
=TEX
¹CN
package mdt507NS_1_1 is
	VAR1 : INTEGER;

	procedure TEST1 (M : out INTEGER)
	„ M ˜ MDT507NS_1_1oVAR1 [MDT507NS_1_1oVAR1 = 0, M = 0];

end mdt507NS_1_1;
°
=SML
store_mt_results mt_run [
	("ns1_1_1a_gp", sl_format o get_parents, "MDT507NS_1_1'spec", "cn"),
	("ns1_1_1a_gc", sl_format o get_children, "MDT507NS_1_1'spec", ""),
	("ns1_1_1a_gcnc", sl_format o get_children, "cn", "MDT507NS_1_1'spec")
	
];
=TEX
=SML
new_script1{name = "TEST2'proc", library_theories=[]};
¹CN
 with mdt507NS_1_1;
  procedure TEST2
  is
  begin
       mdt507NS_1_1.VAR1 := 0;
  end TEST2;
°
=SML
store_mt_results mt_run [
	("ns1_1_1b_gp", sl_format o get_parents, "TEST2'proc", 
		"MDT507NS_1_1'spec, cn"),
	("ns1_1_1b_gc", sl_format o get_children, "TEST2'proc", ""),
	("ns1_1_1b_gcnc", sl_format o get_children, "cn", 
		"TEST2'proc, MDT507NS_1_1'spec")
	
];
=TEX
=SML
new_script1{name = "MDT507NS_1_1'body", library_theories=[]};
¹CN
package body mdt507NS_1_1 is

	procedure TEST1 (M : out INTEGER)
	„ M ˜ MDT507NS_1_1oVAR1 [MDT507NS_1_1oVAR1 = 0, M = 0]
	is
	begin
		M := VAR1;
	end TEST1;

begin
	VAR1 := 2;

end mdt507NS_1_1;
°
=SML
store_mt_results mt_run [
	("ns1_1_1c_gp", sl_format o get_parents, "MDT507NS_1_1'body", 
		"MDT507NS_1_1'spec, cn"),
	("ns1_1_1c_gc", sl_format o get_children, "MDT507NS_1_1'body", ""),
	("ns1_1_1c_gcnc", sl_format o get_children, "cn", 
		"MDT507NS_1_1'body, TEST2'proc, MDT507NS_1_1'spec")	
];
=TEX
=SML
new_script1{name = "TEST3'proc", library_theories=[]};
¹CN
 procedure TEST3 is
    VAR2 : INTEGER;
    procedure TEST4 is separate;
    function TEST5 (I : INTEGER) return INTEGER is separate;
 begin
    null;
    TEST4;
    VAR2 := TEST5( 0 );
 end TEST3;
°
=SML
store_mt_results mt_run [
	("ns1_1_1d_gp", sl_format o get_parents, "TEST3'proc", 
		"cn"),
	("ns1_1_1d_gc", sl_format o get_children, "TEST3'proc", ""),
	("ns1_1_1d_gcnc", sl_format o get_children, "cn", 
		"TEST3oTEST5'stub, TEST3oTEST4'stub, TEST3'proc, MDT507NS_1_1'body, TEST2'proc, MDT507NS_1_1'spec"),
	("ns1_1_1d_gpstub", sl_format o get_parents, "TEST3oTEST5'stub", 
		"cn"),
	("ns1_1_1d_gcstub", sl_format o get_children, "TEST3oTEST5'stub", "")
];
=TEX
=SML
new_script1{name="TEST3oTEST4'proc", library_theories=[]};
¹CN
 separate (TEST3)
    procedure TEST4 is begin VAR2 := 1; end TEST4;
°
=SML
store_mt_results mt_run [
	("ns1_1_1e_gp", sl_format o get_parents, "TEST3oTEST4'proc", 
		"TEST3oTEST4'stub, cn"),
	("ns1_1_1e_gc", sl_format o get_children, "TEST3oTEST4'proc", ""),
	("ns1_1_1e_gcnc", sl_format o get_children, "cn", 
"TEST3oTEST4'proc, TEST3oTEST5'stub, TEST3oTEST4'stub, TEST3'proc, MDT507NS_1_1'body, TEST2'proc, MDT507NS_1_1'spec"),
	("ns1_1_1e_gpstub", sl_format o get_parents, "TEST3oTEST4'stub", 
		"cn"),
	("ns1_1_1e_gcstub", sl_format o get_children, "TEST3oTEST4'stub",
		"TEST3oTEST4'proc")
];

=TEX
=SML
new_script1{name="TEST3oTEST5'func", library_theories=[]};
¹CN
 separate (TEST3)
    function TEST5 (I : INTEGER) return INTEGER is
    begin return 0; end TEST5;
°
=SML
store_mt_results_show mt_run [
	("ns1_1_1f_gp", sl_format o get_parents, "TEST3oTEST5'func", 
		"TEST3oTEST5'stub, cn"),
	("ns1_1_1f_gc", sl_format o get_children, "TEST3oTEST5'func", ""),
	("ns1_1_1f_gcnc", sl_format o get_children, "cn", 
"TEST3oTEST5'func, TEST3oTEST4'proc, TEST3oTEST5'stub, TEST3oTEST4'stub, TEST3'proc, MDT507NS_1_1'body, TEST2'proc, MDT507NS_1_1'spec"),
	("ns1_1_1f_gpstub", sl_format o get_parents, "TEST3oTEST5'stub", 
		"cn"),
	("ns1_1_1f_gcstub", sl_format o get_children, "TEST3oTEST5'stub",
		"TEST3oTEST5'func")
];
=TEX
\subsection{$new\_script1$ - Two Library theories}
=SML
clean_up();
new_theory "A";
=TEX
¹Z
Ü ABST1 ::= Abs1
°
=SML
open_theory "cn";
new_theory "B";
=TEX
¹Z
Ü ABST2 ::= Abs2
°
=SML
open_theory "cn";
new_theory "C";
=TEX
¹Z
Ü ABST3 ::= Abs3
°
=SML
new_script1{name = "MDT507NS1X2_1_1'spec", library_theories=["A", "B"]};
=TEX
¹CN
package mdt507NS1X2_1_1 is
	VAR1 : INTEGER;

	procedure TEST1 (M : out INTEGER)
	„ M ˜ MDT507NS1X2_1_1oVAR1 [MDT507NS1X2_1_1oVAR1 = 0, M = 0];

end mdt507NS1X2_1_1;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1a_gp", sl_format o get_parents, "MDT507NS1X2_1_1'spec", "B, A, cn"),
	("ns1x2_1_1a_gc", sl_format o get_children, "MDT507NS1X2_1_1'spec", ""),
	("ns1x2_1_1a_gcnc", sl_format o get_children, "cn", "MDT507NS1X2_1_1'spec, C, B, A")	
];
=TEX
=SML
new_script1{name = "TEST2'proc", library_theories=["A", "B"]};
¹CN
 with mdt507NS1X2_1_1;
  procedure TEST2
  is
  begin
       mdt507NS1X2_1_1.VAR1 := 0;
  end TEST2;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1b_gp", sl_format o get_parents, "TEST2'proc", 
		"MDT507NS1X2_1_1'spec, B, A, cn"),
	("ns1x2_1_1b_gc", sl_format o get_children, "TEST2'proc", ""),
	("ns1x2_1_1b_gcnc", sl_format o get_children, "cn", 
		"TEST2'proc, MDT507NS1X2_1_1'spec, C, B, A")
];
=TEX
=SML
new_script1{name = "MDT507NS1X2_1_1'body", library_theories=["A", "B"]};
¹CN
package body mdt507NS1X2_1_1 is

	procedure TEST1 (M : out INTEGER)
	„ M ˜ MDT507NS1X2_1_1oVAR1 [MDT507NS1X2_1_1oVAR1 = 0, M = 0]
	is
	begin
		M := VAR1;
	end TEST1;

begin
	VAR1 := 2;

end mdt507NS1X2_1_1;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1c_gp", sl_format o get_parents, "MDT507NS1X2_1_1'body", 
		"MDT507NS1X2_1_1'spec, B, A, cn"),
	("ns1x2_1_1c_gc", sl_format o get_children, "MDT507NS1X2_1_1'body", ""),
	("ns1x2_1_1c_gcnc", sl_format o get_children, "cn", 
	"MDT507NS1X2_1_1'body, TEST2'proc, MDT507NS1X2_1_1'spec, C, B, A")	
];
=TEX
=SML
new_script1{name = "TEST3'proc", library_theories=["A", "B"]};
¹CN
 procedure TEST3 is
    VAR2 : INTEGER;
    procedure TEST4 is separate;
    function TEST5 (I : INTEGER) return INTEGER is separate;
 begin
    null;
    TEST4;
    VAR2 := TEST5( 0 );
 end TEST3;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1d_gp", sl_format o get_parents, "TEST3'proc", 
		"B, A, cn"),
	("ns1x2_1_1d_gc", sl_format o get_children, "TEST3'proc", ""),
	("ns1x2_1_1d_gcnc", sl_format o get_children, "cn", 
		"TEST3oTEST5'stub, TEST3oTEST4'stub, TEST3'proc, MDT507NS1X2_1_1'body, TEST2'proc, MDT507NS1X2_1_1'spec, C, B, A"),
	("ns1x2_1_1d_gpstub", sl_format o get_parents, "TEST3oTEST5'stub", 
		"B, A, cn"),
	("ns1x2_1_1d_gcstub", sl_format o get_children, "TEST3oTEST5'stub", "")
];
=TEX
=SML
new_script1{name="TEST3oTEST4'proc", library_theories=["C"]};
¹CN
 separate (TEST3)
    procedure TEST4 is begin VAR2 := 1; end TEST4;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1e_gp", sl_format o get_parents, "TEST3oTEST4'proc", 
		"TEST3oTEST4'stub, C, cn"),
	("ns1x2_1_1e_gc", sl_format o get_children, "TEST3oTEST4'proc", ""),
	("ns1x2_1_1e_gcnc", sl_format o get_children, "cn", 
"TEST3oTEST4'proc, TEST3oTEST5'stub, TEST3oTEST4'stub, TEST3'proc, MDT507NS1X2_1_1'body, TEST2'proc, MDT507NS1X2_1_1'spec, C, B, A"),
	("ns1x2_1_1e_gpstub", sl_format o get_parents, "TEST3oTEST4'stub", 
		"B, A, cn"),
	("ns1x2_1_1e_gcstub", sl_format o get_children, "TEST3oTEST4'stub",
		"TEST3oTEST4'proc")
];
=TEX
=SML
new_script1{name="TEST3oTEST5'func", library_theories=["C"]};
¹CN
 separate (TEST3)
    function TEST5 (I : INTEGER) return INTEGER is
    begin return 0; end TEST5;
°
=SML
store_mt_results mt_run [
	("ns1x2_1_1f_gp", sl_format o get_parents, "TEST3oTEST5'func", 
		"TEST3oTEST5'stub, C, cn"),
	("ns1x2_1_1f_gc", sl_format o get_children, "TEST3oTEST5'func", ""),
	("ns1x2_1_1f_gcnc", sl_format o get_children, "cn", 
"TEST3oTEST5'func, TEST3oTEST4'proc, TEST3oTEST5'stub, TEST3oTEST4'stub, TEST3'proc, MDT507NS1X2_1_1'body, TEST2'proc, MDT507NS1X2_1_1'spec, C, B, A"),
	("ns1x2_1_1f_gpstub", sl_format o get_parents, "TEST3oTEST5'stub", 
		"B, A, cn"),
	("ns1x2_1_1f_gcstub", sl_format o get_children, "TEST3oTEST5'stub",
		"TEST3oTEST5'func")
];
=TEX
\subsection{Error Messages}
=IGN
new_error_message {id= 50742, text = 
"Library theory ?0 cannot be made a parent of the script theory: ?1" };
=SML
clean_up();
store_mt_results mt_run_fail [
   ("ns1_fail_507042a", new_script1,
	{name="fail1", library_theories=["rubbish"]},
	 gen_fail_msg "new_script1" 507042
	 ["rubbish", "Theory rubbish is not present in the current hierarchy" ])
];
clean_up();
store_mt_results mt_run_fail [
   ("ns1_fail_507042b", new_script1,
	{name="fail2", library_theories=["fail2"]},
	 gen_fail_msg "new_script1" 507042
	 ["fail2", "Suggested parent fail2 is a child of the current theory" ])
];
=TEX
\pagebreak
\section{CHECK 17}
This check concerns ensuring that a theory has not been used by a previous 
compilation unit.
The compilation unit types are:
\begin{enumerate}
\item
Internal Form of Package Specification (*)
\item
Package Body (*)
\item
Subprogram (Function) (*)
\item
Subprogram (Procedure) (*)
\item
Subunit (*)
\item
External Form of Package Specification (i.e. prefixed)
\item
Stub theory
\end{enumerate}
Those annotated by ``(*)'' are placed in theories chosen by the user,
usually via $new\_script$.
Because of the iplementation approach if any combination of a compilation
unit with some other compilation unit demonstrates its correctness.
=SML
clean_up();
new_script{name="C17_1'spec"};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
fun c17_1_1 () =
¹CN
package c17_2 is
	VAR1 : INTEGER;
end c17_2;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_1", c17_1_1, (),
	 gen_fail_msg "check17" 507045
	 ["C17_2", "C17_1'spec","C17_1'spec"])
];
=TEX
=SML
clean_up();
new_script{name="C17_1'spec"};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
fun c17_1_2 () =
¹CN
package body c17_1 is
begin
	VAR1 := 2;
end c17_1;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_2", c17_1_2, (),
	 gen_fail_msg "check17" 507045
	 ["C17_1", "C17_1'spec","C17_1'spec"])
];
=TEX
=SML
clean_up();
new_script{name="C17_1'spec"};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
fun c17_1_3 () =
¹CN
  with c17_1;
  procedure c17_3
  is
  begin
       c17_1.VAR1 := 0;
  end c17_3;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_3", c17_1_3, (),
	 gen_fail_msg "check17" 507045
	 ["C17_3", "C17_1'spec","C17_1'spec"])
];
=TEX
=SML
clean_up();
new_script{name="C17_1'spec"};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
fun c17_1_4 () =
¹CN
    function c17_4 (I : INTEGER) return INTEGER is
    begin return 0; end c17_4;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_4", c17_1_4, (),
	 gen_fail_msg "check17" 507045
	 ["C17_4", "C17_1'spec","C17_1'spec"])
];
=TEX
=SML
clean_up();
new_script{name="C17_6'proc"};
¹CN
  procedure c17_6
  is
	VAR1 : INTEGER;
	procedure c17_5 is separate;
  begin
       VAR1 := 0;
  end c17_6;
°
=SML
fun c17_1_5 () =
¹CN
 separate (c17_5)
    procedure c17_5 is begin VAR1 := 1; end c17_5;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_5", c17_1_5, (),
	 gen_fail_msg "check17" 507045
	 ["C17_5oC17_5", "C17_6'proc","C17_6'proc"])
];
=TEX
=SML
clean_up();
new_script{name="C17_6'proc"};
¹CN
  procedure c17_6
  is
	VAR1 : INTEGER;
	procedure c17_5 is separate;
  begin
       VAR1 := 0;
  end c17_6;
°
=SML
open_theory "C17_6oC17_5'stub";
fun c17_1_6 () =
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
store_mt_results mt_run_fail [
   ("c17_1_6", c17_1_6, (),
	 gen_fail_msg "check17" 507045
	 ["C17_1", 
	  "C17_6oC17_5'stub","C17_6oC17_5'stub"])
];
=TEX
=SML
clean_up();
new_script{name="C17_1'spec"};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
new_script{name="C17_2'spec"};

¹CN
with c17_1;
package c17_2 is
	VAR2 : INTEGER;
end c17_2;
°
=SML
fun c17_1_7 () =
¹CN
package body c17_1 is
begin
	VAR1 := 2;
end c17_1;
°

=SML
store_mt_results mt_run_fail [
   ("c17_1_7", c17_1_7, (),
	 gen_fail_msg "check17" 507045
	 ["C17_1", "C17_2'spec","C17_2'spec"])
];
=TEX
Now check that all the above combinations can be done properly.
=SML
clean_up();
new_script{name="C17_1'spec"};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
new_script{name="C17_2'spec"};
fun c17_2_1 () =
¹CN
package c17_2 is
	VAR1 : INTEGER;
end c17_2;
°

=SML
store_mt_results mt_run [
   ("c17_2_1", c17_2_1, (),())
];
=TEX
=SML
clean_up();
new_script{name="C17_1'spec"};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
new_script{name="C17_1'body"};
fun c17_2_2 () =
¹CN
package body c17_1 is
begin
	VAR1 := 2;
end c17_1;
°

=SML
store_mt_results mt_run [
   ("c17_2_2", c17_2_2, (),())
];
=TEX
=SML
clean_up();
new_script{name="C17_1'spec"};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
new_script{name="C17_3'proc"};
fun c17_2_3 () =
¹CN
  with c17_1;
  procedure c17_3
  is
  begin
       c17_1.VAR1 := 0;
  end c17_3;
°

=SML
store_mt_results mt_run [
   ("c17_2_3", c17_2_3, (),())
];
=TEX
=SML
clean_up();
new_script{name="C17_1'spec"};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
new_script{name="C17_4'func"};
fun c17_2_4 () =
¹CN
    function c17_4 (I : INTEGER) return INTEGER is
    begin return 0; end c17_4;
°

=SML
store_mt_results mt_run [
   ("c17_2_4", c17_2_4, (),())
];
=TEX
=SML
clean_up();
new_script{name="C17_6'proc"};
¹CN
  procedure c17_6
  is
	VAR1 : INTEGER;
	procedure c17_5 is separate;
  begin
       VAR1 := 0;
  end c17_6;
°
=SML
new_script{name="C17_6oC17_5'proc"};
fun c17_2_5 () =
¹CN
 separate (c17_6)
    procedure c17_5 is begin VAR1 := 1; end c17_5;
°

=SML
store_mt_results mt_run [
   ("c17_2_5", c17_2_5, (),())
];
=TEX
=SML
clean_up();
new_script{name="C17_6'proc"};
¹CN
  procedure c17_6
  is
	VAR1 : INTEGER;
	procedure c17_5 is separate;
  begin
       VAR1 := 0;
  end c17_6;
°
=SML
new_script{name="C17_1'spec"};
fun c17_2_6 () =
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
store_mt_results mt_run [
   ("c17_2_6", c17_2_6, (),())
];
=TEX
=SML
clean_up();
new_script{name="C17_1'spec"};
¹CN
package c17_1 is
	VAR1 : INTEGER;
end c17_1;
°
=SML
new_script{name="C17_2'spec"};

¹CN
with c17_1;
package c17_2 is
	VAR2 : INTEGER;
end c17_2;
°
=SML
new_script{name="C17_1'body"};
fun c17_2_7 () =
¹CN
package body c17_1 is
begin
	VAR1 := 2;
end c17_1;
°

=SML
store_mt_results mt_run [
   ("c17_2_7", c17_2_7, (),())
];
=TEX
\section{FUNCTIONS IN PACKAGE SPECIFICATION}
A function declared in a package specification is now allowed to be mentioned in the
Z specification of another function in the same package (enhancement 117).
=SML
clean_up();
new_script{name = "P'spec"};
¹CN
package P is
  function F (X : INTEGER) return INTEGER
  ˜  [PoF(X) = 2*X];
  function G(X:INTEGER) return INTEGER
  ˜  [PoG(X) = 3*PoF(X)]	;
end P;
°
=SML
store_mt_results (mt_runf (op =$)) [
   ("fun_pack_spec.1", z_type_of, ñPoG®, ñú ª ú®)
];
=TEX
\section{Renaming in Package Specifications}
=SML
clean_up();
new_script{name = "P'spec"};
¹CN
package P is
  VAR1 : INTEGER;
  function F (X : INTEGER) return INTEGER
  ˜  [PoF(X) = 2*X];
  procedure TEST1 (M : out INTEGER)
  „ M ˜ PoVAR1 [M = PoVAR1];

end P;
°
=SML
new_script{name = "Q'spec"};
¹CN
with P;
package Q is
	VAR2 : INTEGER;
	function G  (X : INTEGER) return INTEGER renames P.F;
	procedure TEST2 (M : out INTEGER) renames P.TEST1;
end Q;
°
=SML
new_script{name = "Q'body"};
¹CN
$references P;
package body Q is
	procedure TEST2 (M : out INTEGER) renames P.TEST1;
begin
	„ QoVAR2 [PoVAR1 = 0, QoVAR2 = 0] (1)
end Q;
°
=SML
¹CN
(1) Ã TEST2(VAR2);
   VAR2 := G(VAR2);
°
=SML
new_script{name = "R'spec"};
¹CN
with Q;
package R is
	VAR3 : INTEGER;
end R;
°
=SML
new_script{name = "R'body"};
¹CN
with P, Q;
package body R is
begin
	„ RoVAR3 [PoVAR1 = 0, RoVAR3 = 0] (2)
end R;
°
¹CN
(2) Ã Q.TEST2(VAR3);
°
=TEX
=SML
set_pc "cn";
set_goal([], get_conjecture "-" "vc2_2");
a(REPEAT strip_tac);
a(all_var_elim_asm_tac1);
a(strip_tac);
store_mt_results (mt_runf (op =$)) [
	("rename_3", concl o pop_thm, (), 
		get_conjecture "-" "vc2_2")
];
=TEX

Now demonstrate that need the renaming in the specification
to get the renamed procedure used in a future ``with'' clause.
=SML
clean_up();
new_script{name = "P'spec"};
¹CN
package P is
  VAR1 : INTEGER;
  function F (X : INTEGER) return INTEGER
  ˜  [PoF(X) = 2*X];
  procedure TEST1 (M : out INTEGER)
  „ M ˜ PoVAR1 [M = PoVAR1];

end P;
°
=SML
new_script{name = "Q1'spec"};
¹CN
with P;
package Q1 is
	VAR2 : INTEGER;
end Q1;
°
=SML
new_script{name = "Q1'body"};
¹CN
$references P;
package body Q1 is
	procedure TEST2 (M : out INTEGER) renames P.TEST1;
	function G  (X : INTEGER) return INTEGER renames P.F;
begin
	„ Q1oVAR2 [PoVAR1 = 0, Q1oVAR2 = 0] (1)
end Q1;
°
¹CN
(1) Ã TEST2(VAR2);
   VAR2 := G(VAR2);
°
=SML
new_script{name = "R'spec"};
¹CN
with P, Q1;
package R is
	VAR3 : INTEGER;
end R;
°
=SML
new_script{name = "R'body"};
¹CN
with P, Q1;
package body R is
begin
	„ RoVAR3 [PoVAR1 = 0, RoVAR3 = 0] (3)
end R;
°
=SML
fun rename1_1 () =
¹CN
(3) Ã Q1.TEST2(VAR3);
°
=SML
store_mt_results mt_run_fail [
   ("rename1_1", rename1_1, (),
	 gen_fail_msg "check_1_d" 505063 ["Q1oTEST2"])
];
=TEX

Now with renamed items having no formal parts.
=SML
clean_up();
new_script{name = "P'spec"};
¹CN
package P is
  VAR1 : INTEGER;
  function F (X : INTEGER) return INTEGER
  ˜  [PoF(X) = 2*X];
  procedure TEST1 (M : out INTEGER)
  „ M ˜ PoVAR1 [M = PoVAR1];

end P;
°
=SML
new_script{name = "Q'spec"};
¹CN
with P;
package Q is
	VAR2 : INTEGER;
	function G (Y : INTEGER) return INTEGER renames P.F;
	procedure TEST2(X : out INTEGER)  renames P.TEST1;
end Q;
°
=SML
new_script{name = "Q'body"};
¹CN
$references P;
package body Q is
	procedure TEST2 (M : out INTEGER) renames P.TEST1;
begin
	„ QoVAR2 [PoVAR1 = 0, QoVAR2 = 0] (1)
end Q;
°
=SML
¹CN
(1) Ã TEST2(VAR2);
   VAR2 := G(VAR2);
°
=SML
set_pc "cn";
set_goal([], get_conjecture "-" "vc1_2");
a(REPEAT strip_tac);
a(ALL_FC_T rewrite_tac[z_get_spec ñPoF®]);
a(asm_rewrite_tac[]);
store_mt_results (mt_runf (op =$)) [
	("rename_2", concl o pop_thm, (), 
		get_conjecture "-" "vc1_2")
];
=TEX
\section{Immediate Checking of Package Specifications}
=SML
clean_up();
new_script{name="F'spec"};
fun immed1() =
¹CN
package F is
V : INTEGER;
procedure P1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ X > Z , Y > Z + FoV ];
end F;
°
=SML
fun immed2() =
¹CN
package F is
procedure P1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ X > Z + FoV, Y > Z];
end F;
°
=SML
fun immed1a() =
¹CN
package F is
V1, V2 : INTEGER;
procedure P1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ X > Z , Y > Z + FoV1 + FoV2 ];
end F;
°
=SML
fun immed2a() =
¹CN
package F is
procedure P1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ X > Z + FoV1 + FoV2, Y > Z];
end F;
°
=TEX
=SML
store_mt_results
mt_run_fail [
   ("immed1", immed1, (),
	 gen_fail_msg "call_vcs" 507121 [
		"ñY > Z + FoV®",
		"ñFoV®", "", "is"]),
   ("immed2", immed2, (),
	 gen_fail_msg "call_vcs" 507124 [
		"ñX > Z + FoV®",
		"ñFoV®", "", "is"]),
   ("immed1a", immed1a, (),
	 gen_fail_msg "call_vcs" 507121 [
		"ñY > Z + FoV1 + FoV2®",
		"ñFoV1®, ñFoV2®", "s", "are"]),
   ("immed2a", immed2a, (),
	 gen_fail_msg "call_vcs" 507124 [
		"ñX > Z + FoV1 + FoV2®",
		"ñFoV1®, ñFoV2®", "s", "are"])
];
=TEX
=SML
fun immed3() =
¹CN
package F is
procedure P1 (X: in RUBBISH; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ Y > Z , Y > Z + FoV ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed3", immed3, (),
	 gen_fail_msg "type_of_tmark" 507127  ["RUBBISH"])
];
=TEX
=SML
fun immed4() =
¹CN
package F is
function F1 (X: in INTEGER; Y: in INTEGER; Z: in INTEGER) return INTEGER
 ˜ Y [ X > Z , FoF1 Y (X, Y, Z) > FoV ];
end F;
°
=SML
fun immed5() =
¹CN
package F is
function F1 (X: in INTEGER; Y: in INTEGER; Z: in INTEGER) return INTEGER
 ˜ Y [ X > FoV + Z , FoF1 Y (X, Y, Z) > X ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed4", immed4, (),
	 gen_fail_msg "update_theory_db_with_parainfo" 49006 [
		"FoF1", "FoV"]),
   ("immed5", immed5, (),
	 gen_fail_msg "update_theory_db_with_parainfo" 49006 [
		"FoF1", "FoV"])
];
=TEX
=SML
fun immed6() =
¹CN
package F is
function F1 (X: in RUBBISH; Y: out INTEGER; Z: in out INTEGER) return INTEGER
 ˜ Y [ Y > Z , FoF1(X, Y, Z) > X ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed6", immed6, (),
	 gen_fail_msg "type_of_tmark" 507127  ["RUBBISH"])
];
=TEX
=SML
fun immed7() =
¹CN
package F is
function F1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) return INTEGER
 ˜ [ Y > Z , FoF1 (X, Y) > X ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed7", immed7, (), gen_fail_msg "Z-Parser" 62000 [])
];
=TEX
=SML
fun immed8() =
¹CN
package F is
procedure P1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ Y + Z , Y > Z + FoV ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed8", immed8, (),
	 gen_fail_msg "Z-Parser" 62000 [])
];
=TEX
=SML
fun immed9() =
¹CN
package F is
function F1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) return INTEGER
 ˜ Y [ Y + Z , FoF1(X, Y, Z) > X ];
end F;
°
=SML
store_mt_results_show mt_run_fail [
   ("immed9", immed9, (), gen_fail_msg "Z-Parser" 62000 [])
];
=TEX
\section{Clashes between Formal Parameters and Others}
=SML
clean_up();
new_script{name="F'spec"};
¹CN
package F is
X : INTEGER;
function F1 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) return INTEGER
 ˜ [ X > Z , FoF1(X, Y, Z) > X ];
end F;
°
=SML
new_script{name="G'spec"};
¹CN
package G is
X : INTEGER;
procedure P2 (X: in INTEGER; Y: out INTEGER; Z: in out INTEGER) 
 „ Y [ X > Z, Y > Z];
end G;
°
=SML
new_script{name="F1'spec"};
fun fp_clash1 () =
¹CN
with F;
package F1 is
Y : INTEGER;
end F1;
°
=SML
fun fp_clash2 () =
¹CN
with G;
package G1 is
Y : INTEGER;
end G1;
°
=SML
(* 117-TBA - do we still need this??

store_mt_results_show mt_run_fail [
   ("fp_clash1", fp_clash1, (), gen_fail_msg "z_prefix" 507055 
	["X", "F"]),
   ("fp_clash2", fp_clash2, (), gen_fail_msg "z_prefix" 507055 
	["X", "G"])
];
*)

=TEX
\section{REFERENCES CLAUSES}
\subsection{Only ``references''}
=SML
clean_up();
new_script{name="MARK_F'spec"};
¹CN
package MARK_F is
FX : INTEGER;
FY : constant INTEGER := 1;
end MARK_F;
°
=SML
new_script{name="MARK_G'spec"};
¹CN
package MARK_G is
GX : INTEGER;
GY : constant INTEGER := 2;
end MARK_G;
°
=SML
new_script{name="H'spec"};
¹CN
$references MARK_F, MARK_G;
package H is
procedure P(X : in out INTEGER) 
 „ X ˜ MARK_FoFX, MARK_GoGX[ X > MARK_FoFX + MARK_GoGY , 
	X > MARK_FoFY + MARK_GoGX ];
end H;
°
=TEX
Do the right theories exist, and have the right sort of constants:
=SML
store_mt_results_show mt_run [
   ("refer1.1", get_const_theory, "z'MARK_FoFY", "MARK_F'spec"),
   ("refer1.2", get_const_theory, "z'MARK_GoGY", "MARK_G'spec")
];
output_ada_program{script="-", out_file= "mdt507_refer1.ada"};
val _ = ExtendedIO.system "grep MARK_ mdt507_refer1.ada > mdt507.grep";
val is = open_in "mdt507.grep";
store_mt_results_show mt_run [
	("refer1.3", ExtendedIO.input_line, is, "")
];
val _ = close_in is;
=SML
new_script{name="refer4"};
=TEX
A references clause is required to bring the variables
$MARK_FoFX$ and $MARK_GoGX$ into scope (the reference clause of the package specification
only brings constants, types and functions into scope).
We first demonstrate this, then do it right.
=SML
fun refer1() =
¹CN
package body H is
procedure P(X : in out INTEGER) 
 „ X ˜ MARK_FoFX, MARK_GoGX  [ X > MARK_FoFX + MARK_GoGY , 
	X > MARK_FoFY + MARK_GoGX ] is
   begin
	X := X + 10;
   end P;
end H;
°
=SML
(*
store_mt_results_show mt_run_fail [
   ("refer1.11", refer1, (), 
	gen_fail_msg "check_19" 505084 [ "MARK_FoFX" ])
];

¹CN
$references MARK_F, MARK_G;
package body H is
procedure P(X : in out INTEGER) 
 „ X ˜ MARK_FoFX, MARK_GoGX [ X > MARK_FoFX + MARK_GoGY , 
	X > MARK_FoFY + MARK_GoGX ] is
   begin
	X := X + 10;
   end P;
end H;
°
=SML
*)
output_ada_program{script="-", out_file= "mdt507_refer2.ada"};
val _ = ExtendedIO.system "grep MARK_ mdt507_refer2.ada > mdt507.grep";
val is = open_in "mdt507.grep";
store_mt_results_show mt_run [
	("refer1.4", ExtendedIO.input_line, is, "")
];
val _ = close_in is;
=TEX

\subsection{Mix of ``with'' and ``references''}
=SML
clean_up();
new_script{name="MARK_F'spec"};
¹CN
package MARK_F is
FX : INTEGER;
FY : constant INTEGER := 1;
end MARK_F;
°
=SML
new_script{name="MARK_G'spec"};
¹CN
package MARK_G is
GX : INTEGER;
GY : constant INTEGER := 2;
end MARK_G;
°
=SML
new_script{name="I'spec"};
¹CN
with MARK_F;
$references MARK_G;
package I is
procedure P(X : in out INTEGER) 
 „ X ˜ MARK_FoFX, MARK_GoGX [ X > MARK_FoFX + MARK_GoGY , 
	X > MARK_FoFY + MARK_GoGX ];
end I;
°
=TEX
=SML
output_ada_program{script="-", out_file= "mdt507_refer3.ada"};
val _ = ExtendedIO.system "grep MARK_ mdt507_refer3.ada > mdt507.grep";
val is = open_in "mdt507.grep";
store_mt_results_show mt_run [
	("refer1.5", ExtendedIO.input_line, is, "WITH MARK_F;\n")
];
val _ = close_in is;
=SML
new_script{name="I'body"};
=TEX
The references below is required to bring the variables
$MARK_FoFX$ and $MARK_GoGX$ into scope (the reference clause of the package specification
only brings constants, types and functions into scope).
¹CN
$references MARK_F, MARK_G;
package body I is
procedure P(X : in out INTEGER) 
 „ X ˜ MARK_FoFX, MARK_GoGX[ X > MARK_FoFX + MARK_GoGY , 
	X > MARK_FoFY + MARK_GoGX ] is
   begin
	X := X + 10;
   end P;
end I;
°
=SML
output_ada_program{script="-", out_file= "mdt507_refer4.ada"};
val _ = ExtendedIO.system "grep MARK_ mdt507_refer4.ada > mdt507.grep";
val is = open_in "mdt507.grep";
store_mt_results_show mt_run [
	("refer1.6", ExtendedIO.input_line, is, "")
];
val _ = close_in is;
=TEX
\subsection{Only ``with''}
=SML
clean_up();
new_script{name="MARK_F'spec"};
¹CN
package MARK_F is
FX : INTEGER;
FY : constant INTEGER := 1;
end MARK_F;
°
=SML
new_script{name="MARK_G'spec"};
¹CN
package MARK_G is
GX : INTEGER;
GY : constant INTEGER := 2;
end MARK_G;
°
=SML
new_script{name="J'spec"};
¹CN
with MARK_F, MARK_G;
package J is
procedure P(X : in out INTEGER) 
 „ X ˜ MARK_FoFX, MARK_GoGX[ X > MARK_FoFX + MARK_GoGY , 
	X > MARK_FoFY + MARK_GoGX ];
end J;
°
=TEX
=SML
output_ada_program{script="-", out_file= "mdt507_refer5.ada"};
val _ = ExtendedIO.system "grep MARK_ mdt507_refer5.ada > mdt507.grep";
val is = open_in "mdt507.grep";
store_mt_results_show mt_run [
	("refer1.7", ExtendedIO.input_line, is, "WITH MARK_F, MARK_G;\n")
];
val _ = close_in is;
=SML
new_script{name="J'body"};
=TEX
The references below is required to bring the variables
$MARK_FoFX$ and $MARK_GoGX$ into scope (the reference clause of the package specification
only brings constants, types and functions into scope).
¹CN
$references MARK_F, MARK_G;
package body J is
procedure P(X : in out INTEGER) 
 „ X ˜ MARK_FoFX, MARK_GoGX[ X > MARK_FoFX + MARK_GoGY , 
	X > MARK_FoFY + MARK_GoGX ] is
   begin
	X := X + 10;
   end P;
end J;
°
=SML
output_ada_program{script="-", out_file= "mdt507_refer6.ada"};
val _ = ExtendedIO.system "grep MARK_ mdt507_refer6.ada > mdt507.grep";
val is = open_in "mdt507.grep";
store_mt_results_show mt_run [
	("refer1.10", ExtendedIO.input_line, is, "")
];
val _ = close_in is;
=TEX
\subsection{Duplicate names}
=SML
clean_up();
new_script{name="MARK_F'spec"};
¹CN
package MARK_F is
FX : INTEGER;
FY : constant INTEGER := 1;
end MARK_F;
°
=SML
new_script{name="MARK_G'spec"};
¹CN
package MARK_G is
GX : INTEGER;
GY : constant INTEGER := 2;
end MARK_G;
°
=SML
new_script{name="K'spec"};
¹CN
$references MARK_F, MARK_G, MARK_F;
package K is
X : INTEGER;
end K;
°
=SML
store_mt_results_show
mt_run [
   ("refer2.1", get_parents, "K'spec", ["MARK_G'spec", "MARK_F'spec", "cn"])
];
new_script{name="L'spec"};
¹CN
with MARK_F;
$references MARK_G, MARK_F;
package L is
X : INTEGER;
end L;
°
=SML
store_mt_results_show mt_run [
   ("refer3.1", get_parents, "L'spec", ["MARK_G'spec", "MARK_F'spec", "cn"])
];
=TEX
\subsection{Failure Conditions}
=SML
fun refer12() =
¹CN
$references MARK_F, RUBBISH, MARK_G;
package K is
X : INTEGER;
end K;
°
=SML
store_mt_results_show mt_run_fail [
   ("refer12.1", refer12, (), gen_fail_msg "context_clause_check"
	 507038 ["RUBBISH"])
];
=TEX
\section{WP 5 Checks}
=SML
clean_up();
new_script{name="BASIC'spec"};
=TEX
¹CN
package BASIC
is
  type INDEX is range 1 .. 10;
  $auxiliary FLAGS : ğ (1..10);
  procedure SET (I : in INDEX)
  „ FLAGS [ FLAGS = FLAGS‰0 À {I} ] ;
end BASIC;
°
=SML
new_script{name="DERIVED'spec"};
=TEX
¹CN
with BASIC;
package DERIVED
is
  procedure SET_ALL
  „ FLAGS
  [ FLAGS = BASICoINDEX ] ;
end DERIVED;
°
=SML
new_script{name="MAIN'proc"};
=TEX
¹CN
with BASIC;
procedure MAIN
„ FLAGS
[ FLAGS = BASICoINDEX ]
is
begin
  for I in BASIC.INDEX
  loop
    „ FLAGS
    [ 1.. I-1 € FLAGS,
      1 .. I € FLAGS ]
  end loop;
end MAIN;
°
¹CN
 Ã
    BASIC.SET(I);
°
=SML
new_script{name="DERIVED'body"};

fun wp5_test1 () =
¹CN
with BASIC;
package body DERIVED
is
  procedure SET_ALL
  „ FLAGS
  [ FLAGS = BASICoINDEX ]
  is
  begin
    „ FLAGS
    [ FLAGS = BASICoINDEX ]
  end SET_ALL;
end DERIVED;
°
We are only interested in success, so:
=SML
store_mt_results_show mt_run [
	("wp5_test1", wp5_test1, (), ())
];
=TEX
=SML
clean_up();
new_script{name="A'spec"};
=TEX
¹CN
package A is
    V : INTEGER;
end A;
°
=SML
new_script{name="B'spec"};
=TEX
¹CN
with A;
package B is
    procedure INIT
    „ AoV [AoV = 0];
end B;
°
=SML
new_script{name="B'body"};
=TEX
=SML
fun wp5_test2 () = 
¹CN
with A;
package body B is
    procedure INIT
    „ AoV [AoV = 0]
    is
    begin
        A.V := 0;
    end INIT;
end B;
°
We are only interested in success, so:
=SML
store_mt_results_show mt_run [
	("wp5_test2", wp5_test2, (), ())
];
=TEX
\section{Definitions with or without Axiomatic Mode}
=SML
clean_up();
new_script{name= "P'spec"};
val orig_z_use_axioms = set_flag("z_use_axioms", false);
¹ZAX
Ü f : ú ­ ú
÷üüüüüü
Ü f 0 = 1
°
¹ZAX
Ü g,h : ú ­ ú
÷üüüüüü
Ü g 0 = 1 ± h 0 = 2
°
[ Y ]œœœœœœœœœœœ
Ü j : Y ­ Y
÷üüüüüü
Ü ¶ x : Y · j x = x
ˆüüüüüüüüüüüüüü
¹ZAX
Ü k : ú ­ ú
°
[ Y ]œœœœœœœœœœœ
Ü l : Y ­ Y
ˆüüüüüüüüüüüüüü
=SML
set_flag("z_use_axioms", true);
¹ZAX
Ü f1 : ú ­ ú
÷üüüüüü
Ü f1 0 = 1
°
¹ZAX
Ü g1,h1 : ú ­ ú
÷üüüüüü
Ü g1 0 = 1 ± h1 0 = 2
°
[ Y ]œœœœœœœœœœœ
Ü j1 : Y ­ Y
÷üüüüüü
Ü ¶ x : Y · j1 x = x
ˆüüüüüüüüüüüüüü
¹ZAX
Ü k1 : ú ­ ú
°
[ Y ]œœœœœœœœœœœ
Ü l1 : Y ­ Y
ˆüüüüüüüüüüüüüü

¹CN
package P is
X : INTEGER;
end P;
°
=SML

store_mt_results mt_run [("mdt507_axiom_1.output",
	output_z_document, 
	{out_file="mdt507_axiom_temp1.zdoc", script="-"}, ())];
val temp1_consts = map (fst o dest_const) (get_consts "-");

new_script{name="Q'spec"};
¹CN
with P;
package Q is
Y : INTEGER;
end Q;
°
=SML
store_mt_results mt_run [("mdt507_axiom_2.output",
	output_z_document,
	{out_file="mdt507_axiom_temp2.zdoc", script="-"},
	())];
val temp2_consts = map (fst o dest_const) (get_consts "Q'spec");
val Pspec_consts = map (fst o dest_const) (get_consts "P'spec");
=TEX
Now to read these back in:
=SML
clean_up();
store_mt_results mt_run [("mdt507_axiom_1.1",
	use_file, "mdt507_axiom_temp1.zdoc", ())];
store_mt_results_show (mt_runf (op ~=)) [("mdt507_axiom_1.2",
	map (fst o dest_const), (get_consts "P'spec"), temp1_consts)];
store_mt_results mt_run [("mdt507_axiom_2.1",
	use_file, "mdt507_axiom_temp2.zdoc", ())];
store_mt_results_show (mt_runf (op ~=)) [("mdt507_axiom_2.2",
	map (fst o dest_const), (get_consts "Q'spec"), temp2_consts)];
set_flag ("z_use_axioms",orig_z_use_axioms);
=TEX
\section{Tests of References}
=SML
clean_up();
new_script{name="REF1'spec"};
¹CN
package REF1 is
function F1 return INTEGER
˜ [ REF1oF1 = 1 ];
end REF1;
°
=SML
new_script{name="REF2'spec"};
¹CN
$references REF1;
package REF2 is
function F2 return INTEGER
˜ [ REF2oF2 = REF1oF1 ];
end REF2;
°
=SML
new_script{name="REF3'spec"};
fun ref_test1 () =
¹CN
$references REF2;
package REF3 is
function F3 return INTEGER
˜ [ REF3oF3 = REF2oF2 ];
end REF3;
°
=SML
store_mt_results mt_run[("ref_test1",ref_test1, (), ())]; 
=TEX
Now repeat the test, but use a ``with''.
=SML
clean_up();
new_script{name="REF1'spec"};
¹CN
package REF1 is
function F1 return INTEGER
˜ [ REF1oF1 = 1 ];
end REF1;
°
=SML
new_script{name="REF2'spec"};
¹CN
with REF1;
package REF2 is
function F2 return INTEGER
˜ [ REF2oF2 = REF1oF1 ];
end REF2;
°
=SML
new_script{name="REF3'spec"};
fun ref_test2 () =
¹CN
$references REF2;
package REF3 is
function F3 return INTEGER
˜ [ REF3oF3 = REF2oF2 ];
end REF3;
°
=SML
store_mt_results mt_run[("ref_test2",ref_test2, (), ())]; 
=TEX
Now using library theories:
=SML
clean_up();
new_script{name="REF1'spec"};
¹CN
package REF1 is
function F1 return INTEGER
˜ [ REF1oF1 = 1 ];
end REF1;
°
=SML
new_script{name="DUMMY'spec"};
¹CN
with REF1;
package DUMMY is
X: INTEGER;
end DUMMY;
°
=SML
new_script1{name="REF2'spec", library_theories = ["REF1'spec"]};
¹CN
package REF2 is
function F2 return INTEGER
˜ [ REF2oF2 = REF1oF1 ];
end REF2;
°
=SML
new_script{name="REF3'spec"};
fun ref_test3 () =
¹CN
$references REF2;
package REF3 is
function F3 return INTEGER
˜ [ REF3oF3 = REF2oF2 ];
end REF3;
°
=SML
store_mt_results mt_run[("ref_test3",ref_test3, (), ())]; 
=TEX
=SML
clean_up();
new_theory "temp";
new_script{name="REF1'spec"};
¹CN
package REF1 is
function F1 return INTEGER
˜ [ REF1oF1 = 1 ];
end REF1;
°
=SML
new_script1{name="REF2'spec", library_theories = ["temp"]};
¹CN
with REF1;
package REF2 is
function F2 return INTEGER
˜ [ REF2oF2 = REF1oF1 ];
end REF2;
°
=SML
fun ref_test4 () = "temp" mem get_parents  "REF2'spec";
store_mt_results_show mt_run[("ref_test4",ref_test4, (), true)]; 
val _ = ExtendedIO.system "rm mdt507.grep";
=TEX
\section{SUMMARY OF RESULTS}
=SML
diag_string(summarize_mt_results());
=TEX

\end{document}

