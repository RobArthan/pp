% imp506.doc   %Z% $Date: 1997/04/16 14:43:48 $ $Revision: 1.17 $ $RCSfile: imp506.doc,v $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: VC Browser}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP506}  %% Mandatory field
\def\SCCSversion{$Revision: 1.17 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 1997/04/16 14:43:48 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\raggedright{\TPPabstract{This document contains the implementation for the navigation tools.}}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issues 1.1-1.9] Author's drafts.
\item[Issue 1.10] Under integration.
\item[Issue 1.11] corrected order of web clause list.
\item[Issue 1.12] renamed call to $get\_cn\_state$ to be $get\_z\_generator\_state$.
\item[Issue 1.13] right filter now clears text window if there are no VCs selected.
\item[Issue 1.14] Arbitrary replacements enhancements.
\item[Issue 1.15] K-slots as annotations.
\item[Issue 1.16] Addressing changes to SPARK output programs from IUCT WP 6.
\item[Issue 1.17] Ensured that VC soundness error message is seen.
\item[Issue 1.18] Corrected {\LaTeX} error.
\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the VC Browser.
The detailed desi+gn for this material is in \cite{ISS/HAT/DAZ/DTD506}.
\subsection{Introduction}
See \cite{ISS/HAT/DAZ/DTD506}.
\subsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/DTD506}.
\subsection{Algorithms}
The code is a straightforward application of the PolyML Motif interface.
\subsection{Dependencies}
See \cite{ISS/HAT/DAZ/DTD506}.
\subsection{Known Deficencies}
None known.
\subsection{Possible Enhancements}
Various more or less cosmetic adjustments could doubtless to be made.
=TEX
=TEX
=TEX
\section{FRONT END}
=SML
structure ÛCNBrowserFrontEndÝ : CNBrowserFrontEnd = struct
local
open  XWindows Motif;
=TEX
=SML
val words : string -> string list = (
	let	fun aux (done, "") [] = done
		|   aux (done, acc) [] = acc :: done
		|   aux (done, "") (" " :: more) = aux (done, "") more
		|   aux (done, acc) (" " :: more) = aux (acc :: done, "") more
		|   aux (done, acc) (ch :: more) = aux (done, acc ^ ch) more;
	in	(rev o aux ([], "") o explode)
	end
);
fun format_string (i : int) : string -> string list = (
	let	fun aux (done, acc, crsr) [] = acc :: done
		|   aux (done, acc, crsr) (w :: more) = (
			let	val l = size w;
				val crsr' = crsr + l + 1;
			in	if	crsr' > i
				then	aux
					(if acc = "" then done else acc :: done,
					w,
					l) more
				else	aux
					(done,
					if acc = "" then w else acc ^ " " ^ w,
					 crsr') more
			end
		);
	in	rev o aux ([], "", 0) o words
	end
);
=TEX
=SML
val destroy_cb : Widget * 'a XEvent * unit -> unit = (fn (w, _, _) =>
	XtDestroyWidget w
);
=TEX
=SML
val icon_rect = XWindows.Area{x = 0, y = 0, w = 32, h = 32};
=TEX
=SML
val pp_bitmap_bits = [
	255, 255, 255, 255, 1, 0, 0, 128, 1, 0, 0, 128, 1, 0, 0, 128,
	1, 0, 0, 128, 1, 0, 254, 129, 129, 1, 254, 131, 129, 1, 54, 134,
	1, 0, 54, 134, 1, 0, 54, 134, 1, 0, 54, 134, 1, 0, 54, 134,
	1, 0, 246, 131, 225, 31, 246, 129, 225, 63, 54, 128, 97, 99, 54, 128,
	97, 99, 54, 128, 97, 99, 54, 128, 97, 99, 62, 128, 97, 99, 62, 128,
	97, 63, 0, 128, 97, 31, 0, 128, 97, 3, 0, 128, 97, 3, 0, 128,
	97, 3, 48, 128, 97, 3, 48, 128, 225, 3, 0, 128, 225, 3, 0, 128,
	1, 0, 0, 128, 1, 0, 0, 128, 1, 0, 0, 128, 255, 255, 255, 255];
=TEX
=SML
=TEX
=SML
fun help_widget (owner_w : Widget) (text : string list) : Widget = (
	let	val fmtd_txt = format_list Combinators.I
				(flat (map (format_string 60) text)) "\n";
		val help_w = XmCreateInformationDialog owner_w "help-dialog" [
			XmNmessageString fmtd_txt,
			XmNokLabelString " Dismiss ",
			XmNdialogTitle "ProofPower-Help"
		];
		val se1 = XtDestroyWidget(XmMessageBoxGetChild help_w
					XmDIALOG_CANCEL_BUTTON);
		val se2 = XtDestroyWidget(XmMessageBoxGetChild help_w
					XmDIALOG_HELP_BUTTON);
		val se3 = XtSetCallbacks help_w [(XmNokCallback, destroy_cb)];
		val se4 = XtManageChild help_w;
	in	help_w
	end
);
=TEX
The result type of the following function is a long record and has ben omitted.
=SML
fun gen_correlator_tool_widgets {
	left_keys : unit -> string list,
	right_keys : unit -> string list} = (
let
	val shell = XtAppInitialise "" "VCBrowser" "Xpp" [] [];

	val side_effect = XtSetValue shell (XmNdeleteResponse XmDO_NOTHING);

	val outer_paned = XmCreatePanedWindow shell "outer-paned" [
		XmNsashHeight		1,
		XmNsashWidth		1
	];
	val top_form = XmCreateForm outer_paned "top-form" [
		XmNfractionBase	2
	];
	val left_paned = XmCreatePanedWindow top_form "left-paned" [
		XmNtopAttachment	XmATTACH_FORM,
		XmNleftAttachment	XmATTACH_FORM,
		XmNrightAttachment	XmATTACH_POSITION,
		XmNrightPosition	1,
		XmNbottomAttachment	XmATTACH_FORM
	];	
	val vert_sep = XmCreateSeparator top_form "vert-sep"[
		XmNorientation 	XmVERTICAL,
		XmNtopAttachment	XmATTACH_FORM,
		XmNbottomAttachment	XmATTACH_OPPOSITE_WIDGET,
		XmNbottomWidget	left_paned,
		XmNleftAttachment	XmATTACH_WIDGET,
		XmNleftWidget		left_paned
	];
	val right_paned = XmCreatePanedWindow top_form "right-paned" [
		XmNtopAttachment	XmATTACH_FORM,
		XmNleftAttachment	XmATTACH_POSITION,
		XmNleftPosition	1,
		XmNrightAttachment	XmATTACH_FORM,
		XmNbottomAttachment	XmATTACH_FORM
	];
	val left_text = XmCreateScrolledText left_paned "script" [
		XmNrows		12,
		XmNcolumns	40,
		XmNeditMode	XmMULTI_LINE_EDIT,
		XmNeditable	false
	];
	val left_items = left_keys();
	val left_list = XmCreateScrolledList left_paned "script" [
		XmNvisibleItemCount	4,
		XmNitems	left_items,
		XmNscrollBarDisplayPolicy XmSTATIC,
		XmNselectionPolicy	XmBROWSE_SELECT,
		XmNselectedItems	([hd left_items] handle Fail _ => [])
	];
	val right_text = XmCreateScrolledText right_paned "script" [
		XmNrows		12,
		XmNcolumns	40,
		XmNeditMode	XmMULTI_LINE_EDIT,
		XmNeditable	false
	];
	val right_items = right_keys();
	val right_list = XmCreateScrolledList right_paned "script" [
		XmNvisibleItemCount	4,
		XmNitems		right_items,
		XmNscrollBarDisplayPolicy XmSTATIC,
		XmNselectionPolicy	XmBROWSE_SELECT,
		XmNselectedItems	([hd right_items] handle Fail _ => [])
	];
	val button_form = XmCreateForm outer_paned "button-form" [
		XmNfractionBase	8
	];
	val left_filter_btn = XmCreatePushButton button_form "left-filter-btn" [
		XmNlabelString		"Filter",
		XmNtopAttachment	XmATTACH_FORM,
		XmNbottomAttachment	XmATTACH_POSITION,
		XmNbottomPosition	4,
		XmNleftAttachment	XmATTACH_POSITION,
		XmNleftPosition	0,
		XmNrightAttachment	XmATTACH_POSITION,
		XmNrightPosition	2
	];
	val left_reset_btn = XmCreatePushButton button_form "left-reset-btn" [
		XmNlabelString		"Reset",
		XmNtopAttachment	XmATTACH_FORM,
		XmNbottomAttachment	XmATTACH_POSITION,
		XmNbottomPosition	4,
		XmNleftAttachment	XmATTACH_POSITION,
		XmNleftPosition	2,
		XmNrightAttachment	XmATTACH_POSITION,
		XmNrightPosition	4
	];
	val right_filter_btn = XmCreatePushButton button_form "right-filter-btn" [
		XmNlabelString		"Filter",
		XmNtopAttachment	XmATTACH_FORM,
		XmNbottomAttachment	XmATTACH_POSITION,
		XmNbottomPosition	4,
		XmNleftAttachment	XmATTACH_POSITION,
		XmNleftPosition	4,
		XmNrightAttachment	XmATTACH_POSITION,
		XmNrightPosition	6
	];
	val right_reset_btn = XmCreatePushButton button_form "right-reset-btn" [
		XmNlabelString		"Reset",
		XmNtopAttachment	XmATTACH_FORM,
		XmNbottomAttachment	XmATTACH_POSITION,
		XmNbottomPosition	4,
		XmNleftAttachment	XmATTACH_POSITION,
		XmNleftPosition	6,
		XmNrightAttachment	XmATTACH_POSITION,
		XmNrightPosition	8
	];
	val done_btn = XmCreatePushButton button_form "done-btn" [
		XmNlabelString		"Done",
		XmNtopAttachment	XmATTACH_POSITION,
		XmNtopPosition		4,
		XmNbottomAttachment	XmATTACH_FORM,
		XmNleftAttachment	XmATTACH_POSITION,
		XmNleftPosition	1,
		XmNrightAttachment	XmATTACH_POSITION,
		XmNrightPosition	3
	];
	val help_btn = XmCreatePushButton button_form "help-btn" [
		XmNlabelString		"Help",
		XmNtopAttachment	XmATTACH_POSITION,
		XmNtopPosition		4,
		XmNbottomAttachment	XmATTACH_FORM,
		XmNleftAttachment	XmATTACH_POSITION,
		XmNleftPosition	5,
		XmNrightAttachment	XmATTACH_POSITION,
		XmNrightPosition	7
	];
	val side_effect = map XtManageChild [
		done_btn,
		left_filter_btn,
		left_reset_btn,
		help_btn,
		right_filter_btn,
		right_reset_btn,
		button_form,
		left_list,
		left_text,
		left_paned,
		vert_sep,
		right_list,
		right_text,
		right_paned,
		top_form,
		outer_paned
	];
	val side_effect = XtRealizeWidget shell;
	val side_effect = (
		case XtGetValue button_form "height" of
			XmNheight h => (
				XtSetValues button_form
				[(XmNpaneMaximum h), (XmNpaneMinimum h)]
		) |	_ => ());

	val side_effect = XtSetValue shell (
		XmNiconPixmap		(XCreateBitmapFromData
					(XtWindow shell)
					((implode o map chr) pp_bitmap_bits)
					icon_rect));

in {	left_filter_btn = left_filter_btn,
	left_reset_btn = left_reset_btn,
	right_filter_btn = right_filter_btn,
	right_reset_btn = right_reset_btn,
	done_btn = done_btn,
	help_btn = help_btn,
	left_list = left_list,
	left_text = left_text,
	right_list = right_list,
	right_text = right_text,
	shell = shell }
end
)	(* end of function gen_correlator_tool_widgets *);
=TEX
=SML
fun simple_cb (cmd : unit -> unit) :
	Widget * 'a XEvent * unit -> unit = (fn _ => cmd()
);
=TEX
=SML
in
fun gen_correlator_tool {
	left_keys : unit -> string list,
	right_keys : unit -> string list,
	left_filter	: string -> string list,
	right_filter : string -> string list,
	left_key_to_text : string -> string,
	right_key_to_text : string -> string,
	help_text : unit -> string list} : Widget = (
let	val {shell, left_list, left_text, right_list, right_text,
		left_filter_btn, right_filter_btn, left_reset_btn,
		right_reset_btn, help_btn, done_btn} =
			gen_correlator_tool_widgets
			{left_keys = left_keys, right_keys = right_keys};
	fun set list_w keys = (
		if	not(is_nil keys)
		then	XtSetValues list_w
			[XmNitems	keys,
			XmNselectedItems	[hd keys],
			XmNtopItemPosition	1]
		else	XtSetValues list_w	[XmNitems	keys,
						XmNselectedItems	[]]
	);
	fun select list_w text_w f = (fn () =>
		case XtGetValue list_w "selectedItems" of
			XmNselectedItems (x::_) => (
				XmTextSetString text_w "Please wait.";
				XmTextSetString text_w (f x)
		) |	_ => XmTextSetString text_w ""
	);
	fun reset list_w text_w f g = (fn () => (
		set list_w (f());
		select list_w text_w g ()
	));
	fun filter from_list_w to_list_w to_text_w f g = (fn () => 
		let	val keys = (
				case XtGetValue from_list_w "selectedItems" of
					XmNselectedItems (x::_) => (
						f x
				) |	_ => []
			);
		in	set to_list_w keys;
			select to_list_w to_text_w g ()
		end
	);
	fun destroy shell_w = (fn () =>
		XtDestroyWidget shell_w
	);
	fun help () = (
		help_widget shell (help_text ());
		()
	);
in	XtSetCallbacks left_list
	[(XmNdefaultActionCallback, simple_cb
		(select left_list left_text left_key_to_text))] ();
	XtSetCallbacks right_list
	[(XmNdefaultActionCallback, simple_cb
		(select right_list right_text right_key_to_text))] ();
	XtSetCallbacks left_filter_btn
	[(XmNactivateCallback, simple_cb
		(filter right_list left_list left_text left_filter left_key_to_text))] ();
	XtSetCallbacks right_filter_btn
	[(XmNactivateCallback, simple_cb
		(filter left_list right_list right_text right_filter right_key_to_text ))] ();
	XtSetCallbacks left_reset_btn
	[(XmNactivateCallback, simple_cb
		(reset left_list left_text left_keys left_key_to_text))] ();
	XtSetCallbacks right_reset_btn
	[(XmNactivateCallback, simple_cb
		(reset right_list right_text right_keys right_key_to_text))] ();
	XtSetCallbacks help_btn
	[(XmNactivateCallback, simple_cb help)] ();
	XtSetCallbacks done_btn
	[(XmNactivateCallback, simple_cb
		(destroy shell))] ();
	select left_list left_text left_key_to_text ();
	select right_list right_text right_key_to_text ();
	shell
end
);
end (* of local .. in .. end *);
=TEX
=SML
end (* of structure CNBrowserFrontEnd *);
=TEX
\section{USER INTERFACE}
=TEX
=SML
structure ÛCNVCBrowserÝ : CNVCBrowser = struct 
=TEX
\subsection{Preamble}
=SML
open CNZGenerator CNTypes CNTypes1 CNTypes2 CNSparkOutput;
=TEX
\subsection{Help Text}
=SML
val Ûhelp_textÝ : unit -> string list = Combinators.K [
"*** This is the Compliance Notation VC Browser ***",
"",
"Compliance notation clauses are shown on the left and VCs on the right.",
"",
"Double-click on the name of a clause or a VC to see it.",
"",
"Pressing a `Select' button makes the list above the button" ^
" show only the items corresponding to the selection in the other list.",
"",
"Pressing a `Reset' button makes the list above the button show everything again."
];
=TEX
\subsection{List of Web Clause Names}
=SML
fun Ûweb_clause_namesÝ ((): unit) : string list = (
	let val {repl_env, spark_prog, ...} = get_z_generator_state();
	in	rev (map kslot_compilation_unit_name spark_prog)
	@	rev (map fst repl_env)
	end
);
=SML
val Ûleft_keysÝ = (
	map translate_for_output o
	web_clause_names
);
=TEX
\subsection{Web Clauses}

Warning: These may return lists of strings that all require an additional 8 spaces put at the front.
=SML
fun Ûtext_of_kslot_compilation_unitÝ (kscu: KSLOT_COMPILATION_UNIT)
			: string list = (
	strings_from_fmt fmt_kslot_compilation_unit kscu
);
=TEX
=SML
fun Ûtext_of_declarationÝ (d: DECLARATION)
			: string list = (
	strings_from_fmt fmt_declaration d
);
=TEX
=SML
fun Ûtext_of_statementÝ (s: STATEMENT)
			: string list = (
	strings_from_fmt fmt_statement s
);
=TEX
=SML
fun Ûtext_of_annotationÝ (ANKSlot {label,content}::more)
			: string list = (
	"§" ^ content ^ "¢" ^ "(" ^ label ^ ")" :: text_of_annotation more
) | text_of_annotation (ANString s :: more) = (
	s :: text_of_annotation more
) | text_of_annotation [] = (
	[]
);
=TEX
=SML
fun Ûtext_of_replacementÝ (rplcmnt : REPLACEMENT) : string list = (
	case rplcmnt of
		ReplaceComp {comp, ...} => (
			"é" :: flat (map text_of_kslot_compilation_unit comp)
	) |	ReplacePPart {private, ...} => (
			"é" :: flat (map text_of_declaration private)
	) |	ReplaceVPart {visible, ...} => (
			"é" :: flat (map text_of_declaration visible)
	) |	ReplaceDecl {decls, ...} => (
			"é" :: flat (map text_of_declaration decls)
	) |	RefineStat {statement, ...} => (
			"Ã" :: text_of_statement statement
	) |	ReplaceStat {statement, ...} => (
			"é" :: text_of_statement statement
	) |	ReplaceArbitrary {replacement, ...} => (
			["!é" ^ replacement]
	) |	ReplaceAnnotation {replacement, ...} => (
			"é" :: text_of_annotation replacement
	) |	UnReplaced (rsort, lbl) => ["TBS"]
);       
=TEX
=SML
fun Ûsfmt_labelÝ (lbl : string) : string = (
	if	is_all_decimal lbl
	then	"(" ^ lbl ^ ")"
	else	"-- " ^ lbl
);
=TEX
=SML
fun Ûtext_of_repl_env_entryÝ ((lbl, rplcmnt) : string * REPLACEMENT) : string list = (
	sfmt_label lbl :: text_of_replacement rplcmnt
);
=TEX
=SML
fun Ûleft_key_to_textÝ (key : string) : string = (
	translate_for_output
	let	val {spark_prog, repl_env, ...} = get_z_generator_state();
	in
		format_list Combinators.I
		((text_of_repl_env_entry
			(find repl_env(fn (k, _) => translate_for_output k = key)))
			handle Fail _ => (
		(text_of_kslot_compilation_unit
			(find spark_prog (fn kscu =>
				translate_for_output
				(kslot_compilation_unit_name kscu)
				= key)))
		) handle Fail f =>(
			if (area_of (Fail f) = "find")
			then ()
			else (
				diag_line (get_message f)
			);
			[get_error_message 506001 [key]]
		))
		"\n"
	end
);
=TEX
\subsection{VC Names}
=SML
fun Ûvc_namesÝ ((): unit) : string list = (
	(rev o flat o map fst o get_conjectures) "-"
);
val Ûright_keysÝ : unit -> string list = map translate_for_output o vc_names;
=TEX
\subsection{VCs}
=SML
fun Ûright_key_to_textÝ (key : string) : string = (
	translate_for_output
	let	 val act_key = find (vc_names())
			(fn k => translate_for_output k = key);
	in
		format_list Combinators.I
		(	act_key ::
			 "?ô" ::
			 PrettyPrinter.format_term1
	 			false
	 			40 (* arbitrary, but reasonable, line length *)
				(get_conjecture "-" act_key))
		"\n"
	end	handle Fail _ => "There is no VC called " ^ key
);
=TEX
\subsection{Filtering the Clauses}
=SML
fun prefix_of_vc_name (vcn : string) : string = (
	let	fun aux [] = vcn
		|   aux (ch :: more) = (
			if	ch = "_"
			then	implode (rev more)
			else	aux more
		);
	in	case explode vcn of
			"v" :: "c" :: more => aux (rev more)
		|	_ => vcn
	end
);
=TEX
=SML
fun find_clause (vcn : string) : string list = (
	[prefix_of_vc_name vcn]
);
=TEX
=SML
val Ûleft_filterÝ : string -> string list = find_clause;
=TEX
\subsection{Filtering the VCs}
=SML
fun Ûfind_vcsÝ (cln : string) : string list = (
		map translate_for_output (vc_names())
	drop	(fn n => prefix_of_vc_name n <> cln)
);
=TEX
=SML
val right_filter : string -> string list = find_vcs;
=TEX
\subsection{Entry Point}
=SML
fun Ûbrowse_vcsÝ (() : unit) : unit = (
	let	val shell = CNBrowserFrontEnd.gen_correlator_tool{
			left_keys = left_keys,
			right_keys = right_keys,
			left_filter = left_filter,
			right_filter = right_filter,
			left_key_to_text = left_key_to_text,
			right_key_to_text =right_key_to_text,
			help_text =help_text};
	in	()
	end
);
=TEX
=SML
end (* of structure CNVCBrowser *);
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}

(*
print_status();
open_theory"z_library";
XtDestroyWidget shell;
XtDestroyWidget h;
XmNdefaultActionCallback;
help_widget shell text;
val iconBitmap = (
	case XReadBitmapFile (XtWindow shell) "pp_bitmap.h" of
		BitmapSuccess (x,_,_) => x
	|	_ => fail "setting_up_bitmap" 99999 []
);
XtSetValue shell (XmNiconPixmap iconBitmap);
XtSetValue shell (XmNiconName "VC Browser");
XtSetValues shell [XmNdeleteResponse XmUNMAP];
XtSetValues shell [XmNmappedWhenManaged false];
val XmNchildren cs = XtGetValue shell "children";
XtSetValues (hd cs) [XmNmappedWhenManaged true];
XmNeditable;
*)
(*
The following may be used to help convert an X11 bitmap file into
what is needed by XCreateBitmapFromData (although it would be
much better to supply 
fun int_of_hexit ch = (
	if	"0" <= ch andalso ch <= "9"
	then	ord ch - ord "0"
	else if "a" <= ch andalso ch <= "f"
	then	(ord ch - ord "a") + 10
	else	~1
);
fun Ox bb = (
	case explode bb of
		(h :: l :: []) => 16 * int_of_hexit h + int_of_hexit l
	|	_ => ~1
);
*)
