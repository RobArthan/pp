=IGN
********************************************************************************
usr501.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
Lemma 1 Ltd.% $Date: 2007/05/26 11:17:47 $ $Revision: 3.42 $ $RCSfile: usr501.doc,v $
=TEX
% TQtemplate.tex
% rash -W 6in -e usr501A.rs >usr501A.ps
% rash -W 6in -e usr501B.rs >usr501B.ps
% rash -W 6in -e usr501C.rs >usr501C.ps
% rash -W 6in -e usr501D.rs >usr501D.ps
% sed -n '/^=DOC/,/^=ENDDOC/p' <dtd516.doc | sieve tex > usr501E.tex
\documentstyle[11pt,hol1,fleqn,USR,epsf]{book}
% temporary measure while waiting for LaTeXe to come along
\def\LaTeXe{\LaTeX$2_{\varepsilon}$}
\def\Hide#1{}
\def\daztool{Compliance Tool}
% just useful macros
\def\ltm{$^{\rm TM}$}
\def\Note#1{{\small\bf[ #1 ]}}
=IGN
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Compliance Tool User Guide}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/USR501}  %% Mandatory field
\def\SCCSversion{$Revision: 3.42 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2007/05/26 11:17:47 $%
}}
\TPPstatus{Approved}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{Compliance Notation}
\TPPauthor{R.D.~Arthan & WIN01}  %% Mandatory field
\TPPauthorisation{R.D.~Arthan & Project Manager}
\TPPabstract{
This document is the User Guide for the Compliance Tool
being produced for DRA under the DAZ project.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
\begin{tabular}[t]{lr}
C.O'Halloran & DRA\\
DAZ Project Library & WIN01\\
\end{tabular}}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}
\def\TPPheadlhs{Lemma 1 Ltd.}
%\def\TPPheadcentre{}
%\def\TPPheadcentreproject{}
%\def\TPPheadrhs{}
\let\TPPfootlhs=\TPPfootrhs
\def\TPPfootcentre{$\vcenter{\halign{\hfil\strut##\hfil\cr
COPYRIGHT  \copyright\ Lemma 1 Ltd.\cr}}$}
=TEX
\ftlmargin 0.0in
\ftrmargin 0.0in

\def\SCCSversion{$Revision: 3.42 $%
}
\def\SCCSdate{\FormatDate{$Date: 2007/05/26 11:17:47 $%
}}

\USRmanual{Compliance Tool User Guide}
\USRref{USR501}
\USRisbns{1514277689}
\USRisbnl{978-1514277683}

\raggedbottom
\ftlinepenalty=9999
\makeindex

\begin{document}
\makeUSRfrontpage

\underscoreoff

\chapter*{CONTENTS}

\tableofcontents
\listoffigures

\pagebreak

\setcounter{chapter}{-1}

\chapter{ABOUT THIS PUBLICATION} \label{intro}
\section{Purpose}

This document describes the use of the Compliance Tool supplied with {\Product}.

\section{Readership}
This document is intended to be read by users of the Compliance Tool.
It contains both introductory material for the new user and reference material for more experienced users.

\section{Related Publications}

A bibliography is given on page~\pageref{REFERENCES} of this document.

\begin{itemize}

\item
Installation of the Compliance Tool is described in:

{\CNINSTALLATION}


\item
Advice on proving verification conditions generated by the tool is given in:

{\CNPROVINGVCS}


\item
The syntax and semantics of the Compliance Notation as supported by the Compliance Tool is described in:

{\CNNOTATION}

\item
An overview of the of the Compliance notation can be found in the DRA document:

{\em A commentary on the Specification of the Compliance Notation for SPARK and Z} \cite{DRA/CIS(SE2)/PROJ/SWI/TR/1/1.1}.

\item
A description of \Product{} may be found in:

{\DESCRIPTION},

which also contains a full list of other \Product{} documentation.

\end{itemize}

\section{Area Covered}

Once the Compliance Tool is installed on the user's workstation, by following the procedure described in {\em Compliance Tool Installation and Operation \cite{ISS/HAT/DAZ/USR502}}, this User Guide should enable the user to undertake the following tasks:

\begin{enumerate}
\item
Loading a Compliance Notation script into the tool;
\item
Generation of the Ada program from a script;
\item
Generation of the Z document from a script and reloading the Z document into {\Product};
%VCB \item
%VCB Using the VC Browser to examine the VCs and the Compliance Notation constructs which gave rise to them;
\item
Preparation and checking of new scripts;
\item
Using {\Product} facilities to work with VCs, e.g., to begin an attempt to prove a VC;
\item
Evaluation of the rigour of a compliance argument by identifying the informal and formal parts of the argument and recognising potentially anomalous ways of using the facilities of the tool.
\end{enumerate}

\section{Prerequisites}

This User Guide is {\em not} intended to be an introduction to the Z language, or to the Compliance Notation, or to the use of {\Product} to prepare the Z parts of a script.

Familiarity with the Compliance Notation and some familiarity with {\Product} are very desirable, although not essential for simple use of the tool to process existing scripts.
Some familiarity with the use of {\Product} for developing Z specifications is required to use the tool to develop new scripts.



The Compliance Notation is described in {\CNNOTATION}.
There is also a formal specification of the notation in the DRA technical report \cite{DRA/CIS/CSE3/TR/94/27}.
The {\ProductZ} tutorial, \cite{DS/FMU/IED/USR010}, gives an introduction to the use of {\Product} for specification and proof in Z.

The {\Product} user documentation is supplied as part of the {\Product} release  included with the Compliance Tool and is available for on-line reference.

The user interface to the tool described in this document is a Motif application  running under the X Windows System.
Users who are unfamiliar with X or Motif should consult local or supplier's documentation or expertise for further guidance (e.g.\ see \cite{sun92a}).



\section{Acknowledgements}
=IGN
The below are taken from Motif 1.2 Users Guide, July 1993
=TEX
Sun Microsystems is a registered trademark of Sun Microsystems Inc.  Sun-3, OpenWindows, Sun-4, SPARCstation, SunOS and Solaris are trademarks of Sun Microsystems Inc.

Motif is a registered trademark of the Open Software Foundation, Inc.

UNIX is a registered trademark of UNIX System Laboratories, Inc.

\TeX{} is copyright the American Mathematical Society and by Donald E. Knuth.
The \LaTeXe\ distribution tape is copyright the \LaTeX\ 3 project and its individual authors.

The X Windows System is a trademark of the Massachusetts Institute of Technology.

=TEX
\chapter{INTRODUCTION TO THE COMPLIANCE TOOL}\label{INTROTOOL}
\section{The Compliance Notation}
The Compliance Tool supports a notation for demonstrating the compliance of Ada programs with Z specifications.
The notation is described in detail in \CNNOTATION.
The Ada parts of the notation belong to the Compliance Notation subset of Ada and will be referred to as Compliance Notation Ada in the rest of this document.
The Compliance Notation was designed by the Defence Research Agency, Malvern and
the ideas behind its design are discussed in the DRA document \cite{DRA/CIS(SE2)/PROJ/SWI/TR/1/1.1}.

Compliance Notation is prepared and presented in literate scripts containing a mixture of narrative text, Z and Compliance Notation Ada.
Special constructs are provided for two main purposes:

\begin{enumerate}
\item
to allow the Ada program to be presented and documented in an order independent of that prescribed by the Ada syntax (in a similar fashion to Knuth's Web system \cite{Knuth84a});
\item
to allow the behaviour of the Ada code to be formally specified in Z (using a style based on Morgan's refinement calculus \cite{Morgan90}).
\end{enumerate}

These constructs allow the user to assert formal connections between the Z parts and the Ada parts in a Compliance Notation script and permit the compliance of the Ada program against its Z specifications to be reduced to a set of conjectures known as verification conditions, whose truth guarantees compliance.
The VC generation algorithm is formally specified in the DRA technical report \cite{DRA/CIS/CSE3/TR/94/27} and explained by example in \CNNOTATION.
The algorithm maps a Compliance Notation script to a Z document containing the VCs formulated with Z conjectures together with supporting Z definitions.

\section{The Compliance Tool}
The Compliance Tool described in this document supports the use of the Compliance Notation.
It performs the following principal functions:

\begin{enumerate}
\item
Checking the syntax of a Compliance Notation script;
\item
Generating the Z document including VCs from a script;
\item
Extracting the Ada program from a script.
\end{enumerate}

The Compliance Tool is implemented as an application of the {\Product} specification and proof tool.
The tool provides all the facilities offered by {\Product} for developing specifications and proofs in HOL and Z and for preparing high quality printed output via the {\LaTeX} system.
The tool includes custom facilities for working with Compliance Notation including,
in some installations an interactive tool called the VC browser and
some customised proof procedures.

The use of the tool in the development of a compliance argument will involve several stages, typically including the following:

\begin{enumerate}
\item
Initial preparation of the literate scripts using the editing and interactive checking facilities of the tool.
During this stage, the Z documents and Ada program are produced and inspected as required to assist in the development.
\item
Batch processing of the complete literate scripts.
If the conventions suggested in this User Guide are followed, the Z documents and Ada program are produced automatically.
The tool can be used interactively if required, e.g., to help diagnose errors.
\item
Further analysis of the Z documents.
Depending on circumstances and on the level of formality required, this might involve
either or both of:
{\em(a)}, inspection of the documents, on paper or using a viewer;
{\em(b)}, use of the VC browser supplied with the tool;
and, {\em(c)}, machine-checked proof of some or all of the VCs.
\end{enumerate}

The Compliance Tool offers a range of facilities to help in all of these activities.


\chapter{GETTING STARTED}

The task of using of the Compliance Tool to process a script is very similar to that of using {\Product} to process a Z specification.
Indeed, the Z paragraphs in a Compliance Notation script are handled using the usual {\Product} mechanisms and the constructs peculiar to the Compliance Notation are treated in a very similar way.

Simple use of the tool to process existing scripts does not require any great familiarity with {\Product}.
Using the tool to create new scripts or edit existing ones requires some familiarity with the preparation of Z specifications using {\Product} (as described in \cite{DS/FMU/IED/USR011}).
The rest of this chapter explains how to make a start with the tool for either of these levels of use.
Section \ref{Databases} describes set-up procedures which are common to batch and interactive working;
section \ref{BatchWorking} describes how to use the tool to process existing scripts using UNIX commands;
section \ref {InteractiveWorking} explains how to start an interactive session with the tool and gives an overview of its main graphical features.


\section{{\Product} Databases}\label{Databases}
As always with a {\Product} application, to use the Compliance Tool you must first pick the {\Product} database with which you wish to work.
A {\Product} database is a file which holds code and data recording the results of work with {\Product}.
These databases are organised in a hierarchy.
To run the Compliance Tool, you use a database which is a descendant in this hierarchy of the database {\tt pp\_daz}.
This database, held in a file called
{\tt sun4bin/sun4pp\_daz.db} in the {\Product} installation directory, contains the code and data required to process Compliance Notation.
If you are starting from scratch, you would create a suitable database, say called {\tt mydatabase}, using a UNIX command line such as:

\begin{verbatim}
        pp_make_database -p daz mydatabase
\end{verbatim}

This creates an empty database, which you will generally refer to as `{\tt mydatabase}' when using the system.
The database is held in a file called `{\tt sun4mydatabase.db}' and this is the name you would use to carry out UNIX file operations on the database, e.g., to delete it with the UNIX command `{\tt rm}'.

\section{Batch Working}\label{BatchWorking}
Providing the conventions of chapter~\ref{LITERATESCRIPTCONVENTIONS} have been followed in the development of the scripts,
one or more literate scripts may be processed using the programs {\tt docsml} and {\tt pp} to produce the Z documents and Ada program.
For example, assuming a database {\tt mydatabase} has been set up as described above, the following UNIX commands will process the script in file {\tt wrk501.doc}.

\begin{verbatim}
        docsml wrk501
        pp -f wrk501 -d mydatabase >wrk501.run.log
\end{verbatim}

Here the first command produces a file called {\tt wrk501.sml}, containing the formal material from {\tt wrk501.doc} without the narrative text.
The second command causes the Compliance Tool proper to process {\tt wrk501.sml}, updating the database {\tt mydatabase} and producing the Z document and Ada program for the script.
If the conventions of chapter~\ref{LITERATESCRIPTCONVENTIONS} have been followed in the development of the script, the Z document will be in a file called {\tt wrk501.zdoc} and the Ada program will be in {\tt wrk501.ada}.
The log produced as the standard output from {\tt pp} has been directed to a file {\tt wrk501.run.log}, since it is likely to contain non-ASCII characters.

In a compliance argument involving more than one script, the {\tt docsml}-{\tt pp} command sequence above is entered in turn for each script.
Note that the order of the scripts is important, and providers of compliance arguments must indicate the required order (e.g., by supplying a make file or a shell script containing the necessary sequence of commands).

The Ada program is an Ada source file which may be examined with any text editor.
The Z document contains non-ASCII characters and is best examined either using the {\tt xpp} editor or using the program {\tt docpr} to print it.
The log file  is best examined in the same way.
The following UNIX command will print the Z document in our example:

\begin{verbatim}
        docpr wrk501.zdoc
\end{verbatim}

Basic use of the {\tt xpp} editor is described in section \ref{StartingXpp}.
To use it to examine the Z document in this example, one would use the UNIX command:

\begin{verbatim}
        xpp -file wrk501.zdoc
\end{verbatim}

\section{Interactive Working}\label{InteractiveWorking}
\subsection{Starting {\tt xpp}}\label{StartingXpp}
To start an interactive session with the Compliance Tool, you use the UNIX command {\tt xpp}.
{\tt xpp} comprises a custom editor for working on your scripts together with a command interface for executing {\Product} commands and for loading Z and Compliance Notation constructs into the database.

The {\tt xpp} command has options to identify the file containing the script you want edit and to give the {\Product} command options (including the database to use).
To begin work on the script `{\tt wrk501.doc}' with the database `{\tt mydatabase}', you might use the UNIX command line:

\begin{verbatim}
        xpp -f wrk501.doc -c pp -d mydatabase
\end{verbatim}


This will create a Motif window similar to the one shown in figure \ref{fig1}.
This is referred to as the {\tt xpp} Main Window.
If you omit the {\tt -c} option, then you will get a so-called edit-only session, in which the lower part of the window will be missing.

\subsection{Window Layout}\label{WindowLayout}
This section describes briefly the main elements of the {\tt xpp} Main Window.
Further information may be obtained either from the tool's help system or from the {\Product} documentation.

In overview, the top part of the window acts as an editor for literate scripts.
Material from the editor can be transferred into the {\ProductML} system for processing (e.g.\ to type check a specification paragraph or initiate a proof step).
The journal of the transactions with {\Product} occupies the bottom part of the window.
Figure \ref{fig1} also shows a popup window (in this case a palette of special symbols).
The size and position of all the windows can be adjusted using standard Motif techniques.

Sections \ref{MenuBar} to \ref{JournalWindow} below describe the principal features of the {\tt xpp} Main Window.

\subsubsection{Menu Bar}\label{MenuBar}
The menu bar is at the top of the window shown in figure \ref{fig1}.
The menus are all pulldown menus operated in the usual Motif fashion.
The functions they perform are briefly described below.

\paragraph{File Menu}
This menu is for common file operations including: loading and saving the literate script; creating a new literate script; deleting a file.

\paragraph{Tools Menu}
This menu is used to create popup windows to perform various tasks.
An example is the palette window shown in figure \ref{fig1}.

\paragraph{Edit Menu}
This menu provides script editing operations: `Cut', `Copy', `Paste' and `Undo'.
\paragraph{Command Menu}\label{CommandMenu}

This menu is primarily used to cause text from the script window to be executed by the {\ProductML} system.
It also provides various control functions for the {\ProductML} system.

\paragraph{Help Menu}\label{HelpMenu}
This menu provides help on various topics.
Its `Tutorial' item may be consulted for more information on basic operation of {\tt xpp}.

\subsubsection{File Name Bar}\label{FileNameBar}
This displays the name of the file containing the script which is being edited in the Script Window.

\subsubsection{Script Window}\label{ScriptWindow}
The Script Window is the upper large Motif text window in the {\tt xpp} Main Window.
It provides a general purpose editor for viewing and modifying scripts.
In  figure \ref{fig1} on page \pageref{fig1}, a Compliance Notation script containing definitions of a Z global variable, `$primed$', and an Ada procedure, `$primes$', is being displayed in the Script Window.

Part of the Script Window in figure \ref{fig1} is hidden behind a window containing a `palette' of symbols.
This palette has been selected from the Tools Menu and can be used to enter the symbols into the literate script.
Pushing one of the buttons on the palette causes the symbol to appear in the document as if it had been typed at  the keyboard.

Note that the Z and Ada constructs in the Script Window are delimited using special mark-up sequences:
{\ShowAllImages `$ⓈZ$'', `$ⓈCN$' and `■'}.
A tool called the Templates Tool is available from the Tools Menu allowing easy entry of these mark-up sequences.

\subsubsection{Journal Window}\label{JournalWindow}
The Journal Window is the lower large Motif text window in the {\tt xpp} Main Window.
When {\Product} commands are executed the resulting responses from the {\Product} system are displayed in the Journal Window.
The Journal Window is a read-only text window --- you cannot alter its contents by typing into it.

In \ref{fig1}, the user has just issued a command to process the procedure $primes$.
This is done by selecting the procedure and its delimiting mark-up sequences in the Script Window and then using the `Execute' item in the Command Menu.
The absence of error messages in the Journal Window and the prompt (`$:>$') indicate that the procedure has been processed and accepted.

\begin{figure}[hp]
\begin{center}
\leavevmode
% rash -W 6in -e usr501A.rs >usr501A.ps
\epsffile{usr501A.ps}
\end{center}
\caption{An Example Compliance Tool Session}\label{fig1}
\end{figure}


\chapter{LITERATE SCRIPT CONVENTIONS}\label{LITERATESCRIPTCONVENTIONS}

Literate scripts are held in UNIX files, each file holding one or more scripts.
Typically, each script contains exactly one compilation unit (such as a package specification or package body) together with any Z definitions needed to support the specification of that compilation unit.
A script need not contain any Ada code at all, in which case the script just provides Z definitions for use in other scripts.
A script may not contain more than one compilation unit.

Processing a script has three main goals: production of a Z document; production of the Ada program (i.e., the source code contained in the script); and modifications to the state of a database maintained by the tool and used in processing subsequent scripts.
The literate scripts making up a complete compliance argument must be presented to the tool in some order, compatible with any dependencies between the scripts.

In addition to narrative text, Z paragraphs and Compliance Notation clauses, each script contains commands which direct the tool, e.g., to tell it to output the Ada program to a particular file.
In this chapter, we recommend some conventions for these commands which are intended to make the script easy to process both interactively and in batch.
A complete example of a script following these conventions is given in chapter~\ref{EXAMPLESCRIPT}.

The conventions described below are not enforced by the tool, and some users may wish to adapt them to their own needs.
However, other sections of this user guide are written on the assumption that these conventions have been followed (e.g., section~\ref{BatchWorking}).
The conventions are designed to make compliance arguments easy to assess.
If you need to adopt different conventions, please refer to section~\ref{EVALUATIONGUIDELINES} for further guidance on assessing a compliance argument.

\section{Initialisation}\label{Initialisation}
The formal material in each literate script should be preceded by an initialisation section giving a name to the script
in which it is to be processed.
This is done with a {\ProductML} command, $new\_script$.
Execution of $new\_script$ introduces a new {\Product} theory whose name is the name of the script and prepares the Compliance Tool to accept an Ada compilation unit.
For example:
=GFT
	new_script{name = "Utils", unit_type = "spec"};
=TEX
Here the name is the name of the compilation unit and
{\em unit\_type} indicates its type, which
must be one of
=INLINEFT
"spec"
=TEX
\ (package specification),
=INLINEFT
"body"
=TEX
\ (package body),
=INLINEFT
"proc"
=TEX
\ (procedure) or
=INLINEFT
"func"
=TEX
\ (function).

Dependencies on {\Product} theories that come from Ada constructs such as context clauses are handled automatically by the tool.
However, in some circumstances, you may need to inform the tool that a script depends on one or more theories in the initialisation for the script.
This might happen if you have an existing library of Z theories containing definitions that you want to use in the script.
A variant of $new\_script$, called $new\_script1$ allows you to give a list of {\em library theories} that become parents of the script theory.
For example, if $script3$ depends on the Z paragraphs stored in $mytheory1$ and $mytheory2$, then you can use the command:

=GFT
	new_script1{name = "Utils", unit_type = "spec",
		library_theories=["mytheory1", "mytheory2"]};
=TEX

In some circumstances, you may want to write Z paragraphs referring to the types, constants or functions in a package, $P$ say, before giving the Ada compilation unit containing the context clause identifying $P$ as a dependency.
In this case, you can identify the package specification theory, $Pspec$, as a library theory in the script initialisation.

\section{Theory Hierarchy}
For each compilation unit, the corresponding {\em new\_script} (or {\em new\_script1} command introduces a {\Product} theory.
For example, associated with a package body {\tt utils} there will be a theory called {\em UTILS'body}.

For each subprogram body inside a package or subprogram body, and for each package or subprogram stub, the Compliance Tool automatically creates a {\Product} theory whose name is derived from the expanded name of the package or subprogram.
These theories are referred to as subprogram or stub theories.


A subprogram or stub theory is created with an automatically generated parent theory which is a duplicate of the theory associated with the enclosing body as it was at the point where the subprogram body or stub was processed (but with any VCs removed).
This parent theory is called the context theory for the subprogram or stub.
For example, if a package body {\em Utils} contains a procedure {\em sort},
a context theory called {\em UTILSoSORT'context} is created as a duplicate of the script theory
{\em UTILS'body}

The subprogram theories are used to hold the Z paragraphs representing the types and constants defined in the declarative part of the subprogram body and to hold VCs associated with the statement part.
The Compliance Tool requires you to work in the appropriate theory when processing Compliance Notation clauses.
The command {\em open\_scope},
which takes as its argument the expanded name of the subprogram or package, is used to do this.
For example, to refine a specification statement in the body of the procedure {\em sort} in the example mentioned above, you would need to make the following call:

=GFT
	open_scope "Utils.sort";
=TEX


Stub theories are used to provide a context for processing the corresponding subunit.
When a subunit is processed, the stub theory is automatically made a parent of the script theory.


For example, if the package {\tt utils} contains the body of a procedure called {\tt sort}, the tool will create a subprogram theory called {\em UTILSoSORT'proc}.
If the package {\tt utils} contains a stub for a package called {\tt strings}, the tool will create a stub theory called {\em UTILSoSTRINGS'stub}.
The list of all the theories associated with a script can be found using the function {\em get\_script\_theories}.
For example:

=GFT
	get_script_theories "UTILS'body";
=TEX

might result in the following output:

=GFT Compliance Tool Output
val it = ["UTILS'body", "UTILSoSORT'proc", "UTILSoSTRINGS'stub"] : string list
=TEX

\section{Output Commands}\label{OutputCommands}
The formal material in a literate script should be followed by directions for the production of the Z document and of the Ada program.
This should be as in the following example:

=GFT
	output_z_document{script="UTILS'spec", out_file="utils_ads.zdoc"};
	output_ada_program{script="UTILS'spec", out_file="utils_ads.ada"};
=TEX
Here
=INLINEFT
UTILS'spec
=TEX
\ is the script name, and conventional file name suffixes have been added to it for the Z document and the Ada program.



\chapter{COMPLIANCE TOOL FUNCTIONS}
Sections \ref{Loading} to \ref{PrintingAndPreviewing} below describe basic use of the main functions of the Compliance Tool.

You invoke many of these functions by executing {\ProductML} commands.
This may conveniently be done interactively using the Command Line Tool which can be started using the Tools Menu.
An instance of the Command Line Tool may be seen in figure \ref{fig2} on page \pageref{fig2}.
This tool allows single line {\ProductML} commands to be entered and executed without changing the script which is being edited.
The tool also has a scrollable list which you can use as a memory for common commands.

Some functions are provided as UNIX commands or as a combination of UNIX and {\ProductML} commands.

\section{Loading Scripts}\label{Loading}
To load a script, the UNIX command {\tt docsml} must first be used to extract the formal material.
For example, the UNIX command:
\begin{verbatim}
        docsml wrk501
\end{verbatim}

copies the formal material from the file {\tt wrk501.doc} into a file called {\tt wrk501.sml}.

The {\tt .sml} file produced by {\tt docsml} may then be loaded using the {\ProductML} command:

=GFT
	use_file "wrk501";
=TEX

By default, the tool will raise an exception and stop processing a script if it detects an error.
However, while preparing a compliance argument for a large program, it can be convenient to have
the tool continue processing when errors are detected. This can be controlled
using the flag
=INLINEFT
cn_stop_on_exceptions
=TEX
.
The tool maintains a record of the errors that have been detected which can be manipulated
using the {\ProductML} commands,
=INLINEFT
print_exception_log
=TEX
,
=INLINEFT
output_exception_log
=TEX
\ and
=INLINEFT
delete_exception_log
=TEX
. See section~\ref{COMMANDREF} for more information.

\section{Generating the Ada Program}\label{AdaProgram}
The Ada program is output to a file using the {\ProductML} command $output\_ada\_program$.
This command is normally included at the end of each literate script as described in section \ref{OutputCommands} and may also be called at any time during the development of the script.

A function $print\_ada\_program$ is also provided for displaying the compilation
units of the Ada program on the standard output.
It takes a string parameter giving the name of the script in which the compilation unit was introduced.
A minus sign may be used as a short-hand for the name of the current script.
For example, in an interactive session with {\tt xpp}, the {\ProductML} command:

=GFT
	print_ada_program"-"
=TEX
will cause the Ada program for the current script
to be displayed in the journal window.

Some errors, in particular illegal redeclaration of names, are not detected until the Ada program is generated, so generation of the Ada program is an important part of processing a script.
Even if these errors are detected, the Ada program is displayed or output to the file before the errors are reported.
This allows a script containing informally developed code in which redeclaration of names is required to be processed by the tool (some redeclarations are legal Ada, but not legal Compliance Notation Ada).

When loading scripts, detection of an error will normally cause the tool to raise an exception and stop processing.
You can override this behaviour selectively by using a {\ProductML} exception handler.
For example, the following {\ProductML} command will output the Ada program to the file {\tt SCRIPT.ada} and continue without raising an exception even if the program contains illegal redeclarations:

=GFT
	output_ada_program{script="-"=, out_file="SCRIPT.ada"}
		handle Fail _ => ();
=TEX

The subset of Ada accepted by the Compliance Tool includes a number of features, e.g., use clauses,
that are not supported in the SPARK subset of Ada (see \cite{Barnes97} for the definition of the SPARK subset of Ada).
You may ask for Ada comments highlighting constructs that do not conform to the SPARK syntax
to be inserted in the Ada program uinsg the flag
=INLINEFT
cn_spark_syntax_warnings
=TEX
. See section~\ref{COMMANDREF} for more information.

\section{Generating and Reloading the Z document}\label{ZDocument}
The Z document is output to a file using the {\ProductML} command $output\_z\_document$.
This command is normally called at the end of each literate script as described in section \ref{OutputCommands} and may also be called at any time during the development of the script.

A function $print\_z\_document$ is also provided for displaying the Z document on the standard output.
For example, in an interactive session with {\tt xpp}, the {\ProductML} command:

=GFT
	print_z_document "SCRIPT";
=TEX
will cause the Z document for the script called
=INLINEFT
SCRIPT
=TEX
\ to be displayed in the journal window.

In many situations, there is no actual need to reload the Z document, since it is automatically loaded as a side-effect of processing the literate script.
Thus work on proof of VCs, for example, can begin immediately after the script is processed.
The Z document can be reloaded into the tool, if required, simply by treating it in the same way as a {\tt .sml} file produced by running {\tt docsml} on an ordinary Z specification.
Thus one can use either a {\ProductML} command such as:

=GFT
	use_file"SCRIPT.zdoc";
=TEX
or a UNIX command such as:

\begin{verbatim}
        pp -f SCRIPT.zdoc -d database
\end{verbatim}

to load in the Z document.
The following points should be noted in connection with reloading Z documents produced by the Compliance Tool:

\begin{enumerate}
\item the Z document requires the presence of the theory $cn$, which is not provided as standard in {\ProductZ} databases so that {\tt database} in the example above should refer to a Compliance Tool database;
\item loading the Z document attempts to create {\Product} theories which will already exist in a database in which the literate script giving rise to the Z document has already been processed (so that these theories must be deleted, or a fresh Compliance Tool database created, if the loading is to succeed);
\item loading the Z document does not recreate the information about the Ada program which is computed and stored when the literate script is processed
(so that facilities such as {\it print\_ada\_program} which require this information will no longer be useful).
\end{enumerate}




% \section{Using the VC Browser}\label{VCBrowser}
\section{Inspecting the VCs}\label{VCBrowser}
Figure \ref{fig2} on page \pageref{fig2} gives another example of an {\tt xpp} Main Window.
In this example, the user has used the Command Line Tool to issue commands to load an entire script into the tool and then display the Z document in the Journal Window.
The Search-and-Replace Tool has been used to carry out a textual search in the Script Window for the refinement step which introduced the VC at the end of the Z document.


Using an editor to correlate the script with the VCs can be a useful technique but is often time consuming.
The VC Browser is an interactive tool for examining the VCs and relating them to the Compliance Notation clauses which produced them.
The VC Browser is provided in the {\Product} database \verb"xdaz" on implementations
of the Compliance Tool built with the Poly/ML compiler.
To use it you must ensure that X Windows and Motif support is compiled into the Poly/ML driver
program \verb"poly". See the Poly/ML documentation for more information.

To use the VC browser, you carry out your Compliance Notation work in an X Windows environment
using the \verb"xdaz" database rather than the \verb"daz" database. I.e., using \verb"pp -d xdaz"
rather than \verb"pp -d daz".
The VC Browser is started by running the {\ProductML} command `$browse\_vcs()$'.
This brings up a window which can be used to inspect the VCs that have been generated
and the Compliance Notation clauses which gave rise to them.
Press the VC Browser's ``Help'' button for more information.

%VCB This produces a window like the one shown in figure \ref{fig3} on page \pageref{fig3}.


%VCB The main controls in the VC Browser are two scrolling lists of names and some push-buttons.
%VCB Above each list is a text area.
%VCB
%VCB The list on the left contains the names of the clauses in the script;
%VCB the list on the right the names of the VCs.
%VCB Double-click on an item in either list to display the clause or VC in the text area above the list.
%VCB
%VCB The buttons marked `Filter' are used to find the clause corresponding to a selected VC and the VCs corresponding to a selected clause.
%VCB After you have used one of the `Filter' buttons, you can use the corresponding `Reset' button to restore the contents of the list.
%VCB
%VCB In figure \ref{fig3}, the user has double clicked on the label `$5$' in order to see the corresponding refinement step.
%VCB Pressing the right-hand filter button has then resulted in the corresponding VC  being listed and displayed on the right (in this case there is only one VC).
%VCB


\begin{figure}[hp]
\begin{center}
\leavevmode
\epsffile{usr501B.ps}
\end{center}
\caption{Inspecting VCs with {\tt xpp}}\label{fig2}
\end{figure}

%VCB \begin{figure}[hp]
%VCB \begin{center}
%VCB \leavevmode
%VCB \epsffile{usr501C.ps}
%VCB \end{center}
%VCB \caption{Inspecting VCs with the VC Browser}\label{fig3}
%VCB \end{figure}

\pagebreak
\section{Editing and Checking a Script}\label{Editing}

The {\tt xpp} Script Window provides a general purpose editor for use in preparing scripts.
The {\Product} document \cite{DS/FMU/IED/USR004} or the {\tt xpp} help system may be consulted for an introduction to its use.
The easiest way to begin constructing a new script is to adapt an existing one, and a number of examples are supplied with the Compliance Tool for this purpose.

Just as with a {\ProductZ} specification, a Compliance Notation script may be entered a clause at a time so that errors can be detected and corrected interactively.
Note however, that the initialisation section of the script as described in section \ref{Initialisation} has to be entered first of all, and that clauses will generally need to be entered in the correct order.

If a Compliance Notation clause has been rejected because of an error,
the clause can normally be re-entered once the error has been corrected.
However, if a clause has been accepted, it cannot normally be re-entered.
If you have loaded a script and wish to modify and reload it, the function
=INLINEFT
delete_script
=TEX
\ may be used to avoid having to start again from scratch.
=INLINEFT
delete_script
=TEX
\ takes as its parameter the name of the script to be deleted.
It prints out a report of what it has deleted to help you determine what must be reloaded.
A call of
=INLINEFT
delete_script
=TEX
\ would normally be followed by a
=INLINEFT
new_script
=TEX
\ command to begin work on the revised version of the script.

To make entry of Compliance Notation constructs easier, the Templates Tool in {\tt xpp} has been customised so that you can enter a template for any of the following constructs with one button-press:

\begin{enumerate}
\item
Replacement Step;
\item
Refinement Step;
\item
Compilation Unit;
\item
Specification Statement;
\item
Each of the 8 Z Paragraph forms.
\end{enumerate}

The customised Templates Tool may be seen in figure \ref{fig4} on page \pageref{fig4}.
The four buttons at the bottom are for the four Compliance Notation constructs listed above.
In the figure the user has just pressed the refinement step button and has started to fill in the template at the bottom of the Script Window --- the label has been filled in and the ellipsis, `\ldots', has been selected ready to be replaced by the statement part of the refinement.

\begin{figure}[hpt]
\begin{center}
\leavevmode
\epsffile{usr501D.ps}
\end{center}
\caption{Compliance Notation Templates Tool}\label{fig4}
\end{figure}

\section{Accessing and Proving VCs}\label{AccessingVCs}

VCs are represented in the tool using Z's conjecture paragraph form.
A conjecture paragraph associates a name with a Z predicate, and is used in specifications to record properties which the specifier believes to be true of the objects specified.
In {\Product}  the function $get\_conjecture$ retrieves a conjecture from a specification by name.
The conjecture is retrieved as a Z term which can be used, e.g., to form a goal for proof with the {\Product} Subgoal Package.

The tool assigns a name to each Compliance Notation clause in the script being processed and this name is used as the basis for the names of any VCs generated by the clause.
In the case of clauses containing a package or similar named Ada object, the name is taken from the object name;
for other clauses the name is derived from the implicit or explicit numeric label associated with the clause.

Examples of VC names can be seen in  \ref{fig2} on page \pageref{fig2}.
Here the clause name $5$ on the left refers to the refinement step refining label $5$
as shown in the following extracts from the file {\tt wrk501.doc}:

=GFT Compliance Notation
⊑
Δ MULT[mult_inv, mult_inv ∧ MULT (N) ≥ J]
Δ JPRIME [mult_inv ∧ MULT (N) ≥ J,
		mult_inv ∧ MULT (N) ≥ J ∧ JPRIME = MULT (N) noteq J]	(5)
■
=GFT Compliance Notation
(5) ⊑

jprime := mult(n) /= j;
■

The VCs corresponding to the clause named $5$ are named $vc5\_1$, $vc5\_2$, etc. (in this case there is only one).
A clause name like $4\_11$ is used for the $11$-th unlabelled refinement step in the script, with the $4$ indicating that this refinement step comes after the one labelled $4$.

To access the VC in the example, one would use the {\ProductML} function call:

=GFT
	get_conjecture "PRIMES'proc" "vc5_1";
=TEX

Here the first parameter gives the name of the literate script which gave rise to the VC.
Proof of a VC will normally need to be carried out within the theory corresponding to the literate script in question.
Thus, to begin work on a proof of the VC with the Subgoal Package, the following commands would be used:

=GFT
	open_theory "PRIMES'proc;
	set_goal([], get_conjecture "PRIMES'proc" "vc5_1");
=TEX

As ordinary Z goals, VCs may be proved using all of the normal facilities provided by {\Product} for proof in Z.
Some extensions to the Z toolkit are used in many VCs.
These extensions are contained in the theory $cn$.
Some custom support is provided in the Compliance Tool to assist with reasoning in this theory, most notably the proof contexts $cn1$ and $cn1\_ext$.
These proof contexts (amongst others) and the other custom proof tools are described in section \ref{CustomProofFacilities} of this document.
The user interface to the conversions etc. described there is via the proof contexts, so that most users will only need to be familiar with the proof contexts.
An example of a complete proof script for a literate script is included in chapter~\ref{EXAMPLESCRIPT}

\section{Printing and Previewing Scripts}\label{PrintingAndPreviewing}
You can produce a {\LaTeX} document from a Compliance Notation script using {\Product}'s document preparation facilities, which are described in detail in \TUTORIAL.
The UNIX command {\tt doctex} is used to produce the {\LaTeX} file which you can then run through {\LaTeX} using the UNIX command {\tt texdvi}.
You can then print or preview the resulting DVI file using the programs provided with your {\LaTeX} installation.

So for example, to print the script in file {\tt wrk507.doc} on a PostScript printer, you might use the following UNIX commands:

\begin{verbatim}
        doctex wrk507
        texdvi wrk507
        dvips wrk507
\end{verbatim}

You can also generate a DVI file with embedded hypertext links, which help you relate k-slots and specification statements with the corresponding replacement steps and refinement steps.
To do this, you use a Compliance Tool function which generates an edit script which can be used by {\tt doctex} to make the links.
For example, the example script {\tt wrk507.doc}, contains the following {\ProductML} command at the end:

=GFT
output_hypertext_edit_script{out_file="wrk507.ex"};
=TEX

When the script has been loaded, the DVI file with hypertext links can be produced using the UNIX commands:

=GFT
        doctex -e wrk507.ex wrk507
        texdvi wrk507
=TEX

The resulting DVI file, {\tt wrk507.dvi}, can then be viewed with a hypertext viewer such as {\tt xhdvi}.
You can navigate around the script by clicking on the underlined arrows which appear in the margins near k-slots, specification statements, refinement steps and replacement steps.

\chapter{EXAMPLE SCRIPT}\label{EXAMPLESCRIPT}
In this chapter, we give an example literate script, following the conventions recommended in chapter~\ref{LITERATESCRIPTCONVENTIONS}.
The script shows the initial part of the compliance argument for an Ada procedure for computing integer square roots.

Section \ref{TheLiterateScript} contains the script and associated {\Product} commands.
Sections \ref{TheZDocument} and  \ref{TheAdaProgram} shows the corresponding Z document and Ada Program.
Section \ref{TheProofs} contains proofs of the VCs produced by the script and section \ref{TheTheoryListing} shows the listing of the resulting {\Product} theory.

\section{The Literate Script}\label{TheLiterateScript}
\subsection{Initialisation Commands}
We give the script the name $SQRT'proc$ following the conventions for a script containing a compilation unit comprising a function named $SQRT$:

\Hide{%
=SML
force_delete_theory"SQRT'proc" handle Fail _ => ();
=TEX
}
=SML
new_script{name = "SQRT", unit_type = "proc"};
=TEX
\subsection{The Compliance Argument}
For simplicity, we present the square root function as a top-level procedure.
The procedure has a specification statement requiring that for non-negative input values of $X$, the output value of $Y$ is the integer part of the square root of $X$.

ⓈCN
procedure SQRT (X : INTEGER; Y : out INTEGER)

Δ Y [X ≥ 0, Y ** 2 ≤ X < (Y + 1) ** 2]

is
   LO : INTEGER;

   ⟨ local vars ⟩		(2)

begin
   LO := 0;

    Δ LO [X ≥ 0 ∧ LO = 0, LO ** 2 ≤ X < (LO + 1) ** 2]

   Y := LO;
end SQRT;
■

ⓈCN
(2) ≡

HI : INTEGER;
■

ⓈCN
⊑
Δ LO, HI [X ≥ 0 ∧ LO = 0, LO ** 2 ≤ X < (LO + 1) ** 2]
■

ⓈCN
⊑

HI := X + 1;

$till ⟦LO ** 2 ≤ X < (LO + 1) ** 2⟧

loop

    Δ LO, HI [LO ** 2 ≤ X < HI ** 2, LO ** 2 ≤ X < HI ** 2]

end loop;
■

ⓈCN
⊑

exit when LO + 1 = HI;

Δ LO, HI [LO ** 2 ≤ X < HI ** 2, LO ** 2 ≤ X < HI ** 2]
■
Note the development is not complete at this point.
However, we can still output the Z document and the Ada program as if it were, and begin to do proofs.
The fact that the development is not complete is made manifest in the Ada program which will contain null statements corresponding to the omissions, see section \ref{TheAdaProgram}.
\subsection{Output Commands}
=SML
output_z_document{script="SQRT'proc", out_file="usr501.zdoc"};
output_ada_program{script="SQRT'proc", out_file="usr501.ada"};

=TEX
\pagebreak
\section{The Z Document}\label{TheZDocument}
The following shows the Z document produced by the example script.

\Hide{%
=SML
force_delete_theory"SQRT'spec" handle Fail _ => ();
=TEX
}
=SML
new_theory "SQRT'spec";

ⓈZ
│ vcSQRT_1 ?⊢
│     ∀ X : INTEGER | X ≥ 0 ⦁ X ≥ 0 ∧ 0 = 0
■

ⓈZ
│ vcSQRT_2 ?⊢
│     ∀ LO : INTEGER; X : INTEGER
│       | X ≥ 0 ∧ LO ** 2 ≤ X ∧ X < (LO + 1) ** 2
│       ⦁ LO ** 2 ≤ X ∧ X < (LO + 1) ** 2
■

ⓈZ
│ vc2_1_1 ?⊢
│     ∀ LO : INTEGER; X : INTEGER | X ≥ 0 ∧ LO = 0 ⦁ X ≥ 0 ∧ LO = 0
■

ⓈZ
│ vc2_1_2 ?⊢
│     ∀ LO, LO⋎0 : INTEGER; X : INTEGER
│       | (X ≥ 0 ∧ LO⋎0 = 0) ∧ LO ** 2 ≤ X ∧ X < (LO + 1) ** 2
│       ⦁ LO ** 2 ≤ X ∧ X < (LO + 1) ** 2
■

ⓈZ
│ vc2_2_1 ?⊢
│     ∀ LO : INTEGER; X : INTEGER
│       | X ≥ 0 ∧ LO = 0
│       ⦁ LO ** 2 ≤ X ∧ X < (X + 1) ** 2
■

ⓈZ
│ vc2_2_2 ?⊢
│     ∀ HI : INTEGER; LO, LO⋎0 : INTEGER; X : INTEGER
│       | (X ≥ 0 ∧ LO⋎0 = 0) ∧ LO ** 2 ≤ X ∧ X < HI ** 2
│       ⦁ LO ** 2 ≤ X ∧ X < HI ** 2
■

ⓈZ
│ vc2_2_3 ?⊢
│     ∀ LO, LO⋎0 : INTEGER; X : INTEGER
│       | (X ≥ 0 ∧ LO⋎0 = 0) ∧ LO ** 2 ≤ X ∧ X < (LO + 1) ** 2
│       ⦁ LO ** 2 ≤ X ∧ X < (LO + 1) ** 2
■

ⓈZ
│ vc2_3_1 ?⊢
│     ∀ HI : INTEGER; LO : INTEGER; X : INTEGER
│       | (LO ** 2 ≤ X ∧ X < HI ** 2) ∧ LO + 1 eq HI = TRUE
│       ⦁ LO ** 2 ≤ X ∧ X < (LO + 1) ** 2
■

ⓈZ
│ vc2_3_2 ?⊢
│     ∀ HI : INTEGER; LO : INTEGER; X : INTEGER
│       | (LO ** 2 ≤ X ∧ X < HI ** 2) ∧ LO + 1 eq HI = FALSE
│       ⦁ LO ** 2 ≤ X ∧ X < HI ** 2
■

ⓈZ
│ vc2_3_3 ?⊢
│     ∀ HI, HI⋎0 : INTEGER; LO, LO⋎0 : INTEGER; X : INTEGER
│       | (LO⋎0 ** 2 ≤ X ∧ X < HI⋎0 ** 2) ∧ LO ** 2 ≤ X ∧ X < HI ** 2
│       ⦁ LO ** 2 ≤ X ∧ X < HI ** 2
■
=SML
(* Number of VCs in theory "SQRT'spec" : 10 *)
=TEX
\pagebreak
\section{The Ada Program}\label{TheAdaProgram}
The following shows the Ada program produced by the example script.
Note the $NULL$ statement the tool has introduced because the development was not complete.
The comment on the $NULL$ statements means that the unlabelled specification statement to which the tool has assigned label $2\_4$ has not been refined.

\begin{verbatim}
  PROCEDURE SQRT (X : IN INTEGER; Y : OUT INTEGER)
    -- Spec ...
  IS
    LO : INTEGER;
    HI : INTEGER;
  BEGIN
    LO := 0;
    HI := X + 1;
    -- ...
    LOOP
      EXIT WHEN LO + 1 = HI;
      NULL; -- 2_4
    END LOOP;
    Y := LO;
  END SQRT;
\end{verbatim}


\pagebreak
\section{The Proofs}\label{TheProofs}
To embark on the proofs of the VCs, we first open the theory for the literate script:
=SML
open_theory"SQRT'spec";
=TEX
We will work in the proof context $cn1$ most of the time:
=SML
set_pc"cn1";
=TEX
The statements of the VCs may be seen in the Z document in section \ref{TheZDocument} or in the theory listing in section \ref{TheTheoryListing}.

All but one of the VCs are little more than tautologies, and will be proved by repeating $strip\_tac$.
=SML
set_goal([], get_conjecture "SQRT'spec" "vcSQRT_1");
a(REPEAT strip_tac);
val vcSQRT_1_thm = save_pop_thm"vcSQRT_1_thm";
=TEX
=SML
set_goal([], get_conjecture "SQRT'spec" "vcSQRT_2");
a(REPEAT strip_tac);
val vcSQRT_2_thm = save_pop_thm"vcSQRT_2_thm";
=TEX
=SML
set_goal([], get_conjecture "SQRT'spec" "vc2_1_1");
a(REPEAT strip_tac);
val vc2_1_1_thm = save_pop_thm"vc2_1_1_thm";
=TEX
=SML
set_goal([], get_conjecture "SQRT'spec" "vc2_1_2");
a(REPEAT strip_tac);
val vc2_1_2_thm = save_pop_thm"vc2_1_2_thm";
=TEX
Before proving the next VC, we need to prove some simple facts about exponientation, namely:
=INLINEFT
x ** 1 = x
=TEX
\ and
=INLINEFT
x ** 2 = x * x
=TEX
. The proofs require little more than specialising the definition of
=INLINEFT
(_**_)
=TEX
\ appropriately.
=SML
set_goal([], ⓩ∀x: ℤ⦁  x ** 1 = x⌝);
a(REPEAT strip_tac);
a(rewrite_tac[rewrite_rule[](
    z_∀_elimⓩ(x ≜ x, y ≜ 0)⌝ (∧_right_elim(z_get_specⓩ(_**_)⌝)))]);
val star_star_1_thm = pop_thm();
=TEX
=SML
set_goal([], ⓩ∀x: ℤ⦁  x ** 2 = x * x⌝);
a(REPEAT strip_tac);
a(rewrite_tac[star_star_1_thm, rewrite_rule[](
    z_∀_elimⓩ(x ≜ x, y ≜ 1)⌝ (∧_right_elim(z_get_specⓩ(_**_)⌝)))]);
val star_star_2_thm = pop_thm();
=TEX
The meat of the next VC is that for non-negative $X$,
=INLINEFT
X ≤ (X + 1) ** 2
=TEX
.
Induction is used to prove this, together with the above lemmas and the automatic prover for linear arithmetic.
=SML
set_goal([], get_conjecture "SQRT'spec" "vc2_2_1");
a(REPEAT strip_tac THEN asm_rewrite_tac[star_star_2_thm]);
a(DROP_NTH_ASM_T 2 ante_tac THEN DROP_ASMS_T discard_tac THEN strip_tac);
a(z_≤_induction_tacⓩX⌝ THEN PC_T1 "z_lin_arith" asm_prove_tac[]);
val vc2_2_1_thm = save_pop_thm"vc2_2_1_thm";
=TEX
The remaining VCs are straightforward:
=SML
set_goal([], get_conjecture "SQRT'spec" "vc2_2_2");
a(REPEAT strip_tac);
val vc2_2_2_thm = save_pop_thm"vc2_2_2_thm";
=TEX
=SML
set_goal([], get_conjecture "SQRT'spec" "vc2_2_3");
a(REPEAT strip_tac);
val vc2_2_3_thm = save_pop_thm"vc2_2_3_thm";
=TEX
=SML
set_goal([], get_conjecture "SQRT'spec" "vc2_3_1");
a(rewrite_tac[]);
a(REPEAT strip_tac);
a(all_var_elim_asm_tac1);
val vc2_3_1_thm = save_pop_thm"vc2_3_1_thm";
=TEX
=SML
set_goal([], get_conjecture "SQRT'spec" "vc2_3_2");
a(REPEAT strip_tac);
val vc2_3_2_thm = save_pop_thm"vc2_3_2_thm";
=TEX
=SML
set_goal([], get_conjecture "SQRT'spec" "vc2_3_3");
a(REPEAT strip_tac);
val vc2_3_3_thm = save_pop_thm"vc2_3_3_thm";
=TEX


\pagebreak
\section{The Theory Listing}\label{TheTheoryListing}
The following is the listing of the theory $usr501$ produced by the example script and the proofs in the previous section.
=THEORYLISTINGSECTION
Parents
=TEX
=THEORYLISTINGTABLE
	cache'daz	cn
=TEX
=THEORYLISTINGSECTION
Conjectures
=TEX
=THEORYLISTINGOTHER
vcSQRT_1
	∀ X : INTEGER | X ≥ 0 ⦁ X ≥ 0 ∧ 0 = 0
vcSQRT_2
	∀ LO : INTEGER; X : INTEGER
	  | X ≥ 0 ∧ LO ** 2 ≤ X ∧ X < (LO + 1) ** 2
	  ⦁ LO ** 2 ≤ X ∧ X < (LO + 1) ** 2
vc2_1_1	∀ LO : INTEGER; X : INTEGER
	  | X ≥ 0 ∧ LO = 0
	  ⦁ X ≥ 0 ∧ LO = 0
vc2_1_2	∀ LO, LO⋎0 : INTEGER; X : INTEGER
	  | (X ≥ 0
	    ∧ LO⋎0 = 0)
	    ∧ LO ** 2 ≤ X
	    ∧ X < (LO + 1) ** 2
	  ⦁ LO ** 2 ≤ X ∧ X < (LO + 1) ** 2
vc2_2_1	∀ LO : INTEGER; X : INTEGER
	  | X ≥ 0 ∧ LO = 0
	  ⦁ LO ** 2 ≤ X ∧ X < (X + 1) ** 2
vc2_2_2	∀ HI : INTEGER; LO, LO⋎0 : INTEGER; X : INTEGER
	  | (X ≥ 0 ∧ LO⋎0 = 0) ∧ LO ** 2 ≤ X ∧ X < HI ** 2
	  ⦁ LO ** 2 ≤ X ∧ X < HI ** 2
vc2_2_3	∀ LO, LO⋎0 : INTEGER; X : INTEGER
	  | (X ≥ 0
	    ∧ LO⋎0 = 0)
	    ∧ LO ** 2 ≤ X
	    ∧ X < (LO + 1) ** 2
	  ⦁ LO ** 2 ≤ X ∧ X < (LO + 1) ** 2
vc2_3_1	∀ HI : INTEGER; LO : INTEGER; X : INTEGER
	  | (LO ** 2 ≤ X ∧ X < HI ** 2) ∧ LO + 1 eq HI = TRUE
	  ⦁ LO ** 2 ≤ X ∧ X < (LO + 1) ** 2
vc2_3_2	∀ HI : INTEGER; LO : INTEGER; X : INTEGER
	  | (LO ** 2 ≤ X ∧ X < HI ** 2) ∧ LO + 1 eq HI = FALSE
	  ⦁ LO ** 2 ≤ X ∧ X < HI ** 2
vc2_3_3	∀ HI, HI⋎0 : INTEGER; LO, LO⋎0 : INTEGER; X : INTEGER
	  | (LO⋎0 ** 2 ≤ X
	    ∧ X < HI⋎0 ** 2)
	    ∧ LO ** 2 ≤ X
	    ∧ X < HI ** 2
	  ⦁ LO ** 2 ≤ X ∧ X < HI ** 2
=TEX
=THEORYLISTINGSECTION
Theorems
=TEX
=THEORYLISTINGOTHER
vcSQRT_1_thm
	⊢ ∀ X : INTEGER | X ≥ 0 ⦁ X ≥ 0 ∧ 0 = 0
vcSQRT_2_thm
	⊢ ∀ LO : INTEGER; X : INTEGER
	    | X ≥ 0 ∧ LO ** 2 ≤ X ∧ X < (LO + 1) ** 2
	    ⦁ LO ** 2 ≤ X ∧ X < (LO + 1) ** 2
vc2_1_1_thm
	⊢ ∀ LO : INTEGER; X : INTEGER
	    | X ≥ 0 ∧ LO = 0
	    ⦁ X ≥ 0 ∧ LO = 0
vc2_1_2_thm
	⊢ ∀ LO, LO⋎0 : INTEGER; X : INTEGER
	    | (X ≥ 0
	      ∧ LO⋎0 = 0)
	      ∧ LO ** 2 ≤ X
	      ∧ X < (LO + 1) ** 2
	    ⦁ LO ** 2 ≤ X ∧ X < (LO + 1) ** 2
vc2_2_1_thm
	⊢ ∀ LO : INTEGER; X : INTEGER
	    | X ≥ 0 ∧ LO = 0
	    ⦁ LO ** 2 ≤ X ∧ X < (X + 1) ** 2
vc2_2_2_thm
	⊢ ∀ HI : INTEGER; LO, LO⋎0 : INTEGER; X : INTEGER
	    | (X ≥ 0 ∧ LO⋎0 = 0) ∧ LO ** 2 ≤ X ∧ X < HI ** 2
	    ⦁ LO ** 2 ≤ X ∧ X < HI ** 2
vc2_2_3_thm
	⊢ ∀ LO, LO⋎0 : INTEGER; X : INTEGER
	    | (X ≥ 0
	      ∧ LO⋎0 = 0)
	      ∧ LO ** 2 ≤ X
	      ∧ X < (LO + 1) ** 2
	    ⦁ LO ** 2 ≤ X ∧ X < (LO + 1) ** 2
vc2_3_1_thm
	⊢ ∀ HI : INTEGER; LO : INTEGER; X : INTEGER
	    | (LO ** 2 ≤ X ∧ X < HI ** 2) ∧ LO + 1 eq HI = TRUE
	    ⦁ LO ** 2 ≤ X ∧ X < (LO + 1) ** 2
vc2_3_2_thm
	⊢ ∀ HI : INTEGER; LO : INTEGER; X : INTEGER
	    | (LO ** 2 ≤ X
	      ∧ X < HI ** 2)
	      ∧ LO + 1 eq HI = FALSE
	    ⦁ LO ** 2 ≤ X ∧ X < HI ** 2
vc2_3_3_thm
	⊢ ∀ HI, HI⋎0 : INTEGER; LO, LO⋎0 : INTEGER; X : INTEGER
	    | (LO⋎0 ** 2 ≤ X
	      ∧ X < HI⋎0 ** 2)
	      ∧ LO ** 2 ≤ X
	      ∧ X < HI ** 2
	    ⦁ LO ** 2 ≤ X ∧ X < HI ** 2
=TEX
=THEORYLISTINGTRAILER
End of listing of theory usr501
=TEX
\chapter{EVALUATION GUIDELINES}\label{EVALUATIONGUIDELINES}
\section{Introduction}
The Compliance Notation gives considerable flexibility in the degree of formal rigour applied at each stage in the presentation of a compliance argument.
This chapter gives some guidelines for assessing a compliance argument.

\section{Scope of a Compliance Argument}

A compliance argument will contain one or more specification statements acting as the starting points of the formal argument.
These are the specification statements that give the top level statement of  critical properties of the code.

For a subprogram library, the formal starting points might comprise the specification statements for each of the subprograms in a suite of package specifications defining the external interface of the library.

For a complete application, the formal starting point might comprise a single specification statement appearing in the body of the main subprogram of the application.
The formal starting points will generally be explicitly identified as such in the narrative parts of the script.


\section{Conformance with the Ada Standard}

While the Compliance Tool detects many types of error, it does not detect all the types of error that an Ada implementation is required to detect during the compilation process.
A compliance argument is only valid if the Ada code it contains can be compiled without error using an Ada implementation that conforms either to the 1995 version of the standard~\cite{ISO95} or to the 1983 version~\cite{ISO83}.
Providing there are no compilation errors, the checks made by the tool ensure that the formally developed code is not sensitive to the difference between the two versions of the standard.

The predefined type {\em CHARACTER} was changed in the 1995 standard: the value {\em CHARACTER'LAST} was increased from 127 to 255.
The tool takes 127 as a lower bound on {\em CHARACTER'LAST}.
If the compliance argument includes an axiom that further constrains the value of {\em CHARACTER'LAST}, then the argument should include informal justification that the axiom is compatible with the intended Ada implementation.

\section{Formal Development Steps}

The formal argument for each starting point will comprise a chain, or tree, of formal steps each of which may produce one or more verification conditions (VCs).
Type definitions may also give rise to VCs.
The various sorts of VC that may be generated are described in detail in {\CNNOTATION}.
There are several sorts of formal development step:

\begin{itemize}
\item Explicit refinements: in these the refinement symbol (⊑) is used to assert that a sequence of statements correctly implements a specification statement.
\item
Implicit refinements: these occur when the semantics of the Compliance Notation require one specification statement to refine another (e.g., this happens when a formal subprogram in a package body is implemented: the specification statement of the formal subprogram in the package body must correctly implement the specification statement for the subprogram given in the package specification).
\item
Declaration replacements: these occur when a k-slot used as a declaration is expanded using the replacement symbol (≡).
\end{itemize}

A complete formal development comprises a sequence of steps of the above three sorts in which all specification statements have been refined to code.
Given such a complete formal development, the VC generation algorithm is designed so that truth of the VCs entails ``partial'' or ``algorithmic'' correctness of the implementation, i.e., so that truth of the VCs implies
that the code meets its specification providing it terminates and does not raise any exceptions.
Truth of the VCs does not of itself guarantee either that the code
terminates or that the code will not raise exceptions.

Note that the tool can only check the correctness of code that it has actually processed.
For example, the VC generation algorithm assumes that the subprograms in an external package meet their specifications in the package specification.
A formal development of the package body must be processed to ensure that this is the case.

\section{Informal Development Steps}

Other sorts of development step break the chain of formality.
These informal development steps are as follows:

\begin{itemize}
\item Arbitrary replacements: these are introduced by the
arbitrary replacement symbol (%
=INLINEFT
!≡
=TEX
) and enable a k-slot or refinement step to be expanded to an arbitrary fragment of Ada code in an unchecked fashion.
\item Statement replacements: these occur when a k-slot as a statement or specification statement as a statement is expanded using the statement replacement symbol (!⊑)
rather than the refinement symbol (⊑).
\end{itemize}

If either of these sorts of step occurs in a script then the VCs do not give a formal guarantee that the code is correct.
An informal justification of the correctness of the informal step must be provided and evaluated in this case.


\section{Consistency}

An inconcistent axiom allows any property to be proved.
{\Product} supports two modes of dealing with a Z axiomatic
description: in the conservative mode, the defining property
is replaced by a property which is guaranteed consistent and
is equivalent to the desired property if the latter is provably
consistent; in the axiomatic mode, the defining property is
asserted as an axiom.
If consistency is a concern, then {\Product} should be put into its conservative mode of working by setting the system flag
=INLINEFT
z_use_axioms
=TEX
\ to
=INLINEFT
false
=TEX
.
This may be done by:
=GFT
set_flag("z_use_axioms", false);
=TEX

This will ensure that all axiomatic descriptions include a consistency caveat.
Consistency proofs may then be carried out using the usual {\Product} mechanisms.


\section{Checking for Errors}

When an error is detected during loading of a script, the normal behaviour of the tool is to raise an exception and stop processing.
To check that a script has been processed without error, the output from loading the script can be examined.
Alternatively, the function {\it print\_exception\_log} can be used to print a log of all the errors and potential
soundness problems that have been detected in a script.
{\ProductML} exception handlers and certain control flags can be used to make the tool continue processing after an error has been detected.
There is also a flag {\it cn\_stop\_on\_exceptions} defined as part of the Compliance Tool that
may be used for this purpose (see section~\ref{COMMANDREF} below).
The script may be checked for occurrences of the $handle$ keyword or the $set\_flag$ command to see if error reporting has been suppressed inappropriately.
See {\DESCRIPTION} for a description of the {\Product} control flags.

Some errors are only detected when the Ada program is generated (see section~\ref{AdaProgram}).
Thus each script should include a command to generate the Ada program.
This command should come after all the Ada code in the script.
Errors detected during Ada program generation are logged even if the command is protected by a {\ProductML} exception handler.
In some cases, these errors may refer to informal parts of the Ada program and so may be considered acceptable.

The process of generating and reloading the Z document as described in section~\ref{ZDocument} is not intended to give rise to errors except in unusual circumstances.
However, it does provide an extra layer of checking (by passing all the generated Z through the Z
parser and type inferrer) and should increase confidence that the script has been processed correctly by the tool.
For example, it ensures that all the names of Z objects that have been generated conform to the lexical
rules for Z identifiers.

\section{Treatment of Real Types}
Ada floating point and fixed types are mapped by the Compliance Tool to the real numbers
of pure mathematics as represented in the Z theory of real numbers.
This is an idealisation and means outside the scope of the tool must be used
to justify the approximations inherent in the use of computer arithmetic when the
code is executed.

For fixed point types, the accuracy of the idealisation
is heavily dependent on careful use of the Ada features for controlling the accuracy
of the arithmetic. If used carefully, a fixed point type will represent a subset of the
mathematical real numbers with complete accuracy (e.g., by using a representation
clause, if necessary, to make ``small'' the precise value needed by the application
and by restricting operations to addition, subtraction and multiplication by integers).
On  the other hand, a fixed point type whose ``delta'' is specified as $2^n-1$ for
a large integer $n$ and which has no representation clause to define ``small'' will
give a particularly bad approximation.

For floating point types, the accuracy of the idealisation can be heavily dependent on the
compiler used if the Ada features for writing portable floating code are not used carefully.


\chapter{{\ProductML} COMPLIANCE TOOL REFERENCE}\label{COMMANDREF}
The following sections give reference documentation for the principal {\ProductML} commands which are specific to the Compliance Tool, followed by the theory listing of ``cn''.
Consult the {\Product} reference manual for further information on {\ProductML} commands mentioned in this document which are not mentioned here.

\section{Controlling the Tool}
\input{usr501E.tex}
\pagebreak
\section{Custom Proof Facilities}\label{CustomProofFacilities}
=IGN
dtd509
=TEX
\input{usr501F.tex}

=IGN
dtd518
=TEX
\input{usr501G.tex}

=IGN
dtd517
=TEX
\input{usr501H.tex}

{\let\Section\section
\def\section#1{\Section{#1}
For brevity, the global variables
{\it array\_agg6}, {\it array\_agg7}, \ldots, {\it array\_agg20}
have been suppressed from the theory listing.}
\input{cn.thl.tex}}

\chapter*{REFERENCES}\label{REFERENCES}
\addcontentsline{toc}{chapter}{REFERENCES}

\bibliographystyle{fmu}
{\raggedright
\bibliography{fmu,daz}}

\pagebreak
\twocolumn
\chapter*{INDEX}
\addcontentsline{toc}{chapter}{INDEX}
\small

\printindex

\end{document}


