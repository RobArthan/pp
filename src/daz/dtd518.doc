%  dtd518.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999

\def\DRASpecs{\cite{DRA/CIS/CSE3/TR/94/27/2.1}}
\def\Volume#1{\cite[volume #1]{DRA/CIS/CSE3/TR/94/27/2.1}\/}
\def\VolumeOne{\Volume 1}
\def\VolumeTwo{\Volume 2}
\def\VolumeThree{\Volume 3}

\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Detailed Design: Compliance Notation Tactics Etc.}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/DTD518}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
%\TPPstatus{Approved}
\TPPstatus{Draft}
\TPPtype{Specification}
%\TPPkeywords{SPARK}
\TPPauthors{R.D.~Arthan&WIN01}
\TPPauthorisation{R.D.~Arthan & Manager HAT}
\TPPabstract{
This document defines custom tactics and other proof procedures for use with the Compliance Tool.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	A.~Smith, DRA \\
	Library}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}
\item[Issue 1.1-1.9] Initial Drafts.
\item[Issue 1.10] Changed from $cn\_hc\_tac$ to $cn\_\_type\_tac$.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document responds to a requirement for custom tactics, rules etc. to assist in proving the VCs generated by the Compliance Tool Z. 
\subsection{Introduction}

\subsubsection{Purpose and Background}
See \cite{ISS/HAT/DAZ/MIN009}.
\subsubsection{Organisation}
The document has three sections as follows:
\begin{description}
\item[Section \ref{HT}] contains supporting material that could become part of the {\ProductHOL} system;
This currently comprises the raw material for a Horn clause theorem prover using the SLD-resolution algorithm.

\item[Section \ref{ZT}] contains supporting material that could become part of the {\ProductZ} system;
This currently comprises a couple of rules supporting the use of the Horn clause theorem prover in the Z context.

\item[Section \ref{CNT}] contains supporting material which is specific to the Compliance Tool.
\end{description}

=TEX
\pagebreak
\section{HOL TACTICS}\label{HT}
=DOC
signature ÛCNHOLTacticsÝ = sig
=DESCRIBE
This is the name of a metalanguage structure containing supporting functions for the tactics etc. supporting proof of the VCs generated by the Compliance Tool.
=ENDDOC
=DOC
val Ûhc_ruleÝ :	bool -> int -> (TERM list -> TERM) -> TERM list ->
			(TERM -> THM list) list -> THM list ->
			TERM -> THM;
=DESCRIBE
$hc\_rule$ is a Horn clause theorem prover. A call of $hc\_rule$, such as:
=GFT
	hc_rule diag limit sel hyps rules facts ¬t®
=TEX
either fails or returns a theorem
=INLINEFT
‡ ô t
=TEX
\ where the assumptions $\Gamma$ are a subset of the terms in the list $hyps$.
The theorem is found by a backwards search using implicative facts (the Horn clauses) given by the $facts$ and $rules$ parameters in an attempt to eliminate the assumption of the theorem
=INLINEFT
t ô t
=TEX
.
This search is carried out using the so-called SLD-resolution or pure-prolog algorithm.
This algorithm works by processing a set of theorems of the form
=INLINEFT
‡ ô t
=TEX
; on each pass of the algorithm, each theorem in the set is examined in turn and the information provided in the paramters to $hc\_rule$ is used in an attempt to eliminate an assumption of the theorem. 
In more detail the parameters of $hc\_rule$ are as follows:

\begin{centering}
\begin{tabular}{|l|p{5.5in}|}\hline
$diag$ & if this is set $true$, a diagnostic trace of the resolution process is produced.
\\\hline
$limit$ & this gives an upper bound on the number of iterations of the resolution process to be attempted; the rule will abandon processing if the resolution process has not terminated after $limit$ iterations.
\\\hline
$sel$ & this function is used to select the next candidate assumption for elimination.
It must return some member of the (non-empty) list of terms passed as its parameter.
$hd$ is an adequate choice for $sel$ in simple applications.
\\\hline
$hyps$ & the resolution process terminates successfully when a theorem of the form
=INLINEFT
‡ ô t
=TEX
\ has been found, all of whose assumptions, ‡, are contained (up to $\alpha$-convertibility) in the list $hyps$.
\\\hline
$rules$ & The $rules$ are used to provide information which is too general too express using theorems.
Each rule, when given an parameter $p$ say, should either fail or return a list of theorems of the form:
=INLINEFT
R‰1, ..., R‰m ô p'
=TEX
, where $p$ and $p'$ are unifiable.
Each theorem in the list is used to eliminate an assumption in much the same way as a theorem obtained from $facts$ by unification (see below).
\\\hline
$facts$ & The $facts$ have the general form:
=INLINEFT
µx‰1 .. x‰k· R‰1 ± ... ± R‰m ´ R
=TEX
, where either $k$ or $m$ or both may be $0$.
The resolution process works by attempting to unify the succedents $R$ of these theorems with the assumption $p$, say, in a theorem of the form
=INLINEFT
p, „ ô t
=TEX
. If the unification succeeds, the latter theorem is replaced by:
=INLINEFT
R'‰1, ..., R'‰m, „' ô t
=TEX
\ where the primes denote the result of carrying out the (type and term) substitution indicated by unification.
\\\hline
=INLINEFT
¬t®
=TEX
 & is the conclusion of the theorem to be proved.
\\\hline
\end{tabular}
\end{centering}

If either of the two possible failures listed below propagates to the top level, and if $diag$ is $false$, then the results of the last successful resolution pass are printed. (If $diag$ is $true$, these results will have already been printed out.)

=FAILURE
518001	Iteration limit (?0) exceeded trying to prove ?1
518002	Could not prove ?0 using Horn clause algorithm
=ENDDOC
=DOC
	val Ûhc_±_ruleÝ			: TERM -> THM list;
	val Ûhc_²_ruleÝ 		: TERM -> THM list;
	val Ûhc_¶_ruleÝ 		: TERM -> THM list;
	val Ûconv_then_hc_ruleÝ	: CONV -> (TERM -> THM list) ->
					  (TERM -> THM list);
	val Ûhc_rule_of_convÝ		: CONV -> (TERM -> THM list);
	val Ûhc_canonÝ 		: (THM -> THM list);
=DESCRIBE
These functions are intended to assist a tactic programmer in constructing the parameters required by $hc\_rule$ and $basic\_hc\_tac$, q.v.

=INLINEFT
hc_±_rule
=TEX
,
=INLINEFT
hc_²_rule
=TEX
\ and
=INLINEFT
hc_¶_rule
=TEX
\ are for use in the $rules$ parameter:

=FRULE 1 Rule
hc_±_rule ¬t1 ± t2®
÷
÷
t1, t2 ô t1 ± t2
=TEX

=FRULE 1 Rule
hc_²_rule ¬t1 ² t2®
÷
÷
t1 ô t1 ² t2 ; t2 ô t1 ² t2
=TEX
=FRULE 1 Rule
hc_¶_rule ¬¶x· t2®
÷
÷
t2 ô ¶x· t2
=TEX

$conv\_then\_hc\_rule$ and $hc\_rule\_of\_conv$ are also for use in constructing the $rules$ parameter.
$conv\_then\_hc\_rule\,conv\,rule$ is a rule which attempts to apply $conv$ to transform its parameter before applying $rule$ to the result.
$hc\_rule\_of\_conv\,conv$ is a rule which, given a term $t$ such that
=INLINEFT
conv¬t®
=TEX
\ is
=INLINEFT
ô t = t'
=TEX
, returns a list containing the single theorem
=INLINEFT
t' ô t
=TEX
.

$hc\_canon$ is for use in constructing the $thms$ parameter.
It performs the same canonicalisation as $fc\_canon1$, q.v., with the following two exceptions:
\begin{enumerate}
\item
The subterms of the form
=INLINEFT
³p ´ F
=TEX
\ introduced by $fc\_canon1$
are transformed into
=INLINEFT
p
=TEX
.
\item
Where $fc\_canon1\,th$ would return an empty list, $hc\_canon\,th$ will return the list $[th]$ (to serve as a ground clause in the Horn clause theorem prover).
\end{enumerate}

=ENDDOC
=DOC
	val Ûbasic_hc_tacÝ :	bool -> int -> (TERM list -> TERM) ->
				(THM -> THM list) -> 
				(TERM -> THM list) list ->THM list -> 
				TACTIC;
	val Ûhc_tacÝ : 		THM list -> TACTIC;
=DESCRIBE
$basic\_hc\_tac$ is a tactic based on the Horn clause prover $hc\_rule$.
In a typical call:
=GFT
		basic_hc_tac diag limit sel can rules thms
=TEX
the parameters $diag$, $limit$, $sel$, and $rules$ and are exactly as for $hc\_rule$, q.v.
The $facts$ parameter for $hc\_rule$ is computed by using the canonicalisation function $can$ to derive theorems from the assumptions of the goal and from  $thms$.
The $hyps$ parameter for $hc\_rule$ is the list of assumptions of the goal.
$hc\_rule$ is used with these parameter values in an attempt to prove the conclusion of the goal.

$hc\_tac$ is like $basic\_hc\_tac$ but using default values for all parameters but $thms$.
The defaults are to take $diag = false$, $sel = hd$ and $limit = 100$, and to derive $can$ and $rules$ using $hc\_canon$, q.v., and the current proof context.

=ENDDOC
=SML
end (* of signature CNHOLTactics *);
=TEX
\section{Z TACTICS}\label{ZT}
=DOC
signature ÛCNZTacticsÝ = sig
=DESCRIBE
This is the name of a metalanguage structure containing supporting functions for the tactics etc. supporting proof of the VCs generated by the Compliance Tool.
=ENDDOC
=DOC
	val Ûz_sel‰s__ruleÝ : TERM -> THM;
	val Ûz_sel‰t__ruleÝ : TERM -> THM;
	val Ûz_app__ruleÝ : TERM -> THM;
=DESCRIBE
These rules are primarily intended for use by a tactic programmer constructing parameters for use with $hc\_rule$ and $basic\_hc\_tac$.

=FRULE 1 Rule
z_sel‰s__rule ¬b.s‰i  A®
÷
÷
b  [s‰1 : V‰1 ; ...; s‰i : A ; ...; s‰k : V‰k ]
ô b.s‰i  A
=TEX
=FRULE 1 Rule
z_sel‰s__rule ¬t.s‰i  A®
÷
÷
t  (V‰1 ¸ ... ¸ A ¸ ... V‰k)] ô t.i  A
=TEX
=FRULE 1 Rule
z_app__rule ¬f t  A®
÷
÷
f  V‰1 ­ A, t  V‰1 ô f t  A
=TEX

Here $b$, $t$ and $f$ must have the type of a binding, a tuple and a function respectively.
The $V_i$ are variables with names which do not clash with the free variable of the parameter term.


=ENDDOC

=SML
end (* of signature CNZTactics *);
=TEX
\section{COMPLIANCE NOTATION TACTICS}\label{CNT}
\subsection{Preamble}
=DOC
signature ÛCNTacticsÝ = sig
=DESCRIBE
This is the name of a metalanguage structure containing tactics etc. supporting proof of the VCs generated by the Compliance Tool.
=ENDDOC
\subsection{Propositional Simplification Etc.}
=DOC
val Ûcn_vc_simp_tacÝ : THM list -> TACTIC;
=DESCRIBE
This tactic performs simplifications which are often appropriate at the beginning of the proof of a VC goal generated by the Compliance Tool.
It should generally be used in the proof context $cn$ or $cn1$ or in some proof context incorporating one of these.
It attempts to carry out the following steps (and fails if none of them succeeds in changing the goal):

\begin{enumerate}
\item
Rewrite the conclusion of the goal with: the theorems supplied in the parameter (if any); the rewriting rules built into the current proof context; and, $z\_plus\_assoc\_thm$ and $z\_times\_assoc\_thm$.
\item
Remove any outer universal quantifiers (using $z\_µ\_tac$), typically leaving an implication whose operands are conjunctions.
\item
Remove any redundant conjuncts from the result of step 2.
At this stage, the goal will be proved automatically if the antecedents of the implication subsume the succedents.
\end{enumerate}

For example, using the proof context $cn1$, $cn\_vc\_simp\_tac$, will transform the goal:

=GFT
?ô	µ	x : INTEGER; y : INTEGER; z : INTEGER
	|	(x + y) + 1 eq z = TRUE ± (x ¾ 0 ± y ¾ 0) ± x ¾ 0
	·	x ¾ 0 ± z greater_eq 0 = TRUE
=TEX
into:
=GFT
?ô		x  INTEGER ± y  INTEGER ± z  INTEGER
	±	x + y + 1 = z ± 0 ¼ x ± 0 ¼ y
	´	0 ¼ z	
=TEX
=FAILURE
518003	Could not simplify the goal ?0
=ENDDOC
\subsection{Tools for Building Proof Contexts}
=DOC
	val Ûcurrent_pc_z__netÝ :	unit -> (TERM -> THM) NET
	val Ûset_pc_z__rulesÝ :	(TERM * (TERM -> THM)) list ->
					string -> unit;
	val Ûget_pc_z__rulesÝ :	string ->
					((TERM * (TERM -> THM)) list * string) list;
	val Ûpc_z__rules_of_thmsÝ :	string list ->
					THM list -> (TERM * (TERM -> THM)) list;

=DESCRIBE
These are tools used to construct proof contexts for use in conjunction
with the tactic $cn\_hc_tac$.
=ENDDOC
\subsection{Type-Membership Prover}
=DOC
	val Ûcn__type_tacÝ : THM list -> TACTIC
=DESCRIBE
This is a tactic based on $hc\_tac$ intended for proving assertions of the form
$x \in T$ where $T$ is the representation in Z of a Compliance Notation type.
=ENDDOC
=SML
end (* end of signature CNTactics *);
=TEX
=TEX
\section{TEST POLICY}

The module tests for this module are to follow the guidelines
identified in the quality plan~\cite{ISS/HAT/DAZ/PLN003}.
There are no special testing considerations.

\small
\twocolumn[\section{INDEX}]
\printindex

\end{document}



