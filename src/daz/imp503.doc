% imp503.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Compliance Notation Parser}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP503}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the CN 
parser.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue \SCCSversion, \FormatDate{$Date$%
} ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the parser for
HOL/Z.
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD503}.
\subsection{Introduction}

\subsection{Purpose and Background}

\subsection{Algorithms}



\subsection{Dependencies}

\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX
\section{MISCELLANEOUS FUNCTIONS}\label{MISCELLANEOUSFUNCTIONS}
=SML
structure ÛCNParserÝ = struct
=TEX
We need to include the SLRP driver code at this point:
=INCLUDE
imp018.sml
=TEX
=SML
open CNTypes;
open SlrpDriver;
=TEX
\subsection{Miscellanea}
$stack\_error$ is for use during context-free parsing when the parsing stack
is corrupt.
=SML
fun Ûstack_errorÝ (insert : string) : 'a = (
	diag_string(get_error_message 503202 []);
	BasicError.error "CN-Parser"  503203 [fn() => insert]
);
=TEX
To give error reports which are closely related to the actual input,
the following two variables are set up by the functions
$HOL\_parser$ and $HOL\_reader$. At any time during parsing $input\_toks$
can be expected to contain the totality of the token stream being parsed
and $toks\_read$ contains the offset in it of the token most recently
read (or is =INLINEFT
~1
=TEX
\ if nothing has been read yet).
=SML
val input_toks : CN_LEX_ITEM list ref = ref [];
val cur_tok : int ref = ref ~1;
=TEX
=SML
fun Ûformat_lex_itemÝ  ((_, tok) : CN_LEX_ITEM) : string = (
	case tok of
		CNZ _	=> " <z> "
	|	CNText s	=> s
	|	CNString s	=> s
	|	CNKSlot s	=> "K-Slot"
	|	CNEos		=> "<end-of-input>"
);
=TEX

=SML
fun Ûformat_input_itemsÝ  ((ip::rest) : Lex.INPUT list) : string = (
let	val s = (case ip of
		Lex.Char c	=> "`"^c^"`"
	|	Lex.Error s	=> "ERROR__"^(string_of_int s)
	|	Lex.Separator s	=> s
	|	Lex.String s	=> "\""^s^"\""
	|	Lex.Term t	=> string_of_term t
	|	Lex.Text s	=> s
	|	Lex.Type t	=> string_of_type t
	);
in
	s^(format_input_items rest)
end
) | format_input_items _ = "";
=TEX
=SML
fun Ûparse_error_hdrÝ () : unit = (
	let	val ok_toks =	format_list
				format_lex_item 
				((!input_toks) to (!cur_tok-1))
				" ";
		val bad_tok =	if !cur_tok >= 0 andalso !cur_tok < length (!input_toks)
				then " <?> " ^ format_lex_item (nth (!cur_tok) (!input_toks))
				else "";
	in	diag_string (get_error_message 19001 [ok_toks ^ bad_tok])
	end
);
=TEX
The following function produces the error reports for the unexpected
token type of error:
=TEX
=SML
fun Ûparse_errorÝ (msg : int) (insert : string) : 'a = (
	parse_error_hdr();
	diag_string (get_error_message msg [insert]);
	raise SYNTAX_ERROR
);
=TEX
\subsection{Support for Processing Z Fragments}
=SML
local
	open ZLex ZParser ZTypeInference ZTermGenerator ZUserInterfaceSupport;
=TEX
=SML
fun Ûz_para_of_zinferredÝ ((ZInferred p) : Z_INFERRED) : Z_PARA = (
	p
) | z_para_of_zinferred (ZTypeError inf) = (
	print_z_error inf
);
=TEX
=SML
fun Ûterm_of_z_paraÝ ((ZParaTerm (gpars, tm, _)) : Z_PARA) : TERM = (
let	val vns = map string_of_ident gpars;
	val vs = map (fn vn => mk_var(vn, mk_z_power_type(mk_vartype ("'" ^ vn)))) 
			vns;
in	list_mk_µ(vs, (do_in_theory (force_get_cache_theory()) term_of_z_tm tm))
end
) | term_of_z_para _ = (
	fail "z_term_recogniser" 49001 []
);
=TEX
=SML
fun Ûz_term_of_z_tokensÝ (tokens : Z_TOKEN list) : TERM = (
let
	val standard = get_flag "standard_z_terms";
	val parsed = z_parser {is_quot = true} tokens;
	val side = case parsed of
		ZParaTerm _ => ()
		|_ => fail "z_term_recogniser" 49001 [];
	val type_checked = type_check_z_para
				{standard = standard, allow_frees = true} parsed;
	val para = z_para_of_zinferred type_checked;
in	term_of_z_para para
end);
=TEX
=SML
in
=TEX
=SML
fun Ûprocess_con_declÝ (ztokens : ZLex.Z_TOKEN list) : (string * TERM) = (
let	val schtoks = ZTLsqbrack::((rev o tl o rev) ztokens)@[ZTRsqbrack, ZTEos];
	val zterm = z_term_of_z_tokens schtoks;
	val dec = (
		case (dest_z_decl o fst o dest_z_h_schema) zterm of
		[dec] => (case dest_z_dec dec of
			([c], ty) => (
				(((fn (n,_,_) => n) o dest_z_lvar) c, ty)
			) |_ => (
				parse_error 503001 "only one logical constant can be introduced in a logical constant statement"
			)
		) |_ => parse_error 503001 "only one logical constant can be introduced in a logical constant statement"
	);
in
	dec
end);
=TEX
=SML
fun Ûprocess_frameÝ ([] : ZLex.Z_TOKEN list) : ID list = []
  | process_frame [ZTEos] = []
  | process_frame ztokens = (
let	val tuptoks = ZTLbrack::((rev o tl o rev) ztokens)@[ZTRbrack, ZTEos];
	val zterm = z_term_of_z_tokens tuptoks;
	val ids =
		case dest_z_term zterm of
		ZTuple ids => map (fst o dest_var) ids
		|_ => [(fst o dest_var) zterm];
in
	ids
end);
=TEX
=SML
val Ûprocess_pre_conditionÝ : ZLex.Z_TOKEN list -> TERM = z_term_of_z_tokens;
=TEX
=SML
fun Ûprocess_pre_and_post_conditionsÝ (ztokens : ZLex.Z_TOKEN list) : TERM OPT * TERM = (
let	val genitoks = ZTLsqbrack::((rev o tl o rev) ztokens)@[ZTRsqbrack, ZTEos];
	val zpara = ZParserInternals.z_parser_pass_1 genitoks;
	fun apply_pi p = (
		case p of
		ParGeneralTerm (PredGenInst [pp], Nil) => (
			(Nil, ParGeneralTerm (
			PredFancyFix(TmplPre (("", Nil), StubUS), "", [[pp]]),
			Nil))
		) |ParGeneralTerm (PredGenInst [p1,p2], Nil) => (
			(Value (ParGeneralTerm (
			PredFancyFix(TmplPre (("", Nil), StubUS), "", [[p1]]),
			Nil)),
			ParGeneralTerm (
			PredFancyFix(TmplPre (("", Nil), StubUS), "", [[p2]]),
			Nil))
		) |_ => parse_error 503001 "unexpected input after the post-condition"
	);
	val (pretm_opt, posttm) = apply_pi zpara;
	val standard = get_flag "standard_z_terms";
	fun aux parsed = (
	let	val pp = ZParserInternals.z_parser_pass_2 {is_quot = true} parsed;
		val type_checked = type_check_z_para
				{standard = standard, allow_frees = true} pp;
		val tzp = (case type_checked of
				ZInferred p => p
				|ZTypeError inf => print_z_error inf
			);
	in
		term_of_z_para tzp
	end);
in
	case pretm_opt of
	Value pre => (Value (aux pre), aux posttm)
	|Nil => (Nil, aux posttm)
end);

val Ûprocess_aux_expÝ : ZLex.Z_TOKEN list -> TERM = z_term_of_z_tokens;
=TEX
=SML
end (* local...in *);
=TEX

=SML
end (* of structure *);
=TEX

\section{REDUCTION FUNCTIONS}\label{REDUCTIONFUNCTIONS}
=SML
structure ÛCNParserÝ = struct
=TEX
=SML
open CaseIndependence CNParser;
=TEX
We give the reduction functions in the order of their appearance
in the grammar of \cite{ISS/HAT/DAZ/DTD503}. When several reduction
functions would be the same, we use $val$ bindings for the various
instances.

=SML
type AGG = {tm : TMARK OPT, named_assocs : (AGG_CHOICE,EXP) NAMED_ASSOC list, others : EXP OPT};
	
datatype ÛPPARSEDÝ =
			PPAgg of AGG
		|	PPAggregateChoices of (AGG_CHOICE list * bool)
		|	PPBasicDecls of BASIC_DECL list
		|	PPBinaryOp of BIN_OP
		|	PPBinOpTail of (BIN_OP * EXP) list
		|	PPCaseAlternatives of STMT CASE_ALTERNATIVE list
		|	PPCaseChoices of CASE_CHOICE list
		|	PPCompilationUnit of (ID list * COMPILATION_UNIT)
		|	PPComponentClauses of COMPONENT_CLAUSE list
		|	PPComponents of COMPONENT list
		|	PPConstraint of CONSTRAINT
		|	PPDeclarations of DECLARATION list
		|	PPDiscriminantPart of VAR_DECL
		|	PPDiscreteRange of DISCRETE_RANGE
		|	PPElsIf of (EXP * STMT) list
		|	PPExp of EXP
		|	PPExps of EXP list
		|	PPFor of (ID * ID * LOOP_DIRECTION * EXP RANGE OPT)
		|	PPFormals of PARAMETER_SPECIFICATION list
		|	PPFunctionSpecification of FUNCTION_SPECIFICATION
		|	PPId of ID
		|	PPIdExp of (ID * EXP)
		|	PPIds of ID list
		|	PPKSlot of K_SLOT
		|	PPKSlotCUList of KSLOT_COMPILATION_UNIT list
		|	PPLogCon of LOG_CON
		|	PPMode of MODE
		|	PPPackageSpecification of DECLARATION PACKAGE_DECLARATION
		|	PPPrimedIdentifier of (ID * ID)
		|	PPProcedureSpecification of PROCEDURE_SPECIFICATION
		|	PPProperBody of PROPER_BODY
		|	PPReltail of (BIN_OP * EXP)
		|	PPRepresentationClause of REPRESENTATION_CLAUSE
		|	PPSRExpression of (EXP * EXP OPT)
		|	PPStmt of STMT
		|	PPStatement of STATEMENT
		|	PPSubprogram of (DECLARATION list * STATEMENT * ID)
		|	PPSubprogramSpec of SUBPROGRAM_SPECIFICATION
		|	PPSubtypeDeclaration of (EXP * CONSTRAINT)
		|	PPTypeDef of TYPE_DEF
		|	PPUnaryOp of UNARY_OP
		|	PPVarDecls of VAR_DECL list
		|	PPVariants of COMPONENT VARIANT list
		|	PPVariantPart of COMPONENT VARIANT_PART
		|	PPWebClause of WEB_CLAUSE;
=TEX
=SML
fun format_label (n : string) = (
	"("^n^")"
);

fun different_ids (id1 : ID, id2 : ID) : bool = (
	not (to_upper id1 = to_upper id2)
);

fun name_to_tmark (e : EXP) : TMARK = (
	case e of
	EId id =>
		id
	|EInt n =>
		n
	|ESelectedComp {prefix=p, selector=s} =>
		(name_to_tmark p)^"."^s
	|EIndexedComp {prefix=p, index=i} =>
		(name_to_tmark p)^"("^(name_to_tmark i)^")"
	|EAttribute {prefix=p, attribute_desig=ad} =>
		(name_to_tmark p)^"'"^
		(
			case ad of
			ADAttrib a => a
			|ADAttribArg (a, e) => a^"("^(name_to_tmark e)^")"
		)
	|_ => "__unknown"
);

fun sr_expression_to_range ((e,v) : (EXP * EXP OPT)) : EXP RANGE = (
	{lo=e, hi=v}
);

fun sr_expression_to_expression ((e1, Nil) : (EXP * EXP OPT)) : EXP = (e1
) | sr_expression_to_expression _ = (
	parse_error 503001 "a RANGE is not permitted here"
);
=TEX
=SML
fun Ûstatement_to_stmtÝ (st : STATEMENT) : STMT = (
	case st of
	SStmt s => s
	|SLogCon _ => parse_error 503001
		"a logical constant cannot appear here"
	|_ => stack_error "statement_to_stmt"
);
=TEX
=SML
fun red_accept (Parsed pp) = (pp
) | red_accept (Token ((l,CNText t),_)) = (
	stack_error ("red_accept [Token("
		^(PolyML.makestring l)^", Text "^(PolyML.makestring t)^")]")
) | red_accept (Token ((l,t),_)) = (
	stack_error ("red_accept ["
		^(PolyML.makestring l)^", "^(PolyML.makestring t)^"]")
);
=TEX
=SML
fun red_web_clause1 (Parsed (PPKSlotCUList cul)) = (
	PPWebClause (WCCompilation cul)
) | red_web_clause1 _ = stack_error "red_web_clause1";

fun red_web_clause2 (Token ((_, CNText lab), _)) _ (Parsed (PPKSlotCUList cul)) = (
	PPWebClause (WCReplacedByCompilation {label=LExplicit lab,comp=cul})
) | red_web_clause2 _ _ _ = stack_error "red_web_clause2";

fun red_web_clause3 (Token ((_,CNText lab), _)) _ (Parsed (PPDeclarations d)) = (
	PPWebClause (WCReplacedByPrivatePart {label=LExplicit lab, private=d})
) | red_web_clause3 _ _ _ = stack_error "red_web_clause3";

fun red_web_clause4 (Token ((_,CNText lab), _)) _ (Parsed (PPDeclarations d)) = (
	PPWebClause (WCReplacedByVisiblePart {label=LExplicit lab, visible=d})
) | red_web_clause4 _ _ _ = stack_error "red_web_clause4";

fun red_web_clause5 (Token ((_,CNText lab), _)) _ (Parsed (PPDeclarations d)) = (
	PPWebClause (WCReplacedByDecl {label=LExplicit lab, decls=d})
) | red_web_clause5 _ _ _ = stack_error "red_web_clause5";

fun red_web_clause6 (Token ((_,CNText lab), _)) _ (Parsed (PPStatement s)) = (
	PPWebClause (WCReplacedBy {label=LExplicit lab, statement=s})
) | red_web_clause6 _ _ _ = stack_error "red_web_clause6";

fun red_web_clause7 (Token ((_,CNText lab), _)) _ (Parsed (PPStatement s)) = (
	PPWebClause (WCRefinedBy {label=LExplicit lab, statement=s})
) | red_web_clause7 _ _ _ = stack_error "red_web_clause7";

fun red_web_clause8 _ (Parsed (PPStatement s)) = (
	PPWebClause (WCRefinedBy {label=LImplicit, statement=s})
) | red_web_clause8 _ _ = stack_error "red_web_clause8";

fun red_web_clause9 (Token ((_,CNText lab), _)) _ (Parsed (PPStatement s)) = (
	PPWebClause (WCReplacedBy {label=LExplicit lab, statement=s})
) | red_web_clause9 _ _ _ = stack_error "red_web_clause9";

fun red_web_clause10  _ (Parsed (PPStatement s)) = (
	PPWebClause (WCReplacedBy {label=LImplicit, statement=s})
) | red_web_clause10 _ _ = stack_error "red_web_clause10";
=TEX
=SML
val red_basic_declaration1 = red_accept;
val red_basic_declaration2 = red_accept;
val red_basic_declaration3 = red_accept;
val red_basic_declaration4 = red_accept;
val red_object_declaration1 = red_accept;
val red_object_declaration2 = red_accept;
=TEX
=SML
fun red_constant_declaration (Parsed(PPIds ids)) _ _ (Parsed(PPExp n)) _ (Parsed(PPExp e)) _ = (
	PPBasicDecls[BDConstDecl{consts=ids, tm=name_to_tmark n, expr=e}]
) | red_constant_declaration _ _ _ _ _ _ _ = stack_error "red_constant_declaration";

fun red_variable_declaration (Parsed(PPIds ids)) _ (Parsed(PPExp n)) _ = (
	PPBasicDecls[BDVarDecl{vars=ids, tmark=name_to_tmark n}]
) | red_variable_declaration _ _ _ _ = stack_error "red_variable_declaration";

fun red_identifier_list1 (Token ((_,CNText id), _)) = (
	PPIds [id]
) | red_identifier_list1 _ = stack_error "red_identifier_list1";

fun red_identifier_list2 (Token ((_,CNText id), _)) _ (Parsed(PPIds ids)) = (
	PPIds (id::ids)
) | red_identifier_list2 _ _ _ = stack_error "red_identifier_list2";
=TEX
=SML
val red_type_declaration1 = red_accept;
val red_type_declaration2 = red_accept;
=TEX
=SML
fun red_full_type_declaration1 _ (Token ((_,CNText id), _)) (Parsed(PPDiscriminantPart d)) _ (Parsed(PPTypeDef td)) _ = (
	PPBasicDecls[BDTypeDecl{name=id,discr=Value d, type_def=td}]
) | red_full_type_declaration1 _ _ _ _ _ _ = stack_error "red_full_type_declaration1";

fun red_full_type_declaration2 _ (Token ((_,CNText id), _)) _ (Parsed(PPTypeDef td)) _ = (
	PPBasicDecls[BDTypeDecl{name=id,discr=Nil, type_def=td}]
) | red_full_type_declaration2 _ _ _ _ _ = stack_error "red_full_type_declaration2";

=TEX
=SML
val red_type_definition1 = red_accept;
val red_type_definition2 = red_accept;
val red_type_definition3 = red_accept;
val red_type_definition4 = red_accept;
val red_type_definition5 = red_accept;
=TEX
=SML
fun red_subtype_declaration _ (Token ((_,CNText id), _)) _ (Parsed(PPSubtypeDeclaration (n, c))) _ = (
	PPBasicDecls[BDSubtypeDecl{name=id,sub_ind={tmark=name_to_tmark n,con=c}}]
) | red_subtype_declaration _ _ _ _ _ = stack_error "red_subtype_declaration";

fun red_subtype_indication (Parsed(PPExp n)) (Parsed(PPConstraint c)) = (
		PPSubtypeDeclaration(n, c)
) | red_subtype_indication _ _ = stack_error "red_subtype_indication";
=TEX
=SML
fun red_constraint1 (Parsed(PPSRExpression (e,v))) = (
	PPConstraint (CRange {lo=e, hi=v})
) | red_constraint1 _ = stack_error "red_constraint1";

val red_constraint2 = red_accept;
val red_constraint3 = red_accept;
=TEX
=SML
fun red_range_constraint _ (Parsed sr) = (
	sr
) | red_range_constraint _ _ = stack_error "red_range_constraint";

fun red_enumeration_type_definition _ (Parsed(PPIds ids)) _ = (
	PPTypeDef(TDEnumTypeDef{vals = ids})
) | red_enumeration_type_definition _ _ _ = stack_error "red_enumeration_type_definition";
=TEX
=SML
fun red_integer_type_definition (Parsed(PPSRExpression sr)) = (
	PPTypeDef(TDIntTypeDef (sr_expression_to_range sr))
) | red_integer_type_definition _ = stack_error "red_integer_type_definition";

fun red_real_type_definition1 (Parsed(PPConstraint(CFloating c))) = (
	PPTypeDef(TDFloatingTypeDef c)
) | red_real_type_definition1 _ = stack_error "red_real_type_definition1";

fun red_real_type_definition2 (Parsed(PPConstraint (CFixed c))) = (
	PPTypeDef(TDFixedTypeDef c)
) | red_real_type_definition2 _ = stack_error "red_real_type_definition2";
=TEX

SPARK manual 3.5.7:
=SML
fun red_floating_point_constraint1 (Parsed(PPExp e)) = (
	PPConstraint(CFloating{exp=e, range=Nil})
) | red_floating_point_constraint1 _ = stack_error "red_floating_point_constraint1";

fun red_floating_point_constraint2 (Parsed(PPExp e)) (Parsed(PPSRExpression sr)) = (
	PPConstraint(CFloating{exp=e, range=Value (sr_expression_to_range sr)})
) | red_floating_point_constraint2 _ _ = stack_error "red_floating_point_constraint2";

fun red_floating_accuracy_definition _ (Parsed p) = (p
) | red_floating_accuracy_definition _ _ = stack_error "red_floating_accuracy_definition";
=TEX
=SML
fun red_fixed_point_constraint1 (Parsed(PPExp e)) = (
	PPConstraint(CFixed{exp=e, range=Nil})
) | red_fixed_point_constraint1 _ = stack_error "red_fixed_point_constraint1";

fun red_fixed_point_constraint2 (Parsed(PPExp e)) (Parsed(PPSRExpression sr)) = (
		PPConstraint(CFixed{exp=e, range=Value (sr_expression_to_range sr)})
) | red_fixed_point_constraint2 _ _ = stack_error "red_fixed_point_constraint2";

fun red_fixed_accuracy_definition _ (Parsed p) = (p
) | red_fixed_accuracy_definition _ _ = stack_error "red_fixed_accuracy_definition";
=TEX
=SML
val red_array_type_definition1 = red_accept;
val red_array_type_definition2 = red_accept;
=TEX
=SML
fun red_unconstrained_array_definition _ _ (Parsed(PPExps nl)) _ _ (Parsed(PPExp n)) = (
	PPTypeDef(TDUnconArrayDef{index=map name_to_tmark nl,comp=name_to_tmark n})
) | red_unconstrained_array_definition _ _ _ _ _ _ = stack_error "red_unconstrained_array_definition";

fun red_constrained_array_definition _ (Parsed(PPExps nl)) _ (Parsed(PPExp n)) = (
	PPTypeDef(TDConArrayDef{index=map name_to_tmark nl,comp=name_to_tmark n})
) | red_constrained_array_definition _ _ _ _ = stack_error "red_constrained_array_definition";
=TEX
=SML
fun red_index_subtype_definition_list1 (Parsed(PPExp n)) = (
	PPExps [n]
) | red_index_subtype_definition_list1 _ = stack_error "red_index_subtype_definition_list1";
=TEX
=SML
fun red_index_subtype_definition_list2 (Parsed(PPExp n)) _ (Parsed(PPExps nl)) = (
	PPExps (n::nl)
) | red_index_subtype_definition_list2 _ _ _ = stack_error "red_index_subtype_definition_list2";

fun red_index_subtype_definition (Parsed p) _ _ = (
	p
) | red_index_subtype_definition _ _ _ = stack_error "red_index_subtype_definition";
fun red_index_constraint _ (Parsed p) _ = (
	p
) | red_index_constraint _ _ _ = stack_error "red_index_constraint";

fun red_name_list1 (Parsed(PPExp n)) = (
	PPExps [n]
) | red_name_list1 _ = stack_error "red_name_list1";

fun red_name_list2 (Parsed(PPExp n)) _ (Parsed(PPExps nl)) = (
	PPExps (n::nl)
) | red_name_list2 _ _ _ = stack_error "red_name_list2";
=TEX
=SML
fun red_discrete_range1 (Parsed (PPExp e)) (Parsed (PPSRExpression (e2,v))) = (
	PPDiscreteRange(DRConstrained{tmark=name_to_tmark e, range={lo=e2,hi=v}})
) | red_discrete_range1 _ _ = stack_error "red_discrete_range1";

fun red_discrete_range2 (Parsed (PPSRExpression (e,v))) = (
	PPDiscreteRange(DRRange{lo=e,hi=v})
) | red_discrete_range2 _ = stack_error "red_discrete_range2";

fun red_record_type_definition _ (Parsed(PPComponents cs)) _ _ = (
	PPTypeDef(TDRecordTypeDef{comps=cs})
) | red_record_type_definition _ _ _ _ = stack_error "red_record_type_definition";
=TEX
=SML
fun red_component_list1 (Parsed(PPVarDecls v)) = (
	PPComponents[CDeclaration v]
) | red_component_list1 _ = stack_error "red_component_list1";

fun red_component_list2 (Parsed(PPVariantPart vp)) = (
	PPComponents[CVariantPart vp]
) | red_component_list2 _ = stack_error "red_component_list2";
=TEX
=SML
fun red_component_list3 (Parsed(PPVarDecls vds)) (Parsed(PPVariantPart vp)) = (
	PPComponents[CDeclarationVariant{decls=vds, variant=vp}]
) | red_component_list3 _ _ = stack_error "red_component_list3";

fun red_component_list4 (Token ((LCNull,_), _)) = (
	PPComponents [CNone]
) | red_component_list4 _ = stack_error "red_component_list4";

val red_component_declaration_list1 = red_accept;

fun red_component_declaration_list2 (Parsed(PPVarDecls[v])) (Parsed(PPVarDecls vs)) = (
	PPVarDecls (v::vs)
) | red_component_declaration_list2 _ _ = stack_error "red_component_declaration_list2";

fun red_component_declaration (Parsed(PPIds ids)) _ (Parsed(PPExp n)) _ = (
	PPVarDecls [{vars=ids, tmark=name_to_tmark n}]
) | red_component_declaration _ _ _ _ = stack_error "red_component_declaration";

fun red_discriminant_part (Token ((_,CNText id), _)) _ (Parsed(PPExp n)) = (
	PPDiscriminantPart{vars=[id], tmark=name_to_tmark n}
) | red_discriminant_part _ _ _ = stack_error "red_discriminant_part";

fun red_variant_part _ (Token ((_,CNText id), _)) _ (Parsed(PPVariants v)) _ _ _ = (
	PPVariantPart{id=id, variants=v}
) | red_variant_part _ _ _ _ _ _ _ = stack_error "red_variant_part";

val red_variant_list1 = red_accept;

fun red_variant_list2 (Parsed(PPVariants [v])) (Parsed(PPVariants vs)) = (
	PPVariants (v::vs)
) | red_variant_list2 _ _ = stack_error "red_variant_list2";

fun red_variant _ (Parsed(PPIds ids)) _ (Parsed(PPComponents cl)) = (
	PPVariants [{ids=ids, comp=cl}]
) | red_variant _ _ _ _ = stack_error "red_variant";

fun red_variant_choice_list1 (Token ((_,CNText id), _)) = (
	PPIds [id]
) | red_variant_choice_list1 _ = stack_error "red_variant_choice_list1";

fun red_variant_choice_list2 (Token ((_,CNText id), _)) _ (Parsed(PPIds ids)) = (
	PPIds (id::ids)
) | red_variant_choice_list2 _ _ _ = stack_error "red_variant_choice_list2";
=TEX
SPARK manual 3.9:
=TEX
=SML
val red_declarative_part1 = red_accept;

fun red_declarative_part2 (Parsed (PPDeclarations d1)) (Parsed (PPDeclarations d2)) = (
	PPDeclarations (d1@d2)
) | red_declarative_part2 _ _ = stack_error "red_declarative_part2";
=TEX
=SML
fun red_dec1 (Parsed(PPKSlot k)) = (
	PPDeclarations [DDeclarationKSlot k]
) | red_dec1 _ = stack_error "red_dec1";

val red_dec2 = red_accept;
val red_dec3 = red_accept;
val red_dec4 = red_accept;
val red_dec5 = red_accept;
=TEX
=SML
fun red_basic_declarative_item1 (Parsed(PPBasicDecls bds)) = (
	PPDeclarations(map (fn x => DBasicDecl x) bds)
) | red_basic_declarative_item1 _ = stack_error "red_basic_declarative_item1";

fun red_basic_declarative_item2 (Parsed(PPRepresentationClause rc)) = (
	PPDeclarations [DRepresentationClause rc]
) | red_basic_declarative_item2 _ = stack_error "red_basic_declarative_item2";

fun red_body1 (Parsed(PPProperBody p)) = (
	PPDeclarations[DProperBody p]
) | red_body1 _ = stack_error "red_body1";
val red_body2 = red_accept;

val red_proper_body1 = red_accept;
val red_proper_body2 = red_accept;
=TEX
=SML
fun red_name1 (Token ((_,CNText name), _)) = (
	PPExp(EId name)
) | red_name1 _ = stack_error "red_name1";

val red_name2 = red_accept;
val red_name3 = red_accept;
val red_name4 = red_accept;
=TEX
SPARK manual 4.1.1:
=SML
fun red_indexed_component (Parsed(PPExp n)) (Parsed(PPExp index)) = (
	case (n, index) of
	(EAttribute {prefix=prefix,attribute_desig=ADAttrib ad}, _) => (
		PPExp(EAttribute
			{prefix=prefix,attribute_desig=ADAttribArg(ad,index)})
	) | (_, EArrayAggNamedOthers _) => (
		parse_error 503001 "OTHERS is not allowed here"
	) | (_, EArrayAggPosOthers _) => (
		parse_error 503001 "OTHERS is not allowed here"
	) | (_, EArrayAggOthers _) => (
		parse_error 503001 "OTHERS is not allowed here"
	) |_ => (
		PPExp(EIndexedComp{prefix=n, index=index})
	)
) | red_indexed_component _ _ = stack_error "red_indexed_component";
=TEX
SPARK manual 4.1.3:
=SML
fun red_selected_component (Parsed(PPExp n)) _ (Parsed(PPId id)) = (
	PPExp(ESelectedComp{prefix=n, selector=id})
) | red_selected_component _ _ _ = stack_error "red_selected_component";

fun red_selector (Token ((_,CNText id), _)) = (
	PPId id
) | red_selector _ = stack_error "red_selector";
=TEX
SPARK manual 4.1/4.1.1:
=SML
fun red_expression_list1 (Parsed(PPExp e)) = (
	PPExps [e]
) | red_expression_list1 _ = stack_error "red_expression_list1";

fun red_expression_list2 (Parsed(PPExps es)) _ (Parsed(PPExp e)) = (
	PPExps (es@[e])
) | red_expression_list2 _ _ _ = stack_error "red_expression_list2";
=TEX
=SML
fun red_attribute1 (Parsed(PPExp n)) (Token ((_,CNText primedid), _)) = (
	PPExp(EAttribute{prefix=n, attribute_desig=ADAttrib ((implode o tl o explode) primedid)})
) | red_attribute1 _ _ = stack_error "red_attribute1";

fun red_attribute2 (Token ((CharacterLiteral,CNString id), _)) (Token ((_,CNText primedid), _)) = (
	PPExp(EAttribute{prefix=ECharacterLiteral id, attribute_desig=ADAttrib ((implode o tl o explode) primedid)})
) | red_attribute2 _ _ = stack_error "red_attribute2";

fun red_aggregate _ (Parsed p) _ = (
	p
) | red_aggregate _ _ _ = stack_error "red_aggregate";
=TEX
=SML
fun red_component_association1 (Parsed(PPAgg{named_assocs=na,others=ot,...})) = (
	case (ot, na) of
	(Value oe, _::_) => (
		PPExp (EArrayAggNamedOthers{tmark="__comp_assoc",
			agg_named={named_assocs=na},others={others=oe}})
	)| (Value oe, _) => (
		PPExp (EArrayAggOthers{tmark="__comp_assoc", others={others=oe}})
	)|(Nil, _) => (
		PPExp (EArrayAggNamed{named_assocs=na})
	)
) | red_component_association1 _ = stack_error "red_component_association1";

val red_component_association2 = red_accept;

=TEX
=SML
fun red_named_association1 (Parsed(PPAggregateChoices v)) _ (Parsed(PPExp e)) = (
	case v of
	([],true) => PPAgg{tm=Nil, named_assocs=[], others=Value e}
	|(c, false) => PPAgg{tm=Nil, named_assocs =[{choice=c, comp=e}],others=Nil}
	|_ => parse_error 503001 "OTHERS cannot be in a choice list"
) | red_named_association1 _ _ _ = stack_error "red_named_association1";

fun red_named_association2 (Parsed(PPAggregateChoices v)) _ (Parsed(PPExp e)) _ (Parsed(PPAgg {named_assocs=na,others=ot,...})) = (
	case v of
	(c as _::_, false) =>
		PPAgg{tm=Nil,named_assocs={choice=c,comp=e}::na,others=ot}
	|_ => parse_error 503001 "OTHERS must occur last in the choice list"
) | red_named_association2 _ _ _ _ _ = stack_error "red_named_association2";

fun red_aggregate_choice_list1 (Token ((LCOthers,_), _)) = (
	PPAggregateChoices ([], true)
) | red_aggregate_choice_list1 _ = stack_error "red_aggregate_choice_list1";

val red_aggregate_choice_list2 = red_accept;

fun red_aggregate_choice_list3 (Parsed(PPAggregateChoices v)) _ (Parsed(PPAggregateChoices (acl, true))) = (
	parse_error 503001 "OTHERS cannot be in a choice list"
) | red_aggregate_choice_list3 (Parsed(PPAggregateChoices v)) _ (Parsed(PPAggregateChoices (acl, false))) = (
	case v of
	([ac], false) => PPAggregateChoices((ac::acl), false)
	|_ => parse_error 503001 "OTHERS cannot be in a choice list"
) | red_aggregate_choice_list3 _ _ _ = stack_error "red_aggregate_choice_list3";
=TEX
TBS - cannot produce ACAggChoiceSingle at present - do later.
=SML
fun red_aggregate_choice (Parsed(PPDiscreteRange dr)) = (
	PPAggregateChoices([ACAggChoiceRange dr], false)
) | red_aggregate_choice _ = stack_error "red_aggregate_choice";

fun red_positional_association1 (Parsed(PPExps es)) = (
	PPExp(EArrayAggPos{tmark="__positional_association",comps = es})
) | red_positional_association1 _ = stack_error "red_positional_association1";

fun red_positional_association2 (Parsed(PPExps es)) _ _ _ (Parsed(PPExp e)) = (
	PPExp(EArrayAggPosOthers{agg_pos={tmark="__positional_association",comps=es}, others={others=e}})
) | red_positional_association2 _ _ _ _ _ = stack_error "red_positional_association2";
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
=SML
val red_expression1 = red_accept;

fun red_expr (Parsed (PPExp exp1)) (Parsed (PPReltail(binop, exp2))) = (
	PPExp (EBinExp {bop = binop, left = exp1, right = exp2})
) | red_expr _ _ = stack_error "red_expr";

val red_expression2 = red_expr;
val red_expression3 = red_expr;
val red_expression4 = red_expr;
val red_expression5 = red_expr;
val red_expression6 = red_expr;
=TEX
=SML
fun red_logrel1 binop (Parsed(PPExp exp)) = (
	PPReltail(binop, exp)
) | red_logrel1 _ _ = stack_error "red_logrel1";

fun red_logrel2 binop (Parsed(PPExp exp1)) (Parsed(PPReltail(_,exp2))) = (
	PPReltail(binop, EBinExp{bop=binop, left=exp1, right=exp2})
) | red_logrel2 _ _ _ = stack_error "red_logrel2";

fun red_and_relation1 _ x2 =		(red_logrel1 BOSparkAnd x2);
fun red_and_relation2 _ x2 x3 =		(red_logrel2 BOSparkAnd x2 x3);
fun red_and_then_relation1 _ _ x3 =	(red_logrel1 BOSparkAndThen x3);
fun red_and_then_relation2 _ _ x3 x4 =	(red_logrel2 BOSparkAndThen x3 x4);
fun red_or_relation1 _ x2 =		(red_logrel1 BOSparkOr x2);
fun red_or_relation2 _ x2 x3 =		(red_logrel2 BOSparkOr x2 x3);
fun red_or_else_relation1 _ _ x3 =	(red_logrel1 BOSparkOrElse x3);
fun red_or_else_relation2 _ _ x3 x4 =	(red_logrel2 BOSparkOrElse x3 x4);
fun red_xor_relation1 _ x2 =		(red_logrel1 BOSparkXor x2);
fun red_xor_relation2 _ x2 x3 =		(red_logrel2 BOSparkXor x2 x3);
=TEX
=SML
fun red_relation1 (Parsed(PPSRExpression sr)) = (
	PPExp (sr_expression_to_expression sr)
) | red_relation1 _ = stack_error "red_relation1";

fun red_relation2 (Parsed(PPSRExpression sr1)) (Parsed(PPBinaryOp b)) (Parsed(PPSRExpression sr2)) = (
	PPExp(EBinExp{left=sr_expression_to_expression sr1,bop=b,
				right=sr_expression_to_expression sr2})
) | red_relation2 _ _ _ = stack_error "red_relation2";

fun red_relation3 p1 _ p2 = red_relation2 p1 (Parsed(PPBinaryOp BOSparkMem)) p2;
fun red_relation4 p1 _ _ p2 = red_relation2 p1 (Parsed(PPBinaryOp BOSparkNotmem)) p2;
=TEX
=SML
fun red_sr_expression1 (Parsed(PPExp e)) = (
	PPSRExpression (e, Nil)
) | red_sr_expression1 _ = stack_error "red_sr_expression1";

fun red_sr_expression2 (Parsed(PPExp e1)) _ (Parsed(PPExp e2)) = (
	PPSRExpression (e1, Value e2)
) | red_sr_expression2 _ _ _ = stack_error "red_sr_expression2";
=TEX
=SML
fun do_binarytail left ((b,right)::(rest as (_::_))) = (
	EBinExp{left=left, bop=b, right=do_binarytail right rest}
) | do_binarytail left [(b,right)] = (
	EBinExp{left=left, bop=b, right=right}
) | do_binarytail left _ = left;

fun red_simple_expression1 (Parsed(PPExp e)) (Parsed(PPBinOpTail tl)) = (
	PPExp (do_binarytail e tl)
) | red_simple_expression1 _ _ = stack_error "red_simple_expression1";

fun red_simple_expression2 (Parsed(PPUnaryOp uop)) (Parsed(PPExp e)) (Parsed(PPBinOpTail tl)) = (
	PPExp (do_binarytail (EUnaryExp{uop=uop,right=e}) tl)
) | red_simple_expression2 _ _ _ = stack_error "red_simple_expression2";

val red_binoptail1 = PPBinOpTail [];

fun red_binoptail2 (Parsed(PPBinaryOp b)) (Parsed(PPExp e)) (Parsed(PPBinOpTail tl)) = (
	PPBinOpTail((b,e)::tl)
) | red_binoptail2 _ _ _ = stack_error "red_binoptail2";

val red_term1 = red_accept;

fun red_term2 (Parsed(PPExp e1)) (Parsed(PPBinaryOp m)) (Parsed(PPExp e2)) = (
	PPExp(EBinExp{left=e1,bop=m,right=e2})
) | red_term2 _ _ _ = stack_error "red_term2";
=TEX
=SML
val red_factor1 = red_accept;
fun red_factor2 (Parsed(PPExp e1)) _ (Parsed(PPExp e2)) = (
	PPExp(EBinExp{left=e1,bop=BOSparkExpon,right=e2})
) | red_factor2 _ _ _ = stack_error "red_factor2";

fun red_factor3 _ (Parsed(PPExp e)) = (
	PPExp(EUnaryExp{uop=UOSparkAbs, right=e})
) | red_factor3 _ _ = stack_error "red_factor3";

fun red_factor4 _ (Parsed(PPExp e)) = (
	PPExp(EUnaryExp{uop=UOSparkNot, right=e})
) | red_factor4 _ _ = stack_error "red_factor4";
=TEX
=SML
fun red_primary1 (Token ((LCNumericLiteral,CNText n), _)) = (
	PPExp (EInt n)
) | red_primary1 _ = stack_error "red_primary1";

fun red_primary2 (Token ((LCCharacterLiteral,CNString c), _)) = (
	PPExp (ECharacterLiteral c)
) | red_primary2 _ = stack_error "red_primary2";

fun red_primary3 (Token ((LCStringLiteral,CNString s), _)) = (
	PPExp (EStringLiteral s)
) | red_primary3 _ = stack_error "red_primary3";

val red_primary4 = red_accept;
val red_primary5 = red_accept;
fun red_primary6 _ (Parsed (PPExp e)) _ = (
	PPExp (EBracketed e)
) | red_primary6 _ _ _ = stack_error "red_primary6";

val red_primary7 = red_accept;
=TEX
=SML
fun red_relational_operator1 _ = PPBinaryOp BOSparkEq;
fun red_relational_operator2 _ = PPBinaryOp BOSparkNotEq;
fun red_relational_operator3 _ = PPBinaryOp BOSparkLess;
fun red_relational_operator4 _ = PPBinaryOp BOSparkLessEq;
fun red_relational_operator5 _ = PPBinaryOp BOSparkGreater;
fun red_relational_operator6 _ = PPBinaryOp BOSparkGreaterEq;
fun red_binary_adding_operator1 _ = PPBinaryOp BOSparkAdd;
fun red_binary_adding_operator2 _ = PPBinaryOp BOSparkMinus;
fun red_binary_adding_operator3 _ = PPBinaryOp BOSparkConcat;
=TEX
=SML
fun red_unary_adding_operator1 x1 = PPUnaryOp UOSparkUnaryAdd;
fun red_unary_adding_operator2 x1 = PPUnaryOp UOSparkUnaryMinus;
fun red_multiplying_operator1 x1 = PPBinaryOp BOSparkTimes;
fun red_multiplying_operator2 x1 = PPBinaryOp BOSparkIntdiv;
fun red_multiplying_operator3 x1 = PPBinaryOp BOSparkMod;
fun red_multiplying_operator4 x1 = PPBinaryOp BOSparkRem;
=TEX
=SML
fun red_qualified_expression (Parsed(PPExp n)) _ (Parsed(PPExp e)) = (
	PPExp(EQualifiedExp{tmark=name_to_tmark n, exp=e})
) | red_qualified_expression _ _ _ = stack_error "red_qualified_expression";
=TEX
=SML
fun red_sequence_of_statements1 (Parsed p) = (
	case p of
	PPStmt s => PPStatement(SStmt s)
	|PPLogCon c => PPStatement(SLogCon (c, STImplicitNull))
	|_ => stack_error "red_sequence_of_statements1"
) | red_sequence_of_statements1 _ = stack_error "red_sequence_of_statements1";

fun red_sequence_of_statements2 (Parsed p) (Parsed(PPStatement(SStmt st))) = (
	case p of
	PPStmt s => PPStatement(SStmt(STSemicolon(s,st)))
	|PPLogCon c => PPStatement(SLogCon(c, st))
	|_ => stack_error "red_sequence_of_statements2_a"
) | red_sequence_of_statements2 (Parsed p) (Parsed(PPStatement(SLogCon _))) = (
	parse_error 503001 "a logical constant must be the first statement"
) | red_sequence_of_statements2 _ _ = stack_error "red_sequence_of_statements2";

fun red_statement1 (Parsed(PPKSlot k)) = (
	PPStmt(STKSlot k)
) | red_statement1 _ = stack_error "red_statement1";

val red_statement2  = red_accept;

fun red_statement3 _ (Token ((LCZ,CNZ z1), _)) _ (Parsed(PPStmt(STSpecNoIvars s))) = (
let	val (n, ty) = process_con_decl z1;
in
	PPLogCon{x=n, e=ty,spec=s, pre1 = ñtrue®}
end
) | red_statement3 _ _ _ _ = stack_error "red_statement3";

val red_statement4 = red_accept;
val red_statement5 = red_accept;
=TEX
=SML
fun red_specification_statement1 _ (Token ((LCZ,CNZ z1), _)) _ (Token ((LCZ,CNZ z2), _)) _ = (
let	val (pre, post) =
		case process_pre_and_post_conditions z2 of
		(Value pre', post') => (pre', post')
		|(Nil, post') => (ñtrue®, post');
in
	PPStmt(STSpecNoIvars{w=process_frame z1,w0=[],pre=pre,post=post,label=LImplicit})
end
) | red_specification_statement1 _ _ _ _ _ = stack_error "red_specification_statement1";

fun red_specification_statement2 _ (Token ((LCZ,CNZ z1), _)) _ (Token ((LCZ,CNZ z2), _)) _ = (
let	val (pre, post) = (process_pre_condition z2, ñtrue®);
in
	PPStmt(STSpecNoIvars{w=process_frame z1,w0=[],pre=pre,post=post,label=LImplicit})
end
) | red_specification_statement2 _ _ _ _ _ = stack_error "red_specification_statement2";

fun red_specification_statement3 _ (Token ((LCZ,CNZ z1), _)) _ (Token ((LCZ,CNZ z2), _)) _ (Parsed(PPId lab))= (
let	val (pre, post) =
		case process_pre_and_post_conditions z2 of
		(Value pre', post') => (pre', post')
		|(Nil, post') => (ñtrue®, post');
in
	PPStmt(STSpecNoIvars{w=process_frame z1,w0=[],pre=pre,post=post, label=LExplicit lab})
end
) | red_specification_statement3 _ _ _ _ _ _ = stack_error "red_specification_statement3";

fun red_specification_statement4 _ (Token ((LCZ,CNZ z1), _)) _ (Token ((LCZ,CNZ z2), _)) _ (Parsed(PPId lab))= (
let	val (pre, post) = (process_pre_condition z2, ñtrue®);
in
	PPStmt(STSpecNoIvars{w=process_frame z1,w0=[],pre=pre,post=post,label=LExplicit lab})
end
) | red_specification_statement4 _ _ _ _ _ _ = stack_error "red_specification_statement4";
=TEX
=SML
fun red_label _ (Token ((LCNumericLiteral,CNText n), _)) _ = (
	if is_all_decimal n
	then
		PPId (format_label n)
	else
		parse_error 503001 "label can only contain digits"
) | red_label _ _ _ = stack_error "red_label";

fun red_k_slot1 (Token ((LCKSlot,CNKSlot lx), _)) = (
	PPKSlot{content=format_input_items lx, label=LImplicit}
) | red_k_slot1 _ = stack_error "red_k_slot1";

fun red_k_slot2 (Token ((LCKSlot,CNKSlot lx), _)) (Parsed(PPId lab)) = (
	PPKSlot{content=format_input_items lx, label=LExplicit lab}
) | red_k_slot2 _ _ = stack_error "red_k_slot2";
=TEX
=SML
val red_simple_statement1 = red_accept;
val red_simple_statement2 = red_accept;
val red_simple_statement3 = red_accept;
val red_simple_statement4 = red_accept;
val red_simple_statement5 = red_accept;
val red_compound_statement1 = red_accept;
val red_compound_statement2 = red_accept;
val red_compound_statement3 = red_accept;
=TEX
=SML
fun red_null_statement _ _ = PPStmt STNull;

fun red_assignment_statement (Parsed(PPExp n)) _ (Parsed(PPExp e)) _ = (
	PPStmt(STAssign{name=n, e=e})
) | red_assignment_statement _ _ _ _ = stack_error "red_assignment_statement";
=TEX
=SML
fun red_if_statement _ (Parsed(PPExp exp)) _ (Parsed(PPStatement st)) (Parsed(PPElsIf ei)) (Parsed(PPStmt el)) _ _ _ = (
let	val css = (exp, statement_to_stmt st)::ei;
	fun aux ((c,s)::(rest as (_::_))) = (
		(STIfThenElse{g=c,p=s,q=aux rest,elsif=true})
	) | aux [(c,s)] = (
		(STIfThenElse{g=c,p=s,q=el,elsif=false})
	) | aux _ = STImplicitNull;
in
	PPStmt (aux css)
end
) | red_if_statement _ _ _ _ _ _ _ _ _ = stack_error "red_if_statement";
=TEX
=SML
val red_elsif_part1 = PPElsIf [];
fun red_elsif_part2 _ (Parsed (PPExp exp)) _ (Parsed(PPStatement st))
	(Parsed(PPElsIf ei)) = (
	PPElsIf ((exp, statement_to_stmt st)::ei)
) | red_elsif_part2 _ _ _ _ _ = stack_error "red_elsif_part2";
=TEX
=SML
val red_else_part1 = PPStmt STImplicitNull;

fun red_else_part2 _ (Parsed(PPStatement st)) = (
	PPStmt (statement_to_stmt st)
) | red_else_part2 _ _ = stack_error "red_else_part2";

val red_condition = red_accept;
=TEX
=SML
fun red_case_statement _ (Parsed(PPExp e)) _ (Parsed(PPCaseAlternatives cs))
	(Parsed(PPStmt others)) _ _ _ = (
	PPStmt(STCase{e=e, s=cs, others=others})
) | red_case_statement _ _ _ _ _ _ _ _ = stack_error "red_case_statement";

val red_case_statement_alternative_list1 = red_accept;

fun red_case_statement_alternative_list2 (Parsed(PPCaseAlternatives cs))
	(Parsed(PPCaseAlternatives [c])) = (
	PPCaseAlternatives (cs@[c])
) | red_case_statement_alternative_list2 _ _ =
	stack_error "red_case_statement_alternative_list2";

fun red_case_statement_alternative _ (Parsed(PPCaseChoices c)) _
	(Parsed(PPStatement st)) = (
	PPCaseAlternatives[{choices=c, p=statement_to_stmt st}]
) | red_case_statement_alternative _ _ _ _ =
	stack_error "red_case_statement_alternative";
=TEX
=SML
val red_case_choice_list1 = red_accept;

fun red_case_choice_list2 (Parsed(PPCaseChoices [ac])) _
	(Parsed(PPCaseChoices acl)) = (
	PPCaseChoices(ac::acl)
) | red_case_choice_list2 _ _ _ = stack_error "red_acase_choice_list2";
=TEX
TBS Cannot produce CCCaseExp at present.
=SML
fun red_case_choice (Parsed(PPDiscreteRange dr)) = (
	PPCaseChoices[CCCaseRange dr]
) | red_case_choice _ = stack_error "red_case_choice";

val red_others_part1 = PPStmt STImplicitNull;

fun red_others_part2 _ _ _ (Parsed(PPStatement st)) = (
	PPStmt (statement_to_stmt st)
) | red_others_part2 _ _ _ _ = stack_error "red_others_part2";
=TEX
SPARK manual 5.5:
=SML
fun red_loop_statement (Parsed(PPIds ids)) (Parsed p) (Parsed(PPExps es))
	_ (Parsed(PPStatement st)) _ _ (Parsed(PPIds ids')) _ = (
let	val side = case (ids', ids) of
		([id'], [id]) => (
			if different_ids (id', id)
			then	parse_error 503001 "LOOP names do not match"
			else	()
		)| _ => (
			()
		);
	val name = case ids of
			[id] => Value id
			|_ => Nil;
	val till = case es of
			[EAuxiliaryExp tm] => Value tm
			|_ => Nil;
	val s = statement_to_stmt st;
in
	case p of
	PPExp c => (
			PPStmt(STWhile{name=name, g=c, loop={t=till, stmt=s}})
	) |PPFor(id, tm, dir, opr) => (
		case opr of
		Value {lo=lo,hi=hi} => (
			PPStmt(STForStatic{name=name, tmark=tm, i=id, lo=lo,
			hi=hi, dir=dir,loop={t=till, stmt=s}})
		) |Nil => (
			PPStmt(STForTmark{name=name,i=id, tmark=tm, dir=dir,
			loop={t=till, stmt=s}})
		)
	) | PPId "__no_scheme" => (
		case name of
		Value n => (
			PPStmt(STNamedLoop{name=n,t=till, stmt=s})
		) |Nil => (
			PPStmt(STLoop{t=till, stmt=s})
		)
	) | _ => stack_error"red_loop_statement_a"
end
) | red_loop_statement _ _ _ _ _ _ _ _ _ = stack_error "red_loop_statement";

val red_name_opt11 = PPIds[];

fun red_name_opt12 (Token ((_,CNText id), _)) _ = (
	PPIds [id]
) | red_name_opt12 _ _ = stack_error "red_name_opt12";

val red_name_opt21 = PPIds [];

fun red_name_opt22 (Token ((_,CNText id), _)) = (
	PPIds [id]
) | red_name_opt22 _ = stack_error "red_name_opt22";

val red_iteration_scheme_opt1 = PPId "__no_scheme";

val red_iteration_scheme_opt2 = red_accept;

fun red_iteration_scheme1 _ (Parsed p) = (p
) | red_iteration_scheme1 _ _ = stack_error "red_iteration_scheme1";

fun red_iteration_scheme2 _ (Parsed p) = (p
) | red_iteration_scheme2 _ _ = stack_error "red_iteration_scheme2";

fun red_loop_parameter_specification1 (Token ((_,CNText id), _)) _
	(Parsed(PPExp n)) = (
	PPFor(id,name_to_tmark n, LDForwards, Nil)
) | red_loop_parameter_specification1 _ _ _ =
	stack_error "red_loop_parameter_specification1";

fun red_loop_parameter_specification2 (Token ((_,CNText id), _)) _ _
	(Parsed(PPExp n)) = (
	PPFor(id,name_to_tmark n, LDReverse, Nil)
) | red_loop_parameter_specification2 _ _ _ _ = 
	 stack_error "red_loop_parameter_specification2";

fun red_loop_parameter_specification3 (Token ((_,CNText id), _)) _
	(Parsed(PPExp n)) _ (Parsed(PPSRExpression sr)) = (
		PPFor(id, name_to_tmark n, LDForwards, Value (sr_expression_to_range sr))
) | red_loop_parameter_specification3 _ _ _ _ _ =
	stack_error "red_loop_parameter_specification3";

fun red_loop_parameter_specification4 (Token ((_,CNText id), _)) _ _ (Parsed(PPExp n)) _ (Parsed(PPSRExpression sr)) = (
	PPFor(id, name_to_tmark n, LDReverse, Value (sr_expression_to_range sr))
) | red_loop_parameter_specification4 _ _ _ _ _ _ =
	stack_error "red_loop_parameter_specification4";

val red_till_opt1 = PPExps [];
fun red_till_opt2 _ (Parsed(PPExp(EAuxiliaryExp z))) = (
	PPExps[EAuxiliaryExp z]
) | red_till_opt2 _ _ = stack_error "red_till_opt2";
=TEX
=SML
fun red_abstract_expression _ (Token ((LCZ,CNZ z), _)) _ = (
	PPExp(EAuxiliaryExp (process_aux_exp z))
) | red_abstract_expression _ _ _ = stack_error "red_abstract_expression";

fun red_exit_statement1 _ _ = (
	PPStmt STExit
);
fun red_exit_statement2 _ _ (Parsed(PPExp exp)) _ = (
	PPStmt(STExitWhen{g=exp})
) | red_exit_statement2 _ _ _ _ = stack_error "red_exit_statement2";

fun red_return_statement _ (Parsed(PPExp exp)) _ = (
	PPStmt (STRet{e=exp})
) | red_return_statement _ _ _ = stack_error "red_return_statement";
=TEX
=SML
fun red_subprogram_declaration1 (Parsed(PPProcedureSpecification p)) _ = (
	PPDeclarations[DProcedureDeclaration p]
) | red_subprogram_declaration1 _ _ = stack_error "red_subprogram_declaration1";

fun red_subprogram_declaration2 (Parsed(PPFunctionSpecification f)) _ = (
	PPDeclarations[DFunctionDeclaration f]
) | red_subprogram_declaration2 _ _ = stack_error "red_subprogram_declaration2";

fun red_subprogram_specification1 (Parsed(PPProcedureSpecification p)) = (
	PPSubprogramSpec(SSProcedure p)
) | red_subprogram_specification1 _ = stack_error "red_subprogram_specification1";

fun red_subprogram_specification2 (Parsed(PPFunctionSpecification p)) = (
	PPSubprogramSpec(SSFunction p)
) | red_subprogram_specification2 _ = stack_error "red_subprogram_specification2";
=TEX
=SML
fun red_procedure_specification1 _ (Token ((_,CNText id), _)) = (
	PPProcedureSpecification{name=id, formal_part=[],spec=Nil}
) | red_procedure_specification1 _ _ = stack_error "red_procedure_specification1";

fun red_procedure_specification2 _ (Token ((_,CNText id), _)) (Parsed(PPStmt(STSpecNoIvars s))) = (
	PPProcedureSpecification{name=id,formal_part=[],spec=Value s}
) | red_procedure_specification2 _ _ _ = stack_error "red_procedure_specification2";

fun red_procedure_specification3 _ (Token ((_,CNText id), _)) (Parsed (PPFormals f)) = (
	PPProcedureSpecification{name=id,formal_part=f,spec=Nil}
) | red_procedure_specification3 _ _ _ = stack_error "red_procedure_specification3";

fun red_procedure_specification4 _ (Token ((_,CNText id), _)) (Parsed (PPFormals f)) (Parsed(PPStmt(STSpecNoIvars s))) = (
	PPProcedureSpecification{name=id,formal_part=f,spec=Value s}
) | red_procedure_specification4 _ _ _ _= stack_error "red_procedure_specification4";

fun red_function_specification1 _ (Parsed (PPId des)) _ (Parsed(PPExp n)) = (
	PPFunctionSpecification{designator=des, return=name_to_tmark n,formal_part=[],spec=Nil}
) | red_function_specification1 _ _ _ _ = stack_error "red_function_specification1";

fun red_function_specification2 _ (Token ((_,CNText des), _)) _ (Parsed(PPExp n)) (Parsed(PPStmt(STSpecNoIvars s))) = (
	PPFunctionSpecification{designator=des, return=name_to_tmark n,formal_part=[],spec=Value s}
) | red_function_specification2 _ _ _ _ _ = stack_error "red_function_specification2";

fun red_function_specification3 _ (Parsed (PPId des)) (Parsed(PPFormals f)) _ (Parsed(PPExp n)) = (
	PPFunctionSpecification{designator=des, return=name_to_tmark n,formal_part=f,spec=Nil}
) | red_function_specification3 _ _ _ _ _ = stack_error "red_function_specification3";

fun red_function_specification4 _ (Parsed (PPId des)) (Parsed(PPFormals f)) _ (Parsed(PPExp n)) (Parsed(PPStmt(STSpecNoIvars s))) = (
	PPFunctionSpecification{designator=des, return=name_to_tmark n,formal_part=f,spec=Value s}
) | red_function_specification4 _ _ _ _ _ _ = stack_error "red_function_specification4";
=TEX
SPARK manual 6.1:
=SML
fun red_designator (Token((_,CNText des), _)) = (
	PPId des
) | red_designator _ = stack_error "red_designator";

fun red_operator_symbol (Token((StringLiteral,CNString opsym), _)) = (
	PPId opsym
) | red_operator_symbol _ = stack_error "red_operator_symbol";

fun red_formal_part _ (Parsed p) _ = (p
) | red_formal_part _ _ _ = stack_error "red_formal_part";

val red_parlist1 = red_accept;

fun red_parlist2 (Parsed (PPFormals f1)) _ (Parsed(PPFormals f2)) = (
	PPFormals (f1@f2)
) | red_parlist2 _ _ _ = stack_error "red_parlist2";

fun red_parameter_specification (Parsed(PPIds ids)) _ (Parsed(PPMode m)) (Parsed(PPExp n)) = (
	PPFormals[{idlist=ids,mode=m,name=name_to_tmark n}]
) | red_parameter_specification _ _ _ _ = stack_error "red_parameter_specification";
;
val red_mode1 = PPMode MSparkIn;
fun red_mode2 _ = PPMode MSparkIn;
fun red_mode3 _ = PPMode MSparkOut;
fun red_mode4 _ _ = PPMode MSparkInOut;
=TEX
SPARK manual 6.3:
=SML
fun red_subprogram_body1 (Parsed (PPProcedureSpecification ps)) _ (Parsed (PPSubprogram (d, s, id))) = (
let	val {name=id',...} = ps;
	val side =	if	different_ids (id', id)
			then	parse_error 503001 "PROCEDURE identifiers do not match"
			else	();
in
	PPProperBody (PBProcedure {procedure_spec=ps,declarative_part=d,statement=s})
end
) | red_subprogram_body1 _ _ _ = stack_error "red_subprogram_body1";

fun red_subprogram_body2 (Parsed (PPFunctionSpecification fs)) _ (Parsed (PPSubprogram (d, s, id))) = (
let	val {designator=id',...} = fs;
	val side =	if	different_ids (id', id)
			then	parse_error 503001 "FUNCTION designators do not match"
			else	();
in
	PPProperBody (PBFunction {function_spec=fs,declarative_part=d,statement=s})
end
) | red_subprogram_body2 _ _ _ = stack_error "red_subprogram_body2";

fun red_subprogram_implementation (Parsed(PPDeclarations d)) _ (Parsed(PPStatement s)) _ (Parsed(PPId id)) _ = (
	PPSubprogram (d, s, id)
) | red_subprogram_implementation _ _ _ _ _ _ = stack_error "red_subprogram_implementation";
=TEX
=SML
fun red_procedure_call_statement (Parsed (p as (PPExp e))) _ = (
	case e of
	EIndexedComp{prefix=prefix,index=EArrayAggPos{comps = comps,...}} => (
		PPStmt (STProcNoIvars{name=name_to_tmark prefix,
			actuals=APositional comps})
	)| EIndexedComp{prefix=prefix,index=EArrayAggNamed{named_assocs=na}} => (
		PPStmt (STProcNoIvars{name=name_to_tmark prefix,
			actuals=ANamed na})
	)| EIndexedComp{index=EArrayAggNamedOthers _,...} => (
		parse_error 503001 "OTHERS is not allowed in a parameter association"
	)| EIndexedComp{index=EArrayAggPosOthers _,...} => (
		parse_error 503001 "OTHERS is not allowed in a parameter association"
	)| EIndexedComp{index=EArrayAggOthers _,...} => (
		parse_error 503001 "OTHERS is not allowed in a parameter association"
	)|_ => (
		PPStmt (STProcNoIvars{name=name_to_tmark e, actuals=APositional[]})
	)
) | red_procedure_call_statement _ _ = stack_error "red_procedure_call_statement";

fun red_actual_parameter_part _ (Parsed p) _ = (
	p
) | red_actual_parameter_part _ _ _ = stack_error "red_actual_parameter_part";

fun red_parameter_association1 (Parsed(PPAgg{tm=tm,named_assocs=na,others=ot})) = (
	case ot of
	Value oe => PPExp (EArrayAggNamedOthers{tmark="__param_assoc",agg_named={named_assocs=na},others={others=oe}})
	|Nil => PPExp (EArrayAggNamed{named_assocs=na})
) | red_parameter_association1 _ = stack_error "red_parameter_association1";

fun red_parameter_association2 (Parsed(PPExps es)) = (
	PPExp(EArrayAggPos{tmark="__param_assoc",comps = es})
) | red_parameter_association2 _ = stack_error "red_parameter_association2";

fun red_positional_parameter_association1 (Parsed(PPExp a)) = (
	PPExps [a]
) | red_positional_parameter_association1 _ = stack_error "red_positional_parameter_association1";

fun red_positional_parameter_association2 (Parsed(PPExp a)) _ (Parsed(PPExps es)) = (
	PPExps (a::es)
) | red_positional_parameter_association2  _ _ _ = stack_error "red_positional_parameter_association2";
=TEX
=SML
val red_actual_parameter = red_accept;
=TEX
SPARK manual 7.1:
=SML
fun red_package_declaration (Parsed (PPPackageSpecification p)) _ = (
	PPDeclarations[DPackageDeclaration p]
) | red_package_declaration _ _ = stack_error "red_package_declaration";

fun red_package_specification1 _ (Token ((_,CNText id), _)) _ (Parsed(PPDeclarations v)) _ (Token ((_,CNText id'), _)) = (
let	val side =	if	different_ids (id', id)
			then	parse_error 503001 "PACKAGE names do not match"
			else	();
in
	PPPackageSpecification {name=id,visible_decs=v,private_decs=[]}
end
) | red_package_specification1 _ _ _ _ _ _ = stack_error "red_package_specification1";

fun red_package_specification2 _ (Token ((_,CNText id), _)) _ (Parsed(PPDeclarations v)) _  (Parsed(PPDeclarations p)) _ (Token ((_,CNText id'), _)) = (
let	val side =	if	different_ids (id', id)
			then	parse_error 503001 "PACKAGE names do not match"
			else	();
in
	PPPackageSpecification {name=id,visible_decs=v,private_decs=p}
end
) | red_package_specification2 _ _ _ _ _ _ _ _ = stack_error "red_package_specification2";

val red_visible_part1 = red_accept;

fun red_visible_part2 (Parsed (PPDeclarations d1)) (Parsed (PPDeclarations d2)) = ( 
	PPDeclarations (d1@d2)
) | red_visible_part2 _ _ = stack_error "red_visible_part2";

=TEX
SPARK manual 7.1:
=SML
fun red_visdec1 (Parsed (PPKSlot k)) = (
	PPDeclarations [DDeclarationKSlot k]
) | red_visdec1 _ = stack_error "red_visdec1";

val red_visdec2 = red_accept;

val red_visdec3 = red_accept;

val red_private_part1 = red_accept;

fun red_private_part2 (Parsed (PPDeclarations d1)) (Parsed (PPDeclarations d2)) = (
	PPDeclarations (d1@d2)
) | red_private_part2 _ _ = stack_error "red_private_part2";

fun red_pdec1 (Parsed (PPKSlot k)) = (
	PPDeclarations [DDeclarationKSlot k]
) | red_pdec1 _ = stack_error "red_pdec1";

val red_pdec2 = red_accept;
=TEX
=SML
fun red_package_body _ _ (Token ((_,CNText id), _)) _ (Parsed(PPSubprogram (d,s, _))) _ (Token ((_,CNText id'), _)) _ = (
let	val side =	if	different_ids (id', id)
			then	parse_error 503001 "PACKAGE names do not match"
			else	();
in
	PPProperBody(PBPackage{name=id,decls=d,statement=s})
end
) | red_package_body _ _ _ _ _ _ _ _ = stack_error "red_package_body";

fun red_package_implementation1 (Parsed (PPDeclarations d)) = (
	PPSubprogram (d, SStmt STImplicitNull, "")
) | red_package_implementation1 _ = stack_error "red_package_implementation1";

fun red_package_implementation2 (Parsed (PPDeclarations d)) _ (Parsed(PPStatement s)) = (
	PPSubprogram (d, s, "")
) | red_package_implementation2 _ _ _ = stack_error "red_package_implementation2";

val red_package_initialization = red_accept;
=TEX
SPARK manual 7.4:
=SML
fun red_private_type_declaration1 _ (Token ((_,CNText id), _)) _ _ _ = (
	PPBasicDecls[BDPrivateTypeDecl{id=id,limited=false}]
) | red_private_type_declaration1 _ _ _ _ _ = stack_error "red_private_type_declaration1";

fun red_private_type_declaration2 _ (Token ((_,CNText id), _)) _ _ _ _ = (
	PPBasicDecls[BDPrivateTypeDecl{id=id,limited=true}]
) | red_private_type_declaration2 _ _ _ _ _ _ = stack_error "red_private_type_declaration2";

fun red_deferred_constant_declaration (Parsed(PPIds ids)) _ _ (Parsed(PPExp n)) _ = (
	PPBasicDecls[BDDeferredConstDecl{consts=ids,tmark=name_to_tmark n}]
) | red_deferred_constant_declaration _ _ _ _ _ = stack_error "red_deferred_constant_declaration";

fun red_renaming_declaration1 _ (Parsed (PPId opsym1)) (Parsed(PPFormals f)) _ (Parsed(PPExp n)) _ (Token ((_,CNText id), _)) _ (Parsed (PPId opsym2)) _ = (
	PPDeclarations[DRenamingDeclaration(RDFunction{opsym1=opsym1,formal_part=f,tmark=name_to_tmark n,name=id,opsym2=opsym2})]
) | red_renaming_declaration1 _ _ _ _ _ _ _ _ _ _ = stack_error "red_renaming_declaration1";

fun red_renaming_declaration2 (Parsed (PPSubprogramSpec ss)) _ (Token ((_,CNText id1), _)) _ (Token ((_,CNText id2), _)) _ = (
	PPDeclarations[DRenamingDeclaration(RDSubprogram{subprogram_specification=ss,name1=id1,name2=id2})]
) | red_renaming_declaration2 _ _ _ _ _ _ = stack_error "red_renaming_declaration21";

=TEX
=SML
fun red_compilation1 (Parsed (PPKSlot k)) = (
	PPKSlotCUList [KCUKSlot k]
) | red_compilation1 _ = stack_error "red_compilation1";

fun red_compilation2 (Parsed (PPCompilationUnit (ids,c))) = (
	PPKSlotCUList [KCUUnit {context=ids, comp_unit=c}]
) | red_compilation2 _ = stack_error "red_compilation2";

fun red_compilation3 (Parsed (PPCompilationUnit (ids,c))) (Parsed (PPKSlotCUList cl)) = (
	PPKSlotCUList ((KCUUnit {context=ids, comp_unit=c})::cl)
) | red_compilation3 _ _ = stack_error "red_compilation3";
=TEX
=SML
fun red_compilation_unit (Parsed(PPIds ids)) (Parsed (PPCompilationUnit ([],c))) = (
	PPCompilationUnit (ids, c)
) | red_compilation_unit _ _ = stack_error "red_compilation_unit";

val red_compilation_unit1 = red_compilation_unit;
val red_compilation_unit2 = red_compilation_unit;
=TEX
=SML
fun red_library_unit1 (Parsed(PPDeclarations [DPackageDeclaration p])) = (
	PPCompilationUnit ([], CUPackageDeclaration p)
) | red_library_unit1 _ = stack_error "red_library_unit1";

fun red_library_unit2 (Parsed(PPProperBody p)) = (
	PPCompilationUnit ([], CUProperBody p)
) | red_library_unit2 _ = stack_error "red_library_unit2";

=TEX

SPARK manual 10.1:
=SML
val red_secondary_unit1 = red_accept;
val red_secondary_unit2 = red_accept;

fun red_library_unit_body (Parsed(PPProperBody p)) = (
	PPCompilationUnit([], CUProperBody p)
) | red_library_unit_body _ = stack_error "red_library_unit_body";

val red_main_program = red_accept;
=TEX

SPARK manual 10.1.1:
=SML
val red_context_clause1 = PPIds [];
val red_context_clause2 = red_accept;

fun red_with_clause _ (Parsed (PPIds ids)) _ = (
	 PPIds ids
) | red_with_clause _ _ _ = stack_error "red_with_clause";
=TEX
SPARK manual 10.2:
=SML
fun red_body_stub1 (Parsed (PPProcedureSpecification ps)) _ _ _ = (
	PPDeclarations [DProcedureStub ps]
) | red_body_stub1 _ _ _ _ = stack_error "red_body_stub1";

fun red_body_stub2 (Parsed (PPFunctionSpecification fs)) _ _ _ = (
	PPDeclarations [DFunctionStub fs]
) | red_body_stub2 _ _ _ _ = stack_error "red_body_stub2";

fun red_body_stub3 _ _ (Token ((_,CNText id), _)) _ _ _ = (
	PPDeclarations [DPackageStub id]
) | red_body_stub3 _ _ _ _ _ _ = stack_error "red_body_stub3";

fun red_subunit _ _ (Parsed(PPExp n)) _ (Parsed (PPProperBody p)) = (
	PPCompilationUnit([], CUSubUnit{name=n, proper_body=p})
) | red_subunit _ _ _ _ _ = stack_error "red_subunit";
=TEX
=SML
val red_representation_clause1 = red_accept;

val red_representation_clause2 = red_accept;

val red_type_representation_clause1 = red_accept;
val red_type_representation_clause2 = red_accept;
val red_type_representation_clause3 = red_accept;

fun red_length_clause _ (Parsed(PPExp a)) _ (Parsed(PPExp e)) _ = (
	PPRepresentationClause(RCLength{attribute=a, exp=e})
) | red_length_clause _ _ _ _ _ = stack_error "red_length_clause";
=TEX
SPARK manual 13.3:
=SML
fun red_enumeration_representation_clause _ (Token ((_,CNText id), _)) _ (Parsed(PPExp e)) _ = (
	PPRepresentationClause(RCEnumeration{name=id, exp=e})
) | red_enumeration_representation_clause _ _ _ _ _ = stack_error "red_enumeration_representation_clause";
=TEX
SPARK manual 13.4:
=SML
fun red_record_representation_clause _ (Token ((_,CNText id), _)) _ _ (Parsed(PPExps [e])) (Parsed(PPComponentClauses c)) _ _ _ = (
	PPRepresentationClause(RCRecord{name=id,alignment_opt=Value e,component_pack=c})
) | red_record_representation_clause _ (Token ((_,CNText id), _)) _ _ (Parsed(PPExps [])) (Parsed(PPComponentClauses c)) _ _ _ = (
	PPRepresentationClause(RCRecord{name=id,alignment_opt=Nil,component_pack=c})
) | red_record_representation_clause _ _ _ _ _ _ _ _ _ = stack_error "red_record_representation_clause";

=TEX
SPARK manual 13.4:
=SML
val red_alignment_opt1 = PPExps [];
fun red_alignment_opt2 _ _ (Parsed(PPExp e)) _ = (
	PPExps [e]
) | red_alignment_opt2 _ _ _ _ = stack_error "red_alignment_opt2";

val red_component_pack1 = red_accept;

fun red_component_pack2 (Parsed(PPComponentClauses [c])) (Parsed(PPComponentClauses cs)) = (
	PPComponentClauses (c::cs)
) | red_component_pack2 _ _ = stack_error "red_component_pack2";
=TEX
SPARK manual 13.4:
=SML
fun red_component_clause (Parsed(PPExp n)) _ (Parsed(PPExp e)) _ (Parsed(PPSRExpression (e1,v))) _ = (
	PPComponentClauses[{name=n, exp=e, range={lo=e1,hi=v}}]
) | red_component_clause _ _ _ _ _ _ = stack_error "red_component_clause";
=TEX

SPARK manual 13.5:
=SML
fun red_address_clause _ (Token ((_,CNText id), _)) _ _ (Parsed (PPExp exp)) _ = (
	PPRepresentationClause(RCAddress {name=id, exp=exp})
) | red_address_clause _ _ _ _ _ _ = stack_error "red_address_clause";
=TEX
=SML
end (* of structure *);
=TEX

\section{PARSER}\label{PARSER}
=SML
structure ÛCNParserÝ : CNParser = struct
=TEX
=SML
=TEX
We can now load the code generated by SLRP from the grammar
of 'cite{ISS/HAT/DAZ/DTD503}'.
=SML
local
	open CNParser;
=TEX
=INCLUDE
dtd503.grm.sml
=SML
in
=TEX
\subsection{Reader Function}\lab
=TEX
\subsection{Interface}
=TEX
=SML
fun Ûcn_readerÝ (ip : CN_LEX_ITEM list) : CN_LEX_ITEM * (CN_LEX_ITEM list) = (
	case ip of
		(h :: more) => (cur_tok := !cur_tok + 1; (h, more))
	|	[] => ((LCEos, CNEos), [])
);
=TEX
=SML
val Ûcn_errorÝ : (CN_LEX_ITEM, 'b, 'c, 'd) ERROR_ROUTINE = (fn (tok, stk, _, _) => (
	parse_error_hdr();
	diag_string (get_error_message 19003 [format_lex_item tok,
				format_stack format_lex_item stk]);
	raise SYNTAX_ERROR
));
=TEX
The following is adapted from the HOL parser in \cite{ISS/HAT/DAZ/IMP019} q.v.
for explanation.
=SML
fun Ûcn_parserÝ (ip : CN_LEX_ITEM list) : WEB_CLAUSE  = (
	let	val se1 = (input_toks := ip; cur_tok := ~1);
		val res = (slrp'gen_parser
				default_resolver
				fst
				cn_error
				cn_reader) ip;
		val se2 = (input_toks := []);
	in	case res of
		PPWebClause wc => wc
		|_ => fail "cn_parser" 503201 []
	end
);
=TEX
=TEX
\section{EPILOGUE}
=SML
end (* of local ... in *);
end (* of structure CNParser *);
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}

