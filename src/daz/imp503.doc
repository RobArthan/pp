% imp503.doc   @(#) 97/08/01 1.76 imp503.doc
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}	%% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Compliance Notation Parser}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP503}	%% Mandatory field
\def\SCCSversion{1.76%
}
\TPPissue{\SCCSversion}	%% Mandatory field
\TPPdate{\FormatDate{97/08/01%
}}
\TPPstatus{Draft}		%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the Compliance Notation Parser to meet the DRA's requirements for a Compliance Tool.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
    Library}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1-1.55] Initial Drafts.
\item[Issue 1.1-1.55] Initial Drafts.
\item[Issue 1.55-1.59] Bug fixes.
\item[Issue 1.60-1.64] Enhancements 1, 6 and 20.
\item[Issue 1.60-1.65] Enhancement 10.
\item[Issue 1.60-1.65] Enhancement 10.
\item[Issue 1.66] Bug 19 (batch 2).
\item[Issue 1.67] Operator associativity bug.
\item[Issue 1.68] Enhancement 3.
\item[Issue 1.69-1.71] Syntax changes for k-slots as annotations.
\item[Issue 1.72] Change a $stack\_error$ to a $parse\_error$ in $red\_subtype\_indication2\_a$.
\item[Issue 1.73] IUCT WP 7 enhancements.
\item[Issue 1.74] IUCT WP 3 changes.
\item[Issue 1.75] IUCT WP 4 changes.
\item[Issue 1.75] Made it apply ê to invariants and other cases.
\item[Issue 1.76] Added dummy cases for functions using $Z\_TM$, $Z\_PARA$, $Z\_EXP$.
		  Changes to allow compilation with zed.db.
\item[Issue 1.77] Changes to allow compilation with hol.db.
\item[Issue 1.78] Changes to allow compilation with just poly.db.
\item[Issue 1.79-1.83] Changes for NJML port and cut-down tool.
\item[Issues 1.84,1.85] Enhancement R5: Initial Variables in Conditionals.
The main change is that the {\it Stmt} and {\it Statement} data types are merged.
This removes the need for various special cases and type conversion functions.
\item[Issue 1.86] Enhancement R4: Frame Abbreviations.
\item[Issue 1.87] Enhancement R2: Multiple Logical Constants.
\item[Issue 1.88] CTLE II R1/7: empty package specifications.
\item[Issue 1.89,1.90] CTLE II R1/10: multiple with clauses.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the Compliance Notation parser for
HOL/Z. It covers the parsing of Compliance Notation Web Clauses. For Web clauses constituting Z paragraphs, the {\Product} Z Parser is used.

The detailed design for this implementation and the BNF form form of the implemented grammar is in \cite{ISS/HAT/DAZ/DTD503}.

\subsection{Introduction}

\subsection{Purpose and Background}

This document introduces the structure $CNParser$. This provides an implementation of a parser which corresponds to the language definition in \cite{ISS/HAT/DAZ/DTD502} which itself seeks to comply with DRA's specification of the concrete syntax of Compliance Notation.

\subsection{Known Deficencies}

This implementation aims to fully support the language definition of \cite{ISS/HAT/DAZ/DTD502}.

\subsection{Possible Enhancements}

None known.

\section{MISCELLANEOUS FUNCTIONS}\label{MISCELLANEOUSFUNCTIONS}

First we introduce the structure wrapping. The structure is developed
in stages and the official signature constraint is only applied at the
last stage.
=SML
structure €CNParser› (* stage 1 *) = struct
=TEX
=CUTDOWNVERSION
val dummy_z_tm : Z_TM = ();
=TEX
We need to include the SLRP driver code at this point:
=INCLUDE
imp018.sml
=TEX

=SML
    open SlrpDriver;
    open CNTypes;
    open ZLex; 
=FULLVERSION
    open ZParser; 
    open ZTermGenerator; 
    open ZTypeInference;
    open ZUserInterfaceSupport;
=TEX

\subsection{Miscellanea}
$stack\_error$ is for use during context-free parsing when the parsing stack
is corrupt.
=SML
fun €stack_error› (insert : string) : 'a = (
    diag_string(get_error_message 503202 []);
    BasicError.error "CN-Parser"  503203 [fn() => insert]
    );
=TEX

=SML
fun €weird_error› (insert : string) : 'a = (
    diag_string(get_error_message 503202 []);
    BasicError.error "CN-Parser"  503001 [fn() => insert]
    );
=TEX

To give error reports which are closely related to the actual input,
the following two variables are set up by the functions
$HOL\_parser$ and $HOL\_reader$. At any time during parsing $input\_toks$
can be expected to contain the totality of the token stream being parsed
and $toks\_read$ contains the offset in it of the token most recently
read (or is 
=INLINEFT
~1
=TEX
\ if nothing has been read yet).
=SML
val input_toks : CN_LEX_ITEM list ref = ref [];
val cur_tok : int ref = ref ~1;
=TEX

=SML
fun €format_lex_item›  ((_, tok) : CN_LEX_ITEM) : string =
    (case tok
        of CNZ _ => " <Z-Quotation> "
        |  CNText s => s
        |  CNString s => s
        |  CNKSlot s => "K-Slot"
        |  CNEos => "<End-of-Input>"
    );
=TEX

=SML
fun €format_input_items›  ((ip::rest) : Lex.INPUT list) : string = (
    let val s = (case ip
        of Lex.Char c => "`"^c^"`"
        |  Lex.Error s => "ERROR__"^(string_of_int s)
        |  Lex.Separator s => s
        |  Lex.String s => "\""^s^"\""
        |  Lex.Term t => string_of_term t
        |  Lex.Text s => s
        |  Lex.Type t => string_of_type t
        );
    in
        s^(format_input_items rest)
    end)
|   format_input_items _ = "";
=TEX

=SML
fun €parse_error_hdr› () : unit = (
    let val ok_toks =
            format_list format_lex_item ((!input_toks) to (!cur_tok-1)) " ";
        val bad_tok =
            if !cur_tok >= 0 andalso !cur_tok < length (!input_toks)
            then " <?> " ^ format_lex_item (nth (!cur_tok) (!input_toks))
            else "";
    in diag_string (get_error_message 19001 [ok_toks ^ bad_tok])
    end);
=TEX

The following function produces the error reports for the unexpected
token type of error:
=SML
fun €parse_error› (msg : int) (insert : string) : 'a = (
    parse_error_hdr();
    diag_string (get_error_message msg [insert]);
    raise SYNTAX_ERROR
    );
=TEX

\subsection{Support for Processing Z Fragments}

=SML
=FULLVERSION
fun €z_tm_of_z_para› (zp : Z_PARA) : Z_TM = 
(   case zp 
    of ZParaTerm (_, z_tm, _) => z_tm
    |  _ => weird_error "weird error in z_tm_of_z_para"
);
=TEX

=SML
fun €z_tm_of_z_tokens› (tokens : Z_TOKEN list) : Z_TM =
=FULLVERSION
(
    (z_tm_of_z_para o (z_parser {is_quot = true})) tokens
);
=CUTDOWNVERSION
 dummy_z_tm;
=TEX

=SML
fun €process_con_z_decl› (ztokens : ZLex.Z_TOKEN list) : (Z_ID * Z_TM) list = 
=FULLVERSION
(
let	val schtoks =
		ZTLsqbrack::((rev o tl o rev) ztokens)@[ZTRsqbrack, ZTEos];
	fun do1 (ZDDec (vs, tm, _)) = (
		map (fn v => (string_of_ident v, tm)) vs
	) | do1 _ = (
		 parse_error 503001
		"a schema-as-declaration is not allowed in a logical constant statement"
	);
in
	case z_tm_of_z_tokens schtoks of
		ZTmHorizSchema(decs,_, _) => flat (map do1 decs)
        |  _ => parse_error 503001 "badly formed declarations in logical constant statement"
end);
=CUTDOWNVERSION
  ("", [dummy_z_tm]);
=TEX


=SML
fun €process_aux_z_decl› (ztokens : ZLex.Z_TOKEN list) : (Z_ID * Z_TM) = 
=FULLVERSION
(
    let val schtoks =
        ZTLsqbrack::((rev o tl o rev) ztokens)@[ZTRsqbrack, ZTEos];
    in
        case z_tm_of_z_tokens schtoks 
        of ZTmHorizSchema([ZDDec ([tmpl],ty, _)],_, _) =>
            (string_of_ident tmpl, ty)
        |  _ => parse_error 503001 "badly formed auxiliary variable"
    end);
=CUTDOWNVERSION
 ("", dummy_z_tm);
=TEX
=SML
fun €process_frame› ([] : ZLex.Z_TOKEN list) : Z_ID list = []
|   process_frame [ZTEos] = []
|   process_frame ztokens = 
=FULLVERSION
(
    let val tuptoks = ZTLbrack::((rev o tl o rev) ztokens)@[ZTRbrack, ZTEos];
        fun get_name (ZTmLVar (id, _, _)) = string_of_ident id
        |   get_name _ = parse_error 503001 "badly formed frame";
        val z_tm = z_tm_of_z_tokens tuptoks;
    in
        case z_tm 
            of ZTmBracketed z_tm' => [get_name z_tm']
            |  ZTmTuple tml => map get_name tml
            |  _ => parse_error 503001 "badly formed frame"
    end);
=CUTDOWNVERSION
  [];

=TEX
=SML
fun process_predicate (ztokens : ZLex.Z_TOKEN list) : Z_TM = 
=FULLVERSION
(
let	val pi_tm = (
		case ZParserInternals.z_parser_pass_1 ztokens of
		ParGeneralTerm(tm, Nil) => 
			ParGeneralTerm (PredFancyFix(TmplPre
              	      (("ê", Nil), StubUS), "", [[tm]]),Nil)
		|  _ => parse_error 503001 "unexpected Z construct");
	fun aux parsed = (
		(z_tm_of_z_para o (ZParserInternals.z_parser_pass_2
			{is_quot = true})) parsed
	);
in	
  aux pi_tm
end);
=CUTDOWNVERSION
 dummy_z_tm;
=SML

fun €process_pre_and_post_conditions›
    (ztokens : ZLex.Z_TOKEN list) : Z_TM OPT * Z_TM = 
=FULLVERSION
(   let val genitoks =
            ZTLsqbrack::((rev o tl o rev) ztokens)@[ZTRsqbrack, ZTEos];
        val zpara = ZParserInternals.z_parser_pass_1 genitoks;
        fun apply_pi p = (
            case p 
            of ParGeneralTerm (PredGenInst [pp], Nil) => (
                (Nil, ParGeneralTerm (PredFancyFix(TmplPre
                    (("ê", Nil), StubUS), "", [[pp]]),Nil)))
            |  ParGeneralTerm (PredGenInst [p1,p2], Nil) => (
                (Value (ParGeneralTerm (PredFancyFix(TmplPre
                    (("ê", Nil), StubUS), "", [[p1]]),Nil)),
                    ParGeneralTerm (PredFancyFix(TmplPre
                    (("ê", Nil), StubUS), "", [[p2]]),Nil)))
            |  _ => parse_error 503001
                    "unexpected input after the post-condition"
        );
        val (pretm_opt, posttm) = apply_pi zpara;
        fun aux parsed = (
            (z_tm_of_z_para o (ZParserInternals.z_parser_pass_2
            {is_quot = true})) parsed
        );
    in

        case pretm_opt 
        of Value pre => (Value (aux pre), aux posttm)
        |Nil => (Nil, aux posttm)

    end);
=CUTDOWNVERSION
 (Nil, dummy_z_tm);
=TEX

The following functions support the external interface $z\_predexp\_of\_z\_tm$.
=FULLVERSION
fun €z_para_of_zinferred› ((ZInferred p) : Z_INFERRED) : Z_PARA = (p)
|   z_para_of_zinferred (ZTypeError inf) = (print_z_error inf);
=CUTDOWNVERSION
fun €z_para_of_zinferred› x = ();

=TEX
The following is used to give diagnostics, which may sometimes be helpful.
=SML
val €cn_show_typing_context› : bool ref = ref false;
val _ = new_flag{
	name="cn_show_typing_context",
	check=fun_true,
	control=cn_show_typing_context,
	default=fun_false} handle Fail _ => ();
=TEX
set_flag("cn_show_typing_context", true);
show_typing_context();
=FULLVERSION
fun €show_typing_context› (t : TERM) = (
	if	!cn_show_typing_context
	then	let	val cur_thy = get_current_theory_name();
			val zlib = (get_ancestors "z_library" less "z_library")
						handle Fail _ => [];
			val ancs = Sort.sort Sort.string_order
					(get_ancestors cur_thy less cur_thy)
					diff zlib;
			val tic = map dest_var (TypeInference.get_ti_context());
			fun do1tici (n, ty) = "  " ^ n ^ ": " ^ string_of_type ty;
		in	diag_line ("Current theory: " ^ cur_thy);
			diag_line
			(case zlib of [] => "Ancestors:"
			| _ => "Ancestors (up to z_library):");
			map (diag_line o (curry (op^) "  ")) ancs;
			diag_line
			(case tic of [] => "No type inference context."
			| _ => "Type inference context:");
			map (diag_line o do1tici) tic;
			diag_line ("Type-checked term: " ^ string_of_term t);
			()
		end
	else	()
);
=FULLVERSION
fun €term_of_z_para› ((ZParaTerm (gpars, tm, _)) : Z_PARA) : TERM = (
    let val vns = map string_of_ident gpars;
        val vs = map (fn vn =>
            mk_var(vn, mk_z_power_type(mk_vartype ("'" ^ vn)))) vns;
    in	list_mk_µ(vs, (do_in_theory
            (force_get_cache_theory()) term_of_z_tm tm))
    end)
|   term_of_z_para _ = (fail "z_term_recogniser" 49001 []);
=CUTDOWNVERSION
fun €term_of_z_para› () = mk_t;
=TEX

=SML
=FULLVERSION 
fun €z_predexp_of_z_tm› (z_tm : Z_TM) : Z_EXP =
(
    let
        val standard = get_flag "standard_z_terms";
        val z_para = ZParaTerm ([], z_tm, Nil);
        val type_checked = type_check_z_para
                {standard = standard, allow_frees = true} z_para;
        val para = z_para_of_zinferred type_checked;
	 val tm = term_of_z_para para;
    in  show_typing_context tm;
        tm
    end);
=TEX

=SML
end (* of structure CNParser stage 1*);
=TEX

\section{REDUCTION FUNCTIONS}\label{REDUCTIONFUNCTIONS}
=SML
structure €CNParser› (* stage 2 *) = struct
=TEX

=SML
open CaseIndependence CNParser;
=TEX

We give the reduction functions in the order of their appearance
in the grammar of \cite{ISS/HAT/DAZ/DTD503}. When several reduction
functions would be the same, we use $val$ bindings for the various
instances.

=SML
type €AGG› = {tm : TMARK OPT,
                named_assocs : (AGG_CHOICE,EXP) NAMED_ASSOC list,
                others : EXP OPT};
    
datatype €PPARSED› =
           €PPAgg› of AGG
        |  €PPAggregateChoices› of (AGG_CHOICE list * bool)
        |  €PPAnnotation› of ANNOTATION
        |  €PPBasicDecls› of BASIC_DECL list
        |  €PPBinaryOp› of BIN_OP
        |  €PPBinOpTail› of (BIN_OP * EXP) list
        |  €PPCaseAlternatives› of STATEMENT CASE_ALTERNATIVE list
        |  €PPCaseChoices› of CASE_CHOICE list
        |  €PPCompilationUnit› of COMPILATION_UNIT
        |  €PPComponentClauses› of COMPONENT_CLAUSE list
        |  €PPConstraint› of CONSTRAINT
        |  €PPContextClause› of 
			(ID list * (AGG_CHOICE, EXP) PRAGMA list) list *
			ID list *
			ANNOTATION
        |  €PPContextCompilationUnit› of CONTEXT_COMPILATION_UNIT
        |  €PPDeclarations› of DECLARATION list
        |  €PPDiscrete› of (ID OPT * (EXP * EXP OPT))
        |  €PPElsIf› of (EXP * STATEMENT) list
        |  €PPExp› of EXP
        |  €PPExps› of EXP list
        |  €PPFor› of (ID * ID * LOOP_DIRECTION * EXP RANGE OPT)
        |  €PPFormals› of PARAMETER_SPECIFICATION list
        |  €PPFunctionSpecification› of FUNCTION_SPECIFICATION
        |  €PPId› of ID
        |  €PPIdExp› of (ID * EXP)
        |  €PPIds› of ID list
        |  €PPKSlot› of K_SLOT
        |  €PPKSlotCUList› of KSLOT_COMPILATION_UNIT list
        |  €PPMode› of MODE
        |  €PPPackageSpecification› of DECLARATION PACKAGE_DECLARATION
        |  €PPPragma› of (AGG_CHOICE, EXP) PRAGMA
        |  €PPPragmaArgs› of (AGG_CHOICE OPT * EXP) list
        |  €PPPragmaList› of (AGG_CHOICE, EXP) PRAGMA list
        |  €PPPrimedIdentifier› of (ID * ID)
        |  €PPProcedureSpecification› of PROCEDURE_SPECIFICATION
        |  €PPProperBody› of PROPER_BODY
        |  €PPReltail› of (BIN_OP * EXP)
        |  €PPRepresentationClause› of REPRESENTATION_CLAUSE
        |  €PPSRExpression› of (EXP * EXP OPT)
        |  €PPStatement› of STATEMENT
        |  €PPSubprogram› of (DECLARATION list * STATEMENT * ID)
        |  €PPSubprogramSpec› of SUBPROGRAM_SPECIFICATION
        |  €PPSubtypeDeclaration› of (EXP * CONSTRAINT)
        |  €PPTypeDef› of TYPE_DEF
        |  €PPUnaryOp› of UNARY_OP
        |  €PPVarDecls› of VAR_DECL list
        |  €PPWebClause› of WEB_CLAUSE;
=TEX

=SML
fun €different_ids› (id1 : ID, id2 : ID) : bool = (
    (id1 <> id2)
    );
=TEX

=SML
fun €name_to_tmark› (e : EXP) : TMARK = (
    case e 
    of EId id => id
    |  ESelectedComp {prefix, selector} => (name_to_tmark prefix)^"o"^selector
    |  _ => "__invalid"
    );
=TEX

=SML
val €z_tm_true› = 
=FULLVERSION
  ZUserInterfaceSupport.ZTmTruth true; 
=CUTDOWNVERSION
  dummy_z_tm;
=TEX

=SML
fun €is_range_attribute› (EAttribute{attribute_desig=ad,...}) = (
    case ad 
    of ADAttrib attname => attname = "RANGE"
    |  ADAttribArg (attname,_) => attname = "RANGE")
    |  is_range_attribute _ = false;
=TEX

=SML
fun €sr_expression_to_range› ((e1, Value e2) : (EXP * EXP OPT)) : EXP RANGE = (
    RRange{lo=e1, hi=e2})
|   sr_expression_to_range (e, Nil) = (
    if is_range_attribute e
    then
        RRangeAttr e
    else
        parse_error 503001 "a RANGE is expected here"
    );
=TEX

=SML
fun €sr_expression_to_expression› ((e, Nil) : (EXP * EXP OPT)) : EXP = (
    if is_range_attribute e
    then
        parse_error 503001 "a RANGE is not permitted here"
    else
        e)
|   sr_expression_to_expression _ = (
    parse_error 503001 "a RANGE is not permitted here"
    );
=TEX

=TEX

\subsection{Support for Unlabelled KSlots and Specification Statements}

The following reference variable keeps a note of the last unlabelled kslot or specification statement.

=SML
val €unlabelled_stack› : string OPT ref = ref Nil;
val €unlabelled_provisional› : string OPT ref = ref Nil;
val €unlabelled_counter› : int ref = ref 1;
val €last_label› : LABEL ref = ref "";
=TEX

=SML
type €CN_PARSER_STATE› = {
    unlabelled_stack : string OPT,
    unlabelled_provisional : string OPT,
    unlabelled_counter : int,
    last_label : LABEL
    };
=TEX

=SML
fun €implicit_label_of_int› (i : int) = (
    (!last_label) ^ "_" ^ (string_of_int i)
    );
=TEX

=SML
fun €get_cn_parser_state› (() : unit) : CN_PARSER_STATE = (
    {
        unlabelled_stack = !unlabelled_stack,
        unlabelled_provisional = !unlabelled_provisional,
        unlabelled_counter = !unlabelled_counter,
        last_label = !last_label
    }
    );
=TEX

=SML
fun €set_cn_parser_state› (cnps : CN_PARSER_STATE) : unit = (
    unlabelled_stack := #unlabelled_stack cnps;
    unlabelled_provisional := #unlabelled_provisional cnps;
    unlabelled_counter := #unlabelled_counter cnps;
    last_label := #last_label cnps
    );
=TEX
=SML
fun €reset_cn_parser_state› () : unit = (
    unlabelled_stack := Nil;
    unlabelled_counter := 1;
    unlabelled_provisional := Nil;
    last_label := ""
    );
=TEX

When we encounter a k-slot or a specification statement with no label on the rhs, we give it a provisional label. The check that there is no outstanding unlabelled k-slot or specification statement happens later, at which point if all is OK, the provisional label becomes the actual label for expansion.
=SML
fun €push_label› (() : unit) : string = (
if !unlabelled_provisional = Nil
then
    let val label = implicit_label_of_int (!unlabelled_counter);
        val side = unlabelled_counter := (!unlabelled_counter) + 1;
        val side = unlabelled_provisional := Value label;
    in
        label
    end
else    (
    unlabelled_provisional := Nil;
    parse_error 503001
    "There is already an unlabelled, \
    \unexpanded K-Slot or Specification Statement in the script"
    )
    );
=TEX

The following function should be called when a refinement or replaced-by has been parsed. It updates the label stack with a newly generated label. This caters for a specification statement which is unlabelled, and is itself intended to be expanded with an unlabelled expansion.

=SML
fun €update_unlabelled_stack› (() : unit) : unit = (
    if !unlabelled_stack <> Nil
    then    if !unlabelled_provisional <> Nil
        then    (
            unlabelled_provisional := Nil;
            parse_error 503001
            "There is already an unlabelled, unexpanded K-Slot or Specification Statement in the script"
        )
        else    ()
    else    (
        unlabelled_stack := !unlabelled_provisional;
        unlabelled_provisional := Nil
    )
    );
=TEX

=SML
fun €pop_label› (() : unit) : string = (
case !unlabelled_stack 
    of Nil => parse_error 503001
        "there is no unlabelled k-slot or specification statement to expand"
    |Value label => (
        unlabelled_stack := Nil;
        label
    )
    );
=TEX

\subsection{Reduction Functions}
=SML
fun red_accept (Parsed pp) = (pp)
|   red_accept (Token ((l,CNText t),_)) = (
    stack_error ("red_accept [Token("
=POLYML
        ^(PolyML.makestring l)^", Text "^(PolyML.makestring t)^")]"))
=NJML
        ^"... )]"))
=SML
|   red_accept (Token ((l,t),_)) = (
    stack_error ("red_accept ["
=POLYML
        ^(PolyML.makestring l)^", "^(PolyML.makestring t)^"]"));
=NJML
        ^"... )]"))
=TEX

=SML
fun red_web_clause1 (Parsed (PPKSlotCUList cul)) = (
    update_unlabelled_stack();
    PPWebClause (WCCompilation cul))
|   red_web_clause1 _ =
        stack_error "red_web_clause1";

fun red_web_clause2
        (Token ((_, CNText lab), _)) _ (Parsed (PPKSlotCUList cul)) = (
    update_unlabelled_stack();
    PPWebClause (WCReplacedByCompilation {label=lab,comp=cul}))
|   red_web_clause2 _ _ _ =
        stack_error "red_web_clause2";

fun red_web_clause3
        (Token ((_,CNText lab), _)) _ (Parsed (PPDeclarations d)) = (
    update_unlabelled_stack();
    PPWebClause (WCReplacedByPrivatePart {label=lab, private=d}))
|   red_web_clause3 _ _ _ =
        stack_error "red_web_clause3";

fun red_web_clause4
        (Token ((_,CNText lab), _)) _ (Parsed (PPDeclarations d)) = (
    update_unlabelled_stack();
    PPWebClause (WCReplacedByVisiblePart {label=lab, visible=d}))
|   red_web_clause4 _ _ _ =
        stack_error "red_web_clause4";

fun red_web_clause5
        (Token ((_,CNText lab), _)) _ (Parsed (PPDeclarations d)) = (
    update_unlabelled_stack();
    PPWebClause (WCReplacedByDecl {label=lab, decls=d}))
|   red_web_clause5 _ _ _ =
        stack_error "red_web_clause5";

fun red_web_clause6
        (Token ((_,CNText lab), _)) _ (Parsed (PPStatement s)) = (
    update_unlabelled_stack();
    PPWebClause (WCReplacedBy {label=lab, statement=s}))
|   red_web_clause6 _ _ _ =
        stack_error "red_web_clause6";

fun red_web_clause7
        (Token ((_,CNText lab), _)) _ (Parsed (PPStatement s)) = (
    update_unlabelled_stack();
    PPWebClause (WCRefinedBy {label=lab, statement=s}))
|   red_web_clause7 _ _ _ =
        stack_error "red_web_clause7";

fun red_web_clause8 _ (Parsed (PPStatement s)) = (
let val lab = pop_label();
    val side = update_unlabelled_stack();
in
    PPWebClause (WCRefinedBy {label=lab, statement=s})
end)
|   red_web_clause8 _ _ =
        stack_error "red_web_clause8";

fun red_web_clause9
        (Token ((_,CNText lab), _)) _ (Parsed (PPStatement s)) = (
    update_unlabelled_stack();
    PPWebClause (WCReplacedBy {label=lab, statement=s}))
|   red_web_clause9 _ _ _ =
        stack_error "red_web_clause9";

fun red_web_clause10  _ (Parsed (PPStatement s)) = (
let val lab = pop_label();
    val side = update_unlabelled_stack();
in
    PPWebClause (WCReplacedBy {label=lab, statement=s})
end)
|   red_web_clause10 _ _ =
        stack_error "red_web_clause10";

fun red_web_clause11 (Parsed(PPId lab)) (Token ((LCArbitraryAda,CNText aa), _)) = (
    update_unlabelled_stack();
    PPWebClause (WCReplacedByArbitraryAda {label=lab, replacement=aa})
)|   red_web_clause11 _ _ =
        stack_error "red_web_clause11";

fun red_web_clause12 (Token ((LCArbitraryAda,CNText aa), _)) = (
let val lab = pop_label();
    val side = update_unlabelled_stack();
in
    PPWebClause (WCReplacedByArbitraryAda {label=lab, replacement=aa})
end
)|   red_web_clause12 _ =
        stack_error "red_web_clause12";

fun red_web_clause13
        (Token ((_,CNText lab), _))  _ (Parsed (PPAnnotation ann)) = (
    update_unlabelled_stack();
    PPWebClause (WCReplacedByAnnotation {label=lab, replacement=ann})
)|   red_web_clause13 _ _ _ =
        stack_error "red_web_clause13";

fun red_any_label (Token ((_,CNText lab), _)) =
    PPId lab
|   red_any_label _ = stack_error "red_any_label";
=TEX

=SML
val red_basic_declaration1 = red_accept;
val red_basic_declaration2 = red_accept;
val red_basic_declaration3 = red_accept;
val red_basic_declaration4 = red_accept;

fun red_basic_declaration5 (Parsed (PPPragma e)) = 
	PPBasicDecls[BDPragma e]
|   red_basic_declaration5 _ = stack_error "red_basic_declaration5";

fun red_basic_declaration6 (Token ((LCAnnotation,CNText ann), _)) = 
	PPBasicDecls[BDAnnotation [ANString ann]]
|   red_basic_declaration6 _ = stack_error "red_basic_declaration6";

val red_object_declaration1 = red_accept;
val red_object_declaration2 = red_accept;
=TEX

=SML
fun red_constant_declaration
        (Parsed(PPIds ids)) _ _ (Parsed(PPExp n)) _ (Parsed(PPExp e)) _ = (
    PPBasicDecls[BDConstDecl{consts=ids, tm=name_to_tmark n, expr=e}])
|   red_constant_declaration _ _ _ _ _ _ _ =
        stack_error "red_constant_declaration";

fun red_variable_declaration (Parsed(PPIds ids)) _ (Parsed(PPExp n)) _ = (
    PPBasicDecls[BDVarDecl{vars=ids, tmark=name_to_tmark n}])
|   red_variable_declaration _ _ _ _ =
        stack_error "red_variable_declaration";

fun red_variable_declaration2 (Parsed(PPIds ids)) _ (Parsed(PPExp n)) _ 
	(Parsed(PPExp init)) _ = (
    PPBasicDecls[BDVarDeclInit({vars=ids, tmark=name_to_tmark n}, init)])
|   red_variable_declaration2 _ _ _ _ _ _ =
        stack_error "red_variable_declaration2";

fun red_identifier_list1 (Token ((_,CNText id), _)) = (
    PPIds [id])
|   red_identifier_list1 _ =
        stack_error "red_identifier_list1";

fun red_identifier_list2 (Token ((_,CNText id), _)) _ (Parsed(PPIds ids)) = (
    PPIds (id::ids))
|   red_identifier_list2 _ _ _ =
        stack_error "red_identifier_list2";
=TEX

=SML
val red_type_declaration1 = red_accept;
val red_type_declaration2 = red_accept;
=TEX

=SML
fun red_full_type_declaration
        _ (Token ((_,CNText id), _)) _ (Parsed(PPTypeDef td)) _ = (
    PPBasicDecls[BDTypeDecl{name=id, type_def=td}])
|   red_full_type_declaration _ _ _ _ _ =
        stack_error "red_full_type_declaration";

=TEX

=SML
val red_type_definition1 = red_accept;
val red_type_definition2 = red_accept;
val red_type_definition3 = red_accept;
val red_type_definition4 = red_accept;
val red_type_definition5 = red_accept;
=TEX

=SML
fun red_subtype_declaration _ (Token ((_,CNText id), _)) _
        (Parsed(PPSubtypeDeclaration (n, c))) _ = (
    PPBasicDecls[BDSubtypeDecl{name=id,sub_ind={tmark=name_to_tmark n,con=c}}])
|   red_subtype_declaration _ _ _ _ _ =
        stack_error "red_subtype_declaration";

fun red_subtype_indication1 (Parsed(PPExp n)) (Parsed(PPConstraint c)) = (
        PPSubtypeDeclaration(n, c))
|   red_subtype_indication1 _ _ =
        stack_error "red_subtype_indication1";

fun red_subtype_indication2 (Parsed(PPExp n))  = (
    case n 
    of EIndexedComp{prefix=prefix,index=index} => (
        case index 
    of EArrayAggPos{comps=comps,...} =>
            PPSubtypeDeclaration(prefix, (CIndex comps))
        |_ => PPSubtypeDeclaration(n, CNoCon)
    ) |  _ =>
        PPSubtypeDeclaration(n, CNoCon))
|   red_subtype_indication2 _ =
        stack_error "red_subtype_indication2";
=TEX

=SML
fun red_constraint1 (Parsed(PPSRExpression sr)) = (
    PPConstraint (CRange (sr_expression_to_range sr)))
|   red_constraint1 _ =
        stack_error "red_constraint1";

val red_constraint2 = red_accept;
val red_constraint3 = red_accept;
=TEX

=SML
fun red_range_constraint _ (Parsed sr) = (
    sr)
|   red_range_constraint _ _ =
        stack_error "red_range_constraint";

fun red_enumeration_type_definition _ (Parsed(PPIds ids)) _ = (
    PPTypeDef(TDEnumTypeDef{vals = ids}))
|   red_enumeration_type_definition _ _ _ =
        stack_error "red_enumeration_type_definition";
=TEX

=SML
fun red_integer_type_definition (Parsed(PPSRExpression sr)) = (
    PPTypeDef(TDIntTypeDef (sr_expression_to_range sr)))
|   red_integer_type_definition _ =
        stack_error "red_integer_type_definition";

fun red_real_type_definition1 (Parsed(PPConstraint(CFloating c))) = (
    PPTypeDef(TDFloatingTypeDef c))
|   red_real_type_definition1 _ =
        stack_error "red_real_type_definition1";

fun red_real_type_definition2 (Parsed(PPConstraint (CFixed c))) = (
    PPTypeDef(TDFixedTypeDef c))
|   red_real_type_definition2 _ =
        stack_error "red_real_type_definition2";
=TEX

SPARK manual 3.5.7:
=SML
fun red_floating_point_constraint1 (Parsed(PPExp e)) = (
    PPConstraint(CFloating{exp=e, range=Nil}))
|   red_floating_point_constraint1 _ =
        stack_error "red_floating_point_constraint1";

fun red_floating_point_constraint2
        (Parsed(PPExp e)) (Parsed(PPSRExpression sr)) = (
    PPConstraint(CFloating{exp=e, range=Value (sr_expression_to_range sr)}))
|   red_floating_point_constraint2 _ _ =
        stack_error "red_floating_point_constraint2";

fun red_floating_accuracy_definition _ (Parsed p) = (p)
|   red_floating_accuracy_definition _ _ =
        stack_error "red_floating_accuracy_definition";
=TEX

=SML
fun red_fixed_point_constraint1 (Parsed(PPExp e)) = (
    PPConstraint(CFixed{exp=e, range=Nil}))
|   red_fixed_point_constraint1 _ =
        stack_error "red_fixed_point_constraint1";

fun red_fixed_point_constraint2 (Parsed(PPExp e)) (Parsed(PPSRExpression sr)) = (
        PPConstraint(CFixed{exp=e, range=Value (sr_expression_to_range sr)}))
|   red_fixed_point_constraint2 _ _ =
        stack_error "red_fixed_point_constraint2";

fun red_fixed_accuracy_definition _ (Parsed p) = (p)
|   red_fixed_accuracy_definition _ _ =
        stack_error "red_fixed_accuracy_definition";
=TEX

=SML
val red_array_type_definition1 = red_accept;
val red_array_type_definition2 = red_accept;
=TEX

=SML
fun red_unconstrained_array_definition _ _ (Parsed(PPExps nl)) _ _ (Parsed(PPExp n)) = (
    PPTypeDef(TDUnconArrayDef{index=map name_to_tmark nl,comp=name_to_tmark n}))
|   red_unconstrained_array_definition _ _ _ _ _ _ =
        stack_error "red_unconstrained_array_definition";

fun red_constrained_array_definition _ (Parsed(PPExps nl)) _ (Parsed(PPExp n)) = (
    PPTypeDef(TDConArrayDef{index=map name_to_tmark nl,comp=name_to_tmark n}))
|   red_constrained_array_definition _ _ _ _ =
        stack_error "red_constrained_array_definition";
=TEX

=SML
fun red_index_subtype_definition_list1 (Parsed(PPExp n)) = (
    PPExps [n])
|   red_index_subtype_definition_list1 _ =
        stack_error "red_index_subtype_definition_list1";
=TEX

=SML
fun red_index_subtype_definition_list2 (Parsed(PPExp n)) _ (Parsed(PPExps nl)) = (
    PPExps (n::nl))
|   red_index_subtype_definition_list2 _ _ _ =
        stack_error "red_index_subtype_definition_list2";

fun red_index_subtype_definition (Parsed p) _ _ = (
    p)
|   red_index_subtype_definition _ _ _ =
        stack_error "red_index_subtype_definition";
fun red_index_constraint _ (Parsed p) _ = (
    p    )
|   red_index_constraint _ _ _ =
        stack_error "red_index_constraint";

fun red_name_list1 (Parsed(PPExp n)) = (
    PPExps [n])
|   red_name_list1 _ =
        stack_error "red_name_list1";

fun red_name_list2 (Parsed(PPExp n)) _ (Parsed(PPExps nl)) = (
    PPExps (n::nl))
|   red_name_list2 _ _ _ =
        stack_error "red_name_list2";
=TEX

=SML
fun red_discrete_range1 (Parsed (PPExp e)) (Parsed (PPSRExpression sr)) = (
    PPDiscrete(Value (name_to_tmark e), sr))
|   red_discrete_range1 _ _ =
        stack_error "red_discrete_range1";

fun red_discrete_range2 (Parsed (PPSRExpression sr)) = (
    PPDiscrete(Nil, sr))
|   red_discrete_range2 _ =
        stack_error "red_discrete_range2";

fun red_record_type_definition _ (Parsed(PPVarDecls vs)) _ _ = (
    PPTypeDef(TDRecordTypeDef{decl=vs}))
|   red_record_type_definition _ _ _ _ =
        stack_error "red_record_type_definition";
=TEX


=SML
val red_component_list1 = red_accept;

fun red_component_list2 (Parsed(PPVarDecls[v])) (Parsed(PPVarDecls vs)) = (
    PPVarDecls (v::vs))
|   red_component_list2 _ _ =
        stack_error "red_component_list2";

fun red_component_declaration (Parsed(PPIds ids)) _ (Parsed(PPExp n)) _ = (
    PPVarDecls [{vars=ids, tmark=name_to_tmark n}])
|   red_component_declaration _ _ _ _ =
        stack_error "red_component_declaration";
=TEX

SPARK manual 3.9:
=TEX

=SML
val red_declarative_part1 = PPDeclarations [];

fun red_declarative_part2 (Parsed (PPDeclarations d1)) (Parsed (PPDeclarations d2)) = (
    PPDeclarations (d1@d2))
|   red_declarative_part2 _ _ =
        stack_error "red_declarative_part2";
=TEX

=SML
fun red_dec1 (Parsed(PPKSlot k)) = (
    PPDeclarations [DDeclarationKSlot (k, DKDeclaration)])
|   red_dec1 _ =
        stack_error "red_dec1";

val red_dec2 = red_accept;
val red_dec3 = red_accept;
val red_dec4 = red_accept;
val red_dec5 = red_accept;
=TEX

=SML
fun red_basic_declarative_item1 (Parsed(PPBasicDecls bds)) = (
    PPDeclarations(map (fn x => DBasicDecl x) bds))
|   red_basic_declarative_item1 _ =
        stack_error "red_basic_declarative_item1";

fun red_basic_declarative_item2 (Parsed(PPRepresentationClause rc)) = (
    PPDeclarations [DRepresentationClause rc])
|   red_basic_declarative_item2 _ =
        stack_error "red_basic_declarative_item2";

fun red_body1 (Parsed(PPProperBody p)) = (
    PPDeclarations[DProperBody p])
|   red_body1 _ =
        stack_error "red_body1";
val red_body2 = red_accept;

val red_proper_body1 = red_accept;
val red_proper_body2 = red_accept;
=TEX

=SML
fun red_name1 (Token ((_,CNText name), _)) = (
    PPExp(EId name))
|   red_name1 _ =
        stack_error "red_name1";

val red_name2 = red_accept;
val red_name3 = red_accept;
val red_name4 = red_accept;
=TEX

SPARK manual 4.1.1:
=SML
fun red_indexed_component (Parsed(PPExp n)) (Parsed(PPExp index)) = (
    case (n, index) 
    of (EAttribute {prefix=prefix,attribute_desig=ADAttrib ad}, _) => (
        case index of
            EArrayAggPos{comps = [e], ...} => (
                   PPExp(EAttribute
                      {prefix=prefix,attribute_desig=ADAttribArg(ad,e)})
        ) | _ => parse_error 503001
                 "this form of parameter list is not allowed with an attribute"
    ) |  (_, EArrayAggNamedOthers _) => (
        parse_error 503001 "OTHERS is not allowed here"
    ) |  (_, EArrayAggPosOthers _) => (
        parse_error 503001 "OTHERS is not allowed here"
    ) |  (_, EArrayAggOthers _) => (
        parse_error 503001 "OTHERS is not allowed here"
    ) |_ => (
        PPExp(EIndexedComp{prefix=n, index=index})
    ))
|   red_indexed_component _ _ =
        stack_error "red_indexed_component";
=TEX

SPARK manual 4.1.3:
=SML
fun red_selected_component (Parsed(PPExp n)) _ (Parsed(PPId id)) = (
    PPExp(ESelectedComp{prefix=n, selector=id}))
|   red_selected_component _ _ _ =
        stack_error "red_selected_component";

fun red_selector (Token ((_,CNText id), _)) = (
    PPId id)
|   red_selector _ =
        stack_error "red_selector";
=TEX

SPARK manual 4.1/4.1.1:
=SML
fun red_expression_list1 (Parsed(PPExp e)) = (
    PPExps [e])
|   red_expression_list1 _ =
        stack_error "red_expression_list1";

fun red_expression_list2 (Parsed(PPExps es)) _ (Parsed(PPExp e)) = (
    PPExps (es@[e]))
|   red_expression_list2 _ _ _ =
        stack_error "red_expression_list2";
=TEX

=SML
fun red_attribute1 (Parsed(PPExp n)) (Token ((_,CNText primedid), _)) = (
    PPExp(EAttribute{prefix=n, attribute_desig=ADAttrib
    ((implode o tl o explode) primedid)}))
|   red_attribute1 _ _ =
        stack_error "red_attribute1";

fun red_attribute2 (Token ((CharacterLiteral,CNString id), _))
    (Token ((_,CNText primedid), _)) = (
    PPExp(EAttribute{prefix=ECharacterLiteral id, attribute_desig=ADAttrib
    ((implode o tl o explode) primedid)}))
|   red_attribute2 _ _ =
        stack_error "red_attribute2";

fun red_aggregate _ (Parsed p) _ = (
    p)
|   red_aggregate _ _ _ =
        stack_error "red_aggregate";
=TEX

=SML
fun red_component_association1 (Parsed(PPAgg{named_assocs=na,others=ot,...})) = (
    case (ot, na) 
    of (Value oe, _::_) => (
        PPExp (EArrayAggNamedOthers{
            agg_named={tmark=Nil, named_assocs=na},others={others=oe}})
    )|  (Value oe, _) => (
        PPExp (EArrayAggOthers{tmark=Nil, others={others=oe}})
    )|(Nil, _) => (
        PPExp (EArrayAggNamed{tmark=Nil, named_assocs=na})
    ))
|   red_component_association1 _ =
        stack_error "red_component_association1";

val red_component_association2 = red_accept;

=TEX

=SML
fun red_named_association1 (Parsed(PPAggregateChoices v)) _ (Parsed(PPExp e)) = (
    case v 
    of ([],true) => PPAgg{tm=Nil, named_assocs=[], others=Value e}
    |(c, false) => PPAgg{tm=Nil, named_assocs =[{choice=c, comp=e}],others=Nil}
    |_ => parse_error 503001 "OTHERS is not allowed here")
|   red_named_association1 _ _ _ =
        stack_error "red_named_association1";

fun red_named_association2 (Parsed(PPAggregateChoices v)) _
    (Parsed(PPExp e)) _ (Parsed(PPAgg {named_assocs=na,others=ot,...})) = (
    case v 
    of (c as _::_, false) =>
        PPAgg{tm=Nil,named_assocs={choice=c,comp=e}::na,others=ot}
    |_ => parse_error 503001 "OTHERS is not allowed here")
|   red_named_association2 _ _ _ _ _ =
        stack_error "red_named_association2";

fun red_aggregate_choice_list1 (Token ((LCOthers,_), _)) = (
    PPAggregateChoices ([], true))
|   red_aggregate_choice_list1 _ =
        stack_error "red_aggregate_choice_list1";

val red_aggregate_choice_list2 = red_accept;

fun red_aggregate_choice_list3 (Parsed(PPAggregateChoices v)) _
    (Parsed(PPAggregateChoices (acl, true))) = (
    parse_error 503001 "OTHERS is not allowed here")
|   red_aggregate_choice_list3 (Parsed(PPAggregateChoices v)) _
    (Parsed(PPAggregateChoices (acl, false))) = (
    case v 
    of ([ac], false) => PPAggregateChoices((ac::acl), false)
    |_ => parse_error 503001 "OTHERS is not allowed here")
|   red_aggregate_choice_list3 _ _ _ =
        stack_error "red_aggregate_choice_list3";
=TEX

=SML
fun red_aggregate_choice (Parsed(PPDiscrete (idopt, sr))) = (
    case (idopt, sr) 
    of (Value id, _) => (
        PPAggregateChoices([ACAggChoiceRange(DRConstrained
                {tmark=id,range=sr_expression_to_range sr})],false)
    ) |(Nil, (e1, Value e2)) => (
        PPAggregateChoices([ACAggChoiceRange
            (DRRange(sr_expression_to_range sr))],false)
    ) |(Nil, (e, Nil)) => (
        if is_range_attribute e
        then
            PPAggregateChoices([ACAggChoiceRange
                (DRRange(sr_expression_to_range sr))],false)
        else
            PPAggregateChoices([ACAggChoiceSingle
                (sr_expression_to_expression sr)],false)
    ))
|   red_aggregate_choice _ =
        stack_error "red_aggregate_choice";

fun red_positional_association1 (Parsed(PPExps es)) = (
    PPExp(EArrayAggPos{tmark=Nil,comps = es}))
|   red_positional_association1 _ =
        stack_error "red_positional_association1";

fun red_positional_association2 (Parsed(PPExps es)) _ _ _ (Parsed(PPExp e)) = (
    PPExp(EArrayAggPosOthers{agg_pos={tmark=Nil,comps=es},
        others={others=e}}))
|   red_positional_association2 _ _ _ _ _ =
        stack_error "red_positional_association2";
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
=SML
val red_expression1 = red_accept;

fun red_expr (Parsed (PPExp exp1)) (Parsed (PPReltail(binop, exp2))) = (
    PPExp (EBinExp {bop = binop, left = exp1, right = exp2}))
|   red_expr _ _ =
        stack_error "red_expr";

val red_expression2 = red_expr;
val red_expression3 = red_expr;
val red_expression4 = red_expr;
val red_expression5 = red_expr;
val red_expression6 = red_expr;
=TEX

=SML
fun red_logrel1 binop (Parsed(PPExp exp)) = (
    PPReltail(binop, exp))
|   red_logrel1 _ _ =
        stack_error "red_logrel1";

fun red_logrel2 binop (Parsed(PPExp exp1)) (Parsed(PPReltail(_,exp2))) = (
    PPReltail(binop, EBinExp{bop=binop, left=exp1, right=exp2}))
|   red_logrel2 _ _ _ =
        stack_error "red_logrel2";

fun red_and_relation1 _ x2 =(red_logrel1 BOSparkAnd x2);
fun red_and_relation2 _ x2 x3 =(red_logrel2 BOSparkAnd x2 x3);
fun red_and_then_relation1 _ _ x3 =(red_logrel1 BOSparkAndThen x3);
fun red_and_then_relation2 _ _ x3 x4 =(red_logrel2 BOSparkAndThen x3 x4);
fun red_or_relation1 _ x2 =(red_logrel1 BOSparkOr x2);
fun red_or_relation2 _ x2 x3 =(red_logrel2 BOSparkOr x2 x3);
fun red_or_else_relation1 _ _ x3 =(red_logrel1 BOSparkOrElse x3);
fun red_or_else_relation2 _ _ x3 x4 =(red_logrel2 BOSparkOrElse x3 x4);
fun red_xor_relation1 _ x2 =(red_logrel1 BOSparkXor x2);
fun red_xor_relation2 _ x2 x3 =(red_logrel2 BOSparkXor x2 x3);
=TEX

=SML
fun red_relation1 (Parsed(PPSRExpression sr)) = (
    PPExp (sr_expression_to_expression sr))
|   red_relation1 _ =
        stack_error "red_relation1";

fun red_relation2 (Parsed(PPSRExpression sr1)) (Parsed(PPBinaryOp b))
    (Parsed(PPSRExpression sr2)) = (
    PPExp(EBinExp{left=sr_expression_to_expression sr1,bop=b,
                right=sr_expression_to_expression sr2}))
|   red_relation2 _ _ _ =
        stack_error "red_relation2";

fun red_relation3 (Parsed(PPSRExpression sr1)) _
    (Parsed(PPSRExpression (sr2 as (e1, Value e2) : (EXP * EXP OPT)))) = (
    PPExp(EMemRange{left=sr_expression_to_expression sr1, mop=BOSparkMem,
                range=sr_expression_to_range sr2}))
|   red_relation3 (Parsed(PPSRExpression sr1)) _
    (Parsed(PPSRExpression (sr2 as (e, Nil) : (EXP * EXP OPT)))) = (
    case (is_range_attribute e)
    of true => PPExp(EMemRange{left=sr_expression_to_expression sr1,
        mop=BOSparkMem, range=sr_expression_to_range sr2})
    | false => PPExp(EBinExp{left=sr_expression_to_expression sr1,
        bop=BOSparkMem, right=sr_expression_to_expression sr2}))
|   red_relation3 _ _ _ =
        stack_error "red_relation3";

fun red_relation4 (Parsed(PPSRExpression sr1)) _ _
    (Parsed(PPSRExpression (sr2 as (e1, Value e2) : (EXP * EXP OPT)))) = (
    PPExp(EMemRange{left=sr_expression_to_expression sr1, mop=BOSparkNotMem,
                range=sr_expression_to_range sr2}))
|   red_relation4 (Parsed(PPSRExpression sr1)) _ _
    (Parsed(PPSRExpression (sr2 as (e, Nil) : (EXP * EXP OPT)))) = (
    case (is_range_attribute e)
    of true => PPExp(EMemRange{left=sr_expression_to_expression sr1,
        mop=BOSparkNotMem, range=sr_expression_to_range sr2})
    | false => PPExp(EBinExp{left=sr_expression_to_expression sr1,
        bop=BOSparkNotMem, right=sr_expression_to_expression sr2}))
|   red_relation4 _ _ _ _ =
        stack_error "red_relation4";
=TEX

=SML
fun red_sr_expression1 (Parsed(PPExp e)) = (
    PPSRExpression (e, Nil))
|   red_sr_expression1 _ =
        stack_error "red_sr_expression1";

fun red_sr_expression2 (Parsed(PPExp e1)) _ (Parsed(PPExp e2)) = (
    PPSRExpression (e1, Value e2))
|   red_sr_expression2 _ _ _ =
        stack_error "red_sr_expression2";
=TEX

=SML
fun do_binarytail left ((b,right)::(rest as (_::_))) = (
   do_binarytail (EBinExp{left=left, bop=b, right=right}) rest)
|   do_binarytail left [(b,right)] = (
    EBinExp{left=left, bop=b, right=right})
|   do_binarytail left [] = left;

fun red_simple_expression1 (Parsed(PPExp e)) (Parsed(PPBinOpTail tl)) = (
    PPExp (do_binarytail e tl))
|   red_simple_expression1 _ _ =
        stack_error "red_simple_expression1";

fun red_simple_expression2 (Parsed(PPUnaryOp uop)) (Parsed(PPExp e))
    (Parsed(PPBinOpTail tl)) = (
    PPExp (do_binarytail (EUnaryExp{uop=uop,right=e}) tl))
|   red_simple_expression2 _ _ _ =
        stack_error "red_simple_expression2";

val red_binoptail1 = PPBinOpTail [];

fun red_binoptail2 (Parsed(PPBinaryOp b)) (Parsed(PPExp e))
    (Parsed(PPBinOpTail tl)) = (
    PPBinOpTail((b,e)::tl))
|   red_binoptail2 _ _ _ =
        stack_error "red_binoptail2";

val red_term1 = red_accept;

fun red_term2 (Parsed(PPExp e1)) (Parsed(PPBinaryOp m)) (Parsed(PPExp e2)) = (
    PPExp(EBinExp{left=e1,bop=m,right=e2}))
|   red_term2 _ _ _ =
        stack_error "red_term2";
=TEX

=SML
val red_factor1 = red_accept;
fun red_factor2 (Parsed(PPExp e1)) _ (Parsed(PPExp e2)) = (
    PPExp(EBinExp{left=e1,bop=BOSparkExpon,right=e2}))
|   red_factor2 _ _ _ =
        stack_error "red_factor2";

fun red_factor3 _ (Parsed(PPExp e)) = (
    PPExp(EUnaryExp{uop=UOSparkAbs, right=e}))
|   red_factor3 _ _ =
        stack_error "red_factor3";

fun red_factor4 _ (Parsed(PPExp e)) = (
    PPExp(EUnaryExp{uop=UOSparkNot, right=e}))
|   red_factor4 _ _ =
        stack_error "red_factor4";
=TEX

=SML
fun red_primary1 (Token ((LCNumericLiteral,CNText n), _)) = (
    PPExp (EInt n))
|   red_primary1 _ =
        stack_error "red_primary1";

fun red_primary2 (Token ((LCCharacterLiteral,CNString c), _)) = (
    PPExp (ECharacterLiteral c))
|   red_primary2 _ =
        stack_error "red_primary2";

fun red_primary3 (Token ((LCStringLiteral,CNString s), _)) = (
    PPExp (EStringLiteral s))
|   red_primary3 _ =
        stack_error "red_primary3";

val red_primary4 = red_accept;
val red_primary5 = red_accept;
fun red_primary6 (Parsed (PPExp (EArrayAggPos{tmark=Nil,comps = [e]}))) = (
    PPExp (EBracketed e))
|   red_primary6 (Parsed pagg) = pagg
|   red_primary6 _ = stack_error "red_primary6";

val red_primary7 = red_accept;
=TEX

=SML
fun red_relational_operator1 _ = PPBinaryOp BOSparkEq;
fun red_relational_operator2 _ = PPBinaryOp BOSparkNotEq;
fun red_relational_operator3 _ = PPBinaryOp BOSparkLess;
fun red_relational_operator4 _ = PPBinaryOp BOSparkLessEq;
fun red_relational_operator5 _ = PPBinaryOp BOSparkGreater;
fun red_relational_operator6 _ = PPBinaryOp BOSparkGreaterEq;
fun red_binary_adding_operator1 _ = PPBinaryOp BOSparkAdd;
fun red_binary_adding_operator2 _ = PPBinaryOp BOSparkMinus;
fun red_binary_adding_operator3 _ = PPBinaryOp BOSparkConcat;
=TEX

=SML
fun red_unary_adding_operator1 x1 = PPUnaryOp UOSparkUnaryAdd;
fun red_unary_adding_operator2 x1 = PPUnaryOp UOSparkUnaryMinus;
fun red_multiplying_operator1 x1 = PPBinaryOp BOSparkTimes;
fun red_multiplying_operator2 x1 = PPBinaryOp BOSparkIntdiv;
fun red_multiplying_operator3 x1 = PPBinaryOp BOSparkMod;
fun red_multiplying_operator4 x1 = PPBinaryOp BOSparkRem;
=TEX

=SML
fun red_qualified_expression (Parsed(PPExp n)) _ (Parsed(PPExp e)) = (
    PPExp(EQualifiedExp{tmark=name_to_tmark n, exp=e}))
|   red_qualified_expression _ _ _ =
        stack_error "red_qualified_expression";
=TEX

=SML
val red_sequence_of_statements1 = red_accept;

fun red_sequence_of_statements2 (Parsed (PPStatement st1)) (Parsed(PPStatement st2)) = (
    PPStatement(STSemicolon(st1, st2))
) | red_sequence_of_statements2 _ _ =
        stack_error "red_sequence_of_statements2";

fun red_statement1 (Parsed(PPKSlot k)) = (
    PPStatement(STKSlot k))
|   red_statement1 _ =
        stack_error "red_statement1";

fun red_statement2 (Parsed(PPStatement(STSpecNoIvars{spec=spec, ...}))) = (
    PPStatement(STSpecNoIvars{spec=spec, label=push_label()}))
|   red_statement2 _ = stack_error "red_statement2";

fun red_statement3 (Parsed(PPStatement(STSpecNoIvars{spec=spec, ...})))
			(Parsed(PPId label)) = (
    last_label := label;
    PPStatement(STSpecNoIvars{spec=spec, label=label}))
|   red_statement3 _ _ = stack_error "red_statement3";

fun red_statement4 _ (Token ((LCZ,CNZ z1), _)) _
    (Parsed(PPStatement(STSpecNoIvars {spec=s, ...}))) = (
let	val ns_ts = process_con_z_decl z1;
	fun mk_log_con_def (n, t) = {x = n, t = t, e = mk_z_true};
in
	PPStatement(SLogCon{defs = map mk_log_con_def ns_ts, spec=s,
		pre1 = mk_z_true, label=push_label()})
end)
|   red_statement4 _ _ _ _ =
        stack_error "red_statement4";

fun red_statement5 _ (Token ((LCZ,CNZ z1), _)) _
		(Parsed(PPStatement(STSpecNoIvars {spec=s, ...})))
		(Parsed(PPId label)) = (
let	val ns_ts = process_con_z_decl z1;
	fun mk_log_con_def (n, t) = {x = n, t = t, e = mk_z_true};
in
	(last_label := label;
	PPStatement(SLogCon{defs = map mk_log_con_def ns_ts, spec=s,
		pre1 = mk_z_true, label=label}))
end)
|   red_statement5 _ _ _ _ _ =
        stack_error "red_statement5";

val red_statement6 = red_accept;
val red_statement7 = red_accept;
fun red_statement8 (Parsed (PPPragma e)) = 
	PPStatement(STPragma e)
|   red_statement8 _ = stack_error "red_statement8";

fun red_statement9 (Token ((LCAnnotation,CNText ann), _)) = 
	PPStatement(STAnnotation [ANString ann])
|   red_statement9 _ = stack_error "red_statement9";

=TEX

=SML
fun red_specification_statement1 _ (Token ((LCZ,CNZ z1), _)) _
    (Token ((LCZ,CNZ z2), _)) _ = (
    let val (pre, post) =
            case process_pre_and_post_conditions z2 
            of (Value pre', post') => (pre', post')
            |  (Nil, post') => (z_tm_true, post');
        val w=process_frame z1;
in
    PPStatement(STSpecNoIvars{spec={w=w, w0=[], pre=pre, post=post},
			label=""})
end)
|   red_specification_statement1 _ _ _ _ _ =
        stack_error "red_specification_statement1";

fun red_specification_statement2 _ (Token ((LCZ,CNZ z1), _)) _
    (Token ((LCZ,CNZ z2), _)) _ = (
let val (pre, post) = 
    (process_predicate z2, z_tm_true);
    val w=process_frame z1;
in
    PPStatement(STSpecNoIvars{spec={w=w, w0=[], pre=pre,post=post},
			label=""})
end)
|   red_specification_statement2 _ _ _ _ _ =
        stack_error "red_specification_statement2";
=TEX
=SML
fun red_specification_statement3 _ _ (Token ((LCZ,CNZ z1), _)) _ = (
    let val (pre, post) =
            case process_pre_and_post_conditions z1
            of (Value pre', post') => (pre', post')
            |  (Nil, post') => (z_tm_true, post');
in
    PPStatement(STSpecNoIvars{spec={w=[], w0=[], pre=pre, post=post},
			label=""})
end)
|   red_specification_statement3 _ _ _ _ =
        stack_error "red_specification_statement3";

fun red_specification_statement4 _ _ (Token ((LCZ,CNZ z1), _)) _ = (
let val (pre, post) = 
    (process_predicate z1, z_tm_true);
in
    PPStatement(STSpecNoIvars{spec={w=[], w0=[], pre=pre,post=post},
			label=""})
end)
|   red_specification_statement4 _ _ _ _ =
        stack_error "red_specification_statement4";
=TEX
=SML
fun red_label _ (Token ((LCNumericLiteral,CNText n), _)) _ = (
    if is_all_decimal n
    then
        PPId n
    else
        parse_error 503001 "label can only contain digits")
|   red_label _ _ _ =
        stack_error "red_label";

fun red_k_slot1 _ (Token ((LCKSlot,CNKSlot lx), _)) _ = (
    PPKSlot{content=format_input_items lx, label=push_label()})
|   red_k_slot1 _ _ _ =
        stack_error "red_k_slot1";

fun red_k_slot2 _ (Token ((LCKSlot,CNKSlot lx), _)) _ (Parsed(PPId lab)) = (
    last_label := lab;
    PPKSlot{content=format_input_items lx, label= lab})
|   red_k_slot2 _ _ _ _ =
        stack_error "red_k_slot2";
=TEX

=SML
val red_simple_statement1 = red_accept;
val red_simple_statement2 = red_accept;
val red_simple_statement3 = red_accept;
val red_simple_statement4 = red_accept;
val red_simple_statement5 = red_accept;
val red_compound_statement1 = red_accept;
val red_compound_statement2 = red_accept;
val red_compound_statement3 = red_accept;
=TEX

=SML
fun red_null_statement _ _ = PPStatement STNull;

fun red_assignment_statement (Parsed(PPExp n)) _ (Parsed(PPExp e)) _ = (
    PPStatement(STAssign{name=n, e=e}))
|   red_assignment_statement _ _ _ _ =
        stack_error "red_assignment_statement";
=TEX

=SML
fun red_if_statement _ (Parsed(PPExp exp)) _ (Parsed(PPStatement st)) 
    (Parsed(PPElsIf ei)) (Parsed(PPStatement el)) _ _ _ = (
let val css = (exp, st)::ei;
    fun aux ((c,s)::(rest as (_::_))) = (
        (STIfThenElse{g=c,p=s,q=aux rest,elsif=true})
    ) |  aux [(c,s)] = (
        (STIfThenElse{g=c,p=s,q=el,elsif=false})
    ) |  aux _ = STImplicitNull;
in
    PPStatement (aux css)
end)
|   red_if_statement _ _ _ _ _ _ _ _ _ =
        stack_error "red_if_statement";
=TEX

=SML
val red_elsif_part1 = PPElsIf [];
fun red_elsif_part2 _ (Parsed (PPExp exp)) _ (Parsed(PPStatement st))
    (Parsed(PPElsIf ei)) = (
    PPElsIf ((exp, st)::ei))
|   red_elsif_part2 _ _ _ _ _ =
        stack_error "red_elsif_part2";
=TEX

=SML
val red_else_part1 = PPStatement STImplicitNull;

fun red_else_part2 _ (Parsed p) = p
|   red_else_part2 _ _ =
        stack_error "red_else_part2";

val red_condition = red_accept;
=TEX

=SML
fun red_case_statement _ (Parsed(PPExp e)) _ (Parsed(PPCaseAlternatives cs))
    (Parsed(PPStatement others)) _ _ _ = (
    PPStatement(STCase{e=e, s=cs, others=others}))
|   red_case_statement _ _ _ _ _ _ _ _ =
        stack_error "red_case_statement";

val red_case_statement_alternative_list1 = red_accept;

fun red_case_statement_alternative_list2 (Parsed(PPCaseAlternatives cs))
    (Parsed(PPCaseAlternatives [c])) = (
    PPCaseAlternatives (cs@[c]))
|   red_case_statement_alternative_list2 _ _ =
    stack_error "red_case_statement_alternative_list2";

fun red_case_statement_alternative _ (Parsed(PPCaseChoices c)) _
    (Parsed(PPStatement st)) = (
    PPCaseAlternatives[{choices=c, p=st}])
|   red_case_statement_alternative _ _ _ _ =
    stack_error "red_case_statement_alternative";
=TEX

=SML
val red_case_choice_list1 = red_accept;

fun red_case_choice_list2 (Parsed(PPCaseChoices [ac])) _
    (Parsed(PPCaseChoices acl)) = (
    PPCaseChoices(ac::acl))
|   red_case_choice_list2 _ _ _ =
        stack_error "red_acase_choice_list2";
=TEX

=SML
fun red_case_choice (Parsed(PPDiscrete (idopt, sr))) = (
    case (idopt, sr) 
    of (Value id, _) => (
        PPCaseChoices[CCCaseRange(DRConstrained
                {tmark=id,range=sr_expression_to_range sr})]
    ) |(Nil, (e1, Value e2)) => (
        PPCaseChoices[CCCaseRange(DRRange(sr_expression_to_range sr))]
    ) |(Nil, (e, Nil)) => (
        if is_range_attribute e
        then
            PPCaseChoices[CCCaseRange(DRRange(sr_expression_to_range sr))]
        else
            PPCaseChoices[CCCaseExp(sr_expression_to_expression sr)]
    ))
|   red_case_choice _ =
        stack_error "red_case_choice";

val red_others_part1 = PPStatement STImplicitNull;

fun red_others_part2 _ _ _ (Parsed p) = p
|   red_others_part2 _ _ _ _ =
        stack_error "red_others_part2";

=TEX

SPARK manual 5.5:
=SML
fun red_loop_statement (Parsed(PPIds ids)) (Parsed p) (Parsed(PPExps es))
    (Parsed(PPStatement st)) (Parsed(PPIds ids')) _ = (
let val side = case (ids', ids) 
    of ([id'], [id]) => (
            if different_ids (id', id)
            then    parse_error 503001 "LOOP names do not match"
            else    ()
        )|  _ => (
            ()
        );
    val name = case ids 
    of [id] => Value id
            |_ => Nil;
    val till = case es 
    of [EAuxiliaryExp tm] => Value tm
            |_ => Nil;
in
    case p 
    of PPExp c => (
            PPStatement(STWhile{name=name, g=c, loop={t=till, stmt=st}})
    ) |PPFor(id, tm, dir, opr) => (
        case opr 
    of Value range => (
            PPStatement(STForStatic{name=name, tmark=tm, i=id,
            range=range, dir=dir,loop={t=till, stmt=st}})
        ) |Nil => (
            PPStatement(STForTmark{name=name,i=id, tmark=tm, dir=dir,
            loop={t=till, stmt=st}})
        )
    ) |  PPId "__no_scheme" => (
        case name 
    of Value n => (
            PPStatement(STNamedLoop{name=n,t=till, stmt=st})
        ) |Nil => (
            PPStatement(STLoop{t=till, stmt=st})
        )
    ) |  _ => stack_error"red_loop_statement_a"
end)
|   red_loop_statement _ _ _ _ _ _ =
        stack_error "red_loop_statement";
=TEX
=SML
fun red_loop_body _ (Parsed(pst as PPStatement _)) _ _ = pst
|   red_loop_body _ _ _ _  = stack_error "red_loop_body";
=TEX
=SML
val red_name_opt11 = PPIds[];

fun red_name_opt12 (Token ((_,CNText id), _)) _ = (
    PPIds [id])
|   red_name_opt12 _ _ =
        stack_error "red_name_opt12";

val red_name_opt21 = PPIds [];

fun red_name_opt22 (Token ((_,CNText id), _)) = (
    PPIds [id])
|   red_name_opt22 _ =
        stack_error "red_name_opt22";

val red_iteration_scheme_opt1 = PPId "__no_scheme";

val red_iteration_scheme_opt2 = red_accept;

fun red_iteration_scheme1 _ (Parsed p) = (p)
|   red_iteration_scheme1 _ _ =
        stack_error "red_iteration_scheme1";

fun red_iteration_scheme2 _ (Parsed p) = (p)
|   red_iteration_scheme2 _ _ =
        stack_error "red_iteration_scheme2";

fun red_loop_parameter_specification1 (Token ((_,CNText id), _)) _
    (Parsed(PPExp n)) = (
    PPFor(id,name_to_tmark n, LDForwards, Nil))
|   red_loop_parameter_specification1 _ _ _ =
    stack_error "red_loop_parameter_specification1";

fun red_loop_parameter_specification2 (Token ((_,CNText id), _)) _ _
    (Parsed(PPExp n)) = (
    PPFor(id,name_to_tmark n, LDReverse, Nil))
|   red_loop_parameter_specification2 _ _ _ _ = 
     stack_error "red_loop_parameter_specification2";

fun red_loop_parameter_specification3 (Token ((_,CNText id), _)) _
    (Parsed(PPExp n)) _ (Parsed(PPSRExpression sr)) = (
        PPFor(id, name_to_tmark n, LDForwards, Value
        (sr_expression_to_range sr)))
|   red_loop_parameter_specification3 _ _ _ _ _ =
    stack_error "red_loop_parameter_specification3";

fun red_loop_parameter_specification4 (Token ((_,CNText id), _)) _ _
    (Parsed(PPExp n)) _ (Parsed(PPSRExpression sr)) = (
    PPFor(id, name_to_tmark n, LDReverse, Value (sr_expression_to_range sr)))
|   red_loop_parameter_specification4 _ _ _ _ _ _ =
    stack_error "red_loop_parameter_specification4";

val red_till_opt1 = PPExps [];
fun red_till_opt2 _ (Parsed(PPExp(EAuxiliaryExp z))) = (
    PPExps[EAuxiliaryExp z])
|   red_till_opt2 _ _ =
        stack_error "red_till_opt2";
=TEX

=SML
fun red_auxiliary_expression _ (Token ((LCZ,CNZ z), _)) _ = (
    PPExp(EAuxiliaryExp (z_tm_of_z_tokens z )))
|   red_auxiliary_expression _ _ _ =
        stack_error "red_auxiliary_expression";

fun red_exit_statement1 _ _ = (
    PPStatement STExit
    );
fun red_exit_statement2 _ _ (Parsed(PPExp exp)) _ = (
    PPStatement(STExitWhen{g=exp}))
|   red_exit_statement2 _ _ _ _ =
        stack_error "red_exit_statement2";

fun red_return_statement _ (Parsed(PPExp exp)) _ = (
    PPStatement (STRet{e=exp}))
|   red_return_statement _ _ _ =
        stack_error "red_return_statement";
=TEX

=SML
fun red_subprogram_declaration1 (Parsed(PPProcedureSpecification p)) _ = (
    PPDeclarations[DProcedureDeclaration p])
|   red_subprogram_declaration1 _ _ =
        stack_error "red_subprogram_declaration1";

fun red_subprogram_declaration2 (Parsed(PPFunctionSpecification f)) _ = (
    PPDeclarations[DFunctionDeclaration f])
|   red_subprogram_declaration2 _ _ =
        stack_error "red_subprogram_declaration2";

fun red_subprogram_specification1 (Parsed(PPProcedureSpecification p)) = (
    PPSubprogramSpec(SSProcedure p))
|   red_subprogram_specification1 _ =
        stack_error "red_subprogram_specification1";

fun red_subprogram_specification2 (Parsed(PPFunctionSpecification p)) = (
    PPSubprogramSpec(SSFunction p))
|   red_subprogram_specification2 _ =
        stack_error "red_subprogram_specification2";
=TEX

=SML
fun red_procedure_specification_1_1 _ (Token ((_,CNText id), _)) = (
    PPProcedureSpecification{name=id, formal_part=[],spec=Nil, annotation = []})
|   red_procedure_specification_1_1 _ _ =
        stack_error "red_procedure_specification_1_1";

fun red_procedure_specification_1_2 _ (Token ((_,CNText id), _))
    (Parsed(PPStatement(STSpecNoIvars {spec=s, ...}))) = (
    PPProcedureSpecification{name=id,formal_part=[],spec=Value s, annotation = []})
|   red_procedure_specification_1_2 _ _ _ =
        stack_error "red_procedure_specification_1_2";

fun red_procedure_specification_1_3 _ (Token ((_,CNText id), _))
    (Parsed (PPFormals f)) = (
    PPProcedureSpecification{name=id,formal_part=f,spec=Nil, annotation = []})
|   red_procedure_specification_1_3 _ _ _ =
        stack_error "red_procedure_specification_1_3";

fun red_procedure_specification_1_4 _ (Token ((_,CNText id), _))
    (Parsed (PPFormals f)) (Parsed(PPStatement(STSpecNoIvars {spec=s, ...}))) = (
    PPProcedureSpecification{name=id,formal_part=f,spec=Value s, annotation = []})
|   red_procedure_specification_1_4 _ _ _ _=
        stack_error "red_procedure_specification_1_4";

fun red_procedure_specification
    (Parsed(PPProcedureSpecification{name=id,formal_part=f,spec=s, ...}))
    (Parsed (PPAnnotation ann)) = (
	PPProcedureSpecification{name=id,formal_part=f,spec=s,annotation=ann}
) |   red_procedure_specification _ _ =
        stack_error "red_procedure_specification";
=TEX
=SML
val red_function_specification_statement1 = red_specification_statement1;
val red_function_specification_statement2 = red_specification_statement2;
val red_function_specification_statement3 = red_specification_statement3;
val red_function_specification_statement4 = red_specification_statement4;
=TEX
=SML
fun red_function_specification_1_1 _ (Token((_,CNText des), _)) _
    (Parsed(PPExp n)) = (
    PPFunctionSpecification{designator=des,
        return=name_to_tmark n,
	formal_part=[],spec=Nil,globals=[],annotation=[]})
|   red_function_specification_1_1 _ _ _ _ =
        stack_error "red_function_specification_1_1";

fun red_function_specification_1_2 _ (Token((_,CNText des), _)) _
    (Parsed(PPExp n))
	(Parsed(PPStatement(STSpecNoIvars {spec={w, w0, pre, post}, ...}))) = (
    PPFunctionSpecification{designator=des,
	return=name_to_tmark n,
	formal_part=[],spec=Value {w=[], w0=[], pre=pre, post=post},
	globals=w,annotation=[]})
|   red_function_specification_1_2 _ _ _ _ _ =
        stack_error "red_function_specification_1_2";

fun red_function_specification_1_3 _ (Token((_,CNText des), _))
    (Parsed(PPFormals f)) _ (Parsed(PPExp n)) = (
    PPFunctionSpecification{designator=des,
	return=name_to_tmark n,
	formal_part=f,spec=Nil,globals=[],annotation=[]})
|   red_function_specification_1_3 _ _ _ _ _ =
        stack_error "red_function_specification_1_3";

fun red_function_specification_1_4 _ (Token((_,CNText des), _))
    (Parsed(PPFormals f)) _ (Parsed(PPExp n))
    (Parsed(PPStatement(STSpecNoIvars {spec={w, w0, pre, post}, ...}))) = (
    PPFunctionSpecification{designator=des,
        return=name_to_tmark n,
	formal_part=f,spec=Value {w=[], w0=[], pre=pre, post=post},
	globals=w,annotation=[]})
|   red_function_specification_1_4 _ _ _ _ _ _ =
        stack_error "red_function_specification_1_4";

fun red_function_specification
    (Parsed(PPFunctionSpecification{designator=des,return=tm,
			formal_part=f,spec=s,globals=g, ...}))
    (Parsed (PPAnnotation ann)) = (
	PPFunctionSpecification{designator=des,return=tm,
			formal_part=f,spec=s,globals=g,annotation = ann}
) |   red_function_specification _ _ =
        stack_error "red_function_specification";
=TEX
=SML
val red_annotation_list1 = PPAnnotation [];

fun red_annotation_list2 (Token ((LCAnnotation,CNText ann), _))
	(Parsed (PPAnnotation anns)) = (
	PPAnnotation (ANString ann :: anns)
)|  red_annotation_list2 _ _ = stack_error "red_annotation_list2";

fun red_annotation_list3 (Parsed (PPKSlot ks))
	(Parsed (PPAnnotation anns)) = (
	PPAnnotation (ANKSlot ks :: anns)
)|  red_annotation_list3 _ _ = stack_error "red_annotation_list3";
=TEX
SPARK manual 6.1:
=SML
fun red_operator_symbol (Token((StringLiteral,CNString opsym), _)) = (
    PPId opsym)
|   red_operator_symbol _ =
        stack_error "red_operator_symbol";

fun red_formal_part _ (Parsed p) _ = (p)
|   red_formal_part _ _ _ =
        stack_error "red_formal_part";

val red_parlist1 = red_accept;

fun red_parlist2 (Parsed (PPFormals f1)) _ (Parsed(PPFormals f2)) = (
    PPFormals (f1@f2))
|   red_parlist2 _ _ _ =
        stack_error "red_parlist2";

fun red_parameter_specification (Parsed(PPIds ids)) _ (Parsed(PPMode m)) 
    (Parsed(PPExp n)) = (
    PPFormals[{idlist=ids,mode=m,name=name_to_tmark n}])
|   red_parameter_specification _ _ _ _ =
        stack_error "red_parameter_specification";
;
val red_mode1 = PPMode MSparkIn;
fun red_mode2 _ = PPMode MSparkIn;
fun red_mode3 _ = PPMode MSparkOut;
fun red_mode4 _ _ = PPMode MSparkInOut;
=TEX

SPARK manual 6.3:
=SML
fun red_subprogram_body1 (Parsed (PPProcedureSpecification ps)) _
    (Parsed (PPSubprogram (d, s, id))) = (
let val {name=id',...} = ps;
    val side =if    different_ids (id', id)
            then    parse_error 503001 "PROCEDURE identifiers do not match"
            else    ();
in
    PPProperBody (PBProcedure {procedure_spec=ps,declarative_part=d,statement=s})
end)
|   red_subprogram_body1 _ _ _ =
        stack_error "red_subprogram_body1";

fun red_subprogram_body2 (Parsed (PPFunctionSpecification fs)) _
    (Parsed (PPSubprogram (d, s, id))) = (
let val {designator=id',...} = fs;
    val side =if    different_ids (id', id)
            then    parse_error 503001 "FUNCTION designators do not match"
            else    ();
in
    PPProperBody (PBFunction {function_spec=fs,declarative_part=d,statement=s})
end)
|   red_subprogram_body2 _ _ _ =
        stack_error "red_subprogram_body2";

fun red_subprogram_implementation (Parsed(PPDeclarations d)) _ 
    (Parsed(PPStatement s)) _ (Token ((_,CNText id), _)) _ = (
    PPSubprogram (d, s, id))
|   red_subprogram_implementation _ _ _ _ _ _ =
        stack_error "red_subprogram_implementation";
=TEX

=SML
fun red_procedure_call_statement (Parsed (p as (PPExp e))) _ = (
    case e 
    of EIndexedComp{prefix=prefix,index=EArrayAggPos{comps = comps,...}} => (
        PPStatement (STProcNoIvars{name=name_to_tmark prefix,
            actuals=APositional comps})
    )|  EIndexedComp{prefix=prefix,index=EArrayAggNamed
		{tmark=_,named_assocs=na}} => (
        PPStatement (STProcNoIvars{name=name_to_tmark prefix,
            actuals=ANamed na})
    )|  EIndexedComp{index=EArrayAggNamedOthers _,...} => (
        parse_error 503001 "OTHERS is not allowed in a parameter association"
    )|  EIndexedComp{index=EArrayAggPosOthers _,...} => (
        parse_error 503001 "OTHERS is not allowed in a parameter association"
    )|  EIndexedComp{index=EArrayAggOthers _,...} => (
        parse_error 503001 "OTHERS is not allowed in a parameter association"
    )|_ => (
        PPStatement (STProcNoIvars{name=name_to_tmark e, actuals=APositional[]})
    ))
|   red_procedure_call_statement _ _ =
        stack_error "red_procedure_call_statement";

fun red_actual_parameter_part _ (Parsed p) _ = (
    p)
|   red_actual_parameter_part _ _ _ =
        stack_error "red_actual_parameter_part";

fun red_parameter_association1
    (Parsed(PPAgg{tm=tm,named_assocs=na,others=ot})) = (
    case ot 
    of Value oe => PPExp (EArrayAggNamedOthers
            {agg_named={tmark=Nil,named_assocs=na},
            others={others=oe}})
    |  Nil => PPExp (EArrayAggNamed{tmark=Nil,named_assocs=na}))
|   red_parameter_association1 _ =
        stack_error "red_parameter_association1";

fun red_parameter_association2 (Parsed(PPExps es)) = (
    PPExp(EArrayAggPos{tmark=Nil,comps = es}))
|   red_parameter_association2 _ =
        stack_error "red_parameter_association2";

fun red_positional_parameter_association1 (Parsed(PPExp a)) = (
    PPExps [a])
|   red_positional_parameter_association1 _ =
        stack_error "red_positional_parameter_association1";

fun red_positional_parameter_association2 (Parsed(PPExp a)) _
    (Parsed(PPExps es)) = (
    PPExps (a::es))
|   red_positional_parameter_association2  _ _ _ =
        stack_error "red_positional_parameter_association2";
=TEX

=SML
val red_actual_parameter = red_accept;
=TEX

SPARK manual 7.1:
=SML
fun red_package_declaration (Parsed (PPPackageSpecification p)) _ = (
    PPDeclarations[DPackageDeclaration p])
|   red_package_declaration _ _ =
        stack_error "red_package_declaration";

fun red_package_specification1 _ (Token ((_,CNText id), _))
	(Parsed (PPAnnotation ann)) _
    (Parsed(PPDeclarations v)) _ (Token ((_,CNText id'), _)) = (
let val side =if    different_ids (id', id)
            then    parse_error 503001 "PACKAGE names do not match"
            else    ();
in	PPPackageSpecification
	{name=id,visible_decs=v,private_decs=[],annotation=ann}
end)
|   red_package_specification1 _ _ _ _ _ _ _ =
        stack_error "red_package_specification1";

fun red_package_specification2 _ (Token ((_,CNText id), _))
	(Parsed (PPAnnotation ann))  _
    (Parsed(PPDeclarations v)) _  (Parsed(PPDeclarations p)) _
    (Token ((_,CNText id'), _)) = (
let val side =if    different_ids (id', id)
            then    parse_error 503001 "PACKAGE names do not match"
            else    ();
in
    	PPPackageSpecification
	{name=id,visible_decs=v,private_decs=p,annotation=ann}
end)
|   red_package_specification2 _ _ _ _ _ _ _ _ _ =
        stack_error "red_package_specification2";

val red_visible_part1 = PPDeclarations [];

fun red_visible_part2 (Parsed (PPDeclarations d1))
    (Parsed (PPDeclarations d2)) = ( 
    PPDeclarations (d1@d2))
|   red_visible_part2 _ _ =
        stack_error "red_visible_part2";

=TEX

SPARK manual 7.1:
=SML
fun red_visdec1 (Parsed (PPKSlot k)) = (
    PPDeclarations [DDeclarationKSlot (k, DKVisible)])
|   red_visdec1 _ =
        stack_error "red_visdec1";

val red_visdec2 = red_accept;

val red_visdec3 = red_accept;

fun red_visdec4 _ (Token ((LCZ,CNZ z1), _)) _ = (
let	val (n, ty) = 
                        process_aux_z_decl z1
in
    PPDeclarations [DAuxiliary{aux=n, t=ty}]
end)
|   red_visdec4 _ _ _ = stack_error "red_visdec4";

val red_visdec5 = red_accept;

val red_private_part1 = red_accept;

fun red_private_part2 (Parsed (PPDeclarations d1))
    (Parsed (PPDeclarations d2)) = (
    PPDeclarations (d1@d2))
|   red_private_part2 _ _ =
        stack_error "red_private_part2";

fun red_pdec1 (Parsed (PPKSlot k)) = (
    PPDeclarations [DDeclarationKSlot (k, DKPrivate)])
|   red_pdec1 _ =
        stack_error "red_pdec1";

val red_pdec2 = red_accept;

val red_pdec3 = red_accept;
=TEX

=SML
fun red_package_body _ _ (Token ((_,CNText id), _)) 
	(Parsed (PPAnnotation ann)) _
    (Parsed(PPSubprogram (d,s, _))) _ (Token ((_,CNText id'), _)) _ = (
let val side =if    different_ids (id', id)
            then    parse_error 503001 "PACKAGE names do not match"
            else    ();
in
   	PPProperBody
	(PBPackage{name=id,decls=d,statement=s,annotation=ann})
end)
|   red_package_body _ _ _ _ _ _ _ _ _ =
        stack_error "red_package_body";

fun red_package_implementation1 (Parsed (PPDeclarations d)) = (
    PPSubprogram (d, STImplicitNull, ""))
|   red_package_implementation1 _ =
        stack_error "red_package_implementation1";

fun red_package_implementation2 (Parsed (PPDeclarations d)) _
    (Parsed(PPStatement s)) = (
    PPSubprogram (d, s, ""))
|   red_package_implementation2 _ _ _ =
        stack_error "red_package_implementation2";

fun red_package_implementation3 (Parsed (PPDeclarations using))
		(Parsed (PPDeclarations d)) _ (Parsed(PPStatement s)) = (
    PPSubprogram (using@d, s, ""))
|   red_package_implementation3 _ _ _ _ =
        stack_error "red_package_implementation3";

val red_package_initialization = red_accept;
=TEX
=SML
fun €check_basic_dec_list› ((bd::more) : BASIC_DECL list) : bool = (
	case bd of
		BDDeferredConstDecl _ => false
	|	BDPrivateTypeDecl _ => false
	|	_ => check_basic_dec_list more
) | check_basic_dec_list _ = true;
=TEX
=SML
fun €extract_vardecls› ((bd::more) : BASIC_DECL list) : VAR_DECL list = (
	case bd of
		BDVarDecl vd => vd::extract_vardecls more
	|	BDVarDeclInit (vd, init) => vd::extract_vardecls more
	|	_ => extract_vardecls more
) | extract_vardecls _ = [];
=TEX
=SML
fun red_using_list1 (Parsed(PPDeclarations ds)) = (
	PPDeclarations ds)
|   red_using_list1 _ = stack_error "red_using_list1";

fun red_using_list2 (Parsed(PPDeclarations d1)) (Parsed(PPDeclarations d2)) = (
    PPDeclarations (d1@d2))
|   red_using_list2 _ _ = stack_error "red_using_list2";

fun red_using_dec _ (Parsed(PPBasicDecls bds)) _
	(Token ((LCZ,CNZ z1), _)) _ (Token ((LCZ,CNZ zpred), _)) _ = (
    if check_basic_dec_list bds
    then
		PPDeclarations[DUsing{aux=z_tm_of_z_tokens z1,
				concrete_vars=extract_vardecls bds,
				basic_decls=bds,
				invariant=process_predicate zpred}]
    else
	parse_error 503001
	"private types and deferred constants are not allowed in a USING declaration")
|   red_using_dec _ _ _ _ _ _ _ =
        stack_error "red_using_dec";

=TEX
=SML

fun red_basic_dec_list1 (Parsed(PPBasicDecls bds)) = (
	PPBasicDecls bds)
|   red_basic_dec_list1 _ =
        stack_error "red_basic_dec_list1";

fun red_basic_dec_list2 (Parsed(PPBasicDecls bds1))
		(Parsed(PPBasicDecls bds2)) = (
    PPBasicDecls(bds1@bds2))
|   red_basic_dec_list2 _ _ =
        stack_error "red_basic_dec_list2";

=TEX
=SML
fun is_k_slot (DDeclarationKSlot _ : DECLARATION) : bool = true
|   is_k_slot _ = false;

fun red_declarative_part_1_1 (Parsed (PPDeclarations d1)) = (
	if	any d1 is_k_slot
	then	parse_error 503001
       "a k-slot is not allowed after the using declarations"
	else	PPDeclarations d1
) | red_declarative_part_1_1 _ =
        stack_error "red_declarative_part_1_1";

fun red_declarative_part_1_2 (Parsed (PPDeclarations d1)) (Parsed (PPDeclarations d2)) = (
    PPDeclarations (d1@d2))
|   red_declarative_part_1_2 _ _ =
        stack_error "red_declarative_part_1_2";
=TEX
SPARK manual 7.4:
=SML
fun red_private_type_declaration1 _ (Token ((_,CNText id), _)) _ _ _ = (
    PPBasicDecls[BDPrivateTypeDecl{id=id,limited=false}])
|   red_private_type_declaration1 _ _ _ _ _ =
        stack_error "red_private_type_declaration1";

fun red_private_type_declaration2 _ (Token ((_,CNText id), _)) _ _ _ _ = (
    PPBasicDecls[BDPrivateTypeDecl{id=id,limited=true}])
|   red_private_type_declaration2 _ _ _ _ _ _ =
        stack_error "red_private_type_declaration2";

fun red_deferred_constant_declaration (Parsed(PPIds ids)) _ _
    (Parsed(PPExp n)) _ = (
    PPBasicDecls[BDDeferredConstDecl{consts=ids,tmark=name_to_tmark n}])
|   red_deferred_constant_declaration _ _ _ _ _ =
        stack_error "red_deferred_constant_declaration";

fun red_renaming_declaration1 _ (Parsed (PPId opsym1))
    (Parsed(PPFormals f)) _ (Parsed(PPExp n)) _
    (Token ((_,CNText id), _)) _ (Parsed (PPId opsym2)) _ = (
    if opsym1 = opsym2
    then
        PPDeclarations[DRenamingDeclaration(RDFunction
        {opsym1=opsym1,formal_part=f,tmark=name_to_tmark n,
           name=id,opsym2=opsym2})]
    else
        parse_error 503001
       "The two operator symbols in a renaming declaration must be the same")
|   red_renaming_declaration1 _ _ _ _ _ _ _ _ _ _ =
        stack_error "red_renaming_declaration1";

fun red_renaming_declaration2 (Parsed (PPSubprogramSpec ss)) _
    (Token ((_,CNText id1), _)) _ (Token ((_,CNText id2), _)) _ = (
   let val res = 
       PPDeclarations[DRenamingDeclaration(RDSubprogram
          {subprogram_specification=ss,name1=id1,name2=id2})];
   in  case ss of
          SSProcedure {spec = Nil, ...} => res
       |  SSFunction {spec = Nil, ...} => res
       |  _ => parse_error 503001
         "A specification statement is not allowed in a renaming declaration"
   end)
|   red_renaming_declaration2 _ _ _ _ _ _ =
        stack_error "red_renaming_declaration21";

=TEX

=SML
fun red_compilation1 (Parsed (PPKSlot k)) = (
    PPKSlotCUList [KCUKSlot k])
|   red_compilation1 _ =
        stack_error "red_compilation1";

fun red_compilation2 (Parsed (PPContextCompilationUnit ccu)) =
    PPKSlotCUList [KCUUnit ccu]
|   red_compilation2 (Parsed (PPPragma p)) =
    PPKSlotCUList [KCUPragma p]
|   red_compilation2 _ =
        stack_error "red_compilation2";

fun red_compilation3 (Parsed (PPContextCompilationUnit ccu))
    (Parsed (PPKSlotCUList cl)) = (
    PPKSlotCUList ((KCUUnit ccu)::cl))
|   red_compilation3 (Parsed (PPPragma p))
    (Parsed (PPKSlotCUList cl)) = (
    PPKSlotCUList ((KCUPragma p)::cl))
|   red_compilation3 _ _ =
        stack_error "red_compilation3";

=TEX

=SML
fun red_compilation_unit1
    (Parsed (PPContextClause (ids_ps, rids, ann)))
    (Parsed (PPCompilationUnit cu)) = (
    PPContextCompilationUnit
	{context=ids_ps, references=rids, comp_unit=cu, annotation=ann}
) | red_compilation_unit1 _ _ =
        stack_error "red_compilation_unit1";

val red_compilation_unit2 = red_compilation_unit1;
val red_compilation_unit3 = red_accept;
=TEX

=SML
fun red_library_unit1 (Parsed(PPDeclarations [DPackageDeclaration p])) = (
    PPCompilationUnit (CUPackageDeclaration p))
|   red_library_unit1 _ =
        stack_error "red_library_unit1";

fun red_library_unit2 (Parsed(PPProperBody p)) = (
    PPCompilationUnit (CUProperBody p))
|   red_library_unit2 _ =
        stack_error "red_library_unit2";

=TEX

SPARK manual 10.1:
=SML
val red_secondary_unit1 = red_accept;
val red_secondary_unit2 = red_accept;

fun red_library_unit_body (Parsed(PPProperBody p)) = (
    PPCompilationUnit(CUProperBody p))
|   red_library_unit_body _ =
        stack_error "red_library_unit_body";

val red_main_program = red_accept;
=TEX

SPARK manual 10.1.1:
=SML
val red_context_clause1 = PPContextClause ([], [], []);

fun red_context_clause2 (Parsed(PPIds ids))
		(Parsed(PPPragmaList ps))
		(Parsed (PPContextClause (idps, refls, ann))) =
		PPContextClause ((ids, ps) :: idps, refls, ann)
|   red_context_clause2 _ _ _ = stack_error "red_context_clause2";

fun red_context_clause3 (Parsed(PPIds refs))
		(Parsed (PPContextClause (idps, refs1, ann))) =
		PPContextClause (idps, refs @ refs1, ann)
|   red_context_clause3 _ _ = stack_error "red_context_clause2";

fun red_context_clause4 (Token ((LCAnnotation,CNText ann), _))
	(Parsed (PPAnnotation anns)) =
		PPContextClause ([], [], ANString ann::anns)
|   red_context_clause4 _ _ = stack_error "red_context_clause3";
=TEX
=SML
val red_pragma_list1 = PPPragmaList [];

fun red_pragma_list2 (Parsed (PPPragma p)) (Parsed(PPPragmaList ps)) = 
	PPPragmaList (p :: ps)
|   red_pragma_list2 _ _ = stack_error "red_pragma_list2";

fun red_pragma1 _ (Token ((_,CNText id), _)) _ = (
	PPPragma {id = id, args = []}
) | red_pragma1 _ _ _ = stack_error "red_pragma1";

fun red_pragma2 _ (Token ((_,CNText id), _)) _ (Parsed(PPPragmaArgs args)) _ _ = (
	PPPragma {id = id, args = args}
) | red_pragma2 _ _ _ _ _ _ = stack_error "red_pragma2";

val red_arg_ass_list1 = red_accept;

fun red_arg_ass_list2 (Parsed(PPPragmaArgs [arg])) _ (Parsed(PPPragmaArgs args)) = (
	PPPragmaArgs (arg::args)
) | red_arg_ass_list2 _ _ _ = stack_error "red_arg_ass_list2";

fun red_argument_association1 (Parsed(PPAggregateChoices (acl, true)))
      _ _ = (
    parse_error 503001 "OTHERS cannot be used in a pragma argument list"
) | red_argument_association1 (Parsed(PPAggregateChoices (_::_::_, _)))
      _ _ = (
    parse_error 503001 "`|' cannot be used in a pragma argument list"
) | red_argument_association1 (Parsed(PPAggregateChoices ([ac], _)))
      _ (Parsed (PPExp e)) = (
    PPPragmaArgs [(Value ac, e)]
) | red_argument_association1 _ _ _ = stack_error "red_argument_association1";

fun red_argument_association2 (Parsed(PPExp e)) = (
    PPPragmaArgs [(Nil, e)]
) | red_argument_association2 _ = stack_error "red_argument_association2";

=TEX
=SML
fun red_with_clause _ (Parsed (PPIds ids)) _ = (PPIds ids)
|   red_with_clause _ _ _ = stack_error "red_with_clause";
=TEX
=SML
fun red_references_clause _ (Parsed (PPIds ids)) _ = (PPIds ids)
|   red_references_clause _ _ _ = stack_error "red_references_clause";
=TEX

SPARK manual 10.2:
=SML
fun red_body_stub1 (Parsed (PPProcedureSpecification ps)) _ _ _ = (
    PPDeclarations [DProcedureStub ps])
|   red_body_stub1 _ _ _ _ = stack_error "red_body_stub1";

fun red_body_stub2 (Parsed (PPFunctionSpecification fs)) _ _ _ = (
    PPDeclarations [DFunctionStub fs])
|   red_body_stub2 _ _ _ _ =
        stack_error "red_body_stub2";

fun red_body_stub3 _ _ (Token ((_,CNText id), _))
	(Parsed (PPAnnotation ann)) _ _ _ = (
	case ann of
	[] =>	PPDeclarations [DPackageStub id]
	| _ => parse_error 503001"annotations are not allowed in a package stub"
) | red_body_stub3 _ _ _ _ _ _ _ =
        stack_error "red_body_stub3";

fun red_body_stub4 (Parsed (PPProcedureSpecification ps)) _ = (
    PPDeclarations [DExternalProcedureStub ps])
|   red_body_stub4 _ _ = stack_error "red_body_stub4";

fun red_body_stub5 (Parsed (PPFunctionSpecification fs)) _ = (
    PPDeclarations [DExternalFunctionStub fs])
|   red_body_stub5 _ _ = stack_error "red_body_stub5";

fun red_subunit _ _ (Parsed(PPExp n)) _ (Parsed (PPProperBody p)) = (
    PPCompilationUnit(CUSubUnit{name=name_to_tmark n, proper_body=p}))
|   red_subunit _ _ _ _ _ =
        stack_error "red_subunit";
=TEX

=SML
val red_representation_clause1 = red_accept;

val red_representation_clause2 = red_accept;

val red_type_representation_clause1 = red_accept;
val red_type_representation_clause2 = red_accept;
val red_type_representation_clause3 = red_accept;

fun red_length_clause _ (Parsed(PPExp a)) _ (Parsed(PPExp e)) _ = (
    PPRepresentationClause(RCLength{attribute=a, exp=e}))
|   red_length_clause _ _ _ _ _ =
        stack_error "red_length_clause";
=TEX

SPARK manual 13.3:
=SML
fun red_enumeration_representation_clause _ (Token ((_,CNText id), _)) _
    (Parsed(PPExp e)) _ = (
    PPRepresentationClause(RCEnumeration{name=id, exp=e}))
|   red_enumeration_representation_clause _ _ _ _ _ =
        stack_error "red_enumeration_representation_clause";
=TEX

SPARK manual 13.4:
=SML
fun red_record_representation_clause _ (Token ((_,CNText id), _)) _ _
    (Parsed(PPExps [e])) (Parsed(PPComponentClauses c)) _ _ _ = (
    PPRepresentationClause(RCRecord{name=id, alignment_opt=Value e,
    component_pack=c}))
|   red_record_representation_clause _ (Token ((_,CNText id), _)) _ _
    (Parsed(PPExps [])) (Parsed(PPComponentClauses c)) _ _ _ = (
    PPRepresentationClause(RCRecord{name=id,alignment_opt=Nil,
    component_pack=c}))
|   red_record_representation_clause _ _ _ _ _ _ _ _ _ =
        stack_error "red_record_representation_clause";
=TEX

SPARK manual 13.4:
=SML
val red_alignment_opt1 = PPExps [];
fun red_alignment_opt2 _ _ (Parsed(PPExp e)) _ = (
    PPExps [e])
|   red_alignment_opt2 _ _ _ _ =
        stack_error "red_alignment_opt2";

val red_component_pack1 = red_accept;

fun red_component_pack2 (Parsed(PPComponentClauses [c])) 
    (Parsed(PPComponentClauses cs)) = (
    PPComponentClauses (c::cs))
|   red_component_pack2 _ _ =
        stack_error "red_component_pack2";
=TEX

SPARK manual 13.4:
=SML
fun red_component_clause (Parsed(PPExp n)) _ (Parsed(PPExp e)) _
    (Parsed(PPSRExpression sr)) _ = (
    PPComponentClauses[{name=name_to_tmark n, exp=e,
        range=sr_expression_to_range sr}])
|   red_component_clause _ _ _ _ _ _ =
        stack_error "red_component_clause";
=TEX

SPARK manual 13.5:
=SML
fun red_address_clause _ (Token ((_,CNText id), _)) _ _
    (Parsed (PPExp exp)) _ = (
    PPRepresentationClause(RCAddress {name=id, exp=exp}))
|   red_address_clause _ _ _ _ _ _ =
        stack_error "red_address_clause";
=TEX

=SML
end (* of structure CNParser stage 2 *);
=TEX

\section{PARSER}\label{PARSER}
=SML
structure €CNParser› : CNParser (* final stage *) = struct
=TEX

=SML
=TEX

We can now load the code generated by SLRP from the grammar
of 'cite{ISS/HAT/DAZ/DTD503}'.
=SML
    open CNParser ;
=FULLVERSION
   open ZTypeInference;
=TEX

=INCLUDE
dtd503.grm.sml
=TEX

\subsection{Conversion of Names to Type Marks}
The implementation of this function is at the beginning of section \ref{REDUCTIONFUNCTIONS}.
=SML
type €CN_PARSER_STATE› = CN_PARSER_STATE;
val €get_cn_parser_state› = get_cn_parser_state;
val €set_cn_parser_state› = set_cn_parser_state;
val €reset_cn_parser_state› = reset_cn_parser_state;
val €name_to_tmark›  = name_to_tmark;
=FULLVERSION
val €z_predexp_of_z_tm›  = z_predexp_of_z_tm;
=TEX

=FULLVERSION
val €z_tm_true› : Z_TM = z_tm_true;
=CUTDOWNVERSION
val €z_tm_true› : Z_TM = dummy_z_tm;
=TEX

\subsection{The Parser Function Proper}

=SML
fun €cn_reader› (ip : CN_LEX_ITEM list) : CN_LEX_ITEM * (CN_LEX_ITEM list) = (
    case ip 
    of (h :: more) => (cur_tok := !cur_tok + 1; (h, more))
    |  [] => ((LCEos, CNEos), [])
    );
=TEX

=SML
val €cn_error› : (CN_LEX_ITEM, 'b, 'c, 'd) ERROR_ROUTINE =
    (fn (tok, stk, _, _) => (
    parse_error_hdr();
        diag_string (get_error_message 19003 [format_lex_item tok,
                    format_stack format_lex_item stk]);
        raise SYNTAX_ERROR
));
=TEX

The following is adapted from the HOL parser in \cite{DS/FMU/IED/IMP019} q.v.
for explanation.
=SML
fun €cn_parser› (ip : CN_LEX_ITEM list) : WEB_CLAUSE  = (
    let val se1 = (input_toks := ip; cur_tok := ~1);
        val save_cn_parser_state = get_cn_parser_state();
        val res = (((slrp'gen_parser
                default_resolver
                fst
                cn_error
                cn_reader) ip
            handle ex => (
                set_cn_parser_state save_cn_parser_state;
                raise ex
            ))		handle	SYNTAX_ERROR =>
				fail "cn_parser" 503204 []
			|	PARSER_ERROR msg =>
					error "cn_parser" 503205 [fn()=>msg]
	);
        val se2 = (input_toks := []);
    in    case res 
    of PPWebClause wc => wc
        |_ => stack_error "cn_parser - weird result from parser"
    end
    );
=TEX

\section{EPILOGUE}
=SML
end (* of structure CNParser final stage *);
=TEX

\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
