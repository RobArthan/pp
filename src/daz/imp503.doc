% imp503.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Compliance Notation Parser}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP503}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the CN 
parser.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue \SCCSversion, \FormatDate{$Date$%
} ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the parser for
HOL/Z.
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD503}.
\subsection{Introduction}

\subsection{Purpose and Background}

\subsection{Algorithms}



\subsection{Dependencies}

\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX
\section{DATA TYPES}
=SML
structure €CNParser› : CNParser = struct
=TEX
We need to include the SLRP driver code at this point:
=INCLUDE
imp018.sml
=TEX
=SML
local
open CaseIndependence;
open CNTypes;
open SlrpDriver;
in
=TEX

\section{PARSER}\label{PARSER}
\subsection{Miscellanea}
$stack\_error$ is for use during context-free parsing when the parsing stack
is corrupt.
=SML
fun €stack_error› (insert : string) : 'a = (
	diag_string("Internal error in CN-Parser");
	error "CN-Parser"  19005 [fn() => insert]
);
=TEX
To give error reports which are closely related to the actual input,
the following two variables are set up by the functions
$HOL\_parser$ and $HOL\_reader$. At any time during parsing $input\_toks$
can be expected to contain the totality of the token stream being parsed
and $toks\_read$ contains the offset in it of the token most recently
read (or is =INLINEFT
~1
=TEX
\ if nothing has been read yet).
=SML
val input_toks : CN_LEX_ITEM list ref = ref [];
val cur_tok : int ref = ref ~1;
=TEX
=SML
fun €format_lex_item›  ((_, tok) : CN_LEX_ITEM) : string = (
	case tok of
		CNZ _	=> " <z> "
	|	CNText s	=> s
	|	CNString s	=> s
	|	CNKSlot s	=> "K-Slot"
	|	CNEos		=> "<end-of-input>"
);
=TEX
=SML
fun €parse_error_hdr› () : unit = (
	let	val ok_toks =	format_list
				format_lex_item 
				((!input_toks) to (!cur_tok-1))
				" ";
		val bad_tok =	if !cur_tok >= 0 andalso !cur_tok < length (!input_toks)
				then " <?> " ^ format_lex_item (nth (!cur_tok) (!input_toks))
				else "";
	in	diag_string (get_error_message 19001 [ok_toks ^ bad_tok])
	end
);
=TEX
The following function produces the error reports for the unexpected
token type of error:
=TEX
=SML
fun €parse_error› (msg : int) (insert : string) : 'a = (
	parse_error_hdr();
	diag_string (get_error_message msg [insert]);
	raise SYNTAX_ERROR
);
=TEX
\subsection{Reduction Functions}

As with the HOL parser, adding type constraints to the reduction functions
would be both unhelpful and very time-consuming and so in this section
we deliberately suspend that aspect of the coding standards of
\cite{ISS/HAT/DAZ/PLN003}.

We give the reduction functions in the order of their appearance
in the grammar of 'cite{ISS/HAT/DAZ/DTD503}'. When several reduction
functions would be the same, we use $val$ bindings for the various
instances.
=SML
(* Reduction Functions to be supplied *)
=TEX
\subsection{The Generated Parser}
We can now load the code generated by SLRP from the grammar
of 'cite{ISS/HAT/DAZ/DTD503}'.
=SML
local
=TEX
=INCLUDE
dtd503.grm.sml
=IGN
fun slrp'gen_parser x1 x2 x3 x4 = fn _ => ();
=SML
in
=TEX
\subsection{Reader Function}\lab
=TEX
\subsection{Interface}
=TEX
=SML
fun €cn_reader› (ip : CN_LEX_ITEM list) : CN_LEX_ITEM * (CN_LEX_ITEM list) = (
	case ip of
		(h :: more) => (cur_tok := !cur_tok + 1; (h, more))
	|	[] => ((Eos, CNEos), [])
);
=TEX
=SML
val €cn_error› : (CN_CN_LEX_ITEM, 'b, 'c, 'd) ERROR_ROUTINE = (fn (tok, stk, _, _) => (
	parse_error_hdr();
	diag_string (get_error_message 19003 [format_lex_item tok,
				format_stack format_lex_item stk]);
	raise SYNTAX_ERROR
));
=TEX
The following is adapted from the HOL parser in \cite{ISS/HAT/DAZ/IMP019} q.v.
for explanation.
=SML
fun €cn_parser› (ip : CN_CN_LEX_ITEM list) : unit  = (
	let	val se1 = (input_toks := ip; cur_tok := ~1);
		val res = (slrp'gen_parser
				default_resolver fst
				cn_error
				cn_reader) ip;
		val se2 = (input_toks := []);
	in	res
	end
);
end; (* local ... in *)
=TEX
\subsubsection{Sequence Type Definitions}
=TEX
\section{EPILOGUE}
=SML
end (* of local ... in *);
end (* of structure CNParser *);
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
