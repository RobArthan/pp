% imp503.doc   @(#) 97/08/01 1.76 imp503.doc
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}	%% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Compliance Notation Parser}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP503}	%% Mandatory field
\def\SCCSversion{1.76%
}
\TPPissue{\SCCSversion}	%% Mandatory field
\TPPdate{\FormatDate{97/08/01%
}}
\TPPstatus{Draft}		%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the Compliance Notation Parser to meet the DRA's requirements for a Compliance Tool.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
    Library}}
%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1-1.55] Initial Drafts.
\item[Issue 1.1-1.55] Initial Drafts.
\item[Issue 1.55-1.59] Bug fixes.
\item[Issue 1.60-1.64] Enhancements 1, 6 and 20.
\item[Issue 1.60-1.65] Enhancement 10.
\item[Issue 1.60-1.65] Enhancement 10.
\item[Issue 1.66] Bug 19 (batch 2).
\item[Issue 1.67] Operator associativity bug.
\item[Issue 1.68] Enhancement 3.
\item[Issue 1.69-1.71] Syntax changes for k-slots as annotations.
\item[Issue 1.72] Change a $stack\_error$ to a $parse\_error$ in $red\_subtype\_indication2\_a$.
\item[Issue 1.73] IUCT WP 7 enhancements.
\item[Issue 1.74] IUCT WP 3 changes.
\item[Issue 1.75] IUCT WP 4 changes.
\item[Issue 1.75] Made it apply ê to invariants and other cases.
\item[Issue 1.76] Added dummy cases for functions using $Z\_TM$, $Z\_PARA$, $Z\_EXP$.
		  Changes to allow compilation with zed.db.
\item[Issue 1.77] Changes to allow compilation with hol.db.
\item[Issue 1.78] Changes to allow compilation with just poly.db.
\item[Issue 1.79-1.83] Changes for NJML port and cut-down tool.
\item[Issues 1.84,1.85] Enhancement R5: Initial Variables in Conditionals.
The main change is that the {\it Stmt} and {\it Statement} data types are merged.
This removes the need for various special cases and type conversion functions.
\item[Issue 1.86] Enhancement R4: Frame Abbreviations.
\item[Issue 1.87] Enhancement R2: Multiple Logical Constants.
\item[Issue 1.88] CTLE II R1/7: empty package specifications.
\item[Issue 1.89-1.92] CTLE II R1/10: multiple with clauses.
\item[Issue 1.93] CTLE II R2/1: global variable unsoundness.
\item[Issue 1.94] CTLE II R1/11: nested packages.
\item[Issues 1.95,1.96] CTLE II R1/1: real types.
\item[Issue 1.97] Fixed {\LaTeX} error.
\item[Issue 1.98] R0037: support for named numbers.
\item[Issue 1.99--1.102] R0006: free use of subtype indications and ranges.
\item[Issue 1.103] R0056: default parameter modes supported properly.
\item[Issue 1.104] Fixing bug when terms have to be type-checked without a cache theory.
\item[Issue 1.105] Spring 2002 enhancements: syntax changes for interim release.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the Compliance Notation parser for
HOL/Z. It covers the parsing of Compliance Notation Web Clauses. For Web clauses constituting Z paragraphs, the {\Product} Z Parser is used.

The detailed design for this implementation and the BNF form form of the implemented grammar is in \cite{ISS/HAT/DAZ/DTD503}.

\subsection{Introduction}

\subsection{Purpose and Background}

This document introduces the structure $CNParser$. This provides an implementation of a parser which corresponds to the language definition in \cite{ISS/HAT/DAZ/DTD502} which itself seeks to comply with DRA's specification of the concrete syntax of Compliance Notation.

\subsection{Known Deficencies}

This implementation aims to fully support the language definition of \cite{ISS/HAT/DAZ/DTD502}.

\subsection{Possible Enhancements}

None known.

\section{MISCELLANEOUS FUNCTIONS}\label{MISCELLANEOUSFUNCTIONS}

First we introduce the structure wrapping. The structure is developed
in stages and the official signature constraint is only applied at the
last stage.
=SML
structure €CNParser› (* stage 1 *) = struct
=TEX
=CUTDOWNVERSION
val dummy_z_tm : Z_TM = ();
=TEX
We need to include the SLRP driver code at this point:
=INCLUDE
imp018.sml
=TEX

=SML
    open SlrpDriver;
    open CNTypes;
    open ZLex; 
=FULLVERSION
    open ZParser; 
    open ZTermGenerator; 
    open ZTypeInference;
    open ZUserInterfaceSupport;
=TEX

\subsection{Miscellanea}
$stack\_error$ is for use during context-free parsing when the parsing stack
is corrupt.
=SML
fun €stack_error› (insert : string) : 'a = (
    diag_string(get_error_message 503202 []);
    BasicError.error "CN-Parser"  503203 [fn() => insert]
    );
=TEX

=SML
fun €weird_error› (insert : string) : 'a = (
    diag_string(get_error_message 503202 []);
    BasicError.error "CN-Parser"  503001 [fn() => insert]
    );
=TEX

To give error reports which are closely related to the actual input,
the following two variables are set up by the functions
$HOL\_parser$ and $HOL\_reader$. At any time during parsing $input\_toks$
can be expected to contain the totality of the token stream being parsed
and $toks\_read$ contains the offset in it of the token most recently
read (or is 
=INLINEFT
~1
=TEX
\ if nothing has been read yet).
=SML
val input_toks : CN_LEX_ITEM list ref = ref [];
val cur_tok : int ref = ref ~1;
=TEX

=SML
fun €format_lex_item›  ((_, tok) : CN_LEX_ITEM) : string =
    (case tok
        of CNZ _ => " <Z-Quotation> "
        |  CNText s => s
        |  CNString s => s
        |  CNKSlot s => "K-Slot"
        |  CNEos => "<End-of-Input>"
    );
=TEX

=SML
fun €format_input_items›  ((ip::rest) : Lex.INPUT list) : string = (
    let val s = (case ip
        of Lex.Char c => "`"^c^"`"
        |  Lex.Error s => "ERROR__"^(string_of_int s)
        |  Lex.Separator s => s
        |  Lex.String s => "\""^s^"\""
        |  Lex.Term t => string_of_term t
        |  Lex.Text s => s
        |  Lex.Type t => string_of_type t
        );
    in
        s^(format_input_items rest)
    end)
|   format_input_items _ = "";
=TEX

=SML
fun €parse_error_hdr› () : unit = (
    let val ok_toks =
            format_list format_lex_item ((!input_toks) to (!cur_tok-1)) " ";
        val bad_tok =
            if !cur_tok >= 0 andalso !cur_tok < length (!input_toks)
            then " <?> " ^ format_lex_item (nth (!cur_tok) (!input_toks))
            else "";
    in diag_string (get_error_message 19001 [ok_toks ^ bad_tok])
    end);
=TEX

The following function produces the error reports for the unexpected
token type of error:
=SML
fun €parse_error› (msg : int) (insert : string) : 'a = (
    parse_error_hdr();
    diag_string (get_error_message msg [insert]);
    raise SYNTAX_ERROR
    );
=TEX

\subsection{Support for Processing Z Fragments}

=SML
=FULLVERSION
fun €z_tm_of_z_para› (zp : Z_PARA) : Z_TM = 
(   case zp 
    of ZParaTerm (_, z_tm, _) => z_tm
    |  _ => weird_error "weird error in z_tm_of_z_para"
);
=TEX

=SML
fun €z_tm_of_z_tokens› (tokens : Z_TOKEN list) : Z_TM =
=FULLVERSION
(
    (z_tm_of_z_para o (z_parser {is_quot = true})) tokens
);
=CUTDOWNVERSION
 dummy_z_tm;
=TEX

=SML
fun €process_con_z_decl› (ztokens : ZLex.Z_TOKEN list) : (Z_ID * Z_TM) list = 
=FULLVERSION
(
let	val schtoks =
		ZTLsqbrack::((rev o tl o rev) ztokens)@[ZTRsqbrack, ZTEos];
	fun do1 (ZDDec (vs, tm, _)) = (
		map (fn v => (string_of_ident v, tm)) vs
	) | do1 _ = (
		 parse_error 503001
		"a schema-as-declaration is not allowed in a logical constant statement"
	);
in
	case z_tm_of_z_tokens schtoks of
		ZTmHorizSchema(decs,_, _) => flat (map do1 decs)
        |  _ => parse_error 503001 "badly formed declarations in logical constant statement"
end);
=CUTDOWNVERSION
  ("", [dummy_z_tm]);
=TEX


=SML
fun €process_aux_z_decl› (ztokens : ZLex.Z_TOKEN list) : (Z_ID * Z_TM) = 
=FULLVERSION
(
    let val schtoks =
        ZTLsqbrack::((rev o tl o rev) ztokens)@[ZTRsqbrack, ZTEos];
    in
        case z_tm_of_z_tokens schtoks 
        of ZTmHorizSchema([ZDDec ([tmpl],ty, _)],_, _) =>
            (string_of_ident tmpl, ty)
        |  _ => parse_error 503001 "badly formed auxiliary variable"
    end);
=CUTDOWNVERSION
 ("", dummy_z_tm);
=TEX
=SML
fun €process_frame› ([] : ZLex.Z_TOKEN list) : Z_ID list = []
|   process_frame [ZTEos] = []
|   process_frame ztokens = 
=FULLVERSION
(
    let val tuptoks = ZTLbrack::((rev o tl o rev) ztokens)@[ZTRbrack, ZTEos];
        fun get_name (ZTmLVar (id, _, _)) = string_of_ident id
        |   get_name _ = parse_error 503001 "badly formed frame";
        val z_tm = z_tm_of_z_tokens tuptoks;
    in
        case z_tm 
            of ZTmBracketed z_tm' => [get_name z_tm']
            |  ZTmTuple tml => map get_name tml
            |  _ => parse_error 503001 "badly formed frame"
    end);
=CUTDOWNVERSION
  [];

=TEX
=SML
fun process_predicate (ztokens : ZLex.Z_TOKEN list) : Z_TM = 
=FULLVERSION
(
let	val pi_tm = (
		case ZParserInternals.z_parser_pass_1 ztokens of
		ParGeneralTerm(tm, Nil) => 
			ParGeneralTerm (PredFancyFix(TmplPre
              	      (("ê", Nil), StubUS), "", [[tm]]),Nil)
		|  _ => parse_error 503001 "unexpected Z construct");
	fun aux parsed = (
		(z_tm_of_z_para o (ZParserInternals.z_parser_pass_2
			{is_quot = true})) parsed
	);
in	
  aux pi_tm
end);
=CUTDOWNVERSION
 dummy_z_tm;
=SML

fun €process_pre_and_post_conditions›
    (ztokens : ZLex.Z_TOKEN list) : Z_TM OPT * Z_TM = 
=FULLVERSION
(   let val genitoks =
            ZTLsqbrack::((rev o tl o rev) ztokens)@[ZTRsqbrack, ZTEos];
        val zpara = ZParserInternals.z_parser_pass_1 genitoks;
        fun apply_pi p = (
            case p 
            of ParGeneralTerm (PredGenInst [pp], Nil) => (
                (Nil, ParGeneralTerm (PredFancyFix(TmplPre
                    (("ê", Nil), StubUS), "", [[pp]]),Nil)))
            |  ParGeneralTerm (PredGenInst [p1,p2], Nil) => (
                (Value (ParGeneralTerm (PredFancyFix(TmplPre
                    (("ê", Nil), StubUS), "", [[p1]]),Nil)),
                    ParGeneralTerm (PredFancyFix(TmplPre
                    (("ê", Nil), StubUS), "", [[p2]]),Nil)))
            |  _ => parse_error 503001
                    "unexpected input after the post-condition"
        );
        val (pretm_opt, posttm) = apply_pi zpara;
        fun aux parsed = (
            (z_tm_of_z_para o (ZParserInternals.z_parser_pass_2
            {is_quot = true})) parsed
        );
    in

        case pretm_opt 
        of Value pre => (Value (aux pre), aux posttm)
        |Nil => (Nil, aux posttm)

    end);
=CUTDOWNVERSION
 (Nil, dummy_z_tm);
=TEX

The following functions support the external interface $z\_predexp\_of\_z\_tm$.
=FULLVERSION
fun €z_para_of_zinferred› ((ZInferred p) : Z_INFERRED) : Z_PARA = (p)
|   z_para_of_zinferred (ZTypeError inf) = (print_z_error inf);
=CUTDOWNVERSION
fun €z_para_of_zinferred› x = ();

=TEX
The following is used to give diagnostics, which may sometimes be helpful.
=SML
val €cn_show_typing_context› : bool ref = ref false;
val _ = new_flag{
	name="cn_show_typing_context",
	check=fun_true,
	control=cn_show_typing_context,
	default=fun_false} handle Fail _ => ();
=TEX
=FULLVERSION
fun €show_typing_context› (t : TERM) = (
	if	!cn_show_typing_context
	then	let	val cur_thy = get_current_theory_name();
			val zlib = (get_ancestors "z_library" less "z_library")
						handle Fail _ => [];
			val ancs = Sort.sort Sort.string_order
					(get_ancestors cur_thy less cur_thy)
					diff zlib;
			val tic = map dest_var (TypeInference.get_ti_context());
			fun do1tici (n, ty) = "  " ^ n ^ ": " ^ string_of_type ty;
		in	diag_line ("Current theory: " ^ cur_thy);
			diag_line
			(case zlib of [] => "Ancestors:"
			| _ => "Ancestors (up to z_library):");
			map (diag_line o (curry (op^) "  ")) ancs;
			diag_line
			(case tic of [] => "No type inference context."
			| _ => "Type inference context:");
			map (diag_line o do1tici) tic;
			diag_line ("Type-checked term: " ^ string_of_term t);
			()
		end
	else	()
);
=TEX
In the following, it will sometimes be impossible to get a cache theory into
scope. This may happen, for example, in the function {\it z\_prefix} in
the Z Generator module, if a package specification was loaded into a database
that is now an ancestor of the current database. In those cases, the term
should already have been processed when there was a good cache theory and that
cache theory should still be in scope. Consequently we don't fail if we can't
get a cache theory.
(These remarks may become obsolete if we ever get to the situation where all
pre- and post-conditions are type-checked as early as possible and never
type-checked again.)
=FULLVERSION
fun €term_of_z_para› ((ZParaTerm (gpars, tm, _)) : Z_PARA) : TERM = (
    let	val vns = map string_of_ident gpars;
	val vs = map (fn vn =>
		mk_var(vn, mk_z_power_type(mk_vartype ("'" ^ vn)))) vns;
	val t = do_in_theory (force_get_cache_theory()) handle Fail _ => Combinators.I;
    in	list_mk_µ(vs, (t term_of_z_tm tm))
    end
) | term_of_z_para _ = (fail "z_term_recogniser" 49001 []);
=CUTDOWNVERSION
fun €term_of_z_para› () = mk_t;
=TEX

=SML
=FULLVERSION 
fun €z_predexp_of_z_tm› (z_tm : Z_TM) : Z_EXP =
(
    let
        val standard = get_flag "standard_z_terms";
        val z_para = ZParaTerm ([], z_tm, Nil);
        val type_checked = type_check_z_para
                {standard = standard, allow_frees = true} z_para;
        val para = z_para_of_zinferred type_checked;
	 val tm = term_of_z_para para;
    in  show_typing_context tm;
        tm
    end);
=TEX

=SML
end (* of structure CNParser stage 1*);
=TEX

\section{REDUCTION FUNCTIONS}\label{REDUCTIONFUNCTIONS}
=SML
structure €CNParser› (* stage 2 *) = struct
=TEX

=SML
open CNParser;
open CaseIndependence;
=TEX

We give the reduction functions in the order of their appearance
in the grammar of \cite{ISS/HAT/DAZ/DTD503}. When several reduction
functions would be the same, we use $val$ bindings for the various
instances.

=SML
type €AGG› = {tm : TMARK OPT,
                named_assocs : (AGG_CHOICE,EXP) NAMED_ASSOC list,
                others : EXP OPT};
    
datatype €PPARSED› =
           €PPAgg› of AGG
        |  €PPAggregateChoices› of (AGG_CHOICE list * bool)
        |  €PPAnnotation› of ANNOTATION
        |  €PPBasicDecls› of SI_BASIC_DECL list
        |  €PPBinaryOp› of BIN_OP
        |  €PPBinOpTail› of (BIN_OP * EXP) list
        |  €PPCaseAlternatives› of STATEMENT CASE_ALTERNATIVE list
        |  €PPCaseChoices› of CASE_CHOICE list
        |  €PPCompilationUnit› of COMPILATION_UNIT
        |  €PPComponentClauses› of COMPONENT_CLAUSE list
        |  €PPConstraint› of SI_CONSTRAINT
        |  €PPContextClause› of 
			(ID list * (AGG_CHOICE, EXP) PRAGMA list) list *
			ID list *
			ANNOTATION
        |  €PPContextCompilationUnit› of CONTEXT_COMPILATION_UNIT
        |  €PPDeclarations› of DECLARATION list
        |  €PPElsIf› of (EXP * STATEMENT) list
        |  €PPExp› of EXP
        |  €PPExps› of EXP list
        |  €PPFor› of (ID * ID OPT * LOOP_DIRECTION * EXP RANGE OPT)
        |  €PPFormals› of PARAMETER_SPECIFICATION list
        |  €PPFunctionSpecification› of FUNCTION_SPECIFICATION
        |  €PPId› of ID
        |  €PPIdExp› of (ID * EXP)
        |  €PPIds› of ID list
        |  €PPKSlot› of K_SLOT
        |  €PPKSlotCUList› of KSLOT_COMPILATION_UNIT list
        |  €PPMode› of MODE
        |  €PPPackageSpecification› of DECLARATION PACKAGE_DECLARATION
        |  €PPParameterAssociation› of DECLARATION PACKAGE_DECLARATION
        |  €PPPragma› of (AGG_CHOICE, EXP) PRAGMA
        |  €PPPragmaArgs› of (AGG_CHOICE OPT * EXP) list
        |  €PPPragmaList› of (AGG_CHOICE, EXP) PRAGMA list
        |  €PPPrimedIdentifier› of (ID * ID)
        |  €PPProcedureSpecification› of PROCEDURE_SPECIFICATION
        |  €PPProcedureSpecificationStatement› of ID list * STATEMENT
        |  €PPProperBody› of PROPER_BODY
        |  €PPReltail› of (BIN_OP * EXP)
        |  €PPRepresentationClause› of REPRESENTATION_CLAUSE
        |  €PPStatement› of STATEMENT
        |  €PPSubInds› of (EXP * SI_CONSTRAINT) list
        |  €PPSubprogram› of (DECLARATION list * STATEMENT * ID)
        |  €PPSubprogramSpec› of SUBPROGRAM_SPECIFICATION
        |  €PPSubtypeIndication› of (EXP * SI_CONSTRAINT)
        |  €PPTypeDef› of SI_TYPE_DEF
        |  €PPUnaryOp› of UNARY_OP
        |  €PPVarDecls› of SI_VAR_DECL list
        |  €PPWebClause› of WEB_CLAUSE;
=TEX

=SML
fun €different_ids› (id1 : ID, id2 : ID) : bool = (
    (id1 <> id2)
    );
=TEX
=SML
fun €mk_type_mark› (e : EXP) : TMARK = (
    case e 
    of EId id => id
    |  ESelectedComp {prefix, selector} => (mk_type_mark prefix)^"o"^selector
    |  _ => parse_error 503001 "a TYPE MARK is expected here"
);
=TEX
It would probably be neater to define the following in another module.
Quite a few modules depend on this one for no other reason than to use
this function, and it is no longer used here.
=SML
fun €name_to_tmark› (e : EXP) : TMARK = (
    case e 
    of EId id => id
    |  ESelectedComp {prefix, selector} => (name_to_tmark prefix)^"o"^selector
    |  _ => "__invalid"
);
=TEX

=SML
val €z_tm_true› = 
=FULLVERSION
  ZUserInterfaceSupport.ZTmTruth true; 
=CUTDOWNVERSION
  dummy_z_tm;
=TEX

=SML
fun €is_range_attribute› (EAttribute{attribute_desig=ad,...}) = (
    case ad 
    of ADAttrib attname => attname = "RANGE"
    |  ADAttribArg (attname,_) => attname = "RANGE")
    |  is_range_attribute _ = false;
=SML
fun €exp_to_discrete_range› (EDiscreteRange (DRConstrained{tmark, range}) : EXP)
	: SI_DISCRETE_RANGE = (
	SIDiscreteRangeSubInd{tmark = tmark, con = CRange range}
) | exp_to_discrete_range (EDiscreteRange (DRRange range)) = (
	SIDiscreteRangeRange range
) | exp_to_discrete_range e = (
	if	is_range_attribute e
	then	SIDiscreteRangeRange(RRangeAttr e)
  	else	SIDiscreteRangeSubInd{tmark = mk_type_mark e, con = CNoCon}
);
=TEX
=SML
fun €si_to_discrete_range› (e : EXP, con : SI_CONSTRAINT) 
	: EXP = (
	case con of
		SINoCon => (
		case e of
			EDiscreteRange _ => e
		|	_ =>
			if	is_range_attribute e
			then	EDiscreteRange(DRRange(RRangeAttr e))
 		 	else	e
	) |	SIRangeCon range =>
		EDiscreteRange(DRConstrained{tmark = mk_type_mark e, range = range})
	|	_ => parse_error 503001
			"a DISCRETE SUBTYPE INDICATION or a RANGE is expected here"
);
=TEX
=SML
val €si_to_constraint› : EXP * SI_CONSTRAINT -> SI_DISCRETE_RANGE =
	exp_to_discrete_range o si_to_discrete_range;
=TEX
=SML
fun €si_to_tmark› (e : EXP, con : SI_CONSTRAINT) : TMARK = (
	case con of
		SINoCon => mk_type_mark e
	|	_ => parse_error 503001
			"a DISCRETE SUBTYPE INDICATION or a RANGE is not allowed here"
);
=SML
fun €exp_to_range› (EDiscreteRange (DRRange range) : EXP) : EXP RANGE = (
    range
) | exp_to_range e = (
    if is_range_attribute e
    then
        RRangeAttr e
    else
        parse_error 503001 "a RANGE is expected here"
);
=TEX
=SML
fun €is_range› (EDiscreteRange (DRRange range) : EXP) : bool = (
    true
) | is_range e = (
    is_range_attribute e
);
=SML
fun €exp_to_loop_params› (EDiscreteRange (DRConstrained{tmark, range}) : EXP)
	: ID OPT * EXP RANGE OPT= (
	(Value tmark, Value range)
) | exp_to_loop_params (EDiscreteRange (DRRange range)) = (
	(Nil, Value range) 
) | exp_to_loop_params e = (
	if	is_range_attribute e
	then	(Nil, Value(RRangeAttr e))
  	else	(Value (mk_type_mark e), Nil)
);
=TEX
=SML
fun €mk_exp_of_exp› (e : EXP) : EXP = (
    case e of
    	EDiscreteRange _ => (
        		parse_error
		503001 "a RANGE or CONSTRAINED SUBTYPE INDICATION is not permitted here"
    ) |	EArrayAggPos{tmark = tm,comps = es} => (
		EArrayAggPos{tmark = tm, comps = map mk_exp_of_exp es}
    ) | _ => e
);
=TEX
=SML
fun €mk_exp_of_sub_ind› ((e, con) : EXP * SI_CONSTRAINT) : EXP = (
    case con of
    	SINoCon => (e
    ) | _ => (	parse_error
		503001 "a CONSTRAINED SUBTYPE INDICATION is not permitted here"
    )
);
=TEX
=SML
fun €mk_sub_ind› ((e, con) : EXP * SI_CONSTRAINT) : SI_SUB_IND =(
	let	val (tmark, constr) = (
		case e of
			EIndexedComp{prefix=prefix,index=index} => (
				case con of
					SINoCon =>
					(mk_type_mark prefix, SIDiscriminantCon[index])
				| _ => (mk_type_mark e, con)
		) |  _ => (mk_type_mark e, con));
	in	{tmark = tmark, con = constr}
	end
);
=TEX
=SML
fun €par_spec_to_disc_spec› ({idlist, mode, name} : PARAMETER_SPECIFICATION)
	: DISCRIMINANT_SPECIFICATION = (
	case mode of
		MSparkIn false => {vars = idlist, tmark = name}
	|	_ => parse_error 503001
			"a parameter mode is not allowed in a discriminant specification"
);
=TEX
\subsection{Support for Unlabelled KSlots and Specification Statements}

The following reference variable keeps a note of the last unlabelled kslot or specification statement.

=SML
val €unlabelled_stack› : string OPT ref = ref Nil;
val €unlabelled_provisional› : string OPT ref = ref Nil;
val €unlabelled_counter› : int ref = ref 1;
val €last_label› : LABEL ref = ref "";
=TEX

=SML
type €CN_PARSER_STATE› = {
    unlabelled_stack : string OPT,
    unlabelled_provisional : string OPT,
    unlabelled_counter : int,
    last_label : LABEL
    };
=TEX

=SML
fun €implicit_label_of_int› (i : int) = (
    (!last_label) ^ "_" ^ (string_of_int i)
    );
=TEX

=SML
fun €get_cn_parser_state› (() : unit) : CN_PARSER_STATE = (
    {
        unlabelled_stack = !unlabelled_stack,
        unlabelled_provisional = !unlabelled_provisional,
        unlabelled_counter = !unlabelled_counter,
        last_label = !last_label
    }
    );
=TEX

=SML
fun €set_cn_parser_state› (cnps : CN_PARSER_STATE) : unit = (
    unlabelled_stack := #unlabelled_stack cnps;
    unlabelled_provisional := #unlabelled_provisional cnps;
    unlabelled_counter := #unlabelled_counter cnps;
    last_label := #last_label cnps
    );
=TEX
=SML
fun €reset_cn_parser_state› () : unit = (
    unlabelled_stack := Nil;
    unlabelled_counter := 1;
    unlabelled_provisional := Nil;
    last_label := ""
    );
=TEX

When we encounter a k-slot or a specification statement with no label on the rhs, we give it a provisional label. The check that there is no outstanding unlabelled k-slot or specification statement happens later, at which point if all is OK, the provisional label becomes the actual label for expansion.
=SML
fun €push_label› (() : unit) : string = (
if !unlabelled_provisional = Nil
then
    let val label = implicit_label_of_int (!unlabelled_counter);
        val side = unlabelled_counter := (!unlabelled_counter) + 1;
        val side = unlabelled_provisional := Value label;
    in
        label
    end
else    (
    unlabelled_provisional := Nil;
    parse_error 503001
    "There is already an unlabelled, \
    \unexpanded K-Slot or Specification Statement in the script"
    )
    );
=TEX

The following function should be called when a refinement or replaced-by has been parsed. It updates the label stack with a newly generated label. This caters for a specification statement which is unlabelled, and is itself intended to be expanded with an unlabelled expansion.

=SML
fun €update_unlabelled_stack› (() : unit) : unit = (
    if !unlabelled_stack <> Nil
    then    if !unlabelled_provisional <> Nil
        then    (
            unlabelled_provisional := Nil;
            parse_error 503001
            "There is already an unlabelled, unexpanded K-Slot or Specification Statement in the script"
        )
        else    ()
    else    (
        unlabelled_stack := !unlabelled_provisional;
        unlabelled_provisional := Nil
    )
    );
=TEX

=SML
fun €pop_label› (() : unit) : string = (
case !unlabelled_stack 
    of Nil => parse_error 503001
        "there is no unlabelled k-slot or specification statement to expand"
    |Value label => (
        unlabelled_stack := Nil;
        label
    )
    );
=TEX

\subsection{Reduction Functions}
=SML
fun €red_accept› (Parsed pp) = (pp)
|   red_accept (Token ((l,CNText t),_)) = (
    stack_error ("red_accept [Token("
=POLYML
        ^(PolyML.makestring l)^", Text "^(PolyML.makestring t)^")]"))
=NJML
        ^"... )]"))
=SML
|   red_accept (Token ((l,t),_)) = (
    stack_error ("red_accept ["
=POLYML
        ^(PolyML.makestring l)^", "^(PolyML.makestring t)^"]"));
=NJML
        ^"... )]"))
=TEX

=SML
fun €red_web_clause1› (Parsed (PPKSlotCUList cul)) = (
    update_unlabelled_stack();
    PPWebClause (WCCompilation cul))
|   red_web_clause1 _ =
        stack_error "red_web_clause1";

fun €red_web_clause2
        (Token ((_, CNText lab), _)) _ (Parsed (PPKSlotCUList cul)) = (
    update_unlabelled_stack();
    PPWebClause (WCReplacedByCompilation {label=lab,comp=cul}))
|   red_web_clause2 _ _ _ =
        stack_error "red_web_clause2";

fun €red_web_clause3
        (Token ((_,CNText lab), _)) _ (Parsed (PPDeclarations d)) = (
    update_unlabelled_stack();
    PPWebClause (WCReplacedByPrivatePart {label=lab, private=d}))
|   red_web_clause3 _ _ _ =
        stack_error "red_web_clause3";

fun €red_web_clause4
        (Token ((_,CNText lab), _)) _ (Parsed (PPDeclarations d)) = (
    update_unlabelled_stack();
    PPWebClause (WCReplacedByVisiblePart {label=lab, visible=d}))
|   red_web_clause4 _ _ _ =
        stack_error "red_web_clause4";

fun €red_web_clause5
        (Token ((_,CNText lab), _)) _ (Parsed (PPDeclarations d)) = (
    update_unlabelled_stack();
    PPWebClause (WCReplacedByDecl {label=lab, decls=d}))
|   red_web_clause5 _ _ _ =
        stack_error "red_web_clause5";

fun €red_web_clause6
        (Token ((_,CNText lab), _)) _ (Parsed (PPStatement s)) = (
    update_unlabelled_stack();
    PPWebClause (WCReplacedBy {label=lab, statement=s}))
|   red_web_clause6 _ _ _ =
        stack_error "red_web_clause6";

fun €red_web_clause7
        (Token ((_,CNText lab), _)) _ (Parsed (PPStatement s)) = (
    update_unlabelled_stack();
    PPWebClause (WCRefinedBy {label=lab, statement=s}))
|   red_web_clause7 _ _ _ =
        stack_error "red_web_clause7";

fun €red_web_clause8› _ (Parsed (PPStatement s)) = (
let val lab = pop_label();
    val side = update_unlabelled_stack();
in
    PPWebClause (WCRefinedBy {label=lab, statement=s})
end)
|   red_web_clause8 _ _ =
        stack_error "red_web_clause8";

fun €red_web_clause9
        (Token ((_,CNText lab), _)) _ (Parsed (PPStatement s)) = (
    update_unlabelled_stack();
    PPWebClause (WCReplacedBy {label=lab, statement=s}))
|   red_web_clause9 _ _ _ =
        stack_error "red_web_clause9";

fun €red_web_clause10›  _ (Parsed (PPStatement s)) = (
let val lab = pop_label();
    val side = update_unlabelled_stack();
in
    PPWebClause (WCReplacedBy {label=lab, statement=s})
end)
|   red_web_clause10 _ _ =
        stack_error "red_web_clause10";

fun €red_web_clause11› (Parsed(PPId lab)) (Token ((LCArbitraryAda,CNText aa), _)) = (
    update_unlabelled_stack();
    PPWebClause (WCReplacedByArbitraryAda {label=lab, replacement=aa})
)|   red_web_clause11 _ _ =
        stack_error "red_web_clause11";

fun €red_web_clause12› (Token ((LCArbitraryAda,CNText aa), _)) = (
let val lab = pop_label();
    val side = update_unlabelled_stack();
in
    PPWebClause (WCReplacedByArbitraryAda {label=lab, replacement=aa})
end
)|   red_web_clause12 _ =
        stack_error "red_web_clause12";

fun €red_web_clause13
        (Token ((_,CNText lab), _))  _ (Parsed (PPAnnotation ann)) = (
    update_unlabelled_stack();
    PPWebClause (WCReplacedByAnnotation {label=lab, replacement=ann})
)|   red_web_clause13 _ _ _ =
        stack_error "red_web_clause13";
 
fun €red_any_label› (Token ((_,CNText lab), _)) =
    PPId lab
|   red_any_label _ = stack_error "red_any_label";
=TEX

=SML
val €red_basic_declaration1› = red_accept;
val €red_basic_declaration2› = red_accept;
val €red_basic_declaration3› = red_accept;
val €red_basic_declaration4› = red_accept;

fun €red_basic_declaration5› (Parsed (PPPragma e)) = 
	PPBasicDecls[SIPragma e]
|   red_basic_declaration5 _ = stack_error "red_basic_declaration5";

fun €red_basic_declaration6› (Token ((LCAnnotation,CNText ann), _)) = 
	PPBasicDecls[SIAnnotation [ANString ann]]
|   red_basic_declaration6 _ = stack_error "red_basic_declaration6";

val €red_object_declaration1› = red_accept;
val €red_object_declaration2› = red_accept;
=TEX

=SML
fun €red_constant_declaration1
        (Parsed(PPIds ids)) _ _ (Parsed(PPSubtypeIndication si)) _ (Parsed(PPExp e)) _ = (
    PPBasicDecls[SIConstDecl{consts=ids, t=Value (mk_sub_ind si), expr=e}])
|   red_constant_declaration1 _ _ _ _ _ _ _ =
        stack_error "red_constant_declaration1";

fun €red_constant_declaration2
        (Parsed(PPIds ids)) _ _ _ (Parsed(PPExp e)) _ = (
    PPBasicDecls[SIConstDecl{consts=ids, t=Nil, expr=e}])
|   red_constant_declaration2 _ _ _ _ _ _ =
        stack_error "red_constant_declaration2";

fun €red_variable_declaration› (Parsed(PPIds ids)) _ (Parsed(PPSubtypeIndication si)) _ = (
    PPBasicDecls[SIVarDecl{vars=ids, t=mk_sub_ind si}])
|   red_variable_declaration _ _ _ _ =
        stack_error "red_variable_declaration";

fun €red_variable_declaration2› (Parsed(PPIds ids)) _ (Parsed(PPSubtypeIndication si)) _ 
	(Parsed(PPExp init)) _ = (
    PPBasicDecls[SIVarDeclInit({vars=ids, t=mk_sub_ind si}, init)])
|   red_variable_declaration2 _ _ _ _ _ _ =
        stack_error "red_variable_declaration2";

fun €red_identifier_list1› (Token ((_,CNText id), _)) = (
    PPIds [id])
|   red_identifier_list1 _ =
        stack_error "red_identifier_list1";

fun €red_identifier_list2› (Token ((_,CNText id), _)) _ (Parsed(PPIds ids)) = (
    PPIds (id::ids))
|   red_identifier_list2 _ _ _ =
        stack_error "red_identifier_list2";
=TEX

=SML
val €red_type_declaration1› = red_accept;
val €red_type_declaration2› = red_accept;
=TEX

=SML
fun €red_full_type_declaration1›
        _ (Token ((_,CNText id), _)) _ (Parsed(PPTypeDef td)) _ = (
    PPBasicDecls[SITypeDecl{name=id, type_def=td}])
|   red_full_type_declaration1 _ _ _ _ _ =
        stack_error "red_full_type_declaration1";
=TEX

=SML
fun €red_full_type_declaration2›
        _ (Token ((_,CNText id), _)) (Parsed (PPFormals fps)) _ (Parsed(PPTypeDef td)) _ = (
	case td of 
		SIRecordTypeDef {decl, ...} => (
    			PPBasicDecls[SITypeDecl{
				name=id,
				type_def = SIRecordTypeDef {
					decl = decl,
					disc = map par_spec_to_disc_spec fps}}])
	|	_ => parse_error 503001
	"A discriminant part is only allowed in a private or record type declaration"
) | red_full_type_declaration2 _ _ _ _ _ _ =
        stack_error "red_full_type_declaration2";
=TEX

=SML
val €red_type_definition1› = red_accept;
val €red_type_definition2› = red_accept;
val €red_type_definition3› = red_accept;
val €red_type_definition4› = red_accept;
val €red_type_definition5› = red_accept;
=TEX

=SML
fun €red_subtype_declaration› _ (Token ((_,CNText id), _)) _
        (Parsed(PPSubtypeIndication si)) _ = (
    PPBasicDecls[SISubtypeDecl{name=id, type_def=mk_sub_ind si}])
|   red_subtype_declaration _ _ _ _ _ =
        stack_error "red_subtype_declaration";

fun €red_subtype_indication1› (Parsed(PPExp e)) (Parsed(PPConstraint c)) = (
        PPSubtypeIndication(e, c))
|   red_subtype_indication1 _ _ =
        stack_error "red_subtype_indication1";

fun €red_subtype_indication2› (Parsed(PPExp n))  = (
    PPSubtypeIndication(n, SINoCon))
|   red_subtype_indication2 _ =
        stack_error "red_subtype_indication2";
=TEX

=SML
fun €red_constraint1› (Parsed(PPExp e)) = (
    PPConstraint (SIRangeCon (exp_to_range e)))
|   red_constraint1 _ =
        stack_error "red_constraint1";

val €red_constraint2› = red_accept;
val €red_constraint3› = red_accept;
=TEX
=SML
fun €red_range_constraint› _ (Parsed (PPExp e)) = (
    PPExp(EDiscreteRange (DRRange (exp_to_range e)))
) | red_range_constraint _ _ =
        stack_error "red_range_constraint";

fun €red_enumeration_type_definition› _ (Parsed(PPIds ids)) _ = (
    PPTypeDef(SIEnumTypeDef{vals = ids}))
|   red_enumeration_type_definition _ _ _ =
        stack_error "red_enumeration_type_definition";
=TEX

=SML
fun €red_integer_type_definition› (Parsed (PPExp e)) = (
    PPTypeDef(SIIntTypeDef (exp_to_range e)))
|   red_integer_type_definition _ =
        stack_error "red_integer_type_definition";

fun €red_real_type_definition1› (Parsed(PPConstraint(SIFloatingCon c))) = (
    PPTypeDef(SIFloatingTypeDef c))
|   red_real_type_definition1 _ =
        stack_error "red_real_type_definition1";

fun €red_real_type_definition2› (Parsed(PPConstraint (SIFixedCon c))) = (
    PPTypeDef(SIFixedTypeDef c))
|   red_real_type_definition2 _ =
        stack_error "red_real_type_definition2";
=TEX

SPARK manual 3.5.7:
=SML
fun €red_floating_point_constraint1› (Parsed(PPExp e)) = (
    PPConstraint(SIFloatingCon{exp=e, range=Nil}))
|   red_floating_point_constraint1 _ =
        stack_error "red_floating_point_constraint1";

fun €red_floating_point_constraint2
        (Parsed(PPExp e)) (Parsed (PPExp re)) = (
    PPConstraint(SIFloatingCon{exp=e, range=Value (exp_to_range re)}))
|   red_floating_point_constraint2 _ _ =
        stack_error "red_floating_point_constraint2";

fun €red_floating_accuracy_definition› _ (Parsed p) = (p)
|   red_floating_accuracy_definition _ _ =
        stack_error "red_floating_accuracy_definition";
=TEX

=SML
fun €red_fixed_point_constraint1› (Parsed(PPExp e)) = (
    PPConstraint(SIFixedCon{exp=e, range=Nil}))
|   red_fixed_point_constraint1 _ =
        stack_error "red_fixed_point_constraint1";

fun €red_fixed_point_constraint2› (Parsed(PPExp e)) (Parsed(PPExp re)) = (
        PPConstraint(SIFixedCon{exp=e, range=Value (exp_to_range re)}))
|   red_fixed_point_constraint2 _ _ =
        stack_error "red_fixed_point_constraint2";

fun €red_fixed_accuracy_definition› _ (Parsed p) = (p)
|   red_fixed_accuracy_definition _ _ =
        stack_error "red_fixed_accuracy_definition";
=TEX

=SML
val €red_array_type_definition1› = red_accept;
val €red_array_type_definition2› = red_accept;
=TEX

=SML
fun €red_unconstrained_array_definition› _ _ (Parsed(PPSubInds nl)) _ _
	(Parsed(PPSubtypeIndication si)) = (
    PPTypeDef(SIUnconArrayDef{
		index=map si_to_constraint nl,
		comp=mk_sub_ind si}))
|   red_unconstrained_array_definition _ _ _ _ _ _ =
        stack_error "red_unconstrained_array_definition";

fun €red_constrained_array_definition› _ (Parsed(PPSubInds nl)) _
		(Parsed(PPSubtypeIndication si)) = (
    PPTypeDef(SIConArrayDef{
		index=map si_to_constraint nl,
		comp=mk_sub_ind si}))
|   red_constrained_array_definition _ _ _ _ =
        stack_error "red_constrained_array_definition";
=TEX

=SML
fun €red_index_subtype_definition_list1› (Parsed(PPExp n)) = (
    PPSubInds [(n, SINoCon)])
|   red_index_subtype_definition_list1 _ =
        stack_error "red_index_subtype_definition_list1";
=TEX

=SML
fun €red_index_subtype_definition_list2› (Parsed(PPExp n)) _ (Parsed(PPSubInds nl)) = (
    PPSubInds ((n, SINoCon)::nl))
|   red_index_subtype_definition_list2 _ _ _ =
        stack_error "red_index_subtype_definition_list2";

fun €red_index_subtype_definition› (Parsed p) _ _ = (
    p)
|   red_index_subtype_definition _ _ _ =
        stack_error "red_index_subtype_definition";
fun €red_index_constraint› _ (Parsed p) _ = (
    p    )
|   red_index_constraint _ _ _ =
        stack_error "red_index_constraint";

fun €red_discrete_range_list1› (Parsed(PPSubtypeIndication si)) = (
    PPSubInds [si])
|   red_discrete_range_list1 _ =
        stack_error "red_discrete_range_list1";

fun €red_discrete_range_list2› (Parsed(PPSubtypeIndication si)) _
	(Parsed(PPSubInds sil)) = (
    PPSubInds (si::sil))
|   red_discrete_range_list2 _ _ _ =
        stack_error "red_discrete_range_list2";
=TEX

=SML
fun €red_discrete_range1›
	(Parsed (PPExp e))
	(Parsed (PPExp (EDiscreteRange (DRRange range)))) = (
    PPExp(EDiscreteRange(DRConstrained{
	tmark = mk_type_mark e,
	range = range}))
) |   red_discrete_range1 (Parsed _) (Parsed _) = (
	parse_error 503001 "a DISCRETE RANGE was expected here"
) |   red_discrete_range1 _ _ =
        stack_error "red_discrete_range1";
=TEX
=SML
val €red_discrete_range2› = red_accept;

fun €red_record_type_definition› _ (Parsed(PPVarDecls vs)) _ _ = (
    PPTypeDef(SIRecordTypeDef{decl=vs, disc = []}))
|   red_record_type_definition _ _ _ _ =
        stack_error "red_record_type_definition";
=TEX


=SML
val €red_component_list1› = red_accept;

fun €red_component_list2› (Parsed(PPVarDecls[v])) (Parsed(PPVarDecls vs)) = (
    PPVarDecls (v::vs))
|   red_component_list2 _ _ =
        stack_error "red_component_list2";

fun €red_component_declaration› (Parsed(PPIds ids)) _ (Parsed(PPSubtypeIndication si)) _ = (
    PPVarDecls [{vars=ids, t=mk_sub_ind si}])
|   red_component_declaration _ _ _ _ =
        stack_error "red_component_declaration";
=TEX

SPARK manual 3.9:
=TEX

=SML
val €red_declarative_part1› = PPDeclarations [];

fun €red_declarative_part2› (Parsed (PPDeclarations d1)) (Parsed (PPDeclarations d2)) = (
    PPDeclarations (d1@d2))
|   red_declarative_part2 _ _ =
        stack_error "red_declarative_part2";
=TEX

=SML
fun €red_dec1› (Parsed(PPKSlot k)) = (
    PPDeclarations [DDeclarationKSlot (k, DKDeclaration)])
|   red_dec1 _ =
        stack_error "red_dec1";

val €red_dec2› = red_accept;
val €red_dec3› = red_accept;
val €red_dec4› = red_accept;
val €red_dec5› = red_accept;
=TEX

=SML
fun €red_basic_declarative_item1› (Parsed(PPBasicDecls bds)) = (
    PPDeclarations(map (fn x => DBasicDecl x) bds))
|   red_basic_declarative_item1 _ =
        stack_error "red_basic_declarative_item1";

fun €red_basic_declarative_item2› (Parsed(PPRepresentationClause rc)) = (
    PPDeclarations [DRepresentationClause rc])
|   red_basic_declarative_item2 _ =
        stack_error "red_basic_declarative_item2";

fun €red_body1› (Parsed(PPProperBody p)) = (
    PPDeclarations[DProperBody p])
|   red_body1 _ =
        stack_error "red_body1";
val €red_body2› = red_accept;

val €red_proper_body› = red_accept;
=TEX

=SML
fun €red_name1› (Token ((_,CNText name), _)) = (
    PPExp(EId name))
|   red_name1 _ =
        stack_error "red_name1";

val €red_name2› = red_accept;
val €red_name3› = red_accept;
val €red_name4› = red_accept;
=TEX

SPARK manual 4.1.1:
=SML
fun €red_indexed_component› (Parsed(PPExp n)) (Parsed(PPExp index)) = (
    case (n, index) 
    of (EAttribute {prefix=prefix,attribute_desig=ADAttrib ad}, _) => (
        case index of
            EArrayAggPos{comps = [e], ...} => (
                   PPExp(EAttribute
                      {prefix=prefix,attribute_desig=ADAttribArg(ad,e)})
        ) | _ => parse_error 503001
                 "this form of parameter list is not allowed with an attribute"
    ) |  (_, EArrayAggNamedOthers _) => (
        parse_error 503001 "OTHERS is not allowed here"
    ) |  (_, EArrayAggPosOthers _) => (
        parse_error 503001 "OTHERS is not allowed here"
    ) |  (_, EArrayAggOthers _) => (
        parse_error 503001 "OTHERS is not allowed here"
    ) |_ => (
        PPExp(EIndexedComp{prefix=n, index=index})
    ))
|   red_indexed_component _ _ =
        stack_error "red_indexed_component";
=TEX

SPARK manual 4.1.3:
=SML
fun €red_selected_component› (Parsed(PPExp n)) _ (Parsed(PPId id)) = (
    PPExp(ESelectedComp{prefix=n, selector=id}))
|   red_selected_component _ _ _ =
        stack_error "red_selected_component";

fun €red_selector› (Token ((_,CNText id), _)) = (
    PPId id)
|   red_selector _ =
        stack_error "red_selector";
=TEX

SPARK manual 4.1/4.1.1:
=SML
fun €red_expression_list1› (Parsed(PPExp e)) = (
    PPExps [e])
|   red_expression_list1 _ =
        stack_error "red_expression_list1";

fun €red_expression_list2› (Parsed(PPExps es)) _ (Parsed(PPExp e)) = (
    PPExps (es@[e]))
|   red_expression_list2 _ _ _ =
        stack_error "red_expression_list2";
=TEX

=SML
fun €red_attribute1› (Parsed(PPExp n)) (Token ((_,CNText primedid), _)) = (
    PPExp(EAttribute{prefix=n, attribute_desig=ADAttrib
    ((implode o tl o explode) primedid)}))
|   red_attribute1 _ _ =
        stack_error "red_attribute1";

fun €red_attribute2› (Token ((CharacterLiteral,CNString id), _))
    (Token ((_,CNText primedid), _)) = (
    PPExp(EAttribute{prefix=ECharacterLiteral id, attribute_desig=ADAttrib
    ((implode o tl o explode) primedid)}))
|   red_attribute2 _ _ =
        stack_error "red_attribute2";

fun €red_aggregate› _ (Parsed p) _ = (
    p)
|   red_aggregate _ _ _ =
        stack_error "red_aggregate";
=TEX

=SML
fun €red_component_association1› (Parsed(PPAgg{named_assocs=na,others=ot,...})) = (
    case (ot, na) 
    of (Value oe, _::_) => (
        PPExp (EArrayAggNamedOthers{
            agg_named={tmark=Nil, named_assocs=na},others={others=oe}})
    )|  (Value oe, _) => (
        PPExp (EArrayAggOthers{tmark=Nil, others={others=oe}})
    )|(Nil, _) => (
        PPExp (EArrayAggNamed{tmark=Nil, named_assocs=na})
    ))
|   red_component_association1 _ =
        stack_error "red_component_association1";

val €red_component_association2› = red_accept;

=TEX

=SML
fun €red_named_association1› (Parsed(PPAggregateChoices v)) _ (Parsed(PPExp e)) = (
    case v 
    of ([],true) => PPAgg{tm=Nil, named_assocs=[], others=Value e}
    |(c, false) => PPAgg{tm=Nil, named_assocs =[{choice=c, comp=e}],others=Nil}
    |_ => parse_error 503001 "OTHERS is not allowed here")
|   red_named_association1 _ _ _ =
        stack_error "red_named_association1";

fun €red_named_association2› (Parsed(PPAggregateChoices v)) _
    (Parsed(PPExp e)) _ (Parsed(PPAgg {named_assocs=na,others=ot,...})) = (
    case v 
    of (c as _::_, false) =>
        PPAgg{tm=Nil,named_assocs={choice=c,comp=e}::na,others=ot}
    |_ => parse_error 503001 "OTHERS is not allowed here")
|   red_named_association2 _ _ _ _ _ =
        stack_error "red_named_association2";

fun €red_aggregate_choice_list1› (Token ((LCOthers,_), _)) = (
    PPAggregateChoices ([], true))
|   red_aggregate_choice_list1 _ =
        stack_error "red_aggregate_choice_list1";

val €red_aggregate_choice_list2› = red_accept;

fun €red_aggregate_choice_list3› (Parsed(PPAggregateChoices v)) _
    (Parsed(PPAggregateChoices (acl, true))) = (
    parse_error 503001 "OTHERS is not allowed here")
|   red_aggregate_choice_list3 (Parsed(PPAggregateChoices v)) _
    (Parsed(PPAggregateChoices (acl, false))) = (
    case v 
    of ([ac], false) => PPAggregateChoices((ac::acl), false)
    |_ => parse_error 503001 "OTHERS is not allowed here")
|   red_aggregate_choice_list3 _ _ _ =
        stack_error "red_aggregate_choice_list3";
=TEX

=SML
fun €red_aggregate_choice› (Parsed(PPExp e)) = (
    case  e of
       EDiscreteRange (DRConstrained{tmark, range}) => (
        PPAggregateChoices([ACAggChoiceRange(DRConstrained
                {tmark=tmark, range=range})],false)
    ) | EDiscreteRange (DRRange range) => (
        PPAggregateChoices([ACAggChoiceRange
            (DRRange range)],false)
    ) | _ => (
        if is_range_attribute e
        then
            PPAggregateChoices([ACAggChoiceRange
                (DRRange(exp_to_range e))],false)
        else
            PPAggregateChoices([ACAggChoiceSingle e],false)
    )
) |   red_aggregate_choice _ =
        stack_error "red_aggregate_choice";

fun €red_positional_association1› (Parsed(PPExps es)) = (
    PPExp(EArrayAggPos{tmark=Nil,comps = map mk_exp_of_exp es}))
|   red_positional_association1 _ =
        stack_error "red_positional_association1";

fun €red_positional_association2› (Parsed(PPExps es)) _ _ _ (Parsed(PPExp e)) = (
    PPExp(EArrayAggPosOthers{agg_pos={tmark=Nil,comps=map mk_exp_of_exp es},
        others={others=mk_exp_of_exp e}}))
|   red_positional_association2 _ _ _ _ _ =
        stack_error "red_positional_association2";
=TEX

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
=SML
val €red_ranged_expression1› = red_accept;

fun €red_ranged_expression2› (Parsed (PPExp e)) (Parsed (PPExp re)) = (
	PPExp(EDiscreteRange(DRConstrained{
		tmark=mk_type_mark e,
		range=exp_to_range re}))
) | red_ranged_expression2 _ _ =
	stack_error "red_ranged_expression2";

val €red_expression1› = red_accept;

fun €red_expr› (Parsed (PPExp exp1)) (Parsed (PPReltail(binop, exp2))) = (
    PPExp (EBinExp {bop = binop, left = exp1, right = exp2}))
|   red_expr _ _ =
        stack_error "red_expr";

val €red_expression2› = red_expr;
val €red_expression3› = red_expr;
val €red_expression4› = red_expr;
val €red_expression5› = red_expr;
val €red_expression6› = red_expr;
=TEX

=SML
fun €red_logrel1› binop (Parsed(PPExp exp)) = (
    PPReltail(binop, exp))
|   red_logrel1 _ _ =
        stack_error "red_logrel1";

fun €red_logrel2› binop (Parsed(PPExp exp1)) (Parsed(PPReltail(_,exp2))) = (
    PPReltail(binop, EBinExp{bop=binop, left=mk_exp_of_exp exp1,
	right=mk_exp_of_exp exp2}))
|   red_logrel2 _ _ _ =
        stack_error "red_logrel2";

fun €red_and_relation1› _ x2 =(red_logrel1 BOSparkAnd x2);
fun €red_and_relation2› _ x2 x3 =(red_logrel2 BOSparkAnd x2 x3);
fun €red_and_then_relation1› _ _ x3 =(red_logrel1 BOSparkAndThen x3);
fun €red_and_then_relation2› _ _ x3 x4 =(red_logrel2 BOSparkAndThen x3 x4);
fun €red_or_relation1› _ x2 =(red_logrel1 BOSparkOr x2);
fun €red_or_relation2› _ x2 x3 =(red_logrel2 BOSparkOr x2 x3);
fun €red_or_else_relation1› _ _ x3 =(red_logrel1 BOSparkOrElse x3);
fun €red_or_else_relation2› _ _ x3 x4 =(red_logrel2 BOSparkOrElse x3 x4);
fun €red_xor_relation1› _ x2 =(red_logrel1 BOSparkXor x2);
fun €red_xor_relation2› _ x2 x3 =(red_logrel2 BOSparkXor x2 x3);
=TEX

=SML
fun €red_relation1› (Parsed(PPExp sr)) = (
    PPExp sr)
|   red_relation1 _ =
        stack_error "red_relation1";

fun €red_relation2› (Parsed(PPExp sr1)) (Parsed(PPBinaryOp b))
    (Parsed(PPExp sr2)) = (
    PPExp(EBinExp{left=mk_exp_of_exp sr1,bop=b,
                right=mk_exp_of_exp sr2}))
|   red_relation2 _ _ _ =
        stack_error "red_relation2";

fun €red_relation3› (Parsed(PPExp sr1)) _
    (Parsed(PPExp sr2)) = (
	if	is_range sr2
    	then	PPExp(EMemRange{left=mk_exp_of_exp sr1, mop=BOSparkMem,
                range=exp_to_range sr2})
	else	PPExp(EBinExp{left=mk_exp_of_exp sr1,
        bop=BOSparkMem, right=mk_exp_of_exp sr2}))
|   red_relation3 _ _ _ =
        stack_error "red_relation3";

fun €red_relation4› (Parsed(PPExp sr1)) _ _
    (Parsed(PPExp sr2)) = (
	if	is_range sr2
    	then	PPExp(EMemRange{left=mk_exp_of_exp sr1, mop=BOSparkNotMem,
                range=exp_to_range sr2})
	else	PPExp(EBinExp{left=mk_exp_of_exp sr1,
        bop=BOSparkNotMem, right=mk_exp_of_exp sr2}))
|   red_relation4 _ _ _ _ =
        stack_error "red_relation4";
=TEX

=SML
val €red_sr_expression1› = red_accept;

fun €red_sr_expression2› (Parsed(PPExp e1)) _ (Parsed(PPExp e2)) = (
    PPExp(EDiscreteRange (DRRange (RRange{lo=mk_exp_of_exp e1, hi=mk_exp_of_exp e2})))
) | red_sr_expression2 _ _ _ =
        stack_error "red_sr_expression2";
=TEX

=SML
fun do_binarytail left ((b,right)::(rest as (_::_))) = (
   do_binarytail (EBinExp{left=mk_exp_of_exp left, bop=b, right=mk_exp_of_exp right}) rest)
|   do_binarytail left [(b,right)] = (
    EBinExp{left=mk_exp_of_exp left, bop=b, right=mk_exp_of_exp right})
|   do_binarytail left [] = left;

fun €red_simple_expression1› (Parsed(PPExp e)) (Parsed(PPBinOpTail tl)) = (
    PPExp (do_binarytail e tl))
|   red_simple_expression1 _ _ =
        stack_error "red_simple_expression1";

fun €red_simple_expression2› (Parsed(PPUnaryOp uop)) (Parsed(PPExp e))
    (Parsed(PPBinOpTail tl)) = (
    PPExp (do_binarytail (EUnaryExp{uop=uop,right=mk_exp_of_exp e}) tl))
|   red_simple_expression2 _ _ _ =
        stack_error "red_simple_expression2";

val €red_binoptail1› = PPBinOpTail [];

fun €red_binoptail2› (Parsed(PPBinaryOp b)) (Parsed(PPExp e))
    (Parsed(PPBinOpTail tl)) = (
    PPBinOpTail((b,e)::tl))
|   red_binoptail2 _ _ _ =
        stack_error "red_binoptail2";

val €red_term1› = red_accept;

fun €red_term2› (Parsed(PPExp e1)) (Parsed(PPBinaryOp m)) (Parsed(PPExp e2)) = (
    PPExp(EBinExp{left=e1,bop=m,right=e2}))
|   red_term2 _ _ _ =
        stack_error "red_term2";
=TEX

=SML
val €red_factor1› = red_accept;
fun €red_factor2› (Parsed(PPExp e1)) _ (Parsed(PPExp e2)) = (
    PPExp(EBinExp{left=e1,bop=BOSparkExpon,right=e2}))
|   red_factor2 _ _ _ =
        stack_error "red_factor2";

fun €red_factor3› _ (Parsed(PPExp e)) = (
    PPExp(EUnaryExp{uop=UOSparkAbs, right=e}))
|   red_factor3 _ _ =
        stack_error "red_factor3";

fun €red_factor4› _ (Parsed(PPExp e)) = (
    PPExp(EUnaryExp{uop=UOSparkNot, right=e}))
|   red_factor4 _ _ =
        stack_error "red_factor4";
=TEX

=SML
fun €red_primary1› (Token ((LCNumericLiteral,CNText n), _)) = (
    PPExp (EIntReal n))
|   red_primary1 _ =
        stack_error "red_primary1";

fun €red_primary2› (Token ((LCCharacterLiteral,CNString c), _)) = (
    PPExp (ECharacterLiteral c))
|   red_primary2 _ =
        stack_error "red_primary2";

fun €red_primary3› (Token ((LCStringLiteral,CNString s), _)) = (
    PPExp (EStringLiteral s))
|   red_primary3 _ =
        stack_error "red_primary3";

val €red_primary4› = red_accept;
val €red_primary5› = red_accept;
fun €red_primary6› (Parsed (PPExp (EArrayAggPos{tmark=Nil,comps = [e]}))) = (
    PPExp (EBracketed e))
|   red_primary6 (Parsed pagg) = pagg
|   red_primary6 _ = stack_error "red_primary6";

val €red_primary7› = red_accept;
=TEX

=SML
fun €red_relational_operator1› _ = PPBinaryOp BOSparkEq;
fun €red_relational_operator2› _ = PPBinaryOp BOSparkNotEq;
fun €red_relational_operator3› _ = PPBinaryOp BOSparkLess;
fun €red_relational_operator4› _ = PPBinaryOp BOSparkLessEq;
fun €red_relational_operator5› _ = PPBinaryOp BOSparkGreater;
fun €red_relational_operator6› _ = PPBinaryOp BOSparkGreaterEq;
fun €red_binary_adding_operator1› _ = PPBinaryOp BOSparkAdd;
fun €red_binary_adding_operator2› _ = PPBinaryOp BOSparkMinus;
fun €red_binary_adding_operator3› _ = PPBinaryOp BOSparkConcat;
=TEX

=SML
fun €red_unary_adding_operator1› x1 = PPUnaryOp UOSparkUnaryAdd;
fun €red_unary_adding_operator2› x1 = PPUnaryOp UOSparkUnaryMinus;
fun €red_multiplying_operator1› x1 = PPBinaryOp BOSparkTimes;
fun €red_multiplying_operator2› x1 = PPBinaryOp BOSparkDiv;
fun €red_multiplying_operator3› x1 = PPBinaryOp BOSparkMod;
fun €red_multiplying_operator4› x1 = PPBinaryOp BOSparkRem;
=TEX

=SML
fun €red_qualified_expression› (Parsed(PPExp n)) _ (Parsed(PPExp e)) = (
    PPExp(EQualifiedExp{tmark=mk_type_mark n, exp=e}))
|   red_qualified_expression _ _ _ =
        stack_error "red_qualified_expression";
=TEX

=SML
val €red_sequence_of_statements1› = red_accept;

fun €red_sequence_of_statements2› (Parsed (PPStatement st1)) (Parsed(PPStatement st2)) = (
    PPStatement(STSemicolon(st1, st2))
) | red_sequence_of_statements2 _ _ =
        stack_error "red_sequence_of_statements2";

fun €red_statement1› (Parsed(PPKSlot k)) = (
    PPStatement(STKSlot k))
|   red_statement1 _ =
        stack_error "red_statement1";

fun €red_statement2› (Parsed(PPStatement(STSpecNoIvars{spec=spec, ...}))) = (
    PPStatement(STSpecNoIvars{spec=spec, label=push_label()}))
|   red_statement2 _ = stack_error "red_statement2";

fun €red_statement3› (Parsed(PPStatement(STSpecNoIvars{spec=spec, ...})))
			(Parsed(PPId label)) = (
    last_label := label;
    PPStatement(STSpecNoIvars{spec=spec, label=label}))
|   red_statement3 _ _ = stack_error "red_statement3";

fun €red_statement4› _ (Token ((LCZ,CNZ z1), _)) _
    (Parsed(PPStatement(STSpecNoIvars {spec=s, ...}))) = (
let	val ns_ts = process_con_z_decl z1;
	fun mk_log_con_def (n, t) = {x = n, t = t, e = mk_z_true};
in
	PPStatement(SLogCon{defs = map mk_log_con_def ns_ts, spec=s,
		pre1 = mk_z_true, label=push_label()})
end)
|   red_statement4 _ _ _ _ =
        stack_error "red_statement4";

fun €red_statement5› _ (Token ((LCZ,CNZ z1), _)) _
		(Parsed(PPStatement(STSpecNoIvars {spec=s, ...})))
		(Parsed(PPId label)) = (
let	val ns_ts = process_con_z_decl z1;
	fun mk_log_con_def (n, t) = {x = n, t = t, e = mk_z_true};
in
	(last_label := label;
	PPStatement(SLogCon{defs = map mk_log_con_def ns_ts, spec=s,
		pre1 = mk_z_true, label=label}))
end)
|   red_statement5 _ _ _ _ _ =
        stack_error "red_statement5";

val €red_statement6› = red_accept;
val €red_statement7› = red_accept;
fun €red_statement8› (Parsed (PPPragma e)) = 
	PPStatement(STPragma e)
|   red_statement8 _ = stack_error "red_statement8";

fun €red_statement9› (Token ((LCAnnotation,CNText ann), _)) = 
	PPStatement(STAnnotation [ANString ann])
|   red_statement9 _ = stack_error "red_statement9";

=TEX

=SML
fun €red_specification_statement1› _ (Token ((LCZ,CNZ z1), _)) _
    (Token ((LCZ,CNZ z2), _)) _ = (
    let val (pre, post) =
            case process_pre_and_post_conditions z2 
            of (Value pre', post') => (pre', post')
            |  (Nil, post') => (z_tm_true, post');
        val w=process_frame z1;
in
    PPStatement(STSpecNoIvars{spec={w=w, w0=[], pre=pre, post=post},
			label=""})
end)
|   red_specification_statement1 _ _ _ _ _ =
        stack_error "red_specification_statement1";

fun €red_specification_statement2› _ (Token ((LCZ,CNZ z1), _)) _
    (Token ((LCZ,CNZ z2), _)) _ = (
let val (pre, post) = 
    (process_predicate z2, z_tm_true);
    val w=process_frame z1;
in
    PPStatement(STSpecNoIvars{spec={w=w, w0=[], pre=pre,post=post},
			label=""})
end)
|   red_specification_statement2 _ _ _ _ _ =
        stack_error "red_specification_statement2";
=TEX
=SML
fun €red_specification_statement3› _ _ (Token ((LCZ,CNZ z1), _)) _ = (
    let val (pre, post) =
            case process_pre_and_post_conditions z1
            of (Value pre', post') => (pre', post')
            |  (Nil, post') => (z_tm_true, post');
in
    PPStatement(STSpecNoIvars{spec={w=[], w0=[], pre=pre, post=post},
			label=""})
end)
|   red_specification_statement3 _ _ _ _ =
        stack_error "red_specification_statement3";

fun €red_specification_statement4› _ _ (Token ((LCZ,CNZ z1), _)) _ = (
let val (pre, post) = 
    (process_predicate z1, z_tm_true);
in
    PPStatement(STSpecNoIvars{spec={w=[], w0=[], pre=pre,post=post},
			label=""})
end)
|   red_specification_statement4 _ _ _ _ =
        stack_error "red_specification_statement4";
=TEX
=SML
fun €red_label1› _ (Token ((LCNumericLiteral,CNText n), _)) _ = (
    if is_all_decimal n
    then
        PPId n
    else
        parse_error 503001 "numeric label may only contain digits")
|   red_label1 _ _ _ = stack_error "red_label1";

fun €red_label2› _ (Parsed (PPExp n)) _ = (
       PPId (mk_type_mark n))
|   red_label2 _ _ _ = stack_error "red_label2";

fun €red_k_slot1› _ (Token ((LCKSlot,CNKSlot lx), _)) _ = (
    PPKSlot{content=format_input_items lx, label=push_label()})
|   red_k_slot1 _ _ _ =
        stack_error "red_k_slot1";

fun €red_k_slot2› _ (Token ((LCKSlot,CNKSlot lx), _)) _ (Parsed(PPId lab)) = (
    last_label := lab;
    PPKSlot{content=format_input_items lx, label= lab})
|   red_k_slot2 _ _ _ _ =
        stack_error "red_k_slot2";
=TEX

=SML
val €red_simple_statement1› = red_accept;
val €red_simple_statement2› = red_accept;
val €red_simple_statement3› = red_accept;
val €red_simple_statement4› = red_accept;
val €red_simple_statement5› = red_accept;
val €red_compound_statement1› = red_accept;
val €red_compound_statement2› = red_accept;
val €red_compound_statement3› = red_accept;
=TEX

=SML
fun €red_null_statement› _ _ = PPStatement STNull;

fun €red_assignment_statement› (Parsed(PPExp n)) _ (Parsed(PPExp e)) _ = (
    PPStatement(STAssign{name=n, e=e}))
|   red_assignment_statement _ _ _ _ =
        stack_error "red_assignment_statement";
=TEX

=SML
fun €red_if_statement› _ (Parsed(PPExp exp)) _ (Parsed(PPStatement st)) 
    (Parsed(PPElsIf ei)) (Parsed(PPStatement el)) _ _ _ = (
let val css = (exp, st)::ei;
    fun aux ((c,s)::(rest as (_::_))) = (
        (STIfThenElse{g=c,p=s,q=aux rest,elsif=true})
    ) |  aux [(c,s)] = (
        (STIfThenElse{g=c,p=s,q=el,elsif=false})
    ) |  aux _ = STImplicitNull;
in
    PPStatement (aux css)
end)
|   red_if_statement _ _ _ _ _ _ _ _ _ =
        stack_error "red_if_statement";
=TEX

=SML
val €red_elsif_part1› = PPElsIf [];
fun €red_elsif_part2› _ (Parsed (PPExp exp)) _ (Parsed(PPStatement st))
    (Parsed(PPElsIf ei)) = (
    PPElsIf ((exp, st)::ei))
|   red_elsif_part2 _ _ _ _ _ =
        stack_error "red_elsif_part2";
=TEX

=SML
val €red_else_part1› = PPStatement STImplicitNull;

fun €red_else_part2› _ (Parsed p) = p
|   red_else_part2 _ _ =
        stack_error "red_else_part2";

val €red_condition› = red_accept;
=TEX

=SML
fun €red_case_statement› _ (Parsed(PPExp e)) _ (Parsed(PPCaseAlternatives cs))
    (Parsed(PPStatement others)) _ _ _ = (
    PPStatement(STCase{e=e, s=cs, others=others}))
|   red_case_statement _ _ _ _ _ _ _ _ =
        stack_error "red_case_statement";

val €red_case_statement_alternative_list1› = red_accept;

fun €red_case_statement_alternative_list2› (Parsed(PPCaseAlternatives cs))
    (Parsed(PPCaseAlternatives [c])) = (
    PPCaseAlternatives (cs@[c]))
|   red_case_statement_alternative_list2 _ _ =
    stack_error "red_case_statement_alternative_list2";

fun €red_case_statement_alternative› _ (Parsed(PPCaseChoices c)) _
    (Parsed(PPStatement st)) = (
    PPCaseAlternatives[{choices=c, p=st}])
|   red_case_statement_alternative _ _ _ _ =
    stack_error "red_case_statement_alternative";
=TEX

=SML
val €red_case_choice_list1› = red_accept;

fun €red_case_choice_list2› (Parsed(PPCaseChoices [ac])) _
    (Parsed(PPCaseChoices acl)) = (
    PPCaseChoices(ac::acl))
|   red_case_choice_list2 _ _ _ =
        stack_error "red_acase_choice_list2";
=TEX
=SML
fun €red_case_choice› (Parsed(PPExp e)) = (
    case e of 
     EDiscreteRange (DRConstrained{tmark, range}) => (
        PPCaseChoices[CCCaseRange(DRConstrained
                {tmark=tmark,range=range})]
    ) |EDiscreteRange (DRRange range) => (
        PPCaseChoices[CCCaseRange(DRRange range)]
    ) |_ => (
        if is_range_attribute e
        then
            PPCaseChoices[CCCaseRange(DRRange(exp_to_range e))]
        else
            PPCaseChoices[CCCaseExp(mk_exp_of_exp e)]
    ))
|   red_case_choice _ =
        stack_error "red_case_choice";

val €red_others_part1› = PPStatement STImplicitNull;

fun €red_others_part2› _ _ _ (Parsed p) = p
|   red_others_part2 _ _ _ _ =
        stack_error "red_others_part2";

=TEX

SPARK manual 5.5:
=SML
fun €red_loop_statement› (Parsed(PPIds ids)) (Parsed p) (Parsed(PPExps es))
    (Parsed(PPStatement st)) (Parsed(PPIds ids')) _ = (
let val side = case (ids', ids) 
    of ([id'], [id]) => (
            if different_ids (id', id)
            then    parse_error 503001 "LOOP names do not match"
            else    ()
        )|  _ => (
            ()
        );
    val name = case ids 
    of [id] => Value id
            |_ => Nil;
    val till = case es 
    of [EAuxiliaryExp tm] => Value tm
            |_ => Nil;
in
    case p 
    of PPExp c => (
            PPStatement(STWhile{name=name, g=c, loop={t=till, stmt=st}})
    ) |PPFor(id, tm, dir, opr) => (
        case opr 
    of Value range => (
            PPStatement(STForStatic{name=name, tmark=tm, i=id,
            range=range, dir=dir,loop={t=till, stmt=st}})
        ) |Nil => (
            PPStatement(STForTmark{name=name,i=id, tmark=force_value tm, dir=dir,
            loop={t=till, stmt=st}})
        )
    ) |  PPId "__no_scheme" => (
        case name 
    of Value n => (
            PPStatement(STNamedLoop{name=n,t=till, stmt=st})
        ) |Nil => (
            PPStatement(STLoop{t=till, stmt=st})
        )
    ) |  _ => stack_error"red_loop_statement_a"
end)
|   red_loop_statement _ _ _ _ _ _ =
        stack_error "red_loop_statement";
=TEX
=SML
fun €red_loop_body› _ (Parsed(pst as PPStatement _)) _ _ = pst
|   red_loop_body _ _ _ _  = stack_error "red_loop_body";
=TEX
=SML
val €red_name_colon_opt1› = PPIds[];

fun €red_name_colon_opt2› (Token ((_,CNText id), _)) _ = (
    PPIds [id])
|   red_name_colon_opt2 _ _ =
        stack_error "red_name_colon_opt2";

val €red_name_opt1› = PPIds [];

fun €red_name_opt2› (Token ((_,CNText id), _)) = (
    PPIds [id])
|   red_name_opt2 _ =
        stack_error "red_name_opt2";

val €red_iteration_scheme_opt1› = PPId "__no_scheme";

val €red_iteration_scheme_opt2› = red_accept;

fun €red_iteration_scheme1› _ (Parsed p) = (p)
|   red_iteration_scheme1 _ _ =
        stack_error "red_iteration_scheme1";
=SML
fun €red_iteration_scheme2› _ (Parsed p) = (p)
|   red_iteration_scheme2 _ _ =
        stack_error "red_iteration_scheme2";
=TEX
=SML

fun €red_loop_parameter_specification1› (Token ((_,CNText id), _)) _
    (Parsed(PPExp e)) =
	let	val (opt_tm, opt_range) = exp_to_loop_params e;
	in	PPFor(id, opt_tm, LDForwards, opt_range)
	end
|   red_loop_parameter_specification1 _ _ _ =
    stack_error "red_loop_parameter_specification1";

fun €red_loop_parameter_specification2› (Token ((_,CNText id), _)) _ _
    (Parsed(PPExp e)) = 
	let	val (opt_tm, opt_range) = exp_to_loop_params e;
	in	PPFor(id, opt_tm, LDReverse, opt_range)
	end
|   red_loop_parameter_specification2 _ _ _ _ = 
     stack_error "red_loop_parameter_specification2";

val €red_till_opt1› = PPExps [];
fun €red_till_opt2› _ (Parsed(PPExp(EAuxiliaryExp z))) = (
    PPExps[EAuxiliaryExp z])
|   red_till_opt2 _ _ =
        stack_error "red_till_opt2";
=TEX

=SML
fun €red_auxiliary_expression› _ (Token ((LCZ,CNZ z), _)) _ = (
    PPExp(EAuxiliaryExp (z_tm_of_z_tokens z )))
|   red_auxiliary_expression _ _ _ =
        stack_error "red_auxiliary_expression";

fun €red_exit_statement1› _ (Parsed(PPIds [])) _ = (
    PPStatement (STExit { n = Nil })
) | red_exit_statement1 _ (Parsed(PPIds [id])) _ = (
    PPStatement (STExit { n = Value id })
) | red_exit_statement1 _ _ _ = 
    stack_error "red_exit_statement1";

fun €red_exit_statement2› _ (Parsed(PPIds [])) _ (Parsed(PPExp exp)) _ = (
    PPStatement(STExitWhen{ g = exp, n = Nil })
) | red_exit_statement2 _ (Parsed(PPIds [id])) _ (Parsed(PPExp exp)) _ = (
    PPStatement(STExitWhen{ g = exp, n = Nil })
) | red_exit_statement2 _ _ _ _ _ =
        stack_error "red_exit_statement2";
=TEX
=SML
fun €red_return_statement1› _ _ = (
    PPStatement (STRet{ e = Nil })
);

fun €red_return_statement2› _ (Parsed(PPExp exp)) _ = (
    PPStatement (STRet{ e = Value exp }))
|   red_return_statement2 _ _ _ =
        stack_error "red_return_statement2";
=TEX

=SML
fun €red_subprogram_declaration1› (Parsed(PPProcedureSpecification p)) _ = (
    PPDeclarations[DProcedureDeclaration p])
|   red_subprogram_declaration1 _ _ =
        stack_error "red_subprogram_declaration1";

fun €red_subprogram_declaration2› (Parsed(PPFunctionSpecification f)) _ = (
    PPDeclarations[DFunctionDeclaration f])
|   red_subprogram_declaration2 _ _ =
        stack_error "red_subprogram_declaration2";

fun €red_subprogram_specification1› (Parsed(PPProcedureSpecification p)) = (
    PPSubprogramSpec(SSProcedure p))
|   red_subprogram_specification1 _ =
        stack_error "red_subprogram_specification1";

fun €red_subprogram_specification2› (Parsed(PPFunctionSpecification p)) = (
    PPSubprogramSpec(SSFunction p))
|   red_subprogram_specification2 _ =
        stack_error "red_subprogram_specification2";
=TEX

=SML
fun €red_procedure_specification_1_1› _ (Token ((_,CNText id), _)) = (
    PPProcedureSpecification{name=id, formal_part=[], spec=Nil, annotation = [], globals=[]})
|   red_procedure_specification_1_1 _ _ =
        stack_error "red_procedure_specification_1_1";

fun €red_procedure_specification_1_2› _ (Token ((_,CNText id), _))
    (Parsed(PPProcedureSpecificationStatement(deps, STSpecNoIvars {spec=s, ...}))) = (
    PPProcedureSpecification{name=id,formal_part=[],spec=Value s, annotation = [], globals = deps})
|   red_procedure_specification_1_2 _ _ _ =
        stack_error "red_procedure_specification_1_2";

fun €red_procedure_specification_1_3› _ (Token ((_,CNText id), _))
    (Parsed (PPFormals f)) = (
    PPProcedureSpecification{name=id,formal_part=f,spec=Nil, annotation = [], globals = []})
|   red_procedure_specification_1_3 _ _ _ =
        stack_error "red_procedure_specification_1_3";

fun €red_procedure_specification_1_4› _ (Token ((_,CNText id), _))
    (Parsed (PPFormals f))
	(Parsed(PPProcedureSpecificationStatement(deps, STSpecNoIvars {spec=s, ...}))) = (
    PPProcedureSpecification{name=id,formal_part=f,spec=Value s, annotation = [], globals = deps})
|   red_procedure_specification_1_4 _ _ _ _=
        stack_error "red_procedure_specification_1_4";

fun €red_procedure_specification
    (Parsed(PPProcedureSpecification{name=id,formal_part=f,spec=s, globals=g, annotation=_}))
    (Parsed (PPAnnotation ann)) = (
	PPProcedureSpecification{name=id, formal_part=f, spec=s, annotation=ann, globals=g}
) |   red_procedure_specification _ _ =
        stack_error "red_procedure_specification";
=TEX
=SML
fun €red_procedure_specification_statement1› _ (Token ((LCZ,CNZ z1), _)) 
	(Parsed(PPStatement(STSpecNoIvars{spec={w=deps, w0=_, pre=pre, post=post},
			label=""}))) = (
    let         val w=process_frame z1;
in
    PPProcedureSpecificationStatement
	(deps, STSpecNoIvars{spec={w=w, w0=[], pre=pre, post=post}, label=""})
end)
|   red_procedure_specification_statement1 _ _ _ =
        stack_error "red_procedure_specification_statement1";
=TEX
=SML
fun €red_procedure_specification_statement2› _ 
	(Parsed(PPStatement(STSpecNoIvars{spec={w=deps, w0=_, pre=pre, post=post},
			label=""}))) = (
    PPProcedureSpecificationStatement
	(deps, STSpecNoIvars{spec={w=[], w0=[], pre=pre, post=post}, label=""})
) |   red_procedure_specification_statement2 _ _ =
        stack_error "red_procedure_specification_statement2";
=TEX
=SML
fun €red_procedure_specification_statement3› 
	(Parsed(PPStatement spc)) = (
    PPProcedureSpecificationStatement
	([], spc)
) |   red_procedure_specification_statement3 _ =
        stack_error "red_procedure_specification_statement3";
=TEX
=SML
val €red_function_specification_statement1› = red_specification_statement1;
val €red_function_specification_statement2› = red_specification_statement2;
val €red_function_specification_statement3› = red_specification_statement3;
val €red_function_specification_statement4› = red_specification_statement4;
=TEX
=SML
fun €red_function_specification_1_1› _ (Token((_,CNText des), _)) _
    (Parsed(PPExp n)) = (
    PPFunctionSpecification{designator=des,
        return=mk_type_mark n,
	formal_part=[],spec=Nil,globals=[],annotation=[]})
|   red_function_specification_1_1 _ _ _ _ =
        stack_error "red_function_specification_1_1";

fun €red_function_specification_1_2› _ (Token((_,CNText des), _)) _
    (Parsed(PPExp n))
	(Parsed(PPStatement(STSpecNoIvars {spec={w, w0, pre, post}, ...}))) = (
    PPFunctionSpecification{designator=des,
	return=mk_type_mark n,
	formal_part=[],spec=Value {w=[], w0=[], pre=pre, post=post},
	globals=w,annotation=[]})
|   red_function_specification_1_2 _ _ _ _ _ =
        stack_error "red_function_specification_1_2";

fun €red_function_specification_1_3› _ (Token((_,CNText des), _))
    (Parsed(PPFormals f)) _ (Parsed(PPExp n)) = (
    PPFunctionSpecification{designator=des,
	return=mk_type_mark n,
	formal_part=f,spec=Nil,globals=[],annotation=[]})
|   red_function_specification_1_3 _ _ _ _ _ =
        stack_error "red_function_specification_1_3";

fun €red_function_specification_1_4› _ (Token((_,CNText des), _))
    (Parsed(PPFormals f)) _ (Parsed(PPExp n))
    (Parsed(PPStatement(STSpecNoIvars {spec={w, w0, pre, post}, ...}))) = (
    PPFunctionSpecification{designator=des,
        return=mk_type_mark n,
	formal_part=f,spec=Value {w=[], w0=[], pre=pre, post=post},
	globals=w,annotation=[]})
|   red_function_specification_1_4 _ _ _ _ _ _ =
        stack_error "red_function_specification_1_4";

fun €red_function_specification
    (Parsed(PPFunctionSpecification{designator=des,return=tm,
			formal_part=f,spec=s,globals=g, ...}))
    (Parsed (PPAnnotation ann)) = (
	PPFunctionSpecification{designator=des,return=tm,
			formal_part=f,spec=s,globals=g,annotation = ann}
) |   red_function_specification _ _ =
        stack_error "red_function_specification";
=TEX
=SML
val €red_annotation_list1› = PPAnnotation [];

fun €red_annotation_list2› (Token ((LCAnnotation,CNText ann), _))
	(Parsed (PPAnnotation anns)) = (
	PPAnnotation (ANString ann :: anns)
)|  red_annotation_list2 _ _ = stack_error "red_annotation_list2";

fun €red_annotation_list3› (Parsed (PPKSlot ks))
	(Parsed (PPAnnotation anns)) = (
	PPAnnotation (ANKSlot ks :: anns)
)|  red_annotation_list3 _ _ = stack_error "red_annotation_list3";
=TEX
SPARK manual 6.1:
=SML
fun €red_operator_symbol› (Token((StringLiteral,CNString opsym), _)) = (
    PPId opsym)
|   red_operator_symbol _ =
        stack_error "red_operator_symbol";

fun €red_formal_part› _ (Parsed p) _ = (p)
|   red_formal_part _ _ _ =
        stack_error "red_formal_part";

val €red_parlist1› = red_accept;

fun €red_parlist2› (Parsed (PPFormals f1)) _ (Parsed(PPFormals f2)) = (
    PPFormals (f1@f2))
|   red_parlist2 _ _ _ =
        stack_error "red_parlist2";

fun €red_parameter_specification› (Parsed(PPIds ids)) _ (Parsed(PPMode m)) 
    (Parsed(PPExp n)) = (
    PPFormals[{idlist=ids,mode=m,name=mk_type_mark n}])
|   red_parameter_specification _ _ _ _ =
        stack_error "red_parameter_specification";
;
val €red_mode1› = PPMode (MSparkIn false);
fun €red_mode2› _ = PPMode (MSparkIn true);
fun €red_mode3› _ = PPMode MSparkOut;
fun €red_mode4› _ _ = PPMode MSparkInOut;
=TEX

SPARK manual 6.3:
=SML
fun €red_subprogram_body1› (Parsed (PPProcedureSpecification ps)) _
    (Parsed (PPSubprogram (d, s, id))) = (
let val {name=id',...} = ps;
    val side =if    different_ids (id', id)
            then    parse_error 503001 "PROCEDURE identifiers do not match"
            else    ();
in
    PPProperBody (PBProcedure {procedure_spec=ps,declarative_part=d,statement=s})
end)
|   red_subprogram_body1 _ _ _ =
        stack_error "red_subprogram_body1";

fun €red_subprogram_body2› (Parsed (PPFunctionSpecification fs)) _
    (Parsed (PPSubprogram (d, s, id))) = (
let val {designator=id',...} = fs;
    val side =if    different_ids (id', id)
            then    parse_error 503001 "FUNCTION designators do not match"
            else    ();
in
    PPProperBody (PBFunction {function_spec=fs,declarative_part=d,statement=s})
end)
|   red_subprogram_body2 _ _ _ =
        stack_error "red_subprogram_body2";

fun €red_subprogram_implementation› (Parsed(PPDeclarations d)) _ 
    (Parsed(PPStatement s)) _ (Token ((_,CNText id), _)) _ = (
    PPSubprogram (d, s, id))
|   red_subprogram_implementation _ _ _ _ _ _ =
        stack_error "red_subprogram_implementation";
=TEX

=SML
fun €red_procedure_call_statement› (Parsed (p as (PPExp e))) _ = (
    case e 
    of EIndexedComp{prefix=prefix,index=EArrayAggPos{comps = comps,...}} => (
        PPStatement (STProcNoIvars{name=mk_type_mark prefix,
            actuals=APositional comps})
    )|  EIndexedComp{prefix=prefix,index=EArrayAggNamed
		{tmark=_,named_assocs=na}} => (
        PPStatement (STProcNoIvars{name=mk_type_mark prefix,
            actuals=ANamed na})
    )|  EIndexedComp{index=EArrayAggNamedOthers _,...} => (
        parse_error 503001 "OTHERS is not allowed in a parameter association"
    )|  EIndexedComp{index=EArrayAggPosOthers _,...} => (
        parse_error 503001 "OTHERS is not allowed in a parameter association"
    )|  EIndexedComp{index=EArrayAggOthers _,...} => (
        parse_error 503001 "OTHERS is not allowed in a parameter association"
    )|_ => (
        PPStatement (STProcNoIvars{name=mk_type_mark e, actuals=APositional[]})
    ))
|   red_procedure_call_statement _ _ =
        stack_error "red_procedure_call_statement";

fun €red_actual_parameter_part› _ (Parsed p) _ = (
    p)
|   red_actual_parameter_part _ _ _ =
        stack_error "red_actual_parameter_part";

fun €red_parameter_association1
    (Parsed(PPAgg{tm=tm,named_assocs=na,others=ot})) = (
    case ot 
    of Value oe => PPExp (EArrayAggNamedOthers
            {agg_named={tmark=Nil,named_assocs=na},
            others={others=oe}})
    |  Nil => PPExp (EArrayAggNamed{tmark=Nil,named_assocs=na}))
|   red_parameter_association1 _ =
        stack_error "red_parameter_association1";

fun €red_parameter_association2› (Parsed(PPExps es)) = (
    PPExp(EArrayAggPos{tmark=Nil,comps = es}))
|   red_parameter_association2 _ =
        stack_error "red_parameter_association2";

fun €red_positional_parameter_association1› (Parsed(PPExp e)) = (
    PPExps [e])
|   red_positional_parameter_association1 _ =
        stack_error "red_positional_parameter_association1";

fun €red_positional_parameter_association2› (Parsed(PPExp e)) _
    (Parsed(PPExps es)) = (
    PPExps (e::es))
|   red_positional_parameter_association2  _ _ _ =
        stack_error "red_positional_parameter_association2";
=TEX

=SML
fun red_actual_parameter (Parsed(PPSubtypeIndication si)) = (
	PPExp (si_to_discrete_range si)
) | red_actual_parameter  _ =
        stack_error "red_actual_parameter";
=TEX

SPARK manual 7.1:
=SML
fun €red_package_declaration› (Parsed (PPPackageSpecification p)) _ = (
    PPDeclarations[DPackageDeclaration p])
|   red_package_declaration _ _ =
        stack_error "red_package_declaration";

fun €red_package_specification1› _ (Token ((_,CNText id), _))
	(Parsed (PPAnnotation ann)) _
    (Parsed(PPDeclarations v)) _ (Token ((_,CNText id'), _)) = (
let val side =if    different_ids (id', id)
            then    parse_error 503001 "PACKAGE names do not match"
            else    ();
in	PPPackageSpecification
	{name=id,visible_decs=v,private_decs=[],annotation=ann}
end)
|   red_package_specification1 _ _ _ _ _ _ _ =
        stack_error "red_package_specification1";

fun €red_package_specification2› _ (Token ((_,CNText id), _))
	(Parsed (PPAnnotation ann))  _
    (Parsed(PPDeclarations v)) _  (Parsed(PPDeclarations p)) _
    (Token ((_,CNText id'), _)) = (
let val side =if    different_ids (id', id)
            then    parse_error 503001 "PACKAGE names do not match"
            else    ();
in
    	PPPackageSpecification
	{name=id,visible_decs=v,private_decs=p,annotation=ann}
end)
|   red_package_specification2 _ _ _ _ _ _ _ _ _ =
        stack_error "red_package_specification2";

val €red_visible_part1› = PPDeclarations [];

fun €red_visible_part2› (Parsed (PPDeclarations d1))
    (Parsed (PPDeclarations d2)) = ( 
    PPDeclarations (d1@d2))
|   red_visible_part2 _ _ =
        stack_error "red_visible_part2";

=TEX

SPARK manual 7.1:
=SML
fun €red_visdec1› (Parsed (PPKSlot k)) = (
    PPDeclarations [DDeclarationKSlot (k, DKVisible)])
|   red_visdec1 _ =
        stack_error "red_visdec1";

val €red_visdec2› = red_accept;

val €red_visdec3› = red_accept;

fun €red_visdec4› _ (Token ((LCZ,CNZ z1), _)) _ = (
let	val (n, ty) = 
                        process_aux_z_decl z1
in
    PPDeclarations [DAuxiliary{aux=n, t=ty}]
end)
|   red_visdec4 _ _ _ = stack_error "red_visdec4";

val €red_visdec5› = red_accept;

val €red_private_part1› = red_accept;

fun €red_private_part2› (Parsed (PPDeclarations d1))
    (Parsed (PPDeclarations d2)) = (
    PPDeclarations (d1@d2))
|   red_private_part2 _ _ =
        stack_error "red_private_part2";

fun €red_pdec1› (Parsed (PPKSlot k)) = (
    PPDeclarations [DDeclarationKSlot (k, DKPrivate)])
|   red_pdec1 _ =
        stack_error "red_pdec1";

val €red_pdec2› = red_accept;

val €red_pdec3› = red_accept;
=TEX

=SML
fun €red_package_body› _ _ (Token ((_,CNText id), _)) 
	(Parsed (PPAnnotation ann)) _
    (Parsed(PPSubprogram (d,s, _))) _ (Token ((_,CNText id'), _)) _ = (
let val side =if    different_ids (id', id)
            then    parse_error 503001 "PACKAGE names do not match"
            else    ();
in
   	PPProperBody
	(PBPackage{name=id,decls=d,statement=s,annotation=ann})
end)
|   red_package_body _ _ _ _ _ _ _ _ _ =
        stack_error "red_package_body";

fun €red_package_implementation1› (Parsed (PPDeclarations d)) = (
    PPSubprogram (d, STImplicitNull, ""))
|   red_package_implementation1 _ =
        stack_error "red_package_implementation1";

fun €red_package_implementation2› (Parsed (PPDeclarations d)) _
    (Parsed(PPStatement s)) = (
    PPSubprogram (d, s, ""))
|   red_package_implementation2 _ _ _ =
        stack_error "red_package_implementation2";

fun €red_package_implementation3› (Parsed (PPDeclarations using))
		(Parsed (PPDeclarations d)) _ (Parsed(PPStatement s)) = (
    PPSubprogram (using@d, s, ""))
|   red_package_implementation3 _ _ _ _ =
        stack_error "red_package_implementation3";

val €red_package_initialization› = red_accept;
=TEX
=SML
fun €check_basic_dec_list› ((bd::more) : SI_BASIC_DECL list) : bool = (
	case bd of
		SIDeferredConstDecl _ => false
	|	SIPrivateTypeDecl _ => false
	|	_ => check_basic_dec_list more
) | check_basic_dec_list _ = true;
=TEX
=SML
fun €red_using_list1› (Parsed(PPDeclarations ds)) = (
	PPDeclarations ds)
|   red_using_list1 _ = stack_error "red_using_list1";

fun €red_using_list2› (Parsed(PPDeclarations d1)) (Parsed(PPDeclarations d2)) = (
    PPDeclarations (d1@d2))
|   red_using_list2 _ _ = stack_error "red_using_list2";

fun €red_using_dec› _ (Parsed(PPBasicDecls bds)) _
	(Token ((LCZ,CNZ z1), _)) _ (Token ((LCZ,CNZ zpred), _)) _ = (
    if check_basic_dec_list bds
    then
		PPDeclarations[DUsing{aux=z_tm_of_z_tokens z1,
				basic_decls=bds,
				invariant=process_predicate zpred}]
    else
	parse_error 503001
	"private types and deferred constants are not allowed in a USING declaration")
|   red_using_dec _ _ _ _ _ _ _ =
        stack_error "red_using_dec";

=TEX
=SML

fun €red_basic_dec_list1› (Parsed(PPBasicDecls bds)) = (
	PPBasicDecls bds)
|   red_basic_dec_list1 _ =
        stack_error "red_basic_dec_list1";

fun €red_basic_dec_list2› (Parsed(PPBasicDecls bds1))
		(Parsed(PPBasicDecls bds2)) = (
    PPBasicDecls(bds1@bds2))
|   red_basic_dec_list2 _ _ =
        stack_error "red_basic_dec_list2";

=TEX
=SML
fun is_k_slot (DDeclarationKSlot _ : DECLARATION) : bool = true
|   is_k_slot _ = false;

fun €red_declarative_part_1_1› (Parsed (PPDeclarations d1)) = (
	if	any d1 is_k_slot
	then	parse_error 503001
       "a k-slot is not allowed after the using declarations"
	else	PPDeclarations d1
) | red_declarative_part_1_1 _ =
        stack_error "red_declarative_part_1_1";

fun €red_declarative_part_1_2› (Parsed (PPDeclarations d1)) (Parsed (PPDeclarations d2)) = (
    PPDeclarations (d1@d2))
|   red_declarative_part_1_2 _ _ =
        stack_error "red_declarative_part_1_2";
=TEX
SPARK manual 7.4:
=SML
fun €red_private_type_declaration1› _ (Token ((_,CNText id), _)) _ _ _ = (
    PPBasicDecls[SIPrivateTypeDecl{id=id, disc=[], limited=false}])
|   red_private_type_declaration1 _ _ _ _ _ =
        stack_error "red_private_type_declaration1";

fun €red_private_type_declaration2› _ (Token ((_,CNText id), _))
	(Parsed (PPFormals fps)) _ _ _ = (
    PPBasicDecls[SIPrivateTypeDecl{
		id=id,
		disc=map par_spec_to_disc_spec fps,
		limited=false}])
|   red_private_type_declaration2 _ _ _ _ _ _ =
        stack_error "red_private_type_declaration2";

fun €red_private_type_declaration3› _ (Token ((_,CNText id), _)) _ _ _ _ = (
    PPBasicDecls[SIPrivateTypeDecl{id=id, disc=[], limited=true}])
|   red_private_type_declaration3 _ _ _ _ _ _ =
        stack_error "red_private_type_declaration3";

fun €red_private_type_declaration4› _ (Token ((_,CNText id), _))
	(Parsed (PPFormals fps)) _ _ _ _ = (
    PPBasicDecls[SIPrivateTypeDecl{
		id=id,
		disc=map par_spec_to_disc_spec fps,
		limited=true}])
|   red_private_type_declaration4 _ _ _ _ _ _ _ =
        stack_error "red_private_type_declaration4";
=TEX

=SML
fun €red_deferred_constant_declaration› (Parsed(PPIds ids)) _ _
    (Parsed(PPSubtypeIndication n)) _ = (
    PPBasicDecls[SIDeferredConstDecl{consts=ids,tmark=si_to_tmark n}])
|   red_deferred_constant_declaration p _ _ q _ =
        stack_error "red_deferred_constant_declaration";
=TEX
=SML
fun €red_renaming_declaration1›
	(Parsed (PPIds [id])) _ (Parsed (PPExp tm))
	_ (Parsed (PPExp n)) _ = (
	PPDeclarations[DRenamingDeclaration(RDObject
	{new_name = id, tmark = mk_type_mark tm, old_name = mk_type_mark n})]
) | red_renaming_declaration1 (Parsed (PPIds _)) _ _ _ _ _ = (
        parse_error 503001
       "A renaming declaration may declare only one new identifier"
) | red_renaming_declaration1 _ _ _ _ _ _ =
	stack_error "red_renaming_declaration1";
	
fun €red_renaming_declaration2›
	_ (Token ((_,CNText id), _)) _ 
	_ (Parsed (PPExp n)) _ = (
	PPDeclarations[DRenamingDeclaration(RDPackage
	{new_name = id, old_name = mk_type_mark n})]
) | red_renaming_declaration2 _ _ _ _ _ _ =
	stack_error "red_renaming_declaration2";
	

fun €red_renaming_declaration3› _ (Parsed (PPId opsym1))
    (Parsed(PPFormals f)) _ (Parsed(PPExp n1)) _
    (Parsed(PPExp n2)) _ (Parsed (PPId opsym2)) _ = (
    if opsym1 = opsym2
    then
        PPDeclarations[DRenamingDeclaration(RDOpsym
        {new_name=Nil,formal_part=f,tmark=mk_type_mark n1,
           name1=mk_type_mark n2, name2=opsym2})]
    else
        parse_error 503001
       "The two operator symbols in a renaming declaration must be the same")
|   red_renaming_declaration3 _ _ _ _ _ _ _ _ _ _ =
        stack_error "red_renaming_declaration3";

fun €red_renaming_declaration4› (Parsed (PPSubprogramSpec ss)) _
    (Parsed(PPExp n)) _ = (
   let val (id1, id2) = case n of 
		ESelectedComp {prefix, selector} => (Value (mk_type_mark prefix), selector)
	|	_ => (Nil, mk_type_mark n);
	val res = PPDeclarations[DRenamingDeclaration(RDSubprogram
          		{subprogram_specification=ss,name1=id1,name2=id2})];
   in  case ss of
          SSProcedure {spec = Nil, ...} => res
       |  SSFunction {spec = Nil, ...} => res
       |  _ => parse_error 503001
         "A specification statement is not allowed in a renaming declaration"
   end)
|   red_renaming_declaration4 _ _ _ _  =
        stack_error "red_renaming_declaration4";


fun €red_renaming_declaration5› (Parsed (PPSubprogramSpec (SSFunction
	{designator=id,formal_part=f, return=tm, spec=Nil, ...})))
    _ (Parsed(PPExp n2)) _ (Parsed (PPId opsym2)) _ = (
        PPDeclarations[DRenamingDeclaration(RDOpsym
        {new_name=Value id,formal_part=f,tmark=tm,
           name1=mk_type_mark n2, name2=opsym2})])
|   red_renaming_declaration5 (Parsed (PPSubprogramSpec (SSFunction _))) _ _ _ _ _ =
	parse_error 503001
         "A specification statement is not allowed in a renaming declaration"
|   red_renaming_declaration5 (Parsed (PPSubprogramSpec (SSProcedure _))) _ _ _ _ _ =
	parse_error 503001
         "A return type is required in an operator symbol renaming declaration"
|   red_renaming_declaration5 _ _ _ _ _ _ =
        stack_error "red_renaming_declaration5";

=TEX

=SML
fun €red_compilation1› (Parsed (PPKSlot k)) = (
    PPKSlotCUList [KCUKSlot k])
|   red_compilation1 _ =
        stack_error "red_compilation1";

fun €red_compilation2› (Parsed (PPContextCompilationUnit ccu)) =
    PPKSlotCUList [KCUUnit ccu]
|   red_compilation2 (Parsed (PPPragma p)) =
    PPKSlotCUList [KCUPragma p]
|   red_compilation2 _ =
        stack_error "red_compilation2";

fun €red_compilation3› (Parsed (PPContextCompilationUnit ccu))
    (Parsed (PPKSlotCUList cl)) = (
    PPKSlotCUList ((KCUUnit ccu)::cl))
|   red_compilation3 (Parsed (PPPragma p))
    (Parsed (PPKSlotCUList cl)) = (
    PPKSlotCUList ((KCUPragma p)::cl))
|   red_compilation3 _ _ =
        stack_error "red_compilation3";

=TEX

=SML
fun €red_compilation_unit1
    (Parsed (PPContextClause (ids_ps, rids, ann)))
    (Parsed (PPCompilationUnit cu)) = (
    PPContextCompilationUnit
	{context=ids_ps, references=rids, comp_unit=cu, annotation=ann}
) | red_compilation_unit1 _ _ =
        stack_error "red_compilation_unit1";

val €red_compilation_unit2› = red_compilation_unit1;
val €red_compilation_unit3› = red_accept;
=TEX

=SML
fun €red_library_unit1› (Parsed(PPDeclarations [DPackageDeclaration p])) = (
    PPCompilationUnit (CUPackageDeclaration p))
|   red_library_unit1 _ =
        stack_error "red_library_unit1";

fun €red_library_unit2› (Parsed(PPProperBody p)) = (
    PPCompilationUnit (CUProperBody p))
|   red_library_unit2 _ =
        stack_error "red_library_unit2";

=TEX

SPARK manual 10.1:
=SML
val €red_secondary_unit1› = red_accept;
val €red_secondary_unit2› = red_accept;

fun €red_library_unit_body› (Parsed(PPProperBody p)) = (
    PPCompilationUnit(CUProperBody p))
|   red_library_unit_body _ =
        stack_error "red_library_unit_body";

val €red_main_program› = red_accept;
=TEX

SPARK manual 10.1.1:
=SML
val €red_context_clause1› = PPContextClause ([], [], []);

fun €red_context_clause2› (Parsed(PPIds ids))
		(Parsed(PPPragmaList ps))
		(Parsed (PPContextClause (idps, refls, ann))) =
		PPContextClause ((ids, ps) :: idps, refls, ann)
|   red_context_clause2 _ _ _ = stack_error "red_context_clause2";

fun €red_context_clause3› (Parsed(PPIds refs))
		(Parsed (PPContextClause (idps, refs1, ann))) =
		PPContextClause (idps, refs @ refs1, ann)
|   red_context_clause3 _ _ = stack_error "red_context_clause3";

fun €red_context_clause4› (Token ((LCAnnotation,CNText ann), _))
	(Parsed (PPAnnotation anns)) =
		PPContextClause ([], [], ANString ann::anns)
|   red_context_clause4 _ _ = stack_error "red_context_clause3";

fun €red_context_clause5› (Parsed (PPAnnotation ann)) = PPContextClause ([], [], ann)
|   red_context_clause5 _ = stack_error "red_context_clause5";;
=TEX
=SML
val €red_pragma_list1› = PPPragmaList [];

fun €red_pragma_list2› (Parsed (PPPragma p)) (Parsed(PPPragmaList ps)) = 
	PPPragmaList (p :: ps)
|   red_pragma_list2 _ _ = stack_error "red_pragma_list2";

fun €red_pragma1› _ (Token ((_,CNText id), _)) _ = (
	PPPragma {id = id, args = []}
) | red_pragma1 _ _ _ = stack_error "red_pragma1";

fun €red_pragma2› _ (Token ((_,CNText id), _)) _ (Parsed(PPPragmaArgs args)) _ _ = (
	PPPragma {id = id, args = args}
) | red_pragma2 _ _ _ _ _ _ = stack_error "red_pragma2";

val €red_arg_ass_list1› = red_accept;

fun €red_arg_ass_list2› (Parsed(PPPragmaArgs [arg])) _ (Parsed(PPPragmaArgs args)) = (
	PPPragmaArgs (arg::args)
) | red_arg_ass_list2 _ _ _ = stack_error "red_arg_ass_list2";

fun €red_argument_association1› (Parsed(PPAggregateChoices (acl, true)))
      _ _ = (
    parse_error 503001 "OTHERS cannot be used in a pragma argument list"
) | red_argument_association1 (Parsed(PPAggregateChoices (_::_::_, _)))
      _ _ = (
    parse_error 503001 "`|' cannot be used in a pragma argument list"
) | red_argument_association1 (Parsed(PPAggregateChoices ([ac], _)))
      _ (Parsed (PPExp e)) = (
    PPPragmaArgs [(Value ac, e)]
) | red_argument_association1 _ _ _ = stack_error "red_argument_association1";

fun €red_argument_association2› (Parsed(PPExp e)) = (
    PPPragmaArgs [(Nil, e)]
) | red_argument_association2 _ = stack_error "red_argument_association2";

=TEX
=SML
fun €red_with_clause› _ (Parsed (PPIds ids)) _ = (PPIds ids)
|   red_with_clause _ _ _ = stack_error "red_with_clause";
=TEX
=SML
fun €red_references_clause› _ (Parsed (PPIds ids)) _ = (PPIds ids)
|   red_references_clause _ _ _ = stack_error "red_references_clause";
=TEX

SPARK manual 10.2:
=SML
fun €red_body_stub1› (Parsed (PPProcedureSpecification ps)) _ _ _ = (
    PPDeclarations [DProcedureStub ps])
|   red_body_stub1 _ _ _ _ = stack_error "red_body_stub1";

fun €red_body_stub2› (Parsed (PPFunctionSpecification fs)) _ _ _ = (
    PPDeclarations [DFunctionStub fs])
|   red_body_stub2 _ _ _ _ =
        stack_error "red_body_stub2";

fun €red_body_stub3› _ _ (Token ((_,CNText id), _))
	(Parsed (PPAnnotation ann)) _ _ _ = (
	case ann of
	[] =>	PPDeclarations [DPackageStub id]
	| _ => parse_error 503001"annotations are not allowed in a package stub"
) | red_body_stub3 _ _ _ _ _ _ _ =
        stack_error "red_body_stub3";

fun €red_body_stub4› (Parsed (PPProcedureSpecification ps)) _ = (
    PPDeclarations [DExternalProcedureStub ps])
|   red_body_stub4 _ _ = stack_error "red_body_stub4";

fun €red_body_stub5› (Parsed (PPFunctionSpecification fs)) _ = (
    PPDeclarations [DExternalFunctionStub fs])
|   red_body_stub5 _ _ = stack_error "red_body_stub5";

fun €red_subunit› _ _ (Parsed(PPExp n)) _ (Parsed (PPProperBody p)) = (
    PPCompilationUnit(CUSubUnit{name=mk_type_mark n, proper_body=p}))
|   red_subunit _ _ _ _ _ =
        stack_error "red_subunit";
=TEX

=SML
val €red_representation_clause1› = red_accept;

val €red_representation_clause2› = red_accept;

val €red_type_representation_clause1› = red_accept;
val €red_type_representation_clause2› = red_accept;
val €red_type_representation_clause3› = red_accept;

fun €red_length_clause› _ (Parsed(PPExp a)) _ (Parsed(PPExp e)) _ = (
    PPRepresentationClause(RCLength{attribute=a, exp=e}))
|   red_length_clause _ _ _ _ _ =
        stack_error "red_length_clause";
=TEX

SPARK manual 13.3:
=SML
fun €red_enumeration_representation_clause› _ (Token ((_,CNText id), _)) _
    (Parsed(PPExp e)) _ = (
    PPRepresentationClause(RCEnumeration{name=id, exp=e}))
|   red_enumeration_representation_clause _ _ _ _ _ =
        stack_error "red_enumeration_representation_clause";
=TEX

SPARK manual 13.4:
=SML
fun €red_record_representation_clause› _ (Token ((_,CNText id), _)) _ _
    (Parsed(PPExps [e])) (Parsed(PPComponentClauses c)) _ _ _ = (
    PPRepresentationClause(RCRecord{name=id, alignment_opt=Value e,
    component_pack=c}))
|   red_record_representation_clause _ (Token ((_,CNText id), _)) _ _
    (Parsed(PPExps [])) (Parsed(PPComponentClauses c)) _ _ _ = (
    PPRepresentationClause(RCRecord{name=id,alignment_opt=Nil,
    component_pack=c}))
|   red_record_representation_clause _ _ _ _ _ _ _ _ _ =
        stack_error "red_record_representation_clause";
=TEX

SPARK manual 13.4:
=SML
val €red_alignment_opt1› = PPExps [];
fun €red_alignment_opt2› _ _ (Parsed(PPExp e)) _ = (
    PPExps [e])
|   red_alignment_opt2 _ _ _ _ =
        stack_error "red_alignment_opt2";

val €red_component_pack1› = red_accept;

fun €red_component_pack2› (Parsed(PPComponentClauses [c])) 
    (Parsed(PPComponentClauses cs)) = (
    PPComponentClauses (c::cs))
|   red_component_pack2 _ _ =
        stack_error "red_component_pack2";
=TEX

SPARK manual 13.4:
=SML
fun €red_component_clause› (Parsed(PPExp n)) _ (Parsed(PPExp e)) _
    (Parsed(PPExp sr)) _ = (
    PPComponentClauses[{name=mk_type_mark n, exp=e,
        range=exp_to_range sr}])
|   red_component_clause _ _ _ _ _ _ =
        stack_error "red_component_clause";
=TEX

SPARK manual 13.5:
=SML
fun €red_address_clause› _ (Token ((_,CNText id), _)) _ _
    (Parsed (PPExp exp)) _ = (
    PPRepresentationClause(RCAddress {name=id, exp=exp}))
|   red_address_clause _ _ _ _ _ _ =
        stack_error "red_address_clause";
=TEX

=SML
end (* of structure CNParser stage 2 *);
=TEX

\section{PARSER}\label{PARSER}
=SML
structure €CNParser› : CNParser (* final stage *) = struct
=TEX

=SML
=TEX

We can now load the code generated by SLRP from the grammar
of 'cite{ISS/HAT/DAZ/DTD503}'.
=SML
    open CNParser ;
=FULLVERSION
   open ZTypeInference;
=TEX

=INCLUDE
dtd503.grm.sml
=TEX

\subsection{Conversion of Names to Type Marks}
The implementation of this function is at the beginning of section \ref{REDUCTIONFUNCTIONS}.
=SML
type €CN_PARSER_STATE› = CN_PARSER_STATE;
val €get_cn_parser_state› = get_cn_parser_state;
val €set_cn_parser_state› = set_cn_parser_state;
val €reset_cn_parser_state› = reset_cn_parser_state;
=FULLVERSION
val €z_predexp_of_z_tm›  = z_predexp_of_z_tm;
=TEX

=FULLVERSION
val €z_tm_true› : Z_TM = z_tm_true;
=CUTDOWNVERSION
val €z_tm_true› : Z_TM = dummy_z_tm;
=TEX

\subsection{The Parser Function Proper}

=SML
fun €cn_reader› (ip : CN_LEX_ITEM list) : CN_LEX_ITEM * (CN_LEX_ITEM list) = (
    case ip 
    of (h :: more) => (cur_tok := !cur_tok + 1; (h, more))
    |  [] => ((LCEos, CNEos), [])
    );
=TEX

=SML
val €cn_error› : (CN_LEX_ITEM, 'b, 'c, 'd) ERROR_ROUTINE =
    (fn (tok, stk, _, _) => (
    parse_error_hdr();
        diag_string (get_error_message 19003 [format_lex_item tok,
                    format_stack format_lex_item stk]);
        raise SYNTAX_ERROR
));
=TEX

The following is adapted from the HOL parser in \cite{DS/FMU/IED/IMP019} q.v.
for explanation.
=SML
fun €cn_parser› (ip : CN_LEX_ITEM list) : WEB_CLAUSE  = (
    let val se1 = (input_toks := ip; cur_tok := ~1);
        val save_cn_parser_state = get_cn_parser_state();
        val res = (((slrp'gen_parser
                default_resolver
                fst
                cn_error
                cn_reader) ip
            handle ex => (
                set_cn_parser_state save_cn_parser_state;
                raise ex
            ))		handle	SYNTAX_ERROR =>
				fail "cn_parser" 503204 []
			|	PARSER_ERROR msg =>
					error "cn_parser" 503205 [fn()=>msg]
	);
        val se2 = (input_toks := []);
    in    case res 
    of PPWebClause wc => wc
        |_ => stack_error "cn_parser - weird result from parser"
    end
    );
=TEX

\section{EPILOGUE}
=SML
end (* of structure CNParser final stage *);
=TEX

\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
