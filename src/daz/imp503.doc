% imp503.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Compliance Notation Parser}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP503}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the CN 
parser.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue \SCCSversion, \FormatDate{$Date$%
} ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the parser for
HOL/Z.
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD503}.
\subsection{Introduction}

\subsection{Purpose and Background}

\subsection{Algorithms}



\subsection{Dependencies}

\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX
\section{MISCELLANEOUS FUNCTIONS}\label{MISCELLANEOUSFUNCTIONS}
=SML
val debug : ZTypeInference.Z_INFERRED OPT ref = ref Nil;
structure €CNParser› = struct
=TEX
We need to include the SLRP driver code at this point:
=INCLUDE
imp018.sml
=TEX
=SML
open CNTypes;
open SlrpDriver;
=TEX
\subsection{Miscellanea}
$stack\_error$ is for use during context-free parsing when the parsing stack
is corrupt.
=SML
fun €stack_error› (insert : string) : 'a = (
	diag_string("Internal error in CN-Parser");
	BasicError.error "CN-Parser"  19005 [fn() => insert]
);
=TEX
To give error reports which are closely related to the actual input,
the following two variables are set up by the functions
$HOL\_parser$ and $HOL\_reader$. At any time during parsing $input\_toks$
can be expected to contain the totality of the token stream being parsed
and $toks\_read$ contains the offset in it of the token most recently
read (or is =INLINEFT
~1
=TEX
\ if nothing has been read yet).
=SML
val input_toks : CN_LEX_ITEM list ref = ref [];
val cur_tok : int ref = ref ~1;
=TEX
=SML
fun €format_lex_item›  ((_, tok) : CN_LEX_ITEM) : string = (
	case tok of
		CNZ _	=> " <z> "
	|	CNText s	=> s
	|	CNString s	=> s
	|	CNKSlot s	=> "K-Slot"
	|	CNEos		=> "<end-of-input>"
);
=TEX
=SML
fun €parse_error_hdr› () : unit = (
	let	val ok_toks =	format_list
				format_lex_item 
				((!input_toks) to (!cur_tok-1))
				" ";
		val bad_tok =	if !cur_tok >= 0 andalso !cur_tok < length (!input_toks)
				then " <?> " ^ format_lex_item (nth (!cur_tok) (!input_toks))
				else "";
	in	diag_string (get_error_message 19001 [ok_toks ^ bad_tok])
	end
);
=TEX
The following function produces the error reports for the unexpected
token type of error:
=TEX
=SML
fun €parse_error› (msg : int) (insert : string) : 'a = (
	parse_error_hdr();
	diag_string (get_error_message msg [insert]);
	raise SYNTAX_ERROR
);
=TEX
=SML
end (* of structure *);
=TEX

\section{REDUCTION FUNCTIONS}\label{REDUCTIONFUNCTIONS}
=SML
structure €CNParser› = struct
=TEX
=SML
open CNParser;
=TEX
We give the reduction functions in the order of their appearance
in the grammar of 'cite{ISS/HAT/DAZ/DTD503}'. When several reduction
functions would be the same, we use $val$ bindings for the various
instances.

=SML
local
	open ZLex ZParser ZTypeInference  ZTermGenerator ZUserInterfaceSupport;

fun term_of_z_para ((ZParaTerm (gpars, tm, _)) : Z_PARA) : TERM = (
let	val vns = map string_of_ident gpars;
	val vs = map (fn vn => mk_var(vn, mk_z_power_type(mk_vartype ("'" ^ vn)))) 
			vns;
in	list_mk_µ(vs, (do_in_theory (force_get_cache_theory()) term_of_z_tm tm))
end
) | term_of_z_para _ = (
	fail "z_term_recogniser" 49001 []
);

fun z_para_of_zinferred ((ZInferred p) : Z_INFERRED) : Z_PARA = (
	p
) | z_para_of_zinferred (ZTypeError inf) = (
	print_z_error inf
);

fun €z_term_of_z_tokens› (tokens : Z_TOKEN list) : TERM = (
let
	val standard = get_flag "standard_z_terms";
	val parsed = z_parser {is_quot = true} tokens;
	val side = case parsed of
		ZParaTerm _ => ()
		|_ => fail "z_term_recogniser" 49001 [];
	val type_checked = type_check_z_para
				{standard = standard, allow_frees = true} parsed;
	val side = (debug := Value type_checked);
	val para = z_para_of_zinferred type_checked;
in	term_of_z_para para
end);

fun schema_tokens (ztokens : ZLex.Z_TOKEN list) = (
	ZTLsqbrack::((rev o tl o rev) ztokens)@[ZTRsqbrack, ZTEos]
);

fun tuple_tokens (ztokens : ZLex.Z_TOKEN list) = (
	ZTLbrack::((rev o tl o rev) ztokens)@[ZTRbrack, ZTEos]
);

in

fun €z_tm_of_z_tokens› (tokens : Z_TOKEN list) : TERM = (
let
	val standard = get_flag "standard_z_terms";
	val parsed = z_parser {is_quot = true} tokens;
	val side = case parsed of
		ZParaTerm _ => ()
		|_ => fail "z_term_recogniser" 49001 [];
	val type_checked = type_check_z_para
				{standard = standard, allow_frees = true} parsed;
	val side = (debug := Value type_checked);
	val para = z_para_of_zinferred type_checked;
in	term_of_z_para para
end);

fun process_frame (ztokens : ZLex.Z_TOKEN list) : ID list = (
let	val zterm = z_term_of_z_tokens (tuple_tokens ztokens);
	val ids =
		case dest_z_term zterm of
		ZTuple ids => map (fst o dest_var) ids
		|_ => [(fst o dest_var) zterm];
in
	ids
end);

val process_pre_condition : ZLex.Z_TOKEN list -> TERM = z_term_of_z_tokens;

fun process_pre_and_post_conditions (ztokens : ZLex.Z_TOKEN list) : (TERM OPT * TERM) = (
let	val zterm = z_term_of_z_tokens (tuple_tokens ztokens);
	val prepost =
		case dest_z_term zterm of
		ZTuple [pre, post] => (Value pre, post)
		|_ => (Nil, zterm)
in
	prepost
end);
end (* local...in *);
=TEX

=SML
type AGG = {tm : TMARK OPT, named_assocs : (AGG_CHOICE,EXP) NAMED_ASSOC list, others : EXP OPT};
	
datatype €PPARSED› =
			PPAgg of AGG
		|	PPAggregateChoices of AGG_CHOICE list OPT
		|	PPBinaryOp of BIN_OP
		|	PPBinOpTail of (BIN_OP * EXP) list
		|	PPCaseAlternatives of STMT CASE_ALTERNATIVE list
		|	PPCaseChoices of CASE_CHOICE list
		|	PPCompilationUnit of (ID list * COMPILATION_UNIT)
		|	PPComponentClauses of COMPONENT_CLAUSE list
		|	PPDeclarations of DECLARATION list
		|	PPElsIf of (EXP * STMT) list
		|	PPExp of EXP
		|	PPExps of EXP list
		|	PPFormals of PARAMETER_SPECIFICATION list
		|	PPFunctionSpecification of FUNCTION_SPECIFICATION
		|	PPId of ID
		|	PPIdExp of (ID * EXP)
		|	PPIds of ID list
		|	PPKSlot of K_SLOT
		|	PPKSlotCUList of KSLOT_COMPILATION_UNIT list
		|	PPLogCon of LOG_CON
		|	PPMode of MODE
		|	PPPackageSpecification of PACKAGE_DECLARATION
		|	PPPrimedIdentifier of (ID * ID)
		|	PPProcedureSpecification of PROCEDURE_SPECIFICATION
		|	PPProperBody of PROPER_BODY
		|	PPReltail of (BIN_OP * EXP)
		|	PPRenamingDeclaration of RENAMING_DECLARATION
		|	PPRepresentationClause of REPRESENTATION_CLAUSE
		|	PPSRExpression of (EXP * EXP OPT)
		|	PPStmt of STMT
		|	PPSubprogram of (DECLARATION list * STMT)
		|	PPSubprogramSpec of SUBPROGRAM_SPECIFICATION
		|	PPUnaryOp of UNARY_OP
		|	PPWebClause of WEB_CLAUSE
		|	PPtbs;
=TEX
=SML
fun format_rw_input (ip : Lex.INPUT list) = (
	"RW-Input"
);

fun format_label (n : string) = (
	"("^n^")"
);

fun name_to_tmark (e : EXP) :  TMARK = (
	"TMARK_stub"
);

fun range_attribute_to_range (e :EXP) : EXP RANGE OPT = (
	(* Temporary fix *)
	Value {lo=e, hi=e}
);

fun sr_expression_to_range_opt {no_r_attr : bool} ((e,v) : (EXP * EXP OPT)) : EXP RANGE OPT = (
	case v of
	Value e2 => Value {lo=e, hi=e2}
	|Nil => if no_r_attr
		then
			Nil
		else
			range_attribute_to_range e
);

fun sr_expression_to_expression_opt ((e,v) : (EXP * EXP OPT)) : EXP OPT = (
	case sr_expression_to_range_opt {no_r_attr=true} (e,v) of
	Value _ => Nil
	|Nil => Value e
);
=TEX
=SML
fun red_accept (Parsed pp) = (pp
) | red_accept (Token ((l,CNText t),_)) = (
	stack_error ("red_accept [Token("
		^(PolyML.makestring l)^", Text "^(PolyML.makestring t)^")]")
) | red_accept (Token ((l,t),_)) = (
	stack_error ("red_accept ["
		^(PolyML.makestring l)^", "^(PolyML.makestring t)^"]")
);
=TEX
=SML
fun red_web_clause1 (Parsed (PPKSlotCUList cul)) = (
	PPWebClause (Compilation cul)
) | red_web_clause1 _ = stack_error "red_web_clause1";

fun red_web_clause2 (Token ((_, CNText lab), _)) _ (Parsed (PPKSlotCUList cul)) = (
	PPWebClause (ReplacedByCompilation {label=lab,comp=cul})
) | red_web_clause2 _ _ _ = stack_error "red_web_clause2";

fun red_web_clause3 (Token ((_,CNText lab), _)) _ (Parsed (PPDeclarations d)) = (
	PPWebClause (ReplacedByPrivatePart {label=lab, private=d})
) | red_web_clause3 _ _ _ = stack_error "red_web_clause3";

fun red_web_clause4 (Token ((_,CNText lab), _)) _ (Parsed (PPDeclarations d)) = (
	PPWebClause (ReplacedByVisiblePart {label=lab, visible=d})
) | red_web_clause4 _ _ _ = stack_error "red_web_clause4";

fun red_web_clause5 (Token ((_,CNText lab), _)) _ (Parsed (PPDeclarations d)) = (
	PPWebClause (ReplacedByDecl {label=lab, decls=d})
) | red_web_clause5 _ _ _ = stack_error "red_web_clause5";

fun red_web_clause6 (Token ((_,CNText lab), _)) _ (Parsed (PPStmt s)) = (
	PPWebClause (ReplacedBy {label=lab, statement=Stmt s})
) | red_web_clause6 _ _ _ = stack_error "red_web_clause6";

fun red_web_clause7 (Token ((_,CNText lab), _)) _ (Parsed (PPStmt s)) = (
	PPWebClause (RefinedBy {label=lab, statement=Stmt s})
) | red_web_clause7 _ _ _ = stack_error "red_web_clause7";

fun red_web_clause8 _ (Parsed (PPStmt s)) = (
	PPWebClause (RefinedBy {label="*", statement=Stmt s})
) | red_web_clause8 _ _ = stack_error "red_web_clause8";

fun red_web_clause9 (Token ((_,CNText lab), _)) _ (Parsed (PPStmt s)) = (
	PPWebClause (ReplacedBy {label=lab, statement=Stmt s})
) | red_web_clause9 _ _ _ = stack_error "red_web_clause9";

fun red_web_clause10  _ (Parsed (PPStmt s)) = (
	PPWebClause (ReplacedBy {label="*", statement=Stmt s})
) | red_web_clause10 _ _ = stack_error "red_web_clause10";
=TEX
=SML
val red_basic_declaration1 = red_accept;
val red_basic_declaration2 = red_accept;
val red_basic_declaration3 = red_accept;
val red_basic_declaration4 = red_accept;
val red_object_declaration1 = red_accept;
val red_object_declaration2 = red_accept;
=TEX
=SML
fun red_constant_declaration x1 x2 x3 x4 x5 x6 x7 = PPtbs;
fun red_variable_declaration x1 x2 x3 x4 = PPtbs;

fun red_identifier_list1 (Token ((_,CNText id), _)) = (
	PPIds [id]
) | red_identifier_list1 _ = stack_error "red_identifier_list1";

fun red_identifier_list2 (Token ((_,CNText id), _)) _ (Parsed(PPIds ids)) = (
	PPIds (id::ids)
) | red_identifier_list2 _ _ _ = stack_error "red_identifier_list2";
=TEX
=SML
val red_type_declaration1 = red_accept;
val red_type_declaration2 = red_accept;
=TEX
=SML
fun red_full_type_declaration1 x1 x2 x3 x4 x5 x6 = PPtbs;
fun red_full_type_declaration2 x1 x2 x3 x4 x5 = PPtbs;
=TEX
=SML
val red_type_definition1 = red_accept;
val red_type_definition2 = red_accept;
val red_type_definition3 = red_accept;
val red_type_definition4 = red_accept;
val red_type_definition5 = red_accept;
=TEX
=SML
fun red_subtype_declaration x1 x2 x3 x4 x5 = PPtbs;
fun red_subtype_indication x1 x2 = PPtbs;
=TEX
=SML
val red_constraint1 = red_accept;
val red_constraint2 = red_accept;
val red_constraint3 = red_accept;
=TEX
=SML
fun red_range_constraint _ (Parsed sr) = (
	sr
) | red_range_constraint _ _ = stack_error "red_range_constraint";
fun red_enumeration_type_definition x1 x2 x3 = PPtbs;
=TEX
=SML
val red_integer_type_definition = red_accept;
val red_real_type_definition1 = red_accept;
val red_real_type_definition2 = red_accept;
val red_floating_point_constraint1 = red_accept;
=TEX
=SML
fun red_floating_point_constraint2 x1 x2 = PPtbs;
fun red_floating_accuracy_definition x1 x2 = PPtbs;
=TEX
=SML
val red_fixed_point_constraint1 = red_accept;
=TEX
=SML
fun red_fixed_point_constraint2 x1 x2 = PPtbs;
fun red_fixed_accuracy_definition x1 x2 = PPtbs;
=TEX
=SML
val red_array_type_definition1 = red_accept;
val red_array_type_definition2 = red_accept;
=TEX
=SML
fun red_unconstrained_array_definition x1 x2 x3 x4 x5 x6 = PPtbs;
fun red_constrained_array_definition x1 x2 x3 x4 = PPtbs;
=TEX
=SML
fun red_index_subtype_definition_list1 (Parsed(PPExp n)) = (
	PPExps [n]
) | red_index_subtype_definition_list1 _ = stack_error "red_index_subtype_definition_list1";
=TEX
=SML
fun red_index_subtype_definition_list2 (Parsed(PPExp n)) _ (Parsed(PPExps nl)) = (
	PPExps (n::nl)
) | red_index_subtype_definition_list2 _ _ _ = stack_error "red_index_subtype_definition_list2";

fun red_index_subtype_definition (Parsed p) _ _ = (
	p
) | red_index_subtype_definition _ _ _ = stack_error "red_index_subtype_definition";
fun red_index_constraint _ (Parsed p) _ = (
	p
) | red_index_constraint _ _ _ = stack_error "red_index_constraint";

fun red_name_list1 (Parsed(PPExp n)) = (
	PPExps [n]
) | red_name_list1 _ = stack_error "red_name_list1";

fun red_name_list2 (Parsed(PPExp n)) _ (Parsed(PPExps nl)) = (
	PPExps (n::nl)
) | red_name_list2 _ _ _ = stack_error "red_name_list2";
=TEX
=SML
fun red_discrete_range1 (Parsed (PPExp e)) (Parsed p) = (
let	val side = name_to_tmark e;
in
		p
end
) | red_discrete_range1 _ _ = stack_error "red_discrete_range1";

fun red_discrete_range2 (Parsed p) = (
	p
) | red_discrete_range2 _ = stack_error "red_discrete_range2";

fun red_record_type_definition x1 x2 x3 x4 = PPtbs;
=TEX
=SML
val red_component_list1 = red_accept;
val red_component_list2 = red_accept;
=TEX
=SML
fun red_component_list3 x1 x2 = PPtbs;
fun red_component_list4 (Token ((LCNull,_), _)) = (
	PPStmt Null
) | red_component_list4 _ = stack_error "red_component_list4";
fun red_component_declaration_list1 x1 = PPtbs;
fun red_component_declaration_list2 x1 x2 = PPtbs;
fun red_component_declaration x1 x2 x3 x4 = PPtbs;
fun red_discriminant_part x1 x2 x3 = PPtbs;
fun red_variant_part x1 x2 x3 x4 x5 x6 x7 = PPtbs;
fun red_variant_list1 x1 = PPtbs;
fun red_variant_list2 x1 x2 = PPtbs;
fun red_variant x1 x2 x3 x4 = PPtbs;
fun red_variant_choice_list1 (Token ((_,CNText id), _)) = (
	PPIds [id]
) | red_variant_choice_list1 _ = stack_error "red_variant_choice_list1";

fun red_variant_choice_list2 (Token ((_,CNText id), _)) _ (Parsed(PPIds ids)) = (
	PPIds (id::ids)
) | red_variant_choice_list2 _ _ _ = stack_error "red_variant_choice_list2";
=TEX
SPARK manual 3.9:
=TEX
=SML
val red_declarative_part1 = red_accept;

fun red_declarative_part2 (Parsed (PPDeclarations d1)) (Parsed (PPDeclarations d2)) = (
	PPDeclarations (d1@d2)
) | red_declarative_part2 _ _ = stack_error "red_declarative_part2";
=TEX
=SML
fun red_dec1 (Parsed(PPKSlot k)) = (
	PPDeclarations [DDeclarationKSlot k]
) | red_dec1 _ = stack_error "red_dec1";

val red_dec2 = red_accept;
val red_dec3 = red_accept;
val red_dec4 = red_accept;
val red_dec5 = red_accept;
=TEX
=SML
fun red_basic_declarative_item1 _ = PPDeclarations [];
fun red_basic_declarative_item2 _ = PPDeclarations [];
val red_body1 = red_accept;
val red_body2 = red_accept;
val red_proper_body1 = red_accept;
val red_proper_body2 = red_accept;
=TEX
=SML
fun red_name1 (Token ((_,CNText name), _)) = (
	PPExp(Id name)
) | red_name1 _ = stack_error "red_name1";

val red_name2 = red_accept;
val red_name3 = red_accept;
val red_name4 = red_accept;
=TEX
SPARK manual 4.1.1:
=SML
fun red_indexed_component (Parsed(PPExp n)) (Parsed(PPExp index)) = (
	PPExp(IndexedComp{prefix=n, index=index})
) | red_indexed_component _ _ = stack_error "red_indexed_component";
=TEX
SPARK manual 4.1.3:
=SML
fun red_selected_component (Parsed(PPExp n)) _ (Parsed(PPId id)) = (
	PPExp(SelectedComp{prefix=n, selector=id})
) | red_selected_component _ _ _ = stack_error "red_selected_component";

fun red_selector (Token ((_,CNText id), _)) = (
	PPId id
) | red_selector _ = stack_error "red_selector";
=TEX
SPARK manual 4.1/4.1.1:
=SML
fun red_expression_list1 (Parsed(PPExp e)) = (
	PPExps [e]
) | red_expression_list1 _ = stack_error "red_expression_list1";

fun red_expression_list2 (Parsed(PPExp e)) _ (Parsed(PPExps es)) = (
	PPExps (e::es)
) | red_expression_list2 _ _ _ = stack_error "red_expression_list2";
=TEX
TBS - the correct handling of character literals
=SML
fun red_attribute1 (Parsed(PPExp n)) (Token ((_,CNText primedid), _)) = (
	PPExp(IndexedComp{prefix=n, index=Id primedid})
) | red_attribute1 _ _ = stack_error "red_attribute1";

fun red_attribute2 (Token ((CharacterLiteral,CNText id), _)) (Token ((_,CNText primedid), _)) = (
	PPExp(IndexedComp{prefix=Id id, index=Id primedid})
) | red_attribute2 _ _ = stack_error "red_attribute2";

fun red_aggregate _ (Parsed p) _ = (
	p
) | red_aggregate _ _ _ = stack_error "red_aggregate";
=TEX
=SML
fun red_component_association1 (Parsed(PPAgg{tm=tm,named_assocs=na,others=ot})) = (
	case ot of
	Value oe => PPExp (ArrayAggNamedOthers{tmark="__component_association",agg_named={named_assocs=na},others={others=oe}})
	|Nil => PPExp (ArrayAggNamed{named_assocs=na})
) | red_component_association1 _ = stack_error "red_component_association1";

fun red_component_association2 (Parsed(PPExps es)) = (
	PPExp(ArrayAggPos{tmark="__component_association",comps = es})
) | red_component_association2 _ = stack_error "red_component_association2";

=TEX
=SML
fun red_named_association1 (Parsed(PPAggregateChoices v)) _ (Parsed(PPExp e)) = (
	case v of
	Value c => PPAgg{tm=Nil, named_assocs =[{choice=c, comp=e}],others=Nil}
	|Nil => PPAgg{tm=Nil, named_assocs=[], others=Value e}
) | red_named_association1 _ _ _ = stack_error "red_named_association1";

fun red_named_association2 (Parsed(PPAggregateChoices v)) _ (Parsed(PPExp e)) _ (Parsed(PPAgg {named_assocs=na,others=ot,...})) = (
	case v of
	Value c => PPAgg{tm=Nil,named_assocs={choice=c,comp=e}::na,others=ot}
	|Nil => parse_error 0 "red_named_association2"
) | red_named_association2 _ _ _ _ _ = stack_error "red_named_association2";

fun red_aggregate_choice_list1 (Token ((LCOthers,_), _)) = (
	PPAggregateChoices Nil
) | red_aggregate_choice_list1 _ = stack_error "red_aggregate_choice_list1";

val red_aggregate_choice_list2 = red_accept;

fun red_aggregate_choice_list3 (Parsed(PPAggregateChoices v)) _ (Parsed(PPAggregateChoices (Value acl))) = (
	case v of
	Value [ac] => PPAggregateChoices(Value(ac::acl))
	|_ => parse_error 0 "red_aggregate_choice_list3"
) | red_aggregate_choice_list3 _ _ _ = stack_error "red_aggregate_choice_list3";
=TEX
=SML
fun red_aggregate_choice (Parsed(PPSRExpression (e,v))) = (
	case v of
	Value e2 => PPAggregateChoices(Value[AggChoiceRange{lo=e,hi=e2}])
	|Nil => PPAggregateChoices(Value[AggChoiceSingle e])
) | red_aggregate_choice _ = stack_error "red_aggregate_choice";

val red_positional_association = red_accept;
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
=SML
val red_expression1 = red_accept;

fun red_expr (Parsed (PPExp exp1)) (Parsed (PPReltail(binop, exp2))) = (
	PPExp (BinExp {Op = binop, left = exp1, right = exp2})
) | red_expr _ _ = stack_error "red_expr";

val red_expression2 = red_expr;
val red_expression3 = red_expr;
val red_expression4 = red_expr;
val red_expression5 = red_expr;
val red_expression6 = red_expr;
=TEX
=SML
fun red_logrel1 binop (Parsed(PPExp exp)) = (
	PPReltail(binop, exp)
) | red_logrel1 _ _ = stack_error "red_logrel1";

fun red_logrel2 binop (Parsed(PPExp exp1)) (Parsed(PPReltail(_,exp2))) = (
	PPReltail(binop, BinExp{Op=binop, left=exp1, right=exp2})
) | red_logrel2 _ _ _ = stack_error "red_logrel2";

fun red_and_relation1 _ x2 =		(red_logrel1 SparkAnd x2);
fun red_and_relation2 _ x2 x3 =		(red_logrel2 SparkAnd x2 x3);
fun red_and_then_relation1 _ _ x3 =	(red_logrel1 SparkAndThen x3);
fun red_and_then_relation2 _ _ x3 x4 =	(red_logrel2 SparkAndThen x3 x4);
fun red_or_relation1 _ x2 =		(red_logrel1 SparkOr x2);
fun red_or_relation2 _ x2 x3 =		(red_logrel2 SparkOr x2 x3);
fun red_or_else_relation1 _ _ x3 =	(red_logrel1 SparkOrElse x3);
fun red_or_else_relation2 _ _ x3 x4 =	(red_logrel2 SparkOrElse x3 x4);
fun red_xor_relation1 _ x2 =		(red_logrel1 SparkXor x2);
fun red_xor_relation2 _ x2 x3 =		(red_logrel2 SparkXor x2 x3);
=TEX
=SML
fun red_relation1 (Parsed(PPSRExpression (sr as (e, _)))) = (
	case sr_expression_to_expression_opt sr of
	Value e => PPExp e
	|Nil => parse_error 0 "red_relation1"
) | red_relation1 _ = stack_error "red_relation1";

fun red_relation2 (Parsed(PPSRExpression sr1)) (Parsed(PPBinaryOp b)) (Parsed(PPSRExpression sr2)) = (
let	val e1 = ( case sr_expression_to_expression_opt sr1 of
			Value e1 => e1
			|Nil => parse_error 0 "red_relation1"
		);
	val e2 = ( case sr_expression_to_expression_opt sr2 of
			Value e2 => e2
			|Nil => parse_error 0 "red_relation1"
		);
in
	PPExp(BinExp{left=e1,Op=b, right=e2})
end
) | red_relation2 _ _ _ = stack_error "red_relation2";

val red_relation3  = red_relation2;
fun red_relation4 p1 _ _ p2 = red_relation2 p1 (Parsed(PPBinaryOp SparkNotmem)) p2;
=TEX
=SML
fun red_sr_expression1 (Parsed(PPExp e)) = (
	PPSRExpression (e, Nil)
) | red_sr_expression1 _ = stack_error "red_sr_expression1";

fun red_sr_expression2 (Parsed(PPExp e1)) _ (Parsed(PPExp e2)) = (
	PPSRExpression (e1, Value e2)
) | red_sr_expression2 _ _ _ = stack_error "red_sr_expression2";
=TEX
=SML
fun do_binarytail left ((b,right)::(rest as (_::_))) = (
	BinExp{left=left, Op=b, right=do_binarytail right rest}
) | do_binarytail left [(b,right)] = (
	BinExp{left=left, Op=b, right=right}
) | do_binarytail left _ = left;

fun red_simple_expression1 (Parsed(PPExp e)) (Parsed(PPBinOpTail tl)) = (
	PPExp (do_binarytail e tl)
) | red_simple_expression1 _ _ = stack_error "red_simple_expression1";

fun red_simple_expression2 (Parsed(PPUnaryOp uop)) (Parsed(PPExp e)) (Parsed(PPBinOpTail tl)) = (
	PPExp (do_binarytail (UnaryExp{Op=uop,right=e}) tl)
) | red_simple_expression2 _ _ _ = stack_error "red_simple_expression2";

val red_binoptail1 = PPBinOpTail [];

fun red_binoptail2 (Parsed(PPBinaryOp b)) (Parsed(PPExp e)) (Parsed(PPBinOpTail tl)) = (
	PPBinOpTail((b,e)::tl)
) | red_binoptail2 _ _ _ = stack_error "red_binoptail2";

val red_term1 = red_accept;

fun red_term2 (Parsed(PPExp e1)) (Parsed(PPBinaryOp m)) (Parsed(PPExp e2)) = (
	PPExp(BinExp{left=e1,Op=m,right=e2})
) | red_term2 _ _ _ = stack_error "red_term2";
=TEX
=SML
val red_factor1 = red_accept;
fun red_factor2 (Parsed(PPExp e1)) _ (Parsed(PPExp e2)) = (
	PPExp(BinExp{left=e1,Op=SparkExpon,right=e2})
) | red_factor2 _ _ _ = stack_error "red_factor2";

fun red_factor3 _ (Parsed(PPExp e)) = (
	PPExp(UnaryExp{Op=SparkAbs, right=e})
) | red_factor3 _ _ = stack_error "red_factor3";

fun red_factor4 _ (Parsed(PPExp e)) = (
	PPExp(UnaryExp{Op=SparkNot, right=e})
) | red_factor4 _ _ = stack_error "red_factor4";
=TEX
=SML
fun red_primary1 (Token ((LCNumericLiteral,CNText n), _)) = (
	PPExp (Int n)
) | red_primary1 _ = stack_error "red_primary1";

(* TBS character literal missing in AS *)
fun red_primary2 (Token ((LCCharacterLiteral,CNText n), _)) = (
	PPExp (Id n)
) | red_primary2 _ = stack_error "red_primary2";

(* TBS string literal missing in AS *)
fun red_primary3 (Token ((LCStringLiteral,CNText n), _)) = (
	PPExp (Id n)
) | red_primary3 _ = stack_error "red_primary3";

val red_primary4 = red_accept;
val red_primary5 = red_accept;
fun red_primary6 _ (Parsed p) _ = (
	p
) | red_primary6 _ _ _ = stack_error "red_primary6";

val red_primary7 = red_accept;
=TEX
=SML
fun red_relational_operator1 _ = PPBinaryOp SparkEq;
fun red_relational_operator2 _ = PPBinaryOp SparkNotEq;
fun red_relational_operator3 x1 = PPBinaryOp SparkLess;
fun red_relational_operator4 x1 = PPBinaryOp SparkLessEq;
fun red_relational_operator5 x1 = PPBinaryOp SparkGreater;
fun red_relational_operator6 x1 = PPBinaryOp SparkGreaterEq;
fun red_binary_adding_operator1 x1 = PPBinaryOp SparkAdd;
fun red_binary_adding_operator2 x1 = PPBinaryOp SparkMinus;
=TEX
TBS - ampersand missing from AS
=SML
fun red_binary_adding_operator3 x1 = PPBinaryOp SparkAdd;
fun red_unary_adding_operator1 x1 = PPUnaryOp SparkUnaryAdd;
fun red_unary_adding_operator2 x1 = PPUnaryOp SparkUnaryMinus;
fun red_multiplying_operator1 x1 = PPBinaryOp SparkTimes;
fun red_multiplying_operator2 x1 = PPBinaryOp SparkIntdiv;
fun red_multiplying_operator3 x1 = PPBinaryOp SparkMod;
fun red_multiplying_operator4 x1 = PPBinaryOp SparkRem;
=TEX
=SML
fun red_qualified_expression (Parsed(PPExp n)) _ (Parsed(PPExp e)) = (
	case e of
		ArrayAggNamedOthers{agg_named=an,others=ot,...} =>
			PPExp(ArrayAggNamedOthers{tmark=name_to_tmark n,agg_named=an,others=ot})
		|ArrayAggPos{comps=es,...} =>
			PPExp(ArrayAggPos{tmark=name_to_tmark n,comps=es})
		|_ => parse_error 0 "red_qualified_expression"
) | red_qualified_expression _ _ _ = stack_error "red_qualified_expression";

val red_sequence_of_statements1 = red_accept;
fun red_sequence_of_statements2 (Parsed(PPStmt s1)) (Parsed(PPStmt s2)) = (
	PPStmt(Semicolon(s1, s2))
) | red_sequence_of_statements2 _ _ = stack_error "red_sequence_of_statements2";
 ;

fun red_statement1 (Parsed(PPKSlot k)) = (
	PPStmt(KSlot k)
) | red_statement1 _ = stack_error "red_statement1";
val red_statement2 = red_accept;
=IGN
fun red_statement3 _ (Token ((LCZ,CNZ z1), _)) _ (Parsed(PPStmt(SpecNoIvars s))) = (
	PPLogCon{X=process_frame z1, E=ÒtrueÆ,spec=s, pre1 = ÒtrueÆ}

) | red_statement3 _ _ _ _ = stack_error "red_statement3";
=SML
fun red_statement3 _ _ _ _ = PPtbs;
val red_statement4 = red_accept;
val red_statement5 = red_accept;
=TEX

=SML
fun red_specification_statement1 _ (Token ((LCZ,CNZ z1), _)) _ (Token ((LCZ,CNZ z2), _)) _ = (
let	val (pre, post) =
		case process_pre_and_post_conditions z2 of
		(Value pre', post') => (pre', post')
		|(Nil, post') => (ÒTRUEÆ, post');
in
	PPStmt(SpecNoIvars{w=process_frame z1,w0=[],pre=pre,post=post})
end
) | red_specification_statement1 _ _ _ _ _ = stack_error "red_specification_statement1";

fun red_specification_statement2 _ (Token ((LCZ,CNZ z1), _)) _ (Token ((LCZ,CNZ z2), _)) _ = (
let	val (pre, post) = (process_pre_condition z2, ÒTRUEÆ);
in
	PPStmt(SpecNoIvars{w=process_frame z1,w0=[],pre=pre,post=post})
end
) | red_specification_statement2 _ _ _ _ _ = stack_error "red_specification_statement2";

fun red_specification_statement3 _ (Token ((LCZ,CNZ z1), _)) _ (Token ((LCZ,CNZ z2), _)) _ (Parsed(PPId lab))= (
let	val (pre, post) =
		case process_pre_and_post_conditions z2 of
		(Value pre', post') => (pre', post')
		|(Nil, post') => (ÒTRUEÆ, post');
in
	PPStmt(SpecNoIvars{w=process_frame z1,w0=["<Stub>"],pre=pre,post=post})
end
) | red_specification_statement3 _ _ _ _ _ _ = stack_error "red_specification_statement3";

fun red_specification_statement4 _ (Token ((LCZ,CNZ z1), _)) _ (Token ((LCZ,CNZ z2), _)) _ (Parsed(PPId lab))= (
let	val (pre, post) = (process_pre_condition z2, ÒTRUEÆ);
in
	PPStmt(SpecNoIvars{w=process_frame z1,w0=[],pre=pre,post=post})
end
) | red_specification_statement4 _ _ _ _ _ _ = stack_error "red_specification_statement4";
=TEX
=SML
fun red_label _ (Token ((LCNumericLiteral,CNText n), _)) _ = (
	PPId (format_label n)
) | red_label _ _ _ = stack_error "red_label";

fun red_k_slot1 (Token ((LCKSlot,CNKSlot lx), _)) = (
	PPKSlot{content=format_rw_input lx, label="*"}
) | red_k_slot1 _ = stack_error "red_k_slot1";

fun red_k_slot2 (Token ((LCKSlot,CNKSlot lx), _)) (Parsed(PPId lab)) = (
	PPKSlot{content=format_rw_input lx, label=lab}
) | red_k_slot2 _ _ = stack_error "red_k_slot2";
=TEX
=SML
val red_simple_statement1 = red_accept;
val red_simple_statement2 = red_accept;
val red_simple_statement3 = red_accept;
val red_simple_statement4 = red_accept;
val red_simple_statement5 = red_accept;
val red_compound_statement1 = red_accept;
val red_compound_statement2 = red_accept;
val red_compound_statement3 = red_accept;
=TEX
=SML
fun red_null_statement _ _ = PPStmt Null;

fun red_assignment_statement (Parsed(PPExp n)) _ (Parsed(PPExp e)) _ = (
	PPStmt(Assign{name=n, E=e})
) | red_assignment_statement _ _ _ _ = stack_error "red_assignment_statement";
=TEX
=SML
fun red_if_statement _ (Parsed(PPExp exp)) _ (Parsed(PPStmt s)) (Parsed(PPElsIf ei)) (Parsed(PPStmt el)) _ _ _ = (
let	val css = (exp,s)::ei;
	fun aux ((c,s)::(rest as (_::_))) el = (
		(IfThenElse{G=c,P=s,Q=aux rest el})
	) | aux [(c,s)] el = (
		(IfThenElse{G=c,P=s,Q=el})
	) | aux _ _ = Null;
in
	PPStmt (aux css el)
end
) | red_if_statement _ _ _ _ _ _ _ _ _ = stack_error "red_if_statement";
=TEX
=SML
val red_elsif_part1 = PPElsIf [];
fun red_elsif_part2 _ (Parsed (PPExp exp)) _ (Parsed(PPStmt s)) (Parsed(PPElsIf ei)) = (
	PPElsIf ((exp, s)::ei)
) | red_elsif_part2 _ _ _ _ _ = stack_error "red_elsif_part2";
=TEX
=SML
val red_else_part1 = PPStmt Null;

fun red_else_part2 _ (Parsed(PPStmt s)) = (
	PPStmt s
) | red_else_part2 _ _ = stack_error "red_else_part2";

fun red_condition (Parsed (PPExp exp)) = (
	PPExp (Id "<exp-stub>")
) | red_condition _ = stack_error "red_condition";
=TEX
=SML
fun red_case_statement _ (Parsed(PPExp e)) _ (Parsed(PPCaseAlternatives cs)) others _ _ _ = (
	PPStmt(Case{E=e, s=cs})
) | red_case_statement _ _ _ _ _ _ _ _ = stack_error "red_case_statement";

val red_case_statement_alternative_list1 = red_accept;

fun red_case_statement_alternative_list2 (Parsed(PPCaseAlternatives [c])) (Parsed(PPCaseAlternatives cs)) = (
	PPCaseAlternatives (c::cs)
) | red_case_statement_alternative_list2 _ _ = stack_error "red_case_statement_alternative_list2";

fun red_case_statement_alternative _ (Parsed(PPCaseChoices c)) _ (Parsed(PPStmt s)) = (
	PPCaseAlternatives[{choices=c, P=s}]
) | red_case_statement_alternative _ _ _ _ = stack_error "red_case_statement_alternative";
=TEX
=SML
val red_case_choice_list1 = red_accept;

fun red_case_choice_list2 (Parsed(PPCaseChoices [ac])) _ (Parsed(PPCaseChoices acl)) = (
	PPCaseChoices(ac::acl)
) | red_case_choice_list2 _ _ _ = stack_error "red_acase_choice_list2";

fun red_case_choice (Parsed(PPSRExpression (e,v))) = (
	case v of
	Value e2 => PPCaseChoices[CaseRange{lo=e,hi=e2}]
	|Nil => PPCaseChoices[CaseExp e]
) | red_case_choice _ = stack_error "red_case_choice";

val red_others_part1 = PPStmt Null;
fun red_others_part2 _ _ (Parsed(PPStmt s)) = (
	PPStmt s
) | red_others_part2 _ _ _ = stack_error "red_others_part2";
=TEX
SPARK manual 5.5:
TBS The loop construct loses information. This needs to be remedied in the AS.
=SML
fun red_loop_statement _ x2 (Parsed(PPExps t)) _ (Parsed(PPStmt s)) _ _ _ _ = (
	PPtbs
) | red_loop_statement _ _ _ _ _ _ _ _ _ = stack_error "red_loop_statement";

val red_name_opt11 = PPExps[];

fun red_name_opt12 (Token ((_,CNText id), _)) _ = (
	PPExp(Id id)
) | red_name_opt12 _ _ = stack_error "red_name_opt12";

val red_name_opt21 = PPExps [];
fun red_name_opt22 (Token ((_,CNText id), _)) = (
	PPExps [Id id]
) | red_name_opt22 _ = stack_error "red_name_opt22";

val red_iteration_scheme_opt1 = PPtbs;
fun red_iteration_scheme_opt2 x1 = PPtbs;
fun red_iteration_scheme1 x1 x2 = PPtbs;
fun red_iteration_scheme2 x1 x2 = PPtbs;
fun red_loop_parameter_specification1 (Token ((LCZ,CNZ z), _)) _ (Parsed(PPExp n)) = (
	PPtbs
) | red_loop_parameter_specification1 _ _ _ = stack_error "red_loop_parameter_specification1";

fun red_loop_parameter_specification2 (Token ((LCZ,CNZ z), _)) _ _ (Parsed(PPExp n)) = (
	PPtbs
) | red_loop_parameter_specification2 _ _ _ _ = stack_error "red_loop_parameter_specification2";

fun red_loop_parameter_specification3 (Token ((LCZ,CNZ z), _)) _ (Parsed(PPExp n)) _ (Parsed(PPSRExpression (e, v))) = (
	PPtbs
) | red_loop_parameter_specification3 _ _ _ _ _ = stack_error "red_loop_parameter_specification3";

fun red_loop_parameter_specification4 (Token ((LCZ,CNZ z), _)) _ _ (Parsed(PPExp n)) _ (Parsed(PPSRExpression (e, v))) = (
	PPtbs
) | red_loop_parameter_specification4 _ _ _ _ _ _ = stack_error "red_loop_parameter_specification4";

val red_till_opt1 = PPExps [];
fun red_till_opt2 _ (Parsed(PPExp(AuxiliaryExp z))) = (
	PPExps[(AuxiliaryExp z)]
) | red_till_opt2 _ _ = stack_error "red_till_opt2";
=TEX
=SML
fun red_abstract_expression _ (Token ((LCZ,CNZ z), _)) _ = (
	PPExp(AuxiliaryExp (z_tm_of_z_tokens z))
) | red_abstract_expression _ _ _ = stack_error "red_abstract_expression";

fun red_exit_statement1 _ _ = (
	PPStmt Exit
);
fun red_exit_statement2 _ _ (Parsed(PPExp exp)) _ = (
	PPStmt(ExitWhen{G=exp})
) | red_exit_statement2 _ _ _ _ = stack_error "red_exit_statement2";

fun red_return_statement _ (Parsed(PPExp exp)) _ = (
	PPStmt (Ret{E=exp})
) | red_return_statement _ _ _ = stack_error "red_return_statement";
=TEX
=SML
fun red_subprogram_declaration1 (Parsed p) _ = (p
) | red_subprogram_declaration1 _ _ = stack_error "red_subprogram_declaration1";
fun red_subprogram_declaration2 (Parsed p) _ = (p
) | red_subprogram_declaration2 _ _ = stack_error "red_subprogram_declaration2";

fun red_subprogram_specification1 (Parsed(PPProcedureSpecification p)) = (
	PPSubprogramSpec(ProcedureSpecification p)
) | red_subprogram_specification1 _ = stack_error "red_subprogram_specification1";

fun red_subprogram_specification2 (Parsed(PPFunctionSpecification p)) = (
	PPSubprogramSpec(FunctionSpecification p)
) | red_subprogram_specification2 _ = stack_error "red_subprogram_specification2";
=TEX
=SML
fun red_procedure_specification1 _ (Token ((_,CNText id), _)) = (
	PPProcedureSpecification{name=id, formal_part=[],spec=Nil}
) | red_procedure_specification1 _ _ = stack_error "red_procedure_specification1";

fun red_procedure_specification2 _ (Token ((_,CNText id), _)) (Parsed(PPStmt(SpecNoIvars s))) = (
	PPProcedureSpecification{name=id,formal_part=[],spec=Value s}
) | red_procedure_specification2 _ _ _ = stack_error "red_procedure_specification2";

fun red_procedure_specification3 _ (Token ((_,CNText id), _)) (Parsed (PPFormals f)) = (
	PPProcedureSpecification{name=id,formal_part=f,spec=Nil}
) | red_procedure_specification3 _ _ _ = stack_error "red_procedure_specification3";

fun red_procedure_specification4 _ (Token ((_,CNText id), _)) (Parsed (PPFormals f)) (Parsed(PPStmt(SpecNoIvars s))) = (
	PPProcedureSpecification{name=id,formal_part=f,spec=Value s}
) | red_procedure_specification4 _ _ _ _= stack_error "red_procedure_specification4";

fun red_function_specification1 _ (Parsed (PPId des)) _ (Token ((_,CNText name), _)) = (
	PPFunctionSpecification{designator=des, return=name,formal_part=[],spec=Nil}
) | red_function_specification1 _ _ _ _ = stack_error "red_function_specification1";

fun red_function_specification2 _ (Token ((_,CNText des), _)) _ (Token ((_,CNText name), _)) (Parsed(PPStmt(SpecNoIvars s))) = (
	PPFunctionSpecification{designator=des, return=name,formal_part=[],spec=Value s}
) | red_function_specification2 _ _ _ _ _ = stack_error "red_function_specification2";

fun red_function_specification3 _ (Parsed (PPId des)) (Parsed(PPFormals f)) _ (Token ((_,CNText name), _)) = (
	PPFunctionSpecification{designator=des, return=name,formal_part=f,spec=Nil}
) | red_function_specification3 _ _ _ _ _ = stack_error "red_function_specification3";

fun red_function_specification4 _ (Parsed (PPId des)) (Parsed(PPFormals f)) _ (Token ((_,CNText name), _)) (Parsed(PPStmt(SpecNoIvars s))) = (
	PPFunctionSpecification{designator=des, return=name,formal_part=f,spec=Value s}
) | red_function_specification4 _ _ _ _ _ _ = stack_error "red_function_specification4";
=TEX
SPARK manual 6.1:
=SML
fun red_designator (Token((_,CNText des), _)) = (
	PPId des
) | red_designator _ = stack_error "red_designator";

fun red_operator_symbol (Token((StringLiteral,CNString opsym), _)) = (
	PPId opsym
) | red_operator_symbol _ = stack_error "red_operator_symbol";

fun red_formal_part _ (Parsed p) _ = (p
) | red_formal_part _ _ _ = stack_error "red_formal_part";

val red_parlist1 = red_accept;

fun red_parlist2 (Parsed (PPFormals f1)) _ (Parsed(PPFormals f2)) = (
	PPFormals (f1@f2)
) | red_parlist2 _ _ _ = stack_error "red_parlist2";

fun red_parameter_specification (Parsed(PPIds ids)) _ (Parsed(PPMode m)) (Token ((_,CNText name), _)) = (
	PPFormals[{idlist=ids,mode=m,name=name}]
) | red_parameter_specification _ _ _ _ = stack_error "red_parameter_specification";
;
val red_mode1 = PPMode SparkIn;
fun red_mode2 _ = PPMode SparkIn;
fun red_mode3 _ = PPMode SparkOut;
fun red_mode4 _ _ = PPMode SparkInOut;
=TEX
SPARK manual 6.3:
=SML
fun red_subprogram_body1 (Parsed (PPProcedureSpecification ps)) _ (Parsed (PPSubprogram (d, s))) = (
	PPProperBody (PBProcedure {procedure_spec=ps,declarative_part=d,statement=Stmt s})
) | red_subprogram_body1 _ _ _ = stack_error "red_subprogram_body1";

fun red_subprogram_body2 (Parsed (PPFunctionSpecification fs)) _ (Parsed (PPSubprogram (d, s))) = (
	PPProperBody (PBFunction {function_spec=fs,declarative_part=d,statement=Stmt s})
) | red_subprogram_body2 _ _ _ = stack_error "red_subprogram_body2";

fun red_subprogram_implementation (Parsed(PPDeclarations d)) _ (Parsed(PPStmt s)) _ _ _ = (
	PPSubprogram (d, s)
) | red_subprogram_implementation _ _ _ _ _ _ = stack_error "red_subprogram_implementation";
=TEX
=SML
fun red_procedure_call_statement (Parsed p) _ = (
	p
) | red_procedure_call_statement _ _ = stack_error "red_procedure_call_statement";

fun red_actual_parameter_part _ (Parsed p) _ = (
	p
) | red_actual_parameter_part _ _ _ = stack_error "red_actual_parameter_part";

fun red_parameter_association1 (Parsed(PPAgg{tm=tm,named_assocs=na,others=ot})) = (
	case ot of
	Value oe => PPExp (ArrayAggNamedOthers{tmark="__parameter_association",agg_named={named_assocs=na},others={others=oe}})
	|Nil => PPExp (ArrayAggNamed{named_assocs=na})
) | red_parameter_association1 _ = stack_error "red_parameter_association1";

fun red_parameter_association2 (Parsed(PPExps es)) = (
	PPExp(ArrayAggPos{tmark="__parameter_association",comps = es})
) | red_parameter_association2 _ = stack_error "red_parameter_association2";

fun red_positional_parameter_association1 (Parsed(PPExp a)) = (
	PPExps [a]
) | red_positional_parameter_association1 _ = stack_error "red_positional_parameter_association1";

fun red_positional_parameter_association2 (Parsed(PPExp a)) _ (Parsed(PPExps es)) = (
	PPExps (a::es)
) | red_positional_parameter_association2  _ _ _ = stack_error "red_positional_parameter_association2";
=TEX
=SML
val red_actual_parameter = red_accept;
=TEX
SPARK manual 7.1:
=SML
fun red_package_declaration (Parsed p) _ = (p
) | red_package_declaration _ _ = stack_error "red_package_declaration";

fun red_package_specification1 _ (Token ((_,CNText id), _)) _ (Parsed(PPDeclarations v)) _ _ = (
	PPPackageSpecification {name=id,visible_decs=v,private_decs=[]}
) | red_package_specification1 _ _ _ _ _ _ = stack_error "red_package_specification1";

fun red_package_specification2 _ (Token ((_,CNText id), _)) _ (Parsed(PPDeclarations v)) _  (Parsed(PPDeclarations p)) _ _ = (
	PPPackageSpecification {name=id,visible_decs=v,private_decs=p}

) | red_package_specification2 _ _ _ _ _ _ _ _ = stack_error "red_package_specification2";
val red_visible_part1 = red_accept;

fun red_visible_part2 (Parsed (PPDeclarations d1)) (Parsed (PPDeclarations d2)) = ( 
	PPDeclarations (d1@d2)
) | red_visible_part2 _ _ = stack_error "red_visible_part2";

=TEX
SPARK manual 7.1:
=SML
fun red_visdec1 (Parsed (PPKSlot k)) = (
	PPDeclarations [DDeclarationKSlot k]
) | red_visdec1 _ = stack_error "red_visdec1";

val red_visdec2 = red_accept;

val red_visdec3 = red_accept;

val red_private_part1 = red_accept;

fun red_private_part2 (Parsed (PPDeclarations d1)) (Parsed (PPDeclarations d2)) = (
	PPDeclarations (d1@d2)
) | red_private_part2 _ _ = stack_error "red_private_part2";

fun red_pdec1 (Parsed (PPKSlot k)) = (
	PPDeclarations [DDeclarationKSlot k]
) | red_pdec1 _ = stack_error "red_pdec1";

val red_pdec2 = red_accept;
=TEX
=SML
fun red_package_body _ _ (Token ((_,CNText id), _)) _ (Parsed(PPSubprogram (d,s))) _ _ _ = (
	PPProperBody(PBPackage{name=id,decls=d,statement=Stmt s})
) | red_package_body _ _ _ _ _ _ _ _ = stack_error "red_package_body";

fun red_package_implementation1 (Parsed (PPDeclarations d)) = (
	PPSubprogram (d, Null)
) | red_package_implementation1 _ = stack_error "red_package_implementation1";

fun red_package_implementation2 (Parsed (PPDeclarations d)) _ (Parsed(PPStmt s)) = (
	PPSubprogram (d, s)
) | red_package_implementation2 _ _ _ = stack_error "red_package_implementation2";

val red_package_initialization = red_accept;
=TEX
SPARK manual 7.4:
=SML
fun red_private_type_declaration1 _ (Token ((_,CNText id), _)) _ _ _ = (
	PPtbs
) | red_private_type_declaration1 _ _ _ _ _ = stack_error "red_private_type_declaration1";

fun red_private_type_declaration2 _ (Token ((_,CNText id), _)) _ _ _ _ = (
	PPtbs
) | red_private_type_declaration2 _ _ _ _ _ _ = stack_error "red_private_type_declaration2";

fun red_deferred_constant_declaration x1 x2 x3 x4 x5 = PPtbs;

fun red_renaming_declaration1 _ (Parsed (PPId opsym1)) (Parsed(PPFormals f)) _ (Parsed(PPExp n)) _ (Token ((_,CNText id), _)) _ (Parsed (PPId opsym2)) _ = (
	PPRenamingDeclaration(FunctionRenaming{opsym1=opsym1,formal_part=f,tmark=name_to_tmark n,name=id,opsym2=opsym2})
) | red_renaming_declaration1 _ _ _ _ _ _ _ _ _ _ = stack_error "red_renaming_declaration1";

fun red_renaming_declaration2 (Parsed (PPSubprogramSpec ss)) _ (Token ((_,CNText id1), _)) _ (Token ((_,CNText id2), _)) _ = (
	PPRenamingDeclaration(SubprogramRenaming{subprogram_specification=ss,name1=id1,name2=id2})
) | red_renaming_declaration2 _ _ _ _ _ _ = stack_error "red_renaming_declaration21";

=TEX
=SML
fun red_compilation1 (Parsed (PPKSlot k)) = (
	PPKSlotCUList [CompKSlot k]
) | red_compilation1 _ = stack_error "red_compilation1";

fun red_compilation2 (Parsed (PPCompilationUnit (ids,c))) = (
	PPKSlotCUList [CompUnit {context=ids, comp_unit=c}]
) | red_compilation2 _ = stack_error "red_compilation2";

fun red_compilation3 (Parsed (PPCompilationUnit (ids,c))) (Parsed (PPKSlotCUList cl)) = (
	PPKSlotCUList ((CompUnit {context=ids, comp_unit=c})::cl)
) | red_compilation3 _ _ = stack_error "red_compilation3";
=TEX
=SML
fun red_compilation_unit (Parsed(PPIds ids)) (Parsed (PPCompilationUnit ([],c))) = (
	PPCompilationUnit (ids, c)
) | red_compilation_unit _ _ = stack_error "red_compilation_unit";

val red_compilation_unit1 = red_compilation_unit;
val red_compilation_unit2 = red_compilation_unit;
=TEX
=SML
fun red_library_unit1 (Parsed(PPDeclarations [DPackageDeclaration p])) = (
	PPCompilationUnit ([], CUPackageDeclaration p)
) | red_library_unit1 _ = stack_error "red_library_unit1";

fun red_library_unit2 (Parsed(PPProperBody p)) = (
	PPCompilationUnit ([], CUProperBody p)
) | red_library_unit2 _ = stack_error "red_library_unit2";

=TEX

SPARK manual 10.1:
=SML
val red_secondary_unit1 = red_accept;
val red_secondary_unit2 = red_accept;
val red_library_unit_body = red_accept;
val red_main_program = red_accept;
=TEX

SPARK manual 10.1.1:
=SML
val red_context_clause1 = PPIds [];
val red_context_clause2 = red_accept;

fun red_with_clause _ (Parsed (PPIds ids)) _ = (
	 PPIds ids
) | red_with_clause _ _ _ = stack_error "red_with_clause";
=TEX
SPARK manual 10.2:
=SML
fun red_body_stub1 (Parsed p) _ _ _ = (
	p
) | red_body_stub1 _ _ _ _ = stack_error "red_body_stub1";

fun red_body_stub2 (Parsed p) _ _ _ = (
	p
) | red_body_stub2 _ _ _ _ = stack_error "red_body_stub2";

fun red_body_stub3 _ _ (Parsed p) _ _ _ = (
	p
) | red_body_stub3 _ _ _ _ _ _ = stack_error "red_body_stub3";

fun red_subunit _ _ (Token ((_,CNText id), _)) _ (Parsed (PPProperBody p)) = (
	PPCompilationUnit([], CUSubUnit{id=id, proper_body=p})
) | red_subunit _ _ _ _ _ = stack_error "red_subunit";
=TEX
=SML
val red_representation_clause1 = red_accept;

val red_representation_clause2 = red_accept;

val red_type_representation_clause1 = red_accept;
val red_type_representation_clause2 = red_accept;
val red_type_representation_clause3 = red_accept;

fun red_length_clause _ (Parsed(PPExp a)) _ (Parsed(PPExp e)) _ = (
	PPRepresentationClause(LengthClause{attribute=a, exp=e})
) | red_length_clause _ _ _ _ _ = stack_error "red_length_clause";
=TEX
SPARK manual 13.3:
=SML
fun red_enumeration_representation_clause _ (Token ((_,CNText id), _)) _ (Parsed(PPExp e)) _ = (
	PPRepresentationClause(EnumerationRepresentationClause{name=id, exp=e})
) | red_enumeration_representation_clause _ _ _ _ _ = stack_error "red_enumeration_representation_clause";
=TEX
SPARK manual 13.4:
=SML
fun red_record_representation_clause _ (Token ((_,CNText id), _)) _ _ (Parsed(PPExps [e])) (Parsed(PPComponentClauses c)) _ _ _ = (
	PPRepresentationClause(RecordRepresentationClause{name=id,alignment_opt=Value e,component_pack=c})
) | red_record_representation_clause _ (Token ((_,CNText id), _)) _ _ (Parsed(PPExps [])) (Parsed(PPComponentClauses c)) _ _ _ = (
	PPRepresentationClause(RecordRepresentationClause{name=id,alignment_opt=Nil,component_pack=c})
) | red_record_representation_clause _ _ _ _ _ _ _ _ _ = stack_error "red_record_representation_clause";

=TEX
SPARK manual 13.4:
=SML
val red_alignment_opt1 = PPExps [];
fun red_alignment_opt2 _ _ (Parsed(PPExp e)) _ = (
	PPExps [e]
) | red_alignment_opt2 _ _ _ _ = stack_error "red_alignment_opt2";

val red_component_pack1 = red_accept;

fun red_component_pack2 (Parsed(PPComponentClauses [c])) (Parsed(PPComponentClauses cs)) = (
	PPComponentClauses (c::cs)
) | red_component_pack2 _ _ = stack_error "red_component_pack2";
=TEX
SPARK manual 13.4:
=SML
fun red_component_clause (Parsed(PPExp n)) _ (Parsed(PPExp e)) _ (Parsed(PPSRExpression (e1,v))) _ = (
	case v of
	Value e2 => PPComponentClauses[{exp=e, range=AggChoiceRange {lo=e1,hi=e2}}]
	|Nil => PPComponentClauses[{exp=e, range=AggChoiceSingle e1}]
) | red_component_clause _ _ _ _ _ _ = stack_error "red_component_clause";
=TEX

SPARK manual 13.5:
=SML
fun red_address_clause _ (Token ((_,CNText id), _)) _ _ (Parsed (PPExp exp)) _ = (
	PPRepresentationClause(AddressClause {name=id, exp=exp})
) | red_address_clause _ _ _ _ _ _ = stack_error "red_address_clause";
=TEX
=SML
end (* of structure *);
=TEX

\section{PARSER}\label{PARSER}
=SML
structure €CNParser› : CNParser = struct
=TEX
=SML
=TEX
We can now load the code generated by SLRP from the grammar
of 'cite{ISS/HAT/DAZ/DTD503}'.
=SML
local
	open CNParser;
=TEX
=INCLUDE
dtd503.grm.sml
=IGN
fun slrp'gen_parser x1 x2 x3 x4 = fn _ => 
=SML
in
=TEX
\subsection{Reader Function}\lab
=TEX
\subsection{Interface}
=TEX
=SML
fun €cn_reader› (ip : CN_LEX_ITEM list) : CN_LEX_ITEM * (CN_LEX_ITEM list) = (
	case ip of
		(h :: more) => (cur_tok := !cur_tok + 1; (h, more))
	|	[] => ((LCEos, CNEos), [])
);
=TEX
=SML
val €cn_error› : (CN_LEX_ITEM, 'b, 'c, 'd) ERROR_ROUTINE = (fn (tok, stk, _, _) => (
	parse_error_hdr();
	diag_string (get_error_message 19003 [format_lex_item tok,
				format_stack format_lex_item stk]);
	raise SYNTAX_ERROR
));
=TEX
The following is adapted from the HOL parser in \cite{ISS/HAT/DAZ/IMP019} q.v.
for explanation.
=SML
fun €cn_parser› (ip : CN_LEX_ITEM list) : WEB_CLAUSE  = (
	let	val se1 = (input_toks := ip; cur_tok := ~1);
		val res = (slrp'gen_parser
				default_resolver
				fst
				cn_error
				cn_reader) ip;
		val se2 = (input_toks := []);
	in	case res of
		PPWebClause wc => wc
		|_ => fail "cn_parser" 503001 []
	end
);
=TEX
=TEX
\section{EPILOGUE}
=SML
end (* of local ... in *);
end (* of structure CNParser *);
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}

