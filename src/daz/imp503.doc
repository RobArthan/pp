% imp503.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of the Compliance Notation Parser}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP503}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the CN 
parser.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue \SCCSversion, \FormatDate{$Date$%
} ] Initial Draft.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the parser for
HOL/Z.
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD503}.
\subsection{Introduction}

\subsection{Purpose and Background}

\subsection{Algorithms}



\subsection{Dependencies}

\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX
\section{MISCELLANEOUS FUNCTIONS}\label{MISCELLANEOUSFUNCTIONS}
=SML
structure €CNParser› = struct
=TEX
We need to include the SLRP driver code at this point:
=INCLUDE
imp018.sml
=TEX
=SML
open CNTypes;
open SlrpDriver;
=TEX
\subsection{Miscellanea}
$stack\_error$ is for use during context-free parsing when the parsing stack
is corrupt.
=SML
fun €stack_error› (insert : string) : 'a = (
	diag_string("Internal error in CN-Parser");
	BasicError.error "CN-Parser"  19005 [fn() => insert]
);
=TEX
To give error reports which are closely related to the actual input,
the following two variables are set up by the functions
$HOL\_parser$ and $HOL\_reader$. At any time during parsing $input\_toks$
can be expected to contain the totality of the token stream being parsed
and $toks\_read$ contains the offset in it of the token most recently
read (or is =INLINEFT
~1
=TEX
\ if nothing has been read yet).
=SML
val input_toks : CN_LEX_ITEM list ref = ref [];
val cur_tok : int ref = ref ~1;
=TEX
=SML
fun €format_lex_item›  ((_, tok) : CN_LEX_ITEM) : string = (
	case tok of
		CNZ _	=> " <z> "
	|	CNText s	=> s
	|	CNString s	=> s
	|	CNKSlot s	=> "K-Slot"
	|	CNEos		=> "<end-of-input>"
);
=TEX
=SML
fun €parse_error_hdr› () : unit = (
	let	val ok_toks =	format_list
				format_lex_item 
				((!input_toks) to (!cur_tok-1))
				" ";
		val bad_tok =	if !cur_tok >= 0 andalso !cur_tok < length (!input_toks)
				then " <?> " ^ format_lex_item (nth (!cur_tok) (!input_toks))
				else "";
	in	diag_string (get_error_message 19001 [ok_toks ^ bad_tok])
	end
);
=TEX
The following function produces the error reports for the unexpected
token type of error:
=TEX
=SML
fun €parse_error› (msg : int) (insert : string) : 'a = (
	parse_error_hdr();
	diag_string (get_error_message msg [insert]);
	raise SYNTAX_ERROR
);
=TEX
=SML
end (* of structure *);
=TEX

\section{REDUCTION FUNCTIONS}\label{REDUCTIONFUNCTIONS}
=SML
structure €CNParser› = struct
=TEX
=SML
open CNParser;
=TEX
We give the reduction functions in the order of their appearance
in the grammar of 'cite{ISS/HAT/DAZ/DTD503}'. When several reduction
functions would be the same, we use $val$ bindings for the various
instances.

=SML
datatype €PPARSED› =
			PPBinaryOp of BIN_OP
		|	PPCompilationUnit of (ID list * COMPILATION_UNIT)
		|	PPComponentClauses of COMPONENT_CLAUSE list
		|	PPDeclarations of DECLARATION list
		|	PPElsIf of (EXP * STATEMENT) list
		|	PPExp of EXP
		|	PPExps of EXP list
		|	PPFormals of PARAMETER_SPECIFICATION list
		|	PPFunctionSpecification of FUNCTION_SPECIFICATION
		|	PPId of ID
		|	PPIdExp of (ID * EXP)
		|	PPIds of ID list
		|	PPKSlot of K_SLOT
		|	PPKSlotCUList of KSLOT_COMPILATION_UNIT list
		|	PPMode of MODE
		|	PPPackageSpecification of PACKAGE_DECLARATION
		|	PPPrimedIdentifier of (ID * ID)
		|	PPProcedureSpecification of PROCEDURE_SPECIFICATION
		|	PPProperBody of PROPER_BODY
		|	PPRange of EXP RANGE
		|	PPReltail of (BIN_OP * EXP)
		|	PPRepresentationClause of REPRESENTATION_CLAUSE
		|	PPSpecNoIvars of SPEC_NO_IVARS
		|	PPStatement of STATEMENT
		|	PPSubprogram of (DECLARATION list * STATEMENT)
		|	PPUnaryOp of UNARY_OP
		|	PPWebClause of WEB_CLAUSE
		|	PPZ of Z_EXP
		|	PPtbs;
=TEX
=SML
fun red_accept (Parsed pp) = (pp
) | red_accept (Token ((l,CNText t),_)) = (
	stack_error ("red_accept [Token("
		^(PolyML.makestring l)^", Text "^(PolyML.makestring t)^")]")
) | red_accept (Token ((l,t),_)) = (
	stack_error ("red_accept ["
		^(PolyML.makestring l)^", "^(PolyML.makestring t)^"]")
);
=TEX
=SML
fun red_web_clause1 (Parsed (PPKSlotCUList cul)) = (
	PPWebClause (Compilation cul)
) | red_web_clause1 _ = stack_error "red_web_clause1";

fun red_web_clause2 (Token ((_, CNText lab), _)) _ (Parsed (PPKSlotCUList cul)) = (
	PPWebClause (ReplacedByCompilation {label=lab,comp=cul})
) | red_web_clause2 _ _ _ = stack_error "red_web_clause2";

fun red_web_clause3 (Token ((_,CNText lab), _)) _ (Parsed (PPDeclarations d)) = (
	PPWebClause (ReplacedByPrivatePart {label=lab, private=d})
) | red_web_clause3 _ _ _ = stack_error "red_web_clause3";

fun red_web_clause4 (Token ((_,CNText lab), _)) _ (Parsed (PPDeclarations d)) = (
	PPWebClause (ReplacedByVisiblePart {label=lab, visible=d})
) | red_web_clause4 _ _ _ = stack_error "red_web_clause4";

fun red_web_clause5 (Token ((_,CNText lab), _)) _ (Parsed (PPDeclarations d)) = (
	PPWebClause (ReplacedByDecl {label=lab, decls=d})
) | red_web_clause5 _ _ _ = stack_error "red_web_clause5";

fun red_web_clause6 (Token ((_,CNText lab), _)) _ (Parsed (PPStatement s)) = (
	PPWebClause (ReplacedBy {label=lab, statement=s})
) | red_web_clause6 _ _ _ = stack_error "red_web_clause6";

fun red_web_clause7 (Token ((_,CNText lab), _)) _ (Parsed (PPStatement s)) = (
	PPWebClause (RefinedBy {label=lab, statement=s})
) | red_web_clause7 _ _ _ = stack_error "red_web_clause7";

fun red_web_clause8 _ (Parsed (PPStatement s)) = (
	PPWebClause (RefinedBy {label="*", statement=s})
) | red_web_clause8 _ _ = stack_error "red_web_clause8";

fun red_web_clause9 (Token ((_,CNText lab), _)) _ (Parsed (PPStatement s)) = (
	PPWebClause (ReplacedBy {label=lab, statement=s})
) | red_web_clause9 _ _ _ = stack_error "red_web_clause9";

fun red_web_clause10  _ (Parsed (PPStatement s)) = (
	PPWebClause (ReplacedBy {label="*", statement=s})
) | red_web_clause10 _ _ = stack_error "red_web_clause10";
=TEX
=SML
val red_basic_declaration1 = red_accept;
val red_basic_declaration2 = red_accept;
val red_basic_declaration3 = red_accept;
val red_basic_declaration4 = red_accept;
val red_object_declaration1 = red_accept;
val red_object_declaration2 = red_accept;
=TEX
=SML
fun red_constant_declaration x1 x2 x3 x4 x5 x6 x7 = PPtbs;
fun red_variable_declaration x1 x2 x3 x4 = PPtbs;

fun red_identifier_list1 (Token ((_,CNText id), _)) = (
	PPIds [id]
) | red_identifier_list1 _ = stack_error "red_identifier_list1";

fun red_identifier_list2 (Token ((_,CNText id), _)) _ (Parsed(PPIds ids)) = (
	PPIds (id::ids)
) | red_identifier_list2 _ _ _ = stack_error "red_identifier_list2";
=TEX
=SML
val red_type_declaration1 = red_accept;
val red_type_declaration2 = red_accept;
=TEX
=SML
fun red_full_type_declaration1 x1 x2 x3 x4 x5 x6 = PPtbs;
fun red_full_type_declaration2 x1 x2 x3 x4 x5 = PPtbs;
=TEX
=SML
val red_type_definition1 = red_accept;
val red_type_definition2 = red_accept;
val red_type_definition3 = red_accept;
val red_type_definition4 = red_accept;
val red_type_definition5 = red_accept;
=TEX
=SML
fun red_subtype_declaration x1 x2 x3 x4 x5 = PPtbs;
fun red_subtype_indication x1 x2 = PPtbs;
=TEX
=SML
val red_constraint1 = red_accept;
val red_constraint2 = red_accept;
val red_constraint3 = red_accept;
=TEX
=SML
fun red_range_constraint x1 x2 = PPtbs;
fun red_enumeration_type_definition x1 x2 x3 = PPtbs;
=TEX
=SML
val red_integer_type_definition = red_accept;
val red_real_type_definition1 = red_accept;
val red_real_type_definition2 = red_accept;
val red_floating_point_constraint1 = red_accept;
=TEX
=SML
fun red_floating_point_constraint2 x1 x2 = PPtbs;
fun red_floating_accuracy_definition x1 x2 = PPtbs;
=TEX
=SML
val red_fixed_point_constraint1 = red_accept;
=TEX
=SML
fun red_fixed_point_constraint2 x1 x2 = PPtbs;
fun red_fixed_accuracy_definition x1 x2 = PPtbs;
=TEX
=SML
val red_array_type_definition1 = red_accept;
val red_array_type_definition2 = red_accept;
=TEX
=SML
fun red_unconstrained_array_definition x1 x2 x3 x4 x5 x6 = PPtbs;
fun red_constrained_array_definition x1 x2 x3 x4 = PPtbs;
=TEX
=SML
val red_index_subtype_definition_list1 = red_accept;
=TEX
=SML
fun red_index_subtype_definition_list2 x1 x2 x3 = PPtbs;
fun red_index_subtype_definition x1 x2 x3 = PPtbs;
fun red_index_constraint x1 x2 x3 = PPtbs;
fun red_name_list1 x1 = PPtbs;
fun red_name_list2 x1 x2 x3 = PPtbs;
fun red_discrete_range1 x1 x2 = PPtbs;
fun red_discrete_range2 x1 = PPtbs;
fun red_record_type_definition x1 x2 x3 x4 = PPtbs;
=TEX
=SML
val red_component_list1 = red_accept;
val red_component_list2 = red_accept;
=TEX
=SML
fun red_component_list3 x1 x2 = PPtbs;
fun red_component_list4 (Token ((LCNull,_), _)) = (
	PPStatement (Stmt Null)
) | red_component_list4 _ = stack_error "red_component_list4";
fun red_component_declaration_list1 x1 = PPtbs;
fun red_component_declaration_list2 x1 x2 = PPtbs;
fun red_component_declaration x1 x2 x3 x4 = PPtbs;
fun red_discriminant_part x1 x2 x3 = PPtbs;
fun red_variant_part x1 x2 x3 x4 x5 x6 x7 = PPtbs;
fun red_variant_list1 x1 = PPtbs;
fun red_variant_list2 x1 x2 = PPtbs;
fun red_variant x1 x2 x3 x4 = PPtbs;
fun red_variant_choice_list1 (Token ((_,CNText id), _)) = (
	PPIds [id]
) | red_variant_choice_list1 _ = stack_error "red_variant_choice_list1";

fun red_variant_choice_list2 (Token ((_,CNText id), _)) _ (Parsed(PPIds ids)) = (
	PPIds (id::ids)
) | red_variant_choice_list2 _ _ _ = stack_error "red_variant_choice_list2";
=TEX
SPARK manual 3.9:
=TEX
=SML
val red_declarative_part1 = red_accept;

fun red_declarative_part2 (Parsed (PPDeclarations d1)) (Parsed (PPDeclarations d2)) = (
	PPDeclarations (d1@d2)
) | red_declarative_part2 _ _ = stack_error "red_declarative_part2";
=TEX
=SML
fun red_dec1 (Parsed(PPKSlot k)) = (
	PPDeclarations [DDeclarationKSlot k]
) | red_dec1 _ = stack_error "red_dec1";

val red_dec2 = red_accept;
val red_dec3 = red_accept;
val red_dec4 = red_accept;
val red_dec5 = red_accept;
=TEX
=SML
fun red_basic_declarative_item1 _ = PPDeclarations [];
fun red_basic_declarative_item2 _ = PPDeclarations [];
val red_body1 = red_accept;
val red_body2 = red_accept;
val red_proper_body1 = red_accept;
val red_proper_body2 = red_accept;
=TEX
=SML
fun red_name1 (Token ((_,CNText name), _)) = (
	PPExp(Id name)
) | red_name1 _ = stack_error "red_name1";

val red_name2 = red_accept;
val red_name3 = red_accept;
val red_name4 = red_accept;
=TEX
=SML
fun red_indexed_component x1 x2 = PPtbs;
=TEX
SPARK manual 4.1.3:
=SML
fun red_selected_component x1 x2 x3 = PPtbs;

fun red_selector (Token ((_,CNText id), _)) = (
	PPId id
) | red_selector _ = stack_error "red_selector";

fun red_expression_list1 (Parsed(PPExp e)) = (
	PPExps [e]
) | red_expression_list1 _ = stack_error "red_expression_list1";

fun red_expression_list2 (Parsed(PPExp e)) _ (Parsed(PPExps es)) = (
	PPExps (e::es)
) | red_expression_list2 _ _ _ = stack_error "red_expression_list2";
=TEX
tbs the correct handling of character literals
=SML
fun red_attribute1 x1 x2 = PPtbs;
fun red_attribute2 (Token ((CharacterLiteral,CNText id), _)) (Token ((_,CNText primedid), _)) = (
	PPPrimedIdentifier(id, primedid)
) | red_attribute2 _ _ = stack_error "red_attribute2";


fun red_aggregate x1 x2 x3 = PPtbs;
=TEX
=SML
val red_component_association1 = red_accept;
val red_component_association2 = red_accept;
=TEX
=SML
fun red_named_association1 x1 x2 x3 = PPtbs;
fun red_named_association2 x1 x2 x3 x4 x5 = PPtbs;
fun red_aggregate_choice_list1 x1 = PPtbs;
fun red_aggregate_choice_list2 x1 = PPtbs;
fun red_aggregate_choice_list3 x1 x2 x3 = PPtbs;
=TEX
=SML
val red_aggregate_choice = red_accept;
val red_positional_association = red_accept;
=TEX
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
=SML
val red_expression1 = red_accept;

fun red_expr (Parsed (PPExp exp1)) (Parsed (PPReltail(binop, exp2))) = (
	PPExp (BinExp {Op = binop, left = exp1, right = exp2})
) | red_expr _ _ = stack_error "red_expr";

val red_expression2 = red_expr;
val red_expression3 = red_expr;
val red_expression4 = red_expr;
val red_expression5 = red_expr;
val red_expression6 = red_expr;
=TEX
=SML
fun red_logrel1 binop (Parsed(PPExp exp)) = (
	PPReltail(binop, exp)
) | red_logrel1 _ _ = stack_error "red_logrel1";

fun red_logrel2 binop (Parsed(PPExp exp1)) (Parsed(PPReltail(_,exp2))) = (
	PPReltail(binop, BinExp{Op=binop, left=exp1, right=exp2})
) | red_logrel2 _ _ _ = stack_error "red_logrel2";

fun red_and_relation1 _ x2 =		(red_logrel1 SparkAnd x2);
fun red_and_relation2 _ x2 x3 =		(red_logrel2 SparkAnd x2 x3);
fun red_and_then_relation1 _ _ x3 =	(red_logrel1 SparkAndThen x3);
fun red_and_then_relation2 _ _ x3 x4 =	(red_logrel2 SparkAndThen x3 x4);
fun red_or_relation1 _ x2 =		(red_logrel1 SparkOr x2);
fun red_or_relation2 _ x2 x3 =		(red_logrel2 SparkOr x2 x3);
fun red_or_else_relation1 _ _ x3 =	(red_logrel1 SparkOrElse x3);
fun red_or_else_relation2 _ _ x3 x4 =	(red_logrel2 SparkOrElse x3 x4);
fun red_xor_relation1 _ x2 =		(red_logrel1 SparkXor x2);
fun red_xor_relation2 _ x2 x3 =		(red_logrel2 SparkXor x2 x3);
=TEX
=SML
fun red_relation1 x1 = PPtbs;
fun red_relation2 x1 x2 x3 = PPtbs;
fun red_relation3 x1 x2 x3 = PPtbs;
fun red_relation4 x1 x2 x3 x4 = PPtbs;
fun red_sr_expression1 x1 = PPtbs;
fun red_sr_expression2 x1 x2 x3 = PPtbs;
fun red_simple_expression1 x1 x2 = PPtbs;
fun red_simple_expression2 x1 x2 x3 = PPtbs;
val red_binoptail1 = PPtbs;
fun red_binoptail2 x1 x2 x3 = PPtbs;
fun red_term1 x1 = PPtbs;
fun red_term2 x1 x2 x3 = PPtbs;
fun red_factor1 x1 = PPtbs;
fun red_factor2 x1 x2 x3 = PPtbs;
fun red_factor3 x1 x2 = PPtbs;
fun red_factor4 x1 x2 = PPtbs;
=TEX
=SML
fun red_primary1 (Token ((LCNumericLiteral,CNText n), _)) = (
	PPExp (Int n)
) | red_primary1 _ = stack_error "red_primary1";

(* tbs character literal missing in AS *)
fun red_primary2 (Token ((LCCharacterLiteral,CNText n), _)) = (
	PPExp (Id n)
) | red_primary2 _ = stack_error "red_primary2";

(* tbs string literal missing in AS *)
fun red_primary3 (Token ((LCStringLiteral,CNText n), _)) = (
	PPExp (Id n)
) | red_primary3 _ = stack_error "red_primary3";

fun red_primary4 x1 = PPtbs;
fun red_primary5 x1 = PPtbs;
fun red_primary6 x1 x2 x3 = PPtbs;
fun red_primary7 (Parsed(PPZ z)) = (
	PPExp (AuxiliaryExp ¨trueÆ)
) | red_primary7 _ = stack_error "red_primary7";
=TEX
=SML
fun red_relational_operator1 _ = PPBinaryOp SparkEq;
fun red_relational_operator2 _ = PPBinaryOp SparkNotEq;
fun red_relational_operator3 x1 = PPBinaryOp SparkLess;
fun red_relational_operator4 x1 = PPBinaryOp SparkLessEq;
fun red_relational_operator5 x1 = PPBinaryOp SparkGreater;
fun red_relational_operator6 x1 = PPBinaryOp SparkGreaterEq;
fun red_binary_adding_operator1 x1 = PPBinaryOp SparkAdd;
fun red_binary_adding_operator2 x1 = PPBinaryOp SparkMinus;
=TEX
tbs - ampersand missing from AS
=SML
fun red_binary_adding_operator3 x1 = PPBinaryOp SparkAdd;
fun red_unary_adding_operator1 x1 = PPUnaryOp SparkUnaryAdd;
fun red_unary_adding_operator2 x1 = PPUnaryOp SparkUnaryMinus;
fun red_multiplying_operator1 x1 = PPBinaryOp SparkTimes;
fun red_multiplying_operator2 x1 = PPBinaryOp SparkIntdiv;
fun red_multiplying_operator3 x1 = PPBinaryOp SparkMod;
fun red_multiplying_operator4 x1 = PPBinaryOp SparkRem;
=TEX
tbs - AS has abs, but mem, nonmem and starstar can't be produced from the concrete syntax
=SML
fun red_qualified_expression x1 x2 x3 = PPtbs;
fun red_sequence_of_statements1 _ = PPStatement (Stmt Null);
fun red_sequence_of_statements2 _ _ = PPStatement (Stmt Null);
fun red_statement1 x1 = PPtbs;
fun red_statement2 x1 = PPtbs;
fun red_statement3 x1 x2 x3 x4 = PPtbs;
fun red_statement4 x1 = PPtbs;
fun red_statement5 x1 = PPtbs;
=TEX

=SML
fun red_specification_statement1 _ (Token ((LCZ,CNZ z1), _)) _ (Token ((LCZ,CNZ z2), _)) _ = (
	PPSpecNoIvars{w=["<Z_ID stubs>"],w0=["<Stub>"],pre=¨trueÆ,post=¨postÆ}
) | red_specification_statement1 _ _ _ _ _ = stack_error "red_specification_statement1";

fun red_specification_statement2 _ (Token ((LCZ,CNZ z1), _)) _ (Token ((LCZ,CNZ z2), _)) _ = (
	PPSpecNoIvars{w=["<Z_ID stubs>"],w0=["<Stub>"],pre=¨preÆ,post=¨trueÆ}
) | red_specification_statement2 _ _ _ _ _ = stack_error "red_specification_statement2";

fun red_specification_statement3 _ (Token ((LCZ,CNZ z1), _)) _ (Token ((LCZ,CNZ z2), _)) _ (Parsed(PPIds [lab]))= (
	PPSpecNoIvars{w=["<Z_ID stubs>"],w0=["<Stub>"],pre=¨trueÆ,post=¨trueÆ}
) | red_specification_statement3 _ _ _ _ _ _ = stack_error "red_specification_statement3";

fun red_specification_statement4 _ (Token ((LCZ,CNZ z1), _)) _ (Token ((LCZ,CNZ z2), _)) _ (Parsed(PPIds [lab]))= (
	PPSpecNoIvars{w=["<Z_ID stubs>"],w0=["<Stub>"],pre=¨trueÆ,post=¨trueÆ}
) | red_specification_statement4 _ _ _ _ _ _ = stack_error "red_specification_statement4";
=TEX
=SML
fun red_label _ (Token ((LCNumericLiteral,CNText n), _)) _ = (
	PPIds["("^n^")"]
) | red_label _ _ _ = stack_error "red_label";

fun red_k_slot1 _ = PPKSlot{content="<K-slot>", label="*"}
  | red_k_slot1 _ = stack_error "red_k_slot1";

fun red_k_slot2 _ (Parsed(PPIds [lab])) = PPKSlot{content="<K-slot>", label=lab}
  | red_k_slot2 _ _ = stack_error "red_k_slot2";
=TEX
=SML
val red_simple_statement1 = red_accept;
val red_simple_statement2 = red_accept;
val red_simple_statement3 = red_accept;
val red_simple_statement4 = red_accept;
val red_simple_statement5 = red_accept;
val red_compound_statement1 = red_accept;
val red_compound_statement2 = red_accept;
val red_compound_statement3 = red_accept;
=TEX
=SML
fun red_null_statement _ _ = (
	PPStatement (Stmt Null)
); 
fun red_assignment_statement x1 x2 x3 x4 = PPtbs;
fun red_if_statement _ _ _ _ _ _ _ _ _ = PPtbs;

=IGN
fun red_if_statement _ (Parsed(PPExp exp)) _ (Parsed(PPStatement s)) (Parsed(PPElsIf ei)) (Parsed(PPStatement el)) _ _ _ = (
let	val css = (exp,s)::ei;
	fun aux ((c,s)::(rest as (_::_))) el = (
		(IfThenElse{G=c,P=s,Q=aux rest el})
	) | aux [(c,s)] el = (
		(IfThenElse{G=c,P=s,Q=el})
	) | aux _ _ = Null;
in
	PPStatement (Stmt (aux css el))
end
) | red_if_statement _ _ _ _ _ _ _ _ _ = stack_error "red_if_statement";
=TEX
=SML
val red_elsif_part1 = PPElsIf [];
fun red_elsif_part2 _ (Parsed (PPExp exp)) _ (Parsed(PPStatement s)) (Parsed(PPElsIf ei)) = (
	PPElsIf ((exp, s)::ei)
) | red_elsif_part2 _ _ _ _ _ = stack_error "red_elsif_part2";
=TEX
=SML
val red_else_part1 = PPStatement (Stmt Null);

fun red_else_part2 _ (Parsed(PPStatement s)) = (
	PPStatement s
) | red_else_part2 _ _ = stack_error "red_else_part2";

fun red_condition (Parsed (PPExp exp)) = (
	PPExp (Id "<exp-stub>")
) | red_condition _ = stack_error "red_condition";
=TEX
=SML
fun red_case_statement x1 x2 x3 x4 x5 x6 x7 x8 = PPtbs;
fun red_case_statement_alternative_list1 x1 = PPtbs;
fun red_case_statement_alternative_list2 x1 x2 = PPtbs;
fun red_case_statement_alternative x1 x2 x3 x4 = PPtbs;
fun red_case_choice_list1 x1 = PPtbs;
fun red_case_choice_list2 x1 x2 x3 = PPtbs;
fun red_case_choice x1 = PPtbs;
val red_others_part1 = PPtbs;
fun red_others_part2 x1 x2 x3 = PPtbs;
fun red_loop_statement x1 x2 x3 x4 x5 x6 x7 x8 x9 = PPtbs;
val red_name_opt11 = PPtbs;
fun red_name_opt12 x1 x2 = PPtbs;
val red_name_opt21 = PPtbs;
fun red_name_opt22 x1 = PPtbs;
val red_iteration_scheme_opt1 = PPtbs;
fun red_iteration_scheme_opt2 x1 = PPtbs;
fun red_iteration_scheme1 x1 x2 = PPtbs;
fun red_iteration_scheme2 x1 x2 = PPtbs;
fun red_loop_parameter_specification1 x1 x2 x3 = PPtbs;
fun red_loop_parameter_specification2 x1 x2 x3 x4 = PPtbs;
fun red_loop_parameter_specification3 x1 x2 x3 x4 x5 = PPtbs;
fun red_loop_parameter_specification4 x1 x2 x3 x4 x5 x6 = PPtbs;
val red_till_opt1 = PPtbs;
fun red_till_opt2 x1 x2 = PPtbs;
=TEX
tbs - the correct abstract syntax for Z
=SML
fun red_abstract_expression _ (Token ((LCZ,CNZ z), _)) _ = (
	PPZ ¨trueÆ
) | red_abstract_expression _ _ _ = stack_error "red_abstract_expression";
;
(*HERE*)
fun red_exit_statement1 _ _ = (
	PPStatement (Stmt Exit)
);
fun red_exit_statement2 _ _ (Parsed(PPExp exp)) _ = (
	PPStatement (Stmt(ExitWhen{G=exp}))
) | red_exit_statement2 _ _ _ _ = stack_error "red_exit_statement2";

fun red_return_statement _ (Parsed(PPExp exp)) _ = (
	PPStatement (Stmt (Ret{E=exp}))
) | red_return_statement _ _ _ = stack_error "red_return_statement";
=TEX
=SML
fun red_subprogram_declaration1 (Parsed p) _ = (p
) | red_subprogram_declaration1 _ _ = stack_error "red_subprogram_declaration1";
fun red_subprogram_declaration2 (Parsed p) _ = (p
) | red_subprogram_declaration2 _ _ = stack_error "red_subprogram_declaration2";
val red_subprogram_specification1 = red_accept;
val red_subprogram_specification2 = red_accept;
=TEX
tbs - specification statements in the following...
=SML
fun red_procedure_specification1 _ (Token ((_,CNText id), _)) = (
	PPProcedureSpecification{name=id, formal_part=[],spec=Nil}
) | red_procedure_specification1 _ _ = stack_error "red_procedure_specification1";

fun red_procedure_specification2 _ (Token ((_,CNText id), _)) (Parsed (PPSpecNoIvars s)) = (
	PPProcedureSpecification{name=id,formal_part=[],spec=Value s}
) | red_procedure_specification2 _ _ _ = stack_error "red_procedure_specification2";

fun red_procedure_specification3 _ (Token ((_,CNText id), _)) (Parsed (PPFormals f)) = (
	PPProcedureSpecification{name=id,formal_part=f,spec=Nil}
) | red_procedure_specification3 _ _ _ = stack_error "red_procedure_specification3";

fun red_procedure_specification4 _ (Token ((_,CNText id), _)) (Parsed (PPFormals f)) (Parsed (PPSpecNoIvars s)) = (
	PPProcedureSpecification{name=id,formal_part=f,spec=Value s}
) | red_procedure_specification4 _ _ _ _= stack_error "red_procedure_specification4";

fun red_function_specification1 _ (Parsed (PPId des)) _ (Token ((_,CNText name), _)) = (
	PPFunctionSpecification{designator=des, return=name,formal_part=[],spec=Nil}
) | red_function_specification1 _ _ _ _ = stack_error "red_function_specification1";

fun red_function_specification2 _ (Token ((_,CNText des), _)) _ (Token ((_,CNText name), _)) (Parsed (PPSpecNoIvars s)) = (
	PPFunctionSpecification{designator=des, return=name,formal_part=[],spec=Value s}
) | red_function_specification2 _ _ _ _ _ = stack_error "red_function_specification2";

fun red_function_specification3 _ (Parsed (PPId des)) (Parsed(PPFormals f)) _ (Token ((_,CNText name), _)) = (
	PPFunctionSpecification{designator=des, return=name,formal_part=f,spec=Nil}
) | red_function_specification3 _ _ _ _ _ = stack_error "red_function_specification3";

fun red_function_specification4 _ (Parsed (PPId des)) (Parsed(PPFormals f)) _ (Token ((_,CNText name), _)) (Parsed (PPSpecNoIvars s)) = (
	PPFunctionSpecification{designator=des, return=name,formal_part=f,spec=Value s}
) | red_function_specification4 _ _ _ _ _ _ = stack_error "red_function_specification4";
=TEX
SPARK manual 6.1:
=SML
fun red_designator (Token((_,CNText des), _)) = (
	PPId des
) | red_designator _ = stack_error "red_designator";

fun red_operator_symbol (Token((StringLiteral,CNString opsym), _)) = (
	PPId opsym
) | red_operator_symbol _ = stack_error "red_operator_symbol";

fun red_formal_part _ (Parsed p) _ = (p
) | red_formal_part _ _ _ = stack_error "red_formal_part";

val red_parlist1 = red_accept;

fun red_parlist2 (Parsed (PPFormals f1)) _ (Parsed(PPFormals f2)) = (
	PPFormals (f1@f2)
) | red_parlist2 _ _ _ = stack_error "red_parlist2";

fun red_parameter_specification (Parsed(PPIds ids)) _ (Parsed(PPMode m)) (Token ((_,CNText name), _)) = (
	PPFormals[{idlist=ids,mode=m,name=name}]
) | red_parameter_specification _ _ _ _ = stack_error "red_parameter_specification";
;
val red_mode1 = PPMode SparkIn;
fun red_mode2 _ = PPMode SparkIn;
fun red_mode3 _ = PPMode SparkOut;
fun red_mode4 _ _ = PPMode SparkInOut;
=TEX
SPARK manual 6.3:
=SML
fun red_subprogram_body1 (Parsed (PPProcedureSpecification ps)) _ (Parsed (PPSubprogram (d, s))) = (
	PPProperBody (PBProcedure {procedure_spec=ps,declarative_part=d,statement=s})
) | red_subprogram_body1 _ _ _ = stack_error "red_subprogram_body1";

fun red_subprogram_body2 (Parsed (PPFunctionSpecification fs)) _ (Parsed (PPSubprogram (d, s))) = (
	PPProperBody (PBFunction {function_spec=fs,declarative_part=d,statement=s})
) | red_subprogram_body2 _ _ _ = stack_error "red_subprogram_body2";

fun red_subprogram_implementation (Parsed(PPDeclarations d)) _ (Parsed(PPStatement s)) _ _ _ = (
	PPSubprogram (d, s)
) | red_subprogram_implementation _ _ _ _ _ _ = stack_error "red_subprogram_implementation";
=TEX
=SML
fun red_procedure_call_statement x1 x2 = PPtbs;
fun red_actual_parameter_part _ x2 _ = PPtbs;
fun red_parameter_association1 x1 = PPtbs;

val red_parameter_association2 = red_accept;

fun red_positional_parameter_association1 (Parsed(PPExp a)) = (
	PPExps [a]
) | red_positional_parameter_association1 _ = stack_error "red_positional_parameter_association1";

fun red_positional_parameter_association2 (Parsed(PPExp a)) _ (Parsed(PPExps es)) = (
	PPExps (a::es)
) | red_positional_parameter_association2  _ _ _ = stack_error "red_positional_parameter_association2";

val red_actual_parameter = red_accept;
=TEX
SPARK manual 7.1:
=SML
fun red_package_declaration (Parsed p) _ = (p
) | red_package_declaration _ _ = stack_error "red_package_declaration";

fun red_package_specification1 _ (Token ((_,CNText id), _)) _ (Parsed(PPDeclarations v)) _ _ = (
	PPPackageSpecification {name=id,visible_decs=v,private_decs=[]}
) | red_package_specification1 _ _ _ _ _ _ = stack_error "red_package_specification1";

fun red_package_specification2 _ (Token ((_,CNText id), _)) _ (Parsed(PPDeclarations v)) _  (Parsed(PPDeclarations p)) _ _ = (
	PPPackageSpecification {name=id,visible_decs=v,private_decs=p}

) | red_package_specification2 _ _ _ _ _ _ _ _ = stack_error "red_package_specification2";
val red_visible_part1 = red_accept;

fun red_visible_part2 (Parsed (PPDeclarations d1)) (Parsed (PPDeclarations d2)) = ( 
	PPDeclarations (d1@d2)
) | red_visible_part2 _ _ = stack_error "red_visible_part2";

=TEX
SPARK manual 7.1:
=SML
fun red_visdec1 (Parsed (PPKSlot k)) = (
	PPDeclarations [DDeclarationKSlot k]
) | red_visdec1 _ = stack_error "red_visdec1";

val red_visdec2 = red_accept;

val red_visdec3 = red_accept;

val red_private_part1 = red_accept;

fun red_private_part2 (Parsed (PPDeclarations d1)) (Parsed (PPDeclarations d2)) = (
	PPDeclarations (d1@d2)
) | red_private_part2 _ _ = stack_error "red_private_part2";

fun red_pdec1 (Parsed (PPKSlot k)) = (
	PPDeclarations [DDeclarationKSlot k]
) | red_pdec1 _ = stack_error "red_pdec1";

val red_pdec2 = red_accept;
=TEX
=SML
fun red_package_body _ _ (Token ((_,CNText id), _)) _ (Parsed(PPSubprogram (d,s))) _ _ _ = (
	PPProperBody(PBPackage{name=id,decls=d,statement=s})
) | red_package_body _ _ _ _ _ _ _ _ = stack_error "red_package_body";

fun red_package_implementation1 (Parsed (PPDeclarations d)) = (
	PPSubprogram (d, Stmt Null)
) | red_package_implementation1 _ = stack_error "red_package_implementation1";

fun red_package_implementation2 (Parsed (PPDeclarations d)) _ (Parsed(PPStatement s)) = (
	PPSubprogram (d, s)
) | red_package_implementation2 _ _ _ = stack_error "red_package_implementation2";

val red_package_initialization = red_accept;
=TEX
SPARK manual 7.4:
=SML
fun red_private_type_declaration1 _ (Token ((_,CNText id), _)) _ _ _ = (
	PPtbs);
fun red_private_type_declaration2 x1 x2 x3 x4 x5 x6 = PPtbs;
fun red_deferred_constant_declaration x1 x2 x3 x4 x5 = PPtbs;
fun red_renaming_declaration1 _ (Parsed (PPId opsym)) (Parsed(PPFormals f)) _ x5 _ x7 _ x9 _ = PPtbs;
fun red_renaming_declaration2 x1 _ x3 _ x5 _ = PPtbs;
=TEX
=SML
fun red_compilation1 (Parsed (PPKSlot k)) = (
	PPKSlotCUList [CompKSlot k]
) | red_compilation1 _ = stack_error "red_compilation1";

fun red_compilation2 (Parsed (PPCompilationUnit (ids,c))) = (
	PPKSlotCUList [CompUnit {context=ids, comp_unit=c}]
) | red_compilation2 _ = stack_error "red_compilation2";

fun red_compilation3 (Parsed (PPCompilationUnit (ids,c))) (Parsed (PPKSlotCUList cl)) = (
	PPKSlotCUList ((CompUnit {context=ids, comp_unit=c})::cl)
) | red_compilation3 _ _ = stack_error "red_compilation3";
=TEX
=SML
fun red_compilation_unit (Parsed(PPIds ids)) (Parsed (PPCompilationUnit ([],c))) = (
	PPCompilationUnit (ids, c)
) | red_compilation_unit _ _ = stack_error "red_compilation_unit";

val red_compilation_unit1 = red_compilation_unit;
val red_compilation_unit2 = red_compilation_unit;
=TEX
=SML
fun red_library_unit1 (Parsed(PPDeclarations [DPackageDeclaration p])) = (
	PPCompilationUnit ([], CUPackageDeclaration p)
) | red_library_unit1 _ = stack_error "red_library_unit1";

fun red_library_unit2 (Parsed(PPProperBody p)) = (
	PPCompilationUnit ([], CUProperBody p)
) | red_library_unit2 _ = stack_error "red_library_unit2";

=TEX

SPARK manual 10.1:
=SML
val red_secondary_unit1 = red_accept;
val red_secondary_unit2 = red_accept;
val red_library_unit_body = red_accept;
val red_main_program = red_accept;
=TEX

SPARK manual 10.1.1:
=SML
val red_context_clause1 = PPIds [];
val red_context_clause2 = red_accept;

fun red_with_clause _ (Parsed (PPIds ids)) _ = (
	 PPIds ids
) | red_with_clause _ _ _ = stack_error "red_with_clause";
=TEX
SPARK manual 10.2:
=SML
fun red_body_stub1 (Parsed p) _ _ _ = (
	p
) | red_body_stub1 _ _ _ _ = stack_error "red_body_stub1";

fun red_body_stub2 (Parsed p) _ _ _ = (
	p
) | red_body_stub2 _ _ _ _ = stack_error "red_body_stub2";

fun red_body_stub3 _ _ (Parsed p) _ _ _ = (
	p
) | red_body_stub3 _ _ _ _ _ _ = stack_error "red_body_stub3";

fun red_subunit _ _ (Token ((_,CNText id), _)) _ (Parsed (PPProperBody p)) = (
	PPCompilationUnit([], CUSubUnit{id=id, proper_body=p})
) | red_subunit _ _ _ _ _ = stack_error "red_subunit";
=TEX
=SML
val red_representation_clause1 = red_accept;

val red_representation_clause2 = red_accept;

val red_type_representation_clause1 = red_accept;
val red_type_representation_clause2 = red_accept;
val red_type_representation_clause3 = red_accept;
fun red_length_clause _ x2 _ (Parsed(PPExp e)) _ = PPtbs;
=TEX
SPARK manual 13.3:
=SML
fun red_enumeration_representation_clause _ (Token ((_,CNText id), _)) _ x4 _ = PPtbs;
=TEX
SPARK manual 13.4:
=SML
fun red_record_representation_clause _ (Token ((_,CNText id), _)) _ _ (Parsed(PPExps [e])) (Parsed(PPComponentClauses c)) _ _ _ = (
	PPRepresentationClause(RecordRepresentationClause{name=id,alignment_opt=Value e,component_pack=c})
) | red_record_representation_clause _ (Token ((_,CNText id), _)) _ _ (Parsed(PPExps [])) (Parsed(PPComponentClauses c)) _ _ _ = (
	PPRepresentationClause(RecordRepresentationClause{name=id,alignment_opt=Nil,component_pack=c})
) | red_record_representation_clause _ _ _ _ _ _ _ _ _ = stack_error "red_record_representation_clause";



=TEX
SPARK manual 13.4:
=SML
val red_alignment_opt1 = PPExps [];
fun red_alignment_opt2 _ _ (Parsed(PPExp e)) _ = (
	PPExps [e]
) | red_alignment_opt2 _ _ _ _ = stack_error "red_alignment_opt2";

val red_component_pack1 = red_accept;

fun red_component_pack2 (Parsed(PPComponentClauses [c])) (Parsed(PPComponentClauses cs)) = (
	PPComponentClauses (c::cs)
) | red_component_pack2 _ _ = stack_error "red_component_pack2";
=TEX
SPARK manual 13.4:
=SML
fun red_component_clause (Token ((_,CNText id), _)) _ (Parsed(PPExp e)) _ (Parsed(PPRange r)) _ = (
	PPComponentClauses[{exp=e, range=r}]
) | red_component_clause _ _ _ _ _ _ = stack_error "red_component_clause";
=TEX
tbs - the name construction in the following

following tbs re: name
SPARK manual 13.5:
=SML
fun red_address_clause _ (Token ((_,CNText id), _)) _ _ (Parsed (PPExp exp)) _ = (
	PPRepresentationClause(AddressClause {name=id, exp=exp})
) | red_address_clause _ _ _ _ _ _ = stack_error "red_address_clause";
=TEX
=SML
end (* of structure *);
=TEX

\section{PARSER}\label{PARSER}
=SML
structure €CNParser› : CNParser = struct
=TEX
=SML
=TEX
We can now load the code generated by SLRP from the grammar
of 'cite{ISS/HAT/DAZ/DTD503}'.
=SML
local
	open CNParser;
=TEX
=INCLUDE
dtd503.grm.sml
=IGN
fun slrp'gen_parser x1 x2 x3 x4 = fn _ => PPtbs;
=SML
in
=TEX
\subsection{Reader Function}\lab
=TEX
\subsection{Interface}
=TEX
=SML
fun €cn_reader› (ip : CN_LEX_ITEM list) : CN_LEX_ITEM * (CN_LEX_ITEM list) = (
	case ip of
		(h :: more) => (cur_tok := !cur_tok + 1; (h, more))
	|	[] => ((LCEos, CNEos), [])
);
=TEX
=SML
val €cn_error› : (CN_LEX_ITEM, 'b, 'c, 'd) ERROR_ROUTINE = (fn (tok, stk, _, _) => (
	parse_error_hdr();
	diag_string (get_error_message 19003 [format_lex_item tok,
				format_stack format_lex_item stk]);
	raise SYNTAX_ERROR
));
=TEX
The following is adapted from the HOL parser in \cite{ISS/HAT/DAZ/IMP019} q.v.
for explanation.
=SML
fun €cn_parser› (ip : CN_LEX_ITEM list) : WEB_CLAUSE  = (
	let	val se1 = (input_toks := ip; cur_tok := ~1);
		val res = (slrp'gen_parser
				default_resolver
				fst
				cn_error
				cn_reader) ip;
		val se2 = (input_toks := []);
	in	case res of
		PPWebClause wc => wc
		|_ => fail "cn_parser" 503001 []
	end
);
=TEX
=TEX
\section{EPILOGUE}
=SML
end (* of local ... in *);
end (* of structure CNParser *);
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
