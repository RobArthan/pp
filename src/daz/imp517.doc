% %Z%
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Script Proof Support}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP517}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Implementation}
\TPPkeywords{HOL}
\TPPauthor{K.~Blackburn&WIN01}
\TPPauthorisation{R.D.~Arthan & DAZ Team Leader}
\TPPabstract{
This is the implementation of methods of making the paragraphs generated by the compliance notation available to the user in a
normalised form.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issues 1.1 - 1.2] Initial Versions.
\item[Issues 1.3 - 1.4] Specifically working towards fulfilling item 6 of \cite{ISS/HAT/DAZ/MIN09} v1.2.
\item[Issue 1.5]
To match issue 1.5 of dtd517.
\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the Theory Proof Support tools.
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD517}.

\subsection{Introduction}

\subsection{Purpose and Background}

\subsection{Algorithms}

\subsection{Dependencies}

\subsection{Known Deficencies}

\subsection{Possible Enhancements}
\section{PROLOGUE}
=SML
open_theory "cn";
force_delete_theory "imp517" handle _ => ();
if get_current_theory_status() <> TSNormal
then new_theory "imp517"
else ();
push_pc "cn1";
=TEX
=IGN
structure €CNTheoryProofSupport› : CNTheoryProofSupport = struct
=TEX
\subsection{Common Tools}
=SML
fun €override_save_thm› (nm : string, thm : THM) : THM = (
	save_thm (nm, thm)
	handle _ => (
		let 
			val old_thm = get_thm "-" nm;
			val thy_nm = get_current_theory_name();
		in
			(warn "override_save_thm" 517001 [(fn _ => nm), (fn _ => thy_nm)];
			delete_thm nm;
			save_thm (nm, thm)
			)
		end
		handle _ => fail "override_save_thm" 517002 [(fn _ => nm),
				 	get_current_theory_name]
	)
);
=TEX
Make ``-'' into the correct theory name, and otherwise just return the argument.
=SML
fun €make_actual_theory_name› (nm : string) = (
	case nm of
	"-" => get_current_theory_name()
	| _ => nm
);
=TEX
Make an arbitrary name into a valid alphanumeric ML variable name:
=SML
local
	fun aux_sane (c : string) : string = (
	case c of
	"!" => "_splat_"
	| "&" => "_and_"
	| "$" => "_dollar_"
	| "#" => "_hash_"
	| "+" => "_plus_"
	| "-" => "_dash_"
	| "/" => "_slash_"
	| ":" => "_colon_"
	| "<" => "_less_"
	| ">" => "_gtr_"
	| "=" => "_eq_"
	| "?" => "_qu_"
	| "@" => "_at_"
	| "\\" => "_bs_"
	| "~" => "_tw_"
	| "`" => "_bq_"
	| "^" => "_ca_"
	| "|" => "_bar_"
	| "*" => "_star_"
	| "\"" => "_dq_"
	| _ => (if ord(c) = 37
		then "_pc_"
		else c)
	);
in
fun €make_valid_var_name› (nm: string) : string = (
	case nm of 
	"" => "empty"
	| _ => implode (map aux_sane (explode nm))
);
end;

=TEX
\subsection{Auxiliary Functions}
=SML
fun €aux_list_cn_spec_rule› (f : THM -> (string * THM)list ) (fname : string) =(fn 
	(thms : THM list) => (
let 	val thms1 = (flat (mapfilter f thms));
(*	val dummy0 = map ((fn cnm => use_string ("val " ^make_valid_var_name cnm ^ ": THM = t_thm;")
		handle _ => fail fname 517003 [fn _ => cnm])
		o fst)
		thms1; *)
	val dummy1 = map override_save_thm thms1;
	val dummy2 = map (fn (nm1,_) => use_string
		("val "^make_valid_var_name nm1^ ":THM = get_thm \"-\" \""^nm1^"\";")) thms1;
in
	map snd thms1
end)
);

=TEX
=SML
fun €aux_cn_script_support_thms› (f : THM -> (string * THM)list) (fname : string) =(fn  (in_nm : string) => (
let	val thms = map snd (get_defns in_nm @ get_axioms in_nm)
		handle exn => reraise exn fname;
	val thms1 = flat (mapfilter f thms);
(*	val dummy0 = map ((fn cnm => use_string ("val " ^make_valid_var_name cnm ^ ": THM = t_thm;")
		handle _ => fail fname 517003 [fn _ => cnm])
		o fst)
		thms1; *)
	val dummy1 = map override_save_thm thms1;
	val dummy2 = map (fn (nm1,_) => use_string
		("val "^make_valid_var_name nm1^ ":THM = get_thm \"-\" \""^nm1^"\";")) thms1;
in
	map snd thms1
end));
=TEX
=SML
fun €aux_list_cn_script_support_thms›  (f : THM -> (string * THM) list) (fname : string) =(fn (in_nms : string list) => (
let	val thmsl = map (fn nm => 
		map snd (get_defns nm @ get_axioms nm)
		handle exn => reraise exn fname) in_nms;
	val thms1l = map (fn thms => flat(mapfilter f thms)) thmsl;
(*	val dummy0 = map ((fn cnm => use_string ("val " ^make_valid_var_name cnm ^ ": THM = t_thm;")
		handle _ => fail fname 517003 [fn _ => cnm])
		o fst)
		(flat thms1l); *)
	val dummy1 = map (fn thms1 => map override_save_thm thms1) thms1l;
	val dummy2 = map (fn thms1 => map 
		(fn (nm1,_) => use_string
		("val "^make_valid_var_name nm1^ ":THM = get_thm \"-\" \""^nm1^"\";")) thms1) thms1l;
in
	map snd (flat thms1l)
end));
=TEX
\subsection{Alternative Tools}
First some theorems:
=SML
val local_id_thm = tac_proof(
	([],  ¨µ X f ∑
		Ò(f = id X ¥ (µ i : X ∑ f i = i))ÆÆ),
	  PC_T "z_library1"
	  (REPEAT strip_tac THEN 
	  asm_rewrite_tac[z_id_thm] THEN
	  z_app_eq_tac THEN
	  REPEAT strip_tac THEN
	  all_var_elim_asm_tac THEN
	  strip_tac));
=TEX
=SML
val local_id_ty_thm = tac_proof(
	([],  ¨µ X f ∑
		Ò(f = id X ¥ (f ç X ≠ X))ÆÆ),
	  PC_T "z_library1"
	  (REPEAT strip_tac THEN 
	  all_var_elim_asm_tac1 THEN
	  PC_T "z_fun_ext" (REPEAT z_strip_tac) THEN_LIST
	  [ all_var_elim_asm_tac,
	    all_var_elim_asm_tac THEN strip_tac,
	    z_∂_tac Òx1Æ THEN PC_T "z_rel_ext" (REPEAT z_strip_tac)
	  ])
	);
=TEX
=SML
val local_dot_dot_diff_thm = tac_proof(
	([],  Òµi, j : ˙∑ (i .. j) \ {j} = i .. (j + ~ 1)Æ),
	MERGE_PCS_T1 ["'z_numbers1", "z_sets_ext"] REPEAT strip_tac
	THEN PC_T1 "z_lin_arith1" asm_prove_tac []);
=TEX
=SML
val local_id_rel_inv_thm = tac_proof(
	([],  ¨µ X ∑ Ò (id X) Á~Í = id XÆÆ),
	  PC_T "z_library1_ext"
	  (prove_tac[]));
=TEX
=SML
val local_ç_succ_thm =  (
	set_goal([], ¨µ i j ∑
	Ò(i, j) ç succ § (0 º i) ± (j = i + 1)ÆÆ);
	push_pc "z_library1";
	a(strip_tac THEN strip_tac);
	a(ante_tac (µ_elim Òi + 1Æ (µ_intro ÒzÆ (z_µ_elim Ò(f ¶ succ, x ¶ i)Æ 
		(rewrite_rule[](z_µ_elim Ò(X ¶ Ó, Y ¶ Ó)Æ
		 z_≠_app_eq_§_ç_rel_thm))))));
	a(strip_asm_tac (z_get_spec ÒsuccÆ));
	a(asm_rewrite_tac[]);
	a(CASES_T Ò0 º iÆ asm_tac THEN asm_rewrite_tac[]);
	(* *** Goal "1" *** *)
	a(GET_NTH_ASM_T 2 ( strip_asm_tac o
		 rewrite_rule[] o z_µ_elim ÒiÆ));
	a(asm_rewrite_tac[]);
	a(REPEAT strip_tac);
(* *** Goal "1.1" *** *)
	a(GET_NTH_ASM_T 6 (PC_T1 "z_fun_ext" strip_asm_tac));
	a(GET_NTH_ASM_T 2 (ante_tac o z_µ_elim Ò(x ¶ i, y1 ¶ j, y2 ¶ i + 1)Æ));
	a(asm_rewrite_tac[]);
	a(GET_NTH_ASM_T 3 (fn t => fc_tac[t]));
	a(PC_T1 "z_sets_alg" REPEAT strip_tac);
(* *** Goal "1.2" *** *)
	a(var_elim_asm_tac Òj = i + 1Æ);
(* *** Goal "2" *** *)
	a(GET_NTH_ASM_T 3 (PC_T1 "z_fun_ext" strip_asm_tac));
	a(GET_NTH_ASM_T 3 (strip_asm_tac o z_µ_elim Ò(x1 ¶ i, x2 ¶ j)Æ));
	pop_thm()
	);
=TEX
=SML
val local_Ú_succ_thm = tac_proof(
	([],  ¨µ f j k ∑ Ò 0 º j ¥ 
			(f = (j .. k) Ú succ) ¥ 
			(µ i : j .. k ∑ f i = i + 1)ÆÆ),
	  PC_T "z_library1"
	  (REPEAT strip_tac THEN
	  DROP_NTH_ASM_T 3 rewrite_thm_tac THEN
	  z_app_eq_tac THEN
	  rewrite_tac[z_Ú_thm, local_ç_succ_thm] THEN
	  REPEAT strip_tac THEN
	  PC_T1 "z_lin_arith1" asm_prove_tac[]
	  ));
=TEX
=SML
val local_Ú_succ_ty_thm = tac_proof(
	([],  ¨µ f j k ∑ Ò 0 º j ¥ 
			(f = (j .. k) Ú succ) ¥ 
			(f ç (j .. k) ≠ (j + 1 .. k + 1))ÆÆ),
	  PC_T "z_library"
	  (REPEAT strip_tac THEN
	  all_var_elim_asm_tac1 THEN
	  PC_T "z_fun_ext" (REPEAT strip_tac) THEN_LIST
	  [(DROP_NTH_ASM_T 1 (rewrite_thm_tac o rewrite_rule[local_ç_succ_thm]) THEN
		DROP_NTH_ASM_T 1 (rewrite_thm_tac o rewrite_rule[])
		),
	   (DROP_NTH_ASM_T 1 (rewrite_thm_tac o rewrite_rule[local_ç_succ_thm]) THEN
		DROP_NTH_ASM_T 1 (rewrite_thm_tac o rewrite_rule[local_ç_succ_thm])),
	   (z_∂_tac Òx1 + 1Æ THEN PC_T "z_rel_ext" (REPEAT z_strip_tac) THEN
		rewrite_tac[local_ç_succ_thm] THEN
		DROP_NTH_ASM_T 1 (strip_asm_tac o rewrite_rule[]) THEN
		all_asm_fc_tac[z_º_trans_thm])	  
	  ]
	  ));
=TEX
=SML
val local_Ú_succ_rel_inv_thm = tac_proof(
	([],  ¨µ f j k ∑ Ò 0 º j ¥ 
			(f = ((j .. k) Ú succ) Á~Í) ¥ 
			(µ i : j + 1 .. k + 1∑ f i = i + ~ 1)ÆÆ),
	  PC_T "z_library1"
	  (REPEAT strip_tac THEN
	  DROP_NTH_ASM_T 3 rewrite_thm_tac THEN
	  z_app_eq_tac THEN
	  rewrite_tac[z_rel_inv_thm, z_Ú_thm, local_ç_succ_thm] THEN
	  rewrite_tac[z_plus_assoc_thm] THEN
	  PC_T1 "z_lin_arith1" asm_prove_tac[]
	  ));
=SML
=TEX
=SML
val local_Ú_succ_rel_inv_ty_thm = (
	push_pc "z_library1";
	set_goal([],  ¨µ f j k ∑ Ò 0 º j ¥ 
			(f = ((j .. k) Ú succ) Á~Í) ¥ 
			(f ç j + 1  .. k + 1 ≠ (j .. k))ÆÆ);
	a(REPEAT strip_tac THEN
	  DROP_NTH_ASM_T 1 rewrite_thm_tac THEN
	  PC_T "z_fun_ext" (REPEAT z_strip_tac));
	(* *** Goal "1" *** *)
	a(DROP_NTH_ASM_T 1 (strip_asm_tac o rewrite_rule[local_ç_succ_thm]) THEN
		all_var_elim_asm_tac1 THEN
		rewrite_tac[] THEN 
		DROP_NTH_ASM_T 2 (rewrite_thm_tac o rewrite_rule[]));
	(* *** Goal "2" *** *)
	a(DROP_NTH_ASM_T 1 (strip_asm_tac o rewrite_rule[local_ç_succ_thm]) THEN
		DROP_NTH_ASM_T 3 (strip_asm_tac o rewrite_rule[local_ç_succ_thm]) THEN
		all_var_elim_asm_tac1 THEN
		DROP_NTH_ASM_T 1 (rewrite_thm_tac o rewrite_rule[]));
	(* *** Goal "4" *** *)
	a(z_∂_tac Òx1 + (~ 1)Æ THEN rewrite_tac[z_rel_inv_thm, z_Ú_thm, local_ç_succ_thm]	THEN
		DROP_NTH_ASM_T 1 (strip_asm_tac o rewrite_rule[]) THEN
		PC_T1 "z_lin_arith1" asm_prove_tac []);
	pop_pc();
	pop_thm ()
);

=SML
val local_set_abs_thm = (
	  set_goal([],  ¨µ f master index X Y ∑ Ò
			(f = {u : master | dom u = index}) ¥
			(master ç  (X ﬂ Y)) ¥
			f = (index ≠ Y) ° master
			ÆÆ);
		push_pc "z_library1";
		a(strip_tac THEN strip_tac THEN strip_tac THEN strip_tac THEN strip_tac); 
		a(¥_T rewrite_thm_tac);
		a(PC_T1 "z_fun_ext" rewrite_tac[]);
		a(strip_tac THEN z_µ_tac THEN strip_tac);
		a(POP_ASM_T (strip_asm_tac o z_µ_elim Òx1Æ));
(* *** Goal "1" *** *)
		a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
		a(cases_tac Òx1 ç masterÆ THEN asm_rewrite_tac[]);
		a(DROP_NTH_ASM_T 1 discard_tac);
		a(CASES_T (fst(dest_z_§(snd(top_goal()))))
			(fn t => rewrite_tac[t] THEN asm_tac t));
		a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
		a(asm_fc_tac[]);
(* *** Goal "2.2" *** *)
		a(asm_fc_tac[]);
(* *** Goal "2.3" *** *)
		a(z_spec_nth_asm_tac 7 Ò(x ¶ x, y1 ¶ y1, y2 ¶ y2)Æ);
		a(z_spec_nth_asm_tac 9 Ò(x2 ¶ x, x3 ¶ y1)Æ);
		pop_pc();
		pop_thm()
	  );
=TEX
Now the normalisation of Z horizontal schemas signatures:
=SML
val €z_norm_sig_h_schema_conv› : CONV = (fn tm =>
let	val (d,p) = dest_z_h_schema tm;
	val decs = dest_z_decl d;
	val ddecs = map dest_z_dec decs;
	val flat_ddecs = flat (map 
		(fn (vs,ty) => map (fn x => (fst(dest_var x), ([x], ty))) vs)
		ddecs);
	val sorted_flat_ddecs = map snd (Sort.sort 
		(fn (s1,(_,ty1)) => fn (s2,(_,ty2)) => 
		 if s1 = s2
		 then Sort.string_order (string_of_term ty1) (string_of_term ty2)
		 else ZTypesAndTermsSupport.z_sig_order s1 s2)
		flat_ddecs);
	val rhs = mk_z_h_schema(mk_z_decl (map mk_z_dec sorted_flat_ddecs), p);
in
	if (tm ~=$ rhs)
	then refl_conv tm
	else
	tac_proof(([], mk_z_eq (tm, rhs)),
		PC_T "z_library" (
			conv_tac z_sets_ext_conv THEN z_µ_tac THEN z_strip_tac THEN
			conv_tac (ONCE_MAP_C z_ç_h_schema_conv) THEN
			TRY_T(conv_tac (MAP_C z_setd_Ä_conv)) THEN
			taut_tac
		)
	)
end
handle _ => term_fail "z_norm_sig_h_schema_conv" 517005 [tm])
;

=TEX
The following could be made local to $cn\_simplify\_thm$, but for 
development purposes they are pervasive in the module.

We rely on the fact that users shouldn't introduce \Product\ variables with
names prefixed by $icl'$, expecially as these are not valid Z names.
If they do, then patterns won't match.
=IGN
local
=SML
	val nat = ÒÓÆ;
	val nat0 = Ò0Æ;
	val pat1 = Òid ¨icl'nameÆÆ;
	val pat2 = Ò¨icl'nameÆ Á~ÍÆ;
	val pat3 = Ò ( ¨icl'nameÆ \ { ¨icl'lstÆ } ) Ú succÆ;
	val pat4= Ò {u : ¨icl'masterÆ | dom u = ¨icl'indexÆ } Æ;
	val pat5 = Ò¨icl'lhsÆ = ( ¨icl'firstÆ .. ¨icl'lstm1Æ  ) Ú succÆ;
	val pat6 = Ò¨icl'lhsÆ = (( ¨icl'firstÆ .. ¨icl'lstm1Æ  ) Ú succ) Á~ÍÆ;
	val pat7 = Ò¨icl'masterÆ ç  ( ¨icl'XÆ ﬂ ¨icl'YÆ)Æ;

	val local_rw_rule = pure_rewrite_rule[z_plus_assoc_thm,
		±_right_elim(z_get_spec Ò(_ - _)Æ), z_minus_clauses,
		z_plus0_thm];
	val local_rw_rule1 = pure_once_rewrite_rule[local_dot_dot_diff_thm];
=TEX
Match:
=GFT
Ù f = id name
=TEX
=SML	
	fun pat1_canon thm =
	(let 	val ZEq(lhs, rhs) = dest_z_term (concl thm);
		val (tys, [(name, _)]) = term_match rhs pat1;
		val thm1 = list_µ_elim [name, lhs] local_id_thm;
		val thm2 = ¥_elim thm1 thm;
		val thm3 = list_µ_elim [name, lhs] local_id_ty_thm;
		val thm4 = ¥_elim thm3 thm;
	in 
		[thm2, thm4]
	end);
=TEX
Match:
=GFT
Ù f = (name \ {last} ) Ú succ
=TEX
=IGN
pat3_canon (z_get_spec ÒDAYvSUCCÆ);
=SML
	fun pat3_canon thm = 
	(let 	val ZEq(lhs, rhs) = dest_z_term (concl thm);
		val (tys, [(last,_), (name, _)]) = term_match rhs pat3;
		val nm1_spec = z_get_spec name;
		val ZEq (nm1_lhs, nm1_rhs) = dest_z_term (concl nm1_spec);
		val ZGVar (nm2, ty2, []) = dest_z_term nm1_lhs;
		val thm1 = conv_rule (ONCE_MAP_C (eq_match_conv nm1_spec)) thm;
		val last_spec = z_get_spec last;
		val ZEq (last_lhs, last_rhs) = dest_z_term (concl last_spec);
		val ZGVar (nm3, ty3, []) = dest_z_term last_lhs;
		val thm2 = conv_rule (ONCE_MAP_C (eq_match_conv last_spec)) thm1;
		val thm3 = local_rw_rule1 thm2;
		val (_, [(_, _), (first, _), (_, _)] ) = term_match (concl thm3) pat5;
		val first_spec = z_get_spec first;
		val first2 = snd(dest_eq (concl first_spec));
 		val thm4 = §_t_elim (z_º_conv (mk_z_º (nat0, first2)));
		val thm5 = conv_rule (LEFT_C (RIGHT_C 
			(eq_match_conv (eq_sym_rule first_spec)))) thm4;
		val last2 = mk_z_plus(last_rhs, Ò~ 1Æ);
		val thm6 = list_µ_elim [lhs, first, last2]
			local_Ú_succ_thm;
		val thm7 = ¥_elim (¥_elim thm6 thm5) thm3;
		val thm8 = list_µ_elim [lhs, first, last2] local_Ú_succ_ty_thm;
		val thm9 = local_rw_rule (¥_elim (¥_elim thm8 thm5) thm3);
	in 
		[thm7, thm9]
	end);
=TEX
Match:
=GFT
Ù f = g Á~Í
=TEX
Two cases - matching $g$ being the two cases above.
=IGN
pat2_canon (z_get_spec ÒDAYvPREDÆ);
=SML
	fun pat2_canon thm = 
	(let 	val ZEq(lhs, rhs) = dest_z_term (concl thm);
		val (tys, [(name, _)]) = term_match rhs pat2;
		val ZGVar (nm1, ty1, []) = dest_z_term name;
		val nm1_spec = z_get_spec name;
		val ZEq (nm1_lhs, nm1_rhs) = dest_z_term (concl nm1_spec);
		val ZGVar (nm2, ty2, []) = dest_z_term nm1_lhs;
		val thm1 = conv_rule (ONCE_MAP_C (eq_match_conv nm1_spec)) thm;
	in
		(let	val (tys2, [(name2,_)]) = term_match nm1_rhs pat1;
			val thm2 = conv_rule (ONCE_MAP_C (eq_match_conv local_id_rel_inv_thm)) thm1;
			val thm3 = list_µ_elim [name2, lhs] local_id_thm;
			val thm4 = ¥_elim thm3 thm2;
			val thm5 = list_µ_elim [name2, lhs] local_id_ty_thm;
			val thm6 = ¥_elim thm5 thm2;
		in
			[thm4, thm6]
		end) 
		handle _ =>
		(let	val (tys, [(last,_),(nm2, _)]) = term_match nm1_rhs pat3;
			val nm2_spec = z_get_spec nm2;
			val ZEq (nm2_lhs, nm2_rhs) = dest_z_term (concl nm2_spec);
			val ZGVar (nm3, ty3, []) = dest_z_term nm2_lhs;
			val thm2 = conv_rule (ONCE_MAP_C (eq_match_conv nm2_spec)) thm1;
			val last_spec = z_get_spec last;
			val ZEq (last_lhs, last_rhs) = dest_z_term (concl last_spec);
			val ZGVar (nm4, ty4, []) = dest_z_term last_lhs;
			val thm3 = conv_rule (ONCE_MAP_C (eq_match_conv last_spec)) thm2;
			val thm4 = local_rw_rule1 thm3;
			val (_, [(_, _), (first, _), (_, _)] ) = term_match (concl thm4) pat6;
			val first_spec = z_get_spec first;
			val first2 = snd(dest_eq (concl first_spec));
 			val thm5 = §_t_elim (z_º_conv (mk_z_º (nat0, first2)));
			val thm6 = conv_rule (LEFT_C (RIGHT_C 
				(eq_match_conv (eq_sym_rule first_spec)))) thm5;
			val last2 = mk_z_plus(last_rhs, Ò~ 1Æ);
			val thm7 = list_µ_elim [lhs, first, last2]
				local_Ú_succ_rel_inv_thm;
			val thm8 = ¥_elim (¥_elim thm7 thm6) thm4;
			val thm9 = local_rw_rule thm8;
			val thm10 = list_µ_elim [lhs, first, last2]
				local_Ú_succ_rel_inv_ty_thm;
			val thm11 = ¥_elim (¥_elim thm10 thm6) thm4;
			val thm12 = local_rw_rule  thm11;
		in
			[thm9, thm12]
		end)
	end);
=TEX
Match:
=GFT
Ù f = {u : master | dom u = index}
=TEX
=SML
	fun pat4_canon thm =
	(let 	val ZEq(lhs, rhs) = dest_z_term (concl thm);
		val (tys, [(index,_), (master, _)]) = term_match rhs pat4;
		val master_spec = ±_left_elim (z_get_spec master);
		val (tys, [(Y, _), (X, _), (_, _)]) = 
			term_match (concl master_spec) pat7;
		val thm1 = list_µ_elim[lhs, master, index, X, Y]
			 local_set_abs_thm;
		val thm2 = ¥_elim (¥_elim thm1 thm) master_spec;
	in 
		[thm2]
	end);
=IGN
in (* local patterns and canons *)
=TEX
=SML
fun €cn_simplify_canon› (thm: THM) : THM list = (
let 	val cnc = concl thm;
	val ZEq(lhs, rhs) = dest_z_term cnc;
	val ZGVar (_, _, []) = dest_z_term lhs;
in
=TEX
Match:
=GFT
Ù f = id name
=TEX
=SML
	(let 	val (tys, [(name, _)]) = term_match rhs pat1;
	in
		pat1_canon thm
	end) 
	handle _ =>
=TEX
Match:
=GFT
Ù f = (name \ {last} ) Ú succ
=TEX
=SML
	(let 	val (tys, [(last,_), (name, _)]) = term_match rhs pat3;
	in
		pat3_canon thm
	end)
 	handle _ =>
=TEX
Match:
=GFT
Ù f = g Á~Í
=TEX
Two cases - matching $g$ being the two cases above.
=SML
	(let 	val (tys, [(name, _)]) = term_match rhs pat2;
	in
		pat2_canon thm
	end)
	handle _ =>
=TEX
Match:
=GFT
Ù f = {u : master | dom u = index}
=TEX
=SML
	(let 	val (tys, [(index,_), (master, _)]) = term_match rhs pat4;
	in
		pat4_canon thm
 	end) 
	handle _ =>
=TEX
deal with horizontal schemas:
=SML
	[conv_rule (RIGHT_C z_norm_sig_h_schema_conv) thm]
end)
handle _ => []
=IGN
end (* of local patterns and canons *)
=SML
;
=TEX
The following is the same as the pure equivalent, except for the call to
$cn\_simplify\_rule$.
=SML
local val tru = ÒtrueÆ
in
fun €cn_spec_rule› (thm : THM) : (string * THM) list = (
	if is_eq (concl thm) andalso is_u(snd(dest_eq (concl thm)))
	then (let val ZGVar (nm, ty, []) = dest_z_term(fst(dest_eq (concl thm))) ;
		in [("cn_" ^ nm ^ "_thm", thm)]
		end)
	else
let	val thm1 = conv_rule z_para_pred_conv thm;
in
	case (dest_z_term (concl thm1)) of
	ZEq(lhs, rhs) => (
		let val ZGVar (nm, ty, []) = dest_z_term lhs;
		    val r = cn_simplify_canon thm1;
		in 
			case r of
			[thm2, thm3] => [("cn_" ^ nm ^ "_thm", thm2),
				("cn_" ^ nm ^ "_ty_thm", thm3)]
			| [thm2] => [("cn_" ^ nm ^ "_thm", thm2)]
			| _ => [("cn_" ^ nm ^ "_thm", thm1)]
		end
	) | Z± (a, b) => (
		if (b ~=$ tru) andalso is_z_ç a
		then (let val ZGVar (nm, ty, []) = 
				dest_z_term (fst (dest_z_ç a)) ;
		in
			[("cn_"  ^ nm ^ "_thm", ±_left_elim thm1)]
		end)
		else thm_fail "cn_spec_rule" 517004 [thm]
	) | _ => thm_fail "cn_spec_rule" 517004 [thm]
end)
handle _ => 
	thm_fail "cn_spec_rule" 517004 [thm];
end;
=TEX
The following are just the same as the pure tools but with a name change.
=SML
fun €list_cn_spec_rule› (thms : THM list) : THM list = (
	aux_list_cn_spec_rule cn_spec_rule "list_cn_spec_rule" thms
);
=TEX
=SML
fun €cn_script_support_thms› (nm : string) : THM list = (
	aux_cn_script_support_thms cn_spec_rule "cn_script_support_thms" nm
);
=TEX
We choose the following presentation to catch any unknown or out of scope theory 
names before we do any saving.
We use $cup$ to delete duplicates.
=SML
fun €list_cn_script_support_thms› (in_nms : string list) : THM list = (
	aux_list_cn_script_support_thms cn_spec_rule 
		"list_cn_script_support_thms" in_nms
);
=TEX

\subsection{Proof Contexts}
If the index to the equaltion context entry isn't of type BOOL then it can't be
used in stripping.
=SML
fun €maybe_strip› (index,cnv) = (
	if type_of index =: BOOL
	then (index,cnv)
	else fail "" 0 []
);
=TEX
If the index in an equation context is a set type,m then we can promote the
entry to be an equation of memberships.
=SML
local
	val setty = type_of Ò{}Æ;
in
fun €add_ç› ((index,cnv)::rest) = (
	(let val tyms = type_match (type_of index) setty @ [(î'aÆ,î'aÆ)];
		val x = variant (frees index) (mk_var("x",fst(hd tyms)));
	in
		((mk_z_ç(x,index), ç_C cnv) :: (index,cnv) :: add_ç rest)
	end)
	handle (Fail _) =>
	((index,cnv) :: add_ç rest)
) | add_ç [] = [];
end;
=TEX
=SML
local
	val pat = Òx = UÆ;
in
fun €is_U_eqn› (thm : THM) : bool = (
	(term_match (concl thm) pat; true) handle _ => false
);
end;

=TEX
Given a list of theorems create an equation context:
=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
let	val dummy1 = push_pc "cn1";
	val res = flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms);
	val dummy2 = pop_pc();
in
	res
end);
=TEX
Create a proof context from a list of theorems, as called for in 
detailed design.
In theory the following can't fail.
=SML
fun €local_make_pc› (fname : string) (thms : THM list) (pcname : string) : unit = (
let 	val u_thms = filter is_U_eqn thms;
	val not_u_thms = filter (fn x => not(is_U_eqn x)) thms;
	val source_ec = add_ç(thms_to_eqn_cxt not_u_thms);
	val ec_for_strip = mapfilter maybe_strip source_ec;
	val dummy1 = delete_pc pcname handle Fail _ => ();
	val dummy2 = new_pc pcname;
	val dummy3 = merge_pcs ["cn1"] pcname;
	val dummy4 = add_rw_thms not_u_thms pcname;
	val pos = ec_for_strip;
	val neg = map (mk_≥ ** RAND_C) pos;
	val dummy5 = set_st_eqn_cxt (pos @ neg) pcname;
	val dummy6 = set_sc_eqn_cxt (pos @ neg) pcname;
	val dummy7 = set_u_simp_eqn_cxt (u_simp_eqn_cxt u_thms) pcname;
	val dummy8 = commit_pc pcname;
in
	()
end);
=TEX
Now to use it:
=SML
fun €cn_make_script_support› (nm : string) (pcname : string) : THM list = (
let val thms = aux_cn_script_support_thms cn_spec_rule "cn_script_support_thms" nm;
	val dummy = local_make_pc "cn_make_script_support" thms pcname;
in
	thms
end);
=TEX
We choose the following presentation to catch any unknown or out of scope theory 
names before we do any saving.
We use $cup$ to delete duplicates.
=SML
fun €list_cn_make_script_support› (in_nms : string list) (pcname : string) : THM list = (
let 	val thms = aux_list_cn_script_support_thms cn_spec_rule 
		"list_cn_script_support_thms" in_nms;
	val dummy = local_make_pc "list_cn_script_support_thms" thms pcname;
in
	thms
end);
=TEX
=SML
fun €all_cn_make_script_support› (pcname : string) : THM list = (
	list_cn_make_script_support 
		(((get_ancestors "-") diff (get_ancestors "cn")) cup ["cn"])
		pcname
);
=TEX

\section{EPILOGUE}
=IGN
end (* of structure CNTheoryProofSupport *);
open CNTheoryProofSupport;
pop_pc();
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}

