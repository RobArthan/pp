=IGN
********************************************************************************
imp517.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% %Z%
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Script Proof Support}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP517}  %% Mandatory field
\def\SCCSversion{$Revision: 1.17 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2005/12/16 13:46:01 $%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Implementation}
\TPPkeywords{HOL}
\TPPauthor{K.~Blackburn&WIN01}
\TPPauthorisation{R.D.~Arthan & DAZ Team Leader}
\TPPabstract{
This is the implementation of methods of making the paragraphs generated by the compliance notation available to the user in a
normalised form.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issues 1.1 - 1.2] Initial Versions.
\item[Issues 1.3 - 1.4] Specifically working towards fulfilling item 6 of \cite{ISS/HAT/DAZ/MIN09} v1.2.
\item[Issue 1.5]
To match issue 1.5 of dtd517.
\item[Issue 1.6 - 1.10]
Fixing treatment of Q's.
\item [Issue 1.11]
Removed a local theorem in favour of a global one, prevented
some current proof context effects.
\item[Issue 1.12]
Fixed problem with spaces in object language names.
\item[Issue 1.13] Copyright and banner updates for open source release.
\item[Issue 1.14] DAZ-specific updates to banner for open source release
\item[Issue 1.15] DAZ-specific updates to banner for open source release
\item[Issue 1.16] The Z universal set is now called É
\item[Issue 1.17] Private names are now prefixed with $pp'$.
\item[Issue 1.18] Eliminated non-exhaustive matches.
\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the Theory Proof Support tools.
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD517}.

\subsection{Introduction}

\subsection{Purpose and Background}

\subsection{Algorithms}

\subsection{Dependencies}

\subsection{Known Deficencies}

\subsection{Possible Enhancements}
\section{PROLOGUE}
=SML
open_theory "cn";
force_delete_theory "imp517" handle (Fail _) => ();
if get_current_theory_status() <> TSNormal
then new_theory "imp517"
else ();
val imp517_thy = get_current_theory_name ();
push_pc "cn1";
=TEX
=SML
structure €CNTheoryProofSupport› : CNTheoryProofSupport = struct
=TEX
\subsection{Common Tools}
Protect uses of the systems $use\_string$ against mishaps with Q's.
=SML
fun use_string1 (s : string) = use_string (translate_for_output s);
=TEX
=SML
fun €override_save_thm› (nm : string, thm : THM) : THM = (
	save_thm (nm, thm)
	handle (Fail _) => (
		let
			val old_thm = get_thm "-" nm;
			val thy_nm = get_current_theory_name();
		in
			(warn "override_save_thm" 517001 [(fn _ => nm), (fn _ => thy_nm)];
			delete_thm nm;
			save_thm (nm, thm)
			)
		end
		handle (Fail _) => fail "override_save_thm" 517002 [(fn _ => nm),
				 	get_current_theory_name]
	)
);
=TEX
Make ``-'' into the correct theory name, and otherwise just return the argument.
=SML
fun €make_actual_theory_name› (nm : string) = (
	case nm of
	"-" => get_current_theory_name()
	| _ => nm
);
=TEX
Make an arbitrary name into a valid alphanumeric ML variable name:
=SML
local
	fun aux_sane (c : string) : string = (
	case c of
	"!" => "_splat_"
	| "&" => "_and_"
	| "$" => "_dollar_"
	| "#" => "_hash_"
	| "+" => "_plus_"
	| "-" => "_dash_"
	| "/" => "_slash_"
	| ":" => "_colon_"
	| "<" => "_less_"
	| ">" => "_gtr_"
	| "=" => "_eq_"
	| "?" => "_qu_"
	| "@" => "_at_"
	| "\\" => "_bs_"
	| "~" => "_tw_"
	| "`" => "_bq_"
	| "^" => "_ca_"
	| "|" => "_bar_"
	| "*" => "_star_"
	| "\"" => "_dq_"
	| " " => "_sp_"
	| _ => (if ord(c) = 37
		then "_pc_"
		else c)
	);
in
fun €make_valid_var_name› (nm: string) : string = (
	case nm of
	"" => "empty"
	| _ => implode (map aux_sane (explode nm))
);
end;
=TEX
=SML
fun €match1› (tm1 : TERM) (tm2 : TERM) : TERM = (
	case term_match tm1 tm2 of
		(_, [(x, _)]) => x
	|	_ => fail "match1" 517010 []
);
=TEX
=SML
fun €match2› (tm1 : TERM) (tm2 : TERM) : TERM * TERM = (
	case term_match tm1 tm2 of
		(_, [(x, _), (y, _)]) => (x, y)
	|	_ => fail "match1" 517010 []
);
=TEX
=SML
fun €match3› (tm1 : TERM) (tm2 : TERM) : TERM * TERM * TERM = (
	case term_match tm1 tm2 of
		(_, [(x, _), (y, _), (z, _)]) => (x, y, z)
	|	_ => fail "match1" 517010 []
);
=TEX
\subsection{Auxiliary Functions}
=SML
fun €aux_list_cn_spec_rule› (f : THM -> (string * THM)list ) (fname : string) =(fn
	(thms : THM list) => (
let 	val thms1 = (flat (mapfilter f thms));
(*	val dummy0 = map ((fn cnm => use_string1 ("val " ^make_valid_var_name cnm ^ ": THM = t_thm;")
		handle (Fail _) => fail fname 517003 [fn _ => cnm])
		o fst)
		thms1; *)
	val dummy1 = map override_save_thm thms1;
	val dummy2 = map (fn (nm1,_) => use_string1
		("val "^make_valid_var_name nm1^ ":THM = get_thm \"-\" \""^nm1^"\";")) thms1;
in
	union (op ~=|-) (map snd thms1) []
end)
);
=TEX
=SML
fun €aux_cn_script_support_thms› (f : THM -> (string * THM)list) (fname : string) =(fn  (in_nm : string) => (
let	val thms = map snd (get_defns in_nm @ get_axioms in_nm)
		handle exn => reraise exn fname;
	val thms1 = flat (mapfilter f thms);
(*	val dummy0 = map ((fn cnm => use_string1 ("val " ^make_valid_var_name cnm ^ ": THM = t_thm;")
		handle (Fail _) => fail fname 517003 [fn _ => cnm])
		o fst)
		thms1; *)
	val dummy1 = map override_save_thm thms1;
	val dummy2 = map (fn (nm1,_) => use_string1
		("val "^make_valid_var_name nm1^ ":THM = get_thm \"-\" \""^nm1^"\";")) thms1;
in
	union (op ~=|-) (map snd thms1) []
end));
=TEX
=SML
fun €aux_list_cn_script_support_thms›  (f : THM -> (string * THM) list) (fname : string) =(fn (in_nms : string list) => (
let	val thmsl = map (fn nm =>
		map snd (get_defns nm @ get_axioms nm)
		handle exn => reraise exn fname) in_nms;
	val thms1l = map (fn thms => flat(mapfilter f thms)) thmsl;
(*	val dummy0 = map ((fn cnm => use_string1 ("val " ^make_valid_var_name cnm ^ ": THM = t_thm;")
		handle (Fail _) => fail fname 517003 [fn _ => cnm])
		o fst)
		(flat thms1l); *)
	val dummy1 = map (fn thms1 => map override_save_thm thms1) thms1l;
	val dummy2 = map (fn thms1 => map
		(fn (nm1,_) => use_string1
		("val "^make_valid_var_name nm1^ ":THM = get_thm \"-\" \""^nm1^"\";")) thms1) thms1l;
in
	union (op ~=|-) (map snd (flat thms1l)) []
end));
=TEX
\subsection{Alternative Tools}
First some theorems:
=SML
val local_id_thm = tac_proof(
	([],  ¨µ X f ∑
		Ò(f = id X ¥ (µ i : X ∑ f i = i))ÆÆ),
	  PC_T "z_library1"
	  (REPEAT strip_tac THEN
	  asm_rewrite_tac[z_id_thm] THEN
	  z_app_eq_tac THEN
	  REPEAT strip_tac THEN
	  all_var_elim_asm_tac THEN
	  strip_tac));
=TEX
=SML
val local_id_sig_thm = tac_proof(
	([],  ¨µ X f ∑
		Ò(f = id X ¥ (f ç X ≠ X))ÆÆ),
	  PC_T "z_library1"
	  (REPEAT strip_tac THEN
	  all_var_elim_asm_tac1 THEN
	  PC_T "z_fun_ext" (REPEAT z_strip_tac) THEN_LIST
	  [ all_var_elim_asm_tac,
	    all_var_elim_asm_tac THEN strip_tac,
	    z_∂_tac Òx1Æ THEN PC_T "z_rel_ext" (REPEAT z_strip_tac)
	  ])
	);
=TEX
=SML
val local_dot_dot_diff_thm = tac_proof(
	([],  Òµi, j : ˙∑ (i .. j) \ {j} = i .. (j + ~ 1)Æ),
	MERGE_PCS_T1 ["'z_numbers1", "z_sets_ext"] REPEAT strip_tac
	THEN PC_T1 "z_lin_arith1" asm_prove_tac []);
=TEX
=SML
val local_id_rel_inv_thm = tac_proof(
	([],  ¨µ X ∑ Ò (id X) Á~Í = id XÆÆ),
	  PC_T "z_library1_ext"
	  (prove_tac[]));
=TEX
=SML
val local_Ú_succ_thm = tac_proof(
	([],  ¨µ f j k ∑ Ò 0 º j ¥
			(f = (j .. k) Ú succ) ¥
			(µ i : j .. k ∑ f i = i + 1)ÆÆ),
	  PC_T "z_library1"
	  (REPEAT strip_tac THEN
	  DROP_NTH_ASM_T 3 rewrite_thm_tac THEN
	  z_app_eq_tac THEN
	  rewrite_tac[z_Ú_thm, z_ç_succ_thm] THEN
	  REPEAT strip_tac THEN
	  PC_T1 "z_lin_arith1" asm_prove_tac[]
	  ));
=TEX
=SML
val local_Ú_succ_sig_thm = tac_proof(
	([],  ¨µ f j k ∑ Ò 0 º j ¥
			(f = (j .. k) Ú succ) ¥
			(f ç (j .. k) ≠ (j + 1 .. k + 1))ÆÆ),
	  PC_T "z_library1"
	  (REPEAT strip_tac THEN
	  all_var_elim_asm_tac1 THEN
	  PC_T "z_fun_ext" (REPEAT strip_tac) THEN_LIST
	  [(DROP_NTH_ASM_T 1 (rewrite_thm_tac o rewrite_rule[z_ç_succ_thm]) THEN
		DROP_NTH_ASM_T 1 (rewrite_thm_tac o rewrite_rule[])
		),
	   (DROP_NTH_ASM_T 1 (rewrite_thm_tac o rewrite_rule[z_ç_succ_thm]) THEN
		DROP_NTH_ASM_T 1 (rewrite_thm_tac o rewrite_rule[z_ç_succ_thm])),
	   (z_∂_tac Òx1 + 1Æ THEN PC_T "z_rel_ext" (REPEAT z_strip_tac) THEN
		rewrite_tac[z_ç_succ_thm] THEN
		DROP_NTH_ASM_T 1 (strip_asm_tac o rewrite_rule[]) THEN
		all_asm_fc_tac[z_º_trans_thm])	
	  ]
	  ));
=TEX
=SML
val local_Ú_succ_rel_inv_thm = tac_proof(
	([],  ¨µ f j k ∑ Ò 0 º j ¥
			(f = ((j .. k) Ú succ) Á~Í) ¥
			(µ i : j + 1 .. k + 1∑ f i = i + ~ 1)ÆÆ),
	  PC_T "z_library1"
	  (REPEAT strip_tac THEN
	  DROP_NTH_ASM_T 3 rewrite_thm_tac THEN
	  z_app_eq_tac THEN
	  rewrite_tac[z_rel_inv_thm, z_Ú_thm, z_ç_succ_thm] THEN
	  rewrite_tac[z_plus_assoc_thm] THEN
	  PC_T1 "z_lin_arith1" asm_prove_tac[]
	  ));
=SML
=TEX
=SML
val local_Ú_succ_rel_inv_sig_thm = (
	push_pc "z_library1";
	set_goal([],  ¨µ f j k ∑ Ò 0 º j ¥
			(f = ((j .. k) Ú succ) Á~Í) ¥
			(f ç j + 1  .. k + 1 ≠ (j .. k))ÆÆ);
	a(REPEAT strip_tac THEN
	  DROP_NTH_ASM_T 1 rewrite_thm_tac THEN
	  PC_T "z_fun_ext" (REPEAT z_strip_tac));
	(* *** Goal "1" *** *)
	a(DROP_NTH_ASM_T 1 (strip_asm_tac o rewrite_rule[z_ç_succ_thm]) THEN
		all_var_elim_asm_tac1 THEN
		rewrite_tac[] THEN
		DROP_NTH_ASM_T 2 (rewrite_thm_tac o rewrite_rule[]));
	(* *** Goal "2" *** *)
	a(DROP_NTH_ASM_T 1 (strip_asm_tac o rewrite_rule[z_ç_succ_thm]) THEN
		DROP_NTH_ASM_T 3 (strip_asm_tac o rewrite_rule[z_ç_succ_thm]) THEN
		all_var_elim_asm_tac1 THEN
		DROP_NTH_ASM_T 1 (rewrite_thm_tac o rewrite_rule[]));
	(* *** Goal "4" *** *)
	a(z_∂_tac Òx1 + (~ 1)Æ THEN rewrite_tac[z_rel_inv_thm, z_Ú_thm, z_ç_succ_thm]	THEN
		DROP_NTH_ASM_T 1 (strip_asm_tac o rewrite_rule[]) THEN
		PC_T1 "z_lin_arith1" asm_prove_tac []);
	pop_pc();
	pop_thm ()
);

=SML
val local_set_abs_thm = (
	  set_goal([],  ¨µ f master index X Y ∑ Ò
			(f = {u : master | dom u = index}) ¥
			(master ç  (X ﬂ Y)) ¥
			f = (index ≠ Y) ° master
			ÆÆ);
		push_pc "z_library1";
		a(strip_tac THEN strip_tac THEN strip_tac THEN strip_tac THEN strip_tac);
		a(¥_T rewrite_thm_tac);
		a(PC_T1 "z_fun_ext" rewrite_tac[]);
		a(strip_tac THEN z_µ_tac THEN strip_tac);
		a(POP_ASM_T (strip_asm_tac o z_µ_elim Òx1Æ));
(* *** Goal "1" *** *)
		a(asm_rewrite_tac[]);
(* *** Goal "2" *** *)
		a(cases_tac Òx1 ç masterÆ THEN asm_rewrite_tac[]);
		a(DROP_NTH_ASM_T 1 discard_tac);
		a(CASES_T (fst(dest_z_§(snd(top_goal()))))
			(fn t => rewrite_tac[t] THEN asm_tac t));
		a(REPEAT strip_tac);
(* *** Goal "2.1" *** *)
		a(asm_fc_tac[]);
(* *** Goal "2.2" *** *)
		a(asm_fc_tac[]);
(* *** Goal "2.3" *** *)
		a(z_spec_nth_asm_tac 7 Ò(x ¶ x, y1 ¶ y1, y2 ¶ y2)Æ);
		a(z_spec_nth_asm_tac 9 Ò(x2 ¶ x, x3 ¶ y1)Æ);
		pop_pc();
		pop_thm()
	  );
=TEX
Now the normalisation of Z horizontal schemas signatures:
=SML
val €z_norm_sig_h_schema_conv› : CONV = (fn tm =>
let	val (d,p) = dest_z_h_schema tm
		handle exn => reraise exn "z_norm_sig_h_schema_conv";
	val decs = dest_z_decl d;
	val ddecs = mapfilter dest_z_dec decs;
	val otherdecs = filter (not o is_z_dec) decs;
	val flat_ddecs = flat (map
		(fn (vs,ty) => map (fn x => (fst(dest_var x), ([x], ty))) vs)
		ddecs);
	val sorted_flat_ddecs = map snd (Sort.sort
		(fn (s1,(_,ty1)) => fn (s2,(_,ty2)) =>
		 if s1 = s2
		 then Sort.string_order (string_of_term ty1) (string_of_term ty2)
		 else ZTypesAndTermsSupport.z_sig_order s1 s2)
		flat_ddecs);
	val rhs = mk_z_h_schema(mk_z_decl (map mk_z_dec sorted_flat_ddecs
			@ otherdecs), p);
in
	if (tm ~=$ rhs)
	then refl_conv tm
	else
	tac_proof(([], mk_z_eq (tm, rhs)),
		PC_T "z_library1" (
			conv_tac z_sets_ext_conv THEN z_µ_tac THEN z_strip_tac THEN
			conv_tac (ONCE_MAP_C z_ç_h_schema_conv) THEN
			TRY_T(conv_tac (MAP_C z_setd_Ä_conv)) THEN
			taut_tac
		)
	)
end
);

=TEX
The following could be made local to $cn\_simplify\_thm$, but for
development purposes they are pervasive in the module.

We rely on the fact that users shouldn't introduce \Product\ variables with
names prefixed by $pp'$, expecially as these are not valid Z names.
If they do, then patterns won't match.
=IGN
local
=SML
	val nat = ÒÓÆ;
	val nat0 = Ò0Æ;
	val pat1 = Òid ¨pp'nameÆÆ;
	val pat2 = Ò¨pp'nameÆ Á~ÍÆ;
	val pat3 = Ò ( ¨pp'nameÆ \ { ¨pp'lstÆ } ) Ú succÆ;
	val pat4= Ò {u : ¨pp'masterÆ | dom u = ¨pp'indexÆ } Æ;
	val pat5 = Ò¨pp'lhsÆ = ( ¨pp'firstÆ .. ¨pp'lstm1Æ  ) Ú succÆ;
	val pat6 = Ò¨pp'lhsÆ = (( ¨pp'firstÆ .. ¨pp'lstm1Æ  ) Ú succ) Á~ÍÆ;
	val pat7 = Ò¨pp'masterÆ ç  ( ¨pp'XÆ ﬂ ¨pp'YÆ)Æ;

	val local_rw_rule = pure_rewrite_rule[z_plus_assoc_thm,
		±_right_elim(z_get_spec Ò(_ - _)Æ), z_minus_clauses,
		z_plus0_thm];
	val local_rw_rule1 = pure_once_rewrite_rule[local_dot_dot_diff_thm];
=TEX
Match:
=GFT
Ù f = id name
=TEX
=SML	
	fun pat1_canon thm =
	(let 	val (lhs, rhs) = dest_z_eq (concl thm);
		val name = match1 rhs pat1;
		val thm1 = list_µ_elim [name, lhs] local_id_thm;
		val thm2 = ¥_elim thm1 thm;
		val thm3 = list_µ_elim [name, lhs] local_id_sig_thm;
		val thm4 = ¥_elim thm3 thm;
	in
		[thm2, thm4]
	end);
=TEX
Match:
=GFT
Ù f = (name \ {last} ) Ú succ
=TEX
=IGN
pat3_canon (z_get_spec ÒDAYvSUCCÆ);
=SML
	fun pat3_canon thm =
	(let 	val (lhs, rhs) = dest_z_eq (concl thm);
		val (last, name) = match2 rhs pat3;
		val nm1_spec = z_get_spec name;
		val (nm1_lhs, nm1_rhs) = dest_z_eq (concl nm1_spec);
		val (nm2, ty2, []) = dest_z_gvar nm1_lhs;
		val thm1 = conv_rule (ONCE_MAP_C (eq_match_conv nm1_spec)) thm;
		val last_spec = z_get_spec last;
		val (last_lhs, last_rhs) = dest_z_eq (concl last_spec);
		val (nm3, ty3, _) = dest_z_gvar last_lhs;
		val thm2 = conv_rule (ONCE_MAP_C (eq_match_conv last_spec)) thm1;
		val thm3 = local_rw_rule1 thm2;
		val (_, first, _) = match3 (concl thm3) pat5;
		val first_spec = z_get_spec first;
		val first2 = snd(dest_eq (concl first_spec));
 		val thm4 = §_t_elim (z_º_conv (mk_z_º (nat0, first2)));
		val thm5 = conv_rule (LEFT_C (RIGHT_C
			(eq_match_conv (eq_sym_rule first_spec)))) thm4;
		val last2 = mk_z_plus(last_rhs, Ò~ 1Æ);
		val thm6 = list_µ_elim [lhs, first, last2]
			local_Ú_succ_thm;
		val thm7 = ¥_elim (¥_elim thm6 thm5) thm3;
		val thm8 = list_µ_elim [lhs, first, last2] local_Ú_succ_sig_thm;
		val thm9 = local_rw_rule (¥_elim (¥_elim thm8 thm5) thm3);
	in
		[thm7, thm9]
	end);
=TEX
Match:
=GFT
Ù f = g Á~Í
=TEX
Two cases - matching $g$ being the two cases above.
=IGN
pat2_canon (z_get_spec ÒDAYvPREDÆ);
=SML
	fun pat2_canon thm =
	(let 	val (lhs, rhs) = dest_z_eq (concl thm);
		val name = match1 rhs pat2;
		val (nm1, ty1, _) = dest_z_gvar name;
		val nm1_spec = z_get_spec name;
		val (nm1_lhs, nm1_rhs) = dest_z_eq (concl nm1_spec);
		val (nm2, ty2, _) = dest_z_gvar nm1_lhs;
		val thm1 = conv_rule (ONCE_MAP_C (eq_match_conv nm1_spec)) thm;
	in
		(let	val name2 = match1 nm1_rhs pat1;
			val thm2 = conv_rule (ONCE_MAP_C (eq_match_conv local_id_rel_inv_thm)) thm1;
			val thm3 = list_µ_elim [name2, lhs] local_id_thm;
			val thm4 = ¥_elim thm3 thm2;
			val thm5 = list_µ_elim [name2, lhs] local_id_sig_thm;
			val thm6 = ¥_elim thm5 thm2;
		in
			[thm4, thm6]
		end)
		handle (Fail _) =>
		(let	val (last, nm2) = match2 nm1_rhs pat3;
			val nm2_spec = z_get_spec nm2;
			val (nm2_lhs, nm2_rhs) = dest_z_eq (concl nm2_spec);
			val (nm3, ty3, _) = dest_z_gvar nm2_lhs;
			val thm2 = conv_rule (ONCE_MAP_C (eq_match_conv nm2_spec)) thm1;
			val last_spec = z_get_spec last;
			val (last_lhs, last_rhs) = dest_z_eq (concl last_spec);
			val (nm4, ty4, _) = dest_z_gvar last_lhs;
			val thm3 = conv_rule (ONCE_MAP_C (eq_match_conv last_spec)) thm2;
			val thm4 = local_rw_rule1 thm3;
			val (_, first, _)= match3 (concl thm4) pat6;
			val first_spec = z_get_spec first;
			val first2 = snd(dest_eq (concl first_spec));
 			val thm5 = §_t_elim (z_º_conv (mk_z_º (nat0, first2)));
			val thm6 = conv_rule (LEFT_C (RIGHT_C
				(eq_match_conv (eq_sym_rule first_spec)))) thm5;
			val last2 = mk_z_plus(last_rhs, Ò~ 1Æ);
			val thm7 = list_µ_elim [lhs, first, last2]
				local_Ú_succ_rel_inv_thm;
			val thm8 = ¥_elim (¥_elim thm7 thm6) thm4;
			val thm9 = local_rw_rule thm8;
			val thm10 = list_µ_elim [lhs, first, last2]
				local_Ú_succ_rel_inv_sig_thm;
			val thm11 = ¥_elim (¥_elim thm10 thm6) thm4;
			val thm12 = local_rw_rule  thm11;
		in
			[thm9, thm12]
		end)
	end);
=TEX
Match:
=GFT
Ù f = {u : master | dom u = index}
=TEX
=SML
	fun pat4_canon thm =
	(let 	val (lhs, rhs) = dest_z_eq (concl thm);
		val (index, master) = match2 rhs pat4;
		val master_spec = ±_left_elim (z_get_spec master);
		val (Y, X, _) =
			match3 (concl master_spec) pat7;
		val thm1 = list_µ_elim[lhs, master, index, X, Y]
			 local_set_abs_thm;
		val thm2 = ¥_elim (¥_elim thm1 thm) master_spec;
	in
		[thm2]
	end);
=IGN
in (* local patterns and canons *)
=TEX
=SML
fun €cn_simplify_canon› (thm: THM) : THM list = (
	if not (imp517_thy mem get_ancestors "-")
	then fail "cn_simplify_canon" 517006 []
	else ();
let 	val cnc = concl thm;
	val (lhs, rhs) = dest_z_eq cnc;
	val dummy = dest_z_gvar lhs;
in
=TEX
Match:
=GFT
Ù f = id name
=TEX
=SML
	(let 	val name = match1 rhs pat1;
	in
		pat1_canon thm
	end)
	handle (Fail _) =>
=TEX
Match:
=GFT
Ù f = (name \ {last} ) Ú succ
=TEX
=SML
	(let 	val (last, name) = match2 rhs pat3;
	in
		pat3_canon thm
	end)
 	handle (Fail _) =>
=TEX
Match:
=GFT
Ù f = g Á~Í
=TEX
Two cases - matching $g$ being the two cases above.
=SML
	(let 	val name = match1 rhs pat2;
	in
		pat2_canon thm
	end)
	handle (Fail _) =>
=TEX
Match:
=GFT
Ù f = {u : master | dom u = index}
=TEX
=SML
	(let 	val (index, master) = match2 rhs pat4;
	in
		pat4_canon thm
 	end)
	handle (Fail _) =>
=TEX
deal with horizontal schemas:
=SML
	[conv_rule (RIGHT_C z_norm_sig_h_schema_conv) thm]
end)
handle (Fail _) => []
=IGN
end (* of local patterns and canons *)
=SML
;
=TEX
The following doesn't defend its self against bad input.
=SML
fun €strip_decls_canon› (thm : THM) : THM list = (
	if is_± (concl thm)
	then (
		strip_decls_canon (±_left_elim thm) @
		strip_decls_canon (±_right_elim thm))
	else ((let val thm1 = (conv_rule z_setd_Ä_conv thm)
		in
			strip_decls_canon thm1
		end)
		handle (Fail _) =>
		(if is_z_ç (concl thm)
		then (let val (a, _) =  dest_z_ç (concl thm)
			in
			if (is_z_gvar a orelse is_z_binding a)
			then [thm]
			else []
			end)
		else []))
);
=IGN
strip_decls_canon (±_left_elim (z_get_spec Ò(not_)Æ));
=TEX
=SML
fun remove_underscores (nm: string): string = (
let val enm = explode nm;
	val enm1 = case (rev enm) of
		("_" :: " " :: rest) => rev rest
		| _ => enm;
	val enm2 = case enm1 of
		("_" :: " " :: rest) =>  rest
		| _ => enm1;
in
	implode enm2
end);
=TEX
The following is the same as the pure equivalent, except for the call to
$cn\_simplify\_rule$.
=IGN
map (fn x => (x, (cn_spec_rule x handle (Fail _) => [])))
(map snd
(flat(map (fn y => get_defns y @ get_axioms y) (get_ancestors "-" diff
		get_ancestors "cn"))));
map (fn x => (x, (cn_spec_rule x handle (Fail _) => [])))
(map snd
(flat(map (fn y => get_defns y @ get_axioms y) ["Alarm_body"])));
val it = ["SHOLSELECTIONspec", "SENSORspec", "BASICTYPESspec", "Alarm_body"] : string
cn_spec_rule (get_spec Ò(not_)Æ);
cn_spec_rule(get_spec Ò(bag_)Æ);
=SML
local val tru = ÒtrueÆ
in
fun €cn_spec_rule› (thm : THM) : (string * THM) list = (
let	val cthm = concl thm;
in
	if not (imp517_thy mem get_ancestors "-")
	then fail "cn_spec_rule" 517006 []
	else ();
	if is_eq cthm andalso is_u(snd(dest_eq cthm))
	then (let val (full_nm, _, _) = dest_z_gvar(fst(dest_eq cthm)) ;
		    val nm = remove_underscores full_nm;
		in
		[("cn_" ^ nm ^ "_thm", thm)]
		end)
	else if is_app cthm andalso
		(fst (dest_app cthm) =$ ¨$"Z'Constraint"Æ)
	then thm_fail "cn_spec_rule" 517004 [thm]
		 (* can't get names from constraints *)
	else
(let	val thm0 = conv_rule z_para_pred_conv thm
		handle (Fail _) => thm_fail "cn_spec_rule" 517004 [thm];
		(* fail if not a Z para *)
	val thm1 = all_µ_elim thm0;
in
	map (fn (n, t) => (n, all_µ_intro t)) (* reintroduce variables *)
	(case (dest_z_term (concl thm1)) of
	ZEq(lhs, rhs) => (     (* Given sets, abreviation defns, schema boxes *)
		if is_z_gvar(lhs)
		then (
		let val (full_nm, _, _) = dest_z_gvar lhs;
		    val nm = remove_underscores full_nm;
		    val r = cn_simplify_canon thm1;
		in
			case r of
			[thm2, thm3] => [("cn_" ^ nm ^ "_thm", thm2),
				("cn_" ^ nm ^ "_sig_thm", thm3)]
			| [thm2] => [("cn_" ^ nm ^ "_thm", thm2)]
			| _ => [("cn_" ^ nm ^ "_thm", conv_rule
			(TRY_C (PC_C1 "z_library1" rewrite_conv [] )) thm1)]
		end)
		else (warn "cn_spec_rule" 517007 [fn () => string_of_term lhs];
			[])
	) | Z± (a, b) => ( (* axiomatic box with decl, free type defns *)
	let	val a_thms = strip_decls_canon (±_left_elim thm1);
		val (names, a_outs) = split (flat
			(map (fn x =>
			let val (m, t) = dest_z_ç (concl x);
			in
				if is_z_gvar m
				then (let
					val (full_nm, _, _) = dest_z_gvar m;
		    			val nm = remove_underscores full_nm;
				in
					[(nm, ("cn_"  ^ nm ^ "_sig_thm", x))]
				end)
				else (let val nms = fst(split(dest_z_binding m));
				in
				map (fn nm => (remove_underscores nm, ("cn_"  ^
					remove_underscores nm ^ "_sig_thm", x))) nms
				end)
			end)
			a_thms));
		val b_proper_thm = conv_rule
			(TRY_C (PC_C1 "z_library1" rewrite_conv [] ))
			(±_right_elim thm1);
		val b_outs = (if (b ~=$ tru)
			then []
			else map
				(fn nm => ("cn_"  ^ nm ^ "_thm", b_proper_thm))
				 names
		);
	in
		a_outs @ b_outs
	end
	) | _ => thm_fail "cn_spec_rule" 517004 [thm]
		(* axiomatic box w/o decl *)
	)
	handle (exn as Fail _) =>
		reraise exn "cn_spec_rule"

end)
end); (* cthm let *)
end; (* local *)
=TEX
The following are just the same as the pure tools but with a name change.
=SML
fun €list_cn_spec_rule› (thms : THM list) : THM list = (
	if not (imp517_thy mem get_ancestors "-")
	then fail "cn_script_support_thms" 517006 []
	else ();
	aux_list_cn_spec_rule cn_spec_rule "list_cn_spec_rule" thms
);
=TEX
=SML
fun €cn_script_support_thms› (nm : string) : THM list = (
	if not (imp517_thy mem get_ancestors "-")
	then fail "cn_script_support_thms" 517006 []
	else ();
	aux_cn_script_support_thms cn_spec_rule "cn_script_support_thms" nm
);
=TEX
We choose the following presentation to catch any unknown or out of scope theory
names before we do any saving.
We use $cup$ to delete duplicates.
=SML
fun €list_cn_script_support_thms› (in_nms : string list) : THM list = (
	if not (imp517_thy mem get_ancestors "-")
	then fail "list_cn_script_support_thms" 517006 []
	else ();
	aux_list_cn_script_support_thms cn_spec_rule
		"list_cn_script_support_thms" in_nms
);
=TEX

\subsection{Proof Contexts}
If the index to the equaltion context entry isn't of type BOOL then it can't be
used in stripping.
=SML
fun €maybe_strip› (index,cnv) = (
	if type_of index =: BOOL
	then (index,cnv)
	else fail "" 0 []
);
=TEX
If the index in an equation context is a set type,m then we can promote the
entry to be an equation of memberships.
=SML
local
	val setty = type_of Ò{}Æ;
in
fun €add_ç› ((index,cnv)::rest) = (
	(let val tyms = type_match (type_of index) setty @ [(î'aÆ,î'aÆ)];
		val x = variant (frees index) (mk_var("x",fst(hd tyms)));
	in
		((mk_z_ç(x,index), ç_C cnv) :: (index,cnv) :: add_ç rest)
	end)
	handle (Fail _) =>
	((index,cnv) :: add_ç rest)
) | add_ç [] = [];
end;
=TEX
=SML
local
	val pat = Òx = ÉÆ;
in
fun €is_U_eqn› (thm : THM) : bool = (
	(term_match (concl thm) pat; true) handle (Fail _) => false
);
end;

=TEX
Given a list of theorems create an equation context:
=SML
fun €thms_to_eqn_cxt› (thms:THM list) : EQN_CXT = (
let	val dummy1 = push_pc "cn1";
	val res = flat(map (cthm_eqn_cxt(current_ad_rw_canon())) thms);
	val dummy2 = pop_pc();
in
	res
end);
=TEX
Create a proof context from a list of theorems, as called for in
detailed design.
In theory the following can't fail.
=SML
fun €local_make_pc› (fname : string) (in_thms : THM list) (pcname : string) : unit = (
let 	val dummy_pc1 = push_pc "cn1";
	val sort_thms = union (op ~=|-) in_thms []; (* probably already done *)
	val thms = filter (fn x =>
		((z_ç_u_conv (concl x); false) handle (Fail _) => true))
		sort_thms;
	val u_thms = filter is_U_eqn thms;
	val not_u_thms = filter (fn x => not(is_U_eqn x)) thms;
	val source_ec = add_ç(thms_to_eqn_cxt not_u_thms);
	val ec_for_strip = mapfilter maybe_strip source_ec;
	val dummy1 = delete_pc pcname handle Fail _ => ();
	val dummy2 = new_pc pcname;
	val dummy3 = merge_pcs ["cn1"] pcname;
	val dummy4 = add_rw_thms not_u_thms pcname;
	val pos = ec_for_strip;
	val neg = map (mk_≥ ** RAND_C) pos;
	val dummy5 = set_st_eqn_cxt (pos @ neg) pcname;
	val dummy6 = set_sc_eqn_cxt (pos @ neg) pcname;
	val dummy7 = set_u_simp_eqn_cxt (u_simp_eqn_cxt u_thms) pcname;
	val dummy8 = set_pc_z_ç_rules
		(pc_z_ç_rules_of_thms [pcname] not_u_thms)
		pcname;
	val dummy9 = commit_pc pcname;
 	val dummy_pc2 = pop_pc ();
in
	()
end);
=IGN
val thms = cn_make_script_support "cn" "cn_pc";
val nets = get_pc_z_ç_rules "cn_pc";
val enets = map (fn (net, nm) => (nm,
	map (fn (x,y) => (x, y x)) net)) nets;
=TEX
Now to use it:
=SML
fun €cn_make_script_support› (nm : string) (pcname : string) : THM list = (
	if not (imp517_thy mem get_ancestors "-")
	then fail "cn_make_script_support" 517006 []
	else ();
let val thms = aux_cn_script_support_thms cn_spec_rule "cn_script_support_thms" nm;
	val dummy = local_make_pc "cn_make_script_support" thms pcname;
in
	thms
end);
=TEX
We choose the following presentation to catch any unknown or out of scope theory
names before we do any saving.
We use $cup$ to delete duplicates.
=SML
fun €list_cn_make_script_support› (in_nms : string list) (pcname : string) : THM list = (
	if not (imp517_thy mem get_ancestors "-")
	then fail "list_cn_make_script_support" 517006 []
	else ();
let 	val thms = aux_list_cn_script_support_thms cn_spec_rule
		"list_cn_script_support_thms" in_nms;
	val dummy = local_make_pc "list_cn_script_support_thms" thms pcname;
in
	thms
end);
=TEX
=SML
fun €all_cn_make_script_support› (pcname : string) : THM list = (
	if not (imp517_thy mem get_ancestors "-")
	then fail "all_cn_make_script_support" 517006 []
	else ();
	list_cn_make_script_support
		(((get_ancestors "-") diff (get_ancestors "cn")))
		pcname
);
=TEX

\section{EPILOGUE}
=SML
end (* of structure CNTheoryProofSupport *);
open CNTheoryProofSupport;
pop_pc();
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}

