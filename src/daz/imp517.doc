% %Z%
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: Theory Proof Support}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP517}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Implementation}
\TPPkeywords{HOL}
\TPPauthor{K.~Blackburn&WIN01}
\TPPauthorisation{R.D.~Arthan & DAZ Team Leader}
\TPPabstract{
This is the implementation of methods of making the paragraphs generated by the compliance notation available to the user in a
normalised form.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issues 1.1] Initial Versions.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
This document contains the implementation for the Theory Proof Support tools.
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD517}.

\subsection{Introduction}

\subsection{Purpose and Background}

\subsection{Algorithms}

\subsection{Dependencies}

\subsection{Known Deficencies}

\subsection{Possible Enhancements}
\section{PROLOGUE}
=IGN
structure ÛCNTheoryProofSupportÝ : CNTheoryProofSupport = struct
=TEX
=SML

local val tru = ñtrue®
in
fun Ûcn_support_thmÝ (thm : THM) : string * THM = (
	if is_eq (concl thm) andalso is_u(snd(dest_eq (concl thm)))
	then (let val ZGVar (nm, ty, []) = dest_z_term(fst(dest_eq (concl thm))) ;
		in ("cts_" ^ nm ^ "_thm", thm)
		end)
	else
let	val thm1 = conv_rule z_para_pred_conv thm;
in
	case (dest_z_term (concl thm1)) of
	ZEq(lhs, rhs) => (
		let val ZGVar (nm, ty, []) = dest_z_term lhs;
		in
			("cts_" ^ nm ^ "_thm", thm1)
		end
	) | Z± (a, b) => (
		if (b ~=$ tru) andalso is_z_ a
		then (let val ZGVar (nm, ty, []) = 
				dest_z_term (fst (dest_z_ a)) ;
		in
			("cts_"  ^ nm ^ "_thm", ±_left_elim thm1)
		end)
		else thm_fail "cn_support_thm" 517003 [thm]
	) | _ => thm_fail "cn_support_thm" 517003 [thm]
end)
handle _ => 
	thm_fail "cn_support_thm" 517003 [thm];
end;
=TEX
=SML
fun Ûoverride_save_thmÝ (nm : string, thm : THM) : THM = (
	save_thm (nm, thm)
	handle _ => (
		let 
			val old_thm = get_thm "-" nm;
			val thy_nm = get_current_theory_name();
		in
			(warn "override_save_thm" 517001 [(fn _ => nm), (fn _ => thy_nm)];
			delete_thm nm;
			save_thm (nm, thm)
			)
		end
		handle _ => fail "override_save_thm" 517002 [(fn _ => nm),
				 	get_current_theory_name]
	)
);
=TEX
=SML
fun Ûcn_support_thmsÝ (thms : THM list) (nm : string) : unit = (
	use_string ("val " ^ nm ^ ": THM list = [];")
		handle _ => fail "cn_support_thms" 517003 [fn _ => nm];
(let 	val thms1 = mapfilter cn_support_thm thms;
	val dummy1 = map override_save_thm thms1;
	val dummy2 = map (fn (nm1,_) => use_string
		("val "^nm1^ ":THM = get_thm \"-\" \""^nm1^"\";")) thms1;
	val all_of1 = fold (fn (a,b) => a ^ ", " ^ b)
		 (map (fn (nm1,_) => "get_thm \"-\" \""^nm1^"\"") thms1)
		 "t_thm";
	val all_of2 = "val "^nm^" = rev(tl(rev ["^all_of1^"]))";
	val dummy3 = use_string all_of2;
in
	()
end));


=TEX
=SML
fun Ûcn_support_theoryÝ (nm : string) : unit = (
let 	val thms = map snd (get_defns nm @ get_axioms nm)
		handle exn => reraise exn "cn_support_theory";
	val thms1 = mapfilter cn_support_thm thms;
	val dummy1 = map override_save_thm thms1;
	val dummy2 = map (fn (nm1,_) => use_string
		("val "^nm1^ ":THM = get_thm \"-\" \""^nm1^"\";")) thms1;
	val all_of1 = fold (fn (a,b) => a ^ ", " ^ b)
		 (map (fn (nm1,_) => "get_thm \"-\" \""^nm1^"\"") thms1)
		 "t_thm";
	val all_of2 = "val cn_"^nm^"_thms = rev(tl(rev ["^all_of1^"]))";
	val dummy3 = use_string all_of2;
in
	()
end);
=TEX
We choose the following presentation to catch any unknown or out of scope theory 
names before we do any saving.
We use $cup$ to delete duplicates.
=SML
fun Ûlist_cn_support_theoryÝ (in_nms : string list) : unit = (
let 	val nms = in_nms cup [];
	val thmsl = map (fn nm => 
		map snd (get_defns nm @ get_axioms nm)
		handle exn => reraise exn "list_cn_support_theory") nms;
	val thms1l = map (fn thms => mapfilter cn_support_thm thms) thmsl;
	val dummy1 = map (fn thms1 => map override_save_thm thms1) thms1l;
	val dummy2 = map (fn thms1 => map 
		(fn (nm1,_) => use_string
		("val "^nm1^ ":THM = get_thm \"-\" \""^nm1^"\";")) thms1) thms1l;
	val all_of1l = map (fn thms1 => 
		 fold (fn (a,b) => a ^ ", " ^ b)
		 (map (fn (nm1,_) => "get_thm \"-\" \""^nm1^"\"") thms1)
		 "t_thm") thms1l;
	val all_of2l = map (fn (nm,all_of1) => 
		"val cts_"^nm^"_thms = rev(tl(rev ["^all_of1^"]))")
		(combine nms all_of1l);
	val dummy3 = map use_string all_of2l;
in
	()
end);
=TEX

=SML

=TEX
\section{EPILOGUE}
=IGN
end (* of structure CNTheoryProofSupport *);
open CNTheoryProofSupport;
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}

¹CN
procedure P is
   type FIX is delta 0.1 range 5.1 .. 10.0;
begin 
   null;
end P;
°
