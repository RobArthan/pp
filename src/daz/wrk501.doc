=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation of First 1000 Primes Example}  %% Mandatory field
\def\TPPheadtitle{First 1000 Primes Example}
\TPPref{ISS/HAT/DAZ/WRK001}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}  %% Mandatory field (with sensible default)
\TPPstatus{Informal}
%\TPPstatus{Informal}
\TPPtype{Technical}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{R.D.~Arthan & HAT Manager}
\TPPabstract{%
This document gives an experimental implementation ``Refinement of Z to SPARK: First 1000 Primes'', DRA/CIS/CSE3/SW1/WP/5/2.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents list}
\tableofcontents
\subsection{Document cross references}
\bibliographystyle{fmu}
\bibliography{fmu,daz}

\subsection{Changes history}  % to get section number `0.3'
\begin{description}
\item[Issue \SCCSversion] First issue for distribution.
\end{description}
\subsection{Changes forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}
\section{PRELIMINARIES}
=IGN
set_flag ("z_type_check_only", true);
new_theory"primes";
new_parent"z_library";
=TEX

\section{THE LITERATE SCRIPT}

¹Z
Ü	prime ¦ { n : î‰1 | ³(¶ i, j : î‰1 \ {1} · i * j = n)}
°

¹Z
Ü	not_prime ¦ î‰1 \ prime
°

¹Z
Ü	rel     _ next_prime _
°

¹ZAX
Ü	_ next_prime_ : î‰1 ª î‰1
÷üüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	(_ next_prime _) =
Ü	{i, j : î‰1 | i  prime ± j  prime ± j>i ± (i+1)..(j+1) € not_prime}
°

¹Z
Ü	primed ¦ {p : seq‰1 î‰1 | p(1) = 2 ±
Ü			(µ i : dom p \ {1} · p(i-1) next_prime p(i))}
°

¹CN
procedure primes is
subtype Indexrange is Integer range 1..1000;
type Arraytype is array (Indexrange) of Integer;
p : Arraytype;

§ other declarations ¢				(1)
§ other declarations ¢				(2)
§ other declarations ¢				(3)

begin

„ p [true, primed p] (50)

end primes;
°

¹CN
(3) %identical%

j, k : integer;
°

¹Z
Ü	odd ¦ {n : î‰1 | µ i : î‰1 · n ½ 2 * i}
°

ÿ Inv1üüüüüüüüüüüüü
Ü	p : Arraytype;
Ü	j, k : ú
÷üüüüü
Ü	((1..k-1)òp)  primed;
Ü	j = p(k-1);
Ü	j  odd
ˆüüüüüüüüüü

¹CN
%sqsubseteq% „ j,k,p [true, Inv1 ± k = 1001]
°

¹CN
(4) %identical%

ord, square : Integer;
ord_max : constant Integer := 30;
subtype mult_index_type is Integer range 2..ord_max;
type mult_type is array (mult_index_type) of Integer;
mult : mult_type;
°

ÿ ord_invüüüüüüüüüüüüü
Ü	p : Arraytype;
Ü	j, k, ord, square : ú
÷üüüüü
Ü	ord > 1;
Ü	square = p(ord) * p(ord);
Ü	j < square;
Ü	ord < k;
Ü	ord = 2 ´ j  prime
ˆüüüüüüüüüü

¹Z
Ü	rel     _ factor_of _
°

¹ZAX
Ü	_ factor_of _ : î‰1 ª î‰1
÷üüüüüüüüüüüüüüüüüüüüüüüüüü
Ü	(_ factor_of _) =
Ü	{i, n : î‰1 | ¶ j : 2..(n-1) · i * j = n}
°

ÿ mult_invüüüüüüüüüüüüü
Ü	p : Arraytype;
Ü	mult : mult_type;
Ü	ord, j : ú
÷üüüüü
Ü	µ n : 2..(ord - 1) ·
Ü	mult(n)  odd ±
Ü	p(n) factor_of mult (n) ±
Ü	(mult(n) < j ²
Ü		mult(n) - 2 * p(n) < j ¼ mult(n))
ˆüüüüüüüüüü

¹Z
Ü	Inv ¦ ord_inv ± mult_inv
°

¹CN
%sqsubseteq%

p(1) := 2;
p(2) := 3;
j := 3;
k := 3;
ord := 2;
square := 9;

„ j,k,p,ord,square,mult [Inv1 ± Inv, Inv1 ± Inv ± k = 1001]
°


¹CN
%sqsubseteq%

while k /= 1001
loop
	„ j,k,p,ord,square,mult [Inv1 ± Inv, Inv1 ± Inv]
end loop;
°

ÿ Inter1üüüüüüüüüüüüü
Ü	p : Arraytype;
Ü	j, k : ú
÷üüüüü
Ü	((1..k-1) ò p)  primed;
Ü	p(k - 1) next_prime j;
Ü	j  odd
ˆüüüüüüüüüü

¹CN
%sqsubseteq%

„ j, ord, square, mult [Inv1 ± Inv, Inter1 ± Inv]
p(k) := j;
k := k+1;
°

¹CN
%sqsubseteq%
con lastj : ú · „ j, ord, square, mult
	[lastj = j ± Inv1 ± Inv, lastj next_prime j ± Inv]
°

ÿ Inv2üüüüüüüüüüüüü
Ü	p : Arraytype;
Ü	j, k : ú
÷üüüüü
Ü	lastj = p(k - 1);
Ü	j ¾ lastj;
Ü	(lastj + 1) .. (j-1) € not_prime;
Ü	((1..k - 1) ò p)  primed;
Ü	j  odd
ˆüüüüüüüüüü

¹CN
%sqsubseteq%

till ûInv2 ± j > lastk  prime ± Invı
loop
	„ j, ord, square, mult [Inv2 ± Inv ± (prime j ´ last j = j),
		Inv2 ± Inv ± j  prime]

end loop;
°

¹CN
(3) %identical%

jprime : Boolean;
°

¹CN
%sqsubseteq%

	„ j, ord, square, mult [Inv2 ± Inv ± (prime j ´ last j = j),
		Inv2 ± Inv ± j = j‰0 + 2]
	„ jprime, mult [Inv2 ± Inv ± j > last j,
		Inv2 ± Inv ± j > last j ± jprime = j mem prime]		(4)
exit when jprime;
°

¹CN
%sqsubseteq%

j := j + 2;
if j = square
then
	ord := ord + 1;
	square := p(ord) * p(ord);
	mult (ord-1) := j;
end if;
°

¹CN
(6) %sqsubseteq%

jprime := true;
„ jprime, mult [Inv2 ± Inv ± j > jprime = TRUE,
		Inv2 ± Inv ± jprime = j mem prime]
°

ÿ Inv3üüüüüüüüüüüüü
Ü	p : Arraytype;
Ü	j, ord, n : ú;
Ü	jprime : BOOLEAN
÷üüüüü
Ü	n  2..(ord - 1);
Ü	µ m : 2.. (n-1) · ³(p(m) factor_of j);
Ü	jprime = TRUE
Ü	j  odd
ˆüüüüüüüüüü

¹CN
%sqsubseteq%

for n in Integer range 2 .. (ord - 1)
till ûp(n) factor_of j ± jprime = FALSE ± Invı

loop
	„ jprime, mult [Inv3 ± Inv,
			Inv3 ± Inv ± ³(p(n) factor_of j)]
end loop;
°

¹CN
%sqsubseteq%

„ jprime, mult [Inv3 ± mult_inv,
	mult_inv ± (p(n) factor_of j ¤ jprime = FALSE)]

exit when not jprime;
°

¹CN
%sqsubseteq%
„ mult[mult_inv, mult_inv ± mult(n) ¾ j]
„ jprime [mult_inv ± mult(n) ¾ j,
		mult_inv ± mult(n) ¾ j ± jprime = mult (n) noteq j]	(5)
°

¹CN
%sqsubseteq%

while mult(n) < j
loop
	„ mult [mult_inv ± mult(n) < j, mult_inv]
end loop;
°

¹CN
%sqsubseteq%

mult(n) := mult(n) + p(n) + p(n);
°

¹CN
(6) %sqsubseteq%

jprime := mult(n) /= j;
°

%\pagebreak
%\section{THEORY LISTING}
%\HOLindexOff
%\input{zed002.th.tex}
%\HOLindexOn
\twocolumn[\section{INDEX OF DEFINED TERMS}]
\printindex
\end{document}

