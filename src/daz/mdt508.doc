% mdt508.doc %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Basic Declarations and Expressions}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT508}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
%\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{D.J.~King & WIN01\\A.C.~Hayward & WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{
This document comprises test cases and test code/data for
testing the Declaration and Expression generator as described in the document
ISS/HAT/DAZ/DTD508.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1-1.4] Initial Drafts
\item[Issue 1.5] First draft for review.
\item[Issues 1.6-1.10] Finished all tests.
\item[Issues 1.10-1.14] Updates for enhancements.

\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises test cases and test code/data for
testing the Compliance Notation Declaration and Expression generator as specified in \cite{ISS/HAT/DAZ/DTD508}.

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the Basic Declaration and Expression generator as defined in \cite{ISS/HAT/DAZ/DTD508} and implemented in \cite{ISS/HAT/DAZ/IMP508}. The tests are intended to meet the requirements for tests identified in the quality plan \cite{ISS/HAT/DAZ/PLN003}.

\subsubsection{Dependencies}

These tests depend on the test harness as implemented in \cite{DS/FMU/IED/IMP013}, and its corresponding detailed design document, \cite{DS/FMU/IED/DTD013}. Additionally, the tests make use of utilities defined in \cite{ISS/HAT/DAZ/DTD515} and implemented in \cite{ISS/HAT/DAZ/IMP515}.

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

There are no known deficiencies.

\section{PREAMBLE}
Set up the theory database as necessary.

=SML
use_file "dtd013";
use_file "imp013";
init_mt_results();
=TEX

Set up the theory database as necessary.

=SML
use_file "dtd515";
use_file "imp515";
open_theory "cn";
force_delete_theory "mdt508_test" handle (_) => ();
new_theory "mdt508_test";
=TEX

=SML
open CNTypes CNBasicDeclsAndExprs ZParagraphs;
=TEX

\section{INITIALISATION AND SUPPORTING FUNCTIONS}

=SML
fun €comp_z_exp› ((x,y) : Z_EXP * string) : bool =
    (PolyML.makestring x) = y;
fun €comp_parainfo› ((x,y) : PARAINFO * PARAINFO) : bool =
    (PolyML.makestring x)=(PolyML.makestring y);
=TEX

=SML
val _ = (* CNTestUtilities. *) init_env();
=TEX

Declare identifiers needed for the tests.
=SML
cn_declare "FUNCTION max (a, b : INTEGER) return INTEGER;";
cn_declare "subtype DAYRANGE is INTEGER range 1..31;";
cn_declare "subtype MONTHRANGE is INTEGER range 1..12;";
cn_declare "subtype YEARRANGE is INTEGER range 1..4000;";
cn_declare "type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);";
cn_declare "type WEEK is array (DAY) of integer;";
cn_declare "type WEEKUNCON is array (DAY range <>) of integer;";
cn_declare "type DATE is record DAY : DAYRANGE; MONTH : MONTHRANGE;\
           \YEAR : YEARRANGE; end record;";
cn_declare "type HOURS is range 0..23;";
cn_declare "subtype WEEKDAY is DAY range MON..FRI;";
cn_declare "subtype WEEKDAYUNCON is WEEKUNCON(WEEKDAY);";
change_env "DATE" (EIEnvRecordType["DAY", "MONTH", "YEAR"]);
cn_declare "TODAY : DATE;";
cn_declare "A,B : integer;";
cn_declare "PAY_DAY : constant DAY := FRI;";
cn_declare "type CHAR_ARRAY is array (DAY) of CHARACTER;";
cn_declare "CA : constant CHAR_ARRAY := CHAR_ARRAY'\
	\	(others => 'a');";
cn_declare "THISWEEK : WEEK;";
cn_declare "type ARR2 is array (DAY, HOURS) of DAY;";
cn_declare "type UNCON2 is array (DAY range <>, HOURS range <>) of integer;";
cn_declare "type FIX is delta 0.1 range 5.1 .. 10.0;";
cn_declare "type FLOAT1 is digits 7 range -1.0 .. 1.0;";
cn_declare "subtype SUBFIX1 is FIX range 7.0 .. 9.0;";
cn_declare "subtype SUB1 is INTEGER range INTEGER(7.2) .. 10;";
cn_declare "subtype SUBFLOAT is FLOAT1 digits 4 range -0.8 .. 0.8;";
cn_declare "subtype SUBFIX2 is FIX delta 0.3 range 6.0 .. 10.0;";
cn_declare "subtype SUB2 is UNCON2(WEEKDAY, HOURS);";
=TEX

ˇONE
‹one : ˙
˜
‹one = 1
à

\section{TESTS FOR Z ABSTRACT SYNTAX}

=SML
store_mt_results (mt_runf comp_z_exp) [
    ("zabstract.1", (fn x => x), z_unary_minus, "Ò(~ _)Æ"),
    ("zabstract.2", (fn x => x), z_bool_not, "Ò(not _)Æ"),
    ("zabstract.3", (fn x => x), z_abs, "Ò(abs _)Æ")];
=TEX

=SML
store_mt_results (mt_runf comp_z_exp) [
    ("zabstract.4", (fn x => x), z_bool_and, "Ò(_ and _)Æ"),
    ("zabstract.5", (fn x => x), z_bool_or, "Ò(_ or _)Æ"),
    ("zabstract.6", (fn x => x), z_bool_xor, "Ò(_ xor _)Æ"),
    ("zabstract.7", (fn x => x), z_bool_eq, "Ò(_ eq _)Æ"),
    ("zabstract.8", (fn x => x), z_bool_noteq, "Ò(_ noteq _)Æ"),
    ("zabstract.9", (fn x => x), z_bool_less, "Ò(_ less _)Æ"),
    ("zabstract.10", (fn x => x), z_bool_less_eq, "Ò(_ less_eq _)Æ"),
    ("zabstract.11", (fn x => x), z_bool_greater, "Ò(_ greater _)Æ"),
    ("zabstract.12", (fn x => x), z_bool_greater_eq, "Ò(_ greater_eq _)Æ"),
    ("zabstract.13", (fn x => x), z_add, "Ò(_ + _)Æ"),
    ("zabstract.14", (fn x => x), z_minus, "Ò(_ - _)Æ"),
    ("zabstract.15", (fn x => x), z_times, "Ò(_ * _)Æ"),
    ("zabstract.16", (fn x => x), z_intdiv, "Ò(_ intdiv _)Æ"),
    ("zabstract.17", (fn x => x), z_mod, "Ò(_ intmod _)Æ"),
    ("zabstract.18", (fn x => x), z_rem, "Ò(_ rem _)Æ"),
    ("zabstract.19", (fn x => x), z_expon, "Ò(_ ** _)Æ"),
    ("zabstract.20", (fn x => x), z_bool_mem, "Ò(_ mem _)Æ"),
    ("zabstract.21", (fn x => x), z_bool_notmem, "Ò(_ notmem _)Æ")];
=TEX

=SML
store_mt_results (mt_runf comp_z_exp) [
    ("zabstract.22", (fn x => x), zsucc, "ÒsuccÆ"),
    ("zabstract.23", (fn x => x), zid env "DAY", "ÒDAYÆ"),
    ("zabstract.24", (fn x => x), z_num 42, "Ò42Æ"),
    ("zabstract.25", (fn x => x),
        z_tfun (ÒDAYÆ, ÒINTEGERÆ), "ÒDAY ≠ INTEGERÆ"),
    ("zabstract.26", (fn x => x),
        z_pfun (ÒDAYÆ, ÒINTEGERÆ), "ÒDAY ﬂ INTEGERÆ"),
    ("zabstract.27", (fn x => x), z_rng (Ò1Æ, Ò42Æ), "Ò1 .. 42Æ"),
    ("zabstract.28", (fn x => x), z_dom ÒmaxÆ, "Òdom maxÆ"),
    ("zabstract.29", (fn x => x),
        z_dom_res (ÒINTEGERÆ, ÒsuccÆ), "ÒINTEGER Ú succÆ"),
    ("zabstract.30", (fn x => x), z_inv ÒsuccÆ, "Òsucc Á~ÍÆ"),
    ("zabstract.31", (fn x => x), z_id_rel ÒINTEGERÆ, "Òid INTEGERÆ"),
    ("zabstract.32", (fn x => x), z_size ÒDAYÆ, "Ò# DAYÆ"),
    ("zabstract.33", (fn x => x),
        z_set [ÒMONÆ, ÒTUEÆ, ÒWEDÆ, ÒTHUÆ, ÒFRIÆ, ÒSATÆ, ÒSUNÆ],
        "Ò{MON, TUE, WED, THU, FRI, SAT, SUN}Æ"),
    ("zabstract.34", (fn x => x),
        z_set_minus (ÒDAYÆ, Ò{MON}Æ), PolyML.makestring ÒDAY \ {MON}Æ),
    ("zabstract.35", (fn x => x),
        z_set_comp (mk_z_dec ([ÒaÆ],Ò˙Æ),Òa>42Æ), "Ò{a : ˙ | a > 42}Æ"),
    ("zabstract.36", (fn x => x), z_power (ÒsuccÆ,Ò2Æ), "Òsucc Á 2 ÍÆ"),
    ("zabstract.37", (fn x => x),
        z_rel_comp (ÒmaxÆ, ÒsuccÆ), "Òmax ª succÆ"),
    ("zabstract.38", (fn x => x), z_seq [Ò1Æ,Ò42Æ], "Òß1, 42¢Æ"),
    ("zabstract.39", (fn x => x),
        z_cross (ÒINTEGERÆ,ÒDAYÆ), "ÒINTEGER ∏ DAYÆ"),
    ("zabstract.40", (fn x => x), z_override (ÒmaxÆ,ÒmaxÆ), "Òmax ´ maxÆ"),
    ("zabstract.41", (fn x => x),
        z_many_union [Ò1..2Æ,Ò3..4Æ], "Ò(1 .. 2) ¿ (3 .. 4)Æ"),
    ("zabstract.42", (fn x => x),
        z_mu env ("ONE", ÒtrueÆ), "ÒÕ ONE ∑  ONEÆ")];
=TEX

=SML
store_mt_results (mt_runf comp_z_exp) [
    ("zabstract.43", (fn x => x), z_unary_exp (Ò(~ _)Æ, Ò42Æ), "Ò~ 42Æ"),
    ("zabstract.44", (fn x => x),
        z_bin_exp (Ò42Æ, Ò(_ + _)Æ, Ò42Æ), "Ò42 + 42Æ"),
    ("zabstract.45", (fn x => x), z_fun_call (ÒsuccÆ, [Ò42Æ]), "Òsucc 42Æ"),
    ("zabstract.46", (fn x => x),
        z_selection (ÒTODAY∫DATEÆ,"YEAR"), "ÒTODAY.YEARÆ"),
    ("zabstract.47", (fn x => x),
        z_maplet (ÒINTEGERÆ, ÒDATEÆ), "ÒINTEGER Ì DATEÆ"),
    ("zabstract.48", (fn x => x),
        other_z_exp Ò42Æ, "Ò42Æ"),
    ("zabstract.49", (fn x => x), z_eq (Ò42Æ,Ò42Æ), "Ò42 = 42Æ"),
    ("zabstract.50", (fn x => x), z_and (ÒtrueÆ,ÒfalseÆ), "Òtrue ± falseÆ"),
    ("zabstract.51", (fn x => x),
        z_many_and [ÒtrueÆ, ÒfalseÆ, ÒtrueÆ], "Òtrue ± false ± trueÆ"),
    ("zabstract.52", (fn x => x), z_elem (ÒMONÆ,ÒDAYÆ), "ÒMON ç DAYÆ"),
    ("zabstract.53", (fn x => x), z_noteq (Ò42Æ,ÒMONÆ), "Ò42 Ω MONÆ"),
    ("zabstract.54", (fn x => x), z_less_eq (Ò1Æ, Ò42Æ), "Ò1 º 42Æ"),
    ("zabstract.55", (fn x => x), z_greater (Ò42Æ,Ò1Æ), "Ò42 > 1Æ"),
    ("zabstract.56", (fn x => x),
        z_forall ([mk_z_dec ([ÒaÆ],Ò˙Æ)], ÒtrueÆ), "Òµ a : ˙ ∑ trueÆ"),
    ("zabstract.57", (fn x => x), z_imp (ÒtrueÆ, ÒtrueÆ), "Òtrue ¥ trueÆ"),
    ("zabstract.58", (fn x => x),
        other_z_pred ÒtrueÆ, "ÒtrueÆ")];
=TEX

=SML
store_mt_results (mt_runf comp_parainfo) [
    ("zabstract.59", (fn x => x), z_eq_eq ("TODAY", ÒtrueÆ), AbbDefInfo
      ("TODAY", [], ÒtrueÆ)),
    ("zabstract.60", (fn x => x), z_schema ("TODAY", [mk_z_dec ([ÒaÆ],Ò˙Æ)]),
      AbbDefInfo ("TODAY", [], Ò[a : ˙]Æ))];
=TEX

\section{TESTS FOR EXPRESSIONS}

=SML
val €exptest› = (trans_exp env) o (adjust_exp env) o cn_exp_of_string;
=TEX

\subsection{Identifiers}
Tests for $trans\_id$.
=SML
store_mt_results mt_run [
    ("trans_id.1", trans_id, "TODAY.YEAR", "TODAYoYEAR"),
    ("trans_id.2", trans_id, "DAY'FIRST", "DAYvFIRST")];
=TEX

\subsection{Aggregates (Positional Array)}
Tests for $zfst$, $zlst$, $zsuc$, $zpred$, $zpos$, $zval$, $zlength$, $zrange$ and $exp\_array\_agg\_pos$.
=SML
store_mt_results mt_run [
    ("zfst", (fn x => x), zfst, "FIRST"),
    ("zlst", (fn x => x), zlst, "LAST"),
    ("zsuc", (fn x => x), zsuc, "SUCC"),
    ("zpred", (fn x => x), zpred, "PRED"),
    ("zpos", (fn x => x), zpos, "POS"),
    ("zval", (fn x => x), zval, "VAL"),
    ("zlength", (fn x => x), zlength, "LENGTH"),
    ("zrange", (fn x => x), zrange, "RANGE"),
    ("^^", (fn x => x), "DAY" ^^ "FIRST", "DAYvFIRST")];
local
val exp = EArrayAggPos
   {comps =
      [EId "TUE", EId "WED", EId "THU", EId "FRI", EId "SAT", EId "SUN",
         EId "MON"],
      tmark = "WEEK"};
val res = Òsucc Á 1 - WEEKvFIRST Í ª ßTUE,WED,THU,FRI,SAT,SUN,MON¢Æ;
in
val _ = store_mt_results (mt_runf (op =$))
        [("exp_array_agg_pos", trans_exp env, exp, res)];
end;
=TEX

\subsection{Aggregates (Positional Array with Others)}
Tests for $exp\_array\_agg\_pos\_others$.
=SML
local
val exp = EArrayAggPosOthers
   {others = {others = EId "SAT"},
      agg_pos =
      {comps = [EInt "1", EInt "1", EInt "1", EInt "1", EInt "1"],
         tmark = "WEEK"}};
val res = Ò(WEEKvRANGE ∏ {SAT}) ´ (succ Á 1 - WEEKvFIRST Í ª ß1, 1, 1, 1, 1¢)Æ;
in
val _ = store_mt_results (mt_runf (op =$))
        [("exp_array_agg_pos_others", trans_exp env, exp, res)];
end;
=TEX

\subsection{Aggregates (Positional Array with Just Others)}
Tests for $exp\_array\_agg\_others$.
=SML
local
val exp = EArrayAggOthers {tmark = "WEEK", others = {others = EInt "42"}};
val res = ÒWEEKvRANGE ∏ {42}Æ;
in
val _ = store_mt_results (mt_runf (op =$))
        [("exp_array_agg_others", trans_exp env, exp, res)];
end;
=TEX

\subsection{Aggregates (Named Array)}
Tests for $trans\_named\_assoc$ and $exp\_array\_agg\_named$.
=SML
local
val exp = EArrayAggNamed
   {named_assocs =
      [{comp = EInt "42",
            choice =
            [ACAggChoiceRange
                  (DRRange (RRange {hi = EId "THU", lo = EId "MON"})),
               ACAggChoiceSingle (EId "FRI")]},
         {comp = EInt "0",
            choice =
            [ACAggChoiceSingle (EId "SAT"), ACAggChoiceSingle (EId "SUN")]}]};
val res = Ò((MON .. THU) ¿ {FRI} ∏ {42}) ¿ ({SAT,SUN} ∏ {0})Æ;
in
val _ = store_mt_results (mt_runf (op =$))
        [("exp_array_agg_named", trans_exp env, exp, res)];
end;
=TEX

\subsection{Aggregates (Named Array with Others)}
Tests for $exp\_array\_agg\_named\_others$.
=SML
local
val exp = EArrayAggNamedOthers
   {tmark = "WEEK",
      others = {others = EInt "0"},
      agg_named =
      {named_assocs =
         [{comp = EInt "42",
               choice =
               [ACAggChoiceRange
                     (DRRange (RRange {hi = EId "FRI", lo = EId "MON"}))]}]}};
val res = Ò(WEEKvRANGE ∏ {0}) ´ (MON..FRI ∏ {42})Æ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_array_agg_named_others", trans_exp env, exp, res)];
end;
=TEX

\subsection{Aggregates (Positional Record)}
Tests for $retrieve\_record\_components$ and $exp\_rec\_agg\_pos\_z$.
=SML
local
val exp = ERecAggPos
   {comps = [EInt "2", EInt "8", EInt "1994"], tmark = "DATE"};
val res = Ò(DAY ¶ 2, MONTH ¶ 8, YEAR ¶ 1994 )Æ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_rec_agg_pos_z", trans_exp env, exp, res)];
end;
=TEX

\subsection{Aggregates (Named Record)}
Tests for $exp\_rec\_agg\_named$.
=SML
local
val exp = ERecAggNamed
   {tmark = "DATE", named_assocs =
      [{comp = EInt "3", choice = [ACAggChoiceSingle (EId "DAY")]},
         {comp = EInt "8", choice = [ACAggChoiceSingle (EId "MONTH")]},
         {comp = EInt "1994", choice = [ACAggChoiceSingle (EId "YEAR")]}]};
val res = Ò(DAY ¶ 3, MONTH ¶ 8, YEAR ¶ 1994)Æ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_rec_agg_named", trans_exp env, exp, res)];
end;
=TEX

\subsection{Unary Expressions}
Tests for $trans\_unary\_op$ and $exp\_unary\_exp$.
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_unary_exp.1", exptest, "42", Ò42Æ),
    ("exp_unary_exp.2", exptest, "+42", Ò42Æ),
    ("exp_unary_exp.3", exptest, "-42", Ò~42Æ),
    ("exp_unary_exp.4", exptest, "not 42", Ònot 42Æ),
    ("exp_unary_exp.5", exptest, "abs 0", Òabs 0Æ)];
=TEX

\subsection{Binary Expressions}
Tests for $trans\_bin\_op$ and $exp\_bin\_exp$.
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_binary_exp.1", exptest, "a and b", ÒA and BÆ : Z_EXP),
    ("exp_binary_exp.2", exptest, "a or b", ÒA or BÆ),
    ("exp_binary_exp.3", exptest, "a xor b", ÒA xor BÆ),
    ("exp_binary_exp.7", exptest, "a = b", Ò(A∫˙) eq BÆ),
    ("exp_binary_exp.8", exptest, "a /= b", Ò(A∫˙) noteq BÆ),
    ("exp_binary_exp.9", exptest, "a < b", ÒA less BÆ),
    ("exp_binary_exp.10", exptest, "a > b", ÒA greater BÆ),
    ("exp_binary_exp.11", exptest, "a >= b", ÒA greater_eq BÆ),
    ("exp_binary_exp.12", exptest, "a + b", ÒA + BÆ),
    ("exp_binary_exp.13", exptest, "a - b", ÒA - BÆ),
    ("exp_binary_exp.14", exptest, "a * b", ÒA * BÆ),
    ("exp_binary_exp.15", exptest, "a / b", ÒA intdiv BÆ),
    ("exp_binary_exp.16", exptest, "a mod b", ÒA intmod BÆ)];
=TEX

\subsection{Membership of a Range}
Tests for $exp\_mem\_range$.
=SML
local
val arg = "PAY_DAY not in SAT .. SUN";
val res = ÒPAY_DAY notmem SAT .. SUNÆ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_mem_range", exptest, arg, res)];
end;
=TEX

\subsection{Attributes}
Tests for $exp\_attrib$.
=SML
local
val arg = "DAY'FIRST";
val res = ÒDAYvFIRSTÆ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_attrib", exptest, arg, res)];
end;
=TEX

\subsection{Indexed Components}
Tests for $exp\_indexed\_comp$.
=SML
local
val arg = "THISWEEK(DAY'FIRST)";
val res = "ÒTHISWEEK DAYvFIRSTÆ";
in
val _ = store_mt_results (mt_runf (comp_z_exp))
    [("exp_indexed_comp", exptest, arg, res)];
end;
=TEX

\subsection{Selected Components}
Tests for $exp\_selected\_comp$.
=SML
local
val arg = "TODAY.DAY";
val res = "ÒTODAY.DAYÆ";
in
val _ = store_mt_results (mt_runf (op comp_z_exp))
    [("selected_comp", exptest, arg, res)];
end;
=TEX

\subsection{Functions Calls}
Tests for $exp\_fun\_call$.
=SML
local
val arg = "max(1,2)";
val res = ÒMAX (1, 2)Æ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_fun_call", exptest, arg, res)];
end;
=TEX


\subsection{Qualified Expressions}
Tests for $exp\_qualified$.
=SML
local
val arg = "DAYRANGE'(11)";
val res = Ò11Æ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_qualified", exptest, arg, res)];
end;
=TEX

\subsection{Type Conversions}
Tests for $exp\_type\_conv$.
=SML
local
val _ = extend_env "DAYRANGE" (type_ofÒ˙Æ) EIEnvOtherType;
val arg = "DAYRANGE(11)";
val res = Ò11Æ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_type_conv.1", exptest, arg, res)];
end;
=TEX
=SML
local
val _ = extend_env "FIX" (type_ofÒFIXÆ) EIEnvOtherType;
val arg = "FIX(11)";
in
val _ = store_mt_results mt_run_fail
    [("exp_type_conv.2", exptest, arg, gen_fail_msg "exp_type_conv" 508053 [])];
end;
=TEX

\subsection{Integer Literals}
Tests for $trans\_int$, $exp\_int\_lit$.
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_int_lit.1", exptest, "25", Ò25Æ),
    ("exp_int_lit.2", exptest, "15_234", Ò15234Æ),
    ("exp_int_lit.3", exptest, "12E3", Ò12000Æ),
    ("exp_int_lit.4", exptest, "12E+3", Ò12000Æ),
    ("exp_int_lit.5", exptest, "200E-2", Ò2Æ),
    ("exp_int_lit.6", exptest, "2#101#", Ò5Æ),
    ("exp_int_lit.7", exptest, "2#101#e+2", Ò20Æ)];
=TEX

\subsection{Auxiliary Expressions}
Tests for $exp\_auxiliary\_exp$.  Auxiliary expression are not yet supported
by the parser.

\subsection{The Function $trans\_exp$}\label{transexp}
Tests for $trans\_exp$, $trans\_exp1$.  This function is exercised by the tests above.  Theres just one more test to be done, for brackets.
=SML
local
val arg = "(42 + 13) * (17 + 19)";
val res = Ò(42 + 13) * (17 + 19)Æ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("brackets.1", exptest, arg, res)];
end;
=TEX

\section{TESTS FOR BASIC DECLARATIONS}
=SML
fun €bdtest› (tm : TERM) : bool = ( case frees tm of [] => true |_ => false);
=TEX

\subsection{Constants}
Tests for $basic\_decl\_const$.
=SML
store_mt_results (mt_runf (op =))
    [	("constant_1", bdtest, ÒPAY_DAY = FRIÆ, true),
	("constant_2", bdtest, ÒCA = {}Æ, true)];
=TEX

\subsection{Enumeration Types}
Tests for $basic\_decl\_enum$.
=SML
store_mt_results (mt_runf (op =))
    [("enumeration", bdtest, Ò{MON, TUE, WED, THU, FRI, SAT, SUN} Ä DAYÆ,
       true)];
=TEX

\subsection{Array Types}
Tests for $basic\_decl\_con\_array$ and $basic\_decl\_uncon\_array$.
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("array.1", bdtest, Ò{day : WEEK | SUN = day(1)}Æ, true),
    ("array.2", bdtest, Ò{day : WEEKUNCON | SUN = day(1)}Æ, true),
    ("array.3", bdtest, Ò{day : ARR2 | SUN = day(1, 2)}Æ, true),
    ("array.4", bdtest, Ò{day : UNCON2 | SUN = day(1, 2)}Æ, true)];
=TEX

\subsection{Record Types}
Tests for $trans\_decl$, $basic\_decl\_record$.
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("record", bdtest, ÒÕ DATE | DAY=6 ± MONTH=8 ∑ INTEGERÆ, true)];
=TEX

\subsection{Integer Types}
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("integer.1", bdtest, ÒHOURS † 0 .. 23Æ, true),
    ("integer.2", bdtest, ÒHOURSvFIRST < HOURSvLASTÆ, true),
    ("integer.3", bdtest, ÒHOURSvSUCC ¿ HOURSvPRED † ˙ ∏ ˙Æ, true),
    ("integer.4", bdtest, ÒHOURSvPOS ¿ HOURSvVAL † ˙ ∏ ˙Æ, true)
];
=TEX
\subsection{Real Types}
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("real.1", bdtest, ÒFIX ç  FIXÆ, true),
    ("real.2", bdtest, ÒFLOAT1 ç  FLOAT1Æ, true)
];
=TEX

\subsection{Subtypes}
Tests for $basic\_decl\_subtype\_range\_con$ etc..
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("subtype.1", bdtest, ÒMON ç WEEKDAYÆ, true),
    ("subtype.2", bdtest, ÒSUN é {WEEKDAYvFIRST, WEEKDAYvLAST}Æ, true),
    ("subtype.3", bdtest, ÒWEEKDAYvSUCC ¿ WEEKDAYvPRED Ä ˙ ∏ ˙Æ, true),
    ("subtype.4", bdtest, ÒWEEKDAYvPOS ¿ WEEKDAYvVAL Ä ˙ ∏ ˙Æ, true)
];
=TEX
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("subtype.5", bdtest, ÒSUBFIX1 Ω FIXÆ, true),
    ("subtype.6", bdtest, Ò8 ç SUB1Æ, true),
    ("subtype.7", bdtest, ÒSUBFLOAT Ä FLOAT1Æ, true),
    ("subtype.9", bdtest, ÒSUBFIX2 Ä FIXÆ, true),
    ("subtype.10", bdtest, ÒSUB2 Ä UNCON2Æ, true),
    ("subtype.11", bdtest, ÒWEEKDAYUNCON Ä WEEKUNCONÆ, true)
];
=TEX

\subsection{The Function $trans\_basic\_decl$}
Tests for $trans\_basic\_decl$, $trans\_basic\_decl1$.  These have been exercised by the above tests.

\section{ADJUSTMENT OF ABSTRACT SYNTAX FOR EXPRESSIONS}
Tests for $named\_assocs\_to\_exps$, $adjust\_exp$, $adjust\_exp1$.  These have been exercised by the above tests.

=TEX
\section{SUMMARY OF RESULTS}

=SML
diag_line(summarize_mt_results());
=TEX

\end{document}
