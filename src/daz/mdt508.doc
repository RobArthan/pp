=IGN
********************************************************************************
mdt508.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% $Header: /home/rda/daz/RCS/mdt508.doc,v 1.45 2006/06/12 16:42:15 rda Exp rda $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Basic Declarations and Expressions}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT508}  %% Mandatory field
\def\SCCSversion{$Revision: 1.45 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2006/06/12 16:42:15 $
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
%\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{D.J.~King & WIN01\\A.C.~Hayward & WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{
This document comprises test cases and test code/data for
testing the Declaration and Expression generator as described in the document
ISS/HAT/DAZ/DTD508.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1-1.4] Initial Drafts
\item[Issue 1.5] First draft for review.
\item[Issues 1.6-1.10] Finished all tests.
\item[Issues 1.10-1.18] Updates for enhancements.
\item[Issue 1.19] Test for fix of DRA bug 11 (V0.6).
\item[Issue 1.20] IUCT WP7 changes.
\item[Issue 1.21] Update for SML'97 port.
\item[Issue 1.22] CTLE II R1/4 --- logical operators on arrays of booleans.
\item[Issues 1.23,1.24] CTLE II R1/1 --- real types.
\item[Issue 1.25,1.26] CTLE II --- consolidated coverage of various enhancements.
\item[Issue 1.27] Fixed duplicated test identities and erroneous test of exponentiation.
\item[Issue 1.28] Added tests for underscores in real numbers.
\item[Issue 1.29] Adjusted for revisions to treatment of aggregates.
\item[Issue 1.30] Adjusted for change to signature of {\it z\_schema}.
\issue[Issue 1.31] New syntax for discriminants.
\item[Issue 1.32] {\it zsucc} is now called {\it z\_succ}.
\item[Issue 1.33] Allowed for syntax for block statements.
\item
\item[Issue 1.34] Copyright and banner updates for open source release.
\item[Issue 1.35, 1.36] DAZ-specific updates to banner for open source release
\item[Issue 1.37] Uniform treatment of block statements.
\item[Issue 1.38] The SPARK program is now referred to as the Ada program.
\item[Issue 1.39] Allowed for data type changes for environment reform.
\item[Issue 1.40] Adjustments to lexical class data type (for syntax of Ada labels).
\item[Issue 1.41] Allowed for changed signatures.
\item[Issue 1.42] Allowed for changes to {\em cn\_declare} and added selected tests for changes to {\em trans\_basic\_decl}.
\item[Issue 1.43] Allowed for automated state management.
\item[Issue 1.44] Ada real literals are now translated into Z floating point literals.
\item[Issue 1.45] Added tests for improved error handlling for numeric literals.
\item[Issue 1.46] Allowed for type changes for child packages.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises test cases and test code/data for
testing the Compliance Notation Declaration and Expression generator as specified in \cite{ISS/HAT/DAZ/DTD508}.

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the Basic Declaration and Expression generator as defined in \cite{ISS/HAT/DAZ/DTD508} and implemented in \cite{ISS/HAT/DAZ/IMP508}. The tests are intended to meet the requirements for tests identified in the quality plan \cite{ISS/HAT/DAZ/PLN003}.

\subsubsection{Dependencies}

These tests depend on the test harness as implemented in \cite{DS/FMU/IED/IMP013}, and its corresponding detailed design document, \cite{DS/FMU/IED/DTD013}. Additionally, the tests make use of utilities defined in \cite{ISS/HAT/DAZ/DTD515} and implemented in \cite{ISS/HAT/DAZ/IMP515}.

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

There are no known deficiencies.

\section{PREAMBLE}
Set up the theory database as necessary.

=SML
use_file "dtd013";
use_file "imp013";
init_mt_results();
=TEX

Set up the theory database as necessary.

=SML
use_file "dtd515";
use_file "imp515";
open_theory "cn";
force_delete_theory "mdt508_test" handle (_) => ();
new_theory "mdt508_test";
=TEX

=SML
open CNTypes CNBasicDeclsAndExprs ZParagraphs;
=TEX

\section{INITIALISATION AND SUPPORTING FUNCTIONS}

=SML
fun €comp_z_exp› ((x,y) : Z_EXP * string) : bool =
    (string_of_term x) = y;
=TEX

=SML
val _ = (* CNTestUtilities. *) init_env();
=TEX

Declare identifiers needed for the tests.
=SML
cn_declare [] "FUNCTION max (a, b : INTEGER) return INTEGER;";
cn_declare [] "subtype DAYRANGE is INTEGER range 1..31;";
cn_declare [] "subtype MONTHRANGE is INTEGER range 1..12;";
cn_declare [] "subtype YEARRANGE is INTEGER range 1..4000;";
cn_declare [] "subtype ALLINTEGERS is INTEGER;";
cn_declare [] "type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);";
cn_declare [] "type WEEK is array (DAY) of integer;";
cn_declare [] "type WEEKUNCON is array (DAY range <>) of integer;";
cn_declare [] "type DATE is record DAY : DAYRANGE; MONTH : MONTHRANGE;\
           \YEAR : YEARRANGE; end record;";
cn_declare [] "type HOURS is range 0..23;";
cn_declare [] "subtype WEEKDAY is DAY range MON..FRI;";
cn_declare [] "subtype WEEKDAYUNCON is WEEKUNCON(WEEKDAY);";
change_env "DATE" ({
	tipe = Nil,
	canon_name = "DATE",
	info = EIEnvRecordType{comp_names = ["DAY", "MONTH", "YEAR"], num_discs = 0},
	private = false});
cn_declare [] "TODAY : DATE;";
cn_declare [] "A,B : integer;";
cn_declare [] "type FLAGS is array(DAY) of BOOLEAN;";
cn_declare [] "flags1, flags2 : FLAGS;";
cn_declare [] "PAY_DAY : constant DAY := FRI;";
cn_declare [] "type CHAR_ARRAY is array (DAY) of CHARACTER;";
cn_declare [] "CA : constant CHAR_ARRAY := CHAR_ARRAY'\
\\t\t(others => 'a');";
cn_declare [] "THISWEEK : WEEK;";
cn_declare [] "type ARR2 is array (DAY, HOURS) of DAY;";
cn_declare [] "type UNCON2 is array (DAY range <>, HOURS range <>) of integer;";
cn_declare [] "type FIX is delta 0.1 range 5.1 .. 10.0;";
cn_declare [] "R : FIX;";
cn_declare [] "type FLOAT1 is digits 7 range -1.0 .. 1.0;";
cn_declare [] "subtype SUBFIX1 is FIX range 7.0 .. 9.0;";
cn_declare [] "subtype SUB1 is INTEGER range INTEGER(7.2) .. 10;";
cn_declare [] "subtype SUBFLOAT is FLOAT1 digits 4 range -0.8 .. 0.8;";
cn_declare [] "subtype SUBFIX2 is FIX delta 0.3 range 6.0 .. 10.0;";
cn_declare [] "subtype SUB2 is UNCON2(WEEKDAY, HOURS);";
cn_declare [] "subtype SUB3 is SUB2;";
cn_declare [] "subtype INWEEK is WEEK;";
cn_declare [] "V, W : FLOAT1;";
cn_declare [] "obj : ARR2;";
=TEX

ˇONE
‹one : ˙
˜
‹one = 1
à

\section{TESTS FOR Z ABSTRACT SYNTAX}

=SML
store_mt_results (mt_runf comp_z_exp) [
    ("zabstract.1", (fn x => x), z_unary_minus, "Ò(~ _)Æ"),
    ("zabstract.2", (fn x => x), z_bool_not, "Ò(not _)Æ"),
    ("zabstract.3", (fn x => x), z_abs, "Ò(abs _)Æ")];
=TEX

=SML
store_mt_results (mt_runf comp_z_exp) [
    ("zabstract.4", (fn x => x), z_bool_and, "Ò(_ and _)Æ"),
    ("zabstract.5", (fn x => x), z_bool_or, "Ò(_ or _)Æ"),
    ("zabstract.6", (fn x => x), z_bool_xor, "Ò(_ xor _)Æ"),
    ("zabstract.7", (fn x => x), z_bool_eq, "Ò(_ eq _)Æ"),
    ("zabstract.8", (fn x => x), z_bool_noteq, "Ò(_ noteq _)Æ"),
    ("zabstract.9", (fn x => x), z_bool_less, "Ò(_ less _)Æ"),
    ("zabstract.10", (fn x => x), z_bool_less_eq, "Ò(_ less_eq _)Æ"),
    ("zabstract.11", (fn x => x), z_bool_greater, "Ò(_ greater _)Æ"),
    ("zabstract.12", (fn x => x), z_bool_greater_eq, "Ò(_ greater_eq _)Æ"),
    ("zabstract.13", (fn x => x), z_add, "Ò(_ + _)Æ"),
    ("zabstract.14", (fn x => x), z_minus, "Ò(_ - _)Æ"),
    ("zabstract.15", (fn x => x), z_times, "Ò(_ * _)Æ"),
    ("zabstract.16", (fn x => x), z_intdiv, "Ò(_ intdiv _)Æ"),
    ("zabstract.17", (fn x => x), z_mod, "Ò(_ intmod _)Æ"),
    ("zabstract.18", (fn x => x), z_rem, "Ò(_ rem _)Æ"),
    ("zabstract.19", (fn x => x), z_expon, "Ò(_ ** _)Æ"),
    ("zabstract.20", (fn x => x), z_bool_mem, "Ò(_ mem _)Æ"),
    ("zabstract.21", (fn x => x), z_bool_notmem, "Ò(_ notmem _)Æ")];
=TEX

=SML
store_mt_results (mt_runf comp_z_exp) [
    ("zabstract.22", (fn x => x), z_succ, "ÒsuccÆ"),
    ("zabstract.23", (fn x => x), zid env "DAY", "ÒDAYÆ"),
    ("zabstract.24", (fn x => x), z_num (@@"42"), "Ò42Æ"),
    ("zabstract.25", (fn x => x),
        z_tfun (ÒDAYÆ, ÒINTEGERÆ), "ÒDAY ≠ INTEGERÆ"),
    ("zabstract.26", (fn x => x),
        z_pfun (ÒDAYÆ, ÒINTEGERÆ), "ÒDAY ﬂ INTEGERÆ"),
    ("zabstract.27", (fn x => x), z_rng (Ò1Æ, Ò42Æ), "Ò1 .. 42Æ"),
    ("zabstract.28", (fn x => x), z_dom ÒmaxÆ, "Òdom maxÆ"),
    ("zabstract.29", (fn x => x),
        z_dom_res (ÒINTEGERÆ, ÒsuccÆ), "ÒINTEGER Ú succÆ"),
    ("zabstract.30", (fn x => x), z_inv ÒsuccÆ, "Òsucc Á~ÍÆ"),
    ("zabstract.31", (fn x => x), z_id_rel ÒINTEGERÆ, "Òid INTEGERÆ"),
    ("zabstract.32", (fn x => x), z_size ÒDAYÆ, "Ò# DAYÆ"),
    ("zabstract.33", (fn x => x),
        z_set [ÒMONÆ, ÒTUEÆ, ÒWEDÆ, ÒTHUÆ, ÒFRIÆ, ÒSATÆ, ÒSUNÆ],
        "Ò{MON, TUE, WED, THU, FRI, SAT, SUN}Æ"),
    ("zabstract.34", (fn x => x),
        z_set_minus (ÒDAYÆ, Ò{MON}Æ), string_of_term ÒDAY \ {MON}Æ),
    ("zabstract.35", (fn x => x),
        z_set_comp (mk_z_dec ([ÒaÆ],Ò˙Æ),Òa>42Æ), "Ò{a : ˙ | a > 42}Æ"),
    ("zabstract.36", (fn x => x), z_power (ÒsuccÆ,Ò2Æ), "Òsucc Á 2 ÍÆ"),
    ("zabstract.37", (fn x => x),
        z_rel_comp (ÒmaxÆ, ÒsuccÆ), "Òmax ª succÆ"),
    ("zabstract.38", (fn x => x), z_seq [Ò1Æ,Ò42Æ], "Òß1, 42¢Æ"),
    ("zabstract.39", (fn x => x),
        z_cross (ÒINTEGERÆ,ÒDAYÆ), "ÒINTEGER ∏ DAYÆ"),
    ("zabstract.40", (fn x => x), z_override (ÒmaxÆ,ÒmaxÆ), "Òmax ´ maxÆ"),
    ("zabstract.41", (fn x => x),
        z_many_union [Ò1..2Æ,Ò3..4Æ], "Ò(1 .. 2) ¿ (3 .. 4)Æ")];
=TEX

=SML
store_mt_results (mt_runf comp_z_exp) [
    ("zabstract.43", (fn x => x), z_unary_exp (Ò(~ _)Æ, Ò42Æ), "Ò~ 42Æ"),
    ("zabstract.44", (fn x => x),
        z_bin_exp (Ò42Æ, Ò(_ + _)Æ, Ò42Æ), "Ò42 + 42Æ"),
    ("zabstract.45", (fn x => x), z_fun_call (ÒsuccÆ, [Ò42Æ]), "Òsucc 42Æ"),
    ("zabstract.46", (fn x => x),
        z_selection (ÒTODAY∫DATEÆ,"YEAR"), "ÒTODAY.YEARÆ"),
    ("zabstract.47", (fn x => x),
        z_maplet (ÒINTEGERÆ, ÒDATEÆ), "ÒINTEGER Ì DATEÆ"),
    ("zabstract.48", (fn x => x),
        other_z_exp Ò42Æ, "Ò42Æ"),
    ("zabstract.49", (fn x => x), z_eq (Ò42Æ,Ò42Æ), "Ò42 = 42Æ"),
    ("zabstract.50", (fn x => x), z_and (ÒtrueÆ,ÒfalseÆ), "Òtrue ± falseÆ"),
    ("zabstract.51", (fn x => x),
        z_many_and [ÒtrueÆ, ÒfalseÆ, ÒtrueÆ], "Òtrue ± false ± trueÆ"),
    ("zabstract.52", (fn x => x), z_elem (ÒMONÆ,ÒDAYÆ), "ÒMON ç DAYÆ"),
    ("zabstract.53", (fn x => x), z_noteq (Ò42Æ,ÒMONÆ), "Ò42 Ω MONÆ"),
    ("zabstract.54", (fn x => x), z_less_eq (Ò1Æ, Ò42Æ), "Ò1 º 42Æ"),
    ("zabstract.55", (fn x => x), z_greater (Ò42Æ,Ò1Æ), "Ò42 > 1Æ"),
    ("zabstract.56", (fn x => x),
        z_forall ([mk_z_dec ([ÒaÆ],Ò˙Æ)], ÒtrueÆ), "Òµ a : ˙ ∑ trueÆ"),
    ("zabstract.57", (fn x => x), z_imp (ÒtrueÆ, ÒtrueÆ), "Òtrue ¥ trueÆ"),
    ("zabstract.58", (fn x => x),
        other_z_pred ÒtrueÆ, "ÒtrueÆ")];
=TEX

=SML
fun €comp_abbdef_info› ((x,y) : PARAINFO * PARAINFO) : bool = (
    case (x, y) of
	(AbbDefInfo (s1, ss1, t1), AbbDefInfo (s2, ss2, t2)) =>
		s1 = s2 andalso ss1 = ss2 andalso t1 =$ t2
	| _ => false
);
store_mt_results (mt_runf comp_abbdef_info) [
    ("zabstract.59", (fn x => x), z_eq_eq "test" ("TODAY", ÒtrueÆ), AbbDefInfo
      ("TODAY", [], ÒtrueÆ)),
    ("zabstract.60", (fn x => x), z_schema ("TODAY", [mk_z_dec ([Òa∫˙Æ],Ò˙Æ)], z_true),
      AbbDefInfo ("TODAY", [], Ò[a : ˙]Æ))];
=TEX

\section{TESTS FOR EXPRESSIONS}
The following function is convenient for supplying test data in
concrete syntax format. For historical reasons, it is not always
used where it might have been.
=SML
val €exptest› = (trans_exp env) o (adjust_exp env) o cn_exp_of_string;
=TEX

\subsection{Identifiers}
Tests for $trans\_id$.
=SML
store_mt_results mt_run [
    ("trans_id.1", trans_id, "TODAY.YEAR", "TODAYoYEAR"),
    ("trans_id.2", trans_id, "DAY'FIRST", "DAYvFIRST")];
=TEX

\subsection{Aggregates (Positional Array)}
Tests for $zfst$, $zlst$, $zsuc$, $zpred$, $zpos$, $zval$, $zlength$, $zrange$ and $exp\_array\_agg\_pos$.
=SML
store_mt_results mt_run [
    ("zfst", (fn x => x), zfst, "FIRST"),
    ("zlst", (fn x => x), zlst, "LAST"),
    ("zsuc", (fn x => x), zsuc, "SUCC"),
    ("zpred", (fn x => x), zpred, "PRED"),
    ("zpos", (fn x => x), zpos, "POS"),
    ("zval", (fn x => x), zval, "VAL"),
    ("zlength", (fn x => x), zlength, "LENGTH"),
    ("zrange", (fn x => x), zrange, "RANGE"),
    ("^^", (fn x => x), "DAY" ^^ "FIRST", "DAYvFIRST")];
local
val exp = EArrayAggPos
   {comps =
      [EId "TUE", EId "WED", EId "THU", EId "FRI", EId "SAT", EId "SUN",
         EId "MON"],
      tmark = Value "WEEK"};
val res = Òsucc Á 1 - WEEKvFIRST Í ª ßTUE,WED,THU,FRI,SAT,SUN,MON¢Æ;
in
val _ = store_mt_results (mt_runf (op =$))
        [("exp_array_agg_pos", trans_exp env, exp, res)];
end;
=TEX

\subsection{Aggregates (Positional Array with Others)}
Tests for $exp\_array\_agg\_pos\_others$.
=SML
local
val exp = EArrayAggPosOthers
   {others = {others = EId "SAT"},
      agg_pos =
      {comps = [EIntReal "1", EIntReal "1", EIntReal "1", EIntReal "1", EIntReal "1"],
         tmark = Value "WEEK"}};
val res = Ò(WEEKvRANGE ∏ {SAT}) ´ (succ Á 1 - WEEKvFIRST Í ª ß1, 1, 1, 1, 1¢)Æ;
in
val _ = store_mt_results (mt_runf (op =$))
        [("exp_array_agg_pos_others", trans_exp env, exp, res)];
end;
=TEX

\subsection{Aggregates (Positional Array with Just Others)}
Tests for $exp\_array\_agg\_others$.
=SML
local
val exp = EArrayAggOthers {tmark = Value "WEEK", others = {others = EIntReal "42"}};
val res = ÒWEEKvRANGE ∏ {42}Æ;
in
val _ = store_mt_results (mt_runf (op =$))
        [("exp_array_agg_others", trans_exp env, exp, res)];
end;
=TEX

\subsection{Aggregates (Named Array)}
Tests for $trans\_named\_assoc$ and $exp\_array\_agg\_named$.
=SML
local
val exp = EArrayAggNamed
   {tmark = Value "WEEK",
	named_assocs =
      [{comp = EIntReal "42",
            choice =
            [ACAggChoiceRange
                  (DRRange (RRange {hi = EId "THU", lo = EId "MON"})),
               ACAggChoiceSingle (EId "FRI")]},
         {comp = EIntReal "0",
            choice =
            [ACAggChoiceSingle (EId "SAT"), ACAggChoiceSingle (EId "SUN")]}]};
val res = Ò((MON .. THU) ¿ {FRI} ∏ {42}) ¿ ({SAT,SUN} ∏ {0})Æ;
in
val _ = store_mt_results (mt_runf (op =$))
        [("exp_array_agg_named1", trans_exp env, exp, res)];
end;
=TEX
=SML
local
val exp = EArrayAggNamed
   {tmark = Value "WEEK",
	named_assocs =
      [{comp = EIntReal "42",
            choice =
            [ACAggChoiceRange
                  (DRRange (RRange {hi = EId "THU", lo = EId "MON"})),
               ACAggChoiceSingle (EId "FRI")]},
         {comp = EIntReal "0",
            choice =
            [ACAggChoiceSingle (EId "SAT"), ACAggChoiceSingle (EId "SUN")]}]};
val res = Ò((MON .. THU) ¿ {FRI} ∏ {42}) ¿ ({SAT,SUN} ∏ {0})Æ;
in
val _ = store_mt_results (mt_runf (op =$))
        [("exp_array_agg_named2", trans_exp env, exp, res)];
end;
=TEX
cn_exp_of_string "FLAGS'(DAY range MON .. FRI =>TRUE, WEEKDAY => FALSE)";

\subsection{Aggregates (Named Array with Others)}
Tests for $exp\_array\_agg\_named\_others$.
=SML
local
val exp = EArrayAggNamedOthers
   {others = {others = EIntReal "0"},
      agg_named =
      {tmark = Value "WEEK",
	named_assocs =
         [{comp = EIntReal "42",
               choice =
               [ACAggChoiceRange
                     (DRRange (RRange {hi = EId "FRI", lo = EId "MON"}))]}]}};
val res = Ò(WEEKvRANGE ∏ {0}) ´ (MON..FRI ∏ {42})Æ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_array_agg_named_others", trans_exp env, exp, res)];
end;
=TEX

\subsection{Aggregates (Positional Record)}
Tests for $retrieve\_record\_components$ and $exp\_rec\_agg\_pos\_z$.
=SML
local
val exp = ERecAggPos
   {comps = [EIntReal "2", EIntReal "8", EIntReal "1994"], tmark = Value "DATE"};
val res = Ò(DAY ¶ 2, MONTH ¶ 8, YEAR ¶ 1994 )Æ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_rec_agg_pos_z", trans_exp env, exp, res)];
end;
=TEX

\subsection{Aggregates (Named Record)}
Tests for $exp\_rec\_agg\_named$.
=SML
local
val exp = ERecAggNamed
   {tmark = Value "DATE", named_assocs =
      [{comp = EIntReal "3", choice = [ACAggChoiceSingle (EId "DAY")]},
         {comp = EIntReal "8", choice = [ACAggChoiceSingle (EId "MONTH")]},
         {comp = EIntReal "1994", choice = [ACAggChoiceSingle (EId "YEAR")]}]};
val res = Ò(DAY ¶ 3, MONTH ¶ 8, YEAR ¶ 1994)Æ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_rec_agg_named", trans_exp env, exp, res)];
end;
=TEX

\subsection{Unary Expressions}
Tests for $trans\_unary\_op$ and $exp\_unary\_exp$.
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_unary_exp.1", exptest, "42", Ò42Æ),
    ("exp_unary_exp.2", exptest, "+42", Ò42Æ),
    ("exp_unary_exp.3", exptest, "-42", Ò~42Æ),
    ("exp_unary_exp.4", exptest, "not 42", Ònot 42Æ),
    ("exp_unary_exp.5", exptest, "abs 0", Òabs 0Æ),
    ("exp_unary_exp.6", exptest, "not flags1", Òarray_not (FLAGS1∫(˙ ﬂ ˙))Æ)];
=TEX
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_unary_exp.7", exptest, "42.0", Ò42.0Æ),
    ("exp_unary_exp.8", exptest, "+42.0", Ò42.0Æ),
    ("exp_unary_exp.9", exptest, "-42.0", Ò~âR(42.0)Æ),
    ("exp_unary_exp.10", exptest, "abs W", ÒabsâR WÆ)];
=TEX

\subsection{Binary Expressions}
Tests for $trans\_bin\_op$ and $exp\_bin\_exp$.
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_binary_exp.1", exptest, "a and b", ÒA and BÆ),
    ("exp_binary_exp.2", exptest, "a or b", ÒA or BÆ),
    ("exp_binary_exp.3", exptest, "a xor b", ÒA xor BÆ),
    ("exp_binary_exp.7", exptest, "a = b", Ò(A∫˙) eq BÆ),
    ("exp_binary_exp.8", exptest, "a /= b", Ò(A∫˙) noteq BÆ),
    ("exp_binary_exp.9", exptest, "a < b", ÒA less BÆ),
    ("exp_binary_exp.10", exptest, "a > b", ÒA greater BÆ),
    ("exp_binary_exp.11", exptest, "a >= b", ÒA greater_eq BÆ),
    ("exp_binary_exp.12", exptest, "a + b", ÒA + BÆ),
    ("exp_binary_exp.13", exptest, "a - b", ÒA - BÆ),
    ("exp_binary_exp.14", exptest, "a * b", ÒA * BÆ),
    ("exp_binary_exp.15", exptest, "a / b", ÒA intdiv BÆ),
    ("exp_binary_exp.16", exptest, "a mod b", ÒA intmod BÆ),
    ("exp_binary_exp.17", exptest, "flags1 and flags2", Ò(FLAGS1∫(˙ ﬂ ˙)) array_and FLAGS2Æ),
    ("exp_binary_exp.18", exptest, "flags1 or flags2", Ò(FLAGS1∫(˙ ﬂ ˙)) array_or FLAGS2Æ),
    ("exp_binary_exp.19", exptest, "flags1 xor flags2", Ò(FLAGS1∫(˙ ﬂ ˙)) array_xor FLAGS2Æ),
    ("exp_binary_exp.20", exptest, "flags1 > flags2", Ò(FLAGS1∫(˙ ﬂ ˙)) array_greater FLAGS2Æ),
    ("exp_binary_exp.21", exptest, "flags1 < flags2", Ò(FLAGS1∫(˙ ﬂ ˙)) array_less FLAGS2Æ),
    ("exp_binary_exp.22", exptest, "flags1 >= flags2", Ò(FLAGS1∫(˙ ﬂ ˙)) array_greater_eq FLAGS2Æ),
    ("exp_binary_exp.23", exptest, "flags1 <= flags2", Ò(FLAGS1∫(˙ ﬂ ˙)) array_less_eq FLAGS2Æ)];
=TEX
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_binary_exp.30", exptest, "v + w", ÒV +âR WÆ),
    ("exp_binary_exp.31", exptest, "v - w", ÒV -âR WÆ),
    ("exp_binary_exp.32", exptest, "v * w", ÒV *âR WÆ),
    ("exp_binary_exp.33", exptest, "v ** a", ÒV ^âZ AÆ),
    ("exp_binary_exp.34", exptest, "v < w", ÒV real_less WÆ),
    ("exp_binary_exp.35", exptest, "v > w", ÒV real_greater WÆ),
    ("exp_binary_exp.36", exptest, "v <= w", ÒV real_less_eq WÆ),
    ("exp_binary_exp.37", exptest, "v >= w", ÒV real_greater_eq WÆ)];
=TEX
\subsection{Membership of a Range}
Tests for $exp\_mem\_range$.

1) range with explicit integer-valued lower and upper bounds:

=SML
local
val arg = "PAY_DAY not in SAT .. SUN";
val res = ÒPAY_DAY notmem SAT .. SUNÆ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_mem_range.1", exptest, arg, res)];
end;
=TEX
2) range given as a subtype indication:
=SML
local
val arg = "PAY_DAY in DAY";
val res = ÒPAY_DAY mem DAYÆ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_mem_range.2", exptest, arg, res)];
end;
=TEX
=TEX
3) range given with explicit real-valued lower and upper bounds:
=SML
local
val arg = "1.0 in -2.0 .. +2.0";
val res = Ò1.0 mem ~âR 2.0 ..âR 2.0Æ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_mem_range.3", exptest, arg, res)];
end;
=TEX
4) See next section for membership of range given as a range attribute.
\subsection{Attributes}
Tests for $exp\_attrib$.

1) Category A: Z definition generated at point of introducing type;
prefix given as a type mark:

=SML
local
val arg = "DAY'FIRST";
val res = ÒDAYvFIRSTÆ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_attrib.1", exptest, arg, res)];
end;
=TEX

2) Category A: Z definition generated at point of introducing type;
prefix given as a variable name:

=SML
local
val arg = "obj'FIRST";
val res = ÒARR2vFIRSTÆ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_attrib.2", exptest, arg, res)];
end;
=TEX

3) Category A: range attribute used as a range:
=SML
local
val arg = "MON in WEEK'RANGE";
val res = ÒMON mem WEEKvRANGEÆ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_attrib.3", exptest, arg, res)];
end;
=TEX
4) Category B: Z paragraph generated on first encountering a use
of the attribute:
=SML
local
val arg = "A'SIZE";
val res = mk_z_gvar("AvSIZE", type_ofÒ0Æ, []);
fun has_spec c = (z_get_spec c; true) handle Fail _ => false;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_attrib.4", exptest, arg, res)];
val _ = store_mt_results (mt_run)
    [("exp_attrib.4A", has_spec, res, true)];
end;
=TEX
5) Category A: prefix involving base attribute:
=SML
local
val arg = "DAY'BASE'FIRST";
val res = exptest "DAY'FIRST";
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_attrib.5", exptest, arg, res)];
end;
=TEX
6) Category C: user-defined Z paragraph introducing the Z
translation of the attribute:
πZAX
‹ AvADDRESS : ˙
∞
=SML
local
val arg = "A'ADDRESS";
val res = ÒAvADDRESSÆ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_attrib.6", exptest, arg, res)];
end;
=TEX
7) Category C: as (6) but with prefix involving base attribute:
πZAX
‹ DAYvBASEvSTORAGE_SIZE : ˙
∞
=SML
local
val arg = "DAY'BASE'STORAGE_SIZE";
val res = ÒDAYvBASEvSTORAGE_SIZEÆ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_attrib.7", exptest, arg, res)];
end;
=TEX

\subsection{Indexed Components}
Tests for $exp\_indexed\_comp$.
=SML
local
val arg = "THISWEEK(DAY'FIRST)";
val res = "ÒTHISWEEK DAYvFIRSTÆ";
in
val _ = store_mt_results (mt_runf (comp_z_exp))
    [("exp_indexed_comp", exptest, arg, res)];
end;
=TEX

\subsection{Selected Components}
Tests for $exp\_selected\_comp$.
=SML
local
val arg = "TODAY.DAY";
val res = "ÒTODAY.DAYÆ";
in
val _ = store_mt_results (mt_runf (op comp_z_exp))
    [("selected_comp", exptest, arg, res)];
end;
=TEX

\subsection{Functions Calls}
Tests for $exp\_fun\_call$.
=SML
local
val arg = "max(1,2)";
val res = ÒMAX (1, 2)Æ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_fun_call", exptest, arg, res)];
end;
=TEX


\subsection{Qualified Expressions}
Tests for $exp\_qualified$.
=SML
local
val arg = "DAYRANGE'(11)";
val res = Ò11Æ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_qualified", exptest, arg, res)];
end;
=TEX

\subsection{Type Conversions}
Tests for $exp\_type\_conv$.
=SML
local
val _ = change_env "DAYRANGE" {tipe = Value (type_ofÒ˙Æ), canon_name = "DAYRANGE", info = EIEnvOtherType, private = false};
val arg = "DAYRANGE(11)";
val res = Ò11Æ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_type_conv.1", exptest, arg, res)];
end;
=TEX
=SML
local
val _ = extend_env "FIX" {tipe = Value (type_ofÒFIXÆ), canon_name = "FIX", info = EIEnvOtherType, private = false};
val arg = "FIX(11)";
val res = Òinteger_to_real 11Æ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("ep_type_conv.2", exptest, arg, res)];
end;
=TEX
=SML
local
val arg = "DAYRANGE(3.14159)";
val res = Òreal_to_integer (3.14159)Æ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_type_conv.3", exptest, arg, res)];
end;
=TEX
=SML
local
val arg = "DATE(TODAY)";
in
val _ = store_mt_results mt_run_fail
    [("exp_type_conv.4", exptest, arg, gen_fail_msg "exp_type_conv" 508053 [])];
end;
=TEX

\subsection{Integer Literals}
Tests for $trans\_int$, $exp\_int\_lit$.
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_int_lit.1.1", exptest, "25", Ò25Æ),
    ("exp_int_lit.1.2", exptest, "15_234", Ò15234Æ),
    ("exp_int_lit.1.3", exptest, "12E3", Ò12000Æ),
    ("exp_int_lit.1.4", exptest, "12E+3", Ò12000Æ),
    ("exp_int_lit.1.5", exptest, "200E+2", Ò20000Æ),
    ("exp_int_lit.1.6", exptest, "2#101#", Ò5Æ),
    ("exp_int_lit.1.7", exptest, "2#101#e+2", Ò20Æ),
    ("exp_int_lit.1.8", exptest, "16#10#", Ò16Æ),
    ("exp_int_lit.1.9", exptest, "16#Ff#", Ò255Æ),
    ("exp_int_lit.1.10", exptest, "16#10#e2", Ò4096Æ),
    ("exp_int_lit.1.11", exptest, "11#A#e1", Ò110Æ)
];
=TEX
=SML
val _ = store_mt_results mt_run_fail [
    ("exp_int_lit.2.1", exptest, "2#3#",
	gen_fail_msg "trans_int" 508113 ["3", "2"]),
    ("exp_int_lit.2.2", exptest, "11#B#",
	gen_fail_msg "trans_int" 508113 ["B", "11"]),
    ("exp_int_lit.2.3", exptest, "11#B#e-1",
	gen_fail_msg "trans_int" 508110 ["-1"]),
    ("exp_int_lit.2.4", exptest, "17#B#",
	gen_fail_msg "trans_int" 508117 ["17"]),
    ("exp_int_lit.2.5", exptest, "1#0#",
	gen_fail_msg "trans_int" 508117 ["1"]),
    ("exp_int_lit.2.6", exptest, "10000#0#",
	gen_fail_msg "trans_int" 508117 ["10000"])
];
=TEX
\subsection{Real Literals}
Tests for $trans\_real$, $exp\_real\_lit$.
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_real_lit.1", exptest, "25.0", Ò25.0Æ),
    ("exp_real_lit.2", exptest, "15.234", Ò15.234Æ),
    ("exp_real_lit.3", exptest, "0.0", Ò0.0Æ),
    ("exp_real_lit.4", exptest, "1.0", Ò1.0Æ),
    ("exp_real_lit.5", exptest, "2.71828E+0", Ò2.71828Æ),
    ("exp_real_lit.6", exptest, "1.1e-6", Ò1.1e~6Æ),
    ("exp_real_lit.7", exptest, "100.0e200", Ò100.0e200Æ),
    ("exp_real_lit.8", exptest, "100.0e+200", Ò100.0e200Æ),
    ("exp_real_lit.9", exptest, "100.0e-200", Ò100.0e~200Æ),
    ("exp_real_lit.10", exptest, "2.718_28E+0", Ò2.71828Æ),
    ("exp_real_lit.11", exptest, "1_000_000.0E-6", Ò1000000.0e~6Æ)];
=TEX
\subsection{Character Literals}
Tests for $exp\_char\_lit$.
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_char_lit.1", exptest, "'a'", Òchar_lit "a"Æ),
    ("exp_char_lit.2", exptest, "'''", Òchar_lit "'"Æ)];
=TEX
\subsection{String Literals}
Tests for $exp\_string\_lit$.

We have to define a modified version of {\it exptest} to test string literals.

=SML
fun classify_label (itemlist : CN_LEX_ITEM list) : CN_LEX_ITEM list =
  (case itemlist
    of (LCLBracket, _)::(LCNumericLiteral, CNText ntxt)::(LCRBracket, _)::rest =>
      (
        (
          (case nat_of_string ntxt
            of 1 => LCCompLabel
             | 2 => LCPPartLabel
             | 3 => LCVPartLabel
             | 4 => LCDecLabel
             | 5 => LCStmtLabel
             | 6 => LCSpecLabel
             | _ => LCCompLabel
          ),
          CNText ("("^ntxt^")")
        )::rest
      )
     |_ => itemlist
  );
fun cn_exp_of_string_lit (s : string) = (
let	val prefix = "(6) √ a:= ";
	val epilogue = ";";
 	val inp = [Lex.Text prefix, Lex.String s, Lex.Text epilogue];
	val exp =  (CNParser.cn_parser o fst o (CNLex.cn_lex classify_label)) inp;
in
 	case exp of
	WCRefinedBy{statement=STAssign{e,...},...} => e
	|_ => fail "cn_exp_of_string" 508001 []
end
);
val €string_lit_test› = (trans_exp env) o (adjust_exp env) o cn_exp_of_string_lit;
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_string_lit.1", string_lit_test, "Hello World!", Òstring_lit "Hello World!"Æ),
    ("exp_string_lit.2", string_lit_test, "", Òstring_lit ""Æ)];
=TEX

\subsection{Auxiliary Expressions}
Tests for $exp\_auxiliary\_exp$.  Auxiliary expression are not yet supported
by the parser.

\subsection{The Function $trans\_exp$}\label{transexp}
Tests for $trans\_exp$, $trans\_exp1$.  This function is exercised by the tests above.  Theres just one more test to be done, for brackets.
=SML
local
val arg = "(42 + 13) * (17 + 19)";
val res = Ò(42 + 13) * (17 + 19)Æ;
in
val _ = store_mt_results (mt_runf (op =$))
    [("brackets.1", exptest, arg, res)];
end;
=TEX

\section{TESTS FOR BASIC DECLARATIONS}
=SML
fun €bdtest› (tm : TERM) : bool = ( case frees tm of [] => true |_ => false);
=TEX

\subsection{Constants}
Tests for $basic\_decl\_const$.
=SML
store_mt_results (mt_runf (op =))
    [	("constant.1", bdtest, ÒPAY_DAY = FRIÆ, true),
	("constant.2", bdtest, ÒCA = {}Æ, true)];
=TEX
=SML
cn_declare ["PAY_ROLL"] "PAY_DAY : constant DAY := FRI;";
store_mt_results (mt_runf (op =))
    [	("constant_3", bdtest, ÒPAY_ROLLoPAY_DAY = FRIÆ, true)];
=TEX
\subsection{Enumeration Types}
Tests for $basic\_decl\_enum$.
=SML
store_mt_results (mt_runf (op =))
    [("enumeration.1", bdtest, Ò{MON, TUE, WED, THU, FRI, SAT, SUN} Ä DAYÆ,
       true)];
=TEX
=SML
cn_declare ["TYPES"] "type BIT is (TT, FF);";
store_mt_results (mt_runf (op =))
    [	("enumeration.2", bdtest, Ò{TYPESoTT, TYPESoFF} Ä TYPESoBITÆ, true)];
=TEX
\subsection{Array Types}
Tests for $basic\_decl\_con\_array$ and $basic\_decl\_uncon\_array$.
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("array.1", bdtest, Ò{day : WEEK | SUN = day(1)}Æ, true),
    ("array.2", bdtest, Ò{day : WEEKUNCON | SUN = day(1)}Æ, true),
    ("array.3", bdtest, Ò{day : ARR2 | SUN = day(1, 2)}Æ, true),
    ("array.4", bdtest, Ò{day : UNCON2 | SUN = day(1, 2)}Æ, true)];
=TEX

\subsection{Record Types}
Tests for $trans\_decl$, $basic\_decl\_record$.
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("record", bdtest, ÒÕ DATE | DAY=6 ± MONTH=8 ∑ INTEGERÆ, true)];
=TEX

\subsection{Integer Types}
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("integer.1", bdtest, ÒHOURS † 0 .. 23Æ, true),
    ("integer.2", bdtest, ÒHOURSvFIRST < HOURSvLASTÆ, true),
    ("integer.3", bdtest, ÒHOURSvSUCC ¿ HOURSvPRED † ˙ ∏ ˙Æ, true),
    ("integer.4", bdtest, ÒHOURSvPOS ¿ HOURSvVAL † ˙ ∏ ˙Æ, true)
];
=TEX
\subsection{Real Types}
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("real.1", bdtest, ÒFIX ç  FIXÆ, true),
    ("real.2", bdtest, ÒFLOAT1 ç  FLOAT1Æ, true)
];
=TEX

\subsection{Subtypes}
Tests for $basic\_decl\_subtype\_range\_con$ etc..
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("subtype.1", bdtest, ÒMON ç WEEKDAYÆ, true),
    ("subtype.2", bdtest, ÒSUN é {WEEKDAYvFIRST, WEEKDAYvLAST}Æ, true),
    ("subtype.3", bdtest, ÒWEEKDAYvSUCC ¿ WEEKDAYvPRED Ä ˙ ∏ ˙Æ, true),
    ("subtype.4", bdtest, ÒWEEKDAYvPOS ¿ WEEKDAYvVAL Ä ˙ ∏ ˙Æ, true)
];
=TEX
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("subtype.5", bdtest, ÒSUBFIX1 Ω FIXÆ, true),
    ("subtype.6", bdtest, Ò8 ç SUB1Æ, true),
    ("subtype.7", bdtest, ÒSUBFLOAT Ä FLOAT1Æ, true),
    ("subtype.9", bdtest, ÒSUBFIX2 Ä FIXÆ, true),
    ("subtype.10", bdtest, ÒSUB2 Ä UNCON2Æ, true),
    ("subtype.11", bdtest, ÒWEEKDAYUNCON Ä WEEKUNCONÆ, true),
    ("subtype.12", bdtest, ÒSUB3 = SUB2Æ, true),
    ("subtype.13", bdtest, ÒALLINTEGERSvFIRST Ω ALLINTEGERSvLASTÆ, true),
    ("subtype.14", bdtest, ÒINWEEKvFIRST Ω INWEEKvLASTÆ, true)
];
=TEX
=SML
cn_declare ["CALENDAR"] "subtype INWEEK is WEEK;";
val _ = store_mt_results (mt_runf (op =)) [
    ("subtype.15", bdtest, ÒCALENDARoINWEEK = WEEKÆ, true)
];
=TEX
\subsection{The Function $trans\_basic\_decl$}
Tests for $trans\_basic\_decl$, $trans\_basic\_decl1$.  These have been exercised by the above tests.

\section{ADJUSTMENT OF ABSTRACT SYNTAX FOR EXPRESSIONS}
Tests for $named\_assocs\_to\_exps$, $adjust\_exp$, $adjust\_exp1$.  These have been exercised by the above tests.

=TEX
\section{SUMMARY OF RESULTS}

=SML
diag_line(summarize_mt_results());
=TEX

\end{document}
