%  mdt508.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Basic Declarations and Expressions}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT508}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{D.J.~King & WIN01\\A.C.~Hayward & WIN01}
\TPPauthorisation{R.D.~Arthan &}
\TPPabstract{
This document comprises test cases and test code/data for
testing the DAZ parser as described in the document
ISS/HAT/DAZ/DTD508.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ A.C. Hayward\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1]
First draft.

\end{description}
\subsection{Changes Forecast}
As the DAZ Compliance Notation Parser is extended, so will this document.
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises test cases and test code/data for
testing the DAZ Compliance Notation Parser specified in \cite{ISS/HAT/DAZ/DTD508}, and for the DAZ SPARK Output Function as specified in \cite{ISS/HAT/DAZ/DTD510}.

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the DAZ Compliance Notation Parser as defined in \cite{ISS/HAT/DAZ/DTD508} and implemented in \cite{ISS/HAT/DAZ/IMP508}, and for the DAZ SPARK Output Function as defined in \cite{ISS/HAT/DAZ/DTD510} and implemented in \cite{ISS/HAT/DAZ/IMP510}. The tests are intended to meet the requirements for tests identified in the quality plan \cite{ISS/HAT/DAZ/PLN003}.

\subsubsection{Dependencies}

These tests depend on the test harness as implemented in DS/FMU/IED/IMP013, and its corresponding detailed design document, DS/FMU/IED/DTD013.

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

There are no known deficiencies.

\section{TEST CASES}

\section{PREAMBLE}
Set up the theory database as necessary.

=SML
use_file "dtd013";
use_file "imp013";
	open CaseIndependence CNTypes CNBasicDeclsAndExprs ZProofMode;
=TEX

=SML
open_theory "daz_toolkit_extensions";
force_delete_theory "mdt508_test" handle (_) => ();
new_theory "mdt508_test";
=TEX
\section{SUPPORTING FUNCTIONS}

\subsection{String to Expression/Declaration Conversion}
This section of code takes a string and parses it into CN.

=SML
local
fun classify_label (itemlist : CN_LEX_ITEM list) : CN_LEX_ITEM list =
  (case itemlist
    of (LCOrd, _)::(LCNumericLiteral, CNText ntxt)::(LCCrd, _)::rest =>
      (
        (
          (case nat_of_string ntxt
            of 1 => LCCompLabel
             | 2 => LCPPartLabel
             | 3 => LCVPartLabel
             | 4 => LCDecLabel
             | 5 => LCStmtLabel
             | 6 => LCSpecLabel
             | _ => LCCompLabel
          ),
          CNText ("("^ntxt^")")
        )::rest
      )
     |_ => itemlist
  );
in
fun €cn_of_string› (s : string) : CNTypes.WEB_CLAUSE = (
  let
    val inp = [Lex.Text s];
  in
    (CNParser.cn_parser o (CNLex.cn_lex classify_label)) inp
  end)
end;
=TEX
\subsection{Test Environment}
=SML
fun init_env id = (
	case get_const_info ("z'"^id) of
	Value (ty,_) => Value (ty, EIEnvOther)
	|Nil => Nil
);

fun €make_env› (env : CN_ENV) (tm : TERM) (envty : ENV_INFO) = (
let	val (id, ty, _) = dest_z_gvar tm;
in
	fn id' =>
		if to_upper id' = id
		then	Value (ty, envty)
		else	env id'
end
);
=TEX

\section{INITIALISATION}
First we need to initialise the test results routine.

=SML

init_mt_results();

=TEX
\section{BASIC DECLARATIONS}
=SML
fun €cn_basic_decl_of_string› (s : string) : BASIC_DECL = (
let	val prefix = "(4) È ";
	val epilogue = ";";
	val result = cn_of_string (prefix^s^";");
in
	case result of
	WCReplacedByDecl{decls=[DBasicDecl d],...} => d
	|_ => fail "cn_decl_of_string" 508001 []
end);
=TEX
=SML
fun €update_db_with_parainfo› (p : PARAINFO) : unit = (
let	val iw = get_flag"ignore_warnings";
	val side = set_flag("ignore_warnings", true);
	fun do_const(s, tm) =
	let	val side = delete_const(mk_const ("z'"^s, type_of tm))
			handle _ => (set_flag("ignore_warnings", iw);())
		val side = new_const("z'"^s, type_of tm);
		val side = set_flag("ignore_warnings", iw);
	in () end;
	fun do_ty (tc, i) =
	let	val side = delete_type tc handle _ => ();
		val side = (new_type (tc, i);()) handle _ => ();
	in () end;
in
	case p of
	AbbDefInfo (s, _, tm) => (map do_ty (type_tycons (type_of tm));
					do_const (s, tm))
	|_ => ()
end
);
=TEX
=SML
fun €var_decl› (names, tm) = (
let	val ty=(dest_z_power_type o type_of) tm;
in
	map (fn n => new_const ("z'"^n, ty)) names
end
);
=TEX
=SML
fun €declaration› (s : string) : PARAINFO list = (
let	val paras = ((trans_basic_decl init_env) o cn_basic_decl_of_string) s;
	val side = map update_db_with_parainfo paras;
in
	paras
end);
=SML
fun €bdtest› (tm : TERM) : bool = (
	case frees tm of
	[] => true
	|_ => false
);
=TEX
=TEX
\subsection{Translating Enumeration Types}
=SML
val bd1 = declaration "type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN)";
store_mt_results (mt_runf (op =)) [
("bd1", bdtest, Ò{MON, TUE, WED, THU, FRI, SAT, SUN} Ä DAYÆ, true)];
=TEX
\subsection{Translating Constants}
=SML
val bd2 = declaration "PAY_DAY : constant WEEKDAY := FRI";
store_mt_results (mt_runf (op =)) [
("bd2", bdtest, ÒPAY_DAY = FRIÆ, true)];
=TEX
\subsection{Translating Array Types}
=SML
val bd3 = declaration "type ARR is array (DAY) of DAY";
val bd4 = declaration "type UNCON is array (DAY range <>) of DAY";
store_mt_results (mt_runf (op =)) [
("bd3", bdtest, Ò{day : ARR | SUN = day(1)}Æ, true),
("bd4", bdtest, Ò{day : UNCON | SUN = day(1)}Æ, true)];
=TEX
\subsection{Translating Record Types}
=SML
val bd5 = declaration "type REC is record START : DAY; FINISH : DAY; YESTERDAY : ARR; end record";
store_mt_results (mt_runf (op =)) [
("bd5", bdtest, ÒÕ REC | START=FINISH=FRI ∑ YESTERDAYÆ, true)];
=TEX
\subsection{Translating Subtypes}
=SML
val bd6 = declaration "subtype WEEKDAY is DAY range MON..FRI";
val bd7 = declaration "subtype SUB is UNCON(WEEKDAY)";
store_mt_results (mt_runf (op =)) [
("bd6", bdtest, ÒMON ç WEEKDAYÆ, true),
("bd7", bdtest, ÒSUN ç {MON,TUE, WED, THU, FRI}Æ, true)];
=TEX
\subsection{Translating Integer Types}
=SML
val bd8 = declaration "type HOURS is range 0..23";
store_mt_results (mt_runf (op =)) [
("bd8", bdtest, ÒHOURS † 0 .. 23Æ, true)];
=TEX

\section{EXPRESSIONS}
=SML
fun €cn_exp_of_string› (s : string) : EXP = (
let	val prefix = "√ a:= ";
	val epilogue = ";";
	val result = cn_of_string (prefix^s^";");
in
	case result of
	WCRefinedBy{statement=SStmt(STAssign{e,...}),...} => e
	|_ => fail "cn_exp_of_string" 508001 []
end);
=TEX

=SML
fun €etest0› env = (trans_exp env) o (adjust_exp env) o cn_exp_of_string;
=TEX
=SML
val €etest› = etest0 init_env;
=TEX

=SML
var_decl (["TOMORROW"], ÒARRÆ);
var_decl (["REC2"], ÒRECÆ);
var_decl (["A", "B"], ÒHOURSÆ);
var_decl (["MAX"], Ò(DAY ∏ DAY)≠ DAYÆ);
=TEX
=SML
val env_max = make_env init_env ÒMAXÆ (EIEnvFunction[]);

val env_rec = make_env init_env ÒRECÆ EIEnvRecordAgg;
=TEX
\subsection{Identifiers}
=SML
store_mt_results (mt_runf (op =$)) [
("id1", etest, "a", ÒAÆ),
("id2", etest, "A", ÒAÆ),
("id3", etest, "DAY", ÒDAYÆ)
];
=TEX

\subsection{Aggregates (Positional Array)}
=SML
val arg = "ARR'(TUE,WED,THU,FRI,SAT,SUN,MON)";
val res = Òsucc Á 1 - ARRvFIRST Í ª ßTUE,WED,THU,FRI,SAT,SUN,MON¢Æ;
store_mt_results (mt_runf (op =$)) [
("arraggpos", etest, arg, res)
];
=TEX

\subsection{Aggregates (Positional Array with Others)}

etest "ARR'(THU,WED,SUN, others=> SAT)";
=SML
val arg = "ARR'(THU,WED,SUN, others=> SAT)";
val res = Ò(ARRvRANGE ∏ {SAT}) ´ (succ Á 1 - ARRvFIRST Í ª ßTHU, WED, SUN¢)Æ;
store_mt_results (mt_runf (op =$)) [
("arraggposoth", etest, arg, res)
];
=TEX
\subsection{Aggregates (Positional Array with Just Others)}
=SML
val arg = "ARR'(others=>WED)";
val res = ÒARRvRANGE ∏ {WED}Æ;
store_mt_results (mt_runf (op =$)) [
("arraggoth", etest, arg, res)
];
=TEX

\subsection{Aggregates (Named Array)}
=SML
val arg="ARR'(MON..THU | FRI => WED, SAT | SUN => TUE)";
val res = Ò((MON .. THU) ¿ {FRI} ∏ {WED}) ¿ ({SAT,SUN} ∏ {TUE})Æ;
store_mt_results (mt_runf (op =$)) [
("arraggnamed", etest, arg, res)
];
=TEX
\subsection{Aggregates (Named Array with Others)}
=SML
val arg="ARR'(MON..FRI => WED, others => TUE)";
val res = Ò(ARRvRANGE ∏ {TUE}) ´ (MON..FRI ∏ {WED})Æ;
store_mt_results (mt_runf (op =$)) [
("arraggnamedothers", etest, arg, res)
];
=TEX

\subsection{Aggregates (Positional Record)}
=SML
val arg="REC'(WED,SUN,ARR'(others => THU))";
val res = ÒÕ REC |
	FINISH = WED ± START = SUN ± YESTERDAY = ARRvRANGE ∏ {THU} ∑ RECÆ;
store_mt_results (mt_runf (op =$)) [
("recaggpos", etest0 env_rec, arg, res)
];
=TEX

\subsection{Aggregates (Named Record)}
=SML
val arg="REC'(START => THU, FINISH => FRI, YESTERDAY => ARR'(others => SUN))";
val res = ÒÕ REC |
	START = THU ± FINISH = FRI ± YESTERDAY = ARRvRANGE ∏ {SUN} ∑ RECÆ;
store_mt_results (mt_runf (op =$)) [
("recaggnamed", etest0 env_rec, arg, res)
];
=TEX


\subsection{Unary Expressions}
=SML
store_mt_results (mt_runf (op =$)) [
("unary1", etest, "3", Ò3Æ),
("unary2", etest, "+3", Ò3Æ),
("unary3", etest, "-3", Ò~3Æ),
("unary4", etest, "not a", Ònot AÆ),
("unary5", etest, "abs 0", ÒAbs 0Æ)
];
=TEX
\subsection{Binary Expressions}
=SML
store_mt_results (mt_runf (op =$)) [
("binop1", etest, "a and b", ÒA and BÆ),
("binop2", etest, "a or b", ÒA or BÆ),
("binop3", etest, "a xor b", ÒA xor BÆ),
("binop7", etest, "a = b", ÒA eq BÆ),
("binop8", etest, "a /= b", ÒA noteq BÆ),
("binop9", etest, "a < b", ÒA less BÆ),
("binop10", etest, "a > b", ÒA greater BÆ),
("binop11", etest, "a >= b", ÒA greater_eq BÆ),
("binop12", etest, "a + b", ÒA + BÆ),
("binop13", etest, "a - b", ÒA - BÆ),
("binop14", etest, "a * b", ÒA * BÆ),
("binop15", etest, "a / b", ÒA intdiv BÆ),
("binop16", etest, "a mod b", ÒA mod BÆ)
];
=TEX
\subsection{Membership of a Range}
=SML
store_mt_results (mt_runf (op =$)) [
("memop", etest, "PAY_DAY not in SAT .. SUN", ÒPAY_DAY notmem SAT .. SUNÆ)
];
=TEX

\subsection{Attributes}
=SML
store_mt_results (mt_runf (op =$)) [
("attrib", etest, "WEEKDAY'FIRST", ÒWEEKDAYvFIRSTÆ)
];
=TEX

\subsection{Indexed Components}
=SML
store_mt_results (mt_runf (op =$)) [
("indexed_comp", etest, "TOMORROW(DAY'FIRST)", ÒTOMORROW(DAYvFIRST)Æ)
];
=TEX

\subsection{Selected Components}
=SML
store_mt_results (mt_runf (op =$)) [
("selected_comp", etest, "REC2.FINISH", ÒREC2.FINISHÆ)
];
=TEX

\subsection{Functions Calls}
=SML
store_mt_results (mt_runf (op =$)) [
("fun_call", etest0 env_max, "MAX(WED, DAY'LAST)", ÒMAX(WED,DAYvLAST)Æ)
];
=TEX

\subsection{Integer Literals}
=SML
store_mt_results (mt_runf (op =$)) [
("intlit1", etest, "25", Ò25Æ),
("intlit2", etest, "15_234", Ò15234Æ),
("intlit3", etest, "12E3", Ò12000Æ),
("intlit4", etest, "12E+3", Ò12000Æ),
("intlit5", etest, "200E-2", Ò2Æ),
("intlit6", etest, "2#101#", Ò5Æ),
("intlit7", etest, "2#101#e+2", Ò20Æ)
];
=TEX
\subsection{Auxiliary Expressions}

\section{SUMMARY OF RESULTS}

=SML
diag_line(summarize_mt_results());
=TEX

\end{document}


=IGN
z"DAYS(1)";

z"f(1,2)";
z"F(1,2)";
z"RECS'(1)";
z"REC'(1=>r,2=>3)";
z"REC'(1,2)";
z"REC'(1)";
z"abc'(a=>0, b=>10, c=>20)"; (* wrong error message *)
z"FN(a=>0, b=>10, c=>20)";
z"FN(b=>10, a=>0, c=>20)";
z"FN(c=>20, b=>10, a=>0)";
z"FN(c=>20, a=>0)"; (* crap error message *)
z"FN(c=>20, a=>0, a=>0)";
z"FN(c=>20, a=>0, a=>0, b=> 4)"; (* crap error message *)
z"FN(c=>20, a=>0, d=>2)"; (* crap error message *)



z"f(a(f(2,3)))(4)"; (* problem with arrays and attributes - these do not
		     * appear as constants in the theory database.
		     *);
z"r(1)";






fun make_env env envty ((id,ty)::rest) = (
	fn id' =>
		if to_upper id' = id
		then	Value (ty, envty)
		else	make_env env envty rest id'
) | make_env env _ _ = env;

val env2 = make_env env1 (EIEnvFunction[])
	[("F", type_of Ò˙≠˙Æ),("G", type_of Ò˙≠˙Æ)];

val env3 = make_env env2 EIEnvRecordAgg
	[("REC", type_of Ò[a:˙]Æ)];

val env4 = make_env env3 (EIEnvFunction["a","b","c"])
	[("FN", type_of Ò˙≠˙Æ)];

val t = cn_exp_of_string;

val €f1›  = (adjust_exp init_env) o cn_exp_of_string;

new_axiom(["fred"],etest"max(2)");
