=IGN
********************************************************************************
mdt508.doc: this file is part of the PPDaz system

Copyright (c) 2002 Lemma 1 Ltd.

See the file LICENSE for your rights to use and change this file.

Contact: Rob Arthan < rda@lemma-one.com >
********************************************************************************
% $Header: /home/rda/daz/RCS/mdt508.doc,v 1.45 2006/06/12 16:42:15 rda Exp rda $
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Basic Declarations and Expressions}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT508}  %% Mandatory field
\def\SCCSversion{$Revision: 1.45 $
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2006/06/12 16:42:15 $
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
%\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{D.J.~King & WIN01\\A.C.~Hayward & WIN01}
\TPPauthorisation{R.D.~Arthan & HAT Team}
\TPPabstract{
This document comprises test cases and test code/data for
testing the Declaration and Expression generator as described in the document
ISS/HAT/DAZ/DTD508.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : Lemma 1 Ltd. \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1-1.4] Initial Drafts
\item[Issue 1.5] First draft for review.
\item[Issues 1.6-1.10] Finished all tests.
\item[Issues 1.10-1.18] Updates for enhancements.
\item[Issue 1.19] Test for fix of DRA bug 11 (V0.6).
\item[Issue 1.20] IUCT WP7 changes.
\item[Issue 1.21] Update for SML'97 port.
\item[Issue 1.22] CTLE II R1/4 --- logical operators on arrays of booleans.
\item[Issues 1.23,1.24] CTLE II R1/1 --- real types.
\item[Issue 1.25,1.26] CTLE II --- consolidated coverage of various enhancements.
\item[Issue 1.27] Fixed duplicated test identities and erroneous test of exponentiation.
\item[Issue 1.28] Added tests for underscores in real numbers.
\item[Issue 1.29] Adjusted for revisions to treatment of aggregates.
\item[Issue 1.30] Adjusted for change to signature of {\it z\_schema}.
\issue[Issue 1.31] New syntax for discriminants.
\item[Issue 1.32] {\it zsucc} is now called {\it z\_succ}.
\item[Issue 1.33] Allowed for syntax for block statements.
\item
\item[Issue 1.34] Copyright and banner updates for open source release.
\item[Issue 1.35, 1.36] DAZ-specific updates to banner for open source release
\item[Issue 1.37] Uniform treatment of block statements.
\item[Issue 1.38] The SPARK program is now referred to as the Ada program.
\item[Issue 1.39] Allowed for data type changes for environment reform.
\item[Issue 1.40] Adjustments to lexical class data type (for syntax of Ada labels).
\item[Issue 1.41] Allowed for changed signatures.
\item[Issue 1.42] Allowed for changes to {\em cn\_declare} and added selected tests for changes to {\em trans\_basic\_decl}.
\item[Issue 1.43] Allowed for automated state management.
\item[Issue 1.44] Ada real literals are now translated into Z floating point literals.
\item[Issue 1.45] Added tests for improved error handlling for numeric literals.
\item[Issue 1.46] Allowed for type changes for child packages.
\end{description}
\subsection{Changes Forecast}
None.
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises test cases and test code/data for
testing the Compliance Notation Declaration and Expression generator as specified in \cite{ISS/HAT/DAZ/DTD508}.

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the Basic Declaration and Expression generator as defined in \cite{ISS/HAT/DAZ/DTD508} and implemented in \cite{ISS/HAT/DAZ/IMP508}. The tests are intended to meet the requirements for tests identified in the quality plan \cite{ISS/HAT/DAZ/PLN003}.

\subsubsection{Dependencies}

These tests depend on the test harness as implemented in \cite{DS/FMU/IED/IMP013}, and its corresponding detailed design document, \cite{DS/FMU/IED/DTD013}. Additionally, the tests make use of utilities defined in \cite{ISS/HAT/DAZ/DTD515} and implemented in \cite{ISS/HAT/DAZ/IMP515}.

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

There are no known deficiencies.

\section{PREAMBLE}
Set up the theory database as necessary.

=SML
use_file "dtd013";
use_file "imp013";
init_mt_results();
=TEX

Set up the theory database as necessary.

=SML
use_file "dtd515";
use_file "imp515";
open_theory "cn";
force_delete_theory "mdt508_test" handle (_) => ();
new_theory "mdt508_test";
=TEX

=SML
open CNTypes CNBasicDeclsAndExprs ZParagraphs;
=TEX

\section{INITIALISATION AND SUPPORTING FUNCTIONS}

=SML
fun Ûcomp_z_expÝ ((x,y) : Z_EXP * string) : bool =
    (string_of_term x) = y;
=TEX

=SML
val _ = (* CNTestUtilities. *) init_env();
=TEX

Declare identifiers needed for the tests.
=SML
cn_declare [] "FUNCTION max (a, b : INTEGER) return INTEGER;";
cn_declare [] "subtype DAYRANGE is INTEGER range 1..31;";
cn_declare [] "subtype MONTHRANGE is INTEGER range 1..12;";
cn_declare [] "subtype YEARRANGE is INTEGER range 1..4000;";
cn_declare [] "subtype ALLINTEGERS is INTEGER;";
cn_declare [] "type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);";
cn_declare [] "type WEEK is array (DAY) of integer;";
cn_declare [] "type WEEKUNCON is array (DAY range <>) of integer;";
cn_declare [] "type DATE is record DAY : DAYRANGE; MONTH : MONTHRANGE;\
           \YEAR : YEARRANGE; end record;";
cn_declare [] "type HOURS is range 0..23;";
cn_declare [] "subtype WEEKDAY is DAY range MON..FRI;";
cn_declare [] "subtype WEEKDAYUNCON is WEEKUNCON(WEEKDAY);";
change_env "DATE" ({
	tipe = Nil,
	canon_name = "DATE",
	info = EIEnvRecordType{comp_names = ["DAY", "MONTH", "YEAR"], num_discs = 0},
	private = false});
cn_declare [] "TODAY : DATE;";
cn_declare [] "A,B : integer;";
cn_declare [] "type FLAGS is array(DAY) of BOOLEAN;";
cn_declare [] "flags1, flags2 : FLAGS;";
cn_declare [] "PAY_DAY : constant DAY := FRI;";
cn_declare [] "type CHAR_ARRAY is array (DAY) of CHARACTER;";
cn_declare [] "CA : constant CHAR_ARRAY := CHAR_ARRAY'\
\\t\t(others => 'a');";
cn_declare [] "THISWEEK : WEEK;";
cn_declare [] "type ARR2 is array (DAY, HOURS) of DAY;";
cn_declare [] "type UNCON2 is array (DAY range <>, HOURS range <>) of integer;";
cn_declare [] "type FIX is delta 0.1 range 5.1 .. 10.0;";
cn_declare [] "R : FIX;";
cn_declare [] "type FLOAT1 is digits 7 range -1.0 .. 1.0;";
cn_declare [] "subtype SUBFIX1 is FIX range 7.0 .. 9.0;";
cn_declare [] "subtype SUB1 is INTEGER range INTEGER(7.2) .. 10;";
cn_declare [] "subtype SUBFLOAT is FLOAT1 digits 4 range -0.8 .. 0.8;";
cn_declare [] "subtype SUBFIX2 is FIX delta 0.3 range 6.0 .. 10.0;";
cn_declare [] "subtype SUB2 is UNCON2(WEEKDAY, HOURS);";
cn_declare [] "subtype SUB3 is SUB2;";
cn_declare [] "subtype INWEEK is WEEK;";
cn_declare [] "V, W : FLOAT1;";
cn_declare [] "obj : ARR2;";
=TEX

ÿONE
Üone : ú
÷
Üone = 1
ˆ

\section{TESTS FOR Z ABSTRACT SYNTAX}

=SML
store_mt_results (mt_runf comp_z_exp) [
    ("zabstract.1", (fn x => x), z_unary_minus, "ñ(~ _)®"),
    ("zabstract.2", (fn x => x), z_bool_not, "ñ(not _)®"),
    ("zabstract.3", (fn x => x), z_abs, "ñ(abs _)®")];
=TEX

=SML
store_mt_results (mt_runf comp_z_exp) [
    ("zabstract.4", (fn x => x), z_bool_and, "ñ(_ and _)®"),
    ("zabstract.5", (fn x => x), z_bool_or, "ñ(_ or _)®"),
    ("zabstract.6", (fn x => x), z_bool_xor, "ñ(_ xor _)®"),
    ("zabstract.7", (fn x => x), z_bool_eq, "ñ(_ eq _)®"),
    ("zabstract.8", (fn x => x), z_bool_noteq, "ñ(_ noteq _)®"),
    ("zabstract.9", (fn x => x), z_bool_less, "ñ(_ less _)®"),
    ("zabstract.10", (fn x => x), z_bool_less_eq, "ñ(_ less_eq _)®"),
    ("zabstract.11", (fn x => x), z_bool_greater, "ñ(_ greater _)®"),
    ("zabstract.12", (fn x => x), z_bool_greater_eq, "ñ(_ greater_eq _)®"),
    ("zabstract.13", (fn x => x), z_add, "ñ(_ + _)®"),
    ("zabstract.14", (fn x => x), z_minus, "ñ(_ - _)®"),
    ("zabstract.15", (fn x => x), z_times, "ñ(_ * _)®"),
    ("zabstract.16", (fn x => x), z_intdiv, "ñ(_ intdiv _)®"),
    ("zabstract.17", (fn x => x), z_mod, "ñ(_ intmod _)®"),
    ("zabstract.18", (fn x => x), z_rem, "ñ(_ rem _)®"),
    ("zabstract.19", (fn x => x), z_expon, "ñ(_ ** _)®"),
    ("zabstract.20", (fn x => x), z_bool_mem, "ñ(_ mem _)®"),
    ("zabstract.21", (fn x => x), z_bool_notmem, "ñ(_ notmem _)®")];
=TEX

=SML
store_mt_results (mt_runf comp_z_exp) [
    ("zabstract.22", (fn x => x), z_succ, "ñsucc®"),
    ("zabstract.23", (fn x => x), zid env "DAY", "ñDAY®"),
    ("zabstract.24", (fn x => x), z_num (@@"42"), "ñ42®"),
    ("zabstract.25", (fn x => x),
        z_tfun (ñDAY®, ñINTEGER®), "ñDAY ­ INTEGER®"),
    ("zabstract.26", (fn x => x),
        z_pfun (ñDAY®, ñINTEGER®), "ñDAY ß INTEGER®"),
    ("zabstract.27", (fn x => x), z_rng (ñ1®, ñ42®), "ñ1 .. 42®"),
    ("zabstract.28", (fn x => x), z_dom ñmax®, "ñdom max®"),
    ("zabstract.29", (fn x => x),
        z_dom_res (ñINTEGER®, ñsucc®), "ñINTEGER ò succ®"),
    ("zabstract.30", (fn x => x), z_inv ñsucc®, "ñsucc ç~ê®"),
    ("zabstract.31", (fn x => x), z_id_rel ñINTEGER®, "ñid INTEGER®"),
    ("zabstract.32", (fn x => x), z_size ñDAY®, "ñ# DAY®"),
    ("zabstract.33", (fn x => x),
        z_set [ñMON®, ñTUE®, ñWED®, ñTHU®, ñFRI®, ñSAT®, ñSUN®],
        "ñ{MON, TUE, WED, THU, FRI, SAT, SUN}®"),
    ("zabstract.34", (fn x => x),
        z_set_minus (ñDAY®, ñ{MON}®), string_of_term ñDAY \ {MON}®),
    ("zabstract.35", (fn x => x),
        z_set_comp (mk_z_dec ([ña®],ñú®),ña>42®), "ñ{a : ú | a > 42}®"),
    ("zabstract.36", (fn x => x), z_power (ñsucc®,ñ2®), "ñsucc ç 2 ê®"),
    ("zabstract.37", (fn x => x),
        z_rel_comp (ñmax®, ñsucc®), "ñmax » succ®"),
    ("zabstract.38", (fn x => x), z_seq [ñ1®,ñ42®], "ñ§1, 42¢®"),
    ("zabstract.39", (fn x => x),
        z_cross (ñINTEGER®,ñDAY®), "ñINTEGER ¸ DAY®"),
    ("zabstract.40", (fn x => x), z_override (ñmax®,ñmax®), "ñmax « max®"),
    ("zabstract.41", (fn x => x),
        z_many_union [ñ1..2®,ñ3..4®], "ñ(1 .. 2) À (3 .. 4)®")];
=TEX

=SML
store_mt_results (mt_runf comp_z_exp) [
    ("zabstract.43", (fn x => x), z_unary_exp (ñ(~ _)®, ñ42®), "ñ~ 42®"),
    ("zabstract.44", (fn x => x),
        z_bin_exp (ñ42®, ñ(_ + _)®, ñ42®), "ñ42 + 42®"),
    ("zabstract.45", (fn x => x), z_fun_call (ñsucc®, [ñ42®]), "ñsucc 42®"),
    ("zabstract.46", (fn x => x),
        z_selection (ñTODAYºDATE®,"YEAR"), "ñTODAY.YEAR®"),
    ("zabstract.47", (fn x => x),
        z_maplet (ñINTEGER®, ñDATE®), "ñINTEGER í DATE®"),
    ("zabstract.48", (fn x => x),
        other_z_exp ñ42®, "ñ42®"),
    ("zabstract.49", (fn x => x), z_eq (ñ42®,ñ42®), "ñ42 = 42®"),
    ("zabstract.50", (fn x => x), z_and (ñtrue®,ñfalse®), "ñtrue ± false®"),
    ("zabstract.51", (fn x => x),
        z_many_and [ñtrue®, ñfalse®, ñtrue®], "ñtrue ± false ± true®"),
    ("zabstract.52", (fn x => x), z_elem (ñMON®,ñDAY®), "ñMON  DAY®"),
    ("zabstract.53", (fn x => x), z_noteq (ñ42®,ñMON®), "ñ42 ½ MON®"),
    ("zabstract.54", (fn x => x), z_less_eq (ñ1®, ñ42®), "ñ1 ¼ 42®"),
    ("zabstract.55", (fn x => x), z_greater (ñ42®,ñ1®), "ñ42 > 1®"),
    ("zabstract.56", (fn x => x),
        z_forall ([mk_z_dec ([ña®],ñú®)], ñtrue®), "ñµ a : ú · true®"),
    ("zabstract.57", (fn x => x), z_imp (ñtrue®, ñtrue®), "ñtrue ´ true®"),
    ("zabstract.58", (fn x => x),
        other_z_pred ñtrue®, "ñtrue®")];
=TEX

=SML
fun Ûcomp_abbdef_infoÝ ((x,y) : PARAINFO * PARAINFO) : bool = (
    case (x, y) of
	(AbbDefInfo (s1, ss1, t1), AbbDefInfo (s2, ss2, t2)) =>
		s1 = s2 andalso ss1 = ss2 andalso t1 =$ t2
	| _ => false
);
store_mt_results (mt_runf comp_abbdef_info) [
    ("zabstract.59", (fn x => x), z_eq_eq "test" ("TODAY", ñtrue®), AbbDefInfo
      ("TODAY", [], ñtrue®)),
    ("zabstract.60", (fn x => x), z_schema ("TODAY", [mk_z_dec ([ñaºú®],ñú®)], z_true),
      AbbDefInfo ("TODAY", [], ñ[a : ú]®))];
=TEX

\section{TESTS FOR EXPRESSIONS}
The following function is convenient for supplying test data in
concrete syntax format. For historical reasons, it is not always
used where it might have been.
=SML
val ÛexptestÝ = (trans_exp env) o (adjust_exp env) o cn_exp_of_string;
=TEX

\subsection{Identifiers}
Tests for $trans\_id$.
=SML
store_mt_results mt_run [
    ("trans_id.1", trans_id, "TODAY.YEAR", "TODAYoYEAR"),
    ("trans_id.2", trans_id, "DAY'FIRST", "DAYvFIRST")];
=TEX

\subsection{Aggregates (Positional Array)}
Tests for $zfst$, $zlst$, $zsuc$, $zpred$, $zpos$, $zval$, $zlength$, $zrange$ and $exp\_array\_agg\_pos$.
=SML
store_mt_results mt_run [
    ("zfst", (fn x => x), zfst, "FIRST"),
    ("zlst", (fn x => x), zlst, "LAST"),
    ("zsuc", (fn x => x), zsuc, "SUCC"),
    ("zpred", (fn x => x), zpred, "PRED"),
    ("zpos", (fn x => x), zpos, "POS"),
    ("zval", (fn x => x), zval, "VAL"),
    ("zlength", (fn x => x), zlength, "LENGTH"),
    ("zrange", (fn x => x), zrange, "RANGE"),
    ("^^", (fn x => x), "DAY" ^^ "FIRST", "DAYvFIRST")];
local
val exp = EArrayAggPos
   {comps =
      [EId "TUE", EId "WED", EId "THU", EId "FRI", EId "SAT", EId "SUN",
         EId "MON"],
      tmark = Value "WEEK"};
val res = ñsucc ç 1 - WEEKvFIRST ê » §TUE,WED,THU,FRI,SAT,SUN,MON¢®;
in
val _ = store_mt_results (mt_runf (op =$))
        [("exp_array_agg_pos", trans_exp env, exp, res)];
end;
=TEX

\subsection{Aggregates (Positional Array with Others)}
Tests for $exp\_array\_agg\_pos\_others$.
=SML
local
val exp = EArrayAggPosOthers
   {others = {others = EId "SAT"},
      agg_pos =
      {comps = [EIntReal "1", EIntReal "1", EIntReal "1", EIntReal "1", EIntReal "1"],
         tmark = Value "WEEK"}};
val res = ñ(WEEKvRANGE ¸ {SAT}) « (succ ç 1 - WEEKvFIRST ê » §1, 1, 1, 1, 1¢)®;
in
val _ = store_mt_results (mt_runf (op =$))
        [("exp_array_agg_pos_others", trans_exp env, exp, res)];
end;
=TEX

\subsection{Aggregates (Positional Array with Just Others)}
Tests for $exp\_array\_agg\_others$.
=SML
local
val exp = EArrayAggOthers {tmark = Value "WEEK", others = {others = EIntReal "42"}};
val res = ñWEEKvRANGE ¸ {42}®;
in
val _ = store_mt_results (mt_runf (op =$))
        [("exp_array_agg_others", trans_exp env, exp, res)];
end;
=TEX

\subsection{Aggregates (Named Array)}
Tests for $trans\_named\_assoc$ and $exp\_array\_agg\_named$.
=SML
local
val exp = EArrayAggNamed
   {tmark = Value "WEEK",
	named_assocs =
      [{comp = EIntReal "42",
            choice =
            [ACAggChoiceRange
                  (DRRange (RRange {hi = EId "THU", lo = EId "MON"})),
               ACAggChoiceSingle (EId "FRI")]},
         {comp = EIntReal "0",
            choice =
            [ACAggChoiceSingle (EId "SAT"), ACAggChoiceSingle (EId "SUN")]}]};
val res = ñ((MON .. THU) À {FRI} ¸ {42}) À ({SAT,SUN} ¸ {0})®;
in
val _ = store_mt_results (mt_runf (op =$))
        [("exp_array_agg_named1", trans_exp env, exp, res)];
end;
=TEX
=SML
local
val exp = EArrayAggNamed
   {tmark = Value "WEEK",
	named_assocs =
      [{comp = EIntReal "42",
            choice =
            [ACAggChoiceRange
                  (DRRange (RRange {hi = EId "THU", lo = EId "MON"})),
               ACAggChoiceSingle (EId "FRI")]},
         {comp = EIntReal "0",
            choice =
            [ACAggChoiceSingle (EId "SAT"), ACAggChoiceSingle (EId "SUN")]}]};
val res = ñ((MON .. THU) À {FRI} ¸ {42}) À ({SAT,SUN} ¸ {0})®;
in
val _ = store_mt_results (mt_runf (op =$))
        [("exp_array_agg_named2", trans_exp env, exp, res)];
end;
=TEX
cn_exp_of_string "FLAGS'(DAY range MON .. FRI =>TRUE, WEEKDAY => FALSE)";

\subsection{Aggregates (Named Array with Others)}
Tests for $exp\_array\_agg\_named\_others$.
=SML
local
val exp = EArrayAggNamedOthers
   {others = {others = EIntReal "0"},
      agg_named =
      {tmark = Value "WEEK",
	named_assocs =
         [{comp = EIntReal "42",
               choice =
               [ACAggChoiceRange
                     (DRRange (RRange {hi = EId "FRI", lo = EId "MON"}))]}]}};
val res = ñ(WEEKvRANGE ¸ {0}) « (MON..FRI ¸ {42})®;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_array_agg_named_others", trans_exp env, exp, res)];
end;
=TEX

\subsection{Aggregates (Positional Record)}
Tests for $retrieve\_record\_components$ and $exp\_rec\_agg\_pos\_z$.
=SML
local
val exp = ERecAggPos
   {comps = [EIntReal "2", EIntReal "8", EIntReal "1994"], tmark = Value "DATE"};
val res = ñ(DAY ¦ 2, MONTH ¦ 8, YEAR ¦ 1994 )®;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_rec_agg_pos_z", trans_exp env, exp, res)];
end;
=TEX

\subsection{Aggregates (Named Record)}
Tests for $exp\_rec\_agg\_named$.
=SML
local
val exp = ERecAggNamed
   {tmark = Value "DATE", named_assocs =
      [{comp = EIntReal "3", choice = [ACAggChoiceSingle (EId "DAY")]},
         {comp = EIntReal "8", choice = [ACAggChoiceSingle (EId "MONTH")]},
         {comp = EIntReal "1994", choice = [ACAggChoiceSingle (EId "YEAR")]}]};
val res = ñ(DAY ¦ 3, MONTH ¦ 8, YEAR ¦ 1994)®;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_rec_agg_named", trans_exp env, exp, res)];
end;
=TEX

\subsection{Unary Expressions}
Tests for $trans\_unary\_op$ and $exp\_unary\_exp$.
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_unary_exp.1", exptest, "42", ñ42®),
    ("exp_unary_exp.2", exptest, "+42", ñ42®),
    ("exp_unary_exp.3", exptest, "-42", ñ~42®),
    ("exp_unary_exp.4", exptest, "not 42", ñnot 42®),
    ("exp_unary_exp.5", exptest, "abs 0", ñabs 0®),
    ("exp_unary_exp.6", exptest, "not flags1", ñarray_not (FLAGS1º(ú ß ú))®)];
=TEX
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_unary_exp.7", exptest, "42.0", ñ42.0®),
    ("exp_unary_exp.8", exptest, "+42.0", ñ42.0®),
    ("exp_unary_exp.9", exptest, "-42.0", ñ~‰R(42.0)®),
    ("exp_unary_exp.10", exptest, "abs W", ñabs‰R W®)];
=TEX

\subsection{Binary Expressions}
Tests for $trans\_bin\_op$ and $exp\_bin\_exp$.
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_binary_exp.1", exptest, "a and b", ñA and B®),
    ("exp_binary_exp.2", exptest, "a or b", ñA or B®),
    ("exp_binary_exp.3", exptest, "a xor b", ñA xor B®),
    ("exp_binary_exp.7", exptest, "a = b", ñ(Aºú) eq B®),
    ("exp_binary_exp.8", exptest, "a /= b", ñ(Aºú) noteq B®),
    ("exp_binary_exp.9", exptest, "a < b", ñA less B®),
    ("exp_binary_exp.10", exptest, "a > b", ñA greater B®),
    ("exp_binary_exp.11", exptest, "a >= b", ñA greater_eq B®),
    ("exp_binary_exp.12", exptest, "a + b", ñA + B®),
    ("exp_binary_exp.13", exptest, "a - b", ñA - B®),
    ("exp_binary_exp.14", exptest, "a * b", ñA * B®),
    ("exp_binary_exp.15", exptest, "a / b", ñA intdiv B®),
    ("exp_binary_exp.16", exptest, "a mod b", ñA intmod B®),
    ("exp_binary_exp.17", exptest, "flags1 and flags2", ñ(FLAGS1º(ú ß ú)) array_and FLAGS2®),
    ("exp_binary_exp.18", exptest, "flags1 or flags2", ñ(FLAGS1º(ú ß ú)) array_or FLAGS2®),
    ("exp_binary_exp.19", exptest, "flags1 xor flags2", ñ(FLAGS1º(ú ß ú)) array_xor FLAGS2®),
    ("exp_binary_exp.20", exptest, "flags1 > flags2", ñ(FLAGS1º(ú ß ú)) array_greater FLAGS2®),
    ("exp_binary_exp.21", exptest, "flags1 < flags2", ñ(FLAGS1º(ú ß ú)) array_less FLAGS2®),
    ("exp_binary_exp.22", exptest, "flags1 >= flags2", ñ(FLAGS1º(ú ß ú)) array_greater_eq FLAGS2®),
    ("exp_binary_exp.23", exptest, "flags1 <= flags2", ñ(FLAGS1º(ú ß ú)) array_less_eq FLAGS2®)];
=TEX
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_binary_exp.30", exptest, "v + w", ñV +‰R W®),
    ("exp_binary_exp.31", exptest, "v - w", ñV -‰R W®),
    ("exp_binary_exp.32", exptest, "v * w", ñV *‰R W®),
    ("exp_binary_exp.33", exptest, "v ** a", ñV ^‰Z A®),
    ("exp_binary_exp.34", exptest, "v < w", ñV real_less W®),
    ("exp_binary_exp.35", exptest, "v > w", ñV real_greater W®),
    ("exp_binary_exp.36", exptest, "v <= w", ñV real_less_eq W®),
    ("exp_binary_exp.37", exptest, "v >= w", ñV real_greater_eq W®)];
=TEX
\subsection{Membership of a Range}
Tests for $exp\_mem\_range$.

1) range with explicit integer-valued lower and upper bounds:

=SML
local
val arg = "PAY_DAY not in SAT .. SUN";
val res = ñPAY_DAY notmem SAT .. SUN®;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_mem_range.1", exptest, arg, res)];
end;
=TEX
2) range given as a subtype indication:
=SML
local
val arg = "PAY_DAY in DAY";
val res = ñPAY_DAY mem DAY®;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_mem_range.2", exptest, arg, res)];
end;
=TEX
=TEX
3) range given with explicit real-valued lower and upper bounds:
=SML
local
val arg = "1.0 in -2.0 .. +2.0";
val res = ñ1.0 mem ~‰R 2.0 ..‰R 2.0®;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_mem_range.3", exptest, arg, res)];
end;
=TEX
4) See next section for membership of range given as a range attribute.
\subsection{Attributes}
Tests for $exp\_attrib$.

1) Category A: Z definition generated at point of introducing type;
prefix given as a type mark:

=SML
local
val arg = "DAY'FIRST";
val res = ñDAYvFIRST®;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_attrib.1", exptest, arg, res)];
end;
=TEX

2) Category A: Z definition generated at point of introducing type;
prefix given as a variable name:

=SML
local
val arg = "obj'FIRST";
val res = ñARR2vFIRST®;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_attrib.2", exptest, arg, res)];
end;
=TEX

3) Category A: range attribute used as a range:
=SML
local
val arg = "MON in WEEK'RANGE";
val res = ñMON mem WEEKvRANGE®;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_attrib.3", exptest, arg, res)];
end;
=TEX
4) Category B: Z paragraph generated on first encountering a use
of the attribute:
=SML
local
val arg = "A'SIZE";
val res = mk_z_gvar("AvSIZE", type_ofñ0®, []);
fun has_spec c = (z_get_spec c; true) handle Fail _ => false;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_attrib.4", exptest, arg, res)];
val _ = store_mt_results (mt_run)
    [("exp_attrib.4A", has_spec, res, true)];
end;
=TEX
5) Category A: prefix involving base attribute:
=SML
local
val arg = "DAY'BASE'FIRST";
val res = exptest "DAY'FIRST";
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_attrib.5", exptest, arg, res)];
end;
=TEX
6) Category C: user-defined Z paragraph introducing the Z
translation of the attribute:
¹ZAX
Ü AvADDRESS : ú
°
=SML
local
val arg = "A'ADDRESS";
val res = ñAvADDRESS®;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_attrib.6", exptest, arg, res)];
end;
=TEX
7) Category C: as (6) but with prefix involving base attribute:
¹ZAX
Ü DAYvBASEvSTORAGE_SIZE : ú
°
=SML
local
val arg = "DAY'BASE'STORAGE_SIZE";
val res = ñDAYvBASEvSTORAGE_SIZE®;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_attrib.7", exptest, arg, res)];
end;
=TEX

\subsection{Indexed Components}
Tests for $exp\_indexed\_comp$.
=SML
local
val arg = "THISWEEK(DAY'FIRST)";
val res = "ñTHISWEEK DAYvFIRST®";
in
val _ = store_mt_results (mt_runf (comp_z_exp))
    [("exp_indexed_comp", exptest, arg, res)];
end;
=TEX

\subsection{Selected Components}
Tests for $exp\_selected\_comp$.
=SML
local
val arg = "TODAY.DAY";
val res = "ñTODAY.DAY®";
in
val _ = store_mt_results (mt_runf (op comp_z_exp))
    [("selected_comp", exptest, arg, res)];
end;
=TEX

\subsection{Functions Calls}
Tests for $exp\_fun\_call$.
=SML
local
val arg = "max(1,2)";
val res = ñMAX (1, 2)®;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_fun_call", exptest, arg, res)];
end;
=TEX


\subsection{Qualified Expressions}
Tests for $exp\_qualified$.
=SML
local
val arg = "DAYRANGE'(11)";
val res = ñ11®;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_qualified", exptest, arg, res)];
end;
=TEX

\subsection{Type Conversions}
Tests for $exp\_type\_conv$.
=SML
local
val _ = change_env "DAYRANGE" {tipe = Value (type_ofñú®), canon_name = "DAYRANGE", info = EIEnvOtherType, private = false};
val arg = "DAYRANGE(11)";
val res = ñ11®;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_type_conv.1", exptest, arg, res)];
end;
=TEX
=SML
local
val _ = extend_env "FIX" {tipe = Value (type_ofñFIX®), canon_name = "FIX", info = EIEnvOtherType, private = false};
val arg = "FIX(11)";
val res = ñinteger_to_real 11®;
in
val _ = store_mt_results (mt_runf (op =$))
    [("ep_type_conv.2", exptest, arg, res)];
end;
=TEX
=SML
local
val arg = "DAYRANGE(3.14159)";
val res = ñreal_to_integer (3.14159)®;
in
val _ = store_mt_results (mt_runf (op =$))
    [("exp_type_conv.3", exptest, arg, res)];
end;
=TEX
=SML
local
val arg = "DATE(TODAY)";
in
val _ = store_mt_results mt_run_fail
    [("exp_type_conv.4", exptest, arg, gen_fail_msg "exp_type_conv" 508053 [])];
end;
=TEX

\subsection{Integer Literals}
Tests for $trans\_int$, $exp\_int\_lit$.
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_int_lit.1.1", exptest, "25", ñ25®),
    ("exp_int_lit.1.2", exptest, "15_234", ñ15234®),
    ("exp_int_lit.1.3", exptest, "12E3", ñ12000®),
    ("exp_int_lit.1.4", exptest, "12E+3", ñ12000®),
    ("exp_int_lit.1.5", exptest, "200E+2", ñ20000®),
    ("exp_int_lit.1.6", exptest, "2#101#", ñ5®),
    ("exp_int_lit.1.7", exptest, "2#101#e+2", ñ20®),
    ("exp_int_lit.1.8", exptest, "16#10#", ñ16®),
    ("exp_int_lit.1.9", exptest, "16#Ff#", ñ255®),
    ("exp_int_lit.1.10", exptest, "16#10#e2", ñ4096®),
    ("exp_int_lit.1.11", exptest, "11#A#e1", ñ110®)
];
=TEX
=SML
val _ = store_mt_results mt_run_fail [
    ("exp_int_lit.2.1", exptest, "2#3#",
	gen_fail_msg "trans_int" 508113 ["3", "2"]),
    ("exp_int_lit.2.2", exptest, "11#B#",
	gen_fail_msg "trans_int" 508113 ["B", "11"]),
    ("exp_int_lit.2.3", exptest, "11#B#e-1",
	gen_fail_msg "trans_int" 508110 ["-1"]),
    ("exp_int_lit.2.4", exptest, "17#B#",
	gen_fail_msg "trans_int" 508117 ["17"]),
    ("exp_int_lit.2.5", exptest, "1#0#",
	gen_fail_msg "trans_int" 508117 ["1"]),
    ("exp_int_lit.2.6", exptest, "10000#0#",
	gen_fail_msg "trans_int" 508117 ["10000"])
];
=TEX
\subsection{Real Literals}
Tests for $trans\_real$, $exp\_real\_lit$.
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_real_lit.1", exptest, "25.0", ñ25.0®),
    ("exp_real_lit.2", exptest, "15.234", ñ15.234®),
    ("exp_real_lit.3", exptest, "0.0", ñ0.0®),
    ("exp_real_lit.4", exptest, "1.0", ñ1.0®),
    ("exp_real_lit.5", exptest, "2.71828E+0", ñ2.71828®),
    ("exp_real_lit.6", exptest, "1.1e-6", ñ1.1e~6®),
    ("exp_real_lit.7", exptest, "100.0e200", ñ100.0e200®),
    ("exp_real_lit.8", exptest, "100.0e+200", ñ100.0e200®),
    ("exp_real_lit.9", exptest, "100.0e-200", ñ100.0e~200®),
    ("exp_real_lit.10", exptest, "2.718_28E+0", ñ2.71828®),
    ("exp_real_lit.11", exptest, "1_000_000.0E-6", ñ1000000.0e~6®)];
=TEX
\subsection{Character Literals}
Tests for $exp\_char\_lit$.
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_char_lit.1", exptest, "'a'", ñchar_lit "a"®),
    ("exp_char_lit.2", exptest, "'''", ñchar_lit "'"®)];
=TEX
\subsection{String Literals}
Tests for $exp\_string\_lit$.

We have to define a modified version of {\it exptest} to test string literals.

=SML
fun classify_label (itemlist : CN_LEX_ITEM list) : CN_LEX_ITEM list =
  (case itemlist
    of (LCLBracket, _)::(LCNumericLiteral, CNText ntxt)::(LCRBracket, _)::rest =>
      (
        (
          (case nat_of_string ntxt
            of 1 => LCCompLabel
             | 2 => LCPPartLabel
             | 3 => LCVPartLabel
             | 4 => LCDecLabel
             | 5 => LCStmtLabel
             | 6 => LCSpecLabel
             | _ => LCCompLabel
          ),
          CNText ("("^ntxt^")")
        )::rest
      )
     |_ => itemlist
  );
fun cn_exp_of_string_lit (s : string) = (
let	val prefix = "(6) Ã a:= ";
	val epilogue = ";";
 	val inp = [Lex.Text prefix, Lex.String s, Lex.Text epilogue];
	val exp =  (CNParser.cn_parser o fst o (CNLex.cn_lex classify_label)) inp;
in
 	case exp of
	WCRefinedBy{statement=STAssign{e,...},...} => e
	|_ => fail "cn_exp_of_string" 508001 []
end
);
val Ûstring_lit_testÝ = (trans_exp env) o (adjust_exp env) o cn_exp_of_string_lit;
=SML
val _ = store_mt_results (mt_runf (op =$)) [
    ("exp_string_lit.1", string_lit_test, "Hello World!", ñstring_lit "Hello World!"®),
    ("exp_string_lit.2", string_lit_test, "", ñstring_lit ""®)];
=TEX

\subsection{Auxiliary Expressions}
Tests for $exp\_auxiliary\_exp$.  Auxiliary expression are not yet supported
by the parser.

\subsection{The Function $trans\_exp$}\label{transexp}
Tests for $trans\_exp$, $trans\_exp1$.  This function is exercised by the tests above.  Theres just one more test to be done, for brackets.
=SML
local
val arg = "(42 + 13) * (17 + 19)";
val res = ñ(42 + 13) * (17 + 19)®;
in
val _ = store_mt_results (mt_runf (op =$))
    [("brackets.1", exptest, arg, res)];
end;
=TEX

\section{TESTS FOR BASIC DECLARATIONS}
=SML
fun ÛbdtestÝ (tm : TERM) : bool = ( case frees tm of [] => true |_ => false);
=TEX

\subsection{Constants}
Tests for $basic\_decl\_const$.
=SML
store_mt_results (mt_runf (op =))
    [	("constant.1", bdtest, ñPAY_DAY = FRI®, true),
	("constant.2", bdtest, ñCA = {}®, true)];
=TEX
=SML
cn_declare ["PAY_ROLL"] "PAY_DAY : constant DAY := FRI;";
store_mt_results (mt_runf (op =))
    [	("constant_3", bdtest, ñPAY_ROLLoPAY_DAY = FRI®, true)];
=TEX
\subsection{Enumeration Types}
Tests for $basic\_decl\_enum$.
=SML
store_mt_results (mt_runf (op =))
    [("enumeration.1", bdtest, ñ{MON, TUE, WED, THU, FRI, SAT, SUN} € DAY®,
       true)];
=TEX
=SML
cn_declare ["TYPES"] "type BIT is (TT, FF);";
store_mt_results (mt_runf (op =))
    [	("enumeration.2", bdtest, ñ{TYPESoTT, TYPESoFF} € TYPESoBIT®, true)];
=TEX
\subsection{Array Types}
Tests for $basic\_decl\_con\_array$ and $basic\_decl\_uncon\_array$.
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("array.1", bdtest, ñ{day : WEEK | SUN = day(1)}®, true),
    ("array.2", bdtest, ñ{day : WEEKUNCON | SUN = day(1)}®, true),
    ("array.3", bdtest, ñ{day : ARR2 | SUN = day(1, 2)}®, true),
    ("array.4", bdtest, ñ{day : UNCON2 | SUN = day(1, 2)}®, true)];
=TEX

\subsection{Record Types}
Tests for $trans\_decl$, $basic\_decl\_record$.
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("record", bdtest, ñÍ DATE | DAY=6 ± MONTH=8 · INTEGER®, true)];
=TEX

\subsection{Integer Types}
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("integer.1", bdtest, ñHOURS   0 .. 23®, true),
    ("integer.2", bdtest, ñHOURSvFIRST < HOURSvLAST®, true),
    ("integer.3", bdtest, ñHOURSvSUCC À HOURSvPRED   ú ¸ ú®, true),
    ("integer.4", bdtest, ñHOURSvPOS À HOURSvVAL   ú ¸ ú®, true)
];
=TEX
\subsection{Real Types}
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("real.1", bdtest, ñFIX  ð FIX®, true),
    ("real.2", bdtest, ñFLOAT1  ð FLOAT1®, true)
];
=TEX

\subsection{Subtypes}
Tests for $basic\_decl\_subtype\_range\_con$ etc..
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("subtype.1", bdtest, ñMON  WEEKDAY®, true),
    ("subtype.2", bdtest, ñSUN Ž {WEEKDAYvFIRST, WEEKDAYvLAST}®, true),
    ("subtype.3", bdtest, ñWEEKDAYvSUCC À WEEKDAYvPRED € ú ¸ ú®, true),
    ("subtype.4", bdtest, ñWEEKDAYvPOS À WEEKDAYvVAL € ú ¸ ú®, true)
];
=TEX
=SML
val _ = store_mt_results (mt_runf (op =)) [
    ("subtype.5", bdtest, ñSUBFIX1 ½ FIX®, true),
    ("subtype.6", bdtest, ñ8  SUB1®, true),
    ("subtype.7", bdtest, ñSUBFLOAT € FLOAT1®, true),
    ("subtype.9", bdtest, ñSUBFIX2 € FIX®, true),
    ("subtype.10", bdtest, ñSUB2 € UNCON2®, true),
    ("subtype.11", bdtest, ñWEEKDAYUNCON € WEEKUNCON®, true),
    ("subtype.12", bdtest, ñSUB3 = SUB2®, true),
    ("subtype.13", bdtest, ñALLINTEGERSvFIRST ½ ALLINTEGERSvLAST®, true),
    ("subtype.14", bdtest, ñINWEEKvFIRST ½ INWEEKvLAST®, true)
];
=TEX
=SML
cn_declare ["CALENDAR"] "subtype INWEEK is WEEK;";
val _ = store_mt_results (mt_runf (op =)) [
    ("subtype.15", bdtest, ñCALENDARoINWEEK = WEEK®, true)
];
=TEX
\subsection{The Function $trans\_basic\_decl$}
Tests for $trans\_basic\_decl$, $trans\_basic\_decl1$.  These have been exercised by the above tests.

\section{ADJUSTMENT OF ABSTRACT SYNTAX FOR EXPRESSIONS}
Tests for $named\_assocs\_to\_exps$, $adjust\_exp$, $adjust\_exp1$.  These have been exercised by the above tests.

=TEX
\section{SUMMARY OF RESULTS}

=SML
diag_line(summarize_mt_results());
=TEX

\end{document}
