%  mdt508.doc  %Z% $Date$ $Revision$ $RCSfile$
=TEX
% TQtemplate.tex
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Module Tests for Basic Declarations and Expressions}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/MDT508}  %% Mandatory field
\def\SCCSversion{$Revision$
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$
}}  %% Mandatory field (with sensible default)
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{HOL}
\TPPauthor{D.J.~King & WIN01}  %% Mandatory field
%\TPPauthors{D.J.~King & WIN01\\A.C.~Hayward & WIN01}
\TPPauthorisation{R.D.~Arthan &}
\TPPabstract{
This document comprises test cases and test code/data for
testing the DAZ parser as described in the document
ISS/HAT/DAZ/DTD508.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
      Library \\ A.C. Hayward\\ D.J. King}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\pagebreak
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1]
First draft.

\end{description}
\subsection{Changes Forecast}
As the DAZ Compliance Notation Parser is extended, so will this document.
\pagebreak
\section{GENERAL}
\subsection{Scope}

This document comprises test cases and test code/data for
testing the DAZ Compliance Notation Parser specified in \cite{ISS/HAT/DAZ/DTD508}, and for the DAZ SPARK Output Function as specified in \cite{ISS/HAT/DAZ/DTD510}.

\subsection{Introduction}

\subsubsection{Background and Purpose}
This document is intended to supply module tests for the DAZ Compliance Notation Parser as defined in \cite{ISS/HAT/DAZ/DTD508} and implemented in \cite{ISS/HAT/DAZ/IMP508}, and for the DAZ SPARK Output Function as defined in \cite{ISS/HAT/DAZ/DTD510} and implemented in \cite{ISS/HAT/DAZ/IMP510}. The tests are intended to meet the requirements for tests identified in the quality plan \cite{ISS/HAT/DAZ/PLN003}.

\subsubsection{Dependencies}

These tests depend on the test harness as implemented in DS/FMU/IED/IMP013, and its corresponding detailed design document, DS/FMU/IED/DTD013.

\subsubsection{Possible Enhancements}

None known.

\subsubsection{Deficiencies}

There are no known deficiencies.

\section{TEST CASES}

\section{PREAMBLE}
Set up the theory database as necessary.

=SML
use_file "dtd013";
use_file "imp013";
	open CNTypes CNBasicDeclsAndExprs (* ZProofMode*);
=TEX

=SML
open_theory "daz_toolkit_extensions";
force_delete_theory "mdt508_test" handle (_) => ();
new_theory "mdt508_test";
=TEX


\section{INITIALISATION}
First we need to initialise the test results routine.

=SML

init_mt_results();

=TEX
=SML
fun €bdtest› (tm : TERM) : bool = (
	case frees tm of
	[] => true
	|_ => false
);
=TEX
=TEX
\subsection{Translating Enumeration Types}
=SML
val bd1 = cn_declare "type DAY is (MON, TUE, WED, THU, FRI, SAT, SUN);";
store_mt_results (mt_runf (op =)) [
("bd1", bdtest, Ò{MON, TUE, WED, THU, FRI, SAT, SUN} Ä DAYÆ, true)];
=TEX
\subsection{Translating Constants}
=SML
val bd2 = cn_declare "PAY_DAY : constant WEEKDAY := FRI;";
store_mt_results (mt_runf (op =)) [
("bd2", bdtest, ÒPAY_DAY = FRIÆ, true)];
=TEX
\subsection{Translating Array Types}
=SML
val bd3 = cn_declare "type ARR is array (DAY) of DAY;";
val bd4 = cn_declare "type UNCON is array (DAY range <>) of DAY;";
store_mt_results (mt_runf (op =)) [
("bd3", bdtest, Ò{day : ARR | SUN = day(1)}Æ, true),
("bd4", bdtest, Ò{day : UNCON | SUN = day(1)}Æ, true)];
=TEX
\subsection{Translating Record Types}
=SML
val bd5 = cn_declare "type REC is record START : DAY; FINISH : DAY; YESTERDAY : ARR; end record;";
change_env "REC" EIEnvRecord;

store_mt_results (mt_runf (op =)) [
("bd5", bdtest, ÒÕ REC | START=FINISH=FRI ∑ YESTERDAYÆ, true)];
=TEX
\subsection{Translating Subtypes}
=SML
val bd6 = cn_declare "subtype WEEKDAY is DAY range MON..FRI;";
val bd7 = cn_declare "subtype SUB is UNCON(WEEKDAY);";
store_mt_results (mt_runf (op =)) [
("bd6", bdtest, ÒMON ç WEEKDAYÆ, true),
("bd7", bdtest, ÒSUN ç {MON,TUE, WED, THU, FRI}Æ, true)];
=TEX
\subsection{Translating Integer Types}
=SML
val bd8 = cn_declare "type HOURS is range 0..23;";
store_mt_results (mt_runf (op =)) [
("bd8", bdtest, ÒHOURS † 0 .. 23Æ, true)];
=TEX

\section{EXPRESSIONS}
=SML
fun €cn_exp_of_string› (s : string) : EXP = (
let	val prefix = "√ a:= ";
	val epilogue = ";";
	val result = cn_of_string (prefix^s^";");
in
	case result of
	WCRefinedBy{statement=SStmt(STAssign{e,...}),...} => e
	|_ => fail "cn_exp_of_string" 508001 []
end);
=TEX

=SML
val €etest› = (trans_exp env) o (adjust_exp env) o cn_exp_of_string;
=TEX


=SML
cn_declare "tomorrow : arr;";
cn_declare "rec2 : rec;";
cn_declare "a, b : hours;";
cn_declare "FUNCTION max (d1, d2 : DAY) return DAY;";
=TEX

=TEX
\subsection{Identifiers}
=SML
store_mt_results (mt_runf (op =$)) [
("id1", etest, "a", ÒA∫˙Æ),
("id2", etest, "A", ÒA∫˙Æ),
("id3", etest, "DAY", ÒDAY∫  SETÆ)
];
=TEX

\subsection{Aggregates (Positional Array)}
=SML
val arg = "ARR'(TUE,WED,THU,FRI,SAT,SUN,MON)";
val res = Òsucc Á 1 - ARRvFIRST Í ª ßTUE,WED,THU,FRI,SAT,SUN,MON¢Æ;
store_mt_results (mt_runf (op =$)) [
("arraggpos", etest, arg, res)
];
=TEX

\subsection{Aggregates (Positional Array with Others)}

etest "ARR'(THU,WED,SUN, others=> SAT)";
=SML
val arg = "ARR'(THU,WED,SUN, others=> SAT)";
val res = Ò(ARRvRANGE ∏ {SAT}) ´ (succ Á 1 - ARRvFIRST Í ª ßTHU, WED, SUN¢)Æ;
store_mt_results (mt_runf (op =$)) [
("arraggposoth", etest, arg, res)
];
=TEX
\subsection{Aggregates (Positional Array with Just Others)}
=SML
val arg = "ARR'(others=>WED)";
val res = ÒARRvRANGE ∏ {WED}Æ;
store_mt_results (mt_runf (op =$)) [
("arraggoth", etest, arg, res)
];
=TEX

\subsection{Aggregates (Named Array)}
=SML
val arg="ARR'(MON..THU | FRI => WED, SAT | SUN => TUE)";
val res = Ò((MON .. THU) ¿ {FRI} ∏ {WED}) ¿ ({SAT,SUN} ∏ {TUE})Æ;
store_mt_results (mt_runf (op =$)) [
("arraggnamed", etest, arg, res)
];
=TEX
\subsection{Aggregates (Named Array with Others)}
=SML
val arg="ARR'(MON..FRI => WED, others => TUE)";
val res = Ò(ARRvRANGE ∏ {TUE}) ´ (MON..FRI ∏ {WED})Æ;
store_mt_results (mt_runf (op =$)) [
("arraggnamedothers", etest, arg, res)
];
=TEX

\subsection{Aggregates (Positional Record)}
=SML
val arg="REC'(WED,SUN,ARR'(others => THU))";
val res = ÒÕ REC |
	FINISH = WED ± START = SUN ± YESTERDAY = ARRvRANGE ∏ {THU} ∑  RECÆ;
store_mt_results (mt_runf (op =$)) [
("recaggpos", etest, arg, res)
];
=TEX

\subsection{Aggregates (Named Record)}
=SML
val arg="REC'(START => THU, FINISH => FRI, YESTERDAY => ARR'(others => SUN))";
val res = ÒÕ REC |
	START = THU ± FINISH = FRI ± YESTERDAY = ARRvRANGE ∏ {SUN} ∑  RECÆ;
store_mt_results (mt_runf (op =$)) [
("recaggnamed", etest, arg, res)
];
=TEX


\subsection{Unary Expressions}
=SML
store_mt_results (mt_runf (op =$)) [
("unary1", etest, "3", Ò3Æ),
("unary2", etest, "+3", Ò3Æ),
("unary3", etest, "-3", Ò~3Æ),
("unary4", etest, "not a", Ònot AÆ),
("unary5", etest, "abs 0", ÒAbs 0Æ)
];
=TEX
\subsection{Binary Expressions}
=SML
store_mt_results (mt_runf (op =$)) [
("binop1", etest, "a and b", ÒA and BÆ),
("binop2", etest, "a or b", ÒA or BÆ),
("binop3", etest, "a xor b", ÒA xor BÆ),
("binop7", etest, "a = b", Ò(A∫˙) eq BÆ),
("binop8", etest, "a /= b", Ò(A∫˙) noteq BÆ),
("binop9", etest, "a < b", ÒA less BÆ),
("binop10", etest, "a > b", ÒA greater BÆ),
("binop11", etest, "a >= b", ÒA greater_eq BÆ),
("binop12", etest, "a + b", ÒA + BÆ),
("binop13", etest, "a - b", ÒA - BÆ),
("binop14", etest, "a * b", ÒA * BÆ),
("binop15", etest, "a / b", ÒA intdiv BÆ),
("binop16", etest, "a mod b", ÒA mod BÆ)
];
=TEX

\subsection{Membership of a Range}
=SML
store_mt_results (mt_runf (op =$)) [
("memop", etest, "PAY_DAY not in SAT .. SUN", ÒPAY_DAY notmem SAT .. SUNÆ)
];
=TEX

\subsection{Attributes}
=SML
store_mt_results (mt_runf (op =$)) [
("attrib", etest, "WEEKDAY'FIRST", ÒWEEKDAYvFIRSTÆ)
];
=TEX

\subsection{Indexed Components}
=SML
store_mt_results (mt_runf (op =$)) [
("indexed_comp", etest, "TOMORROW(DAY'FIRST)", ÒTOMORROW(DAYvFIRST)∫˙Æ)
];
=TEX

\subsection{Selected Components}
=SML

store_mt_results (mt_runf (op =$)) [
("selected_comp", etest, "REC2.FINISH", Ò(REC2∫REC).FINISHÆ)
];
=TEX

\subsection{Functions Calls}
=SML
store_mt_results (mt_runf (op =$)) [
("fun_call", etest, "MAX(WED, DAY'LAST)", ÒMAX(WED,DAYvLAST)Æ)
];
=TEX

\subsection{Integer Literals}
=SML
store_mt_results (mt_runf (op =$)) [
("intlit1", etest, "25", Ò25Æ),
("intlit2", etest, "15_234", Ò15234Æ),
("intlit3", etest, "12E3", Ò12000Æ),
("intlit4", etest, "12E+3", Ò12000Æ),
("intlit5", etest, "200E-2", Ò2Æ),
("intlit6", etest, "2#101#", Ò5Æ),
("intlit7", etest, "2#101#e+2", Ò20Æ)
];
=TEX
\subsection{Auxiliary Expressions}

\section{SUMMARY OF RESULTS}

=SML
diag_line(summarize_mt_results());
=TEX

\end{document}



