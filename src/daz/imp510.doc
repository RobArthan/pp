% $Header: /home/rda/daz/RCS/imp510.doc,v 1.99 2002/05/02 16:29:28 rda Exp rda $
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: SPARK Output Function}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP510}  %% Mandatory field
\def\SCCSversion{$Revision: 1.99 $%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date: 2002/05/02 16:29:28 $%
}}
\TPPstatus{Draft}	    %% Mandatory field
\TPPtype{Specification}
\TPPkeywords{CN}
\TPPauthor{A.C.~Hayward & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the SPARK output function.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
    Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issues 1.1-1.18]
Initial Drafts.
\item[Issue 1.19]
Added calls to CaseIndependence.get\_external\_name.
\item[Issue 1.20]
Updated in line with changes to SPEC.
\item[Issue 1.21]
Removed output\_spark\_program1 and changed interface to output\_spark\_program.
\item[Issue 1.22]
Added support for auxiliary variables.
\item[Issue 1.23]
Fixed bugs in function/procedure declaration handling and corrected aux vars.
\item[Issue 1.24]
Removed variant records from the implementation.
\item[Issue 1.25]
Added newlines afte compilation units.
\item[Issue 1.26]
Fixed problem with outputting the letter Q to a file.
\item[Issue 1.27]
Fixed to use get\_cn\_state rather than !spark\_prog.
\item[Issue 1.28]
Changed SUBUNIT to COMP\_SUBUNIT.
\item[Issue 1.29]
Adjusted for new AS constructor.
\item[Issue 1.30]
Rationalised the structure wrapping.
\item[Issue 1.31]
Replacement env now distinguishes refinements from replacements.
\item[Issue 1.32]
Fixed a problem with printing labels (now need to add brackets).
\item[Issue 1.33]
Added kslot brackets.
\item[Issue 1.34]
Added first cut of calls to the soundness checking algorithm .
\item[Issue 1.35-1.39]
Minor corrections.
\item[Issue 1.40]
Renamed call of $get\_cn\_state$ to be $get\_z\_generator\_state$.
\item[Issue 1.41]
Fixed DRA bug 3 (batch 1)
\item[Issue 1.42]
Fixed DRA bug 20 (batch 2)
\item[Issue 1.43]
Fixed DRA bug 5 (batch 2)
\item[Issues 1.44,1.45]
Added annotations and pragmas.
\item[Issues 1.46]
Fixed bug in printing of unreplaced compilation unit k-slot.
\item[Issue 1.47] Enhancement 3.
\item[Issue 1.48] Added name-clash checking (which fixes bug 15 inter alia).
\item[Issue 1.49] Fixed DRA bugs 14 and issue 2 (V0.6).
\item[Issue 1.50] Fixed DRA bug 11 (V0.6).
\item[Issue 1.51,1.52] Fixing DRA bug 3 (V0.6).
\item[Issue 1.53] Made it handle membership of a range properly and tidied error-reporting.
\item[Issue 1.54] Fixed named aggregates with others-part and pragmas without arguments.
\item[Issue 1.55-1.56] Syntax changes.
\item[Issue 1.58 - 1.63] Major rewrite as called for as WP 6 of \cite{ISS/HAT/DAZ/HLD505}.
\item[Issue 1.64] Made file reloadable, by gracefully accepting pre-existence
of integer control.
\item[Issue 1.65] Corrected checking of variable redeclaration rules in subprogram specifications. (bug 6 (v0.7.1)).
\item[Issue 1.66] Fixing $strings\_from\_fmt$.
\item[Issue 1.67] IUCT WP 3 changes.
\item[Issue 1.69] Improved use of $cn\_automatic\_line\_splitting$, corrected variable initialisation output.
\item[Issue 1.69] IUCT WP 4 changes.
\item[Issue 1.70] IUCT WP 4 fix --- package names mustn't be overloaded for the changes to be robust.
\item[Issue 1.71] Updated references.

\item[Issue 1.72]  Added conditional compilation for {\bf FULLVERSION} and {\bf CUTDOWNVERSION}
                   Removed CNVCGenerator from open list and added dummy $do\_soundness\_checks2$ for 
                   cut-down version.
		   Changes to allow compilation with hol.db base.
\item[Issue 1.73] Changes to allow compilation with poly.db.
\item[Issue 1.74] Added control over case of keywords.
\item[Issue 1.75] Fixed bug in printing of ELSIF.
\item[Issue 1.76] Enhancement R5 --- Initial Variables in Conditionals.
Also fixed bug in printing of keyword ``CONSTANT''.
\item[Issue 1.77] Enhancement R2 --- Multiple Logical Constant Statements.
\item[Issue 1.78-1.80] Fixed bugs in treatment of case
for keyword ``CONSTANT'', attribute designators and pragmas.
\item[Issue 1.81] CTLE II R1/10 --- multiple with clauses.
\item[Issue 1.82] CTLE II R2/1: global variable unsoundness.
\item[Issues 1.83,1.84] CTLE II R1/1: real types.
\item[Issues 1.85] Adjustment to formatting of {\it Z\_TM}s to support
pretty-printing of Web clauses containing nested quotations
in a format that can more often be re-entered.
\item[Issue 1.86] R0037: support for named numbers.
\item[Issue 1.87] R0043: problem with long lines when the frames of specification statements are printed.
\item[Issue 1.88] Problem with lower case `o' in attribute names.
\item[Issue 1.89, 1.90] R0006: mods to allow for extended use of subtype indications
and ranges; also involved a fairly extensive overhaul to remove the enormous
mutual recursions.
\item[Issue 1.91] R0056: default parameter modes supported properly.
\item[Issue 1.92] Fixed bugs in output of loop statements; tidied various statement forms
which were producing newlines inconsistently.
\item[Issue 1.93] Improved commentary for unexpanded labels; moved {\it
translate\_for\_output} calls to the points where Z-like fragments are being
processed so that per-cent signs in strings etc. will work properly.
\item[Issue 1.92] Soundness check failures now reported after the
program has been printed.
\item[Issue 1.93] Added missing {\it translate\_for\_output} call for identifiers.
\item[Issue 1.94] Added further missing {\it translate\_for\_output} calls.
\item[Issue 1.95] Removed {\it translate\_for\_output} calls that are now
made during lexical analysis (annotations and arbitrary Ada). Added calls
that were missing for refinement and replacement symbols. Also completed R0061:
new symbol for statement replacement.
\item[Issue 1.96-1.98] Various fixes plus R0061: new syntax for statement replacement.
\item [Issue 1.99] First go at new syntax for interim Spring 2002 release.
\item [Issue 1.100] More new syntax plus R0063: unexpanded specification statements
are now handled by printing a comment and then the specification statement.

\end{description}

\subsection{Changes Forecast}
None.
\pagebreak

\section{GENERAL}
\subsection{Scope}

This document contains the implementation for the Compliance Notation Output functions.  The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD510} and the module tests are in \cite{ISS/HAT/DAZ/MDT503}.

\subsection{Introduction}

\subsection{Purpose and Background}

One signature is implemented in this document, $CNSparkOutput$.  The functions in this signature are not intended to be called directly by the user.  Instead \cite{ISS/HAT/DAZ/DTD516} details some top-level functions which use this signature.

\subsection{Dependencies}

The functions in this signature depend on the data types introduced in the structures $CNTypes$, $CNTypes1$, $CNVCGenerator$, $CNZGenerator$ and $ZUserInterfaceSupport$ which are defined in \cite{ISS/HAT/DAZ/DTD513}, \cite{ISS/HAT/DAZ/DTD514}, \cite{ISS/HAT/DAZ/DTD505}, \cite{ISS/HAT/DAZ/DTD507} and \cite{DS/FMU/IED/DTD079}.

\section{THE STRUCTURE $CNSparkOutput$}

=SML
structure €CNSparkOutput› : CNSparkOutput = struct
=SML
    open    CNTypes CNTypes1 CNZGenerator;
=TEX

\subsection{Version Differences}
=FULLVERSION
    open    ZUserInterfaceSupport;
    open    CNVCGenerator;
=TEX

=CUTDOWNVERSION
    fun do_soundness_checks2 a b c = ();
=TEX

\subsection{Checking for Name Clashes}
This module is responsible for implementing the SPARK rules against redeclaration of identifiers as required in \cite{DRA/CIS/CSE3/TR/94/27/3.0}, volume 1.
Some checking is done as web clauses are entered, but only when the program is output is all the information needed to make a comprehensive check available.
The following ML data structures and access functions are used to record information about declarations as they are encounetered.

The bool flag is only set true in the call from the functions which print or output the entire SPARK program.
The flag is used to ensure that diagnostic routines etc. using the lower-level formatting routines directly will not indefinitely consume resources.
N.b. some functions use the stack variable directly for special effects, so they must do so in a way which won't consume resources if the flag is false.
=SML
val €error_checking› : bool ref = ref false;
type €SCOPE› = {block : ID, names : ID list};
val €stack› : SCOPE list ref = ref [];
fun €push_scope› (block : ID) : unit = (
	if	!error_checking
	then	stack := {block=block, names=[]} :: !stack
	else	()
);
fun €pop_scope› () : unit = (
	if	!error_checking
	then	case !stack of
			[] => ()
		|	_ :: more => (stack := more)
	else	()
);
=TEX
The following data structures and functions are used to accumulate a list of name-clash and other
errors.
=SML
type €CLASH_INFO› = {name1 : ID list, name2 : ID list};
val €clashes› : CLASH_INFO list ref = ref [];
fun €check_decl› (name : ID) : unit = (
if	!error_checking
then	let	fun full_name (st : SCOPE list) (n : ID) : ID list = (
			rev(n :: (map #block st less ""))
		);
		fun scan [] = ()
		|   scan (st as ({block, names} :: more)) = (
			if	name mem names
			then	(clashes := !clashes grab
					{name1 = full_name st name,
					name2 = full_name (!stack) name};
				scan more)
			else	scan more
		);
	in	scan (!stack);
		case !stack of
			[] => (
				stack := [{block="", names =[name]}]
		) |	{block, names} :: more => (
				stack :=
				{block=block,names=names grab name}::more
		)
	end
else	()
);
val €soundness_check_results› : string list ref = ref [];
fun €log_soundness_check_result› (msg : MESSAGE) = (
	if	!error_checking
	then	soundness_check_results :=
		get_message_text msg :: !soundness_check_results
	else	()
);
=TEX
In many cases the following gives a convenient idiom:
=SML
fun €in_new_scope› (check_n : bool) (n : ID) (what : unit -> 'b) : 'b = (
	(if check_n then check_decl n else ());
	push_scope n;
	let	val res = what ();
	in	pop_scope ();
		res
	end
);
=TEX
=SML
fun €with_soundness_checks› (what : unit -> 'a) : 'a = (
	clashes := [];
	soundness_check_results := [];
	stack := [];
	error_checking := true;
	let	fun show_name n = format_list Combinators.I n ".";
		fun report_clash {name1, name2} = (
			diag_line
				(get_error_message 510002
					[show_name name1, show_name name2])
		);
		fun report_clashes cls = (
			case cls of
			[]	=> ()
		|	_ => (
				diag_line (get_error_message 510001 []);
				map report_clash cls;
				fail "soundness_checks" 510003 []
			)
		);
		fun report_soundness_check_results scrs = (
			case scrs of
			[]	=> ()
		|	_ => (
				map diag_line scrs;
				fail "soundness_checks" 510005 []
			)
		);
		val res = what();
		val cls = !clashes;
		val scrs = !soundness_check_results;
	in	error_checking := false;
		clashes := [];
		soundness_check_results := [];
		stack := [];
		report_soundness_check_results scrs;
		report_clashes cls;
		res
	end
)	handle ex => (
		error_checking := false;
		clashes := [];
		soundness_check_results := [];
		stack := [];
		raise ex
);
=TEX
\subsection{Low level functions}

These functions deal with the low-level output of characters.

=SML

local
	val €PPTabSize› : int ref = ref 2;
in
fun €set_PPTab_size› (x : int) = (PPTabSize := x);
fun €get_PPTab_size› ( () : unit) : int = !PPTabSize;
end;

fun €fmt_spaces› (i : int) : string =
   if i<=0 then "" else " "^fmt_spaces(i-1);
fun €fmt_tabs› (i : int) : string = (
	let	val tab_str = fmt_spaces(get_PPTab_size());
		fun aux (j : int) = if (j <= 0) then "" else tab_str ^ aux (j-1);
	in
		aux i
	end);
=TEX
Now we set up the tab state as some global state:
=SML
local
	val €PPTabNo› : int ref = ref 0;
in
fun €set_PPTab_no› (x : int) = (if (x > 0) 
	then PPTabNo := x 
	else PPTabNo := 0;
	());
fun €reset_PPTab_no› (() :unit) = (PPTabNo := 0;());
fun €get_PPTab_no› ( () : unit) : int = !PPTabNo;
end;
=TEX
In the following type, {\it outf} is the function to output some
formatted text and {\it fmt\_repl} is the optional function that
deals with a label, either by recursively formatting
and printing the replacement for the label or by printing a place-holder.
The optional function returns {\tt true} iff. the label had a replacement.
=SML
type €PP_FMT_INFO› = {
    outf : string -> unit,
    fmt_repl : (LABEL -> bool) OPT
    };
=TEX
=TEX
=SML
fun €set_tabs›(i : int) = set_PPTab_no(i);
fun €get_tabs›() = get_PPTab_no();

fun €inc_tabs› (() :unit) =
    (set_PPTab_no(get_PPTab_no() + 1));
fun €dec_tabs› (() :unit) =
    (set_PPTab_no(get_PPTab_no() - 1));
fun €reset_tabs› (() :unit) =
    (reset_PPTab_no());
fun €len_tab› (():unit) : int = (get_PPTab_no() * get_PPTab_size());
=TEX
\subsection{The String from Identifiers}
We need this for both bracket tests and actual output, so
it is given here, in isolation.
=SML
fun €sfmt_id_plus›  ({outf,...} : PP_FMT_INFO) (n : ID) (s : string): string  = (
	let	fun break_up acc (lhs, "o"::rest) = (
			break_up ((implode o rev) lhs::acc) ([], rest)
		) | break_up acc (lhs, (c::rest)) = (
			break_up acc (c::lhs, rest)
		) | break_up acc (lhs, []) = (
			(implode o rev) lhs::acc, ([], [])
		);
		val comps = (	map CaseIndependence.get_external_name o rev
				o fst o (break_up [])) ([], explode n);
		fun fmt_aux (a::b::rest) = (
			a^"."^fmt_aux (b::rest)
		) | fmt_aux (a::rest) = a ^ CaseIndependence.get_external_name s
		| fmt_aux [] = CaseIndependence.get_external_name s;
	in
		fmt_aux comps
	end
);
=TEX
\subsection{Case of Keywords}
=SML
local
fun default () = "upper";
fun €check› ("as input" : string) : bool = true
|   check "lower" = true
|   check "upper" = true
|   check x = (
	fail "check_case_of_spark_keywords" 510004 [fn _ => x]
);
val €case_of_spark_keywords› : string ref = ref (default());
fun aux (dec : string) : unit = new_string_control{
		check = check,
		control = case_of_spark_keywords,
		default = default,
		name = 	"case_of_spark_keywords"^dec} handle Fail _ => aux (dec^"'");
val _ = aux "";
in
=TEX
=SML
	fun €kw› (s : string) : string = (
		translate_for_output
		((case !case_of_spark_keywords of
			"as input" => CaseIndependence.get_external_name
		|	"lower" => CaseIndependence.to_lower
		|	_ => CaseIndependence.to_upper) s)
	);
	fun €kw2› (s1 : string) (s2 : string) : string = (
		kw s1 ^ " " ^ kw s2
	);
	fun €kw3› (s1 : string) (s2 : string) (s3 : string) : string = (
		kw s1 ^ " " ^ kw s2 ^ " " ^ kw s3
	);
end;

=TEX
\subsection{Bracketing}
In a few places it is important not to put extra brackets around a
bracketed construct (e.g., an array index).
We check by having a parallel set of functions for expressions and their fragments
(all prefixed by ``nb''),
which return false if the item is either such that it is not printed
(i.e. its string representation would be empty), or it is already bracketed.
=SML
fun €nb_spaces› (i : int) : bool = if (i > 0) then true else false;
fun €nb_tabs› (i : int) : bool = if (i > 0) then true else false;
fun €nb_z_tm› ({outf,...} : PP_FMT_INFO) (z_tm : Z_TM) : bool = true;

fun €nb_id_plus›  (fmtinfo: PP_FMT_INFO) (n : ID) (s : string): bool = (
	(sfmt_id_plus fmtinfo n s) <> ""
);

fun €nb_id_comma›  (fmtinfo : PP_FMT_INFO) (n : ID) : bool  = true;
fun €nb_id›  (fmtinfo : PP_FMT_INFO) (n : ID) : bool = (nb_id_plus fmtinfo n "");

fun €nb_tmark_plus›  (fmtinfo : PP_FMT_INFO) (t : TMARK) (s : string): bool =
	nb_id_plus fmtinfo t s;
fun €nb_tmark›  (fmtinfo : PP_FMT_INFO) (t : TMARK) : bool = 
	nb_tmark_plus fmtinfo t "";
fun €nb_tmark_comma›  (fmtinfo : PP_FMT_INFO) (t : TMARK) : bool = true;

fun €nb_term›  ({outf,...} : PP_FMT_INFO) (z : TERM) : bool = (
let	val cn_als = get_int_control	"cn_automatic_line_splitting";
	val awidth = if cn_als = 0
		then get_line_length()
		else cn_als;
	val awidth1 = if (awidth - len_tab()) < 0
		then 0
		else awidth - len_tab();
	val strs = map translate_for_output
=FULLVERSION
                   (PrettyPrinter.format_term1 false awidth1 z);
=CUTDOWNVERSION
                  [];
=SML
in
	(length strs > 1 orelse (length strs = 1 andalso (hd strs <> "")))
end);

fun €nb_label› ({outf,...} : PP_FMT_INFO) (label : LABEL) = false;

fun €nb_unary_op› ({outf,...} : PP_FMT_INFO) (_ : UNARY_OP) = true;

fun €nb_binary_op› ({outf,...} : PP_FMT_INFO)(_ : BIN_OP) = true;

fun €nb_mode› ({outf,...} : PP_FMT_INFO)(_ : MODE) = true;
 
fun €nb_loop_direction› ({outf,...} : PP_FMT_INFO) (LDForwards : LOOP_DIRECTION) = false
  | nb_loop_direction ({outf,...} : PP_FMT_INFO)(LDReverse : LOOP_DIRECTION) = true;

fun €nb_operator_symbol› ({outf,...} : PP_FMT_INFO)(s : OPERATOR_SYMBOL) = s <> "";

fun €nb_id_list› (fmtinfo : PP_FMT_INFO)([] : ID list) = false
  | nb_id_list (fmtinfo : PP_FMT_INFO)([x] : ID list) = (nb_id fmtinfo x)
  | nb_id_list (fmtinfo : PP_FMT_INFO)(x::xs: ID list) = true;

fun €nb_tmark_list› (_ : PP_FMT_INFO)([] : TMARK list) = false
  | nb_tmark_list (fmtinfo : PP_FMT_INFO)([x] : TMARK list) = (nb_tmark fmtinfo x)
  | nb_tmark_list (fmtinfo: PP_FMT_INFO)(x::xs : TMARK list) = true;

fun €nb_z_pred› (fmtinfo : PP_FMT_INFO) (z : Z_PRED) = nb_term fmtinfo z;
fun €nb_z_exp› (fmtinfo : PP_FMT_INFO) (z : Z_EXP) =  nb_term fmtinfo z;
fun €nb_z_id› ({outf, ...} : PP_FMT_INFO) (z : Z_ID) = z <> "";
fun €nb_attrib› (fmtinfo : PP_FMT_INFO) (x : ATTRIB) = nb_id fmtinfo x;
fun €nb_int_real_lit› (fmtinfo : PP_FMT_INFO) (x : INT_REAL_LIT) = nb_id fmtinfo x;

fun €nb_rangelohi› (fmtinfo: PP_FMT_INFO) 
	({lo=l, hi=h} : EXP RANGELOHI) = true
and €nb_range› (fmtinfo: PP_FMT_INFO)(RRange x : EXP RANGE) = true
  | nb_range fmtinfo (RRangeAttr x : EXP RANGE) = nb_exp fmtinfo x
and €nb_discrete_range_constrained› (fmtinfo: PP_FMT_INFO)
		({tmark=t, range=r} : EXP DISCRETE_RANGE_CONSTRAINED) = true
and €nb_discrete_range› (fmtinfo : PP_FMT_INFO) (DRRange x : DISCRETE_RANGE) = (nb_range fmtinfo x)
  | nb_discrete_range (fmtinfo : PP_FMT_INFO)(DRConstrained x : DISCRETE_RANGE) =
    (nb_discrete_range_constrained fmtinfo x)
and €nb_agg_choice› (fmtinfo : PP_FMT_INFO) (ACAggChoiceRange x : AGG_CHOICE) = (nb_discrete_range fmtinfo x)
  | nb_agg_choice (fmtinfo : PP_FMT_INFO) (ACAggChoiceSingle x : AGG_CHOICE) = (nb_exp fmtinfo x)
and €nb_agg_choice_list› (_: PP_FMT_INFO)([] : AGG_CHOICE list) = false
 | nb_agg_choice_list (fmtinfo: PP_FMT_INFO) ([x] : AGG_CHOICE list) = (nb_agg_choice fmtinfo x)
  | nb_agg_choice_list (fmtinfo: PP_FMT_INFO) (x::xs : AGG_CHOICE list) = true
and €nb_named_assoc› (fmtinfo: PP_FMT_INFO)({choice=c, comp=e} : (AGG_CHOICE, EXP) NAMED_ASSOC) = true
and €nb_named_assoc_list› (_: PP_FMT_INFO)([] : (AGG_CHOICE, EXP) NAMED_ASSOC list) = false
  | nb_named_assoc_list (fmtinfo: PP_FMT_INFO) ([x] : (AGG_CHOICE, EXP) NAMED_ASSOC list) =
    (nb_named_assoc fmtinfo x)
  | nb_named_assoc_list (fmtinfo: PP_FMT_INFO) (x::xs : (AGG_CHOICE, EXP) NAMED_ASSOC list) = true
and €nb_others› (fmtinfo: PP_FMT_INFO)({others=oth} : EXP OTHERS) = true
and €nb_agg_pos› (fmtinfo: PP_FMT_INFO) ({tmark=tm, comps=c} : EXP AGG_POS) =
    (case tm
	of Nil => false
	| Value t => true
    )
and €nb_agg_pos_others› (fmtinfo: PP_FMT_INFO) ({agg_pos = {tmark=tm, comps=c} :
    EXP AGG_POS, others = oth} : EXP AGG_POS_OTHERS) =
    (case tm
	of Nil => false
	| Value t => true
    )
and €nb_agg_others› (fmtinfo: PP_FMT_INFO) ({tmark=tm, others=oth} : EXP AGG_OTHERS) =
    (case tm
	of Nil =>  false
	| Value t => true
    )
and €nb_agg_named› (fmtinfo: PP_FMT_INFO)
	({tmark=tm,named_assocs=n} : (AGG_CHOICE, EXP) AGG_NAMED) =
    (case tm
	of Nil => false
	| Value t => true
    )
and €nb_agg_named_others› (fmtinfo: PP_FMT_INFO) 
	({agg_named=a as{tmark=tm, named_assocs=n}, others=oth} :
		(AGG_CHOICE, EXP) AGG_NAMED_OTHERS) =
    (case tm
	of Nil => false
	| Value t => true
    )
and €nb_unary_exp› (fmtinfo: PP_FMT_INFO) ({uop=u, right=r} 
		: EXP UNARY_EXP) = true
and €nb_bin_exp› (fmtinfo: PP_FMT_INFO) ({bop=b, left=l, right=r}
		: EXP BIN_EXP) = true
and €nb_attrib_desig› (fmtinfo : PP_FMT_INFO) (ADAttrib x : ATTRIB_DESIG) =
	nb_attrib fmtinfo x
  | nb_attrib_desig (fmtinfo: PP_FMT_INFO) (ADAttribArg (a,e) 
		: ATTRIB_DESIG) = true
and €nb_mem_range› (fmtinfo: PP_FMT_INFO) 
	({left=e, mop=m, range=r} : EXP MEM_RANGE) = true

and €nb_attribute› (fmtinfo: PP_FMT_INFO)
	({prefix=p, attribute_desig=a} : (EXP, ATTRIB_DESIG) ATTRIBUTE) = true

and €nb_indexed_comp› (fmtinfo: PP_FMT_INFO) 
	({prefix=p, index=i} : EXP INDEXED_COMP) = true
and €nb_selected_comp› (fmtinfo: PP_FMT_INFO) 
	({prefix=p, selector=s} : EXP SELECTED_COMP) = true
and €nb_qualified_expression› (fmtinfo: PP_FMT_INFO)
	({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) = true
and €nb_type_conversion› (fmtinfo: PP_FMT_INFO)
	({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) = true
and €nb_exp› (fmtinfo: PP_FMT_INFO) (EId x : EXP) = (nb_id fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EIntReal x : EXP) = (nb_int_real_lit fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EArrayAggPos x : EXP) = (nb_agg_pos fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EArrayAggPosOthers x : EXP) = 
	(nb_agg_pos_others fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EArrayAggOthers x : EXP) = 
	(nb_agg_others  fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EArrayAggNamed x : EXP) = 
	(nb_agg_named fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EArrayAggNamedOthers x : EXP) = 
	(nb_agg_named_others fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (ERecAggPos x : EXP) = (nb_agg_pos fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (ERecAggNamed x : EXP) = false
  | nb_exp (fmtinfo: PP_FMT_INFO) (EUnaryExp x : EXP) = (nb_unary_exp fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EBinExp x : EXP) = (nb_bin_exp fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EMemRange x : EXP) = (nb_mem_range fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EAttribute x : EXP) = (nb_attribute fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EIndexedComp x : EXP) = 
	(nb_indexed_comp fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (ESelectedComp x : EXP) = 
	(nb_selected_comp fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EFunCall x : EXP) = false
  | nb_exp (fmtinfo: PP_FMT_INFO) (EAuxiliaryExp x : EXP) = true
  | nb_exp (fmtinfo: PP_FMT_INFO) (EQualifiedExp x : EXP) =
	(nb_qualified_expression fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (ETypeConversion x : EXP) =
	(nb_type_conversion fmtinfo x)
  | nb_exp (fmtinfo  : PP_FMT_INFO) (EBracketed e : EXP) = false
  | nb_exp ({outf,...}: PP_FMT_INFO) (EStringLiteral s : EXP) = true
  | nb_exp ({outf,...}: PP_FMT_INFO) (ECharacterLiteral c : EXP) = true
  | nb_exp ({outf,...}: PP_FMT_INFO) (EDiscreteRange _: EXP) = true
and €nb_exp_list› (fmtinfo: PP_FMT_INFO) ([] : EXP list) = false
  | nb_exp_list (fmtinfo: PP_FMT_INFO) ([x] : EXP list) = (nb_exp fmtinfo x)
  | nb_exp_list (fmtinfo : PP_FMT_INFO) (x::xs : EXP list) = true;
=TEX
=IGN
(* apparently not needed *)
fun €nb_static_exp› (fmtinfo: PP_FMT_INFO)(x : STATIC_EXP) = (nb_exp fmtinfo x);

fun €nb_static_rangelohi› (fmtinfo: PP_FMT_INFO) ({lo=l, hi=h} : STATIC_EXP RANGELOHI) = true;
fun €nb_static_range› (fmtinfo: PP_FMT_INFO) (RRange x : EXP RANGE) =
	nb_static_rangelohi fmtinfo x
  | nb_static_range (fmtinfo: PP_FMT_INFO) (RRangeAttr x : EXP RANGE) =
	nb_static_exp fmtinfo x;

fun €nb_cond› (fmtinfo: PP_FMT_INFO) (c : COND) = (nb_exp fmtinfo c);

fun €nb_actuals› (fmtinfo : PP_FMT_INFO) (_ : (AGG_CHOICE, EXP) ACTUALS) = false;

=TEX
Statements, nor items embedding them never need brackets.

\subsection{Expression Fragments}
=SML
fun €is_expansion_selected› ({fmt_repl, ...} : PP_FMT_INFO) : bool = (
    case fmt_repl of
	Value _	=> true
    |    Nil 	=> false
);
=TEX

=SML
fun €fmt_z_tm› (fmt_info as {outf,...} : PP_FMT_INFO) (z_tm : Z_TM) : unit = 
=FULLVERSION
(
    case z_tm of
	ZTmFancyApp ((TmplPre (("ê", Nil), StubUS), ""),
	ZTmTuple[z_tm']) => (
	    fmt_z_tm fmt_info z_tm'
    ) |    ZTmFancyApp ((TmplPre (("ê", Nil), StubUS), ""), z_tm') => (
	    fmt_z_tm fmt_info z_tm'
    ) |    ZTmQuotation (tm, Nil) => (
	    outf(translate_for_output
		(format_list Combinators.I (PrettyPrinter.format_term false tm) "\n"))
    ) |    _ => outf(translate_for_output(format_z_tm z_tm))
);
=CUTDOWNVERSION
 ();
=TEX

Leaf functions, these don't call any other functions.

=SML

fun €fmt_id_plus›  (fmtinfo as {outf,...}: PP_FMT_INFO) (n : ID) (s : string): unit  = (
	outf(translate_for_output (sfmt_id_plus fmtinfo n s))
);

fun €fmt_id_comma›  (fmtinfo : PP_FMT_INFO) (n : ID) : unit  = (
	fmt_id_plus fmtinfo n ","
);
fun €fmt_id›  (fmtinfo : PP_FMT_INFO) (n : ID) : unit  = (
	fmt_id_plus fmtinfo n ""
);

fun €fmt_tmark_plus›  (fmtinfo : PP_FMT_INFO) (t : TMARK) (s : string): unit =
	fmt_id_plus fmtinfo t s;
fun €fmt_tmark›  (fmtinfo : PP_FMT_INFO) (t : TMARK) : unit = 
	fmt_tmark_plus fmtinfo t "";
fun €fmt_tmark_comma›  (fmtinfo : PP_FMT_INFO) (t : TMARK) : unit =
	fmt_tmark_plus fmtinfo t ",";

fun €fmt_term›  ({outf,...} : PP_FMT_INFO) (z : TERM) : unit = (
let	val cn_als = get_int_control	"cn_automatic_line_splitting";
	val awidth = if cn_als = 0
		then get_line_length()
		else cn_als;
	val awidth1 = if (awidth - len_tab()) < 0
		then 0
		else awidth - len_tab();
	val strs = map translate_for_output
=FULLVERSION
                  (PrettyPrinter.format_term1 false awidth1 z);
=CUTDOWNVERSION
                 [];
=SML
in
	outf (hd strs);
	if (length strs = 1)
	then ()
	else (map (fn s => (outf("\n"); outf(s))) (tl strs);
		())
end);

fun €fmt_label› ({outf,...} : PP_FMT_INFO) (label : LABEL) = 
	outf (translate_for_output("("^label^")"));

fun €fmt_unary_op› ({outf,...} : PP_FMT_INFO) (UOSparkUnaryAdd : UNARY_OP) = outf "+"
  | fmt_unary_op ({outf,...} : PP_FMT_INFO) (UOSparkUnaryMinus : UNARY_OP) = outf "-"
  | fmt_unary_op ({outf,...} : PP_FMT_INFO)(UOSparkNot : UNARY_OP) = outf (kw "not")
  | fmt_unary_op ({outf,...} : PP_FMT_INFO)(UOSparkAbs : UNARY_OP) = outf (kw "abs");

fun €fmt_binary_op› ({outf,...} : PP_FMT_INFO)(BOSparkAdd : BIN_OP) = outf"+"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkAnd : BIN_OP) = outf (kw "and")
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkAndThen : BIN_OP) = outf (kw "and then")
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkConcat : BIN_OP) = outf "&"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkEq : BIN_OP) = outf "="
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkExpon : BIN_OP) = outf "**"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkGreater : BIN_OP) = outf ">"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkGreaterEq : BIN_OP) = outf ">="
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkDiv : BIN_OP) = outf "/"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkLess : BIN_OP) = outf "<"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkLessEq : BIN_OP) = outf "<="
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkMem : BIN_OP) = outf (kw "in")
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkMinus : BIN_OP) = outf "-"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkMod : BIN_OP) = outf (kw "mod")
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkNotEq : BIN_OP) = outf "/="
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkNotMem : BIN_OP) = outf (kw "not in")
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkOr : BIN_OP) = outf (kw "or")
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkOrElse : BIN_OP) = outf (kw "or else")
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkRem : BIN_OP) = outf (kw "rem")
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkTimes : BIN_OP) = outf "*"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkXor : BIN_OP) = outf (kw "xor");

fun €fmt_mode› ({outf,...} : PP_FMT_INFO)(MSparkIn true : MODE) = outf (kw"IN")
  | fmt_mode ({outf,...} : PP_FMT_INFO)(MSparkIn false : MODE) = ()
  | fmt_mode ({outf,...} : PP_FMT_INFO)(MSparkOut : MODE) = outf (kw"OUT")
  | fmt_mode ({outf,...} : PP_FMT_INFO)(MSparkInOut : MODE) = outf (kw2"IN""OUT");

fun €fmt_loop_direction› ({outf,...} : PP_FMT_INFO) (LDForwards : LOOP_DIRECTION) = ()
  | fmt_loop_direction ({outf,...} : PP_FMT_INFO)(LDReverse : LOOP_DIRECTION) = outf (kw"REVERSE");
=TEX
To ensure that the string quotes are adjacent to the operator name.
=SML
fun €sfmt_operator_symbol› ({outf,...} : PP_FMT_INFO)(s : OPERATOR_SYMBOL) = (
	( "\"" ^ translate_for_output s ^ "\"")
);
=TEX

Lists of leaf functions.
=SML

fun €fmt_id_list› (fmtinfo : PP_FMT_INFO)([] : ID list) = ()
  | fmt_id_list (fmtinfo : PP_FMT_INFO)([x] : ID list) = (fmt_id fmtinfo x)
  | fmt_id_list (fmtinfo : PP_FMT_INFO)(x::xs: ID list) = (
	(fmt_id_comma fmtinfo x);
	(fmt_id_list fmtinfo xs)
  );

fun €fmt_tmark_list› (_ : PP_FMT_INFO)([] : TMARK list) = ()
  | fmt_tmark_list (fmtinfo : PP_FMT_INFO)([x] : TMARK list) = (fmt_tmark fmtinfo x)
  | fmt_tmark_list (fmtinfo as {outf,...}: PP_FMT_INFO)(x::xs : TMARK list) = (
    (fmt_tmark_comma fmtinfo x);
    (fmt_tmark_list fmtinfo xs)
  );

=TEX

Equivalences to leaf functions.

=SML

fun €fmt_z_pred› (fmtinfo : PP_FMT_INFO) (z : Z_PRED) = fmt_term fmtinfo z;
fun €fmt_z_exp› (fmtinfo : PP_FMT_INFO) (z : Z_EXP) =  fmt_term fmtinfo z;
fun €sfmt_z_id› ({outf, ...} : PP_FMT_INFO) (z : Z_ID) = z;
fun €fmt_z_id› ({outf, ...} : PP_FMT_INFO) (z : Z_ID) = outf (translate_for_output z);
=TEX
The lexical analyser treats attribute identifiers as including the prime character.
We need to work round that to get the case right.
We must not run the identifier through {\it fmt\_id} once we have adjusted the
case, since that would cause a lower case `o' to be translated into a dot.
=SML
fun €fmt_attrib› (fmtinfo as {outf, ...} : PP_FMT_INFO) (x : ATTRIB) = (
	outf (
		case explode (kw ("'"^x)) of
			"'"::more => implode more
		|	weird => implode weird)
);
fun €fmt_int_real_lit› (fmtinfo : PP_FMT_INFO) (x : INT_REAL_LIT) = fmt_id fmtinfo x;

=TEX

\subsection{Expressions}

Expressions.

=SML
fun €fmt_rangelohi› (fmtinfo as {outf,...}: PP_FMT_INFO) 
	({lo=l, hi=h} : EXP RANGELOHI) = (
		(fmt_exp fmtinfo l);
		outf "..";
		(fmt_exp fmtinfo h)
	)
and €fmt_range› (fmtinfo: PP_FMT_INFO)(RRange x : EXP RANGE) = fmt_rangelohi fmtinfo x
  | fmt_range fmtinfo (RRangeAttr x : EXP RANGE) = fmt_exp fmtinfo x
and €fmt_discrete_range_constrained› (fmtinfo as {outf,...}: PP_FMT_INFO)
		({tmark=t, range=r} : EXP DISCRETE_RANGE_CONSTRAINED) = (
    (fmt_tmark fmtinfo t);
    outf (kw"RANGE");
    (fmt_range fmtinfo r)
    )
and €fmt_discrete_range› (fmtinfo : PP_FMT_INFO) (DRRange x : DISCRETE_RANGE) = (fmt_range fmtinfo x)
  | fmt_discrete_range (fmtinfo : PP_FMT_INFO)(DRConstrained x : DISCRETE_RANGE) =
    (fmt_discrete_range_constrained fmtinfo x)
and €fmt_agg_choice› (fmtinfo : PP_FMT_INFO) (ACAggChoiceRange x : AGG_CHOICE) = (fmt_discrete_range fmtinfo x)
  | fmt_agg_choice (fmtinfo : PP_FMT_INFO) (ACAggChoiceSingle x : AGG_CHOICE) = (fmt_exp fmtinfo x)
and €fmt_agg_choice_list› (_: PP_FMT_INFO)([] : AGG_CHOICE list) = ()
  | fmt_agg_choice_list (fmtinfo as {outf,...}: PP_FMT_INFO) ([x] : AGG_CHOICE list) = (fmt_agg_choice fmtinfo x)
  | fmt_agg_choice_list (fmtinfo as {outf,...}: PP_FMT_INFO) (x::xs : AGG_CHOICE list) = (
	(fmt_agg_choice fmtinfo x);
	outf "|";
	(fmt_agg_choice_list fmtinfo xs)
   )
and €fmt_named_assoc› (fmtinfo as {outf,...}: PP_FMT_INFO)({choice=c, comp=e} : (AGG_CHOICE, EXP) NAMED_ASSOC) = (
    (fmt_agg_choice_list fmtinfo c);
    outf "=>";
    (fmt_exp fmtinfo e))
and €fmt_named_assoc_list› (_: PP_FMT_INFO)([] : (AGG_CHOICE, EXP) NAMED_ASSOC list) = ()
  | fmt_named_assoc_list (fmtinfo as {outf,...}: PP_FMT_INFO) ([x] : (AGG_CHOICE, EXP) NAMED_ASSOC list) =
    (fmt_named_assoc fmtinfo x)
  | fmt_named_assoc_list (fmtinfo as {outf,...}: PP_FMT_INFO) (x::xs : (AGG_CHOICE, EXP) NAMED_ASSOC list) = (
	(fmt_named_assoc fmtinfo x);
	outf ",";
	(fmt_named_assoc_list fmtinfo xs)
    )
and €fmt_others› (fmtinfo as {outf,...}: PP_FMT_INFO)({others=oth} : EXP OTHERS) = (
	outf (kw"OTHERS");
	outf "=>";
	(fmt_exp fmtinfo oth)
)
and €fmt_agg_pos› (fmtinfo as {outf,...}: PP_FMT_INFO) ({tmark=tm, comps=c} : EXP AGG_POS) =
    (case tm
	of Nil => ( outf "("; (fmt_exp_list fmtinfo c); outf ")")
	| Value t => ((fmt_tmark fmtinfo t; outf "'"; outf "(");
		(fmt_exp_list fmtinfo c);
		outf ")")
    )
and €fmt_agg_pos_others› (fmtinfo as {outf,...}: PP_FMT_INFO) ({agg_pos = {tmark=tm, comps=c} :
    EXP AGG_POS, others = oth} : EXP AGG_POS_OTHERS) =
    (case tm
	of Nil => (
		outf "(";
		(fmt_exp_list fmtinfo c);
		outf ",";
		(fmt_others fmtinfo oth);
		outf ")"
	) | Value t => (
		fmt_tmark fmtinfo t; outf "'"; outf "(";
		(fmt_exp_list fmtinfo c);
		outf ",";
		(fmt_others fmtinfo oth);
		outf ")"
	)
    )
and €fmt_agg_others› (fmtinfo as {outf,...}: PP_FMT_INFO) ({tmark=tm, others=oth} : EXP AGG_OTHERS) =
    (case tm
	of Nil =>  (
		outf "(";
		(fmt_others fmtinfo oth);
		outf ")"
    ) | Value t => (
		fmt_tmark fmtinfo t; outf "'"; outf "(";
		(fmt_others fmtinfo oth);
		outf ")"
	)
    )
and €fmt_agg_named› (fmtinfo as {outf,...}: PP_FMT_INFO)
	({tmark=tm,named_assocs=n} : (AGG_CHOICE, EXP) AGG_NAMED) =
    (case tm
	of Nil => (
		outf "(";
		(fmt_named_assoc_list fmtinfo n);
		outf ")"
	) | Value t => (
		fmt_tmark fmtinfo t; outf "'"; outf "(";
		(fmt_named_assoc_list fmtinfo n);
		outf ")"
	)
    )
and €fmt_agg_named_others› (fmtinfo as {outf,...}: PP_FMT_INFO) 
	({agg_named=a as{tmark=tm, named_assocs=n}, others=oth} :
		(AGG_CHOICE, EXP) AGG_NAMED_OTHERS) =
    (case tm
	of Nil => (
		outf "(";
		(fmt_named_assoc_list fmtinfo n);
		outf ",";
		(fmt_others fmtinfo oth);
		outf ")"
	) | Value t => (
		(fmt_tmark fmtinfo t; outf "'"; outf "(");
		(fmt_named_assoc_list fmtinfo n);
		outf ",";
		(fmt_others fmtinfo oth);
		outf ")"
	)
    )
and €fmt_unary_exp› (fmtinfo: PP_FMT_INFO) ({uop=u, right=r} 
		: EXP UNARY_EXP) =
    ((fmt_unary_op fmtinfo u); (fmt_exp fmtinfo r))
and €fmt_bin_exp› (fmtinfo as {outf,...}: PP_FMT_INFO) ({bop=b, left=l, right=r}
		: EXP BIN_EXP) =
    ((fmt_exp fmtinfo l); (fmt_binary_op fmtinfo b); (fmt_exp fmtinfo r))
and €fmt_attrib_desig› (fmtinfo : PP_FMT_INFO) (ADAttrib x : ATTRIB_DESIG) =
	fmt_attrib fmtinfo x
  | fmt_attrib_desig (fmtinfo as {outf,...}: PP_FMT_INFO) (ADAttribArg (a,e) 
		: ATTRIB_DESIG) =
    ((fmt_attrib fmtinfo a); outf "("; (fmt_exp fmtinfo e); outf ")")
and €fmt_mem_range› (fmtinfo as {outf,...}: PP_FMT_INFO) 
	({left=e, mop=m, range=r} : EXP MEM_RANGE) = 
    (fmt_exp fmtinfo e; fmt_binary_op fmtinfo m; fmt_range fmtinfo r)
and €fmt_attribute› (fmtinfo as {outf,...}: PP_FMT_INFO)
	({prefix=p, attribute_desig=a} : (EXP, ATTRIB_DESIG) ATTRIBUTE) =
    (fmt_exp fmtinfo p; outf"'"; (fmt_attrib_desig fmtinfo a))

and €fmt_indexed_comp› (fmtinfo as {outf,...}: PP_FMT_INFO) 
	({prefix=p, index=i} : EXP INDEXED_COMP) = (
    fmt_exp fmtinfo p;
    (if (nb_exp fmtinfo i)
    then ( (* bracket *)
	outf "("; fmt_exp fmtinfo i;	outf ")"
    ) else (fmt_exp fmtinfo i))
   )
and €fmt_selected_comp› (fmtinfo as {outf,...}: PP_FMT_INFO) 
	({prefix=p, selector=s} : EXP SELECTED_COMP) =
    (fmt_exp fmtinfo p; outf "."; (fmt_id fmtinfo s))
and €fmt_qualified_expression› (fmtinfo as {outf,...}: PP_FMT_INFO)
	({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) = (
	(fmt_tmark fmtinfo t); 
	outf "'";
	(if (nb_exp fmtinfo e)
	then ( (* bracket *)
	    outf "("; fmt_exp fmtinfo e; outf ")"
	) else (fmt_exp fmtinfo e)))
and €fmt_type_conversion› (fmtinfo as {outf,...}: PP_FMT_INFO)
	({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) = (
	fmt_tmark fmtinfo t;
	(if (nb_exp fmtinfo e)
	then ( (* bracket *)
	outf "("; fmt_exp fmtinfo e;	outf ")"
	) else (fmt_exp fmtinfo e))
)
and €fmt_exp› (fmtinfo: PP_FMT_INFO) (EId x : EXP) = (fmt_id fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EIntReal x : EXP) = (fmt_int_real_lit fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EArrayAggPos x : EXP) = (fmt_agg_pos fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EArrayAggPosOthers x : EXP) = 
	(fmt_agg_pos_others fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EArrayAggOthers x : EXP) = 
	(fmt_agg_others  fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EArrayAggNamed x : EXP) = 
	(fmt_agg_named fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EArrayAggNamedOthers x : EXP) = 
	(fmt_agg_named_others fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (ERecAggPos x : EXP) = (fmt_agg_pos fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (ERecAggNamed x : EXP) =
    fail "fmt_statement" 510999 [fn()=>"named record aggregate"]
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EUnaryExp x : EXP) = (fmt_unary_exp fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EBinExp x : EXP) = (fmt_bin_exp fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EMemRange x : EXP) = (fmt_mem_range fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EAttribute x : EXP) = (fmt_attribute fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EIndexedComp x : EXP) = 
	(fmt_indexed_comp fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (ESelectedComp x : EXP) = 
	(fmt_selected_comp fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EFunCall x : EXP) = 
    fail "fmt_statement" 510999 [fn()=>"function call"]
  | fmt_exp (fmtinfo as {outf,...}: PP_FMT_INFO) (EAuxiliaryExp x : EXP) = 
	(outf (translate_for_output "˚"); (fmt_z_tm fmtinfo x); outf (translate_for_output "˝"))
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EQualifiedExp x : EXP) =
	(fmt_qualified_expression fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (ETypeConversion x : EXP) =
	(fmt_type_conversion fmtinfo x)
  | fmt_exp (fmtinfo as {outf, ...} : PP_FMT_INFO) (EBracketed e : EXP) = 
	(outf "("; (fmt_exp fmtinfo e); outf ")")
(*
=TEX
We don't use translate_for_output on string and character literals to get
things like percent signs right
=SML
*)
  | fmt_exp ({outf,...}: PP_FMT_INFO) (EStringLiteral s : EXP) = 
	(outf ("\""^s^"\"")) 
  | fmt_exp ({outf,...}: PP_FMT_INFO) (ECharacterLiteral c : EXP) =
	outf ("'"^c^"'")

  | fmt_exp ({outf,...}: PP_FMT_INFO) (EDiscreteRange _: EXP) =
	outf ("<invalid-expression>")
and €fmt_exp_list› (fmtinfo: PP_FMT_INFO) ([] : EXP list) = ()
  | fmt_exp_list (fmtinfo: PP_FMT_INFO) ([x] : EXP list) = (fmt_exp fmtinfo x)
  | fmt_exp_list (fmtinfo as {outf,...} : PP_FMT_INFO) (x::xs : EXP list) = 
	((fmt_exp fmtinfo x); outf ","; (fmt_exp_list fmtinfo xs));
=TEX
=SML
fun €fmt_static_exp› (fmtinfo: PP_FMT_INFO)(x : STATIC_EXP) = (fmt_exp fmtinfo x);

fun €fmt_static_rangelohi› (fmtinfo as {outf,...}: PP_FMT_INFO) ({lo=l, hi=h} : STATIC_EXP RANGELOHI) = (
	(fmt_static_exp fmtinfo l);
	outf "..";
	(fmt_static_exp fmtinfo h)
);
fun €fmt_static_range› (fmtinfo: PP_FMT_INFO) (RRange x : EXP RANGE) =
	fmt_static_rangelohi fmtinfo x
  | fmt_static_range (fmtinfo: PP_FMT_INFO) (RRangeAttr x : EXP RANGE) =
	fmt_static_exp fmtinfo x;

fun €fmt_cond› (fmtinfo: PP_FMT_INFO) (c : COND) = (fmt_exp fmtinfo c);

fun €fmt_actuals› (fmtinfo as {outf,...} : PP_FMT_INFO) (APositional x : (AGG_CHOICE, EXP) ACTUALS) = 
    (case x
	of [] => ()
	| z => (
		outf "(";
		(fmt_exp_list fmtinfo x);
		outf ")"
	)
    )
  | fmt_actuals (fmtinfo as {outf,...}: PP_FMT_INFO) (ANamed x : (AGG_CHOICE, EXP) ACTUALS) =
    (case x
	of [] => ()
	| z => (
		outf "(";
		(fmt_named_assoc_list fmtinfo x);
		outf ")"
	)
    );

=TEX

\subsection{Statements}

A few auxiliary functions before we do statements.

=SML

fun €fmt_spec› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({w=w, w0=w0, pre=pre, post=post} : SPEC) = (
	let	fun out_frame [] = ()
		|   out_frame [zn] = outf ((sfmt_z_id fmtinfo) (translate_for_output zn))
		|   out_frame (zn::zns) = (out_frame [zn]; outf ","; out_frame zns);
	in	outf (translate_for_output "Ñ");
		out_frame w;
		outf "[";
		(fmt_z_tm fmtinfo pre);
		outf ",";
		(fmt_z_tm fmtinfo post);
		outf "]"
	end
);

fun €fmt_proc_call› (fmtinfo : PP_FMT_INFO)
	({name=n, actuals=e} : (AGG_CHOICE, EXP) PROC_CALL) =
    ((fmt_id fmtinfo n); (fmt_actuals fmtinfo e));
=TEX
=SML
fun €fmt_pragma› (fmtinfo as {outf,...} : PP_FMT_INFO)
		({id, args} : (AGG_CHOICE, EXP) PRAGMA) : unit = (
let	fun fmt_arg (Nil, e) =
		fmt_exp fmtinfo e
	|   fmt_arg (Value ac, e) = (
		fmt_agg_choice fmtinfo ac;
		outf "=>";
		fmt_exp fmtinfo e
	);
	fun fmt_arg_list [] = ()
	| fmt_arg_list [x] = fmt_arg x
	| fmt_arg_list (x :: xs) = (
		fmt_arg x;
		outf ",";
		fmt_arg_list xs
	);
in	(outf (kw"PRAGMA" ^" "^ kw id);
	(case args of
		[] => (outf ";"; outf "\n")
		| _ => (
			outf "(";
			fmt_arg_list args;
			outf ")"; outf ";";
			outf "\n"
		)
	))
end);
=TEX
At version 2.5.7 and later, the lexical analyser let us get strings
in arbitrary Ada right by doing the translation for output on the
non-string parts of the Ada for us. This means that `%' and `Q'
in strings print correctly.
=SML
fun €fmt_replaced_by_arbitrary_ada› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({label, replacement} : REPLACED_BY_ARBITRARY_ADA ) = (
	(fmt_label fmtinfo label);
	outf (translate_for_output "!È");
	outf replacement;
	outf "\n"
);
=TEX
At version 2.5.7 and later, the lexical analyser helps us get strings
in annotations right, by doing the translation for output for us on
the non-string parts of the annotation. This means that `%' and `Q'
in strings print correctly.
=SML
fun €fmt_ann› (fmtinfo as {outf,fmt_repl} : PP_FMT_INFO)
	(anks as ANKSlot {content, label} : ANN) = (
    case fmt_repl of
    Value f => (f label; ())
    | Nil => (outf (translate_for_output ("ß " ^ content^" ¢    "));
	(fmt_label fmtinfo label);
	outf "\n"
    )
) |   fmt_ann (fmtinfo as {outf,fmt_repl} : PP_FMT_INFO) (ANString ann) = (
	outf ann;
	outf "\n"
);
=TEX
=SML
fun €fmt_annotation› (fmtinfo : PP_FMT_INFO) (anns: ANNOTATION) = (
	(map (fmt_ann fmtinfo) anns; ())
);
=TEX
=SML
fun €fmt_expansion› (fmtinfo as {fmt_repl, ...} : PP_FMT_INFO)
	(label : LABEL) : unit = (
	case fmt_repl of
		Nil => ()
	|	Value f => (f label; ())
);
=IGN
=TEX
=SML
fun €fmt_spec_no_ivars› (fmtinfo as {outf, fmt_repl} : PP_FMT_INFO) (s as
		{spec, label} : SPEC_NO_IVARS) = (
	if	(case fmt_repl of
			Value f => (f label)
		|	Nil => false)
	then	()
	else	(
		fmt_spec fmtinfo spec;
		outf "    ";
		(fmt_label fmtinfo label);
		outf "\n"
	)
);
=TEX

Statements.

=SML
fun €fmt_assign› (fmtinfo as {outf,...} : PP_FMT_INFO) ({name=n, e=e} : ASSIGN) = (
	(fmt_exp fmtinfo n);
	outf ":=";
	(fmt_exp fmtinfo e);
	outf ";";
	outf "\n"
);

fun €fmt_exit_when› (fmtinfo as {outf,...} : PP_FMT_INFO) ({g=g, n = n} : EXIT_WHEN) = (
	outf (kw"EXIT");
	(case n of Value name => fmt_id fmtinfo name | _ => ());
	outf (kw"WHEN");
	(fmt_cond fmtinfo g);
	outf ";";
	outf "\n"
);

fun €fmt_exit› (fmtinfo as {outf,...} : PP_FMT_INFO) ({n = n} : EXIT) = (
	outf (kw"EXIT");
	(case n of Value name => fmt_id fmtinfo name | _ => ());
	outf ";";
	outf "\n"
);
=TEX
=SML
fun €fmt_return› (fmtinfo as {outf,...} : PP_FMT_INFO) ({e=e} : RETURN) = (
	outf (kw"RETURN");
	(case e of Value exp => fmt_exp fmtinfo exp | _ => ());
	outf ";";
	outf "\n"
);

fun €fmt_proc_call_no_ivars› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(x : (AGG_CHOICE, EXP) PROC_CALL_NO_IVARS) = (
	(fmt_proc_call fmtinfo x);
	outf ";";
	outf "\n"
);

fun €fmt_k_slot› (fmtinfo as {outf, fmt_repl} : PP_FMT_INFO) ({content, label} : K_SLOT) = (
    case fmt_repl of
    Value f =>    (f label; ())
    |Nil =>    (
	outf "ß";
	outf (translate_for_output content);
	outf " ¢   ";
	(fmt_label fmtinfo label);
	outf "\n"
	)
);
=TEX
=SML
fun €fmt_elsif› 
	(fmt_stat : PP_FMT_INFO -> STATEMENT -> unit)
	(fmtinfo as {outf,...} : PP_FMT_INFO)
	(stmt as (STIfThenElse {g=g, p=p, q=q, elsif=true}) : STATEMENT) = (
	outf (kw"ELSIF");
	(fmt_cond fmtinfo g);
	outf "\n";
	outf (kw"THEN");
	outf "\n";
	inc_tabs ();
	(fmt_stat fmtinfo p);
	dec_tabs();
	(fmt_elsif fmt_stat fmtinfo q)
   )
  | fmt_elsif fmt_stat (fmtinfo as {outf,...} : PP_FMT_INFO)
	(stmt as (STIfThenElse {g=g, p=p, q=q, elsif=false}) : STATEMENT) = (
	outf (kw"ELSIF");
	(fmt_cond fmtinfo g); outf "\n";
	outf (kw"THEN"); outf "\n";
	inc_tabs(); fmt_stat fmtinfo p; dec_tabs();
	(case q
	of STImplicitNull => ()
	| z => (
		outf (kw"ELSE"); outf "\n";
		inc_tabs();
		(fmt_stat fmtinfo q);
		dec_tabs()
	)
	)
   )
  | fmt_elsif fmt_stat (fmtinfo as {outf,...} : PP_FMT_INFO) (stmt : STATEMENT) = (
	inc_tabs();
	(fmt_stat fmtinfo stmt);
	dec_tabs()
  );

fun €fmt_if_then_else›
	(fmt_stat : PP_FMT_INFO -> STATEMENT -> unit)
	(fmtinfo as {outf,...} : PP_FMT_INFO)
	({g=g, p=p, q=q, elsif=false} : STATEMENT IF_THEN_ELSE) = (
	outf (kw"IF");
	(fmt_cond fmtinfo g);
	outf "\n";
	outf (kw"THEN");
	outf "\n";
	inc_tabs();
	(fmt_stat fmtinfo p);
	dec_tabs();
	(case q
	of STImplicitNull => ()
	| _ => (
		outf (kw"ELSE"); outf "\n";
		inc_tabs();
		(fmt_stat fmtinfo q);
		dec_tabs()
	    )
	);
	outf (kw2"END" "IF" ^ ";");
	outf "\n"
  ) | fmt_if_then_else fmt_stat (fmtinfo as {outf,...} : PP_FMT_INFO)
	({g=g, p=p, q=q, elsif=true} : STATEMENT IF_THEN_ELSE) = (
	outf (kw"IF");
	(fmt_cond fmtinfo g);
	outf "\n";
	outf (kw"THEN");
	outf "\n";
	inc_tabs();
	(fmt_stat fmtinfo p);
	dec_tabs();
	(fmt_elsif fmt_stat fmtinfo q);
	outf (kw2"END""IF"^";");
	outf "\n"
   );

fun €fmt_case_choice› (fmtinfo : PP_FMT_INFO) (CCCaseExp x : CASE_CHOICE) = (fmt_exp fmtinfo x)
  | fmt_case_choice (fmtinfo : PP_FMT_INFO) (CCCaseRange x : CASE_CHOICE) = (fmt_discrete_range fmtinfo x)
and €fmt_case_choice_list›  (fmtinfo : PP_FMT_INFO) ([] : CASE_CHOICE list) = ()
  | fmt_case_choice_list (fmtinfo : PP_FMT_INFO) ([x] : CASE_CHOICE list) = (fmt_case_choice fmtinfo x)
  | fmt_case_choice_list  (fmtinfo as {outf,...} : PP_FMT_INFO) (x::xs : CASE_CHOICE list) = (
	(fmt_case_choice fmtinfo x);
	outf "|";
	(fmt_case_choice_list fmtinfo xs)
   );

fun €fmt_case_alt›
	(fmt_stat : PP_FMT_INFO -> STATEMENT -> unit)
	(fmtinfo as {outf,...} : PP_FMT_INFO)
	({choices=c, p=s} : STATEMENT CASE_ALTERNATIVE) = (
	outf (kw"WHEN");
	(fmt_case_choice_list fmtinfo c);
	outf "=>";
	outf"\n";
	inc_tabs();
	(fmt_stat fmtinfo s);
	dec_tabs(); outf "\n"
);

fun €fmt_case_alt_list›
	(fmt_stat : PP_FMT_INFO -> STATEMENT -> unit)
	(fmtinfo : PP_FMT_INFO)
	([] : STATEMENT CASE_ALTERNATIVE list) = ()
  | fmt_case_alt_list fmt_stat (fmtinfo : PP_FMT_INFO)
	(x::xs : STATEMENT CASE_ALTERNATIVE list) = (
	(fmt_case_alt fmt_stat fmtinfo x);
	(fmt_case_alt_list fmt_stat fmtinfo xs)
   );

fun €fmt_case›
	(fmt_stat : PP_FMT_INFO -> STATEMENT -> unit)
	(fmtinfo as {outf,...} : PP_FMT_INFO)
	({e=e, s=s, others=oth} : STATEMENT CASE) = (
	outf (kw"CASE");
	(fmt_exp fmtinfo e);
	outf (kw"IS"); outf "\n";
	inc_tabs();
	(fmt_case_alt_list fmt_stat fmtinfo s);
	dec_tabs();
	(
	    case oth
	    of STImplicitNull => ()
	    | _ => (outf (kw2"WHEN""OTHERS" ^ " =>");
			outf"\n";
			inc_tabs();
			fmt_stat fmtinfo oth;
			dec_tabs()
		)
	);
	outf (kw2"END""CASE"^";");
	outf "\n"
   );

fun €fmt_unnamed_loop›
	(fmt_stat : PP_FMT_INFO -> STATEMENT -> unit)
	(fmtinfo as {outf, fmt_repl} : PP_FMT_INFO)
	({t=Value t, stmt=s} : STATEMENT LOOP) = (
    (case fmt_repl of
    Value _ =>    (outf "-- TILL ..."; outf "\n")
    | Nil =>    (
		outf (translate_for_output "TILL ˚");
		(fmt_z_tm fmtinfo t);
		outf (translate_for_output "˝");
		outf "\n")
    );
    outf (kw"LOOP"); outf "\n";
    inc_tabs();
    (fmt_stat fmtinfo s);
    dec_tabs();
    outf (kw2"END""LOOP"^";");
    outf "\n"
    )
  | fmt_unnamed_loop fmt_stat (fmtinfo as {outf,...} : PP_FMT_INFO) ({t=Nil, stmt=s} : STATEMENT LOOP) = (
	outf (kw"LOOP"); outf "\n";
	inc_tabs();
	(fmt_stat fmtinfo s);
	dec_tabs();
	outf (kw2"END""LOOP"^";");
	outf "\n"
   );

fun €fmt_named_loop›
	(fmt_stat : PP_FMT_INFO -> STATEMENT -> unit)
	(fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, t=Value t, stmt=s} : STATEMENT NAMED_LOOP) = (
    in_new_scope false n (fn () => (
	(fmt_id fmtinfo n); outf ":"; outf "\n";
	(    if is_expansion_selected fmtinfo
	then    (outf "-- TILL statement"; outf "\n")
	else    (
		outf (translate_for_output "TILL ˚");
		(fmt_z_tm fmtinfo t);
		outf (translate_for_output "˝"); outf "\n")
	);
	outf (kw"LOOP"); outf "\n";
	inc_tabs();
	(fmt_stat fmtinfo s);
	dec_tabs();
	outf (kw2"END""LOOP"); (fmt_id fmtinfo n); outf ";"; outf "\n"
	)
   )
)  | fmt_named_loop fmt_stat (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, t=Nil, stmt=s} : STATEMENT NAMED_LOOP) = (
    in_new_scope false n (fn () => (
	(fmt_id fmtinfo n); outf ":"; outf "\n";
	outf (kw"LOOP"); outf "\n";
	(inc_tabs(); fmt_stat fmtinfo s; dec_tabs());
	outf (kw2"END""LOOP");(fmt_id fmtinfo n); outf ";"; outf "\n"
    ))
);

fun €fmt_loop_body›
	(fmt_stat : PP_FMT_INFO -> STATEMENT -> unit)
	(fmtinfo as {outf, fmt_repl} : PP_FMT_INFO) ({t=Value t, stmt=s} : STATEMENT LOOP) =  (
    (case fmt_repl of
    Value _  => (outf "-- TILL statement"; outf "\n")
    | Nil =>  (
		outf (translate_for_output "TILL ˚");
		(fmt_z_tm fmtinfo t);
		outf (translate_for_output "˝");
		outf "\n")
    );
    (inc_tabs(); fmt_stat fmtinfo s; dec_tabs())
   )  | fmt_loop_body fmt_stat (fmtinfo : PP_FMT_INFO) ({t=Nil, stmt=s} : STATEMENT LOOP) = (
	(inc_tabs(); fmt_stat fmtinfo s; dec_tabs())
   );

fun €fmt_while›
	(fmt_stat : PP_FMT_INFO -> STATEMENT -> unit)
	(fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=Value n, g=g, loop=l} : STATEMENT WHILE) = (
	(fmt_id fmtinfo n); outf ":"; outf "\n";
	outf  (kw"WHILE"); (fmt_cond fmtinfo g); outf "\n";
	outf (kw"LOOP"); outf "\n";
	(fmt_loop_body fmt_stat fmtinfo l);
	outf (kw2"END""LOOP"); (fmt_id fmtinfo n); outf ";"; outf "\n"
  )
  | fmt_while fmt_stat (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=Nil, g=g, loop=l} : STATEMENT WHILE) = (
	outf (kw"WHILE"); (fmt_cond fmtinfo g); outf "\n";
	outf (kw"LOOP"); outf "\n";
	(fmt_loop_body fmt_stat fmtinfo l);
	outf (kw2"END""LOOP"^";"); outf "\n"
   );

fun €fmt_for_static›
	(fmt_stat : PP_FMT_INFO -> STATEMENT -> unit)
	(fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=Value n, tmark=t, i=i, dir=d, range=r, loop=loop}:
    STATEMENT FOR_STATIC) = (
    in_new_scope false n (fn () => (
	check_decl i;
	(fmt_id fmtinfo n); outf ":"; outf "\n";
	outf (kw"FOR"); fmt_id fmtinfo i; outf (kw"IN");
	fmt_loop_direction fmtinfo d;
	(case t of Value tm => (fmt_tmark fmtinfo tm; outf (kw"RANGE")) | Nil => ());
	(fmt_range fmtinfo r); outf"\n";
	outf (kw"LOOP"); outf "\n";
	(fmt_loop_body fmt_stat fmtinfo loop);
	outf (kw2"END""LOOP");(fmt_id fmtinfo n); outf ";"; outf "\n"
)))
 | fmt_for_static fmt_stat (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=Nil, tmark=t, i=i, dir=d, range=r, loop=loop} :
    STATEMENT FOR_STATIC) = (
    in_new_scope false "" (fn () => (
    check_decl i;
	outf (kw"FOR");
	fmt_id fmtinfo i;
	outf (kw"IN");
	(fmt_loop_direction fmtinfo d);
	(case t of Value tm => (fmt_tmark fmtinfo tm; outf (kw"RANGE")) | Nil => ());
	(fmt_range fmtinfo r); outf "\n";
	outf (kw"LOOP"); outf "\n";
	(fmt_loop_body fmt_stat fmtinfo loop);
	outf (kw2"END""LOOP"^";"); outf "\n"
)));

fun €fmt_for_tmark›
	(fmt_stat : PP_FMT_INFO -> STATEMENT -> unit)
	(fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=Value n, i=i, tmark=t, dir=d, loop=loop} :
    STATEMENT FOR_TMARK) = (
    in_new_scope false n (fn () => (
	check_decl i;
	(fmt_id fmtinfo n); outf ":"; outf "\n";
	outf (kw"FOR"); fmt_id fmtinfo i; outf (kw"IN");
	(fmt_loop_direction fmtinfo d);(fmt_tmark fmtinfo t); outf "\n";
	outf (kw"LOOP"); outf "\n";
	(fmt_loop_body fmt_stat fmtinfo loop);
	outf (kw2"END""LOOP"); (fmt_id fmtinfo n); outf ";"; outf "\n"
)))
 | fmt_for_tmark fmt_stat (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=Nil, i=i, tmark=t, dir=d, loop=loop} :
    STATEMENT FOR_TMARK) = (
    in_new_scope false "" (fn () => (
    check_decl i;
    outf (kw"FOR"); fmt_id fmtinfo i; outf (kw"IN"); 
    (fmt_loop_direction fmtinfo d);
	(fmt_tmark fmtinfo t); outf "\n";
    outf (kw"LOOP"); outf "\n";
    (fmt_loop_body fmt_stat fmtinfo loop);
    outf (kw2"END""LOOP"^";"); outf "\n"
)));
=TEX

Logical constructs.

We don't print out pre1 since it doesn't come from the user *)
=SML
fun €fmt_log_con› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({defs=defs, spec=s, label, ...} : LOG_CON) = (
    if is_expansion_selected fmtinfo
    then    fmt_spec_no_ivars fmtinfo {spec=s, label=label}
    else    (let	fun outdefs [] = ()
		|   outdefs [{x, t, e}] = (
			fmt_z_id fmtinfo x; outf ":"; fmt_z_tm fmtinfo t
		) | outdefs ({x, t, e}::more) = (
			fmt_z_id fmtinfo x; outf ":"; fmt_z_tm fmtinfo t; outf ";";
			outdefs more
		);
	   in
		outf "CON ";
		outdefs defs;
		outf "∑";
		(fmt_spec fmtinfo s);
		outf "    ";(fmt_label fmtinfo label);
		outf "\n"
	   end
	)
);
=TEX
=SML
fun €fmt_statement› (fmtinfo as {outf,...} : PP_FMT_INFO) (STNull : STATEMENT) = (
	outf (kw"NULL"^";"); outf "\n")
  | fmt_statement (fmtinfo as {outf,...} : PP_FMT_INFO) (STImplicitNull : STATEMENT) = ()
  | fmt_statement (fmtinfo as {outf,...} : PP_FMT_INFO) (STAssign x : STATEMENT) =
	(fmt_assign fmtinfo x)
  | fmt_statement (fmtinfo : PP_FMT_INFO) (STSpecNoIvars x : STATEMENT) =
	(fmt_spec_no_ivars fmtinfo x)
  | fmt_statement (fmtinfo : PP_FMT_INFO) (STSemicolon (a,b) : STATEMENT) =
	(fmt_statement fmtinfo a; fmt_statement fmtinfo b)
  | fmt_statement (fmtinfo : PP_FMT_INFO) (STIfThenElse x : STATEMENT) =
	(fmt_if_then_else fmt_statement fmtinfo x)
  | fmt_statement (fmtinfo : PP_FMT_INFO) (STCase x : STATEMENT) =
	(fmt_case fmt_statement fmtinfo x)
  | fmt_statement (fmtinfo : PP_FMT_INFO) (STLoop x : STATEMENT) =
	(fmt_unnamed_loop fmt_statement fmtinfo x)
  | fmt_statement (fmtinfo : PP_FMT_INFO) (STNamedLoop x : STATEMENT) =
	(fmt_named_loop fmt_statement fmtinfo x)
  | fmt_statement (fmtinfo : PP_FMT_INFO) (STWhile x : STATEMENT) =
	(fmt_while fmt_statement fmtinfo x)
  | fmt_statement (fmtinfo : PP_FMT_INFO) (STForStatic x : STATEMENT) =
	(fmt_for_static fmt_statement fmtinfo x)
  | fmt_statement (fmtinfo : PP_FMT_INFO) (STForTmark x : STATEMENT) =
	(fmt_for_tmark fmt_statement fmtinfo x)
  | fmt_statement (fmtinfo : PP_FMT_INFO) (STExitWhen x : STATEMENT) =
	(fmt_exit_when fmtinfo x)
  | fmt_statement (fmtinfo as {outf,...} : PP_FMT_INFO) (STExit x: STATEMENT) =
	(fmt_exit fmtinfo x)
  | fmt_statement (fmtinfo : PP_FMT_INFO) (STRet x : STATEMENT)  =
	(fmt_return fmtinfo x)
  | fmt_statement (fmtinfo : PP_FMT_INFO) (STProcNoIvars x : STATEMENT) =
	(fmt_proc_call_no_ivars fmtinfo x)
  | fmt_statement (fmtinfo : PP_FMT_INFO) (STKSlot x : STATEMENT) =
	(fmt_k_slot fmtinfo x)
  | fmt_statement (fmtinfo : PP_FMT_INFO) (STPragma x : STATEMENT) =
	(fmt_pragma fmtinfo x)
  | fmt_statement (fmtinfo : PP_FMT_INFO) (STAnnotation x : STATEMENT) =
	(fmt_annotation fmtinfo x)
  | fmt_statement (fmtinfo : PP_FMT_INFO) (SSpecIvars x) =
    fail "fmt_statement" 510999 [fn()=>"spec with ivars"]
  | fmt_statement (fmtinfo : PP_FMT_INFO) (SForNonStatic x) = 
    fail "fmt_statement" 510999 [fn()=>"for with non-static bounds"]
  | fmt_statement (fmtinfo : PP_FMT_INFO) (SLogCon x) = (fmt_log_con fmtinfo x)
  | fmt_statement (fmtinfo : PP_FMT_INFO) (SProcIvars x) =
    fail "fmt_statement" 510999 [fn()=>"proc with ivars"];


=TEX

\subsection{Declarations and Type Definitions}
=TEX

Floating point type constraint.

=SML

fun €fmt_floating_point_constraint› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({exp=e, range=Value r} : EXP FLOATING_POINT_CONSTRAINT) = (
	outf (kw"DIGITS"); (fmt_exp fmtinfo e); outf (kw"RANGE");
	(fmt_range fmtinfo r)
  ) | fmt_floating_point_constraint (fmtinfo as {outf,...} : PP_FMT_INFO)
	({exp=e, range=Nil} : EXP FLOATING_POINT_CONSTRAINT) = (
	outf (kw"DIGITS"); fmt_exp fmtinfo e)
and €fmt_floating_type_def› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, x : EXP FLOATING_TYPE_DEF) = (
    check_decl name;
	outf (kw"TYPE"); (fmt_id fmtinfo name);
	outf (kw"IS"); (fmt_floating_point_constraint fmtinfo x); outf ";"; outf "\n"
);

=TEX

Fixed point type constraints.

=SML

fun €fmt_fixed_point_constraint›(fmtinfo as {outf,...} : PP_FMT_INFO)
	({exp=e, range=Value r} : EXP FIXED_POINT_CONSTRAINT) = (
	outf (kw"DELTA"); (fmt_exp fmtinfo e); outf (kw"RANGE");
	(fmt_range fmtinfo r)
) | fmt_fixed_point_constraint(fmtinfo as {outf,...} : PP_FMT_INFO)
	({exp=e, range=Nil} : EXP FIXED_POINT_CONSTRAINT) = (
	outf (kw"DELTA"); fmt_exp fmtinfo e)
and €fmt_fixed_type_def› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, x : EXP FIXED_TYPE_DEF) = (
    check_decl name;
	outf (kw"TYPE"); (fmt_id fmtinfo name);
	outf (kw"IS"); (fmt_fixed_point_constraint fmtinfo x); outf ";"; outf "\n"
);
=TEX
Constraints in the basic syntax:
=SML
fun €fmt_constraint› (fmtinfo as {outf,...} : PP_FMT_INFO) (CRange x : CONSTRAINT) = (
	outf (kw"RANGE"); fmt_range fmtinfo x)
  | fmt_constraint (fmtinfo as {outf,...} : PP_FMT_INFO) (CIndex x : CONSTRAINT) = (
	outf "("; fmt_exp_list fmtinfo x; outf ")")
  | fmt_constraint (fmtinfo as {outf,...} : PP_FMT_INFO) (CDiscriminant x : CONSTRAINT) = (
	outf "("; fmt_exp_list fmtinfo x; outf ")")
  | fmt_constraint (fmtinfo : PP_FMT_INFO)(CFloating x : CONSTRAINT) =
    (fmt_floating_point_constraint fmtinfo x)
  | fmt_constraint (fmtinfo : PP_FMT_INFO)(CFixed x : CONSTRAINT) =
    (fmt_fixed_point_constraint fmtinfo x)
  | fmt_constraint (fmtinfo : PP_FMT_INFO)(CNoCon : CONSTRAINT) =
    ();
=TEX
Subtype indications in the basic syntax:
=SML
fun €fmt_sub_ind›
	(fmtinfo : PP_FMT_INFO)
	({tmark=t, con=c} : CONSTRAINT SUB_IND) = (
    (fmt_tmark fmtinfo t; fmt_constraint fmtinfo c)
);
=TEX
Discrete ranges in the derived syntax:
=SML
fun €fmt_si_discrete_range›
	(fmtinfo : PP_FMT_INFO)
	(SIDiscreteRangeSubInd si : SI_DISCRETE_RANGE) = fmt_sub_ind fmtinfo si
|  fmt_si_discrete_range
	(fmtinfo : PP_FMT_INFO)
	(SIDiscreteRangeRange range) = fmt_range fmtinfo range;
=TEX
Lists of the above:
=SML
fun €fmt_si_discrete_range_list› (fmtinfo: PP_FMT_INFO)
	([] : SI_DISCRETE_RANGE list) = ()
  | fmt_si_discrete_range_list (fmtinfo: PP_FMT_INFO)
	([x]) = (fmt_si_discrete_range fmtinfo x)
  | fmt_si_discrete_range_list (fmtinfo as {outf,...} : PP_FMT_INFO)
	(x::xs) = 
	((fmt_si_discrete_range fmtinfo x); outf ","; (fmt_si_discrete_range_list fmtinfo xs));
=TEX
Constraints in the derived syntax:
=SML
fun €fmt_si_constraint› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(SIRangeCon x : SI_CONSTRAINT) = (
	outf (kw"RANGE"); fmt_range fmtinfo x)
  | fmt_si_constraint (fmtinfo as {outf,...} : PP_FMT_INFO)
	(SIIndexCon x) = (
	outf "("; fmt_si_discrete_range_list fmtinfo x; outf ")")
  | fmt_si_constraint (fmtinfo as {outf,...} : PP_FMT_INFO)
	(SIDiscriminantCon [EArrayAggPos{comps, ...}]) = (
	outf "("; fmt_exp_list fmtinfo comps; outf ")")
  | fmt_si_constraint (fmtinfo as {outf,...} : PP_FMT_INFO)
	(SIDiscriminantCon x) = (
	outf "("; fmt_exp_list fmtinfo x; outf ")")
  | fmt_si_constraint (fmtinfo : PP_FMT_INFO)
	(SIFloatingCon x) =
    (fmt_floating_point_constraint fmtinfo x)
  | fmt_si_constraint (fmtinfo : PP_FMT_INFO)
	(SIFixedCon x) =
    (fmt_fixed_point_constraint fmtinfo x)
  | fmt_si_constraint (fmtinfo : PP_FMT_INFO)
	(SINoCon) =
    ();
=TEX
From now on everything is in the derived syntax and we
sometimes drop the `si' prefix from
the function names.

Subtype indications, lists of same:
=SML
fun €fmt_si_sub_ind›
	(fmtinfo : PP_FMT_INFO)
	({tmark=t, con=c} : SI_SUB_IND) =
    (fmt_tmark fmtinfo t; fmt_si_constraint fmtinfo c);

fun €fmt_si_sub_ind_list› (_ : PP_FMT_INFO)
	([] : SI_SUB_IND list) = ()
  | fmt_si_sub_ind_list (fmtinfo : PP_FMT_INFO)
	([x]) = (fmt_si_sub_ind fmtinfo x)
  | fmt_si_sub_ind_list (fmtinfo as {outf,...}: PP_FMT_INFO)
	(x::xs) = (
	fmt_si_sub_ind fmtinfo x; outf ","; fmt_si_sub_ind_list fmtinfo xs
);
=TEX
Subtype declarations:
=SML
fun €fmt_subtype_decl› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(d as {name=n, sub_ind=s} : CONSTRAINT SUBTYPE_DECL) = (
	check_decl n;
	outf (kw"SUBTYPE"); (fmt_id fmtinfo n); 
	outf (kw"IS"); (fmt_sub_ind fmtinfo s); outf ";"; outf "\n"
);

fun €fmt_si_subtype_decl› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(d as {name=n, type_def=s} : SI_SUBTYPE_DECL) = (
	check_decl n;
	outf (kw"SUBTYPE"); (fmt_id fmtinfo n); 
	outf (kw"IS"); (fmt_si_sub_ind fmtinfo s); outf ";"; outf "\n"
);
=TEX
Variable declarations.

(N.B. $fmt\_var\_decl\_list$ only used in record types, so we need 
not worry about initialisations).
=SML

fun €fmt_si_var_decl› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({vars=v, t=t} : SI_VAR_DECL) = (
	map check_decl v;
	(fmt_id_list fmtinfo v);
	outf ":";
	(fmt_si_sub_ind fmtinfo t);
	outf ";"; outf "\n"
) and fmt_si_var_decl_list (fmtinfo as {outf,...} : PP_FMT_INFO) ([] : SI_VAR_DECL list) = ()
  | fmt_si_var_decl_list (fmtinfo as {outf,...} : PP_FMT_INFO) (x::xs : SI_VAR_DECL list) =
    (fmt_si_var_decl fmtinfo x; fmt_si_var_decl_list fmtinfo xs);

fun €fmt_var_decl› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({vars=v, tmark=t} : VAR_DECL) = (
	map check_decl v;
	(fmt_id_list fmtinfo v);
	outf ":";
	(fmt_tmark fmtinfo t);
	outf ";"; outf "\n"
) and fmt_var_decl_list (fmtinfo as {outf,...} : PP_FMT_INFO) ([] : VAR_DECL list) = ()
  | fmt_var_decl_list (fmtinfo as {outf,...} : PP_FMT_INFO) (x::xs : VAR_DECL list) =
    (fmt_var_decl fmtinfo x; fmt_var_decl_list fmtinfo xs);
=TEX

Initialised variables.
=SML
fun €fmt_var_init_decl› (fmtinfo as {outf,...} : PP_FMT_INFO) 
		(({vars=v, tmark=t} : VAR_DECL), exp : EXP) = (
	map check_decl v;
	(fmt_id_list fmtinfo v);
	outf ":";
	(fmt_tmark fmtinfo t);
	outf ":=";
	(fmt_exp fmtinfo exp);
	outf ";"; outf "\n"
);

fun €fmt_si_var_init_decl› (fmtinfo as {outf,...} : PP_FMT_INFO) 
		(({vars=v, t=t} : SI_VAR_DECL), exp : EXP) = (
	map check_decl v;
	(fmt_id_list fmtinfo v);
	outf ":";
	(fmt_si_sub_ind fmtinfo t);
	outf ":=";
	(fmt_exp fmtinfo exp);
	outf ";"; outf "\n"
);
=TEX

Constant and deferred constant declarations.

=SML

fun €fmt_const_decl› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({consts=c, tm=t, expr=e} : EXP CONST_DECL) = (
    map check_decl c;
    (fmt_id_list fmtinfo c); outf (": " ^ kw"CONSTANT");
    (case t of Value tmark => fmt_tmark fmtinfo tmark | Nil => ()); outf ":=";
    (fmt_exp fmtinfo e); outf ";"; outf "\n"
);

fun €fmt_si_const_decl› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({consts=c, t=t, expr=e} : SI_CONST_DECL) = (
    map check_decl c;
    (fmt_id_list fmtinfo c); outf (": " ^ kw"CONSTANT");
    (case t of Value tmark => fmt_si_sub_ind fmtinfo tmark | Nil => ()); outf ":=";
    (fmt_exp fmtinfo e); outf ";"; outf "\n"
);

fun €fmt_deferred_const_decl› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({consts=c, tmark=t} : DEFERRED_CONST_DECL) = (
	map check_decl c;
	(fmt_id_list fmtinfo c); outf (kw": CONSTANT");
	(fmt_tmark fmtinfo t); outf ";"; outf "\n"
);
=TEX

Enumerated types.

=SML

fun €fmt_enum_type_def› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, {vals=v} : ENUM_TYPE_DEF) = (
    check_decl name;
	outf (kw"TYPE"); (fmt_id fmtinfo name);
	outf (kw"IS"); outf "("; (fmt_id_list fmtinfo v); outf ")"; outf ";"; outf "\n"
);
=TEX

Integer types.

=SML

fun €fmt_int_type_def› (fmtinfo as {outf,...} : PP_FMT_INFO) (name, r : EXP RANGE) = (
    check_decl name;
	outf (kw"TYPE"); (fmt_id fmtinfo name);
	outf (kw2"IS""RANGE"); (fmt_range fmtinfo r); outf ";"; outf "\n"
);
=TEX

Array types.

=SML

fun €fmt_array_def› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, {index=i, comp=c} : ARRAY_DEF) = (
    check_decl name;
	outf (kw"TYPE"); (fmt_id fmtinfo name);
	outf (kw2"IS""ARRAY"); outf "(";
	(fmt_tmark_list fmtinfo i);
	outf ")"; outf (kw"OF");
	(fmt_tmark fmtinfo c); outf ";"; outf "\n"
);

fun €fmt_si_array_def› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, {index=i, comp=c} : SI_ARRAY_DEF) = (
    check_decl name;
	outf (kw"TYPE"); (fmt_id fmtinfo name);
	outf (kw2"IS""ARRAY"); outf "(";
	(fmt_si_discrete_range_list fmtinfo i);
	outf ")"; outf (kw"OF");
	(fmt_si_sub_ind fmtinfo c); outf ";"; outf "\n"
);

fun €fmt_uncon_tmark_list› (fmtinfo : PP_FMT_INFO)
	([] : TMARK list) = ()
  | fmt_uncon_tmark_list(fmtinfo as {outf,...} : PP_FMT_INFO)
	([x]) = (fmt_tmark fmtinfo x; outf (kw"RANGE"^" <>"))
  | fmt_uncon_tmark_list (fmtinfo as {outf,...} : PP_FMT_INFO)
	(x::xs) = (
	fmt_uncon_tmark_list fmtinfo [x]; 
	outf ","; fmt_uncon_tmark_list fmtinfo xs);

fun €fmt_si_uncon_tmark_list› (fmtinfo : PP_FMT_INFO)
	([] : SI_DISCRETE_RANGE list) = ()
  | fmt_si_uncon_tmark_list(fmtinfo as {outf,...} : PP_FMT_INFO)
	([x]) = (fmt_si_discrete_range fmtinfo x; outf (kw"RANGE"^" <>"))
  | fmt_si_uncon_tmark_list (fmtinfo as {outf,...} : PP_FMT_INFO)
	(x::xs) = (
	fmt_si_uncon_tmark_list fmtinfo [x]; 
	outf ","; fmt_si_uncon_tmark_list fmtinfo xs);

fun €fmt_uncon_array_def› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, {index=i, comp=c} : ARRAY_DEF) = (
    check_decl name;
	outf (kw"TYPE"); (fmt_id fmtinfo name);
	outf (kw2"IS""ARRAY"); outf  "(";
	(fmt_uncon_tmark_list fmtinfo i);
	outf ")"; outf (kw"OF"); (fmt_tmark fmtinfo c); outf ";"; outf "\n"
);

fun €fmt_si_uncon_array_def› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, {index=i, comp=c} : SI_ARRAY_DEF) = (
    check_decl name;
	outf (kw"TYPE"); (fmt_id fmtinfo name);
	outf (kw2"IS""ARRAY"); outf  "(";
	(fmt_si_uncon_tmark_list fmtinfo i);
	outf ")"; outf (kw"OF"); (fmt_si_sub_ind fmtinfo c); outf ";"; outf "\n"
);

=TEX

Record types.

Note that the variable name clash rules do not apply here.
=SML

fun €fmt_record_type_def› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, {decl, disc} : RECORD_TYPE_DEF) = (
	check_decl name;
	let	val old_st = !stack;
		val res = (stack := [];
			outf (kw"TYPE"); 
			(fmt_id fmtinfo name);
			(case disc of
				[] => ()
			 |	_ => (
				outf "(";
				fmt_var_decl_list fmtinfo disc;
				outf ")"
			));
			outf (kw"IS");
			outf "\n";
			outf (kw"RECORD"); 
			outf "\n";
			inc_tabs();
			(fmt_var_decl_list fmtinfo decl);
			dec_tabs();
			outf (kw2"END""RECORD"^";");
			outf "\n");
	in	stack := old_st;
		res
	end
);

fun €fmt_si_record_type_def› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, {decl, disc} : SI_RECORD_TYPE_DEF) = (
	check_decl name;
	let	val old_st = !stack;
		val res = (stack := [];
			outf (kw"TYPE"); 
			(fmt_id fmtinfo name);
			(case disc of
				[] => ()
			 |	_ => (
				outf "(";
				fmt_var_decl_list fmtinfo disc;
				outf ")"
			));
			outf (kw"IS");
			outf "\n";
			outf (kw"RECORD"); 
			outf "\n";
			inc_tabs();
			(fmt_si_var_decl_list fmtinfo decl);
			dec_tabs();
			outf (kw2"END""RECORD"^";");
			outf "\n");
	in	stack := old_st;
		res
	end
);

=TEX

Type declarations.

=SML

fun €fmt_type_def› (fmtinfo : PP_FMT_INFO)
	(name, (TDEnumTypeDef x) : TYPE_DEF) =
    (fmt_enum_type_def fmtinfo (name, x))
  | fmt_type_def (fmtinfo : PP_FMT_INFO)
	(name, (TDIntTypeDef x)) =
    (fmt_int_type_def fmtinfo (name, x))
  | fmt_type_def (fmtinfo : PP_FMT_INFO)
	(name, (TDFloatingTypeDef x)) =
    (fmt_floating_type_def fmtinfo (name, x))
  | fmt_type_def (fmtinfo : PP_FMT_INFO)
	(name, (TDFixedTypeDef x)) =
    (fmt_fixed_type_def fmtinfo (name, x))
  | fmt_type_def (fmtinfo : PP_FMT_INFO)
	(name, (TDUnconArrayDef x)) =
    (fmt_uncon_array_def fmtinfo (name, x))
  | fmt_type_def (fmtinfo : PP_FMT_INFO)
	(name, (TDConArrayDef x)) =
    (fmt_array_def fmtinfo (name, x))
  | fmt_type_def (fmtinfo : PP_FMT_INFO) 
	(name, (TDRecordTypeDef x)) =
    (fmt_record_type_def fmtinfo (name, x))
and €fmt_type_decl› (fmtinfo : PP_FMT_INFO)
	({name=n, type_def=t} : TYPE_DEF TYPE_DECL) =
    (fmt_type_def fmtinfo (n, t));

fun €fmt_si_type_def› (fmtinfo : PP_FMT_INFO)
	(name, (SIEnumTypeDef x) : SI_TYPE_DEF) =
    (fmt_enum_type_def fmtinfo (name, x))
  | fmt_si_type_def (fmtinfo : PP_FMT_INFO)
	(name, (SIIntTypeDef x)) =
    (fmt_int_type_def fmtinfo (name, x))
  | fmt_si_type_def (fmtinfo : PP_FMT_INFO)
	(name, (SIFloatingTypeDef x)) =
    (fmt_floating_type_def fmtinfo (name, x))
  | fmt_si_type_def (fmtinfo : PP_FMT_INFO)
	(name, (SIFixedTypeDef x)) =
    (fmt_fixed_type_def fmtinfo (name, x))
  | fmt_si_type_def (fmtinfo : PP_FMT_INFO)
	(name, (SIUnconArrayDef x)) =
    (fmt_si_uncon_array_def fmtinfo (name, x))
  | fmt_si_type_def (fmtinfo : PP_FMT_INFO)
	(name, (SIConArrayDef x)) =
    (fmt_si_array_def fmtinfo (name, x))
  | fmt_si_type_def (fmtinfo : PP_FMT_INFO) 
	(name, (SIRecordTypeDef x)) =
    (fmt_si_record_type_def fmtinfo (name, x))
and €fmt_si_type_decl› (fmtinfo : PP_FMT_INFO)
	({name=n, type_def=t} : SI_TYPE_DECL) =
    (fmt_si_type_def fmtinfo (n, t));

=TEX

Private type declarations.

=SML

fun €fmt_private_type_decl› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({id=i, disc, limited=l} : PRIVATE_TYPE_DECL) = (
	check_decl i;
	outf (kw"TYPE"); fmt_id fmtinfo i;
	(case disc of
		[] => ()
	 |	_ => (
		outf "(";
		fmt_var_decl_list fmtinfo disc;
		outf ")"
	));
	outf (kw"IS"); 
	(if l then outf (kw"LIMITED") else ());
	outf (kw"PRIVATE"^";"); outf "\n"
);
=TEX

Basic declarations.

=SML

fun €fmt_basic_decl› (fmtinfo : PP_FMT_INFO)
	(BDConstDecl x : BASIC_DECL) =
    (fmt_const_decl fmtinfo x)
  | fmt_basic_decl (fmtinfo : PP_FMT_INFO)
	(BDDeferredConstDecl x) =
    (fmt_deferred_const_decl fmtinfo x)
  | fmt_basic_decl (fmtinfo : PP_FMT_INFO)
	(BDTypeDecl x) =
    (fmt_type_decl fmtinfo x)
  | fmt_basic_decl (fmtinfo : PP_FMT_INFO)
	(BDVarDecl x) =
    (fmt_var_decl fmtinfo x)
  | fmt_basic_decl (fmtinfo : PP_FMT_INFO)
	(BDVarDeclInit x) =
    (fmt_var_init_decl fmtinfo x)
  | fmt_basic_decl (fmtinfo : PP_FMT_INFO)
	(BDSubtypeDecl x) =
    (fmt_subtype_decl fmtinfo x)
  | fmt_basic_decl (fmtinfo : PP_FMT_INFO) 
	(BDPrivateTypeDecl x ) =
    (fmt_private_type_decl fmtinfo x)
  | fmt_basic_decl (fmtinfo : PP_FMT_INFO)
	(BDPragma x ) =
    (fmt_pragma fmtinfo x)
  | fmt_basic_decl (fmtinfo : PP_FMT_INFO)
	 (BDAnnotation x ) =
    (fmt_annotation fmtinfo x)
and €fmt_basic_decl_list› (fmtinfo : PP_FMT_INFO)
	([] : BASIC_DECL list) = ()
  | fmt_basic_decl_list (fmtinfo : PP_FMT_INFO)
	(x::xs) =
    (fmt_basic_decl fmtinfo x; fmt_basic_decl_list fmtinfo xs);

fun €fmt_si_basic_decl› (fmtinfo : PP_FMT_INFO)
	(SIConstDecl x : SI_BASIC_DECL) =
    (fmt_si_const_decl fmtinfo x)
  | fmt_si_basic_decl (fmtinfo : PP_FMT_INFO)
	(SIDeferredConstDecl x) =
    (fmt_deferred_const_decl fmtinfo x)
  | fmt_si_basic_decl (fmtinfo : PP_FMT_INFO)
	(SITypeDecl x) =
    (fmt_si_type_decl fmtinfo x)
  | fmt_si_basic_decl (fmtinfo : PP_FMT_INFO)
	(SIVarDecl x) =
    (fmt_si_var_decl fmtinfo x)
  | fmt_si_basic_decl (fmtinfo : PP_FMT_INFO)
	(SIVarDeclInit x) =
    (fmt_si_var_init_decl fmtinfo x)
  | fmt_si_basic_decl (fmtinfo : PP_FMT_INFO)
	(SISubtypeDecl x) =
    (fmt_si_subtype_decl fmtinfo x)
  | fmt_si_basic_decl (fmtinfo : PP_FMT_INFO) 
	(SIPrivateTypeDecl x ) =
    (fmt_private_type_decl fmtinfo x)
  | fmt_si_basic_decl (fmtinfo : PP_FMT_INFO)
	(SIPragma x ) =
    (fmt_pragma fmtinfo x)
  | fmt_si_basic_decl (fmtinfo : PP_FMT_INFO)
	 (SIAnnotation x ) =
    (fmt_annotation fmtinfo x)
and €fmt_si_basic_decl_list› (fmtinfo : PP_FMT_INFO)
	([] : SI_BASIC_DECL list) = ()
  | fmt_si_basic_decl_list (fmtinfo : PP_FMT_INFO)
	(x::xs) =
    (fmt_si_basic_decl fmtinfo x; fmt_si_basic_decl_list fmtinfo xs);

=TEX

\subsection{Procedure and Function specifications}

Procedure and Function parameter specifications.

=SML

fun €fmt_parameter_specification› (fmtinfo as {outf,...} : PP_FMT_INFO) ({idlist=i, mode=m, name=n} :
	PARAMETER_SPECIFICATION) = (
   map  check_decl i;
    (fmt_id_list fmtinfo i); outf ":"; (fmt_mode fmtinfo m); (fmt_tmark fmtinfo n)
);
fun €fmt_parameter_specification_list1› (fmtinfo : PP_FMT_INFO)
	([] : PARAMETER_SPECIFICATION list) = ()
  | fmt_parameter_specification_list1 (fmtinfo : PP_FMT_INFO)
	([x] : PARAMETER_SPECIFICATION list) =
    (fmt_parameter_specification fmtinfo x)
  | fmt_parameter_specification_list1 (fmtinfo as {outf,...} : PP_FMT_INFO)
		(x::xs : PARAMETER_SPECIFICATION list) = (
	(fmt_parameter_specification fmtinfo x);
	outf ";";
	(fmt_parameter_specification_list1 fmtinfo xs)
);
fun €fmt_parameter_specification_list› (fmtinfo : PP_FMT_INFO)
	([] : PARAMETER_SPECIFICATION list) = ()
  | fmt_parameter_specification_list (fmtinfo as {outf,...} : PP_FMT_INFO)
	(xs : PARAMETER_SPECIFICATION list) = (
	outf "("; fmt_parameter_specification_list1 fmtinfo xs; outf ")"
  );
=TEX

Procedure and Function specifications.

Note these do a $push\_scope$ which someone on the calling chain will need to pop.
This is needed because the name of the procedure or function is visible at this level and needs to be on the stack when a subprogram body is processed.
=SML

fun €fmt_procedure_specification› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, formal_part=f, spec=Value s, annotation=ann, globals=_} 
		: PROCEDURE_SPECIFICATION) = (
	check_decl n;
	push_scope n;
	(if is_expansion_selected fmtinfo
		then (
		outf (kw"PROCEDURE");
		(fmt_id fmtinfo n);
		(fmt_parameter_specification_list fmtinfo f);
		outf "\n";
		inc_tabs(); outf "-- Spec ..."; dec_tabs(); outf "\n"
	) else (
		outf (kw"PROCEDURE");
		(fmt_id fmtinfo n);
		(fmt_parameter_specification_list fmtinfo f);
		outf "\n";
		inc_tabs(); (fmt_spec fmtinfo s); dec_tabs(); outf "\n"
   	);
  	fmt_annotation fmtinfo ann)
)  | fmt_procedure_specification (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, formal_part=f, spec=Nil, annotation=ann, globals=_}
		: PROCEDURE_SPECIFICATION) = (
	check_decl n;
	push_scope n;
	outf (kw"PROCEDURE");
	(fmt_id fmtinfo n);
	(fmt_parameter_specification_list fmtinfo f);
	outf "\n";
	fmt_annotation fmtinfo ann
);
=TEX
=SML
fun €fmt_function_specification› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({designator=d, return=r, formal_part=f,
		spec=Value s, annotation=ann, globals=_}
			: FUNCTION_SPECIFICATION) = (
	check_decl d;
	push_scope d;
	(if is_expansion_selected fmtinfo
	then (
		outf (kw"FUNCTION");(fmt_id fmtinfo d);
		(fmt_parameter_specification_list fmtinfo f); 
		outf (kw"RETURN"); (fmt_tmark fmtinfo r);
		outf "\n";
		inc_tabs(); outf "-- Spec ..."; dec_tabs(); outf "\n"
	) else (
		outf (kw"FUNCTION");(fmt_id fmtinfo d);
		(fmt_parameter_specification_list fmtinfo f); 
		outf (kw"RETURN"); (fmt_tmark fmtinfo r); outf "\n";
		inc_tabs(); (fmt_spec fmtinfo s); dec_tabs(); outf "\n"
	);
	fmt_annotation fmtinfo ann
	)
)
  | fmt_function_specification (fmtinfo as {outf,...} : PP_FMT_INFO)
	({designator=d, return=r, formal_part=f,
		spec=Nil, annotation=ann, globals=_}
		: FUNCTION_SPECIFICATION) = (
	check_decl d;
	push_scope d;
	outf (kw"FUNCTION");(fmt_id fmtinfo d);
	(fmt_parameter_specification_list fmtinfo f); outf (kw"RETURN"); 
	(fmt_tmark fmtinfo r); outf "\n";
	fmt_annotation fmtinfo ann
);
=TEX

Subprograms.

Callers of this must pop the scope pushed by the support functions.
=SML

fun €fmt_subprogram_specification› (fmtinfo : PP_FMT_INFO)
	(SSProcedure x : SUBPROGRAM_SPECIFICATION) =
    (fmt_procedure_specification fmtinfo x)
  | €fmt_subprogram_specification› (fmtinfo : PP_FMT_INFO)
	(SSFunction x : SUBPROGRAM_SPECIFICATION) =
    (fmt_function_specification fmtinfo x);

=TEX

Renaming declarations.

=SML
fun €fmt_object_renaming› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({new_name, tmark, old_name} : OBJECT_RENAMING) = (
	in_new_scope false new_name (fn () => (
	fmt_id fmtinfo new_name;
	(fmt_tmark fmtinfo tmark);
	outf (kw"RENAMES");
	fmt_id fmtinfo old_name; 
	outf ";"; outf "\n"
	))
);

fun €fmt_package_renaming› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({new_name, old_name} : PACKAGE_RENAMING) = (
	in_new_scope false new_name (fn () => (
	outf (kw"PACKAGE");
	fmt_id fmtinfo new_name;
	outf (kw"RENAMES");
	fmt_id fmtinfo old_name; 
	outf ";"; outf "\n"
	))
);

fun €fmt_opsym_renaming› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({new_name, formal_part, tmark, name1, name2} : OPSYM_RENAMING) = (
let	val nn = case new_name of Nil => name2 | Value nn => nn;
in
	in_new_scope false nn (fn () => (
	outf (kw"FUNCTION"); 
	(case new_name of
		Nil => outf (sfmt_operator_symbol fmtinfo nn)
	|	Value _ => fmt_id fmtinfo nn);
	(fmt_parameter_specification_list fmtinfo formal_part); 
	outf (kw"RETURN"); 
	(fmt_tmark fmtinfo tmark);
	outf (kw"RENAMES");
	fmt_id fmtinfo name1; outf "."; outf(sfmt_operator_symbol fmtinfo name2); 
	outf ";"; outf "\n"
	))
end
);

fun €fmt_subprogram_renaming› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({subprogram_specification=s, name1=n1, name2=n2} :
	SUBPROGRAM_RENAMING) = (
	let	val res = (
		(fmt_subprogram_specification fmtinfo s);
		inc_tabs ();
			outf (kw"RENAMES");
			(case n1 of
				Nil => ()
			|	Value n => (
				fmt_id fmtinfo n; outf "."
			)); outf (sfmt_id_plus fmtinfo n2 "");
			outf ";"; outf "\n";
		dec_tabs());
	in	pop_scope(); res
	end
);

fun €fmt_renaming_declaration› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(RDObject x : RENAMING_DECLARATION) = (
	fmt_object_renaming fmtinfo x
) | fmt_renaming_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(RDPackage x) = (
	fmt_package_renaming fmtinfo x
) | fmt_renaming_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(RDOpsym x) = (
	fmt_opsym_renaming fmtinfo x
) | fmt_renaming_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(RDSubprogram x) = (
	fmt_subprogram_renaming fmtinfo x
);

=TEX

Representation clauses.

=SML

fun €fmt_component_clause› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, exp=e, range=r} : COMPONENT_CLAUSE) = (
	(fmt_id fmtinfo n);
	outf (kw(kw"AT"));
	(fmt_exp fmtinfo e); outf (kw"RANGE");
	(fmt_range fmtinfo r); outf ";"; outf "\n"
);

fun €fmt_component_clause_list› (fmtinfo : PP_FMT_INFO)
	([] : COMPONENT_CLAUSE list) = ()
  | fmt_component_clause_list (fmtinfo : PP_FMT_INFO)
	(x::xs : COMPONENT_CLAUSE list) =
    (fmt_component_clause fmtinfo x; fmt_component_clause_list fmtinfo xs);

fun €fmt_length_clause› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({attribute=a, exp=e} : LENGTH_CLAUSE) = (
	outf (kw"FOR"); (fmt_exp fmtinfo a);
	outf (kw"USE"); (fmt_exp fmtinfo e); outf ";"; outf "\n"
);
fun €fmt_enumeration_representation_clause› (fmtinfo as {outf,...} : PP_FMT_INFO)
    ({name=n, exp=e} : ENUMERATION_REPRESENTATION_CLAUSE) = (
	outf (kw"FOR"); (fmt_id fmtinfo n); outf (kw"USE"); 
	(fmt_exp fmtinfo e); outf ";"; outf "\n"
);
fun €fmt_record_representation_clause› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, alignment_opt=Value a,  component_pack=c} :
	RECORD_REPRESENTATION_CLAUSE) = (
	outf (kw"FOR"); (fmt_id fmtinfo n); outf (kw"USE"); outf "\n";
	inc_tabs();
		outf (kw3 "RECORD" "AT" "MOD"); (fmt_exp fmtinfo a); 
		outf ";"; outf "\n";
		(fmt_component_clause_list fmtinfo c);
		outf (kw2 "END" "RECORD;");
	dec_tabs(); outf "\n"
 ) | fmt_record_representation_clause (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, alignment_opt=Nil, component_pack=c} :
	RECORD_REPRESENTATION_CLAUSE) = (
	outf (kw"FOR"); (fmt_id fmtinfo n); outf (kw"USE"); outf "\n"; 
	inc_tabs();
		outf (kw"RECORD"); outf "\n";
		(fmt_component_clause_list fmtinfo c);
		outf (kw2"END""RECORD"^";");
	dec_tabs();
	outf "\n"
);

fun €fmt_address_clause› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, exp=e} : ADDRESS_CLAUSE) = (
	outf (kw"FOR"); (fmt_id fmtinfo n);
	outf (" " ^ kw2 "USE""AT"); 
	(fmt_exp fmtinfo e); outf ";"; outf "\n"
);

fun €fmt_representation_clause› (fmtinfo : PP_FMT_INFO)
	(RCLength x : REPRESENTATION_CLAUSE) =
    (fmt_length_clause fmtinfo x)
  | fmt_representation_clause (fmtinfo : PP_FMT_INFO)
	(RCEnumeration x : REPRESENTATION_CLAUSE) =
    (fmt_enumeration_representation_clause fmtinfo x)
  | fmt_representation_clause (fmtinfo : PP_FMT_INFO)
	(RCRecord x : REPRESENTATION_CLAUSE) =
    (fmt_record_representation_clause fmtinfo x)
  | fmt_representation_clause (fmtinfo : PP_FMT_INFO)
	(RCAddress x : REPRESENTATION_CLAUSE) =
    (fmt_address_clause fmtinfo x);
=TEX

Use clauses.

=SML
fun €fmt_use_clause› (fmtinfo as {outf, ...} : PP_FMT_INFO) (UCUse ids : USE_CLAUSE) = (
	outf (kw"USE"); fmt_id_list fmtinfo ids; outf ";"; outf "\n"
) | fmt_use_clause (fmtinfo as {outf, ...}) (UCUseType ids : USE_CLAUSE) = (
	outf (kw2"USE""TYPE"); fmt_id_list fmtinfo ids; outf ";"; outf "\n"
);
=TEX

Subprogram declarations.

=SML
fun €fmt_procedure_declaration› (fmtinfo as {outf, fmt_repl} : PP_FMT_INFO)
	({name=n, formal_part=f, spec=Value s, annotation=ann, globals=_}
		: PROCEDURE_DECLARATION) =
    in_new_scope true n (fn () =>
    (case fmt_repl of
    Value _ =>  (
	outf (kw"PROCEDURE"); 
	(fmt_id fmtinfo n);
	(fmt_parameter_specification_list fmtinfo f); outf ";"; outf "\n";
	inc_tabs(); outf "-- Spec ..."; outf "\n"; dec_tabs()
    ) | Nil => (
	outf (kw"PROCEDURE"); 
	(fmt_id fmtinfo n);
	(fmt_parameter_specification_list fmtinfo f); outf "\n";
	inc_tabs(); (fmt_spec fmtinfo s); outf ";"; 
	outf "\n"; dec_tabs()
    );
    fmt_annotation fmtinfo ann
    )
)
  | fmt_procedure_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, formal_part=f, spec=Nil, annotation=ann, globals=_}
		: PROCEDURE_DECLARATION) =
    in_new_scope true n (fn () => (
	outf (kw"PROCEDURE"); (fmt_id fmtinfo n);
	(fmt_parameter_specification_list fmtinfo f); 
	outf ";"; outf "\n";
	fmt_annotation fmtinfo ann
   )
);

fun €fmt_function_declaration› (fmtinfo as {outf, fmt_repl} : PP_FMT_INFO)
	({designator=d, return=r, formal_part=f,
		spec=Value s, annotation=ann,globals=_}
		: FUNCTION_DECLARATION) =
    in_new_scope true d (fn () =>
    (case fmt_repl of
    Value _ => (
	outf (kw"FUNCTION");(fmt_id fmtinfo d);
	(fmt_parameter_specification_list fmtinfo f); outf (kw"RETURN");
	(fmt_tmark fmtinfo r); outf ";"; outf "\n";
	inc_tabs(); outf "-- Spec ..."; dec_tabs(); outf "\n"
    ) | Nil => (
	outf (kw"FUNCTION");(fmt_id fmtinfo d);
	(fmt_parameter_specification_list fmtinfo f); 
	outf (kw"RETURN"); (fmt_tmark fmtinfo r); outf "\n";
	inc_tabs(); (fmt_spec fmtinfo s); outf ";"; outf "\n";
	dec_tabs()
    );
    fmt_annotation fmtinfo ann
    )
)  | fmt_function_declaration  (fmtinfo as {outf,...} : PP_FMT_INFO)
	({designator=d, return=r, formal_part=f,
		spec=Nil, annotation=ann, globals=_} :
	FUNCTION_DECLARATION) = (
    in_new_scope true d (fn () => (
	outf (kw"FUNCTION");(fmt_id fmtinfo d);
	(fmt_parameter_specification_list fmtinfo f); outf (kw"RETURN"); 
	(fmt_tmark fmtinfo r); outf ";"; outf "\n";
	fmt_annotation fmtinfo ann
    ))
);

fun €fmt_procedure_stub› (fmtinfo as {outf, fmt_repl} : PP_FMT_INFO)
	(x as {spec, name, formal_part, ...} : PROCEDURE_DECLARATION) =
    in_new_scope true name (fn () =>
    case spec of
    Nil => (
	outf (kw"PROCEDURE"); (fmt_id fmtinfo name);
	(fmt_parameter_specification_list fmtinfo formal_part);
	outf (kw2"IS""SEPARATE"^";"); outf "\n"
    ) | Value s => (
	case fmt_repl of
	Value _ => (
		outf (kw"PROCEDURE"); (fmt_id fmtinfo name);
		(fmt_parameter_specification_list fmtinfo formal_part);
		outf "\n";
		outf "-- Spec ..."; outf "\n";
		outf (kw2"IS""SEPARATE"^";"); outf "\n"
	) | Nil =>  (
		outf (kw"PROCEDURE"); (fmt_id fmtinfo name);
	(fmt_parameter_specification_list fmtinfo formal_part);
		outf "\n";
		fmt_spec fmtinfo s; outf "\n";
		outf (kw2"IS""SEPARATE"^";"); outf "\n"
	))
);

fun €fmt_function_stub› (fmtinfo as {outf, fmt_repl} : PP_FMT_INFO)
	(x as {spec, designator, formal_part, return, ...}
			: FUNCTION_DECLARATION) = (
    in_new_scope true designator (fn () =>
    case spec of
    Nil => (
	    outf (kw"FUNCTION");(fmt_id fmtinfo designator);
		(fmt_parameter_specification_list fmtinfo formal_part);
		outf (kw"RETURN"); 
	(fmt_tmark fmtinfo return); outf "\n"; 
		outf (kw2"IS""SEPARATE"^";"); outf "\n"
    ) | Value s => (
	case fmt_repl of 
	Value _ => (
	    outf (kw"FUNCTION");(fmt_id fmtinfo designator);
		(fmt_parameter_specification_list fmtinfo formal_part); 
		outf (kw"RETURN"); 
		(fmt_tmark fmtinfo return); outf "\n";
		outf "-- Spec ..."; outf "\n";
		outf (kw2"IS""SEPARATE"^";"); outf "\n"
	) | Nil => (
	    outf (kw"FUNCTION");(fmt_id fmtinfo designator);
		(fmt_parameter_specification_list fmtinfo formal_part); 
		outf (kw"RETURN"); 
		(fmt_tmark fmtinfo return); outf "\n";
		fmt_spec fmtinfo s; outf "\n";
		outf (kw2"IS""SEPARATE"^";"); outf "\n"
	)
    ))
);
fun €fmt_package_stub› (fmtinfo as {outf,...} : PP_FMT_INFO) (n : ID) = (
	outf (kw2"PACKAGE""BODY");
	(fmt_id fmtinfo n); outf (kw2"IS""SEPARATE"^";");
	outf "\n"
);
fun €fmt_auxiliary› (fmtinfo as {outf, fmt_repl} : PP_FMT_INFO) (av : AUX_VAR) =
    (case fmt_repl of
    Value _ => (outf "-- AUXILIARY ... ;"; outf "\n")
    | Nil => (
	outf "-- AUXILIARY"; (fmt_z_id fmtinfo (#aux av));
	outf" ;"; outf "\n"
    )
);
fun €fmt_using› (fmtinfo as {outf, fmt_repl} : PP_FMT_INFO) (u : SI_USING_DEC) =
    (case fmt_repl of
    Value _ => (
	outf  "-- USING ..."; outf "\n";
	fmt_si_basic_decl_list fmtinfo (#basic_decls u); outf "\n";
	outf "-- IMPLEMENT ... BY ... ;"; outf "\n"
    ) | Nil => (
	outf (kw"USING"); outf "\n";
	(fmt_si_basic_decl_list fmtinfo (#basic_decls u));
	outf (kw"IMPLEMENT"); (fmt_z_tm fmtinfo (#aux u));
	outf (kw"BY"); (fmt_z_tm fmtinfo (#invariant u));
	outf " ;"; outf "\n"
    ));

fun €fmt_package_declaration›
	(fmt_decls : PP_FMT_INFO -> DECLARATION list -> unit)
	(fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, visible_decs=v, private_decs=p, annotation=ann} :
    DECLARATION PACKAGE_DECLARATION) = (
    in_new_scope true n (fn () => (
	outf (kw"PACKAGE"); fmt_id fmtinfo n; outf "\n";
	fmt_annotation fmtinfo ann;
	outf (kw"IS"); outf "\n";
	(inc_tabs();
		fmt_decls fmtinfo v;
	dec_tabs())));
    in_new_scope false n (fn () => (
    	(case p
	of [] => ()
	| _ => (outf (kw"PRIVATE"); outf "\n";
		inc_tabs();
		fmt_decls fmtinfo p;
		dec_tabs())
		);
        outf (kw"END"); (fmt_id fmtinfo n); outf ";"; outf "\n"
    ))
   );
=TEX
=SML
fun €fmt_procedure_body›
	(fmt_decls : PP_FMT_INFO -> DECLARATION list -> unit)
	(fmtinfo as {outf,...} : PP_FMT_INFO)
	({procedure_spec=p, declarative_part=d, statement=s} :
	DECLARATION PROCEDURE_BODY) = (
    do_soundness_checks2 get_replacement false s
    handle Fail msg => log_soundness_check_result msg;
	let val res = (fmt_procedure_specification fmtinfo p;
			outf (kw"IS"); outf "\n";
			(inc_tabs();
				fmt_decls fmtinfo d;
			dec_tabs());
			outf (kw"BEGIN"); outf "\n";
			(inc_tabs();
				fmt_statement fmtinfo s;
			dec_tabs());
			outf (kw"END");
			(fmt_id fmtinfo (#name p)); outf ";"; outf "\n");
	in	pop_scope (); res
	end
);

fun €fmt_function_body›
	(fmt_decls : PP_FMT_INFO -> DECLARATION list -> unit)
	(fmtinfo as {outf,...} : PP_FMT_INFO)
	({function_spec=f, declarative_part=d, statement=s} :
	DECLARATION FUNCTION_BODY) = (
    do_soundness_checks2 get_replacement true s
    handle Fail msg => log_soundness_check_result msg;
	let val res = (fmt_function_specification fmtinfo f;
			outf (kw"IS"); outf "\n";
			(inc_tabs(); 
				fmt_decls fmtinfo d;
			dec_tabs());
			outf (kw"BEGIN"); outf "\n";
			(inc_tabs();fmt_statement fmtinfo s; dec_tabs());
			outf (kw"END"); (fmt_id fmtinfo (#designator f));
			outf ";"; outf "\n");
	in	pop_scope(); res
	end
);
fun €fmt_package_body›
	(fmt_decls : PP_FMT_INFO -> DECLARATION list -> unit)
	(fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, decls=d, statement=s, annotation=ann}
		: DECLARATION PACKAGE_BODY) = (
    in_new_scope true n (fn () => (
    do_soundness_checks2 get_replacement false s
    handle Fail msg => log_soundness_check_result msg;
    outf (kw2"PACKAGE""BODY"); fmt_id fmtinfo n; outf "\n";
    fmt_annotation fmtinfo ann;
    (outf (kw"IS"); outf "\n");
    inc_tabs(); fmt_decls  fmtinfo d; dec_tabs();
    (case s
    of STImplicitNull => ()
    | _ => (outf (kw"BEGIN"); outf "\n"; 
	inc_tabs();fmt_statement fmtinfo s; dec_tabs())
    );
    outf (kw"END"); (fmt_id fmtinfo n); outf ";"; outf "\n")
));

fun €fmt_proper_body›
	(fmt_decls : PP_FMT_INFO -> DECLARATION list -> unit)
	(fmtinfo : PP_FMT_INFO) (PBProcedure x : PROPER_BODY) =
    (fmt_procedure_body fmt_decls fmtinfo x)
  | fmt_proper_body fmt_decls
	(fmtinfo : PP_FMT_INFO) (PBFunction x : PROPER_BODY) =
    (fmt_function_body fmt_decls fmtinfo x)
  | fmt_proper_body fmt_decls
	(fmtinfo : PP_FMT_INFO) (PBPackage x : PROPER_BODY) =
    (fmt_package_body fmt_decls fmtinfo x);

=TEX

Compilation subunits.

=SML

fun €fmt_compilation_subunit›
	(fmt_decls : PP_FMT_INFO -> DECLARATION list -> unit)
	(fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, proper_body=p} : COMP_SUBUNIT) = (
	outf (kw"SEPARATE"); outf "(";
	(fmt_id fmtinfo n); outf")"; outf "\n";
	(inc_tabs(); fmt_proper_body fmt_decls fmtinfo p; dec_tabs())
);

fun €fmt_declaration› (fmtinfo : PP_FMT_INFO)
	(DDeclarationKSlot (x, _) : DECLARATION) =
    (fmt_k_slot fmtinfo x)
  | fmt_declaration (fmtinfo : PP_FMT_INFO)
	(DRenamingDeclaration x : DECLARATION) =
    (fmt_renaming_declaration fmtinfo x)
  | fmt_declaration (fmtinfo : PP_FMT_INFO)
	(DBasicDecl x : DECLARATION) =
    (fmt_si_basic_decl fmtinfo x)
  | fmt_declaration (fmtinfo : PP_FMT_INFO)
	(DRepresentationClause x : DECLARATION) =
    (fmt_representation_clause fmtinfo x)
  | fmt_declaration (fmtinfo : PP_FMT_INFO)
	(DUseClause x : DECLARATION) =
    (fmt_use_clause fmtinfo x)
  | fmt_declaration (fmtinfo : PP_FMT_INFO)
	(DProperBody x : DECLARATION) =
    (fmt_proper_body fmt_declaration_list fmtinfo x)
  | fmt_declaration (fmtinfo : PP_FMT_INFO)
	(DProcedureDeclaration x : DECLARATION) =
    (fmt_procedure_declaration fmtinfo x)
  | fmt_declaration (fmtinfo : PP_FMT_INFO)
	(DFunctionDeclaration x : DECLARATION) =
    (fmt_function_declaration fmtinfo x)
  | fmt_declaration (fmtinfo : PP_FMT_INFO)
	(DPackageDeclaration x : DECLARATION) =
    (fmt_package_declaration fmt_declaration_list fmtinfo x)
  | fmt_declaration (fmtinfo : PP_FMT_INFO)
	(DProcedureStub x : DECLARATION) =
    (fmt_procedure_stub fmtinfo x)
  | fmt_declaration (fmtinfo : PP_FMT_INFO)
	(DFunctionStub x : DECLARATION) =
    (fmt_function_stub fmtinfo x)
  | fmt_declaration (fmtinfo : PP_FMT_INFO)
	(DPackageStub x : DECLARATION) =
    (fmt_package_stub fmtinfo x)
  | fmt_declaration (fmtinfo : PP_FMT_INFO)
	(DExternalProcedureStub x : DECLARATION) =
    (fmt_procedure_declaration fmtinfo x)
  | fmt_declaration (fmtinfo : PP_FMT_INFO)
	(DExternalFunctionStub x : DECLARATION) =
    (fmt_function_declaration fmtinfo x)
  | fmt_declaration (fmtinfo : PP_FMT_INFO)
	(DAuxiliary x : DECLARATION) =
    (fmt_auxiliary fmtinfo x)
  | fmt_declaration (fmtinfo : PP_FMT_INFO)
	(DUsing x : DECLARATION) =
    (fmt_using fmtinfo x)
and €fmt_declaration_list› (fmtinfo : PP_FMT_INFO)
	(decls : DECLARATION list) = (
	map (fmt_declaration fmtinfo) decls; ()
);

=TEX

Compilation units.

=SML

fun €fmt_context_item› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(CIWith x : CONTEXT_ITEM) = (
	outf (kw"WITH"); fmt_id_list fmtinfo x; outf ";"; outf "\n"
) | fmt_context_item fmtinfo (CIUse uc) = (
	fmt_use_clause fmtinfo uc
) | fmt_context_item fmtinfo (CIPragma p) = (
	fmt_pragma fmtinfo p
);

fun €fmt_compilation_unit› (fmtinfo : PP_FMT_INFO)
	(CUPackageDeclaration x : COMPILATION_UNIT) =
    (fmt_package_declaration fmt_declaration_list fmtinfo x)
  | fmt_compilation_unit (fmtinfo : PP_FMT_INFO)
	(CUProperBody x : COMPILATION_UNIT) =
    (fmt_proper_body fmt_declaration_list fmtinfo x)
  | fmt_compilation_unit (fmtinfo : PP_FMT_INFO)
	(CUSubUnit x : COMPILATION_UNIT) =
    (fmt_compilation_subunit fmt_declaration_list fmtinfo x);

(*
=TEX
Note that the references clause, if any, does not get put in the Ada document.
=SML
*)
fun €fmt_context_compilation_unit› (fmtinfo : PP_FMT_INFO)
	({context=cil, references=r, comp_unit=c, annotation=ann}
		: CONTEXT_COMPILATION_UNIT) = (
	map (fmt_context_item fmtinfo) cil;
	fmt_annotation fmtinfo ann;
	fmt_compilation_unit fmtinfo c 
);

fun €fmt_kslot_compilation_unit› (fmtinfo : PP_FMT_INFO)
	(KCUKSlot x : KSLOT_COMPILATION_UNIT) =
    (fmt_k_slot fmtinfo x)
  | fmt_kslot_compilation_unit (fmtinfo : PP_FMT_INFO)
	(KCUUnit x : KSLOT_COMPILATION_UNIT) =
    (fmt_context_compilation_unit fmtinfo x)
  | fmt_kslot_compilation_unit (fmtinfo : PP_FMT_INFO)
	(KCUPragma x : KSLOT_COMPILATION_UNIT) =
    (fmt_pragma fmtinfo x);

fun €fmt_kslot_compilation_unit_list› (fmtinfo : PP_FMT_INFO)
    ([] : KSLOT_COMPILATION_UNIT list) = ()
  | fmt_kslot_compilation_unit_list (fmtinfo as {outf,...} : PP_FMT_INFO)
    (x::xs : KSLOT_COMPILATION_UNIT list) =
    (fmt_kslot_compilation_unit fmtinfo x;
    outf "\n"; outf "\n";
    fmt_kslot_compilation_unit_list fmtinfo xs);

=TEX

=SML

fun €fmt_replaced_by_comp› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({label=l, comp=c} : REPLACED_BY_COMP) =
    (fmt_label fmtinfo l; outf (translate_for_output "È"); outf "\n";
    inc_tabs();  
	fmt_kslot_compilation_unit_list fmtinfo c;
    dec_tabs());
fun €fmt_replaced_by_private_part› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({label=l, private=p} : REPLACED_BY_PRIVATE_PART) =
    (fmt_label fmtinfo l; outf (translate_for_output "È"); outf "\n";
	inc_tabs();
		fmt_declaration_list fmtinfo p;
	dec_tabs());
fun €fmt_replaced_by_visible_part› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({label=l, visible=v} : REPLACED_BY_VISIBLE_PART) =
    (fmt_label fmtinfo l; outf (translate_for_output "È"); outf "\n";
	inc_tabs(); fmt_declaration_list fmtinfo v; dec_tabs());
fun €fmt_replaced_by_decl› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({label=l, decls=d} : REPLACED_BY_DECL) =
    (fmt_label fmtinfo l; outf (translate_for_output "È"); outf "\n";
	inc_tabs(); fmt_declaration_list  fmtinfo d; dec_tabs());
fun €fmt_refined_by› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({label=l, statement=s} : REFINED_BY) =
	(fmt_label fmtinfo l; outf (translate_for_output "√");
	outf "\n"; inc_tabs();fmt_statement fmtinfo s; dec_tabs());
fun €fmt_replaced_by› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({label=l, statement=s} : REFINED_BY) =
    (fmt_label fmtinfo l; outf (translate_for_output "!√"); outf "\n";
	inc_tabs();fmt_statement fmtinfo s; dec_tabs());
fun €fmt_replaced_by_annotation› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({label=l, replacement=a} : REPLACED_BY_ANNOTATION) =
    (fmt_label fmtinfo l; outf (translate_for_output "È"); outf "\n";
	inc_tabs(); fmt_annotation fmtinfo a; dec_tabs());

=TEX

Web Clauses.

=SML

fun €fmt_web_clause› (fmtinfo : PP_FMT_INFO)
	(WCCompilation x : WEB_CLAUSE) =
    (fmt_kslot_compilation_unit_list fmtinfo x)
  | fmt_web_clause (fmtinfo : PP_FMT_INFO)
	(WCReplacedByCompilation x : WEB_CLAUSE) =
    (fmt_replaced_by_comp fmtinfo x)
  | fmt_web_clause (fmtinfo : PP_FMT_INFO)
	(WCReplacedByPrivatePart x : WEB_CLAUSE) =
    (fmt_replaced_by_private_part fmtinfo x)
  | fmt_web_clause (fmtinfo : PP_FMT_INFO)
	(WCReplacedByVisiblePart x : WEB_CLAUSE) =
    (fmt_replaced_by_visible_part fmtinfo x)
  | fmt_web_clause (fmtinfo : PP_FMT_INFO)
	(WCReplacedByDecl x : WEB_CLAUSE) =
    (fmt_replaced_by_decl fmtinfo x)
  | fmt_web_clause (fmtinfo : PP_FMT_INFO)
	(WCReplacedByArbitraryAda x : WEB_CLAUSE) =
    (fmt_replaced_by_arbitrary_ada fmtinfo x)
  | fmt_web_clause (fmtinfo : PP_FMT_INFO)
	(WCRefinedBy x : WEB_CLAUSE) =
    (fmt_refined_by fmtinfo x)
  | fmt_web_clause (fmtinfo : PP_FMT_INFO)
	(WCReplacedBy x : WEB_CLAUSE) =
    (fmt_replaced_by fmtinfo x)
  | fmt_web_clause (fmtinfo : PP_FMT_INFO)
	(WCReplacedByAnnotation x : WEB_CLAUSE) =
    (fmt_replaced_by_annotation fmtinfo x);

=TEX

\section{PRINTING AND OUTPUTTING SPARK}
=SML
val dummy1 = (let
	val lcontrol : int ref = ref 80;
in
(new_int_control{name="cn_automatic_line_splitting",
	control=lcontrol,
	default = (fn () => 80),
	check = (fn (x:int) => 0 <= x)}
handle (Fail _) => () (* assume control already present *)
)
end);
=TEX
=SML

fun €make_output_fun› (outs : outstream) : string -> unit = (
reset_tabs();
let  val max_line_len = get_int_control("cn_automatic_line_splitting");
    val diag_fragment: string -> unit =  (
	fn s => output(outs, s)
    );
    val curr_line_length : int ref = ref 0;
    val skipspace : bool ref = ref false;
    fun out_fun (s : string) : unit = (
	if (s = "\n")
	then (
		skipspace := false;
		curr_line_length := 0;
		diag_fragment("\n");
		()
	) else (
		let val len_s = size(s);
		in
			if ((!curr_line_length) = 0) 
			then (  skipspace := false; 
				let	val tab_s = fmt_tabs(get_PPTab_no());
					val len_tab_s = size(tab_s);
				in
				(diag_fragment(tab_s);
				    diag_fragment(s);
				    curr_line_length := len_tab_s + len_s;
				    ())
				end
			) else (
				if ((max_line_len > 0) andalso 
				    (len_s + (!curr_line_length) >= max_line_len))
				then ( diag_fragment("\n");
					curr_line_length := 0;
					skipspace := false;
					out_fun(s);
				    ()
				) else (
					if (s = ";" orelse s = "," orelse s = ")" 
						orelse s = "." orelse s = "'" orelse s = ".."
						orelse !skipspace)
					then ()
					else (diag_fragment(" ");
						curr_line_length := (!curr_line_length) + 1; ());
					diag_fragment(s);
					if (s = "'" orelse s = "(" orelse s = "." orelse s = "..")
					then skipspace := true
					else skipspace := false;
					curr_line_length := (!curr_line_length) + len_s;
					()
				)
			)
		end
	));
in
   (out_fun)
end);
=IGN
set_int_control("cn_automatic_line_splitting", 40);
val outf = make_output_fun(std_out);
(outf "\n"; outf "12345"; inc_tabs(); outf "12345";outf "12345";outf "12345";outf "12345";
outf "12345";outf "12345";outf "12345";outf "12345";outf "12345";
outf "12345";outf "12345";outf "12345";outf "12345";
outf "12345";outf "12345";outf "12345";outf "12345";outf "12345";
outf "12345";outf "12345";outf "12345";inc_tabs(); outf "12345";outf "12345";
outf "12345";outf "12345";outf "12345";outf "\n");
=SML
fun €mk_fmt_repl›
	(outf : string -> unit)
	(repl_fun : LABEL -> REPLACEMENT OPT)
	: LABEL -> bool = (fn label =>
let    val fmtinfo = {outf = outf, fmt_repl = Value(mk_fmt_repl outf repl_fun)};
in
    case repl_fun label of
    Value repl => (
	case repl of
	       ReplaceComp {comp, ...} => (    
		fmt_kslot_compilation_unit_list fmtinfo comp; true
	) |    ReplacePPart {private, ...} => (
		fmt_declaration_list fmtinfo private; true
	) |    ReplaceVPart {visible, ...} => (
		fmt_declaration_list fmtinfo visible; true
	) |    ReplaceDecl {decls, ...} => (
		fmt_declaration_list fmtinfo decls; true
	) |    RefineStat {statement, ...}    => (
		fmt_statement fmtinfo statement; true
	) |    ReplaceStat {statement, ...}    => (
		fmt_statement fmtinfo statement; true
	) |    ReplaceArbitrary {replacement, ...} => (
		(let val tabs = get_tabs();
		in
			(reset_tabs();
			outf (translate_for_output replacement);
			outf "\n";
			set_tabs (tabs)
			)
		end); true
	) |    ReplaceAnnotation {replacement, ...} => (
		fmt_annotation fmtinfo replacement; true
	) |    UnReplaced (RSCompilation, s) => (
	    outf ("-- unexpanded compilation k-slot: " ^
			 translate_for_output label);
		outf "\n"; false
	) |    UnReplaced (RSSpecStatement, s) => (
	    outf (kw"NULL" ^ "; -- unexpanded specification statement: " ^
			 translate_for_output label);
		outf "\n"; false
	) |    UnReplaced (RSStatement, s) => (
	    outf (kw"NULL" ^ "; -- unexpanded statement k-slot: " ^
			 translate_for_output label);
		outf "\n"; false	
	) |    UnReplaced (RSDeclaration, s) => (
	    outf ("-- unexpanded declaration k-slot " ^
			 translate_for_output label);
		outf "\n"; false
	) |    UnReplaced (RSPrivatePart, s) => (
	    outf ("-- unexpanded private part k-slot " ^
			 translate_for_output label);
		outf "\n"; false
	) |    UnReplaced (RSVisiblePart, s) => (
	    outf ("-- unexpanded visible part k-slot " ^
			 translate_for_output label);
		outf "\n"; false
	) |    UnReplaced (RSAnnotation, s) => (
	    outf ("-- unexpanded annotation k-slot " ^
			 translate_for_output label);
		outf "\n"; false
	)
    ) |    Nil =>    (
		outf ("-- Unrecognised label: " ^
			 translate_for_output label);
		outf "\n"; false
	)  
end);
=TEX
=SML
fun €mk_fmt_info›
	(outf : string -> unit)
	(Value repl_fun : (LABEL -> REPLACEMENT OPT) OPT)
	: PP_FMT_INFO = (
	{outf = outf,
	 fmt_repl = Value(mk_fmt_repl outf repl_fun)}
) | mk_fmt_info outf Nil = {outf = outf, fmt_repl = Nil};
=TEX
=SML
fun €format_web_clause› (repl_fun : (LABEL -> REPLACEMENT OPT) OPT) 
	(x : WEB_CLAUSE) : unit = (
let	val outf = make_output_fun std_out;
	val fmt_info = mk_fmt_info outf repl_fun
in
	(
	reset_tabs();
	fmt_web_clause fmt_info x;
	reset_tabs())
end);

val €print_web_clause› : WEB_CLAUSE -> unit = (
    format_web_clause Nil
);

fun €print_spark_program› (() : unit) : unit = with_soundness_checks (fn () =>
   ( format_web_clause (Value get_replacement)
    (WCCompilation (#spark_prog (get_z_generator_state()))))
);

fun €output_spark_program› ({out_file : string}) = with_soundness_checks (fn () =>
let	val stream = open_out out_file;
	val outf = make_output_fun stream;
	val fmt_info = mk_fmt_info outf (Value get_replacement)
    val x = (WCCompilation (#spark_prog (get_z_generator_state())));
in
	(
	reset_tabs();
	fmt_web_clause fmt_info x;
	reset_tabs();
	close_out stream
	)
end);

=TEX
\subsection{SPARK to Lists of Strings}
For various reasons, functions wish to apply a format function to a piece of
abstract syntax, and gain list of strings, each string being a logical line 
of output, neither indented nor split merely due to length.
The following function takes and $fmt\_$ function and does what is necessary:
=SML
fun €strings_from_fmt› (fmt : PP_FMT_INFO -> 'a -> unit) (syntax : 'a) : string list = (
reset_tabs();
let val skipspace : bool ref = ref false;
    val strings : string list ref = ref [];
    val curr_str : string ref = ref "";
    val line_length = get_int_control"line_length";
    fun out_fun (s : string) : unit = (
	if (s = "\n")
	then (
		skipspace := false;
		strings := !strings @ [!curr_str];
		curr_str := "";
		()
	) else (
		if (s = ";" orelse s = "," orelse s = ")" 
			orelse s = "." orelse s = "'" orelse s = ".."
			orelse !skipspace)
		then ()
		else	let	val cur_len = size (!curr_str);
				val s_len = size s;
			in	if	cur_len > 0 andalso cur_len + s_len > line_length
				then	(strings := !strings @ [!curr_str];
					 curr_str := "")
				else	(curr_str := !curr_str ^ " ")
			end;
		curr_str := !curr_str ^ s;
		if (s = "'" orelse s = "(" orelse s = "." orelse s = "..")
		then skipspace := true
		else skipspace := false;
		()
	)
    );
in
   (
	reset_tabs();
	fmt {outf = out_fun, fmt_repl = Nil} syntax;
	reset_tabs();
	if (!curr_str = "")
	then (!strings)
	else !strings @ [!curr_str]
   )
end);
=TEX
\section{EPILOGUE}

=SML

end (* of structure CNSparkOutput *);

=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
