% imp510.doc   @(#) 94/07/14 1.18 imp510.doc
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: SPARK Output Function}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP510}  %% Mandatory field
\def\SCCSversion{1.18%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{94/07/14%
}}
\TPPstatus{Draft}            %% Mandatory field
\TPPtype{Specification}
\TPPkeywords{CN}
\TPPauthor{A.C.~Hayward & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the SPARK output function.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
    Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1, \FormatDate{94/03/28}]
Initial Draft.
\item[Issue 1.2, \FormatDate{94/03/28}]
Added signature and structure information.
\item[Issue 1.3, \FormatDate{94/03/29}]
Minor bug fixes.
\item[Issue 1.4, \FormatDate{94/03/30}]
Added fmt\_variant\_alt\_list.
\item[Issue 1.5, \FormatDate{94/03/30}]
Slight change to ranges, procedures and functions.
\item[Issue 1.6, \FormatDate{94/04/06}]
Formatting routines now return (int * string) list.
\item[Issue 1.7, \FormatDate{94/04/08}]
Formatting routines now take FmtInfo as an argument rather than as part
of a pair.
\item[Issue 1.14 (1st June 1994)]
Corrected a bug in printing of non-expanded declaration k-slots.
\item[Issue 1.16,1.17 \FormatDate{94/07/04}]
Added output\_spark\_progam, output\_spark\_program1.
\item[Issue 1.18 \FormatDate{94/07/04}]
Minor typographical corrections.
\item[Issue 1.26 \FormatDate{94/11/02}]
Fixed problem with outputting the letter Q to a file.
\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD510}.  The module tests are in \cite{ISS/HAT/DAZ/MDT503}.
\subsection{Introduction}
\subsection{Purpose and Background}
\subsection{Algorithms}
\subsection{Dependencies}
\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX
\section{Start of Structure SPARKOutput}
=SML
structure CNPrettyPrinterSupport : CNPrettyPrinterSupport = struct
    open    CNTypes CNTypes1;
    open    ZUserInterfaceSupport;
=TEX
\subsection{Low level functions}

These functions deal with the low-level output of characters.

=SML

val PPTabSize : int ref = ref 2;
type PP_FMT_INFO = {
    tabs : int,
    line_length : int,
    fmtfn : (LABEL -> REPLACEMENT OPT) OPT
    };
fun set_PPTab_size (x : int) = (PPTabSize := x);
fun get_PPTab_size ( () : unit) : int = !PPTabSize;
fun fmt_spaces (i : int) : string =
   if i=0 then "" else " "^fmt_spaces(i-1);
fun fmt_tabs (i : int) : string = fmt_spaces(i * get_PPTab_size());

fun fmt_info_string_list([] : (PP_FMT_INFO * string) list) = ""
  | fmt_info_string_list((i,x)::xs : (PP_FMT_INFO * string) list) =
    (fmt_tabs (#tabs i))^x^"\n"^(fmt_info_string_list xs);

fun inc_tabs ({tabs=t, line_length=ll, fmtfn=f} : PP_FMT_INFO) =
    ({tabs=(t+1), line_length=ll, fmtfn=f} : PP_FMT_INFO);

=TEX
=SML
fun Ûis_expansion_selectedÝ (FmtInfo : PP_FMT_INFO) : bool = (
    case #fmtfn FmtInfo of
        Value _ =>     true
    |    Nil =>        false
);
=TEX

=SML
fun Ûfmt_z_tmÝ (z_tm : Z_TM) : string = (
    case z_tm of
        ZTmFancyApp ((TmplPre (("", Nil), StubUS), ""),
          ZTmTuple[z_tm']) => (
            format_z_tm z_tm'
    ) |    ZTmFancyApp ((TmplPre (("", Nil), StubUS), ""), z_tm') => (
            format_z_tm z_tm'
    ) |    _ => format_z_tm z_tm
);
=TEX

Leaf functions, these don't call any other functions.

=SML

fun Ûfmt_idÝ (n : ID) : string = CaseIndependence.get_external_name n;
fun fmt_tmark (t : TMARK) : string = CaseIndependence.get_external_name t;
fun fmt_term (z : TERM) : string =
    (implode o tl o rev o tl o rev o explode o string_of_term)(z);
fun fmt_label (label : LABEL) = label^" ";
fun fmt_unary_op (UOSparkUnaryAdd : UNARY_OP) = "+"
  | fmt_unary_op (UOSparkUnaryMinus : UNARY_OP) = "-"
  | fmt_unary_op (UOSparkNot : UNARY_OP) = "not "
  | fmt_unary_op (UOSparkAbs : UNARY_OP) = "abs ";
fun fmt_binary_op (BOSparkAdd : BIN_OP) = " + "
  | fmt_binary_op (BOSparkAnd : BIN_OP) = " and "
  | fmt_binary_op (BOSparkAndThen : BIN_OP) = " and then "
  | fmt_binary_op (BOSparkConcat : BIN_OP) = " & "
  | fmt_binary_op (BOSparkEq : BIN_OP) = " = "
  | fmt_binary_op (BOSparkExpon : BIN_OP) = " ** "
  | fmt_binary_op (BOSparkGreater : BIN_OP) = " > "
  | fmt_binary_op (BOSparkGreaterEq : BIN_OP) = " >= "
  | fmt_binary_op (BOSparkIntdiv : BIN_OP) = " / "
  | fmt_binary_op (BOSparkLess : BIN_OP) = " < "
  | fmt_binary_op (BOSparkLessEq : BIN_OP) = " <= "
  | fmt_binary_op (BOSparkMem : BIN_OP) = " in "
  | fmt_binary_op (BOSparkMinus : BIN_OP) = " - "
  | fmt_binary_op (BOSparkMod : BIN_OP) = " mod "
  | fmt_binary_op (BOSparkNotEq : BIN_OP) = " /= "
  | fmt_binary_op (BOSparkNotMem : BIN_OP) = " not in "
  | fmt_binary_op (BOSparkOr : BIN_OP) = " or "
  | fmt_binary_op (BOSparkOrElse : BIN_OP) = " or else "
  | fmt_binary_op (BOSparkRem : BIN_OP) = " rem "
  | fmt_binary_op (BOSparkTimes : BIN_OP) = " * "
  | fmt_binary_op (BOSparkXor : BIN_OP) = " xor ";
fun fmt_mode (MSparkIn : MODE) = " IN "
  | fmt_mode (MSparkOut : MODE) = " OUT "
  | fmt_mode (MSparkInOut : MODE) = " IN OUT ";
fun fmt_loop_direction (LDForwards : LOOP_DIRECTION) = ""
  | fmt_loop_direction (LDReverse : LOOP_DIRECTION) = "REVERSE ";
fun fmt_operator_symbol (s : OPERATOR_SYMBOL) = s;

=TEX

Lists of leaf functions.

=SML

fun fmt_id_list ([] : ID list) = ""
  | fmt_id_list ([x] : ID list) = (fmt_id x)
  | fmt_id_list (x::xs: ID list) = (fmt_id x)^", "^(fmt_id_list xs);
fun fmt_tmark_list ([] : TMARK list) = ""
  | fmt_tmark_list ([x] : TMARK list) = (fmt_tmark x)
  | fmt_tmark_list (x::xs : TMARK list) =
    (fmt_tmark x)^", "^(fmt_tmark_list xs);

=TEX

Equivalences to leaf functions.

=SML

fun fmt_z_id (z : Z_ID) = fmt_id z;
fun fmt_z_pred (z : Z_PRED) = string_of_term z;
fun fmt_z_exp (z : Z_EXP) = string_of_term z;
fun fmt_z_id (z : Z_ID) = fmt_id z;
fun fmt_attrib (x : ATTRIB) = fmt_id x;
fun fmt_int_lit (x : INT_LIT) = (fmt_id x);

=TEX

\subsection{Expressions}

Expressions.

=SML

fun fmt_rangelohi ({lo=l, hi=h} : EXP RANGELOHI) = (fmt_exp l)^".."^(fmt_exp h)
and fmt_range (RRange x : EXP RANGE) = fmt_rangelohi x
  | fmt_range (RRangeAttr x : EXP RANGE) = fmt_exp x
and fmt_discrete_range_constrained ({tmark=t, range=r} :
    EXP DISCRETE_RANGE_CONSTRAINED) =
    (fmt_tmark t)^" RANGE "^(fmt_range r)
and fmt_discrete_range (DRRange x : DISCRETE_RANGE) = (fmt_range x)
  | fmt_discrete_range (DRConstrained x : DISCRETE_RANGE) =
    (fmt_discrete_range_constrained x)
and fmt_agg_choice (ACAggChoiceRange x : AGG_CHOICE) = (fmt_discrete_range x)
  | fmt_agg_choice (ACAggChoiceSingle x : AGG_CHOICE) = (fmt_exp x)
and fmt_agg_choice_list ([] : AGG_CHOICE list) = ""
  | fmt_agg_choice_list ([x] : AGG_CHOICE list) = (fmt_agg_choice x)
  | fmt_agg_choice_list (x::xs : AGG_CHOICE list) =
    (fmt_agg_choice x)^"|"^(fmt_agg_choice_list xs)
and fmt_named_assoc ({choice=c, comp=e} : (AGG_CHOICE, EXP) NAMED_ASSOC) =
    (fmt_agg_choice_list c)^" => "^(fmt_exp e)
and fmt_named_assoc_list ([] : (AGG_CHOICE, EXP) NAMED_ASSOC list) = ""
  | fmt_named_assoc_list ([x] : (AGG_CHOICE, EXP) NAMED_ASSOC list) =
    (fmt_named_assoc x)
  | fmt_named_assoc_list (x::xs : (AGG_CHOICE, EXP) NAMED_ASSOC list) =
    (fmt_named_assoc x)^", "^(fmt_named_assoc_list xs)
and fmt_others ({others=oth} : EXP OTHERS) = "OTHERS => "^(fmt_exp oth)
and fmt_agg_pos ({tmark=t, comps=c} : EXP AGG_POS) =
    (case (explode t)
        of "_"::"_"::_ => (fmt_exp_list c)
         | _ => (fmt_tmark t)^"'("^(fmt_exp_list c)^")"
    )
and fmt_agg_pos_others ({agg_pos = {tmark=t, comps=c} :
    EXP AGG_POS, others = oth} : EXP AGG_POS_OTHERS) =
    (case (explode t)
        of "_"::"_"::_ => (fmt_exp_list c)^", "^(fmt_others oth)
         | _ => (fmt_tmark t)^"'("^(fmt_exp_list c)^", "^(fmt_others oth)^")"
    )
and fmt_agg_others ({tmark=t, others=oth} : EXP AGG_OTHERS) =
    (case (explode t)
        of "_"::"_"::_ => (fmt_others oth)
         | _ => (fmt_tmark t)^"'("^(fmt_others oth)^")"
    )
and fmt_agg_named ({named_assocs=n} : (AGG_CHOICE, EXP) AGG_NAMED) =
    (fmt_named_assoc_list n)
and fmt_agg_named_others ({tmark=t, agg_named=a, others=oth} :
    (AGG_CHOICE, EXP) AGG_NAMED_OTHERS) =
    (case (explode t)
        of "_"::"_"::_ => (fmt_agg_named a)^", "^(fmt_others oth)
         | _ => (fmt_tmark t)^"'("^(fmt_agg_named a)^", "^(fmt_others oth)^")"
    )
and fmt_unary_exp ({uop=u, right=r} : EXP UNARY_EXP) =
    (fmt_unary_op u)^(fmt_exp r)
and fmt_bin_exp ({bop=b, left=l, right=r} : EXP BIN_EXP) =
    (fmt_exp l)^(fmt_binary_op b)^(fmt_exp r)
and fmt_attrib_desig (ADAttrib x : ATTRIB_DESIG) = fmt_attrib x
  | fmt_attrib_desig (ADAttribArg (a,e) : ATTRIB_DESIG) =
    (fmt_attrib a)^"("^(fmt_exp e)^")"
and fmt_attribute ({prefix=p, attribute_desig=a} :
    (EXP, ATTRIB_DESIG) ATTRIBUTE) =
    (fmt_exp p)^"'"^(fmt_attrib_desig a)
and fmt_indexed_comp ({prefix=p, index=i} : EXP INDEXED_COMP) =
    (fmt_exp p)^"("^(fmt_exp i)^")"
and fmt_selected_comp ({prefix=p, selector=s} : EXP SELECTED_COMP) =
    (fmt_exp p)^"."^(fmt_id s)
and fmt_qualified_expression({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) =
    (fmt_tmark t)^"'("^(fmt_exp e)^")"
and fmt_type_conversion({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) =
    (fmt_tmark t)^"("^(fmt_exp e)^")"
and fmt_exp (EId x : EXP) = (fmt_id x)
  | fmt_exp (EInt x : EXP) = (fmt_int_lit x)
  | fmt_exp (EArrayAggPos x : EXP) = (fmt_agg_pos x)
  | fmt_exp (EArrayAggPosOthers x : EXP) = (fmt_agg_pos_others x)
  | fmt_exp (EArrayAggOthers x : EXP) = (fmt_agg_others x)
  | fmt_exp (EArrayAggNamed x : EXP) = (fmt_agg_named x)
  | fmt_exp (EArrayAggNamedOthers x : EXP) = (fmt_agg_named_others x)
  | fmt_exp (ERecAggPos x : EXP) = (fmt_agg_pos x)
  | fmt_exp (ERecAggNamed x : EXP) =
    "ERecAggnamed : this error shouldn't be raised"
  | fmt_exp (EUnaryExp x : EXP) = (fmt_unary_exp x)
  | fmt_exp (EBinExp x : EXP) = (fmt_bin_exp x)
  | fmt_exp (EMemRange x : EXP) =
    "EMemRange : this error shouldn't be raised"
  | fmt_exp (EAttribute x : EXP) = (fmt_attribute x)
  | fmt_exp (EIndexedComp x : EXP) = (fmt_indexed_comp x)
  | fmt_exp (ESelectedComp x : EXP) = (fmt_selected_comp x)
  | fmt_exp (EFunCall x : EXP) = 
    "EFunCall : this error shouldn't be raised"
  | fmt_exp (EAuxiliaryExp x : EXP) = "û"^(fmt_z_tm x)^"ý"
  | fmt_exp (EQualifiedExp x : EXP) = (fmt_qualified_expression x)
  | fmt_exp (ETypeConversion x : EXP) = (fmt_type_conversion x)
  | fmt_exp (EBracketed e : EXP) = ("("^(fmt_exp e)^")")
  | fmt_exp (EStringLiteral s : EXP) = "\""^s^"\""
  | fmt_exp (ECharacterLiteral c : EXP) = "'"^c^"'"
and fmt_exp_list ([] : EXP list) = ""
  | fmt_exp_list ([x] : EXP list) = (fmt_exp x)
  | fmt_exp_list (x::xs : EXP list) = (fmt_exp x)^", "^(fmt_exp_list xs);
fun fmt_static_exp (x : STATIC_EXP) = (fmt_exp x);
fun fmt_static_rangelohi ({lo=l, hi=h} : STATIC_EXP RANGELOHI) =
    (fmt_static_exp l)^".."^(fmt_static_exp h);
fun fmt_static_range (RRange x : EXP RANGE) = fmt_static_rangelohi x
  | fmt_static_range (RRangeAttr x : EXP RANGE) = fmt_static_exp x;
fun fmt_cond (c : COND) = (fmt_exp c);
fun fmt_actuals (APositional x : (AGG_CHOICE, EXP) ACTUALS) = 
    (case x
        of [] => ""
         | z => " ("^(fmt_exp_list x)^")"
    )
  | fmt_actuals (ANamed x : (AGG_CHOICE, EXP) ACTUALS) =
    (case x
        of [] => ""
         | z => " ("^(fmt_named_assoc_list x)^")"
    );

=TEX

\subsection{Statements}

A couple of minor functions before we do statements.

=SML

fun fmt_spec ({w=w, w0=w0, pre=pre, post=post} : SPEC) =
    "„ "^(fmt_id_list w)^" ["^(fmt_z_tm pre)^", "^
                (fmt_z_tm post)^"] ";

fun fmt_proc_call ({name=n, actuals=e} : (AGG_CHOICE, EXP) PROC_CALL) =
    (fmt_id n)^(fmt_actuals e);

=TEX
=SML
fun Ûfmt_expansionÝ (FmtInfo : PP_FMT_INFO) (label : LABEL) :
        (PP_FMT_INFO * string) list OPT = (
let    val f = case (#fmtfn FmtInfo) of
            Value f =>    f
            | Nil =>    fn _ => Nil;
in

    case f label of
    Value repl => Value (
        case repl of
            ReplaceComp {comp, ...} =>        fmt_kslot_compilation_unit_list FmtInfo comp
        |    ReplacePPart {private, ...} =>    fmt_declaration_list FmtInfo private
        |    ReplaceVPart {visible, ...} =>    fmt_declaration_list FmtInfo visible
        |    ReplaceDecl {decls, ...} =>        fmt_declaration_list FmtInfo decls
        |    ReplaceStat {statement, ...}    =>    fmt_statement FmtInfo statement
        |    UnReplaced (RSCompilation, s) =>
                [(FmtInfo, "NULL; -- " ^ label)]
        |    UnReplaced (RSSpecStatement, s) =>
                [(FmtInfo, "NULL; -- " ^ label)]
        |    UnReplaced (RSStatement, s) =>
                [(FmtInfo, "NULL; -- " ^ label)]
        |    UnReplaced (RSDeclaration, s) =>
                [(FmtInfo, "-- k-slot " ^ label)]
        |    UnReplaced (RSPrivatePart, s) =>
                [(FmtInfo, "-- k-slot " ^ label)]
        |    UnReplaced (RSVisiblePart, s) =>
                [(FmtInfo, "-- k-slot " ^ label)]
        )
    |    Nil =>    Nil
end)

and fmt_spec_no_ivars FmtInfo (s as
		{spec, label} : SPEC_NO_IVARS) =
    case fmt_expansion FmtInfo label of
    Value expansion =>    expansion
    |Nil =>        [(FmtInfo, fmt_spec spec^"    "^(fmt_label label))]

=TEX

Statements.

=SML
and fmt_assign (FmtInfo : PP_FMT_INFO) ({name=n, e=e} : ASSIGN) =
    [(FmtInfo, (fmt_exp n)^" := "^(fmt_exp e)^";")]

and fmt_exit_when (FmtInfo : PP_FMT_INFO) ({g=g} : EXIT_WHEN) =
    [(FmtInfo, "EXIT WHEN "^(fmt_cond g)^";")]
and fmt_return (FmtInfo : PP_FMT_INFO) ({e=e} : RETURN) =
    [(FmtInfo, "RETURN "^(fmt_exp e)^";")]
and fmt_proc_call_no_ivars (FmtInfo : PP_FMT_INFO)
        (x : (AGG_CHOICE, EXP) PROC_CALL_NO_IVARS) =
    [(FmtInfo, (fmt_proc_call x)^";")]



and Ûfmt_k_slotÝ (FmtInfo : PP_FMT_INFO) ({content, label} : K_SLOT) = (
    case fmt_expansion FmtInfo label of
    Value expansion =>    expansion
    |Nil =>        [(FmtInfo, content^"    "^(fmt_label label))]
)

and fmt_elsif (FmtInfo : PP_FMT_INFO)
        (stmt as (STIfThenElse {g=g, p=p, q=q, elsif=true}) : STMT) =
    [(FmtInfo, "ELSIF "^(fmt_cond g))]@
    [(FmtInfo, "THEN")]@
    (fmt_stmt (inc_tabs FmtInfo) p)@
    (fmt_elsif FmtInfo q)
  | fmt_elsif (FmtInfo : PP_FMT_INFO)
        (stmt as (STIfThenElse {g=g, p=p, q=q, elsif=false}) : STMT) =
    [(FmtInfo, "ELSIF "^(fmt_cond g))]@
    [(FmtInfo, "THEN")]@
    (fmt_stmt (inc_tabs FmtInfo) p)@
    (case q
        of STImplicitNull => []
         | z => [(FmtInfo, "ELSE")]@(fmt_stmt (inc_tabs FmtInfo) q)
    )
  | fmt_elsif (FmtInfo : PP_FMT_INFO) (stmt : STMT) =
    (fmt_stmt (inc_tabs FmtInfo) stmt)
and fmt_if_then_else (FmtInfo : PP_FMT_INFO)
        ({g=g, p=p, q=q, elsif=false} : STMT IF_THEN_ELSE) =
    [(FmtInfo, "IF "^(fmt_cond g))]@
    [(FmtInfo, "THEN")]@
    (fmt_stmt (inc_tabs FmtInfo) p)@
    (case q
        of STImplicitNull => []
         | z => [(FmtInfo, "ELSE")]@(fmt_stmt (inc_tabs FmtInfo) q)
    )@
    [(FmtInfo, "END IF;")]
  | fmt_if_then_else (FmtInfo : PP_FMT_INFO)
        ({g=g, p=p, q=q, elsif=true} : STMT IF_THEN_ELSE) =
    [(FmtInfo, "IF "^(fmt_cond g))]@
    [(FmtInfo, "THEN")]@
    (fmt_stmt (inc_tabs FmtInfo) p)@
    (fmt_elsif FmtInfo q)@
    [(FmtInfo, "END IF;")]
and fmt_case_choice (CCCaseExp x : CASE_CHOICE) = (fmt_exp x)
  | fmt_case_choice (CCCaseRange x : CASE_CHOICE) = (fmt_discrete_range x)
and fmt_case_choice_list ([] : CASE_CHOICE list) = ""
  | fmt_case_choice_list ([x] : CASE_CHOICE list) = (fmt_case_choice x)
  | fmt_case_choice_list (x::xs : CASE_CHOICE list) =
    (fmt_case_choice x)^"|"^(fmt_case_choice_list xs)
and fmt_case_alt (FmtInfo : PP_FMT_INFO)
        ({choices=c, p=s} : STMT CASE_ALTERNATIVE) =
    [(FmtInfo, "WHEN "^(fmt_case_choice_list c)^" =>")]@
    (fmt_stmt (inc_tabs FmtInfo) s)
and fmt_case_alt_list (FmtInfo : PP_FMT_INFO)
        ([] : STMT CASE_ALTERNATIVE list) = []
  | fmt_case_alt_list (FmtInfo : PP_FMT_INFO)
        (x::xs : STMT CASE_ALTERNATIVE list) =
    (fmt_case_alt FmtInfo x)@(fmt_case_alt_list FmtInfo xs)
and fmt_case (FmtInfo : PP_FMT_INFO) ({e=e, s=s, others=oth} : STMT CASE) =
    [(FmtInfo, "CASE "^(fmt_exp e)^" IS")]@
    (fmt_case_alt_list (inc_tabs FmtInfo) s)@
    (
      case oth
      of STImplicitNull => []
       | _ => [(FmtInfo, "WHEN OTHERS =>")]@(fmt_stmt (inc_tabs FmtInfo) oth)
    )@
    [(FmtInfo, "END CASE;")]
and fmt_unnamed_loop (FmtInfo : PP_FMT_INFO) ({t=Value t, stmt=s} : STMT LOOP) =
    (if is_expansion_selected FmtInfo
    then    [(FmtInfo, "-- TILL ...")]
    else    [(FmtInfo, "TILL û"^(fmt_z_tm t)^"ý")]
    ) @
    [(FmtInfo, "LOOP")]@
    (fmt_stmt (inc_tabs FmtInfo) s)@
    [(FmtInfo, "END LOOP;")]
  | fmt_unnamed_loop (FmtInfo : PP_FMT_INFO) ({t=Nil, stmt=s} : STMT LOOP) =
    [(FmtInfo, "LOOP")]@
    (fmt_stmt (inc_tabs FmtInfo) s)@
    [(FmtInfo, "END LOOP;")]
and fmt_named_loop (FmtInfo : PP_FMT_INFO)
        ({name=n, t=Value t, stmt=s} : STMT NAMED_LOOP) =
    [(FmtInfo, (fmt_id n)^":")]@
    (    if is_expansion_selected FmtInfo
    then    [(FmtInfo, "-- TILL statement")]
    else    [(FmtInfo, "TILL û"^(fmt_z_tm t)^"ý")]
    ) @
    [(FmtInfo, "LOOP")]@
    (fmt_stmt (inc_tabs FmtInfo) s)@
    [(FmtInfo, "END LOOP "^(fmt_id n)^";")]
  | fmt_named_loop (FmtInfo : PP_FMT_INFO)
        ({name=n, t=Nil, stmt=s} : STMT NAMED_LOOP) =
    [(FmtInfo, (fmt_id n)^":")]@
    [(FmtInfo, "LOOP")]@
    (fmt_stmt (inc_tabs FmtInfo) s)@
    [(FmtInfo, "END LOOP "^(fmt_id n)^";")]
and fmt_loop_body (FmtInfo : PP_FMT_INFO) ({t=Value t, stmt=s} : STMT LOOP) =
    (    if is_expansion_selected FmtInfo
    then    [(FmtInfo, "-- TILL statement")]
    else    [(FmtInfo, "TILL û"^(fmt_z_tm t)^"ý")]
    ) @
    [(FmtInfo, "LOOP")]@
    (fmt_stmt (inc_tabs FmtInfo) s)
  | fmt_loop_body (FmtInfo : PP_FMT_INFO) ({t=Nil, stmt=s} : STMT LOOP) =
    [(FmtInfo, "LOOP")]@
    (fmt_stmt (inc_tabs FmtInfo) s)
and fmt_while (FmtInfo : PP_FMT_INFO)
        ({name=Value n, g=g, loop=l} : STMT WHILE) =
    [(FmtInfo, (fmt_id n)^":")]@
    [(FmtInfo, "WHILE "^(fmt_cond g))]@
    (fmt_loop_body FmtInfo l)@
    [(FmtInfo, "END LOOP "^(fmt_id n)^";")]
  | fmt_while (FmtInfo : PP_FMT_INFO)
        ({name=Nil, g=g, loop=l} : STMT WHILE) =
    [(FmtInfo, "WHILE "^(fmt_cond g))]@
    (fmt_loop_body FmtInfo l)@
    [(FmtInfo, "END LOOP;")]
and fmt_for_static (FmtInfo : PP_FMT_INFO)
        ({name=Value n, tmark=t, i=i, dir=d, range=r, loop=loop}:
    STMT FOR_STATIC) =
    [(FmtInfo, (fmt_id n)^":")]@
    [(FmtInfo, "FOR "^(fmt_id i)^" IN "^
        (fmt_loop_direction d)^(fmt_tmark t)^" RANGE "^(fmt_range r))]@
    (fmt_loop_body FmtInfo loop)@
    [(FmtInfo, "END LOOP "^(fmt_id n)^";")]
  | fmt_for_static (FmtInfo : PP_FMT_INFO)
        ({name=Nil, tmark=t, i=i, dir=d, range=r, loop=loop} :
    STMT FOR_STATIC) =
    [(FmtInfo, "FOR "^(fmt_id i)^" IN "^(fmt_loop_direction d)^
        (fmt_tmark t)^" RANGE "^(fmt_range r))]@
    (fmt_loop_body FmtInfo loop)@
    [(FmtInfo, "END LOOP;")]
and fmt_for_tmark (FmtInfo : PP_FMT_INFO)
        ({name=Value n, i=i, tmark=t, dir=d, loop=loop} :
    STMT FOR_TMARK) =
    [(FmtInfo, (fmt_id n)^":")]@
    [(FmtInfo, "FOR "^(fmt_id i)^" IN "^
        (fmt_loop_direction d)^(fmt_tmark t))]@
    (fmt_loop_body FmtInfo loop)@
    [(FmtInfo, "END LOOP "^(fmt_id n)^";")]
  | fmt_for_tmark (FmtInfo : PP_FMT_INFO)
        ({name=Nil, i=i, tmark=t, dir=d, loop=loop} :
    STMT FOR_TMARK) =
    [(FmtInfo, "FOR "^(fmt_id i)^" IN "^
        (fmt_loop_direction d)^(fmt_tmark t))]@
    (fmt_loop_body FmtInfo loop)@
    [(FmtInfo, "END LOOP;")]
and fmt_stmt (FmtInfo : PP_FMT_INFO) (STNull : STMT) = [(FmtInfo, "NULL;")]
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STImplicitNull : STMT) = []
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STAssign x : STMT) =
        (fmt_assign FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STSpecNoIvars x : STMT) =
        (fmt_spec_no_ivars FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STSemicolon (a,b) : STMT) =
        (fmt_stmt FmtInfo a)@(fmt_stmt FmtInfo b)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STIfThenElse x : STMT) =
        (fmt_if_then_else FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STCase x : STMT) =
        (fmt_case FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STLoop x : STMT) =
        (fmt_unnamed_loop FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STNamedLoop x : STMT) =
        (fmt_named_loop FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STWhile x : STMT) =
        (fmt_while FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STForStatic x : STMT) =
        (fmt_for_static FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STForTmark x : STMT) =
        (fmt_for_tmark FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STExitWhen x : STMT) =
        (fmt_exit_when FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STExit : STMT) = [(FmtInfo, "EXIT;")]
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STRet x : STMT)  =
        (fmt_return FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STProcNoIvars x : STMT) =
        (fmt_proc_call_no_ivars FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STKSlot x : STMT) =
        (fmt_k_slot FmtInfo x)

=TEX

Logical constructs.

=SML

(* we don't print out pre1 since it doesn't come from the user *)
and fmt_log_con (FmtInfo : PP_FMT_INFO)
        ({x=x, t=t, spec=s, label, ...} : LOG_CON, stmt :STMT) =
    if is_expansion_selected FmtInfo
    then    (fmt_spec_no_ivars FmtInfo {spec=s, label=label})
			@ (fmt_stmt FmtInfo stmt)
    else    [(FmtInfo,
            "CON "^(fmt_z_id x)^" : "^(fmt_z_tm t)^" · "^
            (fmt_spec s)^"    "^(fmt_label label))] @ (fmt_stmt FmtInfo stmt)

=TEX

Top level statements.

=SML

and fmt_statement (FmtInfo : PP_FMT_INFO) (SStmt x) = (fmt_stmt FmtInfo x)
  | fmt_statement (FmtInfo : PP_FMT_INFO) (SSpecIvars x) =
    [(FmtInfo, "SSpecIvars : this error shouldn't be raised")]
  | fmt_statement (FmtInfo : PP_FMT_INFO) (SForNonStatic x) = 
    [(FmtInfo, "SForNonStatic : this error shouldn't be raised")]
  | fmt_statement (FmtInfo : PP_FMT_INFO) (SLogCon x) = (fmt_log_con FmtInfo x)
  | fmt_statement (FmtInfo : PP_FMT_INFO) (SProcIvars x) =
    [(FmtInfo, "SProcIvars : this error shouldn't be raised")]

=TEX

\subsection{Declarations and Type Definitions}

Variable declarations.

=SML

and fmt_var_decl (FmtInfo : PP_FMT_INFO) ({vars=v, tmark=t} : VAR_DECL) =
    [(FmtInfo, (fmt_id_list v)^" : "^(fmt_tmark t)^";")]
and fmt_var_decl_list (FmtInfo : PP_FMT_INFO) ([] : VAR_DECL list) = []
  | fmt_var_decl_list (FmtInfo : PP_FMT_INFO) (x::xs : VAR_DECL list) =
    (fmt_var_decl FmtInfo x)@(fmt_var_decl_list FmtInfo xs)

=TEX

Constant and deferred constant declarations.

=SML

and fmt_const_decl (FmtInfo : PP_FMT_INFO)
        ({consts=c, tm=t, expr=e} : EXP CONST_DECL) =
    [(FmtInfo, (fmt_id_list c)^" : CONSTANT "^
        (fmt_tmark t)^" := "^(fmt_exp e)^";")]
and fmt_deferred_const_decl (FmtInfo : PP_FMT_INFO)
        ({consts=c, tmark=t} : DEFERRED_CONST_DECL) =
    [(FmtInfo, (fmt_id_list c)^" : CONSTANT "^(fmt_tmark t)^";")]

=TEX

Enumerated types.

=SML

and fmt_enum_type_def (FmtInfo : PP_FMT_INFO)
        (name, {vals=v} : ENUM_TYPE_DEF) = 
    [(FmtInfo, "TYPE "^(fmt_id name)^
        " IS ("^(fmt_id_list v)^");")]

=TEX

Integer types.

=SML

and fmt_int_type_def (FmtInfo : PP_FMT_INFO) (name, r : EXP RANGE) =
    [(FmtInfo, "TYPE "^(fmt_id name)^
        " IS RANGE "^(fmt_range r)^";")]

=TEX

Floating point types.

=SML

and fmt_floating_point_constraint ({exp=e, range=Value r} :
        EXP FLOATING_POINT_CONSTRAINT) =
    " DIGITS "^(fmt_exp e)^" RANGE "^(fmt_range r)
  | fmt_floating_point_constraint ({exp=e, range=Nil} :
        EXP FLOATING_POINT_CONSTRAINT) =
    " DIGITS "^(fmt_exp e)
and fmt_floating_type_def (FmtInfo : PP_FMT_INFO)
        (name, x : EXP FLOATING_TYPE_DEF) =
    [(FmtInfo, "TYPE "^(fmt_id name)^
        " IS"^(fmt_floating_point_constraint x)^";")]

=TEX

Fixed point types.

=SML

and fmt_fixed_point_constraint ({exp=e, range=Value r} :
        EXP FIXED_POINT_CONSTRAINT) =
    " DELTA "^(fmt_exp e)^" RANGE "^(fmt_range r)
  | fmt_fixed_point_constraint ({exp=e, range=Nil} :
        EXP FIXED_POINT_CONSTRAINT) =
    " DELTA "^(fmt_exp e)
and fmt_fixed_type_def (FmtInfo : PP_FMT_INFO)
        (name, x : EXP FIXED_TYPE_DEF) =
    [(FmtInfo, "TYPE "^(fmt_id name)^
        " IS"^(fmt_fixed_point_constraint x)^";")]

=TEX

Array types.

=SML

and fmt_array_def (FmtInfo : PP_FMT_INFO)
        (name, {index=i, comp=c} : ARRAY_DEF) =
    [(FmtInfo, "TYPE "^(fmt_id name)^
        " IS ARRAY ("^(fmt_tmark_list i)^") OF "^(fmt_tmark c)^";")]
and fmt_uncon_tmark_list ([] : TMARK list) = ""
  | fmt_uncon_tmark_list ([x] : TMARK list) = (fmt_tmark x)^" RANGE <>"
  | fmt_uncon_tmark_list (x::xs : TMARK list) =
    (fmt_uncon_tmark_list [x])^", "^(fmt_uncon_tmark_list xs)
and fmt_uncon_array_def (FmtInfo : PP_FMT_INFO)
        (name, {index=i, comp=c} : ARRAY_DEF) =
    [(FmtInfo, "TYPE "^(fmt_id name)^
        " IS ARRAY ("^(fmt_uncon_tmark_list i)^") OF "^(fmt_tmark c)^";")]

=TEX

Record types.

=SML

and fmt_record_type_def (FmtInfo : PP_FMT_INFO)
        (name, {decl=d} : RECORD_TYPE_DEF) =
    [(FmtInfo, "TYPE "^(fmt_id name)^" IS")]@
    [(FmtInfo, "RECORD")]@
    (fmt_var_decl_list (inc_tabs FmtInfo) d)@
    [(FmtInfo, "END RECORD;")]

=TEX

Type declarations.

=SML

and fmt_type_def (FmtInfo : PP_FMT_INFO)
        (name, (TDEnumTypeDef x) : TYPE_DEF) =
    (fmt_enum_type_def FmtInfo (name, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO)
        (name, (TDIntTypeDef x) : TYPE_DEF) =
    (fmt_int_type_def FmtInfo (name, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO)
        (name, (TDFloatingTypeDef x) : TYPE_DEF) =
    (fmt_floating_type_def FmtInfo (name, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO)
        (name, (TDFixedTypeDef x) : TYPE_DEF) =
    (fmt_fixed_type_def FmtInfo (name, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO)
        (name, (TDUnconArrayDef x) : TYPE_DEF) =
    (fmt_uncon_array_def FmtInfo (name, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO)
        (name, (TDConArrayDef x) : TYPE_DEF) =
    (fmt_array_def FmtInfo (name, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO) 
        (name, (TDRecordTypeDef x) : TYPE_DEF) =
    (fmt_record_type_def FmtInfo (name, x))
and fmt_type_decl (FmtInfo : PP_FMT_INFO)
        ({name=n, type_def=t} : TYPE_DEF TYPE_DECL) =
    (fmt_type_def FmtInfo (n, t))

=TEX

Subtype declarations.

=SML

and fmt_constraint (CRange x : CONSTRAINT) = "RANGE "^fmt_range x
  | fmt_constraint (CIndex x : CONSTRAINT) = (fmt_exp_list x)
  | fmt_constraint (CFloating x : CONSTRAINT) =
    (fmt_floating_point_constraint x)
  | fmt_constraint (CFixed x : CONSTRAINT) =
    (fmt_fixed_point_constraint x)
and fmt_sub_ind ({tmark=t, con=c} : CONSTRAINT SUB_IND) =
    (fmt_tmark t)^" "^(fmt_constraint c)
and fmt_subtype_decl (FmtInfo : PP_FMT_INFO)
        ({name=n, sub_ind=s} : CONSTRAINT SUBTYPE_DECL) =
    [(FmtInfo, "SUBTYPE "^(fmt_id n)^" IS "^(fmt_sub_ind s)^";")]

=TEX

Private type declarations.

=SML

and fmt_private_type_decl (FmtInfo : PP_FMT_INFO)
        ({id=i, limited=l} : PRIVATE_TYPE_DECL) =
    [(FmtInfo, "TYPE "^(fmt_id i)^" IS"^
        (if l=true then " LIMITED" else "")^" PRIVATE;")]

=TEX

Basic declarations.

=SML

and fmt_basic_decl (FmtInfo : PP_FMT_INFO) (BDConstDecl x : BASIC_DECL) =
    (fmt_const_decl FmtInfo x)
  | fmt_basic_decl (FmtInfo : PP_FMT_INFO)
        (BDDeferredConstDecl x : BASIC_DECL) =
    (fmt_deferred_const_decl FmtInfo x)
  | fmt_basic_decl (FmtInfo : PP_FMT_INFO) (BDTypeDecl x : BASIC_DECL) =
    (fmt_type_decl FmtInfo x)
  | fmt_basic_decl (FmtInfo : PP_FMT_INFO) (BDVarDecl x : BASIC_DECL) =
    (fmt_var_decl FmtInfo x)
  | fmt_basic_decl (FmtInfo : PP_FMT_INFO) (BDSubtypeDecl x : BASIC_DECL) =
    (fmt_subtype_decl FmtInfo x)
  | fmt_basic_decl (FmtInfo : PP_FMT_INFO) (BDPrivateTypeDecl x : BASIC_DECL ) =
    (fmt_private_type_decl FmtInfo x)
and fmt_basic_decl_list (FmtInfo : PP_FMT_INFO) ([] : BASIC_DECL list) = []
  | fmt_basic_decl_list (FmtInfo : PP_FMT_INFO) (x::xs : BASIC_DECL list) =
    (fmt_basic_decl FmtInfo x)@(fmt_basic_decl_list FmtInfo xs)

=TEX

\subsection{Procedure and Function specifications}

Procedure and Function parameter specifications.

=SML

and fmt_parameter_specification ({idlist=i, mode=m, name=n} :
        PARAMETER_SPECIFICATION) =
    (fmt_id_list i)^" :"^(fmt_mode m)^(fmt_tmark n)
and fmt_parameter_specification_list1 ([] : PARAMETER_SPECIFICATION list) = ""
  | fmt_parameter_specification_list1 ([x] : PARAMETER_SPECIFICATION list) =
    (fmt_parameter_specification x)
  | fmt_parameter_specification_list1 (x::xs : PARAMETER_SPECIFICATION list) =
    (fmt_parameter_specification x)^"; "^(fmt_parameter_specification_list1 xs)
and fmt_parameter_specification_list ([] : PARAMETER_SPECIFICATION list) = ""
  | fmt_parameter_specification_list (xs : PARAMETER_SPECIFICATION list) =
    " ("^(fmt_parameter_specification_list1 xs)^")"

=TEX

Procedure and Function specifications.

=SML

and fmt_procedure_specification (FmtInfo : PP_FMT_INFO)
        ({name=n, formal_part=f, spec=Value s} : PROCEDURE_SPECIFICATION) =
    if is_expansion_selected FmtInfo
    then
        [(FmtInfo, "PROCEDURE "^
            (fmt_id n)^(fmt_parameter_specification_list f))]@
            [((inc_tabs FmtInfo), "-- „ ...")]
    else
        [(FmtInfo, "PROCEDURE "^
            (fmt_id n)^(fmt_parameter_specification_list f))]@
            [((inc_tabs FmtInfo), (fmt_spec s))]

  | fmt_procedure_specification (FmtInfo : PP_FMT_INFO)
        ({name=n, formal_part=f, spec=Nil} : PROCEDURE_SPECIFICATION) =
    [(FmtInfo, "PROCEDURE "^(fmt_id n)^(fmt_parameter_specification_list f))]
and fmt_function_specification (FmtInfo : PP_FMT_INFO)
        ({designator=d, return=r, formal_part=f, spec=Value s} :
        FUNCTION_SPECIFICATION) =
    if is_expansion_selected FmtInfo
    then
        [(FmtInfo, "FUNCTION "^(fmt_id d)^
            (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark r))]@
            [((inc_tabs FmtInfo), "-- „ ...")]
    else
        [(FmtInfo, "FUNCTION "^(fmt_id d)^
            (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark r))]@
            [((inc_tabs FmtInfo), (fmt_spec s))]
  | fmt_function_specification  (FmtInfo : PP_FMT_INFO)
        ({designator=d, return=r, formal_part=f, spec=Nil} :
        FUNCTION_SPECIFICATION) =
    [(FmtInfo, "FUNCTION "^(fmt_id d)^
        (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark r))]

=TEX

Subprograms.

=SML

and fmt_subprogram_specification (FmtInfo : PP_FMT_INFO)
        (SSProcedure x : SUBPROGRAM_SPECIFICATION) =
    (fmt_procedure_specification FmtInfo x)
  | fmt_subprogram_specification (FmtInfo : PP_FMT_INFO)
        (SSFunction x : SUBPROGRAM_SPECIFICATION) =
    (fmt_function_specification FmtInfo x)

=TEX

Renaming declarations.

=SML

and fmt_function_renaming (FmtInfo : PP_FMT_INFO)
        ({opsym1=o1, formal_part=f, tmark=t, name=n, opsym2=o2} :
        FUNCTION_RENAMING) =
    [(FmtInfo, "FUNCTION \""^(fmt_operator_symbol o1)^"\""^
        (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark t)^
        " RENAMES "^(fmt_id n)^".\""^(fmt_operator_symbol o2)^"\";")]
and fmt_subprogram_renaming (FmtInfo : PP_FMT_INFO)
        ({subprogram_specification=s, name1=n1, name2=n2} :
        SUBPROGRAM_RENAMING) =
    (fmt_subprogram_specification FmtInfo s)@
    [((inc_tabs FmtInfo), " RENAMES "^(fmt_id n1)^"."^(fmt_id n2)^";")]
and fmt_renaming_declaration (FmtInfo : PP_FMT_INFO)
        (RDFunction x : RENAMING_DECLARATION) =
    (fmt_function_renaming FmtInfo x)
  | fmt_renaming_declaration (FmtInfo : PP_FMT_INFO)
        (RDSubprogram x : RENAMING_DECLARATION) =
    (fmt_subprogram_renaming FmtInfo x)

=TEX

Representation clauses.

=SML

and fmt_component_clause (FmtInfo : PP_FMT_INFO)
        ({name=n, exp=e, range=r} : COMPONENT_CLAUSE) =
    [(FmtInfo, (fmt_id n)^" AT "^(fmt_exp e)^" RANGE "^(fmt_range r)^";")]
and fmt_component_clause_list (FmtInfo : PP_FMT_INFO)
        ([] : COMPONENT_CLAUSE list) = []
  | fmt_component_clause_list (FmtInfo : PP_FMT_INFO)
        (x::xs : COMPONENT_CLAUSE list) =
    (fmt_component_clause FmtInfo x)@(fmt_component_clause_list FmtInfo xs)
and fmt_length_clause (FmtInfo : PP_FMT_INFO)
        ({attribute=a, exp=e} : LENGTH_CLAUSE) =
    [(FmtInfo, "FOR "^(fmt_exp a)^" USE "^(fmt_exp e)^";")]
and fmt_enumeration_representation_clause (FmtInfo : PP_FMT_INFO)
       ({name=n, exp=e} : ENUMERATION_REPRESENTATION_CLAUSE) =
    [(FmtInfo, "FOR "^(fmt_id n)^" USE ("^(fmt_exp e)^");")]
and fmt_record_representation_clause (FmtInfo : PP_FMT_INFO)
        ({name=n, alignment_opt=Value a,  component_pack=c} :
        RECORD_REPRESENTATION_CLAUSE) =
    [(FmtInfo, "FOR "^(fmt_id n)^" USE")]@
    [((inc_tabs FmtInfo), "RECORD "^(fmt_exp a))]@
    (fmt_component_clause_list (inc_tabs FmtInfo) c)@
    [((inc_tabs FmtInfo), "END RECORD;")]
  | fmt_record_representation_clause (FmtInfo : PP_FMT_INFO)
        ({name=n, alignment_opt=Nil, component_pack=c} :
        RECORD_REPRESENTATION_CLAUSE) =
    [(FmtInfo, "FOR "^(fmt_id n)^" USE")]@
    [((inc_tabs FmtInfo), "RECORD")]@
    (fmt_component_clause_list (inc_tabs FmtInfo) c)@
    [((inc_tabs FmtInfo), "END RECORD;")]
and fmt_address_clause (FmtInfo : PP_FMT_INFO)
        ({name=n, exp=e} : ADDRESS_CLAUSE) =
    [(FmtInfo, "FOR "^(fmt_id n)^" USE AT "^(fmt_exp e)^";")]
and fmt_representation_clause (FmtInfo : PP_FMT_INFO)
        (RCLength x : REPRESENTATION_CLAUSE) =
    (fmt_length_clause FmtInfo x)
  | fmt_representation_clause (FmtInfo : PP_FMT_INFO)
        (RCEnumeration x : REPRESENTATION_CLAUSE) =
    (fmt_enumeration_representation_clause FmtInfo x)
  | fmt_representation_clause (FmtInfo : PP_FMT_INFO)
        (RCRecord x : REPRESENTATION_CLAUSE) =
    (fmt_record_representation_clause FmtInfo x)
  | fmt_representation_clause (FmtInfo : PP_FMT_INFO)
        (RCAddress x : REPRESENTATION_CLAUSE) =
    (fmt_address_clause FmtInfo x)

=TEX

Declarations, these are defined simultaneously since they can be recursive.

=SML
and fmt_procedure_declaration (FmtInfo : PP_FMT_INFO)
        ({name=n, formal_part=f, spec=Value s} : PROCEDURE_DECLARATION) =
    if is_expansion_selected FmtInfo
    then
        [(FmtInfo, "PROCEDURE "^
            (fmt_id n)^(fmt_parameter_specification_list f)^";")]@
            [((inc_tabs FmtInfo), "-- „ ...")]
    else
        [(FmtInfo, "PROCEDURE "^
            (fmt_id n)^(fmt_parameter_specification_list f))]@
            [((inc_tabs FmtInfo), (fmt_spec s)^";")]

  | fmt_procedure_declaration (FmtInfo : PP_FMT_INFO)
        ({name=n, formal_part=f, spec=Nil} : PROCEDURE_DECLARATION) =
    [(FmtInfo, "PROCEDURE "^(fmt_id n)
			^(fmt_parameter_specification_list f)^";")]

and fmt_function_declaration (FmtInfo : PP_FMT_INFO)
        ({designator=d, return=r, formal_part=f, spec=Value s} :
        FUNCTION_DECLARATION) =
    if is_expansion_selected FmtInfo
    then
        [(FmtInfo, "FUNCTION "^(fmt_id d)^
            (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark r)^";")]@
            [((inc_tabs FmtInfo), "-- „ ...")]
    else
        [(FmtInfo, "FUNCTION "^(fmt_id d)^
            (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark r))]@
            [((inc_tabs FmtInfo), (fmt_spec s)^";")]
  | fmt_function_declaration  (FmtInfo : PP_FMT_INFO)
        ({designator=d, return=r, formal_part=f, spec=Nil} :
        FUNCTION_DECLARATION) =
    [(FmtInfo, "FUNCTION "^(fmt_id d)^
        (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark r)^";")]


and fmt_procedure_stub (FmtInfo : PP_FMT_INFO) (x : PROCEDURE_DECLARATION) =
    [(FmtInfo, "PROCEDURE "^(fmt_id (#name x))^" IS SEPARATE;")]
and fmt_function_stub (FmtInfo : PP_FMT_INFO) (x : FUNCTION_DECLARATION) =
    [(FmtInfo, "FUNCTION "^(fmt_id (#designator x))^" RETURN "^
      (fmt_tmark (#return x))^" IS SEPARATE;")]
and fmt_package_stub (FmtInfo : PP_FMT_INFO) (n : ID) =
    [(FmtInfo, "PACKAGE BODY "^(fmt_id n)^" IS SEPARATE;")]
and fmt_auxiliary (FmtInfo : PP_FMT_INFO) (av : AUX_VAR) =
    (if is_expansion_selected FmtInfo
    then    [(FmtInfo, "-- AUXILIARY ... ;")]
    else    [(FmtInfo, "-- AUXILIARY "^(fmt_z_id (#aux av))^" ;")]
    )
and fmt_using (FmtInfo : PP_FMT_INFO) (u : USING_DEC) =
    (if is_expansion_selected FmtInfo
    then	[(FmtInfo, "-- USING ...")]@
		(fmt_basic_decl_list FmtInfo (#basic_decls u))@
		[(FmtInfo, "-- IMPLEMENT ... BY ... ;")]
    else	[(FmtInfo, "USING ")]@
		(fmt_basic_decl_list FmtInfo (#basic_decls u))@
		[(FmtInfo, "IMPLEMENT "^(fmt_z_tm (#aux u))^" BY "
		^(fmt_z_tm (#invariant u))^" ;")]
    )
and fmt_package_declaration (FmtInfo : PP_FMT_INFO)
        ({name=n, visible_decs=v, private_decs=p} :
    DECLARATION PACKAGE_DECLARATION) =
    [(FmtInfo, "PACKAGE "^(fmt_id n)^" IS")]@
    (fmt_declaration_list (inc_tabs FmtInfo) v)@
    (case p
        of [] => []
         | _ => [(FmtInfo, "PRIVATE")]@
                (fmt_declaration_list (inc_tabs FmtInfo) p)
    )@
    [(FmtInfo, "END "^(fmt_id n)^";")]
and fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DDeclarationKSlot (x, _) : DECLARATION) =
    (fmt_k_slot FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DRenamingDeclaration x : DECLARATION) =
    (fmt_renaming_declaration FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DBasicDecl x : DECLARATION) =
    (fmt_basic_decl FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DRepresentationClause x : DECLARATION) =
    (fmt_representation_clause FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DProperBody x : DECLARATION) =
    (fmt_proper_body FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DProcedureDeclaration x : DECLARATION) =
    (fmt_procedure_declaration FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DFunctionDeclaration x : DECLARATION) =
    (fmt_function_declaration FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DPackageDeclaration x : DECLARATION) =
    (fmt_package_declaration FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DProcedureStub x : DECLARATION) =
    (fmt_procedure_stub FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DFunctionStub x : DECLARATION) =
    (fmt_function_stub FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DPackageStub x : DECLARATION) =
    (fmt_package_stub FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DAuxiliary x : DECLARATION) =
    (fmt_auxiliary FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DUsing x : DECLARATION) =
    (fmt_using FmtInfo x)
=TEX
=SML
and fmt_declaration_list (FmtInfo : PP_FMT_INFO) ([] : DECLARATION list) = []
  | fmt_declaration_list (FmtInfo : PP_FMT_INFO) (x::xs : DECLARATION list) =
    (fmt_declaration FmtInfo x)@(fmt_declaration_list FmtInfo xs)
and fmt_procedure_body (FmtInfo : PP_FMT_INFO)
        ({procedure_spec=p, declarative_part=d, statement=s} :
         DECLARATION PROCEDURE_BODY) =
    (fmt_procedure_specification FmtInfo p)@
    [(FmtInfo, "IS")]@
    (fmt_declaration_list (inc_tabs FmtInfo) d)@
    [(FmtInfo, "BEGIN")]@
    (fmt_statement (inc_tabs FmtInfo) s)@
    [(FmtInfo, "END "^(fmt_id (#name p))^";")]
and fmt_function_body (FmtInfo : PP_FMT_INFO)
        ({function_spec=f, declarative_part=d, statement=s} :
        DECLARATION FUNCTION_BODY) =
    (fmt_function_specification FmtInfo f)@
    [(FmtInfo, "IS")]@
    (fmt_declaration_list (inc_tabs FmtInfo) d)@
    [(FmtInfo, "BEGIN")]@
    (fmt_statement (inc_tabs FmtInfo) s)@
    [(FmtInfo, "END "^(fmt_id (#designator f))^";")]
and fmt_package_body (FmtInfo : PP_FMT_INFO)
        ({name=n, decls=d, statement=s} : DECLARATION PACKAGE_BODY) =
    [(FmtInfo, "PACKAGE BODY "^(fmt_id n)^" IS")]@
    (fmt_declaration_list (inc_tabs FmtInfo) d)@
    (case s
      of SStmt STImplicitNull => []
      | _ => [(FmtInfo, "BEGIN")]@(fmt_statement (inc_tabs FmtInfo) s)
    )@
    [(FmtInfo, "END "^(fmt_id n)^";")]
and fmt_proper_body (FmtInfo : PP_FMT_INFO) (PBProcedure x : PROPER_BODY) =
    (fmt_procedure_body FmtInfo x)
  | fmt_proper_body (FmtInfo : PP_FMT_INFO) (PBFunction x : PROPER_BODY) =
    (fmt_function_body FmtInfo x)
  | fmt_proper_body (FmtInfo : PP_FMT_INFO) (PBPackage x : PROPER_BODY) =
    (fmt_package_body FmtInfo x)

=TEX

Compilation subunits.

=SML

and fmt_compilation_subunit (FmtInfo : PP_FMT_INFO)
        ({name=n, proper_body=p} : COMP_SUBUNIT) =
    [(FmtInfo, "SEPARATE ("^(fmt_id n)^")")]@(fmt_proper_body (inc_tabs FmtInfo) p)

=TEX

Compilation units.

=SML

and fmt_context_clause (FmtInfo : PP_FMT_INFO) ([] : ID list) = []
  | fmt_context_clause (FmtInfo : PP_FMT_INFO) (x : ID list) =
    [(FmtInfo, "WITH "^(fmt_id_list x)^";")]
and fmt_compilation_unit (FmtInfo : PP_FMT_INFO)
        (CUPackageDeclaration x : COMPILATION_UNIT) =
    (fmt_package_declaration FmtInfo x)
  | fmt_compilation_unit (FmtInfo : PP_FMT_INFO)
        (CUProperBody x : COMPILATION_UNIT) =
    (fmt_proper_body FmtInfo x)
  | fmt_compilation_unit (FmtInfo : PP_FMT_INFO)
        (CUSubUnit x : COMPILATION_UNIT) =
    (fmt_compilation_subunit FmtInfo x)
and fmt_context_compilation_unit (FmtInfo : PP_FMT_INFO)
        ({context=i, comp_unit=c} : CONTEXT_COMPILATION_UNIT) =
    (fmt_context_clause FmtInfo i)@(fmt_compilation_unit FmtInfo c)
and fmt_kslot_compilation_unit (FmtInfo : PP_FMT_INFO)
        (KCUKSlot x : KSLOT_COMPILATION_UNIT) =
    (fmt_k_slot FmtInfo x)
  | fmt_kslot_compilation_unit (FmtInfo : PP_FMT_INFO)
        (KCUUnit x : KSLOT_COMPILATION_UNIT) =
    (fmt_context_compilation_unit FmtInfo x)
and fmt_kslot_compilation_unit_list (FmtInfo : PP_FMT_INFO)
    ([] : KSLOT_COMPILATION_UNIT list) = []
  | fmt_kslot_compilation_unit_list (FmtInfo : PP_FMT_INFO)
    (x::xs : KSLOT_COMPILATION_UNIT list) =
    (fmt_kslot_compilation_unit FmtInfo x)@
    [(FmtInfo, "")]@[(FmtInfo, "")]@
    (fmt_kslot_compilation_unit_list FmtInfo xs)

=TEX

=SML

and fmt_replaced_by_comp (FmtInfo : PP_FMT_INFO)
        ({label=l, comp=c} : REPLACED_BY_COMP) =
    [(FmtInfo, (fmt_label l)^" é ")]@
    (fmt_kslot_compilation_unit_list (inc_tabs FmtInfo) c)
and fmt_replaced_by_private_part (FmtInfo : PP_FMT_INFO)
        ({label=l, private=p} : REPLACED_BY_PRIVATE_PART) =
    [(FmtInfo, (fmt_label l)^" é ")]@(fmt_declaration_list (inc_tabs FmtInfo) p)
and fmt_replaced_by_visible_part (FmtInfo : PP_FMT_INFO)
        ({label=l, visible=v} : REPLACED_BY_VISIBLE_PART) =
    [(FmtInfo, (fmt_label l)^" é ")]@(fmt_declaration_list (inc_tabs FmtInfo) v)
and fmt_replaced_by_decl (FmtInfo : PP_FMT_INFO)
        ({label=l, decls=d} : REPLACED_BY_DECL) =
    [(FmtInfo, (fmt_label l)^" é ")]@(fmt_declaration_list (inc_tabs FmtInfo) d)
and fmt_refined_by (FmtInfo : PP_FMT_INFO)
        ({label=l, statement=s} : REFINED_BY) =
    [(FmtInfo, (fmt_label l)^" Ã ")]@(fmt_statement (inc_tabs FmtInfo) s)
and fmt_replaced_by (FmtInfo : PP_FMT_INFO)
        ({label=l, statement=s} : REFINED_BY) =
    [(FmtInfo, (fmt_label l)^" é ")]@(fmt_statement (inc_tabs FmtInfo) s)

=TEX

Web Clauses.

=SML

and fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCCompilation x : WEB_CLAUSE) =
    (fmt_kslot_compilation_unit_list FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCReplacedByCompilation x : WEB_CLAUSE) =
    (fmt_replaced_by_comp FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCReplacedByPrivatePart x : WEB_CLAUSE) =
    (fmt_replaced_by_private_part FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCReplacedByVisiblePart x : WEB_CLAUSE) =
    (fmt_replaced_by_visible_part FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCReplacedByDecl x : WEB_CLAUSE) =
    (fmt_replaced_by_decl FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCRefinedBy x : WEB_CLAUSE) =
    (fmt_refined_by FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCReplacedBy x : WEB_CLAUSE) =
    (fmt_replaced_by FmtInfo x);

=TEX

=SML

end (* of structure CNPrettyPrinterSupport *);

=TEX


\section{AUXILIARY FUNCTIONS}

=SML

structure ÛSPARKOutputÝ : SPARKOutput = struct
    open CNTypes CNPrettyPrinterSupport CNZGenerator;
=TEX
=SML

type ÛPP_FMT_INFOÝ = CNPrettyPrinterSupport.PP_FMT_INFO;

fun Ûformat_web_clauseÝ (FmtInfo : PP_FMT_INFO) (x : WEB_CLAUSE) : unit =
    diag_line (
        (fmt_info_string_list (fmt_web_clause FmtInfo x ))
);

val Ûprint_web_clauseÝ : WEB_CLAUSE -> unit = (
    format_web_clause
    {tabs=1,line_length=get_line_length(),fmtfn=Nil}
);

fun Ûprint_spark_programÝ (() : unit) : unit = (
    format_web_clause
    {    tabs = 1,
        line_length = get_line_length(),
        fmtfn = Value get_replacement
    }
    (WCCompilation (#spark_prog (get_cn_state())))
);

fun Ûoutput_spark_programÝ ({file : string}) = (
  let    val stream = open_out file;
    val FmtInfo = {    tabs =1,
                line_length = get_line_length(),
                fmtfn = Value get_replacement    };
    val x = (WCCompilation (#spark_prog (get_cn_state())));
    val text = (fmt_info_string_list (fmt_web_clause FmtInfo x))
  in
    output (stream, translate_for_output text);
    close_out stream
  end
);

=TEX

\subsection{End of structure SPARKOutput}

The structure SPARKOutput is opened.
=SML

end (* of structure SPARKOutput *);

open SPARKOutput;
=TEX


=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
