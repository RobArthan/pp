% imp510.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: SPARK Output Function}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP510}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{CN}
\TPPauthor{A.C.~Hayward & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the SPARK output function.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1, \FormatDate{94/03/28}]
Initial Draft.
\item[Issue 1.2, \FormatDate{94/03/28}]
Added signature and structure information.
\item[Issue 1.3, \FormatDate{94/03/29}]
Minor bug fixes.
\item[Issue 1.4, \FormatDate{94/03/30}]
Added fmt\_variant\_alt\_list.
\item[Issue 1.5, \FormatDate{94/03/30}]
Slight change to ranges, procedures and functions.
\item[Issue 1.6, \FormatDate{94/04/06}]
Formatting routines now return (int * string) list.
\item[Issue 1.7, \FormatDate{94/04/08}]
Formatting routines now take FmtInfo as an argument rather than as part
of a pair.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD510}.  The module tests are in \cite{ISS/HAT/DAZ/MDT503}.
\subsection{Introduction}
\subsection{Purpose and Background}
\subsection{Algorithms}
\subsection{Dependencies}
\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX
\section{Start of Structure SPARKOutput}
=SML
structure CNPrettyPrinterSupport : CNPrettyPrinterSupport = struct
local
	open	CNTypes;
in
=TEX
\subsection{Low level functions}

These functions deal with the low-level output of characters.

=SML

val PPTabSize : int ref = ref 2;
type PP_FMT_INFO =
    {tabs : int, line_length : int, fmtfn : LABEL -> WEB_CLAUSE OPT};
fun set_PPTab_size (x : int) = (PPTabSize := x);
fun get_PPTab_size ( () : unit) : int = !PPTabSize;
fun fmt_spaces (i : int) : string =
   if i=0 then "" else " "^fmt_spaces(i-1);
fun fmt_tabs (i : int) : string = fmt_spaces(i * get_PPTab_size());

fun fmt_info_string_list([] : (PP_FMT_INFO * string) list) = ""
  | fmt_info_string_list((i,x)::xs : (PP_FMT_INFO * string) list) =
    (fmt_tabs (#tabs i))^x^"\n"^(fmt_info_string_list xs);

fun inc_tabs ({tabs=t, line_length=ll, fmtfn=f} : PP_FMT_INFO) =
    ({tabs=(t+1), line_length=ll, fmtfn=f} : PP_FMT_INFO);


=TEX

Leaf functions, these don't call any other functions.

=SML

fun fmt_id (n : ID) : string = n;
fun fmt_tmark (t : TMARK) : string = t;
fun fmt_term (z : TERM) : string =
    (implode o tl o rev o tl o rev o explode o string_of_term)(z);
fun fmt_label (LExplicit lab : LABEL) = lab^" "
  | fmt_label (LImplicit : LABEL) = "";
fun fmt_unary_op (UOSparkUnaryAdd : UNARY_OP) = "+"
  | fmt_unary_op (UOSparkUnaryMinus : UNARY_OP) = "-"
  | fmt_unary_op (UOSparkNot : UNARY_OP) = "not "
  | fmt_unary_op (UOSparkAbs : UNARY_OP) = "abs ";
fun fmt_binary_op (BOSparkAdd : BIN_OP) = " + "
  | fmt_binary_op (BOSparkAnd : BIN_OP) = " and "
  | fmt_binary_op (BOSparkAndThen : BIN_OP) = " and then "
  | fmt_binary_op (BOSparkConcat : BIN_OP) = " & "
  | fmt_binary_op (BOSparkEq : BIN_OP) = " = "
  | fmt_binary_op (BOSparkExpon : BIN_OP) = " ** "
  | fmt_binary_op (BOSparkGreater : BIN_OP) = " > "
  | fmt_binary_op (BOSparkGreaterEq : BIN_OP) = " >= "
  | fmt_binary_op (BOSparkIntdiv : BIN_OP) = " / "
  | fmt_binary_op (BOSparkLess : BIN_OP) = " < "
  | fmt_binary_op (BOSparkLessEq : BIN_OP) = " <= "
  | fmt_binary_op (BOSparkMem : BIN_OP) = " in "
  | fmt_binary_op (BOSparkMinus : BIN_OP) = " - "
  | fmt_binary_op (BOSparkMod : BIN_OP) = " mod "
  | fmt_binary_op (BOSparkNotEq : BIN_OP) = " /= "
  | fmt_binary_op (BOSparkNotMem : BIN_OP) = " not in "
  | fmt_binary_op (BOSparkOr : BIN_OP) = " or "
  | fmt_binary_op (BOSparkOrElse : BIN_OP) = " or else "
  | fmt_binary_op (BOSparkRem : BIN_OP) = " rem "
  | fmt_binary_op (BOSparkTimes : BIN_OP) = " * "
  | fmt_binary_op (BOSparkXor : BIN_OP) = " xor ";
fun fmt_mode (MSparkIn : MODE) = " IN "
  | fmt_mode (MSparkOut : MODE) = " OUT "
  | fmt_mode (MSparkInOut : MODE) = " IN OUT ";
fun fmt_loop_direction (LDForwards : LOOP_DIRECTION) = ""
  | fmt_loop_direction (LDReverse : LOOP_DIRECTION) = "REVERSE ";
fun fmt_operator_symbol (s : OPERATOR_SYMBOL) = s;

=TEX

Lists of leaf functions.

=SML

fun fmt_id_list ([] : ID list) = ""
  | fmt_id_list ([x] : ID list) = (fmt_id x)
  | fmt_id_list (x::xs: ID list) = (fmt_id x)^", "^(fmt_id_list xs);
fun fmt_tmark_list ([] : TMARK list) = ""
  | fmt_tmark_list ([x] : TMARK list) = (fmt_tmark x)
  | fmt_tmark_list (x::xs : TMARK list) =
    (fmt_tmark x)^", "^(fmt_tmark_list xs);

=TEX

Equivalences to leaf functions.

=SML

fun fmt_z_pred (z : Z_PRED) : string = fmt_term z;
fun fmt_z_exp (z : Z_EXP) : string = fmt_term z;
fun fmt_z_id (z : Z_ID) = fmt_id z;
fun fmt_attrib (x : ATTRIB) = fmt_id x;
fun fmt_int_lit (x : INT_LIT) = (fmt_id x);

=TEX

\subsection{Expressions}

Expressions.

=SML

fun fmt_rangelohi ({lo=l, hi=h} : EXP RANGELOHI) = (fmt_exp l)^".."^(fmt_exp h)
and fmt_range (RRange x : EXP RANGE) = fmt_rangelohi x
  | fmt_range (RRangeAttr x : EXP RANGE) = fmt_exp x
and fmt_discrete_range_constrained ({tmark=t, range=r} :
    EXP DISCRETE_RANGE_CONSTRAINED) =
    (fmt_tmark t)^" RANGE "^(fmt_range r)
and fmt_discrete_range (DRRange x : DISCRETE_RANGE) = (fmt_range x)
  | fmt_discrete_range (DRConstrained x : DISCRETE_RANGE) =
    (fmt_discrete_range_constrained x)
and fmt_agg_choice (ACAggChoiceRange x : AGG_CHOICE) = (fmt_discrete_range x)
  | fmt_agg_choice (ACAggChoiceSingle x : AGG_CHOICE) = (fmt_exp x)
and fmt_agg_choice_list ([] : AGG_CHOICE list) = ""
  | fmt_agg_choice_list ([x] : AGG_CHOICE list) = (fmt_agg_choice x)
  | fmt_agg_choice_list (x::xs : AGG_CHOICE list) =
    (fmt_agg_choice x)^"|"^(fmt_agg_choice_list xs)
and fmt_named_assoc ({choice=c, comp=e} : (AGG_CHOICE, EXP) NAMED_ASSOC) =
    (fmt_agg_choice_list c)^" => "^(fmt_exp e)
and fmt_named_assoc_list ([] : (AGG_CHOICE, EXP) NAMED_ASSOC list) = ""
  | fmt_named_assoc_list ([x] : (AGG_CHOICE, EXP) NAMED_ASSOC list) =
    (fmt_named_assoc x)
  | fmt_named_assoc_list (x::xs : (AGG_CHOICE, EXP) NAMED_ASSOC list) =
    (fmt_named_assoc x)^", "^(fmt_named_assoc_list xs)
and fmt_others ({others=oth} : EXP OTHERS) = "OTHERS => "^(fmt_exp oth)
and fmt_agg_pos ({tmark=t, comps=c} : EXP AGG_POS) =
    (case (explode t)
        of "_"::"_"::_ => (fmt_exp_list c)
         | _ => (fmt_tmark t)^"'("^(fmt_exp_list c)^")"
    )
and fmt_agg_pos_others ({agg_pos = {tmark=t, comps=c} :
    EXP AGG_POS, others = oth} : EXP AGG_POS_OTHERS) =
    (case (explode t)
        of "_"::"_"::_ => (fmt_exp_list c)^", "^(fmt_others oth)
         | _ => (fmt_tmark t)^"'("^(fmt_exp_list c)^", "^(fmt_others oth)^")"
    )
and fmt_agg_others ({tmark=t, others=oth} : EXP AGG_OTHERS) =
    (case (explode t)
        of "_"::"_"::_ => (fmt_others oth)
         | _ => (fmt_tmark t)^"'("^(fmt_others oth)^")"
    )
and fmt_agg_named ({named_assocs=n} : (AGG_CHOICE, EXP) AGG_NAMED) =
    (fmt_named_assoc_list n)
and fmt_agg_named_others ({tmark=t, agg_named=a, others=oth} :
    (AGG_CHOICE, EXP) AGG_NAMED_OTHERS) =
    (case (explode t)
        of "_"::"_"::_ => (fmt_agg_named a)^", "^(fmt_others oth)
         | _ => (fmt_tmark t)^"'("^(fmt_agg_named a)^", "^(fmt_others oth)^")"
    )
and fmt_unary_exp ({uop=u, right=r} : EXP UNARY_EXP) =
    (fmt_unary_op u)^(fmt_exp r)
and fmt_bin_exp ({bop=b, left=l, right=r} : EXP BIN_EXP) =
    (fmt_exp l)^(fmt_binary_op b)^(fmt_exp r)
and fmt_attrib_desig (ADAttrib x : ATTRIB_DESIG) = fmt_attrib x
  | fmt_attrib_desig (ADAttribArg (a,e) : ATTRIB_DESIG) =
    (fmt_attrib a)^"("^(fmt_exp e)^")"
and fmt_attribute ({prefix=p, attribute_desig=a} :
    (EXP, ATTRIB_DESIG) ATTRIBUTE) =
    (fmt_exp p)^"'"^(fmt_attrib_desig a)
and fmt_indexed_comp ({prefix=p, index=i} : EXP INDEXED_COMP) =
    (fmt_exp p)^"("^(fmt_exp i)^")"
and fmt_selected_comp ({prefix=p, selector=s} : EXP SELECTED_COMP) =
    (fmt_exp p)^"."^(fmt_id s)
and fmt_qualified_expression({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) =
    (fmt_tmark t)^"'("^(fmt_exp e)^")"
and fmt_exp (EId x : EXP) = (fmt_id x)
  | fmt_exp (EInt x : EXP) = (fmt_int_lit x)
  | fmt_exp (EArrayAggPos x : EXP) = (fmt_agg_pos x)
  | fmt_exp (EArrayAggPosOthers x : EXP) = (fmt_agg_pos_others x)
  | fmt_exp (EArrayAggOthers x : EXP) = (fmt_agg_others x)
  | fmt_exp (EArrayAggNamed x : EXP) = (fmt_agg_named x)
  | fmt_exp (EArrayAggNamedOthers x : EXP) = (fmt_agg_named_others x)
  | fmt_exp (ERecAggPos x : EXP) = (fmt_agg_pos x)
  | fmt_exp (ERecAggNamed x : EXP) =
    "ERecAggnamed : this error shouldn't be raised"
  | fmt_exp (EUnaryExp x : EXP) = (fmt_unary_exp x)
  | fmt_exp (EBinExp x : EXP) = (fmt_bin_exp x)
  | fmt_exp (EMemRange x : EXP) =
    "EMemRange : this error shouldn't be raised"
  | fmt_exp (EAttribute x : EXP) = (fmt_attribute x)
  | fmt_exp (EIndexedComp x : EXP) = (fmt_indexed_comp x)
  | fmt_exp (ESelectedComp x : EXP) = (fmt_selected_comp x)
  | fmt_exp (EFunCall x : EXP) = 
    "EFunCall : this error shouldn't be raised"
  | fmt_exp (EAuxiliaryExp x : EXP) = "û"^(fmt_z_exp x)^"ý"
  | fmt_exp (EQualifiedExp x : EXP) = (fmt_qualified_expression x)
  | fmt_exp (EBracketed e : EXP) = ("("^(fmt_exp e)^")")
  | fmt_exp (EStringLiteral s : EXP) = "\""^s^"\""
  | fmt_exp (ECharacterLiteral c : EXP) = "'"^c^"'"
and fmt_exp_list ([] : EXP list) = ""
  | fmt_exp_list ([x] : EXP list) = (fmt_exp x)
  | fmt_exp_list (x::xs : EXP list) = (fmt_exp x)^", "^(fmt_exp_list xs);
fun fmt_static_exp (x : STATIC_EXP) = (fmt_exp x);
fun fmt_static_rangelohi ({lo=l, hi=h} : STATIC_EXP RANGELOHI) =
    (fmt_static_exp l)^".."^(fmt_static_exp h);
fun fmt_static_range (RRange x : EXP RANGE) = fmt_static_rangelohi x
  | fmt_static_range (RRangeAttr x : EXP RANGE) = fmt_static_exp x;
fun fmt_cond (c : COND) = (fmt_exp c);
fun fmt_actuals (APositional x : (AGG_CHOICE, EXP) ACTUALS) = 
    (case x
        of [] => ""
         | z => " ("^(fmt_exp_list x)^")"
    )
  | fmt_actuals (ANamed x : (AGG_CHOICE, EXP) ACTUALS) =
    (case x
        of [] => ""
         | z => " ("^(fmt_named_assoc_list x)^")"
    );

=TEX

\subsection{Statements}

A couple of minor functions before we do statements.

=SML

fun fmt_spec ({w=w, w0=w0, pre=pre, post=post, label=l} : SPEC) =
    "„ "^(fmt_id_list w)^" ["^(fmt_z_pred pre)^", "^
    (fmt_z_pred post)^"]"^(fmt_label l);
fun fmt_proc_call ({name=n, actuals=e} : (AGG_CHOICE, EXP) PROC_CALL) =
    (fmt_id n)^(fmt_actuals e);

=TEX

Statements.

=SML

fun fmt_k_slot (FmtInfo : PP_FMT_INFO) ({content=c, label=l} : K_SLOT) =
    [case l
        of LImplicit => (FmtInfo, c)
         | LExplicit _ => (FmtInfo, c^"    "^(fmt_label l))
    ];
fun fmt_assign (FmtInfo : PP_FMT_INFO) ({name=n, e=e} : ASSIGN) =
    [(FmtInfo, (fmt_exp n)^" := "^(fmt_exp e)^";")];
fun fmt_spec_no_ivars (FmtInfo : PP_FMT_INFO) (s : SPEC_NO_IVARS) =
    [(FmtInfo, (fmt_spec s))];
fun fmt_exit_when (FmtInfo : PP_FMT_INFO) ({g=g} : EXIT_WHEN) =
    [(FmtInfo, "EXIT WHEN "^(fmt_cond g)^";")];
fun fmt_return (FmtInfo : PP_FMT_INFO) ({e=e} : RETURN) =
    [(FmtInfo, "RETURN "^(fmt_exp e)^";")];
fun fmt_proc_call_no_ivars (FmtInfo : PP_FMT_INFO)
        (x : (AGG_CHOICE, EXP) PROC_CALL_NO_IVARS) =
    [(FmtInfo, (fmt_proc_call x)^";")];
fun fmt_elsif (FmtInfo : PP_FMT_INFO)
        (stmt as (STIfThenElse {g=g, p=p, q=q, elsif=true}) : STMT) =
    [(FmtInfo, "ELSIF "^(fmt_cond g))]@
    [(FmtInfo, "THEN")]@
    (fmt_stmt (inc_tabs FmtInfo) p)@
    (fmt_elsif FmtInfo q)
  | fmt_elsif (FmtInfo : PP_FMT_INFO)
        (stmt as (STIfThenElse {g=g, p=p, q=q, elsif=false}) : STMT) =
    [(FmtInfo, "ELSIF "^(fmt_cond g))]@
    [(FmtInfo, "THEN")]@
    (fmt_stmt (inc_tabs FmtInfo) p)@
    (case q
        of STImplicitNull => []
         | z => [(FmtInfo, "ELSE")]@(fmt_stmt (inc_tabs FmtInfo) q)
    )
  | fmt_elsif (FmtInfo : PP_FMT_INFO) (stmt : STMT) =
    (fmt_stmt (inc_tabs FmtInfo) stmt)
and fmt_if_then_else (FmtInfo : PP_FMT_INFO)
        ({g=g, p=p, q=q, elsif=false} : STMT IF_THEN_ELSE) =
    [(FmtInfo, "IF "^(fmt_cond g))]@
    [(FmtInfo, "THEN")]@
    (fmt_stmt (inc_tabs FmtInfo) p)@
    (case q
        of STImplicitNull => []
         | z => [(FmtInfo, "ELSE")]@(fmt_stmt (inc_tabs FmtInfo) q)
    )@
    [(FmtInfo, "END IF;")]
  | fmt_if_then_else (FmtInfo : PP_FMT_INFO)
        ({g=g, p=p, q=q, elsif=true} : STMT IF_THEN_ELSE) =
    [(FmtInfo, "IF "^(fmt_cond g))]@
    [(FmtInfo, "THEN")]@
    (fmt_stmt (inc_tabs FmtInfo) p)@
    (fmt_elsif FmtInfo q)@
    [(FmtInfo, "END IF;")]
and fmt_case_choice (CCCaseExp x : CASE_CHOICE) = (fmt_exp x)
  | fmt_case_choice (CCCaseRange x : CASE_CHOICE) = (fmt_discrete_range x)
and fmt_case_choice_list ([] : CASE_CHOICE list) = ""
  | fmt_case_choice_list ([x] : CASE_CHOICE list) = (fmt_case_choice x)
  | fmt_case_choice_list (x::xs : CASE_CHOICE list) =
    (fmt_case_choice x)^"|"^(fmt_case_choice_list xs)
and fmt_case_alt (FmtInfo : PP_FMT_INFO)
        ({choices=c, p=s} : STMT CASE_ALTERNATIVE) =
    [(FmtInfo, "WHEN "^(fmt_case_choice_list c)^" =>")]@
    (fmt_stmt (inc_tabs FmtInfo) s)
and fmt_case_alt_list (FmtInfo : PP_FMT_INFO)
        ([] : STMT CASE_ALTERNATIVE list) = []
  | fmt_case_alt_list (FmtInfo : PP_FMT_INFO)
        (x::xs : STMT CASE_ALTERNATIVE list) =
    (fmt_case_alt FmtInfo x)@(fmt_case_alt_list FmtInfo xs)
and fmt_case (FmtInfo : PP_FMT_INFO) ({e=e, s=s, others=oth} : STMT CASE) =
    [(FmtInfo, "CASE "^(fmt_exp e)^" IS")]@
    (fmt_case_alt_list (inc_tabs FmtInfo) s)@
    (
      case oth
      of STImplicitNull => []
       | _ => [(FmtInfo, "WHEN OTHERS =>")]@(fmt_stmt (inc_tabs FmtInfo) oth)
    )@
    [(FmtInfo, "END CASE;")]
and fmt_unnamed_loop (FmtInfo : PP_FMT_INFO) ({t=Value t, stmt=s} : STMT LOOP) =
    [(FmtInfo, "TILL û"^(fmt_z_pred t)^"ý")]@
    [(FmtInfo, "LOOP")]@
    (fmt_stmt (inc_tabs FmtInfo) s)@
    [(FmtInfo, "END LOOP;")]
  | fmt_unnamed_loop (FmtInfo : PP_FMT_INFO) ({t=Nil, stmt=s} : STMT LOOP) =
    [(FmtInfo, "LOOP")]@
    (fmt_stmt (inc_tabs FmtInfo) s)@
    [(FmtInfo, "END LOOP;")]
and fmt_named_loop (FmtInfo : PP_FMT_INFO)
        ({name=n, t=Value t, stmt=s} : STMT NAMED_LOOP) =
    [(FmtInfo, (fmt_id n)^":")]@
    [(FmtInfo, "TILL û"^(fmt_z_pred t)^"ý")]@
    [(FmtInfo, "LOOP")]@
    (fmt_stmt (inc_tabs FmtInfo) s)@
    [(FmtInfo, "END LOOP "^(fmt_id n)^";")]
  | fmt_named_loop (FmtInfo : PP_FMT_INFO)
        ({name=n, t=Nil, stmt=s} : STMT NAMED_LOOP) =
    [(FmtInfo, (fmt_id n)^":")]@
    [(FmtInfo, "LOOP")]@
    (fmt_stmt (inc_tabs FmtInfo) s)@
    [(FmtInfo, "END LOOP "^(fmt_id n)^";")]
and fmt_loop_body (FmtInfo : PP_FMT_INFO) ({t=Value t, stmt=s} : STMT LOOP) =
    [(FmtInfo, "TILL û"^(fmt_z_pred t)^"ý")]@
    [(FmtInfo, "LOOP")]@
    (fmt_stmt (inc_tabs FmtInfo) s)
  | fmt_loop_body (FmtInfo : PP_FMT_INFO) ({t=Nil, stmt=s} : STMT LOOP) =
    [(FmtInfo, "LOOP")]@
    (fmt_stmt (inc_tabs FmtInfo) s)
and fmt_while (FmtInfo : PP_FMT_INFO)
        ({name=Value n, g=g, loop=l} : STMT WHILE) =
    [(FmtInfo, (fmt_id n)^":")]@
    [(FmtInfo, "WHILE "^(fmt_cond g))]@
    (fmt_loop_body FmtInfo l)@
    [(FmtInfo, "END LOOP "^(fmt_id n)^";")]
  | fmt_while (FmtInfo : PP_FMT_INFO)
        ({name=Nil, g=g, loop=l} : STMT WHILE) =
    [(FmtInfo, "WHILE "^(fmt_cond g))]@
    (fmt_loop_body FmtInfo l)@
    [(FmtInfo, "END LOOP;")]
and fmt_for_static (FmtInfo : PP_FMT_INFO)
        ({name=Value n, tmark=t, i=i, dir=d, range=r, loop=loop}:
    STMT FOR_STATIC) =
    [(FmtInfo, (fmt_id n)^":")]@
    [(FmtInfo, "FOR "^(fmt_id i)^" IN "^
        (fmt_loop_direction d)^(fmt_tmark t)^" RANGE "^(fmt_range r))]@
    (fmt_loop_body FmtInfo loop)@
    [(FmtInfo, "END LOOP "^(fmt_id n)^";")]
  | fmt_for_static (FmtInfo : PP_FMT_INFO)
        ({name=Nil, tmark=t, i=i, dir=d, range=r, loop=loop} :
    STMT FOR_STATIC) =
    [(FmtInfo, "FOR "^(fmt_id i)^" IN "^(fmt_loop_direction d)^
        (fmt_tmark t)^" RANGE "^(fmt_range r))]@
    (fmt_loop_body FmtInfo loop)@
    [(FmtInfo, "END LOOP;")]
and fmt_for_tmark (FmtInfo : PP_FMT_INFO)
        ({name=Value n, i=i, tmark=t, dir=d, loop=loop} :
    STMT FOR_TMARK) =
    [(FmtInfo, (fmt_id n)^":")]@
    [(FmtInfo, "FOR "^(fmt_id i)^" IN "^
        (fmt_loop_direction d)^(fmt_tmark t))]@
    (fmt_loop_body FmtInfo loop)@
    [(FmtInfo, "END LOOP "^(fmt_id n)^";")]
  | fmt_for_tmark (FmtInfo : PP_FMT_INFO)
        ({name=Nil, i=i, tmark=t, dir=d, loop=loop} :
    STMT FOR_TMARK) =
    [(FmtInfo, "FOR "^(fmt_id i)^" IN "^
        (fmt_loop_direction d)^(fmt_tmark t))]@
    (fmt_loop_body FmtInfo loop)@
    [(FmtInfo, "END LOOP;")]
and fmt_stmt (FmtInfo : PP_FMT_INFO) (STNull : STMT) = [(FmtInfo, "NULL;")]
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STImplicitNull : STMT) = []
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STAssign x : STMT) =
        (fmt_assign FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STSpecNoIvars x : STMT) =
        (fmt_spec_no_ivars FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STSemicolon (a,b) : STMT) =
        (fmt_stmt FmtInfo a)@(fmt_stmt FmtInfo b)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STIfThenElse x : STMT) =
        (fmt_if_then_else FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STCase x : STMT) =
        (fmt_case FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STLoop x : STMT) =
        (fmt_unnamed_loop FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STNamedLoop x : STMT) =
        (fmt_named_loop FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STWhile x : STMT) =
        (fmt_while FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STForStatic x : STMT) =
        (fmt_for_static FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STForTmark x : STMT) =
        (fmt_for_tmark FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STExitWhen x : STMT) =
        (fmt_exit_when FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STExit : STMT) = [(FmtInfo, "EXIT;")]
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STRet x : STMT)  =
        (fmt_return FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STProcNoIvars x : STMT) =
        (fmt_proc_call_no_ivars FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STKSlot x : STMT) =
        (fmt_k_slot FmtInfo x);

=TEX

Logical constructs.

=SML

(* we don't print out pre1 since it doesn't come from the user *)
fun fmt_log_con (FmtInfo : PP_FMT_INFO)
        ({x=x, t=t, spec=s, ...} : LOG_CON, stmt :STMT) =
    [(FmtInfo, "CON "^(fmt_z_id x)^" : "^(fmt_z_exp t)^" · "^(fmt_spec s))]@
    (fmt_stmt FmtInfo stmt);

=TEX

Top level statements.

=SML

fun fmt_statement (FmtInfo : PP_FMT_INFO) (SStmt x) = (fmt_stmt FmtInfo x)
  | fmt_statement (FmtInfo : PP_FMT_INFO) (SSpecIvars x) =
    [(FmtInfo, "SSpecIvars : this error shouldn't be raised")]
  | fmt_statement (FmtInfo : PP_FMT_INFO) (SForNonStatic x) = 
    [(FmtInfo, "SForNonStatic : this error shouldn't be raised")]
  | fmt_statement (FmtInfo : PP_FMT_INFO) (SLogCon x) = (fmt_log_con FmtInfo x)
  | fmt_statement (FmtInfo : PP_FMT_INFO) (SProcIvars x) =
    [(FmtInfo, "SProcIvars : this error shouldn't be raised")];

=TEX

\subsection{Declarations and Type Definitions}

Variable declarations.

=SML

fun fmt_var_decl (FmtInfo : PP_FMT_INFO) ({vars=v, tmark=t} : VAR_DECL) =
    [(FmtInfo, (fmt_id_list v)^" : "^(fmt_tmark t)^";")];
fun fmt_var_decl_list (FmtInfo : PP_FMT_INFO) ([] : VAR_DECL list) = []
  | fmt_var_decl_list (FmtInfo : PP_FMT_INFO) (x::xs : VAR_DECL list) =
    (fmt_var_decl FmtInfo x)@(fmt_var_decl_list FmtInfo xs);

=TEX

Constant and deferred constant declarations.

=SML

fun fmt_const_decl (FmtInfo : PP_FMT_INFO)
        ({consts=c, tm=t, expr=e} : EXP CONST_DECL) =
    [(FmtInfo, (fmt_id_list c)^" : CONSTANT "^
        (fmt_tmark t)^" := "^(fmt_exp e)^";")];
fun fmt_deferred_const_decl (FmtInfo : PP_FMT_INFO)
        ({consts=c, tmark=t} : DEFERRED_CONST_DECL) =
    [(FmtInfo, (fmt_id_list c)^" : CONSTANT "^(fmt_tmark t)^";")];

=TEX

Minor functions before type definitions.

=SML

fun fmt_variant_alt_list ([] : ID list) = ""
  | fmt_variant_alt_list ([x] : ID list) = fmt_id x
  | fmt_variant_alt_list (x::xs : ID list) =
    (fmt_id x)^"|"^(fmt_variant_alt_list xs);
fun fmt_variant (FmtInfo : PP_FMT_INFO) ({ids=i, comp=c} : COMPONENT VARIANT) =
    [(FmtInfo, "WHEN "^(fmt_variant_alt_list i)^" =>")]@
    (fmt_component_list (inc_tabs FmtInfo) c)
and fmt_variant_list (FmtInfo : PP_FMT_INFO) ([] : COMPONENT VARIANT list) = []
  | fmt_variant_list (FmtInfo : PP_FMT_INFO) (x::xs : COMPONENT VARIANT list) =
    (fmt_variant FmtInfo x)@(fmt_variant_list FmtInfo xs)
and fmt_variant_part (FmtInfo : PP_FMT_INFO)
        ({id=i, variants=v} : COMPONENT VARIANT_PART) =
    [(FmtInfo, "CASE "^(fmt_id i)^" IS")]@
    (fmt_variant_list (inc_tabs FmtInfo) v)@
    [(FmtInfo, "END CASE;")]
and fmt_declaration_variant (FmtInfo : PP_FMT_INFO)
        ({decls=d, variant=v} : COMPONENT DECLARATION_VARIANT) =
    (fmt_var_decl_list FmtInfo d)@(fmt_variant_part FmtInfo v)
and fmt_component (FmtInfo : PP_FMT_INFO) (CDeclaration x : COMPONENT) =
    (fmt_var_decl_list FmtInfo x)
  | fmt_component (FmtInfo : PP_FMT_INFO) (CVariantPart x : COMPONENT) =
    (fmt_variant_part FmtInfo x)
  | fmt_component (FmtInfo : PP_FMT_INFO) (CDeclarationVariant x : COMPONENT) =
    (fmt_declaration_variant FmtInfo x)
  | fmt_component (FmtInfo : PP_FMT_INFO) (CNone : COMPONENT) =
    [(FmtInfo, "NULL")]
and fmt_component_list (FmtInfo : PP_FMT_INFO) ([] : COMPONENT list) = []
  | fmt_component_list (FmtInfo : PP_FMT_INFO) (x::xs : COMPONENT list) =
    (fmt_component FmtInfo x)@(fmt_component_list FmtInfo xs);

=TEX

Discriminant part.

=SML

fun fmt_discr_part (Value {vars=v, tmark=t} : DISCR_PART) =
    " "^(fmt_id_list v)^" : "^(fmt_tmark t)
  | fmt_discr_part (Nil : DISCR_PART) = "";

=TEX

Enumerated types.

=SML

fun fmt_enum_type_def (FmtInfo : PP_FMT_INFO)
        (name, discr, {vals=v} : ENUM_TYPE_DEF) = 
    [(FmtInfo, "TYPE "^(fmt_id name)^(fmt_discr_part discr)^
        " IS ("^(fmt_id_list v)^");")];

=TEX

Integer types.

=SML

fun fmt_int_type_def (FmtInfo : PP_FMT_INFO) (name, discr, r : EXP RANGE) =
    [(FmtInfo, "TYPE "^(fmt_id name)^(fmt_discr_part discr)^
        " IS RANGE "^(fmt_range r)^";")];

=TEX

Floating point types.

=SML

fun fmt_floating_point_constraint ({exp=e, range=Value r} :
        EXP FLOATING_POINT_CONSTRAINT) =
    " DIGITS "^(fmt_exp e)^" RANGE "^(fmt_range r)
  | fmt_floating_point_constraint ({exp=e, range=Nil} :
        EXP FLOATING_POINT_CONSTRAINT) =
    " DIGITS "^(fmt_exp e);
fun fmt_floating_type_def (FmtInfo : PP_FMT_INFO)
        (name, discr, x : EXP FLOATING_TYPE_DEF) =
    [(FmtInfo, "TYPE "^(fmt_id name)^(fmt_discr_part discr)^
        " IS"^(fmt_floating_point_constraint x)^";")];

=TEX

Fixed point types.

=SML

fun fmt_fixed_point_constraint ({exp=e, range=Value r} :
        EXP FIXED_POINT_CONSTRAINT) =
    " DELTA "^(fmt_exp e)^" RANGE "^(fmt_range r)
  | fmt_fixed_point_constraint ({exp=e, range=Nil} :
        EXP FIXED_POINT_CONSTRAINT) =
    " DELTA "^(fmt_exp e);
fun fmt_fixed_type_def (FmtInfo : PP_FMT_INFO)
        (name, discr, x : EXP FIXED_TYPE_DEF) =
    [(FmtInfo, "TYPE "^(fmt_id name)^(fmt_discr_part discr)^
        " IS"^(fmt_fixed_point_constraint x)^";")];

=TEX

Array types.

=SML

fun fmt_array_def (FmtInfo : PP_FMT_INFO)
        (name, discr, {index=i, comp=c} : ARRAY_DEF) =
    [(FmtInfo, "TYPE "^(fmt_id name)^(fmt_discr_part discr)^
        " IS ARRAY ("^(fmt_tmark_list i)^") OF "^(fmt_tmark c)^";")];
fun fmt_uncon_tmark_list ([] : TMARK list) = ""
  | fmt_uncon_tmark_list ([x] : TMARK list) = (fmt_tmark x)^" RANGE <>"
  | fmt_uncon_tmark_list (x::xs : TMARK list) =
    (fmt_uncon_tmark_list [x])^", "^(fmt_uncon_tmark_list xs);
fun fmt_uncon_array_def (FmtInfo : PP_FMT_INFO)
        (name, discr, {index=i, comp=c} : ARRAY_DEF) =
    [(FmtInfo, "TYPE "^(fmt_id name)^(fmt_discr_part discr)^
        " IS ARRAY ("^(fmt_uncon_tmark_list i)^") OF "^(fmt_tmark c)^";")];

=TEX

Record types.

=SML

fun fmt_record_type_def (FmtInfo : PP_FMT_INFO)
        (name, discr, {comps=c} : COMPONENT RECORD_TYPE_DEF) =
    [(FmtInfo, "TYPE "^(fmt_id name)^(fmt_discr_part discr)^" IS")]@
    [(FmtInfo, "RECORD")]@
    (fmt_component_list (inc_tabs FmtInfo) c)@
    [(FmtInfo, "END RECORD;")];

=TEX

Type declarations.

=SML

fun fmt_type_def (FmtInfo : PP_FMT_INFO)
        (name, discr, (TDEnumTypeDef x) : TYPE_DEF) =
    (fmt_enum_type_def FmtInfo (name, discr, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO)
        (name, discr, (TDIntTypeDef x) : TYPE_DEF) =
    (fmt_int_type_def FmtInfo (name, discr, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO)
        (name, discr, (TDFloatingTypeDef x) : TYPE_DEF) =
    (fmt_floating_type_def FmtInfo (name, discr, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO)
        (name, discr, (TDFixedTypeDef x) : TYPE_DEF) =
    (fmt_fixed_type_def FmtInfo (name, discr, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO)
        (name, discr, (TDUnconArrayDef x) : TYPE_DEF) =
    (fmt_uncon_array_def FmtInfo (name, discr, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO)
        (name, discr, (TDConArrayDef x) : TYPE_DEF) =
    (fmt_array_def FmtInfo (name, discr, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO) 
        (name, discr, (TDRecordTypeDef x) : TYPE_DEF) =
    (fmt_record_type_def FmtInfo (name, discr, x));
fun fmt_type_decl (FmtInfo : PP_FMT_INFO)
        ({name=n, discr=d, type_def=t} : TYPE_DEF TYPE_DECL) =
    (fmt_type_def (inc_tabs FmtInfo) (n, d, t));

=TEX

Subtype declarations.

=SML

fun fmt_constraint (CRange x : CONSTRAINT) = "RANGE "^fmt_range x
  | fmt_constraint (CIndex x : CONSTRAINT) = (fmt_exp_list x)
  | fmt_constraint (CFloating x : CONSTRAINT) =
    (fmt_floating_point_constraint x)
  | fmt_constraint (CFixed x : CONSTRAINT) =
    (fmt_fixed_point_constraint x);
fun fmt_sub_ind ({tmark=t, con=c} : CONSTRAINT SUB_IND) =
    (fmt_tmark t)^" "^(fmt_constraint c);
fun fmt_subtype_decl (FmtInfo : PP_FMT_INFO)
        ({name=n, sub_ind=s} : CONSTRAINT SUBTYPE_DECL) =
    [(FmtInfo, "SUBTYPE "^(fmt_id n)^" IS "^(fmt_sub_ind s)^";")];

=TEX

Private type declarations.

=SML

fun fmt_private_type_decl (FmtInfo : PP_FMT_INFO)
        ({id=i, limited=l} : PRIVATE_TYPE_DECL) =
    [(FmtInfo, "TYPE "^(fmt_id i)^" IS"^
        (if l=true then " LIMITED" else "")^" PRIVATE;")];

=TEX

Basic declarations.

=SML

fun fmt_basic_decl (FmtInfo : PP_FMT_INFO) (BDConstDecl x : BASIC_DECL) =
    (fmt_const_decl FmtInfo x)
  | fmt_basic_decl (FmtInfo : PP_FMT_INFO)
        (BDDeferredConstDecl x : BASIC_DECL) =
    (fmt_deferred_const_decl FmtInfo x)
  | fmt_basic_decl (FmtInfo : PP_FMT_INFO) (BDTypeDecl x : BASIC_DECL) =
    (fmt_type_decl FmtInfo x)
  | fmt_basic_decl (FmtInfo : PP_FMT_INFO) (BDVarDecl x : BASIC_DECL) =
    (fmt_var_decl FmtInfo x)
  | fmt_basic_decl (FmtInfo : PP_FMT_INFO) (BDSubtypeDecl x : BASIC_DECL) =
    (fmt_subtype_decl FmtInfo x)
  | fmt_basic_decl (FmtInfo : PP_FMT_INFO) (BDPrivateTypeDecl x : BASIC_DECL ) =
    (fmt_private_type_decl FmtInfo x);

=TEX

\subsection{Procedure and Function specifications}

Procedure and Function parameter specifications.

=SML

fun fmt_parameter_specification ({idlist=i, mode=m, name=n} :
        PARAMETER_SPECIFICATION) =
    (fmt_id_list i)^" :"^(fmt_mode m)^(fmt_tmark n);
fun fmt_parameter_specification_list1 ([] : PARAMETER_SPECIFICATION list) = ""
  | fmt_parameter_specification_list1 ([x] : PARAMETER_SPECIFICATION list) =
    (fmt_parameter_specification x)
  | fmt_parameter_specification_list1 (x::xs : PARAMETER_SPECIFICATION list) =
    (fmt_parameter_specification x)^"; "^(fmt_parameter_specification_list1 xs);
fun fmt_parameter_specification_list ([] : PARAMETER_SPECIFICATION list) = ""
  | fmt_parameter_specification_list (xs : PARAMETER_SPECIFICATION list) =
    " ("^(fmt_parameter_specification_list1 xs)^")";

=TEX

Procedure and Function specifications.

=SML

fun fmt_procedure_specification (FmtInfo : PP_FMT_INFO)
        ({name=n, formal_part=f, spec=Value s} : PROCEDURE_SPECIFICATION) =
    [(FmtInfo, "PROCEDURE "^(fmt_id n)^(fmt_parameter_specification_list f))]@
    [((inc_tabs FmtInfo), (fmt_spec s))]
  | fmt_procedure_specification (FmtInfo : PP_FMT_INFO)
        ({name=n, formal_part=f, spec=Nil} : PROCEDURE_SPECIFICATION) =
    [(FmtInfo, "PROCEDURE "^(fmt_id n)^(fmt_parameter_specification_list f))];
fun fmt_function_specification (FmtInfo : PP_FMT_INFO)
        ({designator=d, return=r, formal_part=f, spec=Value s} :
        FUNCTION_SPECIFICATION) =
    [(FmtInfo, "FUNCTION "^(fmt_id d)^
        (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark r))]@
    [((inc_tabs FmtInfo), (fmt_spec s))]
  | fmt_function_specification  (FmtInfo : PP_FMT_INFO)
        ({designator=d, return=r, formal_part=f, spec=Nil} :
        FUNCTION_SPECIFICATION) =
    [(FmtInfo, "FUNCTION "^(fmt_id d)^
        (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark r))];

=TEX

Subprograms.

=SML

fun fmt_subprogram_specification (FmtInfo : PP_FMT_INFO)
        (SSProcedure x : SUBPROGRAM_SPECIFICATION) =
    (fmt_procedure_specification FmtInfo x)
  | fmt_subprogram_specification (FmtInfo : PP_FMT_INFO)
        (SSFunction x : SUBPROGRAM_SPECIFICATION) =
    (fmt_function_specification FmtInfo x);

=TEX

Renaming declarations.

=SML

fun fmt_function_renaming (FmtInfo : PP_FMT_INFO)
        ({opsym1=o1, formal_part=f, tmark=t, name=n, opsym2=o2} :
        FUNCTION_RENAMING) =
    [(FmtInfo, "FUNCTION \""^(fmt_operator_symbol o1)^"\""^
        (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark t)^
        " RENAMES "^(fmt_id n)^".\""^(fmt_operator_symbol o2)^"\";")];
fun fmt_subprogram_renaming (FmtInfo : PP_FMT_INFO)
        ({subprogram_specification=s, name1=n1, name2=n2} :
        SUBPROGRAM_RENAMING) =
    (fmt_subprogram_specification FmtInfo s)@
    [((inc_tabs FmtInfo), " RENAMES "^(fmt_id n1)^"."^(fmt_id n2)^";")];
fun fmt_renaming_declaration (FmtInfo : PP_FMT_INFO)
        (RDFunction x : RENAMING_DECLARATION) =
    (fmt_function_renaming FmtInfo x)
  | fmt_renaming_declaration (FmtInfo : PP_FMT_INFO)
        (RDSubprogram x : RENAMING_DECLARATION) =
    (fmt_subprogram_renaming FmtInfo x);

=TEX

Representation clauses.

=SML

fun fmt_component_clause (FmtInfo : PP_FMT_INFO)
        ({name=n, exp=e, range=r} : COMPONENT_CLAUSE) =
    [(FmtInfo, (fmt_exp n)^" AT "^(fmt_exp e)^" RANGE "^(fmt_range r)^";")];
fun fmt_component_clause_list (FmtInfo : PP_FMT_INFO)
        ([] : COMPONENT_CLAUSE list) = []
  | fmt_component_clause_list (FmtInfo : PP_FMT_INFO)
        (x::xs : COMPONENT_CLAUSE list) =
    (fmt_component_clause FmtInfo x)@(fmt_component_clause_list FmtInfo xs);
fun fmt_length_clause (FmtInfo : PP_FMT_INFO)
        ({attribute=a, exp=e} : LENGTH_CLAUSE) =
    [(FmtInfo, "FOR "^(fmt_exp a)^" USE "^(fmt_exp e)^";")];
fun fmt_enumeration_representation_clause (FmtInfo : PP_FMT_INFO)
       ({name=n, exp=e} : ENUMERATION_REPRESENTATION_CLAUSE) =
    [(FmtInfo, "FOR "^(fmt_id n)^" USE ("^(fmt_exp e)^");")];
fun fmt_record_representation_clause (FmtInfo : PP_FMT_INFO)
        ({name=n, alignment_opt=Value a,  component_pack=c} :
        RECORD_REPRESENTATION_CLAUSE) =
    [(FmtInfo, "FOR "^(fmt_id n)^" USE")]@
    [((inc_tabs FmtInfo), "RECORD "^(fmt_exp a))]@
    (fmt_component_clause_list (inc_tabs FmtInfo) c)@
    [((inc_tabs FmtInfo), "END RECORD;")]
  | fmt_record_representation_clause (FmtInfo : PP_FMT_INFO)
        ({name=n, alignment_opt=Nil, component_pack=c} :
        RECORD_REPRESENTATION_CLAUSE) =
    [(FmtInfo, "FOR "^(fmt_id n)^" USE")]@
    [((inc_tabs FmtInfo), "RECORD")]@
    (fmt_component_clause_list (inc_tabs FmtInfo) c)@
    [((inc_tabs FmtInfo), "END RECORD;")];
fun fmt_address_clause (FmtInfo : PP_FMT_INFO)
        ({name=n, exp=e} : ADDRESS_CLAUSE) =
    [(FmtInfo, "FOR "^(fmt_id n)^" USE AT "^(fmt_exp e)^";")];
fun fmt_representation_clause (FmtInfo : PP_FMT_INFO)
        (RCLength x : REPRESENTATION_CLAUSE) =
    (fmt_length_clause FmtInfo x)
  | fmt_representation_clause (FmtInfo : PP_FMT_INFO)
        (RCEnumeration x : REPRESENTATION_CLAUSE) =
    (fmt_enumeration_representation_clause FmtInfo x)
  | fmt_representation_clause (FmtInfo : PP_FMT_INFO)
        (RCRecord x : REPRESENTATION_CLAUSE) =
    (fmt_record_representation_clause FmtInfo x)
  | fmt_representation_clause (FmtInfo : PP_FMT_INFO)
        (RCAddress x : REPRESENTATION_CLAUSE) =
    (fmt_address_clause FmtInfo x);

=TEX

Declarations, these are defined simultaneously since they can be recursive.

=SML

fun fmt_procedure_declaration (FmtInfo : PP_FMT_INFO)
       (x : PROCEDURE_DECLARATION) =
    [(FmtInfo, "PROCEDURE "^(fmt_id (#name x))^";")];
fun fmt_function_declaration (FmtInfo : PP_FMT_INFO)
        (x : FUNCTION_DECLARATION) =
    [(FmtInfo, "FUNCTION "^(fmt_id (#designator x))^
        " RETURN "^(fmt_tmark (#return x))^";")];
fun fmt_procedure_stub (FmtInfo : PP_FMT_INFO) (x : PROCEDURE_DECLARATION) =
    [(FmtInfo, "PROCEDURE "^(fmt_id (#name x))^" IS SEPARATE;")];
fun fmt_function_stub (FmtInfo : PP_FMT_INFO) (x : FUNCTION_DECLARATION) =
    [(FmtInfo, "FUNCTION "^(fmt_id (#designator x))^" RETURN "^
      (fmt_tmark (#return x))^" IS SEPARATE;")];
fun fmt_package_stub (FmtInfo : PP_FMT_INFO) (n : ID) =
    [(FmtInfo, "PACKAGE BODY "^(fmt_id n)^" IS SEPARATE;")];
fun fmt_package_declaration (FmtInfo : PP_FMT_INFO)
        ({name=n, visible_decs=v, private_decs=p} :
    DECLARATION PACKAGE_DECLARATION) =
    [(FmtInfo, "PACKAGE "^(fmt_id n)^" IS")]@
    (fmt_declaration_list (inc_tabs FmtInfo) v)@
    (case p
        of [] => []
         | _ => [(FmtInfo, "PRIVATE")]@
                (fmt_declaration_list (inc_tabs FmtInfo) p)
    )@
    [(FmtInfo, "END "^(fmt_id n)^";")]
and fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DDeclarationKSlot x : DECLARATION) =
    (fmt_k_slot FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DRenamingDeclaration x : DECLARATION) =
    (fmt_renaming_declaration FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DBasicDecl x : DECLARATION) =
    (fmt_basic_decl FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DRepresentationClause x : DECLARATION) =
    (fmt_representation_clause FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DProperBody x : DECLARATION) =
    (fmt_proper_body FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DProcedureDeclaration x : DECLARATION) =
    (fmt_procedure_declaration FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DFunctionDeclaration x : DECLARATION) =
    (fmt_function_declaration FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DPackageDeclaration x : DECLARATION) =
    (fmt_package_declaration FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DProcedureStub x : DECLARATION) =
    (fmt_procedure_stub FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DFunctionStub x : DECLARATION) =
    (fmt_function_stub FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DPackageStub x : DECLARATION) =
    (fmt_package_stub FmtInfo x)
and fmt_declaration_list (FmtInfo : PP_FMT_INFO) ([] : DECLARATION list) = []
  | fmt_declaration_list (FmtInfo : PP_FMT_INFO) (x::xs : DECLARATION list) =
    (fmt_declaration FmtInfo x)@(fmt_declaration_list FmtInfo xs)
and fmt_procedure_body (FmtInfo : PP_FMT_INFO)
        ({procedure_spec=p, declarative_part=d, statement=s} :
         DECLARATION PROCEDURE_BODY) =
    (fmt_procedure_specification FmtInfo p)@
    [(FmtInfo, "IS")]@
    (fmt_declaration_list (inc_tabs FmtInfo) d)@
    [(FmtInfo, "BEGIN")]@
    (fmt_statement (inc_tabs FmtInfo) s)@
    [(FmtInfo, "END "^(fmt_id (#name p))^";")]
and fmt_function_body (FmtInfo : PP_FMT_INFO)
        ({function_spec=f, declarative_part=d, statement=s} :
        DECLARATION FUNCTION_BODY) =
    (fmt_function_specification FmtInfo f)@
    [(FmtInfo, "IS")]@
    (fmt_declaration_list (inc_tabs FmtInfo) d)@
    [(FmtInfo, "BEGIN")]@
    (fmt_statement (inc_tabs FmtInfo) s)@
    [(FmtInfo, "END "^(fmt_id (#designator f))^";")]
and fmt_package_body (FmtInfo : PP_FMT_INFO)
        ({name=n, decls=d, statement=s} : DECLARATION PACKAGE_BODY) =
    [(FmtInfo, "PACKAGE BODY "^(fmt_id n)^" IS")]@
    (fmt_declaration_list (inc_tabs FmtInfo) d)@
    (case s
      of SStmt STImplicitNull => []
      | _ => [(FmtInfo, "BEGIN")]@(fmt_statement (inc_tabs FmtInfo) s)
    )@
    [(FmtInfo, "END "^(fmt_id n)^";")]
and fmt_proper_body (FmtInfo : PP_FMT_INFO) (PBProcedure x : PROPER_BODY) =
    (fmt_procedure_body FmtInfo x)
  | fmt_proper_body (FmtInfo : PP_FMT_INFO) (PBFunction x : PROPER_BODY) =
    (fmt_function_body FmtInfo x)
  | fmt_proper_body (FmtInfo : PP_FMT_INFO) (PBPackage x : PROPER_BODY) =
    (fmt_package_body FmtInfo x);

=TEX

Compilation subunits.

=SML

fun fmt_compilation_subunit (FmtInfo : PP_FMT_INFO)
        ({name=n, proper_body=p} : SUBUNIT) =
    [(FmtInfo, "SEPARATE ("^(fmt_exp n)^")")]@(fmt_proper_body (inc_tabs FmtInfo) p);

=TEX

Compilation units.

=SML

fun fmt_context_clause (FmtInfo : PP_FMT_INFO) ([] : ID list) = []
  | fmt_context_clause (FmtInfo : PP_FMT_INFO) (x : ID list) =
    [(FmtInfo, "WITH "^(fmt_id_list x)^";")];
fun fmt_compilation_unit (FmtInfo : PP_FMT_INFO)
        (CUPackageDeclaration x : COMPILATION_UNIT) =
    (fmt_package_declaration FmtInfo x)
  | fmt_compilation_unit (FmtInfo : PP_FMT_INFO)
        (CUProperBody x : COMPILATION_UNIT) =
    (fmt_proper_body FmtInfo x)
  | fmt_compilation_unit (FmtInfo : PP_FMT_INFO)
        (CUSubUnit x : COMPILATION_UNIT) =
    (fmt_compilation_subunit FmtInfo x);
fun fmt_context_compilation_unit (FmtInfo : PP_FMT_INFO)
        ({context=i, comp_unit=c} : CONTEXT_COMPILATION_UNIT) =
    (fmt_context_clause FmtInfo i)@(fmt_compilation_unit FmtInfo c);
fun fmt_kslot_compilation_unit (FmtInfo : PP_FMT_INFO)
        (KCUKSlot x : KSLOT_COMPILATION_UNIT) =
    (fmt_k_slot FmtInfo x)
  | fmt_kslot_compilation_unit (FmtInfo : PP_FMT_INFO)
        (KCUUnit x : KSLOT_COMPILATION_UNIT) =
    (fmt_context_compilation_unit FmtInfo x);
fun fmt_kslot_compilation_unit_list (FmtInfo : PP_FMT_INFO)
    ([] : KSLOT_COMPILATION_UNIT list) = []
  | fmt_kslot_compilation_unit_list (FmtInfo : PP_FMT_INFO)
    (x::xs : KSLOT_COMPILATION_UNIT list) =
    (fmt_kslot_compilation_unit FmtInfo x)@
    (fmt_kslot_compilation_unit_list FmtInfo xs);

=TEX

=SML

fun fmt_replaced_by_comp (FmtInfo : PP_FMT_INFO)
        ({label=l, comp=c} : REPLACED_BY_COMP) =
    [(FmtInfo, (fmt_label l)^"é")]@
    (fmt_kslot_compilation_unit_list (inc_tabs FmtInfo) c);
fun fmt_replaced_by_private_part (FmtInfo : PP_FMT_INFO)
        ({label=l, private=p} : REPLACED_BY_PRIVATE_PART) =
    [(FmtInfo, (fmt_label l)^"é")]@(fmt_declaration_list (inc_tabs FmtInfo) p);
fun fmt_replaced_by_visible_part (FmtInfo : PP_FMT_INFO)
        ({label=l, visible=v} : REPLACED_BY_VISIBLE_PART) =
    [(FmtInfo, (fmt_label l)^"é")]@(fmt_declaration_list (inc_tabs FmtInfo) v);
fun fmt_replaced_by_decl (FmtInfo : PP_FMT_INFO)
        ({label=l, decls=d} : REPLACED_BY_DECL) =
    [(FmtInfo, (fmt_label l)^"é")]@(fmt_declaration_list (inc_tabs FmtInfo) d);
fun fmt_refined_by (FmtInfo : PP_FMT_INFO)
        ({label=l, statement=s} : REFINED_BY) =
    [(FmtInfo, (fmt_label l)^"Ã")]@(fmt_statement (inc_tabs FmtInfo) s);
fun fmt_replaced_by (FmtInfo : PP_FMT_INFO)
        ({label=l, statement=s} : REFINED_BY) =
    [(FmtInfo, (fmt_label l)^"é")]@(fmt_statement (inc_tabs FmtInfo) s);

=TEX

Web Clauses.

=SML

fun fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCCompilation x : WEB_CLAUSE) =
    (fmt_kslot_compilation_unit_list FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCReplacedByCompilation x : WEB_CLAUSE) =
    (fmt_replaced_by_comp FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCReplacedByPrivatePart x : WEB_CLAUSE) =
    (fmt_replaced_by_private_part FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCReplacedByVisiblePart x : WEB_CLAUSE) =
    (fmt_replaced_by_visible_part FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCReplacedByDecl x : WEB_CLAUSE) =
    (fmt_replaced_by_decl FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCRefinedBy x : WEB_CLAUSE) =
    (fmt_refined_by FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCReplacedBy x : WEB_CLAUSE) =
    (fmt_replaced_by FmtInfo x);

=TEX

=SML

end (* of local...in *);
end (* of structure CNPrettyPrinterSupport *);

=TEX


\section{AUXILIARY FUNCTIONS}

=SML

structure ÛSPARKOutputÝ : SPARKOutput = struct
local
	open CNTypes CNPrettyPrinterSupport;
in
=TEX
=SML

type ÛPP_FMT_INFOÝ = CNPrettyPrinterSupport.PP_FMT_INFO;

fun Ûformat_web_clauseÝ (FmtInfo : PP_FMT_INFO) (x : WEB_CLAUSE) : unit =
	diag_line (
		"Start of Web Clause\n"^
		(fmt_info_string_list (fmt_web_clause FmtInfo x ))^
		"End of Web Clause");

val Ûprint_web_clauseÝ : WEB_CLAUSE -> unit = (
	format_web_clause
	{tabs=1,line_length=get_line_length(),fmtfn=fn _ => Nil}
);

=TEX

\subsection{End of structure SPARKOutput}

The structure SPARKOutput is opened.
=SML

end (* of local...in *);
end (* of structure SPARKOutput *);

open SPARKOutput;
=TEX


=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}

=IGN

signature tmp = sig

type CN_FMT_INFO (* = {tabs : int, line_len : int, f : LABEL -> WEB_CLAUSE OPT}; *)

val format_web_clause : (WEB_CLAUSE * CN_FMT_INFO) -> string list;
val wrap_lines : string -> string;
val print_web_clause : WEB_CLAUSE -> unit;
val output_web_clause : {cn: WEB_CLAUSE, out_file: string} : -> unit;

end (* signature tmp *); 
