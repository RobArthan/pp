% imp510.doc   %Z% $Date$ $Revision$ $RCSfile$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: SPARK Output Function}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP510}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}			%% Mandatory field
\TPPtype{Specification}
\TPPkeywords{CN}
\TPPauthor{A.C.~Hayward & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the SPARK output function.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
	Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issue 1.1, \FormatDate{94/03/28}]
  Initial Draft.
\item[Issue 1.2, \FormatDate{94/03/28}]
  Added signature and structure information.

\end{description}
\subsection{Changes Forecast}
\pagebreak
\section{GENERAL}
\subsection{Scope}
The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD510}.
\subsection{Introduction}
\subsection{Purpose and Background}
\subsection{Algorithms}
\subsection{Dependencies}
\subsection{Known Deficencies}
\subsection{Possible Enhancements}
=TEX
\section{PREAMBLE}
=SML
structure SPARKOutput = struct
=TEX
\section{SPARK Output Function}
These functions deal with the low-level output of characters.
=SML
val PPTabSize : int ref = ref 2;
fun set_PPTab_size (x : int) = (PPTabSize := x);
fun get_PPTab_size (() : unit) : int = !PPTabSize;
fun fmt_spaces (i : int) : string = if i=0 then "" else " "^fmt_spaces(i-1);
fun fmt_tabs (i : int) : string = fmt_spaces(i * get_PPTab_size())
=TEX

Leaf functions, these don't call any other functions.
=SML
fun fmt_id (n : ID) : string = n;
fun fmt_tmark (t : TMARK) : string = t;
fun fmt_term (z : TERM) : string =
    (implode o tl o rev o tl o rev o explode o string_of_term)(z);
fun fmt_label ((LExplicit lab) : LABEL) = lab^" "
  | fmt_label (LImplicit : LABEL) = "";
fun fmt_unary_op (UOSparkUnaryAdd : UNARY_OP) = "+"
  | fmt_unary_op (UOSparkUnaryMinus : UNARY_OP) = "-"
  | fmt_unary_op (UOSparkNot : UNARY_OP) = "not "
  | fmt_unary_op (UOSparkAbs : UNARY_OP) = "abs ";
fun fmt_binary_op (BOSparkAnd : BIN_OP) = " and "
  | fmt_binary_op (BOSparkOr : BIN_OP) = " or "
  | fmt_binary_op (BOSparkXor : BIN_OP) = " xor "
  | fmt_binary_op (BOSparkEq : BIN_OP) = " = "
  | fmt_binary_op (BOSparkNotEq : BIN_OP) = " /= "
  | fmt_binary_op (BOSparkLess : BIN_OP) = " < "
  | fmt_binary_op (BOSparkLessEq : BIN_OP) = " <= "
  | fmt_binary_op (BOSparkGreater : BIN_OP) = " > "
  | fmt_binary_op (BOSparkGreaterEq : BIN_OP) = " >= "
  | fmt_binary_op (BOSparkAdd : BIN_OP) = " + "
  | fmt_binary_op (BOSparkMinus : BIN_OP) = " - "
  | fmt_binary_op (BOSparkTimes : BIN_OP) = " * "
  | fmt_binary_op (BOSparkIntdiv : BIN_OP) = " / "
  | fmt_binary_op (BOSparkMod : BIN_OP) = " mod "
  | fmt_binary_op (BOSparkRem : BIN_OP) = " rem "
  | fmt_binary_op (BOSparkExpon : BIN_OP) = " ** "
  | fmt_binary_op (BOSparkMem : BIN_OP) = " in "
  | fmt_binary_op (BOSparkNotmem : BIN_OP) = " not in "
  | fmt_binary_op (BOSparkAndThen : BIN_OP) = " and then "
  | fmt_binary_op (BOSparkConcat : BIN_OP) = " & "
  | fmt_binary_op (BOSparkOrElse : BIN_OP) = " or else ";
fun fmt_mode (MSparkIn : MODE) = " IN "
  | fmt_mode (MSparkOut : MODE) = " OUT "
  | fmt_mode (MSparkInOut : MODE) = " IN OUT ";
fun fmt_loop_direction (LDForwards : LOOP_DIRECTION) = ""
  | fmt_loop_direction (LDReverse : LOOP_DIRECTION) = "REVERSE ";
fun fmt_operator_symbol (s : OPERATOR_SYMBOL) = s;

=TEX
Lists of leaf functions.
=SML

fun fmt_id_list ([] : ID list) = ""
  | fmt_id_list ([x] : ID list) = (fmt_id x)
  | fmt_id_list (x::xs: ID list) = (fmt_id x)^", "^(fmt_id_list xs);
fun fmt_tmark_list ([] : TMARK list) = ""
  | fmt_tmark_list ([x] : TMARK list) = (fmt_tmark x)
  | fmt_tmark_list (x::xs : TMARK list) =
    (fmt_tmark x)^", "^(fmt_tmark_list xs);

=TEX

Equivalences to leaf functions.

=SML

fun fmt_z_pred (z : Z_PRED) : string = fmt_term z;
fun fmt_z_exp (z : Z_EXP) : string = fmt_term z;
fun fmt_z_id (z : Z_ID) = fmt_id z;
fun fmt_attrib (x : ATTRIB) = fmt_id x;
fun fmt_int_lit (x : INT_LIT) = (fmt_id x);
=TEX

Expressions.

=SML
fun fmt_range ({lo=l, hi=Value h} : EXP RANGE) = (fmt_exp l)^".."^(fmt_exp h)
  | fmt_range ({lo=l, hi=Nil} : EXP RANGE) = (fmt_exp l)
and fmt_discrete_range_constrained ({tmark=t, range=r} :
    EXP DISCRETE_RANGE_CONSTRAINED) =
    (fmt_tmark t)^" RANGE "^(fmt_range r)
and fmt_discrete_range ((DRRange x) : DISCRETE_RANGE) = (fmt_range x)
  | fmt_discrete_range ((DRConstrained x) : DISCRETE_RANGE) =
    (fmt_discrete_range_constrained x)
and fmt_agg_choice ((ACAggChoiceRange x) : AGG_CHOICE) = (fmt_discrete_range x)
  | fmt_agg_choice ((ACAggChoiceSingle x) : AGG_CHOICE) = (fmt_exp x)
and fmt_agg_choice_list ([] : AGG_CHOICE list) = ""
  | fmt_agg_choice_list ([x] : AGG_CHOICE list) = (fmt_agg_choice x)
  | fmt_agg_choice_list (x::xs : AGG_CHOICE list) =
    (fmt_agg_choice x)^"|"^(fmt_agg_choice_list xs)
and fmt_named_assoc ({choice=c, comp=e} : (AGG_CHOICE, EXP) NAMED_ASSOC) =
    (fmt_agg_choice_list c)^" => "^(fmt_exp e)
and fmt_named_assoc_list ([] : (AGG_CHOICE, EXP) NAMED_ASSOC list) = ""
  | fmt_named_assoc_list ([x] : (AGG_CHOICE, EXP) NAMED_ASSOC list) =
    (fmt_named_assoc x)
  | fmt_named_assoc_list (x::xs : (AGG_CHOICE, EXP) NAMED_ASSOC list) =
    (fmt_named_assoc x)^", "^(fmt_named_assoc_list xs)
and fmt_others ({others=oth} : EXP OTHERS) = "OTHERS => "^(fmt_exp oth)
and fmt_agg_pos ({tmark=t, comps=c} : EXP AGG_POS) =
    (case (explode t)
        of "_"::"_"::_ => (fmt_exp_list c)
         | _ => (fmt_tmark t)^"'("^(fmt_exp_list c)^")"
    )
and fmt_agg_pos_others ({agg_pos = {tmark=t, comps=c} :
    EXP AGG_POS, others=oth} : EXP AGG_POS_OTHERS) =
    (fmt_tmark t)^"'("^(fmt_exp_list c)^", "^(fmt_others oth)^")"
and fmt_agg_others ({tmark=t, others=oth} : EXP AGG_OTHERS) =
    (fmt_tmark t)^"'("^(fmt_others oth)^")"
and fmt_agg_named ({named_assocs=n} : (AGG_CHOICE, EXP) AGG_NAMED) =
    (fmt_named_assoc_list n)
and fmt_agg_named_others ({tmark=t, agg_named=a, others=oth} :
    (AGG_CHOICE, EXP) AGG_NAMED_OTHERS) =
    (case (explode t)
        of "_"::"_"::_ => (fmt_agg_named a)^", "^(fmt_others oth)
         | _ => (fmt_tmark t)^"'("^(fmt_agg_named a)^", "^(fmt_others oth)^")"
    )
and fmt_rec_agg_named (x : (AGG_CHOICE, EXP) REC_AGG_NAMED) =
    "fmt_rec_agg_named : this error shouldn't be raised"
and fmt_unary_exp ({uop=u, right=r} : EXP UNARY_EXP) =
    (fmt_unary_op u)^(fmt_exp r)
and fmt_bin_exp ({bop=b, left=l, right=r} : EXP BIN_EXP) =
    (fmt_exp l)^(fmt_binary_op b)^(fmt_exp r)
and fmt_attrib_desig ((ADAttrib x) : ATTRIB_DESIG) = fmt_attrib x
  | fmt_attrib_desig ((ADAttribArg (a,e)) : ATTRIB_DESIG) =
    (fmt_attrib a)^"("^(fmt_exp e)^")"
and fmt_attribute ({prefix=p, attribute_desig=a} :
    (EXP, ATTRIB_DESIG) ATTRIBUTE) =
    (fmt_exp p)^"'"^(fmt_attrib_desig a)
and fmt_indexed_comp ({prefix=p, index=i} : EXP INDEXED_COMP) =
    (fmt_exp p)^"("^(fmt_exp i)^")"
and fmt_selected_comp ({prefix=p, selector=s} : EXP SELECTED_COMP) =
    (fmt_exp p)^"."^(fmt_id s)
and fmt_qualified_expression({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) =
    (fmt_tmark t)^"'("^(fmt_exp e)^")"
and fmt_exp ((EId x) : EXP) = (fmt_id x)
  | fmt_exp ((EInt x) : EXP) = (fmt_int_lit x)
  | fmt_exp ((EArrayAggPos x) : EXP) = (fmt_agg_pos x)
  | fmt_exp ((EArrayAggPosOthers x) : EXP) = (fmt_agg_pos_others x)
  | fmt_exp ((EArrayAggOthers x) : EXP) = (fmt_agg_others x)
  | fmt_exp ((EArrayAggNamed x) : EXP) = (fmt_agg_named x)
  | fmt_exp ((EArrayAggNamedOthers x) : EXP) = (fmt_agg_named_others x)
  | fmt_exp ((ERecAggPos x) : EXP) = (fmt_agg_pos x)
  | fmt_exp ((ERecAggNamed x) : EXP) = (fmt_rec_agg_named x)
  | fmt_exp ((EUnaryExp x) : EXP) = (fmt_unary_exp x)
  | fmt_exp ((EBinExp x) : EXP) = (fmt_bin_exp x)
  | fmt_exp ((EMemRange x) : EXP) =
    "EMemRange : this error shouldn't be raised"
  | fmt_exp ((EAttribute x) : EXP) = (fmt_attribute x)
  | fmt_exp ((EIndexedComp x) : EXP) = (fmt_indexed_comp x)
  | fmt_exp ((ESelectedComp x) : EXP) = (fmt_selected_comp x)
  | fmt_exp ((EFunCall x) : EXP) = 
    "EFunCall : this error shouldn't be raised"
  | fmt_exp ((EAuxiliaryExp x) : EXP) = "û"^(fmt_z_exp x)^"ý"
  | fmt_exp ((EQualifiedExp x) : EXP) = (fmt_qualified_expression x)
  | fmt_exp ((EBracketed e) : EXP) = ("("^(fmt_exp e)^")")
  | fmt_exp ((EStringLiteral s) : EXP) = "\""^s^"\""
  | fmt_exp ((ECharacterLiteral c) : EXP) = "'"^c^"'"
and fmt_exp_list ([] : EXP list) = ""
  | fmt_exp_list ([x] : EXP list) = (fmt_exp x)
  | fmt_exp_list (x::xs : EXP list) = (fmt_exp x)^", "^(fmt_exp_list xs);

=TEX

A couple of minor functions before we do statements.

=SML

fun fmt_spec ({w=w, w0=w0, pre=pre, post=post, label=l} : SPEC) =
    "„ "^(fmt_id_list w)^" ["^(fmt_z_pred pre)^", "^
    (fmt_z_pred post)^"]"^(fmt_label l)^"\n";
fun fmt_static_exp (x : STATIC_EXP) = (fmt_exp x);
fun fmt_static_range ({lo=l, hi=Value h} : STATIC_EXP RANGE) =
    (fmt_static_exp l)^".."^(fmt_static_exp h)
  | fmt_static_range ({lo=l, hi=Nil} : STATIC_EXP RANGE) =
    (fmt_static_exp l);
fun fmt_cond (c : COND) = (fmt_exp c);
fun fmt_actuals ((APositional x) : (AGG_CHOICE, EXP) ACTUALS) = 
    (case x
        of [] => ""
         | z => " ("^(fmt_exp_list x)^")"
    )
  | fmt_actuals ((ANamed x) : (AGG_CHOICE, EXP) ACTUALS) =
    (case x
        of [] => ""
         | z => " ("^(fmt_named_assoc_list x)^")"
    );
fun fmt_proc_call (({name=n, actuals=e} :
    (AGG_CHOICE, EXP) PROC_CALL), PPTabs) =
    (fmt_tabs PPTabs)^(fmt_id n)^(fmt_actuals e)^";\n";
fun fmt_k_slot ({content=c, label=l} : K_SLOT, PPTabs) =
    (case l
        of LImplicit => (fmt_tabs PPTabs)^c^"\n"
         | LExplicit _ => (fmt_tabs PPTabs)^c^"==>>"^(fmt_label l)^"\n"
    );

=TEX

Statements.

=SML

fun fmt_assign (({name=n, e=e} : ASSIGN), PPTabs) =
    (fmt_tabs PPTabs)^(fmt_exp n)^" := "^(fmt_exp e)^";\n";
fun fmt_spec_no_ivars (s : SPEC_NO_IVARS, PPTabs) =
    (fmt_tabs PPTabs)^(fmt_spec s);
fun fmt_exit_when (({g=g} : EXIT_WHEN), PPTabs) =
    (fmt_tabs PPTabs)^"EXIT WHEN "^(fmt_cond g)^";\n";
fun fmt_return (({e=e} : RETURN), PPTabs) =
    (fmt_tabs PPTabs)^"RETURN "^(fmt_exp e)^"\n"
fun fmt_proc_call_no_ivars ((x :
    (AGG_CHOICE, EXP) PROC_CALL_NO_IVARS), PPTabs) =
    (fmt_proc_call (x, PPTabs))
fun fmt_elsif ((stmt as (STIfThenElse {g=g, p=p, q=q, elsif=true}) :
    STMT), PPTabs) =
    (fmt_tabs PPTabs)^"ELSIF "^(fmt_cond g)^"\n"^
    (fmt_tabs PPTabs)^"THEN\n"^(fmt_stmt (p, PPTabs+1))^
    (fmt_elsif (q, PPTabs))
  | fmt_elsif ((stmt as (STIfThenElse {g=g, p=p, q=q, elsif=false}) :
    STMT), PPTabs) =
    (fmt_tabs PPTabs)^"ELSIF "^(fmt_cond g)^"\n"^
    (fmt_tabs PPTabs)^"THEN\n"^(fmt_stmt (p, PPTabs+1))^
    (case q
        of STImplicitNull => ""
         | z => (fmt_tabs PPTabs)^"ELSE\n"^(fmt_stmt (q, PPTabs+1))
    )
  | fmt_elsif (stmt : STMT, PPTabs) =
    (fmt_tabs PPTabs)^(fmt_stmt (stmt, PPTabs))
and fmt_if_then_else (({g=g, p=p, q=q, elsif=false} :
    STMT IF_THEN_ELSE), PPTabs) =
    (fmt_tabs PPTabs)^"IF "^(fmt_cond g)^"\n"^
    (fmt_tabs PPTabs)^"THEN\n"^(fmt_stmt (p, PPTabs+1))^
    (case q
        of STImplicitNull => ""
         | z => (fmt_tabs PPTabs)^"ELSE\n"^(fmt_stmt (q, PPTabs+1))
    )^(fmt_tabs PPTabs)^"END IF;\n"
  | fmt_if_then_else (({g=g, p=p, q=q, elsif=true} :
    STMT IF_THEN_ELSE), PPTabs) =
    (fmt_tabs PPTabs)^"IF "^(fmt_cond g)^"\n"^
    (fmt_tabs PPTabs)^"THEN\n"^(fmt_stmt (p, PPTabs+1))^
    (fmt_elsif (q, PPTabs))^
    (fmt_tabs PPTabs)^"END IF;\n"
and fmt_case_choice ((CCCaseExp x) : CASE_CHOICE) = (fmt_exp x)
  | fmt_case_choice ((CCCaseRange x) : CASE_CHOICE) = (fmt_discrete_range x)
and fmt_case_choice_list ([] : CASE_CHOICE list) = ""
  | fmt_case_choice_list ([x] : CASE_CHOICE list) = (fmt_case_choice x)
  | fmt_case_choice_list (x::xs : CASE_CHOICE list) =
    (fmt_case_choice x)^"|"^(fmt_case_choice_list xs)
and fmt_case_alt (({choices=c, p=s} : STMT CASE_ALTERNATIVE), PPTabs) =
    (fmt_tabs PPTabs)^"WHEN "^(fmt_case_choice_list c)^
    " =>\n"^(fmt_stmt (s, PPTabs+1))
and fmt_case_alt_list([] : STMT CASE_ALTERNATIVE list, PPTabs) = ""
  | fmt_case_alt_list(x::xs : STMT CASE_ALTERNATIVE list, PPTabs) =
    (fmt_case_alt (x, PPTabs))^(fmt_case_alt_list (xs, PPTabs))
and fmt_case (({e=e, s=s, others=oth} : STMT CASE), PPTabs) =
    (fmt_tabs PPTabs)^"CASE "^(fmt_exp e)^" IS\n"^
    (fmt_case_alt_list (s, PPTabs+1))^
    (
      case oth
      of STImplicitNull => ""
       | _ => (fmt_tabs PPTabs)^"WHEN OTHERS =>\n"^(fmt_stmt (oth, PPTabs+1))
    )^
    (fmt_tabs PPTabs)^"END CASE;\n"
and fmt_unnamed_loop (({t=Value t, stmt=s} : STMT LOOP), PPTabs) =
    (fmt_tabs PPTabs)^"TILL û"^(fmt_z_pred t)^"ý\n"^
    (fmt_tabs PPTabs)^"LOOP\n"^
    (fmt_stmt (s, PPTabs+1))^
    (fmt_tabs PPTabs)^"END LOOP;\n"
  | fmt_unnamed_loop (({t=Nil, stmt=s} : STMT LOOP), PPTabs) =
    (fmt_tabs PPTabs)^"LOOP\n"^
    (fmt_stmt (s, PPTabs+1))^
    (fmt_tabs PPTabs)^"END LOOP;\n"
and fmt_named_loop(({name=n, t=Value t, stmt=s} : STMT NAMED_LOOP), PPTabs) =
    (fmt_tabs PPTabs)^(fmt_id n)^":\n"^
    (fmt_tabs PPTabs)^"TILL û"^(fmt_z_pred t)^"ý\n"^
    (fmt_tabs PPTabs)^"LOOP\n"^
    (fmt_stmt (s, PPTabs+1))^
    (fmt_tabs PPTabs)^"END LOOP "^(fmt_id n)^";\n"
  | fmt_named_loop(({name=n, t=Nil, stmt=s} : STMT NAMED_LOOP), PPTabs) =
    (fmt_tabs PPTabs)^(fmt_id n)^":\n"^
    (fmt_tabs PPTabs)^"LOOP\n"^
    (fmt_stmt (s, PPTabs+1))^
    (fmt_tabs PPTabs)^"END LOOP "^(fmt_id n)^";\n"
and fmt_loop_body (({t=Value t, stmt=s} : STMT LOOP), PPTabs) =
    (fmt_tabs PPTabs)^"TILL û"^(fmt_z_pred t)^"ý\n"^
    (fmt_tabs PPTabs)^"LOOP\n"^
    (fmt_stmt (s, PPTabs+1))
  | fmt_loop_body (({t=Nil, stmt=s} : STMT LOOP), PPTabs) =
    (fmt_tabs PPTabs)^"LOOP\n"^
    (fmt_stmt (s, PPTabs+1))
and fmt_while (({name=Value n, g=g, loop=l} : STMT WHILE), PPTabs) =
    (fmt_tabs PPTabs)^(fmt_id n)^":\n"^
    (fmt_tabs PPTabs)^"WHILE "^(fmt_cond g)^"\n"^
    (fmt_loop_body (l, PPTabs))^
    (fmt_tabs PPTabs)^"END LOOP "^(fmt_id n)^";\n"
  | fmt_while (({name=Nil, g=g, loop=l} : STMT WHILE), PPTabs) =
    (fmt_tabs PPTabs)^"WHILE "^(fmt_cond g)^"\n"^
    (fmt_loop_body (l, PPTabs))^
    (fmt_tabs PPTabs)^"END LOOP;\n"
and fmt_for_static (({name=Value n, tmark=t, i=i, dir=d, lo=l, hi=h, loop=loop}:
    STMT FOR_STATIC), PPTabs) =
    (fmt_tabs PPTabs)^(fmt_id n)^":\n"^
    (fmt_tabs PPTabs)^"FOR "^(fmt_id i)^" IN "^
    (fmt_loop_direction d)^(fmt_tmark t)^" RANGE "^
    (fmt_static_range {lo=l, hi=h})^"\n"^
    (fmt_loop_body (loop, PPTabs))^
    (fmt_tabs PPTabs)^"END LOOP "^(fmt_id n)^";\n"
  | fmt_for_static (({name=Nil, tmark=t, i=i, dir=d, lo=l, hi=h, loop=loop} :
    STMT FOR_STATIC), PPTabs) =
    (fmt_tabs PPTabs)^"FOR "^(fmt_id i)^" IN "^(fmt_loop_direction d)^
    (fmt_tmark t)^" RANGE "^(fmt_static_range {lo=l, hi=h})^"\n"^
    (fmt_loop_body (loop, PPTabs))^
    (fmt_tabs PPTabs)^"END LOOP;\n"
and fmt_for_tmark (({name=Value n, i=i, tmark=t, dir=d, loop=loop} :
    STMT FOR_TMARK), PPTabs) =
    (fmt_tabs PPTabs)^(fmt_id n)^":\n"^(fmt_tabs PPTabs)^"FOR "^
    (fmt_id i)^" IN "^
    (fmt_loop_direction d)^(fmt_tmark t)^"\n"^
    (fmt_loop_body (loop, PPTabs))^
    (fmt_tabs PPTabs)^"END LOOP "^(fmt_id n)^";\n"
  | fmt_for_tmark (({name=Nil, i=i, tmark=t, dir=d, loop=loop} :
    STMT FOR_TMARK), PPTabs) =
    (fmt_tabs PPTabs)^"FOR "^(fmt_id i)^" IN "^(fmt_loop_direction d)^
    (fmt_tmark t)^"\n"^
    (fmt_loop_body (loop, PPTabs))^
    (fmt_tabs PPTabs)^"END LOOP;\n"
and fmt_stmt (STNull : STMT, PPTabs : int) = (fmt_tabs PPTabs)^("NULL;\n")
  | fmt_stmt (STImplicitNull : STMT, PPTabs: int) = ""
  | fmt_stmt ((STAssign x) : STMT, PPTabs) = (fmt_assign (x, PPTabs))
  | fmt_stmt ((STSpecNoIvars x) : STMT, PPTabs) =
    (fmt_spec_no_ivars (x, PPTabs))
  | fmt_stmt ((STSemicolon (a,b)) : STMT, PPTabs) =
    (fmt_stmt (a,PPTabs))^(fmt_stmt (b,PPTabs))
  | fmt_stmt ((STIfThenElse x) : STMT, PPTabs) = (fmt_if_then_else (x, PPTabs))
  | fmt_stmt ((STCase x) : STMT, PPTabs) = (fmt_case (x, PPTabs))
  | fmt_stmt ((STLoop x) : STMT, PPTabs) = (fmt_unnamed_loop (x, PPTabs))
  | fmt_stmt ((STNamedLoop x) : STMT, PPTabs) = (fmt_named_loop (x, PPTabs))
  | fmt_stmt ((STWhile x) : STMT, PPTabs) = (fmt_while (x, PPTabs))
  | fmt_stmt ((STForStatic x) : STMT, PPTabs) = (fmt_for_static (x, PPTabs))
  | fmt_stmt ((STForTmark x) : STMT, PPTabs) = (fmt_for_tmark (x, PPTabs))
  | fmt_stmt ((STExitWhen x) : STMT, PPTabs) = (fmt_exit_when (x, PPTabs))
  | fmt_stmt (STExit : STMT, PPTabs) = (fmt_tabs PPTabs)^("EXIT;\n")
  | fmt_stmt ((STRet x) : STMT, PPTabs)  = (fmt_return (x, PPTabs))
  | fmt_stmt ((STProcNoIvars x) : STMT, PPTabs) =
    (fmt_proc_call_no_ivars (x, PPTabs))
  | fmt_stmt ((STKSlot x) : STMT, PPTabs) = (fmt_k_slot (x, PPTabs));

=TEX

Logical constructs.

=SML

(* we don't print out pre1 since it doesn't come from the user *)
fun fmt_log_con ((({x=x, e=e, spec=s, pre1=p} : LOG_CON), stmt :
    STMT), PPTabs) =
    (fmt_tabs PPTabs)^"CON "^(fmt_z_id x)^" : "^(fmt_z_exp e)^
    " "^(fmt_spec s)^(fmt_stmt (stmt, PPTabs));

=TEX

Top level statements.

=SML

fun fmt_statement (SStmt x, PPTabs) = (fmt_stmt (x, PPTabs))
  | fmt_statement (SSpecIvars x,PPTabs) =
    "SSpecIvars : this error shouldn't be raised\n"
  | fmt_statement (SForNonStatic x,PPTabs) = 
    "SForNonStatic : this error shouldn't be raised\n"
  | fmt_statement (SLogCon x,PPTabs) = fmt_log_con (x, PPTabs)
  | fmt_statement (SProcIvars x,PPTabs) =
    "SProcIvars : this error shouldn't be raised\n";

=TEX

Variable declarations.

=SML

fun fmt_var_decl (({vars=v, tmark=t} : VAR_DECL), PPTabs) =
    (fmt_tabs PPTabs)^(fmt_id_list v)^" : "^(fmt_tmark t)^";\n";
fun fmt_var_decl_list ([] : VAR_DECL list, PPTabs) = ""
  | fmt_var_decl_list (x::xs : VAR_DECL list, PPTabs) =
    (fmt_var_decl (x, PPTabs))^(fmt_var_decl_list (xs, PPTabs));

=TEX

Constant and deferred constant declarations.

=SML

fun fmt_const_decl (({consts=c, tm=t, expr=e} : EXP CONST_DECL), PPTabs) =
    (fmt_tabs PPTabs)^(fmt_id_list c)^" : CONSTANT "^
    (fmt_tmark t)^" := "^(fmt_exp e)^";\n";
fun fmt_deferred_const_decl (({consts=c, tmark=t} :
    DEFERRED_CONST_DECL), PPTabs) =
    (fmt_tabs PPTabs)^(fmt_id_list c)^" : CONSTANT "^(fmt_tmark t)^";\n";

=TEX

Minor functions before type definitions.

=SML

fun fmt_variant (({ids=i, comp=c} : COMPONENT VARIANT), PPTabs) =
    (fmt_tabs PPTabs)^"WHEN "^(fmt_id_list i)^" =>\n"^
    (fmt_component_list (c, PPTabs+1))
and fmt_variant_list ([] : COMPONENT VARIANT list, PPTabs) = ""
  | fmt_variant_list (x::xs : COMPONENT VARIANT list, PPTabs) =
    (fmt_variant (x, PPTabs))^(fmt_variant_list (xs, PPTabs))
and fmt_variant_part (({id=i, variants=v} : COMPONENT VARIANT_PART), PPTabs) =
    (fmt_tabs PPTabs)^"CASE "^(fmt_id i)^" IS\n"^
    (fmt_variant_list (v, PPTabs+1))^
    (fmt_tabs PPTabs)^"END CASE;\n"
and fmt_declaration_variant (({decls=d, variant=v} :
    COMPONENT DECLARATION_VARIANT), PPTabs) =
    (fmt_var_decl_list (d, PPTabs))^(fmt_variant_part (v, PPTabs))
and fmt_component ((CDeclaration x) : COMPONENT, PPTabs) =
    fmt_var_decl_list (x, PPTabs)
  | fmt_component ((CVariantPart x) : COMPONENT, PPTabs) =
    fmt_variant_part (x, PPTabs)
  | fmt_component ((CDeclarationVariant x) : COMPONENT, PPTabs) =
    fmt_declaration_variant (x, PPTabs)
  | fmt_component ((CNone) : COMPONENT, PPTabs) = (fmt_tabs PPTabs)^"NULL\n"
and fmt_component_list ([] : COMPONENT list, PPTabs) = ""
  | fmt_component_list ([x] : COMPONENT list, PPTabs) =
    (fmt_component (x, PPTabs))
  | fmt_component_list (x::xs : COMPONENT list, PPTabs) =
    (fmt_component (x, PPTabs))^(fmt_component_list (xs, PPTabs));

=TEX

Discriminant part.

=SML

fun fmt_discr_part (Value {vars=v, tmark=t} : DISCR_PART) =
    " "^(fmt_id_list v)^" : "^(fmt_tmark t)
  | fmt_discr_part (Nil : DISCR_PART) = "";

=TEX

Floating point types.

=SML

fun fmt_floating_point_constraint ({exp=e, range=Value r} :
    EXP FLOATING_POINT_CONSTRAINT) =
    "DIGITS "^(fmt_exp e)^" RANGE "^(fmt_range r)^";\n"
  | fmt_floating_point_constraint ({exp=e, range=Nil} :
    EXP FLOATING_POINT_CONSTRAINT) =
    "DIGITS "^(fmt_exp e)^";\n";
fun fmt_floating_type_def (x : EXP FLOATING_TYPE_DEF) =
    (fmt_floating_point_constraint x);

=TEX

Fixed point types.

=SML

fun fmt_fixed_point_constraint ({exp=e, range=Value r} :
    EXP FIXED_POINT_CONSTRAINT) =
    "DELTA "^(fmt_exp e)^" RANGE "^(fmt_range r)^";\n"
  | fmt_fixed_point_constraint ({exp=e, range=Nil} :
    EXP FIXED_POINT_CONSTRAINT) =
    "DELTA "^(fmt_exp e)^";\n";
fun fmt_fixed_type_def (x : EXP FIXED_TYPE_DEF) =
    (fmt_fixed_point_constraint x);

=TEX

Enumerated types.

=SML

fun fmt_enum_type_def ({vals=v} : ENUM_TYPE_DEF) =
    "("^(fmt_id_list v)^");\n";

=TEX

Array types.

=SML

fun fmt_array_def ({index=i, comp=c} : ARRAY_DEF) =
    "ARRAY ("^(fmt_tmark_list i)^") OF "^(fmt_tmark c)^";\n";

=TEX

Record types.

=SML

fun fmt_record_type_def (({comps=c} : COMPONENT RECORD_TYPE_DEF), PPTabs) =
    "\n"^(fmt_tabs PPTabs)^"RECORD\n"^(fmt_component_list (c, PPTabs+1))^
    (fmt_tabs PPTabs)^"END RECORD;\n";

=TEX

Type declarations.

=SML

fun fmt_type_def ((TDEnumTypeDef x) : TYPE_DEF, PPTabs) =
    (fmt_enum_type_def x)
  | fmt_type_def ((TDIntTypeDef x) : TYPE_DEF, PPTabs) =
    "RANGE "^(fmt_range x)^";\n"
  | fmt_type_def ((TDFloatingTypeDef x) : TYPE_DEF, PPTabs) =
    (fmt_floating_type_def x)
  | fmt_type_def ((TDFixedTypeDef x) : TYPE_DEF, PPTabs) =
    (fmt_fixed_type_def x)
  | fmt_type_def ((TDUnconArrayDef x) : TYPE_DEF, PPTabs) =
    (fmt_array_def x)
  | fmt_type_def ((TDConArrayDef x) : TYPE_DEF, PPTabs) =
    (fmt_array_def x)
  | fmt_type_def ((TDRecordTypeDef x) : TYPE_DEF, PPTabs) =
    (fmt_record_type_def (x, PPTabs));
fun fmt_type_decl ({name=n, discr=d, type_def=t} :
    TYPE_DEF TYPE_DECL, PPTabs) =
   (fmt_tabs PPTabs)^"TYPE "^(fmt_id n)^(fmt_discr_part d)^
    " IS "^(fmt_type_def (t, PPTabs+1));

=TEX

Subtype declarations.

=SML

fun fmt_constraint ((CRange x) : CONSTRAINT) = "RANGE "^fmt_range x^";\n"
  | fmt_constraint ((CFloating x) : CONSTRAINT) =
    (fmt_floating_point_constraint x)
  | fmt_constraint ((CFixed x) : CONSTRAINT) = (fmt_fixed_point_constraint x);
fun fmt_sub_ind ({tmark=t, con=c} : CONSTRAINT SUB_IND) =
    (fmt_tmark t)^" "^(fmt_constraint c);
fun fmt_subtype_decl (({name=n, sub_ind=s} : CONSTRAINT SUBTYPE_DECL), PPTabs) =
    (fmt_tabs PPTabs)^"SUBTYPE "^(fmt_id n)^" IS "^(fmt_sub_ind s);

=TEX

Private type declarations.

=SML

fun fmt_private_type_decl (({id=i, limited=l} : PRIVATE_TYPE_DECL), PPTabs) =
    (fmt_tabs PPTabs)^"TYPE "^(fmt_id i)^" IS"^
    (if l=true then " LIMITED" else "")^
    " PRIVATE;\n";

=TEX

Basic declarations.

=SML

fun fmt_basic_decl ((BDConstDecl x) : BASIC_DECL, PPTabs) =
    fmt_const_decl (x, PPTabs)
  | fmt_basic_decl ((BDDeferredConstDecl x) : BASIC_DECL, PPTabs) =
    fmt_deferred_const_decl (x, PPTabs)
  | fmt_basic_decl ((BDTypeDecl x) : BASIC_DECL, PPTabs) =
    fmt_type_decl (x, PPTabs)
  | fmt_basic_decl ((BDVarDecl x) : BASIC_DECL, PPTabs) =
    fmt_var_decl (x, PPTabs)
  | fmt_basic_decl ((BDSubtypeDecl x) : BASIC_DECL, PPTabs) =
    fmt_subtype_decl (x, PPTabs)
  | fmt_basic_decl ((BDPrivateTypeDecl x) : BASIC_DECL ,PPTabs) =
    fmt_private_type_decl (x, PPTabs);

=TEX

Procedure and Function parameter specifications.

=SML

fun fmt_parameter_specification ({idlist=i, mode=m, name=n} :
    PARAMETER_SPECIFICATION) =
    (fmt_id_list i)^" :"^(fmt_mode m)^(fmt_tmark n);
fun fmt_parameter_specification_list1 ([] : PARAMETER_SPECIFICATION list) = ""
  | fmt_parameter_specification_list1 ([x] : PARAMETER_SPECIFICATION list) =
    (fmt_parameter_specification x)
  | fmt_parameter_specification_list1 (x::xs : PARAMETER_SPECIFICATION list) =
    (fmt_parameter_specification x)^"; "^(fmt_parameter_specification_list1 xs);
fun fmt_parameter_specification_list ([] : PARAMETER_SPECIFICATION list) = ""
  | fmt_parameter_specification_list (xs : PARAMETER_SPECIFICATION list) =
    " ("^(fmt_parameter_specification_list1 xs)^")";

=TEX

Procedure and Function specifications.

=SML

fun fmt_procedure_specification ({name=n, formal_part=f, spec=Value s} :
    PROCEDURE_SPECIFICATION, PPTabs) =
    (fmt_tabs PPTabs)^"PROCEDURE "^(fmt_id n)^
    (fmt_parameter_specification_list f)^" "^(fmt_spec s)
  | fmt_procedure_specification ({name=n, formal_part=f, spec=Nil} :
    PROCEDURE_SPECIFICATION, PPTabs) =
    (fmt_tabs PPTabs)^"PROCEDURE "^(fmt_id n)^
    (fmt_parameter_specification_list f);
fun fmt_function_specification
    ({designator=d, return=r, formal_part=f, spec=Value s} :
    FUNCTION_SPECIFICATION, PPTabs) =
    (fmt_tabs PPTabs)^"FUNCTION "^(fmt_id d)^
    (fmt_parameter_specification_list f)^
    " RETURN "^(fmt_tmark r)^" "^(fmt_spec s)
  | fmt_function_specification
    ({designator=d, return=r, formal_part=f, spec=Nil} :
    FUNCTION_SPECIFICATION, PPTabs) =
    (fmt_tabs PPTabs)^"FUNCTION "^(fmt_id d)^
    (fmt_parameter_specification_list f)^
    " RETURN "^(fmt_tmark r);

=TEX

Subprograms.

=SML

fun fmt_subprogram_specification ((SSProcedure x :
    SUBPROGRAM_SPECIFICATION), PPTabs) = fmt_procedure_specification (x, PPTabs)
  | fmt_subprogram_specification ((SSFunction x :
    SUBPROGRAM_SPECIFICATION), PPTabs) = fmt_function_specification (x, PPTabs)

=TEX

Renaming declarations.

=SML

fun fmt_function_renaming
    (({opsym1=o1, formal_part=f, tmark=t, name=n, opsym2=o2} :
    FUNCTION_RENAMING), PPTabs) =
    (fmt_tabs PPTabs)^"FUNCTION "^(fmt_operator_symbol o1)^
    (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark t)^
    " RENAMES "^(fmt_id n)^"."^(fmt_operator_symbol o2)^";\n";
fun fmt_subprogram_renaming (({subprogram_specification=s, name1=n1, name2=n2} :
    SUBPROGRAM_RENAMING), PPTabs) =
    (fmt_subprogram_specification (s, PPTabs))^" RENAMES "^
    (fmt_id n1)^"."^(fmt_id n2)^";\n";
fun fmt_renaming_declaration ((RDFunction x : RENAMING_DECLARATION), PPTabs) =
    (fmt_function_renaming (x, PPTabs))
  | fmt_renaming_declaration ((RDSubprogram x : RENAMING_DECLARATION), PPTabs) =
    (fmt_subprogram_renaming (x, PPTabs));

=TEX

Representation clauses.

=SML

fun fmt_component_clause (({name=n, exp=e, range=r} :
    COMPONENT_CLAUSE), PPTabs) =
    (fmt_tabs PPTabs)^(fmt_exp n)^" AT "^(fmt_exp e)^
    " RANGE "^(fmt_range r)^";\n";
fun fmt_component_clause_list (([] : COMPONENT_CLAUSE list), PPTabs) = ""
  | fmt_component_clause_list ((x::xs : COMPONENT_CLAUSE list), PPTabs) =
    (fmt_component_clause (x, PPTabs))^(fmt_component_clause_list (xs, PPTabs));
fun fmt_length_clause (({attribute=a, exp=e} : LENGTH_CLAUSE), PPTabs) =
    (fmt_tabs PPTabs)^"FOR "^(fmt_exp a)^" USE "^(fmt_exp e)^";\n";
fun fmt_enumeration_representation_clause (({name=n, exp=e} :
    ENUMERATION_REPRESENTATION_CLAUSE), PPTabs) =
    (fmt_tabs PPTabs)^"FOR "^(fmt_id n)^" USE ("^(fmt_exp e)^");\n";
fun fmt_record_representation_clause
    (({name=n, alignment_opt=Value a, component_pack=c} :
    RECORD_REPRESENTATION_CLAUSE), PPTabs) =
    (fmt_tabs PPTabs)^"FOR "^(fmt_id n)^" USE\n"^
    (fmt_tabs (PPTabs+1))^"RECORD "^(fmt_exp a)^"\n"^
    (fmt_component_clause_list (c, PPTabs+1))^
    (fmt_tabs (PPTabs+1))^"END RECORD;\n"
  | fmt_record_representation_clause
    (({name=n, alignment_opt=Nil, component_pack=c} :
    RECORD_REPRESENTATION_CLAUSE), PPTabs) =
    (fmt_tabs PPTabs)^"FOR "^(fmt_id n)^" USE\n"^
    (fmt_tabs (PPTabs+1))^"RECORD\n"^
    (fmt_component_clause_list (c, PPTabs+1))^
    (fmt_tabs (PPTabs+1))^"END RECORD;\n";
fun fmt_address_clause (({name=n, exp=e} : ADDRESS_CLAUSE), PPTabs) =
    (fmt_tabs PPTabs)^"FOR "^(fmt_id n)^" USE AT "^(fmt_exp e)^";\n";
fun fmt_representation_clause ((RCLength x) : REPRESENTATION_CLAUSE, PPTabs) =
    fmt_length_clause (x, PPTabs)
  | fmt_representation_clause ((RCEnumeration x) :
    REPRESENTATION_CLAUSE, PPTabs) =
    fmt_enumeration_representation_clause (x, PPTabs)
  | fmt_representation_clause ((RCRecord x) : REPRESENTATION_CLAUSE, PPTabs) =
    fmt_record_representation_clause (x, PPTabs)
  | fmt_representation_clause ((RCAddress x) : REPRESENTATION_CLAUSE, PPTabs) =
    fmt_address_clause (x, PPTabs);

=TEX

Declarations, these are defined simultaneously since they can be recursive.

=SML

fun fmt_procedure_declaration (x : PROCEDURE_DECLARATION, PPTabs) =
    (fmt_tabs PPTabs)^"PROCEDURE "^(fmt_id (#name x))^"\n";
fun fmt_function_declaration (x : FUNCTION_DECLARATION, PPTabs) =
    (fmt_tabs PPTabs)^"FUNCTION "^(fmt_id (#designator x))^
    " RETURN "^(fmt_tmark (#return x))^"\n";
fun fmt_procedure_stub (x : PROCEDURE_DECLARATION, PPTabs) =
    (fmt_tabs PPTabs)^"PROCEDURE "^(fmt_id (#name x))^" IS SEPARATE;\n";
fun fmt_function_stub (x : FUNCTION_DECLARATION, PPTabs) =
    (fmt_tabs PPTabs)^"FUNCTION "^(fmt_id (#designator x))^" RETURN "^
    (fmt_tmark (#return x))^" IS SEPARATE;\n";
fun fmt_package_stub (n : ID, PPTabs) =
    (fmt_tabs PPTabs)^"PACKAGE BODY "^(fmt_id n)^" IS SEPARATE;\n";
fun fmt_package_declaration (({name=n, visible_decs=v, private_decs=p} :
    DECLARATION PACKAGE_DECLARATION), PPTabs) =
    (fmt_tabs PPTabs)^"PACKAGE "^(fmt_id n)^" IS\n"^
    (fmt_declaration_list (v, PPTabs+1))^
    (case p
        of [] => ""
         | _ => (fmt_tabs PPTabs)^"PRIVATE\n"^
                (fmt_declaration_list (p, PPTabs+1))
    )^
    (fmt_tabs PPTabs)^"END "^(fmt_id n)^";\n\n"
and fmt_declaration ((DDeclarationKSlot x) : DECLARATION, PPTabs) =
    fmt_k_slot (x, PPTabs)
  | fmt_declaration ((DRenamingDeclaration x) : DECLARATION, PPTabs) =
    fmt_renaming_declaration (x, PPTabs)
  | fmt_declaration ((DBasicDecl x) : DECLARATION, PPTabs) =
    fmt_basic_decl (x, PPTabs)
  | fmt_declaration ((DRepresentationClause x) : DECLARATION, PPTabs) =
    fmt_representation_clause (x, PPTabs)
  | fmt_declaration ((DProperBody x) : DECLARATION, PPTabs) =
    fmt_proper_body (x, PPTabs)
  | fmt_declaration ((DProcedureDeclaration x) : DECLARATION, PPTabs) =
    fmt_procedure_declaration (x, PPTabs)
  | fmt_declaration ((DFunctionDeclaration x) : DECLARATION, PPTabs) =
    fmt_function_declaration (x, PPTabs)
  | fmt_declaration ((DPackageDeclaration x) : DECLARATION, PPTabs) =
    fmt_package_declaration (x, PPTabs)
  | fmt_declaration ((DProcedureStub x) : DECLARATION, PPTabs) =
    fmt_procedure_stub (x, PPTabs)
  | fmt_declaration ((DFunctionStub x) : DECLARATION, PPTabs) =
    fmt_function_stub (x, PPTabs)
  | fmt_declaration ((DPackageStub x) : DECLARATION, PPTabs) =
    fmt_package_stub (x, PPTabs)
and fmt_declaration_list ([] : DECLARATION list, PPTabs) = ""
  | fmt_declaration_list (x::xs : DECLARATION list, PPTabs) =
    (fmt_declaration (x, PPTabs))^(fmt_declaration_list (xs, PPTabs))
and fmt_procedure_body (({procedure_spec=p, declarative_part=d, statement=s} :
    DECLARATION PROCEDURE_BODY), PPTabs) =
    (fmt_procedure_specification (p, PPTabs))^" IS\n"^
    (fmt_declaration_list (d, PPTabs+1))^"\n"^
    (fmt_tabs PPTabs)^"BEGIN\n"^
    (fmt_statement (s, PPTabs+1))^
    (fmt_tabs PPTabs)^"END "^(fmt_id (#name p))^";\n\n"
and fmt_function_body (({function_spec=f, declarative_part=d, statement=s} :
    DECLARATION FUNCTION_BODY), PPTabs) =
    (fmt_function_specification (f, PPTabs))^" IS\n"^
    (fmt_declaration_list (d, PPTabs+1))^"\n"^
    (fmt_tabs PPTabs)^"BEGIN\n"^
    (fmt_statement (s, PPTabs+1))^
    (fmt_tabs PPTabs)^"END "^(fmt_id (#designator f))^";\n\n"
and fmt_package_body (({name=n, decls=d, statement=s} :
    DECLARATION PACKAGE_BODY), PPTabs) =
    (fmt_tabs PPTabs)^"PACKAGE BODY "^(fmt_id n)^" IS\n"^
    (fmt_declaration_list (d, PPTabs+1))^"\n"^
    (fmt_tabs PPTabs)^"BEGIN\n"^
    (fmt_statement (s, PPTabs+1))^
    (fmt_tabs PPTabs)^"END "^(fmt_id n)^";\n\n"
and fmt_proper_body ((PBProcedure x) : PROPER_BODY, PPTabs) =
    (fmt_procedure_body (x, PPTabs))
  | fmt_proper_body ((PBFunction x) : PROPER_BODY, PPTabs) =
    (fmt_function_body (x, PPTabs))
  | fmt_proper_body ((PBPackage x) : PROPER_BODY, PPTabs) =
    (fmt_package_body (x, PPTabs));

=TEX

Compilation subunits.

=SML

fun fmt_compilation_subunit (({name=n, proper_body=p} : SUBUNIT), PPTabs) =
    (fmt_tabs PPTabs)^"SEPARATE ("^(fmt_exp n)^")\n"^
    (fmt_proper_body (p, PPTabs+1));

=TEX

Compilation units.

=SML

fun fmt_context_clause ([] : ID list, PPTabs) = ""
  | fmt_context_clause (x : ID list, PPTabs) =
    (fmt_tabs PPTabs)^"WITH "^(fmt_id_list x)^";\n";
fun fmt_compilation_unit ((CUPackageDeclaration x) : COMPILATION_UNIT, PPTabs) =
    fmt_package_declaration (x, PPTabs)
  | fmt_compilation_unit ((CUProperBody x) : COMPILATION_UNIT, PPTabs) =
    fmt_proper_body (x, PPTabs)
  | fmt_compilation_unit ((CUSubUnit x) : COMPILATION_UNIT, PPTabs) =
    fmt_compilation_subunit (x, PPTabs);
fun fmt_context_compilation_unit ({context=i, comp_unit=c} :
    CONTEXT_COMPILATION_UNIT, PPTabs) =
    (fmt_context_clause (i,PPTabs))^(fmt_compilation_unit (c, PPTabs));
fun fmt_kslot_compilation_unit ((KCUKSlot x) : KSLOT_COMPILATION_UNIT, PPTabs) =
    fmt_k_slot (x, PPTabs)
  | fmt_kslot_compilation_unit ((KCUUnit x) : KSLOT_COMPILATION_UNIT, PPTabs) =
    (fmt_context_compilation_unit (x,PPTabs));
fun fmt_kslot_compilation_unit_list ([] :
    KSLOT_COMPILATION_UNIT list, PPTabs) = ""
  | fmt_kslot_compilation_unit_list (x::xs :
    KSLOT_COMPILATION_UNIT list, PPTabs) =
    (fmt_kslot_compilation_unit (x,PPTabs))^
    (fmt_kslot_compilation_unit_list (xs, PPTabs));

=TEX

=SML

fun fmt_replaced_by_comp (({label=l, comp=c} : REPLACED_BY_COMP), PPTabs) =
    (fmt_label l)^"%identical%\n"^(fmt_kslot_compilation_unit_list (c, PPTabs+1));
fun fmt_replaced_by_private_part (({label=l, private=p} :
    REPLACED_BY_PRIVATE_PART), PPTabs) =
    (fmt_label l)^"é\n"^(fmt_declaration_list (p,PPTabs+1));
fun fmt_replaced_by_visible_part (({label=l, visible=v} :
    REPLACED_BY_VISIBLE_PART), PPTabs) =
    (fmt_label l)^"é\n"^(fmt_declaration_list (v,PPTabs+1));
fun fmt_replaced_by_decl (({label=l, decls=d}) : REPLACED_BY_DECL, PPTabs) =
    (fmt_label l)^"é\n"^(fmt_declaration_list (d,PPTabs+1));
fun fmt_refined_by (({label=l, statement=s}) : REFINED_BY, PPTabs) =
    (fmt_label l)^"Ã\n"^(fmt_statement (s,PPTabs+1));
fun fmt_replaced_by (({label=l, statement=s}) : REFINED_BY, PPTabs) =
    (fmt_label l)^"é\n"^(fmt_statement (s,PPTabs+1));

=TEX

Web Clauses.

=SML

fun fmt_web_clause ((WCCompilation x) : WEB_CLAUSE, PPTabs) =
    fmt_kslot_compilation_unit_list (x,PPTabs)
  | fmt_web_clause ((WCReplacedByCompilation x) : WEB_CLAUSE, PPTabs) =
    fmt_replaced_by_comp (x, PPTabs)
  | fmt_web_clause ((WCReplacedByPrivatePart x) : WEB_CLAUSE, PPTabs) =
    fmt_replaced_by_private_part (x, PPTabs)
  | fmt_web_clause ((WCReplacedByVisiblePart x) : WEB_CLAUSE, PPTabs) =
    fmt_replaced_by_visible_part (x, PPTabs)
  | fmt_web_clause ((WCReplacedByDecl x) : WEB_CLAUSE, PPTabs) =
    fmt_replaced_by_decl (x, PPTabs)
  | fmt_web_clause ((WCRefinedBy x) : WEB_CLAUSE, PPTabs) =
    fmt_refined_by (x, PPTabs)
  | fmt_web_clause ((WCReplacedBy x) : WEB_CLAUSE, PPTabs) =
    fmt_replaced_by (x, PPTabs);

fun web (x : WEB_CLAUSE) : unit = diag_line
    ("Start of Web Clause\n"^(fmt_web_clause (x, 0))^"End of Web Clause");
=TEX 
\section{EPILOGUE}
=SML
end;
=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
