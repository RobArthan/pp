% %Z% $Revision$ $RCSfile$ $Date$
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: SPARK Output Function}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP510}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}	    %% Mandatory field
\TPPtype{Specification}
\TPPkeywords{CN}
\TPPauthor{A.C.~Hayward & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the SPARK output function.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
    Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issues 1.1-1.18, \FormatDate{94/03/28}]
Initial Drafts.
\item[Issue 1.19, \FormatDate{94/10/05}]
Added calls to CaseIndependence.get_external_name.
\item[Issue 1.20, \FormateDate{94/10/10}]
Updated in line with changes to SPEC.
\item[Issue 1.21. \FormatDate{94/10/10}]
Removed output_spark_program1 and changed interface to output_spark_program.
\item[Issue 1.22. \FormatDate{94/10/13}]
Added support for auxiliary variables.
\item[Issue 1.23. \FormatDate{94/10/14}]
Fixed bugs in function/procedure declaration handling and corrected aux vars.
\item[Issue 1.24. \FormatDate{94/10/14}]
Removed variant records from the implementation.
\item[Issue 1.25. \FormatDate{94/10/14}]
Added newlines afte compilation units.
\item[Issue 1.26. \FormatDate{94/11/02}]
Fixed problem with outputting the letter Q to a file.
\item[Issue 1.27. \FormatDate{94/11/03}]
Fixed to use get_cn_state rather than !spark_prog.
\item[Issue 1.28. \FormatDate{94/11/03}]
Changed SUBUNIT to COMP_SUBUNIT.
\item[Issue 1.29. \FormatDate{94/11/09}]
Adjusted for new AS constructor.
\item[Issue 1.30. \FormatDate{94/11/14}]
Rationalised the structure wrapping.
\item[Issue 1.31. \FormatDate{94/11/15}]
Replacement env now distinguishes refinements from replacements.
\item[Issue 1.32. \FormatDate{94/11/18}]
Fixed a problem with printing labels (now need to add brackets).
\item[Issue 1.33. \FormatDate{94/11/18}]
Added kslot brackets.
\item[Issue 1.34. \FormatDate{94/11/24}]
Added first cut of calls to the soundness checking algorithm .
\item[Issue 1.35-1.39. \FormatDate{94/12/08}]
Minor corrections.
\item[Issue 1.40]
Renamed call of $get\_cn\_state$ to be $get\_z\_generator\_state$.
\item[Issue 1.41]
Fixed DRA bug 3 (batch 1)
\item[Issue 1.42]
Fixed DRA bug 20 (batch 2)
\item[Issue 1.43]
Fixed DRA bug 5 (batch 2)
\item[Issues 1.44,1.45]
Added annotations and pragmas.
\item[Issues 1.46]
Fixed bug in printing of unreplaced compilation unit k-slot.
\item[Issue 1.47] Enhancement 3.
\item[Issue 1.48] Added name-clash checking (which fixes bug 15 inter alia).
\item[Issue 1.49] Fixed DRA bugs 14 and issue 2 (V0.6).
\item[Issue 1.50] Fixed DRA bug 11 (V0.6).
\item[Issue 1.51,1.52] Fixing DRA bug 3 (V0.6).
\item[Issue 1.53] Made it handle membership of a range properly and tidied error-reporting.
\item[Issue 1.54] Fixed named aggregates with others-part and pragmas without arguments.
\item[Issue 1.55-1.56] Syntax changes.
\item[Issue 1.58 - 1.63] Major rewrite as called for as WP 6 of \cite{ISS/HAT/DAZ/HLD505}.
\item[Issue 1.64] Made file reloadable, by gracefully accepting pre-existence
of integer control.
\item[Issue 1.65] Corrected checking of variable redeclaration rules in subprogram specifications. (bug 6 (v0.7.1)).
\end{description}

\subsection{Changes Forecast}
None.
\pagebreak

\section{GENERAL}
\subsection{Scope}

This document contains the implementation for the Compliance Notation Output functions.  The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD510} and the module tests are in \cite{ISS/HAT/DAZ/MDT503}.

\subsection{Introduction}

\subsection{Purpose and Background}

One signature is implemented in this document, $CNSparkOutput$.  The functions in this signature are not intended to be called directly by the user.  Instead \cite{ISS/HAT/DAZ/DTD516} details some top-level functions which use this signature.

\subsection{Dependencies}

The functions in this signature depend on the data types introduced in the structures $CNTypes$, $CNTypes1$, $CNVCGenerator$, $CNZGenerator$ and $ZUserInterfaceSupport$ which are defined in \cite{ISS/HAT/DAZ/DTD513}, \cite{ISS/HAT/DAZ/DTD514}, \cite{ISS/HAT/DAZ/DTD505}, \cite{ISS/HAT/DAZ/DTD507} and \cite{DS/FMU/IED/DTD079}.

\section{THE STRUCTURE $CNSparkOutput$}

=SML
structure €CNSparkOutput› : CNSparkOutput = struct
=SML
    open    CNTypes CNTypes1 CNVCGenerator CNZGenerator;
    open    ZUserInterfaceSupport;
=TEX
\subsection{Checking for Name Clashes}
This module is responsible for implementing the SPARK rules against redeclaration of identifiers as required in \cite{DRA/CIS/CSE3/TR/94/27/2}, volume 1.
Some checking is done as web clauses are entered, but only when the program is output is all the information needed to make a comprehensive check available.
The following ML data structures and access functions are used to record information about declarations as they are encounetered.

The bool flag is only set true in the call from the functions which print or output the entire SPARK program.
The flag is used to ensure that diagnostic routines etc. using the lower-level formatting routines directly will not indefinitely consume resources.
N.b. some functions use the stack variable directly for special effects, so they must do so in a way which won't consume resources if the flag is false.
=SML
val €clash_checking› : bool ref = ref false;
type €SCOPE› = {block : ID, names : ID list};
val €stack› : SCOPE list ref = ref [];
fun €push_scope› (block : ID) : unit = (
	if	!clash_checking
	then	stack := {block=block, names=[]} :: !stack
	else	()
);
fun €pop_scope› () : unit = (
	if	!clash_checking
	then	case !stack of
			[] => ()
		|	_ :: more => (stack := more)
	else	()
);
=TEX
The following data structures and functions are used to accumulate a list of name-clash errors.
=SML
type €CLASH_INFO› = {name1 : ID list, name2 : ID list};
val €clashes› : CLASH_INFO list ref = ref [];
fun €check_decl› (name : ID) : unit = (
if	!clash_checking
then	let	fun full_name (st : SCOPE list) (n : ID) : ID list = (
			rev(n :: (map #block st less ""))
		);
		fun scan [] = ()
		|   scan (st as ({block, names} :: more)) = (
			if	name mem names
			then	(clashes := !clashes grab
					{name1 = full_name st name,
					name2 = full_name (!stack) name};
				scan more)
			else	scan more
		);
	in	scan (!stack);
		case !stack of
			[] => (
				stack := [{block="", names =[name]}]
		) |	{block, names} :: more => (
				stack :=
				{block=block,names=names grab name}::more
		)
	end
else	()
);
=TEX
In many cases the following gives a convenient idiom:
=SML
fun €in_new_scope› (check_n : bool) (n : ID) (what : unit -> 'b) : 'b = (
	(if check_n then check_decl n else ());
	push_scope n;
	let	val res = what ();
	in	pop_scope ();
		res
	end
);
=TEX
=SML
fun €with_clash_checks› (what : unit -> 'a) : 'a = (
	clashes := [];
	stack := [];
	clash_checking := true;
	let	fun show_name n = format_list Combinators.I n ".";
		fun report_clash {name1, name2} = (
			diag_line
				(get_error_message 510002
					[show_name name1, show_name name2])
		);
		fun report_results cls = (
			case cls of
			[]	=> ()
		|	_ => (
				diag_line (get_error_message 510001 []);
				map report_clash cls;
				fail "clash_checks" 510003 []
			)
		);
		val res = what();
		val cls = !clashes;
	in	clash_checking := false;
		clashes := [];
		report_results cls;
		res
	end
)	handle ex => (clash_checking := false; clashes := []; raise ex);
=TEX
\subsection{Low level functions}

These functions deal with the low-level output of characters.

=SML

local
	val €PPTabSize› : int ref = ref 2;
in
fun €set_PPTab_size› (x : int) = (PPTabSize := x);
fun €get_PPTab_size› ( () : unit) : int = !PPTabSize;
end;

fun €fmt_spaces› (i : int) : string =
   if i<=0 then "" else " "^fmt_spaces(i-1);
fun €fmt_tabs› (i : int) : string = (
	let	val tab_str = fmt_spaces(get_PPTab_size());
		fun aux (j : int) = if (j <= 0) then "" else tab_str ^ aux (j-1);
	in
		aux i
	end);
=TEX
Now we set up the tab state as some global state:
=SML
local
	val €PPTabNo› : int ref = ref 0;
in
fun €set_PPTab_no› (x : int) = (if (x > 0) 
	then PPTabNo := x 
	else PPTabNo := 0;
	());
fun €reset_PPTab_no› (() :unit) = (PPTabNo := 0;());
fun €get_PPTab_no› ( () : unit) : int = !PPTabNo;
end;


type €PP_FMT_INFO› = {
    outf : string -> unit,
    fmtfn : (LABEL -> REPLACEMENT OPT) OPT
    };
=TEX
=TEX
=SML
fun €set_tabs›(i : int) = set_PPTab_no(i);
fun €get_tabs›() = get_PPTab_no();

fun €inc_tabs› (() :unit) =
    (set_PPTab_no(get_PPTab_no() + 1));
fun €dec_tabs› (() :unit) =
    (set_PPTab_no(get_PPTab_no() - 1));
fun €reset_tabs› (() :unit) =
    (reset_PPTab_no());
fun €len_tab› (():unit) : int = (get_PPTab_no() * get_PPTab_size());
=TEX
\subsection{The String from Identifiers}
We need this for both bracket tests and actual output, so
it is given here, in isolation.
=SML
fun €sfmt_id_plus›  ({outf,...} : PP_FMT_INFO) (n : ID) (s : string): string  = (
	let	fun break_up acc (lhs, "o"::rest) = (
			break_up ((implode o rev) lhs::acc) ([], rest)
		) | break_up acc (lhs, (c::rest)) = (
			break_up acc (c::lhs, rest)
		) | break_up acc (lhs, []) = (
			(implode o rev) lhs::acc, ([], [])
		);
		val comps = (	map CaseIndependence.get_external_name o rev
				o fst o (break_up [])) ([], explode n);
		fun fmt_aux (a::b::rest) = (
			a^"."^fmt_aux (b::rest)
		) | fmt_aux (a::rest) = a ^ s
		| fmt_aux [] = s;
	in
		fmt_aux comps
	end
);
=TEX
\subsection{Bracketing}
In a few places it is important not to put extra brackets around a
bracketed construct (e.g., an array index).
We check by having a parallel set of functions for expressions and their fragments
(all prefixed by ``nb''),
which return false if the item is either such that it is not printed
(i.e. its string representation would be empty), or it is already bracketed.
=SML
fun €nb_spaces› (i : int) : bool = if (i > 0) then true else false;
fun €nb_tabs› (i : int) : bool = if (i > 0) then true else false;
fun €nb_z_tm› ({outf,...} : PP_FMT_INFO) (z_tm : Z_TM) : bool = true;

fun €nb_id_plus›  (fmtinfo: PP_FMT_INFO) (n : ID) (s : string): bool = (
	(sfmt_id_plus fmtinfo n s) <> ""
);

fun €nb_id_comma›  (fmtinfo : PP_FMT_INFO) (n : ID) : bool  = true;
fun €nb_id›  (fmtinfo : PP_FMT_INFO) (n : ID) : bool = (nb_id_plus fmtinfo n "");

fun €nb_tmark_plus›  (fmtinfo : PP_FMT_INFO) (t : TMARK) (s : string): bool =
	nb_id_plus fmtinfo t s;
fun €nb_tmark›  (fmtinfo : PP_FMT_INFO) (t : TMARK) : bool = 
	nb_tmark_plus fmtinfo t "";
fun €nb_tmark_comma›  (fmtinfo : PP_FMT_INFO) (t : TMARK) : bool = true;

fun €nb_term›  ({outf,...} : PP_FMT_INFO) (z : TERM) : bool = (
let	val strs = PrettyPrinter.format_term1 false (get_int_control
		"cn_automatic_line_splitting" - len_tab()) z;
in
	(length strs > 1 orelse (length strs = 1 andalso (hd strs <> "")))
end);

fun €nb_label› ({outf,...} : PP_FMT_INFO) (label : LABEL) = false;

fun €nb_unary_op› ({outf,...} : PP_FMT_INFO) (_ : UNARY_OP) = true;

fun €nb_binary_op› ({outf,...} : PP_FMT_INFO)(_ : BIN_OP) = true;

fun €nb_mode› ({outf,...} : PP_FMT_INFO)(_ : MODE) = true;
 
fun €nb_loop_direction› ({outf,...} : PP_FMT_INFO) (LDForwards : LOOP_DIRECTION) = false
  | nb_loop_direction ({outf,...} : PP_FMT_INFO)(LDReverse : LOOP_DIRECTION) = true;

fun €nb_operator_symbol› ({outf,...} : PP_FMT_INFO)(s : OPERATOR_SYMBOL) = s <> "";

fun €nb_id_list› (fmtinfo : PP_FMT_INFO)([] : ID list) = false
  | nb_id_list (fmtinfo : PP_FMT_INFO)([x] : ID list) = (nb_id fmtinfo x)
  | nb_id_list (fmtinfo : PP_FMT_INFO)(x::xs: ID list) = true;

fun €nb_tmark_list› (_ : PP_FMT_INFO)([] : TMARK list) = false
  | nb_tmark_list (fmtinfo : PP_FMT_INFO)([x] : TMARK list) = (nb_tmark fmtinfo x)
  | nb_tmark_list (fmtinfo: PP_FMT_INFO)(x::xs : TMARK list) = true;

fun €nb_z_pred› (fmtinfo : PP_FMT_INFO) (z : Z_PRED) = nb_term fmtinfo z;
fun €nb_z_exp› (fmtinfo : PP_FMT_INFO) (z : Z_EXP) =  nb_term fmtinfo z;
fun €nb_z_id› ({outf, ...} : PP_FMT_INFO) (z : Z_ID) = z <> "";
fun €nb_attrib› (fmtinfo : PP_FMT_INFO) (x : ATTRIB) = nb_id fmtinfo x;
fun €nb_int_lit› (fmtinfo : PP_FMT_INFO) (x : INT_LIT) = nb_id fmtinfo x;

fun €nb_rangelohi› (fmtinfo: PP_FMT_INFO) 
	({lo=l, hi=h} : EXP RANGELOHI) = true
and €nb_range› (fmtinfo: PP_FMT_INFO)(RRange x : EXP RANGE) = true
  | nb_range fmtinfo (RRangeAttr x : EXP RANGE) = nb_exp fmtinfo x
and €nb_discrete_range_constrained› (fmtinfo: PP_FMT_INFO)
		({tmark=t, range=r} : EXP DISCRETE_RANGE_CONSTRAINED) = true
and €nb_discrete_range› (fmtinfo : PP_FMT_INFO) (DRRange x : DISCRETE_RANGE) = (nb_range fmtinfo x)
  | nb_discrete_range (fmtinfo : PP_FMT_INFO)(DRConstrained x : DISCRETE_RANGE) =
    (nb_discrete_range_constrained fmtinfo x)
and €nb_agg_choice› (fmtinfo : PP_FMT_INFO) (ACAggChoiceRange x : AGG_CHOICE) = (nb_discrete_range fmtinfo x)
  | nb_agg_choice (fmtinfo : PP_FMT_INFO) (ACAggChoiceSingle x : AGG_CHOICE) = (nb_exp fmtinfo x)
and €nb_agg_choice_list› (_: PP_FMT_INFO)([] : AGG_CHOICE list) = false
 | nb_agg_choice_list (fmtinfo: PP_FMT_INFO) ([x] : AGG_CHOICE list) = (nb_agg_choice fmtinfo x)
  | nb_agg_choice_list (fmtinfo: PP_FMT_INFO) (x::xs : AGG_CHOICE list) = true
and €nb_named_assoc› (fmtinfo: PP_FMT_INFO)({choice=c, comp=e} : (AGG_CHOICE, EXP) NAMED_ASSOC) = true
and €nb_named_assoc_list› (_: PP_FMT_INFO)([] : (AGG_CHOICE, EXP) NAMED_ASSOC list) = false
  | nb_named_assoc_list (fmtinfo: PP_FMT_INFO) ([x] : (AGG_CHOICE, EXP) NAMED_ASSOC list) =
    (nb_named_assoc fmtinfo x)
  | nb_named_assoc_list (fmtinfo: PP_FMT_INFO) (x::xs : (AGG_CHOICE, EXP) NAMED_ASSOC list) = true
and €nb_others› (fmtinfo: PP_FMT_INFO)({others=oth} : EXP OTHERS) = true
and €nb_agg_pos› (fmtinfo: PP_FMT_INFO) ({tmark=tm, comps=c} : EXP AGG_POS) =
    (case tm
	of Nil => false
	| Value t => true
    )
and €nb_agg_pos_others› (fmtinfo: PP_FMT_INFO) ({agg_pos = {tmark=tm, comps=c} :
    EXP AGG_POS, others = oth} : EXP AGG_POS_OTHERS) =
    (case tm
	of Nil => false
	| Value t => true
    )
and €nb_agg_others› (fmtinfo: PP_FMT_INFO) ({tmark=tm, others=oth} : EXP AGG_OTHERS) =
    (case tm
	of Nil =>  false
	| Value t => true
    )
and €nb_agg_named› (fmtinfo: PP_FMT_INFO)
	({tmark=tm,named_assocs=n} : (AGG_CHOICE, EXP) AGG_NAMED) =
    (case tm
	of Nil => false
	| Value t => true
    )
and €nb_agg_named_others› (fmtinfo: PP_FMT_INFO) 
	({agg_named=a as{tmark=tm, named_assocs=n}, others=oth} :
		(AGG_CHOICE, EXP) AGG_NAMED_OTHERS) =
    (case tm
	of Nil => false
	| Value t => true
    )
and €nb_unary_exp› (fmtinfo: PP_FMT_INFO) ({uop=u, right=r} 
		: EXP UNARY_EXP) = true
and €nb_bin_exp› (fmtinfo: PP_FMT_INFO) ({bop=b, left=l, right=r}
		: EXP BIN_EXP) = true
and €nb_attrib_desig› (fmtinfo : PP_FMT_INFO) (ADAttrib x : ATTRIB_DESIG) =
	nb_attrib fmtinfo x
  | nb_attrib_desig (fmtinfo: PP_FMT_INFO) (ADAttribArg (a,e) 
		: ATTRIB_DESIG) = true
and €nb_mem_range› (fmtinfo: PP_FMT_INFO) 
	({left=e, mop=m, range=r} : EXP MEM_RANGE) = true

and €nb_attribute› (fmtinfo: PP_FMT_INFO)
	({prefix=p, attribute_desig=a} : (EXP, ATTRIB_DESIG) ATTRIBUTE) = true

and €nb_indexed_comp› (fmtinfo: PP_FMT_INFO) 
	({prefix=p, index=i} : EXP INDEXED_COMP) = true
and €nb_selected_comp› (fmtinfo: PP_FMT_INFO) 
	({prefix=p, selector=s} : EXP SELECTED_COMP) = true
and €nb_qualified_expression› (fmtinfo: PP_FMT_INFO)
	({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) = true
and €nb_type_conversion› (fmtinfo: PP_FMT_INFO)
	({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) = true
and €nb_exp› (fmtinfo: PP_FMT_INFO) (EId x : EXP) = (nb_id fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EInt x : EXP) = (nb_int_lit fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EArrayAggPos x : EXP) = (nb_agg_pos fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EArrayAggPosOthers x : EXP) = 
	(nb_agg_pos_others fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EArrayAggOthers x : EXP) = 
	(nb_agg_others  fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EArrayAggNamed x : EXP) = 
	(nb_agg_named fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EArrayAggNamedOthers x : EXP) = 
	(nb_agg_named_others fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (ERecAggPos x : EXP) = (nb_agg_pos fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (ERecAggNamed x : EXP) = false
  | nb_exp (fmtinfo: PP_FMT_INFO) (EUnaryExp x : EXP) = (nb_unary_exp fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EBinExp x : EXP) = (nb_bin_exp fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EMemRange x : EXP) = (nb_mem_range fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EAttribute x : EXP) = (nb_attribute fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EIndexedComp x : EXP) = 
	(nb_indexed_comp fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (ESelectedComp x : EXP) = 
	(nb_selected_comp fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (EFunCall x : EXP) = false
  | nb_exp (fmtinfo: PP_FMT_INFO) (EAuxiliaryExp x : EXP) = true
  | nb_exp (fmtinfo: PP_FMT_INFO) (EQualifiedExp x : EXP) =
	(nb_qualified_expression fmtinfo x)
  | nb_exp (fmtinfo: PP_FMT_INFO) (ETypeConversion x : EXP) =
	(nb_type_conversion fmtinfo x)
  | nb_exp (fmtinfo  : PP_FMT_INFO) (EBracketed e : EXP) = false
  | nb_exp ({outf,...}: PP_FMT_INFO) (EStringLiteral s : EXP) = true
  | nb_exp ({outf,...}: PP_FMT_INFO) (ECharacterLiteral c : EXP) = true
and €nb_exp_list› (fmtinfo: PP_FMT_INFO) ([] : EXP list) = false
  | nb_exp_list (fmtinfo: PP_FMT_INFO) ([x] : EXP list) = (nb_exp fmtinfo x)
  | nb_exp_list (fmtinfo : PP_FMT_INFO) (x::xs : EXP list) = true;
=TEX
=IGN
(* apparently not needed *)
fun €nb_static_exp› (fmtinfo: PP_FMT_INFO)(x : STATIC_EXP) = (nb_exp fmtinfo x);

fun €nb_static_rangelohi› (fmtinfo: PP_FMT_INFO) ({lo=l, hi=h} : STATIC_EXP RANGELOHI) = true;
fun €nb_static_range› (fmtinfo: PP_FMT_INFO) (RRange x : EXP RANGE) =
	nb_static_rangelohi fmtinfo x
  | nb_static_range (fmtinfo: PP_FMT_INFO) (RRangeAttr x : EXP RANGE) =
	nb_static_exp fmtinfo x;

fun €nb_cond› (fmtinfo: PP_FMT_INFO) (c : COND) = (nb_exp fmtinfo c);

fun €nb_actuals› (fmtinfo : PP_FMT_INFO) (_ : (AGG_CHOICE, EXP) ACTUALS) = false;

=TEX
Statements, nor items embedding them never need brackets.

\subsection{Expression Fragments}
=SML
fun €is_expansion_selected› ({fmtfn, ...} : PP_FMT_INFO) : bool = (
    case fmtfn of
	Value _	=> true
    |    Nil 	=> false
);
=TEX

=SML
fun €fmt_z_tm› ({outf,...} : PP_FMT_INFO) (z_tm : Z_TM) : unit = (
    case z_tm of
	ZTmFancyApp ((TmplPre (("ê", Nil), StubUS), ""),
	ZTmTuple[z_tm']) => (
	    outf(format_z_tm z_tm')
    ) |    ZTmFancyApp ((TmplPre (("ê", Nil), StubUS), ""), z_tm') => (
	    outf(format_z_tm z_tm')
    ) |    _ => outf(format_z_tm z_tm)
);
=TEX

Leaf functions, these don't call any other functions.

=SML

fun €fmt_id_plus›  (fmtinfo as {outf,...}: PP_FMT_INFO) (n : ID) (s : string): unit  = (
	outf(sfmt_id_plus fmtinfo n s)
);

fun €fmt_id_comma›  (fmtinfo : PP_FMT_INFO) (n : ID) : unit  = (
	fmt_id_plus fmtinfo n ","
);
fun €fmt_id›  (fmtinfo : PP_FMT_INFO) (n : ID) : unit  = (
	fmt_id_plus fmtinfo n ""
);

fun €fmt_tmark_plus›  (fmtinfo : PP_FMT_INFO) (t : TMARK) (s : string): unit =
	fmt_id_plus fmtinfo t s;
fun €fmt_tmark›  (fmtinfo : PP_FMT_INFO) (t : TMARK) : unit = 
	fmt_tmark_plus fmtinfo t "";
fun €fmt_tmark_comma›  (fmtinfo : PP_FMT_INFO) (t : TMARK) : unit =
	fmt_tmark_plus fmtinfo t ",";

fun €fmt_term›  ({outf,...} : PP_FMT_INFO) (z : TERM) : unit = (
let	val strs = PrettyPrinter.format_term1 false (get_int_control
		"cn_automatic_line_splitting" - len_tab()) z;
in
	outf (hd strs);
	if (length strs = 1)
	then ()
	else (map (fn s => (outf("\n"); outf(s))) (tl strs);
		())
end);

fun €fmt_label› ({outf,...} : PP_FMT_INFO) (label : LABEL) = outf ("("^label^")");

fun €fmt_unary_op› ({outf,...} : PP_FMT_INFO) (UOSparkUnaryAdd : UNARY_OP) = outf "+"
  | fmt_unary_op ({outf,...} : PP_FMT_INFO) (UOSparkUnaryMinus : UNARY_OP) = outf "-"
  | fmt_unary_op ({outf,...} : PP_FMT_INFO)(UOSparkNot : UNARY_OP) = outf "not"
  | fmt_unary_op ({outf,...} : PP_FMT_INFO)(UOSparkAbs : UNARY_OP) = outf "abs";

fun €fmt_binary_op› ({outf,...} : PP_FMT_INFO)(BOSparkAdd : BIN_OP) = outf"+"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkAnd : BIN_OP) = outf "and"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkAndThen : BIN_OP) = outf "and then"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkConcat : BIN_OP) = outf "&"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkEq : BIN_OP) = outf "="
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkExpon : BIN_OP) = outf "**"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkGreater : BIN_OP) = outf ">"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkGreaterEq : BIN_OP) = outf ">="
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkIntdiv : BIN_OP) = outf "/"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkLess : BIN_OP) = outf "<"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkLessEq : BIN_OP) = outf "<="
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkMem : BIN_OP) = outf "in"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkMinus : BIN_OP) = outf "-"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkMod : BIN_OP) = outf "mod"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkNotEq : BIN_OP) = outf "/="
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkNotMem : BIN_OP) = outf "not in"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkOr : BIN_OP) = outf "or"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkOrElse : BIN_OP) = outf "or else"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkRem : BIN_OP) = outf "rem"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkTimes : BIN_OP) = outf "*"
  | fmt_binary_op ({outf,...} : PP_FMT_INFO)(BOSparkXor : BIN_OP) = outf "xor";

fun €fmt_mode› ({outf,...} : PP_FMT_INFO)(MSparkIn : MODE) = outf "IN"
  | fmt_mode ({outf,...} : PP_FMT_INFO)(MSparkOut : MODE) = outf "OUT"
  | fmt_mode ({outf,...} : PP_FMT_INFO)(MSparkInOut : MODE) = outf "IN OUT";

fun €fmt_loop_direction› ({outf,...} : PP_FMT_INFO) (LDForwards : LOOP_DIRECTION) = ()
  | fmt_loop_direction ({outf,...} : PP_FMT_INFO)(LDReverse : LOOP_DIRECTION) = outf "REVERSE";

fun €fmt_operator_symbol› ({outf,...} : PP_FMT_INFO)(s : OPERATOR_SYMBOL) = outf s;
=TEX
To ensure that the string quotes are adjacent to the operator name.
=SML
fun €sfmt_operator_symbol› ({outf,...} : PP_FMT_INFO)(s : OPERATOR_SYMBOL) = (
	( "\"" ^ s ^ "\"")
);
=TEX

Lists of leaf functions.
=SML

fun €fmt_id_list› (fmtinfo : PP_FMT_INFO)([] : ID list) = ()
  | fmt_id_list (fmtinfo : PP_FMT_INFO)([x] : ID list) = (fmt_id fmtinfo x)
  | fmt_id_list (fmtinfo as {outf,...} : PP_FMT_INFO)(x::xs: ID list) = (
	(fmt_id_comma fmtinfo x);
	(fmt_id_list fmtinfo xs)
  );

fun €fmt_tmark_list› (_ : PP_FMT_INFO)([] : TMARK list) = ()
  | fmt_tmark_list (fmtinfo : PP_FMT_INFO)([x] : TMARK list) = (fmt_tmark fmtinfo x)
  | fmt_tmark_list (fmtinfo as {outf,...}: PP_FMT_INFO)(x::xs : TMARK list) = (
    (fmt_tmark_comma fmtinfo x);
    (fmt_tmark_list fmtinfo xs)
  );

=TEX

Equivalences to leaf functions.

=SML

fun €fmt_z_pred› (fmtinfo : PP_FMT_INFO) (z : Z_PRED) = fmt_term fmtinfo z;
fun €fmt_z_exp› (fmtinfo : PP_FMT_INFO) (z : Z_EXP) =  fmt_term fmtinfo z;
fun €sfmt_z_id› ({outf, ...} : PP_FMT_INFO) (z : Z_ID) = z;
fun €fmt_z_id› ({outf, ...} : PP_FMT_INFO) (z : Z_ID) = outf z;
fun €fmt_attrib› (fmtinfo : PP_FMT_INFO) (x : ATTRIB) = fmt_id fmtinfo x;
fun €fmt_int_lit› (fmtinfo : PP_FMT_INFO) (x : INT_LIT) = fmt_id fmtinfo x;

=TEX

\subsection{Expressions}

Expressions.

=SML
fun €fmt_rangelohi› (fmtinfo as {outf,...}: PP_FMT_INFO) 
	({lo=l, hi=h} : EXP RANGELOHI) = (
		(fmt_exp fmtinfo l);
		outf "..";
		(fmt_exp fmtinfo h)
	)
and €fmt_range› (fmtinfo: PP_FMT_INFO)(RRange x : EXP RANGE) = fmt_rangelohi fmtinfo x
  | fmt_range fmtinfo (RRangeAttr x : EXP RANGE) = fmt_exp fmtinfo x
and €fmt_discrete_range_constrained› (fmtinfo as {outf,...}: PP_FMT_INFO)
		({tmark=t, range=r} : EXP DISCRETE_RANGE_CONSTRAINED) = (
    (fmt_tmark fmtinfo t);
    outf "RANGE";
    (fmt_range fmtinfo r)
    )
and €fmt_discrete_range› (fmtinfo : PP_FMT_INFO) (DRRange x : DISCRETE_RANGE) = (fmt_range fmtinfo x)
  | fmt_discrete_range (fmtinfo : PP_FMT_INFO)(DRConstrained x : DISCRETE_RANGE) =
    (fmt_discrete_range_constrained fmtinfo x)
and €fmt_agg_choice› (fmtinfo : PP_FMT_INFO) (ACAggChoiceRange x : AGG_CHOICE) = (fmt_discrete_range fmtinfo x)
  | fmt_agg_choice (fmtinfo : PP_FMT_INFO) (ACAggChoiceSingle x : AGG_CHOICE) = (fmt_exp fmtinfo x)
and €fmt_agg_choice_list› (_: PP_FMT_INFO)([] : AGG_CHOICE list) = ()
  | fmt_agg_choice_list (fmtinfo as {outf,...}: PP_FMT_INFO) ([x] : AGG_CHOICE list) = (fmt_agg_choice fmtinfo x)
  | fmt_agg_choice_list (fmtinfo as {outf,...}: PP_FMT_INFO) (x::xs : AGG_CHOICE list) = (
	(fmt_agg_choice fmtinfo x);
	outf "|";
	(fmt_agg_choice_list fmtinfo xs)
   )
and €fmt_named_assoc› (fmtinfo as {outf,...}: PP_FMT_INFO)({choice=c, comp=e} : (AGG_CHOICE, EXP) NAMED_ASSOC) = (
    (fmt_agg_choice_list fmtinfo c);
    outf "=>";
    (fmt_exp fmtinfo e))
and €fmt_named_assoc_list› (_: PP_FMT_INFO)([] : (AGG_CHOICE, EXP) NAMED_ASSOC list) = ()
  | fmt_named_assoc_list (fmtinfo as {outf,...}: PP_FMT_INFO) ([x] : (AGG_CHOICE, EXP) NAMED_ASSOC list) =
    (fmt_named_assoc fmtinfo x)
  | fmt_named_assoc_list (fmtinfo as {outf,...}: PP_FMT_INFO) (x::xs : (AGG_CHOICE, EXP) NAMED_ASSOC list) = (
	(fmt_named_assoc fmtinfo x);
	outf ",";
	(fmt_named_assoc_list fmtinfo xs)
    )
and €fmt_others› (fmtinfo as {outf,...}: PP_FMT_INFO)({others=oth} : EXP OTHERS) = (
	outf "OTHERS";
	outf "=>";
	(fmt_exp fmtinfo oth)
)
and €fmt_agg_pos› (fmtinfo as {outf,...}: PP_FMT_INFO) ({tmark=tm, comps=c} : EXP AGG_POS) =
    (case tm
	of Nil => ( outf "("; (fmt_exp_list fmtinfo c); outf ")")
	| Value t => ((fmt_tmark fmtinfo t; outf "'"; outf "(");
		(fmt_exp_list fmtinfo c);
		outf ")")
    )
and €fmt_agg_pos_others› (fmtinfo as {outf,...}: PP_FMT_INFO) ({agg_pos = {tmark=tm, comps=c} :
    EXP AGG_POS, others = oth} : EXP AGG_POS_OTHERS) =
    (case tm
	of Nil => (
		outf "(";
		(fmt_exp_list fmtinfo c);
		outf ",";
		(fmt_others fmtinfo oth);
		outf ")"
	) | Value t => (
		fmt_tmark fmtinfo t; outf "'"; outf "(";
		(fmt_exp_list fmtinfo c);
		outf ",";
		(fmt_others fmtinfo oth);
		outf ")"
	)
    )
and €fmt_agg_others› (fmtinfo as {outf,...}: PP_FMT_INFO) ({tmark=tm, others=oth} : EXP AGG_OTHERS) =
    (case tm
	of Nil =>  (
		outf "(";
		(fmt_others fmtinfo oth);
		outf ")"
    ) | Value t => (
		fmt_tmark fmtinfo t; outf "'"; outf "(";
		(fmt_others fmtinfo oth);
		outf ")"
	)
    )
and €fmt_agg_named› (fmtinfo as {outf,...}: PP_FMT_INFO)
	({tmark=tm,named_assocs=n} : (AGG_CHOICE, EXP) AGG_NAMED) =
    (case tm
	of Nil => (
		outf "(";
		(fmt_named_assoc_list fmtinfo n);
		outf ")"
	) | Value t => (
		fmt_tmark fmtinfo t; outf "'"; outf "(";
		(fmt_named_assoc_list fmtinfo n);
		outf ")"
	)
    )
and €fmt_agg_named_others› (fmtinfo as {outf,...}: PP_FMT_INFO) 
	({agg_named=a as{tmark=tm, named_assocs=n}, others=oth} :
		(AGG_CHOICE, EXP) AGG_NAMED_OTHERS) =
    (case tm
	of Nil => (
		outf "(";
		(fmt_named_assoc_list fmtinfo n);
		outf ",";
		(fmt_others fmtinfo oth);
		outf ")"
	) | Value t => (
		(fmt_tmark fmtinfo t; outf "'"; outf "(");
		(fmt_named_assoc_list fmtinfo n);
		outf ",";
		(fmt_others fmtinfo oth);
		outf ")"
	)
    )
and €fmt_unary_exp› (fmtinfo: PP_FMT_INFO) ({uop=u, right=r} 
		: EXP UNARY_EXP) =
    ((fmt_unary_op fmtinfo u); (fmt_exp fmtinfo r))
and €fmt_bin_exp› (fmtinfo as {outf,...}: PP_FMT_INFO) ({bop=b, left=l, right=r}
		: EXP BIN_EXP) =
    ((fmt_exp fmtinfo l); (fmt_binary_op fmtinfo b); (fmt_exp fmtinfo r))
and €fmt_attrib_desig› (fmtinfo : PP_FMT_INFO) (ADAttrib x : ATTRIB_DESIG) =
	fmt_attrib fmtinfo x
  | fmt_attrib_desig (fmtinfo as {outf,...}: PP_FMT_INFO) (ADAttribArg (a,e) 
		: ATTRIB_DESIG) =
    ((fmt_attrib fmtinfo a); outf "("; (fmt_exp fmtinfo e); outf ")")
and €fmt_mem_range› (fmtinfo as {outf,...}: PP_FMT_INFO) 
	({left=e, mop=m, range=r} : EXP MEM_RANGE) = 
    (fmt_exp fmtinfo e; fmt_binary_op fmtinfo m; fmt_range fmtinfo r)

    (* following doesn't look right *)
and €fmt_attribute› (fmtinfo as {outf,...}: PP_FMT_INFO)
	({prefix=p, attribute_desig=a} : (EXP, ATTRIB_DESIG) ATTRIBUTE) =
    (fmt_exp fmtinfo p; outf "'"; (fmt_attrib_desig fmtinfo a))

and €fmt_indexed_comp› (fmtinfo as {outf,...}: PP_FMT_INFO) 
	({prefix=p, index=i} : EXP INDEXED_COMP) = (
    fmt_exp fmtinfo p;
    (if (nb_exp fmtinfo i)
    then ( (* bracket *)
	outf "("; fmt_exp fmtinfo i;	outf ")"
    ) else (fmt_exp fmtinfo i))
   )
and €fmt_selected_comp› (fmtinfo as {outf,...}: PP_FMT_INFO) 
	({prefix=p, selector=s} : EXP SELECTED_COMP) =
    (fmt_exp fmtinfo p; outf "."; (fmt_id fmtinfo s))
and €fmt_qualified_expression› (fmtinfo as {outf,...}: PP_FMT_INFO)
	({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) = (
	(fmt_tmark fmtinfo t); 
	outf "'";
	(if (nb_exp fmtinfo e)
	then ( (* bracket *)
	    outf "("; fmt_exp fmtinfo e; outf ")"
	) else (fmt_exp fmtinfo e)))
and €fmt_type_conversion› (fmtinfo as {outf,...}: PP_FMT_INFO)
	({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) = (
	fmt_tmark fmtinfo t;
	(if (nb_exp fmtinfo e)
	then ( (* bracket *)
	outf "("; fmt_exp fmtinfo e;	outf ")"
	) else (fmt_exp fmtinfo e))
)
and €fmt_exp› (fmtinfo: PP_FMT_INFO) (EId x : EXP) = (fmt_id fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EInt x : EXP) = (fmt_int_lit fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EArrayAggPos x : EXP) = (fmt_agg_pos fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EArrayAggPosOthers x : EXP) = 
	(fmt_agg_pos_others fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EArrayAggOthers x : EXP) = 
	(fmt_agg_others  fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EArrayAggNamed x : EXP) = 
	(fmt_agg_named fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EArrayAggNamedOthers x : EXP) = 
	(fmt_agg_named_others fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (ERecAggPos x : EXP) = (fmt_agg_pos fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (ERecAggNamed x : EXP) =
    fail "fmt_statement" 510999 [fn()=>"named record aggregate"]
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EUnaryExp x : EXP) = (fmt_unary_exp fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EBinExp x : EXP) = (fmt_bin_exp fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EMemRange x : EXP) = (fmt_mem_range fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EAttribute x : EXP) = (fmt_attribute fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EIndexedComp x : EXP) = 
	(fmt_indexed_comp fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (ESelectedComp x : EXP) = 
	(fmt_selected_comp fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EFunCall x : EXP) = 
    fail "fmt_statement" 510999 [fn()=>"function call"]
  | fmt_exp (fmtinfo as {outf,...}: PP_FMT_INFO) (EAuxiliaryExp x : EXP) = 
	(outf "˚"; (fmt_z_tm fmtinfo x); outf "˝")
  | fmt_exp (fmtinfo: PP_FMT_INFO) (EQualifiedExp x : EXP) =
	(fmt_qualified_expression fmtinfo x)
  | fmt_exp (fmtinfo: PP_FMT_INFO) (ETypeConversion x : EXP) =
	(fmt_type_conversion fmtinfo x)
  | fmt_exp (fmtinfo as {outf, ...} : PP_FMT_INFO) (EBracketed e : EXP) = 
	(outf "("; (fmt_exp fmtinfo e); outf ")")
  | fmt_exp ({outf,...}: PP_FMT_INFO) (EStringLiteral s : EXP) = 
	(outf ("\""^s^"\""))
  | fmt_exp ({outf,...}: PP_FMT_INFO) (ECharacterLiteral c : EXP) = outf ("'"^c^"'")
and €fmt_exp_list› (fmtinfo: PP_FMT_INFO) ([] : EXP list) = ()
  | fmt_exp_list (fmtinfo: PP_FMT_INFO) ([x] : EXP list) = (fmt_exp fmtinfo x)
  | fmt_exp_list (fmtinfo as {outf,...} : PP_FMT_INFO) (x::xs : EXP list) = 
	((fmt_exp fmtinfo x); outf ","; (fmt_exp_list fmtinfo xs));
=TEX
=SML
fun €fmt_static_exp› (fmtinfo: PP_FMT_INFO)(x : STATIC_EXP) = (fmt_exp fmtinfo x);

fun €fmt_static_rangelohi› (fmtinfo as {outf,...}: PP_FMT_INFO) ({lo=l, hi=h} : STATIC_EXP RANGELOHI) = (
	(fmt_static_exp fmtinfo l);
	outf "..";
	(fmt_static_exp fmtinfo h)
);
fun €fmt_static_range› (fmtinfo: PP_FMT_INFO) (RRange x : EXP RANGE) =
	fmt_static_rangelohi fmtinfo x
  | fmt_static_range (fmtinfo: PP_FMT_INFO) (RRangeAttr x : EXP RANGE) =
	fmt_static_exp fmtinfo x;

fun €fmt_cond› (fmtinfo: PP_FMT_INFO) (c : COND) = (fmt_exp fmtinfo c);

fun €fmt_actuals› (fmtinfo as {outf,...} : PP_FMT_INFO) (APositional x : (AGG_CHOICE, EXP) ACTUALS) = 
    (case x
	of [] => ()
	| z => (
		outf "(";
		(fmt_exp_list fmtinfo x);
		outf ")"
	)
    )
  | fmt_actuals (fmtinfo as {outf,...}: PP_FMT_INFO) (ANamed x : (AGG_CHOICE, EXP) ACTUALS) =
    (case x
	of [] => ()
	| z => (
		outf "(";
		(fmt_named_assoc_list fmtinfo x);
		outf ")"
	)
    );

=TEX

\subsection{Statements}

A few auxiliary functions before we do statements.

=SML

fun €fmt_spec› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({w=w, w0=w0, pre=pre, post=post} : SPEC) = (
    outf "Ñ";
    outf(format_list (sfmt_z_id fmtinfo) w ",");
    outf "[";
    (fmt_z_tm fmtinfo pre);
    outf ",";
    (fmt_z_tm fmtinfo post);
    outf "]"
);

fun €fmt_proc_call› (fmtinfo : PP_FMT_INFO)
	({name=n, actuals=e} : (AGG_CHOICE, EXP) PROC_CALL) =
    ((fmt_id fmtinfo n); (fmt_actuals fmtinfo e));
=TEX
=SML
fun €fmt_pragma› (fmtinfo as {outf,...} : PP_FMT_INFO)
		({id, args} : (AGG_CHOICE, EXP) PRAGMA) : unit = (
let	fun fmt_arg (Nil, e) =
		fmt_exp fmtinfo e
	|   fmt_arg (Value ac, e) = (
		fmt_agg_choice fmtinfo ac;
		outf "=>";
		fmt_exp fmtinfo e
	);
	fun fmt_arg_list [] = ()
	| fmt_arg_list [x] = fmt_arg x
	| fmt_arg_list (x :: xs) = (
		fmt_arg x;
		outf ",";
		fmt_arg_list xs
	);
in	(outf ("PRAGMA " ^ id);
	(case args of
		[] => (outf ";"; outf "\n")
		| _ => (
			outf "(";
			fmt_arg_list args;
			outf ")"; outf ";";
			outf "\n"
		)
	))
end);

fun €fmt_replaced_by_arbitrary_ada› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({label, replacement} : REPLACED_BY_ARBITRARY_ADA ) = (
	(fmt_label fmtinfo label);
	outf "!È";
	outf replacement;
	outf "\n"
);
=TEX
=SML
fun €has_expansion› (fmtinfo as {outf,fmtfn} : PP_FMT_INFO) (label : LABEL) = (
let    val f = case fmtfn of
	    Value f =>    f
	    | _ =>    fn _ => Nil;
in
    case f label of
    Value _ => true
    | _ => false
end);
=IGN
fun €fmt_expansion› (fmtinfo : PP_FMT_INFO) (label : LABEL) = Value ();
fun €fmt_stmt› (fmtinfo : PP_FMT_INFO) (stmt : STMT) = ();
=SML
fun €fmt_ann› (fmtinfo as {outf,fmtfn} : PP_FMT_INFO) (anks as ANKSlot {content, label} : ANN) = (
    if (has_expansion fmtinfo label)
    then (fmt_expansion fmtinfo label;())
    else (outf ("ß " ^ content^" ¢    ");
	(fmt_label fmtinfo label);
	outf "\n"
    )
) |   fmt_ann (fmtinfo as {outf,fmtfn} : PP_FMT_INFO) (ANString ann) = (
	outf ann;
	outf "\n"
)
and €fmt_annotation› (fmtinfo : PP_FMT_INFO) (anns: ANNOTATION) = (
	(map (fmt_ann fmtinfo) anns; ())
) 
and €fmt_expansion› (fmtinfo as {outf, fmtfn} : PP_FMT_INFO) (label : LABEL) = (
let    val f = case fmtfn of
	    Value f =>    f
	    | Nil =>    fn _ => Nil;
in
    case f label of
    Value repl => (
	case repl of
	    ReplaceComp {comp, ...} =>    
		fmt_kslot_compilation_unit_list fmtinfo comp
	|    ReplacePPart {private, ...} =>
		fmt_declaration_list fmtinfo private
	|    ReplaceVPart {visible, ...} =>
		fmt_declaration_list fmtinfo visible
	|    ReplaceDecl {decls, ...} =>
		fmt_declaration_list fmtinfo decls
	|    RefineStat {statement, ...}    =>
		fmt_statement fmtinfo statement
	|    ReplaceStat {statement, ...}    =>
		fmt_statement fmtinfo statement
	|    ReplaceArbitrary {replacement, ...}    =>
		(let val tabs = get_tabs();
		in
			(reset_tabs();
			outf replacement;
			outf "\n";
			set_tabs (tabs)
			)
		end)
	|    ReplaceAnnotation {replacement, ...}    =>
		fmt_annotation fmtinfo replacement
	|    UnReplaced (RSCompilation, s) => (
	    outf ("-- k-slot " ^label);
		outf "\n"
	) |    UnReplaced (RSSpecStatement, s) => (
	    outf ("NULL; -- " ^ label);
		outf "\n"
	) |    UnReplaced (RSStatement, s) => (
	    outf ("NULL; -- " ^ label);
		outf "\n"	
	) |    UnReplaced (RSDeclaration, s) => (
	    outf ("-- k-slot " ^ label);
		outf "\n"
	) |    UnReplaced (RSPrivatePart, s) => (
	    outf ("-- k-slot " ^ label);
		outf "\n"
	) |    UnReplaced (RSVisiblePart, s) => (
	    outf ("-- k-slot " ^ label);
		outf "\n"
	) |    UnReplaced (RSAnnotation, s) => (
	    outf ("-- k-slot " ^ label);
		outf "\n"
	);
	Value () (* to indicate success *)
    ) |    Nil =>    Nil  
end)

and €fmt_spec_no_ivars› (fmtinfo as {outf,...} : PP_FMT_INFO) (s as
		{spec, label} : SPEC_NO_IVARS) = (
	if (has_expansion fmtinfo label)
	then (fmt_expansion fmtinfo label; ())
	else (
		fmt_spec fmtinfo spec;
		outf "    ";
		(fmt_label fmtinfo label);
		outf "\n"
	)
)
=TEX

Statements.

=SML
and €fmt_assign› (fmtinfo as {outf,...} : PP_FMT_INFO) ({name=n, e=e} : ASSIGN) = (
	(fmt_exp fmtinfo n);
	outf ":=";
	(fmt_exp fmtinfo e);
	outf ";";
	outf "\n"
)

and €fmt_exit_when› (fmtinfo as {outf,...} : PP_FMT_INFO) ({g=g} : EXIT_WHEN) = (
	outf "EXIT WHEN";
	(fmt_cond fmtinfo g);
	outf ";";
	outf "\n"
)
and €fmt_return› (fmtinfo as {outf,...} : PP_FMT_INFO) ({e=e} : RETURN) = (
	outf "RETURN";
	(fmt_exp fmtinfo e);
	outf ";";
	outf "\n"
)
and €fmt_proc_call_no_ivars› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(x : (AGG_CHOICE, EXP) PROC_CALL_NO_IVARS) = (
	(fmt_proc_call fmtinfo x);
	outf ";";
	outf "\n"
)

and €fmt_k_slot› (fmtinfo as {outf,...} : PP_FMT_INFO) ({content, label} : K_SLOT) = (
    case fmt_expansion fmtinfo label of
    Value _ =>    ()
    |Nil =>    (
	outf "ß";
	outf content;
	outf " ¢   ";
	(fmt_label fmtinfo label);
	outf "\n"
	)
)

and €fmt_elsif› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(stmt as (STIfThenElse {g=g, p=p, q=q, elsif=true}) : STMT) = (
	outf "ELSIF;";
	(fmt_cond fmtinfo g);
	outf "\n";
	outf "THEN";
	outf "\n";
	inc_tabs ();
	(fmt_stmt fmtinfo p);
	dec_tabs();
	(fmt_elsif fmtinfo q)
   )
  | fmt_elsif (fmtinfo as {outf,...} : PP_FMT_INFO)
	(stmt as (STIfThenElse {g=g, p=p, q=q, elsif=false}) : STMT) = (
	outf "ELSIF";
	(fmt_cond fmtinfo g); outf "\n";
	outf "THEN"; outf "\n";
	inc_tabs(); fmt_stmt fmtinfo p; dec_tabs();
	(case q
	of STImplicitNull => outf "\n"
	| z => (
		outf "ELSE"; outf "\n";
		inc_tabs();
		(fmt_stmt fmtinfo q);
		dec_tabs()
	)
	)
   )
  | fmt_elsif (fmtinfo as {outf,...} : PP_FMT_INFO) (stmt : STMT) = (
	inc_tabs();
	(fmt_stmt fmtinfo stmt);
	dec_tabs()
  )
and €fmt_if_then_else› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({g=g, p=p, q=q, elsif=false} : STMT IF_THEN_ELSE) = (
	outf "IF";
	(fmt_cond fmtinfo g);
	outf "\n";
	outf "THEN";
	outf "\n";
	inc_tabs();
	(fmt_stmt fmtinfo p);
	dec_tabs();
	(case q
	of STImplicitNull => outf "\n"
	| z => (
		outf "ELSE"; outf "\n";
		inc_tabs();
		(fmt_stmt fmtinfo q);
		dec_tabs()
	    )
	);
	outf "END IF;";
	outf "\n"
  ) | fmt_if_then_else (fmtinfo as {outf,...} : PP_FMT_INFO)
	({g=g, p=p, q=q, elsif=true} : STMT IF_THEN_ELSE) = (
	outf "IF";
	(fmt_cond fmtinfo g);
	outf "\n";
	outf "THEN";
	outf "\n";
	inc_tabs();
	(fmt_stmt fmtinfo p);
	dec_tabs();
	(fmt_elsif fmtinfo q);
	outf "END IF;";
	outf "\n"
   )
and €fmt_case_choice› (fmtinfo : PP_FMT_INFO) (CCCaseExp x : CASE_CHOICE) = (fmt_exp fmtinfo x)
  | fmt_case_choice (fmtinfo : PP_FMT_INFO) (CCCaseRange x : CASE_CHOICE) = (fmt_discrete_range fmtinfo x)
and €fmt_case_choice_list›  (fmtinfo : PP_FMT_INFO) ([] : CASE_CHOICE list) = ()
  | fmt_case_choice_list (fmtinfo : PP_FMT_INFO) ([x] : CASE_CHOICE list) = (fmt_case_choice fmtinfo x)
  | fmt_case_choice_list  (fmtinfo as {outf,...} : PP_FMT_INFO) (x::xs : CASE_CHOICE list) = (
	(fmt_case_choice fmtinfo x);
	outf "|";
	(fmt_case_choice_list fmtinfo xs)
   )

and €fmt_case_alt› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({choices=c, p=s} : STMT CASE_ALTERNATIVE) = (
	outf "WHEN";
	(fmt_case_choice_list fmtinfo c);
	outf "=>";
	outf "\n";
	inc_tabs();
	(fmt_stmt fmtinfo s);
	dec_tabs(); outf "\n"
)
and €fmt_case_alt_list› (fmtinfo as {outf,...} : PP_FMT_INFO)
	([] : STMT CASE_ALTERNATIVE list) = ()
  | fmt_case_alt_list (fmtinfo as {outf,...} : PP_FMT_INFO)
	(x::xs : STMT CASE_ALTERNATIVE list) = (
	(fmt_case_alt fmtinfo x);
	(fmt_case_alt_list fmtinfo xs)
   )
and €fmt_case› (fmtinfo as {outf,...} : PP_FMT_INFO) ({e=e, s=s, others=oth} : STMT CASE) = (
	outf "CASE";
	(fmt_exp fmtinfo e);
	outf "IS"; outf "\n";
	inc_tabs();
	(fmt_case_alt_list fmtinfo s);
	dec_tabs();
	(
	    case oth
	    of STImplicitNull => ()
	    | _ => (outf "WHEN OTHERS =>";
			inc_tabs();
			fmt_stmt fmtinfo oth;
			dec_tabs();
			outf "\n"
		)
	);
	outf "END CASE;";
	outf "\n"
   )
and €fmt_unnamed_loop› (fmtinfo as {outf,...} : PP_FMT_INFO) ({t=Value t, stmt=s} : STMT LOOP) = (
    (if is_expansion_selected fmtinfo
    then    (outf "-- TILL ..."; outf "\n")
    else    (outf "TILL ˚"; (fmt_z_tm fmtinfo t); outf "˝"; outf "\n")
    );
    outf "LOOP"; outf "\n";
    inc_tabs();
    (fmt_stmt fmtinfo s);
    dec_tabs();
    outf "END LOOP;";
    outf "\n"
    )
  | fmt_unnamed_loop (fmtinfo as {outf,...} : PP_FMT_INFO) ({t=Nil, stmt=s} : STMT LOOP) = (
	outf "LOOP"; outf "\n";
	inc_tabs();
	(fmt_stmt fmtinfo s);
	dec_tabs(); outf "\n"
   )

and €fmt_named_loop› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, t=Value t, stmt=s} : STMT NAMED_LOOP) = (
    in_new_scope false n (fn () => (
	(fmt_id fmtinfo n); outf ":"; outf "\n";
	(    if is_expansion_selected fmtinfo
	then    (outf "-- TILL statement"; outf "\n")
	else    (outf "TILL ˚"; (fmt_z_tm fmtinfo t); outf "˝"; outf "\n")
	);
	outf "LOOP"; outf "\n";
	inc_tabs();
	(fmt_stmt fmtinfo s);
	dec_tabs();
	outf "END LOOP"; (fmt_id fmtinfo n); outf ";"; outf "\n"
	)
   )
)  | fmt_named_loop (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, t=Nil, stmt=s} : STMT NAMED_LOOP) = (
    in_new_scope false n (fn () => (
	(fmt_id fmtinfo n); outf ":"; outf "\n";
	outf "LOOP"; outf "\n";
	(inc_tabs(); fmt_stmt fmtinfo s; dec_tabs());
	outf "END LOOP";(fmt_id fmtinfo n); outf ";"; outf "\n"
    ))
) and €fmt_loop_body› (fmtinfo as {outf,...} : PP_FMT_INFO) ({t=Value t, stmt=s} : STMT LOOP) =  (
    (if is_expansion_selected fmtinfo
    then    (outf "-- TILL statement"; outf "\n")
    else    (outf "TILL ˚"; (fmt_z_tm fmtinfo t); outf "˝"; outf "\n")
    );
    outf "LOOP"; outf "\n";
    (inc_tabs(); fmt_stmt fmtinfo s; dec_tabs())
   )  | fmt_loop_body (fmtinfo as {outf,...} : PP_FMT_INFO) ({t=Nil, stmt=s} : STMT LOOP) = (
	outf "LOOP"; outf "\n";
	(inc_tabs(); fmt_stmt fmtinfo s; dec_tabs())
   )
and €fmt_while› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=Value n, g=g, loop=l} : STMT WHILE) = (
	(fmt_id fmtinfo n); outf ":"; outf "\n";
	outf  "WHILE"; (fmt_cond fmtinfo g); outf "\n";
	(fmt_loop_body fmtinfo l);
	outf "END LOOP"; (fmt_id fmtinfo n); outf ";"; outf "\n"
  )
  | fmt_while (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=Nil, g=g, loop=l} : STMT WHILE) = (
	outf "WHILE"; (fmt_cond fmtinfo g); outf "\n";
	(fmt_loop_body fmtinfo l);
	outf "END LOOP;"; outf "\n"
   )
and €fmt_for_static› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=Value n, tmark=t, i=i, dir=d, range=r, loop=loop}:
    STMT FOR_STATIC) = (
    in_new_scope false n (fn () => (
	check_decl i;
	(fmt_id fmtinfo n); outf ":"; outf "\n";
	outf "FOR"; fmt_id fmtinfo i; outf "IN";
	fmt_loop_direction fmtinfo d;
	fmt_tmark fmtinfo t; outf "RANGE";
	(fmt_range fmtinfo r); outf"\n";
	(fmt_loop_body fmtinfo loop);
	outf "END LOOP";(fmt_id fmtinfo n); outf ";"; outf "\n"
)))
 | fmt_for_static (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=Nil, tmark=t, i=i, dir=d, range=r, loop=loop} :
    STMT FOR_STATIC) = (
    in_new_scope false "" (fn () => (
    check_decl i;
	outf "FOR";
	fmt_id fmtinfo i;
	outf "IN";
	(fmt_loop_direction fmtinfo d);
	(fmt_tmark fmtinfo t);
	outf "RANGE";
	(fmt_range fmtinfo r); outf "\n";
	(fmt_loop_body fmtinfo loop);
	outf "END LOOP;"; outf "\n"
)))
 and €fmt_for_tmark› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=Value n, i=i, tmark=t, dir=d, loop=loop} :
    STMT FOR_TMARK) = (
    in_new_scope false n (fn () => (
	check_decl i;
	(fmt_id fmtinfo n); outf ":"; outf "\n";
	outf "FOR"; fmt_id fmtinfo i; outf "IN";
	(fmt_loop_direction fmtinfo d);(fmt_tmark fmtinfo t); outf "\n";
	(fmt_loop_body fmtinfo loop);
	outf "END LOOP"; (fmt_id fmtinfo n); outf ";"; outf "\n"
)))
 | fmt_for_tmark (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=Nil, i=i, tmark=t, dir=d, loop=loop} :
    STMT FOR_TMARK) = (
    in_new_scope false "" (fn () => (
    check_decl i;
    outf "FOR"; fmt_id fmtinfo i; outf "IN"; 
    (fmt_loop_direction fmtinfo d);
	(fmt_tmark fmtinfo t); outf "\n";
    (fmt_loop_body fmtinfo loop);
    outf "END LOOP;"; outf "\n"
)))
 and €fmt_stmt› (fmtinfo as {outf,...} : PP_FMT_INFO) (STNull : STMT) = (
	outf "NULL;"; outf "\n")
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STImplicitNull : STMT) = ()
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STAssign x : STMT) =
	(fmt_assign fmtinfo x)
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STSpecNoIvars x : STMT) =
	(fmt_spec_no_ivars fmtinfo x)
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STSemicolon (a,b) : STMT) =
	(fmt_stmt fmtinfo a; fmt_stmt fmtinfo b)
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STIfThenElse x : STMT) =
	(fmt_if_then_else fmtinfo x)
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STCase x : STMT) =
	(fmt_case fmtinfo x)
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STLoop x : STMT) =
	(fmt_unnamed_loop fmtinfo x)
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STNamedLoop x : STMT) =
	(fmt_named_loop fmtinfo x)
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STWhile x : STMT) =
	(fmt_while fmtinfo x)
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STForStatic x : STMT) =
	(fmt_for_static fmtinfo x)
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STForTmark x : STMT) =
	(fmt_for_tmark fmtinfo x)
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STExitWhen x : STMT) =
	(fmt_exit_when fmtinfo x)
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STExit : STMT) = (
	outf "EXIT;"; outf "\n")
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STRet x : STMT)  =
	(fmt_return fmtinfo x)
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STProcNoIvars x : STMT) =
	(fmt_proc_call_no_ivars fmtinfo x)
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STKSlot x : STMT) =
	(fmt_k_slot fmtinfo x)
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STPragma x : STMT) =
	(fmt_pragma fmtinfo x)
  | fmt_stmt (fmtinfo as {outf,...} : PP_FMT_INFO) (STAnnotation x : STMT) =
	(fmt_annotation fmtinfo x)

=TEX

Logical constructs.

=SML

(* we don't print out pre1 since it doesn't come from the user *)
and €fmt_log_con› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({x=x, t=t, spec=s, label, ...} : LOG_CON, stmt :STMT) = (
    if is_expansion_selected fmtinfo
    then    (fmt_spec_no_ivars fmtinfo {spec=s, label=label};
		fmt_stmt fmtinfo stmt)
    else    (
		outf "CON";
		(fmt_z_id fmtinfo x); outf ":";fmt_z_tm fmtinfo t;
		outf "∑";
	(fmt_spec fmtinfo s);
		outf "    ";(fmt_label fmtinfo label);
		outf "\n";
		fmt_stmt fmtinfo stmt
	)
)
=TEX

Top level statements.

=SML

and €fmt_statement› (fmtinfo as {outf,...} : PP_FMT_INFO) (SStmt x) = (fmt_stmt fmtinfo x)
  | fmt_statement (fmtinfo as {outf,...} : PP_FMT_INFO) (SSpecIvars x) =
    fail "fmt_statement" 510999 [fn()=>"spec with ivars"]
  | fmt_statement (fmtinfo as {outf,...} : PP_FMT_INFO) (SForNonStatic x) = 
    fail "fmt_statement" 510999 [fn()=>"for with non-static bounds"]
  | fmt_statement (fmtinfo as {outf,...} : PP_FMT_INFO) (SLogCon x) = (fmt_log_con fmtinfo x)
  | fmt_statement (fmtinfo as {outf,...} : PP_FMT_INFO) (SProcIvars x) =
    fail "fmt_statement" 510999 [fn()=>"proc with ivars"]

=TEX

\subsection{Declarations and Type Definitions}

Variable declarations.

(N.B. $fmt\_var\_decl\_list$ only used in record types, so we need 
not worry about initialisations).
=SML

and €fmt_var_decl› (fmtinfo as {outf,...} : PP_FMT_INFO) ({vars=v, tmark=t} : VAR_DECL) = (
	map check_decl v;
	(fmt_id_list fmtinfo v);
	outf ":";
	(fmt_tmark fmtinfo t);
	outf ";"; outf "\n"
) and fmt_var_decl_list (fmtinfo as {outf,...} : PP_FMT_INFO) ([] : VAR_DECL list) = ()
  | fmt_var_decl_list (fmtinfo as {outf,...} : PP_FMT_INFO) (x::xs : VAR_DECL list) =
    (fmt_var_decl fmtinfo x; fmt_var_decl_list fmtinfo xs)

=TEX

Initialised variables.
=SML
and €fmt_var_init_decl› (fmtinfo as {outf,...} : PP_FMT_INFO) 
		(({vars=v, tmark=t} : VAR_DECL), exp : EXP) = (
	map check_decl v;
	(fmt_id_list fmtinfo v);
	outf ":";
	(fmt_tmark fmtinfo t);
	outf "=";
	(fmt_exp fmtinfo exp);
	outf ";"; outf "\n"
)
=TEX

Constant and deferred constant declarations.

=SML

and €fmt_const_decl› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({consts=c, tm=t, expr=e} : EXP CONST_DECL) = (
    map check_decl c;
    (fmt_id_list fmtinfo c); outf ": CONSTANT";
    (fmt_tmark fmtinfo t); outf ":=";
    (fmt_exp fmtinfo e); outf ";"; outf "\n"
) and €fmt_deferred_const_decl› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({consts=c, tmark=t} : DEFERRED_CONST_DECL) = (
	map check_decl c;
	(fmt_id_list fmtinfo c); outf ": CONSTANT";
	(fmt_tmark fmtinfo t); outf ";"; outf "\n"
)
=TEX

Enumerated types.

=SML

and €fmt_enum_type_def› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, {vals=v} : ENUM_TYPE_DEF) = (
    check_decl name;
	outf "TYPE"; (fmt_id fmtinfo name);
	outf "IS"; outf "("; (fmt_id_list fmtinfo v); outf ")"; outf ";"; outf "\n"
)
=TEX

Integer types.

=SML

and €fmt_int_type_def› (fmtinfo as {outf,...} : PP_FMT_INFO) (name, r : EXP RANGE) = (
    check_decl name;
	outf "TYPE"; (fmt_id fmtinfo name);
	outf "IS RANGE"; (fmt_range fmtinfo r); outf ";"; outf "\n"
)
=TEX

Floating point types.

=SML

and €fmt_floating_point_constraint› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({exp=e, range=Value r} : EXP FLOATING_POINT_CONSTRAINT) = (
	outf "DIGITS"; (fmt_exp fmtinfo e); outf "RANGE";
	(fmt_range fmtinfo r)
  ) | fmt_floating_point_constraint (fmtinfo as {outf,...} : PP_FMT_INFO)
	({exp=e, range=Nil} : EXP FLOATING_POINT_CONSTRAINT) = (
	outf "DIGITS"; fmt_exp fmtinfo e)
and €fmt_floating_type_def› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, x : EXP FLOATING_TYPE_DEF) = (
    check_decl name;
	outf "TYPE"; (fmt_id fmtinfo name);
	outf "IS"; (fmt_floating_point_constraint fmtinfo x); outf ";"; outf "\n"
)
=TEX

Fixed point types.

=SML

and €fmt_fixed_point_constraint›(fmtinfo as {outf,...} : PP_FMT_INFO)
	({exp=e, range=Value r} : EXP FIXED_POINT_CONSTRAINT) = (
	outf "DELTA"; (fmt_exp fmtinfo e); outf "RANGE";
	(fmt_range fmtinfo r)
) | fmt_fixed_point_constraint(fmtinfo as {outf,...} : PP_FMT_INFO)
	({exp=e, range=Nil} : EXP FIXED_POINT_CONSTRAINT) = (
	outf "DELTA"; fmt_exp fmtinfo e)
and €fmt_fixed_type_def› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, x : EXP FIXED_TYPE_DEF) = (
    check_decl name;
	outf "TYPE"; (fmt_id fmtinfo name);
	outf "IS"; (fmt_fixed_point_constraint fmtinfo x); outf ";"; outf "\n"
)
=TEX

Array types.

=SML

and €fmt_array_def› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, {index=i, comp=c} : ARRAY_DEF) = (
    check_decl name;
	outf "TYPE"; (fmt_id fmtinfo name);
	outf "IS ARRAY"; outf "(";
	(fmt_tmark_list fmtinfo i);
	outf ")"; outf "OF";
	(fmt_tmark fmtinfo c); outf ";"; outf "\n"
) and €fmt_uncon_tmark_list› (fmtinfo as {outf,...} : PP_FMT_INFO)([] : TMARK list) = ()
  | fmt_uncon_tmark_list(fmtinfo as {outf,...} : PP_FMT_INFO) ([x] : TMARK list) = (fmt_tmark fmtinfo x; outf "RANGE <>")
  | fmt_uncon_tmark_list (fmtinfo as {outf,...} : PP_FMT_INFO)(x::xs : TMARK list) = (
	fmt_uncon_tmark_list fmtinfo [x]; 
	outf ","; fmt_uncon_tmark_list fmtinfo xs)
and €fmt_uncon_array_def› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, {index=i, comp=c} : ARRAY_DEF) = (
    check_decl name;
	outf "TYPE"; (fmt_id fmtinfo name);
	outf "IS ARRAY"; outf  "(";
	(fmt_uncon_tmark_list fmtinfo i);
	outf ")"; outf "OF"; (fmt_tmark fmtinfo c); outf ";"; outf "\n"
)
=TEX

Record types.

Note that the variable name clash rules do not apply here.
=SML

and €fmt_record_type_def› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, {decl=d} : RECORD_TYPE_DEF) = (
	check_decl name;
	let	val old_st = !stack;
		val res = (stack := [];
			outf "TYPE"; 
			(fmt_id fmtinfo name);
			outf "IS";
			outf "\n";
			outf "RECORD"; 
			outf "\n";
			inc_tabs();
			(fmt_var_decl_list fmtinfo d);
			dec_tabs();
			outf "END RECORD;";
			outf "\n");
	in	stack := old_st;
		res
	end
)
=TEX

Type declarations.

=SML

and €fmt_type_def› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, (TDEnumTypeDef x) : TYPE_DEF) =
    (fmt_enum_type_def fmtinfo (name, x))
  | fmt_type_def (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, (TDIntTypeDef x) : TYPE_DEF) =
    (fmt_int_type_def fmtinfo (name, x))
  | fmt_type_def (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, (TDFloatingTypeDef x) : TYPE_DEF) =
    (fmt_floating_type_def fmtinfo (name, x))
  | fmt_type_def (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, (TDFixedTypeDef x) : TYPE_DEF) =
    (fmt_fixed_type_def fmtinfo (name, x))
  | fmt_type_def (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, (TDUnconArrayDef x) : TYPE_DEF) =
    (fmt_uncon_array_def fmtinfo (name, x))
  | fmt_type_def (fmtinfo as {outf,...} : PP_FMT_INFO)
	(name, (TDConArrayDef x) : TYPE_DEF) =
    (fmt_array_def fmtinfo (name, x))
  | fmt_type_def (fmtinfo as {outf,...} : PP_FMT_INFO) 
	(name, (TDRecordTypeDef x) : TYPE_DEF) =
    (fmt_record_type_def fmtinfo (name, x))
and €fmt_type_decl› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, type_def=t} : TYPE_DEF TYPE_DECL) =
    (fmt_type_def fmtinfo (n, t))

=TEX

Subtype declarations.

=SML

and €fmt_constraint› (fmtinfo as {outf,...} : PP_FMT_INFO) (CRange x : CONSTRAINT) = (
	outf "RANGE"; fmt_range fmtinfo x)
  | fmt_constraint (fmtinfo as {outf,...} : PP_FMT_INFO)(CIndex x : CONSTRAINT) = (
	outf "("; fmt_exp_list fmtinfo x; outf ")")
  | fmt_constraint (fmtinfo as {outf,...} : PP_FMT_INFO)(CFloating x : CONSTRAINT) =
    (fmt_floating_point_constraint fmtinfo x)
  | fmt_constraint (fmtinfo as {outf,...} : PP_FMT_INFO)(CFixed x : CONSTRAINT) =
    (fmt_fixed_point_constraint fmtinfo x)
  | fmt_constraint (fmtinfo as {outf,...} : PP_FMT_INFO)(CNoCon : CONSTRAINT) =
    ()
and €fmt_sub_ind› (fmtinfo as {outf,...} : PP_FMT_INFO)({tmark=t, con=c} : CONSTRAINT SUB_IND) =
    (fmt_tmark fmtinfo t; fmt_constraint fmtinfo c)
and €fmt_subtype_decl› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(d as {name=n, sub_ind=s} : CONSTRAINT SUBTYPE_DECL) = (
	check_decl n;
	outf "SUBTYPE"; (fmt_id fmtinfo n); 
	outf "IS"; (fmt_sub_ind fmtinfo s); outf ";"; outf "\n"
)
=TEX

Private type declarations.

=SML

and €fmt_private_type_decl› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({id=i, limited=l} : PRIVATE_TYPE_DECL) = (
	check_decl i;
	outf "TYPE"; fmt_id fmtinfo i; outf "IS"; 
	(if l=true then outf "LIMITED" else ());
	outf "PRIVATE;"; outf "\n"
)
=TEX

Basic declarations.

=SML

and €fmt_basic_decl› (fmtinfo as {outf,...} : PP_FMT_INFO) (BDConstDecl x : BASIC_DECL) =
    (fmt_const_decl fmtinfo x)
  | fmt_basic_decl (fmtinfo as {outf,...} : PP_FMT_INFO)
	(BDDeferredConstDecl x : BASIC_DECL) =
    (fmt_deferred_const_decl fmtinfo x)
  | fmt_basic_decl (fmtinfo as {outf,...} : PP_FMT_INFO) (BDTypeDecl x : BASIC_DECL) =
    (fmt_type_decl fmtinfo x)
  | fmt_basic_decl (fmtinfo as {outf,...} : PP_FMT_INFO) (BDVarDecl x : BASIC_DECL) =
    (fmt_var_decl fmtinfo x)
  | fmt_basic_decl (fmtinfo as {outf,...} : PP_FMT_INFO) (BDVarDeclInit x : BASIC_DECL) =
    (fmt_var_init_decl fmtinfo x)
  | fmt_basic_decl (fmtinfo as {outf,...} : PP_FMT_INFO) (BDSubtypeDecl x : BASIC_DECL) =
    (fmt_subtype_decl fmtinfo x)
  | fmt_basic_decl (fmtinfo as {outf,...} : PP_FMT_INFO) (BDPrivateTypeDecl x : BASIC_DECL ) =
    (fmt_private_type_decl fmtinfo x)
  | fmt_basic_decl (fmtinfo as {outf,...} : PP_FMT_INFO) (BDPragma x : BASIC_DECL ) =
    (fmt_pragma fmtinfo x)
  | fmt_basic_decl (fmtinfo as {outf,...} : PP_FMT_INFO) (BDAnnotation x : BASIC_DECL ) =
    (fmt_annotation fmtinfo x)
and €fmt_basic_decl_list› (fmtinfo as {outf,...} : PP_FMT_INFO) ([] : BASIC_DECL list) = ()
  | fmt_basic_decl_list (fmtinfo as {outf,...} : PP_FMT_INFO) (x::xs : BASIC_DECL list) =
    (fmt_basic_decl fmtinfo x; fmt_basic_decl_list fmtinfo xs)

=TEX

\subsection{Procedure and Function specifications}

Procedure and Function parameter specifications.

=SML

and €fmt_parameter_specification› (fmtinfo as {outf,...} : PP_FMT_INFO) ({idlist=i, mode=m, name=n} :
	PARAMETER_SPECIFICATION) = (
   map  check_decl i;
    (fmt_id_list fmtinfo i); outf ":"; (fmt_mode fmtinfo m); (fmt_tmark fmtinfo n)
) and €fmt_parameter_specification_list1› (fmtinfo as {outf,...} : PP_FMT_INFO)
	([] : PARAMETER_SPECIFICATION list) = ()
  | fmt_parameter_specification_list1 (fmtinfo as {outf,...} : PP_FMT_INFO)
	([x] : PARAMETER_SPECIFICATION list) =
    (fmt_parameter_specification fmtinfo x)
  | fmt_parameter_specification_list1 (fmtinfo as {outf,...} : PP_FMT_INFO)
		(x::xs : PARAMETER_SPECIFICATION list) = (
	(fmt_parameter_specification fmtinfo x);
	outf ";";
	(fmt_parameter_specification_list1 fmtinfo xs)
)
and €fmt_parameter_specification_list› (fmtinfo as {outf,...} : PP_FMT_INFO)
	([] : PARAMETER_SPECIFICATION list) = ()
  | fmt_parameter_specification_list (fmtinfo as {outf,...} : PP_FMT_INFO)
	(xs : PARAMETER_SPECIFICATION list) = (
	outf "("; fmt_parameter_specification_list1 fmtinfo xs; outf ")"
  )
=TEX

Procedure and Function specifications.

Note these do a $push\_scope$ which someone on the calling chain will need to pop.
This is needed because the name of the procedure or function is visible at this level and needs to be on the stack when a subprogram body is processed.
=SML

and €fmt_procedure_specification› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, formal_part=f, spec=Value s, annotation=ann} 
		: PROCEDURE_SPECIFICATION) = (
	check_decl n;
	push_scope n;
	(if is_expansion_selected fmtinfo
		then (
		outf "PROCEDURE";
		(fmt_id fmtinfo n);
		(fmt_parameter_specification_list fmtinfo f);
		outf "\n";
		inc_tabs(); outf "-- Spec ..."; dec_tabs(); outf "\n"
	) else (
		outf "PROCEDURE";
		(fmt_id fmtinfo n);
		(fmt_parameter_specification_list fmtinfo f);
		outf "\n";
		inc_tabs(); (fmt_spec fmtinfo s); dec_tabs(); outf "\n"
   	);
  	fmt_annotation fmtinfo ann)
)  | fmt_procedure_specification (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, formal_part=f, spec=Nil, annotation=ann}
		: PROCEDURE_SPECIFICATION) = (
	check_decl n;
	push_scope n;
	outf "PROCEDURE";
	(fmt_id fmtinfo n);
	(fmt_parameter_specification_list fmtinfo f);
	outf "\n";
	fmt_annotation fmtinfo ann
)
 and €fmt_function_specification› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({designator=d, return=r, formal_part=f, spec=Value s, annotation=ann}
			: FUNCTION_SPECIFICATION) = (
	check_decl d;
	push_scope d;
	(if is_expansion_selected fmtinfo
	then (
		outf "FUNCTION";(fmt_id fmtinfo d);
		(fmt_parameter_specification_list fmtinfo f); 
		outf "RETURN"; (fmt_tmark fmtinfo r);
		outf "\n";
		inc_tabs(); outf "-- Spec ..."; dec_tabs(); outf "\n"
	) else (
		outf "FUNCTION";(fmt_id fmtinfo d);
		(fmt_parameter_specification_list fmtinfo f); 
		outf "RETURN"; (fmt_tmark fmtinfo r); outf "\n";
		inc_tabs(); (fmt_spec fmtinfo s); dec_tabs(); outf "\n"
	);
	fmt_annotation fmtinfo ann
	)
)
  | fmt_function_specification (fmtinfo as {outf,...} : PP_FMT_INFO)
	({designator=d, return=r, formal_part=f, spec=Nil, annotation=ann}
		: FUNCTION_SPECIFICATION) = (
	check_decl d;
	push_scope d;
	outf "FUNCTION";(fmt_id fmtinfo d);
	(fmt_parameter_specification_list fmtinfo f); outf "RETURN"; 
	(fmt_tmark fmtinfo r); outf "\n";
	fmt_annotation fmtinfo ann
)
=TEX

Subprograms.

Callers of this must pop the scope pushed by the support functions.
=SML

and €fmt_subprogram_specification› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(SSProcedure x : SUBPROGRAM_SPECIFICATION) =
    (fmt_procedure_specification fmtinfo x)
  | €fmt_subprogram_specification› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(SSFunction x : SUBPROGRAM_SPECIFICATION) =
    (fmt_function_specification fmtinfo x)

=TEX

Renaming declarations.

=SML

and €fmt_function_renaming› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({opsym1=o1, formal_part=f, tmark=t, name=n, opsym2=o2} :
	FUNCTION_RENAMING) =
	in_new_scope false o1 (fn () => (
	outf "FUNCTION"; 
	outf (sfmt_operator_symbol fmtinfo o1);
	(fmt_parameter_specification_list fmtinfo f); 
	outf "RETURN"; 
	(fmt_tmark fmtinfo t);
	outf "RENAMES";
	fmt_id fmtinfo n; outf "."; outf(sfmt_operator_symbol fmtinfo o2); 
	outf ";"; outf "\n"
	)
) 
and €fmt_subprogram_renaming› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({subprogram_specification=s, name1=n1, name2=n2} :
	SUBPROGRAM_RENAMING) = (
	let	val res = (
		(fmt_subprogram_specification fmtinfo s);
		inc_tabs ();
			outf "RENAMES";
			(fmt_id fmtinfo n1; outf "."; outf (sfmt_id_plus fmtinfo n2 ""));
			outf ";"; outf "\n";
		dec_tabs());
	in	pop_scope(); res
	end
)
and €fmt_renaming_declaration› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(RDFunction x : RENAMING_DECLARATION) =
    (fmt_function_renaming fmtinfo x)
  | fmt_renaming_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(RDSubprogram x : RENAMING_DECLARATION) =
    (fmt_subprogram_renaming fmtinfo x)

=TEX

Representation clauses.

=SML

and €fmt_component_clause› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, exp=e, range=r} : COMPONENT_CLAUSE) = (
	(fmt_id fmtinfo n);
	outf "AT";
	(fmt_exp fmtinfo e); outf "RANGE";
	(fmt_range fmtinfo r); outf ";"; outf "\n"
)
and €fmt_component_clause_list› (fmtinfo as {outf,...} : PP_FMT_INFO)
	([] : COMPONENT_CLAUSE list) = ()
  | fmt_component_clause_list (fmtinfo as {outf,...} : PP_FMT_INFO)
	(x::xs : COMPONENT_CLAUSE list) =
    (fmt_component_clause fmtinfo x; fmt_component_clause_list fmtinfo xs)
and €fmt_length_clause› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({attribute=a, exp=e} : LENGTH_CLAUSE) = (
	outf "FOR"; (fmt_exp fmtinfo a);
	outf "USE"; (fmt_exp fmtinfo e); outf ";"; outf "\n"
)
and €fmt_enumeration_representation_clause› (fmtinfo as {outf,...} : PP_FMT_INFO)
    ({name=n, exp=e} : ENUMERATION_REPRESENTATION_CLAUSE) = (
	outf "FOR"; (fmt_id fmtinfo n); outf "USE"; 
	(fmt_exp fmtinfo e); outf ";"; outf "\n"
)
and €fmt_record_representation_clause› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, alignment_opt=Value a,  component_pack=c} :
	RECORD_REPRESENTATION_CLAUSE) = (
	outf "FOR"; (fmt_id fmtinfo n); outf "USE"; outf "\n";
	inc_tabs();
		outf "RECORD AT MOD"; (fmt_exp fmtinfo a); 
		outf ";"; outf "\n";
		(fmt_component_clause_list fmtinfo c);
		outf "END RECORD;";
	dec_tabs(); outf "\n"
 ) | fmt_record_representation_clause (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, alignment_opt=Nil, component_pack=c} :
	RECORD_REPRESENTATION_CLAUSE) = (
	outf "FOR"; (fmt_id fmtinfo n); outf "USE"; outf "\n"; 
	inc_tabs();
		outf "RECORD"; outf "\n";
		(fmt_component_clause_list fmtinfo c);
		outf "END RECORD;";
	dec_tabs();
	outf "\n"
)
and €fmt_address_clause› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, exp=e} : ADDRESS_CLAUSE) = (
	outf "FOR"; (fmt_id fmtinfo n);
	outf " USE AT"; 
	(fmt_exp fmtinfo e); outf ";"; outf "\n"
)
and €fmt_representation_clause› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(RCLength x : REPRESENTATION_CLAUSE) =
    (fmt_length_clause fmtinfo x)
  | fmt_representation_clause (fmtinfo as {outf,...} : PP_FMT_INFO)
	(RCEnumeration x : REPRESENTATION_CLAUSE) =
    (fmt_enumeration_representation_clause fmtinfo x)
  | fmt_representation_clause (fmtinfo as {outf,...} : PP_FMT_INFO)
	(RCRecord x : REPRESENTATION_CLAUSE) =
    (fmt_record_representation_clause fmtinfo x)
  | fmt_representation_clause (fmtinfo as {outf,...} : PP_FMT_INFO)
	(RCAddress x : REPRESENTATION_CLAUSE) =
    (fmt_address_clause fmtinfo x)

=TEX

Declarations, these are defined simultaneously since they can be recursive.

=SML
and €fmt_procedure_declaration› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, formal_part=f, spec=Value s, annotation=ann}
		: PROCEDURE_DECLARATION) =
    in_new_scope true n (fn () =>
    (if is_expansion_selected fmtinfo
    then (
	outf "PROCEDURE"; 
	(fmt_id fmtinfo n);
	(fmt_parameter_specification_list fmtinfo f); outf ";"; outf "\n";
	inc_tabs(); outf "-- Spec ..."; outf "\n"; dec_tabs()
    ) else (
	outf "PROCEDURE"; 
	(fmt_id fmtinfo n);
	(fmt_parameter_specification_list fmtinfo f); outf "\n";
	inc_tabs(); (fmt_spec fmtinfo s); outf ";"; 
	outf "\n"; dec_tabs()
    );
    fmt_annotation fmtinfo ann
    )
)
  | fmt_procedure_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, formal_part=f, spec=Nil, annotation=ann}
		: PROCEDURE_DECLARATION) =
    in_new_scope true n (fn () => (
	outf "PROCEDURE"; (fmt_id fmtinfo n);
	(fmt_parameter_specification_list fmtinfo f); 
	outf ";"; outf "\n";
	fmt_annotation fmtinfo ann
   )
)
and €fmt_function_declaration› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({designator=d, return=r, formal_part=f, spec=Value s, annotation=ann}
		: FUNCTION_DECLARATION) =
    in_new_scope true d (fn () =>
    (if is_expansion_selected fmtinfo
    then (
	outf "FUNCTION";(fmt_id fmtinfo d);
	(fmt_parameter_specification_list fmtinfo f); outf "RETURN";
	(fmt_tmark fmtinfo r); outf ";"; outf "\n";
	inc_tabs(); outf "-- Spec ..."; dec_tabs(); outf "\n"
    ) else (
	outf "FUNCTION";(fmt_id fmtinfo d);
	(fmt_parameter_specification_list fmtinfo f); 
	outf "RETURN"; (fmt_tmark fmtinfo r); outf "\n";
	inc_tabs(); (fmt_spec fmtinfo s); outf ";"; outf "\n";
	dec_tabs()
    );
    fmt_annotation fmtinfo ann
    )
)  | fmt_function_declaration  (fmtinfo as {outf,...} : PP_FMT_INFO)
	({designator=d, return=r, formal_part=f, spec=Nil,annotation=ann} :
	FUNCTION_DECLARATION) = (
    in_new_scope true d (fn () => (
	outf "FUNCTION";(fmt_id fmtinfo d);
	(fmt_parameter_specification_list fmtinfo f); outf "RETURN"; 
	(fmt_tmark fmtinfo r); outf ";"; outf "\n";
	fmt_annotation fmtinfo ann
    ))
)
and €fmt_procedure_stub› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(x as {spec, name, formal_part, ...} : PROCEDURE_DECLARATION) =
    in_new_scope true name (fn () =>
    case spec of
    Nil => (
	outf "PROCEDURE"; (fmt_id fmtinfo name);
	(fmt_parameter_specification_list fmtinfo formal_part);
	outf "IS SEPARATE;"; outf "\n"
    ) | Value s => (
	if is_expansion_selected fmtinfo
	then (
		outf "PROCEDURE"; (fmt_id fmtinfo name);
		(fmt_parameter_specification_list fmtinfo formal_part);
		outf "\n";
		outf "-- Spec ..."; outf "\n";
		outf "IS SEPARATE;"; outf "\n"
	) else (
		outf "PROCEDURE"; (fmt_id fmtinfo name);
	(fmt_parameter_specification_list fmtinfo formal_part);
		outf "\n";
		fmt_spec fmtinfo s; outf "\n";
		outf "IS SEPARATE;"; outf "\n"
	))
)
and €fmt_function_stub› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(x as {spec, designator, formal_part, return, ...}
			: FUNCTION_DECLARATION) = (
    in_new_scope true designator (fn () =>
    case spec of
    Nil => (
	    outf "FUNCTION";(fmt_id fmtinfo designator);
		(fmt_parameter_specification_list fmtinfo formal_part);
		outf "RETURN"; 
	(fmt_tmark fmtinfo return); outf "\n"; 
		outf "IS SEPARATE;"; outf "\n"
    ) | Value s => (
	if is_expansion_selected fmtinfo
	then (
	    outf "FUNCTION";(fmt_id fmtinfo designator);
		(fmt_parameter_specification_list fmtinfo formal_part); 
		outf "RETURN"; 
		(fmt_tmark fmtinfo return); outf "\n";
		outf "-- Spec ..."; outf "\n";
		outf "IS SEPARATE;"; outf "\n"
	) else (
	    outf "FUNCTION";(fmt_id fmtinfo designator);
		(fmt_parameter_specification_list fmtinfo formal_part); 
		outf "RETURN"; 
		(fmt_tmark fmtinfo return); outf "\n";
		fmt_spec fmtinfo s; outf "\n";
		outf "IS SEPARATE;"; outf "\n"
	)
    ))
)
and €fmt_package_stub› (fmtinfo as {outf,...} : PP_FMT_INFO) (n : ID) = (
	outf "PACKAGE BODY";
	(fmt_id fmtinfo n); outf "IS SEPARATE;";
	outf "\n"
)
and €fmt_auxiliary› (fmtinfo as {outf,...} : PP_FMT_INFO) (av : AUX_VAR) =
    (if is_expansion_selected fmtinfo
    then    (outf "-- AUXILIARY ... ;"; outf "\n")
    else    (
	outf "-- AUXILIARY"; (fmt_z_id fmtinfo (#aux av));
	outf" ;"; outf "\n"
    )
)
and €fmt_using› (fmtinfo as {outf,...} : PP_FMT_INFO) (u : USING_DEC) =
    (if is_expansion_selected fmtinfo
    then (
	outf  "-- USING ..."; outf "\n";
	fmt_basic_decl_list fmtinfo (#basic_decls u); outf "\n";
	outf "-- IMPLEMENT ... BY ... ;"; outf "\n"
    ) else (
	outf "USING"; outf "\n";
	(fmt_basic_decl_list fmtinfo (#basic_decls u));
	outf "IMPLEMENT"; (fmt_z_tm fmtinfo (#aux u));
	outf "BY"; (fmt_z_tm fmtinfo (#invariant u));
	outf " ;"; outf "\n"
    ))
and €fmt_package_declaration› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, visible_decs=v, private_decs=p, annotation=ann} :
    DECLARATION PACKAGE_DECLARATION) = (
    (in_new_scope false n (fn () => (
	outf "PACKAGE"; fmt_id fmtinfo n; outf "\n";
	fmt_annotation fmtinfo ann;
	outf "IS"; outf "\n";
	(inc_tabs();
		fmt_declaration_list fmtinfo v;
	dec_tabs()))
    ));
    (case p
	of [] => ()
	| _ => (outf "PRIVATE"; outf "\n";
		in_new_scope false n
		(fn () => (inc_tabs();
			fmt_declaration_list fmtinfo p;
			dec_tabs())
		))
    );
    outf "END"; (fmt_id fmtinfo n); outf ";"; outf "\n"
   )
and €fmt_declaration› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(DDeclarationKSlot (x, _) : DECLARATION) =
    (fmt_k_slot fmtinfo x)
  | fmt_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(DRenamingDeclaration x : DECLARATION) =
    (fmt_renaming_declaration fmtinfo x)
  | fmt_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(DBasicDecl x : DECLARATION) =
    (fmt_basic_decl fmtinfo x)
  | fmt_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(DRepresentationClause x : DECLARATION) =
    (fmt_representation_clause fmtinfo x)
  | fmt_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(DProperBody x : DECLARATION) =
    (fmt_proper_body fmtinfo x)
  | fmt_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(DProcedureDeclaration x : DECLARATION) =
    (fmt_procedure_declaration fmtinfo x)
  | fmt_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(DFunctionDeclaration x : DECLARATION) =
    (fmt_function_declaration fmtinfo x)
  | fmt_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(DPackageDeclaration x : DECLARATION) =
    (fmt_package_declaration fmtinfo x)
  | fmt_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(DProcedureStub x : DECLARATION) =
    (fmt_procedure_stub fmtinfo x)
  | fmt_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(DFunctionStub x : DECLARATION) =
    (fmt_function_stub fmtinfo x)
  | fmt_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(DPackageStub x : DECLARATION) =
    (fmt_package_stub fmtinfo x)
  | fmt_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(DExternalProcedureStub x : DECLARATION) =
    (fmt_procedure_declaration fmtinfo x)
  | fmt_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(DExternalFunctionStub x : DECLARATION) =
    (fmt_function_declaration fmtinfo x)
  | fmt_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(DAuxiliary x : DECLARATION) =
    (fmt_auxiliary fmtinfo x)
  | fmt_declaration (fmtinfo as {outf,...} : PP_FMT_INFO)
	(DUsing x : DECLARATION) =
    (fmt_using fmtinfo x)
=TEX
=SML
and €fmt_declaration_list› (fmtinfo as {outf,...} : PP_FMT_INFO) ([] : DECLARATION list) = ()
  | fmt_declaration_list (fmtinfo as {outf,...} : PP_FMT_INFO) (x::xs : DECLARATION list) =
    (fmt_declaration fmtinfo x; fmt_declaration_list fmtinfo xs)
and €fmt_procedure_body› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({procedure_spec=p, declarative_part=d, statement=s} :
	DECLARATION PROCEDURE_BODY) = (
    do_soundness_checks2 get_replacement false s;
	let val res = (fmt_procedure_specification fmtinfo p;
			outf "IS"; outf "\n";
			(inc_tabs();
				fmt_declaration_list fmtinfo d;
			dec_tabs());
			outf "BEGIN"; outf "\n";
			(inc_tabs();
				fmt_statement fmtinfo s;
			dec_tabs());
			outf "END";
			(fmt_id fmtinfo (#name p)); outf ";"; outf "\n");
	in	pop_scope (); res
	end
)
and €fmt_function_body› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({function_spec=f, declarative_part=d, statement=s} :
	DECLARATION FUNCTION_BODY) = (
    do_soundness_checks2 get_replacement true s;
	let val res = (fmt_function_specification fmtinfo f;
			outf "IS"; outf "\n";
			(inc_tabs(); 
				fmt_declaration_list fmtinfo d;
			dec_tabs());
			outf "BEGIN"; outf "\n";
			(inc_tabs();fmt_statement fmtinfo s; dec_tabs());
			outf "END"; (fmt_id fmtinfo (#designator f));
			outf ";"; outf "\n");
	in	pop_scope(); res
	end
)
and €fmt_package_body› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, decls=d, statement=s, annotation=ann}
		: DECLARATION PACKAGE_BODY) = (
    in_new_scope false n (fn () => (
    do_soundness_checks2 get_replacement false s;
    outf "PACKAGE BODY"; fmt_id fmtinfo n; outf "\n";
    fmt_annotation fmtinfo ann;
    (outf "IS"; outf "\n");
    inc_tabs(); fmt_declaration_list  fmtinfo d; dec_tabs();
    (case s
    of SStmt STImplicitNull => ()
    | _ => (outf "BEGIN"; outf "\n"; 
	inc_tabs();fmt_statement fmtinfo s; dec_tabs())
    );
    outf "END"; (fmt_id fmtinfo n); outf ";"; outf "\n")
))
and €fmt_proper_body› (fmtinfo as {outf,...} : PP_FMT_INFO) (PBProcedure x : PROPER_BODY) =
    (fmt_procedure_body fmtinfo x)
  | fmt_proper_body (fmtinfo as {outf,...} : PP_FMT_INFO) (PBFunction x : PROPER_BODY) =
    (fmt_function_body fmtinfo x)
  | fmt_proper_body (fmtinfo as {outf,...} : PP_FMT_INFO) (PBPackage x : PROPER_BODY) =
    (fmt_package_body fmtinfo x)

=TEX

Compilation subunits.

=SML

and €fmt_compilation_subunit› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({name=n, proper_body=p} : COMP_SUBUNIT) = (
	outf "SEPARATE"; outf "(";
	(fmt_id fmtinfo n); outf")"; outf "\n";
	(inc_tabs(); fmt_proper_body fmtinfo p; dec_tabs())
)

=TEX

Compilation units.

=SML

and €fmt_context_clause› (fmtinfo as {outf,...} : PP_FMT_INFO) ([] : ID list) = ()
  | fmt_context_clause (fmtinfo as {outf,...} : PP_FMT_INFO) (x : ID list) = (
	outf "WITH"; fmt_id_list fmtinfo x; outf ";"; outf "\n"
)
and €fmt_compilation_unit› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(CUPackageDeclaration x : COMPILATION_UNIT) =
    (fmt_package_declaration fmtinfo x)
  | fmt_compilation_unit (fmtinfo as {outf,...} : PP_FMT_INFO)
	(CUProperBody x : COMPILATION_UNIT) =
    (fmt_proper_body fmtinfo x)
  | fmt_compilation_unit (fmtinfo as {outf,...} : PP_FMT_INFO)
	(CUSubUnit x : COMPILATION_UNIT) =
    (fmt_compilation_subunit fmtinfo x)
and €fmt_context_compilation_unit› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({context=i, comp_unit=c,pragmas=p,annotation=ann}
		: CONTEXT_COMPILATION_UNIT) =
    (fmt_context_clause fmtinfo i;
    (map (fmt_pragma fmtinfo) p);
    (fmt_annotation fmtinfo ann);
    (fmt_compilation_unit fmtinfo c) 
)
and €fmt_kslot_compilation_unit› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(KCUKSlot x : KSLOT_COMPILATION_UNIT) =
    (fmt_k_slot fmtinfo x)
  | fmt_kslot_compilation_unit (fmtinfo as {outf,...} : PP_FMT_INFO)
	(KCUUnit x : KSLOT_COMPILATION_UNIT) =
    (fmt_context_compilation_unit fmtinfo x)
  | fmt_kslot_compilation_unit (fmtinfo as {outf,...} : PP_FMT_INFO)
	(KCUPragma x : KSLOT_COMPILATION_UNIT) =
    (fmt_pragma fmtinfo x)
and €fmt_kslot_compilation_unit_list› (fmtinfo as {outf,...} : PP_FMT_INFO)
    ([] : KSLOT_COMPILATION_UNIT list) = ()
  | fmt_kslot_compilation_unit_list (fmtinfo as {outf,...} : PP_FMT_INFO)
    (x::xs : KSLOT_COMPILATION_UNIT list) =
    (fmt_kslot_compilation_unit fmtinfo x;
    outf "\n"; outf "\n";
    fmt_kslot_compilation_unit_list fmtinfo xs)

=TEX

=SML

and €fmt_replaced_by_comp› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({label=l, comp=c} : REPLACED_BY_COMP) =
    (fmt_label fmtinfo l; outf "È"; outf "\n";
    inc_tabs();  
	fmt_kslot_compilation_unit_list fmtinfo c;
    dec_tabs())
and €fmt_replaced_by_private_part› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({label=l, private=p} : REPLACED_BY_PRIVATE_PART) =
    (fmt_label fmtinfo l; outf "È"; outf "\n";
	inc_tabs();
		fmt_declaration_list fmtinfo p;
	dec_tabs())
and €fmt_replaced_by_visible_part› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({label=l, visible=v} : REPLACED_BY_VISIBLE_PART) =
    (fmt_label fmtinfo l; outf "È"; outf "\n";
	inc_tabs(); fmt_declaration_list fmtinfo v; dec_tabs())
and €fmt_replaced_by_decl› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({label=l, decls=d} : REPLACED_BY_DECL) =
    (fmt_label fmtinfo l; outf "È"; outf "\n";
	inc_tabs(); fmt_declaration_list  fmtinfo d; dec_tabs())
and €fmt_refined_by› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({label=l, statement=s} : REFINED_BY) =
	(fmt_label fmtinfo l; outf "√";
	outf "\n"; inc_tabs();fmt_statement fmtinfo s; dec_tabs())
and €fmt_replaced_by› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({label=l, statement=s} : REFINED_BY) =
    (fmt_label fmtinfo l; outf "È"; outf "\n";
	inc_tabs();fmt_statement fmtinfo s; dec_tabs())
and €fmt_replaced_by_annotation› (fmtinfo as {outf,...} : PP_FMT_INFO)
	({label=l, replacement=a} : REPLACED_BY_ANNOTATION) =
    (fmt_label fmtinfo l; outf "È"; outf "\n";
	inc_tabs(); fmt_annotation fmtinfo a; dec_tabs());

=TEX

Web Clauses.

=SML

fun €fmt_web_clause› (fmtinfo as {outf,...} : PP_FMT_INFO)
	(WCCompilation x : WEB_CLAUSE) =
    (fmt_kslot_compilation_unit_list fmtinfo x)
  | fmt_web_clause (fmtinfo as {outf,...} : PP_FMT_INFO)
	(WCReplacedByCompilation x : WEB_CLAUSE) =
    (fmt_replaced_by_comp fmtinfo x)
  | fmt_web_clause (fmtinfo as {outf,...} : PP_FMT_INFO)
	(WCReplacedByPrivatePart x : WEB_CLAUSE) =
    (fmt_replaced_by_private_part fmtinfo x)
  | fmt_web_clause (fmtinfo as {outf,...} : PP_FMT_INFO)
	(WCReplacedByVisiblePart x : WEB_CLAUSE) =
    (fmt_replaced_by_visible_part fmtinfo x)
  | fmt_web_clause (fmtinfo as {outf,...} : PP_FMT_INFO)
	(WCReplacedByDecl x : WEB_CLAUSE) =
    (fmt_replaced_by_decl fmtinfo x)
  | fmt_web_clause (fmtinfo as {outf,...} : PP_FMT_INFO)
	(WCReplacedByArbitraryAda x : WEB_CLAUSE) =
    (fmt_replaced_by_arbitrary_ada fmtinfo x)
  | fmt_web_clause (fmtinfo as {outf,...} : PP_FMT_INFO)
	(WCRefinedBy x : WEB_CLAUSE) =
    (fmt_refined_by fmtinfo x)
  | fmt_web_clause (fmtinfo as {outf,...} : PP_FMT_INFO)
	(WCReplacedBy x : WEB_CLAUSE) =
    (fmt_replaced_by fmtinfo x)
  | fmt_web_clause (fmtinfo as {outf,...} : PP_FMT_INFO)
	(WCReplacedByAnnotation x : WEB_CLAUSE) =
    (fmt_replaced_by_annotation fmtinfo x);

=TEX

\section{PRINTING AND OUTPUTTING SPARK}
=SML
val dummy1 = (let
	val lcontrol : int ref = ref 80;
in
(new_int_control{name="cn_automatic_line_splitting",
	control=lcontrol,
	default = (fn () => 80),
	check = (fn (x:int) => 0 <= x)}
handle (Fail _) => () (* assume control already present *)
)
end);
=TEX
=SML

fun €make_output_fun› (outs : outstream) : string -> unit = (
reset_tabs();
let  val max_line_len = get_int_control("cn_automatic_line_splitting");
    val diag_fragment: string -> unit =  (
	(fn s => output(outs, s)) o translate_for_output
    );
    val curr_line_length : int ref = ref 0;
    val skipspace : bool ref = ref false;
    fun out_fun (s : string) : unit = (
	if (s = "\n")
	then (
		skipspace := false;
		curr_line_length := 0;
		diag_fragment("\n");
		()
	) else (
		let val len_s = size(s);
		in
			if ((!curr_line_length) = 0) 
			then (  skipspace := false; 
				let	val tab_s = fmt_tabs(get_PPTab_no());
					val len_tab_s = size(tab_s);
				in
				(diag_fragment(tab_s);
				    diag_fragment(s);
				    curr_line_length := len_tab_s + len_s;
				    ())
				end
			) else (
				if (len_s + (!curr_line_length) >= max_line_len)
				then ( diag_fragment("\n");
					curr_line_length := 0;
					skipspace := false;
					out_fun(s);
				    ()
				) else (
					if (s = ";" orelse s = "," orelse s = ")" 
						orelse s = "." orelse s = "'" orelse s = ".."
						orelse !skipspace)
					then ()
					else (diag_fragment(" ");
						curr_line_length := (!curr_line_length) + 1; ());
					diag_fragment(s);
					if (s = "'" orelse s = "(" orelse s = "." orelse s = "..")
					then skipspace := true
					else skipspace := false;
					curr_line_length := (!curr_line_length) + len_s;
					()
				)
			)
		end
	));
in
   (out_fun)
end);
=IGN
set_int_control("cn_automatic_line_splitting", 40);
val outf = make_output_fun(std_out);
(outf "\n"; outf "12345"; inc_tabs(); outf "12345";outf "12345";outf "12345";outf "12345";
outf "12345";outf "12345";outf "12345";outf "12345";outf "12345";
outf "12345";outf "12345";outf "12345";outf "12345";
outf "12345";outf "12345";outf "12345";outf "12345";outf "12345";
outf "12345";outf "12345";outf "12345";inc_tabs(); outf "12345";outf "12345";
outf "12345";outf "12345";outf "12345";outf "\n");
=SML

fun €format_web_clause› (fmtfn : (LABEL -> REPLACEMENT OPT) OPT) 
	(x : WEB_CLAUSE) : unit = (
let val outf = make_output_fun std_out;
in
	(
	reset_tabs();
	fmt_web_clause {outf = outf, fmtfn = fmtfn} x;
	reset_tabs())
end);

val €print_web_clause› : WEB_CLAUSE -> unit = (
    format_web_clause Nil
);

fun €print_spark_program› (() : unit) : unit = with_clash_checks (fn () =>
   ( format_web_clause (Value get_replacement)
    (WCCompilation (#spark_prog (get_z_generator_state()))))
);

fun €output_spark_program› ({out_file : string}) = with_clash_checks (fn () =>
let	val stream = open_out out_file;
	val outf = make_output_fun stream;
    val x = (WCCompilation (#spark_prog (get_z_generator_state())));
in
	(
	reset_tabs();
	fmt_web_clause  {outf = outf, fmtfn = (Value get_replacement)} x;
	reset_tabs();
	close_out stream
	)
end);

=TEX
\subsection{SPARK to Lists of Strings}
For various reasons, functions wish to apply a format function to a piece of
abstract syntax, and gain list of strings, each string being a logical line 
of output, neither indented nor split merely due to length.
The following function takes and $fmt\_$ function and does what is necessary:
=SML
fun €strings_from_fmt› (fmt : PP_FMT_INFO -> 'a -> unit) (syntax : 'a) : string list = (
reset_tabs();
let val skipspace : bool ref = ref false;
    val strings : string list ref = ref [];
    val curr_str : string ref = ref "";
    val was_ll = set_int_control("line_length", 80);
    fun out_fun (s : string) : unit = (
	if (s = "\n")
	then (
		skipspace := false;
		strings := !strings @ [!curr_str];
		curr_str := "";
		()
	) else (
		if (s = ";" orelse s = "," orelse s = ")" 
			orelse s = "." orelse s = "'" orelse s = ".."
			orelse !skipspace)
		then ()
		else (curr_str := !curr_str ^ " ");
		curr_str := !curr_str ^ s;
		if (s = "'" orelse s = "(" orelse s = "." orelse s = "..")
		then skipspace := true
		else skipspace := false;
		()
	)
    );
in
   (
	reset_tabs();
	fmt {outf = out_fun, fmtfn = Nil} syntax;
	reset_tabs();
	set_int_control("line_length", was_ll);
	(!strings)
   )
end);
=TEX
\section{EPILOGUE}

=SML

end (* of structure CNSparkOutput *);

=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
