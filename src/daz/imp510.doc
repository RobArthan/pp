% @(#) 95/04/19 1.41 imp510.doc
=TEX
\documentstyle[hol1,11pt,TQ]{article}
\ftlinepenalty=9999
\def\Hide#1{}
\def\Bool{``$\it{:}bool\,$''}
\makeindex
\TPPproject{DAZ PROJECT}  %% Mandatory field
%\TPPvolume{}
%\TPPpart{}
\TPPtitle{Implementation: SPARK Output Function}  %% Mandatory field
\TPPref{ISS/HAT/DAZ/IMP510}  %% Mandatory field
\def\SCCSversion{$Revision$%
}
\TPPissue{\SCCSversion}  %% Mandatory field
\TPPdate{\FormatDate{$Date$%
}}
\TPPstatus{Draft}            %% Mandatory field
\TPPtype{Specification}
\TPPkeywords{CN}
\TPPauthor{A.C.~Hayward & WIN01}  %% Mandatory field
%\TPPauthors{Name 1&location 1\\Name 2&location 2\\Name 3&location 3}
\TPPauthorisation{D.J.~King & DAZ Team Leader}
\TPPabstract{
This document contains the implementation for the SPARK output function.}
%\TPPabstractB{}
%\TPPabstractC{}
%\TPPabstractD{}
%\TPPabstractE{}
%\TPPabstractF{}
\TPPdistribution{\parbox[t]{4.0in}{%
    Library}}

%\TPPclass{CLASSIFICATION}
%\def\TPPheadlhs{}
%\def\TPPheadcentre{}
%def\TPPheadrhs{}
\newfont{\icllogo}{icllogo50}
\def\TPPheadlhs{$\vcenter{\halign{##\cr\icllogo ICL\cr}}$}
%\def\TPPfootlhs{}
%\def\TPPfootcentre{}
%\def\TPPfootrhs{}

\begin{document}
\TPPsetsizes
\makeTPPfrontpage

\vfill
\begin{centering}

\bf Copyright \copyright\ : International Computers Ltd \number\year

\end{centering}

\newpage
\section{DOCUMENT CONTROL}
\subsection{Contents List}
\tableofcontents
\subsection{Document Cross References}
\bibliographystyle{fmu}
\bibliography{daz,fmu}

\subsection{Changes History}  % to get section number `0.3'
\begin{description}

\item[Issues 1.1-1.18, \FormatDate{94/03/28}]
Initial Drafts.
\item[Issue 1.19, \FormatDate{94/10/05}]
Added calls to CaseIndependence.get_external_name.
\item[Issue 1.20, \FormateDate{94/10/10}]
Updated in line with changes to SPEC.
\item[Issue 1.21. \FormatDate{94/10/10}]
Removed output_spark_program1 and changed interface to output_spark_program.
\item[Issue 1.22. \FormatDate{94/10/13}]
Added support for auxiliary variables.
\item[Issue 1.23. \FormatDate{94/10/14}]
Fixed bugs in function/procedure declaration handling and corrected aux vars.
\item[Issue 1.24. \FormatDate{94/10/14}]
Removed variant records from the implementation.
\item[Issue 1.25. \FormatDate{94/10/14}]
Added newlines afte compilation units.
\item[Issue 1.26. \FormatDate{94/11/02}]
Fixed problem with outputting the letter Q to a file.
\item[Issue 1.27. \FormatDate{94/11/03}]
Fixed to use get_cn_state rather than !spark_prog.
\item[Issue 1.28. \FormatDate{94/11/03}]
Changed SUBUNIT to COMP_SUBUNIT.
\item[Issue 1.29. \FormatDate{94/11/09}]
Adjusted for new AS constructor.
\item[Issue 1.30. \FormatDate{94/11/14}]
Rationalised the structure wrapping.
\item[Issue 1.31. \FormatDate{94/11/15}]
Replacement env now distinguishes refinements from replacements.
\item[Issue 1.32. \FormatDate{94/11/18}]
Fixed a problem with printing labels (now need to add brackets).
\item[Issue 1.33. \FormatDate{94/11/18}]
Added kslot brackets.
\item[Issue 1.34. \FormatDate{94/11/24}]
Added first cut of calls to the soundness checking algorithm .
\item[Issue 1.35-1.39. \FormatDate{94/12/08}]
Minor corrections.
\item[Issue 1.40]
Renamed call of $get\_cn\_state$ to be $get\_z\_generator\_state$.
\item[Issue 1.41]
Fixed DRA bug 3 (batch 1)
\item[Issue 1.42]
Fixed DRA bug 20 (batch 2)
\item[Issue 1.43]
Fixed DRA bug 5 (batch 2)
\item[Issues 1.44,1.45]
Added annotations and pragmas.
\item[Issues 1.46]
Fixed bug in printing of unreplaced compilation unit k-slot.
\item[Issue 1.47] Enhancement 3.
\item[Issue 1.48] Added name-clash checking (which fixes bug 15 inter alia).
\item[Issue 1.49] Fixed DRA bugs 14 and issue 2 (V0.6).
\item[Issue 1.50] Fixed DRA bug 11 (V0.6).
\end{description}

\subsection{Changes Forecast}
None.
\pagebreak

\section{GENERAL}
\subsection{Scope}

This document contains the implementation for the Compliance Notation Output functions.  The detailed design for this material is in \cite{ISS/HAT/DAZ/DTD510} and the module tests are in \cite{ISS/HAT/DAZ/MDT503}.

\subsection{Introduction}

\subsection{Purpose and Background}

One signature is implemented in this document, $CNSparkOutput$.  The functions in this signature are not intended to be called directly by the user.  Instead \cite{ISS/HAT/DAZ/DTD516} details some top-level functions which use this signature.

\subsection{Dependencies}

The functions in this signature depend on the data types introduced in the structures $CNTypes$, $CNTypes1$, $CNVCGenerator$, $CNZGenerator$ and $ZUserInterfaceSupport$ which are defined in \cite{ISS/HAT/DAZ/DTD513}, \cite{ISS/HAT/DAZ/DTD514}, \cite{ISS/HAT/DAZ/DTD505}, \cite{ISS/HAT/DAZ/DTD507} and \cite{DS/FMU/IED/DTD079}.

\section{THE STRUCTURE $CNSparkOutput$}

=SML
structure €CNSparkOutput› : CNSparkOutput = struct
    open    CNTypes CNTypes1 CNVCGenerator CNZGenerator;
    open    ZUserInterfaceSupport;
=TEX
\subsection{Checking for Name Clashes}
This module is responsible for implementing the SPARK rules against redeclaration of identifiers as required in \cite{DRA/CIS/CSE3/TR/94/27/2}, volume 1.
Some checking is done as web clauses are entered, but only when the program is output is all the information needed to make a comprehensive check available.
The following ML data structures and access functions are used to record information about declarations as they are encounetered.

The boolean flag is only set true in the call from the functions which print or output the entire SPARK program.
The flag is used to ensure that diagnostic routines etc. using the lower-level formatting routines directly will not indefinitely consume resources.
N.b. some functions use the stack variable directly for special effects, so they must do so in a way which won't consume resources if the flag is false.
=SML
val €clash_checking› : bool ref = ref false;
type €SCOPE› = {block : ID, names : ID list};
val €stack› : SCOPE list ref = ref [];
fun €push_scope› (block : ID) : unit = (
	if	!clash_checking
	then	stack := {block=block, names=[]} :: !stack
	else	()
);
fun €pop_scope› () : unit = (
	if	!clash_checking
	then	case !stack of
			[] => ()
		|	_ :: more => (stack := more)
	else	()
);
=TEX
The following data structures and functions are used to accumulate a list of name-clash errors.
=SML
type €CLASH_INFO› = {name1 : ID list, name2 : ID list};
val €clashes› : CLASH_INFO list ref = ref [];
fun €check_decl› (name : ID) : unit = (
if	!clash_checking
then	let	fun full_name (st : SCOPE list) (n : ID) : ID list = (
			rev(n :: (map #block st less ""))
		);
		fun scan [] = ()
		|   scan (st as ({block, names} :: more)) = (
			if	name mem names
			then	(clashes := !clashes grab
					{name1 = full_name st name,
					 name2 = full_name (!stack) name};
				scan more)
			else	scan more
		);
	in	scan (!stack);
		case !stack of
			[] => (
				stack := [{block="", names =[name]}]
		) |	{block, names} :: more => (
				stack :=
				{block=block,names=names grab name}::more
		)
	end
else	()
);
=TEX
In many cases the following gives a convenient idiom:
=SML
fun €in_new_scope› (check_n : bool) (n : ID) (what : unit -> 'b) : 'b = (
	(if check_n then check_decl n else ());
	push_scope n;
	let	val res = what ();
	in	pop_scope ();
		res
	end
);
=TEX
=SML
fun €with_clash_checks› (what : unit -> 'a) : 'a = (
	clashes := [];
	clash_checking := true;
	let	fun show_name n = format_list Combinators.I n ".";
		fun report_clash {name1, name2} = (
			diag_line
				(get_error_message 510002
					[show_name name1, show_name name2])
		);
		fun report_results cls = (
			case cls of
			[]	=> ()
		|	_ => (
				diag_line (get_error_message 510001 []);
				map report_clash cls;
				fail "clash_checks" 510003 []
			)
		);
		val res = what();
		val cls = !clashes;
	in	clash_checking := false;
		clashes := [];
		report_results cls;
		res
	end
)	handle ex => (clash_checking := false; clashes := []; raise ex);
=TEX
\subsection{Low level functions}

These functions deal with the low-level output of characters.

=SML

val €PPTabSize› : int ref = ref 2;
type €PP_FMT_INFO› = {
    tabs : int,
    line_length : int,
    fmtfn : (LABEL -> REPLACEMENT OPT) OPT
    };
fun €set_PPTab_size› (x : int) = (PPTabSize := x);
fun €get_PPTab_size› ( () : unit) : int = !PPTabSize;
fun €fmt_spaces› (i : int) : string =
   if i=0 then "" else " "^fmt_spaces(i-1);
fun €fmt_tabs› (i : int) : string = fmt_spaces(i * get_PPTab_size());

fun €fmt_info_string_list›([] : (PP_FMT_INFO * string) list) = ""
  | fmt_info_string_list((i,x)::xs : (PP_FMT_INFO * string) list) =
    (fmt_tabs (#tabs i))^x^"\n"^(fmt_info_string_list xs);

fun €inc_tabs› ({tabs=t, line_length=ll, fmtfn=f} : PP_FMT_INFO) =
    ({tabs=(t+1), line_length=ll, fmtfn=f} : PP_FMT_INFO);

=TEX
In a few places it is important not to put extra brackets around a
bracketed construct (e.g., an array index).
In the following, we use $ord$ to avoid exploding the string.
=SML
local
   val ord_rbrk = ord "(";
in
fun €bracket›  (s : string) : string = (
	if	s = "" orelse ord s <> ord_rbrk
	then	"(" ^ s ^ ")"
	else	s
);
end;
=SML
fun €is_expansion_selected› (FmtInfo : PP_FMT_INFO) : bool = (
    case #fmtfn FmtInfo of
        Value _ =>     true
    |    Nil =>        false
);
=TEX

=SML
fun €fmt_z_tm› (z_tm : Z_TM) : string = (
    case z_tm of
        ZTmFancyApp ((TmplPre (("ê", Nil), StubUS), ""),
          ZTmTuple[z_tm']) => (
            format_z_tm z_tm'
    ) |    ZTmFancyApp ((TmplPre (("ê", Nil), StubUS), ""), z_tm') => (
            format_z_tm z_tm'
    ) |    _ => format_z_tm z_tm
);
=TEX

Leaf functions, these don't call any other functions.

=SML

fun €fmt_id› (n : ID) : string  = (
	let	fun break_up acc (lhs, "o"::rest) = (
			break_up ((implode o rev) lhs::acc) ([], rest)
		) | break_up acc (lhs, (c::rest)) = (
			break_up acc (c::lhs, rest)
		) | break_up acc (lhs, []) = (
			(implode o rev) lhs::acc, ([], [])
		);
		val comps = (	  map CaseIndependence.get_external_name o rev
				o fst o (break_up [])) ([], explode n);
		fun fmt_aux (a::b::rest) = (
			a^"."^fmt_aux (b::rest)
		) | fmt_aux (a::rest) = a
		  | fmt_aux [] = "";
	in
		fmt_aux comps
	end
);
fun €fmt_tmark› (t : TMARK) : string = fmt_id t;

fun €fmt_term› (z : TERM) : string =
    (implode o tl o rev o tl o rev o explode o string_of_term)(z);
fun €fmt_label› (label : LABEL) = "("^label^") ";
fun €fmt_unary_op› (UOSparkUnaryAdd : UNARY_OP) = "+"
  | fmt_unary_op (UOSparkUnaryMinus : UNARY_OP) = "-"
  | fmt_unary_op (UOSparkNot : UNARY_OP) = "not "
  | fmt_unary_op (UOSparkAbs : UNARY_OP) = "abs ";
fun €fmt_binary_op› (BOSparkAdd : BIN_OP) = " + "
  | fmt_binary_op (BOSparkAnd : BIN_OP) = " and "
  | fmt_binary_op (BOSparkAndThen : BIN_OP) = " and then "
  | fmt_binary_op (BOSparkConcat : BIN_OP) = " & "
  | fmt_binary_op (BOSparkEq : BIN_OP) = " = "
  | fmt_binary_op (BOSparkExpon : BIN_OP) = " ** "
  | fmt_binary_op (BOSparkGreater : BIN_OP) = " > "
  | fmt_binary_op (BOSparkGreaterEq : BIN_OP) = " >= "
  | fmt_binary_op (BOSparkIntdiv : BIN_OP) = " / "
  | fmt_binary_op (BOSparkLess : BIN_OP) = " < "
  | fmt_binary_op (BOSparkLessEq : BIN_OP) = " <= "
  | fmt_binary_op (BOSparkMem : BIN_OP) = " in "
  | fmt_binary_op (BOSparkMinus : BIN_OP) = " - "
  | fmt_binary_op (BOSparkMod : BIN_OP) = " mod "
  | fmt_binary_op (BOSparkNotEq : BIN_OP) = " /= "
  | fmt_binary_op (BOSparkNotMem : BIN_OP) = " not in "
  | fmt_binary_op (BOSparkOr : BIN_OP) = " or "
  | fmt_binary_op (BOSparkOrElse : BIN_OP) = " or else "
  | fmt_binary_op (BOSparkRem : BIN_OP) = " rem "
  | fmt_binary_op (BOSparkTimes : BIN_OP) = " * "
  | fmt_binary_op (BOSparkXor : BIN_OP) = " xor ";
fun €fmt_mode› (MSparkIn : MODE) = " IN "
  | fmt_mode (MSparkOut : MODE) = " OUT "
  | fmt_mode (MSparkInOut : MODE) = " IN OUT ";
fun €fmt_loop_direction› (LDForwards : LOOP_DIRECTION) = ""
  | fmt_loop_direction (LDReverse : LOOP_DIRECTION) = "REVERSE ";
fun €fmt_operator_symbol› (s : OPERATOR_SYMBOL) = s;

=TEX

Lists of leaf functions.

=SML

fun €fmt_id_list› ([] : ID list) = ""
  | fmt_id_list ([x] : ID list) = (fmt_id x)
  | fmt_id_list (x::xs: ID list) = (fmt_id x)^", "^(fmt_id_list xs);
fun €fmt_tmark_list› ([] : TMARK list) = ""
  | fmt_tmark_list ([x] : TMARK list) = (fmt_tmark x)
  | fmt_tmark_list (x::xs : TMARK list) =
    (fmt_tmark x)^", "^(fmt_tmark_list xs);

=TEX

Equivalences to leaf functions.

=SML

fun €fmt_z_id› (z : Z_ID) = fmt_id z;
fun €fmt_z_pred› (z : Z_PRED) = string_of_term z;
fun €fmt_z_exp› (z : Z_EXP) = string_of_term z;
fun €fmt_z_id› (z : Z_ID) = fmt_id z;
fun €fmt_attrib› (x : ATTRIB) = fmt_id x;
fun €fmt_int_lit› (x : INT_LIT) = (fmt_id x);

=TEX

\subsection{Expressions}

Expressions.

=SML

fun €fmt_rangelohi› ({lo=l, hi=h} : EXP RANGELOHI) = (fmt_exp l)^".."^(fmt_exp h)
and €fmt_range› (RRange x : EXP RANGE) = fmt_rangelohi x
  | fmt_range (RRangeAttr x : EXP RANGE) = fmt_exp x
and €fmt_discrete_range_constrained› ({tmark=t, range=r} :
    EXP DISCRETE_RANGE_CONSTRAINED) =
    (fmt_tmark t)^" RANGE "^(fmt_range r)
and €fmt_discrete_range› (DRRange x : DISCRETE_RANGE) = (fmt_range x)
  | fmt_discrete_range (DRConstrained x : DISCRETE_RANGE) =
    (fmt_discrete_range_constrained x)
and €fmt_agg_choice› (ACAggChoiceRange x : AGG_CHOICE) = (fmt_discrete_range x)
  | fmt_agg_choice (ACAggChoiceSingle x : AGG_CHOICE) = (fmt_exp x)
and €fmt_agg_choice_list› ([] : AGG_CHOICE list) = ""
  | fmt_agg_choice_list ([x] : AGG_CHOICE list) = (fmt_agg_choice x)
  | fmt_agg_choice_list (x::xs : AGG_CHOICE list) =
    (fmt_agg_choice x)^"|"^(fmt_agg_choice_list xs)
and €fmt_named_assoc› ({choice=c, comp=e} : (AGG_CHOICE, EXP) NAMED_ASSOC) =
    (fmt_agg_choice_list c)^" => "^(fmt_exp e)
and €fmt_named_assoc_list› ([] : (AGG_CHOICE, EXP) NAMED_ASSOC list) = ""
  | fmt_named_assoc_list ([x] : (AGG_CHOICE, EXP) NAMED_ASSOC list) =
    (fmt_named_assoc x)
  | fmt_named_assoc_list (x::xs : (AGG_CHOICE, EXP) NAMED_ASSOC list) =
    (fmt_named_assoc x)^", "^(fmt_named_assoc_list xs)
and €fmt_others› ({others=oth} : EXP OTHERS) = "OTHERS => "^(fmt_exp oth)
and €fmt_agg_pos› ({tmark=tm, comps=c} : EXP AGG_POS) =
    (case tm
        of Nil => "("^(fmt_exp_list c)^")"
         | Value t => (fmt_tmark t)^"'("^(fmt_exp_list c)^")"
    )
and €fmt_agg_pos_others› ({agg_pos = {tmark=tm, comps=c} :
    EXP AGG_POS, others = oth} : EXP AGG_POS_OTHERS) =
    (case tm
        of Nil => "("^(fmt_exp_list c)^", "^(fmt_others oth)^")"
         | Value t => (fmt_tmark t)^"'("^(fmt_exp_list c)^", "^(fmt_others oth)^")"
    )
and €fmt_agg_others› ({tmark=tm, others=oth} : EXP AGG_OTHERS) =
    (case tm
        of Nil =>  "("^(fmt_others oth)^")"
         | Value t => (fmt_tmark t)^"'("^(fmt_others oth)^")"
    )
and €fmt_agg_named› ({tmark=tm,named_assocs=n} : (AGG_CHOICE, EXP) AGG_NAMED) =
    (case tm
        of Nil => "("^(fmt_named_assoc_list n)^")"
         | Value t => (fmt_tmark t)^"'("^(fmt_named_assoc_list n)^")"
    )
and €fmt_agg_named_others› ({agg_named=a as{tmark=tm, named_assocs=n},
					others=oth} :
    (AGG_CHOICE, EXP) AGG_NAMED_OTHERS) =
    (case tm
        of Nil => "("^(fmt_agg_named a)^", "^(fmt_others oth)^")"
         | Value t => (fmt_tmark t)^"'(" ^
		(fmt_agg_named {tmark=Nil, named_assocs=n}) ^ ", " ^
		(fmt_others oth)^")"
    )
and €fmt_unary_exp› ({uop=u, right=r} : EXP UNARY_EXP) =
    (fmt_unary_op u)^(fmt_exp r)
and €fmt_bin_exp› ({bop=b, left=l, right=r} : EXP BIN_EXP) =
    (fmt_exp l)^(fmt_binary_op b)^(fmt_exp r)
and €fmt_attrib_desig› (ADAttrib x : ATTRIB_DESIG) = fmt_attrib x
  | fmt_attrib_desig (ADAttribArg (a,e) : ATTRIB_DESIG) =
    (fmt_attrib a)^"("^(fmt_exp e)^")"
and €fmt_attribute› ({prefix=p, attribute_desig=a} :
    (EXP, ATTRIB_DESIG) ATTRIBUTE) =
    (fmt_exp p)^"'"^(fmt_attrib_desig a)
and €fmt_indexed_comp› ({prefix=p, index=i} : EXP INDEXED_COMP) =
    (fmt_exp p)^ bracket (fmt_exp i)
and €fmt_selected_comp› ({prefix=p, selector=s} : EXP SELECTED_COMP) =
    (fmt_exp p)^"."^(fmt_id s)
and €fmt_qualified_expression› ({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) =
    (fmt_tmark t)^"'"^ bracket (fmt_exp e)
and €fmt_type_conversion› ({tmark=t, exp=e} : EXP QUALIFIED_EXPRESSION) =
    (fmt_tmark t)^ bracket (fmt_exp e)
and €fmt_exp› (EId x : EXP) = (fmt_id x)
  | fmt_exp (EInt x : EXP) = (fmt_int_lit x)
  | fmt_exp (EArrayAggPos x : EXP) = (fmt_agg_pos x)
  | fmt_exp (EArrayAggPosOthers x : EXP) = (fmt_agg_pos_others x)
  | fmt_exp (EArrayAggOthers x : EXP) = (fmt_agg_others x)
  | fmt_exp (EArrayAggNamed x : EXP) = (fmt_agg_named x)
  | fmt_exp (EArrayAggNamedOthers x : EXP) = (fmt_agg_named_others x)
  | fmt_exp (ERecAggPos x : EXP) = (fmt_agg_pos x)
  | fmt_exp (ERecAggNamed x : EXP) =
    "ERecAggnamed : this error shouldn't be raised"
  | fmt_exp (EUnaryExp x : EXP) = (fmt_unary_exp x)
  | fmt_exp (EBinExp x : EXP) = (fmt_bin_exp x)
  | fmt_exp (EMemRange x : EXP) =
    "EMemRange : this error shouldn't be raised"
  | fmt_exp (EAttribute x : EXP) = (fmt_attribute x)
  | fmt_exp (EIndexedComp x : EXP) = (fmt_indexed_comp x)
  | fmt_exp (ESelectedComp x : EXP) = (fmt_selected_comp x)
  | fmt_exp (EFunCall x : EXP) = 
    "EFunCall : this error shouldn't be raised"
  | fmt_exp (EAuxiliaryExp x : EXP) = "˚"^(fmt_z_tm x)^"˝"
  | fmt_exp (EQualifiedExp x : EXP) = (fmt_qualified_expression x)
  | fmt_exp (ETypeConversion x : EXP) = (fmt_type_conversion x)
  | fmt_exp (EBracketed e : EXP) = ("("^(fmt_exp e)^")")
  | fmt_exp (EStringLiteral s : EXP) = "\""^s^"\""
  | fmt_exp (ECharacterLiteral c : EXP) = "'"^c^"'"
and €fmt_exp_list› ([] : EXP list) = ""
  | fmt_exp_list ([x] : EXP list) = (fmt_exp x)
  | fmt_exp_list (x::xs : EXP list) = (fmt_exp x)^", "^(fmt_exp_list xs);
fun €fmt_static_exp› (x : STATIC_EXP) = (fmt_exp x);
fun €fmt_static_rangelohi› ({lo=l, hi=h} : STATIC_EXP RANGELOHI) =
    (fmt_static_exp l)^".."^(fmt_static_exp h);
fun €fmt_static_range› (RRange x : EXP RANGE) = fmt_static_rangelohi x
  | fmt_static_range (RRangeAttr x : EXP RANGE) = fmt_static_exp x;
fun €fmt_cond› (c : COND) = (fmt_exp c);
fun €fmt_actuals› (APositional x : (AGG_CHOICE, EXP) ACTUALS) = 
    (case x
        of [] => ""
         | z => " ("^(fmt_exp_list x)^")"
    )
  | fmt_actuals (ANamed x : (AGG_CHOICE, EXP) ACTUALS) =
    (case x
        of [] => ""
         | z => " ("^(fmt_named_assoc_list x)^")"
    );

=TEX

\subsection{Statements}

A few auxiliary functions before we do statements.

=SML

fun €fmt_spec› ({w=w, w0=w0, pre=pre, post=post} : SPEC) : string =
    "Ñ "^(fmt_id_list w)^" ["^(fmt_z_tm pre)^", "^
                (fmt_z_tm post)^"] ";

fun €fmt_proc_call› ({name=n, actuals=e} : (AGG_CHOICE, EXP) PROC_CALL)
				: string =
    (fmt_id n)^(fmt_actuals e);

fun €fmt_pragma› (FmtInfo : PP_FMT_INFO)
		({id, args} : (AGG_CHOICE, EXP) PRAGMA) : (PP_FMT_INFO * string) list = (
	let	fun fmt_arg (Nil, e) =
			fmt_exp e
		|   fmt_arg (Value ac, e) =
			fmt_agg_choice ac ^ " => " ^ fmt_exp e;
	in	[(FmtInfo,
		 "PRAGMA " ^ id ^ "(" ^ format_list fmt_arg args ", " ^ ");")]
	end
);

fun €fmt_annotation› (FmtInfo : PP_FMT_INFO) (anns: ANNOTATION)
	: (PP_FMT_INFO * string) list = (
	map (fn ann => (FmtInfo, ann)) anns
);

fun €fmt_replaced_by_arbitrary_ada› (FmtInfo : PP_FMT_INFO)
	({label, replacement} : REPLACED_BY_ARBITRARY_ADA )
	: (PP_FMT_INFO * string) list = (
    [(FmtInfo, (fmt_label label)^" !È" ^ replacement)]
);
=TEX
=SML
fun €fmt_expansion› (FmtInfo : PP_FMT_INFO) (label : LABEL) :
        (PP_FMT_INFO * string) list OPT = (
let    val f = case (#fmtfn FmtInfo) of
            Value f =>    f
            | Nil =>    fn _ => Nil;
in

    case f label of
    Value repl => Value (
        case repl of
            ReplaceComp {comp, ...} =>       
			fmt_kslot_compilation_unit_list FmtInfo comp
        |    ReplacePPart {private, ...} =>
			fmt_declaration_list FmtInfo private
        |    ReplaceVPart {visible, ...} =>
			fmt_declaration_list FmtInfo visible
        |    ReplaceDecl {decls, ...} =>
			fmt_declaration_list FmtInfo decls
        |    RefineStat {statement, ...}    =>
			fmt_statement FmtInfo statement
        |    ReplaceStat {statement, ...}    =>
			fmt_statement FmtInfo statement
        |    ReplaceArbitrary {replacement, ...}    =>
			[({tabs=0,line_length=10000,fmtfn=Nil}, replacement)]
        |    UnReplaced (RSCompilation, s) =>
                [(FmtInfo, "-- k-slot " ^ label)]
        |    UnReplaced (RSSpecStatement, s) =>
                [(FmtInfo, "NULL; -- " ^ label)]
        |    UnReplaced (RSStatement, s) =>
                [(FmtInfo, "NULL; -- " ^ label)]
        |    UnReplaced (RSDeclaration, s) =>
                [(FmtInfo, "-- k-slot " ^ label)]
        |    UnReplaced (RSPrivatePart, s) =>
                [(FmtInfo, "-- k-slot " ^ label)]
        |    UnReplaced (RSVisiblePart, s) =>
                [(FmtInfo, "-- k-slot " ^ label)]
        )
    |    Nil =>    Nil
end)

and €fmt_spec_no_ivars› FmtInfo (s as
		{spec, label} : SPEC_NO_IVARS) =
    case fmt_expansion FmtInfo label of
    Value expansion =>    expansion
    |Nil =>        [(FmtInfo, fmt_spec spec^"    "^(fmt_label label))]

=TEX

Statements.

=SML
and €fmt_assign› (FmtInfo : PP_FMT_INFO) ({name=n, e=e} : ASSIGN) =
    [(FmtInfo, (fmt_exp n)^" := "^(fmt_exp e)^";")]

and €fmt_exit_when› (FmtInfo : PP_FMT_INFO) ({g=g} : EXIT_WHEN) =
    [(FmtInfo, "EXIT WHEN "^(fmt_cond g)^";")]
and €fmt_return› (FmtInfo : PP_FMT_INFO) ({e=e} : RETURN) =
    [(FmtInfo, "RETURN "^(fmt_exp e)^";")]
and €fmt_proc_call_no_ivars› (FmtInfo : PP_FMT_INFO)
        (x : (AGG_CHOICE, EXP) PROC_CALL_NO_IVARS) =
    [(FmtInfo, (fmt_proc_call x)^";")]



and €fmt_k_slot› (FmtInfo : PP_FMT_INFO) ({content, label} : K_SLOT) = (
    case fmt_expansion FmtInfo label of
    Value expansion =>    expansion
    |Nil =>        [(FmtInfo, "ß " ^ content^" ¢    "^(fmt_label label))]
)

and €fmt_elsif› (FmtInfo : PP_FMT_INFO)
        (stmt as (STIfThenElse {g=g, p=p, q=q, elsif=true}) : STMT) =
    [(FmtInfo, "ELSIF "^(fmt_cond g))]@
    [(FmtInfo, "THEN")]@
    (fmt_stmt (inc_tabs FmtInfo) p)@
    (fmt_elsif FmtInfo q)
  | fmt_elsif (FmtInfo : PP_FMT_INFO)
        (stmt as (STIfThenElse {g=g, p=p, q=q, elsif=false}) : STMT) =
    [(FmtInfo, "ELSIF "^(fmt_cond g))]@
    [(FmtInfo, "THEN")]@
    (fmt_stmt (inc_tabs FmtInfo) p)@
    (case q
        of STImplicitNull => []
         | z => [(FmtInfo, "ELSE")]@(fmt_stmt (inc_tabs FmtInfo) q)
    )
  | fmt_elsif (FmtInfo : PP_FMT_INFO) (stmt : STMT) =
    (fmt_stmt (inc_tabs FmtInfo) stmt)
and €fmt_if_then_else› (FmtInfo : PP_FMT_INFO)
        ({g=g, p=p, q=q, elsif=false} : STMT IF_THEN_ELSE) =
    [(FmtInfo, "IF "^(fmt_cond g))]@
    [(FmtInfo, "THEN")]@
    (fmt_stmt (inc_tabs FmtInfo) p)@
    (case q
        of STImplicitNull => []
         | z => [(FmtInfo, "ELSE")]@(fmt_stmt (inc_tabs FmtInfo) q)
    )@
    [(FmtInfo, "END IF;")]
  | fmt_if_then_else (FmtInfo : PP_FMT_INFO)
        ({g=g, p=p, q=q, elsif=true} : STMT IF_THEN_ELSE) =
    [(FmtInfo, "IF "^(fmt_cond g))]@
    [(FmtInfo, "THEN")]@
    (fmt_stmt (inc_tabs FmtInfo) p)@
    (fmt_elsif FmtInfo q)@
    [(FmtInfo, "END IF;")]
and €fmt_case_choice› (CCCaseExp x : CASE_CHOICE) = (fmt_exp x)
  | fmt_case_choice (CCCaseRange x : CASE_CHOICE) = (fmt_discrete_range x)
and €fmt_case_choice_list› ([] : CASE_CHOICE list) = ""
  | fmt_case_choice_list ([x] : CASE_CHOICE list) = (fmt_case_choice x)
  | fmt_case_choice_list (x::xs : CASE_CHOICE list) =
    (fmt_case_choice x)^"|"^(fmt_case_choice_list xs)
and €fmt_case_alt› (FmtInfo : PP_FMT_INFO)
        ({choices=c, p=s} : STMT CASE_ALTERNATIVE) =
    [(FmtInfo, "WHEN "^(fmt_case_choice_list c)^" =>")]@
    (fmt_stmt (inc_tabs FmtInfo) s)
and €fmt_case_alt_list› (FmtInfo : PP_FMT_INFO)
        ([] : STMT CASE_ALTERNATIVE list) = []
  | fmt_case_alt_list (FmtInfo : PP_FMT_INFO)
        (x::xs : STMT CASE_ALTERNATIVE list) =
    (fmt_case_alt FmtInfo x)@(fmt_case_alt_list FmtInfo xs)
and €fmt_case› (FmtInfo : PP_FMT_INFO) ({e=e, s=s, others=oth} : STMT CASE) =
    [(FmtInfo, "CASE "^(fmt_exp e)^" IS")]@
    (fmt_case_alt_list (inc_tabs FmtInfo) s)@
    (
      case oth
      of STImplicitNull => []
       | _ => [(FmtInfo, "WHEN OTHERS =>")]@(fmt_stmt (inc_tabs FmtInfo) oth)
    )@
    [(FmtInfo, "END CASE;")]
and €fmt_unnamed_loop› (FmtInfo : PP_FMT_INFO) ({t=Value t, stmt=s} : STMT LOOP) =
    (if is_expansion_selected FmtInfo
    then    [(FmtInfo, "-- TILL ...")]
    else    [(FmtInfo, "TILL ˚"^(fmt_z_tm t)^"˝")]
    ) @
    [(FmtInfo, "LOOP")]@
    (fmt_stmt (inc_tabs FmtInfo) s)@
    [(FmtInfo, "END LOOP;")]
  | fmt_unnamed_loop (FmtInfo : PP_FMT_INFO) ({t=Nil, stmt=s} : STMT LOOP) =
    [(FmtInfo, "LOOP")]@
    (fmt_stmt (inc_tabs FmtInfo) s)@
    [(FmtInfo, "END LOOP;")]
and €fmt_named_loop› (FmtInfo : PP_FMT_INFO)
        ({name=n, t=Value t, stmt=s} : STMT NAMED_LOOP) =
    in_new_scope false n (fn () =>
	[(FmtInfo, (fmt_id n)^":")]@
   	 (    if is_expansion_selected FmtInfo
   	 then    [(FmtInfo, "-- TILL statement")]
   	 else    [(FmtInfo, "TILL ˚"^(fmt_z_tm t)^"˝")]
   	 ) @
   	 [(FmtInfo, "LOOP")]@
   	 (fmt_stmt (inc_tabs FmtInfo) s)@
   	 [(FmtInfo, "END LOOP "^(fmt_id n)^";")]
)  | fmt_named_loop (FmtInfo : PP_FMT_INFO)
        ({name=n, t=Nil, stmt=s} : STMT NAMED_LOOP) =
    in_new_scope false n (fn () =>
	[(FmtInfo, (fmt_id n)^":")]@
	[(FmtInfo, "LOOP")]@
	(fmt_stmt (inc_tabs FmtInfo) s)@
	[(FmtInfo, "END LOOP "^(fmt_id n)^";")]
) and €fmt_loop_body› (FmtInfo : PP_FMT_INFO) ({t=Value t, stmt=s} : STMT LOOP) =
    (    if is_expansion_selected FmtInfo
    then    [(FmtInfo, "-- TILL statement")]
    else    [(FmtInfo, "TILL ˚"^(fmt_z_tm t)^"˝")]
    ) @
    [(FmtInfo, "LOOP")]@
    (fmt_stmt (inc_tabs FmtInfo) s)
  | fmt_loop_body (FmtInfo : PP_FMT_INFO) ({t=Nil, stmt=s} : STMT LOOP) =
    [(FmtInfo, "LOOP")]@
    (fmt_stmt (inc_tabs FmtInfo) s)
and €fmt_while› (FmtInfo : PP_FMT_INFO)
        ({name=Value n, g=g, loop=l} : STMT WHILE) =
    [(FmtInfo, (fmt_id n)^":")]@
    [(FmtInfo, "WHILE "^(fmt_cond g))]@
    (fmt_loop_body FmtInfo l)@
    [(FmtInfo, "END LOOP "^(fmt_id n)^";")]
  | fmt_while (FmtInfo : PP_FMT_INFO)
        ({name=Nil, g=g, loop=l} : STMT WHILE) =
    [(FmtInfo, "WHILE "^(fmt_cond g))]@
    (fmt_loop_body FmtInfo l)@
    [(FmtInfo, "END LOOP;")]
and €fmt_for_static› (FmtInfo : PP_FMT_INFO)
        ({name=Value n, tmark=t, i=i, dir=d, range=r, loop=loop}:
    STMT FOR_STATIC) =
    in_new_scope false n (fn () => (
	check_decl i;
   	 [(FmtInfo, (fmt_id n)^":")]@
  	  [(FmtInfo, "FOR "^(fmt_id i)^" IN "^
  	      (fmt_loop_direction d)^(fmt_tmark t)^" RANGE "^(fmt_range r))]@
  	  (fmt_loop_body FmtInfo loop)@
  	  [(FmtInfo, "END LOOP "^(fmt_id n)^";")]
))  | fmt_for_static (FmtInfo : PP_FMT_INFO)
        ({name=Nil, tmark=t, i=i, dir=d, range=r, loop=loop} :
    STMT FOR_STATIC) =
    in_new_scope false "" (fn () => (
       check_decl i;
	[(FmtInfo, "FOR "^(fmt_id i)^" IN "^(fmt_loop_direction d)^
        	(fmt_tmark t)^" RANGE "^(fmt_range r))]@
	(fmt_loop_body FmtInfo loop)@
	[(FmtInfo, "END LOOP;")]
)) and €fmt_for_tmark› (FmtInfo : PP_FMT_INFO)
        ({name=Value n, i=i, tmark=t, dir=d, loop=loop} :
    STMT FOR_TMARK) =
    in_new_scope false n (fn () => (
	check_decl i;
    	[(FmtInfo, (fmt_id n)^":")]@
    	[(FmtInfo, "FOR "^(fmt_id i)^" IN "^
        	(fmt_loop_direction d)^(fmt_tmark t))]@
   	 (fmt_loop_body FmtInfo loop)@
   	[(FmtInfo, "END LOOP "^(fmt_id n)^";")]
)) | fmt_for_tmark (FmtInfo : PP_FMT_INFO)
        ({name=Nil, i=i, tmark=t, dir=d, loop=loop} :
    STMT FOR_TMARK) =
    in_new_scope false "" (fn () => (
       check_decl i;
       [(FmtInfo, "FOR "^(fmt_id i)^" IN "^
           (fmt_loop_direction d)^(fmt_tmark t))]@
       (fmt_loop_body FmtInfo loop)@
       [(FmtInfo, "END LOOP;")]
)) and €fmt_stmt› (FmtInfo : PP_FMT_INFO) (STNull : STMT) = [(FmtInfo, "NULL;")]
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STImplicitNull : STMT) = []
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STAssign x : STMT) =
        (fmt_assign FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STSpecNoIvars x : STMT) =
        (fmt_spec_no_ivars FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STSemicolon (a,b) : STMT) =
        (fmt_stmt FmtInfo a)@(fmt_stmt FmtInfo b)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STIfThenElse x : STMT) =
        (fmt_if_then_else FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STCase x : STMT) =
        (fmt_case FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STLoop x : STMT) =
        (fmt_unnamed_loop FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STNamedLoop x : STMT) =
        (fmt_named_loop FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STWhile x : STMT) =
        (fmt_while FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STForStatic x : STMT) =
        (fmt_for_static FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STForTmark x : STMT) =
        (fmt_for_tmark FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STExitWhen x : STMT) =
        (fmt_exit_when FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STExit : STMT) = [(FmtInfo, "EXIT;")]
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STRet x : STMT)  =
        (fmt_return FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STProcNoIvars x : STMT) =
        (fmt_proc_call_no_ivars FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STKSlot x : STMT) =
        (fmt_k_slot FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STPragma x : STMT) =
        (fmt_pragma FmtInfo x)
  | fmt_stmt (FmtInfo : PP_FMT_INFO) (STAnnotation x : STMT) =
        (fmt_annotation FmtInfo x)

=TEX

Logical constructs.

=SML

(* we don't print out pre1 since it doesn't come from the user *)
and €fmt_log_con› (FmtInfo : PP_FMT_INFO)
        ({x=x, t=t, spec=s, label, ...} : LOG_CON, stmt :STMT) =
    if is_expansion_selected FmtInfo
    then    (fmt_spec_no_ivars FmtInfo {spec=s, label=label})
			@ (fmt_stmt FmtInfo stmt)
    else    [(FmtInfo,
            "CON "^(fmt_z_id x)^" : "^(fmt_z_tm t)^" ∑ "^
            (fmt_spec s)^"    "^(fmt_label label))] @ (fmt_stmt FmtInfo stmt)

=TEX

Top level statements.

=SML

and €fmt_statement› (FmtInfo : PP_FMT_INFO) (SStmt x) = (fmt_stmt FmtInfo x)
  | fmt_statement (FmtInfo : PP_FMT_INFO) (SSpecIvars x) =
    [(FmtInfo, "SSpecIvars : this error shouldn't be raised")]
  | fmt_statement (FmtInfo : PP_FMT_INFO) (SForNonStatic x) = 
    [(FmtInfo, "SForNonStatic : this error shouldn't be raised")]
  | fmt_statement (FmtInfo : PP_FMT_INFO) (SLogCon x) = (fmt_log_con FmtInfo x)
  | fmt_statement (FmtInfo : PP_FMT_INFO) (SProcIvars x) =
    [(FmtInfo, "SProcIvars : this error shouldn't be raised")]

=TEX

\subsection{Declarations and Type Definitions}

Variable declarations.

=SML

and €fmt_var_decl› (FmtInfo : PP_FMT_INFO) ({vars=v, tmark=t} : VAR_DECL) = (
    map check_decl v;
    [(FmtInfo, (fmt_id_list v)^" : "^(fmt_tmark t)^";")]
) and fmt_var_decl_list (FmtInfo : PP_FMT_INFO) ([] : VAR_DECL list) = []
  | fmt_var_decl_list (FmtInfo : PP_FMT_INFO) (x::xs : VAR_DECL list) =
    (fmt_var_decl FmtInfo x)@(fmt_var_decl_list FmtInfo xs)

=TEX

Constant and deferred constant declarations.

=SML

and €fmt_const_decl› (FmtInfo : PP_FMT_INFO)
        ({consts=c, tm=t, expr=e} : EXP CONST_DECL) = (
    map check_decl c;
    [(FmtInfo, (fmt_id_list c)^" : CONSTANT "^
        (fmt_tmark t)^" := "^(fmt_exp e)^";")]
) and fmt_deferred_const_decl (FmtInfo : PP_FMT_INFO)
        ({consts=c, tmark=t} : DEFERRED_CONST_DECL) = (
    map check_decl c;
    [(FmtInfo, (fmt_id_list c)^" : CONSTANT "^(fmt_tmark t)^";")]
)
=TEX

Enumerated types.

=SML

and €fmt_enum_type_def› (FmtInfo : PP_FMT_INFO)
        (name, {vals=v} : ENUM_TYPE_DEF) = (
    check_decl name;
    [(FmtInfo, "TYPE "^(fmt_id name)^
        " IS ("^(fmt_id_list v)^");")]
)
=TEX

Integer types.

=SML

and €fmt_int_type_def› (FmtInfo : PP_FMT_INFO) (name, r : EXP RANGE) = (
    check_decl name;
    [(FmtInfo, "TYPE "^(fmt_id name)^
        " IS RANGE "^(fmt_range r)^";")]
)
=TEX

Floating point types.

=SML

and €fmt_floating_point_constraint› ({exp=e, range=Value r} :
        EXP FLOATING_POINT_CONSTRAINT) =
    " DIGITS "^(fmt_exp e)^" RANGE "^(fmt_range r)
  | fmt_floating_point_constraint ({exp=e, range=Nil} :
        EXP FLOATING_POINT_CONSTRAINT) =
    " DIGITS "^(fmt_exp e)
and €fmt_floating_type_def› (FmtInfo : PP_FMT_INFO)
        (name, x : EXP FLOATING_TYPE_DEF) = (
    check_decl name;
    [(FmtInfo, "TYPE "^(fmt_id name)^
        " IS"^(fmt_floating_point_constraint x)^";")]
)
=TEX

Fixed point types.

=SML

and €fmt_fixed_point_constraint› ({exp=e, range=Value r} :
        EXP FIXED_POINT_CONSTRAINT) =
    " DELTA "^(fmt_exp e)^" RANGE "^(fmt_range r)
  | fmt_fixed_point_constraint ({exp=e, range=Nil} :
        EXP FIXED_POINT_CONSTRAINT) =
    " DELTA "^(fmt_exp e)
and €fmt_fixed_type_def› (FmtInfo : PP_FMT_INFO)
        (name, x : EXP FIXED_TYPE_DEF) = (
    check_decl name;
    [(FmtInfo, "TYPE "^(fmt_id name)^
        " IS"^(fmt_fixed_point_constraint x)^";")]
)
=TEX

Array types.

=SML

and €fmt_array_def› (FmtInfo : PP_FMT_INFO)
        (name, {index=i, comp=c} : ARRAY_DEF) = (
    check_decl name;
    [(FmtInfo, "TYPE "^(fmt_id name)^
        " IS ARRAY ("^(fmt_tmark_list i)^") OF "^(fmt_tmark c)^";")]
) and €fmt_uncon_tmark_list› ([] : TMARK list) = ""
  | fmt_uncon_tmark_list ([x] : TMARK list) = (fmt_tmark x)^" RANGE <>"
  | fmt_uncon_tmark_list (x::xs : TMARK list) =
    (fmt_uncon_tmark_list [x])^", "^(fmt_uncon_tmark_list xs)
and €fmt_uncon_array_def› (FmtInfo : PP_FMT_INFO)
        (name, {index=i, comp=c} : ARRAY_DEF) = (
    check_decl name;
    [(FmtInfo, "TYPE "^(fmt_id name)^
        " IS ARRAY ("^(fmt_uncon_tmark_list i)^") OF "^(fmt_tmark c)^";")]
)
=TEX

Record types.

Note that the variable name clash rules do not apply here.
=SML

and €fmt_record_type_def› (FmtInfo : PP_FMT_INFO)
        (name, {decl=d} : RECORD_TYPE_DEF) = (
    	check_decl name;
   	let 	val old_st = !stack;
		val res = (stack := [];
   		 	[(FmtInfo, "TYPE "^(fmt_id name)^" IS")]@
   		 	[(FmtInfo, "RECORD")]@
   		 	(fmt_var_decl_list (inc_tabs FmtInfo) d)@
    			[(FmtInfo, "END RECORD;")]);
	in	stack := old_st;
		res
	end
)
=TEX

Type declarations.

=SML

and €fmt_type_def› (FmtInfo : PP_FMT_INFO)
        (name, (TDEnumTypeDef x) : TYPE_DEF) =
    (fmt_enum_type_def FmtInfo (name, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO)
        (name, (TDIntTypeDef x) : TYPE_DEF) =
    (fmt_int_type_def FmtInfo (name, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO)
        (name, (TDFloatingTypeDef x) : TYPE_DEF) =
    (fmt_floating_type_def FmtInfo (name, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO)
        (name, (TDFixedTypeDef x) : TYPE_DEF) =
    (fmt_fixed_type_def FmtInfo (name, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO)
        (name, (TDUnconArrayDef x) : TYPE_DEF) =
    (fmt_uncon_array_def FmtInfo (name, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO)
        (name, (TDConArrayDef x) : TYPE_DEF) =
    (fmt_array_def FmtInfo (name, x))
  | fmt_type_def (FmtInfo : PP_FMT_INFO) 
        (name, (TDRecordTypeDef x) : TYPE_DEF) =
    (fmt_record_type_def FmtInfo (name, x))
and €fmt_type_decl› (FmtInfo : PP_FMT_INFO)
        ({name=n, type_def=t} : TYPE_DEF TYPE_DECL) =
    (fmt_type_def FmtInfo (n, t))

=TEX

Subtype declarations.

=SML

and €fmt_constraint› (CRange x : CONSTRAINT) = "RANGE "^fmt_range x
  | fmt_constraint (CIndex x : CONSTRAINT) = "(" ^ fmt_exp_list x ^ ")"
  | fmt_constraint (CFloating x : CONSTRAINT) =
    (fmt_floating_point_constraint x)
  | fmt_constraint (CFixed x : CONSTRAINT) =
    (fmt_fixed_point_constraint x)
and €fmt_sub_ind› ({tmark=t, con=c} : CONSTRAINT SUB_IND) =
    (fmt_tmark t)^" "^(fmt_constraint c)
and €fmt_subtype_decl› (FmtInfo : PP_FMT_INFO)
        (d as {name=n, sub_ind=s} : CONSTRAINT SUBTYPE_DECL) = (
    check_decl n;
    [(FmtInfo, "SUBTYPE "^(fmt_id n)^" IS "^(fmt_sub_ind s)^";")]
)
=TEX

Private type declarations.

=SML

and €fmt_private_type_decl› (FmtInfo : PP_FMT_INFO)
        ({id=i, limited=l} : PRIVATE_TYPE_DECL) = (
    check_decl i;
    [(FmtInfo, "TYPE "^(fmt_id i)^" IS"^
        (if l=true then " LIMITED" else "")^" PRIVATE;")]
)
=TEX

Basic declarations.

=SML

and €fmt_basic_decl› (FmtInfo : PP_FMT_INFO) (BDConstDecl x : BASIC_DECL) =
    (fmt_const_decl FmtInfo x)
  | fmt_basic_decl (FmtInfo : PP_FMT_INFO)
        (BDDeferredConstDecl x : BASIC_DECL) =
    (fmt_deferred_const_decl FmtInfo x)
  | fmt_basic_decl (FmtInfo : PP_FMT_INFO) (BDTypeDecl x : BASIC_DECL) =
    (fmt_type_decl FmtInfo x)
  | fmt_basic_decl (FmtInfo : PP_FMT_INFO) (BDVarDecl x : BASIC_DECL) =
    (fmt_var_decl FmtInfo x)
  | fmt_basic_decl (FmtInfo : PP_FMT_INFO) (BDSubtypeDecl x : BASIC_DECL) =
    (fmt_subtype_decl FmtInfo x)
  | fmt_basic_decl (FmtInfo : PP_FMT_INFO) (BDPrivateTypeDecl x : BASIC_DECL ) =
    (fmt_private_type_decl FmtInfo x)
  | fmt_basic_decl (FmtInfo : PP_FMT_INFO) (BDPragma x : BASIC_DECL ) =
    (fmt_pragma FmtInfo x)
  | fmt_basic_decl (FmtInfo : PP_FMT_INFO) (BDAnnotation x : BASIC_DECL ) =
    (fmt_annotation FmtInfo x)
and €fmt_basic_decl_list› (FmtInfo : PP_FMT_INFO) ([] : BASIC_DECL list) = []
  | fmt_basic_decl_list (FmtInfo : PP_FMT_INFO) (x::xs : BASIC_DECL list) =
    (fmt_basic_decl FmtInfo x)@(fmt_basic_decl_list FmtInfo xs)

=TEX

\subsection{Procedure and Function specifications}

Procedure and Function parameter specifications.

=SML

and €fmt_parameter_specification› ({idlist=i, mode=m, name=n} :
        PARAMETER_SPECIFICATION) = (
   map  check_decl i;
    (fmt_id_list i)^" :"^(fmt_mode m)^(fmt_tmark n)
) and €fmt_parameter_specification_list1› ([] : PARAMETER_SPECIFICATION list) = ""
  | fmt_parameter_specification_list1 ([x] : PARAMETER_SPECIFICATION list) =
    (fmt_parameter_specification x)
  | fmt_parameter_specification_list1 (x::xs : PARAMETER_SPECIFICATION list) =
    (fmt_parameter_specification x)^"; "^(fmt_parameter_specification_list1 xs)
and €fmt_parameter_specification_list› ([] : PARAMETER_SPECIFICATION list) = ""
  | fmt_parameter_specification_list (xs : PARAMETER_SPECIFICATION list) =
    " ("^(fmt_parameter_specification_list1 xs)^")"

=TEX

Procedure and Function specifications.

Note these do a $push\_scope$ which someone on the calling chain will need to pop.
This is needed because the name of the procedure or function is visible at this level and needs to be on the stack when a subprogram body is processed.
=SML

and €fmt_procedure_specification› (FmtInfo : PP_FMT_INFO)
        ({name=n, formal_part=f, spec=Value s, annotation=ann} 
		 : PROCEDURE_SPECIFICATION) = (
    push_scope n;
    (if is_expansion_selected FmtInfo
    then
        [(FmtInfo, "PROCEDURE "^
            (fmt_id n)^(fmt_parameter_specification_list f))]@
            [((inc_tabs FmtInfo), "-- Spec ...")]
    else
        [(FmtInfo, "PROCEDURE "^
            (fmt_id n)^(fmt_parameter_specification_list f))]@
            [((inc_tabs FmtInfo), (fmt_spec s))]) @
    fmt_annotation FmtInfo ann
)  | fmt_procedure_specification (FmtInfo : PP_FMT_INFO)
        ({name=n, formal_part=f, spec=Nil, annotation=ann}
		: PROCEDURE_SPECIFICATION) = (
    push_scope n;
    [(FmtInfo, "PROCEDURE "^(fmt_id n)^(fmt_parameter_specification_list f))] @
    fmt_annotation FmtInfo ann
) and €fmt_function_specification› (FmtInfo : PP_FMT_INFO)
        ({designator=d, return=r, formal_part=f, spec=Value s, annotation=ann}
			: FUNCTION_SPECIFICATION) = (
    push_scope d;
    (if is_expansion_selected FmtInfo
    then
        [(FmtInfo, "FUNCTION "^(fmt_id d)^
            (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark r))]@
            [((inc_tabs FmtInfo), "-- Spec ...")]
    else
        [(FmtInfo, "FUNCTION "^(fmt_id d)^
            (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark r))]@
            [((inc_tabs FmtInfo), (fmt_spec s))]) @
    fmt_annotation FmtInfo ann
)  | €fmt_function_specification› (FmtInfo : PP_FMT_INFO)
        ({designator=d, return=r, formal_part=f, spec=Nil, annotation=ann}
		: FUNCTION_SPECIFICATION) = (
    push_scope d;
    [(FmtInfo, "FUNCTION "^(fmt_id d)^
        (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark r))] @
    fmt_annotation FmtInfo ann
)
=TEX

Subprograms.

Callers of this must pop the scope pushed by the support functions.
=SML

and €fmt_subprogram_specification› (FmtInfo : PP_FMT_INFO)
        (SSProcedure x : SUBPROGRAM_SPECIFICATION) =
    (fmt_procedure_specification FmtInfo x)
  | €fmt_subprogram_specification› (FmtInfo : PP_FMT_INFO)
        (SSFunction x : SUBPROGRAM_SPECIFICATION) =
    (fmt_function_specification FmtInfo x)

=TEX

Renaming declarations.

=SML

and €fmt_function_renaming› (FmtInfo : PP_FMT_INFO)
        ({opsym1=o1, formal_part=f, tmark=t, name=n, opsym2=o2} :
        FUNCTION_RENAMING) =
	in_new_scope false o1 (fn () =>
    [(FmtInfo, "FUNCTION \""^(fmt_operator_symbol o1)^"\""^
        (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark t)^
        " RENAMES "^(fmt_id n)^".\""^(fmt_operator_symbol o2)^"\";")]
) and €fmt_subprogram_renaming› (FmtInfo : PP_FMT_INFO)
        ({subprogram_specification=s, name1=n1, name2=n2} :
        SUBPROGRAM_RENAMING) =
	let	val res =
   		 (fmt_subprogram_specification FmtInfo s)@
   		 [((inc_tabs FmtInfo), " RENAMES "
			^(fmt_id n1)^"."^(fmt_id n2)^";")];
	in	pop_scope(); res
	end
and €fmt_renaming_declaration› (FmtInfo : PP_FMT_INFO)
        (RDFunction x : RENAMING_DECLARATION) =
    (fmt_function_renaming FmtInfo x)
  | fmt_renaming_declaration (FmtInfo : PP_FMT_INFO)
        (RDSubprogram x : RENAMING_DECLARATION) =
    (fmt_subprogram_renaming FmtInfo x)

=TEX

Representation clauses.

=SML

and €fmt_component_clause› (FmtInfo : PP_FMT_INFO)
        ({name=n, exp=e, range=r} : COMPONENT_CLAUSE) =
    [(FmtInfo, (fmt_id n)^" AT "^(fmt_exp e)^" RANGE "^(fmt_range r)^";")]
and €fmt_component_clause_list› (FmtInfo : PP_FMT_INFO)
        ([] : COMPONENT_CLAUSE list) = []
  | fmt_component_clause_list (FmtInfo : PP_FMT_INFO)
        (x::xs : COMPONENT_CLAUSE list) =
    (fmt_component_clause FmtInfo x)@(fmt_component_clause_list FmtInfo xs)
and €fmt_length_clause› (FmtInfo : PP_FMT_INFO)
        ({attribute=a, exp=e} : LENGTH_CLAUSE) =
    [(FmtInfo, "FOR "^(fmt_exp a)^" USE "^(fmt_exp e)^";")]
and €fmt_enumeration_representation_clause› (FmtInfo : PP_FMT_INFO)
       ({name=n, exp=e} : ENUMERATION_REPRESENTATION_CLAUSE) =
    [(FmtInfo, "FOR "^(fmt_id n)^" USE "^(fmt_exp e)^";")]
and €fmt_record_representation_clause› (FmtInfo : PP_FMT_INFO)
        ({name=n, alignment_opt=Value a,  component_pack=c} :
        RECORD_REPRESENTATION_CLAUSE) =
    [(FmtInfo, "FOR "^(fmt_id n)^" USE")]@
    [((inc_tabs FmtInfo), "RECORD AT MOD "^(fmt_exp a)^";")]@
    (fmt_component_clause_list (inc_tabs FmtInfo) c)@
    [((inc_tabs FmtInfo), "END RECORD;")]
  | fmt_record_representation_clause (FmtInfo : PP_FMT_INFO)
        ({name=n, alignment_opt=Nil, component_pack=c} :
        RECORD_REPRESENTATION_CLAUSE) =
    [(FmtInfo, "FOR "^(fmt_id n)^" USE")]@
    [((inc_tabs FmtInfo), "RECORD")]@
    (fmt_component_clause_list (inc_tabs FmtInfo) c)@
    [((inc_tabs FmtInfo), "END RECORD;")]
and €fmt_address_clause› (FmtInfo : PP_FMT_INFO)
        ({name=n, exp=e} : ADDRESS_CLAUSE) =
    [(FmtInfo, "FOR "^(fmt_id n)^" USE AT "^(fmt_exp e)^";")]
and €fmt_representation_clause› (FmtInfo : PP_FMT_INFO)
        (RCLength x : REPRESENTATION_CLAUSE) =
    (fmt_length_clause FmtInfo x)
  | fmt_representation_clause (FmtInfo : PP_FMT_INFO)
        (RCEnumeration x : REPRESENTATION_CLAUSE) =
    (fmt_enumeration_representation_clause FmtInfo x)
  | fmt_representation_clause (FmtInfo : PP_FMT_INFO)
        (RCRecord x : REPRESENTATION_CLAUSE) =
    (fmt_record_representation_clause FmtInfo x)
  | fmt_representation_clause (FmtInfo : PP_FMT_INFO)
        (RCAddress x : REPRESENTATION_CLAUSE) =
    (fmt_address_clause FmtInfo x)

=TEX

Declarations, these are defined simultaneously since they can be recursive.

=SML
and €fmt_procedure_declaration› (FmtInfo : PP_FMT_INFO)
        ({name=n, formal_part=f, spec=Value s, annotation=ann}
		: PROCEDURE_DECLARATION) =
    in_new_scope true n (fn () =>
    (if is_expansion_selected FmtInfo
    then
        [(FmtInfo, "PROCEDURE "^
            (fmt_id n)^(fmt_parameter_specification_list f)^";")]@
            [((inc_tabs FmtInfo), "-- Spec ...")]
    else
        [(FmtInfo, "PROCEDURE "^
            (fmt_id n)^(fmt_parameter_specification_list f))]@
            [((inc_tabs FmtInfo), (fmt_spec s)^";")]) @
    fmt_annotation FmtInfo ann
)  | fmt_procedure_declaration (FmtInfo : PP_FMT_INFO)
        ({name=n, formal_part=f, spec=Nil, annotation=ann}
		: PROCEDURE_DECLARATION) =
    in_new_scope true n (fn () =>
    [(FmtInfo, "PROCEDURE "^(fmt_id n)
			^(fmt_parameter_specification_list f)^";")] @
    fmt_annotation FmtInfo ann
)
and €fmt_function_declaration› (FmtInfo : PP_FMT_INFO)
        ({designator=d, return=r, formal_part=f, spec=Value s, annotation=ann}
		: FUNCTION_DECLARATION) =
    in_new_scope true d (fn () =>
    (if is_expansion_selected FmtInfo
    then
        [(FmtInfo, "FUNCTION "^(fmt_id d)^
            (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark r)^";")]@
            [((inc_tabs FmtInfo), "-- Spec ...")]
    else
        [(FmtInfo, "FUNCTION "^(fmt_id d)^
            (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark r))]@
            [((inc_tabs FmtInfo), (fmt_spec s)^";")]) @
    fmt_annotation FmtInfo ann
)  | fmt_function_declaration  (FmtInfo : PP_FMT_INFO)
        ({designator=d, return=r, formal_part=f, spec=Nil,annotation=ann} :
        FUNCTION_DECLARATION) =
    in_new_scope true d (fn () =>
    [(FmtInfo, "FUNCTION "^(fmt_id d)^
        (fmt_parameter_specification_list f)^" RETURN "^(fmt_tmark r)^";")] @
    fmt_annotation FmtInfo ann
)
and €fmt_procedure_stub› (FmtInfo : PP_FMT_INFO)
	(x as {spec, name, formal_part, ...} : PROCEDURE_DECLARATION) =
    in_new_scope true name (fn () =>
    case spec of
       Nil =>
    [(FmtInfo, "PROCEDURE "^(fmt_id name)^
        (fmt_parameter_specification_list formal_part)^" IS SEPARATE;")]
    | Value s =>
         if is_expansion_selected FmtInfo
	  then
    [(FmtInfo, "PROCEDURE "^(fmt_id name)^
        (fmt_parameter_specification_list formal_part))]@
    [(FmtInfo, "-- Spec ...")]@
    [(FmtInfo, "IS SEPARATE;")]
         else
    [(FmtInfo, "PROCEDURE "^(fmt_id name)^
        (fmt_parameter_specification_list formal_part))]@
    [(FmtInfo, fmt_spec s)]@
    [(FmtInfo, "IS SEPARATE;")]
)
and €fmt_function_stub› (FmtInfo : PP_FMT_INFO)
	(x as {spec, designator, formal_part, return, ...}
			: FUNCTION_DECLARATION) =
    in_new_scope true designator (fn () =>
    case spec of
       Nil =>
    [(FmtInfo, "FUNCTION "^(fmt_id designator)^
        (fmt_parameter_specification_list formal_part)^" RETURN "^
        (fmt_tmark return)^" IS SEPARATE;")]
    | Value s =>
         if is_expansion_selected FmtInfo
	  then
    [(FmtInfo, "FUNCTION "^(fmt_id designator)^
        (fmt_parameter_specification_list formal_part)^" RETURN "^
        (fmt_tmark return))]@
    [(FmtInfo, "-- Spec ...")]@
    [(FmtInfo, "IS SEPARATE;")]
         else
    [(FmtInfo, "FUNCTION "^(fmt_id designator)^
        (fmt_parameter_specification_list formal_part)^" RETURN "^
        (fmt_tmark return))]@
    [(FmtInfo, fmt_spec s)]@
    [(FmtInfo, "IS SEPARATE;")]
)
and €fmt_package_stub› (FmtInfo : PP_FMT_INFO) (n : ID) =
    [(FmtInfo, "PACKAGE BODY "^(fmt_id n)^" IS SEPARATE;")]
and €fmt_auxiliary› (FmtInfo : PP_FMT_INFO) (av : AUX_VAR) =
    (if is_expansion_selected FmtInfo
    then    [(FmtInfo, "-- AUXILIARY ... ;")]
    else    [(FmtInfo, "-- AUXILIARY "^(fmt_z_id (#aux av))^" ;")]
    )
and €fmt_using› (FmtInfo : PP_FMT_INFO) (u : USING_DEC) =
    (if is_expansion_selected FmtInfo
    then	[(FmtInfo, "-- USING ...")]@
		(fmt_basic_decl_list FmtInfo (#basic_decls u))@
		[(FmtInfo, "-- IMPLEMENT ... BY ... ;")]
    else	[(FmtInfo, "USING ")]@
		(fmt_basic_decl_list FmtInfo (#basic_decls u))@
		[(FmtInfo, "IMPLEMENT "^(fmt_z_tm (#aux u))^" BY "
		^(fmt_z_tm (#invariant u))^" ;")]
    )
and €fmt_package_declaration› (FmtInfo : PP_FMT_INFO)
        ({name=n, visible_decs=v, private_decs=p, annotation=ann} :
    DECLARATION PACKAGE_DECLARATION) =
    in_new_scope false n (fn () =>
  	  [(FmtInfo, "PACKAGE " ^ fmt_id n)] @
   	 fmt_annotation FmtInfo ann @
   	 [(FmtInfo, "IS")] @
   	 (fmt_declaration_list (inc_tabs FmtInfo) v)
   ) @
    (case p
        of [] => []
         | _ => [(FmtInfo, "PRIVATE")]@
                in_new_scope false n
		(fn () => fmt_declaration_list (inc_tabs FmtInfo) p)
    ) @
    [(FmtInfo, "END "^(fmt_id n)^";")]
and €fmt_declaration› (FmtInfo : PP_FMT_INFO)
        (DDeclarationKSlot (x, _) : DECLARATION) =
    (fmt_k_slot FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DRenamingDeclaration x : DECLARATION) =
    (fmt_renaming_declaration FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DBasicDecl x : DECLARATION) =
    (fmt_basic_decl FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DRepresentationClause x : DECLARATION) =
    (fmt_representation_clause FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DProperBody x : DECLARATION) =
    (fmt_proper_body FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DProcedureDeclaration x : DECLARATION) =
    (fmt_procedure_declaration FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DFunctionDeclaration x : DECLARATION) =
    (fmt_function_declaration FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DPackageDeclaration x : DECLARATION) =
    (fmt_package_declaration FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DProcedureStub x : DECLARATION) =
    (fmt_procedure_stub FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DFunctionStub x : DECLARATION) =
    (fmt_function_stub FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DPackageStub x : DECLARATION) =
    (fmt_package_stub FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DExternalProcedureStub x : DECLARATION) =
    (fmt_procedure_declaration FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DExternalFunctionStub x : DECLARATION) =
    (fmt_function_declaration FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DAuxiliary x : DECLARATION) =
    (fmt_auxiliary FmtInfo x)
  | fmt_declaration (FmtInfo : PP_FMT_INFO)
        (DUsing x : DECLARATION) =
    (fmt_using FmtInfo x)
=TEX
=SML
and €fmt_declaration_list› (FmtInfo : PP_FMT_INFO) ([] : DECLARATION list) = []
  | fmt_declaration_list (FmtInfo : PP_FMT_INFO) (x::xs : DECLARATION list) =
    (fmt_declaration FmtInfo x)@(fmt_declaration_list FmtInfo xs)
and €fmt_procedure_body› (FmtInfo : PP_FMT_INFO)
        ({procedure_spec=p, declarative_part=d, statement=s} :
         DECLARATION PROCEDURE_BODY) = (
    do_soundness_checks2 get_replacement false s;
   	let val res = (fmt_procedure_specification FmtInfo p)@
  			 [(FmtInfo, "IS")]@
   			(fmt_declaration_list (inc_tabs FmtInfo) d)@
   			[(FmtInfo, "BEGIN")]@
    			(fmt_statement (inc_tabs FmtInfo) s)@
    			[(FmtInfo, "END "^(fmt_id (#name p))^";")];
	in	pop_scope (); res
	end
)
and €fmt_function_body› (FmtInfo : PP_FMT_INFO)
        ({function_spec=f, declarative_part=d, statement=s} :
        DECLARATION FUNCTION_BODY) = (
    do_soundness_checks2 get_replacement true s;
   	let val res = (fmt_function_specification FmtInfo f)@
			[(FmtInfo, "IS")]@
			(fmt_declaration_list (inc_tabs FmtInfo) d)@
    			[(FmtInfo, "BEGIN")]@
    			(fmt_statement (inc_tabs FmtInfo) s)@
    			[(FmtInfo, "END "^(fmt_id (#designator f))^";")];
	in	pop_scope(); res
	end
)
and €fmt_package_body› (FmtInfo : PP_FMT_INFO)
        ({name=n, decls=d, statement=s, annotation=ann}
		: DECLARATION PACKAGE_BODY) = (
    in_new_scope false n (fn () => (
    do_soundness_checks2 get_replacement false s;
    [(FmtInfo, "PACKAGE BODY " ^ fmt_id n)] @
    fmt_annotation FmtInfo ann @
    [(FmtInfo, "IS")] @
    fmt_declaration_list (inc_tabs FmtInfo) d @
    (case s
      of SStmt STImplicitNull => []
      | _ => [(FmtInfo, "BEGIN")]@(fmt_statement (inc_tabs FmtInfo) s)
    ) @
    [(FmtInfo, "END "^(fmt_id n)^";")])
))
and €fmt_proper_body› (FmtInfo : PP_FMT_INFO) (PBProcedure x : PROPER_BODY) =
    (fmt_procedure_body FmtInfo x)
  | fmt_proper_body (FmtInfo : PP_FMT_INFO) (PBFunction x : PROPER_BODY) =
    (fmt_function_body FmtInfo x)
  | fmt_proper_body (FmtInfo : PP_FMT_INFO) (PBPackage x : PROPER_BODY) =
    (fmt_package_body FmtInfo x)

=TEX

Compilation subunits.

=SML

and €fmt_compilation_subunit› (FmtInfo : PP_FMT_INFO)
        ({name=n, proper_body=p} : COMP_SUBUNIT) =
    [(FmtInfo, "SEPARATE ("^(fmt_id n)^")")]@(fmt_proper_body (inc_tabs FmtInfo) p)

=TEX

Compilation units.

=SML

and €fmt_context_clause› (FmtInfo : PP_FMT_INFO) ([] : ID list) = []
  | fmt_context_clause (FmtInfo : PP_FMT_INFO) (x : ID list) =
    [(FmtInfo, "WITH "^(fmt_id_list x)^";")]
and €fmt_compilation_unit› (FmtInfo : PP_FMT_INFO)
        (CUPackageDeclaration x : COMPILATION_UNIT) =
    (fmt_package_declaration FmtInfo x)
  | fmt_compilation_unit (FmtInfo : PP_FMT_INFO)
        (CUProperBody x : COMPILATION_UNIT) =
    (fmt_proper_body FmtInfo x)
  | fmt_compilation_unit (FmtInfo : PP_FMT_INFO)
        (CUSubUnit x : COMPILATION_UNIT) =
    (fmt_compilation_subunit FmtInfo x)
and €fmt_context_compilation_unit› (FmtInfo : PP_FMT_INFO)
        ({context=i, comp_unit=c,pragmas=p,annotation=ann}
		: CONTEXT_COMPILATION_UNIT) =
    (fmt_context_clause FmtInfo i)@
    (flat (map (fmt_pragma FmtInfo) p))@
    (fmt_annotation FmtInfo ann)@
    (fmt_compilation_unit FmtInfo c) 
and €fmt_kslot_compilation_unit› (FmtInfo : PP_FMT_INFO)
        (KCUKSlot x : KSLOT_COMPILATION_UNIT) =
    (fmt_k_slot FmtInfo x)
  | fmt_kslot_compilation_unit (FmtInfo : PP_FMT_INFO)
        (KCUUnit x : KSLOT_COMPILATION_UNIT) =
    (fmt_context_compilation_unit FmtInfo x)
  | fmt_kslot_compilation_unit (FmtInfo : PP_FMT_INFO)
        (KCUPragma x : KSLOT_COMPILATION_UNIT) =
    (fmt_pragma FmtInfo x)
and €fmt_kslot_compilation_unit_list› (FmtInfo : PP_FMT_INFO)
    ([] : KSLOT_COMPILATION_UNIT list) = []
  | fmt_kslot_compilation_unit_list (FmtInfo : PP_FMT_INFO)
    (x::xs : KSLOT_COMPILATION_UNIT list) =
    (fmt_kslot_compilation_unit FmtInfo x)@
    [(FmtInfo, "")]@[(FmtInfo, "")]@
    (fmt_kslot_compilation_unit_list FmtInfo xs)

=TEX

=SML

and €fmt_replaced_by_comp› (FmtInfo : PP_FMT_INFO)
        ({label=l, comp=c} : REPLACED_BY_COMP) =
    [(FmtInfo, (fmt_label l)^" È ")]@
    (fmt_kslot_compilation_unit_list (inc_tabs FmtInfo) c)
and €fmt_replaced_by_private_part› (FmtInfo : PP_FMT_INFO)
        ({label=l, private=p} : REPLACED_BY_PRIVATE_PART) =
    [(FmtInfo, (fmt_label l)^" È ")]@(fmt_declaration_list (inc_tabs FmtInfo) p)
and €fmt_replaced_by_visible_part› (FmtInfo : PP_FMT_INFO)
        ({label=l, visible=v} : REPLACED_BY_VISIBLE_PART) =
    [(FmtInfo, (fmt_label l)^" È ")]@(fmt_declaration_list (inc_tabs FmtInfo) v)
and €fmt_replaced_by_decl› (FmtInfo : PP_FMT_INFO)
        ({label=l, decls=d} : REPLACED_BY_DECL) =
    [(FmtInfo, (fmt_label l)^" È ")]@(fmt_declaration_list (inc_tabs FmtInfo) d)
and €fmt_refined_by› (FmtInfo : PP_FMT_INFO)
        ({label=l, statement=s} : REFINED_BY) =
    [(FmtInfo, (fmt_label l)^" √ ")]@(fmt_statement (inc_tabs FmtInfo) s)
and €fmt_replaced_by› (FmtInfo : PP_FMT_INFO)
        ({label=l, statement=s} : REFINED_BY) =
    [(FmtInfo, (fmt_label l)^" È ")]@(fmt_statement (inc_tabs FmtInfo) s)

=TEX

Web Clauses.

=SML

and €fmt_web_clause› (FmtInfo : PP_FMT_INFO)
        (WCCompilation x : WEB_CLAUSE) =
    (fmt_kslot_compilation_unit_list FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCReplacedByCompilation x : WEB_CLAUSE) =
    (fmt_replaced_by_comp FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCReplacedByPrivatePart x : WEB_CLAUSE) =
    (fmt_replaced_by_private_part FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCReplacedByVisiblePart x : WEB_CLAUSE) =
    (fmt_replaced_by_visible_part FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCReplacedByDecl x : WEB_CLAUSE) =
    (fmt_replaced_by_decl FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCReplacedByArbitraryAda x : WEB_CLAUSE) =
    (fmt_replaced_by_arbitrary_ada FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCRefinedBy x : WEB_CLAUSE) =
    (fmt_refined_by FmtInfo x)
  | fmt_web_clause (FmtInfo : PP_FMT_INFO)
        (WCReplacedBy x : WEB_CLAUSE) =
    (fmt_replaced_by FmtInfo x);

=TEX

\section{PRINTING AND OUTPUTTING SPARK}
=SML

fun €format_web_clause› (FmtInfo : PP_FMT_INFO) (x : WEB_CLAUSE) : unit =
    diag_line (
        (fmt_info_string_list (fmt_web_clause FmtInfo x ))
);

val €print_web_clause› : WEB_CLAUSE -> unit = (
    format_web_clause
    {tabs=0,line_length=get_line_length(),fmtfn=Nil}
);

fun €print_spark_program› (() : unit) : unit = with_clash_checks (fn () =>
   (clash_checking := true;
    format_web_clause
    {    tabs = 0,
        line_length = get_line_length(),
        fmtfn = Value get_replacement
    }
    (WCCompilation (#spark_prog (get_z_generator_state()))))
    handle ex => (clash_checking := false; raise ex)
);

fun €output_spark_program› ({out_file : string}) = with_clash_checks (fn () =>
  let    val stream = open_out out_file;
    val FmtInfo = {    tabs = 0,
                line_length = get_line_length(),
                fmtfn = Value get_replacement    };
    val x = (WCCompilation (#spark_prog (get_z_generator_state())));
    val text = (fmt_info_string_list (fmt_web_clause FmtInfo x))
  in
    output (stream, translate_for_output text);
    close_out stream
  end
);

=TEX

\section{EPILOGUE}

=SML

end (* of structure CNSparkOutput *);

=TEX
\small
\twocolumn[\section{INDEX}]
\printindex
\end{document}
