=WARNING_EDIT_WITH_CARE spc501.src
=TEX


\documentclass{derarep5}
%\usepackage{cadiZ}

\usepackage{ProofPower}
\def\ZAxDesLabel{}
\def\ZGenericLabel{}
\def\ZOtherLabel{}
\def\ZSchemaLabel{}
\def\Hide#1{\relax}
\ftlmargin=4em
\tabstop=2em
%\ftlinepenalty=9999
\def\RCSVersion{$Revision: 1.15 $%
}

\makeindex

\setcounter{volcnt}{1}


\docno{DRA/CIS/CSE3/TR/94/27/4.0}
\title{Specification of the compliance notation for SPARK and Z}
\volume{1}{3}
\author{C M O'Halloran\\ C T Sennett\\ A Smith}
\Author{O'Halloran C M, Sennett C T, Smith A}
\keywords{Z, SPARK, Refinement, Literate Programming}
\date{February 28, 2002}
\issuedate{February 28, 2002}

%\protmark{}
%\descriptor{}
%\caveat{}
%\codeword{}

\location{Issued by System Assurance Group, KIS Division, \\
QinetiQ, St. Andrews Road, Malvern, Worcestershire, WR14 3PS. \\
Telephone 01684-894320.}
\contractno{CRP8/TG10}
\periodcovered{April 2000 - March 2001}
\customer{DDEC(ISTAR)ET}
\reportprotmark{Not protectively marked}
\reportcaveat{None}
\reportdescriptor{None}
\conference{None}
\titleclass{Not protectively marked}
\keywords{Z, SPARK, Refinement, Literate Programming}
\abstractclass{Not protectively marked}

\raggedbottom

\begin{document}

\maketitle

\begin{center}\fbox{\hspace{3mm}\parbox[t]{130mm}{
\hspc \textbf{Customer Information} \hspc\\[5mm]
\hspc\begin{tabular}{ll}
    Package Number:     & TG10 \\
    Package Title:      & Computing, Information and Signal Processing \\
    Package Customer:   & DDEC(ISTAR)ET \\
    Package Manager:    & Graham Dean \\
    Research Objective: & 5 \\
    Technical Area:     & 3 \\
    Assignment Number:  & 2
\end{tabular}\hspc
}}\vspace{25mm}

\fbox{\hspace{3mm}\parbox[t]{130mm}{\rule[-2mm]{0mm}{8mm}
  This document has been prepared for MoD and, unless indicated, may
  be used and circulated in accordance with the conditions of the Order
  under which it was supplied.\\
  \hspace*{5mm}\\
  It may not be used or copied for any non-Governmental or commercial
  purpose without the written agreement of QinetiQ.
\rule[-4mm]{0mm}{8mm}}\hspace{3mm}}\vspace{25mm}

\copyright Copyright QinetiQ 2002\\
QinetiQ UK \\
\vspace{5mm}
Approval for wider use or release must be sought from:\\
\vspace{5mm}
Intellectual Property Department\\
QinetiQ, Farnborough\\
Farnborough, Hampshire GU14 0LX
\end{center}

\startpre

\section*{Authorisation}

\begin{center}
  \begin{tabular}[t]{@{}p{40mm}p{90mm}@{}}
     Prepared by:       & A Smith \\
     Title:             & Senior Scientist \\
                        & \\
     Signature:         & \hrulefill \\
     Date:              & \hrulefill \\
     Location:          & L113, QinetiQ Malvern \\
                        & \\
     Authorised by:     & M Hill \\
     Title:             & Project Manager \\
                        & \\
     Signature:         & \hrulefill \\
     Date:              & \hrulefill \\
                        & \\
                        & \\
     Principal authors  & \\
                        & \\
     Name:              & A Smith \\
     Appointment:       & Senior Scientist \\
     Location:          & QinetiQ(Malvern) \\
                        & \\
     Name:              & C M O'Halloran \\
     Appointment:       & Lead Researcher \\
     Location:          & QinetiQ(Malvern) \\
                        & \\
     Name:              & C T Sennett \\
     Appointment:       & QinetiQ Fellow \\
     Location:          & QinetiQ(Malvern) \\    
  \end{tabular}

  \vspace{25mm}
  
  Issued by: System Assurance Group, KIS Division \\
  QinetiQ \\
  St. Andrews Road \\
  Malvern \\
  Worcestershire, WR14 3PS. \\
  Telephone 01684-894320
\end{center}

\section*{Record of changes}

This is a controlled document. \\
Additional copies should be obtained through the issuing authority. \\
In the extreme event of copying locally, each document shall be marked
`Uncontrolled Copy'. \\
Amendments shall be by whole document replacement. \\
Proposals for change to this document should be forwarded in writing to the issuing authority.\\
\\[15mm]
\begin{tabular}{|l|l|l|} \hline
    Version\hspace{1cm} & Date\hspace{2cm} & Comments\hspace{5cm} \\ \hline
  1.0  &  March 25, 1994     &  First Issue \\
  1.1  &  June 13, 1994      &  Data refinement added  \\
  1.2  &  December 22, 1994  &  Omissions found during implementation \\
       &                     &  of version 1.1 \\
  2.0  &  July 5, 1995       &  Various enhancements \\
  2.1  &  January 12, 1996   &  Omissions found during implementation \\
       &                     &  of version 2.0 \\
  3.0  &  September 26, 1997 &  Enhancements as recommended by independent \\
       &                     &  evaluation report \\
  3.1  &  August 4, 2000     &  Further enhancements \\
  4.0  &  February 28, 2002  &  \parbox[t]{7cm}{\raggedright
			     The specifications are now maintained on QinetiQ's behalf
			     by Lemma 1 Ltd. The formal Z material is now checked
			     and typeset using {\Product}. The specification changes
			     recorded in the documents HLD507\cite{LEMMA1/DAZ/HLD507}
			     and HLD508\cite{LEMMA1/DAZ/HLD508} have been actioned.

			    }\\
  4.1  &  May 17, 2002  &  \parbox[t]{7cm}{\raggedright
			     The specification has been enhanced to support extra Ada language
                                                    features as described in the interim version
                                                     of the document HLD509\cite{LEMMA1/DAZ/HLD509}.
			    }\\
  4.2  &  Febrary 6th, 2003  &  \parbox[t]{7cm}{\raggedright
			     The specification has been enhanced to support extra Ada language
                                                    features as described in the final version
                                                     of the document HLD509\cite{LEMMA1/DAZ/HLD509}.
			    }\\
                      &                   & \\
                        &                   & \\
                        &                   & \\
                        &                   & \\
                        &                   & \\
                        &                   & \\ \hline
\end{tabular}      

\vfill
{\tiny Lemma 1 RCS \RCSVersion}

\abstract{This volume formally specifies how to obtain the Z document from a 
literate script.  All three volumes are based on edition 3.2 of the SPARK 
manual (October 1996). All three 
volumes have been type-checked and typeset by {\ ProofPower}.}


\tableofcontents

%\ivolume{volume2.toc}
%\ivolume{volume3.toc}

\startmain

\section{Introduction}

\subsection{Overview}

\bpar{
This document specifies how to obtain a Z document, which contains for example the
verification conditions (VCs), from a literate script.
A minor part of the specification is given informally in section 17 and includes for example
the static checks that need to be carried out on a literate script.
}\epar

\bpar{
The specification is top down and is in three volumes.
This volume (volume 1) specifies at which points in the literate script Z is output to the Z document.
A refinement step for example gives rise to some VCs (expressed in Z) being output to the Z document.
The precise form of the VCs is specified in volume 2.
}\epar

\bpar{
Also a SPARK type declaration, for example, needs to be represented in the Z document.
Precisely what Z this should be is specified in volume 3 which specifies the translation of SPARK
basic declarations and expressions to Z.
}\epar

\bpar*{
We run the {\Product} commands to set up a theory to hold the specification.
The specification depends upon the material in volumes 2 and 3.
The material in volume 3 is inherited from volume 2.
}\epar*

=SML
open_theory "Volume_2";
new_theory"Volume_1";
=TEX

\subsection{The structure of the design specification}

\bpar{
The specification is written very much with an implementation in mind.
For this reason the formal specification appears as a set of compiling operations on the
concrete syntax of a literate script (appendix A).
These compiling operations produce Z instead of object code.
The concrete syntax has been written in the form required by SID [4].
SID allows the compiling operations to be embedded in the syntax.
SID will produce an analyser which syntax checks a literate script {\it and} calls each
compiling operation at the point stated in the syntax.
}\epar

\bpar{
As an example of the SID approach consider the following syntax for numerical expressions
which contains compiling operations to evaluate the resulting integer:
}\epar

\bpar*{
BASICS \\
\ \\
number    \# integers \# \\
orb       \# ( \# \\
crb       \# ) \# \\
plus      \# + \# \\
minus     \# - \# \\
multiply  \# * \# \\
}\epar*

\bpar*{
RULES \\
\ \\
expression = \\
expression addop term $<add\_subtract>$, \\
term; \\
\ \\
term = \\
term multop primary $<times>$, \\
primary; \\
\ \\
primary = \\
$<number>$ number, \\
addop primary $<monadic>$, \\
orb expression crb; \\
\ \\
addop = \\
$<op1>$ plus, \\
$<op2>$ minus; \\
\ \\
multop = $<op3>$ multiply;
}\epar*

\bpar*{
The text under the heading BASICS lists the identifiers to be used to stand for the terminal
symbols of the syntax. A comment starts and finishes with a \#. 
The text under RULES lists the syntax rules: an equals sign terminates
the name of the rule, a comma separates alternatives and a semicolon terminates the definition
of the rule. The compiling operations appear inside the angled brackets.
SID is able to transform the above syntax into a one-track form (no back-tracking required)
and outputs a program which will perform syntax analysis. Where compiling operations have been
included the analyser will call them at the appropriate place in the symbol stream: for example,
in the rule for {\it expression}, the operation $add\_subtract$ will be called to 
form each intermediate result in an expression like 5 + 4 + 3.
}\epar*

\bpar{
In this document the compiling operations are specified in Z.
The specification of a compiling operation appears as a Z schema with the same name (all lower case
names). Some of the compiling operations need to use global variables which hold certain
information. Global variables are specified by Z schemas with upper case names.
As an example of using Z schemas to specify compiling operations and global variables consider
again the example above. A global variable $STACK$ can be used to hold all the intermediate
results of evaluating a numerical expression:
}\epar

¹ÿ ÛSTACKÝ
	s : seq ú
ˆ

\bpar*{
The compiling operation $op1$ puts the number 1 on the stack to signify that the
syntax analyser has come across the symbol + (plus):
}\epar*

¹ÿ Ûop1Ý
Ü	„STACK
÷
Ü	s' = §1¢ ë s
ˆ


\bpar*{
Similarly $op2$ puts the number 2 on the stack to signify subtraction:
}\epar* 
  
¹ÿ Ûop2Ý
Ü	„STACK
÷
Ü	s' = §2¢ ë s
ˆ


\bpar*{
The compiling operation $add\_subtract$ evaluates {\it expression\ addop\ term}.
At the point $add\_subtract$ is called, {\it term} has been evaluated and is on top of the stack.
Below this on the stack is the number representing {\it addop} (1 or 2 as described above).
Below {\it addop} on the stack is the result of evaluating {\it expression}.
$add\_subtract$ therefore ``pops" the top three numbers off the stack, performs an addition
or subtraction, and puts the result on the stack:
}\epar*

¹ÿ Ûadd_subtractÝ
Ü	„STACK
Ü	s‰1 : seq ú
÷
Ü	s‰1 = tail(tail(tail s))
Ü		s 2 = 1 ± s' = §s 3 + s 1¢ ë s‰1
Ü	² 
Ü		s 2 = 2 ± s' = §s 3 - s 1¢ ë s‰1
ˆ


\bpar{
The SID functions (compiling operations) specified in this volume are at a certain level of abstraction.
An implementation of a tool to produce a Z document from a literate script will require
more SID functions than specified in this document.
However these extra SID functions are low level and would clutter the specification.
For example when a record type declaration is encountered a SID function is called which translates
it to Z and outputs it to the Z document. However the SID function assumes that all the components of the record type
declaration have collected up ready for translation. Additional low level SID functions will be required
to collect up these components. 
}\epar

\bpar{
In this volume, the syntactic categories that contain SID functions are presented in the same order
as they appear in the concrete syntax of a literate script (appendix A).
The order in appendix A is in turn the same as the order in the SPARK manual.
There are slight differences between the syntax in appendix A and that in the SPARK manual.
This is so the syntax in appendix A can be transformed by SID into a one-track form.
Where there is a change, the original SPARK syntax has been left in but commented out.
}\epar

\bpar{
In this document, a comment refers to the Z after it.
}\epar



\bpar{
This document specifies the production of the Z document in a single pass over the literate script.
This determines a particular ordering for the paragraphs in the Z document.
Some SPARK constructs require the production of auxiliary modules of Z.
The paragraphs to produce these modules are specified here as coming at the head of the Z document
so that the structure of the Z document is broadly conformant with the modularity features of the
draft Z standard.
Tools implementing this specification are intended to preserve the ordering of the main paragraphs
in the Z document as far as possible so as to make it traceable against the literate script.
Tools are, however, permitted to generate the text for auxiliary modules in a non-standard order
(e.g., the text could be produced in situ at the point in the Z document where the module is required).
}\epar

\bpar{\label{ErrorPolicy}
It is to be assumed throughout this document that if something is not mentioned in the signature
of a SID function or other Z schema then it does not change.
Several of the schemas that define the SID functions are partial, i.e., their
pre-conditions may not always hold. This is intended to reflect the control logic
of the production of the Z document: if a SID function cannot be applied it should
be skipped. However, when the functions from volumes 2 and 3 are used, if
an argument is not in the domain of the function then the Compliance Argument contains
an error and this error must be reported.
}\epar

\section{Simple specification of a Z document}

\bpar{
The Z document which is generated from a literate script is a sequence of Z paragraphs.
}\epar

=SPCZ Z_DOC 
=TEX




\bpar{
At the start of each literate script $Z\_DOC$
is initialised using the schema \\
$INIT\_Z\_DOC$.
This takes a name for the script as an input variable.
The means for determining this name are implementation-dependent.
The initial Z document comprises a module header introducing a module with the same name
as the script and with at least two parents: the standard Z toolkit and
the SPARK extensions to the toolkit defined in appendix B of this document.
A tool may also allow the user to add additional parents, if required.
}\epar

=SPCZ Z_toolkit 
=TEX

=SPCZ SCRIPT_NAME 
=TEX

=SPCZ INIT_Z_DOC 
=TEX



\section{Compliance notation environments}

\subsection{Package specification environment}

\bpar{
This environment is incremented on encountering a ification.
This environment records the information from package specifications that is necessary
for formal development. The information in the environment is used when a package body or a {\tt with} clause
is encountered.
}\epar

  

\bpar{
A $Formal\_Fun$ is an Ada function which has a specification statement.
It is in fact an Ada function specification ($Informal\_Fun$) together with the specification statement ($Spec$).
A $Formal\_Fun$ can therefore occur in a package specification, function body or function stub. 
A $Formal\_Fun$ is similar to $Formal\_Proc$ (defined in volume 2) but for functions rather than procedures.
As SPARK functions must have no side-effects then the frame $w$ must be empty.
The $globals$ component records the list of global variables on which the formal function may depend.
}\epar

=SPCZ  Formal_Fun
=TEX



\bpar{
For each package specification the following information is recorded: \\
1. $vc\_vars$:  the variables declared. These will appear as local declarations in VCs if the package is utilised
(that is if a {\tt with} clause or package body is encountered). \\
2. $consts\_types$:  the constants and types declared. These will be output to the Z document if the package is utilised. \\
3. $formal\_procs$:  the formal procedures (those with a specification statement). These are used for VC generation involving
procedure calls if a {\tt with} clause is encountered. \\
4. $informal\_funs$:  the informal functions (those with no specification statement). All Ada functions
(both formal and informal) give rise to a Z
axiomatic description being output to the Z document. Thus the functions in a literate script must have different names
otherwise the Z document will not type-check.
This ensures that only the correct axiomatic description can be used to prove a VC.
The problem is a consequence of the nested structure of Ada being projected onto the flat structure of Z.
In the case of a package specification the $informal\_funs$ are output to the Z document when a {\tt with} clause is encountered. \\
5. $formal\_funs$:  the formal functions (those with a specification statement). These are output to the Z document when
a {\tt with} clause is encountered. \\
6. $aux\_vars$:  the auxiliary variables declared [3]. These will appear as local declarations in VCs if the package is utilised with a {\tt with} clause. They are also needed to generate VCs when data refinement
occurs in the corresponding package body. \\
7. $var\_renamings$:  a mapping recording the renaming declarations in the package.\\
8. $zmod$:  the name of the Z module which was current when the package specification was encountered.
}\epar


=SPCZ  Package
=TEX


\bpar{
The following functions update a $Package$ binding by changing just one component.
For example $Package\_vc\_vars(b, v)$ is the binding $b$ with the value in its
$vc\_vars$ field replaced with the new value $v$. Similar functions appear
for other schemas in this specification.
}\epar   

=SPCZ  Package_vc_vars
=TEX


\bpar{
The package specification environment.
The information from a package specification is stored under the name of the package.
}\epar

=SPCZ  PACK_ENV
=TEX



\bpar{
$PACK\_ENV$ is set to $PACK\_ENV0$ before processing the first literate script only.
}\epar

=SPCZ  PACK_ENV0
=TEX


\subsection{Subunit environment}

\bpar{
This environment is incremented on encountering a subprogram stub ({\tt \ldots\ is\ separate}).
The information in the environment is used when a subunit ({\tt separate\ \ldots}) is encountered.
}\epar





\bpar{
For each stub the following information is recorded: \\
1. $zmod$:  the state of the Z document at the time the stub is encountered; it is made into a module and imported into the
Z document that corresponds to the literate script containing the subunit. \\
2. $specif\_flag$:  a flag to say whether the stub is formal (contains a specification statement). \\
3. $specif$:  the specification statement of the stub; if there is no specification statement then $specif$ could be
set to anything and $specif\_flag$ will be $False$. \\
4. $In\_Scope$:  the variables, formal procedures etc that are in scope at the point the stub is declared.
These will be needed when processing the subunit since they are visible to the stub and hence to the subunit. \\
5. $globs$:  for a formal subprogram, this gives the list of global variables on
which the subprogram may depend. This is needed to check that the subunit and the stub give the same list.

}\epar  

=SPCZ  Subunit
=TEX

\bpar*{
The Subunit
environment will also be used for package stubs.
In particular, for a package stub, {\it specif\_flag} will be false and {\it specif}
can be arbitrary.
}\epar*

\bpar{
More binding update functions.
}\epar

=SPCZ  Subunit_vc_vars
=TEX


\bpar{
The subunit environment.
The information in a subunit is stored under the name of the parent unit (the unit in which the stub
was declared) and the name of the subprogram itself.
}\epar

=SPCZ  SUBUNIT_ENV
=TEX

\bpar{
$SUBUNIT\_ENV$ is set to $SUBUNIT\_ENV0$ before processing the first literate script only.
}\epar

=SPCZ  SUBUNIT_ENV0
=TEX


\subsection{Dec label environment}

\bpar{
This environment is incremented on encountering a k\_slot used as a declaration.
The information is used when the k\_slot is expanded.
}\epar

\bpar{
Throughout the specification a set of flags are used to let the compiling actions know the context
of where they are called. These flags are: \\
1. $pack\_spec\_flag$:  set to $True$ when a package specification is encountered. \\
2. $pack\_body\_flag$:  set to $True$ when a package body is encountered. \\
3. $stub\_flag$:  set to $True$ when a stub is encountered. \\
4. $subunit\_flag$:  set to $True$ when a subunit is encountered. \\
5. $body\_flag$:  set to $True$ when a package or subprogram body is encountered. \\
6. $formal\_body\_flag$:  set to $True$ when a formal procedure or function is encountered. \\
7. $fun\_flag$:  set to $True$ when a function is encountered. \\
8. $declabel\_flag$:  set to $True$ when a k\_slot used as a declaration is expanded. \\
9. $speclabel\_flag$:  set to $True$ when a specification statement is refined. \\
10. $till\_flag$:  set to $True$ when a till predicate is encountered.
}\epar

=SPCZ  Flags
=TEX


\bpar{
For each k\_slot the following information is recorded: \\
1. $block\_name$:  the name of the parent unit (the unit in which the k\_slot occurs).
This is needed in case the k\_slot is subsequently expanded to a stub. \\
2. $Flags$:  the flag settings of the block in which the k\_slot occurs.
This gives the context information for when the k\_slot is expanded. \\
3. $In\_Scope$:  the variables and formal procedures etc that are in scope at the point the k\_slot is encountered.
These are visible to the k\_slot and therefore also to the expansion.
}\epar

=SPCZ  Declab
=TEX


\bpar{
More binding update functions.
}\epar

=SPCZ  Declab_declabel_flag
=TEX


\bpar{
The dec label environment.
}\epar

=SPCZ  DEC_ENV
=TEX


\bpar{
$DEC\_ENV$ is set to $DEC\_ENV0$ at the start of each literate script.
}\epar

=SPCZ  DEC_ENV0
=TEX


\subsection{Spec label environment}

\bpar{
This environment is incremented on encountering a specification statement acting as a SPARK statement.
The information is used when the specification statement is refined (or expanded with $\equiv$).
The environment uses a $Speclab$ (see $SPEC\_ENV$ below).
The definition of $Speclab$ is in volume 2 because the VC generation algorithm is called with a $Speclab$ and a sequence of statements.
The $Speclab$ contains all the information the algorithm needs.
}\epar

\bpar{
The spec label environment is also used to deal with k\_slots acting as statements (see section 6).
Such a k\_slot is treated as a specification statement that is only expanded not refined.
This allows the SID functions for specification statements to be re-used for such k\_slots.
}\epar

\bpar{
More binding update functions.
}\epar

=SPCZ  Speclab_w
=TEX


\bpar{
The spec label environment.
}\epar

=SPCZ  SPEC_ENV
=TEX


\bpar{
$SPEC\_ENV$ is set to $SPEC\_ENV0$ at the start of each literate script.
}\epar

=SPCZ  SPEC_ENV0
=TEX


\subsection{Running environment}

\bpar{
This is a block structured environment which is continuously incremented as the
literate script is processed. It is used to increment the other four environments and
for example holds the information necessary to generate VCs demanding that the body of a
formal subprogram is a refinement of its specification statement.
The running environment reflects the block structure of Ada although extra blocks are also opened.
}\epar





\bpar{
A $Block$ consists of: \\
1. $Declab$:  described in subsection 3.3. This is used to update the other four environments. \\
2. $current\_formal\_proc$: On encountering a formal procedure a new block is opened and $current\_formal\_proc$ is set
to the $Formal\_Proc$: $current\_formal\_proc$ enables the output of VCs demanding that the body of a
formal procedure is a refinement of its specification statement.\\
4. $current\_formal\_fun$: On encountering a formal function a new block is opened and $current\_formal\_fun$ is set
to the $Formal\_Fun$: $current\_formal\_fun$ enables the output of VCs demanding that the body of a
formal function is a refinement of its specification statement. \\
5. $current\_loop\_name$:  the name of the immediately enclosing loop, if any, otherwise a dummy value
that would not be a valid Ada name.
6. $dec\_lab$:  the current dec label being expanded. \\
7. $spec\_lab$:  the current spec label being expanded. \\
8. $till$:  the current till predicate. \\
9. $using\_decs$:  the {\it using} declarations inside a package body needed for data refinement
(see section 13 --- SPARK packages). \\
10. $var\_inits$:  the association of initial values to variables arising from SPARK declarations
with initialising expressions.
}\epar

=SPCZ  Block
=TEX


\bpar{
In a lot of cases (not always) when a new block is opened the components of $In\_Scope$
(together with $var\_inits$) are set to $\{\}$.
}\epar

=SPCZ  Empty_Block
=TEX


\bpar{
More binding update functions.
}\epar

=SPCZ  Block_stub_flag
=TEX


\bpar{
The running environment.
}\epar


=SPCZ  ENV
=TEX


\bpar{
$ENV$ is set to $ENV0$ at the start of each literate script.
}\epar

=SPCZ  ENV0
=TEX




\bpar{
Unlike $ENV$ the other four environments are flat structured.
Three of the four environments record the variables, formal procedures etc that are in scope.
This information is in $ENV$ but block structured and so must be flattened.
In $flatten\_env$, the $dec\_labels$ are only gathered up from the current package or subprogram.
This ensures that the frame-widening described in section 4.4.1 does not propagate into
nested subprograms (which would lead to unsound VCs).
}\epar

=SPCZ  flatten_env
=TEX


\bpar{
The function $expand\_schema\_sigs$ takes a set of Z identifiers and produces a new one
by replacing each schema name in the set  by the set of signature variables of the schema.
}\epar

=SPCZ  expand_schema_sigs
=TEX


\bpar{
The function $subprog\_flatten\_env$ is a variant of $flatten\_env$
that ensures that in the body of a formal subprogram only the parameters,
local variables and named global dependencies are in scope.
(Note that the parameters include any {\tt for} loop variables).
}\epar

=SPCZ  subprog_flatten_env
=TEX


\bpar{
The following auxiliary function merges together two {\it In\_Scope}s.
}\epar

=SPCZ  merge_in_scopes
=TEX


\section{SPARK basic declarations ({\it basic\_declaration})}

\subsection{SID functions}



\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
basic\_declaration = \\
object\_declaration, \\
type\_declaration $< basic\_declaration >$, \\
subtype\_declaration $< basic\_declaration >$, \\
deferred\_constant\_declaration, \\
pragma; \\
\ \\
object\_declaration = \\
constant\_declaration $< basic\_declaration >$, \\
variable\_declaration $< adj\_var\_decl >$ $< var\_pack\_spec >$ $< update\_envs\_var >$ $< add\_var\_init\_env >$ $< add\_var\_env >$;
}\epar

\subsection{The SID function basic\_declaration}

\bpar{
The global variable $BASIC\_DEC$ holds the current constant, type or subtype declaration.
}\epar

=SPCZ BASIC_DEC
=TEX

\bpar{
The SID function $basic\_declaration$ deals with constant, type or subtype declarations.
Its specification is split into two cases
depending on whether the declaration appears in a package specification or not.
}\epar

\bpar{
Case 1. If the declaration is inside a package specification then add it to the package specification environment.
}\epar


=SPCZ  basic_decl_pack_spec
=TEX


\bpar{
Case 2. If the declaration is not inside a package specification then output it to the Z document.
The declaration is first translated to Z by the function $trans\_basic\_decl$ which is specified in volume 3.
}\epar

=SPCZ  basic_decl_otherwise
=TEX


\bpar{
Bringing the two cases together.
}\epar

=SPCZ  basic_declaration
=TEX



\subsection{The SID function var\_pack\_spec}





\bpar{
The global variable $VAR\_DECL$ defined
in volume 3 holds the current variable declaration.
}\epar


\bpar{
If a variable declaration is inside a package specification then the SID function $var\_pack\_spec$
adds it to the package specification environment.
}\epar

=SPCZ  var_pack_spec
=TEX


\subsection{The SID function update\_envs\_var}

\bpar{
If the variable declaration has been introduced by expanding a k\_slot then the SID function $update\_envs\_var$
updates the subunit, dec label and spec label environments (all three need updating).
This is necessary because these environments may have been incremented (perhaps many times) before
the k\_slot has been expanded.
The information from expanding the k\_slot now needs to be recorded in these environments.
Only those stubs, k\_slots and specification statements that are in the scope of the original k\_slot are affected.
The variables introduced by expanding the k\_slot are added to the $vc\_vars$ components of the environments.
Also in the case of the spec label environment the frame of all specification statements, which
are in the scope of the k\_slot, are widened with the new variables.
}\epar

=SPCZ  update_subunit_env_var
=TEX

=SPCZ  update_dec_env_var
=TEX

=SPCZ  update_spec_env_var
=TEX


\bpar*{
Note the $\land$s in the definition of $update\_envs\_var$ below indicating that all three environments need
updating.
}\epar*

=SPCZ  update_envs_var
=TEX


\subsection{The SID function add\_var\_env}

\bpar{
The SID function $add\_var\_env$ adds the variable declaration to the current environment.
This must be done in all cases;
even in the case when the variables are introduced by expanding a k\_slot there could be other declarations
(eg a procedure body) also introduced (a k\_slot can be expanded to a whole sequence of declarations) which are in the
scope of these variables.
}\epar

=SPCZ  add_var_env
=TEX


\subsection{The SID function add\_var\_init\_env}

\bpar{
If the variable declaration contains an initial value, the SID function
$add\_var\_init\_env$ records the initial value in the running environment.
}\epar

=SPCZ  add_var_init_env
=TEX

\subsection{The SID function adj\_var\_decl}

\bpar{
The current variable declaration as input to {\tt\itshape adj\_var\_decl} is given by the
global variable {\tt\itshape SI\_VAR\_DECL} defined in volume 3.
The adjustment gives a value to the global variable {\tt\itshape VAR\_DECL} and may give rise to a new subtype declaration (although a {\tt\itshape SI\_VAR\_DECL} appears to allow for many subtypes, the {\tt\itshape SI\_Var\_Decl}s are constrained to use the same subtype indication so there is 
just one).
The SID function {\tt\itshape adj\_var\_decl} is defined in terms 
of the function {\tt\itshape adjust\_var\_decl} from volume 1 and the
schema SID function {tt\itshape basic\_declaration}.
}\epar

=SPCZ  adj_var_decl
=TEX



\section{SPARK declarations ({\it dec})}

\subsection{SID functions}



\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
dec = \\ 
k\_slot $< k\_slot\_dec >$ $< update\_envs\_k\_slot >$, \\
renaming\_declaration, \\
basic\_declarative\_item, \\
package\_declaration, \\
body;
}\epar

\subsection{The SID function k\_slot\_dec}

\bpar{
The global variable $LAB$ contains the current label. It will therefore contain the label of the
current k\_slot (any type of k\_slot), specification statement or the label currently being expanded or refined.
If a specification statement has no label then $LAB$ contains the special label $no\_label$.
}\epar

=SPCZ  LAB
=TEX

=SPCZ  no_label
=TEX


\bpar{
The function $dot$ takes two Ada identifiers {\tt id1} and {\tt id2} and yields the new identifier {\tt id1.id2} as result.
Ada uses {\tt .} in subunit names.
}\epar 


=SPCZ  dot
=TEX


\bpar{
The SID function $k\_slot\_dec$ increments the dec label environment with the current k\_slot.
Recall that $block\_name$ is needed in the environment in case the k\_slot is subsequently expanded into a stub.
If the k\_slot is in a subunit itself then $block\_name$ must record the name of the subprogram's parent.
}\epar

=SPCZ  k_slot_dec
=TEX



\subsection{The SID function update\_envs\_k\_slot}

\bpar{
If the k\_slot has been introduced by expanding a k\_slot, then
the SID function\\
$update\_envs\_k\_slot$
updates the subunit, dec label and spec label environments (all three
need updating).
This is necessary because these environments may have been incremented
(perhaps many times) before the k\_slot has been expanded.
The information from expanding the k\_slot now needs to be recorded in these
environments.
Only those stubs, k\_slots and specification statements that are in the scope
of the original k\_slot are affected.
The new k\_slot is added to the $dec\_labels$ components of all the environments.
}\epar


=SPCZ  update_subunit_env_k_slot
=TEX

=SPCZ  update_dec_env_k_slot
=TEX

=SPCZ  update_spec_env_k_slot
=TEX


=SPCZ  update_envs_k_slot
=TEX


\section{SPARK statements ({\it statement})}

\subsection{SID functions}

\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
statement = \\
k\_slot $< k\_slot\_stmt >$, \\
specification\_statement $< spec\_stmt >$, \\
con z\_decl $< add\_log\_con\_env >$ fatdot specification\_statement $< spec\_stmt >$ $< remove\_log\_con\_env >$, \\
simple\_statement, \\
compound\_statement, \\
pragma;\\
\\
block\_statement =\\
	name\_colon\_opt $< new\_block >$\\
	declare declarative\_part begin $< update\_spec\_env\_block >$ sequence\_of\_statements end name\_opt semi,\\
	name\_colon\_opt $< new\_block >$ begin sequence\_of\_statements end name\_opt semi;
}\epar

\subsection{The SID function spec\_stmt}

\bpar{
The global variable $SPEC\_STMT$ holds the current specification statement.
}\epar

=SPCZ  SPEC_STMT
=TEX



\bpar*{
Schema names in the concrete frame of the specification statement serve as a short-hand
for the names of the signature variables of the schema.
Each schema name must be replaced by the list of names in the signature of the schema
in the abstract frame inside the global variable $SPEC\_STMT$.
This replacement must be carried out with respect to the schema definitions in the context of the
current Z module (i.e., in the context is used to type-check the pre- and post-condition of the
specification statement).
}\epar*

\bpar{
The SID function $spec\_stmt$ increments the spec label environment on encountering a specification statement.
There are two cases to consider. The following schema is  common to both cases (and is the point
at which we depend on $current\_loop\_name$ being an invalid Ada name by default).
Note that the treatment of $till$ and $till\_flag$ is common to both cases because
$new\_scope\_speclabel$ copies the relevant information into the current environment.

}\epar

=SPCZ  spec_stmt_common
=TEX

\bpar{
Case 1. Specification statement introduced during a refinement step (or the simple expansion of a spec label).
A lot of the information in the new $Speclab$ is simply copied from the $Speclab$ corresponding to the
spec label being refined or expanded.
There is a problem with the specification below if $no\_label$
is refined into a sequence of statements that itself includes a
specification statement with no label. This is because the new occurrence
of $no\_label$ is added to $SPEC\_ENV$ before the first occurrence is deleted
(by the SID function $end\_scope\_speclabel$ in the section on Web clauses),
but this would contradict the fact that $spec\_env$ is a Z function.
The solution is to treat each new occurrence of $no\_label$ in a literate
script as a different label (that is $no\_label\_1$, $no\_label\_2$ etc). 
}\epar

=SPCZ  spec_stmt_speclabel
=TEX


\bpar{
Case 2. All other cases when a specification statement is encountered.
}\epar


=SPCZ  spec_stmt_otherwise
=TEX


\bpar{
Bringing the two cases together.
}\epar

=SPCZ  spec_stmt
=TEX



\subsection{The SID function k\_slot\_stmt}

\bpar{
The SID function $k\_slot\_stmt$ increments the spec label environment on encountering a k\_slot acting
as a SPARK statement.
It does not matter what specification statement is stored in the environment since it will never be used.
}\epar

=SPCZ  k_slot_stmt
=TEX


\subsection{The SID function add\_log\_con\_env}

\bpar{
The global variable $LOGICAL\_CON$ holds the current logical constant declaration.
}\epar



=SPCZ  LOGICAL_CON
=TEX


\bpar{
The SID function $add\_log\_con\_env$ adds a logical constant declaration to the local block.
It will then be stored on encountering the SID function $spec\_stmt$ which is called after the
logical constant's specification statement.
}\epar


=SPCZ  add_log_con_env
=TEX


\subsection{The SID function remove\_log\_con\_env}

\bpar{
The SID function $remove\_log\_con\_env$ removes the logical constant declaration from the local block.
This is because the scope of the logical constant is only its specification statement
(and subsequent refinements of the specification statement).
}\epar

=SPCZ  remove_log_con_env
=TEX

\subsection{The SID function new\_block}
\bpar{
A block statement is only processed formally if it appears on the right-hand side
of a refinement or replacement. It does not create a new scope in the environment.
The purpose of {\it new\_block} is to set {\it body\_flag}.
}\epar
=SPCZ  new_block
=TEX

\subsection{The SID function update\_spec\_env\_block}
\bpar{
In order that the vcs generated by the refinenent statement are correct for a block it is necessary to augment the precondition of the relevant specification to include information about the initialisation of variables in the declarative part of the block.
This is similar to the treatment of vc generation for subprogram bodies (cf. {\it vcs\_body\_proc}), but the relevant specification is in this case found in the {\it SPEC\_ENV}, and generation of vcs is done later.
}\epar
=SPCZ  update_spec_env_block
=TEX


\section{SPARK loops ({\it loop\_statement})}

\subsection{SID functions}

\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
loop\_statement = \\
name\_opt1 $< new\_scope\_loop >$ iteration\_scheme\_opt till\_opt loop \\
sequence\_of\_statements end loop name\_opt2 semi $< end\_scope >$; \\
\ \\
loop\_parameter\_specification = \\
identifier in type\_mark $< for\_param >$, \\
identifier in reverse type\_mark, \\
identifier in type\_mark $< for\_param >$ rrange range, \\
identifier in reverse type\_mark rrange range, \\
identifier in $< for\_param >$ range,\\
identifier in reverse $< for\_param >$ range; \\
\ \\
till\_opt = \\
\$, \\
till z\_pred $< till\_pred >$;
}\epar

\subsection{The SID function new\_scope\_loop}

\bpar{
The SID function $new\_scope\_loop$ adds a new block to the running environment on encountering a loop.
The variable $LOOP\_NAME$ holds the optional loop name which is copied into $current\_loop\_name$
in the running environment.
}\epar

=SPCZ LOOP_NAME
=TEX
=SPCZ  new_scope_loop
=TEX

\subsection{The SID function end\_scope}

\bpar{
The SID function $end\_scope$ takes the innermost block off the running environment.
}\epar

=SPCZ  end_scope
=TEX


\subsection{The SID function for\_param}

\bpar{
The global variable $FOR\_PARAM$ holds the current {\tt for} loop variable.
}\epar

=SPCZ  FOR_PARAM
=TEX


\bpar{
The SID function $for\_param$ adds a {\tt for} loop variable to the $vc\_pars$ field of the local block.
This is because the value of a {\tt for} loop variable can not be changed by the user.
From a formal development point of view it is treated as a formal parameter
of mode $in$. This means that in the local declarations of the VCs there will be no corresponding initial variable. 

In the cases where the loop parameter specification contains no type mark the 
loop identifier will be declared with a subtype derived from the type represented as 
{\tt\itshape universal\_discrete} with the constraint given by the range. In the case where the range is given as a range attribute it is transformed into a simple range by transforming 
{\tt\itshape P'RANGE} into {\tt\itshape P'FIRST $..$ P'LAST} and similarly for multi-dimensional array ranges as elsewhere in this specification.
}\epar

=SPCZ  for_param
=TEX


\subsection{The SID function till\_pred}

\bpar{
The global variable $TILL\_PRED$ holds the current till predicate.
}\epar

=SPCZ  TILL_PRED
=TEX

\bpar{
The SID function $till\_pred$ adds a till predicate to the local block.
$till\_flag$ is also set to $True$ indicating that the $till$ field is correctly set.
}\epar 

=SPCZ  till_pred
=TEX

\section{SPARK subprogram declarations ({\it subprogram\_declaration})}

\subsection{SID functions}

\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
subprogram\_declaration = \\
procedure\_specification semi $< end\_scope >$ $<add\_proc\_env>$, \\
function\_specification semi $< end\_scope >$;
}\epar

\bpar*{
The block opened up for a subprogram must be closed at the end of the subprogram.
Recall that the block is opened up within the syntax for procedure\_specification and function\_specification.
For a procedure, the procedure is then added to the environment so that it can be called.
}\epar*
\subsection{The SID function add\_proc\_env}
\bpar{
The SID function $add\_proc\_env$ adds the formal procedure to the running environment so that
subsequent subprograms can call it.
}\epar

=SPCZ add_proc_env
=TEX


\section{SPARK procedures ({\it procedure\_specification})}

\subsection{SID functions}

\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
procedure\_specification = \\
procedure identifier $< subunit\_inf >$ $< new\_scope\_proc\_inf >$ $< stub >$, \\
procedure identifier $< subunit\_form >$ $< new\_scope\_proc\_form >$ $< stub >$
procedure\_specification\_statement $< curr\_form\_proc >$ $< form\_proc >$ $< stub\_spec\_proc >$, \\
procedure identifier $< subunit\_inf >$ $< new\_scope\_proc\_inf >$ $< stub >$ formal\_part, \\
procedure identifier $< subunit\_form >$ $< new\_scope\_proc\_form >$ $< stub >$ 
formal\_part procedure\_specification\_statement $< curr\_form\_proc >$ $< form\_proc >$ $< stub\_spec\_proc >$;
}\epar

\subsection{The SID function subunit\_form}

\bpar{
The global variable $IDENT$ holds the current identifier.
}\epar

=SPCZ  IDENT
=TEX


\bpar{
On encountering a formal procedure which is also a subunit, the SID function \\ 
$subunit\_form$ outputs to the Z document a paragraph making the Z module formed
when the corresponding stub was processed a parent of the current Z module.
}\epar

=SPCZ  subunit_form
=TEX


\subsection{The SID function subunit\_inf}

\bpar{
On encountering an informal procedure which is also a subunit, the SID function $subunit\_inf$
again outputs the Z module but this time removes the subunit from the subunit environment.
All the information has been extracted from the subunit environment and placed in the running environment.
However in the case of a formal subunit (above) VCs need to be output which demand that the specification statement in the
subunit is a refinement of that in the stub. This is done by the SID function $form\_proc$ (defined later in this section). 
$form\_proc$ therefore needs access to the specification statement of the stub which is held in the
subunit environment. Therefore, in the above case, this information must not be deleted.
}\epar

=SPCZ  subunit_inf
=TEX


\subsection{The SID function new\_scope\_proc\_inf}

\bpar{
The SID function $new\_scope\_proc\_inf$ adds a new block to the running environment on encountering an informal procedure.
}\epar

=SPCZ  new_scope_proc_inf
=TEX


\subsection{The SID function new\_scope\_proc\_form}

\bpar{
The SID function $new\_scope\_proc\_form$ adds a new block to the running environment on encountering a formal procedure.
}\epar

=SPCZ  new_scope_proc_form
=TEX


\subsection{The SID function stub}



\bpar{
When a stub is encountered, the function $make\_module$
is used to make a copy of the current Z module under a new name.
This copy is thought of as being placed at the beginning of the Z document.
When the corresponding subunit is encountered, the stub module becomes
a parent of the current Z module (as seen in the SID functions
$subunit\_form$ and $subunit\_inf$ defined earlier in this section).
This approach will also work if the stub appears in a subunit,
so a user can form subunits of subunits and so on.
}\epar
=SPCZ  make_module
=TEX

\bpar*{
The function $trans\_subunit\_name$
creates a Z module name appropriate for the stub module.
}\epar*

=SPCZ  trans_subunit_name
=TEX



\bpar{
The SID function $stub$ creates the stub module and stores its name in the subunit environment.
The {\it In\_Scope} set up here is provisional, the SID function {\it stub\_spec\_proc}
or {\it stub\_spec\_fun} will calculate the correct value when the function
specification (if any) has been processed.
}\epar

=SPCZ  stub
=TEX

\subsection{The SID function stub\_spec\_proc}

\bpar{
The global variable $FORM\_PROC$ holds the current $Formal\_Proc$.
The {\it globals} component of the formal procedure is derived from
the procedure specification statement in the concrete syntax by concatenating
the frame and the dependencies (the list of global variables read by the procedure
but not written). As with the frame, schema names may be used in the dependencies
in the concrete syntax but these need not be replaced by the signature variables
in $FORM\_PROC$, since that is done explicitly using $expand\_schema\_sigs$ when
necessary.

}\epar

=SPCZ  FORM_PROC
=TEX




\bpar*{
The formal procedure contains a specification statement.
Schema names in the concrete frame of this specification statement must have been replaced
by variable names as described in section 6.2.1.
}\epar*

\bpar{
The SID function $stub\_spec\_proc$ adds the specification statement of a formal procedure stub to the subunit environment.
}\epar

=SPCZ  stub_spec_proc
=TEX

\newpage

\subsection{The SID function form\_proc}

\bpar{
The SID function $form\_proc$ outputs VCs to the Z document demanding that, if a formal procedure is inside a
package body then its specification statement must be a refinement of that in the package specification,
or if a formal procedure is a subunit then its specification statement must be a refinement of that in the stub.
If a formal procedure is inside a package specification then it is added to the package specification environment. 
There are therefore three cases to consider.
}\epar

\bpar{
Case 1. If the formal procedure is in a package specification then add it to the package specification environment.
}\epar

=SPCZ  form_proc_pack_spec
=TEX

\newpage


\bpar{
Case 2. If the formal procedure is in a package body then 
output VCs demanding that its specification statement is a refinement of that in the package specification.
The form of the VCs depends on whether or not the 
specification statement of the formal procedure is a data refinement of that in the package
specification. The following schema is common to both cases.
}\epar



=SPCZ  form_proc_pack_body_common
=TEX


\bpar*{
Case 2.1. The specification statement of the formal procedure is {\it not} a data refinement
of that in the package specification.
}\epar*

=SPCZ  form_proc_pack_body
=TEX

\bpar*{
Case 2.2. The specification statement of the formal procedure {\it is} a data refinement
of that in the package specification.
}\epar*

\bpar*{
VCs for this data refinement are achieved by the tool transforming the
specification statement in the package specification ($Spec_3$),
which is in abstract terms, to a specification statement in concrete terms
($Spec_5$). The usual VC generation algorithm can then be used, demanding
that the specification statement in the package body ($Spec$) is a refinement
of $Spec_5$.
}\epar*

\bpar*{
$Spec_3$ is transformed into $Spec_5$ as follows.
Firstly any {\it auxiliary} variable $A$ appearing in the precondition or
postcondition (of $Spec_3$) that is {\it not} in the frame must be added to the
frame and a predicate $A = A_0$ conjoined to the postcondition.
This new specification statement is $Spec_6$.
The concrete variables are then added to the frame, the auxiliary variables
removed from the frame, and the auxiliary variables removed from the
precondition and postcondition by basically quantifying over them.
}\epar*

\bpar*{
$aux\_vars_0$ is obtained from the set of Z declarations $aux\_vars$ by subscripting
each variable to the left of the $:$ with zero.
$frame\_aux\_conc_0$ and $add\_aux_0$ are obtained from $frame\_aux\_conc$ and $add\_aux$
by subscripting each variable by zero. 
}\epar*


=SPCZ  form_proc_pack_body_aux
=TEX

\newpage

\bpar{
Case 3. If the formal procedure is a subunit then
output VCs demanding that its specification statement is a refinement of that in the stub.
}\epar




=SPCZ  form_proc_subunit
=TEX


\bpar{
Bringing the above cases together.
}\epar

=SPCZ  form_proc
=TEX

\newpage
\subsection{The SID function curr\_form\_proc}

\bpar{
The SID function $curr\_form\_proc$ adds the $Formal\_Proc$ to the running environment so that if it is
part of a formal procedure body then
VCs can be output which demand that the code in its body is a refinement of its
specification statement (this is done by the SID function $vcs\_body$ in the section on subprogram bodies - section 12).
}\epar

=SPCZ  curr_form_proc
=TEX


\section{SPARK functions ({\it function\_specification})}

\subsection{SID functions}



\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
function\_specification = \\
function designator $< subunit\_inf >$ $< new\_scope\_fun\_inf >$ $< stub >$
return type\_mark $< inf\_fun >$, \\
function designator $< subunit\_form >$ $< new\_scope\_fun\_form >$ $< stub >$ return type\_mark
function\_specification\_statement $< curr\_form\_fun >$ $< stub\_spec\_fun >$ $< form\_fun >$, \\
function designator $< subunit\_inf >$ $< new\_scope\_fun\_inf >$ $< stub >$ formal\_part
return type\_mark $< inf\_fun >$, \\
function designator $< subunit\_form >$ $< new\_scope\_fun\_form >$ $< stub >$ formal\_part
return type\_mark function\_specification\_statement $< curr\_form\_fun >$ \\
$< stub\_spec\_fun >$ $< form\_fun >$;
}\epar

\subsection{The SID function new\_scope\_fun\_inf}

\bpar{
The SID function $new\_scope\_fun\_inf$ adds a new block to the running environment on encountering an informal function.
}\epar

=SPCZ  new_scope_fun_inf
=TEX


\subsection{The SID function new\_scope\_fun\_form}

\bpar{
The SID function $new\_scope\_fun\_form$ adds a new block to the running environment on encountering a formal function.
}\epar

=SPCZ  new_scope_fun_form
=TEX

\subsection{The SID function stub\_spec\_fun}

\bpar{
The global variable $FORM\_FUN$ holds the current $Formal\_Fun$.
}\epar

=SPCZ  FORM_FUN
=TEX



\bpar*{
The formal function contains a specification statement.
Schema names in the global dependency list of the function are not to be replaced
by variable names as described in section 6.2.1. Instead, a schema name corresponds
to a single component of the first parameter of the Z translation of the function.
(the component of the parameter corresponding to $S$ being supplied as $\theta S$ when the Z function
is used).

}\epar*

\bpar{
The SID function $stub\_spec\_fun$ adds the specification statement of a formal function stub to the subunit environment.
}\epar

=SPCZ  stub_spec_fun
=TEX


\subsection{The SID function inf\_fun}

\bpar{
The global variable $INF\_FUN$ holds the current $Informal\_Fun$.
}\epar

=SPCZ  INF_FUN
=TEX


\bpar{
Every Ada function gives rise to a Z axiomatic description of the function being output to the Z document;
informal functions give rise to an axiomatic description consisting of just a declaration (no predicate).
Thus if the Z document is to type-check then all functions in the literate script must have different names.
This ensures that when proving a VC involving a function call, the correct axiomatic description is used.
This problem arises because of the nested structure of Ada being projected onto the flat structure of Z.
The SID function $inf\_fun$ deals with informal functions while $formal\_fun$ (specified later in this section)
deals with formal functions. 
}\epar





\bpar{
An informal function is translated, using an axiomatic description, as a member of the given set
$Informal\_Function$. This means that the Z document will not type-check if an informal
function name clashes with the name of some other Z object and helps
to prevent the use of informal function in expressions that are handled formally.
The following function $inf\_fun\_decl$ produces the Z declaration for the axiomatic description.
}\epar

=SPCZ  informal_function
=TEX

=SPCZ  inf_fun_decl
=TEX

Whenever we produce the axiomatic description for a function (formal or informal), we use the
following function which will add it to the sequence of Z paragraphs being produced unless an
identical axiomatic description is already there. This allows for forward declarations of functions
provided the specification statements (if any) in the forward and actual declaration are identical.

=SPCZ add_fun_ax
=TEX

\bpar{
The specification of the SID function $inf\_fun$ is split into two cases.
}\epar

\bpar{
Case 1. If the informal function  is in a package specification then add it to the package specification environment.
}\epar

=SPCZ  inf_fun_pack_spec
=TEX


\bpar{
Case 2. If the informal function is not in a package specification then output an axiomatic description (no predicate)
to the Z document. The SID function $inf\_fun\_\-otherwise$ which does this uses the function $trans\_informal\_fun$
which translates the informal function to Z and creates the Z axiomatic description.
}\epar

=SPCZ  trans_informal_fun
=TEX

=SPCZ  inf_fun_otherwise
=TEX


\bpar{
Bringing the two cases together.
}\epar

=SPCZ  inf_fun
=TEX

\subsection{The SID function form\_fun}

\bpar{
The SID function $form\_fun$ is called on encountering a formal function. As well as outputting a Z axiomatic description
to the Z document (this time with a predicate part) it also outputs VCs in a similar way to that for procedures.
The SID function $form\_fun$ is therefore similar to the SID function $form\_proc$;
if a formal function is inside a
package body then its specification statement must be a refinement of that in the package specification,
if a formal function is a subunit then its specification statement must be a refinement of that in the stub.
If a formal function is inside a package specification then it is added to the package specification environment.
In all other cases just a Z axiomatic description is output. 
There are therefore four cases to consider.
}\epar

\bpar{
Case 1. If the formal function is inside a package specification then add it to the package specification environment.
}\epar

=SPCZ  form_fun_pack_spec
=TEX


\bpar{
Case 2. If the formal function is inside a package body then first output a Z axiomatic description of the function
and then output VCs demanding that the specification statement of the function
must be a refinement of that in the package specification. There are two cases for these Vcs depending
on whether or not the global dependencies of the function in the package specification
refer to auxiliary variables or not (i.e., whether or not the function in the package body is
a data refinement of the one in the package specification).

The Z axiomatic description is calculated by the function $trans\_formal\_fun$.
The Z translation of the formal function has up to two arguments: one corresponding to the global dependencies of the
Ada function, if any, and one corresponding to the Ada formal parameters, if any. 
For example, a function specified as: 


=GFT Compliance Notation Example
function F (X : INTEGER; Y : BOOLEAN) return BOOLEAN
˜ [PRE, POST]
=TEX

will be translated as:

¹IZAX 
F: (INTEGER ¸ BOOLEAN) ­ BOOLEAN
÷
µ X : INTEGER; Y : BOOLEAN · PRE ´ POST
°


and a function specified as: 

=GFT Compliance Notation Example
function G (X : INTEGER; Y : BOOLEAN) return BOOLEAN
˜ A, B, C[PRE, POST]
=TEX

where the program variables, {\tt A} has  Ada type {\tt ATYPE},
where {\tt B} denotes a Z schema and where
the auxiliary variable $C$ is declared as a member of the Z set $CSET$, will be translated as:
}\epar


¹IZAX 
G: (ATYPE ¸ B ¸ CSET) ­ (INTEGER ¸ BOOLEAN) ­ BOOLEAN
÷
µ A : ATYPE; B; C : CSET· 
	µ X : INTEGER; Y : BOOLEAN · PRE ´ POST
°

\bpar*{
Several auxiliary functions are used by $trans\_formal\_fun$. 


The auxiliary function $fun\_sig$ produces the signature of a total function given a sequence of
formal parameter sets and a return set.
If the sequence of formal parameter sets is empty it produces the
signature for a member of the return set.
The latter case handles Ada functions without formal and/or global parameters.
}\epar*

=SPCZ  fun_sig
=TEX


\bpar*{
The auxiliary function $z\_forall\_opt$ is used to form universally quantified Z predicates
as necessary.
}\epar*

=SPCZ  z_forall_opt
=TEX


\bpar*{
The auxiliary function $par\_tmark$ extracts the type mark from an Ada parameter
specification and returns its translation into Z. For example, it maps
{\tt X : INTEGER} into $INTEGER$.
}\epar*

=SPCZ  par_tmark
=TEX


\bpar*{
The auxiliary function $var\_sig$ extracts from the environment the type information
about a variable in the list of global dependencies of a function.
This is the Z translation of the type mark in the case of a program
variable; it is the variable itself in the case of a global variable denoting a schema;
it is the right-hand side of the declaration in the case of an auxiliary variable.
}\epar*

=SPCZ  var_sig
=TEX


\bpar*{
The auxiliary function $fun\_decl$
calculates the Z declaration for the translation of the Ada function.
}\epar*

=SPCZ  fun_decl
=TEX





\bpar*{
The auxiliary function $z\_par\_decl$ forms a Z declaration from an Ada parameter specification.
For example, it maps {\tt X : INTEGER} to $X : INTEGER$.
}\epar*

=SPCZ  z_par_decl
=TEX


\bpar*{
The auxiliary function $z\_vars\_of\_env$  determines the set of Z variables that
are the translations of progam variables (including parameters) and auxiliary
variables that are in an environment.
}\epar*
=SPCZ z_vars_of_env
=TEX

\bpar*{
The auxiliary function $z\_var\_decl$ forms the Z declaration for a Z variable (using
$var\_sig$ to extract the necessary information from the environment):
}\epar*

=SPCZ  z_var_decl
=TEX


\bpar*{
The function $trans\_formal\_fun$ assumes that the only free variables in $pre$ and $post$ are
the formal parameters and global dependencies. Hence the function is partial.
}\epar*

=SPCZ  trans_formal_fun
=TEX


\bpar*{
The function $trans\_formal\_fun\_name$ gives the Z translation of the name of a function
in an Ada function call. This is like $trans\_fun\_name$ in volume 3, but parametrised by
a {$Formal\_Fun$} rather than just the name. 
}\epar*

=SPCZ  trans_formal_fun_name
=TEX
\bpar*{
$subs\_exp\_for\_exp\_in\_pred(p, e_1, e_2)$ gives the result
of substiuting $er_2$ for all free occurrences of $e_1$ in the predicate $p$. 
}\epar*

=SPCZ subs_exp_for_exp_in_pred
=TEX

The following schema applies whether or not the function is a data refinement of the function
in the package specification. It leaves the values of $Spec'''''$ unspecified
so that they can be constrained appropriately later.

=SPCZ  form_fun_pack_body_common
=TEX


\bpar*{
Case 2.1. The specification statement of the formal function is {\it not} a data refinement
of that in the package specification.
}\epar*

=SPCZ  form_fun_pack_body
=TEX

\bpar*{
Case 2.2. The specification statement of the formal procedure {\it is} a data refinement
of that in the package specification.
}\epar*

\bpar*{
VCs for this data refinement are achieved by the tool transforming the
specification statement in the package specification ($Spec'''$),
which is in abstract terms, to a specification statement in concrete terms
($Spec'''''$). The usual VC generation algorithm can then be used, demanding
that the specification statement in the package body ($Spec$) is a refinement
of $Spec'''''$.
}\epar*


\bpar*{
The pre-condition of $Spec'''''$ is obtained from that of $Spec'''$ by conjoining
all the invariants and then existentially quantifying over the auxiliary variables.
The post-condition of $Spec'''''$
is a universally quantified implication, quantified over the
auxiliary variables. The antecedent is the conjunction of the pre-condition of $Spec'''$
and the invariant. The succedent is obtained from the post-condition of $Spec'''$ by substituting
the Z translation of the concrete function name for that of the abstract one,
conjoining the invariants and existentially quantifying
over the auxiliary variables.
}\epar*

\bpar*{
The variable $conc\_ids$ in the following schema is not used here, but is used 
}\epar*


=SPCZ  form_fun_pack_body_aux
=TEX


\bpar{
Case 3. If the formal function is a subunit then first output a Z axiomatic description of the function
and then output VCs demanding that the specification statement of the function
must be a refinement of that in the stub. The global dependencies
declared for the subunit must be the same as those declared for the stub.
}\epar

\newpage



=SPCZ  form_fun_subunit
=TEX

\bpar{
Case 4. In all other cases just output a Z axiomatic description of the function.
}\epar

=SPCZ  form_fun_otherwise
=TEX


\bpar{
Bringing the four cases together.
}\epar

=SPCZ  form_fun
=TEX


\subsection{The SID function curr\_form\_fun}

\bpar{
The SID function $curr\_form\_fun$ adds the $Formal\_Fun$ to the running environment so that if it is
part of a formal function body then
VCs can be output which demand that the code in its body is a refinement of its
specification statement (this is done by the SID function $vcs\_body$ in the section on subprogram bodies - section 12).
}\epar

=SPCZ  curr_form_fun
=TEX


\section{SPARK formal parameters ({\it formal\_part})}

\subsection{SID functions}

\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
formal\_part = ord parlist $< formal\_part >$ crd;
}\epar

\subsection{The SID function formal\_part}

\bpar{
The global variable $FORMALS$ holds the formal parameters of the current subprogram.
}\epar

=SPCZ FORMALS
=TEX

\bpar{
The SID function $formal\_part$ adds the formal parameters to the running environment.
They will ultimately appear as local declarations in the VCs.
}\epar

=SPCZ formal_part
=TEX

\section{SPARK subprogram bodies ({\it subprogram\_body})}

\subsection{SID functions}

\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
subprogram\_body = \\
procedure\_specification is subprogram\_implementation $< update\_envs\_proc >$ \\
$< end\_scope >$, \\
function\_specification is subprogram\_implementation $< end\_scope >$; \\
\ \\
subprogram\_implementation = \\ 
$<add\_proc\_env>$ $< subprogram\_implementation >$
  declarative\_part \\
  sequence\_of\_statements
  $< vcs\_body >$
  end designator semi;

}\epar

\subsection{The SID function update\_envs\_proc}

\bpar{
If the formal procedure has been introduced by expanding a k\_slot then the SID function $update\_envs\_proc$
updates the subunit, dec label and spec label environments (all three need updating).
This is necessary because these environments may have been incremented (perhaps many times) before
the k\_slot has been expanded.
The information from expanding the k\_slot now needs to be recorded in these environments.
Only those stubs, k\_slots and specification statements that are in the scope of the original k\_slot are affected.
The formal procedure is added to the $formal\_procs$ components of the environments. 
}\epar

=SPCZ update_subunit_env_proc
=TEX

=SPCZ update_dec_env_proc
=TEX

=SPCZ update_spec_env_proc
=TEX

=SPCZ update_envs_proc
=TEX

\subsection{The SID function subprogram\_implementation}
\bpar{

 The SID function {\it subprogram\_implementation}
sets {\it body\_flag} to {\it True}.
}\epar

=SPCZ subprogram_implementation
=TEX


\subsection{The SID function vcs\_body}

\bpar{
The global variable $SEQ\_STMTS$ holds the current sequence of statements (or a null statement in
the case of an omitted package initialization).
When a block statement is processed, {\it SEQ\_STMTS} holds the sequence of statements inside
the block.
}\epar

=SPCZ SEQ_STMTS
=TEX


\bpar{
The SID function $vcs\_body$ outputs VCs demanding that the sequence of statements inside the body of
a formal subprogram is a refinement of its formal specification. There are two cases to consider.
In both cases, if any of the local variables of the subprogram have initial values,
then the precondition  of the formal specification is strengthened by conjoining it with predicates
asserting that each initialised local variable is equal to its initial value.
}\epar

\bpar{
Case 1. Sequence of statements inside a formal procedure.
}\epar

=SPCZ vcs_body_proc
=TEX
 

\bpar{
Case 2. Sequence of statements inside a formal function.
}\epar

=SPCZ vcs_body_fun
=TEX

\bpar{
Bringing the two cases together.
}\epar

=SPCZ vcs_body
=TEX

\section{SPARK packages ({\it package\_specification})}

\subsection{SID functions}



\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
package\_specification = \\
package identifier $< new\_scope\_pack\_spec >$ is visible\_part end \\
simple\_name $< end\_scope >$ $<update\_envs\_pack\_spec>$, \\
package identifier $< new\_scope\_pack\_spec >$ is visible\_part private private\_part end \\
simple\_name $< end\_scope >$ $<update\_envs\_pack\_spec>$;
}\epar



\bpar*{
visible\_part = \\
visdec, \\
visdec visible\_part; \\
\ \\
visdec = k\_slot $< k\_slot\_dec >$ $< update\_envs\_k\_slot >$, \\
basic\_declarative\_item, \\
subprogram\_declaration, \\
auxiliary z\_decl $< aux\_var >$ semi, \\
renaming\_declaration; \\
\ \\
private\_part = \\
pdec, \\
pdec private\_part; \\
\ \\
pdec = \\
k\_slot $< k\_slot\_dec >$ $< update\_envs\_k\_slot >$, \\
basic\_declarative\_item, \\
renaming\_declaration; \\
}\epar*

\bpar*{
package\_body = \\
package bbody simple\_name $< new\_scope\_pack\_body >$ $<subunit\_inf>$ \\
is package\_implementation end \\
simple\_name semi $< end\_scope >$;
}\epar*



\bpar*{
package\_implementation = \\
declarative\_part, \\
declarative\_part begin package\_initialization, \\
using\_list declarative\_part\_1 $< vcs\_aux\_initial >$, \\
using\_list declarative\_part\_1 begin package\_initialization $< vcs\_aux\_initial >$; \\
\ \\
using\_list = \\
using\_dec, \\
using\_dec using\_list; \\
\ \\
using\_dec = using basic\_dec\_list implement z\_id by z\_pred $< using\_dec >$ semi; \\
\ \\
basic\_dec\_list = \\
basic\_dec, \\
basic\_dec basic\_dec\_list;
}\epar*



\bpar*{
basic\_dec = \\
constant\_declaration $< basic\_declaration >$, \\
variable\_declaration $< adj\_var\_decl >$ $< add\_var\_init\_env >$ $< var\_pack\_spec >$ $< update\_envs\_var >$ $< add\_var\_env >$, \\
type\_declaration $< basic\_declaration >$, \\
subtype\_declaration $< basic\_declaration >$, \\
pragma;
}\epar*

\bpar*{
compilation\_unit = \\
context\_clause pragma\_list library\_unit $< end\_scope\_comp\_unit >$, \\
context\_clause pragma\_list secondary\_unit $< end\_scope\_comp\_unit >$, \\
pragma;
}\epar*



\bpar*{
context\_clause = \$, \\
                  with\_clause, \\
                  with\_clause references\_clause, \\
                  references\_clause; \\
\ \\
references\_clause = references simple\_name\_list semi;
}\epar*

\bpar*{
with\_clause = with simple\_name\_list semi; \\
\ \\
simple\_name\_list = \\
simple\_name $< new\_scope\_with >$, \\
simple\_name $< new\_scope\_with >$ comma simple\_name\_list;
}\epar*

\subsection{The SID function new\_scope\_pack\_spec}



\bpar{
On encountering a package specification the SID function $new\_scope\_pack\_spec$ adds a new block to the
running environment. $new\_scope\_pack\_spec$ also creates a new package in the package environment
with the $zmod$ field identifying the name of the current Z module.
}\epar

=SPCZ Empty_Package
=TEX

=SPCZ new_scope_pack_spec
=TEX


\subsection{The SID function new\_scope\_pack\_body}

\bpar{
On encountering a package body the SID function $new\_scope\_pack\_body$ adds a new block to the running environment
which contains the variables from the package specification;
these are visible to the package body
and must therefore be made available for VC generation.
}\epar





\bpar*{
$new\_scope\_pack\_body$ makes the Z module that was current when the package specification was encountered
a parent of the current module. This makes the constants and types and any supporting Z paragraphs of the
package available for use in developing the package body.
This also makes any Z modules associated with the {\tt with} clause of the package specification become
ancestors of the current module.
}\epar*

=SPCZ new_scope_pack_body
=TEX

\newpage

\subsection{The SID function new\_scope\_with}

\bpar{
On encountering a {\tt with} clause the SID function $new\_scope\_with$ adds a new block to the running environment
which contains the variables and formal procedures from the package specification; the {\tt with} clause
makes these visible and must therefore be made available for VC generation.
$new\_scope\_with$ also outputs the Z translation of the
constants and types and Z axiomatic descriptions of the functions in the package specification to the Z document.
However in SPARK there are no {\tt use} clauses.
This means that all the identifiers declared in the package
specification must be prefixed with the package name.
This must be done before the new block is added to the environment and before the
translation of the constants and types and the construction of the Z axiomatic descriptions.
}\epar


\bpar{
The following function $new\_ids$ finds the new identifiers declared in a package specification
which need prefixing.
The function $prefix$ (below $new\_ids$) carries out this prefixing.
Every identifier in its third argument (a package specification)
that appears in its second argument (the new identifiers calculated by $new\_ids$)
is prefixed by its first argument (the name of the package).
The function $prefix$ must also prefix any attributes of the identifiers calculated by $new\_ids$.
Also the Z identifiers corresponding to those calculated by $new\_ids$ that appear in
the specification statements (including attributes, initial variables and
record update functions) must be prefixed.
Finally, in addition to the identifiers calculated by $new\_ids$,
any occurrence of an auxiliary variable must be prefixed (including initial
variables).
}\epar

\bpar*{
As an example consider the package specification from [1]:
}\epar*



\begin{verbatim}
         package PACK_P is
            I : INTEGER;
            type COLOUR is (RED, BLUE, GREEN);
            procedure SQRT (X : INTEGER; Y : out INTEGER)
\end{verbatim}
\hspace*{2.5cm} $\Delta\ Y\ [X \geq 0,\ \ Y**2 \leq X < (Y + 1)**2]$;
\begin{verbatim}
            procedure CUBE_ROOT (N : in out INTEGER)
\end{verbatim}
\hspace*{2.5cm}  $\Delta\ N\ [N \geq 0,\ \ N**3 \leq N_0 < (N + 1)**3]$;
\begin{verbatim}
            function NEXT_COLOUR (C : COLOUR) return COLOUR
\end{verbatim}
\hspace*{2.5cm} $\Xi$ \\
\hspace*{2.5cm} $[true,$ \\
\hspace*{2.5cm} $C \neq COLOURoLAST \land$ \\
\hspace*{2.5cm} $NEXT\_COLOUR(C) = COLOURoSUCC(C)$ \\
\hspace*{2.5cm} $\lor$ \\
\hspace*{2.5cm} $C = COLOURoLAST \land$ \\
\hspace*{2.5cm} $NEXT\_COLOUR(C) = COLOURoFIRST]$;
\begin{verbatim}
            function PLUS_ONE (X : INTEGER) return INTEGER;
         end PACK_P;
\end{verbatim}

\bpar*{
The function $new\_ids$ gives: \\
\ \\
\{ {\tt I, COLOUR, RED, BLUE, GREEN, SQRT, CUBE\_ROOT, NEXT\_COLOUR, PLUS\_ONE} \} \\
\ \\
Note how the names of the formal parameters are not recorded since these can not be referred to outside the package.
The function $prefix$ on the above package specification therefore gives:
}\epar*



\begin{verbatim}
         package PACK_P is
            PACK_P.I : INTEGER;
            type PACK_P.COLOUR is (PACK_P.RED, PACK_P.BLUE, PACK_P.GREEN);
            procedure PACK_P.SQRT (X : INTEGER; Y : out INTEGER)
\end{verbatim}
\hspace*{2.5cm} $\Delta\ Y\ [X \geq 0,\ \ Y**2 \leq X < (Y + 1)**2]$;
\begin{verbatim}
            procedure PACK_P.CUBE_ROOT (N : in out INTEGER)
\end{verbatim}
\hspace*{2.5cm}  $\Delta\ N\ [N \geq 0,\ \ N**3 \leq N_0 < (N + 1)**3]$;
\begin{verbatim}
            function PACK_P.NEXT_COLOUR (C : PACK_P.COLOUR) return PACK_P.COLOUR
\end{verbatim}
\hspace*{2.5cm} $\Xi$ \\
\hspace*{2.5cm} $[true,$ \\
\hspace*{2.5cm} $C \neq PACK\_Po\_COLOURoLAST \land$ \\
\hspace*{2.5cm} $PACK\_Po\_NEXT\_COLOUR(C) = PACK\_Po\_COLOURoSUCC(C)$ \\
\hspace*{2.5cm} $\lor$ \\
\hspace*{2.5cm} $C = PACK\_Po\_COLOURoLAST \land$ \\
\hspace*{2.5cm} $PACK\_Po\_NEXT\_COLOUR(C) = PACK\_Po\_COLOURoFIRST]$;
\begin{verbatim}
            function PACK_P.PLUS_ONE (X : INTEGER) return INTEGER;
         end PACK_P;
\end{verbatim}
  
\bpar{
The formal specifications of $new\_ids$, $prefix$, $z\_prefix$ and $new\_scope\_with$.
}\epar

=SPCZ new_ids
=TEX

=SPCZ prefix
=TEX

\bpar*{
The function $z\_prefix$ is the analogue of $prefix$ for a Z module.
It is intended to indicate the generation of the sequence of paragraphs required to produce
a Z module obtained from another Z module by prefixing all the indicated names with the package name.
In $new\_scope\_with$ the (prefixed) Z translations of the functions in the package are appended to
the resulting Z module and the result is inserted at the beginning of the Z document.
The position of the Z parents paragraph identifies for traceability purposes the point in the
Z document at which the new module was produced.
}\epar*

=SPCZ z_prefix
=TEX


\bpar*{
We now have all the supporting functions we need to specify the SID function {\it new\_scope\_with}.
By the conventions described in section~\ref{ErrorPolicy}, the first condition in the predicate of
{\it new\_scope\_with} means that processing continues without generating any Z if a package
that has not been processed is named in a {\tt with} clause
This allows for example, input-output packages to be used informally in a
literate script and to be available for the compilation of the extracted
SPARK program.

However, this does raise a potential soundness problem. The program that has the
{\tt with} clause could generate VCs that reference things in the package.
Another part of the literate script could generate Z entities of the same
name which could be (incorrectly) used to prove the VCs.
This problem should be caught because the Z document will not type-check
(two occurrences of the same name), but $new\_scope\_with$ could cause
the problem if the mapping of Ada names to Z names allowed it to.
The mapping must ensure that the Z names for entities defined in
a package can not be generated from elsewhere in the literate script.
This is achieved in the current implementation
by translating the dot in a package selection to a lower case `o' while translating letters in Ada names
into upper case.

The second condition in the predicate of {\it new\_scope\_with} means that
a package may be named more than once in a context clause.
The second and subsequent occurrences will be ignored.
}\epar*

=SPCZ new_scope_with
=TEX


\subsection{The SID function update\_envs\_pack\_spec}
\bpar{
The SID function {\it update\_envs\_pack\_spec}
mimics the functionality of {\it new\_scope\_with}
when a package specification is encountered inside a package
or subprogram body. The prefixed Z paragraphs for the
inner package are added to the current Z module and the prefixed
variables and procedures of the package are added to the resulting environment.


The formal definition of {\it update\_envs\_pack\_spec} is as follows:
}\epar

=SPCZ update_envs_pack_spec
=TEX




\subsection{The SID function end\_scope\_comp\_unit}

\bpar{
At the start of each literate script the running environment
$ENV$ is set to $ENV0$ which contains a single block (as described in subsection 3.5).
At the end of each compilation unit $ENV$ must revert back to a single block;
this is carried out by the SID function $end\_scope\_comp\_unit$.
The SID function $end\_scope$ can not be used because many new blocks could have been opened as a result of a {\tt with} clause
of the compilation unit.
}\epar  

=SPCZ end_scope_comp_unit
=TEX


\subsection{The SID function aux\_var}

\bpar{
The global variable $AUX\_VAR$ holds the current auxiliary variable declaration.
}\epar

=SPCZ AUX_VAR
=TEX

\bpar{
On encountering an auxiliary variable declaration, the SID function $aux\_var$ adds the declaration
to the package specification environment.
}\epar


=SPCZ aux_var
=TEX


\subsection{The SID function using\_dec}

\bpar{
The global variable $USING\_DEC$ holds the current {\it using} declaration.
It needs to hold the following information: \\
1. $aux$:  the auxiliary variable that is being made concrete (appears between the key
words {\it implement} and {\it by}). \\
2. $concrete\_vars$:  the Ada variables introduced to implement the auxiliary variable.
These variable declarations will appear among the declarations between the key words {\it using}
and {\it implement} (the other declarations, if any, will be constant, type or subtype declarations). The variable declarations are
represented abstractly as the {\tt \itshape Var\_Decl}s resulting from the
SID function {\tt\itshape adj\_var\_decl} called when the concrete variable declaration
was processed. \\
3. $invariant$:  the relationship between the auxiliary and concrete variables (it appears after
the key word {\it by}). 
}\epar

=SPCZ USING_DEC
=TEX


\bpar{
On encountering a {\it using} declaration, the SID function $using\_dec$ adds the declaration
to the running environment.
}\epar

=SPCZ using_dec
=TEX


\subsection{The SID function vcs\_aux\_initial}



\bpar{
The SID function $vcs\_aux\_initial$
outputs VCs demanding that elaboration of the package body will obtain values for the package
variables that satisfy all the invariants introduced in the {\it using} clauses of the package body.
According to the Ada rules for elaboration of a package body, the values of the variables are
established by first elaborating the variable declarations and then executing the sequence of
statements comprising the package initialization.
Elaboration of the variable declarations means each variable declared in the package with an
initial values is equal to that value. The VCs must therefore demand that execution of the package
initialization (or a null statement if there is no package initialization)
achieves the invariants given a precondition asserting these equalities. 
}\epar

=SPCZ vcs_aux_initial
=TEX


\section{SPARK renaming declarations and use clauses ({\it renaming\_declaration ,  use\_clause})}

\subsection{SID functions}

\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
renaming\_declaration = \\
        function operator\_symbol formal\_part return type\_mark renames 
        simple\_name dot operator\_symbol semi, \\
        procedure\_specification\_1 renames name $< renames\_proc >$ semi, \\
        function\_specification\_1 renames name $< renames\_fun>$ semi \\
        function\_specification\_1 renames name dot operator\_symbol $< renames\_opsym>$ semi \\
        identifier colon type\_mark renames name $<renames\_object>$ semi \\
        package identifier $<new\_scope\_pack\_spec>$  renames name
            $<renames\_pack> $ $<end\_scope>$  $<update\_envs\_pack\_spec>$ semi;
}\epar

\bpar*{
use\_clause =\\
        use\_package\_clause, \\
       use\_type\_clause;\\
\\
use\_package\_clause =\\
        with use\_name\_list semi; \\
\ \\
use\_name\_list = \\
use\_name $< use\_pack >$, \\
use\_name $< use\_pack >$ comma use\_name\_list;\\
 \\
use\_name = simple\_name;
}\epar*

\subsection{The SID function renames\_proc}

\bpar{
In a renaming declaration referring to a procedure via an expanded name such as \\
\ \\
{\tt procedure P (X : out INTEGER) renames PACK.Q} \\
\ \\
the global variable $RENAMES\_NEW$ holds the new name, in this case {\tt P}.
The global variable $RENAMES\_OLD$ holds the old name, in this case
{\tt PACK.Q}; the component $pack$ holds {\tt PACK} and $old$ holds {\tt Q}.
In a renaming declaration referring to a procedure via a simple name such as \\
\ \\
{\tt procedure P (X : out INTEGER) renames Q} \\
\ \\
the global variable $RENAMES\_NEW$ holds the new name, in this case {\tt P}.
The global variable $RENAMES\_OLD$ holds the old name, in this case
{\tt Q}; the component $pack$ is {\it Nil} and $old$ holds {\tt Q}.
 
The formal parameter specifications in $RENAMES\_NEW$ are  not used in
this Z specification for procedures. However, the tool
must use the new formal parameter specifications when interpreting named
parameter associations in calls of the procedure via its new name.

}\epar

=SPCZ RENAMES_OLD
=TEX

=SPCZ RENAMES_NEW
=TEX


\bpar{
If the procedure being renamed is a formal procedure, that is if its declaration
includes a specification statement, then the renamed procedure can be treated as
a formal procedure with the same specification statement if {\it pack} is {\it Nil}
or, if {\it pack} is not nil, obtained from the specification statement by prefixing all names
with the name of the package containing the formal procedure.
If the renaming declaration occurs inside a package specification then we add the
new formal procedure to the package environment, otherwise we add it to the running environment.
}\epar

=SPCZ renames_proc_common
=TEX

=SPCZ renames_proc_pack_spec
=TEX

=SPCZ renames_proc_otherwise
=TEX

=SPCZ renames_proc
=TEX



\subsection{The SID function renames\_fun}
\bpar{
The variables {\it RENAMES\_OLD} and {\it RENAMES\_NEW}
hold the same information for functions as for procedures, assuming some
suitable encoding of operator symbols in the space of Ada identifiers. The new
list of formal parameter specifications is also included in $RENAMES\_NEW$.
This allows for overload resolution in the formal specifications below. The tool
must also use the new formal parameter specifications when interpreting named
parameter associations in calls of the subprogram via its new name.
}\epar

\bpar{
On encountering the renaming of a function,  
the SID function $renames\_fun$ outputs a Z abbreviation definition
linking the two names.
}\epar

=SPCZ renames_fun
=TEX

\subsection{The SID function renames\_opsym}

\bpar{
On encountering the renaming of an operator symbol where the new name is an ordinary
function designator,  
the SID function $renames\_fun$ outputs a Z abbreviation definition
linking the new name with the Z or SPARK toolkit operator that implements the predefined
operator in question.
A package name is required in the syntax in this case, but ignored. This reflects the
fact that the predefined operators are always available and may not be redefined.
Since the operator may be overloaded, we specify the following function to resolve
the overloading (it is total, since the Compliance notation rules and
 Ada type rules together ensure that the overloading will be resolvable).
}\epar

=SPCZ resolve_opsym
=TEX

=SPCZ renames_opsym
=TEX

\subsection{The SID function renames\_object}
\bpar{
On encountering the renaming of an object, we need to know whether the object is a constant
or a variable.  A constant renaming is translated into a Z abbreviation definition.
A variable renaming result in an entry in the {\it var\_renamings} mapping in the running
environment.sending the new name to the name used for the variable in its original
declaration (with a package prefix if appropriate).

The following schema checks whether the old name refers to a variable and if so
sets up {\it zname'} to be the z translation of the original name for the variable
and adds the variable renaming to the current environment.  This function is later
re-used to handle package renamings and use clauses. For those purposes, we need
to be able to rename auxiliary variables as well as program variables and so we need
to treat auxiliary variables and program variables in the same way here.

}\epar
=SPCZ renames_var_common
=TEX

\bpar{
If the variable renaming is in a package specification we must also add the
variable renaming to the package in the package environment.
}\epar

=SPCZ renames_var_pack_spec
=TEX

\bpar{
If the variable renaming is not in a package specification then {\it renames\_var\_common}
has done all that is necessary.
}\epar

=SPCZ renames_var_otherwise
=TEX

=SPCZ renames_var
=TEX

\bpar{
If the object being renamed is a constant, then we output a Z abbreviation defining
the new name to be equal to the old one.
}\epar


=SPCZ renames_const
=TEX
\bpar{
{\it renames\_object} brings the three cases together.
}\epar

=SPCZ renames_object
=TEX
\subsection{The SID function renames\_pack}
\bpar{
In a package renaming $IDENTIFIER$ holds the new name and $RENAMES\_NEW$ holds
the new name.

Package renamings are handled by behaving as if we were declaring a local package called by
the new name, $pack$ say. In this local package declaration, we put a sequence of
basic declarations and renaming declarations for each name $n$, in the original package.
The declaration for $n$ identifies $n$ with $pack.n$.

}\epar
\bpar{

The function {\it rename\_basic\_decl} generates a Z abbreviation definition defining $n$
to be equal to $pack.n$, which is all that needs to be done for types and constants.
The function {\it rename\_formal\_fun} does the same for a formal function.

}\epar

=SPCZ rename_basic_decl
=TEX

=SPCZ rename_formal_fun
\bpar{

We now define schemas that iterate earlier operations over the various constituents
of a package. The SID function {\it renames\_pack} will be the sequential composition
of these.

}\epar

=SPCZ renames_pack_consts_types_funs
=TEX

=SPCZ renames_pack_procs
=TEX

=SPCZ renames_pack_vars
=TEX


For auxiliary variables, we need a function that turns a Z identifier into an equivalent
program identifier.

=SPCZ untrans_id
=TEX

=SPCZ renames_pack_aux_vars
=TEX

\bpar{

We can now define {\it renames\_pack} as the sequential composition of the above.
It must be treated as an error if the package is not found in the package environment.
}\epar

=SPCZ renames_pack
=TEX

\subsection{The SID functions use\_pack}
\bpar{

The SID function $use\_pack$ handles an individual package name in a use clause
(not a use type clause). It turns out to be identical with {\it renames\_pack}.
The only difference is that {\it new\_scope\_pack\_spec} has not been called
so that the declarations go into the running environment (and possiblty the
package environment if the use clause is within a package declaration).

}\epar

=SPCZ use_pack
=TEX

\section{SPARK stubs and subunits ({\it body\_stub})}

\subsection{SID functions}


\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
body\_stub = \\ 
$< begin\_stub >$ procedure\_specification is separate semi $<update\_envs\_proc>$ \\
 $< add\_proc\_env >$ $< end\_scope >$ $< end\_stub >$, \\
$< begin\_stub >$ function\_specification is separate semi $< end\_scope >$ $< end\_stub >$, \\
package bbody simple\_name $<pack\_stub>$ is separate semi, \\
procedure\_specification semi, \\
function\_specification semi; \\
\ \\
proper\_body = \\
subprogram\_body, \\
pbody\_kslot $<pack\_stub>$; \\
\ \\
subunit = \\
separate ord name $< new\_scope\_subunit >$ crd proper\_body $< end\_scope >$, \\
separate ord name $< new\_scope\_subunit >$ crd package\_body $< end\_scope >$;
}\epar

\subsection{The SID function begin\_stub}

\bpar{
On encountering a subprogram stub the SID function $begin\_stub$ sets $stub\_flag$ in the running environment to $True$.
}\epar

=SPCZ begin_stub
=TEX


\subsection{The SID function end\_stub}

\bpar{
At the end of a subprogram stub the SID function $end\_stub$ sets $stub\_flag$ to $False$.
}\epar

=SPCZ end_stub
=TEX

\subsection{The SID function new\_scope\_subunit}



\bpar{
When a SPARK subunit is encountered a Z module is output corresponding to the Z document at the
point where the stub was encountered.
The Z specification of this process appears in the sections
on SPARK functions and procedures since the name of the subprogram is required before the subunit
environment can be accessed. Consequently the SID function $new\_scope\_subunit$ below sets the flags but does
not output the Z module.
}\epar

=SPCZ new_scope_subunit
=TEX

\subsection{The SID function pack\_stub}

\bpar{
The SID function {\it pack\_stub} is the analogue of {\it stub} for package stubs
and package k-slots. 

{\it IDENT} holds the name of the inner package.
}\epar

=SPCZ pack_stub
=TEX

\section{Web clauses ({\it web\_clause})}

\subsection{SID functions}



\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
web\_clause = \\
z $< z\_copy >$, \\
compilation, \\
comp\_label replacedby compilation, \\
ppart\_label $< new\_scope\_dec\_replace >$ replacedby private\_part \\
$< update\_envs\_remove\_declabel >$ $< end\_scope >$, \\
vpart\_label $< new\_scope\_dec\_replace >$ replacedby visible\_part \\
$< update\_envs\_remove\_declabel >$ $< end\_scope >$, \\
dec\_label $< new\_scope\_dec\_replace >$ replacedby dec dp1 \\
$< update\_envs\_remove\_declabel >$ $< end\_scope >$, \\
stmt\_label $< new\_scope\_stmt\_label >$ replacedby sequence\_of\_statements \\
$< end\_scope\_stmt\_label >$, \\
spec\_label $< new\_scope\_speclabel >$ refinedby sequence\_of\_statements \\
$< vcs\_speclabel >$ $< end\_scope\_speclabel >$, \\
$< new\_scope\_speclabel >$ refinedby sequence\_of\_statements \\
$< vcs\_speclabel >$ $< end\_scope\_speclabel >$, \\
spec\_label $< new\_scope\_speclabel >$ replacedby sequence\_of\_statements \\
$< end\_scope\_speclabel >$, \\
$< new\_scope\_speclabel >$ replacedby sequence\_of\_statements $< end\_scope\_speclabel >$, \\
any\_label arbitrary\_ada, \\
arbitrary\_ada, \\
ord name $<new\_scope\_subunit>$ crd replacedby package\_body;
}\epar

\subsection{The SID function z\_copy}

\bpar{
The global variable $ZPARA$ holds the current Z paragraph.
}\epar

=SPCZ ZPARA
=TEX


\bpar{
Z paragraphs that appear in the literate script are simply copied into the Z document; this is carried out by the SID
function $z\_copy$.
}\epar

=SPCZ z_copy
=TEX

\subsection{The SID function new\_scope\_dec\_replace}

\bpar{
When a dec label is expanded the SID function $new\_scope\_dec\_replace$ adds a new block to the running environment
which basically holds all the information that was present when the original k\_slot was encountered.
}\epar

=SPCZ new_scope_dec_replace
=TEX


\subsection{The SID function update\_envs\_remove\_declabel}

\bpar{
The SID function $update\_envs\_remove\_declabel$
removes the dec label from subunit, dec label and spec label environments (all three need updating) once the
dec label has been expanded.
}\epar 

=SPCZ update_subunit_env_remove_declabel
=TEX

=SPCZ update_dec_env_remove_declabel
=TEX

=SPCZ update_spec_env_remove_declabel
=TEX

=SPCZ update_envs_remove_declabel
=TEX


\subsection{The SID function new\_scope\_speclabel}

\bpar{
When a spec label is being refined or simply expanded the SID function $new\_scope\_speclabel$ adds a new block
to the running environment and makes a record of the spec label; the information in the spec label environment can then
be accessed as the sequence of statements is processed.
}\epar

=SPCZ new_scope_speclabel
=TEX

\subsection{The SID function vcs\_speclabel}

\bpar{
The SID function $vcs\_speclabel$ outputs VCs demanding that the sequence of statements is a refinement of the specification
statement denoted by the spec label.
}\epar

=SPCZ vcs_speclabel
=TEX


\subsection{The SID function end\_scope\_speclabel}

\bpar{
After the spec label has been refined or expanded the SID function $end\_scope\_speclabel$ removes the block
from the running environment that was opened when the spec label was encountered ($new\_scope\_speclabel$)
and also removes the spec label from the spec label environment.
}\epar

=SPCZ end_scope_speclabel
=TEX


\subsection{The SID functions new\_scope\_stmt\_label and end\_scope\_stmt\_label}

\bpar{
Expansion of stmt labels is treated the same as the expansion of spec labels.
}\epar

=SPCZ new_scope_stmt_label
=TEX

=SPCZ end_scope_stmt_label
=TEX


\section{Informal parts of the specification}

\subsection{Checks}

\bpar{
The compliance notation tool must make the following soundness checks.
The numbering is not sequential for historical reasons.
}\epar


\bpar*{
1. When calling the function $vcs$ with a $Speclab$ and sequence of statements $st$: \\
\ \\
(a) The variables that may be changed in $st$ must be a subset of the frame
in the $Spec$ of $Speclab$. The variables that may be changed by a
sequence of statements may be determined as follows:
(a) an assignment statement may change the variable in its left-hand side;
(b) a specification statement may change the variables in its frame;
(c) a procedure call may change the variables obtained by substitution of actual parameters
for formal parameters in the frame of its specification statement and the global variables in the frame. \\
\ \\
(b) if $st$ contains a {\tt return} statement then $formal\_body\_flag$ must be $True$. \\
\ \\
(c) if $st$ contains an {\tt exit} statement then $till\_flag$ must be $True$. \\
\ \\
(d) Any procedure call in $st$ must have a corresponding $Formal\_Proc$ in the $Speclab$.
(e)  {\it st}  must not contain a block statement. (A block statement is only handled
formally if it appears as the only statement on the right-hand side of a refinement or replacement step).
}\epar*



\bpar*{
2. The Ada program extracted from the literate script must compile
and the Z document produced must type-check.
If the extracted program contains k\_slots and specification statements that have not been expanded
or refined then these can simply be removed or replaced with {\tt null} whichever is appropriate.
Also an {\it auxiliary} variable declaration (in a package specification)
is simply removed, and a {\it using} declaration (in a package body)
is replaced by the Ada declarations between the key words {\it using}
and {\it implement}. (This is a slight diversion to [3] where the
Ada declarations replace the auxiliary variable declaration.)
Any {\it references} clauses must be removed.
The program can then be compiled.
Also the extracted SPARK program must retain any legal SPARK annotations
that were in the literate script.
}\epar*

\bpar*{
3. The closest-containing compound statement of an {\tt exit\ when\ G} statement must be a loop statement.
Also the closest-containing compound statement of an {\tt exit} statement (no condition {\tt G})
must be an {\tt if} statement with no {\tt elsif} or {\tt else} parts; the closest-containing compound statement
of this {\tt if} statement must be a loop and the {\tt exit} statement must be the last statement inside the
{\tt if} statement. (SPARK restrictions for {\tt exit} statements). \\
\ \\
4. A {\tt return} statement is only allowed within the body of a function subprogram.
The last statement in the body of a function must be either a {\tt return} statement or a {\tt case} statement
whose alternatives all end with {\tt return} statements. {\tt return} statements are not allowed anywhere else.
(SPARK restrictions for {\tt return} statements.)
}\epar*

\bpar*{
5. If a subprogram has a subprogram declaration before its subprogram implementation and both of the 
subprogram specifications contain a specification statement, then the two specification statements
must be identical.
}\epar*

\bpar*{
13. Semantic checks mentioned in the compliance notation syntax (appendix A).
}\epar*

\bpar*{
14. A SPARK subtype declaration with a range constraint such as
{\tt subtype WEEKDAY is DAY range MON .. FRI;} must not give rise to the
subtype being translated into Z as an empty range.
The problem can only arise in the schemas
$Basic\_Decl\_Subtype\_\-Range\_Con\_1$ and
$Basic\_Decl\_Int\_Type$
in volume 3 (a subtype declaration of a real type with a range constraint
is {\it not} translated as a Z range and so can not cause a problem).
A check must be made that the bounds of the range are static and that the
upper bound is not less than the lower bound.
}\epar*

\bpar*{
15. When renaming an operator symbol a check must be made that the new
name is the same as the old name (minus the package name). For example
$<=$ must not be allowed to rename {\tt PACK.$>=$}.
No checks are required for the renaming of subprograms.
}\epar*

\bpar*{
16. The arbitrary replacement feature (see arbitrary\_ada in the syntax
of appendix A)
can violate soundness because no
check is made on what the arbitrary text consists of.
A warning must be given to this effect. 
}\epar*



\bpar*{
17. Each literate script should contain at most one compilation unit.
}\epar*

\bpar*{
18. When an Ada expression is translated into Z, an error should be
reported if the expression mentions an informal function (even if the
resulting translation would be well-typed Z).
}\epar*

\bpar*{
19. All variables in the frame of a specification statement must be in scope when the specification
statement is introduced. This check applies both to specification statements appearing as statements
and to specification statements in procedure headers.
Function specification statements have an empty frame and so do not require this check.
}\epar*



\bpar*{
20. In a sequence of statements appearing on the right of the refinement symbol ($\sqsubseteq$),
the use of the following four statement forms is restricted:
\begin{itemize}
\item specification statement containing initial variables
\item logical constant statements
\item call of a procedure whose specification contains initial variables
\item for-loops whose bounds are not static expressions
\end{itemize}
Such statements may only appear in a position which is {\it suitable} in the
following sense:
\begin{itemize}
\item the first statement in a sequence is suitable.
\item the first statement in a branch of a conditional statement which is itself in a suitable position is also suitable.
\end{itemize}
}\epar*
\bpar*{
This ensures that no statement with side effects can be executed before the statement in question.
}\epar*


\bpar*{
21. In the implementations of the schemas $form\_subunit$ and $form\_fun\_pack\_body$,
if VCs are to be generated, it is an error if the global dependency list of the current
formal function is different from the global dependency list in the corresponding
formal function in the stub or package specification.
}\epar*


\bpar*{
22. In the implementations of the schemas $form\_fun\_pack\_body\_aux$,
if VCs are to be generated, it is an error if the global dependency list of the current
formal function is not contained in the set {\it conc\_ids} of global dependencies
deduced from the corresponding formal function in the package specification.
}\epar*


\subsection{For loop variables and logical constants}

\bpar{
When a refinement step is encountered in a literate script, all the variables appearing in the sequence of statements
should have already been declared.
The declarations are needed in the VCs for the refinement step;
they appear as local declarations in the VCs.
In particular if the sequence of statements contains a {\tt for} loop then the {\tt for} loop variable
will be needed in the local declarations of the VCs.
However at the point the refinement step is encountered the {\tt for} loop variable will not have been declared
since it is declared on encountering the {\tt for} loop {\it statement}.
The {\tt for} loop variable will therefore not be in the environment and so will be missing from the VCs;
this will result in the VCs not type-checking (variable undeclared).
The solution is to gather up the {\tt for} loop variable into the environment as the sequence of statements
is processed.
}\epar

\bpar{
Note that for subsequent refinements of the {\tt for} loop {\it body} there is not a problem
since at that point the {\tt for} loop variable has already been declared.
The problem arises for the refinement step in which the {\tt for} loop is first introduced.
}\epar

\bpar{
A similar problem arises for logical constants.
}\epar

\bpar{
The above problem with {\tt for} loop variables
can be solved by adding an extra component,
say $current\_for\_vars$, to $Block$ to hold the
{\tt for} loop variables.
The component will be in $Block$ but not in $In\_Scope$; a similar status
therefore as $current\_formal\_proc$ for example.
The SID function $for\_param$ (in the section on SPARK loops), in addition
to what it does already, must add the {\tt for} loop variable to
the $current\_for\_vars$ component of $Block_2$ (since $for\_param$ is called
after $new\_scope\_loop$).
At the end of the sequence of statements, all the {\tt for} loop variables
will be in the $current\_for\_vars$ component of $Block_1$ (since the blocks
for the {\tt for} loops will have been closed by this stage).
The $current\_for\_vars$ then need to be added to the $vc\_pars$ component
of the $Speclab$ that is used in the call of $vcs$ in the SID functions
$vcs\_body$, $vcs\_aux\_initial$ and $vcs\_speclabel$.
The $current\_for\_vars$ component must be initialised to empty in the
SID functions that start a new scope for formal subprogram bodies
($new\_scope\_proc\_form$ and $new\_scope\_fun\_form$),
package bodies ($new\_scope\_pack\_\-body$) and
refinement steps ($new\_scope\_speclabel$). 
}\epar

\bpar{
The problem with logical constants is solved by
adding an extra component,
say\\
$current\_log\_cons$, to $Block$ to hold the logical constants.
Again the component will be in $Block$ but not in $In\_Scope$.
The SID function $add\_log\_con\_env$ (in the section on SPARK statements),
in addition to what it does already, must add the logical constant to
the $current\_log\_cons$ component of $Block_1$ (since no new block
is opened for logical constants).
At the end of the sequence of statements, all the logical constants
will be in the $current\_log\_cons$ component of $Block_1$.
The $current\_log\_cons$ then need to be added to the $vc\_log\_cons$ component
of the $Speclab$ that is used in the call of $vcs$ in the SID functions
$vcs\_body$, $vcs\_aux\_initial$ and $vcs\_speclabel$.
The $current\_log\_cons$ component must be initialised to empty in the
SID functions that start a new scope for formal subprogram bodies
($new\_scope\_proc\_form$ and $new\_scope\_fun\_form$),
package bodies\\
($new\_scope\_pack\_body$) and
refinement steps ($new\_scope\_speclabel$).
}\epar



\subsection{Syntax --- k\_slots as annotations}

\bpar{
Wherever a SPARK annotation is permitted, a k\_slot
may be used to defer the actual text of the annotation.
}\epar

\subsection{Syntax --- subprogram calls}
\bpar{
Both named and positional parameter associations are permitted in subprogram
calls. A subprogram call may not contain both named and positional parameter associations.
}\epar

\bpar{
Default expressions are permitted in parameter specifications and corresponding actual parameters
that are not specified explicitly in a subprogram call are taken to be specified implicitly by the
default expressions. Default expressions
must be constant expressions, i.e., their translation into Z must contain no variables.
}\epar

\nocite{DRA/CIS/CSE3/SWI/WP/7/2}		% was {example}
\nocite{Sennett92a}			% was {notation}
\nocite{DRA/CIS/CSE3/SWI/1}		% was {aux}
\nocite{Foster68}				% was {sid}
\nocite{DRA/CIS(SE2)/PROJ/SWI/TR/1/1.0}	% was {user}
\nocite{zstan26}				% was {zstandard}

\bibliographystyle{fmu}
\bibliography{daz,fmu}


\begin{tabular}{ll}
\multicolumn{2}{l}{The Draft Z Standard \cite{zstan26} is available via the Internet from:}\\
			&	{\tt http://www-users.cs.york.ac.uk/~ian/zstan/}\\
\hbox to 2.5cm{\hfill or\hfill}	&	{\tt ftp://ftp.cs.york.ac.uk/hise\_reports/cadiz/ZSTAN/}
\end{tabular}

\startappendix
{ %%%% start of special set up for SID syntax
\twocolumn[\section{Compliance notation syntax}]
\makeatletter
\def\prelim@label#1{\relax}
\def\@Zfonts{\global\let\FTfonts\mathtt}
\vertbarfalse
\ftlinepenalty=9999
\ftlmargin=0em
\makeatother
The BASICS section of the SID grammar lists the terminal symbols
of the grammar.
=GFT SID
BASICS
abs
ampersand
and
arbitrary_ada
array
at
auxiliary
auxiliary_expression
bar
bbody
becomes
begin
by
case
character_literal
colon
comma
commagoesto
commaothers
comp_label
con
constant
crd
dec_label
delta
digits
div
dot
dotdot
else
elsif
end
equals
exit
fatdot
for
function
function_name
function_specification_statement
goesto
greaterequals
greaterthan
identifier
if
implement
in
is
k_slot
lessequals
lessgreat
lessthan
limited
loop
minus
mod
na  # look ahead symbol #
not
notequals
null
numeric_literal
of
or
ord
others
out
package
pbody_kslot
plus
ppart_label
ppragma
prime
private
procedure
procedure_name
procedure_specification_statement
record
references
refinedby
rem
renames
replacedby
return
reverse
rrange
semi
separate
specification_statement
spec_label
star
starstar
stmt_label
string_literal
subtype
then
till 
type
type_mark
use
using
vpart_label
when
whenothers
while
with
xor
z
z_decl
z_id
z_pred
=TEX
\newpage
\onecolumn
The RULES section of the SID grammar gives the
production rules.
The rules are indexed by references to sections in the
Ada Language Reference Manual (ALRM, \cite{AJPO83}).
=GFT SID
RULES

# identifiers and literals treated lexically #
=TEX

=GFT SID
# ALRM 2.8 #
pragma = ppragma identifier semi,
	 ppragma identifier ord argument_association arg_ass_list crd semi;

arg_ass_list = $,
	       comma argument_association arg_ass_list;

argument_association = name,
		       identifier goesto name,
		       expression,
		       identifier goesto expression;
=TEX

=GFT SID
# ALRM 2.8 #
pragma = ppragma identifier semi,
	 ppragma identifier ord argument_association arg_ass_list crd semi;

arg_ass_list = $,
	       comma argument_association arg_ass_list;

argument_association = name,
		       identifier goesto name,
		       expression,
		       identifier goesto expression;
=TEX 

=GFT SID
# ALRM 3.1 #
basic_declaration =
	object_declaration,
	type_declaration,
	subtype_declaration,
	deferred_constant_declaration,
	pragma;
=TEX 

=GFT SID
# ALRM 3.2 #
object_declaration =
	constant_declaration,
	variable_declaration;

constant_declaration =
      identifier_list colon constant subtype_indication becomes expression semi,
      identifier_list colon constant becomes expression semi;

variable_declaration =
      identifier_list colon subtype_indication semi,
      identifier_list colon subtype_indication becomes expression semi;

identifier_list = identifier id_list;

id_list = $, comma identifier_list;
=TEX 

=GFT SID
# ALRM 3.3.1 #
type_declaration = 
	full_type_declaration,
	private_type_declaration;

full_type_declaration =
	type identifier discriminant_part_opt is type_definition semi;

discriminant_part_opt = $,
	discriminant_part;

type_definition =
	enumeration_type_definition,
	integer_type_definition,
	real_type_definition,
	array_type_definition,
	record_type_definition;
=TEX 

=GFT SID
# ALRM 3.3.2 #
subtype_declaration =
	subtype identifier is subtype_indication semi;

subtype_indication =
	type_mark constraint,
	type_mark;

# type_mark = name #
=TEX 

=GFT SID
# ALRM 3.5 #
constraint =
	range_constraint,
	floating_point_constraint,
	fixed_point_constraint,
	index_constraint,
	discriminant_constraint;

range_constraint = rrange range;

range =
	simple_expression,
	simple_expression dotdot simple_expression;
#        attribute,
	simple_expression dotdot simple_expression;
(attribute is covered in simple_expression)
#
=TEX 

=GFT SID
# ALRM 3.5.1 #
enumeration_type_definition = ord identifier_list crd;
=TEX 

=GFT SID
# ALRM 3.5.4 #
integer_type_definition = range_constraint;
=TEX 

=GFT SID
# ALRM 3.5.6 #
real_type_definition =
	floating_point_constraint,
	fixed_point_constraint;
=TEX 

=GFT SID
# ALRM 3.5.7 #
floating_point_constraint =
	floating_accuracy_definition,
	floating_accuracy_definition range_constraint;

floating_accuracy_definition = digits simple_expression;
=TEX 

=GFT SID
# ALRM 3.5.9 #
fixed_point_constraint =
	fixed_accuracy_definition,
	fixed_accuracy_definition range_constraint;

fixed_accuracy_definition = delta simple_expression;
=TEX 

=GFT SID
# ALRM 3.6 #
array_type_definition =
	unconstrained_array_definition,
	constrained_array_definition;

unconstrained_array_definition =
	array ord index_subtype_definition_list crd of type_mark;

constrained_array_definition =
	array index_constraint of type_mark;

index_subtype_definition_list = index_subtype_definition subtype_list;

subtype_list =
	$,
	comma index_subtype_definition_list;

index_subtype_definition = type_mark rrange lessgreat;

index_constraint = ord discrete_range_list crd;

discrete_range_list = discrete_range disc_ran_list;

disc_ran_list = $,
		  comma, discrete_range_list;

discrete_range =
	type_mark,
	type_mark range_constraint,
	range;
=TEX 

=GFT SID
# ALRM 3.7 #
record_type_definition = record component_list end record;

component_list = component_declaration,
		 component_declaration component_list;

component_declaration = identifier_list colon subtype_indication semi;
=TEX 

=GFT SID
# ALRM 3.7.1 #
discriminant_part =
	ord discriminant_specification_list crd;

discriminant_specification_list =
	discriminant_specification,
	discriminant_specification discriminant_specification_list;

discriminant_specification =
	identifier_list colon type_mark,
	identifier_list colon type_mark becomes expression semi;
=TEX 

=GFT SID
# ALRM 3.7.2 #
discriminant_constraint =
	ord parameter_association crd;
=TEX 

=GFT SID
# ALRM 3.9 #
declarative_part = dec dp1;

dp1 = $, dec dp1;

dec = 
	k_slot,
	renaming_declaration,
	basic_declarative_item,
	subprogram_declaration,
	package_declaration,
	body;

# differs from SPARK and Ada syntax in not constraining the
order of basic and later decalarative items #

basic_declarative_item =
	basic_declaration,
	representation_clause,
	use_clause;
body =
	proper_body,
	body_stub;

proper_body = 
	subprogram_body,
	pbody_kslot;
=TEX 

=GFT SID
# ALRM 4.1 #
name =
#        simple_name,
	indexed_component,
	selected_component;
#
	simple_name select;

select = 
	$,
	dot simple_name select,
	ord exp_list crd select;

simple_name = identifier;

prefix =
	name,
	function_call;
=TEX 

=GFT SID
# ALRM 4.1.1 #
# indexed_component = prefix ord expression_list crd;
#
expression_list = expression exp_list;

exp_list =
	$,
	comma expression_list;
#
=TEX 

=GFT SID
# ALRM 4.1.3 #
selected_component = prefix dot selector;

selector = simple_name;
#
=TEX 

=GFT SID
# ALRM 4.1.4 #
attribute =
	prefix prime attribute_designator,
	character_literal prime attribute_designator;

attribute_designator = namexp namexp_list;

namexp_list = 
	$,
	prime attribute_designator;

namexp =
	simple_name,
	simple_name ord expression crd;
=TEX 

=GFT SID
# ALRM 4.3 #
aggregate =
	ord component_association crd,
	ord component_association commaothers goesto expression crd,
	ord others goesto expression crd;

component_association =
	na named_association, #na lookahead symbol for goesto #
	positional_association;

named_association =
	aggregate_choice_list goesto expression ass_list;

ass_list = 
	$,
	comma named_association;

aggregate_choice_list = aggregate_choice ag_list;

ag_list =
	$,
	bar aggregate_choice_list;

aggregate_choice = 
	# simple_expression, (in discrete range) #
	discrete_range;
	#simple_name; (in simple_expression) #

positional_association = expression_list;
=TEX 

=GFT SID
# ALRM 4.4 #
expression = relation reltail;

reltail =
	$,
	and_relation,
	and_then_relation,
	or_relation,
	or_else_relation,
	xor_relation;

and_relation =
	and relation,
	and relation and_relation;

and_then_relation =
	and then relation,
	and then relation and_then_relation;

or_relation =
	or relation,
	or relation or_relation;

or_else_relation =
	or else relation,
	or else relation or_else_relation;

xor_relation =
	xor relation,
	xor relation xor_relation;

relation = simple_expression rel2;

rel2 =
	$,
	relational_operator simple_expression,
	in range,
	not in range,
	in type_mark,
	not in type_mark;

simple_expression =
	term binoptail,
	unary_adding_operator term binoptail;

binoptail =
	$,
	binary_adding_operator term binoptail;

term = factor multoptail;

multoptail =
	$,
	multiplying_operator factor;

factor =
	primary,
	primary starstar primary,
	abs primary,
	not primary;

primary =
	numeric_literal,
	character_literal,
	string_literal,
	name,
	function_call,
	type_conversion,
	qualified_expression,
	attribute,
	ord expression crd,
	auxiliary_expression,
	aggregate;      # aggregate added as a primary to allow #
			#  2-dimensional array aggregates #
=TEX 

=GFT SID
# ALRM 4.5 #
relational_operator =
	equals,
	notequals,
	lessthan,
	lessequals,
	greaterthan,
	greaterequals;

binary_adding_operator =
	plus,
	minus,
	ampersand;

unary_adding_operator =
	plus,
	minus;

multiplying_operator =
	star,
	div,
	mod,
	rem;
=TEX 

=GFT SID
# ALRM 4.6 #
type_conversion = type_mark ord expression crd;
=TEX 

=GFT SID
# ALRM 4.7 #
qualified_expression =
	#type_mark prime ord expression crd
	    - (treat as special case of aggregate) #
	type_mark prime aggregate;
=TEX 

=GFT SID
# ALRM 5.1 #
sequence_of_statements = statement statement_list;

statement_list =
	$,
	sequence_of_statements;

z_decls = z_decl, z_decl semi z_decls;

statement =
	k_slot,
	specification_statement,
	con z_decls fatdot specification_statement,
	simple_statement,
	compound_statement,
	pragma;

simple_statement =
	null_statement,
	assignment_statement,
	procedure_call_statement,
	exit_statement,
	return_statement;

compound_statement =
	if_statement,
	case_statement,
	loop_statement,
	block_statement;

null_statement = null semi;
=TEX 

=GFT SID
# ALRM 5.2 #
assignment_statement = name becomes expression semi;
=TEX 

=GFT SID
# ALRM 5.3 #
if_statement =
      if condition then sequence_of_statements elsif_part else_part end if semi;

elsif_part =
	$,
	elsif condition then sequence_of_statements elsif_part;

else_part =
	$,
	else sequence_of_statements;

condition = expression;
=TEX 

=GFT SID
# ALRM 5.4 #
case_statement =
	case expression is case_statement_alternative_list others_part
	end case semi;

case_statement_alternative_list =
	case_statement_alternative,
	case_statement_alternative case_statement_alternative_list;

case_statement_alternative =
	when case_choice_list goesto sequence_of_statements;

case_choice_list =
	case_choice,
	case_choice bar case_choice_list;

case_choice =
	# simple_expression, (in discrete_range) #
	discrete_range;

others_part =
	$,
	whenothers goesto sequence_of_statements;
=TEX 

=GFT SID
# ALRM 5.5 #
loop_statement =
	name_colon_opt iteration_scheme_opt till_opt loop sequence_of_statements
	end loop name_opt semi;

name_colon_opt =
	$,
	simple_name colon;

name_opt =
	$,
	simple_name;

iteration_scheme_opt =
	$,
	iteration_scheme;

iteration_scheme =
	while condition,
	for loop_parameter_specification;

loop_parameter_specification =
	identifier in type_mark,
	identifier in reverse type_mark,
	identifier in type_mark rrange range,
	identifier in reverse type_mark rrange range
	identifier in range,
	identifier in reverse range;

till_opt =
	$,
	till z_pred;
=TEX 
=GFT SID
# ALRM 5.6 #
block_statement =
	name_colon_opt
	declare declarative_part begin sequence_of_statements end name_opt semi,
	name_colon_opt begin sequence_of_statements end name_opt semi;
=TEX
=GFT SID
# ALRM 5.7 #
exit_statement =
	exit name_opt semi,
	exit name_opt when condition semi;
=TEX 

=GFT SID
# ALRM 5.8 #
return_statement =
	return semi,
	return expression semi;
=TEX 

=GFT SID
# ALRM 6.1 #
subprogram_declaration =
	procedure_specification semi,
	function_specification semi;

# subprogram_specification removed as it was only used in #
# renaming_declaration which now does not use it #

# subprogram_specification = #
#         procedure_specification, #
#         function_specification; #

procedure_specification =
	procedure identifier,
	procedure identifier procedure_specification_statement,
	procedure identifier formal_part,
	procedure identifier formal_part procedure_specification_statement;

function_specification =
	function designator return type_mark,
	function designator return type_mark function_specification_statement,
	function designator formal_part return type_mark,
	function designator formal_part return type_mark
	function_specification_statement;

designator = identifier;

operator_symbol = string_literal;

formal_part = ord parlist crd;

parlist =
	parameter_specification,
	parameter_specification semi parlist;

parameter_specification =
	identifier_list colon mode type_mark;

mode = $, in, out, in out;
=TEX 

=GFT SID
# ALRM 6.3 #
subprogram_body =
	procedure_specification is subprogram_implementation,
	function_specification is subprogram_implementation;

subprogram_implementation = 
	declarative_part begin sequence_of_statements end designator semi;
=TEX 

=GFT SID
# ALRM 6.4 #
procedure_call_statement =
	procedure_name semi,
	procedure_name actual_parameter_part semi;

function_call =
	function_name,
	function_name actual_parameter_part;

actual_parameter_part = ord parameter_association crd;

parameter_association =
	named_parameter_association,
	positional_parameter_association;

named_parameter_association =
	formal_parameter goesto actual_parameter,
	formal_parameter goesto actual_parameter comma 
	named_parameter_association;

positional_parameter_association =
	actual_parameter,
	actual_parameter comma positional_parameter_association;

formal_parameter = simple_name;

actual_parameter = expression;
# name is part of expression #
=TEX 

=GFT SID
# ALRM 7.1 #
package_declaration = package_specification semi;

package_specification =
	package identifier is visible_part end simple_name,
	package identifier is visible_part private private_part end simple_name;

visible_part =
	$,
	visdec visible_part;

visdec = k_slot,
	 basic_declarative_item,
	 subprogram_declaration,
	 auxiliary z_decl semi,
	 renaming_declaration;

private_part =
	pdec,
	pdec private_part;

pdec =
	k_slot,
	basic_declarative_item,
	renaming_declaration;

package_body =
	package bbody simple_name is package_implementation end simple_name 
	semi;

package_implementation =
	declarative_part,
	declarative_part begin package_initialization,
	using_list declarative_part_1 begin package_initialization;

using_list =
	using_dec,
	using_dec using_list;

using_dec = using basic_dec_list implement z_id by z_pred semi;

basic_dec_list =
	basic_dec,
	basic_dec basic_dec_list;

basic_dec =
	constant_declaration,
	variable_declaration,
	type_declaration,
	subtype_declaration,
	pragma;

declarative_part_1 = dec_1, dec_1 declarative_part_1;

dec_1 =
	renaming_declaration,
	basic_declarative_item,
	package_declaration,
	body;

package_initialization = sequence_of_statements;
=TEX 

=GFT SID
# ALRM 7.4 #
private_type_declaration =
	type identifier discriminant_part_opt is private semi,
	type identifier discriminant_part_opt is limited private semi;

deferred_constant_declaration = identifier_list colon constant type_mark semi;
=TEX 

=GFT SID
# ALRM 8.1; ALRM'95 8.4 #
use_clause =
	use_package_clause,
	use_type_clause;

use_package_clause =
	use name_list semi;

use_type_clause =
	use type name_list semi;
=TEX 

=GFT SID
# ALRM 8.5 #
renaming_declaration =
	identifier colon type_mark renames name semi,
	package identifier renames name semi,
	function operator_symbol formal_part return type_mark renames 
		name dot operator_symbol semi,
	procedure_specification_1 renames name semi,
	function_specification_1 renames name semi,
	function_specification_1 renames name dot operator_symbol semi;

procedure_specification_1 =
	procedure identifier,
	procedure identifier formal_part;

function_specification_1 =
	function designator return type_mark,
	function designator formal_part return type_mark;
=TEX 

=GFT SID
# ALRM 10.1 #
compilation =
	k_slot,
	compilation_unit,
	compilation_unit compilation;

compilation_unit =
	context_clause pragma_list library_unit,
	context_clause pragma_list secondary_unit,
	pragma;

pragma_list = $,
	      pragma pragma_list;

library_unit =
	subprogram_declaration,
	package_declaration,
	subprogram_body;

secondary_unit = library_unit_body, subunit;

library_unit_body = package_body;
=TEX 

=GFT SID
# ALRM 10.1.1 #
context_clause = $,
		with_clause use_clause_list context_clause,
		references_clause context_clause;

references_clause = references name_list semi;

with_clause = with name_list semi;

name_list =
	name,
	name comma name_list;

use_clause_list = $,
	use_clause use_clause_list;
=TEX 

=GFT SID
# ALRM 10.2 #
body_stub = 
	procedure_specification is separate semi,
	function_specification is separate semi,
	package bbody simple_name is separate semi,
	procedure_specification semi,
	function_specification semi;

subunit = 
	 separate ord name crd proper_body,
	 separate ord name crd package_body;
=TEX 

=GFT SID
# ALRM 13.1 #
representation_clause = type_representation_clause, address_clause;

type_representation_clause =
	length_clause,
	enumeration_representation_clause,
	record_representation_clause;
=TEX 

=GFT SID
# ALRM 13.2 #
length_clause = for attribute use simple_expression semi;
=TEX 

=GFT SID
# ALRM 13.3 #
enumeration_representation_clause = for simple_name use aggregate semi;
=TEX 

=GFT SID
# ALRM 13.4 #
record_representation_clause =
	for simple_name use record alignment_opt component_pack end record semi;

alignment_opt = $, at mod simple_expression semi;

component_pack =
	component_clause,
	component_clause component_pack;

component_clause = name at simple_expression rrange range semi;
=TEX 

=GFT SID
# ALRM 13.5 #
address_clause = for simple_name use at simple_expression semi;
=TEX 

=GFT SID
any_label =
	comp_label,
	ppart_label,
	vpart_label,
	dec_label,
	stmt_label,
	spec_label;
=TEX 

=GFT SID
web_clause =
	z,
	compilation,
	comp_label replacedby compilation,
	ppart_label replacedby private_part,
	vpart_label replacedby visible_part,
	dec_label replacedby dec dp1,
	stmt_label replacedby sequence_of_statements,
	spec_label refinedby sequence_of_statements,
	refinedby sequence_of_statements,
	spec_label replacedby sequence_of_statements,
	replacedby sequence_of_statements,
	any_label arbitrary_ada, 

	# the basic symbol arbitrary_ada includes the #
	# arbitrary replacedby symbol #

	arbitrary_ada,
	ord name crd replacedby package_body;
=TEX 

=GFT SID
lit_script = web_clause, web_clause lit_script;
=TEX 
} %%%% end of special set up for SID syntax
\section{SPARK toolkit}

\subsection{Overview}
\bpar{
This appendix contains an extension to the Z toolkit required for
the translation of SPARK to Z. For example, unlike SPARK, Z does not contain an
explicit Boolean type; a model of the Booleans is therefore in this
extension together with a model of their associated operators.
}\epar

\bpar{
The SPARK toolkit depends on the {\ProductZ} library and on
the {\ProductZ} theory of real numbers. However, the latter
is incompatible with the use of the global variable ``real''
as a constructor of the type EXP in volume 3.
We give the {\Product} commands to set up an appropriate
theory for type-checking the SPARK toolkit.
}\epar
=SML
open_theory "z_library";
new_theory"SPARK_toolkit";
new_parent"z_reals";
=TEX
\subsection{Booleans}

%\HOLindexOff

=SPCTZ FALSE
=TEX

=SPCTZ TRUE
=TEX

=SPCTZ BOOLEAN
=TEX

=SPCTZ BOOLEANvFIRST
=TEX

=SPCTZ BOOLEANvLAST
=TEX

=SPCTZ BOOLEANvSUCC
=TEX

=SPCTZ BOOLEANvPRED
=TEX

=SPCTZ BOOLEANvPOS
=TEX

=SPCTZ BOOLEANvVAL
=TEX

\subsection{Boolean Operators}

% In the following we need to avoid picking up two copies
% of the axiomatic description. But the unary operator
% has a separate fixity paragraph from the binary ones and
% we need that. The following picks out the fixity paragraph:
=TEXSH
	extract_z_para not <tktidx.zed | sed -n -e '1,3p'
=SPCTZ and
=TEX

=SPCTZ and_then
=TEX



\subsection{Relational operators returning Booleans}


=SPCTZ mem
=TEX

% As with "not" above the following picks out the fixity paragraph
% for array_not.
=TEXSH
	extract_z_para array_not <tktidx.zed | sed -n -e '1,3p'
=SPCTZ array_and
=TEX

=SPCTZ less
=TEX

=SPCTZ real_less
=TEX

=SPCTZ array_less
=TEX

\subsection{Numeric Operators}

=SPCTZ intdiv
=TEX

=SPCTZ !STAR!!STAR!
=TEX

=SPCTZ e
=TEX

=SPCTZ integer_to_real
=TEX

=SPCTZ real_to_integer
=TEX

\subsection{Predefined Numeric Types}

=SPCTZ INTEGER
=TEX

=SPCTZ INTEGERvFIRST
=TEX

=SPCTZ NATURAL
=TEX

=SPCTZ NATURALvFIRST
=TEX

=SPCTZ NATURALvLAST
=TEX

=SPCTZ NATURALvSUCC
=TEX

=SPCTZ NATURALvPRED
=TEX

=SPCTZ NATURALvPOS
=TEX

=SPCTZ NATURALvVAL
=TEX

=SPCTZ POSITIVE
=TEX

=SPCTZ POSITIVEvFIRST
=TEX

=SPCTZ POSITIVEvLAST
=TEX

=SPCTZ POSITIVEvSUCC
=TEX

=SPCTZ POSITIVEvPRED
=TEX

=SPCTZ POSITIVEvPOS
=TEX

=SPCTZ POSITIVEvVAL
=TEX

=SPCTZ LONG_INTEGER
=TEX

=SPCTZ LONG_INTEGERvFIRST
=TEX


=SPCTZ SHORT_INTEGER
=TEX

=SPCTZ SHORT_INTEGERvFIRST
=TEX

=SPCTZ FLOAT
=TEX

=SPCTZ FLOATvFIRST
=TEX

=SPCTZ SHORT_FLOAT
=TEX

=SPCTZ SHORT_FLOATvFIRST
=TEX

=SPCTZ LONG_FLOAT
=TEX

=SPCTZ LONG_FLOATvFIRST
=TEX

=SPCTZ universal_discrete
=TEX
=SPCTZ universal_discretevFIRST
=TEX

\subsection{Characters and strings}

=SPCTZ CHARACTERvFIRST
=TEX

=SPCTZ CHARACTERvLAST
=TEX

=SPCTZ CHARACTER
=TEX

=SPCTZ CHARACTERvSUCC
=TEX

=SPCTZ CHARACTERvPRED
=TEX

=SPCTZ CHARACTERvPOS
=TEX

=SPCTZ CHARACTERvVAL
=TEX

=SPCTZ STRING
=TEX

=SPCTZ Z_CHAR
=TEX

=SPCTZ Z_STRING
=TEX

\bpar*{
The sets {\it Z\_CHAR} and {\it Z\_STRING} are intended to be sets
that are convenient for the representation in Z of SPARK string and character literals
(see appendix C). The following functions are used to convert these into the types
required by the translation of SPARK into Z.
}\epar*


% We only want the fixity and signature part of the definitions
% of char_lit and string_lit:
=TEXSH
	extract_z_para char_lit <tktidx.zed | sed -n -e '1,5p' -e '$p'
=TEX
=TEXSH
	extract_z_para string_lit <tktidx.zed | sed -n -e '1,5p' -e '$p'
=TEX


\subsection{Informal Functions}

=SPCTZ Informal_Function
=TEX

\subsection{Support for Arrays}

=SPCTZ !AMPERSAND!‰0
=TEX
 [ X1, X2, X ]œœœœœœœœœœœ
Ü Ûarray_agg2Ý : (X1 ­ X2 ­ X) ­ ( X1 ¸ X2 ­ X)
÷üüüüüü
Ü µf : X1 ­ X2 ­ X; x1 : X1; x2 : X2·
Ü	array_agg2 f (x1, x2) = f x1 x2
ˆüüüüüüüüüüüüüü
 [ X1, X2, X3, X ]œœœœœœœœœœœ
Ü Ûarray_agg3Ý : (X1 ­ X2 ­ X3 ­ X) ­ ( X1 ¸ X2 ¸ X3 ­ X)
÷üüüüüü
Ü µf : X1 ­ X2 ­ X3 ­ X; x1 : X1; x2 : X2; x3 : X3·
Ü	array_agg3 f (x1, x2, x3) = f x1 x2 x3
ˆüüüüüüüüüüüüüü
 [ X1, X2, X3, X4, X ]œœœœœœœœœœœ
Ü Ûarray_agg4Ý : (X1 ­ X2 ­ X3 ­ X4 ­ X) ­ ( X1 ¸ X2 ¸ X3 ¸ X4 ­ X)
÷üüüüüü
Ü µf : X1 ­ X2 ­ X3 ­ X4 ­ X; x1 : X1; x2 : X2; x3 : X3; x4 : X4·
Ü	array_agg4 f (x1, x2, x3, x4) = f x1 x2 x3 x4
ˆüüüüüüüüüüüüüü

\bpar*{
\ldots~(additional functions to support array aggregates of up to a minimum of 20 dimensions are to
be provided).
}\epar*

=SPCTZ slide
=TEX

%\HOLindexOn

\section{Z Toolkit Dependencies}

\subsection{Overview}
\bpar{
The translation of SPARK to Z requires the underlying Z tool
to provide support for characters, strings and real numbers.
This is not specific to SPARK and is not considered to be part of the SPARK toolkit.
As the features required are not in the draft Z standard, they
are briefly described here.
}\epar

\bpar{
We give the {\Product} commands to set up an appropriate
theory for type-checking the Z toolkit dependencies.
}\epar

\Hide{
=SML
set_flag("z_type_check_only", true);
=TEX
}
=SML
open_theory "z_library";
new_theory"Z_toolkit_dependencies";
=TEX

\subsection{Characters and Strings}

\bpar{
Characters in SPARK are represented in Z as integers and strings
are represented as sequences of integers. The translation of SPARK character
and string literals into Z is not formally defined in this specification.
A possible formal definition of the sets {\it Z\_CHAR} and {\it Z\_STRING} used
in appendix B might be as follows using a given set {\it CHAR} to represent
individual characters and using string literals in Z that denote sequences
of characters for both SPARK character literals and SPARK string literals:
}\epar



¹Z
Ü [ CHAR ]
°
¹Z
Ü Z_STRING ¦ seq CHAR
°
¹Z
Ü Z_CHAR ¦ {s : CHAR · §s¢}
°


\subsection{Real Numbers}

\bpar{
The translation of SPARK into Z depends on a type of real numbers in Z.
This must be distinct from the type of integers.
}\epar


¹Z
Ü [¯]
°
\bpar{
The arithmetic operators used are: unary minus; absolute value; addition; subtraction; multiplication;
division of one real by another; division of one integer by another to 
return a real; exponentiation (with integer exponents); the operation
that returns the closed interval defined by two end-points; and, conversion
of an integer to a real.
The fixity and signatures of these operators are as follows:
}\epar


¹Z
fun 2 _ ..‰R _
°

¹Z
fun 3 _ +‰R _, _ -‰R _
°

¹Z
fun 4 _ *‰R _, _ /‰R _, _ /‰Z _
°

¹Z
fun 5 ~‰R _
°
¹Z
fun 5 abs‰R _
°

¹Z
fun 6 _ ^‰Z _
°


¹ZAX
Ü ~‰R_  : ¯ ­ ¯;
Ü abs‰R_ : ¯ ­ ¯;
Ü _+‰R_ : ¯ ¸ ¯ ­ ¯;
Ü _-‰R_ : ¯ ¸ ¯ ­ ¯;
Ü _*‰R_ : ¯ ¸ ¯ ­ ¯;
Ü _/‰R_ : ¯ ¸ ¯ ß ¯;
Ü _/‰Z_ : ú ¸ ú ß ¯;
Ü _^‰Z_ : ¯ ¸ ú ­ ¯;
Ü _..‰R_: ¯ ¸ ¯ ­ ð¯;
Ü real : ú ­ ¯
°


\bpar{
The arithmetic relations used 
are less-than, greater-than, less-than-or-equals
and greater-than-or-equals with signatures as follows:
}\epar


¹Z
rel _ <‰R _, _ ¼‰R _, _ ¾‰R _, _ >‰R _
°

¹ZAX
Ü _<‰R_ : ¯ ª ¯;
Ü _>‰R_ : ¯ ª ¯;
Ü _¼‰R_ : ¯ ª ¯;
Ü _¾‰R_ : ¯ ª ¯
°



\startpost

\small
\twocolumn[\section*{Index of identifiers}]
\printindex

\onecolumn

\thispagestyle{dera}

\end{document}
=WARNING_EDIT_WITH_CARE spc501.src
