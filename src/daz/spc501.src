=WARNING_EDIT_WITH_CARE spc501.src
=TEX


\documentclass{derarep5}
%\usepackage{cadiZ}

\usepackage{ProofPower}
\def\ZAxDesLabel{}
\def\ZGenericLabel{}
\def\ZOtherLabel{}
\def\ZSchemaLabel{}
\def\Hide#1{\relax}
\ftlmargin=4em
\tabstop=2em
%\ftlinepenalty=9999

\makeindex

\setcounter{volcnt}{1}


\docno{DRA/CIS/CSE3/TR/94/27/4.0}
\title{Specification of the compliance notation for SPARK and Z}
\volume{1}{3}
\author{C M O'Halloran\\ C T Sennett\\ A Smith}
\Author{O'Halloran C M, Sennett C T, Smith A}
\keywords{Z, SPARK, Refinement, Literate Programming}
\date{February 28, 2002}
\issuedate{February 28, 2002}

%\protmark{}
%\descriptor{}
%\caveat{}
%\codeword{}

\location{Issued by System Assurance Group, KIS Division, \\
QinetiQ, St. Andrews Road, Malvern, Worcestershire, WR14 3PS. \\
Telephone 01684-894320.}
\contractno{CRP8/TG10}
\periodcovered{April 2000 - March 2001}
\customer{DDEC(ISTAR)ET}
\reportprotmark{Not protectively marked}
\reportcaveat{None}
\reportdescriptor{None}
\conference{None}
\titleclass{Not protectively marked}
\keywords{Z, SPARK, Refinement, Literate Programming}
\abstractclass{Not protectively marked}

\raggedbottom

\begin{document}

\maketitle

\begin{center}\fbox{\hspace{3mm}\parbox[t]{130mm}{
\hspc \textbf{Customer Information} \hspc\\[5mm]
\hspc\begin{tabular}{ll}
    Package Number:     & TG10 \\
    Package Title:      & Computing, Information and Signal Processing \\
    Package Customer:   & DDEC(ISTAR)ET \\
    Package Manager:    & Graham Dean \\
    Research Objective: & 5 \\
    Technical Area:     & 3 \\
    Assignment Number:  & 2
\end{tabular}\hspc
}}\vspace{25mm}

\fbox{\hspace{3mm}\parbox[t]{130mm}{\rule[-2mm]{0mm}{8mm}
  This document has been prepared for MoD and, unless indicated, may
  be used and circulated in accordance with the conditions of the Order
  under which it was supplied.\\
  \hspace*{5mm}\\
  It may not be used or copied for any non-Governmental or commercial
  purpose without the written agreement of QinetiQ.
\rule[-4mm]{0mm}{8mm}}\hspace{3mm}}\vspace{25mm}

\copyright Copyright QinetiQ 2002\\
QinetiQ UK \\
\vspace{5mm}
Approval for wider use or release must be sought from:\\
\vspace{5mm}
Intellectual Property Department\\
QinetiQ, Farnborough\\
Farnborough, Hampshire GU14 0LX
\end{center}

\startpre

\section*{Authorisation}

\begin{center}
  \begin{tabular}[t]{@{}p{40mm}p{90mm}@{}}
     Prepared by:       & A Smith \\
     Title:             & Senior Scientist \\
                        & \\
     Signature:         & \hrulefill \\
     Date:              & \hrulefill \\
     Location:          & L113, QinetiQ Malvern \\
                        & \\
     Authorised by:     & M Hill \\
     Title:             & Project Manager \\
                        & \\
     Signature:         & \hrulefill \\
     Date:              & \hrulefill \\
                        & \\
                        & \\
     Principal authors  & \\
                        & \\
     Name:              & A Smith \\
     Appointment:       & Senior Scientist \\
     Location:          & QinetiQ(Malvern) \\
                        & \\
     Name:              & C M O'Halloran \\
     Appointment:       & Lead Researcher \\
     Location:          & QinetiQ(Malvern) \\
                        & \\
     Name:              & C T Sennett \\
     Appointment:       & QinetiQ Fellow \\
     Location:          & QinetiQ(Malvern) \\    
  \end{tabular}

  \vspace{25mm}
  
  Issued by: System Assurance Group, KIS Division \\
  QinetiQ \\
  St. Andrews Road \\
  Malvern \\
  Worcestershire, WR14 3PS. \\
  Telephone 01684-894320
\end{center}

\section*{Record of changes}

This is a controlled document. \\
Additional copies should be obtained through the issuing authority. \\
In the extreme event of copying locally, each document shall be marked
`Uncontrolled Copy'. \\
Amendments shall be by whole document replacement. \\
Proposals for change to this document should be forwarded in writing to the issuing authority.\\
\\[15mm]
\begin{tabular}{|l|l|l|} \hline
    Version\hspace{1cm} & Date\hspace{2cm} & Comments\hspace{5cm} \\ \hline
  1.0  &  March 25, 1994     &  First Issue \\
  1.1  &  June 13, 1994      &  Data refinement added  \\
  1.2  &  December 22, 1994  &  Omissions found during implementation \\
       &                     &  of version 1.1 \\
  2.0  &  July 5, 1995       &  Various enhancements \\
  2.1  &  January 12, 1996   &  Omissions found during implementation \\
       &                     &  of version 2.0 \\
  3.0  &  September 26, 1997 &  Enhancements as recommended by independent \\
       &                     &  evaluation report \\
  3.1  &  August 4, 2000     &  Further enhancements \\
  4.0  &  February 28, 2002  &  \parbox[t]{7cm}{\raggedright
			     The specifications are now maintained on QinetiQ's behalf
			     by Lemma 1 Ltd. The formal Z material is now checked
			     and typeset using {\Product}. The specification changes
			     recorded in the documents HLD507\cite{LEMMA1/DAZ/HLD507}
			     and HLD508\cite{LEMMA1/DAZ/HLD508} have been actioned.

			    }\\
                        &                   & \\
                        &                   & \\
                        &                   & \\
                        &                   & \\
                        &                   & \\
                        &                   & \\
                        &                   & \\ \hline
\end{tabular}      


\abstract{This volume formally specifies how to obtain the Z document from a 
literate script.  All three volumes are based on edition 3.2 of the SPARK 
manual (October 1996). All three 
volumes have been type-checked and typeset by {\ ProofPower}.}


\tableofcontents

%\ivolume{volume2.toc}
%\ivolume{volume3.toc}

\startmain

\section{Introduction}

\subsection{Overview}

\bpar{
This document specifies how to obtain a Z document, which contains for example the
verification conditions (VCs), from a literate script.
A minor part of the specification is given informally in section 17 and includes for example
the static checks that need to be carried out on a literate script.
}\epar

\bpar{
The specification is top down and is in three volumes.
This volume (volume 1) specifies at which points in the literate script Z is output to the Z document.
A refinement step for example gives rise to some VCs (expressed in Z) being output to the Z document.
The precise form of the VCs is specified in volume 2.
}\epar

\bpar{
Also a SPARK type declaration, for example, needs to be represented in the Z document.
Precisely what Z this should be is specified in volume 3 which specifies the translation of SPARK
basic declarations and expressions to Z.
}\epar

\bpar*{
We run the {\Product} commands to set up a theory to hold the specification.
The specification depends upon the material in volumes 2 and 3.
The material in volume 3 is inherited from volume 2.
}\epar*

=SML
open_theory "Volume_2";
new_theory"Volume_1";
=TEX

\subsection{The structure of the design specification}

\bpar{
The specification is written very much with an implementation in mind.
For this reason the formal specification appears as a set of compiling operations on the
concrete syntax of a literate script (appendix A).
These compiling operations produce Z instead of object code.
The concrete syntax has been written in the form required by SID [4].
SID allows the compiling operations to be embedded in the syntax.
SID will produce an analyser which syntax checks a literate script {\it and} calls each
compiling operation at the point stated in the syntax.
}\epar

\bpar{
As an example of the SID approach consider the following syntax for numerical expressions
which contains compiling operations to evaluate the resulting integer:
}\epar

\bpar*{
BASICS \\
\ \\
number    \# integers \# \\
orb       \# ( \# \\
crb       \# ) \# \\
plus      \# + \# \\
minus     \# - \# \\
multiply  \# * \# \\
}\epar*

\bpar*{
RULES \\
\ \\
expression = \\
expression addop term $<add\_subtract>$, \\
term; \\
\ \\
term = \\
term multop primary $<times>$, \\
primary; \\
\ \\
primary = \\
$<number>$ number, \\
addop primary $<monadic>$, \\
orb expression crb; \\
\ \\
addop = \\
$<op1>$ plus, \\
$<op2>$ minus; \\
\ \\
multop = $<op3>$ multiply;
}\epar*

\bpar*{
The text under the heading BASICS lists the identifiers to be used to stand for the terminal
symbols of the syntax. A comment starts and finishes with a \#. 
The text under RULES lists the syntax rules: an equals sign terminates
the name of the rule, a comma separates alternatives and a semicolon terminates the definition
of the rule. The compiling operations appear inside the angled brackets.
SID is able to transform the above syntax into a one-track form (no back-tracking required)
and outputs a program which will perform syntax analysis. Where compiling operations have been
included the analyser will call them at the appropriate place in the symbol stream: for example,
in the rule for {\it expression}, the operation $add\_subtract$ will be called to 
form each intermediate result in an expression like 5 + 4 + 3.
}\epar*

\bpar{
In this document the compiling operations are specified in Z.
The specification of a compiling operation appears as a Z schema with the same name (all lower case
names). Some of the compiling operations need to use global variables which hold certain
information. Global variables are specified by Z schemas with upper case names.
As an example of using Z schemas to specify compiling operations and global variables consider
again the example above. A global variable $STACK$ can be used to hold all the intermediate
results of evaluating a numerical expression:
}\epar

¹ÿ ÛSTACKÝ
	s : seq ú
ˆ

\bpar*{
The compiling operation $op1$ puts the number 1 on the stack to signify that the
syntax analyser has come across the symbol + (plus):
}\epar*

¹ÿ Ûop1Ý
Ü	„STACK
÷
Ü	s' = §1¢ ë s
ˆ


\bpar*{
Similarly $op2$ puts the number 2 on the stack to signify subtraction:
}\epar* 
  
¹ÿ Ûop2Ý
Ü	„STACK
÷
Ü	s' = §2¢ ë s
ˆ


\bpar*{
The compiling operation $add\_subtract$ evaluates {\it expression\ addop\ term}.
At the point $add\_subtract$ is called, {\it term} has been evaluated and is on top of the stack.
Below this on the stack is the number representing {\it addop} (1 or 2 as described above).
Below {\it addop} on the stack is the result of evaluating {\it expression}.
$add\_subtract$ therefore ``pops" the top three numbers off the stack, performs an addition
or subtraction, and puts the result on the stack:
}\epar*

¹ÿ Ûadd_subtractÝ
Ü	„STACK
Ü	s‰1 : seq ú
÷
Ü	s‰1 = tail(tail(tail s))
Ü		s 2 = 1 ± s' = §s 3 + s 1¢ ë s‰1
Ü	² 
Ü		s 2 = 2 ± s' = §s 3 - s 1¢ ë s‰1
ˆ


\bpar{
The SID functions (compiling operations) specified in this volume are at a certain level of abstraction.
An implementation of a tool to produce a Z document from a literate script will require
more SID functions than specified in this document.
However these extra SID functions are low level and would clutter the specification.
For example when a record type declaration is encountered a SID function is called which translates
it to Z and outputs it to the Z document. However the SID function assumes that all the components of the record type
declaration have collected up ready for translation. Additional low level SID functions will be required
to collect up these components. 
}\epar

\bpar{
In this volume, the syntactic categories that contain SID functions are presented in the same order
as they appear in the concrete syntax of a literate script (appendix A).
The order in appendix A is in turn the same as the order in the SPARK manual.
There are slight differences between the syntax in appendix A and that in the SPARK manual.
This is so the syntax in appendix A can be transformed by SID into a one-track form.
Where there is a change, the original SPARK syntax has been left in but commented out.
}\epar

\bpar{
In this document, a comment refers to the Z after it.
}\epar



\bpar{
This document specifies the production of the Z document in a single pass over the literate script.
This determines a particular ordering for the paragraphs in the Z document.
Some SPARK constructs require the production of auxiliary modules of Z.
The paragraphs to produce these modules are specified here as coming at the head of the Z document
so that the structure of the Z document is broadly conformant with the modularity features of the
draft Z standard.
Tools implementing this specification are intended to preserve the ordering of the main paragraphs
in the Z document as far as possible so as to make it traceable against the literate script.
Tools are, however, permitted to generate the text for auxiliary modules in a non-standard order
(e.g., the text could be produced in situ at the point in the Z document where the module is required).
}\epar

\bpar{
It is to be assumed throughout this document that if something is not mentioned in the signature
of a SID function or other Z schema then it does not change.
}\epar

\section{Simple specification of a Z document}

\bpar{
The Z document which is generated from a literate script is a sequence of Z paragraphs.
}\epar

=SPCZ Z_DOC 
=TEX




\bpar{
At the start of each literate script $Z\_DOC$
is initialised using the schema \\
$INIT\_Z\_DOC$.
This takes a name for the script as an input variable.
The means for determining this name are implementation-dependent.
The initial Z document comprises a module header introducing a module with the same name
as the script and with at least two parents: the standard Z toolkit and
the SPARK extensions to the toolkit defined in appendix B of this document.
A tool may also allow the user to add additional parents, if required.
}\epar

=SPCZ Z_toolkit 
=TEX

=SPCZ SCRIPT_NAME 
=TEX

=SPCZ INIT_Z_DOC 
=TEX



\section{Compliance notation environments}

\subsection{Package specification environment}

\bpar{
This environment is incremented on encountering a ification.
This environment records the information from package specifications that is necessary
for formal development. The information in the environment is used when a package body or a {\tt with} clause
is encountered.
}\epar

  

\bpar{
A $Formal\_Fun$ is an Ada function which has a specification statement.
It is in fact an Ada function specification ($Informal\_Fun$) together with the specification statement ($Spec$).
A $Formal\_Fun$ can therefore occur in a package specification, function body or function stub. 
A $Formal\_Fun$ is similar to $Formal\_Proc$ (defined in volume 2) but for functions rather than procedures.
As SPARK functions must have no side-effects then the frame $w$ must be empty.
The $globals$ component records the list of global variables on which the formal function may depend.
}\epar

=SPCZ  Formal_Fun
=TEX



\bpar{
For each package specification the following information is recorded: \\
1. $vc\_vars$ - the variables declared. These will appear as local declarations in VCs if the package is utilised
(that is if a {\tt with} clause or package body is encountered). \\
2. $consts\_types$ - the constants and types declared. These will be output to the Z document if the package is utilised. \\
3. $formal\_procs$ - the formal procedures (those with a specification statement). These are used for VC generation involving
procedure calls if a {\tt with} clause is encountered. \\
4. $informal\_funs$ - the informal functions (those with no specification statement). All Ada functions
(both formal and informal) give rise to a Z
axiomatic description being output to the Z document. Thus the functions in a literate script must have different names
otherwise the Z document will not type-check.
This ensures that only the correct axiomatic description can be used to prove a VC.
The problem is a consequence of the nested structure of Ada being projected onto the flat structure of Z.
In the case of a package specification the $informal\_funs$ are output to the Z document when a {\tt with} clause is encountered. \\
5. $formal\_funs$ - the formal functions (those with a specification statement). These are output to the Z document when
a {\tt with} clause is encountered. \\
6. $aux\_vars$ - the auxiliary variables declared [3]. These will appear as local declarations in VCs if the package is utilised with a {\tt with} clause. They are also needed to generate VCs when data refinement
occurs in the corresponding package body. \\
7. $zmod$ - the name of the Z module which was current when the package specification was encountered.
}\epar


=SPCZ  Package
=TEX


\bpar{
The following functions update a $Package$ binding by changing just one component.
For example $Package\_vc\_vars(b, v)$ is the binding $b$ with the value in its
$vc\_vars$ field replaced with the new value $v$. Similar functions appear
for other schemas in this specification.
}\epar   

=SPCZ  Package_vc_vars
=TEX


\bpar{
The package specification environment.
The information from a package specification is stored under the name of the package.
}\epar

=SPCZ  PACK_ENV
=TEX



\bpar{
$PACK\_ENV$ is set to $PACK\_ENV0$ before processing the first literate script only.
}\epar

=SPCZ  PACK_ENV0
=TEX


\subsection{Subunit environment}

\bpar{
This environment is incremented on encountering a subprogram stub ({\tt \ldots\ is\ separate}).
The information in the environment is used when a subunit ({\tt separate\ \ldots}) is encountered.
}\epar





\bpar{
For each stub the following information is recorded: \\
1. $zmod$ - the state of the Z document at the time the stub is encountered; it is made into a module and imported into the
Z document that corresponds to the literate script containing the subunit. \\
2. $specif\_flag$ - a flag to say whether the stub is formal (contains a specification statement). \\
3. $specif$ - the specification statement of the stub; if there is no specification statement then $specif$ could be
set to anything and $specif\_flag$ will be $False$. \\
4. $In\_Scope$ - the variables, formal procedures etc that are in scope at the point the stub is declared.
These will be needed when processing the subunit since they are visible to the stub and hence to the subunit. \\
5. $globs$ - for a formal subprogram, this gives the list of global variables on
which the subprogram may depend. This is needed to check that the subunit and the stub give the same list.

}\epar  

=SPCZ  Subunit
=TEX

\bpar*{
The Subunit
environment will also be used for package stubs.
In particular, for a package stub, {\it specif\_flag} will be false and {\it specif}
can be arbitrary.
}\epar*

\bpar{
More binding update functions.
}\epar

=SPCZ  Subunit_vc_vars
=TEX


\bpar{
The subunit environment.
The information in a subunit is stored under the name of the parent unit (the unit in which the stub
was declared) and the name of the subprogram itself.
}\epar

=SPCZ  SUBUNIT_ENV
=TEX

\bpar{
$SUBUNIT\_ENV$ is set to $SUBUNIT\_ENV0$ before processing the first literate script only.
}\epar

=SPCZ  SUBUNIT_ENV0
=TEX


\subsection{Dec label environment}

\bpar{
This environment is incremented on encountering a k\_slot used as a declaration.
The information is used when the k\_slot is expanded.
}\epar

\bpar{
Throughout the specification a set of flags are used to let the compiling actions know the context
of where they are called. These flags are: \\
1. $pack\_spec\_flag$ - set to $True$ when a package specification is encountered. \\
2. $pack\_body\_flag$ - set to $True$ when a package body is encountered. \\
3. $stub\_flag$ - set to $True$ when a stub is encountered. \\
4. $subunit\_flag$ - set to $True$ when a subunit is encountered. \\
5. $body\_flag$ - set to $True$ when a package or subprogram body is encountered. \\
6. $formal\_body\_flag$ - set to $True$ when a formal procedure or function is encountered. \\
7. $fun\_flag$ - set to $True$ when a function is encountered. \\
8. $declabel\_flag$ - set to $True$ when a k\_slot used as a declaration is expanded. \\
9. $speclabel\_flag$ - set to $True$ when a specification statement is refined. \\
10. $till\_flag$ - set to $True$ when a till predicate is encountered.
}\epar

=SPCZ  Flags
=TEX


\bpar{
For each k\_slot the following information is recorded: \\
1. $block\_name$ - the name of the parent unit (the unit in which the k\_slot occurs).
This is needed in case the k\_slot is subsequently expanded to a stub. \\
2. $Flags$ - the flag settings of the block in which the k\_slot occurs.
This gives the context information for when the k\_slot is expanded. \\
3. $In\_Scope$ - the variables and formal procedures etc that are in scope at the point the k\_slot is encountered.
These are visible to the k\_slot and therefore also to the expansion.
}\epar

=SPCZ  Declab
=TEX


\bpar{
More binding update functions.
}\epar

=SPCZ  Declab_declabel_flag
=TEX


\bpar{
The dec label environment.
}\epar

=SPCZ  DEC_ENV
=TEX


\bpar{
$DEC\_ENV$ is set to $DEC\_ENV0$ at the start of each literate script.
}\epar

=SPCZ  DEC_ENV0
=TEX


\subsection{Spec label environment}

\bpar{
This environment is incremented on encountering a specification statement acting as a SPARK statement.
The information is used when the specification statement is refined (or expanded with $\equiv$).
The environment uses a $Speclab$ (see $SPEC\_ENV$ below).
The definition of $Speclab$ is in volume 2 because the VC generation algorithm is called with a $Speclab$ and a sequence of statements.
The $Speclab$ contains all the information the algorithm needs.
}\epar

\bpar{
The spec label environment is also used to deal with k\_slots acting as statements (see section 6).
Such a k\_slot is treated as a specification statement that is only expanded not refined.
This allows the SID functions for specification statements to be re-used for such k\_slots.
}\epar

\bpar{
More binding update functions.
}\epar

=SPCZ  Speclab_w
=TEX


\bpar{
The spec label environment.
}\epar

=SPCZ  SPEC_ENV
=TEX


\bpar{
$SPEC\_ENV$ is set to $SPEC\_ENV0$ at the start of each literate script.
}\epar

=SPCZ  SPEC_ENV0
=TEX


\subsection{Running environment}

\bpar{
This is a block structured environment which is continuously incremented as the
literate script is processed. It is used to increment the other four environments and
for example holds the information necessary to generate VCs demanding that the body of a
formal subprogram is a refinement of its specification statement.
The running environment reflects the block structure of Ada although extra blocks are also opened.
}\epar





\bpar{
A $Block$ consists of: \\
1. $Declab$ - described in subsection 3.3. This is used to update the other four environments. \\
2. $current\_formal\_proc$. On encountering a formal procedure a new block is opened and $current\_formal\_proc$ is set
to the $Formal\_Proc$. $current\_formal\_proc$ enables the output of VCs demanding that the body of a
formal procedure is a refinement of its specification statement.\\
4. $current\_formal\_fun$. On encountering a formal function a new block is opened and $current\_formal\_fun$ is set
to the $Formal\_Fun$. $current\_formal\_fun$ enables the output of VCs demanding that the body of a
formal function is a refinement of its specification statement. \\
5. $dec\_lab$ - the current dec label being expanded. \\
6. $spec\_lab$ - the current spec label being expanded. \\
7. $till$ - the current till predicate. \\
8. $using\_decs$ - the {\it using} declarations inside a package body needed for data refinement
(see section 13 - SPARK packages). \\
9. $var\_inits$ - the association of initial values to variables arising from SPARK declarations
with initialising expressions.
}\epar

=SPCZ  Block
=TEX


\bpar{
In a lot of cases (not always) when a new block is opened the components of $In\_Scope$
(together with $var\_inits$) are set to $\{\}$.
}\epar

=SPCZ  Empty_Block
=TEX


\bpar{
More binding update functions.
}\epar

=SPCZ  Block_stub_flag
=TEX


\bpar{
The running environment.
}\epar


=SPCZ  ENV
=TEX


\bpar{
$ENV$ is set to $ENV0$ at the start of each literate script.
}\epar

=SPCZ  ENV0
=TEX




\bpar{
Unlike $ENV$ the other four environments are flat structured.
Three of the four environments record the variables, formal procedures etc that are in scope.
This information is in $ENV$ but block structured and so must be flattened.
In $flatten\_env$, the $dec\_labels$ are only gathered up from the current package or subprogram.
This ensures that the frame-widening described in section 4.4.1 does not propagate into
nested subprograms (which would lead to unsound VCs).
}\epar

=SPCZ  flatten_env
=TEX


\bpar{
The function $subprog\_flatten\_env$ is a variant of $flatten\_env$
that ensures that in the body of a formal subprogram only the parameters,
local variables and named global dependencies are in scope.
(Note that the parameters include any {\tt for} loop variables).
}\epar

=SPCZ  subprog_flatten_env
=TEX


\section{SPARK basic declarations ({\it basic\_declaration})}

\subsection{SID functions}



\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
basic\_declaration = \\
object\_declaration, \\
type\_declaration $< basic\_declaration >$, \\
subtype\_declaration $< basic\_declaration >$, \\
deferred\_constant\_declaration, \\
pragma; \\
\ \\
object\_declaration = \\
constant\_declaration $< basic\_declaration >$, \\
variable\_declaration $< adj\_var\_decl >$ $< var\_pack\_spec >$ $< update\_envs\_var >$ $< add\_var\_init\_env >$ $< add\_var\_env >$;
}\epar

\subsection{The SID function basic\_declaration}

\bpar{
The global variable $BASIC\_DEC$ holds the current constant, type or subtype declaration.
}\epar

=SPCZ BASIC_DEC
=TEX

\bpar{
The SID function $basic\_declaration$ deals with constant, type or subtype declarations.
Its specification is split into two cases
depending on whether the declaration appears in a package specification or not.
}\epar

\bpar{
Case 1. If the declaration is inside a package specification then add it to the package specification environment.
}\epar


=SPCZ  basic_decl_pack_spec
=TEX


\bpar{
Case 2. If the declaration is not inside a package specification then output it to the Z document.
The declaration is first translated to Z by the function $trans\_basic\_decl$ which is specified in volume 3.
}\epar

=SPCZ  basic_decl_otherwise
=TEX


\bpar{
Bringing the two cases together.
}\epar

=SPCZ  basic_declaration
=TEX



\subsection{The SID function var\_pack\_spec}





\bpar{
The global variable $VAR\_DECL$ defined
in volume 3 holds the current variable declaration.
}\epar


\bpar{
If a variable declaration is inside a package specification then the SID function $var\_pack\_spec$
adds it to the package specification environment.
}\epar

=SPCZ  var_pack_spec
=TEX


\subsection{The SID function update\_envs\_var}

\bpar{
If the variable declaration has been introduced by expanding a k\_slot then the SID function $update\_envs\_var$
updates the subunit, dec label and spec label environments (all three need updating).
This is necessary because these environments may have been incremented (perhaps many times) before
the k\_slot has been expanded.
The information from expanding the k\_slot now needs to be recorded in these environments.
Only those stubs, k\_slots and specification statements that are in the scope of the original k\_slot are affected.
The variables introduced by expanding the k\_slot are added to the $vc\_vars$ components of the environments.
Also in the case of the spec label environment the frame of all specification statements, which
are in the scope of the k\_slot, are widened with the new variables.
}\epar

=SPCZ  update_subunit_env_var
=TEX

=SPCZ  update_dec_env_var
=TEX

=SPCZ  update_spec_env_var
=TEX


\bpar*{
Note the $\land$s in the definition of $update\_envs\_var$ below indicating that all three environments need
updating.
}\epar*

=SPCZ  update_envs_var
=TEX


\subsection{The SID function add\_var\_env}

\bpar{
The SID function $add\_var\_env$ adds the variable declaration to the current environment.
This must be done in all cases;
even in the case when the variables are introduced by expanding a k\_slot there could be other declarations
(eg a procedure body) also introduced (a k\_slot can be expanded to a whole sequence of declarations) which are in the
scope of these variables.
}\epar

=SPCZ  add_var_env
=TEX


\subsection{The SID function add\_var\_init\_env}

\bpar{
If the variable declaration contains an initial value, the SID function
$add\_var\_init\_env$ records the initial value in the running environment.
}\epar

=SPCZ  add_var_init_env
=TEX

\subsection{The SID function adj\_var\_decl}

\bpar{
The current variable declaration as input to {\tt\itshape adj\_var\_decl} is given by the
global variable {\tt\itshape SI\_VAR\_DECL} defined in volume 3.
The adjustment gives a value to the global variable {\tt\itshape VAR\_DECL} and may give rise to a new subtype declaration (although a {\tt\itshape SI\_VAR\_DECL} appears to allow for many subtypes, the {\tt\itshape SI\_Var\_Decl}s are constrained to use the same subtype indication so there is 
just one).
The SID function {\tt\itshape adj\_var\_decl} is defined in terms 
of the function {\tt\itshape adjust\_var\_decl} from volume 1 and the
schema SID function {tt\itshape basic\_declaration}.
}\epar

=SPCZ  adj_var_decl
=TEX



\section{SPARK declarations ({\it dec})}

\subsection{SID functions}



\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
dec = \\ 
k\_slot $< k\_slot\_dec >$ $< update\_envs\_k\_slot >$, \\
renaming\_declaration, \\
basic\_declarative\_item, \\
package\_declaration, \\
body;
}\epar

\subsection{The SID function k\_slot\_dec}

\bpar{
The global variable $LAB$ contains the current label. It will therefore contain the label of the
current k\_slot (any type of k\_slot), specification statement or the label currently being expanded or refined.
If a specification statement has no label then $LAB$ contains the special label $no\_label$.
}\epar

=SPCZ  LAB
=TEX

=SPCZ  no_label
=TEX


\bpar{
The function $dot$ takes two Ada identifiers {\tt id1} and {\tt id2} and yields the new identifier {\tt id1.id2} as result.
Ada uses {\tt .} in subunit names.
}\epar 


=SPCZ  dot
=TEX


\bpar{
The SID function $k\_slot\_dec$ increments the dec label environment with the current k\_slot.
Recall that $block\_name$ is needed in the environment in case the k\_slot is subsequently expanded into a stub.
If the k\_slot is in a subunit itself then $block\_name$ must record the name of the subprogram's parent.
}\epar

=SPCZ  k_slot_dec
=TEX



\subsection{The SID function update\_envs\_k\_slot}

\bpar{
If the k\_slot has been introduced by expanding a k\_slot, then
the SID function\\
$update\_envs\_k\_slot$
updates the subunit, dec label and spec label environments (all three
need updating).
This is necessary because these environments may have been incremented
(perhaps many times) before the k\_slot has been expanded.
The information from expanding the k\_slot now needs to be recorded in these
environments.
Only those stubs, k\_slots and specification statements that are in the scope
of the original k\_slot are affected.
The new k\_slot is added to the $dec\_labels$ components of all the environments.
}\epar


=SPCZ  update_subunit_env_k_slot
=TEX

=SPCZ  update_dec_env_k_slot
=TEX

=SPCZ  update_spec_env_k_slot
=TEX


=SPCZ  update_envs_k_slot
=TEX


\section{SPARK statements ({\it statement})}

\subsection{SID functions}

\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
statement = \\
k\_slot $< k\_slot\_stmt >$, \\
specification\_statement $< spec\_stmt >$, \\
con z\_decl $< add\_log\_con\_env >$ fatdot specification\_statement $< spec\_stmt >$ $< remove\_log\_con\_env >$, \\
simple\_statement, \\
compound\_statement, \\
pragma;
}\epar

\subsection{The SID function spec\_stmt}

\bpar{
The global variable $SPEC\_STMT$ holds the current specification statement.
}\epar

=SPCZ  SPEC_STMT
=TEX



\bpar*{
Schema names in the concrete frame of the specification statement serve as a short-hand
for the names of the signature variables of the schema.
Each schema name must be replaced by the list of names in the signature of the schema
in the abstract frame inside the global variable $SPEC\_STMT$.
This replacement must be carried out with respect to the schema definitions in the context of the
current Z module (i.e., in the context is used to type-check the pre- and post-condition of the
specification statement).
}\epar*

\bpar{
The SID function $spec\_stmt$ increments the spec label environment on encountering a specification statement.
There are two cases to consider.
}\epar

\bpar{
Case 1. Specification statement introduced during a refinement step (or the simple expansion of a spec label).
A lot of the information in the new $Speclab$ is simply copied from the $Speclab$ corresponding to the
spec label being refined or expanded.
There is a problem with the specification below if $no\_label$
is refined into a sequence of statements that itself includes a
specification statement with no label. This is because the new occurrence
of $no\_label$ is added to $SPEC\_ENV$ before the first occurrence is deleted
(by the SID function $end\_scope\_speclabel$ in the section on Web clauses),
but this would contradict the fact that $spec\_env$ is a Z function.
The solution is to treat each new occurrence of $no\_label$ in a literate
script as a different label (that is $no\_label\_1$, $no\_label\_2$ etc). 
}\epar

=SPCZ  spec_stmt_speclabel
=TEX


\bpar{
Case 2. All other cases when a specification statement is encountered.
}\epar


=SPCZ  spec_stmt_otherwise
=TEX


\bpar{
Bringing the two cases together.
}\epar

=SPCZ  spec_stmt
=TEX



\subsection{The SID function k\_slot\_stmt}

\bpar{
The SID function $k\_slot\_stmt$ increments the spec label environment on encountering a k\_slot acting
as a SPARK statement.
It does not matter what specification statement is stored in the environment since it will never be used.
}\epar

=SPCZ  k_slot_stmt
=TEX


\subsection{The SID function add\_log\_con\_env}

\bpar{
The global variable $LOGICAL\_CON$ holds the current logical constant declaration.
}\epar



=SPCZ  LOGICAL_CON
=TEX


\bpar{
The SID function $add\_log\_con\_env$ adds a logical constant declaration to the local block.
It will then be stored on encountering the SID function $spec\_stmt$ which is called after the
logical constant's specification statement.
}\epar


=SPCZ  add_log_con_env
=TEX


\subsection{The SID function remove\_log\_con\_env}

\bpar{
The SID function $remove\_log\_con\_env$ removes the logical constant declaration from the local block.
This is because the scope of the logical constant is only its specification statement
(and subsequent refinements of the specification statement).
}\epar

=SPCZ  remove_log_con_env
=TEX


\section{SPARK loops ({\it loop\_statement})}

\subsection{SID functions}

\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
loop\_statement = \\
name\_opt1 $< new\_scope\_loop >$ iteration\_scheme\_opt till\_opt loop \\
sequence\_of\_statements end loop name\_opt2 semi $< end\_scope >$; \\
\ \\
loop\_parameter\_specification = \\
identifier in type\_mark $< for\_param >$, \\
identifier in reverse type\_mark, \\
identifier in type\_mark $< for\_param >$ rrange range, \\
identifier in reverse type\_mark rrange range, \\
identifier in $< for\_param >$ range,\\
identifier in reverse $< for\_param >$ range; \\
\ \\
till\_opt = \\
\$, \\
till z\_pred $< till\_pred >$;
}\epar

\subsection{The SID function new\_scope\_loop}

\bpar{
The SID function $new\_scope\_loop$ adds a new block to the running environment on encountering a loop.
}\epar

=SPCZ  new_scope_loop
=TEX

\subsection{The SID function end\_scope}

\bpar{
The SID function $end\_scope$ takes the innermost block off the running environment.
}\epar

=SPCZ  end_scope
=TEX


\subsection{The SID function for\_param}

\bpar{
The global variable $FOR\_PARAM$ holds the current {\tt for} loop variable.
}\epar

=SPCZ  FOR_PARAM
=TEX


\bpar{
The SID function $for\_param$ adds a {\tt for} loop variable to the $vc\_pars$ field of the local block.
This is because the value of a {\tt for} loop variable can not be changed by the user.
From a formal development point of view it is treated as a formal parameter
of mode $in$. This means that in the local declarations of the VCs there will be no corresponding initial variable. 

In the cases where the loop parameter specification contains no type mark the 
loop identifier will be declared with a subtype derived from the type represented as 
{\tt\itshape universal\_discrete} with the constraint given by the range. In the case where the range is given as a range attribute it is transformed into a simple range by transforming 
{\tt\itshape P'RANGE} into {\tt\itshape P'FIRST $..$ P'LAST} and similarly for multi-dimensional array ranges as elsewhere in this specification.
}\epar

=SPCZ  for_param
=TEX


\subsection{The SID function till\_pred}

\bpar{
The global variable $TILL\_PRED$ holds the current till predicate.
}\epar

=SPCZ  TILL_PRED
=TEX

\bpar{
The SID function $till\_pred$ adds a till predicate to the local block.
$till\_flag$ is also set to $True$ indicating that the $till$ field is correctly set.
}\epar 

=SPCZ  till_pred
=TEX

\section{SPARK subprogram declarations ({\it subprogram\_declaration})}

\subsection{SID functions}

\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
subprogram\_declaration = \\
procedure\_specification semi $< end\_scope >$, \\
function\_specification semi $< end\_scope >$;
}\epar

\bpar*{
The block opened up for a subprogram must be closed at the end of the subprogram.
Recall that the block is opened up within the syntax for procedure\_specification and function\_specification.
}\epar*

\section{SPARK procedures ({\it procedure\_specification})}

\subsection{SID functions}

\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
procedure\_specification = \\
procedure identifier $< subunit\_inf >$ $< new\_scope\_proc\_inf >$ $< stub >$, \\
procedure identifier $< subunit\_form >$ $< new\_scope\_proc\_form >$ $< stub >$
procedure\_specification\_statement $< curr\_form\_proc >$ $< form\_proc >$ $< stub\_spec\_proc >$, \\
procedure identifier $< subunit\_inf >$ $< new\_scope\_proc\_inf >$ $< stub >$ formal\_part, \\
procedure identifier $< subunit\_form >$ $< new\_scope\_proc\_form >$ $< stub >$ 
formal\_part procedure\_specification\_statement $< curr\_form\_proc >$ $< form\_proc >$ $< stub\_spec\_proc >$;
}\epar

\subsection{The SID function subunit\_form}

\bpar{
The global variable $IDENT$ holds the current identifier.
}\epar

=SPCZ  IDENT
=TEX


\bpar{
On encountering a formal procedure which is also a subunit, the SID function \\ 
$subunit\_form$ outputs to the Z document a paragraph making the Z module formed
when the corresponding stub was processed a parent of the current Z module.
}\epar

=SPCZ  subunit_form
=TEX


\subsection{The SID function subunit\_inf}

\bpar{
On encountering an informal procedure which is also a subunit, the SID function $subunit\_inf$
again outputs the Z module but this time removes the subunit from the subunit environment.
All the information has been extracted from the subunit environment and placed in the running environment.
However in the case of a formal subunit (above) VCs need to be output which demand that the specification statement in the
subunit is a refinement of that in the stub. This is done by the SID function $form\_proc$ (defined later in this section). 
$form\_proc$ therefore needs access to the specification statement of the stub which is held in the
subunit environment. Therefore, in the above case, this information must not be deleted.
}\epar

=SPCZ  subunit_inf
=TEX


\subsection{The SID function new\_scope\_proc\_inf}

\bpar{
The SID function $new\_scope\_proc\_inf$ adds a new block to the running environment on encountering an informal procedure.
}\epar

=SPCZ  new_scope_proc_inf
=TEX


\subsection{The SID function new\_scope\_proc\_form}

\bpar{
The SID function $new\_scope\_proc\_form$ adds a new block to the running environment on encountering a formal procedure.
}\epar

=SPCZ  new_scope_proc_form
=TEX


\subsection{The SID function stub}



\bpar{
When a stub is encountered, the function $make\_module$
is used to make a copy of the current Z module under a new name.
This copy is thought of as being placed at the beginning of the Z document.
When the corresponding subunit is encountered, the stub module becomes
a parent of the current Z module (as seen in the SID functions
$subunit\_form$ and $subunit\_inf$ defined earlier in this section).
This approach will also work if the stub appears in a subunit,
so a user can form subunits of subunits and so on.
}\epar
=SPCZ  make_module
=TEX

\bpar*{
The function $trans\_subunit\_name$
creates a Z module name appropriate for the stub module.
}\epar*

=SPCZ  trans_subunit_name
=TEX



\bpar{
The SID function $stub$ creates the stub module and stores its name in the subunit environment.
The {\it In\_Scope} set up here is provisional, the SID function {\it stub\_spec\_proc}
or {\it stub\_spec\_fun} will calculate the correct value when the function
specification (if any) has been processed.
}\epar

=SPCZ  stub
=TEX

\subsection{The SID function stub\_spec\_proc}

\bpar{
The global variable $FORM\_PROC$ holds the current $Formal\_Proc$.
The {\it globals} component of the formal procedure is derived from
the procedure specification statement in the concrete syntax by concatenating
the frame and the dependencies (the list of global variables read by the procedure
but not written). As with the frame, schema names may be used in the dependencies
in the concrete syntax and these are replaced by the list of signature variables in 
the abstract list of globals.
}\epar

=SPCZ  FORM_PROC
=TEX




\bpar*{
The formal procedure contains a specification statement.
Schema names in the concrete frame of this specification statement must have been replaced
by variable names as described in section 6.2.1.
}\epar*

\bpar{
The SID function $stub\_spec\_proc$ adds the specification statement of a formal procedure stub to the subunit environment.
}\epar

=SPCZ  stub_spec_proc
=TEX

\newpage

\subsection{The SID function form\_proc}

\bpar{
The SID function $form\_proc$ outputs VCs to the Z document demanding that, if a formal procedure is inside a
package body then its specification statement must be a refinement of that in the package specification,
or if a formal procedure is a subunit then its specification statement must be a refinement of that in the stub.
If a formal procedure is inside a package specification then it is added to the package specification environment. 
There are therefore three cases to consider.
}\epar

\bpar{
Case 1. If the formal procedure is in a package specification then add it to the package specification environment.
}\epar

=SPCZ  form_proc_pack_spec
=TEX

\newpage


\bpar{
Case 2. If the formal procedure is in a package body then 
output VCs demanding that its specification statement is a refinement of that in the package specification.
The form of the VCs depends on whether or not the 
specification statement of the formal procedure is a data refinement of that in the package
specification. The following schema is common to both cases.
}\epar



=SPCZ  form_proc_pack_body_common
=TEX


\bpar*{
Case 2.1. The specification statement of the formal procedure is {\it not} a data refinement
of that in the package specification.
}\epar*

=SPCZ  form_proc_pack_body
=TEX

\bpar*{
Case 2.2. The specification statement of the formal procedure {\it is} a data refinement
of that in the package specification.
}\epar*

\bpar*{
VCs for this data refinement are achieved by the tool transforming the
specification statement in the package specification ($Spec_3$),
which is in abstract terms, to a specification statement in concrete terms
($Spec_5$). The usual VC generation algorithm can then be used, demanding
that the specification statement in the package body ($Spec$) is a refinement
of $Spec_5$.
}\epar*

\bpar*{
$Spec_3$ is transformed into $Spec_5$ as follows.
Firstly any {\it auxiliary} variable $A$ appearing in the precondition or
postcondition (of $Spec_3$) that is {\it not} in the frame must be added to the
frame and a predicate $A = A_0$ conjoined to the postcondition.
This new specification statement is $Spec_6$.
The concrete variables are then added to the frame, the auxiliary variables
removed from the frame, and the auxiliary variables removed from the
precondition and postcondition by basically quantifying over them.
}\epar*

\bpar*{
$aux\_vars_0$ is obtained from the set of Z declarations $aux\_vars$ by subscripting
each variable to the left of the $:$ with zero.
$frame\_aux\_conc_0$ and $add\_aux_0$ are obtained from $frame\_aux\_conc$ and $add\_aux$
by subscripting each variable by zero. 
}\epar*


=SPCZ  form_proc_pack_body_aux
=TEX

\newpage

\bpar{
Case 3. If the formal procedure is a subunit then
output VCs demanding that its specification statement is a refinement of that in the stub.
}\epar




=SPCZ  form_proc_subunit
=TEX


\bpar{
Bringing the above cases together.
}\epar

=SPCZ  form_proc
=TEX

\newpage
\subsection{The SID function curr\_form\_proc}

\bpar{
The SID function $curr\_form\_proc$ adds the $Formal\_Proc$ to the running environment so that if it is
part of a formal procedure body then
VCs can be output which demand that the code in its body is a refinement of its
specification statement (this is done by the SID function $vcs\_body$ in the section on subprogram bodies - section 12).
}\epar

=SPCZ  curr_form_proc
=TEX


\section{SPARK functions ({\it function\_specification})}

\subsection{SID functions}



\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
function\_specification = \\
function designator $< subunit\_inf >$ $< new\_scope\_fun\_inf >$ $< stub >$
return type\_mark $< inf\_fun >$, \\
function designator $< subunit\_form >$ $< new\_scope\_fun\_form >$ $< stub >$ return type\_mark
function\_specification\_statement $< curr\_form\_fun >$ $< stub\_spec\_fun >$ $< form\_fun >$, \\
function designator $< subunit\_inf >$ $< new\_scope\_fun\_inf >$ $< stub >$ formal\_part
return type\_mark $< inf\_fun >$, \\
function designator $< subunit\_form >$ $< new\_scope\_fun\_form >$ $< stub >$ formal\_part
return type\_mark function\_specification\_statement $< curr\_form\_fun >$ \\
$< stub\_spec\_fun >$ $< form\_fun >$;
}\epar

\subsection{The SID function new\_scope\_fun\_inf}

\bpar{
The SID function $new\_scope\_fun\_inf$ adds a new block to the running environment on encountering an informal function.
}\epar

=SPCZ  new_scope_fun_inf
=TEX


\subsection{The SID function new\_scope\_fun\_form}

\bpar{
The SID function $new\_scope\_fun\_form$ adds a new block to the running environment on encountering a formal function.
}\epar

=SPCZ  new_scope_fun_form
=TEX

\subsection{The SID function stub\_spec\_fun}

\bpar{
The global variable $FORM\_FUN$ holds the current $Formal\_Fun$.
}\epar

=SPCZ  FORM_FUN
=TEX



\bpar*{
The formal function contains a specification statement.
Schema names in the concrete frame of this specification statement must have been replaced
by variable names as described in section 6.2.1.
}\epar*

\bpar{
The SID function $stub\_spec\_fun$ adds the specification statement of a formal function stub to the subunit environment.
}\epar

=SPCZ  stub_spec_fun
=TEX


\subsection{The SID function inf\_fun}

\bpar{
The global variable $INF\_FUN$ holds the current $Informal\_Fun$.
}\epar

=SPCZ  INF_FUN
=TEX


\bpar{
Every Ada function gives rise to a Z axiomatic description of the function being output to the Z document;
informal functions give rise to an axiomatic description consisting of just a declaration (no predicate).
Thus if the Z document is to type-check then all functions in the literate script must have different names.
This ensures that when proving a VC involving a function call, the correct axiomatic description is used.
This problem arises because of the nested structure of Ada being projected onto the flat structure of Z.
The SID function $inf\_fun$ deals with informal functions while $formal\_fun$ (specified later in this section)
deals with formal functions. 
}\epar





\bpar{
An informal function is translated, using an axiomatic description, as a member of the given set
$INFORMAL\_FUNCTION$. This means that the Z document will not type-check if an informal
function name clashes with the name of some other Z object and helps
to prevent the use of informal function in expressions that are handled formally.
The following function $inf\_fun\_decl$ produces the Z declaration for the axiomatic description.
}\epar

=SPCZ  informal_function
=TEX

=SPCZ  inf_fun_decl
=TEX


\bpar{
The specification of the SID function $inf\_fun$ is split into two cases.
}\epar

\bpar{
Case 1. If the informal function  is in a package specification then add it to the package specification environment.
}\epar

=SPCZ  inf_fun_pack_spec
=TEX


\bpar{
Case 2. If the informal function is not in a package specification then output an axiomatic description (no predicate)
to the Z document. The SID function $inf\_fun\_\-otherwise$ which does this uses the function $trans\_informal\_fun$
which translates the informal function to Z and creates the Z axiomatic description.
}\epar

=SPCZ  trans_informal_fun
=TEX

=SPCZ  inf_fun_otherwise
=TEX


\bpar{
Bringing the two cases together.
}\epar

=SPCZ  inf_fun
=TEX

\subsection{The SID function form\_fun}

\bpar{
The SID function $form\_fun$ is called on encountering a formal function. As well as outputting a Z axiomatic description
to the Z document (this time with a predicate part) it also outputs VCs in a similar way to that for procedures.
The SID function $form\_fun$ is therefore similar to the SID function $form\_proc$;
if a formal function is inside a
package body then its specification statement must be a refinement of that in the package specification,
if a formal function is a subunit then its specification statement must be a refinement of that in the stub.
If a formal function is inside a package specification then it is added to the package specification environment.
In all other cases just a Z axiomatic description is output. 
There are therefore four cases to consider.
}\epar

\bpar{
Case 1. If the formal function is inside a package specification then add it to the package specification environment.
}\epar

=SPCZ  form_fun_pack_spec
=TEX


\bpar{
Case 2. If the formal function is inside a package body then first output a Z axiomatic description of the function
and then output VCs demanding that the specification statement of the function
must be a refinement of that in the package specification.
The Z axiomatic description is calculated by the function $trans\_formal\_fun$.
The Z translation of the formal function has up to two arguments: one corresponding to the global dependencies of the
Ada function, if any, and one corresponding to the Ada formal parameters, if any. 
For example, a function specified as: 


=GFT Compliance Notation Example
function F (X : INTEGER; Y : BOOLEAN) return BOOLEAN
˜ [PRE, POST]
=TEX

will be translated as:

¹IZAX 
F: (INTEGER ¸ BOOLEAN) ­ BOOLEAN
÷
µ X : INTEGER; Y : BOOLEAN · PRE ´ POST
°


and a function specified as: 

=GFT Compliance Notation Example
function G (X : INTEGER; Y : BOOLEAN) return BOOLEAN
˜ A, B, C[PRE, POST]
=TEX

where the program variables, {\tt A} and {\tt B}, have Ada types, {\tt ATYPE} and {\tt BTYPE}, respectively
and the auxiliary variable $C$ is declared as a member of the Z set $CSET$, will be translated as:
}\epar


¹IZAX 
G: (ATYPE ¸ BTYPE ¸ CSET) ­ (INTEGER ¸ BOOLEAN) ­ BOOLEAN
÷
µ A : ATYPE; B : BTYPE; C : CSET· 
	µ X : INTEGER; Y : BOOLEAN · PRE ´ POST
°

\bpar*{
Several auxiliary functions are used by $trans\_formal\_fun$. 


The auxiliary function $fun\_sig$ produces the signature of a total function given a sequence of
formal parameter sets and a return set.
If the sequence of formal parameter sets is empty it produces the
signature for a member of the return set.
The latter case handles Ada functions without formal and/or global parameters.
}\epar*

=SPCZ  fun_sig
=TEX


\bpar*{
The auxiliary function $z\_forall\_opt$ is used to form universally quantified Z predicates
as necessary.
}\epar*

=SPCZ  z_forall_opt
=TEX


\bpar*{
The auxiliary function $par\_tmark$ extracts the type mark from an Ada parameter
specification and returns its translation into Z. For example, it maps
{\tt X : INTEGER} into $INTEGER$.
}\epar*

=SPCZ  par_tmark
=TEX


\bpar*{
The auxiliary function $var\_sig$ extracts from the environment the type information
about a variable in the list of global dependencies of a function.
This is the Z translation of the type mark in the case of a program
variable and the right-hand side of the declaration in the case of an auxiliary variable.
}\epar*

=SPCZ  var_sig
=TEX


\bpar*{
The auxiliary function $fun\_decl$
calculates the Z declaration for the translation of the Ada function.
}\epar*

=SPCZ  fun_decl
=TEX





\bpar*{
The auxiliary function $z\_par\_decl$ forms a Z declaration from an Ada parameter specification.
For example, it maps {\tt X : INTEGER} to $X : INTEGER$.
}\epar*

=SPCZ  z_par_decl
=TEX


\bpar*{
The auxiliary function $z\_var\_decl$ forms the Z declaration for a Z variable (using
$var\_sig$ to extract the necessary information from the environment):
}\epar*

=SPCZ  z_var_decl
=TEX


\bpar*{
The function $trans\_formal\_fun$ assumes that the only free variables in $pre$ and $post$ are
the formal parameters and global dependencies. Hence the function is partial.
}\epar*

=SPCZ  trans_formal_fun
=TEX


\newpage



=SPCZ  form_fun_pack_body
=TEX


\bpar{
Case 3. If the formal function is a subunit then first output a Z axiomatic description of the function
and then output VCs demanding that the specification statement of the function
must be a refinement of that in the stub. The global dependencies
declared for the subunit must be the same as those declared for the stub.
}\epar

\newpage



=SPCZ  form_fun_subunit
=TEX

\bpar{
Case 4. In all other cases just output a Z axiomatic description of the function.
}\epar

=SPCZ  form_fun_otherwise
=TEX


\bpar{
Bringing the four cases together.
}\epar

=SPCZ  form_fun
=TEX


\subsection{The SID function curr\_form\_fun}

\bpar{
The SID function $curr\_form\_fun$ adds the $Formal\_Fun$ to the running environment so that if it is
part of a formal function body then
VCs can be output which demand that the code in its body is a refinement of its
specification statement (this is done by the SID function $vcs\_body$ in the section on subprogram bodies - section 12).
}\epar

=SPCZ  curr_form_fun
=TEX


\section{SPARK formal parameters ({\it formal\_part})}

\subsection{SID functions}

\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
formal\_part = ord parlist $< formal\_part >$ crd;
}\epar

\subsection{The SID function formal\_part}

\bpar{
The global variable $FORMALS$ holds the formal parameters of the current subprogram.
}\epar

=SPCZ FORMALS
=TEX

\bpar{
The SID function $formal\_part$ adds the formal parameters to the running environment.
They will ultimately appear as local declarations in the VCs.
}\epar

=SPCZ formal_part
=TEX

\section{SPARK subprogram bodies ({\it subprogram\_body})}

\subsection{SID functions}

\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
subprogram\_body = \\
procedure\_specification is subprogram\_implementation $< update\_envs\_proc >$ \\
$< add\_proc\_env >$ $< end\_scope >$, \\
function\_specification is subprogram\_implementation $< end\_scope >$; \\
\ \\
subprogram\_implementation = \\ 
$< subprogram\_implementation >$
  declarative\_part \\
  sequence\_of\_statements
  $< vcs\_body >$
  end designator semi;

}\epar

\subsection{The SID function update\_envs\_proc}

\bpar{
If the formal procedure has been introduced by expanding a k\_slot then the SID function $update\_envs\_proc$
updates the subunit, dec label and spec label environments (all three need updating).
This is necessary because these environments may have been incremented (perhaps many times) before
the k\_slot has been expanded.
The information from expanding the k\_slot now needs to be recorded in these environments.
Only those stubs, k\_slots and specification statements that are in the scope of the original k\_slot are affected.
The formal procedure is added to the $formal\_procs$ components of the environments. 
}\epar

=SPCZ update_subunit_env_proc
=TEX

=SPCZ update_dec_env_proc
=TEX

=SPCZ update_spec_env_proc
=TEX

=SPCZ update_envs_proc
=TEX

\subsection{The SID function add\_proc\_env}
\bpar{
The SID function $add\_proc\_env$ adds the formal procedure to the running environment so that
subsequent subprograms can call it.
}\epar

=SPCZ add_proc_env
=TEX

\subsection{The SID function subprogram\_implementation}
\bpar{

 The SID function {\it subprogram\_implementation}
sets {\it body\_flag} to {\it True}.
}\epar

=SPCZ subprogram_implementation
=TEX


\subsection{The SID function vcs\_body}

\bpar{
The global variable $SEQ\_STMTS$ holds the current sequence of statements.
}\epar

=SPCZ SEQ_STMTS
=TEX


\bpar{
The SID function $vcs\_body$ outputs VCs demanding that the sequence of statements inside the body of
a formal subprogram is a refinement of its formal specification. There are two cases to consider.
In both cases, if any of the local variables of the subprogram have initial values,
then the precondition  of the formal specification is strengthened by conjoining it with predicates
asserting that each initialised local variable is equal to its initial value.
}\epar

\bpar{
Case 1. Sequence of statements inside a formal procedure.
}\epar

=SPCZ vcs_body_proc
=TEX
 

\bpar{
Case 2. Sequence of statements inside a formal function.
}\epar

=SPCZ vcs_body_fun
=TEX

\bpar{
Bringing the two cases together.
}\epar

=SPCZ vcs_body
=TEX

\section{SPARK packages ({\it package\_specification})}

\subsection{SID functions}



\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
package\_specification = \\
package identifier $< new\_scope\_pack\_spec >$ is visible\_part end \\
simple\_name $< end\_scope >$ update\_envs\_pack\_spec, \\
package identifier $< new\_scope\_pack\_spec >$ is visible\_part private private\_part end \\
simple\_name $< end\_scope >$ update\_envs\_pack\_spec;
}\epar



\bpar*{
visible\_part = \\
visdec, \\
visdec visible\_part; \\
\ \\
visdec = k\_slot $< k\_slot\_dec >$ $< update\_envs\_k\_slot >$, \\
basic\_declarative\_item, \\
subprogram\_declaration, \\
auxiliary z\_decl $< aux\_var >$ semi, \\
renaming\_declaration; \\
\ \\
private\_part = \\
pdec, \\
pdec private\_part; \\
\ \\
pdec = \\
k\_slot $< k\_slot\_dec >$ $< update\_envs\_k\_slot >$, \\
basic\_declarative\_item, \\
renaming\_declaration; \\
}\epar*

\bpar*{
package\_body = \\
package bbody simple\_name $< new\_scope\_pack\_body >$ $<subunit\_inf>$ \\
is package\_implementation end \\
simple\_name semi $< end\_scope >$;
}\epar*



\bpar*{
package\_implementation = \\
declarative\_part, \\
declarative\_part begin package\_initialization, \\
using\_list declarative\_part\_1 begin package\_initialization $< vcs\_aux\_initial >$; \\
\ \\
using\_list = \\
using\_dec, \\
using\_dec using\_list; \\
\ \\
using\_dec = using basic\_dec\_list implement z\_id by z\_pred $< using\_dec >$ semi; \\
\ \\
basic\_dec\_list = \\
basic\_dec, \\
basic\_dec basic\_dec\_list;
}\epar*



\bpar*{
basic\_dec = \\
constant\_declaration $< basic\_declaration >$, \\
variable\_declaration $< adj\_var\_decl >$ $< add\_var\_init\_env >$ $< var\_pack\_spec >$ $< update\_envs\_var >$ $< add\_var\_env >$, \\
type\_declaration $< basic\_declaration >$, \\
subtype\_declaration $< basic\_declaration >$, \\
pragma;
}\epar*

\bpar*{
compilation\_unit = \\
context\_clause pragma\_list library\_unit $< end\_scope\_comp\_unit >$, \\
context\_clause pragma\_list secondary\_unit $< end\_scope\_comp\_unit >$, \\
pragma;
}\epar*



\bpar*{
context\_clause = \$, \\
                  with\_clause, \\
                  with\_clause references\_clause, \\
                  references\_clause; \\
\ \\
references\_clause = references simple\_name\_list semi;
}\epar*

\bpar*{
with\_clause = with simple\_name\_list semi; \\
\ \\
simple\_name\_list = \\
simple\_name $< new\_scope\_with >$, \\
simple\_name $< new\_scope\_with >$ comma simple\_name\_list;
}\epar*

\subsection{The SID function new\_scope\_pack\_spec}



\bpar{
On encountering a package specification the SID function $new\_scope\_pack\_spec$ adds a new block to the
running environment. $new\_scope\_pack\_spec$ also creates a new package in the package environment
with the $zmod$ field identifying the name of the current Z module.
}\epar

=SPCZ Empty_Package
=TEX

=SPCZ new_scope_pack_spec
=TEX


\subsection{The SID function new\_scope\_pack\_body}

\bpar{
On encountering a package body the SID function $new\_scope\_pack\_body$ adds a new block to the running environment
which contains the variables from the package specification;
these are visible to the package body
and must therefore be made available for VC generation.
}\epar





\bpar*{
$new\_scope\_pack\_body$ makes the Z module that was current when the package specification was encountered
a parent of the current module. This makes the constants and types and any supporting Z paragraphs of the
package available for use in developing the package body.
This also makes any Z modules associated with the {\tt with} clause of the package specification become
ancestors of the current module.
}\epar*

=SPCZ new_scope_pack_body
=TEX


\subsection{The SID function new\_scope\_with}

\bpar{
On encountering a {\tt with} clause the SID function $new\_scope\_with$ adds a new block to the running environment
which contains the variables and formal procedures from the package specification; the {\tt with} clause
makes these visible and must therefore be made available for VC generation.
$new\_scope\_with$ also outputs the Z translation of the
constants and types and Z axiomatic descriptions of the functions in the package specification to the Z document.
However in SPARK there are no {\tt use} clauses.
This means that all the identifiers declared in the package
specification must be prefixed with the package name.
This must be done before the new block is added to the environment and before the
translation of the constants and types and the construction of the Z axiomatic descriptions.
}\epar

\newpage



\bpar{
The following function $new\_ids$ finds the new identifiers declared in a package specification
which need prefixing.
The function $prefix$ (below $new\_ids$) carries out this prefixing.
Every identifier in its third argument (a package specification)
that appears in its second argument (the new identifiers calculated by $new\_ids$)
is prefixed by its first argument (the name of the package).
The function $prefix$ must also prefix any attributes of the identifiers calculated by $new\_ids$.
Also the Z identifiers corresponding to those calculated by $new\_ids$ that appear in
the specification statements (including attributes, initial variables and
record update functions) must be prefixed.
Finally, in addition to the identifiers calculated by $new\_ids$,
any occurrence of an auxiliary variable must be prefixed (including initial
variables).
}\epar

\bpar*{
As an example consider the package specification from [1]:
}\epar*



\begin{verbatim}
         package PACK_P is
            I : INTEGER;
            type COLOUR is (RED, BLUE, GREEN);
            procedure SQRT (X : INTEGER; Y : out INTEGER)
\end{verbatim}
\hspace*{2.5cm} $\Delta\ Y\ [X \geq 0,\ \ Y**2 \leq X < (Y + 1)**2]$;
\begin{verbatim}
            procedure CUBE_ROOT (N : in out INTEGER)
\end{verbatim}
\hspace*{2.5cm}  $\Delta\ N\ [N \geq 0,\ \ N**3 \leq N_0 < (N + 1)**3]$;
\begin{verbatim}
            function NEXT_COLOUR (C : COLOUR) return COLOUR
\end{verbatim}
\hspace*{2.5cm} $\Xi$ \\
\hspace*{2.5cm} $[true,$ \\
\hspace*{2.5cm} $C \neq COLOURoLAST \land$ \\
\hspace*{2.5cm} $NEXT\_COLOUR(C) = COLOURoSUCC(C)$ \\
\hspace*{2.5cm} $\lor$ \\
\hspace*{2.5cm} $C = COLOURoLAST \land$ \\
\hspace*{2.5cm} $NEXT\_COLOUR(C) = COLOURoFIRST]$;
\begin{verbatim}
            function PLUS_ONE (X : INTEGER) return INTEGER;
         end PACK_P;
\end{verbatim}

\bpar*{
The function $new\_ids$ gives: \\
\ \\
\{ {\tt I, COLOUR, RED, BLUE, GREEN, SQRT, CUBE\_ROOT, NEXT\_COLOUR, PLUS\_ONE} \} \\
\ \\
Note how the names of the formal parameters are not recorded since these can not be referred to outside the package.
The function $prefix$ on the above package specification therefore gives:
}\epar*

\newpage



\begin{verbatim}
         package PACK_P is
            PACK_P.I : INTEGER;
            type PACK_P.COLOUR is (PACK_P.RED, PACK_P.BLUE, PACK_P.GREEN);
            procedure PACK_P.SQRT (X : INTEGER; Y : out INTEGER)
\end{verbatim}
\hspace*{2.5cm} $\Delta\ Y\ [X \geq 0,\ \ Y**2 \leq X < (Y + 1)**2]$;
\begin{verbatim}
            procedure PACK_P.CUBE_ROOT (N : in out INTEGER)
\end{verbatim}
\hspace*{2.5cm}  $\Delta\ N\ [N \geq 0,\ \ N**3 \leq N_0 < (N + 1)**3]$;
\begin{verbatim}
            function PACK_P.NEXT_COLOUR (C : PACK_P.COLOUR) return PACK_P.COLOUR
\end{verbatim}
\hspace*{2.5cm} $\Xi$ \\
\hspace*{2.5cm} $[true,$ \\
\hspace*{2.5cm} $C \neq PACK\_Po\_COLOURoLAST \land$ \\
\hspace*{2.5cm} $PACK\_Po\_NEXT\_COLOUR(C) = PACK\_Po\_COLOURoSUCC(C)$ \\
\hspace*{2.5cm} $\lor$ \\
\hspace*{2.5cm} $C = PACK\_Po\_COLOURoLAST \land$ \\
\hspace*{2.5cm} $PACK\_Po\_NEXT\_COLOUR(C) = PACK\_Po\_COLOURoFIRST]$;
\begin{verbatim}
            function PACK_P.PLUS_ONE (X : INTEGER) return INTEGER;
         end PACK_P;
\end{verbatim}
  
\bpar{
The formal specifications of $new\_ids$, $prefix$ and $new\_scope\_with$.
}\epar

=SPCZ new_ids
=TEX

=SPCZ prefix
=TEX

\bpar*{
The function $z\_prefix$ is the analogue of $prefix$ for a Z module.
It is intended to indicate the generation of the sequence of paragraphs required to produce
a Z module obtained from another Z module by prefixing all the indicated names with the package name.
In $new\_scope\_with$ the (prefixed) Z translations of the functions in the package are appended to
the resulting Z module and the result is inserted at the beginning of the Z document.
The position of the Z parents paragraph identifies for traceability purposes the point in the
Z document at which the new module was produced.
}\epar*

=SPCZ z_prefix
=TEX

=SPCZ new_scope_with
=TEX


\bpar*{
$new\_scope\_with$ should be relaxed as follows.
If the package named
in the {\tt with} clause has not been processed by the tool
(and so the tool has no record of it) then $new\_scope\_with$
should continue without doing anything.
This allows for example, input-output packages to be used informally in a
literate script and just be available for the compilation of the extracted
SPARK program.
However this does raise a soundness issue. The program that has the
{\tt with} clause could generate VCs that reference things in the package.
Another part of the literate script could generate Z entities of the same
name which could be (incorrectly) used to prove the VCs.
Normally this problem is caught because the Z document will not type-check
(two occurrences of the same name), but if $new\_scope\_with$ is relaxed
this does not happen.
A solution is to ensure that Z entities of the same name can not be generated
from elsewhere in the literate script. This is achieved in the ICL tool
by translating the dot in a package selection to a {\it lower case} o,
with all other Z identifiers in upper case (apart from apostrophe in attributes
which the tool translates as lower case v). 
}\epar*

\subsection{The SID function update\_envs\_pack\_spec}
\bpar{
The SID function {\it update\_envs\_pack\_spec}
mimics the functionality of {\it new\_scope\_with}
when a package specification is encountered inside a package
or subprogram body. The prefixed Z paragraphs for the
inner package are added to the current Z module and the prefixed
variables and procedures of the package are added to the resulting environment.


The formal definition of {\it update\_envs\_pack\_spec} is as follows:
}\epar

=SPCZ update_envs_pack_spec
=TEX




\subsection{The SID function end\_scope\_comp\_unit}

\bpar{
At the start of each literate script the running environment
$ENV$ is set to $ENV0$ which contains a single block (as described in subsection 3.5).
At the end of each compilation unit $ENV$ must revert back to a single block;
this is carried out by the SID function $end\_scope\_comp\_unit$.
The SID function $end\_scope$ can not be used because many new blocks could have been opened as a result of a {\tt with} clause
of the compilation unit.
}\epar  

=SPCZ end_scope_comp_unit
=TEX


\subsection{The SID function aux\_var}

\bpar{
The global variable $AUX\_VAR$ holds the current auxiliary variable declaration.
}\epar

=SPCZ AUX_VAR
=TEX

\bpar{
On encountering an auxiliary variable declaration, the SID function $aux\_var$ adds the declaration
to the package specification environment.
}\epar


=SPCZ aux_var
=TEX


\subsection{The SID function using\_dec}

\bpar{
The global variable $USING\_DEC$ holds the current {\it using} declaration.
It needs to hold the following information: \\
1. $aux$ - the auxiliary variable that is being made concrete (appears between the key
words {\it implement} and {\it by}). \\
2. $concrete\_vars$ - the Ada variables introduced to implement the auxiliary variable.
These variable declarations will appear among the declarations between the key words {\it using}
and {\it implement} (the other declarations, if any, will be constant, type or subtype declarations). The variable declarations are
represented abstractly as the {\tt \itshape Var\_Decl}s resulting from the
SID function {\tt\itshape adj\_var\_decl} called when the concrete variable declaration
was processed. \\
3. $invariant$ - the relationship between the auxiliary and concrete variables (it appears after
the key word {\it by}). 
}\epar

=SPCZ USING_DEC
=TEX


\bpar{
On encountering a {\it using} declaration, the SID function $using\_dec$ adds the declaration
to the running environment.
}\epar

=SPCZ using_dec
=TEX


\subsection{The SID function vcs\_aux\_initial}



\bpar{
The SID function $vcs\_aux\_initial$
outputs VCs demanding that elaboration of the package body will obtain values for the package
variables that satisfy all the invariants introduced in the {\it using} clauses of the package body.
According to the Ada rules for elaboration of a package body, the values of the variables are
established by first elaborating the variable declarations and then executing the sequence of
statements comprising the package initialisation.
Elaboration of the variable declarations means each variable declared in the package with an
initial values is equal to that value. The VCs must therefore demand that execution of the package
initialisation achieves the invariants given a precondition asserting these equalities. 
}\epar

=SPCZ vcs_aux_initial
=TEX


\section{SPARK renaming declarations ({\it renaming\_declaration})}

\subsection{SID functions}

\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
renaming\_declaration = \\
        function operator\_symbol formal\_part return type\_mark renames 
        simple\_name dot operator\_symbol semi, \\
        procedure\_specification\_1 renames simple\_name dot simple\_name $< renames\_proc >$ semi, \\
        function\_specification\_1 renames simple\_name dot simple\_name $< renames\_fun >$ semi;
}\epar

\subsection{The SID function renames\_proc}

\bpar{
In a renaming declaration such as \\
\ \\
{\tt procedure P (X : out INTEGER) renames PACK.P} \\
\ \\
the global variable $RENAMES\_NEW$ holds the new name, in this case {\tt P}.
The global variable $RENAMES\_OLD$ holds the old name, in this case
{\tt PACK.P}; the component $pack$ holds {\tt PACK} and $old$ holds {\tt P}.
}\epar

=SPCZ RENAMES_OLD
=TEX

=SPCZ RENAMES_NEW
=TEX


\bpar{
If the procedure being renamed is a formal procedure, that is if its declaration
includes a specification statement, then the renamed procedure can be treated as
a formal procedure with a specification statement obtained by prefixing all names
with the name of the package containing the formal procedure.
If the renaming declaration occurs inside a package specification then we add the
new formal procedure to the package environment, otherwise we add it to the running environment.
If the renaming declaration is inside a package specification, then the formal procedure
must not be declared in the package currently being specified.
}\epar

=SPCZ renames_proc_common
=TEX

=SPCZ renames_proc_pack_spec
=TEX

=SPCZ renames_proc_otherwise
=TEX

=SPCZ renames_proc
=TEX




\bpar{
On encountering the renaming of a function,  
the SID function $renames\_fun$ outputs a Z abbreviation definition
linking the two names.
Note that the Z document will not type-check if the renaming declaration occurs inside the
package specification in which the renamed procedure is declared.
}\epar

=SPCZ renames_fun
=TEX


\section{SPARK stubs and subunits ({\it body\_stub})}

\subsection{SID functions}


\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
body\_stub = \\ 
$< begin\_stub >$ procedure\_specification is separate semi $<update\_envs\_proc>$ \\
 $< add\_proc\_env >$ $< end\_scope >$ $< end\_stub >$, \\
$< begin\_stub >$ function\_specification is separate semi $< end\_scope >$ $< end\_stub >$, \\
package bbody simple\_name $<pack\_stub>$ is separate semi, \\
procedure\_specification semi, \\
function\_specification semi; \\
\ \\
proper\_body = \\
subprogram\_body, \\
pbody\_kslot $<pack\_stub>$; \\
\ \\
subunit = \\
separate ord name $< new\_scope\_subunit >$ crd proper\_body $< end\_scope >$, \\
separate ord name $< new\_scope\_subunit >$ crd package\_body $< end\_scope >$;
}\epar

\subsection{The SID function begin\_stub}

\bpar{
On encountering a subprogram stub the SID function $begin\_stub$ sets $stub\_flag$ in the running environment to $True$.
}\epar

=SPCZ begin_stub
=TEX


\subsection{The SID function end\_stub}

\bpar{
At the end of a subprogram stub the SID function $end\_stub$ sets $stub\_flag$ to $False$.
}\epar

=SPCZ end_stub
=TEX

\subsection{The SID function new\_scope\_subunit}



\bpar{
When a SPARK subunit is encountered a Z module is output corresponding to the Z document at the
point where the stub was encountered.
The Z specification of this process appears in the sections
on SPARK functions and procedures since the name of the subprogram is required before the subunit
environment can be accessed. Consequently the SID function $new\_scope\_subunit$ below sets the flags but does
not output the Z module.
}\epar

=SPCZ new_scope_subunit
=TEX

\subsection{The SID function pack\_stub}

\bpar{
The SID function {\it pack\_stub} is the analogue of {\it stub} for package stubs
and package k-slots. 

{\it IDENT} holds the name of the inner package.
}\epar

=SPCZ pack_stub
=TEX

\section{Web clauses ({\it web\_clause})}

\subsection{SID functions}



\bpar{
SID functions are called at the following points in the syntax: \\
\ \\
web\_clause = \\
z $< z\_copy >$, \\
compilation, \\
comp\_label replacedby compilation, \\
ppart\_label $< new\_scope\_dec\_replace >$ replacedby private\_part \\
$< update\_envs\_remove\_declabel >$ $< end\_scope >$, \\
vpart\_label $< new\_scope\_dec\_replace >$ replacedby visible\_part \\
$< update\_envs\_remove\_declabel >$ $< end\_scope >$, \\
dec\_label $< new\_scope\_dec\_replace >$ replacedby dec dp1 \\
$< update\_envs\_remove\_declabel >$ $< end\_scope >$, \\
stmt\_label $< new\_scope\_stmt\_label >$ replacedby sequence\_of\_statements \\
$< end\_scope\_stmt\_label >$, \\
spec\_label $< new\_scope\_speclabel >$ refinedby sequence\_of\_statements \\
$< vcs\_speclabel >$ $< end\_scope\_speclabel >$, \\
$< new\_scope\_speclabel >$ refinedby sequence\_of\_statements \\
$< vcs\_speclabel >$ $< end\_scope\_speclabel >$, \\
spec\_label $< new\_scope\_speclabel >$ replacedby sequence\_of\_statements \\
$< end\_scope\_speclabel >$, \\
$< new\_scope\_speclabel >$ replacedby sequence\_of\_statements $< end\_scope\_speclabel >$, \\
any\_label arbitrary\_ada, \\
arbitrary\_ada, \\
ord name $<new\_scope\_subunit>$ crd replacedby package\_body;
}\epar

\subsection{The SID function z\_copy}

\bpar{
The global variable $ZPARA$ holds the current Z paragraph.
}\epar

=SPCZ ZPARA
=TEX


\bpar{
Z paragraphs that appear in the literate script are simply copied into the Z document; this is carried out by the SID
function $z\_copy$.
}\epar

=SPCZ z_copy
=TEX

\subsection{The SID function new\_scope\_dec\_replace}

\bpar{
When a dec label is expanded the SID function $new\_scope\_dec\_replace$ adds a new block to the running environment
which basically holds all the information that was present when the original k\_slot was encountered.
}\epar

=SPCZ new_scope_dec_replace
=TEX


\subsection{The SID function update\_envs\_remove\_declabel}

\bpar{
The SID function $update\_envs\_remove\_declabel$
removes the dec label from subunit, dec label and spec label environments (all three need updating) once the
dec label has been expanded.
}\epar 

=SPCZ update_subunit_env_remove_declabel
=TEX

=SPCZ update_dec_env_remove_declabel
=TEX

=SPCZ update_spec_env_remove_declabel
=TEX

=SPCZ update_envs_remove_declabel
=TEX


\subsection{The SID function new\_scope\_speclabel}

\bpar{
When a spec label is being refined or simply expanded the SID function $new\_scope\_speclabel$ adds a new block
to the running environment and makes a record of the spec label; the information in the spec label environment can then
be accessed as the sequence of statements is processed.
}\epar

=SPCZ new_scope_speclabel
=TEX

\subsection{The SID function vcs\_speclabel}

\bpar{
The SID function $vcs\_speclabel$ outputs VCs demanding that the sequence of statements is a refinement of the specification
statement denoted by the spec label.
}\epar

=SPCZ vcs_speclabel
=TEX


\subsection{The SID function end\_scope\_speclabel}

\bpar{
After the spec label has been refined or expanded the SID function $end\_scope\_speclabel$ removes the block
from the running environment that was opened when the spec label was encountered ($new\_scope\_speclabel$)
and also removes the spec label from the spec label environment.
}\epar

=SPCZ end_scope_speclabel
=TEX


\subsection{The SID functions new\_scope\_stmt\_label and end\_scope\_stmt\_label}

\bpar{
Expansion of stmt labels is treated the same as the expansion of spec labels.
}\epar

=SPCZ new_scope_stmt_label
=TEX

=SPCZ end_scope_stmt_label
=TEX


\section{Informal parts of the specification}

\subsection{Checks}

\bpar{
The compliance notation tool must make the following soundness checks.
The numbering is not sequential for historical reasons.
}\epar


\bpar*{
1. When calling the function $vcs$ with a $Speclab$ and sequence of statements $st$: \\
\ \\
(a) The variables that may be changed in $st$ must be a subset of the frame
in the $Spec$ of $Speclab$. The variables that may be changed by a
sequence of statements may be determined as follows:
(a) an assignment statement may change the variable in its left-hand side;
(b) a specification statement may change the variables in its frame;
(c) a procedure call may change the variables obtained by substitution of actual parameters
for formal parameters in the frame of its specification statement and the global variables in the frame. \\
\ \\
(b) if $st$ contains a {\tt return} statement then $formal\_body\_flag$ must be $True$. \\
\ \\
(c) if $st$ contains an {\tt exit} statement then $till\_flag$ must be $True$. \\
\ \\
(d) Any procedure call in $st$ must have a corresponding $Formal\_Proc$ in the $Speclab$.
}\epar*



\bpar*{
2. The Ada program extracted from the literate script must compile
and the Z document produced must type-check.
If the extracted program contains k\_slots and specification statements that have not been expanded
or refined then these can simply be removed or replaced with {\tt null} whichever is appropriate.
Also an {\it auxiliary} variable declaration (in a package specification)
is simply removed, and a {\it using} declaration (in a package body)
is replaced by the Ada declarations between the key words {\it using}
and {\it implement}. (This is a slight diversion to [3] where the
Ada declarations replace the auxiliary variable declaration.)
Any {\it references} clauses must be removed.
The program can then be compiled.
Also the extracted SPARK program must retain any legal SPARK annotations
that were in the literate script.
}\epar*

\bpar*{
3. The closest-containing compound statement of an {\tt exit\ when\ G} statement must be a loop statement.
Also the closest-containing compound statement of an {\tt exit} statement (no condition {\tt G})
must be an {\tt if} statement with no {\tt elsif} or {\tt else} parts; the closest-containing compound statement
of this {\tt if} statement must be a loop and the {\tt exit} statement must be the last statement inside the
{\tt if} statement. (SPARK restrictions for {\tt exit} statements). \\
\ \\
4. A {\tt return} statement is only allowed within the body of a function subprogram.
The last statement in the body of a function must be either a {\tt return} statement or a {\tt case} statement
whose alternatives all end with {\tt return} statements. {\tt return} statements are not allowed anywhere else.
(SPARK restrictions for {\tt return} statements.)
}\epar*





\bpar*{
12. A package name cannot appear more than once in the same context clause. (SPARK restriction.)
}\epar*

\bpar*{
13. Semantic checks mentioned in the compliance notation syntax (appendix A).
}\epar*

\bpar*{
14. A SPARK subtype declaration with a range constraint such as
{\tt subtype WEEKDAY is DAY range MON .. FRI;} must not give rise to the
subtype being translated into Z as an empty range.
The problem can only arise in the schemas
$Basic\_Decl\_Subtype\_\-Range\_Con\_1$ and
$Basic\_Decl\_Int\_Type$
in volume 3 (a subtype declaration of a real type with a range constraint
is {\it not} translated as a Z range and so can not cause a problem).
A check must be made that the bounds of the range are static and that the
upper bound is not less than the lower bound.
}\epar*

\bpar*{
15. When renaming an operator symbol a check must be made that the new
name is the same as the old name (minus the package name). For example
$<=$ must not be allowed to rename {\tt PACK.$>=$}.
No checks are required for the renaming of subprograms.
}\epar*

\bpar*{
16. The arbitrary replacement feature (see arbitrary\_ada in the syntax
of appendix A)
can violate soundness because no
check is made on what the arbitrary text consists of.
A warning must be given to this effect. 
}\epar*



\bpar*{
17. Each literate script should contain at most one compilation unit.
}\epar*

\bpar*{
18. When an Ada expression is translated into Z, an error should be
reported if the expression mentions an informal function (even if the
resulting translation would be well-typed Z).
}\epar*

\bpar*{
19. All variables in the frame of a specification statement must be in scope when the specification
statement is introduced. This check applies both to specification statements appearing as statements
and to specification statements in procedure headers.
Function specification statements have an empty frame and so do not require this check.
}\epar*



\bpar*{
20. In a sequence of statements appearing on the right of the refinement symbol ($\sqsubseteq$),
the use of the following four statement forms is restricted:
\begin{itemize}
\item specification statement containing initial variables
\item logical constant statements
\item call of a procedure whose specification contains initial variables
\item for-loops whose bounds are not static expressions
\end{itemize}
Such statements may only appear in a position which is {\it suitable} in the
following sense:
\begin{itemize}
\item the first statement in a sequence is suitable.
\item the first statement in a branch of a conditional statement which is itself in a suitable position is also suitable.
\end{itemize}
}\epar*

\newpage



\bpar*{
This ensures that no statement with side effects can be executed before the statement in question.
}\epar*

\subsection{For loop variables and logical constants}

\bpar{
When a refinement step is encountered in a literate script, all the variables appearing in the sequence of statements
should have already been declared.
The declarations are needed in the VCs for the refinement step;
they appear as local declarations in the VCs.
In particular if the sequence of statements contains a {\tt for} loop then the {\tt for} loop variable
will be needed in the local declarations of the VCs.
However at the point the refinement step is encountered the {\tt for} loop variable will not have been declared
since it is declared on encountering the {\tt for} loop {\it statement}.
The {\tt for} loop variable will therefore not be in the environment and so will be missing from the VCs;
this will result in the VCs not type-checking (variable undeclared).
The solution is to gather up the {\tt for} loop variable into the environment as the sequence of statements
is processed.
}\epar

\bpar{
Note that for subsequent refinements of the {\tt for} loop {\it body} there is not a problem
since at that point the {\tt for} loop variable has already been declared.
The problem arises for the refinement step in which the {\tt for} loop is first introduced.
}\epar

\bpar{
A similar problem arises for logical constants.
}\epar

\bpar{
The above problem with {\tt for} loop variables
can be solved by adding an extra component,
say $current\_for\_vars$, to $Block$ to hold the
{\tt for} loop variables.
The component will be in $Block$ but not in $In\_Scope$; a similar status
therefore as $current\_formal\_proc$ for example.
The SID function $for\_param$ (in the section on SPARK loops), in addition
to what it does already, must add the {\tt for} loop variable to
the $current\_for\_vars$ component of $Block_2$ (since $for\_param$ is called
after $new\_scope\_loop$).
At the end of the sequence of statements, all the {\tt for} loop variables
will be in the $current\_for\_vars$ component of $Block_1$ (since the blocks
for the {\tt for} loops will have been closed by this stage).
The $current\_for\_vars$ then need to be added to the $vc\_pars$ component
of the $Speclab$ that is used in the call of $vcs$ in the SID functions
$vcs\_body$, $vcs\_aux\_initial$ and $vcs\_speclabel$.
The $current\_for\_vars$ component must be initialised to empty in the
SID functions that start a new scope for formal subprogram bodies
($new\_scope\_proc\_form$ and $new\_scope\_fun\_form$),
package bodies ($new\_scope\_pack\_\-body$) and
refinement steps ($new\_scope\_speclabel$). 
}\epar

\bpar{
The problem with logical constants is solved by
adding an extra component,
say\\
$current\_log\_cons$, to $Block$ to hold the logical constants.
Again the component will be in $Block$ but not in $In\_Scope$.
The SID function $add\_log\_con\_env$ (in the section on SPARK statements),
in addition to what it does already, must add the logical constant to
the $current\_log\_cons$ component of $Block_1$ (since no new block
is opened for logical constants).
At the end of the sequence of statements, all the logical constants
will be in the $current\_log\_cons$ component of $Block_1$.
The $current\_log\_cons$ then need to be added to the $vc\_log\_cons$ component
of the $Speclab$ that is used in the call of $vcs$ in the SID functions
$vcs\_body$, $vcs\_aux\_initial$ and $vcs\_speclabel$.
The $current\_log\_cons$ component must be initialised to empty in the
SID functions that start a new scope for formal subprogram bodies
($new\_scope\_proc\_form$ and $new\_scope\_fun\_form$),
package bodies\\
($new\_scope\_pack\_body$) and
refinement steps ($new\_scope\_speclabel$).
}\epar



\subsection{Syntax - k\_slots as annotations}

\bpar{
Wherever a SPARK annotation is permitted, a k\_slot
may be used to defer the actual text of the annotation.
}\epar

\section{Parts of the compliance notation not yet covered}



\bpar{
The following parts of the compliance notation have not yet been dealt with.
They can be used in the informal parts of a literate script but not in the formal parts. \\
\ \\
(a) {\tt case} statements with an {\tt others} part. \\
\ \\
(b) Real literals. \\
\ \\
(d) Character and string literals. \\
\ \\
(e) Some attributes, for example in SPARK there are attributes for both array objects and array types,
but only those for array types have been dealt with. \\
\ \\
(f) {\tt and}, {\tt or}, {\tt not} and {\tt xor} on one dimensional {\tt BOOLEAN} arrays. \\
\ \\
(g) Type conversions involving real types. \\
\ \\
(h) {\tt for} loops where the loop counter decreases (that is, uses {\tt reverse}). \\
\ \\
(i) Packages that are not at the top level of a SPARK program (packages within packages etc). \\
\ \\
(j) A discrete range that is a type mark and a range that is range attribute (expressions).
}\epar
\nocite{DRA/CIS/CSE3/SWI/WP/7/2}		% was {example}
\nocite{Sennett92a}			% was {notation}
\nocite{DRA/CIS/CSE3/SWI/1}		% was {aux}
\nocite{Foster68}				% was {sid}
\nocite{DRA/CIS(SE2)/PROJ/SWI/TR/1/1.0}	% was {user}
\nocite{zstan26}				% was {zstandard}

\bibliographystyle{fmu}
\bibliography{daz,fmu}


\begin{tabular}{ll}
\multicolumn{2}{l}{The Draft Z Standard \cite{zstan26} is available via the Internet from:}\\
			&	{\tt http://www-users.cs.york.ac.uk/~ian/zstan/}\\
\hbox to 2.5cm{\hfill or\hfill}	&	{\tt ftp://ftp.cs.york.ac.uk/hise\_reports/cadiz/ZSTAN/}
\end{tabular}

\startappendix
{ %%%% start of special set up for SID syntax
\twocolumn[\section{Compliance notation syntax}]
\makeatletter
\def\prelim@label#1{\relax}
\def\@Zfonts{\global\let\FTfonts\mathtt}
\vertbarfalse
\ftlinepenalty=9999
\ftlmargin=0em
\makeatother
The BASICS section of the SID grammar lists the terminal symbols
of the grammar.
=GFT SID
BASICS
abs
ampersand
and
arbitrary_ada
array
at
auxiliary
auxiliary_expression
bar
bbody
becomes
begin
by
case
character_literal
colon
comma
commagoesto
commaothers
comp_label
con
constant
crd
dec_label
delta
digits
div
dot
dotdot
else
elsif
end
equals
exit
fatdot
for
function
function_name
function_specification_statement
goesto
greaterequals
greaterthan
identifier
if
implement
in
is
k_slot
lessequals
lessgreat
lessthan
limited
loop
minus
mod
na  # look ahead symbol #
not
notequals
null
numeric_literal
of
or
ord
others
out
package
pbody_kslot
plus
ppart_label
ppragma
prime
private
procedure
procedure_name
procedure_specification_statement
record
references
refinedby
rem
renames
replacedby
return
reverse
rrange
semi
separate
specification_statement
spec_label
star
starstar
stmt_label
string_literal
subtype
then
till 
type
type_mark
use
using
vpart_label
when
whenothers
while
with
xor
z
z_decl
z_id
z_pred
=TEX
\newpage
\onecolumn
The RULES section of the SID grammar gives the
production rules.
The rules are indexed by references to sections in the
Ada Language Reference Manual (ALRM, \cite{AJPO83}).
=GFT SID
RULES

# identifiers and literals treated lexically #
=TEX

=GFT SID
# ALRM 2.8 #
pragma = ppragma identifier semi,
	 ppragma identifier ord argument_association arg_ass_list crd semi;

arg_ass_list = $,
	       comma argument_association arg_ass_list;

argument_association = name,
		       identifier goesto name,
		       expression,
		       identifier goesto expression;
=TEX

=GFT SID
# ALRM 3.1 #
basic_declaration =
	object_declaration,
	type_declaration,
	subtype_declaration,
	deferred_constant_declaration,
	pragma;
=TEX

=GFT SID
# ALRM 3.2 #
object_declaration =
	constant_declaration,
	variable_declaration;

constant_declaration =
      identifier_list colon constant subtype_indication becomes expression semi,
      identifier_list colon constant becomes expression semi;

variable_declaration =
      identifier_list colon subtype_indication semi,
      identifier_list colon subtype_indication becomes expression semi;

identifier_list = identifier id_list;

id_list = $, comma identifier_list;
=TEX

=GFT SID
# ALRM 3.3.1 #
type_declaration = 
	full_type_declaration,
	private_type_declaration;

full_type_declaration =
	type identifier is type_definition semi;

type_definition =
	enumeration_type_definition,
	integer_type_definition,
	real_type_definition,
	array_type_definition,
	record_type_definition;
=TEX

=GFT SID
# ALRM 3.3.2 #
subtype_declaration =
	subtype identifier is subtype_indication semi;

subtype_indication =
	type_mark constraint,
	type_mark;

# type_mark = name #
=TEX

=GFT SID
# ALRM 3.5 #
constraint =
	range_constraint,
	floating_point_constraint,
	fixed_point_constraint,
	index_constraint;

range_constraint = rrange range;

range =
	simple_expression,
	simple_expression dotdot simple_expression;
#        attribute,
	simple_expression dotdot simple_expression;
(attribute is covered in simple_expression)
#
=TEX

=GFT SID
# ALRM 3.5.1 #
enumeration_type_definition = ord identifier_list crd;
=TEX

=GFT SID
# ALRM 3.5.4 #
integer_type_definition = range_constraint;
=TEX

=GFT SID
# ALRM 3.5.6 #
real_type_definition =
	floating_point_constraint,
	fixed_point_constraint;
=TEX

=GFT SID
# ALRM 3.5.7 #
floating_point_constraint =
	floating_accuracy_definition,
	floating_accuracy_definition range_constraint;

floating_accuracy_definition = digits simple_expression;
=TEX

=GFT SID
# ALRM 3.5.9 #
fixed_point_constraint =
	fixed_accuracy_definition,
	fixed_accuracy_definition range_constraint;

fixed_accuracy_definition = delta simple_expression;
=TEX

=GFT SID
# ALRM 3.6 #
array_type_definition =
	unconstrained_array_definition,
	constrained_array_definition;

unconstrained_array_definition =
	array ord index_subtype_definition_list crd of type_mark;

constrained_array_definition =
	array index_constraint of type_mark;

index_subtype_definition_list = index_subtype_definition subtype_list;

subtype_list =
	$,
	comma index_subtype_definition_list;

index_subtype_definition = type_mark rrange lessgreat;

index_constraint = ord discrete_range_list crd;

discrete_range_list = discrete_range disc_ran_list;

disc_ran_list = $,
		  comma, discrete_range_list;

discrete_range =
	type_mark,
	type_mark range_constraint,
	range;
=TEX

=GFT SID
# ALRM 3.7 #
record_type_definition = record component_list end record;

component_list = component_declaration,
		 component_declaration component_list;

component_declaration = identifier_list colon subtype_indication semi;
=TEX

=GFT SID
# ALRM 3.9 #
declarative_part = dec dp1;

dp1 = $, dec dp1;

dec = 
	k_slot,
	renaming_declaration,
	basic_declarative_item,
	package_declaration,
	body;

# differs from SPARK syntax to have at least one dec and
decs and bodies in any order; sort the order out semantically #

basic_declarative_item = basic_declaration,
			 representation_clause;
body =
	proper_body,
	body_stub;

proper_body = 
	subprogram_body,
	pbody_kslot;
=TEX

=GFT SID
# ALRM 4.1 #
name =
#        simple_name,
	indexed_component,
	selected_component;
#
	simple_name select;

select = 
	$,
	dot simple_name select,
	ord exp_list crd select;

simple_name = identifier;

prefix =
	name,
	function_call;
=TEX

=GFT SID
# ALRM 4.1.1 #
# indexed_component = prefix ord expression_list crd;
#
expression_list = expression exp_list;

exp_list =
	$,
	comma expression_list;
#
=TEX

=GFT SID
# ALRM 4.1.3 #
selected_component = prefix dot selector;

selector = simple_name;
#
=TEX

=GFT SID
# ALRM 4.1.4 #
attribute =
	prefix prime attribute_designator,
	character_literal prime attribute_designator;

attribute_designator = namexp namexp_list;

namexp_list = 
	$,
	prime attribute_designator;

namexp =
	simple_name,
	simple_name ord expression crd;
=TEX

=GFT SID
# ALRM 4.3 #
aggregate =
	ord component_association crd,
	ord component_association commaothers goesto expression crd,
	ord others goesto expression crd;

component_association =
	na named_association, #na lookahead symbol for goesto #
	positional_association;

named_association =
	aggregate_choice_list goesto expression ass_list;

ass_list = 
	$,
	comma named_association;

aggregate_choice_list = aggregate_choice ag_list;

ag_list =
	$,
	bar aggregate_choice_list;

aggregate_choice = 
	# simple_expression, (in discrete range) #
	discrete_range;
	#simple_name; (in simple_expression) #

positional_association = expression_list;
=TEX

=GFT SID
# ALRM 4.4 #
expression = relation reltail;

reltail =
	$,
	and_relation,
	and_then_relation,
	or_relation,
	or_else_relation,
	xor_relation;

and_relation =
	and relation,
	and relation and_relation;

and_then_relation =
	and then relation,
	and then relation and_then_relation;

or_relation =
	or relation,
	or relation or_relation;

or_else_relation =
	or else relation,
	or else relation or_else_relation;

xor_relation =
	xor relation,
	xor relation xor_relation;

relation = simple_expression rel2;

rel2 =
	$,
	relational_operator simple_expression,
	in range,
	not in range,
	in type_mark,
	not in type_mark;

simple_expression =
	term binoptail,
	unary_adding_operator term binoptail;

binoptail =
	$,
	binary_adding_operator term binoptail;

term = factor multoptail;

multoptail =
	$,
	multiplying_operator factor;

factor =
	primary,
	primary starstar primary,
	abs primary,
	not primary;

primary =
	numeric_literal,
	character_literal,
	string_literal,
	name,
	function_call,
	type_conversion,
	qualified_expression,
	attribute,
	ord expression crd,
	auxiliary_expression,
	aggregate;      # aggregate added as a primary to allow #
			#  2-dimensional array aggregates #
=TEX

=GFT SID
# ALRM 4.5 #
relational_operator =
	equals,
	notequals,
	lessthan,
	lessequals,
	greaterthan,
	greaterequals;

binary_adding_operator =
	plus,
	minus,
	ampersand;

unary_adding_operator =
	plus,
	minus;

multiplying_operator =
	star,
	div,
	mod,
	rem;
=TEX

=GFT SID
# ALRM 4.6 #
type_conversion = type_mark ord expression crd;
=TEX

=GFT SID
# ALRM 4.7 #
qualified_expression =
	#type_mark prime ord expression crd
	    - (treat as special case of aggregate) #
	type_mark prime aggregate;
=TEX

=GFT SID
# ALRM 5.1 #
sequence_of_statements = statement statement_list;

statement_list =
	$,
	sequence_of_statements;

z_decls = z_decl, z_decl semi z_decls;

statement =
	k_slot,
	specification_statement,
	con z_decls fatdot specification_statement,
	simple_statement,
	compound_statement,
	pragma;

simple_statement =
	null_statement,
	assignment_statement,
	procedure_call_statement,
	exit_statement,
	return_statement;

compound_statement =
	if_statement,
	case_statement,
	loop_statement;

null_statement = null semi;
=TEX

=GFT SID
# ALRM 5.2 #
assignment_statement = name becomes expression semi;
=TEX

=GFT SID
# ALRM 5.3 #
if_statement =
      if condition then sequence_of_statements elsif_part else_part end if semi;

elsif_part =
	$,
	elsif condition then sequence_of_statements elsif_part;

else_part =
	$,
	else sequence_of_statements;

condition = expression;
=TEX

=GFT SID
# ALRM 5.4 #
case_statement =
	case expression is case_statement_alternative_list others_part
	end case semi;

case_statement_alternative_list =
	case_statement_alternative,
	case_statement_alternative case_statement_alternative_list;

case_statement_alternative =
	when case_choice_list goesto sequence_of_statements;

case_choice_list =
	case_choice,
	case_choice bar case_choice_list;

case_choice =
	# simple_expression, (in discrete_range) #
	discrete_range;

others_part =
	$,
	whenothers goesto sequence_of_statements;
=TEX

=GFT SID
# ALRM 5.5 #
loop_statement =
	name_opt1 iteration_scheme_opt till_opt loop sequence_of_statements
	end loop name_opt2 semi;

name_opt1 =
	$,
	simple_name colon;

name_opt2 =
	$,
	simple_name;

iteration_scheme_opt =
	$,
	iteration_scheme;

iteration_scheme =
	while condition,
	for loop_parameter_specification;

loop_parameter_specification =
	identifier in type_mark,
	identifier in reverse type_mark,
	identifier in type_mark rrange range,
	identifier in reverse type_mark rrange range
	identifier in range,
	identifier in reverse range;

till_opt =
	$,
	till z_pred;
=TEX

=GFT SID
# ALRM 5.7 #
exit_statement =
	exit semi,
	exit when condition semi;
=TEX

=GFT SID
# ALRM 5.8 #
return_statement = return expression semi;
=TEX

=GFT SID
# ALRM 6.1 #
subprogram_declaration =
	procedure_specification semi,
	function_specification semi;

# subprogram_specification removed as it was only used in #
# renaming_declaration which now does not use it #

# subprogram_specification = #
#         procedure_specification, #
#         function_specification; #

procedure_specification =
	procedure identifier,
	procedure identifier procedure_specification_statement,
	procedure identifier formal_part,
	procedure identifier formal_part procedure_specification_statement;

function_specification =
	function designator return type_mark,
	function designator return type_mark function_specification_statement,
	function designator formal_part return type_mark,
	function designator formal_part return type_mark
	function_specification_statement;

designator = identifier;

operator_symbol = string_literal;

formal_part = ord parlist crd;

parlist =
	parameter_specification,
	parameter_specification semi parlist;

parameter_specification = identifier_list colon mode type_mark;

mode = $, in, out, in out;
=TEX

=GFT SID
# ALRM 6.3 #
subprogram_body =
	procedure_specification is subprogram_implementation,
	function_specification is subprogram_implementation;

subprogram_implementation = 
	declarative_part begin sequence_of_statements end designator semi;
=TEX

=GFT SID
# ALRM 6.4 #
procedure_call_statement =
	procedure_name semi,
	procedure_name actual_parameter_part semi;

function_call =
	function_name,
	function_name actual_parameter_part;

actual_parameter_part = ord parameter_association crd;

parameter_association =
	named_parameter_association,
	positional_parameter_association;

named_parameter_association =
	formal_parameter goesto actual_parameter,
	formal_parameter goesto actual_parameter comma 
	named_parameter_association;

positional_parameter_association =
	actual_parameter,
	actual_parameter comma positional_parameter_association;

formal_parameter = simple_name;

actual_parameter = expression;
# name is part of expression #
=TEX

=GFT SID
# ALRM 7.1 #
package_declaration = package_specification semi;

package_specification =
	package identifier is visible_part end simple_name,
	package identifier is visible_part private private_part end simple_name;

visible_part =
	$,
	visdec visible_part;

visdec = k_slot,
	 basic_declarative_item,
	 subprogram_declaration,
	 auxiliary z_decl semi,
	 renaming_declaration;

private_part =
	pdec,
	pdec private_part;

pdec =
	k_slot,
	basic_declarative_item,
	renaming_declaration;

package_body =
	package bbody simple_name is package_implementation end simple_name 
	semi;

package_implementation =
	declarative_part,
	declarative_part begin package_initialization,
	using_list declarative_part_1 begin package_initialization;

using_list =
	using_dec,
	using_dec using_list;

using_dec = using basic_dec_list implement z_id by z_pred semi;

basic_dec_list =
	basic_dec,
	basic_dec basic_dec_list;

basic_dec =
	constant_declaration,
	variable_declaration,
	type_declaration,
	subtype_declaration,
	pragma;

declarative_part_1 = dec_1, dec_1 declarative_part_1;

dec_1 =
	renaming_declaration,
	basic_declarative_item,
	package_declaration,
	body;

package_initialization = sequence_of_statements;
=TEX

=GFT SID
# ALRM 7.4 #
private_type_declaration =
	type identifier is private semi,
	type identifier is limited private semi;

deferred_constant_declaration = identifier_list colon constant type_mark semi;
=TEX

=GFT SID
# ALRM 8.5 #
renaming_declaration =
	function operator_symbol formal_part return type_mark renames 
	simple_name dot operator_symbol semi,
	procedure_specification_1 renames simple_name dot simple_name semi,
	function_specification_1 renames simple_name dot simple_name semi;

procedure_specification_1 =
	procedure identifier,
	procedure identifier formal_part;

function_specification_1 =
	function designator return type_mark,
	function designator formal_part return type_mark;
=TEX

=GFT SID
# ALRM 10.1 #
compilation =
	k_slot,
	compilation_unit,
	compilation_unit compilation;

compilation_unit =
	context_clause pragma_list library_unit,
	context_clause pragma_list secondary_unit,
	pragma;

pragma_list = $,
	      pragma pragma_list;

library_unit =
	package_declaration,
	main_program;

secondary_unit = library_unit_body, subunit;

library_unit_body = package_body;

main_program = subprogram_body;
=TEX

=GFT SID
# ALRM 10.1.1 #
context_clause = $,
		 with_clause context_clause,
		 references_clause context_clause;

references_clause = references simple_name_list semi;

with_clause = with simple_name_list semi;

simple_name_list =
	simple_name,
	simple_name comma simple_name_list;
=TEX

=GFT SID
# ALRM 10.2 #
body_stub = 
	procedure_specification is separate semi,
	function_specification is separate semi,
	package bbody simple_name is separate semi,
	procedure_specification semi,
	function_specification semi;

subunit = 
	 separate ord name crd proper_body,
	 separate ord name crd package_body;
=TEX

=GFT SID
# ALRM 13.1 #
representation_clause = type_representation_clause, address_clause;

type_representation_clause =
	length_clause,
	enumeration_representation_clause,
	record_representation_clause;
=TEX

=GFT SID
# ALRM 13.2 #
length_clause = for attribute use simple_expression semi;
=TEX

=GFT SID
# ALRM 13.3 #
enumeration_representation_clause = for simple_name use aggregate semi;
=TEX

=GFT SID
# ALRM 13.4 #
record_representation_clause =
	for simple_name use record alignment_opt component_pack end record semi;

alignment_opt = $, at mod simple_expression semi;

component_pack =
	component_clause,
	component_clause component_pack;

component_clause = name at simple_expression rrange range semi;
=TEX

=GFT SID
# ALRM 13.5 #
address_clause = for simple_name use at simple_expression semi;
=TEX

=GFT SID
any_label =
	comp_label,
	ppart_label,
	vpart_label,
	dec_label,
	stmt_label,
	spec_label;
=TEX

=GFT SID
web_clause =
	z,
	compilation,
	comp_label replacedby compilation,
	ppart_label replacedby private_part,
	vpart_label replacedby visible_part,
	dec_label replacedby dec dp1,
	stmt_label replacedby sequence_of_statements,
	spec_label refinedby sequence_of_statements,
	refinedby sequence_of_statements,
	spec_label replacedby sequence_of_statements,
	replacedby sequence_of_statements,
	any_label arbitrary_ada, 

	# the basic symbol arbitrary_ada includes the #
	# arbitrary replacedby symbol #

	arbitrary_ada,
	ord name crd replacedby package_body;
=TEX

=GFT SID
lit_script = web_clause, web_clause lit_script;
=TEX
} %%%% end of special set up for SID syntax
\section{SPARK toolkit}

\subsection{Overview}
\bpar{
This appendix contains an extension to the Z toolkit required for
the translation of SPARK to Z. For example, unlike SPARK, Z does not contain an
explicit Boolean type; a model of the Booleans is therefore in this
extension together with a model of their associated operators.
}\epar

\bpar{
The SPARK toolkit depends on the {\ProductZ} library and on
the {\ProductZ} theory of real numbers. However, the latter
is incompatible with the use of the global variable ``real''
as a constructor of the type EXP in volume 3.
We give the {\Product} commands to set up an appropriate
theory for type-checking the SPARK toolkit.
}\epar
=SML
open_theory "z_library";
new_theory"SPARK_toolkit";
new_parent"z_reals";
=TEX
\subsection{Booleans}

%\HOLindexOff

=SPCTZ FALSE
=TEX

=SPCTZ TRUE
=TEX

=SPCTZ BOOLEAN
=TEX

=SPCTZ BOOLEANvFIRST
=TEX

=SPCTZ BOOLEANvLAST
=TEX

=SPCTZ BOOLEANvSUCC
=TEX

=SPCTZ BOOLEANvPRED
=TEX

=SPCTZ BOOLEANvPOS
=TEX

=SPCTZ BOOLEANvVAL
=TEX

\subsection{Boolean Operators}

% In the following we need to avoid picking up two copies
% of the axiomatic description. But the unary operator
% has a separate fixity paragraph from the binary ones and
% we need that. The following picks out the fixity paragraph:
=TEXSH
	extract_z_para not <tktidx.zed | sed -n -e '1,3p'
=SPCTZ and
=TEX

=SPCTZ and_then
=TEX



\subsection{Relational operators returning Booleans}


=SPCTZ mem
=TEX

% As with "not" above the following picks out the fixity paragraph
% for array_not.
=TEXSH
	extract_z_para array_not <tktidx.zed | sed -n -e '1,3p'
=SPCTZ array_and
=TEX

=SPCTZ less
=TEX

=SPCTZ real_less
=TEX

=SPCTZ array_less
=TEX

\subsection{Numeric Operators}

=SPCTZ intdiv
=TEX

=SPCTZ !STAR!!STAR!
=TEX

=SPCTZ e
=TEX

=SPCTZ integer_to_real
=TEX

=SPCTZ real_to_integer
=TEX

\subsection{Predefined Numeric Types}

=SPCTZ INTEGER
=TEX

=SPCTZ INTEGERvFIRST
=TEX

=SPCTZ NATURAL
=TEX

=SPCTZ NATURALvFIRST
=TEX

=SPCTZ NATURALvLAST
=TEX

=SPCTZ NATURALvSUCC
=TEX

=SPCTZ NATURALvPRED
=TEX

=SPCTZ NATURALvPOS
=TEX

=SPCTZ NATURALvVAL
=TEX

=SPCTZ POSITIVE
=TEX

=SPCTZ POSITIVEvFIRST
=TEX

=SPCTZ POSITIVEvLAST
=TEX

=SPCTZ POSITIVEvSUCC
=TEX

=SPCTZ POSITIVEvPRED
=TEX

=SPCTZ POSITIVEvPOS
=TEX

=SPCTZ POSITIVEvVAL
=TEX

=SPCTZ LONG_INTEGER
=TEX

=SPCTZ LONG_INTEGERvFIRST
=TEX


=SPCTZ SHORT_INTEGER
=TEX

=SPCTZ SHORT_INTEGERvFIRST
=TEX

=SPCTZ FLOAT
=TEX

=SPCTZ FLOATvFIRST
=TEX

=SPCTZ SHORT_FLOAT
=TEX

=SPCTZ SHORT_FLOATvFIRST
=TEX

=SPCTZ LONG_FLOAT
=TEX

=SPCTZ LONG_FLOATvFIRST
=TEX

=SPCTZ universal_discrete
=TEX
=SPCTZ universal_discretevFIRST
=TEX

\subsection{Characters and strings}

=SPCTZ CHARACTERvFIRST
=TEX

=SPCTZ CHARACTERvLAST
=TEX

=SPCTZ CHARACTER
=TEX

=SPCTZ CHARACTERvSUCC
=TEX

=SPCTZ CHARACTERvPRED
=TEX

=SPCTZ CHARACTERvPOS
=TEX

=SPCTZ CHARACTERvVAL
=TEX

=SPCTZ STRING
=TEX

=SPCTZ Z_CHAR
=TEX

=SPCTZ Z_STRING
=TEX

\bpar*{
The sets {\it Z\_CHAR} and {\it Z\_STRING} are intended to be sets
that are convenient for the representation in Z of SPARK string and character literals
(see appendix C). The following functions are used to convert these into the types
required by the translation of SPARK into Z.
}\epar*


% We only want the fixity and signature part of the definitions
% of char_lit and string_lit:
=TEXSH
	extract_z_para char_lit <tktidx.zed | sed -n -e '1,5p' -e '$p'
=TEX
=TEXSH
	extract_z_para string_lit <tktidx.zed | sed -n -e '1,5p' -e '$p'
=TEX


\subsection{Informal Functions}

=SPCTZ INFORMAL_FUNCTION
=TEX

\subsection{Support for Arrays}

=SPCTZ !AMPERSAND!‰0
=TEX
 [ X1, X2, X ]œœœœœœœœœœœ
Ü Ûarray_agg2Ý : (X1 ­ X2 ­ X) ­ ( X1 ¸ X2 ­ X)
÷üüüüüü
Ü µf : X1 ­ X2 ­ X; x1 : X1; x2 : X2·
Ü	array_agg2 f (x1, x2) = f x1 x2
ˆüüüüüüüüüüüüüü
 [ X1, X2, X3, X ]œœœœœœœœœœœ
Ü Ûarray_agg3Ý : (X1 ­ X2 ­ X3 ­ X) ­ ( X1 ¸ X2 ¸ X3 ­ X)
÷üüüüüü
Ü µf : X1 ­ X2 ­ X3 ­ X; x1 : X1; x2 : X2; x3 : X3·
Ü	array_agg3 f (x1, x2, x3) = f x1 x2 x3
ˆüüüüüüüüüüüüüü
 [ X1, X2, X3, X4, X ]œœœœœœœœœœœ
Ü Ûarray_agg4Ý : (X1 ­ X2 ­ X3 ­ X4 ­ X) ­ ( X1 ¸ X2 ¸ X3 ¸ X4 ­ X)
÷üüüüüü
Ü µf : X1 ­ X2 ­ X3 ­ X4 ­ X; x1 : X1; x2 : X2; x3 : X3; x4 : X4·
Ü	array_agg4 f (x1, x2, x3, x4) = f x1 x2 x3 x4
ˆüüüüüüüüüüüüüü

\bpar*{
\ldots~(additional functions to support array aggregates of up to a minimum of 20 dimensions are to
be provided).
}\epar*

=SPCTZ slide
=TEX

%\HOLindexOn

\section{Z Toolkit Dependencies}

\subsection{Overview}
\bpar{
The translation of SPARK to Z requires the underlying Z tool
to provide support for characters, strings and real numbers.
This is not specific to SPARK and is not considered to be part of the SPARK toolkit.
As the features required are not in the draft Z standard, they
are briefly described here.
}\epar

\bpar{
We give the {\Product} commands to set up an appropriate
theory for type-checking the Z toolkit dependencies.
}\epar

\Hide{
=SML
set_flag("z_type_check_only", true);
=TEX
}
=SML
open_theory "z_library";
new_theory"Z_toolkit_dependencies";
=TEX

\subsection{Characters and Strings}

\bpar{
Characters in SPARK are represented in Z as integers and strings
are represented as sequences of integers. The translation of SPARK character
and string literals into Z is not formally defined in this specification.
A possible formal definition of the sets {\it Z\_CHAR} and {\it Z\_STRING} used
in appendix B might be as follows using a given set {\it CHAR} to represent
individual characters and using string literals in Z that denote sequences
of characters for both SPARK character literals and SPARK string literals:
}\epar



¹Z
Ü [ CHAR ]
°
¹Z
Ü Z_STRING ¦ seq CHAR
°
¹Z
Ü Z_CHAR ¦ {s : CHAR · §s¢}
°


\subsection{Real Numbers}

\bpar{
The translation of SPARK into Z depends on a type of real numbers in Z.
This must be distinct from the type of integers.
}\epar


¹Z
Ü [¯]
°
\bpar{
The arithmetic operators used are: unary minus; absolute value; addition; subtraction; multiplication;
division of one real by another; division of one integer by another to 
return a real; exponentiation (with integer exponents); the operation
that returns the closed interval defined by two end-points; and, conversion
of an integer to a real.
The fixity and signatures of these operators are as follows:
}\epar


¹Z
fun 2 _ ..‰R _
°

¹Z
fun 3 _ +‰R _, _ -‰R _
°

¹Z
fun 4 _ *‰R _, _ /‰R _, _ /‰Z _
°

¹Z
fun 5 ~‰R _
°
¹Z
fun 5 abs‰R _
°

¹Z
fun 6 _ ^‰Z _
°


¹ZAX
Ü ~‰R_  : ¯ ­ ¯;
Ü abs‰R_ : ¯ ­ ¯;
Ü _+‰R_ : ¯ ¸ ¯ ­ ¯;
Ü _-‰R_ : ¯ ¸ ¯ ­ ¯;
Ü _*‰R_ : ¯ ¸ ¯ ­ ¯;
Ü _/‰R_ : ¯ ¸ ¯ ß ¯;
Ü _/‰Z_ : ú ¸ ú ß ¯;
Ü _^‰Z_ : ¯ ¸ ú ­ ¯;
Ü _..‰R_: ¯ ¸ ¯ ­ ð¯;
Ü real : ú ­ ¯
°


\bpar{
The arithmetic relations used 
are less-than, greater-than, less-than-or-equals
and greater-than-or-equals with signatures as follows:
}\epar


¹Z
rel _ <‰R _, _ ¼‰R _, _ ¾‰R _, _ >‰R _
°

¹ZAX
Ü _<‰R_ : ¯ ª ¯;
Ü _>‰R_ : ¯ ª ¯;
Ü _¼‰R_ : ¯ ª ¯;
Ü _¾‰R_ : ¯ ª ¯
°



\startpost

\small
\twocolumn[\section*{Index of identifiers}]
\printindex

\onecolumn

\thispagestyle{dera}

\end{document}
=WARNING_EDIT_WITH_CARE spc501.src
